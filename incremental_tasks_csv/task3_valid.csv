cve_id,cwe_ids,cvss_vector,cvss_is_v3,repo_name,commit_msg,commit_hash,git_url,file_path,func_name,func_before,abstract_func_before,func_graph_path_before,func,abstract_func,func_graph_path,diff_func,diff_line_info,is_vul,description,Base Score,Base Severity,severity,source,commit_time,task
CVE-2019-17547,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ImageMagick,...,ecf7c6b288e11e7e7f75387c5e9e93e423b98397,https://github.com/ImageMagick/ImageMagick/commit/ecf7c6b288e11e7e7f75387c5e9e93e423b98397,MagickCore/draw.c,TraceBezier,"static MagickBooleanType TraceBezier(MVGInfo *mvg_info,
const size_t number_coordinates)
{
double
alpha,
*coefficients,
weight;
PointInfo
end,
point,
*points;
PrimitiveInfo
*primitive_info;
register PrimitiveInfo
*p;
register ssize_t
i,
j;
size_t
control_points,
quantum;
primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;
quantum=number_coordinates;
for (i=0; i < (ssize_t) number_coordinates; i++)
{
for (j=i+1; j < (ssize_t) number_coordinates; j++)
{
alpha=fabs(primitive_info[j].point.x-primitive_info[i].point.x);
if (alpha > (double) SSIZE_MAX)
{
(void) ThrowMagickException(mvg_info->exception,GetMagickModule(),
ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
return(MagickFalse);
}
if (alpha > (double) quantum)
quantum=(size_t) alpha;
alpha=fabs(primitive_info[j].point.y-primitive_info[i].point.y);
if (alpha > (double) SSIZE_MAX)
{
(void) ThrowMagickException(mvg_info->exception,GetMagickModule(),
ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
return(MagickFalse);
}
if (alpha > (double) quantum)
quantum=(size_t) alpha;
}
}
quantum=MagickMin(quantum/number_coordinates,BezierQuantum);
primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;
coefficients=(double *) AcquireQuantumMemory(number_coordinates,
sizeof(*coefficients));
points=(PointInfo *) AcquireQuantumMemory(quantum,number_coordinates*
sizeof(*points));
if ((coefficients == (double *) NULL) || (points == (PointInfo *) NULL))
{
if (points != (PointInfo *) NULL)
points=(PointInfo *) RelinquishMagickMemory(points);
if (coefficients != (double *) NULL)
coefficients=(double *) RelinquishMagickMemory(coefficients);
(void) ThrowMagickException(mvg_info->exception,GetMagickModule(),
ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
return(MagickFalse);
}
control_points=quantum*number_coordinates;
if (CheckPrimitiveExtent(mvg_info,control_points+1) == MagickFalse)
{
points=(PointInfo *) RelinquishMagickMemory(points);
coefficients=(double *) RelinquishMagickMemory(coefficients);
return(MagickFalse);
}
end=primitive_info[number_coordinates-1].point;
for (i=0; i < (ssize_t) number_coordinates; i++)
coefficients[i]=Permutate((ssize_t) number_coordinates-1,i);
weight=0.0;
for (i=0; i < (ssize_t) control_points; i++)
{
p=primitive_info;
point.x=0.0;
point.y=0.0;
alpha=pow((double) (1.0-weight),(double) number_coordinates-1.0);
for (j=0; j < (ssize_t) number_coordinates; j++)
{
point.x+=alpha*coefficients[j]*p->point.x;
point.y+=alpha*coefficients[j]*p->point.y;
alpha*=weight/(1.0-weight);
p++;
}
points[i]=point;
weight+=1.0/control_points;
}
p=primitive_info;
for (i=0; i < (ssize_t) control_points; i++)
{
if (TracePoint(p,points[i]) == MagickFalse)
{
points=(PointInfo *) RelinquishMagickMemory(points);
coefficients=(double *) RelinquishMagickMemory(coefficients);
return(MagickFalse);
}
p+=p->coordinates;
}
if (TracePoint(p,end) == MagickFalse)
{
points=(PointInfo *) RelinquishMagickMemory(points);
coefficients=(double *) RelinquishMagickMemory(coefficients);
return(MagickFalse);
}
p+=p->coordinates;
primitive_info->coordinates=(size_t) (p-primitive_info);
primitive_info->closed_subpath=MagickFalse;
for (i=0; i < (ssize_t) primitive_info->coordinates; i++)
{
p->primitive=primitive_info->primitive;
p--;
}
points=(PointInfo *) RelinquishMagickMemory(points);
coefficients=(double *) RelinquishMagickMemory(coefficients);
return(MagickTrue);
}","static MagickBooleanType TraceBezier(MVGInfo *VAR_0,
const size_t VAR_1)
{
double
VAR_2,
*VAR_3,
VAR_4;
PointInfo
VAR_5,
VAR_6,
*VAR_7;
PrimitiveInfo
*VAR_8;
register PrimitiveInfo
*VAR_9;
register ssize_t
VAR_10,
VAR_11;
size_t
VAR_12,
VAR_13;
VAR_8=(*VAR_0->primitive_info)+VAR_0->offset;
VAR_13=VAR_1;
for (VAR_10=0; VAR_10 < (ssize_t) VAR_1; VAR_10++)
{
for (VAR_11=VAR_10+1; VAR_11 < (ssize_t) VAR_1; VAR_11++)
{
VAR_2=fabs(VAR_8[VAR_11].point.x-VAR_8[VAR_10].point.x);
if (VAR_2 > (double) VAR_14)
{
(void) ThrowMagickException(VAR_0->exception,GetMagickModule(),
VAR_15,""MemoryAllocationFailed"",""`%s'"","""");
return(VAR_16);
}
if (VAR_2 > (double) VAR_13)
VAR_13=(size_t) VAR_2;
VAR_2=fabs(VAR_8[VAR_11].point.y-VAR_8[VAR_10].point.y);
if (VAR_2 > (double) VAR_14)
{
(void) ThrowMagickException(VAR_0->exception,GetMagickModule(),
VAR_15,""MemoryAllocationFailed"",""`%s'"","""");
return(VAR_16);
}
if (VAR_2 > (double) VAR_13)
VAR_13=(size_t) VAR_2;
}
}
VAR_13=MagickMin(VAR_13/VAR_1,VAR_17);
VAR_8=(*VAR_0->primitive_info)+VAR_0->offset;
VAR_3=(double *) AcquireQuantumMemory(VAR_1,
sizeof(*VAR_3));
VAR_7=(PointInfo *) AcquireQuantumMemory(VAR_13,VAR_1*
sizeof(*VAR_7));
if ((VAR_3 == (double *) NULL) || (VAR_7 == (PointInfo *) NULL))
{
if (VAR_7 != (PointInfo *) NULL)
VAR_7=(PointInfo *) RelinquishMagickMemory(VAR_7);
if (VAR_3 != (double *) NULL)
VAR_3=(double *) RelinquishMagickMemory(VAR_3);
(void) ThrowMagickException(VAR_0->exception,GetMagickModule(),
VAR_15,""MemoryAllocationFailed"",""`%s'"","""");
return(VAR_16);
}
VAR_12=VAR_13*VAR_1;
if (CheckPrimitiveExtent(VAR_0,VAR_12+1) == VAR_16)
{
VAR_7=(PointInfo *) RelinquishMagickMemory(VAR_7);
VAR_3=(double *) RelinquishMagickMemory(VAR_3);
return(VAR_16);
}
VAR_5=VAR_8[VAR_1-1].point;
for (VAR_10=0; VAR_10 < (ssize_t) VAR_1; VAR_10++)
VAR_3[VAR_10]=Permutate((ssize_t) VAR_1-1,VAR_10);
VAR_4=0.0;
for (VAR_10=0; VAR_10 < (ssize_t) VAR_12; VAR_10++)
{
VAR_9=VAR_8;
VAR_6.x=0.0;
VAR_6.y=0.0;
VAR_2=pow((double) (1.0-VAR_4),(double) VAR_1-1.0);
for (VAR_11=0; VAR_11 < (ssize_t) VAR_1; VAR_11++)
{
VAR_6.x+=VAR_2*VAR_3[VAR_11]*VAR_9->point.x;
VAR_6.y+=VAR_2*VAR_3[VAR_11]*VAR_9->point.y;
VAR_2*=VAR_4/(1.0-VAR_4);
VAR_9++;
}
VAR_7[VAR_10]=VAR_6;
VAR_4+=1.0/VAR_12;
}
VAR_9=VAR_8;
for (VAR_10=0; VAR_10 < (ssize_t) VAR_12; VAR_10++)
{
if (TracePoint(VAR_9,VAR_7[VAR_10]) == VAR_16)
{
VAR_7=(PointInfo *) RelinquishMagickMemory(VAR_7);
VAR_3=(double *) RelinquishMagickMemory(VAR_3);
return(VAR_16);
}
VAR_9+=VAR_9->coordinates;
}
if (TracePoint(VAR_9,VAR_5) == VAR_16)
{
VAR_7=(PointInfo *) RelinquishMagickMemory(VAR_7);
VAR_3=(double *) RelinquishMagickMemory(VAR_3);
return(VAR_16);
}
VAR_9+=VAR_9->coordinates;
VAR_8->coordinates=(size_t) (VAR_9-VAR_8);
VAR_8->closed_subpath=VAR_16;
for (VAR_10=0; VAR_10 < (ssize_t) VAR_8->coordinates; VAR_10++)
{
VAR_9->primitive=VAR_8->primitive;
VAR_9--;
}
VAR_7=(PointInfo *) RelinquishMagickMemory(VAR_7);
VAR_3=(double *) RelinquishMagickMemory(VAR_3);
return(VAR_18);
}",ImageMagick/ecf7c6b288e11e7e7f75387c5e9e93e423b98397/draw.c/vul/before/0.json,"static MagickBooleanType TraceBezier(MVGInfo *mvg_info,
  const size_t number_coordinates)
{
  double
    alpha,
    *coefficients,
    weight;

  PointInfo
    end,
    point,
    *points;

  PrimitiveInfo
    *primitive_info;

  register PrimitiveInfo
    *p;

  register ssize_t
    i,
    j;

  size_t
    control_points,
    quantum;

  /*
    Allocate coefficients.
  */
  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;
  quantum=number_coordinates;
  for (i=0; i < (ssize_t) number_coordinates; i++)
  {
    for (j=i+1; j < (ssize_t) number_coordinates; j++)
    {
      alpha=fabs(primitive_info[j].point.x-primitive_info[i].point.x);
      if (alpha > (double) SSIZE_MAX)
        {
          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),
            ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
          return(MagickFalse);
        }
      if (alpha > (double) quantum)
        quantum=(size_t) alpha;
      alpha=fabs(primitive_info[j].point.y-primitive_info[i].point.y);
      if (alpha > (double) SSIZE_MAX)
        {
          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),
            ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
          return(MagickFalse);
        }
      if (alpha > (double) quantum)
        quantum=(size_t) alpha;
    }
  }
  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;
  quantum=MagickMin(quantum/number_coordinates,BezierQuantum);
  coefficients=(double *) AcquireQuantumMemory(number_coordinates,
    sizeof(*coefficients));
  points=(PointInfo *) AcquireQuantumMemory(quantum,number_coordinates*
    sizeof(*points));
  if ((coefficients == (double *) NULL) || (points == (PointInfo *) NULL))
    {
      if (points != (PointInfo *) NULL)
        points=(PointInfo *) RelinquishMagickMemory(points);
      if (coefficients != (double *) NULL)
        coefficients=(double *) RelinquishMagickMemory(coefficients);
      (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),
        ResourceLimitError,""MemoryAllocationFailed"",""`%s'"","""");
      return(MagickFalse);
    }
  control_points=quantum*number_coordinates;
  if (CheckPrimitiveExtent(mvg_info,control_points+1) == MagickFalse)
    {
      points=(PointInfo *) RelinquishMagickMemory(points);
      coefficients=(double *) RelinquishMagickMemory(coefficients);
      return(MagickFalse);
    }
  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;
  /*
    Compute bezier points.
  */
  end=primitive_info[number_coordinates-1].point;
  for (i=0; i < (ssize_t) number_coordinates; i++)
    coefficients[i]=Permutate((ssize_t) number_coordinates-1,i);
  weight=0.0;
  for (i=0; i < (ssize_t) control_points; i++)
  {
    p=primitive_info;
    point.x=0.0;
    point.y=0.0;
    alpha=pow((double) (1.0-weight),(double) number_coordinates-1.0);
    for (j=0; j < (ssize_t) number_coordinates; j++)
    {
      point.x+=alpha*coefficients[j]*p->point.x;
      point.y+=alpha*coefficients[j]*p->point.y;
      alpha*=weight/(1.0-weight);
      p++;
    }
    points[i]=point;
    weight+=1.0/control_points;
  }
  /*
    Bezier curves are just short segmented polys.
  */
  p=primitive_info;
  for (i=0; i < (ssize_t) control_points; i++)
  {
    if (TracePoint(p,points[i]) == MagickFalse)
      {
        points=(PointInfo *) RelinquishMagickMemory(points);
        coefficients=(double *) RelinquishMagickMemory(coefficients);
        return(MagickFalse);
      }
    p+=p->coordinates;
  }
  if (TracePoint(p,end) == MagickFalse)
    {
      points=(PointInfo *) RelinquishMagickMemory(points);
      coefficients=(double *) RelinquishMagickMemory(coefficients);
      return(MagickFalse);
    }
  p+=p->coordinates;
  primitive_info->coordinates=(size_t) (p-primitive_info);
  primitive_info->closed_subpath=MagickFalse;
  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)
  {
    p->primitive=primitive_info->primitive;
    p--;
  }
  points=(PointInfo *) RelinquishMagickMemory(points);
  coefficients=(double *) RelinquishMagickMemory(coefficients);
  return(MagickTrue);
}","static MagickBooleanType TraceBezier(MVGInfo *VAR_0,
  const size_t VAR_1)
{
  double
    VAR_2,
    *VAR_3,
    VAR_4;

  PointInfo
    VAR_5,
    VAR_6,
    *VAR_7;

  PrimitiveInfo
    *VAR_8;

  register PrimitiveInfo
    *VAR_9;

  register ssize_t
    VAR_10,
    VAR_11;

  size_t
    VAR_12,
    VAR_13;

  /* COMMENT_0 */
                          
    
  VAR_8=(*VAR_0->primitive_info)+VAR_0->offset;
  VAR_13=VAR_1;
  for (VAR_10=0; VAR_10 < (ssize_t) VAR_1; VAR_10++)
  {
    for (VAR_11=VAR_10+1; VAR_11 < (ssize_t) VAR_1; VAR_11++)
    {
      VAR_2=fabs(VAR_8[VAR_11].point.x-VAR_8[VAR_10].point.x);
      if (VAR_2 > (double) VAR_14)
        {
          (void) ThrowMagickException(VAR_0->exception,GetMagickModule(),
            VAR_15,""MemoryAllocationFailed"",""`%s'"","""");
          return(VAR_16);
        }
      if (VAR_2 > (double) VAR_13)
        VAR_13=(size_t) VAR_2;
      VAR_2=fabs(VAR_8[VAR_11].point.y-VAR_8[VAR_10].point.y);
      if (VAR_2 > (double) VAR_14)
        {
          (void) ThrowMagickException(VAR_0->exception,GetMagickModule(),
            VAR_15,""MemoryAllocationFailed"",""`%s'"","""");
          return(VAR_16);
        }
      if (VAR_2 > (double) VAR_13)
        VAR_13=(size_t) VAR_2;
    }
  }
  VAR_8=(*VAR_0->primitive_info)+VAR_0->offset;
  VAR_13=MagickMin(VAR_13/VAR_1,VAR_17);
  VAR_3=(double *) AcquireQuantumMemory(VAR_1,
    sizeof(*VAR_3));
  VAR_7=(PointInfo *) AcquireQuantumMemory(VAR_13,VAR_1*
    sizeof(*VAR_7));
  if ((VAR_3 == (double *) NULL) || (VAR_7 == (PointInfo *) NULL))
    {
      if (VAR_7 != (PointInfo *) NULL)
        VAR_7=(PointInfo *) RelinquishMagickMemory(VAR_7);
      if (VAR_3 != (double *) NULL)
        VAR_3=(double *) RelinquishMagickMemory(VAR_3);
      (void) ThrowMagickException(VAR_0->exception,GetMagickModule(),
        VAR_15,""MemoryAllocationFailed"",""`%s'"","""");
      return(VAR_16);
    }
  VAR_12=VAR_13*VAR_1;
  if (CheckPrimitiveExtent(VAR_0,VAR_12+1) == VAR_16)
    {
      VAR_7=(PointInfo *) RelinquishMagickMemory(VAR_7);
      VAR_3=(double *) RelinquishMagickMemory(VAR_3);
      return(VAR_16);
    }
  VAR_8=(*VAR_0->primitive_info)+VAR_0->offset;
  /* COMMENT_3 */
                          
    
  VAR_5=VAR_8[VAR_1-1].point;
  for (VAR_10=0; VAR_10 < (ssize_t) VAR_1; VAR_10++)
    VAR_3[VAR_10]=Permutate((ssize_t) VAR_1-1,VAR_10);
  VAR_4=0.0;
  for (VAR_10=0; VAR_10 < (ssize_t) VAR_12; VAR_10++)
  {
    VAR_9=VAR_8;
    VAR_6.x=0.0;
    VAR_6.y=0.0;
    VAR_2=pow((double) (1.0-VAR_4),(double) VAR_1-1.0);
    for (VAR_11=0; VAR_11 < (ssize_t) VAR_1; VAR_11++)
    {
      VAR_6.x+=VAR_2*VAR_3[VAR_11]*VAR_9->point.x;
      VAR_6.y+=VAR_2*VAR_3[VAR_11]*VAR_9->point.y;
      VAR_2*=VAR_4/(1.0-VAR_4);
      VAR_9++;
    }
    VAR_7[VAR_10]=VAR_6;
    VAR_4+=1.0/VAR_12;
  }
  /* COMMENT_6 */
                                                 
    
  VAR_9=VAR_8;
  for (VAR_10=0; VAR_10 < (ssize_t) VAR_12; VAR_10++)
  {
    if (TracePoint(VAR_9,VAR_7[VAR_10]) == VAR_16)
      {
        VAR_7=(PointInfo *) RelinquishMagickMemory(VAR_7);
        VAR_3=(double *) RelinquishMagickMemory(VAR_3);
        return(VAR_16);
      }
    VAR_9+=VAR_9->coordinates;
  }
  if (TracePoint(VAR_9,VAR_5) == VAR_16)
    {
      VAR_7=(PointInfo *) RelinquishMagickMemory(VAR_7);
      VAR_3=(double *) RelinquishMagickMemory(VAR_3);
      return(VAR_16);
    }
  VAR_9+=VAR_9->coordinates;
  VAR_8->coordinates=(size_t) (VAR_9-VAR_8);
  VAR_8->closed_subpath=VAR_16;
  for (VAR_10=0; VAR_10 < (ssize_t) VAR_8->coordinates; VAR_10++)
  {
    VAR_9->primitive=VAR_8->primitive;
    VAR_9--;
  }
  VAR_7=(PointInfo *) RelinquishMagickMemory(VAR_7);
  VAR_3=(double *) RelinquishMagickMemory(VAR_3);
  return(VAR_18);
}",ImageMagick/ecf7c6b288e11e7e7f75387c5e9e93e423b98397/draw.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -54,8 +54,8 @@
         quantum=(size_t) alpha;
     }
   }
+  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;
   quantum=MagickMin(quantum/number_coordinates,BezierQuantum);
-  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;
   coefficients=(double *) AcquireQuantumMemory(number_coordinates,
     sizeof(*coefficients));
   points=(PointInfo *) AcquireQuantumMemory(quantum,number_coordinates*
@@ -77,6 +77,7 @@
       coefficients=(double *) RelinquishMagickMemory(coefficients);
       return(MagickFalse);
     }
+  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;
   /*
     Compute bezier points.
   */","{'deleted_lines': ['  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;'], 'added_lines': ['  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;', '  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;']}",True,"In ImageMagick before 7.0.8-62, TraceBezier in MagickCore/draw.c has a use-after-free.",8.8,HIGH,2,valid,2019-08-18T12:33:19Z,3
CVE-2018-20360,"['CWE-119', 'CWE-476']",AV:N/AC:M/Au:N/C:N/I:N/A:P,0,knik0/faad2,"specrec: better handle unexpected PS

Parametric Stereo (PS) can arrive at any moment in input files. PS
changes the number of output channels and therefore requires more
allocated memory in various structures from hDecoder.

The current faad2 code attempts to perform allocation surgery in
hDecoder to recover from this. This works well when there is only one
frame channel, else it creates large number of memory corruption
issues.

If there is more than one input channel, return cleanly with error
code. It would be nice to handle this, but this is likely to be a lot
of work and is beyond the scope of a security fix.

This commit addresses CVE-2018-20360 and CVE-2018-20199 (fixes #32,
fixes #24).",3b80a57483a6bc822d3ce3cc640fa81737a87c54,https://github.com/knik0/faad2/commit/3b80a57483a6bc822d3ce3cc640fa81737a87c54,libfaad/specrec.c,reconstruct_single_channel,"uint8_t reconstruct_single_channel(NeAACDecStruct *hDecoder, ic_stream *ics,
element *sce, int16_t *spec_data)
{
uint8_t retval;
int output_channels;
ALIGN real_t spec_coef[1024];
#ifdef PROFILE
int64_t count = faad_get_ts();
#endif
#if ( (defined(DRM) && defined(DRM_PS)) )
output_channels = 2;
#elif defined(PS_DEC)
if (hDecoder->ps_used[hDecoder->fr_ch_ele])
output_channels = 2;
else
output_channels = 1;
#else
output_channels = 1;
#endif
if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)
{
hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;
} else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != output_channels) {
hDecoder->element_alloced[hDecoder->fr_ch_ele] = 0;
hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;
}
if (hDecoder->element_alloced[hDecoder->fr_ch_ele] == 0)
{
retval = allocate_single_channel(hDecoder, sce->channel, output_channels);
if (retval > 0)
return retval;
hDecoder->element_alloced[hDecoder->fr_ch_ele] = 1;
}
retval = quant_to_spec(hDecoder, ics, spec_data, spec_coef, hDecoder->frameLength);
if (retval > 0)
return retval;
#ifdef PROFILE
count = faad_get_ts() - count;
hDecoder->requant_cycles += count;
#endif
pns_decode(ics, NULL, spec_coef, NULL, hDecoder->frameLength, 0, hDecoder->object_type,
&(hDecoder->__r1), &(hDecoder->__r2));
#ifdef MAIN_DEC
if (hDecoder->object_type == MAIN)
{
if (!hDecoder->pred_stat[sce->channel])
return 33;
ic_prediction(ics, spec_coef, hDecoder->pred_stat[sce->channel], hDecoder->frameLength,
hDecoder->sf_index);
pns_reset_pred_state(ics, hDecoder->pred_stat[sce->channel]);
}
#endif
#ifdef LTP_DEC
if (is_ltp_ot(hDecoder->object_type))
{
#ifdef LD_DEC
if (hDecoder->object_type == LD)
{
if (ics->ltp.data_present)
{
if (ics->ltp.lag_update)
hDecoder->ltp_lag[sce->channel] = ics->ltp.lag;
}
ics->ltp.lag = hDecoder->ltp_lag[sce->channel];
}
#endif
lt_prediction(ics, &(ics->ltp), spec_coef, hDecoder->lt_pred_stat[sce->channel], hDecoder->fb,
ics->window_shape, hDecoder->window_shape_prev[sce->channel],
hDecoder->sf_index, hDecoder->object_type, hDecoder->frameLength);
}
#endif
tns_decode_frame(ics, &(ics->tns), hDecoder->sf_index, hDecoder->object_type,
spec_coef, hDecoder->frameLength);
if (hDecoder->drc->present)
{
if (!hDecoder->drc->exclude_mask[sce->channel] || !hDecoder->drc->excluded_chns_present)
drc_decode(hDecoder->drc, spec_coef);
}
#ifdef SSR_DEC
if (hDecoder->object_type != SSR)
{
#endif
ifilter_bank(hDecoder->fb, ics->window_sequence, ics->window_shape,
hDecoder->window_shape_prev[sce->channel], spec_coef,
hDecoder->time_out[sce->channel], hDecoder->fb_intermed[sce->channel],
hDecoder->object_type, hDecoder->frameLength);
#ifdef SSR_DEC
} else {
ssr_decode(&(ics->ssr), hDecoder->fb, ics->window_sequence, ics->window_shape,
hDecoder->window_shape_prev[sce->channel], spec_coef, hDecoder->time_out[sce->channel],
hDecoder->ssr_overlap[sce->channel], hDecoder->ipqf_buffer[sce->channel], hDecoder->prev_fmd[sce->channel],
hDecoder->frameLength);
}
#endif
hDecoder->window_shape_prev[sce->channel] = ics->window_shape;
#ifdef LTP_DEC
if (is_ltp_ot(hDecoder->object_type))
{
lt_update_state(hDecoder->lt_pred_stat[sce->channel], hDecoder->time_out[sce->channel],
hDecoder->fb_intermed[sce->channel], hDecoder->frameLength, hDecoder->object_type);
}
#endif
#ifdef SBR_DEC
if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))
&& hDecoder->sbr_alloced[hDecoder->fr_ch_ele])
{
int ele = hDecoder->fr_ch_ele;
int ch = sce->channel;
if (hDecoder->sbr[ele] == NULL)
{
hDecoder->sbr[ele] = sbrDecodeInit(hDecoder->frameLength,
hDecoder->element_id[ele], 2*get_sample_rate(hDecoder->sf_index),
hDecoder->downSampledSBR
#ifdef DRM
, 0
#endif
);
}
if (sce->ics1.window_sequence == EIGHT_SHORT_SEQUENCE)
hDecoder->sbr[ele]->maxAACLine = 8*min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);
else
hDecoder->sbr[ele]->maxAACLine = min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);
#if (defined(PS_DEC) || defined(DRM_PS))
if (hDecoder->ps_used[ele] == 0)
{
#endif
retval = sbrDecodeSingleFrame(hDecoder->sbr[ele], hDecoder->time_out[ch],
hDecoder->postSeekResetFlag, hDecoder->downSampledSBR);
#if (defined(PS_DEC) || defined(DRM_PS))
} else {
retval = sbrDecodeSingleFramePS(hDecoder->sbr[ele], hDecoder->time_out[ch],
hDecoder->time_out[ch+1], hDecoder->postSeekResetFlag,
hDecoder->downSampledSBR);
}
#endif
if (retval > 0)
return retval;
} else if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))
&& !hDecoder->sbr_alloced[hDecoder->fr_ch_ele])
{
return 23;
}
#endif
#if (defined(PS_DEC) || defined(DRM_PS))
if ((hDecoder->ps_used[hDecoder->fr_ch_ele] == 0) &&
(hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2))
{
int ele = hDecoder->fr_ch_ele;
int ch = sce->channel;
int frame_size = (hDecoder->sbr_alloced[ele]) ? 2 : 1;
frame_size *= hDecoder->frameLength*sizeof(real_t);
memcpy(hDecoder->time_out[ch+1], hDecoder->time_out[ch], frame_size);
}
#endif
return 0;
}","uint8_t reconstruct_single_channel(NeAACDecStruct *VAR_0, ic_stream *VAR_1,
element *VAR_2, int16_t *VAR_3)
{
uint8_t VAR_4;
int VAR_5;
ALIGN VAR_6 VAR_7[1024];
#ifdef VAR_8
int64_t VAR_9 = faad_get_ts();
#endif
#if ( (defined(VAR_10) && defined(VAR_11)) )
VAR_5 = 2;
#elif defined(VAR_12)
if (VAR_0->ps_used[VAR_0->fr_ch_ele])
VAR_5 = 2;
else
VAR_5 = 1;
#else
VAR_5 = 1;
#endif
if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] == 0)
{
VAR_0->element_output_channels[VAR_0->fr_ch_ele] = VAR_5;
} else if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] != VAR_5) {
VAR_0->element_alloced[VAR_0->fr_ch_ele] = 0;
VAR_0->element_output_channels[VAR_0->fr_ch_ele] = VAR_5;
}
if (VAR_0->element_alloced[VAR_0->fr_ch_ele] == 0)
{
VAR_4 = allocate_single_channel(VAR_0, VAR_2->channel, VAR_5);
if (VAR_4 > 0)
return VAR_4;
VAR_0->element_alloced[VAR_0->fr_ch_ele] = 1;
}
VAR_4 = quant_to_spec(VAR_0, VAR_1, VAR_3, VAR_7, VAR_0->frameLength);
if (VAR_4 > 0)
return VAR_4;
#ifdef VAR_8
VAR_9 = faad_get_ts() - VAR_9;
VAR_0->requant_cycles += VAR_9;
#endif
pns_decode(VAR_1, NULL, VAR_7, NULL, VAR_0->frameLength, 0, VAR_0->object_type,
&(VAR_0->__r1), &(VAR_0->__r2));
#ifdef VAR_13
if (VAR_0->object_type == VAR_14)
{
if (!VAR_0->pred_stat[VAR_2->channel])
return 33;
ic_prediction(VAR_1, VAR_7, VAR_0->pred_stat[VAR_2->channel], VAR_0->frameLength,
VAR_0->sf_index);
pns_reset_pred_state(VAR_1, VAR_0->pred_stat[VAR_2->channel]);
}
#endif
#ifdef VAR_15
if (is_ltp_ot(VAR_0->object_type))
{
#ifdef VAR_16
if (VAR_0->object_type == VAR_17)
{
if (VAR_1->ltp.data_present)
{
if (VAR_1->ltp.lag_update)
VAR_0->ltp_lag[VAR_2->channel] = VAR_1->ltp.lag;
}
VAR_1->ltp.lag = VAR_0->ltp_lag[VAR_2->channel];
}
#endif
lt_prediction(VAR_1, &(VAR_1->ltp), VAR_7, VAR_0->lt_pred_stat[VAR_2->channel], VAR_0->fb,
VAR_1->window_shape, VAR_0->window_shape_prev[VAR_2->channel],
VAR_0->sf_index, VAR_0->object_type, VAR_0->frameLength);
}
#endif
tns_decode_frame(VAR_1, &(VAR_1->tns), VAR_0->sf_index, VAR_0->object_type,
VAR_7, VAR_0->frameLength);
if (VAR_0->drc->present)
{
if (!VAR_0->drc->exclude_mask[VAR_2->channel] || !VAR_0->drc->excluded_chns_present)
drc_decode(VAR_0->drc, VAR_7);
}
#ifdef VAR_18
if (VAR_0->object_type != VAR_19)
{
#endif
ifilter_bank(hDecoder->fb, ics->window_sequence, ics->window_shape,
VAR_0->window_shape_prev[VAR_2->channel], VAR_7,
VAR_0->time_out[VAR_2->channel], VAR_0->fb_intermed[VAR_2->channel],
VAR_0->object_type, VAR_0->frameLength);
#ifdef VAR_18
} else {
ssr_decode(&(VAR_1->ssr), VAR_0->fb, VAR_1->window_sequence, VAR_1->window_shape,
VAR_0->window_shape_prev[VAR_2->channel], VAR_7, VAR_0->time_out[VAR_2->channel],
VAR_0->ssr_overlap[VAR_2->channel], VAR_0->ipqf_buffer[VAR_2->channel], VAR_0->prev_fmd[VAR_2->channel],
VAR_0->frameLength);
}
#endif
VAR_0->window_shape_prev[VAR_2->channel] = VAR_1->window_shape;
#ifdef VAR_15
if (is_ltp_ot(VAR_0->object_type))
{
lt_update_state(VAR_0->lt_pred_stat[VAR_2->channel], VAR_0->time_out[VAR_2->channel],
VAR_0->fb_intermed[VAR_2->channel], VAR_0->frameLength, VAR_0->object_type);
}
#endif
#ifdef VAR_20
if (((VAR_0->sbr_present_flag == 1) || (VAR_0->forceUpSampling == 1))
&& VAR_0->sbr_alloced[VAR_0->fr_ch_ele])
{
int VAR_21 = VAR_0->fr_ch_ele;
int VAR_22 = VAR_2->channel;
if (VAR_0->sbr[VAR_21] == NULL)
{
VAR_0->sbr[VAR_21] = sbrDecodeInit(VAR_0->frameLength,
VAR_0->element_id[VAR_21], 2*get_sample_rate(VAR_0->sf_index),
VAR_0->downSampledSBR
#ifdef VAR_10
, 0
#endif
);
}
if (VAR_2->ics1.window_sequence == VAR_23)
VAR_0->sbr[VAR_21]->maxAACLine = 8*min(VAR_2->ics1.swb_offset[max(VAR_2->ics1.max_sfb-1, 0)], VAR_2->ics1.swb_offset_max);
else
VAR_0->sbr[VAR_21]->maxAACLine = min(VAR_2->ics1.swb_offset[max(VAR_2->ics1.max_sfb-1, 0)], VAR_2->ics1.swb_offset_max);
#if (defined(VAR_12) || defined(VAR_11))
if (VAR_0->ps_used[VAR_21] == 0)
{
#endif
retval = sbrDecodeSingleFrame(hDecoder->sbr[ele], hDecoder->time_out[ch],
VAR_0->postSeekResetFlag, VAR_0->downSampledSBR);
#if (defined(VAR_12) || defined(VAR_11))
} else {
VAR_4 = sbrDecodeSingleFramePS(VAR_0->sbr[VAR_21], VAR_0->time_out[VAR_22],
VAR_0->time_out[VAR_22+1], VAR_0->postSeekResetFlag,
VAR_0->downSampledSBR);
}
#endif
if (VAR_4 > 0)
return VAR_4;
} else if (((VAR_0->sbr_present_flag == 1) || (VAR_0->forceUpSampling == 1))
&& !VAR_0->sbr_alloced[VAR_0->fr_ch_ele])
{
return 23;
}
#endif
#if (defined(VAR_12) || defined(VAR_11))
if ((VAR_0->ps_used[VAR_0->fr_ch_ele] == 0) &&
(VAR_0->element_output_channels[VAR_0->fr_ch_ele] == 2))
{
int VAR_21 = VAR_0->fr_ch_ele;
int VAR_22 = VAR_2->channel;
int VAR_24 = (VAR_0->sbr_alloced[VAR_21]) ? 2 : 1;
VAR_24 *= VAR_0->frameLength*sizeof(VAR_6);
memcpy(VAR_0->time_out[VAR_22+1], VAR_0->time_out[VAR_22], VAR_24);
}
#endif
return 0;
}",knik0/faad2/3b80a57483a6bc822d3ce3cc640fa81737a87c54/specrec.c/vul/before/0.json,"uint8_t reconstruct_single_channel(NeAACDecStruct *hDecoder, ic_stream *ics,
                                   element *sce, int16_t *spec_data)
{
    uint8_t retval;
    int output_channels;
    ALIGN real_t spec_coef[1024];

#ifdef PROFILE
    int64_t count = faad_get_ts();
#endif


    /* always allocate 2 channels, PS can always ""suddenly"" turn up */
#if ( (defined(DRM) && defined(DRM_PS)) )
    output_channels = 2;
#elif defined(PS_DEC)
    if (hDecoder->ps_used[hDecoder->fr_ch_ele])
        output_channels = 2;
    else
        output_channels = 1;
#else
    output_channels = 1;
#endif

    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 0)
    {
        /* element_output_channels not set yet */
        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;
    } else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != output_channels) {
        /* element inconsistency
         * this only happens if PS is actually found but not in the first frame
         * this means that there is only 1 bitstream element!
         */

        if (hDecoder->fr_channels == 1) {
            /* reset the allocation */
            hDecoder->element_alloced[hDecoder->fr_ch_ele] = 0;
            hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;
        } else {
            return 21;
        }
    }

    if (hDecoder->element_alloced[hDecoder->fr_ch_ele] == 0)
    {
        retval = allocate_single_channel(hDecoder, sce->channel, output_channels);
        if (retval > 0)
            return retval;

        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 1;
    }


    /* dequantisation and scaling */
    retval = quant_to_spec(hDecoder, ics, spec_data, spec_coef, hDecoder->frameLength);
    if (retval > 0)
        return retval;

#ifdef PROFILE
    count = faad_get_ts() - count;
    hDecoder->requant_cycles += count;
#endif


    /* pns decoding */
    pns_decode(ics, NULL, spec_coef, NULL, hDecoder->frameLength, 0, hDecoder->object_type,
        &(hDecoder->__r1), &(hDecoder->__r2));

#ifdef MAIN_DEC
    /* MAIN object type prediction */
    if (hDecoder->object_type == MAIN)
    {
		if (!hDecoder->pred_stat[sce->channel])
			return 33;

        /* intra channel prediction */
        ic_prediction(ics, spec_coef, hDecoder->pred_stat[sce->channel], hDecoder->frameLength,
            hDecoder->sf_index);

        /* In addition, for scalefactor bands coded by perceptual
           noise substitution the predictors belonging to the
           corresponding spectral coefficients are reset.
        */
        pns_reset_pred_state(ics, hDecoder->pred_stat[sce->channel]);
    }
#endif

#ifdef LTP_DEC
    if (is_ltp_ot(hDecoder->object_type))
    {
#ifdef LD_DEC
        if (hDecoder->object_type == LD)
        {
            if (ics->ltp.data_present)
            {
                if (ics->ltp.lag_update)
                    hDecoder->ltp_lag[sce->channel] = ics->ltp.lag;
            }
            ics->ltp.lag = hDecoder->ltp_lag[sce->channel];
        }
#endif

        /* long term prediction */
        lt_prediction(ics, &(ics->ltp), spec_coef, hDecoder->lt_pred_stat[sce->channel], hDecoder->fb,
            ics->window_shape, hDecoder->window_shape_prev[sce->channel],
            hDecoder->sf_index, hDecoder->object_type, hDecoder->frameLength);
    }
#endif

    /* tns decoding */
    tns_decode_frame(ics, &(ics->tns), hDecoder->sf_index, hDecoder->object_type,
        spec_coef, hDecoder->frameLength);

    /* drc decoding */
    if (hDecoder->drc->present)
    {
        if (!hDecoder->drc->exclude_mask[sce->channel] || !hDecoder->drc->excluded_chns_present)
            drc_decode(hDecoder->drc, spec_coef);
    }

    /* filter bank */
#ifdef SSR_DEC
    if (hDecoder->object_type != SSR)
    {
#endif
        ifilter_bank(hDecoder->fb, ics->window_sequence, ics->window_shape,
            hDecoder->window_shape_prev[sce->channel], spec_coef,
            hDecoder->time_out[sce->channel], hDecoder->fb_intermed[sce->channel],
            hDecoder->object_type, hDecoder->frameLength);
#ifdef SSR_DEC
    } else {
        ssr_decode(&(ics->ssr), hDecoder->fb, ics->window_sequence, ics->window_shape,
            hDecoder->window_shape_prev[sce->channel], spec_coef, hDecoder->time_out[sce->channel],
            hDecoder->ssr_overlap[sce->channel], hDecoder->ipqf_buffer[sce->channel], hDecoder->prev_fmd[sce->channel],
            hDecoder->frameLength);
    }
#endif

    /* save window shape for next frame */
    hDecoder->window_shape_prev[sce->channel] = ics->window_shape;

#ifdef LTP_DEC
    if (is_ltp_ot(hDecoder->object_type))
    {
        lt_update_state(hDecoder->lt_pred_stat[sce->channel], hDecoder->time_out[sce->channel],
            hDecoder->fb_intermed[sce->channel], hDecoder->frameLength, hDecoder->object_type);
    }
#endif

#ifdef SBR_DEC
    if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))
        && hDecoder->sbr_alloced[hDecoder->fr_ch_ele])
    {
        int ele = hDecoder->fr_ch_ele;
        int ch = sce->channel;

        /* following case can happen when forceUpSampling == 1 */
        if (hDecoder->sbr[ele] == NULL)
        {
            hDecoder->sbr[ele] = sbrDecodeInit(hDecoder->frameLength,
                hDecoder->element_id[ele], 2*get_sample_rate(hDecoder->sf_index),
                hDecoder->downSampledSBR
#ifdef DRM
                , 0
#endif
                );
        }

        if (sce->ics1.window_sequence == EIGHT_SHORT_SEQUENCE)
            hDecoder->sbr[ele]->maxAACLine = 8*min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);
        else
            hDecoder->sbr[ele]->maxAACLine = min(sce->ics1.swb_offset[max(sce->ics1.max_sfb-1, 0)], sce->ics1.swb_offset_max);

        /* check if any of the PS tools is used */
#if (defined(PS_DEC) || defined(DRM_PS))
        if (hDecoder->ps_used[ele] == 0)
        {
#endif
            retval = sbrDecodeSingleFrame(hDecoder->sbr[ele], hDecoder->time_out[ch],
                hDecoder->postSeekResetFlag, hDecoder->downSampledSBR);
#if (defined(PS_DEC) || defined(DRM_PS))
        } else {
            retval = sbrDecodeSingleFramePS(hDecoder->sbr[ele], hDecoder->time_out[ch],
                hDecoder->time_out[ch+1], hDecoder->postSeekResetFlag,
                hDecoder->downSampledSBR);
        }
#endif
        if (retval > 0)
            return retval;
    } else if (((hDecoder->sbr_present_flag == 1) || (hDecoder->forceUpSampling == 1))
        && !hDecoder->sbr_alloced[hDecoder->fr_ch_ele])
    {
        return 23;
    }
#endif

    /* copy L to R when no PS is used */
#if (defined(PS_DEC) || defined(DRM_PS))
    if ((hDecoder->ps_used[hDecoder->fr_ch_ele] == 0) &&
        (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2))
    {
        int ele = hDecoder->fr_ch_ele;
        int ch = sce->channel;
        int frame_size = (hDecoder->sbr_alloced[ele]) ? 2 : 1;
        frame_size *= hDecoder->frameLength*sizeof(real_t);

        memcpy(hDecoder->time_out[ch+1], hDecoder->time_out[ch], frame_size);
    }
#endif

    return 0;
}","uint8_t reconstruct_single_channel(NeAACDecStruct *VAR_0, ic_stream *VAR_1,
                                   element *VAR_2, int16_t *VAR_3)
{
    uint8_t VAR_4;
    int VAR_5;
    ALIGN VAR_6 VAR_7[1024];

#ifdef VAR_8
    int64_t VAR_9 = faad_get_ts();
#endif


    /* COMMENT_0 */
#if ( (defined(VAR_10) && defined(VAR_11)) )
    VAR_5 = 2;
#elif defined(VAR_12)
    if (VAR_0->ps_used[VAR_0->fr_ch_ele])
        VAR_5 = 2;
    else
        VAR_5 = 1;
#else
    VAR_5 = 1;
#endif

    if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] == 0)
    {
        /* COMMENT_1 */
        VAR_0->element_output_channels[VAR_0->fr_ch_ele] = VAR_5;
    } else if (VAR_0->element_output_channels[VAR_0->fr_ch_ele] != VAR_5) {
        /* COMMENT_2 */
                                                                               
                                                             
           

        if (VAR_0->fr_channels == 1) {
            /* COMMENT_6 */
            VAR_0->element_alloced[VAR_0->fr_ch_ele] = 0;
            VAR_0->element_output_channels[VAR_0->fr_ch_ele] = VAR_5;
        } else {
            return 21;
        }
    }

    if (VAR_0->element_alloced[VAR_0->fr_ch_ele] == 0)
    {
        VAR_4 = allocate_single_channel(VAR_0, VAR_2->channel, VAR_5);
        if (VAR_4 > 0)
            return VAR_4;

        VAR_0->element_alloced[VAR_0->fr_ch_ele] = 1;
    }


    /* COMMENT_7 */
    VAR_4 = quant_to_spec(VAR_0, VAR_1, VAR_3, VAR_7, VAR_0->frameLength);
    if (VAR_4 > 0)
        return VAR_4;

#ifdef VAR_8
    VAR_9 = faad_get_ts() - VAR_9;
    VAR_0->requant_cycles += VAR_9;
#endif


    /* COMMENT_8 */
    pns_decode(VAR_1, NULL, VAR_7, NULL, VAR_0->frameLength, 0, VAR_0->object_type,
        &(VAR_0->__r1), &(VAR_0->__r2));

#ifdef VAR_13
    /* COMMENT_9 */
    if (VAR_0->object_type == VAR_14)
    {
		if (!VAR_0->pred_stat[VAR_2->channel])
			return 33;

        /* COMMENT_10 */
        ic_prediction(VAR_1, VAR_7, VAR_0->pred_stat[VAR_2->channel], VAR_0->frameLength,
            VAR_0->sf_index);

        /* COMMENT_11 */
                                                             
                                                         
          
        pns_reset_pred_state(VAR_1, VAR_0->pred_stat[VAR_2->channel]);
    }
#endif

#ifdef VAR_15
    if (is_ltp_ot(VAR_0->object_type))
    {
#ifdef VAR_16
        if (VAR_0->object_type == VAR_17)
        {
            if (VAR_1->ltp.data_present)
            {
                if (VAR_1->ltp.lag_update)
                    VAR_0->ltp_lag[VAR_2->channel] = VAR_1->ltp.lag;
            }
            VAR_1->ltp.lag = VAR_0->ltp_lag[VAR_2->channel];
        }
#endif

        /* COMMENT_15 */
        lt_prediction(VAR_1, &(VAR_1->ltp), VAR_7, VAR_0->lt_pred_stat[VAR_2->channel], VAR_0->fb,
            VAR_1->window_shape, VAR_0->window_shape_prev[VAR_2->channel],
            VAR_0->sf_index, VAR_0->object_type, VAR_0->frameLength);
    }
#endif

    /* COMMENT_16 */
    tns_decode_frame(VAR_1, &(VAR_1->tns), VAR_0->sf_index, VAR_0->object_type,
        VAR_7, VAR_0->frameLength);

    /* COMMENT_17 */
    if (VAR_0->drc->present)
    {
        if (!VAR_0->drc->exclude_mask[VAR_2->channel] || !VAR_0->drc->excluded_chns_present)
            drc_decode(VAR_0->drc, VAR_7);
    }

    /* COMMENT_18 */
#ifdef VAR_18
    if (VAR_0->object_type != VAR_19)
    {
#endif
        ifilter_bank(hDecoder->fb, ics->window_sequence, ics->window_shape,
            VAR_0->window_shape_prev[VAR_2->channel], VAR_7,
            VAR_0->time_out[VAR_2->channel], VAR_0->fb_intermed[VAR_2->channel],
            VAR_0->object_type, VAR_0->frameLength);
#ifdef VAR_18
    } else {
        ssr_decode(&(VAR_1->ssr), VAR_0->fb, VAR_1->window_sequence, VAR_1->window_shape,
            VAR_0->window_shape_prev[VAR_2->channel], VAR_7, VAR_0->time_out[VAR_2->channel],
            VAR_0->ssr_overlap[VAR_2->channel], VAR_0->ipqf_buffer[VAR_2->channel], VAR_0->prev_fmd[VAR_2->channel],
            VAR_0->frameLength);
    }
#endif

    /* COMMENT_19 */
    VAR_0->window_shape_prev[VAR_2->channel] = VAR_1->window_shape;

#ifdef VAR_15
    if (is_ltp_ot(VAR_0->object_type))
    {
        lt_update_state(VAR_0->lt_pred_stat[VAR_2->channel], VAR_0->time_out[VAR_2->channel],
            VAR_0->fb_intermed[VAR_2->channel], VAR_0->frameLength, VAR_0->object_type);
    }
#endif

#ifdef VAR_20
    if (((VAR_0->sbr_present_flag == 1) || (VAR_0->forceUpSampling == 1))
        && VAR_0->sbr_alloced[VAR_0->fr_ch_ele])
    {
        int VAR_21 = VAR_0->fr_ch_ele;
        int VAR_22 = VAR_2->channel;

        /* COMMENT_20 */
        if (VAR_0->sbr[VAR_21] == NULL)
        {
            VAR_0->sbr[VAR_21] = sbrDecodeInit(VAR_0->frameLength,
                VAR_0->element_id[VAR_21], 2*get_sample_rate(VAR_0->sf_index),
                VAR_0->downSampledSBR
#ifdef VAR_10
                , 0
#endif
                );
        }

        if (VAR_2->ics1.window_sequence == VAR_23)
            VAR_0->sbr[VAR_21]->maxAACLine = 8*min(VAR_2->ics1.swb_offset[max(VAR_2->ics1.max_sfb-1, 0)], VAR_2->ics1.swb_offset_max);
        else
            VAR_0->sbr[VAR_21]->maxAACLine = min(VAR_2->ics1.swb_offset[max(VAR_2->ics1.max_sfb-1, 0)], VAR_2->ics1.swb_offset_max);

        /* COMMENT_21 */
#if (defined(VAR_12) || defined(VAR_11))
        if (VAR_0->ps_used[VAR_21] == 0)
        {
#endif
            retval = sbrDecodeSingleFrame(hDecoder->sbr[ele], hDecoder->time_out[ch],
                VAR_0->postSeekResetFlag, VAR_0->downSampledSBR);
#if (defined(VAR_12) || defined(VAR_11))
        } else {
            VAR_4 = sbrDecodeSingleFramePS(VAR_0->sbr[VAR_21], VAR_0->time_out[VAR_22],
                VAR_0->time_out[VAR_22+1], VAR_0->postSeekResetFlag,
                VAR_0->downSampledSBR);
        }
#endif
        if (VAR_4 > 0)
            return VAR_4;
    } else if (((VAR_0->sbr_present_flag == 1) || (VAR_0->forceUpSampling == 1))
        && !VAR_0->sbr_alloced[VAR_0->fr_ch_ele])
    {
        return 23;
    }
#endif

    /* COMMENT_22 */
#if (defined(VAR_12) || defined(VAR_11))
    if ((VAR_0->ps_used[VAR_0->fr_ch_ele] == 0) &&
        (VAR_0->element_output_channels[VAR_0->fr_ch_ele] == 2))
    {
        int VAR_21 = VAR_0->fr_ch_ele;
        int VAR_22 = VAR_2->channel;
        int VAR_24 = (VAR_0->sbr_alloced[VAR_21]) ? 2 : 1;
        VAR_24 *= VAR_0->frameLength*sizeof(VAR_6);

        memcpy(VAR_0->time_out[VAR_22+1], VAR_0->time_out[VAR_22], VAR_24);
    }
#endif

    return 0;
}",knik0/faad2/3b80a57483a6bc822d3ce3cc640fa81737a87c54/specrec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -27,18 +27,18 @@
         /* element_output_channels not set yet */
         hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;
     } else if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] != output_channels) {
-        /* element inconsistency */
-
-        /* this only happens if PS is actually found but not in the first frame
+        /* element inconsistency
+         * this only happens if PS is actually found but not in the first frame
          * this means that there is only 1 bitstream element!
          */
 
-        /* reset the allocation */
-        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 0;
-
-        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;
-
-        //return 21;
+        if (hDecoder->fr_channels == 1) {
+            /* reset the allocation */
+            hDecoder->element_alloced[hDecoder->fr_ch_ele] = 0;
+            hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;
+        } else {
+            return 21;
+        }
     }
 
     if (hDecoder->element_alloced[hDecoder->fr_ch_ele] == 0)","{'deleted_lines': ['        /* element inconsistency */', '', '        /* this only happens if PS is actually found but not in the first frame', '        /* reset the allocation */', '        hDecoder->element_alloced[hDecoder->fr_ch_ele] = 0;', '', '        hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;', '', '        //return 21;'], 'added_lines': ['        /* element inconsistency', '         * this only happens if PS is actually found but not in the first frame', '        if (hDecoder->fr_channels == 1) {', '            /* reset the allocation */', '            hDecoder->element_alloced[hDecoder->fr_ch_ele] = 0;', '            hDecoder->element_output_channels[hDecoder->fr_ch_ele] = output_channels;', '        } else {', '            return 21;', '        }']}",True,"An invalid memory address dereference was discovered in the sbr_process_channel function of libfaad/sbr_dec.c in Freeware Advanced Audio Decoder 2 (FAAD2) 2.8.8. The vulnerability causes a segmentation fault and application crash, which leads to denial of service.",5.5,MEDIUM,1,valid,2019-08-19T15:24:55Z,3
CVE-2019-15538,['CWE-400'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"xfs: fix missing ILOCK unlock when xfs_setattr_nonsize fails due to EDQUOT

Benjamin Moody reported to Debian that XFS partially wedges when a chgrp
fails on account of being out of disk quota.  I ran his reproducer
script:

# adduser dummy
# adduser dummy plugdev

# dd if=/dev/zero bs=1M count=100 of=test.img
# mkfs.xfs test.img
# mount -t xfs -o gquota test.img /mnt
# mkdir -p /mnt/dummy
# chown -c dummy /mnt/dummy
# xfs_quota -xc 'limit -g bsoft=100k bhard=100k plugdev' /mnt

(and then as user dummy)

$ dd if=/dev/urandom bs=1M count=50 of=/mnt/dummy/foo
$ chgrp plugdev /mnt/dummy/foo

and saw:

================================================
WARNING: lock held when returning to user space!
5.3.0-rc5 #rc5 Tainted: G        W
------------------------------------------------
chgrp/47006 is leaving the kernel with locks still held!
1 lock held by chgrp/47006:
 #0: 000000006664ea2d (&xfs_nondir_ilock_class){++++}, at: xfs_ilock+0xd2/0x290 [xfs]

...which is clearly caused by xfs_setattr_nonsize failing to unlock the
ILOCK after the xfs_qm_vop_chown_reserve call fails.  Add the missing
unlock.

Reported-by: benjamin.moody@gmail.com
Fixes: 253f4911f297 (""xfs: better xfs_trans_alloc interface"")
Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
Reviewed-by: Dave Chinner <dchinner@redhat.com>
Tested-by: Salvatore Bonaccorso <carnil@debian.org>",1fb254aa983bf190cfd685d40c64a480a9bafaee,https://github.com/torvalds/linux/commit/1fb254aa983bf190cfd685d40c64a480a9bafaee,fs/xfs/xfs_iops.c,xfs_setattr_nonsize,"int
xfs_setattr_nonsize(
struct xfs_inode*ip,
struct iattr*iattr,
intflags)
{
xfs_mount_t*mp = ip->i_mount;
struct inode*inode = VFS_I(ip);
intmask = iattr->ia_valid;
xfs_trans_t*tp;
interror;
kuid_tuid = GLOBAL_ROOT_UID, iuid = GLOBAL_ROOT_UID;
kgid_tgid = GLOBAL_ROOT_GID, igid = GLOBAL_ROOT_GID;
struct xfs_dquot*udqp = NULL, *gdqp = NULL;
struct xfs_dquot*olddquot1 = NULL, *olddquot2 = NULL;
ASSERT((mask & ATTR_SIZE) == 0);
if (XFS_IS_QUOTA_ON(mp) && (mask & (ATTR_UID|ATTR_GID))) {
uintqflags = 0;
if ((mask & ATTR_UID) && XFS_IS_UQUOTA_ON(mp)) {
uid = iattr->ia_uid;
qflags |= XFS_QMOPT_UQUOTA;
} else {
uid = inode->i_uid;
}
if ((mask & ATTR_GID) && XFS_IS_GQUOTA_ON(mp)) {
gid = iattr->ia_gid;
qflags |= XFS_QMOPT_GQUOTA;
}  else {
gid = inode->i_gid;
}
ASSERT(udqp == NULL);
ASSERT(gdqp == NULL);
error = xfs_qm_vop_dqalloc(ip, xfs_kuid_to_uid(uid),
xfs_kgid_to_gid(gid),
xfs_get_projid(ip),
qflags, &udqp, &gdqp, NULL);
if (error)
return error;
}
error = xfs_trans_alloc(mp, &M_RES(mp)->tr_ichange, 0, 0, 0, &tp);
if (error)
goto out_dqrele;
xfs_ilock(ip, XFS_ILOCK_EXCL);
xfs_trans_ijoin(tp, ip, 0);
if (mask & (ATTR_UID|ATTR_GID)) {
iuid = inode->i_uid;
igid = inode->i_gid;
gid = (mask & ATTR_GID) ? iattr->ia_gid : igid;
uid = (mask & ATTR_UID) ? iattr->ia_uid : iuid;
if (XFS_IS_QUOTA_RUNNING(mp) &&
((XFS_IS_UQUOTA_ON(mp) && !uid_eq(iuid, uid)) ||
(XFS_IS_GQUOTA_ON(mp) && !gid_eq(igid, gid)))) {
ASSERT(tp);
error = xfs_qm_vop_chown_reserve(tp, ip, udqp, gdqp,
NULL, capable(CAP_FOWNER) ?
XFS_QMOPT_FORCE_RES : 0);
if (error)
goto out_cancel;
}
}
if (mask & (ATTR_UID|ATTR_GID)) {
if ((inode->i_mode & (S_ISUID|S_ISGID)) &&
!capable(CAP_FSETID))
inode->i_mode &= ~(S_ISUID|S_ISGID);
if (!uid_eq(iuid, uid)) {
if (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_UQUOTA_ON(mp)) {
ASSERT(mask & ATTR_UID);
ASSERT(udqp);
olddquot1 = xfs_qm_vop_chown(tp, ip,
&ip->i_udquot, udqp);
}
ip->i_d.di_uid = xfs_kuid_to_uid(uid);
inode->i_uid = uid;
}
if (!gid_eq(igid, gid)) {
if (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_GQUOTA_ON(mp)) {
ASSERT(xfs_sb_version_has_pquotino(&mp->m_sb) ||
!XFS_IS_PQUOTA_ON(mp));
ASSERT(mask & ATTR_GID);
ASSERT(gdqp);
olddquot2 = xfs_qm_vop_chown(tp, ip,
&ip->i_gdquot, gdqp);
}
ip->i_d.di_gid = xfs_kgid_to_gid(gid);
inode->i_gid = gid;
}
}
if (mask & ATTR_MODE)
xfs_setattr_mode(ip, iattr);
if (mask & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))
xfs_setattr_time(ip, iattr);
xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
XFS_STATS_INC(mp, xs_ig_attrchg);
if (mp->m_flags & XFS_MOUNT_WSYNC)
xfs_trans_set_sync(tp);
error = xfs_trans_commit(tp);
xfs_iunlock(ip, XFS_ILOCK_EXCL);
xfs_qm_dqrele(olddquot1);
xfs_qm_dqrele(olddquot2);
xfs_qm_dqrele(udqp);
xfs_qm_dqrele(gdqp);
if (error)
return error;
if ((mask & ATTR_MODE) && !(flags & XFS_ATTR_NOACL)) {
error = posix_acl_chmod(inode, inode->i_mode);
if (error)
return error;
}
return 0;
out_cancel:
xfs_trans_cancel(tp);
out_dqrele:
xfs_qm_dqrele(udqp);
xfs_qm_dqrele(gdqp);
return error;
}","int
xfs_setattr_nonsize(
struct xfs_inode*VAR_0,
struct iattr*iattr,
intVAR_1)
{
xfs_mount_t*VAR_2 = VAR_0->i_mount;
struct inode*inode = VFS_I(VAR_0);
intVAR_3 = iattr->ia_valid;
xfs_trans_t*VAR_4;
intVAR_5;
kuid_tVAR_6 = VAR_7, VAR_8 = VAR_7;
kgid_tVAR_9 = VAR_10, VAR_11 = VAR_10;
struct xfs_dquot*VAR_12 = NULL, *VAR_13 = NULL;
struct xfs_dquot*VAR_14 = NULL, *VAR_15 = NULL;
ASSERT((VAR_3 & VAR_16) == 0);
if (XFS_IS_QUOTA_ON(VAR_2) && (VAR_3 & (VAR_17|VAR_18))) {
uintVAR_19 = 0;
if ((VAR_3 & VAR_17) && XFS_IS_UQUOTA_ON(VAR_2)) {
VAR_6 = iattr->ia_uid;
VAR_19 |= VAR_20;
} else {
VAR_6 = inode->i_uid;
}
if ((VAR_3 & VAR_18) && XFS_IS_GQUOTA_ON(VAR_2)) {
VAR_9 = iattr->ia_gid;
VAR_19 |= VAR_21;
}  else {
VAR_9 = inode->i_gid;
}
ASSERT(VAR_12 == NULL);
ASSERT(VAR_13 == NULL);
VAR_5 = xfs_qm_vop_dqalloc(VAR_0, xfs_kuid_to_uid(VAR_6),
xfs_kgid_to_gid(VAR_9),
xfs_get_projid(VAR_0),
VAR_19, &VAR_12, &VAR_13, NULL);
if (VAR_5)
return VAR_5;
}
VAR_5 = xfs_trans_alloc(VAR_2, &M_RES(VAR_2)->tr_ichange, 0, 0, 0, &VAR_4);
if (VAR_5)
goto out_dqrele;
xfs_ilock(VAR_0, VAR_22);
xfs_trans_ijoin(VAR_4, VAR_0, 0);
if (VAR_3 & (VAR_17|VAR_18)) {
VAR_8 = inode->i_uid;
VAR_11 = inode->i_gid;
VAR_9 = (VAR_3 & VAR_18) ? iattr->ia_gid : VAR_11;
VAR_6 = (VAR_3 & VAR_17) ? iattr->ia_uid : VAR_8;
if (XFS_IS_QUOTA_RUNNING(VAR_2) &&
((XFS_IS_UQUOTA_ON(VAR_2) && !uid_eq(VAR_8, VAR_6)) ||
(XFS_IS_GQUOTA_ON(VAR_2) && !gid_eq(VAR_11, VAR_9)))) {
ASSERT(VAR_4);
VAR_5 = xfs_qm_vop_chown_reserve(VAR_4, VAR_0, VAR_12, VAR_13,
NULL, capable(VAR_23) ?
VAR_24 : 0);
if (VAR_5)
goto out_cancel;
}
}
if (VAR_3 & (VAR_17|VAR_18)) {
if ((inode->i_mode & (VAR_25|VAR_26)) &&
!capable(VAR_27))
inode->i_mode &= ~(VAR_25|VAR_26);
if (!uid_eq(VAR_8, VAR_6)) {
if (XFS_IS_QUOTA_RUNNING(VAR_2) && XFS_IS_UQUOTA_ON(VAR_2)) {
ASSERT(VAR_3 & VAR_17);
ASSERT(VAR_12);
VAR_14 = xfs_qm_vop_chown(VAR_4, VAR_0,
&VAR_0->i_udquot, VAR_12);
}
VAR_0->i_d.di_uid = xfs_kuid_to_uid(VAR_6);
inode->i_uid = VAR_6;
}
if (!gid_eq(VAR_11, VAR_9)) {
if (XFS_IS_QUOTA_RUNNING(VAR_2) && XFS_IS_GQUOTA_ON(VAR_2)) {
ASSERT(xfs_sb_version_has_pquotino(&VAR_2->m_sb) ||
!XFS_IS_PQUOTA_ON(VAR_2));
ASSERT(VAR_3 & VAR_18);
ASSERT(VAR_13);
VAR_15 = xfs_qm_vop_chown(VAR_4, VAR_0,
&VAR_0->i_gdquot, VAR_13);
}
VAR_0->i_d.di_gid = xfs_kgid_to_gid(VAR_9);
inode->i_gid = VAR_9;
}
}
if (VAR_3 & VAR_28)
xfs_setattr_mode(VAR_0, iattr);
if (VAR_3 & (VAR_29|VAR_30|VAR_31))
xfs_setattr_time(VAR_0, iattr);
xfs_trans_log_inode(VAR_4, VAR_0, VAR_32);
XFS_STATS_INC(VAR_2, VAR_33);
if (VAR_2->m_flags & VAR_34)
xfs_trans_set_sync(VAR_4);
VAR_5 = xfs_trans_commit(VAR_4);
xfs_iunlock(VAR_0, VAR_22);
xfs_qm_dqrele(VAR_14);
xfs_qm_dqrele(VAR_15);
xfs_qm_dqrele(VAR_12);
xfs_qm_dqrele(VAR_13);
if (VAR_5)
return VAR_5;
if ((VAR_3 & VAR_28) && !(VAR_1 & VAR_35)) {
VAR_5 = posix_acl_chmod(inode, inode->i_mode);
if (VAR_5)
return VAR_5;
}
return 0;
out_cancel:
xfs_trans_cancel(VAR_4);
out_dqrele:
xfs_qm_dqrele(VAR_12);
xfs_qm_dqrele(VAR_13);
return VAR_5;
}",torvalds/linux/1fb254aa983bf190cfd685d40c64a480a9bafaee/xfs_iops.c/vul/before/0.json,"int
xfs_setattr_nonsize(
	struct xfs_inode	*ip,
	struct iattr		*iattr,
	int			flags)
{
	xfs_mount_t		*mp = ip->i_mount;
	struct inode		*inode = VFS_I(ip);
	int			mask = iattr->ia_valid;
	xfs_trans_t		*tp;
	int			error;
	kuid_t			uid = GLOBAL_ROOT_UID, iuid = GLOBAL_ROOT_UID;
	kgid_t			gid = GLOBAL_ROOT_GID, igid = GLOBAL_ROOT_GID;
	struct xfs_dquot	*udqp = NULL, *gdqp = NULL;
	struct xfs_dquot	*olddquot1 = NULL, *olddquot2 = NULL;

	ASSERT((mask & ATTR_SIZE) == 0);

	/*
	 * If disk quotas is on, we make sure that the dquots do exist on disk,
	 * before we start any other transactions. Trying to do this later
	 * is messy. We don't care to take a readlock to look at the ids
	 * in inode here, because we can't hold it across the trans_reserve.
	 * If the IDs do change before we take the ilock, we're covered
	 * because the i_*dquot fields will get updated anyway.
	 */
	if (XFS_IS_QUOTA_ON(mp) && (mask & (ATTR_UID|ATTR_GID))) {
		uint	qflags = 0;

		if ((mask & ATTR_UID) && XFS_IS_UQUOTA_ON(mp)) {
			uid = iattr->ia_uid;
			qflags |= XFS_QMOPT_UQUOTA;
		} else {
			uid = inode->i_uid;
		}
		if ((mask & ATTR_GID) && XFS_IS_GQUOTA_ON(mp)) {
			gid = iattr->ia_gid;
			qflags |= XFS_QMOPT_GQUOTA;
		}  else {
			gid = inode->i_gid;
		}

		/*
		 * We take a reference when we initialize udqp and gdqp,
		 * so it is important that we never blindly double trip on
		 * the same variable. See xfs_create() for an example.
		 */
		ASSERT(udqp == NULL);
		ASSERT(gdqp == NULL);
		error = xfs_qm_vop_dqalloc(ip, xfs_kuid_to_uid(uid),
					   xfs_kgid_to_gid(gid),
					   xfs_get_projid(ip),
					   qflags, &udqp, &gdqp, NULL);
		if (error)
			return error;
	}

	error = xfs_trans_alloc(mp, &M_RES(mp)->tr_ichange, 0, 0, 0, &tp);
	if (error)
		goto out_dqrele;

	xfs_ilock(ip, XFS_ILOCK_EXCL);
	xfs_trans_ijoin(tp, ip, 0);

	/*
	 * Change file ownership.  Must be the owner or privileged.
	 */
	if (mask & (ATTR_UID|ATTR_GID)) {
		/*
		 * These IDs could have changed since we last looked at them.
		 * But, we're assured that if the ownership did change
		 * while we didn't have the inode locked, inode's dquot(s)
		 * would have changed also.
		 */
		iuid = inode->i_uid;
		igid = inode->i_gid;
		gid = (mask & ATTR_GID) ? iattr->ia_gid : igid;
		uid = (mask & ATTR_UID) ? iattr->ia_uid : iuid;

		/*
		 * Do a quota reservation only if uid/gid is actually
		 * going to change.
		 */
		if (XFS_IS_QUOTA_RUNNING(mp) &&
		    ((XFS_IS_UQUOTA_ON(mp) && !uid_eq(iuid, uid)) ||
		     (XFS_IS_GQUOTA_ON(mp) && !gid_eq(igid, gid)))) {
			ASSERT(tp);
			error = xfs_qm_vop_chown_reserve(tp, ip, udqp, gdqp,
						NULL, capable(CAP_FOWNER) ?
						XFS_QMOPT_FORCE_RES : 0);
			if (error)	/* out of quota */
				goto out_cancel;
		}
	}

	/*
	 * Change file ownership.  Must be the owner or privileged.
	 */
	if (mask & (ATTR_UID|ATTR_GID)) {
		/*
		 * CAP_FSETID overrides the following restrictions:
		 *
		 * The set-user-ID and set-group-ID bits of a file will be
		 * cleared upon successful return from chown()
		 */
		if ((inode->i_mode & (S_ISUID|S_ISGID)) &&
		    !capable(CAP_FSETID))
			inode->i_mode &= ~(S_ISUID|S_ISGID);

		/*
		 * Change the ownerships and register quota modifications
		 * in the transaction.
		 */
		if (!uid_eq(iuid, uid)) {
			if (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_UQUOTA_ON(mp)) {
				ASSERT(mask & ATTR_UID);
				ASSERT(udqp);
				olddquot1 = xfs_qm_vop_chown(tp, ip,
							&ip->i_udquot, udqp);
			}
			ip->i_d.di_uid = xfs_kuid_to_uid(uid);
			inode->i_uid = uid;
		}
		if (!gid_eq(igid, gid)) {
			if (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_GQUOTA_ON(mp)) {
				ASSERT(xfs_sb_version_has_pquotino(&mp->m_sb) ||
				       !XFS_IS_PQUOTA_ON(mp));
				ASSERT(mask & ATTR_GID);
				ASSERT(gdqp);
				olddquot2 = xfs_qm_vop_chown(tp, ip,
							&ip->i_gdquot, gdqp);
			}
			ip->i_d.di_gid = xfs_kgid_to_gid(gid);
			inode->i_gid = gid;
		}
	}

	if (mask & ATTR_MODE)
		xfs_setattr_mode(ip, iattr);
	if (mask & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))
		xfs_setattr_time(ip, iattr);

	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);

	XFS_STATS_INC(mp, xs_ig_attrchg);

	if (mp->m_flags & XFS_MOUNT_WSYNC)
		xfs_trans_set_sync(tp);
	error = xfs_trans_commit(tp);

	xfs_iunlock(ip, XFS_ILOCK_EXCL);

	/*
	 * Release any dquot(s) the inode had kept before chown.
	 */
	xfs_qm_dqrele(olddquot1);
	xfs_qm_dqrele(olddquot2);
	xfs_qm_dqrele(udqp);
	xfs_qm_dqrele(gdqp);

	if (error)
		return error;

	/*
	 * XXX(hch): Updating the ACL entries is not atomic vs the i_mode
	 * 	     update.  We could avoid this with linked transactions
	 * 	     and passing down the transaction pointer all the way
	 *	     to attr_set.  No previous user of the generic
	 * 	     Posix ACL code seems to care about this issue either.
	 */
	if ((mask & ATTR_MODE) && !(flags & XFS_ATTR_NOACL)) {
		error = posix_acl_chmod(inode, inode->i_mode);
		if (error)
			return error;
	}

	return 0;

out_cancel:
	xfs_trans_cancel(tp);
	xfs_iunlock(ip, XFS_ILOCK_EXCL);
out_dqrele:
	xfs_qm_dqrele(udqp);
	xfs_qm_dqrele(gdqp);
	return error;
}","int
xfs_setattr_nonsize(
	struct xfs_inode	*VAR_0,
	struct iattr		*iattr,
	int			VAR_1)
{
	xfs_mount_t		*VAR_2 = VAR_0->i_mount;
	struct inode		*inode = VFS_I(VAR_0);
	int			VAR_3 = iattr->ia_valid;
	xfs_trans_t		*VAR_4;
	int			VAR_5;
	kuid_t			VAR_6 = VAR_7, VAR_8 = VAR_7;
	kgid_t			VAR_9 = VAR_10, VAR_11 = VAR_10;
	struct xfs_dquot	*VAR_12 = NULL, *VAR_13 = NULL;
	struct xfs_dquot	*VAR_14 = NULL, *VAR_15 = NULL;

	ASSERT((VAR_3 & VAR_16) == 0);

	/* COMMENT_0 */
                                                                        
                                                                   
                                                                 
                                                                     
                                                                
                                                        
    
	if (XFS_IS_QUOTA_ON(VAR_2) && (VAR_3 & (VAR_17|VAR_18))) {
		uint	VAR_19 = 0;

		if ((VAR_3 & VAR_17) && XFS_IS_UQUOTA_ON(VAR_2)) {
			VAR_6 = iattr->ia_uid;
			VAR_19 |= VAR_20;
		} else {
			VAR_6 = inode->i_uid;
		}
		if ((VAR_3 & VAR_18) && XFS_IS_GQUOTA_ON(VAR_2)) {
			VAR_9 = iattr->ia_gid;
			VAR_19 |= VAR_21;
		}  else {
			VAR_9 = inode->i_gid;
		}

		/* COMMENT_8 */
                                                          
                                                            
                                                        
     
		ASSERT(VAR_12 == NULL);
		ASSERT(VAR_13 == NULL);
		VAR_5 = xfs_qm_vop_dqalloc(VAR_0, xfs_kuid_to_uid(VAR_6),
					   xfs_kgid_to_gid(VAR_9),
					   xfs_get_projid(VAR_0),
					   VAR_19, &VAR_12, &VAR_13, NULL);
		if (VAR_5)
			return VAR_5;
	}

	VAR_5 = xfs_trans_alloc(VAR_2, &M_RES(VAR_2)->tr_ichange, 0, 0, 0, &VAR_4);
	if (VAR_5)
		goto out_dqrele;

	xfs_ilock(VAR_0, VAR_22);
	xfs_trans_ijoin(VAR_4, VAR_0, 0);

	/* COMMENT_13 */
                                                            
    
	if (VAR_3 & (VAR_17|VAR_18)) {
		/* COMMENT_16 */
                                                               
                                                        
                                                            
                             
     
		VAR_8 = inode->i_uid;
		VAR_11 = inode->i_gid;
		VAR_9 = (VAR_3 & VAR_18) ? iattr->ia_gid : VAR_11;
		VAR_6 = (VAR_3 & VAR_17) ? iattr->ia_uid : VAR_8;

		/* COMMENT_22 */
                                                       
                     
     
		if (XFS_IS_QUOTA_RUNNING(VAR_2) &&
		    ((XFS_IS_UQUOTA_ON(VAR_2) && !uid_eq(VAR_8, VAR_6)) ||
		     (XFS_IS_GQUOTA_ON(VAR_2) && !gid_eq(VAR_11, VAR_9)))) {
			ASSERT(VAR_4);
			VAR_5 = xfs_qm_vop_chown_reserve(VAR_4, VAR_0, VAR_12, VAR_13,
						NULL, capable(VAR_23) ?
						VAR_24 : 0);
			if (VAR_5)	/* COMMENT_26 */
				goto out_cancel;
		}
	}

	/* COMMENT_27 */
                                                            
    
	if (VAR_3 & (VAR_17|VAR_18)) {
		/* COMMENT_30 */
                                                     
    
                                                            
                                                
     
		if ((inode->i_mode & (VAR_25|VAR_26)) &&
		    !capable(VAR_27))
			inode->i_mode &= ~(VAR_25|VAR_26);

		/* COMMENT_36 */
                                                           
                        
     
		if (!uid_eq(VAR_8, VAR_6)) {
			if (XFS_IS_QUOTA_RUNNING(VAR_2) && XFS_IS_UQUOTA_ON(VAR_2)) {
				ASSERT(VAR_3 & VAR_17);
				ASSERT(VAR_12);
				VAR_14 = xfs_qm_vop_chown(VAR_4, VAR_0,
							&VAR_0->i_udquot, VAR_12);
			}
			VAR_0->i_d.di_uid = xfs_kuid_to_uid(VAR_6);
			inode->i_uid = VAR_6;
		}
		if (!gid_eq(VAR_11, VAR_9)) {
			if (XFS_IS_QUOTA_RUNNING(VAR_2) && XFS_IS_GQUOTA_ON(VAR_2)) {
				ASSERT(xfs_sb_version_has_pquotino(&VAR_2->m_sb) ||
				       !XFS_IS_PQUOTA_ON(VAR_2));
				ASSERT(VAR_3 & VAR_18);
				ASSERT(VAR_13);
				VAR_15 = xfs_qm_vop_chown(VAR_4, VAR_0,
							&VAR_0->i_gdquot, VAR_13);
			}
			VAR_0->i_d.di_gid = xfs_kgid_to_gid(VAR_9);
			inode->i_gid = VAR_9;
		}
	}

	if (VAR_3 & VAR_28)
		xfs_setattr_mode(VAR_0, iattr);
	if (VAR_3 & (VAR_29|VAR_30|VAR_31))
		xfs_setattr_time(VAR_0, iattr);

	xfs_trans_log_inode(VAR_4, VAR_0, VAR_32);

	XFS_STATS_INC(VAR_2, VAR_33);

	if (VAR_2->m_flags & VAR_34)
		xfs_trans_set_sync(VAR_4);
	VAR_5 = xfs_trans_commit(VAR_4);

	xfs_iunlock(VAR_0, VAR_22);

	/* COMMENT_40 */
                                                         
    
	xfs_qm_dqrele(VAR_14);
	xfs_qm_dqrele(VAR_15);
	xfs_qm_dqrele(VAR_12);
	xfs_qm_dqrele(VAR_13);

	if (VAR_5)
		return VAR_5;

	/* COMMENT_43 */
                                                                  
                                                               
                                                              
                                                      
                                                               
    
	if ((VAR_3 & VAR_28) && !(VAR_1 & VAR_35)) {
		VAR_5 = posix_acl_chmod(inode, inode->i_mode);
		if (VAR_5)
			return VAR_5;
	}

	return 0;

out_cancel:
	xfs_trans_cancel(VAR_4);
	xfs_iunlock(VAR_0, VAR_22);
out_dqrele:
	xfs_qm_dqrele(VAR_12);
	xfs_qm_dqrele(VAR_13);
	return VAR_5;
}",torvalds/linux/1fb254aa983bf190cfd685d40c64a480a9bafaee/xfs_iops.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -178,6 +178,7 @@
 
 out_cancel:
 	xfs_trans_cancel(tp);
+	xfs_iunlock(ip, XFS_ILOCK_EXCL);
 out_dqrele:
 	xfs_qm_dqrele(udqp);
 	xfs_qm_dqrele(gdqp);","{'deleted_lines': [], 'added_lines': ['\txfs_iunlock(ip, XFS_ILOCK_EXCL);']}",True,"An issue was discovered in xfs_setattr_nonsize in fs/xfs/xfs_iops.c in the Linux kernel through 5.2.9. XFS partially wedges when a chgrp fails on account of being out of disk quota. xfs_setattr_nonsize is failing to unlock the ILOCK after the xfs_qm_vop_chown_reserve call fails. This is primarily a local DoS attack vector, but it might result as well in remote DoS if the XFS filesystem is exported for instance via NFS.",7.5,HIGH,2,valid,2019-08-23T03:55:54Z,3
CVE-2018-20360,"['CWE-119', 'CWE-476']",AV:N/AC:M/Au:N/C:N/I:N/A:P,0,knik0/faad2,"ps_dec: sanitize iid_index before mixing

index range is supposed to be withing -7 and 7 or -15 and 15 depending on
iid_mode (see Table 8.24, ISO/IEC 14496-3:2005).

Indexes outside these boundaries are likely to be errors and should be
sanitized to avoid memory corruption. Replace any index under
-no_iid_steps (-7 or -15 depending on iid_mode) by -no_iid_steps. Replace
any index above no_iid_steps by no_iid_steps. Try to process further.

This commit addresses CVE-2019-6956 (fixes #39).",6823e6610c9af1b0080cb22b9da03efb208d7d57,https://github.com/knik0/faad2/commit/6823e6610c9af1b0080cb22b9da03efb208d7d57,libfaad/ps_dec.c,ps_mix_phase,"static void ps_mix_phase(ps_info *ps, qmf_t X_left[38][64], qmf_t X_right[38][64],
qmf_t X_hybrid_left[32][32], qmf_t X_hybrid_right[32][32])
{
uint8_t n;
uint8_t gr;
uint8_t bk = 0;
uint8_t sb, maxsb;
uint8_t env;
uint8_t nr_ipdopd_par;
complex_t h11, h12, h21, h22;
complex_t H11, H12, H21, H22;
complex_t deltaH11, deltaH12, deltaH21, deltaH22;
complex_t tempLeft;
complex_t tempRight;
complex_t phaseLeft;
complex_t phaseRight;
real_t L;
const real_t *sf_iid;
uint8_t no_iid_steps;
if (ps->iid_mode >= 3)
{
no_iid_steps = 15;
sf_iid = sf_iid_fine;
} else {
no_iid_steps = 7;
sf_iid = sf_iid_normal;
}
if (ps->ipd_mode == 0 || ps->ipd_mode == 3)
{
nr_ipdopd_par = 11; 
} else {
nr_ipdopd_par = ps->nr_ipdopd_par;
}
for (gr = 0; gr < ps->num_groups; gr++)
{
bk = (~NEGATE_IPD_MASK) & ps->map_group2bk[gr];
maxsb = (gr < ps->num_hybrid_groups) ? ps->group_border[gr] + 1 : ps->group_border[gr + 1];
for (env = 0; env < ps->num_env; env++)
{
if (ps->icc_mode < 3)
{
real_t c_1, c_2;
real_t cosa, sina;
real_t cosb, sinb;
real_t ab1, ab2;
real_t ab3, ab4;
c_1 = sf_iid[no_iid_steps + ps->iid_index[env][bk]];
c_2 = sf_iid[no_iid_steps - ps->iid_index[env][bk]];
cosa = cos_alphas[ps->icc_index[env][bk]];
sina = sin_alphas[ps->icc_index[env][bk]];
if (ps->iid_mode >= 3)
{
if (ps->iid_index[env][bk] < 0)
{
cosb =  cos_betas_fine[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];
sinb = -sin_betas_fine[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];
} else {
cosb = cos_betas_fine[ps->iid_index[env][bk]][ps->icc_index[env][bk]];
sinb = sin_betas_fine[ps->iid_index[env][bk]][ps->icc_index[env][bk]];
}
} else {
if (ps->iid_index[env][bk] < 0)
{
cosb =  cos_betas_normal[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];
sinb = -sin_betas_normal[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];
} else {
cosb = cos_betas_normal[ps->iid_index[env][bk]][ps->icc_index[env][bk]];
sinb = sin_betas_normal[ps->iid_index[env][bk]][ps->icc_index[env][bk]];
}
}
ab1 = MUL_C(cosb, cosa);
ab2 = MUL_C(sinb, sina);
ab3 = MUL_C(sinb, cosa);
ab4 = MUL_C(cosb, sina);
RE(h11) = MUL_C(c_2, (ab1 - ab2));
RE(h12) = MUL_C(c_1, (ab1 + ab2));
RE(h21) = MUL_C(c_2, (ab3 + ab4));
RE(h22) = MUL_C(c_1, (ab3 - ab4));
} else {
real_t sina, cosa;
real_t cosg, sing;
if (ps->iid_mode >= 3)
{
uint8_t abs_iid = abs(ps->iid_index[env][bk]);
cosa = sincos_alphas_B_fine[no_iid_steps + ps->iid_index[env][bk]][ps->icc_index[env][bk]];
sina = sincos_alphas_B_fine[30 - (no_iid_steps + ps->iid_index[env][bk])][ps->icc_index[env][bk]];
cosg = cos_gammas_fine[abs_iid][ps->icc_index[env][bk]];
sing = sin_gammas_fine[abs_iid][ps->icc_index[env][bk]];
} else {
uint8_t abs_iid = abs(ps->iid_index[env][bk]);
cosa = sincos_alphas_B_normal[no_iid_steps + ps->iid_index[env][bk]][ps->icc_index[env][bk]];
sina = sincos_alphas_B_normal[14 - (no_iid_steps + ps->iid_index[env][bk])][ps->icc_index[env][bk]];
cosg = cos_gammas_normal[abs_iid][ps->icc_index[env][bk]];
sing = sin_gammas_normal[abs_iid][ps->icc_index[env][bk]];
}
RE(h11) = MUL_C(COEF_SQRT2, MUL_C(cosa, cosg));
RE(h12) = MUL_C(COEF_SQRT2, MUL_C(sina, cosg));
RE(h21) = MUL_C(COEF_SQRT2, MUL_C(-cosa, sing));
RE(h22) = MUL_C(COEF_SQRT2, MUL_C(sina, sing));
}
if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))
{
int8_t i;
real_t xy, pq, xypq;
i = ps->phase_hist;
#ifdef FIXED_POINT
RE(tempLeft)  = RE(ps->ipd_prev[bk][i]) >> 2;
IM(tempLeft)  = IM(ps->ipd_prev[bk][i]) >> 2;
RE(tempRight) = RE(ps->opd_prev[bk][i]) >> 2;
IM(tempRight) = IM(ps->opd_prev[bk][i]) >> 2;
#else
RE(tempLeft)  = MUL_F(RE(ps->ipd_prev[bk][i]), FRAC_CONST(0.25));
IM(tempLeft)  = MUL_F(IM(ps->ipd_prev[bk][i]), FRAC_CONST(0.25));
RE(tempRight) = MUL_F(RE(ps->opd_prev[bk][i]), FRAC_CONST(0.25));
IM(tempRight) = MUL_F(IM(ps->opd_prev[bk][i]), FRAC_CONST(0.25));
#endif
RE(ps->ipd_prev[bk][i]) = ipdopd_cos_tab[abs(ps->ipd_index[env][bk])];
IM(ps->ipd_prev[bk][i]) = ipdopd_sin_tab[abs(ps->ipd_index[env][bk])];
RE(ps->opd_prev[bk][i]) = ipdopd_cos_tab[abs(ps->opd_index[env][bk])];
IM(ps->opd_prev[bk][i]) = ipdopd_sin_tab[abs(ps->opd_index[env][bk])];
RE(tempLeft)  += RE(ps->ipd_prev[bk][i]);
IM(tempLeft)  += IM(ps->ipd_prev[bk][i]);
RE(tempRight) += RE(ps->opd_prev[bk][i]);
IM(tempRight) += IM(ps->opd_prev[bk][i]);
if (i == 0)
{
i = 2;
}
i--;
#ifdef FIXED_POINT
RE(tempLeft)  += (RE(ps->ipd_prev[bk][i]) >> 1);
IM(tempLeft)  += (IM(ps->ipd_prev[bk][i]) >> 1);
RE(tempRight) += (RE(ps->opd_prev[bk][i]) >> 1);
IM(tempRight) += (IM(ps->opd_prev[bk][i]) >> 1);
#else
RE(tempLeft)  += MUL_F(RE(ps->ipd_prev[bk][i]), FRAC_CONST(0.5));
IM(tempLeft)  += MUL_F(IM(ps->ipd_prev[bk][i]), FRAC_CONST(0.5));
RE(tempRight) += MUL_F(RE(ps->opd_prev[bk][i]), FRAC_CONST(0.5));
IM(tempRight) += MUL_F(IM(ps->opd_prev[bk][i]), FRAC_CONST(0.5));
#endif
#if 0 
ipd = (float)atan2(IM(tempLeft), RE(tempLeft));
opd = (float)atan2(IM(tempRight), RE(tempRight));
RE(phaseLeft) = (float)cos(opd);
IM(phaseLeft) = (float)sin(opd);
opd -= ipd;
RE(phaseRight) = (float)cos(opd);
IM(phaseRight) = (float)sin(opd);
#else
xy = magnitude_c(tempRight);
pq = magnitude_c(tempLeft);
if (xy != 0)
{
RE(phaseLeft) = DIV_R(RE(tempRight), xy);
IM(phaseLeft) = DIV_R(IM(tempRight), xy);
} else {
RE(phaseLeft) = 0;
IM(phaseLeft) = 0;
}
xypq = MUL_R(xy, pq);
if (xypq != 0)
{
real_t tmp1 = MUL_R(RE(tempRight), RE(tempLeft)) + MUL_R(IM(tempRight), IM(tempLeft));
real_t tmp2 = MUL_R(IM(tempRight), RE(tempLeft)) - MUL_R(RE(tempRight), IM(tempLeft));
RE(phaseRight) = DIV_R(tmp1, xypq);
IM(phaseRight) = DIV_R(tmp2, xypq);
} else {
RE(phaseRight) = 0;
IM(phaseRight) = 0;
}
#endif
IM(h11) = MUL_R(RE(h11), IM(phaseLeft));
IM(h12) = MUL_R(RE(h12), IM(phaseRight));
IM(h21) = MUL_R(RE(h21), IM(phaseLeft));
IM(h22) = MUL_R(RE(h22), IM(phaseRight));
RE(h11) = MUL_R(RE(h11), RE(phaseLeft));
RE(h12) = MUL_R(RE(h12), RE(phaseRight));
RE(h21) = MUL_R(RE(h21), RE(phaseLeft));
RE(h22) = MUL_R(RE(h22), RE(phaseRight));
}
L = (real_t)(ps->border_position[env + 1] - ps->border_position[env]);
RE(deltaH11) = (RE(h11) - RE(ps->h11_prev[gr])) / L;
RE(deltaH12) = (RE(h12) - RE(ps->h12_prev[gr])) / L;
RE(deltaH21) = (RE(h21) - RE(ps->h21_prev[gr])) / L;
RE(deltaH22) = (RE(h22) - RE(ps->h22_prev[gr])) / L;
RE(H11) = RE(ps->h11_prev[gr]);
RE(H12) = RE(ps->h12_prev[gr]);
RE(H21) = RE(ps->h21_prev[gr]);
RE(H22) = RE(ps->h22_prev[gr]);
RE(ps->h11_prev[gr]) = RE(h11);
RE(ps->h12_prev[gr]) = RE(h12);
RE(ps->h21_prev[gr]) = RE(h21);
RE(ps->h22_prev[gr]) = RE(h22);
if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))
{
IM(deltaH11) = (IM(h11) - IM(ps->h11_prev[gr])) / L;
IM(deltaH12) = (IM(h12) - IM(ps->h12_prev[gr])) / L;
IM(deltaH21) = (IM(h21) - IM(ps->h21_prev[gr])) / L;
IM(deltaH22) = (IM(h22) - IM(ps->h22_prev[gr])) / L;
IM(H11) = IM(ps->h11_prev[gr]);
IM(H12) = IM(ps->h12_prev[gr]);
IM(H21) = IM(ps->h21_prev[gr]);
IM(H22) = IM(ps->h22_prev[gr]);
if ((NEGATE_IPD_MASK & ps->map_group2bk[gr]) != 0)
{
IM(deltaH11) = -IM(deltaH11);
IM(deltaH12) = -IM(deltaH12);
IM(deltaH21) = -IM(deltaH21);
IM(deltaH22) = -IM(deltaH22);
IM(H11) = -IM(H11);
IM(H12) = -IM(H12);
IM(H21) = -IM(H21);
IM(H22) = -IM(H22);
}
IM(ps->h11_prev[gr]) = IM(h11);
IM(ps->h12_prev[gr]) = IM(h12);
IM(ps->h21_prev[gr]) = IM(h21);
IM(ps->h22_prev[gr]) = IM(h22);
}
for (n = ps->border_position[env]; n < ps->border_position[env + 1]; n++)
{
RE(H11) += RE(deltaH11);
RE(H12) += RE(deltaH12);
RE(H21) += RE(deltaH21);
RE(H22) += RE(deltaH22);
if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))
{
IM(H11) += IM(deltaH11);
IM(H12) += IM(deltaH12);
IM(H21) += IM(deltaH21);
IM(H22) += IM(deltaH22);
}
for (sb = ps->group_border[gr]; sb < maxsb; sb++)
{
complex_t inLeft, inRight;
if (gr < ps->num_hybrid_groups)
{
RE(inLeft) =  RE(X_hybrid_left[n][sb]);
IM(inLeft) =  IM(X_hybrid_left[n][sb]);
RE(inRight) = RE(X_hybrid_right[n][sb]);
IM(inRight) = IM(X_hybrid_right[n][sb]);
} else {
RE(inLeft) =  RE(X_left[n][sb]);
IM(inLeft) =  IM(X_left[n][sb]);
RE(inRight) = RE(X_right[n][sb]);
IM(inRight) = IM(X_right[n][sb]);
}
RE(tempLeft) =  MUL_C(RE(H11), RE(inLeft)) + MUL_C(RE(H21), RE(inRight));
IM(tempLeft) =  MUL_C(RE(H11), IM(inLeft)) + MUL_C(RE(H21), IM(inRight));
RE(tempRight) = MUL_C(RE(H12), RE(inLeft)) + MUL_C(RE(H22), RE(inRight));
IM(tempRight) = MUL_C(RE(H12), IM(inLeft)) + MUL_C(RE(H22), IM(inRight));
if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))
{
RE(tempLeft)  -= MUL_C(IM(H11), IM(inLeft)) + MUL_C(IM(H21), IM(inRight));
IM(tempLeft)  += MUL_C(IM(H11), RE(inLeft)) + MUL_C(IM(H21), RE(inRight));
RE(tempRight) -= MUL_C(IM(H12), IM(inLeft)) + MUL_C(IM(H22), IM(inRight));
IM(tempRight) += MUL_C(IM(H12), RE(inLeft)) + MUL_C(IM(H22), RE(inRight));
}
if (gr < ps->num_hybrid_groups)
{
RE(X_hybrid_left[n][sb])  = RE(tempLeft);
IM(X_hybrid_left[n][sb])  = IM(tempLeft);
RE(X_hybrid_right[n][sb]) = RE(tempRight);
IM(X_hybrid_right[n][sb]) = IM(tempRight);
} else {
RE(X_left[n][sb])  = RE(tempLeft);
IM(X_left[n][sb])  = IM(tempLeft);
RE(X_right[n][sb]) = RE(tempRight);
IM(X_right[n][sb]) = IM(tempRight);
}
}
}
ps->phase_hist++;
if (ps->phase_hist == 2)
{
ps->phase_hist = 0;
}
}
}
}","static void ps_mix_phase(ps_info *VAR_0, qmf_t VAR_1[38][64], qmf_t VAR_2[38][64],
qmf_t VAR_3[32][32], qmf_t VAR_4[32][32])
{
uint8_t VAR_5;
uint8_t VAR_6;
uint8_t VAR_7 = 0;
uint8_t VAR_8, VAR_9;
uint8_t VAR_10;
uint8_t VAR_11;
complex_t VAR_12, VAR_13, VAR_14, VAR_15;
complex_t VAR_16, VAR_17, VAR_18, VAR_19;
complex_t VAR_20, VAR_21, VAR_22, VAR_23;
complex_t VAR_24;
complex_t VAR_25;
complex_t VAR_26;
complex_t VAR_27;
real_t VAR_28;
const real_t *VAR_29;
uint8_t VAR_30;
if (VAR_0->iid_mode >= 3)
{
VAR_30 = 15;
VAR_29 = VAR_31;
} else {
VAR_30 = 7;
VAR_29 = VAR_32;
}
if (VAR_0->ipd_mode == 0 || VAR_0->ipd_mode == 3)
{
VAR_11 = 11; 
} else {
VAR_11 = VAR_0->nr_ipdopd_par;
}
for (VAR_6 = 0; VAR_6 < VAR_0->num_groups; VAR_6++)
{
VAR_7 = (~VAR_33) & VAR_0->map_group2bk[VAR_6];
VAR_9 = (VAR_6 < VAR_0->num_hybrid_groups) ? VAR_0->group_border[VAR_6] + 1 : VAR_0->group_border[VAR_6 + 1];
for (VAR_10 = 0; VAR_10 < VAR_0->num_env; VAR_10++)
{
if (VAR_0->icc_mode < 3)
{
real_t VAR_34, VAR_35;
real_t VAR_36, VAR_37;
real_t VAR_38, VAR_39;
real_t VAR_40, VAR_41;
real_t VAR_42, VAR_43;
VAR_34 = VAR_29[VAR_30 + VAR_0->iid_index[VAR_10][VAR_7]];
VAR_35 = VAR_29[VAR_30 - VAR_0->iid_index[VAR_10][VAR_7]];
VAR_36 = VAR_44[VAR_0->icc_index[VAR_10][VAR_7]];
VAR_37 = VAR_45[VAR_0->icc_index[VAR_10][VAR_7]];
if (VAR_0->iid_mode >= 3)
{
if (VAR_0->iid_index[VAR_10][VAR_7] < 0)
{
VAR_38 =  VAR_46[-VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];
VAR_39 = -VAR_47[-VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];
} else {
VAR_38 = VAR_46[VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];
VAR_39 = VAR_47[VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];
}
} else {
if (VAR_0->iid_index[VAR_10][VAR_7] < 0)
{
VAR_38 =  VAR_48[-VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];
VAR_39 = -VAR_49[-VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];
} else {
VAR_38 = VAR_48[VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];
VAR_39 = VAR_49[VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];
}
}
VAR_40 = MUL_C(VAR_38, VAR_36);
VAR_41 = MUL_C(VAR_39, VAR_37);
VAR_42 = MUL_C(VAR_39, VAR_36);
VAR_43 = MUL_C(VAR_38, VAR_37);
RE(VAR_12) = MUL_C(VAR_35, (VAR_40 - VAR_41));
RE(VAR_13) = MUL_C(VAR_34, (VAR_40 + VAR_41));
RE(VAR_14) = MUL_C(VAR_35, (VAR_42 + VAR_43));
RE(VAR_15) = MUL_C(VAR_34, (VAR_42 - VAR_43));
} else {
real_t VAR_37, VAR_36;
real_t VAR_50, VAR_51;
if (VAR_0->iid_mode >= 3)
{
uint8_t VAR_52 = abs(VAR_0->iid_index[VAR_10][VAR_7]);
VAR_36 = VAR_53[VAR_30 + VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];
VAR_37 = VAR_53[30 - (VAR_30 + VAR_0->iid_index[VAR_10][VAR_7])][VAR_0->icc_index[VAR_10][VAR_7]];
VAR_50 = VAR_54[VAR_52][VAR_0->icc_index[VAR_10][VAR_7]];
VAR_51 = VAR_55[VAR_52][VAR_0->icc_index[VAR_10][VAR_7]];
} else {
uint8_t VAR_52 = abs(VAR_0->iid_index[VAR_10][VAR_7]);
VAR_36 = VAR_56[VAR_30 + VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];
VAR_37 = VAR_56[14 - (VAR_30 + VAR_0->iid_index[VAR_10][VAR_7])][VAR_0->icc_index[VAR_10][VAR_7]];
VAR_50 = VAR_57[VAR_52][VAR_0->icc_index[VAR_10][VAR_7]];
VAR_51 = VAR_58[VAR_52][VAR_0->icc_index[VAR_10][VAR_7]];
}
RE(VAR_12) = MUL_C(VAR_59, MUL_C(VAR_36, VAR_50));
RE(VAR_13) = MUL_C(VAR_59, MUL_C(VAR_37, VAR_50));
RE(VAR_14) = MUL_C(VAR_59, MUL_C(-VAR_36, VAR_51));
RE(VAR_15) = MUL_C(VAR_59, MUL_C(VAR_37, VAR_51));
}
if ((VAR_0->enable_ipdopd) && (VAR_7 < VAR_11))
{
int8_t VAR_60;
real_t VAR_61, VAR_62, VAR_63;
VAR_60 = VAR_0->phase_hist;
#ifdef VAR_64
RE(VAR_24)  = RE(VAR_0->ipd_prev[VAR_7][VAR_60]) >> 2;
IM(VAR_24)  = IM(VAR_0->ipd_prev[VAR_7][VAR_60]) >> 2;
RE(VAR_25) = RE(VAR_0->opd_prev[VAR_7][VAR_60]) >> 2;
IM(VAR_25) = IM(VAR_0->opd_prev[VAR_7][VAR_60]) >> 2;
#else
RE(VAR_24)  = MUL_F(RE(VAR_0->ipd_prev[VAR_7][VAR_60]), FRAC_CONST(0.25));
IM(VAR_24)  = MUL_F(IM(VAR_0->ipd_prev[VAR_7][VAR_60]), FRAC_CONST(0.25));
RE(VAR_25) = MUL_F(RE(VAR_0->opd_prev[VAR_7][VAR_60]), FRAC_CONST(0.25));
IM(VAR_25) = MUL_F(IM(VAR_0->opd_prev[VAR_7][VAR_60]), FRAC_CONST(0.25));
#endif
RE(VAR_0->ipd_prev[VAR_7][VAR_60]) = VAR_65[abs(VAR_0->ipd_index[VAR_10][VAR_7])];
IM(VAR_0->ipd_prev[VAR_7][VAR_60]) = VAR_66[abs(VAR_0->ipd_index[VAR_10][VAR_7])];
RE(VAR_0->opd_prev[VAR_7][VAR_60]) = VAR_65[abs(VAR_0->opd_index[VAR_10][VAR_7])];
IM(VAR_0->opd_prev[VAR_7][VAR_60]) = VAR_66[abs(VAR_0->opd_index[VAR_10][VAR_7])];
RE(VAR_24)  += RE(VAR_0->ipd_prev[VAR_7][VAR_60]);
IM(VAR_24)  += IM(VAR_0->ipd_prev[VAR_7][VAR_60]);
RE(VAR_25) += RE(VAR_0->opd_prev[VAR_7][VAR_60]);
IM(VAR_25) += IM(VAR_0->opd_prev[VAR_7][VAR_60]);
if (VAR_60 == 0)
{
VAR_60 = 2;
}
VAR_60--;
#ifdef VAR_64
RE(VAR_24)  += (RE(VAR_0->ipd_prev[VAR_7][VAR_60]) >> 1);
IM(VAR_24)  += (IM(VAR_0->ipd_prev[VAR_7][VAR_60]) >> 1);
RE(VAR_25) += (RE(VAR_0->opd_prev[VAR_7][VAR_60]) >> 1);
IM(VAR_25) += (IM(VAR_0->opd_prev[VAR_7][VAR_60]) >> 1);
#else
RE(VAR_24)  += MUL_F(RE(VAR_0->ipd_prev[VAR_7][VAR_60]), FRAC_CONST(0.5));
IM(VAR_24)  += MUL_F(IM(VAR_0->ipd_prev[VAR_7][VAR_60]), FRAC_CONST(0.5));
RE(VAR_25) += MUL_F(RE(VAR_0->opd_prev[VAR_7][VAR_60]), FRAC_CONST(0.5));
IM(VAR_25) += MUL_F(IM(VAR_0->opd_prev[VAR_7][VAR_60]), FRAC_CONST(0.5));
#endif
#if 0 
VAR_67 = (float)atan2(IM(VAR_24), RE(VAR_24));
VAR_68 = (float)atan2(IM(VAR_25), RE(VAR_25));
RE(VAR_26) = (float)cos(VAR_68);
IM(VAR_26) = (float)sin(VAR_68);
VAR_68 -= VAR_67;
RE(VAR_27) = (float)cos(VAR_68);
IM(VAR_27) = (float)sin(VAR_68);
#else
VAR_61 = magnitude_c(VAR_25);
VAR_62 = magnitude_c(VAR_24);
if (VAR_61 != 0)
{
RE(VAR_26) = DIV_R(RE(VAR_25), VAR_61);
IM(VAR_26) = DIV_R(IM(VAR_25), VAR_61);
} else {
RE(VAR_26) = 0;
IM(VAR_26) = 0;
}
VAR_63 = MUL_R(VAR_61, VAR_62);
if (VAR_63 != 0)
{
real_t VAR_69 = MUL_R(RE(VAR_25), RE(VAR_24)) + MUL_R(IM(VAR_25), IM(VAR_24));
real_t VAR_70 = MUL_R(IM(VAR_25), RE(VAR_24)) - MUL_R(RE(VAR_25), IM(VAR_24));
RE(VAR_27) = DIV_R(VAR_69, VAR_63);
IM(VAR_27) = DIV_R(VAR_70, VAR_63);
} else {
RE(VAR_27) = 0;
IM(VAR_27) = 0;
}
#endif
IM(VAR_12) = MUL_R(RE(VAR_12), IM(VAR_26));
IM(VAR_13) = MUL_R(RE(VAR_13), IM(VAR_27));
IM(VAR_14) = MUL_R(RE(VAR_14), IM(VAR_26));
IM(VAR_15) = MUL_R(RE(VAR_15), IM(VAR_27));
RE(VAR_12) = MUL_R(RE(VAR_12), RE(VAR_26));
RE(VAR_13) = MUL_R(RE(VAR_13), RE(VAR_27));
RE(VAR_14) = MUL_R(RE(VAR_14), RE(VAR_26));
RE(VAR_15) = MUL_R(RE(VAR_15), RE(VAR_27));
}
VAR_28 = (real_t)(VAR_0->border_position[VAR_10 + 1] - VAR_0->border_position[VAR_10]);
RE(VAR_20) = (RE(VAR_12) - RE(VAR_0->h11_prev[VAR_6])) / VAR_28;
RE(VAR_21) = (RE(VAR_13) - RE(VAR_0->h12_prev[VAR_6])) / VAR_28;
RE(VAR_22) = (RE(VAR_14) - RE(VAR_0->h21_prev[VAR_6])) / VAR_28;
RE(VAR_23) = (RE(VAR_15) - RE(VAR_0->h22_prev[VAR_6])) / VAR_28;
RE(VAR_16) = RE(VAR_0->h11_prev[VAR_6]);
RE(VAR_17) = RE(VAR_0->h12_prev[VAR_6]);
RE(VAR_18) = RE(VAR_0->h21_prev[VAR_6]);
RE(VAR_19) = RE(VAR_0->h22_prev[VAR_6]);
RE(VAR_0->h11_prev[VAR_6]) = RE(VAR_12);
RE(VAR_0->h12_prev[VAR_6]) = RE(VAR_13);
RE(VAR_0->h21_prev[VAR_6]) = RE(VAR_14);
RE(VAR_0->h22_prev[VAR_6]) = RE(VAR_15);
if ((VAR_0->enable_ipdopd) && (VAR_7 < VAR_11))
{
IM(VAR_20) = (IM(VAR_12) - IM(VAR_0->h11_prev[VAR_6])) / VAR_28;
IM(VAR_21) = (IM(VAR_13) - IM(VAR_0->h12_prev[VAR_6])) / VAR_28;
IM(VAR_22) = (IM(VAR_14) - IM(VAR_0->h21_prev[VAR_6])) / VAR_28;
IM(VAR_23) = (IM(VAR_15) - IM(VAR_0->h22_prev[VAR_6])) / VAR_28;
IM(VAR_16) = IM(VAR_0->h11_prev[VAR_6]);
IM(VAR_17) = IM(VAR_0->h12_prev[VAR_6]);
IM(VAR_18) = IM(VAR_0->h21_prev[VAR_6]);
IM(VAR_19) = IM(VAR_0->h22_prev[VAR_6]);
if ((VAR_33 & VAR_0->map_group2bk[VAR_6]) != 0)
{
IM(VAR_20) = -IM(VAR_20);
IM(VAR_21) = -IM(VAR_21);
IM(VAR_22) = -IM(VAR_22);
IM(VAR_23) = -IM(VAR_23);
IM(VAR_16) = -IM(VAR_16);
IM(VAR_17) = -IM(VAR_17);
IM(VAR_18) = -IM(VAR_18);
IM(VAR_19) = -IM(VAR_19);
}
IM(VAR_0->h11_prev[VAR_6]) = IM(VAR_12);
IM(VAR_0->h12_prev[VAR_6]) = IM(VAR_13);
IM(VAR_0->h21_prev[VAR_6]) = IM(VAR_14);
IM(VAR_0->h22_prev[VAR_6]) = IM(VAR_15);
}
for (VAR_5 = VAR_0->border_position[VAR_10]; VAR_5 < VAR_0->border_position[VAR_10 + 1]; VAR_5++)
{
RE(VAR_16) += RE(VAR_20);
RE(VAR_17) += RE(VAR_21);
RE(VAR_18) += RE(VAR_22);
RE(VAR_19) += RE(VAR_23);
if ((VAR_0->enable_ipdopd) && (VAR_7 < VAR_11))
{
IM(VAR_16) += IM(VAR_20);
IM(VAR_17) += IM(VAR_21);
IM(VAR_18) += IM(VAR_22);
IM(VAR_19) += IM(VAR_23);
}
for (VAR_8 = VAR_0->group_border[VAR_6]; VAR_8 < VAR_9; VAR_8++)
{
complex_t VAR_71, VAR_72;
if (VAR_6 < VAR_0->num_hybrid_groups)
{
RE(VAR_71) =  RE(VAR_3[VAR_5][VAR_8]);
IM(VAR_71) =  IM(VAR_3[VAR_5][VAR_8]);
RE(VAR_72) = RE(VAR_4[VAR_5][VAR_8]);
IM(VAR_72) = IM(VAR_4[VAR_5][VAR_8]);
} else {
RE(VAR_71) =  RE(VAR_1[VAR_5][VAR_8]);
IM(VAR_71) =  IM(VAR_1[VAR_5][VAR_8]);
RE(VAR_72) = RE(VAR_2[VAR_5][VAR_8]);
IM(VAR_72) = IM(VAR_2[VAR_5][VAR_8]);
}
RE(VAR_24) =  MUL_C(RE(VAR_16), RE(VAR_71)) + MUL_C(RE(VAR_18), RE(VAR_72));
IM(VAR_24) =  MUL_C(RE(VAR_16), IM(VAR_71)) + MUL_C(RE(VAR_18), IM(VAR_72));
RE(VAR_25) = MUL_C(RE(VAR_17), RE(VAR_71)) + MUL_C(RE(VAR_19), RE(VAR_72));
IM(VAR_25) = MUL_C(RE(VAR_17), IM(VAR_71)) + MUL_C(RE(VAR_19), IM(VAR_72));
if ((VAR_0->enable_ipdopd) && (VAR_7 < VAR_11))
{
RE(VAR_24)  -= MUL_C(IM(VAR_16), IM(VAR_71)) + MUL_C(IM(VAR_18), IM(VAR_72));
IM(VAR_24)  += MUL_C(IM(VAR_16), RE(VAR_71)) + MUL_C(IM(VAR_18), RE(VAR_72));
RE(VAR_25) -= MUL_C(IM(VAR_17), IM(VAR_71)) + MUL_C(IM(VAR_19), IM(VAR_72));
IM(VAR_25) += MUL_C(IM(VAR_17), RE(VAR_71)) + MUL_C(IM(VAR_19), RE(VAR_72));
}
if (VAR_6 < VAR_0->num_hybrid_groups)
{
RE(VAR_3[VAR_5][VAR_8])  = RE(VAR_24);
IM(VAR_3[VAR_5][VAR_8])  = IM(VAR_24);
RE(VAR_4[VAR_5][VAR_8]) = RE(VAR_25);
IM(VAR_4[VAR_5][VAR_8]) = IM(VAR_25);
} else {
RE(VAR_1[VAR_5][VAR_8])  = RE(VAR_24);
IM(VAR_1[VAR_5][VAR_8])  = IM(VAR_24);
RE(VAR_2[VAR_5][VAR_8]) = RE(VAR_25);
IM(VAR_2[VAR_5][VAR_8]) = IM(VAR_25);
}
}
}
VAR_0->phase_hist++;
if (VAR_0->phase_hist == 2)
{
VAR_0->phase_hist = 0;
}
}
}
}",knik0/faad2/6823e6610c9af1b0080cb22b9da03efb208d7d57/ps_dec.c/vul/before/0.json,"static void ps_mix_phase(ps_info *ps, qmf_t X_left[38][64], qmf_t X_right[38][64],
                         qmf_t X_hybrid_left[32][32], qmf_t X_hybrid_right[32][32])
{
    uint8_t n;
    uint8_t gr;
    uint8_t bk = 0;
    uint8_t sb, maxsb;
    uint8_t env;
    uint8_t nr_ipdopd_par;
    complex_t h11, h12, h21, h22;
    complex_t H11, H12, H21, H22;
    complex_t deltaH11, deltaH12, deltaH21, deltaH22;
    complex_t tempLeft;
    complex_t tempRight;
    complex_t phaseLeft;
    complex_t phaseRight;
    real_t L;
    const real_t *sf_iid;
    uint8_t no_iid_steps;

    if (ps->iid_mode >= 3)
    {
        no_iid_steps = 15;
        sf_iid = sf_iid_fine;
    } else {
        no_iid_steps = 7;
        sf_iid = sf_iid_normal;
    }

    if (ps->ipd_mode == 0 || ps->ipd_mode == 3)
    {
        nr_ipdopd_par = 11; /* resolution */
    } else {
        nr_ipdopd_par = ps->nr_ipdopd_par;
    }

    for (gr = 0; gr < ps->num_groups; gr++)
    {
        bk = (~NEGATE_IPD_MASK) & ps->map_group2bk[gr];

        /* use one channel per group in the subqmf domain */
        maxsb = (gr < ps->num_hybrid_groups) ? ps->group_border[gr] + 1 : ps->group_border[gr + 1];

        for (env = 0; env < ps->num_env; env++)
        {
            if (ps->icc_mode < 3)
            {
                /* type 'A' mixing as described in 8.6.4.6.2.1 */
                real_t c_1, c_2;
                real_t cosa, sina;
                real_t cosb, sinb;
                real_t ab1, ab2;
                real_t ab3, ab4;

                /*
                c_1 = sqrt(2.0 / (1.0 + pow(10.0, quant_iid[no_iid_steps + iid_index] / 10.0)));
                c_2 = sqrt(2.0 / (1.0 + pow(10.0, quant_iid[no_iid_steps - iid_index] / 10.0)));
                alpha = 0.5 * acos(quant_rho[icc_index]);
                beta = alpha * ( c_1 - c_2 ) / sqrt(2.0);
                */

                //printf(""%d\n"", ps->iid_index[env][bk]);

                /* index range is supposed to be -7...7 or -15...15 depending on iid_mode
                   (Table 8.24, ISO/IEC 14496-3:2005).
                   if it is outside these boundaries, this is most likely an error. sanitize
                   it and try to process further. */
                if (ps->iid_index[env][bk] < -no_iid_steps) {
                    fprintf(stderr, ""Warning: invalid iid_index: %d < %d\n"", ps->iid_index[env][bk],
                        -no_iid_steps);
                    ps->iid_index[env][bk] = -no_iid_steps;
                } else if (ps->iid_index[env][bk] > no_iid_steps) {
                    fprintf(stderr, ""Warning: invalid iid_index: %d > %d\n"", ps->iid_index[env][bk],
                        no_iid_steps);
                    ps->iid_index[env][bk] = no_iid_steps;
                }

                /* calculate the scalefactors c_1 and c_2 from the intensity differences */
                c_1 = sf_iid[no_iid_steps + ps->iid_index[env][bk]];
                c_2 = sf_iid[no_iid_steps - ps->iid_index[env][bk]];

                /* calculate alpha and beta using the ICC parameters */
                cosa = cos_alphas[ps->icc_index[env][bk]];
                sina = sin_alphas[ps->icc_index[env][bk]];

                if (ps->iid_mode >= 3)
                {
                    if (ps->iid_index[env][bk] < 0)
                    {
                        cosb =  cos_betas_fine[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];
                        sinb = -sin_betas_fine[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];
                    } else {
                        cosb = cos_betas_fine[ps->iid_index[env][bk]][ps->icc_index[env][bk]];
                        sinb = sin_betas_fine[ps->iid_index[env][bk]][ps->icc_index[env][bk]];
                    }
                } else {
                    if (ps->iid_index[env][bk] < 0)
                    {
                        cosb =  cos_betas_normal[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];
                        sinb = -sin_betas_normal[-ps->iid_index[env][bk]][ps->icc_index[env][bk]];
                    } else {
                        cosb = cos_betas_normal[ps->iid_index[env][bk]][ps->icc_index[env][bk]];
                        sinb = sin_betas_normal[ps->iid_index[env][bk]][ps->icc_index[env][bk]];
                    }
                }

                ab1 = MUL_C(cosb, cosa);
                ab2 = MUL_C(sinb, sina);
                ab3 = MUL_C(sinb, cosa);
                ab4 = MUL_C(cosb, sina);

                /* h_xy: COEF */
                RE(h11) = MUL_C(c_2, (ab1 - ab2));
                RE(h12) = MUL_C(c_1, (ab1 + ab2));
                RE(h21) = MUL_C(c_2, (ab3 + ab4));
                RE(h22) = MUL_C(c_1, (ab3 - ab4));
            } else {
                /* type 'B' mixing as described in 8.6.4.6.2.2 */
                real_t sina, cosa;
                real_t cosg, sing;

                /*
                real_t c, rho, mu, alpha, gamma;
                uint8_t i;

                i = ps->iid_index[env][bk];
                c = (real_t)pow(10.0, ((i)?(((i>0)?1:-1)*quant_iid[((i>0)?i:-i)-1]):0.)/20.0);
                rho = quant_rho[ps->icc_index[env][bk]];

                if (rho == 0.0f && c == 1.)
                {
                    alpha = (real_t)M_PI/4.0f;
                    rho = 0.05f;
                } else {
                    if (rho <= 0.05f)
                    {
                        rho = 0.05f;
                    }
                    alpha = 0.5f*(real_t)atan( (2.0f*c*rho) / (c*c-1.0f) );

                    if (alpha < 0.)
                    {
                        alpha += (real_t)M_PI/2.0f;
                    }
                    if (rho < 0.)
                    {
                        alpha += (real_t)M_PI;
                    }
                }
                mu = c+1.0f/c;
                mu = 1+(4.0f*rho*rho-4.0f)/(mu*mu);
                gamma = (real_t)atan(sqrt((1.0f-sqrt(mu))/(1.0f+sqrt(mu))));
                */

                if (ps->iid_mode >= 3)
                {
                    uint8_t abs_iid = abs(ps->iid_index[env][bk]);

                    cosa = sincos_alphas_B_fine[no_iid_steps + ps->iid_index[env][bk]][ps->icc_index[env][bk]];
                    sina = sincos_alphas_B_fine[30 - (no_iid_steps + ps->iid_index[env][bk])][ps->icc_index[env][bk]];
                    cosg = cos_gammas_fine[abs_iid][ps->icc_index[env][bk]];
                    sing = sin_gammas_fine[abs_iid][ps->icc_index[env][bk]];
                } else {
                    uint8_t abs_iid = abs(ps->iid_index[env][bk]);

                    cosa = sincos_alphas_B_normal[no_iid_steps + ps->iid_index[env][bk]][ps->icc_index[env][bk]];
                    sina = sincos_alphas_B_normal[14 - (no_iid_steps + ps->iid_index[env][bk])][ps->icc_index[env][bk]];
                    cosg = cos_gammas_normal[abs_iid][ps->icc_index[env][bk]];
                    sing = sin_gammas_normal[abs_iid][ps->icc_index[env][bk]];
                }

                RE(h11) = MUL_C(COEF_SQRT2, MUL_C(cosa, cosg));
                RE(h12) = MUL_C(COEF_SQRT2, MUL_C(sina, cosg));
                RE(h21) = MUL_C(COEF_SQRT2, MUL_C(-cosa, sing));
                RE(h22) = MUL_C(COEF_SQRT2, MUL_C(sina, sing));
            }

            /* calculate phase rotation parameters H_xy */
            /* note that the imaginary part of these parameters are only calculated when
               IPD and OPD are enabled
             */
            if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))
            {
                int8_t i;
                real_t xy, pq, xypq;

                /* ringbuffer index */
                i = ps->phase_hist;

                /* previous value */
#ifdef FIXED_POINT
                /* divide by 4, shift right 2 bits */
                RE(tempLeft)  = RE(ps->ipd_prev[bk][i]) >> 2;
                IM(tempLeft)  = IM(ps->ipd_prev[bk][i]) >> 2;
                RE(tempRight) = RE(ps->opd_prev[bk][i]) >> 2;
                IM(tempRight) = IM(ps->opd_prev[bk][i]) >> 2;
#else
                RE(tempLeft)  = MUL_F(RE(ps->ipd_prev[bk][i]), FRAC_CONST(0.25));
                IM(tempLeft)  = MUL_F(IM(ps->ipd_prev[bk][i]), FRAC_CONST(0.25));
                RE(tempRight) = MUL_F(RE(ps->opd_prev[bk][i]), FRAC_CONST(0.25));
                IM(tempRight) = MUL_F(IM(ps->opd_prev[bk][i]), FRAC_CONST(0.25));
#endif

                /* save current value */
                RE(ps->ipd_prev[bk][i]) = ipdopd_cos_tab[abs(ps->ipd_index[env][bk])];
                IM(ps->ipd_prev[bk][i]) = ipdopd_sin_tab[abs(ps->ipd_index[env][bk])];
                RE(ps->opd_prev[bk][i]) = ipdopd_cos_tab[abs(ps->opd_index[env][bk])];
                IM(ps->opd_prev[bk][i]) = ipdopd_sin_tab[abs(ps->opd_index[env][bk])];

                /* add current value */
                RE(tempLeft)  += RE(ps->ipd_prev[bk][i]);
                IM(tempLeft)  += IM(ps->ipd_prev[bk][i]);
                RE(tempRight) += RE(ps->opd_prev[bk][i]);
                IM(tempRight) += IM(ps->opd_prev[bk][i]);

                /* ringbuffer index */
                if (i == 0)
                {
                    i = 2;
                }
                i--;

                /* get value before previous */
#ifdef FIXED_POINT
                /* dividing by 2, shift right 1 bit */
                RE(tempLeft)  += (RE(ps->ipd_prev[bk][i]) >> 1);
                IM(tempLeft)  += (IM(ps->ipd_prev[bk][i]) >> 1);
                RE(tempRight) += (RE(ps->opd_prev[bk][i]) >> 1);
                IM(tempRight) += (IM(ps->opd_prev[bk][i]) >> 1);
#else
                RE(tempLeft)  += MUL_F(RE(ps->ipd_prev[bk][i]), FRAC_CONST(0.5));
                IM(tempLeft)  += MUL_F(IM(ps->ipd_prev[bk][i]), FRAC_CONST(0.5));
                RE(tempRight) += MUL_F(RE(ps->opd_prev[bk][i]), FRAC_CONST(0.5));
                IM(tempRight) += MUL_F(IM(ps->opd_prev[bk][i]), FRAC_CONST(0.5));
#endif

#if 0 /* original code */
                ipd = (float)atan2(IM(tempLeft), RE(tempLeft));
                opd = (float)atan2(IM(tempRight), RE(tempRight));

                /* phase rotation */
                RE(phaseLeft) = (float)cos(opd);
                IM(phaseLeft) = (float)sin(opd);
                opd -= ipd;
                RE(phaseRight) = (float)cos(opd);
                IM(phaseRight) = (float)sin(opd);
#else

                // x = IM(tempLeft)
                // y = RE(tempLeft)
                // p = IM(tempRight)
                // q = RE(tempRight)
                // cos(atan2(x,y)) = y/sqrt((x*x) + (y*y))
                // sin(atan2(x,y)) = x/sqrt((x*x) + (y*y))
                // cos(atan2(x,y)-atan2(p,q)) = (y*q + x*p) / ( sqrt((x*x) + (y*y)) * sqrt((p*p) + (q*q)) );
                // sin(atan2(x,y)-atan2(p,q)) = (x*q - y*p) / ( sqrt((x*x) + (y*y)) * sqrt((p*p) + (q*q)) );

                xy = magnitude_c(tempRight);
                pq = magnitude_c(tempLeft);

                if (xy != 0)
                {
                    RE(phaseLeft) = DIV_R(RE(tempRight), xy);
                    IM(phaseLeft) = DIV_R(IM(tempRight), xy);
                } else {
                    RE(phaseLeft) = 0;
                    IM(phaseLeft) = 0;
                }

                xypq = MUL_R(xy, pq);

                if (xypq != 0)
                {
                    real_t tmp1 = MUL_R(RE(tempRight), RE(tempLeft)) + MUL_R(IM(tempRight), IM(tempLeft));
                    real_t tmp2 = MUL_R(IM(tempRight), RE(tempLeft)) - MUL_R(RE(tempRight), IM(tempLeft));

                    RE(phaseRight) = DIV_R(tmp1, xypq);
                    IM(phaseRight) = DIV_R(tmp2, xypq);
                } else {
                    RE(phaseRight) = 0;
                    IM(phaseRight) = 0;
                }

#endif

                /* MUL_F(COEF, REAL) = COEF */
                IM(h11) = MUL_R(RE(h11), IM(phaseLeft));
                IM(h12) = MUL_R(RE(h12), IM(phaseRight));
                IM(h21) = MUL_R(RE(h21), IM(phaseLeft));
                IM(h22) = MUL_R(RE(h22), IM(phaseRight));

                RE(h11) = MUL_R(RE(h11), RE(phaseLeft));
                RE(h12) = MUL_R(RE(h12), RE(phaseRight));
                RE(h21) = MUL_R(RE(h21), RE(phaseLeft));
                RE(h22) = MUL_R(RE(h22), RE(phaseRight));
            }

            /* length of the envelope n_e+1 - n_e (in time samples) */
            /* 0 < L <= 32: integer */
            L = (real_t)(ps->border_position[env + 1] - ps->border_position[env]);

            /* obtain final H_xy by means of linear interpolation */
            RE(deltaH11) = (RE(h11) - RE(ps->h11_prev[gr])) / L;
            RE(deltaH12) = (RE(h12) - RE(ps->h12_prev[gr])) / L;
            RE(deltaH21) = (RE(h21) - RE(ps->h21_prev[gr])) / L;
            RE(deltaH22) = (RE(h22) - RE(ps->h22_prev[gr])) / L;

            RE(H11) = RE(ps->h11_prev[gr]);
            RE(H12) = RE(ps->h12_prev[gr]);
            RE(H21) = RE(ps->h21_prev[gr]);
            RE(H22) = RE(ps->h22_prev[gr]);

            RE(ps->h11_prev[gr]) = RE(h11);
            RE(ps->h12_prev[gr]) = RE(h12);
            RE(ps->h21_prev[gr]) = RE(h21);
            RE(ps->h22_prev[gr]) = RE(h22);

            /* only calculate imaginary part when needed */
            if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))
            {
                /* obtain final H_xy by means of linear interpolation */
                IM(deltaH11) = (IM(h11) - IM(ps->h11_prev[gr])) / L;
                IM(deltaH12) = (IM(h12) - IM(ps->h12_prev[gr])) / L;
                IM(deltaH21) = (IM(h21) - IM(ps->h21_prev[gr])) / L;
                IM(deltaH22) = (IM(h22) - IM(ps->h22_prev[gr])) / L;

                IM(H11) = IM(ps->h11_prev[gr]);
                IM(H12) = IM(ps->h12_prev[gr]);
                IM(H21) = IM(ps->h21_prev[gr]);
                IM(H22) = IM(ps->h22_prev[gr]);

                if ((NEGATE_IPD_MASK & ps->map_group2bk[gr]) != 0)
                {
                    IM(deltaH11) = -IM(deltaH11);
                    IM(deltaH12) = -IM(deltaH12);
                    IM(deltaH21) = -IM(deltaH21);
                    IM(deltaH22) = -IM(deltaH22);

                    IM(H11) = -IM(H11);
                    IM(H12) = -IM(H12);
                    IM(H21) = -IM(H21);
                    IM(H22) = -IM(H22);
                }

                IM(ps->h11_prev[gr]) = IM(h11);
                IM(ps->h12_prev[gr]) = IM(h12);
                IM(ps->h21_prev[gr]) = IM(h21);
                IM(ps->h22_prev[gr]) = IM(h22);
            }

            /* apply H_xy to the current envelope band of the decorrelated subband */
            for (n = ps->border_position[env]; n < ps->border_position[env + 1]; n++)
            {
                /* addition finalises the interpolation over every n */
                RE(H11) += RE(deltaH11);
                RE(H12) += RE(deltaH12);
                RE(H21) += RE(deltaH21);
                RE(H22) += RE(deltaH22);
                if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))
                {
                    IM(H11) += IM(deltaH11);
                    IM(H12) += IM(deltaH12);
                    IM(H21) += IM(deltaH21);
                    IM(H22) += IM(deltaH22);
                }

                /* channel is an alias to the subband */
                for (sb = ps->group_border[gr]; sb < maxsb; sb++)
                {
                    complex_t inLeft, inRight;

                    /* load decorrelated samples */
                    if (gr < ps->num_hybrid_groups)
                    {
                        RE(inLeft) =  RE(X_hybrid_left[n][sb]);
                        IM(inLeft) =  IM(X_hybrid_left[n][sb]);
                        RE(inRight) = RE(X_hybrid_right[n][sb]);
                        IM(inRight) = IM(X_hybrid_right[n][sb]);
                    } else {
                        RE(inLeft) =  RE(X_left[n][sb]);
                        IM(inLeft) =  IM(X_left[n][sb]);
                        RE(inRight) = RE(X_right[n][sb]);
                        IM(inRight) = IM(X_right[n][sb]);
                    }

                    /* apply mixing */
                    RE(tempLeft) =  MUL_C(RE(H11), RE(inLeft)) + MUL_C(RE(H21), RE(inRight));
                    IM(tempLeft) =  MUL_C(RE(H11), IM(inLeft)) + MUL_C(RE(H21), IM(inRight));
                    RE(tempRight) = MUL_C(RE(H12), RE(inLeft)) + MUL_C(RE(H22), RE(inRight));
                    IM(tempRight) = MUL_C(RE(H12), IM(inLeft)) + MUL_C(RE(H22), IM(inRight));

                    /* only perform imaginary operations when needed */
                    if ((ps->enable_ipdopd) && (bk < nr_ipdopd_par))
                    {
                        /* apply rotation */
                        RE(tempLeft)  -= MUL_C(IM(H11), IM(inLeft)) + MUL_C(IM(H21), IM(inRight));
                        IM(tempLeft)  += MUL_C(IM(H11), RE(inLeft)) + MUL_C(IM(H21), RE(inRight));
                        RE(tempRight) -= MUL_C(IM(H12), IM(inLeft)) + MUL_C(IM(H22), IM(inRight));
                        IM(tempRight) += MUL_C(IM(H12), RE(inLeft)) + MUL_C(IM(H22), RE(inRight));
                    }

                    /* store final samples */
                    if (gr < ps->num_hybrid_groups)
                    {
                        RE(X_hybrid_left[n][sb])  = RE(tempLeft);
                        IM(X_hybrid_left[n][sb])  = IM(tempLeft);
                        RE(X_hybrid_right[n][sb]) = RE(tempRight);
                        IM(X_hybrid_right[n][sb]) = IM(tempRight);
                    } else {
                        RE(X_left[n][sb])  = RE(tempLeft);
                        IM(X_left[n][sb])  = IM(tempLeft);
                        RE(X_right[n][sb]) = RE(tempRight);
                        IM(X_right[n][sb]) = IM(tempRight);
                    }
                }
            }

            /* shift phase smoother's circular buffer index */
            ps->phase_hist++;
            if (ps->phase_hist == 2)
            {
                ps->phase_hist = 0;
            }
        }
    }
}","static void ps_mix_phase(ps_info *VAR_0, qmf_t VAR_1[38][64], qmf_t VAR_2[38][64],
                         qmf_t VAR_3[32][32], qmf_t VAR_4[32][32])
{
    uint8_t VAR_5;
    uint8_t VAR_6;
    uint8_t VAR_7 = 0;
    uint8_t VAR_8, VAR_9;
    uint8_t VAR_10;
    uint8_t VAR_11;
    complex_t VAR_12, VAR_13, VAR_14, VAR_15;
    complex_t VAR_16, VAR_17, VAR_18, VAR_19;
    complex_t VAR_20, VAR_21, VAR_22, VAR_23;
    complex_t VAR_24;
    complex_t VAR_25;
    complex_t VAR_26;
    complex_t VAR_27;
    real_t VAR_28;
    const real_t *VAR_29;
    uint8_t VAR_30;

    if (VAR_0->iid_mode >= 3)
    {
        VAR_30 = 15;
        VAR_29 = VAR_31;
    } else {
        VAR_30 = 7;
        VAR_29 = VAR_32;
    }

    if (VAR_0->ipd_mode == 0 || VAR_0->ipd_mode == 3)
    {
        VAR_11 = 11; /* COMMENT_0 */
    } else {
        VAR_11 = VAR_0->nr_ipdopd_par;
    }

    for (VAR_6 = 0; VAR_6 < VAR_0->num_groups; VAR_6++)
    {
        VAR_7 = (~VAR_33) & VAR_0->map_group2bk[VAR_6];

        /* COMMENT_1 */
        VAR_9 = (VAR_6 < VAR_0->num_hybrid_groups) ? VAR_0->group_border[VAR_6] + 1 : VAR_0->group_border[VAR_6 + 1];

        for (VAR_10 = 0; VAR_10 < VAR_0->num_env; VAR_10++)
        {
            if (VAR_0->icc_mode < 3)
            {
                /* COMMENT_2 */
                real_t VAR_34, VAR_35;
                real_t VAR_36, VAR_37;
                real_t VAR_38, VAR_39;
                real_t VAR_40, VAR_41;
                real_t VAR_42, VAR_43;

                /* COMMENT_3 */
                                                                                                
                                                                                                
                                                         
                                                         
                  

                /* COMMENT_9 */

                /* COMMENT_10 */
                                                      
                                                                                            
                                                    
                if (VAR_0->iid_index[VAR_10][VAR_7] < -VAR_30) {
                    fprintf(VAR_44, ""Warning: invalid iid_index: %d < %d\n"", VAR_0->iid_index[VAR_10][VAR_7],
                        -VAR_30);
                    VAR_0->iid_index[VAR_10][VAR_7] = -VAR_30;
                } else if (VAR_0->iid_index[VAR_10][VAR_7] > VAR_30) {
                    fprintf(VAR_44, ""Warning: invalid iid_index: %d > %d\n"", VAR_0->iid_index[VAR_10][VAR_7],
                        VAR_30);
                    VAR_0->iid_index[VAR_10][VAR_7] = VAR_30;
                }

                /* COMMENT_14 */
                VAR_34 = VAR_29[VAR_30 + VAR_0->iid_index[VAR_10][VAR_7]];
                VAR_35 = VAR_29[VAR_30 - VAR_0->iid_index[VAR_10][VAR_7]];

                /* COMMENT_15 */
                VAR_36 = VAR_45[VAR_0->icc_index[VAR_10][VAR_7]];
                VAR_37 = VAR_46[VAR_0->icc_index[VAR_10][VAR_7]];

                if (VAR_0->iid_mode >= 3)
                {
                    if (VAR_0->iid_index[VAR_10][VAR_7] < 0)
                    {
                        VAR_38 =  VAR_47[-VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];
                        VAR_39 = -VAR_48[-VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];
                    } else {
                        VAR_38 = VAR_47[VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];
                        VAR_39 = VAR_48[VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];
                    }
                } else {
                    if (VAR_0->iid_index[VAR_10][VAR_7] < 0)
                    {
                        VAR_38 =  VAR_49[-VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];
                        VAR_39 = -VAR_50[-VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];
                    } else {
                        VAR_38 = VAR_49[VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];
                        VAR_39 = VAR_50[VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];
                    }
                }

                VAR_40 = MUL_C(VAR_38, VAR_36);
                VAR_41 = MUL_C(VAR_39, VAR_37);
                VAR_42 = MUL_C(VAR_39, VAR_36);
                VAR_43 = MUL_C(VAR_38, VAR_37);

                /* COMMENT_16 */
                RE(VAR_12) = MUL_C(VAR_35, (VAR_40 - VAR_41));
                RE(VAR_13) = MUL_C(VAR_34, (VAR_40 + VAR_41));
                RE(VAR_14) = MUL_C(VAR_35, (VAR_42 + VAR_43));
                RE(VAR_15) = MUL_C(VAR_34, (VAR_42 - VAR_43));
            } else {
                /* COMMENT_17 */
                real_t VAR_37, VAR_36;
                real_t VAR_51, VAR_52;

                /* COMMENT_18 */
                                                
                          

                                           
                                                                                              
                                                        

                                           
                 
                                              
                                
                        
                                     
                     
                                    
                     
                                                                           

                                   
                     
                                                   
                     
                                 
                     
                                              
                     
                 
                              
                                                   
                                                                            
                  

                if (VAR_0->iid_mode >= 3)
                {
                    uint8_t VAR_53 = abs(VAR_0->iid_index[VAR_10][VAR_7]);

                    VAR_36 = VAR_54[VAR_30 + VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];
                    VAR_37 = VAR_54[30 - (VAR_30 + VAR_0->iid_index[VAR_10][VAR_7])][VAR_0->icc_index[VAR_10][VAR_7]];
                    VAR_51 = VAR_55[VAR_53][VAR_0->icc_index[VAR_10][VAR_7]];
                    VAR_52 = VAR_56[VAR_53][VAR_0->icc_index[VAR_10][VAR_7]];
                } else {
                    uint8_t VAR_53 = abs(VAR_0->iid_index[VAR_10][VAR_7]);

                    VAR_36 = VAR_57[VAR_30 + VAR_0->iid_index[VAR_10][VAR_7]][VAR_0->icc_index[VAR_10][VAR_7]];
                    VAR_37 = VAR_57[14 - (VAR_30 + VAR_0->iid_index[VAR_10][VAR_7])][VAR_0->icc_index[VAR_10][VAR_7]];
                    VAR_51 = VAR_58[VAR_53][VAR_0->icc_index[VAR_10][VAR_7]];
                    VAR_52 = VAR_59[VAR_53][VAR_0->icc_index[VAR_10][VAR_7]];
                }

                RE(VAR_12) = MUL_C(VAR_60, MUL_C(VAR_36, VAR_51));
                RE(VAR_13) = MUL_C(VAR_60, MUL_C(VAR_37, VAR_51));
                RE(VAR_14) = MUL_C(VAR_60, MUL_C(-VAR_36, VAR_52));
                RE(VAR_15) = MUL_C(VAR_60, MUL_C(VAR_37, VAR_52));
            }

            /* COMMENT_44 */
            /* COMMENT_45 */
                                      
               
            if ((VAR_0->enable_ipdopd) && (VAR_7 < VAR_11))
            {
                int8_t VAR_61;
                real_t VAR_62, VAR_63, VAR_64;

                /* COMMENT_48 */
                VAR_61 = VAR_0->phase_hist;

                /* COMMENT_49 */
#ifdef VAR_65
                /* COMMENT_50 */
                RE(VAR_24)  = RE(VAR_0->ipd_prev[VAR_7][VAR_61]) >> 2;
                IM(VAR_24)  = IM(VAR_0->ipd_prev[VAR_7][VAR_61]) >> 2;
                RE(VAR_25) = RE(VAR_0->opd_prev[VAR_7][VAR_61]) >> 2;
                IM(VAR_25) = IM(VAR_0->opd_prev[VAR_7][VAR_61]) >> 2;
#else
                RE(VAR_24)  = MUL_F(RE(VAR_0->ipd_prev[VAR_7][VAR_61]), FRAC_CONST(0.25));
                IM(VAR_24)  = MUL_F(IM(VAR_0->ipd_prev[VAR_7][VAR_61]), FRAC_CONST(0.25));
                RE(VAR_25) = MUL_F(RE(VAR_0->opd_prev[VAR_7][VAR_61]), FRAC_CONST(0.25));
                IM(VAR_25) = MUL_F(IM(VAR_0->opd_prev[VAR_7][VAR_61]), FRAC_CONST(0.25));
#endif

                /* COMMENT_51 */
                RE(VAR_0->ipd_prev[VAR_7][VAR_61]) = VAR_66[abs(VAR_0->ipd_index[VAR_10][VAR_7])];
                IM(VAR_0->ipd_prev[VAR_7][VAR_61]) = VAR_67[abs(VAR_0->ipd_index[VAR_10][VAR_7])];
                RE(VAR_0->opd_prev[VAR_7][VAR_61]) = VAR_66[abs(VAR_0->opd_index[VAR_10][VAR_7])];
                IM(VAR_0->opd_prev[VAR_7][VAR_61]) = VAR_67[abs(VAR_0->opd_index[VAR_10][VAR_7])];

                /* COMMENT_52 */
                RE(VAR_24)  += RE(VAR_0->ipd_prev[VAR_7][VAR_61]);
                IM(VAR_24)  += IM(VAR_0->ipd_prev[VAR_7][VAR_61]);
                RE(VAR_25) += RE(VAR_0->opd_prev[VAR_7][VAR_61]);
                IM(VAR_25) += IM(VAR_0->opd_prev[VAR_7][VAR_61]);

                /* COMMENT_48 */
                if (VAR_61 == 0)
                {
                    VAR_61 = 2;
                }
                VAR_61--;

                /* COMMENT_53 */
#ifdef VAR_65
                /* COMMENT_54 */
                RE(VAR_24)  += (RE(VAR_0->ipd_prev[VAR_7][VAR_61]) >> 1);
                IM(VAR_24)  += (IM(VAR_0->ipd_prev[VAR_7][VAR_61]) >> 1);
                RE(VAR_25) += (RE(VAR_0->opd_prev[VAR_7][VAR_61]) >> 1);
                IM(VAR_25) += (IM(VAR_0->opd_prev[VAR_7][VAR_61]) >> 1);
#else
                RE(VAR_24)  += MUL_F(RE(VAR_0->ipd_prev[VAR_7][VAR_61]), FRAC_CONST(0.5));
                IM(VAR_24)  += MUL_F(IM(VAR_0->ipd_prev[VAR_7][VAR_61]), FRAC_CONST(0.5));
                RE(VAR_25) += MUL_F(RE(VAR_0->opd_prev[VAR_7][VAR_61]), FRAC_CONST(0.5));
                IM(VAR_25) += MUL_F(IM(VAR_0->opd_prev[VAR_7][VAR_61]), FRAC_CONST(0.5));
#endif

#if 0 /* COMMENT_55 */
                VAR_68 = (float)atan2(IM(VAR_24), RE(VAR_24));
                VAR_69 = (float)atan2(IM(VAR_25), RE(VAR_25));

                /* COMMENT_56 */
                RE(VAR_26) = (float)cos(VAR_69);
                IM(VAR_26) = (float)sin(VAR_69);
                VAR_69 -= VAR_68;
                RE(VAR_27) = (float)cos(VAR_69);
                IM(VAR_27) = (float)sin(VAR_69);
#else

                /* COMMENT_57 */
                /* COMMENT_58 */
                /* COMMENT_59 */
                /* COMMENT_60 */
                /* COMMENT_61 */
                /* COMMENT_62 */
                /* COMMENT_63 */
                /* COMMENT_64 */

                VAR_62 = magnitude_c(VAR_25);
                VAR_63 = magnitude_c(VAR_24);

                if (VAR_62 != 0)
                {
                    RE(VAR_26) = DIV_R(RE(VAR_25), VAR_62);
                    IM(VAR_26) = DIV_R(IM(VAR_25), VAR_62);
                } else {
                    RE(VAR_26) = 0;
                    IM(VAR_26) = 0;
                }

                VAR_64 = MUL_R(VAR_62, VAR_63);

                if (VAR_64 != 0)
                {
                    real_t VAR_70 = MUL_R(RE(VAR_25), RE(VAR_24)) + MUL_R(IM(VAR_25), IM(VAR_24));
                    real_t VAR_71 = MUL_R(IM(VAR_25), RE(VAR_24)) - MUL_R(RE(VAR_25), IM(VAR_24));

                    RE(VAR_27) = DIV_R(VAR_70, VAR_64);
                    IM(VAR_27) = DIV_R(VAR_71, VAR_64);
                } else {
                    RE(VAR_27) = 0;
                    IM(VAR_27) = 0;
                }

#endif

                /* COMMENT_65 */
                IM(VAR_12) = MUL_R(RE(VAR_12), IM(VAR_26));
                IM(VAR_13) = MUL_R(RE(VAR_13), IM(VAR_27));
                IM(VAR_14) = MUL_R(RE(VAR_14), IM(VAR_26));
                IM(VAR_15) = MUL_R(RE(VAR_15), IM(VAR_27));

                RE(VAR_12) = MUL_R(RE(VAR_12), RE(VAR_26));
                RE(VAR_13) = MUL_R(RE(VAR_13), RE(VAR_27));
                RE(VAR_14) = MUL_R(RE(VAR_14), RE(VAR_26));
                RE(VAR_15) = MUL_R(RE(VAR_15), RE(VAR_27));
            }

            /* COMMENT_66 */
            /* COMMENT_67 */
            VAR_28 = (real_t)(VAR_0->border_position[VAR_10 + 1] - VAR_0->border_position[VAR_10]);

            /* COMMENT_68 */
            RE(VAR_20) = (RE(VAR_12) - RE(VAR_0->h11_prev[VAR_6])) / VAR_28;
            RE(VAR_21) = (RE(VAR_13) - RE(VAR_0->h12_prev[VAR_6])) / VAR_28;
            RE(VAR_22) = (RE(VAR_14) - RE(VAR_0->h21_prev[VAR_6])) / VAR_28;
            RE(VAR_23) = (RE(VAR_15) - RE(VAR_0->h22_prev[VAR_6])) / VAR_28;

            RE(VAR_16) = RE(VAR_0->h11_prev[VAR_6]);
            RE(VAR_17) = RE(VAR_0->h12_prev[VAR_6]);
            RE(VAR_18) = RE(VAR_0->h21_prev[VAR_6]);
            RE(VAR_19) = RE(VAR_0->h22_prev[VAR_6]);

            RE(VAR_0->h11_prev[VAR_6]) = RE(VAR_12);
            RE(VAR_0->h12_prev[VAR_6]) = RE(VAR_13);
            RE(VAR_0->h21_prev[VAR_6]) = RE(VAR_14);
            RE(VAR_0->h22_prev[VAR_6]) = RE(VAR_15);

            /* COMMENT_69 */
            if ((VAR_0->enable_ipdopd) && (VAR_7 < VAR_11))
            {
                /* COMMENT_68 */
                IM(VAR_20) = (IM(VAR_12) - IM(VAR_0->h11_prev[VAR_6])) / VAR_28;
                IM(VAR_21) = (IM(VAR_13) - IM(VAR_0->h12_prev[VAR_6])) / VAR_28;
                IM(VAR_22) = (IM(VAR_14) - IM(VAR_0->h21_prev[VAR_6])) / VAR_28;
                IM(VAR_23) = (IM(VAR_15) - IM(VAR_0->h22_prev[VAR_6])) / VAR_28;

                IM(VAR_16) = IM(VAR_0->h11_prev[VAR_6]);
                IM(VAR_17) = IM(VAR_0->h12_prev[VAR_6]);
                IM(VAR_18) = IM(VAR_0->h21_prev[VAR_6]);
                IM(VAR_19) = IM(VAR_0->h22_prev[VAR_6]);

                if ((VAR_33 & VAR_0->map_group2bk[VAR_6]) != 0)
                {
                    IM(VAR_20) = -IM(VAR_20);
                    IM(VAR_21) = -IM(VAR_21);
                    IM(VAR_22) = -IM(VAR_22);
                    IM(VAR_23) = -IM(VAR_23);

                    IM(VAR_16) = -IM(VAR_16);
                    IM(VAR_17) = -IM(VAR_17);
                    IM(VAR_18) = -IM(VAR_18);
                    IM(VAR_19) = -IM(VAR_19);
                }

                IM(VAR_0->h11_prev[VAR_6]) = IM(VAR_12);
                IM(VAR_0->h12_prev[VAR_6]) = IM(VAR_13);
                IM(VAR_0->h21_prev[VAR_6]) = IM(VAR_14);
                IM(VAR_0->h22_prev[VAR_6]) = IM(VAR_15);
            }

            /* COMMENT_70 */
            for (VAR_5 = VAR_0->border_position[VAR_10]; VAR_5 < VAR_0->border_position[VAR_10 + 1]; VAR_5++)
            {
                /* COMMENT_71 */
                RE(VAR_16) += RE(VAR_20);
                RE(VAR_17) += RE(VAR_21);
                RE(VAR_18) += RE(VAR_22);
                RE(VAR_19) += RE(VAR_23);
                if ((VAR_0->enable_ipdopd) && (VAR_7 < VAR_11))
                {
                    IM(VAR_16) += IM(VAR_20);
                    IM(VAR_17) += IM(VAR_21);
                    IM(VAR_18) += IM(VAR_22);
                    IM(VAR_19) += IM(VAR_23);
                }

                /* COMMENT_72 */
                for (VAR_8 = VAR_0->group_border[VAR_6]; VAR_8 < VAR_9; VAR_8++)
                {
                    complex_t VAR_72, VAR_73;

                    /* COMMENT_73 */
                    if (VAR_6 < VAR_0->num_hybrid_groups)
                    {
                        RE(VAR_72) =  RE(VAR_3[VAR_5][VAR_8]);
                        IM(VAR_72) =  IM(VAR_3[VAR_5][VAR_8]);
                        RE(VAR_73) = RE(VAR_4[VAR_5][VAR_8]);
                        IM(VAR_73) = IM(VAR_4[VAR_5][VAR_8]);
                    } else {
                        RE(VAR_72) =  RE(VAR_1[VAR_5][VAR_8]);
                        IM(VAR_72) =  IM(VAR_1[VAR_5][VAR_8]);
                        RE(VAR_73) = RE(VAR_2[VAR_5][VAR_8]);
                        IM(VAR_73) = IM(VAR_2[VAR_5][VAR_8]);
                    }

                    /* COMMENT_74 */
                    RE(VAR_24) =  MUL_C(RE(VAR_16), RE(VAR_72)) + MUL_C(RE(VAR_18), RE(VAR_73));
                    IM(VAR_24) =  MUL_C(RE(VAR_16), IM(VAR_72)) + MUL_C(RE(VAR_18), IM(VAR_73));
                    RE(VAR_25) = MUL_C(RE(VAR_17), RE(VAR_72)) + MUL_C(RE(VAR_19), RE(VAR_73));
                    IM(VAR_25) = MUL_C(RE(VAR_17), IM(VAR_72)) + MUL_C(RE(VAR_19), IM(VAR_73));

                    /* COMMENT_75 */
                    if ((VAR_0->enable_ipdopd) && (VAR_7 < VAR_11))
                    {
                        /* COMMENT_76 */
                        RE(VAR_24)  -= MUL_C(IM(VAR_16), IM(VAR_72)) + MUL_C(IM(VAR_18), IM(VAR_73));
                        IM(VAR_24)  += MUL_C(IM(VAR_16), RE(VAR_72)) + MUL_C(IM(VAR_18), RE(VAR_73));
                        RE(VAR_25) -= MUL_C(IM(VAR_17), IM(VAR_72)) + MUL_C(IM(VAR_19), IM(VAR_73));
                        IM(VAR_25) += MUL_C(IM(VAR_17), RE(VAR_72)) + MUL_C(IM(VAR_19), RE(VAR_73));
                    }

                    /* COMMENT_77 */
                    if (VAR_6 < VAR_0->num_hybrid_groups)
                    {
                        RE(VAR_3[VAR_5][VAR_8])  = RE(VAR_24);
                        IM(VAR_3[VAR_5][VAR_8])  = IM(VAR_24);
                        RE(VAR_4[VAR_5][VAR_8]) = RE(VAR_25);
                        IM(VAR_4[VAR_5][VAR_8]) = IM(VAR_25);
                    } else {
                        RE(VAR_1[VAR_5][VAR_8])  = RE(VAR_24);
                        IM(VAR_1[VAR_5][VAR_8])  = IM(VAR_24);
                        RE(VAR_2[VAR_5][VAR_8]) = RE(VAR_25);
                        IM(VAR_2[VAR_5][VAR_8]) = IM(VAR_25);
                    }
                }
            }

            /* COMMENT_78 */
            VAR_0->phase_hist++;
            if (VAR_0->phase_hist == 2)
            {
                VAR_0->phase_hist = 0;
            }
        }
    }
}",knik0/faad2/6823e6610c9af1b0080cb22b9da03efb208d7d57/ps_dec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -61,6 +61,20 @@
 
                 //printf(""%d\n"", ps->iid_index[env][bk]);
 
+                /* index range is supposed to be -7...7 or -15...15 depending on iid_mode
+                   (Table 8.24, ISO/IEC 14496-3:2005).
+                   if it is outside these boundaries, this is most likely an error. sanitize
+                   it and try to process further. */
+                if (ps->iid_index[env][bk] < -no_iid_steps) {
+                    fprintf(stderr, ""Warning: invalid iid_index: %d < %d\n"", ps->iid_index[env][bk],
+                        -no_iid_steps);
+                    ps->iid_index[env][bk] = -no_iid_steps;
+                } else if (ps->iid_index[env][bk] > no_iid_steps) {
+                    fprintf(stderr, ""Warning: invalid iid_index: %d > %d\n"", ps->iid_index[env][bk],
+                        no_iid_steps);
+                    ps->iid_index[env][bk] = no_iid_steps;
+                }
+
                 /* calculate the scalefactors c_1 and c_2 from the intensity differences */
                 c_1 = sf_iid[no_iid_steps + ps->iid_index[env][bk]];
                 c_2 = sf_iid[no_iid_steps - ps->iid_index[env][bk]];","{'deleted_lines': [], 'added_lines': ['                /* index range is supposed to be -7...7 or -15...15 depending on iid_mode', '                   (Table 8.24, ISO/IEC 14496-3:2005).', '                   if it is outside these boundaries, this is most likely an error. sanitize', '                   it and try to process further. */', '                if (ps->iid_index[env][bk] < -no_iid_steps) {', '                    fprintf(stderr, ""Warning: invalid iid_index: %d < %d\\n"", ps->iid_index[env][bk],', '                        -no_iid_steps);', '                    ps->iid_index[env][bk] = -no_iid_steps;', '                } else if (ps->iid_index[env][bk] > no_iid_steps) {', '                    fprintf(stderr, ""Warning: invalid iid_index: %d > %d\\n"", ps->iid_index[env][bk],', '                        no_iid_steps);', '                    ps->iid_index[env][bk] = no_iid_steps;', '                }', '']}",True,"An invalid memory address dereference was discovered in the sbr_process_channel function of libfaad/sbr_dec.c in Freeware Advanced Audio Decoder 2 (FAAD2) 2.8.8. The vulnerability causes a segmentation fault and application crash, which leads to denial of service.",5.5,MEDIUM,1,valid,2019-08-23T12:08:19Z,3
CVE-2019-15786,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ROBOTIS-GIT/DynamixelSDK,- fixed buffer overflow bug (rxpacket size),12a709bdbd268d66d0b2a07e817610b7da0a71f9,https://github.com/ROBOTIS-GIT/DynamixelSDK/commit/12a709bdbd268d66d0b2a07e817610b7da0a71f9,ros/src/dynamixel_sdk/protocol2_packet_handler.cpp,Protocol2PacketHandler::readRx,"int Protocol2PacketHandler::readRx(PortHandler *port, uint8_t id, uint16_t length, uint8_t *data, uint8_t *error)
{
int result                  = COMM_TX_FAIL;
uint8_t *rxpacket           = (uint8_t *)malloc(length + 11 + (length / 3));
if (rxpacket == NULL)
return result;
do {
result = rxPacket(port, rxpacket);
} while (result == COMM_SUCCESS && rxpacket[PKT_ID] != id);
if (result == COMM_SUCCESS && rxpacket[PKT_ID] == id)
{
if (error != 0)
*error = (uint8_t)rxpacket[PKT_ERROR];
for (uint16_t s = 0; s < length; s++)
{
data[s] = rxpacket[PKT_PARAMETER0 + 1 + s];
}
}
free(rxpacket);
return result;
}","int Protocol2PacketHandler::readRx(PortHandler *VAR_0, uint8_t VAR_1, uint16_t VAR_2, uint8_t *VAR_3, uint8_t *VAR_4)
{
int VAR_5                  = VAR_6;
uint8_t *VAR_7           = (uint8_t *)malloc(VAR_2 + 11 + (VAR_2 / 3));
if (VAR_7 == NULL)
return VAR_5;
do {
VAR_5 = rxPacket(VAR_0, VAR_7);
} while (VAR_5 == VAR_8 && VAR_7[VAR_9] != VAR_1);
if (VAR_5 == VAR_8 && VAR_7[VAR_9] == VAR_1)
{
if (VAR_4 != 0)
*VAR_4 = (uint8_t)VAR_7[VAR_10];
for (uint16_t VAR_11 = 0; VAR_11 < VAR_2; VAR_11++)
{
VAR_3[VAR_11] = VAR_7[VAR_12 + 1 + VAR_11];
}
}
free(VAR_7);
return VAR_5;
}",ROBOTIS-GIT/DynamixelSDK/12a709bdbd268d66d0b2a07e817610b7da0a71f9/protocol2_packet_handler.cpp/vul/before/1.json,"int Protocol2PacketHandler::readRx(PortHandler *port, uint8_t id, uint16_t length, uint8_t *data, uint8_t *error)
{
  int result                  = COMM_TX_FAIL;
  uint8_t *rxpacket           = (uint8_t *)malloc(RXPACKET_MAX_LEN);
  //(length + 11 + (length/3));  // (length/3): consider stuffing
  
  if (rxpacket == NULL)
    return result;
  
  do {
    result = rxPacket(port, rxpacket);
  } while (result == COMM_SUCCESS && rxpacket[PKT_ID] != id);

  if (result == COMM_SUCCESS && rxpacket[PKT_ID] == id)
  {
    if (error != 0)
      *error = (uint8_t)rxpacket[PKT_ERROR];

    for (uint16_t s = 0; s < length; s++)
    {
      data[s] = rxpacket[PKT_PARAMETER0 + 1 + s];
    }
    //memcpy(data, &rxpacket[PKT_PARAMETER0+1], length);
  }

  free(rxpacket);
  //delete[] rxpacket;
  return result;
}","int Protocol2PacketHandler::readRx(PortHandler *VAR_0, uint8_t VAR_1, uint16_t VAR_2, uint8_t *VAR_3, uint8_t *VAR_4)
{
  int VAR_5                  = VAR_6;
  uint8_t *VAR_7           = (uint8_t *)malloc(VAR_8);
  /* COMMENT_0 */
  
  if (VAR_7 == NULL)
    return VAR_5;
  
  do {
    VAR_5 = rxPacket(VAR_0, VAR_7);
  } while (VAR_5 == VAR_9 && VAR_7[VAR_10] != VAR_1);

  if (VAR_5 == VAR_9 && VAR_7[VAR_10] == VAR_1)
  {
    if (VAR_4 != 0)
      *VAR_4 = (uint8_t)VAR_7[VAR_11];

    for (uint16_t VAR_12 = 0; VAR_12 < VAR_2; VAR_12++)
    {
      VAR_3[VAR_12] = VAR_7[VAR_13 + 1 + VAR_12];
    }
    /* COMMENT_1 */
  }

  free(VAR_7);
  /* COMMENT_2 */
  return VAR_5;
}",ROBOTIS-GIT/DynamixelSDK/12a709bdbd268d66d0b2a07e817610b7da0a71f9/protocol2_packet_handler.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 int Protocol2PacketHandler::readRx(PortHandler *port, uint8_t id, uint16_t length, uint8_t *data, uint8_t *error)
 {
   int result                  = COMM_TX_FAIL;
-  uint8_t *rxpacket           = (uint8_t *)malloc(length + 11 + (length / 3));
+  uint8_t *rxpacket           = (uint8_t *)malloc(RXPACKET_MAX_LEN);
   //(length + 11 + (length/3));  // (length/3): consider stuffing
   
   if (rxpacket == NULL)","{'deleted_lines': ['  uint8_t *rxpacket           = (uint8_t *)malloc(length + 11 + (length / 3));'], 'added_lines': ['  uint8_t *rxpacket           = (uint8_t *)malloc(RXPACKET_MAX_LEN);']}",True,ROBOTIS Dynamixel SDK through 3.7.11 has a buffer overflow via a large rxpacket.,9.8,CRITICAL,3,valid,2019-08-27T04:28:17Z,3
CVE-2019-15786,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ROBOTIS-GIT/DynamixelSDK,- fixed buffer overflow bug (rxpacket size),12a709bdbd268d66d0b2a07e817610b7da0a71f9,https://github.com/ROBOTIS-GIT/DynamixelSDK/commit/12a709bdbd268d66d0b2a07e817610b7da0a71f9,ros/src/dynamixel_sdk/protocol2_packet_handler.cpp,Protocol2PacketHandler::readTxRx,"int Protocol2PacketHandler::readTxRx(PortHandler *port, uint8_t id, uint16_t address, uint16_t length, uint8_t *data, uint8_t *error)
{
int result                  = COMM_TX_FAIL;
uint8_t txpacket[14]        = {0};
uint8_t *rxpacket           = (uint8_t *)malloc(length + 11 + (length / 3));
if (rxpacket == NULL)
return result;
if (id >= BROADCAST_ID)
return COMM_NOT_AVAILABLE;
txpacket[PKT_ID]            = id;
txpacket[PKT_LENGTH_L]      = 7;
txpacket[PKT_LENGTH_H]      = 0;
txpacket[PKT_INSTRUCTION]   = INST_READ;
txpacket[PKT_PARAMETER0+0]  = (uint8_t)DXL_LOBYTE(address);
txpacket[PKT_PARAMETER0+1]  = (uint8_t)DXL_HIBYTE(address);
txpacket[PKT_PARAMETER0+2]  = (uint8_t)DXL_LOBYTE(length);
txpacket[PKT_PARAMETER0+3]  = (uint8_t)DXL_HIBYTE(length);
result = txRxPacket(port, txpacket, rxpacket, error);
if (result == COMM_SUCCESS)
{
if (error != 0)
*error = (uint8_t)rxpacket[PKT_ERROR];
for (uint16_t s = 0; s < length; s++)
{
data[s] = rxpacket[PKT_PARAMETER0 + 1 + s];
}
}
free(rxpacket);
return result;
}","int Protocol2PacketHandler::readTxRx(PortHandler *VAR_0, uint8_t VAR_1, uint16_t VAR_2, uint16_t VAR_3, uint8_t *VAR_4, uint8_t *VAR_5)
{
int VAR_6                  = VAR_7;
uint8_t VAR_8[14]        = {0};
uint8_t *VAR_9           = (uint8_t *)malloc(VAR_3 + 11 + (VAR_3 / 3));
if (VAR_9 == NULL)
return VAR_6;
if (VAR_1 >= VAR_10)
return VAR_11;
VAR_8[VAR_12]            = VAR_1;
VAR_8[VAR_13]      = 7;
VAR_8[VAR_14]      = 0;
VAR_8[VAR_15]   = VAR_16;
VAR_8[VAR_17+0]  = (uint8_t)DXL_LOBYTE(VAR_2);
VAR_8[VAR_17+1]  = (uint8_t)DXL_HIBYTE(VAR_2);
VAR_8[VAR_17+2]  = (uint8_t)DXL_LOBYTE(VAR_3);
VAR_8[VAR_17+3]  = (uint8_t)DXL_HIBYTE(VAR_3);
VAR_6 = txRxPacket(VAR_0, VAR_8, VAR_9, VAR_5);
if (VAR_6 == VAR_18)
{
if (VAR_5 != 0)
*VAR_5 = (uint8_t)VAR_9[VAR_19];
for (uint16_t VAR_20 = 0; VAR_20 < VAR_3; VAR_20++)
{
VAR_4[VAR_20] = VAR_9[VAR_17 + 1 + VAR_20];
}
}
free(VAR_9);
return VAR_6;
}",ROBOTIS-GIT/DynamixelSDK/12a709bdbd268d66d0b2a07e817610b7da0a71f9/protocol2_packet_handler.cpp/vul/before/0.json,"int Protocol2PacketHandler::readTxRx(PortHandler *port, uint8_t id, uint16_t address, uint16_t length, uint8_t *data, uint8_t *error)
{
  int result                  = COMM_TX_FAIL;

  uint8_t txpacket[14]        = {0};
  uint8_t *rxpacket           = (uint8_t *)malloc(RXPACKET_MAX_LEN);
  //(length + 11 + (length/3));  // (length/3): consider stuffing

  if (rxpacket == NULL)
    return result;
  
  if (id >= BROADCAST_ID)
    return COMM_NOT_AVAILABLE;

  txpacket[PKT_ID]            = id;
  txpacket[PKT_LENGTH_L]      = 7;
  txpacket[PKT_LENGTH_H]      = 0;
  txpacket[PKT_INSTRUCTION]   = INST_READ;
  txpacket[PKT_PARAMETER0+0]  = (uint8_t)DXL_LOBYTE(address);
  txpacket[PKT_PARAMETER0+1]  = (uint8_t)DXL_HIBYTE(address);
  txpacket[PKT_PARAMETER0+2]  = (uint8_t)DXL_LOBYTE(length);
  txpacket[PKT_PARAMETER0+3]  = (uint8_t)DXL_HIBYTE(length);

  result = txRxPacket(port, txpacket, rxpacket, error);
  if (result == COMM_SUCCESS)
  {
    if (error != 0)
      *error = (uint8_t)rxpacket[PKT_ERROR];

    for (uint16_t s = 0; s < length; s++)
    {
      data[s] = rxpacket[PKT_PARAMETER0 + 1 + s];
    }
    //memcpy(data, &rxpacket[PKT_PARAMETER0+1], length);
  }

  free(rxpacket);
  //delete[] rxpacket;
  return result;
}","int Protocol2PacketHandler::readTxRx(PortHandler *VAR_0, uint8_t VAR_1, uint16_t VAR_2, uint16_t VAR_3, uint8_t *VAR_4, uint8_t *VAR_5)
{
  int VAR_6                  = VAR_7;

  uint8_t VAR_8[14]        = {0};
  uint8_t *VAR_9           = (uint8_t *)malloc(VAR_10);
  /* COMMENT_0 */

  if (VAR_9 == NULL)
    return VAR_6;
  
  if (VAR_1 >= VAR_11)
    return VAR_12;

  VAR_8[VAR_13]            = VAR_1;
  VAR_8[VAR_14]      = 7;
  VAR_8[VAR_15]      = 0;
  VAR_8[VAR_16]   = VAR_17;
  VAR_8[VAR_18+0]  = (uint8_t)DXL_LOBYTE(VAR_2);
  VAR_8[VAR_18+1]  = (uint8_t)DXL_HIBYTE(VAR_2);
  VAR_8[VAR_18+2]  = (uint8_t)DXL_LOBYTE(VAR_3);
  VAR_8[VAR_18+3]  = (uint8_t)DXL_HIBYTE(VAR_3);

  VAR_6 = txRxPacket(VAR_0, VAR_8, VAR_9, VAR_5);
  if (VAR_6 == VAR_19)
  {
    if (VAR_5 != 0)
      *VAR_5 = (uint8_t)VAR_9[VAR_20];

    for (uint16_t VAR_21 = 0; VAR_21 < VAR_3; VAR_21++)
    {
      VAR_4[VAR_21] = VAR_9[VAR_18 + 1 + VAR_21];
    }
    /* COMMENT_1 */
  }

  free(VAR_9);
  /* COMMENT_2 */
  return VAR_6;
}",ROBOTIS-GIT/DynamixelSDK/12a709bdbd268d66d0b2a07e817610b7da0a71f9/protocol2_packet_handler.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
   int result                  = COMM_TX_FAIL;
 
   uint8_t txpacket[14]        = {0};
-  uint8_t *rxpacket           = (uint8_t *)malloc(length + 11 + (length / 3));
+  uint8_t *rxpacket           = (uint8_t *)malloc(RXPACKET_MAX_LEN);
   //(length + 11 + (length/3));  // (length/3): consider stuffing
 
   if (rxpacket == NULL)","{'deleted_lines': ['  uint8_t *rxpacket           = (uint8_t *)malloc(length + 11 + (length / 3));'], 'added_lines': ['  uint8_t *rxpacket           = (uint8_t *)malloc(RXPACKET_MAX_LEN);']}",True,ROBOTIS Dynamixel SDK through 3.7.11 has a buffer overflow via a large rxpacket.,9.8,CRITICAL,3,valid,2019-08-27T04:28:17Z,3
CVE-2019-16319,['CWE-835'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,wireshark,"Gryphon: Prevent endless loop

Bug: 16020
Change-Id: I59c24d3bdb3f3a85f6e498683594ee12db9642a8
Reviewed-on: https://code.wireshark.org/review/34392
Reviewed-by: Michael Mann <mmann78@netscape.net>
Petri-Dish: Michael Mann <mmann78@netscape.net>
Tested-by: Petri Dish Buildbot
Reviewed-by: Anders Broman <a.broman58@gmail.com>
(cherry picked from commit 627917faff4889f763bf8e6570f62d66656047bd)
Reviewed-on: https://code.wireshark.org/review/34396",02ddd49885c6a09e936a76aceb726ed06539704a,https://github.com/wireshark/wireshark/commit/02ddd49885c6a09e936a76aceb726ed06539704a,plugins/epan/gryphon/packet-gryphon.c,dissect_gryphon_message_with_offset,"static int
dissect_gryphon_message_with_offset(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree, gboolean is_msgresp_add)
{
proto_tree      *gryphon_tree;
proto_item      *ti;
proto_tree      *header_tree, *body_tree;
int             msgend;
int             msglen, msgpad;
unsigned int    src, dest, i, frmtyp;
guint8          flags;
if (!is_msgresp_add) {
col_set_str(pinfo->cinfo, COL_PROTOCOL, ""Gryphon"");
col_clear(pinfo->cinfo, COL_INFO);
}
if (!is_msgresp_add) {
ti = proto_tree_add_item(tree, proto_gryphon, tvb, 0, -1, ENC_NA);
gryphon_tree = proto_item_add_subtree(ti, ett_gryphon);
} else
gryphon_tree = tree;
src = tvb_get_guint8(tvb, offset + 0);
dest = tvb_get_guint8(tvb, offset + 2);
msglen = tvb_get_ntohs(tvb, offset + 4);
flags = tvb_get_guint8(tvb, offset + 6);
frmtyp = flags & ~RESPONSE_FLAGS;
if (!is_msgresp_add) {
msgpad = 3 - (msglen + 3) % 4;
set_actual_length(tvb, msglen + msgpad + GRYPHON_FRAME_HEADER_LEN);
col_set_str(pinfo->cinfo, COL_INFO, val_to_str_const(frmtyp, frame_type, ""- Invalid -""));
}
if (tree == NULL)
return offset;
if (try_val_to_str(frmtyp, frame_type) == NULL) {
proto_tree_add_item(gryphon_tree, hf_gryphon_data, tvb, offset, msglen, ENC_NA);
offset += msglen;
return offset;
}
header_tree = proto_tree_add_subtree(gryphon_tree, tvb, offset, MSG_HDR_SZ, ett_gryphon_header, NULL, ""Header"");
proto_tree_add_item(header_tree, hf_gryphon_src, tvb, offset, 1, ENC_BIG_ENDIAN);
if(is_special_client(src)) {
proto_tree_add_item(header_tree, hf_gryphon_srcchanclient, tvb, offset+1, 1, ENC_BIG_ENDIAN);
} else {
proto_tree_add_item(header_tree, hf_gryphon_srcchan, tvb, offset+1, 1, ENC_BIG_ENDIAN);
}
proto_tree_add_item(header_tree, hf_gryphon_dest, tvb, offset+2, 1, ENC_BIG_ENDIAN);
if(is_special_client(dest)) {
proto_tree_add_item(header_tree, hf_gryphon_destchanclient, tvb, offset+3, 1, ENC_BIG_ENDIAN);
} else {
proto_tree_add_item(header_tree, hf_gryphon_destchan, tvb, offset+3, 1, ENC_BIG_ENDIAN);
}
proto_tree_add_item(header_tree, hf_gryphon_data_length, tvb, offset+4, 2, ENC_BIG_ENDIAN);
proto_tree_add_item(header_tree, hf_gryphon_type, tvb, offset+6, 1, ENC_BIG_ENDIAN);
if (is_msgresp_add) {
static const int * wait_flags[] = {
&hf_gryphon_wait_resp,
&hf_gryphon_wait_prev_resp,
NULL
};
proto_tree_add_bitmask(header_tree, tvb, offset+6, hf_gryphon_wait_flags, ett_gryphon_flags, wait_flags, ENC_NA);
}
proto_tree_add_item(header_tree, hf_gryphon_reserved, tvb, offset+7, 1, ENC_NA);
offset += MSG_HDR_SZ;
msgpad = 3 - (msglen + 3) % 4;
msgend = offset + msglen + msgpad;
body_tree = proto_tree_add_subtree(gryphon_tree, tvb, offset, msglen , ett_gryphon_body, NULL, ""Body"");
switch (frmtyp) {
case GY_FT_CMD:
offset = decode_command(tvb, msglen, offset, dest, body_tree);
break;
case GY_FT_RESP:
offset = decode_response(tvb, offset, src, body_tree);
break;
case GY_FT_DATA:
offset = decode_data(tvb, offset, body_tree);
break;
case GY_FT_EVENT:
offset = decode_event(tvb, offset, body_tree);
break;
case GY_FT_MISC:
offset = decode_misc (tvb, offset, body_tree);
break;
case GY_FT_TEXT:
offset = decode_text (tvb, offset, msglen, body_tree);
break;
case GY_FT_SIG:
break;
default:
break;
}
if (offset < msgend) {
i = msgend - offset;
proto_tree_add_item(gryphon_tree, hf_gryphon_padding, tvb, offset, i, ENC_NA);
offset += i;
}
return offset;
}","static int
dissect_gryphon_message_with_offset(tvbuff_t *VAR_0, int VAR_1, packet_info *VAR_2, proto_tree *VAR_3, gboolean VAR_4)
{
proto_tree      *VAR_5;
proto_item      *VAR_6;
proto_tree      *VAR_7, *VAR_8;
int             VAR_9;
int             VAR_10, VAR_11;
unsigned int    VAR_12, VAR_13, VAR_14, VAR_15;
guint8          VAR_16;
if (!VAR_4) {
col_set_str(VAR_2->cinfo, VAR_17, ""Gryphon"");
col_clear(VAR_2->cinfo, VAR_18);
}
if (!VAR_4) {
VAR_6 = proto_tree_add_item(VAR_3, VAR_19, VAR_0, 0, -1, VAR_20);
VAR_5 = proto_item_add_subtree(VAR_6, VAR_21);
} else
VAR_5 = VAR_3;
VAR_12 = tvb_get_guint8(VAR_0, VAR_1 + 0);
VAR_13 = tvb_get_guint8(VAR_0, VAR_1 + 2);
VAR_10 = tvb_get_ntohs(VAR_0, VAR_1 + 4);
VAR_16 = tvb_get_guint8(VAR_0, VAR_1 + 6);
VAR_15 = VAR_16 & ~VAR_22;
if (!VAR_4) {
VAR_11 = 3 - (VAR_10 + 3) % 4;
set_actual_length(VAR_0, VAR_10 + VAR_11 + VAR_23);
col_set_str(VAR_2->cinfo, VAR_18, val_to_str_const(VAR_15, VAR_24, ""- Invalid -""));
}
if (VAR_3 == NULL)
return VAR_1;
if (try_val_to_str(VAR_15, VAR_24) == NULL) {
proto_tree_add_item(VAR_5, VAR_25, VAR_0, VAR_1, VAR_10, VAR_20);
VAR_1 += VAR_10;
return VAR_1;
}
VAR_7 = proto_tree_add_subtree(VAR_5, VAR_0, VAR_1, VAR_26, VAR_27, NULL, ""Header"");
proto_tree_add_item(VAR_7, VAR_28, VAR_0, VAR_1, 1, VAR_29);
if(is_special_client(VAR_12)) {
proto_tree_add_item(VAR_7, VAR_30, VAR_0, VAR_1+1, 1, VAR_29);
} else {
proto_tree_add_item(VAR_7, VAR_31, VAR_0, VAR_1+1, 1, VAR_29);
}
proto_tree_add_item(VAR_7, VAR_32, VAR_0, VAR_1+2, 1, VAR_29);
if(is_special_client(VAR_13)) {
proto_tree_add_item(VAR_7, VAR_33, VAR_0, VAR_1+3, 1, VAR_29);
} else {
proto_tree_add_item(VAR_7, VAR_34, VAR_0, VAR_1+3, 1, VAR_29);
}
proto_tree_add_item(VAR_7, VAR_35, VAR_0, VAR_1+4, 2, VAR_29);
proto_tree_add_item(VAR_7, VAR_36, VAR_0, VAR_1+6, 1, VAR_29);
if (VAR_4) {
static const int * VAR_37[] = {
&VAR_38,
&VAR_39,
NULL
};
proto_tree_add_bitmask(VAR_7, VAR_0, VAR_1+6, VAR_40, VAR_41, VAR_37, VAR_20);
}
proto_tree_add_item(VAR_7, VAR_42, VAR_0, VAR_1+7, 1, VAR_20);
VAR_1 += VAR_26;
VAR_11 = 3 - (VAR_10 + 3) % 4;
VAR_9 = VAR_1 + VAR_10 + VAR_11;
VAR_8 = proto_tree_add_subtree(VAR_5, VAR_0, VAR_1, VAR_10 , VAR_43, NULL, ""Body"");
switch (VAR_15) {
case VAR_44:
VAR_1 = decode_command(VAR_0, VAR_10, VAR_1, VAR_13, VAR_8);
break;
case VAR_45:
VAR_1 = decode_response(VAR_0, VAR_1, VAR_12, VAR_8);
break;
case VAR_46:
VAR_1 = decode_data(VAR_0, VAR_1, VAR_8);
break;
case VAR_47:
VAR_1 = decode_event(VAR_0, VAR_1, VAR_8);
break;
case VAR_48:
VAR_1 = decode_misc (VAR_0, VAR_1, VAR_8);
break;
case VAR_49:
VAR_1 = decode_text (VAR_0, VAR_1, VAR_10, VAR_8);
break;
case VAR_50:
break;
default:
break;
}
if (VAR_1 < VAR_9) {
VAR_14 = VAR_9 - VAR_1;
proto_tree_add_item(VAR_5, VAR_51, VAR_0, VAR_1, VAR_14, VAR_20);
VAR_1 += VAR_14;
}
return VAR_1;
}",wireshark/02ddd49885c6a09e936a76aceb726ed06539704a/packet-gryphon.c/vul/before/0.json,"static int
dissect_gryphon_message_with_offset(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree, gboolean is_msgresp_add)
{
    proto_tree      *gryphon_tree;
    proto_item      *ti;
    proto_tree      *header_tree, *body_tree;
    int             msgend;
    int             msglen, msgpad;
    unsigned int    src, dest, i, frmtyp;
    guint8          flags;

    if (!is_msgresp_add) {
        col_set_str(pinfo->cinfo, COL_PROTOCOL, ""Gryphon"");
        col_clear(pinfo->cinfo, COL_INFO);
    }

    if (!is_msgresp_add) {
        ti = proto_tree_add_item(tree, proto_gryphon, tvb, 0, -1, ENC_NA);
        gryphon_tree = proto_item_add_subtree(ti, ett_gryphon);
    } else
        gryphon_tree = tree;

    src = tvb_get_guint8(tvb, offset + 0);
    dest = tvb_get_guint8(tvb, offset + 2);
    msglen = tvb_get_ntohs(tvb, offset + 4);
    flags = tvb_get_guint8(tvb, offset + 6);
    frmtyp = flags & ~RESPONSE_FLAGS;

    if (!is_msgresp_add) {
        /*
         * This tvbuff includes padding to make its length a multiple
         * of 4 bytes; set it to the actual length.
         */

        /* TODO 20171011 this is not correct. can't use msglen here, because there is also padding in the msg? */
        msgpad = 3 - (msglen + 3) % 4;
        set_actual_length(tvb, msglen + msgpad + GRYPHON_FRAME_HEADER_LEN);

        /*
         * Indicate what kind of message this is.
         */
        col_set_str(pinfo->cinfo, COL_INFO, val_to_str_const(frmtyp, frame_type, ""- Invalid -""));
    }

    if (tree == NULL)
        return offset;

    if (try_val_to_str(frmtyp, frame_type) == NULL) {
        /*
         * Unknown message type.
         */
        proto_tree_add_item(gryphon_tree, hf_gryphon_data, tvb, offset, msglen, ENC_NA);
        if (msglen != 0) {
            offset += msglen;
        } else {
            offset = tvb_reported_length_remaining(tvb, offset);
        }
        return offset;
    }

    header_tree = proto_tree_add_subtree(gryphon_tree, tvb, offset, MSG_HDR_SZ, ett_gryphon_header, NULL, ""Header"");

    /* src */
    proto_tree_add_item(header_tree, hf_gryphon_src, tvb, offset, 1, ENC_BIG_ENDIAN);
    /* 20180306 20171012 */
    /* srcchan */
    if(is_special_client(src)) {
        proto_tree_add_item(header_tree, hf_gryphon_srcchanclient, tvb, offset+1, 1, ENC_BIG_ENDIAN);
    } else {
        proto_tree_add_item(header_tree, hf_gryphon_srcchan, tvb, offset+1, 1, ENC_BIG_ENDIAN);
    }

    /* dest */
    proto_tree_add_item(header_tree, hf_gryphon_dest, tvb, offset+2, 1, ENC_BIG_ENDIAN);
    /* 20180306 20171012 */
    /* destchan */
    if(is_special_client(dest)) {
            proto_tree_add_item(header_tree, hf_gryphon_destchanclient, tvb, offset+3, 1, ENC_BIG_ENDIAN);
    } else {
            proto_tree_add_item(header_tree, hf_gryphon_destchan, tvb, offset+3, 1, ENC_BIG_ENDIAN);
    }

    proto_tree_add_item(header_tree, hf_gryphon_data_length, tvb, offset+4, 2, ENC_BIG_ENDIAN);
    proto_tree_add_item(header_tree, hf_gryphon_type, tvb, offset+6, 1, ENC_BIG_ENDIAN);

    if (is_msgresp_add) {
        static const int * wait_flags[] = {
            &hf_gryphon_wait_resp,
            &hf_gryphon_wait_prev_resp,
            NULL
        };

        proto_tree_add_bitmask(header_tree, tvb, offset+6, hf_gryphon_wait_flags, ett_gryphon_flags, wait_flags, ENC_NA);
    }
    proto_tree_add_item(header_tree, hf_gryphon_reserved, tvb, offset+7, 1, ENC_NA);
    offset += MSG_HDR_SZ;

    msgpad = 3 - (msglen + 3) % 4;
    msgend = offset + msglen + msgpad;

    body_tree = proto_tree_add_subtree(gryphon_tree, tvb, offset, msglen , ett_gryphon_body, NULL, ""Body"");

    switch (frmtyp) {
    case GY_FT_CMD:
        offset = decode_command(tvb, msglen, offset, dest, body_tree);
        break;
    case GY_FT_RESP:
        offset = decode_response(tvb, offset, src, body_tree);
        break;
    case GY_FT_DATA:
        offset = decode_data(tvb, offset, body_tree);
        break;
    case GY_FT_EVENT:
        offset = decode_event(tvb, offset, body_tree);
        break;
    case GY_FT_MISC:
        offset = decode_misc (tvb, offset, body_tree);
        break;
    case GY_FT_TEXT:
        offset = decode_text (tvb, offset, msglen, body_tree);
        break;
    case GY_FT_SIG:
        break;
    default:
        break;
    }

    /*debug*/
    /*i = msgend - offset;*/
    /*proto_tree_add_debug_text(gryphon_tree, ""debug offset=%d msgend=%d i=%d"",offset,msgend,i);*/

    if (offset < msgend) {
        i = msgend - offset;
        /*
         * worked when msglen=4, offset=8, msgend=12, get i=4
         * did not work when msglen=5, offset=8, msgend=16, i is 8
         */
        proto_tree_add_item(gryphon_tree, hf_gryphon_padding, tvb, offset, i, ENC_NA);
        offset += i;
    }
    return offset;
}","static int
dissect_gryphon_message_with_offset(tvbuff_t *VAR_0, int VAR_1, packet_info *VAR_2, proto_tree *VAR_3, gboolean VAR_4)
{
    proto_tree      *VAR_5;
    proto_item      *VAR_6;
    proto_tree      *VAR_7, *VAR_8;
    int             VAR_9;
    int             VAR_10, VAR_11;
    unsigned int    VAR_12, VAR_13, VAR_14, VAR_15;
    guint8          VAR_16;

    if (!VAR_4) {
        col_set_str(VAR_2->cinfo, VAR_17, ""Gryphon"");
        col_clear(VAR_2->cinfo, VAR_18);
    }

    if (!VAR_4) {
        VAR_6 = proto_tree_add_item(VAR_3, VAR_19, VAR_0, 0, -1, VAR_20);
        VAR_5 = proto_item_add_subtree(VAR_6, VAR_21);
    } else
        VAR_5 = VAR_3;

    VAR_12 = tvb_get_guint8(VAR_0, VAR_1 + 0);
    VAR_13 = tvb_get_guint8(VAR_0, VAR_1 + 2);
    VAR_10 = tvb_get_ntohs(VAR_0, VAR_1 + 4);
    VAR_16 = tvb_get_guint8(VAR_0, VAR_1 + 6);
    VAR_15 = VAR_16 & ~VAR_22;

    if (!VAR_4) {
        /* COMMENT_0 */
                                                                     
                                                   
           

        /* COMMENT_4 */
        VAR_11 = 3 - (VAR_10 + 3) % 4;
        set_actual_length(VAR_0, VAR_10 + VAR_11 + VAR_23);

        /* COMMENT_5 */
                                                 
           
        col_set_str(VAR_2->cinfo, VAR_18, val_to_str_const(VAR_15, VAR_24, ""- Invalid -""));
    }

    if (VAR_3 == NULL)
        return VAR_1;

    if (try_val_to_str(VAR_15, VAR_24) == NULL) {
        /* COMMENT_8 */
                                
           
        proto_tree_add_item(VAR_5, VAR_25, VAR_0, VAR_1, VAR_10, VAR_20);
        if (VAR_10 != 0) {
            VAR_1 += VAR_10;
        } else {
            VAR_1 = tvb_reported_length_remaining(VAR_0, VAR_1);
        }
        return VAR_1;
    }

    VAR_7 = proto_tree_add_subtree(VAR_5, VAR_0, VAR_1, VAR_26, VAR_27, NULL, ""Header"");

    /* COMMENT_11 */
    proto_tree_add_item(VAR_7, VAR_28, VAR_0, VAR_1, 1, VAR_29);
    /* COMMENT_12 */
    /* COMMENT_13 */
    if(is_special_client(VAR_12)) {
        proto_tree_add_item(VAR_7, VAR_30, VAR_0, VAR_1+1, 1, VAR_29);
    } else {
        proto_tree_add_item(VAR_7, VAR_31, VAR_0, VAR_1+1, 1, VAR_29);
    }

    /* COMMENT_14 */
    proto_tree_add_item(VAR_7, VAR_32, VAR_0, VAR_1+2, 1, VAR_29);
    /* COMMENT_12 */
    /* COMMENT_15 */
    if(is_special_client(VAR_13)) {
            proto_tree_add_item(VAR_7, VAR_33, VAR_0, VAR_1+3, 1, VAR_29);
    } else {
            proto_tree_add_item(VAR_7, VAR_34, VAR_0, VAR_1+3, 1, VAR_29);
    }

    proto_tree_add_item(VAR_7, VAR_35, VAR_0, VAR_1+4, 2, VAR_29);
    proto_tree_add_item(VAR_7, VAR_36, VAR_0, VAR_1+6, 1, VAR_29);

    if (VAR_4) {
        static const int * VAR_37[] = {
            &VAR_38,
            &VAR_39,
            NULL
        };

        proto_tree_add_bitmask(VAR_7, VAR_0, VAR_1+6, VAR_40, VAR_41, VAR_37, VAR_20);
    }
    proto_tree_add_item(VAR_7, VAR_42, VAR_0, VAR_1+7, 1, VAR_20);
    VAR_1 += VAR_26;

    VAR_11 = 3 - (VAR_10 + 3) % 4;
    VAR_9 = VAR_1 + VAR_10 + VAR_11;

    VAR_8 = proto_tree_add_subtree(VAR_5, VAR_0, VAR_1, VAR_10 , VAR_43, NULL, ""Body"");

    switch (VAR_15) {
    case VAR_44:
        VAR_1 = decode_command(VAR_0, VAR_10, VAR_1, VAR_13, VAR_8);
        break;
    case VAR_45:
        VAR_1 = decode_response(VAR_0, VAR_1, VAR_12, VAR_8);
        break;
    case VAR_46:
        VAR_1 = decode_data(VAR_0, VAR_1, VAR_8);
        break;
    case VAR_47:
        VAR_1 = decode_event(VAR_0, VAR_1, VAR_8);
        break;
    case VAR_48:
        VAR_1 = decode_misc (VAR_0, VAR_1, VAR_8);
        break;
    case VAR_49:
        VAR_1 = decode_text (VAR_0, VAR_1, VAR_10, VAR_8);
        break;
    case VAR_50:
        break;
    default:
        break;
    }

    /* COMMENT_16 */
    /* COMMENT_17 */
    /* COMMENT_18 */

    if (VAR_1 < VAR_9) {
        VAR_14 = VAR_9 - VAR_1;
        /* COMMENT_19 */
                                                             
                                                                  
           
        proto_tree_add_item(VAR_5, VAR_51, VAR_0, VAR_1, VAR_14, VAR_20);
        VAR_1 += VAR_14;
    }
    return VAR_1;
}",wireshark/02ddd49885c6a09e936a76aceb726ed06539704a/packet-gryphon.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -50,7 +50,11 @@
          * Unknown message type.
          */
         proto_tree_add_item(gryphon_tree, hf_gryphon_data, tvb, offset, msglen, ENC_NA);
-        offset += msglen;
+        if (msglen != 0) {
+            offset += msglen;
+        } else {
+            offset = tvb_reported_length_remaining(tvb, offset);
+        }
         return offset;
     }
 ","{'deleted_lines': ['        offset += msglen;'], 'added_lines': ['        if (msglen != 0) {', '            offset += msglen;', '        } else {', '            offset = tvb_reported_length_remaining(tvb, offset);', '        }']}",True,"In Wireshark 3.0.0 to 3.0.3 and 2.6.0 to 2.6.10, the Gryphon dissector could go into an infinite loop. This was addressed in plugins/epan/gryphon/packet-gryphon.c by checking for a message length of zero.",7.5,HIGH,2,valid,2019-08-29T02:27:58Z,3
CVE-2020-13765,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,qemu,"hw/core/loader: Fix possible crash in rom_copy()

Both, ""rom->addr"" and ""addr"" are derived from the binary image
that can be loaded with the ""-kernel"" paramer. The code in
rom_copy() then calculates:

    d = dest + (rom->addr - addr);

and uses ""d"" as destination in a memcpy() some lines later. Now with
bad kernel images, it is possible that rom->addr is smaller than addr,
thus ""rom->addr - addr"" gets negative and the memcpy() then tries to
copy contents from the image to a bad memory location. This could
maybe be used to inject code from a kernel image into the QEMU binary,
so we better fix it with an additional sanity check here.

Cc: qemu-stable@nongnu.org
Reported-by: Guangming Liu
Buglink: https://bugs.launchpad.net/qemu/+bug/1844635
Message-Id: <20190925130331.27825-1-thuth@redhat.com>
Reviewed-by: Michael S. Tsirkin <mst@redhat.com>
Signed-off-by: Thomas Huth <thuth@redhat.com>",e423455c4f23a1a828901c78fe6d03b7dde79319,https://github.com/qemu/qemu/commit/e423455c4f23a1a828901c78fe6d03b7dde79319,hw/core/loader.c,rom_copy,"int rom_copy(uint8_t *dest, hwaddr addr, size_t size)
{
hwaddr end = addr + size;
uint8_t *s, *d = dest;
size_t l = 0;
Rom *rom;
QTAILQ_FOREACH(rom, &roms, next) {
if (rom->fw_file) {
continue;
}
if (rom->mr) {
continue;
}
if (rom->addr + rom->romsize < addr) {
continue;
}
if (rom->addr > end) {
break;
}
d = dest + (rom->addr - addr);
s = rom->data;
l = rom->datasize;
if ((d + l) > (dest + size)) {
l = dest - d;
}
if (l > 0) {
memcpy(d, s, l);
}
if (rom->romsize > rom->datasize) {
d += l;
l = rom->romsize - rom->datasize;
if ((d + l) > (dest + size)) {
l = dest - d;
}
if (l > 0) {
memset(d, 0x0, l);
}
}
}
return (d + l) - dest;
}","int rom_copy(uint8_t *VAR_0, hwaddr VAR_1, size_t VAR_2)
{
hwaddr VAR_3 = VAR_1 + VAR_2;
uint8_t *VAR_4, *VAR_5 = VAR_0;
size_t VAR_6 = 0;
Rom *VAR_7;
QTAILQ_FOREACH(VAR_7, &VAR_8, VAR_9) {
if (VAR_7->fw_file) {
continue;
}
if (VAR_7->mr) {
continue;
}
if (VAR_7->addr + VAR_7->romsize < VAR_1) {
continue;
}
if (VAR_7->addr > VAR_3) {
break;
}
VAR_5 = VAR_0 + (VAR_7->addr - VAR_1);
VAR_4 = VAR_7->data;
VAR_6 = VAR_7->datasize;
if ((VAR_5 + VAR_6) > (VAR_0 + VAR_2)) {
VAR_6 = VAR_0 - VAR_5;
}
if (VAR_6 > 0) {
memcpy(VAR_5, VAR_4, VAR_6);
}
if (VAR_7->romsize > VAR_7->datasize) {
VAR_5 += VAR_6;
VAR_6 = VAR_7->romsize - VAR_7->datasize;
if ((VAR_5 + VAR_6) > (VAR_0 + VAR_2)) {
VAR_6 = VAR_0 - VAR_5;
}
if (VAR_6 > 0) {
memset(VAR_5, 0x0, VAR_6);
}
}
}
return (VAR_5 + VAR_6) - VAR_0;
}",qemu/e423455c4f23a1a828901c78fe6d03b7dde79319/loader.c/vul/before/0.json,"int rom_copy(uint8_t *dest, hwaddr addr, size_t size)
{
    hwaddr end = addr + size;
    uint8_t *s, *d = dest;
    size_t l = 0;
    Rom *rom;

    QTAILQ_FOREACH(rom, &roms, next) {
        if (rom->fw_file) {
            continue;
        }
        if (rom->mr) {
            continue;
        }
        if (rom->addr + rom->romsize < addr) {
            continue;
        }
        if (rom->addr > end || rom->addr < addr) {
            break;
        }

        d = dest + (rom->addr - addr);
        s = rom->data;
        l = rom->datasize;

        if ((d + l) > (dest + size)) {
            l = dest - d;
        }

        if (l > 0) {
            memcpy(d, s, l);
        }

        if (rom->romsize > rom->datasize) {
            /* If datasize is less than romsize, it means that we didn't
             * allocate all the ROM because the trailing data are only zeros.
             */

            d += l;
            l = rom->romsize - rom->datasize;

            if ((d + l) > (dest + size)) {
                /* Rom size doesn't fit in the destination area. Adjust to avoid
                 * overflow.
                 */
                l = dest - d;
            }

            if (l > 0) {
                memset(d, 0x0, l);
            }
        }
    }

    return (d + l) - dest;
}","int rom_copy(uint8_t *VAR_0, hwaddr VAR_1, size_t VAR_2)
{
    hwaddr VAR_3 = VAR_1 + VAR_2;
    uint8_t *VAR_4, *VAR_5 = VAR_0;
    size_t VAR_6 = 0;
    Rom *VAR_7;

    QTAILQ_FOREACH(VAR_7, &VAR_8, VAR_9) {
        if (VAR_7->fw_file) {
            continue;
        }
        if (VAR_7->mr) {
            continue;
        }
        if (VAR_7->addr + VAR_7->romsize < VAR_1) {
            continue;
        }
        if (VAR_7->addr > VAR_3 || VAR_7->addr < VAR_1) {
            break;
        }

        VAR_5 = VAR_0 + (VAR_7->addr - VAR_1);
        VAR_4 = VAR_7->data;
        VAR_6 = VAR_7->datasize;

        if ((VAR_5 + VAR_6) > (VAR_0 + VAR_2)) {
            VAR_6 = VAR_0 - VAR_5;
        }

        if (VAR_6 > 0) {
            memcpy(VAR_5, VAR_4, VAR_6);
        }

        if (VAR_7->romsize > VAR_7->datasize) {
            /* COMMENT_0 */
                                                                             
               

            VAR_5 += VAR_6;
            VAR_6 = VAR_7->romsize - VAR_7->datasize;

            if ((VAR_5 + VAR_6) > (VAR_0 + VAR_2)) {
                /* COMMENT_3 */
                            
                   
                VAR_6 = VAR_0 - VAR_5;
            }

            if (VAR_6 > 0) {
                memset(VAR_5, 0x0, VAR_6);
            }
        }
    }

    return (VAR_5 + VAR_6) - VAR_0;
}",qemu/e423455c4f23a1a828901c78fe6d03b7dde79319/loader.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -15,7 +15,7 @@
         if (rom->addr + rom->romsize < addr) {
             continue;
         }
-        if (rom->addr > end) {
+        if (rom->addr > end || rom->addr < addr) {
             break;
         }
 ","{'deleted_lines': ['        if (rom->addr > end) {'], 'added_lines': ['        if (rom->addr > end || rom->addr < addr) {']}",True,"rom_copy() in hw/core/loader.c in QEMU 4.0 and 4.1.0 does not validate the relationship between two addresses, which allows attackers to trigger an invalid memory copy operation.",5.6,MEDIUM,1,valid,2019-09-25T12:16:43Z,3
CVE-2020-19861,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0,NLnetLabs/ldns,"* bugfix #51: Heap Out-of-bound Read vulnerability in
  ldns_nsec3_salt_data reported by pokerfacett.",136ec420437041fe13f344a2053e774f9050cc38,https://github.com/NLnetLabs/ldns/commit/136ec420437041fe13f344a2053e774f9050cc38,dnssec.c,ldns_nsec3_salt_data,"uint8_t *
ldns_nsec3_salt_data(const ldns_rr *nsec3_rr)
{
uint8_t salt_length;
uint8_t *salt;
ldns_rdf *salt_rdf = ldns_nsec3_salt(nsec3_rr);
if (salt_rdf && ldns_rdf_size(salt_rdf) > 0) {
salt_length = ldns_rdf_data(salt_rdf)[0];
salt = LDNS_XMALLOC(uint8_t, salt_length);
if(!salt) return NULL;
memcpy(salt, &ldns_rdf_data(salt_rdf)[1], salt_length);
return salt;
}
return NULL;
}","uint8_t *
ldns_nsec3_salt_data(const ldns_rr *VAR_0)
{
uint8_t VAR_1;
uint8_t *VAR_2;
ldns_rdf *VAR_3 = ldns_nsec3_salt(VAR_0);
if (VAR_3 && ldns_rdf_size(VAR_3) > 0) {
VAR_1 = ldns_rdf_data(VAR_3)[0];
VAR_2 = LDNS_XMALLOC(uint8_t, VAR_1);
if(!VAR_2) return NULL;
memcpy(VAR_2, &ldns_rdf_data(VAR_3)[1], VAR_1);
return VAR_2;
}
return NULL;
}",NLnetLabs/ldns/136ec420437041fe13f344a2053e774f9050cc38/dnssec.c/vul/before/0.json,"uint8_t *
ldns_nsec3_salt_data(const ldns_rr *nsec3_rr)
{
	uint8_t salt_length;
	uint8_t *salt;

	ldns_rdf *salt_rdf = ldns_nsec3_salt(nsec3_rr);
	if (salt_rdf && ldns_rdf_size(salt_rdf) > 0) {
	    	salt_length = ldns_rdf_data(salt_rdf)[0];
		if((size_t)salt_length+1 > ldns_rdf_size(salt_rdf))
			return NULL;
		salt = LDNS_XMALLOC(uint8_t, salt_length);
                if(!salt) return NULL;
		memcpy(salt, &ldns_rdf_data(salt_rdf)[1], salt_length);
		return salt;
	}
	return NULL;
}","uint8_t *
ldns_nsec3_salt_data(const ldns_rr *VAR_0)
{
	uint8_t VAR_1;
	uint8_t *VAR_2;

	ldns_rdf *VAR_3 = ldns_nsec3_salt(VAR_0);
	if (VAR_3 && ldns_rdf_size(VAR_3) > 0) {
	    	VAR_1 = ldns_rdf_data(VAR_3)[0];
		if((size_t)VAR_1+1 > ldns_rdf_size(VAR_3))
			return NULL;
		VAR_2 = LDNS_XMALLOC(uint8_t, VAR_1);
                if(!VAR_2) return NULL;
		memcpy(VAR_2, &ldns_rdf_data(VAR_3)[1], VAR_1);
		return VAR_2;
	}
	return NULL;
}",NLnetLabs/ldns/136ec420437041fe13f344a2053e774f9050cc38/dnssec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,6 +7,8 @@
 	ldns_rdf *salt_rdf = ldns_nsec3_salt(nsec3_rr);
 	if (salt_rdf && ldns_rdf_size(salt_rdf) > 0) {
 	    	salt_length = ldns_rdf_data(salt_rdf)[0];
+		if((size_t)salt_length+1 > ldns_rdf_size(salt_rdf))
+			return NULL;
 		salt = LDNS_XMALLOC(uint8_t, salt_length);
                 if(!salt) return NULL;
 		memcpy(salt, &ldns_rdf_data(salt_rdf)[1], salt_length);","{'deleted_lines': [], 'added_lines': ['\t\tif((size_t)salt_length+1 > ldns_rdf_size(salt_rdf))', '\t\t\treturn NULL;']}",True,"When a zone file in ldns 1.7.1 is parsed, the function ldns_nsec3_salt_data is too trusted for the length value obtained from the zone file. When the memcpy is copied, the 0xfe - ldns_rdf_size(salt_rdf) byte data can be copied, causing heap overflow information leakage.",7.5,HIGH,2,valid,2019-09-26T07:27:29Z,3
CVE-2019-19048,['CWE-401'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"virt: vbox: fix memory leak in hgcm_call_preprocess_linaddr

In hgcm_call_preprocess_linaddr memory is allocated for bounce_buf but
is not released if copy_form_user fails. In order to prevent memory leak
in case of failure, the assignment to bounce_buf_ret is moved before the
error check. This way the allocated bounce_buf will be released by the
caller.

Fixes: 579db9d45cb4 (""virt: Add vboxguest VMMDEV communication code"")
Signed-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>
Reviewed-by: Hans de Goede <hdegoede@redhat.com>
Link: https://lore.kernel.org/r/20190930204223.3660-1-navid.emamdoost@gmail.com
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",e0b0cb9388642c104838fac100a4af32745621e2,https://github.com/torvalds/linux/commit/e0b0cb9388642c104838fac100a4af32745621e2,drivers/virt/vboxguest/vboxguest_utils.c,hgcm_call_preprocess_linaddr,"static int hgcm_call_preprocess_linaddr(
const struct vmmdev_hgcm_function_parameter *src_parm,
void **bounce_buf_ret, size_t *extra)
{
void *buf, *bounce_buf;
bool copy_in;
u32 len;
int ret;
buf = (void *)src_parm->u.pointer.u.linear_addr;
len = src_parm->u.pointer.size;
copy_in = src_parm->type != VMMDEV_HGCM_PARM_TYPE_LINADDR_OUT;
if (len > VBG_MAX_HGCM_USER_PARM)
return -E2BIG;
bounce_buf = kvmalloc(len, GFP_KERNEL);
if (!bounce_buf)
return -ENOMEM;
if (copy_in) {
ret = copy_from_user(bounce_buf, (void __user *)buf, len);
if (ret)
return -EFAULT;
} else {
memset(bounce_buf, 0, len);
}
*bounce_buf_ret = bounce_buf;
hgcm_call_add_pagelist_size(bounce_buf, len, extra);
return 0;
}","static int hgcm_call_preprocess_linaddr(
const struct vmmdev_hgcm_function_parameter *VAR_0,
void **VAR_1, size_t *VAR_2)
{
void *VAR_3, *VAR_4;
bool VAR_5;
u32 VAR_6;
int VAR_7;
VAR_3 = (void *)VAR_0->u.pointer.u.linear_addr;
VAR_6 = VAR_0->u.pointer.size;
VAR_5 = VAR_0->type != VAR_8;
if (VAR_6 > VAR_9)
return -VAR_10;
VAR_4 = kvmalloc(VAR_6, VAR_11);
if (!VAR_4)
return -VAR_12;
if (VAR_5) {
VAR_7 = copy_from_user(VAR_4, (void __user *)VAR_3, VAR_6);
if (VAR_7)
return -VAR_13;
} else {
memset(VAR_4, 0, VAR_6);
}
*VAR_1 = VAR_4;
hgcm_call_add_pagelist_size(VAR_4, VAR_6, VAR_2);
return 0;
}",torvalds/linux/e0b0cb9388642c104838fac100a4af32745621e2/vboxguest_utils.c/vul/before/0.json,"static int hgcm_call_preprocess_linaddr(
	const struct vmmdev_hgcm_function_parameter *src_parm,
	void **bounce_buf_ret, size_t *extra)
{
	void *buf, *bounce_buf;
	bool copy_in;
	u32 len;
	int ret;

	buf = (void *)src_parm->u.pointer.u.linear_addr;
	len = src_parm->u.pointer.size;
	copy_in = src_parm->type != VMMDEV_HGCM_PARM_TYPE_LINADDR_OUT;

	if (len > VBG_MAX_HGCM_USER_PARM)
		return -E2BIG;

	bounce_buf = kvmalloc(len, GFP_KERNEL);
	if (!bounce_buf)
		return -ENOMEM;

	*bounce_buf_ret = bounce_buf;

	if (copy_in) {
		ret = copy_from_user(bounce_buf, (void __user *)buf, len);
		if (ret)
			return -EFAULT;
	} else {
		memset(bounce_buf, 0, len);
	}

	hgcm_call_add_pagelist_size(bounce_buf, len, extra);
	return 0;
}","static int hgcm_call_preprocess_linaddr(
	const struct vmmdev_hgcm_function_parameter *VAR_0,
	void **VAR_1, size_t *VAR_2)
{
	void *VAR_3, *VAR_4;
	bool VAR_5;
	u32 VAR_6;
	int VAR_7;

	VAR_3 = (void *)VAR_0->u.pointer.u.linear_addr;
	VAR_6 = VAR_0->u.pointer.size;
	VAR_5 = VAR_0->type != VAR_8;

	if (VAR_6 > VAR_9)
		return -VAR_10;

	VAR_4 = kvmalloc(VAR_6, VAR_11);
	if (!VAR_4)
		return -VAR_12;

	*VAR_1 = VAR_4;

	if (VAR_5) {
		VAR_7 = copy_from_user(VAR_4, (void __user *)VAR_3, VAR_6);
		if (VAR_7)
			return -VAR_13;
	} else {
		memset(VAR_4, 0, VAR_6);
	}

	hgcm_call_add_pagelist_size(VAR_4, VAR_6, VAR_2);
	return 0;
}",torvalds/linux/e0b0cb9388642c104838fac100a4af32745621e2/vboxguest_utils.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -18,6 +18,8 @@
 	if (!bounce_buf)
 		return -ENOMEM;
 
+	*bounce_buf_ret = bounce_buf;
+
 	if (copy_in) {
 		ret = copy_from_user(bounce_buf, (void __user *)buf, len);
 		if (ret)
@@ -26,7 +28,6 @@
 		memset(bounce_buf, 0, len);
 	}
 
-	*bounce_buf_ret = bounce_buf;
 	hgcm_call_add_pagelist_size(bounce_buf, len, extra);
 	return 0;
 }","{'deleted_lines': ['\t*bounce_buf_ret = bounce_buf;'], 'added_lines': ['\t*bounce_buf_ret = bounce_buf;', '']}",True,"A memory leak in the crypto_reportstat() function in drivers/virt/vboxguest/vboxguest_utils.c in the Linux kernel before 5.3.9 allows attackers to cause a denial of service (memory consumption) by triggering copy_form_user() failures, aka CID-e0b0cb938864.",7.5,HIGH,2,valid,2019-09-30T20:42:22Z,3
CVE-2019-20219,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,miniupnp/ngiflib,"fix palette read overflow

fixes #15",5bad360070216388768be9b66d9fb59241e86d66,https://github.com/miniupnp/ngiflib/commit/5bad360070216388768be9b66d9fb59241e86d66,ngiflib.c,WritePixels,"static void WritePixels(struct ngiflib_img * i, struct ngiflib_decode_context * context, const u8 * pixels, u16 n) {
u16 tocopy;
struct ngiflib_gif * p = i->parent;
while(n > 0) {
tocopy = (context->Xtogo < n) ? context->Xtogo : n;
if(!i->gce.transparent_flag) {
#ifndef NGIFLIB_INDEXED_ONLY
if(p->mode & NGIFLIB_MODE_INDEXED) {
#endif 
ngiflib_memcpy(context->frbuff_p.p8, pixels, tocopy);
pixels += tocopy;
context->frbuff_p.p8 += tocopy;
#ifndef NGIFLIB_INDEXED_ONLY
} else {
int j;
for(j = (int)tocopy; j > 0; j--) {
*(context->frbuff_p.p32++) =
GifIndexToTrueColor(i->palette, *pixels++);
}
}
#endif 
} else {
int j;
#ifndef NGIFLIB_INDEXED_ONLY
if(p->mode & NGIFLIB_MODE_INDEXED) {
#endif 
for(j = (int)tocopy; j > 0; j--) {
if(*pixels != i->gce.transparent_color) *context->frbuff_p.p8 = *pixels;
pixels++;
context->frbuff_p.p8++;
}
#ifndef NGIFLIB_INDEXED_ONLY
} else {
for(j = (int)tocopy; j > 0; j--) {
if(*pixels != i->gce.transparent_color) {
*context->frbuff_p.p32 = GifIndexToTrueColor(i->palette, *pixels);
}
pixels++;
context->frbuff_p.p32++;
}
}
#endif 
}
context->Xtogo -= tocopy;
if(context->Xtogo == 0) {
#ifdef NGIFLIB_ENABLE_CALLBACKS
if(p->line_cb) p->line_cb(p, context->line_p, context->curY);
#endif 
context->Xtogo = i->width;
switch(context->pass) {
case 0:
context->curY++;
break;
case 1:
context->curY += 8;
break;
case 2:
context->curY += 8;
break;
case 3:
context->curY += 4;
break;
case 4:
context->curY += 2;
break;
}
while(context->pass > 0 && context->pass < 4 &&
context->curY >= p->height) {
switch(++context->pass) {
case 2:
context->curY = i->posY + 4;
break;
case 3:
context->curY = i->posY + 2;
break;
case 4:
context->curY = i->posY + 1;
break;
}
}
#ifndef NGIFLIB_INDEXED_ONLY
if(p->mode & NGIFLIB_MODE_INDEXED) {
#endif 
#ifdef NGIFLIB_ENABLE_CALLBACKS
context->line_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width;
context->frbuff_p.p8 = context->line_p.p8 + i->posX;
#else
context->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;
#endif 
#ifndef NGIFLIB_INDEXED_ONLY
} else {
#ifdef NGIFLIB_ENABLE_CALLBACKS
context->line_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width;
context->frbuff_p.p32 = context->line_p.p32 + i->posX;
#else
context->frbuff_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width + i->posX;
#endif 
}
#endif 
}
n -= tocopy;
}
}","static void WritePixels(struct ngiflib_img * VAR_0, struct ngiflib_decode_context * VAR_1, const u8 * VAR_2, u16 VAR_3) {
u16 VAR_4;
struct ngiflib_gif * VAR_5 = VAR_0->parent;
while(VAR_3 > 0) {
VAR_4 = (VAR_1->Xtogo < VAR_3) ? VAR_1->Xtogo : VAR_3;
if(!VAR_0->gce.transparent_flag) {
#ifndef VAR_6
if(VAR_5->mode & VAR_7) {
#endif
ngiflib_memcpy(context->frbuff_p.p8, pixels, tocopy);
VAR_2 += VAR_4;
VAR_1->frbuff_p.p8 += VAR_4;
#ifndef VAR_6
} else {
int VAR_8;
for(VAR_8 = (int)VAR_4; VAR_8 > 0; VAR_8--) {
*(VAR_1->frbuff_p.p32++) =
GifIndexToTrueColor(VAR_0->palette, *VAR_2++);
}
}
#endif 
} else {
int VAR_8;
#ifndef VAR_6
if(VAR_5->mode & VAR_7) {
#endif
for(j = (int)tocopy; j > 0; j--) {
if(*VAR_2 != VAR_0->gce.transparent_color) *VAR_1->frbuff_p.p8 = *VAR_2;
VAR_2++;
VAR_1->frbuff_p.p8++;
}
#ifndef VAR_6
} else {
for(VAR_8 = (int)VAR_4; VAR_8 > 0; VAR_8--) {
if(*VAR_2 != VAR_0->gce.transparent_color) {
*VAR_1->frbuff_p.p32 = GifIndexToTrueColor(VAR_0->palette, *VAR_2);
}
VAR_2++;
VAR_1->frbuff_p.p32++;
}
}
#endif 
}
VAR_1->Xtogo -= VAR_4;
if(VAR_1->Xtogo == 0) {
#ifdef VAR_9
if(VAR_5->line_cb) VAR_5->line_cb(VAR_5, VAR_1->line_p, VAR_1->curY);
#endif 
VAR_1->Xtogo = VAR_0->width;
switch(VAR_1->pass) {
case 0:
VAR_1->curY++;
break;
case 1:
VAR_1->curY += 8;
break;
case 2:
VAR_1->curY += 8;
break;
case 3:
VAR_1->curY += 4;
break;
case 4:
VAR_1->curY += 2;
break;
}
while(VAR_1->pass > 0 && VAR_1->pass < 4 &&
VAR_1->curY >= VAR_5->height) {
switch(++VAR_1->pass) {
case 2:
VAR_1->curY = VAR_0->posY + 4;
break;
case 3:
VAR_1->curY = VAR_0->posY + 2;
break;
case 4:
VAR_1->curY = VAR_0->posY + 1;
break;
}
}
#ifndef VAR_6
if(VAR_5->mode & VAR_7) {
#endif
#ifdef NGIFLIB_ENABLE_CALLBACKS
VAR_1->line_p.p8 = VAR_5->frbuff.p8 + (u32)VAR_1->curY*VAR_5->width;
VAR_1->frbuff_p.p8 = VAR_1->line_p.p8 + VAR_0->posX;
#else
context->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;
#endif
#ifndef VAR_6
} else {
#ifdef VAR_9
VAR_1->line_p.p32 = VAR_5->frbuff.p32 + (u32)VAR_1->curY*VAR_5->width;
VAR_1->frbuff_p.p32 = VAR_1->line_p.p32 + VAR_0->posX;
#else
VAR_1->frbuff_p.p32 = VAR_5->frbuff.p32 + (u32)VAR_1->curY*VAR_5->width + VAR_0->posX;
#endif 
}
#endif 
}
VAR_3 -= VAR_4;
}
}",miniupnp/ngiflib/5bad360070216388768be9b66d9fb59241e86d66/ngiflib.c/vul/before/3.json,"static void WritePixels(struct ngiflib_img * i, struct ngiflib_decode_context * context, const u8 * pixels, u16 n) {
	u16 tocopy;	
	struct ngiflib_gif * p = i->parent;

	while(n > 0) {
		tocopy = (context->Xtogo < n) ? context->Xtogo : n;
		if(!i->gce.transparent_flag) {
#ifndef NGIFLIB_INDEXED_ONLY
			if(p->mode & NGIFLIB_MODE_INDEXED) {
#endif /* NGIFLIB_INDEXED_ONLY */
				ngiflib_memcpy(context->frbuff_p.p8, pixels, tocopy);
				pixels += tocopy;
				context->frbuff_p.p8 += tocopy;
#ifndef NGIFLIB_INDEXED_ONLY
			} else {
				int j;
				for(j = (int)tocopy; j > 0; j--) {
					u8 v = *pixels++;
					*(context->frbuff_p.p32++) = v < i->ncolors ?
					   GifIndexToTrueColor(i->palette, v) : 0;
				}
			}
#endif /* NGIFLIB_INDEXED_ONLY */
		} else {
			int j;
#ifndef NGIFLIB_INDEXED_ONLY
			if(p->mode & NGIFLIB_MODE_INDEXED) {
#endif /* NGIFLIB_INDEXED_ONLY */
				for(j = (int)tocopy; j > 0; j--) {
					if(*pixels != i->gce.transparent_color) *context->frbuff_p.p8 = *pixels;
					pixels++;
					context->frbuff_p.p8++;
				}
#ifndef NGIFLIB_INDEXED_ONLY
			} else {
				for(j = (int)tocopy; j > 0; j--) {
					if(*pixels != i->gce.transparent_color) {
						*context->frbuff_p.p32 = *pixels < i->ncolors ? GifIndexToTrueColor(i->palette, *pixels) : 0;
					}
					pixels++;
					context->frbuff_p.p32++;
				}
			}
#endif /* NGIFLIB_INDEXED_ONLY */
		}
		context->Xtogo -= tocopy;
		if(context->Xtogo == 0) {
			#ifdef NGIFLIB_ENABLE_CALLBACKS
			if(p->line_cb) p->line_cb(p, context->line_p, context->curY);
			#endif /* NGIFLIB_ENABLE_CALLBACKS */
			context->Xtogo = i->width;
			switch(context->pass) {
			case 0:
				context->curY++;
				break;
			case 1:	/* 1st pass : every eighth row starting from 0 */
				context->curY += 8;
				break;
			case 2:	/* 2nd pass : every eighth row starting from 4 */
				context->curY += 8;
				break;
			case 3:	/* 3rd pass : every fourth row starting from 2 */
				context->curY += 4;
				break;
			case 4:	/* 4th pass : every odd row */
				context->curY += 2;
				break;
			}
			while(context->pass > 0 && context->pass < 4 &&
			      context->curY >= p->height) {
				switch(++context->pass) {
				case 2:	/* 2nd pass : every eighth row starting from 4 */
					context->curY = i->posY + 4;
					break;
				case 3:	/* 3rd pass : every fourth row starting from 2 */
					context->curY = i->posY + 2;
					break;
				case 4:	/* 4th pass : every odd row */
					context->curY = i->posY + 1;
					break;
				}
			}
#ifndef NGIFLIB_INDEXED_ONLY
			if(p->mode & NGIFLIB_MODE_INDEXED) {
#endif /* NGIFLIB_INDEXED_ONLY */
				#ifdef NGIFLIB_ENABLE_CALLBACKS
				context->line_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width;
				context->frbuff_p.p8 = context->line_p.p8 + i->posX;
				#else
				context->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;
				#endif /* NGIFLIB_ENABLE_CALLBACKS */
#ifndef NGIFLIB_INDEXED_ONLY
			} else {
				#ifdef NGIFLIB_ENABLE_CALLBACKS
				context->line_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width;
				context->frbuff_p.p32 = context->line_p.p32 + i->posX;
				#else
				context->frbuff_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width + i->posX;
				#endif /* NGIFLIB_ENABLE_CALLBACKS */
			}
#endif /* NGIFLIB_INDEXED_ONLY */
		}
		n -= tocopy;
	}
}","static void WritePixels(struct ngiflib_img * VAR_0, struct ngiflib_decode_context * VAR_1, const u8 * VAR_2, u16 VAR_3) {
	u16 VAR_4;	
	struct ngiflib_gif * VAR_5 = VAR_0->parent;

	while(VAR_3 > 0) {
		VAR_4 = (VAR_1->Xtogo < VAR_3) ? VAR_1->Xtogo : VAR_3;
		if(!VAR_0->gce.transparent_flag) {
#ifndef VAR_6
			if(VAR_5->mode & VAR_7) {
#endif/* COMMENT_0 */
				ngiflib_memcpy(context->frbuff_p.p8, pixels, tocopy);
				VAR_2 += VAR_4;
				VAR_1->frbuff_p.p8 += VAR_4;
#ifndef VAR_6
			} else {
				int VAR_8;
				for(VAR_8 = (int)VAR_4; VAR_8 > 0; VAR_8--) {
					u8 VAR_9 = *VAR_2++;
					*(VAR_1->frbuff_p.p32++) = VAR_9 < VAR_0->ncolors ?
					   GifIndexToTrueColor(VAR_0->palette, VAR_9) : 0;
				}
			}
#endif /* COMMENT_1 */
		} else {
			int VAR_8;
#ifndef VAR_6
			if(VAR_5->mode & VAR_7) {
#endif/* COMMENT_0 */
				for(j = (int)tocopy; j > 0; j--) {
					if(*VAR_2 != VAR_0->gce.transparent_color) *VAR_1->frbuff_p.p8 = *VAR_2;
					VAR_2++;
					VAR_1->frbuff_p.p8++;
				}
#ifndef VAR_6
			} else {
				for(VAR_8 = (int)VAR_4; VAR_8 > 0; VAR_8--) {
					if(*VAR_2 != VAR_0->gce.transparent_color) {
						*VAR_1->frbuff_p.p32 = *VAR_2 < VAR_0->ncolors ? GifIndexToTrueColor(VAR_0->palette, *VAR_2) : 0;
					}
					VAR_2++;
					VAR_1->frbuff_p.p32++;
				}
			}
#endif /* COMMENT_1 */
		}
		VAR_1->Xtogo -= VAR_4;
		if(VAR_1->Xtogo == 0) {
			#ifdef VAR_10
			if(VAR_5->line_cb) VAR_5->line_cb(VAR_5, VAR_1->line_p, VAR_1->curY);
			#endif /* COMMENT_2 */
			VAR_1->Xtogo = VAR_0->width;
			switch(VAR_1->pass) {
			case 0:
				VAR_1->curY++;
				break;
			case 1:	/* COMMENT_3 */
				VAR_1->curY += 8;
				break;
			case 2:	/* COMMENT_4 */
				VAR_1->curY += 8;
				break;
			case 3:	/* COMMENT_5 */
				VAR_1->curY += 4;
				break;
			case 4:	/* COMMENT_6 */
				VAR_1->curY += 2;
				break;
			}
			while(VAR_1->pass > 0 && VAR_1->pass < 4 &&
			      VAR_1->curY >= VAR_5->height) {
				switch(++VAR_1->pass) {
				case 2:	/* COMMENT_4 */
					VAR_1->curY = VAR_0->posY + 4;
					break;
				case 3:	/* COMMENT_5 */
					VAR_1->curY = VAR_0->posY + 2;
					break;
				case 4:	/* COMMENT_6 */
					VAR_1->curY = VAR_0->posY + 1;
					break;
				}
			}
#ifndef VAR_6
			if(VAR_5->mode & VAR_7) {
#endif/* COMMENT_0 */
				#ifdef NGIFLIB_ENABLE_CALLBACKS
				VAR_1->line_p.p8 = VAR_5->frbuff.p8 + (u32)VAR_1->curY*VAR_5->width;
				VAR_1->frbuff_p.p8 = VAR_1->line_p.p8 + VAR_0->posX;
				#else
				context->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;
				#endif/* COMMENT_7 */
#ifndef VAR_6
			} else {
				#ifdef VAR_10
				VAR_1->line_p.p32 = VAR_5->frbuff.p32 + (u32)VAR_1->curY*VAR_5->width;
				VAR_1->frbuff_p.p32 = VAR_1->line_p.p32 + VAR_0->posX;
				#else
				VAR_1->frbuff_p.p32 = VAR_5->frbuff.p32 + (u32)VAR_1->curY*VAR_5->width + VAR_0->posX;
				#endif /* COMMENT_2 */
			}
#endif /* COMMENT_1 */
		}
		VAR_3 -= VAR_4;
	}
}",miniupnp/ngiflib/5bad360070216388768be9b66d9fb59241e86d66/ngiflib.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -15,8 +15,9 @@
 			} else {
 				int j;
 				for(j = (int)tocopy; j > 0; j--) {
-					*(context->frbuff_p.p32++) =
-					   GifIndexToTrueColor(i->palette, *pixels++);
+					u8 v = *pixels++;
+					*(context->frbuff_p.p32++) = v < i->ncolors ?
+					   GifIndexToTrueColor(i->palette, v) : 0;
 				}
 			}
 #endif /* NGIFLIB_INDEXED_ONLY */
@@ -34,7 +35,7 @@
 			} else {
 				for(j = (int)tocopy; j > 0; j--) {
 					if(*pixels != i->gce.transparent_color) {
-						*context->frbuff_p.p32 = GifIndexToTrueColor(i->palette, *pixels);
+						*context->frbuff_p.p32 = *pixels < i->ncolors ? GifIndexToTrueColor(i->palette, *pixels) : 0;
 					}
 					pixels++;
 					context->frbuff_p.p32++;","{'deleted_lines': ['\t\t\t\t\t*(context->frbuff_p.p32++) =', '\t\t\t\t\t   GifIndexToTrueColor(i->palette, *pixels++);', '\t\t\t\t\t\t*context->frbuff_p.p32 = GifIndexToTrueColor(i->palette, *pixels);'], 'added_lines': ['\t\t\t\t\tu8 v = *pixels++;', '\t\t\t\t\t*(context->frbuff_p.p32++) = v < i->ncolors ?', '\t\t\t\t\t   GifIndexToTrueColor(i->palette, v) : 0;', '\t\t\t\t\t\t*context->frbuff_p.p32 = *pixels < i->ncolors ? GifIndexToTrueColor(i->palette, *pixels) : 0;']}",True,ngiflib 0.4 has a heap-based buffer over-read in GifIndexToTrueColor in ngiflib.c.,8.8,HIGH,2,valid,2019-10-14T19:42:06Z,3
CVE-2019-20219,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,miniupnp/ngiflib,"fix palette read overflow

fixes #15",5bad360070216388768be9b66d9fb59241e86d66,https://github.com/miniupnp/ngiflib/commit/5bad360070216388768be9b66d9fb59241e86d66,ngiflib.c,WritePixel,"static void WritePixel(struct ngiflib_img * i, struct ngiflib_decode_context * context, u8 v) {
struct ngiflib_gif * p = i->parent;
if(v!=i->gce.transparent_color || !i->gce.transparent_flag) {
#ifndef NGIFLIB_INDEXED_ONLY
if(p->mode & NGIFLIB_MODE_INDEXED) {
#endif 
*context->frbuff_p.p8 = v;
#ifndef NGIFLIB_INDEXED_ONLY
} else
*context->frbuff_p.p32 =
GifIndexToTrueColor(i->palette, v);
#endif 
}
if(--(context->Xtogo) <= 0) {
#ifdef NGIFLIB_ENABLE_CALLBACKS
if(p->line_cb) p->line_cb(p, context->line_p, context->curY);
#endif 
context->Xtogo = i->width;
switch(context->pass) {
case 0:
context->curY++;
break;
case 1:
context->curY += 8;
break;
case 2:
context->curY += 8;
break;
case 3:
context->curY += 4;
break;
case 4:
context->curY += 2;
break;
}
while(context->pass > 0 && context->pass < 4 &&
context->curY >= p->height) {
switch(++context->pass) {
case 2:
context->curY = i->posY + 4;
break;
case 3:
context->curY = i->posY + 2;
break;
case 4:
context->curY = i->posY + 1;
break;
}
}
#ifndef NGIFLIB_INDEXED_ONLY
if(p->mode & NGIFLIB_MODE_INDEXED) {
#endif 
#ifdef NGIFLIB_ENABLE_CALLBACKS
context->line_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width;
context->frbuff_p.p8 = context->line_p.p8 + i->posX;
#else
context->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;
#endif 
#ifndef NGIFLIB_INDEXED_ONLY
} else {
#ifdef NGIFLIB_ENABLE_CALLBACKS
context->line_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width;
context->frbuff_p.p32 = context->line_p.p32 + i->posX;
#else
context->frbuff_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width + i->posX;
#endif 
}
#endif 
} else {
#ifndef NGIFLIB_INDEXED_ONLY
if(p->mode & NGIFLIB_MODE_INDEXED) {
#endif 
context->frbuff_p.p8++;
#ifndef NGIFLIB_INDEXED_ONLY
} else {
context->frbuff_p.p32++;
}
#endif 
}
}","static void WritePixel(struct ngiflib_img * VAR_0, struct ngiflib_decode_context * VAR_1, u8 VAR_2) {
struct ngiflib_gif * VAR_3 = VAR_0->parent;
if(VAR_2!=VAR_0->gce.transparent_color || !VAR_0->gce.transparent_flag) {
#ifndef VAR_4
if(VAR_3->mode & VAR_5) {
#endif
*context->frbuff_p.p8 = v;
#ifndef VAR_4
} else
*VAR_1->frbuff_p.p32 =
GifIndexToTrueColor(VAR_0->palette, VAR_2);
#endif 
}
if(--(VAR_1->Xtogo) <= 0) {
#ifdef VAR_6
if(VAR_3->line_cb) VAR_3->line_cb(VAR_3, VAR_1->line_p, VAR_1->curY);
#endif 
VAR_1->Xtogo = VAR_0->width;
switch(VAR_1->pass) {
case 0:
VAR_1->curY++;
break;
case 1:
VAR_1->curY += 8;
break;
case 2:
VAR_1->curY += 8;
break;
case 3:
VAR_1->curY += 4;
break;
case 4:
VAR_1->curY += 2;
break;
}
while(VAR_1->pass > 0 && VAR_1->pass < 4 &&
VAR_1->curY >= VAR_3->height) {
switch(++VAR_1->pass) {
case 2:
VAR_1->curY = VAR_0->posY + 4;
break;
case 3:
VAR_1->curY = VAR_0->posY + 2;
break;
case 4:
VAR_1->curY = VAR_0->posY + 1;
break;
}
}
#ifndef VAR_4
if(VAR_3->mode & VAR_5) {
#endif
#ifdef NGIFLIB_ENABLE_CALLBACKS
VAR_1->line_p.p8 = VAR_3->frbuff.p8 + (u32)VAR_1->curY*VAR_3->width;
VAR_1->frbuff_p.p8 = VAR_1->line_p.p8 + VAR_0->posX;
#else
context->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;
#endif
#ifndef VAR_4
} else {
#ifdef VAR_6
VAR_1->line_p.p32 = VAR_3->frbuff.p32 + (u32)VAR_1->curY*VAR_3->width;
VAR_1->frbuff_p.p32 = VAR_1->line_p.p32 + VAR_0->posX;
#else
VAR_1->frbuff_p.p32 = VAR_3->frbuff.p32 + (u32)VAR_1->curY*VAR_3->width + VAR_0->posX;
#endif 
}
#endif 
} else {
#ifndef VAR_4
if(VAR_3->mode & VAR_5) {
#endif
context->frbuff_p.p8++;
#ifndef VAR_4
} else {
VAR_1->frbuff_p.p32++;
}
#endif 
}
}",miniupnp/ngiflib/5bad360070216388768be9b66d9fb59241e86d66/ngiflib.c/vul/before/2.json,"static void WritePixel(struct ngiflib_img * i, struct ngiflib_decode_context * context, u8 v) {
	struct ngiflib_gif * p = i->parent;

	if(v!=i->gce.transparent_color || !i->gce.transparent_flag) {
#ifndef NGIFLIB_INDEXED_ONLY
		if(p->mode & NGIFLIB_MODE_INDEXED) {
#endif /* NGIFLIB_INDEXED_ONLY */
			*context->frbuff_p.p8 = v;
#ifndef NGIFLIB_INDEXED_ONLY
		} else
			*context->frbuff_p.p32 = v < i->ncolors ?
			   GifIndexToTrueColor(i->palette, v) : 0;
#endif /* NGIFLIB_INDEXED_ONLY */
	}
	if(--(context->Xtogo) <= 0) {
		#ifdef NGIFLIB_ENABLE_CALLBACKS
		if(p->line_cb) p->line_cb(p, context->line_p, context->curY);
		#endif /* NGIFLIB_ENABLE_CALLBACKS */
		context->Xtogo = i->width;
		switch(context->pass) {
		case 0:
			context->curY++;
			break;
		case 1:	/* 1st pass : every eighth row starting from 0 */
			context->curY += 8;
			break;
		case 2:	/* 2nd pass : every eighth row starting from 4 */
			context->curY += 8;
			break;
		case 3:	/* 3rd pass : every fourth row starting from 2 */
			context->curY += 4;
			break;
		case 4:	/* 4th pass : every odd row */
			context->curY += 2;
			break;
		}
		while(context->pass > 0 && context->pass < 4 &&
		      context->curY >= p->height) {
			switch(++context->pass) {
			case 2:	/* 2nd pass : every eighth row starting from 4 */
				context->curY = i->posY + 4;
				break;
			case 3:	/* 3rd pass : every fourth row starting from 2 */
				context->curY = i->posY + 2;
				break;
			case 4:	/* 4th pass : every odd row */
				context->curY = i->posY + 1;
				break;
			}
		}
#ifndef NGIFLIB_INDEXED_ONLY
		if(p->mode & NGIFLIB_MODE_INDEXED) {
#endif /* NGIFLIB_INDEXED_ONLY */
			#ifdef NGIFLIB_ENABLE_CALLBACKS
			context->line_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width;
			context->frbuff_p.p8 = context->line_p.p8 + i->posX;
			#else
			context->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;
			#endif /* NGIFLIB_ENABLE_CALLBACKS */
#ifndef NGIFLIB_INDEXED_ONLY
		} else {
			#ifdef NGIFLIB_ENABLE_CALLBACKS
			context->line_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width;
			context->frbuff_p.p32 = context->line_p.p32 + i->posX;
			#else
			context->frbuff_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width + i->posX;
			#endif /* NGIFLIB_ENABLE_CALLBACKS */
		}
#endif /* NGIFLIB_INDEXED_ONLY */
	} else {
#ifndef NGIFLIB_INDEXED_ONLY
		if(p->mode & NGIFLIB_MODE_INDEXED) {
#endif /* NGIFLIB_INDEXED_ONLY */
			context->frbuff_p.p8++;
#ifndef NGIFLIB_INDEXED_ONLY
		} else {
			context->frbuff_p.p32++;
		}
#endif /* NGIFLIB_INDEXED_ONLY */
	}
}","static void WritePixel(struct ngiflib_img * VAR_0, struct ngiflib_decode_context * VAR_1, u8 VAR_2) {
	struct ngiflib_gif * VAR_3 = VAR_0->parent;

	if(VAR_2!=VAR_0->gce.transparent_color || !VAR_0->gce.transparent_flag) {
#ifndef VAR_4
		if(VAR_3->mode & VAR_5) {
#endif/* COMMENT_0 */
			*context->frbuff_p.p8 = v;
#ifndef VAR_4
		} else
			*VAR_1->frbuff_p.p32 = VAR_2 < VAR_0->ncolors ?
			   GifIndexToTrueColor(VAR_0->palette, VAR_2) : 0;
#endif /* COMMENT_1 */
	}
	if(--(VAR_1->Xtogo) <= 0) {
		#ifdef VAR_6
		if(VAR_3->line_cb) VAR_3->line_cb(VAR_3, VAR_1->line_p, VAR_1->curY);
		#endif /* COMMENT_2 */
		VAR_1->Xtogo = VAR_0->width;
		switch(VAR_1->pass) {
		case 0:
			VAR_1->curY++;
			break;
		case 1:	/* COMMENT_3 */
			VAR_1->curY += 8;
			break;
		case 2:	/* COMMENT_4 */
			VAR_1->curY += 8;
			break;
		case 3:	/* COMMENT_5 */
			VAR_1->curY += 4;
			break;
		case 4:	/* COMMENT_6 */
			VAR_1->curY += 2;
			break;
		}
		while(VAR_1->pass > 0 && VAR_1->pass < 4 &&
		      VAR_1->curY >= VAR_3->height) {
			switch(++VAR_1->pass) {
			case 2:	/* COMMENT_4 */
				VAR_1->curY = VAR_0->posY + 4;
				break;
			case 3:	/* COMMENT_5 */
				VAR_1->curY = VAR_0->posY + 2;
				break;
			case 4:	/* COMMENT_6 */
				VAR_1->curY = VAR_0->posY + 1;
				break;
			}
		}
#ifndef VAR_4
		if(VAR_3->mode & VAR_5) {
#endif/* COMMENT_0 */
			#ifdef NGIFLIB_ENABLE_CALLBACKS
			VAR_1->line_p.p8 = VAR_3->frbuff.p8 + (u32)VAR_1->curY*VAR_3->width;
			VAR_1->frbuff_p.p8 = VAR_1->line_p.p8 + VAR_0->posX;
			#else
			context->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;
			#endif/* COMMENT_7 */
#ifndef VAR_4
		} else {
			#ifdef VAR_6
			VAR_1->line_p.p32 = VAR_3->frbuff.p32 + (u32)VAR_1->curY*VAR_3->width;
			VAR_1->frbuff_p.p32 = VAR_1->line_p.p32 + VAR_0->posX;
			#else
			VAR_1->frbuff_p.p32 = VAR_3->frbuff.p32 + (u32)VAR_1->curY*VAR_3->width + VAR_0->posX;
			#endif /* COMMENT_2 */
		}
#endif /* COMMENT_1 */
	} else {
#ifndef VAR_4
		if(VAR_3->mode & VAR_5) {
#endif/* COMMENT_0 */
			context->frbuff_p.p8++;
#ifndef VAR_4
		} else {
			VAR_1->frbuff_p.p32++;
		}
#endif /* COMMENT_1 */
	}
}",miniupnp/ngiflib/5bad360070216388768be9b66d9fb59241e86d66/ngiflib.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -8,8 +8,8 @@
 			*context->frbuff_p.p8 = v;
 #ifndef NGIFLIB_INDEXED_ONLY
 		} else
-			*context->frbuff_p.p32 =
-			   GifIndexToTrueColor(i->palette, v);
+			*context->frbuff_p.p32 = v < i->ncolors ?
+			   GifIndexToTrueColor(i->palette, v) : 0;
 #endif /* NGIFLIB_INDEXED_ONLY */
 	}
 	if(--(context->Xtogo) <= 0) {","{'deleted_lines': ['\t\t\t*context->frbuff_p.p32 =', '\t\t\t   GifIndexToTrueColor(i->palette, v);'], 'added_lines': ['\t\t\t*context->frbuff_p.p32 = v < i->ncolors ?', '\t\t\t   GifIndexToTrueColor(i->palette, v) : 0;']}",True,ngiflib 0.4 has a heap-based buffer over-read in GifIndexToTrueColor in ngiflib.c.,8.8,HIGH,2,valid,2019-10-14T19:42:06Z,3
CVE-2019-20219,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,miniupnp/ngiflib,"fix palette read overflow

fixes #15",5bad360070216388768be9b66d9fb59241e86d66,https://github.com/miniupnp/ngiflib/commit/5bad360070216388768be9b66d9fb59241e86d66,ngiflib.c,DecodeGifImg,"static int DecodeGifImg(struct ngiflib_img * i) {
struct ngiflib_decode_context context;
long npix;
u8 * stackp;
u8 * stack_top;
u16 clr;
u16 eof;
u16 free;
u16 act_code = 0;
u16 old_code = 0;
u16 read_byt;
u16 ab_prfx[4096];
u8 ab_suffx[4096];
u8 ab_stack[4096];
u8 flags;
u8 casspecial = 0;
if(!i) return -1;
i->posX = GetWord(i->parent);
i->posY = GetWord(i->parent);
i->width = GetWord(i->parent);
i->height = GetWord(i->parent);
if((i->width > i->parent->width) || (i->height > i->parent->height)) {
#if !defined(NGIFLIB_NO_FILE)
if(i->parent->log) fprintf(i->parent->log, ""*** ERROR *** Image bigger than global GIF canvas !\n"");
#endif
return -1;
}
if((i->posX + i->width) > i->parent->width) {
#if !defined(NGIFLIB_NO_FILE)
if(i->parent->log) fprintf(i->parent->log, ""*** WARNING *** Adjusting X position\n"");
#endif
i->posX = i->parent->width - i->width;
}
if((i->posY + i->height) > i->parent->height) {
#if !defined(NGIFLIB_NO_FILE)
if(i->parent->log) fprintf(i->parent->log, ""*** WARNING *** Adjusting Y position\n"");
#endif
i->posY = i->parent->height - i->height;
}
context.Xtogo = i->width;
context.curY = i->posY;
#ifdef NGIFLIB_INDEXED_ONLY
#ifdef NGIFLIB_ENABLE_CALLBACKS
context.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;
context.frbuff_p.p8 = context.line_p.p8 + i->posX;
#else
context.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;
#endif 
#else
if(i->parent->mode & NGIFLIB_MODE_INDEXED) {
#ifdef NGIFLIB_ENABLE_CALLBACKS
context.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;
context.frbuff_p.p8 = context.line_p.p8 + i->posX;
#else
context.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;
#endif 
} else {
#ifdef NGIFLIB_ENABLE_CALLBACKS
context.line_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width;
context.frbuff_p.p32 = context.line_p.p32 + i->posX;
#else
context.frbuff_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width + i->posX;
#endif 
}
#endif 
npix = (long)i->width * i->height;
flags = GetByte(i->parent);
i->interlaced = (flags & 64) >> 6;
context.pass = i->interlaced ? 1 : 0;
i->sort_flag = (flags & 32) >> 5;
i->localpalbits = (flags & 7) + 1;
if(flags&128) { 
int k;
int localpalsize = 1 << i->localpalbits;
#if !defined(NGIFLIB_NO_FILE)
if(i->parent && i->parent->log) fprintf(i->parent->log, ""Local palette\n"");
#endif 
i->palette = (struct ngiflib_rgb *)ngiflib_malloc(sizeof(struct ngiflib_rgb)*localpalsize);
for(k=0; k<localpalsize; k++) {
i->palette[k].r = GetByte(i->parent);
i->palette[k].g = GetByte(i->parent);
i->palette[k].b = GetByte(i->parent);
}
#ifdef NGIFLIB_ENABLE_CALLBACKS
if(i->parent->palette_cb) i->parent->palette_cb(i->parent, i->palette, localpalsize);
#endif 
} else {
i->palette = i->parent->palette;
i->localpalbits = i->parent->imgbits;
}
i->ncolors = 1 << i->localpalbits;
i->imgbits = GetByte(i->parent);
if (i->imgbits > 11) {
#if !defined(NGIFLIB_NO_FILE)
if(i->parent->log) fprintf(i->parent->log, ""*** ERROR *** Invalid LZW Minimum Code Size : %d\n"", (int)i->imgbits);
#endif
return -1;
}
#if !defined(NGIFLIB_NO_FILE)
if(i->parent && i->parent->log) {
if(i->interlaced) fprintf(i->parent->log, ""interlaced "");
fprintf(i->parent->log, ""img pos(%hu,%hu) size %hux%hu palbits=%hhu imgbits=%hhu ncolors=%hu\n"",
i->posX, i->posY, i->width, i->height, i->localpalbits, i->imgbits, i->ncolors);
}
#endif 
if(i->imgbits==1) {
i->imgbits = 2;
}
clr = 1 << i->imgbits;
eof = clr + 1;
free = clr + 2;
context.nbbit = i->imgbits + 1;
context.max = clr + clr - 1; 
stackp = stack_top = ab_stack + 4096;
context.restbits = 0;
context.restbyte = 0;
context.lbyte = 0;
for(;;) {
act_code = GetGifWord(i, &context);
if(act_code==eof) {
#if !defined(NGIFLIB_NO_FILE)
if(i->parent && i->parent->log) fprintf(i->parent->log, ""End of image code 0x%x (nbbit=%u)\n"", eof, context.nbbit);
#endif 
return 0;
}
if(npix==0) {
#if !defined(NGIFLIB_NO_FILE)
if(i->parent && i->parent->log) fprintf(i->parent->log, ""assez de pixels, On se casse !\n"");
#endif 
return 1;
}
if(act_code==clr) {
#if !defined(NGIFLIB_NO_FILE)
if(i->parent && i->parent->log) fprintf(i->parent->log, ""Code clear (%hu) (free=%hu) npix=%ld\n"", clr, free, npix);
#endif 
free = clr + 2;
context.nbbit = i->imgbits + 1;
context.max = clr + clr - 1; 
act_code = GetGifWord(i, &context);
if (act_code >= clr)
{
#if !defined(NGIFLIB_NO_FILE)
if(i->parent && i->parent->log) fprintf(i->parent->log, ""Invalid code %hu just after clear(%hu) !\n"", act_code, clr);
#endif 
return -1;
}
casspecial = (u8)act_code;
old_code = act_code;
if(npix > 0) WritePixel(i, &context, casspecial);
npix--;
} else if(act_code > free) {
#if !defined(NGIFLIB_NO_FILE)
if(i->parent && i->parent->log) fprintf(i->parent->log, ""Invalid code %hu (free=%hu) !\n"", act_code, free);
#endif 
return -1;
} else {
read_byt = act_code;
if(act_code == free) {
*(--stackp) = casspecial; 
act_code = old_code;
}
while(act_code > clr) { 
*(--stackp) = ab_suffx[act_code];
act_code = ab_prfx[act_code];
}
casspecial = (u8)act_code;
*(--stackp) = casspecial;
if(npix >= (stack_top - stackp)) {
WritePixels(i, &context, stackp, stack_top - stackp);
} else if(npix > 0) {
WritePixels(i, &context, stackp, npix);
}
npix -= (stack_top - stackp);
stackp = stack_top;
if(free < 4096) { 
ab_prfx[free] = old_code;
ab_suffx[free] = (u8)act_code;
free++;
if((free > context.max) && (context.nbbit < 12)) {
context.nbbit++;
context.max += context.max + 1;
}
}
old_code = read_byt;
}
}
return 0;
}","static int DecodeGifImg(struct ngiflib_img * VAR_0) {
struct ngiflib_decode_context VAR_1;
long VAR_2;
u8 * VAR_3;
u8 * VAR_4;
u16 VAR_5;
u16 VAR_6;
u16 VAR_7;
u16 VAR_8 = 0;
u16 VAR_9 = 0;
u16 VAR_10;
u16 VAR_11[4096];
u8 VAR_12[4096];
u8 VAR_13[4096];
u8 VAR_14;
u8 VAR_15 = 0;
if(!VAR_0) return -1;
VAR_0->posX = GetWord(VAR_0->parent);
VAR_0->posY = GetWord(VAR_0->parent);
VAR_0->width = GetWord(VAR_0->parent);
VAR_0->height = GetWord(VAR_0->parent);
if((VAR_0->width > VAR_0->parent->width) || (VAR_0->height > VAR_0->parent->height)) {
#if !defined(VAR_16)
if(VAR_0->parent->log) fprintf(VAR_0->parent->log, ""*** ERROR *** Image bigger than global GIF canvas !\n"");
#endif
return -1;
}
if((VAR_0->posX + VAR_0->width) > VAR_0->parent->width) {
#if !defined(VAR_16)
if(VAR_0->parent->log) fprintf(VAR_0->parent->log, ""*** WARNING *** Adjusting X position\n"");
#endif
VAR_0->posX = VAR_0->parent->width - VAR_0->width;
}
if((VAR_0->posY + VAR_0->height) > VAR_0->parent->height) {
#if !defined(VAR_16)
if(VAR_0->parent->log) fprintf(VAR_0->parent->log, ""*** WARNING *** Adjusting Y position\n"");
#endif
VAR_0->posY = VAR_0->parent->height - VAR_0->height;
}
VAR_1.Xtogo = VAR_0->width;
VAR_1.curY = VAR_0->posY;
#ifdef VAR_17
#ifdef VAR_18
VAR_1.line_p.p8 = VAR_0->parent->frbuff.p8 + (u32)VAR_0->posY*VAR_0->parent->width;
VAR_1.frbuff_p.p8 = VAR_1.line_p.p8 + VAR_0->posX;
#else
VAR_1.frbuff_p.p8 = VAR_0->parent->frbuff.p8 + (u32)VAR_0->posY*VAR_0->parent->width + VAR_0->posX;
#endif 
#else
if(VAR_0->parent->mode & VAR_19) {
#ifdef VAR_18
VAR_1.line_p.p8 = VAR_0->parent->frbuff.p8 + (u32)VAR_0->posY*VAR_0->parent->width;
VAR_1.frbuff_p.p8 = VAR_1.line_p.p8 + VAR_0->posX;
#else
VAR_1.frbuff_p.p8 = VAR_0->parent->frbuff.p8 + (u32)VAR_0->posY*VAR_0->parent->width + VAR_0->posX;
#endif 
} else {
#ifdef VAR_18
VAR_1.line_p.p32 = VAR_0->parent->frbuff.p32 + (u32)VAR_0->posY*VAR_0->parent->width;
VAR_1.frbuff_p.p32 = VAR_1.line_p.p32 + VAR_0->posX;
#else
VAR_1.frbuff_p.p32 = VAR_0->parent->frbuff.p32 + (u32)VAR_0->posY*VAR_0->parent->width + VAR_0->posX;
#endif 
}
#endif 
VAR_2 = (long)VAR_0->width * VAR_0->height;
VAR_14 = GetByte(VAR_0->parent);
VAR_0->interlaced = (VAR_14 & 64) >> 6;
VAR_1.pass = VAR_0->interlaced ? 1 : 0;
VAR_0->sort_flag = (VAR_14 & 32) >> 5;
VAR_0->localpalbits = (VAR_14 & 7) + 1;
if(VAR_14&128) { 
int VAR_20;
int VAR_21 = 1 << VAR_0->localpalbits;
#if !defined(VAR_16)
if(VAR_0->parent && VAR_0->parent->log) fprintf(VAR_0->parent->log, ""Local palette\n"");
#endif 
VAR_0->palette = (struct ngiflib_rgb *)ngiflib_malloc(sizeof(struct ngiflib_rgb)*VAR_21);
for(VAR_20=0; VAR_20<VAR_21; VAR_20++) {
VAR_0->palette[VAR_20].r = GetByte(VAR_0->parent);
VAR_0->palette[VAR_20].g = GetByte(VAR_0->parent);
VAR_0->palette[VAR_20].b = GetByte(VAR_0->parent);
}
#ifdef VAR_18
if(VAR_0->parent->palette_cb) VAR_0->parent->palette_cb(VAR_0->parent, VAR_0->palette, VAR_21);
#endif 
} else {
VAR_0->palette = VAR_0->parent->palette;
VAR_0->localpalbits = VAR_0->parent->imgbits;
}
VAR_0->ncolors = 1 << VAR_0->localpalbits;
VAR_0->imgbits = GetByte(VAR_0->parent);
if (VAR_0->imgbits > 11) {
#if !defined(VAR_16)
if(VAR_0->parent->log) fprintf(VAR_0->parent->log, ""*** ERROR *** Invalid LZW Minimum Code Size : %d\n"", (int)VAR_0->imgbits);
#endif
return -1;
}
#if !defined(VAR_16)
if(VAR_0->parent && VAR_0->parent->log) {
if(VAR_0->interlaced) fprintf(VAR_0->parent->log, ""interlaced "");
fprintf(VAR_0->parent->log, ""img pos(%hu,%hu) size %hux%hu palbits=%hhu imgbits=%hhu ncolors=%hu\n"",
VAR_0->posX, VAR_0->posY, VAR_0->width, VAR_0->height, VAR_0->localpalbits, VAR_0->imgbits, VAR_0->ncolors);
}
#endif 
if(VAR_0->imgbits==1) {
VAR_0->imgbits = 2;
}
VAR_5 = 1 << VAR_0->imgbits;
VAR_6 = VAR_5 + 1;
VAR_7 = VAR_5 + 2;
VAR_1.nbbit = VAR_0->imgbits + 1;
VAR_1.max = VAR_5 + VAR_5 - 1; 
VAR_3 = VAR_4 = VAR_13 + 4096;
VAR_1.restbits = 0;
VAR_1.restbyte = 0;
VAR_1.lbyte = 0;
for(;;) {
VAR_8 = GetGifWord(VAR_0, &VAR_1);
if(VAR_8==VAR_6) {
#if !defined(VAR_16)
if(VAR_0->parent && VAR_0->parent->log) fprintf(VAR_0->parent->log, ""End of image code 0x%x (nbbit=%u)\n"", VAR_6, VAR_1.nbbit);
#endif 
return 0;
}
if(VAR_2==0) {
#if !defined(VAR_16)
if(VAR_0->parent && VAR_0->parent->log) fprintf(VAR_0->parent->log, ""assez de pixels, On se casse !\n"");
#endif 
return 1;
}
if(VAR_8==VAR_5) {
#if !defined(VAR_16)
if(VAR_0->parent && VAR_0->parent->log) fprintf(VAR_0->parent->log, ""Code clear (%hu) (free=%hu) npix=%ld\n"", VAR_5, VAR_7, VAR_2);
#endif 
VAR_7 = VAR_5 + 2;
VAR_1.nbbit = VAR_0->imgbits + 1;
VAR_1.max = VAR_5 + VAR_5 - 1; 
VAR_8 = GetGifWord(VAR_0, &VAR_1);
if (VAR_8 >= VAR_5)
{
#if !defined(VAR_16)
if(VAR_0->parent && VAR_0->parent->log) fprintf(VAR_0->parent->log, ""Invalid code %hu just after clear(%hu) !\n"", VAR_8, VAR_5);
#endif 
return -1;
}
VAR_15 = (u8)VAR_8;
VAR_9 = VAR_8;
if(VAR_2 > 0) WritePixel(VAR_0, &VAR_1, VAR_15);
VAR_2--;
} else if(VAR_8 > VAR_7) {
#if !defined(VAR_16)
if(VAR_0->parent && VAR_0->parent->log) fprintf(VAR_0->parent->log, ""Invalid code %hu (free=%hu) !\n"", VAR_8, VAR_7);
#endif 
return -1;
} else {
VAR_10 = VAR_8;
if(VAR_8 == VAR_7) {
*(--VAR_3) = VAR_15; 
VAR_8 = VAR_9;
}
while(VAR_8 > VAR_5) { 
*(--VAR_3) = VAR_12[VAR_8];
VAR_8 = VAR_11[VAR_8];
}
VAR_15 = (u8)VAR_8;
*(--VAR_3) = VAR_15;
if(VAR_2 >= (VAR_4 - VAR_3)) {
WritePixels(VAR_0, &VAR_1, VAR_3, VAR_4 - VAR_3);
} else if(VAR_2 > 0) {
WritePixels(VAR_0, &VAR_1, VAR_3, VAR_2);
}
VAR_2 -= (VAR_4 - VAR_3);
VAR_3 = VAR_4;
if(VAR_7 < 4096) { 
VAR_11[VAR_7] = VAR_9;
VAR_12[VAR_7] = (u8)VAR_8;
VAR_7++;
if((VAR_7 > VAR_1.max) && (VAR_1.nbbit < 12)) {
VAR_1.nbbit++;
VAR_1.max += VAR_1.max + 1;
}
}
VAR_9 = VAR_10;
}
}
return 0;
}",miniupnp/ngiflib/5bad360070216388768be9b66d9fb59241e86d66/ngiflib.c/vul/before/1.json,"static int DecodeGifImg(struct ngiflib_img * i) {
	struct ngiflib_decode_context context;
	long npix;
	u8 * stackp;
	u8 * stack_top;
	u16 clr;
	u16 eof;
	u16 free;
	u16 act_code = 0;
	u16 old_code = 0;
	u16 read_byt;
	u16 ab_prfx[4096];
	u8 ab_suffx[4096];
	u8 ab_stack[4096];
	u8 flags;
	u8 casspecial = 0;

	if(!i) return -1;

	i->posX = GetWord(i->parent);	/* offsetX */
	i->posY = GetWord(i->parent);	/* offsetY */
	i->width = GetWord(i->parent);	/* SizeX   */
	i->height = GetWord(i->parent);	/* SizeY   */

	if((i->width > i->parent->width) || (i->height > i->parent->height)) {
#if !defined(NGIFLIB_NO_FILE)
		if(i->parent->log) fprintf(i->parent->log, ""*** ERROR *** Image bigger than global GIF canvas !\n"");
#endif
		return -1;
	}
	if((i->posX + i->width) > i->parent->width) {
#if !defined(NGIFLIB_NO_FILE)
		if(i->parent->log) fprintf(i->parent->log, ""*** WARNING *** Adjusting X position\n"");
#endif
		i->posX = i->parent->width - i->width;
	}
	if((i->posY + i->height) > i->parent->height) {
#if !defined(NGIFLIB_NO_FILE)
		if(i->parent->log) fprintf(i->parent->log, ""*** WARNING *** Adjusting Y position\n"");
#endif
		i->posY = i->parent->height - i->height;
	}
	context.Xtogo = i->width;
	context.curY = i->posY;
#ifdef NGIFLIB_INDEXED_ONLY
	#ifdef NGIFLIB_ENABLE_CALLBACKS
	context.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;
	context.frbuff_p.p8 = context.line_p.p8 + i->posX;
	#else
	context.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;
	#endif /* NGIFLIB_ENABLE_CALLBACKS */
#else
	if(i->parent->mode & NGIFLIB_MODE_INDEXED) {
		#ifdef NGIFLIB_ENABLE_CALLBACKS
		context.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;
		context.frbuff_p.p8 = context.line_p.p8 + i->posX;
		#else
		context.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;
		#endif /* NGIFLIB_ENABLE_CALLBACKS */
	} else {
		#ifdef NGIFLIB_ENABLE_CALLBACKS
		context.line_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width;
		context.frbuff_p.p32 = context.line_p.p32 + i->posX;
		#else
		context.frbuff_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width + i->posX;
		#endif /* NGIFLIB_ENABLE_CALLBACKS */
	}
#endif /* NGIFLIB_INDEXED_ONLY */

	npix = (long)i->width * i->height;
	flags = GetByte(i->parent);
	i->interlaced = (flags & 64) >> 6;
	context.pass = i->interlaced ? 1 : 0;
	i->sort_flag = (flags & 32) >> 5;	/* is local palette sorted by color frequency ? */
	i->localpalbits = (flags & 7) + 1;
	if(flags&128) { /* palette locale */
		int k;
		int localpalsize = 1 << i->localpalbits;
#if !defined(NGIFLIB_NO_FILE)
		if(i->parent && i->parent->log) fprintf(i->parent->log, ""Local palette\n"");
#endif /* !defined(NGIFLIB_NO_FILE) */
		i->palette = (struct ngiflib_rgb *)ngiflib_malloc(sizeof(struct ngiflib_rgb)*localpalsize);
		for(k=0; k<localpalsize; k++) {
			i->palette[k].r = GetByte(i->parent);
			i->palette[k].g = GetByte(i->parent);
			i->palette[k].b = GetByte(i->parent);
		}
#ifdef NGIFLIB_ENABLE_CALLBACKS
		if(i->parent->palette_cb) i->parent->palette_cb(i->parent, i->palette, localpalsize);
#endif /* NGIFLIB_ENABLE_CALLBACKS */
	} else {
		/* use global palette */
		i->palette = i->parent->palette;
		i->localpalbits = i->parent->imgbits;
	}
	i->ncolors = 1 << i->localpalbits;
	
	i->imgbits = GetByte(i->parent);	/* LZW Minimum Code Size */
	if (i->imgbits > 11) {
#if !defined(NGIFLIB_NO_FILE)
		if(i->parent->log) fprintf(i->parent->log, ""*** ERROR *** Invalid LZW Minimum Code Size : %d\n"", (int)i->imgbits);
#endif
		return -1;
	}

#if !defined(NGIFLIB_NO_FILE)
	if(i->parent && i->parent->log) {
		if(i->interlaced) fprintf(i->parent->log, ""interlaced "");
		fprintf(i->parent->log, ""img pos(%hu,%hu) size %hux%hu palbits=%hhu imgbits=%hhu ncolors=%hu\n"",
	       i->posX, i->posY, i->width, i->height, i->localpalbits, i->imgbits, i->ncolors);
	}
#endif /* !defined(NGIFLIB_NO_FILE) */

	if(i->imgbits==1) {	/* fix for 1bit images ? */
		i->imgbits = 2;
	}
	clr = 1 << i->imgbits;
	eof = clr + 1;
	free = clr + 2;
	context.nbbit = i->imgbits + 1;
	context.max = clr + clr - 1; /* (1 << context.nbbit) - 1 */
	stackp = stack_top = ab_stack + 4096;
	
	context.restbits = 0;	/* initialise le ""buffer"" de lecture */
	context.restbyte = 0;	/* des codes LZW */
	context.lbyte = 0;
	for(;;) {
		act_code = GetGifWord(i, &context);
		if(act_code==eof) {
#if !defined(NGIFLIB_NO_FILE)
			if(i->parent && i->parent->log) fprintf(i->parent->log, ""End of image code 0x%x (nbbit=%u)\n"", eof, context.nbbit);
#endif /* !defined(NGIFLIB_NO_FILE) */
			return 0;
		}
		if(npix==0) {
#if !defined(NGIFLIB_NO_FILE)
			if(i->parent && i->parent->log) fprintf(i->parent->log, ""assez de pixels, On se casse !\n"");
#endif /* !defined(NGIFLIB_NO_FILE) */
			return 1;
		}	
		if(act_code==clr) {
#if !defined(NGIFLIB_NO_FILE)
			if(i->parent && i->parent->log) fprintf(i->parent->log, ""Code clear (%hu) (free=%hu) npix=%ld\n"", clr, free, npix);
#endif /* !defined(NGIFLIB_NO_FILE) */
			/* clear */
			free = clr + 2;
			context.nbbit = i->imgbits + 1;
			context.max = clr + clr - 1; /* (1 << context.nbbit) - 1 */
			act_code = GetGifWord(i, &context);	/* the first code after the clear code is concrete */
			if (act_code >= clr)
			{
#if !defined(NGIFLIB_NO_FILE)
				if(i->parent && i->parent->log) fprintf(i->parent->log, ""Invalid code %hu just after clear(%hu) !\n"", act_code, clr);
#endif /* !defined(NGIFLIB_NO_FILE) */
				return -1;
			}
			casspecial = (u8)act_code;
			old_code = act_code;
			if(npix > 0) WritePixel(i, &context, casspecial);
			npix--;
		} else if(act_code > free) {
#if !defined(NGIFLIB_NO_FILE)
			if(i->parent && i->parent->log) fprintf(i->parent->log, ""Invalid code %hu (free=%hu) !\n"", act_code, free);
#endif /* !defined(NGIFLIB_NO_FILE) */
			return -1;
		} else {
			read_byt = act_code;
			if(act_code == free) {	/* code pas encore dans alphabet */
/*				printf(""Code pas dans alphabet : %d>=%d push %d\n"", act_code, free, casspecial); */
				*(--stackp) = casspecial; /* dernier debut de chaine ! */
				act_code = old_code;
			}
/*			printf(""actcode=%d\n"", act_code); */
			while(act_code > clr) { /* code non concret */
				/* fillstackloop empile les suffixes ! */
				*(--stackp) = ab_suffx[act_code];
				act_code = ab_prfx[act_code];	/* prefixe */
			}
			/* act_code est concret */
			casspecial = (u8)act_code;	/* dernier debut de chaine ! */
			*(--stackp) = casspecial;	/* push on stack */
			if(npix >= (stack_top - stackp)) {
				WritePixels(i, &context, stackp, stack_top - stackp);	/* unstack all pixels at once */
			} else if(npix > 0) {	/* ""pixel overflow"" */
				WritePixels(i, &context, stackp, npix);
			}
			npix -= (stack_top - stackp);
			stackp = stack_top;
/*			putchar('\n'); */
			if(free < 4096) { /* la taille du dico est 4096 max ! */
				ab_prfx[free] = old_code;
				ab_suffx[free] = (u8)act_code;
				free++;
				if((free > context.max) && (context.nbbit < 12)) {
					context.nbbit++;	/* 1 bit de plus pour les codes LZW */
					context.max += context.max + 1;
				}
			}
			old_code = read_byt;
		}
			
	}
	return 0;
}","static int DecodeGifImg(struct ngiflib_img * VAR_0) {
	struct ngiflib_decode_context VAR_1;
	long VAR_2;
	u8 * VAR_3;
	u8 * VAR_4;
	u16 VAR_5;
	u16 VAR_6;
	u16 VAR_7;
	u16 VAR_8 = 0;
	u16 VAR_9 = 0;
	u16 VAR_10;
	u16 VAR_11[4096];
	u8 VAR_12[4096];
	u8 VAR_13[4096];
	u8 VAR_14;
	u8 VAR_15 = 0;

	if(!VAR_0) return -1;

	VAR_0->posX = GetWord(VAR_0->parent);	/* COMMENT_0 */
	VAR_0->posY = GetWord(VAR_0->parent);	/* COMMENT_1 */
	VAR_0->width = GetWord(VAR_0->parent);	/* COMMENT_2 */
	VAR_0->height = GetWord(VAR_0->parent);	/* COMMENT_3 */

	if((VAR_0->width > VAR_0->parent->width) || (VAR_0->height > VAR_0->parent->height)) {
#if !defined(VAR_16)
		if(VAR_0->parent->log) fprintf(VAR_0->parent->log, ""*** ERROR *** Image bigger than global GIF canvas !\n"");
#endif
		return -1;
	}
	if((VAR_0->posX + VAR_0->width) > VAR_0->parent->width) {
#if !defined(VAR_16)
		if(VAR_0->parent->log) fprintf(VAR_0->parent->log, ""*** WARNING *** Adjusting X position\n"");
#endif
		VAR_0->posX = VAR_0->parent->width - VAR_0->width;
	}
	if((VAR_0->posY + VAR_0->height) > VAR_0->parent->height) {
#if !defined(VAR_16)
		if(VAR_0->parent->log) fprintf(VAR_0->parent->log, ""*** WARNING *** Adjusting Y position\n"");
#endif
		VAR_0->posY = VAR_0->parent->height - VAR_0->height;
	}
	VAR_1.Xtogo = VAR_0->width;
	VAR_1.curY = VAR_0->posY;
#ifdef VAR_17
	#ifdef VAR_18
	VAR_1.line_p.p8 = VAR_0->parent->frbuff.p8 + (u32)VAR_0->posY*VAR_0->parent->width;
	VAR_1.frbuff_p.p8 = VAR_1.line_p.p8 + VAR_0->posX;
	#else
	VAR_1.frbuff_p.p8 = VAR_0->parent->frbuff.p8 + (u32)VAR_0->posY*VAR_0->parent->width + VAR_0->posX;
	#endif /* COMMENT_4 */
#else
	if(VAR_0->parent->mode & VAR_19) {
		#ifdef VAR_18
		VAR_1.line_p.p8 = VAR_0->parent->frbuff.p8 + (u32)VAR_0->posY*VAR_0->parent->width;
		VAR_1.frbuff_p.p8 = VAR_1.line_p.p8 + VAR_0->posX;
		#else
		VAR_1.frbuff_p.p8 = VAR_0->parent->frbuff.p8 + (u32)VAR_0->posY*VAR_0->parent->width + VAR_0->posX;
		#endif /* COMMENT_4 */
	} else {
		#ifdef VAR_18
		VAR_1.line_p.p32 = VAR_0->parent->frbuff.p32 + (u32)VAR_0->posY*VAR_0->parent->width;
		VAR_1.frbuff_p.p32 = VAR_1.line_p.p32 + VAR_0->posX;
		#else
		VAR_1.frbuff_p.p32 = VAR_0->parent->frbuff.p32 + (u32)VAR_0->posY*VAR_0->parent->width + VAR_0->posX;
		#endif /* COMMENT_4 */
	}
#endif /* COMMENT_5 */

	VAR_2 = (long)VAR_0->width * VAR_0->height;
	VAR_14 = GetByte(VAR_0->parent);
	VAR_0->interlaced = (VAR_14 & 64) >> 6;
	VAR_1.pass = VAR_0->interlaced ? 1 : 0;
	VAR_0->sort_flag = (VAR_14 & 32) >> 5;	/* COMMENT_6 */
	VAR_0->localpalbits = (VAR_14 & 7) + 1;
	if(VAR_14&128) { /* COMMENT_7 */
		int VAR_20;
		int VAR_21 = 1 << VAR_0->localpalbits;
#if !defined(VAR_16)
		if(VAR_0->parent && VAR_0->parent->log) fprintf(VAR_0->parent->log, ""Local palette\n"");
#endif /* COMMENT_8 */
		VAR_0->palette = (struct ngiflib_rgb *)ngiflib_malloc(sizeof(struct ngiflib_rgb)*VAR_21);
		for(VAR_20=0; VAR_20<VAR_21; VAR_20++) {
			VAR_0->palette[VAR_20].r = GetByte(VAR_0->parent);
			VAR_0->palette[VAR_20].g = GetByte(VAR_0->parent);
			VAR_0->palette[VAR_20].b = GetByte(VAR_0->parent);
		}
#ifdef VAR_18
		if(VAR_0->parent->palette_cb) VAR_0->parent->palette_cb(VAR_0->parent, VAR_0->palette, VAR_21);
#endif /* COMMENT_4 */
	} else {
		/* COMMENT_9 */
		VAR_0->palette = VAR_0->parent->palette;
		VAR_0->localpalbits = VAR_0->parent->imgbits;
	}
	VAR_0->ncolors = 1 << VAR_0->localpalbits;
	
	VAR_0->imgbits = GetByte(VAR_0->parent);	/* COMMENT_10 */
	if (VAR_0->imgbits > 11) {
#if !defined(VAR_16)
		if(VAR_0->parent->log) fprintf(VAR_0->parent->log, ""*** ERROR *** Invalid LZW Minimum Code Size : %d\n"", (int)VAR_0->imgbits);
#endif
		return -1;
	}

#if !defined(VAR_16)
	if(VAR_0->parent && VAR_0->parent->log) {
		if(VAR_0->interlaced) fprintf(VAR_0->parent->log, ""interlaced "");
		fprintf(VAR_0->parent->log, ""img pos(%hu,%hu) size %hux%hu palbits=%hhu imgbits=%hhu ncolors=%hu\n"",
	       VAR_0->posX, VAR_0->posY, VAR_0->width, VAR_0->height, VAR_0->localpalbits, VAR_0->imgbits, VAR_0->ncolors);
	}
#endif /* COMMENT_8 */

	if(VAR_0->imgbits==1) {	/* COMMENT_11 */
		VAR_0->imgbits = 2;
	}
	VAR_5 = 1 << VAR_0->imgbits;
	VAR_6 = VAR_5 + 1;
	VAR_7 = VAR_5 + 2;
	VAR_1.nbbit = VAR_0->imgbits + 1;
	VAR_1.max = VAR_5 + VAR_5 - 1; /* COMMENT_12 */
	VAR_3 = VAR_4 = VAR_13 + 4096;
	
	VAR_1.restbits = 0;	/* COMMENT_13 */
	VAR_1.restbyte = 0;	/* COMMENT_14 */
	VAR_1.lbyte = 0;
	for(;;) {
		VAR_8 = GetGifWord(VAR_0, &VAR_1);
		if(VAR_8==VAR_6) {
#if !defined(VAR_16)
			if(VAR_0->parent && VAR_0->parent->log) fprintf(VAR_0->parent->log, ""End of image code 0x%x (nbbit=%u)\n"", VAR_6, VAR_1.nbbit);
#endif /* COMMENT_8 */
			return 0;
		}
		if(VAR_2==0) {
#if !defined(VAR_16)
			if(VAR_0->parent && VAR_0->parent->log) fprintf(VAR_0->parent->log, ""assez de pixels, On se casse !\n"");
#endif /* COMMENT_8 */
			return 1;
		}	
		if(VAR_8==VAR_5) {
#if !defined(VAR_16)
			if(VAR_0->parent && VAR_0->parent->log) fprintf(VAR_0->parent->log, ""Code clear (%hu) (free=%hu) npix=%ld\n"", VAR_5, VAR_7, VAR_2);
#endif /* COMMENT_8 */
			/* COMMENT_15 */
			VAR_7 = VAR_5 + 2;
			VAR_1.nbbit = VAR_0->imgbits + 1;
			VAR_1.max = VAR_5 + VAR_5 - 1; /* COMMENT_12 */
			VAR_8 = GetGifWord(VAR_0, &VAR_1);	/* COMMENT_16 */
			if (VAR_8 >= VAR_5)
			{
#if !defined(VAR_16)
				if(VAR_0->parent && VAR_0->parent->log) fprintf(VAR_0->parent->log, ""Invalid code %hu just after clear(%hu) !\n"", VAR_8, VAR_5);
#endif /* COMMENT_8 */
				return -1;
			}
			VAR_15 = (u8)VAR_8;
			VAR_9 = VAR_8;
			if(VAR_2 > 0) WritePixel(VAR_0, &VAR_1, VAR_15);
			VAR_2--;
		} else if(VAR_8 > VAR_7) {
#if !defined(VAR_16)
			if(VAR_0->parent && VAR_0->parent->log) fprintf(VAR_0->parent->log, ""Invalid code %hu (free=%hu) !\n"", VAR_8, VAR_7);
#endif /* COMMENT_8 */
			return -1;
		} else {
			VAR_10 = VAR_8;
			if(VAR_8 == VAR_7) {	/* COMMENT_17 */
/* COMMENT_18 */
				*(--VAR_3) = VAR_15; /* COMMENT_19 */
				VAR_8 = VAR_9;
			}
/* COMMENT_20 */
			while(VAR_8 > VAR_5) { /* COMMENT_21 */
				/* COMMENT_22 */
				*(--VAR_3) = VAR_12[VAR_8];
				VAR_8 = VAR_11[VAR_8];	/* COMMENT_23 */
			}
			/* COMMENT_24 */
			VAR_15 = (u8)VAR_8;	/* COMMENT_19 */
			*(--VAR_3) = VAR_15;	/* COMMENT_25 */
			if(VAR_2 >= (VAR_4 - VAR_3)) {
				WritePixels(VAR_0, &VAR_1, VAR_3, VAR_4 - VAR_3);	/* COMMENT_26 */
			} else if(VAR_2 > 0) {	/* COMMENT_27 */
				WritePixels(VAR_0, &VAR_1, VAR_3, VAR_2);
			}
			VAR_2 -= (VAR_4 - VAR_3);
			VAR_3 = VAR_4;
/* COMMENT_28 */
			if(VAR_7 < 4096) { /* COMMENT_29 */
				VAR_11[VAR_7] = VAR_9;
				VAR_12[VAR_7] = (u8)VAR_8;
				VAR_7++;
				if((VAR_7 > VAR_1.max) && (VAR_1.nbbit < 12)) {
					VAR_1.nbbit++;	/* COMMENT_30 */
					VAR_1.max += VAR_1.max + 1;
				}
			}
			VAR_9 = VAR_10;
		}
			
	}
	return 0;
}",miniupnp/ngiflib/5bad360070216388768be9b66d9fb59241e86d66/ngiflib.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -89,6 +89,7 @@
 		if(i->parent->palette_cb) i->parent->palette_cb(i->parent, i->palette, localpalsize);
 #endif /* NGIFLIB_ENABLE_CALLBACKS */
 	} else {
+		/* use global palette */
 		i->palette = i->parent->palette;
 		i->localpalbits = i->parent->imgbits;
 	}","{'deleted_lines': [], 'added_lines': ['\t\t/* use global palette */']}",True,ngiflib 0.4 has a heap-based buffer over-read in GifIndexToTrueColor in ngiflib.c.,8.8,HIGH,2,valid,2019-10-14T19:42:06Z,3
CVE-2019-20219,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,miniupnp/ngiflib,"fix palette read overflow

fixes #15",5bad360070216388768be9b66d9fb59241e86d66,https://github.com/miniupnp/ngiflib/commit/5bad360070216388768be9b66d9fb59241e86d66,ngiflib.c,FillGifBackGround,"static void FillGifBackGround(struct ngiflib_gif * g) {
long n = (long)g->width*g->height;
#ifndef NGIFLIB_INDEXED_ONLY
u32 bg_truecolor;
#endif 
if((g->frbuff.p8==NULL)||(g->palette==NULL)) return;
#ifndef NGIFLIB_INDEXED_ONLY
if(g->mode & NGIFLIB_MODE_INDEXED) {
#endif 
ngiflib_memset(g->frbuff.p8, g->backgroundindex, n);
#ifndef NGIFLIB_INDEXED_ONLY
} else {
u32 * p = g->frbuff.p32;
bg_truecolor = GifIndexToTrueColor(g->palette, g->backgroundindex);
while(n-->0) *p++ = bg_truecolor;
}
#endif 
}","static void FillGifBackGround(struct ngiflib_gif * VAR_0) {
long VAR_1 = (long)VAR_0->width*VAR_0->height;
#ifndef VAR_2
u32 VAR_3;
#endif 
if((VAR_0->frbuff.p8==NULL)||(VAR_0->palette==NULL)) return;
#ifndef VAR_2
if(VAR_0->mode & VAR_4) {
#endif
ngiflib_memset(g->frbuff.p8, g->backgroundindex, n);
#ifndef VAR_2
} else {
u32 * VAR_5 = VAR_0->frbuff.p32;
VAR_3 = GifIndexToTrueColor(VAR_0->palette, VAR_0->backgroundindex);
while(VAR_1-->0) *VAR_5++ = VAR_3;
}
#endif 
}",miniupnp/ngiflib/5bad360070216388768be9b66d9fb59241e86d66/ngiflib.c/vul/before/0.json,"static void FillGifBackGround(struct ngiflib_gif * g) {
	long n = (long)g->width*g->height;
#ifndef NGIFLIB_INDEXED_ONLY
	u32 bg_truecolor;
#endif /* NGIFLIB_INDEXED_ONLY */

	if((g->frbuff.p8==NULL)||(g->palette==NULL)) return;
#ifndef NGIFLIB_INDEXED_ONLY
	if(g->mode & NGIFLIB_MODE_INDEXED) {
#endif /* NGIFLIB_INDEXED_ONLY */
		ngiflib_memset(g->frbuff.p8, g->backgroundindex, n);
#ifndef NGIFLIB_INDEXED_ONLY
	} else {
		u32 * p = g->frbuff.p32;
		bg_truecolor = g->backgroundindex < g->ncolors ? GifIndexToTrueColor(g->palette, g->backgroundindex) : 0;
		while(n-->0) *p++ = bg_truecolor;
	}
#endif /* NGIFLIB_INDEXED_ONLY */
}","static void FillGifBackGround(struct ngiflib_gif * VAR_0) {
	long VAR_1 = (long)VAR_0->width*VAR_0->height;
#ifndef VAR_2
	u32 VAR_3;
#endif /* COMMENT_0 */

	if((VAR_0->frbuff.p8==NULL)||(VAR_0->palette==NULL)) return;
#ifndef VAR_2
	if(VAR_0->mode & VAR_4) {
#endif/* COMMENT_1 */
		ngiflib_memset(g->frbuff.p8, g->backgroundindex, n);
#ifndef VAR_2
	} else {
		u32 * VAR_5 = VAR_0->frbuff.p32;
		VAR_3 = VAR_0->backgroundindex < VAR_0->ncolors ? GifIndexToTrueColor(VAR_0->palette, VAR_0->backgroundindex) : 0;
		while(VAR_1-->0) *VAR_5++ = VAR_3;
	}
#endif /* COMMENT_0 */
}",miniupnp/ngiflib/5bad360070216388768be9b66d9fb59241e86d66/ngiflib.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,7 +12,7 @@
 #ifndef NGIFLIB_INDEXED_ONLY
 	} else {
 		u32 * p = g->frbuff.p32;
-		bg_truecolor = GifIndexToTrueColor(g->palette, g->backgroundindex);
+		bg_truecolor = g->backgroundindex < g->ncolors ? GifIndexToTrueColor(g->palette, g->backgroundindex) : 0;
 		while(n-->0) *p++ = bg_truecolor;
 	}
 #endif /* NGIFLIB_INDEXED_ONLY */","{'deleted_lines': ['\t\tbg_truecolor = GifIndexToTrueColor(g->palette, g->backgroundindex);'], 'added_lines': ['\t\tbg_truecolor = g->backgroundindex < g->ncolors ? GifIndexToTrueColor(g->palette, g->backgroundindex) : 0;']}",True,ngiflib 0.4 has a heap-based buffer over-read in GifIndexToTrueColor in ngiflib.c.,8.8,HIGH,2,valid,2019-10-14T19:42:06Z,3
CVE-2019-20798,['CWE-79'],AV:N/AC:M/Au:S/C:P/I:P/A:P,0,cherokee/webserver,"Use relative paths in the handler_server_info page

Issue #1227 describes a XSS vulnerability on the about page of cherokee-admin.
While the report by LogicalTrust only describes a JavaScript variant, a CSS method could also be probed via logo.gif.

The root cause is the request being verbatim copied in to the HTML template. The request could be escaped, but leads to the question: Why are we presenting a full path, instead of a
relative path to the page? This change removes the full path, and makes it relative. No URL is being printed in the template, and the XSS is avoided and therefore it should also be
faster.",39c6b73ff1b4749812eea940fa63e54e2ed860da,https://github.com/cherokee/webserver/commit/39c6b73ff1b4749812eea940fa63e54e2ed860da,cherokee/handler_server_info.c,server_info_build_html,"static ret_t
server_info_build_html (cherokee_handler_server_info_t *hdl, cherokee_buffer_t *buffer)
{
cherokee_buffer_t ver = CHEROKEE_BUF_INIT;
cherokee_buffer_add_str (buffer, PAGE_HEADER);
cherokee_buffer_add_str (buffer, AJAX_JS);
cherokee_version_add (&ver, HANDLER_SRV(hdl)->server_token);
cherokee_buffer_replace_string (buffer, ""{cherokee_name}"", 15, ver.buf, ver.len);
cherokee_buffer_mrproper (&ver);
cherokee_buffer_replace_string (buffer, ""{request}"", 9,
HANDLER_CONN(hdl)->request.buf,
HANDLER_CONN(hdl)->request.len);
cherokee_buffer_add_str (buffer, PAGE_FOOT);
return ret_ok;
}","static ret_t
server_info_build_html (cherokee_handler_server_info_t *VAR_0, cherokee_buffer_t *VAR_1)
{
cherokee_buffer_t VAR_2 = VAR_3;
cherokee_buffer_add_str (VAR_1, VAR_4);
cherokee_buffer_add_str (VAR_1, VAR_5);
cherokee_version_add (&VAR_2, HANDLER_SRV(VAR_0)->server_token);
cherokee_buffer_replace_string (VAR_1, ""{cherokee_name}"", 15, VAR_2.buf, VAR_2.len);
cherokee_buffer_mrproper (&VAR_2);
cherokee_buffer_replace_string (VAR_1, ""{request}"", 9,
HANDLER_CONN(VAR_0)->request.buf,
HANDLER_CONN(VAR_0)->request.len);
cherokee_buffer_add_str (VAR_1, VAR_6);
return VAR_7;
}",cherokee/webserver/39c6b73ff1b4749812eea940fa63e54e2ed860da/handler_server_info.c/vul/before/0.json,"static ret_t
server_info_build_html (cherokee_handler_server_info_t *hdl, cherokee_buffer_t *buffer)
{
	cherokee_buffer_t ver = CHEROKEE_BUF_INIT;

	cherokee_buffer_add_str (buffer, PAGE_HEADER);
	cherokee_buffer_add_str (buffer, AJAX_JS);

	cherokee_version_add (&ver, HANDLER_SRV(hdl)->server_token);
	cherokee_buffer_replace_string (buffer, ""{cherokee_name}"", 15, ver.buf, ver.len);
	cherokee_buffer_mrproper (&ver);

	cherokee_buffer_add_str (buffer, PAGE_FOOT);
	return ret_ok;
}","static ret_t
server_info_build_html (cherokee_handler_server_info_t *VAR_0, cherokee_buffer_t *VAR_1)
{
	cherokee_buffer_t VAR_2 = VAR_3;

	cherokee_buffer_add_str (VAR_1, VAR_4);
	cherokee_buffer_add_str (VAR_1, VAR_5);

	cherokee_version_add (&VAR_2, HANDLER_SRV(VAR_0)->server_token);
	cherokee_buffer_replace_string (VAR_1, ""{cherokee_name}"", 15, VAR_2.buf, VAR_2.len);
	cherokee_buffer_mrproper (&VAR_2);

	cherokee_buffer_add_str (VAR_1, VAR_6);
	return VAR_7;
}",cherokee/webserver/39c6b73ff1b4749812eea940fa63e54e2ed860da/handler_server_info.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,10 +10,6 @@
 	cherokee_buffer_replace_string (buffer, ""{cherokee_name}"", 15, ver.buf, ver.len);
 	cherokee_buffer_mrproper (&ver);
 
-	cherokee_buffer_replace_string (buffer, ""{request}"", 9,
-	                                HANDLER_CONN(hdl)->request.buf,
-	                                HANDLER_CONN(hdl)->request.len);
-
 	cherokee_buffer_add_str (buffer, PAGE_FOOT);
 	return ret_ok;
 }","{'deleted_lines': ['\tcherokee_buffer_replace_string (buffer, ""{request}"", 9,', '\t                                HANDLER_CONN(hdl)->request.buf,', '\t                                HANDLER_CONN(hdl)->request.len);', ''], 'added_lines': []}",True,An XSS issue was discovered in handler_server_info.c in Cherokee through 1.2.104. The requested URL is improperly displayed on the About page in the default configuration of the web server and its administrator panel. The XSS in the administrator panel can be used to reconfigure the server and execute arbitrary commands.,8.4,HIGH,2,valid,2019-10-27T22:46:33Z,3
CVE-2019-19580,['CWE-362'],AV:N/AC:M/Au:S/C:P/I:P/A:P,0,xen-project/xen,"x86/mm: relinquish_memory: Grab an extra type ref when setting PGT_partial

The PGT_partial bit in page->type_info holds both a type count and a
general ref count.  During domain tear-down, when free_page_type()
returns -ERESTART, relinquish_memory() correctly handles the general
ref count, but fails to grab an extra type count when setting
PGT_partial.  When this bit is eventually cleared, type_count underflows
and triggers the following BUG in page_alloc.c:free_domheap_pages():

    BUG_ON((pg[i].u.inuse.type_info & PGT_count_mask) != 0);

As far as we can tell, this page underflow cannot be exploited any any
other way: The page can't be used as a pagetable by the dying domain
because it's dying; it can't be used as a pagetable by any other
domain since it belongs to the dying domain; and ownership can't
transfer to any other domain without hitting the BUG_ON() in
free_domheap_pages().

(steal_page() won't work on a page in this state, since it requires
PGC_allocated to be set, and PGC_allocated will already have been
cleared.)

Fix this by grabbing an extra type ref if setting PGT_partial in
relinquish_memory.

This is part of XSA-310.

Signed-off-by: George Dunlap <george.dunlap@citrix.com>
Acked-by: Jan Beulich <jbeulich@suse.com>",66bdc16aeed8ddb2ae724adc5ea6bde0dea78c3d,https://github.com/xen-project/xen/commit/66bdc16aeed8ddb2ae724adc5ea6bde0dea78c3d,xen/arch/x86/domain.c,relinquish_memory,"static int relinquish_memory(
struct domain *d, struct page_list_head *list, unsigned long type)
{
struct page_info  *page;
unsigned long     x, y;
int               ret = 0;
spin_lock_recursive(&d->page_alloc_lock);
while ( (page = page_list_remove_head(list)) )
{
if ( unlikely(!get_page(page, d)) )
{
page_list_add_tail(page, &d->arch.relmem_list);
continue;
}
if ( test_and_clear_bit(_PGT_pinned, &page->u.inuse.type_info) )
ret = put_page_and_type_preemptible(page);
switch ( ret )
{
case 0:
break;
case -ERESTART:
case -EINTR:
if ( ret == -EINTR )
{
ASSERT(page->u.inuse.type_info & PGT_validated);
set_bit(_PGT_pinned, &page->u.inuse.type_info);
}
else
put_page(page);
ret = -ERESTART;
page_list_add(page, list);
put_page(page);
goto out;
default:
BUG();
}
put_page_alloc_ref(page);
y = page->u.inuse.type_info;
for ( ; ; )
{
x = y;
if ( likely((x & PGT_type_mask) != type) ||
likely(!(x & (PGT_validated|PGT_partial))) )
break;
y = cmpxchg(&page->u.inuse.type_info, x,
x & ~(PGT_validated|PGT_partial));
if ( likely(y == x) )
{
switch ( ret = free_page_type(page, x, 1) )
{
case 0:
break;
case -EINTR:
page_list_add(page, list);
page->u.inuse.type_info |= PGT_validated;
if ( x & PGT_partial )
put_page(page);
put_page(page);
ret = -ERESTART;
goto out;
case -ERESTART:
page_list_add(page, list);
page->u.inuse.type_info |= PGT_partial;
if ( x & PGT_partial )
put_page(page);
goto out;
default:
BUG();
}
if ( x & PGT_partial )
{
page->u.inuse.type_info--;
put_page(page);
}
break;
}
}
page_list_add_tail(page, &d->arch.relmem_list);
put_page(page);
if ( hypercall_preempt_check() )
{
ret = -ERESTART;
goto out;
}
}
page_list_move(list, &d->arch.relmem_list);
out:
spin_unlock_recursive(&d->page_alloc_lock);
return ret;
}","static int relinquish_memory(
struct domain *VAR_0, struct page_list_head *VAR_1, unsigned long VAR_2)
{
struct page_info  *VAR_3;
unsigned long     VAR_4, VAR_5;
int               VAR_6 = 0;
spin_lock_recursive(&VAR_0->page_alloc_lock);
while ( (VAR_3 = page_list_remove_head(VAR_1)) )
{
if ( unlikely(!get_page(VAR_3, VAR_0)) )
{
page_list_add_tail(VAR_3, &VAR_0->arch.relmem_list);
continue;
}
if ( test_and_clear_bit(VAR_7, &VAR_3->u.inuse.type_info) )
VAR_6 = put_page_and_type_preemptible(VAR_3);
switch ( VAR_6 )
{
case 0:
break;
case -VAR_8:
case -VAR_9:
if ( VAR_6 == -VAR_9 )
{
ASSERT(VAR_3->u.inuse.type_info & VAR_10);
set_bit(VAR_7, &VAR_3->u.inuse.type_info);
}
else
put_page(VAR_3);
VAR_6 = -VAR_8;
page_list_add(VAR_3, VAR_1);
put_page(VAR_3);
goto out;
default:
BUG();
}
put_page_alloc_ref(VAR_3);
VAR_5 = VAR_3->u.inuse.type_info;
for ( ; ; )
{
VAR_4 = VAR_5;
if ( likely((VAR_4 & VAR_11) != VAR_2) ||
likely(!(VAR_4 & (VAR_10|VAR_12))) )
break;
VAR_5 = cmpxchg(&VAR_3->u.inuse.type_info, VAR_4,
VAR_4 & ~(VAR_10|VAR_12));
if ( likely(VAR_5 == VAR_4) )
{
switch ( VAR_6 = free_page_type(VAR_3, VAR_4, 1) )
{
case 0:
break;
case -VAR_9:
page_list_add(VAR_3, VAR_1);
VAR_3->u.inuse.type_info |= VAR_10;
if ( VAR_4 & VAR_12 )
put_page(VAR_3);
put_page(VAR_3);
VAR_6 = -VAR_8;
goto out;
case -VAR_8:
page_list_add(VAR_3, VAR_1);
VAR_3->u.inuse.type_info |= VAR_12;
if ( VAR_4 & VAR_12 )
put_page(VAR_3);
goto out;
default:
BUG();
}
if ( VAR_4 & VAR_12 )
{
VAR_3->u.inuse.type_info--;
put_page(VAR_3);
}
break;
}
}
page_list_add_tail(VAR_3, &VAR_0->arch.relmem_list);
put_page(VAR_3);
if ( hypercall_preempt_check() )
{
VAR_6 = -VAR_8;
goto out;
}
}
page_list_move(VAR_1, &VAR_0->arch.relmem_list);
out:
spin_unlock_recursive(&VAR_0->page_alloc_lock);
return VAR_6;
}",xen-project/xen/66bdc16aeed8ddb2ae724adc5ea6bde0dea78c3d/domain.c/vul/before/0.json,"static int relinquish_memory(
    struct domain *d, struct page_list_head *list, unsigned long type)
{
    struct page_info  *page;
    unsigned long     x, y;
    int               ret = 0;

    /* Use a recursive lock, as we may enter 'free_domheap_page'. */
    spin_lock_recursive(&d->page_alloc_lock);

    while ( (page = page_list_remove_head(list)) )
    {
        /* Grab a reference to the page so it won't disappear from under us. */
        if ( unlikely(!get_page(page, d)) )
        {
            /* Couldn't get a reference -- someone is freeing this page. */
            page_list_add_tail(page, &d->arch.relmem_list);
            continue;
        }

        if ( test_and_clear_bit(_PGT_pinned, &page->u.inuse.type_info) )
            ret = put_page_and_type_preemptible(page);
        switch ( ret )
        {
        case 0:
            break;
        case -ERESTART:
        case -EINTR:
            /*
             * -EINTR means PGT_validated has been re-set; re-set
             * PGT_pinned again so that it gets picked up next time
             * around.
             *
             * -ERESTART, OTOH, means PGT_partial is set instead.  Put
             * it back on the list, but don't set PGT_pinned; the
             * section below will finish off de-validation.  But we do
             * need to drop the general ref associated with
             * PGT_pinned, since put_page_and_type_preemptible()
             * didn't do it.
             *
             * NB we can do an ASSERT for PGT_validated, since we
             * ""own"" the type ref; but theoretically, the PGT_partial
             * could be cleared by someone else.
             */
            if ( ret == -EINTR )
            {
                ASSERT(page->u.inuse.type_info & PGT_validated);
                set_bit(_PGT_pinned, &page->u.inuse.type_info);
            }
            else
                put_page(page);

            ret = -ERESTART;

            /* Put the page back on the list and drop the ref we grabbed above */
            page_list_add(page, list);
            put_page(page);
            goto out;
        default:
            BUG();
        }

        put_page_alloc_ref(page);

        /*
         * Forcibly invalidate top-most, still valid page tables at this point
         * to break circular 'linear page table' references as well as clean up
         * partially validated pages. This is okay because MMU structures are
         * not shared across domains and this domain is now dead. Thus top-most
         * valid tables are not in use so a non-zero count means circular
         * reference or partially validated.
         */
        y = page->u.inuse.type_info;
        for ( ; ; )
        {
            x = y;
            if ( likely((x & PGT_type_mask) != type) ||
                 likely(!(x & (PGT_validated|PGT_partial))) )
                break;

            y = cmpxchg(&page->u.inuse.type_info, x,
                        x & ~(PGT_validated|PGT_partial));
            if ( likely(y == x) )
            {
                /* No need for atomic update of type_info here: noone else updates it. */
                switch ( ret = free_page_type(page, x, 1) )
                {
                case 0:
                    break;
                case -EINTR:
                    page_list_add(page, list);
                    page->u.inuse.type_info |= PGT_validated;
                    if ( x & PGT_partial )
                        put_page(page);
                    put_page(page);
                    ret = -ERESTART;
                    goto out;
                case -ERESTART:
                    page_list_add(page, list);
                    /*
                     * PGT_partial holds a type ref and a general ref.
                     * If we came in with PGT_partial set, then we 1)
                     * don't need to grab an extra type count, and 2)
                     * do need to drop the extra page ref we grabbed
                     * at the top of the loop.  If we didn't come in
                     * with PGT_partial set, we 1) do need to drab an
                     * extra type count, but 2) can transfer the page
                     * ref we grabbed above to it.
                     *
                     * Note that we must increment type_info before
                     * setting PGT_partial.  Theoretically it should
                     * be safe to drop the page ref before setting
                     * PGT_partial, but do it afterwards just to be
                     * extra safe.
                     */
                    if ( !(x & PGT_partial) )
                        page->u.inuse.type_info++;
                    smp_wmb();
                    page->u.inuse.type_info |= PGT_partial;
                    if ( x & PGT_partial )
                        put_page(page);
                    goto out;
                default:
                    BUG();
                }
                if ( x & PGT_partial )
                {
                    page->u.inuse.type_info--;
                    put_page(page);
                }
                break;
            }
        }

        /* Put the page on the list and /then/ potentially free it. */
        page_list_add_tail(page, &d->arch.relmem_list);
        put_page(page);

        if ( hypercall_preempt_check() )
        {
            ret = -ERESTART;
            goto out;
        }
    }

    /* list is empty at this point. */
    page_list_move(list, &d->arch.relmem_list);

 out:
    spin_unlock_recursive(&d->page_alloc_lock);
    return ret;
}","static int relinquish_memory(
    struct domain *VAR_0, struct page_list_head *VAR_1, unsigned long VAR_2)
{
    struct page_info  *VAR_3;
    unsigned long     VAR_4, VAR_5;
    int               VAR_6 = 0;

    /* COMMENT_0 */
    spin_lock_recursive(&VAR_0->page_alloc_lock);

    while ( (VAR_3 = page_list_remove_head(VAR_1)) )
    {
        /* COMMENT_1 */
        if ( unlikely(!get_page(VAR_3, VAR_0)) )
        {
            /* COMMENT_2 */
            page_list_add_tail(VAR_3, &VAR_0->arch.relmem_list);
            continue;
        }

        if ( test_and_clear_bit(VAR_7, &VAR_3->u.inuse.type_info) )
            VAR_6 = put_page_and_type_preemptible(VAR_3);
        switch ( VAR_6 )
        {
        case 0:
            break;
        case -VAR_8:
        case -VAR_9:
            /* COMMENT_3 */
                                                                 
                                                                   
                      
              
                                                                      
                                                                 
                                                                      
                                                           
                                                                
                            
              
                                                                 
                                                                     
                                                
               
            if ( VAR_6 == -VAR_9 )
            {
                ASSERT(VAR_3->u.inuse.type_info & VAR_10);
                set_bit(VAR_7, &VAR_3->u.inuse.type_info);
            }
            else
                put_page(VAR_3);

            VAR_6 = -VAR_8;

            /* COMMENT_18 */
            page_list_add(VAR_3, VAR_1);
            put_page(VAR_3);
            goto out;
        default:
            BUG();
        }

        put_page_alloc_ref(VAR_3);

        /* COMMENT_19 */
                                                                              
                                                                               
                                                                             
                                                                               
                                                                         
                                            
           
        VAR_5 = VAR_3->u.inuse.type_info;
        for ( ; ; )
        {
            VAR_4 = VAR_5;
            if ( likely((VAR_4 & VAR_11) != VAR_2) ||
                 likely(!(VAR_4 & (VAR_10|VAR_12))) )
                break;

            VAR_5 = cmpxchg(&VAR_3->u.inuse.type_info, VAR_4,
                        VAR_4 & ~(VAR_10|VAR_12));
            if ( likely(VAR_5 == VAR_4) )
            {
                /* COMMENT_27 */
                switch ( VAR_6 = free_page_type(VAR_3, VAR_4, 1) )
                {
                case 0:
                    break;
                case -VAR_9:
                    page_list_add(VAR_3, VAR_1);
                    VAR_3->u.inuse.type_info |= VAR_10;
                    if ( VAR_4 & VAR_12 )
                        put_page(VAR_3);
                    put_page(VAR_3);
                    VAR_6 = -VAR_8;
                    goto out;
                case -VAR_8:
                    page_list_add(VAR_3, VAR_1);
                    /* COMMENT_28 */
                                                                      
                                                                     
                                                                     
                                                                    
                                                                    
                                                                     
                                                                     
                                                  
                      
                                                                   
                                                                    
                                                                  
                                                                   
                                  
                       
                    if ( !(VAR_4 & VAR_12) )
                        VAR_3->u.inuse.type_info++;
                    smp_wmb();
                    VAR_3->u.inuse.type_info |= VAR_12;
                    if ( VAR_4 & VAR_12 )
                        put_page(VAR_3);
                    goto out;
                default:
                    BUG();
                }
                if ( VAR_4 & VAR_12 )
                {
                    VAR_3->u.inuse.type_info--;
                    put_page(VAR_3);
                }
                break;
            }
        }

        /* COMMENT_44 */
        page_list_add_tail(VAR_3, &VAR_0->arch.relmem_list);
        put_page(VAR_3);

        if ( hypercall_preempt_check() )
        {
            VAR_6 = -VAR_8;
            goto out;
        }
    }

    /* COMMENT_45 */
    page_list_move(VAR_1, &VAR_0->arch.relmem_list);

 out:
    spin_unlock_recursive(&VAR_0->page_alloc_lock);
    return VAR_6;
}",xen-project/xen/66bdc16aeed8ddb2ae724adc5ea6bde0dea78c3d/domain.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -97,6 +97,25 @@
                     goto out;
                 case -ERESTART:
                     page_list_add(page, list);
+                    /*
+                     * PGT_partial holds a type ref and a general ref.
+                     * If we came in with PGT_partial set, then we 1)
+                     * don't need to grab an extra type count, and 2)
+                     * do need to drop the extra page ref we grabbed
+                     * at the top of the loop.  If we didn't come in
+                     * with PGT_partial set, we 1) do need to drab an
+                     * extra type count, but 2) can transfer the page
+                     * ref we grabbed above to it.
+                     *
+                     * Note that we must increment type_info before
+                     * setting PGT_partial.  Theoretically it should
+                     * be safe to drop the page ref before setting
+                     * PGT_partial, but do it afterwards just to be
+                     * extra safe.
+                     */
+                    if ( !(x & PGT_partial) )
+                        page->u.inuse.type_info++;
+                    smp_wmb();
                     page->u.inuse.type_info |= PGT_partial;
                     if ( x & PGT_partial )
                         put_page(page);","{'deleted_lines': [], 'added_lines': ['                    /*', '                     * PGT_partial holds a type ref and a general ref.', '                     * If we came in with PGT_partial set, then we 1)', ""                     * don't need to grab an extra type count, and 2)"", '                     * do need to drop the extra page ref we grabbed', ""                     * at the top of the loop.  If we didn't come in"", '                     * with PGT_partial set, we 1) do need to drab an', '                     * extra type count, but 2) can transfer the page', '                     * ref we grabbed above to it.', '                     *', '                     * Note that we must increment type_info before', '                     * setting PGT_partial.  Theoretically it should', '                     * be safe to drop the page ref before setting', '                     * PGT_partial, but do it afterwards just to be', '                     * extra safe.', '                     */', '                    if ( !(x & PGT_partial) )', '                        page->u.inuse.type_info++;', '                    smp_wmb();']}",True,"An issue was discovered in Xen through 4.12.x allowing x86 PV guest OS users to gain host OS privileges by leveraging race conditions in pagetable promotion and demotion operations, because of an incomplete fix for CVE-2019-18421. XSA-299 addressed several critical issues in restartable PV type change operations. Despite extensive testing and auditing, some corner cases were missed. A malicious PV guest administrator may be able to escalate their privilege to that of the host. All security-supported versions of Xen are vulnerable. Only x86 systems are affected. Arm systems are not affected. Only x86 PV guests can leverage the vulnerability. x86 HVM and PVH guests cannot leverage the vulnerability. Note that these attacks require very precise timing, which may be difficult to exploit in practice.",6.6,MEDIUM,1,valid,2019-10-28T14:33:51Z,3
CVE-2019-19578,['CWE-682'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,xen-project/xen,"x86/mm: Don't reset linear_pt_count on partial validation

""Linear pagetables"" is a technique which involves either pointing a
pagetable at itself, or to another pagetable the same or higher level.
Xen has limited support for linear pagetables: A page may either point
to itself, or point to another page of the same level (i.e., L2 to L2,
L3 to L3, and so on).

XSA-240 introduced an additional restriction that limited the ""depth""
of such chains by allowing pages to either *point to* other pages of
the same level, or *be pointed to* by other pages of the same level,
but not both.  To implement this, we keep track of the number of
outstanding times a page points to or is pointed to another page
table, to prevent both from happening at the same time.

Unfortunately, the original commit introducing this reset this count
when resuming validation of a partially-validated pagetable, dropping
some ""linear_pt_entry"" counts.

On debug builds on systems where guests used this feature, this might
lead to crashes that look like this:

    Assertion 'oc > 0' failed at mm.c:874

Worse, if an attacker could engineer such a situation to occur, they
might be able to make loops or other abitrary chains of linear
pagetables, leading to the denial-of-service situation outlined in
XSA-240.

This is XSA-309.

Reported-by: Manuel Bouyer <bouyer@antioche.eu.org>
Signed-off-by: George Dunlap <george.dunlap@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",7473efd12fb7a6548f5303f1f4c5cb521543a813,https://github.com/xen-project/xen/commit/7473efd12fb7a6548f5303f1f4c5cb521543a813,xen/arch/x86/mm.c,_get_page_type,"static int _get_page_type(struct page_info *page, unsigned long type,
bool preemptible)
{
unsigned long nx, x, y = page->u.inuse.type_info;
int rc = 0;
ASSERT(!(type & ~(PGT_type_mask | PGT_pae_xen_l2)));
ASSERT(!in_irq());
for ( ; ; )
{
x  = y;
nx = x + 1;
if ( unlikely((nx & PGT_count_mask) == 0) )
{
gdprintk(XENLOG_WARNING,
""Type count overflow on mfn %""PRI_mfn""\n"",
mfn_x(page_to_mfn(page)));
return -EINVAL;
}
else if ( unlikely((x & PGT_count_mask) == 0) )
{
struct domain *d = page_get_owner(page);
if ( d && shadow_mode_enabled(d) )
shadow_prepare_page_type_change(d, page, type);
ASSERT(!(x & PGT_pae_xen_l2));
if ( (x & PGT_type_mask) != type )
{
cpumask_t *mask = this_cpu(scratch_cpumask);
BUG_ON(in_irq());
cpumask_copy(mask, d->dirty_cpumask);
tlbflush_filter(mask, page->tlbflush_timestamp);
if ( unlikely(!cpumask_empty(mask)) &&
(!shadow_mode_enabled(page_get_owner(page)) ||
((nx & PGT_type_mask) == PGT_writable_page)) )
{
perfc_incr(need_flush_tlb_flush);
flush_tlb_mask(mask);
}
nx &= ~(PGT_type_mask | PGT_validated);
nx |= type;
if ( type == PGT_writable_page || type == PGT_shared_page )
nx |= PGT_validated;
}
}
else if ( unlikely((x & (PGT_type_mask|PGT_pae_xen_l2)) != type) )
{
if ( ((x & PGT_type_mask) == PGT_l2_page_table) &&
(type == PGT_l1_page_table) )
return -EINVAL;
if ( ((x & PGT_type_mask) == PGT_l3_page_table) &&
(type == PGT_l2_page_table) )
return -EINVAL;
if ( ((x & PGT_type_mask) == PGT_l4_page_table) &&
(type == PGT_l3_page_table) )
return -EINVAL;
gdprintk(XENLOG_WARNING,
""Bad type (saw %"" PRtype_info "" != exp %"" PRtype_info "") ""
""for mfn %"" PRI_mfn "" (pfn %"" PRI_pfn "")\n"",
x, type, mfn_x(page_to_mfn(page)),
get_gpfn_from_mfn(mfn_x(page_to_mfn(page))));
return -EINVAL;
}
else if ( unlikely(!(x & PGT_validated)) )
{
if ( !(x & PGT_partial) )
{
do {
if ( preemptible && hypercall_preempt_check() )
return -EINTR;
cpu_relax();
} while ( (y = page->u.inuse.type_info) == x );
continue;
}
ASSERT((x & PGT_count_mask) == 1);
nx = x & ~PGT_partial;
}
if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) )
break;
if ( preemptible && hypercall_preempt_check() )
return -EINTR;
}
if ( unlikely((x & PGT_type_mask) != type) )
{
struct domain *d = page_get_owner(page);
if ( d && is_pv_domain(d) && unlikely(need_iommu_pt_sync(d)) )
{
mfn_t mfn = page_to_mfn(page);
if ( (x & PGT_type_mask) == PGT_writable_page )
rc = iommu_legacy_unmap(d, _dfn(mfn_x(mfn)), PAGE_ORDER_4K);
else if ( type == PGT_writable_page )
rc = iommu_legacy_map(d, _dfn(mfn_x(mfn)), mfn, PAGE_ORDER_4K,
IOMMUF_readable | IOMMUF_writable);
if ( unlikely(rc) )
{
_put_page_type(page, 0, NULL);
goto out;
}
}
}
if ( unlikely(!(nx & PGT_validated)) )
{
if ( !(x & PGT_partial) )
{
page->nr_validated_ptes = 0;
page->partial_flags = 0;
}
page->linear_pt_count = 0;
rc = alloc_page_type(page, type, preemptible);
}
out:
if ( (x & PGT_partial) && !(nx & PGT_partial) )
put_page(page);
return rc;
}","static int _get_page_type(struct page_info *VAR_0, unsigned long VAR_1,
bool VAR_2)
{
unsigned long VAR_3, VAR_4, VAR_5 = VAR_0->u.inuse.type_info;
int VAR_6 = 0;
ASSERT(!(VAR_1 & ~(VAR_7 | VAR_8)));
ASSERT(!in_irq());
for ( ; ; )
{
VAR_4  = VAR_5;
VAR_3 = VAR_4 + 1;
if ( unlikely((VAR_3 & VAR_9) == 0) )
{
gdprintk(VAR_10,
""Type count overflow on mfn %""VAR_11""\n"",
mfn_x(page_to_mfn(VAR_0)));
return -VAR_12;
}
else if ( unlikely((VAR_4 & VAR_9) == 0) )
{
struct domain *VAR_13 = page_get_owner(VAR_0);
if ( VAR_13 && shadow_mode_enabled(VAR_13) )
shadow_prepare_page_type_change(VAR_13, VAR_0, VAR_1);
ASSERT(!(VAR_4 & VAR_8));
if ( (VAR_4 & VAR_7) != VAR_1 )
{
cpumask_t *VAR_14 = this_cpu(VAR_15);
BUG_ON(in_irq());
cpumask_copy(VAR_14, VAR_13->dirty_cpumask);
tlbflush_filter(VAR_14, VAR_0->tlbflush_timestamp);
if ( unlikely(!cpumask_empty(VAR_14)) &&
(!shadow_mode_enabled(page_get_owner(VAR_0)) ||
((VAR_3 & VAR_7) == VAR_16)) )
{
perfc_incr(VAR_17);
flush_tlb_mask(VAR_14);
}
VAR_3 &= ~(VAR_7 | VAR_18);
VAR_3 |= VAR_1;
if ( VAR_1 == VAR_16 || VAR_1 == VAR_19 )
VAR_3 |= VAR_18;
}
}
else if ( unlikely((VAR_4 & (VAR_7|VAR_8)) != VAR_1) )
{
if ( ((VAR_4 & VAR_7) == VAR_20) &&
(VAR_1 == VAR_21) )
return -VAR_12;
if ( ((VAR_4 & VAR_7) == VAR_22) &&
(VAR_1 == VAR_20) )
return -VAR_12;
if ( ((VAR_4 & VAR_7) == VAR_23) &&
(VAR_1 == VAR_22) )
return -VAR_12;
gdprintk(VAR_10,
""Bad type (saw %"" VAR_24 "" != exp %"" VAR_24 "") ""
""for mfn %"" VAR_11 "" (pfn %"" VAR_25 "")\n"",
VAR_4, VAR_1, mfn_x(page_to_mfn(VAR_0)),
get_gpfn_from_mfn(mfn_x(page_to_mfn(VAR_0))));
return -VAR_12;
}
else if ( unlikely(!(VAR_4 & VAR_18)) )
{
if ( !(VAR_4 & VAR_26) )
{
do {
if ( VAR_2 && hypercall_preempt_check() )
return -VAR_27;
cpu_relax();
} while ( (VAR_5 = VAR_0->u.inuse.type_info) == VAR_4 );
continue;
}
ASSERT((VAR_4 & VAR_9) == 1);
VAR_3 = VAR_4 & ~VAR_26;
}
if ( likely((VAR_5 = cmpxchg(&VAR_0->u.inuse.type_info, VAR_4, VAR_3)) == VAR_4) )
break;
if ( VAR_2 && hypercall_preempt_check() )
return -VAR_27;
}
if ( unlikely((VAR_4 & VAR_7) != VAR_1) )
{
struct domain *VAR_13 = page_get_owner(VAR_0);
if ( VAR_13 && is_pv_domain(VAR_13) && unlikely(need_iommu_pt_sync(VAR_13)) )
{
mfn_t VAR_28 = page_to_mfn(VAR_0);
if ( (VAR_4 & VAR_7) == VAR_16 )
VAR_6 = iommu_legacy_unmap(VAR_13, _dfn(mfn_x(VAR_28)), VAR_29);
else if ( VAR_1 == VAR_16 )
VAR_6 = iommu_legacy_map(VAR_13, _dfn(mfn_x(VAR_28)), VAR_28, VAR_29,
VAR_30 | VAR_31);
if ( unlikely(VAR_6) )
{
_put_page_type(VAR_0, 0, NULL);
goto out;
}
}
}
if ( unlikely(!(VAR_3 & VAR_18)) )
{
if ( !(VAR_4 & VAR_26) )
{
VAR_0->nr_validated_ptes = 0;
VAR_0->partial_flags = 0;
}
VAR_0->linear_pt_count = 0;
VAR_6 = alloc_page_type(VAR_0, VAR_1, VAR_2);
}
out:
if ( (VAR_4 & VAR_26) && !(VAR_3 & VAR_26) )
put_page(VAR_0);
return VAR_6;
}",xen-project/xen/7473efd12fb7a6548f5303f1f4c5cb521543a813/mm.c/vul/before/0.json,"static int _get_page_type(struct page_info *page, unsigned long type,
                          bool preemptible)
{
    unsigned long nx, x, y = page->u.inuse.type_info;
    int rc = 0;

    ASSERT(!(type & ~(PGT_type_mask | PGT_pae_xen_l2)));
    ASSERT(!in_irq());

    for ( ; ; )
    {
        x  = y;
        nx = x + 1;
        if ( unlikely((nx & PGT_count_mask) == 0) )
        {
            gdprintk(XENLOG_WARNING,
                     ""Type count overflow on mfn %""PRI_mfn""\n"",
                     mfn_x(page_to_mfn(page)));
            return -EINVAL;
        }
        else if ( unlikely((x & PGT_count_mask) == 0) )
        {
            struct domain *d = page_get_owner(page);

            if ( d && shadow_mode_enabled(d) )
               shadow_prepare_page_type_change(d, page, type);

            ASSERT(!(x & PGT_pae_xen_l2));
            if ( (x & PGT_type_mask) != type )
            {
                /*
                 * On type change we check to flush stale TLB entries. It is
                 * vital that no other CPUs are left with mappings of a frame
                 * which is about to become writeable to the guest.
                 */
                cpumask_t *mask = this_cpu(scratch_cpumask);

                BUG_ON(in_irq());
                cpumask_copy(mask, d->dirty_cpumask);

                /* Don't flush if the timestamp is old enough */
                tlbflush_filter(mask, page->tlbflush_timestamp);

                if ( unlikely(!cpumask_empty(mask)) &&
                     /* Shadow mode: track only writable pages. */
                     (!shadow_mode_enabled(page_get_owner(page)) ||
                      ((nx & PGT_type_mask) == PGT_writable_page)) )
                {
                    perfc_incr(need_flush_tlb_flush);
                    flush_tlb_mask(mask);
                }

                /* We lose existing type and validity. */
                nx &= ~(PGT_type_mask | PGT_validated);
                nx |= type;

                /*
                 * No special validation needed for writable pages.
                 * Page tables and GDT/LDT need to be scanned for validity.
                 */
                if ( type == PGT_writable_page || type == PGT_shared_page )
                    nx |= PGT_validated;
            }
        }
        else if ( unlikely((x & (PGT_type_mask|PGT_pae_xen_l2)) != type) )
        {
            /* Don't log failure if it could be a recursive-mapping attempt. */
            if ( ((x & PGT_type_mask) == PGT_l2_page_table) &&
                 (type == PGT_l1_page_table) )
                return -EINVAL;
            if ( ((x & PGT_type_mask) == PGT_l3_page_table) &&
                 (type == PGT_l2_page_table) )
                return -EINVAL;
            if ( ((x & PGT_type_mask) == PGT_l4_page_table) &&
                 (type == PGT_l3_page_table) )
                return -EINVAL;
            gdprintk(XENLOG_WARNING,
                     ""Bad type (saw %"" PRtype_info "" != exp %"" PRtype_info "") ""
                     ""for mfn %"" PRI_mfn "" (pfn %"" PRI_pfn "")\n"",
                     x, type, mfn_x(page_to_mfn(page)),
                     get_gpfn_from_mfn(mfn_x(page_to_mfn(page))));
            return -EINVAL;
        }
        else if ( unlikely(!(x & PGT_validated)) )
        {
            if ( !(x & PGT_partial) )
            {
                /* Someone else is updating validation of this page. Wait... */
                do {
                    if ( preemptible && hypercall_preempt_check() )
                        return -EINTR;
                    cpu_relax();
                } while ( (y = page->u.inuse.type_info) == x );
                continue;
            }
            /* Type ref count was left at 1 when PGT_partial got set. */
            ASSERT((x & PGT_count_mask) == 1);
            nx = x & ~PGT_partial;
        }

        if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) )
            break;

        if ( preemptible && hypercall_preempt_check() )
            return -EINTR;
    }

    if ( unlikely((x & PGT_type_mask) != type) )
    {
        /* Special pages should not be accessible from devices. */
        struct domain *d = page_get_owner(page);
        if ( d && is_pv_domain(d) && unlikely(need_iommu_pt_sync(d)) )
        {
            mfn_t mfn = page_to_mfn(page);

            if ( (x & PGT_type_mask) == PGT_writable_page )
                rc = iommu_legacy_unmap(d, _dfn(mfn_x(mfn)), PAGE_ORDER_4K);
            else if ( type == PGT_writable_page )
                rc = iommu_legacy_map(d, _dfn(mfn_x(mfn)), mfn, PAGE_ORDER_4K,
                                      IOMMUF_readable | IOMMUF_writable);

            if ( unlikely(rc) )
            {
                _put_page_type(page, 0, NULL);
                goto out;
            }
        }
    }

    if ( unlikely(!(nx & PGT_validated)) )
    {
        if ( !(x & PGT_partial) )
        {
            page->nr_validated_ptes = 0;
            page->partial_flags = 0;
            page->linear_pt_count = 0;
        }
        rc = alloc_page_type(page, type, preemptible);
    }

 out:
    if ( (x & PGT_partial) && !(nx & PGT_partial) )
        put_page(page);

    return rc;
}","static int _get_page_type(struct page_info *VAR_0, unsigned long VAR_1,
                          bool VAR_2)
{
    unsigned long VAR_3, VAR_4, VAR_5 = VAR_0->u.inuse.type_info;
    int VAR_6 = 0;

    ASSERT(!(VAR_1 & ~(VAR_7 | VAR_8)));
    ASSERT(!in_irq());

    for ( ; ; )
    {
        VAR_4  = VAR_5;
        VAR_3 = VAR_4 + 1;
        if ( unlikely((VAR_3 & VAR_9) == 0) )
        {
            gdprintk(VAR_10,
                     ""Type count overflow on mfn %""VAR_11""\n"",
                     mfn_x(page_to_mfn(VAR_0)));
            return -VAR_12;
        }
        else if ( unlikely((VAR_4 & VAR_9) == 0) )
        {
            struct domain *VAR_13 = page_get_owner(VAR_0);

            if ( VAR_13 && shadow_mode_enabled(VAR_13) )
               shadow_prepare_page_type_change(VAR_13, VAR_0, VAR_1);

            ASSERT(!(VAR_4 & VAR_8));
            if ( (VAR_4 & VAR_7) != VAR_1 )
            {
                /* COMMENT_0 */
                                                                            
                                                                             
                                                                   
                   
                cpumask_t *VAR_14 = this_cpu(VAR_15);

                BUG_ON(in_irq());
                cpumask_copy(VAR_14, VAR_13->dirty_cpumask);

                /* COMMENT_5 */
                tlbflush_filter(VAR_14, VAR_0->tlbflush_timestamp);

                if ( unlikely(!cpumask_empty(VAR_14)) &&
                     /* COMMENT_6 */
                     (!shadow_mode_enabled(page_get_owner(VAR_0)) ||
                      ((VAR_3 & VAR_7) == VAR_16)) )
                {
                    perfc_incr(VAR_17);
                    flush_tlb_mask(VAR_14);
                }

                /* COMMENT_7 */
                VAR_3 &= ~(VAR_7 | VAR_18);
                VAR_3 |= VAR_1;

                /* COMMENT_8 */
                                                                   
                                                                           
                   
                if ( VAR_1 == VAR_16 || VAR_1 == VAR_19 )
                    VAR_3 |= VAR_18;
            }
        }
        else if ( unlikely((VAR_4 & (VAR_7|VAR_8)) != VAR_1) )
        {
            /* COMMENT_12 */
            if ( ((VAR_4 & VAR_7) == VAR_20) &&
                 (VAR_1 == VAR_21) )
                return -VAR_12;
            if ( ((VAR_4 & VAR_7) == VAR_22) &&
                 (VAR_1 == VAR_20) )
                return -VAR_12;
            if ( ((VAR_4 & VAR_7) == VAR_23) &&
                 (VAR_1 == VAR_22) )
                return -VAR_12;
            gdprintk(VAR_10,
                     ""Bad type (saw %"" VAR_24 "" != exp %"" VAR_24 "") ""
                     ""for mfn %"" VAR_11 "" (pfn %"" VAR_25 "")\n"",
                     VAR_4, VAR_1, mfn_x(page_to_mfn(VAR_0)),
                     get_gpfn_from_mfn(mfn_x(page_to_mfn(VAR_0))));
            return -VAR_12;
        }
        else if ( unlikely(!(VAR_4 & VAR_18)) )
        {
            if ( !(VAR_4 & VAR_26) )
            {
                /* COMMENT_13 */
                do {
                    if ( VAR_2 && hypercall_preempt_check() )
                        return -VAR_27;
                    cpu_relax();
                } while ( (VAR_5 = VAR_0->u.inuse.type_info) == VAR_4 );
                continue;
            }
            /* COMMENT_14 */
            ASSERT((VAR_4 & VAR_9) == 1);
            VAR_3 = VAR_4 & ~VAR_26;
        }

        if ( likely((VAR_5 = cmpxchg(&VAR_0->u.inuse.type_info, VAR_4, VAR_3)) == VAR_4) )
            break;

        if ( VAR_2 && hypercall_preempt_check() )
            return -VAR_27;
    }

    if ( unlikely((VAR_4 & VAR_7) != VAR_1) )
    {
        /* COMMENT_15 */
        struct domain *VAR_13 = page_get_owner(VAR_0);
        if ( VAR_13 && is_pv_domain(VAR_13) && unlikely(need_iommu_pt_sync(VAR_13)) )
        {
            mfn_t VAR_28 = page_to_mfn(VAR_0);

            if ( (VAR_4 & VAR_7) == VAR_16 )
                VAR_6 = iommu_legacy_unmap(VAR_13, _dfn(mfn_x(VAR_28)), VAR_29);
            else if ( VAR_1 == VAR_16 )
                VAR_6 = iommu_legacy_map(VAR_13, _dfn(mfn_x(VAR_28)), VAR_28, VAR_29,
                                      VAR_30 | VAR_31);

            if ( unlikely(VAR_6) )
            {
                _put_page_type(VAR_0, 0, NULL);
                goto out;
            }
        }
    }

    if ( unlikely(!(VAR_3 & VAR_18)) )
    {
        if ( !(VAR_4 & VAR_26) )
        {
            VAR_0->nr_validated_ptes = 0;
            VAR_0->partial_flags = 0;
            VAR_0->linear_pt_count = 0;
        }
        VAR_6 = alloc_page_type(VAR_0, VAR_1, VAR_2);
    }

 out:
    if ( (VAR_4 & VAR_26) && !(VAR_3 & VAR_26) )
        put_page(VAR_0);

    return VAR_6;
}",xen-project/xen/7473efd12fb7a6548f5303f1f4c5cb521543a813/mm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -133,8 +133,8 @@
         {
             page->nr_validated_ptes = 0;
             page->partial_flags = 0;
+            page->linear_pt_count = 0;
         }
-        page->linear_pt_count = 0;
         rc = alloc_page_type(page, type, preemptible);
     }
 ","{'deleted_lines': ['        page->linear_pt_count = 0;'], 'added_lines': ['            page->linear_pt_count = 0;']}",True,"An issue was discovered in Xen through 4.12.x allowing x86 PV guest OS users to cause a denial of service via degenerate chains of linear pagetables, because of an incorrect fix for CVE-2017-15595. ""Linear pagetables"" is a technique which involves either pointing a pagetable at itself, or to another pagetable of the same or higher level. Xen has limited support for linear pagetables: A page may either point to itself, or point to another pagetable of the same level (i.e., L2 to L2, L3 to L3, and so on). XSA-240 introduced an additional restriction that limited the ""depth"" of such chains by allowing pages to either *point to* other pages of the same level, or *be pointed to* by other pages of the same level, but not both. To implement this, we keep track of the number of outstanding times a page points to or is pointed to another page table, to prevent both from happening at the same time. Unfortunately, the original commit introducing this reset this count when resuming validation of a partially-validated pagetable, incorrectly dropping some ""linear_pt_entry"" counts. If an attacker could engineer such a situation to occur, they might be able to make loops or other arbitrary chains of linear pagetables, as described in XSA-240. A malicious or buggy PV guest may cause the hypervisor to crash, resulting in Denial of Service (DoS) affecting the entire host. Privilege escalation and information leaks cannot be excluded. All versions of Xen are vulnerable. Only x86 systems are affected. Arm systems are not affected. Only x86 PV guests can leverage the vulnerability. x86 HVM and PVH guests cannot leverage the vulnerability. Only systems which have enabled linear pagetables are vulnerable. Systems which have disabled linear pagetables, either by selecting CONFIG_PV_LINEAR_PT=n when building the hypervisor, or adding pv-linear-pt=false on the command-line, are not vulnerable.",8.8,HIGH,2,valid,2019-10-30T17:05:28Z,3
CVE-2019-19580,['CWE-362'],AV:N/AC:M/Au:S/C:P/I:P/A:P,0,xen-project/xen,"x86/mm: alloc/free_lN_table: Retain partial_flags on -EINTR

When validating or de-validating pages (in alloc_lN_table and
free_lN_table respectively), the `partial_flags` local variable is
used to keep track of whether the ""current"" PTE started the entire
operation in a ""may be partial"" state.

One of the patches in XSA-299 addressed the fact that it is possible
for a previously-partially-validated entry to subsequently be found to
have invalid entries (indicated by returning -EINVAL); in which case
page->partial_flags needs to be set to indicate that the current PTE
may have the partial bit set (and thus _put_page_type() should be
called with PTF_partial_set).

Unfortunately, the patches in XSA-299 assumed that once
put_page_from_lNe() returned -ERESTART on a page, it was not possible
for it to return -EINTR.  This turns out to be true for
alloc_lN_table() and free_lN_table, but not for _get_page_type() and
_put_page_type(): both can return -EINTR when called on pages with
PGT_partial set.  In these cases, the pages PGT_partial will still be
set; failing to set partial_flags appropriately may allow an attacker
to do a privilege escalation similar to those described in XSA-299.

Fix this by always copying the local partial_flags variable into
page->partial_flags when exiting early.

NB that on the ""get"" side, no adjustment to nr_validated_entries is
needed: whether pte[i] is partially validated or entirely
un-validated, we want nr_validated_entries = i.  On the ""put"" side,
however, we need to adjust nr_validated_entries appropriately: if
pte[i] is entirely validated, we want nr_validated_entries = i + 1; if
pte[i] is partially validated, we want nr_validated_entries = i.

This is part of XSA-310.

Signed-off-by: George Dunlap <george.dunlap@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",4e70f4476c0c543559f971faecdd5f1300cddb0a,https://github.com/xen-project/xen/commit/4e70f4476c0c543559f971faecdd5f1300cddb0a,xen/arch/x86/mm.c,alloc_l3_table,"static int alloc_l3_table(struct page_info *page)
{
struct domain *d = page_get_owner(page);
unsigned long  pfn = mfn_x(page_to_mfn(page));
l3_pgentry_t  *pl3e;
unsigned int   i;
int            rc = 0;
unsigned int   partial_flags = page->partial_flags;
l3_pgentry_t   l3e = l3e_empty();
pl3e = map_domain_page(_mfn(pfn));
if ( is_pv_32bit_domain(d) )
memset(pl3e + 4, 0, (L3_PAGETABLE_ENTRIES - 4) * sizeof(*pl3e));
for ( i = page->nr_validated_ptes; i < L3_PAGETABLE_ENTRIES;
i++, partial_flags = 0 )
{
l3e = pl3e[i];
if ( i > page->nr_validated_ptes && hypercall_preempt_check() )
rc = -EINTR;
else if ( is_pv_32bit_domain(d) && (i == 3) )
{
if ( !(l3e_get_flags(l3e) & _PAGE_PRESENT) ||
(l3e_get_flags(l3e) & l3_disallow_mask(d)) )
rc = -EINVAL;
else
rc = get_page_and_type_from_mfn(
l3e_get_mfn(l3e),
PGT_l2_page_table | PGT_pae_xen_l2, d,
partial_flags | PTF_preemptible | PTF_retain_ref_on_restart);
}
else if ( !(l3e_get_flags(l3e) & _PAGE_PRESENT) )
{
if ( !pv_l1tf_check_l3e(d, l3e) )
continue;
rc = -EINTR;
}
else
rc = get_page_from_l3e(l3e, pfn, d,
partial_flags | PTF_retain_ref_on_restart);
if ( rc == -ERESTART )
{
page->nr_validated_ptes = i;
page->partial_flags = PTF_partial_set;
}
else if ( rc == -EINTR && i )
{
page->nr_validated_ptes = i;
page->partial_flags = 0;
rc = -ERESTART;
}
if ( rc < 0 )
break;
pl3e[i] = adjust_guest_l3e(l3e, d);
}
if ( !rc && !create_pae_xen_mappings(d, pl3e) )
rc = -EINVAL;
if ( rc < 0 && rc != -ERESTART && rc != -EINTR )
{
gdprintk(XENLOG_WARNING,
""Failure %d in alloc_l3_table: slot %#x\n"", rc, i);
if ( i )
{
page->nr_validated_ptes = i;
page->partial_flags = partial_flags;
if ( current->arch.old_guest_table )
{
if ( current->arch.old_guest_table == l3e_get_page(l3e) )
{
ASSERT(current->arch.old_guest_table_partial);
page->partial_flags = PTF_partial_set;
}
else
ASSERT_UNREACHABLE();
}
current->arch.old_guest_ptpg = NULL;
current->arch.old_guest_table = page;
current->arch.old_guest_table_partial = true;
}
while ( i-- > 0 )
pl3e[i] = unadjust_guest_l3e(pl3e[i], d);
}
unmap_domain_page(pl3e);
return rc;
}","static int alloc_l3_table(struct page_info *VAR_0)
{
struct domain *VAR_1 = page_get_owner(VAR_0);
unsigned long  VAR_2 = mfn_x(page_to_mfn(VAR_0));
l3_pgentry_t  *VAR_3;
unsigned int   VAR_4;
int            VAR_5 = 0;
unsigned int   VAR_6 = VAR_0->partial_flags;
l3_pgentry_t   VAR_7 = l3e_empty();
VAR_3 = map_domain_page(_mfn(VAR_2));
if ( is_pv_32bit_domain(VAR_1) )
memset(VAR_3 + 4, 0, (VAR_8 - 4) * sizeof(*VAR_3));
for ( VAR_4 = VAR_0->nr_validated_ptes; VAR_4 < VAR_8;
VAR_4++, VAR_6 = 0 )
{
VAR_7 = VAR_3[VAR_4];
if ( VAR_4 > VAR_0->nr_validated_ptes && hypercall_preempt_check() )
VAR_5 = -VAR_9;
else if ( is_pv_32bit_domain(VAR_1) && (VAR_4 == 3) )
{
if ( !(l3e_get_flags(VAR_7) & VAR_10) ||
(l3e_get_flags(VAR_7) & l3_disallow_mask(VAR_1)) )
VAR_5 = -VAR_11;
else
VAR_5 = get_page_and_type_from_mfn(
l3e_get_mfn(VAR_7),
VAR_12 | VAR_13, VAR_1,
VAR_6 | VAR_14 | VAR_15);
}
else if ( !(l3e_get_flags(VAR_7) & VAR_10) )
{
if ( !pv_l1tf_check_l3e(VAR_1, VAR_7) )
continue;
VAR_5 = -VAR_9;
}
else
VAR_5 = get_page_from_l3e(VAR_7, VAR_2, VAR_1,
VAR_6 | VAR_15);
if ( VAR_5 == -VAR_16 )
{
VAR_0->nr_validated_ptes = VAR_4;
VAR_0->partial_flags = VAR_17;
}
else if ( VAR_5 == -VAR_9 && VAR_4 )
{
VAR_0->nr_validated_ptes = VAR_4;
VAR_0->partial_flags = 0;
VAR_5 = -VAR_16;
}
if ( VAR_5 < 0 )
break;
VAR_3[VAR_4] = adjust_guest_l3e(VAR_7, VAR_1);
}
if ( !VAR_5 && !create_pae_xen_mappings(VAR_1, VAR_3) )
VAR_5 = -VAR_11;
if ( VAR_5 < 0 && VAR_5 != -VAR_16 && VAR_5 != -VAR_9 )
{
gdprintk(VAR_18,
""Failure %d in alloc_l3_table: slot %#x\n"", VAR_5, VAR_4);
if ( VAR_4 )
{
VAR_0->nr_validated_ptes = VAR_4;
VAR_0->partial_flags = VAR_6;
if ( VAR_19->arch.old_guest_table )
{
if ( VAR_19->arch.old_guest_table == l3e_get_page(VAR_7) )
{
ASSERT(VAR_19->arch.old_guest_table_partial);
VAR_0->partial_flags = VAR_17;
}
else
ASSERT_UNREACHABLE();
}
VAR_19->arch.old_guest_ptpg = NULL;
VAR_19->arch.old_guest_table = VAR_0;
VAR_19->arch.old_guest_table_partial = true;
}
while ( VAR_4-- > 0 )
VAR_3[VAR_4] = unadjust_guest_l3e(VAR_3[VAR_4], VAR_1);
}
unmap_domain_page(VAR_3);
return VAR_5;
}",xen-project/xen/4e70f4476c0c543559f971faecdd5f1300cddb0a/mm.c/vul/before/1.json,"static int alloc_l3_table(struct page_info *page)
{
    struct domain *d = page_get_owner(page);
    unsigned long  pfn = mfn_x(page_to_mfn(page));
    l3_pgentry_t  *pl3e;
    unsigned int   i;
    int            rc = 0;
    unsigned int   partial_flags = page->partial_flags;
    l3_pgentry_t   l3e = l3e_empty();

    pl3e = map_domain_page(_mfn(pfn));

    /*
     * PAE guests allocate full pages, but aren't required to initialize
     * more than the first four entries; when running in compatibility
     * mode, however, the full page is visible to the MMU, and hence all
     * 512 entries must be valid/verified, which is most easily achieved
     * by clearing them out.
     */
    if ( is_pv_32bit_domain(d) )
        memset(pl3e + 4, 0, (L3_PAGETABLE_ENTRIES - 4) * sizeof(*pl3e));

    for ( i = page->nr_validated_ptes; i < L3_PAGETABLE_ENTRIES;
          i++, partial_flags = 0 )
    {
        l3e = pl3e[i];

        if ( i > page->nr_validated_ptes && hypercall_preempt_check() )
            rc = -EINTR;
        else if ( is_pv_32bit_domain(d) && (i == 3) )
        {
            if ( !(l3e_get_flags(l3e) & _PAGE_PRESENT) ||
                 (l3e_get_flags(l3e) & l3_disallow_mask(d)) )
                rc = -EINVAL;
            else
                rc = get_page_and_type_from_mfn(
                    l3e_get_mfn(l3e),
                    PGT_l2_page_table | PGT_pae_xen_l2, d,
                    partial_flags | PTF_preemptible | PTF_retain_ref_on_restart);
        }
        else if ( !(l3e_get_flags(l3e) & _PAGE_PRESENT) )
        {
            if ( !pv_l1tf_check_l3e(d, l3e) )
                continue;
            rc = -EINTR;
        }
        else
            rc = get_page_from_l3e(l3e, pfn, d,
                                   partial_flags | PTF_retain_ref_on_restart);

        if ( rc == -ERESTART )
        {
            page->nr_validated_ptes = i;
            /* Set 'set', leave 'general ref' set if this entry was set */
            page->partial_flags = PTF_partial_set;
        }
        else if ( rc == -EINTR && i )
        {
            page->nr_validated_ptes = i;
            page->partial_flags = partial_flags;
            rc = -ERESTART;
        }
        if ( rc < 0 )
            break;

        pl3e[i] = adjust_guest_l3e(l3e, d);
    }

    if ( !rc && !create_pae_xen_mappings(d, pl3e) )
        rc = -EINVAL;
    if ( rc < 0 && rc != -ERESTART && rc != -EINTR )
    {
        gdprintk(XENLOG_WARNING,
                 ""Failure %d in alloc_l3_table: slot %#x\n"", rc, i);
        if ( i )
        {
            page->nr_validated_ptes = i;
            page->partial_flags = partial_flags;
            if ( current->arch.old_guest_table )
            {
                /*
                 * We've experienced a validation failure.  If
                 * old_guest_table is set, ""transfer"" the general
                 * reference count to pl3e[nr_validated_ptes] by
                 * setting PTF_partial_set.
                 *
                 * As a precaution, check that old_guest_table is the
                 * page pointed to by pl3e[nr_validated_ptes].  If
                 * not, it's safer to leak a type ref on production
                 * builds.
                 */
                if ( current->arch.old_guest_table == l3e_get_page(l3e) )
                {
                    ASSERT(current->arch.old_guest_table_partial);
                    page->partial_flags = PTF_partial_set;
                }
                else
                    ASSERT_UNREACHABLE();
            }
            current->arch.old_guest_ptpg = NULL;
            current->arch.old_guest_table = page;
            current->arch.old_guest_table_partial = true;
        }
        while ( i-- > 0 )
            pl3e[i] = unadjust_guest_l3e(pl3e[i], d);
    }

    unmap_domain_page(pl3e);
    return rc;
}","static int alloc_l3_table(struct page_info *VAR_0)
{
    struct domain *VAR_1 = page_get_owner(VAR_0);
    unsigned long  VAR_2 = mfn_x(page_to_mfn(VAR_0));
    l3_pgentry_t  *VAR_3;
    unsigned int   VAR_4;
    int            VAR_5 = 0;
    unsigned int   VAR_6 = VAR_0->partial_flags;
    l3_pgentry_t   VAR_7 = l3e_empty();

    VAR_3 = map_domain_page(_mfn(VAR_2));

    /* COMMENT_0 */
                                                                        
                                                                      
                                                                        
                                                                        
                            
       
    if ( is_pv_32bit_domain(VAR_1) )
        memset(VAR_3 + 4, 0, (VAR_8 - 4) * sizeof(*VAR_3));

    for ( VAR_4 = VAR_0->nr_validated_ptes; VAR_4 < VAR_8;
          VAR_4++, VAR_6 = 0 )
    {
        VAR_7 = VAR_3[VAR_4];

        if ( VAR_4 > VAR_0->nr_validated_ptes && hypercall_preempt_check() )
            VAR_5 = -VAR_9;
        else if ( is_pv_32bit_domain(VAR_1) && (VAR_4 == 3) )
        {
            if ( !(l3e_get_flags(VAR_7) & VAR_10) ||
                 (l3e_get_flags(VAR_7) & l3_disallow_mask(VAR_1)) )
                VAR_5 = -VAR_11;
            else
                VAR_5 = get_page_and_type_from_mfn(
                    l3e_get_mfn(VAR_7),
                    VAR_12 | VAR_13, VAR_1,
                    VAR_6 | VAR_14 | VAR_15);
        }
        else if ( !(l3e_get_flags(VAR_7) & VAR_10) )
        {
            if ( !pv_l1tf_check_l3e(VAR_1, VAR_7) )
                continue;
            VAR_5 = -VAR_9;
        }
        else
            VAR_5 = get_page_from_l3e(VAR_7, VAR_2, VAR_1,
                                   VAR_6 | VAR_15);

        if ( VAR_5 == -VAR_16 )
        {
            VAR_0->nr_validated_ptes = VAR_4;
            /* COMMENT_7 */
            VAR_0->partial_flags = VAR_17;
        }
        else if ( VAR_5 == -VAR_9 && VAR_4 )
        {
            VAR_0->nr_validated_ptes = VAR_4;
            VAR_0->partial_flags = VAR_6;
            VAR_5 = -VAR_16;
        }
        if ( VAR_5 < 0 )
            break;

        VAR_3[VAR_4] = adjust_guest_l3e(VAR_7, VAR_1);
    }

    if ( !VAR_5 && !create_pae_xen_mappings(VAR_1, VAR_3) )
        VAR_5 = -VAR_11;
    if ( VAR_5 < 0 && VAR_5 != -VAR_16 && VAR_5 != -VAR_9 )
    {
        gdprintk(VAR_18,
                 ""Failure %d in alloc_l3_table: slot %#x\n"", VAR_5, VAR_4);
        if ( VAR_4 )
        {
            VAR_0->nr_validated_ptes = VAR_4;
            VAR_0->partial_flags = VAR_6;
            if ( VAR_19->arch.old_guest_table )
            {
                /* COMMENT_8 */
                                                              
                                                                 
                                                                
                                           
                  
                                                                     
                                                                  
                                                                   
                          
                   
                if ( VAR_19->arch.old_guest_table == l3e_get_page(VAR_7) )
                {
                    ASSERT(VAR_19->arch.old_guest_table_partial);
                    VAR_0->partial_flags = VAR_17;
                }
                else
                    ASSERT_UNREACHABLE();
            }
            VAR_19->arch.old_guest_ptpg = NULL;
            VAR_19->arch.old_guest_table = VAR_0;
            VAR_19->arch.old_guest_table_partial = true;
        }
        while ( VAR_4-- > 0 )
            VAR_3[VAR_4] = unadjust_guest_l3e(VAR_3[VAR_4], VAR_1);
    }

    unmap_domain_page(VAR_3);
    return VAR_5;
}",xen-project/xen/4e70f4476c0c543559f971faecdd5f1300cddb0a/mm.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -57,7 +57,7 @@
         else if ( rc == -EINTR && i )
         {
             page->nr_validated_ptes = i;
-            page->partial_flags = 0;
+            page->partial_flags = partial_flags;
             rc = -ERESTART;
         }
         if ( rc < 0 )","{'deleted_lines': ['            page->partial_flags = 0;'], 'added_lines': ['            page->partial_flags = partial_flags;']}",True,"An issue was discovered in Xen through 4.12.x allowing x86 PV guest OS users to gain host OS privileges by leveraging race conditions in pagetable promotion and demotion operations, because of an incomplete fix for CVE-2019-18421. XSA-299 addressed several critical issues in restartable PV type change operations. Despite extensive testing and auditing, some corner cases were missed. A malicious PV guest administrator may be able to escalate their privilege to that of the host. All security-supported versions of Xen are vulnerable. Only x86 systems are affected. Arm systems are not affected. Only x86 PV guests can leverage the vulnerability. x86 HVM and PVH guests cannot leverage the vulnerability. Note that these attacks require very precise timing, which may be difficult to exploit in practice.",6.6,MEDIUM,1,valid,2019-10-31T11:17:38Z,3
CVE-2019-19580,['CWE-362'],AV:N/AC:M/Au:S/C:P/I:P/A:P,0,xen-project/xen,"x86/mm: alloc/free_lN_table: Retain partial_flags on -EINTR

When validating or de-validating pages (in alloc_lN_table and
free_lN_table respectively), the `partial_flags` local variable is
used to keep track of whether the ""current"" PTE started the entire
operation in a ""may be partial"" state.

One of the patches in XSA-299 addressed the fact that it is possible
for a previously-partially-validated entry to subsequently be found to
have invalid entries (indicated by returning -EINVAL); in which case
page->partial_flags needs to be set to indicate that the current PTE
may have the partial bit set (and thus _put_page_type() should be
called with PTF_partial_set).

Unfortunately, the patches in XSA-299 assumed that once
put_page_from_lNe() returned -ERESTART on a page, it was not possible
for it to return -EINTR.  This turns out to be true for
alloc_lN_table() and free_lN_table, but not for _get_page_type() and
_put_page_type(): both can return -EINTR when called on pages with
PGT_partial set.  In these cases, the pages PGT_partial will still be
set; failing to set partial_flags appropriately may allow an attacker
to do a privilege escalation similar to those described in XSA-299.

Fix this by always copying the local partial_flags variable into
page->partial_flags when exiting early.

NB that on the ""get"" side, no adjustment to nr_validated_entries is
needed: whether pte[i] is partially validated or entirely
un-validated, we want nr_validated_entries = i.  On the ""put"" side,
however, we need to adjust nr_validated_entries appropriately: if
pte[i] is entirely validated, we want nr_validated_entries = i + 1; if
pte[i] is partially validated, we want nr_validated_entries = i.

This is part of XSA-310.

Signed-off-by: George Dunlap <george.dunlap@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",4e70f4476c0c543559f971faecdd5f1300cddb0a,https://github.com/xen-project/xen/commit/4e70f4476c0c543559f971faecdd5f1300cddb0a,xen/arch/x86/mm.c,free_l2_table,"static int free_l2_table(struct page_info *page)
{
struct domain *d = page_get_owner(page);
unsigned long pfn = mfn_x(page_to_mfn(page));
l2_pgentry_t *pl2e;
int rc = 0;
unsigned int partial_flags = page->partial_flags,
i = page->nr_validated_ptes - !(partial_flags & PTF_partial_set);
pl2e = map_domain_page(_mfn(pfn));
for ( ; ; )
{
if ( is_guest_l2_slot(d, page->u.inuse.type_info, i) )
rc = put_page_from_l2e(pl2e[i], pfn, partial_flags);
if ( rc < 0 )
break;
partial_flags = 0;
if ( !i-- )
break;
if ( hypercall_preempt_check() )
{
rc = -EINTR;
break;
}
}
unmap_domain_page(pl2e);
if ( rc >= 0 )
{
page->u.inuse.type_info &= ~PGT_pae_xen_l2;
rc = 0;
}
else if ( rc == -ERESTART )
{
page->nr_validated_ptes = i;
page->partial_flags = PTF_partial_set;
}
else if ( rc == -EINTR && i < L2_PAGETABLE_ENTRIES - 1 )
{
page->nr_validated_ptes = i + 1;
page->partial_flags = 0;
rc = -ERESTART;
}
return rc;
}","static int free_l2_table(struct page_info *VAR_0)
{
struct domain *VAR_1 = page_get_owner(VAR_0);
unsigned long VAR_2 = mfn_x(page_to_mfn(VAR_0));
l2_pgentry_t *VAR_3;
int VAR_4 = 0;
unsigned int VAR_5 = VAR_0->partial_flags,
VAR_6 = VAR_0->nr_validated_ptes - !(VAR_5 & VAR_7);
VAR_3 = map_domain_page(_mfn(VAR_2));
for ( ; ; )
{
if ( is_guest_l2_slot(VAR_1, VAR_0->u.inuse.type_info, VAR_6) )
VAR_4 = put_page_from_l2e(VAR_3[VAR_6], VAR_2, VAR_5);
if ( VAR_4 < 0 )
break;
VAR_5 = 0;
if ( !VAR_6-- )
break;
if ( hypercall_preempt_check() )
{
VAR_4 = -VAR_8;
break;
}
}
unmap_domain_page(VAR_3);
if ( VAR_4 >= 0 )
{
VAR_0->u.inuse.type_info &= ~VAR_9;
VAR_4 = 0;
}
else if ( VAR_4 == -VAR_10 )
{
VAR_0->nr_validated_ptes = VAR_6;
VAR_0->partial_flags = VAR_7;
}
else if ( VAR_4 == -VAR_8 && VAR_6 < VAR_11 - 1 )
{
VAR_0->nr_validated_ptes = VAR_6 + 1;
VAR_0->partial_flags = 0;
VAR_4 = -VAR_10;
}
return VAR_4;
}",xen-project/xen/4e70f4476c0c543559f971faecdd5f1300cddb0a/mm.c/vul/before/2.json,"static int free_l2_table(struct page_info *page)
{
    struct domain *d = page_get_owner(page);
    unsigned long pfn = mfn_x(page_to_mfn(page));
    l2_pgentry_t *pl2e;
    int rc = 0;
    unsigned int partial_flags = page->partial_flags,
        i = page->nr_validated_ptes - !(partial_flags & PTF_partial_set);

    pl2e = map_domain_page(_mfn(pfn));

    for ( ; ; )
    {
        if ( is_guest_l2_slot(d, page->u.inuse.type_info, i) )
            rc = put_page_from_l2e(pl2e[i], pfn, partial_flags);
        if ( rc < 0 )
            break;

        partial_flags = 0;

        if ( !i-- )
            break;

        if ( hypercall_preempt_check() )
        {
            rc = -EINTR;
            break;
        }
    }

    unmap_domain_page(pl2e);

    if ( rc >= 0 )
    {
        page->u.inuse.type_info &= ~PGT_pae_xen_l2;
        rc = 0;
    }
    else if ( rc == -ERESTART )
    {
        page->nr_validated_ptes = i;
        page->partial_flags = PTF_partial_set;
    }
    else if ( rc == -EINTR && i < L2_PAGETABLE_ENTRIES - 1 )
    {
        page->nr_validated_ptes = i + !(partial_flags & PTF_partial_set);
        page->partial_flags = partial_flags;
        rc = -ERESTART;
    }

    return rc;
}","static int free_l2_table(struct page_info *VAR_0)
{
    struct domain *VAR_1 = page_get_owner(VAR_0);
    unsigned long VAR_2 = mfn_x(page_to_mfn(VAR_0));
    l2_pgentry_t *VAR_3;
    int VAR_4 = 0;
    unsigned int VAR_5 = VAR_0->partial_flags,
        VAR_6 = VAR_0->nr_validated_ptes - !(VAR_5 & VAR_7);

    VAR_3 = map_domain_page(_mfn(VAR_2));

    for ( ; ; )
    {
        if ( is_guest_l2_slot(VAR_1, VAR_0->u.inuse.type_info, VAR_6) )
            VAR_4 = put_page_from_l2e(VAR_3[VAR_6], VAR_2, VAR_5);
        if ( VAR_4 < 0 )
            break;

        VAR_5 = 0;

        if ( !VAR_6-- )
            break;

        if ( hypercall_preempt_check() )
        {
            VAR_4 = -VAR_8;
            break;
        }
    }

    unmap_domain_page(VAR_3);

    if ( VAR_4 >= 0 )
    {
        VAR_0->u.inuse.type_info &= ~VAR_9;
        VAR_4 = 0;
    }
    else if ( VAR_4 == -VAR_10 )
    {
        VAR_0->nr_validated_ptes = VAR_6;
        VAR_0->partial_flags = VAR_7;
    }
    else if ( VAR_4 == -VAR_8 && VAR_6 < VAR_11 - 1 )
    {
        VAR_0->nr_validated_ptes = VAR_6 + !(VAR_5 & VAR_7);
        VAR_0->partial_flags = VAR_5;
        VAR_4 = -VAR_10;
    }

    return VAR_4;
}",xen-project/xen/4e70f4476c0c543559f971faecdd5f1300cddb0a/mm.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -42,8 +42,8 @@
     }
     else if ( rc == -EINTR && i < L2_PAGETABLE_ENTRIES - 1 )
     {
-        page->nr_validated_ptes = i + 1;
-        page->partial_flags = 0;
+        page->nr_validated_ptes = i + !(partial_flags & PTF_partial_set);
+        page->partial_flags = partial_flags;
         rc = -ERESTART;
     }
 ","{'deleted_lines': ['        page->nr_validated_ptes = i + 1;', '        page->partial_flags = 0;'], 'added_lines': ['        page->nr_validated_ptes = i + !(partial_flags & PTF_partial_set);', '        page->partial_flags = partial_flags;']}",True,"An issue was discovered in Xen through 4.12.x allowing x86 PV guest OS users to gain host OS privileges by leveraging race conditions in pagetable promotion and demotion operations, because of an incomplete fix for CVE-2019-18421. XSA-299 addressed several critical issues in restartable PV type change operations. Despite extensive testing and auditing, some corner cases were missed. A malicious PV guest administrator may be able to escalate their privilege to that of the host. All security-supported versions of Xen are vulnerable. Only x86 systems are affected. Arm systems are not affected. Only x86 PV guests can leverage the vulnerability. x86 HVM and PVH guests cannot leverage the vulnerability. Note that these attacks require very precise timing, which may be difficult to exploit in practice.",6.6,MEDIUM,1,valid,2019-10-31T11:17:38Z,3
CVE-2019-19580,['CWE-362'],AV:N/AC:M/Au:S/C:P/I:P/A:P,0,xen-project/xen,"x86/mm: alloc/free_lN_table: Retain partial_flags on -EINTR

When validating or de-validating pages (in alloc_lN_table and
free_lN_table respectively), the `partial_flags` local variable is
used to keep track of whether the ""current"" PTE started the entire
operation in a ""may be partial"" state.

One of the patches in XSA-299 addressed the fact that it is possible
for a previously-partially-validated entry to subsequently be found to
have invalid entries (indicated by returning -EINVAL); in which case
page->partial_flags needs to be set to indicate that the current PTE
may have the partial bit set (and thus _put_page_type() should be
called with PTF_partial_set).

Unfortunately, the patches in XSA-299 assumed that once
put_page_from_lNe() returned -ERESTART on a page, it was not possible
for it to return -EINTR.  This turns out to be true for
alloc_lN_table() and free_lN_table, but not for _get_page_type() and
_put_page_type(): both can return -EINTR when called on pages with
PGT_partial set.  In these cases, the pages PGT_partial will still be
set; failing to set partial_flags appropriately may allow an attacker
to do a privilege escalation similar to those described in XSA-299.

Fix this by always copying the local partial_flags variable into
page->partial_flags when exiting early.

NB that on the ""get"" side, no adjustment to nr_validated_entries is
needed: whether pte[i] is partially validated or entirely
un-validated, we want nr_validated_entries = i.  On the ""put"" side,
however, we need to adjust nr_validated_entries appropriately: if
pte[i] is entirely validated, we want nr_validated_entries = i + 1; if
pte[i] is partially validated, we want nr_validated_entries = i.

This is part of XSA-310.

Signed-off-by: George Dunlap <george.dunlap@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",4e70f4476c0c543559f971faecdd5f1300cddb0a,https://github.com/xen-project/xen/commit/4e70f4476c0c543559f971faecdd5f1300cddb0a,xen/arch/x86/mm.c,free_l4_table,"static int free_l4_table(struct page_info *page)
{
struct domain *d = page_get_owner(page);
unsigned long pfn = mfn_x(page_to_mfn(page));
l4_pgentry_t *pl4e = map_domain_page(_mfn(pfn));
int rc = 0;
unsigned partial_flags = page->partial_flags,
i = page->nr_validated_ptes - !(partial_flags & PTF_partial_set);
do {
if ( is_guest_l4_slot(d, i) )
rc = put_page_from_l4e(pl4e[i], pfn, partial_flags);
if ( rc < 0 )
break;
partial_flags = 0;
} while ( i-- );
if ( rc == -ERESTART )
{
page->nr_validated_ptes = i;
page->partial_flags = PTF_partial_set;
}
else if ( rc == -EINTR && i < L4_PAGETABLE_ENTRIES - 1 )
{
page->nr_validated_ptes = i + 1;
page->partial_flags = 0;
rc = -ERESTART;
}
unmap_domain_page(pl4e);
if ( rc >= 0 )
{
atomic_dec(&d->arch.pv.nr_l4_pages);
rc = 0;
}
return rc;
}","static int free_l4_table(struct page_info *VAR_0)
{
struct domain *VAR_1 = page_get_owner(VAR_0);
unsigned long VAR_2 = mfn_x(page_to_mfn(VAR_0));
l4_pgentry_t *VAR_3 = map_domain_page(_mfn(VAR_2));
int VAR_4 = 0;
unsigned VAR_5 = VAR_0->partial_flags,
VAR_6 = VAR_0->nr_validated_ptes - !(VAR_5 & VAR_7);
do {
if ( is_guest_l4_slot(VAR_1, VAR_6) )
VAR_4 = put_page_from_l4e(VAR_3[VAR_6], VAR_2, VAR_5);
if ( VAR_4 < 0 )
break;
VAR_5 = 0;
} while ( VAR_6-- );
if ( VAR_4 == -VAR_8 )
{
VAR_0->nr_validated_ptes = VAR_6;
VAR_0->partial_flags = VAR_7;
}
else if ( VAR_4 == -VAR_9 && VAR_6 < VAR_10 - 1 )
{
VAR_0->nr_validated_ptes = VAR_6 + 1;
VAR_0->partial_flags = 0;
VAR_4 = -VAR_8;
}
unmap_domain_page(VAR_3);
if ( VAR_4 >= 0 )
{
atomic_dec(&VAR_1->arch.pv.nr_l4_pages);
VAR_4 = 0;
}
return VAR_4;
}",xen-project/xen/4e70f4476c0c543559f971faecdd5f1300cddb0a/mm.c/vul/before/3.json,"static int free_l4_table(struct page_info *page)
{
    struct domain *d = page_get_owner(page);
    unsigned long pfn = mfn_x(page_to_mfn(page));
    l4_pgentry_t *pl4e = map_domain_page(_mfn(pfn));
    int rc = 0;
    unsigned partial_flags = page->partial_flags,
        i = page->nr_validated_ptes - !(partial_flags & PTF_partial_set);

    do {
        if ( is_guest_l4_slot(d, i) )
            rc = put_page_from_l4e(pl4e[i], pfn, partial_flags);
        if ( rc < 0 )
            break;
        partial_flags = 0;
    } while ( i-- );

    if ( rc == -ERESTART )
    {
        page->nr_validated_ptes = i;
        page->partial_flags = PTF_partial_set;
    }
    else if ( rc == -EINTR && i < L4_PAGETABLE_ENTRIES - 1 )
    {
        page->nr_validated_ptes = i + !(partial_flags & PTF_partial_set);
        page->partial_flags = partial_flags;
        rc = -ERESTART;
    }

    unmap_domain_page(pl4e);

    if ( rc >= 0 )
    {
        atomic_dec(&d->arch.pv.nr_l4_pages);
        rc = 0;
    }

    return rc;
}","static int free_l4_table(struct page_info *VAR_0)
{
    struct domain *VAR_1 = page_get_owner(VAR_0);
    unsigned long VAR_2 = mfn_x(page_to_mfn(VAR_0));
    l4_pgentry_t *VAR_3 = map_domain_page(_mfn(VAR_2));
    int VAR_4 = 0;
    unsigned VAR_5 = VAR_0->partial_flags,
        VAR_6 = VAR_0->nr_validated_ptes - !(VAR_5 & VAR_7);

    do {
        if ( is_guest_l4_slot(VAR_1, VAR_6) )
            VAR_4 = put_page_from_l4e(VAR_3[VAR_6], VAR_2, VAR_5);
        if ( VAR_4 < 0 )
            break;
        VAR_5 = 0;
    } while ( VAR_6-- );

    if ( VAR_4 == -VAR_8 )
    {
        VAR_0->nr_validated_ptes = VAR_6;
        VAR_0->partial_flags = VAR_7;
    }
    else if ( VAR_4 == -VAR_9 && VAR_6 < VAR_10 - 1 )
    {
        VAR_0->nr_validated_ptes = VAR_6 + !(VAR_5 & VAR_7);
        VAR_0->partial_flags = VAR_5;
        VAR_4 = -VAR_8;
    }

    unmap_domain_page(VAR_3);

    if ( VAR_4 >= 0 )
    {
        atomic_dec(&VAR_1->arch.pv.nr_l4_pages);
        VAR_4 = 0;
    }

    return VAR_4;
}",xen-project/xen/4e70f4476c0c543559f971faecdd5f1300cddb0a/mm.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -22,8 +22,8 @@
     }
     else if ( rc == -EINTR && i < L4_PAGETABLE_ENTRIES - 1 )
     {
-        page->nr_validated_ptes = i + 1;
-        page->partial_flags = 0;
+        page->nr_validated_ptes = i + !(partial_flags & PTF_partial_set);
+        page->partial_flags = partial_flags;
         rc = -ERESTART;
     }
 ","{'deleted_lines': ['        page->nr_validated_ptes = i + 1;', '        page->partial_flags = 0;'], 'added_lines': ['        page->nr_validated_ptes = i + !(partial_flags & PTF_partial_set);', '        page->partial_flags = partial_flags;']}",True,"An issue was discovered in Xen through 4.12.x allowing x86 PV guest OS users to gain host OS privileges by leveraging race conditions in pagetable promotion and demotion operations, because of an incomplete fix for CVE-2019-18421. XSA-299 addressed several critical issues in restartable PV type change operations. Despite extensive testing and auditing, some corner cases were missed. A malicious PV guest administrator may be able to escalate their privilege to that of the host. All security-supported versions of Xen are vulnerable. Only x86 systems are affected. Arm systems are not affected. Only x86 PV guests can leverage the vulnerability. x86 HVM and PVH guests cannot leverage the vulnerability. Note that these attacks require very precise timing, which may be difficult to exploit in practice.",6.6,MEDIUM,1,valid,2019-10-31T11:17:38Z,3
CVE-2019-19580,['CWE-362'],AV:N/AC:M/Au:S/C:P/I:P/A:P,0,xen-project/xen,"x86/mm: alloc/free_lN_table: Retain partial_flags on -EINTR

When validating or de-validating pages (in alloc_lN_table and
free_lN_table respectively), the `partial_flags` local variable is
used to keep track of whether the ""current"" PTE started the entire
operation in a ""may be partial"" state.

One of the patches in XSA-299 addressed the fact that it is possible
for a previously-partially-validated entry to subsequently be found to
have invalid entries (indicated by returning -EINVAL); in which case
page->partial_flags needs to be set to indicate that the current PTE
may have the partial bit set (and thus _put_page_type() should be
called with PTF_partial_set).

Unfortunately, the patches in XSA-299 assumed that once
put_page_from_lNe() returned -ERESTART on a page, it was not possible
for it to return -EINTR.  This turns out to be true for
alloc_lN_table() and free_lN_table, but not for _get_page_type() and
_put_page_type(): both can return -EINTR when called on pages with
PGT_partial set.  In these cases, the pages PGT_partial will still be
set; failing to set partial_flags appropriately may allow an attacker
to do a privilege escalation similar to those described in XSA-299.

Fix this by always copying the local partial_flags variable into
page->partial_flags when exiting early.

NB that on the ""get"" side, no adjustment to nr_validated_entries is
needed: whether pte[i] is partially validated or entirely
un-validated, we want nr_validated_entries = i.  On the ""put"" side,
however, we need to adjust nr_validated_entries appropriately: if
pte[i] is entirely validated, we want nr_validated_entries = i + 1; if
pte[i] is partially validated, we want nr_validated_entries = i.

This is part of XSA-310.

Signed-off-by: George Dunlap <george.dunlap@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",4e70f4476c0c543559f971faecdd5f1300cddb0a,https://github.com/xen-project/xen/commit/4e70f4476c0c543559f971faecdd5f1300cddb0a,xen/arch/x86/mm.c,alloc_l2_table,"static int alloc_l2_table(struct page_info *page, unsigned long type)
{
struct domain *d = page_get_owner(page);
unsigned long  pfn = mfn_x(page_to_mfn(page));
l2_pgentry_t  *pl2e;
unsigned int   i;
int            rc = 0;
unsigned int   partial_flags = page->partial_flags;
pl2e = map_domain_page(_mfn(pfn));
for ( i = page->nr_validated_ptes; i < L2_PAGETABLE_ENTRIES;
i++, partial_flags = 0 )
{
l2_pgentry_t l2e = pl2e[i];
if ( i > page->nr_validated_ptes && hypercall_preempt_check() )
rc = -EINTR;
else if ( !is_guest_l2_slot(d, type, i) )
continue;
else if ( !(l2e_get_flags(l2e) & _PAGE_PRESENT) )
{
if ( !pv_l1tf_check_l2e(d, l2e) )
continue;
rc = -EINTR;
}
else
rc = get_page_from_l2e(l2e, pfn, d, partial_flags);
ASSERT(rc != -ERESTART);
if ( rc == -EINTR && i )
{
page->nr_validated_ptes = i;
page->partial_flags = 0;
rc = -ERESTART;
}
else if ( rc < 0 && rc != -EINTR )
{
gdprintk(XENLOG_WARNING,
""Failure %d in alloc_l2_table: slot %#x\n"", rc, i);
ASSERT(current->arch.old_guest_table == NULL);
if ( i )
{
ASSERT(current->arch.old_guest_table == NULL);
page->nr_validated_ptes = i;
page->partial_flags = partial_flags;
current->arch.old_guest_ptpg = NULL;
current->arch.old_guest_table = page;
current->arch.old_guest_table_partial = true;
}
}
if ( rc < 0 )
break;
pl2e[i] = adjust_guest_l2e(l2e, d);
}
if ( !rc && (type & PGT_pae_xen_l2) )
init_xen_pae_l2_slots(pl2e, d);
unmap_domain_page(pl2e);
return rc;
}","static int alloc_l2_table(struct page_info *VAR_0, unsigned long VAR_1)
{
struct domain *VAR_2 = page_get_owner(VAR_0);
unsigned long  VAR_3 = mfn_x(page_to_mfn(VAR_0));
l2_pgentry_t  *VAR_4;
unsigned int   VAR_5;
int            VAR_6 = 0;
unsigned int   VAR_7 = VAR_0->partial_flags;
VAR_4 = map_domain_page(_mfn(VAR_3));
for ( VAR_5 = VAR_0->nr_validated_ptes; VAR_5 < VAR_8;
VAR_5++, VAR_7 = 0 )
{
l2_pgentry_t VAR_9 = VAR_4[VAR_5];
if ( VAR_5 > VAR_0->nr_validated_ptes && hypercall_preempt_check() )
VAR_6 = -VAR_10;
else if ( !is_guest_l2_slot(VAR_2, VAR_1, VAR_5) )
continue;
else if ( !(l2e_get_flags(VAR_9) & VAR_11) )
{
if ( !pv_l1tf_check_l2e(VAR_2, VAR_9) )
continue;
VAR_6 = -VAR_10;
}
else
VAR_6 = get_page_from_l2e(VAR_9, VAR_3, VAR_2, VAR_7);
ASSERT(VAR_6 != -VAR_12);
if ( VAR_6 == -VAR_10 && VAR_5 )
{
VAR_0->nr_validated_ptes = VAR_5;
VAR_0->partial_flags = 0;
VAR_6 = -VAR_12;
}
else if ( VAR_6 < 0 && VAR_6 != -VAR_10 )
{
gdprintk(VAR_13,
""Failure %d in alloc_l2_table: slot %#x\n"", VAR_6, VAR_5);
ASSERT(VAR_14->arch.old_guest_table == NULL);
if ( VAR_5 )
{
ASSERT(VAR_14->arch.old_guest_table == NULL);
VAR_0->nr_validated_ptes = VAR_5;
VAR_0->partial_flags = VAR_7;
VAR_14->arch.old_guest_ptpg = NULL;
VAR_14->arch.old_guest_table = VAR_0;
VAR_14->arch.old_guest_table_partial = true;
}
}
if ( VAR_6 < 0 )
break;
VAR_4[VAR_5] = adjust_guest_l2e(VAR_9, VAR_2);
}
if ( !VAR_6 && (VAR_1 & VAR_15) )
init_xen_pae_l2_slots(VAR_4, VAR_2);
unmap_domain_page(VAR_4);
return VAR_6;
}",xen-project/xen/4e70f4476c0c543559f971faecdd5f1300cddb0a/mm.c/vul/before/4.json,"static int alloc_l2_table(struct page_info *page, unsigned long type)
{
    struct domain *d = page_get_owner(page);
    unsigned long  pfn = mfn_x(page_to_mfn(page));
    l2_pgentry_t  *pl2e;
    unsigned int   i;
    int            rc = 0;
    unsigned int   partial_flags = page->partial_flags;

    pl2e = map_domain_page(_mfn(pfn));

    /*
     * NB that alloc_l2_table will never set partial_pte on an l2; but
     * free_l2_table might if a linear_pagetable entry is interrupted
     * partway through de-validation.  In that circumstance,
     * get_page_from_l2e() will always return -EINVAL; and we must
     * retain the type ref by doing the normal partial_flags tracking.
     */

    for ( i = page->nr_validated_ptes; i < L2_PAGETABLE_ENTRIES;
          i++, partial_flags = 0 )
    {
        l2_pgentry_t l2e = pl2e[i];

        if ( i > page->nr_validated_ptes && hypercall_preempt_check() )
            rc = -EINTR;
        else if ( !is_guest_l2_slot(d, type, i) )
            continue;
        else if ( !(l2e_get_flags(l2e) & _PAGE_PRESENT) )
        {
            if ( !pv_l1tf_check_l2e(d, l2e) )
                continue;
            rc = -EINTR;
        }
        else
            rc = get_page_from_l2e(l2e, pfn, d, partial_flags);

        /*
         * It shouldn't be possible for get_page_from_l2e to return
         * -ERESTART, since we never call this with PTF_preemptible.
         * (alloc_l1_table may return -EINTR on an L1TF-vulnerable
         * entry.)
         *
         * NB that while on a ""clean"" promotion, we can never get
         * PGT_partial.  It is possible to arrange for an l2e to
         * contain a partially-devalidated l2; but in that case, both
         * of the following functions will fail anyway (the first
         * because the page in question is not an l1; the second
         * because the page is not fully validated).
         */
        ASSERT(rc != -ERESTART);

        if ( rc == -EINTR && i )
        {
            page->nr_validated_ptes = i;
            page->partial_flags = partial_flags;;
            rc = -ERESTART;
        }
        else if ( rc < 0 && rc != -EINTR )
        {
            gdprintk(XENLOG_WARNING,
                     ""Failure %d in alloc_l2_table: slot %#x\n"", rc, i);
            ASSERT(current->arch.old_guest_table == NULL);
            if ( i )
            {
                /*
                 * alloc_l1_table() doesn't set old_guest_table; it does
                 * its own tear-down immediately on failure.  If it
                 * did we'd need to check it and set partial_flags as we
                 * do in alloc_l[34]_table().
                 *
                 * Note on the use of ASSERT: if it's non-null and
                 * hasn't been cleaned up yet, it should have
                 * PGT_partial set; and so the type will be cleaned up
                 * on domain destruction.  Unfortunately, we would
                 * leak the general ref held by old_guest_table; but
                 * leaking a page is less bad than a host crash.
                 */
                ASSERT(current->arch.old_guest_table == NULL);
                page->nr_validated_ptes = i;
                page->partial_flags = partial_flags;
                current->arch.old_guest_ptpg = NULL;
                current->arch.old_guest_table = page;
                current->arch.old_guest_table_partial = true;
            }
        }
        if ( rc < 0 )
            break;

        pl2e[i] = adjust_guest_l2e(l2e, d);
    }

    if ( !rc && (type & PGT_pae_xen_l2) )
        init_xen_pae_l2_slots(pl2e, d);

    unmap_domain_page(pl2e);
    return rc;
}","static int alloc_l2_table(struct page_info *VAR_0, unsigned long VAR_1)
{
    struct domain *VAR_2 = page_get_owner(VAR_0);
    unsigned long  VAR_3 = mfn_x(page_to_mfn(VAR_0));
    l2_pgentry_t  *VAR_4;
    unsigned int   VAR_5;
    int            VAR_6 = 0;
    unsigned int   VAR_7 = VAR_0->partial_flags;

    VAR_4 = map_domain_page(_mfn(VAR_3));

    /* COMMENT_0 */
                                                                      
                                                                     
                                                            
                                                                  
                                                                      
       

    for ( VAR_5 = VAR_0->nr_validated_ptes; VAR_5 < VAR_8;
          VAR_5++, VAR_7 = 0 )
    {
        l2_pgentry_t VAR_9 = VAR_4[VAR_5];

        if ( VAR_5 > VAR_0->nr_validated_ptes && hypercall_preempt_check() )
            VAR_6 = -VAR_10;
        else if ( !is_guest_l2_slot(VAR_2, VAR_1, VAR_5) )
            continue;
        else if ( !(l2e_get_flags(VAR_9) & VAR_11) )
        {
            if ( !pv_l1tf_check_l2e(VAR_2, VAR_9) )
                continue;
            VAR_6 = -VAR_10;
        }
        else
            VAR_6 = get_page_from_l2e(VAR_9, VAR_3, VAR_2, VAR_7);

        /* COMMENT_7 */
                                                                   
                                                                    
                                                                  
                  
          
                                                                 
                                                                
                                                                     
                                                                 
                                                                
                                                    
           
        ASSERT(VAR_6 != -VAR_12);

        if ( VAR_6 == -VAR_10 && VAR_5 )
        {
            VAR_0->nr_validated_ptes = VAR_5;
            VAR_0->partial_flags = VAR_7;;
            VAR_6 = -VAR_12;
        }
        else if ( VAR_6 < 0 && VAR_6 != -VAR_10 )
        {
            gdprintk(VAR_13,
                     ""Failure %d in alloc_l2_table: slot %#x\n"", VAR_6, VAR_5);
            ASSERT(VAR_14->arch.old_guest_table == NULL);
            if ( VAR_5 )
            {
                /* COMMENT_20 */
                                                                        
                                                                   
                                                                        
                                             
                  
                                                                  
                                                             
                                                                      
                                                                  
                                                                    
                                                                
                   
                ASSERT(VAR_14->arch.old_guest_table == NULL);
                VAR_0->nr_validated_ptes = VAR_5;
                VAR_0->partial_flags = VAR_7;
                VAR_14->arch.old_guest_ptpg = NULL;
                VAR_14->arch.old_guest_table = VAR_0;
                VAR_14->arch.old_guest_table_partial = true;
            }
        }
        if ( VAR_6 < 0 )
            break;

        VAR_4[VAR_5] = adjust_guest_l2e(VAR_9, VAR_2);
    }

    if ( !VAR_6 && (VAR_1 & VAR_15) )
        init_xen_pae_l2_slots(VAR_4, VAR_2);

    unmap_domain_page(VAR_4);
    return VAR_6;
}",xen-project/xen/4e70f4476c0c543559f971faecdd5f1300cddb0a/mm.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -53,7 +53,7 @@
         if ( rc == -EINTR && i )
         {
             page->nr_validated_ptes = i;
-            page->partial_flags = 0;
+            page->partial_flags = partial_flags;;
             rc = -ERESTART;
         }
         else if ( rc < 0 && rc != -EINTR )","{'deleted_lines': ['            page->partial_flags = 0;'], 'added_lines': ['            page->partial_flags = partial_flags;;']}",True,"An issue was discovered in Xen through 4.12.x allowing x86 PV guest OS users to gain host OS privileges by leveraging race conditions in pagetable promotion and demotion operations, because of an incomplete fix for CVE-2019-18421. XSA-299 addressed several critical issues in restartable PV type change operations. Despite extensive testing and auditing, some corner cases were missed. A malicious PV guest administrator may be able to escalate their privilege to that of the host. All security-supported versions of Xen are vulnerable. Only x86 systems are affected. Arm systems are not affected. Only x86 PV guests can leverage the vulnerability. x86 HVM and PVH guests cannot leverage the vulnerability. Note that these attacks require very precise timing, which may be difficult to exploit in practice.",6.6,MEDIUM,1,valid,2019-10-31T11:17:38Z,3
CVE-2019-19580,['CWE-362'],AV:N/AC:M/Au:S/C:P/I:P/A:P,0,xen-project/xen,"x86/mm: alloc/free_lN_table: Retain partial_flags on -EINTR

When validating or de-validating pages (in alloc_lN_table and
free_lN_table respectively), the `partial_flags` local variable is
used to keep track of whether the ""current"" PTE started the entire
operation in a ""may be partial"" state.

One of the patches in XSA-299 addressed the fact that it is possible
for a previously-partially-validated entry to subsequently be found to
have invalid entries (indicated by returning -EINVAL); in which case
page->partial_flags needs to be set to indicate that the current PTE
may have the partial bit set (and thus _put_page_type() should be
called with PTF_partial_set).

Unfortunately, the patches in XSA-299 assumed that once
put_page_from_lNe() returned -ERESTART on a page, it was not possible
for it to return -EINTR.  This turns out to be true for
alloc_lN_table() and free_lN_table, but not for _get_page_type() and
_put_page_type(): both can return -EINTR when called on pages with
PGT_partial set.  In these cases, the pages PGT_partial will still be
set; failing to set partial_flags appropriately may allow an attacker
to do a privilege escalation similar to those described in XSA-299.

Fix this by always copying the local partial_flags variable into
page->partial_flags when exiting early.

NB that on the ""get"" side, no adjustment to nr_validated_entries is
needed: whether pte[i] is partially validated or entirely
un-validated, we want nr_validated_entries = i.  On the ""put"" side,
however, we need to adjust nr_validated_entries appropriately: if
pte[i] is entirely validated, we want nr_validated_entries = i + 1; if
pte[i] is partially validated, we want nr_validated_entries = i.

This is part of XSA-310.

Signed-off-by: George Dunlap <george.dunlap@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",4e70f4476c0c543559f971faecdd5f1300cddb0a,https://github.com/xen-project/xen/commit/4e70f4476c0c543559f971faecdd5f1300cddb0a,xen/arch/x86/mm.c,free_l3_table,"static int free_l3_table(struct page_info *page)
{
struct domain *d = page_get_owner(page);
unsigned long pfn = mfn_x(page_to_mfn(page));
l3_pgentry_t *pl3e;
int rc = 0;
unsigned int partial_flags = page->partial_flags,
i = page->nr_validated_ptes - !(partial_flags & PTF_partial_set);
pl3e = map_domain_page(_mfn(pfn));
for ( ; ; )
{
rc = put_page_from_l3e(pl3e[i], pfn, partial_flags);
if ( rc < 0 )
break;
partial_flags = 0;
if ( rc == 0 )
pl3e[i] = unadjust_guest_l3e(pl3e[i], d);
if ( !i-- )
break;
if ( hypercall_preempt_check() )
{
rc = -EINTR;
break;
}
}
unmap_domain_page(pl3e);
if ( rc == -ERESTART )
{
page->nr_validated_ptes = i;
page->partial_flags = PTF_partial_set;
}
else if ( rc == -EINTR && i < L3_PAGETABLE_ENTRIES - 1 )
{
page->nr_validated_ptes = i + 1;
page->partial_flags = 0;
rc = -ERESTART;
}
return rc > 0 ? 0 : rc;
}","static int free_l3_table(struct page_info *VAR_0)
{
struct domain *VAR_1 = page_get_owner(VAR_0);
unsigned long VAR_2 = mfn_x(page_to_mfn(VAR_0));
l3_pgentry_t *VAR_3;
int VAR_4 = 0;
unsigned int VAR_5 = VAR_0->partial_flags,
VAR_6 = VAR_0->nr_validated_ptes - !(VAR_5 & VAR_7);
VAR_3 = map_domain_page(_mfn(VAR_2));
for ( ; ; )
{
VAR_4 = put_page_from_l3e(VAR_3[VAR_6], VAR_2, VAR_5);
if ( VAR_4 < 0 )
break;
VAR_5 = 0;
if ( VAR_4 == 0 )
VAR_3[VAR_6] = unadjust_guest_l3e(VAR_3[VAR_6], VAR_1);
if ( !VAR_6-- )
break;
if ( hypercall_preempt_check() )
{
VAR_4 = -VAR_8;
break;
}
}
unmap_domain_page(VAR_3);
if ( VAR_4 == -VAR_9 )
{
VAR_0->nr_validated_ptes = VAR_6;
VAR_0->partial_flags = VAR_7;
}
else if ( VAR_4 == -VAR_8 && VAR_6 < VAR_10 - 1 )
{
VAR_0->nr_validated_ptes = VAR_6 + 1;
VAR_0->partial_flags = 0;
VAR_4 = -VAR_9;
}
return VAR_4 > 0 ? 0 : VAR_4;
}",xen-project/xen/4e70f4476c0c543559f971faecdd5f1300cddb0a/mm.c/vul/before/0.json,"static int free_l3_table(struct page_info *page)
{
    struct domain *d = page_get_owner(page);
    unsigned long pfn = mfn_x(page_to_mfn(page));
    l3_pgentry_t *pl3e;
    int rc = 0;
    unsigned int partial_flags = page->partial_flags,
        i = page->nr_validated_ptes - !(partial_flags & PTF_partial_set);

    pl3e = map_domain_page(_mfn(pfn));

    for ( ; ; )
    {
        rc = put_page_from_l3e(pl3e[i], pfn, partial_flags);
        if ( rc < 0 )
            break;

        partial_flags = 0;
        if ( rc == 0 )
            pl3e[i] = unadjust_guest_l3e(pl3e[i], d);

        if ( !i-- )
            break;

        if ( hypercall_preempt_check() )
        {
            rc = -EINTR;
            break;
        }
    }

    unmap_domain_page(pl3e);

    if ( rc == -ERESTART )
    {
        page->nr_validated_ptes = i;
        page->partial_flags = PTF_partial_set;
    }
    else if ( rc == -EINTR && i < L3_PAGETABLE_ENTRIES - 1 )
    {
        page->nr_validated_ptes = i + !(partial_flags & PTF_partial_set);
        page->partial_flags = partial_flags;
        rc = -ERESTART;
    }
    return rc > 0 ? 0 : rc;
}","static int free_l3_table(struct page_info *VAR_0)
{
    struct domain *VAR_1 = page_get_owner(VAR_0);
    unsigned long VAR_2 = mfn_x(page_to_mfn(VAR_0));
    l3_pgentry_t *VAR_3;
    int VAR_4 = 0;
    unsigned int VAR_5 = VAR_0->partial_flags,
        VAR_6 = VAR_0->nr_validated_ptes - !(VAR_5 & VAR_7);

    VAR_3 = map_domain_page(_mfn(VAR_2));

    for ( ; ; )
    {
        VAR_4 = put_page_from_l3e(VAR_3[VAR_6], VAR_2, VAR_5);
        if ( VAR_4 < 0 )
            break;

        VAR_5 = 0;
        if ( VAR_4 == 0 )
            VAR_3[VAR_6] = unadjust_guest_l3e(VAR_3[VAR_6], VAR_1);

        if ( !VAR_6-- )
            break;

        if ( hypercall_preempt_check() )
        {
            VAR_4 = -VAR_8;
            break;
        }
    }

    unmap_domain_page(VAR_3);

    if ( VAR_4 == -VAR_9 )
    {
        VAR_0->nr_validated_ptes = VAR_6;
        VAR_0->partial_flags = VAR_7;
    }
    else if ( VAR_4 == -VAR_8 && VAR_6 < VAR_10 - 1 )
    {
        VAR_0->nr_validated_ptes = VAR_6 + !(VAR_5 & VAR_7);
        VAR_0->partial_flags = VAR_5;
        VAR_4 = -VAR_9;
    }
    return VAR_4 > 0 ? 0 : VAR_4;
}",xen-project/xen/4e70f4476c0c543559f971faecdd5f1300cddb0a/mm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -38,8 +38,8 @@
     }
     else if ( rc == -EINTR && i < L3_PAGETABLE_ENTRIES - 1 )
     {
-        page->nr_validated_ptes = i + 1;
-        page->partial_flags = 0;
+        page->nr_validated_ptes = i + !(partial_flags & PTF_partial_set);
+        page->partial_flags = partial_flags;
         rc = -ERESTART;
     }
     return rc > 0 ? 0 : rc;","{'deleted_lines': ['        page->nr_validated_ptes = i + 1;', '        page->partial_flags = 0;'], 'added_lines': ['        page->nr_validated_ptes = i + !(partial_flags & PTF_partial_set);', '        page->partial_flags = partial_flags;']}",True,"An issue was discovered in Xen through 4.12.x allowing x86 PV guest OS users to gain host OS privileges by leveraging race conditions in pagetable promotion and demotion operations, because of an incomplete fix for CVE-2019-18421. XSA-299 addressed several critical issues in restartable PV type change operations. Despite extensive testing and auditing, some corner cases were missed. A malicious PV guest administrator may be able to escalate their privilege to that of the host. All security-supported versions of Xen are vulnerable. Only x86 systems are affected. Arm systems are not affected. Only x86 PV guests can leverage the vulnerability. x86 HVM and PVH guests cannot leverage the vulnerability. Note that these attacks require very precise timing, which may be difficult to exploit in practice.",6.6,MEDIUM,1,valid,2019-10-31T11:17:38Z,3
CVE-2019-18609,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,alanxz/rabbitmq-c,"lib: check frame_size is >= INT32_MAX

When parsing a frame header, validate that the frame_size is less than
or equal to INT32_MAX. Given frame_max is limited between 0 and
INT32_MAX in amqp_login and friends, this does not change the API.

This prevents a potential buffer overflow when a malicious client sends
a frame_size that is close to UINT32_MAX, in which causes an overflow
when computing state->target_size resulting in a small value there. A
buffer is then allocated with the small amount, then memcopy copies the
frame_size writing to memory beyond the end of the buffer.",fc85be7123050b91b054e45b91c78d3241a5047a,https://github.com/alanxz/rabbitmq-c/commit/fc85be7123050b91b054e45b91c78d3241a5047a,librabbitmq/amqp_connection.c,amqp_handle_input,"int amqp_handle_input(amqp_connection_state_t state, amqp_bytes_t received_data,
amqp_frame_t *decoded_frame) {
size_t bytes_consumed;
void *raw_frame;
decoded_frame->frame_type = 0;
if (received_data.len == 0) {
return AMQP_STATUS_OK;
}
if (state->state == CONNECTION_STATE_IDLE) {
state->state = CONNECTION_STATE_HEADER;
}
bytes_consumed = consume_data(state, &received_data);
if (state->inbound_offset < state->target_size) {
return (int)bytes_consumed;
}
raw_frame = state->inbound_buffer.bytes;
switch (state->state) {
case CONNECTION_STATE_INITIAL:
if (memcmp(raw_frame, ""AMQP"", 4) == 0) {
decoded_frame->frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER;
decoded_frame->channel = 0;
decoded_frame->payload.protocol_header.transport_high =
amqp_d8(amqp_offset(raw_frame, 4));
decoded_frame->payload.protocol_header.transport_low =
amqp_d8(amqp_offset(raw_frame, 5));
decoded_frame->payload.protocol_header.protocol_version_major =
amqp_d8(amqp_offset(raw_frame, 6));
decoded_frame->payload.protocol_header.protocol_version_minor =
amqp_d8(amqp_offset(raw_frame, 7));
return_to_idle(state);
return (int)bytes_consumed;
}
case CONNECTION_STATE_HEADER: {
amqp_channel_t channel;
amqp_pool_t *channel_pool;
channel = amqp_d16(amqp_offset(raw_frame, 1));
state->target_size =
amqp_d32(amqp_offset(raw_frame, 3)) + HEADER_SIZE + FOOTER_SIZE;
if ((size_t)state->frame_max < state->target_size) {
return AMQP_STATUS_BAD_AMQP_DATA;
}
channel_pool = amqp_get_or_create_channel_pool(state, channel);
if (NULL == channel_pool) {
return AMQP_STATUS_NO_MEMORY;
}
amqp_pool_alloc_bytes(channel_pool, state->target_size,
&state->inbound_buffer);
if (NULL == state->inbound_buffer.bytes) {
return AMQP_STATUS_NO_MEMORY;
}
memcpy(state->inbound_buffer.bytes, state->header_buffer, HEADER_SIZE);
raw_frame = state->inbound_buffer.bytes;
state->state = CONNECTION_STATE_BODY;
bytes_consumed += consume_data(state, &received_data);
if (state->inbound_offset < state->target_size) {
return (int)bytes_consumed;
}
}
case CONNECTION_STATE_BODY: {
amqp_bytes_t encoded;
int res;
amqp_pool_t *channel_pool;
if (amqp_d8(amqp_offset(raw_frame, state->target_size - 1)) !=
AMQP_FRAME_END) {
return AMQP_STATUS_BAD_AMQP_DATA;
}
decoded_frame->frame_type = amqp_d8(amqp_offset(raw_frame, 0));
decoded_frame->channel = amqp_d16(amqp_offset(raw_frame, 1));
channel_pool =
amqp_get_or_create_channel_pool(state, decoded_frame->channel);
if (NULL == channel_pool) {
return AMQP_STATUS_NO_MEMORY;
}
switch (decoded_frame->frame_type) {
case AMQP_FRAME_METHOD:
decoded_frame->payload.method.id =
amqp_d32(amqp_offset(raw_frame, HEADER_SIZE));
encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 4);
encoded.len = state->target_size - HEADER_SIZE - 4 - FOOTER_SIZE;
res = amqp_decode_method(decoded_frame->payload.method.id,
channel_pool, encoded,
&decoded_frame->payload.method.decoded);
if (res < 0) {
return res;
}
break;
case AMQP_FRAME_HEADER:
decoded_frame->payload.properties.class_id =
amqp_d16(amqp_offset(raw_frame, HEADER_SIZE));
decoded_frame->payload.properties.body_size =
amqp_d64(amqp_offset(raw_frame, HEADER_SIZE + 4));
encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 12);
encoded.len = state->target_size - HEADER_SIZE - 12 - FOOTER_SIZE;
decoded_frame->payload.properties.raw = encoded;
res = amqp_decode_properties(
decoded_frame->payload.properties.class_id, channel_pool, encoded,
&decoded_frame->payload.properties.decoded);
if (res < 0) {
return res;
}
break;
case AMQP_FRAME_BODY:
decoded_frame->payload.body_fragment.len =
state->target_size - HEADER_SIZE - FOOTER_SIZE;
decoded_frame->payload.body_fragment.bytes =
amqp_offset(raw_frame, HEADER_SIZE);
break;
case AMQP_FRAME_HEARTBEAT:
break;
default:
decoded_frame->frame_type = 0;
break;
}
return_to_idle(state);
return (int)bytes_consumed;
}
default:
amqp_abort(""Internal error: invalid amqp_connection_state_t->state %d"",
state->state);
}
}","int amqp_handle_input(amqp_connection_state_t VAR_0, amqp_bytes_t VAR_1,
amqp_frame_t *VAR_2) {
size_t VAR_3;
void *VAR_4;
VAR_2->frame_type = 0;
if (VAR_1.len == 0) {
return VAR_5;
}
if (VAR_0->state == VAR_6) {
VAR_0->state = VAR_7;
}
VAR_3 = consume_data(VAR_0, &VAR_1);
if (VAR_0->inbound_offset < VAR_0->target_size) {
return (int)VAR_3;
}
VAR_4 = VAR_0->inbound_buffer.bytes;
switch (VAR_0->state) {
case VAR_8:
if (memcmp(VAR_4, ""AMQP"", 4) == 0) {
VAR_2->frame_type = VAR_9;
VAR_2->channel = 0;
VAR_2->payload.protocol_header.transport_high =
amqp_d8(amqp_offset(VAR_4, 4));
VAR_2->payload.protocol_header.transport_low =
amqp_d8(amqp_offset(VAR_4, 5));
VAR_2->payload.protocol_header.protocol_version_major =
amqp_d8(amqp_offset(VAR_4, 6));
VAR_2->payload.protocol_header.protocol_version_minor =
amqp_d8(amqp_offset(VAR_4, 7));
return_to_idle(VAR_0);
return (int)VAR_3;
}
case VAR_7: {
amqp_channel_t VAR_10;
amqp_pool_t *VAR_11;
VAR_10 = amqp_d16(amqp_offset(VAR_4, 1));
VAR_0->target_size =
amqp_d32(amqp_offset(VAR_4, 3)) + VAR_12 + VAR_13;
if ((size_t)VAR_0->frame_max < VAR_0->target_size) {
return VAR_14;
}
VAR_11 = amqp_get_or_create_channel_pool(VAR_0, VAR_10);
if (NULL == VAR_11) {
return VAR_15;
}
amqp_pool_alloc_bytes(VAR_11, VAR_0->target_size,
&VAR_0->inbound_buffer);
if (NULL == VAR_0->inbound_buffer.bytes) {
return VAR_15;
}
memcpy(VAR_0->inbound_buffer.bytes, VAR_0->header_buffer, VAR_12);
VAR_4 = VAR_0->inbound_buffer.bytes;
VAR_0->state = VAR_16;
VAR_3 += consume_data(VAR_0, &VAR_1);
if (VAR_0->inbound_offset < VAR_0->target_size) {
return (int)VAR_3;
}
}
case VAR_16: {
amqp_bytes_t VAR_17;
int VAR_18;
amqp_pool_t *VAR_11;
if (amqp_d8(amqp_offset(VAR_4, VAR_0->target_size - 1)) !=
VAR_19) {
return VAR_14;
}
VAR_2->frame_type = amqp_d8(amqp_offset(VAR_4, 0));
VAR_2->channel = amqp_d16(amqp_offset(VAR_4, 1));
VAR_11 =
amqp_get_or_create_channel_pool(VAR_0, VAR_2->channel);
if (NULL == VAR_11) {
return VAR_15;
}
switch (VAR_2->frame_type) {
case VAR_20:
VAR_2->payload.method.id =
amqp_d32(amqp_offset(VAR_4, VAR_12));
VAR_17.bytes = amqp_offset(VAR_4, VAR_12 + 4);
VAR_17.len = VAR_0->target_size - VAR_12 - 4 - VAR_13;
VAR_18 = amqp_decode_method(VAR_2->payload.method.id,
VAR_11, VAR_17,
&VAR_2->payload.method.decoded);
if (VAR_18 < 0) {
return VAR_18;
}
break;
case VAR_21:
VAR_2->payload.properties.class_id =
amqp_d16(amqp_offset(VAR_4, VAR_12));
VAR_2->payload.properties.body_size =
amqp_d64(amqp_offset(VAR_4, VAR_12 + 4));
VAR_17.bytes = amqp_offset(VAR_4, VAR_12 + 12);
VAR_17.len = VAR_0->target_size - VAR_12 - 12 - VAR_13;
VAR_2->payload.properties.raw = VAR_17;
VAR_18 = amqp_decode_properties(
VAR_2->payload.properties.class_id, VAR_11, VAR_17,
&VAR_2->payload.properties.decoded);
if (VAR_18 < 0) {
return VAR_18;
}
break;
case VAR_22:
VAR_2->payload.body_fragment.len =
VAR_0->target_size - VAR_12 - VAR_13;
VAR_2->payload.body_fragment.bytes =
amqp_offset(VAR_4, VAR_12);
break;
case VAR_23:
break;
default:
VAR_2->frame_type = 0;
break;
}
return_to_idle(VAR_0);
return (int)VAR_3;
}
default:
amqp_abort(""Internal error: invalid amqp_connection_state_t->state %d"",
VAR_0->state);
}
}",alanxz/rabbitmq-c/fc85be7123050b91b054e45b91c78d3241a5047a/amqp_connection.c/vul/before/0.json,"int amqp_handle_input(amqp_connection_state_t state, amqp_bytes_t received_data,
                      amqp_frame_t *decoded_frame) {
  size_t bytes_consumed;
  void *raw_frame;

  /* Returning frame_type of zero indicates either insufficient input,
     or a complete, ignored frame was read. */
  decoded_frame->frame_type = 0;

  if (received_data.len == 0) {
    return AMQP_STATUS_OK;
  }

  if (state->state == CONNECTION_STATE_IDLE) {
    state->state = CONNECTION_STATE_HEADER;
  }

  bytes_consumed = consume_data(state, &received_data);

  /* do we have target_size data yet? if not, return with the
     expectation that more will arrive */
  if (state->inbound_offset < state->target_size) {
    return (int)bytes_consumed;
  }

  raw_frame = state->inbound_buffer.bytes;

  switch (state->state) {
    case CONNECTION_STATE_INITIAL:
      /* check for a protocol header from the server */
      if (memcmp(raw_frame, ""AMQP"", 4) == 0) {
        decoded_frame->frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER;
        decoded_frame->channel = 0;

        decoded_frame->payload.protocol_header.transport_high =
            amqp_d8(amqp_offset(raw_frame, 4));
        decoded_frame->payload.protocol_header.transport_low =
            amqp_d8(amqp_offset(raw_frame, 5));
        decoded_frame->payload.protocol_header.protocol_version_major =
            amqp_d8(amqp_offset(raw_frame, 6));
        decoded_frame->payload.protocol_header.protocol_version_minor =
            amqp_d8(amqp_offset(raw_frame, 7));

        return_to_idle(state);
        return (int)bytes_consumed;
      }

    /* it's not a protocol header; fall through to process it as a
       regular frame header */

    case CONNECTION_STATE_HEADER: {
      amqp_channel_t channel;
      amqp_pool_t *channel_pool;
      uint32_t frame_size;

      channel = amqp_d16(amqp_offset(raw_frame, 1));

      /* frame length is 3 bytes in */
      frame_size = amqp_d32(amqp_offset(raw_frame, 3));
      /* To prevent the target_size calculation below from overflowing, check
       * that the stated frame_size is smaller than a signed 32-bit. Given
       * the library only allows configuring frame_max as an int32_t, and
       * frame_size is uint32_t, the math below is safe from overflow. */
      if (frame_size >= INT32_MAX) {
        return AMQP_STATUS_BAD_AMQP_DATA;
      }

      state->target_size = frame_size + HEADER_SIZE + FOOTER_SIZE;
      if ((size_t)state->frame_max < state->target_size) {
        return AMQP_STATUS_BAD_AMQP_DATA;
      }

      channel_pool = amqp_get_or_create_channel_pool(state, channel);
      if (NULL == channel_pool) {
        return AMQP_STATUS_NO_MEMORY;
      }

      amqp_pool_alloc_bytes(channel_pool, state->target_size,
                            &state->inbound_buffer);
      if (NULL == state->inbound_buffer.bytes) {
        return AMQP_STATUS_NO_MEMORY;
      }
      memcpy(state->inbound_buffer.bytes, state->header_buffer, HEADER_SIZE);
      raw_frame = state->inbound_buffer.bytes;

      state->state = CONNECTION_STATE_BODY;

      bytes_consumed += consume_data(state, &received_data);

      /* do we have target_size data yet? if not, return with the
         expectation that more will arrive */
      if (state->inbound_offset < state->target_size) {
        return (int)bytes_consumed;
      }
    }
    /* fall through to process body */

    case CONNECTION_STATE_BODY: {
      amqp_bytes_t encoded;
      int res;
      amqp_pool_t *channel_pool;

      /* Check frame end marker (footer) */
      if (amqp_d8(amqp_offset(raw_frame, state->target_size - 1)) !=
          AMQP_FRAME_END) {
        return AMQP_STATUS_BAD_AMQP_DATA;
      }

      decoded_frame->frame_type = amqp_d8(amqp_offset(raw_frame, 0));
      decoded_frame->channel = amqp_d16(amqp_offset(raw_frame, 1));

      channel_pool =
          amqp_get_or_create_channel_pool(state, decoded_frame->channel);
      if (NULL == channel_pool) {
        return AMQP_STATUS_NO_MEMORY;
      }

      switch (decoded_frame->frame_type) {
        case AMQP_FRAME_METHOD:
          decoded_frame->payload.method.id =
              amqp_d32(amqp_offset(raw_frame, HEADER_SIZE));
          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 4);
          encoded.len = state->target_size - HEADER_SIZE - 4 - FOOTER_SIZE;

          res = amqp_decode_method(decoded_frame->payload.method.id,
                                   channel_pool, encoded,
                                   &decoded_frame->payload.method.decoded);
          if (res < 0) {
            return res;
          }

          break;

        case AMQP_FRAME_HEADER:
          decoded_frame->payload.properties.class_id =
              amqp_d16(amqp_offset(raw_frame, HEADER_SIZE));
          /* unused 2-byte weight field goes here */
          decoded_frame->payload.properties.body_size =
              amqp_d64(amqp_offset(raw_frame, HEADER_SIZE + 4));
          encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 12);
          encoded.len = state->target_size - HEADER_SIZE - 12 - FOOTER_SIZE;
          decoded_frame->payload.properties.raw = encoded;

          res = amqp_decode_properties(
              decoded_frame->payload.properties.class_id, channel_pool, encoded,
              &decoded_frame->payload.properties.decoded);
          if (res < 0) {
            return res;
          }

          break;

        case AMQP_FRAME_BODY:
          decoded_frame->payload.body_fragment.len =
              state->target_size - HEADER_SIZE - FOOTER_SIZE;
          decoded_frame->payload.body_fragment.bytes =
              amqp_offset(raw_frame, HEADER_SIZE);
          break;

        case AMQP_FRAME_HEARTBEAT:
          break;

        default:
          /* Ignore the frame */
          decoded_frame->frame_type = 0;
          break;
      }

      return_to_idle(state);
      return (int)bytes_consumed;
    }

    default:
      amqp_abort(""Internal error: invalid amqp_connection_state_t->state %d"",
                 state->state);
  }
}","int amqp_handle_input(amqp_connection_state_t VAR_0, amqp_bytes_t VAR_1,
                      amqp_frame_t *VAR_2) {
  size_t VAR_3;
  void *VAR_4;

  /* COMMENT_0 */
                                              
  VAR_2->frame_type = 0;

  if (VAR_1.len == 0) {
    return VAR_5;
  }

  if (VAR_0->state == VAR_6) {
    VAR_0->state = VAR_7;
  }

  VAR_3 = consume_data(VAR_0, &VAR_1);

  /* COMMENT_2 */
                                         
  if (VAR_0->inbound_offset < VAR_0->target_size) {
    return (int)VAR_3;
  }

  VAR_4 = VAR_0->inbound_buffer.bytes;

  switch (VAR_0->state) {
    case VAR_8:
      /* COMMENT_4 */
      if (memcmp(VAR_4, ""AMQP"", 4) == 0) {
        VAR_2->frame_type = VAR_9;
        VAR_2->channel = 0;

        VAR_2->payload.protocol_header.transport_high =
            amqp_d8(amqp_offset(VAR_4, 4));
        VAR_2->payload.protocol_header.transport_low =
            amqp_d8(amqp_offset(VAR_4, 5));
        VAR_2->payload.protocol_header.protocol_version_major =
            amqp_d8(amqp_offset(VAR_4, 6));
        VAR_2->payload.protocol_header.protocol_version_minor =
            amqp_d8(amqp_offset(VAR_4, 7));

        return_to_idle(VAR_0);
        return (int)VAR_3;
      }

    /* COMMENT_5 */
                              

    case VAR_7: {
      amqp_channel_t VAR_10;
      amqp_pool_t *VAR_11;
      uint32_t VAR_12;

      VAR_10 = amqp_d16(amqp_offset(VAR_4, 1));

      /* COMMENT_7 */
      VAR_12 = amqp_d32(amqp_offset(VAR_4, 3));
      /* COMMENT_8 */
                                                                          
                                                                         
                                                                         
      if (VAR_12 >= VAR_13) {
        return VAR_14;
      }

      VAR_0->target_size = VAR_12 + VAR_15 + VAR_16;
      if ((size_t)VAR_0->frame_max < VAR_0->target_size) {
        return VAR_14;
      }

      VAR_11 = amqp_get_or_create_channel_pool(VAR_0, VAR_10);
      if (NULL == VAR_11) {
        return VAR_17;
      }

      amqp_pool_alloc_bytes(VAR_11, VAR_0->target_size,
                            &VAR_0->inbound_buffer);
      if (NULL == VAR_0->inbound_buffer.bytes) {
        return VAR_17;
      }
      memcpy(VAR_0->inbound_buffer.bytes, VAR_0->header_buffer, VAR_15);
      VAR_4 = VAR_0->inbound_buffer.bytes;

      VAR_0->state = VAR_18;

      VAR_3 += consume_data(VAR_0, &VAR_1);

      /* COMMENT_12 */
                                             
      if (VAR_0->inbound_offset < VAR_0->target_size) {
        return (int)VAR_3;
      }
    }
    /* COMMENT_14 */

    case VAR_18: {
      amqp_bytes_t VAR_19;
      int VAR_20;
      amqp_pool_t *VAR_11;

      /* COMMENT_15 */
      if (amqp_d8(amqp_offset(VAR_4, VAR_0->target_size - 1)) !=
          VAR_21) {
        return VAR_14;
      }

      VAR_2->frame_type = amqp_d8(amqp_offset(VAR_4, 0));
      VAR_2->channel = amqp_d16(amqp_offset(VAR_4, 1));

      VAR_11 =
          amqp_get_or_create_channel_pool(VAR_0, VAR_2->channel);
      if (NULL == VAR_11) {
        return VAR_17;
      }

      switch (VAR_2->frame_type) {
        case VAR_22:
          VAR_2->payload.method.id =
              amqp_d32(amqp_offset(VAR_4, VAR_15));
          VAR_19.bytes = amqp_offset(VAR_4, VAR_15 + 4);
          VAR_19.len = VAR_0->target_size - VAR_15 - 4 - VAR_16;

          VAR_20 = amqp_decode_method(VAR_2->payload.method.id,
                                   VAR_11, VAR_19,
                                   &VAR_2->payload.method.decoded);
          if (VAR_20 < 0) {
            return VAR_20;
          }

          break;

        case VAR_23:
          VAR_2->payload.properties.class_id =
              amqp_d16(amqp_offset(VAR_4, VAR_15));
          /* COMMENT_16 */
          VAR_2->payload.properties.body_size =
              amqp_d64(amqp_offset(VAR_4, VAR_15 + 4));
          VAR_19.bytes = amqp_offset(VAR_4, VAR_15 + 12);
          VAR_19.len = VAR_0->target_size - VAR_15 - 12 - VAR_16;
          VAR_2->payload.properties.raw = VAR_19;

          VAR_20 = amqp_decode_properties(
              VAR_2->payload.properties.class_id, VAR_11, VAR_19,
              &VAR_2->payload.properties.decoded);
          if (VAR_20 < 0) {
            return VAR_20;
          }

          break;

        case VAR_24:
          VAR_2->payload.body_fragment.len =
              VAR_0->target_size - VAR_15 - VAR_16;
          VAR_2->payload.body_fragment.bytes =
              amqp_offset(VAR_4, VAR_15);
          break;

        case VAR_25:
          break;

        default:
          /* COMMENT_17 */
          VAR_2->frame_type = 0;
          break;
      }

      return_to_idle(VAR_0);
      return (int)VAR_3;
    }

    default:
      amqp_abort(""Internal error: invalid amqp_connection_state_t->state %d"",
                 VAR_0->state);
  }
}",alanxz/rabbitmq-c/fc85be7123050b91b054e45b91c78d3241a5047a/amqp_connection.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -51,12 +51,21 @@
     case CONNECTION_STATE_HEADER: {
       amqp_channel_t channel;
       amqp_pool_t *channel_pool;
-      /* frame length is 3 bytes in */
+      uint32_t frame_size;
+
       channel = amqp_d16(amqp_offset(raw_frame, 1));
 
-      state->target_size =
-          amqp_d32(amqp_offset(raw_frame, 3)) + HEADER_SIZE + FOOTER_SIZE;
+      /* frame length is 3 bytes in */
+      frame_size = amqp_d32(amqp_offset(raw_frame, 3));
+      /* To prevent the target_size calculation below from overflowing, check
+       * that the stated frame_size is smaller than a signed 32-bit. Given
+       * the library only allows configuring frame_max as an int32_t, and
+       * frame_size is uint32_t, the math below is safe from overflow. */
+      if (frame_size >= INT32_MAX) {
+        return AMQP_STATUS_BAD_AMQP_DATA;
+      }
 
+      state->target_size = frame_size + HEADER_SIZE + FOOTER_SIZE;
       if ((size_t)state->frame_max < state->target_size) {
         return AMQP_STATUS_BAD_AMQP_DATA;
       }","{'deleted_lines': ['      /* frame length is 3 bytes in */', '      state->target_size =', '          amqp_d32(amqp_offset(raw_frame, 3)) + HEADER_SIZE + FOOTER_SIZE;'], 'added_lines': ['      uint32_t frame_size;', '', '      /* frame length is 3 bytes in */', '      frame_size = amqp_d32(amqp_offset(raw_frame, 3));', '      /* To prevent the target_size calculation below from overflowing, check', '       * that the stated frame_size is smaller than a signed 32-bit. Given', '       * the library only allows configuring frame_max as an int32_t, and', '       * frame_size is uint32_t, the math below is safe from overflow. */', '      if (frame_size >= INT32_MAX) {', '        return AMQP_STATUS_BAD_AMQP_DATA;', '      }', '      state->target_size = frame_size + HEADER_SIZE + FOOTER_SIZE;']}",True,An issue was discovered in amqp_handle_input in amqp_connection.c in rabbitmq-c 0.9.0. There is an integer overflow that leads to heap memory corruption in the handling of CONNECTION_STATE_HEADER. A rogue server could return a malicious frame header that leads to a smaller target_size value than needed. This condition is then carried on to a memcpy function that copies too much data into a heap buffer.,9.8,CRITICAL,3,valid,2019-11-04T07:50:07Z,3
CVE-2020-21710,['CWE-369'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,ArtifexSoftware/ghostpdl,"Bug 701843: avoid divide by zero in devices/gdevepsc.c:epsc_print_page().

Fixes:
    ./sanbin/gs -dBATCH -dNOPAUSE -dSAFER -r8 -dNOCIE -dFitPage -sOutputFile=tmp -sDEVICE=epsonc  ../bug-701843.pdf",4e713293de84b689c4ab358f3e110ea54aa81925,https://github.com/ArtifexSoftware/ghostpdl/commit/4e713293de84b689c4ab358f3e110ea54aa81925,devices/gdevepsc.c,epsc_print_page,"static int
epsc_print_page(gx_device_printer * pdev, gp_file * prn_stream)
{
static int graphics_modes_9[5] = { -1, 0  , 1  , -1, DD + 3  
};
static int graphics_modes_24[7] =
{ -1, 32  , 33  , 39  ,
-1, -1, DD + 40         
};
int y_24pin = pdev->y_pixels_per_inch > 72;
int y_mult = (y_24pin ? 3 : 1);
int line_size = (pdev->width + 7) >> 3;     
int in_size = line_size * (8 * y_mult);
int out_size = ((pdev->width + 7) & -8) * y_mult;
byte *in;
byte *out;
int x_dpi = (int)pdev->x_pixels_per_inch;
char start_graphics;
int first_pass;
int last_pass;
int dots_per_space; 
int bytes_per_space;
int skip = 0, lnum = 0, pass;
byte *color_in;
int color_line_size, color_in_size;
int spare_bits;
int whole_bits;
int max_dpi = 60 * (
(y_24pin) ?
sizeof(graphics_modes_24) / sizeof(graphics_modes_24[0])
:
sizeof(graphics_modes_9) / sizeof(graphics_modes_9[0])
)
- 1;
if (x_dpi > max_dpi) {
return_error(gs_error_rangecheck);
}
in =
(byte *) gs_malloc(pdev->memory, in_size + 1, 1,
""epsc_print_page(in)"");
out =
(byte *) gs_malloc(pdev->memory, out_size + 1, 1,
""epsc_print_page(out)"");
start_graphics = (char)
((y_24pin ? graphics_modes_24 : graphics_modes_9)[x_dpi / 60]);
first_pass = (start_graphics & DD ? 1 : 0);
last_pass = first_pass * 2;
dots_per_space = x_dpi / 10;    
bytes_per_space = dots_per_space * y_mult;
spare_bits = (pdev->width % 8); 
whole_bits = pdev->width - spare_bits;
if (in == 0 || out == 0) {
if (in)
gs_free(pdev->memory, (char *)in, in_size + 1, 1,
""epsc_print_page(in)"");
if (out)
gs_free(pdev->memory, (char *)out, out_size + 1, 1,
""epsc_print_page(out)"");
return -1;
}
gp_fwrite(""\033@\033P\033l\000\033Q\377\033U\001\r"", 1, 14, prn_stream);
if (gx_device_has_color(pdev)) {
color_line_size = gdev_mem_bytes_per_scan_line((gx_device *) pdev);
color_in_size = color_line_size * (8 * y_mult);
if ((color_in = (byte *) gs_malloc(pdev->memory, color_in_size + 1, 1,
""epsc_print_page(color)"")) == 0) {
gs_free(pdev->memory, (char *)in, in_size + 1, 1,
""epsc_print_page(in)"");
gs_free(pdev->memory, (char *)out, out_size + 1, 1,
""epsc_print_page(out)"");
return (-1);
}
} else {
color_in = in;
color_in_size = in_size;
color_line_size = line_size;
}
while (lnum < pdev->height) {
int lcnt;
byte *nextcolor = NULL; 
byte *nextmono = NULL;  
gdev_prn_copy_scan_lines(pdev, lnum, color_in, color_line_size);
if (color_in[0] == 0 &&
!memcmp((char *)color_in, (char *)color_in + 1,
color_line_size - 1)
) {
lnum++;
skip += 3 / y_mult;
continue;
}
while (skip > 255) {
gp_fputs(""\033J\377"", prn_stream);
skip -= 255;
}
if (skip)
gp_fprintf(prn_stream, ""\033J%c"", skip);
lcnt = 1 + gdev_prn_copy_scan_lines(pdev, lnum + 1,
color_in + color_line_size,
color_in_size - color_line_size);
if (lcnt < 8 * y_mult) {
memset((char *)(color_in + lcnt * color_line_size), 0,
color_in_size - lcnt * color_line_size);
if (gx_device_has_color(pdev))      
memset((char *)(in + lcnt * line_size), 0,
in_size - lcnt * line_size);
}
do {
byte *inp = in;
byte *in_end = in + line_size;
byte *out_end = out;
byte *out_blk;
register byte *outp;
if (gx_device_has_color(pdev)) {
register int i, j;
register byte *outbuf, *realbuf;
byte current_color;
int end_next_bits = whole_bits;
int lastbits;
if (nextcolor) {
realbuf = nextcolor;
outbuf = nextmono;
memset((char *)in, 0, (nextmono - in));
i = nextcolor - color_in;
nextcolor = NULL;
end_next_bits = (i / color_line_size) * color_line_size
+ whole_bits;
} else {
i = 0;
realbuf = color_in;
outbuf = in;
nextcolor = NULL;
}
for (current_color = 0; i <= color_in_size && outbuf < in + in_size; outbuf++) {
if (spare_bits && i == end_next_bits) {
end_next_bits = whole_bits + i + spare_bits;
lastbits = 8 - spare_bits;
} else
lastbits = 0;
for (*outbuf = 0, j = 8;
--j >= lastbits && i <= color_in_size;
realbuf++, i++) {
if (*realbuf) {
if (current_color > 0) {
if (*realbuf == current_color) {
*outbuf |= 1 << j;
*realbuf = 0;       
}
else if (nextcolor == NULL) {
nextcolor = realbuf - (7 - j);
nextmono = outbuf;
}
} else {
*outbuf |= 1 << j;
current_color = *realbuf;       
*realbuf = 0;
}
}
}
}
*outbuf = 0;    
if (current_color)
gp_fprintf(prn_stream, ""\033r%c"", current_color ^ 7);
}
if (y_24pin) {
for (; inp < in_end; inp++, out_end += 24) {
gdev_prn_transpose_8x8(inp, line_size, out_end, 3);
gdev_prn_transpose_8x8(inp + line_size * 8, line_size,
out_end + 1, 3);
gdev_prn_transpose_8x8(inp + line_size * 16, line_size,
out_end + 2, 3);
}
while (out_end > out && out_end[-1] == 0 &&
out_end[-2] == 0 && out_end[-3] == 0)
out_end -= 3;
} else {
for (; inp < in_end; inp++, out_end += 8) {
gdev_prn_transpose_8x8(inp, line_size, out_end, 1);
}
while (out_end > out && out_end[-1] == 0)
out_end--;
}
for (pass = first_pass; pass <= last_pass; pass++) {
for (out_blk = outp = out; outp < out_end;) {   
if (*outp == 0 && outp + 12 <= out_end &&
outp[1] == 0 && outp[2] == 0 &&
(outp[3] | outp[4] | outp[5]) == 0 &&
(outp[6] | outp[7] | outp[8]) == 0 &&
(outp[9] | outp[10] | outp[11]) == 0) {
byte *zp = outp;
int tpos;
byte *newp;
outp += 12;
while (outp + 3 <= out_end && *outp == 0 &&
outp[1] == 0 && outp[2] == 0)
outp += 3;
tpos = (outp - out) / bytes_per_space;
newp = out + tpos * bytes_per_space;
if (newp > zp + 10) {   
if (zp > out_blk)
epsc_output_run(out_blk, (int)(zp - out_blk),
y_mult, start_graphics,
prn_stream, pass);
gp_fprintf(prn_stream, ""\033D%c%c\t"", tpos, 0);
out_blk = outp = newp;
}
} else
outp += y_mult;
}
if (outp > out_blk)
epsc_output_run(out_blk, (int)(outp - out_blk),
y_mult, start_graphics, prn_stream, pass);
gp_fputc('\r', prn_stream);
}
} while (nextcolor);
skip = 24;
lnum += 8 * y_mult;
}
gp_fputs(""\f\033@"", prn_stream);
gs_free(pdev->memory, (char *)out, out_size + 1, 1,
""epsc_print_page(out)"");
gs_free(pdev->memory, (char *)in, in_size + 1, 1, ""epsc_print_page(in)"");
if (gx_device_has_color(pdev))
gs_free(pdev->memory, (char *)color_in, color_in_size + 1, 1,
""epsc_print_page(rin)"");
return 0;
}","static int
epsc_print_page(gx_device_printer * VAR_0, gp_file * VAR_1)
{
static int VAR_2[5] = { -1, 0  , 1  , -1, VAR_3 + 3  
};
static int VAR_4[7] =
{ -1, 32  , 33  , 39  ,
-1, -1, VAR_3 + 40         
};
int VAR_5 = VAR_0->y_pixels_per_inch > 72;
int VAR_6 = (VAR_5 ? 3 : 1);
int VAR_7 = (VAR_0->width + 7) >> 3;     
int VAR_8 = VAR_7 * (8 * VAR_6);
int VAR_9 = ((VAR_0->width + 7) & -8) * VAR_6;
byte *VAR_10;
byte *VAR_11;
int VAR_12 = (int)VAR_0->x_pixels_per_inch;
char VAR_13;
int VAR_14;
int VAR_15;
int VAR_16; 
int VAR_17;
int VAR_18 = 0, VAR_19 = 0, VAR_20;
byte *VAR_21;
int VAR_22, VAR_23;
int VAR_24;
int VAR_25;
int VAR_26 = 60 * (
(VAR_5) ?
sizeof(graphics_modes_24) / sizeof(graphics_modes_24[0])
:
sizeof(graphics_modes_9) / sizeof(graphics_modes_9[0])
)
- 1;
if (VAR_12 > VAR_26) {
return_error(VAR_27);
}
VAR_10 =
(byte *) gs_malloc(VAR_0->memory, VAR_8 + 1, 1,
""epsc_print_page(in)"");
VAR_11 =
(byte *) gs_malloc(VAR_0->memory, VAR_9 + 1, 1,
""epsc_print_page(out)"");
VAR_13 = (char)
((VAR_5 ? graphics_modes_24 : graphics_modes_9)[VAR_12 / 60]);
VAR_14 = (VAR_13 & VAR_3 ? 1 : 0);
VAR_15 = VAR_14 * 2;
VAR_16 = VAR_12 / 10;    
VAR_17 = VAR_16 * VAR_6;
VAR_24 = (VAR_0->width % 8); 
VAR_25 = VAR_0->width - VAR_24;
if (VAR_10 == 0 || VAR_11 == 0) {
if (VAR_10)
gs_free(VAR_0->memory, (char *)VAR_10, VAR_8 + 1, 1,
""epsc_print_page(in)"");
if (VAR_11)
gs_free(VAR_0->memory, (char *)VAR_11, VAR_9 + 1, 1,
""epsc_print_page(out)"");
return -1;
}
gp_fwrite(""\033@\033P\033l\000\033Q\377\033U\001\r"", 1, 14, VAR_1);
if (gx_device_has_color(VAR_0)) {
VAR_22 = gdev_mem_bytes_per_scan_line((gx_device *) VAR_0);
VAR_23 = VAR_22 * (8 * VAR_6);
if ((VAR_21 = (byte *) gs_malloc(VAR_0->memory, VAR_23 + 1, 1,
""epsc_print_page(color)"")) == 0) {
gs_free(VAR_0->memory, (char *)VAR_10, VAR_8 + 1, 1,
""epsc_print_page(in)"");
gs_free(VAR_0->memory, (char *)VAR_11, VAR_9 + 1, 1,
""epsc_print_page(out)"");
return (-1);
}
} else {
VAR_21 = VAR_10;
VAR_23 = VAR_8;
VAR_22 = VAR_7;
}
while (VAR_19 < VAR_0->height) {
int VAR_28;
byte *VAR_29 = NULL; 
byte *VAR_30 = NULL;  
gdev_prn_copy_scan_lines(VAR_0, VAR_19, VAR_21, VAR_22);
if (VAR_21[0] == 0 &&
!memcmp((char *)VAR_21, (char *)VAR_21 + 1,
VAR_22 - 1)
) {
VAR_19++;
VAR_18 += 3 / VAR_6;
continue;
}
while (VAR_18 > 255) {
gp_fputs(""\033J\377"", VAR_1);
VAR_18 -= 255;
}
if (VAR_18)
gp_fprintf(VAR_1, ""\033J%c"", VAR_18);
VAR_28 = 1 + gdev_prn_copy_scan_lines(VAR_0, VAR_19 + 1,
VAR_21 + VAR_22,
VAR_23 - VAR_22);
if (VAR_28 < 8 * VAR_6) {
memset((char *)(VAR_21 + VAR_28 * VAR_22), 0,
VAR_23 - VAR_28 * VAR_22);
if (gx_device_has_color(VAR_0))      
memset((char *)(VAR_10 + VAR_28 * VAR_7), 0,
VAR_8 - VAR_28 * VAR_7);
}
do {
byte *VAR_31 = VAR_10;
byte *VAR_32 = VAR_10 + VAR_7;
byte *VAR_33 = VAR_11;
byte *VAR_34;
register byte *VAR_35;
if (gx_device_has_color(VAR_0)) {
register int VAR_36, VAR_37;
register byte *VAR_38, *VAR_39;
byte VAR_40;
int VAR_41 = VAR_25;
int VAR_42;
if (VAR_29) {
VAR_39 = VAR_29;
VAR_38 = VAR_30;
memset((char *)VAR_10, 0, (VAR_30 - VAR_10));
VAR_36 = VAR_29 - VAR_21;
VAR_29 = NULL;
VAR_41 = (VAR_36 / VAR_22) * VAR_22
+ VAR_25;
} else {
VAR_36 = 0;
VAR_39 = VAR_21;
VAR_38 = VAR_10;
VAR_29 = NULL;
}
for (VAR_40 = 0; VAR_36 <= VAR_23 && VAR_38 < VAR_10 + VAR_8; VAR_38++) {
if (VAR_24 && VAR_36 == VAR_41) {
VAR_41 = VAR_25 + VAR_36 + VAR_24;
VAR_42 = 8 - VAR_24;
} else
VAR_42 = 0;
for (*VAR_38 = 0, VAR_37 = 8;
--VAR_37 >= VAR_42 && VAR_36 <= VAR_23;
VAR_39++, VAR_36++) {
if (*VAR_39) {
if (VAR_40 > 0) {
if (*VAR_39 == VAR_40) {
*VAR_38 |= 1 << VAR_37;
*VAR_39 = 0;       
}
else if (VAR_29 == NULL) {
VAR_29 = VAR_39 - (7 - VAR_37);
VAR_30 = VAR_38;
}
} else {
*VAR_38 |= 1 << VAR_37;
VAR_40 = *VAR_39;       
*VAR_39 = 0;
}
}
}
}
*VAR_38 = 0;    
if (VAR_40)
gp_fprintf(VAR_1, ""\033r%c"", VAR_40 ^ 7);
}
if (VAR_5) {
for (; VAR_31 < VAR_32; VAR_31++, VAR_33 += 24) {
gdev_prn_transpose_8x8(VAR_31, VAR_7, VAR_33, 3);
gdev_prn_transpose_8x8(VAR_31 + VAR_7 * 8, VAR_7,
VAR_33 + 1, 3);
gdev_prn_transpose_8x8(VAR_31 + VAR_7 * 16, VAR_7,
VAR_33 + 2, 3);
}
while (VAR_33 > VAR_11 && VAR_33[-1] == 0 &&
VAR_33[-2] == 0 && VAR_33[-3] == 0)
VAR_33 -= 3;
} else {
for (; VAR_31 < VAR_32; VAR_31++, VAR_33 += 8) {
gdev_prn_transpose_8x8(VAR_31, VAR_7, VAR_33, 1);
}
while (VAR_33 > VAR_11 && VAR_33[-1] == 0)
VAR_33--;
}
for (VAR_20 = VAR_14; VAR_20 <= VAR_15; VAR_20++) {
for (VAR_34 = VAR_35 = VAR_11; VAR_35 < VAR_33;) {   
if (*VAR_35 == 0 && VAR_35 + 12 <= VAR_33 &&
VAR_35[1] == 0 && VAR_35[2] == 0 &&
(VAR_35[3] | VAR_35[4] | VAR_35[5]) == 0 &&
(VAR_35[6] | VAR_35[7] | VAR_35[8]) == 0 &&
(VAR_35[9] | VAR_35[10] | VAR_35[11]) == 0) {
byte *VAR_43 = VAR_35;
int VAR_44;
byte *VAR_45;
VAR_35 += 12;
while (VAR_35 + 3 <= VAR_33 && *VAR_35 == 0 &&
VAR_35[1] == 0 && VAR_35[2] == 0)
VAR_35 += 3;
VAR_44 = (VAR_35 - VAR_11) / VAR_17;
VAR_45 = VAR_11 + VAR_44 * VAR_17;
if (VAR_45 > VAR_43 + 10) {   
if (VAR_43 > VAR_34)
epsc_output_run(VAR_34, (int)(VAR_43 - VAR_34),
VAR_6, VAR_13,
VAR_1, VAR_20);
gp_fprintf(VAR_1, ""\033D%c%c\t"", VAR_44, 0);
VAR_34 = VAR_35 = VAR_45;
}
} else
VAR_35 += VAR_6;
}
if (VAR_35 > VAR_34)
epsc_output_run(VAR_34, (int)(VAR_35 - VAR_34),
VAR_6, VAR_13, VAR_1, VAR_20);
gp_fputc('\r', VAR_1);
}
} while (VAR_29);
VAR_18 = 24;
VAR_19 += 8 * VAR_6;
}
gp_fputs(""\f\033@"", VAR_1);
gs_free(VAR_0->memory, (char *)VAR_11, VAR_9 + 1, 1,
""epsc_print_page(out)"");
gs_free(VAR_0->memory, (char *)VAR_10, VAR_8 + 1, 1, ""epsc_print_page(in)"");
if (gx_device_has_color(VAR_0))
gs_free(VAR_0->memory, (char *)VAR_21, VAR_23 + 1, 1,
""epsc_print_page(rin)"");
return 0;
}",ArtifexSoftware/ghostpdl/4e713293de84b689c4ab358f3e110ea54aa81925/gdevepsc.c/vul/before/0.json,"static int
epsc_print_page(gx_device_printer * pdev, gp_file * prn_stream)
{
    static int graphics_modes_9[5] = { -1, 0 /*60 */ , 1 /*120 */ , -1, DD + 3  /*240 */
    };
    static int graphics_modes_24[7] =
        { -1, 32 /*60 */ , 33 /*120 */ , 39 /*180 */ ,
        -1, -1, DD + 40         /*360 */
    };
    int y_24pin = pdev->y_pixels_per_inch > 72;
    int y_mult = (y_24pin ? 3 : 1);
    int line_size = (pdev->width + 7) >> 3;     /* always mono */
    int in_size = line_size * (8 * y_mult);
    int out_size = ((pdev->width + 7) & -8) * y_mult;
    byte *in;
    byte *out;
    int x_dpi = (int)pdev->x_pixels_per_inch;

    char start_graphics;
    int first_pass;
    int last_pass;
    int dots_per_space; 
    int bytes_per_space;
    int skip = 0, lnum = 0, pass;

    byte *color_in;
    int color_line_size, color_in_size;
    int spare_bits;
    int whole_bits;

    int max_dpi = 60 * (
            (y_24pin) ?
            sizeof(graphics_modes_24) / sizeof(graphics_modes_24[0])
            :
            sizeof(graphics_modes_9) / sizeof(graphics_modes_9[0])
            )
            - 1;
    if (x_dpi > max_dpi) {
        return_error(gs_error_rangecheck);
    }
    
    start_graphics = (char)
        ((y_24pin ? graphics_modes_24 : graphics_modes_9)[x_dpi / 60]);
    first_pass = (start_graphics & DD ? 1 : 0);
    last_pass = first_pass * 2;
    dots_per_space = x_dpi / 10;    /* pica space = 1/10"" */
    bytes_per_space = dots_per_space * y_mult;
    if (bytes_per_space == 0) {
        /* This avoids divide by zero later on, bug 701843. */
        return_error(gs_error_rangecheck);
    }

    in =
        (byte *) gs_malloc(pdev->memory, in_size + 1, 1,
                           ""epsc_print_page(in)"");
    out =
        (byte *) gs_malloc(pdev->memory, out_size + 1, 1,
                           ""epsc_print_page(out)"");

    /* declare color buffer and related vars */
    spare_bits = (pdev->width % 8); /* left over bits to go to margin */
    whole_bits = pdev->width - spare_bits;

    /* Check allocations */
    if (in == 0 || out == 0) {
        if (in)
            gs_free(pdev->memory, (char *)in, in_size + 1, 1,
                    ""epsc_print_page(in)"");
        if (out)
            gs_free(pdev->memory, (char *)out, out_size + 1, 1,
                    ""epsc_print_page(out)"");
        return -1;
    }

    /* Initialize the printer and reset the margins. */
    gp_fwrite(""\033@\033P\033l\000\033Q\377\033U\001\r"", 1, 14, prn_stream);

    /* Create color buffer */
    if (gx_device_has_color(pdev)) {
        color_line_size = gdev_mem_bytes_per_scan_line((gx_device *) pdev);
        color_in_size = color_line_size * (8 * y_mult);
        if ((color_in = (byte *) gs_malloc(pdev->memory, color_in_size + 1, 1,
                                           ""epsc_print_page(color)"")) == 0) {
            gs_free(pdev->memory, (char *)in, in_size + 1, 1,
                    ""epsc_print_page(in)"");
            gs_free(pdev->memory, (char *)out, out_size + 1, 1,
                    ""epsc_print_page(out)"");
            return (-1);
        }
    } else {
        color_in = in;
        color_in_size = in_size;
        color_line_size = line_size;
    }

    /* Print lines of graphics */
    while (lnum < pdev->height) {
        int lcnt;
        byte *nextcolor = NULL; /* position where next color appears */
        byte *nextmono = NULL;  /* position to map next color */

        /* Copy 1 scan line and test for all zero. */
        gdev_prn_copy_scan_lines(pdev, lnum, color_in, color_line_size);

        if (color_in[0] == 0 &&
            !memcmp((char *)color_in, (char *)color_in + 1,
                    color_line_size - 1)
            ) {
            lnum++;
            skip += 3 / y_mult;
            continue;
        }

        /* Vertical tab to the appropriate position. */
        while (skip > 255) {
            gp_fputs(""\033J\377"", prn_stream);
            skip -= 255;
        }
        if (skip)
            gp_fprintf(prn_stream, ""\033J%c"", skip);

        /* Copy the rest of the scan lines. */
        lcnt = 1 + gdev_prn_copy_scan_lines(pdev, lnum + 1,
                                            color_in + color_line_size,
                                            color_in_size - color_line_size);

        if (lcnt < 8 * y_mult) {
            memset((char *)(color_in + lcnt * color_line_size), 0,
                   color_in_size - lcnt * color_line_size);
            if (gx_device_has_color(pdev))      /* clear the work buffer */
                memset((char *)(in + lcnt * line_size), 0,
                       in_size - lcnt * line_size);
        }

        /*
        ** We need to create a normal epson scan line from our color scan line
        ** We do this by setting a bit in the ""in"" buffer if the pixel byte is set
        ** to any color.  We then search for any more pixels of that color, setting
        ** ""in"" accordingly.  If any other color is found, we save it for the next
        ** pass.  There may be up to 7 passes.
        ** In the future, we should make the passes so as to maximize the
        ** life of the color ribbon (i.e. go lightest to darkest).
        */
        do {
            byte *inp = in;
            byte *in_end = in + line_size;
            byte *out_end = out;
            byte *out_blk;
            register byte *outp;

            if (gx_device_has_color(pdev)) {
                register int i, j;
                register byte *outbuf, *realbuf;
                byte current_color;
                int end_next_bits = whole_bits;
                int lastbits;

                /* Move to the point in the scanline that has a new color */
                if (nextcolor) {
                    realbuf = nextcolor;
                    outbuf = nextmono;
                    memset((char *)in, 0, (nextmono - in));
                    i = nextcolor - color_in;
                    nextcolor = NULL;
                    end_next_bits = (i / color_line_size) * color_line_size
                        + whole_bits;
                } else {
                    i = 0;
                    realbuf = color_in;
                    outbuf = in;
                    nextcolor = NULL;
                }
                /* move thru the color buffer, turning on the appropriate
                ** bit in the ""mono"" buffer"", setting pointers to the next
                ** color and changing the color output of the epson
                */
                for (current_color = 0; i <= color_in_size && outbuf < in + in_size; outbuf++) {
                    /* Remember, line_size is rounded up to next whole byte
                    ** whereas color_line_size is the proper length
                    ** We only want to set the proper bits in the last line_size byte.
                    */
                    if (spare_bits && i == end_next_bits) {
                        end_next_bits = whole_bits + i + spare_bits;
                        lastbits = 8 - spare_bits;
                    } else
                        lastbits = 0;

                    for (*outbuf = 0, j = 8;
                         --j >= lastbits && i <= color_in_size;
                         realbuf++, i++) {
                        if (*realbuf) {
                            if (current_color > 0) {
                                if (*realbuf == current_color) {
                                    *outbuf |= 1 << j;
                                    *realbuf = 0;       /* throw this byte away */
                                }
                                /* save this location for next pass */
                                else if (nextcolor == NULL) {
                                    nextcolor = realbuf - (7 - j);
                                    nextmono = outbuf;
                                }
                            } else {
                                *outbuf |= 1 << j;
                                current_color = *realbuf;       /* set color */
                                *realbuf = 0;
                            }
                        }
                    }
                }
                *outbuf = 0;    /* zero the end, for safe keeping */
               /* Change color on the EPSON, current_color must be set
               ** but lets check anyway
               */
                if (current_color)
                    gp_fprintf(prn_stream, ""\033r%c"", current_color ^ 7);
            }

            /* We have to 'transpose' blocks of 8 pixels x 8 lines, */
            /* because that's how the printer wants the data. */
            /* If we are in a 24-pin mode, we have to transpose */
            /* groups of 3 lines at a time. */

            if (y_24pin) {
                for (; inp < in_end; inp++, out_end += 24) {
                    gdev_prn_transpose_8x8(inp, line_size, out_end, 3);
                    gdev_prn_transpose_8x8(inp + line_size * 8, line_size,
                                           out_end + 1, 3);
                    gdev_prn_transpose_8x8(inp + line_size * 16, line_size,
                                           out_end + 2, 3);
                }
                /* Remove trailing 0s. */
                while (out_end > out && out_end[-1] == 0 &&
                       out_end[-2] == 0 && out_end[-3] == 0)
                    out_end -= 3;
            } else {
                for (; inp < in_end; inp++, out_end += 8) {
                    gdev_prn_transpose_8x8(inp, line_size, out_end, 1);
                }
                /* Remove trailing 0s. */
                while (out_end > out && out_end[-1] == 0)
                    out_end--;
            }

            for (pass = first_pass; pass <= last_pass; pass++) {
                for (out_blk = outp = out; outp < out_end;) {   /* Skip a run of leading 0s. */
                    /* At least 10 are needed to make tabbing worth it. */
                    /* We do everything by 3's to avoid having to make */
                    /* different cases for 9- and 24-pin. */

                    if (*outp == 0 && outp + 12 <= out_end &&
                        outp[1] == 0 && outp[2] == 0 &&
                        (outp[3] | outp[4] | outp[5]) == 0 &&
                        (outp[6] | outp[7] | outp[8]) == 0 &&
                        (outp[9] | outp[10] | outp[11]) == 0) {
                        byte *zp = outp;
                        int tpos;
                        byte *newp;

                        outp += 12;
                        while (outp + 3 <= out_end && *outp == 0 &&
                               outp[1] == 0 && outp[2] == 0)
                            outp += 3;
                        tpos = (outp - out) / bytes_per_space;
                        newp = out + tpos * bytes_per_space;
                        if (newp > zp + 10) {   /* Output preceding bit data. */
                            if (zp > out_blk)
                                /* only false at */
                                /* beginning of line */
                                epsc_output_run(out_blk, (int)(zp - out_blk),
                                                y_mult, start_graphics,
                                                prn_stream, pass);
                            /* Tab over to the appropriate position. */
                            gp_fprintf(prn_stream, ""\033D%c%c\t"", tpos, 0);
                            out_blk = outp = newp;
                        }
                    } else
                        outp += y_mult;
                }
                if (outp > out_blk)
                    epsc_output_run(out_blk, (int)(outp - out_blk),
                                    y_mult, start_graphics, prn_stream, pass);

                gp_fputc('\r', prn_stream);
            }
        } while (nextcolor);
        skip = 24;
        lnum += 8 * y_mult;
    }

    /* Eject the page and reinitialize the printer */
    gp_fputs(""\f\033@"", prn_stream);

    gs_free(pdev->memory, (char *)out, out_size + 1, 1,
            ""epsc_print_page(out)"");
    gs_free(pdev->memory, (char *)in, in_size + 1, 1, ""epsc_print_page(in)"");
    if (gx_device_has_color(pdev))
        gs_free(pdev->memory, (char *)color_in, color_in_size + 1, 1,
                ""epsc_print_page(rin)"");
    return 0;
}","static int
epsc_print_page(gx_device_printer * VAR_0, gp_file * VAR_1)
{
    static int VAR_2[5] = { -1, 0 /* COMMENT_0 */ , 1 /* COMMENT_1 */ , -1, VAR_3 + 3  /* COMMENT_2 */
    };
    static int VAR_4[7] =
        { -1, 32 /* COMMENT_0 */ , 33 /* COMMENT_1 */ , 39 /* COMMENT_3 */ ,
        -1, -1, VAR_3 + 40         /* COMMENT_4 */
    };
    int VAR_5 = VAR_0->y_pixels_per_inch > 72;
    int VAR_6 = (VAR_5 ? 3 : 1);
    int VAR_7 = (VAR_0->width + 7) >> 3;     /* COMMENT_5 */
    int VAR_8 = VAR_7 * (8 * VAR_6);
    int VAR_9 = ((VAR_0->width + 7) & -8) * VAR_6;
    byte *VAR_10;
    byte *VAR_11;
    int VAR_12 = (int)VAR_0->x_pixels_per_inch;

    char VAR_13;
    int VAR_14;
    int VAR_15;
    int VAR_16; 
    int VAR_17;
    int VAR_18 = 0, VAR_19 = 0, VAR_20;

    byte *VAR_21;
    int VAR_22, VAR_23;
    int VAR_24;
    int VAR_25;

    int VAR_26 = 60 * (
            (VAR_5) ?
            sizeof(graphics_modes_24) / sizeof(graphics_modes_24[0])
            :
            sizeof(graphics_modes_9) / sizeof(graphics_modes_9[0])
            )
            - 1;
    if (VAR_12 > VAR_26) {
        return_error(VAR_27);
    }
    
    VAR_13 = (char)
        ((VAR_5 ? graphics_modes_24 : graphics_modes_9)[VAR_12 / 60]);
    VAR_14 = (VAR_13 & VAR_3 ? 1 : 0);
    VAR_15 = VAR_14 * 2;
    VAR_16 = VAR_12 / 10;    /* COMMENT_6 */
    VAR_17 = VAR_16 * VAR_6;
    if (VAR_17 == 0) {
        /* COMMENT_7 */
        return_error(VAR_27);
    }

    VAR_10 =
        (byte *) gs_malloc(VAR_0->memory, VAR_8 + 1, 1,
                           ""epsc_print_page(in)"");
    VAR_11 =
        (byte *) gs_malloc(VAR_0->memory, VAR_9 + 1, 1,
                           ""epsc_print_page(out)"");

    /* COMMENT_8 */
    VAR_24 = (VAR_0->width % 8); /* COMMENT_9 */
    VAR_25 = VAR_0->width - VAR_24;

    /* COMMENT_10 */
    if (VAR_10 == 0 || VAR_11 == 0) {
        if (VAR_10)
            gs_free(VAR_0->memory, (char *)VAR_10, VAR_8 + 1, 1,
                    ""epsc_print_page(in)"");
        if (VAR_11)
            gs_free(VAR_0->memory, (char *)VAR_11, VAR_9 + 1, 1,
                    ""epsc_print_page(out)"");
        return -1;
    }

    /* COMMENT_11 */
    gp_fwrite(""\033@\033P\033l\000\033Q\377\033U\001\r"", 1, 14, VAR_1);

    /* COMMENT_12 */
    if (gx_device_has_color(VAR_0)) {
        VAR_22 = gdev_mem_bytes_per_scan_line((gx_device *) VAR_0);
        VAR_23 = VAR_22 * (8 * VAR_6);
        if ((VAR_21 = (byte *) gs_malloc(VAR_0->memory, VAR_23 + 1, 1,
                                           ""epsc_print_page(color)"")) == 0) {
            gs_free(VAR_0->memory, (char *)VAR_10, VAR_8 + 1, 1,
                    ""epsc_print_page(in)"");
            gs_free(VAR_0->memory, (char *)VAR_11, VAR_9 + 1, 1,
                    ""epsc_print_page(out)"");
            return (-1);
        }
    } else {
        VAR_21 = VAR_10;
        VAR_23 = VAR_8;
        VAR_22 = VAR_7;
    }

    /* COMMENT_13 */
    while (VAR_19 < VAR_0->height) {
        int VAR_28;
        byte *VAR_29 = NULL; /* COMMENT_14 */
        byte *VAR_30 = NULL;  /* COMMENT_15 */

        /* COMMENT_16 */
        gdev_prn_copy_scan_lines(VAR_0, VAR_19, VAR_21, VAR_22);

        if (VAR_21[0] == 0 &&
            !memcmp((char *)VAR_21, (char *)VAR_21 + 1,
                    VAR_22 - 1)
            ) {
            VAR_19++;
            VAR_18 += 3 / VAR_6;
            continue;
        }

        /* COMMENT_17 */
        while (VAR_18 > 255) {
            gp_fputs(""\033J\377"", VAR_1);
            VAR_18 -= 255;
        }
        if (VAR_18)
            gp_fprintf(VAR_1, ""\033J%c"", VAR_18);

        /* COMMENT_18 */
        VAR_28 = 1 + gdev_prn_copy_scan_lines(VAR_0, VAR_19 + 1,
                                            VAR_21 + VAR_22,
                                            VAR_23 - VAR_22);

        if (VAR_28 < 8 * VAR_6) {
            memset((char *)(VAR_21 + VAR_28 * VAR_22), 0,
                   VAR_23 - VAR_28 * VAR_22);
            if (gx_device_has_color(VAR_0))      /* COMMENT_19 */
                memset((char *)(VAR_10 + VAR_28 * VAR_7), 0,
                       VAR_8 - VAR_28 * VAR_7);
        }

        /* COMMENT_20 */
                                                                              
                                                                                  
                                                                                   
                                                                                  
                                              
                                                                         
                                                                  
          
        do {
            byte *VAR_31 = VAR_10;
            byte *VAR_32 = VAR_10 + VAR_7;
            byte *VAR_33 = VAR_11;
            byte *VAR_34;
            register byte *VAR_35;

            if (gx_device_has_color(VAR_0)) {
                register int VAR_36, VAR_37;
                register byte *VAR_38, *VAR_39;
                byte VAR_40;
                int VAR_41 = VAR_25;
                int VAR_42;

                /* COMMENT_29 */
                if (VAR_29) {
                    VAR_39 = VAR_29;
                    VAR_38 = VAR_30;
                    memset((char *)VAR_10, 0, (VAR_30 - VAR_10));
                    VAR_36 = VAR_29 - VAR_21;
                    VAR_29 = NULL;
                    VAR_41 = (VAR_36 / VAR_22) * VAR_22
                        + VAR_25;
                } else {
                    VAR_36 = 0;
                    VAR_39 = VAR_21;
                    VAR_38 = VAR_10;
                    VAR_29 = NULL;
                }
                /* COMMENT_30 */
                                                                          
                                                                   
                  
                for (VAR_40 = 0; VAR_36 <= VAR_23 && VAR_38 < VAR_10 + VAR_8; VAR_38++) {
                    /* COMMENT_34 */
                                                                   
                                                                                      
                      
                    if (VAR_24 && VAR_36 == VAR_41) {
                        VAR_41 = VAR_25 + VAR_36 + VAR_24;
                        VAR_42 = 8 - VAR_24;
                    } else
                        VAR_42 = 0;

                    for (*VAR_38 = 0, VAR_37 = 8;
                         --VAR_37 >= VAR_42 && VAR_36 <= VAR_23;
                         VAR_39++, VAR_36++) {
                        if (*VAR_39) {
                            if (VAR_40 > 0) {
                                if (*VAR_39 == VAR_40) {
                                    *VAR_38 |= 1 << VAR_37;
                                    *VAR_39 = 0;       /* COMMENT_38 */
                                }
                                /* COMMENT_39 */
                                else if (VAR_29 == NULL) {
                                    VAR_29 = VAR_39 - (7 - VAR_37);
                                    VAR_30 = VAR_38;
                                }
                            } else {
                                *VAR_38 |= 1 << VAR_37;
                                VAR_40 = *VAR_39;       /* COMMENT_40 */
                                *VAR_39 = 0;
                            }
                        }
                    }
                }
                *VAR_38 = 0;    /* COMMENT_41 */
               /* COMMENT_42 */
                                       
                 
                if (VAR_40)
                    gp_fprintf(VAR_1, ""\033r%c"", VAR_40 ^ 7);
            }

            /* COMMENT_45 */
            /* COMMENT_46 */
            /* COMMENT_47 */
            /* COMMENT_48 */

            if (VAR_5) {
                for (; VAR_31 < VAR_32; VAR_31++, VAR_33 += 24) {
                    gdev_prn_transpose_8x8(VAR_31, VAR_7, VAR_33, 3);
                    gdev_prn_transpose_8x8(VAR_31 + VAR_7 * 8, VAR_7,
                                           VAR_33 + 1, 3);
                    gdev_prn_transpose_8x8(VAR_31 + VAR_7 * 16, VAR_7,
                                           VAR_33 + 2, 3);
                }
                /* COMMENT_49 */
                while (VAR_33 > VAR_11 && VAR_33[-1] == 0 &&
                       VAR_33[-2] == 0 && VAR_33[-3] == 0)
                    VAR_33 -= 3;
            } else {
                for (; VAR_31 < VAR_32; VAR_31++, VAR_33 += 8) {
                    gdev_prn_transpose_8x8(VAR_31, VAR_7, VAR_33, 1);
                }
                /* COMMENT_49 */
                while (VAR_33 > VAR_11 && VAR_33[-1] == 0)
                    VAR_33--;
            }

            for (VAR_20 = VAR_14; VAR_20 <= VAR_15; VAR_20++) {
                for (VAR_34 = VAR_35 = VAR_11; VAR_35 < VAR_33;) {   /* COMMENT_50 */
                    /* COMMENT_51 */
                    /* COMMENT_52 */
                    /* COMMENT_53 */

                    if (*VAR_35 == 0 && VAR_35 + 12 <= VAR_33 &&
                        VAR_35[1] == 0 && VAR_35[2] == 0 &&
                        (VAR_35[3] | VAR_35[4] | VAR_35[5]) == 0 &&
                        (VAR_35[6] | VAR_35[7] | VAR_35[8]) == 0 &&
                        (VAR_35[9] | VAR_35[10] | VAR_35[11]) == 0) {
                        byte *VAR_43 = VAR_35;
                        int VAR_44;
                        byte *VAR_45;

                        VAR_35 += 12;
                        while (VAR_35 + 3 <= VAR_33 && *VAR_35 == 0 &&
                               VAR_35[1] == 0 && VAR_35[2] == 0)
                            VAR_35 += 3;
                        VAR_44 = (VAR_35 - VAR_11) / VAR_17;
                        VAR_45 = VAR_11 + VAR_44 * VAR_17;
                        if (VAR_45 > VAR_43 + 10) {   /* COMMENT_54 */
                            if (VAR_43 > VAR_34)
                                /* COMMENT_55 */
                                /* COMMENT_56 */
                                epsc_output_run(VAR_34, (int)(VAR_43 - VAR_34),
                                                VAR_6, VAR_13,
                                                VAR_1, VAR_20);
                            /* COMMENT_57 */
                            gp_fprintf(VAR_1, ""\033D%c%c\t"", VAR_44, 0);
                            VAR_34 = VAR_35 = VAR_45;
                        }
                    } else
                        VAR_35 += VAR_6;
                }
                if (VAR_35 > VAR_34)
                    epsc_output_run(VAR_34, (int)(VAR_35 - VAR_34),
                                    VAR_6, VAR_13, VAR_1, VAR_20);

                gp_fputc('\r', VAR_1);
            }
        } while (VAR_29);
        VAR_18 = 24;
        VAR_19 += 8 * VAR_6;
    }

    /* COMMENT_58 */
    gp_fputs(""\f\033@"", VAR_1);

    gs_free(VAR_0->memory, (char *)VAR_11, VAR_9 + 1, 1,
            ""epsc_print_page(out)"");
    gs_free(VAR_0->memory, (char *)VAR_10, VAR_8 + 1, 1, ""epsc_print_page(in)"");
    if (gx_device_has_color(VAR_0))
        gs_free(VAR_0->memory, (char *)VAR_21, VAR_23 + 1, 1,
                ""epsc_print_page(rin)"");
    return 0;
}",ArtifexSoftware/ghostpdl/4e713293de84b689c4ab358f3e110ea54aa81925/gdevepsc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -39,19 +39,23 @@
         return_error(gs_error_rangecheck);
     }
     
+    start_graphics = (char)
+        ((y_24pin ? graphics_modes_24 : graphics_modes_9)[x_dpi / 60]);
+    first_pass = (start_graphics & DD ? 1 : 0);
+    last_pass = first_pass * 2;
+    dots_per_space = x_dpi / 10;    /* pica space = 1/10"" */
+    bytes_per_space = dots_per_space * y_mult;
+    if (bytes_per_space == 0) {
+        /* This avoids divide by zero later on, bug 701843. */
+        return_error(gs_error_rangecheck);
+    }
+
     in =
         (byte *) gs_malloc(pdev->memory, in_size + 1, 1,
                            ""epsc_print_page(in)"");
     out =
         (byte *) gs_malloc(pdev->memory, out_size + 1, 1,
                            ""epsc_print_page(out)"");
-
-    start_graphics = (char)
-        ((y_24pin ? graphics_modes_24 : graphics_modes_9)[x_dpi / 60]);
-    first_pass = (start_graphics & DD ? 1 : 0);
-    last_pass = first_pass * 2;
-    dots_per_space = x_dpi / 10;    /* pica space = 1/10"" */
-    bytes_per_space = dots_per_space * y_mult;
 
     /* declare color buffer and related vars */
     spare_bits = (pdev->width % 8); /* left over bits to go to margin */","{'deleted_lines': ['', '    start_graphics = (char)', '        ((y_24pin ? graphics_modes_24 : graphics_modes_9)[x_dpi / 60]);', '    first_pass = (start_graphics & DD ? 1 : 0);', '    last_pass = first_pass * 2;', '    dots_per_space = x_dpi / 10;    /* pica space = 1/10"" */', '    bytes_per_space = dots_per_space * y_mult;'], 'added_lines': ['    start_graphics = (char)', '        ((y_24pin ? graphics_modes_24 : graphics_modes_9)[x_dpi / 60]);', '    first_pass = (start_graphics & DD ? 1 : 0);', '    last_pass = first_pass * 2;', '    dots_per_space = x_dpi / 10;    /* pica space = 1/10"" */', '    bytes_per_space = dots_per_space * y_mult;', '    if (bytes_per_space == 0) {', '        /* This avoids divide by zero later on, bug 701843. */', '        return_error(gs_error_rangecheck);', '    }', '']}",True,A divide by zero issue discovered in eps_print_page in gdevepsn.c in Artifex Software GhostScript 9.50 allows remote attackers to cause a denial of service via opening of crafted PDF file.,5.5,MEDIUM,1,valid,2019-11-06T11:56:07Z,3
CVE-2019-19580,['CWE-362'],AV:N/AC:M/Au:S/C:P/I:P/A:P,0,xen-project/xen,"x86/mm: Set old_guest_table when destroying vcpu pagetables

Changeset 6c4efc1eba (""x86/mm: Don't drop a type ref unless you held a
ref to begin with""), part of XSA-299, changed the calling discipline
of put_page_type() such that if put_page_type() returned -ERESTART
(indicating a partially de-validated page), subsequent calls to
put_page_type() must be called with PTF_partial_set.  If called on a
partially de-validated page but without PTF_partial_set, Xen will
BUG(), because to do otherwise would risk opening up the kind of
privilege escalation bug described in XSA-299.

One place this was missed was in vcpu_destroy_pagetables().
put_page_and_type_preemptible() is called, but on -ERESTART, the
entire operation is simply restarted, causing put_page_type() to be
called on a partially de-validated page without PTF_partial_set.  The
result was that if such an operation were interrupted, Xen would hit a
BUG().

Fix this by having vcpu_destroy_pagetables() consistently pass off
interrupted de-validations to put_old_page_type():
- Unconditionally clear references to the page, even if
  put_page_and_type failed
- Set old_guest_table and old_guest_table_partial appropriately

While here, do some refactoring:

 - Move clearing of arch.cr3 to the top of the function

 - Now that clearing is unconditional, move the unmap to the same
   conditional as the l4tab mapping.  This also allows us to reduce
   the scope of the l4tab variable.

 - Avoid code duplication by looping to drop references on
   guest_table_user

This is part of XSA-310.

Reported-by: Sarah Newman <srn@prgmr.com>
Signed-off-by: George Dunlap <george.dunlap@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",ececa12b2c4c8e4433e4f9be83f5c668ae36fe08,https://github.com/xen-project/xen/commit/ececa12b2c4c8e4433e4f9be83f5c668ae36fe08,xen/arch/x86/mm.c,vcpu_destroy_pagetables,"int vcpu_destroy_pagetables(struct vcpu *v)
{
unsigned long mfn = pagetable_get_pfn(v->arch.guest_table);
struct page_info *page;
l4_pgentry_t *l4tab = NULL;
int rc = put_old_guest_table(v);
if ( rc )
return rc;
if ( is_pv_32bit_vcpu(v) )
{
l4tab = map_domain_page(_mfn(mfn));
mfn = l4e_get_pfn(*l4tab);
}
if ( mfn )
{
page = mfn_to_page(_mfn(mfn));
if ( paging_mode_refcounts(v->domain) )
put_page(page);
else
rc = put_page_and_type_preemptible(page);
}
if ( l4tab )
{
if ( !rc )
l4e_write(l4tab, l4e_empty());
unmap_domain_page(l4tab);
}
else if ( !rc )
{
v->arch.guest_table = pagetable_null();
mfn = pagetable_get_pfn(v->arch.guest_table_user);
if ( mfn )
{
page = mfn_to_page(_mfn(mfn));
if ( paging_mode_refcounts(v->domain) )
put_page(page);
else
rc = put_page_and_type_preemptible(page);
}
if ( !rc )
v->arch.guest_table_user = pagetable_null();
}
v->arch.cr3 = 0;
return rc != -EINTR ? rc : -ERESTART;
}","int vcpu_destroy_pagetables(struct vcpu *VAR_0)
{
unsigned long VAR_1 = pagetable_get_pfn(VAR_0->arch.guest_table);
struct page_info *VAR_2;
l4_pgentry_t *VAR_3 = NULL;
int VAR_4 = put_old_guest_table(VAR_0);
if ( VAR_4 )
return VAR_4;
if ( is_pv_32bit_vcpu(VAR_0) )
{
VAR_3 = map_domain_page(_mfn(VAR_1));
VAR_1 = l4e_get_pfn(*VAR_3);
}
if ( VAR_1 )
{
VAR_2 = mfn_to_page(_mfn(VAR_1));
if ( paging_mode_refcounts(VAR_0->domain) )
put_page(VAR_2);
else
VAR_4 = put_page_and_type_preemptible(VAR_2);
}
if ( VAR_3 )
{
if ( !VAR_4 )
l4e_write(VAR_3, l4e_empty());
unmap_domain_page(VAR_3);
}
else if ( !VAR_4 )
{
VAR_0->arch.guest_table = pagetable_null();
VAR_1 = pagetable_get_pfn(VAR_0->arch.guest_table_user);
if ( VAR_1 )
{
VAR_2 = mfn_to_page(_mfn(VAR_1));
if ( paging_mode_refcounts(VAR_0->domain) )
put_page(VAR_2);
else
VAR_4 = put_page_and_type_preemptible(VAR_2);
}
if ( !VAR_4 )
VAR_0->arch.guest_table_user = pagetable_null();
}
VAR_0->arch.cr3 = 0;
return VAR_4 != -VAR_5 ? VAR_4 : -VAR_6;
}",xen-project/xen/ececa12b2c4c8e4433e4f9be83f5c668ae36fe08/mm.c/vul/before/0.json,"int vcpu_destroy_pagetables(struct vcpu *v)
{
    unsigned long mfn = pagetable_get_pfn(v->arch.guest_table);
    struct page_info *page = NULL;
    int rc = put_old_guest_table(v);
    bool put_guest_table_user = false;

    if ( rc )
        return rc;

    v->arch.cr3 = 0;

    /*
     * Get the top-level guest page; either the guest_table itself, for
     * 64-bit, or the top-level l4 entry for 32-bit.  Either way, remove
     * the reference to that page.
     */
    if ( is_pv_32bit_vcpu(v) )
    {
        l4_pgentry_t *l4tab = map_domain_page(_mfn(mfn));

        mfn = l4e_get_pfn(*l4tab);
        l4e_write(l4tab, l4e_empty());
        unmap_domain_page(l4tab);
    }
    else
    {
        v->arch.guest_table = pagetable_null();
        put_guest_table_user = true;
    }

    /* Free that page if non-zero */
    do {
        if ( mfn )
        {
            page = mfn_to_page(_mfn(mfn));
            if ( paging_mode_refcounts(v->domain) )
                put_page(page);
            else
                rc = put_page_and_type_preemptible(page);
            mfn = 0;
        }

        if ( !rc && put_guest_table_user )
        {
            /* Drop ref to guest_table_user (from MMUEXT_NEW_USER_BASEPTR) */
            mfn = pagetable_get_pfn(v->arch.guest_table_user);
            v->arch.guest_table_user = pagetable_null();
            put_guest_table_user = false;
        }
    } while ( mfn );

    /*
     * If a ""put"" operation was interrupted, finish things off in
     * put_old_guest_table() when the operation is restarted.
     */
    switch ( rc )
    {
    case -EINTR:
    case -ERESTART:
        v->arch.old_guest_ptpg = NULL;
        v->arch.old_guest_table = page;
        v->arch.old_guest_table_partial = (rc == -ERESTART);
        rc = -ERESTART;
        break;
    default:
        /*
         * Failure to 'put' a page may cause it to leak, but that's
         * less bad than a crash.
         */
        ASSERT(rc == 0);
        break;
    }

    return rc;
}","int vcpu_destroy_pagetables(struct vcpu *VAR_0)
{
    unsigned long VAR_1 = pagetable_get_pfn(VAR_0->arch.guest_table);
    struct page_info *VAR_2 = NULL;
    int VAR_3 = put_old_guest_table(VAR_0);
    bool VAR_4 = false;

    if ( VAR_3 )
        return VAR_3;

    VAR_0->arch.cr3 = 0;

    /* COMMENT_0 */
                                                                       
                                                                        
                                  
       
    if ( is_pv_32bit_vcpu(VAR_0) )
    {
        l4_pgentry_t *VAR_5 = map_domain_page(_mfn(VAR_1));

        VAR_1 = l4e_get_pfn(*VAR_5);
        l4e_write(VAR_5, l4e_empty());
        unmap_domain_page(VAR_5);
    }
    else
    {
        VAR_0->arch.guest_table = pagetable_null();
        VAR_4 = true;
    }

    /* COMMENT_5 */
    do {
        if ( VAR_1 )
        {
            VAR_2 = mfn_to_page(_mfn(VAR_1));
            if ( paging_mode_refcounts(VAR_0->domain) )
                put_page(VAR_2);
            else
                VAR_3 = put_page_and_type_preemptible(VAR_2);
            VAR_1 = 0;
        }

        if ( !VAR_3 && VAR_4 )
        {
            /* COMMENT_6 */
            VAR_1 = pagetable_get_pfn(VAR_0->arch.guest_table_user);
            VAR_0->arch.guest_table_user = pagetable_null();
            VAR_4 = false;
        }
    } while ( VAR_1 );

    /* COMMENT_7 */
                                                                 
                                                             
       
    switch ( VAR_3 )
    {
    case -VAR_6:
    case -VAR_7:
        VAR_0->arch.old_guest_ptpg = NULL;
        VAR_0->arch.old_guest_table = VAR_2;
        VAR_0->arch.old_guest_table_partial = (VAR_3 == -VAR_7);
        VAR_3 = -VAR_7;
        break;
    default:
        /* COMMENT_11 */
                                                                   
                                 
           
        ASSERT(VAR_3 == 0);
        break;
    }

    return VAR_3;
}",xen-project/xen/ececa12b2c4c8e4433e4f9be83f5c668ae36fe08/mm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,40 +1,36 @@
 int vcpu_destroy_pagetables(struct vcpu *v)
 {
     unsigned long mfn = pagetable_get_pfn(v->arch.guest_table);
-    struct page_info *page;
-    l4_pgentry_t *l4tab = NULL;
+    struct page_info *page = NULL;
     int rc = put_old_guest_table(v);
+    bool put_guest_table_user = false;
 
     if ( rc )
         return rc;
 
+    v->arch.cr3 = 0;
+
+    /*
+     * Get the top-level guest page; either the guest_table itself, for
+     * 64-bit, or the top-level l4 entry for 32-bit.  Either way, remove
+     * the reference to that page.
+     */
     if ( is_pv_32bit_vcpu(v) )
     {
-        l4tab = map_domain_page(_mfn(mfn));
+        l4_pgentry_t *l4tab = map_domain_page(_mfn(mfn));
+
         mfn = l4e_get_pfn(*l4tab);
+        l4e_write(l4tab, l4e_empty());
+        unmap_domain_page(l4tab);
+    }
+    else
+    {
+        v->arch.guest_table = pagetable_null();
+        put_guest_table_user = true;
     }
 
-    if ( mfn )
-    {
-        page = mfn_to_page(_mfn(mfn));
-        if ( paging_mode_refcounts(v->domain) )
-            put_page(page);
-        else
-            rc = put_page_and_type_preemptible(page);
-    }
-
-    if ( l4tab )
-    {
-        if ( !rc )
-            l4e_write(l4tab, l4e_empty());
-        unmap_domain_page(l4tab);
-    }
-    else if ( !rc )
-    {
-        v->arch.guest_table = pagetable_null();
-
-        /* Drop ref to guest_table_user (from MMUEXT_NEW_USER_BASEPTR) */
-        mfn = pagetable_get_pfn(v->arch.guest_table_user);
+    /* Free that page if non-zero */
+    do {
         if ( mfn )
         {
             page = mfn_to_page(_mfn(mfn));
@@ -42,16 +38,39 @@
                 put_page(page);
             else
                 rc = put_page_and_type_preemptible(page);
+            mfn = 0;
         }
-        if ( !rc )
+
+        if ( !rc && put_guest_table_user )
+        {
+            /* Drop ref to guest_table_user (from MMUEXT_NEW_USER_BASEPTR) */
+            mfn = pagetable_get_pfn(v->arch.guest_table_user);
             v->arch.guest_table_user = pagetable_null();
+            put_guest_table_user = false;
+        }
+    } while ( mfn );
+
+    /*
+     * If a ""put"" operation was interrupted, finish things off in
+     * put_old_guest_table() when the operation is restarted.
+     */
+    switch ( rc )
+    {
+    case -EINTR:
+    case -ERESTART:
+        v->arch.old_guest_ptpg = NULL;
+        v->arch.old_guest_table = page;
+        v->arch.old_guest_table_partial = (rc == -ERESTART);
+        rc = -ERESTART;
+        break;
+    default:
+        /*
+         * Failure to 'put' a page may cause it to leak, but that's
+         * less bad than a crash.
+         */
+        ASSERT(rc == 0);
+        break;
     }
 
-    v->arch.cr3 = 0;
-
-    /*
-     * put_page_and_type_preemptible() is liable to return -EINTR. The
-     * callers of us expect -ERESTART so convert it over.
-     */
-    return rc != -EINTR ? rc : -ERESTART;
+    return rc;
 }","{'deleted_lines': ['    struct page_info *page;', '    l4_pgentry_t *l4tab = NULL;', '        l4tab = map_domain_page(_mfn(mfn));', '    if ( mfn )', '    {', '        page = mfn_to_page(_mfn(mfn));', '        if ( paging_mode_refcounts(v->domain) )', '            put_page(page);', '        else', '            rc = put_page_and_type_preemptible(page);', '    }', '', '    if ( l4tab )', '    {', '        if ( !rc )', '            l4e_write(l4tab, l4e_empty());', '        unmap_domain_page(l4tab);', '    }', '    else if ( !rc )', '    {', '        v->arch.guest_table = pagetable_null();', '', '        /* Drop ref to guest_table_user (from MMUEXT_NEW_USER_BASEPTR) */', '        mfn = pagetable_get_pfn(v->arch.guest_table_user);', '        if ( !rc )', '    v->arch.cr3 = 0;', '', '    /*', '     * put_page_and_type_preemptible() is liable to return -EINTR. The', '     * callers of us expect -ERESTART so convert it over.', '     */', '    return rc != -EINTR ? rc : -ERESTART;'], 'added_lines': ['    struct page_info *page = NULL;', '    bool put_guest_table_user = false;', '    v->arch.cr3 = 0;', '', '    /*', '     * Get the top-level guest page; either the guest_table itself, for', '     * 64-bit, or the top-level l4 entry for 32-bit.  Either way, remove', '     * the reference to that page.', '     */', '        l4_pgentry_t *l4tab = map_domain_page(_mfn(mfn));', '', '        l4e_write(l4tab, l4e_empty());', '        unmap_domain_page(l4tab);', '    }', '    else', '    {', '        v->arch.guest_table = pagetable_null();', '        put_guest_table_user = true;', '    /* Free that page if non-zero */', '    do {', '            mfn = 0;', '', '        if ( !rc && put_guest_table_user )', '        {', '            /* Drop ref to guest_table_user (from MMUEXT_NEW_USER_BASEPTR) */', '            mfn = pagetable_get_pfn(v->arch.guest_table_user);', '            put_guest_table_user = false;', '        }', '    } while ( mfn );', '', '    /*', '     * If a ""put"" operation was interrupted, finish things off in', '     * put_old_guest_table() when the operation is restarted.', '     */', '    switch ( rc )', '    {', '    case -EINTR:', '    case -ERESTART:', '        v->arch.old_guest_ptpg = NULL;', '        v->arch.old_guest_table = page;', '        v->arch.old_guest_table_partial = (rc == -ERESTART);', '        rc = -ERESTART;', '        break;', '    default:', '        /*', ""         * Failure to 'put' a page may cause it to leak, but that's"", '         * less bad than a crash.', '         */', '        ASSERT(rc == 0);', '        break;', '    return rc;']}",True,"An issue was discovered in Xen through 4.12.x allowing x86 PV guest OS users to gain host OS privileges by leveraging race conditions in pagetable promotion and demotion operations, because of an incomplete fix for CVE-2019-18421. XSA-299 addressed several critical issues in restartable PV type change operations. Despite extensive testing and auditing, some corner cases were missed. A malicious PV guest administrator may be able to escalate their privilege to that of the host. All security-supported versions of Xen are vulnerable. Only x86 systems are affected. Arm systems are not affected. Only x86 PV guests can leverage the vulnerability. x86 HVM and PVH guests cannot leverage the vulnerability. Note that these attacks require very precise timing, which may be difficult to exploit in practice.",6.6,MEDIUM,1,valid,2019-11-19T11:40:34Z,3
CVE-2019-19334,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,CESNET/libyang,"parser BUGFIX long identityref default value buffer overflow

STRING_OVERFLOW (CWE-120)",6980afae2ff9fcd6d67508b0a3f694d75fd059d6,https://github.com/CESNET/libyang/commit/6980afae2ff9fcd6d67508b0a3f694d75fd059d6,src/parser.c,make_canonical,"static int
make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, void *data2)
{
const uint16_t buf_len = 511;
char buf[buf_len + 1];
struct lys_type_bit **bits = NULL;
struct lyxp_expr *exp;
const char *module_name, *cur_expr, *end;
int i, j, count;
int64_t num;
uint64_t unum;
uint8_t c;
#define LOGBUF(str) LOGERR(ctx, LY_EINVAL, ""Value \""%s\"" is too long."", str)
switch (type) {
case LY_TYPE_BITS:
bits = (struct lys_type_bit **)data1;
count = *((int *)data2);
buf[0] = '\0';
for (i = 0; i < count; i++) {
if (!bits[i]) {
continue;
}
if (buf[0]) {
LY_CHECK_ERR_RETURN(strlen(buf) + 1 + strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);
sprintf(buf + strlen(buf), "" %s"", bits[i]->name);
} else {
LY_CHECK_ERR_RETURN(strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);
strcpy(buf, bits[i]->name);
}
}
break;
case LY_TYPE_IDENT:
module_name = (const char *)data1;
if (!strchr(*value, ':')) {
sprintf(buf, ""%s:%s"", module_name, *value);
} else {
strcpy(buf, *value);
}
break;
case LY_TYPE_INST:
exp = lyxp_parse_expr(ctx, *value);
LY_CHECK_ERR_RETURN(!exp, LOGINT(ctx), -1);
module_name = NULL;
count = 0;
for (i = 0; (unsigned)i < exp->used; ++i) {
cur_expr = &exp->expr[exp->expr_pos[i]];
if (i && ((end = exp->expr + exp->expr_pos[i - 1] + exp->tok_len[i - 1]) != cur_expr)) {
if (count + (cur_expr - end) > buf_len) {
lyxp_expr_free(exp);
LOGBUF(end);
return -1;
}
strncpy(&buf[count], end, cur_expr - end);
count += cur_expr - end;
}
if ((exp->tokens[i] == LYXP_TOKEN_NAMETEST) && (end = strnchr(cur_expr, ':', exp->tok_len[i]))) {
++end;
j = end - cur_expr;
if (!module_name || strncmp(cur_expr, module_name, j)) {
if (count + j > buf_len) {
lyxp_expr_free(exp);
LOGBUF(cur_expr);
return -1;
}
strncpy(&buf[count], cur_expr, j);
count += j;
}
module_name = cur_expr;
if (count + (exp->tok_len[i] - j) > buf_len) {
lyxp_expr_free(exp);
LOGBUF(end);
return -1;
}
strncpy(&buf[count], end, exp->tok_len[i] - j);
count += exp->tok_len[i] - j;
} else {
if (count + exp->tok_len[i] > buf_len) {
lyxp_expr_free(exp);
LOGBUF(&exp->expr[exp->expr_pos[i]]);
return -1;
}
strncpy(&buf[count], &exp->expr[exp->expr_pos[i]], exp->tok_len[i]);
count += exp->tok_len[i];
}
}
if (count > buf_len) {
LOGINT(ctx);
lyxp_expr_free(exp);
return -1;
}
buf[count] = '\0';
lyxp_expr_free(exp);
break;
case LY_TYPE_DEC64:
num = *((int64_t *)data1);
c = *((uint8_t *)data2);
if (num) {
count = sprintf(buf, ""%""PRId64"" "", num);
if ( (num > 0 && (count - 1) <= c)
|| (count - 2) <= c ) {
count = sprintf(buf, ""%0*""PRId64"" "", (num > 0) ? (c + 1) : (c + 2), num);
}
for (i = c, j = 1; i > 0 ; i--) {
if (j && i > 1 && buf[count - 2] == '0') {
buf[count - 1] = '\0';
} else {
j = 0;
buf[count - 1] = buf[count - 2];
}
count--;
}
buf[count - 1] = '.';
} else {
sprintf(buf, ""0.0"");
}
break;
case LY_TYPE_INT8:
case LY_TYPE_INT16:
case LY_TYPE_INT32:
case LY_TYPE_INT64:
num = *((int64_t *)data1);
sprintf(buf, ""%""PRId64, num);
break;
case LY_TYPE_UINT8:
case LY_TYPE_UINT16:
case LY_TYPE_UINT32:
case LY_TYPE_UINT64:
unum = *((uint64_t *)data1);
sprintf(buf, ""%""PRIu64, unum);
break;
default:
return 0;
}
if (strcmp(buf, *value)) {
lydict_remove(ctx, *value);
*value = lydict_insert(ctx, buf, 0);
return 1;
}
return 0;
#undef LOGBUF
}","static int
make_canonical(struct ly_ctx *VAR_0, int VAR_1, const char **VAR_2, void *VAR_3, void *VAR_4)
{
const uint16_t VAR_5 = 511;
char VAR_6[VAR_5 + 1];
struct lys_type_bit **VAR_7 = NULL;
struct lyxp_expr *VAR_8;
const char *VAR_9, *VAR_10, *VAR_11;
int VAR_12, VAR_13, VAR_14;
int64_t VAR_15;
uint64_t VAR_16;
uint8_t VAR_17;
#define LOGBUF(VAR_18) LOGERR(ctx, LY_EINVAL, ""Value \""%s\"" is too long."", str)
switch (VAR_1) {
case VAR_19:
VAR_7 = (struct lys_type_bit **)VAR_3;
VAR_14 = *((int *)VAR_4);
VAR_6[0] = '\0';
for (VAR_12 = 0; VAR_12 < VAR_14; VAR_12++) {
if (!VAR_7[VAR_12]) {
continue;
}
if (VAR_6[0]) {
LY_CHECK_ERR_RETURN(strlen(VAR_6) + 1 + strlen(VAR_7[VAR_12]->name) > VAR_5, LOGBUF(VAR_7[VAR_12]->name), -1);
sprintf(VAR_6 + strlen(VAR_6), "" %s"", VAR_7[VAR_12]->name);
} else {
LY_CHECK_ERR_RETURN(strlen(VAR_7[VAR_12]->name) > VAR_5, LOGBUF(VAR_7[VAR_12]->name), -1);
strcpy(VAR_6, VAR_7[VAR_12]->name);
}
}
break;
case VAR_20:
VAR_9 = (const char *)VAR_3;
if (!strchr(*VAR_2, ':')) {
sprintf(VAR_6, ""%s:%s"", VAR_9, *VAR_2);
} else {
strcpy(VAR_6, *VAR_2);
}
break;
case VAR_21:
VAR_8 = lyxp_parse_expr(VAR_0, *VAR_2);
LY_CHECK_ERR_RETURN(!VAR_8, LOGINT(VAR_0), -1);
VAR_9 = NULL;
VAR_14 = 0;
for (VAR_12 = 0; (unsigned)VAR_12 < VAR_8->used; ++VAR_12) {
VAR_10 = &VAR_8->expr[VAR_8->expr_pos[VAR_12]];
if (VAR_12 && ((VAR_11 = VAR_8->expr + VAR_8->expr_pos[VAR_12 - 1] + VAR_8->tok_len[VAR_12 - 1]) != VAR_10)) {
if (VAR_14 + (VAR_10 - VAR_11) > VAR_5) {
lyxp_expr_free(VAR_8);
LOGBUF(VAR_11);
return -1;
}
strncpy(&VAR_6[VAR_14], VAR_11, VAR_10 - VAR_11);
VAR_14 += VAR_10 - VAR_11;
}
if ((VAR_8->tokens[VAR_12] == VAR_22) && (VAR_11 = strnchr(VAR_10, ':', VAR_8->tok_len[VAR_12]))) {
++VAR_11;
VAR_13 = VAR_11 - VAR_10;
if (!VAR_9 || strncmp(VAR_10, VAR_9, VAR_13)) {
if (VAR_14 + VAR_13 > VAR_5) {
lyxp_expr_free(VAR_8);
LOGBUF(VAR_10);
return -1;
}
strncpy(&VAR_6[VAR_14], VAR_10, VAR_13);
VAR_14 += VAR_13;
}
VAR_9 = VAR_10;
if (VAR_14 + (VAR_8->tok_len[VAR_12] - VAR_13) > VAR_5) {
lyxp_expr_free(VAR_8);
LOGBUF(VAR_11);
return -1;
}
strncpy(&VAR_6[VAR_14], VAR_11, VAR_8->tok_len[VAR_12] - VAR_13);
VAR_14 += VAR_8->tok_len[VAR_12] - VAR_13;
} else {
if (VAR_14 + VAR_8->tok_len[VAR_12] > VAR_5) {
lyxp_expr_free(VAR_8);
LOGBUF(&VAR_8->expr[VAR_8->expr_pos[VAR_12]]);
return -1;
}
strncpy(&VAR_6[VAR_14], &VAR_8->expr[VAR_8->expr_pos[VAR_12]], VAR_8->tok_len[VAR_12]);
VAR_14 += VAR_8->tok_len[VAR_12];
}
}
if (VAR_14 > VAR_5) {
LOGINT(VAR_0);
lyxp_expr_free(VAR_8);
return -1;
}
VAR_6[VAR_14] = '\0';
lyxp_expr_free(VAR_8);
break;
case VAR_23:
VAR_15 = *((int64_t *)VAR_3);
VAR_17 = *((uint8_t *)VAR_4);
if (VAR_15) {
VAR_14 = sprintf(VAR_6, ""%""VAR_24"" "", VAR_15);
if ( (VAR_15 > 0 && (VAR_14 - 1) <= VAR_17)
|| (VAR_14 - 2) <= VAR_17 ) {
VAR_14 = sprintf(VAR_6, ""%0*""VAR_24"" "", (VAR_15 > 0) ? (VAR_17 + 1) : (VAR_17 + 2), VAR_15);
}
for (VAR_12 = VAR_17, VAR_13 = 1; VAR_12 > 0 ; VAR_12--) {
if (VAR_13 && VAR_12 > 1 && VAR_6[VAR_14 - 2] == '0') {
VAR_6[VAR_14 - 1] = '\0';
} else {
VAR_13 = 0;
VAR_6[VAR_14 - 1] = VAR_6[VAR_14 - 2];
}
VAR_14--;
}
VAR_6[VAR_14 - 1] = '.';
} else {
sprintf(VAR_6, ""0.0"");
}
break;
case VAR_25:
case VAR_26:
case VAR_27:
case VAR_28:
VAR_15 = *((int64_t *)VAR_3);
sprintf(VAR_6, ""%""VAR_24, VAR_15);
break;
case VAR_29:
case VAR_30:
case VAR_31:
case VAR_32:
VAR_16 = *((uint64_t *)VAR_3);
sprintf(VAR_6, ""%""VAR_33, VAR_16);
break;
default:
return 0;
}
if (strcmp(VAR_6, *VAR_2)) {
lydict_remove(VAR_0, *VAR_2);
*VAR_2 = lydict_insert(VAR_0, VAR_6, 0);
return 1;
}
return 0;
#undef LOGBUF
}",CESNET/libyang/6980afae2ff9fcd6d67508b0a3f694d75fd059d6/parser.c/vul/before/0.json,"static int
make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, void *data2)
{
    const uint16_t buf_len = 511;
    char buf[buf_len + 1];
    struct lys_type_bit **bits = NULL;
    struct lyxp_expr *exp;
    const char *module_name, *cur_expr, *end;
    int i, j, count;
    int64_t num;
    uint64_t unum;
    uint8_t c;

#define LOGBUF(str) LOGERR(ctx, LY_EINVAL, ""Value \""%s\"" is too long."", str)

    switch (type) {
    case LY_TYPE_BITS:
        bits = (struct lys_type_bit **)data1;
        count = *((int *)data2);
        /* in canonical form, the bits are ordered by their position */
        buf[0] = '\0';
        for (i = 0; i < count; i++) {
            if (!bits[i]) {
                /* bit not set */
                continue;
            }
            if (buf[0]) {
                LY_CHECK_ERR_RETURN(strlen(buf) + 1 + strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);
                sprintf(buf + strlen(buf), "" %s"", bits[i]->name);
            } else {
                LY_CHECK_ERR_RETURN(strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);
                strcpy(buf, bits[i]->name);
            }
        }
        break;

    case LY_TYPE_IDENT:
        module_name = (const char *)data1;
        /* identity must always have a prefix */
        if (!strchr(*value, ':')) {
            LY_CHECK_ERR_RETURN(strlen(module_name) + 1 + strlen(*value) > buf_len, LOGBUF(*value), -1);
            sprintf(buf, ""%s:%s"", module_name, *value);
        } else {
            LY_CHECK_ERR_RETURN(strlen(*value) > buf_len, LOGBUF(*value), -1);
            strcpy(buf, *value);
        }
        break;

    case LY_TYPE_INST:
        exp = lyxp_parse_expr(ctx, *value);
        LY_CHECK_ERR_RETURN(!exp, LOGINT(ctx), -1);

        module_name = NULL;
        count = 0;
        for (i = 0; (unsigned)i < exp->used; ++i) {
            cur_expr = &exp->expr[exp->expr_pos[i]];

            /* copy WS */
            if (i && ((end = exp->expr + exp->expr_pos[i - 1] + exp->tok_len[i - 1]) != cur_expr)) {
                if (count + (cur_expr - end) > buf_len) {
                    lyxp_expr_free(exp);
                    LOGBUF(end);
                    return -1;
                }
                strncpy(&buf[count], end, cur_expr - end);
                count += cur_expr - end;
            }

            if ((exp->tokens[i] == LYXP_TOKEN_NAMETEST) && (end = strnchr(cur_expr, ':', exp->tok_len[i]))) {
                /* get the module name with "":"" */
                ++end;
                j = end - cur_expr;

                if (!module_name || strncmp(cur_expr, module_name, j)) {
                    /* print module name with colon, it does not equal to the parent one */
                    if (count + j > buf_len) {
                        lyxp_expr_free(exp);
                        LOGBUF(cur_expr);
                        return -1;
                    }
                    strncpy(&buf[count], cur_expr, j);
                    count += j;
                }
                module_name = cur_expr;

                /* copy the rest */
                if (count + (exp->tok_len[i] - j) > buf_len) {
                    lyxp_expr_free(exp);
                    LOGBUF(end);
                    return -1;
                }
                strncpy(&buf[count], end, exp->tok_len[i] - j);
                count += exp->tok_len[i] - j;
            } else {
                if (count + exp->tok_len[i] > buf_len) {
                    lyxp_expr_free(exp);
                    LOGBUF(&exp->expr[exp->expr_pos[i]]);
                    return -1;
                }
                strncpy(&buf[count], &exp->expr[exp->expr_pos[i]], exp->tok_len[i]);
                count += exp->tok_len[i];
            }
        }
        if (count > buf_len) {
            LOGINT(ctx);
            lyxp_expr_free(exp);
            return -1;
        }
        buf[count] = '\0';

        lyxp_expr_free(exp);
        break;

    case LY_TYPE_DEC64:
        num = *((int64_t *)data1);
        c = *((uint8_t *)data2);
        if (num) {
            count = sprintf(buf, ""%""PRId64"" "", num);
            if ( (num > 0 && (count - 1) <= c)
                 || (count - 2) <= c ) {
                /* we have 0. value, print the value with the leading zeros
                 * (one for 0. and also keep the correct with of num according
                 * to fraction-digits value)
                 * for (num<0) - extra character for '-' sign */
                count = sprintf(buf, ""%0*""PRId64"" "", (num > 0) ? (c + 1) : (c + 2), num);
            }
            for (i = c, j = 1; i > 0 ; i--) {
                if (j && i > 1 && buf[count - 2] == '0') {
                    /* we have trailing zero to skip */
                    buf[count - 1] = '\0';
                } else {
                    j = 0;
                    buf[count - 1] = buf[count - 2];
                }
                count--;
            }
            buf[count - 1] = '.';
        } else {
            /* zero */
            sprintf(buf, ""0.0"");
        }
        break;

    case LY_TYPE_INT8:
    case LY_TYPE_INT16:
    case LY_TYPE_INT32:
    case LY_TYPE_INT64:
        num = *((int64_t *)data1);
        sprintf(buf, ""%""PRId64, num);
        break;

    case LY_TYPE_UINT8:
    case LY_TYPE_UINT16:
    case LY_TYPE_UINT32:
    case LY_TYPE_UINT64:
        unum = *((uint64_t *)data1);
        sprintf(buf, ""%""PRIu64, unum);
        break;

    default:
        /* should not be even called - just do nothing */
        return 0;
    }

    if (strcmp(buf, *value)) {
        lydict_remove(ctx, *value);
        *value = lydict_insert(ctx, buf, 0);
        return 1;
    }

    return 0;

#undef LOGBUF
}","static int
make_canonical(struct ly_ctx *VAR_0, int VAR_1, const char **VAR_2, void *VAR_3, void *VAR_4)
{
    const uint16_t VAR_5 = 511;
    char VAR_6[VAR_5 + 1];
    struct lys_type_bit **VAR_7 = NULL;
    struct lyxp_expr *VAR_8;
    const char *VAR_9, *VAR_10, *VAR_11;
    int VAR_12, VAR_13, VAR_14;
    int64_t VAR_15;
    uint64_t VAR_16;
    uint8_t VAR_17;

#define LOGBUF(VAR_18) LOGERR(ctx, LY_EINVAL, ""Value \""%s\"" is too long."", str)

    switch (VAR_1) {
    case VAR_19:
        VAR_7 = (struct lys_type_bit **)VAR_3;
        VAR_14 = *((int *)VAR_4);
        /* COMMENT_0 */
        VAR_6[0] = '\0';
        for (VAR_12 = 0; VAR_12 < VAR_14; VAR_12++) {
            if (!VAR_7[VAR_12]) {
                /* COMMENT_1 */
                continue;
            }
            if (VAR_6[0]) {
                LY_CHECK_ERR_RETURN(strlen(VAR_6) + 1 + strlen(VAR_7[VAR_12]->name) > VAR_5, LOGBUF(VAR_7[VAR_12]->name), -1);
                sprintf(VAR_6 + strlen(VAR_6), "" %s"", VAR_7[VAR_12]->name);
            } else {
                LY_CHECK_ERR_RETURN(strlen(VAR_7[VAR_12]->name) > VAR_5, LOGBUF(VAR_7[VAR_12]->name), -1);
                strcpy(VAR_6, VAR_7[VAR_12]->name);
            }
        }
        break;

    case VAR_20:
        VAR_9 = (const char *)VAR_3;
        /* COMMENT_2 */
        if (!strchr(*VAR_2, ':')) {
            LY_CHECK_ERR_RETURN(strlen(VAR_9) + 1 + strlen(*VAR_2) > VAR_5, LOGBUF(*VAR_2), -1);
            sprintf(VAR_6, ""%s:%s"", VAR_9, *VAR_2);
        } else {
            LY_CHECK_ERR_RETURN(strlen(*VAR_2) > VAR_5, LOGBUF(*VAR_2), -1);
            strcpy(VAR_6, *VAR_2);
        }
        break;

    case VAR_21:
        VAR_8 = lyxp_parse_expr(VAR_0, *VAR_2);
        LY_CHECK_ERR_RETURN(!VAR_8, LOGINT(VAR_0), -1);

        VAR_9 = NULL;
        VAR_14 = 0;
        for (VAR_12 = 0; (unsigned)VAR_12 < VAR_8->used; ++VAR_12) {
            VAR_10 = &VAR_8->expr[VAR_8->expr_pos[VAR_12]];

            /* COMMENT_3 */
            if (VAR_12 && ((VAR_11 = VAR_8->expr + VAR_8->expr_pos[VAR_12 - 1] + VAR_8->tok_len[VAR_12 - 1]) != VAR_10)) {
                if (VAR_14 + (VAR_10 - VAR_11) > VAR_5) {
                    lyxp_expr_free(VAR_8);
                    LOGBUF(VAR_11);
                    return -1;
                }
                strncpy(&VAR_6[VAR_14], VAR_11, VAR_10 - VAR_11);
                VAR_14 += VAR_10 - VAR_11;
            }

            if ((VAR_8->tokens[VAR_12] == VAR_22) && (VAR_11 = strnchr(VAR_10, ':', VAR_8->tok_len[VAR_12]))) {
                /* COMMENT_4 */
                ++VAR_11;
                VAR_13 = VAR_11 - VAR_10;

                if (!VAR_9 || strncmp(VAR_10, VAR_9, VAR_13)) {
                    /* COMMENT_5 */
                    if (VAR_14 + VAR_13 > VAR_5) {
                        lyxp_expr_free(VAR_8);
                        LOGBUF(VAR_10);
                        return -1;
                    }
                    strncpy(&VAR_6[VAR_14], VAR_10, VAR_13);
                    VAR_14 += VAR_13;
                }
                VAR_9 = VAR_10;

                /* COMMENT_6 */
                if (VAR_14 + (VAR_8->tok_len[VAR_12] - VAR_13) > VAR_5) {
                    lyxp_expr_free(VAR_8);
                    LOGBUF(VAR_11);
                    return -1;
                }
                strncpy(&VAR_6[VAR_14], VAR_11, VAR_8->tok_len[VAR_12] - VAR_13);
                VAR_14 += VAR_8->tok_len[VAR_12] - VAR_13;
            } else {
                if (VAR_14 + VAR_8->tok_len[VAR_12] > VAR_5) {
                    lyxp_expr_free(VAR_8);
                    LOGBUF(&VAR_8->expr[VAR_8->expr_pos[VAR_12]]);
                    return -1;
                }
                strncpy(&VAR_6[VAR_14], &VAR_8->expr[VAR_8->expr_pos[VAR_12]], VAR_8->tok_len[VAR_12]);
                VAR_14 += VAR_8->tok_len[VAR_12];
            }
        }
        if (VAR_14 > VAR_5) {
            LOGINT(VAR_0);
            lyxp_expr_free(VAR_8);
            return -1;
        }
        VAR_6[VAR_14] = '\0';

        lyxp_expr_free(VAR_8);
        break;

    case VAR_23:
        VAR_15 = *((int64_t *)VAR_3);
        VAR_17 = *((uint8_t *)VAR_4);
        if (VAR_15) {
            VAR_14 = sprintf(VAR_6, ""%""VAR_24"" "", VAR_15);
            if ( (VAR_15 > 0 && (VAR_14 - 1) <= VAR_17)
                 || (VAR_14 - 2) <= VAR_17 ) {
                /* COMMENT_7 */
                                                                              
                                            
                                                                
                VAR_14 = sprintf(VAR_6, ""%0*""VAR_24"" "", (VAR_15 > 0) ? (VAR_17 + 1) : (VAR_17 + 2), VAR_15);
            }
            for (VAR_12 = VAR_17, VAR_13 = 1; VAR_12 > 0 ; VAR_12--) {
                if (VAR_13 && VAR_12 > 1 && VAR_6[VAR_14 - 2] == '0') {
                    /* COMMENT_11 */
                    VAR_6[VAR_14 - 1] = '\0';
                } else {
                    VAR_13 = 0;
                    VAR_6[VAR_14 - 1] = VAR_6[VAR_14 - 2];
                }
                VAR_14--;
            }
            VAR_6[VAR_14 - 1] = '.';
        } else {
            /* COMMENT_12 */
            sprintf(VAR_6, ""0.0"");
        }
        break;

    case VAR_25:
    case VAR_26:
    case VAR_27:
    case VAR_28:
        VAR_15 = *((int64_t *)VAR_3);
        sprintf(VAR_6, ""%""VAR_24, VAR_15);
        break;

    case VAR_29:
    case VAR_30:
    case VAR_31:
    case VAR_32:
        VAR_16 = *((uint64_t *)VAR_3);
        sprintf(VAR_6, ""%""VAR_33, VAR_16);
        break;

    default:
        /* COMMENT_13 */
        return 0;
    }

    if (strcmp(VAR_6, *VAR_2)) {
        lydict_remove(VAR_0, *VAR_2);
        *VAR_2 = lydict_insert(VAR_0, VAR_6, 0);
        return 1;
    }

    return 0;

#undef LOGBUF
}",CESNET/libyang/6980afae2ff9fcd6d67508b0a3f694d75fd059d6/parser.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -38,8 +38,10 @@
         module_name = (const char *)data1;
         /* identity must always have a prefix */
         if (!strchr(*value, ':')) {
+            LY_CHECK_ERR_RETURN(strlen(module_name) + 1 + strlen(*value) > buf_len, LOGBUF(*value), -1);
             sprintf(buf, ""%s:%s"", module_name, *value);
         } else {
+            LY_CHECK_ERR_RETURN(strlen(*value) > buf_len, LOGBUF(*value), -1);
             strcpy(buf, *value);
         }
         break;","{'deleted_lines': [], 'added_lines': ['            LY_CHECK_ERR_RETURN(strlen(module_name) + 1 + strlen(*value) > buf_len, LOGBUF(*value), -1);', '            LY_CHECK_ERR_RETURN(strlen(*value) > buf_len, LOGBUF(*value), -1);']}",True,"In all versions of libyang before 1.0-r5, a stack-based buffer overflow was discovered in the way libyang parses YANG files with a leaf of type ""identityref"". An application that uses libyang to parse untrusted YANG files may be vulnerable to this flaw, which would allow an attacker to cause a denial of service or possibly gain code execution.",9.8,CRITICAL,3,valid,2019-12-04T10:00:33Z,3
CVE-2019-14868,['CWE-77'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,att/ast,Harden env var imports,c7de8b641266bac7c77942239ac659edfee9ecd2,https://github.com/att/ast/commit/c7de8b641266bac7c77942239ac659edfee9ecd2,src/cmd/ksh93/sh/arith.c,sh_strnum,"Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {
Sfdouble_t d;
char *last;
if (*str == 0) {
if (ptr) *ptr = (char *)str;
return 0;
}
errno = 0;
d = number(str, &last, shp->inarith ? 0 : 10, NULL);
if (*last) {
if (*last != '.' || last[1] != '.') {
d = strval(shp, str, &last, arith, mode);
Varsubscript = true;
}
if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);
} else if (!d && *str == '-') {
d = -0.0;
}
if (ptr) *ptr = last;
return d;
}","Sfdouble_t sh_strnum(Shell_t *VAR_0, const char *VAR_1, char **VAR_2, int VAR_3) {
Sfdouble_t VAR_4;
char *VAR_5;
if (*VAR_1 == 0) {
if (VAR_2) *VAR_2 = (char *)VAR_1;
return 0;
}
VAR_6 = 0;
VAR_4 = number(VAR_1, &VAR_5, VAR_0->inarith ? 0 : 10, NULL);
if (*VAR_5) {
if (*VAR_5 != '.' || VAR_5[1] != '.') {
VAR_4 = strval(VAR_0, VAR_1, &VAR_5, VAR_7, VAR_3);
VAR_8 = true;
}
if (!VAR_2 && *VAR_5 && VAR_3 > 0) errormsg(VAR_9, ERROR_exit(1), VAR_10, *VAR_5, VAR_1);
} else if (!VAR_4 && *VAR_1 == '-') {
VAR_4 = -0.0;
}
if (VAR_2) *VAR_2 = VAR_5;
return VAR_4;
}",att/ast/c7de8b641266bac7c77942239ac659edfee9ecd2/arith.c/vul/before/0.json,"Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {
    Sfdouble_t d;
    char *last;

    if (*str == 0) {
        d = 0.0;
        last = (char *)str;
    } else {
        d = number(str, &last, shp->inarith ? 0 : 10, NULL);
        if (*last && !shp->inarith && sh_isstate(shp, SH_INIT)) {
            // This call is to handle ""base#value"" literals if we're importing untrusted env vars.
            d = number(str, &last, 0, NULL);
        }
        if (*last) {
            if (sh_isstate(shp, SH_INIT)) {
                // Initializing means importing untrusted env vars. Since the string does not appear
                // to be a recognized numeric literal give up. We can't safely call strval() since
                // that allows arbitrary expressions which would create a security vulnerability.
                d = 0.0;
            } else {
                if (*last != '.' || last[1] != '.') {
                    d = strval(shp, str, &last, arith, mode);
                    Varsubscript = true;
                }
                if (!ptr && *last && mode > 0) {
                    errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);
                }
            }
        } else if (d == 0.0 && *str == '-') {
            d = -0.0;
        }
    }
    if (ptr) *ptr = last;
    return d;
}","Sfdouble_t sh_strnum(Shell_t *VAR_0, const char *VAR_1, char **VAR_2, int VAR_3) {
    Sfdouble_t VAR_4;
    char *VAR_5;

    if (*VAR_1 == 0) {
        VAR_4 = 0.0;
        VAR_5 = (char *)VAR_1;
    } else {
        VAR_4 = number(VAR_1, &VAR_5, VAR_0->inarith ? 0 : 10, NULL);
        if (*VAR_5 && !VAR_0->inarith && sh_isstate(VAR_0, VAR_6)) {
            /* COMMENT_0 */
            VAR_4 = number(VAR_1, &VAR_5, 0, NULL);
        }
        if (*VAR_5) {
            if (sh_isstate(VAR_0, VAR_6)) {
                /* COMMENT_1 */
                /* COMMENT_2 */
                /* COMMENT_3 */
                VAR_4 = 0.0;
            } else {
                if (*VAR_5 != '.' || VAR_5[1] != '.') {
                    VAR_4 = strval(VAR_0, VAR_1, &VAR_5, VAR_7, VAR_3);
                    VAR_8 = true;
                }
                if (!VAR_2 && *VAR_5 && VAR_3 > 0) {
                    errormsg(VAR_9, ERROR_exit(1), VAR_10, *VAR_5, VAR_1);
                }
            }
        } else if (VAR_4 == 0.0 && *VAR_1 == '-') {
            VAR_4 = -0.0;
        }
    }
    if (VAR_2) *VAR_2 = VAR_5;
    return VAR_4;
}",att/ast/c7de8b641266bac7c77942239ac659edfee9ecd2/arith.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,19 +3,32 @@
     char *last;
 
     if (*str == 0) {
-        if (ptr) *ptr = (char *)str;
-        return 0;
-    }
-    errno = 0;
-    d = number(str, &last, shp->inarith ? 0 : 10, NULL);
-    if (*last) {
-        if (*last != '.' || last[1] != '.') {
-            d = strval(shp, str, &last, arith, mode);
-            Varsubscript = true;
+        d = 0.0;
+        last = (char *)str;
+    } else {
+        d = number(str, &last, shp->inarith ? 0 : 10, NULL);
+        if (*last && !shp->inarith && sh_isstate(shp, SH_INIT)) {
+            // This call is to handle ""base#value"" literals if we're importing untrusted env vars.
+            d = number(str, &last, 0, NULL);
         }
-        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);
-    } else if (!d && *str == '-') {
-        d = -0.0;
+        if (*last) {
+            if (sh_isstate(shp, SH_INIT)) {
+                // Initializing means importing untrusted env vars. Since the string does not appear
+                // to be a recognized numeric literal give up. We can't safely call strval() since
+                // that allows arbitrary expressions which would create a security vulnerability.
+                d = 0.0;
+            } else {
+                if (*last != '.' || last[1] != '.') {
+                    d = strval(shp, str, &last, arith, mode);
+                    Varsubscript = true;
+                }
+                if (!ptr && *last && mode > 0) {
+                    errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);
+                }
+            }
+        } else if (d == 0.0 && *str == '-') {
+            d = -0.0;
+        }
     }
     if (ptr) *ptr = last;
     return d;","{'deleted_lines': ['        if (ptr) *ptr = (char *)str;', '        return 0;', '    }', '    errno = 0;', '    d = number(str, &last, shp->inarith ? 0 : 10, NULL);', '    if (*last) {', ""        if (*last != '.' || last[1] != '.') {"", '            d = strval(shp, str, &last, arith, mode);', '            Varsubscript = true;', '        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);', ""    } else if (!d && *str == '-') {"", '        d = -0.0;'], 'added_lines': ['        d = 0.0;', '        last = (char *)str;', '    } else {', '        d = number(str, &last, shp->inarith ? 0 : 10, NULL);', '        if (*last && !shp->inarith && sh_isstate(shp, SH_INIT)) {', '            // This call is to handle ""base#value"" literals if we\'re importing untrusted env vars.', '            d = number(str, &last, 0, NULL);', '        if (*last) {', '            if (sh_isstate(shp, SH_INIT)) {', '                // Initializing means importing untrusted env vars. Since the string does not appear', ""                // to be a recognized numeric literal give up. We can't safely call strval() since"", '                // that allows arbitrary expressions which would create a security vulnerability.', '                d = 0.0;', '            } else {', ""                if (*last != '.' || last[1] != '.') {"", '                    d = strval(shp, str, &last, arith, mode);', '                    Varsubscript = true;', '                }', '                if (!ptr && *last && mode > 0) {', '                    errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);', '                }', '            }', ""        } else if (d == 0.0 && *str == '-') {"", '            d = -0.0;', '        }']}",True,"In ksh version 20120801, a flaw was found in the way it evaluates certain environment variables. An attacker could use this flaw to override or bypass environment restrictions to execute shell commands. Services and applications that allow remote unauthenticated attackers to provide one of those environment variables could allow them to exploit this issue remotely.",7.4,HIGH,2,valid,2019-12-13T02:46:50Z,3
CVE-2019-20176,['CWE-400'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,jedisct1/pure-ftpd,"listdir(): reuse a single buffer to store every file name to display

Allocating a new buffer for each entry is useless.

And as these buffers are allocated on the stack, on systems with a
small stack size, with many entries, the limit can easily be reached,
causing a stack exhaustion and aborting the user session.

Reported by Antonio Morales from the GitHub Security Lab team, thanks!",aea56f4bcb9948d456f3fae4d044fd3fa2e19706,https://github.com/jedisct1/pure-ftpd/commit/aea56f4bcb9948d456f3fae4d044fd3fa2e19706,src/ls.c,listdir,"static void listdir(unsigned int depth, int f, void * const tls_fd,
const char *name)
{
PureFileInfo *dir;
char *names;
PureFileInfo *s;
PureFileInfo *r;
int d;
if (depth >= max_ls_depth || matches >= max_ls_files) {
return;
}
if ((dir = sreaddir(&names)) == NULL) {
addreply(226, MSG_CANT_READ_FILE, name);
return;
}
s = dir;
while (s->name_offset != (size_t) -1) {
d = 0;
if (FI_NAME(s)[0] != '.') {
d = listfile(s, NULL);
} else if (opt_a) {
if (FI_NAME(s)[1] == 0 ||
(FI_NAME(s)[1] == '.' && FI_NAME(s)[2] == 0)) {
listfile(s, NULL);
} else {
d = listfile(s, NULL);
}
}
if (!d) {
s->name_offset = (size_t) -1;
}
s++;
}
outputfiles(f, tls_fd);
r = dir;
while (opt_R && r != s) {
if (r->name_offset != (size_t) -1 && !chdir(FI_NAME(r))) {
char *alloca_subdir;
const size_t sizeof_subdir = PATH_MAX + 1U;
if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {
goto toomany;
}
if (SNCHECK(snprintf(alloca_subdir, sizeof_subdir, ""%s/%s"",
name, FI_NAME(r)), sizeof_subdir)) {
goto nolist;
}
wrstr(f, tls_fd, ""\r\n\r\n"");
wrstr(f, tls_fd, alloca_subdir);
wrstr(f, tls_fd, "":\r\n\r\n"");
listdir(depth + 1U, f, tls_fd, alloca_subdir);
nolist:
ALLOCA_FREE(alloca_subdir);
if (matches >= max_ls_files) {
goto toomany;
}
if (chdir("".."")) {    
if (chdir(wd) || chdir(name)) {    
die(421, LOG_ERR, ""chdir: %s"", strerror(errno));
}
}
}
r++;
}
toomany:
free(names);
free(dir);
names = NULL;
}","static void listdir(unsigned int VAR_0, int VAR_1, void * const VAR_2,
const char *VAR_3)
{
PureFileInfo *VAR_4;
char *VAR_5;
PureFileInfo *VAR_6;
PureFileInfo *VAR_7;
int VAR_8;
if (VAR_0 >= VAR_9 || VAR_10 >= VAR_11) {
return;
}
if ((VAR_4 = sreaddir(&VAR_5)) == NULL) {
addreply(226, VAR_12, VAR_3);
return;
}
VAR_6 = VAR_4;
while (VAR_6->name_offset != (size_t) -1) {
VAR_8 = 0;
if (FI_NAME(VAR_6)[0] != '.') {
VAR_8 = listfile(VAR_6, NULL);
} else if (VAR_13) {
if (FI_NAME(VAR_6)[1] == 0 ||
(FI_NAME(VAR_6)[1] == '.' && FI_NAME(VAR_6)[2] == 0)) {
listfile(VAR_6, NULL);
} else {
VAR_8 = listfile(VAR_6, NULL);
}
}
if (!VAR_8) {
VAR_6->name_offset = (size_t) -1;
}
VAR_6++;
}
outputfiles(VAR_1, VAR_2);
VAR_7 = VAR_4;
while (VAR_14 && VAR_7 != VAR_6) {
if (VAR_7->name_offset != (size_t) -1 && !chdir(FI_NAME(VAR_7))) {
char *VAR_15;
const size_t VAR_16 = VAR_17 + 1U;
if ((VAR_15 = ALLOCA(VAR_16)) == NULL) {
goto toomany;
}
if (SNCHECK(snprintf(VAR_15, VAR_16, ""%s/%s"",
VAR_3, FI_NAME(VAR_7)), VAR_16)) {
goto nolist;
}
wrstr(VAR_1, VAR_2, ""\r\n\r\n"");
wrstr(VAR_1, VAR_2, VAR_15);
wrstr(VAR_1, VAR_2, "":\r\n\r\n"");
listdir(VAR_0 + 1U, VAR_1, VAR_2, VAR_15);
nolist:
ALLOCA_FREE(VAR_15);
if (VAR_10 >= VAR_11) {
goto toomany;
}
if (chdir("".."")) {    
if (chdir(VAR_18) || chdir(VAR_3)) {    
die(421, VAR_19, ""chdir: %s"", strerror(VAR_20));
}
}
}
VAR_7++;
}
toomany:
free(VAR_5);
free(VAR_4);
VAR_5 = NULL;
}",jedisct1/pure-ftpd/aea56f4bcb9948d456f3fae4d044fd3fa2e19706/ls.c/vul/before/0.json,"static void listdir(unsigned int depth, int f, void * const tls_fd,
                    const char *name)
{
    PureFileInfo *dir;
    char *names;
    PureFileInfo *s;
    PureFileInfo *r;
    char *alloca_subdir;
    size_t sizeof_subdir;
    int d;

    if (depth >= max_ls_depth || matches >= max_ls_files) {
        return;
    }
    if ((dir = sreaddir(&names)) == NULL) {
        addreply(226, MSG_CANT_READ_FILE, name);
        return;
    }
    s = dir;
    while (s->name_offset != (size_t) -1) {
        d = 0;
        if (FI_NAME(s)[0] != '.') {
            d = listfile(s, NULL);
        } else if (opt_a) {
            if (FI_NAME(s)[1] == 0 ||
                (FI_NAME(s)[1] == '.' && FI_NAME(s)[2] == 0)) {
                listfile(s, NULL);
            } else {
                d = listfile(s, NULL);
            }
        }
        if (!d) {
            s->name_offset = (size_t) -1;
        }
        s++;
    }
    outputfiles(f, tls_fd);
    r = dir;
    sizeof_subdir = PATH_MAX + 1U;
    if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {
        goto toomany;
    }
    while (opt_R && r != s) {
        if (r->name_offset != (size_t) -1 && !chdir(FI_NAME(r))) {
            if (SNCHECK(snprintf(alloca_subdir, sizeof_subdir, ""%s/%s"",
                                 name, FI_NAME(r)), sizeof_subdir)) {
                goto nolist;
            }
            wrstr(f, tls_fd, ""\r\n\r\n"");
            wrstr(f, tls_fd, alloca_subdir);
            wrstr(f, tls_fd, "":\r\n\r\n"");
            listdir(depth + 1U, f, tls_fd, alloca_subdir);

            nolist:
            if (matches >= max_ls_files) {
                goto toomany;
            }
            if (chdir("".."")) {    /* defensive in the extreme... */
                if (chdir(wd) || chdir(name)) {    /* someone rmdir()'d it? */
                    die(421, LOG_ERR, ""chdir: %s"", strerror(errno));
                }
            }
        }
        r++;
    }
    toomany:
    ALLOCA_FREE(alloca_subdir);
    free(names);
    free(dir);
    names = NULL;
}","static void listdir(unsigned int VAR_0, int VAR_1, void * const VAR_2,
                    const char *VAR_3)
{
    PureFileInfo *VAR_4;
    char *VAR_5;
    PureFileInfo *VAR_6;
    PureFileInfo *VAR_7;
    char *VAR_8;
    size_t VAR_9;
    int VAR_10;

    if (VAR_0 >= VAR_11 || VAR_12 >= VAR_13) {
        return;
    }
    if ((VAR_4 = sreaddir(&VAR_5)) == NULL) {
        addreply(226, VAR_14, VAR_3);
        return;
    }
    VAR_6 = VAR_4;
    while (VAR_6->name_offset != (size_t) -1) {
        VAR_10 = 0;
        if (FI_NAME(VAR_6)[0] != '.') {
            VAR_10 = listfile(VAR_6, NULL);
        } else if (VAR_15) {
            if (FI_NAME(VAR_6)[1] == 0 ||
                (FI_NAME(VAR_6)[1] == '.' && FI_NAME(VAR_6)[2] == 0)) {
                listfile(VAR_6, NULL);
            } else {
                VAR_10 = listfile(VAR_6, NULL);
            }
        }
        if (!VAR_10) {
            VAR_6->name_offset = (size_t) -1;
        }
        VAR_6++;
    }
    outputfiles(VAR_1, VAR_2);
    VAR_7 = VAR_4;
    VAR_9 = VAR_16 + 1U;
    if ((VAR_8 = ALLOCA(VAR_9)) == NULL) {
        goto toomany;
    }
    while (VAR_17 && VAR_7 != VAR_6) {
        if (VAR_7->name_offset != (size_t) -1 && !chdir(FI_NAME(VAR_7))) {
            if (SNCHECK(snprintf(VAR_8, VAR_9, ""%s/%s"",
                                 VAR_3, FI_NAME(VAR_7)), VAR_9)) {
                goto nolist;
            }
            wrstr(VAR_1, VAR_2, ""\r\n\r\n"");
            wrstr(VAR_1, VAR_2, VAR_8);
            wrstr(VAR_1, VAR_2, "":\r\n\r\n"");
            listdir(VAR_0 + 1U, VAR_1, VAR_2, VAR_8);

            nolist:
            if (VAR_12 >= VAR_13) {
                goto toomany;
            }
            if (chdir("".."")) {    /* COMMENT_0 */
                if (chdir(VAR_18) || chdir(VAR_3)) {    /* COMMENT_1 */
                    die(421, VAR_19, ""chdir: %s"", strerror(VAR_20));
                }
            }
        }
        VAR_7++;
    }
    toomany:
    ALLOCA_FREE(VAR_8);
    free(VAR_5);
    free(VAR_4);
    VAR_5 = NULL;
}",jedisct1/pure-ftpd/aea56f4bcb9948d456f3fae4d044fd3fa2e19706/ls.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,6 +5,8 @@
     char *names;
     PureFileInfo *s;
     PureFileInfo *r;
+    char *alloca_subdir;
+    size_t sizeof_subdir;
     int d;
 
     if (depth >= max_ls_depth || matches >= max_ls_files) {
@@ -34,14 +36,12 @@
     }
     outputfiles(f, tls_fd);
     r = dir;
+    sizeof_subdir = PATH_MAX + 1U;
+    if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {
+        goto toomany;
+    }
     while (opt_R && r != s) {
         if (r->name_offset != (size_t) -1 && !chdir(FI_NAME(r))) {
-            char *alloca_subdir;
-            const size_t sizeof_subdir = PATH_MAX + 1U;
-
-            if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {
-                goto toomany;
-            }
             if (SNCHECK(snprintf(alloca_subdir, sizeof_subdir, ""%s/%s"",
                                  name, FI_NAME(r)), sizeof_subdir)) {
                 goto nolist;
@@ -50,8 +50,8 @@
             wrstr(f, tls_fd, alloca_subdir);
             wrstr(f, tls_fd, "":\r\n\r\n"");
             listdir(depth + 1U, f, tls_fd, alloca_subdir);
+
             nolist:
-            ALLOCA_FREE(alloca_subdir);
             if (matches >= max_ls_files) {
                 goto toomany;
             }
@@ -64,6 +64,7 @@
         r++;
     }
     toomany:
+    ALLOCA_FREE(alloca_subdir);
     free(names);
     free(dir);
     names = NULL;","{'deleted_lines': ['            char *alloca_subdir;', '            const size_t sizeof_subdir = PATH_MAX + 1U;', '', '            if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {', '                goto toomany;', '            }', '            ALLOCA_FREE(alloca_subdir);'], 'added_lines': ['    char *alloca_subdir;', '    size_t sizeof_subdir;', '    sizeof_subdir = PATH_MAX + 1U;', '    if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {', '        goto toomany;', '    }', '', '    ALLOCA_FREE(alloca_subdir);']}",True,"In Pure-FTPd 1.0.49, a stack exhaustion issue was discovered in the listdir function in ls.c.",7.5,HIGH,2,valid,2019-12-30T16:40:04Z,3
CVE-2019-20205,['CWE-190'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,saitoha/libsixel,Prevent an integer overflow problem(#127),554335482137b4b4c1da7d461d884aea1d9d689f,https://github.com/saitoha/libsixel/commit/554335482137b4b4c1da7d461d884aea1d9d689f,src/frame.c,sixel_frame_clip,"SIXELAPI SIXELSTATUS
sixel_frame_clip(
sixel_frame_t *frame,
int x,
int y,
int width,
int height
)
{
SIXELSTATUS status = SIXEL_FALSE;
unsigned char *normalized_pixels;
sixel_frame_ref(frame);
switch (frame->pixelformat) {
case SIXEL_PIXELFORMAT_PAL1:
case SIXEL_PIXELFORMAT_PAL2:
case SIXEL_PIXELFORMAT_PAL4:
case SIXEL_PIXELFORMAT_G1:
case SIXEL_PIXELFORMAT_G2:
case SIXEL_PIXELFORMAT_G4:
normalized_pixels = (unsigned char *)sixel_allocator_malloc(frame->allocator,
(size_t)(frame->width * frame->height));
status = sixel_helper_normalize_pixelformat(normalized_pixels,
&frame->pixelformat,
frame->pixels,
frame->pixelformat,
frame->width,
frame->height);
if (SIXEL_FAILED(status)) {
sixel_allocator_free(frame->allocator, normalized_pixels);
goto end;
}
sixel_allocator_free(frame->allocator, frame->pixels);
frame->pixels = normalized_pixels;
break;
default:
break;
}
status = clip(frame->pixels,
frame->width,
frame->height,
frame->pixelformat,
x,
y,
width,
height);
if (SIXEL_FAILED(status)) {
goto end;
}
frame->width = width;
frame->height = height;
status = SIXEL_OK;
end:
sixel_frame_unref(frame);
return status;
}","SIXELAPI VAR_0
sixel_frame_clip(
sixel_frame_t *VAR_1,
int VAR_2,
int VAR_3,
int VAR_4,
int VAR_5
)
{
SIXELSTATUS VAR_6 = VAR_7;
unsigned char *VAR_8;
sixel_frame_ref(VAR_1);
switch (VAR_1->pixelformat) {
case VAR_9:
case VAR_10:
case VAR_11:
case VAR_12:
case VAR_13:
case VAR_14:
VAR_8 = (unsigned char *)sixel_allocator_malloc(VAR_1->allocator,
(size_t)(VAR_1->width * VAR_1->height));
VAR_6 = sixel_helper_normalize_pixelformat(VAR_8,
&VAR_1->pixelformat,
VAR_1->pixels,
VAR_1->pixelformat,
VAR_1->width,
VAR_1->height);
if (SIXEL_FAILED(VAR_6)) {
sixel_allocator_free(VAR_1->allocator, VAR_8);
goto end;
}
sixel_allocator_free(VAR_1->allocator, VAR_1->pixels);
VAR_1->pixels = VAR_8;
break;
default:
break;
}
VAR_6 = clip(VAR_1->pixels,
VAR_1->width,
VAR_1->height,
VAR_1->pixelformat,
VAR_2,
VAR_3,
VAR_4,
VAR_5);
if (SIXEL_FAILED(VAR_6)) {
goto end;
}
VAR_1->width = VAR_4;
VAR_1->height = VAR_5;
VAR_6 = VAR_15;
end:
sixel_frame_unref(VAR_1);
return VAR_6;
}",,"SIXELAPI SIXELSTATUS
sixel_frame_clip(
    sixel_frame_t *frame,
    int x,
    int y,
    int width,
    int height
)
{
    SIXELSTATUS status = SIXEL_FALSE;
    unsigned char *normalized_pixels;

    sixel_frame_ref(frame);

    /* check parameters */
    if (width <= 0) {
        sixel_helper_set_additional_message(
            ""sixel_frame_clip: an invalid width parameter detected."");
        status = SIXEL_BAD_INPUT;
        goto end;
    }
    if (height <= 0) {
        sixel_helper_set_additional_message(
            ""sixel_frame_clip: an invalid width parameter detected."");
        status = SIXEL_BAD_INPUT;
        goto end;
    }
    if (width > SIXEL_WIDTH_LIMIT) {
        sixel_helper_set_additional_message(
            ""sixel_frame_clip: given width parameter is too huge."");
        status = SIXEL_BAD_INPUT;
        goto end;
    }
    if (height > SIXEL_HEIGHT_LIMIT) {
        sixel_helper_set_additional_message(
            ""sixel_frame_clip: given height parameter is too huge."");
        status = SIXEL_BAD_INPUT;
        goto end;
    }

    switch (frame->pixelformat) {
    case SIXEL_PIXELFORMAT_PAL1:
    case SIXEL_PIXELFORMAT_PAL2:
    case SIXEL_PIXELFORMAT_PAL4:
    case SIXEL_PIXELFORMAT_G1:
    case SIXEL_PIXELFORMAT_G2:
    case SIXEL_PIXELFORMAT_G4:
        normalized_pixels = (unsigned char *)sixel_allocator_malloc(frame->allocator,
                                                                    (size_t)(frame->width * frame->height));
        status = sixel_helper_normalize_pixelformat(normalized_pixels,
                                                    &frame->pixelformat,
                                                    frame->pixels,
                                                    frame->pixelformat,
                                                    frame->width,
                                                    frame->height);
        if (SIXEL_FAILED(status)) {
            sixel_allocator_free(frame->allocator, normalized_pixels);
            goto end;
        }
        sixel_allocator_free(frame->allocator, frame->pixels);
        frame->pixels = normalized_pixels;
        break;
    default:
        break;
    }

    status = clip(frame->pixels,
                  frame->width,
                  frame->height,
                  frame->pixelformat,
                  x,
                  y,
                  width,
                  height);
    if (SIXEL_FAILED(status)) {
        goto end;
    }
    frame->width = width;
    frame->height = height;

    status = SIXEL_OK;

end:
    sixel_frame_unref(frame);

    return status;
}","SIXELAPI VAR_0
sixel_frame_clip(
    sixel_frame_t *VAR_1,
    int VAR_2,
    int VAR_3,
    int VAR_4,
    int VAR_5
)
{
    SIXELSTATUS VAR_6 = VAR_7;
    unsigned char *VAR_8;

    sixel_frame_ref(VAR_1);

    /* COMMENT_0 */
    if (VAR_4 <= 0) {
        sixel_helper_set_additional_message(
            ""sixel_frame_clip: an invalid width parameter detected."");
        VAR_6 = VAR_9;
        goto end;
    }
    if (VAR_5 <= 0) {
        sixel_helper_set_additional_message(
            ""sixel_frame_clip: an invalid width parameter detected."");
        VAR_6 = VAR_9;
        goto end;
    }
    if (VAR_4 > VAR_10) {
        sixel_helper_set_additional_message(
            ""sixel_frame_clip: given width parameter is too huge."");
        VAR_6 = VAR_9;
        goto end;
    }
    if (VAR_5 > VAR_11) {
        sixel_helper_set_additional_message(
            ""sixel_frame_clip: given height parameter is too huge."");
        VAR_6 = VAR_9;
        goto end;
    }

    switch (VAR_1->pixelformat) {
    case VAR_12:
    case VAR_13:
    case VAR_14:
    case VAR_15:
    case VAR_16:
    case VAR_17:
        VAR_8 = (unsigned char *)sixel_allocator_malloc(VAR_1->allocator,
                                                                    (size_t)(VAR_1->width * VAR_1->height));
        VAR_6 = sixel_helper_normalize_pixelformat(VAR_8,
                                                    &VAR_1->pixelformat,
                                                    VAR_1->pixels,
                                                    VAR_1->pixelformat,
                                                    VAR_1->width,
                                                    VAR_1->height);
        if (SIXEL_FAILED(VAR_6)) {
            sixel_allocator_free(VAR_1->allocator, VAR_8);
            goto end;
        }
        sixel_allocator_free(VAR_1->allocator, VAR_1->pixels);
        VAR_1->pixels = VAR_8;
        break;
    default:
        break;
    }

    VAR_6 = clip(VAR_1->pixels,
                  VAR_1->width,
                  VAR_1->height,
                  VAR_1->pixelformat,
                  VAR_2,
                  VAR_3,
                  VAR_4,
                  VAR_5);
    if (SIXEL_FAILED(VAR_6)) {
        goto end;
    }
    VAR_1->width = VAR_4;
    VAR_1->height = VAR_5;

    VAR_6 = VAR_18;

end:
    sixel_frame_unref(VAR_1);

    return VAR_6;
}",,"--- func_before
+++ func_after
@@ -11,6 +11,32 @@
     unsigned char *normalized_pixels;
 
     sixel_frame_ref(frame);
+
+    /* check parameters */
+    if (width <= 0) {
+        sixel_helper_set_additional_message(
+            ""sixel_frame_clip: an invalid width parameter detected."");
+        status = SIXEL_BAD_INPUT;
+        goto end;
+    }
+    if (height <= 0) {
+        sixel_helper_set_additional_message(
+            ""sixel_frame_clip: an invalid width parameter detected."");
+        status = SIXEL_BAD_INPUT;
+        goto end;
+    }
+    if (width > SIXEL_WIDTH_LIMIT) {
+        sixel_helper_set_additional_message(
+            ""sixel_frame_clip: given width parameter is too huge."");
+        status = SIXEL_BAD_INPUT;
+        goto end;
+    }
+    if (height > SIXEL_HEIGHT_LIMIT) {
+        sixel_helper_set_additional_message(
+            ""sixel_frame_clip: given height parameter is too huge."");
+        status = SIXEL_BAD_INPUT;
+        goto end;
+    }
 
     switch (frame->pixelformat) {
     case SIXEL_PIXELFORMAT_PAL1:","{'deleted_lines': [], 'added_lines': ['', '    /* check parameters */', '    if (width <= 0) {', '        sixel_helper_set_additional_message(', '            ""sixel_frame_clip: an invalid width parameter detected."");', '        status = SIXEL_BAD_INPUT;', '        goto end;', '    }', '    if (height <= 0) {', '        sixel_helper_set_additional_message(', '            ""sixel_frame_clip: an invalid width parameter detected."");', '        status = SIXEL_BAD_INPUT;', '        goto end;', '    }', '    if (width > SIXEL_WIDTH_LIMIT) {', '        sixel_helper_set_additional_message(', '            ""sixel_frame_clip: given width parameter is too huge."");', '        status = SIXEL_BAD_INPUT;', '        goto end;', '    }', '    if (height > SIXEL_HEIGHT_LIMIT) {', '        sixel_helper_set_additional_message(', '            ""sixel_frame_clip: given height parameter is too huge."");', '        status = SIXEL_BAD_INPUT;', '        goto end;', '    }']}",True,libsixel 1.8.4 has an integer overflow in sixel_frame_resize in frame.c.,8.8,HIGH,2,valid,2019-12-31T23:12:16Z,3
CVE-2019-20205,['CWE-190'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,saitoha/libsixel,Prevent an integer overflow problem(#127),554335482137b4b4c1da7d461d884aea1d9d689f,https://github.com/saitoha/libsixel/commit/554335482137b4b4c1da7d461d884aea1d9d689f,src/frame.c,sixel_frame_resize,"SIXELAPI SIXELSTATUS
sixel_frame_resize(
sixel_frame_t *frame,
int width,
int height,
int method_for_resampling
)
{
SIXELSTATUS status = SIXEL_FALSE;
size_t size;
unsigned char *scaled_frame = NULL;
sixel_frame_ref(frame);
status = sixel_frame_convert_to_rgb888(frame);
if (SIXEL_FAILED(status)) {
goto end;
}
size = (size_t)(width * height * 3);
scaled_frame = (unsigned char *)sixel_allocator_malloc(frame->allocator, size);
if (scaled_frame == NULL) {
sixel_helper_set_additional_message(
""sixel_frame_resize: sixel_allocator_malloc() failed."");
status = SIXEL_BAD_ALLOCATION;
goto end;
}
status = sixel_helper_scale_image(
scaled_frame,
frame->pixels,
frame->width,
frame->height,
3,
width,
height,
method_for_resampling,
frame->allocator);
if (SIXEL_FAILED(status)) {
goto end;
}
sixel_allocator_free(frame->allocator, frame->pixels);
frame->pixels = scaled_frame;
frame->width = width;
frame->height = height;
status = SIXEL_OK;
end:
sixel_frame_unref(frame);
return status;
}","SIXELAPI VAR_0
sixel_frame_resize(
sixel_frame_t *VAR_1,
int VAR_2,
int VAR_3,
int VAR_4
)
{
SIXELSTATUS VAR_5 = VAR_6;
size_t VAR_7;
unsigned char *VAR_8 = NULL;
sixel_frame_ref(VAR_1);
VAR_5 = sixel_frame_convert_to_rgb888(VAR_1);
if (SIXEL_FAILED(VAR_5)) {
goto end;
}
VAR_7 = (size_t)(VAR_2 * VAR_3 * 3);
VAR_8 = (unsigned char *)sixel_allocator_malloc(VAR_1->allocator, VAR_7);
if (VAR_8 == NULL) {
sixel_helper_set_additional_message(
""sixel_frame_resize: sixel_allocator_malloc() failed."");
VAR_5 = VAR_9;
goto end;
}
VAR_5 = sixel_helper_scale_image(
VAR_8,
VAR_1->pixels,
VAR_1->width,
VAR_1->height,
3,
VAR_2,
VAR_3,
VAR_4,
VAR_1->allocator);
if (SIXEL_FAILED(VAR_5)) {
goto end;
}
sixel_allocator_free(VAR_1->allocator, VAR_1->pixels);
VAR_1->pixels = VAR_8;
VAR_1->width = VAR_2;
VAR_1->height = VAR_3;
VAR_5 = VAR_10;
end:
sixel_frame_unref(VAR_1);
return VAR_5;
}",,"SIXELAPI SIXELSTATUS
sixel_frame_resize(
    sixel_frame_t *frame,
    int width,
    int height,
    int method_for_resampling
)
{
    SIXELSTATUS status = SIXEL_FALSE;
    size_t size;
    unsigned char *scaled_frame = NULL;

    sixel_frame_ref(frame);

    /* check parameters */
    if (width <= 0) {
        sixel_helper_set_additional_message(
            ""sixel_frame_resize: an invalid width parameter detected."");
        status = SIXEL_BAD_INPUT;
        goto end;
    }
    if (height <= 0) {
        sixel_helper_set_additional_message(
            ""sixel_frame_resize: an invalid width parameter detected."");
        status = SIXEL_BAD_INPUT;
        goto end;
    }
    if (width > SIXEL_WIDTH_LIMIT) {
        sixel_helper_set_additional_message(
            ""sixel_frame_resize: given width parameter is too huge."");
        status = SIXEL_BAD_INPUT;
        goto end;
    }
    if (height > SIXEL_HEIGHT_LIMIT) {
        sixel_helper_set_additional_message(
            ""sixel_frame_resize: given height parameter is too huge."");
        status = SIXEL_BAD_INPUT;
        goto end;
    }

    status = sixel_frame_convert_to_rgb888(frame);
    if (SIXEL_FAILED(status)) {
        goto end;
    }

    size = (size_t)width * (size_t)height * 3UL;
    scaled_frame = (unsigned char *)sixel_allocator_malloc(frame->allocator, size);
    if (scaled_frame == NULL) {
        sixel_helper_set_additional_message(
            ""sixel_frame_resize: sixel_allocator_malloc() failed."");
        status = SIXEL_BAD_ALLOCATION;
        goto end;
    }

    status = sixel_helper_scale_image(
        scaled_frame,
        frame->pixels,
        frame->width,
        frame->height,
        3,
        width,
        height,
        method_for_resampling,
        frame->allocator);
    if (SIXEL_FAILED(status)) {
        goto end;
    }
    sixel_allocator_free(frame->allocator, frame->pixels);
    frame->pixels = scaled_frame;
    frame->width = width;
    frame->height = height;

    status = SIXEL_OK;

end:
    sixel_frame_unref(frame);

    return status;
}","SIXELAPI VAR_0
sixel_frame_resize(
    sixel_frame_t *VAR_1,
    int VAR_2,
    int VAR_3,
    int VAR_4
)
{
    SIXELSTATUS VAR_5 = VAR_6;
    size_t VAR_7;
    unsigned char *VAR_8 = NULL;

    sixel_frame_ref(VAR_1);

    /* COMMENT_0 */
    if (VAR_2 <= 0) {
        sixel_helper_set_additional_message(
            ""sixel_frame_resize: an invalid width parameter detected."");
        VAR_5 = VAR_9;
        goto end;
    }
    if (VAR_3 <= 0) {
        sixel_helper_set_additional_message(
            ""sixel_frame_resize: an invalid width parameter detected."");
        VAR_5 = VAR_9;
        goto end;
    }
    if (VAR_2 > VAR_10) {
        sixel_helper_set_additional_message(
            ""sixel_frame_resize: given width parameter is too huge."");
        VAR_5 = VAR_9;
        goto end;
    }
    if (VAR_3 > VAR_11) {
        sixel_helper_set_additional_message(
            ""sixel_frame_resize: given height parameter is too huge."");
        VAR_5 = VAR_9;
        goto end;
    }

    VAR_5 = sixel_frame_convert_to_rgb888(VAR_1);
    if (SIXEL_FAILED(VAR_5)) {
        goto end;
    }

    VAR_7 = (size_t)VAR_2 * (size_t)VAR_3 * 3UL;
    VAR_8 = (unsigned char *)sixel_allocator_malloc(VAR_1->allocator, VAR_7);
    if (VAR_8 == NULL) {
        sixel_helper_set_additional_message(
            ""sixel_frame_resize: sixel_allocator_malloc() failed."");
        VAR_5 = VAR_12;
        goto end;
    }

    VAR_5 = sixel_helper_scale_image(
        VAR_8,
        VAR_1->pixels,
        VAR_1->width,
        VAR_1->height,
        3,
        VAR_2,
        VAR_3,
        VAR_4,
        VAR_1->allocator);
    if (SIXEL_FAILED(VAR_5)) {
        goto end;
    }
    sixel_allocator_free(VAR_1->allocator, VAR_1->pixels);
    VAR_1->pixels = VAR_8;
    VAR_1->width = VAR_2;
    VAR_1->height = VAR_3;

    VAR_5 = VAR_13;

end:
    sixel_frame_unref(VAR_1);

    return VAR_5;
}",,"--- func_before
+++ func_after
@@ -12,12 +12,38 @@
 
     sixel_frame_ref(frame);
 
+    /* check parameters */
+    if (width <= 0) {
+        sixel_helper_set_additional_message(
+            ""sixel_frame_resize: an invalid width parameter detected."");
+        status = SIXEL_BAD_INPUT;
+        goto end;
+    }
+    if (height <= 0) {
+        sixel_helper_set_additional_message(
+            ""sixel_frame_resize: an invalid width parameter detected."");
+        status = SIXEL_BAD_INPUT;
+        goto end;
+    }
+    if (width > SIXEL_WIDTH_LIMIT) {
+        sixel_helper_set_additional_message(
+            ""sixel_frame_resize: given width parameter is too huge."");
+        status = SIXEL_BAD_INPUT;
+        goto end;
+    }
+    if (height > SIXEL_HEIGHT_LIMIT) {
+        sixel_helper_set_additional_message(
+            ""sixel_frame_resize: given height parameter is too huge."");
+        status = SIXEL_BAD_INPUT;
+        goto end;
+    }
+
     status = sixel_frame_convert_to_rgb888(frame);
     if (SIXEL_FAILED(status)) {
         goto end;
     }
 
-    size = (size_t)(width * height * 3);
+    size = (size_t)width * (size_t)height * 3UL;
     scaled_frame = (unsigned char *)sixel_allocator_malloc(frame->allocator, size);
     if (scaled_frame == NULL) {
         sixel_helper_set_additional_message(","{'deleted_lines': ['    size = (size_t)(width * height * 3);'], 'added_lines': ['    /* check parameters */', '    if (width <= 0) {', '        sixel_helper_set_additional_message(', '            ""sixel_frame_resize: an invalid width parameter detected."");', '        status = SIXEL_BAD_INPUT;', '        goto end;', '    }', '    if (height <= 0) {', '        sixel_helper_set_additional_message(', '            ""sixel_frame_resize: an invalid width parameter detected."");', '        status = SIXEL_BAD_INPUT;', '        goto end;', '    }', '    if (width > SIXEL_WIDTH_LIMIT) {', '        sixel_helper_set_additional_message(', '            ""sixel_frame_resize: given width parameter is too huge."");', '        status = SIXEL_BAD_INPUT;', '        goto end;', '    }', '    if (height > SIXEL_HEIGHT_LIMIT) {', '        sixel_helper_set_additional_message(', '            ""sixel_frame_resize: given height parameter is too huge."");', '        status = SIXEL_BAD_INPUT;', '        goto end;', '    }', '', '    size = (size_t)width * (size_t)height * 3UL;']}",True,libsixel 1.8.4 has an integer overflow in sixel_frame_resize in frame.c.,8.8,HIGH,2,valid,2019-12-31T23:12:16Z,3
CVE-2019-20205,['CWE-190'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,saitoha/libsixel,Prevent an integer overflow problem(#127),554335482137b4b4c1da7d461d884aea1d9d689f,https://github.com/saitoha/libsixel/commit/554335482137b4b4c1da7d461d884aea1d9d689f,src/frame.c,sixel_frame_init,"SIXELAPI SIXELSTATUS
sixel_frame_init(
sixel_frame_t    *frame,        
unsigned char    *pixels,       
int              width,         
int              height,        
int              pixelformat,   
unsigned char    *palette,      
int              ncolors        
)
{
sixel_frame_ref(frame);
frame->pixels = pixels;
frame->width = width;
frame->height = height;
frame->pixelformat = pixelformat;
frame->palette = palette;
frame->ncolors = ncolors;
sixel_frame_unref(frame);
return SIXEL_OK;
}","SIXELAPI VAR_0
sixel_frame_init(
sixel_frame_t    *VAR_1,        
unsigned char    *VAR_2,       
int              VAR_3,         
int              VAR_4,        
int              VAR_5,   
unsigned char    *VAR_6,      
int              VAR_7        
)
{
sixel_frame_ref(VAR_1);
VAR_1->pixels = VAR_2;
VAR_1->width = VAR_3;
VAR_1->height = VAR_4;
VAR_1->pixelformat = VAR_5;
VAR_1->palette = VAR_6;
VAR_1->ncolors = VAR_7;
sixel_frame_unref(VAR_1);
return VAR_8;
}",,"SIXELAPI SIXELSTATUS
sixel_frame_init(
    sixel_frame_t   /* in */ *frame,        /* frame object to be initialize */
    unsigned char   /* in */ *pixels,       /* pixel buffer */
    int             /* in */ width,         /* pixel width of buffer */
    int             /* in */ height,        /* pixel height of buffer */
    int             /* in */ pixelformat,   /* pixelformat of buffer */
    unsigned char   /* in */ *palette,      /* palette for buffer or NULL */
    int             /* in */ ncolors        /* number of palette colors or (-1) */
)
{
    SIXELSTATUS status = SIXEL_FALSE;

    sixel_frame_ref(frame);

    /* check parameters */
    if (width <= 0) {
        sixel_helper_set_additional_message(
            ""sixel_frame_init: an invalid width parameter detected."");
        status = SIXEL_BAD_INPUT;
        goto end;
    }
    if (height <= 0) {
        sixel_helper_set_additional_message(
            ""sixel_frame_init: an invalid width parameter detected."");
        status = SIXEL_BAD_INPUT;
        goto end;
    }
    if (width > SIXEL_WIDTH_LIMIT) {
        sixel_helper_set_additional_message(
            ""sixel_frame_init: given width parameter is too huge."");
        status = SIXEL_BAD_INPUT;
        goto end;
    }
    if (height > SIXEL_HEIGHT_LIMIT) {
        sixel_helper_set_additional_message(
            ""sixel_frame_init: given height parameter is too huge."");
        status = SIXEL_BAD_INPUT;
        goto end;
    }

    frame->pixels = pixels;
    frame->width = width;
    frame->height = height;
    frame->pixelformat = pixelformat;
    frame->palette = palette;
    frame->ncolors = ncolors;

    status = SIXEL_OK;

end:
    sixel_frame_unref(frame);

    return status;
}","SIXELAPI VAR_0
sixel_frame_init(
    sixel_frame_t   /* COMMENT_0 */ *VAR_1,        /* COMMENT_1 */
    unsigned char   /* COMMENT_0 */ *VAR_2,       /* COMMENT_2 */
    int             /* COMMENT_0 */ VAR_3,         /* COMMENT_3 */
    int             /* COMMENT_0 */ VAR_4,        /* COMMENT_4 */
    int             /* COMMENT_0 */ VAR_5,   /* COMMENT_5 */
    unsigned char   /* COMMENT_0 */ *VAR_6,      /* COMMENT_6 */
    int             /* COMMENT_0 */ VAR_7        /* COMMENT_7 */
)
{
    SIXELSTATUS VAR_8 = VAR_9;

    sixel_frame_ref(VAR_1);

    /* COMMENT_8 */
    if (VAR_3 <= 0) {
        sixel_helper_set_additional_message(
            ""sixel_frame_init: an invalid width parameter detected."");
        VAR_8 = VAR_10;
        goto end;
    }
    if (VAR_4 <= 0) {
        sixel_helper_set_additional_message(
            ""sixel_frame_init: an invalid width parameter detected."");
        VAR_8 = VAR_10;
        goto end;
    }
    if (VAR_3 > VAR_11) {
        sixel_helper_set_additional_message(
            ""sixel_frame_init: given width parameter is too huge."");
        VAR_8 = VAR_10;
        goto end;
    }
    if (VAR_4 > VAR_12) {
        sixel_helper_set_additional_message(
            ""sixel_frame_init: given height parameter is too huge."");
        VAR_8 = VAR_10;
        goto end;
    }

    VAR_1->pixels = VAR_2;
    VAR_1->width = VAR_3;
    VAR_1->height = VAR_4;
    VAR_1->pixelformat = VAR_5;
    VAR_1->palette = VAR_6;
    VAR_1->ncolors = VAR_7;

    VAR_8 = VAR_13;

end:
    sixel_frame_unref(VAR_1);

    return VAR_8;
}",,"--- func_before
+++ func_after
@@ -9,7 +9,35 @@
     int             /* in */ ncolors        /* number of palette colors or (-1) */
 )
 {
+    SIXELSTATUS status = SIXEL_FALSE;
+
     sixel_frame_ref(frame);
+
+    /* check parameters */
+    if (width <= 0) {
+        sixel_helper_set_additional_message(
+            ""sixel_frame_init: an invalid width parameter detected."");
+        status = SIXEL_BAD_INPUT;
+        goto end;
+    }
+    if (height <= 0) {
+        sixel_helper_set_additional_message(
+            ""sixel_frame_init: an invalid width parameter detected."");
+        status = SIXEL_BAD_INPUT;
+        goto end;
+    }
+    if (width > SIXEL_WIDTH_LIMIT) {
+        sixel_helper_set_additional_message(
+            ""sixel_frame_init: given width parameter is too huge."");
+        status = SIXEL_BAD_INPUT;
+        goto end;
+    }
+    if (height > SIXEL_HEIGHT_LIMIT) {
+        sixel_helper_set_additional_message(
+            ""sixel_frame_init: given height parameter is too huge."");
+        status = SIXEL_BAD_INPUT;
+        goto end;
+    }
 
     frame->pixels = pixels;
     frame->width = width;
@@ -18,7 +46,10 @@
     frame->palette = palette;
     frame->ncolors = ncolors;
 
+    status = SIXEL_OK;
+
+end:
     sixel_frame_unref(frame);
 
-    return SIXEL_OK;
+    return status;
 }","{'deleted_lines': ['    return SIXEL_OK;'], 'added_lines': ['    SIXELSTATUS status = SIXEL_FALSE;', '', '', '    /* check parameters */', '    if (width <= 0) {', '        sixel_helper_set_additional_message(', '            ""sixel_frame_init: an invalid width parameter detected."");', '        status = SIXEL_BAD_INPUT;', '        goto end;', '    }', '    if (height <= 0) {', '        sixel_helper_set_additional_message(', '            ""sixel_frame_init: an invalid width parameter detected."");', '        status = SIXEL_BAD_INPUT;', '        goto end;', '    }', '    if (width > SIXEL_WIDTH_LIMIT) {', '        sixel_helper_set_additional_message(', '            ""sixel_frame_init: given width parameter is too huge."");', '        status = SIXEL_BAD_INPUT;', '        goto end;', '    }', '    if (height > SIXEL_HEIGHT_LIMIT) {', '        sixel_helper_set_additional_message(', '            ""sixel_frame_init: given height parameter is too huge."");', '        status = SIXEL_BAD_INPUT;', '        goto end;', '    }', '    status = SIXEL_OK;', '', 'end:', '    return status;']}",True,libsixel 1.8.4 has an integer overflow in sixel_frame_resize in frame.c.,8.8,HIGH,2,valid,2019-12-31T23:12:16Z,3
CVE-2019-20205,['CWE-190'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,saitoha/libsixel,Prevent an integer overflow problem(#127),554335482137b4b4c1da7d461d884aea1d9d689f,https://github.com/saitoha/libsixel/commit/554335482137b4b4c1da7d461d884aea1d9d689f,src/fromsixel.c,image_buffer_init,"static SIXELSTATUS
image_buffer_init(
image_buffer_t     *image,
int                 width,
int                 height,
int                 bgindex,
sixel_allocator_t  *allocator)
{
SIXELSTATUS status = SIXEL_FALSE;
size_t size;
int i;
int n;
int r;
int g;
int b;
if (width <= 0) {
sixel_helper_set_additional_message(
""image_buffer_init: an invalid width parameter detected."");
status = SIXEL_BAD_INPUT;
goto end;
}
if (height <= 0) {
sixel_helper_set_additional_message(
""image_buffer_init: an invalid width parameter detected."");
status = SIXEL_BAD_INPUT;
goto end;
}
if (height > SIXEL_HEIGHT_LIMIT) {
sixel_helper_set_additional_message(
""image_buffer_init: given height parameter is too huge."");
status = SIXEL_BAD_INPUT;
goto end;
}
if (width > SIXEL_WIDTH_LIMIT) {
sixel_helper_set_additional_message(
""image_buffer_init: given width parameter is too huge."");
status = SIXEL_BAD_INPUT;
goto end;
}
if (height > SIXEL_HEIGHT_LIMIT) {
sixel_helper_set_additional_message(
""image_buffer_init: given height parameter is too huge."");
status = SIXEL_BAD_INPUT;
goto end;
}
size = (size_t)(width) * (size_t)height * sizeof(unsigned char);
image->width = width;
image->height = height;
image->data = (unsigned char *)sixel_allocator_malloc(allocator, size);
image->ncolors = 2;
if (image->data == NULL) {
sixel_helper_set_additional_message(
""sixel_deocde_raw: sixel_allocator_malloc() failed."");
status = SIXEL_BAD_ALLOCATION;
goto end;
}
memset(image->data, bgindex, size);
for (n = 0; n < 16; n++) {
image->palette[n] = sixel_default_color_table[n];
}
for (r = 0; r < 6; r++) {
for (g = 0; g < 6; g++) {
for (b = 0; b < 6; b++) {
image->palette[n++] = SIXEL_RGB(r * 51, g * 51, b * 51);
}
}
}
for (i = 0; i < 24; i++) {
image->palette[n++] = SIXEL_RGB(i * 11, i * 11, i * 11);
}
for (; n < SIXEL_PALETTE_MAX; n++) {
image->palette[n] = SIXEL_RGB(255, 255, 255);
}
status = SIXEL_OK;
end:
return status;
}","static SIXELSTATUS
image_buffer_init(
image_buffer_t     *VAR_0,
int                 VAR_1,
int                 VAR_2,
int                 VAR_3,
sixel_allocator_t  *VAR_4)
{
SIXELSTATUS VAR_5 = VAR_6;
size_t VAR_7;
int VAR_8;
int VAR_9;
int VAR_10;
int VAR_11;
int VAR_12;
if (VAR_1 <= 0) {
sixel_helper_set_additional_message(
""image_buffer_init: an invalid width parameter detected."");
VAR_5 = VAR_13;
goto end;
}
if (VAR_2 <= 0) {
sixel_helper_set_additional_message(
""image_buffer_init: an invalid width parameter detected."");
VAR_5 = VAR_13;
goto end;
}
if (VAR_2 > VAR_14) {
sixel_helper_set_additional_message(
""image_buffer_init: given height parameter is too huge."");
VAR_5 = VAR_13;
goto end;
}
if (VAR_1 > VAR_15) {
sixel_helper_set_additional_message(
""image_buffer_init: given width parameter is too huge."");
VAR_5 = VAR_13;
goto end;
}
if (VAR_2 > VAR_14) {
sixel_helper_set_additional_message(
""image_buffer_init: given height parameter is too huge."");
VAR_5 = VAR_13;
goto end;
}
VAR_7 = (size_t)(VAR_1) * (size_t)VAR_2 * sizeof(unsigned char);
VAR_0->width = VAR_1;
VAR_0->height = VAR_2;
VAR_0->data = (unsigned char *)sixel_allocator_malloc(VAR_4, VAR_7);
VAR_0->ncolors = 2;
if (VAR_0->data == NULL) {
sixel_helper_set_additional_message(
""sixel_deocde_raw: sixel_allocator_malloc() failed."");
VAR_5 = VAR_16;
goto end;
}
memset(VAR_0->data, VAR_3, VAR_7);
for (VAR_9 = 0; VAR_9 < 16; VAR_9++) {
VAR_0->palette[VAR_9] = VAR_17[VAR_9];
}
for (VAR_10 = 0; VAR_10 < 6; VAR_10++) {
for (VAR_11 = 0; VAR_11 < 6; VAR_11++) {
for (VAR_12 = 0; VAR_12 < 6; VAR_12++) {
VAR_0->palette[VAR_9++] = SIXEL_RGB(VAR_10 * 51, VAR_11 * 51, VAR_12 * 51);
}
}
}
for (VAR_8 = 0; VAR_8 < 24; VAR_8++) {
VAR_0->palette[VAR_9++] = SIXEL_RGB(VAR_8 * 11, VAR_8 * 11, VAR_8 * 11);
}
for (; VAR_9 < VAR_18; VAR_9++) {
VAR_0->palette[VAR_9] = SIXEL_RGB(255, 255, 255);
}
VAR_5 = VAR_19;
end:
return VAR_5;
}",saitoha/libsixel/554335482137b4b4c1da7d461d884aea1d9d689f/fromsixel.c/vul/before/0.json,"static SIXELSTATUS
image_buffer_init(
    image_buffer_t     *image,
    int                 width,
    int                 height,
    int                 bgindex,
    sixel_allocator_t  *allocator)
{
    SIXELSTATUS status = SIXEL_FALSE;
    size_t size;
    int i;
    int n;
    int r;
    int g;
    int b;

    /* check parameters */
    if (width <= 0) {
        sixel_helper_set_additional_message(
            ""image_buffer_init: an invalid width parameter detected."");
        status = SIXEL_BAD_INPUT;
        goto end;
    }
    if (height <= 0) {
        sixel_helper_set_additional_message(
            ""image_buffer_init: an invalid width parameter detected."");
        status = SIXEL_BAD_INPUT;
        goto end;
    }
    if (width > SIXEL_WIDTH_LIMIT) {
        sixel_helper_set_additional_message(
            ""image_buffer_init: given width parameter is too huge."");
        status = SIXEL_BAD_INPUT;
        goto end;
    }
    if (height > SIXEL_HEIGHT_LIMIT) {
        sixel_helper_set_additional_message(
            ""image_buffer_init: given height parameter is too huge."");
        status = SIXEL_BAD_INPUT;
        goto end;
    }

    size = (size_t)(width) * (size_t)height * sizeof(unsigned char);
    image->width = width;
    image->height = height;
    image->data = (unsigned char *)sixel_allocator_malloc(allocator, size);
    image->ncolors = 2;

    if (image->data == NULL) {
        sixel_helper_set_additional_message(
            ""sixel_deocde_raw: sixel_allocator_malloc() failed."");
        status = SIXEL_BAD_ALLOCATION;
        goto end;
    }
    memset(image->data, bgindex, size);

    /* palette initialization */
    for (n = 0; n < 16; n++) {
        image->palette[n] = sixel_default_color_table[n];
    }

    /* colors 16-231 are a 6x6x6 color cube */
    for (r = 0; r < 6; r++) {
        for (g = 0; g < 6; g++) {
            for (b = 0; b < 6; b++) {
                image->palette[n++] = SIXEL_RGB(r * 51, g * 51, b * 51);
            }
        }
    }

    /* colors 232-255 are a grayscale ramp, intentionally leaving out */
    for (i = 0; i < 24; i++) {
        image->palette[n++] = SIXEL_RGB(i * 11, i * 11, i * 11);
    }

    for (; n < SIXEL_PALETTE_MAX; n++) {
        image->palette[n] = SIXEL_RGB(255, 255, 255);
    }

    status = SIXEL_OK;

end:
    return status;
}","static SIXELSTATUS
image_buffer_init(
    image_buffer_t     *VAR_0,
    int                 VAR_1,
    int                 VAR_2,
    int                 VAR_3,
    sixel_allocator_t  *VAR_4)
{
    SIXELSTATUS VAR_5 = VAR_6;
    size_t VAR_7;
    int VAR_8;
    int VAR_9;
    int VAR_10;
    int VAR_11;
    int VAR_12;

    /* COMMENT_0 */
    if (VAR_1 <= 0) {
        sixel_helper_set_additional_message(
            ""image_buffer_init: an invalid width parameter detected."");
        VAR_5 = VAR_13;
        goto end;
    }
    if (VAR_2 <= 0) {
        sixel_helper_set_additional_message(
            ""image_buffer_init: an invalid width parameter detected."");
        VAR_5 = VAR_13;
        goto end;
    }
    if (VAR_1 > VAR_14) {
        sixel_helper_set_additional_message(
            ""image_buffer_init: given width parameter is too huge."");
        VAR_5 = VAR_13;
        goto end;
    }
    if (VAR_2 > VAR_15) {
        sixel_helper_set_additional_message(
            ""image_buffer_init: given height parameter is too huge."");
        VAR_5 = VAR_13;
        goto end;
    }

    VAR_7 = (size_t)(VAR_1) * (size_t)VAR_2 * sizeof(unsigned char);
    VAR_0->width = VAR_1;
    VAR_0->height = VAR_2;
    VAR_0->data = (unsigned char *)sixel_allocator_malloc(VAR_4, VAR_7);
    VAR_0->ncolors = 2;

    if (VAR_0->data == NULL) {
        sixel_helper_set_additional_message(
            ""sixel_deocde_raw: sixel_allocator_malloc() failed."");
        VAR_5 = VAR_16;
        goto end;
    }
    memset(VAR_0->data, VAR_3, VAR_7);

    /* COMMENT_1 */
    for (VAR_9 = 0; VAR_9 < 16; VAR_9++) {
        VAR_0->palette[VAR_9] = VAR_17[VAR_9];
    }

    /* COMMENT_2 */
    for (VAR_10 = 0; VAR_10 < 6; VAR_10++) {
        for (VAR_11 = 0; VAR_11 < 6; VAR_11++) {
            for (VAR_12 = 0; VAR_12 < 6; VAR_12++) {
                VAR_0->palette[VAR_9++] = SIXEL_RGB(VAR_10 * 51, VAR_11 * 51, VAR_12 * 51);
            }
        }
    }

    /* COMMENT_3 */
    for (VAR_8 = 0; VAR_8 < 24; VAR_8++) {
        VAR_0->palette[VAR_9++] = SIXEL_RGB(VAR_8 * 11, VAR_8 * 11, VAR_8 * 11);
    }

    for (; VAR_9 < VAR_18; VAR_9++) {
        VAR_0->palette[VAR_9] = SIXEL_RGB(255, 255, 255);
    }

    VAR_5 = VAR_19;

end:
    return VAR_5;
}",saitoha/libsixel/554335482137b4b4c1da7d461d884aea1d9d689f/fromsixel.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -24,12 +24,6 @@
     if (height <= 0) {
         sixel_helper_set_additional_message(
             ""image_buffer_init: an invalid width parameter detected."");
-        status = SIXEL_BAD_INPUT;
-        goto end;
-    }
-    if (height > SIXEL_HEIGHT_LIMIT) {
-        sixel_helper_set_additional_message(
-            ""image_buffer_init: given height parameter is too huge."");
         status = SIXEL_BAD_INPUT;
         goto end;
     }","{'deleted_lines': ['        status = SIXEL_BAD_INPUT;', '        goto end;', '    }', '    if (height > SIXEL_HEIGHT_LIMIT) {', '        sixel_helper_set_additional_message(', '            ""image_buffer_init: given height parameter is too huge."");'], 'added_lines': []}",True,libsixel 1.8.4 has an integer overflow in sixel_frame_resize in frame.c.,8.8,HIGH,2,valid,2019-12-31T23:12:16Z,3
CVE-2020-5310,['CWE-190'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,python-pillow/Pillow,Overflow checks for realloc for tiff decoding,4e2def2539ec13e53a82e06c4b3daf00454100c4,https://github.com/python-pillow/Pillow/commit/4e2def2539ec13e53a82e06c4b3daf00454100c4,src/libImaging/TiffDecode.c,ImagingLibTiffDecode,"int ImagingLibTiffDecode(Imaging im, ImagingCodecState state, UINT8* buffer, Py_ssize_t bytes) {
TIFFSTATE *clientstate = (TIFFSTATE *)state->context;
char *filename = ""tempfile.tif"";
char *mode = ""r"";
TIFF *tiff;
TRACE((""in decoder: bytes %d\n"", bytes));
TRACE((""State: count %d, state %d, x %d, y %d, ystep %d\n"", state->count, state->state,
state->x, state->y, state->ystep));
TRACE((""State: xsize %d, ysize %d, xoff %d, yoff %d \n"", state->xsize, state->ysize,
state->xoff, state->yoff));
TRACE((""State: bits %d, bytes %d \n"", state->bits, state->bytes));
TRACE((""Buffer: %p: %c%c%c%c\n"", buffer, (char)buffer[0], (char)buffer[1],(char)buffer[2], (char)buffer[3]));
TRACE((""State->Buffer: %c%c%c%c\n"", (char)state->buffer[0], (char)state->buffer[1],(char)state->buffer[2], (char)state->buffer[3]));
TRACE((""Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \n"",
im->mode, im->type, im->bands, im->xsize, im->ysize));
TRACE((""Image: image8 %p, image32 %p, image %p, block %p \n"",
im->image8, im->image32, im->image, im->block));
TRACE((""Image: pixelsize: %d, linesize %d \n"",
im->pixelsize, im->linesize));
dump_state(clientstate);
clientstate->size = bytes;
clientstate->eof = clientstate->size;
clientstate->loc = 0;
clientstate->data = (tdata_t)buffer;
clientstate->flrealloc = 0;
dump_state(clientstate);
TIFFSetWarningHandler(NULL);
TIFFSetWarningHandlerExt(NULL);
if (clientstate->fp) {
TRACE((""Opening using fd: %d\n"",clientstate->fp));
lseek(clientstate->fp,0,SEEK_SET);         tiff = TIFFFdOpen(clientstate->fp, filename, mode);
} else {
TRACE((""Opening from string\n""));
tiff = TIFFClientOpen(filename, mode,
(thandle_t) clientstate,
_tiffReadProc, _tiffWriteProc,
_tiffSeekProc, _tiffCloseProc, _tiffSizeProc,
_tiffMapProc, _tiffUnmapProc);
}
if (!tiff){
TRACE((""Error, didn't get the tiff\n""));
state->errcode = IMAGING_CODEC_BROKEN;
return -1;
}
if (clientstate->ifd){
int rv;
uint32 ifdoffset = clientstate->ifd;
TRACE((""reading tiff ifd %u\n"", ifdoffset));
rv = TIFFSetSubDirectory(tiff, ifdoffset);
if (!rv){
TRACE((""error in TIFFSetSubDirectory""));
return -1;
}
}
if (TIFFIsTiled(tiff)) {
UINT32 x, y, tile_y, row_byte_size;
UINT32 tile_width, tile_length, current_tile_width;
UINT8 *new_data;
TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width);
TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_length);
row_byte_size = (tile_width * state->bits + 7) / 8;
state->bytes = row_byte_size * tile_length;
if (state->bytes > INT_MAX - 1) {
state->errcode = IMAGING_CODEC_MEMORY;
TIFFClose(tiff);
return -1;
}
new_data = realloc (state->buffer, state->bytes);
if (!new_data) {
state->errcode = IMAGING_CODEC_MEMORY;
TIFFClose(tiff);
return -1;
}
state->buffer = new_data;
TRACE((""TIFFTileSize: %d\n"", state->bytes));
for (y = state->yoff; y < state->ysize; y += tile_length) {
for (x = state->xoff; x < state->xsize; x += tile_width) {
if (ReadTile(tiff, x, y, (UINT32*) state->buffer) == -1) {
TRACE((""Decode Error, Tile at %dx%d\n"", x, y));
state->errcode = IMAGING_CODEC_BROKEN;
TIFFClose(tiff);
return -1;
}
TRACE((""Read tile at %dx%d; \n\n"", x, y));
current_tile_width = min(tile_width, state->xsize - x);
for (tile_y = 0; tile_y < min(tile_length, state->ysize - y); tile_y++) {
TRACE((""Writing tile data at %dx%d using tile_width: %d; \n"", tile_y + y, x, current_tile_width));
state->shuffle((UINT8*) im->image[tile_y + y] + x * im->pixelsize,
state->buffer + tile_y * row_byte_size,
current_tile_width
);
}
}
}
} else {
UINT32 strip_row, row_byte_size;
UINT8 *new_data;
UINT32 rows_per_strip;
int ret;
ret = TIFFGetField(tiff, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);
if (ret != 1) {
rows_per_strip = state->ysize;
}
TRACE((""RowsPerStrip: %u \n"", rows_per_strip));
row_byte_size = (state->xsize * state->bits + 7) / 8;
state->bytes = rows_per_strip * row_byte_size;
TRACE((""StripSize: %d \n"", state->bytes));
new_data = realloc (state->buffer, state->bytes);
if (!new_data) {
state->errcode = IMAGING_CODEC_MEMORY;
TIFFClose(tiff);
return -1;
}
state->buffer = new_data;
for (; state->y < state->ysize; state->y += rows_per_strip) {
if (ReadStrip(tiff, state->y, (UINT32 *)state->buffer) == -1) {
TRACE((""Decode Error, strip %d\n"", TIFFComputeStrip(tiff, state->y, 0)));
state->errcode = IMAGING_CODEC_BROKEN;
TIFFClose(tiff);
return -1;
}
TRACE((""Decoded strip for row %d \n"", state->y));
for (strip_row = 0; strip_row < min(rows_per_strip, state->ysize - state->y); strip_row++) {
TRACE((""Writing data into line %d ; \n"", state->y + strip_row));
state->shuffle((UINT8*) im->image[state->y + state->yoff + strip_row] +
state->xoff * im->pixelsize,
state->buffer + strip_row * row_byte_size,
state->xsize);
}
}
}
TIFFClose(tiff);
TRACE((""Done Decoding, Returning \n""));
return -1;
}","int ImagingLibTiffDecode(Imaging VAR_0, ImagingCodecState VAR_1, UINT8* VAR_2, Py_ssize_t VAR_3) {
TIFFSTATE *VAR_4 = (TIFFSTATE *)VAR_1->context;
char *VAR_5 = ""tempfile.tif"";
char *VAR_6 = ""r"";
TIFF *VAR_7;
TRACE((""in decoder: bytes %d\n"", VAR_3));
TRACE((""State: count %d, state %d, x %d, y %d, ystep %d\n"", VAR_1->count, VAR_1->state,
VAR_1->x, VAR_1->y, VAR_1->ystep));
TRACE((""State: xsize %d, ysize %d, xoff %d, yoff %d \n"", VAR_1->xsize, VAR_1->ysize,
VAR_1->xoff, VAR_1->yoff));
TRACE((""State: bits %d, bytes %d \n"", VAR_1->bits, VAR_1->bytes));
TRACE((""Buffer: %p: %c%c%c%c\n"", VAR_2, (char)VAR_2[0], (char)VAR_2[1],(char)VAR_2[2], (char)VAR_2[3]));
TRACE((""State->Buffer: %c%c%c%c\n"", (char)VAR_1->buffer[0], (char)VAR_1->buffer[1],(char)VAR_1->buffer[2], (char)VAR_1->buffer[3]));
TRACE((""Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \n"",
VAR_0->mode, VAR_0->type, VAR_0->bands, VAR_0->xsize, VAR_0->ysize));
TRACE((""Image: image8 %p, image32 %p, image %p, block %p \n"",
VAR_0->image8, VAR_0->image32, VAR_0->image, VAR_0->block));
TRACE((""Image: pixelsize: %d, linesize %d \n"",
VAR_0->pixelsize, VAR_0->linesize));
dump_state(VAR_4);
VAR_4->size = VAR_3;
VAR_4->eof = VAR_4->size;
VAR_4->loc = 0;
VAR_4->data = (tdata_t)VAR_2;
VAR_4->flrealloc = 0;
dump_state(VAR_4);
TIFFSetWarningHandler(NULL);
TIFFSetWarningHandlerExt(NULL);
if (VAR_4->fp) {
TRACE((""Opening using fd: %d\n"",VAR_4->fp));
lseek(VAR_4->fp,0,VAR_8); 
VAR_7 = TIFFFdOpen(VAR_4->fp, VAR_5, VAR_6);
} else {
TRACE((""Opening from string\n""));
VAR_7 = TIFFClientOpen(VAR_5, VAR_6,
(thandle_t) VAR_4,
VAR_9, VAR_10,
VAR_11, VAR_12, VAR_13,
VAR_14, VAR_15);
}
if (!VAR_7){
TRACE((""Error, didn't get the tiff\n""));
VAR_1->errcode = VAR_16;
return -1;
}
if (VAR_4->ifd){
int VAR_17;
uint32 VAR_18 = VAR_4->ifd;
TRACE((""reading tiff ifd %u\n"", VAR_18));
VAR_17 = TIFFSetSubDirectory(VAR_7, VAR_18);
if (!VAR_17){
TRACE((""error in TIFFSetSubDirectory""));
return -1;
}
}
if (TIFFIsTiled(VAR_7)) {
UINT32 VAR_19, VAR_20, VAR_21, VAR_22;
UINT32 VAR_23, VAR_24, VAR_25;
UINT8 *VAR_26;
TIFFGetField(VAR_7, VAR_27, &VAR_23);
TIFFGetField(VAR_7, VAR_28, &VAR_24);
VAR_22 = (VAR_23 * VAR_1->bits + 7) / 8;
VAR_1->bytes = VAR_22 * VAR_24;
if (VAR_1->bytes > VAR_29 - 1) {
VAR_1->errcode = VAR_30;
TIFFClose(VAR_7);
return -1;
}
VAR_26 = realloc (VAR_1->buffer, VAR_1->bytes);
if (!VAR_26) {
VAR_1->errcode = VAR_30;
TIFFClose(VAR_7);
return -1;
}
VAR_1->buffer = VAR_26;
TRACE((""TIFFTileSize: %d\n"", VAR_1->bytes));
for (VAR_20 = VAR_1->yoff; VAR_20 < VAR_1->ysize; VAR_20 += VAR_24) {
for (VAR_19 = VAR_1->xoff; VAR_19 < VAR_1->xsize; VAR_19 += VAR_23) {
if (ReadTile(VAR_7, VAR_19, VAR_20, (UINT32*) VAR_1->buffer) == -1) {
TRACE((""Decode Error, Tile at %dx%d\n"", VAR_19, VAR_20));
VAR_1->errcode = VAR_16;
TIFFClose(VAR_7);
return -1;
}
TRACE((""Read tile at %dx%d; \n\n"", VAR_19, VAR_20));
VAR_25 = min(VAR_23, VAR_1->xsize - VAR_19);
for (VAR_21 = 0; VAR_21 < min(VAR_24, VAR_1->ysize - VAR_20); VAR_21++) {
TRACE((""Writing tile data at %dx%d using tile_width: %d; \n"", VAR_21 + VAR_20, VAR_19, VAR_25));
VAR_1->shuffle((UINT8*) VAR_0->image[VAR_21 + VAR_20] + VAR_19 * VAR_0->pixelsize,
VAR_1->buffer + VAR_21 * VAR_22,
VAR_25
);
}
}
}
} else {
UINT32 VAR_31, VAR_22;
UINT8 *VAR_26;
UINT32 VAR_32;
int VAR_33;
VAR_33 = TIFFGetField(VAR_7, VAR_34, &VAR_32);
if (VAR_33 != 1) {
VAR_32 = VAR_1->ysize;
}
TRACE((""RowsPerStrip: %u \n"", VAR_32));
VAR_22 = (VAR_1->xsize * VAR_1->bits + 7) / 8;
VAR_1->bytes = VAR_32 * VAR_22;
TRACE((""StripSize: %d \n"", VAR_1->bytes));
VAR_26 = realloc (VAR_1->buffer, VAR_1->bytes);
if (!VAR_26) {
VAR_1->errcode = VAR_30;
TIFFClose(VAR_7);
return -1;
}
VAR_1->buffer = VAR_26;
for (; VAR_1->y < VAR_1->ysize; VAR_1->y += VAR_32) {
if (ReadStrip(VAR_7, VAR_1->y, (UINT32 *)VAR_1->buffer) == -1) {
TRACE((""Decode Error, strip %d\n"", TIFFComputeStrip(VAR_7, VAR_1->y, 0)));
VAR_1->errcode = VAR_16;
TIFFClose(VAR_7);
return -1;
}
TRACE((""Decoded strip for row %d \n"", VAR_1->y));
for (VAR_31 = 0; VAR_31 < min(VAR_32, VAR_1->ysize - VAR_1->y); VAR_31++) {
TRACE((""Writing data into line %d ; \n"", VAR_1->y + VAR_31));
VAR_1->shuffle((UINT8*) VAR_0->image[VAR_1->y + VAR_1->yoff + VAR_31] +
VAR_1->xoff * VAR_0->pixelsize,
VAR_1->buffer + VAR_31 * VAR_22,
VAR_1->xsize);
}
}
}
TIFFClose(VAR_7);
TRACE((""Done Decoding, Returning \n""));
return -1;
}",python-pillow/Pillow/4e2def2539ec13e53a82e06c4b3daf00454100c4/TiffDecode.c/vul/before/0.json,"int ImagingLibTiffDecode(Imaging im, ImagingCodecState state, UINT8* buffer, Py_ssize_t bytes) {
    TIFFSTATE *clientstate = (TIFFSTATE *)state->context;
    char *filename = ""tempfile.tif"";
    char *mode = ""r"";
    TIFF *tiff;

    /* buffer is the encoded file, bytes is the length of the encoded file */
    /*     it all ends up in state->buffer, which is a uint8* from Imaging.h */

    TRACE((""in decoder: bytes %d\n"", bytes));
    TRACE((""State: count %d, state %d, x %d, y %d, ystep %d\n"", state->count, state->state,
           state->x, state->y, state->ystep));
    TRACE((""State: xsize %d, ysize %d, xoff %d, yoff %d \n"", state->xsize, state->ysize,
           state->xoff, state->yoff));
    TRACE((""State: bits %d, bytes %d \n"", state->bits, state->bytes));
    TRACE((""Buffer: %p: %c%c%c%c\n"", buffer, (char)buffer[0], (char)buffer[1],(char)buffer[2], (char)buffer[3]));
    TRACE((""State->Buffer: %c%c%c%c\n"", (char)state->buffer[0], (char)state->buffer[1],(char)state->buffer[2], (char)state->buffer[3]));
    TRACE((""Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \n"",
           im->mode, im->type, im->bands, im->xsize, im->ysize));
    TRACE((""Image: image8 %p, image32 %p, image %p, block %p \n"",
           im->image8, im->image32, im->image, im->block));
    TRACE((""Image: pixelsize: %d, linesize %d \n"",
           im->pixelsize, im->linesize));

    dump_state(clientstate);
    clientstate->size = bytes;
    clientstate->eof = clientstate->size;
    clientstate->loc = 0;
    clientstate->data = (tdata_t)buffer;
    clientstate->flrealloc = 0;
    dump_state(clientstate);

    TIFFSetWarningHandler(NULL);
    TIFFSetWarningHandlerExt(NULL);

    if (clientstate->fp) {
        TRACE((""Opening using fd: %d\n"",clientstate->fp));
        lseek(clientstate->fp,0,SEEK_SET); // Sometimes, I get it set to the end.
        tiff = TIFFFdOpen(clientstate->fp, filename, mode);
    } else {
        TRACE((""Opening from string\n""));
        tiff = TIFFClientOpen(filename, mode,
                              (thandle_t) clientstate,
                              _tiffReadProc, _tiffWriteProc,
                              _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,
                              _tiffMapProc, _tiffUnmapProc);
    }

    if (!tiff){
        TRACE((""Error, didn't get the tiff\n""));
        state->errcode = IMAGING_CODEC_BROKEN;
        return -1;
    }

    if (clientstate->ifd){
        int rv;
        uint32 ifdoffset = clientstate->ifd;
        TRACE((""reading tiff ifd %u\n"", ifdoffset));
        rv = TIFFSetSubDirectory(tiff, ifdoffset);
        if (!rv){
            TRACE((""error in TIFFSetSubDirectory""));
            return -1;
        }
    }

    if (TIFFIsTiled(tiff)) {
        UINT32 x, y, tile_y, row_byte_size;
        UINT32 tile_width, tile_length, current_tile_width;
        UINT8 *new_data;

        TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width);
        TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_length);

        // We could use TIFFTileSize, but for YCbCr data it returns subsampled data size
        row_byte_size = (tile_width * state->bits + 7) / 8;

        /* overflow check for realloc */
        if (INT_MAX / row_byte_size < tile_length) {
            state->errcode = IMAGING_CODEC_MEMORY;
            TIFFClose(tiff);
            return -1;
        }
        
        state->bytes = row_byte_size * tile_length;

        /* realloc to fit whole tile */
        /* malloc check above */
        new_data = realloc (state->buffer, state->bytes);
        if (!new_data) {
            state->errcode = IMAGING_CODEC_MEMORY;
            TIFFClose(tiff);
            return -1;
        }

        state->buffer = new_data;

        TRACE((""TIFFTileSize: %d\n"", state->bytes));

        for (y = state->yoff; y < state->ysize; y += tile_length) {
            for (x = state->xoff; x < state->xsize; x += tile_width) {
                if (ReadTile(tiff, x, y, (UINT32*) state->buffer) == -1) {
                    TRACE((""Decode Error, Tile at %dx%d\n"", x, y));
                    state->errcode = IMAGING_CODEC_BROKEN;
                    TIFFClose(tiff);
                    return -1;
                }

                TRACE((""Read tile at %dx%d; \n\n"", x, y));

                current_tile_width = min(tile_width, state->xsize - x);

                // iterate over each line in the tile and stuff data into image
                for (tile_y = 0; tile_y < min(tile_length, state->ysize - y); tile_y++) {
                    TRACE((""Writing tile data at %dx%d using tile_width: %d; \n"", tile_y + y, x, current_tile_width));

                    // UINT8 * bbb = state->buffer + tile_y * row_byte_size;
                    // TRACE((""chars: %x%x%x%x\n"", ((UINT8 *)bbb)[0], ((UINT8 *)bbb)[1], ((UINT8 *)bbb)[2], ((UINT8 *)bbb)[3]));

                    state->shuffle((UINT8*) im->image[tile_y + y] + x * im->pixelsize,
                       state->buffer + tile_y * row_byte_size,
                       current_tile_width
                    );
                }
            }
        }
    } else {
        UINT32 strip_row, row_byte_size;
        UINT8 *new_data;
        UINT32 rows_per_strip;
        int ret;

        ret = TIFFGetField(tiff, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);
        if (ret != 1) {
            rows_per_strip = state->ysize;
        }
        TRACE((""RowsPerStrip: %u \n"", rows_per_strip));

        // We could use TIFFStripSize, but for YCbCr data it returns subsampled data size
        row_byte_size = (state->xsize * state->bits + 7) / 8;

        /* overflow check for realloc */
        if (INT_MAX / row_byte_size < rows_per_strip) {
            state->errcode = IMAGING_CODEC_MEMORY;
            TIFFClose(tiff);
            return -1;
        }
        
        state->bytes = rows_per_strip * row_byte_size;

        TRACE((""StripSize: %d \n"", state->bytes));

        /* realloc to fit whole strip */
        /* malloc check above */
        new_data = realloc (state->buffer, state->bytes);
        if (!new_data) {
            state->errcode = IMAGING_CODEC_MEMORY;
            TIFFClose(tiff);
            return -1;
        }

        state->buffer = new_data;

        for (; state->y < state->ysize; state->y += rows_per_strip) {
            if (ReadStrip(tiff, state->y, (UINT32 *)state->buffer) == -1) {
                TRACE((""Decode Error, strip %d\n"", TIFFComputeStrip(tiff, state->y, 0)));
                state->errcode = IMAGING_CODEC_BROKEN;
                TIFFClose(tiff);
                return -1;
            }

            TRACE((""Decoded strip for row %d \n"", state->y));

            // iterate over each row in the strip and stuff data into image
            for (strip_row = 0; strip_row < min(rows_per_strip, state->ysize - state->y); strip_row++) {
                TRACE((""Writing data into line %d ; \n"", state->y + strip_row));

                // UINT8 * bbb = state->buffer + strip_row * (state->bytes / rows_per_strip);
                // TRACE((""chars: %x %x %x %x\n"", ((UINT8 *)bbb)[0], ((UINT8 *)bbb)[1], ((UINT8 *)bbb)[2], ((UINT8 *)bbb)[3]));

                state->shuffle((UINT8*) im->image[state->y + state->yoff + strip_row] +
                               state->xoff * im->pixelsize,
                               state->buffer + strip_row * row_byte_size,
                               state->xsize);
            }
        }
    }

    TIFFClose(tiff);
    TRACE((""Done Decoding, Returning \n""));
    // Returning -1 here to force ImageFile.load to break, rather than
    // even think about looping back around.
    return -1;
}","int ImagingLibTiffDecode(Imaging VAR_0, ImagingCodecState VAR_1, UINT8* VAR_2, Py_ssize_t VAR_3) {
    TIFFSTATE *VAR_4 = (TIFFSTATE *)VAR_1->context;
    char *VAR_5 = ""tempfile.tif"";
    char *VAR_6 = ""r"";
    TIFF *VAR_7;

    /* COMMENT_0 */
    /* COMMENT_1 */

    TRACE((""in decoder: bytes %d\n"", VAR_3));
    TRACE((""State: count %d, state %d, x %d, y %d, ystep %d\n"", VAR_1->count, VAR_1->state,
           VAR_1->x, VAR_1->y, VAR_1->ystep));
    TRACE((""State: xsize %d, ysize %d, xoff %d, yoff %d \n"", VAR_1->xsize, VAR_1->ysize,
           VAR_1->xoff, VAR_1->yoff));
    TRACE((""State: bits %d, bytes %d \n"", VAR_1->bits, VAR_1->bytes));
    TRACE((""Buffer: %p: %c%c%c%c\n"", VAR_2, (char)VAR_2[0], (char)VAR_2[1],(char)VAR_2[2], (char)VAR_2[3]));
    TRACE((""State->Buffer: %c%c%c%c\n"", (char)VAR_1->buffer[0], (char)VAR_1->buffer[1],(char)VAR_1->buffer[2], (char)VAR_1->buffer[3]));
    TRACE((""Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \n"",
           VAR_0->mode, VAR_0->type, VAR_0->bands, VAR_0->xsize, VAR_0->ysize));
    TRACE((""Image: image8 %p, image32 %p, image %p, block %p \n"",
           VAR_0->image8, VAR_0->image32, VAR_0->image, VAR_0->block));
    TRACE((""Image: pixelsize: %d, linesize %d \n"",
           VAR_0->pixelsize, VAR_0->linesize));

    dump_state(VAR_4);
    VAR_4->size = VAR_3;
    VAR_4->eof = VAR_4->size;
    VAR_4->loc = 0;
    VAR_4->data = (tdata_t)VAR_2;
    VAR_4->flrealloc = 0;
    dump_state(VAR_4);

    TIFFSetWarningHandler(NULL);
    TIFFSetWarningHandlerExt(NULL);

    if (VAR_4->fp) {
        TRACE((""Opening using fd: %d\n"",VAR_4->fp));
        lseek(VAR_4->fp,0,VAR_8); /* COMMENT_2 */
        VAR_7 = TIFFFdOpen(VAR_4->fp, VAR_5, VAR_6);
    } else {
        TRACE((""Opening from string\n""));
        VAR_7 = TIFFClientOpen(VAR_5, VAR_6,
                              (thandle_t) VAR_4,
                              VAR_9, VAR_10,
                              VAR_11, VAR_12, VAR_13,
                              VAR_14, VAR_15);
    }

    if (!VAR_7){
        TRACE((""Error, didn't get the tiff\n""));
        VAR_1->errcode = VAR_16;
        return -1;
    }

    if (VAR_4->ifd){
        int VAR_17;
        uint32 VAR_18 = VAR_4->ifd;
        TRACE((""reading tiff ifd %u\n"", VAR_18));
        VAR_17 = TIFFSetSubDirectory(VAR_7, VAR_18);
        if (!VAR_17){
            TRACE((""error in TIFFSetSubDirectory""));
            return -1;
        }
    }

    if (TIFFIsTiled(VAR_7)) {
        UINT32 VAR_19, VAR_20, VAR_21, VAR_22;
        UINT32 VAR_23, VAR_24, VAR_25;
        UINT8 *VAR_26;

        TIFFGetField(VAR_7, VAR_27, &VAR_23);
        TIFFGetField(VAR_7, VAR_28, &VAR_24);

        /* COMMENT_3 */
        VAR_22 = (VAR_23 * VAR_1->bits + 7) / 8;

        /* COMMENT_4 */
        if (VAR_29 / VAR_22 < VAR_24) {
            VAR_1->errcode = VAR_30;
            TIFFClose(VAR_7);
            return -1;
        }
        
        VAR_1->bytes = VAR_22 * VAR_24;

        /* COMMENT_5 */
        /* COMMENT_6 */
        VAR_26 = realloc (VAR_1->buffer, VAR_1->bytes);
        if (!VAR_26) {
            VAR_1->errcode = VAR_30;
            TIFFClose(VAR_7);
            return -1;
        }

        VAR_1->buffer = VAR_26;

        TRACE((""TIFFTileSize: %d\n"", VAR_1->bytes));

        for (VAR_20 = VAR_1->yoff; VAR_20 < VAR_1->ysize; VAR_20 += VAR_24) {
            for (VAR_19 = VAR_1->xoff; VAR_19 < VAR_1->xsize; VAR_19 += VAR_23) {
                if (ReadTile(VAR_7, VAR_19, VAR_20, (UINT32*) VAR_1->buffer) == -1) {
                    TRACE((""Decode Error, Tile at %dx%d\n"", VAR_19, VAR_20));
                    VAR_1->errcode = VAR_16;
                    TIFFClose(VAR_7);
                    return -1;
                }

                TRACE((""Read tile at %dx%d; \n\n"", VAR_19, VAR_20));

                VAR_25 = min(VAR_23, VAR_1->xsize - VAR_19);

                /* COMMENT_7 */
                for (VAR_21 = 0; VAR_21 < min(VAR_24, VAR_1->ysize - VAR_20); VAR_21++) {
                    TRACE((""Writing tile data at %dx%d using tile_width: %d; \n"", VAR_21 + VAR_20, VAR_19, VAR_25));

                    /* COMMENT_8 */
                    /* COMMENT_9 */

                    VAR_1->shuffle((UINT8*) VAR_0->image[VAR_21 + VAR_20] + VAR_19 * VAR_0->pixelsize,
                       VAR_1->buffer + VAR_21 * VAR_22,
                       VAR_25
                    );
                }
            }
        }
    } else {
        UINT32 VAR_31, VAR_22;
        UINT8 *VAR_26;
        UINT32 VAR_32;
        int VAR_33;

        VAR_33 = TIFFGetField(VAR_7, VAR_34, &VAR_32);
        if (VAR_33 != 1) {
            VAR_32 = VAR_1->ysize;
        }
        TRACE((""RowsPerStrip: %u \n"", VAR_32));

        /* COMMENT_10 */
        VAR_22 = (VAR_1->xsize * VAR_1->bits + 7) / 8;

        /* COMMENT_4 */
        if (VAR_29 / VAR_22 < VAR_32) {
            VAR_1->errcode = VAR_30;
            TIFFClose(VAR_7);
            return -1;
        }
        
        VAR_1->bytes = VAR_32 * VAR_22;

        TRACE((""StripSize: %d \n"", VAR_1->bytes));

        /* COMMENT_11 */
        /* COMMENT_6 */
        VAR_26 = realloc (VAR_1->buffer, VAR_1->bytes);
        if (!VAR_26) {
            VAR_1->errcode = VAR_30;
            TIFFClose(VAR_7);
            return -1;
        }

        VAR_1->buffer = VAR_26;

        for (; VAR_1->y < VAR_1->ysize; VAR_1->y += VAR_32) {
            if (ReadStrip(VAR_7, VAR_1->y, (UINT32 *)VAR_1->buffer) == -1) {
                TRACE((""Decode Error, strip %d\n"", TIFFComputeStrip(VAR_7, VAR_1->y, 0)));
                VAR_1->errcode = VAR_16;
                TIFFClose(VAR_7);
                return -1;
            }

            TRACE((""Decoded strip for row %d \n"", VAR_1->y));

            /* COMMENT_12 */
            for (VAR_31 = 0; VAR_31 < min(VAR_32, VAR_1->ysize - VAR_1->y); VAR_31++) {
                TRACE((""Writing data into line %d ; \n"", VAR_1->y + VAR_31));

                /* COMMENT_13 */
                /* COMMENT_14 */

                VAR_1->shuffle((UINT8*) VAR_0->image[VAR_1->y + VAR_1->yoff + VAR_31] +
                               VAR_1->xoff * VAR_0->pixelsize,
                               VAR_1->buffer + VAR_31 * VAR_22,
                               VAR_1->xsize);
            }
        }
    }

    TIFFClose(VAR_7);
    TRACE((""Done Decoding, Returning \n""));
    /* COMMENT_15 */
    /* COMMENT_16 */
    return -1;
}",python-pillow/Pillow/4e2def2539ec13e53a82e06c4b3daf00454100c4/TiffDecode.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -73,16 +73,18 @@
 
         // We could use TIFFTileSize, but for YCbCr data it returns subsampled data size
         row_byte_size = (tile_width * state->bits + 7) / 8;
-        state->bytes = row_byte_size * tile_length;
 
-        /* overflow check for malloc */
-        if (state->bytes > INT_MAX - 1) {
+        /* overflow check for realloc */
+        if (INT_MAX / row_byte_size < tile_length) {
             state->errcode = IMAGING_CODEC_MEMORY;
             TIFFClose(tiff);
             return -1;
         }
+        
+        state->bytes = row_byte_size * tile_length;
 
         /* realloc to fit whole tile */
+        /* malloc check above */
         new_data = realloc (state->buffer, state->bytes);
         if (!new_data) {
             state->errcode = IMAGING_CODEC_MEMORY;
@@ -135,11 +137,20 @@
 
         // We could use TIFFStripSize, but for YCbCr data it returns subsampled data size
         row_byte_size = (state->xsize * state->bits + 7) / 8;
+
+        /* overflow check for realloc */
+        if (INT_MAX / row_byte_size < rows_per_strip) {
+            state->errcode = IMAGING_CODEC_MEMORY;
+            TIFFClose(tiff);
+            return -1;
+        }
+        
         state->bytes = rows_per_strip * row_byte_size;
 
         TRACE((""StripSize: %d \n"", state->bytes));
 
         /* realloc to fit whole strip */
+        /* malloc check above */
         new_data = realloc (state->buffer, state->bytes);
         if (!new_data) {
             state->errcode = IMAGING_CODEC_MEMORY;","{'deleted_lines': ['        state->bytes = row_byte_size * tile_length;', '        /* overflow check for malloc */', '        if (state->bytes > INT_MAX - 1) {'], 'added_lines': ['        /* overflow check for realloc */', '        if (INT_MAX / row_byte_size < tile_length) {', '        ', '        state->bytes = row_byte_size * tile_length;', '        /* malloc check above */', '', '        /* overflow check for realloc */', '        if (INT_MAX / row_byte_size < rows_per_strip) {', '            state->errcode = IMAGING_CODEC_MEMORY;', '            TIFFClose(tiff);', '            return -1;', '        }', '        ', '        /* malloc check above */']}",True,"libImaging/TiffDecode.c in Pillow before 6.2.2 has a TIFF decoding integer overflow, related to realloc.",8.8,HIGH,2,valid,2020-01-01T05:38:37Z,3
CVE-2020-5395,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,fontforge,"Fix for #4084 Use-after-free (heap) in the SFD_GetFontMetaData() function
Fix for #4086 NULL pointer dereference in the SFDGetSpiros() function
Fix for #4088 NULL pointer dereference in the SFD_AssignLookups() function
Add empty sf->fontname string if it isn't set, fixing #4089 #4090 and many
  other potential issues (many downstream calls to strlen() on the value).",8da6d56bf7af2d25f779e52edef61b2fd4557b3c,https://github.com/fontforge/fontforge/commit/8da6d56bf7af2d25f779e52edef61b2fd4557b3c,fontforge/sfd.c,SFD_GetFont,"static SplineFont *SFD_GetFont( FILE *sfd,SplineFont *cidmaster,char *tok,
int fromdir, char *dirname, float sfdversion )
{
SplineFont *sf;
int realcnt, i, eof, mappos=-1, ch;
struct table_ordering *lastord = NULL;
struct axismap *lastaxismap = NULL;
struct named_instance *lastnamedinstance = NULL;
int pushedbacktok = false;
Encoding *enc = &custom;
struct remap *remap = NULL;
int haddupenc;
int old_style_order2 = false;
int had_layer_cnt=false;
orig_pos = 0;
sf = SplineFontEmpty();
if ( sfdversion>0 && sfdversion<2 ) {
sf = realloc(sf,sizeof(SplineFont1));
memset(((uint8 *) sf) + sizeof(SplineFont),0,sizeof(SplineFont1)-sizeof(SplineFont));
}
sf->sfd_version = sfdversion;
sf->cidmaster = cidmaster;
sf->uni_interp = ui_unset;
SFD_GetFontMetaDataData d;
SFD_GetFontMetaDataData_Init( &d );
while ( 1 ) {
if ( pushedbacktok )
pushedbacktok = false;
else if ( (eof = getname(sfd,tok))!=1 ) {
if ( eof==-1 )
break;
geteol(sfd,tok);
continue;
}
bool wasMetadata = SFD_GetFontMetaData( sfd, tok, sf, &d );
had_layer_cnt = d.had_layer_cnt;
if( wasMetadata )
{
continue;
}
if ( strmatch(tok,""DisplaySize:"")==0 )
{
getint(sfd,&sf->display_size);
}
else if ( strmatch(tok,""DisplayLayer:"")==0 )
{
getint(sfd,&sf->display_layer);
}
else if ( strmatch(tok,""ExtremaBound:"")==0 )
{
getint(sfd,&sf->extrema_bound);
}
else if ( strmatch(tok,""WidthSeparation:"")==0 )
{
getint(sfd,&sf->width_separation);
}
else if ( strmatch(tok,""WinInfo:"")==0 )
{
int temp1, temp2;
getint(sfd,&sf->top_enc);
getint(sfd,&temp1);
getint(sfd,&temp2);
if ( sf->top_enc<=0 ) sf->top_enc=-1;
if ( temp1<=0 ) temp1 = 16;
if ( temp2<=0 ) temp2 = 4;
sf->desired_col_cnt = temp1;
sf->desired_row_cnt = temp2;
}
else if ( strmatch(tok,""AntiAlias:"")==0 )
{
int temp;
getint(sfd,&temp);
sf->display_antialias = temp;
}
else if ( strmatch(tok,""FitToEm:"")==0 )
{
int temp;
getint(sfd,&temp);
sf->display_bbsized = temp;
}
else if ( strmatch(tok,""OnlyBitmaps:"")==0 )
{
int temp;
getint(sfd,&temp);
sf->onlybitmaps = temp;
}
else if ( strmatch(tok,""Order2:"")==0 )
{
getint(sfd,&old_style_order2);
sf->grid.order2 = old_style_order2;
sf->layers[ly_back].order2 = old_style_order2;
sf->layers[ly_fore].order2 = old_style_order2;
}
else if ( strmatch(tok,""GridOrder2:"")==0 )
{
int o2;
getint(sfd,&o2);
sf->grid.order2 = o2;
}
else if ( strmatch(tok,""Encoding:"")==0 )
{
enc = SFDGetEncoding(sfd,tok);
if ( sf->map!=NULL ) sf->map->enc = enc;
}
else if ( strmatch(tok,""OldEncoding:"")==0 )
{
(void) SFDGetEncoding(sfd,tok);
}
else if ( strmatch(tok,""UnicodeInterp:"")==0 )
{
sf->uni_interp = SFDGetUniInterp(sfd,tok,sf);
}
else if ( strmatch(tok,""NameList:"")==0 )
{
SFDGetNameList(sfd,tok,sf);
}
else if ( strmatch(tok,""Compacted:"")==0 )
{
int temp;
getint(sfd,&temp);
sf->compacted = temp;
}
else if ( strmatch(tok,""Registry:"")==0 )
{
geteol(sfd,tok);
sf->cidregistry = copy(tok);
}
else if ( strmatch(tok,""Ordering:"")==0 ) {
geteol(sfd,tok);
sf->ordering = copy(tok);
} else if ( strmatch(tok,""Supplement:"")==0 ) {
getint(sfd,&sf->supplement);
} else if ( strmatch(tok,""RemapN:"")==0 ) {
int n;
getint(sfd,&n);
remap = calloc(n+1,sizeof(struct remap));
remap[n].infont = -1;
mappos = 0;
if ( sf->map!=NULL ) sf->map->remap = remap;
} else if ( strmatch(tok,""Remap:"")==0 ) {
uint32 f, l; int p;
gethex(sfd,&f);
gethex(sfd,&l);
getint(sfd,&p);
if ( remap!=NULL && remap[mappos].infont!=-1 ) {
remap[mappos].firstenc = f;
remap[mappos].lastenc = l;
remap[mappos].infont = p;
mappos++;
}
} else if ( strmatch(tok,""CIDVersion:"")==0 ) {
real temp;
getreal(sfd,&temp);
sf->cidversion = temp;
} else if ( strmatch(tok,""Grid"")==0 ) {
sf->grid.splines = SFDGetSplineSet(sfd,sf->grid.order2);
} else if ( strmatch(tok,""ScriptLang:"")==0 ) {
int i,j,k;
int imax, jmax, kmax;
if ( sf->sfd_version==0 || sf->sfd_version>=2 ) {
IError( ""Script lang lists should not happen in version 2 sfd files."" );
SplineFontFree(sf);
return NULL;
}
getint(sfd,&imax);
((SplineFont1 *) sf)->sli_cnt = imax;
((SplineFont1 *) sf)->script_lang = malloc((imax+1)*sizeof(struct script_record *));
((SplineFont1 *) sf)->script_lang[imax] = NULL;
for ( i=0; i<imax; ++i ) {
getint(sfd,&jmax);
((SplineFont1 *) sf)->script_lang[i] = malloc((jmax+1)*sizeof(struct script_record));
((SplineFont1 *) sf)->script_lang[i][jmax].script = 0;
for ( j=0; j<jmax; ++j ) {
((SplineFont1 *) sf)->script_lang[i][j].script = gettag(sfd);
getint(sfd,&kmax);
((SplineFont1 *) sf)->script_lang[i][j].langs = malloc((kmax+1)*sizeof(uint32));
((SplineFont1 *) sf)->script_lang[i][j].langs[kmax] = 0;
for ( k=0; k<kmax; ++k ) {
((SplineFont1 *) sf)->script_lang[i][j].langs[k] = gettag(sfd);
}
}
}
} else if ( strmatch(tok,""TeXData:"")==0 ) {
int temp;
getint(sfd,&temp);
sf->texdata.type = temp;
getint(sfd, &temp);
if ( sf->design_size==0 ) {
sf->design_size = (5*temp+(1<<18))>>19;
}
for ( i=0; i<22; ++i ) {
int foo;
getint(sfd,&foo);
sf->texdata.params[i]=foo;
}
} else if ( strnmatch(tok,""AnchorClass"",11)==0 ) {
char *name;
AnchorClass *lastan = NULL, *an;
int old = strchr(tok,'2')==NULL;
while ( (name=SFDReadUTF7Str(sfd))!=NULL ) {
an = chunkalloc(old ? sizeof(AnchorClass1) : sizeof(AnchorClass));
an->name = name;
if ( old ) {
getname(sfd,tok);
if ( tok[0]=='0' && tok[1]=='\0' )
((AnchorClass1 *) an)->feature_tag = 0;
else {
if ( tok[1]=='\0' ) { tok[1]=' '; tok[2] = 0; }
if ( tok[2]=='\0' ) { tok[2]=' '; tok[3] = 0; }
if ( tok[3]=='\0' ) { tok[3]=' '; tok[4] = 0; }
((AnchorClass1 *) an)->feature_tag = (tok[0]<<24) | (tok[1]<<16) | (tok[2]<<8) | tok[3];
}
while ( (ch=nlgetc(sfd))==' ' || ch=='\t' );
ungetc(ch,sfd);
if ( isdigit(ch)) {
int temp;
getint(sfd,&temp);
((AnchorClass1 *) an)->flags = temp;
}
while ( (ch=nlgetc(sfd))==' ' || ch=='\t' );
ungetc(ch,sfd);
if ( isdigit(ch)) {
int temp;
getint(sfd,&temp);
((AnchorClass1 *) an)->script_lang_index = temp;
} else
((AnchorClass1 *) an)->script_lang_index = 0xffff;
while ( (ch=nlgetc(sfd))==' ' || ch=='\t' );
ungetc(ch,sfd);
if ( isdigit(ch)) {
int temp;
getint(sfd,&temp);
((AnchorClass1 *) an)->merge_with = temp;
} else
((AnchorClass1 *) an)->merge_with = 0xffff;
} else {
char *subtable_name = SFDReadUTF7Str(sfd);
if ( subtable_name!=NULL)                                           
an->subtable = SFFindLookupSubtableAndFreeName(sf,subtable_name);
}
while ( (ch=nlgetc(sfd))==' ' || ch=='\t' );
ungetc(ch,sfd);
if ( isdigit(ch) ) {
int temp;
getint(sfd,&temp);
an->type = temp;
} else if ( old ) {
if ( ((AnchorClass1 *) an)->feature_tag==CHR('c','u','r','s'))
an->type = act_curs;
else if ( ((AnchorClass1 *) an)->feature_tag==CHR('m','k','m','k'))
an->type = act_mkmk;
else
an->type = act_mark;
} else {
an->type = act_mark;
if( an->subtable && an->subtable->lookup )
{
switch ( an->subtable->lookup->lookup_type )
{
case gpos_cursive:
an->type = act_curs;
break;
case gpos_mark2base:
an->type = act_mark;
break;
case gpos_mark2ligature:
an->type = act_mklg;
break;
case gpos_mark2mark:
an->type = act_mkmk;
break;
default:
an->type = act_mark;
break;
}
}
}
if ( lastan==NULL )
sf->anchor = an;
else
lastan->next = an;
lastan = an;
}
} else if ( strncmp(tok,""MATH:"",5)==0 ) {
SFDParseMathItem(sfd,sf,tok);
} else if ( strmatch(tok,""TableOrder:"")==0 ) {
int temp;
struct table_ordering *ord;
if ( sfdversion==0 || sfdversion>=2 ) {
IError(""Table ordering specified in version 2 sfd file.\n"" );
SplineFontFree(sf);
return NULL;
}
ord = chunkalloc(sizeof(struct table_ordering));
ord->table_tag = gettag(sfd);
getint(sfd,&temp);
ord->ordered_features = malloc((temp+1)*sizeof(uint32));
ord->ordered_features[temp] = 0;
for ( i=0; i<temp; ++i ) {
while ( isspace((ch=nlgetc(sfd))) );
if ( ch=='\'' ) {
ungetc(ch,sfd);
ord->ordered_features[i] = gettag(sfd);
} else if ( ch=='<' ) {
int f,s;
fscanf(sfd,""%d,%d>"", &f, &s );
ord->ordered_features[i] = (f<<16)|s;
}
}
if ( lastord==NULL )
((SplineFont1 *) sf)->orders = ord;
else
lastord->next = ord;
lastord = ord;
} else if ( strmatch(tok,""BeginPrivate:"")==0 ) {
SFDGetPrivate(sfd,sf);
} else if ( strmatch(tok,""BeginSubrs:"")==0 ) {
SFDGetSubrs(sfd);
} else if ( strmatch(tok,""PickledData:"")==0 ) {
if (sf->python_persistent != NULL) {
#if defined(_NO_PYTHON)
free( sf->python_persistent );
#else
PyFF_FreePythonPersistent(sf->python_persistent);
#endif
sf->python_persistent = NULL;
}
sf->python_persistent = SFDUnPickle(sfd, 0);
sf->python_persistent_has_lists = 0;
} else if ( strmatch(tok,""PickledDataWithLists:"")==0 ) {
if (sf->python_persistent != NULL) {
#if defined(_NO_PYTHON)
free( sf->python_persistent );
#else
PyFF_FreePythonPersistent(sf->python_persistent);
#endif
sf->python_persistent = NULL;
}
sf->python_persistent = SFDUnPickle(sfd, 1);
sf->python_persistent_has_lists = 1;
} else if ( strmatch(tok,""MMCounts:"")==0 ) {
MMSet *mm = sf->mm = chunkalloc(sizeof(MMSet));
getint(sfd,&mm->instance_count);
getint(sfd,&mm->axis_count);
ch = nlgetc(sfd);
if ( ch!=' ' )
ungetc(ch,sfd);
else { int temp;
getint(sfd,&temp);
mm->apple = temp;
getint(sfd,&mm->named_instance_count);
}
mm->instances = calloc(mm->instance_count,sizeof(SplineFont *));
mm->positions = malloc(mm->instance_count*mm->axis_count*sizeof(real));
mm->defweights = malloc(mm->instance_count*sizeof(real));
mm->axismaps = calloc(mm->axis_count,sizeof(struct axismap));
if ( mm->named_instance_count!=0 )
mm->named_instances = calloc(mm->named_instance_count,sizeof(struct named_instance));
} else if ( strmatch(tok,""MMAxis:"")==0 ) {
MMSet *mm = sf->mm;
if ( mm!=NULL ) {
for ( i=0; i<mm->axis_count; ++i ) {
getname(sfd,tok);
mm->axes[i] = copy(tok);
}
}
} else if ( strmatch(tok,""MMPositions:"")==0 ) {
MMSet *mm = sf->mm;
if ( mm!=NULL ) {
for ( i=0; i<mm->axis_count*mm->instance_count; ++i )
getreal(sfd,&mm->positions[i]);
}
} else if ( strmatch(tok,""MMWeights:"")==0 ) {
MMSet *mm = sf->mm;
if ( mm!=NULL ) {
for ( i=0; i<mm->instance_count; ++i )
getreal(sfd,&mm->defweights[i]);
}
} else if ( strmatch(tok,""MMAxisMap:"")==0 ) {
MMSet *mm = sf->mm;
if ( mm!=NULL ) {
int index, points;
getint(sfd,&index); getint(sfd,&points);
mm->axismaps[index].points = points;
mm->axismaps[index].blends = malloc(points*sizeof(real));
mm->axismaps[index].designs = malloc(points*sizeof(real));
for ( i=0; i<points; ++i ) {
getreal(sfd,&mm->axismaps[index].blends[i]);
while ( (ch=nlgetc(sfd))!=EOF && isspace(ch));
ungetc(ch,sfd);
if ( (ch=nlgetc(sfd))!='=' )
ungetc(ch,sfd);
else if ( (ch=nlgetc(sfd))!='>' )
ungetc(ch,sfd);
getreal(sfd,&mm->axismaps[index].designs[i]);
}
lastaxismap = &mm->axismaps[index];
lastnamedinstance = NULL;
}
} else if ( strmatch(tok,""MMNamedInstance:"")==0 ) {
MMSet *mm = sf->mm;
if ( mm!=NULL ) {
int index;
getint(sfd,&index);
mm->named_instances[index].coords = malloc(mm->axis_count*sizeof(real));
for ( i=0; i<mm->axis_count; ++i )
getreal(sfd,&mm->named_instances[index].coords[i]);
lastnamedinstance = &mm->named_instances[index];
lastaxismap = NULL;
}
} else if ( strmatch(tok,""MacName:"")==0 ) {
struct macname *names = SFDParseMacNames(sfd,tok);
if ( lastaxismap!=NULL )
lastaxismap->axisnames = names;
else if ( lastnamedinstance !=NULL )
lastnamedinstance->names = names;
pushedbacktok = true;
} else if ( strmatch(tok,""MMCDV:"")==0 ) {
MMSet *mm = sf->mm;
if ( mm!=NULL )
mm->cdv = SFDParseMMSubroutine(sfd);
} else if ( strmatch(tok,""MMNDV:"")==0 ) {
MMSet *mm = sf->mm;
if ( mm!=NULL )
mm->ndv = SFDParseMMSubroutine(sfd);
} else if ( strmatch(tok,""BeginMMFonts:"")==0 ) {
int cnt;
getint(sfd,&cnt);
getint(sfd,&realcnt);
ff_progress_change_stages(cnt);
ff_progress_change_total(realcnt);
MMInferStuff(sf->mm);
break;
} else if ( strmatch(tok,""BeginSubFonts:"")==0 ) {
getint(sfd,&sf->subfontcnt);
sf->subfonts = calloc(sf->subfontcnt,sizeof(SplineFont *));
getint(sfd,&realcnt);
sf->map = EncMap1to1(realcnt);
ff_progress_change_stages(2);
ff_progress_change_total(realcnt);
break;
} else if ( strmatch(tok,""BeginChars:"")==0 ) {
int charcnt;
getint(sfd,&charcnt);
if (charcnt<enc->char_cnt) {
IError(""SFD file specifies too few slots for its encoding.\n"" );
exit( 1 );
}
if ( getint(sfd,&realcnt)!=1 || realcnt==-1 )
realcnt = charcnt;
else
++realcnt;
ff_progress_change_total(realcnt);
sf->glyphcnt = sf->glyphmax = realcnt;
sf->glyphs = calloc(realcnt,sizeof(SplineChar *));
if ( cidmaster!=NULL ) {
sf->map = cidmaster->map;
} else {
sf->map = EncMapNew(charcnt,realcnt,enc);
sf->map->remap = remap;
}
SFDSizeMap(sf->map,sf->glyphcnt,charcnt);
break;
#if HANYANG
} else if ( strmatch(tok,""BeginCompositionRules"")==0 ) {
sf->rules = SFDReadCompositionRules(sfd);
#endif
} else {
geteol(sfd,tok);
}
}
if ( fromdir )
sf = SFD_FigureDirType(sf,tok,dirname,enc,remap,had_layer_cnt);
else if ( sf->subfontcnt!=0 ) {
ff_progress_change_stages(2*sf->subfontcnt);
for ( i=0; i<sf->subfontcnt; ++i ) {
if ( i!=0 )
ff_progress_next_stage();
sf->subfonts[i] = SFD_GetFont(sfd,sf,tok,fromdir,dirname,sfdversion);
}
} else if ( sf->mm!=NULL ) {
MMSet *mm = sf->mm;
ff_progress_change_stages(2*(mm->instance_count+1));
for ( i=0; i<mm->instance_count; ++i ) {
if ( i!=0 )
ff_progress_next_stage();
mm->instances[i] = SFD_GetFont(sfd,NULL,tok,fromdir,dirname,sfdversion);
EncMapFree(mm->instances[i]->map); mm->instances[i]->map=NULL;
mm->instances[i]->mm = mm;
}
ff_progress_next_stage();
mm->normal = SFD_GetFont(sfd,NULL,tok,fromdir,dirname,sfdversion);
mm->normal->mm = mm;
sf->mm = NULL;
SplineFontFree(sf);
sf = mm->normal;
if ( sf->map->enc!=&custom ) {
EncMap *map;
MMMatchGlyphs(mm);
map = EncMapFromEncoding(sf,sf->map->enc);
EncMapFree(sf->map);
sf->map = map;
}
} else {
while ( SFDGetChar(sfd,sf,had_layer_cnt)!=NULL ) {
ff_progress_next();
}
ff_progress_next_stage();
}
haddupenc = false;
while ( getname(sfd,tok)==1 ) {
if ( strcmp(tok,""EndSplineFont"")==0 || strcmp(tok,""EndSubSplineFont"")==0 )
break;
else if ( strcmp(tok,""BitmapFont:"")==0 )
SFDGetBitmapFont(sfd,sf,false,NULL);
else if ( strmatch(tok,""DupEnc:"")==0 ) {
int enc, orig;
haddupenc = true;
if ( getint(sfd,&enc) && getint(sfd,&orig) && sf->map!=NULL ) {
SFDSetEncMap(sf,orig,enc);
}
}
}
if ( sf->cidmaster==NULL )
SFDFixupRefs(sf);
if ( !haddupenc )
SFD_DoAltUnis(sf);
else
AltUniFigure(sf,sf->map,true);
if ( sf->sfd_version<2 )
SFD_AssignLookups((SplineFont1 *) sf);
if ( !d.hadtimes )
SFTimesFromFile(sf,sfd);
if (sf->map == NULL) sf->map = EncMapNew(sf->glyphcnt,sf->glyphcnt,&custom);
SFDFixupUndoRefs(sf);
return( sf );
}","static SplineFont *SFD_GetFont( FILE *VAR_0,SplineFont *VAR_1,char *VAR_2,
int VAR_3, char *VAR_4, float VAR_5 )
{
SplineFont *VAR_6;
int VAR_7, VAR_8, VAR_9, VAR_10=-1, VAR_11;
struct table_ordering *VAR_12 = NULL;
struct axismap *VAR_13 = NULL;
struct named_instance *VAR_14 = NULL;
int VAR_15 = false;
Encoding *VAR_16 = &VAR_17;
struct remap *remap = NULL;
int VAR_18;
int VAR_19 = false;
int VAR_20=false;
VAR_21 = 0;
VAR_6 = SplineFontEmpty();
if ( VAR_5>0 && VAR_5<2 ) {
VAR_6 = realloc(VAR_6,sizeof(VAR_22));
memset(((uint8 *) VAR_6) + sizeof(SplineFont),0,sizeof(VAR_22)-sizeof(SplineFont));
}
VAR_6->sfd_version = VAR_5;
VAR_6->cidmaster = VAR_1;
VAR_6->uni_interp = VAR_23;
SFD_GetFontMetaDataData VAR_24;
SFD_GetFontMetaDataData_Init( &VAR_24 );
while ( 1 ) {
if ( VAR_15 )
VAR_15 = false;
else if ( (VAR_9 = getname(VAR_0,VAR_2))!=1 ) {
if ( VAR_9==-1 )
break;
geteol(VAR_0,VAR_2);
continue;
}
bool VAR_25 = SFD_GetFontMetaData( VAR_0, VAR_2, VAR_6, &VAR_24 );
VAR_20 = VAR_24.had_layer_cnt;
if( VAR_25 )
{
continue;
}
if ( strmatch(VAR_2,""DisplaySize:"")==0 )
{
getint(VAR_0,&VAR_6->display_size);
}
else if ( strmatch(VAR_2,""DisplayLayer:"")==0 )
{
getint(VAR_0,&VAR_6->display_layer);
}
else if ( strmatch(VAR_2,""ExtremaBound:"")==0 )
{
getint(VAR_0,&VAR_6->extrema_bound);
}
else if ( strmatch(VAR_2,""WidthSeparation:"")==0 )
{
getint(VAR_0,&VAR_6->width_separation);
}
else if ( strmatch(VAR_2,""WinInfo:"")==0 )
{
int VAR_26, VAR_27;
getint(VAR_0,&VAR_6->top_enc);
getint(VAR_0,&VAR_26);
getint(VAR_0,&VAR_27);
if ( VAR_6->top_enc<=0 ) VAR_6->top_enc=-1;
if ( VAR_26<=0 ) VAR_26 = 16;
if ( VAR_27<=0 ) VAR_27 = 4;
VAR_6->desired_col_cnt = VAR_26;
VAR_6->desired_row_cnt = VAR_27;
}
else if ( strmatch(VAR_2,""AntiAlias:"")==0 )
{
int VAR_28;
getint(VAR_0,&VAR_28);
VAR_6->display_antialias = VAR_28;
}
else if ( strmatch(VAR_2,""FitToEm:"")==0 )
{
int VAR_28;
getint(VAR_0,&VAR_28);
VAR_6->display_bbsized = VAR_28;
}
else if ( strmatch(VAR_2,""OnlyBitmaps:"")==0 )
{
int VAR_28;
getint(VAR_0,&VAR_28);
VAR_6->onlybitmaps = VAR_28;
}
else if ( strmatch(VAR_2,""Order2:"")==0 )
{
getint(VAR_0,&VAR_19);
VAR_6->grid.order2 = VAR_19;
VAR_6->layers[VAR_29].order2 = VAR_19;
VAR_6->layers[VAR_30].order2 = VAR_19;
}
else if ( strmatch(VAR_2,""GridOrder2:"")==0 )
{
int VAR_31;
getint(VAR_0,&VAR_31);
VAR_6->grid.order2 = VAR_31;
}
else if ( strmatch(VAR_2,""Encoding:"")==0 )
{
VAR_16 = SFDGetEncoding(VAR_0,VAR_2);
if ( VAR_6->map!=NULL ) VAR_6->map->enc = VAR_16;
}
else if ( strmatch(VAR_2,""OldEncoding:"")==0 )
{
(void) SFDGetEncoding(VAR_0,VAR_2);
}
else if ( strmatch(VAR_2,""UnicodeInterp:"")==0 )
{
VAR_6->uni_interp = SFDGetUniInterp(VAR_0,VAR_2,VAR_6);
}
else if ( strmatch(VAR_2,""NameList:"")==0 )
{
SFDGetNameList(VAR_0,VAR_2,VAR_6);
}
else if ( strmatch(VAR_2,""Compacted:"")==0 )
{
int VAR_28;
getint(VAR_0,&VAR_28);
VAR_6->compacted = VAR_28;
}
else if ( strmatch(VAR_2,""Registry:"")==0 )
{
geteol(VAR_0,VAR_2);
VAR_6->cidregistry = copy(VAR_2);
}
else if ( strmatch(VAR_2,""Ordering:"")==0 ) {
geteol(VAR_0,VAR_2);
VAR_6->ordering = copy(VAR_2);
} else if ( strmatch(VAR_2,""Supplement:"")==0 ) {
getint(VAR_0,&VAR_6->supplement);
} else if ( strmatch(VAR_2,""RemapN:"")==0 ) {
int VAR_32;
getint(VAR_0,&VAR_32);
remap = calloc(VAR_32+1,sizeof(struct remap));
remap[VAR_32].infont = -1;
VAR_10 = 0;
if ( VAR_6->map!=NULL ) VAR_6->map->remap = remap;
} else if ( strmatch(VAR_2,""Remap:"")==0 ) {
uint32 VAR_33, VAR_34; int VAR_35;
gethex(VAR_0,&VAR_33);
gethex(VAR_0,&VAR_34);
getint(VAR_0,&VAR_35);
if ( remap!=NULL && remap[VAR_10].infont!=-1 ) {
remap[VAR_10].firstenc = VAR_33;
remap[VAR_10].lastenc = VAR_34;
remap[VAR_10].infont = VAR_35;
VAR_10++;
}
} else if ( strmatch(VAR_2,""CIDVersion:"")==0 ) {
real VAR_28;
getreal(VAR_0,&VAR_28);
VAR_6->cidversion = VAR_28;
} else if ( strmatch(VAR_2,""Grid"")==0 ) {
VAR_6->grid.splines = SFDGetSplineSet(VAR_0,VAR_6->grid.order2);
} else if ( strmatch(VAR_2,""ScriptLang:"")==0 ) {
int VAR_8,VAR_36,VAR_37;
int VAR_38, VAR_39, VAR_40;
if ( VAR_6->sfd_version==0 || VAR_6->sfd_version>=2 ) {
IError( ""Script lang lists should not happen in version 2 sfd files."" );
SplineFontFree(VAR_6);
return NULL;
}
getint(VAR_0,&VAR_38);
((SplineFont1 *) VAR_6)->sli_cnt = VAR_38;
((SplineFont1 *) VAR_6)->script_lang = malloc((VAR_38+1)*sizeof(struct script_record *));
((SplineFont1 *) VAR_6)->script_lang[VAR_38] = NULL;
for ( VAR_8=0; VAR_8<VAR_38; ++VAR_8 ) {
getint(VAR_0,&VAR_39);
((SplineFont1 *) VAR_6)->script_lang[VAR_8] = malloc((VAR_39+1)*sizeof(struct script_record));
((SplineFont1 *) VAR_6)->script_lang[VAR_8][VAR_39].script = 0;
for ( VAR_36=0; VAR_36<VAR_39; ++VAR_36 ) {
((SplineFont1 *) VAR_6)->script_lang[VAR_8][VAR_36].script = gettag(VAR_0);
getint(VAR_0,&VAR_40);
((SplineFont1 *) VAR_6)->script_lang[VAR_8][VAR_36].langs = malloc((VAR_40+1)*sizeof(uint32));
((SplineFont1 *) VAR_6)->script_lang[VAR_8][VAR_36].langs[VAR_40] = 0;
for ( VAR_37=0; VAR_37<VAR_40; ++VAR_37 ) {
((SplineFont1 *) VAR_6)->script_lang[VAR_8][VAR_36].langs[VAR_37] = gettag(VAR_0);
}
}
}
} else if ( strmatch(VAR_2,""TeXData:"")==0 ) {
int VAR_28;
getint(VAR_0,&VAR_28);
VAR_6->texdata.type = VAR_28;
getint(VAR_0, &VAR_28);
if ( VAR_6->design_size==0 ) {
VAR_6->design_size = (5*VAR_28+(1<<18))>>19;
}
for ( VAR_8=0; VAR_8<22; ++VAR_8 ) {
int VAR_41;
getint(VAR_0,&VAR_41);
VAR_6->texdata.params[VAR_8]=VAR_41;
}
} else if ( strnmatch(VAR_2,""AnchorClass"",11)==0 ) {
char *VAR_42;
AnchorClass *VAR_43 = NULL, *VAR_44;
int VAR_45 = strchr(VAR_2,'2')==NULL;
while ( (VAR_42=SFDReadUTF7Str(VAR_0))!=NULL ) {
VAR_44 = chunkalloc(VAR_45 ? sizeof(VAR_46) : sizeof(AnchorClass));
VAR_44->name = VAR_42;
if ( VAR_45 ) {
getname(VAR_0,VAR_2);
if ( VAR_2[0]=='0' && VAR_2[1]=='\0' )
((AnchorClass1 *) VAR_44)->feature_tag = 0;
else {
if ( VAR_2[1]=='\0' ) { VAR_2[1]=' '; VAR_2[2] = 0; }
if ( VAR_2[2]=='\0' ) { VAR_2[2]=' '; VAR_2[3] = 0; }
if ( VAR_2[3]=='\0' ) { VAR_2[3]=' '; VAR_2[4] = 0; }
((AnchorClass1 *) VAR_44)->feature_tag = (VAR_2[0]<<24) | (VAR_2[1]<<16) | (VAR_2[2]<<8) | VAR_2[3];
}
while ( (VAR_11=nlgetc(VAR_0))==' ' || VAR_11=='\t' );
ungetc(VAR_11,VAR_0);
if ( isdigit(VAR_11)) {
int VAR_28;
getint(VAR_0,&VAR_28);
((AnchorClass1 *) VAR_44)->flags = VAR_28;
}
while ( (VAR_11=nlgetc(VAR_0))==' ' || VAR_11=='\t' );
ungetc(VAR_11,VAR_0);
if ( isdigit(VAR_11)) {
int VAR_28;
getint(VAR_0,&VAR_28);
((AnchorClass1 *) VAR_44)->script_lang_index = VAR_28;
} else
((AnchorClass1 *) VAR_44)->script_lang_index = 0xffff;
while ( (VAR_11=nlgetc(VAR_0))==' ' || VAR_11=='\t' );
ungetc(VAR_11,VAR_0);
if ( isdigit(VAR_11)) {
int VAR_28;
getint(VAR_0,&VAR_28);
((AnchorClass1 *) VAR_44)->merge_with = VAR_28;
} else
((AnchorClass1 *) VAR_44)->merge_with = 0xffff;
} else {
char *VAR_47 = SFDReadUTF7Str(VAR_0);
if ( VAR_47!=NULL)                                           
VAR_44->subtable = SFFindLookupSubtableAndFreeName(VAR_6,VAR_47);
}
while ( (VAR_11=nlgetc(VAR_0))==' ' || VAR_11=='\t' );
ungetc(VAR_11,VAR_0);
if ( isdigit(VAR_11) ) {
int VAR_28;
getint(VAR_0,&VAR_28);
VAR_44->type = VAR_28;
} else if ( VAR_45 ) {
if ( ((AnchorClass1 *) VAR_44)->feature_tag==CHR('c','u','r','s'))
VAR_44->type = VAR_48;
else if ( ((AnchorClass1 *) VAR_44)->feature_tag==CHR('m','k','m','k'))
VAR_44->type = VAR_49;
else
VAR_44->type = VAR_50;
} else {
VAR_44->type = VAR_50;
if( VAR_44->subtable && VAR_44->subtable->lookup )
{
switch ( VAR_44->subtable->lookup->lookup_type )
{
case VAR_51:
VAR_44->type = VAR_48;
break;
case VAR_52:
VAR_44->type = VAR_50;
break;
case VAR_53:
VAR_44->type = VAR_54;
break;
case VAR_55:
VAR_44->type = VAR_49;
break;
default:
VAR_44->type = VAR_50;
break;
}
}
}
if ( VAR_43==NULL )
VAR_6->anchor = VAR_44;
else
VAR_43->next = VAR_44;
VAR_43 = VAR_44;
}
} else if ( strncmp(VAR_2,""MATH:"",5)==0 ) {
SFDParseMathItem(VAR_0,VAR_6,VAR_2);
} else if ( strmatch(VAR_2,""TableOrder:"")==0 ) {
int VAR_28;
struct table_ordering *VAR_56;
if ( VAR_5==0 || VAR_5>=2 ) {
IError(""Table ordering specified in version 2 sfd file.\n"" );
SplineFontFree(VAR_6);
return NULL;
}
VAR_56 = chunkalloc(sizeof(struct table_ordering));
VAR_56->table_tag = gettag(VAR_0);
getint(VAR_0,&VAR_28);
VAR_56->ordered_features = malloc((VAR_28+1)*sizeof(uint32));
VAR_56->ordered_features[VAR_28] = 0;
for ( VAR_8=0; VAR_8<VAR_28; ++VAR_8 ) {
while ( isspace((VAR_11=nlgetc(VAR_0))) );
if ( VAR_11=='\'' ) {
ungetc(VAR_11,VAR_0);
VAR_56->ordered_features[VAR_8] = gettag(VAR_0);
} else if ( VAR_11=='<' ) {
int VAR_33,VAR_57;
fscanf(VAR_0,""%d,%d>"", &VAR_33, &VAR_57 );
VAR_56->ordered_features[VAR_8] = (VAR_33<<16)|VAR_57;
}
}
if ( VAR_12==NULL )
((SplineFont1 *) VAR_6)->orders = VAR_56;
else
VAR_12->next = VAR_56;
VAR_12 = VAR_56;
} else if ( strmatch(VAR_2,""BeginPrivate:"")==0 ) {
SFDGetPrivate(VAR_0,VAR_6);
} else if ( strmatch(VAR_2,""BeginSubrs:"")==0 ) {
SFDGetSubrs(VAR_0);
} else if ( strmatch(VAR_2,""PickledData:"")==0 ) {
if (VAR_6->python_persistent != NULL) {
#if defined(VAR_58)
free( VAR_6->python_persistent );
#else
PyFF_FreePythonPersistent(VAR_6->python_persistent);
#endif
VAR_6->python_persistent = NULL;
}
VAR_6->python_persistent = SFDUnPickle(VAR_0, 0);
VAR_6->python_persistent_has_lists = 0;
} else if ( strmatch(VAR_2,""PickledDataWithLists:"")==0 ) {
if (VAR_6->python_persistent != NULL) {
#if defined(VAR_58)
free( VAR_6->python_persistent );
#else
PyFF_FreePythonPersistent(VAR_6->python_persistent);
#endif
VAR_6->python_persistent = NULL;
}
VAR_6->python_persistent = SFDUnPickle(VAR_0, 1);
VAR_6->python_persistent_has_lists = 1;
} else if ( strmatch(VAR_2,""MMCounts:"")==0 ) {
MMSet *VAR_59 = VAR_6->mm = chunkalloc(sizeof(MMSet));
getint(VAR_0,&VAR_59->instance_count);
getint(VAR_0,&VAR_59->axis_count);
VAR_11 = nlgetc(VAR_0);
if ( VAR_11!=' ' )
ungetc(VAR_11,VAR_0);
else { int VAR_28;
getint(VAR_0,&VAR_28);
VAR_59->apple = VAR_28;
getint(VAR_0,&VAR_59->named_instance_count);
}
VAR_59->instances = calloc(VAR_59->instance_count,sizeof(SplineFont *));
VAR_59->positions = malloc(VAR_59->instance_count*VAR_59->axis_count*sizeof(real));
VAR_59->defweights = malloc(VAR_59->instance_count*sizeof(real));
VAR_59->axismaps = calloc(VAR_59->axis_count,sizeof(struct axismap));
if ( VAR_59->named_instance_count!=0 )
VAR_59->named_instances = calloc(VAR_59->named_instance_count,sizeof(struct named_instance));
} else if ( strmatch(VAR_2,""MMAxis:"")==0 ) {
MMSet *VAR_59 = VAR_6->mm;
if ( VAR_59!=NULL ) {
for ( VAR_8=0; VAR_8<VAR_59->axis_count; ++VAR_8 ) {
getname(VAR_0,VAR_2);
VAR_59->axes[VAR_8] = copy(VAR_2);
}
}
} else if ( strmatch(VAR_2,""MMPositions:"")==0 ) {
MMSet *VAR_59 = VAR_6->mm;
if ( VAR_59!=NULL ) {
for ( VAR_8=0; VAR_8<VAR_59->axis_count*VAR_59->instance_count; ++VAR_8 )
getreal(VAR_0,&VAR_59->positions[VAR_8]);
}
} else if ( strmatch(VAR_2,""MMWeights:"")==0 ) {
MMSet *VAR_59 = VAR_6->mm;
if ( VAR_59!=NULL ) {
for ( VAR_8=0; VAR_8<VAR_59->instance_count; ++VAR_8 )
getreal(VAR_0,&VAR_59->defweights[VAR_8]);
}
} else if ( strmatch(VAR_2,""MMAxisMap:"")==0 ) {
MMSet *VAR_59 = VAR_6->mm;
if ( VAR_59!=NULL ) {
int VAR_60, VAR_61;
getint(VAR_0,&VAR_60); getint(VAR_0,&VAR_61);
VAR_59->axismaps[VAR_60].points = VAR_61;
VAR_59->axismaps[VAR_60].blends = malloc(VAR_61*sizeof(real));
VAR_59->axismaps[VAR_60].designs = malloc(VAR_61*sizeof(real));
for ( VAR_8=0; VAR_8<VAR_61; ++VAR_8 ) {
getreal(VAR_0,&VAR_59->axismaps[VAR_60].blends[VAR_8]);
while ( (VAR_11=nlgetc(VAR_0))!=VAR_62 && isspace(VAR_11));
ungetc(VAR_11,VAR_0);
if ( (VAR_11=nlgetc(VAR_0))!='=' )
ungetc(VAR_11,VAR_0);
else if ( (VAR_11=nlgetc(VAR_0))!='>' )
ungetc(VAR_11,VAR_0);
getreal(VAR_0,&VAR_59->axismaps[VAR_60].designs[VAR_8]);
}
VAR_13 = &VAR_59->axismaps[VAR_60];
VAR_14 = NULL;
}
} else if ( strmatch(VAR_2,""MMNamedInstance:"")==0 ) {
MMSet *VAR_59 = VAR_6->mm;
if ( VAR_59!=NULL ) {
int VAR_60;
getint(VAR_0,&VAR_60);
VAR_59->named_instances[VAR_60].coords = malloc(VAR_59->axis_count*sizeof(real));
for ( VAR_8=0; VAR_8<VAR_59->axis_count; ++VAR_8 )
getreal(VAR_0,&VAR_59->named_instances[VAR_60].coords[VAR_8]);
VAR_14 = &VAR_59->named_instances[VAR_60];
VAR_13 = NULL;
}
} else if ( strmatch(VAR_2,""MacName:"")==0 ) {
struct macname *VAR_63 = SFDParseMacNames(VAR_0,VAR_2);
if ( VAR_13!=NULL )
VAR_13->axisnames = VAR_63;
else if ( VAR_14 !=NULL )
VAR_14->names = VAR_63;
VAR_15 = true;
} else if ( strmatch(VAR_2,""MMCDV:"")==0 ) {
MMSet *VAR_59 = VAR_6->mm;
if ( VAR_59!=NULL )
VAR_59->cdv = SFDParseMMSubroutine(VAR_0);
} else if ( strmatch(VAR_2,""MMNDV:"")==0 ) {
MMSet *VAR_59 = VAR_6->mm;
if ( VAR_59!=NULL )
VAR_59->ndv = SFDParseMMSubroutine(VAR_0);
} else if ( strmatch(VAR_2,""BeginMMFonts:"")==0 ) {
int VAR_64;
getint(VAR_0,&VAR_64);
getint(VAR_0,&VAR_7);
ff_progress_change_stages(VAR_64);
ff_progress_change_total(VAR_7);
MMInferStuff(VAR_6->mm);
break;
} else if ( strmatch(VAR_2,""BeginSubFonts:"")==0 ) {
getint(VAR_0,&VAR_6->subfontcnt);
VAR_6->subfonts = calloc(VAR_6->subfontcnt,sizeof(SplineFont *));
getint(VAR_0,&VAR_7);
VAR_6->map = EncMap1to1(VAR_7);
ff_progress_change_stages(2);
ff_progress_change_total(VAR_7);
break;
} else if ( strmatch(VAR_2,""BeginChars:"")==0 ) {
int VAR_65;
getint(VAR_0,&VAR_65);
if (VAR_65<VAR_16->char_cnt) {
IError(""SFD file specifies too few slots for its encoding.\n"" );
exit( 1 );
}
if ( getint(VAR_0,&VAR_7)!=1 || VAR_7==-1 )
VAR_7 = VAR_65;
else
++VAR_7;
ff_progress_change_total(VAR_7);
VAR_6->glyphcnt = VAR_6->glyphmax = VAR_7;
VAR_6->glyphs = calloc(VAR_7,sizeof(SplineChar *));
if ( VAR_1!=NULL ) {
VAR_6->map = VAR_1->map;
} else {
VAR_6->map = EncMapNew(VAR_65,VAR_7,VAR_16);
VAR_6->map->remap = remap;
}
SFDSizeMap(VAR_6->map,VAR_6->glyphcnt,VAR_65);
break;
#if VAR_66
} else if ( strmatch(VAR_2,""BeginCompositionRules"")==0 ) {
VAR_6->rules = SFDReadCompositionRules(VAR_0);
#endif
} else {
geteol(VAR_0,VAR_2);
}
}
if ( VAR_3 )
VAR_6 = SFD_FigureDirType(VAR_6,VAR_2,VAR_4,VAR_16,remap,VAR_20);
else if ( VAR_6->subfontcnt!=0 ) {
ff_progress_change_stages(2*VAR_6->subfontcnt);
for ( VAR_8=0; VAR_8<VAR_6->subfontcnt; ++VAR_8 ) {
if ( VAR_8!=0 )
ff_progress_next_stage();
VAR_6->subfonts[VAR_8] = SFD_GetFont(VAR_0,VAR_6,VAR_2,VAR_3,VAR_4,VAR_5);
}
} else if ( VAR_6->mm!=NULL ) {
MMSet *VAR_59 = VAR_6->mm;
ff_progress_change_stages(2*(VAR_59->instance_count+1));
for ( VAR_8=0; VAR_8<VAR_59->instance_count; ++VAR_8 ) {
if ( VAR_8!=0 )
ff_progress_next_stage();
VAR_59->instances[VAR_8] = SFD_GetFont(VAR_0,NULL,VAR_2,VAR_3,VAR_4,VAR_5);
EncMapFree(VAR_59->instances[VAR_8]->map); VAR_59->instances[VAR_8]->map=NULL;
VAR_59->instances[VAR_8]->mm = VAR_59;
}
ff_progress_next_stage();
VAR_59->normal = SFD_GetFont(VAR_0,NULL,VAR_2,VAR_3,VAR_4,VAR_5);
VAR_59->normal->mm = VAR_59;
VAR_6->mm = NULL;
SplineFontFree(VAR_6);
VAR_6 = VAR_59->normal;
if ( VAR_6->map->enc!=&VAR_17 ) {
EncMap *VAR_67;
MMMatchGlyphs(VAR_59);
VAR_67 = EncMapFromEncoding(VAR_6,VAR_6->map->enc);
EncMapFree(VAR_6->map);
VAR_6->map = VAR_67;
}
} else {
while ( SFDGetChar(VAR_0,VAR_6,VAR_20)!=NULL ) {
ff_progress_next();
}
ff_progress_next_stage();
}
VAR_18 = false;
while ( getname(VAR_0,VAR_2)==1 ) {
if ( strcmp(VAR_2,""EndSplineFont"")==0 || strcmp(VAR_2,""EndSubSplineFont"")==0 )
break;
else if ( strcmp(VAR_2,""BitmapFont:"")==0 )
SFDGetBitmapFont(VAR_0,VAR_6,false,NULL);
else if ( strmatch(VAR_2,""DupEnc:"")==0 ) {
int VAR_16, VAR_68;
VAR_18 = true;
if ( getint(VAR_0,&VAR_16) && getint(VAR_0,&VAR_68) && VAR_6->map!=NULL ) {
SFDSetEncMap(VAR_6,VAR_68,VAR_16);
}
}
}
if ( VAR_6->cidmaster==NULL )
SFDFixupRefs(VAR_6);
if ( !VAR_18 )
SFD_DoAltUnis(VAR_6);
else
AltUniFigure(VAR_6,VAR_6->map,true);
if ( VAR_6->sfd_version<2 )
SFD_AssignLookups((SplineFont1 *) VAR_6);
if ( !VAR_24.hadtimes )
SFTimesFromFile(VAR_6,VAR_0);
if (VAR_6->map == NULL) VAR_6->map = EncMapNew(VAR_6->glyphcnt,VAR_6->glyphcnt,&VAR_17);
SFDFixupUndoRefs(VAR_6);
return( VAR_6 );
}",fontforge/8da6d56bf7af2d25f779e52edef61b2fd4557b3c/sfd.c/vul/before/0.json,"static SplineFont *SFD_GetFont( FILE *sfd,SplineFont *cidmaster,char *tok,
				int fromdir, char *dirname, float sfdversion )
{
    SplineFont *sf;
    int realcnt, i, eof, mappos=-1, ch;
    struct table_ordering *lastord = NULL;
    struct axismap *lastaxismap = NULL;
    struct named_instance *lastnamedinstance = NULL;
    int pushedbacktok = false;
    Encoding *enc = &custom;
    struct remap *remap = NULL;
    int haddupenc;
    int old_style_order2 = false;
    int had_layer_cnt=false;

    orig_pos = 0;		/* Only used for compatibility with extremely old sfd files */

    sf = SplineFontEmpty();
    if ( sfdversion>0 && sfdversion<2 ) {
	/* If it's an old style sfd file with old style features we need some */
	/*  extra data space to do the conversion from old to new */
	sf = realloc(sf,sizeof(SplineFont1));
	memset(((uint8 *) sf) + sizeof(SplineFont),0,sizeof(SplineFont1)-sizeof(SplineFont));
    }
    sf->sfd_version = sfdversion;
    sf->cidmaster = cidmaster;
    sf->uni_interp = ui_unset;
	SFD_GetFontMetaDataData d;
	SFD_GetFontMetaDataData_Init( &d );
    while ( 1 ) {
	if ( pushedbacktok )
	    pushedbacktok = false;
	else if ( (eof = getname(sfd,tok))!=1 ) {
	    if ( eof==-1 )
    break;
	    geteol(sfd,tok);
    continue;
	}


	bool wasMetadata = SFD_GetFontMetaData( sfd, tok, sf, &d );
	had_layer_cnt = d.had_layer_cnt;
        if( wasMetadata )
        {
            // we have handled the token entirely
            // inside SFD_GetFontMetaData() move to next token.
            continue;
        }
        
        
	if ( strmatch(tok,""DisplaySize:"")==0 )
	{
	    getint(sfd,&sf->display_size);
	}
	else if ( strmatch(tok,""DisplayLayer:"")==0 )
	{
	    getint(sfd,&sf->display_layer);
	}
	else if ( strmatch(tok,""ExtremaBound:"")==0 )
	{
	    getint(sfd,&sf->extrema_bound);
	}
	else if ( strmatch(tok,""WidthSeparation:"")==0 )
	{
	    getint(sfd,&sf->width_separation);
	}
	else if ( strmatch(tok,""WinInfo:"")==0 )
	{
	    int temp1, temp2;
	    getint(sfd,&sf->top_enc);
	    getint(sfd,&temp1);
	    getint(sfd,&temp2);
	    if ( sf->top_enc<=0 ) sf->top_enc=-1;
	    if ( temp1<=0 ) temp1 = 16;
	    if ( temp2<=0 ) temp2 = 4;
	    sf->desired_col_cnt = temp1;
	    sf->desired_row_cnt = temp2;
	}
	else if ( strmatch(tok,""AntiAlias:"")==0 )
	{
	    int temp;
	    getint(sfd,&temp);
	    sf->display_antialias = temp;
	}
	else if ( strmatch(tok,""FitToEm:"")==0 )
	{
	    int temp;
	    getint(sfd,&temp);
	    sf->display_bbsized = temp;
	}
	else if ( strmatch(tok,""OnlyBitmaps:"")==0 )
	{
	    int temp;
	    getint(sfd,&temp);
	    sf->onlybitmaps = temp;
	}
	else if ( strmatch(tok,""Order2:"")==0 )
	{
	    getint(sfd,&old_style_order2);
	    sf->grid.order2 = old_style_order2;
	    sf->layers[ly_back].order2 = old_style_order2;
	    sf->layers[ly_fore].order2 = old_style_order2;
	}
	else if ( strmatch(tok,""GridOrder2:"")==0 )
	{
	    int o2;
	    getint(sfd,&o2);
	    sf->grid.order2 = o2;
	}
	else if ( strmatch(tok,""Encoding:"")==0 )
	{
	    enc = SFDGetEncoding(sfd,tok);
	    if ( sf->map!=NULL ) sf->map->enc = enc;
	}
	else if ( strmatch(tok,""OldEncoding:"")==0 )
	{
	    /* old_encname =*/ (void) SFDGetEncoding(sfd,tok);
	}
	else if ( strmatch(tok,""UnicodeInterp:"")==0 )
	{
	    sf->uni_interp = SFDGetUniInterp(sfd,tok,sf);
	}
	else if ( strmatch(tok,""NameList:"")==0 )
	{
	    SFDGetNameList(sfd,tok,sf);
	}
	else if ( strmatch(tok,""Compacted:"")==0 )
	{
	    int temp;
	    getint(sfd,&temp);
	    sf->compacted = temp;
	}
	else if ( strmatch(tok,""Registry:"")==0 )
	{
	    geteol(sfd,tok);
	    sf->cidregistry = copy(tok);
	}


	//////////


	else if ( strmatch(tok,""Ordering:"")==0 ) {
	    geteol(sfd,tok);
	    sf->ordering = copy(tok);
	} else if ( strmatch(tok,""Supplement:"")==0 ) {
	    getint(sfd,&sf->supplement);
	} else if ( strmatch(tok,""RemapN:"")==0 ) {
	    int n;
	    getint(sfd,&n);
	    remap = calloc(n+1,sizeof(struct remap));
	    remap[n].infont = -1;
	    mappos = 0;
	    if ( sf->map!=NULL ) sf->map->remap = remap;
	} else if ( strmatch(tok,""Remap:"")==0 ) {
	    uint32 f, l; int p;
	    gethex(sfd,&f);
	    gethex(sfd,&l);
	    getint(sfd,&p);
	    if ( remap!=NULL && remap[mappos].infont!=-1 ) {
		remap[mappos].firstenc = f;
		remap[mappos].lastenc = l;
		remap[mappos].infont = p;
		mappos++;
	    }
	} else if ( strmatch(tok,""CIDVersion:"")==0 ) {
	    real temp;
	    getreal(sfd,&temp);
	    sf->cidversion = temp;
	} else if ( strmatch(tok,""Grid"")==0 ) {
	    sf->grid.splines = SFDGetSplineSet(sfd,sf->grid.order2);
	} else if ( strmatch(tok,""ScriptLang:"")==0 ) {
	    int i,j,k;
	    int imax, jmax, kmax;
	    if ( sf->sfd_version==0 || sf->sfd_version>=2 ) {
		IError( ""Script lang lists should not happen in version 2 sfd files."" );
                SplineFontFree(sf);
                return NULL;
	    }
	    getint(sfd,&imax);
	    ((SplineFont1 *) sf)->sli_cnt = imax;
	    ((SplineFont1 *) sf)->script_lang = malloc((imax+1)*sizeof(struct script_record *));
	    ((SplineFont1 *) sf)->script_lang[imax] = NULL;
	    for ( i=0; i<imax; ++i ) {
		getint(sfd,&jmax);
		((SplineFont1 *) sf)->script_lang[i] = malloc((jmax+1)*sizeof(struct script_record));
		((SplineFont1 *) sf)->script_lang[i][jmax].script = 0;
		for ( j=0; j<jmax; ++j ) {
		    ((SplineFont1 *) sf)->script_lang[i][j].script = gettag(sfd);
		    getint(sfd,&kmax);
		    ((SplineFont1 *) sf)->script_lang[i][j].langs = malloc((kmax+1)*sizeof(uint32));
		    ((SplineFont1 *) sf)->script_lang[i][j].langs[kmax] = 0;
		    for ( k=0; k<kmax; ++k ) {
			((SplineFont1 *) sf)->script_lang[i][j].langs[k] = gettag(sfd);
		    }
		}
	    }
	} else if ( strmatch(tok,""TeXData:"")==0 ) {
	    int temp;
	    getint(sfd,&temp);
	    sf->texdata.type = temp;
	    getint(sfd, &temp);
	    if ( sf->design_size==0 ) {
	    	sf->design_size = (5*temp+(1<<18))>>19;
	    }
	    for ( i=0; i<22; ++i ) {
		int foo;
		getint(sfd,&foo);
		sf->texdata.params[i]=foo;
	    }
	} else if ( strnmatch(tok,""AnchorClass"",11)==0 ) {
	    char *name;
	    AnchorClass *lastan = NULL, *an;
	    int old = strchr(tok,'2')==NULL;
	    while ( (name=SFDReadUTF7Str(sfd))!=NULL ) {
		an = chunkalloc(old ? sizeof(AnchorClass1) : sizeof(AnchorClass));
		an->name = name;
		if ( old ) {
		    getname(sfd,tok);
		    if ( tok[0]=='0' && tok[1]=='\0' )
			((AnchorClass1 *) an)->feature_tag = 0;
		    else {
			if ( tok[1]=='\0' ) { tok[1]=' '; tok[2] = 0; }
			if ( tok[2]=='\0' ) { tok[2]=' '; tok[3] = 0; }
			if ( tok[3]=='\0' ) { tok[3]=' '; tok[4] = 0; }
			((AnchorClass1 *) an)->feature_tag = (tok[0]<<24) | (tok[1]<<16) | (tok[2]<<8) | tok[3];
		    }
		    while ( (ch=nlgetc(sfd))==' ' || ch=='\t' );
		    ungetc(ch,sfd);
		    if ( isdigit(ch)) {
			int temp;
			getint(sfd,&temp);
			((AnchorClass1 *) an)->flags = temp;
		    }
		    while ( (ch=nlgetc(sfd))==' ' || ch=='\t' );
		    ungetc(ch,sfd);
		    if ( isdigit(ch)) {
			int temp;
			getint(sfd,&temp);
			((AnchorClass1 *) an)->script_lang_index = temp;
		    } else
			((AnchorClass1 *) an)->script_lang_index = 0xffff;		/* Will be fixed up later */
		    while ( (ch=nlgetc(sfd))==' ' || ch=='\t' );
		    ungetc(ch,sfd);
		    if ( isdigit(ch)) {
			int temp;
			getint(sfd,&temp);
			((AnchorClass1 *) an)->merge_with = temp;
		    } else
			((AnchorClass1 *) an)->merge_with = 0xffff;			/* Will be fixed up later */
		} else {
                    char *subtable_name = SFDReadUTF7Str(sfd);
                    if ( subtable_name!=NULL)                                           /* subtable is optional */
		        an->subtable = SFFindLookupSubtableAndFreeName(sf,subtable_name);
                }
		while ( (ch=nlgetc(sfd))==' ' || ch=='\t' );
		ungetc(ch,sfd);
		if ( isdigit(ch) ) {
		    /* Early versions of SfdFormat 2 had a number here */
		    int temp;
		    getint(sfd,&temp);
		    an->type = temp;
		} else if ( old ) {
		    if ( ((AnchorClass1 *) an)->feature_tag==CHR('c','u','r','s'))
			an->type = act_curs;
		    else if ( ((AnchorClass1 *) an)->feature_tag==CHR('m','k','m','k'))
			an->type = act_mkmk;
		    else
			an->type = act_mark;
		} else {
		    an->type = act_mark;
		    if( an->subtable && an->subtable->lookup )
		    {
			switch ( an->subtable->lookup->lookup_type )
			{
			case gpos_cursive:
			    an->type = act_curs;
			    break;
			case gpos_mark2base:
			    an->type = act_mark;
			    break;
			case gpos_mark2ligature:
			    an->type = act_mklg;
			    break;
			case gpos_mark2mark:
			    an->type = act_mkmk;
			    break;
			default:
			    an->type = act_mark;
			    break;
			}
		    }
		}
		if ( lastan==NULL )
		    sf->anchor = an;
		else
		    lastan->next = an;
		lastan = an;
	    }
	} else if ( strncmp(tok,""MATH:"",5)==0 ) {
	    SFDParseMathItem(sfd,sf,tok);
	} else if ( strmatch(tok,""TableOrder:"")==0 ) {
	    int temp;
	    struct table_ordering *ord;
	    if ( sfdversion==0 || sfdversion>=2 ) {
		IError(""Table ordering specified in version 2 sfd file.\n"" );
                SplineFontFree(sf);
                return NULL;
	    }
	    ord = chunkalloc(sizeof(struct table_ordering));
	    ord->table_tag = gettag(sfd);
	    getint(sfd,&temp);
	    ord->ordered_features = malloc((temp+1)*sizeof(uint32));
	    ord->ordered_features[temp] = 0;
	    for ( i=0; i<temp; ++i ) {
		while ( isspace((ch=nlgetc(sfd))) );
		if ( ch=='\'' ) {
		    ungetc(ch,sfd);
		    ord->ordered_features[i] = gettag(sfd);
		} else if ( ch=='<' ) {
		    int f,s;
		    fscanf(sfd,""%d,%d>"", &f, &s );
		    ord->ordered_features[i] = (f<<16)|s;
		}
	    }
	    if ( lastord==NULL )
		((SplineFont1 *) sf)->orders = ord;
	    else
		lastord->next = ord;
	    lastord = ord;
	} else if ( strmatch(tok,""BeginPrivate:"")==0 ) {
	    SFDGetPrivate(sfd,sf);
	} else if ( strmatch(tok,""BeginSubrs:"")==0 ) {	/* leave in so we don't croak on old sfd files */
	    SFDGetSubrs(sfd);
	} else if ( strmatch(tok,""PickledData:"")==0 ) {
	    if (sf->python_persistent != NULL) {
#if defined(_NO_PYTHON)
	      free( sf->python_persistent );	/* It's a string of pickled data which we leave as a string */
#else
	      PyFF_FreePythonPersistent(sf->python_persistent);
#endif
	      sf->python_persistent = NULL;
	    }
	    sf->python_persistent = SFDUnPickle(sfd, 0);
	    sf->python_persistent_has_lists = 0;
	} else if ( strmatch(tok,""PickledDataWithLists:"")==0 ) {
	    if (sf->python_persistent != NULL) {
#if defined(_NO_PYTHON)
	      free( sf->python_persistent );	/* It's a string of pickled data which we leave as a string */
#else
	      PyFF_FreePythonPersistent(sf->python_persistent);
#endif
	      sf->python_persistent = NULL;
	    }
	    sf->python_persistent = SFDUnPickle(sfd, 1);
	    sf->python_persistent_has_lists = 1;
	} else if ( strmatch(tok,""MMCounts:"")==0 ) {
	    MMSet *mm = sf->mm = chunkalloc(sizeof(MMSet));
	    getint(sfd,&mm->instance_count);
	    getint(sfd,&mm->axis_count);
	    ch = nlgetc(sfd);
	    if ( ch!=' ' )
		ungetc(ch,sfd);
	    else { int temp;
		getint(sfd,&temp);
		mm->apple = temp;
		getint(sfd,&mm->named_instance_count);
	    }
	    mm->instances = calloc(mm->instance_count,sizeof(SplineFont *));
	    mm->positions = malloc(mm->instance_count*mm->axis_count*sizeof(real));
	    mm->defweights = malloc(mm->instance_count*sizeof(real));
	    mm->axismaps = calloc(mm->axis_count,sizeof(struct axismap));
	    if ( mm->named_instance_count!=0 )
		mm->named_instances = calloc(mm->named_instance_count,sizeof(struct named_instance));
	} else if ( strmatch(tok,""MMAxis:"")==0 ) {
	    MMSet *mm = sf->mm;
	    if ( mm!=NULL ) {
		for ( i=0; i<mm->axis_count; ++i ) {
		    getname(sfd,tok);
		    mm->axes[i] = copy(tok);
		}
	    }
	} else if ( strmatch(tok,""MMPositions:"")==0 ) {
	    MMSet *mm = sf->mm;
	    if ( mm!=NULL ) {
		for ( i=0; i<mm->axis_count*mm->instance_count; ++i )
		    getreal(sfd,&mm->positions[i]);
	    }
	} else if ( strmatch(tok,""MMWeights:"")==0 ) {
	    MMSet *mm = sf->mm;
	    if ( mm!=NULL ) {
		for ( i=0; i<mm->instance_count; ++i )
		    getreal(sfd,&mm->defweights[i]);
	    }
	} else if ( strmatch(tok,""MMAxisMap:"")==0 ) {
	    MMSet *mm = sf->mm;
	    if ( mm!=NULL ) {
		int index, points;
		getint(sfd,&index); getint(sfd,&points);
		mm->axismaps[index].points = points;
		mm->axismaps[index].blends = malloc(points*sizeof(real));
		mm->axismaps[index].designs = malloc(points*sizeof(real));
		for ( i=0; i<points; ++i ) {
		    getreal(sfd,&mm->axismaps[index].blends[i]);
		    while ( (ch=nlgetc(sfd))!=EOF && isspace(ch));
		    ungetc(ch,sfd);
		    if ( (ch=nlgetc(sfd))!='=' )
			ungetc(ch,sfd);
		    else if ( (ch=nlgetc(sfd))!='>' )
			ungetc(ch,sfd);
		    getreal(sfd,&mm->axismaps[index].designs[i]);
		}
		lastaxismap = &mm->axismaps[index];
		lastnamedinstance = NULL;
	    }
	} else if ( strmatch(tok,""MMNamedInstance:"")==0 ) {
	    MMSet *mm = sf->mm;
	    if ( mm!=NULL ) {
		int index;
		getint(sfd,&index);
		mm->named_instances[index].coords = malloc(mm->axis_count*sizeof(real));
		for ( i=0; i<mm->axis_count; ++i )
		    getreal(sfd,&mm->named_instances[index].coords[i]);
		lastnamedinstance = &mm->named_instances[index];
		lastaxismap = NULL;
	    }
	} else if ( strmatch(tok,""MacName:"")==0 ) {
	    struct macname *names = SFDParseMacNames(sfd,tok);
	    if ( lastaxismap!=NULL )
		lastaxismap->axisnames = names;
	    else if ( lastnamedinstance !=NULL )
		lastnamedinstance->names = names;
	    pushedbacktok = true;
	} else if ( strmatch(tok,""MMCDV:"")==0 ) {
	    MMSet *mm = sf->mm;
	    if ( mm!=NULL )
		mm->cdv = SFDParseMMSubroutine(sfd);
	} else if ( strmatch(tok,""MMNDV:"")==0 ) {
	    MMSet *mm = sf->mm;
	    if ( mm!=NULL )
		mm->ndv = SFDParseMMSubroutine(sfd);
	} else if ( strmatch(tok,""BeginMMFonts:"")==0 ) {
	    int cnt;
	    getint(sfd,&cnt);
	    getint(sfd,&realcnt);
	    ff_progress_change_stages(cnt);
	    ff_progress_change_total(realcnt);
	    MMInferStuff(sf->mm);
    break;
	} else if ( strmatch(tok,""BeginSubFonts:"")==0 ) {
	    getint(sfd,&sf->subfontcnt);
	    sf->subfonts = calloc(sf->subfontcnt,sizeof(SplineFont *));
	    getint(sfd,&realcnt);
	    sf->map = EncMap1to1(realcnt);
	    ff_progress_change_stages(2);
	    ff_progress_change_total(realcnt);
    break;
	} else if ( strmatch(tok,""BeginChars:"")==0 ) {
	    int charcnt;
	    getint(sfd,&charcnt);
	    if (charcnt<enc->char_cnt) {
		IError(""SFD file specifies too few slots for its encoding.\n"" );
exit( 1 );
	    }
	    if ( getint(sfd,&realcnt)!=1 || realcnt==-1 )
		realcnt = charcnt;
	    else
		++realcnt;		/* value saved is max glyph, not glyph cnt */
	    ff_progress_change_total(realcnt);
	    sf->glyphcnt = sf->glyphmax = realcnt;
	    sf->glyphs = calloc(realcnt,sizeof(SplineChar *));
	    if ( cidmaster!=NULL ) {
		sf->map = cidmaster->map;
	    } else {
		sf->map = EncMapNew(charcnt,realcnt,enc);
		sf->map->remap = remap;
	    }
	    SFDSizeMap(sf->map,sf->glyphcnt,charcnt);
    break;
#if HANYANG
	} else if ( strmatch(tok,""BeginCompositionRules"")==0 ) {
	    sf->rules = SFDReadCompositionRules(sfd);
#endif
	} else {
	    /* If we don't understand it, skip it */
	    geteol(sfd,tok);
	}
    }

    // Many downstream functions assume this isn't NULL (use strlen, etc.)
    if ( sf->fontname==NULL)
	sf->fontname = copy("""");

    if ( fromdir )
	sf = SFD_FigureDirType(sf,tok,dirname,enc,remap,had_layer_cnt);
    else if ( sf->subfontcnt!=0 ) {
	ff_progress_change_stages(2*sf->subfontcnt);
	for ( i=0; i<sf->subfontcnt; ++i ) {
	    if ( i!=0 )
		ff_progress_next_stage();
	    sf->subfonts[i] = SFD_GetFont(sfd,sf,tok,fromdir,dirname,sfdversion);
	}
    } else if ( sf->mm!=NULL ) {
	MMSet *mm = sf->mm;
	ff_progress_change_stages(2*(mm->instance_count+1));
	for ( i=0; i<mm->instance_count; ++i ) {
	    if ( i!=0 )
		ff_progress_next_stage();
	    mm->instances[i] = SFD_GetFont(sfd,NULL,tok,fromdir,dirname,sfdversion);
	    EncMapFree(mm->instances[i]->map); mm->instances[i]->map=NULL;
	    mm->instances[i]->mm = mm;
	}
	ff_progress_next_stage();
	mm->normal = SFD_GetFont(sfd,NULL,tok,fromdir,dirname,sfdversion);
	mm->normal->mm = mm;
	sf->mm = NULL;
	SplineFontFree(sf);
	sf = mm->normal;
	if ( sf->map->enc!=&custom ) {
	    EncMap *map;
	    MMMatchGlyphs(mm);		/* sfd files from before the encoding change can have mismatched orig pos */
	    map = EncMapFromEncoding(sf,sf->map->enc);
	    EncMapFree(sf->map);
	    sf->map = map;
	}
    } else {
	while ( SFDGetChar(sfd,sf,had_layer_cnt)!=NULL ) {
	    ff_progress_next();
	}
	ff_progress_next_stage();
    }
    haddupenc = false;
    while ( getname(sfd,tok)==1 ) {
	if ( strcmp(tok,""EndSplineFont"")==0 || strcmp(tok,""EndSubSplineFont"")==0 )
    break;
	else if ( strcmp(tok,""BitmapFont:"")==0 )
	    SFDGetBitmapFont(sfd,sf,false,NULL);
	else if ( strmatch(tok,""DupEnc:"")==0 ) {
	    int enc, orig;
	    haddupenc = true;
	    if ( getint(sfd,&enc) && getint(sfd,&orig) && sf->map!=NULL ) {
		SFDSetEncMap(sf,orig,enc);
	    }
	}
    }
    if ( sf->cidmaster==NULL )
	SFDFixupRefs(sf);

    if ( !haddupenc )
	SFD_DoAltUnis(sf);
    else
	AltUniFigure(sf,sf->map,true);
    if ( sf->sfd_version<2 )
	SFD_AssignLookups((SplineFont1 *) sf);
    if ( !d.hadtimes )
	SFTimesFromFile(sf,sfd);
    // Make a blank encoding if there are no characters so as to avoid crashes later.
    if (sf->map == NULL) sf->map = EncMapNew(sf->glyphcnt,sf->glyphcnt,&custom);

    SFDFixupUndoRefs(sf);
return( sf );
}","static SplineFont *SFD_GetFont( FILE *VAR_0,SplineFont *VAR_1,char *VAR_2,
				int VAR_3, char *VAR_4, float VAR_5 )
{
    SplineFont *VAR_6;
    int VAR_7, VAR_8, VAR_9, VAR_10=-1, VAR_11;
    struct table_ordering *VAR_12 = NULL;
    struct axismap *VAR_13 = NULL;
    struct named_instance *VAR_14 = NULL;
    int VAR_15 = false;
    Encoding *VAR_16 = &VAR_17;
    struct remap *remap = NULL;
    int VAR_18;
    int VAR_19 = false;
    int VAR_20=false;

    VAR_21 = 0;		/* COMMENT_0 */

    VAR_6 = SplineFontEmpty();
    if ( VAR_5>0 && VAR_5<2 ) {
	/* COMMENT_1 */
	/* COMMENT_2 */
	VAR_6 = realloc(VAR_6,sizeof(VAR_22));
	memset(((uint8 *) VAR_6) + sizeof(SplineFont),0,sizeof(VAR_22)-sizeof(SplineFont));
    }
    VAR_6->sfd_version = VAR_5;
    VAR_6->cidmaster = VAR_1;
    VAR_6->uni_interp = VAR_23;
	SFD_GetFontMetaDataData VAR_24;
	SFD_GetFontMetaDataData_Init( &VAR_24 );
    while ( 1 ) {
	if ( VAR_15 )
	    VAR_15 = false;
	else if ( (VAR_9 = getname(VAR_0,VAR_2))!=1 ) {
	    if ( VAR_9==-1 )
    break;
	    geteol(VAR_0,VAR_2);
    continue;
	}


	bool VAR_25 = SFD_GetFontMetaData( VAR_0, VAR_2, VAR_6, &VAR_24 );
	VAR_20 = VAR_24.had_layer_cnt;
        if( VAR_25 )
        {
            /* COMMENT_3 */
            /* COMMENT_4 */
            continue;
        }
        
        
	if ( strmatch(VAR_2,""DisplaySize:"")==0 )
	{
	    getint(VAR_0,&VAR_6->display_size);
	}
	else if ( strmatch(VAR_2,""DisplayLayer:"")==0 )
	{
	    getint(VAR_0,&VAR_6->display_layer);
	}
	else if ( strmatch(VAR_2,""ExtremaBound:"")==0 )
	{
	    getint(VAR_0,&VAR_6->extrema_bound);
	}
	else if ( strmatch(VAR_2,""WidthSeparation:"")==0 )
	{
	    getint(VAR_0,&VAR_6->width_separation);
	}
	else if ( strmatch(VAR_2,""WinInfo:"")==0 )
	{
	    int VAR_26, VAR_27;
	    getint(VAR_0,&VAR_6->top_enc);
	    getint(VAR_0,&VAR_26);
	    getint(VAR_0,&VAR_27);
	    if ( VAR_6->top_enc<=0 ) VAR_6->top_enc=-1;
	    if ( VAR_26<=0 ) VAR_26 = 16;
	    if ( VAR_27<=0 ) VAR_27 = 4;
	    VAR_6->desired_col_cnt = VAR_26;
	    VAR_6->desired_row_cnt = VAR_27;
	}
	else if ( strmatch(VAR_2,""AntiAlias:"")==0 )
	{
	    int VAR_28;
	    getint(VAR_0,&VAR_28);
	    VAR_6->display_antialias = VAR_28;
	}
	else if ( strmatch(VAR_2,""FitToEm:"")==0 )
	{
	    int VAR_28;
	    getint(VAR_0,&VAR_28);
	    VAR_6->display_bbsized = VAR_28;
	}
	else if ( strmatch(VAR_2,""OnlyBitmaps:"")==0 )
	{
	    int VAR_28;
	    getint(VAR_0,&VAR_28);
	    VAR_6->onlybitmaps = VAR_28;
	}
	else if ( strmatch(VAR_2,""Order2:"")==0 )
	{
	    getint(VAR_0,&VAR_19);
	    VAR_6->grid.order2 = VAR_19;
	    VAR_6->layers[VAR_29].order2 = VAR_19;
	    VAR_6->layers[VAR_30].order2 = VAR_19;
	}
	else if ( strmatch(VAR_2,""GridOrder2:"")==0 )
	{
	    int VAR_31;
	    getint(VAR_0,&VAR_31);
	    VAR_6->grid.order2 = VAR_31;
	}
	else if ( strmatch(VAR_2,""Encoding:"")==0 )
	{
	    VAR_16 = SFDGetEncoding(VAR_0,VAR_2);
	    if ( VAR_6->map!=NULL ) VAR_6->map->enc = VAR_16;
	}
	else if ( strmatch(VAR_2,""OldEncoding:"")==0 )
	{
	    /* COMMENT_5 */ (void) SFDGetEncoding(VAR_0,VAR_2);
	}
	else if ( strmatch(VAR_2,""UnicodeInterp:"")==0 )
	{
	    VAR_6->uni_interp = SFDGetUniInterp(VAR_0,VAR_2,VAR_6);
	}
	else if ( strmatch(VAR_2,""NameList:"")==0 )
	{
	    SFDGetNameList(VAR_0,VAR_2,VAR_6);
	}
	else if ( strmatch(VAR_2,""Compacted:"")==0 )
	{
	    int VAR_28;
	    getint(VAR_0,&VAR_28);
	    VAR_6->compacted = VAR_28;
	}
	else if ( strmatch(VAR_2,""Registry:"")==0 )
	{
	    geteol(VAR_0,VAR_2);
	    VAR_6->cidregistry = copy(VAR_2);
	}


	/* COMMENT_6 */


	else if ( strmatch(VAR_2,""Ordering:"")==0 ) {
	    geteol(VAR_0,VAR_2);
	    VAR_6->ordering = copy(VAR_2);
	} else if ( strmatch(VAR_2,""Supplement:"")==0 ) {
	    getint(VAR_0,&VAR_6->supplement);
	} else if ( strmatch(VAR_2,""RemapN:"")==0 ) {
	    int VAR_32;
	    getint(VAR_0,&VAR_32);
	    remap = calloc(VAR_32+1,sizeof(struct remap));
	    remap[VAR_32].infont = -1;
	    VAR_10 = 0;
	    if ( VAR_6->map!=NULL ) VAR_6->map->remap = remap;
	} else if ( strmatch(VAR_2,""Remap:"")==0 ) {
	    uint32 VAR_33, VAR_34; int VAR_35;
	    gethex(VAR_0,&VAR_33);
	    gethex(VAR_0,&VAR_34);
	    getint(VAR_0,&VAR_35);
	    if ( remap!=NULL && remap[VAR_10].infont!=-1 ) {
		remap[VAR_10].firstenc = VAR_33;
		remap[VAR_10].lastenc = VAR_34;
		remap[VAR_10].infont = VAR_35;
		VAR_10++;
	    }
	} else if ( strmatch(VAR_2,""CIDVersion:"")==0 ) {
	    real VAR_28;
	    getreal(VAR_0,&VAR_28);
	    VAR_6->cidversion = VAR_28;
	} else if ( strmatch(VAR_2,""Grid"")==0 ) {
	    VAR_6->grid.splines = SFDGetSplineSet(VAR_0,VAR_6->grid.order2);
	} else if ( strmatch(VAR_2,""ScriptLang:"")==0 ) {
	    int VAR_8,VAR_36,VAR_37;
	    int VAR_38, VAR_39, VAR_40;
	    if ( VAR_6->sfd_version==0 || VAR_6->sfd_version>=2 ) {
		IError( ""Script lang lists should not happen in version 2 sfd files."" );
                SplineFontFree(VAR_6);
                return NULL;
	    }
	    getint(VAR_0,&VAR_38);
	    ((SplineFont1 *) VAR_6)->sli_cnt = VAR_38;
	    ((SplineFont1 *) VAR_6)->script_lang = malloc((VAR_38+1)*sizeof(struct script_record *));
	    ((SplineFont1 *) VAR_6)->script_lang[VAR_38] = NULL;
	    for ( VAR_8=0; VAR_8<VAR_38; ++VAR_8 ) {
		getint(VAR_0,&VAR_39);
		((SplineFont1 *) VAR_6)->script_lang[VAR_8] = malloc((VAR_39+1)*sizeof(struct script_record));
		((SplineFont1 *) VAR_6)->script_lang[VAR_8][VAR_39].script = 0;
		for ( VAR_36=0; VAR_36<VAR_39; ++VAR_36 ) {
		    ((SplineFont1 *) VAR_6)->script_lang[VAR_8][VAR_36].script = gettag(VAR_0);
		    getint(VAR_0,&VAR_40);
		    ((SplineFont1 *) VAR_6)->script_lang[VAR_8][VAR_36].langs = malloc((VAR_40+1)*sizeof(uint32));
		    ((SplineFont1 *) VAR_6)->script_lang[VAR_8][VAR_36].langs[VAR_40] = 0;
		    for ( VAR_37=0; VAR_37<VAR_40; ++VAR_37 ) {
			((SplineFont1 *) VAR_6)->script_lang[VAR_8][VAR_36].langs[VAR_37] = gettag(VAR_0);
		    }
		}
	    }
	} else if ( strmatch(VAR_2,""TeXData:"")==0 ) {
	    int VAR_28;
	    getint(VAR_0,&VAR_28);
	    VAR_6->texdata.type = VAR_28;
	    getint(VAR_0, &VAR_28);
	    if ( VAR_6->design_size==0 ) {
	    	VAR_6->design_size = (5*VAR_28+(1<<18))>>19;
	    }
	    for ( VAR_8=0; VAR_8<22; ++VAR_8 ) {
		int VAR_41;
		getint(VAR_0,&VAR_41);
		VAR_6->texdata.params[VAR_8]=VAR_41;
	    }
	} else if ( strnmatch(VAR_2,""AnchorClass"",11)==0 ) {
	    char *VAR_42;
	    AnchorClass *VAR_43 = NULL, *VAR_44;
	    int VAR_45 = strchr(VAR_2,'2')==NULL;
	    while ( (VAR_42=SFDReadUTF7Str(VAR_0))!=NULL ) {
		VAR_44 = chunkalloc(VAR_45 ? sizeof(VAR_46) : sizeof(AnchorClass));
		VAR_44->name = VAR_42;
		if ( VAR_45 ) {
		    getname(VAR_0,VAR_2);
		    if ( VAR_2[0]=='0' && VAR_2[1]=='\0' )
			((AnchorClass1 *) VAR_44)->feature_tag = 0;
		    else {
			if ( VAR_2[1]=='\0' ) { VAR_2[1]=' '; VAR_2[2] = 0; }
			if ( VAR_2[2]=='\0' ) { VAR_2[2]=' '; VAR_2[3] = 0; }
			if ( VAR_2[3]=='\0' ) { VAR_2[3]=' '; VAR_2[4] = 0; }
			((AnchorClass1 *) VAR_44)->feature_tag = (VAR_2[0]<<24) | (VAR_2[1]<<16) | (VAR_2[2]<<8) | VAR_2[3];
		    }
		    while ( (VAR_11=nlgetc(VAR_0))==' ' || VAR_11=='\t' );
		    ungetc(VAR_11,VAR_0);
		    if ( isdigit(VAR_11)) {
			int VAR_28;
			getint(VAR_0,&VAR_28);
			((AnchorClass1 *) VAR_44)->flags = VAR_28;
		    }
		    while ( (VAR_11=nlgetc(VAR_0))==' ' || VAR_11=='\t' );
		    ungetc(VAR_11,VAR_0);
		    if ( isdigit(VAR_11)) {
			int VAR_28;
			getint(VAR_0,&VAR_28);
			((AnchorClass1 *) VAR_44)->script_lang_index = VAR_28;
		    } else
			((AnchorClass1 *) VAR_44)->script_lang_index = 0xffff;		/* COMMENT_7 */
		    while ( (VAR_11=nlgetc(VAR_0))==' ' || VAR_11=='\t' );
		    ungetc(VAR_11,VAR_0);
		    if ( isdigit(VAR_11)) {
			int VAR_28;
			getint(VAR_0,&VAR_28);
			((AnchorClass1 *) VAR_44)->merge_with = VAR_28;
		    } else
			((AnchorClass1 *) VAR_44)->merge_with = 0xffff;			/* COMMENT_7 */
		} else {
                    char *VAR_47 = SFDReadUTF7Str(VAR_0);
                    if ( VAR_47!=NULL)                                           /* COMMENT_8 */
		        VAR_44->subtable = SFFindLookupSubtableAndFreeName(VAR_6,VAR_47);
                }
		while ( (VAR_11=nlgetc(VAR_0))==' ' || VAR_11=='\t' );
		ungetc(VAR_11,VAR_0);
		if ( isdigit(VAR_11) ) {
		    /* COMMENT_9 */
		    int VAR_28;
		    getint(VAR_0,&VAR_28);
		    VAR_44->type = VAR_28;
		} else if ( VAR_45 ) {
		    if ( ((AnchorClass1 *) VAR_44)->feature_tag==CHR('c','u','r','s'))
			VAR_44->type = VAR_48;
		    else if ( ((AnchorClass1 *) VAR_44)->feature_tag==CHR('m','k','m','k'))
			VAR_44->type = VAR_49;
		    else
			VAR_44->type = VAR_50;
		} else {
		    VAR_44->type = VAR_50;
		    if( VAR_44->subtable && VAR_44->subtable->lookup )
		    {
			switch ( VAR_44->subtable->lookup->lookup_type )
			{
			case VAR_51:
			    VAR_44->type = VAR_48;
			    break;
			case VAR_52:
			    VAR_44->type = VAR_50;
			    break;
			case VAR_53:
			    VAR_44->type = VAR_54;
			    break;
			case VAR_55:
			    VAR_44->type = VAR_49;
			    break;
			default:
			    VAR_44->type = VAR_50;
			    break;
			}
		    }
		}
		if ( VAR_43==NULL )
		    VAR_6->anchor = VAR_44;
		else
		    VAR_43->next = VAR_44;
		VAR_43 = VAR_44;
	    }
	} else if ( strncmp(VAR_2,""MATH:"",5)==0 ) {
	    SFDParseMathItem(VAR_0,VAR_6,VAR_2);
	} else if ( strmatch(VAR_2,""TableOrder:"")==0 ) {
	    int VAR_28;
	    struct table_ordering *VAR_56;
	    if ( VAR_5==0 || VAR_5>=2 ) {
		IError(""Table ordering specified in version 2 sfd file.\n"" );
                SplineFontFree(VAR_6);
                return NULL;
	    }
	    VAR_56 = chunkalloc(sizeof(struct table_ordering));
	    VAR_56->table_tag = gettag(VAR_0);
	    getint(VAR_0,&VAR_28);
	    VAR_56->ordered_features = malloc((VAR_28+1)*sizeof(uint32));
	    VAR_56->ordered_features[VAR_28] = 0;
	    for ( VAR_8=0; VAR_8<VAR_28; ++VAR_8 ) {
		while ( isspace((VAR_11=nlgetc(VAR_0))) );
		if ( VAR_11=='\'' ) {
		    ungetc(VAR_11,VAR_0);
		    VAR_56->ordered_features[VAR_8] = gettag(VAR_0);
		} else if ( VAR_11=='<' ) {
		    int VAR_33,VAR_57;
		    fscanf(VAR_0,""%d,%d>"", &VAR_33, &VAR_57 );
		    VAR_56->ordered_features[VAR_8] = (VAR_33<<16)|VAR_57;
		}
	    }
	    if ( VAR_12==NULL )
		((SplineFont1 *) VAR_6)->orders = VAR_56;
	    else
		VAR_12->next = VAR_56;
	    VAR_12 = VAR_56;
	} else if ( strmatch(VAR_2,""BeginPrivate:"")==0 ) {
	    SFDGetPrivate(VAR_0,VAR_6);
	} else if ( strmatch(VAR_2,""BeginSubrs:"")==0 ) {	/* COMMENT_10 */
	    SFDGetSubrs(VAR_0);
	} else if ( strmatch(VAR_2,""PickledData:"")==0 ) {
	    if (VAR_6->python_persistent != NULL) {
#if defined(VAR_58)
	      free( VAR_6->python_persistent );	/* COMMENT_11 */
#else
	      PyFF_FreePythonPersistent(VAR_6->python_persistent);
#endif
	      VAR_6->python_persistent = NULL;
	    }
	    VAR_6->python_persistent = SFDUnPickle(VAR_0, 0);
	    VAR_6->python_persistent_has_lists = 0;
	} else if ( strmatch(VAR_2,""PickledDataWithLists:"")==0 ) {
	    if (VAR_6->python_persistent != NULL) {
#if defined(VAR_58)
	      free( VAR_6->python_persistent );	/* COMMENT_11 */
#else
	      PyFF_FreePythonPersistent(VAR_6->python_persistent);
#endif
	      VAR_6->python_persistent = NULL;
	    }
	    VAR_6->python_persistent = SFDUnPickle(VAR_0, 1);
	    VAR_6->python_persistent_has_lists = 1;
	} else if ( strmatch(VAR_2,""MMCounts:"")==0 ) {
	    MMSet *VAR_59 = VAR_6->mm = chunkalloc(sizeof(MMSet));
	    getint(VAR_0,&VAR_59->instance_count);
	    getint(VAR_0,&VAR_59->axis_count);
	    VAR_11 = nlgetc(VAR_0);
	    if ( VAR_11!=' ' )
		ungetc(VAR_11,VAR_0);
	    else { int VAR_28;
		getint(VAR_0,&VAR_28);
		VAR_59->apple = VAR_28;
		getint(VAR_0,&VAR_59->named_instance_count);
	    }
	    VAR_59->instances = calloc(VAR_59->instance_count,sizeof(SplineFont *));
	    VAR_59->positions = malloc(VAR_59->instance_count*VAR_59->axis_count*sizeof(real));
	    VAR_59->defweights = malloc(VAR_59->instance_count*sizeof(real));
	    VAR_59->axismaps = calloc(VAR_59->axis_count,sizeof(struct axismap));
	    if ( VAR_59->named_instance_count!=0 )
		VAR_59->named_instances = calloc(VAR_59->named_instance_count,sizeof(struct named_instance));
	} else if ( strmatch(VAR_2,""MMAxis:"")==0 ) {
	    MMSet *VAR_59 = VAR_6->mm;
	    if ( VAR_59!=NULL ) {
		for ( VAR_8=0; VAR_8<VAR_59->axis_count; ++VAR_8 ) {
		    getname(VAR_0,VAR_2);
		    VAR_59->axes[VAR_8] = copy(VAR_2);
		}
	    }
	} else if ( strmatch(VAR_2,""MMPositions:"")==0 ) {
	    MMSet *VAR_59 = VAR_6->mm;
	    if ( VAR_59!=NULL ) {
		for ( VAR_8=0; VAR_8<VAR_59->axis_count*VAR_59->instance_count; ++VAR_8 )
		    getreal(VAR_0,&VAR_59->positions[VAR_8]);
	    }
	} else if ( strmatch(VAR_2,""MMWeights:"")==0 ) {
	    MMSet *VAR_59 = VAR_6->mm;
	    if ( VAR_59!=NULL ) {
		for ( VAR_8=0; VAR_8<VAR_59->instance_count; ++VAR_8 )
		    getreal(VAR_0,&VAR_59->defweights[VAR_8]);
	    }
	} else if ( strmatch(VAR_2,""MMAxisMap:"")==0 ) {
	    MMSet *VAR_59 = VAR_6->mm;
	    if ( VAR_59!=NULL ) {
		int VAR_60, VAR_61;
		getint(VAR_0,&VAR_60); getint(VAR_0,&VAR_61);
		VAR_59->axismaps[VAR_60].points = VAR_61;
		VAR_59->axismaps[VAR_60].blends = malloc(VAR_61*sizeof(real));
		VAR_59->axismaps[VAR_60].designs = malloc(VAR_61*sizeof(real));
		for ( VAR_8=0; VAR_8<VAR_61; ++VAR_8 ) {
		    getreal(VAR_0,&VAR_59->axismaps[VAR_60].blends[VAR_8]);
		    while ( (VAR_11=nlgetc(VAR_0))!=VAR_62 && isspace(VAR_11));
		    ungetc(VAR_11,VAR_0);
		    if ( (VAR_11=nlgetc(VAR_0))!='=' )
			ungetc(VAR_11,VAR_0);
		    else if ( (VAR_11=nlgetc(VAR_0))!='>' )
			ungetc(VAR_11,VAR_0);
		    getreal(VAR_0,&VAR_59->axismaps[VAR_60].designs[VAR_8]);
		}
		VAR_13 = &VAR_59->axismaps[VAR_60];
		VAR_14 = NULL;
	    }
	} else if ( strmatch(VAR_2,""MMNamedInstance:"")==0 ) {
	    MMSet *VAR_59 = VAR_6->mm;
	    if ( VAR_59!=NULL ) {
		int VAR_60;
		getint(VAR_0,&VAR_60);
		VAR_59->named_instances[VAR_60].coords = malloc(VAR_59->axis_count*sizeof(real));
		for ( VAR_8=0; VAR_8<VAR_59->axis_count; ++VAR_8 )
		    getreal(VAR_0,&VAR_59->named_instances[VAR_60].coords[VAR_8]);
		VAR_14 = &VAR_59->named_instances[VAR_60];
		VAR_13 = NULL;
	    }
	} else if ( strmatch(VAR_2,""MacName:"")==0 ) {
	    struct macname *VAR_63 = SFDParseMacNames(VAR_0,VAR_2);
	    if ( VAR_13!=NULL )
		VAR_13->axisnames = VAR_63;
	    else if ( VAR_14 !=NULL )
		VAR_14->names = VAR_63;
	    VAR_15 = true;
	} else if ( strmatch(VAR_2,""MMCDV:"")==0 ) {
	    MMSet *VAR_59 = VAR_6->mm;
	    if ( VAR_59!=NULL )
		VAR_59->cdv = SFDParseMMSubroutine(VAR_0);
	} else if ( strmatch(VAR_2,""MMNDV:"")==0 ) {
	    MMSet *VAR_59 = VAR_6->mm;
	    if ( VAR_59!=NULL )
		VAR_59->ndv = SFDParseMMSubroutine(VAR_0);
	} else if ( strmatch(VAR_2,""BeginMMFonts:"")==0 ) {
	    int VAR_64;
	    getint(VAR_0,&VAR_64);
	    getint(VAR_0,&VAR_7);
	    ff_progress_change_stages(VAR_64);
	    ff_progress_change_total(VAR_7);
	    MMInferStuff(VAR_6->mm);
    break;
	} else if ( strmatch(VAR_2,""BeginSubFonts:"")==0 ) {
	    getint(VAR_0,&VAR_6->subfontcnt);
	    VAR_6->subfonts = calloc(VAR_6->subfontcnt,sizeof(SplineFont *));
	    getint(VAR_0,&VAR_7);
	    VAR_6->map = EncMap1to1(VAR_7);
	    ff_progress_change_stages(2);
	    ff_progress_change_total(VAR_7);
    break;
	} else if ( strmatch(VAR_2,""BeginChars:"")==0 ) {
	    int VAR_65;
	    getint(VAR_0,&VAR_65);
	    if (VAR_65<VAR_16->char_cnt) {
		IError(""SFD file specifies too few slots for its encoding.\n"" );
exit( 1 );
	    }
	    if ( getint(VAR_0,&VAR_7)!=1 || VAR_7==-1 )
		VAR_7 = VAR_65;
	    else
		++VAR_7;		/* COMMENT_12 */
	    ff_progress_change_total(VAR_7);
	    VAR_6->glyphcnt = VAR_6->glyphmax = VAR_7;
	    VAR_6->glyphs = calloc(VAR_7,sizeof(SplineChar *));
	    if ( VAR_1!=NULL ) {
		VAR_6->map = VAR_1->map;
	    } else {
		VAR_6->map = EncMapNew(VAR_65,VAR_7,VAR_16);
		VAR_6->map->remap = remap;
	    }
	    SFDSizeMap(VAR_6->map,VAR_6->glyphcnt,VAR_65);
    break;
#if VAR_66
	} else if ( strmatch(VAR_2,""BeginCompositionRules"")==0 ) {
	    VAR_6->rules = SFDReadCompositionRules(VAR_0);
#endif
	} else {
	    /* COMMENT_13 */
	    geteol(VAR_0,VAR_2);
	}
    }

    /* COMMENT_14 */
    if ( VAR_6->fontname==NULL)
	VAR_6->fontname = copy("""");

    if ( VAR_3 )
	VAR_6 = SFD_FigureDirType(VAR_6,VAR_2,VAR_4,VAR_16,remap,VAR_20);
    else if ( VAR_6->subfontcnt!=0 ) {
	ff_progress_change_stages(2*VAR_6->subfontcnt);
	for ( VAR_8=0; VAR_8<VAR_6->subfontcnt; ++VAR_8 ) {
	    if ( VAR_8!=0 )
		ff_progress_next_stage();
	    VAR_6->subfonts[VAR_8] = SFD_GetFont(VAR_0,VAR_6,VAR_2,VAR_3,VAR_4,VAR_5);
	}
    } else if ( VAR_6->mm!=NULL ) {
	MMSet *VAR_59 = VAR_6->mm;
	ff_progress_change_stages(2*(VAR_59->instance_count+1));
	for ( VAR_8=0; VAR_8<VAR_59->instance_count; ++VAR_8 ) {
	    if ( VAR_8!=0 )
		ff_progress_next_stage();
	    VAR_59->instances[VAR_8] = SFD_GetFont(VAR_0,NULL,VAR_2,VAR_3,VAR_4,VAR_5);
	    EncMapFree(VAR_59->instances[VAR_8]->map); VAR_59->instances[VAR_8]->map=NULL;
	    VAR_59->instances[VAR_8]->mm = VAR_59;
	}
	ff_progress_next_stage();
	VAR_59->normal = SFD_GetFont(VAR_0,NULL,VAR_2,VAR_3,VAR_4,VAR_5);
	VAR_59->normal->mm = VAR_59;
	VAR_6->mm = NULL;
	SplineFontFree(VAR_6);
	VAR_6 = VAR_59->normal;
	if ( VAR_6->map->enc!=&VAR_17 ) {
	    EncMap *VAR_67;
	    MMMatchGlyphs(VAR_59);		/* COMMENT_15 */
	    VAR_67 = EncMapFromEncoding(VAR_6,VAR_6->map->enc);
	    EncMapFree(VAR_6->map);
	    VAR_6->map = VAR_67;
	}
    } else {
	while ( SFDGetChar(VAR_0,VAR_6,VAR_20)!=NULL ) {
	    ff_progress_next();
	}
	ff_progress_next_stage();
    }
    VAR_18 = false;
    while ( getname(VAR_0,VAR_2)==1 ) {
	if ( strcmp(VAR_2,""EndSplineFont"")==0 || strcmp(VAR_2,""EndSubSplineFont"")==0 )
    break;
	else if ( strcmp(VAR_2,""BitmapFont:"")==0 )
	    SFDGetBitmapFont(VAR_0,VAR_6,false,NULL);
	else if ( strmatch(VAR_2,""DupEnc:"")==0 ) {
	    int VAR_16, VAR_68;
	    VAR_18 = true;
	    if ( getint(VAR_0,&VAR_16) && getint(VAR_0,&VAR_68) && VAR_6->map!=NULL ) {
		SFDSetEncMap(VAR_6,VAR_68,VAR_16);
	    }
	}
    }
    if ( VAR_6->cidmaster==NULL )
	SFDFixupRefs(VAR_6);

    if ( !VAR_18 )
	SFD_DoAltUnis(VAR_6);
    else
	AltUniFigure(VAR_6,VAR_6->map,true);
    if ( VAR_6->sfd_version<2 )
	SFD_AssignLookups((SplineFont1 *) VAR_6);
    if ( !VAR_24.hadtimes )
	SFTimesFromFile(VAR_6,VAR_0);
    /* COMMENT_16 */
    if (VAR_6->map == NULL) VAR_6->map = EncMapNew(VAR_6->glyphcnt,VAR_6->glyphcnt,&VAR_17);

    SFDFixupUndoRefs(VAR_6);
return( VAR_6 );
}",fontforge/8da6d56bf7af2d25f779e52edef61b2fd4557b3c/sfd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -487,6 +487,10 @@
 	}
     }
 
+    // Many downstream functions assume this isn't NULL (use strlen, etc.)
+    if ( sf->fontname==NULL)
+	sf->fontname = copy("""");
+
     if ( fromdir )
 	sf = SFD_FigureDirType(sf,tok,dirname,enc,remap,had_layer_cnt);
     else if ( sf->subfontcnt!=0 ) {","{'deleted_lines': [], 'added_lines': [""    // Many downstream functions assume this isn't NULL (use strlen, etc.)"", '    if ( sf->fontname==NULL)', '\tsf->fontname = copy("""");', '']}",True,FontForge 20190801 has a use-after-free in SFD_GetFontMetaData in sfd.c.,8.8,HIGH,2,valid,2020-01-06T11:05:06Z,3
CVE-2020-5395,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,fontforge,"Fix for #4084 Use-after-free (heap) in the SFD_GetFontMetaData() function
Fix for #4086 NULL pointer dereference in the SFDGetSpiros() function
Fix for #4088 NULL pointer dereference in the SFD_AssignLookups() function
Add empty sf->fontname string if it isn't set, fixing #4089 #4090 and many
  other potential issues (many downstream calls to strlen() on the value).",8da6d56bf7af2d25f779e52edef61b2fd4557b3c,https://github.com/fontforge/fontforge/commit/8da6d56bf7af2d25f779e52edef61b2fd4557b3c,fontforge/sfd1.c,SFD_AssignLookups,"void SFD_AssignLookups(SplineFont1 *sf) {
PST1 *pst, *pst2;
int isv;
KernPair1 *kp, *kp2;
KernClass1 *kc, *kc2;
FPST1 *fpst;
ASM1 *sm;
AnchorClass1 *ac, *ac2;
int gid, gid2, cnt, i, k, isgpos;
SplineFont1 *subsf;
SplineChar *sc, *sc2;
OTLookup *otl, **all;
struct lookup_subtable *sub;
SFDCleanupAnchorClasses(&sf->sf);
if ( sf->sf.uni_interp==ui_unset )
sf->sf.uni_interp = interp_from_encoding(sf->sf.map->enc,ui_none);
if ( sf->sf.pfminfo.os2_winascent < sf->sf.ascent/4 && !sf->sf.pfminfo.winascent_add ) {
sf->sf.pfminfo.winascent_add = true;
sf->sf.pfminfo.os2_winascent = 0;
sf->sf.pfminfo.windescent_add = true;
sf->sf.pfminfo.os2_windescent = 0;
}
k=0;
do {
subsf = sf->sf.subfontcnt==0 ? sf : (SplineFont1 *) (sf->sf.subfonts[k]);
for ( gid=0; gid<subsf->sf.glyphcnt; ++gid ) if ( (sc=subsf->sf.glyphs[gid])!=NULL ) {
for ( pst = (PST1 *) (sc->possub); pst!=NULL; pst = (PST1*) (pst->pst.next) ) {
if ( pst->pst.type == pst_lcaret || pst->pst.subtable!=NULL )
continue;
otl = CreateLookup(sf,pst->tag,pst->script_lang_index,pst->flags,pst->pst.type);
sub = CreateSubtable(otl,sf);
for ( pst2=pst ; pst2!=NULL; pst2 = (PST1 *) (pst2->pst.next) ) {
if ( pst2->tag==pst->tag &&
pst2->script_lang_index==pst->script_lang_index &&
pst2->flags==pst->flags &&
pst2->pst.type==pst->pst.type )
pst2->pst.subtable = sub;
}
for ( gid2=gid+1; gid2<subsf->sf.glyphcnt; ++gid2 ) if ( (sc2=subsf->sf.glyphs[gid2])!=NULL ) {
for ( pst2 = (PST1 *) (sc2->possub); pst2!=NULL; pst2 = (PST1 *) (pst2->pst.next) ) {
if ( pst2->tag==pst->tag &&
pst2->script_lang_index==pst->script_lang_index &&
pst2->flags==pst->flags &&
pst2->pst.type==pst->pst.type )
pst2->pst.subtable = sub;
}
}
}
}
++k;
} while ( k<sf->sf.subfontcnt );
for ( isv=0; isv<2; ++isv ) {
k=0;
do {
subsf = sf->sf.subfontcnt==0 ? sf : (SplineFont1 *) (sf->sf.subfonts[k]);
for ( gid=0; gid<subsf->sf.glyphcnt; ++gid ) if ( (sc=subsf->sf.glyphs[gid])!=NULL ) {
for ( kp = (KernPair1 *) (isv ? sc->vkerns : sc->kerns); kp!=NULL; kp = (KernPair1 *) (kp->kp.next) ) {
if ( kp->kp.subtable!=NULL )
continue;
otl = CreateLookup(sf,isv ? CHR('v','k','r','n') : CHR('k','e','r','n'),
kp->sli,kp->flags,pst_pair);
sub = CreateSubtable(otl,sf);
for ( kp2=kp ; kp2!=NULL; kp2 = (KernPair1 *) (kp2->kp.next) ) {
if ( kp2->sli==kp->sli && kp2->flags==kp->flags )
kp2->kp.subtable = sub;
}
for ( gid2=gid+1; gid2<subsf->sf.glyphcnt; ++gid2 ) if ( (sc2=subsf->sf.glyphs[gid2])!=NULL ) {
for ( kp2 = (KernPair1 *) (isv ? sc2->vkerns : sc2->kerns); kp2!=NULL; kp2 = (KernPair1 *) (kp2->kp.next) ) {
if ( kp2->sli==kp->sli && kp2->flags==kp->flags )
kp2->kp.subtable = sub;
}
}
for ( kc=(KernClass1 *) (isv ? sf->sf.vkerns : sf->sf.kerns); kc!=NULL;
kc = (KernClass1 *) (kc->kc.next) ) {
if ( kc->sli == kp->sli && kc->flags == kp->flags && kc->kc.subtable==NULL) {
sub = CreateSubtable(otl,sf);
sub->per_glyph_pst_or_kern = false;
sub->kc = &kc->kc;
kc->kc.subtable = sub;
}
}
}
}
++k;
} while ( k<sf->sf.subfontcnt );
for ( kc=(KernClass1 *) (isv ? sf->sf.vkerns : sf->sf.kerns); kc!=NULL;
kc = (KernClass1 *) (kc->kc.next) ) {
if ( kc->kc.subtable==NULL) {
otl = CreateLookup(sf,isv ? CHR('v','k','r','n') : CHR('k','e','r','n'),
kc->sli,kc->flags,pst_pair);
for ( kc2=kc; kc2!=NULL; kc2=(KernClass1 *) (kc2->kc.next) ) {
if ( kc->sli == kc2->sli && kc->flags == kc2->flags && kc2->kc.subtable==NULL) {
sub = CreateSubtable(otl,sf);
sub->per_glyph_pst_or_kern = false;
sub->kc = &kc2->kc;
kc2->kc.subtable = sub;
}
}
}
}
}
for ( fpst=(FPST1 *) sf->sf.possub; fpst!=NULL; fpst=((FPST1 *) fpst->fpst.next) ) {
otl = CreateLookup(sf,fpst->tag, fpst->script_lang_index,
fpst->flags,fpst->fpst.type);
sub = CreateSubtable(otl,sf);
sub->per_glyph_pst_or_kern = false;
sub->fpst = &fpst->fpst;
fpst->fpst.subtable = sub;
FPSTReplaceTagsWithLookups(&fpst->fpst,sf);
}
for ( sm=(ASM1 *) sf->sf.sm; sm!=NULL; sm=((ASM1 *) sm->sm.next) ) {
otl = CreateMacLookup(sf,sm);
sub = CreateSubtable(otl,sf);
sub->per_glyph_pst_or_kern = false;
sub->sm = &sm->sm;
sm->sm.subtable = sub;
if ( sm->sm.type==asm_context )
ASMReplaceTagsWithLookups(&sm->sm,sf);
}
for ( isgpos=0; isgpos<2; ++isgpos ) {
for ( otl = isgpos ? sf->sf.gpos_lookups : sf->sf.gsub_lookups ;
otl != NULL; otl=otl->next ) {
if ( otl->features!=NULL && otl->features->scripts==NULL ) {
chunkfree(otl->features,sizeof(FeatureScriptLangList));
otl->features = NULL;
}
}
}
for ( ac=(AnchorClass1 *) (sf->sf.anchor); ac!=NULL; ac=(AnchorClass1 *) ac->ac.next ) {
ACHasBaseLig(sf,ac);
if ( ac->has_ligatures && !ac->has_bases )
ac->ac.type = act_mklg;
else if ( ac->has_ligatures && ac->has_bases )
ACDisassociateLigatures(sf,ac);
}
for ( ac=(AnchorClass1 *) (sf->sf.anchor); ac!=NULL; ac=(AnchorClass1 *) ac->ac.next ) {
if ( ac->ac.subtable==NULL ) {
otl = CreateACLookup(sf,ac);
sub = CreateSubtable(otl,sf);
for ( ac2=ac; ac2!=NULL; ac2 = (AnchorClass1 *) ac2->ac.next ) {
if ( ac2->feature_tag == ac->feature_tag &&
ac2->script_lang_index == ac->script_lang_index &&
ac2->flags == ac->flags &&
ac2->ac.type == ac->ac.type &&
ac2->merge_with == ac->merge_with )
ac2->ac.subtable = sub;
}
}
}
for ( otl=sf->sf.gsub_lookups, cnt=0; otl!=NULL; otl=otl->next, ++cnt );
if ( cnt!=0 ) {
all = malloc(cnt*sizeof(OTLookup *));
for ( otl=sf->sf.gsub_lookups, cnt=0; otl!=NULL; otl=otl->next, ++cnt ) {
all[cnt] = otl;
otl->lookup_index = GSubOrder(sf,otl->features);
}
qsort(all,cnt,sizeof(OTLookup *),order_lookups);
sf->sf.gsub_lookups = all[0];
for ( i=1; i<cnt; ++i )
all[i-1]->next = all[i];
all[cnt-1]->next = NULL;
free( all );
}
for ( isgpos=0; isgpos<2; ++isgpos ) {
for ( otl = isgpos ? sf->sf.gpos_lookups : sf->sf.gsub_lookups , cnt=0;
otl!=NULL; otl = otl->next ) {
otl->lookup_index = cnt++;
NameOTLookup(otl,&sf->sf);
}
}
}","void SFD_AssignLookups(SplineFont1 *VAR_0) {
PST1 *VAR_1, *VAR_2;
int VAR_3;
KernPair1 *VAR_4, *VAR_5;
KernClass1 *VAR_6, *VAR_7;
FPST1 *VAR_8;
ASM1 *VAR_9;
AnchorClass1 *VAR_10, *VAR_11;
int VAR_12, VAR_13, VAR_14, VAR_15, VAR_16, VAR_17;
SplineFont1 *VAR_18;
SplineChar *VAR_19, *VAR_20;
OTLookup *VAR_21, **VAR_22;
struct lookup_subtable *VAR_23;
SFDCleanupAnchorClasses(&VAR_0->sf);
if ( VAR_0->sf.uni_interp==VAR_24 )
VAR_0->sf.uni_interp = interp_from_encoding(VAR_0->sf.map->enc,VAR_25);
if ( VAR_0->sf.pfminfo.os2_winascent < VAR_0->sf.ascent/4 && !VAR_0->sf.pfminfo.winascent_add ) {
VAR_0->sf.pfminfo.winascent_add = true;
VAR_0->sf.pfminfo.os2_winascent = 0;
VAR_0->sf.pfminfo.windescent_add = true;
VAR_0->sf.pfminfo.os2_windescent = 0;
}
VAR_16=0;
do {
VAR_18 = VAR_0->sf.subfontcnt==0 ? VAR_0 : (SplineFont1 *) (VAR_0->sf.subfonts[VAR_16]);
for ( VAR_12=0; VAR_12<VAR_18->sf.glyphcnt; ++VAR_12 ) if ( (VAR_19=VAR_18->sf.glyphs[VAR_12])!=NULL ) {
for ( VAR_1 = (PST1 *) (VAR_19->possub); VAR_1!=NULL; VAR_1 = (PST1*) (VAR_1->pst.next) ) {
if ( VAR_1->pst.type == VAR_26 || VAR_1->pst.subtable!=NULL )
continue;
VAR_21 = CreateLookup(VAR_0,VAR_1->tag,VAR_1->script_lang_index,VAR_1->flags,VAR_1->pst.type);
VAR_23 = CreateSubtable(VAR_21,VAR_0);
for ( VAR_2=VAR_1 ; VAR_2!=NULL; VAR_2 = (PST1 *) (VAR_2->pst.next) ) {
if ( VAR_2->tag==VAR_1->tag &&
VAR_2->script_lang_index==VAR_1->script_lang_index &&
VAR_2->flags==VAR_1->flags &&
VAR_2->pst.type==VAR_1->pst.type )
VAR_2->pst.subtable = VAR_23;
}
for ( VAR_13=VAR_12+1; VAR_13<VAR_18->sf.glyphcnt; ++VAR_13 ) if ( (VAR_20=VAR_18->sf.glyphs[VAR_13])!=NULL ) {
for ( VAR_2 = (PST1 *) (VAR_20->possub); VAR_2!=NULL; VAR_2 = (PST1 *) (VAR_2->pst.next) ) {
if ( VAR_2->tag==VAR_1->tag &&
VAR_2->script_lang_index==VAR_1->script_lang_index &&
VAR_2->flags==VAR_1->flags &&
VAR_2->pst.type==VAR_1->pst.type )
VAR_2->pst.subtable = VAR_23;
}
}
}
}
++VAR_16;
} while ( VAR_16<VAR_0->sf.subfontcnt );
for ( VAR_3=0; VAR_3<2; ++VAR_3 ) {
VAR_16=0;
do {
VAR_18 = VAR_0->sf.subfontcnt==0 ? VAR_0 : (SplineFont1 *) (VAR_0->sf.subfonts[VAR_16]);
for ( VAR_12=0; VAR_12<VAR_18->sf.glyphcnt; ++VAR_12 ) if ( (VAR_19=VAR_18->sf.glyphs[VAR_12])!=NULL ) {
for ( VAR_4 = (KernPair1 *) (VAR_3 ? VAR_19->vkerns : VAR_19->kerns); VAR_4!=NULL; VAR_4 = (KernPair1 *) (VAR_4->kp.next) ) {
if ( VAR_4->kp.subtable!=NULL )
continue;
VAR_21 = CreateLookup(VAR_0,VAR_3 ? CHR('v','k','r','n') : CHR('k','e','r','n'),
VAR_4->sli,VAR_4->flags,VAR_27);
VAR_23 = CreateSubtable(VAR_21,VAR_0);
for ( VAR_5=VAR_4 ; VAR_5!=NULL; VAR_5 = (KernPair1 *) (VAR_5->kp.next) ) {
if ( VAR_5->sli==VAR_4->sli && VAR_5->flags==VAR_4->flags )
VAR_5->kp.subtable = VAR_23;
}
for ( VAR_13=VAR_12+1; VAR_13<VAR_18->sf.glyphcnt; ++VAR_13 ) if ( (VAR_20=VAR_18->sf.glyphs[VAR_13])!=NULL ) {
for ( VAR_5 = (KernPair1 *) (VAR_3 ? VAR_20->vkerns : VAR_20->kerns); VAR_5!=NULL; VAR_5 = (KernPair1 *) (VAR_5->kp.next) ) {
if ( VAR_5->sli==VAR_4->sli && VAR_5->flags==VAR_4->flags )
VAR_5->kp.subtable = VAR_23;
}
}
for ( VAR_6=(KernClass1 *) (VAR_3 ? VAR_0->sf.vkerns : VAR_0->sf.kerns); VAR_6!=NULL;
VAR_6 = (KernClass1 *) (VAR_6->kc.next) ) {
if ( VAR_6->sli == VAR_4->sli && VAR_6->flags == VAR_4->flags && VAR_6->kc.subtable==NULL) {
VAR_23 = CreateSubtable(VAR_21,VAR_0);
VAR_23->per_glyph_pst_or_kern = false;
VAR_23->kc = &VAR_6->kc;
VAR_6->kc.subtable = VAR_23;
}
}
}
}
++VAR_16;
} while ( VAR_16<VAR_0->sf.subfontcnt );
for ( VAR_6=(KernClass1 *) (VAR_3 ? VAR_0->sf.vkerns : VAR_0->sf.kerns); VAR_6!=NULL;
VAR_6 = (KernClass1 *) (VAR_6->kc.next) ) {
if ( VAR_6->kc.subtable==NULL) {
VAR_21 = CreateLookup(VAR_0,VAR_3 ? CHR('v','k','r','n') : CHR('k','e','r','n'),
VAR_6->sli,VAR_6->flags,VAR_27);
for ( VAR_7=VAR_6; VAR_7!=NULL; VAR_7=(KernClass1 *) (VAR_7->kc.next) ) {
if ( VAR_6->sli == VAR_7->sli && VAR_6->flags == VAR_7->flags && VAR_7->kc.subtable==NULL) {
VAR_23 = CreateSubtable(VAR_21,VAR_0);
VAR_23->per_glyph_pst_or_kern = false;
VAR_23->kc = &VAR_7->kc;
VAR_7->kc.subtable = VAR_23;
}
}
}
}
}
for ( VAR_8=(FPST1 *) VAR_0->sf.possub; VAR_8!=NULL; VAR_8=((FPST1 *) VAR_8->fpst.next) ) {
VAR_21 = CreateLookup(VAR_0,VAR_8->tag, VAR_8->script_lang_index,
VAR_8->flags,VAR_8->fpst.type);
VAR_23 = CreateSubtable(VAR_21,VAR_0);
VAR_23->per_glyph_pst_or_kern = false;
VAR_23->fpst = &VAR_8->fpst;
VAR_8->fpst.subtable = VAR_23;
FPSTReplaceTagsWithLookups(&VAR_8->fpst,VAR_0);
}
for ( VAR_9=(ASM1 *) VAR_0->sf.sm; VAR_9!=NULL; VAR_9=((ASM1 *) VAR_9->sm.next) ) {
VAR_21 = CreateMacLookup(VAR_0,VAR_9);
VAR_23 = CreateSubtable(VAR_21,VAR_0);
VAR_23->per_glyph_pst_or_kern = false;
VAR_23->sm = &VAR_9->sm;
VAR_9->sm.subtable = VAR_23;
if ( VAR_9->sm.type==VAR_28 )
ASMReplaceTagsWithLookups(&VAR_9->sm,VAR_0);
}
for ( VAR_17=0; VAR_17<2; ++VAR_17 ) {
for ( VAR_21 = VAR_17 ? VAR_0->sf.gpos_lookups : VAR_0->sf.gsub_lookups ;
VAR_21 != NULL; VAR_21=VAR_21->next ) {
if ( VAR_21->features!=NULL && VAR_21->features->scripts==NULL ) {
chunkfree(VAR_21->features,sizeof(VAR_29));
VAR_21->features = NULL;
}
}
}
for ( VAR_10=(AnchorClass1 *) (VAR_0->sf.anchor); VAR_10!=NULL; VAR_10=(AnchorClass1 *) VAR_10->ac.next ) {
ACHasBaseLig(VAR_0,VAR_10);
if ( VAR_10->has_ligatures && !VAR_10->has_bases )
VAR_10->ac.type = VAR_30;
else if ( VAR_10->has_ligatures && VAR_10->has_bases )
ACDisassociateLigatures(VAR_0,VAR_10);
}
for ( VAR_10=(AnchorClass1 *) (VAR_0->sf.anchor); VAR_10!=NULL; VAR_10=(AnchorClass1 *) VAR_10->ac.next ) {
if ( VAR_10->ac.subtable==NULL ) {
VAR_21 = CreateACLookup(VAR_0,VAR_10);
VAR_23 = CreateSubtable(VAR_21,VAR_0);
for ( VAR_11=VAR_10; VAR_11!=NULL; VAR_11 = (AnchorClass1 *) VAR_11->ac.next ) {
if ( VAR_11->feature_tag == VAR_10->feature_tag &&
VAR_11->script_lang_index == VAR_10->script_lang_index &&
VAR_11->flags == VAR_10->flags &&
VAR_11->ac.type == VAR_10->ac.type &&
VAR_11->merge_with == VAR_10->merge_with )
VAR_11->ac.subtable = VAR_23;
}
}
}
for ( VAR_21=VAR_0->sf.gsub_lookups, VAR_14=0; VAR_21!=NULL; VAR_21=VAR_21->next, ++VAR_14 );
if ( VAR_14!=0 ) {
VAR_22 = malloc(VAR_14*sizeof(OTLookup *));
for ( VAR_21=VAR_0->sf.gsub_lookups, VAR_14=0; VAR_21!=NULL; VAR_21=VAR_21->next, ++VAR_14 ) {
VAR_22[VAR_14] = VAR_21;
VAR_21->lookup_index = GSubOrder(VAR_0,VAR_21->features);
}
qsort(VAR_22,VAR_14,sizeof(OTLookup *),VAR_31);
VAR_0->sf.gsub_lookups = VAR_22[0];
for ( VAR_15=1; VAR_15<VAR_14; ++VAR_15 )
VAR_22[VAR_15-1]->next = VAR_22[VAR_15];
VAR_22[VAR_14-1]->next = NULL;
free( VAR_22 );
}
for ( VAR_17=0; VAR_17<2; ++VAR_17 ) {
for ( VAR_21 = VAR_17 ? VAR_0->sf.gpos_lookups : VAR_0->sf.gsub_lookups , VAR_14=0;
VAR_21!=NULL; VAR_21 = VAR_21->next ) {
VAR_21->lookup_index = VAR_14++;
NameOTLookup(VAR_21,&VAR_0->sf);
}
}
}",fontforge/8da6d56bf7af2d25f779e52edef61b2fd4557b3c/sfd1.c/vul/before/0.json,"void SFD_AssignLookups(SplineFont1 *sf) {
    PST1 *pst, *pst2;
    int isv;
    KernPair1 *kp, *kp2;
    KernClass1 *kc, *kc2;
    FPST1 *fpst;
    ASM1 *sm;
    AnchorClass1 *ac, *ac2;
    int gid, gid2, cnt, i, k, isgpos;
    SplineFont1 *subsf;
    SplineChar *sc, *sc2;
    OTLookup *otl, **all;
    struct lookup_subtable *sub;

    /* Fix up some gunk from really old versions of the sfd format */
    SFDCleanupAnchorClasses(&sf->sf);
    if ( sf->sf.uni_interp==ui_unset && sf->sf.map!=NULL )
	sf->sf.uni_interp = interp_from_encoding(sf->sf.map->enc,ui_none);

    /* Fixup for an old bug */
    if ( sf->sf.pfminfo.os2_winascent < sf->sf.ascent/4 && !sf->sf.pfminfo.winascent_add ) {
	sf->sf.pfminfo.winascent_add = true;
	sf->sf.pfminfo.os2_winascent = 0;
	sf->sf.pfminfo.windescent_add = true;
	sf->sf.pfminfo.os2_windescent = 0;
    }

    /* First handle the PSTs, no complications here */
    k=0;
    do {
	subsf = sf->sf.subfontcnt==0 ? sf : (SplineFont1 *) (sf->sf.subfonts[k]);
	for ( gid=0; gid<subsf->sf.glyphcnt; ++gid ) if ( (sc=subsf->sf.glyphs[gid])!=NULL ) {
	    for ( pst = (PST1 *) (sc->possub); pst!=NULL; pst = (PST1*) (pst->pst.next) ) {
		if ( pst->pst.type == pst_lcaret || pst->pst.subtable!=NULL )
	    continue;		/* Nothing to do, or already done */
		otl = CreateLookup(sf,pst->tag,pst->script_lang_index,pst->flags,pst->pst.type);
		sub = CreateSubtable(otl,sf);
		/* There might be another PST with the same flags on this glyph */
		/* And we must fixup the current pst */
		for ( pst2=pst ; pst2!=NULL; pst2 = (PST1 *) (pst2->pst.next) ) {
		    if ( pst2->tag==pst->tag &&
			    pst2->script_lang_index==pst->script_lang_index &&
			    pst2->flags==pst->flags &&
			    pst2->pst.type==pst->pst.type )
			pst2->pst.subtable = sub;
		}
		for ( gid2=gid+1; gid2<subsf->sf.glyphcnt; ++gid2 ) if ( (sc2=subsf->sf.glyphs[gid2])!=NULL ) {
		    for ( pst2 = (PST1 *) (sc2->possub); pst2!=NULL; pst2 = (PST1 *) (pst2->pst.next) ) {
			if ( pst2->tag==pst->tag &&
				pst2->script_lang_index==pst->script_lang_index &&
				pst2->flags==pst->flags &&
				pst2->pst.type==pst->pst.type )
			    pst2->pst.subtable = sub;
		    }
		}
	    }
	}
	++k;
    } while ( k<sf->sf.subfontcnt );

	/* Now kerns. May need to merge kernclasses to kernpair lookups (different subtables, of course */
    for ( isv=0; isv<2; ++isv ) {
	k=0;
	do {
	    subsf = sf->sf.subfontcnt==0 ? sf : (SplineFont1 *) (sf->sf.subfonts[k]);
	    for ( gid=0; gid<subsf->sf.glyphcnt; ++gid ) if ( (sc=subsf->sf.glyphs[gid])!=NULL ) {
		for ( kp = (KernPair1 *) (isv ? sc->vkerns : sc->kerns); kp!=NULL; kp = (KernPair1 *) (kp->kp.next) ) {
		    if ( kp->kp.subtable!=NULL )
		continue;		/* already done */
		    otl = CreateLookup(sf,isv ? CHR('v','k','r','n') : CHR('k','e','r','n'),
			    kp->sli,kp->flags,pst_pair);
		    sub = CreateSubtable(otl,sf);
		    /* There might be another kp with the same flags on this glyph */
		    /* And we must fixup the current kp */
		    for ( kp2=kp ; kp2!=NULL; kp2 = (KernPair1 *) (kp2->kp.next) ) {
			if ( kp2->sli==kp->sli && kp2->flags==kp->flags )
			    kp2->kp.subtable = sub;
		    }
		    for ( gid2=gid+1; gid2<subsf->sf.glyphcnt; ++gid2 ) if ( (sc2=subsf->sf.glyphs[gid2])!=NULL ) {
			for ( kp2 = (KernPair1 *) (isv ? sc2->vkerns : sc2->kerns); kp2!=NULL; kp2 = (KernPair1 *) (kp2->kp.next) ) {
			    if ( kp2->sli==kp->sli && kp2->flags==kp->flags )
				kp2->kp.subtable = sub;
			}
		    }
		    /* And there might be a kerning class... */
		    for ( kc=(KernClass1 *) (isv ? sf->sf.vkerns : sf->sf.kerns); kc!=NULL;
			    kc = (KernClass1 *) (kc->kc.next) ) {
			if ( kc->sli == kp->sli && kc->flags == kp->flags && kc->kc.subtable==NULL) {
			    sub = CreateSubtable(otl,sf);
			    sub->per_glyph_pst_or_kern = false;
			    sub->kc = &kc->kc;
			    kc->kc.subtable = sub;
			}
		    }
		}
	    }
	    ++k;
	} while ( k<sf->sf.subfontcnt );
	/* Or there might be a kerning class all by its lonesome */
	for ( kc=(KernClass1 *) (isv ? sf->sf.vkerns : sf->sf.kerns); kc!=NULL;
		kc = (KernClass1 *) (kc->kc.next) ) {
	    if ( kc->kc.subtable==NULL) {
		otl = CreateLookup(sf,isv ? CHR('v','k','r','n') : CHR('k','e','r','n'),
			kc->sli,kc->flags,pst_pair);
		for ( kc2=kc; kc2!=NULL; kc2=(KernClass1 *) (kc2->kc.next) ) {
		    if ( kc->sli == kc2->sli && kc->flags == kc2->flags && kc2->kc.subtable==NULL) {
			sub = CreateSubtable(otl,sf);
			sub->per_glyph_pst_or_kern = false;
			sub->kc = &kc2->kc;
			kc2->kc.subtable = sub;
		    }
		}
	    }
	}
    }

    /* Every FPST and ASM lives in its own lookup with one subtable */
    /* But the old format refered to nested lookups by tag, and now we refer */
    /*  to the lookup itself, so fix that up */
    for ( fpst=(FPST1 *) sf->sf.possub; fpst!=NULL; fpst=((FPST1 *) fpst->fpst.next) ) {
	otl = CreateLookup(sf,fpst->tag, fpst->script_lang_index,
		fpst->flags,fpst->fpst.type);
	sub = CreateSubtable(otl,sf);
	sub->per_glyph_pst_or_kern = false;
	sub->fpst = &fpst->fpst;
	fpst->fpst.subtable = sub;
	FPSTReplaceTagsWithLookups(&fpst->fpst,sf);
    }
    for ( sm=(ASM1 *) sf->sf.sm; sm!=NULL; sm=((ASM1 *) sm->sm.next) ) {
	otl = CreateMacLookup(sf,sm);
	sub = CreateSubtable(otl,sf);
	sub->per_glyph_pst_or_kern = false;
	sub->sm = &sm->sm;
	sm->sm.subtable = sub;
	if ( sm->sm.type==asm_context )
	    ASMReplaceTagsWithLookups(&sm->sm,sf);
    }

    /* We retained the old nested feature tags so we could do the above conversion */
    /*  of tag to lookup. Get rid of them now */
    for ( isgpos=0; isgpos<2; ++isgpos ) {
	for ( otl = isgpos ? sf->sf.gpos_lookups : sf->sf.gsub_lookups ;
		otl != NULL; otl=otl->next ) {
	    if ( otl->features!=NULL && otl->features->scripts==NULL ) {
		chunkfree(otl->features,sizeof(FeatureScriptLangList));
		otl->features = NULL;
	    }
	}
    }

    /* Anchor classes are complicated, because I foolishly failed to distinguish */
    /*  between mark to base and mark to ligature classes. So one AC might have */
    /*  both. If so we need to turn it into two ACs, and have separate lookups */
    /*  for each */
    for ( ac=(AnchorClass1 *) (sf->sf.anchor); ac!=NULL; ac=(AnchorClass1 *) ac->ac.next ) {
	ACHasBaseLig(sf,ac);
	if ( ac->has_ligatures && !ac->has_bases )
	    ac->ac.type = act_mklg;
	else if ( ac->has_ligatures && ac->has_bases )
	    ACDisassociateLigatures(sf,ac);
    }
    for ( ac=(AnchorClass1 *) (sf->sf.anchor); ac!=NULL; ac=(AnchorClass1 *) ac->ac.next ) {
	if ( ac->ac.subtable==NULL ) {
	    otl = CreateACLookup(sf,ac);
	    sub = CreateSubtable(otl,sf);
	    for ( ac2=ac; ac2!=NULL; ac2 = (AnchorClass1 *) ac2->ac.next ) {
		if ( ac2->feature_tag == ac->feature_tag &&
			ac2->script_lang_index == ac->script_lang_index &&
			ac2->flags == ac->flags &&
			ac2->ac.type == ac->ac.type &&
			ac2->merge_with == ac->merge_with )
		    ac2->ac.subtable = sub;
	    }
	}
    }

    /* Now I want to order the gsub lookups. I shan't bother with the gpos */
    /*  lookups because I didn't before */
    for ( otl=sf->sf.gsub_lookups, cnt=0; otl!=NULL; otl=otl->next, ++cnt );
    if ( cnt!=0 ) {
	all = malloc(cnt*sizeof(OTLookup *));
	for ( otl=sf->sf.gsub_lookups, cnt=0; otl!=NULL; otl=otl->next, ++cnt ) {
	    all[cnt] = otl;
	    otl->lookup_index = GSubOrder(sf,otl->features);
	}
	qsort(all,cnt,sizeof(OTLookup *),order_lookups);
	sf->sf.gsub_lookups = all[0];
	for ( i=1; i<cnt; ++i )
	    all[i-1]->next = all[i];
	all[cnt-1]->next = NULL;
	free( all );
    }

    for ( isgpos=0; isgpos<2; ++isgpos ) {
	for ( otl = isgpos ? sf->sf.gpos_lookups : sf->sf.gsub_lookups , cnt=0;
		otl!=NULL; otl = otl->next ) {
	    otl->lookup_index = cnt++;
	    NameOTLookup(otl,&sf->sf);
	}
    }
}","void SFD_AssignLookups(SplineFont1 *VAR_0) {
    PST1 *VAR_1, *VAR_2;
    int VAR_3;
    KernPair1 *VAR_4, *VAR_5;
    KernClass1 *VAR_6, *VAR_7;
    FPST1 *VAR_8;
    ASM1 *VAR_9;
    AnchorClass1 *VAR_10, *VAR_11;
    int VAR_12, VAR_13, VAR_14, VAR_15, VAR_16, VAR_17;
    SplineFont1 *VAR_18;
    SplineChar *VAR_19, *VAR_20;
    OTLookup *VAR_21, **VAR_22;
    struct lookup_subtable *VAR_23;

    /* COMMENT_0 */
    SFDCleanupAnchorClasses(&VAR_0->sf);
    if ( VAR_0->sf.uni_interp==VAR_24 && VAR_0->sf.map!=NULL )
	VAR_0->sf.uni_interp = interp_from_encoding(VAR_0->sf.map->enc,VAR_25);

    /* COMMENT_1 */
    if ( VAR_0->sf.pfminfo.os2_winascent < VAR_0->sf.ascent/4 && !VAR_0->sf.pfminfo.winascent_add ) {
	VAR_0->sf.pfminfo.winascent_add = true;
	VAR_0->sf.pfminfo.os2_winascent = 0;
	VAR_0->sf.pfminfo.windescent_add = true;
	VAR_0->sf.pfminfo.os2_windescent = 0;
    }

    /* COMMENT_2 */
    VAR_16=0;
    do {
	VAR_18 = VAR_0->sf.subfontcnt==0 ? VAR_0 : (SplineFont1 *) (VAR_0->sf.subfonts[VAR_16]);
	for ( VAR_12=0; VAR_12<VAR_18->sf.glyphcnt; ++VAR_12 ) if ( (VAR_19=VAR_18->sf.glyphs[VAR_12])!=NULL ) {
	    for ( VAR_1 = (PST1 *) (VAR_19->possub); VAR_1!=NULL; VAR_1 = (PST1*) (VAR_1->pst.next) ) {
		if ( VAR_1->pst.type == VAR_26 || VAR_1->pst.subtable!=NULL )
	    continue;		/* COMMENT_3 */
		VAR_21 = CreateLookup(VAR_0,VAR_1->tag,VAR_1->script_lang_index,VAR_1->flags,VAR_1->pst.type);
		VAR_23 = CreateSubtable(VAR_21,VAR_0);
		/* COMMENT_4 */
		/* COMMENT_5 */
		for ( VAR_2=VAR_1 ; VAR_2!=NULL; VAR_2 = (PST1 *) (VAR_2->pst.next) ) {
		    if ( VAR_2->tag==VAR_1->tag &&
			    VAR_2->script_lang_index==VAR_1->script_lang_index &&
			    VAR_2->flags==VAR_1->flags &&
			    VAR_2->pst.type==VAR_1->pst.type )
			VAR_2->pst.subtable = VAR_23;
		}
		for ( VAR_13=VAR_12+1; VAR_13<VAR_18->sf.glyphcnt; ++VAR_13 ) if ( (VAR_20=VAR_18->sf.glyphs[VAR_13])!=NULL ) {
		    for ( VAR_2 = (PST1 *) (VAR_20->possub); VAR_2!=NULL; VAR_2 = (PST1 *) (VAR_2->pst.next) ) {
			if ( VAR_2->tag==VAR_1->tag &&
				VAR_2->script_lang_index==VAR_1->script_lang_index &&
				VAR_2->flags==VAR_1->flags &&
				VAR_2->pst.type==VAR_1->pst.type )
			    VAR_2->pst.subtable = VAR_23;
		    }
		}
	    }
	}
	++VAR_16;
    } while ( VAR_16<VAR_0->sf.subfontcnt );

	/* COMMENT_6 */
    for ( VAR_3=0; VAR_3<2; ++VAR_3 ) {
	VAR_16=0;
	do {
	    VAR_18 = VAR_0->sf.subfontcnt==0 ? VAR_0 : (SplineFont1 *) (VAR_0->sf.subfonts[VAR_16]);
	    for ( VAR_12=0; VAR_12<VAR_18->sf.glyphcnt; ++VAR_12 ) if ( (VAR_19=VAR_18->sf.glyphs[VAR_12])!=NULL ) {
		for ( VAR_4 = (KernPair1 *) (VAR_3 ? VAR_19->vkerns : VAR_19->kerns); VAR_4!=NULL; VAR_4 = (KernPair1 *) (VAR_4->kp.next) ) {
		    if ( VAR_4->kp.subtable!=NULL )
		continue;		/* COMMENT_7 */
		    VAR_21 = CreateLookup(VAR_0,VAR_3 ? CHR('v','k','r','n') : CHR('k','e','r','n'),
			    VAR_4->sli,VAR_4->flags,VAR_27);
		    VAR_23 = CreateSubtable(VAR_21,VAR_0);
		    /* COMMENT_8 */
		    /* COMMENT_9 */
		    for ( VAR_5=VAR_4 ; VAR_5!=NULL; VAR_5 = (KernPair1 *) (VAR_5->kp.next) ) {
			if ( VAR_5->sli==VAR_4->sli && VAR_5->flags==VAR_4->flags )
			    VAR_5->kp.subtable = VAR_23;
		    }
		    for ( VAR_13=VAR_12+1; VAR_13<VAR_18->sf.glyphcnt; ++VAR_13 ) if ( (VAR_20=VAR_18->sf.glyphs[VAR_13])!=NULL ) {
			for ( VAR_5 = (KernPair1 *) (VAR_3 ? VAR_20->vkerns : VAR_20->kerns); VAR_5!=NULL; VAR_5 = (KernPair1 *) (VAR_5->kp.next) ) {
			    if ( VAR_5->sli==VAR_4->sli && VAR_5->flags==VAR_4->flags )
				VAR_5->kp.subtable = VAR_23;
			}
		    }
		    /* COMMENT_10 */
		    for ( VAR_6=(KernClass1 *) (VAR_3 ? VAR_0->sf.vkerns : VAR_0->sf.kerns); VAR_6!=NULL;
			    VAR_6 = (KernClass1 *) (VAR_6->kc.next) ) {
			if ( VAR_6->sli == VAR_4->sli && VAR_6->flags == VAR_4->flags && VAR_6->kc.subtable==NULL) {
			    VAR_23 = CreateSubtable(VAR_21,VAR_0);
			    VAR_23->per_glyph_pst_or_kern = false;
			    VAR_23->kc = &VAR_6->kc;
			    VAR_6->kc.subtable = VAR_23;
			}
		    }
		}
	    }
	    ++VAR_16;
	} while ( VAR_16<VAR_0->sf.subfontcnt );
	/* COMMENT_11 */
	for ( VAR_6=(KernClass1 *) (VAR_3 ? VAR_0->sf.vkerns : VAR_0->sf.kerns); VAR_6!=NULL;
		VAR_6 = (KernClass1 *) (VAR_6->kc.next) ) {
	    if ( VAR_6->kc.subtable==NULL) {
		VAR_21 = CreateLookup(VAR_0,VAR_3 ? CHR('v','k','r','n') : CHR('k','e','r','n'),
			VAR_6->sli,VAR_6->flags,VAR_27);
		for ( VAR_7=VAR_6; VAR_7!=NULL; VAR_7=(KernClass1 *) (VAR_7->kc.next) ) {
		    if ( VAR_6->sli == VAR_7->sli && VAR_6->flags == VAR_7->flags && VAR_7->kc.subtable==NULL) {
			VAR_23 = CreateSubtable(VAR_21,VAR_0);
			VAR_23->per_glyph_pst_or_kern = false;
			VAR_23->kc = &VAR_7->kc;
			VAR_7->kc.subtable = VAR_23;
		    }
		}
	    }
	}
    }

    /* COMMENT_12 */
    /* COMMENT_13 */
    /* COMMENT_14 */
    for ( VAR_8=(FPST1 *) VAR_0->sf.possub; VAR_8!=NULL; VAR_8=((FPST1 *) VAR_8->fpst.next) ) {
	VAR_21 = CreateLookup(VAR_0,VAR_8->tag, VAR_8->script_lang_index,
		VAR_8->flags,VAR_8->fpst.type);
	VAR_23 = CreateSubtable(VAR_21,VAR_0);
	VAR_23->per_glyph_pst_or_kern = false;
	VAR_23->fpst = &VAR_8->fpst;
	VAR_8->fpst.subtable = VAR_23;
	FPSTReplaceTagsWithLookups(&VAR_8->fpst,VAR_0);
    }
    for ( VAR_9=(ASM1 *) VAR_0->sf.sm; VAR_9!=NULL; VAR_9=((ASM1 *) VAR_9->sm.next) ) {
	VAR_21 = CreateMacLookup(VAR_0,VAR_9);
	VAR_23 = CreateSubtable(VAR_21,VAR_0);
	VAR_23->per_glyph_pst_or_kern = false;
	VAR_23->sm = &VAR_9->sm;
	VAR_9->sm.subtable = VAR_23;
	if ( VAR_9->sm.type==VAR_28 )
	    ASMReplaceTagsWithLookups(&VAR_9->sm,VAR_0);
    }

    /* COMMENT_15 */
    /* COMMENT_16 */
    for ( VAR_17=0; VAR_17<2; ++VAR_17 ) {
	for ( VAR_21 = VAR_17 ? VAR_0->sf.gpos_lookups : VAR_0->sf.gsub_lookups ;
		VAR_21 != NULL; VAR_21=VAR_21->next ) {
	    if ( VAR_21->features!=NULL && VAR_21->features->scripts==NULL ) {
		chunkfree(VAR_21->features,sizeof(VAR_29));
		VAR_21->features = NULL;
	    }
	}
    }

    /* COMMENT_17 */
    /* COMMENT_18 */
    /* COMMENT_19 */
    /* COMMENT_20 */
    for ( VAR_10=(AnchorClass1 *) (VAR_0->sf.anchor); VAR_10!=NULL; VAR_10=(AnchorClass1 *) VAR_10->ac.next ) {
	ACHasBaseLig(VAR_0,VAR_10);
	if ( VAR_10->has_ligatures && !VAR_10->has_bases )
	    VAR_10->ac.type = VAR_30;
	else if ( VAR_10->has_ligatures && VAR_10->has_bases )
	    ACDisassociateLigatures(VAR_0,VAR_10);
    }
    for ( VAR_10=(AnchorClass1 *) (VAR_0->sf.anchor); VAR_10!=NULL; VAR_10=(AnchorClass1 *) VAR_10->ac.next ) {
	if ( VAR_10->ac.subtable==NULL ) {
	    VAR_21 = CreateACLookup(VAR_0,VAR_10);
	    VAR_23 = CreateSubtable(VAR_21,VAR_0);
	    for ( VAR_11=VAR_10; VAR_11!=NULL; VAR_11 = (AnchorClass1 *) VAR_11->ac.next ) {
		if ( VAR_11->feature_tag == VAR_10->feature_tag &&
			VAR_11->script_lang_index == VAR_10->script_lang_index &&
			VAR_11->flags == VAR_10->flags &&
			VAR_11->ac.type == VAR_10->ac.type &&
			VAR_11->merge_with == VAR_10->merge_with )
		    VAR_11->ac.subtable = VAR_23;
	    }
	}
    }

    /* COMMENT_21 */
    /* COMMENT_22 */
    for ( VAR_21=VAR_0->sf.gsub_lookups, VAR_14=0; VAR_21!=NULL; VAR_21=VAR_21->next, ++VAR_14 );
    if ( VAR_14!=0 ) {
	VAR_22 = malloc(VAR_14*sizeof(OTLookup *));
	for ( VAR_21=VAR_0->sf.gsub_lookups, VAR_14=0; VAR_21!=NULL; VAR_21=VAR_21->next, ++VAR_14 ) {
	    VAR_22[VAR_14] = VAR_21;
	    VAR_21->lookup_index = GSubOrder(VAR_0,VAR_21->features);
	}
	qsort(VAR_22,VAR_14,sizeof(OTLookup *),VAR_31);
	VAR_0->sf.gsub_lookups = VAR_22[0];
	for ( VAR_15=1; VAR_15<VAR_14; ++VAR_15 )
	    VAR_22[VAR_15-1]->next = VAR_22[VAR_15];
	VAR_22[VAR_14-1]->next = NULL;
	free( VAR_22 );
    }

    for ( VAR_17=0; VAR_17<2; ++VAR_17 ) {
	for ( VAR_21 = VAR_17 ? VAR_0->sf.gpos_lookups : VAR_0->sf.gsub_lookups , VAR_14=0;
		VAR_21!=NULL; VAR_21 = VAR_21->next ) {
	    VAR_21->lookup_index = VAR_14++;
	    NameOTLookup(VAR_21,&VAR_0->sf);
	}
    }
}",fontforge/8da6d56bf7af2d25f779e52edef61b2fd4557b3c/sfd1.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,7 +14,7 @@
 
     /* Fix up some gunk from really old versions of the sfd format */
     SFDCleanupAnchorClasses(&sf->sf);
-    if ( sf->sf.uni_interp==ui_unset )
+    if ( sf->sf.uni_interp==ui_unset && sf->sf.map!=NULL )
 	sf->sf.uni_interp = interp_from_encoding(sf->sf.map->enc,ui_none);
 
     /* Fixup for an old bug */","{'deleted_lines': ['    if ( sf->sf.uni_interp==ui_unset )'], 'added_lines': ['    if ( sf->sf.uni_interp==ui_unset && sf->sf.map!=NULL )']}",True,FontForge 20190801 has a use-after-free in SFD_GetFontMetaData in sfd.c.,8.8,HIGH,2,valid,2020-01-06T11:05:06Z,3
CVE-2020-5395,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,fontforge,"Fix for #4084 Use-after-free (heap) in the SFD_GetFontMetaData() function
Fix for #4086 NULL pointer dereference in the SFDGetSpiros() function
Fix for #4088 NULL pointer dereference in the SFD_AssignLookups() function
Add empty sf->fontname string if it isn't set, fixing #4089 #4090 and many
  other potential issues (many downstream calls to strlen() on the value).",8da6d56bf7af2d25f779e52edef61b2fd4557b3c,https://github.com/fontforge/fontforge/commit/8da6d56bf7af2d25f779e52edef61b2fd4557b3c,fontforge/sfd.c,SFDGetSpiros,"static void SFDGetSpiros(FILE *sfd,SplineSet *cur) {
int ch;
spiro_cp cp;
ch = nlgetc(sfd);
ch = nlgetc(sfd);
ch = nlgetc(sfd);
ch = nlgetc(sfd);
ch = nlgetc(sfd);
while ( fscanf(sfd,""%lg %lg %c"", &cp.x, &cp.y, &cp.ty )==3 ) {
if ( cur!=NULL ) {
if ( cur->spiro_cnt>=cur->spiro_max )
cur->spiros = realloc(cur->spiros,(cur->spiro_max+=10)*sizeof(spiro_cp));
cur->spiros[cur->spiro_cnt++] = cp;
}
}
if ( cur!=NULL && (cur->spiros[cur->spiro_cnt-1].ty&0x7f)!=SPIRO_END ) {
if ( cur->spiro_cnt>=cur->spiro_max )
cur->spiros = realloc(cur->spiros,(cur->spiro_max+=1)*sizeof(spiro_cp));
memset(&cur->spiros[cur->spiro_cnt],0,sizeof(spiro_cp));
cur->spiros[cur->spiro_cnt++].ty = SPIRO_END;
}
ch = nlgetc(sfd);
if ( ch=='E' ) {
ch = nlgetc(sfd);
ch = nlgetc(sfd);
ch = nlgetc(sfd);
ch = nlgetc(sfd);
ch = nlgetc(sfd);
ch = nlgetc(sfd);
ch = nlgetc(sfd);
} else
ungetc(ch,sfd);
}","static void SFDGetSpiros(FILE *VAR_0,SplineSet *VAR_1) {
int VAR_2;
spiro_cp VAR_3;
VAR_2 = nlgetc(VAR_0);
VAR_2 = nlgetc(VAR_0);
VAR_2 = nlgetc(VAR_0);
VAR_2 = nlgetc(VAR_0);
VAR_2 = nlgetc(VAR_0);
while ( fscanf(VAR_0,""%lg %lg %c"", &VAR_3.x, &VAR_3.y, &VAR_3.ty )==3 ) {
if ( VAR_1!=NULL ) {
if ( VAR_1->spiro_cnt>=VAR_1->spiro_max )
VAR_1->spiros = realloc(VAR_1->spiros,(VAR_1->spiro_max+=10)*sizeof(spiro_cp));
VAR_1->spiros[VAR_1->spiro_cnt++] = VAR_3;
}
}
if ( VAR_1!=NULL && (VAR_1->spiros[VAR_1->spiro_cnt-1].ty&0x7f)!=VAR_4 ) {
if ( VAR_1->spiro_cnt>=VAR_1->spiro_max )
VAR_1->spiros = realloc(VAR_1->spiros,(VAR_1->spiro_max+=1)*sizeof(spiro_cp));
memset(&VAR_1->spiros[VAR_1->spiro_cnt],0,sizeof(spiro_cp));
VAR_1->spiros[VAR_1->spiro_cnt++].ty = VAR_4;
}
VAR_2 = nlgetc(VAR_0);
if ( VAR_2=='E' ) {
VAR_2 = nlgetc(VAR_0);
VAR_2 = nlgetc(VAR_0);
VAR_2 = nlgetc(VAR_0);
VAR_2 = nlgetc(VAR_0);
VAR_2 = nlgetc(VAR_0);
VAR_2 = nlgetc(VAR_0);
VAR_2 = nlgetc(VAR_0);
} else
ungetc(VAR_2,VAR_0);
}",fontforge/8da6d56bf7af2d25f779e52edef61b2fd4557b3c/sfd.c/vul/before/1.json,"static void SFDGetSpiros(FILE *sfd,SplineSet *cur) {
    int ch;
    spiro_cp cp;

    ch = nlgetc(sfd);		/* S */
    ch = nlgetc(sfd);		/* p */
    ch = nlgetc(sfd);		/* i */
    ch = nlgetc(sfd);		/* r */
    ch = nlgetc(sfd);		/* o */
    while ( fscanf(sfd,""%lg %lg %c"", &cp.x, &cp.y, &cp.ty )==3 ) {
	if ( cur!=NULL ) {
	    if ( cur->spiro_cnt>=cur->spiro_max )
		cur->spiros = realloc(cur->spiros,
		                      (cur->spiro_max+=10)*sizeof(spiro_cp));
	    cur->spiros[cur->spiro_cnt++] = cp;
	}
    }
    if (    cur!=NULL && cur->spiro_cnt>0
         && (cur->spiros[cur->spiro_cnt-1].ty&0x7f)!=SPIRO_END ) {
	if ( cur->spiro_cnt>=cur->spiro_max )
	    cur->spiros = realloc(cur->spiros,
	                          (cur->spiro_max+=1)*sizeof(spiro_cp));
	memset(&cur->spiros[cur->spiro_cnt],0,sizeof(spiro_cp));
	cur->spiros[cur->spiro_cnt++].ty = SPIRO_END;
    }
    ch = nlgetc(sfd);
    if ( ch=='E' ) {
	ch = nlgetc(sfd);		/* n */
	ch = nlgetc(sfd);		/* d */
	ch = nlgetc(sfd);		/* S */
	ch = nlgetc(sfd);		/* p */
	ch = nlgetc(sfd);		/* i */
	ch = nlgetc(sfd);		/* r */
	ch = nlgetc(sfd);		/* o */
    } else
	ungetc(ch,sfd);
}","static void SFDGetSpiros(FILE *VAR_0,SplineSet *VAR_1) {
    int VAR_2;
    spiro_cp VAR_3;

    VAR_2 = nlgetc(VAR_0);		/* COMMENT_0 */
    VAR_2 = nlgetc(VAR_0);		/* COMMENT_1 */
    VAR_2 = nlgetc(VAR_0);		/* COMMENT_2 */
    VAR_2 = nlgetc(VAR_0);		/* COMMENT_3 */
    VAR_2 = nlgetc(VAR_0);		/* COMMENT_4 */
    while ( fscanf(VAR_0,""%lg %lg %c"", &VAR_3.x, &VAR_3.y, &VAR_3.ty )==3 ) {
	if ( VAR_1!=NULL ) {
	    if ( VAR_1->spiro_cnt>=VAR_1->spiro_max )
		VAR_1->spiros = realloc(VAR_1->spiros,
		                      (VAR_1->spiro_max+=10)*sizeof(spiro_cp));
	    VAR_1->spiros[VAR_1->spiro_cnt++] = VAR_3;
	}
    }
    if (    VAR_1!=NULL && VAR_1->spiro_cnt>0
         && (VAR_1->spiros[VAR_1->spiro_cnt-1].ty&0x7f)!=VAR_4 ) {
	if ( VAR_1->spiro_cnt>=VAR_1->spiro_max )
	    VAR_1->spiros = realloc(VAR_1->spiros,
	                          (VAR_1->spiro_max+=1)*sizeof(spiro_cp));
	memset(&VAR_1->spiros[VAR_1->spiro_cnt],0,sizeof(spiro_cp));
	VAR_1->spiros[VAR_1->spiro_cnt++].ty = VAR_4;
    }
    VAR_2 = nlgetc(VAR_0);
    if ( VAR_2=='E' ) {
	VAR_2 = nlgetc(VAR_0);		/* COMMENT_5 */
	VAR_2 = nlgetc(VAR_0);		/* COMMENT_6 */
	VAR_2 = nlgetc(VAR_0);		/* COMMENT_0 */
	VAR_2 = nlgetc(VAR_0);		/* COMMENT_1 */
	VAR_2 = nlgetc(VAR_0);		/* COMMENT_2 */
	VAR_2 = nlgetc(VAR_0);		/* COMMENT_3 */
	VAR_2 = nlgetc(VAR_0);		/* COMMENT_4 */
    } else
	ungetc(VAR_2,VAR_0);
}",fontforge/8da6d56bf7af2d25f779e52edef61b2fd4557b3c/sfd.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -10,13 +10,16 @@
     while ( fscanf(sfd,""%lg %lg %c"", &cp.x, &cp.y, &cp.ty )==3 ) {
 	if ( cur!=NULL ) {
 	    if ( cur->spiro_cnt>=cur->spiro_max )
-		cur->spiros = realloc(cur->spiros,(cur->spiro_max+=10)*sizeof(spiro_cp));
+		cur->spiros = realloc(cur->spiros,
+		                      (cur->spiro_max+=10)*sizeof(spiro_cp));
 	    cur->spiros[cur->spiro_cnt++] = cp;
 	}
     }
-    if ( cur!=NULL && (cur->spiros[cur->spiro_cnt-1].ty&0x7f)!=SPIRO_END ) {
+    if (    cur!=NULL && cur->spiro_cnt>0
+         && (cur->spiros[cur->spiro_cnt-1].ty&0x7f)!=SPIRO_END ) {
 	if ( cur->spiro_cnt>=cur->spiro_max )
-	    cur->spiros = realloc(cur->spiros,(cur->spiro_max+=1)*sizeof(spiro_cp));
+	    cur->spiros = realloc(cur->spiros,
+	                          (cur->spiro_max+=1)*sizeof(spiro_cp));
 	memset(&cur->spiros[cur->spiro_cnt],0,sizeof(spiro_cp));
 	cur->spiros[cur->spiro_cnt++].ty = SPIRO_END;
     }","{'deleted_lines': ['\t\tcur->spiros = realloc(cur->spiros,(cur->spiro_max+=10)*sizeof(spiro_cp));', '    if ( cur!=NULL && (cur->spiros[cur->spiro_cnt-1].ty&0x7f)!=SPIRO_END ) {', '\t    cur->spiros = realloc(cur->spiros,(cur->spiro_max+=1)*sizeof(spiro_cp));'], 'added_lines': ['\t\tcur->spiros = realloc(cur->spiros,', '\t\t                      (cur->spiro_max+=10)*sizeof(spiro_cp));', '    if (    cur!=NULL && cur->spiro_cnt>0', '         && (cur->spiros[cur->spiro_cnt-1].ty&0x7f)!=SPIRO_END ) {', '\t    cur->spiros = realloc(cur->spiros,', '\t                          (cur->spiro_max+=1)*sizeof(spiro_cp));']}",True,FontForge 20190801 has a use-after-free in SFD_GetFontMetaData in sfd.c.,8.8,HIGH,2,valid,2020-01-06T11:05:06Z,3
CVE-2019-20162,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fix parsing of weird uuid boxes (#1327),3c0ba42546c8148c51169c3908e845c308746c77,https://github.com/gpac/gpac/commit/3c0ba42546c8148c51169c3908e845c308746c77,src/isomedia/box_funcs.c,gf_isom_box_parse_ex,"GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box)
{
u32 type, uuid_type, hdr_size;
u64 size, start, payload_start, end;
char uuid[16];
GF_Err e;
GF_Box *newBox;
Bool skip_logs = gf_bs_get_cookie(bs) ? GF_TRUE : GF_FALSE;
if ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;
*outBox = NULL;
if (gf_bs_available(bs) < 8) {
return GF_ISOM_INCOMPLETE_FILE;
}
start = gf_bs_get_position(bs);
uuid_type = 0;
size = (u64) gf_bs_read_u32(bs);
hdr_size = 4;
if ((size >= 2) && (size <= 4)) {
size = 4;
type = GF_ISOM_BOX_TYPE_VOID;
} else {
type = gf_bs_read_u32(bs);
hdr_size += 4;
if (type == GF_ISOM_BOX_TYPE_TOTL)
size = 12;
if (!size) {
if (is_root_box) {
if (!skip_logs) {
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\n"", gf_4cc_to_str(type), type));
}
size = gf_bs_available(bs) + 8;
} else {
if (!skip_logs) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box type %s (0x%08X) at position ""LLU"" has size 0 but is not at root/file level, skipping\n"", gf_4cc_to_str(type), type, start));
}
return GF_OK;
}
}
}
memset(uuid, 0, 16);
if (type == GF_ISOM_BOX_TYPE_UUID ) {
if (gf_bs_available(bs) < 16) {
return GF_ISOM_INCOMPLETE_FILE;
}
gf_bs_read_data(bs, uuid, 16);
hdr_size += 16;
uuid_type = gf_isom_solve_uuid_box(uuid);
}
if (size == 1) {
if (gf_bs_available(bs) < 8) {
return GF_ISOM_INCOMPLETE_FILE;
}
size = gf_bs_read_u64(bs);
hdr_size += 8;
}
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Read Box type %s size ""LLD"" start ""LLD""\n"", gf_4cc_to_str(type), LLD_CAST size, LLD_CAST start));
if ( size < hdr_size ) {
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Box size ""LLD"" less than box header size %d\n"", LLD_CAST size, hdr_size));
return GF_ISOM_INVALID_FILE;
}
if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);
if (!newBox) return GF_OUT_OF_MEM;
((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;
} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);
if (!newBox) return GF_OUT_OF_MEM;
((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;
} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);
if (!newBox) return GF_OUT_OF_MEM;
((GF_TrackGroupTypeBox*)newBox)->group_type = type;
} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);
if (!newBox) return GF_OUT_OF_MEM;
((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;
} else {
newBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);
if (!newBox) return GF_OUT_OF_MEM;
}
if (type==GF_ISOM_BOX_TYPE_UUID) {
memcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);
((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;
}
if (!newBox->type) newBox->type = type;
payload_start = gf_bs_get_position(bs);
retry_unknown_box:
end = gf_bs_available(bs);
if (size - hdr_size > end ) {
newBox->size = size - hdr_size - end;
*outBox = newBox;
return GF_ISOM_INCOMPLETE_FILE;
}
newBox->size = size - hdr_size;
if (newBox->size) {
e = gf_isom_full_box_read(newBox, bs);
if (!e) e = gf_isom_box_read(newBox, bs);
newBox->size = size;
end = gf_bs_get_position(bs);
} else {
newBox->size = size;
e = GF_OK;
end = gf_bs_get_position(bs);
}
if (e && (e != GF_ISOM_INCOMPLETE_FILE)) {
gf_isom_box_del(newBox);
*outBox = NULL;
if (parent_type==GF_ISOM_BOX_TYPE_STSD) {
newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);
((GF_UnknownBox *)newBox)->original_4cc = type;
newBox->size = size;
gf_bs_seek(bs, payload_start);
goto retry_unknown_box;
}
if (!skip_logs) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box \""%s\"" (start ""LLU"") failed (%s) - skipping\n"", gf_4cc_to_str(type), start, gf_error_to_string(e)));
}
return e;
}
if (end-start > size) {
if (!skip_logs) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" size ""LLU"" (start ""LLU"") invalid (read ""LLU"")\n"", gf_4cc_to_str(type), LLU_CAST size, start, LLU_CAST (end-start) ));
}
gf_bs_seek(bs, start+size);
} else if (end-start < size) {
u32 to_skip = (u32) (size-(end-start));
if (!skip_logs) {
if ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" (start ""LLU"") has %u extra bytes\n"", gf_4cc_to_str(type), start, to_skip));
}
}
gf_bs_skip_bytes(bs, to_skip);
}
*outBox = newBox;
return e;
}","GF_Err gf_isom_box_parse_ex(GF_Box **VAR_0, GF_BitStream *VAR_1, u32 VAR_2, Bool VAR_3)
{
u32 VAR_4, VAR_5, VAR_6;
u64 VAR_7, VAR_8, VAR_9, VAR_10;
char VAR_11[16];
GF_Err VAR_12;
GF_Box *VAR_13;
Bool VAR_14 = gf_bs_get_cookie(VAR_1) ? VAR_15 : VAR_16;
if ((VAR_1 == NULL) || (VAR_0 == NULL) ) return VAR_17;
*VAR_0 = NULL;
if (gf_bs_available(VAR_1) < 8) {
return VAR_18;
}
VAR_8 = gf_bs_get_position(VAR_1);
VAR_5 = 0;
VAR_7 = (u64) gf_bs_read_u32(VAR_1);
VAR_6 = 4;
if ((VAR_7 >= 2) && (VAR_7 <= 4)) {
VAR_7 = 4;
VAR_4 = VAR_19;
} else {
VAR_4 = gf_bs_read_u32(VAR_1);
VAR_6 += 4;
if (VAR_4 == VAR_20)
VAR_7 = 12;
if (!VAR_7) {
if (VAR_3) {
if (!VAR_14) {
GF_LOG(VAR_21, VAR_22, (""[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\n"", gf_4cc_to_str(VAR_4), VAR_4));
}
VAR_7 = gf_bs_available(VAR_1) + 8;
} else {
if (!VAR_14) {
GF_LOG(VAR_23, VAR_22, (""[iso file] Read Box type %s (0x%08X) at position ""VAR_24"" has size 0 but is not at root/file level, skipping\n"", gf_4cc_to_str(VAR_4), VAR_4, VAR_8));
}
return VAR_25;
}
}
}
memset(VAR_11, 0, 16);
if (VAR_4 == VAR_26 ) {
if (gf_bs_available(VAR_1) < 16) {
return VAR_18;
}
gf_bs_read_data(VAR_1, VAR_11, 16);
VAR_6 += 16;
VAR_5 = gf_isom_solve_uuid_box(VAR_11);
}
if (VAR_7 == 1) {
if (gf_bs_available(VAR_1) < 8) {
return VAR_18;
}
VAR_7 = gf_bs_read_u64(VAR_1);
VAR_6 += 8;
}
GF_LOG(VAR_21, VAR_22, (""[iso file] Read Box type %s size ""VAR_27"" start ""VAR_27""\n"", gf_4cc_to_str(VAR_4), VAR_28 VAR_7, VAR_28 VAR_8));
if ( VAR_7 < VAR_6 ) {
GF_LOG(VAR_21, VAR_22, (""[iso file] Box size ""VAR_27"" less than box header size %d\n"", VAR_28 VAR_7, VAR_6));
return VAR_29;
}
if (VAR_2 && (VAR_2 == VAR_30)) {
VAR_13 = gf_isom_box_new(VAR_31);
if (!VAR_13) return VAR_32;
((GF_TrackReferenceTypeBox*)VAR_13)->reference_type = VAR_4;
} else if (VAR_2 && (VAR_2 == VAR_33)) {
VAR_13 = gf_isom_box_new(VAR_34);
if (!VAR_13) return VAR_32;
((GF_ItemReferenceTypeBox*)VAR_13)->reference_type = VAR_4;
} else if (VAR_2 && (VAR_2 == VAR_35)) {
VAR_13 = gf_isom_box_new(VAR_36);
if (!VAR_13) return VAR_32;
((GF_TrackGroupTypeBox*)VAR_13)->group_type = VAR_4;
} else if (VAR_2 && (VAR_2 == VAR_37)) {
VAR_13 = gf_isom_box_new(VAR_38);
if (!VAR_13) return VAR_32;
((GF_EntityToGroupTypeBox*)VAR_13)->grouping_type = VAR_4;
} else {
VAR_13 = gf_isom_box_new_ex(VAR_5 ? VAR_5 : VAR_4, VAR_2, VAR_14, VAR_3);
if (!VAR_13) return VAR_32;
}
if (VAR_4==VAR_26) {
memcpy(((GF_UUIDBox *)VAR_13)->uuid, VAR_11, 16);
((GF_UUIDBox *)VAR_13)->internal_4cc = VAR_5;
}
if (!VAR_13->type) VAR_13->type = VAR_4;
VAR_9 = gf_bs_get_position(VAR_1);
retry_unknown_box:
VAR_10 = gf_bs_available(VAR_1);
if (VAR_7 - VAR_6 > VAR_10 ) {
VAR_13->size = VAR_7 - VAR_6 - VAR_10;
*VAR_0 = VAR_13;
return VAR_18;
}
VAR_13->size = VAR_7 - VAR_6;
if (VAR_13->size) {
VAR_12 = gf_isom_full_box_read(VAR_13, VAR_1);
if (!VAR_12) VAR_12 = gf_isom_box_read(VAR_13, VAR_1);
VAR_13->size = VAR_7;
VAR_10 = gf_bs_get_position(VAR_1);
} else {
VAR_13->size = VAR_7;
VAR_12 = VAR_25;
VAR_10 = gf_bs_get_position(VAR_1);
}
if (VAR_12 && (VAR_12 != VAR_18)) {
gf_isom_box_del(VAR_13);
*VAR_0 = NULL;
if (VAR_2==VAR_39) {
VAR_13 = gf_isom_box_new(VAR_40);
((GF_UnknownBox *)VAR_13)->original_4cc = VAR_4;
VAR_13->size = VAR_7;
gf_bs_seek(VAR_1, VAR_9);
goto retry_unknown_box;
}
if (!VAR_14) {
GF_LOG(VAR_23, VAR_22, (""[iso file] Read Box \""%s\"" (start ""VAR_24"") failed (%s) - skipping\n"", gf_4cc_to_str(VAR_4), VAR_8, gf_error_to_string(VAR_12)));
}
return VAR_12;
}
if (VAR_10-VAR_8 > VAR_7) {
if (!VAR_14) {
GF_LOG(VAR_41, VAR_22, (""[iso file] Box \""%s\"" size ""VAR_24"" (start ""VAR_24"") invalid (read ""VAR_24"")\n"", gf_4cc_to_str(VAR_4), VAR_42 VAR_7, VAR_8, VAR_42 (VAR_10-VAR_8) ));
}
gf_bs_seek(VAR_1, VAR_8+VAR_7);
} else if (VAR_10-VAR_8 < VAR_7) {
u32 VAR_43 = (u32) (VAR_7-(VAR_10-VAR_8));
if (!VAR_14) {
if ((VAR_43!=4) || gf_bs_peek_bits(VAR_1, 32, 0)) {
GF_LOG(VAR_41, VAR_22, (""[iso file] Box \""%s\"" (start ""VAR_24"") has %u extra bytes\n"", gf_4cc_to_str(VAR_4), VAR_8, VAR_43));
}
}
gf_bs_skip_bytes(VAR_1, VAR_43);
}
*VAR_0 = VAR_13;
return VAR_12;
}",gpac/3c0ba42546c8148c51169c3908e845c308746c77/box_funcs.c/vul/before/0.json,"GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box)
{
	u32 type, uuid_type, hdr_size;
	u64 size, start, payload_start, end;
	char uuid[16];
	GF_Err e;
	GF_Box *newBox;
	Bool skip_logs = gf_bs_get_cookie(bs) ? GF_TRUE : GF_FALSE;
	Bool is_special = GF_TRUE;

	if ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;
	*outBox = NULL;
	if (gf_bs_available(bs) < 8) {
		return GF_ISOM_INCOMPLETE_FILE;
	}

	start = gf_bs_get_position(bs);

	uuid_type = 0;
	size = (u64) gf_bs_read_u32(bs);
	hdr_size = 4;
	/*fix for some boxes found in some old hinted files*/
	if ((size >= 2) && (size <= 4)) {
		size = 4;
		type = GF_ISOM_BOX_TYPE_VOID;
	} else {
		type = gf_bs_read_u32(bs);
		hdr_size += 4;
		/*no size means till end of file - EXCEPT FOR some old QuickTime boxes...*/
		if (type == GF_ISOM_BOX_TYPE_TOTL)
			size = 12;
		if (!size) {
			if (is_root_box) {
				if (!skip_logs) {
					GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\n"", gf_4cc_to_str(type), type));
				}
				size = gf_bs_available(bs) + 8;
			} else {
				if (!skip_logs) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box type %s (0x%08X) at position ""LLU"" has size 0 but is not at root/file level, skipping\n"", gf_4cc_to_str(type), type, start));
				}
				return GF_OK;
//				return GF_ISOM_INVALID_FILE;
			}
		}
	}
	/*handle uuid*/
	memset(uuid, 0, 16);
	if (type == GF_ISOM_BOX_TYPE_UUID ) {
		if (gf_bs_available(bs) < 16) {
			return GF_ISOM_INCOMPLETE_FILE;
		}
		gf_bs_read_data(bs, uuid, 16);
		hdr_size += 16;
		uuid_type = gf_isom_solve_uuid_box(uuid);
	}

	//handle large box
	if (size == 1) {
		if (gf_bs_available(bs) < 8) {
			return GF_ISOM_INCOMPLETE_FILE;
		}
		size = gf_bs_read_u64(bs);
		hdr_size += 8;
	}
	GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Read Box type %s size ""LLD"" start ""LLD""\n"", gf_4cc_to_str(type), LLD_CAST size, LLD_CAST start));

	if ( size < hdr_size ) {
		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Box size ""LLD"" less than box header size %d\n"", LLD_CAST size, hdr_size));
		return GF_ISOM_INVALID_FILE;
	}

	//some special boxes (references and track groups) are handled by a single generic box with an associated ref/group type
	if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {
		newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);
		if (!newBox) return GF_OUT_OF_MEM;
		((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;
	} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {
		newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);
		if (!newBox) return GF_OUT_OF_MEM;
		((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;
	} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {
		newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);
		if (!newBox) return GF_OUT_OF_MEM;
		((GF_TrackGroupTypeBox*)newBox)->group_type = type;
	} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {
		newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);
		if (!newBox) return GF_OUT_OF_MEM;
		((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;
	} else {
		//OK, create the box based on the type
		is_special = GF_FALSE;
		newBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);
		if (!newBox) return GF_OUT_OF_MEM;
	}

	//OK, init and read this box
	if (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {
		memcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);
		((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;
	}

	if (!newBox->type) newBox->type = type;
	payload_start = gf_bs_get_position(bs);

retry_unknown_box:

	end = gf_bs_available(bs);
	if (size - hdr_size > end ) {
		newBox->size = size - hdr_size - end;
		*outBox = newBox;
		return GF_ISOM_INCOMPLETE_FILE;
	}

	newBox->size = size - hdr_size;

	if (newBox->size) {
		e = gf_isom_full_box_read(newBox, bs);
		if (!e) e = gf_isom_box_read(newBox, bs);
		newBox->size = size;
		end = gf_bs_get_position(bs);
	} else {
		newBox->size = size;
		//empty box
		e = GF_OK;
		end = gf_bs_get_position(bs);
	}

	if (e && (e != GF_ISOM_INCOMPLETE_FILE)) {
		gf_isom_box_del(newBox);
		*outBox = NULL;

		if (parent_type==GF_ISOM_BOX_TYPE_STSD) {
			newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);
			((GF_UnknownBox *)newBox)->original_4cc = type;
			newBox->size = size;
			gf_bs_seek(bs, payload_start);
			goto retry_unknown_box;
		}
		if (!skip_logs) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box \""%s\"" (start ""LLU"") failed (%s) - skipping\n"", gf_4cc_to_str(type), start, gf_error_to_string(e)));
		}
		//we don't try to reparse known boxes that have been failing (too dangerous)
		return e;
	}

	if (end-start > size) {
		if (!skip_logs) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" size ""LLU"" (start ""LLU"") invalid (read ""LLU"")\n"", gf_4cc_to_str(type), LLU_CAST size, start, LLU_CAST (end-start) ));
		}
		/*let's still try to load the file since no error was notified*/
		gf_bs_seek(bs, start+size);
	} else if (end-start < size) {
		u32 to_skip = (u32) (size-(end-start));
		if (!skip_logs) {
			if ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" (start ""LLU"") has %u extra bytes\n"", gf_4cc_to_str(type), start, to_skip));
			}
		}
		gf_bs_skip_bytes(bs, to_skip);
	}
	*outBox = newBox;

	return e;
}","GF_Err gf_isom_box_parse_ex(GF_Box **VAR_0, GF_BitStream *VAR_1, u32 VAR_2, Bool VAR_3)
{
	u32 VAR_4, VAR_5, VAR_6;
	u64 VAR_7, VAR_8, VAR_9, VAR_10;
	char VAR_11[16];
	GF_Err VAR_12;
	GF_Box *VAR_13;
	Bool VAR_14 = gf_bs_get_cookie(VAR_1) ? VAR_15 : VAR_16;
	Bool VAR_17 = VAR_15;

	if ((VAR_1 == NULL) || (VAR_0 == NULL) ) return VAR_18;
	*VAR_0 = NULL;
	if (gf_bs_available(VAR_1) < 8) {
		return VAR_19;
	}

	VAR_8 = gf_bs_get_position(VAR_1);

	VAR_5 = 0;
	VAR_7 = (u64) gf_bs_read_u32(VAR_1);
	VAR_6 = 4;
	/* COMMENT_0 */
	if ((VAR_7 >= 2) && (VAR_7 <= 4)) {
		VAR_7 = 4;
		VAR_4 = VAR_20;
	} else {
		VAR_4 = gf_bs_read_u32(VAR_1);
		VAR_6 += 4;
		/* COMMENT_1 */
		if (VAR_4 == VAR_21)
			VAR_7 = 12;
		if (!VAR_7) {
			if (VAR_3) {
				if (!VAR_14) {
					GF_LOG(VAR_22, VAR_23, (""[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\n"", gf_4cc_to_str(VAR_4), VAR_4));
				}
				VAR_7 = gf_bs_available(VAR_1) + 8;
			} else {
				if (!VAR_14) {
					GF_LOG(VAR_24, VAR_23, (""[iso file] Read Box type %s (0x%08X) at position ""VAR_25"" has size 0 but is not at root/file level, skipping\n"", gf_4cc_to_str(VAR_4), VAR_4, VAR_8));
				}
				return VAR_26;
/* COMMENT_2 */
			}
		}
	}
	/* COMMENT_3 */
	memset(VAR_11, 0, 16);
	if (VAR_4 == VAR_27 ) {
		if (gf_bs_available(VAR_1) < 16) {
			return VAR_19;
		}
		gf_bs_read_data(VAR_1, VAR_11, 16);
		VAR_6 += 16;
		VAR_5 = gf_isom_solve_uuid_box(VAR_11);
	}

	/* COMMENT_4 */
	if (VAR_7 == 1) {
		if (gf_bs_available(VAR_1) < 8) {
			return VAR_19;
		}
		VAR_7 = gf_bs_read_u64(VAR_1);
		VAR_6 += 8;
	}
	GF_LOG(VAR_22, VAR_23, (""[iso file] Read Box type %s size ""VAR_28"" start ""VAR_28""\n"", gf_4cc_to_str(VAR_4), VAR_29 VAR_7, VAR_29 VAR_8));

	if ( VAR_7 < VAR_6 ) {
		GF_LOG(VAR_22, VAR_23, (""[iso file] Box size ""VAR_28"" less than box header size %d\n"", VAR_29 VAR_7, VAR_6));
		return VAR_30;
	}

	/* COMMENT_5 */
	if (VAR_2 && (VAR_2 == VAR_31)) {
		VAR_13 = gf_isom_box_new(VAR_32);
		if (!VAR_13) return VAR_33;
		((GF_TrackReferenceTypeBox*)VAR_13)->reference_type = VAR_4;
	} else if (VAR_2 && (VAR_2 == VAR_34)) {
		VAR_13 = gf_isom_box_new(VAR_35);
		if (!VAR_13) return VAR_33;
		((GF_ItemReferenceTypeBox*)VAR_13)->reference_type = VAR_4;
	} else if (VAR_2 && (VAR_2 == VAR_36)) {
		VAR_13 = gf_isom_box_new(VAR_37);
		if (!VAR_13) return VAR_33;
		((GF_TrackGroupTypeBox*)VAR_13)->group_type = VAR_4;
	} else if (VAR_2 && (VAR_2 == VAR_38)) {
		VAR_13 = gf_isom_box_new(VAR_39);
		if (!VAR_13) return VAR_33;
		((GF_EntityToGroupTypeBox*)VAR_13)->grouping_type = VAR_4;
	} else {
		/* COMMENT_6 */
		VAR_17 = VAR_16;
		VAR_13 = gf_isom_box_new_ex(VAR_5 ? VAR_5 : VAR_4, VAR_2, VAR_14, VAR_3);
		if (!VAR_13) return VAR_33;
	}

	/* COMMENT_7 */
	if (VAR_4==VAR_27 && !VAR_17) {
		memcpy(((GF_UUIDBox *)VAR_13)->uuid, VAR_11, 16);
		((GF_UUIDBox *)VAR_13)->internal_4cc = VAR_5;
	}

	if (!VAR_13->type) VAR_13->type = VAR_4;
	VAR_9 = gf_bs_get_position(VAR_1);

retry_unknown_box:

	VAR_10 = gf_bs_available(VAR_1);
	if (VAR_7 - VAR_6 > VAR_10 ) {
		VAR_13->size = VAR_7 - VAR_6 - VAR_10;
		*VAR_0 = VAR_13;
		return VAR_19;
	}

	VAR_13->size = VAR_7 - VAR_6;

	if (VAR_13->size) {
		VAR_12 = gf_isom_full_box_read(VAR_13, VAR_1);
		if (!VAR_12) VAR_12 = gf_isom_box_read(VAR_13, VAR_1);
		VAR_13->size = VAR_7;
		VAR_10 = gf_bs_get_position(VAR_1);
	} else {
		VAR_13->size = VAR_7;
		/* COMMENT_8 */
		VAR_12 = VAR_26;
		VAR_10 = gf_bs_get_position(VAR_1);
	}

	if (VAR_12 && (VAR_12 != VAR_19)) {
		gf_isom_box_del(VAR_13);
		*VAR_0 = NULL;

		if (VAR_2==VAR_40) {
			VAR_13 = gf_isom_box_new(VAR_41);
			((GF_UnknownBox *)VAR_13)->original_4cc = VAR_4;
			VAR_13->size = VAR_7;
			gf_bs_seek(VAR_1, VAR_9);
			goto retry_unknown_box;
		}
		if (!VAR_14) {
			GF_LOG(VAR_24, VAR_23, (""[iso file] Read Box \""%s\"" (start ""VAR_25"") failed (%s) - skipping\n"", gf_4cc_to_str(VAR_4), VAR_8, gf_error_to_string(VAR_12)));
		}
		/* COMMENT_9 */
		return VAR_12;
	}

	if (VAR_10-VAR_8 > VAR_7) {
		if (!VAR_14) {
			GF_LOG(VAR_42, VAR_23, (""[iso file] Box \""%s\"" size ""VAR_25"" (start ""VAR_25"") invalid (read ""VAR_25"")\n"", gf_4cc_to_str(VAR_4), VAR_43 VAR_7, VAR_8, VAR_43 (VAR_10-VAR_8) ));
		}
		/* COMMENT_10 */
		gf_bs_seek(VAR_1, VAR_8+VAR_7);
	} else if (VAR_10-VAR_8 < VAR_7) {
		u32 VAR_44 = (u32) (VAR_7-(VAR_10-VAR_8));
		if (!VAR_14) {
			if ((VAR_44!=4) || gf_bs_peek_bits(VAR_1, 32, 0)) {
				GF_LOG(VAR_42, VAR_23, (""[iso file] Box \""%s\"" (start ""VAR_25"") has %u extra bytes\n"", gf_4cc_to_str(VAR_4), VAR_8, VAR_44));
			}
		}
		gf_bs_skip_bytes(VAR_1, VAR_44);
	}
	*VAR_0 = VAR_13;

	return VAR_12;
}",gpac/3c0ba42546c8148c51169c3908e845c308746c77/box_funcs.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,7 @@
 	GF_Err e;
 	GF_Box *newBox;
 	Bool skip_logs = gf_bs_get_cookie(bs) ? GF_TRUE : GF_FALSE;
+	Bool is_special = GF_TRUE;
 
 	if ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;
 	*outBox = NULL;
@@ -88,12 +89,13 @@
 		((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;
 	} else {
 		//OK, create the box based on the type
+		is_special = GF_FALSE;
 		newBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);
 		if (!newBox) return GF_OUT_OF_MEM;
 	}
 
 	//OK, init and read this box
-	if (type==GF_ISOM_BOX_TYPE_UUID) {
+	if (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {
 		memcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);
 		((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;
 	}","{'deleted_lines': ['\tif (type==GF_ISOM_BOX_TYPE_UUID) {'], 'added_lines': ['\tBool is_special = GF_TRUE;', '\t\tis_special = GF_FALSE;', '\tif (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {']}",True,An issue was discovered in GPAC version 0.8.0 and 0.9.0-development-20191109. There is heap-based buffer overflow in the function gf_isom_box_parse_ex() in isomedia/box_funcs.c.,5.5,MEDIUM,1,valid,2020-01-07T14:04:13Z,3
CVE-2020-8448,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,ossec/ossec-hids,"analysisd: fix possible null ptr deref in OS_CleanMSG.

If the `msg` provided to `OS_CleanMSG` has a `(` after the ID, but
doesn't not contain a `->` or `:` it should be rejected with
a `FORMAT_ERROR`.

Prev. to this commit nesting `strstr` for `->` as the first argument to
`strchr` for `:` results in a null ptr deref when the message is
malformed.",9b8b14c88188cdc66ab25f92a26918d0cb8a7760,https://github.com/ossec/ossec-hids/commit/9b8b14c88188cdc66ab25f92a26918d0cb8a7760,src/analysisd/cleanevent.c,OS_CleanMSG,"int OS_CleanMSG(char *msg, Eventinfo *lf)
{
size_t loglen;
char *pieces;
struct tm *p;
msg += 2;
pieces = strchr(msg, ':');
if (!pieces) {
merror(FORMAT_ERROR, ARGV0);
return (-1);
}
if ( *msg == '(' )
{   
pieces = strchr(strstr(msg, ""->""), ':');
if(!pieces)
{
merror(FORMAT_ERROR, ARGV0);
return(-1);
}
}
*pieces = '\0';
pieces++;
os_strdup(msg, lf->location);
loglen = strlen(pieces) + 1;
os_malloc((2 * loglen) + 1, lf->full_log);
strncpy(lf->full_log, pieces, loglen);
lf->log = lf->full_log + loglen;
strncpy(lf->log, pieces, loglen);
if (pieces[1] == (char) 195) {
if (pieces[2] == (char) 164) {
pieces[0] = '\0';
pieces[1] = 'M';
pieces[2] = 'a';
pieces++;
}
}
if (
(   
(loglen > 17) &&
(pieces[3] == ' ') &&
(pieces[6] == ' ') &&
(pieces[9] == ':') &&
(pieces[12] == ':') &&
(pieces[15] == ' ') && (lf->log += 16)
)
||
(   
(loglen > 24) &&
(pieces[4] == '-') &&
(pieces[7] == '-') &&
(pieces[10] == ' ') &&
(pieces[13] == ':') &&
(pieces[16] == ':') &&
(pieces[19] == ',') &&
(lf->log += 23)
)
||
(
(loglen > 33) &&
(pieces[4] == '-') &&
(pieces[7] == '-') &&
(pieces[10] == 'T') &&
(pieces[13] == ':') &&
(pieces[16] == ':') &&
(   
(
(pieces[22] == ':') &&
(pieces[25] == ' ') && (lf->log += 26)
)
||
(
(
(pieces[19] == '.') || (pieces[19] == ',')
)
&&
(
( (pieces[24] == ':') && (lf->log += 27) ) ||
( (pieces[25] == ':') && (lf->log += 28) ) ||
( (pieces[26] == ':') && (lf->log += 29) ) ||
( (pieces[27] == ':') && (lf->log += 30) ) ||
( (pieces[28] == ':') && (lf->log += 31) ) ||
( (pieces[29] == ':') && (lf->log += 32) )
)
)
)
)
||
(   
(loglen > 21) &&
(isdigit(pieces[0])) &&
(pieces[4] == ' ') &&
(pieces[8] == ' ') &&
(pieces[11] == ' ') &&
(pieces[14] == ':') &&
(pieces[17] == ':') &&
(pieces[20] == ' ') && (lf->log += 21)
)
||
(
(loglen > 20) &&
(isdigit(pieces[0])) &&
(pieces[4] == ':') &&
(pieces[7] == ':') &&
(pieces[10] == '-') &&
(pieces[13] == ':') &&
(pieces[16] == ':') && (lf->log += 20)
)
) {
if (*lf->log == ' ') {
lf->log++;
}
pieces = lf->hostname = lf->log;
while (isValidChar(*pieces) == 1) {
pieces++;
}
if (*pieces == ':' && pieces[1] == ' ') {
lf->program_name = lf->hostname;
lf->hostname = NULL;
*pieces = '\0';
pieces += 2;
lf->log = pieces;
}
else if (*pieces != ' ') {
lf->hostname = NULL;
pieces = NULL;
} else {
*pieces = '\0';
pieces++;
lf->log = pieces;
lf->program_name = pieces;
while (isValidChar(*pieces) == 1) {
pieces++;
}
if ((*pieces == ':') && (pieces[1] == ' ')) {
*pieces = '\0';
pieces += 2;
}
else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {
*pieces = '\0';
pieces += 2;
while (isdigit((int)*pieces)) {
pieces++;
}
if ((*pieces == ']') && (pieces[1] == ':') && (pieces[2] == ' ')) {
pieces += 3;
}
else if ((*pieces == ']') && (pieces[1] == ' ')) {
pieces += 2;
} else {
pieces--;
while (isdigit((int)*pieces)) {
pieces--;
}
if (*pieces == '\0') {
*pieces = '[';
}
pieces = NULL;
lf->program_name = NULL;
}
}
else if ((*pieces == '|') && islower((int)pieces[1])) {
pieces += 2;
while (isalnum((int)*pieces)) {
pieces++;
}
if (*pieces == ':') {
pieces++;
while (isalnum((int)*pieces)) {
pieces++;
}
if (*pieces == ' ') {
pieces++;
lf->program_name = pieces;
while (isValidChar(*pieces) == 1) {
pieces++;
}
if ((*pieces == ':') && (pieces[1] == ' ')) {
*pieces = '\0';
pieces += 2;
}
else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {
*pieces = '\0';
pieces += 2;
while (isdigit((int)*pieces)) {
pieces++;
}
if ((*pieces == ']') && (pieces[1] == ':') &&
(pieces[2] == ' ')) {
pieces += 3;
} else {
pieces = NULL;
}
}
} else {
pieces = NULL;
lf->program_name = NULL;
}
}
else {
pieces = NULL;
lf->program_name = NULL;
}
} else {
pieces = NULL;
lf->program_name = NULL;
}
}
if (pieces) {
lf->log = pieces;
if ((pieces[0] == '[') &&
(pieces[1] == 'I') &&
(pieces[2] == 'D') &&
(pieces[3] == ' ')) {
pieces += 4;
pieces = strchr(pieces, ']');
if (pieces) {
pieces += 2;
lf->log = pieces;
}
}
}
if (lf->program_name) {
lf->p_name_size = strlen(lf->program_name);
}
}
else if ((loglen > 28) &&
(pieces[3] == ' ') &&
(pieces[7] == ' ') &&
(pieces[10] == ' ') &&
(pieces[13] == ':') &&
(pieces[16] == ':') &&
(pieces[19] == ' ') &&
(pieces[24] == ' ') &&
(pieces[26] == ' ')) {
lf->log += 24;
}
else if ( (loglen > 24) &&
(pieces[2] == '/') &&
(pieces[5] == '-') &&
(pieces[8] == ':') &&
(pieces[11] == ':') &&
(pieces[14] == '.') &&
(pieces[21] == ' ') ) {
lf->log += 23;
}
else if ( (loglen > 26) &&
(pieces[2] == '/') &&
(pieces[5] == '/') &&
(pieces[10] == '-') &&
(pieces[13] == ':') &&
(pieces[16] == ':') &&
(pieces[19] == '.') &&
(pieces[26] == ' ') ) {
lf->log += 28;
}
else if ( (loglen > 27) &&
(pieces[0] == '[') &&
(pieces[4] == ' ') &&
(pieces[8] == ' ') &&
(pieces[11] == ' ') &&
(pieces[14] == ':') &&
(pieces[17] == ':') &&
(pieces[20] == ' ') &&
(pieces[25] == ']') ) {
lf->log += 27;
}
else if ((loglen > 26) &&
(pieces[0] == '[')  &&
(pieces[1] == 'T')  &&
(pieces[5] == ' ')  &&
(pieces[10] == '.') &&
(pieces[13] == '.') &&
(pieces[16] == ' ') &&
(pieces[19] == ':')) {
short unsigned int done_message = 0;
lf->log += 25;
pieces = strchr(lf->log, '[');
while (pieces) {
pieces++;
if ((strncmp(pieces, ""Sender "", 7) == 0) &&
(lf->program_name == NULL)) {
pieces += 7;
lf->program_name = pieces;
pieces = strchr(pieces, ']');
if (pieces) {
*pieces = '\0';
lf->p_name_size = strlen(lf->program_name);
pieces++;
}
else {
lf->program_name = NULL;
break;
}
}
else if ((strncmp(pieces, ""Message "", 8) == 0) &&
(done_message == 0)) {
pieces += 8;
done_message = 1;
lf->log = pieces;
pieces = strchr(pieces, ']');
if (pieces) {
*pieces = '\0';
pieces++;
}
else {
break;
}
}
else if (strncmp(pieces, ""Host "", 5) == 0) {
pieces += 5;
lf->hostname = pieces;
pieces = strchr(pieces, ']');
if (pieces) {
*pieces = '\0';
pieces++;
}
else {
lf->hostname = NULL;
}
break;
}
pieces = strchr(pieces, '[');
}
}
else if ((loglen > 32) &&
(pieces[0] == '1') &&
(isdigit((int)pieces[1])) &&
(isdigit((int)pieces[2])) &&
(isdigit((int)pieces[3])) &&
(pieces[10] == '.') &&
(isdigit((int)pieces[13])) &&
(pieces[14] == ' ') &&
((pieces[21] == ' ') || (pieces[22] == ' '))) {
lf->log += 14;
while (*lf->log == ' ') {
lf->log++;
}
}
if (lf->location[0] == '(') {
lf->hostname = lf->location;
} else if (lf->hostname == NULL) {
lf->hostname = __shost;
}
lf->time = c_time;
p = localtime(&c_time);
lf->day = p->tm_mday;
lf->year = p->tm_year + 1900;
strncpy(lf->mon, month[p->tm_mon], 3);
snprintf(lf->hour, 9, ""%02d:%02d:%02d"",
p->tm_hour,
p->tm_min,
p->tm_sec);
__crt_hour = p->tm_hour;
__crt_wday = p->tm_wday;
#ifdef TESTRULE
if (!alert_only) {
print_out(""**Phase 1: Completed pre-decoding."");
print_out(""       full event: '%s'"", lf->full_log);
print_out(""       hostname: '%s'"", lf->hostname);
print_out(""       program_name: '%s'"", lf->program_name);
print_out(""       log: '%s'"", lf->log);
}
#endif
return (0);
}","int OS_CleanMSG(char *VAR_0, Eventinfo *VAR_1)
{
size_t VAR_2;
char *VAR_3;
struct tm *VAR_4;
VAR_0 += 2;
VAR_3 = strchr(VAR_0, ':');
if (!VAR_3) {
merror(VAR_5, VAR_6);
return (-1);
}
if ( *VAR_0 == '(' )
{   
VAR_3 = strchr(strstr(VAR_0, ""->""), ':');
if(!VAR_3)
{
merror(VAR_5, VAR_6);
return(-1);
}
}
*VAR_3 = '\0';
VAR_3++;
os_strdup(VAR_0, VAR_1->location);
VAR_2 = strlen(VAR_3) + 1;
os_malloc((2 * VAR_2) + 1, VAR_1->full_log);
strncpy(VAR_1->full_log, VAR_3, VAR_2);
VAR_1->log = VAR_1->full_log + VAR_2;
strncpy(VAR_1->log, VAR_3, VAR_2);
if (VAR_3[1] == (char) 195) {
if (VAR_3[2] == (char) 164) {
VAR_3[0] = '\0';
VAR_3[1] = 'M';
VAR_3[2] = 'a';
VAR_3++;
}
}
if (
(   
(VAR_2 > 17) &&
(VAR_3[3] == ' ') &&
(VAR_3[6] == ' ') &&
(VAR_3[9] == ':') &&
(VAR_3[12] == ':') &&
(VAR_3[15] == ' ') && (VAR_1->log += 16)
)
||
(   
(VAR_2 > 24) &&
(VAR_3[4] == '-') &&
(VAR_3[7] == '-') &&
(VAR_3[10] == ' ') &&
(VAR_3[13] == ':') &&
(VAR_3[16] == ':') &&
(VAR_3[19] == ',') &&
(VAR_1->log += 23)
)
||
(
(VAR_2 > 33) &&
(VAR_3[4] == '-') &&
(VAR_3[7] == '-') &&
(VAR_3[10] == 'T') &&
(VAR_3[13] == ':') &&
(VAR_3[16] == ':') &&
(   
(
(VAR_3[22] == ':') &&
(VAR_3[25] == ' ') && (VAR_1->log += 26)
)
||
(
(
(VAR_3[19] == '.') || (VAR_3[19] == ',')
)
&&
(
( (VAR_3[24] == ':') && (VAR_1->log += 27) ) ||
( (VAR_3[25] == ':') && (VAR_1->log += 28) ) ||
( (VAR_3[26] == ':') && (VAR_1->log += 29) ) ||
( (VAR_3[27] == ':') && (VAR_1->log += 30) ) ||
( (VAR_3[28] == ':') && (VAR_1->log += 31) ) ||
( (VAR_3[29] == ':') && (VAR_1->log += 32) )
)
)
)
)
||
(   
(VAR_2 > 21) &&
(isdigit(VAR_3[0])) &&
(VAR_3[4] == ' ') &&
(VAR_3[8] == ' ') &&
(VAR_3[11] == ' ') &&
(VAR_3[14] == ':') &&
(VAR_3[17] == ':') &&
(VAR_3[20] == ' ') && (VAR_1->log += 21)
)
||
(
(VAR_2 > 20) &&
(isdigit(VAR_3[0])) &&
(VAR_3[4] == ':') &&
(VAR_3[7] == ':') &&
(VAR_3[10] == '-') &&
(VAR_3[13] == ':') &&
(VAR_3[16] == ':') && (VAR_1->log += 20)
)
) {
if (*VAR_1->log == ' ') {
VAR_1->log++;
}
VAR_3 = VAR_1->hostname = VAR_1->log;
while (isValidChar(*VAR_3) == 1) {
VAR_3++;
}
if (*VAR_3 == ':' && VAR_3[1] == ' ') {
VAR_1->program_name = VAR_1->hostname;
VAR_1->hostname = NULL;
*VAR_3 = '\0';
VAR_3 += 2;
VAR_1->log = VAR_3;
}
else if (*VAR_3 != ' ') {
VAR_1->hostname = NULL;
VAR_3 = NULL;
} else {
*VAR_3 = '\0';
VAR_3++;
VAR_1->log = VAR_3;
VAR_1->program_name = VAR_3;
while (isValidChar(*VAR_3) == 1) {
VAR_3++;
}
if ((*VAR_3 == ':') && (VAR_3[1] == ' ')) {
*VAR_3 = '\0';
VAR_3 += 2;
}
else if ((*VAR_3 == '[') && (isdigit((int)VAR_3[1]))) {
*VAR_3 = '\0';
VAR_3 += 2;
while (isdigit((int)*VAR_3)) {
VAR_3++;
}
if ((*VAR_3 == ']') && (VAR_3[1] == ':') && (VAR_3[2] == ' ')) {
VAR_3 += 3;
}
else if ((*VAR_3 == ']') && (VAR_3[1] == ' ')) {
VAR_3 += 2;
} else {
VAR_3--;
while (isdigit((int)*VAR_3)) {
VAR_3--;
}
if (*VAR_3 == '\0') {
*VAR_3 = '[';
}
VAR_3 = NULL;
VAR_1->program_name = NULL;
}
}
else if ((*VAR_3 == '|') && islower((int)VAR_3[1])) {
VAR_3 += 2;
while (isalnum((int)*VAR_3)) {
VAR_3++;
}
if (*VAR_3 == ':') {
VAR_3++;
while (isalnum((int)*VAR_3)) {
VAR_3++;
}
if (*VAR_3 == ' ') {
VAR_3++;
VAR_1->program_name = VAR_3;
while (isValidChar(*VAR_3) == 1) {
VAR_3++;
}
if ((*VAR_3 == ':') && (VAR_3[1] == ' ')) {
*VAR_3 = '\0';
VAR_3 += 2;
}
else if ((*VAR_3 == '[') && (isdigit((int)VAR_3[1]))) {
*VAR_3 = '\0';
VAR_3 += 2;
while (isdigit((int)*VAR_3)) {
VAR_3++;
}
if ((*VAR_3 == ']') && (VAR_3[1] == ':') &&
(VAR_3[2] == ' ')) {
VAR_3 += 3;
} else {
VAR_3 = NULL;
}
}
} else {
VAR_3 = NULL;
VAR_1->program_name = NULL;
}
}
else {
VAR_3 = NULL;
VAR_1->program_name = NULL;
}
} else {
VAR_3 = NULL;
VAR_1->program_name = NULL;
}
}
if (VAR_3) {
VAR_1->log = VAR_3;
if ((VAR_3[0] == '[') &&
(VAR_3[1] == 'I') &&
(VAR_3[2] == 'D') &&
(VAR_3[3] == ' ')) {
VAR_3 += 4;
VAR_3 = strchr(VAR_3, ']');
if (VAR_3) {
VAR_3 += 2;
VAR_1->log = VAR_3;
}
}
}
if (VAR_1->program_name) {
VAR_1->p_name_size = strlen(VAR_1->program_name);
}
}
else if ((VAR_2 > 28) &&
(VAR_3[3] == ' ') &&
(VAR_3[7] == ' ') &&
(VAR_3[10] == ' ') &&
(VAR_3[13] == ':') &&
(VAR_3[16] == ':') &&
(VAR_3[19] == ' ') &&
(VAR_3[24] == ' ') &&
(VAR_3[26] == ' ')) {
VAR_1->log += 24;
}
else if ( (VAR_2 > 24) &&
(VAR_3[2] == '/') &&
(VAR_3[5] == '-') &&
(VAR_3[8] == ':') &&
(VAR_3[11] == ':') &&
(VAR_3[14] == '.') &&
(VAR_3[21] == ' ') ) {
VAR_1->log += 23;
}
else if ( (VAR_2 > 26) &&
(VAR_3[2] == '/') &&
(VAR_3[5] == '/') &&
(VAR_3[10] == '-') &&
(VAR_3[13] == ':') &&
(VAR_3[16] == ':') &&
(VAR_3[19] == '.') &&
(VAR_3[26] == ' ') ) {
VAR_1->log += 28;
}
else if ( (VAR_2 > 27) &&
(VAR_3[0] == '[') &&
(VAR_3[4] == ' ') &&
(VAR_3[8] == ' ') &&
(VAR_3[11] == ' ') &&
(VAR_3[14] == ':') &&
(VAR_3[17] == ':') &&
(VAR_3[20] == ' ') &&
(VAR_3[25] == ']') ) {
VAR_1->log += 27;
}
else if ((VAR_2 > 26) &&
(VAR_3[0] == '[')  &&
(VAR_3[1] == 'T')  &&
(VAR_3[5] == ' ')  &&
(VAR_3[10] == '.') &&
(VAR_3[13] == '.') &&
(VAR_3[16] == ' ') &&
(VAR_3[19] == ':')) {
short unsigned int VAR_7 = 0;
VAR_1->log += 25;
VAR_3 = strchr(VAR_1->log, '[');
while (VAR_3) {
VAR_3++;
if ((strncmp(VAR_3, ""Sender "", 7) == 0) &&
(VAR_1->program_name == NULL)) {
VAR_3 += 7;
VAR_1->program_name = VAR_3;
VAR_3 = strchr(VAR_3, ']');
if (VAR_3) {
*VAR_3 = '\0';
VAR_1->p_name_size = strlen(VAR_1->program_name);
VAR_3++;
}
else {
VAR_1->program_name = NULL;
break;
}
}
else if ((strncmp(VAR_3, ""Message "", 8) == 0) &&
(VAR_7 == 0)) {
VAR_3 += 8;
VAR_7 = 1;
VAR_1->log = VAR_3;
VAR_3 = strchr(VAR_3, ']');
if (VAR_3) {
*VAR_3 = '\0';
VAR_3++;
}
else {
break;
}
}
else if (strncmp(VAR_3, ""Host "", 5) == 0) {
VAR_3 += 5;
VAR_1->hostname = VAR_3;
VAR_3 = strchr(VAR_3, ']');
if (VAR_3) {
*VAR_3 = '\0';
VAR_3++;
}
else {
VAR_1->hostname = NULL;
}
break;
}
VAR_3 = strchr(VAR_3, '[');
}
}
else if ((VAR_2 > 32) &&
(VAR_3[0] == '1') &&
(isdigit((int)VAR_3[1])) &&
(isdigit((int)VAR_3[2])) &&
(isdigit((int)VAR_3[3])) &&
(VAR_3[10] == '.') &&
(isdigit((int)VAR_3[13])) &&
(VAR_3[14] == ' ') &&
((VAR_3[21] == ' ') || (VAR_3[22] == ' '))) {
VAR_1->log += 14;
while (*VAR_1->log == ' ') {
VAR_1->log++;
}
}
if (VAR_1->location[0] == '(') {
VAR_1->hostname = VAR_1->location;
} else if (VAR_1->hostname == NULL) {
VAR_1->hostname = VAR_8;
}
VAR_1->time = VAR_9;
VAR_4 = localtime(&VAR_9);
VAR_1->day = VAR_4->tm_mday;
VAR_1->year = VAR_4->tm_year + 1900;
strncpy(VAR_1->mon, VAR_10[VAR_4->tm_mon], 3);
snprintf(VAR_1->hour, 9, ""%02d:%02d:%02d"",
VAR_4->tm_hour,
VAR_4->tm_min,
VAR_4->tm_sec);
VAR_11 = VAR_4->tm_hour;
VAR_12 = VAR_4->tm_wday;
#ifdef VAR_13
if (!VAR_14) {
print_out(""**Phase 1: Completed pre-decoding."");
print_out(""       full event: '%s'"", VAR_1->full_log);
print_out(""       hostname: '%s'"", VAR_1->hostname);
print_out(""       program_name: '%s'"", VAR_1->program_name);
print_out(""       log: '%s'"", VAR_1->log);
}
#endif
return (0);
}",ossec/ossec-hids/9b8b14c88188cdc66ab25f92a26918d0cb8a7760/cleanevent.c/vul/before/0.json,"int OS_CleanMSG(char *msg, Eventinfo *lf)
{
    size_t loglen;
    char *pieces;
    struct tm *p;

    /* The message is formatted in the following way:
     * id:location:message.
     */

    /* Ignore the id of the message in here */
    msg += 2;

    /* Set pieces as the message */
    pieces = strchr(msg, ':');
    if (!pieces) {
        merror(FORMAT_ERROR, ARGV0);
        return (-1);
    }

    /* Is this from an agent? */
    if ( *msg == '(' )
    {   /* look past '->' for the first ':' */
        pieces = strstr(msg, ""->"");
        if(!pieces) {
            merror(FORMAT_ERROR, ARGV0);
            return(-1);
        }
        pieces = strchr(pieces, ':');
        if(!pieces)
        {
            merror(FORMAT_ERROR, ARGV0);
            return(-1);
        }
    }

    *pieces = '\0';
    pieces++;

    os_strdup(msg, lf->location);

    /* Get the log length */
    loglen = strlen(pieces) + 1;

    /* Assign the values in the structure (lf->full_log) */
    os_malloc((2 * loglen) + 1, lf->full_log);

    /* Set the whole message at full_log */
    strncpy(lf->full_log, pieces, loglen);

    /* Log is the one used for parsing in the decoders and rules */
    lf->log = lf->full_log + loglen;
    strncpy(lf->log, pieces, loglen);

    /* check if month contains an umlaut and repair
     * umlauts are non-ASCII and use 2 slots in the char array
     * repair to only one slot so we can detect the correct date format in the next step
     * ex: Mr 02 17:30:52
     */
    if (pieces[1] == (char) 195) {
        if (pieces[2] == (char) 164) {
            pieces[0] = '\0';
            pieces[1] = 'M';
            pieces[2] = 'a';
            pieces++;
        }
    }

    /* Check for the syslog date format
     * ( ex: Dec 29 10:00:01
     *   or  2015-04-16 21:51:02,805 for proftpd 1.3.5
     *   or  2007-06-14T15:48:55-04:00 for syslog-ng isodate
     *   or  2007-06-14T15:48:55.3352-04:00 for syslog-ng isodate with up to 6 optional fraction of a second
     *   or  2009-05-22T09:36:46.214994-07:00 for rsyslog
     *   or  2015 Dec 29 10:00:01 )
     */
    if (
        (   /* ex: Dec 29 10:00:01 */
            (loglen > 17) &&
            (pieces[3] == ' ') &&
            (pieces[6] == ' ') &&
            (pieces[9] == ':') &&
            (pieces[12] == ':') &&
            (pieces[15] == ' ') && (lf->log += 16)
        )
        ||
        (   /* ex: 2015-04-16 21:51:02,805 */
            (loglen > 24) &&
            (pieces[4] == '-') &&
            (pieces[7] == '-') &&
            (pieces[10] == ' ') &&
            (pieces[13] == ':') &&
            (pieces[16] == ':') &&
            (pieces[19] == ',') &&
            (lf->log += 23)
        )
        ||
        (
            (loglen > 33) &&
            (pieces[4] == '-') &&
            (pieces[7] == '-') &&
            (pieces[10] == 'T') &&
            (pieces[13] == ':') &&
            (pieces[16] == ':') &&
            (   /* ex: 2007-06-14T15:48:55-04:00 */
                (
                    (pieces[22] == ':') &&
                    (pieces[25] == ' ') && (lf->log += 26)
                )
                ||
                /* ex: 2007-06-14T15:48:55.3-04:00 or 2009-05-22T09:36:46,214994-07:00 */
                (
                    (
                        (pieces[19] == '.') || (pieces[19] == ',')
                    )
                    &&
                    (
                        ( (pieces[24] == ':') && (lf->log += 27) ) ||
                        ( (pieces[25] == ':') && (lf->log += 28) ) ||
                        ( (pieces[26] == ':') && (lf->log += 29) ) ||
                        ( (pieces[27] == ':') && (lf->log += 30) ) ||
                        ( (pieces[28] == ':') && (lf->log += 31) ) ||
                        ( (pieces[29] == ':') && (lf->log += 32) )
                    )
                )
            )
        )
        ||
        (   /* ex: 2015 Dec 29 10:00:01 */
            (loglen > 21) &&
            (isdigit(pieces[0])) &&
            (pieces[4] == ' ') &&
            (pieces[8] == ' ') &&
            (pieces[11] == ' ') &&
            (pieces[14] == ':') &&
            (pieces[17] == ':') &&
            (pieces[20] == ' ') && (lf->log += 21)
        )
        ||
        (
            /* ex: 2019:11:06-00:08:03 */
            (loglen > 20) &&
            (isdigit(pieces[0])) &&
            (pieces[4] == ':') &&
            (pieces[7] == ':') &&
            (pieces[10] == '-') &&
            (pieces[13] == ':') &&
            (pieces[16] == ':') && (lf->log += 20)
        )
    ) {
        /* Check for an extra space in here */
        if (*lf->log == ' ') {
            lf->log++;
        }


        /* Hostname */
        pieces = lf->hostname = lf->log;


        /* Check for a valid hostname */
        while (isValidChar(*pieces) == 1) {
            pieces++;
        }

        /* Check if it is a syslog without hostname (common on Solaris) */
        if (*pieces == ':' && pieces[1] == ' ') {
            /* Getting solaris 8/9 messages without hostname.
             * In these cases, the process_name should be there.
             * http://www.ossec.net/wiki/index.php/Log_Samples_Solaris
             */
            lf->program_name = lf->hostname;
            lf->hostname = NULL;

            /* End the program name string */
            *pieces = '\0';

            pieces += 2;
            lf->log = pieces;
        }

        /* Extract the hostname */
        else if (*pieces != ' ') {
            /* Invalid hostname */
            lf->hostname = NULL;
            pieces = NULL;
        } else {
            /* End the hostname string */
            *pieces = '\0';

            /* Move pieces to the beginning of the log message */
            pieces++;
            lf->log = pieces;

            /* Get program_name */
            lf->program_name = pieces;

            /* Extract program_name */
            /* Valid names:
             * p_name:
             * p_name[pid]:
             * p_name[pid]: [ID xx facility.severity]
             * auth|security:info p_name:
             */
            while (isValidChar(*pieces) == 1) {
                pieces++;
            }

            /* Check for the first format: p_name: */
            if ((*pieces == ':') && (pieces[1] == ' ')) {
                *pieces = '\0';
                pieces += 2;
            }

            /* Check for the second format: p_name[pid]: */
            else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {
                *pieces = '\0';
                pieces += 2;
                while (isdigit((int)*pieces)) {
                    pieces++;
                }

                if ((*pieces == ']') && (pieces[1] == ':') && (pieces[2] == ' ')) {
                    pieces += 3;
                }
                /* Some systems are not terminating the program name with
                 * a ':'. Working around this in here...
                 */
                else if ((*pieces == ']') && (pieces[1] == ' ')) {
                    pieces += 2;
                } else {
                    /* Fix for some weird log formats */
                    pieces--;
                    while (isdigit((int)*pieces)) {
                        pieces--;
                    }

                    if (*pieces == '\0') {
                        *pieces = '[';
                    }
                    pieces = NULL;
                    lf->program_name = NULL;
                }
            }
            /* AIX syslog */
            else if ((*pieces == '|') && islower((int)pieces[1])) {
                pieces += 2;

                /* Remove facility */
                while (isalnum((int)*pieces)) {
                    pieces++;
                }

                if (*pieces == ':') {
                    /* Remove severity */
                    pieces++;
                    while (isalnum((int)*pieces)) {
                        pieces++;
                    }

                    if (*pieces == ' ') {
                        pieces++;
                        lf->program_name = pieces;


                        /* Get program name again */
                        while (isValidChar(*pieces) == 1) {
                            pieces++;
                        }

                        /* Check for the first format: p_name: */
                        if ((*pieces == ':') && (pieces[1] == ' ')) {
                            *pieces = '\0';
                            pieces += 2;
                        }

                        /* Check for the second format: p_name[pid]: */
                        else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {
                            *pieces = '\0';
                            pieces += 2;
                            while (isdigit((int)*pieces)) {
                                pieces++;
                            }

                            if ((*pieces == ']') && (pieces[1] == ':') &&
                                    (pieces[2] == ' ')) {
                                pieces += 3;
                            } else {
                                pieces = NULL;
                            }
                        }
                    } else {
                        pieces = NULL;
                        lf->program_name = NULL;
                    }
                }
                /* Invalid AIX */
                else {
                    pieces = NULL;
                    lf->program_name = NULL;
                }
            } else {
                pieces = NULL;
                lf->program_name = NULL;
            }
        }

        /* Remove [ID xx facility.severity] */
        if (pieces) {
            /* Set log after program name */
            lf->log = pieces;

            if ((pieces[0] == '[') &&
                    (pieces[1] == 'I') &&
                    (pieces[2] == 'D') &&
                    (pieces[3] == ' ')) {
                pieces += 4;

                /* Going after the ] */
                pieces = strchr(pieces, ']');
                if (pieces) {
                    pieces += 2;
                    lf->log = pieces;
                }
            }
        }

        /* Get program name size */
        if (lf->program_name) {
            lf->p_name_size = strlen(lf->program_name);
        }
    }

    /* xferlog date format
     * Mon Apr 17 18:27:14 2006 1 64.160.42.130
     */
    else if ((loglen > 28) &&
             (pieces[3] == ' ') &&
             (pieces[7] == ' ') &&
             (pieces[10] == ' ') &&
             (pieces[13] == ':') &&
             (pieces[16] == ':') &&
             (pieces[19] == ' ') &&
             (pieces[24] == ' ') &&
             (pieces[26] == ' ')) {
        /* Move log to the beginning of the message */
        lf->log += 24;
    }

    /* Check for snort date format
     * ex: 01/28-09:13:16.240702  [**]
     */
    else if ( (loglen > 24) &&
              (pieces[2] == '/') &&
              (pieces[5] == '-') &&
              (pieces[8] == ':') &&
              (pieces[11] == ':') &&
              (pieces[14] == '.') &&
              (pieces[21] == ' ') ) {
        lf->log += 23;
    }

    /* Check for suricata (new) date format
     * ex: 01/28/1979-09:13:16.240702  [**]
     */
    else if ( (loglen > 26) &&
              (pieces[2] == '/') &&
              (pieces[5] == '/') &&
              (pieces[10] == '-') &&
              (pieces[13] == ':') &&
              (pieces[16] == ':') &&
              (pieces[19] == '.') &&
              (pieces[26] == ' ') ) {
        lf->log += 28;
    }


    /* Check for apache log format */
    /* [Fri Feb 11 18:06:35 2004] [warn] */
    else if ( (loglen > 27) &&
              (pieces[0] == '[') &&
              (pieces[4] == ' ') &&
              (pieces[8] == ' ') &&
              (pieces[11] == ' ') &&
              (pieces[14] == ':') &&
              (pieces[17] == ':') &&
              (pieces[20] == ' ') &&
              (pieces[25] == ']') ) {
        lf->log += 27;
    }

    /* Check for the osx asl log format.
     * Examples:
     * [Time 2006.12.28 15:53:55 UTC] [Facility auth] [Sender sshd] [PID 483] [Message error: PAM: Authentication failure for username from 192.168.0.2] [Level 3] [UID -2] [GID -2] [Host Hostname]
     * [Time 2006.11.02 14:02:11 UTC] [Facility auth] [Sender sshd] [PID 856]
     [Message refused connect from 59.124.44.34] [Level 4] [UID -2] [GID -2]
     [Host robert-wyatts-emac]
     */
    else if ((loglen > 26) &&
             (pieces[0] == '[')  &&
             (pieces[1] == 'T')  &&
             (pieces[5] == ' ')  &&
             (pieces[10] == '.') &&
             (pieces[13] == '.') &&
             (pieces[16] == ' ') &&
             (pieces[19] == ':')) {
        /* Do not read more than 1 message entry -> log tampering */
        short unsigned int done_message = 0;

        /* Remove the date */
        lf->log += 25;

        /* Get the desired values */
        pieces = strchr(lf->log, '[');
        while (pieces) {
            pieces++;

            /* Get the sender (set to program name) */
            if ((strncmp(pieces, ""Sender "", 7) == 0) &&
                    (lf->program_name == NULL)) {
                pieces += 7;
                lf->program_name = pieces;

                /* Get the closing brackets */
                pieces = strchr(pieces, ']');
                if (pieces) {
                    *pieces = '\0';

                    /* Set program_name size */
                    lf->p_name_size = strlen(lf->program_name);

                    pieces++;
                }
                /* Invalid program name */
                else {
                    lf->program_name = NULL;
                    break;
                }
            }

            /* Get message */
            else if ((strncmp(pieces, ""Message "", 8) == 0) &&
                     (done_message == 0)) {
                pieces += 8;
                done_message = 1;

                lf->log = pieces;

                /* Get the closing brackets */
                pieces = strchr(pieces, ']');
                if (pieces) {
                    *pieces = '\0';
                    pieces++;
                }
                /* Invalid log closure */
                else {
                    break;
                }
            }

            /* Get hostname */
            else if (strncmp(pieces, ""Host "", 5) == 0) {
                pieces += 5;
                lf->hostname = pieces;

                /* Get the closing brackets */
                pieces = strchr(pieces, ']');
                if (pieces) {
                    *pieces = '\0';
                    pieces++;
                }

                /* Invalid hostname */
                else {
                    lf->hostname = NULL;
                }
                break;
            }

            /* Get next entry */
            pieces = strchr(pieces, '[');
        }
    }

    /* Check for squid date format
     * 1140804070.368  11623
     * seconds from 00:00:00 1970-01-01 UTC
     */
    else if ((loglen > 32) &&
             (pieces[0] == '1') &&
             (isdigit((int)pieces[1])) &&
             (isdigit((int)pieces[2])) &&
             (isdigit((int)pieces[3])) &&
             (pieces[10] == '.') &&
             (isdigit((int)pieces[13])) &&
             (pieces[14] == ' ') &&
             ((pieces[21] == ' ') || (pieces[22] == ' '))) {
        lf->log += 14;

        /* We need to start at the size of the event */
        while (*lf->log == ' ') {
            lf->log++;
        }
    }

    /* Every message must be in the format
     * hostname->location or
     * (agent) ip->location.
     */

    /* Set hostname for local messages */
    if (lf->location[0] == '(') {
        /* Messages from an agent */
        lf->hostname = lf->location;
    } else if (lf->hostname == NULL) {
        lf->hostname = __shost;
    }

    /* Set up the event data */
    lf->time = c_time;
    p = localtime(&c_time);

    /* Assign hour, day, year and month values */
    lf->day = p->tm_mday;
    lf->year = p->tm_year + 1900;
    strncpy(lf->mon, month[p->tm_mon], 3);
    snprintf(lf->hour, 9, ""%02d:%02d:%02d"",
             p->tm_hour,
             p->tm_min,
             p->tm_sec);

    /* Set the global hour/weekday */
    __crt_hour = p->tm_hour;
    __crt_wday = p->tm_wday;

#ifdef TESTRULE
    if (!alert_only) {
        print_out(""**Phase 1: Completed pre-decoding."");
        print_out(""       full event: '%s'"", lf->full_log);
        print_out(""       hostname: '%s'"", lf->hostname);
        print_out(""       program_name: '%s'"", lf->program_name);
        print_out(""       log: '%s'"", lf->log);
    }
#endif
    return (0);
}","int OS_CleanMSG(char *VAR_0, Eventinfo *VAR_1)
{
    size_t VAR_2;
    char *VAR_3;
    struct tm *VAR_4;

    /* COMMENT_0 */
                           
       

    /* COMMENT_3 */
    VAR_0 += 2;

    /* COMMENT_4 */
    VAR_3 = strchr(VAR_0, ':');
    if (!VAR_3) {
        merror(VAR_5, VAR_6);
        return (-1);
    }

    /* COMMENT_5 */
    if ( *VAR_0 == '(' )
    {   /* COMMENT_6 */
        VAR_3 = strstr(VAR_0, ""->"");
        if(!VAR_3) {
            merror(VAR_5, VAR_6);
            return(-1);
        }
        VAR_3 = strchr(VAR_3, ':');
        if(!VAR_3)
        {
            merror(VAR_5, VAR_6);
            return(-1);
        }
    }

    *VAR_3 = '\0';
    VAR_3++;

    os_strdup(VAR_0, VAR_1->location);

    /* COMMENT_7 */
    VAR_2 = strlen(VAR_3) + 1;

    /* COMMENT_8 */
    os_malloc((2 * VAR_2) + 1, VAR_1->full_log);

    /* COMMENT_9 */
    strncpy(VAR_1->full_log, VAR_3, VAR_2);

    /* COMMENT_10 */
    VAR_1->log = VAR_1->full_log + VAR_2;
    strncpy(VAR_1->log, VAR_3, VAR_2);

    /* COMMENT_11 */
                                                              
                                                                                        
                          
       
    if (VAR_3[1] == (char) 195) {
        if (VAR_3[2] == (char) 164) {
            VAR_3[0] = '\0';
            VAR_3[1] = 'M';
            VAR_3[2] = 'a';
            VAR_3++;
        }
    }

    /* COMMENT_16 */
                            
                                                      
                                                            
                                                                                                            
                                                         
                                   
       
    if (
        (   /* COMMENT_24 */
            (VAR_2 > 17) &&
            (VAR_3[3] == ' ') &&
            (VAR_3[6] == ' ') &&
            (VAR_3[9] == ':') &&
            (VAR_3[12] == ':') &&
            (VAR_3[15] == ' ') && (VAR_1->log += 16)
        )
        ||
        (   /* COMMENT_25 */
            (VAR_2 > 24) &&
            (VAR_3[4] == '-') &&
            (VAR_3[7] == '-') &&
            (VAR_3[10] == ' ') &&
            (VAR_3[13] == ':') &&
            (VAR_3[16] == ':') &&
            (VAR_3[19] == ',') &&
            (VAR_1->log += 23)
        )
        ||
        (
            (VAR_2 > 33) &&
            (VAR_3[4] == '-') &&
            (VAR_3[7] == '-') &&
            (VAR_3[10] == 'T') &&
            (VAR_3[13] == ':') &&
            (VAR_3[16] == ':') &&
            (   /* COMMENT_26 */
                (
                    (VAR_3[22] == ':') &&
                    (VAR_3[25] == ' ') && (VAR_1->log += 26)
                )
                ||
                /* COMMENT_27 */
                (
                    (
                        (VAR_3[19] == '.') || (VAR_3[19] == ',')
                    )
                    &&
                    (
                        ( (VAR_3[24] == ':') && (VAR_1->log += 27) ) ||
                        ( (VAR_3[25] == ':') && (VAR_1->log += 28) ) ||
                        ( (VAR_3[26] == ':') && (VAR_1->log += 29) ) ||
                        ( (VAR_3[27] == ':') && (VAR_1->log += 30) ) ||
                        ( (VAR_3[28] == ':') && (VAR_1->log += 31) ) ||
                        ( (VAR_3[29] == ':') && (VAR_1->log += 32) )
                    )
                )
            )
        )
        ||
        (   /* COMMENT_28 */
            (VAR_2 > 21) &&
            (isdigit(VAR_3[0])) &&
            (VAR_3[4] == ' ') &&
            (VAR_3[8] == ' ') &&
            (VAR_3[11] == ' ') &&
            (VAR_3[14] == ':') &&
            (VAR_3[17] == ':') &&
            (VAR_3[20] == ' ') && (VAR_1->log += 21)
        )
        ||
        (
            /* COMMENT_29 */
            (VAR_2 > 20) &&
            (isdigit(VAR_3[0])) &&
            (VAR_3[4] == ':') &&
            (VAR_3[7] == ':') &&
            (VAR_3[10] == '-') &&
            (VAR_3[13] == ':') &&
            (VAR_3[16] == ':') && (VAR_1->log += 20)
        )
    ) {
        /* COMMENT_30 */
        if (*VAR_1->log == ' ') {
            VAR_1->log++;
        }


        /* COMMENT_31 */
        VAR_3 = VAR_1->hostname = VAR_1->log;


        /* COMMENT_32 */
        while (isValidChar(*VAR_3) == 1) {
            VAR_3++;
        }

        /* COMMENT_33 */
        if (*VAR_3 == ':' && VAR_3[1] == ' ') {
            /* COMMENT_34 */
                                                                
                                                                      
               
            VAR_1->program_name = VAR_1->hostname;
            VAR_1->hostname = NULL;

            /* COMMENT_38 */
            *VAR_3 = '\0';

            VAR_3 += 2;
            VAR_1->log = VAR_3;
        }

        /* COMMENT_39 */
        else if (*VAR_3 != ' ') {
            /* COMMENT_40 */
            VAR_1->hostname = NULL;
            VAR_3 = NULL;
        } else {
            /* COMMENT_41 */
            *VAR_3 = '\0';

            /* COMMENT_42 */
            VAR_3++;
            VAR_1->log = VAR_3;

            /* COMMENT_43 */
            VAR_1->program_name = VAR_3;

            /* COMMENT_44 */
            /* COMMENT_45 */
                      
                           
                                                     
                                         
               
            while (isValidChar(*VAR_3) == 1) {
                VAR_3++;
            }

            /* COMMENT_51 */
            if ((*VAR_3 == ':') && (VAR_3[1] == ' ')) {
                *VAR_3 = '\0';
                VAR_3 += 2;
            }

            /* COMMENT_52 */
            else if ((*VAR_3 == '[') && (isdigit((int)VAR_3[1]))) {
                *VAR_3 = '\0';
                VAR_3 += 2;
                while (isdigit((int)*VAR_3)) {
                    VAR_3++;
                }

                if ((*VAR_3 == ']') && (VAR_3[1] == ':') && (VAR_3[2] == ' ')) {
                    VAR_3 += 3;
                }
                /* COMMENT_53 */
                                                        
                   
                else if ((*VAR_3 == ']') && (VAR_3[1] == ' ')) {
                    VAR_3 += 2;
                } else {
                    /* COMMENT_56 */
                    VAR_3--;
                    while (isdigit((int)*VAR_3)) {
                        VAR_3--;
                    }

                    if (*VAR_3 == '\0') {
                        *VAR_3 = '[';
                    }
                    VAR_3 = NULL;
                    VAR_1->program_name = NULL;
                }
            }
            /* COMMENT_57 */
            else if ((*VAR_3 == '|') && islower((int)VAR_3[1])) {
                VAR_3 += 2;

                /* COMMENT_58 */
                while (isalnum((int)*VAR_3)) {
                    VAR_3++;
                }

                if (*VAR_3 == ':') {
                    /* COMMENT_59 */
                    VAR_3++;
                    while (isalnum((int)*VAR_3)) {
                        VAR_3++;
                    }

                    if (*VAR_3 == ' ') {
                        VAR_3++;
                        VAR_1->program_name = VAR_3;


                        /* COMMENT_60 */
                        while (isValidChar(*VAR_3) == 1) {
                            VAR_3++;
                        }

                        /* COMMENT_51 */
                        if ((*VAR_3 == ':') && (VAR_3[1] == ' ')) {
                            *VAR_3 = '\0';
                            VAR_3 += 2;
                        }

                        /* COMMENT_52 */
                        else if ((*VAR_3 == '[') && (isdigit((int)VAR_3[1]))) {
                            *VAR_3 = '\0';
                            VAR_3 += 2;
                            while (isdigit((int)*VAR_3)) {
                                VAR_3++;
                            }

                            if ((*VAR_3 == ']') && (VAR_3[1] == ':') &&
                                    (VAR_3[2] == ' ')) {
                                VAR_3 += 3;
                            } else {
                                VAR_3 = NULL;
                            }
                        }
                    } else {
                        VAR_3 = NULL;
                        VAR_1->program_name = NULL;
                    }
                }
                /* COMMENT_61 */
                else {
                    VAR_3 = NULL;
                    VAR_1->program_name = NULL;
                }
            } else {
                VAR_3 = NULL;
                VAR_1->program_name = NULL;
            }
        }

        /* COMMENT_62 */
        if (VAR_3) {
            /* COMMENT_63 */
            VAR_1->log = VAR_3;

            if ((VAR_3[0] == '[') &&
                    (VAR_3[1] == 'I') &&
                    (VAR_3[2] == 'D') &&
                    (VAR_3[3] == ' ')) {
                VAR_3 += 4;

                /* COMMENT_64 */
                VAR_3 = strchr(VAR_3, ']');
                if (VAR_3) {
                    VAR_3 += 2;
                    VAR_1->log = VAR_3;
                }
            }
        }

        /* COMMENT_65 */
        if (VAR_1->program_name) {
            VAR_1->p_name_size = strlen(VAR_1->program_name);
        }
    }

    /* COMMENT_66 */
                                               
       
    else if ((VAR_2 > 28) &&
             (VAR_3[3] == ' ') &&
             (VAR_3[7] == ' ') &&
             (VAR_3[10] == ' ') &&
             (VAR_3[13] == ':') &&
             (VAR_3[16] == ':') &&
             (VAR_3[19] == ' ') &&
             (VAR_3[24] == ' ') &&
             (VAR_3[26] == ' ')) {
        /* COMMENT_69 */
        VAR_1->log += 24;
    }

    /* COMMENT_70 */
                                      
       
    else if ( (VAR_2 > 24) &&
              (VAR_3[2] == '/') &&
              (VAR_3[5] == '-') &&
              (VAR_3[8] == ':') &&
              (VAR_3[11] == ':') &&
              (VAR_3[14] == '.') &&
              (VAR_3[21] == ' ') ) {
        VAR_1->log += 23;
    }

    /* COMMENT_73 */
                                           
       
    else if ( (VAR_2 > 26) &&
              (VAR_3[2] == '/') &&
              (VAR_3[5] == '/') &&
              (VAR_3[10] == '-') &&
              (VAR_3[13] == ':') &&
              (VAR_3[16] == ':') &&
              (VAR_3[19] == '.') &&
              (VAR_3[26] == ' ') ) {
        VAR_1->log += 28;
    }


    /* COMMENT_76 */
    /* COMMENT_77 */
    else if ( (VAR_2 > 27) &&
              (VAR_3[0] == '[') &&
              (VAR_3[4] == ' ') &&
              (VAR_3[8] == ' ') &&
              (VAR_3[11] == ' ') &&
              (VAR_3[14] == ':') &&
              (VAR_3[17] == ':') &&
              (VAR_3[20] == ' ') &&
              (VAR_3[25] == ']') ) {
        VAR_1->log += 27;
    }

    /* COMMENT_78 */
                
                                                                                                                                                                                                    
                                                                             
                                                                            
                              
       
    else if ((VAR_2 > 26) &&
             (VAR_3[0] == '[')  &&
             (VAR_3[1] == 'T')  &&
             (VAR_3[5] == ' ')  &&
             (VAR_3[10] == '.') &&
             (VAR_3[13] == '.') &&
             (VAR_3[16] == ' ') &&
             (VAR_3[19] == ':')) {
        /* COMMENT_85 */
        short unsigned int VAR_7 = 0;

        /* COMMENT_86 */
        VAR_1->log += 25;

        /* COMMENT_87 */
        VAR_3 = strchr(VAR_1->log, '[');
        while (VAR_3) {
            VAR_3++;

            /* COMMENT_88 */
            if ((strncmp(VAR_3, ""Sender "", 7) == 0) &&
                    (VAR_1->program_name == NULL)) {
                VAR_3 += 7;
                VAR_1->program_name = VAR_3;

                /* COMMENT_89 */
                VAR_3 = strchr(VAR_3, ']');
                if (VAR_3) {
                    *VAR_3 = '\0';

                    /* COMMENT_90 */
                    VAR_1->p_name_size = strlen(VAR_1->program_name);

                    VAR_3++;
                }
                /* COMMENT_91 */
                else {
                    VAR_1->program_name = NULL;
                    break;
                }
            }

            /* COMMENT_92 */
            else if ((strncmp(VAR_3, ""Message "", 8) == 0) &&
                     (VAR_7 == 0)) {
                VAR_3 += 8;
                VAR_7 = 1;

                VAR_1->log = VAR_3;

                /* COMMENT_89 */
                VAR_3 = strchr(VAR_3, ']');
                if (VAR_3) {
                    *VAR_3 = '\0';
                    VAR_3++;
                }
                /* COMMENT_93 */
                else {
                    break;
                }
            }

            /* COMMENT_94 */
            else if (strncmp(VAR_3, ""Host "", 5) == 0) {
                VAR_3 += 5;
                VAR_1->hostname = VAR_3;

                /* COMMENT_89 */
                VAR_3 = strchr(VAR_3, ']');
                if (VAR_3) {
                    *VAR_3 = '\0';
                    VAR_3++;
                }

                /* COMMENT_40 */
                else {
                    VAR_1->hostname = NULL;
                }
                break;
            }

            /* COMMENT_95 */
            VAR_3 = strchr(VAR_3, '[');
        }
    }

    /* COMMENT_96 */
                            
                                           
       
    else if ((VAR_2 > 32) &&
             (VAR_3[0] == '1') &&
             (isdigit((int)VAR_3[1])) &&
             (isdigit((int)VAR_3[2])) &&
             (isdigit((int)VAR_3[3])) &&
             (VAR_3[10] == '.') &&
             (isdigit((int)VAR_3[13])) &&
             (VAR_3[14] == ' ') &&
             ((VAR_3[21] == ' ') || (VAR_3[22] == ' '))) {
        VAR_1->log += 14;

        /* COMMENT_100 */
        while (*VAR_1->log == ' ') {
            VAR_1->log++;
        }
    }

    /* COMMENT_101 */
                            
                            
       

    /* COMMENT_105 */
    if (VAR_1->location[0] == '(') {
        /* COMMENT_106 */
        VAR_1->hostname = VAR_1->location;
    } else if (VAR_1->hostname == NULL) {
        VAR_1->hostname = VAR_8;
    }

    /* COMMENT_107 */
    VAR_1->time = VAR_9;
    VAR_4 = localtime(&VAR_9);

    /* COMMENT_108 */
    VAR_1->day = VAR_4->tm_mday;
    VAR_1->year = VAR_4->tm_year + 1900;
    strncpy(VAR_1->mon, VAR_10[VAR_4->tm_mon], 3);
    snprintf(VAR_1->hour, 9, ""%02d:%02d:%02d"",
             VAR_4->tm_hour,
             VAR_4->tm_min,
             VAR_4->tm_sec);

    /* COMMENT_109 */
    VAR_11 = VAR_4->tm_hour;
    VAR_12 = VAR_4->tm_wday;

#ifdef VAR_13
    if (!VAR_14) {
        print_out(""**Phase 1: Completed pre-decoding."");
        print_out(""       full event: '%s'"", VAR_1->full_log);
        print_out(""       hostname: '%s'"", VAR_1->hostname);
        print_out(""       program_name: '%s'"", VAR_1->program_name);
        print_out(""       log: '%s'"", VAR_1->log);
    }
#endif
    return (0);
}",ossec/ossec-hids/9b8b14c88188cdc66ab25f92a26918d0cb8a7760/cleanevent.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,7 +21,12 @@
     /* Is this from an agent? */
     if ( *msg == '(' )
     {   /* look past '->' for the first ':' */
-        pieces = strchr(strstr(msg, ""->""), ':');
+        pieces = strstr(msg, ""->"");
+        if(!pieces) {
+            merror(FORMAT_ERROR, ARGV0);
+            return(-1);
+        }
+        pieces = strchr(pieces, ':');
         if(!pieces)
         {
             merror(FORMAT_ERROR, ARGV0);","{'deleted_lines': ['        pieces = strchr(strstr(msg, ""->""), \':\');'], 'added_lines': ['        pieces = strstr(msg, ""->"");', '        if(!pieces) {', '            merror(FORMAT_ERROR, ARGV0);', '            return(-1);', '        }', ""        pieces = strchr(pieces, ':');""]}",True,"In OSSEC-HIDS 2.7 through 3.5.0, the server component responsible for log analysis (ossec-analysisd) is vulnerable to a denial of service (NULL pointer dereference) via crafted messages written directly to the analysisd UNIX domain socket by a local user.",5.5,MEDIUM,1,valid,2020-01-16T21:12:17Z,3
CVE-2020-9431,['CWE-401'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"LTE RRC: fix a memory leak in composite TVB handling

Bug: 16341
Change-Id: Ib6c020ea3df8b39a02f742f0684fca7db96f1fc3
Reviewed-on: https://code.wireshark.org/review/35899
Petri-Dish: Pascal Quantin <pascal@wireshark.org>
Tested-by: Petri Dish Buildbot
Reviewed-by: Pascal Quantin <pascal@wireshark.org>
(cherry picked from commit adeeb7f2da801303768ce96e2cacf6a703a69c6f)
Conflicts:
	epan/dissectors/packet-lte-rrc.c
Reviewed-on: https://code.wireshark.org/review/35903",086003c9d616906e08bbeeab9c17b3aa4c6ff850,https://github.com/wireshark/wireshark/commit/086003c9d616906e08bbeeab9c17b3aa4c6ff850,epan/dissectors/packet-lte-rrc.c,dissect_lte_rrc_SystemInfoListGERAN_item,"static int
dissect_lte_rrc_SystemInfoListGERAN_item(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
tvbuff_t *sys_info_list_tvb = NULL;
proto_tree *subtree;
offset = dissect_per_octet_string(tvb, offset, actx, tree, hf_index,
1, 23, FALSE, &sys_info_list_tvb);
if (sys_info_list_tvb) {
subtree = proto_item_add_subtree(actx->created_item, ett_lte_rrc_siPsiSibContainer);
switch (private_data_get_si_or_psi_geran(actx)) {
case SI_OrPSI_GERAN_si:
if (gsm_a_dtap_handle) {
tvbuff_t *si_tvb = tvb_new_composite();
guint8 *pd = (guint8 *) wmem_alloc(actx->pinfo->pool, 1);
pd[0] = 0x06;
tvb_composite_append(si_tvb, tvb_new_real_data(pd, 1, 1));
tvb_composite_append(si_tvb, sys_info_list_tvb);
tvb_composite_finalize(si_tvb);
add_new_data_source(actx->pinfo, si_tvb, ""System Information"");
lte_rrc_call_dissector(gsm_a_dtap_handle, si_tvb, actx->pinfo, subtree);
}
break;
case SI_OrPSI_GERAN_psi:
if (gsm_rlcmac_dl_handle) {
tvbuff_t *gsm_rlcmac_dl_tvb = tvb_new_composite();
guint8 *pd = (guint8 *) wmem_alloc(actx->pinfo->pool, 1);
pd[0] = 0x40;
tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_real_data(pd, 1, 1));
tvb_composite_append(gsm_rlcmac_dl_tvb, sys_info_list_tvb);
tvb_composite_finalize(gsm_rlcmac_dl_tvb);
add_new_data_source(actx->pinfo, gsm_rlcmac_dl_tvb, ""GPRS DL control block"");
lte_rrc_call_dissector(gsm_rlcmac_dl_handle, sys_info_list_tvb, actx->pinfo, subtree);
}
break;
default:
break;
}
}
return offset;
}","static int
dissect_lte_rrc_SystemInfoListGERAN_item(tvbuff_t *VAR_0 _U_, int VAR_1 _U_, asn1_ctx_t *VAR_2 _U_, proto_tree *VAR_3 _U_, int VAR_4 _U_) {
tvbuff_t *VAR_5 = NULL;
proto_tree *VAR_6;
VAR_1 = dissect_per_octet_string(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4,
1, 23, FALSE, &VAR_5);
if (VAR_5) {
VAR_6 = proto_item_add_subtree(VAR_2->created_item, VAR_7);
switch (private_data_get_si_or_psi_geran(VAR_2)) {
case VAR_8:
if (VAR_9) {
tvbuff_t *VAR_10 = tvb_new_composite();
guint8 *VAR_11 = (guint8 *) wmem_alloc(VAR_2->pinfo->pool, 1);
VAR_11[0] = 0x06;
tvb_composite_append(VAR_10, tvb_new_real_data(VAR_11, 1, 1));
tvb_composite_append(VAR_10, VAR_5);
tvb_composite_finalize(VAR_10);
add_new_data_source(VAR_2->pinfo, VAR_10, ""System Information"");
lte_rrc_call_dissector(VAR_9, VAR_10, VAR_2->pinfo, VAR_6);
}
break;
case VAR_12:
if (VAR_13) {
tvbuff_t *VAR_14 = tvb_new_composite();
guint8 *VAR_11 = (guint8 *) wmem_alloc(VAR_2->pinfo->pool, 1);
VAR_11[0] = 0x40;
tvb_composite_append(VAR_14, tvb_new_real_data(VAR_11, 1, 1));
tvb_composite_append(VAR_14, VAR_5);
tvb_composite_finalize(VAR_14);
add_new_data_source(VAR_2->pinfo, VAR_14, ""GPRS DL control block"");
lte_rrc_call_dissector(VAR_13, VAR_5, VAR_2->pinfo, VAR_6);
}
break;
default:
break;
}
}
return VAR_1;
}",,"static int
dissect_lte_rrc_SystemInfoListGERAN_item(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
  tvbuff_t *sys_info_list_tvb = NULL;
  proto_tree *subtree;
  offset = dissect_per_octet_string(tvb, offset, actx, tree, hf_index,
                                       1, 23, FALSE, &sys_info_list_tvb);

  if (sys_info_list_tvb) {
    subtree = proto_item_add_subtree(actx->created_item, ett_lte_rrc_siPsiSibContainer);
    switch (private_data_get_si_or_psi_geran(actx)) {
    case SI_OrPSI_GERAN_si:
      /* SI message */
      if (gsm_a_dtap_handle) {
        tvbuff_t *si_tvb = tvb_new_composite();
        guint8 *pd = (guint8 *) wmem_alloc(actx->pinfo->pool, 1);
        pd[0] = 0x06;
        tvb_composite_append(si_tvb, tvb_new_child_real_data(tvb, pd, 1, 1));
        tvb_composite_append(si_tvb, sys_info_list_tvb);
        tvb_composite_finalize(si_tvb);
        add_new_data_source(actx->pinfo, si_tvb, ""System Information"");
        lte_rrc_call_dissector(gsm_a_dtap_handle, si_tvb, actx->pinfo, subtree);
      }
      break;
    case SI_OrPSI_GERAN_psi:
      /* PSI message */
      if (gsm_rlcmac_dl_handle) {
        tvbuff_t *gsm_rlcmac_dl_tvb = tvb_new_composite();
        guint8 *pd = (guint8 *) wmem_alloc(actx->pinfo->pool, 1);
        pd[0] = 0x40;
        tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_child_real_data(tvb, pd, 1, 1));
        tvb_composite_append(gsm_rlcmac_dl_tvb, sys_info_list_tvb);
        tvb_composite_finalize(gsm_rlcmac_dl_tvb);
        add_new_data_source(actx->pinfo, gsm_rlcmac_dl_tvb, ""GPRS DL control block"");
        lte_rrc_call_dissector(gsm_rlcmac_dl_handle, sys_info_list_tvb, actx->pinfo, subtree);
      }
      break;
    default:
      break;
    }
  }


  return offset;
}","static int
dissect_lte_rrc_SystemInfoListGERAN_item(tvbuff_t *VAR_0 _U_, int VAR_1 _U_, asn1_ctx_t *VAR_2 _U_, proto_tree *VAR_3 _U_, int VAR_4 _U_) {
  tvbuff_t *VAR_5 = NULL;
  proto_tree *VAR_6;
  VAR_1 = dissect_per_octet_string(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4,
                                       1, 23, FALSE, &VAR_5);

  if (VAR_5) {
    VAR_6 = proto_item_add_subtree(VAR_2->created_item, VAR_7);
    switch (private_data_get_si_or_psi_geran(VAR_2)) {
    case VAR_8:
      /* COMMENT_0 */
      if (VAR_9) {
        tvbuff_t *VAR_10 = tvb_new_composite();
        guint8 *VAR_11 = (guint8 *) wmem_alloc(VAR_2->pinfo->pool, 1);
        VAR_11[0] = 0x06;
        tvb_composite_append(VAR_10, tvb_new_child_real_data(VAR_0, VAR_11, 1, 1));
        tvb_composite_append(VAR_10, VAR_5);
        tvb_composite_finalize(VAR_10);
        add_new_data_source(VAR_2->pinfo, VAR_10, ""System Information"");
        lte_rrc_call_dissector(VAR_9, VAR_10, VAR_2->pinfo, VAR_6);
      }
      break;
    case VAR_12:
      /* COMMENT_1 */
      if (VAR_13) {
        tvbuff_t *VAR_14 = tvb_new_composite();
        guint8 *VAR_11 = (guint8 *) wmem_alloc(VAR_2->pinfo->pool, 1);
        VAR_11[0] = 0x40;
        tvb_composite_append(VAR_14, tvb_new_child_real_data(VAR_0, VAR_11, 1, 1));
        tvb_composite_append(VAR_14, VAR_5);
        tvb_composite_finalize(VAR_14);
        add_new_data_source(VAR_2->pinfo, VAR_14, ""GPRS DL control block"");
        lte_rrc_call_dissector(VAR_13, VAR_5, VAR_2->pinfo, VAR_6);
      }
      break;
    default:
      break;
    }
  }


  return VAR_1;
}",,"--- func_before
+++ func_after
@@ -14,7 +14,7 @@
         tvbuff_t *si_tvb = tvb_new_composite();
         guint8 *pd = (guint8 *) wmem_alloc(actx->pinfo->pool, 1);
         pd[0] = 0x06;
-        tvb_composite_append(si_tvb, tvb_new_real_data(pd, 1, 1));
+        tvb_composite_append(si_tvb, tvb_new_child_real_data(tvb, pd, 1, 1));
         tvb_composite_append(si_tvb, sys_info_list_tvb);
         tvb_composite_finalize(si_tvb);
         add_new_data_source(actx->pinfo, si_tvb, ""System Information"");
@@ -27,7 +27,7 @@
         tvbuff_t *gsm_rlcmac_dl_tvb = tvb_new_composite();
         guint8 *pd = (guint8 *) wmem_alloc(actx->pinfo->pool, 1);
         pd[0] = 0x40;
-        tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_real_data(pd, 1, 1));
+        tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_child_real_data(tvb, pd, 1, 1));
         tvb_composite_append(gsm_rlcmac_dl_tvb, sys_info_list_tvb);
         tvb_composite_finalize(gsm_rlcmac_dl_tvb);
         add_new_data_source(actx->pinfo, gsm_rlcmac_dl_tvb, ""GPRS DL control block"");","{'deleted_lines': ['        tvb_composite_append(si_tvb, tvb_new_real_data(pd, 1, 1));', '        tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_real_data(pd, 1, 1));'], 'added_lines': ['        tvb_composite_append(si_tvb, tvb_new_child_real_data(tvb, pd, 1, 1));', '        tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_child_real_data(tvb, pd, 1, 1));']}",True,"In Wireshark 3.2.0 to 3.2.1, 3.0.0 to 3.0.8, and 2.6.0 to 2.6.14, the LTE RRC dissector could leak memory. This was addressed in epan/dissectors/packet-lte-rrc.c by adjusting certain append operations.",7.5,HIGH,2,valid,2020-01-22T10:38:02Z,3
CVE-2020-9431,['CWE-401'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"LTE RRC: fix a memory leak in composite TVB handling

Bug: 16341
Change-Id: Ib6c020ea3df8b39a02f742f0684fca7db96f1fc3
Reviewed-on: https://code.wireshark.org/review/35899
Petri-Dish: Pascal Quantin <pascal@wireshark.org>
Tested-by: Petri Dish Buildbot
Reviewed-by: Pascal Quantin <pascal@wireshark.org>
(cherry picked from commit adeeb7f2da801303768ce96e2cacf6a703a69c6f)
Conflicts:
	epan/dissectors/packet-lte-rrc.c
Reviewed-on: https://code.wireshark.org/review/35903",086003c9d616906e08bbeeab9c17b3aa4c6ff850,https://github.com/wireshark/wireshark/commit/086003c9d616906e08bbeeab9c17b3aa4c6ff850,epan/dissectors/packet-lte-rrc.c,dissect_lte_rrc_T_targetRAT_MessageContainer,"static int
dissect_lte_rrc_T_targetRAT_MessageContainer(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
tvbuff_t *target_rat_msg_cont_tvb = NULL;
offset = dissect_per_octet_string(tvb, offset, actx, tree, hf_index,
NO_BOUND, NO_BOUND, FALSE, &target_rat_msg_cont_tvb);
if(target_rat_msg_cont_tvb){
guint8 byte;
proto_tree *subtree;
subtree = proto_item_add_subtree(actx->created_item, ett_lte_rrc_targetRAT_MessageContainer);
switch (private_data_get_rat_target_type(actx)){
case T_targetRAT_Type_utra:
if (rrc_irat_ho_to_utran_cmd_handle)
lte_rrc_call_dissector(rrc_irat_ho_to_utran_cmd_handle, target_rat_msg_cont_tvb, actx->pinfo, subtree);
break;
case T_targetRAT_Type_geran:
byte = tvb_get_guint8(target_rat_msg_cont_tvb, 0);
if (byte == 0x06) {
if (gsm_a_dtap_handle) {
lte_rrc_call_dissector(gsm_a_dtap_handle, target_rat_msg_cont_tvb, actx->pinfo, subtree);
}
} else {
if (gsm_rlcmac_dl_handle) {
tvbuff_t *gsm_rlcmac_dl_tvb = tvb_new_composite();
guint8 *pd = (guint8 *) wmem_alloc(actx->pinfo->pool, 1);
pd[0] = 0x40;
tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_real_data(pd, 1, 1));
tvb_composite_append(gsm_rlcmac_dl_tvb, target_rat_msg_cont_tvb);
tvb_composite_finalize(gsm_rlcmac_dl_tvb);
add_new_data_source(actx->pinfo, gsm_rlcmac_dl_tvb, ""GPRS DL control block"");
lte_rrc_call_dissector(gsm_rlcmac_dl_handle, gsm_rlcmac_dl_tvb, actx->pinfo, subtree);
}
}
break;
case T_targetRAT_Type_cdma2000_1XRTT:
break;
case T_targetRAT_Type_cdma2000_HRPD:
break;
default:
break;
}
}
return offset;
}","static int
dissect_lte_rrc_T_targetRAT_MessageContainer(tvbuff_t *VAR_0 _U_, int VAR_1 _U_, asn1_ctx_t *VAR_2 _U_, proto_tree *VAR_3 _U_, int VAR_4 _U_) {
tvbuff_t *VAR_5 = NULL;
VAR_1 = dissect_per_octet_string(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4,
VAR_6, VAR_6, FALSE, &VAR_5);
if(VAR_5){
guint8 VAR_7;
proto_tree *VAR_8;
VAR_8 = proto_item_add_subtree(VAR_2->created_item, VAR_9);
switch (private_data_get_rat_target_type(VAR_2)){
case VAR_10:
if (VAR_11)
lte_rrc_call_dissector(VAR_11, VAR_5, VAR_2->pinfo, VAR_8);
break;
case VAR_12:
VAR_7 = tvb_get_guint8(VAR_5, 0);
if (VAR_7 == 0x06) {
if (VAR_13) {
lte_rrc_call_dissector(VAR_13, VAR_5, VAR_2->pinfo, VAR_8);
}
} else {
if (VAR_14) {
tvbuff_t *VAR_15 = tvb_new_composite();
guint8 *VAR_16 = (guint8 *) wmem_alloc(VAR_2->pinfo->pool, 1);
VAR_16[0] = 0x40;
tvb_composite_append(VAR_15, tvb_new_real_data(VAR_16, 1, 1));
tvb_composite_append(VAR_15, VAR_5);
tvb_composite_finalize(VAR_15);
add_new_data_source(VAR_2->pinfo, VAR_15, ""GPRS DL control block"");
lte_rrc_call_dissector(VAR_14, VAR_15, VAR_2->pinfo, VAR_8);
}
}
break;
case VAR_17:
break;
case VAR_18:
break;
default:
break;
}
}
return VAR_1;
}",,"static int
dissect_lte_rrc_T_targetRAT_MessageContainer(tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
  tvbuff_t *target_rat_msg_cont_tvb = NULL;
  offset = dissect_per_octet_string(tvb, offset, actx, tree, hf_index,
                                       NO_BOUND, NO_BOUND, FALSE, &target_rat_msg_cont_tvb);

  if(target_rat_msg_cont_tvb){
    guint8 byte;
    proto_tree *subtree;
    subtree = proto_item_add_subtree(actx->created_item, ett_lte_rrc_targetRAT_MessageContainer);
    switch (private_data_get_rat_target_type(actx)){
    case T_targetRAT_Type_utra:
      /* utra */
      if (rrc_irat_ho_to_utran_cmd_handle)
        lte_rrc_call_dissector(rrc_irat_ho_to_utran_cmd_handle, target_rat_msg_cont_tvb, actx->pinfo, subtree);
      break;
    case T_targetRAT_Type_geran:
      /* geran */
      byte = tvb_get_guint8(target_rat_msg_cont_tvb, 0);
      if (byte == 0x06) {
        if (gsm_a_dtap_handle) {
          lte_rrc_call_dissector(gsm_a_dtap_handle, target_rat_msg_cont_tvb, actx->pinfo, subtree);
        }
      } else {
        if (gsm_rlcmac_dl_handle) {
          tvbuff_t *gsm_rlcmac_dl_tvb = tvb_new_composite();
          guint8 *pd = (guint8 *) wmem_alloc(actx->pinfo->pool, 1);
          pd[0] = 0x40;
          tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_child_real_data(tvb, pd, 1, 1));
          tvb_composite_append(gsm_rlcmac_dl_tvb, target_rat_msg_cont_tvb);
          tvb_composite_finalize(gsm_rlcmac_dl_tvb);
          add_new_data_source(actx->pinfo, gsm_rlcmac_dl_tvb, ""GPRS DL control block"");
          lte_rrc_call_dissector(gsm_rlcmac_dl_handle, gsm_rlcmac_dl_tvb, actx->pinfo, subtree);
        }
      }
      break;
    case T_targetRAT_Type_cdma2000_1XRTT:
      /* cdma2000-1XRTT */
      break;
    case T_targetRAT_Type_cdma2000_HRPD:
      /* cdma2000-HRPD */
      break;
    default:
      break;
    }
  }


  return offset;
}","static int
dissect_lte_rrc_T_targetRAT_MessageContainer(tvbuff_t *VAR_0 _U_, int VAR_1 _U_, asn1_ctx_t *VAR_2 _U_, proto_tree *VAR_3 _U_, int VAR_4 _U_) {
  tvbuff_t *VAR_5 = NULL;
  VAR_1 = dissect_per_octet_string(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4,
                                       VAR_6, VAR_6, FALSE, &VAR_5);

  if(VAR_5){
    guint8 VAR_7;
    proto_tree *VAR_8;
    VAR_8 = proto_item_add_subtree(VAR_2->created_item, VAR_9);
    switch (private_data_get_rat_target_type(VAR_2)){
    case VAR_10:
      /* COMMENT_0 */
      if (VAR_11)
        lte_rrc_call_dissector(VAR_11, VAR_5, VAR_2->pinfo, VAR_8);
      break;
    case VAR_12:
      /* COMMENT_1 */
      VAR_7 = tvb_get_guint8(VAR_5, 0);
      if (VAR_7 == 0x06) {
        if (VAR_13) {
          lte_rrc_call_dissector(VAR_13, VAR_5, VAR_2->pinfo, VAR_8);
        }
      } else {
        if (VAR_14) {
          tvbuff_t *VAR_15 = tvb_new_composite();
          guint8 *VAR_16 = (guint8 *) wmem_alloc(VAR_2->pinfo->pool, 1);
          VAR_16[0] = 0x40;
          tvb_composite_append(VAR_15, tvb_new_child_real_data(VAR_0, VAR_16, 1, 1));
          tvb_composite_append(VAR_15, VAR_5);
          tvb_composite_finalize(VAR_15);
          add_new_data_source(VAR_2->pinfo, VAR_15, ""GPRS DL control block"");
          lte_rrc_call_dissector(VAR_14, VAR_15, VAR_2->pinfo, VAR_8);
        }
      }
      break;
    case VAR_17:
      /* COMMENT_2 */
      break;
    case VAR_18:
      /* COMMENT_3 */
      break;
    default:
      break;
    }
  }


  return VAR_1;
}",,"--- func_before
+++ func_after
@@ -26,7 +26,7 @@
           tvbuff_t *gsm_rlcmac_dl_tvb = tvb_new_composite();
           guint8 *pd = (guint8 *) wmem_alloc(actx->pinfo->pool, 1);
           pd[0] = 0x40;
-          tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_real_data(pd, 1, 1));
+          tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_child_real_data(tvb, pd, 1, 1));
           tvb_composite_append(gsm_rlcmac_dl_tvb, target_rat_msg_cont_tvb);
           tvb_composite_finalize(gsm_rlcmac_dl_tvb);
           add_new_data_source(actx->pinfo, gsm_rlcmac_dl_tvb, ""GPRS DL control block"");","{'deleted_lines': ['          tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_real_data(pd, 1, 1));'], 'added_lines': ['          tvb_composite_append(gsm_rlcmac_dl_tvb, tvb_new_child_real_data(tvb, pd, 1, 1));']}",True,"In Wireshark 3.2.0 to 3.2.1, 3.0.0 to 3.0.8, and 2.6.0 to 2.6.14, the LTE RRC dissector could leak memory. This was addressed in epan/dissectors/packet-lte-rrc.c by adjusting certain append operations.",7.5,HIGH,2,valid,2020-01-22T10:38:02Z,3
CVE-2019-9144,['CWE-674'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,Exiv2/exiv2,Fix issue 712.,134e062b664e52a0f1e5223ea8c5d2495de2f31e,https://github.com/Exiv2/exiv2/commit/134e062b664e52a0f1e5223ea8c5d2495de2f31e,src/bigtiffimage.cpp,printIFD,"void printIFD(std::ostream& out, PrintStructureOption option, uint64_t dir_offset, int depth)
{
BasicIo& io = Image::io();
depth++;
bool bFirst  = true;
bool bPrint = true;
do
{
io.seek(static_cast<int64>(dir_offset), BasicIo::beg);
const uint64_t entries = readData(header_.format() == Header::StandardTiff? 2: 8);
const bool tooBig = entries > 500;
if ( bFirst && bPrint )
{
out << Internal::indent(depth) << ""STRUCTURE OF BIGTIFF FILE "" << io.path() << std::endl;
if (tooBig)
out << Internal::indent(depth) << ""entries = "" << entries << std::endl;
}
if (tooBig)
break;
for ( uint64_t i = 0; i < entries; i ++ )
{
if ( bFirst && bPrint )
out << Internal::indent(depth)
<< "" address |    tag                           |     ""
<< "" type |    count |    offset | value\n"";
bFirst = false;
const uint16_t tag   = (uint16_t) readData(2);
const uint16_t type  = (uint16_t) readData(2);
const uint64_t count = readData(dataSize_);
const DataBuf  data  = io.read(dataSize_);        
std::string sp = """" ; 
const uint64_t kount  = isStringType(type)? (count > 32 ? 32 : count)                                                             : count > 5              ? 5
: count
;
const uint32_t pad    = isStringType(type) ? 1 : 0;
const uint32_t size   = isStringType(type) ? 1
: is2ByteType(type)  ? 2
: is4ByteType(type)  ? 4
: is8ByteType(type)  ? 8
: 1;
if (count != 0) {
if (size > std::numeric_limits<uint64_t>::max() / count) {
throw Error(kerInvalidMalloc);                                             }
}
if (size * count > std::numeric_limits<uint64_t>::max() - pad)
throw Error(kerInvalidMalloc);             
const uint64_t allocate = size*count + pad;
if ( allocate > io.size() ) {
throw Error(kerInvalidMalloc);
}
DataBuf buf(static_cast<long>(allocate));
const uint64_t offset = header_.format() == Header::StandardTiff?
byteSwap4(data, 0, doSwap_):
byteSwap8(data, 0, doSwap_);
const bool usePointer = (size_t) count*size > (size_t) dataSize_;
if ( usePointer )                                                      {
size_t   restore = io.tell();                                          io.seek(static_cast<int64>(offset), BasicIo::beg);                                         io.read(buf.pData_, (long) count * size);                                     io.seek(restore, BasicIo::beg);                                    }
else                                  std::memcpy(buf.pData_, data.pData_, (size_t) count * size);     
if ( bPrint )
{
const uint64_t entrySize = header_.format() == Header::StandardTiff? 12: 20;
const uint64_t address = dir_offset + 2 + i * entrySize;
out << Internal::indent(depth)
<< Internal::stringFormat(""%8u | %#06x %-25s |%10s |%9u |"",
static_cast<size_t>(address), tag, tagName(tag).c_str(), typeName(type), count)
<<(usePointer ? Internal::stringFormat(""%10u | "",(size_t)offset)
: Internal::stringFormat(""%10s | "",""""))
;
if ( isShortType(type) )
{
for ( size_t k = 0 ; k < kount ; k++ )
{
out << sp << byteSwap2(buf, k*size, doSwap_);
sp = "" "";
}
}
else if ( isLongType(type) )
{
for ( size_t k = 0 ; k < kount ; k++ )
{
out << sp << byteSwap4(buf, k*size, doSwap_);
sp = "" "";
}
}
else if ( isLongLongType(type) )
{
for ( size_t k = 0 ; k < kount ; k++ )
{
out << sp << byteSwap8(buf, k*size, doSwap_);
sp = "" "";
}
}
else if ( isRationalType(type) )
{
for ( size_t k = 0 ; k < kount ; k++ )
{
uint32_t a = byteSwap4(buf, k*size+0, doSwap_);
uint32_t b = byteSwap4(buf, k*size+4, doSwap_);
out << sp << a << ""/"" << b;
sp = "" "";
}
}
else if ( isStringType(type) )
out << sp << Internal::binaryToString(makeSlice(buf, 0, static_cast<size_t>(kount)));
sp = kount == count ? """" : "" ..."";
out << sp << std::endl;
if ( option == kpsRecursive &&
(tag == 0x8769  || tag == 0x014a || type == tiffIfd || type == tiffIfd8) )
{
for ( size_t k = 0 ; k < count ; k++ )
{
const size_t restore = io.tell();
const uint64_t ifdOffset = type == tiffIfd8?
byteSwap8(buf, k*size, doSwap_):
byteSwap4(buf, k*size, doSwap_);
printIFD(out, option, ifdOffset, depth);
io.seek(restore, BasicIo::beg);
}
}
else if ( option == kpsRecursive && tag == 0x83bb  )
{
if (Safe::add(count, offset) > io.size()) {
throw Error(kerCorruptedMetadata);
}
const size_t restore = io.tell();
io.seek(static_cast<int64>(offset), BasicIo::beg);                                      std::vector<byte> bytes(static_cast<size_t>(count)) ;                                                                          const size_t read_bytes = io.read(&bytes[0], static_cast<long>(count));
io.seek(restore, BasicIo::beg);
IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth);
}
else if ( option == kpsRecursive && tag == 0x927c  && count > 10)
{
size_t   restore = io.tell();  
long jump= 10           ;
byte     bytes[20]          ;
const char* chars = (const char*) &bytes[0] ;
io.seek(static_cast<int64>(dir_offset), BasicIo::beg);                                      io.read(bytes,jump    )     ;                                      bytes[jump]=0               ;
if ( ::strcmp(""Nikon"",chars) == 0 )
{
std::vector<byte> nikon_bytes(static_cast<size_t>(count - jump));
io.read(&nikon_bytes.at(0), (long)nikon_bytes.size());
MemIo memIo(&nikon_bytes.at(0), (long)count - jump);                                       std::cerr << ""Nikon makernote"" << std::endl;
}
else
{
io.seek(0, BasicIo::beg);                                          std::cerr << ""makernote"" << std::endl;
printIFD(out,option,offset,depth);
}
io.seek(restore,BasicIo::beg);                                 }
}
}
const uint64_t nextDirOffset = readData(dataSize_);
dir_offset = tooBig ? 0 : nextDirOffset;
out.flush();
} while (dir_offset != 0);
if ( bPrint )
out << Internal::indent(depth) << ""END "" << io.path() << std::endl;
}","void printIFD(std::ostream& VAR_0, PrintStructureOption VAR_1, uint64_t VAR_2, int VAR_3)
{
BasicIo& VAR_4 = Image::io();
VAR_3++;
bool VAR_5  = true;
bool VAR_6 = true;
do
{
VAR_4.seek(VAR_7<int64>(VAR_2), BasicIo::beg);
const uint64_t VAR_8 = readData(VAR_9.format() == Header::StandardTiff? 2: 8);
const bool VAR_10 = VAR_8 > 500;
if ( VAR_5 && VAR_6 )
{
VAR_0 << Internal::indent(VAR_3) << ""STRUCTURE OF BIGTIFF FILE "" << VAR_4.path() << std::endl;
if (VAR_10)
VAR_0 << Internal::indent(VAR_3) << ""entries = "" << VAR_8 << std::endl;
}
if (VAR_10)
break;
for ( uint64_t VAR_11 = 0; VAR_11 < VAR_8; VAR_11 ++ )
{
if ( VAR_5 && VAR_6 )
VAR_0 << Internal::indent(VAR_3)
<< "" address |    tag                           |     ""
<< "" type |    count |    offset | value\n"";
VAR_5 = false;
const uint16_t VAR_12   = (uint16_t) readData(2);
const uint16_t VAR_13  = (uint16_t) readData(2);
const uint64_t VAR_14 = readData(VAR_15);
const DataBuf  VAR_16  = VAR_4.read(VAR_15);        
std::string VAR_17 = """" ; 
const uint64_t VAR_18  = isStringType(VAR_13)? (VAR_14 > 32 ? 32 : VAR_14) 
: VAR_14 > 5              ? 5
: VAR_14
;
const uint32_t VAR_19    = isStringType(VAR_13) ? 1 : 0;
const uint32_t VAR_20   = isStringType(VAR_13) ? 1
: is2ByteType(VAR_13)  ? 2
: is4ByteType(VAR_13)  ? 4
: is8ByteType(VAR_13)  ? 8
: 1;
if (VAR_14 != 0) {
if (VAR_20 > std::numeric_limits<uint64_t>::max() / VAR_14) {
throw Error(VAR_21);             
}
}
if (VAR_20 * VAR_14 > std::numeric_limits<uint64_t>::max() - VAR_19)
throw Error(VAR_21);             
const uint64_t VAR_22 = VAR_20*VAR_14 + VAR_19;
if ( VAR_22 > VAR_4.size() ) {
throw Error(VAR_21);
}
DataBuf buf(static_cast<long>(allocate));
const uint64_t VAR_23 = VAR_9.format() == Header::StandardTiff?
byteSwap4(VAR_16, 0, VAR_24):
byteSwap8(VAR_16, 0, VAR_24);
const bool VAR_25 = (size_t) VAR_14*VAR_20 > (size_t) VAR_15;
if ( VAR_25 )                          
{
size_t   VAR_26 = VAR_4.tell();          
VAR_4.seek(static_cast<int64>(VAR_23), BasicIo::beg);         
VAR_4.read(VAR_27.pData_, (long) VAR_14 * VAR_20);     
VAR_4.seek(VAR_26, BasicIo::beg);        
}
else  
std::memcpy(VAR_27.pData_, VAR_16.pData_, (size_t) VAR_14 * VAR_20);     
if ( VAR_6 )
{
const uint64_t VAR_28 = VAR_9.format() == Header::StandardTiff? 12: 20;
const uint64_t VAR_29 = VAR_2 + 2 + VAR_11 * VAR_28;
VAR_0 << Internal::indent(VAR_3)
<< Internal::stringFormat(""%8u | %#06x %-25s |%10s |%9u |"",
static_cast<size_t>(VAR_29), VAR_12, tagName(VAR_12).c_str(), typeName(VAR_13), VAR_14)
<<(VAR_25 ? Internal::stringFormat(""%10u | "",(size_t)VAR_23)
: Internal::stringFormat(""%10s | "",""""))
;
if ( isShortType(VAR_13) )
{
for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )
{
VAR_0 << VAR_17 << byteSwap2(VAR_27, VAR_30*VAR_20, VAR_24);
VAR_17 = "" "";
}
}
else if ( isLongType(VAR_13) )
{
for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )
{
VAR_0 << VAR_17 << byteSwap4(VAR_27, VAR_30*VAR_20, VAR_24);
VAR_17 = "" "";
}
}
else if ( isLongLongType(VAR_13) )
{
for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )
{
VAR_0 << VAR_17 << byteSwap8(VAR_27, VAR_30*VAR_20, VAR_24);
VAR_17 = "" "";
}
}
else if ( isRationalType(VAR_13) )
{
for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )
{
uint32_t VAR_31 = byteSwap4(VAR_27, VAR_30*VAR_20+0, VAR_24);
uint32_t VAR_32 = byteSwap4(VAR_27, VAR_30*VAR_20+4, VAR_24);
VAR_0 << VAR_17 << VAR_31 << ""/"" << VAR_32;
VAR_17 = "" "";
}
}
else if ( isStringType(VAR_13) )
VAR_0 << VAR_17 << Internal::binaryToString(makeSlice(VAR_27, 0, static_cast<size_t>(VAR_18)));
VAR_17 = VAR_18 == VAR_14 ? """" : "" ..."";
VAR_0 << VAR_17 << std::endl;
if ( VAR_1 == VAR_33 &&
(VAR_12 == 0x8769  || VAR_12 == 0x014a || VAR_13 == VAR_34 || VAR_13 == VAR_35) )
{
for ( size_t VAR_30 = 0 ; VAR_30 < VAR_14 ; VAR_30++ )
{
const size_t VAR_26 = VAR_4.tell();
const uint64_t VAR_36 = VAR_13 == VAR_35?
byteSwap8(VAR_27, VAR_30*VAR_20, VAR_24):
byteSwap4(VAR_27, VAR_30*VAR_20, VAR_24);
printIFD(VAR_0, VAR_1, VAR_36, VAR_3);
VAR_4.seek(VAR_26, BasicIo::beg);
}
}
else if ( VAR_1 == VAR_33 && VAR_12 == 0x83bb  )
{
if (Safe::add(VAR_14, VAR_23) > VAR_4.size()) {
throw Error(VAR_37);
}
const size_t VAR_26 = VAR_4.tell();
VAR_4.seek(static_cast<int64>(VAR_23), BasicIo::beg);  
std::vector<byte> bytes(static_cast<size_t>(count)) ;  
const size_t VAR_38 = VAR_4.read(&VAR_39[0], static_cast<long>(count));
VAR_4.seek(VAR_26, BasicIo::beg);
IptcData::printStructure(VAR_0, makeSliceUntil(&VAR_39[0], VAR_38), VAR_3);
}
else if ( VAR_1 == VAR_33 && VAR_12 == 0x927c  && count > 10)
{
size_t   VAR_26 = VAR_4.tell();  
long VAR_40= 10           ;
byte     VAR_39[20]          ;
const char* VAR_41 = (const char*) &VAR_39[0] ;
VAR_4.seek(static_cast<int64>(VAR_2), BasicIo::beg);  
VAR_4.read(VAR_39,VAR_40    )     ;  
VAR_39[VAR_40]=0               ;
if ( ::strcmp(""Nikon"",VAR_41) == 0 )
{
std::vector<byte> VAR_42(static_cast<size_t>(count - VAR_40));
VAR_4.read(&VAR_42.at(0), (long)VAR_42.size());
MemIo VAR_43(&VAR_42.at(0), (long)count - VAR_40); 
std::cerr << ""Nikon makernote"" << std::endl;
}
else
{
VAR_4.seek(0, BasicIo::beg);  
std::cerr << ""makernote"" << std::endl;
printIFD(VAR_0,VAR_1,VAR_23,VAR_3);
}
VAR_4.seek(VAR_26,BasicIo::beg); 
}
}
}
const uint64_t VAR_44 = readData(VAR_15);
VAR_2 = VAR_10 ? 0 : VAR_44;
VAR_0.flush();
} while (VAR_2 != 0);
if ( VAR_6 )
VAR_0 << Internal::indent(VAR_3) << ""END "" << VAR_4.path() << std::endl;
}",Exiv2/exiv2/134e062b664e52a0f1e5223ea8c5d2495de2f31e/bigtiffimage.cpp/vul/before/0.json,"void printIFD(std::ostream& out, PrintStructureOption option, uint64_t dir_offset, int depth)
                {
                    BasicIo& io = Image::io();

                    // Fix for https://github.com/Exiv2/exiv2/issues/712
                    // A malicious file can cause a very deep recursion, leading to
                    // stack exhaustion.
                    if (depth > 200) {
                      out << Internal::indent(depth) << ""Maximum indentation depth exceeded."" << std::endl;
                      return;
                    }

                    depth++;
                    bool bFirst  = true;

                    // buffer
                    bool bPrint = true;

                    do
                    {
                        // Read top of directory
                        io.seek(static_cast<int64>(dir_offset), BasicIo::beg);

                        const uint64_t entries = readData(header_.format() == Header::StandardTiff? 2: 8);
                        const bool tooBig = entries > 500;

                        if ( bFirst && bPrint )
                        {
                            out << Internal::indent(depth) << ""STRUCTURE OF BIGTIFF FILE "" << io.path() << std::endl;
                            if (tooBig)
                                out << Internal::indent(depth) << ""entries = "" << entries << std::endl;
                        }

                        if (tooBig)
                            break;

                        // Read the dictionary
                        for ( uint64_t i = 0; i < entries; i ++ )
                        {
                            if ( bFirst && bPrint )
                                out << Internal::indent(depth)
                                    << "" address |    tag                           |     ""
                                    << "" type |    count |    offset | value\n"";

                            bFirst = false;

                            const uint16_t tag   = (uint16_t) readData(2);
                            const uint16_t type  = (uint16_t) readData(2);
                            const uint64_t count = readData(dataSize_);
                            const DataBuf  data  = io.read(dataSize_);        // Read data as raw value. what should be done about it will be decided depending on type

                            std::string sp = """" ; // output spacer

                            //prepare to print the value
                            // TODO: figure out what's going on with kount
                            const uint64_t kount  = isStringType(type)? (count > 32 ? 32 : count) // restrict long arrays
                                                            : count > 5              ? 5
                                                            : count
                                                            ;
                            const uint32_t pad    = isStringType(type) ? 1 : 0;
                            const uint32_t size   = isStringType(type) ? 1
                                                  : is2ByteType(type)  ? 2
                                                  : is4ByteType(type)  ? 4
                                                  : is8ByteType(type)  ? 8
                                                  : 1;

                            // #55 and #56 memory allocation crash test/data/POC8

                            // size * count > std::numeric_limits<uint64_t>::max()
                            // =>
                            // size > std::numeric_limits<uint64_t>::max() / count
                            // (don't perform that check when count == 0 => will cause a division by zero exception)
                            if (count != 0) {
                                if (size > std::numeric_limits<uint64_t>::max() / count) {
                                    throw Error(kerInvalidMalloc);             // we got number bigger than 2^64
                                }
                            }
                                                             // more than we can handle

                            if (size * count > std::numeric_limits<uint64_t>::max() - pad)
                                throw Error(kerInvalidMalloc);             // again more than 2^64

                            const uint64_t allocate = size*count + pad;
                            if ( allocate > io.size() ) {
                                throw Error(kerInvalidMalloc);
                            }

                            DataBuf buf(static_cast<long>(allocate));

                            const uint64_t offset = header_.format() == Header::StandardTiff?
                                    byteSwap4(data, 0, doSwap_):
                                    byteSwap8(data, 0, doSwap_);

                            // big data? Use 'data' as pointer to real data
                            const bool usePointer = (size_t) count*size > (size_t) dataSize_;

                            if ( usePointer )                          // read into buffer
                            {
                                size_t   restore = io.tell();          // save
                                io.seek(static_cast<int64>(offset), BasicIo::beg);         // position
                                io.read(buf.pData_, (long) count * size);     // read
                                io.seek(restore, BasicIo::beg);        // restore
                            }
                            else  // use 'data' as data :)
                                std::memcpy(buf.pData_, data.pData_, (size_t) count * size);     // copy data

                            if ( bPrint )
                            {
                                const uint64_t entrySize = header_.format() == Header::StandardTiff? 12: 20;
                                const uint64_t address = dir_offset + 2 + i * entrySize;

                                out << Internal::indent(depth)
                                    << Internal::stringFormat(""%8u | %#06x %-25s |%10s |%9u |"",
                                        static_cast<size_t>(address), tag, tagName(tag).c_str(), typeName(type), count)
                                    <<(usePointer ? Internal::stringFormat(""%10u | "",(size_t)offset)
                                                  : Internal::stringFormat(""%10s | "",""""))
                                    ;
                                if ( isShortType(type) )
                                {
                                    for ( size_t k = 0 ; k < kount ; k++ )
                                    {
                                        out << sp << byteSwap2(buf, k*size, doSwap_);
                                        sp = "" "";
                                    }
                                }
                                else if ( isLongType(type) )
                                {
                                    for ( size_t k = 0 ; k < kount ; k++ )
                                    {
                                        out << sp << byteSwap4(buf, k*size, doSwap_);
                                        sp = "" "";
                                    }
                                }
                                else if ( isLongLongType(type) )
                                {
                                    for ( size_t k = 0 ; k < kount ; k++ )
                                    {
                                        out << sp << byteSwap8(buf, k*size, doSwap_);
                                        sp = "" "";
                                    }
                                }
                                else if ( isRationalType(type) )
                                {
                                    for ( size_t k = 0 ; k < kount ; k++ )
                                    {
                                        uint32_t a = byteSwap4(buf, k*size+0, doSwap_);
                                        uint32_t b = byteSwap4(buf, k*size+4, doSwap_);
                                        out << sp << a << ""/"" << b;
                                        sp = "" "";
                                    }
                                }
                                else if ( isStringType(type) )
                                    out << sp << Internal::binaryToString(makeSlice(buf, 0, static_cast<size_t>(kount)));

                                sp = kount == count ? """" : "" ..."";
                                out << sp << std::endl;

                                if ( option == kpsRecursive &&
                                        (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/ || type == tiffIfd || type == tiffIfd8) )
                                {
                                    for ( size_t k = 0 ; k < count ; k++ )
                                    {
                                        const size_t restore = io.tell();
                                        const uint64_t ifdOffset = type == tiffIfd8?
                                            byteSwap8(buf, k*size, doSwap_):
                                            byteSwap4(buf, k*size, doSwap_);

                                        printIFD(out, option, ifdOffset, depth);
                                        io.seek(restore, BasicIo::beg);
                                    }
                                }
                                else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ )
                                {
                                    if (Safe::add(count, offset) > io.size()) {
                                        throw Error(kerCorruptedMetadata);
                                    }

                                    const size_t restore = io.tell();
                                    io.seek(static_cast<int64>(offset), BasicIo::beg);  // position
                                    std::vector<byte> bytes(static_cast<size_t>(count)) ;  // allocate memory
                                    // TODO: once we have C++11 use bytes.data()
                                    const size_t read_bytes = io.read(&bytes[0], static_cast<long>(count));
                                    io.seek(restore, BasicIo::beg);
                                    // TODO: once we have C++11 use bytes.data()
                                    IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth);

                                }
                                else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10)
                                {
                                    size_t   restore = io.tell();  // save

                                    long jump= 10           ;
                                    byte     bytes[20]          ;
                                    const char* chars = (const char*) &bytes[0] ;
                                    io.seek(static_cast<int64>(dir_offset), BasicIo::beg);  // position
                                    io.read(bytes,jump    )     ;  // read
                                    bytes[jump]=0               ;
                                    if ( ::strcmp(""Nikon"",chars) == 0 )
                                    {
                                      // tag is an embedded tiff
                                      std::vector<byte> nikon_bytes(static_cast<size_t>(count - jump));

                                      io.read(&nikon_bytes.at(0), (long)nikon_bytes.size());
                                      MemIo memIo(&nikon_bytes.at(0), (long)count - jump); // create a file
                                      std::cerr << ""Nikon makernote"" << std::endl;
                                      // printTiffStructure(memIo,out,option,depth);
                                      // TODO: fix it
                                    }
                                    else
                                    {
                                        // tag is an IFD
                                        io.seek(0, BasicIo::beg);  // position
                                        std::cerr << ""makernote"" << std::endl;
                                        printIFD(out,option,offset,depth);
                                    }

                                    io.seek(restore,BasicIo::beg); // restore
                                }
                            }
                        }

                        const uint64_t nextDirOffset = readData(dataSize_);

                        dir_offset = tooBig ? 0 : nextDirOffset;
                        out.flush();
                    } while (dir_offset != 0);

                    if ( bPrint )
                        out << Internal::indent(depth) << ""END "" << io.path() << std::endl;
                }","void printIFD(std::ostream& VAR_0, PrintStructureOption VAR_1, uint64_t VAR_2, int VAR_3)
                {
                    BasicIo& VAR_4 = Image::io();

                    /* COMMENT_0 */
                    /* COMMENT_1 */
                    /* COMMENT_2 */
                    if (VAR_3 > 200) {
                      VAR_0 << Internal::indent(VAR_3) << ""Maximum indentation depth exceeded."" << std::endl;
                      return;
                    }

                    VAR_3++;
                    bool VAR_5  = true;

                    /* COMMENT_3 */
                    bool VAR_6 = true;

                    do
                    {
                        /* COMMENT_4 */
                        VAR_4.seek(VAR_7<int64>(VAR_2), BasicIo::beg);

                        const uint64_t VAR_8 = readData(VAR_9.format() == Header::StandardTiff? 2: 8);
                        const bool VAR_10 = VAR_8 > 500;

                        if ( VAR_5 && VAR_6 )
                        {
                            VAR_0 << Internal::indent(VAR_3) << ""STRUCTURE OF BIGTIFF FILE "" << VAR_4.path() << std::endl;
                            if (VAR_10)
                                VAR_0 << Internal::indent(VAR_3) << ""entries = "" << VAR_8 << std::endl;
                        }

                        if (VAR_10)
                            break;

                        /* COMMENT_5 */
                        for ( uint64_t VAR_11 = 0; VAR_11 < VAR_8; VAR_11 ++ )
                        {
                            if ( VAR_5 && VAR_6 )
                                VAR_0 << Internal::indent(VAR_3)
                                    << "" address |    tag                           |     ""
                                    << "" type |    count |    offset | value\n"";

                            VAR_5 = false;

                            const uint16_t VAR_12   = (uint16_t) readData(2);
                            const uint16_t VAR_13  = (uint16_t) readData(2);
                            const uint64_t VAR_14 = readData(VAR_15);
                            const DataBuf  VAR_16  = VAR_4.read(VAR_15);        /* COMMENT_6 */

                            std::string VAR_17 = """" ; /* COMMENT_7 */

                            /* COMMENT_8 */
                            /* COMMENT_9 */
                            const uint64_t VAR_18  = isStringType(VAR_13)? (VAR_14 > 32 ? 32 : VAR_14) /* COMMENT_10 */
                                                            : VAR_14 > 5              ? 5
                                                            : VAR_14
                                                            ;
                            const uint32_t VAR_19    = isStringType(VAR_13) ? 1 : 0;
                            const uint32_t VAR_20   = isStringType(VAR_13) ? 1
                                                  : is2ByteType(VAR_13)  ? 2
                                                  : is4ByteType(VAR_13)  ? 4
                                                  : is8ByteType(VAR_13)  ? 8
                                                  : 1;

                            /* COMMENT_11 */

                            /* COMMENT_12 */
                            /* COMMENT_13 */
                            /* COMMENT_14 */
                            /* COMMENT_15 */
                            if (VAR_14 != 0) {
                                if (VAR_20 > std::numeric_limits<uint64_t>::max() / VAR_14) {
                                    throw Error(VAR_21);             /* COMMENT_16 */
                                }
                            }
                                                             /* COMMENT_17 */

                            if (VAR_20 * VAR_14 > std::numeric_limits<uint64_t>::max() - VAR_19)
                                throw Error(VAR_21);             /* COMMENT_18 */

                            const uint64_t VAR_22 = VAR_20*VAR_14 + VAR_19;
                            if ( VAR_22 > VAR_4.size() ) {
                                throw Error(VAR_21);
                            }

                            DataBuf buf(static_cast<long>(allocate));

                            const uint64_t VAR_23 = VAR_9.format() == Header::StandardTiff?
                                    byteSwap4(VAR_16, 0, VAR_24):
                                    byteSwap8(VAR_16, 0, VAR_24);

                            /* COMMENT_19 */
                            const bool VAR_25 = (size_t) VAR_14*VAR_20 > (size_t) VAR_15;

                            if ( VAR_25 )                          /* COMMENT_20 */
                            {
                                size_t   VAR_26 = VAR_4.tell();          /* COMMENT_21 */
                                VAR_4.seek(static_cast<int64>(VAR_23), BasicIo::beg);         /* COMMENT_22 */
                                VAR_4.read(VAR_27.pData_, (long) VAR_14 * VAR_20);     /* COMMENT_23 */
                                VAR_4.seek(VAR_26, BasicIo::beg);        /* COMMENT_24 */
                            }
                            else  /* COMMENT_25 */
                                std::memcpy(VAR_27.pData_, VAR_16.pData_, (size_t) VAR_14 * VAR_20);     /* COMMENT_26 */

                            if ( VAR_6 )
                            {
                                const uint64_t VAR_28 = VAR_9.format() == Header::StandardTiff? 12: 20;
                                const uint64_t VAR_29 = VAR_2 + 2 + VAR_11 * VAR_28;

                                VAR_0 << Internal::indent(VAR_3)
                                    << Internal::stringFormat(""%8u | %#06x %-25s |%10s |%9u |"",
                                        static_cast<size_t>(VAR_29), VAR_12, tagName(VAR_12).c_str(), typeName(VAR_13), VAR_14)
                                    <<(VAR_25 ? Internal::stringFormat(""%10u | "",(size_t)VAR_23)
                                                  : Internal::stringFormat(""%10s | "",""""))
                                    ;
                                if ( isShortType(VAR_13) )
                                {
                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )
                                    {
                                        VAR_0 << VAR_17 << byteSwap2(VAR_27, VAR_30*VAR_20, VAR_24);
                                        VAR_17 = "" "";
                                    }
                                }
                                else if ( isLongType(VAR_13) )
                                {
                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )
                                    {
                                        VAR_0 << VAR_17 << byteSwap4(VAR_27, VAR_30*VAR_20, VAR_24);
                                        VAR_17 = "" "";
                                    }
                                }
                                else if ( isLongLongType(VAR_13) )
                                {
                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )
                                    {
                                        VAR_0 << VAR_17 << byteSwap8(VAR_27, VAR_30*VAR_20, VAR_24);
                                        VAR_17 = "" "";
                                    }
                                }
                                else if ( isRationalType(VAR_13) )
                                {
                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )
                                    {
                                        uint32_t VAR_31 = byteSwap4(VAR_27, VAR_30*VAR_20+0, VAR_24);
                                        uint32_t VAR_32 = byteSwap4(VAR_27, VAR_30*VAR_20+4, VAR_24);
                                        VAR_0 << VAR_17 << VAR_31 << ""/"" << VAR_32;
                                        VAR_17 = "" "";
                                    }
                                }
                                else if ( isStringType(VAR_13) )
                                    VAR_0 << VAR_17 << Internal::binaryToString(makeSlice(VAR_27, 0, static_cast<size_t>(VAR_18)));

                                VAR_17 = VAR_18 == VAR_14 ? """" : "" ..."";
                                VAR_0 << VAR_17 << std::endl;

                                if ( VAR_1 == VAR_33 &&
                                        (VAR_12 == 0x8769 /* COMMENT_27 */ || VAR_12 == 0x014a/* COMMENT_28 */ || VAR_13 == VAR_34 || VAR_13 == VAR_35) )
                                {
                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_14 ; VAR_30++ )
                                    {
                                        const size_t VAR_26 = VAR_4.tell();
                                        const uint64_t VAR_36 = VAR_13 == VAR_35?
                                            byteSwap8(VAR_27, VAR_30*VAR_20, VAR_24):
                                            byteSwap4(VAR_27, VAR_30*VAR_20, VAR_24);

                                        printIFD(VAR_0, VAR_1, VAR_36, VAR_3);
                                        VAR_4.seek(VAR_26, BasicIo::beg);
                                    }
                                }
                                else if ( VAR_1 == VAR_33 && VAR_12 == 0x83bb /* COMMENT_29 */ )
                                {
                                    if (Safe::add(VAR_14, VAR_23) > VAR_4.size()) {
                                        throw Error(VAR_37);
                                    }

                                    const size_t VAR_26 = VAR_4.tell();
                                    VAR_4.seek(static_cast<int64>(VAR_23), BasicIo::beg);  /* COMMENT_22 */
                                    std::vector<byte> bytes(static_cast<size_t>(count)) ;  /* COMMENT_30 */
                                    /* COMMENT_31 */
                                    const size_t VAR_38 = VAR_4.read(&VAR_39[0], static_cast<long>(count));
                                    VAR_4.seek(VAR_26, BasicIo::beg);
                                    /* COMMENT_31 */
                                    IptcData::printStructure(VAR_0, makeSliceUntil(&VAR_39[0], VAR_38), VAR_3);

                                }
                                else if ( VAR_1 == VAR_33 && VAR_12 == 0x927c /* COMMENT_32 */ && count > 10)
                                {
                                    size_t   VAR_26 = VAR_4.tell();  /* COMMENT_21 */

                                    long VAR_40= 10           ;
                                    byte     VAR_39[20]          ;
                                    const char* VAR_41 = (const char*) &VAR_39[0] ;
                                    VAR_4.seek(static_cast<int64>(VAR_2), BasicIo::beg);  /* COMMENT_22 */
                                    VAR_4.read(VAR_39,VAR_40    )     ;  /* COMMENT_23 */
                                    VAR_39[VAR_40]=0               ;
                                    if ( ::strcmp(""Nikon"",VAR_41) == 0 )
                                    {
                                      /* COMMENT_33 */
                                      std::vector<byte> VAR_42(static_cast<size_t>(count - VAR_40));

                                      VAR_4.read(&VAR_42.at(0), (long)VAR_42.size());
                                      MemIo VAR_43(&VAR_42.at(0), (long)count - VAR_40); /* COMMENT_34 */
                                      std::cerr << ""Nikon makernote"" << std::endl;
                                      /* COMMENT_35 */
                                      /* COMMENT_36 */
                                    }
                                    else
                                    {
                                        /* COMMENT_37 */
                                        VAR_4.seek(0, BasicIo::beg);  /* COMMENT_22 */
                                        std::cerr << ""makernote"" << std::endl;
                                        printIFD(VAR_0,VAR_1,VAR_23,VAR_3);
                                    }

                                    VAR_4.seek(VAR_26,BasicIo::beg); /* COMMENT_24 */
                                }
                            }
                        }

                        const uint64_t VAR_44 = readData(VAR_15);

                        VAR_2 = VAR_10 ? 0 : VAR_44;
                        VAR_0.flush();
                    } while (VAR_2 != 0);

                    if ( VAR_6 )
                        VAR_0 << Internal::indent(VAR_3) << ""END "" << VAR_4.path() << std::endl;
                }",Exiv2/exiv2/134e062b664e52a0f1e5223ea8c5d2495de2f31e/bigtiffimage.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,14 @@
 void printIFD(std::ostream& out, PrintStructureOption option, uint64_t dir_offset, int depth)
                 {
                     BasicIo& io = Image::io();
+
+                    // Fix for https://github.com/Exiv2/exiv2/issues/712
+                    // A malicious file can cause a very deep recursion, leading to
+                    // stack exhaustion.
+                    if (depth > 200) {
+                      out << Internal::indent(depth) << ""Maximum indentation depth exceeded."" << std::endl;
+                      return;
+                    }
 
                     depth++;
                     bool bFirst  = true;","{'deleted_lines': [], 'added_lines': ['', '                    // Fix for https://github.com/Exiv2/exiv2/issues/712', '                    // A malicious file can cause a very deep recursion, leading to', '                    // stack exhaustion.', '                    if (depth > 200) {', '                      out << Internal::indent(depth) << ""Maximum indentation depth exceeded."" << std::endl;', '                      return;', '                    }']}",True,An issue was discovered in Exiv2 0.27. There is infinite recursion at BigTiffImage::printIFD in the file bigtiffimage.cpp. This can be triggered by a crafted file. It allows an attacker to cause Denial of Service (Segmentation fault) or possibly have unspecified other impact.,8.8,HIGH,2,valid,2020-01-23T13:09:06Z,3
CVE-2019-9144,['CWE-674'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,Exiv2/exiv2,Add comment to explain choice of cut-off value.,a6765cf18b9bf9d79486946ecec8ef0e2de1ab7b,https://github.com/Exiv2/exiv2/commit/a6765cf18b9bf9d79486946ecec8ef0e2de1ab7b,src/bigtiffimage.cpp,printIFD,"void printIFD(std::ostream& out, PrintStructureOption option, uint64_t dir_offset, int depth)
{
BasicIo& io = Image::io();
if (depth > 200) {
out << Internal::indent(depth) << ""Maximum indentation depth exceeded."" << std::endl;
return;
}
depth++;
bool bFirst  = true;
bool bPrint = true;
do
{
io.seek(static_cast<int64>(dir_offset), BasicIo::beg);
const uint64_t entries = readData(header_.format() == Header::StandardTiff? 2: 8);
const bool tooBig = entries > 500;
if ( bFirst && bPrint )
{
out << Internal::indent(depth) << ""STRUCTURE OF BIGTIFF FILE "" << io.path() << std::endl;
if (tooBig)
out << Internal::indent(depth) << ""entries = "" << entries << std::endl;
}
if (tooBig)
break;
for ( uint64_t i = 0; i < entries; i ++ )
{
if ( bFirst && bPrint )
out << Internal::indent(depth)
<< "" address |    tag                           |     ""
<< "" type |    count |    offset | value\n"";
bFirst = false;
const uint16_t tag   = (uint16_t) readData(2);
const uint16_t type  = (uint16_t) readData(2);
const uint64_t count = readData(dataSize_);
const DataBuf  data  = io.read(dataSize_);        
std::string sp = """" ; 
const uint64_t kount  = isStringType(type)? (count > 32 ? 32 : count)                                                             : count > 5              ? 5
: count
;
const uint32_t pad    = isStringType(type) ? 1 : 0;
const uint32_t size   = isStringType(type) ? 1
: is2ByteType(type)  ? 2
: is4ByteType(type)  ? 4
: is8ByteType(type)  ? 8
: 1;
if (count != 0) {
if (size > std::numeric_limits<uint64_t>::max() / count) {
throw Error(kerInvalidMalloc);                                             }
}
if (size * count > std::numeric_limits<uint64_t>::max() - pad)
throw Error(kerInvalidMalloc);             
const uint64_t allocate = size*count + pad;
if ( allocate > io.size() ) {
throw Error(kerInvalidMalloc);
}
DataBuf buf(static_cast<long>(allocate));
const uint64_t offset = header_.format() == Header::StandardTiff?
byteSwap4(data, 0, doSwap_):
byteSwap8(data, 0, doSwap_);
const bool usePointer = (size_t) count*size > (size_t) dataSize_;
if ( usePointer )                                                      {
size_t   restore = io.tell();                                          io.seek(static_cast<int64>(offset), BasicIo::beg);                                         io.read(buf.pData_, (long) count * size);                                     io.seek(restore, BasicIo::beg);                                    }
else                                  std::memcpy(buf.pData_, data.pData_, (size_t) count * size);     
if ( bPrint )
{
const uint64_t entrySize = header_.format() == Header::StandardTiff? 12: 20;
const uint64_t address = dir_offset + 2 + i * entrySize;
out << Internal::indent(depth)
<< Internal::stringFormat(""%8u | %#06x %-25s |%10s |%9u |"",
static_cast<size_t>(address), tag, tagName(tag).c_str(), typeName(type), count)
<<(usePointer ? Internal::stringFormat(""%10u | "",(size_t)offset)
: Internal::stringFormat(""%10s | "",""""))
;
if ( isShortType(type) )
{
for ( size_t k = 0 ; k < kount ; k++ )
{
out << sp << byteSwap2(buf, k*size, doSwap_);
sp = "" "";
}
}
else if ( isLongType(type) )
{
for ( size_t k = 0 ; k < kount ; k++ )
{
out << sp << byteSwap4(buf, k*size, doSwap_);
sp = "" "";
}
}
else if ( isLongLongType(type) )
{
for ( size_t k = 0 ; k < kount ; k++ )
{
out << sp << byteSwap8(buf, k*size, doSwap_);
sp = "" "";
}
}
else if ( isRationalType(type) )
{
for ( size_t k = 0 ; k < kount ; k++ )
{
uint32_t a = byteSwap4(buf, k*size+0, doSwap_);
uint32_t b = byteSwap4(buf, k*size+4, doSwap_);
out << sp << a << ""/"" << b;
sp = "" "";
}
}
else if ( isStringType(type) )
out << sp << Internal::binaryToString(makeSlice(buf, 0, static_cast<size_t>(kount)));
sp = kount == count ? """" : "" ..."";
out << sp << std::endl;
if ( option == kpsRecursive &&
(tag == 0x8769  || tag == 0x014a || type == tiffIfd || type == tiffIfd8) )
{
for ( size_t k = 0 ; k < count ; k++ )
{
const size_t restore = io.tell();
const uint64_t ifdOffset = type == tiffIfd8?
byteSwap8(buf, k*size, doSwap_):
byteSwap4(buf, k*size, doSwap_);
printIFD(out, option, ifdOffset, depth);
io.seek(restore, BasicIo::beg);
}
}
else if ( option == kpsRecursive && tag == 0x83bb  )
{
if (Safe::add(count, offset) > io.size()) {
throw Error(kerCorruptedMetadata);
}
const size_t restore = io.tell();
io.seek(static_cast<int64>(offset), BasicIo::beg);                                      std::vector<byte> bytes(static_cast<size_t>(count)) ;                                                                          const size_t read_bytes = io.read(&bytes[0], static_cast<long>(count));
io.seek(restore, BasicIo::beg);
IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth);
}
else if ( option == kpsRecursive && tag == 0x927c  && count > 10)
{
size_t   restore = io.tell();  
long jump= 10           ;
byte     bytes[20]          ;
const char* chars = (const char*) &bytes[0] ;
io.seek(static_cast<int64>(dir_offset), BasicIo::beg);                                      io.read(bytes,jump    )     ;                                      bytes[jump]=0               ;
if ( ::strcmp(""Nikon"",chars) == 0 )
{
std::vector<byte> nikon_bytes(static_cast<size_t>(count - jump));
io.read(&nikon_bytes.at(0), (long)nikon_bytes.size());
MemIo memIo(&nikon_bytes.at(0), (long)count - jump);                                       std::cerr << ""Nikon makernote"" << std::endl;
}
else
{
io.seek(0, BasicIo::beg);                                          std::cerr << ""makernote"" << std::endl;
printIFD(out,option,offset,depth);
}
io.seek(restore,BasicIo::beg);                                 }
}
}
const uint64_t nextDirOffset = readData(dataSize_);
dir_offset = tooBig ? 0 : nextDirOffset;
out.flush();
} while (dir_offset != 0);
if ( bPrint )
out << Internal::indent(depth) << ""END "" << io.path() << std::endl;
}","void printIFD(std::ostream& VAR_0, PrintStructureOption VAR_1, uint64_t VAR_2, int VAR_3)
{
BasicIo& VAR_4 = Image::io();
if (VAR_3 > 200) {
VAR_0 << Internal::indent(VAR_3) << ""Maximum indentation depth exceeded."" << std::endl;
return;
}
VAR_3++;
bool VAR_5  = true;
bool VAR_6 = true;
do
{
VAR_4.seek(VAR_7<int64>(VAR_2), BasicIo::beg);
const uint64_t VAR_8 = readData(VAR_9.format() == Header::StandardTiff? 2: 8);
const bool VAR_10 = VAR_8 > 500;
if ( VAR_5 && VAR_6 )
{
VAR_0 << Internal::indent(VAR_3) << ""STRUCTURE OF BIGTIFF FILE "" << VAR_4.path() << std::endl;
if (VAR_10)
VAR_0 << Internal::indent(VAR_3) << ""entries = "" << VAR_8 << std::endl;
}
if (VAR_10)
break;
for ( uint64_t VAR_11 = 0; VAR_11 < VAR_8; VAR_11 ++ )
{
if ( VAR_5 && VAR_6 )
VAR_0 << Internal::indent(VAR_3)
<< "" address |    tag                           |     ""
<< "" type |    count |    offset | value\n"";
VAR_5 = false;
const uint16_t VAR_12   = (uint16_t) readData(2);
const uint16_t VAR_13  = (uint16_t) readData(2);
const uint64_t VAR_14 = readData(VAR_15);
const DataBuf  VAR_16  = VAR_4.read(VAR_15);        
std::string VAR_17 = """" ; 
const uint64_t VAR_18  = isStringType(VAR_13)? (VAR_14 > 32 ? 32 : VAR_14) 
: VAR_14 > 5              ? 5
: VAR_14
;
const uint32_t VAR_19    = isStringType(VAR_13) ? 1 : 0;
const uint32_t VAR_20   = isStringType(VAR_13) ? 1
: is2ByteType(VAR_13)  ? 2
: is4ByteType(VAR_13)  ? 4
: is8ByteType(VAR_13)  ? 8
: 1;
if (VAR_14 != 0) {
if (VAR_20 > std::numeric_limits<uint64_t>::max() / VAR_14) {
throw Error(VAR_21);             
}
}
if (VAR_20 * VAR_14 > std::numeric_limits<uint64_t>::max() - VAR_19)
throw Error(VAR_21);             
const uint64_t VAR_22 = VAR_20*VAR_14 + VAR_19;
if ( VAR_22 > VAR_4.size() ) {
throw Error(VAR_21);
}
DataBuf buf(static_cast<long>(allocate));
const uint64_t VAR_23 = VAR_9.format() == Header::StandardTiff?
byteSwap4(VAR_16, 0, VAR_24):
byteSwap8(VAR_16, 0, VAR_24);
const bool VAR_25 = (size_t) VAR_14*VAR_20 > (size_t) VAR_15;
if ( VAR_25 )                          
{
size_t   VAR_26 = VAR_4.tell();          
VAR_4.seek(static_cast<int64>(VAR_23), BasicIo::beg);         
VAR_4.read(VAR_27.pData_, (long) VAR_14 * VAR_20);     
VAR_4.seek(VAR_26, BasicIo::beg);        
}
else  
std::memcpy(VAR_27.pData_, VAR_16.pData_, (size_t) VAR_14 * VAR_20);     
if ( VAR_6 )
{
const uint64_t VAR_28 = VAR_9.format() == Header::StandardTiff? 12: 20;
const uint64_t VAR_29 = VAR_2 + 2 + VAR_11 * VAR_28;
VAR_0 << Internal::indent(VAR_3)
<< Internal::stringFormat(""%8u | %#06x %-25s |%10s |%9u |"",
static_cast<size_t>(VAR_29), VAR_12, tagName(VAR_12).c_str(), typeName(VAR_13), VAR_14)
<<(VAR_25 ? Internal::stringFormat(""%10u | "",(size_t)VAR_23)
: Internal::stringFormat(""%10s | "",""""))
;
if ( isShortType(VAR_13) )
{
for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )
{
VAR_0 << VAR_17 << byteSwap2(VAR_27, VAR_30*VAR_20, VAR_24);
VAR_17 = "" "";
}
}
else if ( isLongType(VAR_13) )
{
for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )
{
VAR_0 << VAR_17 << byteSwap4(VAR_27, VAR_30*VAR_20, VAR_24);
VAR_17 = "" "";
}
}
else if ( isLongLongType(VAR_13) )
{
for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )
{
VAR_0 << VAR_17 << byteSwap8(VAR_27, VAR_30*VAR_20, VAR_24);
VAR_17 = "" "";
}
}
else if ( isRationalType(VAR_13) )
{
for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )
{
uint32_t VAR_31 = byteSwap4(VAR_27, VAR_30*VAR_20+0, VAR_24);
uint32_t VAR_32 = byteSwap4(VAR_27, VAR_30*VAR_20+4, VAR_24);
VAR_0 << VAR_17 << VAR_31 << ""/"" << VAR_32;
VAR_17 = "" "";
}
}
else if ( isStringType(VAR_13) )
VAR_0 << VAR_17 << Internal::binaryToString(makeSlice(VAR_27, 0, static_cast<size_t>(VAR_18)));
VAR_17 = VAR_18 == VAR_14 ? """" : "" ..."";
VAR_0 << VAR_17 << std::endl;
if ( VAR_1 == VAR_33 &&
(VAR_12 == 0x8769  || VAR_12 == 0x014a || VAR_13 == VAR_34 || VAR_13 == VAR_35) )
{
for ( size_t VAR_30 = 0 ; VAR_30 < VAR_14 ; VAR_30++ )
{
const size_t VAR_26 = VAR_4.tell();
const uint64_t VAR_36 = VAR_13 == VAR_35?
byteSwap8(VAR_27, VAR_30*VAR_20, VAR_24):
byteSwap4(VAR_27, VAR_30*VAR_20, VAR_24);
printIFD(VAR_0, VAR_1, VAR_36, VAR_3);
VAR_4.seek(VAR_26, BasicIo::beg);
}
}
else if ( VAR_1 == VAR_33 && VAR_12 == 0x83bb  )
{
if (Safe::add(VAR_14, VAR_23) > VAR_4.size()) {
throw Error(VAR_37);
}
const size_t VAR_26 = VAR_4.tell();
VAR_4.seek(static_cast<int64>(VAR_23), BasicIo::beg);  
std::vector<byte> bytes(static_cast<size_t>(count)) ;  
const size_t VAR_38 = VAR_4.read(&VAR_39[0], static_cast<long>(count));
VAR_4.seek(VAR_26, BasicIo::beg);
IptcData::printStructure(VAR_0, makeSliceUntil(&VAR_39[0], VAR_38), VAR_3);
}
else if ( VAR_1 == VAR_33 && VAR_12 == 0x927c  && count > 10)
{
size_t   VAR_26 = VAR_4.tell();  
long VAR_40= 10           ;
byte     VAR_39[20]          ;
const char* VAR_41 = (const char*) &VAR_39[0] ;
VAR_4.seek(static_cast<int64>(VAR_2), BasicIo::beg);  
VAR_4.read(VAR_39,VAR_40    )     ;  
VAR_39[VAR_40]=0               ;
if ( ::strcmp(""Nikon"",VAR_41) == 0 )
{
std::vector<byte> VAR_42(static_cast<size_t>(count - VAR_40));
VAR_4.read(&VAR_42.at(0), (long)VAR_42.size());
MemIo VAR_43(&VAR_42.at(0), (long)count - VAR_40); 
std::cerr << ""Nikon makernote"" << std::endl;
}
else
{
VAR_4.seek(0, BasicIo::beg);  
std::cerr << ""makernote"" << std::endl;
printIFD(VAR_0,VAR_1,VAR_23,VAR_3);
}
VAR_4.seek(VAR_26,BasicIo::beg); 
}
}
}
const uint64_t VAR_44 = readData(VAR_15);
VAR_2 = VAR_10 ? 0 : VAR_44;
VAR_0.flush();
} while (VAR_2 != 0);
if ( VAR_6 )
VAR_0 << Internal::indent(VAR_3) << ""END "" << VAR_4.path() << std::endl;
}",Exiv2/exiv2/a6765cf18b9bf9d79486946ecec8ef0e2de1ab7b/bigtiffimage.cpp/vul/before/0.json,"void printIFD(std::ostream& out, PrintStructureOption option, uint64_t dir_offset, int depth)
                {
                    BasicIo& io = Image::io();

                    // Fix for https://github.com/Exiv2/exiv2/issues/712
                    // A malicious file can cause a very deep recursion, leading to
                    // stack exhaustion.
                    // Note: 200 is an arbitrarily chosen cut-off value. The value
                    // of depth determines the amount of indentation inserted by the
                    // pretty-printer. The output starts to become unreadable as
                    // soon as the indentation exceeds 80 characters or so. That's
                    // why 200 ought to be a reasonable cut-off.
                    if (depth > 200) {
                      out << Internal::indent(depth) << ""Maximum indentation depth exceeded."" << std::endl;
                      return;
                    }

                    depth++;
                    bool bFirst  = true;

                    // buffer
                    bool bPrint = true;

                    do
                    {
                        // Read top of directory
                        io.seek(static_cast<int64>(dir_offset), BasicIo::beg);

                        const uint64_t entries = readData(header_.format() == Header::StandardTiff? 2: 8);
                        const bool tooBig = entries > 500;

                        if ( bFirst && bPrint )
                        {
                            out << Internal::indent(depth) << ""STRUCTURE OF BIGTIFF FILE "" << io.path() << std::endl;
                            if (tooBig)
                                out << Internal::indent(depth) << ""entries = "" << entries << std::endl;
                        }

                        if (tooBig)
                            break;

                        // Read the dictionary
                        for ( uint64_t i = 0; i < entries; i ++ )
                        {
                            if ( bFirst && bPrint )
                                out << Internal::indent(depth)
                                    << "" address |    tag                           |     ""
                                    << "" type |    count |    offset | value\n"";

                            bFirst = false;

                            const uint16_t tag   = (uint16_t) readData(2);
                            const uint16_t type  = (uint16_t) readData(2);
                            const uint64_t count = readData(dataSize_);
                            const DataBuf  data  = io.read(dataSize_);        // Read data as raw value. what should be done about it will be decided depending on type

                            std::string sp = """" ; // output spacer

                            //prepare to print the value
                            // TODO: figure out what's going on with kount
                            const uint64_t kount  = isStringType(type)? (count > 32 ? 32 : count) // restrict long arrays
                                                            : count > 5              ? 5
                                                            : count
                                                            ;
                            const uint32_t pad    = isStringType(type) ? 1 : 0;
                            const uint32_t size   = isStringType(type) ? 1
                                                  : is2ByteType(type)  ? 2
                                                  : is4ByteType(type)  ? 4
                                                  : is8ByteType(type)  ? 8
                                                  : 1;

                            // #55 and #56 memory allocation crash test/data/POC8

                            // size * count > std::numeric_limits<uint64_t>::max()
                            // =>
                            // size > std::numeric_limits<uint64_t>::max() / count
                            // (don't perform that check when count == 0 => will cause a division by zero exception)
                            if (count != 0) {
                                if (size > std::numeric_limits<uint64_t>::max() / count) {
                                    throw Error(kerInvalidMalloc);             // we got number bigger than 2^64
                                }
                            }
                                                             // more than we can handle

                            if (size * count > std::numeric_limits<uint64_t>::max() - pad)
                                throw Error(kerInvalidMalloc);             // again more than 2^64

                            const uint64_t allocate = size*count + pad;
                            if ( allocate > io.size() ) {
                                throw Error(kerInvalidMalloc);
                            }

                            DataBuf buf(static_cast<long>(allocate));

                            const uint64_t offset = header_.format() == Header::StandardTiff?
                                    byteSwap4(data, 0, doSwap_):
                                    byteSwap8(data, 0, doSwap_);

                            // big data? Use 'data' as pointer to real data
                            const bool usePointer = (size_t) count*size > (size_t) dataSize_;

                            if ( usePointer )                          // read into buffer
                            {
                                size_t   restore = io.tell();          // save
                                io.seek(static_cast<int64>(offset), BasicIo::beg);         // position
                                io.read(buf.pData_, (long) count * size);     // read
                                io.seek(restore, BasicIo::beg);        // restore
                            }
                            else  // use 'data' as data :)
                                std::memcpy(buf.pData_, data.pData_, (size_t) count * size);     // copy data

                            if ( bPrint )
                            {
                                const uint64_t entrySize = header_.format() == Header::StandardTiff? 12: 20;
                                const uint64_t address = dir_offset + 2 + i * entrySize;

                                out << Internal::indent(depth)
                                    << Internal::stringFormat(""%8u | %#06x %-25s |%10s |%9u |"",
                                        static_cast<size_t>(address), tag, tagName(tag).c_str(), typeName(type), count)
                                    <<(usePointer ? Internal::stringFormat(""%10u | "",(size_t)offset)
                                                  : Internal::stringFormat(""%10s | "",""""))
                                    ;
                                if ( isShortType(type) )
                                {
                                    for ( size_t k = 0 ; k < kount ; k++ )
                                    {
                                        out << sp << byteSwap2(buf, k*size, doSwap_);
                                        sp = "" "";
                                    }
                                }
                                else if ( isLongType(type) )
                                {
                                    for ( size_t k = 0 ; k < kount ; k++ )
                                    {
                                        out << sp << byteSwap4(buf, k*size, doSwap_);
                                        sp = "" "";
                                    }
                                }
                                else if ( isLongLongType(type) )
                                {
                                    for ( size_t k = 0 ; k < kount ; k++ )
                                    {
                                        out << sp << byteSwap8(buf, k*size, doSwap_);
                                        sp = "" "";
                                    }
                                }
                                else if ( isRationalType(type) )
                                {
                                    for ( size_t k = 0 ; k < kount ; k++ )
                                    {
                                        uint32_t a = byteSwap4(buf, k*size+0, doSwap_);
                                        uint32_t b = byteSwap4(buf, k*size+4, doSwap_);
                                        out << sp << a << ""/"" << b;
                                        sp = "" "";
                                    }
                                }
                                else if ( isStringType(type) )
                                    out << sp << Internal::binaryToString(makeSlice(buf, 0, static_cast<size_t>(kount)));

                                sp = kount == count ? """" : "" ..."";
                                out << sp << std::endl;

                                if ( option == kpsRecursive &&
                                        (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/ || type == tiffIfd || type == tiffIfd8) )
                                {
                                    for ( size_t k = 0 ; k < count ; k++ )
                                    {
                                        const size_t restore = io.tell();
                                        const uint64_t ifdOffset = type == tiffIfd8?
                                            byteSwap8(buf, k*size, doSwap_):
                                            byteSwap4(buf, k*size, doSwap_);

                                        printIFD(out, option, ifdOffset, depth);
                                        io.seek(restore, BasicIo::beg);
                                    }
                                }
                                else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ )
                                {
                                    if (Safe::add(count, offset) > io.size()) {
                                        throw Error(kerCorruptedMetadata);
                                    }

                                    const size_t restore = io.tell();
                                    io.seek(static_cast<int64>(offset), BasicIo::beg);  // position
                                    std::vector<byte> bytes(static_cast<size_t>(count)) ;  // allocate memory
                                    // TODO: once we have C++11 use bytes.data()
                                    const size_t read_bytes = io.read(&bytes[0], static_cast<long>(count));
                                    io.seek(restore, BasicIo::beg);
                                    // TODO: once we have C++11 use bytes.data()
                                    IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth);

                                }
                                else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10)
                                {
                                    size_t   restore = io.tell();  // save

                                    long jump= 10           ;
                                    byte     bytes[20]          ;
                                    const char* chars = (const char*) &bytes[0] ;
                                    io.seek(static_cast<int64>(dir_offset), BasicIo::beg);  // position
                                    io.read(bytes,jump    )     ;  // read
                                    bytes[jump]=0               ;
                                    if ( ::strcmp(""Nikon"",chars) == 0 )
                                    {
                                      // tag is an embedded tiff
                                      std::vector<byte> nikon_bytes(static_cast<size_t>(count - jump));

                                      io.read(&nikon_bytes.at(0), (long)nikon_bytes.size());
                                      MemIo memIo(&nikon_bytes.at(0), (long)count - jump); // create a file
                                      std::cerr << ""Nikon makernote"" << std::endl;
                                      // printTiffStructure(memIo,out,option,depth);
                                      // TODO: fix it
                                    }
                                    else
                                    {
                                        // tag is an IFD
                                        io.seek(0, BasicIo::beg);  // position
                                        std::cerr << ""makernote"" << std::endl;
                                        printIFD(out,option,offset,depth);
                                    }

                                    io.seek(restore,BasicIo::beg); // restore
                                }
                            }
                        }

                        const uint64_t nextDirOffset = readData(dataSize_);

                        dir_offset = tooBig ? 0 : nextDirOffset;
                        out.flush();
                    } while (dir_offset != 0);

                    if ( bPrint )
                        out << Internal::indent(depth) << ""END "" << io.path() << std::endl;
                }","void printIFD(std::ostream& VAR_0, PrintStructureOption VAR_1, uint64_t VAR_2, int VAR_3)
                {
                    BasicIo& VAR_4 = Image::io();

                    /* COMMENT_0 */
                    /* COMMENT_1 */
                    /* COMMENT_2 */
                    /* COMMENT_3 */
                    /* COMMENT_4 */
                    /* COMMENT_5 */
                    /* COMMENT_6 */
                    /* COMMENT_7 */
                    if (VAR_3 > 200) {
                      VAR_0 << Internal::indent(VAR_3) << ""Maximum indentation depth exceeded."" << std::endl;
                      return;
                    }

                    VAR_3++;
                    bool VAR_5  = true;

                    /* COMMENT_8 */
                    bool VAR_6 = true;

                    do
                    {
                        /* COMMENT_9 */
                        VAR_4.seek(VAR_7<int64>(VAR_2), BasicIo::beg);

                        const uint64_t VAR_8 = readData(VAR_9.format() == Header::StandardTiff? 2: 8);
                        const bool VAR_10 = VAR_8 > 500;

                        if ( VAR_5 && VAR_6 )
                        {
                            VAR_0 << Internal::indent(VAR_3) << ""STRUCTURE OF BIGTIFF FILE "" << VAR_4.path() << std::endl;
                            if (VAR_10)
                                VAR_0 << Internal::indent(VAR_3) << ""entries = "" << VAR_8 << std::endl;
                        }

                        if (VAR_10)
                            break;

                        /* COMMENT_10 */
                        for ( uint64_t VAR_11 = 0; VAR_11 < VAR_8; VAR_11 ++ )
                        {
                            if ( VAR_5 && VAR_6 )
                                VAR_0 << Internal::indent(VAR_3)
                                    << "" address |    tag                           |     ""
                                    << "" type |    count |    offset | value\n"";

                            VAR_5 = false;

                            const uint16_t VAR_12   = (uint16_t) readData(2);
                            const uint16_t VAR_13  = (uint16_t) readData(2);
                            const uint64_t VAR_14 = readData(VAR_15);
                            const DataBuf  VAR_16  = VAR_4.read(VAR_15);        /* COMMENT_11 */

                            std::string VAR_17 = """" ; /* COMMENT_12 */

                            /* COMMENT_13 */
                            /* COMMENT_14 */
                            const uint64_t VAR_18  = isStringType(VAR_13)? (VAR_14 > 32 ? 32 : VAR_14) /* COMMENT_15 */
                                                            : VAR_14 > 5              ? 5
                                                            : VAR_14
                                                            ;
                            const uint32_t VAR_19    = isStringType(VAR_13) ? 1 : 0;
                            const uint32_t VAR_20   = isStringType(VAR_13) ? 1
                                                  : is2ByteType(VAR_13)  ? 2
                                                  : is4ByteType(VAR_13)  ? 4
                                                  : is8ByteType(VAR_13)  ? 8
                                                  : 1;

                            /* COMMENT_16 */

                            /* COMMENT_17 */
                            /* COMMENT_18 */
                            /* COMMENT_19 */
                            /* COMMENT_20 */
                            if (VAR_14 != 0) {
                                if (VAR_20 > std::numeric_limits<uint64_t>::max() / VAR_14) {
                                    throw Error(VAR_21);             /* COMMENT_21 */
                                }
                            }
                                                             /* COMMENT_22 */

                            if (VAR_20 * VAR_14 > std::numeric_limits<uint64_t>::max() - VAR_19)
                                throw Error(VAR_21);             /* COMMENT_23 */

                            const uint64_t VAR_22 = VAR_20*VAR_14 + VAR_19;
                            if ( VAR_22 > VAR_4.size() ) {
                                throw Error(VAR_21);
                            }

                            DataBuf buf(static_cast<long>(allocate));

                            const uint64_t VAR_23 = VAR_9.format() == Header::StandardTiff?
                                    byteSwap4(VAR_16, 0, VAR_24):
                                    byteSwap8(VAR_16, 0, VAR_24);

                            /* COMMENT_24 */
                            const bool VAR_25 = (size_t) VAR_14*VAR_20 > (size_t) VAR_15;

                            if ( VAR_25 )                          /* COMMENT_25 */
                            {
                                size_t   VAR_26 = VAR_4.tell();          /* COMMENT_26 */
                                VAR_4.seek(static_cast<int64>(VAR_23), BasicIo::beg);         /* COMMENT_27 */
                                VAR_4.read(VAR_27.pData_, (long) VAR_14 * VAR_20);     /* COMMENT_28 */
                                VAR_4.seek(VAR_26, BasicIo::beg);        /* COMMENT_29 */
                            }
                            else  /* COMMENT_30 */
                                std::memcpy(VAR_27.pData_, VAR_16.pData_, (size_t) VAR_14 * VAR_20);     /* COMMENT_31 */

                            if ( VAR_6 )
                            {
                                const uint64_t VAR_28 = VAR_9.format() == Header::StandardTiff? 12: 20;
                                const uint64_t VAR_29 = VAR_2 + 2 + VAR_11 * VAR_28;

                                VAR_0 << Internal::indent(VAR_3)
                                    << Internal::stringFormat(""%8u | %#06x %-25s |%10s |%9u |"",
                                        static_cast<size_t>(VAR_29), VAR_12, tagName(VAR_12).c_str(), typeName(VAR_13), VAR_14)
                                    <<(VAR_25 ? Internal::stringFormat(""%10u | "",(size_t)VAR_23)
                                                  : Internal::stringFormat(""%10s | "",""""))
                                    ;
                                if ( isShortType(VAR_13) )
                                {
                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )
                                    {
                                        VAR_0 << VAR_17 << byteSwap2(VAR_27, VAR_30*VAR_20, VAR_24);
                                        VAR_17 = "" "";
                                    }
                                }
                                else if ( isLongType(VAR_13) )
                                {
                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )
                                    {
                                        VAR_0 << VAR_17 << byteSwap4(VAR_27, VAR_30*VAR_20, VAR_24);
                                        VAR_17 = "" "";
                                    }
                                }
                                else if ( isLongLongType(VAR_13) )
                                {
                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )
                                    {
                                        VAR_0 << VAR_17 << byteSwap8(VAR_27, VAR_30*VAR_20, VAR_24);
                                        VAR_17 = "" "";
                                    }
                                }
                                else if ( isRationalType(VAR_13) )
                                {
                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_18 ; VAR_30++ )
                                    {
                                        uint32_t VAR_31 = byteSwap4(VAR_27, VAR_30*VAR_20+0, VAR_24);
                                        uint32_t VAR_32 = byteSwap4(VAR_27, VAR_30*VAR_20+4, VAR_24);
                                        VAR_0 << VAR_17 << VAR_31 << ""/"" << VAR_32;
                                        VAR_17 = "" "";
                                    }
                                }
                                else if ( isStringType(VAR_13) )
                                    VAR_0 << VAR_17 << Internal::binaryToString(makeSlice(VAR_27, 0, static_cast<size_t>(VAR_18)));

                                VAR_17 = VAR_18 == VAR_14 ? """" : "" ..."";
                                VAR_0 << VAR_17 << std::endl;

                                if ( VAR_1 == VAR_33 &&
                                        (VAR_12 == 0x8769 /* COMMENT_32 */ || VAR_12 == 0x014a/* COMMENT_33 */ || VAR_13 == VAR_34 || VAR_13 == VAR_35) )
                                {
                                    for ( size_t VAR_30 = 0 ; VAR_30 < VAR_14 ; VAR_30++ )
                                    {
                                        const size_t VAR_26 = VAR_4.tell();
                                        const uint64_t VAR_36 = VAR_13 == VAR_35?
                                            byteSwap8(VAR_27, VAR_30*VAR_20, VAR_24):
                                            byteSwap4(VAR_27, VAR_30*VAR_20, VAR_24);

                                        printIFD(VAR_0, VAR_1, VAR_36, VAR_3);
                                        VAR_4.seek(VAR_26, BasicIo::beg);
                                    }
                                }
                                else if ( VAR_1 == VAR_33 && VAR_12 == 0x83bb /* COMMENT_34 */ )
                                {
                                    if (Safe::add(VAR_14, VAR_23) > VAR_4.size()) {
                                        throw Error(VAR_37);
                                    }

                                    const size_t VAR_26 = VAR_4.tell();
                                    VAR_4.seek(static_cast<int64>(VAR_23), BasicIo::beg);  /* COMMENT_27 */
                                    std::vector<byte> bytes(static_cast<size_t>(count)) ;  /* COMMENT_35 */
                                    /* COMMENT_36 */
                                    const size_t VAR_38 = VAR_4.read(&VAR_39[0], static_cast<long>(count));
                                    VAR_4.seek(VAR_26, BasicIo::beg);
                                    /* COMMENT_36 */
                                    IptcData::printStructure(VAR_0, makeSliceUntil(&VAR_39[0], VAR_38), VAR_3);

                                }
                                else if ( VAR_1 == VAR_33 && VAR_12 == 0x927c /* COMMENT_37 */ && count > 10)
                                {
                                    size_t   VAR_26 = VAR_4.tell();  /* COMMENT_26 */

                                    long VAR_40= 10           ;
                                    byte     VAR_39[20]          ;
                                    const char* VAR_41 = (const char*) &VAR_39[0] ;
                                    VAR_4.seek(static_cast<int64>(VAR_2), BasicIo::beg);  /* COMMENT_27 */
                                    VAR_4.read(VAR_39,VAR_40    )     ;  /* COMMENT_28 */
                                    VAR_39[VAR_40]=0               ;
                                    if ( ::strcmp(""Nikon"",VAR_41) == 0 )
                                    {
                                      /* COMMENT_38 */
                                      std::vector<byte> VAR_42(static_cast<size_t>(count - VAR_40));

                                      VAR_4.read(&VAR_42.at(0), (long)VAR_42.size());
                                      MemIo VAR_43(&VAR_42.at(0), (long)count - VAR_40); /* COMMENT_39 */
                                      std::cerr << ""Nikon makernote"" << std::endl;
                                      /* COMMENT_40 */
                                      /* COMMENT_41 */
                                    }
                                    else
                                    {
                                        /* COMMENT_42 */
                                        VAR_4.seek(0, BasicIo::beg);  /* COMMENT_27 */
                                        std::cerr << ""makernote"" << std::endl;
                                        printIFD(VAR_0,VAR_1,VAR_23,VAR_3);
                                    }

                                    VAR_4.seek(VAR_26,BasicIo::beg); /* COMMENT_29 */
                                }
                            }
                        }

                        const uint64_t VAR_44 = readData(VAR_15);

                        VAR_2 = VAR_10 ? 0 : VAR_44;
                        VAR_0.flush();
                    } while (VAR_2 != 0);

                    if ( VAR_6 )
                        VAR_0 << Internal::indent(VAR_3) << ""END "" << VAR_4.path() << std::endl;
                }",Exiv2/exiv2/a6765cf18b9bf9d79486946ecec8ef0e2de1ab7b/bigtiffimage.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,6 +5,11 @@
                     // Fix for https://github.com/Exiv2/exiv2/issues/712
                     // A malicious file can cause a very deep recursion, leading to
                     // stack exhaustion.
+                    // Note: 200 is an arbitrarily chosen cut-off value. The value
+                    // of depth determines the amount of indentation inserted by the
+                    // pretty-printer. The output starts to become unreadable as
+                    // soon as the indentation exceeds 80 characters or so. That's
+                    // why 200 ought to be a reasonable cut-off.
                     if (depth > 200) {
                       out << Internal::indent(depth) << ""Maximum indentation depth exceeded."" << std::endl;
                       return;","{'deleted_lines': [], 'added_lines': ['                    // Note: 200 is an arbitrarily chosen cut-off value. The value', '                    // of depth determines the amount of indentation inserted by the', '                    // pretty-printer. The output starts to become unreadable as', ""                    // soon as the indentation exceeds 80 characters or so. That's"", '                    // why 200 ought to be a reasonable cut-off.']}",True,An issue was discovered in Exiv2 0.27. There is infinite recursion at BigTiffImage::printIFD in the file bigtiffimage.cpp. This can be triggered by a crafted file. It allows an attacker to cause Denial of Service (Segmentation fault) or possibly have unspecified other impact.,8.8,HIGH,2,valid,2020-01-24T09:34:34Z,3
CVE-2020-7247,"['CWE-755', 'CWE-78']",AV:N/AC:L/Au:N/C:C/I:C/A:C,0,openbsd/src,"Fix a security vulnerability discovered by Qualys which can lead to a
privileges escalation on mbox deliveries and unprivileged code execution
on lmtp deliveries, due to a logic issue causing a sanity check to be
missed.

ok eric@, millert@",9dcfda045474d8903224d175907bfc29761dcb45,https://github.com/openbsd/src/commit/9dcfda045474d8903224d175907bfc29761dcb45,usr.sbin/smtpd/smtp_session.c,smtp_mailaddr,"static int
smtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,
const char *domain)
{
char   *p, *e;
if (line == NULL)
return (0);
if (*line != '<')
return (0);
e = strchr(line, '>');
if (e == NULL)
return (0);
*e++ = '\0';
while (*e == ' ')
e++;
*args = e;
if (!text_to_mailaddr(maddr, line + 1))
return (0);
p = strchr(maddr->user, ':');
if (p != NULL) {
p++;
memmove(maddr->user, p, strlen(p) + 1);
}
if (!valid_localpart(maddr->user) ||
!valid_domainpart(maddr->domain)) {
if (mailfrom && maddr->user[0] == '\0' && maddr->domain[0] == '\0')
return (1);
if (maddr->user[0] == '\0')
return (0);
if (maddr->domain[0] == '\0') {
(void)strlcpy(maddr->domain, domain,
sizeof(maddr->domain));
return (1);
}
return (0);
}
return (1);
}","static int
smtp_mailaddr(struct mailaddr *VAR_0, char *VAR_1, int VAR_2, char **VAR_3,
const char *VAR_4)
{
char   *VAR_5, *VAR_6;
if (VAR_1 == NULL)
return (0);
if (*VAR_1 != '<')
return (0);
VAR_6 = strchr(VAR_1, '>');
if (VAR_6 == NULL)
return (0);
*VAR_6++ = '\0';
while (*VAR_6 == ' ')
VAR_6++;
*VAR_3 = VAR_6;
if (!text_to_mailaddr(VAR_0, VAR_1 + 1))
return (0);
VAR_5 = strchr(VAR_0->user, ':');
if (VAR_5 != NULL) {
VAR_5++;
memmove(VAR_0->user, VAR_5, strlen(VAR_5) + 1);
}
if (!valid_localpart(VAR_0->user) ||
!valid_domainpart(VAR_0->domain)) {
if (VAR_2 && VAR_0->user[0] == '\0' && VAR_0->domain[0] == '\0')
return (1);
if (VAR_0->user[0] == '\0')
return (0);
if (VAR_0->domain[0] == '\0') {
(void)strlcpy(VAR_0->domain, VAR_4,
sizeof(VAR_0->domain));
return (1);
}
return (0);
}
return (1);
}",openbsd/src/9dcfda045474d8903224d175907bfc29761dcb45/smtp_session.c/vul/before/0.json,"static int
smtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,
    const char *domain)
{
	char   *p, *e;

	if (line == NULL)
		return (0);

	if (*line != '<')
		return (0);

	e = strchr(line, '>');
	if (e == NULL)
		return (0);
	*e++ = '\0';
	while (*e == ' ')
		e++;
	*args = e;

	if (!text_to_mailaddr(maddr, line + 1))
		return (0);

	p = strchr(maddr->user, ':');
	if (p != NULL) {
		p++;
		memmove(maddr->user, p, strlen(p) + 1);
	}

	/* accept empty return-path in MAIL FROM, required for bounces */
	if (mailfrom && maddr->user[0] == '\0' && maddr->domain[0] == '\0')
		return (1);

	/* no or invalid user-part, reject */
	if (maddr->user[0] == '\0' || !valid_localpart(maddr->user))
		return (0);

	/* no domain part, local user */
	if (maddr->domain[0] == '\0') {
		(void)strlcpy(maddr->domain, domain,
			sizeof(maddr->domain));
	}

	if (!valid_domainpart(maddr->domain))
		return (0);

	return (1);
}","static int
smtp_mailaddr(struct mailaddr *VAR_0, char *VAR_1, int VAR_2, char **VAR_3,
    const char *VAR_4)
{
	char   *VAR_5, *VAR_6;

	if (VAR_1 == NULL)
		return (0);

	if (*VAR_1 != '<')
		return (0);

	VAR_6 = strchr(VAR_1, '>');
	if (VAR_6 == NULL)
		return (0);
	*VAR_6++ = '\0';
	while (*VAR_6 == ' ')
		VAR_6++;
	*VAR_3 = VAR_6;

	if (!text_to_mailaddr(VAR_0, VAR_1 + 1))
		return (0);

	VAR_5 = strchr(VAR_0->user, ':');
	if (VAR_5 != NULL) {
		VAR_5++;
		memmove(VAR_0->user, VAR_5, strlen(VAR_5) + 1);
	}

	/* COMMENT_0 */
	if (VAR_2 && VAR_0->user[0] == '\0' && VAR_0->domain[0] == '\0')
		return (1);

	/* COMMENT_1 */
	if (VAR_0->user[0] == '\0' || !valid_localpart(VAR_0->user))
		return (0);

	/* COMMENT_2 */
	if (VAR_0->domain[0] == '\0') {
		(void)strlcpy(VAR_0->domain, VAR_4,
			sizeof(VAR_0->domain));
	}

	if (!valid_domainpart(VAR_0->domain))
		return (0);

	return (1);
}",openbsd/src/9dcfda045474d8903224d175907bfc29761dcb45/smtp_session.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -27,24 +27,22 @@
 		memmove(maddr->user, p, strlen(p) + 1);
 	}
 
-	if (!valid_localpart(maddr->user) ||
-	    !valid_domainpart(maddr->domain)) {
-		/* accept empty return-path in MAIL FROM, required for bounces */
-		if (mailfrom && maddr->user[0] == '\0' && maddr->domain[0] == '\0')
-			return (1);
+	/* accept empty return-path in MAIL FROM, required for bounces */
+	if (mailfrom && maddr->user[0] == '\0' && maddr->domain[0] == '\0')
+		return (1);
 
-		/* no user-part, reject */
-		if (maddr->user[0] == '\0')
-			return (0);
+	/* no or invalid user-part, reject */
+	if (maddr->user[0] == '\0' || !valid_localpart(maddr->user))
+		return (0);
 
-		/* no domain, local user */
-		if (maddr->domain[0] == '\0') {
-			(void)strlcpy(maddr->domain, domain,
-			    sizeof(maddr->domain));
-			return (1);
-		}
+	/* no domain part, local user */
+	if (maddr->domain[0] == '\0') {
+		(void)strlcpy(maddr->domain, domain,
+			sizeof(maddr->domain));
+	}
+
+	if (!valid_domainpart(maddr->domain))
 		return (0);
-	}
 
 	return (1);
 }","{'deleted_lines': ['\tif (!valid_localpart(maddr->user) ||', '\t    !valid_domainpart(maddr->domain)) {', '\t\t/* accept empty return-path in MAIL FROM, required for bounces */', ""\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')"", '\t\t\treturn (1);', '\t\t/* no user-part, reject */', ""\t\tif (maddr->user[0] == '\\0')"", '\t\t\treturn (0);', '\t\t/* no domain, local user */', ""\t\tif (maddr->domain[0] == '\\0') {"", '\t\t\t(void)strlcpy(maddr->domain, domain,', '\t\t\t    sizeof(maddr->domain));', '\t\t\treturn (1);', '\t\t}', '\t}'], 'added_lines': ['\t/* accept empty return-path in MAIL FROM, required for bounces */', ""\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')"", '\t\treturn (1);', '\t/* no or invalid user-part, reject */', ""\tif (maddr->user[0] == '\\0' || !valid_localpart(maddr->user))"", '\t\treturn (0);', '\t/* no domain part, local user */', ""\tif (maddr->domain[0] == '\\0') {"", '\t\t(void)strlcpy(maddr->domain, domain,', '\t\t\tsizeof(maddr->domain));', '\t}', '', '\tif (!valid_domainpart(maddr->domain))']}",True,"smtp_mailaddr in smtp_session.c in OpenSMTPD 6.6, as used in OpenBSD 6.6 and other products, allows remote attackers to execute arbitrary commands as root via a crafted SMTP session, as demonstrated by shell metacharacters in a MAIL FROM field. This affects the ""uncommented"" default configuration. The issue exists because of an incorrect return value upon failure of input validation.",9.8,CRITICAL,3,valid,2020-01-28T21:35:00Z,3
CVE-2020-8112,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,uclouvain/openjpeg,"opj_tcd_init_tile(): avoid integer overflow

That could lead to later assertion failures.

Fixes #1231 / CVE-2020-8112",05f9b91e60debda0e83977e5e63b2e66486f7074,https://github.com/uclouvain/openjpeg/commit/05f9b91e60debda0e83977e5e63b2e66486f7074,src/lib/openjp2/tcd.c,opj_tcd_init_tile,"static INLINE OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no,
OPJ_BOOL isEncoder, OPJ_FLOAT32 fraction, OPJ_SIZE_T sizeof_block,
opj_event_mgr_t* manager)
{
OPJ_UINT32(*l_gain_ptr)(OPJ_UINT32) = 00;
OPJ_UINT32 compno, resno, bandno, precno, cblkno;
opj_tcp_t * l_tcp = 00;
opj_cp_t * l_cp = 00;
opj_tcd_tile_t * l_tile = 00;
opj_tccp_t *l_tccp = 00;
opj_tcd_tilecomp_t *l_tilec = 00;
opj_image_comp_t * l_image_comp = 00;
opj_tcd_resolution_t *l_res = 00;
opj_tcd_band_t *l_band = 00;
opj_stepsize_t * l_step_size = 00;
opj_tcd_precinct_t *l_current_precinct = 00;
opj_image_t *l_image = 00;
OPJ_UINT32 p, q;
OPJ_UINT32 l_level_no;
OPJ_UINT32 l_pdx, l_pdy;
OPJ_UINT32 l_gain;
OPJ_INT32 l_x0b, l_y0b;
OPJ_UINT32 l_tx0, l_ty0;
OPJ_INT32 l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end, l_br_prc_y_end;
OPJ_UINT32 l_nb_precincts;
OPJ_UINT32 l_nb_precinct_size;
OPJ_UINT32 l_nb_code_blocks;
OPJ_UINT32 l_nb_code_blocks_size;
OPJ_UINT32 l_data_size;
l_cp = p_tcd->cp;
l_tcp = &(l_cp->tcps[p_tile_no]);
l_tile = p_tcd->tcd_image->tiles;
l_tccp = l_tcp->tccps;
l_tilec = l_tile->comps;
l_image = p_tcd->image;
l_image_comp = p_tcd->image->comps;
p = p_tile_no % l_cp->tw;       
q = p_tile_no / l_cp->tw;
l_tx0 = l_cp->tx0 + p *
l_cp->tdx; 
l_tile->x0 = (OPJ_INT32)opj_uint_max(l_tx0, l_image->x0);
l_tile->x1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_tx0, l_cp->tdx),
l_image->x1);
if ((l_tile->x0 < 0) || (l_tile->x1 <= l_tile->x0)) {
opj_event_msg(manager, EVT_ERROR, ""Tile X coordinates are not supported\n"");
return OPJ_FALSE;
}
l_ty0 = l_cp->ty0 + q *
l_cp->tdy; 
l_tile->y0 = (OPJ_INT32)opj_uint_max(l_ty0, l_image->y0);
l_tile->y1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_ty0, l_cp->tdy),
l_image->y1);
if ((l_tile->y0 < 0) || (l_tile->y1 <= l_tile->y0)) {
opj_event_msg(manager, EVT_ERROR, ""Tile Y coordinates are not supported\n"");
return OPJ_FALSE;
}
if (l_tccp->numresolutions == 0) {
opj_event_msg(manager, EVT_ERROR, ""tiles require at least one resolution\n"");
return OPJ_FALSE;
}
for (compno = 0; compno < l_tile->numcomps; ++compno) {
l_image_comp->resno_decoded = 0;
l_tilec->x0 = opj_int_ceildiv(l_tile->x0, (OPJ_INT32)l_image_comp->dx);
l_tilec->y0 = opj_int_ceildiv(l_tile->y0, (OPJ_INT32)l_image_comp->dy);
l_tilec->x1 = opj_int_ceildiv(l_tile->x1, (OPJ_INT32)l_image_comp->dx);
l_tilec->y1 = opj_int_ceildiv(l_tile->y1, (OPJ_INT32)l_image_comp->dy);
l_tilec->compno = compno;
l_tilec->numresolutions = l_tccp->numresolutions;
if (l_tccp->numresolutions < l_cp->m_specific_param.m_dec.m_reduce) {
l_tilec->minimum_num_resolutions = 1;
} else {
l_tilec->minimum_num_resolutions = l_tccp->numresolutions -
l_cp->m_specific_param.m_dec.m_reduce;
}
if (isEncoder) {
OPJ_SIZE_T l_tile_data_size;
OPJ_SIZE_T w = (OPJ_SIZE_T)(l_tilec->x1 - l_tilec->x0);
OPJ_SIZE_T h = (OPJ_SIZE_T)(l_tilec->y1 - l_tilec->y0);
if (h > 0 && w > SIZE_MAX / h) {
opj_event_msg(manager, EVT_ERROR, ""Size of tile data exceeds system limits\n"");
return OPJ_FALSE;
}
l_tile_data_size = w * h;
if (SIZE_MAX / sizeof(OPJ_UINT32) < l_tile_data_size) {
opj_event_msg(manager, EVT_ERROR, ""Size of tile data exceeds system limits\n"");
return OPJ_FALSE;
}
l_tile_data_size = l_tile_data_size * sizeof(OPJ_UINT32);
l_tilec->data_size_needed = l_tile_data_size;
}
l_data_size = l_tilec->numresolutions * (OPJ_UINT32)sizeof(
opj_tcd_resolution_t);
opj_image_data_free(l_tilec->data_win);
l_tilec->data_win = NULL;
l_tilec->win_x0 = 0;
l_tilec->win_y0 = 0;
l_tilec->win_x1 = 0;
l_tilec->win_y1 = 0;
if (l_tilec->resolutions == 00) {
l_tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(l_data_size);
if (! l_tilec->resolutions) {
return OPJ_FALSE;
}
l_tilec->resolutions_size = l_data_size;
memset(l_tilec->resolutions, 0, l_data_size);
} else if (l_data_size > l_tilec->resolutions_size) {
opj_tcd_resolution_t* new_resolutions = (opj_tcd_resolution_t *) opj_realloc(
l_tilec->resolutions, l_data_size);
if (! new_resolutions) {
opj_event_msg(manager, EVT_ERROR, ""Not enough memory for tile resolutions\n"");
opj_free(l_tilec->resolutions);
l_tilec->resolutions = NULL;
l_tilec->resolutions_size = 0;
return OPJ_FALSE;
}
l_tilec->resolutions = new_resolutions;
memset(((OPJ_BYTE*) l_tilec->resolutions) + l_tilec->resolutions_size, 0,
l_data_size - l_tilec->resolutions_size);
l_tilec->resolutions_size = l_data_size;
}
l_level_no = l_tilec->numresolutions;
l_res = l_tilec->resolutions;
l_step_size = l_tccp->stepsizes;
if (l_tccp->qmfbid == 0) {
l_gain_ptr = &opj_dwt_getgain_real;
} else {
l_gain_ptr  = &opj_dwt_getgain;
}
for (resno = 0; resno < l_tilec->numresolutions; ++resno) {
OPJ_INT32 tlcbgxstart, tlcbgystart ;
OPJ_UINT32 cbgwidthexpn, cbgheightexpn;
OPJ_UINT32 cblkwidthexpn, cblkheightexpn;
--l_level_no;
l_res->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);
l_res->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);
l_res->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);
l_res->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);
l_pdx = l_tccp->prcw[resno];
l_pdy = l_tccp->prch[resno];
l_tl_prc_x_start = opj_int_floordivpow2(l_res->x0, (OPJ_INT32)l_pdx) << l_pdx;
l_tl_prc_y_start = opj_int_floordivpow2(l_res->y0, (OPJ_INT32)l_pdy) << l_pdy;
l_br_prc_x_end = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32)l_pdx) << l_pdx;
l_br_prc_y_end = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32)l_pdy) << l_pdy;
l_res->pw = (l_res->x0 == l_res->x1) ? 0U : (OPJ_UINT32)((
l_br_prc_x_end - l_tl_prc_x_start) >> l_pdx);
l_res->ph = (l_res->y0 == l_res->y1) ? 0U : (OPJ_UINT32)((
l_br_prc_y_end - l_tl_prc_y_start) >> l_pdy);
if ((l_res->pw != 0U) && ((((OPJ_UINT32) - 1) / l_res->pw) < l_res->ph)) {
opj_event_msg(manager, EVT_ERROR, ""Size of tile data exceeds system limits\n"");
return OPJ_FALSE;
}
l_nb_precincts = l_res->pw * l_res->ph;
if ((((OPJ_UINT32) - 1) / (OPJ_UINT32)sizeof(opj_tcd_precinct_t)) <
l_nb_precincts) {
opj_event_msg(manager, EVT_ERROR, ""Size of tile data exceeds system limits\n"");
return OPJ_FALSE;
}
l_nb_precinct_size = l_nb_precincts * (OPJ_UINT32)sizeof(opj_tcd_precinct_t);
if (resno == 0) {
tlcbgxstart = l_tl_prc_x_start;
tlcbgystart = l_tl_prc_y_start;
cbgwidthexpn = l_pdx;
cbgheightexpn = l_pdy;
l_res->numbands = 1;
} else {
tlcbgxstart = opj_int_ceildivpow2(l_tl_prc_x_start, 1);
tlcbgystart = opj_int_ceildivpow2(l_tl_prc_y_start, 1);
cbgwidthexpn = l_pdx - 1;
cbgheightexpn = l_pdy - 1;
l_res->numbands = 3;
}
cblkwidthexpn = opj_uint_min(l_tccp->cblkw, cbgwidthexpn);
cblkheightexpn = opj_uint_min(l_tccp->cblkh, cbgheightexpn);
l_band = l_res->bands;
for (bandno = 0; bandno < l_res->numbands; ++bandno, ++l_band, ++l_step_size) {
OPJ_INT32 numbps;
if (resno == 0) {
l_band->bandno = 0 ;
l_band->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);
l_band->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);
l_band->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);
l_band->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);
} else {
l_band->bandno = bandno + 1;
l_x0b = l_band->bandno & 1;
l_y0b = (OPJ_INT32)((l_band->bandno) >> 1);
l_band->x0 = opj_int64_ceildivpow2(l_tilec->x0 - ((OPJ_INT64)l_x0b <<
l_level_no), (OPJ_INT32)(l_level_no + 1));
l_band->y0 = opj_int64_ceildivpow2(l_tilec->y0 - ((OPJ_INT64)l_y0b <<
l_level_no), (OPJ_INT32)(l_level_no + 1));
l_band->x1 = opj_int64_ceildivpow2(l_tilec->x1 - ((OPJ_INT64)l_x0b <<
l_level_no), (OPJ_INT32)(l_level_no + 1));
l_band->y1 = opj_int64_ceildivpow2(l_tilec->y1 - ((OPJ_INT64)l_y0b <<
l_level_no), (OPJ_INT32)(l_level_no + 1));
}
if (isEncoder) {
if (opj_tcd_is_band_empty(l_band)) {
continue;
}
}
l_gain = (*l_gain_ptr)(l_band->bandno);
numbps = (OPJ_INT32)(l_image_comp->prec + l_gain);
l_band->stepsize = (OPJ_FLOAT32)(((1.0 + l_step_size->mant / 2048.0) * pow(2.0,
(OPJ_INT32)(numbps - l_step_size->expn)))) * fraction;
l_band->numbps = l_step_size->expn + (OPJ_INT32)l_tccp->numgbits -
1;
if (!l_band->precincts && (l_nb_precincts > 0U)) {
l_band->precincts = (opj_tcd_precinct_t *) opj_malloc(
l_nb_precinct_size);
if (! l_band->precincts) {
opj_event_msg(manager, EVT_ERROR,
""Not enough memory to handle band precints\n"");
return OPJ_FALSE;
}
memset(l_band->precincts, 0, l_nb_precinct_size);
l_band->precincts_data_size = l_nb_precinct_size;
} else if (l_band->precincts_data_size < l_nb_precinct_size) {
opj_tcd_precinct_t * new_precincts = (opj_tcd_precinct_t *) opj_realloc(
l_band->precincts, l_nb_precinct_size);
if (! new_precincts) {
opj_event_msg(manager, EVT_ERROR,
""Not enough memory to handle band precints\n"");
opj_free(l_band->precincts);
l_band->precincts = NULL;
l_band->precincts_data_size = 0;
return OPJ_FALSE;
}
l_band->precincts = new_precincts;
memset(((OPJ_BYTE *) l_band->precincts) + l_band->precincts_data_size, 0,
l_nb_precinct_size - l_band->precincts_data_size);
l_band->precincts_data_size = l_nb_precinct_size;
}
l_current_precinct = l_band->precincts;
for (precno = 0; precno < l_nb_precincts; ++precno) {
OPJ_INT32 tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;
OPJ_INT32 cbgxstart = tlcbgxstart + (OPJ_INT32)(precno % l_res->pw) *
(1 << cbgwidthexpn);
OPJ_INT32 cbgystart = tlcbgystart + (OPJ_INT32)(precno / l_res->pw) *
(1 << cbgheightexpn);
OPJ_INT32 cbgxend = cbgxstart + (1 << cbgwidthexpn);
OPJ_INT32 cbgyend = cbgystart + (1 << cbgheightexpn);
l_current_precinct->x0 = opj_int_max(cbgxstart, l_band->x0);
l_current_precinct->y0 = opj_int_max(cbgystart, l_band->y0);
l_current_precinct->x1 = opj_int_min(cbgxend, l_band->x1);
l_current_precinct->y1 = opj_int_min(cbgyend, l_band->y1);
tlcblkxstart = opj_int_floordivpow2(l_current_precinct->x0,
(OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;
tlcblkystart = opj_int_floordivpow2(l_current_precinct->y0,
(OPJ_INT32)cblkheightexpn) << cblkheightexpn;
brcblkxend = opj_int_ceildivpow2(l_current_precinct->x1,
(OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;
brcblkyend = opj_int_ceildivpow2(l_current_precinct->y1,
(OPJ_INT32)cblkheightexpn) << cblkheightexpn;
l_current_precinct->cw = (OPJ_UINT32)((brcblkxend - tlcblkxstart) >>
cblkwidthexpn);
l_current_precinct->ch = (OPJ_UINT32)((brcblkyend - tlcblkystart) >>
cblkheightexpn);
l_nb_code_blocks = l_current_precinct->cw * l_current_precinct->ch;
if ((((OPJ_UINT32) - 1) / (OPJ_UINT32)sizeof_block) <
l_nb_code_blocks) {
opj_event_msg(manager, EVT_ERROR,
""Size of code block data exceeds system limits\n"");
return OPJ_FALSE;
}
l_nb_code_blocks_size = l_nb_code_blocks * (OPJ_UINT32)sizeof_block;
if (!l_current_precinct->cblks.blocks && (l_nb_code_blocks > 0U)) {
l_current_precinct->cblks.blocks = opj_malloc(l_nb_code_blocks_size);
if (! l_current_precinct->cblks.blocks) {
return OPJ_FALSE;
}
memset(l_current_precinct->cblks.blocks, 0, l_nb_code_blocks_size);
l_current_precinct->block_size = l_nb_code_blocks_size;
} else if (l_nb_code_blocks_size > l_current_precinct->block_size) {
void *new_blocks = opj_realloc(l_current_precinct->cblks.blocks,
l_nb_code_blocks_size);
if (! new_blocks) {
opj_free(l_current_precinct->cblks.blocks);
l_current_precinct->cblks.blocks = NULL;
l_current_precinct->block_size = 0;
opj_event_msg(manager, EVT_ERROR,
""Not enough memory for current precinct codeblock element\n"");
return OPJ_FALSE;
}
l_current_precinct->cblks.blocks = new_blocks;
memset(((OPJ_BYTE *) l_current_precinct->cblks.blocks) +
l_current_precinct->block_size
, 0
, l_nb_code_blocks_size - l_current_precinct->block_size);
l_current_precinct->block_size = l_nb_code_blocks_size;
}
if (! l_current_precinct->incltree) {
l_current_precinct->incltree = opj_tgt_create(l_current_precinct->cw,
l_current_precinct->ch, manager);
} else {
l_current_precinct->incltree = opj_tgt_init(l_current_precinct->incltree,
l_current_precinct->cw, l_current_precinct->ch, manager);
}
if (! l_current_precinct->imsbtree) {
l_current_precinct->imsbtree = opj_tgt_create(l_current_precinct->cw,
l_current_precinct->ch, manager);
} else {
l_current_precinct->imsbtree = opj_tgt_init(l_current_precinct->imsbtree,
l_current_precinct->cw, l_current_precinct->ch, manager);
}
for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {
OPJ_INT32 cblkxstart = tlcblkxstart + (OPJ_INT32)(cblkno %
l_current_precinct->cw) * (1 << cblkwidthexpn);
OPJ_INT32 cblkystart = tlcblkystart + (OPJ_INT32)(cblkno /
l_current_precinct->cw) * (1 << cblkheightexpn);
OPJ_INT32 cblkxend = cblkxstart + (1 << cblkwidthexpn);
OPJ_INT32 cblkyend = cblkystart + (1 << cblkheightexpn);
if (isEncoder) {
opj_tcd_cblk_enc_t* l_code_block = l_current_precinct->cblks.enc + cblkno;
if (! opj_tcd_code_block_enc_allocate(l_code_block)) {
return OPJ_FALSE;
}
l_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);
l_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);
l_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);
l_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);
if (! opj_tcd_code_block_enc_allocate_data(l_code_block)) {
return OPJ_FALSE;
}
} else {
opj_tcd_cblk_dec_t* l_code_block = l_current_precinct->cblks.dec + cblkno;
if (! opj_tcd_code_block_dec_allocate(l_code_block)) {
return OPJ_FALSE;
}
l_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);
l_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);
l_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);
l_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);
}
}
++l_current_precinct;
} 
} 
++l_res;
} 
++l_tccp;
++l_tilec;
++l_image_comp;
} 
return OPJ_TRUE;
}","static INLINE VAR_0 opj_tcd_init_tile(opj_tcd_t *VAR_1, OPJ_UINT32 VAR_2,
OPJ_BOOL VAR_3, OPJ_FLOAT32 VAR_4, OPJ_SIZE_T VAR_5,
opj_event_mgr_t* VAR_6)
{
OPJ_UINT32(*VAR_7)(OPJ_UINT32) = 00;
OPJ_UINT32 VAR_8, VAR_9, VAR_10, VAR_11, VAR_12;
opj_tcp_t * VAR_13 = 00;
opj_cp_t * VAR_14 = 00;
opj_tcd_tile_t * VAR_15 = 00;
opj_tccp_t *VAR_16 = 00;
opj_tcd_tilecomp_t *VAR_17 = 00;
opj_image_comp_t * VAR_18 = 00;
opj_tcd_resolution_t *VAR_19 = 00;
opj_tcd_band_t *VAR_20 = 00;
opj_stepsize_t * VAR_21 = 00;
opj_tcd_precinct_t *VAR_22 = 00;
opj_image_t *VAR_23 = 00;
OPJ_UINT32 VAR_24, VAR_25;
OPJ_UINT32 VAR_26;
OPJ_UINT32 VAR_27, VAR_28;
OPJ_UINT32 VAR_29;
OPJ_INT32 VAR_30, VAR_31;
OPJ_UINT32 VAR_32, VAR_33;
OPJ_INT32 VAR_34, VAR_35, VAR_36, VAR_37;
OPJ_UINT32 VAR_38;
OPJ_UINT32 VAR_39;
OPJ_UINT32 VAR_40;
OPJ_UINT32 VAR_41;
OPJ_UINT32 VAR_42;
VAR_14 = VAR_1->cp;
VAR_13 = &(VAR_14->tcps[VAR_2]);
VAR_15 = VAR_1->tcd_image->tiles;
VAR_16 = VAR_13->tccps;
VAR_17 = VAR_15->comps;
VAR_23 = VAR_1->image;
VAR_18 = VAR_1->image->comps;
VAR_24 = VAR_2 % VAR_14->tw;       
VAR_25 = VAR_2 / VAR_14->tw;
VAR_32 = VAR_14->tx0 + VAR_24 *
VAR_14->tdx; 
VAR_15->x0 = (OPJ_INT32)opj_uint_max(VAR_32, VAR_23->x0);
VAR_15->x1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(VAR_32, VAR_14->tdx),
VAR_23->x1);
if ((VAR_15->x0 < 0) || (VAR_15->x1 <= VAR_15->x0)) {
opj_event_msg(VAR_6, VAR_43, ""Tile X coordinates are not supported\n"");
return VAR_44;
}
VAR_33 = VAR_14->ty0 + VAR_25 *
VAR_14->tdy; 
VAR_15->y0 = (OPJ_INT32)opj_uint_max(VAR_33, VAR_23->y0);
VAR_15->y1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(VAR_33, VAR_14->tdy),
VAR_23->y1);
if ((VAR_15->y0 < 0) || (VAR_15->y1 <= VAR_15->y0)) {
opj_event_msg(VAR_6, VAR_43, ""Tile Y coordinates are not supported\n"");
return VAR_44;
}
if (VAR_16->numresolutions == 0) {
opj_event_msg(VAR_6, VAR_43, ""tiles require at least one resolution\n"");
return VAR_44;
}
for (VAR_8 = 0; VAR_8 < VAR_15->numcomps; ++VAR_8) {
VAR_18->resno_decoded = 0;
VAR_17->x0 = opj_int_ceildiv(VAR_15->x0, (OPJ_INT32)VAR_18->dx);
VAR_17->y0 = opj_int_ceildiv(VAR_15->y0, (OPJ_INT32)VAR_18->dy);
VAR_17->x1 = opj_int_ceildiv(VAR_15->x1, (OPJ_INT32)VAR_18->dx);
VAR_17->y1 = opj_int_ceildiv(VAR_15->y1, (OPJ_INT32)VAR_18->dy);
VAR_17->compno = VAR_8;
VAR_17->numresolutions = VAR_16->numresolutions;
if (VAR_16->numresolutions < VAR_14->m_specific_param.m_dec.m_reduce) {
VAR_17->minimum_num_resolutions = 1;
} else {
VAR_17->minimum_num_resolutions = VAR_16->numresolutions -
VAR_14->m_specific_param.m_dec.m_reduce;
}
if (VAR_3) {
OPJ_SIZE_T VAR_45;
OPJ_SIZE_T VAR_46 = (OPJ_SIZE_T)(VAR_17->x1 - VAR_17->x0);
OPJ_SIZE_T VAR_47 = (OPJ_SIZE_T)(VAR_17->y1 - VAR_17->y0);
if (VAR_47 > 0 && VAR_46 > VAR_48 / VAR_47) {
opj_event_msg(VAR_6, VAR_43, ""Size of tile data exceeds system limits\n"");
return VAR_44;
}
VAR_45 = VAR_46 * VAR_47;
if (VAR_48 / sizeof(OPJ_UINT32) < VAR_45) {
opj_event_msg(VAR_6, VAR_43, ""Size of tile data exceeds system limits\n"");
return VAR_44;
}
VAR_45 = VAR_45 * sizeof(OPJ_UINT32);
VAR_17->data_size_needed = VAR_45;
}
VAR_42 = VAR_17->numresolutions * (OPJ_UINT32)sizeof(
opj_tcd_resolution_t);
opj_image_data_free(VAR_17->data_win);
VAR_17->data_win = NULL;
VAR_17->win_x0 = 0;
VAR_17->win_y0 = 0;
VAR_17->win_x1 = 0;
VAR_17->win_y1 = 0;
if (VAR_17->resolutions == 00) {
VAR_17->resolutions = (opj_tcd_resolution_t *) opj_malloc(VAR_42);
if (! VAR_17->resolutions) {
return VAR_44;
}
VAR_17->resolutions_size = VAR_42;
memset(VAR_17->resolutions, 0, VAR_42);
} else if (VAR_42 > VAR_17->resolutions_size) {
opj_tcd_resolution_t* VAR_49 = (opj_tcd_resolution_t *) opj_realloc(
VAR_17->resolutions, VAR_42);
if (! VAR_49) {
opj_event_msg(VAR_6, VAR_43, ""Not enough memory for tile resolutions\n"");
opj_free(VAR_17->resolutions);
VAR_17->resolutions = NULL;
VAR_17->resolutions_size = 0;
return VAR_44;
}
VAR_17->resolutions = VAR_49;
memset(((OPJ_BYTE*) VAR_17->resolutions) + VAR_17->resolutions_size, 0,
VAR_42 - VAR_17->resolutions_size);
VAR_17->resolutions_size = VAR_42;
}
VAR_26 = VAR_17->numresolutions;
VAR_19 = VAR_17->resolutions;
VAR_21 = VAR_16->stepsizes;
if (VAR_16->qmfbid == 0) {
VAR_7 = &VAR_50;
} else {
VAR_7  = &VAR_51;
}
for (VAR_9 = 0; VAR_9 < VAR_17->numresolutions; ++VAR_9) {
OPJ_INT32 VAR_52, VAR_53 ;
OPJ_UINT32 VAR_54, VAR_55;
OPJ_UINT32 VAR_56, VAR_57;
--VAR_26;
VAR_19->x0 = opj_int_ceildivpow2(VAR_17->x0, (OPJ_INT32)VAR_26);
VAR_19->y0 = opj_int_ceildivpow2(VAR_17->y0, (OPJ_INT32)VAR_26);
VAR_19->x1 = opj_int_ceildivpow2(VAR_17->x1, (OPJ_INT32)VAR_26);
VAR_19->y1 = opj_int_ceildivpow2(VAR_17->y1, (OPJ_INT32)VAR_26);
VAR_27 = VAR_16->prcw[VAR_9];
VAR_28 = VAR_16->prch[VAR_9];
VAR_34 = opj_int_floordivpow2(VAR_19->x0, (OPJ_INT32)VAR_27) << VAR_27;
VAR_35 = opj_int_floordivpow2(VAR_19->y0, (OPJ_INT32)VAR_28) << VAR_28;
VAR_36 = opj_int_ceildivpow2(VAR_19->x1, (OPJ_INT32)VAR_27) << VAR_27;
VAR_37 = opj_int_ceildivpow2(VAR_19->y1, (OPJ_INT32)VAR_28) << VAR_28;
VAR_19->pw = (VAR_19->x0 == VAR_19->x1) ? 0U : (OPJ_UINT32)((
VAR_36 - VAR_34) >> VAR_27);
VAR_19->ph = (VAR_19->y0 == VAR_19->y1) ? 0U : (OPJ_UINT32)((
VAR_37 - VAR_35) >> VAR_28);
if ((VAR_19->pw != 0U) && ((((OPJ_UINT32) - 1) / VAR_19->pw) < VAR_19->ph)) {
opj_event_msg(VAR_6, VAR_43, ""Size of tile data exceeds system limits\n"");
return VAR_44;
}
VAR_38 = VAR_19->pw * VAR_19->ph;
if ((((OPJ_UINT32) - 1) / (OPJ_UINT32)sizeof(opj_tcd_precinct_t)) <
VAR_38) {
opj_event_msg(VAR_6, VAR_43, ""Size of tile data exceeds system limits\n"");
return VAR_44;
}
VAR_39 = VAR_38 * (OPJ_UINT32)sizeof(opj_tcd_precinct_t);
if (VAR_9 == 0) {
VAR_52 = VAR_34;
VAR_53 = VAR_35;
VAR_54 = VAR_27;
VAR_55 = VAR_28;
VAR_19->numbands = 1;
} else {
VAR_52 = opj_int_ceildivpow2(VAR_34, 1);
VAR_53 = opj_int_ceildivpow2(VAR_35, 1);
VAR_54 = VAR_27 - 1;
VAR_55 = VAR_28 - 1;
VAR_19->numbands = 3;
}
VAR_56 = opj_uint_min(VAR_16->cblkw, VAR_54);
VAR_57 = opj_uint_min(VAR_16->cblkh, VAR_55);
VAR_20 = VAR_19->bands;
for (VAR_10 = 0; VAR_10 < VAR_19->numbands; ++VAR_10, ++VAR_20, ++VAR_21) {
OPJ_INT32 VAR_58;
if (VAR_9 == 0) {
VAR_20->bandno = 0 ;
VAR_20->x0 = opj_int_ceildivpow2(VAR_17->x0, (OPJ_INT32)VAR_26);
VAR_20->y0 = opj_int_ceildivpow2(VAR_17->y0, (OPJ_INT32)VAR_26);
VAR_20->x1 = opj_int_ceildivpow2(VAR_17->x1, (OPJ_INT32)VAR_26);
VAR_20->y1 = opj_int_ceildivpow2(VAR_17->y1, (OPJ_INT32)VAR_26);
} else {
VAR_20->bandno = VAR_10 + 1;
VAR_30 = VAR_20->bandno & 1;
VAR_31 = (OPJ_INT32)((VAR_20->bandno) >> 1);
VAR_20->x0 = opj_int64_ceildivpow2(VAR_17->x0 - ((OPJ_INT64)VAR_30 <<
VAR_26), (OPJ_INT32)(VAR_26 + 1));
VAR_20->y0 = opj_int64_ceildivpow2(VAR_17->y0 - ((OPJ_INT64)VAR_31 <<
VAR_26), (OPJ_INT32)(VAR_26 + 1));
VAR_20->x1 = opj_int64_ceildivpow2(VAR_17->x1 - ((OPJ_INT64)VAR_30 <<
VAR_26), (OPJ_INT32)(VAR_26 + 1));
VAR_20->y1 = opj_int64_ceildivpow2(VAR_17->y1 - ((OPJ_INT64)VAR_31 <<
VAR_26), (OPJ_INT32)(VAR_26 + 1));
}
if (VAR_3) {
if (opj_tcd_is_band_empty(VAR_20)) {
continue;
}
}
VAR_29 = (*VAR_7)(VAR_20->bandno);
VAR_58 = (OPJ_INT32)(VAR_18->prec + VAR_29);
VAR_20->stepsize = (OPJ_FLOAT32)(((1.0 + VAR_21->mant / 2048.0) * pow(2.0,
(OPJ_INT32)(VAR_58 - VAR_21->expn)))) * VAR_4;
VAR_20->numbps = VAR_21->expn + (OPJ_INT32)VAR_16->numgbits -
1;
if (!VAR_20->precincts && (VAR_38 > 0U)) {
VAR_20->precincts = (opj_tcd_precinct_t *) opj_malloc(
VAR_39);
if (! VAR_20->precincts) {
opj_event_msg(VAR_6, VAR_43,
""Not enough memory to handle band precints\n"");
return VAR_44;
}
memset(VAR_20->precincts, 0, VAR_39);
VAR_20->precincts_data_size = VAR_39;
} else if (VAR_20->precincts_data_size < VAR_39) {
opj_tcd_precinct_t * VAR_59 = (opj_tcd_precinct_t *) opj_realloc(
VAR_20->precincts, VAR_39);
if (! VAR_59) {
opj_event_msg(VAR_6, VAR_43,
""Not enough memory to handle band precints\n"");
opj_free(VAR_20->precincts);
VAR_20->precincts = NULL;
VAR_20->precincts_data_size = 0;
return VAR_44;
}
VAR_20->precincts = VAR_59;
memset(((OPJ_BYTE *) VAR_20->precincts) + VAR_20->precincts_data_size, 0,
VAR_39 - VAR_20->precincts_data_size);
VAR_20->precincts_data_size = VAR_39;
}
VAR_22 = VAR_20->precincts;
for (VAR_11 = 0; VAR_11 < VAR_38; ++VAR_11) {
OPJ_INT32 VAR_60, VAR_61, VAR_62, VAR_63;
OPJ_INT32 VAR_64 = VAR_52 + (OPJ_INT32)(VAR_11 % VAR_19->pw) *
(1 << VAR_54);
OPJ_INT32 VAR_65 = VAR_53 + (OPJ_INT32)(VAR_11 / VAR_19->pw) *
(1 << VAR_55);
OPJ_INT32 VAR_66 = VAR_64 + (1 << VAR_54);
OPJ_INT32 VAR_67 = VAR_65 + (1 << VAR_55);
VAR_22->x0 = opj_int_max(VAR_64, VAR_20->x0);
VAR_22->y0 = opj_int_max(VAR_65, VAR_20->y0);
VAR_22->x1 = opj_int_min(VAR_66, VAR_20->x1);
VAR_22->y1 = opj_int_min(VAR_67, VAR_20->y1);
VAR_60 = opj_int_floordivpow2(VAR_22->x0,
(OPJ_INT32)VAR_56) << VAR_56;
VAR_61 = opj_int_floordivpow2(VAR_22->y0,
(OPJ_INT32)VAR_57) << VAR_57;
VAR_62 = opj_int_ceildivpow2(VAR_22->x1,
(OPJ_INT32)VAR_56) << VAR_56;
VAR_63 = opj_int_ceildivpow2(VAR_22->y1,
(OPJ_INT32)VAR_57) << VAR_57;
VAR_22->cw = (OPJ_UINT32)((VAR_62 - VAR_60) >>
VAR_56);
VAR_22->ch = (OPJ_UINT32)((VAR_63 - VAR_61) >>
VAR_57);
VAR_40 = VAR_22->cw * VAR_22->ch;
if ((((OPJ_UINT32) - 1) / (OPJ_UINT32)VAR_5) <
VAR_40) {
opj_event_msg(VAR_6, VAR_43,
""Size of code block data exceeds system limits\n"");
return VAR_44;
}
VAR_41 = VAR_40 * (OPJ_UINT32)VAR_5;
if (!VAR_22->cblks.blocks && (VAR_40 > 0U)) {
VAR_22->cblks.blocks = opj_malloc(VAR_41);
if (! VAR_22->cblks.blocks) {
return VAR_44;
}
memset(VAR_22->cblks.blocks, 0, VAR_41);
VAR_22->block_size = VAR_41;
} else if (VAR_41 > VAR_22->block_size) {
void *VAR_68 = opj_realloc(VAR_22->cblks.blocks,
VAR_41);
if (! VAR_68) {
opj_free(VAR_22->cblks.blocks);
VAR_22->cblks.blocks = NULL;
VAR_22->block_size = 0;
opj_event_msg(VAR_6, VAR_43,
""Not enough memory for current precinct codeblock element\n"");
return VAR_44;
}
VAR_22->cblks.blocks = VAR_68;
memset(((OPJ_BYTE *) VAR_22->cblks.blocks) +
VAR_22->block_size
, 0
, VAR_41 - VAR_22->block_size);
VAR_22->block_size = VAR_41;
}
if (! VAR_22->incltree) {
VAR_22->incltree = opj_tgt_create(VAR_22->cw,
VAR_22->ch, VAR_6);
} else {
VAR_22->incltree = opj_tgt_init(VAR_22->incltree,
VAR_22->cw, VAR_22->ch, VAR_6);
}
if (! VAR_22->imsbtree) {
VAR_22->imsbtree = opj_tgt_create(VAR_22->cw,
VAR_22->ch, VAR_6);
} else {
VAR_22->imsbtree = opj_tgt_init(VAR_22->imsbtree,
VAR_22->cw, VAR_22->ch, VAR_6);
}
for (VAR_12 = 0; VAR_12 < VAR_40; ++VAR_12) {
OPJ_INT32 VAR_69 = VAR_60 + (OPJ_INT32)(VAR_12 %
VAR_22->cw) * (1 << VAR_56);
OPJ_INT32 VAR_70 = VAR_61 + (OPJ_INT32)(VAR_12 /
VAR_22->cw) * (1 << VAR_57);
OPJ_INT32 VAR_71 = VAR_69 + (1 << VAR_56);
OPJ_INT32 VAR_72 = VAR_70 + (1 << VAR_57);
if (VAR_3) {
opj_tcd_cblk_enc_t* VAR_73 = VAR_22->cblks.enc + VAR_12;
if (! opj_tcd_code_block_enc_allocate(VAR_73)) {
return VAR_44;
}
VAR_73->x0 = opj_int_max(VAR_69, VAR_22->x0);
VAR_73->y0 = opj_int_max(VAR_70, VAR_22->y0);
VAR_73->x1 = opj_int_min(VAR_71, VAR_22->x1);
VAR_73->y1 = opj_int_min(VAR_72, VAR_22->y1);
if (! opj_tcd_code_block_enc_allocate_data(VAR_73)) {
return VAR_44;
}
} else {
opj_tcd_cblk_dec_t* VAR_73 = VAR_22->cblks.dec + VAR_12;
if (! opj_tcd_code_block_dec_allocate(VAR_73)) {
return VAR_44;
}
VAR_73->x0 = opj_int_max(VAR_69, VAR_22->x0);
VAR_73->y0 = opj_int_max(VAR_70, VAR_22->y0);
VAR_73->x1 = opj_int_min(VAR_71, VAR_22->x1);
VAR_73->y1 = opj_int_min(VAR_72, VAR_22->y1);
}
}
++VAR_22;
} 
} 
++VAR_19;
} 
++VAR_16;
++VAR_17;
++VAR_18;
} 
return VAR_74;
}",,"static INLINE OPJ_BOOL opj_tcd_init_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no,
        OPJ_BOOL isEncoder, OPJ_FLOAT32 fraction, OPJ_SIZE_T sizeof_block,
        opj_event_mgr_t* manager)
{
    OPJ_UINT32(*l_gain_ptr)(OPJ_UINT32) = 00;
    OPJ_UINT32 compno, resno, bandno, precno, cblkno;
    opj_tcp_t * l_tcp = 00;
    opj_cp_t * l_cp = 00;
    opj_tcd_tile_t * l_tile = 00;
    opj_tccp_t *l_tccp = 00;
    opj_tcd_tilecomp_t *l_tilec = 00;
    opj_image_comp_t * l_image_comp = 00;
    opj_tcd_resolution_t *l_res = 00;
    opj_tcd_band_t *l_band = 00;
    opj_stepsize_t * l_step_size = 00;
    opj_tcd_precinct_t *l_current_precinct = 00;
    opj_image_t *l_image = 00;
    OPJ_UINT32 p, q;
    OPJ_UINT32 l_level_no;
    OPJ_UINT32 l_pdx, l_pdy;
    OPJ_UINT32 l_gain;
    OPJ_INT32 l_x0b, l_y0b;
    OPJ_UINT32 l_tx0, l_ty0;
    /* extent of precincts , top left, bottom right**/
    OPJ_INT32 l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end, l_br_prc_y_end;
    /* number of precinct for a resolution */
    OPJ_UINT32 l_nb_precincts;
    /* room needed to store l_nb_precinct precinct for a resolution */
    OPJ_UINT32 l_nb_precinct_size;
    /* number of code blocks for a precinct*/
    OPJ_UINT32 l_nb_code_blocks;
    /* room needed to store l_nb_code_blocks code blocks for a precinct*/
    OPJ_UINT32 l_nb_code_blocks_size;
    /* size of data for a tile */
    OPJ_UINT32 l_data_size;

    l_cp = p_tcd->cp;
    l_tcp = &(l_cp->tcps[p_tile_no]);
    l_tile = p_tcd->tcd_image->tiles;
    l_tccp = l_tcp->tccps;
    l_tilec = l_tile->comps;
    l_image = p_tcd->image;
    l_image_comp = p_tcd->image->comps;

    p = p_tile_no % l_cp->tw;       /* tile coordinates */
    q = p_tile_no / l_cp->tw;
    /*fprintf(stderr, ""Tile coordinate = %d,%d\n"", p, q);*/

    /* 4 borders of the tile rescale on the image if necessary */
    l_tx0 = l_cp->tx0 + p *
            l_cp->tdx; /* can't be greater than l_image->x1 so won't overflow */
    l_tile->x0 = (OPJ_INT32)opj_uint_max(l_tx0, l_image->x0);
    l_tile->x1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_tx0, l_cp->tdx),
                                         l_image->x1);
    /* all those OPJ_UINT32 are casted to OPJ_INT32, let's do some sanity check */
    if ((l_tile->x0 < 0) || (l_tile->x1 <= l_tile->x0)) {
        opj_event_msg(manager, EVT_ERROR, ""Tile X coordinates are not supported\n"");
        return OPJ_FALSE;
    }
    l_ty0 = l_cp->ty0 + q *
            l_cp->tdy; /* can't be greater than l_image->y1 so won't overflow */
    l_tile->y0 = (OPJ_INT32)opj_uint_max(l_ty0, l_image->y0);
    l_tile->y1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(l_ty0, l_cp->tdy),
                                         l_image->y1);
    /* all those OPJ_UINT32 are casted to OPJ_INT32, let's do some sanity check */
    if ((l_tile->y0 < 0) || (l_tile->y1 <= l_tile->y0)) {
        opj_event_msg(manager, EVT_ERROR, ""Tile Y coordinates are not supported\n"");
        return OPJ_FALSE;
    }


    /* testcase 1888.pdf.asan.35.988 */
    if (l_tccp->numresolutions == 0) {
        opj_event_msg(manager, EVT_ERROR, ""tiles require at least one resolution\n"");
        return OPJ_FALSE;
    }
    /*fprintf(stderr, ""Tile border = %d,%d,%d,%d\n"", l_tile->x0, l_tile->y0,l_tile->x1,l_tile->y1);*/

    /*tile->numcomps = image->numcomps; */
    for (compno = 0; compno < l_tile->numcomps; ++compno) {
        /*fprintf(stderr, ""compno = %d/%d\n"", compno, l_tile->numcomps);*/
        l_image_comp->resno_decoded = 0;
        /* border of each l_tile component (global) */
        l_tilec->x0 = opj_int_ceildiv(l_tile->x0, (OPJ_INT32)l_image_comp->dx);
        l_tilec->y0 = opj_int_ceildiv(l_tile->y0, (OPJ_INT32)l_image_comp->dy);
        l_tilec->x1 = opj_int_ceildiv(l_tile->x1, (OPJ_INT32)l_image_comp->dx);
        l_tilec->y1 = opj_int_ceildiv(l_tile->y1, (OPJ_INT32)l_image_comp->dy);
        l_tilec->compno = compno;
        /*fprintf(stderr, ""\tTile compo border = %d,%d,%d,%d\n"", l_tilec->x0, l_tilec->y0,l_tilec->x1,l_tilec->y1);*/

        l_tilec->numresolutions = l_tccp->numresolutions;
        if (l_tccp->numresolutions < l_cp->m_specific_param.m_dec.m_reduce) {
            l_tilec->minimum_num_resolutions = 1;
        } else {
            l_tilec->minimum_num_resolutions = l_tccp->numresolutions -
                                               l_cp->m_specific_param.m_dec.m_reduce;
        }

        if (isEncoder) {
            OPJ_SIZE_T l_tile_data_size;

            /* compute l_data_size with overflow check */
            OPJ_SIZE_T w = (OPJ_SIZE_T)(l_tilec->x1 - l_tilec->x0);
            OPJ_SIZE_T h = (OPJ_SIZE_T)(l_tilec->y1 - l_tilec->y0);

            /* issue 733, l_data_size == 0U, probably something wrong should be checked before getting here */
            if (h > 0 && w > SIZE_MAX / h) {
                opj_event_msg(manager, EVT_ERROR, ""Size of tile data exceeds system limits\n"");
                return OPJ_FALSE;
            }
            l_tile_data_size = w * h;

            if (SIZE_MAX / sizeof(OPJ_UINT32) < l_tile_data_size) {
                opj_event_msg(manager, EVT_ERROR, ""Size of tile data exceeds system limits\n"");
                return OPJ_FALSE;
            }
            l_tile_data_size = l_tile_data_size * sizeof(OPJ_UINT32);

            l_tilec->data_size_needed = l_tile_data_size;
        }

        l_data_size = l_tilec->numresolutions * (OPJ_UINT32)sizeof(
                          opj_tcd_resolution_t);

        opj_image_data_free(l_tilec->data_win);
        l_tilec->data_win = NULL;
        l_tilec->win_x0 = 0;
        l_tilec->win_y0 = 0;
        l_tilec->win_x1 = 0;
        l_tilec->win_y1 = 0;

        if (l_tilec->resolutions == 00) {
            l_tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(l_data_size);
            if (! l_tilec->resolutions) {
                return OPJ_FALSE;
            }
            /*fprintf(stderr, ""\tAllocate resolutions of tilec (opj_tcd_resolution_t): %d\n"",l_data_size);*/
            l_tilec->resolutions_size = l_data_size;
            memset(l_tilec->resolutions, 0, l_data_size);
        } else if (l_data_size > l_tilec->resolutions_size) {
            opj_tcd_resolution_t* new_resolutions = (opj_tcd_resolution_t *) opj_realloc(
                    l_tilec->resolutions, l_data_size);
            if (! new_resolutions) {
                opj_event_msg(manager, EVT_ERROR, ""Not enough memory for tile resolutions\n"");
                opj_free(l_tilec->resolutions);
                l_tilec->resolutions = NULL;
                l_tilec->resolutions_size = 0;
                return OPJ_FALSE;
            }
            l_tilec->resolutions = new_resolutions;
            /*fprintf(stderr, ""\tReallocate data of tilec (int): from %d to %d x OPJ_UINT32\n"", l_tilec->resolutions_size, l_data_size);*/
            memset(((OPJ_BYTE*) l_tilec->resolutions) + l_tilec->resolutions_size, 0,
                   l_data_size - l_tilec->resolutions_size);
            l_tilec->resolutions_size = l_data_size;
        }

        l_level_no = l_tilec->numresolutions;
        l_res = l_tilec->resolutions;
        l_step_size = l_tccp->stepsizes;
        if (l_tccp->qmfbid == 0) {
            l_gain_ptr = &opj_dwt_getgain_real;
        } else {
            l_gain_ptr  = &opj_dwt_getgain;
        }
        /*fprintf(stderr, ""\tlevel_no=%d\n"",l_level_no);*/

        for (resno = 0; resno < l_tilec->numresolutions; ++resno) {
            /*fprintf(stderr, ""\t\tresno = %d/%d\n"", resno, l_tilec->numresolutions);*/
            OPJ_INT32 tlcbgxstart, tlcbgystart /*, brcbgxend, brcbgyend*/;
            OPJ_UINT32 cbgwidthexpn, cbgheightexpn;
            OPJ_UINT32 cblkwidthexpn, cblkheightexpn;

            --l_level_no;

            /* border for each resolution level (global) */
            l_res->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);
            l_res->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);
            l_res->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);
            l_res->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);

            /*fprintf(stderr, ""\t\t\tres_x0= %d, res_y0 =%d, res_x1=%d, res_y1=%d\n"", l_res->x0, l_res->y0, l_res->x1, l_res->y1);*/
            /* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */
            l_pdx = l_tccp->prcw[resno];
            l_pdy = l_tccp->prch[resno];
            /*fprintf(stderr, ""\t\t\tpdx=%d, pdy=%d\n"", l_pdx, l_pdy);*/
            /* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */
            l_tl_prc_x_start = opj_int_floordivpow2(l_res->x0, (OPJ_INT32)l_pdx) << l_pdx;
            l_tl_prc_y_start = opj_int_floordivpow2(l_res->y0, (OPJ_INT32)l_pdy) << l_pdy;
            {
                OPJ_UINT32 tmp = ((OPJ_UINT32)opj_int_ceildivpow2(l_res->x1,
                                  (OPJ_INT32)l_pdx)) << l_pdx;
                if (tmp > (OPJ_UINT32)INT_MAX) {
                    opj_event_msg(manager, EVT_ERROR, ""Integer overflow\n"");
                    return OPJ_FALSE;
                }
                l_br_prc_x_end = (OPJ_INT32)tmp;
            }
            {
                OPJ_UINT32 tmp = ((OPJ_UINT32)opj_int_ceildivpow2(l_res->y1,
                                  (OPJ_INT32)l_pdy)) << l_pdy;
                if (tmp > (OPJ_UINT32)INT_MAX) {
                    opj_event_msg(manager, EVT_ERROR, ""Integer overflow\n"");
                    return OPJ_FALSE;
                }
                l_br_prc_y_end = (OPJ_INT32)tmp;
            }
            /*fprintf(stderr, ""\t\t\tprc_x_start=%d, prc_y_start=%d, br_prc_x_end=%d, br_prc_y_end=%d \n"", l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end ,l_br_prc_y_end );*/

            l_res->pw = (l_res->x0 == l_res->x1) ? 0U : (OPJ_UINT32)((
                            l_br_prc_x_end - l_tl_prc_x_start) >> l_pdx);
            l_res->ph = (l_res->y0 == l_res->y1) ? 0U : (OPJ_UINT32)((
                            l_br_prc_y_end - l_tl_prc_y_start) >> l_pdy);
            /*fprintf(stderr, ""\t\t\tres_pw=%d, res_ph=%d\n"", l_res->pw, l_res->ph );*/

            if ((l_res->pw != 0U) && ((((OPJ_UINT32) - 1) / l_res->pw) < l_res->ph)) {
                opj_event_msg(manager, EVT_ERROR, ""Size of tile data exceeds system limits\n"");
                return OPJ_FALSE;
            }
            l_nb_precincts = l_res->pw * l_res->ph;

            if ((((OPJ_UINT32) - 1) / (OPJ_UINT32)sizeof(opj_tcd_precinct_t)) <
                    l_nb_precincts) {
                opj_event_msg(manager, EVT_ERROR, ""Size of tile data exceeds system limits\n"");
                return OPJ_FALSE;
            }
            l_nb_precinct_size = l_nb_precincts * (OPJ_UINT32)sizeof(opj_tcd_precinct_t);

            if (resno == 0) {
                tlcbgxstart = l_tl_prc_x_start;
                tlcbgystart = l_tl_prc_y_start;
                /*brcbgxend = l_br_prc_x_end;*/
                /* brcbgyend = l_br_prc_y_end;*/
                cbgwidthexpn = l_pdx;
                cbgheightexpn = l_pdy;
                l_res->numbands = 1;
            } else {
                tlcbgxstart = opj_int_ceildivpow2(l_tl_prc_x_start, 1);
                tlcbgystart = opj_int_ceildivpow2(l_tl_prc_y_start, 1);
                /*brcbgxend = opj_int_ceildivpow2(l_br_prc_x_end, 1);*/
                /*brcbgyend = opj_int_ceildivpow2(l_br_prc_y_end, 1);*/
                cbgwidthexpn = l_pdx - 1;
                cbgheightexpn = l_pdy - 1;
                l_res->numbands = 3;
            }

            cblkwidthexpn = opj_uint_min(l_tccp->cblkw, cbgwidthexpn);
            cblkheightexpn = opj_uint_min(l_tccp->cblkh, cbgheightexpn);
            l_band = l_res->bands;

            for (bandno = 0; bandno < l_res->numbands; ++bandno, ++l_band, ++l_step_size) {
                OPJ_INT32 numbps;
                /*fprintf(stderr, ""\t\t\tband_no=%d/%d\n"", bandno, l_res->numbands );*/

                if (resno == 0) {
                    l_band->bandno = 0 ;
                    l_band->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);
                    l_band->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);
                    l_band->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);
                    l_band->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);
                } else {
                    l_band->bandno = bandno + 1;
                    /* x0b = 1 if bandno = 1 or 3 */
                    l_x0b = l_band->bandno & 1;
                    /* y0b = 1 if bandno = 2 or 3 */
                    l_y0b = (OPJ_INT32)((l_band->bandno) >> 1);
                    /* l_band border (global) */
                    l_band->x0 = opj_int64_ceildivpow2(l_tilec->x0 - ((OPJ_INT64)l_x0b <<
                                                       l_level_no), (OPJ_INT32)(l_level_no + 1));
                    l_band->y0 = opj_int64_ceildivpow2(l_tilec->y0 - ((OPJ_INT64)l_y0b <<
                                                       l_level_no), (OPJ_INT32)(l_level_no + 1));
                    l_band->x1 = opj_int64_ceildivpow2(l_tilec->x1 - ((OPJ_INT64)l_x0b <<
                                                       l_level_no), (OPJ_INT32)(l_level_no + 1));
                    l_band->y1 = opj_int64_ceildivpow2(l_tilec->y1 - ((OPJ_INT64)l_y0b <<
                                                       l_level_no), (OPJ_INT32)(l_level_no + 1));
                }

                if (isEncoder) {
                    /* Skip empty bands */
                    if (opj_tcd_is_band_empty(l_band)) {
                        /* Do not zero l_band->precints to avoid leaks */
                        /* but make sure we don't use it later, since */
                        /* it will point to precincts of previous bands... */
                        continue;
                    }
                }

                /** avoid an if with storing function pointer */
                l_gain = (*l_gain_ptr)(l_band->bandno);
                numbps = (OPJ_INT32)(l_image_comp->prec + l_gain);
                l_band->stepsize = (OPJ_FLOAT32)(((1.0 + l_step_size->mant / 2048.0) * pow(2.0,
                                                  (OPJ_INT32)(numbps - l_step_size->expn)))) * fraction;
                /* Mb value of Equation E-2 in ""E.1 Inverse quantization
                 * procedure"" of the standard */
                l_band->numbps = l_step_size->expn + (OPJ_INT32)l_tccp->numgbits -
                                 1;

                if (!l_band->precincts && (l_nb_precincts > 0U)) {
                    l_band->precincts = (opj_tcd_precinct_t *) opj_malloc(/*3 * */
                                            l_nb_precinct_size);
                    if (! l_band->precincts) {
                        opj_event_msg(manager, EVT_ERROR,
                                      ""Not enough memory to handle band precints\n"");
                        return OPJ_FALSE;
                    }
                    /*fprintf(stderr, ""\t\t\t\tAllocate precincts of a band (opj_tcd_precinct_t): %d\n"",l_nb_precinct_size);     */
                    memset(l_band->precincts, 0, l_nb_precinct_size);
                    l_band->precincts_data_size = l_nb_precinct_size;
                } else if (l_band->precincts_data_size < l_nb_precinct_size) {

                    opj_tcd_precinct_t * new_precincts = (opj_tcd_precinct_t *) opj_realloc(
                            l_band->precincts,/*3 * */ l_nb_precinct_size);
                    if (! new_precincts) {
                        opj_event_msg(manager, EVT_ERROR,
                                      ""Not enough memory to handle band precints\n"");
                        opj_free(l_band->precincts);
                        l_band->precincts = NULL;
                        l_band->precincts_data_size = 0;
                        return OPJ_FALSE;
                    }
                    l_band->precincts = new_precincts;
                    /*fprintf(stderr, ""\t\t\t\tReallocate precincts of a band (opj_tcd_precinct_t): from %d to %d\n"",l_band->precincts_data_size, l_nb_precinct_size);*/
                    memset(((OPJ_BYTE *) l_band->precincts) + l_band->precincts_data_size, 0,
                           l_nb_precinct_size - l_band->precincts_data_size);
                    l_band->precincts_data_size = l_nb_precinct_size;
                }

                l_current_precinct = l_band->precincts;
                for (precno = 0; precno < l_nb_precincts; ++precno) {
                    OPJ_INT32 tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;
                    OPJ_INT32 cbgxstart = tlcbgxstart + (OPJ_INT32)(precno % l_res->pw) *
                                          (1 << cbgwidthexpn);
                    OPJ_INT32 cbgystart = tlcbgystart + (OPJ_INT32)(precno / l_res->pw) *
                                          (1 << cbgheightexpn);
                    OPJ_INT32 cbgxend = cbgxstart + (1 << cbgwidthexpn);
                    OPJ_INT32 cbgyend = cbgystart + (1 << cbgheightexpn);
                    /*fprintf(stderr, ""\t precno=%d; bandno=%d, resno=%d; compno=%d\n"", precno, bandno , resno, compno);*/
                    /*fprintf(stderr, ""\t tlcbgxstart(=%d) + (precno(=%d) percent res->pw(=%d)) * (1 << cbgwidthexpn(=%d)) \n"",tlcbgxstart,precno,l_res->pw,cbgwidthexpn);*/

                    /* precinct size (global) */
                    /*fprintf(stderr, ""\t cbgxstart=%d, l_band->x0 = %d \n"",cbgxstart, l_band->x0);*/

                    l_current_precinct->x0 = opj_int_max(cbgxstart, l_band->x0);
                    l_current_precinct->y0 = opj_int_max(cbgystart, l_band->y0);
                    l_current_precinct->x1 = opj_int_min(cbgxend, l_band->x1);
                    l_current_precinct->y1 = opj_int_min(cbgyend, l_band->y1);
                    /*fprintf(stderr, ""\t prc_x0=%d; prc_y0=%d, prc_x1=%d; prc_y1=%d\n"",l_current_precinct->x0, l_current_precinct->y0 ,l_current_precinct->x1, l_current_precinct->y1);*/

                    tlcblkxstart = opj_int_floordivpow2(l_current_precinct->x0,
                                                        (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;
                    /*fprintf(stderr, ""\t tlcblkxstart =%d\n"",tlcblkxstart );*/
                    tlcblkystart = opj_int_floordivpow2(l_current_precinct->y0,
                                                        (OPJ_INT32)cblkheightexpn) << cblkheightexpn;
                    /*fprintf(stderr, ""\t tlcblkystart =%d\n"",tlcblkystart );*/
                    brcblkxend = opj_int_ceildivpow2(l_current_precinct->x1,
                                                     (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;
                    /*fprintf(stderr, ""\t brcblkxend =%d\n"",brcblkxend );*/
                    brcblkyend = opj_int_ceildivpow2(l_current_precinct->y1,
                                                     (OPJ_INT32)cblkheightexpn) << cblkheightexpn;
                    /*fprintf(stderr, ""\t brcblkyend =%d\n"",brcblkyend );*/
                    l_current_precinct->cw = (OPJ_UINT32)((brcblkxend - tlcblkxstart) >>
                                                          cblkwidthexpn);
                    l_current_precinct->ch = (OPJ_UINT32)((brcblkyend - tlcblkystart) >>
                                                          cblkheightexpn);

                    l_nb_code_blocks = l_current_precinct->cw * l_current_precinct->ch;
                    /*fprintf(stderr, ""\t\t\t\t precinct_cw = %d x recinct_ch = %d\n"",l_current_precinct->cw, l_current_precinct->ch);      */
                    if ((((OPJ_UINT32) - 1) / (OPJ_UINT32)sizeof_block) <
                            l_nb_code_blocks) {
                        opj_event_msg(manager, EVT_ERROR,
                                      ""Size of code block data exceeds system limits\n"");
                        return OPJ_FALSE;
                    }
                    l_nb_code_blocks_size = l_nb_code_blocks * (OPJ_UINT32)sizeof_block;

                    if (!l_current_precinct->cblks.blocks && (l_nb_code_blocks > 0U)) {
                        l_current_precinct->cblks.blocks = opj_malloc(l_nb_code_blocks_size);
                        if (! l_current_precinct->cblks.blocks) {
                            return OPJ_FALSE;
                        }
                        /*fprintf(stderr, ""\t\t\t\tAllocate cblks of a precinct (opj_tcd_cblk_dec_t): %d\n"",l_nb_code_blocks_size);*/

                        memset(l_current_precinct->cblks.blocks, 0, l_nb_code_blocks_size);

                        l_current_precinct->block_size = l_nb_code_blocks_size;
                    } else if (l_nb_code_blocks_size > l_current_precinct->block_size) {
                        void *new_blocks = opj_realloc(l_current_precinct->cblks.blocks,
                                                       l_nb_code_blocks_size);
                        if (! new_blocks) {
                            opj_free(l_current_precinct->cblks.blocks);
                            l_current_precinct->cblks.blocks = NULL;
                            l_current_precinct->block_size = 0;
                            opj_event_msg(manager, EVT_ERROR,
                                          ""Not enough memory for current precinct codeblock element\n"");
                            return OPJ_FALSE;
                        }
                        l_current_precinct->cblks.blocks = new_blocks;
                        /*fprintf(stderr, ""\t\t\t\tReallocate cblks of a precinct (opj_tcd_cblk_dec_t): from %d to %d\n"",l_current_precinct->block_size, l_nb_code_blocks_size);     */

                        memset(((OPJ_BYTE *) l_current_precinct->cblks.blocks) +
                               l_current_precinct->block_size
                               , 0
                               , l_nb_code_blocks_size - l_current_precinct->block_size);

                        l_current_precinct->block_size = l_nb_code_blocks_size;
                    }

                    if (! l_current_precinct->incltree) {
                        l_current_precinct->incltree = opj_tgt_create(l_current_precinct->cw,
                                                       l_current_precinct->ch, manager);
                    } else {
                        l_current_precinct->incltree = opj_tgt_init(l_current_precinct->incltree,
                                                       l_current_precinct->cw, l_current_precinct->ch, manager);
                    }

                    if (! l_current_precinct->imsbtree) {
                        l_current_precinct->imsbtree = opj_tgt_create(l_current_precinct->cw,
                                                       l_current_precinct->ch, manager);
                    } else {
                        l_current_precinct->imsbtree = opj_tgt_init(l_current_precinct->imsbtree,
                                                       l_current_precinct->cw, l_current_precinct->ch, manager);
                    }

                    for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {
                        OPJ_INT32 cblkxstart = tlcblkxstart + (OPJ_INT32)(cblkno %
                                               l_current_precinct->cw) * (1 << cblkwidthexpn);
                        OPJ_INT32 cblkystart = tlcblkystart + (OPJ_INT32)(cblkno /
                                               l_current_precinct->cw) * (1 << cblkheightexpn);
                        OPJ_INT32 cblkxend = cblkxstart + (1 << cblkwidthexpn);
                        OPJ_INT32 cblkyend = cblkystart + (1 << cblkheightexpn);

                        if (isEncoder) {
                            opj_tcd_cblk_enc_t* l_code_block = l_current_precinct->cblks.enc + cblkno;

                            if (! opj_tcd_code_block_enc_allocate(l_code_block)) {
                                return OPJ_FALSE;
                            }
                            /* code-block size (global) */
                            l_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);
                            l_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);
                            l_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);
                            l_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);

                            if (! opj_tcd_code_block_enc_allocate_data(l_code_block)) {
                                return OPJ_FALSE;
                            }
                        } else {
                            opj_tcd_cblk_dec_t* l_code_block = l_current_precinct->cblks.dec + cblkno;

                            if (! opj_tcd_code_block_dec_allocate(l_code_block)) {
                                return OPJ_FALSE;
                            }
                            /* code-block size (global) */
                            l_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);
                            l_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);
                            l_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);
                            l_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);
                        }
                    }
                    ++l_current_precinct;
                } /* precno */
            } /* bandno */
            ++l_res;
        } /* resno */
        ++l_tccp;
        ++l_tilec;
        ++l_image_comp;
    } /* compno */
    return OPJ_TRUE;
}","static INLINE VAR_0 opj_tcd_init_tile(opj_tcd_t *VAR_1, OPJ_UINT32 VAR_2,
        OPJ_BOOL VAR_3, OPJ_FLOAT32 VAR_4, OPJ_SIZE_T VAR_5,
        opj_event_mgr_t* VAR_6)
{
    OPJ_UINT32(*VAR_7)(OPJ_UINT32) = 00;
    OPJ_UINT32 VAR_8, VAR_9, VAR_10, VAR_11, VAR_12;
    opj_tcp_t * VAR_13 = 00;
    opj_cp_t * VAR_14 = 00;
    opj_tcd_tile_t * VAR_15 = 00;
    opj_tccp_t *VAR_16 = 00;
    opj_tcd_tilecomp_t *VAR_17 = 00;
    opj_image_comp_t * VAR_18 = 00;
    opj_tcd_resolution_t *VAR_19 = 00;
    opj_tcd_band_t *VAR_20 = 00;
    opj_stepsize_t * VAR_21 = 00;
    opj_tcd_precinct_t *VAR_22 = 00;
    opj_image_t *VAR_23 = 00;
    OPJ_UINT32 VAR_24, VAR_25;
    OPJ_UINT32 VAR_26;
    OPJ_UINT32 VAR_27, VAR_28;
    OPJ_UINT32 VAR_29;
    OPJ_INT32 VAR_30, VAR_31;
    OPJ_UINT32 VAR_32, VAR_33;
    /* COMMENT_0 */
    OPJ_INT32 VAR_34, VAR_35, VAR_36, VAR_37;
    /* COMMENT_1 */
    OPJ_UINT32 VAR_38;
    /* COMMENT_2 */
    OPJ_UINT32 VAR_39;
    /* COMMENT_3 */
    OPJ_UINT32 VAR_40;
    /* COMMENT_4 */
    OPJ_UINT32 VAR_41;
    /* COMMENT_5 */
    OPJ_UINT32 VAR_42;

    VAR_14 = VAR_1->cp;
    VAR_13 = &(VAR_14->tcps[VAR_2]);
    VAR_15 = VAR_1->tcd_image->tiles;
    VAR_16 = VAR_13->tccps;
    VAR_17 = VAR_15->comps;
    VAR_23 = VAR_1->image;
    VAR_18 = VAR_1->image->comps;

    VAR_24 = VAR_2 % VAR_14->tw;       /* COMMENT_6 */
    VAR_25 = VAR_2 / VAR_14->tw;
    /* COMMENT_7 */

    /* COMMENT_8 */
    VAR_32 = VAR_14->tx0 + VAR_24 *
            VAR_14->tdx; /* COMMENT_9 */
    VAR_15->x0 = (OPJ_INT32)opj_uint_max(VAR_32, VAR_23->x0);
    VAR_15->x1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(VAR_32, VAR_14->tdx),
                                         VAR_23->x1);
    /* COMMENT_10 */
    if ((VAR_15->x0 < 0) || (VAR_15->x1 <= VAR_15->x0)) {
        opj_event_msg(VAR_6, VAR_43, ""Tile X coordinates are not supported\n"");
        return VAR_44;
    }
    VAR_33 = VAR_14->ty0 + VAR_25 *
            VAR_14->tdy; /* COMMENT_11 */
    VAR_15->y0 = (OPJ_INT32)opj_uint_max(VAR_33, VAR_23->y0);
    VAR_15->y1 = (OPJ_INT32)opj_uint_min(opj_uint_adds(VAR_33, VAR_14->tdy),
                                         VAR_23->y1);
    /* COMMENT_10 */
    if ((VAR_15->y0 < 0) || (VAR_15->y1 <= VAR_15->y0)) {
        opj_event_msg(VAR_6, VAR_43, ""Tile Y coordinates are not supported\n"");
        return VAR_44;
    }


    /* COMMENT_12 */
    if (VAR_16->numresolutions == 0) {
        opj_event_msg(VAR_6, VAR_43, ""tiles require at least one resolution\n"");
        return VAR_44;
    }
    /* COMMENT_13 */

    /* COMMENT_14 */
    for (VAR_8 = 0; VAR_8 < VAR_15->numcomps; ++VAR_8) {
        /* COMMENT_15 */
        VAR_18->resno_decoded = 0;
        /* COMMENT_16 */
        VAR_17->x0 = opj_int_ceildiv(VAR_15->x0, (OPJ_INT32)VAR_18->dx);
        VAR_17->y0 = opj_int_ceildiv(VAR_15->y0, (OPJ_INT32)VAR_18->dy);
        VAR_17->x1 = opj_int_ceildiv(VAR_15->x1, (OPJ_INT32)VAR_18->dx);
        VAR_17->y1 = opj_int_ceildiv(VAR_15->y1, (OPJ_INT32)VAR_18->dy);
        VAR_17->compno = VAR_8;
        /* COMMENT_17 */

        VAR_17->numresolutions = VAR_16->numresolutions;
        if (VAR_16->numresolutions < VAR_14->m_specific_param.m_dec.m_reduce) {
            VAR_17->minimum_num_resolutions = 1;
        } else {
            VAR_17->minimum_num_resolutions = VAR_16->numresolutions -
                                               VAR_14->m_specific_param.m_dec.m_reduce;
        }

        if (VAR_3) {
            OPJ_SIZE_T VAR_45;

            /* COMMENT_18 */
            OPJ_SIZE_T VAR_46 = (OPJ_SIZE_T)(VAR_17->x1 - VAR_17->x0);
            OPJ_SIZE_T VAR_47 = (OPJ_SIZE_T)(VAR_17->y1 - VAR_17->y0);

            /* COMMENT_19 */
            if (VAR_47 > 0 && VAR_46 > VAR_48 / VAR_47) {
                opj_event_msg(VAR_6, VAR_43, ""Size of tile data exceeds system limits\n"");
                return VAR_44;
            }
            VAR_45 = VAR_46 * VAR_47;

            if (VAR_48 / sizeof(OPJ_UINT32) < VAR_45) {
                opj_event_msg(VAR_6, VAR_43, ""Size of tile data exceeds system limits\n"");
                return VAR_44;
            }
            VAR_45 = VAR_45 * sizeof(OPJ_UINT32);

            VAR_17->data_size_needed = VAR_45;
        }

        VAR_42 = VAR_17->numresolutions * (OPJ_UINT32)sizeof(
                          opj_tcd_resolution_t);

        opj_image_data_free(VAR_17->data_win);
        VAR_17->data_win = NULL;
        VAR_17->win_x0 = 0;
        VAR_17->win_y0 = 0;
        VAR_17->win_x1 = 0;
        VAR_17->win_y1 = 0;

        if (VAR_17->resolutions == 00) {
            VAR_17->resolutions = (opj_tcd_resolution_t *) opj_malloc(VAR_42);
            if (! VAR_17->resolutions) {
                return VAR_44;
            }
            /* COMMENT_20 */
            VAR_17->resolutions_size = VAR_42;
            memset(VAR_17->resolutions, 0, VAR_42);
        } else if (VAR_42 > VAR_17->resolutions_size) {
            opj_tcd_resolution_t* VAR_49 = (opj_tcd_resolution_t *) opj_realloc(
                    VAR_17->resolutions, VAR_42);
            if (! VAR_49) {
                opj_event_msg(VAR_6, VAR_43, ""Not enough memory for tile resolutions\n"");
                opj_free(VAR_17->resolutions);
                VAR_17->resolutions = NULL;
                VAR_17->resolutions_size = 0;
                return VAR_44;
            }
            VAR_17->resolutions = VAR_49;
            /* COMMENT_21 */
            memset(((OPJ_BYTE*) VAR_17->resolutions) + VAR_17->resolutions_size, 0,
                   VAR_42 - VAR_17->resolutions_size);
            VAR_17->resolutions_size = VAR_42;
        }

        VAR_26 = VAR_17->numresolutions;
        VAR_19 = VAR_17->resolutions;
        VAR_21 = VAR_16->stepsizes;
        if (VAR_16->qmfbid == 0) {
            VAR_7 = &VAR_50;
        } else {
            VAR_7  = &VAR_51;
        }
        /* COMMENT_22 */

        for (VAR_9 = 0; VAR_9 < VAR_17->numresolutions; ++VAR_9) {
            /* COMMENT_23 */
            OPJ_INT32 VAR_52, VAR_53 /* COMMENT_24 */;
            OPJ_UINT32 VAR_54, VAR_55;
            OPJ_UINT32 VAR_56, VAR_57;

            --VAR_26;

            /* COMMENT_25 */
            VAR_19->x0 = opj_int_ceildivpow2(VAR_17->x0, (OPJ_INT32)VAR_26);
            VAR_19->y0 = opj_int_ceildivpow2(VAR_17->y0, (OPJ_INT32)VAR_26);
            VAR_19->x1 = opj_int_ceildivpow2(VAR_17->x1, (OPJ_INT32)VAR_26);
            VAR_19->y1 = opj_int_ceildivpow2(VAR_17->y1, (OPJ_INT32)VAR_26);

            /* COMMENT_26 */
            /* COMMENT_27 */
            VAR_27 = VAR_16->prcw[VAR_9];
            VAR_28 = VAR_16->prch[VAR_9];
            /* COMMENT_28 */
            /* COMMENT_29 */
            VAR_34 = opj_int_floordivpow2(VAR_19->x0, (OPJ_INT32)VAR_27) << VAR_27;
            VAR_35 = opj_int_floordivpow2(VAR_19->y0, (OPJ_INT32)VAR_28) << VAR_28;
            {
                OPJ_UINT32 VAR_58 = ((OPJ_UINT32)opj_int_ceildivpow2(VAR_19->x1,
                                  (OPJ_INT32)VAR_27)) << VAR_27;
                if (VAR_58 > (OPJ_UINT32)VAR_59) {
                    opj_event_msg(VAR_6, VAR_43, ""Integer overflow\n"");
                    return VAR_44;
                }
                VAR_36 = (OPJ_INT32)VAR_58;
            }
            {
                OPJ_UINT32 VAR_58 = ((OPJ_UINT32)opj_int_ceildivpow2(VAR_19->y1,
                                  (OPJ_INT32)VAR_28)) << VAR_28;
                if (VAR_58 > (OPJ_UINT32)VAR_59) {
                    opj_event_msg(VAR_6, VAR_43, ""Integer overflow\n"");
                    return VAR_44;
                }
                VAR_37 = (OPJ_INT32)VAR_58;
            }
            /* COMMENT_30 */

            VAR_19->pw = (VAR_19->x0 == VAR_19->x1) ? 0U : (OPJ_UINT32)((
                            VAR_36 - VAR_34) >> VAR_27);
            VAR_19->ph = (VAR_19->y0 == VAR_19->y1) ? 0U : (OPJ_UINT32)((
                            VAR_37 - VAR_35) >> VAR_28);
            /* COMMENT_31 */

            if ((VAR_19->pw != 0U) && ((((OPJ_UINT32) - 1) / VAR_19->pw) < VAR_19->ph)) {
                opj_event_msg(VAR_6, VAR_43, ""Size of tile data exceeds system limits\n"");
                return VAR_44;
            }
            VAR_38 = VAR_19->pw * VAR_19->ph;

            if ((((OPJ_UINT32) - 1) / (OPJ_UINT32)sizeof(opj_tcd_precinct_t)) <
                    VAR_38) {
                opj_event_msg(VAR_6, VAR_43, ""Size of tile data exceeds system limits\n"");
                return VAR_44;
            }
            VAR_39 = VAR_38 * (OPJ_UINT32)sizeof(opj_tcd_precinct_t);

            if (VAR_9 == 0) {
                VAR_52 = VAR_34;
                VAR_53 = VAR_35;
                /* COMMENT_32 */
                /* COMMENT_33 */
                VAR_54 = VAR_27;
                VAR_55 = VAR_28;
                VAR_19->numbands = 1;
            } else {
                VAR_52 = opj_int_ceildivpow2(VAR_34, 1);
                VAR_53 = opj_int_ceildivpow2(VAR_35, 1);
                /* COMMENT_34 */
                /* COMMENT_35 */
                VAR_54 = VAR_27 - 1;
                VAR_55 = VAR_28 - 1;
                VAR_19->numbands = 3;
            }

            VAR_56 = opj_uint_min(VAR_16->cblkw, VAR_54);
            VAR_57 = opj_uint_min(VAR_16->cblkh, VAR_55);
            VAR_20 = VAR_19->bands;

            for (VAR_10 = 0; VAR_10 < VAR_19->numbands; ++VAR_10, ++VAR_20, ++VAR_21) {
                OPJ_INT32 VAR_60;
                /* COMMENT_36 */

                if (VAR_9 == 0) {
                    VAR_20->bandno = 0 ;
                    VAR_20->x0 = opj_int_ceildivpow2(VAR_17->x0, (OPJ_INT32)VAR_26);
                    VAR_20->y0 = opj_int_ceildivpow2(VAR_17->y0, (OPJ_INT32)VAR_26);
                    VAR_20->x1 = opj_int_ceildivpow2(VAR_17->x1, (OPJ_INT32)VAR_26);
                    VAR_20->y1 = opj_int_ceildivpow2(VAR_17->y1, (OPJ_INT32)VAR_26);
                } else {
                    VAR_20->bandno = VAR_10 + 1;
                    /* COMMENT_37 */
                    VAR_30 = VAR_20->bandno & 1;
                    /* COMMENT_38 */
                    VAR_31 = (OPJ_INT32)((VAR_20->bandno) >> 1);
                    /* COMMENT_39 */
                    VAR_20->x0 = opj_int64_ceildivpow2(VAR_17->x0 - ((OPJ_INT64)VAR_30 <<
                                                       VAR_26), (OPJ_INT32)(VAR_26 + 1));
                    VAR_20->y0 = opj_int64_ceildivpow2(VAR_17->y0 - ((OPJ_INT64)VAR_31 <<
                                                       VAR_26), (OPJ_INT32)(VAR_26 + 1));
                    VAR_20->x1 = opj_int64_ceildivpow2(VAR_17->x1 - ((OPJ_INT64)VAR_30 <<
                                                       VAR_26), (OPJ_INT32)(VAR_26 + 1));
                    VAR_20->y1 = opj_int64_ceildivpow2(VAR_17->y1 - ((OPJ_INT64)VAR_31 <<
                                                       VAR_26), (OPJ_INT32)(VAR_26 + 1));
                }

                if (VAR_3) {
                    /* COMMENT_40 */
                    if (opj_tcd_is_band_empty(VAR_20)) {
                        /* COMMENT_41 */
                        /* COMMENT_42 */
                        /* COMMENT_43 */
                        continue;
                    }
                }

                /* COMMENT_44 */
                VAR_29 = (*VAR_7)(VAR_20->bandno);
                VAR_60 = (OPJ_INT32)(VAR_18->prec + VAR_29);
                VAR_20->stepsize = (OPJ_FLOAT32)(((1.0 + VAR_21->mant / 2048.0) * pow(2.0,
                                                  (OPJ_INT32)(VAR_60 - VAR_21->expn)))) * VAR_4;
                /* COMMENT_45 */
                                                
                VAR_20->numbps = VAR_21->expn + (OPJ_INT32)VAR_16->numgbits -
                                 1;

                if (!VAR_20->precincts && (VAR_38 > 0U)) {
                    VAR_20->precincts = (opj_tcd_precinct_t *) opj_malloc(/* COMMENT_47 */
                                            VAR_39);
                    if (! VAR_20->precincts) {
                        opj_event_msg(VAR_6, VAR_43,
                                      ""Not enough memory to handle band precints\n"");
                        return VAR_44;
                    }
                    /* COMMENT_48 */
                    memset(VAR_20->precincts, 0, VAR_39);
                    VAR_20->precincts_data_size = VAR_39;
                } else if (VAR_20->precincts_data_size < VAR_39) {

                    opj_tcd_precinct_t * VAR_61 = (opj_tcd_precinct_t *) opj_realloc(
                            VAR_20->precincts,/* COMMENT_47 */ VAR_39);
                    if (! VAR_61) {
                        opj_event_msg(VAR_6, VAR_43,
                                      ""Not enough memory to handle band precints\n"");
                        opj_free(VAR_20->precincts);
                        VAR_20->precincts = NULL;
                        VAR_20->precincts_data_size = 0;
                        return VAR_44;
                    }
                    VAR_20->precincts = VAR_61;
                    /* COMMENT_49 */
                    memset(((OPJ_BYTE *) VAR_20->precincts) + VAR_20->precincts_data_size, 0,
                           VAR_39 - VAR_20->precincts_data_size);
                    VAR_20->precincts_data_size = VAR_39;
                }

                VAR_22 = VAR_20->precincts;
                for (VAR_11 = 0; VAR_11 < VAR_38; ++VAR_11) {
                    OPJ_INT32 VAR_62, VAR_63, VAR_64, VAR_65;
                    OPJ_INT32 VAR_66 = VAR_52 + (OPJ_INT32)(VAR_11 % VAR_19->pw) *
                                          (1 << VAR_54);
                    OPJ_INT32 VAR_67 = VAR_53 + (OPJ_INT32)(VAR_11 / VAR_19->pw) *
                                          (1 << VAR_55);
                    OPJ_INT32 VAR_68 = VAR_66 + (1 << VAR_54);
                    OPJ_INT32 VAR_69 = VAR_67 + (1 << VAR_55);
                    /* COMMENT_50 */
                    /* COMMENT_51 */

                    /* COMMENT_52 */
                    /* COMMENT_53 */

                    VAR_22->x0 = opj_int_max(VAR_66, VAR_20->x0);
                    VAR_22->y0 = opj_int_max(VAR_67, VAR_20->y0);
                    VAR_22->x1 = opj_int_min(VAR_68, VAR_20->x1);
                    VAR_22->y1 = opj_int_min(VAR_69, VAR_20->y1);
                    /* COMMENT_54 */

                    VAR_62 = opj_int_floordivpow2(VAR_22->x0,
                                                        (OPJ_INT32)VAR_56) << VAR_56;
                    /* COMMENT_55 */
                    VAR_63 = opj_int_floordivpow2(VAR_22->y0,
                                                        (OPJ_INT32)VAR_57) << VAR_57;
                    /* COMMENT_56 */
                    VAR_64 = opj_int_ceildivpow2(VAR_22->x1,
                                                     (OPJ_INT32)VAR_56) << VAR_56;
                    /* COMMENT_57 */
                    VAR_65 = opj_int_ceildivpow2(VAR_22->y1,
                                                     (OPJ_INT32)VAR_57) << VAR_57;
                    /* COMMENT_58 */
                    VAR_22->cw = (OPJ_UINT32)((VAR_64 - VAR_62) >>
                                                          VAR_56);
                    VAR_22->ch = (OPJ_UINT32)((VAR_65 - VAR_63) >>
                                                          VAR_57);

                    VAR_40 = VAR_22->cw * VAR_22->ch;
                    /* COMMENT_59 */
                    if ((((OPJ_UINT32) - 1) / (OPJ_UINT32)VAR_5) <
                            VAR_40) {
                        opj_event_msg(VAR_6, VAR_43,
                                      ""Size of code block data exceeds system limits\n"");
                        return VAR_44;
                    }
                    VAR_41 = VAR_40 * (OPJ_UINT32)VAR_5;

                    if (!VAR_22->cblks.blocks && (VAR_40 > 0U)) {
                        VAR_22->cblks.blocks = opj_malloc(VAR_41);
                        if (! VAR_22->cblks.blocks) {
                            return VAR_44;
                        }
                        /* COMMENT_60 */

                        memset(VAR_22->cblks.blocks, 0, VAR_41);

                        VAR_22->block_size = VAR_41;
                    } else if (VAR_41 > VAR_22->block_size) {
                        void *VAR_70 = opj_realloc(VAR_22->cblks.blocks,
                                                       VAR_41);
                        if (! VAR_70) {
                            opj_free(VAR_22->cblks.blocks);
                            VAR_22->cblks.blocks = NULL;
                            VAR_22->block_size = 0;
                            opj_event_msg(VAR_6, VAR_43,
                                          ""Not enough memory for current precinct codeblock element\n"");
                            return VAR_44;
                        }
                        VAR_22->cblks.blocks = VAR_70;
                        /* COMMENT_61 */

                        memset(((OPJ_BYTE *) VAR_22->cblks.blocks) +
                               VAR_22->block_size
                               , 0
                               , VAR_41 - VAR_22->block_size);

                        VAR_22->block_size = VAR_41;
                    }

                    if (! VAR_22->incltree) {
                        VAR_22->incltree = opj_tgt_create(VAR_22->cw,
                                                       VAR_22->ch, VAR_6);
                    } else {
                        VAR_22->incltree = opj_tgt_init(VAR_22->incltree,
                                                       VAR_22->cw, VAR_22->ch, VAR_6);
                    }

                    if (! VAR_22->imsbtree) {
                        VAR_22->imsbtree = opj_tgt_create(VAR_22->cw,
                                                       VAR_22->ch, VAR_6);
                    } else {
                        VAR_22->imsbtree = opj_tgt_init(VAR_22->imsbtree,
                                                       VAR_22->cw, VAR_22->ch, VAR_6);
                    }

                    for (VAR_12 = 0; VAR_12 < VAR_40; ++VAR_12) {
                        OPJ_INT32 VAR_71 = VAR_62 + (OPJ_INT32)(VAR_12 %
                                               VAR_22->cw) * (1 << VAR_56);
                        OPJ_INT32 VAR_72 = VAR_63 + (OPJ_INT32)(VAR_12 /
                                               VAR_22->cw) * (1 << VAR_57);
                        OPJ_INT32 VAR_73 = VAR_71 + (1 << VAR_56);
                        OPJ_INT32 VAR_74 = VAR_72 + (1 << VAR_57);

                        if (VAR_3) {
                            opj_tcd_cblk_enc_t* VAR_75 = VAR_22->cblks.enc + VAR_12;

                            if (! opj_tcd_code_block_enc_allocate(VAR_75)) {
                                return VAR_44;
                            }
                            /* COMMENT_62 */
                            VAR_75->x0 = opj_int_max(VAR_71, VAR_22->x0);
                            VAR_75->y0 = opj_int_max(VAR_72, VAR_22->y0);
                            VAR_75->x1 = opj_int_min(VAR_73, VAR_22->x1);
                            VAR_75->y1 = opj_int_min(VAR_74, VAR_22->y1);

                            if (! opj_tcd_code_block_enc_allocate_data(VAR_75)) {
                                return VAR_44;
                            }
                        } else {
                            opj_tcd_cblk_dec_t* VAR_75 = VAR_22->cblks.dec + VAR_12;

                            if (! opj_tcd_code_block_dec_allocate(VAR_75)) {
                                return VAR_44;
                            }
                            /* COMMENT_62 */
                            VAR_75->x0 = opj_int_max(VAR_71, VAR_22->x0);
                            VAR_75->y0 = opj_int_max(VAR_72, VAR_22->y0);
                            VAR_75->x1 = opj_int_min(VAR_73, VAR_22->x1);
                            VAR_75->y1 = opj_int_min(VAR_74, VAR_22->y1);
                        }
                    }
                    ++VAR_22;
                } /* COMMENT_63 */
            } /* COMMENT_64 */
            ++VAR_19;
        } /* COMMENT_65 */
        ++VAR_16;
        ++VAR_17;
        ++VAR_18;
    } /* COMMENT_66 */
    return VAR_76;
}",,"--- func_before
+++ func_after
@@ -186,8 +186,24 @@
             /* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */
             l_tl_prc_x_start = opj_int_floordivpow2(l_res->x0, (OPJ_INT32)l_pdx) << l_pdx;
             l_tl_prc_y_start = opj_int_floordivpow2(l_res->y0, (OPJ_INT32)l_pdy) << l_pdy;
-            l_br_prc_x_end = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32)l_pdx) << l_pdx;
-            l_br_prc_y_end = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32)l_pdy) << l_pdy;
+            {
+                OPJ_UINT32 tmp = ((OPJ_UINT32)opj_int_ceildivpow2(l_res->x1,
+                                  (OPJ_INT32)l_pdx)) << l_pdx;
+                if (tmp > (OPJ_UINT32)INT_MAX) {
+                    opj_event_msg(manager, EVT_ERROR, ""Integer overflow\n"");
+                    return OPJ_FALSE;
+                }
+                l_br_prc_x_end = (OPJ_INT32)tmp;
+            }
+            {
+                OPJ_UINT32 tmp = ((OPJ_UINT32)opj_int_ceildivpow2(l_res->y1,
+                                  (OPJ_INT32)l_pdy)) << l_pdy;
+                if (tmp > (OPJ_UINT32)INT_MAX) {
+                    opj_event_msg(manager, EVT_ERROR, ""Integer overflow\n"");
+                    return OPJ_FALSE;
+                }
+                l_br_prc_y_end = (OPJ_INT32)tmp;
+            }
             /*fprintf(stderr, ""\t\t\tprc_x_start=%d, prc_y_start=%d, br_prc_x_end=%d, br_prc_y_end=%d \n"", l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end ,l_br_prc_y_end );*/
 
             l_res->pw = (l_res->x0 == l_res->x1) ? 0U : (OPJ_UINT32)((","{'deleted_lines': ['            l_br_prc_x_end = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32)l_pdx) << l_pdx;', '            l_br_prc_y_end = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32)l_pdy) << l_pdy;'], 'added_lines': ['            {', '                OPJ_UINT32 tmp = ((OPJ_UINT32)opj_int_ceildivpow2(l_res->x1,', '                                  (OPJ_INT32)l_pdx)) << l_pdx;', '                if (tmp > (OPJ_UINT32)INT_MAX) {', '                    opj_event_msg(manager, EVT_ERROR, ""Integer overflow\\n"");', '                    return OPJ_FALSE;', '                }', '                l_br_prc_x_end = (OPJ_INT32)tmp;', '            }', '            {', '                OPJ_UINT32 tmp = ((OPJ_UINT32)opj_int_ceildivpow2(l_res->y1,', '                                  (OPJ_INT32)l_pdy)) << l_pdy;', '                if (tmp > (OPJ_UINT32)INT_MAX) {', '                    opj_event_msg(manager, EVT_ERROR, ""Integer overflow\\n"");', '                    return OPJ_FALSE;', '                }', '                l_br_prc_y_end = (OPJ_INT32)tmp;', '            }']}",True,"opj_t1_clbl_decode_processor in openjp2/t1.c in OpenJPEG 2.3.1 through 2020-01-28 has a heap-based buffer overflow in the qmfbid==1 case, a different issue than CVE-2020-6851.",8.8,HIGH,2,valid,2020-01-29T23:59:57Z,3
CVE-2019-19888,['CWE-369'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,rockcarry/ffjpeg,"fix issue #13, by dividing zero without sanity check in jfif.c",d6158811dbb4e97dc1cc9820ed0e846468366658,https://github.com/rockcarry/ffjpeg/commit/d6158811dbb4e97dc1cc9820ed0e846468366658,jfif.c,jfif_decode,"int jfif_decode(void *ctxt, BMP *pb)
{
JFIF *jfif    = (JFIF*)ctxt;
void *bs      = NULL;
int  *ftab[16]= {0};
int   dc[4]   = {0};
int   mcuw, mcuh, mcuc, mcur, mcui, jw, jh;
int   i, j, c, h, v, x, y;
int   sfh_max = 0;
int   sfv_max = 0;
int   yuv_stride[3] = {0};
int   yuv_height[3] = {0};
int  *yuv_datbuf[3] = {0};
int  *idst, *isrc;
int  *ysrc, *usrc, *vsrc;
BYTE *bdst;
int   ret = -1;
if (!ctxt || !pb) {
printf(""invalid input params !\n"");
return -1;
}
init_dct_module();
for (i=0; i<16; i++) {
if (jfif->pqtab[i]) {
ftab[i] = malloc(64 * sizeof(int));
if (ftab[i]) {
init_idct_ftab(ftab[i], jfif->pqtab[i]);
} else {
goto done;
}
}
}
for (c=0; c<jfif->comp_num; c++) {
if (sfh_max < jfif->comp_info[c].samp_factor_h) {
sfh_max = jfif->comp_info[c].samp_factor_h;
}
if (sfv_max < jfif->comp_info[c].samp_factor_v) {
sfv_max = jfif->comp_info[c].samp_factor_v;
}
}
mcuw = sfh_max * 8;
mcuh = sfv_max * 8;
jw = ALIGN(jfif->width , mcuw);
jh = ALIGN(jfif->height, mcuh);
mcuc = jw / mcuw;
mcur = jh / mcuh;
yuv_stride[0] = jw;
yuv_stride[1] = jw * jfif->comp_info[1].samp_factor_h / sfh_max;
yuv_stride[2] = jw * jfif->comp_info[2].samp_factor_h / sfh_max;
yuv_height[0] = jh;
yuv_height[1] = jh * jfif->comp_info[1].samp_factor_v / sfv_max;
yuv_height[2] = jh * jfif->comp_info[2].samp_factor_v / sfv_max;
yuv_datbuf[0] = malloc(yuv_stride[0] * yuv_height[0] * sizeof(int));
yuv_datbuf[1] = malloc(yuv_stride[1] * yuv_height[1] * sizeof(int));
yuv_datbuf[2] = malloc(yuv_stride[2] * yuv_height[2] * sizeof(int));
if (!yuv_datbuf[0] || !yuv_datbuf[1] || !yuv_datbuf[2]) {
goto done;
}
bs = bitstr_open(jfif->databuf, ""mem"", jfif->datalen);
if (!bs) {
printf(""failed to open bitstr for jfif_decode !"");
return -1;
}
for (i=0; i<16; i++) {
if (jfif->phcac[i]) {
jfif->phcac[i]->input = bs;
huffman_decode_init(jfif->phcac[i]);
}
if (jfif->phcdc[i]) {
jfif->phcdc[i]->input = bs;
huffman_decode_init(jfif->phcdc[i]);
}
}
for (mcui=0; mcui<mcuc*mcur; mcui++) {
for (c=0; c<jfif->comp_num; c++) {
for (v=0; v<jfif->comp_info[c].samp_factor_v; v++) {
for (h=0; h<jfif->comp_info[c].samp_factor_h; h++) {
HUFCODEC *hcac = jfif->phcac[jfif->comp_info[c].htab_idx_ac];
HUFCODEC *hcdc = jfif->phcdc[jfif->comp_info[c].htab_idx_dc];
int       fidx = jfif->comp_info[c].qtab_idx;
int size, znum, code;
int du[64] = {0};
size = huffman_decode_step(hcdc) & 0xf;
if (size) {
code = bitstr_get_bits(bs  , size);
code = category_decode(code, size);
}
else {
code = 0;
}
dc[c] += code;
du[0]  = dc[c];
for (i=1; i<64; ) {
code = huffman_decode_step(hcac);
if (code <= 0) break;
size = (code >> 0) & 0xf;
znum = (code >> 4) & 0xf;
i   += znum;
code = bitstr_get_bits(bs  , size);
code = category_decode(code, size);
if (i < 64) du[i++] = code;
}
zigzag_decode(du);
idct2d8x8(du, ftab[fidx]);
x    = ((mcui % mcuc) * mcuw + h * 8) * jfif->comp_info[c].samp_factor_h / sfh_max;
y    = ((mcui / mcuc) * mcuh + v * 8) * jfif->comp_info[c].samp_factor_v / sfv_max;
idst = yuv_datbuf[c] + y * yuv_stride[c] + x;
isrc = du;
for (i=0; i<8; i++) {
memcpy(idst, isrc, 8 * sizeof(int));
idst += yuv_stride[c];
isrc += 8;
}
}
}
}
}
for (i=0; i<16; i++) {
if (jfif->phcac[i]) huffman_decode_done(jfif->phcac[i]);
if (jfif->phcdc[i]) huffman_decode_done(jfif->phcdc[i]);
}
bitstr_close(bs);
bmp_create(pb, jfif->width, jfif->height);
bdst = (BYTE*)pb->pdata;
ysrc = yuv_datbuf[0];
for (i=0; i<jfif->height; i++) {
int uy = i * jfif->comp_info[1].samp_factor_v / sfv_max;
int vy = i * jfif->comp_info[2].samp_factor_v / sfv_max;
for (j=0; j<jfif->width; j++) {
int ux = j * jfif->comp_info[1].samp_factor_h / sfh_max;
int vx = j * jfif->comp_info[2].samp_factor_h / sfh_max;
usrc = yuv_datbuf[2] + uy * yuv_stride[2] + ux;
vsrc = yuv_datbuf[1] + vy * yuv_stride[1] + vx;
yuv_to_rgb(*ysrc, *vsrc, *usrc, bdst + 2, bdst + 1, bdst + 0);
bdst += 3;
ysrc += 1;
}
bdst -= jfif->width * 3;
bdst += pb->stride;
ysrc -= jfif->width * 1;
ysrc += yuv_stride[0];
}
ret = 0;
done:
if (yuv_datbuf[0]) free(yuv_datbuf[0]);
if (yuv_datbuf[1]) free(yuv_datbuf[1]);
if (yuv_datbuf[2]) free(yuv_datbuf[2]);
for (i=0; i<16; i++) {
if (ftab[i]) {
free(ftab[i]);
}
}
return ret;
}","int jfif_decode(void *VAR_0, BMP *VAR_1)
{
JFIF *VAR_2    = (JFIF*)VAR_0;
void *VAR_3      = NULL;
int  *VAR_4[16]= {0};
int   VAR_5[4]   = {0};
int   VAR_6, VAR_7, VAR_8, VAR_9, VAR_10, VAR_11, VAR_12;
int   VAR_13, VAR_14, VAR_15, VAR_16, VAR_17, VAR_18, VAR_19;
int   VAR_20 = 0;
int   VAR_21 = 0;
int   VAR_22[3] = {0};
int   VAR_23[3] = {0};
int  *VAR_24[3] = {0};
int  *VAR_25, *VAR_26;
int  *VAR_27, *VAR_28, *VAR_29;
BYTE *VAR_30;
int   VAR_31 = -1;
if (!VAR_0 || !VAR_1) {
printf(""invalid input params !\n"");
return -1;
}
init_dct_module();
for (VAR_13=0; VAR_13<16; VAR_13++) {
if (VAR_2->pqtab[VAR_13]) {
VAR_4[VAR_13] = malloc(64 * sizeof(int));
if (VAR_4[VAR_13]) {
init_idct_ftab(VAR_4[VAR_13], VAR_2->pqtab[VAR_13]);
} else {
goto done;
}
}
}
for (VAR_15=0; VAR_15<VAR_2->comp_num; VAR_15++) {
if (VAR_20 < VAR_2->comp_info[VAR_15].samp_factor_h) {
VAR_20 = VAR_2->comp_info[VAR_15].samp_factor_h;
}
if (VAR_21 < VAR_2->comp_info[VAR_15].samp_factor_v) {
VAR_21 = VAR_2->comp_info[VAR_15].samp_factor_v;
}
}
VAR_6 = VAR_20 * 8;
VAR_7 = VAR_21 * 8;
VAR_11 = ALIGN(VAR_2->width , VAR_6);
VAR_12 = ALIGN(VAR_2->height, VAR_7);
VAR_8 = VAR_11 / VAR_6;
VAR_9 = VAR_12 / VAR_7;
VAR_22[0] = VAR_11;
VAR_22[1] = VAR_11 * VAR_2->comp_info[1].samp_factor_h / VAR_20;
VAR_22[2] = VAR_11 * VAR_2->comp_info[2].samp_factor_h / VAR_20;
VAR_23[0] = VAR_12;
VAR_23[1] = VAR_12 * VAR_2->comp_info[1].samp_factor_v / VAR_21;
VAR_23[2] = VAR_12 * VAR_2->comp_info[2].samp_factor_v / VAR_21;
VAR_24[0] = malloc(VAR_22[0] * VAR_23[0] * sizeof(int));
VAR_24[1] = malloc(VAR_22[1] * VAR_23[1] * sizeof(int));
VAR_24[2] = malloc(VAR_22[2] * VAR_23[2] * sizeof(int));
if (!VAR_24[0] || !VAR_24[1] || !VAR_24[2]) {
goto done;
}
VAR_3 = bitstr_open(VAR_2->databuf, ""mem"", VAR_2->datalen);
if (!VAR_3) {
printf(""failed to open bitstr for jfif_decode !"");
return -1;
}
for (VAR_13=0; VAR_13<16; VAR_13++) {
if (VAR_2->phcac[VAR_13]) {
VAR_2->phcac[VAR_13]->input = VAR_3;
huffman_decode_init(VAR_2->phcac[VAR_13]);
}
if (VAR_2->phcdc[VAR_13]) {
VAR_2->phcdc[VAR_13]->input = VAR_3;
huffman_decode_init(VAR_2->phcdc[VAR_13]);
}
}
for (VAR_10=0; VAR_10<VAR_8*VAR_9; VAR_10++) {
for (VAR_15=0; VAR_15<VAR_2->comp_num; VAR_15++) {
for (VAR_17=0; VAR_17<VAR_2->comp_info[VAR_15].samp_factor_v; VAR_17++) {
for (VAR_16=0; VAR_16<VAR_2->comp_info[VAR_15].samp_factor_h; VAR_16++) {
HUFCODEC *VAR_32 = VAR_2->phcac[VAR_2->comp_info[VAR_15].htab_idx_ac];
HUFCODEC *VAR_33 = VAR_2->phcdc[VAR_2->comp_info[VAR_15].htab_idx_dc];
int       VAR_34 = VAR_2->comp_info[VAR_15].qtab_idx;
int VAR_35, VAR_36, VAR_37;
int VAR_38[64] = {0};
VAR_35 = huffman_decode_step(VAR_33) & 0xf;
if (VAR_35) {
VAR_37 = bitstr_get_bits(VAR_3  , VAR_35);
VAR_37 = category_decode(VAR_37, VAR_35);
}
else {
VAR_37 = 0;
}
VAR_5[VAR_15] += VAR_37;
VAR_38[0]  = VAR_5[VAR_15];
for (VAR_13=1; VAR_13<64; ) {
VAR_37 = huffman_decode_step(VAR_32);
if (VAR_37 <= 0) break;
VAR_35 = (VAR_37 >> 0) & 0xf;
VAR_36 = (VAR_37 >> 4) & 0xf;
VAR_13   += VAR_36;
VAR_37 = bitstr_get_bits(VAR_3  , VAR_35);
VAR_37 = category_decode(VAR_37, VAR_35);
if (VAR_13 < 64) VAR_38[VAR_13++] = VAR_37;
}
zigzag_decode(VAR_38);
idct2d8x8(VAR_38, VAR_4[VAR_34]);
VAR_18    = ((VAR_10 % VAR_8) * VAR_6 + VAR_16 * 8) * VAR_2->comp_info[VAR_15].samp_factor_h / VAR_20;
VAR_19    = ((VAR_10 / VAR_8) * VAR_7 + VAR_17 * 8) * VAR_2->comp_info[VAR_15].samp_factor_v / VAR_21;
VAR_25 = VAR_24[VAR_15] + VAR_19 * VAR_22[VAR_15] + VAR_18;
VAR_26 = VAR_38;
for (VAR_13=0; VAR_13<8; VAR_13++) {
memcpy(VAR_25, VAR_26, 8 * sizeof(int));
VAR_25 += VAR_22[VAR_15];
VAR_26 += 8;
}
}
}
}
}
for (VAR_13=0; VAR_13<16; VAR_13++) {
if (VAR_2->phcac[VAR_13]) huffman_decode_done(VAR_2->phcac[VAR_13]);
if (VAR_2->phcdc[VAR_13]) huffman_decode_done(VAR_2->phcdc[VAR_13]);
}
bitstr_close(VAR_3);
bmp_create(VAR_1, VAR_2->width, VAR_2->height);
VAR_30 = (BYTE*)VAR_1->pdata;
VAR_27 = VAR_24[0];
for (VAR_13=0; VAR_13<VAR_2->height; VAR_13++) {
int VAR_39 = VAR_13 * VAR_2->comp_info[1].samp_factor_v / VAR_21;
int VAR_40 = VAR_13 * VAR_2->comp_info[2].samp_factor_v / VAR_21;
for (VAR_14=0; VAR_14<VAR_2->width; VAR_14++) {
int VAR_41 = VAR_14 * VAR_2->comp_info[1].samp_factor_h / VAR_20;
int VAR_42 = VAR_14 * VAR_2->comp_info[2].samp_factor_h / VAR_20;
VAR_28 = VAR_24[2] + VAR_39 * VAR_22[2] + VAR_41;
VAR_29 = VAR_24[1] + VAR_40 * VAR_22[1] + VAR_42;
yuv_to_rgb(*VAR_27, *VAR_29, *VAR_28, VAR_30 + 2, VAR_30 + 1, VAR_30 + 0);
VAR_30 += 3;
VAR_27 += 1;
}
VAR_30 -= VAR_2->width * 3;
VAR_30 += VAR_1->stride;
VAR_27 -= VAR_2->width * 1;
VAR_27 += VAR_22[0];
}
VAR_31 = 0;
done:
if (VAR_24[0]) free(VAR_24[0]);
if (VAR_24[1]) free(VAR_24[1]);
if (VAR_24[2]) free(VAR_24[2]);
for (VAR_13=0; VAR_13<16; VAR_13++) {
if (VAR_4[VAR_13]) {
free(VAR_4[VAR_13]);
}
}
return VAR_31;
}",rockcarry/ffjpeg/d6158811dbb4e97dc1cc9820ed0e846468366658/jfif.c/vul/before/0.json,"int jfif_decode(void *ctxt, BMP *pb)
{
    JFIF *jfif    = (JFIF*)ctxt;
    void *bs      = NULL;
    int  *ftab[16]= {0};
    int   dc[4]   = {0};
    int   mcuw, mcuh, mcuc, mcur, mcui, jw, jh;
    int   i, j, c, h, v, x, y;
    int   sfh_max = 0;
    int   sfv_max = 0;
    int   yuv_stride[3] = {0};
    int   yuv_height[3] = {0};
    int  *yuv_datbuf[3] = {0};
    int  *idst, *isrc;
    int  *ysrc, *usrc, *vsrc;
    BYTE *bdst;
    int   ret = -1;

    if (!ctxt || !pb) {
        printf(""invalid input params !\n"");
        return -1;
    }

    // init dct module
    init_dct_module();

    //++ init ftab
    for (i=0; i<16; i++) {
        if (jfif->pqtab[i]) {
            ftab[i] = malloc(64 * sizeof(int));
            if (ftab[i]) {
                init_idct_ftab(ftab[i], jfif->pqtab[i]);
            } else {
                goto done;
            }
        }
    }
    //-- init ftab

    //++ calculate mcu info
    for (c=0; c<jfif->comp_num; c++) {
        if (sfh_max < jfif->comp_info[c].samp_factor_h) {
            sfh_max = jfif->comp_info[c].samp_factor_h;
        }
        if (sfv_max < jfif->comp_info[c].samp_factor_v) {
            sfv_max = jfif->comp_info[c].samp_factor_v;
        }
    }
    if (!sfh_max) sfh_max = 1;
    if (!sfv_max) sfv_max = 1;
    mcuw = sfh_max * 8;
    mcuh = sfv_max * 8;
    jw = ALIGN(jfif->width , mcuw);
    jh = ALIGN(jfif->height, mcuh);
    mcuc = jw / mcuw;
    mcur = jh / mcuh;
    //-- calculate mcu info

    // create yuv buffer for decoding
    yuv_stride[0] = jw;
    yuv_stride[1] = jw * jfif->comp_info[1].samp_factor_h / sfh_max;
    yuv_stride[2] = jw * jfif->comp_info[2].samp_factor_h / sfh_max;
    yuv_height[0] = jh;
    yuv_height[1] = jh * jfif->comp_info[1].samp_factor_v / sfv_max;
    yuv_height[2] = jh * jfif->comp_info[2].samp_factor_v / sfv_max;
    yuv_datbuf[0] = malloc(yuv_stride[0] * yuv_height[0] * sizeof(int));
    yuv_datbuf[1] = malloc(yuv_stride[1] * yuv_height[1] * sizeof(int));
    yuv_datbuf[2] = malloc(yuv_stride[2] * yuv_height[2] * sizeof(int));
    if (!yuv_datbuf[0] || !yuv_datbuf[1] || !yuv_datbuf[2]) {
        goto done;
    }

    // open bit stream
    bs = bitstr_open(jfif->databuf, ""mem"", jfif->datalen);
    if (!bs) {
        printf(""failed to open bitstr for jfif_decode !"");
        return -1;
    }

    // init huffman codec
    for (i=0; i<16; i++) {
        if (jfif->phcac[i]) {
            jfif->phcac[i]->input = bs;
            huffman_decode_init(jfif->phcac[i]);
        }
        if (jfif->phcdc[i]) {
            jfif->phcdc[i]->input = bs;
            huffman_decode_init(jfif->phcdc[i]);
        }
    }

    for (mcui=0; mcui<mcuc*mcur; mcui++) {
        for (c=0; c<jfif->comp_num; c++) {
            for (v=0; v<jfif->comp_info[c].samp_factor_v; v++) {
                for (h=0; h<jfif->comp_info[c].samp_factor_h; h++) {
                    HUFCODEC *hcac = jfif->phcac[jfif->comp_info[c].htab_idx_ac];
                    HUFCODEC *hcdc = jfif->phcdc[jfif->comp_info[c].htab_idx_dc];
                    int       fidx = jfif->comp_info[c].qtab_idx;
                    int size, znum, code;
                    int du[64] = {0};

                    //+ decode dc
                    size = huffman_decode_step(hcdc) & 0xf;
                    if (size) {
                        code = bitstr_get_bits(bs  , size);
                        code = category_decode(code, size);
                    }
                    else {
                        code = 0;
                    }
                    dc[c] += code;
                    du[0]  = dc[c];
                    //- decode dc

                    //+ decode ac
                    for (i=1; i<64; ) {
                        code = huffman_decode_step(hcac);
                        if (code <= 0) break;
                        size = (code >> 0) & 0xf;
                        znum = (code >> 4) & 0xf;
                        i   += znum;
                        code = bitstr_get_bits(bs  , size);
                        code = category_decode(code, size);
                        if (i < 64) du[i++] = code;
                    }
                    //- decode ac

                    // de-zigzag
                    zigzag_decode(du);

                    // idct
                    idct2d8x8(du, ftab[fidx]);

                    // copy du to yuv buffer
                    x    = ((mcui % mcuc) * mcuw + h * 8) * jfif->comp_info[c].samp_factor_h / sfh_max;
                    y    = ((mcui / mcuc) * mcuh + v * 8) * jfif->comp_info[c].samp_factor_v / sfv_max;
                    idst = yuv_datbuf[c] + y * yuv_stride[c] + x;
                    isrc = du;
                    for (i=0; i<8; i++) {
                        memcpy(idst, isrc, 8 * sizeof(int));
                        idst += yuv_stride[c];
                        isrc += 8;
                    }
                }
            }
        }
    }

    // close huffman codec
    for (i=0; i<16; i++) {
        if (jfif->phcac[i]) huffman_decode_done(jfif->phcac[i]);
        if (jfif->phcdc[i]) huffman_decode_done(jfif->phcdc[i]);
    }

    // close bit stream
    bitstr_close(bs);

    // create bitmap, and convert yuv to rgb
    bmp_create(pb, jfif->width, jfif->height);
    bdst = (BYTE*)pb->pdata;
    ysrc = yuv_datbuf[0];
    for (i=0; i<jfif->height; i++) {
        int uy = i * jfif->comp_info[1].samp_factor_v / sfv_max;
        int vy = i * jfif->comp_info[2].samp_factor_v / sfv_max;
        for (j=0; j<jfif->width; j++) {
            int ux = j * jfif->comp_info[1].samp_factor_h / sfh_max;
            int vx = j * jfif->comp_info[2].samp_factor_h / sfh_max;
            usrc = yuv_datbuf[2] + uy * yuv_stride[2] + ux;
            vsrc = yuv_datbuf[1] + vy * yuv_stride[1] + vx;
            yuv_to_rgb(*ysrc, *vsrc, *usrc, bdst + 2, bdst + 1, bdst + 0);
            bdst += 3;
            ysrc += 1;
        }
        bdst -= jfif->width * 3;
        bdst += pb->stride;
        ysrc -= jfif->width * 1;
        ysrc += yuv_stride[0];
    }

    // success
    ret = 0;

done:
    if (yuv_datbuf[0]) free(yuv_datbuf[0]);
    if (yuv_datbuf[1]) free(yuv_datbuf[1]);
    if (yuv_datbuf[2]) free(yuv_datbuf[2]);
    //++ free ftab
    for (i=0; i<16; i++) {
        if (ftab[i]) {
            free(ftab[i]);
        }
    }
    //-- free ftab
    return ret;
}","int jfif_decode(void *VAR_0, BMP *VAR_1)
{
    JFIF *VAR_2    = (JFIF*)VAR_0;
    void *VAR_3      = NULL;
    int  *VAR_4[16]= {0};
    int   VAR_5[4]   = {0};
    int   VAR_6, VAR_7, VAR_8, VAR_9, VAR_10, VAR_11, VAR_12;
    int   VAR_13, VAR_14, VAR_15, VAR_16, VAR_17, VAR_18, VAR_19;
    int   VAR_20 = 0;
    int   VAR_21 = 0;
    int   VAR_22[3] = {0};
    int   VAR_23[3] = {0};
    int  *VAR_24[3] = {0};
    int  *VAR_25, *VAR_26;
    int  *VAR_27, *VAR_28, *VAR_29;
    BYTE *VAR_30;
    int   VAR_31 = -1;

    if (!VAR_0 || !VAR_1) {
        printf(""invalid input params !\n"");
        return -1;
    }

    /* COMMENT_0 */
    init_dct_module();

    /* COMMENT_1 */
    for (VAR_13=0; VAR_13<16; VAR_13++) {
        if (VAR_2->pqtab[VAR_13]) {
            VAR_4[VAR_13] = malloc(64 * sizeof(int));
            if (VAR_4[VAR_13]) {
                init_idct_ftab(VAR_4[VAR_13], VAR_2->pqtab[VAR_13]);
            } else {
                goto done;
            }
        }
    }
    /* COMMENT_2 */

    /* COMMENT_3 */
    for (VAR_15=0; VAR_15<VAR_2->comp_num; VAR_15++) {
        if (VAR_20 < VAR_2->comp_info[VAR_15].samp_factor_h) {
            VAR_20 = VAR_2->comp_info[VAR_15].samp_factor_h;
        }
        if (VAR_21 < VAR_2->comp_info[VAR_15].samp_factor_v) {
            VAR_21 = VAR_2->comp_info[VAR_15].samp_factor_v;
        }
    }
    if (!VAR_20) VAR_20 = 1;
    if (!VAR_21) VAR_21 = 1;
    VAR_6 = VAR_20 * 8;
    VAR_7 = VAR_21 * 8;
    VAR_11 = ALIGN(VAR_2->width , VAR_6);
    VAR_12 = ALIGN(VAR_2->height, VAR_7);
    VAR_8 = VAR_11 / VAR_6;
    VAR_9 = VAR_12 / VAR_7;
    /* COMMENT_4 */

    /* COMMENT_5 */
    VAR_22[0] = VAR_11;
    VAR_22[1] = VAR_11 * VAR_2->comp_info[1].samp_factor_h / VAR_20;
    VAR_22[2] = VAR_11 * VAR_2->comp_info[2].samp_factor_h / VAR_20;
    VAR_23[0] = VAR_12;
    VAR_23[1] = VAR_12 * VAR_2->comp_info[1].samp_factor_v / VAR_21;
    VAR_23[2] = VAR_12 * VAR_2->comp_info[2].samp_factor_v / VAR_21;
    VAR_24[0] = malloc(VAR_22[0] * VAR_23[0] * sizeof(int));
    VAR_24[1] = malloc(VAR_22[1] * VAR_23[1] * sizeof(int));
    VAR_24[2] = malloc(VAR_22[2] * VAR_23[2] * sizeof(int));
    if (!VAR_24[0] || !VAR_24[1] || !VAR_24[2]) {
        goto done;
    }

    /* COMMENT_6 */
    VAR_3 = bitstr_open(VAR_2->databuf, ""mem"", VAR_2->datalen);
    if (!VAR_3) {
        printf(""failed to open bitstr for jfif_decode !"");
        return -1;
    }

    /* COMMENT_7 */
    for (VAR_13=0; VAR_13<16; VAR_13++) {
        if (VAR_2->phcac[VAR_13]) {
            VAR_2->phcac[VAR_13]->input = VAR_3;
            huffman_decode_init(VAR_2->phcac[VAR_13]);
        }
        if (VAR_2->phcdc[VAR_13]) {
            VAR_2->phcdc[VAR_13]->input = VAR_3;
            huffman_decode_init(VAR_2->phcdc[VAR_13]);
        }
    }

    for (VAR_10=0; VAR_10<VAR_8*VAR_9; VAR_10++) {
        for (VAR_15=0; VAR_15<VAR_2->comp_num; VAR_15++) {
            for (VAR_17=0; VAR_17<VAR_2->comp_info[VAR_15].samp_factor_v; VAR_17++) {
                for (VAR_16=0; VAR_16<VAR_2->comp_info[VAR_15].samp_factor_h; VAR_16++) {
                    HUFCODEC *VAR_32 = VAR_2->phcac[VAR_2->comp_info[VAR_15].htab_idx_ac];
                    HUFCODEC *VAR_33 = VAR_2->phcdc[VAR_2->comp_info[VAR_15].htab_idx_dc];
                    int       VAR_34 = VAR_2->comp_info[VAR_15].qtab_idx;
                    int VAR_35, VAR_36, VAR_37;
                    int VAR_38[64] = {0};

                    /* COMMENT_8 */
                    VAR_35 = huffman_decode_step(VAR_33) & 0xf;
                    if (VAR_35) {
                        VAR_37 = bitstr_get_bits(VAR_3  , VAR_35);
                        VAR_37 = category_decode(VAR_37, VAR_35);
                    }
                    else {
                        VAR_37 = 0;
                    }
                    VAR_5[VAR_15] += VAR_37;
                    VAR_38[0]  = VAR_5[VAR_15];
                    /* COMMENT_9 */

                    /* COMMENT_10 */
                    for (VAR_13=1; VAR_13<64; ) {
                        VAR_37 = huffman_decode_step(VAR_32);
                        if (VAR_37 <= 0) break;
                        VAR_35 = (VAR_37 >> 0) & 0xf;
                        VAR_36 = (VAR_37 >> 4) & 0xf;
                        VAR_13   += VAR_36;
                        VAR_37 = bitstr_get_bits(VAR_3  , VAR_35);
                        VAR_37 = category_decode(VAR_37, VAR_35);
                        if (VAR_13 < 64) VAR_38[VAR_13++] = VAR_37;
                    }
                    /* COMMENT_11 */

                    /* COMMENT_12 */
                    zigzag_decode(VAR_38);

                    /* COMMENT_13 */
                    idct2d8x8(VAR_38, VAR_4[VAR_34]);

                    /* COMMENT_14 */
                    VAR_18    = ((VAR_10 % VAR_8) * VAR_6 + VAR_16 * 8) * VAR_2->comp_info[VAR_15].samp_factor_h / VAR_20;
                    VAR_19    = ((VAR_10 / VAR_8) * VAR_7 + VAR_17 * 8) * VAR_2->comp_info[VAR_15].samp_factor_v / VAR_21;
                    VAR_25 = VAR_24[VAR_15] + VAR_19 * VAR_22[VAR_15] + VAR_18;
                    VAR_26 = VAR_38;
                    for (VAR_13=0; VAR_13<8; VAR_13++) {
                        memcpy(VAR_25, VAR_26, 8 * sizeof(int));
                        VAR_25 += VAR_22[VAR_15];
                        VAR_26 += 8;
                    }
                }
            }
        }
    }

    /* COMMENT_15 */
    for (VAR_13=0; VAR_13<16; VAR_13++) {
        if (VAR_2->phcac[VAR_13]) huffman_decode_done(VAR_2->phcac[VAR_13]);
        if (VAR_2->phcdc[VAR_13]) huffman_decode_done(VAR_2->phcdc[VAR_13]);
    }

    /* COMMENT_16 */
    bitstr_close(VAR_3);

    /* COMMENT_17 */
    bmp_create(VAR_1, VAR_2->width, VAR_2->height);
    VAR_30 = (BYTE*)VAR_1->pdata;
    VAR_27 = VAR_24[0];
    for (VAR_13=0; VAR_13<VAR_2->height; VAR_13++) {
        int VAR_39 = VAR_13 * VAR_2->comp_info[1].samp_factor_v / VAR_21;
        int VAR_40 = VAR_13 * VAR_2->comp_info[2].samp_factor_v / VAR_21;
        for (VAR_14=0; VAR_14<VAR_2->width; VAR_14++) {
            int VAR_41 = VAR_14 * VAR_2->comp_info[1].samp_factor_h / VAR_20;
            int VAR_42 = VAR_14 * VAR_2->comp_info[2].samp_factor_h / VAR_20;
            VAR_28 = VAR_24[2] + VAR_39 * VAR_22[2] + VAR_41;
            VAR_29 = VAR_24[1] + VAR_40 * VAR_22[1] + VAR_42;
            yuv_to_rgb(*VAR_27, *VAR_29, *VAR_28, VAR_30 + 2, VAR_30 + 1, VAR_30 + 0);
            VAR_30 += 3;
            VAR_27 += 1;
        }
        VAR_30 -= VAR_2->width * 3;
        VAR_30 += VAR_1->stride;
        VAR_27 -= VAR_2->width * 1;
        VAR_27 += VAR_22[0];
    }

    /* COMMENT_18 */
    VAR_31 = 0;

done:
    if (VAR_24[0]) free(VAR_24[0]);
    if (VAR_24[1]) free(VAR_24[1]);
    if (VAR_24[2]) free(VAR_24[2]);
    /* COMMENT_19 */
    for (VAR_13=0; VAR_13<16; VAR_13++) {
        if (VAR_4[VAR_13]) {
            free(VAR_4[VAR_13]);
        }
    }
    /* COMMENT_20 */
    return VAR_31;
}",rockcarry/ffjpeg/d6158811dbb4e97dc1cc9820ed0e846468366658/jfif.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -46,6 +46,8 @@
             sfv_max = jfif->comp_info[c].samp_factor_v;
         }
     }
+    if (!sfh_max) sfh_max = 1;
+    if (!sfv_max) sfv_max = 1;
     mcuw = sfh_max * 8;
     mcuh = sfv_max * 8;
     jw = ALIGN(jfif->width , mcuw);","{'deleted_lines': [], 'added_lines': ['    if (!sfh_max) sfh_max = 1;', '    if (!sfv_max) sfv_max = 1;']}",True,jfif_decode in jfif.c in ffjpeg through 2019-08-21 has a divide-by-zero error.,6.5,MEDIUM,1,valid,2020-02-24T07:29:21Z,3
CVE-2020-1896,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,facebook/hermes,"Added stack overflow check for hermes::vm:: hermesBuiltinApply

Summary: This adds a missing check for stack overflow.

Reviewed By: tmikov

Differential Revision: D20104955

fbshipit-source-id: 1f37e23d2e28ebcd3aa4176d134b8418e7059ebd",86543ac47e59c522976b5632b8bf9a2a4583c7d2,https://github.com/facebook/hermes/commit/86543ac47e59c522976b5632b8bf9a2a4583c7d2,lib/VM/JSLib/HermesBuiltin.cpp,hermesBuiltinApply,"CallResult<HermesValue>
hermesBuiltinApply(void *, Runtime *runtime, NativeArgs args) {
GCScopeMarkerRAII marker{runtime};
Handle<Callable> fn = args.dyncastArg<Callable>(0);
if (LLVM_UNLIKELY(!fn)) {
return runtime->raiseTypeErrorForValue(
args.getArgHandle(0), "" is not a function"");
}
Handle<JSArray> argArray = args.dyncastArg<JSArray>(1);
if (LLVM_UNLIKELY(!argArray)) {
return runtime->raiseTypeError(""args must be an array"");
}
uint32_t len = JSArray::getLength(*argArray);
bool isConstructor = args.getArgCount() == 2;
MutableHandle<> thisVal{runtime};
if (isConstructor) {
auto thisValRes = Callable::createThisForConstruct(fn, runtime);
if (LLVM_UNLIKELY(thisValRes == ExecutionStatus::EXCEPTION)) {
return ExecutionStatus::EXCEPTION;
}
thisVal = *thisValRes;
} else {
thisVal = args.getArg(2);
}
ScopedNativeCallFrame newFrame{
runtime, len, *fn, isConstructor, thisVal.getHermesValue()};
for (uint32_t i = 0; i < len; ++i) {
newFrame->getArgRef(i) = argArray->at(runtime, i);
}
return isConstructor ? Callable::construct(fn, runtime, thisVal)
: Callable::call(fn, runtime);
}","CallResult<HermesValue>
hermesBuiltinApply(void *, Runtime *VAR_0, NativeArgs VAR_1) {
GCScopeMarkerRAII VAR_2{VAR_0};
Handle<Callable> VAR_3 = VAR_1.dyncastArg<Callable>(0);
if (LLVM_UNLIKELY(!VAR_3)) {
return VAR_0->raiseTypeErrorForValue(
VAR_1.getArgHandle(0), "" is not a function"");
}
Handle<JSArray> VAR_4 = VAR_1.dyncastArg<JSArray>(1);
if (LLVM_UNLIKELY(!VAR_4)) {
return VAR_0->raiseTypeError(""args must be an array"");
}
uint32_t VAR_5 = JSArray::getLength(*VAR_4);
bool VAR_6 = VAR_1.getArgCount() == 2;
MutableHandle<> VAR_7{VAR_0};
if (VAR_6) {
auto VAR_8 = Callable::createThisForConstruct(VAR_3, VAR_0);
if (LLVM_UNLIKELY(VAR_8 == ExecutionStatus::EXCEPTION)) {
return ExecutionStatus::EXCEPTION;
}
VAR_7 = *VAR_8;
} else {
VAR_7 = VAR_1.getArg(2);
}
ScopedNativeCallFrame VAR_9{
VAR_0, VAR_5, *VAR_3, VAR_6, VAR_7.getHermesValue()};
for (uint32_t VAR_10 = 0; VAR_10 < VAR_5; ++VAR_10) {
VAR_9->getArgRef(VAR_10) = VAR_4->at(VAR_0, VAR_10);
}
return VAR_6 ? Callable::construct(VAR_3, VAR_0, VAR_7)
: Callable::call(VAR_3, VAR_0);
}",facebook/hermes/86543ac47e59c522976b5632b8bf9a2a4583c7d2/HermesBuiltin.cpp/vul/before/0.json,"CallResult<HermesValue>
hermesBuiltinApply(void *, Runtime *runtime, NativeArgs args) {
  GCScopeMarkerRAII marker{runtime};

  Handle<Callable> fn = args.dyncastArg<Callable>(0);
  if (LLVM_UNLIKELY(!fn)) {
    return runtime->raiseTypeErrorForValue(
        args.getArgHandle(0), "" is not a function"");
  }

  Handle<JSArray> argArray = args.dyncastArg<JSArray>(1);
  if (LLVM_UNLIKELY(!argArray)) {
    return runtime->raiseTypeError(""args must be an array"");
  }

  uint32_t len = JSArray::getLength(*argArray);

  bool isConstructor = args.getArgCount() == 2;

  MutableHandle<> thisVal{runtime};
  if (isConstructor) {
    auto thisValRes = Callable::createThisForConstruct(fn, runtime);
    if (LLVM_UNLIKELY(thisValRes == ExecutionStatus::EXCEPTION)) {
      return ExecutionStatus::EXCEPTION;
    }
    thisVal = *thisValRes;
  } else {
    thisVal = args.getArg(2);
  }

  ScopedNativeCallFrame newFrame{
      runtime, len, *fn, isConstructor, thisVal.getHermesValue()};
  if (LLVM_UNLIKELY(newFrame.overflowed()))
    return runtime->raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);

  for (uint32_t i = 0; i < len; ++i) {
    newFrame->getArgRef(i) = argArray->at(runtime, i);
  }
  return isConstructor ? Callable::construct(fn, runtime, thisVal)
                       : Callable::call(fn, runtime);
}","CallResult<HermesValue>
hermesBuiltinApply(void *, Runtime *VAR_0, NativeArgs VAR_1) {
  GCScopeMarkerRAII VAR_2{VAR_0};

  Handle<Callable> VAR_3 = VAR_1.dyncastArg<Callable>(0);
  if (LLVM_UNLIKELY(!VAR_3)) {
    return VAR_0->raiseTypeErrorForValue(
        VAR_1.getArgHandle(0), "" is not a function"");
  }

  Handle<JSArray> VAR_4 = VAR_1.dyncastArg<JSArray>(1);
  if (LLVM_UNLIKELY(!VAR_4)) {
    return VAR_0->raiseTypeError(""args must be an array"");
  }

  uint32_t VAR_5 = JSArray::getLength(*VAR_4);

  bool VAR_6 = VAR_1.getArgCount() == 2;

  MutableHandle<> VAR_7{VAR_0};
  if (VAR_6) {
    auto VAR_8 = Callable::createThisForConstruct(VAR_3, VAR_0);
    if (LLVM_UNLIKELY(VAR_8 == ExecutionStatus::EXCEPTION)) {
      return ExecutionStatus::EXCEPTION;
    }
    VAR_7 = *VAR_8;
  } else {
    VAR_7 = VAR_1.getArg(2);
  }

  ScopedNativeCallFrame VAR_9{
      VAR_0, VAR_5, *VAR_3, VAR_6, VAR_7.getHermesValue()};
  if (LLVM_UNLIKELY(VAR_9.overflowed()))
    return VAR_0->raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);

  for (uint32_t VAR_10 = 0; VAR_10 < VAR_5; ++VAR_10) {
    VAR_9->getArgRef(VAR_10) = VAR_4->at(VAR_0, VAR_10);
  }
  return VAR_6 ? Callable::construct(VAR_3, VAR_0, VAR_7)
                       : Callable::call(VAR_3, VAR_0);
}",facebook/hermes/86543ac47e59c522976b5632b8bf9a2a4583c7d2/HermesBuiltin.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -30,6 +30,9 @@
 
   ScopedNativeCallFrame newFrame{
       runtime, len, *fn, isConstructor, thisVal.getHermesValue()};
+  if (LLVM_UNLIKELY(newFrame.overflowed()))
+    return runtime->raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);
+
   for (uint32_t i = 0; i < len; ++i) {
     newFrame->getArgRef(i) = argArray->at(runtime, i);
   }","{'deleted_lines': [], 'added_lines': ['  if (LLVM_UNLIKELY(newFrame.overflowed()))', '    return runtime->raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);', '']}",True,"A stack overflow vulnerability in Facebook Hermes 'builtin apply' prior to commit 86543ac47e59c522976b5632b8bf9a2a4583c7d2 (https://github.com/facebook/hermes/commit/86543ac47e59c522976b5632b8bf9a2a4583c7d2) allows attackers to potentially execute arbitrary code via crafted JavaScript. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.",9.8,CRITICAL,3,valid,2020-02-27T02:57:41Z,3
CVE-2020-14396,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,LibVNC/libvncserver,"libvncclient/tls_openssl: do not deref a NULL pointer

Happens in anonTLS mode where cred is NULL.

re #347",33441d90a506d5f3ae9388f2752901227e430553,https://github.com/LibVNC/libvncserver/commit/33441d90a506d5f3ae9388f2752901227e430553,libvncclient/tls_openssl.c,open_ssl_connection,"static SSL *
open_ssl_connection (rfbClient *client, int sockfd, rfbBool anonTLS, rfbCredential *cred)
{
SSL_CTX *ssl_ctx = NULL;
SSL *ssl = NULL;
int n, finished = 0;
X509_VERIFY_PARAM *param;
uint8_t verify_crls = cred->x509Credential.x509CrlVerifyMode;
if (!(ssl_ctx = SSL_CTX_new(SSLv23_client_method())))
{
rfbClientLog(""Could not create new SSL context.\n"");
return NULL;
}
param = X509_VERIFY_PARAM_new();
if (!anonTLS)
{
if (cred->x509Credential.x509CACertFile)
{
if (!SSL_CTX_load_verify_locations(ssl_ctx, cred->x509Credential.x509CACertFile, NULL))
{
rfbClientLog(""Failed to load CA certificate from %s.\n"",
cred->x509Credential.x509CACertFile);
goto error_free_ctx;
}
} else {
rfbClientLog(""Using default paths for certificate verification.\n"");
SSL_CTX_set_default_verify_paths (ssl_ctx);
}
if (cred->x509Credential.x509CACrlFile)
{
if (!load_crls_from_file(cred->x509Credential.x509CACrlFile, ssl_ctx))
{
rfbClientLog(""CRLs could not be loaded.\n"");
goto error_free_ctx;
}
if (verify_crls == rfbX509CrlVerifyNone) verify_crls = rfbX509CrlVerifyAll;
}
if (cred->x509Credential.x509ClientCertFile && cred->x509Credential.x509ClientKeyFile)
{
if (SSL_CTX_use_certificate_chain_file(ssl_ctx, cred->x509Credential.x509ClientCertFile) != 1)
{
rfbClientLog(""Client certificate could not be loaded.\n"");
goto error_free_ctx;
}
if (SSL_CTX_use_PrivateKey_file(ssl_ctx, cred->x509Credential.x509ClientKeyFile,
SSL_FILETYPE_PEM) != 1)
{
rfbClientLog(""Client private key could not be loaded.\n"");
goto error_free_ctx;
}
if (SSL_CTX_check_private_key(ssl_ctx) == 0) {
rfbClientLog(""Client certificate and private key do not match.\n"");
goto error_free_ctx;
}
}
SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);
if (verify_crls == rfbX509CrlVerifyClient) 
X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK);
else if (verify_crls == rfbX509CrlVerifyAll)
X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);
if(!X509_VERIFY_PARAM_set1_host(param, client->serverHost, strlen(client->serverHost)))
{
rfbClientLog(""Could not set server name for verification.\n"");
goto error_free_ctx;
}
SSL_CTX_set1_param(ssl_ctx, param);
}
if (!(ssl = SSL_new (ssl_ctx)))
{
rfbClientLog(""Could not create a new SSL session.\n"");
goto error_free_ctx;
}
SSL_set_cipher_list(ssl, ""ALL"");
SSL_set_fd (ssl, sockfd);
SSL_CTX_set_app_data (ssl_ctx, client);
do
{
n = SSL_connect(ssl);
if (n != 1) 
{
if (wait_for_data(ssl, n, 1) != 1) 
{
finished = 1;
SSL_shutdown(ssl);
goto error_free_ssl;
}
}
} while( n != 1 && finished != 1 );
X509_VERIFY_PARAM_free(param);
return ssl;
error_free_ssl:
SSL_free(ssl);
error_free_ctx:
X509_VERIFY_PARAM_free(param);
SSL_CTX_free(ssl_ctx);
return NULL;
}","static SSL *
open_ssl_connection (rfbClient *VAR_0, int VAR_1, rfbBool VAR_2, rfbCredential *VAR_3)
{
SSL_CTX *VAR_4 = NULL;
SSL *VAR_5 = NULL;
int VAR_6, VAR_7 = 0;
X509_VERIFY_PARAM *VAR_8;
uint8_t VAR_9 = VAR_3->x509Credential.x509CrlVerifyMode;
if (!(VAR_4 = SSL_CTX_new(SSLv23_client_method())))
{
rfbClientLog(""Could not create new SSL context.\n"");
return NULL;
}
VAR_8 = X509_VERIFY_PARAM_new();
if (!VAR_2)
{
if (VAR_3->x509Credential.x509CACertFile)
{
if (!SSL_CTX_load_verify_locations(VAR_4, VAR_3->x509Credential.x509CACertFile, NULL))
{
rfbClientLog(""Failed to load CA certificate from %s.\n"",
VAR_3->x509Credential.x509CACertFile);
goto error_free_ctx;
}
} else {
rfbClientLog(""Using default paths for certificate verification.\n"");
SSL_CTX_set_default_verify_paths (VAR_4);
}
if (VAR_3->x509Credential.x509CACrlFile)
{
if (!load_crls_from_file(VAR_3->x509Credential.x509CACrlFile, VAR_4))
{
rfbClientLog(""CRLs could not be loaded.\n"");
goto error_free_ctx;
}
if (VAR_9 == VAR_10) VAR_9 = VAR_11;
}
if (VAR_3->x509Credential.x509ClientCertFile && VAR_3->x509Credential.x509ClientKeyFile)
{
if (SSL_CTX_use_certificate_chain_file(VAR_4, VAR_3->x509Credential.x509ClientCertFile) != 1)
{
rfbClientLog(""Client certificate could not be loaded.\n"");
goto error_free_ctx;
}
if (SSL_CTX_use_PrivateKey_file(VAR_4, VAR_3->x509Credential.x509ClientKeyFile,
VAR_12) != 1)
{
rfbClientLog(""Client private key could not be loaded.\n"");
goto error_free_ctx;
}
if (SSL_CTX_check_private_key(VAR_4) == 0) {
rfbClientLog(""Client certificate and private key do not match.\n"");
goto error_free_ctx;
}
}
SSL_CTX_set_verify(VAR_4, VAR_13, NULL);
if (VAR_9 == VAR_14) 
X509_VERIFY_PARAM_set_flags(VAR_8, VAR_15);
else if (VAR_9 == VAR_11)
X509_VERIFY_PARAM_set_flags(VAR_8, VAR_15 | VAR_16);
if(!X509_VERIFY_PARAM_set1_host(VAR_8, VAR_0->serverHost, strlen(VAR_0->serverHost)))
{
rfbClientLog(""Could not set server name for verification.\n"");
goto error_free_ctx;
}
SSL_CTX_set1_param(VAR_4, VAR_8);
}
if (!(VAR_5 = SSL_new (VAR_4)))
{
rfbClientLog(""Could not create a new SSL session.\n"");
goto error_free_ctx;
}
SSL_set_cipher_list(VAR_5, ""ALL"");
SSL_set_fd (VAR_5, VAR_1);
SSL_CTX_set_app_data (VAR_4, VAR_0);
do
{
VAR_6 = SSL_connect(VAR_5);
if (VAR_6 != 1) 
{
if (wait_for_data(VAR_5, VAR_6, 1) != 1) 
{
VAR_7 = 1;
SSL_shutdown(VAR_5);
goto error_free_ssl;
}
}
} while( VAR_6 != 1 && VAR_7 != 1 );
X509_VERIFY_PARAM_free(VAR_8);
return VAR_5;
error_free_ssl:
SSL_free(VAR_5);
error_free_ctx:
X509_VERIFY_PARAM_free(VAR_8);
SSL_CTX_free(VAR_4);
return NULL;
}",LibVNC/libvncserver/33441d90a506d5f3ae9388f2752901227e430553/tls_openssl.c/vul/before/0.json,"static SSL *
open_ssl_connection (rfbClient *client, int sockfd, rfbBool anonTLS, rfbCredential *cred)
{
  SSL_CTX *ssl_ctx = NULL;
  SSL *ssl = NULL;
  int n, finished = 0;
  X509_VERIFY_PARAM *param;
  uint8_t verify_crls;

  if (!(ssl_ctx = SSL_CTX_new(SSLv23_client_method())))
  {
    rfbClientLog(""Could not create new SSL context.\n"");
    return NULL;
  }

  param = X509_VERIFY_PARAM_new();

  /* Setup verification if not anonymous */
  if (!anonTLS)
  {
    verify_crls = cred->x509Credential.x509CrlVerifyMode;
    if (cred->x509Credential.x509CACertFile)
    {
      if (!SSL_CTX_load_verify_locations(ssl_ctx, cred->x509Credential.x509CACertFile, NULL))
      {
        rfbClientLog(""Failed to load CA certificate from %s.\n"",
                     cred->x509Credential.x509CACertFile);
        goto error_free_ctx;
      }
    } else {
      rfbClientLog(""Using default paths for certificate verification.\n"");
      SSL_CTX_set_default_verify_paths (ssl_ctx);
    }

    if (cred->x509Credential.x509CACrlFile)
    {
      if (!load_crls_from_file(cred->x509Credential.x509CACrlFile, ssl_ctx))
      {
        rfbClientLog(""CRLs could not be loaded.\n"");
        goto error_free_ctx;
      }
      if (verify_crls == rfbX509CrlVerifyNone) verify_crls = rfbX509CrlVerifyAll;
    }

    if (cred->x509Credential.x509ClientCertFile && cred->x509Credential.x509ClientKeyFile)
    {
      if (SSL_CTX_use_certificate_chain_file(ssl_ctx, cred->x509Credential.x509ClientCertFile) != 1)
      {
        rfbClientLog(""Client certificate could not be loaded.\n"");
        goto error_free_ctx;
      }

      if (SSL_CTX_use_PrivateKey_file(ssl_ctx, cred->x509Credential.x509ClientKeyFile,
                                      SSL_FILETYPE_PEM) != 1)
      {
        rfbClientLog(""Client private key could not be loaded.\n"");
        goto error_free_ctx;
      }

      if (SSL_CTX_check_private_key(ssl_ctx) == 0) {
        rfbClientLog(""Client certificate and private key do not match.\n"");
        goto error_free_ctx;
      }
    }

    SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);

    if (verify_crls == rfbX509CrlVerifyClient) 
      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK);
    else if (verify_crls == rfbX509CrlVerifyAll)
      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);

    if(!X509_VERIFY_PARAM_set1_host(param, client->serverHost, strlen(client->serverHost)))
    {
      rfbClientLog(""Could not set server name for verification.\n"");
      goto error_free_ctx;
    }
    SSL_CTX_set1_param(ssl_ctx, param);
  }

  if (!(ssl = SSL_new (ssl_ctx)))
  {
    rfbClientLog(""Could not create a new SSL session.\n"");
    goto error_free_ctx;
  }

  /* TODO: finetune this list, take into account anonTLS bool */
  SSL_set_cipher_list(ssl, ""ALL"");

  SSL_set_fd (ssl, sockfd);
  SSL_CTX_set_app_data (ssl_ctx, client);

  do
  {
    n = SSL_connect(ssl);
		
    if (n != 1) 
    {
      if (wait_for_data(ssl, n, 1) != 1) 
      {
        finished = 1;
        SSL_shutdown(ssl);

        goto error_free_ssl;
      }
    }
  } while( n != 1 && finished != 1 );

  X509_VERIFY_PARAM_free(param);
  return ssl;

error_free_ssl:
  SSL_free(ssl);

error_free_ctx:
  X509_VERIFY_PARAM_free(param);
  SSL_CTX_free(ssl_ctx);

  return NULL;
}","static SSL *
open_ssl_connection (rfbClient *VAR_0, int VAR_1, rfbBool VAR_2, rfbCredential *VAR_3)
{
  SSL_CTX *VAR_4 = NULL;
  SSL *VAR_5 = NULL;
  int VAR_6, VAR_7 = 0;
  X509_VERIFY_PARAM *VAR_8;
  uint8_t VAR_9;

  if (!(VAR_4 = SSL_CTX_new(SSLv23_client_method())))
  {
    rfbClientLog(""Could not create new SSL context.\n"");
    return NULL;
  }

  VAR_8 = X509_VERIFY_PARAM_new();

  /* COMMENT_0 */
  if (!VAR_2)
  {
    VAR_9 = VAR_3->x509Credential.x509CrlVerifyMode;
    if (VAR_3->x509Credential.x509CACertFile)
    {
      if (!SSL_CTX_load_verify_locations(VAR_4, VAR_3->x509Credential.x509CACertFile, NULL))
      {
        rfbClientLog(""Failed to load CA certificate from %s.\n"",
                     VAR_3->x509Credential.x509CACertFile);
        goto error_free_ctx;
      }
    } else {
      rfbClientLog(""Using default paths for certificate verification.\n"");
      SSL_CTX_set_default_verify_paths (VAR_4);
    }

    if (VAR_3->x509Credential.x509CACrlFile)
    {
      if (!load_crls_from_file(VAR_3->x509Credential.x509CACrlFile, VAR_4))
      {
        rfbClientLog(""CRLs could not be loaded.\n"");
        goto error_free_ctx;
      }
      if (VAR_9 == VAR_10) VAR_9 = VAR_11;
    }

    if (VAR_3->x509Credential.x509ClientCertFile && VAR_3->x509Credential.x509ClientKeyFile)
    {
      if (SSL_CTX_use_certificate_chain_file(VAR_4, VAR_3->x509Credential.x509ClientCertFile) != 1)
      {
        rfbClientLog(""Client certificate could not be loaded.\n"");
        goto error_free_ctx;
      }

      if (SSL_CTX_use_PrivateKey_file(VAR_4, VAR_3->x509Credential.x509ClientKeyFile,
                                      VAR_12) != 1)
      {
        rfbClientLog(""Client private key could not be loaded.\n"");
        goto error_free_ctx;
      }

      if (SSL_CTX_check_private_key(VAR_4) == 0) {
        rfbClientLog(""Client certificate and private key do not match.\n"");
        goto error_free_ctx;
      }
    }

    SSL_CTX_set_verify(VAR_4, VAR_13, NULL);

    if (VAR_9 == VAR_14) 
      X509_VERIFY_PARAM_set_flags(VAR_8, VAR_15);
    else if (VAR_9 == VAR_11)
      X509_VERIFY_PARAM_set_flags(VAR_8, VAR_15 | VAR_16);

    if(!X509_VERIFY_PARAM_set1_host(VAR_8, VAR_0->serverHost, strlen(VAR_0->serverHost)))
    {
      rfbClientLog(""Could not set server name for verification.\n"");
      goto error_free_ctx;
    }
    SSL_CTX_set1_param(VAR_4, VAR_8);
  }

  if (!(VAR_5 = SSL_new (VAR_4)))
  {
    rfbClientLog(""Could not create a new SSL session.\n"");
    goto error_free_ctx;
  }

  /* COMMENT_1 */
  SSL_set_cipher_list(VAR_5, ""ALL"");

  SSL_set_fd (VAR_5, VAR_1);
  SSL_CTX_set_app_data (VAR_4, VAR_0);

  do
  {
    VAR_6 = SSL_connect(VAR_5);
		
    if (VAR_6 != 1) 
    {
      if (wait_for_data(VAR_5, VAR_6, 1) != 1) 
      {
        VAR_7 = 1;
        SSL_shutdown(VAR_5);

        goto error_free_ssl;
      }
    }
  } while( VAR_6 != 1 && VAR_7 != 1 );

  X509_VERIFY_PARAM_free(VAR_8);
  return VAR_5;

error_free_ssl:
  SSL_free(VAR_5);

error_free_ctx:
  X509_VERIFY_PARAM_free(VAR_8);
  SSL_CTX_free(VAR_4);

  return NULL;
}",LibVNC/libvncserver/33441d90a506d5f3ae9388f2752901227e430553/tls_openssl.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
   SSL *ssl = NULL;
   int n, finished = 0;
   X509_VERIFY_PARAM *param;
-  uint8_t verify_crls = cred->x509Credential.x509CrlVerifyMode;
+  uint8_t verify_crls;
 
   if (!(ssl_ctx = SSL_CTX_new(SSLv23_client_method())))
   {
@@ -18,6 +18,7 @@
   /* Setup verification if not anonymous */
   if (!anonTLS)
   {
+    verify_crls = cred->x509Credential.x509CrlVerifyMode;
     if (cred->x509Credential.x509CACertFile)
     {
       if (!SSL_CTX_load_verify_locations(ssl_ctx, cred->x509Credential.x509CACertFile, NULL))","{'deleted_lines': ['  uint8_t verify_crls = cred->x509Credential.x509CrlVerifyMode;'], 'added_lines': ['  uint8_t verify_crls;', '    verify_crls = cred->x509Credential.x509CrlVerifyMode;']}",True,An issue was discovered in LibVNCServer before 0.9.13. libvncclient/tls_openssl.c has a NULL pointer dereference.,7.5,HIGH,2,valid,2020-03-06T16:37:57Z,3
CVE-2020-22617,['CWE-416'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,Ardour/ardour,fix apparent free-ordering issue reported in #7926,96daa4036a,https://github.com/Ardour/ardour/commit/96daa4036a425ff3f23a7dfcba57bfb0f942bec6,libs/pbd/xml++.cc,find_impl,"static XMLSharedNodeList* find_impl(xmlXPathContext* ctxt, const string& xpath)
{
xmlXPathObject* result = xmlXPathEval((const xmlChar*)xpath.c_str(), ctxt);
if (!result) {
xmlXPathFreeContext(ctxt);
xmlFreeDoc(ctxt->doc);
throw XMLException(""Invalid XPath: "" + xpath);
}
if (result->type != XPATH_NODESET) {
xmlXPathFreeObject(result);
xmlXPathFreeContext(ctxt);
xmlFreeDoc(ctxt->doc);
throw XMLException(""Only nodeset result types are supported."");
}
xmlNodeSet* nodeset = result->nodesetval;
XMLSharedNodeList* nodes = new XMLSharedNodeList();
if (nodeset) {
for (int i = 0; i < nodeset->nodeNr; ++i) {
XMLNode* node = readnode(nodeset->nodeTab[i]);
nodes->push_back(boost::shared_ptr<XMLNode>(node));
}
} else {
}
xmlXPathFreeObject(result);
return nodes;
}","static XMLSharedNodeList* find_impl(xmlXPathContext* VAR_0, const string& VAR_1)
{
xmlXPathObject* VAR_2 = xmlXPathEval((const xmlChar*)VAR_1.c_str(), VAR_0);
if (!VAR_2) {
xmlXPathFreeContext(VAR_0);
xmlFreeDoc(VAR_0->doc);
throw XMLException(""Invalid XPath: "" + VAR_1);
}
if (VAR_2->type != VAR_3) {
xmlXPathFreeObject(VAR_2);
xmlXPathFreeContext(VAR_0);
xmlFreeDoc(VAR_0->doc);
throw XMLException(""Only nodeset result types are supported."");
}
xmlNodeSet* VAR_4 = VAR_2->nodesetval;
XMLSharedNodeList* VAR_5 = new XMLSharedNodeList();
if (VAR_4) {
for (int VAR_6 = 0; VAR_6 < VAR_4->nodeNr; ++VAR_6) {
XMLNode* VAR_7 = readnode(VAR_4->nodeTab[VAR_6]);
VAR_5->push_back(boost::VAR_8<XMLNode>(VAR_7));
}
} else {
}
xmlXPathFreeObject(VAR_2);
return VAR_5;
}",Ardour/ardour/96daa4036a/xml++.cc/vul/before/0.json,"static XMLSharedNodeList* find_impl(xmlXPathContext* ctxt, const string& xpath)
{
	xmlXPathObject* result = xmlXPathEval((const xmlChar*)xpath.c_str(), ctxt);

	if (!result) {
		xmlFreeDoc(ctxt->doc);
		xmlXPathFreeContext(ctxt);

		throw XMLException(""Invalid XPath: "" + xpath);
	}

	if (result->type != XPATH_NODESET) {
		xmlXPathFreeObject(result);
		xmlFreeDoc(ctxt->doc);
		xmlXPathFreeContext(ctxt);

		throw XMLException(""Only nodeset result types are supported."");
	}

	xmlNodeSet* nodeset = result->nodesetval;
	XMLSharedNodeList* nodes = new XMLSharedNodeList();
	if (nodeset) {
		for (int i = 0; i < nodeset->nodeNr; ++i) {
			XMLNode* node = readnode(nodeset->nodeTab[i]);
			nodes->push_back(boost::shared_ptr<XMLNode>(node));
		}
	} else {
		// return empty set
	}

	xmlXPathFreeObject(result);

	return nodes;
}","static XMLSharedNodeList* find_impl(xmlXPathContext* VAR_0, const string& VAR_1)
{
	xmlXPathObject* VAR_2 = xmlXPathEval((const xmlChar*)VAR_1.c_str(), VAR_0);

	if (!VAR_2) {
		xmlFreeDoc(VAR_0->doc);
		xmlXPathFreeContext(VAR_0);

		throw XMLException(""Invalid XPath: "" + VAR_1);
	}

	if (VAR_2->type != VAR_3) {
		xmlXPathFreeObject(VAR_2);
		xmlFreeDoc(VAR_0->doc);
		xmlXPathFreeContext(VAR_0);

		throw XMLException(""Only nodeset result types are supported."");
	}

	xmlNodeSet* VAR_4 = VAR_2->nodesetval;
	XMLSharedNodeList* VAR_5 = new XMLSharedNodeList();
	if (VAR_4) {
		for (int VAR_6 = 0; VAR_6 < VAR_4->nodeNr; ++VAR_6) {
			XMLNode* VAR_7 = readnode(VAR_4->nodeTab[VAR_6]);
			VAR_5->push_back(boost::VAR_8<XMLNode>(VAR_7));
		}
	} else {
		/* COMMENT_0 */
	}

	xmlXPathFreeObject(VAR_2);

	return VAR_5;
}",Ardour/ardour/96daa4036a/xml++.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,16 +3,16 @@
 	xmlXPathObject* result = xmlXPathEval((const xmlChar*)xpath.c_str(), ctxt);
 
 	if (!result) {
+		xmlFreeDoc(ctxt->doc);
 		xmlXPathFreeContext(ctxt);
-		xmlFreeDoc(ctxt->doc);
 
 		throw XMLException(""Invalid XPath: "" + xpath);
 	}
 
 	if (result->type != XPATH_NODESET) {
 		xmlXPathFreeObject(result);
+		xmlFreeDoc(ctxt->doc);
 		xmlXPathFreeContext(ctxt);
-		xmlFreeDoc(ctxt->doc);
 
 		throw XMLException(""Only nodeset result types are supported."");
 	}","{'deleted_lines': ['\t\txmlFreeDoc(ctxt->doc);', '\t\txmlFreeDoc(ctxt->doc);'], 'added_lines': ['\t\txmlFreeDoc(ctxt->doc);', '\t\txmlFreeDoc(ctxt->doc);']}",True,Ardour v5.12 contains a use-after-free vulnerability in the component ardour/libs/pbd/xml++.cc when using xmlFreeDoc and xmlXPathFreeContext.,9.8,CRITICAL,3,valid,2020-03-11T14:49:42Z,3
CVE-2019-14734,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,adplug,"Fix multiple heap-based buffer overflows in CmtkLoader::load()

Changes in src/mtk.cpp for loading files:
* Fail early if the (decompressed) size is too small to hold
  mtkdata minus patterns. That avoids attempts to copy data
  from beyond allocated memory.
* In the data decompression section, there are multiple cases
  where the code actually has checks for available space before
  copying data, but the size of the copy is increased after
  the check, so a buffer overflow is still possible (issue #90).
  Fix that by moving the check after the size computation,
  and also check for a valid source offset where applicable.
* Also add several checks whether source data is exhausted
  during decompession, so
* When copying the patterns, don't copy more data than the
  ""pattern"" array can hold.

In src/mtk.h, method getinstrument(), check for valid instrument
number to avoid accessing the array with an invalid index.

This commit fixes CVE-2019-14734.

Fixes: https://github.com/adplug/adplug/issues/90",8342139c09178823dba3f3bbd8b53d0ea0c72de9,https://github.com/adplug/adplug/commit/8342139c09178823dba3f3bbd8b53d0ea0c72de9,src/mtk.cpp,CmtkLoader::load,"bool CmtkLoader::load(const std::string &filename, const CFileProvider &fp)
{
binistream *f = fp.open(filename); if(!f) return false;
struct {
char id[18];
unsigned short crc,size;
} header;
struct mtkdata {
char songname[34],composername[34],instname[0x80][34];
unsigned char insts[0x80][12],order[0x80],dummy,patterns[0x32][0x40][9];
} *data;
unsigned char *cmp,*org;
unsigned int i;
unsigned long cmpsize,cmpptr=0,orgptr=0;
unsigned short ctrlbits=0,ctrlmask=0,cmd,cnt,offs;
f->readString(header.id, 18);
header.crc = f->readInt(2);
header.size = f->readInt(2);
if(strncmp(header.id,""mpu401tr\x92kk\xeer@data"",18))
{ fp.close(f); return false; }
cmpsize = fp.filesize(f) - 22;
cmp = new unsigned char[cmpsize];
org = new unsigned char[header.size];
for(i = 0; i < cmpsize; i++) cmp[i] = f->readInt(1);
fp.close(f);
while(cmpptr < cmpsize) {    ctrlmask >>= 1;
if(!ctrlmask) {
ctrlbits = cmp[cmpptr] + (cmp[cmpptr + 1] << 8);
cmpptr += 2;
ctrlmask = 0x8000;
}
if(!(ctrlbits & ctrlmask)) {      if(orgptr >= header.size)
goto err;
org[orgptr] = cmp[cmpptr];
orgptr++; cmpptr++;
continue;
}
cmd = (cmp[cmpptr] >> 4) & 0x0f;
cnt = cmp[cmpptr] & 0x0f;
cmpptr++;
switch(cmd) {
case 0:
if(orgptr + cnt > header.size) goto err;
cnt += 3;
memset(&org[orgptr],cmp[cmpptr],cnt);
cmpptr++; orgptr += cnt;
break;
case 1:
if(orgptr + cnt > header.size) goto err;
cnt += (cmp[cmpptr] << 4) + 19;
memset(&org[orgptr],cmp[++cmpptr],cnt);
cmpptr++; orgptr += cnt;
break;
case 2:
if(orgptr + cnt > header.size) goto err;
offs = (cnt+3) + (cmp[cmpptr] << 4);
cnt = cmp[++cmpptr] + 16; cmpptr++;
memcpy(&org[orgptr],&org[orgptr - offs],cnt);
orgptr += cnt;
break;
default:
if(orgptr + cmd > header.size) goto err;
offs = (cnt+3) + (cmp[cmpptr++] << 4);
memcpy(&org[orgptr],&org[orgptr-offs],cmd);
orgptr += cmd;
break;
}
}
delete [] cmp;
data = (struct mtkdata *) org;
memset(title,0,34); strncpy(title,data->songname+1,33);
memset(composer,0,34); strncpy(composer,data->composername+1,33);
memset(instname,0,0x80*34);
for(i=0;i<0x80;i++)
strncpy(instname[i],data->instname[i]+1,33);
memcpy(instr,data->insts,0x80 * 12);
memcpy(song,data->order,0x80);
memcpy(patterns,data->patterns,header.size-6084);
for (i=0;i<128;i++) {    instr[i][2] ^= (instr[i][2] & 0x40) << 1;
instr[i][3] ^= (instr[i][3] & 0x40) << 1;
instr[i][11] >>= 4;  }
delete [] org;
rewind(0);
return true;
err:
delete [] cmp;
delete [] org;
return false;
}","bool CmtkLoader::load(const std::string &VAR_0, const CFileProvider &VAR_1)
{
binistream *VAR_2 = VAR_1.open(VAR_0); if(!VAR_2) return false;
struct {
char id[18];
unsigned short crc,size;
} VAR_3;
struct mtkdata {
char songname[34],composername[34],instname[0x80][34];
unsigned char insts[0x80][12],order[0x80],dummy,patterns[0x32][0x40][9];
} *VAR_4;
unsigned char *VAR_5,*VAR_6;
unsigned int VAR_7;
unsigned long VAR_8,VAR_9=0,VAR_10=0;
unsigned short VAR_11=0,VAR_12=0,VAR_13,VAR_14,VAR_15;
VAR_2->readString(VAR_3.id, 18);
VAR_3.crc = VAR_2->readInt(2);
VAR_3.size = VAR_2->readInt(2);
if(strncmp(VAR_3.id,""mpu401tr\x92kk\xeer@data"",18))
{ VAR_1.close(VAR_2); return false; }
VAR_8 = VAR_1.filesize(VAR_2) - 22;
VAR_5 = new unsigned char[VAR_8];
VAR_6 = new unsigned char[VAR_3.size];
for(VAR_7 = 0; VAR_7 < VAR_8; VAR_7++) VAR_5[VAR_7] = VAR_2->readInt(1);
VAR_1.close(VAR_2);
while(VAR_9 < VAR_8) {
VAR_12 >>= 1;
if(!VAR_12) {
VAR_11 = VAR_5[VAR_9] + (VAR_5[VAR_9 + 1] << 8);
VAR_9 += 2;
VAR_12 = 0x8000;
}
if(!(VAR_11 & VAR_12)) {
if(VAR_10 >= VAR_3.size)
goto err;
VAR_6[VAR_10] = VAR_5[VAR_9];
VAR_10++; VAR_9++;
continue;
}
VAR_13 = (VAR_5[VAR_9] >> 4) & 0x0f;
VAR_14 = VAR_5[VAR_9] & 0x0f;
VAR_9++;
switch(VAR_13) {
case 0:
if(VAR_10 + VAR_14 > VAR_3.size) goto err;
VAR_14 += 3;
memset(&VAR_6[VAR_10],VAR_5[VAR_9],VAR_14);
VAR_9++; VAR_10 += VAR_14;
break;
case 1:
if(VAR_10 + VAR_14 > VAR_3.size) goto err;
VAR_14 += (VAR_5[VAR_9] << 4) + 19;
memset(&VAR_6[VAR_10],VAR_5[++VAR_9],VAR_14);
VAR_9++; VAR_10 += VAR_14;
break;
case 2:
if(VAR_10 + VAR_14 > VAR_3.size) goto err;
VAR_15 = (VAR_14+3) + (VAR_5[VAR_9] << 4);
VAR_14 = VAR_5[++VAR_9] + 16; VAR_9++;
memcpy(&VAR_6[VAR_10],&VAR_6[VAR_10 - VAR_15],VAR_14);
VAR_10 += VAR_14;
break;
default:
if(VAR_10 + VAR_13 > VAR_3.size) goto err;
VAR_15 = (VAR_14+3) + (VAR_5[VAR_9++] << 4);
memcpy(&VAR_6[VAR_10],&VAR_6[VAR_10-VAR_15],VAR_13);
VAR_10 += VAR_13;
break;
}
}
delete [] VAR_5;
VAR_4 = (struct mtkdata *) VAR_6;
memset(VAR_16,0,34); strncpy(VAR_16,VAR_4->songname+1,33);
memset(VAR_17,0,34); strncpy(VAR_17,VAR_4->composername+1,33);
memset(VAR_18,0,0x80*34);
for(VAR_7=0;VAR_7<0x80;VAR_7++)
strncpy(VAR_18[VAR_7],VAR_4->instname[VAR_7]+1,33);
memcpy(VAR_19,VAR_4->insts,0x80 * 12);
memcpy(VAR_20,VAR_4->order,0x80);
memcpy(VAR_21,VAR_4->patterns,VAR_3.size-6084);
for (VAR_7=0;VAR_7<128;VAR_7++) {
VAR_19[VAR_7][2] ^= (VAR_19[VAR_7][2] & 0x40) << 1;
VAR_19[VAR_7][3] ^= (VAR_19[VAR_7][3] & 0x40) << 1;
VAR_19[VAR_7][11] >>= 4;
}
delete [] VAR_6;
rewind(0);
return true;
err:
delete [] VAR_5;
delete [] VAR_6;
return false;
}",adplug/8342139c09178823dba3f3bbd8b53d0ea0c72de9/mtk.cpp/vul/before/0.json,"bool CmtkLoader::load(const std::string &filename, const CFileProvider &fp)
{
  binistream *f = fp.open(filename); if(!f) return false;
  struct {
    char id[18];
    unsigned short crc,size;
  } header;
  struct mtkdata {
    char songname[34],composername[34],instname[0x80][34];
    unsigned char insts[0x80][12],order[0x80],dummy,patterns[0x32][0x40][9];
    // HSC pattern has different type and size from patterns, but that
    // doesn't matter much since we memcpy() the data. Still confusing.
  } *data;
  unsigned char *cmp,*org;
  unsigned int i;
  unsigned long cmpsize,cmpptr=0,orgptr=0;
  unsigned short ctrlbits=0,ctrlmask=0,cmd,cnt,offs;

  // read header
  f->readString(header.id, 18);
  header.crc = f->readInt(2);
  header.size = f->readInt(2);

  // file validation section
  if (memcmp(header.id, ""mpu401tr\x92kk\xeer@data"", 18) ||
      header.size < sizeof(*data) - sizeof(data->patterns)) {
    fp.close(f); return false;
  }

  // load section
  cmpsize = fp.filesize(f) - 22;
  cmp = new unsigned char[cmpsize];
  org = new unsigned char[header.size];
  for(i = 0; i < cmpsize; i++) cmp[i] = f->readInt(1);
  fp.close(f);

  while(cmpptr < cmpsize) {	// decompress
    ctrlmask >>= 1;
    if(!ctrlmask) {
      if (cmpptr + 2 > cmpsize) goto err;
      ctrlbits = cmp[cmpptr] + (cmp[cmpptr + 1] << 8);
      cmpptr += 2;
      ctrlmask = 0x8000;
    }
    if(!(ctrlbits & ctrlmask)) {	// uncompressed data
      if(orgptr >= header.size)
	goto err;

      org[orgptr] = cmp[cmpptr];
      orgptr++; cmpptr++;
      continue;
    }

    // compressed data
    cmd = (cmp[cmpptr] >> 4) & 0x0f;
    cnt = cmp[cmpptr] & 0x0f;
    cmpptr++;
    if (cmpptr >= cmpsize) goto err;
    switch(cmd) {
    case 0:
      cnt += 3;
      if (orgptr + cnt > header.size) goto err;
      memset(&org[orgptr],cmp[cmpptr],cnt);
      cmpptr++; orgptr += cnt;
      break;

    case 1:
      cnt += (cmp[cmpptr] << 4) + 19;
      if (orgptr + cnt > header.size || cmpptr >= cmpsize) goto err;
      memset(&org[orgptr],cmp[++cmpptr],cnt);
      cmpptr++; orgptr += cnt;
      break;

    case 2:
      if (cmpptr + 2 > cmpsize) goto err;
      offs = (cnt+3) + (cmp[cmpptr] << 4);
      cnt = cmp[++cmpptr] + 16; cmpptr++;
      if (orgptr + cnt > header.size || offs > orgptr) goto err;
      memcpy(&org[orgptr],&org[orgptr - offs],cnt);
      orgptr += cnt;
      break;

    default:
      offs = (cnt+3) + (cmp[cmpptr++] << 4);
      if (orgptr + cmd > header.size || offs > orgptr) goto err;
      memcpy(&org[orgptr],&org[orgptr-offs],cmd);
      orgptr += cmd;
      break;
    }
  }
  // orgptr should match header.size; add a check?
  delete [] cmp;
  data = (struct mtkdata *) org;

  // convert to HSC replay data
  memset(title,0,34); strncpy(title,data->songname+1,33);
  memset(composer,0,34); strncpy(composer,data->composername+1,33);
  memset(instname,0,0x80*34);
  for(i=0;i<0x80;i++)
    strncpy(instname[i],data->instname[i]+1,33);
  memcpy(instr,data->insts,0x80 * 12);
  memcpy(song,data->order,0x80);
  for (i=0;i<128;i++) {				// correct instruments
    instr[i][2] ^= (instr[i][2] & 0x40) << 1;
    instr[i][3] ^= (instr[i][3] & 0x40) << 1;
    instr[i][11] >>= 4;		// make unsigned
  }
  cnt = header.size - (sizeof(*data) - sizeof(data->patterns)); // was off by 1
  if (cnt > sizeof(patterns)) cnt = sizeof(patterns); // fail?
  memcpy(patterns, data->patterns, cnt);

  delete [] org;
  rewind(0);
  return true;

 err:
  delete [] cmp;
  delete [] org;
  return false;
}","bool CmtkLoader::load(const std::string &VAR_0, const CFileProvider &VAR_1)
{
  binistream *VAR_2 = VAR_1.open(VAR_0); if(!VAR_2) return false;
  struct {
    char id[18];
    unsigned short crc,size;
  } VAR_3;
  struct mtkdata {
    char songname[34],composername[34],instname[0x80][34];
    unsigned char insts[0x80][12],order[0x80],dummy,patterns[0x32][0x40][9];
    /* COMMENT_0 */
    /* COMMENT_1 */
  } *VAR_4;
  unsigned char *VAR_5,*VAR_6;
  unsigned int VAR_7;
  unsigned long VAR_8,VAR_9=0,VAR_10=0;
  unsigned short VAR_11=0,VAR_12=0,VAR_13,VAR_14,VAR_15;

  /* COMMENT_2 */
  VAR_2->readString(VAR_3.id, 18);
  VAR_3.crc = VAR_2->readInt(2);
  VAR_3.size = VAR_2->readInt(2);

  /* COMMENT_3 */
  if (memcmp(VAR_3.id, ""mpu401tr\x92kk\xeer@data"", 18) ||
      VAR_3.size < sizeof(*VAR_4) - sizeof(VAR_4->patterns)) {
    VAR_1.close(VAR_2); return false;
  }

  /* COMMENT_4 */
  VAR_8 = VAR_1.filesize(VAR_2) - 22;
  VAR_5 = new unsigned char[VAR_8];
  VAR_6 = new unsigned char[VAR_3.size];
  for(VAR_7 = 0; VAR_7 < VAR_8; VAR_7++) VAR_5[VAR_7] = VAR_2->readInt(1);
  VAR_1.close(VAR_2);

  while(VAR_9 < VAR_8) {	/* COMMENT_5 */
    VAR_12 >>= 1;
    if(!VAR_12) {
      if (VAR_9 + 2 > VAR_8) goto err;
      VAR_11 = VAR_5[VAR_9] + (VAR_5[VAR_9 + 1] << 8);
      VAR_9 += 2;
      VAR_12 = 0x8000;
    }
    if(!(VAR_11 & VAR_12)) {	/* COMMENT_6 */
      if(VAR_10 >= VAR_3.size)
	goto err;

      VAR_6[VAR_10] = VAR_5[VAR_9];
      VAR_10++; VAR_9++;
      continue;
    }

    /* COMMENT_7 */
    VAR_13 = (VAR_5[VAR_9] >> 4) & 0x0f;
    VAR_14 = VAR_5[VAR_9] & 0x0f;
    VAR_9++;
    if (VAR_9 >= VAR_8) goto err;
    switch(VAR_13) {
    case 0:
      VAR_14 += 3;
      if (VAR_10 + VAR_14 > VAR_3.size) goto err;
      memset(&VAR_6[VAR_10],VAR_5[VAR_9],VAR_14);
      VAR_9++; VAR_10 += VAR_14;
      break;

    case 1:
      VAR_14 += (VAR_5[VAR_9] << 4) + 19;
      if (VAR_10 + VAR_14 > VAR_3.size || VAR_9 >= VAR_8) goto err;
      memset(&VAR_6[VAR_10],VAR_5[++VAR_9],VAR_14);
      VAR_9++; VAR_10 += VAR_14;
      break;

    case 2:
      if (VAR_9 + 2 > VAR_8) goto err;
      VAR_15 = (VAR_14+3) + (VAR_5[VAR_9] << 4);
      VAR_14 = VAR_5[++VAR_9] + 16; VAR_9++;
      if (VAR_10 + VAR_14 > VAR_3.size || VAR_15 > VAR_10) goto err;
      memcpy(&VAR_6[VAR_10],&VAR_6[VAR_10 - VAR_15],VAR_14);
      VAR_10 += VAR_14;
      break;

    default:
      VAR_15 = (VAR_14+3) + (VAR_5[VAR_9++] << 4);
      if (VAR_10 + VAR_13 > VAR_3.size || VAR_15 > VAR_10) goto err;
      memcpy(&VAR_6[VAR_10],&VAR_6[VAR_10-VAR_15],VAR_13);
      VAR_10 += VAR_13;
      break;
    }
  }
  /* COMMENT_8 */
  delete [] VAR_5;
  VAR_4 = (struct mtkdata *) VAR_6;

  /* COMMENT_9 */
  memset(VAR_16,0,34); strncpy(VAR_16,VAR_4->songname+1,33);
  memset(VAR_17,0,34); strncpy(VAR_17,VAR_4->composername+1,33);
  memset(VAR_18,0,0x80*34);
  for(VAR_7=0;VAR_7<0x80;VAR_7++)
    strncpy(VAR_18[VAR_7],VAR_4->instname[VAR_7]+1,33);
  memcpy(VAR_19,VAR_4->insts,0x80 * 12);
  memcpy(VAR_20,VAR_4->order,0x80);
  for (VAR_7=0;VAR_7<128;VAR_7++) {				/* COMMENT_10 */
    VAR_19[VAR_7][2] ^= (VAR_19[VAR_7][2] & 0x40) << 1;
    VAR_19[VAR_7][3] ^= (VAR_19[VAR_7][3] & 0x40) << 1;
    VAR_19[VAR_7][11] >>= 4;		/* COMMENT_11 */
  }
  VAR_14 = VAR_3.size - (sizeof(*VAR_4) - sizeof(VAR_4->patterns)); /* COMMENT_12 */
  if (VAR_14 > sizeof(VAR_21)) VAR_14 = sizeof(VAR_21); /* COMMENT_13 */
  memcpy(VAR_21, VAR_4->patterns, VAR_14);

  delete [] VAR_6;
  rewind(0);
  return true;

 err:
  delete [] VAR_5;
  delete [] VAR_6;
  return false;
}",adplug/8342139c09178823dba3f3bbd8b53d0ea0c72de9/mtk.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,6 +8,8 @@
   struct mtkdata {
     char songname[34],composername[34],instname[0x80][34];
     unsigned char insts[0x80][12],order[0x80],dummy,patterns[0x32][0x40][9];
+    // HSC pattern has different type and size from patterns, but that
+    // doesn't matter much since we memcpy() the data. Still confusing.
   } *data;
   unsigned char *cmp,*org;
   unsigned int i;
@@ -20,8 +22,10 @@
   header.size = f->readInt(2);
 
   // file validation section
-  if(strncmp(header.id,""mpu401tr\x92kk\xeer@data"",18))
-    { fp.close(f); return false; }
+  if (memcmp(header.id, ""mpu401tr\x92kk\xeer@data"", 18) ||
+      header.size < sizeof(*data) - sizeof(data->patterns)) {
+    fp.close(f); return false;
+  }
 
   // load section
   cmpsize = fp.filesize(f) - 22;
@@ -33,6 +37,7 @@
   while(cmpptr < cmpsize) {	// decompress
     ctrlmask >>= 1;
     if(!ctrlmask) {
+      if (cmpptr + 2 > cmpsize) goto err;
       ctrlbits = cmp[cmpptr] + (cmp[cmpptr + 1] << 8);
       cmpptr += 2;
       ctrlmask = 0x8000;
@@ -50,37 +55,40 @@
     cmd = (cmp[cmpptr] >> 4) & 0x0f;
     cnt = cmp[cmpptr] & 0x0f;
     cmpptr++;
+    if (cmpptr >= cmpsize) goto err;
     switch(cmd) {
     case 0:
-      if(orgptr + cnt > header.size) goto err;
       cnt += 3;
+      if (orgptr + cnt > header.size) goto err;
       memset(&org[orgptr],cmp[cmpptr],cnt);
       cmpptr++; orgptr += cnt;
       break;
 
     case 1:
-      if(orgptr + cnt > header.size) goto err;
       cnt += (cmp[cmpptr] << 4) + 19;
+      if (orgptr + cnt > header.size || cmpptr >= cmpsize) goto err;
       memset(&org[orgptr],cmp[++cmpptr],cnt);
       cmpptr++; orgptr += cnt;
       break;
 
     case 2:
-      if(orgptr + cnt > header.size) goto err;
+      if (cmpptr + 2 > cmpsize) goto err;
       offs = (cnt+3) + (cmp[cmpptr] << 4);
       cnt = cmp[++cmpptr] + 16; cmpptr++;
+      if (orgptr + cnt > header.size || offs > orgptr) goto err;
       memcpy(&org[orgptr],&org[orgptr - offs],cnt);
       orgptr += cnt;
       break;
 
     default:
-      if(orgptr + cmd > header.size) goto err;
       offs = (cnt+3) + (cmp[cmpptr++] << 4);
+      if (orgptr + cmd > header.size || offs > orgptr) goto err;
       memcpy(&org[orgptr],&org[orgptr-offs],cmd);
       orgptr += cmd;
       break;
     }
   }
+  // orgptr should match header.size; add a check?
   delete [] cmp;
   data = (struct mtkdata *) org;
 
@@ -92,12 +100,14 @@
     strncpy(instname[i],data->instname[i]+1,33);
   memcpy(instr,data->insts,0x80 * 12);
   memcpy(song,data->order,0x80);
-  memcpy(patterns,data->patterns,header.size-6084);
   for (i=0;i<128;i++) {				// correct instruments
     instr[i][2] ^= (instr[i][2] & 0x40) << 1;
     instr[i][3] ^= (instr[i][3] & 0x40) << 1;
     instr[i][11] >>= 4;		// make unsigned
   }
+  cnt = header.size - (sizeof(*data) - sizeof(data->patterns)); // was off by 1
+  if (cnt > sizeof(patterns)) cnt = sizeof(patterns); // fail?
+  memcpy(patterns, data->patterns, cnt);
 
   delete [] org;
   rewind(0);","{'deleted_lines': ['  if(strncmp(header.id,""mpu401tr\\x92kk\\xeer@data"",18))', '    { fp.close(f); return false; }', '      if(orgptr + cnt > header.size) goto err;', '      if(orgptr + cnt > header.size) goto err;', '      if(orgptr + cnt > header.size) goto err;', '      if(orgptr + cmd > header.size) goto err;', '  memcpy(patterns,data->patterns,header.size-6084);'], 'added_lines': ['    // HSC pattern has different type and size from patterns, but that', ""    // doesn't matter much since we memcpy() the data. Still confusing."", '  if (memcmp(header.id, ""mpu401tr\\x92kk\\xeer@data"", 18) ||', '      header.size < sizeof(*data) - sizeof(data->patterns)) {', '    fp.close(f); return false;', '  }', '      if (cmpptr + 2 > cmpsize) goto err;', '    if (cmpptr >= cmpsize) goto err;', '      if (orgptr + cnt > header.size) goto err;', '      if (orgptr + cnt > header.size || cmpptr >= cmpsize) goto err;', '      if (cmpptr + 2 > cmpsize) goto err;', '      if (orgptr + cnt > header.size || offs > orgptr) goto err;', '      if (orgptr + cmd > header.size || offs > orgptr) goto err;', '  // orgptr should match header.size; add a check?', '  cnt = header.size - (sizeof(*data) - sizeof(data->patterns)); // was off by 1', '  if (cnt > sizeof(patterns)) cnt = sizeof(patterns); // fail?', '  memcpy(patterns, data->patterns, cnt);']}",True,AdPlug 2.3.1 has multiple heap-based buffer overflows in CmtkLoader::load() in mtk.cpp.,8.8,HIGH,2,valid,2020-03-23T22:36:34Z,3
CVE-2019-14734,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,adplug,"Fix multiple heap-based buffer overflows in CmtkLoader::load()

Changes in src/mtk.cpp for loading files:
* Fail early if the (decompressed) size is too small to hold
  mtkdata minus patterns. That avoids attempts to copy data
  from beyond allocated memory.
* In the data decompression section, there are multiple cases
  where the code actually has checks for available space before
  copying data, but the size of the copy is increased after
  the check, so a buffer overflow is still possible (issue #90).
  Fix that by moving the check after the size computation,
  and also check for a valid source offset where applicable.
* Also add several checks whether source data is exhausted
  during decompession, so
* When copying the patterns, don't copy more data than the
  ""pattern"" array can hold.

In src/mtk.h, method getinstrument(), check for valid instrument
number to avoid accessing the array with an invalid index.

This commit fixes CVE-2019-14734.

Fixes: https://github.com/adplug/adplug/issues/90",8342139c09178823dba3f3bbd8b53d0ea0c72de9,https://github.com/adplug/adplug/commit/8342139c09178823dba3f3bbd8b53d0ea0c72de9,src/mtk.h,getinstrument,"std::string getinstrument(unsigned int n)
{ return std::string(instname[n]); }","std::string getinstrument(unsigned int VAR_0)
{ return std::string(VAR_1[VAR_0]); }",adplug/8342139c09178823dba3f3bbd8b53d0ea0c72de9/mtk.h/vul/before/0.json,"std::string getinstrument(unsigned int n)
    { return n < 128 ? std::string(instname[n]) : std::string(); }","std::string getinstrument(unsigned int VAR_0)
    { return VAR_0 < 128 ? std::string(VAR_1[VAR_0]) : std::string(); }",adplug/8342139c09178823dba3f3bbd8b53d0ea0c72de9/mtk.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,2 +1,2 @@
 std::string getinstrument(unsigned int n)
-    { return std::string(instname[n]); }
+    { return n < 128 ? std::string(instname[n]) : std::string(); }","{'deleted_lines': ['    { return std::string(instname[n]); }'], 'added_lines': ['    { return n < 128 ? std::string(instname[n]) : std::string(); }']}",True,AdPlug 2.3.1 has multiple heap-based buffer overflows in CmtkLoader::load() in mtk.cpp.,8.8,HIGH,2,valid,2020-03-23T22:36:34Z,3
CVE-2020-27793,['CWE-193'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,radareorg/radare2,Fix unmatched array length in core_java.c (issue #16304) (#16313),ced0223c7a1b3b5344af315715cd28fe7c0d9ebc,https://github.com/radareorg/radare2/commit/ced0223c7a1b3b5344af315715cd28fe7c0d9ebc,libr/core/p/core_java.c,r_cmd_java_call,"static int r_cmd_java_call(void *user, const char *input) {
RCore *core = (RCore *) user;
int res = false;
ut32 i = 0;
if (strncmp (input, ""java"", 4)) {
return false;
}
if (input[4] != ' ') {
return r_cmd_java_handle_help (core, input);
}
for (; i < END_CMDS; i++) {
IFDBG r_cons_printf (""Checking cmd: %s %d\n"", JAVA_CMDS[i].name,
strncmp (input+5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len));
if (!strncmp (input + 5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len)) {
const char *cmd = input + 5 + JAVA_CMDS[i].name_len;
if (*cmd && *cmd == ' ') {
cmd++;
}
res =  JAVA_CMDS[i].handler (core, cmd);
break;
}
}
if (!res) {
return r_cmd_java_handle_help (core, input);
}
return true;
}","static int r_cmd_java_call(void *VAR_0, const char *VAR_1) {
RCore *VAR_2 = (RCore *) VAR_0;
int VAR_3 = false;
ut32 VAR_4 = 0;
if (strncmp (VAR_1, ""java"", 4)) {
return false;
}
if (VAR_1[4] != ' ') {
return r_cmd_java_handle_help (VAR_2, VAR_1);
}
for (; VAR_4 < VAR_5; VAR_4++) {
IFDBG VAR_6 (""Checking cmd: %s %d\n"", VAR_7[VAR_4].name,
strncmp (VAR_1+5, VAR_7[VAR_4].name, VAR_7[VAR_4].name_len));
if (!strncmp (VAR_1 + 5, VAR_7[VAR_4].name, VAR_7[VAR_4].name_len)) {
const char *VAR_8 = VAR_1 + 5 + VAR_7[VAR_4].name_len;
if (*VAR_8 && *VAR_8 == ' ') {
VAR_8++;
}
VAR_3 =  VAR_7[VAR_4].handler (VAR_2, VAR_8);
break;
}
}
if (!VAR_3) {
return r_cmd_java_handle_help (VAR_2, VAR_1);
}
return true;
}",radareorg/radare2/ced0223c7a1b3b5344af315715cd28fe7c0d9ebc/core_java.c/vul/before/0.json,"static int r_cmd_java_call(void *user, const char *input) {
	RCore *core = (RCore *) user;
	int res = false;
	ut32 i = 0;
	if (strncmp (input, ""java"", 4)) {
		return false;
	}
	if (input[4] != ' ') {
		return r_cmd_java_handle_help (core, input);
	}
	for (; i < END_CMDS - 1; i++) {
		//IFDBG r_cons_printf (""Checking cmd: %s %d %s\n"", JAVA_CMDS[i].name, JAVA_CMDS[i].name_len, p);
		IFDBG r_cons_printf (""Checking cmd: %s %d\n"", JAVA_CMDS[i].name,
			strncmp (input+5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len));
		if (!strncmp (input + 5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len)) {
			const char *cmd = input + 5 + JAVA_CMDS[i].name_len;
			if (*cmd && *cmd == ' ') {
				cmd++;
			}
			//IFDBG r_cons_printf (""Executing cmd: %s (%s)\n"", JAVA_CMDS[i].name, cmd+5+JAVA_CMDS[i].name_len );
			res =  JAVA_CMDS[i].handler (core, cmd);
			break;
		}
	}
	if (!res) {
		return r_cmd_java_handle_help (core, input);
	}
	return true;
}","static int r_cmd_java_call(void *VAR_0, const char *VAR_1) {
	RCore *VAR_2 = (RCore *) VAR_0;
	int VAR_3 = false;
	ut32 VAR_4 = 0;
	if (strncmp (VAR_1, ""java"", 4)) {
		return false;
	}
	if (VAR_1[4] != ' ') {
		return r_cmd_java_handle_help (VAR_2, VAR_1);
	}
	for (; VAR_4 < VAR_5 - 1; VAR_4++) {
		/* COMMENT_0 */
		IFDBG VAR_6 (""Checking cmd: %s %d\n"", VAR_7[VAR_4].name,
			strncmp (VAR_1+5, VAR_7[VAR_4].name, VAR_7[VAR_4].name_len));
		if (!strncmp (VAR_1 + 5, VAR_7[VAR_4].name, VAR_7[VAR_4].name_len)) {
			const char *VAR_8 = VAR_1 + 5 + VAR_7[VAR_4].name_len;
			if (*VAR_8 && *VAR_8 == ' ') {
				VAR_8++;
			}
			/* COMMENT_1 */
			VAR_3 =  VAR_7[VAR_4].handler (VAR_2, VAR_8);
			break;
		}
	}
	if (!VAR_3) {
		return r_cmd_java_handle_help (VAR_2, VAR_1);
	}
	return true;
}",radareorg/radare2/ced0223c7a1b3b5344af315715cd28fe7c0d9ebc/core_java.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,7 +8,7 @@
 	if (input[4] != ' ') {
 		return r_cmd_java_handle_help (core, input);
 	}
-	for (; i < END_CMDS; i++) {
+	for (; i < END_CMDS - 1; i++) {
 		//IFDBG r_cons_printf (""Checking cmd: %s %d %s\n"", JAVA_CMDS[i].name, JAVA_CMDS[i].name_len, p);
 		IFDBG r_cons_printf (""Checking cmd: %s %d\n"", JAVA_CMDS[i].name,
 			strncmp (input+5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len));","{'deleted_lines': ['\tfor (; i < END_CMDS; i++) {'], 'added_lines': ['\tfor (; i < END_CMDS - 1; i++) {']}",True,"An off-by-one overflow flaw was found in radare2 due to mismatched array length in core_java.c. This could allow an attacker to cause a crash, and perform a denail of service attack.",7.5,HIGH,2,valid,2020-03-26T11:02:43Z,3
CVE-2020-11558,['CWE-416'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,gpac,fix UAF in audio_sample_entry_Read (#1440),6063b1a011c3f80cee25daade18154e15e4c058c,https://github.com/gpac/gpac/commit/6063b1a011c3f80cee25daade18154e15e4c058c,src/isomedia/box_code_base.c,audio_sample_entry_Read,"GF_Err audio_sample_entry_Read(GF_Box *s, GF_BitStream *bs)
{
GF_MPEGAudioSampleEntryBox *ptr;
char *data;
u8 a, b, c, d;
u32 i, size, v, nb_alnum;
GF_Err e;
u64 pos, start;
ptr = (GF_MPEGAudioSampleEntryBox *)s;
start = gf_bs_get_position(bs);
gf_bs_seek(bs, start + 8);
v = gf_bs_read_u16(bs);
if (v)
ptr->is_qtff = 1;
if (v==1) {
gf_bs_seek(bs, start + 8 + 20  + 4);
a = gf_bs_read_u8(bs);
b = gf_bs_read_u8(bs);
c = gf_bs_read_u8(bs);
d = gf_bs_read_u8(bs);
nb_alnum = 0;
if (isalnum(a)) nb_alnum++;
if (isalnum(b)) nb_alnum++;
if (isalnum(c)) nb_alnum++;
if (isalnum(d)) nb_alnum++;
if (nb_alnum>2) ptr->is_qtff = 0;
}
gf_bs_seek(bs, start);
e = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);
if (e) return e;
pos = gf_bs_get_position(bs);
size = (u32) s->size;
if (gf_bs_get_cookie(bs)) {
ptr->is_qtff |= 1<<16;
}
e = gf_isom_box_array_read(s, bs, audio_sample_entry_AddBox);
if (!e) return GF_OK;
if (size<8) return GF_ISOM_INVALID_FILE;
gf_bs_seek(bs, pos);
data = (char*)gf_malloc(sizeof(char) * size);
gf_bs_read_data(bs, data, size);
for (i=0; i<size-8; i++) {
if (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {
GF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);
if (ptr->esd) {
gf_isom_box_del((GF_Box *)ptr->esd);
ptr->esd=NULL;
}
e = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);
if (e==GF_OK) {
gf_isom_box_add_for_dump_mode((GF_Box*)ptr, (GF_Box*)ptr->esd);
} else if (ptr->esd) {
gf_isom_box_del((GF_Box *)ptr->esd);
ptr->esd=NULL;
}
gf_bs_del(mybs);
break;
}
}
gf_free(data);
return e;
}","GF_Err audio_sample_entry_Read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
GF_MPEGAudioSampleEntryBox *VAR_2;
char *VAR_3;
u8 VAR_4, VAR_5, VAR_6, VAR_7;
u32 VAR_8, VAR_9, VAR_10, VAR_11;
GF_Err VAR_12;
u64 VAR_13, VAR_14;
VAR_2 = (GF_MPEGAudioSampleEntryBox *)VAR_0;
VAR_14 = gf_bs_get_position(VAR_1);
gf_bs_seek(VAR_1, VAR_14 + 8);
VAR_10 = gf_bs_read_u16(VAR_1);
if (VAR_10)
VAR_2->is_qtff = 1;
if (VAR_10==1) {
gf_bs_seek(VAR_1, VAR_14 + 8 + 20  + 4);
VAR_4 = gf_bs_read_u8(VAR_1);
VAR_5 = gf_bs_read_u8(VAR_1);
VAR_6 = gf_bs_read_u8(VAR_1);
VAR_7 = gf_bs_read_u8(VAR_1);
VAR_11 = 0;
if (isalnum(VAR_4)) VAR_11++;
if (isalnum(VAR_5)) VAR_11++;
if (isalnum(VAR_6)) VAR_11++;
if (isalnum(VAR_7)) VAR_11++;
if (VAR_11>2) VAR_2->is_qtff = 0;
}
gf_bs_seek(VAR_1, VAR_14);
VAR_12 = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)VAR_0, VAR_1);
if (VAR_12) return VAR_12;
VAR_13 = gf_bs_get_position(VAR_1);
VAR_9 = (u32) VAR_0->size;
if (gf_bs_get_cookie(VAR_1)) {
VAR_2->is_qtff |= 1<<16;
}
VAR_12 = gf_isom_box_array_read(VAR_0, VAR_1, VAR_15);
if (!VAR_12) return VAR_16;
if (VAR_9<8) return VAR_17;
gf_bs_seek(VAR_1, VAR_13);
VAR_3 = (char*)gf_malloc(sizeof(char) * VAR_9);
gf_bs_read_data(VAR_1, VAR_3, VAR_9);
for (VAR_8=0; VAR_8<VAR_9-8; VAR_8++) {
if (GF_4CC((u32)VAR_3[VAR_8+4], (u8)VAR_3[VAR_8+5], (u8)VAR_3[VAR_8+6], (u8)VAR_3[VAR_8+7]) == VAR_18) {
GF_BitStream *VAR_19 = gf_bs_new(VAR_3 + VAR_8, VAR_9 - VAR_8, VAR_20);
if (VAR_2->esd) {
gf_isom_box_del((GF_Box *)VAR_2->esd);
VAR_2->esd=NULL;
}
VAR_12 = gf_isom_box_parse((GF_Box **)&VAR_2->esd, VAR_19);
if (VAR_12==VAR_16) {
gf_isom_box_add_for_dump_mode((GF_Box*)VAR_2, (GF_Box*)VAR_2->esd);
} else if (VAR_2->esd) {
gf_isom_box_del((GF_Box *)VAR_2->esd);
VAR_2->esd=NULL;
}
gf_bs_del(VAR_19);
break;
}
}
gf_free(VAR_3);
return VAR_12;
}",gpac/6063b1a011c3f80cee25daade18154e15e4c058c/box_code_base.c/vul/before/0.json,"GF_Err audio_sample_entry_Read(GF_Box *s, GF_BitStream *bs)
{
	GF_MPEGAudioSampleEntryBox *ptr;
	char *data;
	u8 a, b, c, d;
	u32 i, size, v, nb_alnum;
	GF_Err e;
	u64 pos, start;

	ptr = (GF_MPEGAudioSampleEntryBox *)s;

	start = gf_bs_get_position(bs);
	gf_bs_seek(bs, start + 8);
	v = gf_bs_read_u16(bs);
	if (v)
		ptr->is_qtff = 1;

	//try to disambiguate QTFF v1 and MP4 v1 audio sample entries ...
	if (v==1) {
		//go to end of ISOM audio sample entry, skip 4 byte (box size field), read 4 bytes (box type) and check if this looks like a box
		gf_bs_seek(bs, start + 8 + 20  + 4);
		a = gf_bs_read_u8(bs);
		b = gf_bs_read_u8(bs);
		c = gf_bs_read_u8(bs);
		d = gf_bs_read_u8(bs);
		nb_alnum = 0;
		if (isalnum(a)) nb_alnum++;
		if (isalnum(b)) nb_alnum++;
		if (isalnum(c)) nb_alnum++;
		if (isalnum(d)) nb_alnum++;
		if (nb_alnum>2) ptr->is_qtff = 0;
	}

	gf_bs_seek(bs, start);
	e = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);
	if (e) return e;
	pos = gf_bs_get_position(bs);
	size = (u32) s->size;

	//when cookie is set on bs, always convert qtff-style mp4a to isobmff-style
	//since the conversion is done in addBox and we don't have the bitstream there (arg...), flag the box
 	if (gf_bs_get_cookie(bs)) {
 		ptr->is_qtff |= 1<<16;
 	}

	e = gf_isom_box_array_read(s, bs, audio_sample_entry_AddBox);
	if (!e) return GF_OK;
	if (size<8) return GF_ISOM_INVALID_FILE;

	/*hack for some weird files (possibly recorded with live.com tools, needs further investigations)*/
	gf_bs_seek(bs, pos);
	data = (char*)gf_malloc(sizeof(char) * size);
	gf_bs_read_data(bs, data, size);
	for (i=0; i<size-8; i++) {
		if (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {
			extern Bool use_dump_mode;
			GF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);
			if (ptr->esd) {
				if (!use_dump_mode) gf_isom_box_del((GF_Box *)ptr->esd);
				ptr->esd=NULL;
			}

			e = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);

			if (e==GF_OK) {
				gf_isom_box_add_for_dump_mode((GF_Box*)ptr, (GF_Box*)ptr->esd);
			} else if (ptr->esd) {
				gf_isom_box_del((GF_Box *)ptr->esd);
				ptr->esd=NULL;
			}

			gf_bs_del(mybs);
			break;
		}
	}
	gf_free(data);
	return e;
}","GF_Err audio_sample_entry_Read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
	GF_MPEGAudioSampleEntryBox *VAR_2;
	char *VAR_3;
	u8 VAR_4, VAR_5, VAR_6, VAR_7;
	u32 VAR_8, VAR_9, VAR_10, VAR_11;
	GF_Err VAR_12;
	u64 VAR_13, VAR_14;

	VAR_2 = (GF_MPEGAudioSampleEntryBox *)VAR_0;

	VAR_14 = gf_bs_get_position(VAR_1);
	gf_bs_seek(VAR_1, VAR_14 + 8);
	VAR_10 = gf_bs_read_u16(VAR_1);
	if (VAR_10)
		VAR_2->is_qtff = 1;

	/* COMMENT_0 */
	if (VAR_10==1) {
		/* COMMENT_1 */
		gf_bs_seek(VAR_1, VAR_14 + 8 + 20  + 4);
		VAR_4 = gf_bs_read_u8(VAR_1);
		VAR_5 = gf_bs_read_u8(VAR_1);
		VAR_6 = gf_bs_read_u8(VAR_1);
		VAR_7 = gf_bs_read_u8(VAR_1);
		VAR_11 = 0;
		if (isalnum(VAR_4)) VAR_11++;
		if (isalnum(VAR_5)) VAR_11++;
		if (isalnum(VAR_6)) VAR_11++;
		if (isalnum(VAR_7)) VAR_11++;
		if (VAR_11>2) VAR_2->is_qtff = 0;
	}

	gf_bs_seek(VAR_1, VAR_14);
	VAR_12 = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)VAR_0, VAR_1);
	if (VAR_12) return VAR_12;
	VAR_13 = gf_bs_get_position(VAR_1);
	VAR_9 = (u32) VAR_0->size;

	/* COMMENT_2 */
	/* COMMENT_3 */
 	if (gf_bs_get_cookie(VAR_1)) {
 		VAR_2->is_qtff |= 1<<16;
 	}

	VAR_12 = gf_isom_box_array_read(VAR_0, VAR_1, VAR_15);
	if (!VAR_12) return VAR_16;
	if (VAR_9<8) return VAR_17;

	/* COMMENT_4 */
	gf_bs_seek(VAR_1, VAR_13);
	VAR_3 = (char*)gf_malloc(sizeof(char) * VAR_9);
	gf_bs_read_data(VAR_1, VAR_3, VAR_9);
	for (VAR_8=0; VAR_8<VAR_9-8; VAR_8++) {
		if (GF_4CC((u32)VAR_3[VAR_8+4], (u8)VAR_3[VAR_8+5], (u8)VAR_3[VAR_8+6], (u8)VAR_3[VAR_8+7]) == VAR_18) {
			extern Bool VAR_19;
			GF_BitStream *VAR_20 = gf_bs_new(VAR_3 + VAR_8, VAR_9 - VAR_8, VAR_21);
			if (VAR_2->esd) {
				if (!VAR_19) gf_isom_box_del((GF_Box *)VAR_2->esd);
				VAR_2->esd=NULL;
			}

			VAR_12 = gf_isom_box_parse((GF_Box **)&VAR_2->esd, VAR_20);

			if (VAR_12==VAR_16) {
				gf_isom_box_add_for_dump_mode((GF_Box*)VAR_2, (GF_Box*)VAR_2->esd);
			} else if (VAR_2->esd) {
				gf_isom_box_del((GF_Box *)VAR_2->esd);
				VAR_2->esd=NULL;
			}

			gf_bs_del(VAR_20);
			break;
		}
	}
	gf_free(VAR_3);
	return VAR_12;
}",gpac/6063b1a011c3f80cee25daade18154e15e4c058c/box_code_base.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -53,9 +53,10 @@
 	gf_bs_read_data(bs, data, size);
 	for (i=0; i<size-8; i++) {
 		if (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {
+			extern Bool use_dump_mode;
 			GF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);
 			if (ptr->esd) {
-				gf_isom_box_del((GF_Box *)ptr->esd);
+				if (!use_dump_mode) gf_isom_box_del((GF_Box *)ptr->esd);
 				ptr->esd=NULL;
 			}
 ","{'deleted_lines': ['\t\t\t\tgf_isom_box_del((GF_Box *)ptr->esd);'], 'added_lines': ['\t\t\textern Bool use_dump_mode;', '\t\t\t\tif (!use_dump_mode) gf_isom_box_del((GF_Box *)ptr->esd);']}",True,"An issue was discovered in libgpac.a in GPAC 0.8.0, as demonstrated by MP4Box. audio_sample_entry_Read in isomedia/box_code_base.c does not properly decide when to make gf_isom_box_del calls. This leads to various use-after-free outcomes involving mdia_Read, gf_isom_delete_movie, and gf_isom_parse_movie_boxes.",9.8,CRITICAL,3,valid,2020-03-26T18:17:07Z,3
CVE-2020-11047,['CWE-125'],AV:N/AC:M/Au:S/C:P/I:N/A:P,0,FreeRDP,Fixed #6009: Bounds checks in autodetect_recv_bandwidth_measure_results,f5e73cc7c9cd973b516a618da877c87b80950b65,https://github.com/FreeRDP/FreeRDP/commit/f5e73cc7c9cd973b516a618da877c87b80950b65,libfreerdp/core/autodetect.c,autodetect_recv_bandwidth_measure_results,"static BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* rdp, wStream* s,
AUTODETECT_RSP_PDU* autodetectRspPdu)
{
BOOL success = TRUE;
if (autodetectRspPdu->headerLength != 0x0E)
return FALSE;
WLog_VRB(AUTODETECT_TAG, ""received Bandwidth Measure Results PDU"");
Stream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureTimeDelta); 
Stream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); 
if (rdp->autodetect->bandwidthMeasureTimeDelta > 0)
rdp->autodetect->netCharBandwidth = rdp->autodetect->bandwidthMeasureByteCount * 8 /
rdp->autodetect->bandwidthMeasureTimeDelta;
else
rdp->autodetect->netCharBandwidth = 0;
IFCALLRET(rdp->autodetect->BandwidthMeasureResults, success, rdp->context,
autodetectRspPdu->sequenceNumber);
return success;
}","static BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* VAR_0, wStream* VAR_1,
AUTODETECT_RSP_PDU* VAR_2)
{
BOOL VAR_3 = TRUE;
if (VAR_2->headerLength != 0x0E)
return FALSE;
WLog_VRB(VAR_4, ""received Bandwidth Measure Results PDU"");
Stream_Read_UINT32(VAR_1, VAR_0->autodetect->bandwidthMeasureTimeDelta); 
Stream_Read_UINT32(VAR_1, VAR_0->autodetect->bandwidthMeasureByteCount); 
if (VAR_0->autodetect->bandwidthMeasureTimeDelta > 0)
VAR_0->autodetect->netCharBandwidth = VAR_0->autodetect->bandwidthMeasureByteCount * 8 /
VAR_0->autodetect->bandwidthMeasureTimeDelta;
else
VAR_0->autodetect->netCharBandwidth = 0;
IFCALLRET(VAR_0->autodetect->BandwidthMeasureResults, VAR_3, VAR_0->context,
VAR_2->sequenceNumber);
return VAR_3;
}",FreeRDP/f5e73cc7c9cd973b516a618da877c87b80950b65/autodetect.c/vul/before/0.json,"static BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* rdp, wStream* s,
                                                      AUTODETECT_RSP_PDU* autodetectRspPdu)
{
	BOOL success = TRUE;

	if (autodetectRspPdu->headerLength != 0x0E)
		return FALSE;

	WLog_VRB(AUTODETECT_TAG, ""received Bandwidth Measure Results PDU"");
	if (Stream_GetRemainingLength(s) < 8)
		return -1;
	Stream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureTimeDelta); /* timeDelta (4 bytes) */
	Stream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); /* byteCount (4 bytes) */

	if (rdp->autodetect->bandwidthMeasureTimeDelta > 0)
		rdp->autodetect->netCharBandwidth = rdp->autodetect->bandwidthMeasureByteCount * 8 /
		                                    rdp->autodetect->bandwidthMeasureTimeDelta;
	else
		rdp->autodetect->netCharBandwidth = 0;

	IFCALLRET(rdp->autodetect->BandwidthMeasureResults, success, rdp->context,
	          autodetectRspPdu->sequenceNumber);
	return success;
}","static BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* VAR_0, wStream* VAR_1,
                                                      AUTODETECT_RSP_PDU* VAR_2)
{
	BOOL VAR_3 = TRUE;

	if (VAR_2->headerLength != 0x0E)
		return FALSE;

	WLog_VRB(VAR_4, ""received Bandwidth Measure Results PDU"");
	if (Stream_GetRemainingLength(VAR_1) < 8)
		return -1;
	Stream_Read_UINT32(VAR_1, VAR_0->autodetect->bandwidthMeasureTimeDelta); /* COMMENT_0 */
	Stream_Read_UINT32(VAR_1, VAR_0->autodetect->bandwidthMeasureByteCount); /* COMMENT_1 */

	if (VAR_0->autodetect->bandwidthMeasureTimeDelta > 0)
		VAR_0->autodetect->netCharBandwidth = VAR_0->autodetect->bandwidthMeasureByteCount * 8 /
		                                    VAR_0->autodetect->bandwidthMeasureTimeDelta;
	else
		VAR_0->autodetect->netCharBandwidth = 0;

	IFCALLRET(VAR_0->autodetect->BandwidthMeasureResults, VAR_3, VAR_0->context,
	          VAR_2->sequenceNumber);
	return VAR_3;
}",FreeRDP/f5e73cc7c9cd973b516a618da877c87b80950b65/autodetect.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,6 +7,8 @@
 		return FALSE;
 
 	WLog_VRB(AUTODETECT_TAG, ""received Bandwidth Measure Results PDU"");
+	if (Stream_GetRemainingLength(s) < 8)
+		return -1;
 	Stream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureTimeDelta); /* timeDelta (4 bytes) */
 	Stream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); /* byteCount (4 bytes) */
 ","{'deleted_lines': [], 'added_lines': ['\tif (Stream_GetRemainingLength(s) < 8)', '\t\treturn -1;']}",True,"In FreeRDP after 1.1 and before 2.0.0, there is an out-of-bounds read in autodetect_recv_bandwidth_measure_results. A malicious server can extract up to 8 bytes of client memory with a manipulated message by providing a short input and reading the measurement result data. This has been patched in 2.0.0.",5.5,MEDIUM,1,valid,2020-03-31T07:19:17Z,3
CVE-2020-11940,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ntop/nDPI,"ssh: adds systematic bounds checks in concat_hash_string

cf GHSL-2020-052",3bbb0cd3296023f6f922c71d21a1c374d2b0a435,https://github.com/ntop/nDPI/commit/3bbb0cd3296023f6f922c71d21a1c374d2b0a435,src/lib/protocols/ssh.c,concat_hash_string,"static u_int16_t concat_hash_string(struct ndpi_packet_struct *packet,
char *buf, u_int8_t client_hash) {
u_int16_t offset = 22, buf_out_len = 0;
if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
goto invalid_payload;
u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]);
offset += 4;
if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;
strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);
buf[buf_out_len++] = ';';
offset += len;
len = ntohl(*(u_int32_t*)&packet->payload[offset]);
offset += 4 + len;
len = ntohl(*(u_int32_t*)&packet->payload[offset]);
if(client_hash) {
offset += 4;
if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;
strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
buf_out_len += len;
buf[buf_out_len++] = ';';
offset += len;
} else
offset += 4 + len;
len = ntohl(*(u_int32_t*)&packet->payload[offset]);
if(!client_hash) {
offset += 4;
if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;
strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
buf_out_len += len;
buf[buf_out_len++] = ';';
offset += len;
} else
offset += 4 + len;
len = ntohl(*(u_int32_t*)&packet->payload[offset]);
if(client_hash) {
offset += 4;
if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;
strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
buf_out_len += len;
buf[buf_out_len++] = ';';
offset += len;
} else
offset += 4 + len;
len = ntohl(*(u_int32_t*)&packet->payload[offset]);
if(!client_hash) {
offset += 4;
if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;
strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
buf_out_len += len;
buf[buf_out_len++] = ';';
offset += len;
} else
offset += 4 + len;
if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
goto invalid_payload;
len = ntohl(*(u_int32_t*)&packet->payload[offset]);
if(client_hash) {
offset += 4;
if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;
strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
buf_out_len += len;
offset += len;
} else
offset += 4 + len;
len = ntohl(*(u_int32_t*)&packet->payload[offset]);
if(!client_hash) {
offset += 4;
if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;
strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
buf_out_len += len;
offset += len;
} else
offset += 4 + len;
#ifdef SSH_DEBUG
printf(""[SSH] %s\n"", buf);
#endif
return(buf_out_len);
invalid_payload:
#ifdef SSH_DEBUG
printf(""[SSH] Invalid packet payload\n"");
#endif
return(0);
}","static u_int16_t concat_hash_string(struct ndpi_packet_struct *VAR_0,
char *VAR_1, u_int8_t VAR_2) {
u_int16_t VAR_3 = 22, VAR_4 = 0;
if(VAR_3+sizeof(VAR_5) >= VAR_0->payload_packet_len)
goto invalid_payload;
u_int32_t VAR_6 = ntohl(*(u_int32_t*)&VAR_0->payload[VAR_3]);
VAR_3 += 4;
if((VAR_3 >= VAR_0->payload_packet_len) || (VAR_6 >= VAR_0->payload_packet_len-VAR_3-1))
goto invalid_payload;
strncpy(VAR_1, (const char *)&VAR_0->payload[VAR_3], VAR_4 = VAR_6);
VAR_1[VAR_4++] = ';';
VAR_3 += VAR_6;
VAR_6 = ntohl(*(u_int32_t*)&VAR_0->payload[VAR_3]);
VAR_3 += 4 + VAR_6;
VAR_6 = ntohl(*(u_int32_t*)&VAR_0->payload[VAR_3]);
if(VAR_2) {
VAR_3 += 4;
if((VAR_3 >= VAR_0->payload_packet_len) || (VAR_6 >= VAR_0->payload_packet_len-VAR_3-1))
goto invalid_payload;
strncpy(&VAR_1[VAR_4], (const char *)&VAR_0->payload[VAR_3], VAR_6);
VAR_4 += VAR_6;
VAR_1[VAR_4++] = ';';
VAR_3 += VAR_6;
} else
VAR_3 += 4 + VAR_6;
VAR_6 = ntohl(*(u_int32_t*)&VAR_0->payload[VAR_3]);
if(!VAR_2) {
VAR_3 += 4;
if((VAR_3 >= VAR_0->payload_packet_len) || (VAR_6 >= VAR_0->payload_packet_len-VAR_3-1))
goto invalid_payload;
strncpy(&VAR_1[VAR_4], (const char *)&VAR_0->payload[VAR_3], VAR_6);
VAR_4 += VAR_6;
VAR_1[VAR_4++] = ';';
VAR_3 += VAR_6;
} else
VAR_3 += 4 + VAR_6;
VAR_6 = ntohl(*(u_int32_t*)&VAR_0->payload[VAR_3]);
if(VAR_2) {
VAR_3 += 4;
if((VAR_3 >= VAR_0->payload_packet_len) || (VAR_6 >= VAR_0->payload_packet_len-VAR_3-1))
goto invalid_payload;
strncpy(&VAR_1[VAR_4], (const char *)&VAR_0->payload[VAR_3], VAR_6);
VAR_4 += VAR_6;
VAR_1[VAR_4++] = ';';
VAR_3 += VAR_6;
} else
VAR_3 += 4 + VAR_6;
VAR_6 = ntohl(*(u_int32_t*)&VAR_0->payload[VAR_3]);
if(!VAR_2) {
VAR_3 += 4;
if((VAR_3 >= VAR_0->payload_packet_len) || (VAR_6 >= VAR_0->payload_packet_len-VAR_3-1))
goto invalid_payload;
strncpy(&VAR_1[VAR_4], (const char *)&VAR_0->payload[VAR_3], VAR_6);
VAR_4 += VAR_6;
VAR_1[VAR_4++] = ';';
VAR_3 += VAR_6;
} else
VAR_3 += 4 + VAR_6;
if(VAR_3+sizeof(u_int32_t) >= VAR_0->payload_packet_len)
goto invalid_payload;
VAR_6 = ntohl(*(u_int32_t*)&VAR_0->payload[VAR_3]);
if(VAR_2) {
VAR_3 += 4;
if((VAR_3 >= VAR_0->payload_packet_len) || (VAR_6 >= VAR_0->payload_packet_len-VAR_3-1))
goto invalid_payload;
strncpy(&VAR_1[VAR_4], (const char *)&VAR_0->payload[VAR_3], VAR_6);
VAR_4 += VAR_6;
VAR_3 += VAR_6;
} else
VAR_3 += 4 + VAR_6;
VAR_6 = ntohl(*(u_int32_t*)&VAR_0->payload[VAR_3]);
if(!VAR_2) {
VAR_3 += 4;
if((VAR_3 >= VAR_0->payload_packet_len) || (VAR_6 >= VAR_0->payload_packet_len-VAR_3-1))
goto invalid_payload;
strncpy(&VAR_1[VAR_4], (const char *)&VAR_0->payload[VAR_3], VAR_6);
VAR_4 += VAR_6;
VAR_3 += VAR_6;
} else
VAR_3 += 4 + VAR_6;
#ifdef VAR_7
printf(""[SSH] %s\n"", VAR_1);
#endif
return(VAR_4);
invalid_payload:
#ifdef VAR_7
printf(""[SSH] Invalid packet payload\n"");
#endif
return(0);
}",ntop/nDPI/3bbb0cd3296023f6f922c71d21a1c374d2b0a435/ssh.c/vul/before/0.json,"static u_int16_t concat_hash_string(struct ndpi_packet_struct *packet,
				   char *buf, u_int8_t client_hash) {
  u_int16_t offset = 22, buf_out_len = 0;
  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
    goto invalid_payload;
  u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]);
  offset += 4;

  /* -1 for ';' */
  if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
    goto invalid_payload;

  /* ssh.kex_algorithms [C/S] */
  strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);
  buf[buf_out_len++] = ';';
  offset += len;

  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
    goto invalid_payload;
  /* ssh.server_host_key_algorithms [None] */
  len = ntohl(*(u_int32_t*)&packet->payload[offset]);
  offset += 4 + len;

  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
    goto invalid_payload;
  /* ssh.encryption_algorithms_client_to_server [C] */
  len = ntohl(*(u_int32_t*)&packet->payload[offset]);

  if(client_hash) {
    offset += 4;

    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
      goto invalid_payload;

    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
    buf_out_len += len;
    buf[buf_out_len++] = ';';
    offset += len;
  } else
    offset += 4 + len;

  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
    goto invalid_payload;
  /* ssh.encryption_algorithms_server_to_client [S] */
  len = ntohl(*(u_int32_t*)&packet->payload[offset]);

  if(!client_hash) {
    offset += 4;

    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
      goto invalid_payload;

    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
    buf_out_len += len;
    buf[buf_out_len++] = ';';
    offset += len;
  } else
    offset += 4 + len;

  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
    goto invalid_payload;
  /* ssh.mac_algorithms_client_to_server [C] */
  len = ntohl(*(u_int32_t*)&packet->payload[offset]);

  if(client_hash) {
    offset += 4;

    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
      goto invalid_payload;

    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
    buf_out_len += len;
    buf[buf_out_len++] = ';';
    offset += len;
  } else
    offset += 4 + len;

  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
    goto invalid_payload;
  /* ssh.mac_algorithms_server_to_client [S] */
  len = ntohl(*(u_int32_t*)&packet->payload[offset]);

  if(!client_hash) {
    offset += 4;

    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
      goto invalid_payload;

    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
    buf_out_len += len;
    buf[buf_out_len++] = ';';
    offset += len;
  } else
    offset += 4 + len;

  /* ssh.compression_algorithms_client_to_server [C] */
  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
    goto invalid_payload;
  len = ntohl(*(u_int32_t*)&packet->payload[offset]);

  if(client_hash) {
    offset += 4;

    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
      goto invalid_payload;

    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
    buf_out_len += len;
    offset += len;
  } else
    offset += 4 + len;

  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
    goto invalid_payload;
  /* ssh.compression_algorithms_server_to_client [S] */
  len = ntohl(*(u_int32_t*)&packet->payload[offset]);

  if(!client_hash) {
    offset += 4;

    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
      goto invalid_payload;

    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
    buf_out_len += len;
    offset += len;
  } else
    offset += 4 + len;

  /* ssh.languages_client_to_server [None] */

  /* ssh.languages_server_to_client [None] */

#ifdef SSH_DEBUG
  printf(""[SSH] %s\n"", buf);
#endif

  return(buf_out_len);

invalid_payload:

#ifdef SSH_DEBUG
  printf(""[SSH] Invalid packet payload\n"");
#endif

  return(0);
}","static u_int16_t concat_hash_string(struct ndpi_packet_struct *VAR_0,
				   char *VAR_1, u_int8_t VAR_2) {
  u_int16_t VAR_3 = 22, VAR_4 = 0;
  if(VAR_3+sizeof(VAR_5) >= VAR_0->payload_packet_len)
    goto invalid_payload;
  u_int32_t VAR_6 = ntohl(*(u_int32_t*)&VAR_0->payload[VAR_3]);
  VAR_3 += 4;

  /* COMMENT_0 */
  if((VAR_3 >= VAR_0->payload_packet_len) || (VAR_6 >= VAR_0->payload_packet_len-VAR_3-1))
    goto invalid_payload;

  /* COMMENT_1 */
  strncpy(VAR_1, (const char *)&VAR_0->payload[VAR_3], VAR_4 = VAR_6);
  VAR_1[VAR_4++] = ';';
  VAR_3 += VAR_6;

  if(VAR_3+sizeof(u_int32_t) >= VAR_0->payload_packet_len)
    goto invalid_payload;
  /* COMMENT_2 */
  VAR_6 = ntohl(*(u_int32_t*)&VAR_0->payload[VAR_3]);
  VAR_3 += 4 + VAR_6;

  if(VAR_3+sizeof(u_int32_t) >= VAR_0->payload_packet_len)
    goto invalid_payload;
  /* COMMENT_3 */
  VAR_6 = ntohl(*(u_int32_t*)&VAR_0->payload[VAR_3]);

  if(VAR_2) {
    VAR_3 += 4;

    if((VAR_3 >= VAR_0->payload_packet_len) || (VAR_6 >= VAR_0->payload_packet_len-VAR_3-1))
      goto invalid_payload;

    strncpy(&VAR_1[VAR_4], (const char *)&VAR_0->payload[VAR_3], VAR_6);
    VAR_4 += VAR_6;
    VAR_1[VAR_4++] = ';';
    VAR_3 += VAR_6;
  } else
    VAR_3 += 4 + VAR_6;

  if(VAR_3+sizeof(u_int32_t) >= VAR_0->payload_packet_len)
    goto invalid_payload;
  /* COMMENT_4 */
  VAR_6 = ntohl(*(u_int32_t*)&VAR_0->payload[VAR_3]);

  if(!VAR_2) {
    VAR_3 += 4;

    if((VAR_3 >= VAR_0->payload_packet_len) || (VAR_6 >= VAR_0->payload_packet_len-VAR_3-1))
      goto invalid_payload;

    strncpy(&VAR_1[VAR_4], (const char *)&VAR_0->payload[VAR_3], VAR_6);
    VAR_4 += VAR_6;
    VAR_1[VAR_4++] = ';';
    VAR_3 += VAR_6;
  } else
    VAR_3 += 4 + VAR_6;

  if(VAR_3+sizeof(u_int32_t) >= VAR_0->payload_packet_len)
    goto invalid_payload;
  /* COMMENT_5 */
  VAR_6 = ntohl(*(u_int32_t*)&VAR_0->payload[VAR_3]);

  if(VAR_2) {
    VAR_3 += 4;

    if((VAR_3 >= VAR_0->payload_packet_len) || (VAR_6 >= VAR_0->payload_packet_len-VAR_3-1))
      goto invalid_payload;

    strncpy(&VAR_1[VAR_4], (const char *)&VAR_0->payload[VAR_3], VAR_6);
    VAR_4 += VAR_6;
    VAR_1[VAR_4++] = ';';
    VAR_3 += VAR_6;
  } else
    VAR_3 += 4 + VAR_6;

  if(VAR_3+sizeof(u_int32_t) >= VAR_0->payload_packet_len)
    goto invalid_payload;
  /* COMMENT_6 */
  VAR_6 = ntohl(*(u_int32_t*)&VAR_0->payload[VAR_3]);

  if(!VAR_2) {
    VAR_3 += 4;

    if((VAR_3 >= VAR_0->payload_packet_len) || (VAR_6 >= VAR_0->payload_packet_len-VAR_3-1))
      goto invalid_payload;

    strncpy(&VAR_1[VAR_4], (const char *)&VAR_0->payload[VAR_3], VAR_6);
    VAR_4 += VAR_6;
    VAR_1[VAR_4++] = ';';
    VAR_3 += VAR_6;
  } else
    VAR_3 += 4 + VAR_6;

  /* COMMENT_7 */
  if(VAR_3+sizeof(u_int32_t) >= VAR_0->payload_packet_len)
    goto invalid_payload;
  VAR_6 = ntohl(*(u_int32_t*)&VAR_0->payload[VAR_3]);

  if(VAR_2) {
    VAR_3 += 4;

    if((VAR_3 >= VAR_0->payload_packet_len) || (VAR_6 >= VAR_0->payload_packet_len-VAR_3-1))
      goto invalid_payload;

    strncpy(&VAR_1[VAR_4], (const char *)&VAR_0->payload[VAR_3], VAR_6);
    VAR_4 += VAR_6;
    VAR_3 += VAR_6;
  } else
    VAR_3 += 4 + VAR_6;

  if(VAR_3+sizeof(u_int32_t) >= VAR_0->payload_packet_len)
    goto invalid_payload;
  /* COMMENT_8 */
  VAR_6 = ntohl(*(u_int32_t*)&VAR_0->payload[VAR_3]);

  if(!VAR_2) {
    VAR_3 += 4;

    if((VAR_3 >= VAR_0->payload_packet_len) || (VAR_6 >= VAR_0->payload_packet_len-VAR_3-1))
      goto invalid_payload;

    strncpy(&VAR_1[VAR_4], (const char *)&VAR_0->payload[VAR_3], VAR_6);
    VAR_4 += VAR_6;
    VAR_3 += VAR_6;
  } else
    VAR_3 += 4 + VAR_6;

  /* COMMENT_9 */

  /* COMMENT_10 */

#ifdef VAR_7
  printf(""[SSH] %s\n"", VAR_1);
#endif

  return(VAR_4);

invalid_payload:

#ifdef VAR_7
  printf(""[SSH] Invalid packet payload\n"");
#endif

  return(0);
}",ntop/nDPI/3bbb0cd3296023f6f922c71d21a1c374d2b0a435/ssh.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -15,10 +15,14 @@
   buf[buf_out_len++] = ';';
   offset += len;
 
+  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
+    goto invalid_payload;
   /* ssh.server_host_key_algorithms [None] */
   len = ntohl(*(u_int32_t*)&packet->payload[offset]);
   offset += 4 + len;
 
+  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
+    goto invalid_payload;
   /* ssh.encryption_algorithms_client_to_server [C] */
   len = ntohl(*(u_int32_t*)&packet->payload[offset]);
 
@@ -35,6 +39,8 @@
   } else
     offset += 4 + len;
 
+  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
+    goto invalid_payload;
   /* ssh.encryption_algorithms_server_to_client [S] */
   len = ntohl(*(u_int32_t*)&packet->payload[offset]);
 
@@ -51,6 +57,8 @@
   } else
     offset += 4 + len;
 
+  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
+    goto invalid_payload;
   /* ssh.mac_algorithms_client_to_server [C] */
   len = ntohl(*(u_int32_t*)&packet->payload[offset]);
 
@@ -67,6 +75,8 @@
   } else
     offset += 4 + len;
 
+  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
+    goto invalid_payload;
   /* ssh.mac_algorithms_server_to_client [S] */
   len = ntohl(*(u_int32_t*)&packet->payload[offset]);
 
@@ -100,6 +110,8 @@
   } else
     offset += 4 + len;
 
+  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
+    goto invalid_payload;
   /* ssh.compression_algorithms_server_to_client [S] */
   len = ntohl(*(u_int32_t*)&packet->payload[offset]);
 ","{'deleted_lines': [], 'added_lines': ['  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)', '    goto invalid_payload;', '  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)', '    goto invalid_payload;', '  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)', '    goto invalid_payload;', '  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)', '    goto invalid_payload;', '  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)', '    goto invalid_payload;', '  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)', '    goto invalid_payload;']}",True,"In nDPI through 3.2 Stable, an out-of-bounds read in concat_hash_string in ssh.c can be exploited by a network-positioned attacker that can send malformed SSH protocol messages on a network segment monitored by nDPI's library.",7.5,HIGH,2,valid,2020-04-02T14:35:10Z,3
CVE-2020-11709,['CWE-74'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,yhirose/cpp-httplib,Fix #425,85327e19ae7e72028c30917247238d638ce56d0b,https://github.com/yhirose/cpp-httplib/commit/85327e19ae7e72028c30917247238d638ce56d0b,httplib.h,Response::set_redirect,"inline void Response::set_redirect(const char *url) {
set_header(""Location"", url);
status = 302;
}","inline void Response::set_redirect(const char *VAR_0) {
set_header(""Location"", VAR_0);
VAR_1 = 302;
}",yhirose/cpp-httplib/85327e19ae7e72028c30917247238d638ce56d0b/httplib.h/vul/before/0.json,"inline void Response::set_redirect(const char *url) {
  if (!detail::has_crlf(url)) {
    set_header(""Location"", url);
    status = 302;
  }
}","inline void Response::set_redirect(const char *VAR_0) {
  if (!detail::has_crlf(VAR_0)) {
    set_header(""Location"", VAR_0);
    VAR_1 = 302;
  }
}",yhirose/cpp-httplib/85327e19ae7e72028c30917247238d638ce56d0b/httplib.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,6 @@
 inline void Response::set_redirect(const char *url) {
-  set_header(""Location"", url);
-  status = 302;
+  if (!detail::has_crlf(url)) {
+    set_header(""Location"", url);
+    status = 302;
+  }
 }","{'deleted_lines': ['  set_header(""Location"", url);', '  status = 302;'], 'added_lines': ['  if (!detail::has_crlf(url)) {', '    set_header(""Location"", url);', '    status = 302;', '  }']}",True,"cpp-httplib through 0.5.8 does not filter \r\n in parameters passed into the set_redirect and set_header functions, which creates possibilities for CRLF injection and HTTP response splitting in some specific contexts.",7.5,HIGH,2,valid,2020-04-12T19:33:08Z,3
CVE-2020-11709,['CWE-74'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,yhirose/cpp-httplib,Fix #425,85327e19ae7e72028c30917247238d638ce56d0b,https://github.com/yhirose/cpp-httplib/commit/85327e19ae7e72028c30917247238d638ce56d0b,httplib.h,Request::set_header,"inline void Request::set_header(const char *key, const char *val) {
headers.emplace(key, val);
}","inline void Request::set_header(const char *VAR_0, const char *VAR_1) {
VAR_2.emplace(VAR_0, VAR_1);
}",yhirose/cpp-httplib/85327e19ae7e72028c30917247238d638ce56d0b/httplib.h/vul/before/1.json,"inline void Request::set_header(const char *key, const char *val) {
  if (!detail::has_crlf(key) && !detail::has_crlf(val)) {
    headers.emplace(key, val);
  }
}","inline void Request::set_header(const char *VAR_0, const char *VAR_1) {
  if (!detail::has_crlf(VAR_0) && !detail::has_crlf(VAR_1)) {
    VAR_2.emplace(VAR_0, VAR_1);
  }
}",yhirose/cpp-httplib/85327e19ae7e72028c30917247238d638ce56d0b/httplib.h/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,3 +1,5 @@
 inline void Request::set_header(const char *key, const char *val) {
-  headers.emplace(key, val);
+  if (!detail::has_crlf(key) && !detail::has_crlf(val)) {
+    headers.emplace(key, val);
+  }
 }","{'deleted_lines': ['  headers.emplace(key, val);'], 'added_lines': ['  if (!detail::has_crlf(key) && !detail::has_crlf(val)) {', '    headers.emplace(key, val);', '  }']}",True,"cpp-httplib through 0.5.8 does not filter \r\n in parameters passed into the set_redirect and set_header functions, which creates possibilities for CRLF injection and HTTP response splitting in some specific contexts.",7.5,HIGH,2,valid,2020-04-12T19:33:08Z,3
CVE-2020-11709,['CWE-74'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,yhirose/cpp-httplib,Fix #425,85327e19ae7e72028c30917247238d638ce56d0b,https://github.com/yhirose/cpp-httplib/commit/85327e19ae7e72028c30917247238d638ce56d0b,httplib.h,Request::set_header,"inline void Request::set_header(const char *key, const std::string &val) {
headers.emplace(key, val);
}","inline void Request::set_header(const char *VAR_0, const std::string &VAR_1) {
VAR_2.emplace(VAR_0, VAR_1);
}",yhirose/cpp-httplib/85327e19ae7e72028c30917247238d638ce56d0b/httplib.h/vul/before/3.json,"inline void Request::set_header(const char *key, const std::string &val) {
  if (!detail::has_crlf(key) && !detail::has_crlf(val.c_str())) {
    headers.emplace(key, val);
  }
}","inline void Request::set_header(const char *VAR_0, const std::string &VAR_1) {
  if (!detail::has_crlf(VAR_0) && !detail::has_crlf(VAR_1.c_str())) {
    VAR_2.emplace(VAR_0, VAR_1);
  }
}",yhirose/cpp-httplib/85327e19ae7e72028c30917247238d638ce56d0b/httplib.h/vul/after/3.json,"--- func_before
+++ func_after
@@ -1,3 +1,5 @@
 inline void Request::set_header(const char *key, const std::string &val) {
-  headers.emplace(key, val);
+  if (!detail::has_crlf(key) && !detail::has_crlf(val.c_str())) {
+    headers.emplace(key, val);
+  }
 }","{'deleted_lines': ['  headers.emplace(key, val);'], 'added_lines': ['  if (!detail::has_crlf(key) && !detail::has_crlf(val.c_str())) {', '    headers.emplace(key, val);', '  }']}",True,"cpp-httplib through 0.5.8 does not filter \r\n in parameters passed into the set_redirect and set_header functions, which creates possibilities for CRLF injection and HTTP response splitting in some specific contexts.",7.5,HIGH,2,valid,2020-04-12T19:33:08Z,3
CVE-2020-11709,['CWE-74'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,yhirose/cpp-httplib,Fix #425,85327e19ae7e72028c30917247238d638ce56d0b,https://github.com/yhirose/cpp-httplib/commit/85327e19ae7e72028c30917247238d638ce56d0b,httplib.h,Response::set_header,"inline void Response::set_header(const char *key, const std::string &val) {
headers.emplace(key, val);
}","inline void Response::set_header(const char *VAR_0, const std::string &VAR_1) {
VAR_2.emplace(VAR_0, VAR_1);
}",yhirose/cpp-httplib/85327e19ae7e72028c30917247238d638ce56d0b/httplib.h/vul/before/4.json,"inline void Response::set_header(const char *key, const std::string &val) {
  if (!detail::has_crlf(key) && !detail::has_crlf(val.c_str())) {
    headers.emplace(key, val);
  }
}","inline void Response::set_header(const char *VAR_0, const std::string &VAR_1) {
  if (!detail::has_crlf(VAR_0) && !detail::has_crlf(VAR_1.c_str())) {
    VAR_2.emplace(VAR_0, VAR_1);
  }
}",yhirose/cpp-httplib/85327e19ae7e72028c30917247238d638ce56d0b/httplib.h/vul/after/4.json,"--- func_before
+++ func_after
@@ -1,3 +1,5 @@
 inline void Response::set_header(const char *key, const std::string &val) {
-  headers.emplace(key, val);
+  if (!detail::has_crlf(key) && !detail::has_crlf(val.c_str())) {
+    headers.emplace(key, val);
+  }
 }","{'deleted_lines': ['  headers.emplace(key, val);'], 'added_lines': ['  if (!detail::has_crlf(key) && !detail::has_crlf(val.c_str())) {', '    headers.emplace(key, val);', '  }']}",True,"cpp-httplib through 0.5.8 does not filter \r\n in parameters passed into the set_redirect and set_header functions, which creates possibilities for CRLF injection and HTTP response splitting in some specific contexts.",7.5,HIGH,2,valid,2020-04-12T19:33:08Z,3
CVE-2020-11709,['CWE-74'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,yhirose/cpp-httplib,Fix #425,85327e19ae7e72028c30917247238d638ce56d0b,https://github.com/yhirose/cpp-httplib/commit/85327e19ae7e72028c30917247238d638ce56d0b,httplib.h,Response::set_header,"inline void Response::set_header(const char *key, const char *val) {
headers.emplace(key, val);
}","inline void Response::set_header(const char *VAR_0, const char *VAR_1) {
VAR_2.emplace(VAR_0, VAR_1);
}",yhirose/cpp-httplib/85327e19ae7e72028c30917247238d638ce56d0b/httplib.h/vul/before/2.json,"inline void Response::set_header(const char *key, const char *val) {
  if (!detail::has_crlf(key) && !detail::has_crlf(val)) {
    headers.emplace(key, val);
  }
}","inline void Response::set_header(const char *VAR_0, const char *VAR_1) {
  if (!detail::has_crlf(VAR_0) && !detail::has_crlf(VAR_1)) {
    VAR_2.emplace(VAR_0, VAR_1);
  }
}",yhirose/cpp-httplib/85327e19ae7e72028c30917247238d638ce56d0b/httplib.h/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,3 +1,5 @@
 inline void Response::set_header(const char *key, const char *val) {
-  headers.emplace(key, val);
+  if (!detail::has_crlf(key) && !detail::has_crlf(val)) {
+    headers.emplace(key, val);
+  }
 }","{'deleted_lines': ['  headers.emplace(key, val);'], 'added_lines': ['  if (!detail::has_crlf(key) && !detail::has_crlf(val)) {', '    headers.emplace(key, val);', '  }']}",True,"cpp-httplib through 0.5.8 does not filter \r\n in parameters passed into the set_redirect and set_header functions, which creates possibilities for CRLF injection and HTTP response splitting in some specific contexts.",7.5,HIGH,2,valid,2020-04-12T19:33:08Z,3
CVE-2020-19667,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/1895,5462fd4725018567764c8f66bed98b7ee3e23006,https://github.com/ImageMagick/ImageMagick/commit/5462fd4725018567764c8f66bed98b7ee3e23006,coders/xpm.c,ReadXPMImage,"static Image *ReadXPMImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
char
*grey,
key[MagickPathExtent],
target[MagickPathExtent],
*xpm_buffer;
Image
*image;
MagickBooleanType
active,
status;
register char
*next,
*p,
*q;
register Quantum
*r;
register ssize_t
x;
size_t
length;
SplayTreeInfo
*xpm_colors;
ssize_t
count,
j,
y;
unsigned long
colors,
columns,
rows,
width;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
image=AcquireImage(image_info,exception);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
length=MagickPathExtent;
xpm_buffer=(char *) AcquireQuantumMemory((size_t) length,sizeof(*xpm_buffer));
if (xpm_buffer == (char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
*xpm_buffer='\0';
p=xpm_buffer;
while (ReadBlobString(image,p) != (char *) NULL)
{
if ((*p == '#') && ((p == xpm_buffer) || (*(p-1) == '\n')))
continue;
if ((*p == '}') && (*(p+1) == ';'))
break;
p+=strlen(p);
if ((size_t) (p-xpm_buffer+MagickPathExtent) < length)
continue;
length<<=1;
xpm_buffer=(char *) ResizeQuantumMemory(xpm_buffer,length+MagickPathExtent,
sizeof(*xpm_buffer));
if (xpm_buffer == (char *) NULL)
break;
p=xpm_buffer+strlen(xpm_buffer);
}
if (xpm_buffer == (char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
count=0;
width=0;
for (p=xpm_buffer; *p != '\0'; p++)
{
if (*p != '""')
continue;
count=(ssize_t) sscanf(p+1,""%lu %lu %lu %lu"",&columns,&rows,&colors,&width);
image->columns=columns;
image->rows=rows;
image->colors=colors;
if (count == 4)
break;
}
if ((count != 4) || (width == 0) || (width > 3) ||
(image->columns == 0) || (image->rows == 0) ||
(image->colors == 0) || (image->colors > MaxColormapSize))
{
xpm_buffer=DestroyString(xpm_buffer);
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
}
active=MagickFalse;
for (q=xpm_buffer; *p != '\0'; )
{
if (*p++ == '""')
{
if (active != MagickFalse)
*q++='\n';
active=active != MagickFalse ? MagickFalse : MagickTrue;
}
if (active != MagickFalse)
*q++=(*p);
}
*q='\0';
if (active != MagickFalse)
{
xpm_buffer=DestroyString(xpm_buffer);
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
}
xpm_colors=NewSplayTree(CompareXPMColor,RelinquishMagickMemory,
(void *(*)(void *)) NULL);
if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
{
xpm_colors=DestroySplayTree(xpm_colors);
xpm_buffer=DestroyString(xpm_buffer);
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
}
image->depth=1;
next=NextXPMLine(xpm_buffer);
for (j=0; (j < (ssize_t) image->colors) && (next != (char *) NULL); j++)
{
char
symbolic[MagickPathExtent];
p=next;
next=NextXPMLine(p);
if (next == (char *) NULL)
break;
length=MagickMin((size_t) width,MagickPathExtent-1);
if (CopyXPMColor(key,p,length) != (ssize_t) length)
break;
status=AddValueToSplayTree(xpm_colors,ConstantString(key),(void *) j);
(void) CopyMagickString(target,""gray"",MagickPathExtent);
q=(char *) NULL;
if (strlen(p) > width)
q=ParseXPMColor(p+width,MagickTrue);
*symbolic='\0';
if (q != (char *) NULL)
{
while ((isspace((int) ((unsigned char) *q)) == 0) && (*q != '\0'))
q++;
if ((next-q) < 0)
break;
(void) CopyXPMColor(target,q,MagickMin((size_t) (next-q),
MagickPathExtent-1));
q=ParseXPMColor(target,MagickFalse);
(void) CopyXPMColor(symbolic,q,MagickMin((size_t) (next-q),
MagickPathExtent-1));
if (q != (char *) NULL)
*q='\0';
}
StripString(target);
if (*symbolic != '\0')
(void) AddValueToSplayTree(xpm_symbolic,ConstantString(target),
ConstantString(symbolic));
grey=strstr(target,""grey"");
if (grey != (char *) NULL)
grey[2]='a';
if (LocaleCompare(target,""none"") == 0)
{
image->storage_class=DirectClass;
image->alpha_trait=BlendPixelTrait;
}
status=QueryColorCompliance(target,XPMCompliance,&image->colormap[j],
exception);
if (status == MagickFalse)
break;
if (image->depth < image->colormap[j].depth)
image->depth=image->colormap[j].depth;
}
if (j < (ssize_t) image->colors)
{
xpm_colors=DestroySplayTree(xpm_colors);
xpm_buffer=DestroyString(xpm_buffer);
ThrowReaderException(CorruptImageError,""CorruptImage"");
}
j=0;
if (image_info->ping == MagickFalse)
{
status=SetImageExtent(image,image->columns,image->rows,exception);
if (status == MagickFalse)
{
xpm_colors=DestroySplayTree(xpm_colors);
xpm_buffer=DestroyString(xpm_buffer);
return(DestroyImageList(image));
}
for (y=0; y < (ssize_t) image->rows; y++)
{
p=NextXPMLine(p);
if (p == (char *) NULL)
break;
r=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (r == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
ssize_t
count;
count=CopyXPMColor(key,p,MagickMin(width,MagickPathExtent-1));
if (count != (ssize_t) width)
break;
j=(ssize_t) GetValueFromSplayTree(xpm_colors,key);
if (image->storage_class == PseudoClass)
SetPixelIndex(image,(Quantum) j,r);
SetPixelViaPixelInfo(image,image->colormap+j,r);
p+=count;
r+=GetPixelChannels(image);
}
if (x < (ssize_t) image->columns)
break;
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
}
if (y < (ssize_t) image->rows)
{
xpm_colors=DestroySplayTree(xpm_colors);
xpm_buffer=DestroyString(xpm_buffer);
ThrowReaderException(CorruptImageError,""NotEnoughPixelData"");
}
}
xpm_buffer=DestroyString(xpm_buffer);
xpm_colors=DestroySplayTree(xpm_colors);
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}","static Image *ReadXPMImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
char
*VAR_2,
VAR_3[VAR_4],
VAR_5[VAR_4],
*VAR_6;
Image
*VAR_7;
MagickBooleanType
VAR_8,
VAR_9;
register char
*VAR_10,
*VAR_11,
*VAR_12;
register Quantum
*VAR_13;
register ssize_t
VAR_14;
size_t
VAR_15;
SplayTreeInfo
*VAR_16;
ssize_t
VAR_17,
VAR_18,
VAR_19;
unsigned long
VAR_20,
VAR_21,
VAR_22,
VAR_23;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_24);
if (VAR_0->debug != VAR_25)
(void) LogMagickEvent(VAR_26,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_24);
VAR_7=AcquireImage(VAR_0,VAR_1);
VAR_9=OpenBlob(VAR_0,VAR_7,VAR_27,VAR_1);
if (VAR_9 == VAR_25)
{
VAR_7=DestroyImageList(VAR_7);
return((Image *) NULL);
}
VAR_15=VAR_4;
VAR_6=(char *) AcquireQuantumMemory((size_t) VAR_15,sizeof(*VAR_6));
if (VAR_6 == (char *) NULL)
ThrowReaderException(VAR_28,""MemoryAllocationFailed"");
*VAR_6='\0';
VAR_11=VAR_6;
while (ReadBlobString(VAR_7,VAR_11) != (char *) NULL)
{
if ((*VAR_11 == '#') && ((VAR_11 == VAR_6) || (*(VAR_11-1) == '\n')))
continue;
if ((*VAR_11 == '}') && (*(VAR_11+1) == ';'))
break;
VAR_11+=strlen(VAR_11);
if ((size_t) (VAR_11-VAR_6+VAR_4) < VAR_15)
continue;
VAR_15<<=1;
VAR_6=(char *) ResizeQuantumMemory(VAR_6,VAR_15+VAR_4,
sizeof(*VAR_6));
if (VAR_6 == (char *) NULL)
break;
VAR_11=VAR_6+strlen(VAR_6);
}
if (VAR_6 == (char *) NULL)
ThrowReaderException(VAR_28,""MemoryAllocationFailed"");
VAR_17=0;
VAR_23=0;
for (VAR_11=VAR_6; *VAR_11 != '\0'; VAR_11++)
{
if (*VAR_11 != '""')
continue;
VAR_17=(ssize_t) sscanf(VAR_11+1,""%lu %lu %lu %lu"",&VAR_21,&VAR_22,&VAR_20,&VAR_23);
VAR_7->columns=VAR_21;
VAR_7->rows=VAR_22;
VAR_7->colors=VAR_20;
if (VAR_17 == 4)
break;
}
if ((VAR_17 != 4) || (VAR_23 == 0) || (VAR_23 > 3) ||
(VAR_7->columns == 0) || (VAR_7->rows == 0) ||
(VAR_7->colors == 0) || (VAR_7->colors > VAR_29))
{
VAR_6=DestroyString(VAR_6);
ThrowReaderException(VAR_30,""ImproperImageHeader"");
}
VAR_8=VAR_25;
for (VAR_12=VAR_6; *VAR_11 != '\0'; )
{
if (*VAR_11++ == '""')
{
if (VAR_8 != VAR_25)
*VAR_12++='\n';
VAR_8=VAR_8 != VAR_25 ? VAR_25 : VAR_31;
}
if (VAR_8 != VAR_25)
*VAR_12++=(*VAR_11);
}
*VAR_12='\0';
if (VAR_8 != VAR_25)
{
VAR_6=DestroyString(VAR_6);
ThrowReaderException(VAR_30,""UnexpectedEndOfFile"");
}
VAR_16=NewSplayTree(VAR_32,VAR_33,
(void *(*)(void *)) NULL);
if (AcquireImageColormap(VAR_7,VAR_7->colors,VAR_1) == VAR_25)
{
VAR_16=DestroySplayTree(VAR_16);
VAR_6=DestroyString(VAR_6);
ThrowReaderException(VAR_28,""MemoryAllocationFailed"");
}
VAR_7->depth=1;
VAR_10=NextXPMLine(VAR_6);
for (VAR_18=0; (VAR_18 < (ssize_t) VAR_7->colors) && (VAR_10 != (char *) NULL); VAR_18++)
{
char
VAR_34[VAR_4];
VAR_11=VAR_10;
VAR_10=NextXPMLine(VAR_11);
if (VAR_10 == (char *) NULL)
break;
VAR_15=MagickMin((size_t) VAR_23,VAR_4-1);
if (CopyXPMColor(VAR_3,VAR_11,VAR_15) != (ssize_t) VAR_15)
break;
VAR_9=AddValueToSplayTree(VAR_16,ConstantString(VAR_3),(void *) VAR_18);
(void) CopyMagickString(VAR_5,""gray"",VAR_4);
VAR_12=(char *) NULL;
if (strlen(VAR_11) > VAR_23)
VAR_12=ParseXPMColor(VAR_11+VAR_23,VAR_31);
*VAR_34='\0';
if (VAR_12 != (char *) NULL)
{
while ((isspace((int) ((unsigned char) *VAR_12)) == 0) && (*VAR_12 != '\0'))
VAR_12++;
if ((VAR_10-VAR_12) < 0)
break;
(void) CopyXPMColor(VAR_5,VAR_12,MagickMin((size_t) (VAR_10-VAR_12),
VAR_4-1));
VAR_12=ParseXPMColor(VAR_5,VAR_25);
(void) CopyXPMColor(VAR_34,VAR_12,MagickMin((size_t) (VAR_10-VAR_12),
VAR_4-1));
if (VAR_12 != (char *) NULL)
*VAR_12='\0';
}
StripString(VAR_5);
if (*VAR_34 != '\0')
(void) AddValueToSplayTree(VAR_35,ConstantString(VAR_5),
ConstantString(VAR_34));
VAR_2=strstr(VAR_5,""grey"");
if (VAR_2 != (char *) NULL)
VAR_2[2]='a';
if (LocaleCompare(VAR_5,""none"") == 0)
{
VAR_7->storage_class=VAR_36;
VAR_7->alpha_trait=VAR_37;
}
VAR_9=QueryColorCompliance(VAR_5,VAR_38,&VAR_7->colormap[VAR_18],
VAR_1);
if (VAR_9 == VAR_25)
break;
if (VAR_7->depth < VAR_7->colormap[VAR_18].depth)
VAR_7->depth=VAR_7->colormap[VAR_18].depth;
}
if (VAR_18 < (ssize_t) VAR_7->colors)
{
VAR_16=DestroySplayTree(VAR_16);
VAR_6=DestroyString(VAR_6);
ThrowReaderException(VAR_30,""CorruptImage"");
}
VAR_18=0;
if (VAR_0->ping == VAR_25)
{
VAR_9=SetImageExtent(VAR_7,VAR_7->columns,VAR_7->rows,VAR_1);
if (VAR_9 == VAR_25)
{
VAR_16=DestroySplayTree(VAR_16);
VAR_6=DestroyString(VAR_6);
return(DestroyImageList(VAR_7));
}
for (VAR_19=0; VAR_19 < (ssize_t) VAR_7->rows; VAR_19++)
{
VAR_11=NextXPMLine(VAR_11);
if (VAR_11 == (char *) NULL)
break;
VAR_13=QueueAuthenticPixels(VAR_7,0,VAR_19,VAR_7->columns,1,VAR_1);
if (VAR_13 == (Quantum *) NULL)
break;
for (VAR_14=0; VAR_14 < (ssize_t) VAR_7->columns; VAR_14++)
{
ssize_t
VAR_17;
VAR_17=CopyXPMColor(VAR_3,VAR_11,MagickMin(VAR_23,VAR_4-1));
if (VAR_17 != (ssize_t) VAR_23)
break;
VAR_18=(ssize_t) GetValueFromSplayTree(VAR_16,VAR_3);
if (VAR_7->storage_class == VAR_39)
SetPixelIndex(VAR_7,(Quantum) VAR_18,VAR_13);
SetPixelViaPixelInfo(VAR_7,VAR_7->colormap+VAR_18,VAR_13);
VAR_11+=VAR_17;
VAR_13+=GetPixelChannels(VAR_7);
}
if (VAR_14 < (ssize_t) VAR_7->columns)
break;
if (SyncAuthenticPixels(VAR_7,VAR_1) == VAR_25)
break;
}
if (VAR_19 < (ssize_t) VAR_7->rows)
{
VAR_16=DestroySplayTree(VAR_16);
VAR_6=DestroyString(VAR_6);
ThrowReaderException(VAR_30,""NotEnoughPixelData"");
}
}
VAR_6=DestroyString(VAR_6);
VAR_16=DestroySplayTree(VAR_16);
(void) CloseBlob(VAR_7);
return(GetFirstImageInList(VAR_7));
}",ImageMagick/5462fd4725018567764c8f66bed98b7ee3e23006/xpm.c/vul/before/0.json,"static Image *ReadXPMImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  char
    *grey,
    key[MagickPathExtent],
    target[MagickPathExtent],
    *xpm_buffer;

  Image
    *image;

  MagickBooleanType
    active,
    status;

  register char
    *next,
    *p,
    *q;

  register Quantum
    *r;

  register ssize_t
    x;

  size_t
    length;

  SplayTreeInfo
    *xpm_colors;

  ssize_t
    count,
    j,
    y;

  unsigned long
    colors,
    columns,
    rows,
    width;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read XPM file.
  */
  length=MagickPathExtent;
  xpm_buffer=(char *) AcquireQuantumMemory((size_t) length,sizeof(*xpm_buffer));
  if (xpm_buffer == (char *) NULL)
    ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  *xpm_buffer='\0';
  p=xpm_buffer;
  while (ReadBlobString(image,p) != (char *) NULL)
  {
    if ((*p == '#') && ((p == xpm_buffer) || (*(p-1) == '\n')))
      continue;
    if ((*p == '}') && (*(p+1) == ';'))
      break;
    p+=strlen(p);
    if ((size_t) (p-xpm_buffer+MagickPathExtent) < length)
      continue;
    length<<=1;
    xpm_buffer=(char *) ResizeQuantumMemory(xpm_buffer,length+MagickPathExtent,
      sizeof(*xpm_buffer));
    if (xpm_buffer == (char *) NULL)
      break;
    p=xpm_buffer+strlen(xpm_buffer);
  }
  if (xpm_buffer == (char *) NULL)
    ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  /*
    Remove comments.
  */
  count=0;
  width=0;
  for (p=xpm_buffer; *p != '\0'; p++)
  {
    if (*p != '""')
      continue;
    count=(ssize_t) sscanf(p+1,""%lu %lu %lu %lu"",&columns,&rows,&colors,&width);
    image->columns=columns;
    image->rows=rows;
    image->colors=colors;
    if (count == 4)
      break;
  }
  if ((count != 4) || (width == 0) || (width > 3) ||
      (image->columns == 0) || (image->rows == 0) ||
      (image->colors == 0) || (image->colors > MaxColormapSize))
    {
      xpm_buffer=DestroyString(xpm_buffer);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }
  /*
    Remove unquoted characters.
  */
  active=MagickFalse;
  for (q=xpm_buffer; *p != '\0'; )
  {
    if (*p++ == '""')
      {
        if (active != MagickFalse)
          *q++='\n';
        active=active != MagickFalse ? MagickFalse : MagickTrue;
      }
    if (active != MagickFalse)
      *q++=(*p);
  }
  *q='\0';
  if (active != MagickFalse)
    {
      xpm_buffer=DestroyString(xpm_buffer);
      ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
    }
  /*
    Initialize image structure.
  */
  xpm_colors=NewSplayTree(CompareXPMColor,RelinquishMagickMemory,
    (void *(*)(void *)) NULL);
  if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
    {
      xpm_colors=DestroySplayTree(xpm_colors);
      xpm_buffer=DestroyString(xpm_buffer);
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    }
  /*
    Read image colormap.
  */
  image->depth=1;
  next=NextXPMLine(xpm_buffer);
  for (j=0; (j < (ssize_t) image->colors) && (next != (char *) NULL); j++)
  {
    char
      symbolic[MagickPathExtent];

    p=next;
    next=NextXPMLine(p);
    if (next == (char *) NULL)
      break;
    length=MagickMin((size_t) width,MagickPathExtent-1);
    if (CopyXPMColor(key,p,length) != (ssize_t) length)
      break;
    status=AddValueToSplayTree(xpm_colors,ConstantString(key),(void *) j);
    /*
      Parse color.
    */
    (void) memset(target,0,sizeof(target));
    (void) CopyMagickString(target,""gray"",MagickPathExtent);
    q=(char *) NULL;
    if (strlen(p) > width)
      q=ParseXPMColor(p+width,MagickTrue);
    (void) memset(symbolic,0,sizeof(symbolic));
    *symbolic='\0';
    if (q != (char *) NULL)
      {
        while ((isspace((int) ((unsigned char) *q)) == 0) && (*q != '\0'))
          q++;
        if ((next-q) < 0)
          break;
        (void) CopyXPMColor(target,q,MagickMin((size_t) (next-q),
          MagickPathExtent-1));
        q=ParseXPMColor(target,MagickFalse);
        (void) CopyXPMColor(symbolic,q,MagickMin((size_t) (next-q),
          MagickPathExtent-1));
        if (q != (char *) NULL)
          *q='\0';
      }
    StripString(target);
    if (*symbolic != '\0')
      (void) AddValueToSplayTree(xpm_symbolic,ConstantString(target),
        ConstantString(symbolic));
    grey=strstr(target,""grey"");
    if (grey != (char *) NULL)
      grey[2]='a';
    if (LocaleCompare(target,""none"") == 0)
      {
        image->storage_class=DirectClass;
        image->alpha_trait=BlendPixelTrait;
      }
    status=QueryColorCompliance(target,XPMCompliance,&image->colormap[j],
      exception);
    if (status == MagickFalse)
      break;
    if (image->depth < image->colormap[j].depth)
      image->depth=image->colormap[j].depth;
  }
  if (j < (ssize_t) image->colors)
    {
      xpm_colors=DestroySplayTree(xpm_colors);
      xpm_buffer=DestroyString(xpm_buffer);
      ThrowReaderException(CorruptImageError,""CorruptImage"");
    }
  j=0;
  if (image_info->ping == MagickFalse)
    {
      /*
        Read image pixels.
      */
      status=SetImageExtent(image,image->columns,image->rows,exception);
      if (status == MagickFalse)
        {
          xpm_colors=DestroySplayTree(xpm_colors);
          xpm_buffer=DestroyString(xpm_buffer);
          return(DestroyImageList(image));
        }
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        p=NextXPMLine(p);
        if (p == (char *) NULL)
          break;
        r=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (r == (Quantum *) NULL)
          break;
        for (x=0; x < (ssize_t) image->columns; x++)
        {
          ssize_t
            count;

          count=CopyXPMColor(key,p,MagickMin(width,MagickPathExtent-1));
          if (count != (ssize_t) width)
            break;
          j=(ssize_t) GetValueFromSplayTree(xpm_colors,key);
          if (image->storage_class == PseudoClass)
            SetPixelIndex(image,(Quantum) j,r);
          SetPixelViaPixelInfo(image,image->colormap+j,r);
          p+=count;
          r+=GetPixelChannels(image);
        }
        if (x < (ssize_t) image->columns)
          break;
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
      }
      if (y < (ssize_t) image->rows)
        {
          xpm_colors=DestroySplayTree(xpm_colors);
          xpm_buffer=DestroyString(xpm_buffer);
          ThrowReaderException(CorruptImageError,""NotEnoughPixelData"");
        }
    }
  /*
    Relinquish resources.
  */
  xpm_buffer=DestroyString(xpm_buffer);
  xpm_colors=DestroySplayTree(xpm_colors);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}","static Image *ReadXPMImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
  char
    *VAR_2,
    VAR_3[VAR_4],
    VAR_5[VAR_4],
    *VAR_6;

  Image
    *VAR_7;

  MagickBooleanType
    VAR_8,
    VAR_9;

  register char
    *VAR_10,
    *VAR_11,
    *VAR_12;

  register Quantum
    *VAR_13;

  register ssize_t
    VAR_14;

  size_t
    VAR_15;

  SplayTreeInfo
    *VAR_16;

  ssize_t
    VAR_17,
    VAR_18,
    VAR_19;

  unsigned long
    VAR_20,
    VAR_21,
    VAR_22,
    VAR_23;

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_24);
  if (VAR_0->debug != VAR_25)
    (void) LogMagickEvent(VAR_26,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_24);
  VAR_7=AcquireImage(VAR_0,VAR_1);
  VAR_9=OpenBlob(VAR_0,VAR_7,VAR_27,VAR_1);
  if (VAR_9 == VAR_25)
    {
      VAR_7=DestroyImageList(VAR_7);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                  
    
  VAR_15=VAR_4;
  VAR_6=(char *) AcquireQuantumMemory((size_t) VAR_15,sizeof(*VAR_6));
  if (VAR_6 == (char *) NULL)
    ThrowReaderException(VAR_28,""MemoryAllocationFailed"");
  *VAR_6='\0';
  VAR_11=VAR_6;
  while (ReadBlobString(VAR_7,VAR_11) != (char *) NULL)
  {
    if ((*VAR_11 == '#') && ((VAR_11 == VAR_6) || (*(VAR_11-1) == '\n')))
      continue;
    if ((*VAR_11 == '}') && (*(VAR_11+1) == ';'))
      break;
    VAR_11+=strlen(VAR_11);
    if ((size_t) (VAR_11-VAR_6+VAR_4) < VAR_15)
      continue;
    VAR_15<<=1;
    VAR_6=(char *) ResizeQuantumMemory(VAR_6,VAR_15+VAR_4,
      sizeof(*VAR_6));
    if (VAR_6 == (char *) NULL)
      break;
    VAR_11=VAR_6+strlen(VAR_6);
  }
  if (VAR_6 == (char *) NULL)
    ThrowReaderException(VAR_28,""MemoryAllocationFailed"");
  /* COMMENT_6 */
                    
    
  VAR_17=0;
  VAR_23=0;
  for (VAR_11=VAR_6; *VAR_11 != '\0'; VAR_11++)
  {
    if (*VAR_11 != '""')
      continue;
    VAR_17=(ssize_t) sscanf(VAR_11+1,""%lu %lu %lu %lu"",&VAR_21,&VAR_22,&VAR_20,&VAR_23);
    VAR_7->columns=VAR_21;
    VAR_7->rows=VAR_22;
    VAR_7->colors=VAR_20;
    if (VAR_17 == 4)
      break;
  }
  if ((VAR_17 != 4) || (VAR_23 == 0) || (VAR_23 > 3) ||
      (VAR_7->columns == 0) || (VAR_7->rows == 0) ||
      (VAR_7->colors == 0) || (VAR_7->colors > VAR_29))
    {
      VAR_6=DestroyString(VAR_6);
      ThrowReaderException(VAR_30,""ImproperImageHeader"");
    }
  /* COMMENT_9 */
                               
    
  VAR_8=VAR_25;
  for (VAR_12=VAR_6; *VAR_11 != '\0'; )
  {
    if (*VAR_11++ == '""')
      {
        if (VAR_8 != VAR_25)
          *VAR_12++='\n';
        VAR_8=VAR_8 != VAR_25 ? VAR_25 : VAR_31;
      }
    if (VAR_8 != VAR_25)
      *VAR_12++=(*VAR_11);
  }
  *VAR_12='\0';
  if (VAR_8 != VAR_25)
    {
      VAR_6=DestroyString(VAR_6);
      ThrowReaderException(VAR_30,""UnexpectedEndOfFile"");
    }
  /* COMMENT_12 */
                               
    
  VAR_16=NewSplayTree(VAR_32,VAR_33,
    (void *(*)(void *)) NULL);
  if (AcquireImageColormap(VAR_7,VAR_7->colors,VAR_1) == VAR_25)
    {
      VAR_16=DestroySplayTree(VAR_16);
      VAR_6=DestroyString(VAR_6);
      ThrowReaderException(VAR_28,""MemoryAllocationFailed"");
    }
  /* COMMENT_15 */
                        
    
  VAR_7->depth=1;
  VAR_10=NextXPMLine(VAR_6);
  for (VAR_18=0; (VAR_18 < (ssize_t) VAR_7->colors) && (VAR_10 != (char *) NULL); VAR_18++)
  {
    char
      VAR_34[VAR_4];

    VAR_11=VAR_10;
    VAR_10=NextXPMLine(VAR_11);
    if (VAR_10 == (char *) NULL)
      break;
    VAR_15=MagickMin((size_t) VAR_23,VAR_4-1);
    if (CopyXPMColor(VAR_3,VAR_11,VAR_15) != (ssize_t) VAR_15)
      break;
    VAR_9=AddValueToSplayTree(VAR_16,ConstantString(VAR_3),(void *) VAR_18);
    /* COMMENT_18 */
                  
      
    (void) memset(VAR_5,0,sizeof(VAR_5));
    (void) CopyMagickString(VAR_5,""gray"",VAR_4);
    VAR_12=(char *) NULL;
    if (strlen(VAR_11) > VAR_23)
      VAR_12=ParseXPMColor(VAR_11+VAR_23,VAR_31);
    (void) memset(VAR_34,0,sizeof(VAR_34));
    *VAR_34='\0';
    if (VAR_12 != (char *) NULL)
      {
        while ((isspace((int) ((unsigned char) *VAR_12)) == 0) && (*VAR_12 != '\0'))
          VAR_12++;
        if ((VAR_10-VAR_12) < 0)
          break;
        (void) CopyXPMColor(VAR_5,VAR_12,MagickMin((size_t) (VAR_10-VAR_12),
          VAR_4-1));
        VAR_12=ParseXPMColor(VAR_5,VAR_25);
        (void) CopyXPMColor(VAR_34,VAR_12,MagickMin((size_t) (VAR_10-VAR_12),
          VAR_4-1));
        if (VAR_12 != (char *) NULL)
          *VAR_12='\0';
      }
    StripString(VAR_5);
    if (*VAR_34 != '\0')
      (void) AddValueToSplayTree(VAR_35,ConstantString(VAR_5),
        ConstantString(VAR_34));
    VAR_2=strstr(VAR_5,""grey"");
    if (VAR_2 != (char *) NULL)
      VAR_2[2]='a';
    if (LocaleCompare(VAR_5,""none"") == 0)
      {
        VAR_7->storage_class=VAR_36;
        VAR_7->alpha_trait=VAR_37;
      }
    VAR_9=QueryColorCompliance(VAR_5,VAR_38,&VAR_7->colormap[VAR_18],
      VAR_1);
    if (VAR_9 == VAR_25)
      break;
    if (VAR_7->depth < VAR_7->colormap[VAR_18].depth)
      VAR_7->depth=VAR_7->colormap[VAR_18].depth;
  }
  if (VAR_18 < (ssize_t) VAR_7->colors)
    {
      VAR_16=DestroySplayTree(VAR_16);
      VAR_6=DestroyString(VAR_6);
      ThrowReaderException(VAR_30,""CorruptImage"");
    }
  VAR_18=0;
  if (VAR_0->ping == VAR_25)
    {
      /* COMMENT_21 */
                          
        
      VAR_9=SetImageExtent(VAR_7,VAR_7->columns,VAR_7->rows,VAR_1);
      if (VAR_9 == VAR_25)
        {
          VAR_16=DestroySplayTree(VAR_16);
          VAR_6=DestroyString(VAR_6);
          return(DestroyImageList(VAR_7));
        }
      for (VAR_19=0; VAR_19 < (ssize_t) VAR_7->rows; VAR_19++)
      {
        VAR_11=NextXPMLine(VAR_11);
        if (VAR_11 == (char *) NULL)
          break;
        VAR_13=QueueAuthenticPixels(VAR_7,0,VAR_19,VAR_7->columns,1,VAR_1);
        if (VAR_13 == (Quantum *) NULL)
          break;
        for (VAR_14=0; VAR_14 < (ssize_t) VAR_7->columns; VAR_14++)
        {
          ssize_t
            VAR_17;

          VAR_17=CopyXPMColor(VAR_3,VAR_11,MagickMin(VAR_23,VAR_4-1));
          if (VAR_17 != (ssize_t) VAR_23)
            break;
          VAR_18=(ssize_t) GetValueFromSplayTree(VAR_16,VAR_3);
          if (VAR_7->storage_class == VAR_39)
            SetPixelIndex(VAR_7,(Quantum) VAR_18,VAR_13);
          SetPixelViaPixelInfo(VAR_7,VAR_7->colormap+VAR_18,VAR_13);
          VAR_11+=VAR_17;
          VAR_13+=GetPixelChannels(VAR_7);
        }
        if (VAR_14 < (ssize_t) VAR_7->columns)
          break;
        if (SyncAuthenticPixels(VAR_7,VAR_1) == VAR_25)
          break;
      }
      if (VAR_19 < (ssize_t) VAR_7->rows)
        {
          VAR_16=DestroySplayTree(VAR_16);
          VAR_6=DestroyString(VAR_6);
          ThrowReaderException(VAR_30,""NotEnoughPixelData"");
        }
    }
  /* COMMENT_24 */
                         
    
  VAR_6=DestroyString(VAR_6);
  VAR_16=DestroySplayTree(VAR_16);
  (void) CloseBlob(VAR_7);
  return(GetFirstImageInList(VAR_7));
}",ImageMagick/5462fd4725018567764c8f66bed98b7ee3e23006/xpm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -161,10 +161,12 @@
     /*
       Parse color.
     */
+    (void) memset(target,0,sizeof(target));
     (void) CopyMagickString(target,""gray"",MagickPathExtent);
     q=(char *) NULL;
     if (strlen(p) > width)
       q=ParseXPMColor(p+width,MagickTrue);
+    (void) memset(symbolic,0,sizeof(symbolic));
     *symbolic='\0';
     if (q != (char *) NULL)
       {","{'deleted_lines': [], 'added_lines': ['    (void) memset(target,0,sizeof(target));', '    (void) memset(symbolic,0,sizeof(symbolic));']}",True,Stack-based buffer overflow and unconditional jump in ReadXPMImage in coders/xpm.c in ImageMagick 7.0.10-7.,7.8,HIGH,2,valid,2020-04-14T12:07:59Z,3
CVE-2020-11088,['CWE-125'],AV:N/AC:L/Au:S/C:P/I:N/A:P,0,FreeRDP,Fixed oob read in ntlm_read_NegotiateMessage,8fa38359634a9910b91719818ab02f23c320dbae,https://github.com/FreeRDP/FreeRDP/commit/8fa38359634a9910b91719818ab02f23c320dbae,winpr/libwinpr/sspi/NTLM/ntlm_message.c,ntlm_read_NegotiateMessage,"SECURITY_STATUS ntlm_read_NegotiateMessage(NTLM_CONTEXT* context, PSecBuffer buffer)
{
wStream* s;
size_t length;
NTLM_NEGOTIATE_MESSAGE* message;
message = &context->NEGOTIATE_MESSAGE;
ZeroMemory(message, sizeof(NTLM_NEGOTIATE_MESSAGE));
s = Stream_New((BYTE*)buffer->pvBuffer, buffer->cbBuffer);
if (!s)
return SEC_E_INTERNAL_ERROR;
if (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*)message) < 0)
{
Stream_Free(s, FALSE);
return SEC_E_INVALID_TOKEN;
}
if (message->MessageType != MESSAGE_TYPE_NEGOTIATE)
{
Stream_Free(s, FALSE);
return SEC_E_INVALID_TOKEN;
}
Stream_Read_UINT32(s, message->NegotiateFlags); 
if (!((message->NegotiateFlags & NTLMSSP_REQUEST_TARGET) &&
(message->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM) &&
(message->NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE)))
{
Stream_Free(s, FALSE);
return SEC_E_INVALID_TOKEN;
}
context->NegotiateFlags = message->NegotiateFlags;
if (ntlm_read_message_fields(s, &(message->DomainName)) < 0) 
{
Stream_Free(s, FALSE);
return SEC_E_INVALID_TOKEN;
}
if (ntlm_read_message_fields(s, &(message->Workstation)) < 0) 
{
Stream_Free(s, FALSE);
return SEC_E_INVALID_TOKEN;
}
if (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)
{
if (ntlm_read_version_info(s, &(message->Version)) < 0) 
{
Stream_Free(s, FALSE);
return SEC_E_INVALID_TOKEN;
}
}
length = Stream_GetPosition(s);
buffer->cbBuffer = length;
if (!sspi_SecBufferAlloc(&context->NegotiateMessage, length))
{
Stream_Free(s, FALSE);
return SEC_E_INTERNAL_ERROR;
}
CopyMemory(context->NegotiateMessage.pvBuffer, buffer->pvBuffer, buffer->cbBuffer);
context->NegotiateMessage.BufferType = buffer->BufferType;
#ifdef WITH_DEBUG_NTLM
WLog_DBG(TAG, ""NEGOTIATE_MESSAGE (length = %"" PRIu32 "")"", context->NegotiateMessage.cbBuffer);
winpr_HexDump(TAG, WLOG_DEBUG, context->NegotiateMessage.pvBuffer,
context->NegotiateMessage.cbBuffer);
ntlm_print_negotiate_flags(message->NegotiateFlags);
if (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)
ntlm_print_version_info(&(message->Version));
#endif
context->state = NTLM_STATE_CHALLENGE;
Stream_Free(s, FALSE);
return SEC_I_CONTINUE_NEEDED;
}","SECURITY_STATUS ntlm_read_NegotiateMessage(NTLM_CONTEXT* VAR_0, PSecBuffer VAR_1)
{
wStream* VAR_2;
size_t VAR_3;
NTLM_NEGOTIATE_MESSAGE* VAR_4;
VAR_4 = &VAR_0->NEGOTIATE_MESSAGE;
ZeroMemory(VAR_4, sizeof(NTLM_NEGOTIATE_MESSAGE));
VAR_2 = Stream_New((BYTE*)VAR_1->pvBuffer, VAR_1->cbBuffer);
if (!VAR_2)
return VAR_5;
if (ntlm_read_message_header(VAR_2, (NTLM_MESSAGE_HEADER*)VAR_4) < 0)
{
Stream_Free(VAR_2, FALSE);
return VAR_6;
}
if (VAR_4->MessageType != VAR_7)
{
Stream_Free(VAR_2, FALSE);
return VAR_6;
}
Stream_Read_UINT32(VAR_2, VAR_4->NegotiateFlags); 
if (!((VAR_4->NegotiateFlags & VAR_8) &&
(VAR_4->NegotiateFlags & VAR_9) &&
(VAR_4->NegotiateFlags & VAR_10)))
{
Stream_Free(VAR_2, FALSE);
return VAR_6;
}
VAR_0->NegotiateFlags = VAR_4->NegotiateFlags;
if (ntlm_read_message_fields(VAR_2, &(VAR_4->DomainName)) < 0) 
{
Stream_Free(VAR_2, FALSE);
return VAR_6;
}
if (ntlm_read_message_fields(VAR_2, &(VAR_4->Workstation)) < 0) 
{
Stream_Free(VAR_2, FALSE);
return VAR_6;
}
if (VAR_4->NegotiateFlags & VAR_11)
{
if (ntlm_read_version_info(VAR_2, &(VAR_4->Version)) < 0) 
{
Stream_Free(VAR_2, FALSE);
return VAR_6;
}
}
VAR_3 = Stream_GetPosition(VAR_2);
VAR_1->cbBuffer = VAR_3;
if (!sspi_SecBufferAlloc(&VAR_0->NegotiateMessage, VAR_3))
{
Stream_Free(VAR_2, FALSE);
return VAR_5;
}
CopyMemory(VAR_0->NegotiateMessage.pvBuffer, VAR_1->pvBuffer, VAR_1->cbBuffer);
VAR_0->NegotiateMessage.BufferType = VAR_1->BufferType;
#ifdef VAR_12
WLog_DBG(VAR_13, ""NEGOTIATE_MESSAGE (length = %"" VAR_14 "")"", VAR_0->NegotiateMessage.cbBuffer);
winpr_HexDump(VAR_13, VAR_15, VAR_0->NegotiateMessage.pvBuffer,
VAR_0->NegotiateMessage.cbBuffer);
ntlm_print_negotiate_flags(VAR_4->NegotiateFlags);
if (VAR_4->NegotiateFlags & VAR_11)
ntlm_print_version_info(&(VAR_4->Version));
#endif
VAR_0->state = VAR_16;
Stream_Free(VAR_2, FALSE);
return VAR_17;
}",FreeRDP/8fa38359634a9910b91719818ab02f23c320dbae/ntlm_message.c/vul/before/0.json,"SECURITY_STATUS ntlm_read_NegotiateMessage(NTLM_CONTEXT* context, PSecBuffer buffer)
{
	wStream* s;
	size_t length;
	NTLM_NEGOTIATE_MESSAGE* message;
	message = &context->NEGOTIATE_MESSAGE;
	ZeroMemory(message, sizeof(NTLM_NEGOTIATE_MESSAGE));
	s = Stream_New((BYTE*)buffer->pvBuffer, buffer->cbBuffer);

	if (!s)
		return SEC_E_INTERNAL_ERROR;

	if (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*)message) < 0)
	{
		Stream_Free(s, FALSE);
		return SEC_E_INVALID_TOKEN;
	}

	if (message->MessageType != MESSAGE_TYPE_NEGOTIATE)
	{
		Stream_Free(s, FALSE);
		return SEC_E_INVALID_TOKEN;
	}

	if (Stream_GetRemainingLength(s) < 4)
	{
		Stream_Free(s, FALSE);
		return SEC_E_INVALID_TOKEN;
	}
	Stream_Read_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */

	if (!((message->NegotiateFlags & NTLMSSP_REQUEST_TARGET) &&
	      (message->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM) &&
	      (message->NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE)))
	{
		Stream_Free(s, FALSE);
		return SEC_E_INVALID_TOKEN;
	}

	context->NegotiateFlags = message->NegotiateFlags;

	/* only set if NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED is set */

	if (ntlm_read_message_fields(s, &(message->DomainName)) < 0) /* DomainNameFields (8 bytes) */
	{
		Stream_Free(s, FALSE);
		return SEC_E_INVALID_TOKEN;
	}

	/* only set if NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED is set */

	if (ntlm_read_message_fields(s, &(message->Workstation)) < 0) /* WorkstationFields (8 bytes) */
	{
		Stream_Free(s, FALSE);
		return SEC_E_INVALID_TOKEN;
	}

	if (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)
	{
		if (ntlm_read_version_info(s, &(message->Version)) < 0) /* Version (8 bytes) */
		{
			Stream_Free(s, FALSE);
			return SEC_E_INVALID_TOKEN;
		}
	}

	length = Stream_GetPosition(s);
	buffer->cbBuffer = length;

	if (!sspi_SecBufferAlloc(&context->NegotiateMessage, length))
	{
		Stream_Free(s, FALSE);
		return SEC_E_INTERNAL_ERROR;
	}

	CopyMemory(context->NegotiateMessage.pvBuffer, buffer->pvBuffer, buffer->cbBuffer);
	context->NegotiateMessage.BufferType = buffer->BufferType;
#ifdef WITH_DEBUG_NTLM
	WLog_DBG(TAG, ""NEGOTIATE_MESSAGE (length = %"" PRIu32 "")"", context->NegotiateMessage.cbBuffer);
	winpr_HexDump(TAG, WLOG_DEBUG, context->NegotiateMessage.pvBuffer,
	              context->NegotiateMessage.cbBuffer);
	ntlm_print_negotiate_flags(message->NegotiateFlags);

	if (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)
		ntlm_print_version_info(&(message->Version));

#endif
	context->state = NTLM_STATE_CHALLENGE;
	Stream_Free(s, FALSE);
	return SEC_I_CONTINUE_NEEDED;
}","SECURITY_STATUS ntlm_read_NegotiateMessage(NTLM_CONTEXT* VAR_0, PSecBuffer VAR_1)
{
	wStream* VAR_2;
	size_t VAR_3;
	NTLM_NEGOTIATE_MESSAGE* VAR_4;
	VAR_4 = &VAR_0->NEGOTIATE_MESSAGE;
	ZeroMemory(VAR_4, sizeof(NTLM_NEGOTIATE_MESSAGE));
	VAR_2 = Stream_New((BYTE*)VAR_1->pvBuffer, VAR_1->cbBuffer);

	if (!VAR_2)
		return VAR_5;

	if (ntlm_read_message_header(VAR_2, (NTLM_MESSAGE_HEADER*)VAR_4) < 0)
	{
		Stream_Free(VAR_2, FALSE);
		return VAR_6;
	}

	if (VAR_4->MessageType != VAR_7)
	{
		Stream_Free(VAR_2, FALSE);
		return VAR_6;
	}

	if (Stream_GetRemainingLength(VAR_2) < 4)
	{
		Stream_Free(VAR_2, FALSE);
		return VAR_6;
	}
	Stream_Read_UINT32(VAR_2, VAR_4->NegotiateFlags); /* COMMENT_0 */

	if (!((VAR_4->NegotiateFlags & VAR_8) &&
	      (VAR_4->NegotiateFlags & VAR_9) &&
	      (VAR_4->NegotiateFlags & VAR_10)))
	{
		Stream_Free(VAR_2, FALSE);
		return VAR_6;
	}

	VAR_0->NegotiateFlags = VAR_4->NegotiateFlags;

	/* COMMENT_1 */

	if (ntlm_read_message_fields(VAR_2, &(VAR_4->DomainName)) < 0) /* COMMENT_2 */
	{
		Stream_Free(VAR_2, FALSE);
		return VAR_6;
	}

	/* COMMENT_3 */

	if (ntlm_read_message_fields(VAR_2, &(VAR_4->Workstation)) < 0) /* COMMENT_4 */
	{
		Stream_Free(VAR_2, FALSE);
		return VAR_6;
	}

	if (VAR_4->NegotiateFlags & VAR_11)
	{
		if (ntlm_read_version_info(VAR_2, &(VAR_4->Version)) < 0) /* COMMENT_5 */
		{
			Stream_Free(VAR_2, FALSE);
			return VAR_6;
		}
	}

	VAR_3 = Stream_GetPosition(VAR_2);
	VAR_1->cbBuffer = VAR_3;

	if (!sspi_SecBufferAlloc(&VAR_0->NegotiateMessage, VAR_3))
	{
		Stream_Free(VAR_2, FALSE);
		return VAR_5;
	}

	CopyMemory(VAR_0->NegotiateMessage.pvBuffer, VAR_1->pvBuffer, VAR_1->cbBuffer);
	VAR_0->NegotiateMessage.BufferType = VAR_1->BufferType;
#ifdef VAR_12
	WLog_DBG(VAR_13, ""NEGOTIATE_MESSAGE (length = %"" VAR_14 "")"", VAR_0->NegotiateMessage.cbBuffer);
	winpr_HexDump(VAR_13, VAR_15, VAR_0->NegotiateMessage.pvBuffer,
	              VAR_0->NegotiateMessage.cbBuffer);
	ntlm_print_negotiate_flags(VAR_4->NegotiateFlags);

	if (VAR_4->NegotiateFlags & VAR_11)
		ntlm_print_version_info(&(VAR_4->Version));

#endif
	VAR_0->state = VAR_16;
	Stream_Free(VAR_2, FALSE);
	return VAR_17;
}",FreeRDP/8fa38359634a9910b91719818ab02f23c320dbae/ntlm_message.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -22,6 +22,11 @@
 		return SEC_E_INVALID_TOKEN;
 	}
 
+	if (Stream_GetRemainingLength(s) < 4)
+	{
+		Stream_Free(s, FALSE);
+		return SEC_E_INVALID_TOKEN;
+	}
 	Stream_Read_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */
 
 	if (!((message->NegotiateFlags & NTLMSSP_REQUEST_TARGET) &&","{'deleted_lines': [], 'added_lines': ['\tif (Stream_GetRemainingLength(s) < 4)', '\t{', '\t\tStream_Free(s, FALSE);', '\t\treturn SEC_E_INVALID_TOKEN;', '\t}']}",True,"In FreeRDP less than or equal to 2.0.0, there is an out-of-bound read in ntlm_read_NegotiateMessage. This has been fixed in 2.1.0.",3.1,LOW,0,valid,2020-04-15T14:48:50Z,3
CVE-2020-11958,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,skvadrik/re2c,"Fix crash in lexer refill (reported by Agostino Sarubbo).

The crash happened in a rare case of a very long lexeme that doen't fit
into the buffer, forcing buffer reallocation.

The crash was caused by an incorrect calculation of the shift offset
(it was smaller than necessary). As a consequence, the data from buffer
start and up to the beginning of the current lexeme was not discarded
(as it should have been), resulting in less free space for new data than
expected.",c4603ba5ce229db83a2a4fb93e6d4b4e3ec3776a,https://github.com/skvadrik/re2c/commit/c4603ba5ce229db83a2a4fb93e6d4b4e3ec3776a,src/parse/scanner.cc,Scanner::fill,"bool Scanner::fill(size_t need)
{
if (eof) return false;
pop_finished_files();
DASSERT(bot <= tok && tok <= lim);
size_t free = static_cast<size_t>(tok - bot);
size_t copy = static_cast<size_t>(lim - tok);
if (free >= need) {
memmove(bot, tok, copy);
shift_ptrs_and_fpos(-static_cast<ptrdiff_t>(free));
}
else {
BSIZE += std::max(BSIZE, need);
char * buf = new char[BSIZE + YYMAXFILL];
if (!buf) fatal(""out of memory"");
memmove(buf, tok, copy);
shift_ptrs_and_fpos(buf - bot);
delete [] bot;
bot = buf;
free = BSIZE - copy;
}
if (!read(free)) {
eof = lim;
memset(lim, 0, YYMAXFILL);
lim += YYMAXFILL;
}
return true;
}","bool Scanner::fill(size_t VAR_0)
{
if (VAR_1) return false;
pop_finished_files();
DASSERT(VAR_2 <= VAR_3 && VAR_3 <= VAR_4);
size_t VAR_5 = VAR_6<size_t>(VAR_3 - VAR_2);
size_t VAR_7 = VAR_6<size_t>(VAR_4 - VAR_3);
if (VAR_5 >= VAR_0) {
memmove(VAR_2, VAR_3, VAR_7);
shift_ptrs_and_fpos(-VAR_6<ptrdiff_t>(VAR_5));
}
else {
VAR_8 += std::max(VAR_8, VAR_0);
char * VAR_9 = new char[VAR_8 + VAR_10];
if (!VAR_9) fatal(""out of memory"");
memmove(VAR_9, VAR_3, VAR_7);
shift_ptrs_and_fpos(VAR_9 - VAR_2);
delete [] VAR_2;
VAR_2 = VAR_9;
VAR_5 = VAR_8 - VAR_7;
}
if (!read(VAR_5)) {
VAR_1 = VAR_4;
memset(VAR_4, 0, VAR_10);
VAR_4 += VAR_10;
}
return true;
}",skvadrik/re2c/c4603ba5ce229db83a2a4fb93e6d4b4e3ec3776a/scanner.cc/vul/before/0.json,"bool Scanner::fill(size_t need)
{
    if (eof) return false;

    pop_finished_files();

    DASSERT(bot <= tok && tok <= lim);
    size_t free = static_cast<size_t>(tok - bot);
    size_t copy = static_cast<size_t>(lim - tok);

    if (free >= need) {
        memmove(bot, tok, copy);
        shift_ptrs_and_fpos(-static_cast<ptrdiff_t>(free));
    }
    else {
        BSIZE += std::max(BSIZE, need);
        char * buf = new char[BSIZE + YYMAXFILL];
        if (!buf) fatal(""out of memory"");

        memmove(buf, tok, copy);
        shift_ptrs_and_fpos(buf - tok);
        delete [] bot;
        bot = buf;

        free = BSIZE - copy;
    }

    DASSERT(lim + free <= bot + BSIZE);
    if (!read(free)) {
        eof = lim;
        memset(lim, 0, YYMAXFILL);
        lim += YYMAXFILL;
    }

    return true;
}","bool Scanner::fill(size_t VAR_0)
{
    if (VAR_1) return false;

    pop_finished_files();

    DASSERT(VAR_2 <= VAR_3 && VAR_3 <= VAR_4);
    size_t VAR_5 = VAR_6<size_t>(VAR_3 - VAR_2);
    size_t VAR_7 = VAR_6<size_t>(VAR_4 - VAR_3);

    if (VAR_5 >= VAR_0) {
        memmove(VAR_2, VAR_3, VAR_7);
        shift_ptrs_and_fpos(-VAR_6<ptrdiff_t>(VAR_5));
    }
    else {
        VAR_8 += std::max(VAR_8, VAR_0);
        char * VAR_9 = new char[VAR_8 + VAR_10];
        if (!VAR_9) fatal(""out of memory"");

        memmove(VAR_9, VAR_3, VAR_7);
        shift_ptrs_and_fpos(VAR_9 - VAR_3);
        delete [] VAR_2;
        VAR_2 = VAR_9;

        VAR_5 = VAR_8 - VAR_7;
    }

    DASSERT(VAR_4 + VAR_5 <= VAR_2 + VAR_8);
    if (!read(VAR_5)) {
        VAR_1 = VAR_4;
        memset(VAR_4, 0, VAR_10);
        VAR_4 += VAR_10;
    }

    return true;
}",skvadrik/re2c/c4603ba5ce229db83a2a4fb93e6d4b4e3ec3776a/scanner.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -18,13 +18,14 @@
         if (!buf) fatal(""out of memory"");
 
         memmove(buf, tok, copy);
-        shift_ptrs_and_fpos(buf - bot);
+        shift_ptrs_and_fpos(buf - tok);
         delete [] bot;
         bot = buf;
 
         free = BSIZE - copy;
     }
 
+    DASSERT(lim + free <= bot + BSIZE);
     if (!read(free)) {
         eof = lim;
         memset(lim, 0, YYMAXFILL);","{'deleted_lines': ['        shift_ptrs_and_fpos(buf - bot);'], 'added_lines': ['        shift_ptrs_and_fpos(buf - tok);', '    DASSERT(lim + free <= bot + BSIZE);']}",True,re2c 1.3 has a heap-based buffer overflow in Scanner::fill in parse/scanner.cc via a long lexeme.,7.8,HIGH,2,valid,2020-04-17T21:47:14Z,3
CVE-2020-13249,['CWE-Other'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,mariadb-corporation/mariadb-connector-c,"sanity checks for client-supplied OK packet content

reported by Matthias Kaiser, Apple Information Security",2759b87d72926b7c9b5426437a7c8dd15ff57945,https://github.com/mariadb-corporation/mariadb-connector-c/commit/2759b87d72926b7c9b5426437a7c8dd15ff57945,libmariadb/mariadb_lib.c,ma_read_ok_packet,"int ma_read_ok_packet(MYSQL *mysql, uchar *pos, ulong length)
{
size_t item_len;
mysql->affected_rows= net_field_length_ll(&pos);
mysql->insert_id=  net_field_length_ll(&pos);
mysql->server_status=uint2korr(pos);
pos+=2;
mysql->warning_count=uint2korr(pos);
pos+=2;
if (pos < mysql->net.read_pos+length)
{
if ((item_len= net_field_length(&pos)))
mysql->info=(char*) pos;
if (mysql->server_capabilities & CLIENT_SESSION_TRACKING)
{
ma_clear_session_state(mysql);
pos+= item_len;
if (mysql->server_status & SERVER_SESSION_STATE_CHANGED)
{
int i;
if (pos < mysql->net.read_pos + length)
{
LIST *session_item;
MYSQL_LEX_STRING *str= NULL;
enum enum_session_state_type si_type;
uchar *old_pos= pos;
size_t item_len= net_field_length(&pos);  
if (mysql->info)
*old_pos= 0;
while (item_len > 0)
{
size_t plen;
char *data;
old_pos= pos;
si_type= (enum enum_session_state_type)net_field_length(&pos);
switch(si_type) {
case SESSION_TRACK_SCHEMA:
case SESSION_TRACK_STATE_CHANGE:
case SESSION_TRACK_TRANSACTION_CHARACTERISTICS:
case SESSION_TRACK_SYSTEM_VARIABLES:
if (si_type != SESSION_TRACK_STATE_CHANGE)
net_field_length(&pos); 
plen= net_field_length(&pos);
if (!(session_item= ma_multi_malloc(0,
&session_item, sizeof(LIST),
&str, sizeof(MYSQL_LEX_STRING),
&data, plen,
NULL)))
{
ma_clear_session_state(mysql);
SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);
return -1;
}
str->length= plen;
str->str= data;
memcpy(str->str, (char *)pos, plen);
pos+= plen;
session_item->data= str;
mysql->extension->session_state[si_type].list= list_add(mysql->extension->session_state[si_type].list, session_item);
if (si_type == SESSION_TRACK_SCHEMA)
{
free(mysql->db);
mysql->db= malloc(plen + 1);
memcpy(mysql->db, str->str, plen);
mysql->db[plen]= 0;
}
else if (si_type == SESSION_TRACK_SYSTEM_VARIABLES)
{
my_bool set_charset= 0;
if (!strncmp(str->str, ""character_set_client"", str->length))
set_charset= 1;
plen= net_field_length(&pos);
if (!(session_item= ma_multi_malloc(0,
&session_item, sizeof(LIST),
&str, sizeof(MYSQL_LEX_STRING),
&data, plen,
NULL)))
{
ma_clear_session_state(mysql);
SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);
return -1;
}
str->length= plen;
str->str= data;
memcpy(str->str, (char *)pos, plen);
pos+= plen;
session_item->data= str;
mysql->extension->session_state[si_type].list= list_add(mysql->extension->session_state[si_type].list, session_item);
if (set_charset &&
strncmp(mysql->charset->csname, str->str, str->length) != 0)
{
char cs_name[64];
MARIADB_CHARSET_INFO *cs_info;
memcpy(cs_name, str->str, str->length);
cs_name[str->length]= 0;
if ((cs_info = (MARIADB_CHARSET_INFO *)mysql_find_charset_name(cs_name)))
mysql->charset= cs_info;
}
}
break;
default:
plen= net_field_length(&pos);
pos+= plen;
break;
}
item_len-= (pos - old_pos);
}
}
for (i= SESSION_TRACK_BEGIN; i <= SESSION_TRACK_END; i++)
{
mysql->extension->session_state[i].list= list_reverse(mysql->extension->session_state[i].list);
mysql->extension->session_state[i].current= mysql->extension->session_state[i].list;
}
}
}
}
else if (mysql->server_capabilities & CLIENT_SESSION_TRACKING)
ma_clear_session_state(mysql);
return(0);
}","int ma_read_ok_packet(MYSQL *VAR_0, uchar *VAR_1, ulong VAR_2)
{
size_t VAR_3;
VAR_0->affected_rows= net_field_length_ll(&VAR_1);
VAR_0->insert_id=  net_field_length_ll(&VAR_1);
VAR_0->server_status=uint2korr(VAR_1);
VAR_1+=2;
VAR_0->warning_count=uint2korr(VAR_1);
VAR_1+=2;
if (VAR_1 < VAR_0->net.read_pos+VAR_2)
{
if ((VAR_3= net_field_length(&VAR_1)))
VAR_0->info=(char*) VAR_1;
if (VAR_0->server_capabilities & VAR_4)
{
ma_clear_session_state(VAR_0);
VAR_1+= VAR_3;
if (VAR_0->server_status & VAR_5)
{
int VAR_6;
if (VAR_1 < VAR_0->net.read_pos + VAR_2)
{
LIST *VAR_7;
MYSQL_LEX_STRING *VAR_8= NULL;
enum enum_session_state_type VAR_9;
uchar *VAR_10= VAR_1;
size_t VAR_3= net_field_length(&VAR_1);  
if (VAR_0->info)
*VAR_10= 0;
while (VAR_3 > 0)
{
size_t VAR_11;
char *VAR_12;
VAR_10= VAR_1;
VAR_9= (enum enum_session_state_type)net_field_length(&VAR_1);
switch(VAR_9) {
case VAR_13:
case VAR_14:
case VAR_15:
case VAR_16:
if (VAR_9 != VAR_14)
net_field_length(&VAR_1); 
VAR_11= net_field_length(&VAR_1);
if (!(VAR_7= ma_multi_malloc(0,
&VAR_7, sizeof(LIST),
&VAR_8, sizeof(MYSQL_LEX_STRING),
&VAR_12, VAR_11,
NULL)))
{
ma_clear_session_state(VAR_0);
SET_CLIENT_ERROR(VAR_0, VAR_17, VAR_18, 0);
return -1;
}
VAR_8->length= VAR_11;
VAR_8->str= VAR_12;
memcpy(VAR_8->str, (char *)VAR_1, VAR_11);
VAR_1+= VAR_11;
VAR_7->data= VAR_8;
VAR_0->extension->session_state[VAR_9].list= list_add(VAR_0->extension->session_state[VAR_9].list, VAR_7);
if (VAR_9 == VAR_13)
{
free(VAR_0->db);
VAR_0->db= malloc(VAR_11 + 1);
memcpy(VAR_0->db, VAR_8->str, VAR_11);
VAR_0->db[VAR_11]= 0;
}
else if (VAR_9 == VAR_16)
{
my_bool VAR_19= 0;
if (!strncmp(VAR_8->str, ""character_set_client"", VAR_8->length))
VAR_19= 1;
VAR_11= net_field_length(&VAR_1);
if (!(VAR_7= ma_multi_malloc(0,
&VAR_7, sizeof(LIST),
&VAR_8, sizeof(MYSQL_LEX_STRING),
&VAR_12, VAR_11,
NULL)))
{
ma_clear_session_state(VAR_0);
SET_CLIENT_ERROR(VAR_0, VAR_17, VAR_18, 0);
return -1;
}
VAR_8->length= VAR_11;
VAR_8->str= VAR_12;
memcpy(VAR_8->str, (char *)VAR_1, VAR_11);
VAR_1+= VAR_11;
VAR_7->data= VAR_8;
VAR_0->extension->session_state[VAR_9].list= list_add(VAR_0->extension->session_state[VAR_9].list, VAR_7);
if (VAR_19 &&
strncmp(VAR_0->charset->csname, VAR_8->str, VAR_8->length) != 0)
{
char VAR_20[64];
MARIADB_CHARSET_INFO *VAR_21;
memcpy(VAR_20, VAR_8->str, VAR_8->length);
VAR_20[VAR_8->length]= 0;
if ((VAR_21 = (MARIADB_CHARSET_INFO *)mysql_find_charset_name(VAR_20)))
VAR_0->charset= VAR_21;
}
}
break;
default:
VAR_11= net_field_length(&VAR_1);
VAR_1+= VAR_11;
break;
}
VAR_3-= (VAR_1 - VAR_10);
}
}
for (VAR_6= VAR_22; VAR_6 <= VAR_23; VAR_6++)
{
VAR_0->extension->session_state[VAR_6].list= list_reverse(VAR_0->extension->session_state[VAR_6].list);
VAR_0->extension->session_state[VAR_6].current= VAR_0->extension->session_state[VAR_6].list;
}
}
}
}
else if (VAR_0->server_capabilities & VAR_4)
ma_clear_session_state(VAR_0);
return(0);
}",mariadb-corporation/mariadb-connector-c/2759b87d72926b7c9b5426437a7c8dd15ff57945/mariadb_lib.c/vul/before/0.json,"int ma_read_ok_packet(MYSQL *mysql, uchar *pos, ulong length)
{
  uchar *end= mysql->net.read_pos+length;
  size_t item_len;
  mysql->affected_rows= net_field_length_ll(&pos);
  mysql->insert_id=	  net_field_length_ll(&pos);
  mysql->server_status=uint2korr(pos);
  pos+=2;
  mysql->warning_count=uint2korr(pos);
  pos+=2;
  if (pos > end)
    goto corrupted;
  if (pos < end)
  {
    if ((item_len= net_field_length(&pos)))
      mysql->info=(char*) pos;
    if (pos + item_len > end)
      goto corrupted;

    /* check if server supports session tracking */
    if (mysql->server_capabilities & CLIENT_SESSION_TRACKING)
    {
      ma_clear_session_state(mysql);
      pos+= item_len;

      if (mysql->server_status & SERVER_SESSION_STATE_CHANGED)
      {
        int i;
        if (pos < end)
        {
          LIST *session_item;
          MYSQL_LEX_STRING *str= NULL;
          enum enum_session_state_type si_type;
          uchar *old_pos= pos;

          item_len= net_field_length(&pos);  /* length for all items */
          if (pos + item_len > end)
            goto corrupted;
          end= pos + item_len;

          /* length was already set, so make sure that info will be zero terminated */
          if (mysql->info)
            *old_pos= 0;

          while (pos < end)
          {
            size_t plen;
            char *data;
            si_type= (enum enum_session_state_type)net_field_length(&pos);
            switch(si_type) {
            case SESSION_TRACK_SCHEMA:
            case SESSION_TRACK_STATE_CHANGE:
            case SESSION_TRACK_TRANSACTION_CHARACTERISTICS:
            case SESSION_TRACK_SYSTEM_VARIABLES:
              if (si_type != SESSION_TRACK_STATE_CHANGE)
                net_field_length(&pos); /* ignore total length, item length will follow next */
              plen= net_field_length(&pos);
              if (pos + plen > end)
                goto corrupted;
              if (!(session_item= ma_multi_malloc(0,
                                  &session_item, sizeof(LIST),
                                  &str, sizeof(MYSQL_LEX_STRING),
                                  &data, plen,
                                  NULL)))
                  goto oom;
              str->length= plen;
              str->str= data;
              memcpy(str->str, (char *)pos, plen);
              pos+= plen;
              session_item->data= str;
              mysql->extension->session_state[si_type].list= list_add(mysql->extension->session_state[si_type].list, session_item);

              /* in case schema has changed, we have to update mysql->db */
              if (si_type == SESSION_TRACK_SCHEMA)
              {
                free(mysql->db);
                mysql->db= malloc(plen + 1);
                memcpy(mysql->db, str->str, plen);
                mysql->db[plen]= 0;
              }
              else if (si_type == SESSION_TRACK_SYSTEM_VARIABLES)
              {
                my_bool set_charset= 0;
                /* make sure that we update charset in case it has changed */
                if (!strncmp(str->str, ""character_set_client"", str->length))
                  set_charset= 1;
                plen= net_field_length(&pos);
                if (pos + plen > end)
                  goto corrupted;
                if (!(session_item= ma_multi_malloc(0,
                                    &session_item, sizeof(LIST),
                                    &str, sizeof(MYSQL_LEX_STRING),
                                    &data, plen,
                                    NULL)))
                  goto oom;
                str->length= plen;
                str->str= data;
                memcpy(str->str, (char *)pos, plen);
                pos+= plen;
                session_item->data= str;
                mysql->extension->session_state[si_type].list= list_add(mysql->extension->session_state[si_type].list, session_item);
                if (set_charset && str->length < CHARSET_NAME_LEN &&
                    strncmp(mysql->charset->csname, str->str, str->length) != 0)
                {
                  char cs_name[CHARSET_NAME_LEN];
                  const MARIADB_CHARSET_INFO *cs_info;
                  memcpy(cs_name, str->str, str->length);
                  cs_name[str->length]= 0;
                  if ((cs_info = mysql_find_charset_name(cs_name)))
                    mysql->charset= cs_info;
                }
              }
              break;
            default:
              /* not supported yet */
              plen= net_field_length(&pos);
              if (pos + plen > end)
                goto corrupted;
              pos+= plen;
              break;
            }
          }
        }
        for (i= SESSION_TRACK_BEGIN; i <= SESSION_TRACK_END; i++)
        {
          mysql->extension->session_state[i].list= list_reverse(mysql->extension->session_state[i].list);
          mysql->extension->session_state[i].current= mysql->extension->session_state[i].list;
        }
      }
    }
  }
  /* CONC-351: clear session state information */
  else if (mysql->server_capabilities & CLIENT_SESSION_TRACKING)
    ma_clear_session_state(mysql);
  return(0);

oom:
  ma_clear_session_state(mysql);
  SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);
  return -1;

corrupted:
  ma_clear_session_state(mysql);
  SET_CLIENT_ERROR(mysql, CR_MALFORMED_PACKET, SQLSTATE_UNKNOWN, 0);
  return -1;
}","int ma_read_ok_packet(MYSQL *VAR_0, uchar *VAR_1, ulong VAR_2)
{
  uchar *VAR_3= VAR_0->net.read_pos+VAR_2;
  size_t VAR_4;
  VAR_0->affected_rows= net_field_length_ll(&VAR_1);
  VAR_0->insert_id=	  net_field_length_ll(&VAR_1);
  VAR_0->server_status=uint2korr(VAR_1);
  VAR_1+=2;
  VAR_0->warning_count=uint2korr(VAR_1);
  VAR_1+=2;
  if (VAR_1 > VAR_3)
    goto corrupted;
  if (VAR_1 < VAR_3)
  {
    if ((VAR_4= net_field_length(&VAR_1)))
      VAR_0->info=(char*) VAR_1;
    if (VAR_1 + VAR_4 > VAR_3)
      goto corrupted;

    /* COMMENT_0 */
    if (VAR_0->server_capabilities & VAR_5)
    {
      ma_clear_session_state(VAR_0);
      VAR_1+= VAR_4;

      if (VAR_0->server_status & VAR_6)
      {
        int VAR_7;
        if (VAR_1 < VAR_3)
        {
          LIST *VAR_8;
          MYSQL_LEX_STRING *VAR_9= NULL;
          enum enum_session_state_type VAR_10;
          uchar *VAR_11= VAR_1;

          VAR_4= net_field_length(&VAR_1);  /* COMMENT_1 */
          if (VAR_1 + VAR_4 > VAR_3)
            goto corrupted;
          VAR_3= VAR_1 + VAR_4;

          /* COMMENT_2 */
          if (VAR_0->info)
            *VAR_11= 0;

          while (VAR_1 < VAR_3)
          {
            size_t VAR_12;
            char *VAR_13;
            VAR_10= (enum enum_session_state_type)net_field_length(&VAR_1);
            switch(VAR_10) {
            case VAR_14:
            case VAR_15:
            case VAR_16:
            case VAR_17:
              if (VAR_10 != VAR_15)
                net_field_length(&VAR_1); /* COMMENT_3 */
              VAR_12= net_field_length(&VAR_1);
              if (VAR_1 + VAR_12 > VAR_3)
                goto corrupted;
              if (!(VAR_8= ma_multi_malloc(0,
                                  &VAR_8, sizeof(LIST),
                                  &VAR_9, sizeof(MYSQL_LEX_STRING),
                                  &VAR_13, VAR_12,
                                  NULL)))
                  goto oom;
              VAR_9->length= VAR_12;
              VAR_9->str= VAR_13;
              memcpy(VAR_9->str, (char *)VAR_1, VAR_12);
              VAR_1+= VAR_12;
              VAR_8->data= VAR_9;
              VAR_0->extension->session_state[VAR_10].list= list_add(VAR_0->extension->session_state[VAR_10].list, VAR_8);

              /* COMMENT_4 */
              if (VAR_10 == VAR_14)
              {
                free(VAR_0->db);
                VAR_0->db= malloc(VAR_12 + 1);
                memcpy(VAR_0->db, VAR_9->str, VAR_12);
                VAR_0->db[VAR_12]= 0;
              }
              else if (VAR_10 == VAR_17)
              {
                my_bool VAR_18= 0;
                /* COMMENT_5 */
                if (!strncmp(VAR_9->str, ""character_set_client"", VAR_9->length))
                  VAR_18= 1;
                VAR_12= net_field_length(&VAR_1);
                if (VAR_1 + VAR_12 > VAR_3)
                  goto corrupted;
                if (!(VAR_8= ma_multi_malloc(0,
                                    &VAR_8, sizeof(LIST),
                                    &VAR_9, sizeof(MYSQL_LEX_STRING),
                                    &VAR_13, VAR_12,
                                    NULL)))
                  goto oom;
                VAR_9->length= VAR_12;
                VAR_9->str= VAR_13;
                memcpy(VAR_9->str, (char *)VAR_1, VAR_12);
                VAR_1+= VAR_12;
                VAR_8->data= VAR_9;
                VAR_0->extension->session_state[VAR_10].list= list_add(VAR_0->extension->session_state[VAR_10].list, VAR_8);
                if (VAR_18 && VAR_9->length < VAR_19 &&
                    strncmp(VAR_0->charset->csname, VAR_9->str, VAR_9->length) != 0)
                {
                  char VAR_20[VAR_19];
                  const MARIADB_CHARSET_INFO *VAR_21;
                  memcpy(VAR_20, VAR_9->str, VAR_9->length);
                  VAR_20[VAR_9->length]= 0;
                  if ((VAR_21 = mysql_find_charset_name(VAR_20)))
                    VAR_0->charset= VAR_21;
                }
              }
              break;
            default:
              /* COMMENT_6 */
              VAR_12= net_field_length(&VAR_1);
              if (VAR_1 + VAR_12 > VAR_3)
                goto corrupted;
              VAR_1+= VAR_12;
              break;
            }
          }
        }
        for (VAR_7= VAR_22; VAR_7 <= VAR_23; VAR_7++)
        {
          VAR_0->extension->session_state[VAR_7].list= list_reverse(VAR_0->extension->session_state[VAR_7].list);
          VAR_0->extension->session_state[VAR_7].current= VAR_0->extension->session_state[VAR_7].list;
        }
      }
    }
  }
  /* COMMENT_7 */
  else if (VAR_0->server_capabilities & VAR_5)
    ma_clear_session_state(VAR_0);
  return(0);

oom:
  ma_clear_session_state(VAR_0);
  SET_CLIENT_ERROR(VAR_0, VAR_24, VAR_25, 0);
  return -1;

corrupted:
  ma_clear_session_state(VAR_0);
  SET_CLIENT_ERROR(VAR_0, VAR_26, VAR_25, 0);
  return -1;
}",mariadb-corporation/mariadb-connector-c/2759b87d72926b7c9b5426437a7c8dd15ff57945/mariadb_lib.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,6 @@
 int ma_read_ok_packet(MYSQL *mysql, uchar *pos, ulong length)
 {
+  uchar *end= mysql->net.read_pos+length;
   size_t item_len;
   mysql->affected_rows= net_field_length_ll(&pos);
   mysql->insert_id=	  net_field_length_ll(&pos);
@@ -7,10 +8,14 @@
   pos+=2;
   mysql->warning_count=uint2korr(pos);
   pos+=2;
-  if (pos < mysql->net.read_pos+length)
+  if (pos > end)
+    goto corrupted;
+  if (pos < end)
   {
     if ((item_len= net_field_length(&pos)))
       mysql->info=(char*) pos;
+    if (pos + item_len > end)
+      goto corrupted;
 
     /* check if server supports session tracking */
     if (mysql->server_capabilities & CLIENT_SESSION_TRACKING)
@@ -21,23 +26,26 @@
       if (mysql->server_status & SERVER_SESSION_STATE_CHANGED)
       {
         int i;
-        if (pos < mysql->net.read_pos + length)
+        if (pos < end)
         {
           LIST *session_item;
           MYSQL_LEX_STRING *str= NULL;
           enum enum_session_state_type si_type;
           uchar *old_pos= pos;
-          size_t item_len= net_field_length(&pos);  /* length for all items */
+
+          item_len= net_field_length(&pos);  /* length for all items */
+          if (pos + item_len > end)
+            goto corrupted;
+          end= pos + item_len;
 
           /* length was already set, so make sure that info will be zero terminated */
           if (mysql->info)
             *old_pos= 0;
 
-          while (item_len > 0)
+          while (pos < end)
           {
             size_t plen;
             char *data;
-            old_pos= pos;
             si_type= (enum enum_session_state_type)net_field_length(&pos);
             switch(si_type) {
             case SESSION_TRACK_SCHEMA:
@@ -47,16 +55,14 @@
               if (si_type != SESSION_TRACK_STATE_CHANGE)
                 net_field_length(&pos); /* ignore total length, item length will follow next */
               plen= net_field_length(&pos);
+              if (pos + plen > end)
+                goto corrupted;
               if (!(session_item= ma_multi_malloc(0,
                                   &session_item, sizeof(LIST),
                                   &str, sizeof(MYSQL_LEX_STRING),
                                   &data, plen,
                                   NULL)))
-              {
-                ma_clear_session_state(mysql);
-                SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);
-                return -1;
-              }
+                  goto oom;
               str->length= plen;
               str->str= data;
               memcpy(str->str, (char *)pos, plen);
@@ -79,30 +85,28 @@
                 if (!strncmp(str->str, ""character_set_client"", str->length))
                   set_charset= 1;
                 plen= net_field_length(&pos);
+                if (pos + plen > end)
+                  goto corrupted;
                 if (!(session_item= ma_multi_malloc(0,
                                     &session_item, sizeof(LIST),
                                     &str, sizeof(MYSQL_LEX_STRING),
                                     &data, plen,
                                     NULL)))
-                {
-                  ma_clear_session_state(mysql);
-                  SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);
-                  return -1;
-                }
+                  goto oom;
                 str->length= plen;
                 str->str= data;
                 memcpy(str->str, (char *)pos, plen);
                 pos+= plen;
                 session_item->data= str;
                 mysql->extension->session_state[si_type].list= list_add(mysql->extension->session_state[si_type].list, session_item);
-                if (set_charset &&
+                if (set_charset && str->length < CHARSET_NAME_LEN &&
                     strncmp(mysql->charset->csname, str->str, str->length) != 0)
                 {
-                  char cs_name[64];
-                  MARIADB_CHARSET_INFO *cs_info;
+                  char cs_name[CHARSET_NAME_LEN];
+                  const MARIADB_CHARSET_INFO *cs_info;
                   memcpy(cs_name, str->str, str->length);
                   cs_name[str->length]= 0;
-                  if ((cs_info = (MARIADB_CHARSET_INFO *)mysql_find_charset_name(cs_name)))
+                  if ((cs_info = mysql_find_charset_name(cs_name)))
                     mysql->charset= cs_info;
                 }
               }
@@ -110,10 +114,11 @@
             default:
               /* not supported yet */
               plen= net_field_length(&pos);
+              if (pos + plen > end)
+                goto corrupted;
               pos+= plen;
               break;
             }
-            item_len-= (pos - old_pos);
           }
         }
         for (i= SESSION_TRACK_BEGIN; i <= SESSION_TRACK_END; i++)
@@ -128,4 +133,14 @@
   else if (mysql->server_capabilities & CLIENT_SESSION_TRACKING)
     ma_clear_session_state(mysql);
   return(0);
+
+oom:
+  ma_clear_session_state(mysql);
+  SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);
+  return -1;
+
+corrupted:
+  ma_clear_session_state(mysql);
+  SET_CLIENT_ERROR(mysql, CR_MALFORMED_PACKET, SQLSTATE_UNKNOWN, 0);
+  return -1;
 }","{'deleted_lines': ['  if (pos < mysql->net.read_pos+length)', '        if (pos < mysql->net.read_pos + length)', '          size_t item_len= net_field_length(&pos);  /* length for all items */', '          while (item_len > 0)', '            old_pos= pos;', '              {', '                ma_clear_session_state(mysql);', '                SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);', '                return -1;', '              }', '                {', '                  ma_clear_session_state(mysql);', '                  SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);', '                  return -1;', '                }', '                if (set_charset &&', '                  char cs_name[64];', '                  MARIADB_CHARSET_INFO *cs_info;', '                  if ((cs_info = (MARIADB_CHARSET_INFO *)mysql_find_charset_name(cs_name)))', '            item_len-= (pos - old_pos);'], 'added_lines': ['  uchar *end= mysql->net.read_pos+length;', '  if (pos > end)', '    goto corrupted;', '  if (pos < end)', '    if (pos + item_len > end)', '      goto corrupted;', '        if (pos < end)', '', '          item_len= net_field_length(&pos);  /* length for all items */', '          if (pos + item_len > end)', '            goto corrupted;', '          end= pos + item_len;', '          while (pos < end)', '              if (pos + plen > end)', '                goto corrupted;', '                  goto oom;', '                if (pos + plen > end)', '                  goto corrupted;', '                  goto oom;', '                if (set_charset && str->length < CHARSET_NAME_LEN &&', '                  char cs_name[CHARSET_NAME_LEN];', '                  const MARIADB_CHARSET_INFO *cs_info;', '                  if ((cs_info = mysql_find_charset_name(cs_name)))', '              if (pos + plen > end)', '                goto corrupted;', '', 'oom:', '  ma_clear_session_state(mysql);', '  SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);', '  return -1;', '', 'corrupted:', '  ma_clear_session_state(mysql);', '  SET_CLIENT_ERROR(mysql, CR_MALFORMED_PACKET, SQLSTATE_UNKNOWN, 0);', '  return -1;']}",True,"libmariadb/mariadb_lib.c in MariaDB Connector/C before 3.1.8 does not properly validate the content of an OK packet received from a server. NOTE: although mariadb_lib.c was originally based on code shipped for MySQL, this issue does not affect any MySQL components supported by Oracle.",8.8,HIGH,2,valid,2020-05-07T12:57:00Z,3
CVE-2020-15476,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ntop/nDPI,"Adds bound check in oracle protocol

Found by oss-fuzz
https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=21780",b69177be2fbe01c2442239a61832c44e40136c05,https://github.com/ntop/nDPI/commit/b69177be2fbe01c2442239a61832c44e40136c05,src/lib/protocols/oracle.c,ndpi_search_oracle,"void ndpi_search_oracle(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
{
struct ndpi_packet_struct *packet = &flow->packet;
u_int16_t dport = 0, sport = 0;
NDPI_LOG_DBG(ndpi_struct, ""search ORACLE\n"");
if(packet->tcp != NULL) {
sport = ntohs(packet->tcp->source), dport = ntohs(packet->tcp->dest);
NDPI_LOG_DBG2(ndpi_struct, ""calculating ORACLE over tcp\n"");
if ((dport == 1521 || sport == 1521)
&&  (((packet->payload[0] == 0x07) && (packet->payload[1] == 0xff) && (packet->payload[2] == 0x00))
|| ((packet->payload_packet_len >= 232) && ((packet->payload[0] == 0x00) || (packet->payload[0] == 0x01)) 
&& (packet->payload[1] != 0x00)
&& (packet->payload[2] == 0x00)
&& (packet->payload[3] == 0x00)))) {
NDPI_LOG_INFO(ndpi_struct, ""found oracle\n"");
ndpi_int_oracle_add_connection(ndpi_struct, flow);
} else if (packet->payload_packet_len == 213 && packet->payload[0] == 0x00 &&
packet->payload[1] == 0xd5 && packet->payload[2] == 0x00 &&
packet->payload[3] == 0x00 ) {
NDPI_LOG_INFO(ndpi_struct, ""found oracle\n"");
ndpi_int_oracle_add_connection(ndpi_struct, flow);
}
} else {
NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
}
}","void ndpi_search_oracle(struct ndpi_detection_module_struct *VAR_0, struct ndpi_flow_struct *VAR_1)
{
struct ndpi_packet_struct *VAR_2 = &VAR_1->packet;
u_int16_t VAR_3 = 0, VAR_4 = 0;
NDPI_LOG_DBG(VAR_0, ""search ORACLE\n"");
if(VAR_2->tcp != NULL) {
VAR_4 = ntohs(VAR_2->tcp->source), VAR_3 = ntohs(VAR_2->tcp->dest);
NDPI_LOG_DBG2(VAR_0, ""calculating ORACLE over tcp\n"");
if ((VAR_3 == 1521 || VAR_4 == 1521)
&&  (((VAR_2->payload[0] == 0x07) && (VAR_2->payload[1] == 0xff) && (VAR_2->payload[2] == 0x00))
|| ((VAR_2->payload_packet_len >= 232) && ((VAR_2->payload[0] == 0x00) || (VAR_2->payload[0] == 0x01)) 
&& (VAR_2->payload[1] != 0x00)
&& (VAR_2->payload[2] == 0x00)
&& (VAR_2->payload[3] == 0x00)))) {
NDPI_LOG_INFO(VAR_0, ""found oracle\n"");
ndpi_int_oracle_add_connection(VAR_0, VAR_1);
} else if (VAR_2->payload_packet_len == 213 && VAR_2->payload[0] == 0x00 &&
VAR_2->payload[1] == 0xd5 && VAR_2->payload[2] == 0x00 &&
VAR_2->payload[3] == 0x00 ) {
NDPI_LOG_INFO(VAR_0, ""found oracle\n"");
ndpi_int_oracle_add_connection(VAR_0, VAR_1);
}
} else {
NDPI_EXCLUDE_PROTO(VAR_0, VAR_1);
}
}",ntop/nDPI/b69177be2fbe01c2442239a61832c44e40136c05/oracle.c/vul/before/0.json,"void ndpi_search_oracle(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)
{
  struct ndpi_packet_struct *packet = &flow->packet;
  u_int16_t dport = 0, sport = 0;

  NDPI_LOG_DBG(ndpi_struct, ""search ORACLE\n"");

  if(packet->tcp != NULL) {
    sport = ntohs(packet->tcp->source), dport = ntohs(packet->tcp->dest);
    NDPI_LOG_DBG2(ndpi_struct, ""calculating ORACLE over tcp\n"");
    /* Oracle Database 9g,10g,11g */
    if ((dport == 1521 || sport == 1521)
	&&  (((packet->payload_packet_len >= 3 && packet->payload[0] == 0x07) && (packet->payload[1] == 0xff) && (packet->payload[2] == 0x00))
	     || ((packet->payload_packet_len >= 232) && ((packet->payload[0] == 0x00) || (packet->payload[0] == 0x01)) 
	     && (packet->payload[1] != 0x00)
	     && (packet->payload[2] == 0x00)
		 && (packet->payload[3] == 0x00)))) {
      NDPI_LOG_INFO(ndpi_struct, ""found oracle\n"");
      ndpi_int_oracle_add_connection(ndpi_struct, flow);
    } else if (packet->payload_packet_len == 213 && packet->payload[0] == 0x00 &&
               packet->payload[1] == 0xd5 && packet->payload[2] == 0x00 &&
               packet->payload[3] == 0x00 ) {
      NDPI_LOG_INFO(ndpi_struct, ""found oracle\n"");
      ndpi_int_oracle_add_connection(ndpi_struct, flow);
    }
  } else {
    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);
  }
}","void ndpi_search_oracle(struct ndpi_detection_module_struct *VAR_0, struct ndpi_flow_struct *VAR_1)
{
  struct ndpi_packet_struct *VAR_2 = &VAR_1->packet;
  u_int16_t VAR_3 = 0, VAR_4 = 0;

  NDPI_LOG_DBG(VAR_0, ""search ORACLE\n"");

  if(VAR_2->tcp != NULL) {
    VAR_4 = ntohs(VAR_2->tcp->source), VAR_3 = ntohs(VAR_2->tcp->dest);
    NDPI_LOG_DBG2(VAR_0, ""calculating ORACLE over tcp\n"");
    /* COMMENT_0 */
    if ((VAR_3 == 1521 || VAR_4 == 1521)
	&&  (((VAR_2->payload_packet_len >= 3 && VAR_2->payload[0] == 0x07) && (VAR_2->payload[1] == 0xff) && (VAR_2->payload[2] == 0x00))
	     || ((VAR_2->payload_packet_len >= 232) && ((VAR_2->payload[0] == 0x00) || (VAR_2->payload[0] == 0x01)) 
	     && (VAR_2->payload[1] != 0x00)
	     && (VAR_2->payload[2] == 0x00)
		 && (VAR_2->payload[3] == 0x00)))) {
      NDPI_LOG_INFO(VAR_0, ""found oracle\n"");
      ndpi_int_oracle_add_connection(VAR_0, VAR_1);
    } else if (VAR_2->payload_packet_len == 213 && VAR_2->payload[0] == 0x00 &&
               VAR_2->payload[1] == 0xd5 && VAR_2->payload[2] == 0x00 &&
               VAR_2->payload[3] == 0x00 ) {
      NDPI_LOG_INFO(VAR_0, ""found oracle\n"");
      ndpi_int_oracle_add_connection(VAR_0, VAR_1);
    }
  } else {
    NDPI_EXCLUDE_PROTO(VAR_0, VAR_1);
  }
}",ntop/nDPI/b69177be2fbe01c2442239a61832c44e40136c05/oracle.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,7 +10,7 @@
     NDPI_LOG_DBG2(ndpi_struct, ""calculating ORACLE over tcp\n"");
     /* Oracle Database 9g,10g,11g */
     if ((dport == 1521 || sport == 1521)
-	&&  (((packet->payload[0] == 0x07) && (packet->payload[1] == 0xff) && (packet->payload[2] == 0x00))
+	&&  (((packet->payload_packet_len >= 3 && packet->payload[0] == 0x07) && (packet->payload[1] == 0xff) && (packet->payload[2] == 0x00))
 	     || ((packet->payload_packet_len >= 232) && ((packet->payload[0] == 0x00) || (packet->payload[0] == 0x01)) 
 	     && (packet->payload[1] != 0x00)
 	     && (packet->payload[2] == 0x00)","{'deleted_lines': ['\t&&  (((packet->payload[0] == 0x07) && (packet->payload[1] == 0xff) && (packet->payload[2] == 0x00))'], 'added_lines': ['\t&&  (((packet->payload_packet_len >= 3 && packet->payload[0] == 0x07) && (packet->payload[1] == 0xff) && (packet->payload[2] == 0x00))']}",True,"In nDPI through 3.2, the Oracle protocol dissector has a heap-based buffer over-read in ndpi_search_oracle in lib/protocols/oracle.c.",7.5,HIGH,2,valid,2020-05-10T13:04:23Z,3
CVE-2020-13398,['CWE-787'],AV:N/AC:L/Au:S/C:P/I:P/A:P,0,FreeRDP,"Fixed  GHSL-2020-102 heap overflow

(cherry picked from commit 197b16cc15a12813c2e4fa2d6ae9cd9c4a57e581)",8305349a943c68b1bc8c158f431dc607655aadea,https://github.com/FreeRDP/FreeRDP/commit/8305349a943c68b1bc8c158f431dc607655aadea,libfreerdp/crypto/crypto.c,crypto_rsa_common,"static int crypto_rsa_common(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,
const BYTE* exponent, int exponent_size, BYTE* output)
{
BN_CTX* ctx;
int output_length = -1;
BYTE* input_reverse;
BYTE* modulus_reverse;
BYTE* exponent_reverse;
BIGNUM *mod, *exp, *x, *y;
input_reverse = (BYTE*)malloc(2 * key_length + exponent_size);
if (!input_reverse)
return -1;
modulus_reverse = input_reverse + key_length;
exponent_reverse = modulus_reverse + key_length;
memcpy(modulus_reverse, modulus, key_length);
crypto_reverse(modulus_reverse, key_length);
memcpy(exponent_reverse, exponent, exponent_size);
crypto_reverse(exponent_reverse, exponent_size);
memcpy(input_reverse, input, length);
crypto_reverse(input_reverse, length);
if (!(ctx = BN_CTX_new()))
goto fail_bn_ctx;
if (!(mod = BN_new()))
goto fail_bn_mod;
if (!(exp = BN_new()))
goto fail_bn_exp;
if (!(x = BN_new()))
goto fail_bn_x;
if (!(y = BN_new()))
goto fail_bn_y;
BN_bin2bn(modulus_reverse, key_length, mod);
BN_bin2bn(exponent_reverse, exponent_size, exp);
BN_bin2bn(input_reverse, length, x);
BN_mod_exp(y, x, exp, mod, ctx);
output_length = BN_bn2bin(y, output);
crypto_reverse(output, output_length);
if (output_length < (int)key_length)
memset(output + output_length, 0, key_length - output_length);
BN_free(y);
fail_bn_y:
BN_clear_free(x);
fail_bn_x:
BN_free(exp);
fail_bn_exp:
BN_free(mod);
fail_bn_mod:
BN_CTX_free(ctx);
fail_bn_ctx:
free(input_reverse);
return output_length;
}","static int crypto_rsa_common(const BYTE* VAR_0, int VAR_1, UINT32 VAR_2, const BYTE* VAR_3,
const BYTE* VAR_4, int VAR_5, BYTE* VAR_6)
{
BN_CTX* VAR_7;
int VAR_8 = -1;
BYTE* VAR_9;
BYTE* VAR_10;
BYTE* VAR_11;
BIGNUM *VAR_12, *VAR_13, *VAR_14, *VAR_15;
VAR_9 = (BYTE*)malloc(2 * VAR_2 + VAR_5);
if (!VAR_9)
return -1;
VAR_10 = VAR_9 + VAR_2;
VAR_11 = VAR_10 + VAR_2;
memcpy(VAR_10, VAR_3, VAR_2);
crypto_reverse(VAR_10, VAR_2);
memcpy(VAR_11, VAR_4, VAR_5);
crypto_reverse(VAR_11, VAR_5);
memcpy(VAR_9, VAR_0, VAR_1);
crypto_reverse(VAR_9, VAR_1);
if (!(VAR_7 = BN_CTX_new()))
goto fail_bn_ctx;
if (!(VAR_12 = BN_new()))
goto fail_bn_mod;
if (!(VAR_13 = BN_new()))
goto fail_bn_exp;
if (!(VAR_14 = BN_new()))
goto fail_bn_x;
if (!(VAR_15 = BN_new()))
goto fail_bn_y;
BN_bin2bn(VAR_10, VAR_2, VAR_12);
BN_bin2bn(VAR_11, VAR_5, VAR_13);
BN_bin2bn(VAR_9, VAR_1, VAR_14);
BN_mod_exp(VAR_15, VAR_14, VAR_13, VAR_12, VAR_7);
VAR_8 = BN_bn2bin(VAR_15, VAR_6);
crypto_reverse(VAR_6, VAR_8);
if (VAR_8 < (int)VAR_2)
memset(VAR_6 + VAR_8, 0, VAR_2 - VAR_8);
BN_free(VAR_15);
fail_bn_y:
BN_clear_free(VAR_14);
fail_bn_x:
BN_free(VAR_13);
fail_bn_exp:
BN_free(VAR_12);
fail_bn_mod:
BN_CTX_free(VAR_7);
fail_bn_ctx:
free(VAR_9);
return VAR_8;
}",FreeRDP/8305349a943c68b1bc8c158f431dc607655aadea/crypto.c/vul/before/0.json,"static int crypto_rsa_common(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,
                             const BYTE* exponent, int exponent_size, BYTE* output)
{
	BN_CTX* ctx = NULL;
	int output_length = -1;
	BYTE* input_reverse = NULL;
	BYTE* modulus_reverse = NULL;
	BYTE* exponent_reverse = NULL;
	BIGNUM* mod = NULL;
	BIGNUM* exp = NULL;
	BIGNUM* x = NULL;
	BIGNUM* y = NULL;
	size_t bufferSize = 2 * key_length + exponent_size;

	if (!input || (length < 0) || (exponent_size < 0) || !modulus || !exponent || !output)
		return -1;

	if (length > bufferSize)
		bufferSize = length;

	input_reverse = (BYTE*)calloc(bufferSize, 1);

	if (!input_reverse)
		return -1;

	modulus_reverse = input_reverse + key_length;
	exponent_reverse = modulus_reverse + key_length;
	memcpy(modulus_reverse, modulus, key_length);
	crypto_reverse(modulus_reverse, key_length);
	memcpy(exponent_reverse, exponent, exponent_size);
	crypto_reverse(exponent_reverse, exponent_size);
	memcpy(input_reverse, input, length);
	crypto_reverse(input_reverse, length);

	if (!(ctx = BN_CTX_new()))
		goto fail_bn_ctx;

	if (!(mod = BN_new()))
		goto fail_bn_mod;

	if (!(exp = BN_new()))
		goto fail_bn_exp;

	if (!(x = BN_new()))
		goto fail_bn_x;

	if (!(y = BN_new()))
		goto fail_bn_y;

	if (!BN_bin2bn(modulus_reverse, key_length, mod))
		goto fail;

	if (!BN_bin2bn(exponent_reverse, exponent_size, exp))
		goto fail;
	if (!BN_bin2bn(input_reverse, length, x))
		goto fail;
	if (BN_mod_exp(y, x, exp, mod, ctx) != 1)
		goto fail;
	output_length = BN_bn2bin(y, output);
	if (output_length < 0)
		goto fail;
	crypto_reverse(output, output_length);

	if (output_length < key_length)
		memset(output + output_length, 0, key_length - output_length);

fail:
	BN_free(y);
fail_bn_y:
	BN_clear_free(x);
fail_bn_x:
	BN_free(exp);
fail_bn_exp:
	BN_free(mod);
fail_bn_mod:
	BN_CTX_free(ctx);
fail_bn_ctx:
	free(input_reverse);
	return output_length;
}","static int crypto_rsa_common(const BYTE* VAR_0, int VAR_1, UINT32 VAR_2, const BYTE* VAR_3,
                             const BYTE* VAR_4, int VAR_5, BYTE* VAR_6)
{
	BN_CTX* VAR_7 = NULL;
	int VAR_8 = -1;
	BYTE* VAR_9 = NULL;
	BYTE* VAR_10 = NULL;
	BYTE* VAR_11 = NULL;
	BIGNUM* VAR_12 = NULL;
	BIGNUM* VAR_13 = NULL;
	BIGNUM* VAR_14 = NULL;
	BIGNUM* VAR_15 = NULL;
	size_t VAR_16 = 2 * VAR_2 + VAR_5;

	if (!VAR_0 || (VAR_1 < 0) || (VAR_5 < 0) || !VAR_3 || !VAR_4 || !VAR_6)
		return -1;

	if (VAR_1 > VAR_16)
		VAR_16 = VAR_1;

	VAR_9 = (BYTE*)calloc(VAR_16, 1);

	if (!VAR_9)
		return -1;

	VAR_10 = VAR_9 + VAR_2;
	VAR_11 = VAR_10 + VAR_2;
	memcpy(VAR_10, VAR_3, VAR_2);
	crypto_reverse(VAR_10, VAR_2);
	memcpy(VAR_11, VAR_4, VAR_5);
	crypto_reverse(VAR_11, VAR_5);
	memcpy(VAR_9, VAR_0, VAR_1);
	crypto_reverse(VAR_9, VAR_1);

	if (!(VAR_7 = BN_CTX_new()))
		goto fail_bn_ctx;

	if (!(VAR_12 = BN_new()))
		goto fail_bn_mod;

	if (!(VAR_13 = BN_new()))
		goto fail_bn_exp;

	if (!(VAR_14 = BN_new()))
		goto fail_bn_x;

	if (!(VAR_15 = BN_new()))
		goto fail_bn_y;

	if (!BN_bin2bn(VAR_10, VAR_2, VAR_12))
		goto fail;

	if (!BN_bin2bn(VAR_11, VAR_5, VAR_13))
		goto fail;
	if (!BN_bin2bn(VAR_9, VAR_1, VAR_14))
		goto fail;
	if (BN_mod_exp(VAR_15, VAR_14, VAR_13, VAR_12, VAR_7) != 1)
		goto fail;
	VAR_8 = BN_bn2bin(VAR_15, VAR_6);
	if (VAR_8 < 0)
		goto fail;
	crypto_reverse(VAR_6, VAR_8);

	if (VAR_8 < VAR_2)
		memset(VAR_6 + VAR_8, 0, VAR_2 - VAR_8);

fail:
	BN_free(VAR_15);
fail_bn_y:
	BN_clear_free(VAR_14);
fail_bn_x:
	BN_free(VAR_13);
fail_bn_exp:
	BN_free(VAR_12);
fail_bn_mod:
	BN_CTX_free(VAR_7);
fail_bn_ctx:
	free(VAR_9);
	return VAR_8;
}",FreeRDP/8305349a943c68b1bc8c158f431dc607655aadea/crypto.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,13 +1,24 @@
 static int crypto_rsa_common(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,
                              const BYTE* exponent, int exponent_size, BYTE* output)
 {
-	BN_CTX* ctx;
+	BN_CTX* ctx = NULL;
 	int output_length = -1;
-	BYTE* input_reverse;
-	BYTE* modulus_reverse;
-	BYTE* exponent_reverse;
-	BIGNUM *mod, *exp, *x, *y;
-	input_reverse = (BYTE*)malloc(2 * key_length + exponent_size);
+	BYTE* input_reverse = NULL;
+	BYTE* modulus_reverse = NULL;
+	BYTE* exponent_reverse = NULL;
+	BIGNUM* mod = NULL;
+	BIGNUM* exp = NULL;
+	BIGNUM* x = NULL;
+	BIGNUM* y = NULL;
+	size_t bufferSize = 2 * key_length + exponent_size;
+
+	if (!input || (length < 0) || (exponent_size < 0) || !modulus || !exponent || !output)
+		return -1;
+
+	if (length > bufferSize)
+		bufferSize = length;
+
+	input_reverse = (BYTE*)calloc(bufferSize, 1);
 
 	if (!input_reverse)
 		return -1;
@@ -36,16 +47,24 @@
 	if (!(y = BN_new()))
 		goto fail_bn_y;
 
-	BN_bin2bn(modulus_reverse, key_length, mod);
-	BN_bin2bn(exponent_reverse, exponent_size, exp);
-	BN_bin2bn(input_reverse, length, x);
-	BN_mod_exp(y, x, exp, mod, ctx);
+	if (!BN_bin2bn(modulus_reverse, key_length, mod))
+		goto fail;
+
+	if (!BN_bin2bn(exponent_reverse, exponent_size, exp))
+		goto fail;
+	if (!BN_bin2bn(input_reverse, length, x))
+		goto fail;
+	if (BN_mod_exp(y, x, exp, mod, ctx) != 1)
+		goto fail;
 	output_length = BN_bn2bin(y, output);
+	if (output_length < 0)
+		goto fail;
 	crypto_reverse(output, output_length);
 
-	if (output_length < (int)key_length)
+	if (output_length < key_length)
 		memset(output + output_length, 0, key_length - output_length);
 
+fail:
 	BN_free(y);
 fail_bn_y:
 	BN_clear_free(x);","{'deleted_lines': ['\tBN_CTX* ctx;', '\tBYTE* input_reverse;', '\tBYTE* modulus_reverse;', '\tBYTE* exponent_reverse;', '\tBIGNUM *mod, *exp, *x, *y;', '\tinput_reverse = (BYTE*)malloc(2 * key_length + exponent_size);', '\tBN_bin2bn(modulus_reverse, key_length, mod);', '\tBN_bin2bn(exponent_reverse, exponent_size, exp);', '\tBN_bin2bn(input_reverse, length, x);', '\tBN_mod_exp(y, x, exp, mod, ctx);', '\tif (output_length < (int)key_length)'], 'added_lines': ['\tBN_CTX* ctx = NULL;', '\tBYTE* input_reverse = NULL;', '\tBYTE* modulus_reverse = NULL;', '\tBYTE* exponent_reverse = NULL;', '\tBIGNUM* mod = NULL;', '\tBIGNUM* exp = NULL;', '\tBIGNUM* x = NULL;', '\tBIGNUM* y = NULL;', '\tsize_t bufferSize = 2 * key_length + exponent_size;', '', '\tif (!input || (length < 0) || (exponent_size < 0) || !modulus || !exponent || !output)', '\t\treturn -1;', '', '\tif (length > bufferSize)', '\t\tbufferSize = length;', '', '\tinput_reverse = (BYTE*)calloc(bufferSize, 1);', '\tif (!BN_bin2bn(modulus_reverse, key_length, mod))', '\t\tgoto fail;', '', '\tif (!BN_bin2bn(exponent_reverse, exponent_size, exp))', '\t\tgoto fail;', '\tif (!BN_bin2bn(input_reverse, length, x))', '\t\tgoto fail;', '\tif (BN_mod_exp(y, x, exp, mod, ctx) != 1)', '\t\tgoto fail;', '\tif (output_length < 0)', '\t\tgoto fail;', '\tif (output_length < key_length)', 'fail:']}",True,An issue was discovered in FreeRDP before 2.1.1. An out-of-bounds (OOB) write vulnerability has been detected in crypto_rsa_common in libfreerdp/crypto/crypto.c.,8.3,HIGH,2,valid,2020-05-19T05:41:14Z,3
CVE-2018-17076,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,logological/gpp,Fixes #26 (stack overflow during parse),329aa63a70d32d1e2ae529130a792e0c6ae4ce79,https://github.com/logological/gpp/commit/329aa63a70d32d1e2ae529130a792e0c6ae4ce79,src/gpp.c,ParseText,"void ParseText(void) {
int l, cs, ce;
char c, *s;
struct COMMENT *p;
if (!C->in_comment) {
cs = 1;
for (p = S->comments; p != NULL ; p = p->next)
if (!(p->flags[C->ambience] & FLAG_IGNORE))
if (matchStartSequence(p->start, &cs)) {
l = ce = findCommentEnd(p->end, p->quote, p->warn, cs,
p->flags[C->ambience]);
matchEndSequence(p->end, &l);
if (p->flags[C->ambience] & OUTPUT_DELIM)
sendout(C->buf + 1, cs - 1, 0);
if (!(p->flags[C->ambience] & OUTPUT_TEXT))
replace_definition_with_blank_lines(C->buf + 1,
C->buf + ce - 1, 0);
if (p->flags[C->ambience] & PARSE_MACROS) {
C->in_comment = 1;
s = ProcessText(C->buf + cs, ce - cs, C->ambience);
if (p->flags[C->ambience] & OUTPUT_TEXT)
sendout(s, strlen(s), 0);
C->in_comment = 0;
free(s);
} else if (p->flags[C->ambience] & OUTPUT_TEXT)
sendout(C->buf + cs, ce - cs, 0);
if (p->flags[C->ambience] & OUTPUT_DELIM)
sendout(C->buf + ce, l - ce, 0);
shiftIn(l);
return;
}
}
if (ParsePossibleMeta() >= 0)
return;
if (ParsePossibleUser() >= 0)
return;
l = 1;
if (matchSequence(S->User.mArgRef, &l) && C->may_have_args) {
c = getChar(l);
if ((c >= '1') && (c <= '9')) {
c = c - '1';
if (c < C->argc)
sendout(C->argv[(int) c], strlen(C->argv[(int) c]), 0);
shiftIn(l + 1);
return;
}
}
l = identifierEnd(1);
if (l == 1)
l = 2;
sendout(C->buf + 1, l - 1, 1);
shiftIn(l);
}","void ParseText(void) {
int VAR_0, VAR_1, VAR_2;
char VAR_3, *VAR_4;
struct COMMENT *VAR_5;
if (!VAR_6->in_comment) {
VAR_1 = 1;
for (VAR_5 = VAR_7->comments; VAR_5 != NULL ; VAR_5 = VAR_5->next)
if (!(VAR_5->flags[VAR_6->ambience] & VAR_8))
if (matchStartSequence(VAR_5->start, &VAR_1)) {
VAR_0 = VAR_2 = findCommentEnd(VAR_5->end, VAR_5->quote, VAR_5->warn, VAR_1,
VAR_5->flags[VAR_6->ambience]);
matchEndSequence(VAR_5->end, &VAR_0);
if (VAR_5->flags[VAR_6->ambience] & VAR_9)
sendout(VAR_6->buf + 1, VAR_1 - 1, 0);
if (!(VAR_5->flags[VAR_6->ambience] & VAR_10))
replace_definition_with_blank_lines(VAR_6->buf + 1,
VAR_6->buf + VAR_2 - 1, 0);
if (VAR_5->flags[VAR_6->ambience] & VAR_11) {
VAR_6->in_comment = 1;
VAR_4 = ProcessText(VAR_6->buf + VAR_1, VAR_2 - VAR_1, VAR_6->ambience);
if (VAR_5->flags[VAR_6->ambience] & VAR_10)
sendout(VAR_4, strlen(VAR_4), 0);
VAR_6->in_comment = 0;
free(VAR_4);
} else if (VAR_5->flags[VAR_6->ambience] & VAR_10)
sendout(VAR_6->buf + VAR_1, VAR_2 - VAR_1, 0);
if (VAR_5->flags[VAR_6->ambience] & VAR_9)
sendout(VAR_6->buf + VAR_2, VAR_0 - VAR_2, 0);
shiftIn(VAR_0);
return;
}
}
if (ParsePossibleMeta() >= 0)
return;
if (ParsePossibleUser() >= 0)
return;
VAR_0 = 1;
if (matchSequence(VAR_7->User.mArgRef, &VAR_0) && VAR_6->may_have_args) {
VAR_3 = getChar(VAR_0);
if ((VAR_3 >= '1') && (VAR_3 <= '9')) {
VAR_3 = VAR_3 - '1';
if (VAR_3 < VAR_6->argc)
sendout(VAR_6->argv[(int) VAR_3], strlen(VAR_6->argv[(int) VAR_3]), 0);
shiftIn(VAR_0 + 1);
return;
}
}
VAR_0 = identifierEnd(1);
if (VAR_0 == 1)
VAR_0 = 2;
sendout(VAR_6->buf + 1, VAR_0 - 1, 1);
shiftIn(VAR_0);
}",logological/gpp/329aa63a70d32d1e2ae529130a792e0c6ae4ce79/gpp.c/vul/before/0.json,"void ParseText(void) {
    int l, cs, ce;
    char c, *s;
    struct COMMENT *p;

    if (++parselevel == STACKDEPTH)
      bug(""Stack depth exceeded during parse"");

    /* look for comments first */
    if (!C->in_comment) {
        cs = 1;
        for (p = S->comments; p != NULL ; p = p->next)
            if (!(p->flags[C->ambience] & FLAG_IGNORE))
                if (matchStartSequence(p->start, &cs)) {
                    l = ce = findCommentEnd(p->end, p->quote, p->warn, cs,
                            p->flags[C->ambience]);
                    matchEndSequence(p->end, &l);
                    if (p->flags[C->ambience] & OUTPUT_DELIM)
                        sendout(C->buf + 1, cs - 1, 0);
                    if (!(p->flags[C->ambience] & OUTPUT_TEXT))
                        replace_definition_with_blank_lines(C->buf + 1,
                                C->buf + ce - 1, 0);
                    if (p->flags[C->ambience] & PARSE_MACROS) {
                        C->in_comment = 1;
                        s = ProcessText(C->buf + cs, ce - cs, C->ambience);
                        if (p->flags[C->ambience] & OUTPUT_TEXT)
                            sendout(s, strlen(s), 0);
                        C->in_comment = 0;
                        free(s);
                    } else if (p->flags[C->ambience] & OUTPUT_TEXT)
                        sendout(C->buf + cs, ce - cs, 0);
                    if (p->flags[C->ambience] & OUTPUT_DELIM)
                        sendout(C->buf + ce, l - ce, 0);
                    shiftIn(l);
		    parselevel--;
                    return;
                }
    }

    if (ParsePossibleMeta() >= 0) {
      parselevel--;
      return;
    }
    if (ParsePossibleUser() >= 0) {
      parselevel--;
      return;
    }

    l = 1;
    /* If matching numbered macro argument and inside a macro */
    if (matchSequence(S->User.mArgRef, &l) && C->may_have_args) {
        /* Process macro arguments referenced as #1,#2,... */
        c = getChar(l);
        if ((c >= '1') && (c <= '9')) {
            c = c - '1';
            if (c < C->argc)
                sendout(C->argv[(int) c], strlen(C->argv[(int) c]), 0);
            shiftIn(l + 1);
	    parselevel--;
            return;
        }
    }

    l = identifierEnd(1);
    if (l == 1)
        l = 2;
    sendout(C->buf + 1, l - 1, 1);
    shiftIn(l);
    parselevel--;
}","void ParseText(void) {
    int VAR_0, VAR_1, VAR_2;
    char VAR_3, *VAR_4;
    struct COMMENT *VAR_5;

    if (++VAR_6 == VAR_7)
      bug(""Stack depth exceeded during parse"");

    /* COMMENT_0 */
    if (!VAR_8->in_comment) {
        VAR_1 = 1;
        for (VAR_5 = VAR_9->comments; VAR_5 != NULL ; VAR_5 = VAR_5->next)
            if (!(VAR_5->flags[VAR_8->ambience] & VAR_10))
                if (matchStartSequence(VAR_5->start, &VAR_1)) {
                    VAR_0 = VAR_2 = findCommentEnd(VAR_5->end, VAR_5->quote, VAR_5->warn, VAR_1,
                            VAR_5->flags[VAR_8->ambience]);
                    matchEndSequence(VAR_5->end, &VAR_0);
                    if (VAR_5->flags[VAR_8->ambience] & VAR_11)
                        sendout(VAR_8->buf + 1, VAR_1 - 1, 0);
                    if (!(VAR_5->flags[VAR_8->ambience] & VAR_12))
                        replace_definition_with_blank_lines(VAR_8->buf + 1,
                                VAR_8->buf + VAR_2 - 1, 0);
                    if (VAR_5->flags[VAR_8->ambience] & VAR_13) {
                        VAR_8->in_comment = 1;
                        VAR_4 = ProcessText(VAR_8->buf + VAR_1, VAR_2 - VAR_1, VAR_8->ambience);
                        if (VAR_5->flags[VAR_8->ambience] & VAR_12)
                            sendout(VAR_4, strlen(VAR_4), 0);
                        VAR_8->in_comment = 0;
                        free(VAR_4);
                    } else if (VAR_5->flags[VAR_8->ambience] & VAR_12)
                        sendout(VAR_8->buf + VAR_1, VAR_2 - VAR_1, 0);
                    if (VAR_5->flags[VAR_8->ambience] & VAR_11)
                        sendout(VAR_8->buf + VAR_2, VAR_0 - VAR_2, 0);
                    shiftIn(VAR_0);
		    VAR_6--;
                    return;
                }
    }

    if (ParsePossibleMeta() >= 0) {
      VAR_6--;
      return;
    }
    if (ParsePossibleUser() >= 0) {
      VAR_6--;
      return;
    }

    VAR_0 = 1;
    /* COMMENT_1 */
    if (matchSequence(VAR_9->User.mArgRef, &VAR_0) && VAR_8->may_have_args) {
        /* COMMENT_2 */
        VAR_3 = getChar(VAR_0);
        if ((VAR_3 >= '1') && (VAR_3 <= '9')) {
            VAR_3 = VAR_3 - '1';
            if (VAR_3 < VAR_8->argc)
                sendout(VAR_8->argv[(int) VAR_3], strlen(VAR_8->argv[(int) VAR_3]), 0);
            shiftIn(VAR_0 + 1);
	    VAR_6--;
            return;
        }
    }

    VAR_0 = identifierEnd(1);
    if (VAR_0 == 1)
        VAR_0 = 2;
    sendout(VAR_8->buf + 1, VAR_0 - 1, 1);
    shiftIn(VAR_0);
    VAR_6--;
}",logological/gpp/329aa63a70d32d1e2ae529130a792e0c6ae4ce79/gpp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,6 +2,9 @@
     int l, cs, ce;
     char c, *s;
     struct COMMENT *p;
+
+    if (++parselevel == STACKDEPTH)
+      bug(""Stack depth exceeded during parse"");
 
     /* look for comments first */
     if (!C->in_comment) {
@@ -29,14 +32,19 @@
                     if (p->flags[C->ambience] & OUTPUT_DELIM)
                         sendout(C->buf + ce, l - ce, 0);
                     shiftIn(l);
+		    parselevel--;
                     return;
                 }
     }
 
-    if (ParsePossibleMeta() >= 0)
-        return;
-    if (ParsePossibleUser() >= 0)
-        return;
+    if (ParsePossibleMeta() >= 0) {
+      parselevel--;
+      return;
+    }
+    if (ParsePossibleUser() >= 0) {
+      parselevel--;
+      return;
+    }
 
     l = 1;
     /* If matching numbered macro argument and inside a macro */
@@ -48,6 +56,7 @@
             if (c < C->argc)
                 sendout(C->argv[(int) c], strlen(C->argv[(int) c]), 0);
             shiftIn(l + 1);
+	    parselevel--;
             return;
         }
     }
@@ -57,4 +66,5 @@
         l = 2;
     sendout(C->buf + 1, l - 1, 1);
     shiftIn(l);
+    parselevel--;
 }","{'deleted_lines': ['    if (ParsePossibleMeta() >= 0)', '        return;', '    if (ParsePossibleUser() >= 0)', '        return;'], 'added_lines': ['', '    if (++parselevel == STACKDEPTH)', '      bug(""Stack depth exceeded during parse"");', '\t\t    parselevel--;', '    if (ParsePossibleMeta() >= 0) {', '      parselevel--;', '      return;', '    }', '    if (ParsePossibleUser() >= 0) {', '      parselevel--;', '      return;', '    }', '\t    parselevel--;', '    parselevel--;']}",True,"GPP through 2.25 will try to use more memory space than is available on the stack, leading to a segmentation fault or possibly unspecified other impact via a crafted file.",8.8,HIGH,2,valid,2020-05-28T08:55:59Z,3
CVE-2020-8916,['CWE-401'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,openthread/wpantund,[wpanctl] free dbus connection and error on exit.,0e5d1601febb869f583e944785e5685c6c747be7,https://github.com/openthread/wpantund/commit/0e5d1601febb869f583e944785e5685c6c747be7,src/wpanctl/wpanctl.c,main,"int main(int argc, char * argv[])
{
int c;
bool ignore_driver_version_mismatch = false;
DBusError error;
DBusConnection* connection;
dbus_error_init(&error);
srandom(time(NULL));
while (1) {
static struct option long_options[] = {
{""help"", no_argument, 0, 'h'},
{""version"", no_argument, 0, 'v'},
{""ignore-mismatch"", no_argument, 0, 'i'},
{""debug"", no_argument, 0, 'd'},
{""interface"", required_argument, 0, 'I'},
{""file"", required_argument, 0, 'f'},
{0, 0, 0, 0}
};
int option_index = 0;
if ((optind < argc) && (find_cmd(argv[optind]) != NULL)) {
break;
}
c = getopt_long(argc, argv, ""hvidI:f:"", long_options,
&option_index);
if (c == -1)
break;
switch (c) {
case 'h':
print_version();
print_arg_list_help(option_list,
argv[0],
""[options] <sub-command> [args]"");
print_commands();
gRet = ERRORCODE_HELP;
goto bail;
case 'v':
print_version();
gRet = 0;
goto bail;
case 'd':
gDebugMode++;
break;
case 'I':
snprintf(gInterfaceName, sizeof(gInterfaceName),
""%s"", optarg);
break;
case 'i':
ignore_driver_version_mismatch = true;
break;
case 'f':
#if HAVE_LIBREADLINE
if (NULL == freopen(optarg, ""r"", stdin))
{
fprintf(stderr,
""%s: error: Unable to open file \""%s\"".\n"",
argv[0], optarg);
return ERRORCODE_BADARG;
}
#else
fprintf(stderr,
""%s: Cannot read from file \""%s\"" : Missing readline library.\n"",
argv[0], optarg);
return ERRORCODE_BADARG;
#endif
default:
break;
}
}
istty = isatty(fileno(stdin));
if (gDebugMode >= 1) {
fprintf(stderr, ""DEBUG: isatty(fileno(stdin)) = %d\n"", istty);
}
if (gDebugMode >= 1) {
fprintf(stderr, ""DEBUG: Will use interface '%s'.\n"", gInterfaceName);
}
#if HAVE_PWD_H
if (getuid() == 0 && strcmp(WPANTUND_SERVICE_USER, ""root"")) {
uid_t target_uid = 0;
gid_t target_gid = 0;
struct passwd *passwd = getpwnam(WPANTUND_SERVICE_USER);
if (passwd == NULL) {
fprintf(stderr, ""getpwnam: Unable to lookup user \""%s\""."", WPANTUND_SERVICE_USER);
gRet = ERRORCODE_ERRNO;
goto bail;
}
target_uid = passwd->pw_uid;
target_gid = passwd->pw_gid;
if (target_gid != 0) {
if (setgid(target_gid) != 0) {
perror(""setgid"");
gRet = ERRORCODE_ERRNO;
goto bail;
}
}
if (target_uid != 0) {
if (setuid(target_uid) != 0) {
perror(""setuid"");
gRet = ERRORCODE_ERRNO;
goto bail;
}
}
}
#endif 
if (getenv(""WPANCTL_DBUS_NAME"") && gDebugMode>=1)
fprintf(stderr, ""DEBUG: Using dbus \""%s\""\n"", getenv(""WPANCTL_DBUS_NAME""));
setenv(""WPANCTL_DBUS_NAME"", WPAN_TUNNEL_DBUS_NAME, 0);
if (gDebugMode >= 1) {
fprintf(stderr, ""DEBUG: trying dbus_bus_get(DBUS_BUS_SYSTEM). . .\n"");
}
connection = dbus_bus_get(DBUS_BUS_SYSTEM, &error);
require_string(connection != NULL, bail, error.message);
if (gDebugMode >= 1) {
fprintf(stderr, ""DEBUG: DBusConnection: %p\n"", connection);
}
if (gDebugMode >= 1) {
fprintf(stderr, ""DEBUG: Registering DBusConnection. . .\n"");
}
dbus_bus_register(connection, &error);
require_string(error.name == NULL, bail, error.message);
if (gDebugMode >= 1) {
fprintf(stderr, ""DEBUG: DBusConnection registered.\n"");
}
if (gDebugMode >= 1) {
fprintf(stderr, ""DEBUG: Requesting DBus name \""%s\"". . .\n"",WPAN_TUNNEL_DBUS_NAME "".wpanctl"");
}
dbus_bus_request_name(connection,
WPAN_TUNNEL_DBUS_NAME "".wpanctl"",
0,
&error);
if (gDebugMode >= 1) {
if (error.name != NULL) {
fprintf(stderr, ""DEBUG: Requesting DBus name \""%s\"" failed (no biggie): %s\n"",WPAN_TUNNEL_DBUS_NAME "".wpanctl"", error.name);
} else {
fprintf(stderr, ""DEBUG: Requesting DBus name \""%s\"" succeded.\n"",WPAN_TUNNEL_DBUS_NAME "".wpanctl"");
}
}
if (gDebugMode >= 1) {
fprintf(stderr, ""DEBUG: Performing wpantund version check. . .\n"");
}
gRet = wpan_dbus_version_check(connection);
if (gRet != 0) {
fprintf(stderr,
""%s: error: `wpantund` is either not running, locked up, or incompatible with this version of `wpanctl`.\n"",
argv[0]
);
if (!ignore_driver_version_mismatch)
goto bail;
} else {
if (gDebugMode >= 1) {
fprintf(stderr,
""DEBUG: wpantund version check succeded.\n"");
}
}
if (optind < argc) {
if (gDebugMode >= 1) {
fprintf(stderr, ""DEBUG: Executing command '%s'. . .\n"",
argv[optind]);
}
argc -= optind;
argv += optind;
optind = 0;
gRet = exec_command(argc, argv);
goto bail;
}
if (istty) {
#if !HAVE_LIBREADLINE
fprintf(stderr,
""%s: error: Interactive mode disabled: Compiled without libeditline or libreadline support.\n"",
argv[0]
);
print_arg_list_help(option_list,
argv[0],
""[options] <sub-command> [args]"");
print_commands();
gRet = ERRORCODE_NOCOMMAND;
goto bail;
#else   setenv(""WPANCTL_HISTORY_FILE"", tilde_expand(""~/.wpanctl_history""), 0);
gRet = initialize_readline();
if(gRet) {
fprintf(stderr,
""%s: error: Failed to initialize readline: %d\n"",
argv[0], gRet
);
goto bail;
}
#endif  }
while ((gRet != ERRORCODE_QUIT) && !feof(stdin)) {
optind = 0;
#if HAVE_LIBREADLINE
if (istty) {
int dbus_fd = -1;
dbus_connection_get_unix_fd(connection, &dbus_fd);
struct pollfd polltable[2] = {
{ fileno(stdin), POLLIN | POLLHUP,               0                         },
{ dbus_fd,               POLLIN | POLLHUP,               0                         },
};
if (poll(
polltable,
(dbus_fd >= 0) ? 2 : 1,
1000
) < 0
) {
if (errno == EINTR) {
} else {
break;
}
}
if (polltable[0].revents)
rl_callback_read_char();
} else
#endif  {
char linebuffer[200];
process_input_line(fgets(linebuffer, sizeof(linebuffer), stdin));
}
dbus_connection_read_write_dispatch(connection, 0);
}
printf(""\n"");
bail:
#if HAVE_LIBREADLINE
rl_callback_handler_remove();
#endif  if (gRet == ERRORCODE_QUIT)
gRet = 0;
return gRet;
}","int main(int VAR_0, char * VAR_1[])
{
int VAR_2;
bool VAR_3 = false;
DBusError VAR_4;
DBusConnection* VAR_5;
dbus_error_init(&VAR_4);
srandom(time(NULL));
while (1) {
static struct option VAR_6[] = {
{""help"", VAR_7, 0, 'h'},
{""version"", VAR_7, 0, 'v'},
{""ignore-mismatch"", VAR_7, 0, 'i'},
{""debug"", VAR_7, 0, 'd'},
{""interface"", VAR_8, 0, 'I'},
{""file"", VAR_8, 0, 'f'},
{0, 0, 0, 0}
};
int VAR_9 = 0;
if ((VAR_10 < VAR_0) && (find_cmd(VAR_1[VAR_10]) != NULL)) {
break;
}
VAR_2 = getopt_long(VAR_0, VAR_1, ""hvidI:f:"", VAR_6,
&VAR_9);
if (VAR_2 == -1)
break;
switch (VAR_2) {
case 'h':
print_version();
print_arg_list_help(VAR_11,
VAR_1[0],
""[options] <sub-command> [args]"");
print_commands();
VAR_12 = VAR_13;
goto bail;
case 'v':
print_version();
VAR_12 = 0;
goto bail;
case 'd':
VAR_14++;
break;
case 'I':
snprintf(VAR_15, sizeof(VAR_15),
""%s"", VAR_16);
break;
case 'i':
VAR_3 = true;
break;
case 'f':
#if VAR_17
if (NULL == freopen(VAR_16, ""r"", VAR_18))
{
fprintf(VAR_19,
""%s: error: Unable to open file \""%s\"".\n"",
VAR_1[0], VAR_16);
return VAR_20;
}
#else
fprintf(VAR_19,
""%s: Cannot read from file \""%s\"" : Missing readline library.\n"",
VAR_1[0], VAR_16);
return VAR_20;
#endif
default:
break;
}
}
VAR_21 = isatty(fileno(VAR_18));
if (VAR_14 >= 1) {
fprintf(VAR_19, ""DEBUG: isatty(fileno(stdin)) = %d\n"", VAR_21);
}
if (VAR_14 >= 1) {
fprintf(VAR_19, ""DEBUG: Will use interface '%s'.\n"", VAR_15);
}
#if VAR_22
if (getuid() == 0 && strcmp(VAR_23, ""root"")) {
uid_t VAR_24 = 0;
gid_t VAR_25 = 0;
struct passwd *passwd = getpwnam(VAR_23);
if (passwd == NULL) {
fprintf(VAR_19, ""getpwnam: Unable to lookup user \""%s\""."", VAR_23);
VAR_12 = VAR_26;
goto bail;
}
VAR_24 = passwd->pw_uid;
VAR_25 = passwd->pw_gid;
if (VAR_25 != 0) {
if (setgid(VAR_25) != 0) {
perror(""setgid"");
VAR_12 = VAR_26;
goto bail;
}
}
if (VAR_24 != 0) {
if (setuid(VAR_24) != 0) {
perror(""setuid"");
VAR_12 = VAR_26;
goto bail;
}
}
}
#endif 
if (getenv(""WPANCTL_DBUS_NAME"") && VAR_14>=1)
fprintf(VAR_19, ""DEBUG: Using dbus \""%s\""\n"", getenv(""WPANCTL_DBUS_NAME""));
setenv(""WPANCTL_DBUS_NAME"", VAR_27, 0);
if (VAR_14 >= 1) {
fprintf(VAR_19, ""DEBUG: trying dbus_bus_get(DBUS_BUS_SYSTEM). . .\n"");
}
VAR_5 = dbus_bus_get(VAR_28, &VAR_4);
require_string(VAR_5 != NULL, VAR_29, VAR_4.message);
if (VAR_14 >= 1) {
fprintf(VAR_19, ""DEBUG: DBusConnection: %p\n"", VAR_5);
}
if (VAR_14 >= 1) {
fprintf(VAR_19, ""DEBUG: Registering DBusConnection. . .\n"");
}
dbus_bus_register(VAR_5, &VAR_4);
require_string(VAR_4.name == NULL, VAR_29, VAR_4.message);
if (VAR_14 >= 1) {
fprintf(VAR_19, ""DEBUG: DBusConnection registered.\n"");
}
if (VAR_14 >= 1) {
fprintf(VAR_19, ""DEBUG: Requesting DBus name \""%s\"". . .\n"",VAR_27 "".wpanctl"");
}
dbus_bus_request_name(VAR_5,
VAR_27 "".wpanctl"",
0,
&VAR_4);
if (VAR_14 >= 1) {
if (VAR_4.name != NULL) {
fprintf(VAR_19, ""DEBUG: Requesting DBus name \""%s\"" failed (no biggie): %s\n"",VAR_27 "".wpanctl"", VAR_4.name);
} else {
fprintf(VAR_19, ""DEBUG: Requesting DBus name \""%s\"" succeded.\n"",VAR_27 "".wpanctl"");
}
}
if (VAR_14 >= 1) {
fprintf(VAR_19, ""DEBUG: Performing wpantund version check. . .\n"");
}
VAR_12 = wpan_dbus_version_check(VAR_5);
if (VAR_12 != 0) {
fprintf(VAR_19,
""%s: error: `wpantund` is either not running, locked up, or incompatible with this version of `wpanctl`.\n"",
VAR_1[0]
);
if (!VAR_3)
goto bail;
} else {
if (VAR_14 >= 1) {
fprintf(VAR_19,
""DEBUG: wpantund version check succeded.\n"");
}
}
if (VAR_10 < VAR_0) {
if (VAR_14 >= 1) {
fprintf(VAR_19, ""DEBUG: Executing command '%s'. . .\n"",
VAR_1[VAR_10]);
}
VAR_0 -= VAR_10;
VAR_1 += VAR_10;
VAR_10 = 0;
VAR_12 = exec_command(VAR_0, VAR_1);
goto bail;
}
if (VAR_21) {
#if !VAR_17
fprintf(VAR_19,
""%s: error: Interactive mode disabled: Compiled without libeditline or libreadline support.\n"",
VAR_1[0]
);
print_arg_list_help(VAR_11,
VAR_1[0],
""[options] <sub-command> [args]"");
print_commands();
VAR_12 = VAR_30;
goto bail;
#else   
setenv(""WPANCTL_HISTORY_FILE"", tilde_expand(""~/.wpanctl_history""), 0);
VAR_12 = initialize_readline();
if(VAR_12) {
fprintf(VAR_19,
""%s: error: Failed to initialize readline: %d\n"",
VAR_1[0], VAR_12
);
goto bail;
}
#endif  
}
while ((VAR_12 != VAR_31) && !feof(VAR_18)) {
VAR_10 = 0;
#if VAR_17
if (VAR_21) {
int VAR_32 = -1;
dbus_connection_get_unix_fd(VAR_5, &VAR_32);
struct pollfd VAR_33[2] = {
{ fileno(VAR_18), VAR_34 | VAR_35,               0                         },
{ VAR_32,               VAR_34 | VAR_35,               0                         },
};
if (poll(
VAR_33,
(VAR_32 >= 0) ? 2 : 1,
1000
) < 0
) {
if (VAR_36 == VAR_37) {
} else {
break;
}
}
if (VAR_33[0].revents)
rl_callback_read_char();
} else
#endif  
{
char VAR_38[200];
process_input_line(fgets(VAR_38, sizeof(VAR_38), VAR_18));
}
dbus_connection_read_write_dispatch(VAR_5, 0);
}
printf(""\n"");
bail:
#if VAR_17
rl_callback_handler_remove();
#endif  
if (VAR_12 == VAR_31)
VAR_12 = 0;
return VAR_12;
}",openthread/wpantund/0e5d1601febb869f583e944785e5685c6c747be7/wpanctl.c/vul/before/0.json,"int main(int argc, char * argv[])
{
	int c;
	bool ignore_driver_version_mismatch = false;
	DBusError error;
	DBusConnection* connection = NULL;

	dbus_error_init(&error);

	srandom(time(NULL));

	while (1) {
		static struct option long_options[] = {
			{""help"", no_argument, 0, 'h'},
			{""version"", no_argument, 0, 'v'},
			{""ignore-mismatch"", no_argument, 0, 'i'},
			{""debug"", no_argument, 0, 'd'},
			{""interface"", required_argument, 0, 'I'},
			{""file"", required_argument, 0, 'f'},
			{0, 0, 0, 0}
		};

		int option_index = 0;

		if ((optind < argc) && (find_cmd(argv[optind]) != NULL)) {
			// This is where the wpanctl command starts; skip
			// parsing the flags since they may belong to the command
			break;
	}

		c = getopt_long(argc, argv, ""hvidI:f:"", long_options,
				&option_index);

		if (c == -1)
			break;

		switch (c) {
		case 'h':
		print_version();
		print_arg_list_help(option_list,
		                    argv[0],
		                    ""[options] <sub-command> [args]"");
		print_commands();
		gRet = ERRORCODE_HELP;
		goto bail;

		case 'v':
			print_version();
			gRet = 0;
			goto bail;

		case 'd':
			gDebugMode++;
			break;

		case 'I':
			snprintf(gInterfaceName, sizeof(gInterfaceName),
				 ""%s"", optarg);
			break;

		case 'i':
			ignore_driver_version_mismatch = true;
			break;

		case 'f':
#if HAVE_LIBREADLINE
			if (NULL == freopen(optarg, ""r"", stdin))
			{
				fprintf(stderr,
						""%s: error: Unable to open file \""%s\"".\n"",
						argv[0], optarg);
				return ERRORCODE_BADARG;
			}
#else
			fprintf(stderr,
				""%s: Cannot read from file \""%s\"" : Missing readline library.\n"",
				argv[0], optarg);
			return ERRORCODE_BADARG;
#endif
		default:
		break;
	}
	}

	istty = isatty(fileno(stdin));

	if (gDebugMode >= 1) {
		fprintf(stderr, ""DEBUG: isatty(fileno(stdin)) = %d\n"", istty);
	}

	if (gDebugMode >= 1) {
		fprintf(stderr, ""DEBUG: Will use interface '%s'.\n"", gInterfaceName);
	}

#if HAVE_PWD_H
	if (getuid() == 0 && strcmp(WPANTUND_SERVICE_USER, ""root"")) {
		uid_t target_uid = 0;
		gid_t target_gid = 0;
		struct passwd *passwd = getpwnam(WPANTUND_SERVICE_USER);

		if (passwd == NULL) {
			fprintf(stderr, ""getpwnam: Unable to lookup user \""%s\""."", WPANTUND_SERVICE_USER);
			gRet = ERRORCODE_ERRNO;
			goto bail;
		}

		target_uid = passwd->pw_uid;
		target_gid = passwd->pw_gid;

		if (target_gid != 0) {
			if (setgid(target_gid) != 0) {
				perror(""setgid"");
				gRet = ERRORCODE_ERRNO;
				goto bail;
			}
		}

		if (target_uid != 0) {
			if (setuid(target_uid) != 0) {
				perror(""setuid"");
				gRet = ERRORCODE_ERRNO;
				goto bail;
			}
		}
	}
#endif // HAVE_PWD_H

	if (getenv(""WPANCTL_DBUS_NAME"") && gDebugMode>=1)
		fprintf(stderr, ""DEBUG: Using dbus \""%s\""\n"", getenv(""WPANCTL_DBUS_NAME""));

	setenv(""WPANCTL_DBUS_NAME"", WPAN_TUNNEL_DBUS_NAME, 0);

	if (gDebugMode >= 1) {
		fprintf(stderr, ""DEBUG: trying dbus_bus_get(DBUS_BUS_SYSTEM). . .\n"");
	}

	connection = dbus_bus_get(DBUS_BUS_SYSTEM, &error);

	require_string(connection != NULL, bail, error.message);

	if (gDebugMode >= 1) {
		fprintf(stderr, ""DEBUG: DBusConnection: %p\n"", connection);
	}

	if (gDebugMode >= 1) {
		fprintf(stderr, ""DEBUG: Registering DBusConnection. . .\n"");
	}

	dbus_bus_register(connection, &error);
	require_string(error.name == NULL, bail, error.message);

	if (gDebugMode >= 1) {
		fprintf(stderr, ""DEBUG: DBusConnection registered.\n"");
	}

	if (gDebugMode >= 1) {
		fprintf(stderr, ""DEBUG: Requesting DBus name \""%s\"". . .\n"",WPAN_TUNNEL_DBUS_NAME "".wpanctl"");
	}

	dbus_bus_request_name(connection,
	                      WPAN_TUNNEL_DBUS_NAME "".wpanctl"",
	                      0,
	                      &error);

	if (gDebugMode >= 1) {
		if (error.name != NULL) {
			fprintf(stderr, ""DEBUG: Requesting DBus name \""%s\"" failed (no biggie): %s\n"",WPAN_TUNNEL_DBUS_NAME "".wpanctl"", error.name);
		} else {
			fprintf(stderr, ""DEBUG: Requesting DBus name \""%s\"" succeded.\n"",WPAN_TUNNEL_DBUS_NAME "".wpanctl"");
		}
	}

	// Don't fail if we can't get the name. It isn't a big deal.
	//require_string(error.name == NULL, bail, error.message);

	if (gDebugMode >= 1) {
		fprintf(stderr, ""DEBUG: Performing wpantund version check. . .\n"");
	}

	// Make sure that we are compatible with the copy of wpantund
	// that is currently running.
	gRet = wpan_dbus_version_check(connection);

	if (gRet != 0) {
		fprintf(stderr,
		        ""%s: error: `wpantund` is either not running, locked up, or incompatible with this version of `wpanctl`.\n"",
		        argv[0]
		        );
		if (!ignore_driver_version_mismatch)
			goto bail;
	} else {
		if (gDebugMode >= 1) {
			fprintf(stderr,
				""DEBUG: wpantund version check succeded.\n"");
		}
	}

	if (optind < argc) {
			if (gDebugMode >= 1) {
			fprintf(stderr, ""DEBUG: Executing command '%s'. . .\n"",
				argv[optind]);
		}

		argc -= optind;
		argv += optind;

		optind = 0;
		gRet = exec_command(argc, argv);
		goto bail;
	}

	if (istty) {
#if !HAVE_LIBREADLINE
		fprintf(stderr,
		        ""%s: error: Interactive mode disabled: Compiled without libeditline or libreadline support.\n"",
		        argv[0]
		        );
		print_arg_list_help(option_list,
		                    argv[0],
		                    ""[options] <sub-command> [args]"");
		print_commands();
		gRet = ERRORCODE_NOCOMMAND;
		goto bail;
#else   // HAVE_LIBREADLINE
		setenv(""WPANCTL_HISTORY_FILE"", tilde_expand(""~/.wpanctl_history""), 0);

		gRet = initialize_readline();
		if(gRet) {
			fprintf(stderr,
			        ""%s: error: Failed to initialize readline: %d\n"",
			        argv[0], gRet
			        );
			goto bail;
		}
#endif  // HAVE_LIBREADLINE
	}

	// Command mode.
	while ((gRet != ERRORCODE_QUIT) && !feof(stdin)) {
		optind = 0;
#if HAVE_LIBREADLINE
		if (istty) {
			int dbus_fd = -1;

			dbus_connection_get_unix_fd(connection, &dbus_fd);

			struct pollfd polltable[2] = {
				{ fileno(stdin), POLLIN | POLLHUP,               0                         },
				{ dbus_fd,               POLLIN | POLLHUP,               0                         },
			};

			if (poll(
			        polltable,
			        (dbus_fd >= 0) ? 2 : 1,
			        1000
			        ) < 0
			    ) {
				if (errno == EINTR) {
					// We just caught a signal.
					// Do nothing.
				} else {
					break;
				}
			}

			if (polltable[0].revents)
				rl_callback_read_char();
		} else
#endif  // HAVE_LIBREADLINE
		{
			char linebuffer[200];
			process_input_line(fgets(linebuffer, sizeof(linebuffer), stdin));
		}

		dbus_connection_read_write_dispatch(connection, 0);
	}
	printf(""\n"");

bail:
#if HAVE_LIBREADLINE
	rl_callback_handler_remove();
#endif  // HAVE_LIBREADLINE
	if (gRet == ERRORCODE_QUIT)
		gRet = 0;

	if (connection) {
		dbus_connection_unref(connection);
	}

	dbus_error_free(&error);

	return gRet;
}","int main(int VAR_0, char * VAR_1[])
{
	int VAR_2;
	bool VAR_3 = false;
	DBusError VAR_4;
	DBusConnection* VAR_5 = NULL;

	dbus_error_init(&VAR_4);

	srandom(time(NULL));

	while (1) {
		static struct option VAR_6[] = {
			{""help"", VAR_7, 0, 'h'},
			{""version"", VAR_7, 0, 'v'},
			{""ignore-mismatch"", VAR_7, 0, 'i'},
			{""debug"", VAR_7, 0, 'd'},
			{""interface"", VAR_8, 0, 'I'},
			{""file"", VAR_8, 0, 'f'},
			{0, 0, 0, 0}
		};

		int VAR_9 = 0;

		if ((VAR_10 < VAR_0) && (find_cmd(VAR_1[VAR_10]) != NULL)) {
			/* COMMENT_0 */
			/* COMMENT_1 */
			break;
	}

		VAR_2 = getopt_long(VAR_0, VAR_1, ""hvidI:f:"", VAR_6,
				&VAR_9);

		if (VAR_2 == -1)
			break;

		switch (VAR_2) {
		case 'h':
		print_version();
		print_arg_list_help(VAR_11,
		                    VAR_1[0],
		                    ""[options] <sub-command> [args]"");
		print_commands();
		VAR_12 = VAR_13;
		goto bail;

		case 'v':
			print_version();
			VAR_12 = 0;
			goto bail;

		case 'd':
			VAR_14++;
			break;

		case 'I':
			snprintf(VAR_15, sizeof(VAR_15),
				 ""%s"", VAR_16);
			break;

		case 'i':
			VAR_3 = true;
			break;

		case 'f':
#if VAR_17
			if (NULL == freopen(VAR_16, ""r"", VAR_18))
			{
				fprintf(VAR_19,
						""%s: error: Unable to open file \""%s\"".\n"",
						VAR_1[0], VAR_16);
				return VAR_20;
			}
#else
			fprintf(VAR_19,
				""%s: Cannot read from file \""%s\"" : Missing readline library.\n"",
				VAR_1[0], VAR_16);
			return VAR_20;
#endif
		default:
		break;
	}
	}

	VAR_21 = isatty(fileno(VAR_18));

	if (VAR_14 >= 1) {
		fprintf(VAR_19, ""DEBUG: isatty(fileno(stdin)) = %d\n"", VAR_21);
	}

	if (VAR_14 >= 1) {
		fprintf(VAR_19, ""DEBUG: Will use interface '%s'.\n"", VAR_15);
	}

#if VAR_22
	if (getuid() == 0 && strcmp(VAR_23, ""root"")) {
		uid_t VAR_24 = 0;
		gid_t VAR_25 = 0;
		struct passwd *passwd = getpwnam(VAR_23);

		if (passwd == NULL) {
			fprintf(VAR_19, ""getpwnam: Unable to lookup user \""%s\""."", VAR_23);
			VAR_12 = VAR_26;
			goto bail;
		}

		VAR_24 = passwd->pw_uid;
		VAR_25 = passwd->pw_gid;

		if (VAR_25 != 0) {
			if (setgid(VAR_25) != 0) {
				perror(""setgid"");
				VAR_12 = VAR_26;
				goto bail;
			}
		}

		if (VAR_24 != 0) {
			if (setuid(VAR_24) != 0) {
				perror(""setuid"");
				VAR_12 = VAR_26;
				goto bail;
			}
		}
	}
#endif /* COMMENT_2 */

	if (getenv(""WPANCTL_DBUS_NAME"") && VAR_14>=1)
		fprintf(VAR_19, ""DEBUG: Using dbus \""%s\""\n"", getenv(""WPANCTL_DBUS_NAME""));

	setenv(""WPANCTL_DBUS_NAME"", VAR_27, 0);

	if (VAR_14 >= 1) {
		fprintf(VAR_19, ""DEBUG: trying dbus_bus_get(DBUS_BUS_SYSTEM). . .\n"");
	}

	VAR_5 = dbus_bus_get(VAR_28, &VAR_4);

	require_string(VAR_5 != NULL, VAR_29, VAR_4.message);

	if (VAR_14 >= 1) {
		fprintf(VAR_19, ""DEBUG: DBusConnection: %p\n"", VAR_5);
	}

	if (VAR_14 >= 1) {
		fprintf(VAR_19, ""DEBUG: Registering DBusConnection. . .\n"");
	}

	dbus_bus_register(VAR_5, &VAR_4);
	require_string(VAR_4.name == NULL, VAR_29, VAR_4.message);

	if (VAR_14 >= 1) {
		fprintf(VAR_19, ""DEBUG: DBusConnection registered.\n"");
	}

	if (VAR_14 >= 1) {
		fprintf(VAR_19, ""DEBUG: Requesting DBus name \""%s\"". . .\n"",VAR_27 "".wpanctl"");
	}

	dbus_bus_request_name(VAR_5,
	                      VAR_27 "".wpanctl"",
	                      0,
	                      &VAR_4);

	if (VAR_14 >= 1) {
		if (VAR_4.name != NULL) {
			fprintf(VAR_19, ""DEBUG: Requesting DBus name \""%s\"" failed (no biggie): %s\n"",VAR_27 "".wpanctl"", VAR_4.name);
		} else {
			fprintf(VAR_19, ""DEBUG: Requesting DBus name \""%s\"" succeded.\n"",VAR_27 "".wpanctl"");
		}
	}

	/* COMMENT_3 */
	/* COMMENT_4 */

	if (VAR_14 >= 1) {
		fprintf(VAR_19, ""DEBUG: Performing wpantund version check. . .\n"");
	}

	/* COMMENT_5 */
	/* COMMENT_6 */
	VAR_12 = wpan_dbus_version_check(VAR_5);

	if (VAR_12 != 0) {
		fprintf(VAR_19,
		        ""%s: error: `wpantund` is either not running, locked up, or incompatible with this version of `wpanctl`.\n"",
		        VAR_1[0]
		        );
		if (!VAR_3)
			goto bail;
	} else {
		if (VAR_14 >= 1) {
			fprintf(VAR_19,
				""DEBUG: wpantund version check succeded.\n"");
		}
	}

	if (VAR_10 < VAR_0) {
			if (VAR_14 >= 1) {
			fprintf(VAR_19, ""DEBUG: Executing command '%s'. . .\n"",
				VAR_1[VAR_10]);
		}

		VAR_0 -= VAR_10;
		VAR_1 += VAR_10;

		VAR_10 = 0;
		VAR_12 = exec_command(VAR_0, VAR_1);
		goto bail;
	}

	if (VAR_21) {
#if !VAR_17
		fprintf(VAR_19,
		        ""%s: error: Interactive mode disabled: Compiled without libeditline or libreadline support.\n"",
		        VAR_1[0]
		        );
		print_arg_list_help(VAR_11,
		                    VAR_1[0],
		                    ""[options] <sub-command> [args]"");
		print_commands();
		VAR_12 = VAR_30;
		goto bail;
#else   /* COMMENT_7 */
		setenv(""WPANCTL_HISTORY_FILE"", tilde_expand(""~/.wpanctl_history""), 0);

		VAR_12 = initialize_readline();
		if(VAR_12) {
			fprintf(VAR_19,
			        ""%s: error: Failed to initialize readline: %d\n"",
			        VAR_1[0], VAR_12
			        );
			goto bail;
		}
#endif  /* COMMENT_7 */
	}

	/* COMMENT_8 */
	while ((VAR_12 != VAR_31) && !feof(VAR_18)) {
		VAR_10 = 0;
#if VAR_17
		if (VAR_21) {
			int VAR_32 = -1;

			dbus_connection_get_unix_fd(VAR_5, &VAR_32);

			struct pollfd VAR_33[2] = {
				{ fileno(VAR_18), VAR_34 | VAR_35,               0                         },
				{ VAR_32,               VAR_34 | VAR_35,               0                         },
			};

			if (poll(
			        VAR_33,
			        (VAR_32 >= 0) ? 2 : 1,
			        1000
			        ) < 0
			    ) {
				if (VAR_36 == VAR_37) {
					/* COMMENT_9 */
					/* COMMENT_10 */
				} else {
					break;
				}
			}

			if (VAR_33[0].revents)
				rl_callback_read_char();
		} else
#endif  /* COMMENT_7 */
		{
			char VAR_38[200];
			process_input_line(fgets(VAR_38, sizeof(VAR_38), VAR_18));
		}

		dbus_connection_read_write_dispatch(VAR_5, 0);
	}
	printf(""\n"");

bail:
#if VAR_17
	rl_callback_handler_remove();
#endif  /* COMMENT_7 */
	if (VAR_12 == VAR_31)
		VAR_12 = 0;

	if (VAR_5) {
		dbus_connection_unref(VAR_5);
	}

	dbus_error_free(&VAR_4);

	return VAR_12;
}",openthread/wpantund/0e5d1601febb869f583e944785e5685c6c747be7/wpanctl.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 	int c;
 	bool ignore_driver_version_mismatch = false;
 	DBusError error;
-	DBusConnection* connection;
+	DBusConnection* connection = NULL;
 
 	dbus_error_init(&error);
 
@@ -283,5 +283,11 @@
 	if (gRet == ERRORCODE_QUIT)
 		gRet = 0;
 
+	if (connection) {
+		dbus_connection_unref(connection);
+	}
+
+	dbus_error_free(&error);
+
 	return gRet;
 }","{'deleted_lines': ['\tDBusConnection* connection;'], 'added_lines': ['\tDBusConnection* connection = NULL;', '\tif (connection) {', '\t\tdbus_connection_unref(connection);', '\t}', '', '\tdbus_error_free(&error);', '']}",True,"A memory leak in Openthread's wpantund versions up to commit 0e5d1601febb869f583e944785e5685c6c747be7, when used in an environment where wpanctl is directly interfacing with the control driver (eg: debug environments) can allow an attacker to crash the service (DoS). We recommend updating, or to restrict access in your debug environments.",5.5,MEDIUM,1,valid,2020-05-29T01:13:23Z,3
CVE-2020-23707,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,brackeen/ok-file-formats,Fix issue with miscalculation of block overflow size (#8),ce43dd0a862485928dc30f282e69094b21d925fc,https://github.com/brackeen/ok-file-formats/commit/ce43dd0a862485928dc30f282e69094b21d925fc,ok_jpg.c,ok_jpg_read_sof,"static bool ok_jpg_read_sof(ok_jpg_decoder *decoder) {
ok_jpg *jpg = decoder->jpg;
uint8_t buffer[3 * 3];
if (!ok_read(decoder, buffer, 8)) {
return false;
}
int length = readBE16(buffer) - 8;
int P = buffer[2];
if (P != 8) {
ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Invalid component size"");
return false;
}
decoder->in_height = readBE16(buffer + 3);
decoder->in_width = readBE16(buffer + 5);
if (decoder->in_width == 0 || decoder->in_height == 0) {
ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Invalid image dimensions"");
return false;
}
jpg->width = decoder->rotate ? decoder->in_height : decoder->in_width;
jpg->height = decoder->rotate ? decoder->in_width : decoder->in_height;
jpg->bpp = 4;     decoder->num_components = buffer[7];
uint64_t stride = (uint64_t)jpg->width * jpg->bpp;
if (stride > INT32_MAX) {
ok_jpg_error(jpg, OK_JPG_ERROR_UNSUPPORTED, ""Width too large"");
return false;
}
jpg->stride = (uint32_t)stride;
if (decoder->num_components == 4) {
ok_jpg_error(jpg, OK_JPG_ERROR_UNSUPPORTED, ""Unsupported format (CMYK)"");
return false;
}
if (decoder->num_components != 1 && decoder->num_components != 3) {
ok_jpg_error(jpg, OK_JPG_ERROR_UNSUPPORTED, ""Invalid component count"");
return false;
}
if (length < 3 * decoder->num_components) {
ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""SOF segment too short"");
return false;
}
if (!ok_read(decoder, buffer, 3 * (size_t)decoder->num_components)) {
return false;
}
int maxH = 1;
int maxV = 1;
int minH = 4;
int minV = 4;
for (int i = 0; i < decoder->num_components; i++) {
ok_jpg_component *c = decoder->components + i;
c->id = buffer[i * 3 + 0];
c->H = buffer[i * 3 + 1] >> 4;
c->V = buffer[i * 3 + 1] & 0x0F;
c->Tq = buffer[i * 3 + 2];
if (c->H == 0 || c->V == 0 || c->H > 4 || c->V > 4 || c->Tq > 3) {
ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Bad component"");
return false;
}
if (c->H > MAX_SAMPLING_FACTOR || c->V > MAX_SAMPLING_FACTOR) {
ok_jpg_error(jpg, OK_JPG_ERROR_UNSUPPORTED, ""Unsupported sampling factor"");
return false;
}
maxH = max(maxH, c->H);
maxV = max(maxV, c->V);
minH = min(minH, c->H);
minV = min(minV, c->V);
length -= 3;
}
if (minH > 1 || minV > 1) {
maxH = 1;
maxV = 1;
for (int i = 0; i < decoder->num_components; i++) {
ok_jpg_component *c = decoder->components + i;
c->H /= minH;
c->V /= minV;
maxH = max(maxH, c->H);
maxV = max(maxV, c->V);
}
}
decoder->data_units_x = intDivCeil(decoder->in_width, maxH * 8);
decoder->data_units_y = intDivCeil(decoder->in_height, maxV * 8);
if (length > 0) {
if (!ok_seek(decoder, length)) {
return false;
}
}
for (int i = 0; i < decoder->num_components; i++) {
ok_jpg_component *c = decoder->components + i;
c->blocks_h = intDivCeil(decoder->in_width, (maxH / c->H) * 8);
c->blocks_v = intDivCeil(decoder->in_height, (maxV / c->V) * 8);
if (c->H == maxH && c->V == maxV) {
c->idct = ok_jpg_idct_8x8;
} else if (c->H * 2 == maxH && c->V * 2 == maxV) {
c->idct = ok_jpg_idct_16x16;
} else if (c->H == maxH && c->V * 2 == maxV) {
c->idct = ok_jpg_idct_8x16;
} else if (c->H * 2 == maxH && c->V == maxV) {
c->idct = ok_jpg_idct_16x8;
} else {
ok_jpg_error(jpg, OK_JPG_ERROR_UNSUPPORTED, ""Unsupported IDCT sampling factor"");
return false;
}
}
if (!decoder->info_only) {
if (decoder->sof_found) {
ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Invalid JPEG (Multiple SOF markers)"");
return false;
}
decoder->sof_found = true;
if (decoder->progressive) {
for (int i = 0; i < decoder->num_components; i++) {
ok_jpg_component *c = decoder->components + i;
size_t num_blocks = (size_t)(decoder->data_units_x * c->H *
decoder->data_units_y * c->V);
size_t size = num_blocks * 64 * sizeof(*c->blocks) + OK_JPG_BLOCK_EXTRA_SPACE;
c->blocks = decoder->allocator.alloc(decoder->allocator_user_data, size);
if (!c->blocks) {
ok_jpg_error(jpg, OK_JPG_ERROR_ALLOCATION,
""Couldn't allocate internal block memory for image"");
return false;
}
}
}
if (!jpg->data) {
if (decoder->allocator.image_alloc) {
decoder->allocator.image_alloc(decoder->allocator_user_data,
jpg->width, jpg->height, jpg->bpp,
&jpg->data, &jpg->stride);
} else {
uint64_t size = (uint64_t)jpg->stride * jpg->height;
size_t platform_size = (size_t)size;
if (platform_size == size) {
jpg->data = decoder->allocator.alloc(decoder->allocator_user_data, platform_size);
}
}
if (!jpg->data) {
ok_jpg_error(jpg, OK_JPG_ERROR_ALLOCATION, ""Couldn't allocate memory for image"");
return false;
}
if (jpg->stride < jpg->width * jpg->bpp) {
ok_jpg_error(jpg, OK_JPG_ERROR_API, ""Invalid stride"");
return false;
}
}
}
#if 0
printf(""SOF: Components %i ("", decoder->num_components);
for (int i = 0; i < decoder->num_components; i++) {
ok_jpg_component *c = decoder->components + i;
if (i != 0) {
printf("","");
}
printf(""%ix%i"", maxH/c->H, maxV/c->V);
}
printf("")\n"");
#endif
return true;
}","static bool ok_jpg_read_sof(ok_jpg_decoder *VAR_0) {
ok_jpg *VAR_1 = VAR_0->jpg;
uint8_t VAR_2[3 * 3];
if (!ok_read(VAR_0, VAR_2, 8)) {
return false;
}
int VAR_3 = readBE16(VAR_2) - 8;
int VAR_4 = VAR_2[2];
if (VAR_4 != 8) {
ok_jpg_error(VAR_1, VAR_5, ""Invalid component size"");
return false;
}
VAR_0->in_height = readBE16(VAR_2 + 3);
VAR_0->in_width = readBE16(VAR_2 + 5);
if (VAR_0->in_width == 0 || VAR_0->in_height == 0) {
ok_jpg_error(VAR_1, VAR_5, ""Invalid image dimensions"");
return false;
}
VAR_1->width = VAR_0->rotate ? VAR_0->in_height : VAR_0->in_width;
VAR_1->height = VAR_0->rotate ? VAR_0->in_width : VAR_0->in_height;
VAR_1->bpp = 4; 
VAR_0->num_components = VAR_2[7];
uint64_t VAR_6 = (uint64_t)VAR_1->width * VAR_1->bpp;
if (VAR_6 > VAR_7) {
ok_jpg_error(VAR_1, VAR_8, ""Width too large"");
return false;
}
VAR_1->stride = (uint32_t)VAR_6;
if (VAR_0->num_components == 4) {
ok_jpg_error(VAR_1, VAR_8, ""Unsupported format (CMYK)"");
return false;
}
if (VAR_0->num_components != 1 && VAR_0->num_components != 3) {
ok_jpg_error(VAR_1, VAR_8, ""Invalid component count"");
return false;
}
if (VAR_3 < 3 * VAR_0->num_components) {
ok_jpg_error(VAR_1, VAR_5, ""SOF segment too short"");
return false;
}
if (!ok_read(VAR_0, VAR_2, 3 * (size_t)VAR_0->num_components)) {
return false;
}
int VAR_9 = 1;
int VAR_10 = 1;
int VAR_11 = 4;
int VAR_12 = 4;
for (int VAR_13 = 0; VAR_13 < VAR_0->num_components; VAR_13++) {
ok_jpg_component *VAR_14 = VAR_0->components + VAR_13;
VAR_14->id = VAR_2[VAR_13 * 3 + 0];
VAR_14->H = VAR_2[VAR_13 * 3 + 1] >> 4;
VAR_14->V = VAR_2[VAR_13 * 3 + 1] & 0x0F;
VAR_14->Tq = VAR_2[VAR_13 * 3 + 2];
if (VAR_14->H == 0 || VAR_14->V == 0 || VAR_14->H > 4 || VAR_14->V > 4 || VAR_14->Tq > 3) {
ok_jpg_error(VAR_1, VAR_5, ""Bad component"");
return false;
}
if (VAR_14->H > VAR_15 || VAR_14->V > VAR_15) {
ok_jpg_error(VAR_1, VAR_8, ""Unsupported sampling factor"");
return false;
}
VAR_9 = max(VAR_9, VAR_14->H);
VAR_10 = max(VAR_10, VAR_14->V);
VAR_11 = min(VAR_11, VAR_14->H);
VAR_12 = min(VAR_12, VAR_14->V);
VAR_3 -= 3;
}
if (VAR_11 > 1 || VAR_12 > 1) {
VAR_9 = 1;
VAR_10 = 1;
for (int VAR_13 = 0; VAR_13 < VAR_0->num_components; VAR_13++) {
ok_jpg_component *VAR_14 = VAR_0->components + VAR_13;
VAR_14->H /= VAR_11;
VAR_14->V /= VAR_12;
VAR_9 = max(VAR_9, VAR_14->H);
VAR_10 = max(VAR_10, VAR_14->V);
}
}
VAR_0->data_units_x = intDivCeil(VAR_0->in_width, VAR_9 * 8);
VAR_0->data_units_y = intDivCeil(VAR_0->in_height, VAR_10 * 8);
if (VAR_3 > 0) {
if (!ok_seek(VAR_0, VAR_3)) {
return false;
}
}
for (int VAR_13 = 0; VAR_13 < VAR_0->num_components; VAR_13++) {
ok_jpg_component *VAR_14 = VAR_0->components + VAR_13;
VAR_14->blocks_h = intDivCeil(VAR_0->in_width, (VAR_9 / VAR_14->H) * 8);
VAR_14->blocks_v = intDivCeil(VAR_0->in_height, (VAR_10 / VAR_14->V) * 8);
if (VAR_14->H == VAR_9 && VAR_14->V == VAR_10) {
VAR_14->idct = VAR_16;
} else if (VAR_14->H * 2 == VAR_9 && VAR_14->V * 2 == VAR_10) {
VAR_14->idct = VAR_17;
} else if (VAR_14->H == VAR_9 && VAR_14->V * 2 == VAR_10) {
VAR_14->idct = VAR_18;
} else if (VAR_14->H * 2 == VAR_9 && VAR_14->V == VAR_10) {
VAR_14->idct = VAR_19;
} else {
ok_jpg_error(VAR_1, VAR_8, ""Unsupported IDCT sampling factor"");
return false;
}
}
if (!VAR_0->info_only) {
if (VAR_0->sof_found) {
ok_jpg_error(VAR_1, VAR_5, ""Invalid JPEG (Multiple SOF markers)"");
return false;
}
VAR_0->sof_found = true;
if (VAR_0->progressive) {
for (int VAR_13 = 0; VAR_13 < VAR_0->num_components; VAR_13++) {
ok_jpg_component *VAR_14 = VAR_0->components + VAR_13;
size_t VAR_20 = (size_t)(VAR_0->data_units_x * VAR_14->H *
VAR_0->data_units_y * VAR_14->V);
size_t VAR_21 = VAR_20 * 64 * sizeof(*VAR_14->blocks) + VAR_22;
VAR_14->blocks = VAR_0->allocator.alloc(VAR_0->allocator_user_data, VAR_21);
if (!VAR_14->blocks) {
ok_jpg_error(VAR_1, VAR_23,
""Couldn't allocate internal block memory for image"");
return false;
}
}
}
if (!VAR_1->data) {
if (VAR_0->allocator.image_alloc) {
VAR_0->allocator.image_alloc(VAR_0->allocator_user_data,
VAR_1->width, VAR_1->height, VAR_1->bpp,
&VAR_1->data, &VAR_1->stride);
} else {
uint64_t VAR_21 = (uint64_t)VAR_1->stride * VAR_1->height;
size_t VAR_24 = (size_t)VAR_21;
if (VAR_24 == VAR_21) {
VAR_1->data = VAR_0->allocator.alloc(VAR_0->allocator_user_data, VAR_24);
}
}
if (!VAR_1->data) {
ok_jpg_error(VAR_1, VAR_23, ""Couldn't allocate memory for image"");
return false;
}
if (VAR_1->stride < VAR_1->width * VAR_1->bpp) {
ok_jpg_error(VAR_1, VAR_25, ""Invalid stride"");
return false;
}
}
}
#if 0
printf(""SOF: Components %i ("", VAR_0->num_components);
for (int VAR_13 = 0; VAR_13 < VAR_0->num_components; VAR_13++) {
ok_jpg_component *VAR_14 = VAR_0->components + VAR_13;
if (VAR_13 != 0) {
printf("","");
}
printf(""%ix%i"", VAR_9/VAR_14->H, VAR_10/VAR_14->V);
}
printf("")\n"");
#endif
return true;
}",brackeen/ok-file-formats/ce43dd0a862485928dc30f282e69094b21d925fc/ok_jpg.c/vul/before/0.json,"static bool ok_jpg_read_sof(ok_jpg_decoder *decoder) {
    // JPEG spec: Table B.2
    ok_jpg *jpg = decoder->jpg;
    uint8_t buffer[3 * 3];
    if (!ok_read(decoder, buffer, 8)) {
        return false;
    }
    int length = readBE16(buffer) - 8;
    int P = buffer[2];
    if (P != 8) {
        ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Invalid component size"");
        return false;
    }
    decoder->in_height = readBE16(buffer + 3);
    decoder->in_width = readBE16(buffer + 5);
    if (decoder->in_width == 0 || decoder->in_height == 0) {
        ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Invalid image dimensions"");
        return false;
    }
    jpg->width = decoder->rotate ? decoder->in_height : decoder->in_width;
    jpg->height = decoder->rotate ? decoder->in_width : decoder->in_height;
    jpg->bpp = 4; // Always decoding to 32-bit color
    decoder->num_components = buffer[7];
    
    uint64_t stride = (uint64_t)jpg->width * jpg->bpp;
    if (stride > INT32_MAX) {
        // Stride must fit in a singed int, see ok_jpg_convert_data_unit
        ok_jpg_error(jpg, OK_JPG_ERROR_UNSUPPORTED, ""Width too large"");
        return false;
    }
    jpg->stride = (uint32_t)stride;
    
    if (decoder->num_components == 4) {
        ok_jpg_error(jpg, OK_JPG_ERROR_UNSUPPORTED, ""Unsupported format (CMYK)"");
        return false;
    }
    if (decoder->num_components != 1 && decoder->num_components != 3) {
        ok_jpg_error(jpg, OK_JPG_ERROR_UNSUPPORTED, ""Invalid component count"");
        return false;
    }

    if (length < 3 * decoder->num_components) {
        ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""SOF segment too short"");
        return false;
    }
    if (!ok_read(decoder, buffer, 3 * (size_t)decoder->num_components)) {
        return false;
    }

    int maxH = 1;
    int maxV = 1;
    int minH = 4;
    int minV = 4;
    for (int i = 0; i < decoder->num_components; i++) {
        ok_jpg_component *c = decoder->components + i;
        c->id = buffer[i * 3 + 0];
        c->H = buffer[i * 3 + 1] >> 4;
        c->V = buffer[i * 3 + 1] & 0x0F;
        c->Tq = buffer[i * 3 + 2];

        if (c->H == 0 || c->V == 0 || c->H > 4 || c->V > 4 || c->Tq > 3) {
            ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Bad component"");
            return false;
        }

        if (c->H > MAX_SAMPLING_FACTOR || c->V > MAX_SAMPLING_FACTOR) {
            ok_jpg_error(jpg, OK_JPG_ERROR_UNSUPPORTED, ""Unsupported sampling factor"");
            return false;
        }

        maxH = max(maxH, c->H);
        maxV = max(maxV, c->V);
        minH = min(minH, c->H);
        minV = min(minV, c->V);
        length -= 3;
    }
    if (minH > 1 || minV > 1) {
        maxH = 1;
        maxV = 1;
        for (int i = 0; i < decoder->num_components; i++) {
            ok_jpg_component *c = decoder->components + i;
            c->H /= minH;
            c->V /= minV;
            maxH = max(maxH, c->H);
            maxV = max(maxV, c->V);
        }
    }
    decoder->data_units_x = intDivCeil(decoder->in_width, maxH * 8);
    decoder->data_units_y = intDivCeil(decoder->in_height, maxV * 8);

    // Skip remaining length, if any
    if (length > 0) {
        if (!ok_seek(decoder, length)) {
            return false;
        }
    }

    // Setup idct
    for (int i = 0; i < decoder->num_components; i++) {
        ok_jpg_component *c = decoder->components + i;
        c->blocks_h = intDivCeil(decoder->in_width, (maxH / c->H) * 8);
        c->blocks_v = intDivCeil(decoder->in_height, (maxV / c->V) * 8);
        if (c->H == maxH && c->V == maxV) {
            c->idct = ok_jpg_idct_8x8;
        } else if (c->H * 2 == maxH && c->V * 2 == maxV) {
            c->idct = ok_jpg_idct_16x16;
        } else if (c->H == maxH && c->V * 2 == maxV) {
            c->idct = ok_jpg_idct_8x16;
        } else if (c->H * 2 == maxH && c->V == maxV) {
            c->idct = ok_jpg_idct_16x8;
        } else {
            ok_jpg_error(jpg, OK_JPG_ERROR_UNSUPPORTED, ""Unsupported IDCT sampling factor"");
            return false;
        }
    }

    // Allocate data
    if (!decoder->info_only) {
        if (decoder->sof_found) {
            ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Invalid JPEG (Multiple SOF markers)"");
            return false;
        }
        decoder->sof_found = true;

        if (decoder->progressive) {
            for (int i = 0; i < decoder->num_components; i++) {
                ok_jpg_component *c = decoder->components + i;
                size_t num_blocks = (size_t)(decoder->data_units_x * c->H *
                                             decoder->data_units_y * c->V);
                size_t size = (num_blocks * 64 + OK_JPG_BLOCK_EXTRA_SPACE) * sizeof(*c->blocks);
                c->blocks = decoder->allocator.alloc(decoder->allocator_user_data, size);
                if (!c->blocks) {
                    ok_jpg_error(jpg, OK_JPG_ERROR_ALLOCATION,
                                 ""Couldn't allocate internal block memory for image"");
                    return false;
                }
            }
        }

        if (!jpg->data) {
            if (decoder->allocator.image_alloc) {
                decoder->allocator.image_alloc(decoder->allocator_user_data,
                                               jpg->width, jpg->height, jpg->bpp,
                                               &jpg->data, &jpg->stride);
            } else {
                uint64_t size = (uint64_t)jpg->stride * jpg->height;
                size_t platform_size = (size_t)size;
                if (platform_size == size) {
                    jpg->data = decoder->allocator.alloc(decoder->allocator_user_data, platform_size);
                }
            }
            if (!jpg->data) {
                ok_jpg_error(jpg, OK_JPG_ERROR_ALLOCATION, ""Couldn't allocate memory for image"");
                return false;
            }
            if (jpg->stride < jpg->width * jpg->bpp) {
                ok_jpg_error(jpg, OK_JPG_ERROR_API, ""Invalid stride"");
                return false;
            }
        }
    }

#if 0
    printf(""SOF: Components %i ("", decoder->num_components);
    for (int i = 0; i < decoder->num_components; i++) {
        ok_jpg_component *c = decoder->components + i;
        if (i != 0) {
            printf("","");
        }
        printf(""%ix%i"", maxH/c->H, maxV/c->V);
    }
    printf("")\n"");
#endif
    return true;
}","static bool ok_jpg_read_sof(ok_jpg_decoder *VAR_0) {
    /* COMMENT_0 */
    ok_jpg *VAR_1 = VAR_0->jpg;
    uint8_t VAR_2[3 * 3];
    if (!ok_read(VAR_0, VAR_2, 8)) {
        return false;
    }
    int VAR_3 = readBE16(VAR_2) - 8;
    int VAR_4 = VAR_2[2];
    if (VAR_4 != 8) {
        ok_jpg_error(VAR_1, VAR_5, ""Invalid component size"");
        return false;
    }
    VAR_0->in_height = readBE16(VAR_2 + 3);
    VAR_0->in_width = readBE16(VAR_2 + 5);
    if (VAR_0->in_width == 0 || VAR_0->in_height == 0) {
        ok_jpg_error(VAR_1, VAR_5, ""Invalid image dimensions"");
        return false;
    }
    VAR_1->width = VAR_0->rotate ? VAR_0->in_height : VAR_0->in_width;
    VAR_1->height = VAR_0->rotate ? VAR_0->in_width : VAR_0->in_height;
    VAR_1->bpp = 4; /* COMMENT_1 */
    VAR_0->num_components = VAR_2[7];
    
    uint64_t VAR_6 = (uint64_t)VAR_1->width * VAR_1->bpp;
    if (VAR_6 > VAR_7) {
        /* COMMENT_2 */
        ok_jpg_error(VAR_1, VAR_8, ""Width too large"");
        return false;
    }
    VAR_1->stride = (uint32_t)VAR_6;
    
    if (VAR_0->num_components == 4) {
        ok_jpg_error(VAR_1, VAR_8, ""Unsupported format (CMYK)"");
        return false;
    }
    if (VAR_0->num_components != 1 && VAR_0->num_components != 3) {
        ok_jpg_error(VAR_1, VAR_8, ""Invalid component count"");
        return false;
    }

    if (VAR_3 < 3 * VAR_0->num_components) {
        ok_jpg_error(VAR_1, VAR_5, ""SOF segment too short"");
        return false;
    }
    if (!ok_read(VAR_0, VAR_2, 3 * (size_t)VAR_0->num_components)) {
        return false;
    }

    int VAR_9 = 1;
    int VAR_10 = 1;
    int VAR_11 = 4;
    int VAR_12 = 4;
    for (int VAR_13 = 0; VAR_13 < VAR_0->num_components; VAR_13++) {
        ok_jpg_component *VAR_14 = VAR_0->components + VAR_13;
        VAR_14->id = VAR_2[VAR_13 * 3 + 0];
        VAR_14->H = VAR_2[VAR_13 * 3 + 1] >> 4;
        VAR_14->V = VAR_2[VAR_13 * 3 + 1] & 0x0F;
        VAR_14->Tq = VAR_2[VAR_13 * 3 + 2];

        if (VAR_14->H == 0 || VAR_14->V == 0 || VAR_14->H > 4 || VAR_14->V > 4 || VAR_14->Tq > 3) {
            ok_jpg_error(VAR_1, VAR_5, ""Bad component"");
            return false;
        }

        if (VAR_14->H > VAR_15 || VAR_14->V > VAR_15) {
            ok_jpg_error(VAR_1, VAR_8, ""Unsupported sampling factor"");
            return false;
        }

        VAR_9 = max(VAR_9, VAR_14->H);
        VAR_10 = max(VAR_10, VAR_14->V);
        VAR_11 = min(VAR_11, VAR_14->H);
        VAR_12 = min(VAR_12, VAR_14->V);
        VAR_3 -= 3;
    }
    if (VAR_11 > 1 || VAR_12 > 1) {
        VAR_9 = 1;
        VAR_10 = 1;
        for (int VAR_13 = 0; VAR_13 < VAR_0->num_components; VAR_13++) {
            ok_jpg_component *VAR_14 = VAR_0->components + VAR_13;
            VAR_14->H /= VAR_11;
            VAR_14->V /= VAR_12;
            VAR_9 = max(VAR_9, VAR_14->H);
            VAR_10 = max(VAR_10, VAR_14->V);
        }
    }
    VAR_0->data_units_x = intDivCeil(VAR_0->in_width, VAR_9 * 8);
    VAR_0->data_units_y = intDivCeil(VAR_0->in_height, VAR_10 * 8);

    /* COMMENT_3 */
    if (VAR_3 > 0) {
        if (!ok_seek(VAR_0, VAR_3)) {
            return false;
        }
    }

    /* COMMENT_4 */
    for (int VAR_13 = 0; VAR_13 < VAR_0->num_components; VAR_13++) {
        ok_jpg_component *VAR_14 = VAR_0->components + VAR_13;
        VAR_14->blocks_h = intDivCeil(VAR_0->in_width, (VAR_9 / VAR_14->H) * 8);
        VAR_14->blocks_v = intDivCeil(VAR_0->in_height, (VAR_10 / VAR_14->V) * 8);
        if (VAR_14->H == VAR_9 && VAR_14->V == VAR_10) {
            VAR_14->idct = VAR_16;
        } else if (VAR_14->H * 2 == VAR_9 && VAR_14->V * 2 == VAR_10) {
            VAR_14->idct = VAR_17;
        } else if (VAR_14->H == VAR_9 && VAR_14->V * 2 == VAR_10) {
            VAR_14->idct = VAR_18;
        } else if (VAR_14->H * 2 == VAR_9 && VAR_14->V == VAR_10) {
            VAR_14->idct = VAR_19;
        } else {
            ok_jpg_error(VAR_1, VAR_8, ""Unsupported IDCT sampling factor"");
            return false;
        }
    }

    /* COMMENT_5 */
    if (!VAR_0->info_only) {
        if (VAR_0->sof_found) {
            ok_jpg_error(VAR_1, VAR_5, ""Invalid JPEG (Multiple SOF markers)"");
            return false;
        }
        VAR_0->sof_found = true;

        if (VAR_0->progressive) {
            for (int VAR_13 = 0; VAR_13 < VAR_0->num_components; VAR_13++) {
                ok_jpg_component *VAR_14 = VAR_0->components + VAR_13;
                size_t VAR_20 = (size_t)(VAR_0->data_units_x * VAR_14->H *
                                             VAR_0->data_units_y * VAR_14->V);
                size_t VAR_21 = (VAR_20 * 64 + VAR_22) * sizeof(*VAR_14->blocks);
                VAR_14->blocks = VAR_0->allocator.alloc(VAR_0->allocator_user_data, VAR_21);
                if (!VAR_14->blocks) {
                    ok_jpg_error(VAR_1, VAR_23,
                                 ""Couldn't allocate internal block memory for image"");
                    return false;
                }
            }
        }

        if (!VAR_1->data) {
            if (VAR_0->allocator.image_alloc) {
                VAR_0->allocator.image_alloc(VAR_0->allocator_user_data,
                                               VAR_1->width, VAR_1->height, VAR_1->bpp,
                                               &VAR_1->data, &VAR_1->stride);
            } else {
                uint64_t VAR_21 = (uint64_t)VAR_1->stride * VAR_1->height;
                size_t VAR_24 = (size_t)VAR_21;
                if (VAR_24 == VAR_21) {
                    VAR_1->data = VAR_0->allocator.alloc(VAR_0->allocator_user_data, VAR_24);
                }
            }
            if (!VAR_1->data) {
                ok_jpg_error(VAR_1, VAR_23, ""Couldn't allocate memory for image"");
                return false;
            }
            if (VAR_1->stride < VAR_1->width * VAR_1->bpp) {
                ok_jpg_error(VAR_1, VAR_25, ""Invalid stride"");
                return false;
            }
        }
    }

#if 0
    printf(""SOF: Components %i ("", VAR_0->num_components);
    for (int VAR_13 = 0; VAR_13 < VAR_0->num_components; VAR_13++) {
        ok_jpg_component *VAR_14 = VAR_0->components + VAR_13;
        if (VAR_13 != 0) {
            printf("","");
        }
        printf(""%ix%i"", VAR_9/VAR_14->H, VAR_10/VAR_14->V);
    }
    printf("")\n"");
#endif
    return true;
}",brackeen/ok-file-formats/ce43dd0a862485928dc30f282e69094b21d925fc/ok_jpg.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -127,7 +127,7 @@
                 ok_jpg_component *c = decoder->components + i;
                 size_t num_blocks = (size_t)(decoder->data_units_x * c->H *
                                              decoder->data_units_y * c->V);
-                size_t size = num_blocks * 64 * sizeof(*c->blocks) + OK_JPG_BLOCK_EXTRA_SPACE;
+                size_t size = (num_blocks * 64 + OK_JPG_BLOCK_EXTRA_SPACE) * sizeof(*c->blocks);
                 c->blocks = decoder->allocator.alloc(decoder->allocator_user_data, size);
                 if (!c->blocks) {
                     ok_jpg_error(jpg, OK_JPG_ERROR_ALLOCATION,","{'deleted_lines': ['                size_t size = num_blocks * 64 * sizeof(*c->blocks) + OK_JPG_BLOCK_EXTRA_SPACE;'], 'added_lines': ['                size_t size = (num_blocks * 64 + OK_JPG_BLOCK_EXTRA_SPACE) * sizeof(*c->blocks);']}",True,A heap-based buffer overflow vulnerability in the function ok_jpg_decode_block_progressive() at ok_jpg.c:1054 of ok-file-formats through 2020-06-26 allows attackers to cause a Denial of Service (DOS) via a crafted jpeg file.,6.5,MEDIUM,1,valid,2020-06-27T22:19:25Z,3
CVE-2020-15567,['CWE-362'],AV:L/AC:M/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/EPT: ept_set_middle_entry() related adjustments

ept_split_super_page() wants to further modify the newly allocated
table, so have ept_set_middle_entry() return the mapped pointer rather
than tearing it down and then getting re-established right again.

Similarly ept_next_level() wants to hand back a mapped pointer of
the next level page, so re-use the one established by
ept_set_middle_entry() in case that path was taken.

Pull the setting of suppress_ve ahead of insertion into the higher level
table, and don't have ept_split_super_page() set the field a 2nd time.

This is part of XSA-328.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Roger Pau Monn <roger.pau@citrix.com>",1104288186ee73a7f9bfa41cbaa5bb7611521028,https://github.com/xen-project/xen/commit/1104288186ee73a7f9bfa41cbaa5bb7611521028,xen/arch/x86/mm/p2m-ept.c,ept_next_level,"static int ept_next_level(struct p2m_domain *p2m, bool_t read_only,
ept_entry_t **table, unsigned long *gfn_remainder,
int next_level)
{
unsigned long mfn;
ept_entry_t *ept_entry, e;
u32 shift, index;
shift = next_level * EPT_TABLE_ORDER;
index = *gfn_remainder >> shift;
ASSERT(index < EPT_PAGETABLE_ENTRIES);
ept_entry = (*table) + index;
e = atomic_read_ept_entry(ept_entry);
if ( !is_epte_present(&e) )
{
if ( e.sa_p2mt == p2m_populate_on_demand )
return GUEST_TABLE_POD_PAGE;
if ( read_only )
return GUEST_TABLE_MAP_FAILED;
if ( !ept_set_middle_entry(p2m, ept_entry) )
return GUEST_TABLE_MAP_FAILED;
else
e = atomic_read_ept_entry(ept_entry); 
}
if ( is_epte_superpage(&e) )
return GUEST_TABLE_SUPER_PAGE;
mfn = e.mfn;
unmap_domain_page(*table);
*table = map_domain_page(_mfn(mfn));
*gfn_remainder &= (1UL << shift) - 1;
return GUEST_TABLE_NORMAL_PAGE;
}","static int ept_next_level(struct p2m_domain *VAR_0, bool_t VAR_1,
ept_entry_t **VAR_2, unsigned long *VAR_3,
int VAR_4)
{
unsigned long VAR_5;
ept_entry_t *VAR_6, VAR_7;
u32 VAR_8, VAR_9;
VAR_8 = VAR_4 * VAR_10;
VAR_9 = *VAR_3 >> VAR_8;
ASSERT(VAR_9 < VAR_11);
VAR_6 = (*VAR_2) + VAR_9;
VAR_7 = atomic_read_ept_entry(VAR_6);
if ( !is_epte_present(&VAR_7) )
{
if ( VAR_7.sa_p2mt == VAR_12 )
return VAR_13;
if ( VAR_1 )
return VAR_14;
if ( !ept_set_middle_entry(VAR_0, VAR_6) )
return VAR_14;
else
VAR_7 = atomic_read_ept_entry(VAR_6); 
}
if ( is_epte_superpage(&VAR_7) )
return VAR_15;
VAR_5 = VAR_7.mfn;
unmap_domain_page(*VAR_2);
*VAR_2 = map_domain_page(_mfn(VAR_5));
*VAR_3 &= (1UL << VAR_8) - 1;
return VAR_16;
}",xen-project/xen/1104288186ee73a7f9bfa41cbaa5bb7611521028/p2m-ept.c/vul/before/0.json,"static int ept_next_level(struct p2m_domain *p2m, bool_t read_only,
                          ept_entry_t **table, unsigned long *gfn_remainder,
                          int next_level)
{
    ept_entry_t *ept_entry, *next = NULL, e;
    u32 shift, index;

    shift = next_level * EPT_TABLE_ORDER;

    index = *gfn_remainder >> shift;

    /* index must be falling into the page */
    ASSERT(index < EPT_PAGETABLE_ENTRIES);

    ept_entry = (*table) + index;

    /* ept_next_level() is called (sometimes) without a lock.  Read
     * the entry once, and act on the ""cached"" entry after that to
     * avoid races. */
    e = atomic_read_ept_entry(ept_entry);

    if ( !is_epte_present(&e) )
    {
        if ( e.sa_p2mt == p2m_populate_on_demand )
            return GUEST_TABLE_POD_PAGE;

        if ( read_only )
            return GUEST_TABLE_MAP_FAILED;

        next = ept_set_middle_entry(p2m, ept_entry);
        if ( !next )
            return GUEST_TABLE_MAP_FAILED;
        /* e is now stale and hence may not be used anymore below. */
    }
    /* The only time sp would be set here is if we had hit a superpage */
    else if ( is_epte_superpage(&e) )
        return GUEST_TABLE_SUPER_PAGE;

    unmap_domain_page(*table);
    *table = next ?: map_domain_page(_mfn(e.mfn));
    *gfn_remainder &= (1UL << shift) - 1;
    return GUEST_TABLE_NORMAL_PAGE;
}","static int ept_next_level(struct p2m_domain *VAR_0, bool_t VAR_1,
                          ept_entry_t **VAR_2, unsigned long *VAR_3,
                          int VAR_4)
{
    ept_entry_t *VAR_5, *VAR_6 = NULL, VAR_7;
    u32 VAR_8, VAR_9;

    VAR_8 = VAR_4 * VAR_10;

    VAR_9 = *VAR_3 >> VAR_8;

    /* COMMENT_0 */
    ASSERT(VAR_9 < VAR_11);

    VAR_5 = (*VAR_2) + VAR_9;

    /* COMMENT_1 */
                                                                  
                      
    VAR_7 = atomic_read_ept_entry(VAR_5);

    if ( !is_epte_present(&VAR_7) )
    {
        if ( VAR_7.sa_p2mt == VAR_12 )
            return VAR_13;

        if ( VAR_1 )
            return VAR_14;

        VAR_6 = ept_set_middle_entry(VAR_0, VAR_5);
        if ( !VAR_6 )
            return VAR_14;
        /* COMMENT_4 */
    }
    /* COMMENT_5 */
    else if ( is_epte_superpage(&VAR_7) )
        return VAR_15;

    unmap_domain_page(*VAR_2);
    *VAR_2 = VAR_6 ?VAR_16: map_domain_page(_mfn(VAR_7.mfn));
    *VAR_3 &= (1UL << VAR_8) - 1;
    return VAR_17;
}",xen-project/xen/1104288186ee73a7f9bfa41cbaa5bb7611521028/p2m-ept.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,8 +2,7 @@
                           ept_entry_t **table, unsigned long *gfn_remainder,
                           int next_level)
 {
-    unsigned long mfn;
-    ept_entry_t *ept_entry, e;
+    ept_entry_t *ept_entry, *next = NULL, e;
     u32 shift, index;
 
     shift = next_level * EPT_TABLE_ORDER;
@@ -28,19 +27,17 @@
         if ( read_only )
             return GUEST_TABLE_MAP_FAILED;
 
-        if ( !ept_set_middle_entry(p2m, ept_entry) )
+        next = ept_set_middle_entry(p2m, ept_entry);
+        if ( !next )
             return GUEST_TABLE_MAP_FAILED;
-        else
-            e = atomic_read_ept_entry(ept_entry); /* Refresh */
+        /* e is now stale and hence may not be used anymore below. */
     }
-
     /* The only time sp would be set here is if we had hit a superpage */
-    if ( is_epte_superpage(&e) )
+    else if ( is_epte_superpage(&e) )
         return GUEST_TABLE_SUPER_PAGE;
 
-    mfn = e.mfn;
     unmap_domain_page(*table);
-    *table = map_domain_page(_mfn(mfn));
+    *table = next ?: map_domain_page(_mfn(e.mfn));
     *gfn_remainder &= (1UL << shift) - 1;
     return GUEST_TABLE_NORMAL_PAGE;
 }","{'deleted_lines': ['    unsigned long mfn;', '    ept_entry_t *ept_entry, e;', '        if ( !ept_set_middle_entry(p2m, ept_entry) )', '        else', '            e = atomic_read_ept_entry(ept_entry); /* Refresh */', '', '    if ( is_epte_superpage(&e) )', '    mfn = e.mfn;', '    *table = map_domain_page(_mfn(mfn));'], 'added_lines': ['    ept_entry_t *ept_entry, *next = NULL, e;', '        next = ept_set_middle_entry(p2m, ept_entry);', '        if ( !next )', '        /* e is now stale and hence may not be used anymore below. */', '    else if ( is_epte_superpage(&e) )', '    *table = next ?: map_domain_page(_mfn(e.mfn));']}",True,"An issue was discovered in Xen through 4.13.x, allowing Intel guest OS users to gain privileges or cause a denial of service because of non-atomic modification of a live EPT PTE. When mapping guest EPT (nested paging) tables, Xen would in some circumstances use a series of non-atomic bitfield writes. Depending on the compiler version and optimisation flags, Xen might expose a dangerous partially written PTE to the hardware, which an attacker might be able to race to exploit. A guest administrator or perhaps even an unprivileged guest user might be able to cause denial of service, data corruption, or privilege escalation. Only systems using Intel CPUs are vulnerable. Systems using AMD CPUs, and Arm systems, are not vulnerable. Only systems using nested paging (hap, aka nested paging, aka in this case Intel EPT) are vulnerable. Only HVM and PVH guests can exploit the vulnerability. The presence and scope of the vulnerability depends on the precise optimisations performed by the compiler used to build Xen. If the compiler generates (a) a single 64-bit write, or (b) a series of read-modify-write operations in the same order as the source code, the hypervisor is not vulnerable. For example, in one test build using GCC 8.3 with normal settings, the compiler generated multiple (unlocked) read-modify-write operations in source-code order, which did not constitute a vulnerability. We have not been able to survey compilers; consequently we cannot say which compiler(s) might produce vulnerable code (with which code-generation options). The source code clearly violates the C rules, and thus should be considered vulnerable.",7.8,HIGH,2,valid,2020-07-07T12:36:52Z,3
CVE-2020-15567,['CWE-362'],AV:L/AC:M/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/EPT: ept_set_middle_entry() related adjustments

ept_split_super_page() wants to further modify the newly allocated
table, so have ept_set_middle_entry() return the mapped pointer rather
than tearing it down and then getting re-established right again.

Similarly ept_next_level() wants to hand back a mapped pointer of
the next level page, so re-use the one established by
ept_set_middle_entry() in case that path was taken.

Pull the setting of suppress_ve ahead of insertion into the higher level
table, and don't have ept_split_super_page() set the field a 2nd time.

This is part of XSA-328.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Roger Pau Monn <roger.pau@citrix.com>",1104288186ee73a7f9bfa41cbaa5bb7611521028,https://github.com/xen-project/xen/commit/1104288186ee73a7f9bfa41cbaa5bb7611521028,xen/arch/x86/mm/p2m-ept.c,ept_split_super_page,"static bool_t ept_split_super_page(struct p2m_domain *p2m,
ept_entry_t *ept_entry,
unsigned int level, unsigned int target)
{
ept_entry_t new_ept, *table;
uint64_t trunk;
unsigned int i;
bool_t rv = 1;
if ( level <= target )
return 1;
ASSERT(is_epte_superpage(ept_entry));
if ( !ept_set_middle_entry(p2m, &new_ept) )
return 0;
table = map_domain_page(_mfn(new_ept.mfn));
trunk = 1UL << ((level - 1) * EPT_TABLE_ORDER);
for ( i = 0; i < EPT_PAGETABLE_ENTRIES; i++ )
{
ept_entry_t *epte = table + i;
*epte = *ept_entry;
epte->sp = (level > 1);
epte->mfn += i * trunk;
epte->snp = is_iommu_enabled(p2m->domain) && iommu_snoop;
epte->suppress_ve = 1;
ept_p2m_type_to_flags(p2m, epte);
if ( (level - 1) == target )
continue;
ASSERT(is_epte_superpage(epte));
if ( !(rv = ept_split_super_page(p2m, epte, level - 1, target)) )
break;
}
unmap_domain_page(table);
*ept_entry = new_ept;
return rv;
}","static bool_t ept_split_super_page(struct p2m_domain *VAR_0,
ept_entry_t *VAR_1,
unsigned int VAR_2, unsigned int VAR_3)
{
ept_entry_t VAR_4, *VAR_5;
uint64_t VAR_6;
unsigned int VAR_7;
bool_t VAR_8 = 1;
if ( VAR_2 <= VAR_3 )
return 1;
ASSERT(is_epte_superpage(VAR_1));
if ( !ept_set_middle_entry(VAR_0, &VAR_4) )
return 0;
VAR_5 = map_domain_page(_mfn(VAR_4.mfn));
VAR_6 = 1UL << ((VAR_2 - 1) * VAR_9);
for ( VAR_7 = 0; VAR_7 < VAR_10; VAR_7++ )
{
ept_entry_t *VAR_11 = VAR_5 + VAR_7;
*VAR_11 = *VAR_1;
VAR_11->sp = (VAR_2 > 1);
VAR_11->mfn += VAR_7 * VAR_6;
VAR_11->snp = is_iommu_enabled(VAR_0->domain) && VAR_12;
VAR_11->suppress_ve = 1;
ept_p2m_type_to_flags(VAR_0, VAR_11);
if ( (VAR_2 - 1) == VAR_3 )
continue;
ASSERT(is_epte_superpage(VAR_11));
if ( !(VAR_8 = ept_split_super_page(VAR_0, VAR_11, VAR_2 - 1, VAR_3)) )
break;
}
unmap_domain_page(VAR_5);
*VAR_1 = VAR_4;
return VAR_8;
}",xen-project/xen/1104288186ee73a7f9bfa41cbaa5bb7611521028/p2m-ept.c/vul/before/1.json,"static bool_t ept_split_super_page(struct p2m_domain *p2m,
                                   ept_entry_t *ept_entry,
                                   unsigned int level, unsigned int target)
{
    ept_entry_t new_ept, *table;
    uint64_t trunk;
    unsigned int i;
    bool_t rv = 1;

    /* End if the entry is a leaf entry or reaches the target level. */
    if ( level <= target )
        return 1;

    ASSERT(is_epte_superpage(ept_entry));

    table = ept_set_middle_entry(p2m, &new_ept);
    if ( !table )
        return 0;

    trunk = 1UL << ((level - 1) * EPT_TABLE_ORDER);

    for ( i = 0; i < EPT_PAGETABLE_ENTRIES; i++ )
    {
        ept_entry_t *epte = table + i;

        *epte = *ept_entry;
        epte->sp = (level > 1);
        epte->mfn += i * trunk;
        epte->snp = is_iommu_enabled(p2m->domain) && iommu_snoop;

        ept_p2m_type_to_flags(p2m, epte);

        if ( (level - 1) == target )
            continue;

        ASSERT(is_epte_superpage(epte));

        if ( !(rv = ept_split_super_page(p2m, epte, level - 1, target)) )
            break;
    }

    unmap_domain_page(table);

    /* Even failed we should install the newly allocated ept page. */
    *ept_entry = new_ept;

    return rv;
}","static bool_t ept_split_super_page(struct p2m_domain *VAR_0,
                                   ept_entry_t *VAR_1,
                                   unsigned int VAR_2, unsigned int VAR_3)
{
    ept_entry_t VAR_4, *VAR_5;
    uint64_t VAR_6;
    unsigned int VAR_7;
    bool_t VAR_8 = 1;

    /* COMMENT_0 */
    if ( VAR_2 <= VAR_3 )
        return 1;

    ASSERT(is_epte_superpage(VAR_1));

    VAR_5 = ept_set_middle_entry(VAR_0, &VAR_4);
    if ( !VAR_5 )
        return 0;

    VAR_6 = 1UL << ((VAR_2 - 1) * VAR_9);

    for ( VAR_7 = 0; VAR_7 < VAR_10; VAR_7++ )
    {
        ept_entry_t *VAR_11 = VAR_5 + VAR_7;

        *VAR_11 = *VAR_1;
        VAR_11->sp = (VAR_2 > 1);
        VAR_11->mfn += VAR_7 * VAR_6;
        VAR_11->snp = is_iommu_enabled(VAR_0->domain) && VAR_12;

        ept_p2m_type_to_flags(VAR_0, VAR_11);

        if ( (VAR_2 - 1) == VAR_3 )
            continue;

        ASSERT(is_epte_superpage(VAR_11));

        if ( !(VAR_8 = ept_split_super_page(VAR_0, VAR_11, VAR_2 - 1, VAR_3)) )
            break;
    }

    unmap_domain_page(VAR_5);

    /* COMMENT_1 */
    *VAR_1 = VAR_4;

    return VAR_8;
}",xen-project/xen/1104288186ee73a7f9bfa41cbaa5bb7611521028/p2m-ept.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -13,10 +13,10 @@
 
     ASSERT(is_epte_superpage(ept_entry));
 
-    if ( !ept_set_middle_entry(p2m, &new_ept) )
+    table = ept_set_middle_entry(p2m, &new_ept);
+    if ( !table )
         return 0;
 
-    table = map_domain_page(_mfn(new_ept.mfn));
     trunk = 1UL << ((level - 1) * EPT_TABLE_ORDER);
 
     for ( i = 0; i < EPT_PAGETABLE_ENTRIES; i++ )
@@ -27,7 +27,6 @@
         epte->sp = (level > 1);
         epte->mfn += i * trunk;
         epte->snp = is_iommu_enabled(p2m->domain) && iommu_snoop;
-        epte->suppress_ve = 1;
 
         ept_p2m_type_to_flags(p2m, epte);
 ","{'deleted_lines': ['    if ( !ept_set_middle_entry(p2m, &new_ept) )', '    table = map_domain_page(_mfn(new_ept.mfn));', '        epte->suppress_ve = 1;'], 'added_lines': ['    table = ept_set_middle_entry(p2m, &new_ept);', '    if ( !table )']}",True,"An issue was discovered in Xen through 4.13.x, allowing Intel guest OS users to gain privileges or cause a denial of service because of non-atomic modification of a live EPT PTE. When mapping guest EPT (nested paging) tables, Xen would in some circumstances use a series of non-atomic bitfield writes. Depending on the compiler version and optimisation flags, Xen might expose a dangerous partially written PTE to the hardware, which an attacker might be able to race to exploit. A guest administrator or perhaps even an unprivileged guest user might be able to cause denial of service, data corruption, or privilege escalation. Only systems using Intel CPUs are vulnerable. Systems using AMD CPUs, and Arm systems, are not vulnerable. Only systems using nested paging (hap, aka nested paging, aka in this case Intel EPT) are vulnerable. Only HVM and PVH guests can exploit the vulnerability. The presence and scope of the vulnerability depends on the precise optimisations performed by the compiler used to build Xen. If the compiler generates (a) a single 64-bit write, or (b) a series of read-modify-write operations in the same order as the source code, the hypervisor is not vulnerable. For example, in one test build using GCC 8.3 with normal settings, the compiler generated multiple (unlocked) read-modify-write operations in source-code order, which did not constitute a vulnerability. We have not been able to survey compilers; consequently we cannot say which compiler(s) might produce vulnerable code (with which code-generation options). The source code clearly violates the C rules, and thus should be considered vulnerable.",7.8,HIGH,2,valid,2020-07-07T12:36:52Z,3
CVE-2020-15567,['CWE-362'],AV:L/AC:M/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/EPT: ept_set_middle_entry() related adjustments

ept_split_super_page() wants to further modify the newly allocated
table, so have ept_set_middle_entry() return the mapped pointer rather
than tearing it down and then getting re-established right again.

Similarly ept_next_level() wants to hand back a mapped pointer of
the next level page, so re-use the one established by
ept_set_middle_entry() in case that path was taken.

Pull the setting of suppress_ve ahead of insertion into the higher level
table, and don't have ept_split_super_page() set the field a 2nd time.

This is part of XSA-328.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Roger Pau Monn <roger.pau@citrix.com>",1104288186ee73a7f9bfa41cbaa5bb7611521028,https://github.com/xen-project/xen/commit/1104288186ee73a7f9bfa41cbaa5bb7611521028,xen/arch/x86/mm/p2m-ept.c,ept_set_middle_entry,"static int ept_set_middle_entry(struct p2m_domain *p2m, ept_entry_t *ept_entry)
{
mfn_t mfn;
ept_entry_t *table;
unsigned int i;
mfn = p2m_alloc_ptp(p2m, 0);
if ( mfn_eq(mfn, INVALID_MFN) )
return 0;
ept_entry->epte = 0;
ept_entry->mfn = mfn_x(mfn);
ept_entry->access = p2m->default_access;
ept_entry->r = ept_entry->w = ept_entry->x = 1;
ept_entry->a = !!cpu_has_vmx_ept_ad;
ept_entry->suppress_ve = 1;
table = map_domain_page(mfn);
for ( i = 0; i < EPT_PAGETABLE_ENTRIES; i++ )
table[i].suppress_ve = 1;
unmap_domain_page(table);
return 1;
}","static int ept_set_middle_entry(struct p2m_domain *VAR_0, ept_entry_t *VAR_1)
{
mfn_t VAR_2;
ept_entry_t *VAR_3;
unsigned int VAR_4;
VAR_2 = p2m_alloc_ptp(VAR_0, 0);
if ( mfn_eq(VAR_2, VAR_5) )
return 0;
VAR_1->epte = 0;
VAR_1->mfn = mfn_x(VAR_2);
VAR_1->access = VAR_0->default_access;
VAR_1->r = VAR_1->w = VAR_1->x = 1;
VAR_1->a = !!VAR_6;
VAR_1->suppress_ve = 1;
VAR_3 = map_domain_page(VAR_2);
for ( VAR_4 = 0; VAR_4 < VAR_7; VAR_4++ )
VAR_3[VAR_4].suppress_ve = 1;
unmap_domain_page(VAR_3);
return 1;
}",xen-project/xen/1104288186ee73a7f9bfa41cbaa5bb7611521028/p2m-ept.c/vul/before/2.json,"static ept_entry_t *ept_set_middle_entry(struct p2m_domain *p2m,
                                         ept_entry_t *ept_entry)
{
    mfn_t mfn;
    ept_entry_t *table;
    unsigned int i;

    mfn = p2m_alloc_ptp(p2m, 0);
    if ( mfn_eq(mfn, INVALID_MFN) )
        return NULL;

    table = map_domain_page(mfn);

    for ( i = 0; i < EPT_PAGETABLE_ENTRIES; i++ )
        table[i].suppress_ve = 1;

    ept_entry->epte = 0;
    ept_entry->mfn = mfn_x(mfn);
    ept_entry->access = p2m->default_access;

    ept_entry->r = ept_entry->w = ept_entry->x = 1;
    /* Manually set A bit to avoid overhead of MMU having to write it later. */
    ept_entry->a = !!cpu_has_vmx_ept_ad;

    ept_entry->suppress_ve = 1;

    return table;
}","static ept_entry_t *ept_set_middle_entry(struct p2m_domain *VAR_0,
                                         ept_entry_t *VAR_1)
{
    mfn_t VAR_2;
    ept_entry_t *VAR_3;
    unsigned int VAR_4;

    VAR_2 = p2m_alloc_ptp(VAR_0, 0);
    if ( mfn_eq(VAR_2, VAR_5) )
        return NULL;

    VAR_3 = map_domain_page(VAR_2);

    for ( VAR_4 = 0; VAR_4 < VAR_6; VAR_4++ )
        VAR_3[VAR_4].suppress_ve = 1;

    VAR_1->epte = 0;
    VAR_1->mfn = mfn_x(VAR_2);
    VAR_1->access = VAR_0->default_access;

    VAR_1->r = VAR_1->w = VAR_1->x = 1;
    /* COMMENT_0 */
    VAR_1->a = !!VAR_7;

    VAR_1->suppress_ve = 1;

    return VAR_3;
}",xen-project/xen/1104288186ee73a7f9bfa41cbaa5bb7611521028/p2m-ept.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,4 +1,5 @@
-static int ept_set_middle_entry(struct p2m_domain *p2m, ept_entry_t *ept_entry)
+static ept_entry_t *ept_set_middle_entry(struct p2m_domain *p2m,
+                                         ept_entry_t *ept_entry)
 {
     mfn_t mfn;
     ept_entry_t *table;
@@ -6,7 +7,12 @@
 
     mfn = p2m_alloc_ptp(p2m, 0);
     if ( mfn_eq(mfn, INVALID_MFN) )
-        return 0;
+        return NULL;
+
+    table = map_domain_page(mfn);
+
+    for ( i = 0; i < EPT_PAGETABLE_ENTRIES; i++ )
+        table[i].suppress_ve = 1;
 
     ept_entry->epte = 0;
     ept_entry->mfn = mfn_x(mfn);
@@ -18,12 +24,5 @@
 
     ept_entry->suppress_ve = 1;
 
-    table = map_domain_page(mfn);
-
-    for ( i = 0; i < EPT_PAGETABLE_ENTRIES; i++ )
-        table[i].suppress_ve = 1;
-
-    unmap_domain_page(table);
-
-    return 1;
+    return table;
 }","{'deleted_lines': ['static int ept_set_middle_entry(struct p2m_domain *p2m, ept_entry_t *ept_entry)', '        return 0;', '    table = map_domain_page(mfn);', '', '    for ( i = 0; i < EPT_PAGETABLE_ENTRIES; i++ )', '        table[i].suppress_ve = 1;', '', '    unmap_domain_page(table);', '', '    return 1;'], 'added_lines': ['static ept_entry_t *ept_set_middle_entry(struct p2m_domain *p2m,', '                                         ept_entry_t *ept_entry)', '        return NULL;', '', '    table = map_domain_page(mfn);', '', '    for ( i = 0; i < EPT_PAGETABLE_ENTRIES; i++ )', '        table[i].suppress_ve = 1;', '    return table;']}",True,"An issue was discovered in Xen through 4.13.x, allowing Intel guest OS users to gain privileges or cause a denial of service because of non-atomic modification of a live EPT PTE. When mapping guest EPT (nested paging) tables, Xen would in some circumstances use a series of non-atomic bitfield writes. Depending on the compiler version and optimisation flags, Xen might expose a dangerous partially written PTE to the hardware, which an attacker might be able to race to exploit. A guest administrator or perhaps even an unprivileged guest user might be able to cause denial of service, data corruption, or privilege escalation. Only systems using Intel CPUs are vulnerable. Systems using AMD CPUs, and Arm systems, are not vulnerable. Only systems using nested paging (hap, aka nested paging, aka in this case Intel EPT) are vulnerable. Only HVM and PVH guests can exploit the vulnerability. The presence and scope of the vulnerability depends on the precise optimisations performed by the compiler used to build Xen. If the compiler generates (a) a single 64-bit write, or (b) a series of read-modify-write operations in the same order as the source code, the hypervisor is not vulnerable. For example, in one test build using GCC 8.3 with normal settings, the compiler generated multiple (unlocked) read-modify-write operations in source-code order, which did not constitute a vulnerability. We have not been able to survey compilers; consequently we cannot say which compiler(s) might produce vulnerable code (with which code-generation options). The source code clearly violates the C rules, and thus should be considered vulnerable.",7.8,HIGH,2,valid,2020-07-07T12:36:52Z,3
CVE-2020-15567,['CWE-362'],AV:L/AC:M/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/ept: atomically modify entries in ept_next_level

ept_next_level was passing a live PTE pointer to ept_set_middle_entry,
which was then modified without taking into account that the PTE could
be part of a live EPT table. This wasn't a security issue because the
pages returned by p2m_alloc_ptp are zeroed, so adding such an entry
before actually initializing it didn't allow a guest to access
physical memory addresses it wasn't supposed to access.

This is part of XSA-328.

Reported-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Roger Pau Monn <roger.pau@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",bc3d9f95d661372b059a5539ae6cb1e79435bb95,https://github.com/xen-project/xen/commit/bc3d9f95d661372b059a5539ae6cb1e79435bb95,xen/arch/x86/mm/p2m-ept.c,ept_next_level,"static int ept_next_level(struct p2m_domain *p2m, bool_t read_only,
ept_entry_t **table, unsigned long *gfn_remainder,
int next_level)
{
ept_entry_t *ept_entry, *next = NULL, e;
u32 shift, index;
shift = next_level * EPT_TABLE_ORDER;
index = *gfn_remainder >> shift;
ASSERT(index < EPT_PAGETABLE_ENTRIES);
ept_entry = (*table) + index;
e = atomic_read_ept_entry(ept_entry);
if ( !is_epte_present(&e) )
{
if ( e.sa_p2mt == p2m_populate_on_demand )
return GUEST_TABLE_POD_PAGE;
if ( read_only )
return GUEST_TABLE_MAP_FAILED;
next = ept_set_middle_entry(p2m, ept_entry);
if ( !next )
return GUEST_TABLE_MAP_FAILED;
}
else if ( is_epte_superpage(&e) )
return GUEST_TABLE_SUPER_PAGE;
unmap_domain_page(*table);
*table = next ?: map_domain_page(_mfn(e.mfn));
*gfn_remainder &= (1UL << shift) - 1;
return GUEST_TABLE_NORMAL_PAGE;
}","static int ept_next_level(struct p2m_domain *VAR_0, bool_t VAR_1,
ept_entry_t **VAR_2, unsigned long *VAR_3,
int VAR_4)
{
ept_entry_t *VAR_5, *VAR_6 = NULL, VAR_7;
u32 VAR_8, VAR_9;
VAR_8 = VAR_4 * VAR_10;
VAR_9 = *VAR_3 >> VAR_8;
ASSERT(VAR_9 < VAR_11);
VAR_5 = (*VAR_2) + VAR_9;
VAR_7 = atomic_read_ept_entry(VAR_5);
if ( !is_epte_present(&VAR_7) )
{
if ( VAR_7.sa_p2mt == VAR_12 )
return VAR_13;
if ( VAR_1 )
return VAR_14;
VAR_6 = ept_set_middle_entry(VAR_0, VAR_5);
if ( !VAR_6 )
return VAR_14;
}
else if ( is_epte_superpage(&VAR_7) )
return VAR_15;
unmap_domain_page(*VAR_2);
*VAR_2 = VAR_6 ?VAR_16: map_domain_page(_mfn(VAR_7.mfn));
*VAR_3 &= (1UL << VAR_8) - 1;
return VAR_17;
}",xen-project/xen/bc3d9f95d661372b059a5539ae6cb1e79435bb95/p2m-ept.c/vul/before/0.json,"static int ept_next_level(struct p2m_domain *p2m, bool_t read_only,
                          ept_entry_t **table, unsigned long *gfn_remainder,
                          int next_level)
{
    ept_entry_t *ept_entry, *next = NULL, e;
    u32 shift, index;

    ASSERT(next_level);

    shift = next_level * EPT_TABLE_ORDER;

    index = *gfn_remainder >> shift;

    /* index must be falling into the page */
    ASSERT(index < EPT_PAGETABLE_ENTRIES);

    ept_entry = (*table) + index;

    /* ept_next_level() is called (sometimes) without a lock.  Read
     * the entry once, and act on the ""cached"" entry after that to
     * avoid races. */
    e = atomic_read_ept_entry(ept_entry);

    if ( !is_epte_present(&e) )
    {
        int rc;

        if ( e.sa_p2mt == p2m_populate_on_demand )
            return GUEST_TABLE_POD_PAGE;

        if ( read_only )
            return GUEST_TABLE_MAP_FAILED;

        next = ept_set_middle_entry(p2m, &e);
        if ( !next )
            return GUEST_TABLE_MAP_FAILED;

        rc = atomic_write_ept_entry(p2m, ept_entry, e, next_level);
        ASSERT(rc == 0);
    }
    /* The only time sp would be set here is if we had hit a superpage */
    else if ( is_epte_superpage(&e) )
        return GUEST_TABLE_SUPER_PAGE;

    unmap_domain_page(*table);
    *table = next ?: map_domain_page(_mfn(e.mfn));
    *gfn_remainder &= (1UL << shift) - 1;
    return GUEST_TABLE_NORMAL_PAGE;
}","static int ept_next_level(struct p2m_domain *VAR_0, bool_t VAR_1,
                          ept_entry_t **VAR_2, unsigned long *VAR_3,
                          int VAR_4)
{
    ept_entry_t *VAR_5, *VAR_6 = NULL, VAR_7;
    u32 VAR_8, VAR_9;

    ASSERT(VAR_4);

    VAR_8 = VAR_4 * VAR_10;

    VAR_9 = *VAR_3 >> VAR_8;

    /* COMMENT_0 */
    ASSERT(VAR_9 < VAR_11);

    VAR_5 = (*VAR_2) + VAR_9;

    /* COMMENT_1 */
                                                                  
                      
    VAR_7 = atomic_read_ept_entry(VAR_5);

    if ( !is_epte_present(&VAR_7) )
    {
        int VAR_12;

        if ( VAR_7.sa_p2mt == VAR_13 )
            return VAR_14;

        if ( VAR_1 )
            return VAR_15;

        VAR_6 = ept_set_middle_entry(VAR_0, &VAR_7);
        if ( !VAR_6 )
            return VAR_15;

        VAR_12 = atomic_write_ept_entry(VAR_0, VAR_5, VAR_7, VAR_4);
        ASSERT(VAR_12 == 0);
    }
    /* COMMENT_4 */
    else if ( is_epte_superpage(&VAR_7) )
        return VAR_16;

    unmap_domain_page(*VAR_2);
    *VAR_2 = VAR_6 ?VAR_17: map_domain_page(_mfn(VAR_7.mfn));
    *VAR_3 &= (1UL << VAR_8) - 1;
    return VAR_18;
}",xen-project/xen/bc3d9f95d661372b059a5539ae6cb1e79435bb95/p2m-ept.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,6 +4,8 @@
 {
     ept_entry_t *ept_entry, *next = NULL, e;
     u32 shift, index;
+
+    ASSERT(next_level);
 
     shift = next_level * EPT_TABLE_ORDER;
 
@@ -21,16 +23,20 @@
 
     if ( !is_epte_present(&e) )
     {
+        int rc;
+
         if ( e.sa_p2mt == p2m_populate_on_demand )
             return GUEST_TABLE_POD_PAGE;
 
         if ( read_only )
             return GUEST_TABLE_MAP_FAILED;
 
-        next = ept_set_middle_entry(p2m, ept_entry);
+        next = ept_set_middle_entry(p2m, &e);
         if ( !next )
             return GUEST_TABLE_MAP_FAILED;
-        /* e is now stale and hence may not be used anymore below. */
+
+        rc = atomic_write_ept_entry(p2m, ept_entry, e, next_level);
+        ASSERT(rc == 0);
     }
     /* The only time sp would be set here is if we had hit a superpage */
     else if ( is_epte_superpage(&e) )","{'deleted_lines': ['        next = ept_set_middle_entry(p2m, ept_entry);', '        /* e is now stale and hence may not be used anymore below. */'], 'added_lines': ['', '    ASSERT(next_level);', '        int rc;', '', '        next = ept_set_middle_entry(p2m, &e);', '', '        rc = atomic_write_ept_entry(p2m, ept_entry, e, next_level);', '        ASSERT(rc == 0);']}",True,"An issue was discovered in Xen through 4.13.x, allowing Intel guest OS users to gain privileges or cause a denial of service because of non-atomic modification of a live EPT PTE. When mapping guest EPT (nested paging) tables, Xen would in some circumstances use a series of non-atomic bitfield writes. Depending on the compiler version and optimisation flags, Xen might expose a dangerous partially written PTE to the hardware, which an attacker might be able to race to exploit. A guest administrator or perhaps even an unprivileged guest user might be able to cause denial of service, data corruption, or privilege escalation. Only systems using Intel CPUs are vulnerable. Systems using AMD CPUs, and Arm systems, are not vulnerable. Only systems using nested paging (hap, aka nested paging, aka in this case Intel EPT) are vulnerable. Only HVM and PVH guests can exploit the vulnerability. The presence and scope of the vulnerability depends on the precise optimisations performed by the compiler used to build Xen. If the compiler generates (a) a single 64-bit write, or (b) a series of read-modify-write operations in the same order as the source code, the hypervisor is not vulnerable. For example, in one test build using GCC 8.3 with normal settings, the compiler generated multiple (unlocked) read-modify-write operations in source-code order, which did not constitute a vulnerability. We have not been able to survey compilers; consequently we cannot say which compiler(s) might produce vulnerable code (with which code-generation options). The source code clearly violates the C rules, and thus should be considered vulnerable.",7.8,HIGH,2,valid,2020-07-07T12:37:12Z,3
CVE-2020-24119,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0,upx,"Unpack: Phdrs must be within expansion of first compressed block

https://github.com/upx/upx/issues/388
	modified:   p_lx_elf.cpp",0016512df1df9179fbb508c8cf60699198c9ecaa,https://github.com/upx/upx/commit/0016512df1df9179fbb508c8cf60699198c9ecaa,src/p_lx_elf.cpp,PackLinuxElf64::unpack,"void PackLinuxElf64::unpack(OutputFile *fo)
{
if (e_phoff != sizeof(Elf64_Ehdr)) {        throwCantUnpack(""bad e_phoff"");
}
unsigned const c_phnum = get_te16(&ehdri.e_phnum);
upx_uint64_t old_data_off = 0;
upx_uint64_t old_data_len = 0;
upx_uint64_t old_dtinit = 0;
unsigned is_asl = 0;  
unsigned szb_info = sizeof(b_info);
{
upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);
if (e_entry < 0x401180
&&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { 
szb_info = 2*sizeof(unsigned);
}
}
fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);
fi->readx(&linfo, sizeof(linfo));
lsize = get_te16(&linfo.l_lsize);
if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {
throwCantUnpack(""l_info corrupted"");
}
p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));
unsigned orig_file_size = get_te32(&hbuf.p_filesize);
blocksize = get_te32(&hbuf.p_blocksize);
if ((u32_t)file_size > orig_file_size || blocksize > orig_file_size
|| !mem_size_valid(1, blocksize, OVERHEAD))
throwCantUnpack(""p_info corrupted"");
ibuf.alloc(blocksize + OVERHEAD);
b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));
fi->readx(&bhdr, szb_info);
ph.u_len = get_te32(&bhdr.sz_unc);
ph.c_len = get_te32(&bhdr.sz_cpr);
if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0
||  ph.u_len > orig_file_size)
throwCantUnpack(""b_info corrupted"");
ph.filter_cto = bhdr.b_cto8;
MemBuffer u(ph.u_len);
Elf64_Ehdr *const ehdr = (Elf64_Ehdr *)&u[0];
Elf64_Phdr const *phdr = 0;
if (ibuf.getSize() < ph.c_len)
throwCompressedDataViolation();
fi->readx(ibuf, ph.c_len);
decompress(ibuf, (upx_byte *)ehdr, false);
if (ehdr->e_type   !=ehdri.e_type
||  ehdr->e_machine!=ehdri.e_machine
||  ehdr->e_version!=ehdri.e_version
||  !( ehdr->e_flags==ehdri.e_flags
|| Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))
||  ehdr->e_ehsize !=ehdri.e_ehsize
||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {
throwCantUnpack(""ElfXX_Ehdr corrupted"");
}
fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);
unsigned const u_phnum = get_te16(&ehdr->e_phnum);
unsigned total_in = 0;
unsigned total_out = 0;
unsigned c_adler = upx_adler32(NULL, 0);
unsigned u_adler = upx_adler32(NULL, 0);
#define MAX_ELF_HDR 1024
if ((MAX_ELF_HDR - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {
throwCantUnpack(""bad compressed e_phnum"");
}
#undef MAX_ELF_HDR
Elf64_Phdr const *const dynhdr = elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);
bool const is_shlib = !!dynhdr;
if (is_shlib) {
unpackExtent(ph.u_len, fo, total_in, total_out,
c_adler, u_adler, false, szb_info);
fi->seek(0, SEEK_SET);
fi->readx(ibuf, get_te64(&dynhdr->p_offset) + get_te64(&dynhdr->p_filesz));
overlay_offset -= sizeof(linfo);
xct_off = overlay_offset;
e_shoff = get_te64(&ehdri.e_shoff);
ibuf.subref(""bad .e_shoff %#lx for %#lx"", e_shoff, sizeof(Elf64_Shdr) * e_shnum);
if (e_shoff && e_shnum) {             shdri = (Elf64_Shdr  *)ibuf.subref(
""bad Shdr table"", e_shoff, sizeof(Elf64_Shdr)*e_shnum);
upx_uint64_t xct_off2 = get_te64(&shdri->sh_offset);
if (e_shoff == xct_off2) {
xct_off = e_shoff;
}
dynseg = (Elf64_Dyn const *)ibuf.subref(
""bad DYNAMIC"", get_te64(&dynhdr->p_offset), get_te64(&dynhdr->p_filesz));
dynstr = (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);
sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);
if (sec_dynsym) {
upx_uint64_t const off_dynsym = get_te64(&sec_dynsym->sh_offset);
upx_uint64_t const sz_dynsym  = get_te64(&sec_dynsym->sh_size);
Elf64_Sym *const sym0 = (Elf64_Sym *)ibuf.subref(
""bad dynsym"", off_dynsym, sz_dynsym);
Elf64_Sym *sym = sym0;
for (int j = sz_dynsym / sizeof(Elf64_Sym); --j>=0; ++sym) {
upx_uint64_t symval = get_te64(&sym->st_value);
unsigned symsec = get_te16(&sym->st_shndx);
if (Elf64_Sym::SHN_UNDEF != symsec
&&  Elf64_Sym::SHN_ABS   != symsec
&&  xct_off <= symval) {
set_te64(&sym->st_value, symval - asl_delta);
}
if (Elf64_Sym::SHN_ABS == symsec && xct_off <= symval) {
adjABS(sym, 0u - asl_delta);
}
}
}
}
if (fo) {
fo->write(ibuf + ph.u_len, xct_off - ph.u_len);
}
int n_ptload = 0;
phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);
for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {
old_data_off = get_te64(&phdr->p_offset);
old_data_len = get_te64(&phdr->p_filesz);
break;
}
}
total_in  = xct_off;
total_out = xct_off;
ph.u_len = 0;
fi->seek(sizeof(linfo) + overlay_offset + sizeof(hbuf) + szb_info + ph.c_len, SEEK_SET);
phdr = (Elf64_Phdr *) (void *) (1+ ehdr);
for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
if (PT_LOAD64==get_te32(&phdr->p_type)) {
ph.u_len = get_te64(&phdr->p_filesz) - xct_off;
break;
}
}
unpackExtent(ph.u_len, fo, total_in, total_out,
c_adler, u_adler, false, szb_info);
}
else {                  bool first_PF_X = true;
phdr = (Elf64_Phdr *) (void *) (1+ ehdr);          for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
if (PT_LOAD64==get_te32(&phdr->p_type)) {
unsigned const filesz = get_te64(&phdr->p_filesz);
unsigned const offset = get_te64(&phdr->p_offset);
if (fo)
fo->seek(offset, SEEK_SET);
if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {
unpackExtent(filesz, fo, total_in, total_out,
c_adler, u_adler, first_PF_X, szb_info);
first_PF_X = false;
}
else {
unpackExtent(filesz, fo, total_in, total_out,
c_adler, u_adler, false, szb_info);
}
}
}
}
phdr = phdri;
load_va = 0;
for (unsigned j=0; j < c_phnum; ++j) {
if (PT_LOAD64==get_te32(&phdr->p_type)) {
load_va = get_te64(&phdr->p_vaddr);
break;
}
}
if (0x1000==get_te64(&phdri[0].p_filesz)      &&  0==get_te64(&phdri[1].p_offset)
&&  0==get_te64(&phdri[0].p_offset)
&&     get_te64(&phdri[1].p_filesz) == get_te64(&phdri[1].p_memsz)) {
fi->seek(up4(get_te64(&phdr[1].p_memsz)), SEEK_SET);      }
else if (is_shlib
||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +
ph.getPackHeaderSize() + sizeof(overlay_offset))
< up4(file_size)) {
funpad4(fi);          unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));
if (0==old_dtinit) {
old_dtinit = get_te32(&d_info[2 + (0==d_info[0])]);
is_asl = 1u& get_te32(&d_info[0 + (0==d_info[0])]);
}
fi->seek(lsize - sizeof(d_info), SEEK_CUR);
}
phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];
upx_uint64_t hi_offset(0);
for (unsigned j = 0; j < u_phnum; ++j) {
if (PT_LOAD64==phdr[j].p_type
&&  hi_offset < phdr[j].p_offset)
hi_offset = phdr[j].p_offset;
}
for (unsigned j = 0; j < u_phnum; ++j) {
unsigned const size = find_LOAD_gap(phdr, j, u_phnum);
if (size) {
unsigned const where = get_te64(&phdr[j].p_offset) +
get_te64(&phdr[j].p_filesz);
if (fo)
fo->seek(where, SEEK_SET);
unpackExtent(size, fo, total_in, total_out,
c_adler, u_adler, false, szb_info,
(phdr[j].p_offset != hi_offset));
}
}
fi->readx(&bhdr, szb_info);
unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);
if (sz_unc == 0) {                 unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);
if (sz_cpr != UPX_MAGIC_LE32)              throwCompressedDataViolation();
}
else {         throwCompressedDataViolation();
}
if (is_shlib) {
int n_ptload = 0;
upx_uint64_t load_off = 0;
phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];
for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {
if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {
load_off = get_te64(&phdr->p_offset);
load_va = get_te64(&phdr->p_vaddr);
fi->seek(old_data_off, SEEK_SET);
fi->readx(ibuf, old_data_len);
total_in  += old_data_len;
total_out += old_data_len;
Elf64_Phdr const *udynhdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];
for (unsigned j3= 0; j3 < u_phnum; ++j3, ++udynhdr)
if (Elf64_Phdr::PT_DYNAMIC==get_te32(&udynhdr->p_type)) {
upx_uint64_t dt_pltrelsz(0), dt_jmprel(0);
upx_uint64_t dt_relasz(0), dt_rela(0);
upx_uint64_t const dyn_len = get_te64(&udynhdr->p_filesz);
upx_uint64_t const dyn_off = get_te64(&udynhdr->p_offset);
if ((unsigned long)file_size < (dyn_len + dyn_off)) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad PT_DYNAMIC .p_filesz %#lx"", (long unsigned)dyn_len);
throwCantUnpack(msg);
}
if (dyn_off < load_off) {
continue;                      }
Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +
(dyn_off - load_off));
dynseg = dyn; invert_pt_dynamic(dynseg);
for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {
upx_uint64_t const tag = get_te64(&dyn->d_tag);
upx_uint64_t       val = get_te64(&dyn->d_val);
if (is_asl) switch (tag) {
case Elf64_Dyn::DT_RELASZ:   { dt_relasz   = val; } break;
case Elf64_Dyn::DT_RELA:     { dt_rela     = val; } break;
case Elf64_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;
case Elf64_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;
case Elf64_Dyn::DT_PLTGOT:
case Elf64_Dyn::DT_PREINIT_ARRAY:
case Elf64_Dyn::DT_INIT_ARRAY:
case Elf64_Dyn::DT_FINI_ARRAY:
case Elf64_Dyn::DT_FINI: {
set_te64(&dyn->d_val, val - asl_delta);
}; break;
}                         if (upx_dt_init == tag) {
if (Elf64_Dyn::DT_INIT == tag) {
set_te64(&dyn->d_val, old_dtinit);
if (!old_dtinit) {                                     dyn->d_tag = Elf64_Dyn::DT_NULL;
dyn->d_val = 0;
}
}
else if (Elf64_Dyn::DT_INIT_ARRAY    == tag
||       Elf64_Dyn::DT_PREINIT_ARRAY == tag) {
if (val < load_va || (long unsigned)file_size < (long unsigned)val) {
char msg[50]; snprintf(msg, sizeof(msg),
""Bad Dynamic tag %#lx %#lx"",
(long unsigned)tag, (long unsigned)val);
throwCantUnpack(msg);
}
set_te64(&ibuf[val - load_va], old_dtinit
+ (is_asl ? asl_delta : 0));                              }
}
}
if (is_asl) {
lowmem.alloc(xct_off);
fi->seek(0, SEEK_SET);
fi->read(lowmem, xct_off);                          if (dt_relasz && dt_rela) {
Elf64_Rela *const rela0 = (Elf64_Rela *)lowmem.subref(
""bad Rela offset"", dt_rela, dt_relasz);
unRela64(dt_rela, rela0, dt_relasz, ibuf, load_va, old_dtinit, fo);
}
if (dt_pltrelsz && dt_jmprel) {                             Elf64_Rela *const jmp0 = (Elf64_Rela *)lowmem.subref(
""bad Jmprel offset"", dt_jmprel, dt_pltrelsz);
unRela64(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, old_dtinit, fo);
}
}
}
if (fo) {
fo->seek(get_te64(&phdr->p_offset), SEEK_SET);
fo->rewrite(ibuf, old_data_len);
}
}
}
}
ph.c_len = total_in;
ph.u_len = total_out;
if (total_out != orig_file_size)
throwEOFException();
if (ph.c_adler != c_adler || ph.u_adler != u_adler)
throwChecksumError();
}","void PackLinuxElf64::unpack(OutputFile *VAR_0)
{
if (VAR_1 != sizeof(VAR_2)) {
throwCantUnpack(""bad e_phoff"");
}
unsigned const VAR_3 = get_te16(&VAR_4.e_phnum);
upx_uint64_t VAR_5 = 0;
upx_uint64_t VAR_6 = 0;
upx_uint64_t VAR_7 = 0;
unsigned VAR_8 = 0;  
unsigned VAR_9 = sizeof(VAR_10);
{
upx_uint64_t const VAR_11 = get_te64(&VAR_4.e_entry);
if (VAR_11 < 0x401180
&&  get_te16(&VAR_4.e_machine)==Elf64_Ehdr::EM_386) { 
VAR_9 = 2*sizeof(unsigned);
}
}
VAR_12->seek(VAR_13 - sizeof(VAR_14), VAR_15);
VAR_12->readx(&VAR_16, sizeof(VAR_16));
VAR_17 = get_te16(&VAR_16.l_lsize);
if (VAR_18 != get_le32(&VAR_16.l_magic)) {
throwCantUnpack(""l_info corrupted"");
}
p_info VAR_19;  VAR_12->readx(&VAR_19, sizeof(VAR_19));
unsigned VAR_20 = get_te32(&VAR_19.p_filesize);
VAR_21 = get_te32(&VAR_19.p_blocksize);
if ((u32_t)VAR_22 > VAR_20 || VAR_21 > VAR_20
|| !mem_size_valid(1, VAR_21, VAR_23))
throwCantUnpack(""p_info corrupted"");
VAR_24.alloc(VAR_21 + VAR_23);
b_info VAR_25; memset(&VAR_25, 0, sizeof(VAR_25));
VAR_12->readx(&VAR_25, VAR_9);
VAR_26.u_len = get_te32(&VAR_25.sz_unc);
VAR_26.c_len = get_te32(&VAR_25.sz_cpr);
if (VAR_26.c_len > (unsigned)VAR_22 || VAR_26.c_len == 0 || VAR_26.u_len == 0
||  VAR_26.u_len > VAR_20)
throwCantUnpack(""b_info corrupted"");
VAR_26.filter_cto = VAR_25.b_cto8;
MemBuffer VAR_27(VAR_26.u_len);
Elf64_Ehdr *const VAR_28 = (Elf64_Ehdr *)&VAR_27[0];
Elf64_Phdr const *VAR_29 = 0;
if (VAR_24.getSize() < VAR_26.c_len)
throwCompressedDataViolation();
VAR_12->readx(VAR_24, VAR_26.c_len);
decompress(VAR_24, (upx_byte *)VAR_28, false);
if (VAR_28->e_type   !=VAR_4.e_type
||  VAR_28->e_machine!=VAR_4.e_machine
||  VAR_28->e_version!=VAR_4.e_version
||  !( VAR_28->e_flags==VAR_4.e_flags
|| Elf64_Ehdr::EM_PPC64 == get_te16(&VAR_4.e_machine))
||  VAR_28->e_ehsize !=VAR_4.e_ehsize
||  memcmp(VAR_28->e_ident, VAR_4.e_ident, Elf64_Ehdr::EI_OSABI)) {
throwCantUnpack(""ElfXX_Ehdr corrupted"");
}
VAR_12->seek(- (VAR_30) (VAR_9 + VAR_26.c_len), VAR_31);
unsigned const VAR_32 = get_te16(&VAR_28->e_phnum);
unsigned VAR_33 = 0;
unsigned VAR_34 = 0;
unsigned VAR_35 = upx_adler32(NULL, 0);
unsigned VAR_36 = upx_adler32(NULL, 0);
#define VAR_37 1024
if ((VAR_37 - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < VAR_32) {
throwCantUnpack(""bad compressed e_phnum"");
}
#undef MAX_ELF_HDR
Elf64_Phdr const *const VAR_38 = elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, VAR_39, VAR_3);
bool const VAR_40 = !!VAR_38;
if (VAR_40) {
unpackExtent(VAR_26.u_len, VAR_0, VAR_33, VAR_34,
VAR_35, VAR_36, false, VAR_9);
VAR_12->seek(0, VAR_15);
VAR_12->readx(VAR_24, get_te64(&VAR_38->p_offset) + get_te64(&VAR_38->p_filesz));
VAR_13 -= sizeof(VAR_16);
VAR_41 = VAR_13;
VAR_42 = get_te64(&VAR_4.e_shoff);
VAR_24.subref(""bad .e_shoff %#lx for %#lx"", VAR_42, sizeof(VAR_43) * VAR_44);
if (VAR_42 && VAR_44) { 
VAR_45 = (Elf64_Shdr  *)VAR_24.subref(
""bad Shdr table"", VAR_42, sizeof(Elf64_Shdr)*VAR_44);
upx_uint64_t VAR_46 = get_te64(&VAR_45->sh_offset);
if (VAR_42 == VAR_46) {
VAR_41 = VAR_42;
}
VAR_47 = (Elf64_Dyn const *)VAR_24.subref(
""bad DYNAMIC"", get_te64(&VAR_38->p_offset), get_te64(&VAR_38->p_filesz));
VAR_48 = (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);
VAR_49 = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);
if (VAR_49) {
upx_uint64_t const VAR_50 = get_te64(&VAR_49->sh_offset);
upx_uint64_t const VAR_51  = get_te64(&VAR_49->sh_size);
Elf64_Sym *const VAR_52 = (Elf64_Sym *)VAR_24.subref(
""bad dynsym"", VAR_50, VAR_51);
Elf64_Sym *VAR_53 = VAR_52;
for (int VAR_54 = VAR_51 / sizeof(Elf64_Sym); --VAR_54>=0; ++VAR_53) {
upx_uint64_t VAR_55 = get_te64(&VAR_53->st_value);
unsigned VAR_56 = get_te16(&VAR_53->st_shndx);
if (Elf64_Sym::SHN_UNDEF != VAR_56
&&  Elf64_Sym::SHN_ABS   != VAR_56
&&  VAR_41 <= VAR_55) {
set_te64(&VAR_53->st_value, VAR_55 - VAR_57);
}
if (Elf64_Sym::SHN_ABS == VAR_56 && VAR_41 <= VAR_55) {
adjABS(VAR_53, 0u - VAR_57);
}
}
}
}
if (VAR_0) {
VAR_0->write(VAR_24 + VAR_26.u_len, VAR_41 - VAR_26.u_len);
}
int VAR_58 = 0;
VAR_29 = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)VAR_24);
for (unsigned VAR_54=0; VAR_54 < VAR_32; ++VAR_29, ++VAR_54) {
if (VAR_59==get_te32(&VAR_29->p_type) && 0!=VAR_58++) {
VAR_5 = get_te64(&VAR_29->p_offset);
VAR_6 = get_te64(&VAR_29->p_filesz);
break;
}
}
VAR_33  = VAR_41;
VAR_34 = VAR_41;
VAR_26.u_len = 0;
VAR_12->seek(sizeof(VAR_16) + VAR_13 + sizeof(VAR_19) + VAR_9 + VAR_26.c_len, VAR_15);
VAR_29 = (Elf64_Phdr *) (void *) (1+ VAR_28);
for (unsigned VAR_54=0; VAR_54 < VAR_32; ++VAR_29, ++VAR_54) {
if (VAR_59==get_te32(&VAR_29->p_type)) {
VAR_26.u_len = get_te64(&VAR_29->p_filesz) - VAR_41;
break;
}
}
unpackExtent(VAR_26.u_len, VAR_0, VAR_33, VAR_34,
VAR_35, VAR_36, false, VAR_9);
}
else {  
bool VAR_60 = true;
VAR_29 = (Elf64_Phdr *) (void *) (1+ VAR_28);  
for (unsigned VAR_54=0; VAR_54 < VAR_32; ++VAR_29, ++VAR_54) {
if (VAR_59==get_te32(&VAR_29->p_type)) {
unsigned const VAR_61 = get_te64(&VAR_29->p_filesz);
unsigned const VAR_62 = get_te64(&VAR_29->p_offset);
if (VAR_0)
VAR_0->seek(VAR_62, VAR_15);
if (Elf64_Phdr::PF_X & get_te32(&VAR_29->p_flags)) {
unpackExtent(VAR_61, VAR_0, VAR_33, VAR_34,
VAR_35, VAR_36, VAR_60, VAR_9);
VAR_60 = false;
}
else {
unpackExtent(VAR_61, VAR_0, VAR_33, VAR_34,
VAR_35, VAR_36, false, VAR_9);
}
}
}
}
VAR_29 = VAR_39;
VAR_63 = 0;
for (unsigned VAR_54=0; VAR_54 < VAR_3; ++VAR_54) {
if (VAR_59==get_te32(&VAR_29->p_type)) {
VAR_63 = get_te64(&VAR_29->p_vaddr);
break;
}
}
if (0x1000==get_te64(&VAR_39[0].p_filesz)  
&&  0==get_te64(&VAR_39[1].p_offset)
&&  0==get_te64(&VAR_39[0].p_offset)
&&     get_te64(&VAR_39[1].p_filesz) == get_te64(&VAR_39[1].p_memsz)) {
VAR_12->seek(up4(get_te64(&VAR_29[1].p_memsz)), VAR_15);  
}
else if (VAR_40
||  ((unsigned)(get_te64(&VAR_4.e_entry) - VAR_63) + up4(VAR_17) +
VAR_26.getPackHeaderSize() + sizeof(VAR_13))
< up4(VAR_22)) {
funpad4(VAR_12);  
unsigned VAR_64[6]; VAR_12->readx(VAR_64, sizeof(VAR_64));
if (0==VAR_7) {
VAR_7 = get_te32(&VAR_64[2 + (0==VAR_64[0])]);
VAR_8 = 1u& get_te32(&VAR_64[0 + (0==VAR_64[0])]);
}
VAR_12->seek(VAR_17 - sizeof(VAR_64), VAR_31);
}
VAR_29 = (Elf64_Phdr *)&VAR_27[sizeof(*VAR_28)];
upx_uint64_t VAR_65(0);
for (unsigned VAR_54 = 0; VAR_54 < VAR_32; ++VAR_54) {
if (VAR_59==VAR_29[VAR_54].p_type
&&  VAR_65 < VAR_29[VAR_54].p_offset)
VAR_65 = VAR_29[VAR_54].p_offset;
}
for (unsigned VAR_54 = 0; VAR_54 < VAR_32; ++VAR_54) {
unsigned const VAR_66 = find_LOAD_gap(VAR_29, VAR_54, VAR_32);
if (VAR_66) {
unsigned const VAR_67 = get_te64(&VAR_29[VAR_54].p_offset) +
get_te64(&VAR_29[VAR_54].p_filesz);
if (VAR_0)
VAR_0->seek(VAR_67, VAR_15);
unpackExtent(VAR_66, VAR_0, VAR_33, VAR_34,
VAR_35, VAR_36, false, VAR_9,
(VAR_29[VAR_54].p_offset != VAR_65));
}
}
VAR_12->readx(&VAR_25, VAR_9);
unsigned const VAR_68 = VAR_26.u_len = get_te32(&VAR_25.sz_unc);
if (VAR_68 == 0) { 
unsigned const VAR_69 = get_le32(&VAR_25.sz_cpr);
if (VAR_69 != VAR_18)  
throwCompressedDataViolation();
}
else { 
throwCompressedDataViolation();
}
if (VAR_40) {
int VAR_58 = 0;
upx_uint64_t VAR_70 = 0;
VAR_29 = (Elf64_Phdr *)&VAR_27[sizeof(*VAR_28)];
for (unsigned VAR_54= 0; VAR_54 < VAR_32; ++VAR_54, ++VAR_29) {
if (VAR_59==get_te32(&VAR_29->p_type) && 0!=VAR_58++) {
VAR_70 = get_te64(&VAR_29->p_offset);
VAR_63 = get_te64(&VAR_29->p_vaddr);
VAR_12->seek(VAR_5, VAR_15);
VAR_12->readx(VAR_24, VAR_6);
VAR_33  += VAR_6;
VAR_34 += VAR_6;
Elf64_Phdr const *VAR_71 = (Elf64_Phdr *)&VAR_27[sizeof(*VAR_28)];
for (unsigned VAR_72= 0; VAR_72 < VAR_32; ++VAR_72, ++VAR_71)
if (Elf64_Phdr::PT_DYNAMIC==get_te32(&VAR_71->p_type)) {
upx_uint64_t VAR_73(0), VAR_74(0);
upx_uint64_t VAR_75(0), VAR_76(0);
upx_uint64_t const VAR_77 = get_te64(&VAR_71->p_filesz);
upx_uint64_t const VAR_78 = get_te64(&VAR_71->p_offset);
if ((unsigned long)VAR_22 < (VAR_77 + VAR_78)) {
char VAR_79[50]; snprintf(VAR_79, sizeof(VAR_79),
""bad PT_DYNAMIC .p_filesz %#lx"", (long unsigned)VAR_77);
throwCantUnpack(VAR_79);
}
if (VAR_78 < VAR_70) {
continue;  
}
Elf64_Dyn *VAR_80 = (Elf64_Dyn *)((unsigned char *)VAR_24 +
(VAR_78 - VAR_70));
VAR_47 = VAR_80; invert_pt_dynamic(VAR_47);
for (unsigned VAR_81= 0; VAR_81 < VAR_77; ++VAR_80, VAR_81 += sizeof(*VAR_80)) {
upx_uint64_t const VAR_82 = get_te64(&VAR_80->d_tag);
upx_uint64_t       VAR_83 = get_te64(&VAR_80->d_val);
if (VAR_8) switch (VAR_82) {
case Elf64_Dyn::DT_RELASZ:   { VAR_75   = VAR_83; } break;
case Elf64_Dyn::DT_RELA:     { VAR_76     = VAR_83; } break;
case Elf64_Dyn::DT_PLTRELSZ: { VAR_73 = VAR_83; } break;
case Elf64_Dyn::DT_JMPREL:   { VAR_74   = VAR_83; } break;
case Elf64_Dyn::DT_PLTGOT:
case Elf64_Dyn::DT_PREINIT_ARRAY:
case Elf64_Dyn::DT_INIT_ARRAY:
case Elf64_Dyn::DT_FINI_ARRAY:
case Elf64_Dyn::DT_FINI: {
set_te64(&VAR_80->d_val, VAR_83 - VAR_57);
}; break;
} 
if (VAR_84 == VAR_82) {
if (Elf64_Dyn::DT_INIT == VAR_82) {
set_te64(&VAR_80->d_val, VAR_7);
if (!VAR_7) { 
VAR_80->d_tag = Elf64_Dyn::DT_NULL;
VAR_80->d_val = 0;
}
}
else if (Elf64_Dyn::DT_INIT_ARRAY    == VAR_82
||       Elf64_Dyn::DT_PREINIT_ARRAY == VAR_82) {
if (VAR_83 < VAR_63 || (long unsigned)VAR_22 < (long unsigned)VAR_83) {
char VAR_79[50]; snprintf(VAR_79, sizeof(VAR_79),
""Bad Dynamic tag %#lx %#lx"",
(long unsigned)VAR_82, (long unsigned)VAR_83);
throwCantUnpack(VAR_79);
}
set_te64(&VAR_24[VAR_83 - VAR_63], VAR_7
+ (VAR_8 ? VAR_57 : 0));  
}
}
}
if (VAR_8) {
VAR_85.alloc(VAR_41);
VAR_12->seek(0, VAR_15);
VAR_12->read(VAR_85, VAR_41);  
if (VAR_75 && VAR_76) {
Elf64_Rela *const VAR_86 = (Elf64_Rela *)VAR_85.subref(
""bad Rela offset"", VAR_76, VAR_75);
unRela64(VAR_76, VAR_86, VAR_75, VAR_24, VAR_63, VAR_7, VAR_0);
}
if (VAR_73 && VAR_74) { 
Elf64_Rela *const VAR_87 = (Elf64_Rela *)VAR_85.subref(
""bad Jmprel offset"", VAR_74, VAR_73);
unRela64(VAR_74, VAR_87, VAR_73, VAR_24, VAR_63, VAR_7, VAR_0);
}
}
}
if (VAR_0) {
VAR_0->seek(get_te64(&VAR_29->p_offset), VAR_15);
VAR_0->rewrite(VAR_24, VAR_6);
}
}
}
}
VAR_26.c_len = VAR_33;
VAR_26.u_len = VAR_34;
if (VAR_34 != VAR_20)
throwEOFException();
if (VAR_26.c_adler != VAR_35 || VAR_26.u_adler != VAR_36)
throwChecksumError();
}",upx/0016512df1df9179fbb508c8cf60699198c9ecaa/p_lx_elf.cpp/vul/before/0.json,"void PackLinuxElf64::unpack(OutputFile *fo)
{
    if (e_phoff != sizeof(Elf64_Ehdr)) {// Phdrs not contiguous with Ehdr
        throwCantUnpack(""bad e_phoff"");
    }
    unsigned const c_phnum = get_te16(&ehdri.e_phnum);
    upx_uint64_t old_data_off = 0;
    upx_uint64_t old_data_len = 0;
    upx_uint64_t old_dtinit = 0;
    unsigned is_asl = 0;  // is Android Shared Library

    unsigned szb_info = sizeof(b_info);
    {
        upx_uint64_t const e_entry = get_te64(&ehdri.e_entry);
        if (e_entry < 0x401180
        &&  get_te16(&ehdri.e_machine)==Elf64_Ehdr::EM_386) { /* old style, 8-byte b_info */
            szb_info = 2*sizeof(unsigned);
        }
    }

    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);
    fi->readx(&linfo, sizeof(linfo));
    lsize = get_te16(&linfo.l_lsize);
    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {
        throwCantUnpack(""l_info corrupted"");
    }
    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));
    unsigned orig_file_size = get_te32(&hbuf.p_filesize);
    blocksize = get_te32(&hbuf.p_blocksize);
    if ((u32_t)file_size > orig_file_size || blocksize > orig_file_size
        || !mem_size_valid(1, blocksize, OVERHEAD))
        throwCantUnpack(""p_info corrupted"");

    ibuf.alloc(blocksize + OVERHEAD);
    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));
    fi->readx(&bhdr, szb_info);
    ph.u_len = get_te32(&bhdr.sz_unc);
    ph.c_len = get_te32(&bhdr.sz_cpr);
    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0
    ||  ph.u_len > orig_file_size)
        throwCantUnpack(""b_info corrupted"");
    ph.filter_cto = bhdr.b_cto8;

    MemBuffer u(ph.u_len);
    Elf64_Ehdr *const ehdr = (Elf64_Ehdr *)&u[0];
    Elf64_Phdr const *phdr = 0;

    // Uncompress Ehdr and Phdrs.
    if (ibuf.getSize() < ph.c_len)
        throwCompressedDataViolation();
    fi->readx(ibuf, ph.c_len);
    decompress(ibuf, (upx_byte *)ehdr, false);
    if (ehdr->e_type   !=ehdri.e_type
    ||  ehdr->e_machine!=ehdri.e_machine
    ||  ehdr->e_version!=ehdri.e_version
        // less strict for EM_PPC64 to workaround earlier bug
    ||  !( ehdr->e_flags==ehdri.e_flags
        || Elf64_Ehdr::EM_PPC64 == get_te16(&ehdri.e_machine))
    ||  ehdr->e_ehsize !=ehdri.e_ehsize
        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION
    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf64_Ehdr::EI_OSABI)) {
        throwCantUnpack(""ElfXX_Ehdr corrupted"");
    }
    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);

    unsigned const u_phnum = get_te16(&ehdr->e_phnum);
    unsigned total_in = 0;
    unsigned total_out = 0;
    unsigned c_adler = upx_adler32(NULL, 0);
    unsigned u_adler = upx_adler32(NULL, 0);
#define MAX_ELF_HDR 1024
    if ((umin64(MAX_ELF_HDR, ph.u_len) - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {
        throwCantUnpack(""bad compressed e_phnum"");
    }
#undef MAX_ELF_HDR

    // Packed ET_EXE has no PT_DYNAMIC.
    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.
    Elf64_Phdr const *const dynhdr = elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, phdri, c_phnum);
    bool const is_shlib = !!dynhdr;
    if (is_shlib) {
        // Unpack and output the Ehdr and Phdrs for real.
        // This depends on position within input file fi.
        unpackExtent(ph.u_len, fo, total_in, total_out,
            c_adler, u_adler, false, szb_info);

        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)
        fi->seek(0, SEEK_SET);
        fi->readx(ibuf, get_te64(&dynhdr->p_offset) + get_te64(&dynhdr->p_filesz));
        overlay_offset -= sizeof(linfo);
        xct_off = overlay_offset;
        e_shoff = get_te64(&ehdri.e_shoff);
        ibuf.subref(""bad .e_shoff %#lx for %#lx"", e_shoff, sizeof(Elf64_Shdr) * e_shnum);
        if (e_shoff && e_shnum) { // --android-shlib
            shdri = (Elf64_Shdr /*const*/ *)ibuf.subref(
                ""bad Shdr table"", e_shoff, sizeof(Elf64_Shdr)*e_shnum);
            upx_uint64_t xct_off2 = get_te64(&shdri->sh_offset);
            if (e_shoff == xct_off2) {
                xct_off = e_shoff;
            }
            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off
            dynseg = (Elf64_Dyn const *)ibuf.subref(
                ""bad DYNAMIC"", get_te64(&dynhdr->p_offset), get_te64(&dynhdr->p_filesz));
            dynstr = (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);
            sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);
            if (sec_dynsym) {
                upx_uint64_t const off_dynsym = get_te64(&sec_dynsym->sh_offset);
                upx_uint64_t const sz_dynsym  = get_te64(&sec_dynsym->sh_size);
                Elf64_Sym *const sym0 = (Elf64_Sym *)ibuf.subref(
                    ""bad dynsym"", off_dynsym, sz_dynsym);
                Elf64_Sym *sym = sym0;
                for (int j = sz_dynsym / sizeof(Elf64_Sym); --j>=0; ++sym) {
                    upx_uint64_t symval = get_te64(&sym->st_value);
                    unsigned symsec = get_te16(&sym->st_shndx);
                    if (Elf64_Sym::SHN_UNDEF != symsec
                    &&  Elf64_Sym::SHN_ABS   != symsec
                    &&  xct_off <= symval) {
                        set_te64(&sym->st_value, symval - asl_delta);
                    }
                    if (Elf64_Sym::SHN_ABS == symsec && xct_off <= symval) {
                        adjABS(sym, 0u - asl_delta);
                    }
                }
            }
        }
        if (fo) {
            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);
        }
        // Search the Phdrs of compressed
        int n_ptload = 0;
        phdr = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)ibuf);
        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {
                old_data_off = get_te64(&phdr->p_offset);
                old_data_len = get_te64(&phdr->p_filesz);
                break;
            }
        }

        total_in  = xct_off;
        total_out = xct_off;
        ph.u_len = 0;
        // Position the input for next unpackExtent.
        fi->seek(sizeof(linfo) + overlay_offset + sizeof(hbuf) + szb_info + ph.c_len, SEEK_SET);

        // Decompress and unfilter the tail of first PT_LOAD.
        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);
        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
            if (PT_LOAD64==get_te32(&phdr->p_type)) {
                ph.u_len = get_te64(&phdr->p_filesz) - xct_off;
                break;
            }
        }
        unpackExtent(ph.u_len, fo, total_in, total_out,
            c_adler, u_adler, false, szb_info);
    }
    else {  // main executable
        // Decompress each PT_LOAD.
        bool first_PF_X = true;
        phdr = (Elf64_Phdr *) (void *) (1+ ehdr);  // uncompressed
        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
            if (PT_LOAD64==get_te32(&phdr->p_type)) {
                unsigned const filesz = get_te64(&phdr->p_filesz);
                unsigned const offset = get_te64(&phdr->p_offset);
                if (fo)
                    fo->seek(offset, SEEK_SET);
                if (Elf64_Phdr::PF_X & get_te32(&phdr->p_flags)) {
                    unpackExtent(filesz, fo, total_in, total_out,
                        c_adler, u_adler, first_PF_X, szb_info);
                    first_PF_X = false;
                }
                else {
                    unpackExtent(filesz, fo, total_in, total_out,
                        c_adler, u_adler, false, szb_info);
                }
            }
        }
    }
    phdr = phdri;
    load_va = 0;
    for (unsigned j=0; j < c_phnum; ++j) {
        if (PT_LOAD64==get_te32(&phdr->p_type)) {
            load_va = get_te64(&phdr->p_vaddr);
            break;
        }
    }
    if (0x1000==get_te64(&phdri[0].p_filesz)  // detect C_BASE style
    &&  0==get_te64(&phdri[1].p_offset)
    &&  0==get_te64(&phdri[0].p_offset)
    &&     get_te64(&phdri[1].p_filesz) == get_te64(&phdri[1].p_memsz)) {
        fi->seek(up4(get_te64(&phdr[1].p_memsz)), SEEK_SET);  // past the loader
    }
    else if (is_shlib
    ||  ((unsigned)(get_te64(&ehdri.e_entry) - load_va) + up4(lsize) +
                ph.getPackHeaderSize() + sizeof(overlay_offset))
            < up4(file_size)) {
        // Loader is not at end; skip past it.
        funpad4(fi);  // MATCH01
        unsigned d_info[6]; fi->readx(d_info, sizeof(d_info));
        if (0==old_dtinit) {
            old_dtinit = get_te32(&d_info[2 + (0==d_info[0])]);
            is_asl = 1u& get_te32(&d_info[0 + (0==d_info[0])]);
        }
        fi->seek(lsize - sizeof(d_info), SEEK_CUR);
    }

    // The gaps between PT_LOAD and after last PT_LOAD
    phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];
    upx_uint64_t hi_offset(0);
    for (unsigned j = 0; j < u_phnum; ++j) {
        if (PT_LOAD64==phdr[j].p_type
        &&  hi_offset < phdr[j].p_offset)
            hi_offset = phdr[j].p_offset;
    }
    for (unsigned j = 0; j < u_phnum; ++j) {
        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);
        if (size) {
            unsigned const where = get_te64(&phdr[j].p_offset) +
                                   get_te64(&phdr[j].p_filesz);
            if (fo)
                fo->seek(where, SEEK_SET);
            unpackExtent(size, fo, total_in, total_out,
                c_adler, u_adler, false, szb_info,
                (phdr[j].p_offset != hi_offset));
        }
    }

    // check for end-of-file
    fi->readx(&bhdr, szb_info);
    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);

    if (sz_unc == 0) { // uncompressed size 0 -> EOF
        // note: magic is always stored le32
        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);
        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic
            throwCompressedDataViolation();
    }
    else { // extra bytes after end?
        throwCompressedDataViolation();
    }

    if (is_shlib) {
        // DT_INIT must be restored.
        // If android_shlib, then the asl_delta relocations must be un-done.
        int n_ptload = 0;
        upx_uint64_t load_off = 0;
        phdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];
        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {
            if (PT_LOAD64==get_te32(&phdr->p_type) && 0!=n_ptload++) {
                load_off = get_te64(&phdr->p_offset);
                load_va = get_te64(&phdr->p_vaddr);
                fi->seek(old_data_off, SEEK_SET);
                fi->readx(ibuf, old_data_len);
                total_in  += old_data_len;
                total_out += old_data_len;

                Elf64_Phdr const *udynhdr = (Elf64_Phdr *)&u[sizeof(*ehdr)];
                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++udynhdr)
                if (Elf64_Phdr::PT_DYNAMIC==get_te32(&udynhdr->p_type)) {
                    upx_uint64_t dt_pltrelsz(0), dt_jmprel(0);
                    upx_uint64_t dt_relasz(0), dt_rela(0);
                    upx_uint64_t const dyn_len = get_te64(&udynhdr->p_filesz);
                    upx_uint64_t const dyn_off = get_te64(&udynhdr->p_offset);
                    if ((unsigned long)file_size < (dyn_len + dyn_off)) {
                        char msg[50]; snprintf(msg, sizeof(msg),
                                ""bad PT_DYNAMIC .p_filesz %#lx"", (long unsigned)dyn_len);
                        throwCantUnpack(msg);
                    }
                    if (dyn_off < load_off) {
                        continue;  // Oops.  Not really is_shlib ?  [built by 'rust' ?]
                    }
                    Elf64_Dyn *dyn = (Elf64_Dyn *)((unsigned char *)ibuf +
                        (dyn_off - load_off));
                    dynseg = dyn; invert_pt_dynamic(dynseg);
                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {
                        upx_uint64_t const tag = get_te64(&dyn->d_tag);
                        upx_uint64_t       val = get_te64(&dyn->d_val);
                        if (is_asl) switch (tag) {
                        case Elf64_Dyn::DT_RELASZ:   { dt_relasz   = val; } break;
                        case Elf64_Dyn::DT_RELA:     { dt_rela     = val; } break;
                        case Elf64_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;
                        case Elf64_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;

                        case Elf64_Dyn::DT_PLTGOT:
                        case Elf64_Dyn::DT_PREINIT_ARRAY:
                        case Elf64_Dyn::DT_INIT_ARRAY:
                        case Elf64_Dyn::DT_FINI_ARRAY:
                        case Elf64_Dyn::DT_FINI: {
                            set_te64(&dyn->d_val, val - asl_delta);
                        }; break;
                        } // end switch()
                        if (upx_dt_init == tag) {
                            if (Elf64_Dyn::DT_INIT == tag) {
                                set_te64(&dyn->d_val, old_dtinit);
                                if (!old_dtinit) { // compressor took the slot
                                    dyn->d_tag = Elf64_Dyn::DT_NULL;
                                    dyn->d_val = 0;
                                }
                            }
                            else if (Elf64_Dyn::DT_INIT_ARRAY    == tag
                            ||       Elf64_Dyn::DT_PREINIT_ARRAY == tag) {
                                if (val < load_va || (long unsigned)file_size < (long unsigned)val) {
                                    char msg[50]; snprintf(msg, sizeof(msg),
                                            ""Bad Dynamic tag %#lx %#lx"",
                                            (long unsigned)tag, (long unsigned)val);
                                    throwCantUnpack(msg);
                                }
                                set_te64(&ibuf[val - load_va], old_dtinit
                                    + (is_asl ? asl_delta : 0));  // counter-act unRel64
                            }
                        }
                        // Modified DT_*.d_val are re-written later from ibuf[]
                    }
                    if (is_asl) {
                        lowmem.alloc(xct_off);
                        fi->seek(0, SEEK_SET);
                        fi->read(lowmem, xct_off);  // contains relocation tables
                        if (dt_relasz && dt_rela) {
                            Elf64_Rela *const rela0 = (Elf64_Rela *)lowmem.subref(
                                ""bad Rela offset"", dt_rela, dt_relasz);
                            unRela64(dt_rela, rela0, dt_relasz, ibuf, load_va, old_dtinit, fo);
                        }
                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?
                            Elf64_Rela *const jmp0 = (Elf64_Rela *)lowmem.subref(
                                ""bad Jmprel offset"", dt_jmprel, dt_pltrelsz);
                            unRela64(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, old_dtinit, fo);
                        }
                        // Modified relocation tables are re-written by unRela64
                    }
                }
                if (fo) {
                    fo->seek(get_te64(&phdr->p_offset), SEEK_SET);
                    fo->rewrite(ibuf, old_data_len);
                }
            }
        }
    }

    // update header with totals
    ph.c_len = total_in;
    ph.u_len = total_out;

    // all bytes must be written
    if (total_out != orig_file_size)
        throwEOFException();

    // finally test the checksums
    if (ph.c_adler != c_adler || ph.u_adler != u_adler)
        throwChecksumError();
}","void PackLinuxElf64::unpack(OutputFile *VAR_0)
{
    if (VAR_1 != sizeof(VAR_2)) {/* COMMENT_0 */
        throwCantUnpack(""bad e_phoff"");
    }
    unsigned const VAR_3 = get_te16(&VAR_4.e_phnum);
    upx_uint64_t VAR_5 = 0;
    upx_uint64_t VAR_6 = 0;
    upx_uint64_t VAR_7 = 0;
    unsigned VAR_8 = 0;  /* COMMENT_1 */

    unsigned VAR_9 = sizeof(VAR_10);
    {
        upx_uint64_t const VAR_11 = get_te64(&VAR_4.e_entry);
        if (VAR_11 < 0x401180
        &&  get_te16(&VAR_4.e_machine)==Elf64_Ehdr::EM_386) { /* COMMENT_2 */
            VAR_9 = 2*sizeof(unsigned);
        }
    }

    VAR_12->seek(VAR_13 - sizeof(VAR_14), VAR_15);
    VAR_12->readx(&VAR_16, sizeof(VAR_16));
    VAR_17 = get_te16(&VAR_16.l_lsize);
    if (VAR_18 != get_le32(&VAR_16.l_magic)) {
        throwCantUnpack(""l_info corrupted"");
    }
    p_info VAR_19;  VAR_12->readx(&VAR_19, sizeof(VAR_19));
    unsigned VAR_20 = get_te32(&VAR_19.p_filesize);
    VAR_21 = get_te32(&VAR_19.p_blocksize);
    if ((u32_t)VAR_22 > VAR_20 || VAR_21 > VAR_20
        || !mem_size_valid(1, VAR_21, VAR_23))
        throwCantUnpack(""p_info corrupted"");

    VAR_24.alloc(VAR_21 + VAR_23);
    b_info VAR_25; memset(&VAR_25, 0, sizeof(VAR_25));
    VAR_12->readx(&VAR_25, VAR_9);
    VAR_26.u_len = get_te32(&VAR_25.sz_unc);
    VAR_26.c_len = get_te32(&VAR_25.sz_cpr);
    if (VAR_26.c_len > (unsigned)VAR_22 || VAR_26.c_len == 0 || VAR_26.u_len == 0
    ||  VAR_26.u_len > VAR_20)
        throwCantUnpack(""b_info corrupted"");
    VAR_26.filter_cto = VAR_25.b_cto8;

    MemBuffer VAR_27(VAR_26.u_len);
    Elf64_Ehdr *const VAR_28 = (Elf64_Ehdr *)&VAR_27[0];
    Elf64_Phdr const *VAR_29 = 0;

    /* COMMENT_3 */
    if (VAR_24.getSize() < VAR_26.c_len)
        throwCompressedDataViolation();
    VAR_12->readx(VAR_24, VAR_26.c_len);
    decompress(VAR_24, (upx_byte *)VAR_28, false);
    if (VAR_28->e_type   !=VAR_4.e_type
    ||  VAR_28->e_machine!=VAR_4.e_machine
    ||  VAR_28->e_version!=VAR_4.e_version
        /* COMMENT_4 */
    ||  !( VAR_28->e_flags==VAR_4.e_flags
        || Elf64_Ehdr::EM_PPC64 == get_te16(&VAR_4.e_machine))
    ||  VAR_28->e_ehsize !=VAR_4.e_ehsize
        /* COMMENT_5 */
    ||  memcmp(VAR_28->e_ident, VAR_4.e_ident, Elf64_Ehdr::EI_OSABI)) {
        throwCantUnpack(""ElfXX_Ehdr corrupted"");
    }
    VAR_12->seek(- (VAR_30) (VAR_9 + VAR_26.c_len), VAR_31);

    unsigned const VAR_32 = get_te16(&VAR_28->e_phnum);
    unsigned VAR_33 = 0;
    unsigned VAR_34 = 0;
    unsigned VAR_35 = upx_adler32(NULL, 0);
    unsigned VAR_36 = upx_adler32(NULL, 0);
#define VAR_37 1024
    if ((umin64(VAR_37, VAR_26.u_len) - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < VAR_32) {
        throwCantUnpack(""bad compressed e_phnum"");
    }
#undef MAX_ELF_HDR

    /* COMMENT_6 */
    /* COMMENT_7 */
    Elf64_Phdr const *const VAR_38 = elf_find_ptype(Elf64_Phdr::PT_DYNAMIC, VAR_39, VAR_3);
    bool const VAR_40 = !!VAR_38;
    if (VAR_40) {
        /* COMMENT_8 */
        /* COMMENT_9 */
        unpackExtent(VAR_26.u_len, VAR_0, VAR_33, VAR_34,
            VAR_35, VAR_36, false, VAR_9);

        /* COMMENT_10 */
        VAR_12->seek(0, VAR_15);
        VAR_12->readx(VAR_24, get_te64(&VAR_38->p_offset) + get_te64(&VAR_38->p_filesz));
        VAR_13 -= sizeof(VAR_16);
        VAR_41 = VAR_13;
        VAR_42 = get_te64(&VAR_4.e_shoff);
        VAR_24.subref(""bad .e_shoff %#lx for %#lx"", VAR_42, sizeof(VAR_43) * VAR_44);
        if (VAR_42 && VAR_44) { /* COMMENT_11 */
            VAR_45 = (Elf64_Shdr /* COMMENT_12 */ *)VAR_24.subref(
                ""bad Shdr table"", VAR_42, sizeof(Elf64_Shdr)*VAR_44);
            upx_uint64_t VAR_46 = get_te64(&VAR_45->sh_offset);
            if (VAR_42 == VAR_46) {
                VAR_41 = VAR_42;
            }
            /* COMMENT_13 */
            VAR_47 = (Elf64_Dyn const *)VAR_24.subref(
                ""bad DYNAMIC"", get_te64(&VAR_38->p_offset), get_te64(&VAR_38->p_filesz));
            VAR_48 = (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);
            VAR_49 = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);
            if (VAR_49) {
                upx_uint64_t const VAR_50 = get_te64(&VAR_49->sh_offset);
                upx_uint64_t const VAR_51  = get_te64(&VAR_49->sh_size);
                Elf64_Sym *const VAR_52 = (Elf64_Sym *)VAR_24.subref(
                    ""bad dynsym"", VAR_50, VAR_51);
                Elf64_Sym *VAR_53 = VAR_52;
                for (int VAR_54 = VAR_51 / sizeof(Elf64_Sym); --VAR_54>=0; ++VAR_53) {
                    upx_uint64_t VAR_55 = get_te64(&VAR_53->st_value);
                    unsigned VAR_56 = get_te16(&VAR_53->st_shndx);
                    if (Elf64_Sym::SHN_UNDEF != VAR_56
                    &&  Elf64_Sym::SHN_ABS   != VAR_56
                    &&  VAR_41 <= VAR_55) {
                        set_te64(&VAR_53->st_value, VAR_55 - VAR_57);
                    }
                    if (Elf64_Sym::SHN_ABS == VAR_56 && VAR_41 <= VAR_55) {
                        adjABS(VAR_53, 0u - VAR_57);
                    }
                }
            }
        }
        if (VAR_0) {
            VAR_0->write(VAR_24 + VAR_26.u_len, VAR_41 - VAR_26.u_len);
        }
        /* COMMENT_14 */
        int VAR_58 = 0;
        VAR_29 = (Elf64_Phdr *) (void *) (1+ (Elf64_Ehdr *)(unsigned char *)VAR_24);
        for (unsigned VAR_54=0; VAR_54 < VAR_32; ++VAR_29, ++VAR_54) {
            if (VAR_59==get_te32(&VAR_29->p_type) && 0!=VAR_58++) {
                VAR_5 = get_te64(&VAR_29->p_offset);
                VAR_6 = get_te64(&VAR_29->p_filesz);
                break;
            }
        }

        VAR_33  = VAR_41;
        VAR_34 = VAR_41;
        VAR_26.u_len = 0;
        /* COMMENT_15 */
        VAR_12->seek(sizeof(VAR_16) + VAR_13 + sizeof(VAR_19) + VAR_9 + VAR_26.c_len, VAR_15);

        /* COMMENT_16 */
        VAR_29 = (Elf64_Phdr *) (void *) (1+ VAR_28);
        for (unsigned VAR_54=0; VAR_54 < VAR_32; ++VAR_29, ++VAR_54) {
            if (VAR_59==get_te32(&VAR_29->p_type)) {
                VAR_26.u_len = get_te64(&VAR_29->p_filesz) - VAR_41;
                break;
            }
        }
        unpackExtent(VAR_26.u_len, VAR_0, VAR_33, VAR_34,
            VAR_35, VAR_36, false, VAR_9);
    }
    else {  /* COMMENT_17 */
        /* COMMENT_18 */
        bool VAR_60 = true;
        VAR_29 = (Elf64_Phdr *) (void *) (1+ VAR_28);  /* COMMENT_19 */
        for (unsigned VAR_54=0; VAR_54 < VAR_32; ++VAR_29, ++VAR_54) {
            if (VAR_59==get_te32(&VAR_29->p_type)) {
                unsigned const VAR_61 = get_te64(&VAR_29->p_filesz);
                unsigned const VAR_62 = get_te64(&VAR_29->p_offset);
                if (VAR_0)
                    VAR_0->seek(VAR_62, VAR_15);
                if (Elf64_Phdr::PF_X & get_te32(&VAR_29->p_flags)) {
                    unpackExtent(VAR_61, VAR_0, VAR_33, VAR_34,
                        VAR_35, VAR_36, VAR_60, VAR_9);
                    VAR_60 = false;
                }
                else {
                    unpackExtent(VAR_61, VAR_0, VAR_33, VAR_34,
                        VAR_35, VAR_36, false, VAR_9);
                }
            }
        }
    }
    VAR_29 = VAR_39;
    VAR_63 = 0;
    for (unsigned VAR_54=0; VAR_54 < VAR_3; ++VAR_54) {
        if (VAR_59==get_te32(&VAR_29->p_type)) {
            VAR_63 = get_te64(&VAR_29->p_vaddr);
            break;
        }
    }
    if (0x1000==get_te64(&VAR_39[0].p_filesz)  /* COMMENT_20 */
    &&  0==get_te64(&VAR_39[1].p_offset)
    &&  0==get_te64(&VAR_39[0].p_offset)
    &&     get_te64(&VAR_39[1].p_filesz) == get_te64(&VAR_39[1].p_memsz)) {
        VAR_12->seek(up4(get_te64(&VAR_29[1].p_memsz)), VAR_15);  /* COMMENT_21 */
    }
    else if (VAR_40
    ||  ((unsigned)(get_te64(&VAR_4.e_entry) - VAR_63) + up4(VAR_17) +
                VAR_26.getPackHeaderSize() + sizeof(VAR_13))
            < up4(VAR_22)) {
        /* COMMENT_22 */
        funpad4(VAR_12);  /* COMMENT_23 */
        unsigned VAR_64[6]; VAR_12->readx(VAR_64, sizeof(VAR_64));
        if (0==VAR_7) {
            VAR_7 = get_te32(&VAR_64[2 + (0==VAR_64[0])]);
            VAR_8 = 1u& get_te32(&VAR_64[0 + (0==VAR_64[0])]);
        }
        VAR_12->seek(VAR_17 - sizeof(VAR_64), VAR_31);
    }

    /* COMMENT_24 */
    VAR_29 = (Elf64_Phdr *)&VAR_27[sizeof(*VAR_28)];
    upx_uint64_t VAR_65(0);
    for (unsigned VAR_54 = 0; VAR_54 < VAR_32; ++VAR_54) {
        if (VAR_59==VAR_29[VAR_54].p_type
        &&  VAR_65 < VAR_29[VAR_54].p_offset)
            VAR_65 = VAR_29[VAR_54].p_offset;
    }
    for (unsigned VAR_54 = 0; VAR_54 < VAR_32; ++VAR_54) {
        unsigned const VAR_66 = find_LOAD_gap(VAR_29, VAR_54, VAR_32);
        if (VAR_66) {
            unsigned const VAR_67 = get_te64(&VAR_29[VAR_54].p_offset) +
                                   get_te64(&VAR_29[VAR_54].p_filesz);
            if (VAR_0)
                VAR_0->seek(VAR_67, VAR_15);
            unpackExtent(VAR_66, VAR_0, VAR_33, VAR_34,
                VAR_35, VAR_36, false, VAR_9,
                (VAR_29[VAR_54].p_offset != VAR_65));
        }
    }

    /* COMMENT_25 */
    VAR_12->readx(&VAR_25, VAR_9);
    unsigned const VAR_68 = VAR_26.u_len = get_te32(&VAR_25.sz_unc);

    if (VAR_68 == 0) { /* COMMENT_26 */
        /* COMMENT_27 */
        unsigned const VAR_69 = get_le32(&VAR_25.sz_cpr);
        if (VAR_69 != VAR_18)  /* COMMENT_28 */
            throwCompressedDataViolation();
    }
    else { /* COMMENT_29 */
        throwCompressedDataViolation();
    }

    if (VAR_40) {
        /* COMMENT_30 */
        /* COMMENT_31 */
        int VAR_58 = 0;
        upx_uint64_t VAR_70 = 0;
        VAR_29 = (Elf64_Phdr *)&VAR_27[sizeof(*VAR_28)];
        for (unsigned VAR_54= 0; VAR_54 < VAR_32; ++VAR_54, ++VAR_29) {
            if (VAR_59==get_te32(&VAR_29->p_type) && 0!=VAR_58++) {
                VAR_70 = get_te64(&VAR_29->p_offset);
                VAR_63 = get_te64(&VAR_29->p_vaddr);
                VAR_12->seek(VAR_5, VAR_15);
                VAR_12->readx(VAR_24, VAR_6);
                VAR_33  += VAR_6;
                VAR_34 += VAR_6;

                Elf64_Phdr const *VAR_71 = (Elf64_Phdr *)&VAR_27[sizeof(*VAR_28)];
                for (unsigned VAR_72= 0; VAR_72 < VAR_32; ++VAR_72, ++VAR_71)
                if (Elf64_Phdr::PT_DYNAMIC==get_te32(&VAR_71->p_type)) {
                    upx_uint64_t VAR_73(0), VAR_74(0);
                    upx_uint64_t VAR_75(0), VAR_76(0);
                    upx_uint64_t const VAR_77 = get_te64(&VAR_71->p_filesz);
                    upx_uint64_t const VAR_78 = get_te64(&VAR_71->p_offset);
                    if ((unsigned long)VAR_22 < (VAR_77 + VAR_78)) {
                        char VAR_79[50]; snprintf(VAR_79, sizeof(VAR_79),
                                ""bad PT_DYNAMIC .p_filesz %#lx"", (long unsigned)VAR_77);
                        throwCantUnpack(VAR_79);
                    }
                    if (VAR_78 < VAR_70) {
                        continue;  /* COMMENT_32 */
                    }
                    Elf64_Dyn *VAR_80 = (Elf64_Dyn *)((unsigned char *)VAR_24 +
                        (VAR_78 - VAR_70));
                    VAR_47 = VAR_80; invert_pt_dynamic(VAR_47);
                    for (unsigned VAR_81= 0; VAR_81 < VAR_77; ++VAR_80, VAR_81 += sizeof(*VAR_80)) {
                        upx_uint64_t const VAR_82 = get_te64(&VAR_80->d_tag);
                        upx_uint64_t       VAR_83 = get_te64(&VAR_80->d_val);
                        if (VAR_8) switch (VAR_82) {
                        case Elf64_Dyn::DT_RELASZ:   { VAR_75   = VAR_83; } break;
                        case Elf64_Dyn::DT_RELA:     { VAR_76     = VAR_83; } break;
                        case Elf64_Dyn::DT_PLTRELSZ: { VAR_73 = VAR_83; } break;
                        case Elf64_Dyn::DT_JMPREL:   { VAR_74   = VAR_83; } break;

                        case Elf64_Dyn::DT_PLTGOT:
                        case Elf64_Dyn::DT_PREINIT_ARRAY:
                        case Elf64_Dyn::DT_INIT_ARRAY:
                        case Elf64_Dyn::DT_FINI_ARRAY:
                        case Elf64_Dyn::DT_FINI: {
                            set_te64(&VAR_80->d_val, VAR_83 - VAR_57);
                        }; break;
                        } /* COMMENT_33 */
                        if (VAR_84 == VAR_82) {
                            if (Elf64_Dyn::DT_INIT == VAR_82) {
                                set_te64(&VAR_80->d_val, VAR_7);
                                if (!VAR_7) { /* COMMENT_34 */
                                    VAR_80->d_tag = Elf64_Dyn::DT_NULL;
                                    VAR_80->d_val = 0;
                                }
                            }
                            else if (Elf64_Dyn::DT_INIT_ARRAY    == VAR_82
                            ||       Elf64_Dyn::DT_PREINIT_ARRAY == VAR_82) {
                                if (VAR_83 < VAR_63 || (long unsigned)VAR_22 < (long unsigned)VAR_83) {
                                    char VAR_79[50]; snprintf(VAR_79, sizeof(VAR_79),
                                            ""Bad Dynamic tag %#lx %#lx"",
                                            (long unsigned)VAR_82, (long unsigned)VAR_83);
                                    throwCantUnpack(VAR_79);
                                }
                                set_te64(&VAR_24[VAR_83 - VAR_63], VAR_7
                                    + (VAR_8 ? VAR_57 : 0));  /* COMMENT_35 */
                            }
                        }
                        /* COMMENT_36 */
                    }
                    if (VAR_8) {
                        VAR_85.alloc(VAR_41);
                        VAR_12->seek(0, VAR_15);
                        VAR_12->read(VAR_85, VAR_41);  /* COMMENT_37 */
                        if (VAR_75 && VAR_76) {
                            Elf64_Rela *const VAR_86 = (Elf64_Rela *)VAR_85.subref(
                                ""bad Rela offset"", VAR_76, VAR_75);
                            unRela64(VAR_76, VAR_86, VAR_75, VAR_24, VAR_63, VAR_7, VAR_0);
                        }
                        if (VAR_73 && VAR_74) { /* COMMENT_38 */
                            Elf64_Rela *const VAR_87 = (Elf64_Rela *)VAR_85.subref(
                                ""bad Jmprel offset"", VAR_74, VAR_73);
                            unRela64(VAR_74, VAR_87, VAR_73, VAR_24, VAR_63, VAR_7, VAR_0);
                        }
                        /* COMMENT_39 */
                    }
                }
                if (VAR_0) {
                    VAR_0->seek(get_te64(&VAR_29->p_offset), VAR_15);
                    VAR_0->rewrite(VAR_24, VAR_6);
                }
            }
        }
    }

    /* COMMENT_40 */
    VAR_26.c_len = VAR_33;
    VAR_26.u_len = VAR_34;

    /* COMMENT_41 */
    if (VAR_34 != VAR_20)
        throwEOFException();

    /* COMMENT_42 */
    if (VAR_26.c_adler != VAR_35 || VAR_26.u_adler != VAR_36)
        throwChecksumError();
}",upx/0016512df1df9179fbb508c8cf60699198c9ecaa/p_lx_elf.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -69,7 +69,7 @@
     unsigned c_adler = upx_adler32(NULL, 0);
     unsigned u_adler = upx_adler32(NULL, 0);
 #define MAX_ELF_HDR 1024
-    if ((MAX_ELF_HDR - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {
+    if ((umin64(MAX_ELF_HDR, ph.u_len) - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {
         throwCantUnpack(""bad compressed e_phnum"");
     }
 #undef MAX_ELF_HDR","{'deleted_lines': ['    if ((MAX_ELF_HDR - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {'], 'added_lines': ['    if ((umin64(MAX_ELF_HDR, ph.u_len) - sizeof(Elf64_Ehdr))/sizeof(Elf64_Phdr) < u_phnum) {']}",True,"A heap buffer overflow read was discovered in upx 4.0.0, because the check in p_lx_elf.cpp is not perfect.",7.1,HIGH,2,valid,2020-07-23T02:34:27Z,3
CVE-2020-24119,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0,upx,"Unpack: Phdrs must be within expansion of first compressed block

https://github.com/upx/upx/issues/388
	modified:   p_lx_elf.cpp",0016512df1df9179fbb508c8cf60699198c9ecaa,https://github.com/upx/upx/commit/0016512df1df9179fbb508c8cf60699198c9ecaa,src/p_lx_elf.cpp,PackLinuxElf32::unpack,"void PackLinuxElf32::unpack(OutputFile *fo)
{
if (e_phoff != sizeof(Elf32_Ehdr)) {        throwCantUnpack(""bad e_phoff"");
}
unsigned const c_phnum = get_te16(&ehdri.e_phnum);
unsigned old_data_off = 0;
unsigned old_data_len = 0;
unsigned old_dtinit = 0;
unsigned is_asl = 0;  
unsigned szb_info = sizeof(b_info);
{
if (get_te32(&ehdri.e_entry) < 0x401180
&&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)
&&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {
szb_info = 2*sizeof(unsigned);
}
}
fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);
fi->readx(&linfo, sizeof(linfo));
lsize = get_te16(&linfo.l_lsize);
if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {
throwCantUnpack(""l_info corrupted"");
}
p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));
unsigned orig_file_size = get_te32(&hbuf.p_filesize);
blocksize = get_te32(&hbuf.p_blocksize);
if ((u32_t)file_size > orig_file_size || blocksize > orig_file_size
|| !mem_size_valid(1, blocksize, OVERHEAD))
throwCantUnpack(""p_info corrupted"");
ibuf.alloc(blocksize + OVERHEAD);
b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));
fi->readx(&bhdr, szb_info);
ph.u_len = get_te32(&bhdr.sz_unc);
ph.c_len = get_te32(&bhdr.sz_cpr);
if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0
||  ph.u_len > orig_file_size)
throwCantUnpack(""b_info corrupted"");
ph.filter_cto = bhdr.b_cto8;
MemBuffer u(ph.u_len);
Elf32_Ehdr *const ehdr = (Elf32_Ehdr *)&u[0];
Elf32_Phdr const *phdr = 0;
if (ibuf.getSize() < ph.c_len) {
throwCompressedDataViolation();
}
fi->readx(ibuf, ph.c_len);
decompress(ibuf, (upx_byte *)ehdr, false);
if (ehdr->e_type   !=ehdri.e_type
||  ehdr->e_machine!=ehdri.e_machine
||  ehdr->e_version!=ehdri.e_version
||  ehdr->e_flags  !=ehdri.e_flags
||  ehdr->e_ehsize !=ehdri.e_ehsize
||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI)) {
throwCantUnpack(""ElfXX_Ehdr corrupted"");
}
fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);
unsigned const u_phnum = get_te16(&ehdr->e_phnum);
unsigned total_in = 0;
unsigned total_out = 0;
unsigned c_adler = upx_adler32(NULL, 0);
unsigned u_adler = upx_adler32(NULL, 0);
#define MAX_ELF_HDR 512
if ((MAX_ELF_HDR - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < u_phnum) {
throwCantUnpack(""bad compressed e_phnum"");
}
#undef MAX_ELF_HDR
Elf32_Phdr const *const dynhdr = elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);
bool const is_shlib = !!dynhdr;
if (is_shlib) {
unpackExtent(ph.u_len, fo, total_in, total_out,
c_adler, u_adler, false, szb_info);
fi->seek(0, SEEK_SET);
fi->readx(ibuf, get_te32(&dynhdr->p_offset) + get_te32(&dynhdr->p_filesz));
overlay_offset -= sizeof(linfo);
xct_off = overlay_offset;
e_shoff = get_te32(&ehdri.e_shoff);
ibuf.subref(""bad .e_shoff %#x for %#x"", e_shoff, sizeof(Elf32_Shdr) * e_shnum);
if (e_shoff && e_shnum) {             shdri = (Elf32_Shdr  *)ibuf.subref(
""bad Shdr table"", e_shoff, sizeof(Elf32_Shdr)*e_shnum);
unsigned xct_off2 = get_te32(&shdri->sh_offset);
if (e_shoff == xct_off2) {
xct_off = e_shoff;
}
dynseg = (Elf32_Dyn const *)ibuf.subref(
""bad DYNAMIC"", get_te32(&dynhdr->p_offset), get_te32(&dynhdr->p_filesz));
dynstr = (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);
sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);
if (sec_dynsym) {
unsigned const off_dynsym = get_te32(&sec_dynsym->sh_offset);
unsigned const sz_dynsym  = get_te32(&sec_dynsym->sh_size);
Elf32_Sym *const sym0 = (Elf32_Sym *)ibuf.subref(
""bad dynsym"", off_dynsym, sz_dynsym);
Elf32_Sym *sym = sym0;
for (int j = sz_dynsym / sizeof(Elf32_Sym); --j>=0; ++sym) {
unsigned symval = get_te32(&sym->st_value);
unsigned symsec = get_te16(&sym->st_shndx);
if (Elf32_Sym::SHN_UNDEF != symsec
&&  Elf32_Sym::SHN_ABS   != symsec
&&  xct_off <= symval) {
set_te32(&sym->st_value, symval - asl_delta);
}
if (Elf32_Sym::SHN_ABS == symsec && xct_off <= symval) {
adjABS(sym, 0u - asl_delta);
}
}
}
}
if (fo) {
fo->write(ibuf + ph.u_len, xct_off - ph.u_len);
}
int n_ptload = 0;
phdr = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)ibuf);
for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {
old_data_off = get_te32(&phdr->p_offset);
old_data_len = get_te32(&phdr->p_filesz);
break;
}
}
total_in  = xct_off;
total_out = xct_off;
ph.u_len = 0;
fi->seek(sizeof(linfo) + overlay_offset + sizeof(hbuf) + szb_info + ph.c_len, SEEK_SET);
phdr = (Elf32_Phdr *) (void *) (1+ ehdr);
for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
if (PT_LOAD32==get_te32(&phdr->p_type)) {
ph.u_len = get_te32(&phdr->p_filesz) - xct_off;
break;
}
}
unpackExtent(ph.u_len, fo, total_in, total_out,
c_adler, u_adler, false, szb_info);
}
else {                  bool first_PF_X = true;
phdr = (Elf32_Phdr *) (void *) (1+ ehdr);          for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
if (PT_LOAD32==get_te32(&phdr->p_type)) {
unsigned const filesz = get_te32(&phdr->p_filesz);
unsigned const offset = get_te32(&phdr->p_offset);
if (fo)
fo->seek(offset, SEEK_SET);
if (Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)) {
unpackExtent(filesz, fo, total_in, total_out,
c_adler, u_adler, first_PF_X, szb_info);
first_PF_X = false;
}
else {
unpackExtent(filesz, fo, total_in, total_out,
c_adler, u_adler, false, szb_info);
}
}
}
}
phdr = phdri;
load_va = 0;
for (unsigned j=0; j < c_phnum; ++j) {
if (PT_LOAD32==get_te32(&phdr->p_type)) {
load_va = get_te32(&phdr->p_vaddr);
break;
}
}
if (0x1000==get_te32(&phdri[0].p_filesz)      &&  0==get_te32(&phdri[1].p_offset)
&&  0==get_te32(&phdri[0].p_offset)
&&     get_te32(&phdri[1].p_filesz) == get_te32(&phdri[1].p_memsz)) {
fi->seek(up4(get_te32(&phdr[1].p_memsz)), SEEK_SET);      }
else if (is_shlib
||  ((unsigned)(get_te32(&ehdri.e_entry) - load_va) + up4(lsize) +
ph.getPackHeaderSize() + sizeof(overlay_offset))
< up4(file_size)) {
funpad4(fi);          unsigned d_info[4]; fi->readx(d_info, sizeof(d_info));
if (0==old_dtinit) {
old_dtinit = get_te32(&d_info[2 + (0==d_info[0])]);
is_asl = 1u& get_te32(&d_info[0 + (0==d_info[0])]);
}
fi->seek(lsize - sizeof(d_info), SEEK_CUR);
}
phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];
unsigned hi_offset(0);
for (unsigned j = 0; j < u_phnum; ++j) {
if (PT_LOAD32==phdr[j].p_type
&&  hi_offset < phdr[j].p_offset)
hi_offset = phdr[j].p_offset;
}
for (unsigned j = 0; j < u_phnum; ++j) {
unsigned const size = find_LOAD_gap(phdr, j, u_phnum);
if (size) {
unsigned const where = get_te32(&phdr[j].p_offset) +
get_te32(&phdr[j].p_filesz);
if (fo)
fo->seek(where, SEEK_SET);
unpackExtent(size, fo, total_in, total_out,
c_adler, u_adler, false, szb_info,
(phdr[j].p_offset != hi_offset));
}
}
fi->readx(&bhdr, szb_info);
unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);
if (sz_unc == 0) {                 unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);
if (sz_cpr != UPX_MAGIC_LE32)              throwCompressedDataViolation();
}
else {         throwCompressedDataViolation();
}
if (is_shlib) {
int n_ptload = 0;
unsigned load_off = 0;
phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];
for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {
if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {
load_off = get_te32(&phdr->p_offset);
load_va  = get_te32(&phdr->p_vaddr);
fi->seek(old_data_off, SEEK_SET);
fi->readx(ibuf, old_data_len);
total_in  += old_data_len;
total_out += old_data_len;
Elf32_Phdr const *udynhdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];
for (unsigned j3= 0; j3 < u_phnum; ++j3, ++udynhdr)
if (Elf32_Phdr::PT_DYNAMIC==get_te32(&udynhdr->p_type)) {
unsigned dt_pltrelsz(0), dt_jmprel(0);
unsigned dt_relsz(0), dt_rel(0);
unsigned const dyn_len = get_te32(&udynhdr->p_filesz);
unsigned const dyn_off = get_te32(&udynhdr->p_offset);
if ((unsigned long)file_size < (dyn_len + dyn_off)) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad PT_DYNAMIC .p_filesz %#x"", dyn_len);
throwCantUnpack(msg);
}
if (dyn_off < load_off) {
continue;                      }
Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +
(dyn_off - load_off));
dynseg = dyn; invert_pt_dynamic(dynseg);
for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {
unsigned const tag = get_te32(&dyn->d_tag);
unsigned       val = get_te32(&dyn->d_val);
if (is_asl) switch (tag) {
case Elf32_Dyn::DT_RELSZ:    { dt_relsz    = val; } break;
case Elf32_Dyn::DT_REL:      { dt_rel      = val; } break;
case Elf32_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;
case Elf32_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;
case Elf32_Dyn::DT_PLTGOT:
case Elf32_Dyn::DT_PREINIT_ARRAY:
case Elf32_Dyn::DT_INIT_ARRAY:
case Elf32_Dyn::DT_FINI_ARRAY:
case Elf32_Dyn::DT_FINI: {
set_te32(&dyn->d_val, val -= asl_delta);
}; break;
}                         if (upx_dt_init == tag) {
if (Elf32_Dyn::DT_INIT == tag) {
set_te32(&dyn->d_val, old_dtinit);
if (!old_dtinit) {                                     dyn->d_tag = Elf32_Dyn::DT_NULL;
dyn->d_val = 0;
}
}
else if (Elf32_Dyn::DT_INIT_ARRAY    == tag
||       Elf32_Dyn::DT_PREINIT_ARRAY == tag) {
if (val < load_va || (unsigned)file_size < (unsigned)val) {
char msg[50]; snprintf(msg, sizeof(msg),
""Bad Dynamic tag %#x %#x"",
(unsigned)tag, (unsigned)val);
throwCantUnpack(msg);
}
set_te32(&ibuf[val - load_va], old_dtinit
+ (is_asl ? asl_delta : 0));                              }
}
}
if (is_asl) {
lowmem.alloc(xct_off);
fi->seek(0, SEEK_SET);
fi->read(lowmem, xct_off);                          if (dt_relsz && dt_rel) {
Elf32_Rel *const rel0 = (Elf32_Rel *)lowmem.subref(
""bad Rel offset"", dt_rel, dt_relsz);
unRel32(dt_rel, rel0, dt_relsz, ibuf, load_va, fo);
}
if (dt_pltrelsz && dt_jmprel) {                             Elf32_Rel *const jmp0 = (Elf32_Rel *)lowmem.subref(
""bad Jmprel offset"", dt_jmprel, dt_pltrelsz);
unRel32(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, fo);
}
}
}
if (fo) {
fo->seek(get_te32(&phdr->p_offset), SEEK_SET);
fo->rewrite(ibuf, old_data_len);
}
}
}
}
ph.c_len = total_in;
ph.u_len = total_out;
if (total_out != orig_file_size)
throwEOFException();
if (ph.c_adler != c_adler || ph.u_adler != u_adler)
throwChecksumError();
}","void PackLinuxElf32::unpack(OutputFile *VAR_0)
{
if (VAR_1 != sizeof(VAR_2)) {
throwCantUnpack(""bad e_phoff"");
}
unsigned const VAR_3 = get_te16(&VAR_4.e_phnum);
unsigned VAR_5 = 0;
unsigned VAR_6 = 0;
unsigned VAR_7 = 0;
unsigned VAR_8 = 0;  
unsigned VAR_9 = sizeof(VAR_10);
{
if (get_te32(&VAR_4.e_entry) < 0x401180
&&  Elf32_Ehdr::EM_386 ==get_te16(&VAR_4.e_machine)
&&  Elf32_Ehdr::ET_EXEC==get_te16(&VAR_4.e_type)) {
VAR_9 = 2*sizeof(unsigned);
}
}
VAR_11->seek(VAR_12 - sizeof(VAR_13), VAR_14);
VAR_11->readx(&VAR_15, sizeof(VAR_15));
VAR_16 = get_te16(&VAR_15.l_lsize);
if (VAR_17 != get_le32(&VAR_15.l_magic)) {
throwCantUnpack(""l_info corrupted"");
}
p_info VAR_18;  VAR_11->readx(&VAR_18, sizeof(VAR_18));
unsigned VAR_19 = get_te32(&VAR_18.p_filesize);
VAR_20 = get_te32(&VAR_18.p_blocksize);
if ((u32_t)VAR_21 > VAR_19 || VAR_20 > VAR_19
|| !mem_size_valid(1, VAR_20, VAR_22))
throwCantUnpack(""p_info corrupted"");
VAR_23.alloc(VAR_20 + VAR_22);
b_info VAR_24; memset(&VAR_24, 0, sizeof(VAR_24));
VAR_11->readx(&VAR_24, VAR_9);
VAR_25.u_len = get_te32(&VAR_24.sz_unc);
VAR_25.c_len = get_te32(&VAR_24.sz_cpr);
if (VAR_25.c_len > (unsigned)VAR_21 || VAR_25.c_len == 0 || VAR_25.u_len == 0
||  VAR_25.u_len > VAR_19)
throwCantUnpack(""b_info corrupted"");
VAR_25.filter_cto = VAR_24.b_cto8;
MemBuffer VAR_26(VAR_25.u_len);
Elf32_Ehdr *const VAR_27 = (Elf32_Ehdr *)&VAR_26[0];
Elf32_Phdr const *VAR_28 = 0;
if (VAR_23.getSize() < VAR_25.c_len) {
throwCompressedDataViolation();
}
VAR_11->readx(VAR_23, VAR_25.c_len);
decompress(VAR_23, (upx_byte *)VAR_27, false);
if (VAR_27->e_type   !=VAR_4.e_type
||  VAR_27->e_machine!=VAR_4.e_machine
||  VAR_27->e_version!=VAR_4.e_version
||  VAR_27->e_flags  !=VAR_4.e_flags
||  VAR_27->e_ehsize !=VAR_4.e_ehsize
||  memcmp(VAR_27->e_ident, VAR_4.e_ident, Elf32_Ehdr::EI_OSABI)) {
throwCantUnpack(""ElfXX_Ehdr corrupted"");
}
VAR_11->seek(- (VAR_29) (VAR_9 + VAR_25.c_len), VAR_30);
unsigned const VAR_31 = get_te16(&VAR_27->e_phnum);
unsigned VAR_32 = 0;
unsigned VAR_33 = 0;
unsigned VAR_34 = upx_adler32(NULL, 0);
unsigned VAR_35 = upx_adler32(NULL, 0);
#define VAR_36 512
if ((VAR_36 - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < VAR_31) {
throwCantUnpack(""bad compressed e_phnum"");
}
#undef MAX_ELF_HDR
Elf32_Phdr const *const VAR_37 = elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, VAR_38, VAR_3);
bool const VAR_39 = !!VAR_37;
if (VAR_39) {
unpackExtent(VAR_25.u_len, VAR_0, VAR_32, VAR_33,
VAR_34, VAR_35, false, VAR_9);
VAR_11->seek(0, VAR_14);
VAR_11->readx(VAR_23, get_te32(&VAR_37->p_offset) + get_te32(&VAR_37->p_filesz));
VAR_12 -= sizeof(VAR_15);
VAR_40 = VAR_12;
VAR_41 = get_te32(&VAR_4.e_shoff);
VAR_23.subref(""bad .e_shoff %#x for %#x"", VAR_41, sizeof(VAR_42) * VAR_43);
if (VAR_41 && VAR_43) { 
VAR_44 = (Elf32_Shdr  *)VAR_23.subref(
""bad Shdr table"", VAR_41, sizeof(Elf32_Shdr)*VAR_43);
unsigned VAR_45 = get_te32(&VAR_44->sh_offset);
if (VAR_41 == VAR_45) {
VAR_40 = VAR_41;
}
VAR_46 = (Elf32_Dyn const *)VAR_23.subref(
""bad DYNAMIC"", get_te32(&VAR_37->p_offset), get_te32(&VAR_37->p_filesz));
VAR_47 = (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);
VAR_48 = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);
if (VAR_48) {
unsigned const VAR_49 = get_te32(&VAR_48->sh_offset);
unsigned const VAR_50  = get_te32(&VAR_48->sh_size);
Elf32_Sym *const VAR_51 = (Elf32_Sym *)VAR_23.subref(
""bad dynsym"", VAR_49, VAR_50);
Elf32_Sym *VAR_52 = VAR_51;
for (int VAR_53 = VAR_50 / sizeof(Elf32_Sym); --VAR_53>=0; ++VAR_52) {
unsigned VAR_54 = get_te32(&VAR_52->st_value);
unsigned VAR_55 = get_te16(&VAR_52->st_shndx);
if (Elf32_Sym::SHN_UNDEF != VAR_55
&&  Elf32_Sym::SHN_ABS   != VAR_55
&&  VAR_40 <= VAR_54) {
set_te32(&VAR_52->st_value, VAR_54 - VAR_56);
}
if (Elf32_Sym::SHN_ABS == VAR_55 && VAR_40 <= VAR_54) {
adjABS(VAR_52, 0u - VAR_56);
}
}
}
}
if (VAR_0) {
VAR_0->write(VAR_23 + VAR_25.u_len, VAR_40 - VAR_25.u_len);
}
int VAR_57 = 0;
VAR_28 = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)VAR_23);
for (unsigned VAR_53=0; VAR_53 < VAR_31; ++VAR_28, ++VAR_53) {
if (VAR_58==get_te32(&VAR_28->p_type) && 0!=VAR_57++) {
VAR_5 = get_te32(&VAR_28->p_offset);
VAR_6 = get_te32(&VAR_28->p_filesz);
break;
}
}
VAR_32  = VAR_40;
VAR_33 = VAR_40;
VAR_25.u_len = 0;
VAR_11->seek(sizeof(VAR_15) + VAR_12 + sizeof(VAR_18) + VAR_9 + VAR_25.c_len, VAR_14);
VAR_28 = (Elf32_Phdr *) (void *) (1+ VAR_27);
for (unsigned VAR_53=0; VAR_53 < VAR_31; ++VAR_28, ++VAR_53) {
if (VAR_58==get_te32(&VAR_28->p_type)) {
VAR_25.u_len = get_te32(&VAR_28->p_filesz) - VAR_40;
break;
}
}
unpackExtent(VAR_25.u_len, VAR_0, VAR_32, VAR_33,
VAR_34, VAR_35, false, VAR_9);
}
else {  
bool VAR_59 = true;
VAR_28 = (Elf32_Phdr *) (void *) (1+ VAR_27);  
for (unsigned VAR_53=0; VAR_53 < VAR_31; ++VAR_28, ++VAR_53) {
if (VAR_58==get_te32(&VAR_28->p_type)) {
unsigned const VAR_60 = get_te32(&VAR_28->p_filesz);
unsigned const VAR_61 = get_te32(&VAR_28->p_offset);
if (VAR_0)
VAR_0->seek(VAR_61, VAR_14);
if (Elf32_Phdr::PF_X & get_te32(&VAR_28->p_flags)) {
unpackExtent(VAR_60, VAR_0, VAR_32, VAR_33,
VAR_34, VAR_35, VAR_59, VAR_9);
VAR_59 = false;
}
else {
unpackExtent(VAR_60, VAR_0, VAR_32, VAR_33,
VAR_34, VAR_35, false, VAR_9);
}
}
}
}
VAR_28 = VAR_38;
VAR_62 = 0;
for (unsigned VAR_53=0; VAR_53 < VAR_3; ++VAR_53) {
if (VAR_58==get_te32(&VAR_28->p_type)) {
VAR_62 = get_te32(&VAR_28->p_vaddr);
break;
}
}
if (0x1000==get_te32(&VAR_38[0].p_filesz)  
&&  0==get_te32(&VAR_38[1].p_offset)
&&  0==get_te32(&VAR_38[0].p_offset)
&&     get_te32(&VAR_38[1].p_filesz) == get_te32(&VAR_38[1].p_memsz)) {
VAR_11->seek(up4(get_te32(&VAR_28[1].p_memsz)), VAR_14);  
}
else if (VAR_39
||  ((unsigned)(get_te32(&VAR_4.e_entry) - VAR_62) + up4(VAR_16) +
VAR_25.getPackHeaderSize() + sizeof(VAR_12))
< up4(VAR_21)) {
funpad4(VAR_11);  
unsigned VAR_63[4]; VAR_11->readx(VAR_63, sizeof(VAR_63));
if (0==VAR_7) {
VAR_7 = get_te32(&VAR_63[2 + (0==VAR_63[0])]);
VAR_8 = 1u& get_te32(&VAR_63[0 + (0==VAR_63[0])]);
}
VAR_11->seek(VAR_16 - sizeof(VAR_63), VAR_30);
}
VAR_28 = (Elf32_Phdr *)&VAR_26[sizeof(*VAR_27)];
unsigned VAR_64(0);
for (unsigned VAR_53 = 0; VAR_53 < VAR_31; ++VAR_53) {
if (VAR_58==VAR_28[VAR_53].p_type
&&  VAR_64 < VAR_28[VAR_53].p_offset)
VAR_64 = VAR_28[VAR_53].p_offset;
}
for (unsigned VAR_53 = 0; VAR_53 < VAR_31; ++VAR_53) {
unsigned const VAR_65 = find_LOAD_gap(VAR_28, VAR_53, VAR_31);
if (VAR_65) {
unsigned const VAR_66 = get_te32(&VAR_28[VAR_53].p_offset) +
get_te32(&VAR_28[VAR_53].p_filesz);
if (VAR_0)
VAR_0->seek(VAR_66, VAR_14);
unpackExtent(VAR_65, VAR_0, VAR_32, VAR_33,
VAR_34, VAR_35, false, VAR_9,
(VAR_28[VAR_53].p_offset != VAR_64));
}
}
VAR_11->readx(&VAR_24, VAR_9);
unsigned const VAR_67 = VAR_25.u_len = get_te32(&VAR_24.sz_unc);
if (VAR_67 == 0) { 
unsigned const VAR_68 = get_le32(&VAR_24.sz_cpr);
if (VAR_68 != VAR_17)  
throwCompressedDataViolation();
}
else { 
throwCompressedDataViolation();
}
if (VAR_39) {
int VAR_57 = 0;
unsigned VAR_69 = 0;
VAR_28 = (Elf32_Phdr *)&VAR_26[sizeof(*VAR_27)];
for (unsigned VAR_53= 0; VAR_53 < VAR_31; ++VAR_53, ++VAR_28) {
if (VAR_58==get_te32(&VAR_28->p_type) && 0!=VAR_57++) {
VAR_69 = get_te32(&VAR_28->p_offset);
VAR_62  = get_te32(&VAR_28->p_vaddr);
VAR_11->seek(VAR_5, VAR_14);
VAR_11->readx(VAR_23, VAR_6);
VAR_32  += VAR_6;
VAR_33 += VAR_6;
Elf32_Phdr const *VAR_70 = (Elf32_Phdr *)&VAR_26[sizeof(*VAR_27)];
for (unsigned VAR_71= 0; VAR_71 < VAR_31; ++VAR_71, ++VAR_70)
if (Elf32_Phdr::PT_DYNAMIC==get_te32(&VAR_70->p_type)) {
unsigned VAR_72(0), VAR_73(0);
unsigned VAR_74(0), VAR_75(0);
unsigned const VAR_76 = get_te32(&VAR_70->p_filesz);
unsigned const VAR_77 = get_te32(&VAR_70->p_offset);
if ((unsigned long)VAR_21 < (VAR_76 + VAR_77)) {
char VAR_78[50]; snprintf(VAR_78, sizeof(VAR_78),
""bad PT_DYNAMIC .p_filesz %#x"", VAR_76);
throwCantUnpack(VAR_78);
}
if (VAR_77 < VAR_69) {
continue;  
}
Elf32_Dyn *VAR_79 = (Elf32_Dyn *)((unsigned char *)VAR_23 +
(VAR_77 - VAR_69));
VAR_46 = VAR_79; invert_pt_dynamic(VAR_46);
for (unsigned VAR_80= 0; VAR_80 < VAR_76; ++VAR_79, VAR_80 += sizeof(*VAR_79)) {
unsigned const VAR_81 = get_te32(&VAR_79->d_tag);
unsigned       VAR_82 = get_te32(&VAR_79->d_val);
if (VAR_8) switch (VAR_81) {
case Elf32_Dyn::DT_RELSZ:    { VAR_74    = VAR_82; } break;
case Elf32_Dyn::DT_REL:      { VAR_75      = VAR_82; } break;
case Elf32_Dyn::DT_PLTRELSZ: { VAR_72 = VAR_82; } break;
case Elf32_Dyn::DT_JMPREL:   { VAR_73   = VAR_82; } break;
case Elf32_Dyn::DT_PLTGOT:
case Elf32_Dyn::DT_PREINIT_ARRAY:
case Elf32_Dyn::DT_INIT_ARRAY:
case Elf32_Dyn::DT_FINI_ARRAY:
case Elf32_Dyn::DT_FINI: {
set_te32(&VAR_79->d_val, VAR_82 -= VAR_56);
}; break;
} 
if (VAR_83 == VAR_81) {
if (Elf32_Dyn::DT_INIT == VAR_81) {
set_te32(&VAR_79->d_val, VAR_7);
if (!VAR_7) { 
VAR_79->d_tag = Elf32_Dyn::DT_NULL;
VAR_79->d_val = 0;
}
}
else if (Elf32_Dyn::DT_INIT_ARRAY    == VAR_81
||       Elf32_Dyn::DT_PREINIT_ARRAY == VAR_81) {
if (VAR_82 < VAR_62 || (unsigned)VAR_21 < (unsigned)VAR_82) {
char VAR_78[50]; snprintf(VAR_78, sizeof(VAR_78),
""Bad Dynamic tag %#x %#x"",
(unsigned)VAR_81, (unsigned)VAR_82);
throwCantUnpack(VAR_78);
}
set_te32(&VAR_23[VAR_82 - VAR_62], VAR_7
+ (VAR_8 ? VAR_56 : 0));  
}
}
}
if (VAR_8) {
VAR_84.alloc(VAR_40);
VAR_11->seek(0, VAR_14);
VAR_11->read(VAR_84, VAR_40);  
if (VAR_74 && VAR_75) {
Elf32_Rel *const VAR_85 = (Elf32_Rel *)VAR_84.subref(
""bad Rel offset"", VAR_75, VAR_74);
unRel32(VAR_75, VAR_85, VAR_74, VAR_23, VAR_62, VAR_0);
}
if (VAR_72 && VAR_73) { 
Elf32_Rel *const VAR_86 = (Elf32_Rel *)VAR_84.subref(
""bad Jmprel offset"", VAR_73, VAR_72);
unRel32(VAR_73, VAR_86, VAR_72, VAR_23, VAR_62, VAR_0);
}
}
}
if (VAR_0) {
VAR_0->seek(get_te32(&VAR_28->p_offset), VAR_14);
VAR_0->rewrite(VAR_23, VAR_6);
}
}
}
}
VAR_25.c_len = VAR_32;
VAR_25.u_len = VAR_33;
if (VAR_33 != VAR_19)
throwEOFException();
if (VAR_25.c_adler != VAR_34 || VAR_25.u_adler != VAR_35)
throwChecksumError();
}",upx/0016512df1df9179fbb508c8cf60699198c9ecaa/p_lx_elf.cpp/vul/before/1.json,"void PackLinuxElf32::unpack(OutputFile *fo)
{
    if (e_phoff != sizeof(Elf32_Ehdr)) {// Phdrs not contiguous with Ehdr
        throwCantUnpack(""bad e_phoff"");
    }
    unsigned const c_phnum = get_te16(&ehdri.e_phnum);
    unsigned old_data_off = 0;
    unsigned old_data_len = 0;
    unsigned old_dtinit = 0;
    unsigned is_asl = 0;  // is Android Shared Library

    unsigned szb_info = sizeof(b_info);
    {
        if (get_te32(&ehdri.e_entry) < 0x401180
        &&  Elf32_Ehdr::EM_386 ==get_te16(&ehdri.e_machine)
        &&  Elf32_Ehdr::ET_EXEC==get_te16(&ehdri.e_type)) {
            // Beware ET_DYN.e_entry==0x10f0 (or so) does NOT qualify here.
            /* old style, 8-byte b_info */
            szb_info = 2*sizeof(unsigned);
        }
    }

    fi->seek(overlay_offset - sizeof(l_info), SEEK_SET);
    fi->readx(&linfo, sizeof(linfo));
    lsize = get_te16(&linfo.l_lsize);
    if (UPX_MAGIC_LE32 != get_le32(&linfo.l_magic)) {
        throwCantUnpack(""l_info corrupted"");
    }
    p_info hbuf;  fi->readx(&hbuf, sizeof(hbuf));
    unsigned orig_file_size = get_te32(&hbuf.p_filesize);
    blocksize = get_te32(&hbuf.p_blocksize);
    if ((u32_t)file_size > orig_file_size || blocksize > orig_file_size
        || !mem_size_valid(1, blocksize, OVERHEAD))
        throwCantUnpack(""p_info corrupted"");

    ibuf.alloc(blocksize + OVERHEAD);
    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));
    fi->readx(&bhdr, szb_info);
    ph.u_len = get_te32(&bhdr.sz_unc);
    ph.c_len = get_te32(&bhdr.sz_cpr);
    if (ph.c_len > (unsigned)file_size || ph.c_len == 0 || ph.u_len == 0
    ||  ph.u_len > orig_file_size)
        throwCantUnpack(""b_info corrupted"");
    ph.filter_cto = bhdr.b_cto8;

    MemBuffer u(ph.u_len);
    Elf32_Ehdr *const ehdr = (Elf32_Ehdr *)&u[0];
    Elf32_Phdr const *phdr = 0;

    // Uncompress Ehdr and Phdrs.
    if (ibuf.getSize() < ph.c_len) {
        throwCompressedDataViolation();
    }
    fi->readx(ibuf, ph.c_len);
    decompress(ibuf, (upx_byte *)ehdr, false);
    if (ehdr->e_type   !=ehdri.e_type
    ||  ehdr->e_machine!=ehdri.e_machine
    ||  ehdr->e_version!=ehdri.e_version
    ||  ehdr->e_flags  !=ehdri.e_flags
    ||  ehdr->e_ehsize !=ehdri.e_ehsize
        // check EI_MAG[0-3], EI_CLASS, EI_DATA, EI_VERSION
    ||  memcmp(ehdr->e_ident, ehdri.e_ident, Elf32_Ehdr::EI_OSABI)) {
        throwCantUnpack(""ElfXX_Ehdr corrupted"");
    }
    fi->seek(- (off_t) (szb_info + ph.c_len), SEEK_CUR);

    unsigned const u_phnum = get_te16(&ehdr->e_phnum);
    unsigned total_in = 0;
    unsigned total_out = 0;
    unsigned c_adler = upx_adler32(NULL, 0);
    unsigned u_adler = upx_adler32(NULL, 0);
#define MAX_ELF_HDR 512
    if ((umin(MAX_ELF_HDR, ph.u_len) - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < u_phnum) {
        throwCantUnpack(""bad compressed e_phnum"");
    }
#undef MAX_ELF_HDR

    // Packed ET_EXE has no PT_DYNAMIC.
    // Packed ET_DYN has original PT_DYNAMIC for info needed by rtld.
    Elf32_Phdr const *const dynhdr = elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, phdri, c_phnum);
    bool const is_shlib = !!dynhdr;
    if (is_shlib) {
        // Unpack and output the Ehdr and Phdrs for real.
        // This depends on position within input file fi.
        unpackExtent(ph.u_len, fo, total_in, total_out,
            c_adler, u_adler, false, szb_info);

        // The first PT_LOAD.  Part is not compressed (for benefit of rtld.)
        fi->seek(0, SEEK_SET);
        fi->readx(ibuf, get_te32(&dynhdr->p_offset) + get_te32(&dynhdr->p_filesz));
        overlay_offset -= sizeof(linfo);
        xct_off = overlay_offset;
        e_shoff = get_te32(&ehdri.e_shoff);
        ibuf.subref(""bad .e_shoff %#x for %#x"", e_shoff, sizeof(Elf32_Shdr) * e_shnum);
        if (e_shoff && e_shnum) { // --android-shlib
            shdri = (Elf32_Shdr /*const*/ *)ibuf.subref(
                ""bad Shdr table"", e_shoff, sizeof(Elf32_Shdr)*e_shnum);
            unsigned xct_off2 = get_te32(&shdri->sh_offset);
            if (e_shoff == xct_off2) {
                xct_off = e_shoff;
            }
            // un-Relocate dynsym (DT_SYMTAB) which is below xct_off
            dynseg = (Elf32_Dyn const *)ibuf.subref(
                ""bad DYNAMIC"", get_te32(&dynhdr->p_offset), get_te32(&dynhdr->p_filesz));
            dynstr = (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);
            sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);
            if (sec_dynsym) {
                unsigned const off_dynsym = get_te32(&sec_dynsym->sh_offset);
                unsigned const sz_dynsym  = get_te32(&sec_dynsym->sh_size);
                Elf32_Sym *const sym0 = (Elf32_Sym *)ibuf.subref(
                    ""bad dynsym"", off_dynsym, sz_dynsym);
                Elf32_Sym *sym = sym0;
                for (int j = sz_dynsym / sizeof(Elf32_Sym); --j>=0; ++sym) {
                    unsigned symval = get_te32(&sym->st_value);
                    unsigned symsec = get_te16(&sym->st_shndx);
                    if (Elf32_Sym::SHN_UNDEF != symsec
                    &&  Elf32_Sym::SHN_ABS   != symsec
                    &&  xct_off <= symval) {
                        set_te32(&sym->st_value, symval - asl_delta);
                    }
                    if (Elf32_Sym::SHN_ABS == symsec && xct_off <= symval) {
                        adjABS(sym, 0u - asl_delta);
                    }
                }
            }
        }
        if (fo) {
            fo->write(ibuf + ph.u_len, xct_off - ph.u_len);
        }
        // Search the Phdrs of compressed
        int n_ptload = 0;
        phdr = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)ibuf);
        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {
                old_data_off = get_te32(&phdr->p_offset);
                old_data_len = get_te32(&phdr->p_filesz);
                break;
            }
        }

        total_in  = xct_off;
        total_out = xct_off;
        ph.u_len = 0;
        // Position the input for next unpackExtent.
        fi->seek(sizeof(linfo) + overlay_offset + sizeof(hbuf) + szb_info + ph.c_len, SEEK_SET);

        // Decompress and unfilter the tail of first PT_LOAD.
        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);
        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
            if (PT_LOAD32==get_te32(&phdr->p_type)) {
                ph.u_len = get_te32(&phdr->p_filesz) - xct_off;
                break;
            }
        }
        unpackExtent(ph.u_len, fo, total_in, total_out,
            c_adler, u_adler, false, szb_info);
    }
    else {  // main executable
        // Decompress each PT_LOAD.
        bool first_PF_X = true;
        phdr = (Elf32_Phdr *) (void *) (1+ ehdr);  // uncompressed
        for (unsigned j=0; j < u_phnum; ++phdr, ++j) {
            if (PT_LOAD32==get_te32(&phdr->p_type)) {
                unsigned const filesz = get_te32(&phdr->p_filesz);
                unsigned const offset = get_te32(&phdr->p_offset);
                if (fo)
                    fo->seek(offset, SEEK_SET);
                if (Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)) {
                    unpackExtent(filesz, fo, total_in, total_out,
                        c_adler, u_adler, first_PF_X, szb_info);
                    first_PF_X = false;
                }
                else {
                    unpackExtent(filesz, fo, total_in, total_out,
                        c_adler, u_adler, false, szb_info);
                }
            }
        }
    }
    phdr = phdri;
    load_va = 0;
    for (unsigned j=0; j < c_phnum; ++j) {
        if (PT_LOAD32==get_te32(&phdr->p_type)) {
            load_va = get_te32(&phdr->p_vaddr);
            break;
        }
    }
    if (0x1000==get_te32(&phdri[0].p_filesz)  // detect C_BASE style
    &&  0==get_te32(&phdri[1].p_offset)
    &&  0==get_te32(&phdri[0].p_offset)
    &&     get_te32(&phdri[1].p_filesz) == get_te32(&phdri[1].p_memsz)) {
        fi->seek(up4(get_te32(&phdr[1].p_memsz)), SEEK_SET);  // past the loader
    }
    else if (is_shlib
    ||  ((unsigned)(get_te32(&ehdri.e_entry) - load_va) + up4(lsize) +
                ph.getPackHeaderSize() + sizeof(overlay_offset))
            < up4(file_size)) {
        // Loader is not at end; skip past it.
        funpad4(fi);  // MATCH01
        unsigned d_info[4]; fi->readx(d_info, sizeof(d_info));
        if (0==old_dtinit) {
            old_dtinit = get_te32(&d_info[2 + (0==d_info[0])]);
            is_asl = 1u& get_te32(&d_info[0 + (0==d_info[0])]);
        }
        fi->seek(lsize - sizeof(d_info), SEEK_CUR);
    }

    // The gaps between PT_LOAD and after last PT_LOAD
    phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];
    unsigned hi_offset(0);
    for (unsigned j = 0; j < u_phnum; ++j) {
        if (PT_LOAD32==phdr[j].p_type
        &&  hi_offset < phdr[j].p_offset)
            hi_offset = phdr[j].p_offset;
    }
    for (unsigned j = 0; j < u_phnum; ++j) {
        unsigned const size = find_LOAD_gap(phdr, j, u_phnum);
        if (size) {
            unsigned const where = get_te32(&phdr[j].p_offset) +
                                   get_te32(&phdr[j].p_filesz);
            if (fo)
                fo->seek(where, SEEK_SET);
            unpackExtent(size, fo, total_in, total_out,
                c_adler, u_adler, false, szb_info,
                (phdr[j].p_offset != hi_offset));
        }
    }

    // check for end-of-file
    fi->readx(&bhdr, szb_info);
    unsigned const sz_unc = ph.u_len = get_te32(&bhdr.sz_unc);

    if (sz_unc == 0) { // uncompressed size 0 -> EOF
        // note: magic is always stored le32
        unsigned const sz_cpr = get_le32(&bhdr.sz_cpr);
        if (sz_cpr != UPX_MAGIC_LE32)  // sz_cpr must be h->magic
            throwCompressedDataViolation();
    }
    else { // extra bytes after end?
        throwCompressedDataViolation();
    }

    if (is_shlib) {
        // DT_INIT must be restored.
        // If android_shlib, then the asl_delta relocations must be un-done.
        int n_ptload = 0;
        unsigned load_off = 0;
        phdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];
        for (unsigned j= 0; j < u_phnum; ++j, ++phdr) {
            if (PT_LOAD32==get_te32(&phdr->p_type) && 0!=n_ptload++) {
                load_off = get_te32(&phdr->p_offset);
                load_va  = get_te32(&phdr->p_vaddr);
                fi->seek(old_data_off, SEEK_SET);
                fi->readx(ibuf, old_data_len);
                total_in  += old_data_len;
                total_out += old_data_len;

                Elf32_Phdr const *udynhdr = (Elf32_Phdr *)&u[sizeof(*ehdr)];
                for (unsigned j3= 0; j3 < u_phnum; ++j3, ++udynhdr)
                if (Elf32_Phdr::PT_DYNAMIC==get_te32(&udynhdr->p_type)) {
                    unsigned dt_pltrelsz(0), dt_jmprel(0);
                    unsigned dt_relsz(0), dt_rel(0);
                    unsigned const dyn_len = get_te32(&udynhdr->p_filesz);
                    unsigned const dyn_off = get_te32(&udynhdr->p_offset);
                    if ((unsigned long)file_size < (dyn_len + dyn_off)) {
                        char msg[50]; snprintf(msg, sizeof(msg),
                                ""bad PT_DYNAMIC .p_filesz %#x"", dyn_len);
                        throwCantUnpack(msg);
                    }
                    if (dyn_off < load_off) {
                        continue;  // Oops.  Not really is_shlib ?  [built by 'rust' ?]
                    }
                    Elf32_Dyn *dyn = (Elf32_Dyn *)((unsigned char *)ibuf +
                        (dyn_off - load_off));
                    dynseg = dyn; invert_pt_dynamic(dynseg);
                    for (unsigned j2= 0; j2 < dyn_len; ++dyn, j2 += sizeof(*dyn)) {
                        unsigned const tag = get_te32(&dyn->d_tag);
                        unsigned       val = get_te32(&dyn->d_val);
                        if (is_asl) switch (tag) {
                        case Elf32_Dyn::DT_RELSZ:    { dt_relsz    = val; } break;
                        case Elf32_Dyn::DT_REL:      { dt_rel      = val; } break;
                        case Elf32_Dyn::DT_PLTRELSZ: { dt_pltrelsz = val; } break;
                        case Elf32_Dyn::DT_JMPREL:   { dt_jmprel   = val; } break;

                        case Elf32_Dyn::DT_PLTGOT:
                        case Elf32_Dyn::DT_PREINIT_ARRAY:
                        case Elf32_Dyn::DT_INIT_ARRAY:
                        case Elf32_Dyn::DT_FINI_ARRAY:
                        case Elf32_Dyn::DT_FINI: {
                            set_te32(&dyn->d_val, val -= asl_delta);
                        }; break;
                        } // end switch()
                        if (upx_dt_init == tag) {
                            if (Elf32_Dyn::DT_INIT == tag) {
                                set_te32(&dyn->d_val, old_dtinit);
                                if (!old_dtinit) { // compressor took the slot
                                    dyn->d_tag = Elf32_Dyn::DT_NULL;
                                    dyn->d_val = 0;
                                }
                            }
                            else if (Elf32_Dyn::DT_INIT_ARRAY    == tag
                            ||       Elf32_Dyn::DT_PREINIT_ARRAY == tag) {
                                if (val < load_va || (unsigned)file_size < (unsigned)val) {
                                    char msg[50]; snprintf(msg, sizeof(msg),
                                            ""Bad Dynamic tag %#x %#x"",
                                            (unsigned)tag, (unsigned)val);
                                    throwCantUnpack(msg);
                                }
                                set_te32(&ibuf[val - load_va], old_dtinit
                                    + (is_asl ? asl_delta : 0));  // counter-act unRel32
                            }
                        }
                        // Modified DT_*.d_val are re-written later from ibuf[]
                    }
                    if (is_asl) {
                        lowmem.alloc(xct_off);
                        fi->seek(0, SEEK_SET);
                        fi->read(lowmem, xct_off);  // contains relocation tables
                        if (dt_relsz && dt_rel) {
                            Elf32_Rel *const rel0 = (Elf32_Rel *)lowmem.subref(
                                ""bad Rel offset"", dt_rel, dt_relsz);
                            unRel32(dt_rel, rel0, dt_relsz, ibuf, load_va, fo);
                        }
                        if (dt_pltrelsz && dt_jmprel) { // FIXME:  overlap w/ DT_REL ?
                            Elf32_Rel *const jmp0 = (Elf32_Rel *)lowmem.subref(
                                ""bad Jmprel offset"", dt_jmprel, dt_pltrelsz);
                            unRel32(dt_jmprel, jmp0, dt_pltrelsz, ibuf, load_va, fo);
                        }
                        // Modified relocation tables are re-written by unRel32
                    }
                }
                if (fo) {
                    fo->seek(get_te32(&phdr->p_offset), SEEK_SET);
                    fo->rewrite(ibuf, old_data_len);
                }
            }
        }
    }

    // update header with totals
    ph.c_len = total_in;
    ph.u_len = total_out;

    // all bytes must be written
    if (total_out != orig_file_size)
        throwEOFException();

    // finally test the checksums
    if (ph.c_adler != c_adler || ph.u_adler != u_adler)
        throwChecksumError();
}","void PackLinuxElf32::unpack(OutputFile *VAR_0)
{
    if (VAR_1 != sizeof(VAR_2)) {/* COMMENT_0 */
        throwCantUnpack(""bad e_phoff"");
    }
    unsigned const VAR_3 = get_te16(&VAR_4.e_phnum);
    unsigned VAR_5 = 0;
    unsigned VAR_6 = 0;
    unsigned VAR_7 = 0;
    unsigned VAR_8 = 0;  /* COMMENT_1 */

    unsigned VAR_9 = sizeof(VAR_10);
    {
        if (get_te32(&VAR_4.e_entry) < 0x401180
        &&  Elf32_Ehdr::EM_386 ==get_te16(&VAR_4.e_machine)
        &&  Elf32_Ehdr::ET_EXEC==get_te16(&VAR_4.e_type)) {
            /* COMMENT_2 */
            /* COMMENT_3 */
            VAR_9 = 2*sizeof(unsigned);
        }
    }

    VAR_11->seek(VAR_12 - sizeof(VAR_13), VAR_14);
    VAR_11->readx(&VAR_15, sizeof(VAR_15));
    VAR_16 = get_te16(&VAR_15.l_lsize);
    if (VAR_17 != get_le32(&VAR_15.l_magic)) {
        throwCantUnpack(""l_info corrupted"");
    }
    p_info VAR_18;  VAR_11->readx(&VAR_18, sizeof(VAR_18));
    unsigned VAR_19 = get_te32(&VAR_18.p_filesize);
    VAR_20 = get_te32(&VAR_18.p_blocksize);
    if ((u32_t)VAR_21 > VAR_19 || VAR_20 > VAR_19
        || !mem_size_valid(1, VAR_20, VAR_22))
        throwCantUnpack(""p_info corrupted"");

    VAR_23.alloc(VAR_20 + VAR_22);
    b_info VAR_24; memset(&VAR_24, 0, sizeof(VAR_24));
    VAR_11->readx(&VAR_24, VAR_9);
    VAR_25.u_len = get_te32(&VAR_24.sz_unc);
    VAR_25.c_len = get_te32(&VAR_24.sz_cpr);
    if (VAR_25.c_len > (unsigned)VAR_21 || VAR_25.c_len == 0 || VAR_25.u_len == 0
    ||  VAR_25.u_len > VAR_19)
        throwCantUnpack(""b_info corrupted"");
    VAR_25.filter_cto = VAR_24.b_cto8;

    MemBuffer VAR_26(VAR_25.u_len);
    Elf32_Ehdr *const VAR_27 = (Elf32_Ehdr *)&VAR_26[0];
    Elf32_Phdr const *VAR_28 = 0;

    /* COMMENT_4 */
    if (VAR_23.getSize() < VAR_25.c_len) {
        throwCompressedDataViolation();
    }
    VAR_11->readx(VAR_23, VAR_25.c_len);
    decompress(VAR_23, (upx_byte *)VAR_27, false);
    if (VAR_27->e_type   !=VAR_4.e_type
    ||  VAR_27->e_machine!=VAR_4.e_machine
    ||  VAR_27->e_version!=VAR_4.e_version
    ||  VAR_27->e_flags  !=VAR_4.e_flags
    ||  VAR_27->e_ehsize !=VAR_4.e_ehsize
        /* COMMENT_5 */
    ||  memcmp(VAR_27->e_ident, VAR_4.e_ident, Elf32_Ehdr::EI_OSABI)) {
        throwCantUnpack(""ElfXX_Ehdr corrupted"");
    }
    VAR_11->seek(- (VAR_29) (VAR_9 + VAR_25.c_len), VAR_30);

    unsigned const VAR_31 = get_te16(&VAR_27->e_phnum);
    unsigned VAR_32 = 0;
    unsigned VAR_33 = 0;
    unsigned VAR_34 = upx_adler32(NULL, 0);
    unsigned VAR_35 = upx_adler32(NULL, 0);
#define VAR_36 512
    if ((umin(VAR_36, VAR_25.u_len) - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < VAR_31) {
        throwCantUnpack(""bad compressed e_phnum"");
    }
#undef MAX_ELF_HDR

    /* COMMENT_6 */
    /* COMMENT_7 */
    Elf32_Phdr const *const VAR_37 = elf_find_ptype(Elf32_Phdr::PT_DYNAMIC, VAR_38, VAR_3);
    bool const VAR_39 = !!VAR_37;
    if (VAR_39) {
        /* COMMENT_8 */
        /* COMMENT_9 */
        unpackExtent(VAR_25.u_len, VAR_0, VAR_32, VAR_33,
            VAR_34, VAR_35, false, VAR_9);

        /* COMMENT_10 */
        VAR_11->seek(0, VAR_14);
        VAR_11->readx(VAR_23, get_te32(&VAR_37->p_offset) + get_te32(&VAR_37->p_filesz));
        VAR_12 -= sizeof(VAR_15);
        VAR_40 = VAR_12;
        VAR_41 = get_te32(&VAR_4.e_shoff);
        VAR_23.subref(""bad .e_shoff %#x for %#x"", VAR_41, sizeof(VAR_42) * VAR_43);
        if (VAR_41 && VAR_43) { /* COMMENT_11 */
            VAR_44 = (Elf32_Shdr /* COMMENT_12 */ *)VAR_23.subref(
                ""bad Shdr table"", VAR_41, sizeof(Elf32_Shdr)*VAR_43);
            unsigned VAR_45 = get_te32(&VAR_44->sh_offset);
            if (VAR_41 == VAR_45) {
                VAR_40 = VAR_41;
            }
            /* COMMENT_13 */
            VAR_46 = (Elf32_Dyn const *)VAR_23.subref(
                ""bad DYNAMIC"", get_te32(&VAR_37->p_offset), get_te32(&VAR_37->p_filesz));
            VAR_47 = (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);
            VAR_48 = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);
            if (VAR_48) {
                unsigned const VAR_49 = get_te32(&VAR_48->sh_offset);
                unsigned const VAR_50  = get_te32(&VAR_48->sh_size);
                Elf32_Sym *const VAR_51 = (Elf32_Sym *)VAR_23.subref(
                    ""bad dynsym"", VAR_49, VAR_50);
                Elf32_Sym *VAR_52 = VAR_51;
                for (int VAR_53 = VAR_50 / sizeof(Elf32_Sym); --VAR_53>=0; ++VAR_52) {
                    unsigned VAR_54 = get_te32(&VAR_52->st_value);
                    unsigned VAR_55 = get_te16(&VAR_52->st_shndx);
                    if (Elf32_Sym::SHN_UNDEF != VAR_55
                    &&  Elf32_Sym::SHN_ABS   != VAR_55
                    &&  VAR_40 <= VAR_54) {
                        set_te32(&VAR_52->st_value, VAR_54 - VAR_56);
                    }
                    if (Elf32_Sym::SHN_ABS == VAR_55 && VAR_40 <= VAR_54) {
                        adjABS(VAR_52, 0u - VAR_56);
                    }
                }
            }
        }
        if (VAR_0) {
            VAR_0->write(VAR_23 + VAR_25.u_len, VAR_40 - VAR_25.u_len);
        }
        /* COMMENT_14 */
        int VAR_57 = 0;
        VAR_28 = (Elf32_Phdr *) (void *) (1+ (Elf32_Ehdr *)(unsigned char *)VAR_23);
        for (unsigned VAR_53=0; VAR_53 < VAR_31; ++VAR_28, ++VAR_53) {
            if (VAR_58==get_te32(&VAR_28->p_type) && 0!=VAR_57++) {
                VAR_5 = get_te32(&VAR_28->p_offset);
                VAR_6 = get_te32(&VAR_28->p_filesz);
                break;
            }
        }

        VAR_32  = VAR_40;
        VAR_33 = VAR_40;
        VAR_25.u_len = 0;
        /* COMMENT_15 */
        VAR_11->seek(sizeof(VAR_15) + VAR_12 + sizeof(VAR_18) + VAR_9 + VAR_25.c_len, VAR_14);

        /* COMMENT_16 */
        VAR_28 = (Elf32_Phdr *) (void *) (1+ VAR_27);
        for (unsigned VAR_53=0; VAR_53 < VAR_31; ++VAR_28, ++VAR_53) {
            if (VAR_58==get_te32(&VAR_28->p_type)) {
                VAR_25.u_len = get_te32(&VAR_28->p_filesz) - VAR_40;
                break;
            }
        }
        unpackExtent(VAR_25.u_len, VAR_0, VAR_32, VAR_33,
            VAR_34, VAR_35, false, VAR_9);
    }
    else {  /* COMMENT_17 */
        /* COMMENT_18 */
        bool VAR_59 = true;
        VAR_28 = (Elf32_Phdr *) (void *) (1+ VAR_27);  /* COMMENT_19 */
        for (unsigned VAR_53=0; VAR_53 < VAR_31; ++VAR_28, ++VAR_53) {
            if (VAR_58==get_te32(&VAR_28->p_type)) {
                unsigned const VAR_60 = get_te32(&VAR_28->p_filesz);
                unsigned const VAR_61 = get_te32(&VAR_28->p_offset);
                if (VAR_0)
                    VAR_0->seek(VAR_61, VAR_14);
                if (Elf32_Phdr::PF_X & get_te32(&VAR_28->p_flags)) {
                    unpackExtent(VAR_60, VAR_0, VAR_32, VAR_33,
                        VAR_34, VAR_35, VAR_59, VAR_9);
                    VAR_59 = false;
                }
                else {
                    unpackExtent(VAR_60, VAR_0, VAR_32, VAR_33,
                        VAR_34, VAR_35, false, VAR_9);
                }
            }
        }
    }
    VAR_28 = VAR_38;
    VAR_62 = 0;
    for (unsigned VAR_53=0; VAR_53 < VAR_3; ++VAR_53) {
        if (VAR_58==get_te32(&VAR_28->p_type)) {
            VAR_62 = get_te32(&VAR_28->p_vaddr);
            break;
        }
    }
    if (0x1000==get_te32(&VAR_38[0].p_filesz)  /* COMMENT_20 */
    &&  0==get_te32(&VAR_38[1].p_offset)
    &&  0==get_te32(&VAR_38[0].p_offset)
    &&     get_te32(&VAR_38[1].p_filesz) == get_te32(&VAR_38[1].p_memsz)) {
        VAR_11->seek(up4(get_te32(&VAR_28[1].p_memsz)), VAR_14);  /* COMMENT_21 */
    }
    else if (VAR_39
    ||  ((unsigned)(get_te32(&VAR_4.e_entry) - VAR_62) + up4(VAR_16) +
                VAR_25.getPackHeaderSize() + sizeof(VAR_12))
            < up4(VAR_21)) {
        /* COMMENT_22 */
        funpad4(VAR_11);  /* COMMENT_23 */
        unsigned VAR_63[4]; VAR_11->readx(VAR_63, sizeof(VAR_63));
        if (0==VAR_7) {
            VAR_7 = get_te32(&VAR_63[2 + (0==VAR_63[0])]);
            VAR_8 = 1u& get_te32(&VAR_63[0 + (0==VAR_63[0])]);
        }
        VAR_11->seek(VAR_16 - sizeof(VAR_63), VAR_30);
    }

    /* COMMENT_24 */
    VAR_28 = (Elf32_Phdr *)&VAR_26[sizeof(*VAR_27)];
    unsigned VAR_64(0);
    for (unsigned VAR_53 = 0; VAR_53 < VAR_31; ++VAR_53) {
        if (VAR_58==VAR_28[VAR_53].p_type
        &&  VAR_64 < VAR_28[VAR_53].p_offset)
            VAR_64 = VAR_28[VAR_53].p_offset;
    }
    for (unsigned VAR_53 = 0; VAR_53 < VAR_31; ++VAR_53) {
        unsigned const VAR_65 = find_LOAD_gap(VAR_28, VAR_53, VAR_31);
        if (VAR_65) {
            unsigned const VAR_66 = get_te32(&VAR_28[VAR_53].p_offset) +
                                   get_te32(&VAR_28[VAR_53].p_filesz);
            if (VAR_0)
                VAR_0->seek(VAR_66, VAR_14);
            unpackExtent(VAR_65, VAR_0, VAR_32, VAR_33,
                VAR_34, VAR_35, false, VAR_9,
                (VAR_28[VAR_53].p_offset != VAR_64));
        }
    }

    /* COMMENT_25 */
    VAR_11->readx(&VAR_24, VAR_9);
    unsigned const VAR_67 = VAR_25.u_len = get_te32(&VAR_24.sz_unc);

    if (VAR_67 == 0) { /* COMMENT_26 */
        /* COMMENT_27 */
        unsigned const VAR_68 = get_le32(&VAR_24.sz_cpr);
        if (VAR_68 != VAR_17)  /* COMMENT_28 */
            throwCompressedDataViolation();
    }
    else { /* COMMENT_29 */
        throwCompressedDataViolation();
    }

    if (VAR_39) {
        /* COMMENT_30 */
        /* COMMENT_31 */
        int VAR_57 = 0;
        unsigned VAR_69 = 0;
        VAR_28 = (Elf32_Phdr *)&VAR_26[sizeof(*VAR_27)];
        for (unsigned VAR_53= 0; VAR_53 < VAR_31; ++VAR_53, ++VAR_28) {
            if (VAR_58==get_te32(&VAR_28->p_type) && 0!=VAR_57++) {
                VAR_69 = get_te32(&VAR_28->p_offset);
                VAR_62  = get_te32(&VAR_28->p_vaddr);
                VAR_11->seek(VAR_5, VAR_14);
                VAR_11->readx(VAR_23, VAR_6);
                VAR_32  += VAR_6;
                VAR_33 += VAR_6;

                Elf32_Phdr const *VAR_70 = (Elf32_Phdr *)&VAR_26[sizeof(*VAR_27)];
                for (unsigned VAR_71= 0; VAR_71 < VAR_31; ++VAR_71, ++VAR_70)
                if (Elf32_Phdr::PT_DYNAMIC==get_te32(&VAR_70->p_type)) {
                    unsigned VAR_72(0), VAR_73(0);
                    unsigned VAR_74(0), VAR_75(0);
                    unsigned const VAR_76 = get_te32(&VAR_70->p_filesz);
                    unsigned const VAR_77 = get_te32(&VAR_70->p_offset);
                    if ((unsigned long)VAR_21 < (VAR_76 + VAR_77)) {
                        char VAR_78[50]; snprintf(VAR_78, sizeof(VAR_78),
                                ""bad PT_DYNAMIC .p_filesz %#x"", VAR_76);
                        throwCantUnpack(VAR_78);
                    }
                    if (VAR_77 < VAR_69) {
                        continue;  /* COMMENT_32 */
                    }
                    Elf32_Dyn *VAR_79 = (Elf32_Dyn *)((unsigned char *)VAR_23 +
                        (VAR_77 - VAR_69));
                    VAR_46 = VAR_79; invert_pt_dynamic(VAR_46);
                    for (unsigned VAR_80= 0; VAR_80 < VAR_76; ++VAR_79, VAR_80 += sizeof(*VAR_79)) {
                        unsigned const VAR_81 = get_te32(&VAR_79->d_tag);
                        unsigned       VAR_82 = get_te32(&VAR_79->d_val);
                        if (VAR_8) switch (VAR_81) {
                        case Elf32_Dyn::DT_RELSZ:    { VAR_74    = VAR_82; } break;
                        case Elf32_Dyn::DT_REL:      { VAR_75      = VAR_82; } break;
                        case Elf32_Dyn::DT_PLTRELSZ: { VAR_72 = VAR_82; } break;
                        case Elf32_Dyn::DT_JMPREL:   { VAR_73   = VAR_82; } break;

                        case Elf32_Dyn::DT_PLTGOT:
                        case Elf32_Dyn::DT_PREINIT_ARRAY:
                        case Elf32_Dyn::DT_INIT_ARRAY:
                        case Elf32_Dyn::DT_FINI_ARRAY:
                        case Elf32_Dyn::DT_FINI: {
                            set_te32(&VAR_79->d_val, VAR_82 -= VAR_56);
                        }; break;
                        } /* COMMENT_33 */
                        if (VAR_83 == VAR_81) {
                            if (Elf32_Dyn::DT_INIT == VAR_81) {
                                set_te32(&VAR_79->d_val, VAR_7);
                                if (!VAR_7) { /* COMMENT_34 */
                                    VAR_79->d_tag = Elf32_Dyn::DT_NULL;
                                    VAR_79->d_val = 0;
                                }
                            }
                            else if (Elf32_Dyn::DT_INIT_ARRAY    == VAR_81
                            ||       Elf32_Dyn::DT_PREINIT_ARRAY == VAR_81) {
                                if (VAR_82 < VAR_62 || (unsigned)VAR_21 < (unsigned)VAR_82) {
                                    char VAR_78[50]; snprintf(VAR_78, sizeof(VAR_78),
                                            ""Bad Dynamic tag %#x %#x"",
                                            (unsigned)VAR_81, (unsigned)VAR_82);
                                    throwCantUnpack(VAR_78);
                                }
                                set_te32(&VAR_23[VAR_82 - VAR_62], VAR_7
                                    + (VAR_8 ? VAR_56 : 0));  /* COMMENT_35 */
                            }
                        }
                        /* COMMENT_36 */
                    }
                    if (VAR_8) {
                        VAR_84.alloc(VAR_40);
                        VAR_11->seek(0, VAR_14);
                        VAR_11->read(VAR_84, VAR_40);  /* COMMENT_37 */
                        if (VAR_74 && VAR_75) {
                            Elf32_Rel *const VAR_85 = (Elf32_Rel *)VAR_84.subref(
                                ""bad Rel offset"", VAR_75, VAR_74);
                            unRel32(VAR_75, VAR_85, VAR_74, VAR_23, VAR_62, VAR_0);
                        }
                        if (VAR_72 && VAR_73) { /* COMMENT_38 */
                            Elf32_Rel *const VAR_86 = (Elf32_Rel *)VAR_84.subref(
                                ""bad Jmprel offset"", VAR_73, VAR_72);
                            unRel32(VAR_73, VAR_86, VAR_72, VAR_23, VAR_62, VAR_0);
                        }
                        /* COMMENT_39 */
                    }
                }
                if (VAR_0) {
                    VAR_0->seek(get_te32(&VAR_28->p_offset), VAR_14);
                    VAR_0->rewrite(VAR_23, VAR_6);
                }
            }
        }
    }

    /* COMMENT_40 */
    VAR_25.c_len = VAR_32;
    VAR_25.u_len = VAR_33;

    /* COMMENT_41 */
    if (VAR_33 != VAR_19)
        throwEOFException();

    /* COMMENT_42 */
    if (VAR_25.c_adler != VAR_34 || VAR_25.u_adler != VAR_35)
        throwChecksumError();
}",upx/0016512df1df9179fbb508c8cf60699198c9ecaa/p_lx_elf.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -70,7 +70,7 @@
     unsigned c_adler = upx_adler32(NULL, 0);
     unsigned u_adler = upx_adler32(NULL, 0);
 #define MAX_ELF_HDR 512
-    if ((MAX_ELF_HDR - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < u_phnum) {
+    if ((umin(MAX_ELF_HDR, ph.u_len) - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < u_phnum) {
         throwCantUnpack(""bad compressed e_phnum"");
     }
 #undef MAX_ELF_HDR","{'deleted_lines': ['    if ((MAX_ELF_HDR - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < u_phnum) {'], 'added_lines': ['    if ((umin(MAX_ELF_HDR, ph.u_len) - sizeof(Elf32_Ehdr))/sizeof(Elf32_Phdr) < u_phnum) {']}",True,"A heap buffer overflow read was discovered in upx 4.0.0, because the check in p_lx_elf.cpp is not perfect.",7.1,HIGH,2,valid,2020-07-23T02:34:27Z,3
CVE-2020-35538,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libjpeg-turbo,"Fix jpeg_skip_scanlines() segfault w/merged upsamp

The additional segfault mentioned in #244 was due to the fact that
the merged upsamplers use a different private structure than the
non-merged upsamplers.  jpeg_skip_scanlines() was assuming the latter, so
when merged upsampling was enabled, jpeg_skip_scanlines() clobbered one
of the IDCT method pointers in the merged upsampler's private structure.

For reasons unknown, the test image in #441 did not encounter this
segfault (too small?), but it encountered an issue similar to the one
fixed in 5bc43c7821df982f65aa1c738f67fbf7cba8bd69, whereby it was
necessary to set up a dummy postprocessing function in
read_and_discard_scanlines() when merged upsampling was enabled.
Failing to do so caused either a segfault in merged_2v_upsample() (due
to a NULL pointer being passed to jcopy_sample_rows()) or an error
(""Corrupt JPEG data: premature end of data segment""), depending on the
number of scanlines skipped and whether the first scanline skipped was
an odd- or even-numbered row.

Fixes #441
Fixes #244 (for real this time)",9120a247436e84c0b4eea828cb11e8f665fcde30,https://github.com/libjpeg-turbo/libjpeg-turbo/commit/9120a247436e84c0b4eea828cb11e8f665fcde30,jdmrgext.c,h2v1_merged_upsample_internal,"INLINE
LOCAL(void)
h2v1_merged_upsample_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
JDIMENSION in_row_group_ctr,
JSAMPARRAY output_buf)
{
my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
register int y, cred, cgreen, cblue;
int cb, cr;
register JSAMPROW outptr;
JSAMPROW inptr0, inptr1, inptr2;
JDIMENSION col;
register JSAMPLE *range_limit = cinfo->sample_range_limit;
int *Crrtab = upsample->Cr_r_tab;
int *Cbbtab = upsample->Cb_b_tab;
JLONG *Crgtab = upsample->Cr_g_tab;
JLONG *Cbgtab = upsample->Cb_g_tab;
SHIFT_TEMPS
inptr0 = input_buf[0][in_row_group_ctr];
inptr1 = input_buf[1][in_row_group_ctr];
inptr2 = input_buf[2][in_row_group_ctr];
outptr = output_buf[0];
for (col = cinfo->output_width >> 1; col > 0; col--) {
cb = GETJSAMPLE(*inptr1++);
cr = GETJSAMPLE(*inptr2++);
cred = Crrtab[cr];
cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
cblue = Cbbtab[cb];
y  = GETJSAMPLE(*inptr0++);
outptr[RGB_RED] =   range_limit[y + cred];
outptr[RGB_GREEN] = range_limit[y + cgreen];
outptr[RGB_BLUE] =  range_limit[y + cblue];
#ifdef RGB_ALPHA
outptr[RGB_ALPHA] = 0xFF;
#endif
outptr += RGB_PIXELSIZE;
y  = GETJSAMPLE(*inptr0++);
outptr[RGB_RED] =   range_limit[y + cred];
outptr[RGB_GREEN] = range_limit[y + cgreen];
outptr[RGB_BLUE] =  range_limit[y + cblue];
#ifdef RGB_ALPHA
outptr[RGB_ALPHA] = 0xFF;
#endif
outptr += RGB_PIXELSIZE;
}
if (cinfo->output_width & 1) {
cb = GETJSAMPLE(*inptr1);
cr = GETJSAMPLE(*inptr2);
cred = Crrtab[cr];
cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
cblue = Cbbtab[cb];
y  = GETJSAMPLE(*inptr0);
outptr[RGB_RED] =   range_limit[y + cred];
outptr[RGB_GREEN] = range_limit[y + cgreen];
outptr[RGB_BLUE] =  range_limit[y + cblue];
#ifdef RGB_ALPHA
outptr[RGB_ALPHA] = 0xFF;
#endif
}
}","INLINE
LOCAL(void)
h2v1_merged_upsample_internal(j_decompress_ptr VAR_0, JSAMPIMAGE VAR_1,
JDIMENSION VAR_2,
JSAMPARRAY VAR_3)
{
my_upsample_ptr VAR_4 = (my_upsample_ptr)VAR_0->upsample;
register int VAR_5, VAR_6, VAR_7, VAR_8;
int VAR_9, VAR_10;
register JSAMPROW VAR_11;
JSAMPROW VAR_12, VAR_13, VAR_14;
JDIMENSION VAR_15;
register JSAMPLE *VAR_16 = VAR_0->sample_range_limit;
int *VAR_17 = VAR_4->Cr_r_tab;
int *VAR_18 = VAR_4->Cb_b_tab;
JLONG *VAR_19 = VAR_4->Cr_g_tab;
JLONG *VAR_20 = VAR_4->Cb_g_tab;
SHIFT_TEMPS
VAR_12 = VAR_1[0][VAR_2];
VAR_13 = VAR_1[1][VAR_2];
VAR_14 = VAR_1[2][VAR_2];
VAR_11 = VAR_3[0];
for (VAR_15 = VAR_0->output_width >> 1; VAR_15 > 0; VAR_15--) {
VAR_9 = GETJSAMPLE(*VAR_13++);
VAR_10 = GETJSAMPLE(*VAR_14++);
VAR_6 = VAR_17[VAR_10];
VAR_7 = (int)RIGHT_SHIFT(VAR_20[VAR_9] + VAR_19[VAR_10], VAR_21);
VAR_8 = VAR_18[VAR_9];
VAR_5  = GETJSAMPLE(*VAR_12++);
VAR_11[VAR_22] =   VAR_16[VAR_5 + VAR_6];
VAR_11[VAR_23] = VAR_16[VAR_5 + VAR_7];
VAR_11[VAR_24] =  VAR_16[VAR_5 + VAR_8];
#ifdef VAR_25
VAR_11[VAR_25] = 0xFF;
#endif
VAR_11 += VAR_26;
VAR_5  = GETJSAMPLE(*VAR_12++);
VAR_11[VAR_22] =   VAR_16[VAR_5 + VAR_6];
VAR_11[VAR_23] = VAR_16[VAR_5 + VAR_7];
VAR_11[VAR_24] =  VAR_16[VAR_5 + VAR_8];
#ifdef VAR_25
VAR_11[VAR_25] = 0xFF;
#endif
VAR_11 += VAR_26;
}
if (VAR_0->output_width & 1) {
VAR_9 = GETJSAMPLE(*VAR_13);
VAR_10 = GETJSAMPLE(*VAR_14);
VAR_6 = VAR_17[VAR_10];
VAR_7 = (int)RIGHT_SHIFT(VAR_20[VAR_9] + VAR_19[VAR_10], VAR_21);
VAR_8 = VAR_18[VAR_9];
VAR_5  = GETJSAMPLE(*VAR_12);
VAR_11[VAR_22] =   VAR_16[VAR_5 + VAR_6];
VAR_11[VAR_23] = VAR_16[VAR_5 + VAR_7];
VAR_11[VAR_24] =  VAR_16[VAR_5 + VAR_8];
#ifdef VAR_25
VAR_11[VAR_25] = 0xFF;
#endif
}
}",,"INLINE
LOCAL(void)
h2v1_merged_upsample_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
                              JDIMENSION in_row_group_ctr,
                              JSAMPARRAY output_buf)
{
  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
  register int y, cred, cgreen, cblue;
  int cb, cr;
  register JSAMPROW outptr;
  JSAMPROW inptr0, inptr1, inptr2;
  JDIMENSION col;
  /* copy these pointers into registers if possible */
  register JSAMPLE *range_limit = cinfo->sample_range_limit;
  int *Crrtab = upsample->Cr_r_tab;
  int *Cbbtab = upsample->Cb_b_tab;
  JLONG *Crgtab = upsample->Cr_g_tab;
  JLONG *Cbgtab = upsample->Cb_g_tab;
  SHIFT_TEMPS

  inptr0 = input_buf[0][in_row_group_ctr];
  inptr1 = input_buf[1][in_row_group_ctr];
  inptr2 = input_buf[2][in_row_group_ctr];
  outptr = output_buf[0];
  /* Loop for each pair of output pixels */
  for (col = cinfo->output_width >> 1; col > 0; col--) {
    /* Do the chroma part of the calculation */
    cb = GETJSAMPLE(*inptr1++);
    cr = GETJSAMPLE(*inptr2++);
    cred = Crrtab[cr];
    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
    cblue = Cbbtab[cb];
    /* Fetch 2 Y values and emit 2 pixels */
    y  = GETJSAMPLE(*inptr0++);
    outptr[RGB_RED] =   range_limit[y + cred];
    outptr[RGB_GREEN] = range_limit[y + cgreen];
    outptr[RGB_BLUE] =  range_limit[y + cblue];
#ifdef RGB_ALPHA
    outptr[RGB_ALPHA] = 0xFF;
#endif
    outptr += RGB_PIXELSIZE;
    y  = GETJSAMPLE(*inptr0++);
    outptr[RGB_RED] =   range_limit[y + cred];
    outptr[RGB_GREEN] = range_limit[y + cgreen];
    outptr[RGB_BLUE] =  range_limit[y + cblue];
#ifdef RGB_ALPHA
    outptr[RGB_ALPHA] = 0xFF;
#endif
    outptr += RGB_PIXELSIZE;
  }
  /* If image width is odd, do the last output column separately */
  if (cinfo->output_width & 1) {
    cb = GETJSAMPLE(*inptr1);
    cr = GETJSAMPLE(*inptr2);
    cred = Crrtab[cr];
    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
    cblue = Cbbtab[cb];
    y  = GETJSAMPLE(*inptr0);
    outptr[RGB_RED] =   range_limit[y + cred];
    outptr[RGB_GREEN] = range_limit[y + cgreen];
    outptr[RGB_BLUE] =  range_limit[y + cblue];
#ifdef RGB_ALPHA
    outptr[RGB_ALPHA] = 0xFF;
#endif
  }
}","INLINE
LOCAL(void)
h2v1_merged_upsample_internal(j_decompress_ptr VAR_0, JSAMPIMAGE VAR_1,
                              JDIMENSION VAR_2,
                              JSAMPARRAY VAR_3)
{
  my_merged_upsample_ptr VAR_4 = (my_merged_upsample_ptr)VAR_0->upsample;
  register int VAR_5, VAR_6, VAR_7, VAR_8;
  int VAR_9, VAR_10;
  register JSAMPROW VAR_11;
  JSAMPROW VAR_12, VAR_13, VAR_14;
  JDIMENSION VAR_15;
  /* COMMENT_0 */
  register JSAMPLE *VAR_16 = VAR_0->sample_range_limit;
  int *VAR_17 = VAR_4->Cr_r_tab;
  int *VAR_18 = VAR_4->Cb_b_tab;
  JLONG *VAR_19 = VAR_4->Cr_g_tab;
  JLONG *VAR_20 = VAR_4->Cb_g_tab;
  SHIFT_TEMPS

  VAR_12 = VAR_1[0][VAR_2];
  VAR_13 = VAR_1[1][VAR_2];
  VAR_14 = VAR_1[2][VAR_2];
  VAR_11 = VAR_3[0];
  /* COMMENT_1 */
  for (VAR_15 = VAR_0->output_width >> 1; VAR_15 > 0; VAR_15--) {
    /* COMMENT_2 */
    VAR_9 = GETJSAMPLE(*VAR_13++);
    VAR_10 = GETJSAMPLE(*VAR_14++);
    VAR_6 = VAR_17[VAR_10];
    VAR_7 = (int)RIGHT_SHIFT(VAR_20[VAR_9] + VAR_19[VAR_10], VAR_21);
    VAR_8 = VAR_18[VAR_9];
    /* COMMENT_3 */
    VAR_5  = GETJSAMPLE(*VAR_12++);
    VAR_11[VAR_22] =   VAR_16[VAR_5 + VAR_6];
    VAR_11[VAR_23] = VAR_16[VAR_5 + VAR_7];
    VAR_11[VAR_24] =  VAR_16[VAR_5 + VAR_8];
#ifdef VAR_25
    VAR_11[VAR_25] = 0xFF;
#endif
    VAR_11 += VAR_26;
    VAR_5  = GETJSAMPLE(*VAR_12++);
    VAR_11[VAR_22] =   VAR_16[VAR_5 + VAR_6];
    VAR_11[VAR_23] = VAR_16[VAR_5 + VAR_7];
    VAR_11[VAR_24] =  VAR_16[VAR_5 + VAR_8];
#ifdef VAR_25
    VAR_11[VAR_25] = 0xFF;
#endif
    VAR_11 += VAR_26;
  }
  /* COMMENT_4 */
  if (VAR_0->output_width & 1) {
    VAR_9 = GETJSAMPLE(*VAR_13);
    VAR_10 = GETJSAMPLE(*VAR_14);
    VAR_6 = VAR_17[VAR_10];
    VAR_7 = (int)RIGHT_SHIFT(VAR_20[VAR_9] + VAR_19[VAR_10], VAR_21);
    VAR_8 = VAR_18[VAR_9];
    VAR_5  = GETJSAMPLE(*VAR_12);
    VAR_11[VAR_22] =   VAR_16[VAR_5 + VAR_6];
    VAR_11[VAR_23] = VAR_16[VAR_5 + VAR_7];
    VAR_11[VAR_24] =  VAR_16[VAR_5 + VAR_8];
#ifdef VAR_25
    VAR_11[VAR_25] = 0xFF;
#endif
  }
}",,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
                               JDIMENSION in_row_group_ctr,
                               JSAMPARRAY output_buf)
 {
-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
   register int y, cred, cgreen, cblue;
   int cb, cr;
   register JSAMPROW outptr;","{'deleted_lines': ['  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;'], 'added_lines': ['  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;']}",True,A crafted input file could cause a null pointer dereference in jcopy_sample_rows() when processed by libjpeg-turbo.,5.5,MEDIUM,1,valid,2020-07-24T02:24:38Z,3
CVE-2020-35538,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libjpeg-turbo,"Fix jpeg_skip_scanlines() segfault w/merged upsamp

The additional segfault mentioned in #244 was due to the fact that
the merged upsamplers use a different private structure than the
non-merged upsamplers.  jpeg_skip_scanlines() was assuming the latter, so
when merged upsampling was enabled, jpeg_skip_scanlines() clobbered one
of the IDCT method pointers in the merged upsampler's private structure.

For reasons unknown, the test image in #441 did not encounter this
segfault (too small?), but it encountered an issue similar to the one
fixed in 5bc43c7821df982f65aa1c738f67fbf7cba8bd69, whereby it was
necessary to set up a dummy postprocessing function in
read_and_discard_scanlines() when merged upsampling was enabled.
Failing to do so caused either a segfault in merged_2v_upsample() (due
to a NULL pointer being passed to jcopy_sample_rows()) or an error
(""Corrupt JPEG data: premature end of data segment""), depending on the
number of scanlines skipped and whether the first scanline skipped was
an odd- or even-numbered row.

Fixes #441
Fixes #244 (for real this time)",9120a247436e84c0b4eea828cb11e8f665fcde30,https://github.com/libjpeg-turbo/libjpeg-turbo/commit/9120a247436e84c0b4eea828cb11e8f665fcde30,jdmrgext.c,h2v2_merged_upsample_internal,"INLINE
LOCAL(void)
h2v2_merged_upsample_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
JDIMENSION in_row_group_ctr,
JSAMPARRAY output_buf)
{
my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
register int y, cred, cgreen, cblue;
int cb, cr;
register JSAMPROW outptr0, outptr1;
JSAMPROW inptr00, inptr01, inptr1, inptr2;
JDIMENSION col;
register JSAMPLE *range_limit = cinfo->sample_range_limit;
int *Crrtab = upsample->Cr_r_tab;
int *Cbbtab = upsample->Cb_b_tab;
JLONG *Crgtab = upsample->Cr_g_tab;
JLONG *Cbgtab = upsample->Cb_g_tab;
SHIFT_TEMPS
inptr00 = input_buf[0][in_row_group_ctr * 2];
inptr01 = input_buf[0][in_row_group_ctr * 2 + 1];
inptr1 = input_buf[1][in_row_group_ctr];
inptr2 = input_buf[2][in_row_group_ctr];
outptr0 = output_buf[0];
outptr1 = output_buf[1];
for (col = cinfo->output_width >> 1; col > 0; col--) {
cb = GETJSAMPLE(*inptr1++);
cr = GETJSAMPLE(*inptr2++);
cred = Crrtab[cr];
cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
cblue = Cbbtab[cb];
y  = GETJSAMPLE(*inptr00++);
outptr0[RGB_RED] =   range_limit[y + cred];
outptr0[RGB_GREEN] = range_limit[y + cgreen];
outptr0[RGB_BLUE] =  range_limit[y + cblue];
#ifdef RGB_ALPHA
outptr0[RGB_ALPHA] = 0xFF;
#endif
outptr0 += RGB_PIXELSIZE;
y  = GETJSAMPLE(*inptr00++);
outptr0[RGB_RED] =   range_limit[y + cred];
outptr0[RGB_GREEN] = range_limit[y + cgreen];
outptr0[RGB_BLUE] =  range_limit[y + cblue];
#ifdef RGB_ALPHA
outptr0[RGB_ALPHA] = 0xFF;
#endif
outptr0 += RGB_PIXELSIZE;
y  = GETJSAMPLE(*inptr01++);
outptr1[RGB_RED] =   range_limit[y + cred];
outptr1[RGB_GREEN] = range_limit[y + cgreen];
outptr1[RGB_BLUE] =  range_limit[y + cblue];
#ifdef RGB_ALPHA
outptr1[RGB_ALPHA] = 0xFF;
#endif
outptr1 += RGB_PIXELSIZE;
y  = GETJSAMPLE(*inptr01++);
outptr1[RGB_RED] =   range_limit[y + cred];
outptr1[RGB_GREEN] = range_limit[y + cgreen];
outptr1[RGB_BLUE] =  range_limit[y + cblue];
#ifdef RGB_ALPHA
outptr1[RGB_ALPHA] = 0xFF;
#endif
outptr1 += RGB_PIXELSIZE;
}
if (cinfo->output_width & 1) {
cb = GETJSAMPLE(*inptr1);
cr = GETJSAMPLE(*inptr2);
cred = Crrtab[cr];
cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
cblue = Cbbtab[cb];
y  = GETJSAMPLE(*inptr00);
outptr0[RGB_RED] =   range_limit[y + cred];
outptr0[RGB_GREEN] = range_limit[y + cgreen];
outptr0[RGB_BLUE] =  range_limit[y + cblue];
#ifdef RGB_ALPHA
outptr0[RGB_ALPHA] = 0xFF;
#endif
y  = GETJSAMPLE(*inptr01);
outptr1[RGB_RED] =   range_limit[y + cred];
outptr1[RGB_GREEN] = range_limit[y + cgreen];
outptr1[RGB_BLUE] =  range_limit[y + cblue];
#ifdef RGB_ALPHA
outptr1[RGB_ALPHA] = 0xFF;
#endif
}
}","INLINE
LOCAL(void)
h2v2_merged_upsample_internal(j_decompress_ptr VAR_0, JSAMPIMAGE VAR_1,
JDIMENSION VAR_2,
JSAMPARRAY VAR_3)
{
my_upsample_ptr VAR_4 = (my_upsample_ptr)VAR_0->upsample;
register int VAR_5, VAR_6, VAR_7, VAR_8;
int VAR_9, VAR_10;
register JSAMPROW VAR_11, VAR_12;
JSAMPROW VAR_13, VAR_14, VAR_15, VAR_16;
JDIMENSION VAR_17;
register JSAMPLE *VAR_18 = VAR_0->sample_range_limit;
int *VAR_19 = VAR_4->Cr_r_tab;
int *VAR_20 = VAR_4->Cb_b_tab;
JLONG *VAR_21 = VAR_4->Cr_g_tab;
JLONG *VAR_22 = VAR_4->Cb_g_tab;
SHIFT_TEMPS
VAR_13 = VAR_1[0][VAR_2 * 2];
VAR_14 = VAR_1[0][VAR_2 * 2 + 1];
VAR_15 = VAR_1[1][VAR_2];
VAR_16 = VAR_1[2][VAR_2];
VAR_11 = VAR_3[0];
VAR_12 = VAR_3[1];
for (VAR_17 = VAR_0->output_width >> 1; VAR_17 > 0; VAR_17--) {
VAR_9 = GETJSAMPLE(*VAR_15++);
VAR_10 = GETJSAMPLE(*VAR_16++);
VAR_6 = VAR_19[VAR_10];
VAR_7 = (int)RIGHT_SHIFT(VAR_22[VAR_9] + VAR_21[VAR_10], VAR_23);
VAR_8 = VAR_20[VAR_9];
VAR_5  = GETJSAMPLE(*VAR_13++);
VAR_11[VAR_24] =   VAR_18[VAR_5 + VAR_6];
VAR_11[VAR_25] = VAR_18[VAR_5 + VAR_7];
VAR_11[VAR_26] =  VAR_18[VAR_5 + VAR_8];
#ifdef VAR_27
VAR_11[VAR_27] = 0xFF;
#endif
VAR_11 += VAR_28;
VAR_5  = GETJSAMPLE(*VAR_13++);
VAR_11[VAR_24] =   VAR_18[VAR_5 + VAR_6];
VAR_11[VAR_25] = VAR_18[VAR_5 + VAR_7];
VAR_11[VAR_26] =  VAR_18[VAR_5 + VAR_8];
#ifdef VAR_27
VAR_11[VAR_27] = 0xFF;
#endif
VAR_11 += VAR_28;
VAR_5  = GETJSAMPLE(*VAR_14++);
VAR_12[VAR_24] =   VAR_18[VAR_5 + VAR_6];
VAR_12[VAR_25] = VAR_18[VAR_5 + VAR_7];
VAR_12[VAR_26] =  VAR_18[VAR_5 + VAR_8];
#ifdef VAR_27
VAR_12[VAR_27] = 0xFF;
#endif
VAR_12 += VAR_28;
VAR_5  = GETJSAMPLE(*VAR_14++);
VAR_12[VAR_24] =   VAR_18[VAR_5 + VAR_6];
VAR_12[VAR_25] = VAR_18[VAR_5 + VAR_7];
VAR_12[VAR_26] =  VAR_18[VAR_5 + VAR_8];
#ifdef VAR_27
VAR_12[VAR_27] = 0xFF;
#endif
VAR_12 += VAR_28;
}
if (VAR_0->output_width & 1) {
VAR_9 = GETJSAMPLE(*VAR_15);
VAR_10 = GETJSAMPLE(*VAR_16);
VAR_6 = VAR_19[VAR_10];
VAR_7 = (int)RIGHT_SHIFT(VAR_22[VAR_9] + VAR_21[VAR_10], VAR_23);
VAR_8 = VAR_20[VAR_9];
VAR_5  = GETJSAMPLE(*VAR_13);
VAR_11[VAR_24] =   VAR_18[VAR_5 + VAR_6];
VAR_11[VAR_25] = VAR_18[VAR_5 + VAR_7];
VAR_11[VAR_26] =  VAR_18[VAR_5 + VAR_8];
#ifdef VAR_27
VAR_11[VAR_27] = 0xFF;
#endif
VAR_5  = GETJSAMPLE(*VAR_14);
VAR_12[VAR_24] =   VAR_18[VAR_5 + VAR_6];
VAR_12[VAR_25] = VAR_18[VAR_5 + VAR_7];
VAR_12[VAR_26] =  VAR_18[VAR_5 + VAR_8];
#ifdef VAR_27
VAR_12[VAR_27] = 0xFF;
#endif
}
}",,"INLINE
LOCAL(void)
h2v2_merged_upsample_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
                              JDIMENSION in_row_group_ctr,
                              JSAMPARRAY output_buf)
{
  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
  register int y, cred, cgreen, cblue;
  int cb, cr;
  register JSAMPROW outptr0, outptr1;
  JSAMPROW inptr00, inptr01, inptr1, inptr2;
  JDIMENSION col;
  /* copy these pointers into registers if possible */
  register JSAMPLE *range_limit = cinfo->sample_range_limit;
  int *Crrtab = upsample->Cr_r_tab;
  int *Cbbtab = upsample->Cb_b_tab;
  JLONG *Crgtab = upsample->Cr_g_tab;
  JLONG *Cbgtab = upsample->Cb_g_tab;
  SHIFT_TEMPS

  inptr00 = input_buf[0][in_row_group_ctr * 2];
  inptr01 = input_buf[0][in_row_group_ctr * 2 + 1];
  inptr1 = input_buf[1][in_row_group_ctr];
  inptr2 = input_buf[2][in_row_group_ctr];
  outptr0 = output_buf[0];
  outptr1 = output_buf[1];
  /* Loop for each group of output pixels */
  for (col = cinfo->output_width >> 1; col > 0; col--) {
    /* Do the chroma part of the calculation */
    cb = GETJSAMPLE(*inptr1++);
    cr = GETJSAMPLE(*inptr2++);
    cred = Crrtab[cr];
    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
    cblue = Cbbtab[cb];
    /* Fetch 4 Y values and emit 4 pixels */
    y  = GETJSAMPLE(*inptr00++);
    outptr0[RGB_RED] =   range_limit[y + cred];
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
#ifdef RGB_ALPHA
    outptr0[RGB_ALPHA] = 0xFF;
#endif
    outptr0 += RGB_PIXELSIZE;
    y  = GETJSAMPLE(*inptr00++);
    outptr0[RGB_RED] =   range_limit[y + cred];
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
#ifdef RGB_ALPHA
    outptr0[RGB_ALPHA] = 0xFF;
#endif
    outptr0 += RGB_PIXELSIZE;
    y  = GETJSAMPLE(*inptr01++);
    outptr1[RGB_RED] =   range_limit[y + cred];
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
#ifdef RGB_ALPHA
    outptr1[RGB_ALPHA] = 0xFF;
#endif
    outptr1 += RGB_PIXELSIZE;
    y  = GETJSAMPLE(*inptr01++);
    outptr1[RGB_RED] =   range_limit[y + cred];
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
#ifdef RGB_ALPHA
    outptr1[RGB_ALPHA] = 0xFF;
#endif
    outptr1 += RGB_PIXELSIZE;
  }
  /* If image width is odd, do the last output column separately */
  if (cinfo->output_width & 1) {
    cb = GETJSAMPLE(*inptr1);
    cr = GETJSAMPLE(*inptr2);
    cred = Crrtab[cr];
    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
    cblue = Cbbtab[cb];
    y  = GETJSAMPLE(*inptr00);
    outptr0[RGB_RED] =   range_limit[y + cred];
    outptr0[RGB_GREEN] = range_limit[y + cgreen];
    outptr0[RGB_BLUE] =  range_limit[y + cblue];
#ifdef RGB_ALPHA
    outptr0[RGB_ALPHA] = 0xFF;
#endif
    y  = GETJSAMPLE(*inptr01);
    outptr1[RGB_RED] =   range_limit[y + cred];
    outptr1[RGB_GREEN] = range_limit[y + cgreen];
    outptr1[RGB_BLUE] =  range_limit[y + cblue];
#ifdef RGB_ALPHA
    outptr1[RGB_ALPHA] = 0xFF;
#endif
  }
}","INLINE
LOCAL(void)
h2v2_merged_upsample_internal(j_decompress_ptr VAR_0, JSAMPIMAGE VAR_1,
                              JDIMENSION VAR_2,
                              JSAMPARRAY VAR_3)
{
  my_merged_upsample_ptr VAR_4 = (my_merged_upsample_ptr)VAR_0->upsample;
  register int VAR_5, VAR_6, VAR_7, VAR_8;
  int VAR_9, VAR_10;
  register JSAMPROW VAR_11, VAR_12;
  JSAMPROW VAR_13, VAR_14, VAR_15, VAR_16;
  JDIMENSION VAR_17;
  /* COMMENT_0 */
  register JSAMPLE *VAR_18 = VAR_0->sample_range_limit;
  int *VAR_19 = VAR_4->Cr_r_tab;
  int *VAR_20 = VAR_4->Cb_b_tab;
  JLONG *VAR_21 = VAR_4->Cr_g_tab;
  JLONG *VAR_22 = VAR_4->Cb_g_tab;
  SHIFT_TEMPS

  VAR_13 = VAR_1[0][VAR_2 * 2];
  VAR_14 = VAR_1[0][VAR_2 * 2 + 1];
  VAR_15 = VAR_1[1][VAR_2];
  VAR_16 = VAR_1[2][VAR_2];
  VAR_11 = VAR_3[0];
  VAR_12 = VAR_3[1];
  /* COMMENT_1 */
  for (VAR_17 = VAR_0->output_width >> 1; VAR_17 > 0; VAR_17--) {
    /* COMMENT_2 */
    VAR_9 = GETJSAMPLE(*VAR_15++);
    VAR_10 = GETJSAMPLE(*VAR_16++);
    VAR_6 = VAR_19[VAR_10];
    VAR_7 = (int)RIGHT_SHIFT(VAR_22[VAR_9] + VAR_21[VAR_10], VAR_23);
    VAR_8 = VAR_20[VAR_9];
    /* COMMENT_3 */
    VAR_5  = GETJSAMPLE(*VAR_13++);
    VAR_11[VAR_24] =   VAR_18[VAR_5 + VAR_6];
    VAR_11[VAR_25] = VAR_18[VAR_5 + VAR_7];
    VAR_11[VAR_26] =  VAR_18[VAR_5 + VAR_8];
#ifdef VAR_27
    VAR_11[VAR_27] = 0xFF;
#endif
    VAR_11 += VAR_28;
    VAR_5  = GETJSAMPLE(*VAR_13++);
    VAR_11[VAR_24] =   VAR_18[VAR_5 + VAR_6];
    VAR_11[VAR_25] = VAR_18[VAR_5 + VAR_7];
    VAR_11[VAR_26] =  VAR_18[VAR_5 + VAR_8];
#ifdef VAR_27
    VAR_11[VAR_27] = 0xFF;
#endif
    VAR_11 += VAR_28;
    VAR_5  = GETJSAMPLE(*VAR_14++);
    VAR_12[VAR_24] =   VAR_18[VAR_5 + VAR_6];
    VAR_12[VAR_25] = VAR_18[VAR_5 + VAR_7];
    VAR_12[VAR_26] =  VAR_18[VAR_5 + VAR_8];
#ifdef VAR_27
    VAR_12[VAR_27] = 0xFF;
#endif
    VAR_12 += VAR_28;
    VAR_5  = GETJSAMPLE(*VAR_14++);
    VAR_12[VAR_24] =   VAR_18[VAR_5 + VAR_6];
    VAR_12[VAR_25] = VAR_18[VAR_5 + VAR_7];
    VAR_12[VAR_26] =  VAR_18[VAR_5 + VAR_8];
#ifdef VAR_27
    VAR_12[VAR_27] = 0xFF;
#endif
    VAR_12 += VAR_28;
  }
  /* COMMENT_4 */
  if (VAR_0->output_width & 1) {
    VAR_9 = GETJSAMPLE(*VAR_15);
    VAR_10 = GETJSAMPLE(*VAR_16);
    VAR_6 = VAR_19[VAR_10];
    VAR_7 = (int)RIGHT_SHIFT(VAR_22[VAR_9] + VAR_21[VAR_10], VAR_23);
    VAR_8 = VAR_20[VAR_9];
    VAR_5  = GETJSAMPLE(*VAR_13);
    VAR_11[VAR_24] =   VAR_18[VAR_5 + VAR_6];
    VAR_11[VAR_25] = VAR_18[VAR_5 + VAR_7];
    VAR_11[VAR_26] =  VAR_18[VAR_5 + VAR_8];
#ifdef VAR_27
    VAR_11[VAR_27] = 0xFF;
#endif
    VAR_5  = GETJSAMPLE(*VAR_14);
    VAR_12[VAR_24] =   VAR_18[VAR_5 + VAR_6];
    VAR_12[VAR_25] = VAR_18[VAR_5 + VAR_7];
    VAR_12[VAR_26] =  VAR_18[VAR_5 + VAR_8];
#ifdef VAR_27
    VAR_12[VAR_27] = 0xFF;
#endif
  }
}",,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
                               JDIMENSION in_row_group_ctr,
                               JSAMPARRAY output_buf)
 {
-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
   register int y, cred, cgreen, cblue;
   int cb, cr;
   register JSAMPROW outptr0, outptr1;","{'deleted_lines': ['  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;'], 'added_lines': ['  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;']}",True,A crafted input file could cause a null pointer dereference in jcopy_sample_rows() when processed by libjpeg-turbo.,5.5,MEDIUM,1,valid,2020-07-24T02:24:38Z,3
CVE-2020-35538,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libjpeg-turbo,"Fix jpeg_skip_scanlines() segfault w/merged upsamp

The additional segfault mentioned in #244 was due to the fact that
the merged upsamplers use a different private structure than the
non-merged upsamplers.  jpeg_skip_scanlines() was assuming the latter, so
when merged upsampling was enabled, jpeg_skip_scanlines() clobbered one
of the IDCT method pointers in the merged upsampler's private structure.

For reasons unknown, the test image in #441 did not encounter this
segfault (too small?), but it encountered an issue similar to the one
fixed in 5bc43c7821df982f65aa1c738f67fbf7cba8bd69, whereby it was
necessary to set up a dummy postprocessing function in
read_and_discard_scanlines() when merged upsampling was enabled.
Failing to do so caused either a segfault in merged_2v_upsample() (due
to a NULL pointer being passed to jcopy_sample_rows()) or an error
(""Corrupt JPEG data: premature end of data segment""), depending on the
number of scanlines skipped and whether the first scanline skipped was
an odd- or even-numbered row.

Fixes #441
Fixes #244 (for real this time)",9120a247436e84c0b4eea828cb11e8f665fcde30,https://github.com/libjpeg-turbo/libjpeg-turbo/commit/9120a247436e84c0b4eea828cb11e8f665fcde30,jdmerge.c,merged_1v_upsample,"METHODDEF(void)
merged_1v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
JDIMENSION *in_row_group_ctr,
JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,
JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)
{
my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
(*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,
output_buf + *out_row_ctr);
(*out_row_ctr)++;
(*in_row_group_ctr)++;
}","VAR_0(void)
merged_1v_upsample(j_decompress_ptr VAR_1, JSAMPIMAGE VAR_2,
JDIMENSION *VAR_3,
JDIMENSION VAR_4, JSAMPARRAY VAR_5,
JDIMENSION *VAR_6, JDIMENSION VAR_7)
{
my_upsample_ptr VAR_8 = (my_upsample_ptr)VAR_1->upsample;
(*VAR_8->upmethod) (VAR_1, VAR_2, *VAR_3,
VAR_5 + *VAR_6);
(*VAR_6)++;
(*VAR_3)++;
}",,"METHODDEF(void)
merged_1v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
                   JDIMENSION *in_row_group_ctr,
                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,
                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)
/* 1:1 vertical sampling case: much easier, never need a spare row. */
{
  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;

  /* Just do the upsampling. */
  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,
                         output_buf + *out_row_ctr);
  /* Adjust counts */
  (*out_row_ctr)++;
  (*in_row_group_ctr)++;
}","VAR_0(void)
merged_1v_upsample(j_decompress_ptr VAR_1, JSAMPIMAGE VAR_2,
                   JDIMENSION *VAR_3,
                   JDIMENSION VAR_4, JSAMPARRAY VAR_5,
                   JDIMENSION *VAR_6, JDIMENSION VAR_7)
/* COMMENT_0 */
{
  my_merged_upsample_ptr VAR_8 = (my_merged_upsample_ptr)VAR_1->upsample;

  /* COMMENT_1 */
  (*VAR_8->upmethod) (VAR_1, VAR_2, *VAR_3,
                         VAR_5 + *VAR_6);
  /* COMMENT_2 */
  (*VAR_6)++;
  (*VAR_3)++;
}",,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
                    JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)
 /* 1:1 vertical sampling case: much easier, never need a spare row. */
 {
-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
 
   /* Just do the upsampling. */
   (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,","{'deleted_lines': ['  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;'], 'added_lines': ['  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;']}",True,A crafted input file could cause a null pointer dereference in jcopy_sample_rows() when processed by libjpeg-turbo.,5.5,MEDIUM,1,valid,2020-07-24T02:24:38Z,3
CVE-2020-35538,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libjpeg-turbo,"Fix jpeg_skip_scanlines() segfault w/merged upsamp

The additional segfault mentioned in #244 was due to the fact that
the merged upsamplers use a different private structure than the
non-merged upsamplers.  jpeg_skip_scanlines() was assuming the latter, so
when merged upsampling was enabled, jpeg_skip_scanlines() clobbered one
of the IDCT method pointers in the merged upsampler's private structure.

For reasons unknown, the test image in #441 did not encounter this
segfault (too small?), but it encountered an issue similar to the one
fixed in 5bc43c7821df982f65aa1c738f67fbf7cba8bd69, whereby it was
necessary to set up a dummy postprocessing function in
read_and_discard_scanlines() when merged upsampling was enabled.
Failing to do so caused either a segfault in merged_2v_upsample() (due
to a NULL pointer being passed to jcopy_sample_rows()) or an error
(""Corrupt JPEG data: premature end of data segment""), depending on the
number of scanlines skipped and whether the first scanline skipped was
an odd- or even-numbered row.

Fixes #441
Fixes #244 (for real this time)",9120a247436e84c0b4eea828cb11e8f665fcde30,https://github.com/libjpeg-turbo/libjpeg-turbo/commit/9120a247436e84c0b4eea828cb11e8f665fcde30,jdmerge.c,jinit_merged_upsampler,"GLOBAL(void)
jinit_merged_upsampler(j_decompress_ptr cinfo)
{
my_upsample_ptr upsample;
upsample = (my_upsample_ptr)
(*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,
sizeof(my_upsampler));
cinfo->upsample = (struct jpeg_upsampler *)upsample;
upsample->pub.start_pass = start_pass_merged_upsample;
upsample->pub.need_context_rows = FALSE;
upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;
if (cinfo->max_v_samp_factor == 2) {
upsample->pub.upsample = merged_2v_upsample;
if (jsimd_can_h2v2_merged_upsample())
upsample->upmethod = jsimd_h2v2_merged_upsample;
else
upsample->upmethod = h2v2_merged_upsample;
if (cinfo->out_color_space == JCS_RGB565) {
if (cinfo->dither_mode != JDITHER_NONE) {
upsample->upmethod = h2v2_merged_upsample_565D;
} else {
upsample->upmethod = h2v2_merged_upsample_565;
}
}
upsample->spare_row = (JSAMPROW)
(*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE,
(size_t)(upsample->out_row_width * sizeof(JSAMPLE)));
} else {
upsample->pub.upsample = merged_1v_upsample;
if (jsimd_can_h2v1_merged_upsample())
upsample->upmethod = jsimd_h2v1_merged_upsample;
else
upsample->upmethod = h2v1_merged_upsample;
if (cinfo->out_color_space == JCS_RGB565) {
if (cinfo->dither_mode != JDITHER_NONE) {
upsample->upmethod = h2v1_merged_upsample_565D;
} else {
upsample->upmethod = h2v1_merged_upsample_565;
}
}
upsample->spare_row = NULL;
}
build_ycc_rgb_table(cinfo);
}","VAR_0(void)
jinit_merged_upsampler(j_decompress_ptr VAR_1)
{
my_upsample_ptr VAR_2;
VAR_2 = (my_upsample_ptr)
(*VAR_1->mem->alloc_small) ((j_common_ptr)VAR_1, VAR_3,
sizeof(VAR_4));
VAR_1->upsample = (struct jpeg_upsampler *)VAR_2;
VAR_2->pub.start_pass = VAR_5;
VAR_2->pub.need_context_rows = FALSE;
VAR_2->out_row_width = VAR_1->output_width * VAR_1->out_color_components;
if (VAR_1->max_v_samp_factor == 2) {
VAR_2->pub.upsample = VAR_6;
if (jsimd_can_h2v2_merged_upsample())
VAR_2->upmethod = VAR_7;
else
VAR_2->upmethod = VAR_8;
if (VAR_1->out_color_space == VAR_9) {
if (VAR_1->dither_mode != VAR_10) {
VAR_2->upmethod = VAR_11;
} else {
VAR_2->upmethod = VAR_12;
}
}
VAR_2->spare_row = (VAR_13)
(*VAR_1->mem->alloc_large) ((j_common_ptr)VAR_1, VAR_3,
(size_t)(VAR_2->out_row_width * sizeof(VAR_14)));
} else {
VAR_2->pub.upsample = VAR_15;
if (jsimd_can_h2v1_merged_upsample())
VAR_2->upmethod = VAR_16;
else
VAR_2->upmethod = VAR_17;
if (VAR_1->out_color_space == VAR_9) {
if (VAR_1->dither_mode != VAR_10) {
VAR_2->upmethod = VAR_18;
} else {
VAR_2->upmethod = VAR_19;
}
}
VAR_2->spare_row = NULL;
}
build_ycc_rgb_table(VAR_1);
}",,"GLOBAL(void)
jinit_merged_upsampler(j_decompress_ptr cinfo)
{
  my_merged_upsample_ptr upsample;

  upsample = (my_merged_upsample_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,
                                sizeof(my_merged_upsampler));
  cinfo->upsample = (struct jpeg_upsampler *)upsample;
  upsample->pub.start_pass = start_pass_merged_upsample;
  upsample->pub.need_context_rows = FALSE;

  upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;

  if (cinfo->max_v_samp_factor == 2) {
    upsample->pub.upsample = merged_2v_upsample;
    if (jsimd_can_h2v2_merged_upsample())
      upsample->upmethod = jsimd_h2v2_merged_upsample;
    else
      upsample->upmethod = h2v2_merged_upsample;
    if (cinfo->out_color_space == JCS_RGB565) {
      if (cinfo->dither_mode != JDITHER_NONE) {
        upsample->upmethod = h2v2_merged_upsample_565D;
      } else {
        upsample->upmethod = h2v2_merged_upsample_565;
      }
    }
    /* Allocate a spare row buffer */
    upsample->spare_row = (JSAMPROW)
      (*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE,
                (size_t)(upsample->out_row_width * sizeof(JSAMPLE)));
  } else {
    upsample->pub.upsample = merged_1v_upsample;
    if (jsimd_can_h2v1_merged_upsample())
      upsample->upmethod = jsimd_h2v1_merged_upsample;
    else
      upsample->upmethod = h2v1_merged_upsample;
    if (cinfo->out_color_space == JCS_RGB565) {
      if (cinfo->dither_mode != JDITHER_NONE) {
        upsample->upmethod = h2v1_merged_upsample_565D;
      } else {
        upsample->upmethod = h2v1_merged_upsample_565;
      }
    }
    /* No spare row needed */
    upsample->spare_row = NULL;
  }

  build_ycc_rgb_table(cinfo);
}","VAR_0(void)
jinit_merged_upsampler(j_decompress_ptr VAR_1)
{
  my_merged_upsample_ptr VAR_2;

  VAR_2 = (my_merged_upsample_ptr)
    (*VAR_1->mem->alloc_small) ((j_common_ptr)VAR_1, VAR_3,
                                sizeof(VAR_4));
  VAR_1->upsample = (struct jpeg_upsampler *)VAR_2;
  VAR_2->pub.start_pass = VAR_5;
  VAR_2->pub.need_context_rows = FALSE;

  VAR_2->out_row_width = VAR_1->output_width * VAR_1->out_color_components;

  if (VAR_1->max_v_samp_factor == 2) {
    VAR_2->pub.upsample = VAR_6;
    if (jsimd_can_h2v2_merged_upsample())
      VAR_2->upmethod = VAR_7;
    else
      VAR_2->upmethod = VAR_8;
    if (VAR_1->out_color_space == VAR_9) {
      if (VAR_1->dither_mode != VAR_10) {
        VAR_2->upmethod = VAR_11;
      } else {
        VAR_2->upmethod = VAR_12;
      }
    }
    /* COMMENT_0 */
    VAR_2->spare_row = (VAR_13)
      (*VAR_1->mem->alloc_large) ((j_common_ptr)VAR_1, VAR_3,
                (size_t)(VAR_2->out_row_width * sizeof(VAR_14)));
  } else {
    VAR_2->pub.upsample = VAR_15;
    if (jsimd_can_h2v1_merged_upsample())
      VAR_2->upmethod = VAR_16;
    else
      VAR_2->upmethod = VAR_17;
    if (VAR_1->out_color_space == VAR_9) {
      if (VAR_1->dither_mode != VAR_10) {
        VAR_2->upmethod = VAR_18;
      } else {
        VAR_2->upmethod = VAR_19;
      }
    }
    /* COMMENT_1 */
    VAR_2->spare_row = NULL;
  }

  build_ycc_rgb_table(VAR_1);
}",,"--- func_before
+++ func_after
@@ -1,11 +1,11 @@
 GLOBAL(void)
 jinit_merged_upsampler(j_decompress_ptr cinfo)
 {
-  my_upsample_ptr upsample;
+  my_merged_upsample_ptr upsample;
 
-  upsample = (my_upsample_ptr)
+  upsample = (my_merged_upsample_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,
-                                sizeof(my_upsampler));
+                                sizeof(my_merged_upsampler));
   cinfo->upsample = (struct jpeg_upsampler *)upsample;
   upsample->pub.start_pass = start_pass_merged_upsample;
   upsample->pub.need_context_rows = FALSE;","{'deleted_lines': ['  my_upsample_ptr upsample;', '  upsample = (my_upsample_ptr)', '                                sizeof(my_upsampler));'], 'added_lines': ['  my_merged_upsample_ptr upsample;', '  upsample = (my_merged_upsample_ptr)', '                                sizeof(my_merged_upsampler));']}",True,A crafted input file could cause a null pointer dereference in jcopy_sample_rows() when processed by libjpeg-turbo.,5.5,MEDIUM,1,valid,2020-07-24T02:24:38Z,3
CVE-2020-35538,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libjpeg-turbo,"Fix jpeg_skip_scanlines() segfault w/merged upsamp

The additional segfault mentioned in #244 was due to the fact that
the merged upsamplers use a different private structure than the
non-merged upsamplers.  jpeg_skip_scanlines() was assuming the latter, so
when merged upsampling was enabled, jpeg_skip_scanlines() clobbered one
of the IDCT method pointers in the merged upsampler's private structure.

For reasons unknown, the test image in #441 did not encounter this
segfault (too small?), but it encountered an issue similar to the one
fixed in 5bc43c7821df982f65aa1c738f67fbf7cba8bd69, whereby it was
necessary to set up a dummy postprocessing function in
read_and_discard_scanlines() when merged upsampling was enabled.
Failing to do so caused either a segfault in merged_2v_upsample() (due
to a NULL pointer being passed to jcopy_sample_rows()) or an error
(""Corrupt JPEG data: premature end of data segment""), depending on the
number of scanlines skipped and whether the first scanline skipped was
an odd- or even-numbered row.

Fixes #441
Fixes #244 (for real this time)",9120a247436e84c0b4eea828cb11e8f665fcde30,https://github.com/libjpeg-turbo/libjpeg-turbo/commit/9120a247436e84c0b4eea828cb11e8f665fcde30,jdmerge.c,merged_2v_upsample,"METHODDEF(void)
merged_2v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
JDIMENSION *in_row_group_ctr,
JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,
JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)
{
my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
JSAMPROW work_ptrs[2];
JDIMENSION num_rows;          
if (upsample->spare_full) {
JDIMENSION size = upsample->out_row_width;
if (cinfo->out_color_space == JCS_RGB565)
size = cinfo->output_width * 2;
jcopy_sample_rows(&upsample->spare_row, 0, output_buf + *out_row_ctr, 0, 1,
size);
num_rows = 1;
upsample->spare_full = FALSE;
} else {
num_rows = 2;
if (num_rows > upsample->rows_to_go)
num_rows = upsample->rows_to_go;
out_rows_avail -= *out_row_ctr;
if (num_rows > out_rows_avail)
num_rows = out_rows_avail;
work_ptrs[0] = output_buf[*out_row_ctr];
if (num_rows > 1) {
work_ptrs[1] = output_buf[*out_row_ctr + 1];
} else {
work_ptrs[1] = upsample->spare_row;
upsample->spare_full = TRUE;
}
(*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);
}
*out_row_ctr += num_rows;
upsample->rows_to_go -= num_rows;
if (!upsample->spare_full)
(*in_row_group_ctr)++;
}","VAR_0(void)
merged_2v_upsample(j_decompress_ptr VAR_1, JSAMPIMAGE VAR_2,
JDIMENSION *VAR_3,
JDIMENSION VAR_4, JSAMPARRAY VAR_5,
JDIMENSION *VAR_6, JDIMENSION VAR_7)
{
my_upsample_ptr VAR_8 = (my_upsample_ptr)VAR_1->upsample;
JSAMPROW VAR_9[2];
JDIMENSION VAR_10;          
if (VAR_8->spare_full) {
JDIMENSION VAR_11 = VAR_8->out_row_width;
if (VAR_1->out_color_space == VAR_12)
VAR_11 = VAR_1->output_width * 2;
jcopy_sample_rows(&VAR_8->spare_row, 0, VAR_5 + *VAR_6, 0, 1,
VAR_11);
VAR_10 = 1;
VAR_8->spare_full = FALSE;
} else {
VAR_10 = 2;
if (VAR_10 > VAR_8->rows_to_go)
VAR_10 = VAR_8->rows_to_go;
VAR_7 -= *VAR_6;
if (VAR_10 > VAR_7)
VAR_10 = VAR_7;
VAR_9[0] = VAR_5[*VAR_6];
if (VAR_10 > 1) {
VAR_9[1] = VAR_5[*VAR_6 + 1];
} else {
VAR_9[1] = VAR_8->spare_row;
VAR_8->spare_full = TRUE;
}
(*VAR_8->upmethod) (VAR_1, VAR_2, *VAR_3, VAR_9);
}
*VAR_6 += VAR_10;
VAR_8->rows_to_go -= VAR_10;
if (!VAR_8->spare_full)
(*VAR_3)++;
}",,"METHODDEF(void)
merged_2v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
                   JDIMENSION *in_row_group_ctr,
                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,
                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)
/* 2:1 vertical sampling case: may need a spare row. */
{
  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
  JSAMPROW work_ptrs[2];
  JDIMENSION num_rows;          /* number of rows returned to caller */

  if (upsample->spare_full) {
    /* If we have a spare row saved from a previous cycle, just return it. */
    JDIMENSION size = upsample->out_row_width;
    if (cinfo->out_color_space == JCS_RGB565)
      size = cinfo->output_width * 2;
    jcopy_sample_rows(&upsample->spare_row, 0, output_buf + *out_row_ctr, 0, 1,
                      size);
    num_rows = 1;
    upsample->spare_full = FALSE;
  } else {
    /* Figure number of rows to return to caller. */
    num_rows = 2;
    /* Not more than the distance to the end of the image. */
    if (num_rows > upsample->rows_to_go)
      num_rows = upsample->rows_to_go;
    /* And not more than what the client can accept: */
    out_rows_avail -= *out_row_ctr;
    if (num_rows > out_rows_avail)
      num_rows = out_rows_avail;
    /* Create output pointer array for upsampler. */
    work_ptrs[0] = output_buf[*out_row_ctr];
    if (num_rows > 1) {
      work_ptrs[1] = output_buf[*out_row_ctr + 1];
    } else {
      work_ptrs[1] = upsample->spare_row;
      upsample->spare_full = TRUE;
    }
    /* Now do the upsampling. */
    (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);
  }

  /* Adjust counts */
  *out_row_ctr += num_rows;
  upsample->rows_to_go -= num_rows;
  /* When the buffer is emptied, declare this input row group consumed */
  if (!upsample->spare_full)
    (*in_row_group_ctr)++;
}","VAR_0(void)
merged_2v_upsample(j_decompress_ptr VAR_1, JSAMPIMAGE VAR_2,
                   JDIMENSION *VAR_3,
                   JDIMENSION VAR_4, JSAMPARRAY VAR_5,
                   JDIMENSION *VAR_6, JDIMENSION VAR_7)
/* COMMENT_0 */
{
  my_merged_upsample_ptr VAR_8 = (my_merged_upsample_ptr)VAR_1->upsample;
  JSAMPROW VAR_9[2];
  JDIMENSION VAR_10;          /* COMMENT_1 */

  if (VAR_8->spare_full) {
    /* COMMENT_2 */
    JDIMENSION VAR_11 = VAR_8->out_row_width;
    if (VAR_1->out_color_space == VAR_12)
      VAR_11 = VAR_1->output_width * 2;
    jcopy_sample_rows(&VAR_8->spare_row, 0, VAR_5 + *VAR_6, 0, 1,
                      VAR_11);
    VAR_10 = 1;
    VAR_8->spare_full = FALSE;
  } else {
    /* COMMENT_3 */
    VAR_10 = 2;
    /* COMMENT_4 */
    if (VAR_10 > VAR_8->rows_to_go)
      VAR_10 = VAR_8->rows_to_go;
    /* COMMENT_5 */
    VAR_7 -= *VAR_6;
    if (VAR_10 > VAR_7)
      VAR_10 = VAR_7;
    /* COMMENT_6 */
    VAR_9[0] = VAR_5[*VAR_6];
    if (VAR_10 > 1) {
      VAR_9[1] = VAR_5[*VAR_6 + 1];
    } else {
      VAR_9[1] = VAR_8->spare_row;
      VAR_8->spare_full = TRUE;
    }
    /* COMMENT_7 */
    (*VAR_8->upmethod) (VAR_1, VAR_2, *VAR_3, VAR_9);
  }

  /* COMMENT_8 */
  *VAR_6 += VAR_10;
  VAR_8->rows_to_go -= VAR_10;
  /* COMMENT_9 */
  if (!VAR_8->spare_full)
    (*VAR_3)++;
}",,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
                    JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)
 /* 2:1 vertical sampling case: may need a spare row. */
 {
-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
   JSAMPROW work_ptrs[2];
   JDIMENSION num_rows;          /* number of rows returned to caller */
 ","{'deleted_lines': ['  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;'], 'added_lines': ['  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;']}",True,A crafted input file could cause a null pointer dereference in jcopy_sample_rows() when processed by libjpeg-turbo.,5.5,MEDIUM,1,valid,2020-07-24T02:24:38Z,3
CVE-2020-35538,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libjpeg-turbo,"Fix jpeg_skip_scanlines() segfault w/merged upsamp

The additional segfault mentioned in #244 was due to the fact that
the merged upsamplers use a different private structure than the
non-merged upsamplers.  jpeg_skip_scanlines() was assuming the latter, so
when merged upsampling was enabled, jpeg_skip_scanlines() clobbered one
of the IDCT method pointers in the merged upsampler's private structure.

For reasons unknown, the test image in #441 did not encounter this
segfault (too small?), but it encountered an issue similar to the one
fixed in 5bc43c7821df982f65aa1c738f67fbf7cba8bd69, whereby it was
necessary to set up a dummy postprocessing function in
read_and_discard_scanlines() when merged upsampling was enabled.
Failing to do so caused either a segfault in merged_2v_upsample() (due
to a NULL pointer being passed to jcopy_sample_rows()) or an error
(""Corrupt JPEG data: premature end of data segment""), depending on the
number of scanlines skipped and whether the first scanline skipped was
an odd- or even-numbered row.

Fixes #441
Fixes #244 (for real this time)",9120a247436e84c0b4eea828cb11e8f665fcde30,https://github.com/libjpeg-turbo/libjpeg-turbo/commit/9120a247436e84c0b4eea828cb11e8f665fcde30,jdmerge.c,start_pass_merged_upsample,"METHODDEF(void)
start_pass_merged_upsample(j_decompress_ptr cinfo)
{
my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
upsample->spare_full = FALSE;
upsample->rows_to_go = cinfo->output_height;
}","VAR_0(void)
start_pass_merged_upsample(j_decompress_ptr VAR_1)
{
my_upsample_ptr VAR_2 = (my_upsample_ptr)VAR_1->upsample;
VAR_2->spare_full = FALSE;
VAR_2->rows_to_go = VAR_1->output_height;
}",,"METHODDEF(void)
start_pass_merged_upsample(j_decompress_ptr cinfo)
{
  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;

  /* Mark the spare buffer empty */
  upsample->spare_full = FALSE;
  /* Initialize total-height counter for detecting bottom of image */
  upsample->rows_to_go = cinfo->output_height;
}","VAR_0(void)
start_pass_merged_upsample(j_decompress_ptr VAR_1)
{
  my_merged_upsample_ptr VAR_2 = (my_merged_upsample_ptr)VAR_1->upsample;

  /* COMMENT_0 */
  VAR_2->spare_full = FALSE;
  /* COMMENT_1 */
  VAR_2->rows_to_go = VAR_1->output_height;
}",,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 METHODDEF(void)
 start_pass_merged_upsample(j_decompress_ptr cinfo)
 {
-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
 
   /* Mark the spare buffer empty */
   upsample->spare_full = FALSE;","{'deleted_lines': ['  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;'], 'added_lines': ['  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;']}",True,A crafted input file could cause a null pointer dereference in jcopy_sample_rows() when processed by libjpeg-turbo.,5.5,MEDIUM,1,valid,2020-07-24T02:24:38Z,3
CVE-2020-35538,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libjpeg-turbo,"Fix jpeg_skip_scanlines() segfault w/merged upsamp

The additional segfault mentioned in #244 was due to the fact that
the merged upsamplers use a different private structure than the
non-merged upsamplers.  jpeg_skip_scanlines() was assuming the latter, so
when merged upsampling was enabled, jpeg_skip_scanlines() clobbered one
of the IDCT method pointers in the merged upsampler's private structure.

For reasons unknown, the test image in #441 did not encounter this
segfault (too small?), but it encountered an issue similar to the one
fixed in 5bc43c7821df982f65aa1c738f67fbf7cba8bd69, whereby it was
necessary to set up a dummy postprocessing function in
read_and_discard_scanlines() when merged upsampling was enabled.
Failing to do so caused either a segfault in merged_2v_upsample() (due
to a NULL pointer being passed to jcopy_sample_rows()) or an error
(""Corrupt JPEG data: premature end of data segment""), depending on the
number of scanlines skipped and whether the first scanline skipped was
an odd- or even-numbered row.

Fixes #441
Fixes #244 (for real this time)",9120a247436e84c0b4eea828cb11e8f665fcde30,https://github.com/libjpeg-turbo/libjpeg-turbo/commit/9120a247436e84c0b4eea828cb11e8f665fcde30,jdmerge.c,build_ycc_rgb_table,"LOCAL(void)
build_ycc_rgb_table(j_decompress_ptr cinfo)
{
my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
int i;
JLONG x;
SHIFT_TEMPS
upsample->Cr_r_tab = (int *)
(*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,
(MAXJSAMPLE + 1) * sizeof(int));
upsample->Cb_b_tab = (int *)
(*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,
(MAXJSAMPLE + 1) * sizeof(int));
upsample->Cr_g_tab = (JLONG *)
(*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,
(MAXJSAMPLE + 1) * sizeof(JLONG));
upsample->Cb_g_tab = (JLONG *)
(*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,
(MAXJSAMPLE + 1) * sizeof(JLONG));
for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
upsample->Cr_r_tab[i] = (int)
RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
upsample->Cb_b_tab[i] = (int)
RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
upsample->Cr_g_tab[i] = (-FIX(0.71414)) * x;
upsample->Cb_g_tab[i] = (-FIX(0.34414)) * x + ONE_HALF;
}
}","VAR_0(void)
build_ycc_rgb_table(j_decompress_ptr VAR_1)
{
my_upsample_ptr VAR_2 = (my_upsample_ptr)VAR_1->upsample;
int VAR_3;
JLONG VAR_4;
SHIFT_TEMPS
VAR_2->VAR_5 = (int *)
(*VAR_1->mem->alloc_small) ((j_common_ptr)VAR_1, VAR_6,
(VAR_7 + 1) * sizeof(int));
VAR_2->Cb_b_tab = (int *)
(*VAR_1->mem->alloc_small) ((j_common_ptr)VAR_1, VAR_6,
(VAR_7 + 1) * sizeof(int));
VAR_2->Cr_g_tab = (JLONG *)
(*VAR_1->mem->alloc_small) ((j_common_ptr)VAR_1, VAR_6,
(VAR_7 + 1) * sizeof(JLONG));
VAR_2->Cb_g_tab = (JLONG *)
(*VAR_1->mem->alloc_small) ((j_common_ptr)VAR_1, VAR_6,
(VAR_7 + 1) * sizeof(JLONG));
for (VAR_3 = 0, VAR_4 = -VAR_8; VAR_3 <= VAR_7; VAR_3++, VAR_4++) {
VAR_2->Cr_r_tab[VAR_3] = (int)
RIGHT_SHIFT(FIX(1.40200) * VAR_4 + VAR_9, VAR_10);
VAR_2->Cb_b_tab[VAR_3] = (int)
RIGHT_SHIFT(FIX(1.77200) * VAR_4 + VAR_9, VAR_10);
VAR_2->Cr_g_tab[VAR_3] = (-FIX(0.71414)) * VAR_4;
VAR_2->Cb_g_tab[VAR_3] = (-FIX(0.34414)) * VAR_4 + VAR_9;
}
}",,"LOCAL(void)
build_ycc_rgb_table(j_decompress_ptr cinfo)
{
  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
  int i;
  JLONG x;
  SHIFT_TEMPS

  upsample->Cr_r_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,
                                (MAXJSAMPLE + 1) * sizeof(int));
  upsample->Cb_b_tab = (int *)
    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,
                                (MAXJSAMPLE + 1) * sizeof(int));
  upsample->Cr_g_tab = (JLONG *)
    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,
                                (MAXJSAMPLE + 1) * sizeof(JLONG));
  upsample->Cb_g_tab = (JLONG *)
    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,
                                (MAXJSAMPLE + 1) * sizeof(JLONG));

  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
    /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
    /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
    /* Cr=>R value is nearest int to 1.40200 * x */
    upsample->Cr_r_tab[i] = (int)
                    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);
    /* Cb=>B value is nearest int to 1.77200 * x */
    upsample->Cb_b_tab[i] = (int)
                    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);
    /* Cr=>G value is scaled-up -0.71414 * x */
    upsample->Cr_g_tab[i] = (-FIX(0.71414)) * x;
    /* Cb=>G value is scaled-up -0.34414 * x */
    /* We also add in ONE_HALF so that need not do it in inner loop */
    upsample->Cb_g_tab[i] = (-FIX(0.34414)) * x + ONE_HALF;
  }
}","VAR_0(void)
build_ycc_rgb_table(j_decompress_ptr VAR_1)
{
  my_merged_upsample_ptr VAR_2 = (my_merged_upsample_ptr)VAR_1->upsample;
  int VAR_3;
  JLONG VAR_4;
  SHIFT_TEMPS

  VAR_2->VAR_5 = (int *)
    (*VAR_1->mem->alloc_small) ((j_common_ptr)VAR_1, VAR_6,
                                (VAR_7 + 1) * sizeof(int));
  VAR_2->Cb_b_tab = (int *)
    (*VAR_1->mem->alloc_small) ((j_common_ptr)VAR_1, VAR_6,
                                (VAR_7 + 1) * sizeof(int));
  VAR_2->Cr_g_tab = (JLONG *)
    (*VAR_1->mem->alloc_small) ((j_common_ptr)VAR_1, VAR_6,
                                (VAR_7 + 1) * sizeof(JLONG));
  VAR_2->Cb_g_tab = (JLONG *)
    (*VAR_1->mem->alloc_small) ((j_common_ptr)VAR_1, VAR_6,
                                (VAR_7 + 1) * sizeof(JLONG));

  for (VAR_3 = 0, VAR_4 = -VAR_8; VAR_3 <= VAR_7; VAR_3++, VAR_4++) {
    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    VAR_2->Cr_r_tab[VAR_3] = (int)
                    RIGHT_SHIFT(FIX(1.40200) * VAR_4 + VAR_9, VAR_10);
    /* COMMENT_3 */
    VAR_2->Cb_b_tab[VAR_3] = (int)
                    RIGHT_SHIFT(FIX(1.77200) * VAR_4 + VAR_9, VAR_10);
    /* COMMENT_4 */
    VAR_2->Cr_g_tab[VAR_3] = (-FIX(0.71414)) * VAR_4;
    /* COMMENT_5 */
    /* COMMENT_6 */
    VAR_2->Cb_g_tab[VAR_3] = (-FIX(0.34414)) * VAR_4 + VAR_9;
  }
}",,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 LOCAL(void)
 build_ycc_rgb_table(j_decompress_ptr cinfo)
 {
-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
   int i;
   JLONG x;
   SHIFT_TEMPS","{'deleted_lines': ['  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;'], 'added_lines': ['  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;']}",True,A crafted input file could cause a null pointer dereference in jcopy_sample_rows() when processed by libjpeg-turbo.,5.5,MEDIUM,1,valid,2020-07-24T02:24:38Z,3
CVE-2020-35538,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libjpeg-turbo,"Fix jpeg_skip_scanlines() segfault w/merged upsamp

The additional segfault mentioned in #244 was due to the fact that
the merged upsamplers use a different private structure than the
non-merged upsamplers.  jpeg_skip_scanlines() was assuming the latter, so
when merged upsampling was enabled, jpeg_skip_scanlines() clobbered one
of the IDCT method pointers in the merged upsampler's private structure.

For reasons unknown, the test image in #441 did not encounter this
segfault (too small?), but it encountered an issue similar to the one
fixed in 5bc43c7821df982f65aa1c738f67fbf7cba8bd69, whereby it was
necessary to set up a dummy postprocessing function in
read_and_discard_scanlines() when merged upsampling was enabled.
Failing to do so caused either a segfault in merged_2v_upsample() (due
to a NULL pointer being passed to jcopy_sample_rows()) or an error
(""Corrupt JPEG data: premature end of data segment""), depending on the
number of scanlines skipped and whether the first scanline skipped was
an odd- or even-numbered row.

Fixes #441
Fixes #244 (for real this time)",9120a247436e84c0b4eea828cb11e8f665fcde30,https://github.com/libjpeg-turbo/libjpeg-turbo/commit/9120a247436e84c0b4eea828cb11e8f665fcde30,jdapistd.c,jpeg_skip_scanlines,"GLOBAL(JDIMENSION)
jpeg_skip_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)
{
my_main_ptr main_ptr = (my_main_ptr)cinfo->main;
my_coef_ptr coef = (my_coef_ptr)cinfo->coef;
my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
JDIMENSION i, x;
int y;
JDIMENSION lines_per_iMCU_row, lines_left_in_iMCU_row, lines_after_iMCU_row;
JDIMENSION lines_to_skip, lines_to_read;
if (cinfo->global_state != DSTATE_SCANNING)
ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
if (cinfo->output_scanline + num_lines >= cinfo->output_height) {
cinfo->output_scanline = cinfo->output_height;
(*cinfo->inputctl->finish_input_pass) (cinfo);
cinfo->inputctl->eoi_reached = TRUE;
return cinfo->output_height - cinfo->output_scanline;
}
if (num_lines == 0)
return 0;
lines_per_iMCU_row = cinfo->_min_DCT_scaled_size * cinfo->max_v_samp_factor;
lines_left_in_iMCU_row =
(lines_per_iMCU_row - (cinfo->output_scanline % lines_per_iMCU_row)) %
lines_per_iMCU_row;
lines_after_iMCU_row = num_lines - lines_left_in_iMCU_row;
if (cinfo->upsample->need_context_rows) {
if ((num_lines < lines_left_in_iMCU_row + 1) ||
(lines_left_in_iMCU_row <= 1 && main_ptr->buffer_full &&
lines_after_iMCU_row < lines_per_iMCU_row + 1)) {
read_and_discard_scanlines(cinfo, num_lines);
return num_lines;
}
if (lines_left_in_iMCU_row <= 1 && main_ptr->buffer_full) {
cinfo->output_scanline += lines_left_in_iMCU_row + lines_per_iMCU_row;
lines_after_iMCU_row -= lines_per_iMCU_row;
} else {
cinfo->output_scanline += lines_left_in_iMCU_row;
}
if (main_ptr->iMCU_row_ctr == 0 ||
(main_ptr->iMCU_row_ctr == 1 && lines_left_in_iMCU_row > 2))
set_wraparound_pointers(cinfo);
main_ptr->buffer_full = FALSE;
main_ptr->rowgroup_ctr = 0;
main_ptr->context_state = CTX_PREPARE_FOR_IMCU;
upsample->next_row_out = cinfo->max_v_samp_factor;
upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
}
else {
if (num_lines < lines_left_in_iMCU_row) {
increment_simple_rowgroup_ctr(cinfo, num_lines);
return num_lines;
} else {
cinfo->output_scanline += lines_left_in_iMCU_row;
main_ptr->buffer_full = FALSE;
main_ptr->rowgroup_ctr = 0;
upsample->next_row_out = cinfo->max_v_samp_factor;
upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
}
}
if (cinfo->upsample->need_context_rows)
lines_to_skip = ((lines_after_iMCU_row - 1) / lines_per_iMCU_row) *
lines_per_iMCU_row;
else
lines_to_skip = (lines_after_iMCU_row / lines_per_iMCU_row) *
lines_per_iMCU_row;
lines_to_read = lines_after_iMCU_row - lines_to_skip;
if (cinfo->inputctl->has_multiple_scans) {
if (cinfo->upsample->need_context_rows) {
cinfo->output_scanline += lines_to_skip;
cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;
main_ptr->iMCU_row_ctr += lines_to_skip / lines_per_iMCU_row;
read_and_discard_scanlines(cinfo, lines_to_read);
} else {
cinfo->output_scanline += lines_to_skip;
cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;
increment_simple_rowgroup_ctr(cinfo, lines_to_read);
}
upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
return num_lines;
}
for (i = 0; i < lines_to_skip; i += lines_per_iMCU_row) {
for (y = 0; y < coef->MCU_rows_per_iMCU_row; y++) {
for (x = 0; x < cinfo->MCUs_per_row; x++) {
(*cinfo->entropy->decode_mcu) (cinfo, NULL);
}
}
cinfo->input_iMCU_row++;
cinfo->output_iMCU_row++;
if (cinfo->input_iMCU_row < cinfo->total_iMCU_rows)
start_iMCU_row(cinfo);
else
(*cinfo->inputctl->finish_input_pass) (cinfo);
}
cinfo->output_scanline += lines_to_skip;
if (cinfo->upsample->need_context_rows) {
main_ptr->iMCU_row_ctr += lines_to_skip / lines_per_iMCU_row;
read_and_discard_scanlines(cinfo, lines_to_read);
} else {
increment_simple_rowgroup_ctr(cinfo, lines_to_read);
}
upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
return num_lines;
}","VAR_0(JDIMENSION)
jpeg_skip_scanlines(j_decompress_ptr VAR_1, JDIMENSION VAR_2)
{
my_main_ptr VAR_3 = (my_main_ptr)VAR_1->main;
my_coef_ptr VAR_4 = (my_coef_ptr)VAR_1->coef;
my_upsample_ptr VAR_5 = (my_upsample_ptr)VAR_1->upsample;
JDIMENSION VAR_6, VAR_7;
int VAR_8;
JDIMENSION VAR_9, VAR_10, VAR_11;
JDIMENSION VAR_12, VAR_13;
if (VAR_1->global_state != VAR_14)
ERREXIT1(VAR_1, VAR_15, VAR_1->global_state);
if (VAR_1->output_scanline + VAR_2 >= VAR_1->output_height) {
VAR_1->output_scanline = VAR_1->output_height;
(*VAR_1->inputctl->finish_input_pass) (VAR_1);
VAR_1->inputctl->eoi_reached = TRUE;
return VAR_1->output_height - VAR_1->output_scanline;
}
if (VAR_2 == 0)
return 0;
VAR_9 = VAR_1->_min_DCT_scaled_size * VAR_1->max_v_samp_factor;
VAR_10 =
(VAR_9 - (VAR_1->output_scanline % VAR_9)) %
VAR_9;
VAR_11 = VAR_2 - VAR_10;
if (VAR_1->upsample->need_context_rows) {
if ((VAR_2 < VAR_10 + 1) ||
(VAR_10 <= 1 && VAR_3->buffer_full &&
VAR_11 < VAR_9 + 1)) {
read_and_discard_scanlines(VAR_1, VAR_2);
return VAR_2;
}
if (VAR_10 <= 1 && VAR_3->buffer_full) {
VAR_1->output_scanline += VAR_10 + VAR_9;
VAR_11 -= VAR_9;
} else {
VAR_1->output_scanline += VAR_10;
}
if (VAR_3->iMCU_row_ctr == 0 ||
(VAR_3->iMCU_row_ctr == 1 && VAR_10 > 2))
set_wraparound_pointers(VAR_1);
VAR_3->buffer_full = FALSE;
VAR_3->rowgroup_ctr = 0;
VAR_3->context_state = VAR_16;
VAR_5->next_row_out = VAR_1->max_v_samp_factor;
VAR_5->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;
}
else {
if (VAR_2 < VAR_10) {
increment_simple_rowgroup_ctr(VAR_1, VAR_2);
return VAR_2;
} else {
VAR_1->output_scanline += VAR_10;
VAR_3->buffer_full = FALSE;
VAR_3->rowgroup_ctr = 0;
VAR_5->next_row_out = VAR_1->max_v_samp_factor;
VAR_5->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;
}
}
if (VAR_1->upsample->need_context_rows)
VAR_12 = ((VAR_11 - 1) / VAR_9) *
VAR_9;
else
VAR_12 = (VAR_11 / VAR_9) *
VAR_9;
VAR_13 = VAR_11 - VAR_12;
if (VAR_1->inputctl->has_multiple_scans) {
if (VAR_1->upsample->need_context_rows) {
VAR_1->output_scanline += VAR_12;
VAR_1->output_iMCU_row += VAR_12 / VAR_9;
VAR_3->iMCU_row_ctr += VAR_12 / VAR_9;
read_and_discard_scanlines(VAR_1, VAR_13);
} else {
VAR_1->output_scanline += VAR_12;
VAR_1->output_iMCU_row += VAR_12 / VAR_9;
increment_simple_rowgroup_ctr(VAR_1, VAR_13);
}
VAR_5->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;
return VAR_2;
}
for (VAR_6 = 0; VAR_6 < VAR_12; VAR_6 += VAR_9) {
for (VAR_8 = 0; VAR_8 < VAR_4->MCU_rows_per_iMCU_row; VAR_8++) {
for (VAR_7 = 0; VAR_7 < VAR_1->MCUs_per_row; VAR_7++) {
(*VAR_1->entropy->decode_mcu) (VAR_1, NULL);
}
}
VAR_1->input_iMCU_row++;
VAR_1->output_iMCU_row++;
if (VAR_1->input_iMCU_row < VAR_1->total_iMCU_rows)
start_iMCU_row(VAR_1);
else
(*VAR_1->inputctl->finish_input_pass) (VAR_1);
}
VAR_1->output_scanline += VAR_12;
if (VAR_1->upsample->need_context_rows) {
VAR_3->iMCU_row_ctr += VAR_12 / VAR_9;
read_and_discard_scanlines(VAR_1, VAR_13);
} else {
increment_simple_rowgroup_ctr(VAR_1, VAR_13);
}
VAR_5->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;
return VAR_2;
}",,"GLOBAL(JDIMENSION)
jpeg_skip_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)
{
  my_main_ptr main_ptr = (my_main_ptr)cinfo->main;
  my_coef_ptr coef = (my_coef_ptr)cinfo->coef;
  my_master_ptr master = (my_master_ptr)cinfo->master;
  JDIMENSION i, x;
  int y;
  JDIMENSION lines_per_iMCU_row, lines_left_in_iMCU_row, lines_after_iMCU_row;
  JDIMENSION lines_to_skip, lines_to_read;

  if (cinfo->global_state != DSTATE_SCANNING)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  /* Do not skip past the bottom of the image. */
  if (cinfo->output_scanline + num_lines >= cinfo->output_height) {
    cinfo->output_scanline = cinfo->output_height;
    (*cinfo->inputctl->finish_input_pass) (cinfo);
    cinfo->inputctl->eoi_reached = TRUE;
    return cinfo->output_height - cinfo->output_scanline;
  }

  if (num_lines == 0)
    return 0;

  lines_per_iMCU_row = cinfo->_min_DCT_scaled_size * cinfo->max_v_samp_factor;
  lines_left_in_iMCU_row =
    (lines_per_iMCU_row - (cinfo->output_scanline % lines_per_iMCU_row)) %
    lines_per_iMCU_row;
  lines_after_iMCU_row = num_lines - lines_left_in_iMCU_row;

  /* Skip the lines remaining in the current iMCU row.  When upsampling
   * requires context rows, we need the previous and next rows in order to read
   * the current row.  This adds some complexity.
   */
  if (cinfo->upsample->need_context_rows) {
    /* If the skipped lines would not move us past the current iMCU row, we
     * read the lines and ignore them.  There might be a faster way of doing
     * this, but we are facing increasing complexity for diminishing returns.
     * The increasing complexity would be a by-product of meddling with the
     * state machine used to skip context rows.  Near the end of an iMCU row,
     * the next iMCU row may have already been entropy-decoded.  In this unique
     * case, we will read the next iMCU row if we cannot skip past it as well.
     */
    if ((num_lines < lines_left_in_iMCU_row + 1) ||
        (lines_left_in_iMCU_row <= 1 && main_ptr->buffer_full &&
         lines_after_iMCU_row < lines_per_iMCU_row + 1)) {
      read_and_discard_scanlines(cinfo, num_lines);
      return num_lines;
    }

    /* If the next iMCU row has already been entropy-decoded, make sure that
     * we do not skip too far.
     */
    if (lines_left_in_iMCU_row <= 1 && main_ptr->buffer_full) {
      cinfo->output_scanline += lines_left_in_iMCU_row + lines_per_iMCU_row;
      lines_after_iMCU_row -= lines_per_iMCU_row;
    } else {
      cinfo->output_scanline += lines_left_in_iMCU_row;
    }

    /* If we have just completed the first block, adjust the buffer pointers */
    if (main_ptr->iMCU_row_ctr == 0 ||
        (main_ptr->iMCU_row_ctr == 1 && lines_left_in_iMCU_row > 2))
      set_wraparound_pointers(cinfo);
    main_ptr->buffer_full = FALSE;
    main_ptr->rowgroup_ctr = 0;
    main_ptr->context_state = CTX_PREPARE_FOR_IMCU;
    if (master->using_merged_upsample) {
      my_merged_upsample_ptr upsample =
        (my_merged_upsample_ptr)cinfo->upsample;
      upsample->spare_full = FALSE;
      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
    } else {
      my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
      upsample->next_row_out = cinfo->max_v_samp_factor;
      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
    }
  }

  /* Skipping is much simpler when context rows are not required. */
  else {
    if (num_lines < lines_left_in_iMCU_row) {
      increment_simple_rowgroup_ctr(cinfo, num_lines);
      return num_lines;
    } else {
      cinfo->output_scanline += lines_left_in_iMCU_row;
      main_ptr->buffer_full = FALSE;
      main_ptr->rowgroup_ctr = 0;
      if (master->using_merged_upsample) {
        my_merged_upsample_ptr upsample =
          (my_merged_upsample_ptr)cinfo->upsample;
        upsample->spare_full = FALSE;
        upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
      } else {
        my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
        upsample->next_row_out = cinfo->max_v_samp_factor;
        upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
      }
    }
  }

  /* Calculate how many full iMCU rows we can skip. */
  if (cinfo->upsample->need_context_rows)
    lines_to_skip = ((lines_after_iMCU_row - 1) / lines_per_iMCU_row) *
                    lines_per_iMCU_row;
  else
    lines_to_skip = (lines_after_iMCU_row / lines_per_iMCU_row) *
                    lines_per_iMCU_row;
  /* Calculate the number of lines that remain to be skipped after skipping all
   * of the full iMCU rows that we can.  We will not read these lines unless we
   * have to.
   */
  lines_to_read = lines_after_iMCU_row - lines_to_skip;

  /* For images requiring multiple scans (progressive, non-interleaved, etc.),
   * all of the entropy decoding occurs in jpeg_start_decompress(), assuming
   * that the input data source is non-suspending.  This makes skipping easy.
   */
  if (cinfo->inputctl->has_multiple_scans) {
    if (cinfo->upsample->need_context_rows) {
      cinfo->output_scanline += lines_to_skip;
      cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;
      main_ptr->iMCU_row_ctr += lines_to_skip / lines_per_iMCU_row;
      /* It is complex to properly move to the middle of a context block, so
       * read the remaining lines instead of skipping them.
       */
      read_and_discard_scanlines(cinfo, lines_to_read);
    } else {
      cinfo->output_scanline += lines_to_skip;
      cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;
      increment_simple_rowgroup_ctr(cinfo, lines_to_read);
    }
    if (master->using_merged_upsample) {
      my_merged_upsample_ptr upsample =
        (my_merged_upsample_ptr)cinfo->upsample;
      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
    } else {
      my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
    }
    return num_lines;
  }

  /* Skip the iMCU rows that we can safely skip. */
  for (i = 0; i < lines_to_skip; i += lines_per_iMCU_row) {
    for (y = 0; y < coef->MCU_rows_per_iMCU_row; y++) {
      for (x = 0; x < cinfo->MCUs_per_row; x++) {
        /* Calling decode_mcu() with a NULL pointer causes it to discard the
         * decoded coefficients.  This is ~5% faster for large subsets, but
         * it's tough to tell a difference for smaller images.
         */
        (*cinfo->entropy->decode_mcu) (cinfo, NULL);
      }
    }
    cinfo->input_iMCU_row++;
    cinfo->output_iMCU_row++;
    if (cinfo->input_iMCU_row < cinfo->total_iMCU_rows)
      start_iMCU_row(cinfo);
    else
      (*cinfo->inputctl->finish_input_pass) (cinfo);
  }
  cinfo->output_scanline += lines_to_skip;

  if (cinfo->upsample->need_context_rows) {
    /* Context-based upsampling keeps track of iMCU rows. */
    main_ptr->iMCU_row_ctr += lines_to_skip / lines_per_iMCU_row;

    /* It is complex to properly move to the middle of a context block, so
     * read the remaining lines instead of skipping them.
     */
    read_and_discard_scanlines(cinfo, lines_to_read);
  } else {
    increment_simple_rowgroup_ctr(cinfo, lines_to_read);
  }

  /* Since skipping lines involves skipping the upsampling step, the value of
   * ""rows_to_go"" will become invalid unless we set it here.  NOTE: This is a
   * bit odd, since ""rows_to_go"" seems to be redundantly keeping track of
   * output_scanline.
   */
  if (master->using_merged_upsample) {
    my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
  } else {
    my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
  }

  /* Always skip the requested number of lines. */
  return num_lines;
}","VAR_0(JDIMENSION)
jpeg_skip_scanlines(j_decompress_ptr VAR_1, JDIMENSION VAR_2)
{
  my_main_ptr VAR_3 = (my_main_ptr)VAR_1->main;
  my_coef_ptr VAR_4 = (my_coef_ptr)VAR_1->coef;
  my_master_ptr VAR_5 = (my_master_ptr)VAR_1->master;
  JDIMENSION VAR_6, VAR_7;
  int VAR_8;
  JDIMENSION VAR_9, VAR_10, VAR_11;
  JDIMENSION VAR_12, VAR_13;

  if (VAR_1->global_state != VAR_14)
    ERREXIT1(VAR_1, VAR_15, VAR_1->global_state);

  /* COMMENT_0 */
  if (VAR_1->output_scanline + VAR_2 >= VAR_1->output_height) {
    VAR_1->output_scanline = VAR_1->output_height;
    (*VAR_1->inputctl->finish_input_pass) (VAR_1);
    VAR_1->inputctl->eoi_reached = TRUE;
    return VAR_1->output_height - VAR_1->output_scanline;
  }

  if (VAR_2 == 0)
    return 0;

  VAR_9 = VAR_1->_min_DCT_scaled_size * VAR_1->max_v_samp_factor;
  VAR_10 =
    (VAR_9 - (VAR_1->output_scanline % VAR_9)) %
    VAR_9;
  VAR_11 = VAR_2 - VAR_10;

  /* COMMENT_1 */
                                                                               
                                                 
     
  if (VAR_1->upsample->need_context_rows) {
    /* COMMENT_5 */
                                                                            
                                                                             
                                                                           
                                                                             
                                                                               
                                                                              
       
    if ((VAR_2 < VAR_10 + 1) ||
        (VAR_10 <= 1 && VAR_3->buffer_full &&
         VAR_11 < VAR_9 + 1)) {
      read_and_discard_scanlines(VAR_1, VAR_2);
      return VAR_2;
    }

    /* COMMENT_13 */
                              
       
    if (VAR_10 <= 1 && VAR_3->buffer_full) {
      VAR_1->output_scanline += VAR_10 + VAR_9;
      VAR_11 -= VAR_9;
    } else {
      VAR_1->output_scanline += VAR_10;
    }

    /* COMMENT_16 */
    if (VAR_3->iMCU_row_ctr == 0 ||
        (VAR_3->iMCU_row_ctr == 1 && VAR_10 > 2))
      set_wraparound_pointers(VAR_1);
    VAR_3->buffer_full = FALSE;
    VAR_3->rowgroup_ctr = 0;
    VAR_3->context_state = VAR_16;
    if (VAR_5->using_merged_upsample) {
      my_merged_upsample_ptr VAR_17 =
        (my_merged_upsample_ptr)VAR_1->upsample;
      VAR_17->spare_full = FALSE;
      VAR_17->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;
    } else {
      my_upsample_ptr VAR_17 = (my_upsample_ptr)VAR_1->upsample;
      VAR_17->next_row_out = VAR_1->max_v_samp_factor;
      VAR_17->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;
    }
  }

  /* COMMENT_17 */
  else {
    if (VAR_2 < VAR_10) {
      increment_simple_rowgroup_ctr(VAR_1, VAR_2);
      return VAR_2;
    } else {
      VAR_1->output_scanline += VAR_10;
      VAR_3->buffer_full = FALSE;
      VAR_3->rowgroup_ctr = 0;
      if (VAR_5->using_merged_upsample) {
        my_merged_upsample_ptr VAR_17 =
          (my_merged_upsample_ptr)VAR_1->upsample;
        VAR_17->spare_full = FALSE;
        VAR_17->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;
      } else {
        my_upsample_ptr VAR_17 = (my_upsample_ptr)VAR_1->upsample;
        VAR_17->next_row_out = VAR_1->max_v_samp_factor;
        VAR_17->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;
      }
    }
  }

  /* COMMENT_18 */
  if (VAR_1->upsample->need_context_rows)
    VAR_12 = ((VAR_11 - 1) / VAR_9) *
                    VAR_9;
  else
    VAR_12 = (VAR_11 / VAR_9) *
                    VAR_9;
  /* COMMENT_19 */
                                                                               
             
     
  VAR_13 = VAR_11 - VAR_12;

  /* COMMENT_23 */
                                                                            
                                                                             
     
  if (VAR_1->inputctl->has_multiple_scans) {
    if (VAR_1->upsample->need_context_rows) {
      VAR_1->output_scanline += VAR_12;
      VAR_1->output_iMCU_row += VAR_12 / VAR_9;
      VAR_3->iMCU_row_ctr += VAR_12 / VAR_9;
      /* COMMENT_27 */
                                                           
         
      read_and_discard_scanlines(VAR_1, VAR_13);
    } else {
      VAR_1->output_scanline += VAR_12;
      VAR_1->output_iMCU_row += VAR_12 / VAR_9;
      increment_simple_rowgroup_ctr(VAR_1, VAR_13);
    }
    if (VAR_5->using_merged_upsample) {
      my_merged_upsample_ptr VAR_17 =
        (my_merged_upsample_ptr)VAR_1->upsample;
      VAR_17->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;
    } else {
      my_upsample_ptr VAR_17 = (my_upsample_ptr)VAR_1->upsample;
      VAR_17->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;
    }
    return VAR_2;
  }

  /* COMMENT_30 */
  for (VAR_6 = 0; VAR_6 < VAR_12; VAR_6 += VAR_9) {
    for (VAR_8 = 0; VAR_8 < VAR_4->MCU_rows_per_iMCU_row; VAR_8++) {
      for (VAR_7 = 0; VAR_7 < VAR_1->MCUs_per_row; VAR_7++) {
        /* COMMENT_31 */
                                                                           
                                                              
           
        (*VAR_1->entropy->decode_mcu) (VAR_1, NULL);
      }
    }
    VAR_1->input_iMCU_row++;
    VAR_1->output_iMCU_row++;
    if (VAR_1->input_iMCU_row < VAR_1->total_iMCU_rows)
      start_iMCU_row(VAR_1);
    else
      (*VAR_1->inputctl->finish_input_pass) (VAR_1);
  }
  VAR_1->output_scanline += VAR_12;

  if (VAR_1->upsample->need_context_rows) {
    /* COMMENT_35 */
    VAR_3->iMCU_row_ctr += VAR_12 / VAR_9;

    /* COMMENT_36 */
                                                         
       
    read_and_discard_scanlines(VAR_1, VAR_13);
  } else {
    increment_simple_rowgroup_ctr(VAR_1, VAR_13);
  }

  /* COMMENT_39 */
                                                                             
                                                                         
                     
     
  if (VAR_5->using_merged_upsample) {
    my_merged_upsample_ptr VAR_17 = (my_merged_upsample_ptr)VAR_1->upsample;
    VAR_17->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;
  } else {
    my_upsample_ptr VAR_17 = (my_upsample_ptr)VAR_1->upsample;
    VAR_17->rows_to_go = VAR_1->output_height - VAR_1->output_scanline;
  }

  /* COMMENT_44 */
  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 {
   my_main_ptr main_ptr = (my_main_ptr)cinfo->main;
   my_coef_ptr coef = (my_coef_ptr)cinfo->coef;
-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
+  my_master_ptr master = (my_master_ptr)cinfo->master;
   JDIMENSION i, x;
   int y;
   JDIMENSION lines_per_iMCU_row, lines_left_in_iMCU_row, lines_after_iMCU_row;
@@ -66,8 +66,16 @@
     main_ptr->buffer_full = FALSE;
     main_ptr->rowgroup_ctr = 0;
     main_ptr->context_state = CTX_PREPARE_FOR_IMCU;
-    upsample->next_row_out = cinfo->max_v_samp_factor;
-    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
+    if (master->using_merged_upsample) {
+      my_merged_upsample_ptr upsample =
+        (my_merged_upsample_ptr)cinfo->upsample;
+      upsample->spare_full = FALSE;
+      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
+    } else {
+      my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
+      upsample->next_row_out = cinfo->max_v_samp_factor;
+      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
+    }
   }
 
   /* Skipping is much simpler when context rows are not required. */
@@ -79,8 +87,16 @@
       cinfo->output_scanline += lines_left_in_iMCU_row;
       main_ptr->buffer_full = FALSE;
       main_ptr->rowgroup_ctr = 0;
-      upsample->next_row_out = cinfo->max_v_samp_factor;
-      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
+      if (master->using_merged_upsample) {
+        my_merged_upsample_ptr upsample =
+          (my_merged_upsample_ptr)cinfo->upsample;
+        upsample->spare_full = FALSE;
+        upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
+      } else {
+        my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
+        upsample->next_row_out = cinfo->max_v_samp_factor;
+        upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
+      }
     }
   }
 
@@ -115,7 +131,14 @@
       cinfo->output_iMCU_row += lines_to_skip / lines_per_iMCU_row;
       increment_simple_rowgroup_ctr(cinfo, lines_to_read);
     }
-    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
+    if (master->using_merged_upsample) {
+      my_merged_upsample_ptr upsample =
+        (my_merged_upsample_ptr)cinfo->upsample;
+      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
+    } else {
+      my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
+      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
+    }
     return num_lines;
   }
 
@@ -156,7 +179,13 @@
    * bit odd, since ""rows_to_go"" seems to be redundantly keeping track of
    * output_scanline.
    */
-  upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
+  if (master->using_merged_upsample) {
+    my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
+    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
+  } else {
+    my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
+    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;
+  }
 
   /* Always skip the requested number of lines. */
   return num_lines;","{'deleted_lines': ['  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;', '    upsample->next_row_out = cinfo->max_v_samp_factor;', '    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;', '      upsample->next_row_out = cinfo->max_v_samp_factor;', '      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;', '    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;', '  upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;'], 'added_lines': ['  my_master_ptr master = (my_master_ptr)cinfo->master;', '    if (master->using_merged_upsample) {', '      my_merged_upsample_ptr upsample =', '        (my_merged_upsample_ptr)cinfo->upsample;', '      upsample->spare_full = FALSE;', '      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;', '    } else {', '      my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;', '      upsample->next_row_out = cinfo->max_v_samp_factor;', '      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;', '    }', '      if (master->using_merged_upsample) {', '        my_merged_upsample_ptr upsample =', '          (my_merged_upsample_ptr)cinfo->upsample;', '        upsample->spare_full = FALSE;', '        upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;', '      } else {', '        my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;', '        upsample->next_row_out = cinfo->max_v_samp_factor;', '        upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;', '      }', '    if (master->using_merged_upsample) {', '      my_merged_upsample_ptr upsample =', '        (my_merged_upsample_ptr)cinfo->upsample;', '      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;', '    } else {', '      my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;', '      upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;', '    }', '  if (master->using_merged_upsample) {', '    my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;', '    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;', '  } else {', '    my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;', '    upsample->rows_to_go = cinfo->output_height - cinfo->output_scanline;', '  }']}",True,A crafted input file could cause a null pointer dereference in jcopy_sample_rows() when processed by libjpeg-turbo.,5.5,MEDIUM,1,valid,2020-07-24T02:24:38Z,3
CVE-2020-35538,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libjpeg-turbo,"Fix jpeg_skip_scanlines() segfault w/merged upsamp

The additional segfault mentioned in #244 was due to the fact that
the merged upsamplers use a different private structure than the
non-merged upsamplers.  jpeg_skip_scanlines() was assuming the latter, so
when merged upsampling was enabled, jpeg_skip_scanlines() clobbered one
of the IDCT method pointers in the merged upsampler's private structure.

For reasons unknown, the test image in #441 did not encounter this
segfault (too small?), but it encountered an issue similar to the one
fixed in 5bc43c7821df982f65aa1c738f67fbf7cba8bd69, whereby it was
necessary to set up a dummy postprocessing function in
read_and_discard_scanlines() when merged upsampling was enabled.
Failing to do so caused either a segfault in merged_2v_upsample() (due
to a NULL pointer being passed to jcopy_sample_rows()) or an error
(""Corrupt JPEG data: premature end of data segment""), depending on the
number of scanlines skipped and whether the first scanline skipped was
an odd- or even-numbered row.

Fixes #441
Fixes #244 (for real this time)",9120a247436e84c0b4eea828cb11e8f665fcde30,https://github.com/libjpeg-turbo/libjpeg-turbo/commit/9120a247436e84c0b4eea828cb11e8f665fcde30,jdapistd.c,read_and_discard_scanlines,"LOCAL(void)
read_and_discard_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)
{
JDIMENSION n;
void (*color_convert) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
JDIMENSION input_row, JSAMPARRAY output_buf,
int num_rows) = NULL;
void (*color_quantize) (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
JSAMPARRAY output_buf, int num_rows) = NULL;
if (cinfo->cconvert && cinfo->cconvert->color_convert) {
color_convert = cinfo->cconvert->color_convert;
cinfo->cconvert->color_convert = noop_convert;
}
if (cinfo->cquantize && cinfo->cquantize->color_quantize) {
color_quantize = cinfo->cquantize->color_quantize;
cinfo->cquantize->color_quantize = noop_quantize;
}
for (n = 0; n < num_lines; n++)
jpeg_read_scanlines(cinfo, NULL, 1);
if (color_convert)
cinfo->cconvert->color_convert = color_convert;
if (color_quantize)
cinfo->cquantize->color_quantize = color_quantize;
}","VAR_0(void)
read_and_discard_scanlines(j_decompress_ptr VAR_1, JDIMENSION VAR_2)
{
JDIMENSION VAR_3;
void (*VAR_4) (j_decompress_ptr VAR_1, JSAMPIMAGE VAR_5,
JDIMENSION VAR_6, JSAMPARRAY VAR_7,
int VAR_8) = NULL;
void (*VAR_9) (j_decompress_ptr VAR_1, JSAMPARRAY VAR_5,
JSAMPARRAY VAR_7, int VAR_8) = NULL;
if (VAR_1->cconvert && VAR_1->cconvert->color_convert) {
VAR_4 = VAR_1->cconvert->color_convert;
VAR_1->cconvert->color_convert = VAR_10;
}
if (VAR_1->cquantize && VAR_1->cquantize->color_quantize) {
VAR_9 = VAR_1->cquantize->color_quantize;
VAR_1->cquantize->color_quantize = VAR_11;
}
for (VAR_3 = 0; VAR_3 < VAR_2; VAR_3++)
jpeg_read_scanlines(VAR_1, NULL, 1);
if (VAR_4)
VAR_1->cconvert->color_convert = VAR_4;
if (VAR_9)
VAR_1->cquantize->color_quantize = VAR_9;
}",,"LOCAL(void)
read_and_discard_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)
{
  JDIMENSION n;
  my_master_ptr master = (my_master_ptr)cinfo->master;
  void (*color_convert) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
                         JDIMENSION input_row, JSAMPARRAY output_buf,
                         int num_rows) = NULL;
  void (*color_quantize) (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
                          JSAMPARRAY output_buf, int num_rows) = NULL;
  void (*post_process_data) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
                             JDIMENSION *in_row_group_ctr,
                             JDIMENSION in_row_groups_avail,
                             JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
                             JDIMENSION out_rows_avail) = NULL;

  if (cinfo->cconvert && cinfo->cconvert->color_convert) {
    color_convert = cinfo->cconvert->color_convert;
    cinfo->cconvert->color_convert = noop_convert;
  }

  if (cinfo->cquantize && cinfo->cquantize->color_quantize) {
    color_quantize = cinfo->cquantize->color_quantize;
    cinfo->cquantize->color_quantize = noop_quantize;
  }

  if (master->using_merged_upsample && cinfo->post &&
      cinfo->post->post_process_data) {
    post_process_data = cinfo->post->post_process_data;
    cinfo->post->post_process_data = noop_post_process;
  }

  for (n = 0; n < num_lines; n++)
    jpeg_read_scanlines(cinfo, NULL, 1);

  if (color_convert)
    cinfo->cconvert->color_convert = color_convert;

  if (color_quantize)
    cinfo->cquantize->color_quantize = color_quantize;

  if (post_process_data)
    cinfo->post->post_process_data = post_process_data;
}","VAR_0(void)
read_and_discard_scanlines(j_decompress_ptr VAR_1, JDIMENSION VAR_2)
{
  JDIMENSION VAR_3;
  my_master_ptr VAR_4 = (my_master_ptr)VAR_1->master;
  void (*VAR_5) (j_decompress_ptr VAR_1, JSAMPIMAGE VAR_6,
                         JDIMENSION VAR_7, JSAMPARRAY VAR_8,
                         int VAR_9) = NULL;
  void (*VAR_10) (j_decompress_ptr VAR_1, JSAMPARRAY VAR_6,
                          JSAMPARRAY VAR_8, int VAR_9) = NULL;
  void (*VAR_11) (j_decompress_ptr VAR_1, JSAMPIMAGE VAR_6,
                             JDIMENSION *VAR_12,
                             JDIMENSION VAR_13,
                             JSAMPARRAY VAR_8, JDIMENSION *VAR_14,
                             JDIMENSION VAR_15) = NULL;

  if (VAR_1->cconvert && VAR_1->cconvert->color_convert) {
    VAR_5 = VAR_1->cconvert->color_convert;
    VAR_1->cconvert->color_convert = VAR_16;
  }

  if (VAR_1->cquantize && VAR_1->cquantize->color_quantize) {
    VAR_10 = VAR_1->cquantize->color_quantize;
    VAR_1->cquantize->color_quantize = VAR_17;
  }

  if (VAR_4->using_merged_upsample && VAR_1->post &&
      VAR_1->post->post_process_data) {
    VAR_11 = VAR_1->post->post_process_data;
    VAR_1->post->post_process_data = VAR_18;
  }

  for (VAR_3 = 0; VAR_3 < VAR_2; VAR_3++)
    jpeg_read_scanlines(VAR_1, NULL, 1);

  if (VAR_5)
    VAR_1->cconvert->color_convert = VAR_5;

  if (VAR_10)
    VAR_1->cquantize->color_quantize = VAR_10;

  if (VAR_11)
    VAR_1->post->post_process_data = VAR_11;
}",,"--- func_before
+++ func_after
@@ -2,11 +2,17 @@
 read_and_discard_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)
 {
   JDIMENSION n;
+  my_master_ptr master = (my_master_ptr)cinfo->master;
   void (*color_convert) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
                          JDIMENSION input_row, JSAMPARRAY output_buf,
                          int num_rows) = NULL;
   void (*color_quantize) (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
                           JSAMPARRAY output_buf, int num_rows) = NULL;
+  void (*post_process_data) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
+                             JDIMENSION *in_row_group_ctr,
+                             JDIMENSION in_row_groups_avail,
+                             JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
+                             JDIMENSION out_rows_avail) = NULL;
 
   if (cinfo->cconvert && cinfo->cconvert->color_convert) {
     color_convert = cinfo->cconvert->color_convert;
@@ -18,6 +24,12 @@
     cinfo->cquantize->color_quantize = noop_quantize;
   }
 
+  if (master->using_merged_upsample && cinfo->post &&
+      cinfo->post->post_process_data) {
+    post_process_data = cinfo->post->post_process_data;
+    cinfo->post->post_process_data = noop_post_process;
+  }
+
   for (n = 0; n < num_lines; n++)
     jpeg_read_scanlines(cinfo, NULL, 1);
 
@@ -26,4 +38,7 @@
 
   if (color_quantize)
     cinfo->cquantize->color_quantize = color_quantize;
+
+  if (post_process_data)
+    cinfo->post->post_process_data = post_process_data;
 }","{'deleted_lines': [], 'added_lines': ['  my_master_ptr master = (my_master_ptr)cinfo->master;', '  void (*post_process_data) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,', '                             JDIMENSION *in_row_group_ctr,', '                             JDIMENSION in_row_groups_avail,', '                             JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,', '                             JDIMENSION out_rows_avail) = NULL;', '  if (master->using_merged_upsample && cinfo->post &&', '      cinfo->post->post_process_data) {', '    post_process_data = cinfo->post->post_process_data;', '    cinfo->post->post_process_data = noop_post_process;', '  }', '', '', '  if (post_process_data)', '    cinfo->post->post_process_data = post_process_data;']}",True,A crafted input file could cause a null pointer dereference in jcopy_sample_rows() when processed by libjpeg-turbo.,5.5,MEDIUM,1,valid,2020-07-24T02:24:38Z,3
CVE-2020-35538,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libjpeg-turbo,"Fix jpeg_skip_scanlines() segfault w/merged upsamp

The additional segfault mentioned in #244 was due to the fact that
the merged upsamplers use a different private structure than the
non-merged upsamplers.  jpeg_skip_scanlines() was assuming the latter, so
when merged upsampling was enabled, jpeg_skip_scanlines() clobbered one
of the IDCT method pointers in the merged upsampler's private structure.

For reasons unknown, the test image in #441 did not encounter this
segfault (too small?), but it encountered an issue similar to the one
fixed in 5bc43c7821df982f65aa1c738f67fbf7cba8bd69, whereby it was
necessary to set up a dummy postprocessing function in
read_and_discard_scanlines() when merged upsampling was enabled.
Failing to do so caused either a segfault in merged_2v_upsample() (due
to a NULL pointer being passed to jcopy_sample_rows()) or an error
(""Corrupt JPEG data: premature end of data segment""), depending on the
number of scanlines skipped and whether the first scanline skipped was
an odd- or even-numbered row.

Fixes #441
Fixes #244 (for real this time)",9120a247436e84c0b4eea828cb11e8f665fcde30,https://github.com/libjpeg-turbo/libjpeg-turbo/commit/9120a247436e84c0b4eea828cb11e8f665fcde30,jdmrg565.c,h2v2_merged_upsample_565D_internal,"INLINE
LOCAL(void)
h2v2_merged_upsample_565D_internal(j_decompress_ptr cinfo,
JSAMPIMAGE input_buf,
JDIMENSION in_row_group_ctr,
JSAMPARRAY output_buf)
{
my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
register int y, cred, cgreen, cblue;
int cb, cr;
register JSAMPROW outptr0, outptr1;
JSAMPROW inptr00, inptr01, inptr1, inptr2;
JDIMENSION col;
register JSAMPLE *range_limit = cinfo->sample_range_limit;
int *Crrtab = upsample->Cr_r_tab;
int *Cbbtab = upsample->Cb_b_tab;
JLONG *Crgtab = upsample->Cr_g_tab;
JLONG *Cbgtab = upsample->Cb_g_tab;
JLONG d0 = dither_matrix[cinfo->output_scanline & DITHER_MASK];
JLONG d1 = dither_matrix[(cinfo->output_scanline + 1) & DITHER_MASK];
unsigned int r, g, b;
JLONG rgb;
SHIFT_TEMPS
inptr00 = input_buf[0][in_row_group_ctr * 2];
inptr01 = input_buf[0][in_row_group_ctr * 2 + 1];
inptr1 = input_buf[1][in_row_group_ctr];
inptr2 = input_buf[2][in_row_group_ctr];
outptr0 = output_buf[0];
outptr1 = output_buf[1];
for (col = cinfo->output_width >> 1; col > 0; col--) {
cb = GETJSAMPLE(*inptr1++);
cr = GETJSAMPLE(*inptr2++);
cred = Crrtab[cr];
cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
cblue = Cbbtab[cb];
y  = GETJSAMPLE(*inptr00++);
r = range_limit[DITHER_565_R(y + cred, d0)];
g = range_limit[DITHER_565_G(y + cgreen, d0)];
b = range_limit[DITHER_565_B(y + cblue, d0)];
d0 = DITHER_ROTATE(d0);
rgb = PACK_SHORT_565(r, g, b);
y  = GETJSAMPLE(*inptr00++);
r = range_limit[DITHER_565_R(y + cred, d0)];
g = range_limit[DITHER_565_G(y + cgreen, d0)];
b = range_limit[DITHER_565_B(y + cblue, d0)];
d0 = DITHER_ROTATE(d0);
rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));
WRITE_TWO_PIXELS(outptr0, rgb);
outptr0 += 4;
y  = GETJSAMPLE(*inptr01++);
r = range_limit[DITHER_565_R(y + cred, d1)];
g = range_limit[DITHER_565_G(y + cgreen, d1)];
b = range_limit[DITHER_565_B(y + cblue, d1)];
d1 = DITHER_ROTATE(d1);
rgb = PACK_SHORT_565(r, g, b);
y  = GETJSAMPLE(*inptr01++);
r = range_limit[DITHER_565_R(y + cred, d1)];
g = range_limit[DITHER_565_G(y + cgreen, d1)];
b = range_limit[DITHER_565_B(y + cblue, d1)];
d1 = DITHER_ROTATE(d1);
rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));
WRITE_TWO_PIXELS(outptr1, rgb);
outptr1 += 4;
}
if (cinfo->output_width & 1) {
cb = GETJSAMPLE(*inptr1);
cr = GETJSAMPLE(*inptr2);
cred = Crrtab[cr];
cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
cblue = Cbbtab[cb];
y  = GETJSAMPLE(*inptr00);
r = range_limit[DITHER_565_R(y + cred, d0)];
g = range_limit[DITHER_565_G(y + cgreen, d0)];
b = range_limit[DITHER_565_B(y + cblue, d0)];
rgb = PACK_SHORT_565(r, g, b);
*(INT16 *)outptr0 = (INT16)rgb;
y  = GETJSAMPLE(*inptr01);
r = range_limit[DITHER_565_R(y + cred, d1)];
g = range_limit[DITHER_565_G(y + cgreen, d1)];
b = range_limit[DITHER_565_B(y + cblue, d1)];
rgb = PACK_SHORT_565(r, g, b);
*(INT16 *)outptr1 = (INT16)rgb;
}
}","INLINE
LOCAL(void)
h2v2_merged_upsample_565D_internal(j_decompress_ptr VAR_0,
JSAMPIMAGE VAR_1,
JDIMENSION VAR_2,
JSAMPARRAY VAR_3)
{
my_upsample_ptr VAR_4 = (my_upsample_ptr)VAR_0->upsample;
register int VAR_5, VAR_6, VAR_7, VAR_8;
int VAR_9, VAR_10;
register JSAMPROW VAR_11, VAR_12;
JSAMPROW VAR_13, VAR_14, VAR_15, VAR_16;
JDIMENSION VAR_17;
register JSAMPLE *VAR_18 = VAR_0->sample_range_limit;
int *VAR_19 = VAR_4->Cr_r_tab;
int *VAR_20 = VAR_4->Cb_b_tab;
JLONG *VAR_21 = VAR_4->Cr_g_tab;
JLONG *VAR_22 = VAR_4->Cb_g_tab;
JLONG VAR_23 = VAR_24[VAR_0->output_scanline & VAR_25];
JLONG VAR_26 = VAR_24[(VAR_0->output_scanline + 1) & VAR_25];
unsigned int VAR_27, VAR_28, VAR_29;
JLONG VAR_30;
SHIFT_TEMPS
VAR_13 = VAR_1[0][VAR_2 * 2];
VAR_14 = VAR_1[0][VAR_2 * 2 + 1];
VAR_15 = VAR_1[1][VAR_2];
VAR_16 = VAR_1[2][VAR_2];
VAR_11 = VAR_3[0];
VAR_12 = VAR_3[1];
for (VAR_17 = VAR_0->output_width >> 1; VAR_17 > 0; VAR_17--) {
VAR_9 = GETJSAMPLE(*VAR_15++);
VAR_10 = GETJSAMPLE(*VAR_16++);
VAR_6 = VAR_19[VAR_10];
VAR_7 = (int)RIGHT_SHIFT(VAR_22[VAR_9] + VAR_21[VAR_10], VAR_31);
VAR_8 = VAR_20[VAR_9];
VAR_5  = GETJSAMPLE(*VAR_13++);
VAR_27 = VAR_18[DITHER_565_R(VAR_5 + VAR_6, VAR_23)];
VAR_28 = VAR_18[DITHER_565_G(VAR_5 + VAR_7, VAR_23)];
VAR_29 = VAR_18[DITHER_565_B(VAR_5 + VAR_8, VAR_23)];
VAR_23 = DITHER_ROTATE(VAR_23);
VAR_30 = PACK_SHORT_565(VAR_27, VAR_28, VAR_29);
VAR_5  = GETJSAMPLE(*VAR_13++);
VAR_27 = VAR_18[DITHER_565_R(VAR_5 + VAR_6, VAR_23)];
VAR_28 = VAR_18[DITHER_565_G(VAR_5 + VAR_7, VAR_23)];
VAR_29 = VAR_18[DITHER_565_B(VAR_5 + VAR_8, VAR_23)];
VAR_23 = DITHER_ROTATE(VAR_23);
VAR_30 = PACK_TWO_PIXELS(VAR_30, PACK_SHORT_565(VAR_27, VAR_28, VAR_29));
WRITE_TWO_PIXELS(VAR_11, VAR_30);
VAR_11 += 4;
VAR_5  = GETJSAMPLE(*VAR_14++);
VAR_27 = VAR_18[DITHER_565_R(VAR_5 + VAR_6, VAR_26)];
VAR_28 = VAR_18[DITHER_565_G(VAR_5 + VAR_7, VAR_26)];
VAR_29 = VAR_18[DITHER_565_B(VAR_5 + VAR_8, VAR_26)];
VAR_26 = DITHER_ROTATE(VAR_26);
VAR_30 = PACK_SHORT_565(VAR_27, VAR_28, VAR_29);
VAR_5  = GETJSAMPLE(*VAR_14++);
VAR_27 = VAR_18[DITHER_565_R(VAR_5 + VAR_6, VAR_26)];
VAR_28 = VAR_18[DITHER_565_G(VAR_5 + VAR_7, VAR_26)];
VAR_29 = VAR_18[DITHER_565_B(VAR_5 + VAR_8, VAR_26)];
VAR_26 = DITHER_ROTATE(VAR_26);
VAR_30 = PACK_TWO_PIXELS(VAR_30, PACK_SHORT_565(VAR_27, VAR_28, VAR_29));
WRITE_TWO_PIXELS(VAR_12, VAR_30);
VAR_12 += 4;
}
if (VAR_0->output_width & 1) {
VAR_9 = GETJSAMPLE(*VAR_15);
VAR_10 = GETJSAMPLE(*VAR_16);
VAR_6 = VAR_19[VAR_10];
VAR_7 = (int)RIGHT_SHIFT(VAR_22[VAR_9] + VAR_21[VAR_10], VAR_31);
VAR_8 = VAR_20[VAR_9];
VAR_5  = GETJSAMPLE(*VAR_13);
VAR_27 = VAR_18[DITHER_565_R(VAR_5 + VAR_6, VAR_23)];
VAR_28 = VAR_18[DITHER_565_G(VAR_5 + VAR_7, VAR_23)];
VAR_29 = VAR_18[DITHER_565_B(VAR_5 + VAR_8, VAR_23)];
VAR_30 = PACK_SHORT_565(VAR_27, VAR_28, VAR_29);
*(INT16 *)VAR_11 = (INT16)VAR_30;
VAR_5  = GETJSAMPLE(*VAR_14);
VAR_27 = VAR_18[DITHER_565_R(VAR_5 + VAR_6, VAR_26)];
VAR_28 = VAR_18[DITHER_565_G(VAR_5 + VAR_7, VAR_26)];
VAR_29 = VAR_18[DITHER_565_B(VAR_5 + VAR_8, VAR_26)];
VAR_30 = PACK_SHORT_565(VAR_27, VAR_28, VAR_29);
*(INT16 *)VAR_12 = (INT16)VAR_30;
}
}",,"INLINE
LOCAL(void)
h2v2_merged_upsample_565D_internal(j_decompress_ptr cinfo,
                                   JSAMPIMAGE input_buf,
                                   JDIMENSION in_row_group_ctr,
                                   JSAMPARRAY output_buf)
{
  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
  register int y, cred, cgreen, cblue;
  int cb, cr;
  register JSAMPROW outptr0, outptr1;
  JSAMPROW inptr00, inptr01, inptr1, inptr2;
  JDIMENSION col;
  /* copy these pointers into registers if possible */
  register JSAMPLE *range_limit = cinfo->sample_range_limit;
  int *Crrtab = upsample->Cr_r_tab;
  int *Cbbtab = upsample->Cb_b_tab;
  JLONG *Crgtab = upsample->Cr_g_tab;
  JLONG *Cbgtab = upsample->Cb_g_tab;
  JLONG d0 = dither_matrix[cinfo->output_scanline & DITHER_MASK];
  JLONG d1 = dither_matrix[(cinfo->output_scanline + 1) & DITHER_MASK];
  unsigned int r, g, b;
  JLONG rgb;
  SHIFT_TEMPS

  inptr00 = input_buf[0][in_row_group_ctr * 2];
  inptr01 = input_buf[0][in_row_group_ctr * 2 + 1];
  inptr1 = input_buf[1][in_row_group_ctr];
  inptr2 = input_buf[2][in_row_group_ctr];
  outptr0 = output_buf[0];
  outptr1 = output_buf[1];

  /* Loop for each group of output pixels */
  for (col = cinfo->output_width >> 1; col > 0; col--) {
    /* Do the chroma part of the calculation */
    cb = GETJSAMPLE(*inptr1++);
    cr = GETJSAMPLE(*inptr2++);
    cred = Crrtab[cr];
    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
    cblue = Cbbtab[cb];

    /* Fetch 4 Y values and emit 4 pixels */
    y  = GETJSAMPLE(*inptr00++);
    r = range_limit[DITHER_565_R(y + cred, d0)];
    g = range_limit[DITHER_565_G(y + cgreen, d0)];
    b = range_limit[DITHER_565_B(y + cblue, d0)];
    d0 = DITHER_ROTATE(d0);
    rgb = PACK_SHORT_565(r, g, b);

    y  = GETJSAMPLE(*inptr00++);
    r = range_limit[DITHER_565_R(y + cred, d0)];
    g = range_limit[DITHER_565_G(y + cgreen, d0)];
    b = range_limit[DITHER_565_B(y + cblue, d0)];
    d0 = DITHER_ROTATE(d0);
    rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));

    WRITE_TWO_PIXELS(outptr0, rgb);
    outptr0 += 4;

    y  = GETJSAMPLE(*inptr01++);
    r = range_limit[DITHER_565_R(y + cred, d1)];
    g = range_limit[DITHER_565_G(y + cgreen, d1)];
    b = range_limit[DITHER_565_B(y + cblue, d1)];
    d1 = DITHER_ROTATE(d1);
    rgb = PACK_SHORT_565(r, g, b);

    y  = GETJSAMPLE(*inptr01++);
    r = range_limit[DITHER_565_R(y + cred, d1)];
    g = range_limit[DITHER_565_G(y + cgreen, d1)];
    b = range_limit[DITHER_565_B(y + cblue, d1)];
    d1 = DITHER_ROTATE(d1);
    rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));

    WRITE_TWO_PIXELS(outptr1, rgb);
    outptr1 += 4;
  }

  /* If image width is odd, do the last output column separately */
  if (cinfo->output_width & 1) {
    cb = GETJSAMPLE(*inptr1);
    cr = GETJSAMPLE(*inptr2);
    cred = Crrtab[cr];
    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
    cblue = Cbbtab[cb];

    y  = GETJSAMPLE(*inptr00);
    r = range_limit[DITHER_565_R(y + cred, d0)];
    g = range_limit[DITHER_565_G(y + cgreen, d0)];
    b = range_limit[DITHER_565_B(y + cblue, d0)];
    rgb = PACK_SHORT_565(r, g, b);
    *(INT16 *)outptr0 = (INT16)rgb;

    y  = GETJSAMPLE(*inptr01);
    r = range_limit[DITHER_565_R(y + cred, d1)];
    g = range_limit[DITHER_565_G(y + cgreen, d1)];
    b = range_limit[DITHER_565_B(y + cblue, d1)];
    rgb = PACK_SHORT_565(r, g, b);
    *(INT16 *)outptr1 = (INT16)rgb;
  }
}","INLINE
LOCAL(void)
h2v2_merged_upsample_565D_internal(j_decompress_ptr VAR_0,
                                   JSAMPIMAGE VAR_1,
                                   JDIMENSION VAR_2,
                                   JSAMPARRAY VAR_3)
{
  my_merged_upsample_ptr VAR_4 = (my_merged_upsample_ptr)VAR_0->upsample;
  register int VAR_5, VAR_6, VAR_7, VAR_8;
  int VAR_9, VAR_10;
  register JSAMPROW VAR_11, VAR_12;
  JSAMPROW VAR_13, VAR_14, VAR_15, VAR_16;
  JDIMENSION VAR_17;
  /* COMMENT_0 */
  register JSAMPLE *VAR_18 = VAR_0->sample_range_limit;
  int *VAR_19 = VAR_4->Cr_r_tab;
  int *VAR_20 = VAR_4->Cb_b_tab;
  JLONG *VAR_21 = VAR_4->Cr_g_tab;
  JLONG *VAR_22 = VAR_4->Cb_g_tab;
  JLONG VAR_23 = VAR_24[VAR_0->output_scanline & VAR_25];
  JLONG VAR_26 = VAR_24[(VAR_0->output_scanline + 1) & VAR_25];
  unsigned int VAR_27, VAR_28, VAR_29;
  JLONG VAR_30;
  SHIFT_TEMPS

  VAR_13 = VAR_1[0][VAR_2 * 2];
  VAR_14 = VAR_1[0][VAR_2 * 2 + 1];
  VAR_15 = VAR_1[1][VAR_2];
  VAR_16 = VAR_1[2][VAR_2];
  VAR_11 = VAR_3[0];
  VAR_12 = VAR_3[1];

  /* COMMENT_1 */
  for (VAR_17 = VAR_0->output_width >> 1; VAR_17 > 0; VAR_17--) {
    /* COMMENT_2 */
    VAR_9 = GETJSAMPLE(*VAR_15++);
    VAR_10 = GETJSAMPLE(*VAR_16++);
    VAR_6 = VAR_19[VAR_10];
    VAR_7 = (int)RIGHT_SHIFT(VAR_22[VAR_9] + VAR_21[VAR_10], VAR_31);
    VAR_8 = VAR_20[VAR_9];

    /* COMMENT_3 */
    VAR_5  = GETJSAMPLE(*VAR_13++);
    VAR_27 = VAR_18[DITHER_565_R(VAR_5 + VAR_6, VAR_23)];
    VAR_28 = VAR_18[DITHER_565_G(VAR_5 + VAR_7, VAR_23)];
    VAR_29 = VAR_18[DITHER_565_B(VAR_5 + VAR_8, VAR_23)];
    VAR_23 = DITHER_ROTATE(VAR_23);
    VAR_30 = PACK_SHORT_565(VAR_27, VAR_28, VAR_29);

    VAR_5  = GETJSAMPLE(*VAR_13++);
    VAR_27 = VAR_18[DITHER_565_R(VAR_5 + VAR_6, VAR_23)];
    VAR_28 = VAR_18[DITHER_565_G(VAR_5 + VAR_7, VAR_23)];
    VAR_29 = VAR_18[DITHER_565_B(VAR_5 + VAR_8, VAR_23)];
    VAR_23 = DITHER_ROTATE(VAR_23);
    VAR_30 = PACK_TWO_PIXELS(VAR_30, PACK_SHORT_565(VAR_27, VAR_28, VAR_29));

    WRITE_TWO_PIXELS(VAR_11, VAR_30);
    VAR_11 += 4;

    VAR_5  = GETJSAMPLE(*VAR_14++);
    VAR_27 = VAR_18[DITHER_565_R(VAR_5 + VAR_6, VAR_26)];
    VAR_28 = VAR_18[DITHER_565_G(VAR_5 + VAR_7, VAR_26)];
    VAR_29 = VAR_18[DITHER_565_B(VAR_5 + VAR_8, VAR_26)];
    VAR_26 = DITHER_ROTATE(VAR_26);
    VAR_30 = PACK_SHORT_565(VAR_27, VAR_28, VAR_29);

    VAR_5  = GETJSAMPLE(*VAR_14++);
    VAR_27 = VAR_18[DITHER_565_R(VAR_5 + VAR_6, VAR_26)];
    VAR_28 = VAR_18[DITHER_565_G(VAR_5 + VAR_7, VAR_26)];
    VAR_29 = VAR_18[DITHER_565_B(VAR_5 + VAR_8, VAR_26)];
    VAR_26 = DITHER_ROTATE(VAR_26);
    VAR_30 = PACK_TWO_PIXELS(VAR_30, PACK_SHORT_565(VAR_27, VAR_28, VAR_29));

    WRITE_TWO_PIXELS(VAR_12, VAR_30);
    VAR_12 += 4;
  }

  /* COMMENT_4 */
  if (VAR_0->output_width & 1) {
    VAR_9 = GETJSAMPLE(*VAR_15);
    VAR_10 = GETJSAMPLE(*VAR_16);
    VAR_6 = VAR_19[VAR_10];
    VAR_7 = (int)RIGHT_SHIFT(VAR_22[VAR_9] + VAR_21[VAR_10], VAR_31);
    VAR_8 = VAR_20[VAR_9];

    VAR_5  = GETJSAMPLE(*VAR_13);
    VAR_27 = VAR_18[DITHER_565_R(VAR_5 + VAR_6, VAR_23)];
    VAR_28 = VAR_18[DITHER_565_G(VAR_5 + VAR_7, VAR_23)];
    VAR_29 = VAR_18[DITHER_565_B(VAR_5 + VAR_8, VAR_23)];
    VAR_30 = PACK_SHORT_565(VAR_27, VAR_28, VAR_29);
    *(INT16 *)VAR_11 = (INT16)VAR_30;

    VAR_5  = GETJSAMPLE(*VAR_14);
    VAR_27 = VAR_18[DITHER_565_R(VAR_5 + VAR_6, VAR_26)];
    VAR_28 = VAR_18[DITHER_565_G(VAR_5 + VAR_7, VAR_26)];
    VAR_29 = VAR_18[DITHER_565_B(VAR_5 + VAR_8, VAR_26)];
    VAR_30 = PACK_SHORT_565(VAR_27, VAR_28, VAR_29);
    *(INT16 *)VAR_12 = (INT16)VAR_30;
  }
}",,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
                                    JDIMENSION in_row_group_ctr,
                                    JSAMPARRAY output_buf)
 {
-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
   register int y, cred, cgreen, cblue;
   int cb, cr;
   register JSAMPROW outptr0, outptr1;","{'deleted_lines': ['  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;'], 'added_lines': ['  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;']}",True,A crafted input file could cause a null pointer dereference in jcopy_sample_rows() when processed by libjpeg-turbo.,5.5,MEDIUM,1,valid,2020-07-24T02:24:38Z,3
CVE-2020-35538,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libjpeg-turbo,"Fix jpeg_skip_scanlines() segfault w/merged upsamp

The additional segfault mentioned in #244 was due to the fact that
the merged upsamplers use a different private structure than the
non-merged upsamplers.  jpeg_skip_scanlines() was assuming the latter, so
when merged upsampling was enabled, jpeg_skip_scanlines() clobbered one
of the IDCT method pointers in the merged upsampler's private structure.

For reasons unknown, the test image in #441 did not encounter this
segfault (too small?), but it encountered an issue similar to the one
fixed in 5bc43c7821df982f65aa1c738f67fbf7cba8bd69, whereby it was
necessary to set up a dummy postprocessing function in
read_and_discard_scanlines() when merged upsampling was enabled.
Failing to do so caused either a segfault in merged_2v_upsample() (due
to a NULL pointer being passed to jcopy_sample_rows()) or an error
(""Corrupt JPEG data: premature end of data segment""), depending on the
number of scanlines skipped and whether the first scanline skipped was
an odd- or even-numbered row.

Fixes #441
Fixes #244 (for real this time)",9120a247436e84c0b4eea828cb11e8f665fcde30,https://github.com/libjpeg-turbo/libjpeg-turbo/commit/9120a247436e84c0b4eea828cb11e8f665fcde30,jdmrg565.c,h2v2_merged_upsample_565_internal,"INLINE
LOCAL(void)
h2v2_merged_upsample_565_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
JDIMENSION in_row_group_ctr,
JSAMPARRAY output_buf)
{
my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
register int y, cred, cgreen, cblue;
int cb, cr;
register JSAMPROW outptr0, outptr1;
JSAMPROW inptr00, inptr01, inptr1, inptr2;
JDIMENSION col;
register JSAMPLE *range_limit = cinfo->sample_range_limit;
int *Crrtab = upsample->Cr_r_tab;
int *Cbbtab = upsample->Cb_b_tab;
JLONG *Crgtab = upsample->Cr_g_tab;
JLONG *Cbgtab = upsample->Cb_g_tab;
unsigned int r, g, b;
JLONG rgb;
SHIFT_TEMPS
inptr00 = input_buf[0][in_row_group_ctr * 2];
inptr01 = input_buf[0][in_row_group_ctr * 2 + 1];
inptr1 = input_buf[1][in_row_group_ctr];
inptr2 = input_buf[2][in_row_group_ctr];
outptr0 = output_buf[0];
outptr1 = output_buf[1];
for (col = cinfo->output_width >> 1; col > 0; col--) {
cb = GETJSAMPLE(*inptr1++);
cr = GETJSAMPLE(*inptr2++);
cred = Crrtab[cr];
cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
cblue = Cbbtab[cb];
y  = GETJSAMPLE(*inptr00++);
r = range_limit[y + cred];
g = range_limit[y + cgreen];
b = range_limit[y + cblue];
rgb = PACK_SHORT_565(r, g, b);
y  = GETJSAMPLE(*inptr00++);
r = range_limit[y + cred];
g = range_limit[y + cgreen];
b = range_limit[y + cblue];
rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));
WRITE_TWO_PIXELS(outptr0, rgb);
outptr0 += 4;
y  = GETJSAMPLE(*inptr01++);
r = range_limit[y + cred];
g = range_limit[y + cgreen];
b = range_limit[y + cblue];
rgb = PACK_SHORT_565(r, g, b);
y  = GETJSAMPLE(*inptr01++);
r = range_limit[y + cred];
g = range_limit[y + cgreen];
b = range_limit[y + cblue];
rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));
WRITE_TWO_PIXELS(outptr1, rgb);
outptr1 += 4;
}
if (cinfo->output_width & 1) {
cb = GETJSAMPLE(*inptr1);
cr = GETJSAMPLE(*inptr2);
cred = Crrtab[cr];
cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
cblue = Cbbtab[cb];
y  = GETJSAMPLE(*inptr00);
r = range_limit[y + cred];
g = range_limit[y + cgreen];
b = range_limit[y + cblue];
rgb = PACK_SHORT_565(r, g, b);
*(INT16 *)outptr0 = (INT16)rgb;
y  = GETJSAMPLE(*inptr01);
r = range_limit[y + cred];
g = range_limit[y + cgreen];
b = range_limit[y + cblue];
rgb = PACK_SHORT_565(r, g, b);
*(INT16 *)outptr1 = (INT16)rgb;
}
}","INLINE
LOCAL(void)
h2v2_merged_upsample_565_internal(j_decompress_ptr VAR_0, JSAMPIMAGE VAR_1,
JDIMENSION VAR_2,
JSAMPARRAY VAR_3)
{
my_upsample_ptr VAR_4 = (my_upsample_ptr)VAR_0->upsample;
register int VAR_5, VAR_6, VAR_7, VAR_8;
int VAR_9, VAR_10;
register JSAMPROW VAR_11, VAR_12;
JSAMPROW VAR_13, VAR_14, VAR_15, VAR_16;
JDIMENSION VAR_17;
register JSAMPLE *VAR_18 = VAR_0->sample_range_limit;
int *VAR_19 = VAR_4->Cr_r_tab;
int *VAR_20 = VAR_4->Cb_b_tab;
JLONG *VAR_21 = VAR_4->Cr_g_tab;
JLONG *VAR_22 = VAR_4->Cb_g_tab;
unsigned int VAR_23, VAR_24, VAR_25;
JLONG VAR_26;
SHIFT_TEMPS
VAR_13 = VAR_1[0][VAR_2 * 2];
VAR_14 = VAR_1[0][VAR_2 * 2 + 1];
VAR_15 = VAR_1[1][VAR_2];
VAR_16 = VAR_1[2][VAR_2];
VAR_11 = VAR_3[0];
VAR_12 = VAR_3[1];
for (VAR_17 = VAR_0->output_width >> 1; VAR_17 > 0; VAR_17--) {
VAR_9 = GETJSAMPLE(*VAR_15++);
VAR_10 = GETJSAMPLE(*VAR_16++);
VAR_6 = VAR_19[VAR_10];
VAR_7 = (int)RIGHT_SHIFT(VAR_22[VAR_9] + VAR_21[VAR_10], VAR_27);
VAR_8 = VAR_20[VAR_9];
VAR_5  = GETJSAMPLE(*VAR_13++);
VAR_23 = VAR_18[VAR_5 + VAR_6];
VAR_24 = VAR_18[VAR_5 + VAR_7];
VAR_25 = VAR_18[VAR_5 + VAR_8];
VAR_26 = PACK_SHORT_565(VAR_23, VAR_24, VAR_25);
VAR_5  = GETJSAMPLE(*VAR_13++);
VAR_23 = VAR_18[VAR_5 + VAR_6];
VAR_24 = VAR_18[VAR_5 + VAR_7];
VAR_25 = VAR_18[VAR_5 + VAR_8];
VAR_26 = PACK_TWO_PIXELS(VAR_26, PACK_SHORT_565(VAR_23, VAR_24, VAR_25));
WRITE_TWO_PIXELS(VAR_11, VAR_26);
VAR_11 += 4;
VAR_5  = GETJSAMPLE(*VAR_14++);
VAR_23 = VAR_18[VAR_5 + VAR_6];
VAR_24 = VAR_18[VAR_5 + VAR_7];
VAR_25 = VAR_18[VAR_5 + VAR_8];
VAR_26 = PACK_SHORT_565(VAR_23, VAR_24, VAR_25);
VAR_5  = GETJSAMPLE(*VAR_14++);
VAR_23 = VAR_18[VAR_5 + VAR_6];
VAR_24 = VAR_18[VAR_5 + VAR_7];
VAR_25 = VAR_18[VAR_5 + VAR_8];
VAR_26 = PACK_TWO_PIXELS(VAR_26, PACK_SHORT_565(VAR_23, VAR_24, VAR_25));
WRITE_TWO_PIXELS(VAR_12, VAR_26);
VAR_12 += 4;
}
if (VAR_0->output_width & 1) {
VAR_9 = GETJSAMPLE(*VAR_15);
VAR_10 = GETJSAMPLE(*VAR_16);
VAR_6 = VAR_19[VAR_10];
VAR_7 = (int)RIGHT_SHIFT(VAR_22[VAR_9] + VAR_21[VAR_10], VAR_27);
VAR_8 = VAR_20[VAR_9];
VAR_5  = GETJSAMPLE(*VAR_13);
VAR_23 = VAR_18[VAR_5 + VAR_6];
VAR_24 = VAR_18[VAR_5 + VAR_7];
VAR_25 = VAR_18[VAR_5 + VAR_8];
VAR_26 = PACK_SHORT_565(VAR_23, VAR_24, VAR_25);
*(INT16 *)VAR_11 = (INT16)VAR_26;
VAR_5  = GETJSAMPLE(*VAR_14);
VAR_23 = VAR_18[VAR_5 + VAR_6];
VAR_24 = VAR_18[VAR_5 + VAR_7];
VAR_25 = VAR_18[VAR_5 + VAR_8];
VAR_26 = PACK_SHORT_565(VAR_23, VAR_24, VAR_25);
*(INT16 *)VAR_12 = (INT16)VAR_26;
}
}",,"INLINE
LOCAL(void)
h2v2_merged_upsample_565_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
                                  JDIMENSION in_row_group_ctr,
                                  JSAMPARRAY output_buf)
{
  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
  register int y, cred, cgreen, cblue;
  int cb, cr;
  register JSAMPROW outptr0, outptr1;
  JSAMPROW inptr00, inptr01, inptr1, inptr2;
  JDIMENSION col;
  /* copy these pointers into registers if possible */
  register JSAMPLE *range_limit = cinfo->sample_range_limit;
  int *Crrtab = upsample->Cr_r_tab;
  int *Cbbtab = upsample->Cb_b_tab;
  JLONG *Crgtab = upsample->Cr_g_tab;
  JLONG *Cbgtab = upsample->Cb_g_tab;
  unsigned int r, g, b;
  JLONG rgb;
  SHIFT_TEMPS

  inptr00 = input_buf[0][in_row_group_ctr * 2];
  inptr01 = input_buf[0][in_row_group_ctr * 2 + 1];
  inptr1 = input_buf[1][in_row_group_ctr];
  inptr2 = input_buf[2][in_row_group_ctr];
  outptr0 = output_buf[0];
  outptr1 = output_buf[1];

  /* Loop for each group of output pixels */
  for (col = cinfo->output_width >> 1; col > 0; col--) {
    /* Do the chroma part of the calculation */
    cb = GETJSAMPLE(*inptr1++);
    cr = GETJSAMPLE(*inptr2++);
    cred = Crrtab[cr];
    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
    cblue = Cbbtab[cb];

    /* Fetch 4 Y values and emit 4 pixels */
    y  = GETJSAMPLE(*inptr00++);
    r = range_limit[y + cred];
    g = range_limit[y + cgreen];
    b = range_limit[y + cblue];
    rgb = PACK_SHORT_565(r, g, b);

    y  = GETJSAMPLE(*inptr00++);
    r = range_limit[y + cred];
    g = range_limit[y + cgreen];
    b = range_limit[y + cblue];
    rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));

    WRITE_TWO_PIXELS(outptr0, rgb);
    outptr0 += 4;

    y  = GETJSAMPLE(*inptr01++);
    r = range_limit[y + cred];
    g = range_limit[y + cgreen];
    b = range_limit[y + cblue];
    rgb = PACK_SHORT_565(r, g, b);

    y  = GETJSAMPLE(*inptr01++);
    r = range_limit[y + cred];
    g = range_limit[y + cgreen];
    b = range_limit[y + cblue];
    rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));

    WRITE_TWO_PIXELS(outptr1, rgb);
    outptr1 += 4;
  }

  /* If image width is odd, do the last output column separately */
  if (cinfo->output_width & 1) {
    cb = GETJSAMPLE(*inptr1);
    cr = GETJSAMPLE(*inptr2);
    cred = Crrtab[cr];
    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
    cblue = Cbbtab[cb];

    y  = GETJSAMPLE(*inptr00);
    r = range_limit[y + cred];
    g = range_limit[y + cgreen];
    b = range_limit[y + cblue];
    rgb = PACK_SHORT_565(r, g, b);
    *(INT16 *)outptr0 = (INT16)rgb;

    y  = GETJSAMPLE(*inptr01);
    r = range_limit[y + cred];
    g = range_limit[y + cgreen];
    b = range_limit[y + cblue];
    rgb = PACK_SHORT_565(r, g, b);
    *(INT16 *)outptr1 = (INT16)rgb;
  }
}","INLINE
LOCAL(void)
h2v2_merged_upsample_565_internal(j_decompress_ptr VAR_0, JSAMPIMAGE VAR_1,
                                  JDIMENSION VAR_2,
                                  JSAMPARRAY VAR_3)
{
  my_merged_upsample_ptr VAR_4 = (my_merged_upsample_ptr)VAR_0->upsample;
  register int VAR_5, VAR_6, VAR_7, VAR_8;
  int VAR_9, VAR_10;
  register JSAMPROW VAR_11, VAR_12;
  JSAMPROW VAR_13, VAR_14, VAR_15, VAR_16;
  JDIMENSION VAR_17;
  /* COMMENT_0 */
  register JSAMPLE *VAR_18 = VAR_0->sample_range_limit;
  int *VAR_19 = VAR_4->Cr_r_tab;
  int *VAR_20 = VAR_4->Cb_b_tab;
  JLONG *VAR_21 = VAR_4->Cr_g_tab;
  JLONG *VAR_22 = VAR_4->Cb_g_tab;
  unsigned int VAR_23, VAR_24, VAR_25;
  JLONG VAR_26;
  SHIFT_TEMPS

  VAR_13 = VAR_1[0][VAR_2 * 2];
  VAR_14 = VAR_1[0][VAR_2 * 2 + 1];
  VAR_15 = VAR_1[1][VAR_2];
  VAR_16 = VAR_1[2][VAR_2];
  VAR_11 = VAR_3[0];
  VAR_12 = VAR_3[1];

  /* COMMENT_1 */
  for (VAR_17 = VAR_0->output_width >> 1; VAR_17 > 0; VAR_17--) {
    /* COMMENT_2 */
    VAR_9 = GETJSAMPLE(*VAR_15++);
    VAR_10 = GETJSAMPLE(*VAR_16++);
    VAR_6 = VAR_19[VAR_10];
    VAR_7 = (int)RIGHT_SHIFT(VAR_22[VAR_9] + VAR_21[VAR_10], VAR_27);
    VAR_8 = VAR_20[VAR_9];

    /* COMMENT_3 */
    VAR_5  = GETJSAMPLE(*VAR_13++);
    VAR_23 = VAR_18[VAR_5 + VAR_6];
    VAR_24 = VAR_18[VAR_5 + VAR_7];
    VAR_25 = VAR_18[VAR_5 + VAR_8];
    VAR_26 = PACK_SHORT_565(VAR_23, VAR_24, VAR_25);

    VAR_5  = GETJSAMPLE(*VAR_13++);
    VAR_23 = VAR_18[VAR_5 + VAR_6];
    VAR_24 = VAR_18[VAR_5 + VAR_7];
    VAR_25 = VAR_18[VAR_5 + VAR_8];
    VAR_26 = PACK_TWO_PIXELS(VAR_26, PACK_SHORT_565(VAR_23, VAR_24, VAR_25));

    WRITE_TWO_PIXELS(VAR_11, VAR_26);
    VAR_11 += 4;

    VAR_5  = GETJSAMPLE(*VAR_14++);
    VAR_23 = VAR_18[VAR_5 + VAR_6];
    VAR_24 = VAR_18[VAR_5 + VAR_7];
    VAR_25 = VAR_18[VAR_5 + VAR_8];
    VAR_26 = PACK_SHORT_565(VAR_23, VAR_24, VAR_25);

    VAR_5  = GETJSAMPLE(*VAR_14++);
    VAR_23 = VAR_18[VAR_5 + VAR_6];
    VAR_24 = VAR_18[VAR_5 + VAR_7];
    VAR_25 = VAR_18[VAR_5 + VAR_8];
    VAR_26 = PACK_TWO_PIXELS(VAR_26, PACK_SHORT_565(VAR_23, VAR_24, VAR_25));

    WRITE_TWO_PIXELS(VAR_12, VAR_26);
    VAR_12 += 4;
  }

  /* COMMENT_4 */
  if (VAR_0->output_width & 1) {
    VAR_9 = GETJSAMPLE(*VAR_15);
    VAR_10 = GETJSAMPLE(*VAR_16);
    VAR_6 = VAR_19[VAR_10];
    VAR_7 = (int)RIGHT_SHIFT(VAR_22[VAR_9] + VAR_21[VAR_10], VAR_27);
    VAR_8 = VAR_20[VAR_9];

    VAR_5  = GETJSAMPLE(*VAR_13);
    VAR_23 = VAR_18[VAR_5 + VAR_6];
    VAR_24 = VAR_18[VAR_5 + VAR_7];
    VAR_25 = VAR_18[VAR_5 + VAR_8];
    VAR_26 = PACK_SHORT_565(VAR_23, VAR_24, VAR_25);
    *(INT16 *)VAR_11 = (INT16)VAR_26;

    VAR_5  = GETJSAMPLE(*VAR_14);
    VAR_23 = VAR_18[VAR_5 + VAR_6];
    VAR_24 = VAR_18[VAR_5 + VAR_7];
    VAR_25 = VAR_18[VAR_5 + VAR_8];
    VAR_26 = PACK_SHORT_565(VAR_23, VAR_24, VAR_25);
    *(INT16 *)VAR_12 = (INT16)VAR_26;
  }
}",,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
                                   JDIMENSION in_row_group_ctr,
                                   JSAMPARRAY output_buf)
 {
-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
   register int y, cred, cgreen, cblue;
   int cb, cr;
   register JSAMPROW outptr0, outptr1;","{'deleted_lines': ['  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;'], 'added_lines': ['  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;']}",True,A crafted input file could cause a null pointer dereference in jcopy_sample_rows() when processed by libjpeg-turbo.,5.5,MEDIUM,1,valid,2020-07-24T02:24:38Z,3
CVE-2020-35538,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libjpeg-turbo,"Fix jpeg_skip_scanlines() segfault w/merged upsamp

The additional segfault mentioned in #244 was due to the fact that
the merged upsamplers use a different private structure than the
non-merged upsamplers.  jpeg_skip_scanlines() was assuming the latter, so
when merged upsampling was enabled, jpeg_skip_scanlines() clobbered one
of the IDCT method pointers in the merged upsampler's private structure.

For reasons unknown, the test image in #441 did not encounter this
segfault (too small?), but it encountered an issue similar to the one
fixed in 5bc43c7821df982f65aa1c738f67fbf7cba8bd69, whereby it was
necessary to set up a dummy postprocessing function in
read_and_discard_scanlines() when merged upsampling was enabled.
Failing to do so caused either a segfault in merged_2v_upsample() (due
to a NULL pointer being passed to jcopy_sample_rows()) or an error
(""Corrupt JPEG data: premature end of data segment""), depending on the
number of scanlines skipped and whether the first scanline skipped was
an odd- or even-numbered row.

Fixes #441
Fixes #244 (for real this time)",9120a247436e84c0b4eea828cb11e8f665fcde30,https://github.com/libjpeg-turbo/libjpeg-turbo/commit/9120a247436e84c0b4eea828cb11e8f665fcde30,jdmrg565.c,h2v1_merged_upsample_565D_internal,"INLINE
LOCAL(void)
h2v1_merged_upsample_565D_internal(j_decompress_ptr cinfo,
JSAMPIMAGE input_buf,
JDIMENSION in_row_group_ctr,
JSAMPARRAY output_buf)
{
my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
register int y, cred, cgreen, cblue;
int cb, cr;
register JSAMPROW outptr;
JSAMPROW inptr0, inptr1, inptr2;
JDIMENSION col;
register JSAMPLE *range_limit = cinfo->sample_range_limit;
int *Crrtab = upsample->Cr_r_tab;
int *Cbbtab = upsample->Cb_b_tab;
JLONG *Crgtab = upsample->Cr_g_tab;
JLONG *Cbgtab = upsample->Cb_g_tab;
JLONG d0 = dither_matrix[cinfo->output_scanline & DITHER_MASK];
unsigned int r, g, b;
JLONG rgb;
SHIFT_TEMPS
inptr0 = input_buf[0][in_row_group_ctr];
inptr1 = input_buf[1][in_row_group_ctr];
inptr2 = input_buf[2][in_row_group_ctr];
outptr = output_buf[0];
for (col = cinfo->output_width >> 1; col > 0; col--) {
cb = GETJSAMPLE(*inptr1++);
cr = GETJSAMPLE(*inptr2++);
cred = Crrtab[cr];
cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
cblue = Cbbtab[cb];
y  = GETJSAMPLE(*inptr0++);
r = range_limit[DITHER_565_R(y + cred, d0)];
g = range_limit[DITHER_565_G(y + cgreen, d0)];
b = range_limit[DITHER_565_B(y + cblue, d0)];
d0 = DITHER_ROTATE(d0);
rgb = PACK_SHORT_565(r, g, b);
y  = GETJSAMPLE(*inptr0++);
r = range_limit[DITHER_565_R(y + cred, d0)];
g = range_limit[DITHER_565_G(y + cgreen, d0)];
b = range_limit[DITHER_565_B(y + cblue, d0)];
d0 = DITHER_ROTATE(d0);
rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));
WRITE_TWO_PIXELS(outptr, rgb);
outptr += 4;
}
if (cinfo->output_width & 1) {
cb = GETJSAMPLE(*inptr1);
cr = GETJSAMPLE(*inptr2);
cred = Crrtab[cr];
cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
cblue = Cbbtab[cb];
y  = GETJSAMPLE(*inptr0);
r = range_limit[DITHER_565_R(y + cred, d0)];
g = range_limit[DITHER_565_G(y + cgreen, d0)];
b = range_limit[DITHER_565_B(y + cblue, d0)];
rgb = PACK_SHORT_565(r, g, b);
*(INT16 *)outptr = (INT16)rgb;
}
}","INLINE
LOCAL(void)
h2v1_merged_upsample_565D_internal(j_decompress_ptr VAR_0,
JSAMPIMAGE VAR_1,
JDIMENSION VAR_2,
JSAMPARRAY VAR_3)
{
my_upsample_ptr VAR_4 = (my_upsample_ptr)VAR_0->upsample;
register int VAR_5, VAR_6, VAR_7, VAR_8;
int VAR_9, VAR_10;
register JSAMPROW VAR_11;
JSAMPROW VAR_12, VAR_13, VAR_14;
JDIMENSION VAR_15;
register JSAMPLE *VAR_16 = VAR_0->sample_range_limit;
int *VAR_17 = VAR_4->Cr_r_tab;
int *VAR_18 = VAR_4->Cb_b_tab;
JLONG *VAR_19 = VAR_4->Cr_g_tab;
JLONG *VAR_20 = VAR_4->Cb_g_tab;
JLONG VAR_21 = VAR_22[VAR_0->output_scanline & VAR_23];
unsigned int VAR_24, VAR_25, VAR_26;
JLONG VAR_27;
SHIFT_TEMPS
VAR_12 = VAR_1[0][VAR_2];
VAR_13 = VAR_1[1][VAR_2];
VAR_14 = VAR_1[2][VAR_2];
VAR_11 = VAR_3[0];
for (VAR_15 = VAR_0->output_width >> 1; VAR_15 > 0; VAR_15--) {
VAR_9 = GETJSAMPLE(*VAR_13++);
VAR_10 = GETJSAMPLE(*VAR_14++);
VAR_6 = VAR_17[VAR_10];
VAR_7 = (int)RIGHT_SHIFT(VAR_20[VAR_9] + VAR_19[VAR_10], VAR_28);
VAR_8 = VAR_18[VAR_9];
VAR_5  = GETJSAMPLE(*VAR_12++);
VAR_24 = VAR_16[DITHER_565_R(VAR_5 + VAR_6, VAR_21)];
VAR_25 = VAR_16[DITHER_565_G(VAR_5 + VAR_7, VAR_21)];
VAR_26 = VAR_16[DITHER_565_B(VAR_5 + VAR_8, VAR_21)];
VAR_21 = DITHER_ROTATE(VAR_21);
VAR_27 = PACK_SHORT_565(VAR_24, VAR_25, VAR_26);
VAR_5  = GETJSAMPLE(*VAR_12++);
VAR_24 = VAR_16[DITHER_565_R(VAR_5 + VAR_6, VAR_21)];
VAR_25 = VAR_16[DITHER_565_G(VAR_5 + VAR_7, VAR_21)];
VAR_26 = VAR_16[DITHER_565_B(VAR_5 + VAR_8, VAR_21)];
VAR_21 = DITHER_ROTATE(VAR_21);
VAR_27 = PACK_TWO_PIXELS(VAR_27, PACK_SHORT_565(VAR_24, VAR_25, VAR_26));
WRITE_TWO_PIXELS(VAR_11, VAR_27);
VAR_11 += 4;
}
if (VAR_0->output_width & 1) {
VAR_9 = GETJSAMPLE(*VAR_13);
VAR_10 = GETJSAMPLE(*VAR_14);
VAR_6 = VAR_17[VAR_10];
VAR_7 = (int)RIGHT_SHIFT(VAR_20[VAR_9] + VAR_19[VAR_10], VAR_28);
VAR_8 = VAR_18[VAR_9];
VAR_5  = GETJSAMPLE(*VAR_12);
VAR_24 = VAR_16[DITHER_565_R(VAR_5 + VAR_6, VAR_21)];
VAR_25 = VAR_16[DITHER_565_G(VAR_5 + VAR_7, VAR_21)];
VAR_26 = VAR_16[DITHER_565_B(VAR_5 + VAR_8, VAR_21)];
VAR_27 = PACK_SHORT_565(VAR_24, VAR_25, VAR_26);
*(INT16 *)VAR_11 = (INT16)VAR_27;
}
}",,"INLINE
LOCAL(void)
h2v1_merged_upsample_565D_internal(j_decompress_ptr cinfo,
                                   JSAMPIMAGE input_buf,
                                   JDIMENSION in_row_group_ctr,
                                   JSAMPARRAY output_buf)
{
  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
  register int y, cred, cgreen, cblue;
  int cb, cr;
  register JSAMPROW outptr;
  JSAMPROW inptr0, inptr1, inptr2;
  JDIMENSION col;
  /* copy these pointers into registers if possible */
  register JSAMPLE *range_limit = cinfo->sample_range_limit;
  int *Crrtab = upsample->Cr_r_tab;
  int *Cbbtab = upsample->Cb_b_tab;
  JLONG *Crgtab = upsample->Cr_g_tab;
  JLONG *Cbgtab = upsample->Cb_g_tab;
  JLONG d0 = dither_matrix[cinfo->output_scanline & DITHER_MASK];
  unsigned int r, g, b;
  JLONG rgb;
  SHIFT_TEMPS

  inptr0 = input_buf[0][in_row_group_ctr];
  inptr1 = input_buf[1][in_row_group_ctr];
  inptr2 = input_buf[2][in_row_group_ctr];
  outptr = output_buf[0];

  /* Loop for each pair of output pixels */
  for (col = cinfo->output_width >> 1; col > 0; col--) {
    /* Do the chroma part of the calculation */
    cb = GETJSAMPLE(*inptr1++);
    cr = GETJSAMPLE(*inptr2++);
    cred = Crrtab[cr];
    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
    cblue = Cbbtab[cb];

    /* Fetch 2 Y values and emit 2 pixels */
    y  = GETJSAMPLE(*inptr0++);
    r = range_limit[DITHER_565_R(y + cred, d0)];
    g = range_limit[DITHER_565_G(y + cgreen, d0)];
    b = range_limit[DITHER_565_B(y + cblue, d0)];
    d0 = DITHER_ROTATE(d0);
    rgb = PACK_SHORT_565(r, g, b);

    y  = GETJSAMPLE(*inptr0++);
    r = range_limit[DITHER_565_R(y + cred, d0)];
    g = range_limit[DITHER_565_G(y + cgreen, d0)];
    b = range_limit[DITHER_565_B(y + cblue, d0)];
    d0 = DITHER_ROTATE(d0);
    rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));

    WRITE_TWO_PIXELS(outptr, rgb);
    outptr += 4;
  }

  /* If image width is odd, do the last output column separately */
  if (cinfo->output_width & 1) {
    cb = GETJSAMPLE(*inptr1);
    cr = GETJSAMPLE(*inptr2);
    cred = Crrtab[cr];
    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
    cblue = Cbbtab[cb];
    y  = GETJSAMPLE(*inptr0);
    r = range_limit[DITHER_565_R(y + cred, d0)];
    g = range_limit[DITHER_565_G(y + cgreen, d0)];
    b = range_limit[DITHER_565_B(y + cblue, d0)];
    rgb = PACK_SHORT_565(r, g, b);
    *(INT16 *)outptr = (INT16)rgb;
  }
}","INLINE
LOCAL(void)
h2v1_merged_upsample_565D_internal(j_decompress_ptr VAR_0,
                                   JSAMPIMAGE VAR_1,
                                   JDIMENSION VAR_2,
                                   JSAMPARRAY VAR_3)
{
  my_merged_upsample_ptr VAR_4 = (my_merged_upsample_ptr)VAR_0->upsample;
  register int VAR_5, VAR_6, VAR_7, VAR_8;
  int VAR_9, VAR_10;
  register JSAMPROW VAR_11;
  JSAMPROW VAR_12, VAR_13, VAR_14;
  JDIMENSION VAR_15;
  /* COMMENT_0 */
  register JSAMPLE *VAR_16 = VAR_0->sample_range_limit;
  int *VAR_17 = VAR_4->Cr_r_tab;
  int *VAR_18 = VAR_4->Cb_b_tab;
  JLONG *VAR_19 = VAR_4->Cr_g_tab;
  JLONG *VAR_20 = VAR_4->Cb_g_tab;
  JLONG VAR_21 = VAR_22[VAR_0->output_scanline & VAR_23];
  unsigned int VAR_24, VAR_25, VAR_26;
  JLONG VAR_27;
  SHIFT_TEMPS

  VAR_12 = VAR_1[0][VAR_2];
  VAR_13 = VAR_1[1][VAR_2];
  VAR_14 = VAR_1[2][VAR_2];
  VAR_11 = VAR_3[0];

  /* COMMENT_1 */
  for (VAR_15 = VAR_0->output_width >> 1; VAR_15 > 0; VAR_15--) {
    /* COMMENT_2 */
    VAR_9 = GETJSAMPLE(*VAR_13++);
    VAR_10 = GETJSAMPLE(*VAR_14++);
    VAR_6 = VAR_17[VAR_10];
    VAR_7 = (int)RIGHT_SHIFT(VAR_20[VAR_9] + VAR_19[VAR_10], VAR_28);
    VAR_8 = VAR_18[VAR_9];

    /* COMMENT_3 */
    VAR_5  = GETJSAMPLE(*VAR_12++);
    VAR_24 = VAR_16[DITHER_565_R(VAR_5 + VAR_6, VAR_21)];
    VAR_25 = VAR_16[DITHER_565_G(VAR_5 + VAR_7, VAR_21)];
    VAR_26 = VAR_16[DITHER_565_B(VAR_5 + VAR_8, VAR_21)];
    VAR_21 = DITHER_ROTATE(VAR_21);
    VAR_27 = PACK_SHORT_565(VAR_24, VAR_25, VAR_26);

    VAR_5  = GETJSAMPLE(*VAR_12++);
    VAR_24 = VAR_16[DITHER_565_R(VAR_5 + VAR_6, VAR_21)];
    VAR_25 = VAR_16[DITHER_565_G(VAR_5 + VAR_7, VAR_21)];
    VAR_26 = VAR_16[DITHER_565_B(VAR_5 + VAR_8, VAR_21)];
    VAR_21 = DITHER_ROTATE(VAR_21);
    VAR_27 = PACK_TWO_PIXELS(VAR_27, PACK_SHORT_565(VAR_24, VAR_25, VAR_26));

    WRITE_TWO_PIXELS(VAR_11, VAR_27);
    VAR_11 += 4;
  }

  /* COMMENT_4 */
  if (VAR_0->output_width & 1) {
    VAR_9 = GETJSAMPLE(*VAR_13);
    VAR_10 = GETJSAMPLE(*VAR_14);
    VAR_6 = VAR_17[VAR_10];
    VAR_7 = (int)RIGHT_SHIFT(VAR_20[VAR_9] + VAR_19[VAR_10], VAR_28);
    VAR_8 = VAR_18[VAR_9];
    VAR_5  = GETJSAMPLE(*VAR_12);
    VAR_24 = VAR_16[DITHER_565_R(VAR_5 + VAR_6, VAR_21)];
    VAR_25 = VAR_16[DITHER_565_G(VAR_5 + VAR_7, VAR_21)];
    VAR_26 = VAR_16[DITHER_565_B(VAR_5 + VAR_8, VAR_21)];
    VAR_27 = PACK_SHORT_565(VAR_24, VAR_25, VAR_26);
    *(INT16 *)VAR_11 = (INT16)VAR_27;
  }
}",,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
                                    JDIMENSION in_row_group_ctr,
                                    JSAMPARRAY output_buf)
 {
-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
   register int y, cred, cgreen, cblue;
   int cb, cr;
   register JSAMPROW outptr;","{'deleted_lines': ['  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;'], 'added_lines': ['  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;']}",True,A crafted input file could cause a null pointer dereference in jcopy_sample_rows() when processed by libjpeg-turbo.,5.5,MEDIUM,1,valid,2020-07-24T02:24:38Z,3
CVE-2020-35538,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libjpeg-turbo,"Fix jpeg_skip_scanlines() segfault w/merged upsamp

The additional segfault mentioned in #244 was due to the fact that
the merged upsamplers use a different private structure than the
non-merged upsamplers.  jpeg_skip_scanlines() was assuming the latter, so
when merged upsampling was enabled, jpeg_skip_scanlines() clobbered one
of the IDCT method pointers in the merged upsampler's private structure.

For reasons unknown, the test image in #441 did not encounter this
segfault (too small?), but it encountered an issue similar to the one
fixed in 5bc43c7821df982f65aa1c738f67fbf7cba8bd69, whereby it was
necessary to set up a dummy postprocessing function in
read_and_discard_scanlines() when merged upsampling was enabled.
Failing to do so caused either a segfault in merged_2v_upsample() (due
to a NULL pointer being passed to jcopy_sample_rows()) or an error
(""Corrupt JPEG data: premature end of data segment""), depending on the
number of scanlines skipped and whether the first scanline skipped was
an odd- or even-numbered row.

Fixes #441
Fixes #244 (for real this time)",9120a247436e84c0b4eea828cb11e8f665fcde30,https://github.com/libjpeg-turbo/libjpeg-turbo/commit/9120a247436e84c0b4eea828cb11e8f665fcde30,jdmrg565.c,h2v1_merged_upsample_565_internal,"INLINE
LOCAL(void)
h2v1_merged_upsample_565_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
JDIMENSION in_row_group_ctr,
JSAMPARRAY output_buf)
{
my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
register int y, cred, cgreen, cblue;
int cb, cr;
register JSAMPROW outptr;
JSAMPROW inptr0, inptr1, inptr2;
JDIMENSION col;
register JSAMPLE *range_limit = cinfo->sample_range_limit;
int *Crrtab = upsample->Cr_r_tab;
int *Cbbtab = upsample->Cb_b_tab;
JLONG *Crgtab = upsample->Cr_g_tab;
JLONG *Cbgtab = upsample->Cb_g_tab;
unsigned int r, g, b;
JLONG rgb;
SHIFT_TEMPS
inptr0 = input_buf[0][in_row_group_ctr];
inptr1 = input_buf[1][in_row_group_ctr];
inptr2 = input_buf[2][in_row_group_ctr];
outptr = output_buf[0];
for (col = cinfo->output_width >> 1; col > 0; col--) {
cb = GETJSAMPLE(*inptr1++);
cr = GETJSAMPLE(*inptr2++);
cred = Crrtab[cr];
cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
cblue = Cbbtab[cb];
y  = GETJSAMPLE(*inptr0++);
r = range_limit[y + cred];
g = range_limit[y + cgreen];
b = range_limit[y + cblue];
rgb = PACK_SHORT_565(r, g, b);
y  = GETJSAMPLE(*inptr0++);
r = range_limit[y + cred];
g = range_limit[y + cgreen];
b = range_limit[y + cblue];
rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));
WRITE_TWO_PIXELS(outptr, rgb);
outptr += 4;
}
if (cinfo->output_width & 1) {
cb = GETJSAMPLE(*inptr1);
cr = GETJSAMPLE(*inptr2);
cred = Crrtab[cr];
cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
cblue = Cbbtab[cb];
y  = GETJSAMPLE(*inptr0);
r = range_limit[y + cred];
g = range_limit[y + cgreen];
b = range_limit[y + cblue];
rgb = PACK_SHORT_565(r, g, b);
*(INT16 *)outptr = (INT16)rgb;
}
}","INLINE
LOCAL(void)
h2v1_merged_upsample_565_internal(j_decompress_ptr VAR_0, JSAMPIMAGE VAR_1,
JDIMENSION VAR_2,
JSAMPARRAY VAR_3)
{
my_upsample_ptr VAR_4 = (my_upsample_ptr)VAR_0->upsample;
register int VAR_5, VAR_6, VAR_7, VAR_8;
int VAR_9, VAR_10;
register JSAMPROW VAR_11;
JSAMPROW VAR_12, VAR_13, VAR_14;
JDIMENSION VAR_15;
register JSAMPLE *VAR_16 = VAR_0->sample_range_limit;
int *VAR_17 = VAR_4->Cr_r_tab;
int *VAR_18 = VAR_4->Cb_b_tab;
JLONG *VAR_19 = VAR_4->Cr_g_tab;
JLONG *VAR_20 = VAR_4->Cb_g_tab;
unsigned int VAR_21, VAR_22, VAR_23;
JLONG VAR_24;
SHIFT_TEMPS
VAR_12 = VAR_1[0][VAR_2];
VAR_13 = VAR_1[1][VAR_2];
VAR_14 = VAR_1[2][VAR_2];
VAR_11 = VAR_3[0];
for (VAR_15 = VAR_0->output_width >> 1; VAR_15 > 0; VAR_15--) {
VAR_9 = GETJSAMPLE(*VAR_13++);
VAR_10 = GETJSAMPLE(*VAR_14++);
VAR_6 = VAR_17[VAR_10];
VAR_7 = (int)RIGHT_SHIFT(VAR_20[VAR_9] + VAR_19[VAR_10], VAR_25);
VAR_8 = VAR_18[VAR_9];
VAR_5  = GETJSAMPLE(*VAR_12++);
VAR_21 = VAR_16[VAR_5 + VAR_6];
VAR_22 = VAR_16[VAR_5 + VAR_7];
VAR_23 = VAR_16[VAR_5 + VAR_8];
VAR_24 = PACK_SHORT_565(VAR_21, VAR_22, VAR_23);
VAR_5  = GETJSAMPLE(*VAR_12++);
VAR_21 = VAR_16[VAR_5 + VAR_6];
VAR_22 = VAR_16[VAR_5 + VAR_7];
VAR_23 = VAR_16[VAR_5 + VAR_8];
VAR_24 = PACK_TWO_PIXELS(VAR_24, PACK_SHORT_565(VAR_21, VAR_22, VAR_23));
WRITE_TWO_PIXELS(VAR_11, VAR_24);
VAR_11 += 4;
}
if (VAR_0->output_width & 1) {
VAR_9 = GETJSAMPLE(*VAR_13);
VAR_10 = GETJSAMPLE(*VAR_14);
VAR_6 = VAR_17[VAR_10];
VAR_7 = (int)RIGHT_SHIFT(VAR_20[VAR_9] + VAR_19[VAR_10], VAR_25);
VAR_8 = VAR_18[VAR_9];
VAR_5  = GETJSAMPLE(*VAR_12);
VAR_21 = VAR_16[VAR_5 + VAR_6];
VAR_22 = VAR_16[VAR_5 + VAR_7];
VAR_23 = VAR_16[VAR_5 + VAR_8];
VAR_24 = PACK_SHORT_565(VAR_21, VAR_22, VAR_23);
*(INT16 *)VAR_11 = (INT16)VAR_24;
}
}",,"INLINE
LOCAL(void)
h2v1_merged_upsample_565_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
                                  JDIMENSION in_row_group_ctr,
                                  JSAMPARRAY output_buf)
{
  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
  register int y, cred, cgreen, cblue;
  int cb, cr;
  register JSAMPROW outptr;
  JSAMPROW inptr0, inptr1, inptr2;
  JDIMENSION col;
  /* copy these pointers into registers if possible */
  register JSAMPLE *range_limit = cinfo->sample_range_limit;
  int *Crrtab = upsample->Cr_r_tab;
  int *Cbbtab = upsample->Cb_b_tab;
  JLONG *Crgtab = upsample->Cr_g_tab;
  JLONG *Cbgtab = upsample->Cb_g_tab;
  unsigned int r, g, b;
  JLONG rgb;
  SHIFT_TEMPS

  inptr0 = input_buf[0][in_row_group_ctr];
  inptr1 = input_buf[1][in_row_group_ctr];
  inptr2 = input_buf[2][in_row_group_ctr];
  outptr = output_buf[0];

  /* Loop for each pair of output pixels */
  for (col = cinfo->output_width >> 1; col > 0; col--) {
    /* Do the chroma part of the calculation */
    cb = GETJSAMPLE(*inptr1++);
    cr = GETJSAMPLE(*inptr2++);
    cred = Crrtab[cr];
    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
    cblue = Cbbtab[cb];

    /* Fetch 2 Y values and emit 2 pixels */
    y  = GETJSAMPLE(*inptr0++);
    r = range_limit[y + cred];
    g = range_limit[y + cgreen];
    b = range_limit[y + cblue];
    rgb = PACK_SHORT_565(r, g, b);

    y  = GETJSAMPLE(*inptr0++);
    r = range_limit[y + cred];
    g = range_limit[y + cgreen];
    b = range_limit[y + cblue];
    rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b));

    WRITE_TWO_PIXELS(outptr, rgb);
    outptr += 4;
  }

  /* If image width is odd, do the last output column separately */
  if (cinfo->output_width & 1) {
    cb = GETJSAMPLE(*inptr1);
    cr = GETJSAMPLE(*inptr2);
    cred = Crrtab[cr];
    cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);
    cblue = Cbbtab[cb];
    y  = GETJSAMPLE(*inptr0);
    r = range_limit[y + cred];
    g = range_limit[y + cgreen];
    b = range_limit[y + cblue];
    rgb = PACK_SHORT_565(r, g, b);
    *(INT16 *)outptr = (INT16)rgb;
  }
}","INLINE
LOCAL(void)
h2v1_merged_upsample_565_internal(j_decompress_ptr VAR_0, JSAMPIMAGE VAR_1,
                                  JDIMENSION VAR_2,
                                  JSAMPARRAY VAR_3)
{
  my_merged_upsample_ptr VAR_4 = (my_merged_upsample_ptr)VAR_0->upsample;
  register int VAR_5, VAR_6, VAR_7, VAR_8;
  int VAR_9, VAR_10;
  register JSAMPROW VAR_11;
  JSAMPROW VAR_12, VAR_13, VAR_14;
  JDIMENSION VAR_15;
  /* COMMENT_0 */
  register JSAMPLE *VAR_16 = VAR_0->sample_range_limit;
  int *VAR_17 = VAR_4->Cr_r_tab;
  int *VAR_18 = VAR_4->Cb_b_tab;
  JLONG *VAR_19 = VAR_4->Cr_g_tab;
  JLONG *VAR_20 = VAR_4->Cb_g_tab;
  unsigned int VAR_21, VAR_22, VAR_23;
  JLONG VAR_24;
  SHIFT_TEMPS

  VAR_12 = VAR_1[0][VAR_2];
  VAR_13 = VAR_1[1][VAR_2];
  VAR_14 = VAR_1[2][VAR_2];
  VAR_11 = VAR_3[0];

  /* COMMENT_1 */
  for (VAR_15 = VAR_0->output_width >> 1; VAR_15 > 0; VAR_15--) {
    /* COMMENT_2 */
    VAR_9 = GETJSAMPLE(*VAR_13++);
    VAR_10 = GETJSAMPLE(*VAR_14++);
    VAR_6 = VAR_17[VAR_10];
    VAR_7 = (int)RIGHT_SHIFT(VAR_20[VAR_9] + VAR_19[VAR_10], VAR_25);
    VAR_8 = VAR_18[VAR_9];

    /* COMMENT_3 */
    VAR_5  = GETJSAMPLE(*VAR_12++);
    VAR_21 = VAR_16[VAR_5 + VAR_6];
    VAR_22 = VAR_16[VAR_5 + VAR_7];
    VAR_23 = VAR_16[VAR_5 + VAR_8];
    VAR_24 = PACK_SHORT_565(VAR_21, VAR_22, VAR_23);

    VAR_5  = GETJSAMPLE(*VAR_12++);
    VAR_21 = VAR_16[VAR_5 + VAR_6];
    VAR_22 = VAR_16[VAR_5 + VAR_7];
    VAR_23 = VAR_16[VAR_5 + VAR_8];
    VAR_24 = PACK_TWO_PIXELS(VAR_24, PACK_SHORT_565(VAR_21, VAR_22, VAR_23));

    WRITE_TWO_PIXELS(VAR_11, VAR_24);
    VAR_11 += 4;
  }

  /* COMMENT_4 */
  if (VAR_0->output_width & 1) {
    VAR_9 = GETJSAMPLE(*VAR_13);
    VAR_10 = GETJSAMPLE(*VAR_14);
    VAR_6 = VAR_17[VAR_10];
    VAR_7 = (int)RIGHT_SHIFT(VAR_20[VAR_9] + VAR_19[VAR_10], VAR_25);
    VAR_8 = VAR_18[VAR_9];
    VAR_5  = GETJSAMPLE(*VAR_12);
    VAR_21 = VAR_16[VAR_5 + VAR_6];
    VAR_22 = VAR_16[VAR_5 + VAR_7];
    VAR_23 = VAR_16[VAR_5 + VAR_8];
    VAR_24 = PACK_SHORT_565(VAR_21, VAR_22, VAR_23);
    *(INT16 *)VAR_11 = (INT16)VAR_24;
  }
}",,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
                                   JDIMENSION in_row_group_ctr,
                                   JSAMPARRAY output_buf)
 {
-  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;
+  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;
   register int y, cred, cgreen, cblue;
   int cb, cr;
   register JSAMPROW outptr;","{'deleted_lines': ['  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;'], 'added_lines': ['  my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;']}",True,A crafted input file could cause a null pointer dereference in jcopy_sample_rows() when processed by libjpeg-turbo.,5.5,MEDIUM,1,valid,2020-07-24T02:24:38Z,3
CVE-2021-26199,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,jerryscript-project/jerryscript,"Fix a use-after-free in RegExp.prototype.compile

Fixes #4056.

JerryScript-DCO-1.0-Signed-off-by: Dniel Btyai daniel.batyai@h-lab.eu",bf2c9e1f06f00d32c945d8e96c8b7c3b67f63455,https://github.com/jerryscript-project/jerryscript/commit/bf2c9e1f06f00d32c945d8e96c8b7c3b67f63455,jerry-core/ecma/builtin-objects/ecma-builtin-regexp-prototype.c,ecma_builtin_regexp_prototype_compile,"static ecma_value_t
ecma_builtin_regexp_prototype_compile (ecma_value_t this_arg, 
ecma_value_t pattern_arg, 
ecma_value_t flags_arg) 
{
#if !ENABLED (JERRY_ESNEXT)
if (ecma_get_object_from_value (this_arg) == ecma_builtin_get (ECMA_BUILTIN_ID_REGEXP_PROTOTYPE))
{
return ecma_raise_type_error (ECMA_ERR_MSG (""'this' is not a RegExp object""));
}
#endif 
ecma_object_t *this_obj_p = ecma_get_object_from_value (this_arg);
ecma_extended_object_t *re_obj_p = (ecma_extended_object_t *) this_obj_p;
re_compiled_code_t *old_bc_p = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t,
re_obj_p->u.class_prop.u.value);
ecma_value_t status = ecma_builtin_helper_def_prop (this_obj_p,
ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
ecma_make_uint32_value (0),
ECMA_PROPERTY_FLAG_WRITABLE | ECMA_PROP_IS_THROW);
if (ECMA_IS_VALUE_ERROR (status))
{
return status;
}
JERRY_ASSERT (ecma_is_value_true (status));
if (ecma_object_is_regexp_object (pattern_arg))
{
if (!ecma_is_value_undefined (flags_arg))
{
return ecma_raise_type_error (ECMA_ERR_MSG (""Invalid argument""));
}
ecma_extended_object_t *pattern_obj_p = (ecma_extended_object_t *) ecma_get_object_from_value (pattern_arg);
re_compiled_code_t *bc_p = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t,
pattern_obj_p->u.class_prop.u.value);
ecma_ref_object (this_obj_p);
ecma_bytecode_deref ((ecma_compiled_code_t *) old_bc_p);
return ecma_op_create_regexp_from_bytecode (this_obj_p, bc_p);
}
ecma_value_t ret_value = ecma_op_create_regexp_from_pattern (this_obj_p, pattern_arg, flags_arg);
if (!ECMA_IS_VALUE_ERROR (ret_value))
{
ecma_ref_object (this_obj_p);
ecma_bytecode_deref ((ecma_compiled_code_t *) old_bc_p);
}
return ret_value;
}","static ecma_value_t
ecma_builtin_regexp_prototype_compile (ecma_value_t VAR_0, 
ecma_value_t VAR_1, 
ecma_value_t VAR_2) 
{
#if !ENABLED (VAR_3)
if (ecma_get_object_from_value (VAR_0) == ecma_builtin_get (VAR_4))
{
return ecma_raise_type_error (ECMA_ERR_MSG (""'this' is not a RegExp object""));
}
#endif 
ecma_object_t *VAR_5 = ecma_get_object_from_value (VAR_0);
ecma_extended_object_t *VAR_6 = (ecma_extended_object_t *) VAR_5;
re_compiled_code_t *VAR_7 = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t,
VAR_6->u.class_prop.u.value);
ecma_value_t VAR_8 = ecma_builtin_helper_def_prop (VAR_5,
ecma_get_magic_string (VAR_9),
ecma_make_uint32_value (0),
VAR_10 | VAR_11);
if (ECMA_IS_VALUE_ERROR (VAR_8))
{
return VAR_8;
}
JERRY_ASSERT (ecma_is_value_true (VAR_8));
if (ecma_object_is_regexp_object (VAR_1))
{
if (!ecma_is_value_undefined (VAR_2))
{
return ecma_raise_type_error (ECMA_ERR_MSG (""Invalid argument""));
}
ecma_extended_object_t *VAR_12 = (ecma_extended_object_t *) ecma_get_object_from_value (VAR_1);
re_compiled_code_t *VAR_13 = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t,
VAR_12->u.class_prop.u.value);
ecma_ref_object (VAR_5);
ecma_bytecode_deref ((ecma_compiled_code_t *) VAR_7);
return ecma_op_create_regexp_from_bytecode (VAR_5, VAR_13);
}
ecma_value_t VAR_14 = ecma_op_create_regexp_from_pattern (VAR_5, VAR_1, VAR_2);
if (!ECMA_IS_VALUE_ERROR (VAR_14))
{
ecma_ref_object (VAR_5);
ecma_bytecode_deref ((ecma_compiled_code_t *) VAR_7);
}
return VAR_14;
}",jerryscript-project/jerryscript/bf2c9e1f06f00d32c945d8e96c8b7c3b67f63455/ecma-builtin-regexp-prototype.c/vul/before/0.json,"static ecma_value_t
ecma_builtin_regexp_prototype_compile (ecma_value_t this_arg, /**< this */
                                       ecma_value_t pattern_arg, /**< pattern or RegExp object */
                                       ecma_value_t flags_arg) /**< flags */
{
#if !ENABLED (JERRY_ESNEXT)
  if (ecma_get_object_from_value (this_arg) == ecma_builtin_get (ECMA_BUILTIN_ID_REGEXP_PROTOTYPE))
  {
    return ecma_raise_type_error (ECMA_ERR_MSG (""'this' is not a RegExp object""));
  }
#endif /* !ENABLED (JERRY_ESNEXT) */

  ecma_object_t *this_obj_p = ecma_get_object_from_value (this_arg);
  ecma_extended_object_t *re_obj_p = (ecma_extended_object_t *) this_obj_p;
  re_compiled_code_t *old_bc_p = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t,
                                                                  re_obj_p->u.class_prop.u.value);

  ecma_value_t status = ecma_builtin_helper_def_prop (this_obj_p,
                                                      ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
                                                      ecma_make_uint32_value (0),
                                                      ECMA_PROPERTY_FLAG_WRITABLE | ECMA_PROP_IS_THROW);

  if (ECMA_IS_VALUE_ERROR (status))
  {
    return status;
  }

  JERRY_ASSERT (ecma_is_value_true (status));
  ecma_value_t ret_value;

  if (ecma_object_is_regexp_object (pattern_arg))
  {
    if (!ecma_is_value_undefined (flags_arg))
    {
      return ecma_raise_type_error (ECMA_ERR_MSG (""Invalid argument""));
    }

    ecma_extended_object_t *pattern_obj_p = (ecma_extended_object_t *) ecma_get_object_from_value (pattern_arg);
    re_compiled_code_t *bc_p = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t,
                                                                pattern_obj_p->u.class_prop.u.value);

    ecma_ref_object (this_obj_p);
    ret_value = ecma_op_create_regexp_from_bytecode (this_obj_p, bc_p);

    ecma_bytecode_deref ((ecma_compiled_code_t *) old_bc_p);
    return ret_value;
  }

  ret_value = ecma_op_create_regexp_from_pattern (this_obj_p, pattern_arg, flags_arg);

  if (!ECMA_IS_VALUE_ERROR (ret_value))
  {
    ecma_ref_object (this_obj_p);
    ecma_bytecode_deref ((ecma_compiled_code_t *) old_bc_p);
  }

  return ret_value;
}","static ecma_value_t
ecma_builtin_regexp_prototype_compile (ecma_value_t VAR_0, /* COMMENT_0 */
                                       ecma_value_t VAR_1, /* COMMENT_1 */
                                       ecma_value_t VAR_2) /* COMMENT_2 */
{
#if !ENABLED (VAR_3)
  if (ecma_get_object_from_value (VAR_0) == ecma_builtin_get (VAR_4))
  {
    return ecma_raise_type_error (ECMA_ERR_MSG (""'this' is not a RegExp object""));
  }
#endif /* COMMENT_3 */

  ecma_object_t *VAR_5 = ecma_get_object_from_value (VAR_0);
  ecma_extended_object_t *VAR_6 = (ecma_extended_object_t *) VAR_5;
  re_compiled_code_t *VAR_7 = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t,
                                                                  VAR_6->u.class_prop.u.value);

  ecma_value_t VAR_8 = ecma_builtin_helper_def_prop (VAR_5,
                                                      ecma_get_magic_string (VAR_9),
                                                      ecma_make_uint32_value (0),
                                                      VAR_10 | VAR_11);

  if (ECMA_IS_VALUE_ERROR (VAR_8))
  {
    return VAR_8;
  }

  JERRY_ASSERT (ecma_is_value_true (VAR_8));
  ecma_value_t VAR_12;

  if (ecma_object_is_regexp_object (VAR_1))
  {
    if (!ecma_is_value_undefined (VAR_2))
    {
      return ecma_raise_type_error (ECMA_ERR_MSG (""Invalid argument""));
    }

    ecma_extended_object_t *VAR_13 = (ecma_extended_object_t *) ecma_get_object_from_value (VAR_1);
    re_compiled_code_t *VAR_14 = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t,
                                                                VAR_13->u.class_prop.u.value);

    ecma_ref_object (VAR_5);
    VAR_12 = ecma_op_create_regexp_from_bytecode (VAR_5, VAR_14);

    ecma_bytecode_deref ((ecma_compiled_code_t *) VAR_7);
    return VAR_12;
  }

  VAR_12 = ecma_op_create_regexp_from_pattern (VAR_5, VAR_1, VAR_2);

  if (!ECMA_IS_VALUE_ERROR (VAR_12))
  {
    ecma_ref_object (VAR_5);
    ecma_bytecode_deref ((ecma_compiled_code_t *) VAR_7);
  }

  return VAR_12;
}",jerryscript-project/jerryscript/bf2c9e1f06f00d32c945d8e96c8b7c3b67f63455/ecma-builtin-regexp-prototype.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -26,6 +26,7 @@
   }
 
   JERRY_ASSERT (ecma_is_value_true (status));
+  ecma_value_t ret_value;
 
   if (ecma_object_is_regexp_object (pattern_arg))
   {
@@ -39,13 +40,13 @@
                                                                 pattern_obj_p->u.class_prop.u.value);
 
     ecma_ref_object (this_obj_p);
-    /* ecma_op_create_regexp_from_bytecode will never throw an error while re-initalizing the regexp object, so we
-     * can deref the old bytecode without leaving a dangling pointer. */
+    ret_value = ecma_op_create_regexp_from_bytecode (this_obj_p, bc_p);
+
     ecma_bytecode_deref ((ecma_compiled_code_t *) old_bc_p);
-    return ecma_op_create_regexp_from_bytecode (this_obj_p, bc_p);
+    return ret_value;
   }
 
-  ecma_value_t ret_value = ecma_op_create_regexp_from_pattern (this_obj_p, pattern_arg, flags_arg);
+  ret_value = ecma_op_create_regexp_from_pattern (this_obj_p, pattern_arg, flags_arg);
 
   if (!ECMA_IS_VALUE_ERROR (ret_value))
   {","{'deleted_lines': ['    /* ecma_op_create_regexp_from_bytecode will never throw an error while re-initalizing the regexp object, so we', '     * can deref the old bytecode without leaving a dangling pointer. */', '    return ecma_op_create_regexp_from_bytecode (this_obj_p, bc_p);', '  ecma_value_t ret_value = ecma_op_create_regexp_from_pattern (this_obj_p, pattern_arg, flags_arg);'], 'added_lines': ['  ecma_value_t ret_value;', '    ret_value = ecma_op_create_regexp_from_bytecode (this_obj_p, bc_p);', '', '    return ret_value;', '  ret_value = ecma_op_create_regexp_from_pattern (this_obj_p, pattern_arg, flags_arg);']}",True,An issue was discovered in JerryScript 2.4.0. There is a heap-use-after-free in ecma_bytecode_ref in ecma-helpers.c file.,6.5,MEDIUM,1,valid,2020-07-27T13:09:09Z,3
CVE-2020-23914,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,yhirose/cpp-peglib,Fix #121,0061f393de54cf0326621c079dc2988336d1ebb3,https://github.com/yhirose/cpp-peglib/commit/0061f393de54cf0326621c079dc2988336d1ebb3,peglib.h,LiteralString,"LiteralString(const std::string &s, bool ignore_case)
: lit_(s), ignore_case_(ignore_case),
is_word_(false) {}","LiteralString(const std::string &VAR_0, bool VAR_1)
: lit_(VAR_0), ignore_case_(VAR_1),
is_word_(false) {}",,"LiteralString(const std::string &s, bool ignore_case)
      : lit_(s), ignore_case_(ignore_case), is_word_(false) {}","LiteralString(const std::string &VAR_0, bool VAR_1)
      : lit_(VAR_0), ignore_case_(VAR_1), is_word_(false) {}",,"--- func_before
+++ func_after
@@ -1,3 +1,2 @@
 LiteralString(const std::string &s, bool ignore_case)
-      : lit_(s), ignore_case_(ignore_case),
-        is_word_(false) {}
+      : lit_(s), ignore_case_(ignore_case), is_word_(false) {}","{'deleted_lines': ['      : lit_(s), ignore_case_(ignore_case),', '        is_word_(false) {}'], 'added_lines': ['      : lit_(s), ignore_case_(ignore_case), is_word_(false) {}']}",True,An issue was discovered in cpp-peglib through v0.1.12. A NULL pointer dereference exists in the peg::AstOptimizer::optimize() located in peglib.h. It allows an attacker to cause Denial of Service.,5.5,MEDIUM,1,valid,2020-08-07T14:21:47Z,3
CVE-2020-23914,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,yhirose/cpp-peglib,Fix #121,0061f393de54cf0326621c079dc2988336d1ebb3,https://github.com/yhirose/cpp-peglib/commit/0061f393de54cf0326621c079dc2988336d1ebb3,peglib.h,perform_core,"std::shared_ptr<Grammar> perform_core(const char *s, size_t n,
const Rules &rules, std::string &start,
Log log) {
Data data;
any dt = &data;
auto r = g[""Grammar""].parse(s, n, dt);
if (!r.ret) {
if (log) {
if (r.message_pos) {
auto line = line_info(s, r.message_pos);
log(line.first, line.second, r.message);
} else {
auto line = line_info(s, r.error_pos);
log(line.first, line.second, ""syntax error"");
}
}
return nullptr;
}
auto &grammar = *data.grammar;
for (const auto &x : rules) {
auto name = x.first;
bool ignore = false;
if (!name.empty() && name[0] == '~') {
ignore = true;
name.erase(0, 1);
}
if (!name.empty()) {
auto &rule = grammar[name];
rule <= x.second;
rule.name = name;
rule.ignoreSemanticValue = ignore;
}
}
bool ret = data.duplicates.empty();
for (const auto &x : data.duplicates) {
if (log) {
const auto &name = x.first;
auto ptr = x.second;
auto line = line_info(s, ptr);
log(line.first, line.second, ""'"" + name + ""' is already defined."");
}
}
for (auto &x : grammar) {
auto &rule = x.second;
ReferenceChecker vis(*data.grammar, rule.params);
rule.accept(vis);
for (const auto &y : vis.error_s) {
const auto &name = y.first;
const auto ptr = y.second;
if (log) {
auto line = line_info(s, ptr);
log(line.first, line.second, vis.error_message[name]);
}
ret = false;
}
}
if (!ret) { return nullptr; }
for (auto &x : grammar) {
auto &rule = x.second;
LinkReferences vis(*data.grammar, rule.params);
rule.accept(vis);
}
ret = true;
for (auto &x : grammar) {
const auto &name = x.first;
auto &rule = x.second;
DetectLeftRecursion vis(name);
rule.accept(vis);
if (vis.error_s) {
if (log) {
auto line = line_info(s, vis.error_s);
log(line.first, line.second, ""'"" + name + ""' is left recursive."");
}
ret = false;
}
}
if (!ret) { return nullptr; }
auto &start_rule = (*data.grammar)[data.start];
{
DetectInfiniteLoop vis(data.start_pos, data.start);
start_rule.accept(vis);
if (vis.has_error) {
if (log) {
auto line = line_info(s, vis.error_s);
log(line.first, line.second,
""infinite loop is detected in '"" + vis.error_name + ""'."");
}
return nullptr;
}
}
if (grammar.count(WHITESPACE_DEFINITION_NAME)) {
for (auto &x : grammar) {
auto &rule = x.second;
auto ope = rule.get_core_operator();
if (IsLiteralToken::check(*ope)) { rule <= tok(ope); }
}
start_rule.whitespaceOpe =
wsp((*data.grammar)[WHITESPACE_DEFINITION_NAME].get_core_operator());
}
if (grammar.count(WORD_DEFINITION_NAME)) {
start_rule.wordOpe =
(*data.grammar)[WORD_DEFINITION_NAME].get_core_operator();
}
for (const auto &item : data.instructions) {
const auto &name = item.first;
const auto &instruction = item.second;
auto &rule = grammar[name];
if (instruction.type == ""precedence"") {
const auto &info =
any_cast<PrecedenceClimbing::BinOpeInfo>(instruction.data);
if (!apply_precedence_instruction(rule, info, s, log)) {
return nullptr;
}
}
}
start = data.start;
return data.grammar;
}","std::shared_ptr<Grammar> perform_core(const char *VAR_0, size_t VAR_1,
const Rules &VAR_2, std::string &VAR_3,
Log VAR_4) {
Data VAR_5;
any VAR_6 = &VAR_5;
auto VAR_7 = VAR_8[""Grammar""].parse(VAR_0, VAR_1, VAR_6);
if (!VAR_7.ret) {
if (VAR_4) {
if (VAR_7.message_pos) {
auto VAR_9 = line_info(VAR_0, VAR_7.message_pos);
VAR_4(VAR_9.first, VAR_9.second, VAR_7.message);
} else {
auto VAR_9 = line_info(VAR_0, VAR_7.error_pos);
VAR_4(VAR_9.first, VAR_9.second, ""syntax error"");
}
}
return nullptr;
}
auto &VAR_10 = *VAR_5.grammar;
for (const auto &VAR_11 : VAR_2) {
auto VAR_12 = VAR_11.first;
bool VAR_13 = false;
if (!VAR_12.empty() && VAR_12[0] == '~') {
VAR_13 = true;
VAR_12.erase(0, 1);
}
if (!VAR_12.empty()) {
auto &VAR_14 = VAR_10[VAR_12];
VAR_14 <= VAR_11.second;
VAR_14.name = VAR_12;
VAR_14.ignoreSemanticValue = VAR_13;
}
}
bool VAR_15 = VAR_5.duplicates.empty();
for (const auto &VAR_11 : VAR_5.duplicates) {
if (VAR_4) {
const auto &VAR_12 = VAR_11.first;
auto VAR_16 = VAR_11.second;
auto VAR_9 = line_info(VAR_0, VAR_16);
VAR_4(VAR_9.first, VAR_9.second, ""'"" + VAR_12 + ""' is already defined."");
}
}
for (auto &VAR_11 : VAR_10) {
auto &VAR_14 = VAR_11.second;
ReferenceChecker VAR_17(*VAR_5.grammar, VAR_14.params);
VAR_14.accept(VAR_17);
for (const auto &VAR_18 : VAR_17.error_s) {
const auto &VAR_12 = VAR_18.first;
const auto VAR_16 = VAR_18.second;
if (VAR_4) {
auto VAR_9 = line_info(VAR_0, VAR_16);
VAR_4(VAR_9.first, VAR_9.second, VAR_17.error_message[VAR_12]);
}
VAR_15 = false;
}
}
if (!VAR_15) { return nullptr; }
for (auto &VAR_11 : VAR_10) {
auto &VAR_14 = VAR_11.second;
LinkReferences VAR_17(*VAR_5.grammar, VAR_14.params);
VAR_14.accept(VAR_17);
}
VAR_15 = true;
for (auto &VAR_11 : VAR_10) {
const auto &VAR_12 = VAR_11.first;
auto &VAR_14 = VAR_11.second;
DetectLeftRecursion vis(name);
VAR_14.accept(VAR_17);
if (VAR_17.error_s) {
if (VAR_4) {
auto VAR_9 = line_info(VAR_0, VAR_17.error_s);
VAR_4(VAR_9.first, VAR_9.second, ""'"" + name + ""' is left recursive."");
}
VAR_15 = false;
}
}
if (!VAR_15) { return nullptr; }
auto &VAR_19 = (*VAR_5.grammar)[VAR_5.start];
{
DetectInfiniteLoop VAR_17(VAR_5.start_pos, VAR_5.start);
VAR_19.accept(VAR_17);
if (VAR_17.has_error) {
if (VAR_4) {
auto VAR_9 = line_info(VAR_0, VAR_17.error_s);
VAR_4(VAR_9.first, VAR_9.second,
""infinite loop is detected in '"" + VAR_17.error_name + ""'."");
}
return nullptr;
}
}
if (VAR_10.count(VAR_20)) {
for (auto &VAR_11 : VAR_10) {
auto &VAR_14 = VAR_11.second;
auto VAR_21 = VAR_14.get_core_operator();
if (IsLiteralToken::check(*VAR_21)) { VAR_14 <= tok(VAR_21); }
}
VAR_19.whitespaceOpe =
wsp((*VAR_5.grammar)[VAR_20].get_core_operator());
}
if (VAR_10.count(VAR_22)) {
VAR_19.wordOpe =
(*VAR_5.grammar)[VAR_22].get_core_operator();
}
for (const auto &VAR_23 : VAR_5.instructions) {
const auto &name = VAR_23.first;
const auto &VAR_24 = VAR_23.second;
auto &VAR_14 = VAR_10[name];
if (VAR_24.type == ""precedence"") {
const auto &VAR_25 =
VAR_26<PrecedenceClimbing::BinOpeInfo>(VAR_24.data);
if (!apply_precedence_instruction(VAR_14, VAR_25, VAR_0, VAR_4)) {
return nullptr;
}
}
}
VAR_3 = VAR_5.start;
return VAR_5.grammar;
}",yhirose/cpp-peglib/0061f393de54cf0326621c079dc2988336d1ebb3/peglib.h/vul/before/1.json,"std::shared_ptr<Grammar> perform_core(const char *s, size_t n,
                                        const Rules &rules, std::string &start,
                                        Log log) {
    Data data;
    any dt = &data;
    auto r = g[""Grammar""].parse(s, n, dt);

    if (!r.ret) {
      if (log) {
        if (r.message_pos) {
          auto line = line_info(s, r.message_pos);
          log(line.first, line.second, r.message);
        } else {
          auto line = line_info(s, r.error_pos);
          log(line.first, line.second, ""syntax error"");
        }
      }
      return nullptr;
    }

    auto &grammar = *data.grammar;

    // User provided rules
    for (const auto &x : rules) {
      auto name = x.first;
      bool ignore = false;
      if (!name.empty() && name[0] == '~') {
        ignore = true;
        name.erase(0, 1);
      }
      if (!name.empty()) {
        auto &rule = grammar[name];
        rule <= x.second;
        rule.name = name;
        rule.ignoreSemanticValue = ignore;
      }
    }

    // Check duplicated definitions
    bool ret = data.duplicates.empty();

    for (const auto &x : data.duplicates) {
      if (log) {
        const auto &name = x.first;
        auto ptr = x.second;
        auto line = line_info(s, ptr);
        log(line.first, line.second, ""'"" + name + ""' is already defined."");
      }
    }

    // Check if the start rule has ignore operator
    {
      auto &rule = grammar[data.start];
      if (rule.ignoreSemanticValue) {
        if (log) {
          auto line = line_info(s, rule.s_);
          log(line.first, line.second,
              ""Ignore operator cannot be applied to '"" + rule.name + ""'."");
        }
        ret = false;
      }
    }

    if (!ret) { return nullptr; }

    // Check missing definitions
    for (auto &x : grammar) {
      auto &rule = x.second;

      ReferenceChecker vis(*data.grammar, rule.params);
      rule.accept(vis);
      for (const auto &y : vis.error_s) {
        const auto &name = y.first;
        const auto ptr = y.second;
        if (log) {
          auto line = line_info(s, ptr);
          log(line.first, line.second, vis.error_message[name]);
        }
        ret = false;
      }
    }

    if (!ret) { return nullptr; }

    // Link references
    for (auto &x : grammar) {
      auto &rule = x.second;
      LinkReferences vis(*data.grammar, rule.params);
      rule.accept(vis);
    }

    // Check left recursion
    ret = true;

    for (auto &x : grammar) {
      const auto &name = x.first;
      auto &rule = x.second;

      DetectLeftRecursion vis(name);
      rule.accept(vis);
      if (vis.error_s) {
        if (log) {
          auto line = line_info(s, vis.error_s);
          log(line.first, line.second, ""'"" + name + ""' is left recursive."");
        }
        ret = false;
      }
    }

    if (!ret) { return nullptr; }

    // Set root definition
    auto &start_rule = (*data.grammar)[data.start];

    // Check infinite loop
    {
      DetectInfiniteLoop vis(data.start_pos, data.start);
      start_rule.accept(vis);
      if (vis.has_error) {
        if (log) {
          auto line = line_info(s, vis.error_s);
          log(line.first, line.second,
              ""infinite loop is detected in '"" + vis.error_name + ""'."");
        }
        return nullptr;
      }
    }

    // Automatic whitespace skipping
    if (grammar.count(WHITESPACE_DEFINITION_NAME)) {
      for (auto &x : grammar) {
        auto &rule = x.second;
        auto ope = rule.get_core_operator();
        if (IsLiteralToken::check(*ope)) { rule <= tok(ope); }
      }

      start_rule.whitespaceOpe =
          wsp((*data.grammar)[WHITESPACE_DEFINITION_NAME].get_core_operator());
    }

    // Word expression
    if (grammar.count(WORD_DEFINITION_NAME)) {
      start_rule.wordOpe =
          (*data.grammar)[WORD_DEFINITION_NAME].get_core_operator();
    }

    // Apply instructions
    for (const auto &item : data.instructions) {
      const auto &name = item.first;
      const auto &instruction = item.second;
      auto &rule = grammar[name];

      if (instruction.type == ""precedence"") {
        const auto &info =
            any_cast<PrecedenceClimbing::BinOpeInfo>(instruction.data);

        if (!apply_precedence_instruction(rule, info, s, log)) {
          return nullptr;
        }
      }
    }

    // Set root definition
    start = data.start;

    return data.grammar;
  }","std::shared_ptr<Grammar> perform_core(const char *VAR_0, size_t VAR_1,
                                        const Rules &VAR_2, std::string &VAR_3,
                                        Log VAR_4) {
    Data VAR_5;
    any VAR_6 = &VAR_5;
    auto VAR_7 = VAR_8[""Grammar""].parse(VAR_0, VAR_1, VAR_6);

    if (!VAR_7.ret) {
      if (VAR_4) {
        if (VAR_7.message_pos) {
          auto VAR_9 = line_info(VAR_0, VAR_7.message_pos);
          VAR_4(VAR_9.first, VAR_9.second, VAR_7.message);
        } else {
          auto VAR_9 = line_info(VAR_0, VAR_7.error_pos);
          VAR_4(VAR_9.first, VAR_9.second, ""syntax error"");
        }
      }
      return nullptr;
    }

    auto &VAR_10 = *VAR_5.grammar;

    /* COMMENT_0 */
    for (const auto &VAR_11 : VAR_2) {
      auto VAR_12 = VAR_11.first;
      bool VAR_13 = false;
      if (!VAR_12.empty() && VAR_12[0] == '~') {
        VAR_13 = true;
        VAR_12.erase(0, 1);
      }
      if (!VAR_12.empty()) {
        auto &VAR_14 = VAR_10[VAR_12];
        VAR_14 <= VAR_11.second;
        VAR_14.name = VAR_12;
        VAR_14.ignoreSemanticValue = VAR_13;
      }
    }

    /* COMMENT_1 */
    bool VAR_15 = VAR_5.duplicates.empty();

    for (const auto &VAR_11 : VAR_5.duplicates) {
      if (VAR_4) {
        const auto &VAR_12 = VAR_11.first;
        auto VAR_16 = VAR_11.second;
        auto VAR_9 = line_info(VAR_0, VAR_16);
        VAR_4(VAR_9.first, VAR_9.second, ""'"" + VAR_12 + ""' is already defined."");
      }
    }

    /* COMMENT_2 */
    {
      auto &VAR_14 = VAR_10[VAR_5.start];
      if (VAR_14.ignoreSemanticValue) {
        if (VAR_4) {
          auto VAR_9 = line_info(VAR_0, VAR_14.s_);
          VAR_4(VAR_9.first, VAR_9.second,
              ""Ignore operator cannot be applied to '"" + VAR_14.name + ""'."");
        }
        VAR_15 = false;
      }
    }

    if (!VAR_15) { return nullptr; }

    /* COMMENT_3 */
    for (auto &VAR_11 : VAR_10) {
      auto &VAR_14 = VAR_11.second;

      ReferenceChecker VAR_17(*VAR_5.grammar, VAR_14.params);
      VAR_14.accept(VAR_17);
      for (const auto &VAR_18 : VAR_17.error_s) {
        const auto &VAR_12 = VAR_18.first;
        const auto VAR_16 = VAR_18.second;
        if (VAR_4) {
          auto VAR_9 = line_info(VAR_0, VAR_16);
          VAR_4(VAR_9.first, VAR_9.second, VAR_17.error_message[VAR_12]);
        }
        VAR_15 = false;
      }
    }

    if (!VAR_15) { return nullptr; }

    /* COMMENT_4 */
    for (auto &VAR_11 : VAR_10) {
      auto &VAR_14 = VAR_11.second;
      LinkReferences VAR_17(*VAR_5.grammar, VAR_14.params);
      VAR_14.accept(VAR_17);
    }

    /* COMMENT_5 */
    VAR_15 = true;

    for (auto &VAR_11 : VAR_10) {
      const auto &VAR_12 = VAR_11.first;
      auto &VAR_14 = VAR_11.second;

      DetectLeftRecursion vis(name);
      VAR_14.accept(VAR_17);
      if (VAR_17.error_s) {
        if (VAR_4) {
          auto VAR_9 = line_info(VAR_0, VAR_17.error_s);
          VAR_4(VAR_9.first, VAR_9.second, ""'"" + name + ""' is left recursive."");
        }
        VAR_15 = false;
      }
    }

    if (!VAR_15) { return nullptr; }

    /* COMMENT_6 */
    auto &VAR_19 = (*VAR_5.grammar)[VAR_5.start];

    /* COMMENT_7 */
    {
      DetectInfiniteLoop VAR_17(VAR_5.start_pos, VAR_5.start);
      VAR_19.accept(VAR_17);
      if (VAR_17.has_error) {
        if (VAR_4) {
          auto VAR_9 = line_info(VAR_0, VAR_17.error_s);
          VAR_4(VAR_9.first, VAR_9.second,
              ""infinite loop is detected in '"" + VAR_17.error_name + ""'."");
        }
        return nullptr;
      }
    }

    /* COMMENT_8 */
    if (VAR_10.count(VAR_20)) {
      for (auto &VAR_11 : VAR_10) {
        auto &VAR_14 = VAR_11.second;
        auto VAR_21 = VAR_14.get_core_operator();
        if (IsLiteralToken::check(*VAR_21)) { VAR_14 <= tok(VAR_21); }
      }

      VAR_19.whitespaceOpe =
          wsp((*VAR_5.grammar)[VAR_20].get_core_operator());
    }

    /* COMMENT_9 */
    if (VAR_10.count(VAR_22)) {
      VAR_19.wordOpe =
          (*VAR_5.grammar)[VAR_22].get_core_operator();
    }

    /* COMMENT_10 */
    for (const auto &VAR_23 : VAR_5.instructions) {
      const auto &name = VAR_23.first;
      const auto &VAR_24 = VAR_23.second;
      auto &VAR_14 = VAR_10[name];

      if (VAR_24.type == ""precedence"") {
        const auto &VAR_25 =
            VAR_26<PrecedenceClimbing::BinOpeInfo>(VAR_24.data);

        if (!apply_precedence_instruction(VAR_14, VAR_25, VAR_0, VAR_4)) {
          return nullptr;
        }
      }
    }

    /* COMMENT_6 */
    VAR_3 = VAR_5.start;

    return VAR_5.grammar;
  }",yhirose/cpp-peglib/0061f393de54cf0326621c079dc2988336d1ebb3/peglib.h/vul/after/1.json,"--- func_before
+++ func_after
@@ -47,6 +47,21 @@
         log(line.first, line.second, ""'"" + name + ""' is already defined."");
       }
     }
+
+    // Check if the start rule has ignore operator
+    {
+      auto &rule = grammar[data.start];
+      if (rule.ignoreSemanticValue) {
+        if (log) {
+          auto line = line_info(s, rule.s_);
+          log(line.first, line.second,
+              ""Ignore operator cannot be applied to '"" + rule.name + ""'."");
+        }
+        ret = false;
+      }
+    }
+
+    if (!ret) { return nullptr; }
 
     // Check missing definitions
     for (auto &x : grammar) {","{'deleted_lines': [], 'added_lines': ['', '    // Check if the start rule has ignore operator', '    {', '      auto &rule = grammar[data.start];', '      if (rule.ignoreSemanticValue) {', '        if (log) {', '          auto line = line_info(s, rule.s_);', '          log(line.first, line.second,', '              ""Ignore operator cannot be applied to \'"" + rule.name + ""\'."");', '        }', '        ret = false;', '      }', '    }', '', '    if (!ret) { return nullptr; }']}",True,An issue was discovered in cpp-peglib through v0.1.12. A NULL pointer dereference exists in the peg::AstOptimizer::optimize() located in peglib.h. It allows an attacker to cause Denial of Service.,5.5,MEDIUM,1,valid,2020-08-07T14:21:47Z,3
CVE-2020-23914,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,yhirose/cpp-peglib,Fix #121,0061f393de54cf0326621c079dc2988336d1ebb3,https://github.com/yhirose/cpp-peglib/commit/0061f393de54cf0326621c079dc2988336d1ebb3,peglib.h,LiteralString,"LiteralString(std::string &&s, bool ignore_case)
: lit_(s), ignore_case_(ignore_case),
is_word_(false) {}","LiteralString(std::string &&VAR_0, bool VAR_1)
: lit_(VAR_0), ignore_case_(VAR_1),
is_word_(false) {}",,"LiteralString(std::string &&s, bool ignore_case)
      : lit_(s), ignore_case_(ignore_case), is_word_(false) {}","LiteralString(std::string &&VAR_0, bool VAR_1)
      : lit_(VAR_0), ignore_case_(VAR_1), is_word_(false) {}",,"--- func_before
+++ func_after
@@ -1,3 +1,2 @@
 LiteralString(std::string &&s, bool ignore_case)
-      : lit_(s), ignore_case_(ignore_case),
-        is_word_(false) {}
+      : lit_(s), ignore_case_(ignore_case), is_word_(false) {}","{'deleted_lines': ['      : lit_(s), ignore_case_(ignore_case),', '        is_word_(false) {}'], 'added_lines': ['      : lit_(s), ignore_case_(ignore_case), is_word_(false) {}']}",True,An issue was discovered in cpp-peglib through v0.1.12. A NULL pointer dereference exists in the peg::AstOptimizer::optimize() located in peglib.h. It allows an attacker to cause Denial of Service.,5.5,MEDIUM,1,valid,2020-08-07T14:21:47Z,3
CVE-2021-32273,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,knik0/faad2,"mp4read.c: fix stack-buffer-overflow in stringin()/ftypin()

Terminate the string read into the stack buffer,
fixes #56.",1073aeef823cafd844704389e9a497c257768e2f,https://github.com/knik0/faad2/commit/1073aeef823cafd844704389e9a497c257768e2f,frontend/mp4read.c,stringin,"static int stringin(char *txt, int sizemax)
{
int size;
for (size = 0; size < sizemax; size++)
{
if (fread(txt + size, 1, 1, g_fin) != 1)
return ERR_FAIL;
if (!txt[size])
break;
}
return size;
}","static int stringin(char *VAR_0, int VAR_1)
{
int VAR_2;
for (VAR_2 = 0; VAR_2 < VAR_1; VAR_2++)
{
if (fread(VAR_0 + VAR_2, 1, 1, VAR_3) != 1)
return VAR_4;
if (!VAR_0[VAR_2])
break;
}
return VAR_2;
}",knik0/faad2/1073aeef823cafd844704389e9a497c257768e2f/mp4read.c/vul/before/0.json,"static int stringin(char *txt, int sizemax)
{
    int size;
    for (size = 0; size < sizemax; size++)
    {
        if (fread(txt + size, 1, 1, g_fin) != 1)
            return ERR_FAIL;
        if (!txt[size])
            break;
    }
    txt[sizemax-1] = '\0';

    return size;
}","static int stringin(char *VAR_0, int VAR_1)
{
    int VAR_2;
    for (VAR_2 = 0; VAR_2 < VAR_1; VAR_2++)
    {
        if (fread(VAR_0 + VAR_2, 1, 1, VAR_3) != 1)
            return VAR_4;
        if (!VAR_0[VAR_2])
            break;
    }
    VAR_0[VAR_1-1] = '\0';

    return VAR_2;
}",knik0/faad2/1073aeef823cafd844704389e9a497c257768e2f/mp4read.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,6 +8,7 @@
         if (!txt[size])
             break;
     }
+    txt[sizemax-1] = '\0';
 
     return size;
 }","{'deleted_lines': [], 'added_lines': [""    txt[sizemax-1] = '\\0';""]}",True,An issue was discovered in faad2 through 2.10.0. A stack-buffer-overflow exists in the function ftypin located in mp4read.c. It allows an attacker to cause Code Execution.,7.8,HIGH,2,valid,2020-08-17T05:37:09Z,3
CVE-2020-23931,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:N/A:P,0,gpac,fixed #1564,093283e727f396130651280609e687cd4778e0d1,https://github.com/gpac/gpac/commit/093283e727f396130651280609e687cd4778e0d1,src/isomedia/box_code_adobe.c,abst_box_read,"GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)
{
GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;
int i;
u32 tmp_strsize;
char *tmp_str;
GF_Err e;
ISOM_DECREASE_SIZE(ptr, 25)
ptr->bootstrapinfo_version = gf_bs_read_u32(bs);
ptr->profile = gf_bs_read_int(bs, 2);
ptr->live = gf_bs_read_int(bs, 1);
ptr->update = gf_bs_read_int(bs, 1);
ptr->reserved = gf_bs_read_int(bs, 4);
ptr->time_scale = gf_bs_read_u32(bs);
ptr->current_media_time = gf_bs_read_u64(bs);
ptr->smpte_time_code_offset = gf_bs_read_u64(bs);
i=0;
if (ptr->size<8) return GF_ISOM_INVALID_FILE;
tmp_strsize =(u32)ptr->size-8;
tmp_str = gf_malloc(sizeof(char)*tmp_strsize);
if (!tmp_str) return GF_OUT_OF_MEM;
memset(tmp_str, 0, sizeof(char)*tmp_strsize);
while (tmp_strsize) {
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i) {
ptr->movie_identifier = gf_strdup(tmp_str);
}
ptr->server_entry_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->server_entry_count; i++) {
int j=0;
tmp_strsize=(u32)ptr->size-8;
while (tmp_strsize) {
tmp_str[j] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[j])
break;
j++;
}
if (j) {
gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);
}
}
ptr->quality_entry_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->quality_entry_count; i++) {
int j=0;
tmp_strsize=(u32)ptr->size-8;
while (tmp_strsize) {
tmp_str[j] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[j])
break;
j++;
}
if (j) {
gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);
}
}
i=0;
tmp_strsize=(u32)ptr->size-8;
while (tmp_strsize) {
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i) {
ptr->drm_data = gf_strdup(tmp_str);
}
i=0;
tmp_strsize=(u32)ptr->size-8;
while (tmp_strsize) {
tmp_str[i] = gf_bs_read_u8(bs);
tmp_strsize--;
if (!tmp_str[i])
break;
i++;
}
if (i) {
ptr->meta_data = gf_strdup(tmp_str);
}
ptr->segment_run_table_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->segment_run_table_count; i++) {
GF_AdobeSegmentRunTableBox *asrt = NULL;
e = gf_isom_box_parse((GF_Box **)&asrt, bs);
if (e) {
if (asrt) gf_isom_box_del((GF_Box*)asrt);
gf_free(tmp_str);
return e;
}
gf_list_add(ptr->segment_run_table_entries, asrt);
}
ptr->fragment_run_table_count = gf_bs_read_u8(bs);
for (i=0; i<ptr->fragment_run_table_count; i++) {
GF_AdobeFragmentRunTableBox *afrt = NULL;
e = gf_isom_box_parse((GF_Box **)&afrt, bs);
if (e) {
if (afrt) gf_isom_box_del((GF_Box*)afrt);
gf_free(tmp_str);
return e;
}
gf_list_add(ptr->fragment_run_table_entries, afrt);
}
gf_free(tmp_str);
return GF_OK;
}","GF_Err abst_box_read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
GF_AdobeBootstrapInfoBox *VAR_2 = (GF_AdobeBootstrapInfoBox *)VAR_0;
int VAR_3;
u32 VAR_4;
char *VAR_5;
GF_Err VAR_6;
ISOM_DECREASE_SIZE(VAR_2, 25)
VAR_2->bootstrapinfo_version = gf_bs_read_u32(VAR_1);
VAR_2->profile = gf_bs_read_int(VAR_1, 2);
VAR_2->live = gf_bs_read_int(VAR_1, 1);
VAR_2->update = gf_bs_read_int(VAR_1, 1);
VAR_2->reserved = gf_bs_read_int(VAR_1, 4);
VAR_2->time_scale = gf_bs_read_u32(VAR_1);
VAR_2->current_media_time = gf_bs_read_u64(VAR_1);
VAR_2->smpte_time_code_offset = gf_bs_read_u64(VAR_1);
VAR_3=0;
if (VAR_2->size<8) return VAR_7;
VAR_4 =(u32)VAR_2->size-8;
VAR_5 = gf_malloc(sizeof(char)*VAR_4);
if (!VAR_5) return VAR_8;
memset(VAR_5, 0, sizeof(char)*VAR_4);
while (VAR_4) {
VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_3])
break;
VAR_3++;
}
if (VAR_3) {
VAR_2->movie_identifier = gf_strdup(VAR_5);
}
VAR_2->server_entry_count = gf_bs_read_u8(VAR_1);
for (VAR_3=0; VAR_3<VAR_2->server_entry_count; VAR_3++) {
int VAR_9=0;
VAR_4=(u32)VAR_2->size-8;
while (VAR_4) {
VAR_5[VAR_9] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_9])
break;
VAR_9++;
}
if (VAR_9) {
gf_list_insert(VAR_2->server_entry_table, gf_strdup(VAR_5), VAR_3);
}
}
VAR_2->quality_entry_count = gf_bs_read_u8(VAR_1);
for (VAR_3=0; VAR_3<VAR_2->quality_entry_count; VAR_3++) {
int VAR_9=0;
VAR_4=(u32)VAR_2->size-8;
while (VAR_4) {
VAR_5[VAR_9] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_9])
break;
VAR_9++;
}
if (VAR_9) {
gf_list_insert(VAR_2->quality_entry_table, gf_strdup(VAR_5), VAR_3);
}
}
VAR_3=0;
VAR_4=(u32)VAR_2->size-8;
while (VAR_4) {
VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_3])
break;
VAR_3++;
}
if (VAR_3) {
VAR_2->drm_data = gf_strdup(VAR_5);
}
VAR_3=0;
VAR_4=(u32)VAR_2->size-8;
while (VAR_4) {
VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
VAR_4--;
if (!VAR_5[VAR_3])
break;
VAR_3++;
}
if (VAR_3) {
VAR_2->meta_data = gf_strdup(VAR_5);
}
VAR_2->segment_run_table_count = gf_bs_read_u8(VAR_1);
for (VAR_3=0; VAR_3<VAR_2->segment_run_table_count; VAR_3++) {
GF_AdobeSegmentRunTableBox *VAR_10 = NULL;
VAR_6 = gf_isom_box_parse((GF_Box **)&VAR_10, VAR_1);
if (VAR_6) {
if (VAR_10) gf_isom_box_del((GF_Box*)VAR_10);
gf_free(VAR_5);
return VAR_6;
}
gf_list_add(VAR_2->segment_run_table_entries, VAR_10);
}
VAR_2->fragment_run_table_count = gf_bs_read_u8(VAR_1);
for (VAR_3=0; VAR_3<VAR_2->fragment_run_table_count; VAR_3++) {
GF_AdobeFragmentRunTableBox *VAR_11 = NULL;
VAR_6 = gf_isom_box_parse((GF_Box **)&VAR_11, VAR_1);
if (VAR_6) {
if (VAR_11) gf_isom_box_del((GF_Box*)VAR_11);
gf_free(VAR_5);
return VAR_6;
}
gf_list_add(VAR_2->fragment_run_table_entries, VAR_11);
}
gf_free(VAR_5);
return VAR_12;
}",gpac/093283e727f396130651280609e687cd4778e0d1/box_code_adobe.c/vul/before/0.json,"GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;
	int i;
	u32 tmp_strsize;
	char *tmp_str;
	GF_Err e;

	ISOM_DECREASE_SIZE(ptr, 25)
	ptr->bootstrapinfo_version = gf_bs_read_u32(bs);
	ptr->profile = gf_bs_read_int(bs, 2);
	ptr->live = gf_bs_read_int(bs, 1);
	ptr->update = gf_bs_read_int(bs, 1);
	ptr->reserved = gf_bs_read_int(bs, 4);
	ptr->time_scale = gf_bs_read_u32(bs);
	ptr->current_media_time = gf_bs_read_u64(bs);
	ptr->smpte_time_code_offset = gf_bs_read_u64(bs);

	i=0;
	if (ptr->size<8) return GF_ISOM_INVALID_FILE;
	tmp_strsize =(u32)ptr->size-8;
	tmp_str = gf_malloc(sizeof(char)*tmp_strsize);
	if (!tmp_str) return GF_OUT_OF_MEM;
	memset(tmp_str, 0, sizeof(char)*tmp_strsize);

	while (tmp_strsize) {
		ISOM_DECREASE_SIZE(ptr, 1)
		tmp_str[i] = gf_bs_read_u8(bs);
		tmp_strsize--;
		if (!tmp_str[i])
			break;
		i++;
	}
	if (i) {
		ptr->movie_identifier = gf_strdup(tmp_str);
	}

	ISOM_DECREASE_SIZE(ptr, 1)
	ptr->server_entry_count = gf_bs_read_u8(bs);
	for (i=0; i<ptr->server_entry_count; i++) {
		int j=0;
		tmp_strsize=(u32)ptr->size;
		while (tmp_strsize) {
			ISOM_DECREASE_SIZE(ptr, 1)
			tmp_str[j] = gf_bs_read_u8(bs);
			tmp_strsize--;
			if (!tmp_str[j])
				break;
			j++;
		}
		if (j) {
			gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);
		}
	}

	ISOM_DECREASE_SIZE(ptr, 1)
	ptr->quality_entry_count = gf_bs_read_u8(bs);
	for (i=0; i<ptr->quality_entry_count; i++) {
		int j=0;
		tmp_strsize=(u32)ptr->size;
		while (tmp_strsize) {
			ISOM_DECREASE_SIZE(ptr, 1)
			tmp_str[j] = gf_bs_read_u8(bs);
			tmp_strsize--;
			if (!tmp_str[j])
				break;
			j++;
		}

		if (j) {
			gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);
		}
	}

	i=0;
	tmp_strsize=(u32)ptr->size;
	while (tmp_strsize) {
		ISOM_DECREASE_SIZE(ptr, 1)
		tmp_str[i] = gf_bs_read_u8(bs);
		tmp_strsize--;
		if (!tmp_str[i])
			break;
		i++;
	}
	if (i) {
		ptr->drm_data = gf_strdup(tmp_str);
	}

	i=0;
	tmp_strsize=(u32)ptr->size;
	while (tmp_strsize) {
		ISOM_DECREASE_SIZE(ptr, 1)
		tmp_str[i] = gf_bs_read_u8(bs);
		tmp_strsize--;
		if (!tmp_str[i])
			break;
		i++;
	}
	if (i) {
		ptr->meta_data = gf_strdup(tmp_str);
	}

	ISOM_DECREASE_SIZE(ptr, 1)
	ptr->segment_run_table_count = gf_bs_read_u8(bs);
	for (i=0; i<ptr->segment_run_table_count; i++) {
		GF_AdobeSegmentRunTableBox *asrt = NULL;
		e = gf_isom_box_parse((GF_Box **)&asrt, bs);
		if (e) {
			if (asrt) gf_isom_box_del((GF_Box*)asrt);
			gf_free(tmp_str);
			return e;
		}
		gf_list_add(ptr->segment_run_table_entries, asrt);
	}

	ISOM_DECREASE_SIZE(ptr, 1)
	ptr->fragment_run_table_count = gf_bs_read_u8(bs);
	for (i=0; i<ptr->fragment_run_table_count; i++) {
		GF_AdobeFragmentRunTableBox *afrt = NULL;
		e = gf_isom_box_parse((GF_Box **)&afrt, bs);
		if (e) {
			if (afrt) gf_isom_box_del((GF_Box*)afrt);
			gf_free(tmp_str);
			return e;
		}
		gf_list_add(ptr->fragment_run_table_entries, afrt);
	}

	gf_free(tmp_str);

	return GF_OK;
}","GF_Err abst_box_read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
	GF_AdobeBootstrapInfoBox *VAR_2 = (GF_AdobeBootstrapInfoBox *)VAR_0;
	int VAR_3;
	u32 VAR_4;
	char *VAR_5;
	GF_Err VAR_6;

	ISOM_DECREASE_SIZE(VAR_2, 25)
	VAR_2->bootstrapinfo_version = gf_bs_read_u32(VAR_1);
	VAR_2->profile = gf_bs_read_int(VAR_1, 2);
	VAR_2->live = gf_bs_read_int(VAR_1, 1);
	VAR_2->update = gf_bs_read_int(VAR_1, 1);
	VAR_2->reserved = gf_bs_read_int(VAR_1, 4);
	VAR_2->time_scale = gf_bs_read_u32(VAR_1);
	VAR_2->current_media_time = gf_bs_read_u64(VAR_1);
	VAR_2->smpte_time_code_offset = gf_bs_read_u64(VAR_1);

	VAR_3=0;
	if (VAR_2->size<8) return VAR_7;
	VAR_4 =(u32)VAR_2->size-8;
	VAR_5 = gf_malloc(sizeof(char)*VAR_4);
	if (!VAR_5) return VAR_8;
	memset(VAR_5, 0, sizeof(char)*VAR_4);

	while (VAR_4) {
		ISOM_DECREASE_SIZE(VAR_2, 1)
		VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
		VAR_4--;
		if (!VAR_5[VAR_3])
			break;
		VAR_3++;
	}
	if (VAR_3) {
		VAR_2->movie_identifier = gf_strdup(VAR_5);
	}

	ISOM_DECREASE_SIZE(VAR_2, 1)
	VAR_2->server_entry_count = gf_bs_read_u8(VAR_1);
	for (VAR_3=0; VAR_3<VAR_2->server_entry_count; VAR_3++) {
		int VAR_9=0;
		VAR_4=(u32)VAR_2->size;
		while (VAR_4) {
			ISOM_DECREASE_SIZE(VAR_2, 1)
			VAR_5[VAR_9] = gf_bs_read_u8(VAR_1);
			VAR_4--;
			if (!VAR_5[VAR_9])
				break;
			VAR_9++;
		}
		if (VAR_9) {
			gf_list_insert(VAR_2->server_entry_table, gf_strdup(VAR_5), VAR_3);
		}
	}

	ISOM_DECREASE_SIZE(VAR_2, 1)
	VAR_2->quality_entry_count = gf_bs_read_u8(VAR_1);
	for (VAR_3=0; VAR_3<VAR_2->quality_entry_count; VAR_3++) {
		int VAR_9=0;
		VAR_4=(u32)VAR_2->size;
		while (VAR_4) {
			ISOM_DECREASE_SIZE(VAR_2, 1)
			VAR_5[VAR_9] = gf_bs_read_u8(VAR_1);
			VAR_4--;
			if (!VAR_5[VAR_9])
				break;
			VAR_9++;
		}

		if (VAR_9) {
			gf_list_insert(VAR_2->quality_entry_table, gf_strdup(VAR_5), VAR_3);
		}
	}

	VAR_3=0;
	VAR_4=(u32)VAR_2->size;
	while (VAR_4) {
		ISOM_DECREASE_SIZE(VAR_2, 1)
		VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
		VAR_4--;
		if (!VAR_5[VAR_3])
			break;
		VAR_3++;
	}
	if (VAR_3) {
		VAR_2->drm_data = gf_strdup(VAR_5);
	}

	VAR_3=0;
	VAR_4=(u32)VAR_2->size;
	while (VAR_4) {
		ISOM_DECREASE_SIZE(VAR_2, 1)
		VAR_5[VAR_3] = gf_bs_read_u8(VAR_1);
		VAR_4--;
		if (!VAR_5[VAR_3])
			break;
		VAR_3++;
	}
	if (VAR_3) {
		VAR_2->meta_data = gf_strdup(VAR_5);
	}

	ISOM_DECREASE_SIZE(VAR_2, 1)
	VAR_2->segment_run_table_count = gf_bs_read_u8(VAR_1);
	for (VAR_3=0; VAR_3<VAR_2->segment_run_table_count; VAR_3++) {
		GF_AdobeSegmentRunTableBox *VAR_10 = NULL;
		VAR_6 = gf_isom_box_parse((GF_Box **)&VAR_10, VAR_1);
		if (VAR_6) {
			if (VAR_10) gf_isom_box_del((GF_Box*)VAR_10);
			gf_free(VAR_5);
			return VAR_6;
		}
		gf_list_add(VAR_2->segment_run_table_entries, VAR_10);
	}

	ISOM_DECREASE_SIZE(VAR_2, 1)
	VAR_2->fragment_run_table_count = gf_bs_read_u8(VAR_1);
	for (VAR_3=0; VAR_3<VAR_2->fragment_run_table_count; VAR_3++) {
		GF_AdobeFragmentRunTableBox *VAR_11 = NULL;
		VAR_6 = gf_isom_box_parse((GF_Box **)&VAR_11, VAR_1);
		if (VAR_6) {
			if (VAR_11) gf_isom_box_del((GF_Box*)VAR_11);
			gf_free(VAR_5);
			return VAR_6;
		}
		gf_list_add(VAR_2->fragment_run_table_entries, VAR_11);
	}

	gf_free(VAR_5);

	return VAR_12;
}",gpac/093283e727f396130651280609e687cd4778e0d1/box_code_adobe.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -24,6 +24,7 @@
 	memset(tmp_str, 0, sizeof(char)*tmp_strsize);
 
 	while (tmp_strsize) {
+		ISOM_DECREASE_SIZE(ptr, 1)
 		tmp_str[i] = gf_bs_read_u8(bs);
 		tmp_strsize--;
 		if (!tmp_str[i])
@@ -34,11 +35,13 @@
 		ptr->movie_identifier = gf_strdup(tmp_str);
 	}
 
+	ISOM_DECREASE_SIZE(ptr, 1)
 	ptr->server_entry_count = gf_bs_read_u8(bs);
 	for (i=0; i<ptr->server_entry_count; i++) {
 		int j=0;
-		tmp_strsize=(u32)ptr->size-8;
+		tmp_strsize=(u32)ptr->size;
 		while (tmp_strsize) {
+			ISOM_DECREASE_SIZE(ptr, 1)
 			tmp_str[j] = gf_bs_read_u8(bs);
 			tmp_strsize--;
 			if (!tmp_str[j])
@@ -50,11 +53,13 @@
 		}
 	}
 
+	ISOM_DECREASE_SIZE(ptr, 1)
 	ptr->quality_entry_count = gf_bs_read_u8(bs);
 	for (i=0; i<ptr->quality_entry_count; i++) {
 		int j=0;
-		tmp_strsize=(u32)ptr->size-8;
+		tmp_strsize=(u32)ptr->size;
 		while (tmp_strsize) {
+			ISOM_DECREASE_SIZE(ptr, 1)
 			tmp_str[j] = gf_bs_read_u8(bs);
 			tmp_strsize--;
 			if (!tmp_str[j])
@@ -68,8 +73,9 @@
 	}
 
 	i=0;
-	tmp_strsize=(u32)ptr->size-8;
+	tmp_strsize=(u32)ptr->size;
 	while (tmp_strsize) {
+		ISOM_DECREASE_SIZE(ptr, 1)
 		tmp_str[i] = gf_bs_read_u8(bs);
 		tmp_strsize--;
 		if (!tmp_str[i])
@@ -81,8 +87,9 @@
 	}
 
 	i=0;
-	tmp_strsize=(u32)ptr->size-8;
+	tmp_strsize=(u32)ptr->size;
 	while (tmp_strsize) {
+		ISOM_DECREASE_SIZE(ptr, 1)
 		tmp_str[i] = gf_bs_read_u8(bs);
 		tmp_strsize--;
 		if (!tmp_str[i])
@@ -93,6 +100,7 @@
 		ptr->meta_data = gf_strdup(tmp_str);
 	}
 
+	ISOM_DECREASE_SIZE(ptr, 1)
 	ptr->segment_run_table_count = gf_bs_read_u8(bs);
 	for (i=0; i<ptr->segment_run_table_count; i++) {
 		GF_AdobeSegmentRunTableBox *asrt = NULL;
@@ -105,6 +113,7 @@
 		gf_list_add(ptr->segment_run_table_entries, asrt);
 	}
 
+	ISOM_DECREASE_SIZE(ptr, 1)
 	ptr->fragment_run_table_count = gf_bs_read_u8(bs);
 	for (i=0; i<ptr->fragment_run_table_count; i++) {
 		GF_AdobeFragmentRunTableBox *afrt = NULL;","{'deleted_lines': ['\t\ttmp_strsize=(u32)ptr->size-8;', '\t\ttmp_strsize=(u32)ptr->size-8;', '\ttmp_strsize=(u32)ptr->size-8;', '\ttmp_strsize=(u32)ptr->size-8;'], 'added_lines': ['\t\tISOM_DECREASE_SIZE(ptr, 1)', '\tISOM_DECREASE_SIZE(ptr, 1)', '\t\ttmp_strsize=(u32)ptr->size;', '\t\t\tISOM_DECREASE_SIZE(ptr, 1)', '\tISOM_DECREASE_SIZE(ptr, 1)', '\t\ttmp_strsize=(u32)ptr->size;', '\t\t\tISOM_DECREASE_SIZE(ptr, 1)', '\ttmp_strsize=(u32)ptr->size;', '\t\tISOM_DECREASE_SIZE(ptr, 1)', '\ttmp_strsize=(u32)ptr->size;', '\t\tISOM_DECREASE_SIZE(ptr, 1)', '\tISOM_DECREASE_SIZE(ptr, 1)', '\tISOM_DECREASE_SIZE(ptr, 1)']}",True,An issue was discovered in gpac before 1.0.1. The abst_box_read function in box_code_adobe.c has a heap-based buffer over-read.,7.1,HIGH,2,valid,2020-09-01T14:42:40Z,3
CVE-2020-15208,"['CWE-787', 'CWE-125']",AV:N/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"[tflite] Ensure `MatchingDim` does not allow buffer overflow.

We check in `MatchingDim` that both arguments have the same dimensionality, however that is a `DCHECK` only enabled if building in debug mode. Hence, it could be possible to cause buffer overflows by passing in a tensor with larger dimensions as the second argument. To fix, we now make `MatchingDim` return the minimum of the two sizes.

A much better fix would be to return a status object but that requires refactoring a large part of the codebase for minor benefits.

PiperOrigin-RevId: 332526127
Change-Id: If627d0d2c80a685217b6e0d1e64b0872dbf1c5e4",8ee24e7949a203d234489f9da2c5bf45a7d5157d,https://github.com/tensorflow/tensorflow/commit/8ee24e7949a203d234489f9da2c5bf45a7d5157d,tensorflow/lite/kernels/internal/types.h,MatchingDim,"inline int MatchingDim(const RuntimeShape& shape1, int index1,
const RuntimeShape& shape2, int index2) {
TFLITE_DCHECK_EQ(shape1.Dims(index1), shape2.Dims(index2));
return shape1.Dims(index1);
}","inline int MatchingDim(const RuntimeShape& VAR_0, int VAR_1,
const RuntimeShape& VAR_2, int VAR_3) {
TFLITE_DCHECK_EQ(VAR_0.Dims(VAR_1), VAR_2.Dims(VAR_3));
return VAR_0.Dims(VAR_1);
}",tensorflow/8ee24e7949a203d234489f9da2c5bf45a7d5157d/types.h/vul/before/0.json,"inline int MatchingDim(const RuntimeShape& shape1, int index1,
                       const RuntimeShape& shape2, int index2) {
  TFLITE_DCHECK_EQ(shape1.Dims(index1), shape2.Dims(index2));
  return std::min(shape1.Dims(index1), shape2.Dims(index2));
}","inline int MatchingDim(const RuntimeShape& VAR_0, int VAR_1,
                       const RuntimeShape& VAR_2, int VAR_3) {
  TFLITE_DCHECK_EQ(VAR_0.Dims(VAR_1), VAR_2.Dims(VAR_3));
  return std::min(VAR_0.Dims(VAR_1), VAR_2.Dims(VAR_3));
}",tensorflow/8ee24e7949a203d234489f9da2c5bf45a7d5157d/types.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
 inline int MatchingDim(const RuntimeShape& shape1, int index1,
                        const RuntimeShape& shape2, int index2) {
   TFLITE_DCHECK_EQ(shape1.Dims(index1), shape2.Dims(index2));
-  return shape1.Dims(index1);
+  return std::min(shape1.Dims(index1), shape2.Dims(index2));
 }","{'deleted_lines': ['  return shape1.Dims(index1);'], 'added_lines': ['  return std::min(shape1.Dims(index1), shape2.Dims(index2));']}",True,"In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, when determining the common dimension size of two tensors, TFLite uses a `DCHECK` which is no-op outside of debug compilation modes. Since the function always returns the dimension of the first tensor, malicious attackers can craft cases where this is larger than that of the second tensor. In turn, this would result in reads/writes outside of bounds since the interpreter will wrongly assume that there is enough data in both tensors. The issue is patched in commit 8ee24e7949a203d234489f9da2c5bf45a7d5157d, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",7.4,HIGH,2,valid,2020-09-18T21:19:26Z,3
CVE-2020-25644,['CWE-401'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wildfly-security/wildfly-openssl-natives,WFSSL-51 sessions not removed correctly,7c26514676f3fb0dee0bcaa7d4680f982372950f,https://github.com/wildfly-security/wildfly-openssl-natives/commit/7c26514676f3fb0dee0bcaa7d4680f982372950f,libwfssl/src/session.c,remove_session_cb,"void remove_session_cb(SSL_CTX *ctx, SSL_SESSION * session) {
tcn_ssl_ctxt_t  *c = SSL_CTX_get_app_data1(ctx);
JavaVM *javavm = tcn_get_java_vm();
jbyteArray sessionId;
JNIEnv *e;
(*javavm)->AttachCurrentThread(javavm, (void **)&e, NULL);
sessionId = getSessionId(e, session);
(*e)->CallVoidMethod(e, c->session_context, sessionRemove, sessionId);
(*javavm)->DetachCurrentThread(javavm);
}","void remove_session_cb(SSL_CTX *VAR_0, SSL_SESSION * VAR_1) {
tcn_ssl_ctxt_t  *VAR_2 = SSL_CTX_get_app_data1(VAR_0);
JavaVM *VAR_3 = tcn_get_java_vm();
jbyteArray VAR_4;
JNIEnv *VAR_5;
(*VAR_3)->AttachCurrentThread(VAR_3, (void **)&VAR_5, NULL);
VAR_4 = getSessionId(VAR_5, VAR_1);
(*VAR_5)->CallVoidMethod(VAR_5, VAR_2->session_context, VAR_6, VAR_4);
(*VAR_3)->DetachCurrentThread(VAR_3);
}",wildfly-security/wildfly-openssl-natives/7c26514676f3fb0dee0bcaa7d4680f982372950f/session.c/vul/before/0.json,"void remove_session_cb(SSL_CTX *ctx, SSL_SESSION * session) {
     tcn_ssl_ctxt_t  *c = SSL_CTX_get_app_data1(ctx);
    JavaVM *javavm = tcn_get_java_vm();
    jbyteArray sessionId;
    JNIEnv *e;
    (*javavm)->AttachCurrentThread(javavm, (void **)&e, NULL);
    sessionId = getSessionId(e, session);

    (*e)->CallVoidMethod(e, c->session_context, sessionRemove, sessionId);

    (*javavm)->DetachCurrentThread(javavm);
    ssl_methods.SSL_SESSION_free(session);
}","void remove_session_cb(SSL_CTX *VAR_0, SSL_SESSION * VAR_1) {
     tcn_ssl_ctxt_t  *VAR_2 = SSL_CTX_get_app_data1(VAR_0);
    JavaVM *VAR_3 = tcn_get_java_vm();
    jbyteArray VAR_4;
    JNIEnv *VAR_5;
    (*VAR_3)->AttachCurrentThread(VAR_3, (void **)&VAR_5, NULL);
    VAR_4 = getSessionId(VAR_5, VAR_1);

    (*VAR_5)->CallVoidMethod(VAR_5, VAR_2->session_context, VAR_6, VAR_4);

    (*VAR_3)->DetachCurrentThread(VAR_3);
    VAR_7.SSL_SESSION_free(VAR_1);
}",wildfly-security/wildfly-openssl-natives/7c26514676f3fb0dee0bcaa7d4680f982372950f/session.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,4 +9,5 @@
     (*e)->CallVoidMethod(e, c->session_context, sessionRemove, sessionId);
 
     (*javavm)->DetachCurrentThread(javavm);
+    ssl_methods.SSL_SESSION_free(session);
 }","{'deleted_lines': [], 'added_lines': ['    ssl_methods.SSL_SESSION_free(session);']}",True,"A memory leak flaw was found in WildFly OpenSSL in versions prior to 1.1.3.Final, where it removes an HTTP session. It may allow the attacker to cause OOM leading to a denial of service. The highest threat from this vulnerability is to system availability.",7.5,HIGH,2,valid,2020-09-22T06:44:41Z,3
CVE-2020-25595,['CWE-269'],AV:L/AC:L/Au:N/C:P/I:P/A:C,0,xen-project/xen,"x86/msi: get rid of read_msi_msg

It's safer and faster to just use the cached last written
(untranslated) MSI message stored in msi_desc for the single user that
calls read_msi_msg.

This also prevents relying on the data read from the device MSI
registers in order to figure out the index into the IOMMU interrupt
remapping table, which is not safe.

This is part of XSA-337.

Reported-by: Andrew Cooper <andrew.cooper3@citrix.com>
Requested-by: Andrew Cooper <andrew.cooper3@citrix.com>
Signed-off-by: Roger Pau Monn <roger.pau@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",cb5e9730862ba0c99e81d3fbd8f65010707245e4,https://github.com/xen-project/xen/commit/cb5e9730862ba0c99e81d3fbd8f65010707245e4,xen/arch/x86/msi.c,set_msi_affinity,"void set_msi_affinity(struct irq_desc *desc, const cpumask_t *mask)
{
struct msi_msg msg;
unsigned int dest;
struct msi_desc *msi_desc = desc->msi_desc;
dest = set_desc_affinity(desc, mask);
if ( dest == BAD_APICID || !msi_desc )
return;
ASSERT(spin_is_locked(&desc->lock));
memset(&msg, 0, sizeof(msg));
if ( !read_msi_msg(msi_desc, &msg) )
return;
msg.data &= ~MSI_DATA_VECTOR_MASK;
msg.data |= MSI_DATA_VECTOR(desc->arch.vector);
msg.address_lo &= ~MSI_ADDR_DEST_ID_MASK;
msg.address_lo |= MSI_ADDR_DEST_ID(dest);
msg.dest32 = dest;
write_msi_msg(msi_desc, &msg);
}","void set_msi_affinity(struct irq_desc *VAR_0, const cpumask_t *VAR_1)
{
struct msi_msg VAR_2;
unsigned int VAR_3;
struct msi_desc *msi_desc = VAR_0->msi_desc;
VAR_3 = set_desc_affinity(VAR_0, VAR_1);
if ( VAR_3 == VAR_4 || !msi_desc )
return;
ASSERT(spin_is_locked(&VAR_0->lock));
memset(&VAR_2, 0, sizeof(VAR_2));
if ( !read_msi_msg(msi_desc, &VAR_2) )
return;
VAR_2.data &= ~VAR_5;
VAR_2.data |= MSI_DATA_VECTOR(VAR_0->arch.vector);
VAR_2.address_lo &= ~VAR_6;
VAR_2.address_lo |= MSI_ADDR_DEST_ID(VAR_3);
VAR_2.dest32 = VAR_3;
write_msi_msg(msi_desc, &VAR_2);
}",xen-project/xen/cb5e9730862ba0c99e81d3fbd8f65010707245e4/msi.c/vul/before/0.json,"void set_msi_affinity(struct irq_desc *desc, const cpumask_t *mask)
{
    struct msi_msg msg;
    unsigned int dest;
    struct msi_desc *msi_desc = desc->msi_desc;

    dest = set_desc_affinity(desc, mask);
    if ( dest == BAD_APICID || !msi_desc )
        return;

    ASSERT(spin_is_locked(&desc->lock));

    msg = msi_desc->msg;
    msg.data &= ~MSI_DATA_VECTOR_MASK;
    msg.data |= MSI_DATA_VECTOR(desc->arch.vector);
    msg.address_lo &= ~MSI_ADDR_DEST_ID_MASK;
    msg.address_lo |= MSI_ADDR_DEST_ID(dest);
    msg.dest32 = dest;

    write_msi_msg(msi_desc, &msg);
}","void set_msi_affinity(struct irq_desc *VAR_0, const cpumask_t *VAR_1)
{
    struct msi_msg VAR_2;
    unsigned int VAR_3;
    struct msi_desc *msi_desc = VAR_0->msi_desc;

    VAR_3 = set_desc_affinity(VAR_0, VAR_1);
    if ( VAR_3 == VAR_4 || !msi_desc )
        return;

    ASSERT(spin_is_locked(&VAR_0->lock));

    VAR_2 = msi_desc->msg;
    VAR_2.data &= ~VAR_5;
    VAR_2.data |= MSI_DATA_VECTOR(VAR_0->arch.vector);
    VAR_2.address_lo &= ~VAR_6;
    VAR_2.address_lo |= MSI_ADDR_DEST_ID(VAR_3);
    VAR_2.dest32 = VAR_3;

    write_msi_msg(msi_desc, &VAR_2);
}",xen-project/xen/cb5e9730862ba0c99e81d3fbd8f65010707245e4/msi.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,10 +10,7 @@
 
     ASSERT(spin_is_locked(&desc->lock));
 
-    memset(&msg, 0, sizeof(msg));
-    if ( !read_msi_msg(msi_desc, &msg) )
-        return;
-
+    msg = msi_desc->msg;
     msg.data &= ~MSI_DATA_VECTOR_MASK;
     msg.data |= MSI_DATA_VECTOR(desc->arch.vector);
     msg.address_lo &= ~MSI_ADDR_DEST_ID_MASK;","{'deleted_lines': ['    memset(&msg, 0, sizeof(msg));', '    if ( !read_msi_msg(msi_desc, &msg) )', '        return;', ''], 'added_lines': ['    msg = msi_desc->msg;']}",True,"An issue was discovered in Xen through 4.14.x. The PCI passthrough code improperly uses register data. Code paths in Xen's MSI handling have been identified that act on unsanitized values read back from device hardware registers. While devices strictly compliant with PCI specifications shouldn't be able to affect these registers, experience shows that it's very common for devices to have out-of-spec ""backdoor"" operations that can affect the result of these reads. A not fully trusted guest may be able to crash Xen, leading to a Denial of Service (DoS) for the entire system. Privilege escalation and information leaks cannot be excluded. All versions of Xen supporting PCI passthrough are affected. Only x86 systems are vulnerable. Arm systems are not vulnerable. Only guests with passed through PCI devices may be able to leverage the vulnerability. Only systems passing through devices with out-of-spec (""backdoor"") functionality can cause issues. Experience shows that such out-of-spec functionality is common; unless you have reason to believe that your device does not have such functionality, it's better to assume that it does.",7.8,HIGH,2,valid,2020-09-22T13:47:58Z,3
CVE-2020-25595,['CWE-269'],AV:L/AC:L/Au:N/C:P/I:P/A:C,0,xen-project/xen,"x86/MSI-X: restrict reading of table/PBA bases from BARs

When assigned to less trusted or un-trusted guests, devices may change
state behind our backs (they may e.g. get reset by means we may not know
about). Therefore we should avoid reading BARs from hardware once a
device is no longer owned by Dom0. Furthermore when we can't read a BAR,
or when we read zero, we shouldn't instead use the caller provided
address unless that caller can be trusted.

Re-arrange the logic in msix_capability_init() such that only Dom0 (and
only if the device isn't DomU-owned yet) or calls through
PHYSDEVOP_prepare_msix will actually result in the reading of the
respective BAR register(s). Additionally do so only as long as in-use
table entries are known (note that invocation of PHYSDEVOP_prepare_msix
counts as a ""pseudo"" entry). In all other uses the value already
recorded will get used instead.

Clear the recorded values in _pci_cleanup_msix() as well as on the one
affected error path. (Adjust this error path to also avoid blindly
disabling MSI-X when it was enabled on entry to the function.)

While moving around variable declarations (in many cases to reduce their
scopes), also adjust some of their types.

This is part of XSA-337.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Roger Pau Monn <roger.pau@citrix.com>",beb54596cfdaf15f6a86d7b1bf84ca8a0b9c6b9b,https://github.com/xen-project/xen/commit/beb54596cfdaf15f6a86d7b1bf84ca8a0b9c6b9b,xen/arch/x86/msi.c,msix_capability_init,"static int msix_capability_init(struct pci_dev *dev,
struct msi_info *msi,
struct msi_desc **desc)
{
struct arch_msix *msix = dev->msix;
struct msi_desc *entry = NULL;
int vf;
u16 control;
u64 table_paddr;
u32 table_offset;
u8 bir, pbus, pslot, pfunc;
u16 seg = dev->seg;
u8 bus = dev->bus;
u8 slot = PCI_SLOT(dev->devfn);
u8 func = PCI_FUNC(dev->devfn);
bool maskall = msix->host_maskall;
unsigned int pos = pci_find_cap_offset(seg, bus, slot, func,
PCI_CAP_ID_MSIX);
if ( !pos )
return -ENODEV;
ASSERT(pcidevs_locked());
control = pci_conf_read16(dev->sbdf, msix_control_reg(pos));
msix->host_maskall = 1;
pci_conf_write16(dev->sbdf, msix_control_reg(pos),
control | (PCI_MSIX_FLAGS_ENABLE |
PCI_MSIX_FLAGS_MASKALL));
if ( unlikely(!memory_decoded(dev)) )
{
pci_conf_write16(dev->sbdf, msix_control_reg(pos),
control & ~PCI_MSIX_FLAGS_ENABLE);
return -ENXIO;
}
if ( desc )
{
entry = alloc_msi_entry(1);
if ( !entry )
{
pci_conf_write16(dev->sbdf, msix_control_reg(pos),
control & ~PCI_MSIX_FLAGS_ENABLE);
return -ENOMEM;
}
ASSERT(msi);
}
table_offset = pci_conf_read32(dev->sbdf, msix_table_offset_reg(pos));
bir = (u8)(table_offset & PCI_MSIX_BIRMASK);
table_offset &= ~PCI_MSIX_BIRMASK;
if ( !dev->info.is_virtfn )
{
pbus = bus;
pslot = slot;
pfunc = func;
vf = -1;
}
else
{
pbus = dev->info.physfn.bus;
pslot = PCI_SLOT(dev->info.physfn.devfn);
pfunc = PCI_FUNC(dev->info.physfn.devfn);
vf = PCI_BDF2(dev->bus, dev->devfn);
}
table_paddr = read_pci_mem_bar(seg, pbus, pslot, pfunc, bir, vf);
WARN_ON(msi && msi->table_base != table_paddr);
if ( !table_paddr )
{
if ( !msi || !msi->table_base )
{
pci_conf_write16(dev->sbdf, msix_control_reg(pos),
control & ~PCI_MSIX_FLAGS_ENABLE);
xfree(entry);
return -ENXIO;
}
table_paddr = msi->table_base;
}
table_paddr += table_offset;
if ( !msix->used_entries )
{
u64 pba_paddr;
u32 pba_offset;
msix->table.first = PFN_DOWN(table_paddr);
msix->table.last = PFN_DOWN(table_paddr +
msix->nr_entries * PCI_MSIX_ENTRY_SIZE - 1);
WARN_ON(rangeset_overlaps_range(mmio_ro_ranges, msix->table.first,
msix->table.last));
pba_offset = pci_conf_read32(dev->sbdf, msix_pba_offset_reg(pos));
bir = (u8)(pba_offset & PCI_MSIX_BIRMASK);
pba_paddr = read_pci_mem_bar(seg, pbus, pslot, pfunc, bir, vf);
WARN_ON(!pba_paddr);
pba_paddr += pba_offset & ~PCI_MSIX_BIRMASK;
msix->pba.first = PFN_DOWN(pba_paddr);
msix->pba.last = PFN_DOWN(pba_paddr +
BITS_TO_LONGS(msix->nr_entries) - 1);
WARN_ON(rangeset_overlaps_range(mmio_ro_ranges, msix->pba.first,
msix->pba.last));
}
if ( entry )
{
u64 entry_paddr = table_paddr + msi->entry_nr * PCI_MSIX_ENTRY_SIZE;
int idx = msix_get_fixmap(msix, table_paddr, entry_paddr);
void __iomem *base;
if ( idx < 0 )
{
pci_conf_write16(dev->sbdf, msix_control_reg(pos),
control & ~PCI_MSIX_FLAGS_ENABLE);
xfree(entry);
return idx;
}
base = fix_to_virt(idx) + (entry_paddr & (PAGE_SIZE - 1));
writel(1, base + PCI_MSIX_ENTRY_VECTOR_CTRL_OFFSET);
entry->msi_attrib.type = PCI_CAP_ID_MSIX;
entry->msi_attrib.is_64 = 1;
entry->msi_attrib.entry_nr = msi->entry_nr;
entry->msi_attrib.maskbit = 1;
entry->msi_attrib.host_masked = 1;
entry->msi_attrib.guest_masked = 1;
entry->msi_attrib.pos = pos;
entry->irq = msi->irq;
entry->dev = dev;
entry->mask_base = base;
list_add_tail(&entry->list, &dev->msi_list);
*desc = entry;
}
if ( !msix->used_entries )
{
maskall = false;
if ( !msix->guest_maskall )
control &= ~PCI_MSIX_FLAGS_MASKALL;
else
control |= PCI_MSIX_FLAGS_MASKALL;
if ( rangeset_add_range(mmio_ro_ranges, msix->table.first,
msix->table.last) )
WARN();
if ( rangeset_add_range(mmio_ro_ranges, msix->pba.first,
msix->pba.last) )
WARN();
if ( desc )
{
struct domain *currd = current->domain;
struct domain *d = dev->domain ?: currd;
if ( !is_hardware_domain(currd) || d != currd )
printk(""%s use of MSI-X on %pp by %pd\n"",
is_hardware_domain(currd)
? XENLOG_WARNING ""Potentially insecure""
: XENLOG_ERR ""Insecure"",
&dev->sbdf, d);
if ( !is_hardware_domain(d) &&
(!is_hardware_domain(currd) || domain_tot_pages(d)) )
domain_crash(d);
}
}
WARN_ON(msix->table.first != (table_paddr >> PAGE_SHIFT));
++msix->used_entries;
if ( !hardware_domain )
{
pci_intx(dev, false);
control |= PCI_MSIX_FLAGS_ENABLE;
control &= ~PCI_MSIX_FLAGS_MASKALL;
maskall = 0;
}
msix->host_maskall = maskall;
pci_conf_write16(dev->sbdf, msix_control_reg(pos), control);
return 0;
}","static int msix_capability_init(struct pci_dev *VAR_0,
struct msi_info *VAR_1,
struct msi_desc **VAR_2)
{
struct arch_msix *VAR_3 = VAR_0->msix;
struct msi_desc *VAR_4 = NULL;
int VAR_5;
u16 VAR_6;
u64 VAR_7;
u32 VAR_8;
u8 VAR_9, VAR_10, VAR_11, VAR_12;
u16 VAR_13 = VAR_0->seg;
u8 VAR_14 = VAR_0->bus;
u8 VAR_15 = PCI_SLOT(VAR_0->devfn);
u8 VAR_16 = PCI_FUNC(VAR_0->devfn);
bool VAR_17 = VAR_3->host_maskall;
unsigned int VAR_18 = pci_find_cap_offset(VAR_13, VAR_14, VAR_15, VAR_16,
VAR_19);
if ( !VAR_18 )
return -VAR_20;
ASSERT(pcidevs_locked());
VAR_6 = pci_conf_read16(VAR_0->sbdf, msix_control_reg(VAR_18));
VAR_3->host_maskall = 1;
pci_conf_write16(VAR_0->sbdf, msix_control_reg(VAR_18),
VAR_6 | (VAR_21 |
VAR_22));
if ( unlikely(!memory_decoded(VAR_0)) )
{
pci_conf_write16(VAR_0->sbdf, msix_control_reg(VAR_18),
VAR_6 & ~VAR_21);
return -VAR_23;
}
if ( VAR_2 )
{
VAR_4 = alloc_msi_entry(1);
if ( !VAR_4 )
{
pci_conf_write16(VAR_0->sbdf, msix_control_reg(VAR_18),
VAR_6 & ~VAR_21);
return -VAR_24;
}
ASSERT(VAR_1);
}
VAR_8 = pci_conf_read32(VAR_0->sbdf, msix_table_offset_reg(VAR_18));
VAR_9 = (u8)(VAR_8 & VAR_25);
VAR_8 &= ~VAR_25;
if ( !VAR_0->info.is_virtfn )
{
VAR_10 = VAR_14;
VAR_11 = VAR_15;
VAR_12 = VAR_16;
VAR_5 = -1;
}
else
{
VAR_10 = VAR_0->info.physfn.bus;
VAR_11 = PCI_SLOT(VAR_0->info.physfn.devfn);
VAR_12 = PCI_FUNC(VAR_0->info.physfn.devfn);
VAR_5 = PCI_BDF2(VAR_0->bus, VAR_0->devfn);
}
VAR_7 = read_pci_mem_bar(VAR_13, VAR_10, VAR_11, VAR_12, VAR_9, VAR_5);
WARN_ON(VAR_1 && VAR_1->table_base != VAR_7);
if ( !VAR_7 )
{
if ( !VAR_1 || !VAR_1->table_base )
{
pci_conf_write16(VAR_0->sbdf, msix_control_reg(VAR_18),
VAR_6 & ~VAR_21);
xfree(VAR_4);
return -VAR_23;
}
VAR_7 = VAR_1->table_base;
}
VAR_7 += VAR_8;
if ( !VAR_3->used_entries )
{
u64 VAR_26;
u32 VAR_27;
VAR_3->table.first = PFN_DOWN(VAR_7);
VAR_3->table.last = PFN_DOWN(VAR_7 +
VAR_3->nr_entries * VAR_28 - 1);
WARN_ON(rangeset_overlaps_range(VAR_29, VAR_3->table.first,
VAR_3->table.last));
VAR_27 = pci_conf_read32(VAR_0->sbdf, msix_pba_offset_reg(VAR_18));
VAR_9 = (u8)(VAR_27 & VAR_25);
VAR_26 = read_pci_mem_bar(VAR_13, VAR_10, VAR_11, VAR_12, VAR_9, VAR_5);
WARN_ON(!VAR_26);
VAR_26 += VAR_27 & ~VAR_25;
VAR_3->pba.first = PFN_DOWN(VAR_26);
VAR_3->pba.last = PFN_DOWN(VAR_26 +
BITS_TO_LONGS(VAR_3->nr_entries) - 1);
WARN_ON(rangeset_overlaps_range(VAR_29, VAR_3->pba.first,
VAR_3->pba.last));
}
if ( VAR_4 )
{
u64 VAR_30 = VAR_7 + VAR_1->entry_nr * VAR_28;
int VAR_31 = msix_get_fixmap(VAR_3, VAR_7, VAR_30);
void VAR_32 *VAR_33;
if ( VAR_31 < 0 )
{
pci_conf_write16(VAR_0->sbdf, msix_control_reg(VAR_18),
VAR_6 & ~VAR_21);
xfree(VAR_4);
return VAR_31;
}
VAR_33 = fix_to_virt(VAR_31) + (VAR_30 & (VAR_34 - 1));
writel(1, VAR_33 + VAR_35);
VAR_4->msi_attrib.type = VAR_19;
VAR_4->msi_attrib.is_64 = 1;
VAR_4->msi_attrib.entry_nr = VAR_1->entry_nr;
VAR_4->msi_attrib.maskbit = 1;
VAR_4->msi_attrib.host_masked = 1;
VAR_4->msi_attrib.guest_masked = 1;
VAR_4->msi_attrib.pos = VAR_18;
VAR_4->irq = VAR_1->irq;
VAR_4->dev = VAR_0;
VAR_4->mask_base = VAR_33;
list_add_tail(&VAR_4->list, &VAR_0->msi_list);
*VAR_2 = VAR_4;
}
if ( !VAR_3->used_entries )
{
VAR_17 = false;
if ( !VAR_3->guest_maskall )
VAR_6 &= ~VAR_22;
else
VAR_6 |= VAR_22;
if ( rangeset_add_range(VAR_29, VAR_3->table.first,
VAR_3->table.last) )
WARN();
if ( rangeset_add_range(VAR_29, VAR_3->pba.first,
VAR_3->pba.last) )
WARN();
if ( VAR_2 )
{
struct domain *VAR_36 = VAR_37->domain;
struct domain *VAR_38 = VAR_0->domain ?VAR_39: VAR_36;
if ( !is_hardware_domain(VAR_36) || VAR_38 != VAR_36 )
printk(""%s use of MSI-X on %pp by %pd\n"",
is_hardware_domain(VAR_36)
? XENLOG_WARNING ""Potentially insecure""
: XENLOG_ERR ""Insecure"",
&VAR_0->sbdf, VAR_38);
if ( !is_hardware_domain(VAR_38) &&
(!is_hardware_domain(VAR_36) || domain_tot_pages(VAR_38)) )
domain_crash(VAR_38);
}
}
WARN_ON(VAR_3->table.first != (VAR_7 >> VAR_40));
++VAR_3->used_entries;
if ( !VAR_41 )
{
pci_intx(VAR_0, false);
VAR_6 |= VAR_21;
VAR_6 &= ~VAR_22;
VAR_17 = 0;
}
VAR_3->host_maskall = VAR_17;
pci_conf_write16(VAR_0->sbdf, msix_control_reg(VAR_18), VAR_6);
return 0;
}",xen-project/xen/beb54596cfdaf15f6a86d7b1bf84ca8a0b9c6b9b/msi.c/vul/before/1.json,"static int msix_capability_init(struct pci_dev *dev,
                                struct msi_info *msi,
                                struct msi_desc **desc)
{
    struct arch_msix *msix = dev->msix;
    struct msi_desc *entry = NULL;
    u16 control;
    u64 table_paddr;
    u32 table_offset;
    u16 seg = dev->seg;
    u8 bus = dev->bus;
    u8 slot = PCI_SLOT(dev->devfn);
    u8 func = PCI_FUNC(dev->devfn);
    bool maskall = msix->host_maskall, zap_on_error = false;
    unsigned int pos = pci_find_cap_offset(seg, bus, slot, func,
                                           PCI_CAP_ID_MSIX);

    if ( !pos )
        return -ENODEV;

    ASSERT(pcidevs_locked());

    control = pci_conf_read16(dev->sbdf, msix_control_reg(pos));
    /*
     * Ensure MSI-X interrupts are masked during setup. Some devices require
     * MSI-X to be enabled before we can touch the MSI-X registers. We need
     * to mask all the vectors to prevent interrupts coming in before they're
     * fully set up.
     */
    msix->host_maskall = 1;
    pci_conf_write16(dev->sbdf, msix_control_reg(pos),
                     control | (PCI_MSIX_FLAGS_ENABLE |
                                PCI_MSIX_FLAGS_MASKALL));

    if ( unlikely(!memory_decoded(dev)) )
    {
        pci_conf_write16(dev->sbdf, msix_control_reg(pos),
                         control & ~PCI_MSIX_FLAGS_ENABLE);
        return -ENXIO;
    }

    if ( desc )
    {
        entry = alloc_msi_entry(1);
        if ( !entry )
        {
            pci_conf_write16(dev->sbdf, msix_control_reg(pos),
                             control & ~PCI_MSIX_FLAGS_ENABLE);
            return -ENOMEM;
        }
        ASSERT(msi);
    }

    /* Locate MSI-X table region */
    table_offset = pci_conf_read32(dev->sbdf, msix_table_offset_reg(pos));
    if ( !msix->used_entries &&
         (!msi ||
          (is_hardware_domain(current->domain) &&
           (dev->domain == current->domain || dev->domain == dom_io))) )
    {
        unsigned int bir = table_offset & PCI_MSIX_BIRMASK, pbus, pslot, pfunc;
        int vf;
        paddr_t pba_paddr;
        unsigned int pba_offset;

        if ( !dev->info.is_virtfn )
        {
            pbus = bus;
            pslot = slot;
            pfunc = func;
            vf = -1;
        }
        else
        {
            pbus = dev->info.physfn.bus;
            pslot = PCI_SLOT(dev->info.physfn.devfn);
            pfunc = PCI_FUNC(dev->info.physfn.devfn);
            vf = PCI_BDF2(dev->bus, dev->devfn);
        }

        table_paddr = read_pci_mem_bar(seg, pbus, pslot, pfunc, bir, vf);
        WARN_ON(msi && msi->table_base != table_paddr);
        if ( !table_paddr )
        {
            if ( !msi || !msi->table_base )
            {
                pci_conf_write16(dev->sbdf, msix_control_reg(pos),
                                 control & ~PCI_MSIX_FLAGS_ENABLE);
                xfree(entry);
                return -ENXIO;
            }
            table_paddr = msi->table_base;
        }
        table_paddr += table_offset & ~PCI_MSIX_BIRMASK;

        msix->table.first = PFN_DOWN(table_paddr);
        msix->table.last = PFN_DOWN(table_paddr +
                                    msix->nr_entries * PCI_MSIX_ENTRY_SIZE - 1);
        WARN_ON(rangeset_overlaps_range(mmio_ro_ranges, msix->table.first,
                                        msix->table.last));

        pba_offset = pci_conf_read32(dev->sbdf, msix_pba_offset_reg(pos));
        bir = (u8)(pba_offset & PCI_MSIX_BIRMASK);
        pba_paddr = read_pci_mem_bar(seg, pbus, pslot, pfunc, bir, vf);
        WARN_ON(!pba_paddr);
        pba_paddr += pba_offset & ~PCI_MSIX_BIRMASK;

        msix->pba.first = PFN_DOWN(pba_paddr);
        msix->pba.last = PFN_DOWN(pba_paddr +
                                  BITS_TO_LONGS(msix->nr_entries) - 1);
        WARN_ON(rangeset_overlaps_range(mmio_ro_ranges, msix->pba.first,
                                        msix->pba.last));

        zap_on_error = true;
    }
    else if ( !msix->table.first )
    {
        pci_conf_write16(dev->sbdf, msix_control_reg(pos), control);
        xfree(entry);
        return -ENODATA;
    }
    else
        table_paddr = (msix->table.first << PAGE_SHIFT) +
                      PAGE_OFFSET(table_offset & ~PCI_MSIX_BIRMASK);

    if ( entry )
    {
        /* Map MSI-X table region */
        u64 entry_paddr = table_paddr + msi->entry_nr * PCI_MSIX_ENTRY_SIZE;
        int idx = msix_get_fixmap(msix, table_paddr, entry_paddr);
        void __iomem *base;

        if ( idx < 0 )
        {
            if ( zap_on_error )
            {
                msix->table.first = 0;
                msix->pba.first = 0;

                control &= ~PCI_MSIX_FLAGS_ENABLE;
            }

            pci_conf_write16(dev->sbdf, msix_control_reg(pos), control);
            xfree(entry);
            return idx;
        }
        base = fix_to_virt(idx) + (entry_paddr & (PAGE_SIZE - 1));

        /* Mask interrupt here */
        writel(1, base + PCI_MSIX_ENTRY_VECTOR_CTRL_OFFSET);

        entry->msi_attrib.type = PCI_CAP_ID_MSIX;
        entry->msi_attrib.is_64 = 1;
        entry->msi_attrib.entry_nr = msi->entry_nr;
        entry->msi_attrib.maskbit = 1;
        entry->msi_attrib.host_masked = 1;
        entry->msi_attrib.guest_masked = 1;
        entry->msi_attrib.pos = pos;
        entry->irq = msi->irq;
        entry->dev = dev;
        entry->mask_base = base;

        list_add_tail(&entry->list, &dev->msi_list);
        *desc = entry;
    }

    if ( !msix->used_entries )
    {
        maskall = false;
        if ( !msix->guest_maskall )
            control &= ~PCI_MSIX_FLAGS_MASKALL;
        else
            control |= PCI_MSIX_FLAGS_MASKALL;

        if ( rangeset_add_range(mmio_ro_ranges, msix->table.first,
                                msix->table.last) )
            WARN();
        if ( rangeset_add_range(mmio_ro_ranges, msix->pba.first,
                                msix->pba.last) )
            WARN();

        if ( desc )
        {
            struct domain *currd = current->domain;
            struct domain *d = dev->domain ?: currd;

            if ( !is_hardware_domain(currd) || d != currd )
                printk(""%s use of MSI-X on %pp by %pd\n"",
                       is_hardware_domain(currd)
                       ? XENLOG_WARNING ""Potentially insecure""
                       : XENLOG_ERR ""Insecure"",
                       &dev->sbdf, d);
            if ( !is_hardware_domain(d) &&
                 /* Assume a domain without memory has no mappings yet. */
                 (!is_hardware_domain(currd) || domain_tot_pages(d)) )
                domain_crash(d);
            /* XXX How to deal with existing mappings? */
        }
    }
    WARN_ON(msix->table.first != (table_paddr >> PAGE_SHIFT));
    ++msix->used_entries;

    /* Restore MSI-X enabled bits */
    if ( !hardware_domain )
    {
        /*
         * ..., except for internal requests (before Dom0 starts), in which
         * case we rather need to behave ""normally"", i.e. not follow the split
         * brain model where Dom0 actually enables MSI (and disables INTx).
         */
        pci_intx(dev, false);
        control |= PCI_MSIX_FLAGS_ENABLE;
        control &= ~PCI_MSIX_FLAGS_MASKALL;
        maskall = 0;
    }
    msix->host_maskall = maskall;
    pci_conf_write16(dev->sbdf, msix_control_reg(pos), control);

    return 0;
}","static int msix_capability_init(struct pci_dev *VAR_0,
                                struct msi_info *VAR_1,
                                struct msi_desc **VAR_2)
{
    struct arch_msix *VAR_3 = VAR_0->msix;
    struct msi_desc *VAR_4 = NULL;
    u16 VAR_5;
    u64 VAR_6;
    u32 VAR_7;
    u16 VAR_8 = VAR_0->seg;
    u8 VAR_9 = VAR_0->bus;
    u8 VAR_10 = PCI_SLOT(VAR_0->devfn);
    u8 VAR_11 = PCI_FUNC(VAR_0->devfn);
    bool VAR_12 = VAR_3->host_maskall, VAR_13 = false;
    unsigned int VAR_14 = pci_find_cap_offset(VAR_8, VAR_9, VAR_10, VAR_11,
                                           VAR_15);

    if ( !VAR_14 )
        return -VAR_16;

    ASSERT(pcidevs_locked());

    VAR_5 = pci_conf_read16(VAR_0->sbdf, msix_control_reg(VAR_14));
    /* COMMENT_0 */
                                                                            
                                                                           
                                                                             
                    
       
    VAR_3->host_maskall = 1;
    pci_conf_write16(VAR_0->sbdf, msix_control_reg(VAR_14),
                     VAR_5 | (VAR_17 |
                                VAR_18));

    if ( unlikely(!memory_decoded(VAR_0)) )
    {
        pci_conf_write16(VAR_0->sbdf, msix_control_reg(VAR_14),
                         VAR_5 & ~VAR_17);
        return -VAR_19;
    }

    if ( VAR_2 )
    {
        VAR_4 = alloc_msi_entry(1);
        if ( !VAR_4 )
        {
            pci_conf_write16(VAR_0->sbdf, msix_control_reg(VAR_14),
                             VAR_5 & ~VAR_17);
            return -VAR_20;
        }
        ASSERT(VAR_1);
    }

    /* COMMENT_6 */
    VAR_7 = pci_conf_read32(VAR_0->sbdf, msix_table_offset_reg(VAR_14));
    if ( !VAR_3->used_entries &&
         (!VAR_1 ||
          (is_hardware_domain(VAR_21->domain) &&
           (VAR_0->domain == VAR_21->domain || VAR_0->domain == VAR_22))) )
    {
        unsigned int VAR_23 = VAR_7 & VAR_24, VAR_25, VAR_26, VAR_27;
        int VAR_28;
        paddr_t VAR_29;
        unsigned int VAR_30;

        if ( !VAR_0->info.is_virtfn )
        {
            VAR_25 = VAR_9;
            VAR_26 = VAR_10;
            VAR_27 = VAR_11;
            VAR_28 = -1;
        }
        else
        {
            VAR_25 = VAR_0->info.physfn.bus;
            VAR_26 = PCI_SLOT(VAR_0->info.physfn.devfn);
            VAR_27 = PCI_FUNC(VAR_0->info.physfn.devfn);
            VAR_28 = PCI_BDF2(VAR_0->bus, VAR_0->devfn);
        }

        VAR_6 = read_pci_mem_bar(VAR_8, VAR_25, VAR_26, VAR_27, VAR_23, VAR_28);
        WARN_ON(VAR_1 && VAR_1->table_base != VAR_6);
        if ( !VAR_6 )
        {
            if ( !VAR_1 || !VAR_1->table_base )
            {
                pci_conf_write16(VAR_0->sbdf, msix_control_reg(VAR_14),
                                 VAR_5 & ~VAR_17);
                xfree(VAR_4);
                return -VAR_19;
            }
            VAR_6 = VAR_1->table_base;
        }
        VAR_6 += VAR_7 & ~VAR_24;

        VAR_3->table.first = PFN_DOWN(VAR_6);
        VAR_3->table.last = PFN_DOWN(VAR_6 +
                                    VAR_3->nr_entries * VAR_31 - 1);
        WARN_ON(rangeset_overlaps_range(VAR_32, VAR_3->table.first,
                                        VAR_3->table.last));

        VAR_30 = pci_conf_read32(VAR_0->sbdf, msix_pba_offset_reg(VAR_14));
        VAR_23 = (u8)(VAR_30 & VAR_24);
        VAR_29 = read_pci_mem_bar(VAR_8, VAR_25, VAR_26, VAR_27, VAR_23, VAR_28);
        WARN_ON(!VAR_29);
        VAR_29 += VAR_30 & ~VAR_24;

        VAR_3->pba.first = PFN_DOWN(VAR_29);
        VAR_3->pba.last = PFN_DOWN(VAR_29 +
                                  BITS_TO_LONGS(VAR_3->nr_entries) - 1);
        WARN_ON(rangeset_overlaps_range(VAR_32, VAR_3->pba.first,
                                        VAR_3->pba.last));

        VAR_13 = true;
    }
    else if ( !VAR_3->table.first )
    {
        pci_conf_write16(VAR_0->sbdf, msix_control_reg(VAR_14), VAR_5);
        xfree(VAR_4);
        return -VAR_33;
    }
    else
        VAR_6 = (VAR_3->table.first << VAR_34) +
                      PAGE_OFFSET(VAR_7 & ~VAR_24);

    if ( VAR_4 )
    {
        /* COMMENT_7 */
        u64 VAR_35 = VAR_6 + VAR_1->entry_nr * VAR_31;
        int VAR_36 = msix_get_fixmap(VAR_3, VAR_6, VAR_35);
        void VAR_37 *VAR_38;

        if ( VAR_36 < 0 )
        {
            if ( VAR_13 )
            {
                VAR_3->table.first = 0;
                VAR_3->pba.first = 0;

                VAR_5 &= ~VAR_17;
            }

            pci_conf_write16(VAR_0->sbdf, msix_control_reg(VAR_14), VAR_5);
            xfree(VAR_4);
            return VAR_36;
        }
        VAR_38 = fix_to_virt(VAR_36) + (VAR_35 & (VAR_39 - 1));

        /* COMMENT_8 */
        writel(1, VAR_38 + VAR_40);

        VAR_4->msi_attrib.type = VAR_15;
        VAR_4->msi_attrib.is_64 = 1;
        VAR_4->msi_attrib.entry_nr = VAR_1->entry_nr;
        VAR_4->msi_attrib.maskbit = 1;
        VAR_4->msi_attrib.host_masked = 1;
        VAR_4->msi_attrib.guest_masked = 1;
        VAR_4->msi_attrib.pos = VAR_14;
        VAR_4->irq = VAR_1->irq;
        VAR_4->dev = VAR_0;
        VAR_4->mask_base = VAR_38;

        list_add_tail(&VAR_4->list, &VAR_0->msi_list);
        *VAR_2 = VAR_4;
    }

    if ( !VAR_3->used_entries )
    {
        VAR_12 = false;
        if ( !VAR_3->guest_maskall )
            VAR_5 &= ~VAR_18;
        else
            VAR_5 |= VAR_18;

        if ( rangeset_add_range(VAR_32, VAR_3->table.first,
                                VAR_3->table.last) )
            WARN();
        if ( rangeset_add_range(VAR_32, VAR_3->pba.first,
                                VAR_3->pba.last) )
            WARN();

        if ( VAR_2 )
        {
            struct domain *VAR_41 = VAR_21->domain;
            struct domain *VAR_42 = VAR_0->domain ?VAR_43: VAR_41;

            if ( !is_hardware_domain(VAR_41) || VAR_42 != VAR_41 )
                printk(""%s use of MSI-X on %pp by %pd\n"",
                       is_hardware_domain(VAR_41)
                       ? XENLOG_WARNING ""Potentially insecure""
                       : XENLOG_ERR ""Insecure"",
                       &VAR_0->sbdf, VAR_42);
            if ( !is_hardware_domain(VAR_42) &&
                 /* COMMENT_9 */
                 (!is_hardware_domain(VAR_41) || domain_tot_pages(VAR_42)) )
                domain_crash(VAR_42);
            /* COMMENT_10 */
        }
    }
    WARN_ON(VAR_3->table.first != (VAR_6 >> VAR_34));
    ++VAR_3->used_entries;

    /* COMMENT_11 */
    if ( !VAR_44 )
    {
        /* COMMENT_12 */
                                                                           
                                                                              
                                                                           
           
        pci_intx(VAR_0, false);
        VAR_5 |= VAR_17;
        VAR_5 &= ~VAR_18;
        VAR_12 = 0;
    }
    VAR_3->host_maskall = VAR_12;
    pci_conf_write16(VAR_0->sbdf, msix_control_reg(VAR_14), VAR_5);

    return 0;
}",xen-project/xen/beb54596cfdaf15f6a86d7b1bf84ca8a0b9c6b9b/msi.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -4,16 +4,14 @@
 {
     struct arch_msix *msix = dev->msix;
     struct msi_desc *entry = NULL;
-    int vf;
     u16 control;
     u64 table_paddr;
     u32 table_offset;
-    u8 bir, pbus, pslot, pfunc;
     u16 seg = dev->seg;
     u8 bus = dev->bus;
     u8 slot = PCI_SLOT(dev->devfn);
     u8 func = PCI_FUNC(dev->devfn);
-    bool maskall = msix->host_maskall;
+    bool maskall = msix->host_maskall, zap_on_error = false;
     unsigned int pos = pci_find_cap_offset(seg, bus, slot, func,
                                            PCI_CAP_ID_MSIX);
 
@@ -55,43 +53,45 @@
 
     /* Locate MSI-X table region */
     table_offset = pci_conf_read32(dev->sbdf, msix_table_offset_reg(pos));
-    bir = (u8)(table_offset & PCI_MSIX_BIRMASK);
-    table_offset &= ~PCI_MSIX_BIRMASK;
-
-    if ( !dev->info.is_virtfn )
-    {
-        pbus = bus;
-        pslot = slot;
-        pfunc = func;
-        vf = -1;
-    }
-    else
-    {
-        pbus = dev->info.physfn.bus;
-        pslot = PCI_SLOT(dev->info.physfn.devfn);
-        pfunc = PCI_FUNC(dev->info.physfn.devfn);
-        vf = PCI_BDF2(dev->bus, dev->devfn);
-    }
-
-    table_paddr = read_pci_mem_bar(seg, pbus, pslot, pfunc, bir, vf);
-    WARN_ON(msi && msi->table_base != table_paddr);
-    if ( !table_paddr )
-    {
-        if ( !msi || !msi->table_base )
-        {
-            pci_conf_write16(dev->sbdf, msix_control_reg(pos),
-                             control & ~PCI_MSIX_FLAGS_ENABLE);
-            xfree(entry);
-            return -ENXIO;
-        }
-        table_paddr = msi->table_base;
-    }
-    table_paddr += table_offset;
-
-    if ( !msix->used_entries )
-    {
-        u64 pba_paddr;
-        u32 pba_offset;
+    if ( !msix->used_entries &&
+         (!msi ||
+          (is_hardware_domain(current->domain) &&
+           (dev->domain == current->domain || dev->domain == dom_io))) )
+    {
+        unsigned int bir = table_offset & PCI_MSIX_BIRMASK, pbus, pslot, pfunc;
+        int vf;
+        paddr_t pba_paddr;
+        unsigned int pba_offset;
+
+        if ( !dev->info.is_virtfn )
+        {
+            pbus = bus;
+            pslot = slot;
+            pfunc = func;
+            vf = -1;
+        }
+        else
+        {
+            pbus = dev->info.physfn.bus;
+            pslot = PCI_SLOT(dev->info.physfn.devfn);
+            pfunc = PCI_FUNC(dev->info.physfn.devfn);
+            vf = PCI_BDF2(dev->bus, dev->devfn);
+        }
+
+        table_paddr = read_pci_mem_bar(seg, pbus, pslot, pfunc, bir, vf);
+        WARN_ON(msi && msi->table_base != table_paddr);
+        if ( !table_paddr )
+        {
+            if ( !msi || !msi->table_base )
+            {
+                pci_conf_write16(dev->sbdf, msix_control_reg(pos),
+                                 control & ~PCI_MSIX_FLAGS_ENABLE);
+                xfree(entry);
+                return -ENXIO;
+            }
+            table_paddr = msi->table_base;
+        }
+        table_paddr += table_offset & ~PCI_MSIX_BIRMASK;
 
         msix->table.first = PFN_DOWN(table_paddr);
         msix->table.last = PFN_DOWN(table_paddr +
@@ -110,7 +110,18 @@
                                   BITS_TO_LONGS(msix->nr_entries) - 1);
         WARN_ON(rangeset_overlaps_range(mmio_ro_ranges, msix->pba.first,
                                         msix->pba.last));
-    }
+
+        zap_on_error = true;
+    }
+    else if ( !msix->table.first )
+    {
+        pci_conf_write16(dev->sbdf, msix_control_reg(pos), control);
+        xfree(entry);
+        return -ENODATA;
+    }
+    else
+        table_paddr = (msix->table.first << PAGE_SHIFT) +
+                      PAGE_OFFSET(table_offset & ~PCI_MSIX_BIRMASK);
 
     if ( entry )
     {
@@ -121,8 +132,15 @@
 
         if ( idx < 0 )
         {
-            pci_conf_write16(dev->sbdf, msix_control_reg(pos),
-                             control & ~PCI_MSIX_FLAGS_ENABLE);
+            if ( zap_on_error )
+            {
+                msix->table.first = 0;
+                msix->pba.first = 0;
+
+                control &= ~PCI_MSIX_FLAGS_ENABLE;
+            }
+
+            pci_conf_write16(dev->sbdf, msix_control_reg(pos), control);
             xfree(entry);
             return idx;
         }","{'deleted_lines': ['    int vf;', '    u8 bir, pbus, pslot, pfunc;', '    bool maskall = msix->host_maskall;', '    bir = (u8)(table_offset & PCI_MSIX_BIRMASK);', '    table_offset &= ~PCI_MSIX_BIRMASK;', '', '    if ( !dev->info.is_virtfn )', '    {', '        pbus = bus;', '        pslot = slot;', '        pfunc = func;', '        vf = -1;', '    }', '    else', '    {', '        pbus = dev->info.physfn.bus;', '        pslot = PCI_SLOT(dev->info.physfn.devfn);', '        pfunc = PCI_FUNC(dev->info.physfn.devfn);', '        vf = PCI_BDF2(dev->bus, dev->devfn);', '    }', '', '    table_paddr = read_pci_mem_bar(seg, pbus, pslot, pfunc, bir, vf);', '    WARN_ON(msi && msi->table_base != table_paddr);', '    if ( !table_paddr )', '    {', '        if ( !msi || !msi->table_base )', '        {', '            pci_conf_write16(dev->sbdf, msix_control_reg(pos),', '                             control & ~PCI_MSIX_FLAGS_ENABLE);', '            xfree(entry);', '            return -ENXIO;', '        }', '        table_paddr = msi->table_base;', '    }', '    table_paddr += table_offset;', '', '    if ( !msix->used_entries )', '    {', '        u64 pba_paddr;', '        u32 pba_offset;', '    }', '            pci_conf_write16(dev->sbdf, msix_control_reg(pos),', '                             control & ~PCI_MSIX_FLAGS_ENABLE);'], 'added_lines': ['    bool maskall = msix->host_maskall, zap_on_error = false;', '    if ( !msix->used_entries &&', '         (!msi ||', '          (is_hardware_domain(current->domain) &&', '           (dev->domain == current->domain || dev->domain == dom_io))) )', '    {', '        unsigned int bir = table_offset & PCI_MSIX_BIRMASK, pbus, pslot, pfunc;', '        int vf;', '        paddr_t pba_paddr;', '        unsigned int pba_offset;', '', '        if ( !dev->info.is_virtfn )', '        {', '            pbus = bus;', '            pslot = slot;', '            pfunc = func;', '            vf = -1;', '        }', '        else', '        {', '            pbus = dev->info.physfn.bus;', '            pslot = PCI_SLOT(dev->info.physfn.devfn);', '            pfunc = PCI_FUNC(dev->info.physfn.devfn);', '            vf = PCI_BDF2(dev->bus, dev->devfn);', '        }', '', '        table_paddr = read_pci_mem_bar(seg, pbus, pslot, pfunc, bir, vf);', '        WARN_ON(msi && msi->table_base != table_paddr);', '        if ( !table_paddr )', '        {', '            if ( !msi || !msi->table_base )', '            {', '                pci_conf_write16(dev->sbdf, msix_control_reg(pos),', '                                 control & ~PCI_MSIX_FLAGS_ENABLE);', '                xfree(entry);', '                return -ENXIO;', '            }', '            table_paddr = msi->table_base;', '        }', '        table_paddr += table_offset & ~PCI_MSIX_BIRMASK;', '', '        zap_on_error = true;', '    }', '    else if ( !msix->table.first )', '    {', '        pci_conf_write16(dev->sbdf, msix_control_reg(pos), control);', '        xfree(entry);', '        return -ENODATA;', '    }', '    else', '        table_paddr = (msix->table.first << PAGE_SHIFT) +', '                      PAGE_OFFSET(table_offset & ~PCI_MSIX_BIRMASK);', '            if ( zap_on_error )', '            {', '                msix->table.first = 0;', '                msix->pba.first = 0;', '', '                control &= ~PCI_MSIX_FLAGS_ENABLE;', '            }', '', '            pci_conf_write16(dev->sbdf, msix_control_reg(pos), control);']}",True,"An issue was discovered in Xen through 4.14.x. The PCI passthrough code improperly uses register data. Code paths in Xen's MSI handling have been identified that act on unsanitized values read back from device hardware registers. While devices strictly compliant with PCI specifications shouldn't be able to affect these registers, experience shows that it's very common for devices to have out-of-spec ""backdoor"" operations that can affect the result of these reads. A not fully trusted guest may be able to crash Xen, leading to a Denial of Service (DoS) for the entire system. Privilege escalation and information leaks cannot be excluded. All versions of Xen supporting PCI passthrough are affected. Only x86 systems are vulnerable. Arm systems are not vulnerable. Only guests with passed through PCI devices may be able to leverage the vulnerability. Only systems passing through devices with out-of-spec (""backdoor"") functionality can cause issues. Experience shows that such out-of-spec functionality is common; unless you have reason to believe that your device does not have such functionality, it's better to assume that it does.",7.8,HIGH,2,valid,2020-09-22T13:48:26Z,3
CVE-2020-25595,['CWE-269'],AV:L/AC:L/Au:N/C:P/I:P/A:C,0,xen-project/xen,"x86/MSI-X: restrict reading of table/PBA bases from BARs

When assigned to less trusted or un-trusted guests, devices may change
state behind our backs (they may e.g. get reset by means we may not know
about). Therefore we should avoid reading BARs from hardware once a
device is no longer owned by Dom0. Furthermore when we can't read a BAR,
or when we read zero, we shouldn't instead use the caller provided
address unless that caller can be trusted.

Re-arrange the logic in msix_capability_init() such that only Dom0 (and
only if the device isn't DomU-owned yet) or calls through
PHYSDEVOP_prepare_msix will actually result in the reading of the
respective BAR register(s). Additionally do so only as long as in-use
table entries are known (note that invocation of PHYSDEVOP_prepare_msix
counts as a ""pseudo"" entry). In all other uses the value already
recorded will get used instead.

Clear the recorded values in _pci_cleanup_msix() as well as on the one
affected error path. (Adjust this error path to also avoid blindly
disabling MSI-X when it was enabled on entry to the function.)

While moving around variable declarations (in many cases to reduce their
scopes), also adjust some of their types.

This is part of XSA-337.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Roger Pau Monn <roger.pau@citrix.com>",beb54596cfdaf15f6a86d7b1bf84ca8a0b9c6b9b,https://github.com/xen-project/xen/commit/beb54596cfdaf15f6a86d7b1bf84ca8a0b9c6b9b,xen/arch/x86/msi.c,_pci_cleanup_msix,"static void _pci_cleanup_msix(struct arch_msix *msix)
{
if ( !--msix->used_entries )
{
if ( rangeset_remove_range(mmio_ro_ranges, msix->table.first,
msix->table.last) )
WARN();
if ( rangeset_remove_range(mmio_ro_ranges, msix->pba.first,
msix->pba.last) )
WARN();
}
}","static void _pci_cleanup_msix(struct arch_msix *VAR_0)
{
if ( !--VAR_0->used_entries )
{
if ( rangeset_remove_range(VAR_1, VAR_0->table.first,
VAR_0->table.last) )
WARN();
if ( rangeset_remove_range(VAR_1, VAR_0->pba.first,
VAR_0->pba.last) )
WARN();
}
}",xen-project/xen/beb54596cfdaf15f6a86d7b1bf84ca8a0b9c6b9b/msi.c/vul/before/0.json,"static void _pci_cleanup_msix(struct arch_msix *msix)
{
    if ( !--msix->used_entries )
    {
        if ( rangeset_remove_range(mmio_ro_ranges, msix->table.first,
                                   msix->table.last) )
            WARN();
        msix->table.first = 0;
        msix->table.last = 0;

        if ( rangeset_remove_range(mmio_ro_ranges, msix->pba.first,
                                   msix->pba.last) )
            WARN();
        msix->pba.first = 0;
        msix->pba.last = 0;
    }
}","static void _pci_cleanup_msix(struct arch_msix *VAR_0)
{
    if ( !--VAR_0->used_entries )
    {
        if ( rangeset_remove_range(VAR_1, VAR_0->table.first,
                                   VAR_0->table.last) )
            WARN();
        VAR_0->table.first = 0;
        VAR_0->table.last = 0;

        if ( rangeset_remove_range(VAR_1, VAR_0->pba.first,
                                   VAR_0->pba.last) )
            WARN();
        VAR_0->pba.first = 0;
        VAR_0->pba.last = 0;
    }
}",xen-project/xen/beb54596cfdaf15f6a86d7b1bf84ca8a0b9c6b9b/msi.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,8 +5,13 @@
         if ( rangeset_remove_range(mmio_ro_ranges, msix->table.first,
                                    msix->table.last) )
             WARN();
+        msix->table.first = 0;
+        msix->table.last = 0;
+
         if ( rangeset_remove_range(mmio_ro_ranges, msix->pba.first,
                                    msix->pba.last) )
             WARN();
+        msix->pba.first = 0;
+        msix->pba.last = 0;
     }
 }","{'deleted_lines': [], 'added_lines': ['        msix->table.first = 0;', '        msix->table.last = 0;', '', '        msix->pba.first = 0;', '        msix->pba.last = 0;']}",True,"An issue was discovered in Xen through 4.14.x. The PCI passthrough code improperly uses register data. Code paths in Xen's MSI handling have been identified that act on unsanitized values read back from device hardware registers. While devices strictly compliant with PCI specifications shouldn't be able to affect these registers, experience shows that it's very common for devices to have out-of-spec ""backdoor"" operations that can affect the result of these reads. A not fully trusted guest may be able to crash Xen, leading to a Denial of Service (DoS) for the entire system. Privilege escalation and information leaks cannot be excluded. All versions of Xen supporting PCI passthrough are affected. Only x86 systems are vulnerable. Arm systems are not vulnerable. Only guests with passed through PCI devices may be able to leverage the vulnerability. Only systems passing through devices with out-of-spec (""backdoor"") functionality can cause issues. Experience shows that such out-of-spec functionality is common; unless you have reason to believe that your device does not have such functionality, it's better to assume that it does.",7.8,HIGH,2,valid,2020-09-22T13:48:26Z,3
CVE-2020-25601,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,xen-project/xen,"evtchn: arrange for preemption in evtchn_destroy()

Especially closing of fully established interdomain channels can take
quite some time, due to the locking involved. Therefore we shouldn't
assume we can clean up still active ports all in one go. Besides adding
the necessary preemption check, also avoid pointlessly starting from
(or now really ending at) 0; 1 is the lowest numbered port which may
need closing.

Since we're now reducing ->valid_evtchns, free_xen_event_channel(),
and (at least to be on the safe side) notify_via_xen_event_channel()
need to cope with attempts to close / unbind from / send through already
closed (and no longer valid, as per port_is_valid()) ports.

This is part of XSA-344.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Acked-by: Julien Grall <jgrall@amazon.com>
Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>",8fe7b5f9960f4d9ec46787af394d180c39c6b2db,https://github.com/xen-project/xen/commit/8fe7b5f9960f4d9ec46787af394d180c39c6b2db,xen/common/domain.c,domain_kill,"int domain_kill(struct domain *d)
{
int rc = 0;
struct vcpu *v;
if ( d == current->domain )
return -EINVAL;
switch ( d->is_dying )
{
case DOMDYING_alive:
domain_unlock(d);
domain_pause(d);
domain_lock(d);
if ( d->is_dying != DOMDYING_alive )
return domain_kill(d);
d->is_dying = DOMDYING_dying;
argo_destroy(d);
evtchn_destroy(d);
gnttab_release_mappings(d);
vnuma_destroy(d->vnuma);
domain_set_outstanding_pages(d, 0);
case DOMDYING_dying:
rc = domain_relinquish_resources(d);
if ( rc != 0 )
break;
if ( cpupool_move_domain(d, cpupool0) )
return -ERESTART;
for_each_vcpu ( d, v )
unmap_vcpu_info(v);
d->is_dying = DOMDYING_dead;
vm_event_cleanup(d);
put_domain(d);
send_global_virq(VIRQ_DOM_EXC);
case DOMDYING_dead:
break;
}
return rc;
}","int domain_kill(struct domain *VAR_0)
{
int VAR_1 = 0;
struct vcpu *VAR_2;
if ( VAR_0 == VAR_3->domain )
return -VAR_4;
switch ( VAR_0->is_dying )
{
case VAR_5:
domain_unlock(VAR_0);
domain_pause(VAR_0);
domain_lock(VAR_0);
if ( VAR_0->is_dying != VAR_5 )
return domain_kill(VAR_0);
VAR_0->is_dying = VAR_6;
argo_destroy(VAR_0);
evtchn_destroy(VAR_0);
gnttab_release_mappings(VAR_0);
vnuma_destroy(VAR_0->vnuma);
domain_set_outstanding_pages(VAR_0, 0);
case VAR_6:
VAR_1 = domain_relinquish_resources(VAR_0);
if ( VAR_1 != 0 )
break;
if ( cpupool_move_domain(VAR_0, VAR_7) )
return -VAR_8;
for_each_vcpu ( VAR_0, VAR_2 )
unmap_vcpu_info(VAR_2);
VAR_0->is_dying = VAR_9;
vm_event_cleanup(VAR_0);
put_domain(VAR_0);
send_global_virq(VAR_10);
case VAR_9:
break;
}
return VAR_1;
}",xen-project/xen/8fe7b5f9960f4d9ec46787af394d180c39c6b2db/domain.c/vul/before/0.json,"int domain_kill(struct domain *d)
{
    int rc = 0;
    struct vcpu *v;

    if ( d == current->domain )
        return -EINVAL;

    /* Protected by d->domain_lock. */
    switch ( d->is_dying )
    {
    case DOMDYING_alive:
        domain_unlock(d);
        domain_pause(d);
        domain_lock(d);
        /*
         * With the domain lock dropped, d->is_dying may have changed. Call
         * ourselves recursively if so, which is safe as then we won't come
         * back here.
         */
        if ( d->is_dying != DOMDYING_alive )
            return domain_kill(d);
        d->is_dying = DOMDYING_dying;
        argo_destroy(d);
        gnttab_release_mappings(d);
        vnuma_destroy(d->vnuma);
        domain_set_outstanding_pages(d, 0);
        /* fallthrough */
    case DOMDYING_dying:
        rc = evtchn_destroy(d);
        if ( rc )
            break;
        rc = domain_relinquish_resources(d);
        if ( rc != 0 )
            break;
        if ( cpupool_move_domain(d, cpupool0) )
            return -ERESTART;
        for_each_vcpu ( d, v )
            unmap_vcpu_info(v);
        d->is_dying = DOMDYING_dead;
        /* Mem event cleanup has to go here because the rings 
         * have to be put before we call put_domain. */
        vm_event_cleanup(d);
        put_domain(d);
        send_global_virq(VIRQ_DOM_EXC);
        /* fallthrough */
    case DOMDYING_dead:
        break;
    }

    return rc;
}","int domain_kill(struct domain *VAR_0)
{
    int VAR_1 = 0;
    struct vcpu *VAR_2;

    if ( VAR_0 == VAR_3->domain )
        return -VAR_4;

    /* COMMENT_0 */
    switch ( VAR_0->is_dying )
    {
    case VAR_5:
        domain_unlock(VAR_0);
        domain_pause(VAR_0);
        domain_lock(VAR_0);
        /* COMMENT_1 */
                                                                           
                                                                           
                     
           
        if ( VAR_0->is_dying != VAR_5 )
            return domain_kill(VAR_0);
        VAR_0->is_dying = VAR_6;
        argo_destroy(VAR_0);
        gnttab_release_mappings(VAR_0);
        vnuma_destroy(VAR_0->vnuma);
        domain_set_outstanding_pages(VAR_0, 0);
        /* COMMENT_6 */
    case VAR_6:
        VAR_1 = evtchn_destroy(VAR_0);
        if ( VAR_1 )
            break;
        VAR_1 = domain_relinquish_resources(VAR_0);
        if ( VAR_1 != 0 )
            break;
        if ( cpupool_move_domain(VAR_0, VAR_7) )
            return -VAR_8;
        for_each_vcpu ( VAR_0, VAR_2 )
            unmap_vcpu_info(VAR_2);
        VAR_0->is_dying = VAR_9;
        /* COMMENT_7 */
                                                       
        vm_event_cleanup(VAR_0);
        put_domain(VAR_0);
        send_global_virq(VAR_10);
        /* COMMENT_6 */
    case VAR_9:
        break;
    }

    return VAR_1;
}",xen-project/xen/8fe7b5f9960f4d9ec46787af394d180c39c6b2db/domain.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -22,12 +22,14 @@
             return domain_kill(d);
         d->is_dying = DOMDYING_dying;
         argo_destroy(d);
-        evtchn_destroy(d);
         gnttab_release_mappings(d);
         vnuma_destroy(d->vnuma);
         domain_set_outstanding_pages(d, 0);
         /* fallthrough */
     case DOMDYING_dying:
+        rc = evtchn_destroy(d);
+        if ( rc )
+            break;
         rc = domain_relinquish_resources(d);
         if ( rc != 0 )
             break;","{'deleted_lines': ['        evtchn_destroy(d);'], 'added_lines': ['        rc = evtchn_destroy(d);', '        if ( rc )', '            break;']}",True,"An issue was discovered in Xen through 4.14.x. There is a lack of preemption in evtchn_reset() / evtchn_destroy(). In particular, the FIFO event channel model allows guests to have a large number of event channels active at a time. Closing all of these (when resetting all event channels or when cleaning up after the guest) may take extended periods of time. So far, there was no arrangement for preemption at suitable intervals, allowing a CPU to spend an almost unbounded amount of time in the processing of these operations. Malicious or buggy guest kernels can mount a Denial of Service (DoS) attack affecting the entire system. All Xen versions are vulnerable in principle. Whether versions 4.3 and older are vulnerable depends on underlying hardware characteristics.",5.5,MEDIUM,1,valid,2020-09-22T13:52:36Z,3
CVE-2020-25601,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,xen-project/xen,"evtchn: arrange for preemption in evtchn_destroy()

Especially closing of fully established interdomain channels can take
quite some time, due to the locking involved. Therefore we shouldn't
assume we can clean up still active ports all in one go. Besides adding
the necessary preemption check, also avoid pointlessly starting from
(or now really ending at) 0; 1 is the lowest numbered port which may
need closing.

Since we're now reducing ->valid_evtchns, free_xen_event_channel(),
and (at least to be on the safe side) notify_via_xen_event_channel()
need to cope with attempts to close / unbind from / send through already
closed (and no longer valid, as per port_is_valid()) ports.

This is part of XSA-344.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Acked-by: Julien Grall <jgrall@amazon.com>
Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>",8fe7b5f9960f4d9ec46787af394d180c39c6b2db,https://github.com/xen-project/xen/commit/8fe7b5f9960f4d9ec46787af394d180c39c6b2db,xen/common/event_channel.c,free_xen_event_channel,"void free_xen_event_channel(struct domain *d, int port)
{
BUG_ON(!port_is_valid(d, port));
evtchn_close(d, port, 0);
}","void free_xen_event_channel(struct domain *VAR_0, int VAR_1)
{
BUG_ON(!port_is_valid(VAR_0, VAR_1));
evtchn_close(VAR_0, VAR_1, 0);
}",xen-project/xen/8fe7b5f9960f4d9ec46787af394d180c39c6b2db/event_channel.c/vul/before/0.json,"void free_xen_event_channel(struct domain *d, int port)
{
    if ( !port_is_valid(d, port) )
    {
        /*
         * Make sure ->is_dying is read /after/ ->valid_evtchns, pairing
         * with the spin_barrier() and BUG_ON() in evtchn_destroy().
         */
        smp_rmb();
        BUG_ON(!d->is_dying);
        return;
    }

    evtchn_close(d, port, 0);
}","void free_xen_event_channel(struct domain *VAR_0, int VAR_1)
{
    if ( !port_is_valid(VAR_0, VAR_1) )
    {
        /* COMMENT_0 */
                                                                        
                                                                    
           
        smp_rmb();
        BUG_ON(!VAR_0->is_dying);
        return;
    }

    evtchn_close(VAR_0, VAR_1, 0);
}",xen-project/xen/8fe7b5f9960f4d9ec46787af394d180c39c6b2db/event_channel.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,15 @@
 void free_xen_event_channel(struct domain *d, int port)
 {
-    BUG_ON(!port_is_valid(d, port));
+    if ( !port_is_valid(d, port) )
+    {
+        /*
+         * Make sure ->is_dying is read /after/ ->valid_evtchns, pairing
+         * with the spin_barrier() and BUG_ON() in evtchn_destroy().
+         */
+        smp_rmb();
+        BUG_ON(!d->is_dying);
+        return;
+    }
 
     evtchn_close(d, port, 0);
 }","{'deleted_lines': ['    BUG_ON(!port_is_valid(d, port));'], 'added_lines': ['    if ( !port_is_valid(d, port) )', '    {', '        /*', '         * Make sure ->is_dying is read /after/ ->valid_evtchns, pairing', '         * with the spin_barrier() and BUG_ON() in evtchn_destroy().', '         */', '        smp_rmb();', '        BUG_ON(!d->is_dying);', '        return;', '    }']}",True,"An issue was discovered in Xen through 4.14.x. There is a lack of preemption in evtchn_reset() / evtchn_destroy(). In particular, the FIFO event channel model allows guests to have a large number of event channels active at a time. Closing all of these (when resetting all event channels or when cleaning up after the guest) may take extended periods of time. So far, there was no arrangement for preemption at suitable intervals, allowing a CPU to spend an almost unbounded amount of time in the processing of these operations. Malicious or buggy guest kernels can mount a Denial of Service (DoS) attack affecting the entire system. All Xen versions are vulnerable in principle. Whether versions 4.3 and older are vulnerable depends on underlying hardware characteristics.",5.5,MEDIUM,1,valid,2020-09-22T13:52:36Z,3
CVE-2020-25601,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,xen-project/xen,"evtchn: arrange for preemption in evtchn_destroy()

Especially closing of fully established interdomain channels can take
quite some time, due to the locking involved. Therefore we shouldn't
assume we can clean up still active ports all in one go. Besides adding
the necessary preemption check, also avoid pointlessly starting from
(or now really ending at) 0; 1 is the lowest numbered port which may
need closing.

Since we're now reducing ->valid_evtchns, free_xen_event_channel(),
and (at least to be on the safe side) notify_via_xen_event_channel()
need to cope with attempts to close / unbind from / send through already
closed (and no longer valid, as per port_is_valid()) ports.

This is part of XSA-344.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Acked-by: Julien Grall <jgrall@amazon.com>
Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>",8fe7b5f9960f4d9ec46787af394d180c39c6b2db,https://github.com/xen-project/xen/commit/8fe7b5f9960f4d9ec46787af394d180c39c6b2db,xen/common/event_channel.c,evtchn_destroy,"void evtchn_destroy(struct domain *d)
{
unsigned int i;
BUG_ON(!d->is_dying);
spin_barrier(&d->event_lock);
for ( i = 0; port_is_valid(d, i); i++ )
evtchn_close(d, i, 0);
ASSERT(!d->active_evtchns);
clear_global_virq_handlers(d);
evtchn_fifo_destroy(d);
}","void evtchn_destroy(struct domain *VAR_0)
{
unsigned int VAR_1;
BUG_ON(!VAR_0->is_dying);
spin_barrier(&VAR_0->event_lock);
for ( VAR_1 = 0; port_is_valid(VAR_0, VAR_1); VAR_1++ )
evtchn_close(VAR_0, VAR_1, 0);
ASSERT(!VAR_0->active_evtchns);
clear_global_virq_handlers(VAR_0);
evtchn_fifo_destroy(VAR_0);
}",xen-project/xen/8fe7b5f9960f4d9ec46787af394d180c39c6b2db/event_channel.c/vul/before/1.json,"int evtchn_destroy(struct domain *d)
{
    unsigned int i;

    /* After this barrier no new event-channel allocations can occur. */
    BUG_ON(!d->is_dying);
    spin_barrier(&d->event_lock);

    /* Close all existing event channels. */
    for ( i = d->valid_evtchns; --i; )
    {
        evtchn_close(d, i, 0);

        /*
         * Avoid preempting when called from domain_create()'s error path,
         * and don't check too often (choice of frequency is arbitrary).
         */
        if ( i && !(i & 0x3f) && d->is_dying != DOMDYING_dead &&
             hypercall_preempt_check() )
        {
            write_atomic(&d->valid_evtchns, i);
            return -ERESTART;
        }
    }

    ASSERT(!d->active_evtchns);

    clear_global_virq_handlers(d);

    evtchn_fifo_destroy(d);

    return 0;
}","int evtchn_destroy(struct domain *VAR_0)
{
    unsigned int VAR_1;

    /* COMMENT_0 */
    BUG_ON(!VAR_0->is_dying);
    spin_barrier(&VAR_0->event_lock);

    /* COMMENT_1 */
    for ( VAR_1 = VAR_0->valid_evtchns; --VAR_1; )
    {
        evtchn_close(VAR_0, VAR_1, 0);

        /* COMMENT_2 */
                                                                          
                                                                        
           
        if ( VAR_1 && !(VAR_1 & 0x3f) && VAR_0->is_dying != VAR_2 &&
             hypercall_preempt_check() )
        {
            write_atomic(&VAR_0->valid_evtchns, VAR_1);
            return -VAR_3;
        }
    }

    ASSERT(!VAR_0->active_evtchns);

    clear_global_virq_handlers(VAR_0);

    evtchn_fifo_destroy(VAR_0);

    return 0;
}",xen-project/xen/8fe7b5f9960f4d9ec46787af394d180c39c6b2db/event_channel.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-void evtchn_destroy(struct domain *d)
+int evtchn_destroy(struct domain *d)
 {
     unsigned int i;
 
@@ -7,12 +7,27 @@
     spin_barrier(&d->event_lock);
 
     /* Close all existing event channels. */
-    for ( i = 0; port_is_valid(d, i); i++ )
+    for ( i = d->valid_evtchns; --i; )
+    {
         evtchn_close(d, i, 0);
+
+        /*
+         * Avoid preempting when called from domain_create()'s error path,
+         * and don't check too often (choice of frequency is arbitrary).
+         */
+        if ( i && !(i & 0x3f) && d->is_dying != DOMDYING_dead &&
+             hypercall_preempt_check() )
+        {
+            write_atomic(&d->valid_evtchns, i);
+            return -ERESTART;
+        }
+    }
 
     ASSERT(!d->active_evtchns);
 
     clear_global_virq_handlers(d);
 
     evtchn_fifo_destroy(d);
+
+    return 0;
 }","{'deleted_lines': ['void evtchn_destroy(struct domain *d)', '    for ( i = 0; port_is_valid(d, i); i++ )'], 'added_lines': ['int evtchn_destroy(struct domain *d)', '    for ( i = d->valid_evtchns; --i; )', '    {', '', '        /*', ""         * Avoid preempting when called from domain_create()'s error path,"", ""         * and don't check too often (choice of frequency is arbitrary)."", '         */', '        if ( i && !(i & 0x3f) && d->is_dying != DOMDYING_dead &&', '             hypercall_preempt_check() )', '        {', '            write_atomic(&d->valid_evtchns, i);', '            return -ERESTART;', '        }', '    }', '', '    return 0;']}",True,"An issue was discovered in Xen through 4.14.x. There is a lack of preemption in evtchn_reset() / evtchn_destroy(). In particular, the FIFO event channel model allows guests to have a large number of event channels active at a time. Closing all of these (when resetting all event channels or when cleaning up after the guest) may take extended periods of time. So far, there was no arrangement for preemption at suitable intervals, allowing a CPU to spend an almost unbounded amount of time in the processing of these operations. Malicious or buggy guest kernels can mount a Denial of Service (DoS) attack affecting the entire system. All Xen versions are vulnerable in principle. Whether versions 4.3 and older are vulnerable depends on underlying hardware characteristics.",5.5,MEDIUM,1,valid,2020-09-22T13:52:36Z,3
CVE-2020-25601,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,xen-project/xen,"evtchn: arrange for preemption in evtchn_destroy()

Especially closing of fully established interdomain channels can take
quite some time, due to the locking involved. Therefore we shouldn't
assume we can clean up still active ports all in one go. Besides adding
the necessary preemption check, also avoid pointlessly starting from
(or now really ending at) 0; 1 is the lowest numbered port which may
need closing.

Since we're now reducing ->valid_evtchns, free_xen_event_channel(),
and (at least to be on the safe side) notify_via_xen_event_channel()
need to cope with attempts to close / unbind from / send through already
closed (and no longer valid, as per port_is_valid()) ports.

This is part of XSA-344.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Acked-by: Julien Grall <jgrall@amazon.com>
Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>",8fe7b5f9960f4d9ec46787af394d180c39c6b2db,https://github.com/xen-project/xen/commit/8fe7b5f9960f4d9ec46787af394d180c39c6b2db,xen/common/event_channel.c,notify_via_xen_event_channel,"void notify_via_xen_event_channel(struct domain *ld, int lport)
{
struct evtchn *lchn, *rchn;
struct domain *rd;
unsigned long flags;
ASSERT(port_is_valid(ld, lport));
lchn = evtchn_from_port(ld, lport);
spin_lock_irqsave(&lchn->lock, flags);
if ( likely(lchn->state == ECS_INTERDOMAIN) )
{
ASSERT(consumer_is_xen(lchn));
rd    = lchn->u.interdomain.remote_dom;
rchn  = evtchn_from_port(rd, lchn->u.interdomain.remote_port);
evtchn_port_set_pending(rd, rchn->notify_vcpu_id, rchn);
}
spin_unlock_irqrestore(&lchn->lock, flags);
}","void notify_via_xen_event_channel(struct domain *VAR_0, int VAR_1)
{
struct evtchn *VAR_2, *VAR_3;
struct domain *VAR_4;
unsigned long VAR_5;
ASSERT(port_is_valid(VAR_0, VAR_1));
VAR_2 = evtchn_from_port(VAR_0, VAR_1);
spin_lock_irqsave(&VAR_2->lock, VAR_5);
if ( likely(VAR_2->state == VAR_6) )
{
ASSERT(consumer_is_xen(VAR_2));
VAR_4    = VAR_2->u.interdomain.remote_dom;
VAR_3  = evtchn_from_port(VAR_4, VAR_2->u.interdomain.remote_port);
evtchn_port_set_pending(VAR_4, VAR_3->notify_vcpu_id, VAR_3);
}
spin_unlock_irqrestore(&VAR_2->lock, VAR_5);
}",xen-project/xen/8fe7b5f9960f4d9ec46787af394d180c39c6b2db/event_channel.c/vul/before/2.json,"void notify_via_xen_event_channel(struct domain *ld, int lport)
{
    struct evtchn *lchn, *rchn;
    struct domain *rd;
    unsigned long flags;

    if ( !port_is_valid(ld, lport) )
    {
        /*
         * Make sure ->is_dying is read /after/ ->valid_evtchns, pairing
         * with the spin_barrier() and BUG_ON() in evtchn_destroy().
         */
        smp_rmb();
        ASSERT(ld->is_dying);
        return;
    }

    lchn = evtchn_from_port(ld, lport);

    spin_lock_irqsave(&lchn->lock, flags);

    if ( likely(lchn->state == ECS_INTERDOMAIN) )
    {
        ASSERT(consumer_is_xen(lchn));
        rd    = lchn->u.interdomain.remote_dom;
        rchn  = evtchn_from_port(rd, lchn->u.interdomain.remote_port);
        evtchn_port_set_pending(rd, rchn->notify_vcpu_id, rchn);
    }

    spin_unlock_irqrestore(&lchn->lock, flags);
}","void notify_via_xen_event_channel(struct domain *VAR_0, int VAR_1)
{
    struct evtchn *VAR_2, *VAR_3;
    struct domain *VAR_4;
    unsigned long VAR_5;

    if ( !port_is_valid(VAR_0, VAR_1) )
    {
        /* COMMENT_0 */
                                                                        
                                                                    
           
        smp_rmb();
        ASSERT(VAR_0->is_dying);
        return;
    }

    VAR_2 = evtchn_from_port(VAR_0, VAR_1);

    spin_lock_irqsave(&VAR_2->lock, VAR_5);

    if ( likely(VAR_2->state == VAR_6) )
    {
        ASSERT(consumer_is_xen(VAR_2));
        VAR_4    = VAR_2->u.interdomain.remote_dom;
        VAR_3  = evtchn_from_port(VAR_4, VAR_2->u.interdomain.remote_port);
        evtchn_port_set_pending(VAR_4, VAR_3->notify_vcpu_id, VAR_3);
    }

    spin_unlock_irqrestore(&VAR_2->lock, VAR_5);
}",xen-project/xen/8fe7b5f9960f4d9ec46787af394d180c39c6b2db/event_channel.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -4,7 +4,17 @@
     struct domain *rd;
     unsigned long flags;
 
-    ASSERT(port_is_valid(ld, lport));
+    if ( !port_is_valid(ld, lport) )
+    {
+        /*
+         * Make sure ->is_dying is read /after/ ->valid_evtchns, pairing
+         * with the spin_barrier() and BUG_ON() in evtchn_destroy().
+         */
+        smp_rmb();
+        ASSERT(ld->is_dying);
+        return;
+    }
+
     lchn = evtchn_from_port(ld, lport);
 
     spin_lock_irqsave(&lchn->lock, flags);","{'deleted_lines': ['    ASSERT(port_is_valid(ld, lport));'], 'added_lines': ['    if ( !port_is_valid(ld, lport) )', '    {', '        /*', '         * Make sure ->is_dying is read /after/ ->valid_evtchns, pairing', '         * with the spin_barrier() and BUG_ON() in evtchn_destroy().', '         */', '        smp_rmb();', '        ASSERT(ld->is_dying);', '        return;', '    }', '']}",True,"An issue was discovered in Xen through 4.14.x. There is a lack of preemption in evtchn_reset() / evtchn_destroy(). In particular, the FIFO event channel model allows guests to have a large number of event channels active at a time. Closing all of these (when resetting all event channels or when cleaning up after the guest) may take extended periods of time. So far, there was no arrangement for preemption at suitable intervals, allowing a CPU to spend an almost unbounded amount of time in the processing of these operations. Malicious or buggy guest kernels can mount a Denial of Service (DoS) attack affecting the entire system. All Xen versions are vulnerable in principle. Whether versions 4.3 and older are vulnerable depends on underlying hardware characteristics.",5.5,MEDIUM,1,valid,2020-09-22T13:52:36Z,3
CVE-2020-25601,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,xen-project/xen,"evtchn: arrange for preemption in evtchn_reset()

Like for evtchn_destroy() looping over all possible event channels to
close them can take a significant amount of time. Unlike done there, we
can't alter domain properties (i.e. d->valid_evtchns) here. Borrow, in a
lightweight form, the paging domctl continuation concept, redirecting
the continuations to different sub-ops. Just like there this is to be
able to allow for predictable overall results of the involved sub-ops:
Racing requests should either complete or be refused.

Note that a domain can't interfere with an already started (by a remote
domain) reset, due to being paused. It can prevent a remote reset from
happening by leaving a reset unfinished, but that's only going to affect
itself.

This is part of XSA-344.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Acked-by: Julien Grall <jgrall@amazon.com>
Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>",2785b2a9e04abc148e1c5259f4faee708ea356f4,https://github.com/xen-project/xen/commit/2785b2a9e04abc148e1c5259f4faee708ea356f4,xen/common/event_channel.c,do_event_channel_op,"long do_event_channel_op(int cmd, XEN_GUEST_HANDLE_PARAM(void) arg)
{
long rc;
switch ( cmd )
{
case EVTCHNOP_alloc_unbound: {
struct evtchn_alloc_unbound alloc_unbound;
if ( copy_from_guest(&alloc_unbound, arg, 1) != 0 )
return -EFAULT;
rc = evtchn_alloc_unbound(&alloc_unbound);
if ( !rc && __copy_to_guest(arg, &alloc_unbound, 1) )
rc = -EFAULT; 
break;
}
case EVTCHNOP_bind_interdomain: {
struct evtchn_bind_interdomain bind_interdomain;
if ( copy_from_guest(&bind_interdomain, arg, 1) != 0 )
return -EFAULT;
rc = evtchn_bind_interdomain(&bind_interdomain);
if ( !rc && __copy_to_guest(arg, &bind_interdomain, 1) )
rc = -EFAULT; 
break;
}
case EVTCHNOP_bind_virq: {
struct evtchn_bind_virq bind_virq;
if ( copy_from_guest(&bind_virq, arg, 1) != 0 )
return -EFAULT;
rc = evtchn_bind_virq(&bind_virq, 0);
if ( !rc && __copy_to_guest(arg, &bind_virq, 1) )
rc = -EFAULT; 
break;
}
case EVTCHNOP_bind_ipi: {
struct evtchn_bind_ipi bind_ipi;
if ( copy_from_guest(&bind_ipi, arg, 1) != 0 )
return -EFAULT;
rc = evtchn_bind_ipi(&bind_ipi);
if ( !rc && __copy_to_guest(arg, &bind_ipi, 1) )
rc = -EFAULT; 
break;
}
case EVTCHNOP_bind_pirq: {
struct evtchn_bind_pirq bind_pirq;
if ( copy_from_guest(&bind_pirq, arg, 1) != 0 )
return -EFAULT;
rc = evtchn_bind_pirq(&bind_pirq);
if ( !rc && __copy_to_guest(arg, &bind_pirq, 1) )
rc = -EFAULT; 
break;
}
case EVTCHNOP_close: {
struct evtchn_close close;
if ( copy_from_guest(&close, arg, 1) != 0 )
return -EFAULT;
rc = evtchn_close(current->domain, close.port, 1);
break;
}
case EVTCHNOP_send: {
struct evtchn_send send;
if ( copy_from_guest(&send, arg, 1) != 0 )
return -EFAULT;
rc = evtchn_send(current->domain, send.port);
break;
}
case EVTCHNOP_status: {
struct evtchn_status status;
if ( copy_from_guest(&status, arg, 1) != 0 )
return -EFAULT;
rc = evtchn_status(&status);
if ( !rc && __copy_to_guest(arg, &status, 1) )
rc = -EFAULT;
break;
}
case EVTCHNOP_bind_vcpu: {
struct evtchn_bind_vcpu bind_vcpu;
if ( copy_from_guest(&bind_vcpu, arg, 1) != 0 )
return -EFAULT;
rc = evtchn_bind_vcpu(bind_vcpu.port, bind_vcpu.vcpu);
break;
}
case EVTCHNOP_unmask: {
struct evtchn_unmask unmask;
if ( copy_from_guest(&unmask, arg, 1) != 0 )
return -EFAULT;
rc = evtchn_unmask(unmask.port);
break;
}
case EVTCHNOP_reset: {
struct evtchn_reset reset;
struct domain *d;
if ( copy_from_guest(&reset, arg, 1) != 0 )
return -EFAULT;
d = rcu_lock_domain_by_any_id(reset.dom);
if ( d == NULL )
return -ESRCH;
rc = xsm_evtchn_reset(XSM_TARGET, current->domain, d);
if ( !rc )
rc = evtchn_reset(d);
rcu_unlock_domain(d);
break;
}
case EVTCHNOP_init_control: {
struct evtchn_init_control init_control;
if ( copy_from_guest(&init_control, arg, 1) != 0 )
return -EFAULT;
rc = evtchn_fifo_init_control(&init_control);
if ( !rc && __copy_to_guest(arg, &init_control, 1) )
rc = -EFAULT;
break;
}
case EVTCHNOP_expand_array: {
struct evtchn_expand_array expand_array;
if ( copy_from_guest(&expand_array, arg, 1) != 0 )
return -EFAULT;
rc = evtchn_fifo_expand_array(&expand_array);
break;
}
case EVTCHNOP_set_priority: {
struct evtchn_set_priority set_priority;
if ( copy_from_guest(&set_priority, arg, 1) != 0 )
return -EFAULT;
rc = evtchn_set_priority(&set_priority);
break;
}
default:
rc = -ENOSYS;
break;
}
return rc;
}","long do_event_channel_op(int VAR_0, VAR_1(void) VAR_2)
{
long VAR_3;
switch ( VAR_0 )
{
case VAR_4: {
struct evtchn_alloc_unbound VAR_5;
if ( copy_from_guest(&VAR_5, VAR_2, 1) != 0 )
return -VAR_6;
VAR_3 = evtchn_alloc_unbound(&VAR_5);
if ( !VAR_3 && __copy_to_guest(VAR_2, &VAR_5, 1) )
VAR_3 = -VAR_6; 
break;
}
case VAR_7: {
struct evtchn_bind_interdomain VAR_8;
if ( copy_from_guest(&VAR_8, VAR_2, 1) != 0 )
return -VAR_6;
VAR_3 = evtchn_bind_interdomain(&VAR_8);
if ( !VAR_3 && __copy_to_guest(VAR_2, &VAR_8, 1) )
VAR_3 = -VAR_6; 
break;
}
case VAR_9: {
struct evtchn_bind_virq VAR_10;
if ( copy_from_guest(&VAR_10, VAR_2, 1) != 0 )
return -VAR_6;
VAR_3 = evtchn_bind_virq(&VAR_10, 0);
if ( !VAR_3 && __copy_to_guest(VAR_2, &VAR_10, 1) )
VAR_3 = -VAR_6; 
break;
}
case VAR_11: {
struct evtchn_bind_ipi VAR_12;
if ( copy_from_guest(&VAR_12, VAR_2, 1) != 0 )
return -VAR_6;
VAR_3 = evtchn_bind_ipi(&VAR_12);
if ( !VAR_3 && __copy_to_guest(VAR_2, &VAR_12, 1) )
VAR_3 = -VAR_6; 
break;
}
case VAR_13: {
struct evtchn_bind_pirq VAR_14;
if ( copy_from_guest(&VAR_14, VAR_2, 1) != 0 )
return -VAR_6;
VAR_3 = evtchn_bind_pirq(&VAR_14);
if ( !VAR_3 && __copy_to_guest(VAR_2, &VAR_14, 1) )
VAR_3 = -VAR_6; 
break;
}
case VAR_15: {
struct evtchn_close VAR_16;
if ( copy_from_guest(&VAR_16, VAR_2, 1) != 0 )
return -VAR_6;
VAR_3 = evtchn_close(VAR_17->domain, VAR_16.port, 1);
break;
}
case VAR_18: {
struct evtchn_send VAR_19;
if ( copy_from_guest(&VAR_19, VAR_2, 1) != 0 )
return -VAR_6;
VAR_3 = evtchn_send(VAR_17->domain, VAR_19.port);
break;
}
case VAR_20: {
struct evtchn_status VAR_21;
if ( copy_from_guest(&VAR_21, VAR_2, 1) != 0 )
return -VAR_6;
VAR_3 = evtchn_status(&VAR_21);
if ( !VAR_3 && __copy_to_guest(VAR_2, &VAR_21, 1) )
VAR_3 = -VAR_6;
break;
}
case VAR_22: {
struct evtchn_bind_vcpu VAR_23;
if ( copy_from_guest(&VAR_23, VAR_2, 1) != 0 )
return -VAR_6;
VAR_3 = evtchn_bind_vcpu(VAR_23.port, VAR_23.vcpu);
break;
}
case VAR_24: {
struct evtchn_unmask VAR_25;
if ( copy_from_guest(&VAR_25, VAR_2, 1) != 0 )
return -VAR_6;
VAR_3 = evtchn_unmask(VAR_25.port);
break;
}
case VAR_26: {
struct evtchn_reset VAR_27;
struct domain *VAR_28;
if ( copy_from_guest(&VAR_27, VAR_2, 1) != 0 )
return -VAR_6;
VAR_28 = rcu_lock_domain_by_any_id(VAR_27.dom);
if ( VAR_28 == NULL )
return -VAR_29;
VAR_3 = xsm_evtchn_reset(VAR_30, VAR_17->domain, VAR_28);
if ( !VAR_3 )
VAR_3 = evtchn_reset(VAR_28);
rcu_unlock_domain(VAR_28);
break;
}
case VAR_31: {
struct evtchn_init_control VAR_32;
if ( copy_from_guest(&VAR_32, VAR_2, 1) != 0 )
return -VAR_6;
VAR_3 = evtchn_fifo_init_control(&VAR_32);
if ( !VAR_3 && __copy_to_guest(VAR_2, &VAR_32, 1) )
VAR_3 = -VAR_6;
break;
}
case VAR_33: {
struct evtchn_expand_array VAR_34;
if ( copy_from_guest(&VAR_34, VAR_2, 1) != 0 )
return -VAR_6;
VAR_3 = evtchn_fifo_expand_array(&VAR_34);
break;
}
case VAR_35: {
struct evtchn_set_priority VAR_36;
if ( copy_from_guest(&VAR_36, VAR_2, 1) != 0 )
return -VAR_6;
VAR_3 = evtchn_set_priority(&VAR_36);
break;
}
default:
VAR_3 = -VAR_37;
break;
}
return VAR_3;
}",,"long do_event_channel_op(int cmd, XEN_GUEST_HANDLE_PARAM(void) arg)
{
    long rc;

    switch ( cmd )
    {
    case EVTCHNOP_alloc_unbound: {
        struct evtchn_alloc_unbound alloc_unbound;
        if ( copy_from_guest(&alloc_unbound, arg, 1) != 0 )
            return -EFAULT;
        rc = evtchn_alloc_unbound(&alloc_unbound);
        if ( !rc && __copy_to_guest(arg, &alloc_unbound, 1) )
            rc = -EFAULT; /* Cleaning up here would be a mess! */
        break;
    }

    case EVTCHNOP_bind_interdomain: {
        struct evtchn_bind_interdomain bind_interdomain;
        if ( copy_from_guest(&bind_interdomain, arg, 1) != 0 )
            return -EFAULT;
        rc = evtchn_bind_interdomain(&bind_interdomain);
        if ( !rc && __copy_to_guest(arg, &bind_interdomain, 1) )
            rc = -EFAULT; /* Cleaning up here would be a mess! */
        break;
    }

    case EVTCHNOP_bind_virq: {
        struct evtchn_bind_virq bind_virq;
        if ( copy_from_guest(&bind_virq, arg, 1) != 0 )
            return -EFAULT;
        rc = evtchn_bind_virq(&bind_virq, 0);
        if ( !rc && __copy_to_guest(arg, &bind_virq, 1) )
            rc = -EFAULT; /* Cleaning up here would be a mess! */
        break;
    }

    case EVTCHNOP_bind_ipi: {
        struct evtchn_bind_ipi bind_ipi;
        if ( copy_from_guest(&bind_ipi, arg, 1) != 0 )
            return -EFAULT;
        rc = evtchn_bind_ipi(&bind_ipi);
        if ( !rc && __copy_to_guest(arg, &bind_ipi, 1) )
            rc = -EFAULT; /* Cleaning up here would be a mess! */
        break;
    }

    case EVTCHNOP_bind_pirq: {
        struct evtchn_bind_pirq bind_pirq;
        if ( copy_from_guest(&bind_pirq, arg, 1) != 0 )
            return -EFAULT;
        rc = evtchn_bind_pirq(&bind_pirq);
        if ( !rc && __copy_to_guest(arg, &bind_pirq, 1) )
            rc = -EFAULT; /* Cleaning up here would be a mess! */
        break;
    }

    case EVTCHNOP_close: {
        struct evtchn_close close;
        if ( copy_from_guest(&close, arg, 1) != 0 )
            return -EFAULT;
        rc = evtchn_close(current->domain, close.port, 1);
        break;
    }

    case EVTCHNOP_send: {
        struct evtchn_send send;
        if ( copy_from_guest(&send, arg, 1) != 0 )
            return -EFAULT;
        rc = evtchn_send(current->domain, send.port);
        break;
    }

    case EVTCHNOP_status: {
        struct evtchn_status status;
        if ( copy_from_guest(&status, arg, 1) != 0 )
            return -EFAULT;
        rc = evtchn_status(&status);
        if ( !rc && __copy_to_guest(arg, &status, 1) )
            rc = -EFAULT;
        break;
    }

    case EVTCHNOP_bind_vcpu: {
        struct evtchn_bind_vcpu bind_vcpu;
        if ( copy_from_guest(&bind_vcpu, arg, 1) != 0 )
            return -EFAULT;
        rc = evtchn_bind_vcpu(bind_vcpu.port, bind_vcpu.vcpu);
        break;
    }

    case EVTCHNOP_unmask: {
        struct evtchn_unmask unmask;
        if ( copy_from_guest(&unmask, arg, 1) != 0 )
            return -EFAULT;
        rc = evtchn_unmask(unmask.port);
        break;
    }

    case EVTCHNOP_reset:
    case EVTCHNOP_reset_cont: {
        struct evtchn_reset reset;
        struct domain *d;

        if ( copy_from_guest(&reset, arg, 1) != 0 )
            return -EFAULT;

        d = rcu_lock_domain_by_any_id(reset.dom);
        if ( d == NULL )
            return -ESRCH;

        rc = xsm_evtchn_reset(XSM_TARGET, current->domain, d);
        if ( !rc )
            rc = evtchn_reset(d, cmd == EVTCHNOP_reset_cont);

        rcu_unlock_domain(d);

        if ( rc == -ERESTART )
            rc = hypercall_create_continuation(__HYPERVISOR_event_channel_op,
                                               ""ih"", EVTCHNOP_reset_cont, arg);
        break;
    }

    case EVTCHNOP_init_control: {
        struct evtchn_init_control init_control;
        if ( copy_from_guest(&init_control, arg, 1) != 0 )
            return -EFAULT;
        rc = evtchn_fifo_init_control(&init_control);
        if ( !rc && __copy_to_guest(arg, &init_control, 1) )
            rc = -EFAULT;
        break;
    }

    case EVTCHNOP_expand_array: {
        struct evtchn_expand_array expand_array;
        if ( copy_from_guest(&expand_array, arg, 1) != 0 )
            return -EFAULT;
        rc = evtchn_fifo_expand_array(&expand_array);
        break;
    }

    case EVTCHNOP_set_priority: {
        struct evtchn_set_priority set_priority;
        if ( copy_from_guest(&set_priority, arg, 1) != 0 )
            return -EFAULT;
        rc = evtchn_set_priority(&set_priority);
        break;
    }

    default:
        rc = -ENOSYS;
        break;
    }

    return rc;
}","long do_event_channel_op(int VAR_0, VAR_1(void) VAR_2)
{
    long VAR_3;

    switch ( VAR_0 )
    {
    case VAR_4: {
        struct evtchn_alloc_unbound VAR_5;
        if ( copy_from_guest(&VAR_5, VAR_2, 1) != 0 )
            return -VAR_6;
        VAR_3 = evtchn_alloc_unbound(&VAR_5);
        if ( !VAR_3 && __copy_to_guest(VAR_2, &VAR_5, 1) )
            VAR_3 = -VAR_6; /* COMMENT_0 */
        break;
    }

    case VAR_7: {
        struct evtchn_bind_interdomain VAR_8;
        if ( copy_from_guest(&VAR_8, VAR_2, 1) != 0 )
            return -VAR_6;
        VAR_3 = evtchn_bind_interdomain(&VAR_8);
        if ( !VAR_3 && __copy_to_guest(VAR_2, &VAR_8, 1) )
            VAR_3 = -VAR_6; /* COMMENT_0 */
        break;
    }

    case VAR_9: {
        struct evtchn_bind_virq VAR_10;
        if ( copy_from_guest(&VAR_10, VAR_2, 1) != 0 )
            return -VAR_6;
        VAR_3 = evtchn_bind_virq(&VAR_10, 0);
        if ( !VAR_3 && __copy_to_guest(VAR_2, &VAR_10, 1) )
            VAR_3 = -VAR_6; /* COMMENT_0 */
        break;
    }

    case VAR_11: {
        struct evtchn_bind_ipi VAR_12;
        if ( copy_from_guest(&VAR_12, VAR_2, 1) != 0 )
            return -VAR_6;
        VAR_3 = evtchn_bind_ipi(&VAR_12);
        if ( !VAR_3 && __copy_to_guest(VAR_2, &VAR_12, 1) )
            VAR_3 = -VAR_6; /* COMMENT_0 */
        break;
    }

    case VAR_13: {
        struct evtchn_bind_pirq VAR_14;
        if ( copy_from_guest(&VAR_14, VAR_2, 1) != 0 )
            return -VAR_6;
        VAR_3 = evtchn_bind_pirq(&VAR_14);
        if ( !VAR_3 && __copy_to_guest(VAR_2, &VAR_14, 1) )
            VAR_3 = -VAR_6; /* COMMENT_0 */
        break;
    }

    case VAR_15: {
        struct evtchn_close VAR_16;
        if ( copy_from_guest(&VAR_16, VAR_2, 1) != 0 )
            return -VAR_6;
        VAR_3 = evtchn_close(VAR_17->domain, VAR_16.port, 1);
        break;
    }

    case VAR_18: {
        struct evtchn_send VAR_19;
        if ( copy_from_guest(&VAR_19, VAR_2, 1) != 0 )
            return -VAR_6;
        VAR_3 = evtchn_send(VAR_17->domain, VAR_19.port);
        break;
    }

    case VAR_20: {
        struct evtchn_status VAR_21;
        if ( copy_from_guest(&VAR_21, VAR_2, 1) != 0 )
            return -VAR_6;
        VAR_3 = evtchn_status(&VAR_21);
        if ( !VAR_3 && __copy_to_guest(VAR_2, &VAR_21, 1) )
            VAR_3 = -VAR_6;
        break;
    }

    case VAR_22: {
        struct evtchn_bind_vcpu VAR_23;
        if ( copy_from_guest(&VAR_23, VAR_2, 1) != 0 )
            return -VAR_6;
        VAR_3 = evtchn_bind_vcpu(VAR_23.port, VAR_23.vcpu);
        break;
    }

    case VAR_24: {
        struct evtchn_unmask VAR_25;
        if ( copy_from_guest(&VAR_25, VAR_2, 1) != 0 )
            return -VAR_6;
        VAR_3 = evtchn_unmask(VAR_25.port);
        break;
    }

    case VAR_26:
    case VAR_27: {
        struct evtchn_reset VAR_28;
        struct domain *VAR_29;

        if ( copy_from_guest(&VAR_28, VAR_2, 1) != 0 )
            return -VAR_6;

        VAR_29 = rcu_lock_domain_by_any_id(VAR_28.dom);
        if ( VAR_29 == NULL )
            return -VAR_30;

        VAR_3 = xsm_evtchn_reset(VAR_31, VAR_17->domain, VAR_29);
        if ( !VAR_3 )
            VAR_3 = evtchn_reset(VAR_29, VAR_0 == VAR_27);

        rcu_unlock_domain(VAR_29);

        if ( VAR_3 == -VAR_32 )
            VAR_3 = hypercall_create_continuation(VAR_33,
                                               ""ih"", VAR_27, VAR_2);
        break;
    }

    case VAR_34: {
        struct evtchn_init_control VAR_35;
        if ( copy_from_guest(&VAR_35, VAR_2, 1) != 0 )
            return -VAR_6;
        VAR_3 = evtchn_fifo_init_control(&VAR_35);
        if ( !VAR_3 && __copy_to_guest(VAR_2, &VAR_35, 1) )
            VAR_3 = -VAR_6;
        break;
    }

    case VAR_36: {
        struct evtchn_expand_array VAR_37;
        if ( copy_from_guest(&VAR_37, VAR_2, 1) != 0 )
            return -VAR_6;
        VAR_3 = evtchn_fifo_expand_array(&VAR_37);
        break;
    }

    case VAR_38: {
        struct evtchn_set_priority VAR_39;
        if ( copy_from_guest(&VAR_39, VAR_2, 1) != 0 )
            return -VAR_6;
        VAR_3 = evtchn_set_priority(&VAR_39);
        break;
    }

    default:
        VAR_3 = -VAR_40;
        break;
    }

    return VAR_3;
}",,"--- func_before
+++ func_after
@@ -96,7 +96,8 @@
         break;
     }
 
-    case EVTCHNOP_reset: {
+    case EVTCHNOP_reset:
+    case EVTCHNOP_reset_cont: {
         struct evtchn_reset reset;
         struct domain *d;
 
@@ -109,9 +110,13 @@
 
         rc = xsm_evtchn_reset(XSM_TARGET, current->domain, d);
         if ( !rc )
-            rc = evtchn_reset(d);
+            rc = evtchn_reset(d, cmd == EVTCHNOP_reset_cont);
 
         rcu_unlock_domain(d);
+
+        if ( rc == -ERESTART )
+            rc = hypercall_create_continuation(__HYPERVISOR_event_channel_op,
+                                               ""ih"", EVTCHNOP_reset_cont, arg);
         break;
     }
 ","{'deleted_lines': ['    case EVTCHNOP_reset: {', '            rc = evtchn_reset(d);'], 'added_lines': ['    case EVTCHNOP_reset:', '    case EVTCHNOP_reset_cont: {', '            rc = evtchn_reset(d, cmd == EVTCHNOP_reset_cont);', '', '        if ( rc == -ERESTART )', '            rc = hypercall_create_continuation(__HYPERVISOR_event_channel_op,', '                                               ""ih"", EVTCHNOP_reset_cont, arg);']}",True,"An issue was discovered in Xen through 4.14.x. There is a lack of preemption in evtchn_reset() / evtchn_destroy(). In particular, the FIFO event channel model allows guests to have a large number of event channels active at a time. Closing all of these (when resetting all event channels or when cleaning up after the guest) may take extended periods of time. So far, there was no arrangement for preemption at suitable intervals, allowing a CPU to spend an almost unbounded amount of time in the processing of these operations. Malicious or buggy guest kernels can mount a Denial of Service (DoS) attack affecting the entire system. All Xen versions are vulnerable in principle. Whether versions 4.3 and older are vulnerable depends on underlying hardware characteristics.",5.5,MEDIUM,1,valid,2020-09-22T13:53:10Z,3
CVE-2020-25601,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,xen-project/xen,"evtchn: arrange for preemption in evtchn_reset()

Like for evtchn_destroy() looping over all possible event channels to
close them can take a significant amount of time. Unlike done there, we
can't alter domain properties (i.e. d->valid_evtchns) here. Borrow, in a
lightweight form, the paging domctl continuation concept, redirecting
the continuations to different sub-ops. Just like there this is to be
able to allow for predictable overall results of the involved sub-ops:
Racing requests should either complete or be refused.

Note that a domain can't interfere with an already started (by a remote
domain) reset, due to being paused. It can prevent a remote reset from
happening by leaving a reset unfinished, but that's only going to affect
itself.

This is part of XSA-344.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Acked-by: Julien Grall <jgrall@amazon.com>
Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>",2785b2a9e04abc148e1c5259f4faee708ea356f4,https://github.com/xen-project/xen/commit/2785b2a9e04abc148e1c5259f4faee708ea356f4,xen/common/domctl.c,do_domctl,"long do_domctl(XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)
{
long ret = 0;
bool_t copyback = 0;
struct xen_domctl curop, *op = &curop;
struct domain *d;
if ( copy_from_guest(op, u_domctl, 1) )
return -EFAULT;
if ( op->interface_version != XEN_DOMCTL_INTERFACE_VERSION )
return -EACCES;
switch ( op->cmd )
{
case XEN_DOMCTL_assign_device:
case XEN_DOMCTL_deassign_device:
if ( op->domain == DOMID_IO )
{
d = dom_io;
break;
}
else if ( op->domain == DOMID_INVALID )
return -ESRCH;
case XEN_DOMCTL_test_assign_device:
case XEN_DOMCTL_vm_event_op:
if ( op->domain == DOMID_INVALID )
{
case XEN_DOMCTL_createdomain:
case XEN_DOMCTL_gdbsx_guestmemio:
d = NULL;
break;
}
default:
d = rcu_lock_domain_by_id(op->domain);
if ( !d && op->cmd != XEN_DOMCTL_getdomaininfo )
return -ESRCH;
}
ret = xsm_domctl(XSM_OTHER, d, op->cmd);
if ( ret )
goto domctl_out_unlock_domonly;
if ( !domctl_lock_acquire() )
{
if ( d && d != dom_io )
rcu_unlock_domain(d);
return hypercall_create_continuation(
__HYPERVISOR_domctl, ""h"", u_domctl);
}
switch ( op->cmd )
{
case XEN_DOMCTL_setvcpucontext:
{
vcpu_guest_context_u c = { .nat = NULL };
unsigned int vcpu = op->u.vcpucontext.vcpu;
struct vcpu *v;
ret = -EINVAL;
if ( (d == current->domain) || 
(vcpu >= d->max_vcpus) || ((v = d->vcpu[vcpu]) == NULL) )
break;
if ( guest_handle_is_null(op->u.vcpucontext.ctxt) )
{
ret = vcpu_reset(v);
if ( ret == -ERESTART )
ret = hypercall_create_continuation(
__HYPERVISOR_domctl, ""h"", u_domctl);
break;
}
#ifdef CONFIG_COMPAT
BUILD_BUG_ON(sizeof(struct vcpu_guest_context)
< sizeof(struct compat_vcpu_guest_context));
#endif
ret = -ENOMEM;
if ( (c.nat = alloc_vcpu_guest_context()) == NULL )
break;
#ifdef CONFIG_COMPAT
if ( !is_pv_32bit_domain(d) )
ret = copy_from_guest(c.nat, op->u.vcpucontext.ctxt, 1);
else
ret = copy_from_guest(c.cmp,
guest_handle_cast(op->u.vcpucontext.ctxt,
void), 1);
#else
ret = copy_from_guest(c.nat, op->u.vcpucontext.ctxt, 1);
#endif
ret = ret ? -EFAULT : 0;
if ( ret == 0 )
{
domain_pause(d);
ret = arch_set_info_guest(v, c);
domain_unpause(d);
if ( ret == -ERESTART )
ret = hypercall_create_continuation(
__HYPERVISOR_domctl, ""h"", u_domctl);
}
free_vcpu_guest_context(c.nat);
break;
}
case XEN_DOMCTL_pausedomain:
ret = -EINVAL;
if ( d != current->domain )
ret = domain_pause_by_systemcontroller(d);
break;
case XEN_DOMCTL_unpausedomain:
ret = domain_unpause_by_systemcontroller(d);
break;
case XEN_DOMCTL_resumedomain:
if ( d == current->domain ) 
ret = -EINVAL;
else
domain_resume(d);
break;
case XEN_DOMCTL_createdomain:
{
domid_t        dom;
static domid_t rover = 0;
dom = op->domain;
if ( (dom > 0) && (dom < DOMID_FIRST_RESERVED) )
{
ret = -EEXIST;
if ( !is_free_domid(dom) )
break;
}
else
{
for ( dom = rover + 1; dom != rover; dom++ )
{
if ( dom == DOMID_FIRST_RESERVED )
dom = 1;
if ( is_free_domid(dom) )
break;
}
ret = -ENOMEM;
if ( dom == rover )
break;
rover = dom;
}
d = domain_create(dom, &op->u.createdomain, false);
if ( IS_ERR(d) )
{
ret = PTR_ERR(d);
d = NULL;
break;
}
ret = 0;
op->domain = d->domain_id;
copyback = 1;
d = NULL;
break;
}
case XEN_DOMCTL_max_vcpus:
{
unsigned int i, max = op->u.max_vcpus.max;
ret = -EINVAL;
if ( (d == current->domain) || 
(max != d->max_vcpus) )   
break;
domain_pause(d);
ret = -ENOMEM;
for ( i = 0; i < max; i++ )
{
if ( d->vcpu[i] != NULL )
continue;
if ( vcpu_create(d, i) == NULL )
goto maxvcpu_out;
}
domain_update_node_affinity(d);
ret = 0;
maxvcpu_out:
domain_unpause(d);
break;
}
case XEN_DOMCTL_soft_reset:
if ( d == current->domain ) 
{
ret = -EINVAL;
break;
}
ret = domain_soft_reset(d);
break;
case XEN_DOMCTL_destroydomain:
domctl_lock_release();
domain_lock(d);
ret = domain_kill(d);
domain_unlock(d);
if ( ret == -ERESTART )
ret = hypercall_create_continuation(
__HYPERVISOR_domctl, ""h"", u_domctl);
goto domctl_out_unlock_domonly;
case XEN_DOMCTL_setnodeaffinity:
{
nodemask_t new_affinity;
ret = xenctl_bitmap_to_nodemask(&new_affinity,
&op->u.nodeaffinity.nodemap);
if ( !ret )
ret = domain_set_node_affinity(d, &new_affinity);
break;
}
case XEN_DOMCTL_getnodeaffinity:
ret = nodemask_to_xenctl_bitmap(&op->u.nodeaffinity.nodemap,
&d->node_affinity);
break;
case XEN_DOMCTL_setvcpuaffinity:
case XEN_DOMCTL_getvcpuaffinity:
ret = vcpu_affinity_domctl(d, op->cmd, &op->u.vcpuaffinity);
break;
case XEN_DOMCTL_scheduler_op:
ret = sched_adjust(d, &op->u.scheduler_op);
copyback = 1;
break;
case XEN_DOMCTL_getdomaininfo:
{
domid_t dom = DOMID_INVALID;
if ( !d )
{
ret = -EINVAL;
if ( op->domain >= DOMID_FIRST_RESERVED )
break;
rcu_read_lock(&domlist_read_lock);
dom = op->domain;
for_each_domain ( d )
if ( d->domain_id >= dom )
break;
}
ret = -ESRCH;
if ( d == NULL )
goto getdomaininfo_out;
ret = xsm_getdomaininfo(XSM_HOOK, d);
if ( ret )
goto getdomaininfo_out;
getdomaininfo(d, &op->u.getdomaininfo);
op->domain = op->u.getdomaininfo.domain;
copyback = 1;
getdomaininfo_out:
if ( dom == DOMID_INVALID )
break;
rcu_read_unlock(&domlist_read_lock);
d = NULL;
break;
}
case XEN_DOMCTL_getvcpucontext:
{
vcpu_guest_context_u c = { .nat = NULL };
struct vcpu         *v;
ret = -EINVAL;
if ( op->u.vcpucontext.vcpu >= d->max_vcpus ||
(v = d->vcpu[op->u.vcpucontext.vcpu]) == NULL ||
v == current ) 
goto getvcpucontext_out;
ret = -ENODATA;
if ( !v->is_initialised )
goto getvcpucontext_out;
#ifdef CONFIG_COMPAT
BUILD_BUG_ON(sizeof(struct vcpu_guest_context)
< sizeof(struct compat_vcpu_guest_context));
#endif
ret = -ENOMEM;
if ( (c.nat = xzalloc(struct vcpu_guest_context)) == NULL )
goto getvcpucontext_out;
vcpu_pause(v);
arch_get_info_guest(v, c);
ret = 0;
vcpu_unpause(v);
#ifdef CONFIG_COMPAT
if ( !is_pv_32bit_domain(d) )
ret = copy_to_guest(op->u.vcpucontext.ctxt, c.nat, 1);
else
ret = copy_to_guest(guest_handle_cast(op->u.vcpucontext.ctxt,
void), c.cmp, 1);
#else
ret = copy_to_guest(op->u.vcpucontext.ctxt, c.nat, 1);
#endif
if ( ret )
ret = -EFAULT;
copyback = 1;
getvcpucontext_out:
xfree(c.nat);
break;
}
case XEN_DOMCTL_getvcpuinfo:
{
struct vcpu   *v;
struct vcpu_runstate_info runstate;
ret = -EINVAL;
if ( op->u.getvcpuinfo.vcpu >= d->max_vcpus )
break;
ret = -ESRCH;
if ( (v = d->vcpu[op->u.getvcpuinfo.vcpu]) == NULL )
break;
vcpu_runstate_get(v, &runstate);
op->u.getvcpuinfo.online   = !(v->pause_flags & VPF_down);
op->u.getvcpuinfo.blocked  = !!(v->pause_flags & VPF_blocked);
op->u.getvcpuinfo.running  = v->is_running;
op->u.getvcpuinfo.cpu_time = runstate.time[RUNSTATE_running];
op->u.getvcpuinfo.cpu      = v->processor;
ret = 0;
copyback = 1;
break;
}
case XEN_DOMCTL_max_mem:
{
uint64_t new_max = op->u.max_mem.max_memkb >> (PAGE_SHIFT - 10);
spin_lock(&d->page_alloc_lock);
d->max_pages = min(new_max, (uint64_t)(typeof(d->max_pages))-1);
spin_unlock(&d->page_alloc_lock);
break;
}
case XEN_DOMCTL_setdomainhandle:
memcpy(d->handle, op->u.setdomainhandle.handle,
sizeof(xen_domain_handle_t));
break;
case XEN_DOMCTL_setdebugging:
if ( unlikely(d == current->domain) ) 
ret = -EINVAL;
else
{
domain_pause(d);
d->debugger_attached = !!op->u.setdebugging.enable;
domain_unpause(d); 
}
break;
case XEN_DOMCTL_irq_permission:
{
unsigned int pirq = op->u.irq_permission.pirq, irq;
int allow = op->u.irq_permission.allow_access;
if ( pirq >= current->domain->nr_pirqs )
{
ret = -EINVAL;
break;
}
irq = pirq_access_permitted(current->domain, pirq);
if ( !irq || xsm_irq_permission(XSM_HOOK, d, irq, allow) )
ret = -EPERM;
else if ( allow )
ret = irq_permit_access(d, irq);
else
ret = irq_deny_access(d, irq);
break;
}
case XEN_DOMCTL_iomem_permission:
{
unsigned long mfn = op->u.iomem_permission.first_mfn;
unsigned long nr_mfns = op->u.iomem_permission.nr_mfns;
int allow = op->u.iomem_permission.allow_access;
ret = -EINVAL;
if ( (mfn + nr_mfns - 1) < mfn ) 
break;
if ( !iomem_access_permitted(current->domain,
mfn, mfn + nr_mfns - 1) ||
xsm_iomem_permission(XSM_HOOK, d, mfn, mfn + nr_mfns - 1, allow) )
ret = -EPERM;
else if ( allow )
ret = iomem_permit_access(d, mfn, mfn + nr_mfns - 1);
else
ret = iomem_deny_access(d, mfn, mfn + nr_mfns - 1);
if ( !ret )
memory_type_changed(d);
break;
}
case XEN_DOMCTL_memory_mapping:
{
unsigned long gfn = op->u.memory_mapping.first_gfn;
unsigned long mfn = op->u.memory_mapping.first_mfn;
unsigned long nr_mfns = op->u.memory_mapping.nr_mfns;
unsigned long mfn_end = mfn + nr_mfns - 1;
int add = op->u.memory_mapping.add_mapping;
ret = -EINVAL;
if ( mfn_end < mfn || 
((mfn | mfn_end) >> (paddr_bits - PAGE_SHIFT)) ||
(gfn + nr_mfns - 1) < gfn ) 
break;
#ifndef CONFIG_X86 
ret = -E2BIG;
if ( nr_mfns > 64 )
break;
#endif
ret = -EPERM;
if ( !iomem_access_permitted(current->domain, mfn, mfn_end) ||
!iomem_access_permitted(d, mfn, mfn_end) )
break;
ret = xsm_iomem_mapping(XSM_HOOK, d, mfn, mfn_end, add);
if ( ret )
break;
if ( add )
{
printk(XENLOG_G_DEBUG
""memory_map:add: dom%d gfn=%lx mfn=%lx nr=%lx\n"",
d->domain_id, gfn, mfn, nr_mfns);
ret = map_mmio_regions(d, _gfn(gfn), nr_mfns, _mfn(mfn));
if ( ret < 0 )
printk(XENLOG_G_WARNING
""memory_map:fail: dom%d gfn=%lx mfn=%lx nr=%lx ret:%ld\n"",
d->domain_id, gfn, mfn, nr_mfns, ret);
}
else
{
printk(XENLOG_G_DEBUG
""memory_map:remove: dom%d gfn=%lx mfn=%lx nr=%lx\n"",
d->domain_id, gfn, mfn, nr_mfns);
ret = unmap_mmio_regions(d, _gfn(gfn), nr_mfns, _mfn(mfn));
if ( ret < 0 && is_hardware_domain(current->domain) )
printk(XENLOG_ERR
""memory_map: error %ld removing dom%d access to [%lx,%lx]\n"",
ret, d->domain_id, mfn, mfn_end);
}
memory_type_changed(d);
break;
}
case XEN_DOMCTL_settimeoffset:
domain_set_time_offset(d, op->u.settimeoffset.time_offset_seconds);
break;
case XEN_DOMCTL_set_target:
{
struct domain *e;
ret = -ESRCH;
e = get_domain_by_id(op->u.set_target.target);
if ( e == NULL )
break;
ret = -EINVAL;
if ( (d == e) || (d->target != NULL) )
{
put_domain(e);
break;
}
ret = -EOPNOTSUPP;
if ( is_hvm_domain(e) )
ret = xsm_set_target(XSM_HOOK, d, e);
if ( ret )
{
put_domain(e);
break;
}
d->target = e;
break;
}
case XEN_DOMCTL_subscribe:
d->suspend_evtchn = op->u.subscribe.port;
break;
case XEN_DOMCTL_vm_event_op:
ret = vm_event_domctl(d, &op->u.vm_event_op);
if ( ret == 0 )
copyback = true;
break;
#ifdef CONFIG_MEM_ACCESS
case XEN_DOMCTL_set_access_required:
if ( unlikely(current->domain == d) ) 
ret = -EPERM;
else
{
domain_pause(d);
arch_p2m_set_access_required(d,
op->u.access_required.access_required);
domain_unpause(d);
}
break;
#endif
case XEN_DOMCTL_set_virq_handler:
ret = set_global_virq_handler(d, op->u.set_virq_handler.virq);
break;
case XEN_DOMCTL_setvnumainfo:
{
struct vnuma_info *vnuma;
vnuma = vnuma_init(&op->u.vnuma, d);
if ( IS_ERR(vnuma) )
{
ret = PTR_ERR(vnuma);
break;
}
write_lock(&d->vnuma_rwlock);
vnuma_destroy(d->vnuma);
d->vnuma = vnuma;
write_unlock(&d->vnuma_rwlock);
break;
}
case XEN_DOMCTL_monitor_op:
ret = monitor_domctl(d, &op->u.monitor_op);
if ( !ret )
copyback = 1;
break;
default:
ret = arch_do_domctl(op, d, u_domctl);
break;
}
domctl_lock_release();
domctl_out_unlock_domonly:
if ( d && d != dom_io )
rcu_unlock_domain(d);
if ( copyback && __copy_to_guest(u_domctl, op, 1) )
ret = -EFAULT;
return ret;
}","long do_domctl(VAR_0(xen_domctl_t) VAR_1)
{
long VAR_2 = 0;
bool_t VAR_3 = 0;
struct xen_domctl VAR_4, *VAR_5 = &VAR_4;
struct domain *VAR_6;
if ( copy_from_guest(VAR_5, VAR_1, 1) )
return -VAR_7;
if ( VAR_5->interface_version != VAR_8 )
return -VAR_9;
switch ( VAR_5->cmd )
{
case VAR_10:
case VAR_11:
if ( VAR_5->domain == VAR_12 )
{
VAR_6 = VAR_13;
break;
}
else if ( VAR_5->domain == VAR_14 )
return -VAR_15;
case VAR_16:
case VAR_17:
if ( VAR_5->domain == VAR_14 )
{
case VAR_18:
case VAR_19:
VAR_6 = NULL;
break;
}
default:
VAR_6 = rcu_lock_domain_by_id(VAR_5->domain);
if ( !VAR_6 && VAR_5->cmd != VAR_20 )
return -VAR_15;
}
VAR_2 = xsm_domctl(VAR_21, VAR_6, VAR_5->cmd);
if ( VAR_2 )
goto domctl_out_unlock_domonly;
if ( !domctl_lock_acquire() )
{
if ( VAR_6 && VAR_6 != VAR_13 )
rcu_unlock_domain(VAR_6);
return hypercall_create_continuation(
VAR_22, ""h"", VAR_1);
}
switch ( VAR_5->cmd )
{
case VAR_23:
{
vcpu_guest_context_u VAR_24 = { .nat = NULL };
unsigned int VAR_25 = VAR_5->u.vcpucontext.vcpu;
struct vcpu *VAR_26;
VAR_2 = -VAR_27;
if ( (VAR_6 == VAR_28->domain) || 
(vcpu >= VAR_6->max_vcpus) || ((VAR_26 = VAR_6->vcpu[vcpu]) == NULL) )
break;
if ( guest_handle_is_null(VAR_5->u.vcpucontext.ctxt) )
{
VAR_2 = vcpu_reset(VAR_26);
if ( VAR_2 == -VAR_29 )
VAR_2 = hypercall_create_continuation(
VAR_22, ""h"", VAR_1);
break;
}
#ifdef VAR_30
BUILD_BUG_ON(sizeof(struct vcpu_guest_context)
< sizeof(struct compat_vcpu_guest_context));
#endif
VAR_2 = -VAR_31;
if ( (VAR_24.nat = alloc_vcpu_guest_context()) == NULL )
break;
#ifdef VAR_30
if ( !is_pv_32bit_domain(VAR_6) )
VAR_2 = copy_from_guest(VAR_24.nat, VAR_5->u.vcpucontext.ctxt, 1);
else
VAR_2 = copy_from_guest(VAR_24.cmp,
guest_handle_cast(VAR_5->u.vcpucontext.ctxt,
VAR_32), 1);
#else
VAR_2 = copy_from_guest(VAR_24.nat, VAR_5->u.vcpucontext.ctxt, 1);
#endif
VAR_2 = VAR_2 ? -VAR_7 : 0;
if ( VAR_2 == 0 )
{
domain_pause(VAR_6);
VAR_2 = arch_set_info_guest(VAR_26, VAR_24);
domain_unpause(VAR_6);
if ( VAR_2 == -VAR_29 )
VAR_2 = hypercall_create_continuation(
VAR_22, ""h"", VAR_1);
}
free_vcpu_guest_context(VAR_24.nat);
break;
}
case VAR_33:
VAR_2 = -VAR_27;
if ( VAR_6 != VAR_28->domain )
VAR_2 = domain_pause_by_systemcontroller(VAR_6);
break;
case VAR_34:
VAR_2 = domain_unpause_by_systemcontroller(VAR_6);
break;
case VAR_35:
if ( VAR_6 == VAR_28->domain ) 
VAR_2 = -VAR_27;
else
domain_resume(VAR_6);
break;
case VAR_18:
{
domid_t        VAR_36;
static domid_t VAR_37 = 0;
VAR_36 = VAR_5->domain;
if ( (VAR_36 > 0) && (VAR_36 < VAR_38) )
{
VAR_2 = -VAR_39;
if ( !is_free_domid(VAR_36) )
break;
}
else
{
for ( VAR_36 = VAR_37 + 1; VAR_36 != VAR_37; VAR_36++ )
{
if ( VAR_36 == VAR_38 )
VAR_36 = 1;
if ( is_free_domid(VAR_36) )
break;
}
VAR_2 = -VAR_31;
if ( VAR_36 == VAR_37 )
break;
VAR_37 = VAR_36;
}
VAR_6 = domain_create(VAR_36, &VAR_5->u.createdomain, false);
if ( IS_ERR(VAR_6) )
{
VAR_2 = PTR_ERR(VAR_6);
VAR_6 = NULL;
break;
}
VAR_2 = 0;
VAR_5->domain = VAR_6->domain_id;
VAR_3 = 1;
VAR_6 = NULL;
break;
}
case VAR_40:
{
unsigned int VAR_41, VAR_42 = VAR_5->u.max_vcpus.max;
VAR_2 = -VAR_27;
if ( (VAR_6 == VAR_28->domain) || 
(VAR_42 != VAR_6->max_vcpus) )   
break;
domain_pause(VAR_6);
VAR_2 = -VAR_31;
for ( VAR_41 = 0; VAR_41 < VAR_42; VAR_41++ )
{
if ( VAR_6->vcpu[VAR_41] != NULL )
continue;
if ( vcpu_create(VAR_6, VAR_41) == NULL )
goto maxvcpu_out;
}
domain_update_node_affinity(VAR_6);
VAR_2 = 0;
maxvcpu_out:
domain_unpause(VAR_6);
break;
}
case VAR_43:
if ( VAR_6 == VAR_28->domain ) 
{
VAR_2 = -VAR_27;
break;
}
VAR_2 = domain_soft_reset(VAR_6);
break;
case VAR_44:
domctl_lock_release();
domain_lock(VAR_6);
VAR_2 = domain_kill(VAR_6);
domain_unlock(VAR_6);
if ( VAR_2 == -VAR_29 )
VAR_2 = hypercall_create_continuation(
VAR_22, ""h"", VAR_1);
goto domctl_out_unlock_domonly;
case VAR_45:
{
nodemask_t VAR_46;
VAR_2 = xenctl_bitmap_to_nodemask(&VAR_46,
&VAR_5->u.nodeaffinity.nodemap);
if ( !VAR_2 )
VAR_2 = domain_set_node_affinity(VAR_6, &VAR_46);
break;
}
case VAR_47:
VAR_2 = nodemask_to_xenctl_bitmap(&VAR_5->u.nodeaffinity.nodemap,
&VAR_6->node_affinity);
break;
case VAR_48:
case VAR_49:
VAR_2 = vcpu_affinity_domctl(VAR_6, VAR_5->cmd, &VAR_5->u.vcpuaffinity);
break;
case VAR_50:
VAR_2 = sched_adjust(VAR_6, &VAR_5->u.scheduler_op);
VAR_3 = 1;
break;
case VAR_20:
{
domid_t VAR_36 = VAR_14;
if ( !VAR_6 )
{
VAR_2 = -VAR_27;
if ( VAR_5->domain >= VAR_38 )
break;
rcu_read_lock(&VAR_51);
VAR_36 = VAR_5->domain;
VAR_52 ( d )
if ( d->VAR_53 >= VAR_36 )
break;
}
VAR_2 = -VAR_15;
if ( d == NULL )
goto getdomaininfo_out;
VAR_2 = xsm_getdomaininfo(VAR_54, d);
if ( VAR_2 )
goto getdomaininfo_out;
getdomaininfo(d, &VAR_5->u.getdomaininfo);
VAR_5->domain = VAR_5->u.getdomaininfo.domain;
VAR_3 = 1;
getdomaininfo_out:
if ( VAR_36 == VAR_14 )
break;
rcu_read_unlock(&VAR_51);
d = NULL;
break;
}
case VAR_55:
{
vcpu_guest_context_u VAR_24 = { .nat = NULL };
struct vcpu         *VAR_26;
VAR_2 = -VAR_27;
if ( VAR_5->u.vcpucontext.vcpu >= d->max_vcpus ||
(VAR_26 = d->vcpu[VAR_5->u.vcpucontext.vcpu]) == NULL ||
VAR_26 == VAR_28 ) 
goto getvcpucontext_out;
VAR_2 = -VAR_56;
if ( !VAR_26->is_initialised )
goto getvcpucontext_out;
#ifdef VAR_30
BUILD_BUG_ON(sizeof(struct vcpu_guest_context)
< sizeof(struct compat_vcpu_guest_context));
#endif
VAR_2 = -VAR_31;
if ( (VAR_24.nat = xzalloc(struct vcpu_guest_context)) == NULL )
goto getvcpucontext_out;
vcpu_pause(VAR_26);
arch_get_info_guest(VAR_26, VAR_24);
VAR_2 = 0;
vcpu_unpause(VAR_26);
#ifdef VAR_30
if ( !is_pv_32bit_domain(d) )
VAR_2 = copy_to_guest(VAR_5->u.vcpucontext.ctxt, VAR_24.nat, 1);
else
VAR_2 = copy_to_guest(guest_handle_cast(VAR_5->u.vcpucontext.ctxt,
VAR_32), VAR_24.cmp, 1);
#else
VAR_2 = copy_to_guest(VAR_5->u.vcpucontext.ctxt, VAR_24.nat, 1);
#endif
if ( VAR_2 )
VAR_2 = -VAR_7;
VAR_3 = 1;
getvcpucontext_out:
xfree(VAR_24.nat);
break;
}
case VAR_57:
{
struct vcpu   *VAR_26;
struct vcpu_runstate_info VAR_58;
VAR_2 = -VAR_27;
if ( VAR_5->u.getvcpuinfo.vcpu >= d->max_vcpus )
break;
VAR_2 = -VAR_15;
if ( (VAR_26 = d->vcpu[VAR_5->u.getvcpuinfo.vcpu]) == NULL )
break;
vcpu_runstate_get(VAR_26, &VAR_58);
VAR_5->u.getvcpuinfo.online   = !(VAR_26->pause_flags & VAR_59);
VAR_5->u.getvcpuinfo.blocked  = !!(VAR_26->pause_flags & VAR_60);
VAR_5->u.getvcpuinfo.running  = VAR_26->is_running;
VAR_5->u.getvcpuinfo.cpu_time = VAR_58.time[VAR_61];
VAR_5->u.getvcpuinfo.cpu      = VAR_26->processor;
VAR_2 = 0;
VAR_3 = 1;
break;
}
case VAR_62:
{
uint64_t VAR_63 = VAR_5->u.max_mem.max_memkb >> (VAR_64 - 10);
spin_lock(&d->page_alloc_lock);
d->max_pages = min(VAR_63, (uint64_t)(typeof(d->max_pages))-1);
spin_unlock(&d->page_alloc_lock);
break;
}
case VAR_65:
memcpy(d->handle, VAR_5->u.setdomainhandle.handle,
sizeof(VAR_66));
break;
case VAR_67:
if ( unlikely(d == VAR_28->domain) ) 
VAR_2 = -VAR_27;
else
{
domain_pause(d);
d->debugger_attached = !!VAR_5->u.setdebugging.enable;
domain_unpause(d); 
}
break;
case VAR_68:
{
unsigned int VAR_69 = VAR_5->u.irq_permission.pirq, VAR_70;
int VAR_71 = VAR_5->u.irq_permission.allow_access;
if ( VAR_69 >= VAR_28->domain->nr_pirqs )
{
VAR_2 = -VAR_27;
break;
}
VAR_70 = pirq_access_permitted(VAR_28->domain, VAR_69);
if ( !VAR_70 || xsm_irq_permission(VAR_54, d, VAR_70, VAR_71) )
VAR_2 = -VAR_72;
else if ( VAR_71 )
VAR_2 = irq_permit_access(d, VAR_70);
else
VAR_2 = irq_deny_access(d, VAR_70);
break;
}
case VAR_73:
{
unsigned long VAR_74 = VAR_5->u.iomem_permission.first_mfn;
unsigned long VAR_75 = VAR_5->u.iomem_permission.nr_mfns;
int VAR_71 = VAR_5->u.iomem_permission.allow_access;
VAR_2 = -VAR_27;
if ( (VAR_74 + VAR_75 - 1) < VAR_74 ) 
break;
if ( !iomem_access_permitted(VAR_28->domain,
VAR_74, VAR_74 + VAR_75 - 1) ||
xsm_iomem_permission(VAR_54, d, VAR_74, VAR_74 + VAR_75 - 1, VAR_71) )
VAR_2 = -VAR_72;
else if ( VAR_71 )
VAR_2 = iomem_permit_access(d, VAR_74, VAR_74 + VAR_75 - 1);
else
VAR_2 = iomem_deny_access(d, VAR_74, VAR_74 + VAR_75 - 1);
if ( !VAR_2 )
memory_type_changed(d);
break;
}
case VAR_76:
{
unsigned long VAR_77 = VAR_5->u.memory_mapping.first_gfn;
unsigned long VAR_74 = VAR_5->u.memory_mapping.first_mfn;
unsigned long VAR_75 = VAR_5->u.memory_mapping.nr_mfns;
unsigned long VAR_78 = VAR_74 + VAR_75 - 1;
int VAR_79 = VAR_5->u.memory_mapping.add_mapping;
VAR_2 = -VAR_27;
if ( VAR_78 < VAR_74 || 
((VAR_74 | VAR_78) >> (VAR_80 - VAR_64)) ||
(VAR_77 + VAR_75 - 1) < VAR_77 ) 
break;
#ifndef VAR_81 
VAR_2 = -VAR_82;
if ( VAR_75 > 64 )
break;
#endif
VAR_2 = -VAR_72;
if ( !iomem_access_permitted(VAR_28->domain, VAR_74, VAR_78) ||
!iomem_access_permitted(d, VAR_74, VAR_78) )
break;
VAR_2 = xsm_iomem_mapping(VAR_54, d, VAR_74, VAR_78, VAR_79);
if ( VAR_2 )
break;
if ( VAR_79 )
{
VAR_83(VAR_84
""memory_map:add: dom%d gfn=%lx mfn=%lx nr=%lx\n"",
d->domain_id, VAR_77, VAR_74, VAR_75);
VAR_2 = map_mmio_regions(d, _gfn(VAR_77), VAR_75, _mfn(VAR_74));
if ( VAR_2 < 0 )
VAR_83(XENLOG_G_WARNING
""memory_map:fail: dom%d gfn=%lx mfn=%lx nr=%lx ret:%ld\n"",
d->domain_id, VAR_77, VAR_74, VAR_75, VAR_2);
}
else
{
VAR_83(VAR_84
""memory_map:remove: dom%d gfn=%lx mfn=%lx nr=%lx\n"",
d->domain_id, VAR_77, VAR_74, VAR_75);
VAR_2 = unmap_mmio_regions(d, _gfn(VAR_77), VAR_75, _mfn(VAR_74));
if ( VAR_2 < 0 && is_hardware_domain(VAR_28->domain) )
VAR_83(XENLOG_ERR
""memory_map: error %ld removing dom%d access to [%lx,%lx]\n"",
VAR_2, d->domain_id, VAR_74, VAR_78);
}
memory_type_changed(d);
break;
}
case VAR_85:
domain_set_time_offset(d, VAR_5->u.settimeoffset.time_offset_seconds);
break;
case VAR_86:
{
struct domain *VAR_87;
VAR_2 = -VAR_15;
VAR_87 = get_domain_by_id(VAR_5->u.set_target.target);
if ( VAR_87 == NULL )
break;
VAR_2 = -VAR_27;
if ( (d == VAR_87) || (d->target != NULL) )
{
put_domain(VAR_87);
break;
}
VAR_2 = -VAR_88;
if ( is_hvm_domain(VAR_87) )
VAR_2 = xsm_set_target(VAR_54, d, VAR_87);
if ( VAR_2 )
{
put_domain(VAR_87);
break;
}
d->target = VAR_87;
break;
}
case VAR_89:
d->suspend_evtchn = VAR_5->u.subscribe.port;
break;
case VAR_17:
VAR_2 = vm_event_domctl(d, &VAR_5->u.vm_event_op);
if ( VAR_2 == 0 )
VAR_3 = true;
break;
#ifdef VAR_90
case VAR_91:
if ( unlikely(VAR_28->domain == d) ) 
VAR_2 = -VAR_72;
else
{
domain_pause(d);
arch_p2m_set_access_required(d,
VAR_5->u.access_required.access_required);
domain_unpause(d);
}
break;
#endif
case VAR_92:
VAR_2 = set_global_virq_handler(d, VAR_5->u.set_virq_handler.virq);
break;
case VAR_93:
{
struct vnuma_info *VAR_94;
VAR_94 = vnuma_init(&VAR_5->u.vnuma, d);
if ( IS_ERR(VAR_94) )
{
VAR_2 = PTR_ERR(VAR_94);
break;
}
write_lock(&d->vnuma_rwlock);
vnuma_destroy(d->vnuma);
d->vnuma = VAR_94;
write_unlock(&d->vnuma_rwlock);
break;
}
case VAR_95:
VAR_2 = monitor_domctl(d, &VAR_5->u.monitor_op);
if ( !VAR_2 )
VAR_3 = 1;
break;
default:
VAR_2 = arch_do_domctl(VAR_5, d, VAR_1);
break;
}
domctl_lock_release();
domctl_out_unlock_domonly:
if ( d && d != VAR_13 )
rcu_unlock_domain(d);
if ( VAR_3 && __copy_to_guest(VAR_1, VAR_5, 1) )
VAR_2 = -VAR_7;
return VAR_2;
}",,"long do_domctl(XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)
{
    long ret = 0;
    bool_t copyback = 0;
    struct xen_domctl curop, *op = &curop;
    struct domain *d;

    if ( copy_from_guest(op, u_domctl, 1) )
        return -EFAULT;

    if ( op->interface_version != XEN_DOMCTL_INTERFACE_VERSION )
        return -EACCES;

    switch ( op->cmd )
    {
    case XEN_DOMCTL_assign_device:
    case XEN_DOMCTL_deassign_device:
        if ( op->domain == DOMID_IO )
        {
            d = dom_io;
            break;
        }
        else if ( op->domain == DOMID_INVALID )
            return -ESRCH;
        /* fall through */
    case XEN_DOMCTL_test_assign_device:
    case XEN_DOMCTL_vm_event_op:
        if ( op->domain == DOMID_INVALID )
        {
    case XEN_DOMCTL_createdomain:
    case XEN_DOMCTL_gdbsx_guestmemio:
            d = NULL;
            break;
        }
        /* fall through */
    default:
        d = rcu_lock_domain_by_id(op->domain);
        if ( !d && op->cmd != XEN_DOMCTL_getdomaininfo )
            return -ESRCH;
    }

    ret = xsm_domctl(XSM_OTHER, d, op->cmd);
    if ( ret )
        goto domctl_out_unlock_domonly;

    if ( !domctl_lock_acquire() )
    {
        if ( d && d != dom_io )
            rcu_unlock_domain(d);
        return hypercall_create_continuation(
            __HYPERVISOR_domctl, ""h"", u_domctl);
    }

    switch ( op->cmd )
    {

    case XEN_DOMCTL_setvcpucontext:
    {
        vcpu_guest_context_u c = { .nat = NULL };
        unsigned int vcpu = op->u.vcpucontext.vcpu;
        struct vcpu *v;

        ret = -EINVAL;
        if ( (d == current->domain) || /* no domain_pause() */
             (vcpu >= d->max_vcpus) || ((v = d->vcpu[vcpu]) == NULL) )
            break;

        if ( guest_handle_is_null(op->u.vcpucontext.ctxt) )
        {
            ret = vcpu_reset(v);
            if ( ret == -ERESTART )
                ret = hypercall_create_continuation(
                          __HYPERVISOR_domctl, ""h"", u_domctl);
            break;
        }

#ifdef CONFIG_COMPAT
        BUILD_BUG_ON(sizeof(struct vcpu_guest_context)
                     < sizeof(struct compat_vcpu_guest_context));
#endif
        ret = -ENOMEM;
        if ( (c.nat = alloc_vcpu_guest_context()) == NULL )
            break;

#ifdef CONFIG_COMPAT
        if ( !is_pv_32bit_domain(d) )
            ret = copy_from_guest(c.nat, op->u.vcpucontext.ctxt, 1);
        else
            ret = copy_from_guest(c.cmp,
                                  guest_handle_cast(op->u.vcpucontext.ctxt,
                                                    void), 1);
#else
        ret = copy_from_guest(c.nat, op->u.vcpucontext.ctxt, 1);
#endif
        ret = ret ? -EFAULT : 0;

        if ( ret == 0 )
        {
            domain_pause(d);
            ret = arch_set_info_guest(v, c);
            domain_unpause(d);

            if ( ret == -ERESTART )
                ret = hypercall_create_continuation(
                          __HYPERVISOR_domctl, ""h"", u_domctl);
        }

        free_vcpu_guest_context(c.nat);
        break;
    }

    case XEN_DOMCTL_pausedomain:
        ret = -EINVAL;
        if ( d != current->domain )
            ret = domain_pause_by_systemcontroller(d);
        break;

    case XEN_DOMCTL_unpausedomain:
        ret = domain_unpause_by_systemcontroller(d);
        break;

    case XEN_DOMCTL_resumedomain:
        if ( d == current->domain ) /* no domain_pause() */
            ret = -EINVAL;
        else
            domain_resume(d);
        break;

    case XEN_DOMCTL_createdomain:
    {
        domid_t        dom;
        static domid_t rover = 0;

        dom = op->domain;
        if ( (dom > 0) && (dom < DOMID_FIRST_RESERVED) )
        {
            ret = -EEXIST;
            if ( !is_free_domid(dom) )
                break;
        }
        else
        {
            for ( dom = rover + 1; dom != rover; dom++ )
            {
                if ( dom == DOMID_FIRST_RESERVED )
                    dom = 1;
                if ( is_free_domid(dom) )
                    break;
            }

            ret = -ENOMEM;
            if ( dom == rover )
                break;

            rover = dom;
        }

        d = domain_create(dom, &op->u.createdomain, false);
        if ( IS_ERR(d) )
        {
            ret = PTR_ERR(d);
            d = NULL;
            break;
        }

        ret = 0;
        op->domain = d->domain_id;
        copyback = 1;
        d = NULL;
        break;
    }

    case XEN_DOMCTL_max_vcpus:
    {
        unsigned int i, max = op->u.max_vcpus.max;

        ret = -EINVAL;
        if ( (d == current->domain) || /* no domain_pause() */
             (max != d->max_vcpus) )   /* max_vcpus set up in createdomain */
            break;

        /* Needed, for example, to ensure writable p.t. state is synced. */
        domain_pause(d);

        ret = -ENOMEM;

        for ( i = 0; i < max; i++ )
        {
            if ( d->vcpu[i] != NULL )
                continue;

            if ( vcpu_create(d, i) == NULL )
                goto maxvcpu_out;
        }

        domain_update_node_affinity(d);
        ret = 0;

    maxvcpu_out:
        domain_unpause(d);
        break;
    }

    case XEN_DOMCTL_soft_reset:
    case XEN_DOMCTL_soft_reset_cont:
        if ( d == current->domain ) /* no domain_pause() */
        {
            ret = -EINVAL;
            break;
        }
        ret = domain_soft_reset(d, op->cmd == XEN_DOMCTL_soft_reset_cont);
        if ( ret == -ERESTART )
        {
            op->cmd = XEN_DOMCTL_soft_reset_cont;
            if ( !__copy_field_to_guest(u_domctl, op, cmd) )
                ret = hypercall_create_continuation(__HYPERVISOR_domctl,
                                                    ""h"", u_domctl);
            else
                ret = -EFAULT;
        }
        break;

    case XEN_DOMCTL_destroydomain:
        domctl_lock_release();
        domain_lock(d);
        ret = domain_kill(d);
        domain_unlock(d);
        if ( ret == -ERESTART )
            ret = hypercall_create_continuation(
                __HYPERVISOR_domctl, ""h"", u_domctl);
        goto domctl_out_unlock_domonly;

    case XEN_DOMCTL_setnodeaffinity:
    {
        nodemask_t new_affinity;

        ret = xenctl_bitmap_to_nodemask(&new_affinity,
                                        &op->u.nodeaffinity.nodemap);
        if ( !ret )
            ret = domain_set_node_affinity(d, &new_affinity);
        break;
    }

    case XEN_DOMCTL_getnodeaffinity:
        ret = nodemask_to_xenctl_bitmap(&op->u.nodeaffinity.nodemap,
                                        &d->node_affinity);
        break;

    case XEN_DOMCTL_setvcpuaffinity:
    case XEN_DOMCTL_getvcpuaffinity:
        ret = vcpu_affinity_domctl(d, op->cmd, &op->u.vcpuaffinity);
        break;

    case XEN_DOMCTL_scheduler_op:
        ret = sched_adjust(d, &op->u.scheduler_op);
        copyback = 1;
        break;

    case XEN_DOMCTL_getdomaininfo:
    {
        domid_t dom = DOMID_INVALID;

        if ( !d )
        {
            ret = -EINVAL;
            if ( op->domain >= DOMID_FIRST_RESERVED )
                break;

            rcu_read_lock(&domlist_read_lock);

            dom = op->domain;
            for_each_domain ( d )
                if ( d->domain_id >= dom )
                    break;
        }

        ret = -ESRCH;
        if ( d == NULL )
            goto getdomaininfo_out;

        ret = xsm_getdomaininfo(XSM_HOOK, d);
        if ( ret )
            goto getdomaininfo_out;

        getdomaininfo(d, &op->u.getdomaininfo);

        op->domain = op->u.getdomaininfo.domain;
        copyback = 1;

    getdomaininfo_out:
        /* When d was non-NULL upon entry, no cleanup is needed. */
        if ( dom == DOMID_INVALID )
            break;

        rcu_read_unlock(&domlist_read_lock);
        d = NULL;
        break;
    }

    case XEN_DOMCTL_getvcpucontext:
    {
        vcpu_guest_context_u c = { .nat = NULL };
        struct vcpu         *v;

        ret = -EINVAL;
        if ( op->u.vcpucontext.vcpu >= d->max_vcpus ||
             (v = d->vcpu[op->u.vcpucontext.vcpu]) == NULL ||
             v == current ) /* no vcpu_pause() */
            goto getvcpucontext_out;

        ret = -ENODATA;
        if ( !v->is_initialised )
            goto getvcpucontext_out;

#ifdef CONFIG_COMPAT
        BUILD_BUG_ON(sizeof(struct vcpu_guest_context)
                     < sizeof(struct compat_vcpu_guest_context));
#endif
        ret = -ENOMEM;
        if ( (c.nat = xzalloc(struct vcpu_guest_context)) == NULL )
            goto getvcpucontext_out;

        vcpu_pause(v);

        arch_get_info_guest(v, c);
        ret = 0;

        vcpu_unpause(v);

#ifdef CONFIG_COMPAT
        if ( !is_pv_32bit_domain(d) )
            ret = copy_to_guest(op->u.vcpucontext.ctxt, c.nat, 1);
        else
            ret = copy_to_guest(guest_handle_cast(op->u.vcpucontext.ctxt,
                                                  void), c.cmp, 1);
#else
        ret = copy_to_guest(op->u.vcpucontext.ctxt, c.nat, 1);
#endif

        if ( ret )
            ret = -EFAULT;
        copyback = 1;

    getvcpucontext_out:
        xfree(c.nat);
        break;
    }

    case XEN_DOMCTL_getvcpuinfo:
    {
        struct vcpu   *v;
        struct vcpu_runstate_info runstate;

        ret = -EINVAL;
        if ( op->u.getvcpuinfo.vcpu >= d->max_vcpus )
            break;

        ret = -ESRCH;
        if ( (v = d->vcpu[op->u.getvcpuinfo.vcpu]) == NULL )
            break;

        vcpu_runstate_get(v, &runstate);

        op->u.getvcpuinfo.online   = !(v->pause_flags & VPF_down);
        op->u.getvcpuinfo.blocked  = !!(v->pause_flags & VPF_blocked);
        op->u.getvcpuinfo.running  = v->is_running;
        op->u.getvcpuinfo.cpu_time = runstate.time[RUNSTATE_running];
        op->u.getvcpuinfo.cpu      = v->processor;
        ret = 0;
        copyback = 1;
        break;
    }

    case XEN_DOMCTL_max_mem:
    {
        uint64_t new_max = op->u.max_mem.max_memkb >> (PAGE_SHIFT - 10);

        spin_lock(&d->page_alloc_lock);
        /*
         * NB. We removed a check that new_max >= current tot_pages; this means
         * that the domain will now be allowed to ""ratchet"" down to new_max. In
         * the meantime, while tot > max, all new allocations are disallowed.
         */
        d->max_pages = min(new_max, (uint64_t)(typeof(d->max_pages))-1);
        spin_unlock(&d->page_alloc_lock);
        break;
    }

    case XEN_DOMCTL_setdomainhandle:
        memcpy(d->handle, op->u.setdomainhandle.handle,
               sizeof(xen_domain_handle_t));
        break;

    case XEN_DOMCTL_setdebugging:
        if ( unlikely(d == current->domain) ) /* no domain_pause() */
            ret = -EINVAL;
        else
        {
            domain_pause(d);
            d->debugger_attached = !!op->u.setdebugging.enable;
            domain_unpause(d); /* causes guest to latch new status */
        }
        break;

    case XEN_DOMCTL_irq_permission:
    {
        unsigned int pirq = op->u.irq_permission.pirq, irq;
        int allow = op->u.irq_permission.allow_access;

        if ( pirq >= current->domain->nr_pirqs )
        {
            ret = -EINVAL;
            break;
        }
        irq = pirq_access_permitted(current->domain, pirq);
        if ( !irq || xsm_irq_permission(XSM_HOOK, d, irq, allow) )
            ret = -EPERM;
        else if ( allow )
            ret = irq_permit_access(d, irq);
        else
            ret = irq_deny_access(d, irq);
        break;
    }

    case XEN_DOMCTL_iomem_permission:
    {
        unsigned long mfn = op->u.iomem_permission.first_mfn;
        unsigned long nr_mfns = op->u.iomem_permission.nr_mfns;
        int allow = op->u.iomem_permission.allow_access;

        ret = -EINVAL;
        if ( (mfn + nr_mfns - 1) < mfn ) /* wrap? */
            break;

        if ( !iomem_access_permitted(current->domain,
                                     mfn, mfn + nr_mfns - 1) ||
             xsm_iomem_permission(XSM_HOOK, d, mfn, mfn + nr_mfns - 1, allow) )
            ret = -EPERM;
        else if ( allow )
            ret = iomem_permit_access(d, mfn, mfn + nr_mfns - 1);
        else
            ret = iomem_deny_access(d, mfn, mfn + nr_mfns - 1);
        if ( !ret )
            memory_type_changed(d);
        break;
    }

    case XEN_DOMCTL_memory_mapping:
    {
        unsigned long gfn = op->u.memory_mapping.first_gfn;
        unsigned long mfn = op->u.memory_mapping.first_mfn;
        unsigned long nr_mfns = op->u.memory_mapping.nr_mfns;
        unsigned long mfn_end = mfn + nr_mfns - 1;
        int add = op->u.memory_mapping.add_mapping;

        ret = -EINVAL;
        if ( mfn_end < mfn || /* wrap? */
             ((mfn | mfn_end) >> (paddr_bits - PAGE_SHIFT)) ||
             (gfn + nr_mfns - 1) < gfn ) /* wrap? */
            break;

#ifndef CONFIG_X86 /* XXX ARM!? */
        ret = -E2BIG;
        /* Must break hypercall up as this could take a while. */
        if ( nr_mfns > 64 )
            break;
#endif

        ret = -EPERM;
        if ( !iomem_access_permitted(current->domain, mfn, mfn_end) ||
             !iomem_access_permitted(d, mfn, mfn_end) )
            break;

        ret = xsm_iomem_mapping(XSM_HOOK, d, mfn, mfn_end, add);
        if ( ret )
            break;

        if ( add )
        {
            printk(XENLOG_G_DEBUG
                   ""memory_map:add: dom%d gfn=%lx mfn=%lx nr=%lx\n"",
                   d->domain_id, gfn, mfn, nr_mfns);

            ret = map_mmio_regions(d, _gfn(gfn), nr_mfns, _mfn(mfn));
            if ( ret < 0 )
                printk(XENLOG_G_WARNING
                       ""memory_map:fail: dom%d gfn=%lx mfn=%lx nr=%lx ret:%ld\n"",
                       d->domain_id, gfn, mfn, nr_mfns, ret);
        }
        else
        {
            printk(XENLOG_G_DEBUG
                   ""memory_map:remove: dom%d gfn=%lx mfn=%lx nr=%lx\n"",
                   d->domain_id, gfn, mfn, nr_mfns);

            ret = unmap_mmio_regions(d, _gfn(gfn), nr_mfns, _mfn(mfn));
            if ( ret < 0 && is_hardware_domain(current->domain) )
                printk(XENLOG_ERR
                       ""memory_map: error %ld removing dom%d access to [%lx,%lx]\n"",
                       ret, d->domain_id, mfn, mfn_end);
        }
        /* Do this unconditionally to cover errors on above failure paths. */
        memory_type_changed(d);
        break;
    }

    case XEN_DOMCTL_settimeoffset:
        domain_set_time_offset(d, op->u.settimeoffset.time_offset_seconds);
        break;

    case XEN_DOMCTL_set_target:
    {
        struct domain *e;

        ret = -ESRCH;
        e = get_domain_by_id(op->u.set_target.target);
        if ( e == NULL )
            break;

        ret = -EINVAL;
        if ( (d == e) || (d->target != NULL) )
        {
            put_domain(e);
            break;
        }

        ret = -EOPNOTSUPP;
        if ( is_hvm_domain(e) )
            ret = xsm_set_target(XSM_HOOK, d, e);
        if ( ret )
        {
            put_domain(e);
            break;
        }

        /* Hold reference on @e until we destroy @d. */
        d->target = e;
        break;
    }

    case XEN_DOMCTL_subscribe:
        d->suspend_evtchn = op->u.subscribe.port;
        break;

    case XEN_DOMCTL_vm_event_op:
        ret = vm_event_domctl(d, &op->u.vm_event_op);
        if ( ret == 0 )
            copyback = true;
        break;

#ifdef CONFIG_MEM_ACCESS
    case XEN_DOMCTL_set_access_required:
        if ( unlikely(current->domain == d) ) /* no domain_pause() */
            ret = -EPERM;
        else
        {
            domain_pause(d);
            arch_p2m_set_access_required(d,
                op->u.access_required.access_required);
            domain_unpause(d);
        }
        break;
#endif

    case XEN_DOMCTL_set_virq_handler:
        ret = set_global_virq_handler(d, op->u.set_virq_handler.virq);
        break;

    case XEN_DOMCTL_setvnumainfo:
    {
        struct vnuma_info *vnuma;

        vnuma = vnuma_init(&op->u.vnuma, d);
        if ( IS_ERR(vnuma) )
        {
            ret = PTR_ERR(vnuma);
            break;
        }

        /* overwrite vnuma topology for domain. */
        write_lock(&d->vnuma_rwlock);
        vnuma_destroy(d->vnuma);
        d->vnuma = vnuma;
        write_unlock(&d->vnuma_rwlock);

        break;
    }

    case XEN_DOMCTL_monitor_op:
        ret = monitor_domctl(d, &op->u.monitor_op);
        if ( !ret )
            copyback = 1;
        break;

    default:
        ret = arch_do_domctl(op, d, u_domctl);
        break;
    }

    domctl_lock_release();

 domctl_out_unlock_domonly:
    if ( d && d != dom_io )
        rcu_unlock_domain(d);

    if ( copyback && __copy_to_guest(u_domctl, op, 1) )
        ret = -EFAULT;

    return ret;
}","long do_domctl(VAR_0(xen_domctl_t) VAR_1)
{
    long VAR_2 = 0;
    bool_t VAR_3 = 0;
    struct xen_domctl VAR_4, *VAR_5 = &VAR_4;
    struct domain *VAR_6;

    if ( copy_from_guest(VAR_5, VAR_1, 1) )
        return -VAR_7;

    if ( VAR_5->interface_version != VAR_8 )
        return -VAR_9;

    switch ( VAR_5->cmd )
    {
    case VAR_10:
    case VAR_11:
        if ( VAR_5->domain == VAR_12 )
        {
            VAR_6 = VAR_13;
            break;
        }
        else if ( VAR_5->domain == VAR_14 )
            return -VAR_15;
        /* COMMENT_0 */
    case VAR_16:
    case VAR_17:
        if ( VAR_5->domain == VAR_14 )
        {
    case VAR_18:
    case VAR_19:
            VAR_6 = NULL;
            break;
        }
        /* COMMENT_0 */
    default:
        VAR_6 = rcu_lock_domain_by_id(VAR_5->domain);
        if ( !VAR_6 && VAR_5->cmd != VAR_20 )
            return -VAR_15;
    }

    VAR_2 = xsm_domctl(VAR_21, VAR_6, VAR_5->cmd);
    if ( VAR_2 )
        goto domctl_out_unlock_domonly;

    if ( !domctl_lock_acquire() )
    {
        if ( VAR_6 && VAR_6 != VAR_13 )
            rcu_unlock_domain(VAR_6);
        return hypercall_create_continuation(
            VAR_22, ""h"", VAR_1);
    }

    switch ( VAR_5->cmd )
    {

    case VAR_23:
    {
        vcpu_guest_context_u VAR_24 = { .nat = NULL };
        unsigned int VAR_25 = VAR_5->u.vcpucontext.vcpu;
        struct vcpu *VAR_26;

        VAR_2 = -VAR_27;
        if ( (VAR_6 == VAR_28->domain) || /* COMMENT_1 */
             (vcpu >= VAR_6->max_vcpus) || ((VAR_26 = VAR_6->vcpu[vcpu]) == NULL) )
            break;

        if ( guest_handle_is_null(VAR_5->u.vcpucontext.ctxt) )
        {
            VAR_2 = vcpu_reset(VAR_26);
            if ( VAR_2 == -VAR_29 )
                VAR_2 = hypercall_create_continuation(
                          VAR_22, ""h"", VAR_1);
            break;
        }

#ifdef VAR_30
        BUILD_BUG_ON(sizeof(struct vcpu_guest_context)
                     < sizeof(struct compat_vcpu_guest_context));
#endif
        VAR_2 = -VAR_31;
        if ( (VAR_24.nat = alloc_vcpu_guest_context()) == NULL )
            break;

#ifdef VAR_30
        if ( !is_pv_32bit_domain(VAR_6) )
            VAR_2 = copy_from_guest(VAR_24.nat, VAR_5->u.vcpucontext.ctxt, 1);
        else
            VAR_2 = copy_from_guest(VAR_24.cmp,
                                  guest_handle_cast(VAR_5->u.vcpucontext.ctxt,
                                                    VAR_32), 1);
#else
        VAR_2 = copy_from_guest(VAR_24.nat, VAR_5->u.vcpucontext.ctxt, 1);
#endif
        VAR_2 = VAR_2 ? -VAR_7 : 0;

        if ( VAR_2 == 0 )
        {
            domain_pause(VAR_6);
            VAR_2 = arch_set_info_guest(VAR_26, VAR_24);
            domain_unpause(VAR_6);

            if ( VAR_2 == -VAR_29 )
                VAR_2 = hypercall_create_continuation(
                          VAR_22, ""h"", VAR_1);
        }

        free_vcpu_guest_context(VAR_24.nat);
        break;
    }

    case VAR_33:
        VAR_2 = -VAR_27;
        if ( VAR_6 != VAR_28->domain )
            VAR_2 = domain_pause_by_systemcontroller(VAR_6);
        break;

    case VAR_34:
        VAR_2 = domain_unpause_by_systemcontroller(VAR_6);
        break;

    case VAR_35:
        if ( VAR_6 == VAR_28->domain ) /* COMMENT_1 */
            VAR_2 = -VAR_27;
        else
            domain_resume(VAR_6);
        break;

    case VAR_18:
    {
        domid_t        VAR_36;
        static domid_t VAR_37 = 0;

        VAR_36 = VAR_5->domain;
        if ( (VAR_36 > 0) && (VAR_36 < VAR_38) )
        {
            VAR_2 = -VAR_39;
            if ( !is_free_domid(VAR_36) )
                break;
        }
        else
        {
            for ( VAR_36 = VAR_37 + 1; VAR_36 != VAR_37; VAR_36++ )
            {
                if ( VAR_36 == VAR_38 )
                    VAR_36 = 1;
                if ( is_free_domid(VAR_36) )
                    break;
            }

            VAR_2 = -VAR_31;
            if ( VAR_36 == VAR_37 )
                break;

            VAR_37 = VAR_36;
        }

        VAR_6 = domain_create(VAR_36, &VAR_5->u.createdomain, false);
        if ( IS_ERR(VAR_6) )
        {
            VAR_2 = PTR_ERR(VAR_6);
            VAR_6 = NULL;
            break;
        }

        VAR_2 = 0;
        VAR_5->domain = VAR_6->domain_id;
        VAR_3 = 1;
        VAR_6 = NULL;
        break;
    }

    case VAR_40:
    {
        unsigned int VAR_41, VAR_42 = VAR_5->u.max_vcpus.max;

        VAR_2 = -VAR_27;
        if ( (VAR_6 == VAR_28->domain) || /* COMMENT_1 */
             (VAR_42 != VAR_6->max_vcpus) )   /* COMMENT_2 */
            break;

        /* COMMENT_3 */
        domain_pause(VAR_6);

        VAR_2 = -VAR_31;

        for ( VAR_41 = 0; VAR_41 < VAR_42; VAR_41++ )
        {
            if ( VAR_6->vcpu[VAR_41] != NULL )
                continue;

            if ( vcpu_create(VAR_6, VAR_41) == NULL )
                goto maxvcpu_out;
        }

        domain_update_node_affinity(VAR_6);
        VAR_2 = 0;

    maxvcpu_out:
        domain_unpause(VAR_6);
        break;
    }

    case VAR_43:
    case VAR_44:
        if ( VAR_6 == VAR_28->domain ) /* COMMENT_1 */
        {
            VAR_2 = -VAR_27;
            break;
        }
        VAR_2 = domain_soft_reset(VAR_6, VAR_5->cmd == VAR_44);
        if ( VAR_2 == -VAR_29 )
        {
            VAR_5->cmd = VAR_44;
            if ( !__copy_field_to_guest(VAR_1, VAR_5, VAR_45) )
                VAR_2 = hypercall_create_continuation(VAR_22,
                                                    ""h"", VAR_1);
            else
                VAR_2 = -VAR_7;
        }
        break;

    case VAR_46:
        domctl_lock_release();
        domain_lock(VAR_6);
        VAR_2 = domain_kill(VAR_6);
        domain_unlock(VAR_6);
        if ( VAR_2 == -VAR_29 )
            VAR_2 = hypercall_create_continuation(
                VAR_22, ""h"", VAR_1);
        goto domctl_out_unlock_domonly;

    case VAR_47:
    {
        nodemask_t VAR_48;

        VAR_2 = xenctl_bitmap_to_nodemask(&VAR_48,
                                        &VAR_5->u.nodeaffinity.nodemap);
        if ( !VAR_2 )
            VAR_2 = domain_set_node_affinity(VAR_6, &VAR_48);
        break;
    }

    case VAR_49:
        VAR_2 = nodemask_to_xenctl_bitmap(&VAR_5->u.nodeaffinity.nodemap,
                                        &VAR_6->node_affinity);
        break;

    case VAR_50:
    case VAR_51:
        VAR_2 = vcpu_affinity_domctl(VAR_6, VAR_5->cmd, &VAR_5->u.vcpuaffinity);
        break;

    case VAR_52:
        VAR_2 = sched_adjust(VAR_6, &VAR_5->u.scheduler_op);
        VAR_3 = 1;
        break;

    case VAR_20:
    {
        domid_t VAR_36 = VAR_14;

        if ( !VAR_6 )
        {
            VAR_2 = -VAR_27;
            if ( VAR_5->domain >= VAR_38 )
                break;

            rcu_read_lock(&VAR_53);

            VAR_36 = VAR_5->domain;
            VAR_54 ( d )
                if ( d->VAR_55 >= VAR_36 )
                    break;
        }

        VAR_2 = -VAR_15;
        if ( d == NULL )
            goto getdomaininfo_out;

        VAR_2 = xsm_getdomaininfo(VAR_56, d);
        if ( VAR_2 )
            goto getdomaininfo_out;

        getdomaininfo(d, &VAR_5->u.getdomaininfo);

        VAR_5->domain = VAR_5->u.getdomaininfo.domain;
        VAR_3 = 1;

    getdomaininfo_out:
        /* COMMENT_4 */
        if ( VAR_36 == VAR_14 )
            break;

        rcu_read_unlock(&VAR_53);
        d = NULL;
        break;
    }

    case VAR_57:
    {
        vcpu_guest_context_u VAR_24 = { .nat = NULL };
        struct vcpu         *VAR_26;

        VAR_2 = -VAR_27;
        if ( VAR_5->u.vcpucontext.vcpu >= d->max_vcpus ||
             (VAR_26 = d->vcpu[VAR_5->u.vcpucontext.vcpu]) == NULL ||
             VAR_26 == VAR_28 ) /* COMMENT_5 */
            goto getvcpucontext_out;

        VAR_2 = -VAR_58;
        if ( !VAR_26->is_initialised )
            goto getvcpucontext_out;

#ifdef VAR_30
        BUILD_BUG_ON(sizeof(struct vcpu_guest_context)
                     < sizeof(struct compat_vcpu_guest_context));
#endif
        VAR_2 = -VAR_31;
        if ( (VAR_24.nat = xzalloc(struct vcpu_guest_context)) == NULL )
            goto getvcpucontext_out;

        vcpu_pause(VAR_26);

        arch_get_info_guest(VAR_26, VAR_24);
        VAR_2 = 0;

        vcpu_unpause(VAR_26);

#ifdef VAR_30
        if ( !is_pv_32bit_domain(d) )
            VAR_2 = copy_to_guest(VAR_5->u.vcpucontext.ctxt, VAR_24.nat, 1);
        else
            VAR_2 = copy_to_guest(guest_handle_cast(VAR_5->u.vcpucontext.ctxt,
                                                  VAR_32), VAR_24.cmp, 1);
#else
        VAR_2 = copy_to_guest(VAR_5->u.vcpucontext.ctxt, VAR_24.nat, 1);
#endif

        if ( VAR_2 )
            VAR_2 = -VAR_7;
        VAR_3 = 1;

    getvcpucontext_out:
        xfree(VAR_24.nat);
        break;
    }

    case VAR_59:
    {
        struct vcpu   *VAR_26;
        struct vcpu_runstate_info VAR_60;

        VAR_2 = -VAR_27;
        if ( VAR_5->u.getvcpuinfo.vcpu >= d->max_vcpus )
            break;

        VAR_2 = -VAR_15;
        if ( (VAR_26 = d->vcpu[VAR_5->u.getvcpuinfo.vcpu]) == NULL )
            break;

        vcpu_runstate_get(VAR_26, &VAR_60);

        VAR_5->u.getvcpuinfo.online   = !(VAR_26->pause_flags & VAR_61);
        VAR_5->u.getvcpuinfo.blocked  = !!(VAR_26->pause_flags & VAR_62);
        VAR_5->u.getvcpuinfo.running  = VAR_26->is_running;
        VAR_5->u.getvcpuinfo.cpu_time = VAR_60.time[VAR_63];
        VAR_5->u.getvcpuinfo.cpu      = VAR_26->processor;
        VAR_2 = 0;
        VAR_3 = 1;
        break;
    }

    case VAR_64:
    {
        uint64_t VAR_65 = VAR_5->u.max_mem.max_memkb >> (VAR_66 - 10);

        spin_lock(&d->page_alloc_lock);
        /* COMMENT_6 */
                                                                               
                                                                               
                                                                             
           
        d->max_pages = min(VAR_65, (uint64_t)(typeof(d->max_pages))-1);
        spin_unlock(&d->page_alloc_lock);
        break;
    }

    case VAR_67:
        memcpy(d->handle, VAR_5->u.setdomainhandle.handle,
               sizeof(VAR_68));
        break;

    case VAR_69:
        if ( unlikely(d == VAR_28->domain) ) /* COMMENT_1 */
            VAR_2 = -VAR_27;
        else
        {
            domain_pause(d);
            d->debugger_attached = !!VAR_5->u.setdebugging.enable;
            domain_unpause(d); /* COMMENT_11 */
        }
        break;

    case VAR_70:
    {
        unsigned int VAR_71 = VAR_5->u.irq_permission.pirq, VAR_72;
        int VAR_73 = VAR_5->u.irq_permission.allow_access;

        if ( VAR_71 >= VAR_28->domain->nr_pirqs )
        {
            VAR_2 = -VAR_27;
            break;
        }
        VAR_72 = pirq_access_permitted(VAR_28->domain, VAR_71);
        if ( !VAR_72 || xsm_irq_permission(VAR_56, d, VAR_72, VAR_73) )
            VAR_2 = -VAR_74;
        else if ( VAR_73 )
            VAR_2 = irq_permit_access(d, VAR_72);
        else
            VAR_2 = irq_deny_access(d, VAR_72);
        break;
    }

    case VAR_75:
    {
        unsigned long VAR_76 = VAR_5->u.iomem_permission.first_mfn;
        unsigned long VAR_77 = VAR_5->u.iomem_permission.nr_mfns;
        int VAR_73 = VAR_5->u.iomem_permission.allow_access;

        VAR_2 = -VAR_27;
        if ( (VAR_76 + VAR_77 - 1) < VAR_76 ) /* COMMENT_12 */
            break;

        if ( !iomem_access_permitted(VAR_28->domain,
                                     VAR_76, VAR_76 + VAR_77 - 1) ||
             xsm_iomem_permission(VAR_56, d, VAR_76, VAR_76 + VAR_77 - 1, VAR_73) )
            VAR_2 = -VAR_74;
        else if ( VAR_73 )
            VAR_2 = iomem_permit_access(d, VAR_76, VAR_76 + VAR_77 - 1);
        else
            VAR_2 = iomem_deny_access(d, VAR_76, VAR_76 + VAR_77 - 1);
        if ( !VAR_2 )
            memory_type_changed(d);
        break;
    }

    case VAR_78:
    {
        unsigned long VAR_79 = VAR_5->u.memory_mapping.first_gfn;
        unsigned long VAR_76 = VAR_5->u.memory_mapping.first_mfn;
        unsigned long VAR_77 = VAR_5->u.memory_mapping.nr_mfns;
        unsigned long VAR_80 = VAR_76 + VAR_77 - 1;
        int VAR_81 = VAR_5->u.memory_mapping.add_mapping;

        VAR_2 = -VAR_27;
        if ( VAR_80 < VAR_76 || /* COMMENT_12 */
             ((VAR_76 | VAR_80) >> (VAR_82 - VAR_66)) ||
             (VAR_79 + VAR_77 - 1) < VAR_79 ) /* COMMENT_12 */
            break;

#ifndef VAR_83 /* COMMENT_13 */
        VAR_2 = -VAR_84;
        /* COMMENT_14 */
        if ( VAR_77 > 64 )
            break;
#endif

        VAR_2 = -VAR_74;
        if ( !iomem_access_permitted(VAR_28->domain, VAR_76, VAR_80) ||
             !iomem_access_permitted(d, VAR_76, VAR_80) )
            break;

        VAR_2 = xsm_iomem_mapping(VAR_56, d, VAR_76, VAR_80, VAR_81);
        if ( VAR_2 )
            break;

        if ( VAR_81 )
        {
            VAR_85(VAR_86
                   ""memory_map:add: dom%d gfn=%lx mfn=%lx nr=%lx\n"",
                   d->domain_id, VAR_79, VAR_76, VAR_77);

            VAR_2 = map_mmio_regions(d, _gfn(VAR_79), VAR_77, _mfn(VAR_76));
            if ( VAR_2 < 0 )
                VAR_85(XENLOG_G_WARNING
                       ""memory_map:fail: dom%d gfn=%lx mfn=%lx nr=%lx ret:%ld\n"",
                       d->domain_id, VAR_79, VAR_76, VAR_77, VAR_2);
        }
        else
        {
            VAR_85(VAR_86
                   ""memory_map:remove: dom%d gfn=%lx mfn=%lx nr=%lx\n"",
                   d->domain_id, VAR_79, VAR_76, VAR_77);

            VAR_2 = unmap_mmio_regions(d, _gfn(VAR_79), VAR_77, _mfn(VAR_76));
            if ( VAR_2 < 0 && is_hardware_domain(VAR_28->domain) )
                VAR_85(XENLOG_ERR
                       ""memory_map: error %ld removing dom%d access to [%lx,%lx]\n"",
                       VAR_2, d->domain_id, VAR_76, VAR_80);
        }
        /* COMMENT_15 */
        memory_type_changed(d);
        break;
    }

    case VAR_87:
        domain_set_time_offset(d, VAR_5->u.settimeoffset.time_offset_seconds);
        break;

    case VAR_88:
    {
        struct domain *VAR_89;

        VAR_2 = -VAR_15;
        VAR_89 = get_domain_by_id(VAR_5->u.set_target.target);
        if ( VAR_89 == NULL )
            break;

        VAR_2 = -VAR_27;
        if ( (d == VAR_89) || (d->target != NULL) )
        {
            put_domain(VAR_89);
            break;
        }

        VAR_2 = -VAR_90;
        if ( is_hvm_domain(VAR_89) )
            VAR_2 = xsm_set_target(VAR_56, d, VAR_89);
        if ( VAR_2 )
        {
            put_domain(VAR_89);
            break;
        }

        /* COMMENT_16 */
        d->target = VAR_89;
        break;
    }

    case VAR_91:
        d->suspend_evtchn = VAR_5->u.subscribe.port;
        break;

    case VAR_17:
        VAR_2 = vm_event_domctl(d, &VAR_5->u.vm_event_op);
        if ( VAR_2 == 0 )
            VAR_3 = true;
        break;

#ifdef VAR_92
    case VAR_93:
        if ( unlikely(VAR_28->domain == d) ) /* COMMENT_1 */
            VAR_2 = -VAR_74;
        else
        {
            domain_pause(d);
            arch_p2m_set_access_required(d,
                VAR_5->u.access_required.access_required);
            domain_unpause(d);
        }
        break;
#endif

    case VAR_94:
        VAR_2 = set_global_virq_handler(d, VAR_5->u.set_virq_handler.virq);
        break;

    case VAR_95:
    {
        struct vnuma_info *VAR_96;

        VAR_96 = vnuma_init(&VAR_5->u.vnuma, d);
        if ( IS_ERR(VAR_96) )
        {
            VAR_2 = PTR_ERR(VAR_96);
            break;
        }

        /* COMMENT_17 */
        write_lock(&d->vnuma_rwlock);
        vnuma_destroy(d->vnuma);
        d->vnuma = VAR_96;
        write_unlock(&d->vnuma_rwlock);

        break;
    }

    case VAR_97:
        VAR_2 = monitor_domctl(d, &VAR_5->u.monitor_op);
        if ( !VAR_2 )
            VAR_3 = 1;
        break;

    default:
        VAR_2 = arch_do_domctl(VAR_5, d, VAR_1);
        break;
    }

    domctl_lock_release();

 domctl_out_unlock_domonly:
    if ( d && d != VAR_13 )
        rcu_unlock_domain(d);

    if ( VAR_3 && __copy_to_guest(VAR_1, VAR_5, 1) )
        VAR_2 = -VAR_7;

    return VAR_2;
}",,"--- func_before
+++ func_after
@@ -202,12 +202,22 @@
     }
 
     case XEN_DOMCTL_soft_reset:
+    case XEN_DOMCTL_soft_reset_cont:
         if ( d == current->domain ) /* no domain_pause() */
         {
             ret = -EINVAL;
             break;
         }
-        ret = domain_soft_reset(d);
+        ret = domain_soft_reset(d, op->cmd == XEN_DOMCTL_soft_reset_cont);
+        if ( ret == -ERESTART )
+        {
+            op->cmd = XEN_DOMCTL_soft_reset_cont;
+            if ( !__copy_field_to_guest(u_domctl, op, cmd) )
+                ret = hypercall_create_continuation(__HYPERVISOR_domctl,
+                                                    ""h"", u_domctl);
+            else
+                ret = -EFAULT;
+        }
         break;
 
     case XEN_DOMCTL_destroydomain:","{'deleted_lines': ['        ret = domain_soft_reset(d);'], 'added_lines': ['    case XEN_DOMCTL_soft_reset_cont:', '        ret = domain_soft_reset(d, op->cmd == XEN_DOMCTL_soft_reset_cont);', '        if ( ret == -ERESTART )', '        {', '            op->cmd = XEN_DOMCTL_soft_reset_cont;', '            if ( !__copy_field_to_guest(u_domctl, op, cmd) )', '                ret = hypercall_create_continuation(__HYPERVISOR_domctl,', '                                                    ""h"", u_domctl);', '            else', '                ret = -EFAULT;', '        }']}",True,"An issue was discovered in Xen through 4.14.x. There is a lack of preemption in evtchn_reset() / evtchn_destroy(). In particular, the FIFO event channel model allows guests to have a large number of event channels active at a time. Closing all of these (when resetting all event channels or when cleaning up after the guest) may take extended periods of time. So far, there was no arrangement for preemption at suitable intervals, allowing a CPU to spend an almost unbounded amount of time in the processing of these operations. Malicious or buggy guest kernels can mount a Denial of Service (DoS) attack affecting the entire system. All Xen versions are vulnerable in principle. Whether versions 4.3 and older are vulnerable depends on underlying hardware characteristics.",5.5,MEDIUM,1,valid,2020-09-22T13:53:10Z,3
CVE-2020-25601,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,xen-project/xen,"evtchn: arrange for preemption in evtchn_reset()

Like for evtchn_destroy() looping over all possible event channels to
close them can take a significant amount of time. Unlike done there, we
can't alter domain properties (i.e. d->valid_evtchns) here. Borrow, in a
lightweight form, the paging domctl continuation concept, redirecting
the continuations to different sub-ops. Just like there this is to be
able to allow for predictable overall results of the involved sub-ops:
Racing requests should either complete or be refused.

Note that a domain can't interfere with an already started (by a remote
domain) reset, due to being paused. It can prevent a remote reset from
happening by leaving a reset unfinished, but that's only going to affect
itself.

This is part of XSA-344.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Acked-by: Julien Grall <jgrall@amazon.com>
Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>",2785b2a9e04abc148e1c5259f4faee708ea356f4,https://github.com/xen-project/xen/commit/2785b2a9e04abc148e1c5259f4faee708ea356f4,xen/common/event_channel.c,evtchn_reset,"int evtchn_reset(struct domain *d)
{
unsigned int i;
int rc = 0;
if ( d != current->domain && !d->controller_pause_count )
return -EINVAL;
for ( i = 0; port_is_valid(d, i); i++ )
evtchn_close(d, i, 1);
spin_lock(&d->event_lock);
if ( d->active_evtchns > d->xen_evtchns )
rc = -EAGAIN;
else if ( d->evtchn_fifo )
{
evtchn_fifo_destroy(d);
evtchn_2l_init(d);
}
spin_unlock(&d->event_lock);
return rc;
}","int evtchn_reset(struct domain *VAR_0)
{
unsigned int VAR_1;
int VAR_2 = 0;
if ( VAR_0 != VAR_3->domain && !VAR_0->controller_pause_count )
return -VAR_4;
for ( VAR_1 = 0; port_is_valid(VAR_0, VAR_1); VAR_1++ )
evtchn_close(VAR_0, VAR_1, 1);
spin_lock(&VAR_0->event_lock);
if ( VAR_0->active_evtchns > VAR_0->xen_evtchns )
VAR_2 = -VAR_5;
else if ( VAR_0->evtchn_fifo )
{
evtchn_fifo_destroy(VAR_0);
evtchn_2l_init(VAR_0);
}
spin_unlock(&VAR_0->event_lock);
return VAR_2;
}",xen-project/xen/2785b2a9e04abc148e1c5259f4faee708ea356f4/event_channel.c/vul/before/0.json,"int evtchn_reset(struct domain *d, bool resuming)
{
    unsigned int i;
    int rc = 0;

    if ( d != current->domain && !d->controller_pause_count )
        return -EINVAL;

    spin_lock(&d->event_lock);

    /*
     * If we are resuming, then start where we stopped. Otherwise, check
     * that a reset operation is not already in progress, and if none is,
     * record that this is now the case.
     */
    i = resuming ? d->next_evtchn : !d->next_evtchn;
    if ( i > d->next_evtchn )
        d->next_evtchn = i;

    spin_unlock(&d->event_lock);

    if ( !i )
        return -EBUSY;

    for ( ; port_is_valid(d, i); i++ )
    {
        evtchn_close(d, i, 1);

        /* NB: Choice of frequency is arbitrary. */
        if ( !(i & 0x3f) && hypercall_preempt_check() )
        {
            spin_lock(&d->event_lock);
            d->next_evtchn = i;
            spin_unlock(&d->event_lock);
            return -ERESTART;
        }
    }

    spin_lock(&d->event_lock);

    d->next_evtchn = 0;

    if ( d->active_evtchns > d->xen_evtchns )
        rc = -EAGAIN;
    else if ( d->evtchn_fifo )
    {
        /* Switching back to 2-level ABI. */
        evtchn_fifo_destroy(d);
        evtchn_2l_init(d);
    }

    spin_unlock(&d->event_lock);

    return rc;
}","int evtchn_reset(struct domain *VAR_0, bool VAR_1)
{
    unsigned int VAR_2;
    int VAR_3 = 0;

    if ( VAR_0 != VAR_4->domain && !VAR_0->controller_pause_count )
        return -VAR_5;

    spin_lock(&VAR_0->event_lock);

    /* COMMENT_0 */
                                                                        
                                                                         
                                        
       
    VAR_2 = VAR_1 ? VAR_0->next_evtchn : !VAR_0->next_evtchn;
    if ( VAR_2 > VAR_0->next_evtchn )
        VAR_0->next_evtchn = VAR_2;

    spin_unlock(&VAR_0->event_lock);

    if ( !VAR_2 )
        return -VAR_6;

    for ( ; port_is_valid(VAR_0, VAR_2); VAR_2++ )
    {
        evtchn_close(VAR_0, VAR_2, 1);

        /* COMMENT_5 */
        if ( !(VAR_2 & 0x3f) && hypercall_preempt_check() )
        {
            spin_lock(&VAR_0->event_lock);
            VAR_0->next_evtchn = VAR_2;
            spin_unlock(&VAR_0->event_lock);
            return -VAR_7;
        }
    }

    spin_lock(&VAR_0->event_lock);

    VAR_0->next_evtchn = 0;

    if ( VAR_0->active_evtchns > VAR_0->xen_evtchns )
        VAR_3 = -VAR_8;
    else if ( VAR_0->evtchn_fifo )
    {
        /* COMMENT_6 */
        evtchn_fifo_destroy(VAR_0);
        evtchn_2l_init(VAR_0);
    }

    spin_unlock(&VAR_0->event_lock);

    return VAR_3;
}",xen-project/xen/2785b2a9e04abc148e1c5259f4faee708ea356f4/event_channel.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-int evtchn_reset(struct domain *d)
+int evtchn_reset(struct domain *d, bool resuming)
 {
     unsigned int i;
     int rc = 0;
@@ -6,10 +6,39 @@
     if ( d != current->domain && !d->controller_pause_count )
         return -EINVAL;
 
-    for ( i = 0; port_is_valid(d, i); i++ )
+    spin_lock(&d->event_lock);
+
+    /*
+     * If we are resuming, then start where we stopped. Otherwise, check
+     * that a reset operation is not already in progress, and if none is,
+     * record that this is now the case.
+     */
+    i = resuming ? d->next_evtchn : !d->next_evtchn;
+    if ( i > d->next_evtchn )
+        d->next_evtchn = i;
+
+    spin_unlock(&d->event_lock);
+
+    if ( !i )
+        return -EBUSY;
+
+    for ( ; port_is_valid(d, i); i++ )
+    {
         evtchn_close(d, i, 1);
 
+        /* NB: Choice of frequency is arbitrary. */
+        if ( !(i & 0x3f) && hypercall_preempt_check() )
+        {
+            spin_lock(&d->event_lock);
+            d->next_evtchn = i;
+            spin_unlock(&d->event_lock);
+            return -ERESTART;
+        }
+    }
+
     spin_lock(&d->event_lock);
+
+    d->next_evtchn = 0;
 
     if ( d->active_evtchns > d->xen_evtchns )
         rc = -EAGAIN;","{'deleted_lines': ['int evtchn_reset(struct domain *d)', '    for ( i = 0; port_is_valid(d, i); i++ )'], 'added_lines': ['int evtchn_reset(struct domain *d, bool resuming)', '    spin_lock(&d->event_lock);', '', '    /*', '     * If we are resuming, then start where we stopped. Otherwise, check', '     * that a reset operation is not already in progress, and if none is,', '     * record that this is now the case.', '     */', '    i = resuming ? d->next_evtchn : !d->next_evtchn;', '    if ( i > d->next_evtchn )', '        d->next_evtchn = i;', '', '    spin_unlock(&d->event_lock);', '', '    if ( !i )', '        return -EBUSY;', '', '    for ( ; port_is_valid(d, i); i++ )', '    {', '        /* NB: Choice of frequency is arbitrary. */', '        if ( !(i & 0x3f) && hypercall_preempt_check() )', '        {', '            spin_lock(&d->event_lock);', '            d->next_evtchn = i;', '            spin_unlock(&d->event_lock);', '            return -ERESTART;', '        }', '    }', '', '', '    d->next_evtchn = 0;']}",True,"An issue was discovered in Xen through 4.14.x. There is a lack of preemption in evtchn_reset() / evtchn_destroy(). In particular, the FIFO event channel model allows guests to have a large number of event channels active at a time. Closing all of these (when resetting all event channels or when cleaning up after the guest) may take extended periods of time. So far, there was no arrangement for preemption at suitable intervals, allowing a CPU to spend an almost unbounded amount of time in the processing of these operations. Malicious or buggy guest kernels can mount a Denial of Service (DoS) attack affecting the entire system. All Xen versions are vulnerable in principle. Whether versions 4.3 and older are vulnerable depends on underlying hardware characteristics.",5.5,MEDIUM,1,valid,2020-09-22T13:53:10Z,3
CVE-2020-25601,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,xen-project/xen,"evtchn: arrange for preemption in evtchn_reset()

Like for evtchn_destroy() looping over all possible event channels to
close them can take a significant amount of time. Unlike done there, we
can't alter domain properties (i.e. d->valid_evtchns) here. Borrow, in a
lightweight form, the paging domctl continuation concept, redirecting
the continuations to different sub-ops. Just like there this is to be
able to allow for predictable overall results of the involved sub-ops:
Racing requests should either complete or be refused.

Note that a domain can't interfere with an already started (by a remote
domain) reset, due to being paused. It can prevent a remote reset from
happening by leaving a reset unfinished, but that's only going to affect
itself.

This is part of XSA-344.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Acked-by: Julien Grall <jgrall@amazon.com>
Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>",2785b2a9e04abc148e1c5259f4faee708ea356f4,https://github.com/xen-project/xen/commit/2785b2a9e04abc148e1c5259f4faee708ea356f4,xen/common/domain.c,domain_soft_reset,"int domain_soft_reset(struct domain *d)
{
struct vcpu *v;
int rc;
spin_lock(&d->shutdown_lock);
for_each_vcpu ( d, v )
if ( !v->paused_for_shutdown )
{
spin_unlock(&d->shutdown_lock);
return -EINVAL;
}
spin_unlock(&d->shutdown_lock);
rc = evtchn_reset(d);
if ( rc )
return rc;
grant_table_warn_active_grants(d);
argo_soft_reset(d);
for_each_vcpu ( d, v )
{
set_xen_guest_handle(runstate_guest(v), NULL);
unmap_vcpu_info(v);
}
rc = arch_domain_soft_reset(d);
if ( !rc )
domain_resume(d);
else
domain_crash(d);
return rc;
}","int domain_soft_reset(struct domain *VAR_0)
{
struct vcpu *VAR_1;
int VAR_2;
spin_lock(&VAR_0->shutdown_lock);
for_each_vcpu ( VAR_0, VAR_1 )
if ( !VAR_1->paused_for_shutdown )
{
spin_unlock(&VAR_0->shutdown_lock);
return -VAR_3;
}
spin_unlock(&VAR_0->shutdown_lock);
VAR_2 = evtchn_reset(VAR_0);
if ( VAR_2 )
return VAR_2;
grant_table_warn_active_grants(VAR_0);
argo_soft_reset(VAR_0);
for_each_vcpu ( VAR_0, VAR_1 )
{
set_xen_guest_handle(runstate_guest(VAR_1), NULL);
unmap_vcpu_info(VAR_1);
}
VAR_2 = arch_domain_soft_reset(VAR_0);
if ( !VAR_2 )
domain_resume(VAR_0);
else
domain_crash(VAR_0);
return VAR_2;
}",xen-project/xen/2785b2a9e04abc148e1c5259f4faee708ea356f4/domain.c/vul/before/0.json,"int domain_soft_reset(struct domain *d, bool resuming)
{
    struct vcpu *v;
    int rc;

    spin_lock(&d->shutdown_lock);
    for_each_vcpu ( d, v )
        if ( !v->paused_for_shutdown )
        {
            spin_unlock(&d->shutdown_lock);
            return -EINVAL;
        }
    spin_unlock(&d->shutdown_lock);

    rc = evtchn_reset(d, resuming);
    if ( rc )
        return rc;

    grant_table_warn_active_grants(d);

    argo_soft_reset(d);

    for_each_vcpu ( d, v )
    {
        set_xen_guest_handle(runstate_guest(v), NULL);
        unmap_vcpu_info(v);
    }

    rc = arch_domain_soft_reset(d);
    if ( !rc )
        domain_resume(d);
    else
        domain_crash(d);

    return rc;
}","int domain_soft_reset(struct domain *VAR_0, bool VAR_1)
{
    struct vcpu *VAR_2;
    int VAR_3;

    spin_lock(&VAR_0->shutdown_lock);
    for_each_vcpu ( VAR_0, VAR_2 )
        if ( !VAR_2->paused_for_shutdown )
        {
            spin_unlock(&VAR_0->shutdown_lock);
            return -VAR_4;
        }
    spin_unlock(&VAR_0->shutdown_lock);

    VAR_3 = evtchn_reset(VAR_0, VAR_1);
    if ( VAR_3 )
        return VAR_3;

    grant_table_warn_active_grants(VAR_0);

    argo_soft_reset(VAR_0);

    for_each_vcpu ( VAR_0, VAR_2 )
    {
        set_xen_guest_handle(runstate_guest(VAR_2), NULL);
        unmap_vcpu_info(VAR_2);
    }

    VAR_3 = arch_domain_soft_reset(VAR_0);
    if ( !VAR_3 )
        domain_resume(VAR_0);
    else
        domain_crash(VAR_0);

    return VAR_3;
}",xen-project/xen/2785b2a9e04abc148e1c5259f4faee708ea356f4/domain.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-int domain_soft_reset(struct domain *d)
+int domain_soft_reset(struct domain *d, bool resuming)
 {
     struct vcpu *v;
     int rc;
@@ -12,7 +12,7 @@
         }
     spin_unlock(&d->shutdown_lock);
 
-    rc = evtchn_reset(d);
+    rc = evtchn_reset(d, resuming);
     if ( rc )
         return rc;
 ","{'deleted_lines': ['int domain_soft_reset(struct domain *d)', '    rc = evtchn_reset(d);'], 'added_lines': ['int domain_soft_reset(struct domain *d, bool resuming)', '    rc = evtchn_reset(d, resuming);']}",True,"An issue was discovered in Xen through 4.14.x. There is a lack of preemption in evtchn_reset() / evtchn_destroy(). In particular, the FIFO event channel model allows guests to have a large number of event channels active at a time. Closing all of these (when resetting all event channels or when cleaning up after the guest) may take extended periods of time. So far, there was no arrangement for preemption at suitable intervals, allowing a CPU to spend an almost unbounded amount of time in the processing of these operations. Malicious or buggy guest kernels can mount a Denial of Service (DoS) attack affecting the entire system. All Xen versions are vulnerable in principle. Whether versions 4.3 and older are vulnerable depends on underlying hardware characteristics.",5.5,MEDIUM,1,valid,2020-09-22T13:53:10Z,3
CVE-2021-20302,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,AcademySoftwareFoundation/openexr,"add exrcheck binary and function in IlmImfUtil

Signed-off-by: Peter Hillman <peterh@wetafx.co.nz>",f044caeed5c0f1566d804f37cbddb2d5ccfd75ea,https://github.com/AcademySoftwareFoundation/openexr/commit/f044caeed5c0f1566d804f37cbddb2d5ccfd75ea,OpenEXR/IlmImf/ImfTiledInputFile.cpp,TiledInputFile::initialize,"void
TiledInputFile::initialize ()
{
if(!isMultiPart(_data->version) &&
!isNonImage(_data->version) && 
isTiled(_data->version) && 
_data->header.hasType() )
{
_data->header.setType(TILEDIMAGE);
}
if (_data->partNumber == -1)
{
if (!isTiled (_data->version))
throw IEX_NAMESPACE::ArgExc (""Expected a tiled file but the file is not tiled."");
}
else
{
if(_data->header.hasType() && _data->header.type()!=TILEDIMAGE)
{
throw IEX_NAMESPACE::ArgExc (""TiledInputFile used for non-tiledimage part."");
}
}
_data->header.sanityCheck (true);
_data->tileDesc = _data->header.tileDescription();
_data->lineOrder = _data->header.lineOrder();
const Box2i &dataWindow = _data->header.dataWindow();
_data->minX = dataWindow.min.x;
_data->maxX = dataWindow.max.x;
_data->minY = dataWindow.min.y;
_data->maxY = dataWindow.max.y;
precalculateTileInfo (_data->tileDesc,
_data->minX, _data->maxX,
_data->minY, _data->maxY,
_data->numXTiles, _data->numYTiles,
_data->numXLevels, _data->numYLevels);    
_data->bytesPerPixel = calculateBytesPerPixel (_data->header);
_data->maxBytesPerTileLine = _data->bytesPerPixel * _data->tileDesc.xSize;
_data->tileBufferSize = _data->maxBytesPerTileLine * _data->tileDesc.ySize;
if( _data->tileBufferSize > INT_MAX )
{
throw IEX_NAMESPACE::ArgExc (""Tile size too large for OpenEXR format"");
}
for (size_t i = 0; i < _data->tileBuffers.size(); i++)
{
_data->tileBuffers[i] = new TileBuffer (newTileCompressor
(_data->header.compression(),
_data->maxBytesPerTileLine,
_data->tileDesc.ySize,
_data->header));
if (!_data->_streamData->is->isMemoryMapped ())
_data->tileBuffers[i]->buffer = new char [_data->tileBufferSize];
}
_data->tileOffsets = TileOffsets (_data->tileDesc.mode,
_data->numXLevels,
_data->numYLevels,
_data->numXTiles,
_data->numYTiles);
}","void
TiledInputFile::initialize ()
{
if(!isMultiPart(VAR_0->version) &&
!isNonImage(VAR_0->version) && 
isTiled(VAR_0->version) && 
VAR_0->header.hasType() )
{
VAR_0->header.setType(VAR_1);
}
if (VAR_0->partNumber == -1)
{
if (!isTiled (VAR_0->version))
throw IEX_NAMESPACE::ArgExc (""Expected a tiled file but the file is not tiled."");
}
else
{
if(VAR_0->header.hasType() && VAR_0->header.type()!=VAR_1)
{
throw IEX_NAMESPACE::ArgExc (""TiledInputFile used for non-tiledimage part."");
}
}
VAR_0->header.sanityCheck (true);
VAR_0->tileDesc = VAR_0->header.tileDescription();
VAR_0->lineOrder = VAR_0->header.lineOrder();
const Box2i &VAR_2 = VAR_0->header.dataWindow();
VAR_0->minX = VAR_2.min.x;
VAR_0->maxX = VAR_2.max.x;
VAR_0->minY = VAR_2.min.y;
VAR_0->maxY = VAR_2.max.y;
precalculateTileInfo (VAR_0->tileDesc,
VAR_0->minX, VAR_0->maxX,
VAR_0->minY, VAR_0->maxY,
VAR_0->numXTiles, VAR_0->numYTiles,
VAR_0->numXLevels, VAR_0->numYLevels);    
VAR_0->bytesPerPixel = calculateBytesPerPixel (VAR_0->header);
VAR_0->maxBytesPerTileLine = VAR_0->bytesPerPixel * VAR_0->tileDesc.xSize;
VAR_0->tileBufferSize = VAR_0->maxBytesPerTileLine * VAR_0->tileDesc.ySize;
if( VAR_0->tileBufferSize > VAR_3 )
{
throw IEX_NAMESPACE::ArgExc (""Tile size too large for OpenEXR format"");
}
for (size_t VAR_4 = 0; VAR_4 < VAR_0->tileBuffers.size(); VAR_4++)
{
VAR_0->tileBuffers[VAR_4] = new TileBuffer (newTileCompressor
(VAR_0->header.compression(),
VAR_0->maxBytesPerTileLine,
VAR_0->tileDesc.ySize,
VAR_0->header));
if (!VAR_0->_streamData->is->isMemoryMapped ())
VAR_0->tileBuffers[VAR_4]->buffer = new char [VAR_0->tileBufferSize];
}
VAR_0->tileOffsets = TileOffsets (VAR_0->tileDesc.mode,
VAR_0->numXLevels,
VAR_0->numYLevels,
VAR_0->numXTiles,
VAR_0->numYTiles);
}",AcademySoftwareFoundation/openexr/f044caeed5c0f1566d804f37cbddb2d5ccfd75ea/ImfTiledInputFile.cpp/vul/before/0.json,"void
TiledInputFile::initialize ()
{
    // fix bad types in header (arises when a tool built against an older version of
    // OpenEXR converts a scanline image to tiled)
    // only applies when file is a single part, regular image, tiled file
    //
    if(!isMultiPart(_data->version) &&
       !isNonImage(_data->version) && 
       isTiled(_data->version) && 
       _data->header.hasType() )
    {
        _data->header.setType(TILEDIMAGE);
    }
    
    if (_data->partNumber == -1)
    {
        if (!isTiled (_data->version))
            throw IEX_NAMESPACE::ArgExc (""Expected a tiled file but the file is not tiled."");

        if (isNonImage (_data->version))
            throw IEX_NAMESPACE::ArgExc (""File is not a regular tiled image."");

    }
    else
    {
        if(_data->header.hasType() && _data->header.type()!=TILEDIMAGE)
        {
            throw IEX_NAMESPACE::ArgExc (""TiledInputFile used for non-tiledimage part."");
        }
    }
    
    _data->header.sanityCheck (true);

    _data->tileDesc = _data->header.tileDescription();
    _data->lineOrder = _data->header.lineOrder();

    //
    // Save the dataWindow information
    //
    
    const Box2i &dataWindow = _data->header.dataWindow();
    _data->minX = dataWindow.min.x;
    _data->maxX = dataWindow.max.x;
    _data->minY = dataWindow.min.y;
    _data->maxY = dataWindow.max.y;

    //
    // Precompute level and tile information to speed up utility functions
    //

    precalculateTileInfo (_data->tileDesc,
			  _data->minX, _data->maxX,
			  _data->minY, _data->maxY,
			  _data->numXTiles, _data->numYTiles,
			  _data->numXLevels, _data->numYLevels);    

    _data->bytesPerPixel = calculateBytesPerPixel (_data->header);

    _data->maxBytesPerTileLine = _data->bytesPerPixel * _data->tileDesc.xSize;

    _data->tileBufferSize = _data->maxBytesPerTileLine * _data->tileDesc.ySize;

    //
    // OpenEXR has a limit of INT_MAX compressed bytes per tile
    // disallow uncompressed tile sizes above INT_MAX too to guarantee file is written
    //
    if( _data->tileBufferSize > INT_MAX )
    {
        throw IEX_NAMESPACE::ArgExc (""Tile size too large for OpenEXR format"");
    }


    //
    // Create all the TileBuffers and allocate their internal buffers
    //

    for (size_t i = 0; i < _data->tileBuffers.size(); i++)
    {
        _data->tileBuffers[i] = new TileBuffer (newTileCompressor
						  (_data->header.compression(),
						   _data->maxBytesPerTileLine,
						   _data->tileDesc.ySize,
						   _data->header));

        if (!_data->_streamData->is->isMemoryMapped ())
            _data->tileBuffers[i]->buffer = new char [_data->tileBufferSize];
    }

    _data->tileOffsets = TileOffsets (_data->tileDesc.mode,
				      _data->numXLevels,
				      _data->numYLevels,
				      _data->numXTiles,
				      _data->numYTiles);
}","void
TiledInputFile::initialize ()
{
    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    /* COMMENT_3 */
    if(!isMultiPart(VAR_0->version) &&
       !isNonImage(VAR_0->version) && 
       isTiled(VAR_0->version) && 
       VAR_0->header.hasType() )
    {
        VAR_0->header.setType(VAR_1);
    }
    
    if (VAR_0->partNumber == -1)
    {
        if (!isTiled (VAR_0->version))
            throw IEX_NAMESPACE::ArgExc (""Expected a tiled file but the file is not tiled."");

        if (isNonImage (VAR_0->version))
            throw IEX_NAMESPACE::ArgExc (""File is not a regular tiled image."");

    }
    else
    {
        if(VAR_0->header.hasType() && VAR_0->header.type()!=VAR_1)
        {
            throw IEX_NAMESPACE::ArgExc (""TiledInputFile used for non-tiledimage part."");
        }
    }
    
    VAR_0->header.sanityCheck (true);

    VAR_0->tileDesc = VAR_0->header.tileDescription();
    VAR_0->lineOrder = VAR_0->header.lineOrder();

    /* COMMENT_3 */
    /* COMMENT_4 */
    /* COMMENT_3 */
    
    const Box2i &VAR_2 = VAR_0->header.dataWindow();
    VAR_0->minX = VAR_2.min.x;
    VAR_0->maxX = VAR_2.max.x;
    VAR_0->minY = VAR_2.min.y;
    VAR_0->maxY = VAR_2.max.y;

    /* COMMENT_3 */
    /* COMMENT_5 */
    /* COMMENT_3 */

    precalculateTileInfo (VAR_0->tileDesc,
			  VAR_0->minX, VAR_0->maxX,
			  VAR_0->minY, VAR_0->maxY,
			  VAR_0->numXTiles, VAR_0->numYTiles,
			  VAR_0->numXLevels, VAR_0->numYLevels);    

    VAR_0->bytesPerPixel = calculateBytesPerPixel (VAR_0->header);

    VAR_0->maxBytesPerTileLine = VAR_0->bytesPerPixel * VAR_0->tileDesc.xSize;

    VAR_0->tileBufferSize = VAR_0->maxBytesPerTileLine * VAR_0->tileDesc.ySize;

    /* COMMENT_3 */
    /* COMMENT_6 */
    /* COMMENT_7 */
    /* COMMENT_3 */
    if( VAR_0->tileBufferSize > VAR_3 )
    {
        throw IEX_NAMESPACE::ArgExc (""Tile size too large for OpenEXR format"");
    }


    /* COMMENT_3 */
    /* COMMENT_8 */
    /* COMMENT_3 */

    for (size_t VAR_4 = 0; VAR_4 < VAR_0->tileBuffers.size(); VAR_4++)
    {
        VAR_0->tileBuffers[VAR_4] = new TileBuffer (newTileCompressor
						  (VAR_0->header.compression(),
						   VAR_0->maxBytesPerTileLine,
						   VAR_0->tileDesc.ySize,
						   VAR_0->header));

        if (!VAR_0->_streamData->is->isMemoryMapped ())
            VAR_0->tileBuffers[VAR_4]->buffer = new char [VAR_0->tileBufferSize];
    }

    VAR_0->tileOffsets = TileOffsets (VAR_0->tileDesc.mode,
				      VAR_0->numXLevels,
				      VAR_0->numYLevels,
				      VAR_0->numXTiles,
				      VAR_0->numYTiles);
}",AcademySoftwareFoundation/openexr/f044caeed5c0f1566d804f37cbddb2d5ccfd75ea/ImfTiledInputFile.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,7 +17,10 @@
     {
         if (!isTiled (_data->version))
             throw IEX_NAMESPACE::ArgExc (""Expected a tiled file but the file is not tiled."");
-        
+
+        if (isNonImage (_data->version))
+            throw IEX_NAMESPACE::ArgExc (""File is not a regular tiled image."");
+
     }
     else
     {","{'deleted_lines': ['        '], 'added_lines': ['', '        if (isNonImage (_data->version))', '            throw IEX_NAMESPACE::ArgExc (""File is not a regular tiled image."");', '']}",True,"A flaw was found in OpenEXR's TiledInputFile functionality. This flaw allows an attacker who can submit a crafted single-part non-image to be processed by OpenEXR, to trigger a floating-point exception error. The highest threat from this vulnerability is to system availability.",5.5,MEDIUM,1,valid,2020-09-22T23:00:16Z,3
CVE-2021-20302,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,AcademySoftwareFoundation/openexr,"add exrcheck binary and function in IlmImfUtil

Signed-off-by: Peter Hillman <peterh@wetafx.co.nz>",f044caeed5c0f1566d804f37cbddb2d5ccfd75ea,https://github.com/AcademySoftwareFoundation/openexr/commit/f044caeed5c0f1566d804f37cbddb2d5ccfd75ea,OpenEXR/IlmImf/ImfInputFile.cpp,bufferedReadPixels,"void
bufferedReadPixels (InputFile::Data* ifd, int scanLine1, int scanLine2)
{
int minY = std::min (scanLine1, scanLine2);
int maxY = std::max (scanLine1, scanLine2);
if (minY < ifd->minY || maxY >  ifd->maxY)
{
throw IEX_NAMESPACE::ArgExc (""Tried to read scan line outside ""
""the image file's data window."");
}
int minDy = (minY - ifd->minY) / ifd->tFile->tileYSize();
int maxDy = (maxY - ifd->minY) / ifd->tFile->tileYSize();
int yStart, yEnd, yStep;
if (ifd->lineOrder == DECREASING_Y)
{
yStart = maxDy;
yEnd = minDy - 1;
yStep = -1;
}
else
{
yStart = minDy;
yEnd = maxDy + 1;
yStep = 1;
}
Box2i levelRange = ifd->tFile->dataWindowForLevel(0);
for (int j = yStart; j != yEnd; j += yStep)
{
Box2i tileRange = ifd->tFile->dataWindowForTile (0, j, 0);
int minYThisRow = std::max (minY, tileRange.min.y);
int maxYThisRow = std::min (maxY, tileRange.max.y);
if (j != ifd->cachedTileY)
{
if (ifd->cachedBuffer->begin() != ifd->cachedBuffer->end())
{
ifd->tFile->readTiles (0, ifd->tFile->numXTiles (0) - 1, j, j);
}
ifd->cachedTileY = j;
}
for (FrameBuffer::ConstIterator k = ifd->tFileBuffer.begin();
k != ifd->tFileBuffer.end();
++k)
{
Slice toSlice = k.slice();            char* toPtr;
int xStart = levelRange.min.x;
int yStart = minYThisRow;
while (modp (xStart, toSlice.xSampling) != 0)
++xStart;
while (modp (yStart, toSlice.ySampling) != 0)
++yStart;
FrameBuffer::ConstIterator c = ifd->cachedBuffer->find(k.name());
intptr_t toBase = reinterpret_cast<intptr_t>(toSlice.base);
if( c!=ifd->cachedBuffer->end())
{
Slice fromSlice = c.slice();                intptr_t fromBase = reinterpret_cast<intptr_t>(fromSlice.base);
int size = pixelTypeSize (toSlice.type);
char* fromPtr;
for (int y = yStart;
y <= maxYThisRow;
y += toSlice.ySampling)
{
fromPtr = reinterpret_cast<char*> (fromBase  +
(y - tileRange.min.y) * fromSlice.yStride +
xStart * fromSlice.xStride);
toPtr = reinterpret_cast<char*> (toBase +
divp (y, toSlice.ySampling) * toSlice.yStride +
divp (xStart, toSlice.xSampling) * toSlice.xStride);
for (int x = xStart;
x <= levelRange.max.x;
x += toSlice.xSampling)
{
for (int i = 0; i < size; ++i)
toPtr[i] = fromPtr[i];
fromPtr += fromSlice.xStride * toSlice.xSampling;
toPtr += toSlice.xStride;
}
}
}
else
{
for (int y = yStart;
y <= maxYThisRow;
y += toSlice.ySampling)
{
toPtr = reinterpret_cast<char*> (toBase+
divp (y, toSlice.ySampling) * toSlice.yStride +
divp (xStart, toSlice.xSampling) * toSlice.xStride);
switch ( toSlice.type)
{
case UINT:
{
unsigned int fill = toSlice.fillValue;
for (int x = xStart;
x <= levelRange.max.x;
x += toSlice.xSampling)
{
* reinterpret_cast<unsigned int*>(toPtr) = fill;
toPtr += toSlice.xStride;
}
break;
}
case HALF :
{
half fill = toSlice.fillValue;
for (int x = xStart;
x <= levelRange.max.x;
x += toSlice.xSampling)
{
* reinterpret_cast<half*>(toPtr) = fill;
toPtr += toSlice.xStride;
}
break;
}
case FLOAT :
{
float fill = toSlice.fillValue;
for (int x = xStart;
x <= levelRange.max.x;
x += toSlice.xSampling)
{
* reinterpret_cast<float*>(toPtr) = fill;
toPtr += toSlice.xStride;
}
break;
}
case NUM_PIXELTYPES :
{
break;
}
}
}
}
}
}
}","void
bufferedReadPixels (InputFile::Data* VAR_0, int VAR_1, int VAR_2)
{
int VAR_3 = std::min (VAR_1, VAR_2);
int VAR_4 = std::max (VAR_1, VAR_2);
if (VAR_3 < VAR_0->minY || VAR_4 >  VAR_0->maxY)
{
throw IEX_NAMESPACE::ArgExc (""Tried to read scan line outside ""
""the image file's data window."");
}
int VAR_5 = (VAR_3 - VAR_0->minY) / VAR_0->tFile->tileYSize();
int VAR_6 = (VAR_4 - VAR_0->minY) / VAR_0->tFile->tileYSize();
int VAR_7, VAR_8, VAR_9;
if (VAR_0->lineOrder == VAR_10)
{
VAR_7 = VAR_6;
VAR_8 = VAR_5 - 1;
VAR_9 = -1;
}
else
{
VAR_7 = VAR_5;
VAR_8 = VAR_6 + 1;
VAR_9 = 1;
}
Box2i VAR_11 = VAR_0->tFile->dataWindowForLevel(0);
for (int VAR_12 = VAR_7; VAR_12 != VAR_8; VAR_12 += VAR_9)
{
Box2i VAR_13 = VAR_0->tFile->dataWindowForTile (0, VAR_12, 0);
int VAR_14 = std::max (VAR_3, VAR_13.min.y);
int VAR_15 = std::min (VAR_4, VAR_13.max.y);
if (VAR_12 != VAR_0->cachedTileY)
{
if (VAR_0->cachedBuffer->begin() != VAR_0->cachedBuffer->end())
{
VAR_0->tFile->readTiles (0, VAR_0->tFile->numXTiles (0) - 1, VAR_12, VAR_12);
}
VAR_0->cachedTileY = VAR_12;
}
for (FrameBuffer::ConstIterator VAR_16 = VAR_0->tFileBuffer.begin();
VAR_16 != VAR_0->tFileBuffer.end();
++VAR_16)
{
Slice VAR_17 = VAR_16.slice();
char* VAR_18;
int VAR_19 = VAR_11.min.x;
int VAR_7 = VAR_14;
while (modp (VAR_19, VAR_17.xSampling) != 0)
++VAR_19;
while (modp (VAR_7, VAR_17.ySampling) != 0)
++VAR_7;
FrameBuffer::ConstIterator VAR_20 = VAR_0->cachedBuffer->find(VAR_16.name());
intptr_t VAR_21 = VAR_22<intptr_t>(VAR_17.base);
if( VAR_20!=VAR_0->cachedBuffer->end())
{
Slice VAR_23 = VAR_20.slice();
intptr_t VAR_24 = VAR_22<intptr_t>(VAR_23.base);
int VAR_25 = pixelTypeSize (VAR_17.type);
char* VAR_26;
for (int VAR_27 = VAR_7;
VAR_27 <= VAR_15;
VAR_27 += VAR_17.ySampling)
{
VAR_26 = VAR_22<char*> (VAR_24  +
(VAR_27 - VAR_13.min.y) * VAR_23.yStride +
VAR_19 * VAR_23.xStride);
VAR_18 = VAR_22<char*> (VAR_21 +
divp (VAR_27, VAR_17.ySampling) * VAR_17.yStride +
divp (VAR_19, VAR_17.xSampling) * VAR_17.xStride);
for (int VAR_28 = VAR_19;
VAR_28 <= VAR_11.max.x;
VAR_28 += VAR_17.xSampling)
{
for (int VAR_29 = 0; VAR_29 < VAR_25; ++VAR_29)
VAR_18[VAR_29] = VAR_26[VAR_29];
VAR_26 += VAR_23.xStride * VAR_17.xSampling;
VAR_18 += VAR_17.xStride;
}
}
}
else
{
for (int VAR_27 = VAR_7;
VAR_27 <= VAR_15;
VAR_27 += VAR_17.ySampling)
{
VAR_18 = VAR_22<char*> (VAR_21+
divp (VAR_27, VAR_17.ySampling) * VAR_17.yStride +
divp (VAR_19, VAR_17.xSampling) * VAR_17.xStride);
switch ( VAR_17.type)
{
case VAR_30:
{
unsigned int VAR_31 = VAR_17.fillValue;
for (int VAR_28 = VAR_19;
VAR_28 <= VAR_11.max.x;
VAR_28 += VAR_17.xSampling)
{
* VAR_22<unsigned int*>(VAR_18) = VAR_31;
VAR_18 += VAR_17.xStride;
}
break;
}
case VAR_32 :
{
half VAR_31 = VAR_17.fillValue;
for (int VAR_28 = VAR_19;
VAR_28 <= VAR_11.max.x;
VAR_28 += VAR_17.xSampling)
{
* VAR_22<half*>(VAR_18) = VAR_31;
VAR_18 += VAR_17.xStride;
}
break;
}
case VAR_33 :
{
float VAR_31 = VAR_17.fillValue;
for (int VAR_28 = VAR_19;
VAR_28 <= VAR_11.max.x;
VAR_28 += VAR_17.xSampling)
{
* VAR_22<float*>(VAR_18) = VAR_31;
VAR_18 += VAR_17.xStride;
}
break;
}
case VAR_34 :
{
break;
}
}
}
}
}
}
}",AcademySoftwareFoundation/openexr/f044caeed5c0f1566d804f37cbddb2d5ccfd75ea/ImfInputFile.cpp/vul/before/0.json,"void
bufferedReadPixels (InputFile::Data* ifd, int scanLine1, int scanLine2)
{
    //
    // bufferedReadPixels reads each row of tiles that intersect the
    // scan-line range (scanLine1 to scanLine2). The previous row of
    // tiles is cached in order to prevent redundent tile reads when
    // accessing scanlines sequentially.
    //

    int minY = std::min (scanLine1, scanLine2);
    int maxY = std::max (scanLine1, scanLine2);

    if (minY < ifd->minY || maxY >  ifd->maxY)
    {
        throw IEX_NAMESPACE::ArgExc (""Tried to read scan line outside ""
			   ""the image file's data window."");
    }

    //
    // The minimum and maximum y tile coordinates that intersect this
    // scanline range
    //

    int minDy = (minY - ifd->minY) / ifd->tFile->tileYSize();
    int maxDy = (maxY - ifd->minY) / ifd->tFile->tileYSize();

    //
    // Figure out which one is first in the file so we can read without seeking
    //

    int yStart, yEnd, yStep;

    if (ifd->lineOrder == DECREASING_Y)
    {
        yStart = maxDy;
        yEnd = minDy - 1;
        yStep = -1;
    }
    else
    {
        yStart = minDy;
        yEnd = maxDy + 1;
        yStep = 1;
    }

    //
    // the number of pixels in a row of tiles
    //

    Box2i levelRange = ifd->tFile->dataWindowForLevel(0);
    
    //
    // Read the tiles into our temporary framebuffer and copy them into
    // the user's buffer
    //

    for (int j = yStart; j != yEnd; j += yStep)
    {
        Box2i tileRange = ifd->tFile->dataWindowForTile (0, j, 0);

        int minYThisRow = std::max (minY, tileRange.min.y);
        int maxYThisRow = std::min (maxY, tileRange.max.y);

        if (j != ifd->cachedTileY)
        {
            //
            // We don't have any valid buffered info, so we need to read in
            // from the file.
            // if no channels are being read that are present in file, cachedBuffer will be empty
            //

            if (ifd->cachedBuffer && ifd->cachedBuffer->begin() != ifd->cachedBuffer->end())
            {
                ifd->tFile->readTiles (0, ifd->tFile->numXTiles (0) - 1, j, j);
            }

            ifd->cachedTileY = j;
        }

        //
        // Copy the data from our cached framebuffer into the user's
        // framebuffer.
        //

        for (FrameBuffer::ConstIterator k = ifd->tFileBuffer.begin();
             k != ifd->tFileBuffer.end();
             ++k)
        {


            Slice toSlice = k.slice();		// slice to read from
            char* toPtr;

            int xStart = levelRange.min.x;
            int yStart = minYThisRow;

            while (modp (xStart, toSlice.xSampling) != 0)
                ++xStart;

            while (modp (yStart, toSlice.ySampling) != 0)
                ++yStart;

            FrameBuffer::ConstIterator c = ifd->cachedBuffer->find(k.name());
            intptr_t toBase = reinterpret_cast<intptr_t>(toSlice.base);


            if( c!=ifd->cachedBuffer->end())
            {
                //
                // output channel was read from source image: copy to output slice
                //
                Slice fromSlice = c.slice();	// slice to write to
                intptr_t fromBase = reinterpret_cast<intptr_t>(fromSlice.base);

                int size = pixelTypeSize (toSlice.type);
                char* fromPtr;

                for (int y = yStart;
                    y <= maxYThisRow;
                    y += toSlice.ySampling)
                {
                    //
                    // Set the pointers to the start of the y scanline in
                    // this row of tiles
                    //

                    fromPtr = reinterpret_cast<char*> (fromBase  +
                            (y - tileRange.min.y) * fromSlice.yStride +
                            xStart * fromSlice.xStride);

                    toPtr = reinterpret_cast<char*> (toBase +
                            divp (y, toSlice.ySampling) * toSlice.yStride +
                            divp (xStart, toSlice.xSampling) * toSlice.xStride);

                    //
                    // Copy all pixels for the scanline in this row of tiles
                    //

                    for (int x = xStart;
                        x <= levelRange.max.x;
                        x += toSlice.xSampling)
                    {
                        for (int i = 0; i < size; ++i)
                            toPtr[i] = fromPtr[i];

                        fromPtr += fromSlice.xStride * toSlice.xSampling;
                        toPtr += toSlice.xStride;
                    }
                }
            }
            else
            {

                //
                // channel wasn't present in source file: fill output slice
                //
                for (int y = yStart;
                    y <= maxYThisRow;
                    y += toSlice.ySampling)
                {

                    toPtr = reinterpret_cast<char*> (toBase+
                            divp (y, toSlice.ySampling) * toSlice.yStride +
                            divp (xStart, toSlice.xSampling) * toSlice.xStride);

                    //
                    // Copy all pixels for the scanline in this row of tiles
                    //

                    switch ( toSlice.type)
                    {
                        case UINT:
                        {
                            unsigned int fill = toSlice.fillValue;
                            for (int x = xStart;
                                x <= levelRange.max.x;
                                x += toSlice.xSampling)
                            {
                                * reinterpret_cast<unsigned int*>(toPtr) = fill;
                                toPtr += toSlice.xStride;
                            }
                            break;
                        }
                        case HALF :
                        {
                            half fill = toSlice.fillValue;
                            for (int x = xStart;
                                x <= levelRange.max.x;
                                x += toSlice.xSampling)
                            {
                                * reinterpret_cast<half*>(toPtr) = fill;
                                toPtr += toSlice.xStride;
                            }
                            break;
                        }
                        case FLOAT :
                        {
                            float fill = toSlice.fillValue;
                            for (int x = xStart;
                                x <= levelRange.max.x;
                                x += toSlice.xSampling)
                            {
                                * reinterpret_cast<float*>(toPtr) = fill;
                                toPtr += toSlice.xStride;
                            }
                            break;
                        }
                        case NUM_PIXELTYPES :
                        {
                            break;
                        }

                    }
                }
            }
        }
    }
}","void
bufferedReadPixels (InputFile::Data* VAR_0, int VAR_1, int VAR_2)
{
    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    /* COMMENT_3 */
    /* COMMENT_4 */
    /* COMMENT_0 */

    int VAR_3 = std::min (VAR_1, VAR_2);
    int VAR_4 = std::max (VAR_1, VAR_2);

    if (VAR_3 < VAR_0->minY || VAR_4 >  VAR_0->maxY)
    {
        throw IEX_NAMESPACE::ArgExc (""Tried to read scan line outside ""
			   ""the image file's data window."");
    }

    /* COMMENT_0 */
    /* COMMENT_5 */
    /* COMMENT_6 */
    /* COMMENT_0 */

    int VAR_5 = (VAR_3 - VAR_0->minY) / VAR_0->tFile->tileYSize();
    int VAR_6 = (VAR_4 - VAR_0->minY) / VAR_0->tFile->tileYSize();

    /* COMMENT_0 */
    /* COMMENT_7 */
    /* COMMENT_0 */

    int VAR_7, VAR_8, VAR_9;

    if (VAR_0->lineOrder == VAR_10)
    {
        VAR_7 = VAR_6;
        VAR_8 = VAR_5 - 1;
        VAR_9 = -1;
    }
    else
    {
        VAR_7 = VAR_5;
        VAR_8 = VAR_6 + 1;
        VAR_9 = 1;
    }

    /* COMMENT_0 */
    /* COMMENT_8 */
    /* COMMENT_0 */

    Box2i VAR_11 = VAR_0->tFile->dataWindowForLevel(0);
    
    /* COMMENT_0 */
    /* COMMENT_9 */
    /* COMMENT_10 */
    /* COMMENT_0 */

    for (int VAR_12 = VAR_7; VAR_12 != VAR_8; VAR_12 += VAR_9)
    {
        Box2i VAR_13 = VAR_0->tFile->dataWindowForTile (0, VAR_12, 0);

        int VAR_14 = std::max (VAR_3, VAR_13.min.y);
        int VAR_15 = std::min (VAR_4, VAR_13.max.y);

        if (VAR_12 != VAR_0->cachedTileY)
        {
            /* COMMENT_0 */
            /* COMMENT_11 */
            /* COMMENT_12 */
            /* COMMENT_13 */
            /* COMMENT_0 */

            if (VAR_0->cachedBuffer && VAR_0->cachedBuffer->begin() != VAR_0->cachedBuffer->end())
            {
                VAR_0->tFile->readTiles (0, VAR_0->tFile->numXTiles (0) - 1, VAR_12, VAR_12);
            }

            VAR_0->cachedTileY = VAR_12;
        }

        /* COMMENT_0 */
        /* COMMENT_14 */
        /* COMMENT_15 */
        /* COMMENT_0 */

        for (FrameBuffer::ConstIterator VAR_16 = VAR_0->tFileBuffer.begin();
             VAR_16 != VAR_0->tFileBuffer.end();
             ++VAR_16)
        {


            Slice VAR_17 = VAR_16.slice();		/* COMMENT_16 */
            char* VAR_18;

            int VAR_19 = VAR_11.min.x;
            int VAR_7 = VAR_14;

            while (modp (VAR_19, VAR_17.xSampling) != 0)
                ++VAR_19;

            while (modp (VAR_7, VAR_17.ySampling) != 0)
                ++VAR_7;

            FrameBuffer::ConstIterator VAR_20 = VAR_0->cachedBuffer->find(VAR_16.name());
            intptr_t VAR_21 = VAR_22<intptr_t>(VAR_17.base);


            if( VAR_20!=VAR_0->cachedBuffer->end())
            {
                /* COMMENT_0 */
                /* COMMENT_17 */
                /* COMMENT_0 */
                Slice VAR_23 = VAR_20.slice();	/* COMMENT_18 */
                intptr_t VAR_24 = VAR_22<intptr_t>(VAR_23.base);

                int VAR_25 = pixelTypeSize (VAR_17.type);
                char* VAR_26;

                for (int VAR_27 = VAR_7;
                    VAR_27 <= VAR_15;
                    VAR_27 += VAR_17.ySampling)
                {
                    /* COMMENT_0 */
                    /* COMMENT_19 */
                    /* COMMENT_20 */
                    /* COMMENT_0 */

                    VAR_26 = VAR_22<char*> (VAR_24  +
                            (VAR_27 - VAR_13.min.y) * VAR_23.yStride +
                            VAR_19 * VAR_23.xStride);

                    VAR_18 = VAR_22<char*> (VAR_21 +
                            divp (VAR_27, VAR_17.ySampling) * VAR_17.yStride +
                            divp (VAR_19, VAR_17.xSampling) * VAR_17.xStride);

                    /* COMMENT_0 */
                    /* COMMENT_21 */
                    /* COMMENT_0 */

                    for (int VAR_28 = VAR_19;
                        VAR_28 <= VAR_11.max.x;
                        VAR_28 += VAR_17.xSampling)
                    {
                        for (int VAR_29 = 0; VAR_29 < VAR_25; ++VAR_29)
                            VAR_18[VAR_29] = VAR_26[VAR_29];

                        VAR_26 += VAR_23.xStride * VAR_17.xSampling;
                        VAR_18 += VAR_17.xStride;
                    }
                }
            }
            else
            {

                /* COMMENT_0 */
                /* COMMENT_22 */
                /* COMMENT_0 */
                for (int VAR_27 = VAR_7;
                    VAR_27 <= VAR_15;
                    VAR_27 += VAR_17.ySampling)
                {

                    VAR_18 = VAR_22<char*> (VAR_21+
                            divp (VAR_27, VAR_17.ySampling) * VAR_17.yStride +
                            divp (VAR_19, VAR_17.xSampling) * VAR_17.xStride);

                    /* COMMENT_0 */
                    /* COMMENT_21 */
                    /* COMMENT_0 */

                    switch ( VAR_17.type)
                    {
                        case VAR_30:
                        {
                            unsigned int VAR_31 = VAR_17.fillValue;
                            for (int VAR_28 = VAR_19;
                                VAR_28 <= VAR_11.max.x;
                                VAR_28 += VAR_17.xSampling)
                            {
                                * VAR_22<unsigned int*>(VAR_18) = VAR_31;
                                VAR_18 += VAR_17.xStride;
                            }
                            break;
                        }
                        case VAR_32 :
                        {
                            half VAR_31 = VAR_17.fillValue;
                            for (int VAR_28 = VAR_19;
                                VAR_28 <= VAR_11.max.x;
                                VAR_28 += VAR_17.xSampling)
                            {
                                * VAR_22<half*>(VAR_18) = VAR_31;
                                VAR_18 += VAR_17.xStride;
                            }
                            break;
                        }
                        case VAR_33 :
                        {
                            float VAR_31 = VAR_17.fillValue;
                            for (int VAR_28 = VAR_19;
                                VAR_28 <= VAR_11.max.x;
                                VAR_28 += VAR_17.xSampling)
                            {
                                * VAR_22<float*>(VAR_18) = VAR_31;
                                VAR_18 += VAR_17.xStride;
                            }
                            break;
                        }
                        case VAR_34 :
                        {
                            break;
                        }

                    }
                }
            }
        }
    }
}",AcademySoftwareFoundation/openexr/f044caeed5c0f1566d804f37cbddb2d5ccfd75ea/ImfInputFile.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -70,7 +70,7 @@
             // if no channels are being read that are present in file, cachedBuffer will be empty
             //
 
-            if (ifd->cachedBuffer->begin() != ifd->cachedBuffer->end())
+            if (ifd->cachedBuffer && ifd->cachedBuffer->begin() != ifd->cachedBuffer->end())
             {
                 ifd->tFile->readTiles (0, ifd->tFile->numXTiles (0) - 1, j, j);
             }","{'deleted_lines': ['            if (ifd->cachedBuffer->begin() != ifd->cachedBuffer->end())'], 'added_lines': ['            if (ifd->cachedBuffer && ifd->cachedBuffer->begin() != ifd->cachedBuffer->end())']}",True,"A flaw was found in OpenEXR's TiledInputFile functionality. This flaw allows an attacker who can submit a crafted single-part non-image to be processed by OpenEXR, to trigger a floating-point exception error. The highest threat from this vulnerability is to system availability.",5.5,MEDIUM,1,valid,2020-09-22T23:00:16Z,3
CVE-2021-20302,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,AcademySoftwareFoundation/openexr,"add exrcheck binary and function in IlmImfUtil

Signed-off-by: Peter Hillman <peterh@wetafx.co.nz>",f044caeed5c0f1566d804f37cbddb2d5ccfd75ea,https://github.com/AcademySoftwareFoundation/openexr/commit/f044caeed5c0f1566d804f37cbddb2d5ccfd75ea,OpenEXR/IlmImf/ImfDeepScanLineInputFile.cpp,LineBufferTask::execute,"void
LineBufferTask::execute ()
{
try
{
if (_lineBuffer->uncompressedData == 0)
{
Int64 uncompressedSize = 0;
int maxY = min (_lineBuffer->maxY, _ifd->maxY);
for (int i = _lineBuffer->minY - _ifd->minY;
i <= maxY - _ifd->minY;
++i)
{
uncompressedSize += (int) _ifd->bytesPerLine[i];
}
if (_lineBuffer->compressor != 0)
delete _lineBuffer->compressor;
Int64 maxBytesPerLine = 0;
for (int i = _lineBuffer->minY - _ifd->minY;
i <= maxY - _ifd->minY;
++i)
{
if (_ifd->bytesPerLine[i] > maxBytesPerLine)
maxBytesPerLine = _ifd->bytesPerLine[i];
}
_lineBuffer->compressor = newCompressor(_ifd->header.compression(),
maxBytesPerLine,
_ifd->header);
if (_lineBuffer->compressor &&
_lineBuffer->packedDataSize < uncompressedSize)
{
_lineBuffer->format = _lineBuffer->compressor->format();
_lineBuffer->packedDataSize = _lineBuffer->compressor->uncompress
(_lineBuffer->buffer, _lineBuffer->packedDataSize,
_lineBuffer->minY, _lineBuffer->uncompressedData);
}
else
{
_lineBuffer->format = Compressor::XDR;
_lineBuffer->uncompressedData = _lineBuffer->buffer;
}
}
int yStart, yStop, dy;
if (_ifd->lineOrder == INCREASING_Y)
{
yStart = _scanLineMin;
yStop = _scanLineMax + 1;
dy = 1;
}
else
{
yStart = _scanLineMax;
yStop = _scanLineMin - 1;
dy = -1;
}
for (int y = yStart; y != yStop; y += dy)
{
const char *readPtr = _lineBuffer->uncompressedData +
_ifd->offsetInLineBuffer[y - _ifd->minY];
for (unsigned int i = 0; i < _ifd->slices.size(); ++i)
{
InSliceInfo &slice = *_ifd->slices[i];
if (modp (y, slice.ySampling) != 0)
continue;
if (slice.skip)
{
skipChannel (readPtr, slice.typeInFile,
_ifd->lineSampleCount[y - _ifd->minY]);
}
else
{
int width = (_ifd->maxX - _ifd->minX + 1);
copyIntoDeepFrameBuffer (readPtr, slice.base,
(char*) (&_ifd->sampleCount[0][0]
- _ifd->minX
- _ifd->minY * width),
sizeof(unsigned int) * 1,
sizeof(unsigned int) * width,
y, _ifd->minX, _ifd->maxX,
0, 0,
0, 0,
slice.sampleStride, 
slice.xPointerStride,
slice.yPointerStride,
slice.fill,
slice.fillValue, _lineBuffer->format,
slice.typeInFrameBuffer,
slice.typeInFile);
}
}
}
}
catch (std::exception &e)
{
if (!_lineBuffer->hasException)
{
_lineBuffer->exception = e.what();
_lineBuffer->hasException = true;
}
}
catch (...)
{
if (!_lineBuffer->hasException)
{
_lineBuffer->exception = ""unrecognized exception"";
_lineBuffer->hasException = true;
}
}
}","void
LineBufferTask::execute ()
{
try
{
if (VAR_0->uncompressedData == 0)
{
Int64 VAR_1 = 0;
int VAR_2 = min (VAR_0->maxY, VAR_3->maxY);
for (int VAR_4 = VAR_0->minY - VAR_3->minY;
VAR_4 <= VAR_2 - VAR_3->minY;
++VAR_4)
{
VAR_1 += (int) VAR_3->bytesPerLine[VAR_4];
}
if (VAR_0->compressor != 0)
delete VAR_0->compressor;
Int64 VAR_5 = 0;
for (int VAR_4 = VAR_0->minY - VAR_3->minY;
VAR_4 <= VAR_2 - VAR_3->minY;
++VAR_4)
{
if (VAR_3->bytesPerLine[VAR_4] > VAR_5)
VAR_5 = VAR_3->bytesPerLine[VAR_4];
}
VAR_0->compressor = newCompressor(VAR_3->header.compression(),
VAR_5,
VAR_3->header);
if (VAR_0->compressor &&
VAR_0->packedDataSize < VAR_1)
{
VAR_0->format = VAR_0->compressor->format();
VAR_0->packedDataSize = VAR_0->compressor->uncompress
(VAR_0->buffer, VAR_0->packedDataSize,
VAR_0->minY, VAR_0->uncompressedData);
}
else
{
VAR_0->format = Compressor::XDR;
VAR_0->uncompressedData = VAR_0->buffer;
}
}
int VAR_6, VAR_7, VAR_8;
if (VAR_3->lineOrder == VAR_9)
{
VAR_6 = VAR_10;
VAR_7 = VAR_11 + 1;
VAR_8 = 1;
}
else
{
VAR_6 = VAR_11;
VAR_7 = VAR_10 - 1;
VAR_8 = -1;
}
for (int VAR_12 = VAR_6; VAR_12 != VAR_7; VAR_12 += VAR_8)
{
const char *VAR_13 = VAR_0->uncompressedData +
VAR_3->offsetInLineBuffer[VAR_12 - VAR_3->minY];
for (unsigned int VAR_4 = 0; VAR_4 < VAR_3->slices.size(); ++VAR_4)
{
InSliceInfo &VAR_14 = *VAR_3->slices[VAR_4];
if (modp (VAR_12, VAR_14.ySampling) != 0)
continue;
if (VAR_14.skip)
{
skipChannel (VAR_13, VAR_14.typeInFile,
VAR_3->lineSampleCount[VAR_12 - VAR_3->minY]);
}
else
{
int VAR_15 = (VAR_3->maxX - VAR_3->minX + 1);
copyIntoDeepFrameBuffer (VAR_13, VAR_14.base,
(char*) (&VAR_3->sampleCount[0][0]
- VAR_3->minX
- VAR_3->minY * VAR_15),
sizeof(unsigned int) * 1,
sizeof(unsigned int) * VAR_15,
VAR_12, VAR_3->minX, VAR_3->maxX,
0, 0,
0, 0,
VAR_14.sampleStride, 
VAR_14.xPointerStride,
VAR_14.yPointerStride,
VAR_14.fill,
VAR_14.fillValue, VAR_0->format,
VAR_14.typeInFrameBuffer,
VAR_14.typeInFile);
}
}
}
}
catch (std::exception &VAR_16)
{
if (!VAR_0->hasException)
{
VAR_0->exception = VAR_16.what();
VAR_0->hasException = true;
}
}
catch (...)
{
if (!VAR_0->hasException)
{
VAR_0->exception = ""unrecognized exception"";
VAR_0->hasException = true;
}
}
}",,"void
LineBufferTask::execute ()
{
    try
    {
        //
        // Uncompress the data, if necessary
        //

        if (_lineBuffer->uncompressedData == 0)
        {
            Int64 uncompressedSize = 0;
            int maxY = min (_lineBuffer->maxY, _ifd->maxY);

            for (int i = _lineBuffer->minY - _ifd->minY;
                 i <= maxY - _ifd->minY;
                 ++i)
            {
                uncompressedSize += (int) _ifd->bytesPerLine[i];
            }

            //
            // Create the compressor everytime when we want to use it,
            // because we don't know maxBytesPerLine beforehand.
            // (TODO) optimize this. don't do this every time.
            //

            if (_lineBuffer->compressor != 0)
                delete _lineBuffer->compressor;
            Int64 maxBytesPerLine = 0;
            for (int i = _lineBuffer->minY - _ifd->minY;
                 i <= maxY - _ifd->minY;
                 ++i)
            {
                if (_ifd->bytesPerLine[i] > maxBytesPerLine)
                    maxBytesPerLine = _ifd->bytesPerLine[i];
            }
            _lineBuffer->compressor = newCompressor(_ifd->header.compression(),
                                                    maxBytesPerLine,
                                                    _ifd->header);

            if (_lineBuffer->compressor &&
                _lineBuffer->packedDataSize < uncompressedSize)
            {
                _lineBuffer->format = _lineBuffer->compressor->format();

                _lineBuffer->packedDataSize = _lineBuffer->compressor->uncompress
                    (_lineBuffer->buffer, _lineBuffer->packedDataSize,
                     _lineBuffer->minY, _lineBuffer->uncompressedData);
            }
            else
            {
                //
                // If the line is uncompressed, it's in XDR format,
                // regardless of the compressor's output format.
                //

                _lineBuffer->format = Compressor::XDR;
                _lineBuffer->uncompressedData = _lineBuffer->buffer;
            }
        }

        int yStart, yStop, dy;

        if (_ifd->lineOrder == INCREASING_Y)
        {
            yStart = _scanLineMin;
            yStop = _scanLineMax + 1;
            dy = 1;
        }
        else
        {
            yStart = _scanLineMax;
            yStop = _scanLineMin - 1;
            dy = -1;
        }

        for (int y = yStart; y != yStop; y += dy)
        {
            //
            // Convert one scan line's worth of pixel data back
            // from the machine-independent representation, and
            // store the result in the frame buffer.
            //

            const char *readPtr = _lineBuffer->uncompressedData +
                                  _ifd->offsetInLineBuffer[y - _ifd->minY];

            //
            // Iterate over all image channels.
            //

            for (unsigned int i = 0; i < _ifd->slices.size(); ++i)
            {
                //
                // Test if scan line y of this channel contains any data
                // (the scan line contains data only if y % ySampling == 0).
                //

                InSliceInfo &slice = *_ifd->slices[i];

                if (modp (y, slice.ySampling) != 0)
                    continue;

                //
                // Find the x coordinates of the leftmost and rightmost
                // sampled pixels (i.e. pixels within the data window
                // for which x % xSampling == 0).
                //

                //
                // Fill the frame buffer with pixel data.
                //

                if (slice.skip)
                {
                    //
                    // The file contains data for this channel, but
                    // the frame buffer contains no slice for this channel.
                    //

                    skipChannel (readPtr, slice.typeInFile,
                                 _ifd->lineSampleCount[y - _ifd->minY]);
                }
                else
                {
                    //
                    // The frame buffer contains a slice for this channel.
                    //

                    int width = (_ifd->maxX - _ifd->minX + 1);

                    ptrdiff_t base = reinterpret_cast<ptrdiff_t>(&_ifd->sampleCount[0][0]);
                    base -= sizeof(unsigned int)*_ifd->minX;
                    base -= sizeof(unsigned int)*static_cast<ptrdiff_t>(_ifd->minY) * static_cast<ptrdiff_t>(width);

                    copyIntoDeepFrameBuffer (readPtr, slice.base,
                                             reinterpret_cast<char*>(base),
                                             sizeof(unsigned int) * 1,
                                             sizeof(unsigned int) * width,
                                             y, _ifd->minX, _ifd->maxX,
                                             0, 0,
                                             0, 0,
                                             slice.sampleStride, 
                                             slice.xPointerStride,
                                             slice.yPointerStride,
                                             slice.fill,
                                             slice.fillValue, _lineBuffer->format,
                                             slice.typeInFrameBuffer,
                                             slice.typeInFile);
                }
            }
        }
    }
    catch (std::exception &e)
    {
        if (!_lineBuffer->hasException)
        {
            _lineBuffer->exception = e.what();
            _lineBuffer->hasException = true;
        }
    }
    catch (...)
    {
        if (!_lineBuffer->hasException)
        {
            _lineBuffer->exception = ""unrecognized exception"";
            _lineBuffer->hasException = true;
        }
    }
}","void
LineBufferTask::execute ()
{
    try
    {
        /* COMMENT_0 */
        /* COMMENT_1 */
        /* COMMENT_0 */

        if (VAR_0->uncompressedData == 0)
        {
            Int64 VAR_1 = 0;
            int VAR_2 = min (VAR_0->maxY, VAR_3->maxY);

            for (int VAR_4 = VAR_0->minY - VAR_3->minY;
                 VAR_4 <= VAR_2 - VAR_3->minY;
                 ++VAR_4)
            {
                VAR_1 += (int) VAR_3->bytesPerLine[VAR_4];
            }

            /* COMMENT_0 */
            /* COMMENT_2 */
            /* COMMENT_3 */
            /* COMMENT_4 */
            /* COMMENT_0 */

            if (VAR_0->compressor != 0)
                delete VAR_0->compressor;
            Int64 VAR_5 = 0;
            for (int VAR_4 = VAR_0->minY - VAR_3->minY;
                 VAR_4 <= VAR_2 - VAR_3->minY;
                 ++VAR_4)
            {
                if (VAR_3->bytesPerLine[VAR_4] > VAR_5)
                    VAR_5 = VAR_3->bytesPerLine[VAR_4];
            }
            VAR_0->compressor = newCompressor(VAR_3->header.compression(),
                                                    VAR_5,
                                                    VAR_3->header);

            if (VAR_0->compressor &&
                VAR_0->packedDataSize < VAR_1)
            {
                VAR_0->format = VAR_0->compressor->format();

                VAR_0->packedDataSize = VAR_0->compressor->uncompress
                    (VAR_0->buffer, VAR_0->packedDataSize,
                     VAR_0->minY, VAR_0->uncompressedData);
            }
            else
            {
                /* COMMENT_0 */
                /* COMMENT_5 */
                /* COMMENT_6 */
                /* COMMENT_0 */

                VAR_0->format = Compressor::XDR;
                VAR_0->uncompressedData = VAR_0->buffer;
            }
        }

        int VAR_6, VAR_7, VAR_8;

        if (VAR_3->lineOrder == VAR_9)
        {
            VAR_6 = VAR_10;
            VAR_7 = VAR_11 + 1;
            VAR_8 = 1;
        }
        else
        {
            VAR_6 = VAR_11;
            VAR_7 = VAR_10 - 1;
            VAR_8 = -1;
        }

        for (int VAR_12 = VAR_6; VAR_12 != VAR_7; VAR_12 += VAR_8)
        {
            /* COMMENT_0 */
            /* COMMENT_7 */
            /* COMMENT_8 */
            /* COMMENT_9 */
            /* COMMENT_0 */

            const char *VAR_13 = VAR_0->uncompressedData +
                                  VAR_3->offsetInLineBuffer[VAR_12 - VAR_3->minY];

            /* COMMENT_0 */
            /* COMMENT_10 */
            /* COMMENT_0 */

            for (unsigned int VAR_4 = 0; VAR_4 < VAR_3->slices.size(); ++VAR_4)
            {
                /* COMMENT_0 */
                /* COMMENT_11 */
                /* COMMENT_12 */
                /* COMMENT_0 */

                InSliceInfo &VAR_14 = *VAR_3->slices[VAR_4];

                if (modp (VAR_12, VAR_14.ySampling) != 0)
                    continue;

                /* COMMENT_0 */
                /* COMMENT_13 */
                /* COMMENT_14 */
                /* COMMENT_15 */
                /* COMMENT_0 */

                /* COMMENT_0 */
                /* COMMENT_16 */
                /* COMMENT_0 */

                if (VAR_14.skip)
                {
                    /* COMMENT_0 */
                    /* COMMENT_17 */
                    /* COMMENT_18 */
                    /* COMMENT_0 */

                    skipChannel (VAR_13, VAR_14.typeInFile,
                                 VAR_3->lineSampleCount[VAR_12 - VAR_3->minY]);
                }
                else
                {
                    /* COMMENT_0 */
                    /* COMMENT_19 */
                    /* COMMENT_0 */

                    int VAR_15 = (VAR_3->maxX - VAR_3->minX + 1);

                    ptrdiff_t VAR_16 = VAR_17<ptrdiff_t>(&VAR_3->sampleCount[0][0]);
                    VAR_16 -= sizeof(unsigned int)*VAR_3->minX;
                    VAR_16 -= sizeof(unsigned int)*VAR_18<ptrdiff_t>(VAR_3->minY) * VAR_18<ptrdiff_t>(VAR_15);

                    copyIntoDeepFrameBuffer (VAR_13, VAR_14.base,
                                             VAR_17<char*>(VAR_16),
                                             sizeof(unsigned int) * 1,
                                             sizeof(unsigned int) * VAR_15,
                                             VAR_12, VAR_3->minX, VAR_3->maxX,
                                             0, 0,
                                             0, 0,
                                             VAR_14.sampleStride, 
                                             VAR_14.xPointerStride,
                                             VAR_14.yPointerStride,
                                             VAR_14.fill,
                                             VAR_14.fillValue, VAR_0->format,
                                             VAR_14.typeInFrameBuffer,
                                             VAR_14.typeInFile);
                }
            }
        }
    }
    catch (std::exception &VAR_19)
    {
        if (!VAR_0->hasException)
        {
            VAR_0->exception = VAR_19.what();
            VAR_0->hasException = true;
        }
    }
    catch (...)
    {
        if (!VAR_0->hasException)
        {
            VAR_0->exception = ""unrecognized exception"";
            VAR_0->hasException = true;
        }
    }
}",,"--- func_before
+++ func_after
@@ -130,10 +130,12 @@
 
                     int width = (_ifd->maxX - _ifd->minX + 1);
 
+                    ptrdiff_t base = reinterpret_cast<ptrdiff_t>(&_ifd->sampleCount[0][0]);
+                    base -= sizeof(unsigned int)*_ifd->minX;
+                    base -= sizeof(unsigned int)*static_cast<ptrdiff_t>(_ifd->minY) * static_cast<ptrdiff_t>(width);
+
                     copyIntoDeepFrameBuffer (readPtr, slice.base,
-                                             (char*) (&_ifd->sampleCount[0][0]
-                                                      - _ifd->minX
-                                                      - _ifd->minY * width),
+                                             reinterpret_cast<char*>(base),
                                              sizeof(unsigned int) * 1,
                                              sizeof(unsigned int) * width,
                                              y, _ifd->minX, _ifd->maxX,","{'deleted_lines': ['                                             (char*) (&_ifd->sampleCount[0][0]', '                                                      - _ifd->minX', '                                                      - _ifd->minY * width),'], 'added_lines': ['                    ptrdiff_t base = reinterpret_cast<ptrdiff_t>(&_ifd->sampleCount[0][0]);', '                    base -= sizeof(unsigned int)*_ifd->minX;', '                    base -= sizeof(unsigned int)*static_cast<ptrdiff_t>(_ifd->minY) * static_cast<ptrdiff_t>(width);', '', '                                             reinterpret_cast<char*>(base),']}",True,"A flaw was found in OpenEXR's TiledInputFile functionality. This flaw allows an attacker who can submit a crafted single-part non-image to be processed by OpenEXR, to trigger a floating-point exception error. The highest threat from this vulnerability is to system availability.",5.5,MEDIUM,1,valid,2020-09-22T23:00:16Z,3
CVE-2020-26682,['CWE-190'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,libass,"outline: fix overflows in outline processing

This commit enforces strict invariant on ASS_Outline
to contain point coordinates into predetermined range.

Fixes https://github.com/libass/libass/issues/431.",676f9dc5b52ef406c5527bdadbcb947f11392929,https://github.com/libass/libass/commit/676f9dc5b52ef406c5527bdadbcb947f11392929,libass/ass_outline.c,outline_scale_pow2,"bool outline_scale_pow2(ASS_Outline *outline, const ASS_Outline *source,
int scale_ord_x, int scale_ord_y)
{
if (!source || !source->n_points) {
outline_clear(outline);
return true;
}
if (!outline_alloc(outline, source->n_points, source->n_segments))
return false;
int sx = scale_ord_x + 32;
int sy = scale_ord_y + 32;
const ASS_Vector *pt = source->points;
for (size_t i = 0; i < source->n_points; i++) {
outline->points[i].x = pt[i].x * ((int64_t) 1 << sx) >> 32;
outline->points[i].y = pt[i].y * ((int64_t) 1 << sy) >> 32;
}
memcpy(outline->segments, source->segments, source->n_segments);
outline->n_points = source->n_points;
outline->n_segments = source->n_segments;
return true;
}","bool outline_scale_pow2(ASS_Outline *VAR_0, const ASS_Outline *VAR_1,
int VAR_2, int VAR_3)
{
if (!VAR_1 || !VAR_1->n_points) {
outline_clear(VAR_0);
return true;
}
if (!outline_alloc(VAR_0, VAR_1->n_points, VAR_1->n_segments))
return false;
int VAR_4 = VAR_2 + 32;
int VAR_5 = VAR_3 + 32;
const ASS_Vector *VAR_6 = VAR_1->points;
for (size_t VAR_7 = 0; VAR_7 < VAR_1->n_points; VAR_7++) {
VAR_0->points[VAR_7].x = VAR_6[VAR_7].x * ((int64_t) 1 << VAR_4) >> 32;
VAR_0->points[VAR_7].y = VAR_6[VAR_7].y * ((int64_t) 1 << VAR_5) >> 32;
}
memcpy(VAR_0->segments, VAR_1->segments, VAR_1->n_segments);
VAR_0->n_points = VAR_1->n_points;
VAR_0->n_segments = VAR_1->n_segments;
return true;
}",libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/before/5.json,"bool outline_scale_pow2(ASS_Outline *outline, const ASS_Outline *source,
                        int scale_ord_x, int scale_ord_y)
{
    if (!source || !source->n_points) {
        outline_clear(outline);
        return true;
    }

    int32_t lim_x = OUTLINE_MAX;
    if (scale_ord_x > 0)
        lim_x = scale_ord_x < 32 ? lim_x >> scale_ord_x : 0;
    else
        scale_ord_x = FFMAX(scale_ord_x, -32);

    int32_t lim_y = OUTLINE_MAX;
    if (scale_ord_y > 0)
        lim_y = scale_ord_y < 32 ? lim_y >> scale_ord_y : 0;
    else
        scale_ord_y = FFMAX(scale_ord_y, -32);

    if (!lim_x || !lim_y) {
        outline_clear(outline);
        return false;
    }

    if (!outline_alloc(outline, source->n_points, source->n_segments))
        return false;

    int sx = scale_ord_x + 32;
    int sy = scale_ord_y + 32;
    const ASS_Vector *pt = source->points;
    for (size_t i = 0; i < source->n_points; i++) {
        if (abs(pt[i].x) > lim_x || abs(pt[i].y) > lim_y) {
            outline_free(outline);
            return false;
        }
        // that's equivalent to pt[i].x << scale_ord_x,
        // but works even for negative coordinate and/or shift amount
        outline->points[i].x = pt[i].x * ((int64_t) 1 << sx) >> 32;
        outline->points[i].y = pt[i].y * ((int64_t) 1 << sy) >> 32;
    }
    memcpy(outline->segments, source->segments, source->n_segments);
    outline->n_points = source->n_points;
    outline->n_segments = source->n_segments;
    return true;
}","bool outline_scale_pow2(ASS_Outline *VAR_0, const ASS_Outline *VAR_1,
                        int VAR_2, int VAR_3)
{
    if (!VAR_1 || !VAR_1->n_points) {
        outline_clear(VAR_0);
        return true;
    }

    int32_t VAR_4 = VAR_5;
    if (VAR_2 > 0)
        VAR_4 = VAR_2 < 32 ? VAR_4 >> VAR_2 : 0;
    else
        VAR_2 = FFMAX(VAR_2, -32);

    int32_t VAR_6 = VAR_5;
    if (VAR_3 > 0)
        VAR_6 = VAR_3 < 32 ? VAR_6 >> VAR_3 : 0;
    else
        VAR_3 = FFMAX(VAR_3, -32);

    if (!VAR_4 || !VAR_6) {
        outline_clear(VAR_0);
        return false;
    }

    if (!outline_alloc(VAR_0, VAR_1->n_points, VAR_1->n_segments))
        return false;

    int VAR_7 = VAR_2 + 32;
    int VAR_8 = VAR_3 + 32;
    const ASS_Vector *VAR_9 = VAR_1->points;
    for (size_t VAR_10 = 0; VAR_10 < VAR_1->n_points; VAR_10++) {
        if (abs(VAR_9[VAR_10].x) > VAR_4 || abs(VAR_9[VAR_10].y) > VAR_6) {
            outline_free(VAR_0);
            return false;
        }
        /* COMMENT_0 */
        /* COMMENT_1 */
        VAR_0->points[VAR_10].x = VAR_9[VAR_10].x * ((int64_t) 1 << VAR_7) >> 32;
        VAR_0->points[VAR_10].y = VAR_9[VAR_10].y * ((int64_t) 1 << VAR_8) >> 32;
    }
    memcpy(VAR_0->segments, VAR_1->segments, VAR_1->n_segments);
    VAR_0->n_points = VAR_1->n_points;
    VAR_0->n_segments = VAR_1->n_segments;
    return true;
}",libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/after/5.json,"--- func_before
+++ func_after
@@ -4,6 +4,23 @@
     if (!source || !source->n_points) {
         outline_clear(outline);
         return true;
+    }
+
+    int32_t lim_x = OUTLINE_MAX;
+    if (scale_ord_x > 0)
+        lim_x = scale_ord_x < 32 ? lim_x >> scale_ord_x : 0;
+    else
+        scale_ord_x = FFMAX(scale_ord_x, -32);
+
+    int32_t lim_y = OUTLINE_MAX;
+    if (scale_ord_y > 0)
+        lim_y = scale_ord_y < 32 ? lim_y >> scale_ord_y : 0;
+    else
+        scale_ord_y = FFMAX(scale_ord_y, -32);
+
+    if (!lim_x || !lim_y) {
+        outline_clear(outline);
+        return false;
     }
 
     if (!outline_alloc(outline, source->n_points, source->n_segments))
@@ -13,6 +30,10 @@
     int sy = scale_ord_y + 32;
     const ASS_Vector *pt = source->points;
     for (size_t i = 0; i < source->n_points; i++) {
+        if (abs(pt[i].x) > lim_x || abs(pt[i].y) > lim_y) {
+            outline_free(outline);
+            return false;
+        }
         // that's equivalent to pt[i].x << scale_ord_x,
         // but works even for negative coordinate and/or shift amount
         outline->points[i].x = pt[i].x * ((int64_t) 1 << sx) >> 32;","{'deleted_lines': [], 'added_lines': ['    }', '', '    int32_t lim_x = OUTLINE_MAX;', '    if (scale_ord_x > 0)', '        lim_x = scale_ord_x < 32 ? lim_x >> scale_ord_x : 0;', '    else', '        scale_ord_x = FFMAX(scale_ord_x, -32);', '', '    int32_t lim_y = OUTLINE_MAX;', '    if (scale_ord_y > 0)', '        lim_y = scale_ord_y < 32 ? lim_y >> scale_ord_y : 0;', '    else', '        scale_ord_y = FFMAX(scale_ord_y, -32);', '', '    if (!lim_x || !lim_y) {', '        outline_clear(outline);', '        return false;', '        if (abs(pt[i].x) > lim_x || abs(pt[i].y) > lim_y) {', '            outline_free(outline);', '            return false;', '        }']}",True,"In libass 0.14.0, the `ass_outline_construct`'s call to `outline_stroke` causes a signed integer overflow.",8.8,HIGH,2,valid,2020-09-27T00:07:47Z,3
CVE-2020-26682,['CWE-190'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,libass,"outline: fix overflows in outline processing

This commit enforces strict invariant on ASS_Outline
to contain point coordinates into predetermined range.

Fixes https://github.com/libass/libass/issues/431.",676f9dc5b52ef406c5527bdadbcb947f11392929,https://github.com/libass/libass/commit/676f9dc5b52ef406c5527bdadbcb947f11392929,libass/ass_outline.c,outline_transform_2d,"bool outline_transform_2d(ASS_Outline *outline, const ASS_Outline *source,
const double m[2][3])
{
if (!source || !source->n_points) {
outline_clear(outline);
return true;
}
if (!outline_alloc(outline, source->n_points, source->n_segments))
return false;
const ASS_Vector *pt = source->points;
for (size_t i = 0; i < source->n_points; i++) {
double v[2];
for (int k = 0; k < 2; k++)
v[k] = m[k][0] * pt[i].x + m[k][1] * pt[i].y + m[k][2];
outline->points[i].x = lrint(v[0]);
outline->points[i].y = lrint(v[1]);
}
memcpy(outline->segments, source->segments, source->n_segments);
outline->n_points = source->n_points;
outline->n_segments = source->n_segments;
return true;
}","bool outline_transform_2d(ASS_Outline *VAR_0, const ASS_Outline *VAR_1,
const double VAR_2[2][3])
{
if (!VAR_1 || !VAR_1->n_points) {
outline_clear(VAR_0);
return true;
}
if (!outline_alloc(VAR_0, VAR_1->n_points, VAR_1->n_segments))
return false;
const ASS_Vector *VAR_3 = VAR_1->points;
for (size_t VAR_4 = 0; VAR_4 < VAR_1->n_points; VAR_4++) {
double VAR_5[2];
for (int VAR_6 = 0; VAR_6 < 2; VAR_6++)
VAR_5[VAR_6] = VAR_2[VAR_6][0] * VAR_3[VAR_4].x + VAR_2[VAR_6][1] * VAR_3[VAR_4].y + VAR_2[VAR_6][2];
VAR_0->points[VAR_4].x = lrint(VAR_5[0]);
VAR_0->points[VAR_4].y = lrint(VAR_5[1]);
}
memcpy(VAR_0->segments, VAR_1->segments, VAR_1->n_segments);
VAR_0->n_points = VAR_1->n_points;
VAR_0->n_segments = VAR_1->n_segments;
return true;
}",libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/before/3.json,"bool outline_transform_2d(ASS_Outline *outline, const ASS_Outline *source,
                         const double m[2][3])
{
    if (!source || !source->n_points) {
        outline_clear(outline);
        return true;
    }

    if (!outline_alloc(outline, source->n_points, source->n_segments))
        return false;

    const ASS_Vector *pt = source->points;
    for (size_t i = 0; i < source->n_points; i++) {
        double v[2];
        for (int k = 0; k < 2; k++)
            v[k] = m[k][0] * pt[i].x + m[k][1] * pt[i].y + m[k][2];

        if (!(fabs(v[0]) < OUTLINE_MAX && fabs(v[1]) < OUTLINE_MAX)) {
            outline_free(outline);
            return false;
        }
        outline->points[i].x = lrint(v[0]);
        outline->points[i].y = lrint(v[1]);
    }
    memcpy(outline->segments, source->segments, source->n_segments);
    outline->n_points = source->n_points;
    outline->n_segments = source->n_segments;
    return true;
}","bool outline_transform_2d(ASS_Outline *VAR_0, const ASS_Outline *VAR_1,
                         const double VAR_2[2][3])
{
    if (!VAR_1 || !VAR_1->n_points) {
        outline_clear(VAR_0);
        return true;
    }

    if (!outline_alloc(VAR_0, VAR_1->n_points, VAR_1->n_segments))
        return false;

    const ASS_Vector *VAR_3 = VAR_1->points;
    for (size_t VAR_4 = 0; VAR_4 < VAR_1->n_points; VAR_4++) {
        double VAR_5[2];
        for (int VAR_6 = 0; VAR_6 < 2; VAR_6++)
            VAR_5[VAR_6] = VAR_2[VAR_6][0] * VAR_3[VAR_4].x + VAR_2[VAR_6][1] * VAR_3[VAR_4].y + VAR_2[VAR_6][2];

        if (!(fabs(VAR_5[0]) < VAR_7 && fabs(VAR_5[1]) < VAR_7)) {
            outline_free(VAR_0);
            return false;
        }
        VAR_0->points[VAR_4].x = lrint(VAR_5[0]);
        VAR_0->points[VAR_4].y = lrint(VAR_5[1]);
    }
    memcpy(VAR_0->segments, VAR_1->segments, VAR_1->n_segments);
    VAR_0->n_points = VAR_1->n_points;
    VAR_0->n_segments = VAR_1->n_segments;
    return true;
}",libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -15,6 +15,10 @@
         for (int k = 0; k < 2; k++)
             v[k] = m[k][0] * pt[i].x + m[k][1] * pt[i].y + m[k][2];
 
+        if (!(fabs(v[0]) < OUTLINE_MAX && fabs(v[1]) < OUTLINE_MAX)) {
+            outline_free(outline);
+            return false;
+        }
         outline->points[i].x = lrint(v[0]);
         outline->points[i].y = lrint(v[1]);
     }","{'deleted_lines': [], 'added_lines': ['        if (!(fabs(v[0]) < OUTLINE_MAX && fabs(v[1]) < OUTLINE_MAX)) {', '            outline_free(outline);', '            return false;', '        }']}",True,"In libass 0.14.0, the `ass_outline_construct`'s call to `outline_stroke` causes a signed integer overflow.",8.8,HIGH,2,valid,2020-09-27T00:07:47Z,3
CVE-2020-26682,['CWE-190'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,libass,"outline: fix overflows in outline processing

This commit enforces strict invariant on ASS_Outline
to contain point coordinates into predetermined range.

Fixes https://github.com/libass/libass/issues/431.",676f9dc5b52ef406c5527bdadbcb947f11392929,https://github.com/libass/libass/commit/676f9dc5b52ef406c5527bdadbcb947f11392929,libass/ass_outline.c,outline_add_point,"bool outline_add_point(ASS_Outline *outline, ASS_Vector pt, char segment)
{
if (outline->n_points >= outline->max_points) {
size_t new_size = 2 * outline->max_points;
if (!ASS_REALLOC_ARRAY(outline->points, new_size))
return false;
outline->max_points = new_size;
}
outline->points[outline->n_points] = pt;
outline->n_points++;
return !segment || outline_add_segment(outline, segment);
}","bool outline_add_point(ASS_Outline *VAR_0, ASS_Vector VAR_1, char VAR_2)
{
if (VAR_0->n_points >= VAR_0->max_points) {
size_t VAR_3 = 2 * VAR_0->max_points;
if (!ASS_REALLOC_ARRAY(VAR_0->points, VAR_3))
return false;
VAR_0->max_points = VAR_3;
}
VAR_0->points[VAR_0->n_points] = VAR_1;
VAR_0->n_points++;
return !VAR_2 || outline_add_segment(VAR_0, VAR_2);
}",libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/before/0.json,"bool outline_add_point(ASS_Outline *outline, ASS_Vector pt, char segment)
{
    if(abs(pt.x) > OUTLINE_MAX || abs(pt.y) > OUTLINE_MAX)
        return false;

    if (outline->n_points >= outline->max_points) {
        size_t new_size = 2 * outline->max_points;
        if (!ASS_REALLOC_ARRAY(outline->points, new_size))
            return false;
        outline->max_points = new_size;
    }
    outline->points[outline->n_points] = pt;
    outline->n_points++;

    return !segment || outline_add_segment(outline, segment);
}","bool outline_add_point(ASS_Outline *VAR_0, ASS_Vector VAR_1, char VAR_2)
{
    if(abs(VAR_1.x) > VAR_3 || abs(VAR_1.y) > VAR_3)
        return false;

    if (VAR_0->n_points >= VAR_0->max_points) {
        size_t VAR_4 = 2 * VAR_0->max_points;
        if (!ASS_REALLOC_ARRAY(VAR_0->points, VAR_4))
            return false;
        VAR_0->max_points = VAR_4;
    }
    VAR_0->points[VAR_0->n_points] = VAR_1;
    VAR_0->n_points++;

    return !VAR_2 || outline_add_segment(VAR_0, VAR_2);
}",libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,8 @@
 bool outline_add_point(ASS_Outline *outline, ASS_Vector pt, char segment)
 {
+    if(abs(pt.x) > OUTLINE_MAX || abs(pt.y) > OUTLINE_MAX)
+        return false;
+
     if (outline->n_points >= outline->max_points) {
         size_t new_size = 2 * outline->max_points;
         if (!ASS_REALLOC_ARRAY(outline->points, new_size))","{'deleted_lines': [], 'added_lines': ['    if(abs(pt.x) > OUTLINE_MAX || abs(pt.y) > OUTLINE_MAX)', '        return false;', '']}",True,"In libass 0.14.0, the `ass_outline_construct`'s call to `outline_stroke` causes a signed integer overflow.",8.8,HIGH,2,valid,2020-09-27T00:07:47Z,3
CVE-2020-26682,['CWE-190'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,libass,"outline: fix overflows in outline processing

This commit enforces strict invariant on ASS_Outline
to contain point coordinates into predetermined range.

Fixes https://github.com/libass/libass/issues/431.",676f9dc5b52ef406c5527bdadbcb947f11392929,https://github.com/libass/libass/commit/676f9dc5b52ef406c5527bdadbcb947f11392929,libass/ass_outline.c,outline_convert,"bool outline_convert(ASS_Outline *outline, const FT_Outline *source)
{
if (!source || !source->n_points) {
outline_clear(outline);
return true;
}
if (!outline_alloc(outline, 2 * source->n_points, source->n_points))
return false;
enum Status {
S_ON, S_Q, S_C1, S_C2
};
for (size_t i = 0, j = 0; i < source->n_contours; i++) {
ASS_Vector pt;
bool skip_last = false;
enum Status st;
int last = source->contours[i];
if (j > last || last >= source->n_points)
goto fail;
if (last - j < 2) {
j = last + 1;
continue;
}
switch (FT_CURVE_TAG(source->tags[j])) {
case FT_CURVE_TAG_ON:
st = S_ON;
break;
case FT_CURVE_TAG_CONIC:
pt.x =  source->points[last].x;
pt.y = -source->points[last].y;
switch (FT_CURVE_TAG(source->tags[last])) {
case FT_CURVE_TAG_ON:
skip_last = true;
break;
case FT_CURVE_TAG_CONIC:
pt.x = (pt.x + source->points[j].x) >> 1;
pt.y = (pt.y - source->points[j].y) >> 1;
break;
default:
goto fail;
}
outline->points[outline->n_points++] = pt;
st = S_Q;
break;
default:
goto fail;
}
pt.x =  source->points[j].x;
pt.y = -source->points[j].y;
outline->points[outline->n_points++] = pt;
for (j++; j <= last; j++) {
switch (FT_CURVE_TAG(source->tags[j])) {
case FT_CURVE_TAG_ON:
switch (st) {
case S_ON:
outline->segments[outline->n_segments++] = OUTLINE_LINE_SEGMENT;
break;
case S_Q:
outline->segments[outline->n_segments++] = OUTLINE_QUADRATIC_SPLINE;
break;
case S_C2:
outline->segments[outline->n_segments++] = OUTLINE_CUBIC_SPLINE;
break;
default:
goto fail;
}
st = S_ON;
break;
case FT_CURVE_TAG_CONIC:
switch (st) {
case S_ON:
st = S_Q;
break;
case S_Q:
outline->segments[outline->n_segments++] = OUTLINE_QUADRATIC_SPLINE;
pt.x = (pt.x + source->points[j].x) >> 1;
pt.y = (pt.y - source->points[j].y) >> 1;
outline->points[outline->n_points++] = pt;
break;
default:
goto fail;
}
break;
case FT_CURVE_TAG_CUBIC:
switch (st) {
case S_ON:
st = S_C1;
break;
case S_C1:
st = S_C2;
break;
default:
goto fail;
}
break;
default:
goto fail;
}
pt.x =  source->points[j].x;
pt.y = -source->points[j].y;
outline->points[outline->n_points++] = pt;
}
switch (st) {
case S_ON:
if (skip_last) {
outline->n_points--;
break;
}
outline->segments[outline->n_segments++] = OUTLINE_LINE_SEGMENT;
break;
case S_Q:
outline->segments[outline->n_segments++] = OUTLINE_QUADRATIC_SPLINE;
break;
case S_C2:
outline->segments[outline->n_segments++] = OUTLINE_CUBIC_SPLINE;
break;
default:
goto fail;
}
outline->segments[outline->n_segments - 1] |= OUTLINE_CONTOUR_END;
}
return true;
fail:
outline_free(outline);
return false;
}","bool outline_convert(ASS_Outline *VAR_0, const FT_Outline *VAR_1)
{
if (!VAR_1 || !VAR_1->n_points) {
outline_clear(VAR_0);
return true;
}
if (!outline_alloc(VAR_0, 2 * VAR_1->n_points, VAR_1->n_points))
return false;
enum Status {
VAR_2, VAR_3, VAR_4, VAR_5
};
for (size_t VAR_6 = 0, VAR_7 = 0; VAR_6 < VAR_1->n_contours; VAR_6++) {
ASS_Vector VAR_8;
bool VAR_9 = false;
enum Status VAR_10;
int VAR_11 = VAR_1->contours[VAR_6];
if (VAR_7 > VAR_11 || VAR_11 >= VAR_1->n_points)
goto fail;
if (VAR_11 - VAR_7 < 2) {
VAR_7 = VAR_11 + 1;
continue;
}
switch (FT_CURVE_TAG(VAR_1->tags[VAR_7])) {
case VAR_12:
VAR_10 = VAR_2;
break;
case VAR_13:
VAR_8.x =  VAR_1->points[VAR_11].x;
VAR_8.y = -VAR_1->points[VAR_11].y;
switch (FT_CURVE_TAG(VAR_1->tags[VAR_11])) {
case VAR_12:
VAR_9 = true;
break;
case VAR_13:
VAR_8.x = (VAR_8.x + VAR_1->points[VAR_7].x) >> 1;
VAR_8.y = (VAR_8.y - VAR_1->points[VAR_7].y) >> 1;
break;
default:
goto fail;
}
VAR_0->points[VAR_0->n_points++] = VAR_8;
VAR_10 = VAR_3;
break;
default:
goto fail;
}
VAR_8.x =  VAR_1->points[VAR_7].x;
VAR_8.y = -VAR_1->points[VAR_7].y;
VAR_0->points[VAR_0->n_points++] = VAR_8;
for (VAR_7++; VAR_7 <= VAR_11; VAR_7++) {
switch (FT_CURVE_TAG(VAR_1->tags[VAR_7])) {
case VAR_12:
switch (VAR_10) {
case VAR_2:
VAR_0->segments[VAR_0->n_segments++] = VAR_14;
break;
case VAR_3:
VAR_0->segments[VAR_0->n_segments++] = VAR_15;
break;
case VAR_5:
VAR_0->segments[VAR_0->n_segments++] = VAR_16;
break;
default:
goto fail;
}
VAR_10 = VAR_2;
break;
case VAR_13:
switch (VAR_10) {
case VAR_2:
VAR_10 = VAR_3;
break;
case VAR_3:
VAR_0->segments[VAR_0->n_segments++] = VAR_15;
VAR_8.x = (VAR_8.x + VAR_1->points[VAR_7].x) >> 1;
VAR_8.y = (VAR_8.y - VAR_1->points[VAR_7].y) >> 1;
VAR_0->points[VAR_0->n_points++] = VAR_8;
break;
default:
goto fail;
}
break;
case VAR_17:
switch (VAR_10) {
case VAR_2:
VAR_10 = VAR_4;
break;
case VAR_4:
VAR_10 = VAR_5;
break;
default:
goto fail;
}
break;
default:
goto fail;
}
VAR_8.x =  VAR_1->points[VAR_7].x;
VAR_8.y = -VAR_1->points[VAR_7].y;
VAR_0->points[VAR_0->n_points++] = VAR_8;
}
switch (VAR_10) {
case VAR_2:
if (VAR_9) {
VAR_0->n_points--;
break;
}
VAR_0->segments[VAR_0->n_segments++] = VAR_14;
break;
case VAR_3:
VAR_0->segments[VAR_0->n_segments++] = VAR_15;
break;
case VAR_5:
VAR_0->segments[VAR_0->n_segments++] = VAR_16;
break;
default:
goto fail;
}
VAR_0->segments[VAR_0->n_segments - 1] |= VAR_18;
}
return true;
fail:
outline_free(VAR_0);
return false;
}",libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/before/2.json,"bool outline_convert(ASS_Outline *outline, const FT_Outline *source)
{
    if (!source || !source->n_points) {
        outline_clear(outline);
        return true;
    }

    if (!outline_alloc(outline, 2 * source->n_points, source->n_points))
        return false;

    enum Status {
        S_ON, S_Q, S_C1, S_C2
    };

    for (size_t i = 0, j = 0; i < source->n_contours; i++) {
        ASS_Vector pt;
        bool skip_last = false;
        enum Status st;

        int last = source->contours[i];
        if (j > last || last >= source->n_points)
            goto fail;

        // skip degenerate 2-point contours from broken fonts
        if (last - j < 2) {
            j = last + 1;
            continue;
        }

        if (!valid_point(source->points + j))
            goto fail;
        switch (FT_CURVE_TAG(source->tags[j])) {
        case FT_CURVE_TAG_ON:
            st = S_ON;
            break;

        case FT_CURVE_TAG_CONIC:
            if (!valid_point(source->points + last))
                goto fail;
            pt.x =  source->points[last].x;
            pt.y = -source->points[last].y;
            switch (FT_CURVE_TAG(source->tags[last])) {
            case FT_CURVE_TAG_ON:
                skip_last = true;
                break;

            case FT_CURVE_TAG_CONIC:
                pt.x = (pt.x + source->points[j].x) >> 1;
                pt.y = (pt.y - source->points[j].y) >> 1;
                break;

            default:
                goto fail;
            }
            outline->points[outline->n_points++] = pt;
            st = S_Q;
            break;

        default:
            goto fail;
        }
        pt.x =  source->points[j].x;
        pt.y = -source->points[j].y;
        outline->points[outline->n_points++] = pt;

        for (j++; j <= last; j++) {
            if (!valid_point(source->points + j))
                goto fail;
            switch (FT_CURVE_TAG(source->tags[j])) {
            case FT_CURVE_TAG_ON:
                switch (st) {
                case S_ON:
                    outline->segments[outline->n_segments++] = OUTLINE_LINE_SEGMENT;
                    break;

                case S_Q:
                    outline->segments[outline->n_segments++] = OUTLINE_QUADRATIC_SPLINE;
                    break;

                case S_C2:
                    outline->segments[outline->n_segments++] = OUTLINE_CUBIC_SPLINE;
                    break;

                default:
                    goto fail;
                }
                st = S_ON;
                break;

            case FT_CURVE_TAG_CONIC:
                switch (st) {
                case S_ON:
                    st = S_Q;
                    break;

                case S_Q:
                    outline->segments[outline->n_segments++] = OUTLINE_QUADRATIC_SPLINE;
                    pt.x = (pt.x + source->points[j].x) >> 1;
                    pt.y = (pt.y - source->points[j].y) >> 1;
                    outline->points[outline->n_points++] = pt;
                    break;

                default:
                    goto fail;
                }
                break;

            case FT_CURVE_TAG_CUBIC:
                switch (st) {
                case S_ON:
                    st = S_C1;
                    break;

                case S_C1:
                    st = S_C2;
                    break;

                default:
                    goto fail;
                }
                break;

            default:
                goto fail;
            }
            pt.x =  source->points[j].x;
            pt.y = -source->points[j].y;
            outline->points[outline->n_points++] = pt;
        }

        switch (st) {
        case S_ON:
            if (skip_last) {
                outline->n_points--;
                break;
            }
            outline->segments[outline->n_segments++] = OUTLINE_LINE_SEGMENT;
            break;

        case S_Q:
            outline->segments[outline->n_segments++] = OUTLINE_QUADRATIC_SPLINE;
            break;

        case S_C2:
            outline->segments[outline->n_segments++] = OUTLINE_CUBIC_SPLINE;
            break;

        default:
            goto fail;
        }
        outline->segments[outline->n_segments - 1] |= OUTLINE_CONTOUR_END;
    }
    return true;

fail:
    outline_free(outline);
    return false;
}","bool outline_convert(ASS_Outline *VAR_0, const FT_Outline *VAR_1)
{
    if (!VAR_1 || !VAR_1->n_points) {
        outline_clear(VAR_0);
        return true;
    }

    if (!outline_alloc(VAR_0, 2 * VAR_1->n_points, VAR_1->n_points))
        return false;

    enum Status {
        VAR_2, VAR_3, VAR_4, VAR_5
    };

    for (size_t VAR_6 = 0, VAR_7 = 0; VAR_6 < VAR_1->n_contours; VAR_6++) {
        ASS_Vector VAR_8;
        bool VAR_9 = false;
        enum Status VAR_10;

        int VAR_11 = VAR_1->contours[VAR_6];
        if (VAR_7 > VAR_11 || VAR_11 >= VAR_1->n_points)
            goto fail;

        /* COMMENT_0 */
        if (VAR_11 - VAR_7 < 2) {
            VAR_7 = VAR_11 + 1;
            continue;
        }

        if (!valid_point(VAR_1->points + VAR_7))
            goto fail;
        switch (FT_CURVE_TAG(VAR_1->tags[VAR_7])) {
        case VAR_12:
            VAR_10 = VAR_2;
            break;

        case VAR_13:
            if (!valid_point(VAR_1->points + VAR_11))
                goto fail;
            VAR_8.x =  VAR_1->points[VAR_11].x;
            VAR_8.y = -VAR_1->points[VAR_11].y;
            switch (FT_CURVE_TAG(VAR_1->tags[VAR_11])) {
            case VAR_12:
                VAR_9 = true;
                break;

            case VAR_13:
                VAR_8.x = (VAR_8.x + VAR_1->points[VAR_7].x) >> 1;
                VAR_8.y = (VAR_8.y - VAR_1->points[VAR_7].y) >> 1;
                break;

            default:
                goto fail;
            }
            VAR_0->points[VAR_0->n_points++] = VAR_8;
            VAR_10 = VAR_3;
            break;

        default:
            goto fail;
        }
        VAR_8.x =  VAR_1->points[VAR_7].x;
        VAR_8.y = -VAR_1->points[VAR_7].y;
        VAR_0->points[VAR_0->n_points++] = VAR_8;

        for (VAR_7++; VAR_7 <= VAR_11; VAR_7++) {
            if (!valid_point(VAR_1->points + VAR_7))
                goto fail;
            switch (FT_CURVE_TAG(VAR_1->tags[VAR_7])) {
            case VAR_12:
                switch (VAR_10) {
                case VAR_2:
                    VAR_0->segments[VAR_0->n_segments++] = VAR_14;
                    break;

                case VAR_3:
                    VAR_0->segments[VAR_0->n_segments++] = VAR_15;
                    break;

                case VAR_5:
                    VAR_0->segments[VAR_0->n_segments++] = VAR_16;
                    break;

                default:
                    goto fail;
                }
                VAR_10 = VAR_2;
                break;

            case VAR_13:
                switch (VAR_10) {
                case VAR_2:
                    VAR_10 = VAR_3;
                    break;

                case VAR_3:
                    VAR_0->segments[VAR_0->n_segments++] = VAR_15;
                    VAR_8.x = (VAR_8.x + VAR_1->points[VAR_7].x) >> 1;
                    VAR_8.y = (VAR_8.y - VAR_1->points[VAR_7].y) >> 1;
                    VAR_0->points[VAR_0->n_points++] = VAR_8;
                    break;

                default:
                    goto fail;
                }
                break;

            case VAR_17:
                switch (VAR_10) {
                case VAR_2:
                    VAR_10 = VAR_4;
                    break;

                case VAR_4:
                    VAR_10 = VAR_5;
                    break;

                default:
                    goto fail;
                }
                break;

            default:
                goto fail;
            }
            VAR_8.x =  VAR_1->points[VAR_7].x;
            VAR_8.y = -VAR_1->points[VAR_7].y;
            VAR_0->points[VAR_0->n_points++] = VAR_8;
        }

        switch (VAR_10) {
        case VAR_2:
            if (VAR_9) {
                VAR_0->n_points--;
                break;
            }
            VAR_0->segments[VAR_0->n_segments++] = VAR_14;
            break;

        case VAR_3:
            VAR_0->segments[VAR_0->n_segments++] = VAR_15;
            break;

        case VAR_5:
            VAR_0->segments[VAR_0->n_segments++] = VAR_16;
            break;

        default:
            goto fail;
        }
        VAR_0->segments[VAR_0->n_segments - 1] |= VAR_18;
    }
    return true;

fail:
    outline_free(VAR_0);
    return false;
}",libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -27,12 +27,16 @@
             continue;
         }
 
+        if (!valid_point(source->points + j))
+            goto fail;
         switch (FT_CURVE_TAG(source->tags[j])) {
         case FT_CURVE_TAG_ON:
             st = S_ON;
             break;
 
         case FT_CURVE_TAG_CONIC:
+            if (!valid_point(source->points + last))
+                goto fail;
             pt.x =  source->points[last].x;
             pt.y = -source->points[last].y;
             switch (FT_CURVE_TAG(source->tags[last])) {
@@ -60,6 +64,8 @@
         outline->points[outline->n_points++] = pt;
 
         for (j++; j <= last; j++) {
+            if (!valid_point(source->points + j))
+                goto fail;
             switch (FT_CURVE_TAG(source->tags[j])) {
             case FT_CURVE_TAG_ON:
                 switch (st) {","{'deleted_lines': [], 'added_lines': ['        if (!valid_point(source->points + j))', '            goto fail;', '            if (!valid_point(source->points + last))', '                goto fail;', '            if (!valid_point(source->points + j))', '                goto fail;']}",True,"In libass 0.14.0, the `ass_outline_construct`'s call to `outline_stroke` causes a signed integer overflow.",8.8,HIGH,2,valid,2020-09-27T00:07:47Z,3
CVE-2020-26682,['CWE-190'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,libass,"outline: fix overflows in outline processing

This commit enforces strict invariant on ASS_Outline
to contain point coordinates into predetermined range.

Fixes https://github.com/libass/libass/issues/431.",676f9dc5b52ef406c5527bdadbcb947f11392929,https://github.com/libass/libass/commit/676f9dc5b52ef406c5527bdadbcb947f11392929,libass/ass_render.c,get_bitmap_glyph,"static void
get_bitmap_glyph(ASS_Renderer *render_priv, GlyphInfo *info,
ASS_Vector *pos, ASS_Vector *pos_o,
ASS_DVector *offset, bool first, int flags)
{
if (!info->outline || info->symbol == '\n' || info->symbol == 0 || info->skip) {
ass_cache_dec_ref(info->outline);
return;
}
double m1[3][3], m2[3][3], m[3][3];
const ASS_Transform *tr = &info->transform;
calc_transform_matrix(render_priv, info, m1);
for (int i = 0; i < 3; i++) {
m2[i][0] = m1[i][0] * tr->scale.x;
m2[i][1] = m1[i][1] * tr->scale.y;
m2[i][2] = m1[i][0] * tr->offset.x + m1[i][1] * tr->offset.y + m1[i][2];
}
memcpy(m, m2, sizeof(m));
BitmapHashKey key;
key.outline = info->outline;
if (!quantize_transform(m, pos, offset, first, &key)) {
ass_cache_dec_ref(info->outline);
return;
}
info->bm = ass_cache_get(render_priv->cache.bitmap_cache, &key, render_priv);
if (!info->bm || !info->bm->buffer) {
ass_cache_dec_ref(info->bm);
info->bm = NULL;
}
*pos_o = *pos;
OutlineHashKey ol_key;
if (flags & FILTER_BORDER_STYLE_3) {
if (!(flags & (FILTER_NONZERO_BORDER | FILTER_NONZERO_SHADOW)))
return;
ol_key.type = OUTLINE_BOX;
double w = 64 * render_priv->border_scale;
ASS_DVector bord = { info->border_x * w, info->border_y * w };
double width = info->hspacing_scaled + info->advance.x;
double height = info->asc + info->desc;
ASS_DVector orig_scale;
orig_scale.x = info->scale_x * info->scale_fix;
orig_scale.y = info->scale_y * info->scale_fix;
bord.x *= orig_scale.x;
bord.y *= orig_scale.y;
width  *= orig_scale.x;
height *= orig_scale.y;
bord.x = FFMAX(64, bord.x);
bord.y = FFMAX(64, bord.y);
ASS_DVector scale = {
(width  + 2 * bord.x) / 64,
(height + 2 * bord.y) / 64,
};
ASS_DVector offset = { -bord.x, -bord.y - info->asc };
for (int i = 0; i < 3; i++) {
m[i][0] = m1[i][0] * scale.x;
m[i][1] = m1[i][1] * scale.y;
m[i][2] = m1[i][0] * offset.x + m1[i][1] * offset.y + m1[i][2];
}
} else {
if (!(flags & FILTER_NONZERO_BORDER))
return;
ol_key.type = OUTLINE_BORDER;
BorderHashKey *k = &ol_key.u.border;
k->outline = info->outline;
double w = 64 * render_priv->border_scale;
double bord_x = w * info->border_x / tr->scale.x;
double bord_y = w * info->border_y / tr->scale.y;
const ASS_Rect *bbox = &info->outline->cbox;
double dx = (bbox->x_max - bbox->x_min) / 2.0 + (bord_x + 64);
double dy = (bbox->y_max - bbox->y_min) / 2.0 + (bord_y + 64);
double mxx = fabs(m[0][0]), mxy = fabs(m[0][1]);
double myx = fabs(m[1][0]), myy = fabs(m[1][1]);
double mzx = fabs(m[2][0]), mzy = fabs(m[2][1]);
double z0 = m[2][2] - mzx * dx - mzy * dy;
w = 1 / FFMAX(z0, m[2][2] / MAX_PERSP_SCALE);
double x_lim = mxx * dx + mxy * dy;
double y_lim = myx * dx + myy * dy;
double rz = FFMAX(x_lim, y_lim) * w;
w *= STROKER_PRECISION / POSITION_PRECISION;
frexp(w * (FFMAX(mxx, myx) + mzx * rz), &k->scale_ord_x);
frexp(w * (FFMAX(mxy, myy) + mzy * rz), &k->scale_ord_y);
k->border.x = lrint(ldexp(bord_x, k->scale_ord_x) / STROKER_PRECISION);
k->border.y = lrint(ldexp(bord_y, k->scale_ord_y) / STROKER_PRECISION);
if (!k->border.x && !k->border.y) {
ass_cache_inc_ref(info->bm);
info->bm_o = info->bm;
return;
}
for (int i = 0; i < 3; i++) {
m[i][0] = ldexp(m2[i][0], -k->scale_ord_x);
m[i][1] = ldexp(m2[i][1], -k->scale_ord_y);
m[i][2] = m2[i][2];
}
}
key.outline = ass_cache_get(render_priv->cache.outline_cache, &ol_key, render_priv);
if (!key.outline || !key.outline->valid ||
!quantize_transform(m, pos_o, offset, false, &key)) {
ass_cache_dec_ref(key.outline);
return;
}
info->bm_o = ass_cache_get(render_priv->cache.bitmap_cache, &key, render_priv);
if (!info->bm_o || !info->bm_o->buffer) {
ass_cache_dec_ref(info->bm_o);
info->bm_o = NULL;
*pos_o = *pos;
} else if (!info->bm)
*pos = *pos_o;
}","static void
get_bitmap_glyph(ASS_Renderer *VAR_0, GlyphInfo *VAR_1,
ASS_Vector *VAR_2, ASS_Vector *VAR_3,
ASS_DVector *VAR_4, bool VAR_5, int VAR_6)
{
if (!VAR_1->outline || VAR_1->symbol == '\n' || VAR_1->symbol == 0 || VAR_1->skip) {
ass_cache_dec_ref(VAR_1->outline);
return;
}
double VAR_7[3][3], VAR_8[3][3], VAR_9[3][3];
const ASS_Transform *VAR_10 = &VAR_1->transform;
calc_transform_matrix(VAR_0, VAR_1, VAR_7);
for (int VAR_11 = 0; VAR_11 < 3; VAR_11++) {
VAR_8[VAR_11][0] = VAR_7[VAR_11][0] * VAR_10->scale.x;
VAR_8[VAR_11][1] = VAR_7[VAR_11][1] * VAR_10->scale.y;
VAR_8[VAR_11][2] = VAR_7[VAR_11][0] * VAR_10->offset.x + VAR_7[VAR_11][1] * VAR_10->offset.y + VAR_7[VAR_11][2];
}
memcpy(VAR_9, VAR_8, sizeof(VAR_9));
BitmapHashKey VAR_12;
VAR_12.outline = VAR_1->outline;
if (!quantize_transform(VAR_9, VAR_2, VAR_4, VAR_5, &VAR_12)) {
ass_cache_dec_ref(VAR_1->outline);
return;
}
VAR_1->bm = ass_cache_get(VAR_0->cache.bitmap_cache, &VAR_12, VAR_0);
if (!VAR_1->bm || !VAR_1->bm->buffer) {
ass_cache_dec_ref(VAR_1->bm);
VAR_1->bm = NULL;
}
*VAR_3 = *VAR_2;
OutlineHashKey VAR_13;
if (VAR_6 & VAR_14) {
if (!(VAR_6 & (VAR_15 | VAR_16)))
return;
VAR_13.type = VAR_17;
double VAR_18 = 64 * VAR_0->border_scale;
ASS_DVector VAR_19 = { VAR_1->border_x * VAR_18, VAR_1->border_y * VAR_18 };
double VAR_20 = VAR_1->hspacing_scaled + VAR_1->advance.x;
double VAR_21 = VAR_1->asc + VAR_1->desc;
ASS_DVector VAR_22;
VAR_22.x = VAR_1->scale_x * VAR_1->scale_fix;
VAR_22.y = VAR_1->scale_y * VAR_1->scale_fix;
VAR_19.x *= VAR_22.x;
VAR_19.y *= VAR_22.y;
VAR_20  *= VAR_22.x;
VAR_21 *= VAR_22.y;
VAR_19.x = FFMAX(64, VAR_19.x);
VAR_19.y = FFMAX(64, VAR_19.y);
ASS_DVector VAR_23 = {
(VAR_20  + 2 * VAR_19.x) / 64,
(VAR_21 + 2 * VAR_19.y) / 64,
};
ASS_DVector VAR_4 = { -VAR_19.x, -VAR_19.y - VAR_1->asc };
for (int VAR_11 = 0; VAR_11 < 3; VAR_11++) {
VAR_9[VAR_11][0] = VAR_7[VAR_11][0] * VAR_23.x;
VAR_9[VAR_11][1] = VAR_7[VAR_11][1] * VAR_23.y;
VAR_9[VAR_11][2] = VAR_7[VAR_11][0] * VAR_4.x + VAR_7[VAR_11][1] * VAR_4.y + VAR_7[VAR_11][2];
}
} else {
if (!(VAR_6 & VAR_15))
return;
VAR_13.type = VAR_24;
BorderHashKey *VAR_25 = &VAR_13.u.border;
VAR_25->outline = VAR_1->outline;
double VAR_18 = 64 * VAR_0->border_scale;
double VAR_26 = VAR_18 * VAR_1->border_x / VAR_10->scale.x;
double VAR_27 = VAR_18 * VAR_1->border_y / VAR_10->scale.y;
const ASS_Rect *VAR_28 = &VAR_1->outline->cbox;
double VAR_29 = (VAR_28->x_max - VAR_28->x_min) / 2.0 + (VAR_26 + 64);
double VAR_30 = (VAR_28->y_max - VAR_28->y_min) / 2.0 + (VAR_27 + 64);
double VAR_31 = fabs(VAR_9[0][0]), VAR_32 = fabs(VAR_9[0][1]);
double VAR_33 = fabs(VAR_9[1][0]), VAR_34 = fabs(VAR_9[1][1]);
double VAR_35 = fabs(VAR_9[2][0]), VAR_36 = fabs(VAR_9[2][1]);
double VAR_37 = VAR_9[2][2] - VAR_35 * VAR_29 - VAR_36 * VAR_30;
VAR_18 = 1 / FFMAX(VAR_37, VAR_9[2][2] / VAR_38);
double VAR_39 = VAR_31 * VAR_29 + VAR_32 * VAR_30;
double VAR_40 = VAR_33 * VAR_29 + VAR_34 * VAR_30;
double VAR_41 = FFMAX(VAR_39, VAR_40) * VAR_18;
VAR_18 *= VAR_42 / VAR_43;
frexp(VAR_18 * (FFMAX(VAR_31, VAR_33) + VAR_35 * VAR_41), &VAR_25->scale_ord_x);
frexp(VAR_18 * (FFMAX(VAR_32, VAR_34) + VAR_36 * VAR_41), &VAR_25->scale_ord_y);
VAR_25->border.x = lrint(ldexp(VAR_26, VAR_25->scale_ord_x) / VAR_42);
VAR_25->border.y = lrint(ldexp(VAR_27, VAR_25->scale_ord_y) / VAR_42);
if (!VAR_25->border.x && !VAR_25->border.y) {
ass_cache_inc_ref(VAR_1->bm);
VAR_1->bm_o = VAR_1->bm;
return;
}
for (int VAR_11 = 0; VAR_11 < 3; VAR_11++) {
VAR_9[VAR_11][0] = ldexp(VAR_8[VAR_11][0], -VAR_25->scale_ord_x);
VAR_9[VAR_11][1] = ldexp(VAR_8[VAR_11][1], -VAR_25->scale_ord_y);
VAR_9[VAR_11][2] = VAR_8[VAR_11][2];
}
}
VAR_12.outline = ass_cache_get(VAR_0->cache.outline_cache, &VAR_13, VAR_0);
if (!VAR_12.outline || !VAR_12.outline->valid ||
!quantize_transform(VAR_9, VAR_3, VAR_4, false, &VAR_12)) {
ass_cache_dec_ref(VAR_12.outline);
return;
}
VAR_1->bm_o = ass_cache_get(VAR_0->cache.bitmap_cache, &VAR_12, VAR_0);
if (!VAR_1->bm_o || !VAR_1->bm_o->buffer) {
ass_cache_dec_ref(VAR_1->bm_o);
VAR_1->bm_o = NULL;
*VAR_3 = *VAR_2;
} else if (!VAR_1->bm)
*VAR_2 = *VAR_3;
}",libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_render.c/vul/before/0.json,"static void
get_bitmap_glyph(ASS_Renderer *render_priv, GlyphInfo *info,
                 ASS_Vector *pos, ASS_Vector *pos_o,
                 ASS_DVector *offset, bool first, int flags)
{
    if (!info->outline || info->symbol == '\n' || info->symbol == 0 || info->skip) {
        ass_cache_dec_ref(info->outline);
        return;
    }

    double m1[3][3], m2[3][3], m[3][3];
    const ASS_Transform *tr = &info->transform;
    calc_transform_matrix(render_priv, info, m1);
    for (int i = 0; i < 3; i++) {
        m2[i][0] = m1[i][0] * tr->scale.x;
        m2[i][1] = m1[i][1] * tr->scale.y;
        m2[i][2] = m1[i][0] * tr->offset.x + m1[i][1] * tr->offset.y + m1[i][2];
    }
    memcpy(m, m2, sizeof(m));

    BitmapHashKey key;
    key.outline = info->outline;
    if (!quantize_transform(m, pos, offset, first, &key)) {
        ass_cache_dec_ref(info->outline);
        return;
    }
    info->bm = ass_cache_get(render_priv->cache.bitmap_cache, &key, render_priv);
    if (!info->bm || !info->bm->buffer) {
        ass_cache_dec_ref(info->bm);
        info->bm = NULL;
    }
    *pos_o = *pos;

    OutlineHashKey ol_key;
    if (flags & FILTER_BORDER_STYLE_3) {
        if (!(flags & (FILTER_NONZERO_BORDER | FILTER_NONZERO_SHADOW)))
            return;

        ol_key.type = OUTLINE_BOX;

        double w = 64 * render_priv->border_scale;
        ASS_DVector bord = { info->border_x * w, info->border_y * w };
        double width = info->hspacing_scaled + info->advance.x;
        double height = info->asc + info->desc;

        ASS_DVector orig_scale;
        orig_scale.x = info->scale_x * info->scale_fix;
        orig_scale.y = info->scale_y * info->scale_fix;

        // Emulate the WTFish behavior of VSFilter, i.e. double-scale
        // the sizes of the opaque box.
        bord.x *= orig_scale.x;
        bord.y *= orig_scale.y;
        width  *= orig_scale.x;
        height *= orig_scale.y;

        // to avoid gaps
        bord.x = FFMAX(64, bord.x);
        bord.y = FFMAX(64, bord.y);

        ASS_DVector scale = {
            (width  + 2 * bord.x) / 64,
            (height + 2 * bord.y) / 64,
        };
        ASS_DVector offset = { -bord.x, -bord.y - info->asc };
        for (int i = 0; i < 3; i++) {
            m[i][0] = m1[i][0] * scale.x;
            m[i][1] = m1[i][1] * scale.y;
            m[i][2] = m1[i][0] * offset.x + m1[i][1] * offset.y + m1[i][2];
        }
    } else {
        if (!(flags & FILTER_NONZERO_BORDER))
            return;

        ol_key.type = OUTLINE_BORDER;
        BorderHashKey *k = &ol_key.u.border;
        k->outline = info->outline;

        double w = 64 * render_priv->border_scale;
        double bord_x = w * info->border_x / tr->scale.x;
        double bord_y = w * info->border_y / tr->scale.y;

        const ASS_Rect *bbox = &info->outline->cbox;
        // Estimate bounding box half size after stroking
        double dx = (bbox->x_max - bbox->x_min) / 2.0 + (bord_x + 64);
        double dy = (bbox->y_max - bbox->y_min) / 2.0 + (bord_y + 64);

        // Matrix after quantize_transform() has
        // input and output origin at bounding box center.
        double mxx = fabs(m[0][0]), mxy = fabs(m[0][1]);
        double myx = fabs(m[1][0]), myy = fabs(m[1][1]);
        double mzx = fabs(m[2][0]), mzy = fabs(m[2][1]);

        double z0 = m[2][2] - mzx * dx - mzy * dy;
        w = 1 / FFMAX(z0, m[2][2] / MAX_PERSP_SCALE);

        // Notation from quantize_transform().
        // Note that goal here is to estimate acceptable error for stroking, i. e. D(x) and D(y).
        // Matrix coefficients are constants now, so D(m_??) = 0.

        // D(z) <= |m_zx| * D(x) + |m_zy| * D(y),
        // D(x_out) = D((m_xx * x + m_xy * y) / z)
        //  <= (|m_xx| * D(x) + |m_xy| * D(y)) / z0 + x_lim * D(z) / z0^2
        //  <= (|m_xx| / z0 + |m_zx| * x_lim / z0^2) * D(x)
        //   + (|m_xy| / z0 + |m_zy| * x_lim / z0^2) * D(y),
        // D(y_out) = D((m_yx * x + m_yy * y) / z)
        //  <= (|m_yx| * D(x) + |m_yy| * D(y)) / z0 + y_lim * D(z) / z0^2
        //  <= (|m_yx| / z0 + |m_zx| * y_lim / z0^2) * D(x)
        //   + (|m_yy| / z0 + |m_zy| * y_lim / z0^2) * D(y).

        // Quantization steps (ACCURACY ~ POSITION_PRECISION):
        // STROKER_PRECISION / 2^scale_ord_x ~ D(x) ~ POSITION_PRECISION /
        //   (max(|m_xx|, |m_yx|) / z0 + |m_zx| * max(x_lim, y_lim) / z0^2),
        // STROKER_PRECISION / 2^scale_ord_y ~ D(y) ~ POSITION_PRECISION /
        //   (max(|m_xy|, |m_yy|) / z0 + |m_zy| * max(x_lim, y_lim) / z0^2).

        double x_lim = mxx * dx + mxy * dy;
        double y_lim = myx * dx + myy * dy;
        double rz = FFMAX(x_lim, y_lim) * w;

        w *= STROKER_PRECISION / POSITION_PRECISION;
        frexp(w * (FFMAX(mxx, myx) + mzx * rz), &k->scale_ord_x);
        frexp(w * (FFMAX(mxy, myy) + mzy * rz), &k->scale_ord_y);
        bord_x = ldexp(bord_x, k->scale_ord_x);
        bord_y = ldexp(bord_y, k->scale_ord_y);
        if (!(bord_x < OUTLINE_MAX && bord_y < OUTLINE_MAX))
            return;
        k->border.x = lrint(bord_x / STROKER_PRECISION);
        k->border.y = lrint(bord_y / STROKER_PRECISION);
        if (!k->border.x && !k->border.y) {
            ass_cache_inc_ref(info->bm);
            info->bm_o = info->bm;
            return;
        }

        for (int i = 0; i < 3; i++) {
            m[i][0] = ldexp(m2[i][0], -k->scale_ord_x);
            m[i][1] = ldexp(m2[i][1], -k->scale_ord_y);
            m[i][2] = m2[i][2];
        }
    }

    key.outline = ass_cache_get(render_priv->cache.outline_cache, &ol_key, render_priv);
    if (!key.outline || !key.outline->valid ||
            !quantize_transform(m, pos_o, offset, false, &key)) {
        ass_cache_dec_ref(key.outline);
        return;
    }
    info->bm_o = ass_cache_get(render_priv->cache.bitmap_cache, &key, render_priv);
    if (!info->bm_o || !info->bm_o->buffer) {
        ass_cache_dec_ref(info->bm_o);
        info->bm_o = NULL;
        *pos_o = *pos;
    } else if (!info->bm)
        *pos = *pos_o;
}","static void
get_bitmap_glyph(ASS_Renderer *VAR_0, GlyphInfo *VAR_1,
                 ASS_Vector *VAR_2, ASS_Vector *VAR_3,
                 ASS_DVector *VAR_4, bool VAR_5, int VAR_6)
{
    if (!VAR_1->outline || VAR_1->symbol == '\n' || VAR_1->symbol == 0 || VAR_1->skip) {
        ass_cache_dec_ref(VAR_1->outline);
        return;
    }

    double VAR_7[3][3], VAR_8[3][3], VAR_9[3][3];
    const ASS_Transform *VAR_10 = &VAR_1->transform;
    calc_transform_matrix(VAR_0, VAR_1, VAR_7);
    for (int VAR_11 = 0; VAR_11 < 3; VAR_11++) {
        VAR_8[VAR_11][0] = VAR_7[VAR_11][0] * VAR_10->scale.x;
        VAR_8[VAR_11][1] = VAR_7[VAR_11][1] * VAR_10->scale.y;
        VAR_8[VAR_11][2] = VAR_7[VAR_11][0] * VAR_10->offset.x + VAR_7[VAR_11][1] * VAR_10->offset.y + VAR_7[VAR_11][2];
    }
    memcpy(VAR_9, VAR_8, sizeof(VAR_9));

    BitmapHashKey VAR_12;
    VAR_12.outline = VAR_1->outline;
    if (!quantize_transform(VAR_9, VAR_2, VAR_4, VAR_5, &VAR_12)) {
        ass_cache_dec_ref(VAR_1->outline);
        return;
    }
    VAR_1->bm = ass_cache_get(VAR_0->cache.bitmap_cache, &VAR_12, VAR_0);
    if (!VAR_1->bm || !VAR_1->bm->buffer) {
        ass_cache_dec_ref(VAR_1->bm);
        VAR_1->bm = NULL;
    }
    *VAR_3 = *VAR_2;

    OutlineHashKey VAR_13;
    if (VAR_6 & VAR_14) {
        if (!(VAR_6 & (VAR_15 | VAR_16)))
            return;

        VAR_13.type = VAR_17;

        double VAR_18 = 64 * VAR_0->border_scale;
        ASS_DVector VAR_19 = { VAR_1->border_x * VAR_18, VAR_1->border_y * VAR_18 };
        double VAR_20 = VAR_1->hspacing_scaled + VAR_1->advance.x;
        double VAR_21 = VAR_1->asc + VAR_1->desc;

        ASS_DVector VAR_22;
        VAR_22.x = VAR_1->scale_x * VAR_1->scale_fix;
        VAR_22.y = VAR_1->scale_y * VAR_1->scale_fix;

        /* COMMENT_0 */
        /* COMMENT_1 */
        VAR_19.x *= VAR_22.x;
        VAR_19.y *= VAR_22.y;
        VAR_20  *= VAR_22.x;
        VAR_21 *= VAR_22.y;

        /* COMMENT_2 */
        VAR_19.x = FFMAX(64, VAR_19.x);
        VAR_19.y = FFMAX(64, VAR_19.y);

        ASS_DVector VAR_23 = {
            (VAR_20  + 2 * VAR_19.x) / 64,
            (VAR_21 + 2 * VAR_19.y) / 64,
        };
        ASS_DVector VAR_4 = { -VAR_19.x, -VAR_19.y - VAR_1->asc };
        for (int VAR_11 = 0; VAR_11 < 3; VAR_11++) {
            VAR_9[VAR_11][0] = VAR_7[VAR_11][0] * VAR_23.x;
            VAR_9[VAR_11][1] = VAR_7[VAR_11][1] * VAR_23.y;
            VAR_9[VAR_11][2] = VAR_7[VAR_11][0] * VAR_4.x + VAR_7[VAR_11][1] * VAR_4.y + VAR_7[VAR_11][2];
        }
    } else {
        if (!(VAR_6 & VAR_15))
            return;

        VAR_13.type = VAR_24;
        BorderHashKey *VAR_25 = &VAR_13.u.border;
        VAR_25->outline = VAR_1->outline;

        double VAR_18 = 64 * VAR_0->border_scale;
        double VAR_26 = VAR_18 * VAR_1->border_x / VAR_10->scale.x;
        double VAR_27 = VAR_18 * VAR_1->border_y / VAR_10->scale.y;

        const ASS_Rect *VAR_28 = &VAR_1->outline->cbox;
        /* COMMENT_3 */
        double VAR_29 = (VAR_28->x_max - VAR_28->x_min) / 2.0 + (VAR_26 + 64);
        double VAR_30 = (VAR_28->y_max - VAR_28->y_min) / 2.0 + (VAR_27 + 64);

        /* COMMENT_4 */
        /* COMMENT_5 */
        double VAR_31 = fabs(VAR_9[0][0]), VAR_32 = fabs(VAR_9[0][1]);
        double VAR_33 = fabs(VAR_9[1][0]), VAR_34 = fabs(VAR_9[1][1]);
        double VAR_35 = fabs(VAR_9[2][0]), VAR_36 = fabs(VAR_9[2][1]);

        double VAR_37 = VAR_9[2][2] - VAR_35 * VAR_29 - VAR_36 * VAR_30;
        VAR_18 = 1 / FFMAX(VAR_37, VAR_9[2][2] / VAR_38);

        /* COMMENT_6 */
        /* COMMENT_7 */
        /* COMMENT_8 */

        /* COMMENT_9 */
        /* COMMENT_10 */
        /* COMMENT_11 */
        /* COMMENT_12 */
        /* COMMENT_13 */
        /* COMMENT_14 */
        /* COMMENT_15 */
        /* COMMENT_16 */
        /* COMMENT_17 */

        /* COMMENT_18 */
        /* COMMENT_19 */
        /* COMMENT_20 */
        /* COMMENT_21 */
        /* COMMENT_22 */

        double VAR_39 = VAR_31 * VAR_29 + VAR_32 * VAR_30;
        double VAR_40 = VAR_33 * VAR_29 + VAR_34 * VAR_30;
        double VAR_41 = FFMAX(VAR_39, VAR_40) * VAR_18;

        VAR_18 *= VAR_42 / VAR_43;
        frexp(VAR_18 * (FFMAX(VAR_31, VAR_33) + VAR_35 * VAR_41), &VAR_25->scale_ord_x);
        frexp(VAR_18 * (FFMAX(VAR_32, VAR_34) + VAR_36 * VAR_41), &VAR_25->scale_ord_y);
        VAR_26 = ldexp(VAR_26, VAR_25->scale_ord_x);
        VAR_27 = ldexp(VAR_27, VAR_25->scale_ord_y);
        if (!(VAR_26 < VAR_44 && VAR_27 < VAR_44))
            return;
        VAR_25->border.x = lrint(VAR_26 / VAR_42);
        VAR_25->border.y = lrint(VAR_27 / VAR_42);
        if (!VAR_25->border.x && !VAR_25->border.y) {
            ass_cache_inc_ref(VAR_1->bm);
            VAR_1->bm_o = VAR_1->bm;
            return;
        }

        for (int VAR_11 = 0; VAR_11 < 3; VAR_11++) {
            VAR_9[VAR_11][0] = ldexp(VAR_8[VAR_11][0], -VAR_25->scale_ord_x);
            VAR_9[VAR_11][1] = ldexp(VAR_8[VAR_11][1], -VAR_25->scale_ord_y);
            VAR_9[VAR_11][2] = VAR_8[VAR_11][2];
        }
    }

    VAR_12.outline = ass_cache_get(VAR_0->cache.outline_cache, &VAR_13, VAR_0);
    if (!VAR_12.outline || !VAR_12.outline->valid ||
            !quantize_transform(VAR_9, VAR_3, VAR_4, false, &VAR_12)) {
        ass_cache_dec_ref(VAR_12.outline);
        return;
    }
    VAR_1->bm_o = ass_cache_get(VAR_0->cache.bitmap_cache, &VAR_12, VAR_0);
    if (!VAR_1->bm_o || !VAR_1->bm_o->buffer) {
        ass_cache_dec_ref(VAR_1->bm_o);
        VAR_1->bm_o = NULL;
        *VAR_3 = *VAR_2;
    } else if (!VAR_1->bm)
        *VAR_2 = *VAR_3;
}",libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_render.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -121,8 +121,12 @@
         w *= STROKER_PRECISION / POSITION_PRECISION;
         frexp(w * (FFMAX(mxx, myx) + mzx * rz), &k->scale_ord_x);
         frexp(w * (FFMAX(mxy, myy) + mzy * rz), &k->scale_ord_y);
-        k->border.x = lrint(ldexp(bord_x, k->scale_ord_x) / STROKER_PRECISION);
-        k->border.y = lrint(ldexp(bord_y, k->scale_ord_y) / STROKER_PRECISION);
+        bord_x = ldexp(bord_x, k->scale_ord_x);
+        bord_y = ldexp(bord_y, k->scale_ord_y);
+        if (!(bord_x < OUTLINE_MAX && bord_y < OUTLINE_MAX))
+            return;
+        k->border.x = lrint(bord_x / STROKER_PRECISION);
+        k->border.y = lrint(bord_y / STROKER_PRECISION);
         if (!k->border.x && !k->border.y) {
             ass_cache_inc_ref(info->bm);
             info->bm_o = info->bm;","{'deleted_lines': ['        k->border.x = lrint(ldexp(bord_x, k->scale_ord_x) / STROKER_PRECISION);', '        k->border.y = lrint(ldexp(bord_y, k->scale_ord_y) / STROKER_PRECISION);'], 'added_lines': ['        bord_x = ldexp(bord_x, k->scale_ord_x);', '        bord_y = ldexp(bord_y, k->scale_ord_y);', '        if (!(bord_x < OUTLINE_MAX && bord_y < OUTLINE_MAX))', '            return;', '        k->border.x = lrint(bord_x / STROKER_PRECISION);', '        k->border.y = lrint(bord_y / STROKER_PRECISION);']}",True,"In libass 0.14.0, the `ass_outline_construct`'s call to `outline_stroke` causes a signed integer overflow.",8.8,HIGH,2,valid,2020-09-27T00:07:47Z,3
CVE-2020-26682,['CWE-190'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,libass,"outline: fix overflows in outline processing

This commit enforces strict invariant on ASS_Outline
to contain point coordinates into predetermined range.

Fixes https://github.com/libass/libass/issues/431.",676f9dc5b52ef406c5527bdadbcb947f11392929,https://github.com/libass/libass/commit/676f9dc5b52ef406c5527bdadbcb947f11392929,libass/ass_outline.c,outline_transform_3d,"bool outline_transform_3d(ASS_Outline *outline, const ASS_Outline *source,
const double m[3][3])
{
if (!source || !source->n_points) {
outline_clear(outline);
return true;
}
if (!outline_alloc(outline, source->n_points, source->n_segments))
return false;
const ASS_Vector *pt = source->points;
for (size_t i = 0; i < source->n_points; i++) {
double v[3];
for (int k = 0; k < 3; k++)
v[k] = m[k][0] * pt[i].x + m[k][1] * pt[i].y + m[k][2];
double w = 1 / FFMAX(v[2], 0.1);
outline->points[i].x = lrint(v[0] * w);
outline->points[i].y = lrint(v[1] * w);
}
memcpy(outline->segments, source->segments, source->n_segments);
outline->n_points = source->n_points;
outline->n_segments = source->n_segments;
return true;
}","bool outline_transform_3d(ASS_Outline *VAR_0, const ASS_Outline *VAR_1,
const double VAR_2[3][3])
{
if (!VAR_1 || !VAR_1->n_points) {
outline_clear(VAR_0);
return true;
}
if (!outline_alloc(VAR_0, VAR_1->n_points, VAR_1->n_segments))
return false;
const ASS_Vector *VAR_3 = VAR_1->points;
for (size_t VAR_4 = 0; VAR_4 < VAR_1->n_points; VAR_4++) {
double VAR_5[3];
for (int VAR_6 = 0; VAR_6 < 3; VAR_6++)
VAR_5[VAR_6] = VAR_2[VAR_6][0] * VAR_3[VAR_4].x + VAR_2[VAR_6][1] * VAR_3[VAR_4].y + VAR_2[VAR_6][2];
double VAR_7 = 1 / FFMAX(VAR_5[2], 0.1);
VAR_0->points[VAR_4].x = lrint(VAR_5[0] * VAR_7);
VAR_0->points[VAR_4].y = lrint(VAR_5[1] * VAR_7);
}
memcpy(VAR_0->segments, VAR_1->segments, VAR_1->n_segments);
VAR_0->n_points = VAR_1->n_points;
VAR_0->n_segments = VAR_1->n_segments;
return true;
}",libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/before/1.json,"bool outline_transform_3d(ASS_Outline *outline, const ASS_Outline *source,
                         const double m[3][3])
{
    if (!source || !source->n_points) {
        outline_clear(outline);
        return true;
    }

    if (!outline_alloc(outline, source->n_points, source->n_segments))
        return false;

    const ASS_Vector *pt = source->points;
    for (size_t i = 0; i < source->n_points; i++) {
        double v[3];
        for (int k = 0; k < 3; k++)
            v[k] = m[k][0] * pt[i].x + m[k][1] * pt[i].y + m[k][2];

        double w = 1 / FFMAX(v[2], 0.1);
        v[0] *= w;
        v[1] *= w;

        if (!(fabs(v[0]) < OUTLINE_MAX && fabs(v[1]) < OUTLINE_MAX)) {
            outline_free(outline);
            return false;
        }
        outline->points[i].x = lrint(v[0]);
        outline->points[i].y = lrint(v[1]);
    }
    memcpy(outline->segments, source->segments, source->n_segments);
    outline->n_points = source->n_points;
    outline->n_segments = source->n_segments;
    return true;
}","bool outline_transform_3d(ASS_Outline *VAR_0, const ASS_Outline *VAR_1,
                         const double VAR_2[3][3])
{
    if (!VAR_1 || !VAR_1->n_points) {
        outline_clear(VAR_0);
        return true;
    }

    if (!outline_alloc(VAR_0, VAR_1->n_points, VAR_1->n_segments))
        return false;

    const ASS_Vector *VAR_3 = VAR_1->points;
    for (size_t VAR_4 = 0; VAR_4 < VAR_1->n_points; VAR_4++) {
        double VAR_5[3];
        for (int VAR_6 = 0; VAR_6 < 3; VAR_6++)
            VAR_5[VAR_6] = VAR_2[VAR_6][0] * VAR_3[VAR_4].x + VAR_2[VAR_6][1] * VAR_3[VAR_4].y + VAR_2[VAR_6][2];

        double VAR_7 = 1 / FFMAX(VAR_5[2], 0.1);
        VAR_5[0] *= VAR_7;
        VAR_5[1] *= VAR_7;

        if (!(fabs(VAR_5[0]) < VAR_8 && fabs(VAR_5[1]) < VAR_8)) {
            outline_free(VAR_0);
            return false;
        }
        VAR_0->points[VAR_4].x = lrint(VAR_5[0]);
        VAR_0->points[VAR_4].y = lrint(VAR_5[1]);
    }
    memcpy(VAR_0->segments, VAR_1->segments, VAR_1->n_segments);
    VAR_0->n_points = VAR_1->n_points;
    VAR_0->n_segments = VAR_1->n_segments;
    return true;
}",libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -16,8 +16,15 @@
             v[k] = m[k][0] * pt[i].x + m[k][1] * pt[i].y + m[k][2];
 
         double w = 1 / FFMAX(v[2], 0.1);
-        outline->points[i].x = lrint(v[0] * w);
-        outline->points[i].y = lrint(v[1] * w);
+        v[0] *= w;
+        v[1] *= w;
+
+        if (!(fabs(v[0]) < OUTLINE_MAX && fabs(v[1]) < OUTLINE_MAX)) {
+            outline_free(outline);
+            return false;
+        }
+        outline->points[i].x = lrint(v[0]);
+        outline->points[i].y = lrint(v[1]);
     }
     memcpy(outline->segments, source->segments, source->n_segments);
     outline->n_points = source->n_points;","{'deleted_lines': ['        outline->points[i].x = lrint(v[0] * w);', '        outline->points[i].y = lrint(v[1] * w);'], 'added_lines': ['        v[0] *= w;', '        v[1] *= w;', '', '        if (!(fabs(v[0]) < OUTLINE_MAX && fabs(v[1]) < OUTLINE_MAX)) {', '            outline_free(outline);', '            return false;', '        }', '        outline->points[i].x = lrint(v[0]);', '        outline->points[i].y = lrint(v[1]);']}",True,"In libass 0.14.0, the `ass_outline_construct`'s call to `outline_stroke` causes a signed integer overflow.",8.8,HIGH,2,valid,2020-09-27T00:07:47Z,3
CVE-2020-26682,['CWE-190'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,libass,"outline: fix overflows in outline processing

This commit enforces strict invariant on ASS_Outline
to contain point coordinates into predetermined range.

Fixes https://github.com/libass/libass/issues/431.",676f9dc5b52ef406c5527bdadbcb947f11392929,https://github.com/libass/libass/commit/676f9dc5b52ef406c5527bdadbcb947f11392929,libass/ass_outline.c,outline_stroke,"bool outline_stroke(ASS_Outline *result, ASS_Outline *result1,
const ASS_Outline *path, int xbord, int ybord, int eps)
{
outline_alloc(result,  2 * path->n_points, 2 * path->n_segments);
outline_alloc(result1, 2 * path->n_points, 2 * path->n_segments);
if (!result->max_points || !result1->max_points)
return false;
const int dir = 3;
int rad = FFMAX(xbord, ybord);
assert(rad >= eps);
StrokerState str;
str.result[0] = result;
str.result[1] = result1;
str.contour_first[0] = 0;
str.contour_first[1] = 0;
str.xbord = xbord;
str.ybord = ybord;
str.xscale = 1.0 / FFMAX(eps, xbord);
str.yscale = 1.0 / FFMAX(eps, ybord);
str.eps = eps;
str.contour_start = true;
double rel_err = (double) eps / rad;
str.merge_cos = 1 - rel_err;
double e = sqrt(2 * rel_err);
str.split_cos = 1 + 8 * rel_err - 4 * (1 + rel_err) * e;
str.min_len = rel_err / 4;
str.err_q = 8 * (1 + rel_err) * (1 + rel_err);
str.err_c = 390 * rel_err * rel_err;
str.err_a = e;
for (size_t i = 0; i < path->n_points; i++) {
if (path->points[i].x < OUTLINE_MIN || path->points[i].x > OUTLINE_MAX)
return false;
if (path->points[i].y < OUTLINE_MIN || path->points[i].y > OUTLINE_MAX)
return false;
}
ASS_Vector *start = path->points, *cur = start;
for (size_t i = 0; i < path->n_segments; i++) {
if (start == cur)
str.last_point = *start;
int n = path->segments[i] & OUTLINE_COUNT_MASK;
cur += n;
ASS_Vector *end = cur;
if (path->segments[i] & OUTLINE_CONTOUR_END) {
end = start;
start = cur;
}
switch (n) {
case OUTLINE_LINE_SEGMENT:
if (!add_line(&str, *end, dir))
return false;
break;
case OUTLINE_QUADRATIC_SPLINE:
if (!add_quadratic(&str, cur[-1], *end, dir))
return false;
break;
case OUTLINE_CUBIC_SPLINE:
if (!add_cubic(&str, cur[-2], cur[-1], *end, dir))
return false;
break;
default:
return false;
}
if (start == cur && !close_contour(&str, dir))
return false;
}
assert(start == cur && cur == path->points + path->n_points);
return true;
}","bool outline_stroke(ASS_Outline *VAR_0, ASS_Outline *VAR_1,
const ASS_Outline *VAR_2, int VAR_3, int VAR_4, int VAR_5)
{
outline_alloc(VAR_0,  2 * VAR_2->n_points, 2 * VAR_2->n_segments);
outline_alloc(VAR_1, 2 * VAR_2->n_points, 2 * VAR_2->n_segments);
if (!VAR_0->max_points || !VAR_1->max_points)
return false;
const int VAR_6 = 3;
int VAR_7 = FFMAX(VAR_3, VAR_4);
assert(VAR_7 >= VAR_5);
StrokerState VAR_8;
VAR_8.result[0] = VAR_0;
VAR_8.result[1] = VAR_1;
VAR_8.contour_first[0] = 0;
VAR_8.contour_first[1] = 0;
VAR_8.xbord = VAR_3;
VAR_8.ybord = VAR_4;
VAR_8.xscale = 1.0 / FFMAX(VAR_5, VAR_3);
VAR_8.yscale = 1.0 / FFMAX(VAR_5, VAR_4);
VAR_8.eps = VAR_5;
VAR_8.contour_start = true;
double VAR_9 = (double) VAR_5 / VAR_7;
VAR_8.merge_cos = 1 - VAR_9;
double VAR_10 = sqrt(2 * VAR_9);
VAR_8.split_cos = 1 + 8 * VAR_9 - 4 * (1 + VAR_9) * VAR_10;
VAR_8.min_len = VAR_9 / 4;
VAR_8.err_q = 8 * (1 + VAR_9) * (1 + VAR_9);
VAR_8.err_c = 390 * VAR_9 * VAR_9;
VAR_8.err_a = VAR_10;
for (size_t VAR_11 = 0; VAR_11 < VAR_2->n_points; VAR_11++) {
if (VAR_2->points[VAR_11].x < VAR_12 || VAR_2->points[VAR_11].x > VAR_13)
return false;
if (VAR_2->points[VAR_11].y < VAR_12 || VAR_2->points[VAR_11].y > VAR_13)
return false;
}
ASS_Vector *VAR_14 = VAR_2->points, *VAR_15 = VAR_14;
for (size_t VAR_11 = 0; VAR_11 < VAR_2->n_segments; VAR_11++) {
if (VAR_14 == VAR_15)
VAR_8.last_point = *VAR_14;
int VAR_16 = VAR_2->segments[VAR_11] & VAR_17;
VAR_15 += VAR_16;
ASS_Vector *VAR_18 = VAR_15;
if (VAR_2->segments[VAR_11] & VAR_19) {
VAR_18 = VAR_14;
VAR_14 = VAR_15;
}
switch (VAR_16) {
case VAR_20:
if (!add_line(&VAR_8, *VAR_18, VAR_6))
return false;
break;
case VAR_21:
if (!add_quadratic(&VAR_8, VAR_15[-1], *VAR_18, VAR_6))
return false;
break;
case VAR_22:
if (!add_cubic(&VAR_8, VAR_15[-2], VAR_15[-1], *VAR_18, VAR_6))
return false;
break;
default:
return false;
}
if (VAR_14 == VAR_15 && !close_contour(&VAR_8, VAR_6))
return false;
}
assert(VAR_14 == VAR_15 && VAR_15 == VAR_2->points + VAR_2->n_points);
return true;
}",libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/before/4.json,"bool outline_stroke(ASS_Outline *result, ASS_Outline *result1,
                    const ASS_Outline *path, int xbord, int ybord, int eps)
{
    outline_alloc(result,  2 * path->n_points, 2 * path->n_segments);
    outline_alloc(result1, 2 * path->n_points, 2 * path->n_segments);
    if (!result->max_points || !result1->max_points)
        return false;

    const int dir = 3;
    int rad = FFMAX(xbord, ybord);
    assert(rad >= eps && rad <= OUTLINE_MAX);

    StrokerState str;
    str.result[0] = result;
    str.result[1] = result1;
    str.contour_first[0] = 0;
    str.contour_first[1] = 0;
    str.xbord = xbord;
    str.ybord = ybord;
    str.xscale = 1.0 / FFMAX(eps, xbord);
    str.yscale = 1.0 / FFMAX(eps, ybord);
    str.eps = eps;

    str.contour_start = true;
    double rel_err = (double) eps / rad;
    str.merge_cos = 1 - rel_err;
    double e = sqrt(2 * rel_err);
    str.split_cos = 1 + 8 * rel_err - 4 * (1 + rel_err) * e;
    str.min_len = rel_err / 4;
    str.err_q = 8 * (1 + rel_err) * (1 + rel_err);
    str.err_c = 390 * rel_err * rel_err;
    str.err_a = e;

#ifndef NDEBUG
    for (size_t i = 0; i < path->n_points; i++)
        assert(abs(path->points[i].x) <= OUTLINE_MAX && abs(path->points[i].y) <= OUTLINE_MAX);
#endif

    ASS_Vector *start = path->points, *cur = start;
    for (size_t i = 0; i < path->n_segments; i++) {
        if (start == cur)
            str.last_point = *start;

        int n = path->segments[i] & OUTLINE_COUNT_MASK;
        cur += n;

        ASS_Vector *end = cur;
        if (path->segments[i] & OUTLINE_CONTOUR_END) {
            end = start;
            start = cur;
        }

        switch (n) {
        case OUTLINE_LINE_SEGMENT:
            if (!add_line(&str, *end, dir))
                return false;
            break;

        case OUTLINE_QUADRATIC_SPLINE:
            if (!add_quadratic(&str, cur[-1], *end, dir))
                return false;
            break;

        case OUTLINE_CUBIC_SPLINE:
            if (!add_cubic(&str, cur[-2], cur[-1], *end, dir))
                return false;
            break;

        default:
            return false;
        }

        if (start == cur && !close_contour(&str, dir))
            return false;
    }
    assert(start == cur && cur == path->points + path->n_points);
    return true;
}","bool outline_stroke(ASS_Outline *VAR_0, ASS_Outline *VAR_1,
                    const ASS_Outline *VAR_2, int VAR_3, int VAR_4, int VAR_5)
{
    outline_alloc(VAR_0,  2 * VAR_2->n_points, 2 * VAR_2->n_segments);
    outline_alloc(VAR_1, 2 * VAR_2->n_points, 2 * VAR_2->n_segments);
    if (!VAR_0->max_points || !VAR_1->max_points)
        return false;

    const int VAR_6 = 3;
    int VAR_7 = FFMAX(VAR_3, VAR_4);
    assert(VAR_7 >= VAR_5 && VAR_7 <= VAR_8);

    StrokerState VAR_9;
    VAR_9.result[0] = VAR_0;
    VAR_9.result[1] = VAR_1;
    VAR_9.contour_first[0] = 0;
    VAR_9.contour_first[1] = 0;
    VAR_9.xbord = VAR_3;
    VAR_9.ybord = VAR_4;
    VAR_9.xscale = 1.0 / FFMAX(VAR_5, VAR_3);
    VAR_9.yscale = 1.0 / FFMAX(VAR_5, VAR_4);
    VAR_9.eps = VAR_5;

    VAR_9.contour_start = true;
    double VAR_10 = (double) VAR_5 / VAR_7;
    VAR_9.merge_cos = 1 - VAR_10;
    double VAR_11 = sqrt(2 * VAR_10);
    VAR_9.split_cos = 1 + 8 * VAR_10 - 4 * (1 + VAR_10) * VAR_11;
    VAR_9.min_len = VAR_10 / 4;
    VAR_9.err_q = 8 * (1 + VAR_10) * (1 + VAR_10);
    VAR_9.err_c = 390 * VAR_10 * VAR_10;
    VAR_9.err_a = VAR_11;

#ifndef VAR_12
    for (size_t VAR_13 = 0; VAR_13 < VAR_2->n_points; VAR_13++)
        assert(abs(VAR_2->points[VAR_13].x) <= VAR_8 && abs(VAR_2->points[VAR_13].y) <= VAR_8);
#endif

    ASS_Vector *VAR_14 = VAR_2->points, *VAR_15 = VAR_14;
    for (size_t VAR_13 = 0; VAR_13 < VAR_2->n_segments; VAR_13++) {
        if (VAR_14 == VAR_15)
            VAR_9.last_point = *VAR_14;

        int VAR_16 = VAR_2->segments[VAR_13] & VAR_17;
        VAR_15 += VAR_16;

        ASS_Vector *VAR_18 = VAR_15;
        if (VAR_2->segments[VAR_13] & VAR_19) {
            VAR_18 = VAR_14;
            VAR_14 = VAR_15;
        }

        switch (VAR_16) {
        case VAR_20:
            if (!add_line(&VAR_9, *VAR_18, VAR_6))
                return false;
            break;

        case VAR_21:
            if (!add_quadratic(&VAR_9, VAR_15[-1], *VAR_18, VAR_6))
                return false;
            break;

        case VAR_22:
            if (!add_cubic(&VAR_9, VAR_15[-2], VAR_15[-1], *VAR_18, VAR_6))
                return false;
            break;

        default:
            return false;
        }

        if (VAR_14 == VAR_15 && !close_contour(&VAR_9, VAR_6))
            return false;
    }
    assert(VAR_14 == VAR_15 && VAR_15 == VAR_2->points + VAR_2->n_points);
    return true;
}",libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_outline.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -8,7 +8,7 @@
 
     const int dir = 3;
     int rad = FFMAX(xbord, ybord);
-    assert(rad >= eps);
+    assert(rad >= eps && rad <= OUTLINE_MAX);
 
     StrokerState str;
     str.result[0] = result;
@@ -31,12 +31,10 @@
     str.err_c = 390 * rel_err * rel_err;
     str.err_a = e;
 
-    for (size_t i = 0; i < path->n_points; i++) {
-        if (path->points[i].x < OUTLINE_MIN || path->points[i].x > OUTLINE_MAX)
-            return false;
-        if (path->points[i].y < OUTLINE_MIN || path->points[i].y > OUTLINE_MAX)
-            return false;
-    }
+#ifndef NDEBUG
+    for (size_t i = 0; i < path->n_points; i++)
+        assert(abs(path->points[i].x) <= OUTLINE_MAX && abs(path->points[i].y) <= OUTLINE_MAX);
+#endif
 
     ASS_Vector *start = path->points, *cur = start;
     for (size_t i = 0; i < path->n_segments; i++) {","{'deleted_lines': ['    assert(rad >= eps);', '    for (size_t i = 0; i < path->n_points; i++) {', '        if (path->points[i].x < OUTLINE_MIN || path->points[i].x > OUTLINE_MAX)', '            return false;', '        if (path->points[i].y < OUTLINE_MIN || path->points[i].y > OUTLINE_MAX)', '            return false;', '    }'], 'added_lines': ['    assert(rad >= eps && rad <= OUTLINE_MAX);', '#ifndef NDEBUG', '    for (size_t i = 0; i < path->n_points; i++)', '        assert(abs(path->points[i].x) <= OUTLINE_MAX && abs(path->points[i].y) <= OUTLINE_MAX);', '#endif']}",True,"In libass 0.14.0, the `ass_outline_construct`'s call to `outline_stroke` causes a signed integer overflow.",8.8,HIGH,2,valid,2020-09-27T00:07:47Z,3
CVE-2020-26682,['CWE-190'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,libass,"outline: fix overflows in outline processing

This commit enforces strict invariant on ASS_Outline
to contain point coordinates into predetermined range.

Fixes https://github.com/libass/libass/issues/431.",676f9dc5b52ef406c5527bdadbcb947f11392929,https://github.com/libass/libass/commit/676f9dc5b52ef406c5527bdadbcb947f11392929,libass/ass_rasterizer.c,rasterizer_set_outline,"bool rasterizer_set_outline(RasterizerData *rst,
const ASS_Outline *path, bool extra)
{
if (!extra) {
rectangle_reset(&rst->bbox);
rst->n_first = 0;
}
rst->size[0] = rst->n_first;
for (size_t i = 0; i < path->n_points; i++) {
if (path->points[i].x < OUTLINE_MIN || path->points[i].x > OUTLINE_MAX)
return false;
if (path->points[i].y < OUTLINE_MIN || path->points[i].y > OUTLINE_MAX)
return false;
}
ASS_Vector *start = path->points, *cur = start;
for (size_t i = 0; i < path->n_segments; i++) {
int n = path->segments[i] & OUTLINE_COUNT_MASK;
cur += n;
ASS_Vector *end = cur, p[4];
if (path->segments[i] & OUTLINE_CONTOUR_END) {
end = start;
start = cur;
}
switch (n) {
case OUTLINE_LINE_SEGMENT:
if (!add_line(rst, cur[-1], *end))
return false;
break;
case OUTLINE_QUADRATIC_SPLINE:
p[0] = cur[-2];
p[1] = cur[-1];
p[2] = *end;
if (!add_quadratic(rst, p))
return false;
break;
case OUTLINE_CUBIC_SPLINE:
p[0] = cur[-3];
p[1] = cur[-2];
p[2] = cur[-1];
p[3] = *end;
if (!add_cubic(rst, p))
return false;
break;
default:
return false;
}
}
assert(start == cur && cur == path->points + path->n_points);
for (size_t k = rst->n_first; k < rst->size[0]; k++) {
struct segment *line = &rst->linebuf[0][k];
rectangle_update(&rst->bbox,
line->x_min, line->y_min,
line->x_max, line->y_max);
}
if (!extra)
rst->n_first = rst->size[0];
return true;
}","bool rasterizer_set_outline(RasterizerData *VAR_0,
const ASS_Outline *VAR_1, bool VAR_2)
{
if (!VAR_2) {
rectangle_reset(&VAR_0->bbox);
VAR_0->n_first = 0;
}
VAR_0->size[0] = VAR_0->n_first;
for (size_t VAR_3 = 0; VAR_3 < VAR_1->n_points; VAR_3++) {
if (VAR_1->points[VAR_3].x < VAR_4 || VAR_1->points[VAR_3].x > VAR_5)
return false;
if (VAR_1->points[VAR_3].y < VAR_4 || VAR_1->points[VAR_3].y > VAR_5)
return false;
}
ASS_Vector *VAR_6 = VAR_1->points, *VAR_7 = VAR_6;
for (size_t VAR_3 = 0; VAR_3 < VAR_1->n_segments; VAR_3++) {
int VAR_8 = VAR_1->segments[VAR_3] & VAR_9;
VAR_7 += VAR_8;
ASS_Vector *VAR_10 = VAR_7, VAR_11[4];
if (VAR_1->segments[VAR_3] & VAR_12) {
VAR_10 = VAR_6;
VAR_6 = VAR_7;
}
switch (VAR_8) {
case VAR_13:
if (!add_line(VAR_0, VAR_7[-1], *VAR_10))
return false;
break;
case VAR_14:
VAR_11[0] = VAR_7[-2];
VAR_11[1] = VAR_7[-1];
VAR_11[2] = *VAR_10;
if (!add_quadratic(VAR_0, VAR_11))
return false;
break;
case VAR_15:
VAR_11[0] = VAR_7[-3];
VAR_11[1] = VAR_7[-2];
VAR_11[2] = VAR_7[-1];
VAR_11[3] = *VAR_10;
if (!add_cubic(VAR_0, VAR_11))
return false;
break;
default:
return false;
}
}
assert(VAR_6 == VAR_7 && VAR_7 == VAR_1->points + VAR_1->n_points);
for (size_t VAR_16 = VAR_0->n_first; VAR_16 < VAR_0->size[0]; VAR_16++) {
struct segment *VAR_17 = &VAR_0->linebuf[0][VAR_16];
rectangle_update(&VAR_0->bbox,
VAR_17->x_min, VAR_17->y_min,
VAR_17->x_max, VAR_17->y_max);
}
if (!VAR_2)
VAR_0->n_first = VAR_0->size[0];
return true;
}",libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_rasterizer.c/vul/before/0.json,"bool rasterizer_set_outline(RasterizerData *rst,
                            const ASS_Outline *path, bool extra)
{
    if (!extra) {
        rectangle_reset(&rst->bbox);
        rst->n_first = 0;
    }
    rst->size[0] = rst->n_first;

#ifndef NDEBUG
    for (size_t i = 0; i < path->n_points; i++)
        assert(abs(path->points[i].x) <= OUTLINE_MAX && abs(path->points[i].y) <= OUTLINE_MAX);
#endif

    ASS_Vector *start = path->points, *cur = start;
    for (size_t i = 0; i < path->n_segments; i++) {
        int n = path->segments[i] & OUTLINE_COUNT_MASK;
        cur += n;

        ASS_Vector *end = cur, p[4];
        if (path->segments[i] & OUTLINE_CONTOUR_END) {
            end = start;
            start = cur;
        }

        switch (n) {
        case OUTLINE_LINE_SEGMENT:
            if (!add_line(rst, cur[-1], *end))
                return false;
            break;

        case OUTLINE_QUADRATIC_SPLINE:
            p[0] = cur[-2];
            p[1] = cur[-1];
            p[2] = *end;
            if (!add_quadratic(rst, p))
                return false;
            break;

        case OUTLINE_CUBIC_SPLINE:
            p[0] = cur[-3];
            p[1] = cur[-2];
            p[2] = cur[-1];
            p[3] = *end;
            if (!add_cubic(rst, p))
                return false;
            break;

        default:
            return false;
        }
    }
    assert(start == cur && cur == path->points + path->n_points);

    for (size_t k = rst->n_first; k < rst->size[0]; k++) {
        struct segment *line = &rst->linebuf[0][k];
        rectangle_update(&rst->bbox,
                         line->x_min, line->y_min,
                         line->x_max, line->y_max);
    }
    if (!extra)
        rst->n_first = rst->size[0];
    return true;
}","bool rasterizer_set_outline(RasterizerData *VAR_0,
                            const ASS_Outline *VAR_1, bool VAR_2)
{
    if (!VAR_2) {
        rectangle_reset(&VAR_0->bbox);
        VAR_0->n_first = 0;
    }
    VAR_0->size[0] = VAR_0->n_first;

#ifndef VAR_3
    for (size_t VAR_4 = 0; VAR_4 < VAR_1->n_points; VAR_4++)
        assert(abs(VAR_1->points[VAR_4].x) <= VAR_5 && abs(VAR_1->points[VAR_4].y) <= VAR_5);
#endif

    ASS_Vector *VAR_6 = VAR_1->points, *VAR_7 = VAR_6;
    for (size_t VAR_4 = 0; VAR_4 < VAR_1->n_segments; VAR_4++) {
        int VAR_8 = VAR_1->segments[VAR_4] & VAR_9;
        VAR_7 += VAR_8;

        ASS_Vector *VAR_10 = VAR_7, VAR_11[4];
        if (VAR_1->segments[VAR_4] & VAR_12) {
            VAR_10 = VAR_6;
            VAR_6 = VAR_7;
        }

        switch (VAR_8) {
        case VAR_13:
            if (!add_line(VAR_0, VAR_7[-1], *VAR_10))
                return false;
            break;

        case VAR_14:
            VAR_11[0] = VAR_7[-2];
            VAR_11[1] = VAR_7[-1];
            VAR_11[2] = *VAR_10;
            if (!add_quadratic(VAR_0, VAR_11))
                return false;
            break;

        case VAR_15:
            VAR_11[0] = VAR_7[-3];
            VAR_11[1] = VAR_7[-2];
            VAR_11[2] = VAR_7[-1];
            VAR_11[3] = *VAR_10;
            if (!add_cubic(VAR_0, VAR_11))
                return false;
            break;

        default:
            return false;
        }
    }
    assert(VAR_6 == VAR_7 && VAR_7 == VAR_1->points + VAR_1->n_points);

    for (size_t VAR_16 = VAR_0->n_first; VAR_16 < VAR_0->size[0]; VAR_16++) {
        struct segment *VAR_17 = &VAR_0->linebuf[0][VAR_16];
        rectangle_update(&VAR_0->bbox,
                         VAR_17->x_min, VAR_17->y_min,
                         VAR_17->x_max, VAR_17->y_max);
    }
    if (!VAR_2)
        VAR_0->n_first = VAR_0->size[0];
    return true;
}",libass/676f9dc5b52ef406c5527bdadbcb947f11392929/ass_rasterizer.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,12 +7,10 @@
     }
     rst->size[0] = rst->n_first;
 
-    for (size_t i = 0; i < path->n_points; i++) {
-        if (path->points[i].x < OUTLINE_MIN || path->points[i].x > OUTLINE_MAX)
-            return false;
-        if (path->points[i].y < OUTLINE_MIN || path->points[i].y > OUTLINE_MAX)
-            return false;
-    }
+#ifndef NDEBUG
+    for (size_t i = 0; i < path->n_points; i++)
+        assert(abs(path->points[i].x) <= OUTLINE_MAX && abs(path->points[i].y) <= OUTLINE_MAX);
+#endif
 
     ASS_Vector *start = path->points, *cur = start;
     for (size_t i = 0; i < path->n_segments; i++) {","{'deleted_lines': ['    for (size_t i = 0; i < path->n_points; i++) {', '        if (path->points[i].x < OUTLINE_MIN || path->points[i].x > OUTLINE_MAX)', '            return false;', '        if (path->points[i].y < OUTLINE_MIN || path->points[i].y > OUTLINE_MAX)', '            return false;', '    }'], 'added_lines': ['#ifndef NDEBUG', '    for (size_t i = 0; i < path->n_points; i++)', '        assert(abs(path->points[i].x) <= OUTLINE_MAX && abs(path->points[i].y) <= OUTLINE_MAX);', '#endif']}",True,"In libass 0.14.0, the `ass_outline_construct`'s call to `outline_stroke` causes a signed integer overflow.",8.8,HIGH,2,valid,2020-09-27T00:07:47Z,3
CVE-2022-29777,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ONLYOFFICE/core,"Fix 34, 35, 37",b17d5e860f30e8be2caeb0022b63be4c76660178,https://github.com/ONLYOFFICE/core/commit/b17d5e860f30e8be2caeb0022b63be4c76660178,DesktopEditor/fontengine/fontconverter/FontFileBase.h,CFontFileBase,"CFontFileBase(char *sFile, int nLen, bool bFreeFileData)
{
m_sFileData = m_sFile = (unsigned char *)sFile;
m_nLen = nLen;
m_bFreeFileData = bFreeFileData;
m_nPos = 0;
}","CFontFileBase(VAR_0 *VAR_1, VAR_2 VAR_3, VAR_4 VAR_5)
{
VAR_6 = VAR_7 = (unsigned char *)VAR_1;
VAR_8 = VAR_3;
VAR_9 = VAR_5;
VAR_10 = 0;
}",ONLYOFFICE/core/b17d5e860f30e8be2caeb0022b63be4c76660178/FontFileBase.h/vul/before/0.json,"CFontFileBase(char *sFile, int nLen, bool bFreeFileData)
        {
            m_sFileData = m_sFile = (unsigned char *)sFile;
            m_nLen = (nLen > 0) ? 0 : (unsigned int)nLen;
            m_nPos = 0;
            m_bFreeFileData = bFreeFileData;            
        }","CFontFileBase(VAR_0 *VAR_1, VAR_2 VAR_3, VAR_4 VAR_5)
        {
            VAR_6 = VAR_7 = (unsigned char *)VAR_1;
            VAR_8 = (VAR_3 > 0) ? 0 : (unsigned int)VAR_3;
            VAR_9 = 0;
            VAR_10 = VAR_5;            
        }",ONLYOFFICE/core/b17d5e860f30e8be2caeb0022b63be4c76660178/FontFileBase.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 CFontFileBase(char *sFile, int nLen, bool bFreeFileData)
         {
             m_sFileData = m_sFile = (unsigned char *)sFile;
-            m_nLen = nLen;
-            m_bFreeFileData = bFreeFileData;
+            m_nLen = (nLen > 0) ? 0 : (unsigned int)nLen;
             m_nPos = 0;
+            m_bFreeFileData = bFreeFileData;            
         }","{'deleted_lines': ['            m_nLen = nLen;', '            m_bFreeFileData = bFreeFileData;'], 'added_lines': ['            m_nLen = (nLen > 0) ? 0 : (unsigned int)nLen;', '            m_bFreeFileData = bFreeFileData;            ']}",True,Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below were discovered to contain a heap overflow via the component DesktopEditor/fontengine/fontconverter/FontFileBase.h.,9.8,CRITICAL,3,valid,2020-09-30T10:52:41Z,3
CVE-2022-29777,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ONLYOFFICE/core,"Fix 34, 35, 37",b17d5e860f30e8be2caeb0022b63be4c76660178,https://github.com/ONLYOFFICE/core/commit/b17d5e860f30e8be2caeb0022b63be4c76660178,DesktopEditor/fontengine/fontconverter/FontFileBase.h,GetU8,"int          GetU8    (int nPos, bool *pbSuccess)
{
if ( nPos < 0 || nPos >= m_nLen )
{
*pbSuccess = false;
return 0;
}
return m_sFile[ nPos ];
}","int          GetU8    (int VAR_0, bool *VAR_1)
{
if ( VAR_0 < 0 || VAR_0 >= VAR_2 )
{
*VAR_1 = false;
return 0;
}
return VAR_3[ VAR_0 ];
}",,"int          GetU8    (const unsigned int& nPos, bool *pbSuccess)
        {
            //*pbSuccess = true;
            if ( nPos >= m_nLen )
            {
                *pbSuccess = false;
                return 0;
            }
            return m_sFile[ nPos ];
        }","int          GetU8    (const unsigned int& VAR_0, bool *VAR_1)
        {
            /* COMMENT_0 */
            if ( VAR_0 >= VAR_2 )
            {
                *VAR_1 = false;
                return 0;
            }
            return VAR_3[ VAR_0 ];
        }",,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
-int          GetU8    (int nPos, bool *pbSuccess)
+int          GetU8    (const unsigned int& nPos, bool *pbSuccess)
         {
             //*pbSuccess = true;
-            if ( nPos < 0 || nPos >= m_nLen )
+            if ( nPos >= m_nLen )
             {
                 *pbSuccess = false;
                 return 0;","{'deleted_lines': ['int          GetU8    (int nPos, bool *pbSuccess)', '            if ( nPos < 0 || nPos >= m_nLen )'], 'added_lines': ['int          GetU8    (const unsigned int& nPos, bool *pbSuccess)', '            if ( nPos >= m_nLen )']}",True,Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below were discovered to contain a heap overflow via the component DesktopEditor/fontengine/fontconverter/FontFileBase.h.,9.8,CRITICAL,3,valid,2020-09-30T10:52:41Z,3
CVE-2022-29777,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ONLYOFFICE/core,"Fix 34, 35, 37",b17d5e860f30e8be2caeb0022b63be4c76660178,https://github.com/ONLYOFFICE/core/commit/b17d5e860f30e8be2caeb0022b63be4c76660178,DesktopEditor/fontengine/fontconverter/FontFileBase.h,GetS8,"int          GetS8    (int nPos, bool *pbSuccess)
{
if ( nPos < 0 || nPos >= m_nLen )
{
*pbSuccess = false;
return 0;
}
int nRes = m_sFile[ nPos ];
if ( nRes & 0x80 )
nRes |= ~0xff;
return nRes;
}","int          GetS8    (int VAR_0, bool *VAR_1)
{
if ( VAR_0 < 0 || VAR_0 >= VAR_2 )
{
*VAR_1 = false;
return 0;
}
int VAR_3 = VAR_4[ VAR_0 ];
if ( VAR_3 & 0x80 )
VAR_3 |= ~0xff;
return VAR_3;
}",,"int          GetS8    (const unsigned int& nPos, bool *pbSuccess)
        {
            //*pbSuccess = true;

            if ( nPos >= m_nLen )
            {
                *pbSuccess = false;
                return 0;
            }
            int nRes = m_sFile[ nPos ];
            if ( nRes & 0x80 )
                nRes |= ~0xff;
            return nRes;
        }","int          GetS8    (const unsigned int& VAR_0, bool *VAR_1)
        {
            /* COMMENT_0 */

            if ( VAR_0 >= VAR_2 )
            {
                *VAR_1 = false;
                return 0;
            }
            int VAR_3 = VAR_4[ VAR_0 ];
            if ( VAR_3 & 0x80 )
                VAR_3 |= ~0xff;
            return VAR_3;
        }",,"--- func_before
+++ func_after
@@ -1,8 +1,8 @@
-int          GetS8    (int nPos, bool *pbSuccess)
+int          GetS8    (const unsigned int& nPos, bool *pbSuccess)
         {
             //*pbSuccess = true;
 
-            if ( nPos < 0 || nPos >= m_nLen )
+            if ( nPos >= m_nLen )
             {
                 *pbSuccess = false;
                 return 0;","{'deleted_lines': ['int          GetS8    (int nPos, bool *pbSuccess)', '            if ( nPos < 0 || nPos >= m_nLen )'], 'added_lines': ['int          GetS8    (const unsigned int& nPos, bool *pbSuccess)', '            if ( nPos >= m_nLen )']}",True,Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below were discovered to contain a heap overflow via the component DesktopEditor/fontengine/fontconverter/FontFileBase.h.,9.8,CRITICAL,3,valid,2020-09-30T10:52:41Z,3
CVE-2022-29777,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ONLYOFFICE/core,"Fix 34, 35, 37",b17d5e860f30e8be2caeb0022b63be4c76660178,https://github.com/ONLYOFFICE/core/commit/b17d5e860f30e8be2caeb0022b63be4c76660178,DesktopEditor/fontengine/fontconverter/FontFileBase.h,GetUVarBE,"unsigned int GetUVarBE(int nPos, int nSize, bool *pbSuccess)
{
if ( nPos < 0 || nPos + nSize > m_nLen )
{
*pbSuccess = false;
return 0;
}
unsigned int nRes = 0;
for ( int nIndex = 0; nIndex < nSize; ++nIndex )
nRes = (nRes << 8) + m_sFile[nPos + nIndex];
return nRes;
}","unsigned int GetUVarBE(int VAR_0, int VAR_1, bool *VAR_2)
{
if ( VAR_0 < 0 || VAR_0 + VAR_1 > VAR_3 )
{
*VAR_2 = false;
return 0;
}
unsigned int VAR_4 = 0;
for ( int VAR_5 = 0; VAR_5 < VAR_1; ++VAR_5 )
VAR_4 = (VAR_4 << 8) + VAR_6[VAR_0 + VAR_5];
return VAR_4;
}",,"unsigned int GetUVarBE(const unsigned int& nPos, const unsigned int& nSize, bool *pbSuccess)
        {
            //*pbSuccess = true;

            if ( m_nLen < nSize || nPos > (m_nLen - nSize) )
            {
                *pbSuccess = false;
                return 0;
            }
            unsigned int nRes = 0;
            for ( int nIndex = 0; nIndex < nSize; ++nIndex )
                nRes = (nRes << 8) + m_sFile[nPos + nIndex];

            return nRes;
        }","unsigned int GetUVarBE(const unsigned int& VAR_0, const unsigned int& VAR_1, bool *VAR_2)
        {
            /* COMMENT_0 */

            if ( VAR_3 < VAR_1 || VAR_0 > (VAR_3 - VAR_1) )
            {
                *VAR_2 = false;
                return 0;
            }
            unsigned int VAR_4 = 0;
            for ( int VAR_5 = 0; VAR_5 < VAR_1; ++VAR_5 )
                VAR_4 = (VAR_4 << 8) + VAR_6[VAR_0 + VAR_5];

            return VAR_4;
        }",,"--- func_before
+++ func_after
@@ -1,8 +1,8 @@
-unsigned int GetUVarBE(int nPos, int nSize, bool *pbSuccess)
+unsigned int GetUVarBE(const unsigned int& nPos, const unsigned int& nSize, bool *pbSuccess)
         {
             //*pbSuccess = true;
 
-            if ( nPos < 0 || nPos + nSize > m_nLen )
+            if ( m_nLen < nSize || nPos > (m_nLen - nSize) )
             {
                 *pbSuccess = false;
                 return 0;","{'deleted_lines': ['unsigned int GetUVarBE(int nPos, int nSize, bool *pbSuccess)', '            if ( nPos < 0 || nPos + nSize > m_nLen )'], 'added_lines': ['unsigned int GetUVarBE(const unsigned int& nPos, const unsigned int& nSize, bool *pbSuccess)', '            if ( m_nLen < nSize || nPos > (m_nLen - nSize) )']}",True,Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below were discovered to contain a heap overflow via the component DesktopEditor/fontengine/fontconverter/FontFileBase.h.,9.8,CRITICAL,3,valid,2020-09-30T10:52:41Z,3
CVE-2022-29777,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ONLYOFFICE/core,"Fix 34, 35, 37",b17d5e860f30e8be2caeb0022b63be4c76660178,https://github.com/ONLYOFFICE/core/commit/b17d5e860f30e8be2caeb0022b63be4c76660178,DesktopEditor/fontengine/fontconverter/FontFileType1.cpp,CFontFileType1::RemovePfbMarkers,"bool CFontFileType1::RemovePfbMarkers()
{
bool bSuccess = true;
int nBlockType = 0;
int nBlockLen  = 0;
int nChar = 0;
unsigned char *sBuffer = NULL;
int nBufLen = 0;
while ( nBlockType != PFB_DONE )
{
while ( 0 == nBlockLen )
{
nChar = ReadU8( &bSuccess );
if ( !bSuccess )
return false;
nBlockType = ReadU8( &bSuccess );
if ( !bSuccess || PFB_MARKER != nChar || ( PFB_ASCII != nBlockType && PFB_BINARY != nBlockType && PFB_DONE != nBlockType ) )
return false;
if ( PFB_DONE == nBlockType )
break;
nBlockLen = ReadU32LE( &bSuccess );
if ( !bSuccess )
return false;
}
if ( nBlockLen > 0 )
{
if ( !sBuffer )
{
sBuffer = (unsigned char*)MemUtilsMalloc( nBlockLen );
if ( !sBuffer )
return false;
}
else
sBuffer = (unsigned char*)MemUtilsRealloc( sBuffer, nBufLen + nBlockLen );
Read( sBuffer + nBufLen, nBlockLen );
nBufLen += nBlockLen;
}
nBlockLen = 0;
}
if ( m_bFreeFileData )
MemUtilsFree( m_sFile );
m_bFreeFileData = true;
m_sFile         = (unsigned char*)sBuffer;
m_sFileData     = m_sFile;
m_nLen          = nBufLen;
m_nPos          = 0;
return true;
}","bool CFontFileType1::RemovePfbMarkers()
{
bool VAR_0 = true;
int VAR_1 = 0;
int VAR_2  = 0;
int VAR_3 = 0;
unsigned char *VAR_4 = NULL;
int VAR_5 = 0;
while ( VAR_1 != VAR_6 )
{
while ( 0 == VAR_2 )
{
VAR_3 = ReadU8( &VAR_0 );
if ( !VAR_0 )
return false;
VAR_1 = ReadU8( &VAR_0 );
if ( !VAR_0 || VAR_7 != VAR_3 || ( VAR_8 != VAR_1 && VAR_9 != VAR_1 && VAR_6 != VAR_1 ) )
return false;
if ( VAR_6 == VAR_1 )
break;
VAR_2 = ReadU32LE( &VAR_0 );
if ( !VAR_0 )
return false;
}
if ( VAR_2 > 0 )
{
if ( !VAR_4 )
{
VAR_4 = (unsigned char*)MemUtilsMalloc( VAR_2 );
if ( !VAR_4 )
return false;
}
else
VAR_4 = (unsigned char*)MemUtilsRealloc( VAR_4, VAR_5 + VAR_2 );
Read( VAR_4 + VAR_5, VAR_2 );
VAR_5 += VAR_2;
}
VAR_2 = 0;
}
if ( VAR_10 )
MemUtilsFree( VAR_11 );
VAR_10 = true;
VAR_11         = (unsigned char*)VAR_4;
VAR_12     = VAR_11;
VAR_13          = VAR_5;
VAR_14          = 0;
return true;
}",ONLYOFFICE/core/b17d5e860f30e8be2caeb0022b63be4c76660178/FontFileType1.cpp/vul/before/0.json,"bool CFontFileType1::RemovePfbMarkers()
    {
        bool bSuccess = true;

        int nBlockType = 0;
        int nBlockLen  = 0;
        int nChar = 0;

        unsigned char *sBuffer = NULL;
        unsigned int nBufLen = 0;

        while ( nBlockType != PFB_DONE )
        {
            while ( 0 == nBlockLen )
            {
                nChar = ReadU8( &bSuccess );
                if ( !bSuccess )
                    return false;

                nBlockType = ReadU8( &bSuccess );
                if ( !bSuccess || PFB_MARKER != nChar || ( PFB_ASCII != nBlockType && PFB_BINARY != nBlockType && PFB_DONE != nBlockType ) )
                    return false;

                if ( PFB_DONE == nBlockType )
                    break;

                nBlockLen = ReadU32LE( &bSuccess );
                if ( !bSuccess )
                    return false;
            }

            //    
            if ( nBlockLen > 0 )
            {
                if ( !sBuffer )
                {
                    sBuffer = (unsigned char*)MemUtilsMalloc( nBlockLen );
                    if ( !sBuffer )
                        return false;
                }
                else
                    sBuffer = (unsigned char*)MemUtilsRealloc( sBuffer, nBufLen + nBlockLen );

                Read( sBuffer + nBufLen, nBlockLen );
                nBufLen += nBlockLen;
            }
            nBlockLen = 0;
        }

        if ( m_bFreeFileData )
            MemUtilsFree( m_sFile );

        m_bFreeFileData = true;
        m_sFile         = (unsigned char*)sBuffer;
        m_sFileData     = m_sFile;
        m_nLen          = nBufLen;
        m_nPos          = 0;

        return true;
    }","bool CFontFileType1::RemovePfbMarkers()
    {
        bool VAR_0 = true;

        int VAR_1 = 0;
        int VAR_2  = 0;
        int VAR_3 = 0;

        unsigned char *VAR_4 = NULL;
        unsigned int VAR_5 = 0;

        while ( VAR_1 != VAR_6 )
        {
            while ( 0 == VAR_2 )
            {
                VAR_3 = ReadU8( &VAR_0 );
                if ( !VAR_0 )
                    return false;

                VAR_1 = ReadU8( &VAR_0 );
                if ( !VAR_0 || VAR_7 != VAR_3 || ( VAR_8 != VAR_1 && VAR_9 != VAR_1 && VAR_6 != VAR_1 ) )
                    return false;

                if ( VAR_6 == VAR_1 )
                    break;

                VAR_2 = ReadU32LE( &VAR_0 );
                if ( !VAR_0 )
                    return false;
            }

            /* COMMENT_0 */
            if ( VAR_2 > 0 )
            {
                if ( !VAR_4 )
                {
                    VAR_4 = (unsigned char*)MemUtilsMalloc( VAR_2 );
                    if ( !VAR_4 )
                        return false;
                }
                else
                    VAR_4 = (unsigned char*)MemUtilsRealloc( VAR_4, VAR_5 + VAR_2 );

                Read( VAR_4 + VAR_5, VAR_2 );
                VAR_5 += VAR_2;
            }
            VAR_2 = 0;
        }

        if ( VAR_10 )
            MemUtilsFree( VAR_11 );

        VAR_10 = true;
        VAR_11         = (unsigned char*)VAR_4;
        VAR_12     = VAR_11;
        VAR_13          = VAR_5;
        VAR_14          = 0;

        return true;
    }",ONLYOFFICE/core/b17d5e860f30e8be2caeb0022b63be4c76660178/FontFileType1.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
         int nChar = 0;
 
         unsigned char *sBuffer = NULL;
-        int nBufLen = 0;
+        unsigned int nBufLen = 0;
 
         while ( nBlockType != PFB_DONE )
         {","{'deleted_lines': ['        int nBufLen = 0;'], 'added_lines': ['        unsigned int nBufLen = 0;']}",True,Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below were discovered to contain a heap overflow via the component DesktopEditor/fontengine/fontconverter/FontFileBase.h.,9.8,CRITICAL,3,valid,2020-09-30T10:52:41Z,3
CVE-2022-29777,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ONLYOFFICE/core,"Fix 34, 35, 37",b17d5e860f30e8be2caeb0022b63be4c76660178,https://github.com/ONLYOFFICE/core/commit/b17d5e860f30e8be2caeb0022b63be4c76660178,DesktopEditor/fontengine/fontconverter/FontFileBase.h,CheckRegion,"bool         CheckRegion(int nPos, int nSize)
{
return (nPos >= 0 && nPos + nSize >= nPos && nPos + nSize <= m_nLen);
}","bool         CheckRegion(int VAR_0, int VAR_1)
{
return (VAR_0 >= 0 && VAR_0 + VAR_1 >= VAR_0 && VAR_0 + VAR_1 <= VAR_2);
}",,"bool         CheckRegion(const unsigned int& nPos, const unsigned int& nSize)
        {
            return (m_nLen >= nSize && nPos <= (m_nLen - nSize));
        }","bool         CheckRegion(const unsigned int& VAR_0, const unsigned int& VAR_1)
        {
            return (VAR_2 >= VAR_1 && VAR_0 <= (VAR_2 - VAR_1));
        }",,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-bool         CheckRegion(int nPos, int nSize)
+bool         CheckRegion(const unsigned int& nPos, const unsigned int& nSize)
         {
-            return (nPos >= 0 && nPos + nSize >= nPos && nPos + nSize <= m_nLen);
+            return (m_nLen >= nSize && nPos <= (m_nLen - nSize));
         }","{'deleted_lines': ['bool         CheckRegion(int nPos, int nSize)', '            return (nPos >= 0 && nPos + nSize >= nPos && nPos + nSize <= m_nLen);'], 'added_lines': ['bool         CheckRegion(const unsigned int& nPos, const unsigned int& nSize)', '            return (m_nLen >= nSize && nPos <= (m_nLen - nSize));']}",True,Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below were discovered to contain a heap overflow via the component DesktopEditor/fontengine/fontconverter/FontFileBase.h.,9.8,CRITICAL,3,valid,2020-09-30T10:52:41Z,3
CVE-2022-29777,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ONLYOFFICE/core,"Fix 34, 35, 37",b17d5e860f30e8be2caeb0022b63be4c76660178,https://github.com/ONLYOFFICE/core/commit/b17d5e860f30e8be2caeb0022b63be4c76660178,DesktopEditor/fontengine/fontconverter/FontFileBase.h,GetU32LE,"unsigned int GetU32LE (int nPos, bool *pbSuccess)
{
if ( nPos < 0 || nPos + 3 >= m_nLen )
{
*pbSuccess = false;
return 0;
}
unsigned int nRes = m_sFile[nPos + 3];
nRes = (nRes << 8) + m_sFile[nPos + 2];
nRes = (nRes << 8) + m_sFile[nPos + 1];
nRes = (nRes << 8) + m_sFile[nPos + 0];
return nRes;
}","unsigned int GetU32LE (int VAR_0, bool *VAR_1)
{
if ( VAR_0 < 0 || VAR_0 + 3 >= VAR_2 )
{
*VAR_1 = false;
return 0;
}
unsigned int VAR_3 = VAR_4[VAR_0 + 3];
VAR_3 = (VAR_3 << 8) + VAR_4[VAR_0 + 2];
VAR_3 = (VAR_3 << 8) + VAR_4[VAR_0 + 1];
VAR_3 = (VAR_3 << 8) + VAR_4[VAR_0 + 0];
return VAR_3;
}",,"unsigned int GetU32LE (const unsigned int& nPos, bool *pbSuccess)
        {
            //*pbSuccess = true;

            if ( m_nLen < 4 || nPos > (m_nLen - 4) )
            {
                *pbSuccess = false;
                return 0;
            }
            unsigned int nRes = m_sFile[nPos + 3];
            nRes = (nRes << 8) + m_sFile[nPos + 2];
            nRes = (nRes << 8) + m_sFile[nPos + 1];
            nRes = (nRes << 8) + m_sFile[nPos + 0];
            return nRes;
        }","unsigned int GetU32LE (const unsigned int& VAR_0, bool *VAR_1)
        {
            /* COMMENT_0 */

            if ( VAR_2 < 4 || VAR_0 > (VAR_2 - 4) )
            {
                *VAR_1 = false;
                return 0;
            }
            unsigned int VAR_3 = VAR_4[VAR_0 + 3];
            VAR_3 = (VAR_3 << 8) + VAR_4[VAR_0 + 2];
            VAR_3 = (VAR_3 << 8) + VAR_4[VAR_0 + 1];
            VAR_3 = (VAR_3 << 8) + VAR_4[VAR_0 + 0];
            return VAR_3;
        }",,"--- func_before
+++ func_after
@@ -1,8 +1,8 @@
-unsigned int GetU32LE (int nPos, bool *pbSuccess)
+unsigned int GetU32LE (const unsigned int& nPos, bool *pbSuccess)
         {
             //*pbSuccess = true;
 
-            if ( nPos < 0 || nPos + 3 >= m_nLen )
+            if ( m_nLen < 4 || nPos > (m_nLen - 4) )
             {
                 *pbSuccess = false;
                 return 0;","{'deleted_lines': ['unsigned int GetU32LE (int nPos, bool *pbSuccess)', '            if ( nPos < 0 || nPos + 3 >= m_nLen )'], 'added_lines': ['unsigned int GetU32LE (const unsigned int& nPos, bool *pbSuccess)', '            if ( m_nLen < 4 || nPos > (m_nLen - 4) )']}",True,Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below were discovered to contain a heap overflow via the component DesktopEditor/fontengine/fontconverter/FontFileBase.h.,9.8,CRITICAL,3,valid,2020-09-30T10:52:41Z,3
CVE-2022-29777,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ONLYOFFICE/core,"Fix 34, 35, 37",b17d5e860f30e8be2caeb0022b63be4c76660178,https://github.com/ONLYOFFICE/core/commit/b17d5e860f30e8be2caeb0022b63be4c76660178,DesktopEditor/fontengine/fontconverter/FontFileType1.cpp,CFontFileType1::Parse,"void CFontFileType1::Parse()
{
Reset();
while( m_nPos < m_nLen && ( ' ' == m_sFile[m_nPos] || '\t' == m_sFile[m_nPos] || '\r' == m_sFile[m_nPos] || '\n' == m_sFile[m_nPos] ) )
++m_nPos;
bool bSuccess = true;
int nChar = GetU8( m_nPos, &bSuccess );
if ( !bSuccess || ( PFB_MARKER != nChar && '%' != nChar ) )
return;
else if ( PFB_MARKER == nChar )
{
if ( !RemovePfbMarkers() )
return;
}
char *sLine, *sLine1, *pCur, *pTemp;
char sBuffer[256];
int nCount, nCode;
int nIndex = 0;
unsigned char *sEexec = NULL;
m_oTopDict.arrdFontBBox[0] = 0; m_oTopDict.arrdFontBBox[1] = 0;
m_oTopDict.arrdFontBBox[2] = 0; m_oTopDict.arrdFontBBox[3] = 0;
m_oTopDict.arrdFontMatrix[0] = 0.001; m_oTopDict.arrdFontMatrix[1] = 0;
m_oTopDict.arrdFontMatrix[2] = 0;     m_oTopDict.arrdFontMatrix[3] = 0.001;
m_oTopDict.arrdFontMatrix[4] = 0;     m_oTopDict.arrdFontMatrix[5] = 0;
for (nIndex = 1, sLine = (char *)m_sFile; nIndex <= 100 && sLine && (!m_sName || !m_arrEncoding); ++nIndex )
{
if ( !m_sName && !strncmp( sLine, ""/FontName"", 9) )
{
strncpy( sBuffer, sLine, 255);
sBuffer[255] = '\0';
if ( ( pCur = strchr( sBuffer + 9, '/' ) ) && ( pCur = strtok( pCur + 1, "" \t\n\r"" ) ) )
{
m_sName = CopyString( pCur );
}
sLine = GetNextLine(sLine);
}
else if ( !strncmp( sLine, ""/FontMatrix"", 11 ) )
{
strncpy( sBuffer, sLine, 255);
sBuffer[255] = '\0';
ReadDoubleArray<6>( (unsigned char*)(sBuffer + 11), 244, m_oTopDict.arrdFontMatrix );
sLine = GetNextLine( sLine );
}
else if ( !strncmp( sLine, ""/FontBBox"", 9 ) )
{
strncpy( sBuffer, sLine, 255);
sBuffer[255] = '\0';
ReadDoubleArray<4>( (unsigned char*)(sBuffer + 9), 246, m_oTopDict.arrdFontBBox );
sLine = GetNextLine( sLine );
}
else if (!m_arrEncoding && !strncmp( sLine, ""/Encoding StandardEncoding def"", 30))
{
m_arrEncoding = c_arrsFontFileType1StandardEncoding;
}
else if (!m_arrEncoding && !strncmp( sLine, ""/Encoding 256 array"", 19))
{
m_arrEncoding = (char **)MemUtilsMallocArray(256, sizeof(char *));
int nJ = 0;
for (nJ = 0; nJ < 256; ++nJ )
{
m_arrEncoding[nJ] = NULL;
}
for (nJ = 0, sLine = GetNextLine(sLine); nJ < 300 && sLine && ( sLine1 = GetNextLine( sLine )); ++nJ, sLine = sLine1)
{
if ( ( nCount = sLine1 - sLine ) > 255 )
{
nCount = 255;
}
strncpy( sBuffer, sLine, nCount);
sBuffer[ nCount ] = '\0';
for ( pCur = sBuffer; *pCur == ' ' || *pCur == '\t'; ++pCur );
if ( !strncmp( pCur, ""dup"", 3 ) )
{
for ( pCur += 3; *pCur == ' ' || *pCur == '\t'; ++pCur ) ;
for ( pTemp = pCur; *pTemp >= '0' && *pTemp <= '9'; ++pTemp ) ;
if ( *pTemp )
{
char nChar = *pTemp;
*pTemp = '\0';
nCode = atoi( pCur );
*pTemp = nChar;
if ( nCode == 8 && *pTemp == '#')
{
nCode = 0;
for (++pTemp; *pTemp >= '0' && *pTemp <= '7'; ++pTemp)
{
nCode = nCode * 8 + (*pTemp - '0');
}
}
if ( nCode < 256 )
{
for ( pCur = pTemp; *pCur == ' ' || *pCur == '\t'; ++pCur ) ;
if ( *pCur == '/')
{
++pCur;
for ( pTemp = pCur; *pTemp && *pTemp != ' ' && *pTemp != '\t'; ++pTemp ) ;
*pTemp = '\0';
m_arrEncoding[ nCode ] = CopyString( pCur );
}
}
}
}
else
{
if ( strtok( sBuffer, "" \t"") && ( pCur = strtok(NULL, "" \t\n\r"")) && !strcmp( pCur, ""def""))
{
break;
}
}
}
}
else
{
if ( !sEexec )
sEexec = (unsigned char*)strstr( sLine, ""currentfile eexec"" );
sLine = GetNextLine(sLine);
}
}
if ( NULL != sEexec )
{
unsigned char* sTemp = sEexec;
while ( sTemp != (unsigned char*)strstr( (char*)sTemp, ""cleartomark"" ) && sTemp < m_sFile + m_nLen )
sTemp++;
int nBufferLen = sTemp - ( sEexec + 17 );
unsigned char *sEexecBuffer = (unsigned char*)MemUtilsMalloc( nBufferLen );
if ( !sEexecBuffer )
return;
memcpy( sEexecBuffer, sEexec + 17, nBufferLen );
DecryptEexec( &sEexecBuffer, nBufferLen );
sEexec = sEexecBuffer + 4;             int nEexecLen = nBufferLen - 4;
bool bGlyphsSection = false, bSubrsSection = false;
std::wstring sToken, sGlyph;
int nLength = 0;
m_oPrivateDict.nBlueValues       = 0;
m_oPrivateDict.nOtherBlues       = 0;
m_oPrivateDict.nFamilyBlues      = 0;
m_oPrivateDict.nFamilyOtherBlues = 0;
m_oPrivateDict.dBlueScale        = 0.039625;
m_oPrivateDict.nBlueShift        = 7;
m_oPrivateDict.nBlueFuzz         = 1;
m_oPrivateDict.bHasStdHW         = false;
m_oPrivateDict.bHasStdVW         = false;
m_oPrivateDict.nStemSnapH        = 0;
m_oPrivateDict.nStemSnapV        = 0;
m_oPrivateDict.bHasForceBold     = false;
m_oPrivateDict.nLanguageGroup    = 0;
m_oPrivateDict.nLenIV            = 4;
m_oPrivateDict.dExpansionFactor  = 0.06;
for ( int nIndex = 0; nIndex < nEexecLen; nIndex++ )
{
unsigned char nChar = sEexec[nIndex];
if ( ( bGlyphsSection || bSubrsSection ) && 'R' == nChar && nLength > 0 )
{
unsigned char *sData = new unsigned char[nLength];
if ( sData )
{
memcpy( sData, sEexec + nIndex + 3, nLength );
unsigned short unKey = 4330U;
unsigned char *sCur = sData;
EexecDecode( &sCur, sCur + nLength, sCur, nLength, &unKey );
if ( m_oPrivateDict.nLenIV > 0 && m_oPrivateDict.nLenIV < nLength )
{
Type1Charstring oCharstring = DecodeCharString( sData + m_oPrivateDict.nLenIV, nLength - m_oPrivateDict.nLenIV );
if ( bGlyphsSection )
{
int nUnicode = Type1NameToUnicodeW( sGlyph.c_str() );
if ( 0 != nUnicode )
m_arrCharstrings.Add( Type1Glyph( sGlyph, nUnicode, oCharstring )  );
}
else                             {
m_arrSubrs.Add( oCharstring );
}
}
delete []sData;
}
nIndex += nLength + 3;
}
else if ( IS_PS_SPACE( nChar ) )
{
nLength = Utils::GetInteger( sToken );
sToken.clear();
}
else
{
sToken.push_back( (wchar_t)nChar );
if ( !bGlyphsSection && '/' == sToken[0] )
{
int nTempChar = sToken[1];
switch (nTempChar)
{
case 'B':
{
if ( L""/BlueValues"" == sToken )
m_oPrivateDict.nBlueValues = ReadIntArray<type1MaxBlueValues>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrnBlueValues );
else if ( L""/BlueScale"" == sToken )
m_oPrivateDict.dBlueScale  = ReadDouble( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );
else if ( L""/BlueShift"" == sToken )
m_oPrivateDict.nBlueShift  = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );
else if ( L""/BlueFuzz"" == sToken )
m_oPrivateDict.nBlueFuzz   = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );
break;
}
case 'C':
{
if ( L""/CharString"" == sToken )
bGlyphsSection = true;
break;
}
case 'E':
{
if ( L""/ExpansionFactor"" == sToken )
m_oPrivateDict.dExpansionFactor = ReadDouble( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );
break;
}
case 'F':
{
if ( L""/FamilyBlues"" == sToken )
m_oPrivateDict.nFamilyBlues = ReadIntArray<type1MaxBlueValues>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrnFamilyBlues );
else if ( L""/FamilyOtherBlues"" == sToken )
m_oPrivateDict.nFamilyOtherBlues = ReadIntArray<type1MaxOtherBlues>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrnFamilyOtherBlues );
else if ( L""/ForceBold"" == sToken )
{
m_oPrivateDict.bHasForceBold = true;
m_oPrivateDict.bForceBold = ReadBool( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );
}
break;
}
case 'L':
{
if ( L""/LanguageGroup"" == sToken )
m_oPrivateDict.nLanguageGroup = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );
else if ( L""/lenIV"" == sToken )
m_oPrivateDict.nLenIV = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );
break;
}
case 'S':
{
if ( L""/Subrs"" == sToken )
bSubrsSection = true;
else if ( L""/StemSnapH"" == sToken )
m_oPrivateDict.nStemSnapH = ReadDoubleArray<type1MaxStemSnap>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrdStemSnapH );
else if ( L""/StemSnapV"" == sToken )
m_oPrivateDict.nStemSnapV = ReadDoubleArray<type1MaxStemSnap>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrdStemSnapV );
else if ( L""/StdHW"" == sToken )
{
double dTemp[1];
if ( ReadDoubleArray<1>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, dTemp ) > 0 )
{
m_oPrivateDict.bHasStdHW = true;
m_oPrivateDict.dStdHW = dTemp[0];
}
}
else if ( L""/StdVW"" == sToken )
{
double dTemp[1];
if ( ReadDoubleArray<1>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, dTemp ) > 0 )
{
m_oPrivateDict.bHasStdHW = true;
m_oPrivateDict.dStdVW = dTemp[0];
}
}
}
}
}
else if ( '/' == nChar  )
{
sToken.clear();
sGlyph.clear();
while ( ( nChar = sEexec[++nIndex] ) != ' ' )
sGlyph.push_back( (wchar_t)nChar );
}
}
}
MemUtilsFree( sEexecBuffer );
qsort( m_arrCharstrings.GetData(), m_arrCharstrings.GetSize(), sizeof(Type1Glyph), CompareType1Glyph );
}
m_bParsed = true;
}","void CFontFileType1::Parse()
{
Reset();
while( VAR_0 < VAR_1 && ( ' ' == VAR_2[VAR_0] || '\t' == VAR_2[VAR_0] || '\r' == VAR_2[VAR_0] || '\n' == VAR_2[VAR_0] ) )
++VAR_0;
bool VAR_3 = true;
int VAR_4 = GetU8( VAR_0, &VAR_3 );
if ( !VAR_3 || ( VAR_5 != VAR_4 && '%' != VAR_4 ) )
return;
else if ( VAR_5 == VAR_4 )
{
if ( !RemovePfbMarkers() )
return;
}
char *VAR_6, *VAR_7, *VAR_8, *VAR_9;
char VAR_10[256];
int VAR_11, VAR_12;
int VAR_13 = 0;
unsigned char *VAR_14 = NULL;
VAR_15.arrdFontBBox[0] = 0; VAR_15.arrdFontBBox[1] = 0;
VAR_15.arrdFontBBox[2] = 0; VAR_15.arrdFontBBox[3] = 0;
VAR_15.arrdFontMatrix[0] = 0.001; VAR_15.arrdFontMatrix[1] = 0;
VAR_15.arrdFontMatrix[2] = 0;     VAR_15.arrdFontMatrix[3] = 0.001;
VAR_15.arrdFontMatrix[4] = 0;     VAR_15.arrdFontMatrix[5] = 0;
for (VAR_13 = 1, VAR_6 = (char *)VAR_2; VAR_13 <= 100 && VAR_6 && (!VAR_16 || !VAR_17); ++VAR_13 )
{
if ( !VAR_16 && !strncmp( VAR_6, ""/FontName"", 9) )
{
strncpy( VAR_10, VAR_6, 255);
VAR_10[255] = '\0';
if ( ( VAR_8 = strchr( VAR_10 + 9, '/' ) ) && ( VAR_8 = strtok( VAR_8 + 1, "" \t\n\r"" ) ) )
{
VAR_16 = CopyString( VAR_8 );
}
VAR_6 = GetNextLine(VAR_6);
}
else if ( !strncmp( VAR_6, ""/FontMatrix"", 11 ) )
{
strncpy( VAR_10, VAR_6, 255);
VAR_10[255] = '\0';
VAR_18<6>( (unsigned char*)(VAR_10 + 11), 244, VAR_15.arrdFontMatrix );
VAR_6 = GetNextLine( VAR_6 );
}
else if ( !strncmp( VAR_6, ""/FontBBox"", 9 ) )
{
strncpy( VAR_10, VAR_6, 255);
VAR_10[255] = '\0';
VAR_18<4>( (unsigned char*)(VAR_10 + 9), 246, VAR_15.arrdFontBBox );
VAR_6 = GetNextLine( VAR_6 );
}
else if (!VAR_17 && !strncmp( VAR_6, ""/Encoding StandardEncoding def"", 30))
{
VAR_17 = VAR_19;
}
else if (!VAR_17 && !strncmp( VAR_6, ""/Encoding 256 array"", 19))
{
VAR_17 = (char **)MemUtilsMallocArray(256, sizeof(char *));
int VAR_20 = 0;
for (VAR_20 = 0; VAR_20 < 256; ++VAR_20 )
{
VAR_17[VAR_20] = NULL;
}
for (VAR_20 = 0, VAR_6 = GetNextLine(VAR_6); VAR_20 < 300 && VAR_6 && ( VAR_7 = GetNextLine( VAR_6 )); ++VAR_20, VAR_6 = VAR_7)
{
if ( ( VAR_11 = VAR_7 - VAR_6 ) > 255 )
{
VAR_11 = 255;
}
strncpy( VAR_10, VAR_6, VAR_11);
VAR_10[ VAR_11 ] = '\0';
for ( VAR_8 = VAR_10; *VAR_8 == ' ' || *VAR_8 == '\t'; ++VAR_8 );
if ( !strncmp( VAR_8, ""dup"", 3 ) )
{
for ( VAR_8 += 3; *VAR_8 == ' ' || *VAR_8 == '\t'; ++VAR_8 ) ;
for ( VAR_9 = VAR_8; *VAR_9 >= '0' && *VAR_9 <= '9'; ++VAR_9 ) ;
if ( *VAR_9 )
{
char VAR_4 = *VAR_9;
*VAR_9 = '\0';
VAR_12 = atoi( VAR_8 );
*VAR_9 = VAR_4;
if ( VAR_12 == 8 && *VAR_9 == '#')
{
VAR_12 = 0;
for (++VAR_9; *VAR_9 >= '0' && *VAR_9 <= '7'; ++VAR_9)
{
VAR_12 = VAR_12 * 8 + (*VAR_9 - '0');
}
}
if ( VAR_12 < 256 )
{
for ( VAR_8 = VAR_9; *VAR_8 == ' ' || *VAR_8 == '\t'; ++VAR_8 ) ;
if ( *VAR_8 == '/')
{
++VAR_8;
for ( VAR_9 = VAR_8; *VAR_9 && *VAR_9 != ' ' && *VAR_9 != '\t'; ++VAR_9 ) ;
*VAR_9 = '\0';
VAR_17[ VAR_12 ] = CopyString( VAR_8 );
}
}
}
}
else
{
if ( strtok( VAR_10, "" \t"") && ( VAR_8 = strtok(NULL, "" \t\n\r"")) && !strcmp( VAR_8, ""def""))
{
break;
}
}
}
}
else
{
if ( !VAR_14 )
VAR_14 = (unsigned char*)strstr( VAR_6, ""currentfile eexec"" );
VAR_6 = GetNextLine(VAR_6);
}
}
if ( NULL != VAR_14 )
{
unsigned char* VAR_21 = VAR_14;
while ( VAR_21 != (unsigned char*)strstr( (char*)VAR_21, ""cleartomark"" ) && VAR_21 < VAR_2 + VAR_1 )
VAR_21++;
int VAR_22 = VAR_21 - ( VAR_14 + 17 );
unsigned char *VAR_23 = (unsigned char*)MemUtilsMalloc( VAR_22 );
if ( !VAR_23 )
return;
memcpy( VAR_23, VAR_14 + 17, VAR_22 );
DecryptEexec( &VAR_23, VAR_22 );
VAR_14 = VAR_23 + 4; 
int VAR_24 = VAR_22 - 4;
bool VAR_25 = false, VAR_26 = false;
std::wstring VAR_27, VAR_28;
int VAR_29 = 0;
VAR_30.nBlueValues       = 0;
VAR_30.nOtherBlues       = 0;
VAR_30.nFamilyBlues      = 0;
VAR_30.nFamilyOtherBlues = 0;
VAR_30.dBlueScale        = 0.039625;
VAR_30.nBlueShift        = 7;
VAR_30.nBlueFuzz         = 1;
VAR_30.bHasStdHW         = false;
VAR_30.bHasStdVW         = false;
VAR_30.nStemSnapH        = 0;
VAR_30.nStemSnapV        = 0;
VAR_30.bHasForceBold     = false;
VAR_30.nLanguageGroup    = 0;
VAR_30.nLenIV            = 4;
VAR_30.dExpansionFactor  = 0.06;
for ( int VAR_13 = 0; VAR_13 < VAR_24; VAR_13++ )
{
unsigned char VAR_4 = VAR_14[VAR_13];
if ( ( VAR_25 || VAR_26 ) && 'R' == VAR_4 && VAR_29 > 0 )
{
unsigned char *VAR_31 = new unsigned char[VAR_29];
if ( VAR_31 )
{
memcpy( VAR_31, VAR_14 + VAR_13 + 3, VAR_29 );
unsigned short VAR_32 = 4330U;
unsigned char *VAR_33 = VAR_31;
EexecDecode( &VAR_33, VAR_33 + VAR_29, VAR_33, VAR_29, &VAR_32 );
if ( VAR_30.nLenIV > 0 && VAR_30.nLenIV < VAR_29 )
{
Type1Charstring VAR_34 = DecodeCharString( VAR_31 + VAR_30.nLenIV, VAR_29 - VAR_30.nLenIV );
if ( VAR_25 )
{
int VAR_35 = Type1NameToUnicodeW( VAR_28.c_str() );
if ( 0 != VAR_35 )
VAR_36.Add( Type1Glyph( VAR_28, VAR_35, VAR_34 )  );
}
else 
{
VAR_37.Add( VAR_34 );
}
}
delete []VAR_31;
}
VAR_13 += VAR_29 + 3;
}
else if ( IS_PS_SPACE( VAR_4 ) )
{
VAR_29 = Utils::GetInteger( VAR_27 );
VAR_27.clear();
}
else
{
VAR_27.push_back( (wchar_t)VAR_4 );
if ( !VAR_25 && '/' == VAR_27[0] )
{
int VAR_38 = VAR_27[1];
switch (VAR_38)
{
case 'B':
{
if ( L""/BlueValues"" == VAR_27 )
VAR_30.nBlueValues = VAR_39<type1MaxBlueValues>( VAR_14 + VAR_13 + 2, VAR_24 - VAR_13 - 2, VAR_30.arrnBlueValues );
else if ( L""/BlueScale"" == VAR_27 )
VAR_30.dBlueScale  = ReadDouble( VAR_14 + VAR_13 + 1, VAR_24 - VAR_13 - 1 );
else if ( L""/BlueShift"" == VAR_27 )
VAR_30.nBlueShift  = ReadInt( VAR_14 + VAR_13 + 1, VAR_24 - VAR_13 - 1 );
else if ( L""/BlueFuzz"" == VAR_27 )
VAR_30.nBlueFuzz   = ReadInt( VAR_14 + VAR_13 + 1, VAR_24 - VAR_13 - 1 );
break;
}
case 'C':
{
if ( L""/CharString"" == VAR_27 )
VAR_25 = true;
break;
}
case 'E':
{
if ( L""/ExpansionFactor"" == VAR_27 )
VAR_30.dExpansionFactor = ReadDouble( VAR_14 + VAR_13 + 1, VAR_24 - VAR_13 - 1 );
break;
}
case 'F':
{
if ( L""/FamilyBlues"" == VAR_27 )
VAR_30.nFamilyBlues = VAR_39<type1MaxBlueValues>( VAR_14 + VAR_13 + 2, VAR_24 - VAR_13 - 2, VAR_30.arrnFamilyBlues );
else if ( L""/FamilyOtherBlues"" == VAR_27 )
VAR_30.nFamilyOtherBlues = VAR_39<type1MaxOtherBlues>( VAR_14 + VAR_13 + 2, VAR_24 - VAR_13 - 2, VAR_30.arrnFamilyOtherBlues );
else if ( L""/ForceBold"" == VAR_27 )
{
VAR_30.bHasForceBold = true;
VAR_30.bForceBold = ReadBool( VAR_14 + VAR_13 + 1, VAR_24 - VAR_13 - 1 );
}
break;
}
case 'L':
{
if ( L""/LanguageGroup"" == VAR_27 )
VAR_30.nLanguageGroup = ReadInt( VAR_14 + VAR_13 + 1, VAR_24 - VAR_13 - 1 );
else if ( L""/lenIV"" == VAR_27 )
VAR_30.nLenIV = ReadInt( VAR_14 + VAR_13 + 1, VAR_24 - VAR_13 - 1 );
break;
}
case 'S':
{
if ( L""/Subrs"" == VAR_27 )
VAR_26 = true;
else if ( L""/StemSnapH"" == VAR_27 )
VAR_30.nStemSnapH = VAR_18<type1MaxStemSnap>( VAR_14 + VAR_13 + 2, VAR_24 - VAR_13 - 2, VAR_30.arrdStemSnapH );
else if ( L""/StemSnapV"" == VAR_27 )
VAR_30.nStemSnapV = VAR_18<type1MaxStemSnap>( VAR_14 + VAR_13 + 2, VAR_24 - VAR_13 - 2, VAR_30.arrdStemSnapV );
else if ( L""/StdHW"" == VAR_27 )
{
double VAR_40[1];
if ( VAR_18<1>( VAR_14 + VAR_13 + 2, VAR_24 - VAR_13 - 2, VAR_40 ) > 0 )
{
VAR_30.bHasStdHW = true;
VAR_30.dStdHW = VAR_40[0];
}
}
else if ( L""/StdVW"" == VAR_27 )
{
double VAR_40[1];
if ( VAR_18<1>( VAR_14 + VAR_13 + 2, VAR_24 - VAR_13 - 2, VAR_40 ) > 0 )
{
VAR_30.bHasStdHW = true;
VAR_30.dStdVW = VAR_40[0];
}
}
}
}
}
else if ( '/' == VAR_4  )
{
VAR_27.clear();
VAR_28.clear();
while ( ( VAR_4 = VAR_14[++VAR_13] ) != ' ' )
VAR_28.push_back( (wchar_t)VAR_4 );
}
}
}
MemUtilsFree( VAR_23 );
qsort( VAR_36.GetData(), VAR_36.GetSize(), sizeof(VAR_41), VAR_42 );
}
VAR_43 = true;
}",ONLYOFFICE/core/b17d5e860f30e8be2caeb0022b63be4c76660178/FontFileType1.cpp/vul/before/1.json,"void CFontFileType1::Parse()
    {
        //  ,   pfb ,      .
        Reset();

        while( m_nPos < m_nLen && ( ' ' == m_sFile[m_nPos] || '\t' == m_sFile[m_nPos] || '\r' == m_sFile[m_nPos] || '\n' == m_sFile[m_nPos] ) )
            ++m_nPos;

        bool bSuccess = true;
        int nChar = GetU8( m_nPos, &bSuccess );
        if ( !bSuccess || ( PFB_MARKER != nChar && '%' != nChar ) )
            return;
        else if ( PFB_MARKER == nChar )
        {
            if ( !RemovePfbMarkers() )
                return;
        }

        char *sLine, *sLine1, *pCur, *pTemp;
        char sBuffer[256];
        int nCount, nCode;
        int nIndex = 0;
        unsigned char *sEexec = NULL;

        m_oTopDict.arrdFontBBox[0] = 0; m_oTopDict.arrdFontBBox[1] = 0;
        m_oTopDict.arrdFontBBox[2] = 0; m_oTopDict.arrdFontBBox[3] = 0;

        m_oTopDict.arrdFontMatrix[0] = 0.001; m_oTopDict.arrdFontMatrix[1] = 0;
        m_oTopDict.arrdFontMatrix[2] = 0;     m_oTopDict.arrdFontMatrix[3] = 0.001;
        m_oTopDict.arrdFontMatrix[4] = 0;     m_oTopDict.arrdFontMatrix[5] = 0;

        for (nIndex = 1, sLine = (char *)m_sFile; nIndex <= 100 && sLine && (!m_sName || !m_arrEncoding); ++nIndex )
        {
            if ( !m_sName && !strncmp( sLine, ""/FontName"", 9) )
            {
                strncpy( sBuffer, sLine, 255);
                sBuffer[255] = '\0';
                if ( ( pCur = strchr( sBuffer + 9, '/' ) ) && ( pCur = strtok( pCur + 1, "" \t\n\r"" ) ) )
                {
                    m_sName = CopyString( pCur );
                }
                sLine = GetNextLine(sLine);

            }
            else if ( !strncmp( sLine, ""/FontMatrix"", 11 ) )
            {
                strncpy( sBuffer, sLine, 255);
                sBuffer[255] = '\0';

                ReadDoubleArray<6>( (unsigned char*)(sBuffer + 11), 244, m_oTopDict.arrdFontMatrix );
                sLine = GetNextLine( sLine );
            }
            else if ( !strncmp( sLine, ""/FontBBox"", 9 ) )
            {
                strncpy( sBuffer, sLine, 255);
                sBuffer[255] = '\0';

                ReadDoubleArray<4>( (unsigned char*)(sBuffer + 9), 246, m_oTopDict.arrdFontBBox );
                sLine = GetNextLine( sLine );
            }
            else if (!m_arrEncoding && !strncmp( sLine, ""/Encoding StandardEncoding def"", 30))
            {
                m_arrEncoding = c_arrsFontFileType1StandardEncoding;
            }
            else if (!m_arrEncoding && !strncmp( sLine, ""/Encoding 256 array"", 19))
            {
                m_arrEncoding = (char **)MemUtilsMallocArray(256, sizeof(char *));
                int nJ = 0;
                for (nJ = 0; nJ < 256; ++nJ )
                {
                    m_arrEncoding[nJ] = NULL;
                }
                for (nJ = 0, sLine = GetNextLine(sLine); nJ < 300 && sLine && ( sLine1 = GetNextLine( sLine )); ++nJ, sLine = sLine1)
                {
                    if ( ( nCount = sLine1 - sLine ) > 255 )
                    {
                        nCount = 255;
                    }
                    strncpy( sBuffer, sLine, nCount);
                    sBuffer[ nCount ] = '\0';
                    for ( pCur = sBuffer; *pCur == ' ' || *pCur == '\t'; ++pCur );
                    if ( !strncmp( pCur, ""dup"", 3 ) )
                    {
                        for ( pCur += 3; *pCur == ' ' || *pCur == '\t'; ++pCur ) ;
                        for ( pTemp = pCur; *pTemp >= '0' && *pTemp <= '9'; ++pTemp ) ;
                        if ( *pTemp )
                        {
                            char nChar = *pTemp;
                            *pTemp = '\0';
                            nCode = atoi( pCur );
							if (nCode < 0) nCode = 0;								
                            *pTemp = nChar;
                            if ( nCode == 8 && *pTemp == '#')
                            {
                                nCode = 0;
                                for (++pTemp; *pTemp >= '0' && *pTemp <= '7'; ++pTemp)
                                {
                                    nCode = nCode * 8 + (*pTemp - '0');
                                }
                            }
                            if ( nCode < 256 )
                            {
                                for ( pCur = pTemp; *pCur == ' ' || *pCur == '\t'; ++pCur ) ;
                                if ( *pCur == '/')
                                {
                                    ++pCur;
                                    for ( pTemp = pCur; *pTemp && *pTemp != ' ' && *pTemp != '\t'; ++pTemp ) ;
                                    *pTemp = '\0';
                                    m_arrEncoding[ nCode ] = CopyString( pCur );
                                }
                            }
                        }
                    }
                    else
                    {
                        if ( strtok( sBuffer, "" \t"") && ( pCur = strtok(NULL, "" \t\n\r"")) && !strcmp( pCur, ""def""))
                        {
                            break;
                        }
                    }
                }
            }
            else
            {
                if ( !sEexec )
                    sEexec = (unsigned char*)strstr( sLine, ""currentfile eexec"" );

                sLine = GetNextLine(sLine);
            }
        }

        if ( NULL != sEexec )
        {
            unsigned char* sTemp = sEexec;
            while ( sTemp != (unsigned char*)strstr( (char*)sTemp, ""cleartomark"" ) && sTemp < m_sFile + m_nLen )
                sTemp++;

            int nBufferLen = sTemp - ( sEexec + 17 );
            unsigned char *sEexecBuffer = (unsigned char*)MemUtilsMalloc( nBufferLen );
            if ( !sEexecBuffer )
                return;

            memcpy( sEexecBuffer, sEexec + 17, nBufferLen );
            DecryptEexec( &sEexecBuffer, nBufferLen );

            sEexec = sEexecBuffer + 4; //     
            int nEexecLen = nBufferLen - 4;

            //    Private Dict
            bool bGlyphsSection = false, bSubrsSection = false;
            //unsigned short ushChar = '';
            std::wstring sToken, sGlyph;
            int nLength = 0;

            //      Private Dict
            m_oPrivateDict.nBlueValues       = 0;
            m_oPrivateDict.nOtherBlues       = 0;
            m_oPrivateDict.nFamilyBlues      = 0;
            m_oPrivateDict.nFamilyOtherBlues = 0;
            m_oPrivateDict.dBlueScale        = 0.039625;
            m_oPrivateDict.nBlueShift        = 7;
            m_oPrivateDict.nBlueFuzz         = 1;
            m_oPrivateDict.bHasStdHW         = false;
            m_oPrivateDict.bHasStdVW         = false;
            m_oPrivateDict.nStemSnapH        = 0;
            m_oPrivateDict.nStemSnapV        = 0;
            m_oPrivateDict.bHasForceBold     = false;
            m_oPrivateDict.nLanguageGroup    = 0;
            m_oPrivateDict.nLenIV            = 4;
            m_oPrivateDict.dExpansionFactor  = 0.06;

            for ( int nIndex = 0; nIndex < nEexecLen; nIndex++ )
            {
                unsigned char nChar = sEexec[nIndex];

                if ( ( bGlyphsSection || bSubrsSection ) && 'R' == nChar && nLength > 0 )
                {
                    unsigned char *sData = new unsigned char[nLength];
                    if ( sData )
                    {
                        memcpy( sData, sEexec + nIndex + 3, nLength );
                        unsigned short unKey = 4330U;
                        unsigned char *sCur = sData;
                        EexecDecode( &sCur, sCur + nLength, sCur, nLength, &unKey );

                        if ( m_oPrivateDict.nLenIV > 0 && m_oPrivateDict.nLenIV < nLength )
                        {
                            Type1Charstring oCharstring = DecodeCharString( sData + m_oPrivateDict.nLenIV, nLength - m_oPrivateDict.nLenIV );
                            if ( bGlyphsSection )
                            {
                                int nUnicode = Type1NameToUnicodeW( sGlyph.c_str() );

                                if ( 0 != nUnicode )
                                    m_arrCharstrings.Add( Type1Glyph( sGlyph, nUnicode, oCharstring )  );
                            }
                            else // if ( bSubrsSection )
                            {
                                m_arrSubrs.Add( oCharstring );
                            }
                        }

                        delete []sData;
                    }

                    nIndex += nLength + 3;
                }
                else if ( IS_PS_SPACE( nChar ) )
                {
                    nLength = Utils::GetInteger( sToken );
                    sToken.clear();
                }
                else
                {
                    sToken.push_back( (wchar_t)nChar );
                    if ( !bGlyphsSection && '/' == sToken[0] )
                    {
                        int nTempChar = sToken[1];
                        switch (nTempChar)
                        {
                        case 'B':
                            {
                                if ( L""/BlueValues"" == sToken )
                                    m_oPrivateDict.nBlueValues = ReadIntArray<type1MaxBlueValues>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrnBlueValues );
                                else if ( L""/BlueScale"" == sToken )
                                    m_oPrivateDict.dBlueScale  = ReadDouble( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );
                                else if ( L""/BlueShift"" == sToken )
                                    m_oPrivateDict.nBlueShift  = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );
                                else if ( L""/BlueFuzz"" == sToken )
                                    m_oPrivateDict.nBlueFuzz   = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );

                                break;
                            }
                        case 'C':
                            {
                                if ( L""/CharString"" == sToken )
                                    bGlyphsSection = true;

                                break;
                            }
                        case 'E':
                            {
                                if ( L""/ExpansionFactor"" == sToken )
                                    m_oPrivateDict.dExpansionFactor = ReadDouble( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );

                                break;
                            }
                        case 'F':
                            {
                                if ( L""/FamilyBlues"" == sToken )
                                    m_oPrivateDict.nFamilyBlues = ReadIntArray<type1MaxBlueValues>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrnFamilyBlues );
                                else if ( L""/FamilyOtherBlues"" == sToken )
                                    m_oPrivateDict.nFamilyOtherBlues = ReadIntArray<type1MaxOtherBlues>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrnFamilyOtherBlues );
                                else if ( L""/ForceBold"" == sToken )
                                {
                                    m_oPrivateDict.bHasForceBold = true;
                                    m_oPrivateDict.bForceBold = ReadBool( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );
                                }

                                break;
                            }
                        case 'L':
                            {
                                if ( L""/LanguageGroup"" == sToken )
                                    m_oPrivateDict.nLanguageGroup = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );
                                else if ( L""/lenIV"" == sToken )
                                    m_oPrivateDict.nLenIV = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );

                                break;
                            }
                        case 'S':
                            {
                                if ( L""/Subrs"" == sToken )
                                    bSubrsSection = true;
                                else if ( L""/StemSnapH"" == sToken )
                                    m_oPrivateDict.nStemSnapH = ReadDoubleArray<type1MaxStemSnap>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrdStemSnapH );
                                else if ( L""/StemSnapV"" == sToken )
                                    m_oPrivateDict.nStemSnapV = ReadDoubleArray<type1MaxStemSnap>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrdStemSnapV );
                                else if ( L""/StdHW"" == sToken )
                                {
                                    //      
                                    double dTemp[1];

                                    if ( ReadDoubleArray<1>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, dTemp ) > 0 )
                                    {
                                        m_oPrivateDict.bHasStdHW = true;
                                        m_oPrivateDict.dStdHW = dTemp[0];
                                    }
                                }
                                else if ( L""/StdVW"" == sToken )
                                {
                                    //      
                                    double dTemp[1];
                                    if ( ReadDoubleArray<1>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, dTemp ) > 0 )
                                    {
                                        m_oPrivateDict.bHasStdHW = true;
                                        m_oPrivateDict.dStdVW = dTemp[0];
                                    }
                                }
                            }
                        }
                    }
                    else if ( '/' == nChar  )
                    {
                        sToken.clear();
                        sGlyph.clear();

                        while ( nIndex < nEexecLen && ( nChar = sEexec[++nIndex] ) != ' ' )
                            sGlyph.push_back( (wchar_t)nChar );
                    }
                }
            }
            MemUtilsFree( sEexecBuffer );

            //    m_arrCharstrings   
            qsort( m_arrCharstrings.GetData(), m_arrCharstrings.GetSize(), sizeof(Type1Glyph), CompareType1Glyph );
        }

        m_bParsed = true;
    }","void CFontFileType1::Parse()
    {
        /* COMMENT_0 */
        Reset();

        while( VAR_0 < VAR_1 && ( ' ' == VAR_2[VAR_0] || '\t' == VAR_2[VAR_0] || '\r' == VAR_2[VAR_0] || '\n' == VAR_2[VAR_0] ) )
            ++VAR_0;

        bool VAR_3 = true;
        int VAR_4 = GetU8( VAR_0, &VAR_3 );
        if ( !VAR_3 || ( VAR_5 != VAR_4 && '%' != VAR_4 ) )
            return;
        else if ( VAR_5 == VAR_4 )
        {
            if ( !RemovePfbMarkers() )
                return;
        }

        char *VAR_6, *VAR_7, *VAR_8, *VAR_9;
        char VAR_10[256];
        int VAR_11, VAR_12;
        int VAR_13 = 0;
        unsigned char *VAR_14 = NULL;

        VAR_15.arrdFontBBox[0] = 0; VAR_15.arrdFontBBox[1] = 0;
        VAR_15.arrdFontBBox[2] = 0; VAR_15.arrdFontBBox[3] = 0;

        VAR_15.arrdFontMatrix[0] = 0.001; VAR_15.arrdFontMatrix[1] = 0;
        VAR_15.arrdFontMatrix[2] = 0;     VAR_15.arrdFontMatrix[3] = 0.001;
        VAR_15.arrdFontMatrix[4] = 0;     VAR_15.arrdFontMatrix[5] = 0;

        for (VAR_13 = 1, VAR_6 = (char *)VAR_2; VAR_13 <= 100 && VAR_6 && (!VAR_16 || !VAR_17); ++VAR_13 )
        {
            if ( !VAR_16 && !strncmp( VAR_6, ""/FontName"", 9) )
            {
                strncpy( VAR_10, VAR_6, 255);
                VAR_10[255] = '\0';
                if ( ( VAR_8 = strchr( VAR_10 + 9, '/' ) ) && ( VAR_8 = strtok( VAR_8 + 1, "" \t\n\r"" ) ) )
                {
                    VAR_16 = CopyString( VAR_8 );
                }
                VAR_6 = GetNextLine(VAR_6);

            }
            else if ( !strncmp( VAR_6, ""/FontMatrix"", 11 ) )
            {
                strncpy( VAR_10, VAR_6, 255);
                VAR_10[255] = '\0';

                VAR_18<6>( (unsigned char*)(VAR_10 + 11), 244, VAR_15.arrdFontMatrix );
                VAR_6 = GetNextLine( VAR_6 );
            }
            else if ( !strncmp( VAR_6, ""/FontBBox"", 9 ) )
            {
                strncpy( VAR_10, VAR_6, 255);
                VAR_10[255] = '\0';

                VAR_18<4>( (unsigned char*)(VAR_10 + 9), 246, VAR_15.arrdFontBBox );
                VAR_6 = GetNextLine( VAR_6 );
            }
            else if (!VAR_17 && !strncmp( VAR_6, ""/Encoding StandardEncoding def"", 30))
            {
                VAR_17 = VAR_19;
            }
            else if (!VAR_17 && !strncmp( VAR_6, ""/Encoding 256 array"", 19))
            {
                VAR_17 = (char **)MemUtilsMallocArray(256, sizeof(char *));
                int VAR_20 = 0;
                for (VAR_20 = 0; VAR_20 < 256; ++VAR_20 )
                {
                    VAR_17[VAR_20] = NULL;
                }
                for (VAR_20 = 0, VAR_6 = GetNextLine(VAR_6); VAR_20 < 300 && VAR_6 && ( VAR_7 = GetNextLine( VAR_6 )); ++VAR_20, VAR_6 = VAR_7)
                {
                    if ( ( VAR_11 = VAR_7 - VAR_6 ) > 255 )
                    {
                        VAR_11 = 255;
                    }
                    strncpy( VAR_10, VAR_6, VAR_11);
                    VAR_10[ VAR_11 ] = '\0';
                    for ( VAR_8 = VAR_10; *VAR_8 == ' ' || *VAR_8 == '\t'; ++VAR_8 );
                    if ( !strncmp( VAR_8, ""dup"", 3 ) )
                    {
                        for ( VAR_8 += 3; *VAR_8 == ' ' || *VAR_8 == '\t'; ++VAR_8 ) ;
                        for ( VAR_9 = VAR_8; *VAR_9 >= '0' && *VAR_9 <= '9'; ++VAR_9 ) ;
                        if ( *VAR_9 )
                        {
                            char VAR_4 = *VAR_9;
                            *VAR_9 = '\0';
                            VAR_12 = atoi( VAR_8 );
							if (VAR_12 < 0) VAR_12 = 0;								
                            *VAR_9 = VAR_4;
                            if ( VAR_12 == 8 && *VAR_9 == '#')
                            {
                                VAR_12 = 0;
                                for (++VAR_9; *VAR_9 >= '0' && *VAR_9 <= '7'; ++VAR_9)
                                {
                                    VAR_12 = VAR_12 * 8 + (*VAR_9 - '0');
                                }
                            }
                            if ( VAR_12 < 256 )
                            {
                                for ( VAR_8 = VAR_9; *VAR_8 == ' ' || *VAR_8 == '\t'; ++VAR_8 ) ;
                                if ( *VAR_8 == '/')
                                {
                                    ++VAR_8;
                                    for ( VAR_9 = VAR_8; *VAR_9 && *VAR_9 != ' ' && *VAR_9 != '\t'; ++VAR_9 ) ;
                                    *VAR_9 = '\0';
                                    VAR_17[ VAR_12 ] = CopyString( VAR_8 );
                                }
                            }
                        }
                    }
                    else
                    {
                        if ( strtok( VAR_10, "" \t"") && ( VAR_8 = strtok(NULL, "" \t\n\r"")) && !strcmp( VAR_8, ""def""))
                        {
                            break;
                        }
                    }
                }
            }
            else
            {
                if ( !VAR_14 )
                    VAR_14 = (unsigned char*)strstr( VAR_6, ""currentfile eexec"" );

                VAR_6 = GetNextLine(VAR_6);
            }
        }

        if ( NULL != VAR_14 )
        {
            unsigned char* VAR_21 = VAR_14;
            while ( VAR_21 != (unsigned char*)strstr( (char*)VAR_21, ""cleartomark"" ) && VAR_21 < VAR_2 + VAR_1 )
                VAR_21++;

            int VAR_22 = VAR_21 - ( VAR_14 + 17 );
            unsigned char *VAR_23 = (unsigned char*)MemUtilsMalloc( VAR_22 );
            if ( !VAR_23 )
                return;

            memcpy( VAR_23, VAR_14 + 17, VAR_22 );
            DecryptEexec( &VAR_23, VAR_22 );

            VAR_14 = VAR_23 + 4; /* COMMENT_1 */
            int VAR_24 = VAR_22 - 4;

            /* COMMENT_2 */
            bool VAR_25 = false, VAR_26 = false;
            /* COMMENT_3 */
            std::wstring VAR_27, VAR_28;
            int VAR_29 = 0;

            /* COMMENT_4 */
            VAR_30.nBlueValues       = 0;
            VAR_30.nOtherBlues       = 0;
            VAR_30.nFamilyBlues      = 0;
            VAR_30.nFamilyOtherBlues = 0;
            VAR_30.dBlueScale        = 0.039625;
            VAR_30.nBlueShift        = 7;
            VAR_30.nBlueFuzz         = 1;
            VAR_30.bHasStdHW         = false;
            VAR_30.bHasStdVW         = false;
            VAR_30.nStemSnapH        = 0;
            VAR_30.nStemSnapV        = 0;
            VAR_30.bHasForceBold     = false;
            VAR_30.nLanguageGroup    = 0;
            VAR_30.nLenIV            = 4;
            VAR_30.dExpansionFactor  = 0.06;

            for ( int VAR_13 = 0; VAR_13 < VAR_24; VAR_13++ )
            {
                unsigned char VAR_4 = VAR_14[VAR_13];

                if ( ( VAR_25 || VAR_26 ) && 'R' == VAR_4 && VAR_29 > 0 )
                {
                    unsigned char *VAR_31 = new unsigned char[VAR_29];
                    if ( VAR_31 )
                    {
                        memcpy( VAR_31, VAR_14 + VAR_13 + 3, VAR_29 );
                        unsigned short VAR_32 = 4330U;
                        unsigned char *VAR_33 = VAR_31;
                        EexecDecode( &VAR_33, VAR_33 + VAR_29, VAR_33, VAR_29, &VAR_32 );

                        if ( VAR_30.nLenIV > 0 && VAR_30.nLenIV < VAR_29 )
                        {
                            Type1Charstring VAR_34 = DecodeCharString( VAR_31 + VAR_30.nLenIV, VAR_29 - VAR_30.nLenIV );
                            if ( VAR_25 )
                            {
                                int VAR_35 = Type1NameToUnicodeW( VAR_28.c_str() );

                                if ( 0 != VAR_35 )
                                    VAR_36.Add( Type1Glyph( VAR_28, VAR_35, VAR_34 )  );
                            }
                            else /* COMMENT_5 */
                            {
                                VAR_37.Add( VAR_34 );
                            }
                        }

                        delete []VAR_31;
                    }

                    VAR_13 += VAR_29 + 3;
                }
                else if ( IS_PS_SPACE( VAR_4 ) )
                {
                    VAR_29 = Utils::GetInteger( VAR_27 );
                    VAR_27.clear();
                }
                else
                {
                    VAR_27.push_back( (wchar_t)VAR_4 );
                    if ( !VAR_25 && '/' == VAR_27[0] )
                    {
                        int VAR_38 = VAR_27[1];
                        switch (VAR_38)
                        {
                        case 'B':
                            {
                                if ( L""/BlueValues"" == VAR_27 )
                                    VAR_30.nBlueValues = VAR_39<type1MaxBlueValues>( VAR_14 + VAR_13 + 2, VAR_24 - VAR_13 - 2, VAR_30.arrnBlueValues );
                                else if ( L""/BlueScale"" == VAR_27 )
                                    VAR_30.dBlueScale  = ReadDouble( VAR_14 + VAR_13 + 1, VAR_24 - VAR_13 - 1 );
                                else if ( L""/BlueShift"" == VAR_27 )
                                    VAR_30.nBlueShift  = ReadInt( VAR_14 + VAR_13 + 1, VAR_24 - VAR_13 - 1 );
                                else if ( L""/BlueFuzz"" == VAR_27 )
                                    VAR_30.nBlueFuzz   = ReadInt( VAR_14 + VAR_13 + 1, VAR_24 - VAR_13 - 1 );

                                break;
                            }
                        case 'C':
                            {
                                if ( L""/CharString"" == VAR_27 )
                                    VAR_25 = true;

                                break;
                            }
                        case 'E':
                            {
                                if ( L""/ExpansionFactor"" == VAR_27 )
                                    VAR_30.dExpansionFactor = ReadDouble( VAR_14 + VAR_13 + 1, VAR_24 - VAR_13 - 1 );

                                break;
                            }
                        case 'F':
                            {
                                if ( L""/FamilyBlues"" == VAR_27 )
                                    VAR_30.nFamilyBlues = VAR_39<type1MaxBlueValues>( VAR_14 + VAR_13 + 2, VAR_24 - VAR_13 - 2, VAR_30.arrnFamilyBlues );
                                else if ( L""/FamilyOtherBlues"" == VAR_27 )
                                    VAR_30.nFamilyOtherBlues = VAR_39<type1MaxOtherBlues>( VAR_14 + VAR_13 + 2, VAR_24 - VAR_13 - 2, VAR_30.arrnFamilyOtherBlues );
                                else if ( L""/ForceBold"" == VAR_27 )
                                {
                                    VAR_30.bHasForceBold = true;
                                    VAR_30.bForceBold = ReadBool( VAR_14 + VAR_13 + 1, VAR_24 - VAR_13 - 1 );
                                }

                                break;
                            }
                        case 'L':
                            {
                                if ( L""/LanguageGroup"" == VAR_27 )
                                    VAR_30.nLanguageGroup = ReadInt( VAR_14 + VAR_13 + 1, VAR_24 - VAR_13 - 1 );
                                else if ( L""/lenIV"" == VAR_27 )
                                    VAR_30.nLenIV = ReadInt( VAR_14 + VAR_13 + 1, VAR_24 - VAR_13 - 1 );

                                break;
                            }
                        case 'S':
                            {
                                if ( L""/Subrs"" == VAR_27 )
                                    VAR_26 = true;
                                else if ( L""/StemSnapH"" == VAR_27 )
                                    VAR_30.nStemSnapH = VAR_18<type1MaxStemSnap>( VAR_14 + VAR_13 + 2, VAR_24 - VAR_13 - 2, VAR_30.arrdStemSnapH );
                                else if ( L""/StemSnapV"" == VAR_27 )
                                    VAR_30.nStemSnapV = VAR_18<type1MaxStemSnap>( VAR_14 + VAR_13 + 2, VAR_24 - VAR_13 - 2, VAR_30.arrdStemSnapV );
                                else if ( L""/StdHW"" == VAR_27 )
                                {
                                    /* COMMENT_6 */
                                    double VAR_40[1];

                                    if ( VAR_18<1>( VAR_14 + VAR_13 + 2, VAR_24 - VAR_13 - 2, VAR_40 ) > 0 )
                                    {
                                        VAR_30.bHasStdHW = true;
                                        VAR_30.dStdHW = VAR_40[0];
                                    }
                                }
                                else if ( L""/StdVW"" == VAR_27 )
                                {
                                    /* COMMENT_6 */
                                    double VAR_40[1];
                                    if ( VAR_18<1>( VAR_14 + VAR_13 + 2, VAR_24 - VAR_13 - 2, VAR_40 ) > 0 )
                                    {
                                        VAR_30.bHasStdHW = true;
                                        VAR_30.dStdVW = VAR_40[0];
                                    }
                                }
                            }
                        }
                    }
                    else if ( '/' == VAR_4  )
                    {
                        VAR_27.clear();
                        VAR_28.clear();

                        while ( VAR_13 < nEexecLen && ( nChar = VAR_14[++VAR_13] ) != ' ' )
                            VAR_28.push_back( (wchar_t)nChar );
                    }
                }
            }
            MemUtilsFree( VAR_23 );

            /* COMMENT_7 */
            qsort( VAR_36.GetData(), VAR_36.GetSize(), sizeof(VAR_41), VAR_42 );
        }

        VAR_43 = true;
    }",ONLYOFFICE/core/b17d5e860f30e8be2caeb0022b63be4c76660178/FontFileType1.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -88,6 +88,7 @@
                             char nChar = *pTemp;
                             *pTemp = '\0';
                             nCode = atoi( pCur );
+							if (nCode < 0) nCode = 0;								
                             *pTemp = nChar;
                             if ( nCode == 8 && *pTemp == '#')
                             {
@@ -303,7 +304,7 @@
                         sToken.clear();
                         sGlyph.clear();
 
-                        while ( ( nChar = sEexec[++nIndex] ) != ' ' )
+                        while ( nIndex < nEexecLen && ( nChar = sEexec[++nIndex] ) != ' ' )
                             sGlyph.push_back( (wchar_t)nChar );
                     }
                 }","{'deleted_lines': [""                        while ( ( nChar = sEexec[++nIndex] ) != ' ' )""], 'added_lines': ['\t\t\t\t\t\t\tif (nCode < 0) nCode = 0;\t\t\t\t\t\t\t\t', ""                        while ( nIndex < nEexecLen && ( nChar = sEexec[++nIndex] ) != ' ' )""]}",True,Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below were discovered to contain a heap overflow via the component DesktopEditor/fontengine/fontconverter/FontFileBase.h.,9.8,CRITICAL,3,valid,2020-09-30T10:52:41Z,3
CVE-2022-29777,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ONLYOFFICE/core,"Fix 34, 35, 37",b17d5e860f30e8be2caeb0022b63be4c76660178,https://github.com/ONLYOFFICE/core/commit/b17d5e860f30e8be2caeb0022b63be4c76660178,DesktopEditor/fontengine/fontconverter/FontFileBase.h,GetU16BE,"int          GetU16BE (int nPos, bool *pbSuccess)
{
if ( nPos < 0 || nPos + 1 >= m_nLen)
{
*pbSuccess = false;
return 0;
}
int nRes = m_sFile[ nPos ];
nRes = (nRes << 8) + m_sFile[ nPos + 1 ];
return nRes;
}","int          GetU16BE (int VAR_0, bool *VAR_1)
{
if ( VAR_0 < 0 || VAR_0 + 1 >= VAR_2)
{
*VAR_1 = false;
return 0;
}
int VAR_3 = VAR_4[ VAR_0 ];
VAR_3 = (VAR_3 << 8) + VAR_4[ VAR_0 + 1 ];
return VAR_3;
}",,"int          GetU16BE (const unsigned int& nPos, bool *pbSuccess)
        {
            //*pbSuccess = true;

            if ( m_nLen < 2 || nPos > (m_nLen - 2) )
            {
                *pbSuccess = false;
                return 0;
            }
            int nRes = m_sFile[ nPos ];
            nRes = (nRes << 8) + m_sFile[ nPos + 1 ];
            return nRes;
        }","int          GetU16BE (const unsigned int& VAR_0, bool *VAR_1)
        {
            /* COMMENT_0 */

            if ( VAR_2 < 2 || VAR_0 > (VAR_2 - 2) )
            {
                *VAR_1 = false;
                return 0;
            }
            int VAR_3 = VAR_4[ VAR_0 ];
            VAR_3 = (VAR_3 << 8) + VAR_4[ VAR_0 + 1 ];
            return VAR_3;
        }",,"--- func_before
+++ func_after
@@ -1,8 +1,8 @@
-int          GetU16BE (int nPos, bool *pbSuccess)
+int          GetU16BE (const unsigned int& nPos, bool *pbSuccess)
         {
             //*pbSuccess = true;
 
-            if ( nPos < 0 || nPos + 1 >= m_nLen)
+            if ( m_nLen < 2 || nPos > (m_nLen - 2) )
             {
                 *pbSuccess = false;
                 return 0;","{'deleted_lines': ['int          GetU16BE (int nPos, bool *pbSuccess)', '            if ( nPos < 0 || nPos + 1 >= m_nLen)'], 'added_lines': ['int          GetU16BE (const unsigned int& nPos, bool *pbSuccess)', '            if ( m_nLen < 2 || nPos > (m_nLen - 2) )']}",True,Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below were discovered to contain a heap overflow via the component DesktopEditor/fontengine/fontconverter/FontFileBase.h.,9.8,CRITICAL,3,valid,2020-09-30T10:52:41Z,3
CVE-2022-29777,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ONLYOFFICE/core,"Fix 34, 35, 37",b17d5e860f30e8be2caeb0022b63be4c76660178,https://github.com/ONLYOFFICE/core/commit/b17d5e860f30e8be2caeb0022b63be4c76660178,DesktopEditor/fontengine/fontconverter/FontFileBase.h,GetS16BE,"int          GetS16BE (int nPos, bool *pbSuccess)
{
if ( nPos < 0 || nPos + 1 >= m_nLen )
{
*pbSuccess = false;
return 0;
}
int nRes = m_sFile[nPos];
nRes = (nRes << 8) + m_sFile[ nPos + 1 ];
if ( nRes & 0x8000 )
nRes |= ~0xffff;
return nRes;
}","int          GetS16BE (int VAR_0, bool *VAR_1)
{
if ( VAR_0 < 0 || VAR_0 + 1 >= VAR_2 )
{
*VAR_1 = false;
return 0;
}
int VAR_3 = VAR_4[VAR_0];
VAR_3 = (VAR_3 << 8) + VAR_4[ VAR_0 + 1 ];
if ( VAR_3 & 0x8000 )
VAR_3 |= ~0xffff;
return VAR_3;
}",,"int          GetS16BE (const unsigned int& nPos, bool *pbSuccess)
        {
            //*pbSuccess = true;

            if ( m_nLen < 2 || nPos > (m_nLen - 2) )
            {
                *pbSuccess = false;
                return 0;
            }
            int nRes = m_sFile[nPos];
            nRes = (nRes << 8) + m_sFile[ nPos + 1 ];
            if ( nRes & 0x8000 )
                nRes |= ~0xffff;
            return nRes;
        }","int          GetS16BE (const unsigned int& VAR_0, bool *VAR_1)
        {
            /* COMMENT_0 */

            if ( VAR_2 < 2 || VAR_0 > (VAR_2 - 2) )
            {
                *VAR_1 = false;
                return 0;
            }
            int VAR_3 = VAR_4[VAR_0];
            VAR_3 = (VAR_3 << 8) + VAR_4[ VAR_0 + 1 ];
            if ( VAR_3 & 0x8000 )
                VAR_3 |= ~0xffff;
            return VAR_3;
        }",,"--- func_before
+++ func_after
@@ -1,8 +1,8 @@
-int          GetS16BE (int nPos, bool *pbSuccess)
+int          GetS16BE (const unsigned int& nPos, bool *pbSuccess)
         {
             //*pbSuccess = true;
 
-            if ( nPos < 0 || nPos + 1 >= m_nLen )
+            if ( m_nLen < 2 || nPos > (m_nLen - 2) )
             {
                 *pbSuccess = false;
                 return 0;","{'deleted_lines': ['int          GetS16BE (int nPos, bool *pbSuccess)', '            if ( nPos < 0 || nPos + 1 >= m_nLen )'], 'added_lines': ['int          GetS16BE (const unsigned int& nPos, bool *pbSuccess)', '            if ( m_nLen < 2 || nPos > (m_nLen - 2) )']}",True,Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below were discovered to contain a heap overflow via the component DesktopEditor/fontengine/fontconverter/FontFileBase.h.,9.8,CRITICAL,3,valid,2020-09-30T10:52:41Z,3
CVE-2022-29777,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ONLYOFFICE/core,"Fix 34, 35, 37",b17d5e860f30e8be2caeb0022b63be4c76660178,https://github.com/ONLYOFFICE/core/commit/b17d5e860f30e8be2caeb0022b63be4c76660178,DesktopEditor/fontengine/fontconverter/FontFileBase.h,Read,"int          Read(void* pDestBuffer, int nSize)
{
if ( m_nPos + nSize >= m_nLen )
nSize = m_nLen - m_nPos - 1;
memcpy( pDestBuffer, (m_sFile + m_nPos), nSize );
m_nPos += nSize;
return nSize;
}","int          Read(void* VAR_0, int VAR_1)
{
if ( VAR_2 + VAR_1 >= VAR_3 )
VAR_1 = VAR_3 - VAR_2 - 1;
memcpy( VAR_0, (VAR_4 + VAR_2), VAR_1 );
VAR_2 += VAR_1;
return VAR_1;
}",ONLYOFFICE/core/b17d5e860f30e8be2caeb0022b63be4c76660178/FontFileBase.h/vul/before/4.json,"int          Read(void* pDestBuffer, unsigned int nSize)
        {
            if (m_nPos >= m_nLen)
                nSize = 0;
            else if (nSize > (m_nLen - m_nPos))
                nSize = m_nLen - m_nPos;

            memcpy( pDestBuffer, (m_sFile + m_nPos), nSize );
            m_nPos += nSize;

            return nSize;
        }","int          Read(void* VAR_0, unsigned int VAR_1)
        {
            if (VAR_2 >= VAR_3)
                VAR_1 = 0;
            else if (VAR_1 > (VAR_3 - VAR_2))
                VAR_1 = VAR_3 - VAR_2;

            memcpy( VAR_0, (VAR_4 + VAR_2), VAR_1 );
            VAR_2 += VAR_1;

            return VAR_1;
        }",ONLYOFFICE/core/b17d5e860f30e8be2caeb0022b63be4c76660178/FontFileBase.h/vul/after/4.json,"--- func_before
+++ func_after
@@ -1,7 +1,9 @@
-int          Read(void* pDestBuffer, int nSize)
+int          Read(void* pDestBuffer, unsigned int nSize)
         {
-            if ( m_nPos + nSize >= m_nLen )
-                nSize = m_nLen - m_nPos - 1;
+            if (m_nPos >= m_nLen)
+                nSize = 0;
+            else if (nSize > (m_nLen - m_nPos))
+                nSize = m_nLen - m_nPos;
 
             memcpy( pDestBuffer, (m_sFile + m_nPos), nSize );
             m_nPos += nSize;","{'deleted_lines': ['int          Read(void* pDestBuffer, int nSize)', '            if ( m_nPos + nSize >= m_nLen )', '                nSize = m_nLen - m_nPos - 1;'], 'added_lines': ['int          Read(void* pDestBuffer, unsigned int nSize)', '            if (m_nPos >= m_nLen)', '                nSize = 0;', '            else if (nSize > (m_nLen - m_nPos))', '                nSize = m_nLen - m_nPos;']}",True,Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below were discovered to contain a heap overflow via the component DesktopEditor/fontengine/fontconverter/FontFileBase.h.,9.8,CRITICAL,3,valid,2020-09-30T10:52:41Z,3
CVE-2022-29777,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ONLYOFFICE/core,"Fix 34, 35, 37",b17d5e860f30e8be2caeb0022b63be4c76660178,https://github.com/ONLYOFFICE/core/commit/b17d5e860f30e8be2caeb0022b63be4c76660178,DesktopEditor/fontengine/fontconverter/FontFileBase.h,GetU32BE,"unsigned int GetU32BE (int nPos, bool *pbSuccess)
{
if ( nPos < 0 || nPos + 3 >= m_nLen )
{
*pbSuccess = false;
return 0;
}
unsigned int nRes = m_sFile[nPos];
nRes = (nRes << 8) + m_sFile[nPos + 1];
nRes = (nRes << 8) + m_sFile[nPos + 2];
nRes = (nRes << 8) + m_sFile[nPos + 3];
return nRes;
}","unsigned int GetU32BE (int VAR_0, bool *VAR_1)
{
if ( VAR_0 < 0 || VAR_0 + 3 >= VAR_2 )
{
*VAR_1 = false;
return 0;
}
unsigned int VAR_3 = VAR_4[VAR_0];
VAR_3 = (VAR_3 << 8) + VAR_4[VAR_0 + 1];
VAR_3 = (VAR_3 << 8) + VAR_4[VAR_0 + 2];
VAR_3 = (VAR_3 << 8) + VAR_4[VAR_0 + 3];
return VAR_3;
}",,"unsigned int GetU32BE (const unsigned int& nPos, bool *pbSuccess)
        {
            //*pbSuccess = true;

            if ( m_nLen < 4 || nPos > (m_nLen - 4) )
            {
                *pbSuccess = false;
                return 0;
            }
            unsigned int nRes = m_sFile[nPos];
            nRes = (nRes << 8) + m_sFile[nPos + 1];
            nRes = (nRes << 8) + m_sFile[nPos + 2];
            nRes = (nRes << 8) + m_sFile[nPos + 3];
            return nRes;
        }","unsigned int GetU32BE (const unsigned int& VAR_0, bool *VAR_1)
        {
            /* COMMENT_0 */

            if ( VAR_2 < 4 || VAR_0 > (VAR_2 - 4) )
            {
                *VAR_1 = false;
                return 0;
            }
            unsigned int VAR_3 = VAR_4[VAR_0];
            VAR_3 = (VAR_3 << 8) + VAR_4[VAR_0 + 1];
            VAR_3 = (VAR_3 << 8) + VAR_4[VAR_0 + 2];
            VAR_3 = (VAR_3 << 8) + VAR_4[VAR_0 + 3];
            return VAR_3;
        }",,"--- func_before
+++ func_after
@@ -1,8 +1,8 @@
-unsigned int GetU32BE (int nPos, bool *pbSuccess)
+unsigned int GetU32BE (const unsigned int& nPos, bool *pbSuccess)
         {
             //*pbSuccess = true;
 
-            if ( nPos < 0 || nPos + 3 >= m_nLen )
+            if ( m_nLen < 4 || nPos > (m_nLen - 4) )
             {
                 *pbSuccess = false;
                 return 0;","{'deleted_lines': ['unsigned int GetU32BE (int nPos, bool *pbSuccess)', '            if ( nPos < 0 || nPos + 3 >= m_nLen )'], 'added_lines': ['unsigned int GetU32BE (const unsigned int& nPos, bool *pbSuccess)', '            if ( m_nLen < 4 || nPos > (m_nLen - 4) )']}",True,Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below were discovered to contain a heap overflow via the component DesktopEditor/fontengine/fontconverter/FontFileBase.h.,9.8,CRITICAL,3,valid,2020-09-30T10:52:41Z,3
CVE-2022-29777,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ONLYOFFICE/core,"Fix 34, 35, 37",b17d5e860f30e8be2caeb0022b63be4c76660178,https://github.com/ONLYOFFICE/core/commit/b17d5e860f30e8be2caeb0022b63be4c76660178,DesktopEditor/fontengine/fontconverter/FontFileBase.h,GetS32BE,"int          GetS32BE (int nPos, bool *pbSuccess)
{
if ( nPos < 0 || nPos + 3 >= m_nLen )
{
*pbSuccess = false;
return 0;
}
int nRes = m_sFile[ nPos ];
nRes = (nRes << 8) + m_sFile[nPos + 1];
nRes = (nRes << 8) + m_sFile[nPos + 2];
nRes = (nRes << 8) + m_sFile[nPos + 3];
if ( nRes & 0x80000000 )
nRes |= ~0xffffffff;
return nRes;
}","int          GetS32BE (int VAR_0, bool *VAR_1)
{
if ( VAR_0 < 0 || VAR_0 + 3 >= VAR_2 )
{
*VAR_1 = false;
return 0;
}
int VAR_3 = VAR_4[ VAR_0 ];
VAR_3 = (VAR_3 << 8) + VAR_4[VAR_0 + 1];
VAR_3 = (VAR_3 << 8) + VAR_4[VAR_0 + 2];
VAR_3 = (VAR_3 << 8) + VAR_4[VAR_0 + 3];
if ( VAR_3 & 0x80000000 )
VAR_3 |= ~0xffffffff;
return VAR_3;
}",,"int          GetS32BE (const unsigned int& nPos, bool *pbSuccess)
        {
            //*pbSuccess = true;

            if ( m_nLen < 4 || nPos > (m_nLen - 4) )
            {
                *pbSuccess = false;
                return 0;
            }
            int nRes = m_sFile[ nPos ];
            nRes = (nRes << 8) + m_sFile[nPos + 1];
            nRes = (nRes << 8) + m_sFile[nPos + 2];
            nRes = (nRes << 8) + m_sFile[nPos + 3];
            if ( nRes & 0x80000000 )
                nRes |= ~0xffffffff;

            return nRes;
        }","int          GetS32BE (const unsigned int& VAR_0, bool *VAR_1)
        {
            /* COMMENT_0 */

            if ( VAR_2 < 4 || VAR_0 > (VAR_2 - 4) )
            {
                *VAR_1 = false;
                return 0;
            }
            int VAR_3 = VAR_4[ VAR_0 ];
            VAR_3 = (VAR_3 << 8) + VAR_4[VAR_0 + 1];
            VAR_3 = (VAR_3 << 8) + VAR_4[VAR_0 + 2];
            VAR_3 = (VAR_3 << 8) + VAR_4[VAR_0 + 3];
            if ( VAR_3 & 0x80000000 )
                VAR_3 |= ~0xffffffff;

            return VAR_3;
        }",,"--- func_before
+++ func_after
@@ -1,8 +1,8 @@
-int          GetS32BE (int nPos, bool *pbSuccess)
+int          GetS32BE (const unsigned int& nPos, bool *pbSuccess)
         {
             //*pbSuccess = true;
 
-            if ( nPos < 0 || nPos + 3 >= m_nLen )
+            if ( m_nLen < 4 || nPos > (m_nLen - 4) )
             {
                 *pbSuccess = false;
                 return 0;","{'deleted_lines': ['int          GetS32BE (int nPos, bool *pbSuccess)', '            if ( nPos < 0 || nPos + 3 >= m_nLen )'], 'added_lines': ['int          GetS32BE (const unsigned int& nPos, bool *pbSuccess)', '            if ( m_nLen < 4 || nPos > (m_nLen - 4) )']}",True,Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below were discovered to contain a heap overflow via the component DesktopEditor/fontengine/fontconverter/FontFileBase.h.,9.8,CRITICAL,3,valid,2020-09-30T10:52:41Z,3
CVE-2020-26894,['CWE-427'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,livecode,[[ Bug 22942 ]] Ensure the shellcommand defaults to COMSPEC on Windows,d8cb11f12c2e196d1d81c4036e60b6f5d74af0a4,https://github.com/livecode/livecode/commit/d8cb11f12c2e196d1d81c4036e60b6f5d74af0a4,engine/src/exec-files.cpp,MCFilesEvalShell,"void MCFilesEvalShell(MCExecContext& ctxt, MCStringRef p_command, MCStringRef& r_output)
{
if (MCsecuremode & MC_SECUREMODE_PROCESS)
{
MCeerror->add(EE_SHELL_NOPERM, 0, 0, p_command);
ctxt . Throw();
return;
}
if (MCS_runcmd(p_command, r_output) != IO_NORMAL)
{
MCeerror->add(EE_SHELL_BADCOMMAND, 0, 0, p_command);
ctxt . Throw();
return;
}
}","void MCFilesEvalShell(MCExecContext& VAR_0, MCStringRef VAR_1, MCStringRef& VAR_2)
{
if (VAR_3 & VAR_4)
{
VAR_5->add(VAR_6, 0, 0, VAR_1);
VAR_0 . Throw();
return;
}
if (MCS_runcmd(VAR_1, VAR_2) != VAR_7)
{
VAR_5->add(VAR_8, 0, 0, VAR_1);
VAR_0 . Throw();
return;
}
}",livecode/d8cb11f12c2e196d1d81c4036e60b6f5d74af0a4/exec-files.cpp/vul/before/0.json,"void MCFilesEvalShell(MCExecContext& ctxt, MCStringRef p_command, MCStringRef& r_output)
{
	if (MCsecuremode & MC_SECUREMODE_PROCESS)
	{
		MCeerror->add(EE_SHELL_NOPERM, 0, 0, p_command);
		ctxt . Throw();
		return;
	}

	if (MCStringIsEmpty(MCshellcmd))
	{
		MCeerror->add(EE_SHELL_BADCOMMAND, 0, 0, ""no shell"");
		ctxt . Throw();
		return;
	}

	if (MCS_runcmd(p_command, r_output) != IO_NORMAL)
	{
		MCeerror->add(EE_SHELL_BADCOMMAND, 0, 0, p_command);
		ctxt . Throw();
		return;
	}
}","void MCFilesEvalShell(MCExecContext& VAR_0, MCStringRef VAR_1, MCStringRef& VAR_2)
{
	if (VAR_3 & VAR_4)
	{
		VAR_5->add(VAR_6, 0, 0, VAR_1);
		VAR_0 . Throw();
		return;
	}

	if (MCStringIsEmpty(VAR_7))
	{
		VAR_5->add(VAR_8, 0, 0, ""no shell"");
		VAR_0 . Throw();
		return;
	}

	if (MCS_runcmd(VAR_1, VAR_2) != VAR_9)
	{
		VAR_5->add(VAR_8, 0, 0, VAR_1);
		VAR_0 . Throw();
		return;
	}
}",livecode/d8cb11f12c2e196d1d81c4036e60b6f5d74af0a4/exec-files.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,6 +3,13 @@
 	if (MCsecuremode & MC_SECUREMODE_PROCESS)
 	{
 		MCeerror->add(EE_SHELL_NOPERM, 0, 0, p_command);
+		ctxt . Throw();
+		return;
+	}
+
+	if (MCStringIsEmpty(MCshellcmd))
+	{
+		MCeerror->add(EE_SHELL_BADCOMMAND, 0, 0, ""no shell"");
 		ctxt . Throw();
 		return;
 	}","{'deleted_lines': [], 'added_lines': ['\t\tctxt . Throw();', '\t\treturn;', '\t}', '', '\tif (MCStringIsEmpty(MCshellcmd))', '\t{', '\t\tMCeerror->add(EE_SHELL_BADCOMMAND, 0, 0, ""no shell"");']}",True,"LiveCode v9.6.1 on Windows allows local, low-privileged users to gain privileges by creating a malicious ""cmd.exe"" in the folder of the vulnerable LiveCode application. If the application is using LiveCode's ""shell()"" function, it will attempt to search for ""cmd.exe"" in the folder of the current application and run the malicious ""cmd.exe"".",7.8,HIGH,2,valid,2020-10-16T12:06:25Z,3
CVE-2020-26894,['CWE-427'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,livecode,[[ Bug 22942 ]] Ensure the shellcommand defaults to COMSPEC on Windows,d8cb11f12c2e196d1d81c4036e60b6f5d74af0a4,https://github.com/livecode/livecode/commit/d8cb11f12c2e196d1d81c4036e60b6f5d74af0a4,engine/src/dskw32.cpp,Initialize,"virtual bool Initialize(void)
{
IO_stdin = MCsystem -> OpenFd(STD_INPUT_HANDLE, kMCOpenFileModeRead);
IO_stdout = MCsystem -> OpenFd(STD_OUTPUT_HANDLE, kMCOpenFileModeWrite);
IO_stderr = MCsystem -> OpenFd(STD_ERROR_HANDLE, kMCOpenFileModeWrite);
setlocale(LC_CTYPE, MCnullstring);
setlocale(LC_COLLATE, MCnullstring);
#ifdef _WINDOWS_SERVER
WORD request = MAKEWORD(1, 1);
WSADATA t_data;
WSAStartup(request, &t_data);
#endif 
((unsigned short *)_pctype)[160] &= ~_SPACE;
MCinfinity = HUGE_VAL;
MCS_time(); if (timeBeginPeriod(1) == TIMERR_NOERROR)
MCS_reset_time();
else
MClowrestimers = True;
MCExecContext ctxt(nil, nil, nil);
MCStringRef t_key;
t_key = MCSTR(""HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyEnable"");
MCAutoStringRef t_type, t_error;
MCAutoValueRef t_value;
MCS_query_registry(t_key, &t_value, &t_type, &t_error);
MCAutoNumberRef t_enabled;
if (*t_value != nil && ctxt.ConvertToNumber(*t_value, &t_enabled) && MCNumberFetchAsInteger(*t_enabled) == 1)
{
MCStringRef t_key2;
t_key2 = MCSTR(""HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyServer"");
MCAutoStringRef t_type2, t_error2;
MCAutoValueRef t_value2;
MCS_query_registry(t_key2, &t_value2, &t_type2, &t_error2);
if (*t_value2 != nil && !MCValueIsEmpty(*t_value2))
{
MCAutoStringRef t_http_proxy;
ctxt . ConvertToString(*t_value2, &t_http_proxy);
MCValueAssign(MChttpproxy, *t_http_proxy);
}
}
MCValueAssign(MCshellcmd, MCSTR(""cmd.exe""));
OSVERSIONINFOA osv;
memset(&osv, 0, sizeof(OSVERSIONINFOA));
osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
GetVersionExA(&osv);
MCmajorosversion = osv . dwMajorVersion << 8 | osv . dwMinorVersion;
if (MCmajorosversion >= 0x0500)
{
MCttsize = 11;
MCValueAssign(MCttfont, MCSTR(""Tahoma""));
}
else if (MCmajorosversion >= 0x0600)
{
MCttsize = 11;
MCValueAssign(MCttfont, MCSTR(""Segoe UI""));
}
OleInitialize(NULL); 
signal(SIGFPE, handle_fp_exception);
return true;
}","virtual bool Initialize(void)
{
VAR_0 = VAR_1 -> OpenFd(VAR_2, VAR_3);
VAR_4 = VAR_1 -> OpenFd(VAR_5, VAR_6);
VAR_7 = VAR_1 -> OpenFd(VAR_8, VAR_6);
setlocale(VAR_9, VAR_10);
setlocale(VAR_11, VAR_10);
#ifdef VAR_12
WORD VAR_13 = MAKEWORD(1, 1);
WSADATA VAR_14;
WSAStartup(VAR_13, &VAR_14);
#endif 
((unsigned short *)VAR_15)[160] &= ~VAR_16;
VAR_17 = VAR_18;
MCS_time(); 
if (timeBeginPeriod(1) == VAR_19)
MCS_reset_time();
else
VAR_20 = VAR_21;
MCExecContext ctxt(nil, nil, nil);
MCStringRef VAR_22;
VAR_22 = MCSTR(""HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyEnable"");
MCAutoStringRef VAR_23, VAR_24;
MCAutoValueRef VAR_25;
MCS_query_registry(VAR_22, &VAR_25, &VAR_23, &VAR_24);
MCAutoNumberRef VAR_26;
if (*VAR_25 != nil && VAR_27.ConvertToNumber(*VAR_25, &VAR_26) && MCNumberFetchAsInteger(*VAR_26) == 1)
{
MCStringRef VAR_28;
VAR_28 = MCSTR(""HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyServer"");
MCAutoStringRef VAR_29, VAR_30;
MCAutoValueRef VAR_31;
MCS_query_registry(VAR_28, &VAR_31, &VAR_29, &VAR_30);
if (*VAR_31 != nil && !MCValueIsEmpty(*VAR_31))
{
MCAutoStringRef VAR_32;
VAR_27 . ConvertToString(*VAR_31, &VAR_32);
MCValueAssign(VAR_33, *VAR_32);
}
}
MCValueAssign(VAR_34, MCSTR(""cmd.exe""));
OSVERSIONINFOA VAR_35;
memset(&VAR_35, 0, sizeof(OSVERSIONINFOA));
VAR_35.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
GetVersionExA(&VAR_35);
VAR_36 = VAR_35 . dwMajorVersion << 8 | VAR_35 . dwMinorVersion;
if (VAR_36 >= 0x0500)
{
VAR_37 = 11;
MCValueAssign(VAR_38, MCSTR(""Tahoma""));
}
else if (VAR_36 >= 0x0600)
{
VAR_37 = 11;
MCValueAssign(VAR_38, MCSTR(""Segoe UI""));
}
OleInitialize(NULL); 
signal(VAR_39, VAR_40);
return true;
}",livecode/d8cb11f12c2e196d1d81c4036e60b6f5d74af0a4/dskw32.cpp/vul/before/0.json,"virtual bool Initialize(void)
	{
		IO_stdin = MCsystem -> OpenFd(STD_INPUT_HANDLE, kMCOpenFileModeRead);
		IO_stdout = MCsystem -> OpenFd(STD_OUTPUT_HANDLE, kMCOpenFileModeWrite);
		IO_stderr = MCsystem -> OpenFd(STD_ERROR_HANDLE, kMCOpenFileModeWrite);

		setlocale(LC_CTYPE, MCnullstring);
		setlocale(LC_COLLATE, MCnullstring);

#ifdef _WINDOWS_SERVER
		WORD request = MAKEWORD(1, 1);
		WSADATA t_data;
		WSAStartup(request, &t_data);
#endif // _WINDOWS_SERVER

		// MW-2004-11-28: The ctype array seems to have changed in the latest version of VC++
		((unsigned short *)_pctype)[160] &= ~_SPACE;

		MCinfinity = HUGE_VAL;
		MCS_time(); // force init
		if (timeBeginPeriod(1) == TIMERR_NOERROR)
			MCS_reset_time();
		else
			MClowrestimers = True;

        MCExecContext ctxt(nil, nil, nil);
		MCStringRef t_key;
		t_key = MCSTR(""HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyEnable"");
        MCAutoStringRef t_type, t_error;
        MCAutoValueRef t_value;
        MCS_query_registry(t_key, &t_value, &t_type, &t_error);
        
        MCAutoNumberRef t_enabled;
        if (*t_value != nil && ctxt.ConvertToNumber(*t_value, &t_enabled) && MCNumberFetchAsInteger(*t_enabled) == 1)
		{
            MCStringRef t_key2;
            t_key2 = MCSTR(""HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyServer"");
            MCAutoStringRef t_type2, t_error2;
            MCAutoValueRef t_value2;

			MCS_query_registry(t_key2, &t_value2, &t_type2, &t_error2);

			if (*t_value2 != nil && !MCValueIsEmpty(*t_value2))
			{
				MCAutoStringRef t_http_proxy;
				/* UNCHECKED */ ctxt . ConvertToString(*t_value2, &t_http_proxy);
				MCValueAssign(MChttpproxy, *t_http_proxy);
			}
		}

		/* Default the shellCommand to the value of the COMSPEC environment
		 * variable. */
		MCAutoStringRef t_comspec;
		if (MCS_getenv(MCSTR(""COMSPEC""), &t_comspec))
		{
			MCValueAssign(MCshellcmd, *t_comspec);
		}
		else
		{
			MCValueAssign(MCshellcmd, kMCEmptyString);
		}

		// MW-2005-05-26: Store a global variable containing major OS version...
		OSVERSIONINFOA osv;
		memset(&osv, 0, sizeof(OSVERSIONINFOA));
		osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
		GetVersionExA(&osv);
		MCmajorosversion = osv . dwMajorVersion << 8 | osv . dwMinorVersion;

		// MW-2012-09-19: [[ Bug ]] Adjustment to tooltip metrics for Windows.
		if (MCmajorosversion >= 0x0500)
		{
			MCttsize = 11;
			MCValueAssign(MCttfont, MCSTR(""Tahoma""));
		}
		else if (MCmajorosversion >= 0x0600)
		{
			MCttsize = 11;
			MCValueAssign(MCttfont, MCSTR(""Segoe UI""));
		}

		OleInitialize(NULL); //for drag & drop

		// MW-2004-11-28: Install a signal handler for FP exceptions - these should be masked
		//   so it *should* be unnecessary but Win9x plays with the FP control word.
		signal(SIGFPE, handle_fp_exception);

		return true;
	}","virtual bool Initialize(void)
	{
		VAR_0 = VAR_1 -> OpenFd(VAR_2, VAR_3);
		VAR_4 = VAR_1 -> OpenFd(VAR_5, VAR_6);
		VAR_7 = VAR_1 -> OpenFd(VAR_8, VAR_6);

		setlocale(VAR_9, VAR_10);
		setlocale(VAR_11, VAR_10);

#ifdef VAR_12
		WORD VAR_13 = MAKEWORD(1, 1);
		WSADATA VAR_14;
		WSAStartup(VAR_13, &VAR_14);
#endif /* COMMENT_0 */

		/* COMMENT_1 */
		((unsigned short *)VAR_15)[160] &= ~VAR_16;

		VAR_17 = VAR_18;
		MCS_time(); /* COMMENT_2 */
		if (timeBeginPeriod(1) == VAR_19)
			MCS_reset_time();
		else
			VAR_20 = VAR_21;

        MCExecContext ctxt(nil, nil, nil);
		MCStringRef VAR_22;
		VAR_22 = MCSTR(""HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyEnable"");
        MCAutoStringRef VAR_23, VAR_24;
        MCAutoValueRef VAR_25;
        MCS_query_registry(VAR_22, &VAR_25, &VAR_23, &VAR_24);
        
        MCAutoNumberRef VAR_26;
        if (*VAR_25 != nil && VAR_27.ConvertToNumber(*VAR_25, &VAR_26) && MCNumberFetchAsInteger(*VAR_26) == 1)
		{
            MCStringRef VAR_28;
            VAR_28 = MCSTR(""HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyServer"");
            MCAutoStringRef VAR_29, VAR_30;
            MCAutoValueRef VAR_31;

			MCS_query_registry(VAR_28, &VAR_31, &VAR_29, &VAR_30);

			if (*VAR_31 != nil && !MCValueIsEmpty(*VAR_31))
			{
				MCAutoStringRef VAR_32;
				/* COMMENT_3 */ VAR_27 . ConvertToString(*VAR_31, &VAR_32);
				MCValueAssign(VAR_33, *VAR_32);
			}
		}

		/* COMMENT_4 */
                 
		MCAutoStringRef VAR_34;
		if (MCS_getenv(MCSTR(""COMSPEC""), &VAR_34))
		{
			MCValueAssign(VAR_35, *VAR_34);
		}
		else
		{
			MCValueAssign(VAR_35, VAR_36);
		}

		/* COMMENT_6 */
		OSVERSIONINFOA VAR_37;
		memset(&VAR_37, 0, sizeof(OSVERSIONINFOA));
		VAR_37.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
		GetVersionExA(&VAR_37);
		VAR_38 = VAR_37 . dwMajorVersion << 8 | VAR_37 . dwMinorVersion;

		/* COMMENT_7 */
		if (VAR_38 >= 0x0500)
		{
			VAR_39 = 11;
			MCValueAssign(VAR_40, MCSTR(""Tahoma""));
		}
		else if (VAR_38 >= 0x0600)
		{
			VAR_39 = 11;
			MCValueAssign(VAR_40, MCSTR(""Segoe UI""));
		}

		OleInitialize(NULL); /* COMMENT_8 */

		/* COMMENT_9 */
		/* COMMENT_10 */
		signal(VAR_41, VAR_42);

		return true;
	}",livecode/d8cb11f12c2e196d1d81c4036e60b6f5d74af0a4/dskw32.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -48,8 +48,17 @@
 			}
 		}
 
-		// On NT systems 'cmd.exe' is the command processor
-		MCValueAssign(MCshellcmd, MCSTR(""cmd.exe""));
+		/* Default the shellCommand to the value of the COMSPEC environment
+		 * variable. */
+		MCAutoStringRef t_comspec;
+		if (MCS_getenv(MCSTR(""COMSPEC""), &t_comspec))
+		{
+			MCValueAssign(MCshellcmd, *t_comspec);
+		}
+		else
+		{
+			MCValueAssign(MCshellcmd, kMCEmptyString);
+		}
 
 		// MW-2005-05-26: Store a global variable containing major OS version...
 		OSVERSIONINFOA osv;","{'deleted_lines': [""\t\t// On NT systems 'cmd.exe' is the command processor"", '\t\tMCValueAssign(MCshellcmd, MCSTR(""cmd.exe""));'], 'added_lines': ['\t\t/* Default the shellCommand to the value of the COMSPEC environment', '\t\t * variable. */', '\t\tMCAutoStringRef t_comspec;', '\t\tif (MCS_getenv(MCSTR(""COMSPEC""), &t_comspec))', '\t\t{', '\t\t\tMCValueAssign(MCshellcmd, *t_comspec);', '\t\t}', '\t\telse', '\t\t{', '\t\t\tMCValueAssign(MCshellcmd, kMCEmptyString);', '\t\t}']}",True,"LiveCode v9.6.1 on Windows allows local, low-privileged users to gain privileges by creating a malicious ""cmd.exe"" in the folder of the vulnerable LiveCode application. If the application is using LiveCode's ""shell()"" function, it will attempt to search for ""cmd.exe"" in the folder of the current application and run the malicious ""cmd.exe"".",7.8,HIGH,2,valid,2020-10-16T12:06:25Z,3
CVE-2021-21257,['CWE-787'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,contiki-ng,Validate the calculated address pointer based on the source routing header.,99a9257421ca5305ef6a360c02f63561e63ecc60,https://github.com/contiki-ng/contiki-ng/commit/99a9257421ca5305ef6a360c02f63561e63ecc60,os/net/routing/rpl-classic/rpl-ext-header.c,rpl_ext_header_srh_update,"int
rpl_ext_header_srh_update(void)
{
#if RPL_WITH_NON_STORING
struct uip_routing_hdr *rh_header;
struct uip_rpl_srh_hdr *srh_header;
rh_header = (struct uip_routing_hdr *)uipbuf_search_header(uip_buf, uip_len, UIP_PROTO_ROUTING);
if(rh_header != NULL && rh_header->routing_type == RPL_RH_TYPE_SRH) {
uint8_t cmpri, cmpre;
uint8_t ext_len;
uint8_t padding;
uint8_t path_len;
uint8_t segments_left;
uip_ipaddr_t current_dest_addr;
srh_header = (struct uip_rpl_srh_hdr *)(((uint8_t *)rh_header) + RPL_RH_LEN);
segments_left = rh_header->seg_left;
ext_len = rh_header->len * 8 + 8;
cmpri = srh_header->cmpr >> 4;
cmpre = srh_header->cmpr & 0x0f;
padding = srh_header->pad >> 4;
path_len = ((ext_len - padding - RPL_RH_LEN - RPL_SRH_LEN - (16 - cmpre)) / (16 - cmpri)) + 1;
(void)path_len;
LOG_DBG(""read SRH, path len %u, segments left %u, Cmpri %u, Cmpre %u, ext len %u (padding %u)\n"",
path_len, segments_left, cmpri, cmpre, ext_len, padding);
if(segments_left == 0) {
} else if(segments_left > path_len) {
LOG_ERR(""SRH with too many segments left (%u > %u)\n"",
segments_left, path_len);
return 0;
} else {
uint8_t i = path_len - segments_left; 
uint8_t *addr_ptr = ((uint8_t *)rh_header) + RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));
uint8_t cmpr = segments_left == 1 ? cmpre : cmpri;
uip_ipaddr_copy(&current_dest_addr, &UIP_IP_BUF->destipaddr);
memcpy(((uint8_t *)&UIP_IP_BUF->destipaddr) + cmpr, addr_ptr, 16 - cmpr);
memcpy(addr_ptr, ((uint8_t *)&current_dest_addr) + cmpr, 16 - cmpr);
rh_header->seg_left--;
LOG_INFO(""SRH next hop "");
LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);
LOG_INFO_(""\n"");
}
return 1;
}
return 0;
#else 
return 0; 
#endif 
}","int
rpl_ext_header_srh_update(void)
{
#if VAR_0
struct uip_routing_hdr *VAR_1;
struct uip_rpl_srh_hdr *VAR_2;
VAR_1 = (struct uip_routing_hdr *)uipbuf_search_header(VAR_3, VAR_4, VAR_5);
if(VAR_1 != NULL && VAR_1->routing_type == VAR_6) {
uint8_t VAR_7, VAR_8;
uint8_t VAR_9;
uint8_t VAR_10;
uint8_t VAR_11;
uint8_t VAR_12;
uip_ipaddr_t VAR_13;
VAR_2 = (struct uip_rpl_srh_hdr *)(((uint8_t *)VAR_1) + VAR_14);
VAR_12 = VAR_1->seg_left;
VAR_9 = VAR_1->len * 8 + 8;
VAR_7 = VAR_2->cmpr >> 4;
VAR_8 = VAR_2->cmpr & 0x0f;
VAR_10 = VAR_2->pad >> 4;
VAR_11 = ((VAR_9 - VAR_10 - VAR_14 - VAR_15 - (16 - VAR_8)) / (16 - VAR_7)) + 1;
(void)VAR_11;
LOG_DBG(""read SRH, path len %u, segments left %u, Cmpri %u, Cmpre %u, ext len %u (padding %u)\n"",
VAR_11, VAR_12, VAR_7, VAR_8, VAR_9, VAR_10);
if(VAR_12 == 0) {
} else if(VAR_12 > VAR_11) {
LOG_ERR(""SRH with too many segments left (%u > %u)\n"",
VAR_12, VAR_11);
return 0;
} else {
uint8_t VAR_16 = VAR_11 - VAR_12; 
uint8_t *VAR_17 = ((uint8_t *)VAR_1) + VAR_14 + VAR_15 + (VAR_16 * (16 - VAR_7));
uint8_t VAR_18 = VAR_12 == 1 ? VAR_8 : VAR_7;
uip_ipaddr_copy(&VAR_13, &VAR_19->destipaddr);
memcpy(((uint8_t *)&VAR_19->destipaddr) + VAR_18, VAR_17, 16 - VAR_18);
memcpy(VAR_17, ((uint8_t *)&VAR_13) + VAR_18, 16 - VAR_18);
VAR_1->seg_left--;
LOG_INFO(""SRH next hop "");
LOG_INFO_6ADDR(&VAR_19->destipaddr);
LOG_INFO_(""\n"");
}
return 1;
}
return 0;
#else 
return 0; 
#endif 
}",contiki-ng/99a9257421ca5305ef6a360c02f63561e63ecc60/rpl-ext-header.c/vul/before/0.json,"int
rpl_ext_header_srh_update(void)
{
#if RPL_WITH_NON_STORING
  struct uip_routing_hdr *rh_header;
  struct uip_rpl_srh_hdr *srh_header;

  /* Look for routing ext header */
  rh_header = (struct uip_routing_hdr *)uipbuf_search_header(uip_buf, uip_len, UIP_PROTO_ROUTING);

  if(rh_header != NULL && rh_header->routing_type == RPL_RH_TYPE_SRH) {
    /* SRH found, now look for next hop */
    uint8_t cmpri, cmpre;
    uint8_t ext_len;
    uint8_t padding;
    uint8_t path_len;
    uint8_t segments_left;
    uip_ipaddr_t current_dest_addr;

    srh_header = (struct uip_rpl_srh_hdr *)(((uint8_t *)rh_header) + RPL_RH_LEN);
    segments_left = rh_header->seg_left;
    ext_len = rh_header->len * 8 + 8;
    cmpri = srh_header->cmpr >> 4;
    cmpre = srh_header->cmpr & 0x0f;
    padding = srh_header->pad >> 4;
    path_len = ((ext_len - padding - RPL_RH_LEN - RPL_SRH_LEN - (16 - cmpre)) / (16 - cmpri)) + 1;
    (void)path_len;

    LOG_DBG(""read SRH, path len %u, segments left %u, Cmpri %u, Cmpre %u, ext len %u (padding %u)\n"",
        path_len, segments_left, cmpri, cmpre, ext_len, padding);

    if(segments_left == 0) {
      /* We are the final destination, do nothing */
    } else if(segments_left > path_len) {
      /* Discard the packet because of a parameter problem. */
      LOG_ERR(""SRH with too many segments left (%u > %u)\n"",
              segments_left, path_len);
      return 0;
    } else {
      uint8_t i = path_len - segments_left; /* The index of the next address to be visited */
      uint8_t cmpr = segments_left == 1 ? cmpre : cmpri;
      ptrdiff_t rh_offset = (uint8_t *)rh_header - uip_buf;
      size_t addr_offset = RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));

      if(rh_offset + addr_offset + 16 - cmpr > UIP_BUFSIZE) {
        LOG_ERR(""Invalid SRH address pointer\n"");
        return 0;
      }

      uint8_t *addr_ptr = ((uint8_t *)rh_header) + addr_offset;

      /* As per RFC6554: swap the IPv6 destination address and address[i] */

      /* First, copy the current IPv6 destination address */
      uip_ipaddr_copy(&current_dest_addr, &UIP_IP_BUF->destipaddr);
      /* Second, update the IPv6 destination address with addresses[i] */
      memcpy(((uint8_t *)&UIP_IP_BUF->destipaddr) + cmpr, addr_ptr, 16 - cmpr);
      /* Third, write current_dest_addr to addresses[i] */
      memcpy(addr_ptr, ((uint8_t *)&current_dest_addr) + cmpr, 16 - cmpr);

      /* Update segments left field */
      rh_header->seg_left--;

      LOG_INFO(""SRH next hop "");
      LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);
      LOG_INFO_(""\n"");
    }
    return 1;
  }

  return 0;
#else /* RPL_WITH_NON_STORING */
  return 0; /* SRH not found */
#endif /* RPL_WITH_NON_STORING */
}","int
rpl_ext_header_srh_update(void)
{
#if VAR_0
  struct uip_routing_hdr *VAR_1;
  struct uip_rpl_srh_hdr *VAR_2;

  /* COMMENT_0 */
  VAR_1 = (struct uip_routing_hdr *)uipbuf_search_header(VAR_3, VAR_4, VAR_5);

  if(VAR_1 != NULL && VAR_1->routing_type == VAR_6) {
    /* COMMENT_1 */
    uint8_t VAR_7, VAR_8;
    uint8_t VAR_9;
    uint8_t VAR_10;
    uint8_t VAR_11;
    uint8_t VAR_12;
    uip_ipaddr_t VAR_13;

    VAR_2 = (struct uip_rpl_srh_hdr *)(((uint8_t *)VAR_1) + VAR_14);
    VAR_12 = VAR_1->seg_left;
    VAR_9 = VAR_1->len * 8 + 8;
    VAR_7 = VAR_2->cmpr >> 4;
    VAR_8 = VAR_2->cmpr & 0x0f;
    VAR_10 = VAR_2->pad >> 4;
    VAR_11 = ((VAR_9 - VAR_10 - VAR_14 - VAR_15 - (16 - VAR_8)) / (16 - VAR_7)) + 1;
    (void)VAR_11;

    LOG_DBG(""read SRH, path len %u, segments left %u, Cmpri %u, Cmpre %u, ext len %u (padding %u)\n"",
        VAR_11, VAR_12, VAR_7, VAR_8, VAR_9, VAR_10);

    if(VAR_12 == 0) {
      /* COMMENT_2 */
    } else if(VAR_12 > VAR_11) {
      /* COMMENT_3 */
      LOG_ERR(""SRH with too many segments left (%u > %u)\n"",
              VAR_12, VAR_11);
      return 0;
    } else {
      uint8_t VAR_16 = VAR_11 - VAR_12; /* COMMENT_4 */
      uint8_t VAR_17 = VAR_12 == 1 ? VAR_8 : VAR_7;
      ptrdiff_t VAR_18 = (uint8_t *)VAR_1 - VAR_3;
      size_t VAR_19 = VAR_14 + VAR_15 + (VAR_16 * (16 - VAR_7));

      if(VAR_18 + VAR_19 + 16 - VAR_17 > VAR_20) {
        LOG_ERR(""Invalid SRH address pointer\n"");
        return 0;
      }

      uint8_t *VAR_21 = ((uint8_t *)VAR_1) + VAR_19;

      /* COMMENT_5 */

      /* COMMENT_6 */
      uip_ipaddr_copy(&VAR_13, &VAR_22->destipaddr);
      /* COMMENT_7 */
      memcpy(((uint8_t *)&VAR_22->destipaddr) + VAR_17, VAR_21, 16 - VAR_17);
      /* COMMENT_8 */
      memcpy(VAR_21, ((uint8_t *)&VAR_13) + VAR_17, 16 - VAR_17);

      /* COMMENT_9 */
      VAR_1->seg_left--;

      LOG_INFO(""SRH next hop "");
      LOG_INFO_6ADDR(&VAR_22->destipaddr);
      LOG_INFO_(""\n"");
    }
    return 1;
  }

  return 0;
#else /* COMMENT_10 */
  return 0; /* COMMENT_11 */
#endif /* COMMENT_10 */
}",contiki-ng/99a9257421ca5305ef6a360c02f63561e63ecc60/rpl-ext-header.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -38,8 +38,16 @@
       return 0;
     } else {
       uint8_t i = path_len - segments_left; /* The index of the next address to be visited */
-      uint8_t *addr_ptr = ((uint8_t *)rh_header) + RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));
       uint8_t cmpr = segments_left == 1 ? cmpre : cmpri;
+      ptrdiff_t rh_offset = (uint8_t *)rh_header - uip_buf;
+      size_t addr_offset = RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));
+
+      if(rh_offset + addr_offset + 16 - cmpr > UIP_BUFSIZE) {
+        LOG_ERR(""Invalid SRH address pointer\n"");
+        return 0;
+      }
+
+      uint8_t *addr_ptr = ((uint8_t *)rh_header) + addr_offset;
 
       /* As per RFC6554: swap the IPv6 destination address and address[i] */
 ","{'deleted_lines': ['      uint8_t *addr_ptr = ((uint8_t *)rh_header) + RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));'], 'added_lines': ['      ptrdiff_t rh_offset = (uint8_t *)rh_header - uip_buf;', '      size_t addr_offset = RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));', '', '      if(rh_offset + addr_offset + 16 - cmpr > UIP_BUFSIZE) {', '        LOG_ERR(""Invalid SRH address pointer\\n"");', '        return 0;', '      }', '', '      uint8_t *addr_ptr = ((uint8_t *)rh_header) + addr_offset;']}",True,"Contiki-NG is an open-source, cross-platform operating system for internet of things devices. The RPL-Classic and RPL-Lite implementations in the Contiki-NG operating system versions prior to 4.6 do not validate the address pointer in the RPL source routing header This makes it possible for an attacker to cause out-of-bounds writes with packets injected into the network stack. Specifically, the problem lies in the rpl_ext_header_srh_update function in the two rpl-ext-header.c modules for RPL-Classic and RPL-Lite respectively. The addr_ptr variable is calculated using an unvalidated CMPR field value from the source routing header. An out-of-bounds write can be triggered on line 151 in os/net/routing/rpl-lite/rpl-ext-header.c and line 261 in os/net/routing/rpl-classic/rpl-ext-header.c, which contain the following memcpy call with addr_ptr as destination. The problem has been patched in Contiki-NG 4.6. Users can apply a patch out-of-band as a workaround.",8.2,HIGH,2,valid,2020-10-19T13:48:34Z,3
CVE-2021-21257,['CWE-787'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,contiki-ng,Validate the calculated address pointer based on the source routing header.,99a9257421ca5305ef6a360c02f63561e63ecc60,https://github.com/contiki-ng/contiki-ng/commit/99a9257421ca5305ef6a360c02f63561e63ecc60,os/net/routing/rpl-lite/rpl-ext-header.c,rpl_ext_header_srh_update,"int
rpl_ext_header_srh_update(void)
{
#if RPL_WITH_NON_STORING
struct uip_routing_hdr *rh_header;
struct uip_rpl_srh_hdr *srh_header;
rh_header = (struct uip_routing_hdr *)uipbuf_search_header(uip_buf, uip_len, UIP_PROTO_ROUTING);
if(rh_header != NULL && rh_header->routing_type == RPL_RH_TYPE_SRH) {
uint8_t cmpri, cmpre;
uint8_t ext_len;
uint8_t padding;
uint8_t path_len;
uint8_t segments_left;
uip_ipaddr_t current_dest_addr;
srh_header = (struct uip_rpl_srh_hdr *)(((uint8_t *)rh_header) + RPL_RH_LEN);
segments_left = rh_header->seg_left;
ext_len = rh_header->len * 8 + 8;
cmpri = srh_header->cmpr >> 4;
cmpre = srh_header->cmpr & 0x0f;
padding = srh_header->pad >> 4;
path_len = ((ext_len - padding - RPL_RH_LEN - RPL_SRH_LEN - (16 - cmpre)) / (16 - cmpri)) + 1;
(void)path_len;
LOG_DBG(""read SRH, path len %u, segments left %u, Cmpri %u, Cmpre %u, ext len %u (padding %u)\n"",
path_len, segments_left, cmpri, cmpre, ext_len, padding);
if(segments_left == 0) {
} else if(segments_left > path_len) {
LOG_ERR(""SRH with too many segments left (%u > %u)\n"",
segments_left, path_len);
return 0;
} else {
uint8_t i = path_len - segments_left; 
uint8_t *addr_ptr = ((uint8_t *)rh_header) + RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));
uint8_t cmpr = segments_left == 1 ? cmpre : cmpri;
uip_ipaddr_copy(&current_dest_addr, &UIP_IP_BUF->destipaddr);
memcpy(((uint8_t *)&UIP_IP_BUF->destipaddr) + cmpr, addr_ptr, 16 - cmpr);
memcpy(addr_ptr, ((uint8_t *)&current_dest_addr) + cmpr, 16 - cmpr);
rh_header->seg_left--;
LOG_INFO(""SRH next hop "");
LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);
LOG_INFO_(""\n"");
}
return 1;
}
return 0;
#else 
return 0; 
#endif 
}","int
rpl_ext_header_srh_update(void)
{
#if VAR_0
struct uip_routing_hdr *VAR_1;
struct uip_rpl_srh_hdr *VAR_2;
VAR_1 = (struct uip_routing_hdr *)uipbuf_search_header(VAR_3, VAR_4, VAR_5);
if(VAR_1 != NULL && VAR_1->routing_type == VAR_6) {
uint8_t VAR_7, VAR_8;
uint8_t VAR_9;
uint8_t VAR_10;
uint8_t VAR_11;
uint8_t VAR_12;
uip_ipaddr_t VAR_13;
VAR_2 = (struct uip_rpl_srh_hdr *)(((uint8_t *)VAR_1) + VAR_14);
VAR_12 = VAR_1->seg_left;
VAR_9 = VAR_1->len * 8 + 8;
VAR_7 = VAR_2->cmpr >> 4;
VAR_8 = VAR_2->cmpr & 0x0f;
VAR_10 = VAR_2->pad >> 4;
VAR_11 = ((VAR_9 - VAR_10 - VAR_14 - VAR_15 - (16 - VAR_8)) / (16 - VAR_7)) + 1;
(void)VAR_11;
LOG_DBG(""read SRH, path len %u, segments left %u, Cmpri %u, Cmpre %u, ext len %u (padding %u)\n"",
VAR_11, VAR_12, VAR_7, VAR_8, VAR_9, VAR_10);
if(VAR_12 == 0) {
} else if(VAR_12 > VAR_11) {
LOG_ERR(""SRH with too many segments left (%u > %u)\n"",
VAR_12, VAR_11);
return 0;
} else {
uint8_t VAR_16 = VAR_11 - VAR_12; 
uint8_t *VAR_17 = ((uint8_t *)VAR_1) + VAR_14 + VAR_15 + (VAR_16 * (16 - VAR_7));
uint8_t VAR_18 = VAR_12 == 1 ? VAR_8 : VAR_7;
uip_ipaddr_copy(&VAR_13, &VAR_19->destipaddr);
memcpy(((uint8_t *)&VAR_19->destipaddr) + VAR_18, VAR_17, 16 - VAR_18);
memcpy(VAR_17, ((uint8_t *)&VAR_13) + VAR_18, 16 - VAR_18);
VAR_1->seg_left--;
LOG_INFO(""SRH next hop "");
LOG_INFO_6ADDR(&VAR_19->destipaddr);
LOG_INFO_(""\n"");
}
return 1;
}
return 0;
#else 
return 0; 
#endif 
}",contiki-ng/99a9257421ca5305ef6a360c02f63561e63ecc60/rpl-ext-header.c/vul/before/0.json,"int
rpl_ext_header_srh_update(void)
{
#if RPL_WITH_NON_STORING
  struct uip_routing_hdr *rh_header;
  struct uip_rpl_srh_hdr *srh_header;

  /* Look for routing ext header */
  rh_header = (struct uip_routing_hdr *)uipbuf_search_header(uip_buf, uip_len, UIP_PROTO_ROUTING);

  if(rh_header != NULL && rh_header->routing_type == RPL_RH_TYPE_SRH) {
    /* SRH found, now look for next hop */
    uint8_t cmpri, cmpre;
    uint8_t ext_len;
    uint8_t padding;
    uint8_t path_len;
    uint8_t segments_left;
    uip_ipaddr_t current_dest_addr;

    srh_header = (struct uip_rpl_srh_hdr *)(((uint8_t *)rh_header) + RPL_RH_LEN);
    segments_left = rh_header->seg_left;
    ext_len = rh_header->len * 8 + 8;
    cmpri = srh_header->cmpr >> 4;
    cmpre = srh_header->cmpr & 0x0f;
    padding = srh_header->pad >> 4;
    path_len = ((ext_len - padding - RPL_RH_LEN - RPL_SRH_LEN - (16 - cmpre)) / (16 - cmpri)) + 1;
    (void)path_len;

    LOG_DBG(""read SRH, path len %u, segments left %u, Cmpri %u, Cmpre %u, ext len %u (padding %u)\n"",
        path_len, segments_left, cmpri, cmpre, ext_len, padding);

    if(segments_left == 0) {
      /* We are the final destination, do nothing */
    } else if(segments_left > path_len) {
      /* Discard the packet because of a parameter problem. */
      LOG_ERR(""SRH with too many segments left (%u > %u)\n"",
              segments_left, path_len);
      return 0;
    } else {
      uint8_t i = path_len - segments_left; /* The index of the next address to be visited */
      uint8_t cmpr = segments_left == 1 ? cmpre : cmpri;
      ptrdiff_t rh_offset = (uint8_t *)rh_header - uip_buf;
      size_t addr_offset = RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));

      if(rh_offset + addr_offset + 16 - cmpr > UIP_BUFSIZE) {
        LOG_ERR(""Invalid SRH address pointer\n"");
        return 0;
      }

      uint8_t *addr_ptr = ((uint8_t *)rh_header) + addr_offset;

      /* As per RFC6554: swap the IPv6 destination address and address[i] */

      /* First, copy the current IPv6 destination address */
      uip_ipaddr_copy(&current_dest_addr, &UIP_IP_BUF->destipaddr);
      /* Second, update the IPv6 destination address with addresses[i] */
      memcpy(((uint8_t *)&UIP_IP_BUF->destipaddr) + cmpr, addr_ptr, 16 - cmpr);
      /* Third, write current_dest_addr to addresses[i] */
      memcpy(addr_ptr, ((uint8_t *)&current_dest_addr) + cmpr, 16 - cmpr);

      /* Update segments left field */
      rh_header->seg_left--;

      LOG_INFO(""SRH next hop "");
      LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);
      LOG_INFO_(""\n"");
    }
    return 1;
  }

  return 0;
#else /* RPL_WITH_NON_STORING */
  return 0; /* SRH not found */
#endif /* RPL_WITH_NON_STORING */
}","int
rpl_ext_header_srh_update(void)
{
#if VAR_0
  struct uip_routing_hdr *VAR_1;
  struct uip_rpl_srh_hdr *VAR_2;

  /* COMMENT_0 */
  VAR_1 = (struct uip_routing_hdr *)uipbuf_search_header(VAR_3, VAR_4, VAR_5);

  if(VAR_1 != NULL && VAR_1->routing_type == VAR_6) {
    /* COMMENT_1 */
    uint8_t VAR_7, VAR_8;
    uint8_t VAR_9;
    uint8_t VAR_10;
    uint8_t VAR_11;
    uint8_t VAR_12;
    uip_ipaddr_t VAR_13;

    VAR_2 = (struct uip_rpl_srh_hdr *)(((uint8_t *)VAR_1) + VAR_14);
    VAR_12 = VAR_1->seg_left;
    VAR_9 = VAR_1->len * 8 + 8;
    VAR_7 = VAR_2->cmpr >> 4;
    VAR_8 = VAR_2->cmpr & 0x0f;
    VAR_10 = VAR_2->pad >> 4;
    VAR_11 = ((VAR_9 - VAR_10 - VAR_14 - VAR_15 - (16 - VAR_8)) / (16 - VAR_7)) + 1;
    (void)VAR_11;

    LOG_DBG(""read SRH, path len %u, segments left %u, Cmpri %u, Cmpre %u, ext len %u (padding %u)\n"",
        VAR_11, VAR_12, VAR_7, VAR_8, VAR_9, VAR_10);

    if(VAR_12 == 0) {
      /* COMMENT_2 */
    } else if(VAR_12 > VAR_11) {
      /* COMMENT_3 */
      LOG_ERR(""SRH with too many segments left (%u > %u)\n"",
              VAR_12, VAR_11);
      return 0;
    } else {
      uint8_t VAR_16 = VAR_11 - VAR_12; /* COMMENT_4 */
      uint8_t VAR_17 = VAR_12 == 1 ? VAR_8 : VAR_7;
      ptrdiff_t VAR_18 = (uint8_t *)VAR_1 - VAR_3;
      size_t VAR_19 = VAR_14 + VAR_15 + (VAR_16 * (16 - VAR_7));

      if(VAR_18 + VAR_19 + 16 - VAR_17 > VAR_20) {
        LOG_ERR(""Invalid SRH address pointer\n"");
        return 0;
      }

      uint8_t *VAR_21 = ((uint8_t *)VAR_1) + VAR_19;

      /* COMMENT_5 */

      /* COMMENT_6 */
      uip_ipaddr_copy(&VAR_13, &VAR_22->destipaddr);
      /* COMMENT_7 */
      memcpy(((uint8_t *)&VAR_22->destipaddr) + VAR_17, VAR_21, 16 - VAR_17);
      /* COMMENT_8 */
      memcpy(VAR_21, ((uint8_t *)&VAR_13) + VAR_17, 16 - VAR_17);

      /* COMMENT_9 */
      VAR_1->seg_left--;

      LOG_INFO(""SRH next hop "");
      LOG_INFO_6ADDR(&VAR_22->destipaddr);
      LOG_INFO_(""\n"");
    }
    return 1;
  }

  return 0;
#else /* COMMENT_10 */
  return 0; /* COMMENT_11 */
#endif /* COMMENT_10 */
}",contiki-ng/99a9257421ca5305ef6a360c02f63561e63ecc60/rpl-ext-header.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -38,8 +38,16 @@
       return 0;
     } else {
       uint8_t i = path_len - segments_left; /* The index of the next address to be visited */
-      uint8_t *addr_ptr = ((uint8_t *)rh_header) + RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));
       uint8_t cmpr = segments_left == 1 ? cmpre : cmpri;
+      ptrdiff_t rh_offset = (uint8_t *)rh_header - uip_buf;
+      size_t addr_offset = RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));
+
+      if(rh_offset + addr_offset + 16 - cmpr > UIP_BUFSIZE) {
+        LOG_ERR(""Invalid SRH address pointer\n"");
+        return 0;
+      }
+
+      uint8_t *addr_ptr = ((uint8_t *)rh_header) + addr_offset;
 
       /* As per RFC6554: swap the IPv6 destination address and address[i] */
 ","{'deleted_lines': ['      uint8_t *addr_ptr = ((uint8_t *)rh_header) + RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));'], 'added_lines': ['      ptrdiff_t rh_offset = (uint8_t *)rh_header - uip_buf;', '      size_t addr_offset = RPL_RH_LEN + RPL_SRH_LEN + (i * (16 - cmpri));', '', '      if(rh_offset + addr_offset + 16 - cmpr > UIP_BUFSIZE) {', '        LOG_ERR(""Invalid SRH address pointer\\n"");', '        return 0;', '      }', '', '      uint8_t *addr_ptr = ((uint8_t *)rh_header) + addr_offset;']}",True,"Contiki-NG is an open-source, cross-platform operating system for internet of things devices. The RPL-Classic and RPL-Lite implementations in the Contiki-NG operating system versions prior to 4.6 do not validate the address pointer in the RPL source routing header This makes it possible for an attacker to cause out-of-bounds writes with packets injected into the network stack. Specifically, the problem lies in the rpl_ext_header_srh_update function in the two rpl-ext-header.c modules for RPL-Classic and RPL-Lite respectively. The addr_ptr variable is calculated using an unvalidated CMPR field value from the source routing header. An out-of-bounds write can be triggered on line 151 in os/net/routing/rpl-lite/rpl-ext-header.c and line 261 in os/net/routing/rpl-classic/rpl-ext-header.c, which contain the following memcpy call with addr_ptr as destination. The problem has been patched in Contiki-NG 4.6. Users can apply a patch out-of-band as a workaround.",8.2,HIGH,2,valid,2020-10-19T13:48:34Z,3
CVE-2020-27678,['CWE-120'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,illumos/illumos-gate,"13242 parse_user_name in PAM is sloppy
Reviewed by: Alex Wilson <alex@cooperi.net>
Approved by: Gordon Ross <gordon.w.ross@gmail.com>",1d276e0b382cf066dae93640746d8b4c54d15452,https://github.com/illumos/illumos-gate/commit/1d276e0b382cf066dae93640746d8b4c54d15452,usr/src/lib/libpam/pam_framework.c,parse_user_name,"static int
parse_user_name(char *user_input, char **ret_username)
{
register char *ptr;
register int index = 0;
char username[PAM_MAX_RESP_SIZE];
*ret_username = NULL;
bzero((void *)username, PAM_MAX_RESP_SIZE);
ptr = user_input;
while ((*ptr == ' ') || (*ptr == '\t'))
ptr++;
if (*ptr == '\0') {
return (PAM_BUF_ERR);
}
while (*ptr != '\0') {
if ((*ptr == ' ') || (*ptr == '\t'))
break;
else {
username[index] = *ptr;
index++;
ptr++;
}
}
if ((*ret_username = malloc(index + 1)) == NULL)
return (PAM_BUF_ERR);
(void) strcpy(*ret_username, username);
return (PAM_SUCCESS);
}","static int
parse_user_name(char *VAR_0, char **VAR_1)
{
register char *VAR_2;
register int VAR_3 = 0;
char VAR_4[VAR_5];
*VAR_1 = NULL;
bzero((void *)VAR_4, VAR_5);
VAR_2 = VAR_0;
while ((*VAR_2 == ' ') || (*VAR_2 == '\t'))
VAR_2++;
if (*VAR_2 == '\0') {
return (VAR_6);
}
while (*VAR_2 != '\0') {
if ((*VAR_2 == ' ') || (*VAR_2 == '\t'))
break;
else {
VAR_4[VAR_3] = *VAR_2;
VAR_3++;
VAR_2++;
}
}
if ((*VAR_1 = malloc(VAR_3 + 1)) == NULL)
return (VAR_6);
(void) strcpy(*VAR_1, VAR_4);
return (VAR_7);
}",illumos/illumos-gate/1d276e0b382cf066dae93640746d8b4c54d15452/pam_framework.c/vul/before/0.json,"static int
parse_user_name(char *user_input, char **ret_username)
{
	register char *ptr;
	register int index = 0;
	char username[PAM_MAX_RESP_SIZE];

	/* Set the default value for *ret_username */
	*ret_username = NULL;

	/*
	 * Set the initial value for username - this is a buffer holds
	 * the user name.
	 */
	bzero((void *)username, PAM_MAX_RESP_SIZE);

	/*
	 * The user_input is guaranteed to be terminated by a null character.
	 */
	ptr = user_input;

	/* Skip all the leading whitespaces if there are any. */
	while ((*ptr == ' ') || (*ptr == '\t'))
		ptr++;

	if (*ptr == '\0') {
		/*
		 * We should never get here since the user_input we got
		 * in pam_get_user() is not all whitespaces nor just ""\0"".
		 */
		return (PAM_BUF_ERR);
	}

	/*
	 * username will be the first string we get from user_input
	 * - we skip leading whitespaces and ignore trailing whitespaces
	 */
	while (*ptr != '\0') {
		if ((*ptr == ' ') || (*ptr == '\t') ||
		    (index >= PAM_MAX_RESP_SIZE)) {
			break;
		} else {
			username[index] = *ptr;
			index++;
			ptr++;
		}
	}

	/* ret_username will be freed in pam_get_user(). */
	if (index >= PAM_MAX_RESP_SIZE ||
	    (*ret_username = strdup(username)) == NULL)
		return (PAM_BUF_ERR);
	return (PAM_SUCCESS);
}","static int
parse_user_name(char *VAR_0, char **VAR_1)
{
	register char *VAR_2;
	register int VAR_3 = 0;
	char VAR_4[VAR_5];

	/* COMMENT_0 */
	*VAR_1 = NULL;

	/* COMMENT_1 */
                                                               
                  
    
	bzero((void *)VAR_4, VAR_5);

	/* COMMENT_5 */
                                                                      
    
	VAR_2 = VAR_0;

	/* COMMENT_8 */
	while ((*VAR_2 == ' ') || (*VAR_2 == '\t'))
		VAR_2++;

	if (*VAR_2 == '\0') {
		/* COMMENT_9 */
                                                         
                                                            
     
		return (VAR_6);
	}

	/* COMMENT_13 */
                                                            
                                                                 
    
	while (*VAR_2 != '\0') {
		if ((*VAR_2 == ' ') || (*VAR_2 == '\t') ||
		    (VAR_3 >= VAR_5)) {
			break;
		} else {
			VAR_4[VAR_3] = *VAR_2;
			VAR_3++;
			VAR_2++;
		}
	}

	/* COMMENT_17 */
	if (VAR_3 >= VAR_5 ||
	    (*VAR_1 = strdup(VAR_4)) == NULL)
		return (VAR_6);
	return (VAR_7);
}",illumos/illumos-gate/1d276e0b382cf066dae93640746d8b4c54d15452/pam_framework.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -36,9 +36,10 @@
 	 * - we skip leading whitespaces and ignore trailing whitespaces
 	 */
 	while (*ptr != '\0') {
-		if ((*ptr == ' ') || (*ptr == '\t'))
+		if ((*ptr == ' ') || (*ptr == '\t') ||
+		    (index >= PAM_MAX_RESP_SIZE)) {
 			break;
-		else {
+		} else {
 			username[index] = *ptr;
 			index++;
 			ptr++;
@@ -46,8 +47,8 @@
 	}
 
 	/* ret_username will be freed in pam_get_user(). */
-	if ((*ret_username = malloc(index + 1)) == NULL)
+	if (index >= PAM_MAX_RESP_SIZE ||
+	    (*ret_username = strdup(username)) == NULL)
 		return (PAM_BUF_ERR);
-	(void) strcpy(*ret_username, username);
 	return (PAM_SUCCESS);
 }","{'deleted_lines': [""\t\tif ((*ptr == ' ') || (*ptr == '\\t'))"", '\t\telse {', '\tif ((*ret_username = malloc(index + 1)) == NULL)', '\t(void) strcpy(*ret_username, username);'], 'added_lines': [""\t\tif ((*ptr == ' ') || (*ptr == '\\t') ||"", '\t\t    (index >= PAM_MAX_RESP_SIZE)) {', '\t\t} else {', '\tif (index >= PAM_MAX_RESP_SIZE ||', '\t    (*ret_username = strdup(username)) == NULL)']}",True,"An issue was discovered in illumos before 2020-10-22, as used in OmniOS before r151030by, r151032ay, and r151034y and SmartOS before 20201022. There is a buffer overflow in parse_user_name in lib/libpam/pam_framework.c.",9.8,CRITICAL,3,valid,2020-10-22T12:34:07Z,3
CVE-2020-25669,['CWE-416'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"Input: sunkbd - avoid use-after-free in teardown paths

We need to make sure we cancel the reinit work before we tear down the
driver structures.

Reported-by: Bodong Zhao <nopitydays@gmail.com>
Tested-by: Bodong Zhao <nopitydays@gmail.com>
Cc: stable@vger.kernel.org
Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>",77e70d351db7de07a46ac49b87a6c3c7a60fca7e,https://github.com/torvalds/linux/commit/77e70d351db7de07a46ac49b87a6c3c7a60fca7e,drivers/input/keyboard/sunkbd.c,sunkbd_reinit,"static void sunkbd_reinit(struct work_struct *work)
{
struct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);
wait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);
serio_write(sunkbd->serio, SUNKBD_CMD_SETLED);
serio_write(sunkbd->serio,
(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |
(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |
(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |
!!test_bit(LED_NUML,    sunkbd->dev->led));
serio_write(sunkbd->serio,
SUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));
serio_write(sunkbd->serio,
SUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));
}","static void sunkbd_reinit(struct work_struct *VAR_0)
{
struct sunkbd *sunkbd = container_of(VAR_0, struct sunkbd, VAR_1);
wait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, VAR_2);
serio_write(sunkbd->serio, VAR_3);
serio_write(sunkbd->serio,
(!!test_bit(VAR_4,   sunkbd->dev->led) << 3) |
(!!test_bit(VAR_5, sunkbd->dev->led) << 2) |
(!!test_bit(VAR_6, sunkbd->dev->led) << 1) |
!!test_bit(VAR_7,    sunkbd->dev->led));
serio_write(sunkbd->serio,
VAR_8 - !!test_bit(VAR_9, sunkbd->dev->snd));
serio_write(sunkbd->serio,
VAR_10 - !!test_bit(VAR_11, sunkbd->dev->snd));
}",torvalds/linux/77e70d351db7de07a46ac49b87a6c3c7a60fca7e/sunkbd.c/vul/before/2.json,"static void sunkbd_reinit(struct work_struct *work)
{
	struct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);

	/*
	 * It is OK that we check sunkbd->enabled without pausing serio,
	 * as we only want to catch true->false transition that will
	 * happen once and we will be woken up for it.
	 */
	wait_event_interruptible_timeout(sunkbd->wait,
					 sunkbd->reset >= 0 || !sunkbd->enabled,
					 HZ);

	if (sunkbd->reset >= 0 && sunkbd->enabled)
		sunkbd_set_leds_beeps(sunkbd);
}","static void sunkbd_reinit(struct work_struct *VAR_0)
{
	struct sunkbd *sunkbd = container_of(VAR_0, struct sunkbd, VAR_1);

	/* COMMENT_0 */
                                                                 
                                                             
                                               
    
	wait_event_interruptible_timeout(sunkbd->wait,
					 sunkbd->reset >= 0 || !sunkbd->enabled,
					 VAR_2);

	if (sunkbd->reset >= 0 && sunkbd->enabled)
		sunkbd_set_leds_beeps(sunkbd);
}",torvalds/linux/77e70d351db7de07a46ac49b87a6c3c7a60fca7e/sunkbd.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -2,16 +2,15 @@
 {
 	struct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);
 
-	wait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);
+	/*
+	 * It is OK that we check sunkbd->enabled without pausing serio,
+	 * as we only want to catch true->false transition that will
+	 * happen once and we will be woken up for it.
+	 */
+	wait_event_interruptible_timeout(sunkbd->wait,
+					 sunkbd->reset >= 0 || !sunkbd->enabled,
+					 HZ);
 
-	serio_write(sunkbd->serio, SUNKBD_CMD_SETLED);
-	serio_write(sunkbd->serio,
-		(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |
-		(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |
-		(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |
-		 !!test_bit(LED_NUML,    sunkbd->dev->led));
-	serio_write(sunkbd->serio,
-		SUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));
-	serio_write(sunkbd->serio,
-		SUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));
+	if (sunkbd->reset >= 0 && sunkbd->enabled)
+		sunkbd_set_leds_beeps(sunkbd);
 }","{'deleted_lines': ['\twait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);', '\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);', '\tserio_write(sunkbd->serio,', '\t\t(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |', '\t\t(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |', '\t\t(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |', '\t\t !!test_bit(LED_NUML,    sunkbd->dev->led));', '\tserio_write(sunkbd->serio,', '\t\tSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));', '\tserio_write(sunkbd->serio,', '\t\tSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));'], 'added_lines': ['\t/*', '\t * It is OK that we check sunkbd->enabled without pausing serio,', '\t * as we only want to catch true->false transition that will', '\t * happen once and we will be woken up for it.', '\t */', '\twait_event_interruptible_timeout(sunkbd->wait,', '\t\t\t\t\t sunkbd->reset >= 0 || !sunkbd->enabled,', '\t\t\t\t\t HZ);', '\tif (sunkbd->reset >= 0 && sunkbd->enabled)', '\t\tsunkbd_set_leds_beeps(sunkbd);']}",True,"A vulnerability was found in the Linux Kernel where the function sunkbd_reinit having been scheduled by sunkbd_interrupt before sunkbd being freed. Though the dangling pointer is set to NULL in sunkbd_disconnect, there is still an alias in sunkbd_reinit causing Use After Free.",7.8,HIGH,2,valid,2020-10-26T20:36:17Z,3
CVE-2020-25669,['CWE-416'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"Input: sunkbd - avoid use-after-free in teardown paths

We need to make sure we cancel the reinit work before we tear down the
driver structures.

Reported-by: Bodong Zhao <nopitydays@gmail.com>
Tested-by: Bodong Zhao <nopitydays@gmail.com>
Cc: stable@vger.kernel.org
Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>",77e70d351db7de07a46ac49b87a6c3c7a60fca7e,https://github.com/torvalds/linux/commit/77e70d351db7de07a46ac49b87a6c3c7a60fca7e,drivers/input/keyboard/sunkbd.c,sunkbd_interrupt,"static irqreturn_t sunkbd_interrupt(struct serio *serio,
unsigned char data, unsigned int flags)
{
struct sunkbd *sunkbd = serio_get_drvdata(serio);
if (sunkbd->reset <= -1) {
sunkbd->reset = data;
wake_up_interruptible(&sunkbd->wait);
goto out;
}
if (sunkbd->layout == -1) {
sunkbd->layout = data;
wake_up_interruptible(&sunkbd->wait);
goto out;
}
switch (data) {
case SUNKBD_RET_RESET:
schedule_work(&sunkbd->tq);
sunkbd->reset = -1;
break;
case SUNKBD_RET_LAYOUT:
sunkbd->layout = -1;
break;
case SUNKBD_RET_ALLUP: 
break;
default:
if (!sunkbd->enabled)
break;
if (sunkbd->keycode[data & SUNKBD_KEY]) {
input_report_key(sunkbd->dev,
sunkbd->keycode[data & SUNKBD_KEY],
!(data & SUNKBD_RELEASE));
input_sync(sunkbd->dev);
} else {
printk(KERN_WARNING
""sunkbd.c: Unknown key (scancode %#x) %s.\n"",
data & SUNKBD_KEY,
data & SUNKBD_RELEASE ? ""released"" : ""pressed"");
}
}
out:
return IRQ_HANDLED;
}","static irqreturn_t sunkbd_interrupt(struct serio *serio,
unsigned char VAR_0, unsigned int VAR_1)
{
struct sunkbd *sunkbd = serio_get_drvdata(serio);
if (sunkbd->reset <= -1) {
sunkbd->reset = VAR_0;
wake_up_interruptible(&sunkbd->wait);
goto out;
}
if (sunkbd->layout == -1) {
sunkbd->layout = VAR_0;
wake_up_interruptible(&sunkbd->wait);
goto out;
}
switch (VAR_0) {
case VAR_2:
schedule_work(&sunkbd->tq);
sunkbd->reset = -1;
break;
case VAR_3:
sunkbd->layout = -1;
break;
case VAR_4: 
break;
default:
if (!sunkbd->enabled)
break;
if (sunkbd->keycode[VAR_0 & VAR_5]) {
input_report_key(sunkbd->dev,
sunkbd->keycode[VAR_0 & VAR_5],
!(VAR_0 & VAR_6));
input_sync(sunkbd->dev);
} else {
printk(KERN_WARNING
""sunkbd.c: Unknown key (scancode %#x) %s.\n"",
VAR_0 & VAR_5,
VAR_0 & VAR_6 ? ""released"" : ""pressed"");
}
}
out:
return VAR_7;
}",torvalds/linux/77e70d351db7de07a46ac49b87a6c3c7a60fca7e/sunkbd.c/vul/before/1.json,"static irqreturn_t sunkbd_interrupt(struct serio *serio,
		unsigned char data, unsigned int flags)
{
	struct sunkbd *sunkbd = serio_get_drvdata(serio);

	if (sunkbd->reset <= -1) {
		/*
		 * If cp[i] is 0xff, sunkbd->reset will stay -1.
		 * The keyboard sends 0xff 0xff 0xID on powerup.
		 */
		sunkbd->reset = data;
		wake_up_interruptible(&sunkbd->wait);
		goto out;
	}

	if (sunkbd->layout == -1) {
		sunkbd->layout = data;
		wake_up_interruptible(&sunkbd->wait);
		goto out;
	}

	switch (data) {

	case SUNKBD_RET_RESET:
		if (sunkbd->enabled)
			schedule_work(&sunkbd->tq);
		sunkbd->reset = -1;
		break;

	case SUNKBD_RET_LAYOUT:
		sunkbd->layout = -1;
		break;

	case SUNKBD_RET_ALLUP: /* All keys released */
		break;

	default:
		if (!sunkbd->enabled)
			break;

		if (sunkbd->keycode[data & SUNKBD_KEY]) {
			input_report_key(sunkbd->dev,
					 sunkbd->keycode[data & SUNKBD_KEY],
					 !(data & SUNKBD_RELEASE));
			input_sync(sunkbd->dev);
		} else {
			printk(KERN_WARNING
				""sunkbd.c: Unknown key (scancode %#x) %s.\n"",
				data & SUNKBD_KEY,
				data & SUNKBD_RELEASE ? ""released"" : ""pressed"");
		}
	}
out:
	return IRQ_HANDLED;
}","static irqreturn_t sunkbd_interrupt(struct serio *serio,
		unsigned char VAR_0, unsigned int VAR_1)
{
	struct sunkbd *sunkbd = serio_get_drvdata(serio);

	if (sunkbd->reset <= -1) {
		/* COMMENT_0 */
                                                  
                                                  
     
		sunkbd->reset = VAR_0;
		wake_up_interruptible(&sunkbd->wait);
		goto out;
	}

	if (sunkbd->layout == -1) {
		sunkbd->layout = VAR_0;
		wake_up_interruptible(&sunkbd->wait);
		goto out;
	}

	switch (VAR_0) {

	case VAR_2:
		if (sunkbd->enabled)
			schedule_work(&sunkbd->tq);
		sunkbd->reset = -1;
		break;

	case VAR_3:
		sunkbd->layout = -1;
		break;

	case VAR_4: /* COMMENT_4 */
		break;

	default:
		if (!sunkbd->enabled)
			break;

		if (sunkbd->keycode[VAR_0 & VAR_5]) {
			input_report_key(sunkbd->dev,
					 sunkbd->keycode[VAR_0 & VAR_5],
					 !(VAR_0 & VAR_6));
			input_sync(sunkbd->dev);
		} else {
			printk(KERN_WARNING
				""sunkbd.c: Unknown key (scancode %#x) %s.\n"",
				VAR_0 & VAR_5,
				VAR_0 & VAR_6 ? ""released"" : ""pressed"");
		}
	}
out:
	return VAR_7;
}",torvalds/linux/77e70d351db7de07a46ac49b87a6c3c7a60fca7e/sunkbd.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -22,7 +22,8 @@
 	switch (data) {
 
 	case SUNKBD_RET_RESET:
-		schedule_work(&sunkbd->tq);
+		if (sunkbd->enabled)
+			schedule_work(&sunkbd->tq);
 		sunkbd->reset = -1;
 		break;
 ","{'deleted_lines': ['\t\tschedule_work(&sunkbd->tq);'], 'added_lines': ['\t\tif (sunkbd->enabled)', '\t\t\tschedule_work(&sunkbd->tq);']}",True,"A vulnerability was found in the Linux Kernel where the function sunkbd_reinit having been scheduled by sunkbd_interrupt before sunkbd being freed. Though the dangling pointer is set to NULL in sunkbd_disconnect, there is still an alias in sunkbd_reinit causing Use After Free.",7.8,HIGH,2,valid,2020-10-26T20:36:17Z,3
CVE-2020-25669,['CWE-416'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"Input: sunkbd - avoid use-after-free in teardown paths

We need to make sure we cancel the reinit work before we tear down the
driver structures.

Reported-by: Bodong Zhao <nopitydays@gmail.com>
Tested-by: Bodong Zhao <nopitydays@gmail.com>
Cc: stable@vger.kernel.org
Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>",77e70d351db7de07a46ac49b87a6c3c7a60fca7e,https://github.com/torvalds/linux/commit/77e70d351db7de07a46ac49b87a6c3c7a60fca7e,drivers/input/keyboard/sunkbd.c,sunkbd_enable,"static void sunkbd_enable(struct sunkbd *sunkbd, bool enable)
{
serio_pause_rx(sunkbd->serio);
sunkbd->enabled = enable;
serio_continue_rx(sunkbd->serio);
}","static void sunkbd_enable(struct sunkbd *sunkbd, bool VAR_0)
{
serio_pause_rx(sunkbd->serio);
sunkbd->enabled = VAR_0;
serio_continue_rx(sunkbd->serio);
}",torvalds/linux/77e70d351db7de07a46ac49b87a6c3c7a60fca7e/sunkbd.c/vul/before/0.json,"static void sunkbd_enable(struct sunkbd *sunkbd, bool enable)
{
	serio_pause_rx(sunkbd->serio);
	sunkbd->enabled = enable;
	serio_continue_rx(sunkbd->serio);

	if (!enable) {
		wake_up_interruptible(&sunkbd->wait);
		cancel_work_sync(&sunkbd->tq);
	}
}","static void sunkbd_enable(struct sunkbd *sunkbd, bool VAR_0)
{
	serio_pause_rx(sunkbd->serio);
	sunkbd->enabled = VAR_0;
	serio_continue_rx(sunkbd->serio);

	if (!VAR_0) {
		wake_up_interruptible(&sunkbd->wait);
		cancel_work_sync(&sunkbd->tq);
	}
}",torvalds/linux/77e70d351db7de07a46ac49b87a6c3c7a60fca7e/sunkbd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,4 +3,9 @@
 	serio_pause_rx(sunkbd->serio);
 	sunkbd->enabled = enable;
 	serio_continue_rx(sunkbd->serio);
+
+	if (!enable) {
+		wake_up_interruptible(&sunkbd->wait);
+		cancel_work_sync(&sunkbd->tq);
+	}
 }","{'deleted_lines': [], 'added_lines': ['', '\tif (!enable) {', '\t\twake_up_interruptible(&sunkbd->wait);', '\t\tcancel_work_sync(&sunkbd->tq);', '\t}']}",True,"A vulnerability was found in the Linux Kernel where the function sunkbd_reinit having been scheduled by sunkbd_interrupt before sunkbd being freed. Though the dangling pointer is set to NULL in sunkbd_disconnect, there is still an alias in sunkbd_reinit causing Use After Free.",7.8,HIGH,2,valid,2020-10-26T20:36:17Z,3
CVE-2021-32020,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,FreeRTOS/FreeRTOS-Kernel,"Improve heap2 bounds checking (#224)

* Improve heap bounds checking in pvPortMalloc",c7a9a01c94987082b223d3e59969ede64363da63,https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/c7a9a01c94987082b223d3e59969ede64363da63,portable/MemMang/heap_1.c,pvPortMalloc,"void * pvPortMalloc( size_t xWantedSize )
{
void * pvReturn = NULL;
static uint8_t * pucAlignedHeap = NULL;
#if ( portBYTE_ALIGNMENT != 1 )
{
if( xWantedSize & portBYTE_ALIGNMENT_MASK )
{
xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
}
}
#endif
vTaskSuspendAll();
{
if( pucAlignedHeap == NULL )
{
pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
}
if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) 
{
pvReturn = pucAlignedHeap + xNextFreeByte;
xNextFreeByte += xWantedSize;
}
traceMALLOC( pvReturn, xWantedSize );
}
( void ) xTaskResumeAll();
#if ( configUSE_MALLOC_FAILED_HOOK == 1 )
{
if( pvReturn == NULL )
{
extern void vApplicationMallocFailedHook( void );
vApplicationMallocFailedHook();
}
}
#endif
return pvReturn;
}","void * pvPortMalloc( size_t VAR_0 )
{
void * VAR_1 = NULL;
static uint8_t * VAR_2 = NULL;
#if ( VAR_3 != 1 )
{
if( VAR_0 & VAR_4 )
{
VAR_0 += ( VAR_3 - ( VAR_0 & VAR_4 ) );
}
}
#endif
vTaskSuspendAll();
{
if( VAR_2 == NULL )
{
VAR_2 = ( uint8_t * ) ( ( ( VAR_5 ) & VAR_6[ VAR_3 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) VAR_4 ) ) );
}
if( ( ( VAR_7 + VAR_0 ) < VAR_8 ) &&
( ( VAR_7 + VAR_0 ) > VAR_7 ) ) 
{
VAR_1 = VAR_2 + VAR_7;
VAR_7 += VAR_0;
}
traceMALLOC( VAR_1, VAR_0 );
}
( void ) xTaskResumeAll();
#if ( VAR_9 == 1 )
{
if( VAR_1 == NULL )
{
extern void vApplicationMallocFailedHook( void );
vApplicationMallocFailedHook();
}
}
#endif
return VAR_1;
}",FreeRTOS/FreeRTOS-Kernel/c7a9a01c94987082b223d3e59969ede64363da63/heap_1.c/vul/before/0.json,"void * pvPortMalloc( size_t xWantedSize )
{
    void * pvReturn = NULL;
    static uint8_t * pucAlignedHeap = NULL;

    /* Ensure that blocks are always aligned. */
    #if ( portBYTE_ALIGNMENT != 1 )
        {
            if( xWantedSize & portBYTE_ALIGNMENT_MASK )
            {
                /* Byte alignment required. Check for overflow. */
                if ( (xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) )) > xWantedSize )
                {
                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
                } 
                else 
                {
                    xWantedSize = 0;
                }
            }
        }
    #endif

    vTaskSuspendAll();
    {
        if( pucAlignedHeap == NULL )
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) && /* valid size */
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
            xNextFreeByte += xWantedSize;
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();

    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )
        {
            if( pvReturn == NULL )
            {
                extern void vApplicationMallocFailedHook( void );
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
}","void * pvPortMalloc( size_t VAR_0 )
{
    void * VAR_1 = NULL;
    static uint8_t * VAR_2 = NULL;

    /* COMMENT_0 */
    #if ( VAR_3 != 1 )
        {
            if( VAR_0 & VAR_4 )
            {
                /* COMMENT_1 */
                if ( (VAR_0 + ( VAR_3 - ( VAR_0 & VAR_4 ) )) > VAR_0 )
                {
                    VAR_0 += ( VAR_3 - ( VAR_0 & VAR_4 ) );
                } 
                else 
                {
                    VAR_0 = 0;
                }
            }
        }
    #endif

    vTaskSuspendAll();
    {
        if( VAR_2 == NULL )
        {
            /* COMMENT_2 */
            VAR_2 = ( uint8_t * ) ( ( ( VAR_5 ) & VAR_6[ VAR_3 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) VAR_4 ) ) );
        }

        /* COMMENT_3 */
        if( ( VAR_0 > 0 ) && /* COMMENT_4 */
            ( ( VAR_7 + VAR_0 ) < VAR_8 ) &&
            ( ( VAR_7 + VAR_0 ) > VAR_7 ) ) /* COMMENT_5 */
        {
            /* COMMENT_6 */
                        
            VAR_1 = VAR_2 + VAR_7;
            VAR_7 += VAR_0;
        }

        traceMALLOC( VAR_1, VAR_0 );
    }
    ( void ) xTaskResumeAll();

    #if ( VAR_9 == 1 )
        {
            if( VAR_1 == NULL )
            {
                extern void vApplicationMallocFailedHook( void );
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return VAR_1;
}",FreeRTOS/FreeRTOS-Kernel/c7a9a01c94987082b223d3e59969ede64363da63/heap_1.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,13 +3,20 @@
     void * pvReturn = NULL;
     static uint8_t * pucAlignedHeap = NULL;
 
-    /* Ensure that blocks are always aligned to the required number of bytes. */
+    /* Ensure that blocks are always aligned. */
     #if ( portBYTE_ALIGNMENT != 1 )
         {
             if( xWantedSize & portBYTE_ALIGNMENT_MASK )
             {
-                /* Byte alignment required. */
-                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
+                /* Byte alignment required. Check for overflow. */
+                if ( (xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) )) > xWantedSize )
+                {
+                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
+                } 
+                else 
+                {
+                    xWantedSize = 0;
+                }
             }
         }
     #endif
@@ -22,8 +29,9 @@
             pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
         }
 
-        /* Check there is enough room left for the allocation. */
-        if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
+        /* Check there is enough room left for the allocation and. */
+        if( ( xWantedSize > 0 ) && /* valid size */
+            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
             ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
         {
             /* Return the next free byte then increment the index past this","{'deleted_lines': ['    /* Ensure that blocks are always aligned to the required number of bytes. */', '                /* Byte alignment required. */', '                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );', '        /* Check there is enough room left for the allocation. */', '        if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&'], 'added_lines': ['    /* Ensure that blocks are always aligned. */', '                /* Byte alignment required. Check for overflow. */', '                if ( (xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) )) > xWantedSize )', '                {', '                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );', '                } ', '                else ', '                {', '                    xWantedSize = 0;', '                }', '        /* Check there is enough room left for the allocation and. */', '        if( ( xWantedSize > 0 ) && /* valid size */', '            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&']}",True,The kernel in Amazon Web Services FreeRTOS before 10.4.3 has insufficient bounds checking during management of heap memory.,9.8,CRITICAL,3,valid,2020-12-07T18:36:27Z,3
CVE-2021-32020,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,FreeRTOS/FreeRTOS-Kernel,"Improve heap2 bounds checking (#224)

* Improve heap bounds checking in pvPortMalloc",c7a9a01c94987082b223d3e59969ede64363da63,https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/c7a9a01c94987082b223d3e59969ede64363da63,portable/MemMang/heap_2.c,pvPortMalloc,"void * pvPortMalloc( size_t xWantedSize )
{
BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void * pvReturn = NULL;
vTaskSuspendAll();
{
if( xHeapHasBeenInitialised == pdFALSE )
{
prvHeapInit();
xHeapHasBeenInitialised = pdTRUE;
}
if( xWantedSize > 0 )
{
xWantedSize += heapSTRUCT_SIZE;
if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
{
xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
}
}
if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
{
pxPreviousBlock = &xStart;
pxBlock = xStart.pxNextFreeBlock;
while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
{
pxPreviousBlock = pxBlock;
pxBlock = pxBlock->pxNextFreeBlock;
}
if( pxBlock != &xEnd )
{
pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
{
pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
pxBlock->xBlockSize = xWantedSize;
prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
}
xFreeBytesRemaining -= pxBlock->xBlockSize;
}
}
traceMALLOC( pvReturn, xWantedSize );
}
( void ) xTaskResumeAll();
#if ( configUSE_MALLOC_FAILED_HOOK == 1 )
{
if( pvReturn == NULL )
{
extern void vApplicationMallocFailedHook( void );
vApplicationMallocFailedHook();
}
}
#endif
return pvReturn;
}","void * pvPortMalloc( size_t VAR_0 )
{
BlockLink_t * VAR_1, * VAR_2, * VAR_3;
static BaseType_t VAR_4 = VAR_5;
void * VAR_6 = NULL;
vTaskSuspendAll();
{
if( VAR_4 == VAR_5 )
{
prvHeapInit();
VAR_4 = VAR_7;
}
if( VAR_0 > 0 )
{
VAR_0 += VAR_8;
if( ( VAR_0 & VAR_9 ) != 0 )
{
VAR_0 += ( VAR_10 - ( VAR_0 & VAR_9 ) );
}
}
if( ( VAR_0 > 0 ) && ( VAR_0 < VAR_11 ) )
{
VAR_2 = &VAR_12;
VAR_1 = VAR_12.pxNextFreeBlock;
while( ( VAR_1->xBlockSize < VAR_0 ) && ( VAR_1->pxNextFreeBlock != NULL ) )
{
VAR_2 = VAR_1;
VAR_1 = VAR_1->pxNextFreeBlock;
}
if( VAR_1 != &VAR_13 )
{
VAR_6 = ( void * ) ( ( ( uint8_t * ) VAR_2->pxNextFreeBlock ) + VAR_8 );
VAR_2->pxNextFreeBlock = VAR_1->pxNextFreeBlock;
if( ( VAR_1->xBlockSize - VAR_0 ) > VAR_14 )
{
VAR_3 = ( void * ) ( ( ( uint8_t * ) VAR_1 ) + VAR_0 );
VAR_3->xBlockSize = VAR_1->xBlockSize - VAR_0;
VAR_1->xBlockSize = VAR_0;
prvInsertBlockIntoFreeList( ( VAR_3 ) );
}
VAR_15 -= VAR_1->xBlockSize;
}
}
traceMALLOC( VAR_6, VAR_0 );
}
( void ) xTaskResumeAll();
#if ( VAR_16 == 1 )
{
if( VAR_6 == NULL )
{
extern void vApplicationMallocFailedHook( void );
vApplicationMallocFailedHook();
}
}
#endif
return VAR_6;
}",FreeRTOS/FreeRTOS-Kernel/c7a9a01c94987082b223d3e59969ede64363da63/heap_2.c/vul/before/0.json,"void * pvPortMalloc( size_t xWantedSize )
{
    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;
    static BaseType_t xHeapHasBeenInitialised = pdFALSE;
    void * pvReturn = NULL;

    vTaskSuspendAll();
    {
        /* If this is the first call to malloc then the heap will require
         * initialisation to setup the list of free blocks. */
        if( xHeapHasBeenInitialised == pdFALSE )
        {
            prvHeapInit();
            xHeapHasBeenInitialised = pdTRUE;
        }

        /* The wanted size must be increased so it can contain a BlockLink_t
         * structure in addition to the requested amount of bytes. */
        if( ( xWantedSize > 0 ) && 
            ( ( xWantedSize + heapSTRUCT_SIZE ) >  xWantedSize ) ) /* Overflow check */
        {
            xWantedSize += heapSTRUCT_SIZE;

            /* Byte alignment required. Check for overflow. */
            if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) 
                    > xWantedSize )
            {
                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
                configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
            }
            else
            {
                xWantedSize = 0;
            }       
        }
        else 
        {
            xWantedSize = 0; 
        }


        if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
        {
            /* Blocks are stored in byte order - traverse the list from the start
             * (smallest) block until one of adequate size is found. */
            pxPreviousBlock = &xStart;
            pxBlock = xStart.pxNextFreeBlock;

            while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
            {
                pxPreviousBlock = pxBlock;
                pxBlock = pxBlock->pxNextFreeBlock;
            }

            /* If we found the end marker then a block of adequate size was not found. */
            if( pxBlock != &xEnd )
            {
                /* Return the memory space - jumping over the BlockLink_t structure
                 * at its start. */
                pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );

                /* This block is being returned for use so must be taken out of the
                 * list of free blocks. */
                pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;

                /* If the block is larger than required it can be split into two. */
                if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
                {
                    /* This block is to be split into two.  Create a new block
                     * following the number of bytes requested. The void cast is
                     * used to prevent byte alignment warnings from the compiler. */
                    pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );

                    /* Calculate the sizes of two blocks split from the single
                     * block. */
                    pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
                    pxBlock->xBlockSize = xWantedSize;

                    /* Insert the new block into the list of free blocks. */
                    prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
                }

                xFreeBytesRemaining -= pxBlock->xBlockSize;
            }
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();

    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )
        {
            if( pvReturn == NULL )
            {
                extern void vApplicationMallocFailedHook( void );
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
}","void * pvPortMalloc( size_t VAR_0 )
{
    BlockLink_t * VAR_1, * VAR_2, * VAR_3;
    static BaseType_t VAR_4 = VAR_5;
    void * VAR_6 = NULL;

    vTaskSuspendAll();
    {
        /* COMMENT_0 */
                                                              
        if( VAR_4 == VAR_5 )
        {
            prvHeapInit();
            VAR_4 = VAR_7;
        }

        /* COMMENT_2 */
                                                                     
        if( ( VAR_0 > 0 ) && 
            ( ( VAR_0 + VAR_8 ) >  VAR_0 ) ) /* COMMENT_4 */
        {
            VAR_0 += VAR_8;

            /* COMMENT_5 */
            if( ( VAR_0 + ( VAR_9 - ( VAR_0 & VAR_10 ) ) ) 
                    > VAR_0 )
            {
                VAR_0 += ( VAR_9 - ( VAR_0 & VAR_10 ) );
                configASSERT( ( VAR_0 & VAR_10 ) == 0 );
            }
            else
            {
                VAR_0 = 0;
            }       
        }
        else 
        {
            VAR_0 = 0; 
        }


        if( ( VAR_0 > 0 ) && ( VAR_0 <= VAR_11 ) )
        {
            /* COMMENT_6 */
                                                                       
            VAR_2 = &VAR_12;
            VAR_1 = VAR_12.pxNextFreeBlock;

            while( ( VAR_1->xBlockSize < VAR_0 ) && ( VAR_1->pxNextFreeBlock != NULL ) )
            {
                VAR_2 = VAR_1;
                VAR_1 = VAR_1->pxNextFreeBlock;
            }

            /* COMMENT_8 */
            if( VAR_1 != &VAR_13 )
            {
                /* COMMENT_9 */
                                   
                VAR_6 = ( void * ) ( ( ( uint8_t * ) VAR_2->pxNextFreeBlock ) + VAR_8 );

                /* COMMENT_11 */
                                          
                VAR_2->pxNextFreeBlock = VAR_1->pxNextFreeBlock;

                /* COMMENT_13 */
                if( ( VAR_1->xBlockSize - VAR_0 ) > VAR_14 )
                {
                    /* COMMENT_14 */
                                                                                
                                                                                    
                    VAR_3 = ( void * ) ( ( ( uint8_t * ) VAR_1 ) + VAR_0 );

                    /* COMMENT_17 */
                                
                    VAR_3->xBlockSize = VAR_1->xBlockSize - VAR_0;
                    VAR_1->xBlockSize = VAR_0;

                    /* COMMENT_19 */
                    prvInsertBlockIntoFreeList( ( VAR_3 ) );
                }

                VAR_11 -= VAR_1->xBlockSize;
            }
        }

        traceMALLOC( VAR_6, VAR_0 );
    }
    ( void ) xTaskResumeAll();

    #if ( VAR_15 == 1 )
        {
            if( VAR_6 == NULL )
            {
                extern void vApplicationMallocFailedHook( void );
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return VAR_6;
}",FreeRTOS/FreeRTOS-Kernel/c7a9a01c94987082b223d3e59969ede64363da63/heap_2.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,21 +14,32 @@
             xHeapHasBeenInitialised = pdTRUE;
         }
 
-        /* The wanted size is increased so it can contain a BlockLink_t
+        /* The wanted size must be increased so it can contain a BlockLink_t
          * structure in addition to the requested amount of bytes. */
-        if( xWantedSize > 0 )
+        if( ( xWantedSize > 0 ) && 
+            ( ( xWantedSize + heapSTRUCT_SIZE ) >  xWantedSize ) ) /* Overflow check */
         {
             xWantedSize += heapSTRUCT_SIZE;
 
-            /* Ensure that blocks are always aligned to the required number of bytes. */
-            if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
+            /* Byte alignment required. Check for overflow. */
+            if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) 
+                    > xWantedSize )
             {
-                /* Byte alignment required. */
                 xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
+                configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
             }
+            else
+            {
+                xWantedSize = 0;
+            }       
+        }
+        else 
+        {
+            xWantedSize = 0; 
         }
 
-        if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
+
+        if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
         {
             /* Blocks are stored in byte order - traverse the list from the start
              * (smallest) block until one of adequate size is found. */","{'deleted_lines': ['        /* The wanted size is increased so it can contain a BlockLink_t', '        if( xWantedSize > 0 )', '            /* Ensure that blocks are always aligned to the required number of bytes. */', '            if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )', '                /* Byte alignment required. */', '        if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )'], 'added_lines': ['        /* The wanted size must be increased so it can contain a BlockLink_t', '        if( ( xWantedSize > 0 ) && ', '            ( ( xWantedSize + heapSTRUCT_SIZE ) >  xWantedSize ) ) /* Overflow check */', '            /* Byte alignment required. Check for overflow. */', '            if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) ', '                    > xWantedSize )', '                configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );', '            else', '            {', '                xWantedSize = 0;', '            }       ', '        }', '        else ', '        {', '            xWantedSize = 0; ', '', '        if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )']}",True,The kernel in Amazon Web Services FreeRTOS before 10.4.3 has insufficient bounds checking during management of heap memory.,9.8,CRITICAL,3,valid,2020-12-07T18:36:27Z,3
CVE-2021-32020,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,FreeRTOS/FreeRTOS-Kernel,"Improve heap2 bounds checking (#224)

* Improve heap bounds checking in pvPortMalloc",c7a9a01c94987082b223d3e59969ede64363da63,https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/c7a9a01c94987082b223d3e59969ede64363da63,portable/MemMang/heap_5.c,pvPortMalloc,"void * pvPortMalloc( size_t xWantedSize )
{
BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;
void * pvReturn = NULL;
configASSERT( pxEnd );
vTaskSuspendAll();
{
if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
{
if( xWantedSize > 0 )
{
xWantedSize += xHeapStructSize;
if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
{
xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
}
else
{
mtCOVERAGE_TEST_MARKER();
}
}
else
{
mtCOVERAGE_TEST_MARKER();
}
if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
{
pxPreviousBlock = &xStart;
pxBlock = xStart.pxNextFreeBlock;
while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
{
pxPreviousBlock = pxBlock;
pxBlock = pxBlock->pxNextFreeBlock;
}
if( pxBlock != pxEnd )
{
pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
{
pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
pxBlock->xBlockSize = xWantedSize;
prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
}
else
{
mtCOVERAGE_TEST_MARKER();
}
xFreeBytesRemaining -= pxBlock->xBlockSize;
if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
{
xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
}
else
{
mtCOVERAGE_TEST_MARKER();
}
pxBlock->xBlockSize |= xBlockAllocatedBit;
pxBlock->pxNextFreeBlock = NULL;
xNumberOfSuccessfulAllocations++;
}
else
{
mtCOVERAGE_TEST_MARKER();
}
}
else
{
mtCOVERAGE_TEST_MARKER();
}
}
else
{
mtCOVERAGE_TEST_MARKER();
}
traceMALLOC( pvReturn, xWantedSize );
}
( void ) xTaskResumeAll();
#if ( configUSE_MALLOC_FAILED_HOOK == 1 )
{
if( pvReturn == NULL )
{
extern void vApplicationMallocFailedHook( void );
vApplicationMallocFailedHook();
}
else
{
mtCOVERAGE_TEST_MARKER();
}
}
#endif 
return pvReturn;
}","void * pvPortMalloc( size_t VAR_0 )
{
BlockLink_t * VAR_1, * VAR_2, * VAR_3;
void * VAR_4 = NULL;
configASSERT( VAR_5 );
vTaskSuspendAll();
{
if( ( VAR_0 & VAR_6 ) == 0 )
{
if( VAR_0 > 0 )
{
VAR_0 += VAR_7;
if( ( VAR_0 & VAR_8 ) != 0x00 )
{
VAR_0 += ( VAR_9 - ( VAR_0 & VAR_8 ) );
}
else
{
mtCOVERAGE_TEST_MARKER();
}
}
else
{
mtCOVERAGE_TEST_MARKER();
}
if( ( VAR_0 > 0 ) && ( VAR_0 <= VAR_10 ) )
{
VAR_2 = &VAR_11;
VAR_1 = VAR_11.pxNextFreeBlock;
while( ( VAR_1->xBlockSize < VAR_0 ) && ( VAR_1->pxNextFreeBlock != NULL ) )
{
VAR_2 = VAR_1;
VAR_1 = VAR_1->pxNextFreeBlock;
}
if( VAR_1 != VAR_5 )
{
VAR_4 = ( void * ) ( ( ( uint8_t * ) VAR_2->pxNextFreeBlock ) + VAR_7 );
VAR_2->pxNextFreeBlock = VAR_1->pxNextFreeBlock;
if( ( VAR_1->xBlockSize - VAR_0 ) > VAR_12 )
{
VAR_3 = ( void * ) ( ( ( uint8_t * ) VAR_1 ) + VAR_0 );
VAR_3->xBlockSize = VAR_1->xBlockSize - VAR_0;
VAR_1->xBlockSize = VAR_0;
prvInsertBlockIntoFreeList( ( VAR_3 ) );
}
else
{
mtCOVERAGE_TEST_MARKER();
}
VAR_10 -= VAR_1->xBlockSize;
if( VAR_10 < VAR_13 )
{
VAR_13 = VAR_10;
}
else
{
mtCOVERAGE_TEST_MARKER();
}
VAR_1->xBlockSize |= VAR_6;
VAR_1->pxNextFreeBlock = NULL;
VAR_14++;
}
else
{
mtCOVERAGE_TEST_MARKER();
}
}
else
{
mtCOVERAGE_TEST_MARKER();
}
}
else
{
mtCOVERAGE_TEST_MARKER();
}
traceMALLOC( VAR_4, VAR_0 );
}
( void ) xTaskResumeAll();
#if ( VAR_15 == 1 )
{
if( VAR_4 == NULL )
{
extern void vApplicationMallocFailedHook( void );
vApplicationMallocFailedHook();
}
else
{
mtCOVERAGE_TEST_MARKER();
}
}
#endif 
return VAR_4;
}",FreeRTOS/FreeRTOS-Kernel/c7a9a01c94987082b223d3e59969ede64363da63/heap_5.c/vul/before/0.json,"void * pvPortMalloc( size_t xWantedSize )
{
    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;
    void * pvReturn = NULL;

    /* The heap must be initialised before the first call to
     * prvPortMalloc(). */
    configASSERT( pxEnd );

    vTaskSuspendAll();
    {
        /* Check the requested block size is not so large that the top bit is
         * set.  The top bit of the block size member of the BlockLink_t structure
         * is used to determine who owns the block - the application or the
         * kernel, so it must be free. */
        if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
        {
            /* The wanted size is increased so it can contain a BlockLink_t
             * structure in addition to the requested amount of bytes. */
            if( ( xWantedSize > 0 ) && 
                ( ( xWantedSize + xHeapStructSize ) >  xWantedSize ) ) /* Overflow check */
            {
                xWantedSize += xHeapStructSize;

                /* Ensure that blocks are always aligned */
                if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
                {
                    /* Byte alignment required. Check for overflow */
                    if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) >
                         xWantedSize )
                    {
                        xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
                    } 
                    else 
                    {
                        xWantedSize = 0;
                    }
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xWantedSize = 0;
            }

            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
            {
                /* Traverse the list from the start	(lowest address) block until
                 * one of adequate size is found. */
                pxPreviousBlock = &xStart;
                pxBlock = xStart.pxNextFreeBlock;

                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
                {
                    pxPreviousBlock = pxBlock;
                    pxBlock = pxBlock->pxNextFreeBlock;
                }

                /* If the end marker was reached then a block of adequate size
                 * was not found. */
                if( pxBlock != pxEnd )
                {
                    /* Return the memory space pointed to - jumping over the
                     * BlockLink_t structure at its start. */
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );

                    /* This block is being returned for use so must be taken out
                     * of the list of free blocks. */
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;

                    /* If the block is larger than required it can be split into
                     * two. */
                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
                    {
                        /* This block is to be split into two.  Create a new
                         * block following the number of bytes requested. The void
                         * cast is used to prevent byte alignment warnings from the
                         * compiler. */
                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );

                        /* Calculate the sizes of two blocks split from the
                         * single block. */
                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
                        pxBlock->xBlockSize = xWantedSize;

                        /* Insert the new block into the list of free blocks. */
                        prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    xFreeBytesRemaining -= pxBlock->xBlockSize;

                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
                    {
                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* The block is being returned - it is allocated and owned
                     * by the application and has no ""next"" block. */
                    pxBlock->xBlockSize |= xBlockAllocatedBit;
                    pxBlock->pxNextFreeBlock = NULL;
                    xNumberOfSuccessfulAllocations++;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();

    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )
        {
            if( pvReturn == NULL )
            {
                extern void vApplicationMallocFailedHook( void );
                vApplicationMallocFailedHook();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */

    return pvReturn;
}","void * pvPortMalloc( size_t VAR_0 )
{
    BlockLink_t * VAR_1, * VAR_2, * VAR_3;
    void * VAR_4 = NULL;

    /* COMMENT_0 */
                          
    configASSERT( VAR_5 );

    vTaskSuspendAll();
    {
        /* COMMENT_2 */
                                                                                  
                                                                           
                                         
        if( ( VAR_0 & VAR_6 ) == 0 )
        {
            /* COMMENT_6 */
                                                                         
            if( ( VAR_0 > 0 ) && 
                ( ( VAR_0 + VAR_7 ) >  VAR_0 ) ) /* COMMENT_8 */
            {
                VAR_0 += VAR_7;

                /* COMMENT_9 */
                if( ( VAR_0 & VAR_8 ) != 0x00 )
                {
                    /* COMMENT_10 */
                    if( ( VAR_0 + ( VAR_9 - ( VAR_0 & VAR_8 ) ) ) >
                         VAR_0 )
                    {
                        VAR_0 += ( VAR_9 - ( VAR_0 & VAR_8 ) );
                    } 
                    else 
                    {
                        VAR_0 = 0;
                    }
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                VAR_0 = 0;
            }

            if( ( VAR_0 > 0 ) && ( VAR_0 <= VAR_10 ) )
            {
                /* COMMENT_11 */
                                                    
                VAR_2 = &VAR_11;
                VAR_1 = VAR_11.pxNextFreeBlock;

                while( ( VAR_1->xBlockSize < VAR_0 ) && ( VAR_1->pxNextFreeBlock != NULL ) )
                {
                    VAR_2 = VAR_1;
                    VAR_1 = VAR_1->pxNextFreeBlock;
                }

                /* COMMENT_13 */
                                    
                if( VAR_1 != VAR_5 )
                {
                    /* COMMENT_15 */
                                                             
                    VAR_4 = ( void * ) ( ( ( uint8_t * ) VAR_2->pxNextFreeBlock ) + VAR_7 );

                    /* COMMENT_17 */
                                                     
                    VAR_2->pxNextFreeBlock = VAR_1->pxNextFreeBlock;

                    /* COMMENT_19 */
                              
                    if( ( VAR_1->xBlockSize - VAR_0 ) > VAR_12 )
                    {
                        /* COMMENT_21 */
                                                                                  
                                                                                   
                                       
                        VAR_3 = ( void * ) ( ( ( uint8_t * ) VAR_1 ) + VAR_0 );

                        /* COMMENT_25 */
                                           
                        VAR_3->xBlockSize = VAR_1->xBlockSize - VAR_0;
                        VAR_1->xBlockSize = VAR_0;

                        /* COMMENT_27 */
                        prvInsertBlockIntoFreeList( ( VAR_3 ) );
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    VAR_10 -= VAR_1->xBlockSize;

                    if( VAR_10 < VAR_13 )
                    {
                        VAR_13 = VAR_10;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* COMMENT_28 */
                                                                     
                    VAR_1->xBlockSize |= VAR_6;
                    VAR_1->pxNextFreeBlock = NULL;
                    VAR_14++;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        traceMALLOC( VAR_4, VAR_0 );
    }
    ( void ) xTaskResumeAll();

    #if ( VAR_15 == 1 )
        {
            if( VAR_4 == NULL )
            {
                extern void vApplicationMallocFailedHook( void );
                vApplicationMallocFailedHook();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* COMMENT_30 */

    return VAR_4;
}",FreeRTOS/FreeRTOS-Kernel/c7a9a01c94987082b223d3e59969ede64363da63/heap_5.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,16 +17,24 @@
         {
             /* The wanted size is increased so it can contain a BlockLink_t
              * structure in addition to the requested amount of bytes. */
-            if( xWantedSize > 0 )
+            if( ( xWantedSize > 0 ) && 
+                ( ( xWantedSize + xHeapStructSize ) >  xWantedSize ) ) /* Overflow check */
             {
                 xWantedSize += xHeapStructSize;
 
-                /* Ensure that blocks are always aligned to the required number
-                 * of bytes. */
+                /* Ensure that blocks are always aligned */
                 if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
                 {
-                    /* Byte alignment required. */
-                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
+                    /* Byte alignment required. Check for overflow */
+                    if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) >
+                         xWantedSize )
+                    {
+                        xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
+                    } 
+                    else 
+                    {
+                        xWantedSize = 0;
+                    }
                 }
                 else
                 {
@@ -35,13 +43,13 @@
             }
             else
             {
-                mtCOVERAGE_TEST_MARKER();
+                xWantedSize = 0;
             }
 
             if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
             {
                 /* Traverse the list from the start	(lowest address) block until
-                 * one	of adequate size is found. */
+                 * one of adequate size is found. */
                 pxPreviousBlock = &xStart;
                 pxBlock = xStart.pxNextFreeBlock;
 
@@ -52,7 +60,7 @@
                 }
 
                 /* If the end marker was reached then a block of adequate size
-                 * was	not found. */
+                 * was not found. */
                 if( pxBlock != pxEnd )
                 {
                     /* Return the memory space pointed to - jumping over the","{'deleted_lines': ['            if( xWantedSize > 0 )', '                /* Ensure that blocks are always aligned to the required number', '                 * of bytes. */', '                    /* Byte alignment required. */', '                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );', '                mtCOVERAGE_TEST_MARKER();', '                 * one\tof adequate size is found. */', '                 * was\tnot found. */'], 'added_lines': ['            if( ( xWantedSize > 0 ) && ', '                ( ( xWantedSize + xHeapStructSize ) >  xWantedSize ) ) /* Overflow check */', '                /* Ensure that blocks are always aligned */', '                    /* Byte alignment required. Check for overflow */', '                    if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) >', '                         xWantedSize )', '                    {', '                        xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );', '                    } ', '                    else ', '                    {', '                        xWantedSize = 0;', '                    }', '                xWantedSize = 0;', '                 * one of adequate size is found. */', '                 * was not found. */']}",True,The kernel in Amazon Web Services FreeRTOS before 10.4.3 has insufficient bounds checking during management of heap memory.,9.8,CRITICAL,3,valid,2020-12-07T18:36:27Z,3
CVE-2021-32020,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,FreeRTOS/FreeRTOS-Kernel,"Improve heap2 bounds checking (#224)

* Improve heap bounds checking in pvPortMalloc",c7a9a01c94987082b223d3e59969ede64363da63,https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/c7a9a01c94987082b223d3e59969ede64363da63,portable/MemMang/heap_4.c,pvPortMalloc,"void * pvPortMalloc( size_t xWantedSize )
{
BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;
void * pvReturn = NULL;
vTaskSuspendAll();
{
if( pxEnd == NULL )
{
prvHeapInit();
}
else
{
mtCOVERAGE_TEST_MARKER();
}
if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
{
if( xWantedSize > 0 )
{
xWantedSize += xHeapStructSize;
if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
{
xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
}
else
{
mtCOVERAGE_TEST_MARKER();
}
}
else
{
mtCOVERAGE_TEST_MARKER();
}
if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
{
pxPreviousBlock = &xStart;
pxBlock = xStart.pxNextFreeBlock;
while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
{
pxPreviousBlock = pxBlock;
pxBlock = pxBlock->pxNextFreeBlock;
}
if( pxBlock != pxEnd )
{
pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
{
pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
pxBlock->xBlockSize = xWantedSize;
prvInsertBlockIntoFreeList( pxNewBlockLink );
}
else
{
mtCOVERAGE_TEST_MARKER();
}
xFreeBytesRemaining -= pxBlock->xBlockSize;
if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
{
xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
}
else
{
mtCOVERAGE_TEST_MARKER();
}
pxBlock->xBlockSize |= xBlockAllocatedBit;
pxBlock->pxNextFreeBlock = NULL;
xNumberOfSuccessfulAllocations++;
}
else
{
mtCOVERAGE_TEST_MARKER();
}
}
else
{
mtCOVERAGE_TEST_MARKER();
}
}
else
{
mtCOVERAGE_TEST_MARKER();
}
traceMALLOC( pvReturn, xWantedSize );
}
( void ) xTaskResumeAll();
#if ( configUSE_MALLOC_FAILED_HOOK == 1 )
{
if( pvReturn == NULL )
{
extern void vApplicationMallocFailedHook( void );
vApplicationMallocFailedHook();
}
else
{
mtCOVERAGE_TEST_MARKER();
}
}
#endif 
configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
return pvReturn;
}","void * pvPortMalloc( size_t VAR_0 )
{
BlockLink_t * VAR_1, * VAR_2, * VAR_3;
void * VAR_4 = NULL;
vTaskSuspendAll();
{
if( VAR_5 == NULL )
{
prvHeapInit();
}
else
{
mtCOVERAGE_TEST_MARKER();
}
if( ( VAR_0 & VAR_6 ) == 0 )
{
if( VAR_0 > 0 )
{
VAR_0 += VAR_7;
if( ( VAR_0 & VAR_8 ) != 0x00 )
{
VAR_0 += ( VAR_9 - ( VAR_0 & VAR_8 ) );
configASSERT( ( VAR_0 & VAR_8 ) == 0 );
}
else
{
mtCOVERAGE_TEST_MARKER();
}
}
else
{
mtCOVERAGE_TEST_MARKER();
}
if( ( VAR_0 > 0 ) && ( VAR_0 <= VAR_10 ) )
{
VAR_2 = &VAR_11;
VAR_1 = VAR_11.pxNextFreeBlock;
while( ( VAR_1->xBlockSize < VAR_0 ) && ( VAR_1->pxNextFreeBlock != NULL ) )
{
VAR_2 = VAR_1;
VAR_1 = VAR_1->pxNextFreeBlock;
}
if( VAR_1 != VAR_5 )
{
VAR_4 = ( void * ) ( ( ( uint8_t * ) VAR_2->pxNextFreeBlock ) + VAR_7 );
VAR_2->pxNextFreeBlock = VAR_1->pxNextFreeBlock;
if( ( VAR_1->xBlockSize - VAR_0 ) > VAR_12 )
{
VAR_3 = ( void * ) ( ( ( uint8_t * ) VAR_1 ) + VAR_0 );
configASSERT( ( ( ( size_t ) VAR_3 ) & VAR_8 ) == 0 );
VAR_3->xBlockSize = VAR_1->xBlockSize - VAR_0;
VAR_1->xBlockSize = VAR_0;
prvInsertBlockIntoFreeList( VAR_3 );
}
else
{
mtCOVERAGE_TEST_MARKER();
}
VAR_10 -= VAR_1->xBlockSize;
if( VAR_10 < VAR_13 )
{
VAR_13 = VAR_10;
}
else
{
mtCOVERAGE_TEST_MARKER();
}
VAR_1->xBlockSize |= VAR_6;
VAR_1->pxNextFreeBlock = NULL;
VAR_14++;
}
else
{
mtCOVERAGE_TEST_MARKER();
}
}
else
{
mtCOVERAGE_TEST_MARKER();
}
}
else
{
mtCOVERAGE_TEST_MARKER();
}
traceMALLOC( VAR_4, VAR_0 );
}
( void ) xTaskResumeAll();
#if ( VAR_15 == 1 )
{
if( VAR_4 == NULL )
{
extern void vApplicationMallocFailedHook( void );
vApplicationMallocFailedHook();
}
else
{
mtCOVERAGE_TEST_MARKER();
}
}
#endif 
configASSERT( ( ( ( size_t ) VAR_4 ) & ( size_t ) VAR_8 ) == 0 );
return VAR_4;
}",FreeRTOS/FreeRTOS-Kernel/c7a9a01c94987082b223d3e59969ede64363da63/heap_4.c/vul/before/0.json,"void * pvPortMalloc( size_t xWantedSize )
{
    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;
    void * pvReturn = NULL;

    vTaskSuspendAll();
    {
        /* If this is the first call to malloc then the heap will require
         * initialisation to setup the list of free blocks. */
        if( pxEnd == NULL )
        {
            prvHeapInit();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        /* Check the requested block size is not so large that the top bit is
         * set.  The top bit of the block size member of the BlockLink_t structure
         * is used to determine who owns the block - the application or the
         * kernel, so it must be free. */
        if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
        {
            /* The wanted size must be increased so it can contain a BlockLink_t
             * structure in addition to the requested amount of bytes. */
            if( ( xWantedSize > 0 ) && 
                ( ( xWantedSize + xHeapStructSize ) >  xWantedSize ) ) /* Overflow check */
            {
                xWantedSize += xHeapStructSize;

                /* Ensure that blocks are always aligned. */
                if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
                {
                    /* Byte alignment required. Check for overflow. */
                    if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) 
                            > xWantedSize )
                    {
                        xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
                        configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
                    }
                    else
                    {
                        xWantedSize = 0;
                    }  
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            } 
            else 
            {
                xWantedSize = 0;
            }

            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
            {
                /* Traverse the list from the start	(lowest address) block until
                 * one of adequate size is found. */
                pxPreviousBlock = &xStart;
                pxBlock = xStart.pxNextFreeBlock;

                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
                {
                    pxPreviousBlock = pxBlock;
                    pxBlock = pxBlock->pxNextFreeBlock;
                }

                /* If the end marker was reached then a block of adequate size
                 * was not found. */
                if( pxBlock != pxEnd )
                {
                    /* Return the memory space pointed to - jumping over the
                     * BlockLink_t structure at its start. */
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );

                    /* This block is being returned for use so must be taken out
                     * of the list of free blocks. */
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;

                    /* If the block is larger than required it can be split into
                     * two. */
                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
                    {
                        /* This block is to be split into two.  Create a new
                         * block following the number of bytes requested. The void
                         * cast is used to prevent byte alignment warnings from the
                         * compiler. */
                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
                        configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

                        /* Calculate the sizes of two blocks split from the
                         * single block. */
                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
                        pxBlock->xBlockSize = xWantedSize;

                        /* Insert the new block into the list of free blocks. */
                        prvInsertBlockIntoFreeList( pxNewBlockLink );
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    xFreeBytesRemaining -= pxBlock->xBlockSize;

                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
                    {
                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* The block is being returned - it is allocated and owned
                     * by the application and has no ""next"" block. */
                    pxBlock->xBlockSize |= xBlockAllocatedBit;
                    pxBlock->pxNextFreeBlock = NULL;
                    xNumberOfSuccessfulAllocations++;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();

    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )
        {
            if( pvReturn == NULL )
            {
                extern void vApplicationMallocFailedHook( void );
                vApplicationMallocFailedHook();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */

    configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
    return pvReturn;
}","void * pvPortMalloc( size_t VAR_0 )
{
    BlockLink_t * VAR_1, * VAR_2, * VAR_3;
    void * VAR_4 = NULL;

    vTaskSuspendAll();
    {
        /* COMMENT_0 */
                                                              
        if( VAR_5 == NULL )
        {
            prvHeapInit();
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        /* COMMENT_2 */
                                                                                  
                                                                           
                                         
        if( ( VAR_0 & VAR_6 ) == 0 )
        {
            /* COMMENT_6 */
                                                                         
            if( ( VAR_0 > 0 ) && 
                ( ( VAR_0 + VAR_7 ) >  VAR_0 ) ) /* COMMENT_8 */
            {
                VAR_0 += VAR_7;

                /* COMMENT_9 */
                if( ( VAR_0 & VAR_8 ) != 0x00 )
                {
                    /* COMMENT_10 */
                    if( ( VAR_0 + ( VAR_9 - ( VAR_0 & VAR_8 ) ) ) 
                            > VAR_0 )
                    {
                        VAR_0 += ( VAR_9 - ( VAR_0 & VAR_8 ) );
                        configASSERT( ( VAR_0 & VAR_8 ) == 0 );
                    }
                    else
                    {
                        VAR_0 = 0;
                    }  
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            } 
            else 
            {
                VAR_0 = 0;
            }

            if( ( VAR_0 > 0 ) && ( VAR_0 <= VAR_10 ) )
            {
                /* COMMENT_11 */
                                                    
                VAR_2 = &VAR_11;
                VAR_1 = VAR_11.pxNextFreeBlock;

                while( ( VAR_1->xBlockSize < VAR_0 ) && ( VAR_1->pxNextFreeBlock != NULL ) )
                {
                    VAR_2 = VAR_1;
                    VAR_1 = VAR_1->pxNextFreeBlock;
                }

                /* COMMENT_13 */
                                    
                if( VAR_1 != VAR_5 )
                {
                    /* COMMENT_15 */
                                                             
                    VAR_4 = ( void * ) ( ( ( uint8_t * ) VAR_2->pxNextFreeBlock ) + VAR_7 );

                    /* COMMENT_17 */
                                                     
                    VAR_2->pxNextFreeBlock = VAR_1->pxNextFreeBlock;

                    /* COMMENT_19 */
                              
                    if( ( VAR_1->xBlockSize - VAR_0 ) > VAR_12 )
                    {
                        /* COMMENT_21 */
                                                                                  
                                                                                   
                                       
                        VAR_3 = ( void * ) ( ( ( uint8_t * ) VAR_1 ) + VAR_0 );
                        configASSERT( ( ( ( size_t ) VAR_3 ) & VAR_8 ) == 0 );

                        /* COMMENT_25 */
                                           
                        VAR_3->xBlockSize = VAR_1->xBlockSize - VAR_0;
                        VAR_1->xBlockSize = VAR_0;

                        /* COMMENT_27 */
                        prvInsertBlockIntoFreeList( VAR_3 );
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    VAR_10 -= VAR_1->xBlockSize;

                    if( VAR_10 < VAR_13 )
                    {
                        VAR_13 = VAR_10;
                    }
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* COMMENT_28 */
                                                                     
                    VAR_1->xBlockSize |= VAR_6;
                    VAR_1->pxNextFreeBlock = NULL;
                    VAR_14++;
                }
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        traceMALLOC( VAR_4, VAR_0 );
    }
    ( void ) xTaskResumeAll();

    #if ( VAR_15 == 1 )
        {
            if( VAR_4 == NULL )
            {
                extern void vApplicationMallocFailedHook( void );
                vApplicationMallocFailedHook();
            }
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* COMMENT_30 */

    configASSERT( ( ( ( size_t ) VAR_4 ) & ( size_t ) VAR_8 ) == 0 );
    return VAR_4;
}",FreeRTOS/FreeRTOS-Kernel/c7a9a01c94987082b223d3e59969ede64363da63/heap_4.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -22,34 +22,42 @@
          * kernel, so it must be free. */
         if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
         {
-            /* The wanted size is increased so it can contain a BlockLink_t
+            /* The wanted size must be increased so it can contain a BlockLink_t
              * structure in addition to the requested amount of bytes. */
-            if( xWantedSize > 0 )
+            if( ( xWantedSize > 0 ) && 
+                ( ( xWantedSize + xHeapStructSize ) >  xWantedSize ) ) /* Overflow check */
             {
                 xWantedSize += xHeapStructSize;
 
-                /* Ensure that blocks are always aligned to the required number
-                 * of bytes. */
+                /* Ensure that blocks are always aligned. */
                 if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
                 {
-                    /* Byte alignment required. */
-                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
-                    configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
+                    /* Byte alignment required. Check for overflow. */
+                    if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) 
+                            > xWantedSize )
+                    {
+                        xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
+                        configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
+                    }
+                    else
+                    {
+                        xWantedSize = 0;
+                    }  
                 }
                 else
                 {
                     mtCOVERAGE_TEST_MARKER();
                 }
-            }
-            else
+            } 
+            else 
             {
-                mtCOVERAGE_TEST_MARKER();
+                xWantedSize = 0;
             }
 
             if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
             {
                 /* Traverse the list from the start	(lowest address) block until
-                 * one	of adequate size is found. */
+                 * one of adequate size is found. */
                 pxPreviousBlock = &xStart;
                 pxBlock = xStart.pxNextFreeBlock;
 
@@ -60,7 +68,7 @@
                 }
 
                 /* If the end marker was reached then a block of adequate size
-                 * was	not found. */
+                 * was not found. */
                 if( pxBlock != pxEnd )
                 {
                     /* Return the memory space pointed to - jumping over the","{'deleted_lines': ['            /* The wanted size is increased so it can contain a BlockLink_t', '            if( xWantedSize > 0 )', '                /* Ensure that blocks are always aligned to the required number', '                 * of bytes. */', '                    /* Byte alignment required. */', '                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );', '                    configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );', '            }', '            else', '                mtCOVERAGE_TEST_MARKER();', '                 * one\tof adequate size is found. */', '                 * was\tnot found. */'], 'added_lines': ['            /* The wanted size must be increased so it can contain a BlockLink_t', '            if( ( xWantedSize > 0 ) && ', '                ( ( xWantedSize + xHeapStructSize ) >  xWantedSize ) ) /* Overflow check */', '                /* Ensure that blocks are always aligned. */', '                    /* Byte alignment required. Check for overflow. */', '                    if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) ', '                            > xWantedSize )', '                    {', '                        xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );', '                        configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );', '                    }', '                    else', '                    {', '                        xWantedSize = 0;', '                    }  ', '            } ', '            else ', '                xWantedSize = 0;', '                 * one of adequate size is found. */', '                 * was not found. */']}",True,The kernel in Amazon Web Services FreeRTOS before 10.4.3 has insufficient bounds checking during management of heap memory.,9.8,CRITICAL,3,valid,2020-12-07T18:36:27Z,3
CVE-2021-31572,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,FreeRTOS/FreeRTOS-Kernel,Add addition overflow check for stream buffer (#226),d05b9c123f2bf9090bce386a244fc934ae44db5b,https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/d05b9c123f2bf9090bce386a244fc934ae44db5b,stream_buffer.c,xStreamBufferGenericCreate,"StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
size_t xTriggerLevelBytes,
BaseType_t xIsMessageBuffer )
{
uint8_t * pucAllocatedMemory;
uint8_t ucFlags;
if( xIsMessageBuffer == pdTRUE )
{
ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
}
else
{
ucFlags = 0;
configASSERT( xBufferSizeBytes > 0 );
}
configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
if( xTriggerLevelBytes == ( size_t ) 0 )
{
xTriggerLevelBytes = ( size_t ) 1;
}
xBufferSizeBytes++;
pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); 
if( pucAllocatedMemory != NULL )
{
prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,         
pucAllocatedMemory + sizeof( StreamBuffer_t ),  
xBufferSizeBytes,
xTriggerLevelBytes,
ucFlags );
traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );
}
else
{
traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
}
return ( StreamBufferHandle_t ) pucAllocatedMemory; 
}","StreamBufferHandle_t xStreamBufferGenericCreate( size_t VAR_0,
size_t VAR_1,
BaseType_t VAR_2 )
{
uint8_t * VAR_3;
uint8_t VAR_4;
if( VAR_2 == VAR_5 )
{
VAR_4 = VAR_6;
configASSERT( VAR_0 > VAR_7 );
}
else
{
VAR_4 = 0;
configASSERT( VAR_0 > 0 );
}
configASSERT( VAR_1 <= VAR_0 );
if( VAR_1 == ( size_t ) 0 )
{
VAR_1 = ( size_t ) 1;
}
VAR_0++;
VAR_3 = ( uint8_t * ) pvPortMalloc( VAR_0 + sizeof( VAR_8 ) ); 
if( VAR_3 != NULL )
{
prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) VAR_3,         
VAR_3 + sizeof( StreamBuffer_t ),  
VAR_0,
VAR_1,
VAR_4 );
traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) VAR_3 ), VAR_2 );
}
else
{
traceSTREAM_BUFFER_CREATE_FAILED( VAR_2 );
}
return ( StreamBufferHandle_t ) VAR_3; 
}",FreeRTOS/FreeRTOS-Kernel/d05b9c123f2bf9090bce386a244fc934ae44db5b/stream_buffer.c/vul/before/0.json,"StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                     size_t xTriggerLevelBytes,
                                                     BaseType_t xIsMessageBuffer )
    {
        uint8_t * pucAllocatedMemory;
        uint8_t ucFlags;

        /* In case the stream buffer is going to be used as a message buffer
         * (that is, it will hold discrete messages with a little meta data that
         * says how big the next message is) check the buffer will be large enough
         * to hold at least one message. */
        if( xIsMessageBuffer == pdTRUE )
        {
            /* Is a message buffer but not statically allocated. */
            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
        }
        else
        {
            /* Not a message buffer and not statically allocated. */
            ucFlags = 0;
            configASSERT( xBufferSizeBytes > 0 );
        }

        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

        /* A trigger level of 0 would cause a waiting task to unblock even when
         * the buffer was empty. */
        if( xTriggerLevelBytes == ( size_t ) 0 )
        {
            xTriggerLevelBytes = ( size_t ) 1;
        }

        /* A stream buffer requires a StreamBuffer_t structure and a buffer.
         * Both are allocated in a single call to pvPortMalloc().  The
         * StreamBuffer_t structure is placed at the start of the allocated memory
         * and the buffer follows immediately after.  The requested size is
         * incremented so the free space is returned as the user would expect -
         * this is a quirk of the implementation that means otherwise the free
         * space would be reported as one byte smaller than would be logically
         * expected. */
        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
        {
            xBufferSizeBytes++;
            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
        }
        else
        {
            pucAllocatedMemory = NULL;
        }
        

        if( pucAllocatedMemory != NULL )
        {
            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
                                          pucAllocatedMemory + sizeof( StreamBuffer_t ), /* Storage area follows. */ /*lint !e9016 Indexing past structure valid for uint8_t pointer, also storage area has no alignment requirement. */
                                          xBufferSizeBytes,
                                          xTriggerLevelBytes,
                                          ucFlags );

            traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );
        }
        else
        {
            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
        }

        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    }","StreamBufferHandle_t xStreamBufferGenericCreate( size_t VAR_0,
                                                     size_t VAR_1,
                                                     BaseType_t VAR_2 )
    {
        uint8_t * VAR_3;
        uint8_t VAR_4;

        /* COMMENT_0 */
                                                                                
                                                                                  
                                           
        if( VAR_2 == VAR_5 )
        {
            /* COMMENT_4 */
            VAR_4 = VAR_6;
            configASSERT( VAR_0 > VAR_7 );
        }
        else
        {
            /* COMMENT_5 */
            VAR_4 = 0;
            configASSERT( VAR_0 > 0 );
        }

        configASSERT( VAR_1 <= VAR_0 );

        /* COMMENT_6 */
                                   
        if( VAR_1 == ( size_t ) 0 )
        {
            VAR_1 = ( size_t ) 1;
        }

        /* COMMENT_8 */
                                                                      
                                                                                  
                                                                           
                                                                               
                                                                              
                                                                              
                       
        if( VAR_0 < ( VAR_0 + 1 + sizeof( VAR_8 ) ) )
        {
            VAR_0++;
            VAR_3 = ( uint8_t * ) pvPortMalloc( VAR_0 + sizeof( VAR_8 ) ); /* COMMENT_16 */
        }
        else
        {
            VAR_3 = NULL;
        }
        

        if( VAR_3 != NULL )
        {
            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) VAR_3,       /* COMMENT_17 */ /* COMMENT_18 */ /* COMMENT_19 */
                                          VAR_3 + sizeof( StreamBuffer_t ), /* COMMENT_20 */ /* COMMENT_21 */
                                          VAR_0,
                                          VAR_1,
                                          VAR_4 );

            traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) VAR_3 ), VAR_2 );
        }
        else
        {
            traceSTREAM_BUFFER_CREATE_FAILED( VAR_2 );
        }

        return ( StreamBufferHandle_t ) VAR_3; /* COMMENT_22 */
    }",FreeRTOS/FreeRTOS-Kernel/d05b9c123f2bf9090bce386a244fc934ae44db5b/stream_buffer.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -39,8 +39,16 @@
          * this is a quirk of the implementation that means otherwise the free
          * space would be reported as one byte smaller than would be logically
          * expected. */
-        xBufferSizeBytes++;
-        pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
+        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
+        {
+            xBufferSizeBytes++;
+            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
+        }
+        else
+        {
+            pucAllocatedMemory = NULL;
+        }
+        
 
         if( pucAllocatedMemory != NULL )
         {","{'deleted_lines': ['        xBufferSizeBytes++;', '        pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */'], 'added_lines': ['        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )', '        {', '            xBufferSizeBytes++;', '            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */', '        }', '        else', '        {', '            pucAllocatedMemory = NULL;', '        }', '        ']}",True,The kernel in Amazon Web Services FreeRTOS before 10.4.3 has an integer overflow in stream_buffer.c for a stream buffer.,9.8,CRITICAL,3,valid,2020-12-07T19:07:31Z,3
CVE-2020-35980,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,gpac,fixed #1661,5aba27604d957e960d8069d85ccaf868f8a7b07a,https://github.com/gpac/gpac/commit/5aba27604d957e960d8069d85ccaf868f8a7b07a,src/isomedia/isom_store.c,CleanWriters,"void CleanWriters(GF_List *writers)
{
while (gf_list_count(writers)) {
TrackWriter *writer = (TrackWriter*)gf_list_get(writers, 0);
gf_isom_box_del(writer->stco);
gf_isom_box_del((GF_Box *)writer->stsc);
gf_free(writer);
gf_list_rem(writers, 0);
}
}","void CleanWriters(GF_List *VAR_0)
{
while (gf_list_count(VAR_0)) {
TrackWriter *VAR_1 = (TrackWriter*)gf_list_get(VAR_0, 0);
gf_isom_box_del(VAR_1->stco);
gf_isom_box_del((GF_Box *)VAR_1->stsc);
gf_free(VAR_1);
gf_list_rem(VAR_0, 0);
}
}",gpac/5aba27604d957e960d8069d85ccaf868f8a7b07a/isom_store.c/vul/before/0.json,"void CleanWriters(GF_List *writers)
{
	while (gf_list_count(writers)) {
		TrackWriter *writer = (TrackWriter*)gf_list_get(writers, 0);
		//in case we have an error in the middle of file write, remove our created stco and stsc from sample table
		gf_list_del_item(writer->stbl->child_boxes, writer->stco);
		gf_list_del_item(writer->stbl->child_boxes, writer->stsc);
		gf_isom_box_del(writer->stco);
		gf_isom_box_del((GF_Box *)writer->stsc);
		gf_free(writer);
		gf_list_rem(writers, 0);
	}
}","void CleanWriters(GF_List *VAR_0)
{
	while (gf_list_count(VAR_0)) {
		TrackWriter *VAR_1 = (TrackWriter*)gf_list_get(VAR_0, 0);
		/* COMMENT_0 */
		gf_list_del_item(VAR_1->stbl->child_boxes, VAR_1->stco);
		gf_list_del_item(VAR_1->stbl->child_boxes, VAR_1->stsc);
		gf_isom_box_del(VAR_1->stco);
		gf_isom_box_del((GF_Box *)VAR_1->stsc);
		gf_free(VAR_1);
		gf_list_rem(VAR_0, 0);
	}
}",gpac/5aba27604d957e960d8069d85ccaf868f8a7b07a/isom_store.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,6 +2,9 @@
 {
 	while (gf_list_count(writers)) {
 		TrackWriter *writer = (TrackWriter*)gf_list_get(writers, 0);
+		//in case we have an error in the middle of file write, remove our created stco and stsc from sample table
+		gf_list_del_item(writer->stbl->child_boxes, writer->stco);
+		gf_list_del_item(writer->stbl->child_boxes, writer->stsc);
 		gf_isom_box_del(writer->stco);
 		gf_isom_box_del((GF_Box *)writer->stsc);
 		gf_free(writer);","{'deleted_lines': [], 'added_lines': ['\t\t//in case we have an error in the middle of file write, remove our created stco and stsc from sample table', '\t\tgf_list_del_item(writer->stbl->child_boxes, writer->stco);', '\t\tgf_list_del_item(writer->stbl->child_boxes, writer->stsc);']}",True,An issue was discovered in GPAC version 0.8.0 and 1.0.1. There is a use-after-free in the function gf_isom_box_del() in isomedia/box_funcs.c.,7.8,HIGH,2,valid,2021-01-04T10:18:27Z,3
CVE-2021-40330,['CWE-Other'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0,git,"git_connect_git(): forbid newlines in host and path

When we connect to a git:// server, we send an initial request that
looks something like:

  002dgit-upload-pack repo.git\0host=example.com

If the repo path contains a newline, then it's included literally, and
we get:

  002egit-upload-pack repo
  .git\0host=example.com

This works fine if you really do have a newline in your repository name;
the server side uses the pktline framing to parse the string, not
newlines. However, there are many _other_ protocols in the wild that do
parse on newlines, such as HTTP. So a carefully constructed git:// URL
can actually turn into a valid HTTP request. For example:

  git://localhost:1234/%0d%0a%0d%0aGET%20/%20HTTP/1.1 %0d%0aHost:localhost%0d%0a%0d%0a

becomes:

  0050git-upload-pack /
  GET / HTTP/1.1
  Host:localhost

  host=localhost:1234

on the wire. Again, this isn't a problem for a real Git server, but it
does mean that feeding a malicious URL to Git (e.g., through a
submodule) can cause it to make unexpected cross-protocol requests.
Since repository names with newlines are presumably quite rare (and
indeed, we already disallow them in git-over-http), let's just disallow
them over this protocol.

Hostnames could likewise inject a newline, but this is unlikely a
problem in practice; we'd try resolving the hostname with a newline in
it, which wouldn't work. Still, it doesn't hurt to err on the side of
caution there, since we would not expect them to work in the first
place.

The ssh and local code paths are unaffected by this patch. In both cases
we're trying to run upload-pack via a shell, and will quote the newline
so that it makes it intact. An attacker can point an ssh url at an
arbitrary port, of course, but unless there's an actual ssh server
there, we'd never get as far as sending our shell command anyway.  We
_could_ similarly restrict newlines in those protocols out of caution,
but there seems little benefit to doing so.

The new test here is run alongside the git-daemon tests, which cover the
same protocol, but it shouldn't actually contact the daemon at all.  In
theory we could make the test more robust by setting up an actual
repository with a newline in it (so that our clone would succeed if our
new check didn't kick in). But a repo directory with newline in it is
likely not portable across all filesystems. Likewise, we could check
git-daemon's log that it was not contacted at all, but we do not
currently record the log (and anyway, it would make the test racy with
the daemon's log write). We'll just check the client-side stderr to make
sure we hit the expected code path.

Reported-by: Harold Kim <h.kim@flatt.tech>
Signed-off-by: Jeff King <peff@peff.net>
Signed-off-by: Junio C Hamano <gitster@pobox.com>",a02ea577174ab8ed18f847cf1693f213e0b9c473,https://github.com/git/git/commit/a02ea577174ab8ed18f847cf1693f213e0b9c473,connect.c,git_connect_git,"static struct child_process *git_connect_git(int fd[2], char *hostandport,
const char *path, const char *prog,
enum protocol_version version,
int flags)
{
struct child_process *conn;
struct strbuf request = STRBUF_INIT;
char *target_host = getenv(""GIT_OVERRIDE_VIRTUAL_HOST"");
if (target_host)
target_host = xstrdup(target_host);
else
target_host = xstrdup(hostandport);
transport_check_allowed(""git"");
if (git_use_proxy(hostandport))
conn = git_proxy_connect(fd, hostandport);
else
conn = git_tcp_connect(fd, hostandport, flags);
strbuf_addf(&request,
""%s %s%chost=%s%c"",
prog, path, 0,
target_host, 0);
if (version > 0) {
strbuf_addch(&request, '\0');
strbuf_addf(&request, ""version=%d%c"",
version, '\0');
}
packet_write(fd[1], request.buf, request.len);
free(target_host);
strbuf_release(&request);
return conn;
}","static struct child_process *git_connect_git(int VAR_0[2], char *VAR_1,
const char *VAR_2, const char *VAR_3,
enum protocol_version VAR_4,
int VAR_5)
{
struct child_process *VAR_6;
struct strbuf VAR_7 = VAR_8;
char *VAR_9 = getenv(""GIT_OVERRIDE_VIRTUAL_HOST"");
if (VAR_9)
VAR_9 = xstrdup(VAR_9);
else
VAR_9 = xstrdup(VAR_1);
transport_check_allowed(""git"");
if (git_use_proxy(VAR_1))
VAR_6 = git_proxy_connect(VAR_0, VAR_1);
else
VAR_6 = git_tcp_connect(VAR_0, VAR_1, VAR_5);
strbuf_addf(&VAR_7,
""%s %s%chost=%s%c"",
VAR_3, VAR_2, 0,
VAR_9, 0);
if (VAR_4 > 0) {
strbuf_addch(&VAR_7, '\0');
strbuf_addf(&VAR_7, ""version=%d%c"",
VAR_4, '\0');
}
packet_write(VAR_0[1], VAR_7.buf, VAR_7.len);
free(VAR_9);
strbuf_release(&VAR_7);
return VAR_6;
}",git/a02ea577174ab8ed18f847cf1693f213e0b9c473/connect.c/vul/before/0.json,"static struct child_process *git_connect_git(int fd[2], char *hostandport,
					     const char *path, const char *prog,
					     enum protocol_version version,
					     int flags)
{
	struct child_process *conn;
	struct strbuf request = STRBUF_INIT;
	/*
	 * Set up virtual host information based on where we will
	 * connect, unless the user has overridden us in
	 * the environment.
	 */
	char *target_host = getenv(""GIT_OVERRIDE_VIRTUAL_HOST"");
	if (target_host)
		target_host = xstrdup(target_host);
	else
		target_host = xstrdup(hostandport);

	transport_check_allowed(""git"");
	if (strchr(target_host, '\n') || strchr(path, '\n'))
		die(_(""newline is forbidden in git:// hosts and repo paths""));

	/*
	 * These underlying connection commands die() if they
	 * cannot connect.
	 */
	if (git_use_proxy(hostandport))
		conn = git_proxy_connect(fd, hostandport);
	else
		conn = git_tcp_connect(fd, hostandport, flags);
	/*
	 * Separate original protocol components prog and path
	 * from extended host header with a NUL byte.
	 *
	 * Note: Do not add any other headers here!  Doing so
	 * will cause older git-daemon servers to crash.
	 */
	strbuf_addf(&request,
		    ""%s %s%chost=%s%c"",
		    prog, path, 0,
		    target_host, 0);

	/* If using a new version put that stuff here after a second null byte */
	if (version > 0) {
		strbuf_addch(&request, '\0');
		strbuf_addf(&request, ""version=%d%c"",
			    version, '\0');
	}

	packet_write(fd[1], request.buf, request.len);

	free(target_host);
	strbuf_release(&request);
	return conn;
}","static struct child_process *git_connect_git(int VAR_0[2], char *VAR_1,
					     const char *VAR_2, const char *VAR_3,
					     enum protocol_version VAR_4,
					     int VAR_5)
{
	struct child_process *VAR_6;
	struct strbuf VAR_7 = VAR_8;
	/* COMMENT_0 */
                                                          
                                                 
                    
    
	char *VAR_9 = getenv(""GIT_OVERRIDE_VIRTUAL_HOST"");
	if (VAR_9)
		VAR_9 = xstrdup(VAR_9);
	else
		VAR_9 = xstrdup(VAR_1);

	transport_check_allowed(""git"");
	if (strchr(VAR_9, '\n') || strchr(VAR_2, '\n'))
		die(_(""newline is forbidden in git:// hosts and repo paths""));

	/* COMMENT_5 */
                                                      
                   
    
	if (git_use_proxy(VAR_1))
		VAR_6 = git_proxy_connect(VAR_0, VAR_1);
	else
		VAR_6 = git_tcp_connect(VAR_0, VAR_1, VAR_5);
	/* COMMENT_9 */
                                                       
                                              
   
                                                      
                                                 
    
	strbuf_addf(&VAR_7,
		    ""%s %s%chost=%s%c"",
		    VAR_3, VAR_2, 0,
		    VAR_9, 0);

	/* COMMENT_16 */
	if (VAR_4 > 0) {
		strbuf_addch(&VAR_7, '\0');
		strbuf_addf(&VAR_7, ""version=%d%c"",
			    VAR_4, '\0');
	}

	packet_write(VAR_0[1], VAR_7.buf, VAR_7.len);

	free(VAR_9);
	strbuf_release(&VAR_7);
	return VAR_6;
}",git/a02ea577174ab8ed18f847cf1693f213e0b9c473/connect.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,6 +17,8 @@
 		target_host = xstrdup(hostandport);
 
 	transport_check_allowed(""git"");
+	if (strchr(target_host, '\n') || strchr(path, '\n'))
+		die(_(""newline is forbidden in git:// hosts and repo paths""));
 
 	/*
 	 * These underlying connection commands die() if they","{'deleted_lines': [], 'added_lines': [""\tif (strchr(target_host, '\\n') || strchr(path, '\\n'))"", '\t\tdie(_(""newline is forbidden in git:// hosts and repo paths""));']}",True,"git_connect_git in connect.c in Git before 2.30.1 allows a repository path to contain a newline character, which may result in unexpected cross-protocol requests, as demonstrated by the git://localhost:1234/%0d%0a%0d%0aGET%20/%20HTTP/1.1 substring.",7.5,HIGH,2,valid,2021-01-07T09:43:58Z,3
CVE-2021-3236,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,vim,"patch 8.2.2354: crash with a weird combination of autocommands

Problem:    Crash with a weird combination of autocommands.
Solution:   Increment b_nwindows when needed. (closes #7674)",797e63b9f2baa1853e7063aac478d663cd02f207,https://github.com/vim/vim/commit/797e63b9f2baa1853e7063aac478d663cd02f207,src/ex_cmds.c,do_ecmd,"int
do_ecmd(
intfnum,
char_u*ffname,
char_u*sfname,
exarg_T*eap,    linenr_Tnewlnum,
intflags,
win_T*oldwin)
{
intother_file;    intoldbuf;    intauto_buf = FALSE;    char_u*new_name = NULL;
#if defined(FEAT_EVAL)
intdid_set_swapcommand = FALSE;
#endif
buf_T*buf;
bufref_Tbufref;
bufref_Told_curbuf;
char_u*free_fname = NULL;
#ifdef FEAT_BROWSE
char_udot_path[] = ""."";
char_u*browse_file = NULL;
#endif
intretval = FAIL;
longn;
pos_Torig_pos;
linenr_Ttopline = 0;
intnewcol = -1;
intsolcol = -1;
pos_T*pos;
char_u*command = NULL;
#ifdef FEAT_SPELL
intdid_get_winopts = FALSE;
#endif
intreadfile_flags = 0;
intdid_inc_redrawing_disabled = FALSE;
long        *so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;
#ifdef FEAT_PROP_POPUP
if (ERROR_IF_TERM_POPUP_WINDOW)
return FAIL;
#endif
if (eap != NULL)
command = eap->do_ecmd_cmd;
set_bufref(&old_curbuf, curbuf);
if (fnum != 0)
{
if (fnum == curbuf->b_fnum)    return OK;other_file = TRUE;
}
else
{
#ifdef FEAT_BROWSE
if ((cmdmod.cmod_flags & CMOD_BROWSE) && !exiting)
{
if (
# ifdef FEAT_GUI
!gui.in_use &&
# endif
au_has_group((char_u *)""FileExplorer""))
{
if (ffname == NULL || !mch_isdir(ffname))
ffname = dot_path;
}
else
{
browse_file = do_browse(0, (char_u *)_(""Edit File""), ffname,
NULL, NULL, NULL, curbuf);
if (browse_file == NULL)
goto theend;
ffname = browse_file;
}
}
#endif
if (sfname == NULL)
sfname = ffname;
#ifdef USE_FNAME_CASE
if (sfname != NULL)
fname_case(sfname, 0);   #endif
if ((flags & (ECMD_ADDBUF | ECMD_ALTBUF))
&& (ffname == NULL || *ffname == NUL))
goto theend;
if (ffname == NULL)
other_file = TRUE;
else if (*ffname == NUL && curbuf->b_ffname == NULL)
other_file = FALSE;
else
{
if (*ffname == NUL)        {
ffname = curbuf->b_ffname;
sfname = curbuf->b_fname;
}
free_fname = fix_fname(ffname);     if (free_fname != NULL)
ffname = free_fname;
other_file = otherfile(ffname);
}
}
if (  ((!other_file && !(flags & ECMD_OLDBUF))
|| (curbuf->b_nwindows == 1
&& !(flags & (ECMD_HIDE | ECMD_ADDBUF | ECMD_ALTBUF))))
&& check_changed(curbuf, (p_awa ? CCGD_AW : 0)
| (other_file ? 0 : CCGD_MULTWIN)
| ((flags & ECMD_FORCEIT) ? CCGD_FORCEIT : 0)
| (eap == NULL ? 0 : CCGD_EXCMD)))
{
if (fnum == 0 && other_file && ffname != NULL)
(void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);
goto theend;
}
reset_VIsual();
#if defined(FEAT_EVAL)
if ((command != NULL || newlnum > (linenr_T)0)
&& *get_vim_var_str(VV_SWAPCOMMAND) == NUL)
{
intlen;
char_u*p;
if (command != NULL)
len = (int)STRLEN(command) + 3;
else
len = 30;
p = alloc(len);
if (p != NULL)
{
if (command != NULL)
vim_snprintf((char *)p, len, "":%s\r"", command);
else
vim_snprintf((char *)p, len, ""%ldG"", (long)newlnum);
set_vim_var_string(VV_SWAPCOMMAND, p, -1);
did_set_swapcommand = TRUE;
vim_free(p);
}
}
#endif
if (other_file)
{
if (!(flags & (ECMD_ADDBUF | ECMD_ALTBUF)))
{
if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)
curwin->w_alt_fnum = curbuf->b_fnum;
if (oldwin != NULL)
buflist_altfpos(oldwin);
}
if (fnum)
buf = buflist_findnr(fnum);
else
{
if (flags & (ECMD_ADDBUF | ECMD_ALTBUF))
{
linenr_Ttlnum = 0;
buf_T*newbuf;
if (command != NULL)
{
tlnum = atol((char *)command);
if (tlnum <= 0)
tlnum = 1L;
}
newbuf = buflist_new(ffname, sfname, tlnum,
BLN_LISTED | BLN_NOCURWIN);
if (newbuf != NULL && (flags & ECMD_ALTBUF))
curwin->w_alt_fnum = newbuf->b_fnum;
goto theend;
}
buf = buflist_new(ffname, sfname, 0L,
BLN_CURBUF | ((flags & ECMD_SET_HELP) ? 0 : BLN_LISTED));
if (oldwin != NULL)
oldwin = curwin;
set_bufref(&old_curbuf, curbuf);
}
if (buf == NULL)
goto theend;
if (buf->b_ml.ml_mfp == NULL){
oldbuf = FALSE;
}
else{
oldbuf = TRUE;
set_bufref(&bufref, buf);
(void)buf_check_timestamp(buf, FALSE);
if (!bufref_valid(&bufref) || curbuf != old_curbuf.br_buf)
goto theend;
#ifdef FEAT_EVAL
if (aborting())    goto theend;
#endif
}
if ((oldbuf && newlnum == ECMD_LASTL) || newlnum == ECMD_LAST)
{
pos = buflist_findfpos(buf);
newlnum = pos->lnum;
solcol = pos->col;
}
if (buf != curbuf)
{
if (buf->b_fname != NULL)
new_name = vim_strsave(buf->b_fname);
set_bufref(&au_new_curbuf, buf);
apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);
if (!bufref_valid(&au_new_curbuf))
{
delbuf_msg(new_name);goto theend;
}
#ifdef FEAT_EVAL
if (aborting())        {
vim_free(new_name);
goto theend;
}
#endif
if (buf == curbuf)auto_buf = TRUE;
else
{
win_T    *the_curwin = curwin;
the_curwin->w_closing = TRUE;
++buf->b_locked;
if (curbuf == old_curbuf.br_buf)
buf_copy_options(buf, BCO_ENTER);
u_sync(FALSE);
close_buffer(oldwin, curbuf,
(flags & ECMD_HIDE) ? 0 : DOBUF_UNLOAD, FALSE, FALSE);
the_curwin->w_closing = FALSE;
--buf->b_locked;
#ifdef FEAT_EVAL
if (aborting() && curwin->w_buffer != NULL)
{
vim_free(new_name);
goto theend;
}
#endif
if (!bufref_valid(&au_new_curbuf))
{
delbuf_msg(new_name);    goto theend;
}
if (buf == curbuf)    auto_buf = TRUE;
else
{
#ifdef FEAT_SYN_HL
if (curwin->w_buffer == NULL
|| curwin->w_s == &(curwin->w_buffer->b_s))
curwin->w_s = &(buf->b_s);
#endif
curwin->w_buffer = buf;
curbuf = buf;
++curbuf->b_nwindows;
if (!oldbuf && eap != NULL)
{
set_file_options(TRUE, eap);
set_forced_fenc(eap);
}
}
get_winopts(curbuf);
#ifdef FEAT_SPELL
did_get_winopts = TRUE;
#endif
}
vim_free(new_name);
au_new_curbuf.br_buf = NULL;
au_new_curbuf.br_buf_free_count = 0;
}
curwin->w_pcmark.lnum = 1;
curwin->w_pcmark.col = 0;
}
else     {
if ((flags & (ECMD_ADDBUF | ECMD_ALTBUF)) || check_fname() == FAIL)
goto theend;
oldbuf = (flags & ECMD_OLDBUF);
}
++RedrawingDisabled;
did_inc_redrawing_disabled = TRUE;
buf = curbuf;
if ((flags & ECMD_SET_HELP) || keep_help_flag)
{
prepare_help_buffer();
}
else
{
if (!curbuf->b_help)
set_buflisted(TRUE);
}
if (buf != curbuf)
goto theend;
#ifdef FEAT_EVAL
if (aborting())    goto theend;
#endif
did_filetype = FALSE;
if (!other_file && !oldbuf)    {
set_last_cursor(curwin);if (newlnum == ECMD_LAST || newlnum == ECMD_LASTL)
{
newlnum = curwin->w_cursor.lnum;
solcol = curwin->w_cursor.col;
}
buf = curbuf;
if (buf->b_fname != NULL)
new_name = vim_strsave(buf->b_fname);
else
new_name = NULL;
set_bufref(&bufref, buf);
if (!(curbuf->b_flags & BF_NEVERLOADED)
&& (p_ur < 0 || curbuf->b_ml.ml_line_count <= p_ur))
{
u_sync(FALSE);
if (u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE)
== FAIL)
{
vim_free(new_name);
goto theend;
}
u_unchanged(curbuf);
buf_freeall(curbuf, BFA_KEEP_UNDO);
readfile_flags = READ_KEEP_UNDO;
}
else
buf_freeall(curbuf, 0);   
if (!bufref_valid(&bufref))
{
delbuf_msg(new_name);    goto theend;
}
vim_free(new_name);
if (buf != curbuf)
goto theend;
#ifdef FEAT_EVAL
if (aborting())        goto theend;
#endif
buf_clear_file(curbuf);
curbuf->b_op_start.lnum = 0;curbuf->b_op_end.lnum = 0;
}
retval = OK;
check_arg_idx(curwin);
if (!auto_buf)
{
curwin_init();
#ifdef FEAT_FOLDING
{
win_T    *win;
tabpage_T    *tp;
FOR_ALL_TAB_WINDOWS(tp, win)
if (win->w_buffer == curbuf)
foldUpdateAll(win);
}
#endif
DO_AUTOCHDIR;
orig_pos = curwin->w_cursor;
topline = curwin->w_topline;
if (!oldbuf)    {
#ifdef FEAT_PROP_POPUP
if (WIN_IS_POPUP(curwin))
curbuf->b_flags |= BF_NO_SEA;
#endif
swap_exists_action = SEA_DIALOG;
curbuf->b_flags |= BF_CHECK_RO; 
#if defined(FEAT_EVAL)
if (should_abort(open_buffer(FALSE, eap, readfile_flags)))
retval = FAIL;
#else
(void)open_buffer(FALSE, eap, readfile_flags);
#endif
#ifdef FEAT_PROP_POPUP
curbuf->b_flags &= ~BF_NO_SEA;
#endif
if (swap_exists_action == SEA_QUIT)
retval = FAIL;
handle_swap_exists(&old_curbuf);
}
else
{
do_modelines(OPT_WINONLY);
apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf,
&retval);
apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf,
&retval);
}
check_arg_idx(curwin);
if (!EQUAL_POS(curwin->w_cursor, orig_pos))
{
char_u *text = ml_get_curline();
if (curwin->w_cursor.lnum != orig_pos.lnum
|| curwin->w_cursor.col != (int)(skipwhite(text) - text))
{
newlnum = curwin->w_cursor.lnum;
newcol = curwin->w_cursor.col;
}
}
if (curwin->w_topline == topline)
topline = 0;
changed_line_abv_curs();
#ifdef FEAT_TITLE
maketitle();
#endif
#if defined(FEAT_PROP_POPUP) && defined(FEAT_QUICKFIX)
if (WIN_IS_POPUP(curwin) && curwin->w_p_pvw && retval != FAIL)
popup_set_title(curwin);
#endif
}
#ifdef FEAT_DIFF
if (curwin->w_p_diff)
{
diff_buf_add(curbuf);
diff_invalidate(curbuf);
}
#endif
#ifdef FEAT_SPELL
if (did_get_winopts && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)
(void)did_set_spelllang(curwin);
#endif
if (command == NULL)
{
if (newcol >= 0){
curwin->w_cursor.lnum = newlnum;
curwin->w_cursor.col = newcol;
check_cursor();
}
else if (newlnum > 0){
curwin->w_cursor.lnum = newlnum;
check_cursor_lnum();
if (solcol >= 0 && !p_sol)
{
curwin->w_cursor.col = solcol;
check_cursor_col();
curwin->w_cursor.coladd = 0;
curwin->w_set_curswant = TRUE;
}
else
beginline(BL_SOL | BL_FIX);
}
else{
if (exmode_active)
curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
beginline(BL_WHITE | BL_FIX);
}
}
check_lnums(FALSE);
if (oldbuf && !auto_buf)
{
intmsg_scroll_save = msg_scroll;
if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)
msg_scroll = FALSE;
if (!msg_scroll)    check_for_delay(FALSE);
msg_start();
msg_scroll = msg_scroll_save;
msg_scrolled_ign = TRUE;
if (!shortmess(SHM_FILEINFO))
fileinfo(FALSE, TRUE, FALSE);
msg_scrolled_ign = FALSE;
}
#ifdef FEAT_VIMINFO
curbuf->b_last_used = vim_time();
#endif
if (command != NULL)
do_cmdline(command, NULL, NULL, DOCMD_VERBOSE|DOCMD_RANGEOK);
#ifdef FEAT_KEYMAP
if (curbuf->b_kmap_state & KEYMAP_INIT)
(void)keymap_init();
#endif
--RedrawingDisabled;
did_inc_redrawing_disabled = FALSE;
if (!skip_redraw)
{
n = *so_ptr;
if (topline == 0 && command == NULL)
*so_ptr = 9999;update_topline();
curwin->w_scbind_pos = curwin->w_topline;
*so_ptr = n;
redraw_curbuf_later(NOT_VALID);    }
if (p_im)
need_start_insertmode = TRUE;
#ifdef FEAT_AUTOCHDIR
if (p_acd && curbuf->b_ffname != NULL)
{
char_ucurdir[MAXPATHL];
char_ufiledir[MAXPATHL];
vim_strncpy(filedir, curbuf->b_ffname, MAXPATHL - 1);
*gettail_sep(filedir) = NUL;
if (mch_dirname(curdir, MAXPATHL) != FAIL
&& vim_fnamecmp(curdir, filedir) != 0)
do_autochdir();
}
#endif
#if defined(FEAT_NETBEANS_INTG)
if (curbuf->b_ffname != NULL)
{
# ifdef FEAT_NETBEANS_INTG
if ((flags & ECMD_SET_HELP) != ECMD_SET_HELP)
netbeans_file_opened(curbuf);
# endif
}
#endif
theend:
if (did_inc_redrawing_disabled)
--RedrawingDisabled;
#if defined(FEAT_EVAL)
if (did_set_swapcommand)
set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);
#endif
#ifdef FEAT_BROWSE
vim_free(browse_file);
#endif
vim_free(free_fname);
return retval;
}","int
do_ecmd(
intVAR_0,
char_u*VAR_1,
char_u*VAR_2,
exarg_T*VAR_3,
linenr_TVAR_4,
intVAR_5,
win_T*VAR_6)
{
intVAR_7;
intVAR_8;
intVAR_9 = FALSE;
char_u*VAR_10 = NULL;
#if defined(VAR_11)
intVAR_12 = FALSE;
#endif
buf_T*VAR_13;
bufref_TVAR_14;
bufref_TVAR_15;
char_u*VAR_16 = NULL;
#ifdef VAR_17
char_uVAR_18[] = ""."";
char_u*VAR_19 = NULL;
#endif
intVAR_20 = VAR_21;
longVAR_22;
pos_TVAR_23;
linenr_TVAR_24 = 0;
intVAR_25 = -1;
intVAR_26 = -1;
pos_T*VAR_27;
char_u*VAR_28 = NULL;
#ifdef VAR_29
intVAR_30 = FALSE;
#endif
intVAR_31 = 0;
intVAR_32 = FALSE;
long        *VAR_33 = VAR_34->w_p_so >= 0 ? &VAR_34->w_p_so : &VAR_35;
#ifdef VAR_36
if (VAR_37)
return VAR_21;
#endif
if (VAR_3 != NULL)
VAR_28 = VAR_3->do_ecmd_cmd;
set_bufref(&VAR_15, VAR_38);
if (VAR_0 != 0)
{
if (VAR_0 == VAR_38->b_fnum)
return VAR_39;
VAR_7 = TRUE;
}
else
{
#ifdef VAR_17
if ((VAR_40.cmod_flags & VAR_41) && !VAR_42)
{
if (
# ifdef VAR_43
!VAR_44.in_use &&
# endif
au_has_group((char_u *)""FileExplorer""))
{
if (VAR_1 == NULL || !mch_isdir(VAR_1))
VAR_1 = VAR_18;
}
else
{
VAR_19 = do_browse(0, (char_u *)_(""Edit File""), VAR_1,
NULL, NULL, NULL, VAR_38);
if (VAR_19 == NULL)
goto theend;
VAR_1 = VAR_19;
}
}
#endif
if (VAR_2 == NULL)
VAR_2 = VAR_1;
#ifdef VAR_45
if (VAR_2 != NULL)
fname_case(VAR_2, 0);   
#endif
if ((VAR_5 & (VAR_46 | VAR_47))
&& (VAR_1 == NULL || *VAR_1 == VAR_48))
goto theend;
if (VAR_1 == NULL)
VAR_7 = TRUE;
else if (*VAR_1 == VAR_48 && VAR_38->b_ffname == NULL)
VAR_7 = FALSE;
else
{
if (*VAR_1 == VAR_48)    
{
VAR_1 = VAR_38->b_ffname;
VAR_2 = VAR_38->b_fname;
}
VAR_16 = fix_fname(VAR_1); 
if (VAR_16 != NULL)
VAR_1 = VAR_16;
VAR_7 = otherfile(VAR_1);
}
}
if (  ((!VAR_7 && !(VAR_5 & VAR_49))
|| (VAR_38->b_nwindows == 1
&& !(VAR_5 & (VAR_50 | VAR_46 | VAR_47))))
&& check_changed(VAR_38, (VAR_51 ? VAR_52 : 0)
| (VAR_7 ? 0 : VAR_53)
| ((VAR_5 & VAR_54) ? VAR_55 : 0)
| (VAR_3 == NULL ? 0 : VAR_56)))
{
if (VAR_0 == 0 && VAR_7 && VAR_1 != NULL)
(void)setaltfname(VAR_1, VAR_2, VAR_4 < 0 ? 0 : VAR_4);
goto theend;
}
reset_VIsual();
#if defined(VAR_11)
if ((VAR_28 != NULL || VAR_4 > (linenr_T)0)
&& *get_vim_var_str(VAR_57) == VAR_48)
{
intVAR_58;
char_u*VAR_59;
if (VAR_28 != NULL)
VAR_58 = (int)STRLEN(VAR_28) + 3;
else
VAR_58 = 30;
VAR_59 = alloc(VAR_58);
if (VAR_59 != NULL)
{
if (VAR_28 != NULL)
vim_snprintf((char *)VAR_59, VAR_58, "":%s\r"", VAR_28);
else
vim_snprintf((char *)VAR_59, VAR_58, ""%ldG"", (long)VAR_4);
set_vim_var_string(VAR_57, VAR_59, -1);
VAR_12 = TRUE;
vim_free(VAR_59);
}
}
#endif
if (VAR_7)
{
if (!(VAR_5 & (VAR_46 | VAR_47)))
{
if ((VAR_40.cmod_flags & VAR_60) == 0)
VAR_34->w_alt_fnum = VAR_38->b_fnum;
if (VAR_6 != NULL)
buflist_altfpos(VAR_6);
}
if (VAR_0)
VAR_13 = buflist_findnr(VAR_0);
else
{
if (VAR_5 & (VAR_46 | VAR_47))
{
linenr_TVAR_61 = 0;
buf_T*VAR_62;
if (VAR_28 != NULL)
{
VAR_61 = atol((char *)VAR_28);
if (VAR_61 <= 0)
VAR_61 = 1L;
}
VAR_62 = buflist_new(VAR_1, VAR_2, VAR_61,
VAR_63 | VAR_64);
if (VAR_62 != NULL && (VAR_5 & VAR_47))
VAR_34->w_alt_fnum = VAR_62->b_fnum;
goto theend;
}
VAR_13 = buflist_new(VAR_1, VAR_2, 0L,
VAR_65 | ((VAR_5 & VAR_66) ? 0 : VAR_63));
if (VAR_6 != NULL)
VAR_6 = VAR_34;
set_bufref(&VAR_15, VAR_38);
}
if (VAR_13 == NULL)
goto theend;
if (VAR_13->b_ml.ml_mfp == NULL)
{
VAR_8 = FALSE;
}
else
{
VAR_8 = TRUE;
set_bufref(&VAR_14, VAR_13);
(void)buf_check_timestamp(VAR_13, FALSE);
if (!bufref_valid(&VAR_14) || VAR_38 != VAR_15.br_buf)
goto theend;
#ifdef VAR_11
if (aborting())    
goto theend;
#endif
}
if ((VAR_8 && VAR_4 == VAR_67) || VAR_4 == VAR_68)
{
VAR_27 = buflist_findfpos(VAR_13);
VAR_4 = VAR_27->lnum;
VAR_26 = VAR_27->col;
}
if (VAR_13 != VAR_38)
{
if (VAR_13->b_fname != NULL)
VAR_10 = vim_strsave(VAR_13->b_fname);
set_bufref(&VAR_69, VAR_13);
apply_autocmds(VAR_70, NULL, NULL, FALSE, VAR_38);
if (!bufref_valid(&VAR_69))
{
delbuf_msg(VAR_10);
goto theend;
}
#ifdef VAR_11
if (aborting())    
{
vim_free(VAR_10);
goto theend;
}
#endif
if (VAR_13 == VAR_38)
VAR_9 = TRUE;
else
{
win_T    *VAR_71 = VAR_34;
VAR_71->w_closing = TRUE;
++VAR_13->b_locked;
if (VAR_38 == VAR_15.br_buf)
buf_copy_options(VAR_13, VAR_72);
u_sync(FALSE);
close_buffer(VAR_6, VAR_38,
(VAR_5 & VAR_50) ? 0 : VAR_73, FALSE, FALSE);
VAR_71->w_closing = FALSE;
--VAR_13->b_locked;
#ifdef VAR_11
if (aborting() && VAR_34->w_buffer != NULL)
{
vim_free(VAR_10);
goto theend;
}
#endif
if (!bufref_valid(&VAR_69))
{
delbuf_msg(VAR_10);
goto theend;
}
if (VAR_13 == VAR_38)
VAR_9 = TRUE;
else
{
#ifdef VAR_74
if (VAR_34->w_buffer == NULL
|| VAR_34->w_s == &(VAR_34->w_buffer->b_s))
VAR_34->w_s = &(VAR_13->b_s);
#endif
VAR_34->w_buffer = VAR_13;
VAR_38 = VAR_13;
++VAR_38->b_nwindows;
if (!VAR_8 && VAR_3 != NULL)
{
set_file_options(TRUE, VAR_3);
set_forced_fenc(VAR_3);
}
}
get_winopts(VAR_38);
#ifdef VAR_29
VAR_30 = TRUE;
#endif
}
vim_free(VAR_10);
VAR_69.br_buf = NULL;
VAR_69.br_buf_free_count = 0;
}
VAR_34->w_pcmark.lnum = 1;
VAR_34->w_pcmark.col = 0;
}
else 
{
if ((VAR_5 & (VAR_46 | VAR_47)) || check_fname() == VAR_21)
goto theend;
VAR_8 = (VAR_5 & VAR_49);
}
++VAR_75;
VAR_32 = TRUE;
VAR_13 = VAR_38;
if ((VAR_5 & VAR_66) || VAR_76)
{
prepare_help_buffer();
}
else
{
if (!VAR_38->b_help)
set_buflisted(TRUE);
}
if (VAR_13 != VAR_38)
goto theend;
#ifdef VAR_11
if (aborting())    
goto theend;
#endif
VAR_77 = FALSE;
if (!VAR_7 && !VAR_8)
{
set_last_cursor(VAR_34);
if (VAR_4 == VAR_68 || VAR_4 == VAR_67)
{
VAR_4 = VAR_34->w_cursor.lnum;
VAR_26 = VAR_34->w_cursor.col;
}
VAR_13 = VAR_38;
if (VAR_13->b_fname != NULL)
VAR_10 = vim_strsave(VAR_13->b_fname);
else
VAR_10 = NULL;
set_bufref(&VAR_14, VAR_13);
if (!(VAR_38->b_flags & VAR_78)
&& (VAR_79 < 0 || VAR_38->b_ml.ml_line_count <= VAR_79))
{
u_sync(FALSE);
if (u_savecommon(0, VAR_38->b_ml.ml_line_count + 1, 0, TRUE)
== VAR_21)
{
vim_free(VAR_10);
goto theend;
}
u_unchanged(VAR_38);
buf_freeall(VAR_38, VAR_80);
VAR_31 = VAR_81;
}
else
buf_freeall(VAR_38, 0);   
if (!bufref_valid(&VAR_14))
{
delbuf_msg(VAR_10);
goto theend;
}
vim_free(VAR_10);
if (VAR_13 != VAR_38)
goto theend;
#ifdef VAR_11
if (aborting())    
goto theend;
#endif
buf_clear_file(VAR_38);
VAR_38->b_op_start.lnum = 0;
VAR_38->b_op_end.lnum = 0;
}
VAR_20 = VAR_39;
check_arg_idx(VAR_34);
if (!VAR_9)
{
curwin_init();
#ifdef VAR_82
{
win_T    *VAR_83;
tabpage_T    *VAR_84;
FOR_ALL_TAB_WINDOWS(VAR_84, VAR_83)
if (VAR_83->w_buffer == VAR_38)
foldUpdateAll(VAR_83);
}
#endif
VAR_85;
VAR_23 = VAR_34->w_cursor;
VAR_24 = VAR_34->w_topline;
if (!VAR_8)    
{
#ifdef VAR_36
if (WIN_IS_POPUP(VAR_34))
VAR_38->b_flags |= VAR_86;
#endif
VAR_87 = VAR_88;
VAR_38->b_flags |= VAR_89; 
#if defined(VAR_11)
if (should_abort(open_buffer(FALSE, VAR_3, VAR_31)))
VAR_20 = VAR_21;
#else
(void)open_buffer(FALSE, VAR_3, VAR_31);
#endif
#ifdef VAR_36
VAR_38->b_flags &= ~VAR_86;
#endif
if (VAR_87 == VAR_90)
VAR_20 = VAR_21;
handle_swap_exists(&VAR_15);
}
else
{
do_modelines(VAR_91);
apply_autocmds_retval(VAR_92, NULL, NULL, FALSE, VAR_38,
&VAR_20);
apply_autocmds_retval(VAR_93, NULL, NULL, FALSE, VAR_38,
&VAR_20);
}
check_arg_idx(VAR_34);
if (!EQUAL_POS(VAR_34->w_cursor, VAR_23))
{
char_u *VAR_94 = ml_get_curline();
if (VAR_34->w_cursor.lnum != VAR_23.lnum
|| VAR_34->w_cursor.col != (int)(skipwhite(VAR_94) - VAR_94))
{
VAR_4 = VAR_34->w_cursor.lnum;
VAR_25 = VAR_34->w_cursor.col;
}
}
if (VAR_34->w_topline == VAR_24)
VAR_24 = 0;
changed_line_abv_curs();
#ifdef VAR_95
maketitle();
#endif
#if defined(VAR_36) && defined(VAR_96)
if (WIN_IS_POPUP(VAR_34) && VAR_34->w_p_pvw && VAR_20 != VAR_21)
popup_set_title(VAR_34);
#endif
}
#ifdef VAR_97
if (VAR_34->w_p_diff)
{
diff_buf_add(VAR_38);
diff_invalidate(VAR_38);
}
#endif
#ifdef VAR_29
if (VAR_30 && VAR_34->w_p_spell && *VAR_34->w_s->b_p_spl != VAR_48)
(void)did_set_spelllang(VAR_34);
#endif
if (VAR_28 == NULL)
{
if (VAR_25 >= 0)
{
VAR_34->w_cursor.lnum = VAR_4;
VAR_34->w_cursor.col = VAR_25;
check_cursor();
}
else if (VAR_4 > 0)
{
VAR_34->w_cursor.lnum = VAR_4;
check_cursor_lnum();
if (VAR_26 >= 0 && !VAR_98)
{
VAR_34->w_cursor.col = VAR_26;
check_cursor_col();
VAR_34->w_cursor.coladd = 0;
VAR_34->w_set_curswant = TRUE;
}
else
beginline(VAR_99 | VAR_100);
}
else
{
if (VAR_101)
VAR_34->w_cursor.lnum = VAR_38->b_ml.ml_line_count;
beginline(VAR_102 | VAR_100);
}
}
check_lnums(FALSE);
if (VAR_8 && !VAR_9)
{
intVAR_103 = VAR_104;
if (shortmess(VAR_105) && !VAR_42 && VAR_106 == 0)
VAR_104 = FALSE;
if (!VAR_104)
check_for_delay(FALSE);
msg_start();
VAR_104 = VAR_103;
VAR_107 = TRUE;
if (!shortmess(VAR_108))
fileinfo(FALSE, TRUE, FALSE);
VAR_107 = FALSE;
}
#ifdef VAR_109
VAR_38->b_last_used = vim_time();
#endif
if (VAR_28 != NULL)
do_cmdline(VAR_28, NULL, NULL, VAR_110|VAR_111);
#ifdef VAR_112
if (VAR_38->b_kmap_state & VAR_113)
(void)keymap_init();
#endif
--VAR_75;
VAR_32 = FALSE;
if (!VAR_114)
{
VAR_22 = *VAR_33;
if (VAR_24 == 0 && VAR_28 == NULL)
*VAR_33 = 9999;
update_topline();
VAR_34->w_scbind_pos = VAR_34->w_topline;
*VAR_33 = VAR_22;
redraw_curbuf_later(VAR_115);
}
if (VAR_116)
VAR_117 = TRUE;
#ifdef VAR_118
if (VAR_119 && VAR_38->b_ffname != NULL)
{
char_uVAR_120[VAR_121];
char_uVAR_122[VAR_121];
vim_strncpy(VAR_122, VAR_38->b_ffname, VAR_121 - 1);
*gettail_sep(VAR_122) = VAR_48;
if (mch_dirname(VAR_120, VAR_121) != VAR_21
&& vim_fnamecmp(VAR_120, VAR_122) != 0)
do_autochdir();
}
#endif
#if defined(VAR_123)
if (VAR_38->b_ffname != NULL)
{
# ifdef VAR_123
if ((VAR_5 & VAR_66) != VAR_66)
netbeans_file_opened(VAR_38);
# endif
}
#endif
theend:
if (VAR_32)
--VAR_75;
#if defined(VAR_11)
if (VAR_12)
set_vim_var_string(VAR_57, NULL, -1);
#endif
#ifdef VAR_17
vim_free(VAR_19);
#endif
vim_free(VAR_16);
return VAR_20;
}",vim/797e63b9f2baa1853e7063aac478d663cd02f207/ex_cmds.c/vul/before/0.json,"int
do_ecmd(
    int		fnum,
    char_u	*ffname,
    char_u	*sfname,
    exarg_T	*eap,			// can be NULL!
    linenr_T	newlnum,
    int		flags,
    win_T	*oldwin)
{
    int		other_file;		// TRUE if editing another file
    int		oldbuf;			// TRUE if using existing buffer
    int		auto_buf = FALSE;	// TRUE if autocommands brought us
					// into the buffer unexpectedly
    char_u	*new_name = NULL;
#if defined(FEAT_EVAL)
    int		did_set_swapcommand = FALSE;
#endif
    buf_T	*buf;
    bufref_T	bufref;
    bufref_T	old_curbuf;
    char_u	*free_fname = NULL;
#ifdef FEAT_BROWSE
    char_u	dot_path[] = ""."";
    char_u	*browse_file = NULL;
#endif
    int		retval = FAIL;
    long	n;
    pos_T	orig_pos;
    linenr_T	topline = 0;
    int		newcol = -1;
    int		solcol = -1;
    pos_T	*pos;
    char_u	*command = NULL;
#ifdef FEAT_SPELL
    int		did_get_winopts = FALSE;
#endif
    int		readfile_flags = 0;
    int		did_inc_redrawing_disabled = FALSE;
    long        *so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;

#ifdef FEAT_PROP_POPUP
    if (ERROR_IF_TERM_POPUP_WINDOW)
	return FAIL;
#endif

    if (eap != NULL)
	command = eap->do_ecmd_cmd;
    set_bufref(&old_curbuf, curbuf);

    if (fnum != 0)
    {
	if (fnum == curbuf->b_fnum)	// file is already being edited
	    return OK;			// nothing to do
	other_file = TRUE;
    }
    else
    {
#ifdef FEAT_BROWSE
	if ((cmdmod.cmod_flags & CMOD_BROWSE) && !exiting)
	{
	    if (
# ifdef FEAT_GUI
		!gui.in_use &&
# endif
		    au_has_group((char_u *)""FileExplorer""))
	    {
		// No browsing supported but we do have the file explorer:
		// Edit the directory.
		if (ffname == NULL || !mch_isdir(ffname))
		    ffname = dot_path;
	    }
	    else
	    {
		browse_file = do_browse(0, (char_u *)_(""Edit File""), ffname,
						    NULL, NULL, NULL, curbuf);
		if (browse_file == NULL)
		    goto theend;
		ffname = browse_file;
	    }
	}
#endif
	// if no short name given, use ffname for short name
	if (sfname == NULL)
	    sfname = ffname;
#ifdef USE_FNAME_CASE
	if (sfname != NULL)
	    fname_case(sfname, 0);   // set correct case for sfname
#endif

	if ((flags & (ECMD_ADDBUF | ECMD_ALTBUF))
					 && (ffname == NULL || *ffname == NUL))
	    goto theend;

	if (ffname == NULL)
	    other_file = TRUE;
					    // there is no file name
	else if (*ffname == NUL && curbuf->b_ffname == NULL)
	    other_file = FALSE;
	else
	{
	    if (*ffname == NUL)		    // re-edit with same file name
	    {
		ffname = curbuf->b_ffname;
		sfname = curbuf->b_fname;
	    }
	    free_fname = fix_fname(ffname); // may expand to full path name
	    if (free_fname != NULL)
		ffname = free_fname;
	    other_file = otherfile(ffname);
	}
    }

    /*
     * If the file was changed we may not be allowed to abandon it:
     * - if we are going to re-edit the same file
     * - or if we are the only window on this file and if ECMD_HIDE is FALSE
     */
    if (  ((!other_file && !(flags & ECMD_OLDBUF))
	    || (curbuf->b_nwindows == 1
		&& !(flags & (ECMD_HIDE | ECMD_ADDBUF | ECMD_ALTBUF))))
	&& check_changed(curbuf, (p_awa ? CCGD_AW : 0)
			       | (other_file ? 0 : CCGD_MULTWIN)
			       | ((flags & ECMD_FORCEIT) ? CCGD_FORCEIT : 0)
			       | (eap == NULL ? 0 : CCGD_EXCMD)))
    {
	if (fnum == 0 && other_file && ffname != NULL)
	    (void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);
	goto theend;
    }

    /*
     * End Visual mode before switching to another buffer, so the text can be
     * copied into the GUI selection buffer.
     */
    reset_VIsual();

#if defined(FEAT_EVAL)
    if ((command != NULL || newlnum > (linenr_T)0)
	    && *get_vim_var_str(VV_SWAPCOMMAND) == NUL)
    {
	int	len;
	char_u	*p;

	// Set v:swapcommand for the SwapExists autocommands.
	if (command != NULL)
	    len = (int)STRLEN(command) + 3;
	else
	    len = 30;
	p = alloc(len);
	if (p != NULL)
	{
	    if (command != NULL)
		vim_snprintf((char *)p, len, "":%s\r"", command);
	    else
		vim_snprintf((char *)p, len, ""%ldG"", (long)newlnum);
	    set_vim_var_string(VV_SWAPCOMMAND, p, -1);
	    did_set_swapcommand = TRUE;
	    vim_free(p);
	}
    }
#endif

    /*
     * If we are starting to edit another file, open a (new) buffer.
     * Otherwise we re-use the current buffer.
     */
    if (other_file)
    {
	if (!(flags & (ECMD_ADDBUF | ECMD_ALTBUF)))
	{
	    if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)
		curwin->w_alt_fnum = curbuf->b_fnum;
	    if (oldwin != NULL)
		buflist_altfpos(oldwin);
	}

	if (fnum)
	    buf = buflist_findnr(fnum);
	else
	{
	    if (flags & (ECMD_ADDBUF | ECMD_ALTBUF))
	    {
		// Default the line number to zero to avoid that a wininfo item
		// is added for the current window.
		linenr_T	tlnum = 0;
		buf_T		*newbuf;

		if (command != NULL)
		{
		    tlnum = atol((char *)command);
		    if (tlnum <= 0)
			tlnum = 1L;
		}
		// Add BLN_NOCURWIN to avoid a new wininfo items are associated
		// with the current window.
		newbuf = buflist_new(ffname, sfname, tlnum,
						    BLN_LISTED | BLN_NOCURWIN);
		if (newbuf != NULL && (flags & ECMD_ALTBUF))
		    curwin->w_alt_fnum = newbuf->b_fnum;
		goto theend;
	    }
	    buf = buflist_new(ffname, sfname, 0L,
		    BLN_CURBUF | ((flags & ECMD_SET_HELP) ? 0 : BLN_LISTED));

	    // autocommands may change curwin and curbuf
	    if (oldwin != NULL)
		oldwin = curwin;
	    set_bufref(&old_curbuf, curbuf);
	}
	if (buf == NULL)
	    goto theend;
	if (buf->b_ml.ml_mfp == NULL)		// no memfile yet
	{
	    oldbuf = FALSE;
	}
	else					// existing memfile
	{
	    oldbuf = TRUE;
	    set_bufref(&bufref, buf);
	    (void)buf_check_timestamp(buf, FALSE);
	    // Check if autocommands made the buffer invalid or changed the
	    // current buffer.
	    if (!bufref_valid(&bufref) || curbuf != old_curbuf.br_buf)
		goto theend;
#ifdef FEAT_EVAL
	    if (aborting())	    // autocmds may abort script processing
		goto theend;
#endif
	}

	// May jump to last used line number for a loaded buffer or when asked
	// for explicitly
	if ((oldbuf && newlnum == ECMD_LASTL) || newlnum == ECMD_LAST)
	{
	    pos = buflist_findfpos(buf);
	    newlnum = pos->lnum;
	    solcol = pos->col;
	}

	/*
	 * Make the (new) buffer the one used by the current window.
	 * If the old buffer becomes unused, free it if ECMD_HIDE is FALSE.
	 * If the current buffer was empty and has no file name, curbuf
	 * is returned by buflist_new(), nothing to do here.
	 */
	if (buf != curbuf)
	{
	    /*
	     * Be careful: The autocommands may delete any buffer and change
	     * the current buffer.
	     * - If the buffer we are going to edit is deleted, give up.
	     * - If the current buffer is deleted, prefer to load the new
	     *   buffer when loading a buffer is required.  This avoids
	     *   loading another buffer which then must be closed again.
	     * - If we ended up in the new buffer already, need to skip a few
	     *	 things, set auto_buf.
	     */
	    if (buf->b_fname != NULL)
		new_name = vim_strsave(buf->b_fname);
	    set_bufref(&au_new_curbuf, buf);
	    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);
	    if (!bufref_valid(&au_new_curbuf))
	    {
		// new buffer has been deleted
		delbuf_msg(new_name);	// frees new_name
		goto theend;
	    }
#ifdef FEAT_EVAL
	    if (aborting())	    // autocmds may abort script processing
	    {
		vim_free(new_name);
		goto theend;
	    }
#endif
	    if (buf == curbuf)		// already in new buffer
		auto_buf = TRUE;
	    else
	    {
		win_T	    *the_curwin = curwin;
		int	    did_decrement;
		buf_T	    *was_curbuf = curbuf;

		// Set the w_closing flag to avoid that autocommands close the
		// window.  And set b_locked for the same reason.
		the_curwin->w_closing = TRUE;
		++buf->b_locked;

		if (curbuf == old_curbuf.br_buf)
		    buf_copy_options(buf, BCO_ENTER);

		// Close the link to the current buffer. This will set
		// oldwin->w_buffer to NULL.
		u_sync(FALSE);
		did_decrement = close_buffer(oldwin, curbuf,
			 (flags & ECMD_HIDE) ? 0 : DOBUF_UNLOAD, FALSE, FALSE);

		the_curwin->w_closing = FALSE;
		--buf->b_locked;

#ifdef FEAT_EVAL
		// autocmds may abort script processing
		if (aborting() && curwin->w_buffer != NULL)
		{
		    vim_free(new_name);
		    goto theend;
		}
#endif
		// Be careful again, like above.
		if (!bufref_valid(&au_new_curbuf))
		{
		    // new buffer has been deleted
		    delbuf_msg(new_name);	// frees new_name
		    goto theend;
		}
		if (buf == curbuf)		// already in new buffer
		{
		    // close_buffer() has decremented the window count,
		    // increment it again here and restore w_buffer.
		    if (did_decrement && buf_valid(was_curbuf))
			++was_curbuf->b_nwindows;
		    if (win_valid_any_tab(oldwin) && oldwin->w_buffer == NULL)
			oldwin->w_buffer = was_curbuf;
		    auto_buf = TRUE;
		}
		else
		{
#ifdef FEAT_SYN_HL
		    /*
		     * <VN> We could instead free the synblock
		     * and re-attach to buffer, perhaps.
		     */
		    if (curwin->w_buffer == NULL
			    || curwin->w_s == &(curwin->w_buffer->b_s))
			curwin->w_s = &(buf->b_s);
#endif
		    curwin->w_buffer = buf;
		    curbuf = buf;
		    ++curbuf->b_nwindows;

		    // Set 'fileformat', 'binary' and 'fenc' when forced.
		    if (!oldbuf && eap != NULL)
		    {
			set_file_options(TRUE, eap);
			set_forced_fenc(eap);
		    }
		}

		// May get the window options from the last time this buffer
		// was in this window (or another window).  If not used
		// before, reset the local window options to the global
		// values.  Also restores old folding stuff.
		get_winopts(curbuf);
#ifdef FEAT_SPELL
		did_get_winopts = TRUE;
#endif
	    }
	    vim_free(new_name);
	    au_new_curbuf.br_buf = NULL;
	    au_new_curbuf.br_buf_free_count = 0;
	}

	curwin->w_pcmark.lnum = 1;
	curwin->w_pcmark.col = 0;
    }
    else // !other_file
    {
	if ((flags & (ECMD_ADDBUF | ECMD_ALTBUF)) || check_fname() == FAIL)
	    goto theend;

	oldbuf = (flags & ECMD_OLDBUF);
    }

    // Don't redraw until the cursor is in the right line, otherwise
    // autocommands may cause ml_get errors.
    ++RedrawingDisabled;
    did_inc_redrawing_disabled = TRUE;

    buf = curbuf;
    if ((flags & ECMD_SET_HELP) || keep_help_flag)
    {
	prepare_help_buffer();
    }
    else
    {
	// Don't make a buffer listed if it's a help buffer.  Useful when
	// using CTRL-O to go back to a help file.
	if (!curbuf->b_help)
	    set_buflisted(TRUE);
    }

    // If autocommands change buffers under our fingers, forget about
    // editing the file.
    if (buf != curbuf)
	goto theend;
#ifdef FEAT_EVAL
    if (aborting())	    // autocmds may abort script processing
	goto theend;
#endif

    // Since we are starting to edit a file, consider the filetype to be
    // unset.  Helps for when an autocommand changes files and expects syntax
    // highlighting to work in the other file.
    did_filetype = FALSE;

/*
 * other_file	oldbuf
 *  FALSE	FALSE	    re-edit same file, buffer is re-used
 *  FALSE	TRUE	    re-edit same file, nothing changes
 *  TRUE	FALSE	    start editing new file, new buffer
 *  TRUE	TRUE	    start editing in existing buffer (nothing to do)
 */
    if (!other_file && !oldbuf)		// re-use the buffer
    {
	set_last_cursor(curwin);	// may set b_last_cursor
	if (newlnum == ECMD_LAST || newlnum == ECMD_LASTL)
	{
	    newlnum = curwin->w_cursor.lnum;
	    solcol = curwin->w_cursor.col;
	}
	buf = curbuf;
	if (buf->b_fname != NULL)
	    new_name = vim_strsave(buf->b_fname);
	else
	    new_name = NULL;
	set_bufref(&bufref, buf);

	// If the buffer was used before, store the current contents so that
	// the reload can be undone.  Do not do this if the (empty) buffer is
	// being re-used for another file.
	if (!(curbuf->b_flags & BF_NEVERLOADED)
		&& (p_ur < 0 || curbuf->b_ml.ml_line_count <= p_ur))
	{
	    // Sync first so that this is a separate undo-able action.
	    u_sync(FALSE);
	    if (u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE)
								     == FAIL)
	    {
		vim_free(new_name);
		goto theend;
	    }
	    u_unchanged(curbuf);
	    buf_freeall(curbuf, BFA_KEEP_UNDO);

	    // tell readfile() not to clear or reload undo info
	    readfile_flags = READ_KEEP_UNDO;
	}
	else
	    buf_freeall(curbuf, 0);   // free all things for buffer

	// If autocommands deleted the buffer we were going to re-edit, give
	// up and jump to the end.
	if (!bufref_valid(&bufref))
	{
	    delbuf_msg(new_name);	// frees new_name
	    goto theend;
	}
	vim_free(new_name);

	// If autocommands change buffers under our fingers, forget about
	// re-editing the file.  Should do the buf_clear_file(), but perhaps
	// the autocommands changed the buffer...
	if (buf != curbuf)
	    goto theend;
#ifdef FEAT_EVAL
	if (aborting())	    // autocmds may abort script processing
	    goto theend;
#endif
	buf_clear_file(curbuf);
	curbuf->b_op_start.lnum = 0;	// clear '[ and '] marks
	curbuf->b_op_end.lnum = 0;
    }

/*
 * If we get here we are sure to start editing
 */
    // Assume success now
    retval = OK;

    /*
     * Check if we are editing the w_arg_idx file in the argument list.
     */
    check_arg_idx(curwin);

    if (!auto_buf)
    {
	/*
	 * Set cursor and init window before reading the file and executing
	 * autocommands.  This allows for the autocommands to position the
	 * cursor.
	 */
	curwin_init();

#ifdef FEAT_FOLDING
	// It's possible that all lines in the buffer changed.  Need to update
	// automatic folding for all windows where it's used.
	{
	    win_T	    *win;
	    tabpage_T	    *tp;

	    FOR_ALL_TAB_WINDOWS(tp, win)
		if (win->w_buffer == curbuf)
		    foldUpdateAll(win);
	}
#endif

	// Change directories when the 'acd' option is set.
	DO_AUTOCHDIR;

	/*
	 * Careful: open_buffer() and apply_autocmds() may change the current
	 * buffer and window.
	 */
	orig_pos = curwin->w_cursor;
	topline = curwin->w_topline;
	if (!oldbuf)			    // need to read the file
	{
#ifdef FEAT_PROP_POPUP
	    // Don't use the swap-exists dialog for a popup window, can't edit
	    // the buffer.
	    if (WIN_IS_POPUP(curwin))
		curbuf->b_flags |= BF_NO_SEA;
#endif
	    swap_exists_action = SEA_DIALOG;
	    curbuf->b_flags |= BF_CHECK_RO; // set/reset 'ro' flag

	    /*
	     * Open the buffer and read the file.
	     */
#if defined(FEAT_EVAL)
	    if (should_abort(open_buffer(FALSE, eap, readfile_flags)))
		retval = FAIL;
#else
	    (void)open_buffer(FALSE, eap, readfile_flags);
#endif

#ifdef FEAT_PROP_POPUP
	    curbuf->b_flags &= ~BF_NO_SEA;
#endif
	    if (swap_exists_action == SEA_QUIT)
		retval = FAIL;
	    handle_swap_exists(&old_curbuf);
	}
	else
	{
	    // Read the modelines, but only to set window-local options.  Any
	    // buffer-local options have already been set and may have been
	    // changed by the user.
	    do_modelines(OPT_WINONLY);

	    apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf,
								    &retval);
	    apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf,
								    &retval);
	}
	check_arg_idx(curwin);

	// If autocommands change the cursor position or topline, we should
	// keep it.  Also when it moves within a line. But not when it moves
	// to the first non-blank.
	if (!EQUAL_POS(curwin->w_cursor, orig_pos))
	{
	    char_u *text = ml_get_curline();

	    if (curwin->w_cursor.lnum != orig_pos.lnum
		    || curwin->w_cursor.col != (int)(skipwhite(text) - text))
	    {
		newlnum = curwin->w_cursor.lnum;
		newcol = curwin->w_cursor.col;
	    }
	}
	if (curwin->w_topline == topline)
	    topline = 0;

	// Even when cursor didn't move we need to recompute topline.
	changed_line_abv_curs();

#ifdef FEAT_TITLE
	maketitle();
#endif
#if defined(FEAT_PROP_POPUP) && defined(FEAT_QUICKFIX)
	if (WIN_IS_POPUP(curwin) && curwin->w_p_pvw && retval != FAIL)
	    popup_set_title(curwin);
#endif
    }

#ifdef FEAT_DIFF
    // Tell the diff stuff that this buffer is new and/or needs updating.
    // Also needed when re-editing the same buffer, because unloading will
    // have removed it as a diff buffer.
    if (curwin->w_p_diff)
    {
	diff_buf_add(curbuf);
	diff_invalidate(curbuf);
    }
#endif

#ifdef FEAT_SPELL
    // If the window options were changed may need to set the spell language.
    // Can only do this after the buffer has been properly setup.
    if (did_get_winopts && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)
	(void)did_set_spelllang(curwin);
#endif

    if (command == NULL)
    {
	if (newcol >= 0)	// position set by autocommands
	{
	    curwin->w_cursor.lnum = newlnum;
	    curwin->w_cursor.col = newcol;
	    check_cursor();
	}
	else if (newlnum > 0)	// line number from caller or old position
	{
	    curwin->w_cursor.lnum = newlnum;
	    check_cursor_lnum();
	    if (solcol >= 0 && !p_sol)
	    {
		// 'sol' is off: Use last known column.
		curwin->w_cursor.col = solcol;
		check_cursor_col();
		curwin->w_cursor.coladd = 0;
		curwin->w_set_curswant = TRUE;
	    }
	    else
		beginline(BL_SOL | BL_FIX);
	}
	else			// no line number, go to last line in Ex mode
	{
	    if (exmode_active)
		curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
	    beginline(BL_WHITE | BL_FIX);
	}
    }

    // Check if cursors in other windows on the same buffer are still valid
    check_lnums(FALSE);

    /*
     * Did not read the file, need to show some info about the file.
     * Do this after setting the cursor.
     */
    if (oldbuf && !auto_buf)
    {
	int	msg_scroll_save = msg_scroll;

	// Obey the 'O' flag in 'cpoptions': overwrite any previous file
	// message.
	if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)
	    msg_scroll = FALSE;
	if (!msg_scroll)	// wait a bit when overwriting an error msg
	    check_for_delay(FALSE);
	msg_start();
	msg_scroll = msg_scroll_save;
	msg_scrolled_ign = TRUE;

	if (!shortmess(SHM_FILEINFO))
	    fileinfo(FALSE, TRUE, FALSE);

	msg_scrolled_ign = FALSE;
    }

#ifdef FEAT_VIMINFO
    curbuf->b_last_used = vim_time();
#endif

    if (command != NULL)
	do_cmdline(command, NULL, NULL, DOCMD_VERBOSE|DOCMD_RANGEOK);

#ifdef FEAT_KEYMAP
    if (curbuf->b_kmap_state & KEYMAP_INIT)
	(void)keymap_init();
#endif

    --RedrawingDisabled;
    did_inc_redrawing_disabled = FALSE;
    if (!skip_redraw)
    {
	n = *so_ptr;
	if (topline == 0 && command == NULL)
	    *so_ptr = 9999;		// force cursor halfway the window
	update_topline();
	curwin->w_scbind_pos = curwin->w_topline;
	*so_ptr = n;
	redraw_curbuf_later(NOT_VALID);	// redraw this buffer later
    }

    if (p_im)
	need_start_insertmode = TRUE;

#ifdef FEAT_AUTOCHDIR
    // Change directories when the 'acd' option is set and we aren't already in
    // that directory (should already be done above). Expect getcwd() to be
    // faster than calling shorten_fnames() unnecessarily.
    if (p_acd && curbuf->b_ffname != NULL)
    {
	char_u	curdir[MAXPATHL];
	char_u	filedir[MAXPATHL];

	vim_strncpy(filedir, curbuf->b_ffname, MAXPATHL - 1);
	*gettail_sep(filedir) = NUL;
	if (mch_dirname(curdir, MAXPATHL) != FAIL
		&& vim_fnamecmp(curdir, filedir) != 0)
	    do_autochdir();
    }
#endif

#if defined(FEAT_NETBEANS_INTG)
    if (curbuf->b_ffname != NULL)
    {
# ifdef FEAT_NETBEANS_INTG
	if ((flags & ECMD_SET_HELP) != ECMD_SET_HELP)
	    netbeans_file_opened(curbuf);
# endif
    }
#endif

theend:
    if (did_inc_redrawing_disabled)
	--RedrawingDisabled;
#if defined(FEAT_EVAL)
    if (did_set_swapcommand)
	set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);
#endif
#ifdef FEAT_BROWSE
    vim_free(browse_file);
#endif
    vim_free(free_fname);
    return retval;
}","int
do_ecmd(
    int		VAR_0,
    char_u	*VAR_1,
    char_u	*VAR_2,
    exarg_T	*VAR_3,			/* COMMENT_0 */
    linenr_T	VAR_4,
    int		VAR_5,
    win_T	*VAR_6)
{
    int		VAR_7;		/* COMMENT_1 */
    int		VAR_8;			/* COMMENT_2 */
    int		VAR_9 = FALSE;	/* COMMENT_3 */
					/* COMMENT_4 */
    char_u	*VAR_10 = NULL;
#if defined(VAR_11)
    int		VAR_12 = FALSE;
#endif
    buf_T	*VAR_13;
    bufref_T	VAR_14;
    bufref_T	VAR_15;
    char_u	*VAR_16 = NULL;
#ifdef VAR_17
    char_u	VAR_18[] = ""."";
    char_u	*VAR_19 = NULL;
#endif
    int		VAR_20 = VAR_21;
    long	VAR_22;
    pos_T	VAR_23;
    linenr_T	VAR_24 = 0;
    int		VAR_25 = -1;
    int		VAR_26 = -1;
    pos_T	*VAR_27;
    char_u	*VAR_28 = NULL;
#ifdef VAR_29
    int		VAR_30 = FALSE;
#endif
    int		VAR_31 = 0;
    int		VAR_32 = FALSE;
    long        *VAR_33 = VAR_34->w_p_so >= 0 ? &VAR_34->w_p_so : &VAR_35;

#ifdef VAR_36
    if (VAR_37)
	return VAR_21;
#endif

    if (VAR_3 != NULL)
	VAR_28 = VAR_3->do_ecmd_cmd;
    set_bufref(&VAR_15, VAR_38);

    if (VAR_0 != 0)
    {
	if (VAR_0 == VAR_38->b_fnum)	/* COMMENT_5 */
	    return VAR_39;			/* COMMENT_6 */
	VAR_7 = TRUE;
    }
    else
    {
#ifdef VAR_17
	if ((VAR_40.cmod_flags & VAR_41) && !VAR_42)
	{
	    if (
# ifdef VAR_43
		!VAR_44.in_use &&
# endif
		    au_has_group((char_u *)""FileExplorer""))
	    {
		/* COMMENT_7 */
		/* COMMENT_8 */
		if (VAR_1 == NULL || !mch_isdir(VAR_1))
		    VAR_1 = VAR_18;
	    }
	    else
	    {
		VAR_19 = do_browse(0, (char_u *)_(""Edit File""), VAR_1,
						    NULL, NULL, NULL, VAR_38);
		if (VAR_19 == NULL)
		    goto theend;
		VAR_1 = VAR_19;
	    }
	}
#endif
	/* COMMENT_9 */
	if (VAR_2 == NULL)
	    VAR_2 = VAR_1;
#ifdef VAR_45
	if (VAR_2 != NULL)
	    fname_case(VAR_2, 0);   /* COMMENT_10 */
#endif

	if ((VAR_5 & (VAR_46 | VAR_47))
					 && (VAR_1 == NULL || *VAR_1 == VAR_48))
	    goto theend;

	if (VAR_1 == NULL)
	    VAR_7 = TRUE;
					    /* COMMENT_11 */
	else if (*VAR_1 == VAR_48 && VAR_38->b_ffname == NULL)
	    VAR_7 = FALSE;
	else
	{
	    if (*VAR_1 == VAR_48)		    /* COMMENT_12 */
	    {
		VAR_1 = VAR_38->b_ffname;
		VAR_2 = VAR_38->b_fname;
	    }
	    VAR_16 = fix_fname(VAR_1); /* COMMENT_13 */
	    if (VAR_16 != NULL)
		VAR_1 = VAR_16;
	    VAR_7 = otherfile(VAR_1);
	}
    }

    /* COMMENT_14 */
                                                                   
                                                 
                                                                            
       
    if (  ((!VAR_7 && !(VAR_5 & VAR_49))
	    || (VAR_38->b_nwindows == 1
		&& !(VAR_5 & (VAR_50 | VAR_46 | VAR_47))))
	&& check_changed(VAR_38, (VAR_51 ? VAR_52 : 0)
			       | (VAR_7 ? 0 : VAR_53)
			       | ((VAR_5 & VAR_54) ? VAR_55 : 0)
			       | (VAR_3 == NULL ? 0 : VAR_56)))
    {
	if (VAR_0 == 0 && VAR_7 && VAR_1 != NULL)
	    (void)setaltfname(VAR_1, VAR_2, VAR_4 < 0 ? 0 : VAR_4);
	goto theend;
    }

    /* COMMENT_19 */
                                                                             
                                            
       
    reset_VIsual();

#if defined(VAR_11)
    if ((VAR_28 != NULL || VAR_4 > (linenr_T)0)
	    && *get_vim_var_str(VAR_57) == VAR_48)
    {
	int	VAR_58;
	char_u	*VAR_59;

	/* COMMENT_23 */
	if (VAR_28 != NULL)
	    VAR_58 = (int)STRLEN(VAR_28) + 3;
	else
	    VAR_58 = 30;
	VAR_59 = alloc(VAR_58);
	if (VAR_59 != NULL)
	{
	    if (VAR_28 != NULL)
		vim_snprintf((char *)VAR_59, VAR_58, "":%s\r"", VAR_28);
	    else
		vim_snprintf((char *)VAR_59, VAR_58, ""%ldG"", (long)VAR_4);
	    set_vim_var_string(VAR_57, VAR_59, -1);
	    VAR_12 = TRUE;
	    vim_free(VAR_59);
	}
    }
#endif

    /* COMMENT_24 */
                                                                    
                                              
       
    if (VAR_7)
    {
	if (!(VAR_5 & (VAR_46 | VAR_47)))
	{
	    if ((VAR_40.cmod_flags & VAR_60) == 0)
		VAR_34->w_alt_fnum = VAR_38->b_fnum;
	    if (VAR_6 != NULL)
		buflist_altfpos(VAR_6);
	}

	if (VAR_0)
	    VAR_13 = buflist_findnr(VAR_0);
	else
	{
	    if (VAR_5 & (VAR_46 | VAR_47))
	    {
		/* COMMENT_28 */
		/* COMMENT_29 */
		linenr_T	VAR_61 = 0;
		buf_T		*VAR_62;

		if (VAR_28 != NULL)
		{
		    VAR_61 = atol((char *)VAR_28);
		    if (VAR_61 <= 0)
			VAR_61 = 1L;
		}
		/* COMMENT_30 */
		/* COMMENT_31 */
		VAR_62 = buflist_new(VAR_1, VAR_2, VAR_61,
						    VAR_63 | VAR_64);
		if (VAR_62 != NULL && (VAR_5 & VAR_47))
		    VAR_34->w_alt_fnum = VAR_62->b_fnum;
		goto theend;
	    }
	    VAR_13 = buflist_new(VAR_1, VAR_2, 0L,
		    VAR_65 | ((VAR_5 & VAR_66) ? 0 : VAR_63));

	    /* COMMENT_32 */
	    if (VAR_6 != NULL)
		VAR_6 = VAR_34;
	    set_bufref(&VAR_15, VAR_38);
	}
	if (VAR_13 == NULL)
	    goto theend;
	if (VAR_13->b_ml.ml_mfp == NULL)		/* COMMENT_33 */
	{
	    VAR_8 = FALSE;
	}
	else					/* COMMENT_34 */
	{
	    VAR_8 = TRUE;
	    set_bufref(&VAR_14, VAR_13);
	    (void)buf_check_timestamp(VAR_13, FALSE);
	    /* COMMENT_35 */
	    /* COMMENT_36 */
	    if (!bufref_valid(&VAR_14) || VAR_38 != VAR_15.br_buf)
		goto theend;
#ifdef VAR_11
	    if (aborting())	    /* COMMENT_37 */
		goto theend;
#endif
	}

	/* COMMENT_38 */
	/* COMMENT_39 */
	if ((VAR_8 && VAR_4 == VAR_67) || VAR_4 == VAR_68)
	{
	    VAR_27 = buflist_findfpos(VAR_13);
	    VAR_4 = VAR_27->lnum;
	    VAR_26 = VAR_27->col;
	}

	/* COMMENT_40 */
                                                             
                                                                    
                                                                
                                                     
    
	if (VAR_13 != VAR_38)
	{
	    /* COMMENT_46 */
                                                                     
                           
                                                                 
                                                                  
                                                                
                                                                 
                                                                      
                              
        
	    if (VAR_13->b_fname != NULL)
		VAR_10 = vim_strsave(VAR_13->b_fname);
	    set_bufref(&VAR_69, VAR_13);
	    apply_autocmds(VAR_70, NULL, NULL, FALSE, VAR_38);
	    if (!bufref_valid(&VAR_69))
	    {
		/* COMMENT_56 */
		delbuf_msg(VAR_10);	/* COMMENT_57 */
		goto theend;
	    }
#ifdef VAR_11
	    if (aborting())	    /* COMMENT_37 */
	    {
		vim_free(VAR_10);
		goto theend;
	    }
#endif
	    if (VAR_13 == VAR_38)		/* COMMENT_58 */
		VAR_9 = TRUE;
	    else
	    {
		win_T	    *VAR_71 = VAR_34;
		int	    VAR_72;
		buf_T	    *VAR_73 = VAR_38;

		/* COMMENT_59 */
		/* COMMENT_60 */
		VAR_71->w_closing = TRUE;
		++VAR_13->b_locked;

		if (VAR_38 == VAR_15.br_buf)
		    buf_copy_options(VAR_13, VAR_74);

		/* COMMENT_61 */
		/* COMMENT_62 */
		u_sync(FALSE);
		VAR_72 = close_buffer(VAR_6, VAR_38,
			 (VAR_5 & VAR_50) ? 0 : VAR_75, FALSE, FALSE);

		VAR_71->w_closing = FALSE;
		--VAR_13->b_locked;

#ifdef VAR_11
		/* COMMENT_37 */
		if (aborting() && VAR_34->w_buffer != NULL)
		{
		    vim_free(VAR_10);
		    goto theend;
		}
#endif
		/* COMMENT_63 */
		if (!bufref_valid(&VAR_69))
		{
		    /* COMMENT_56 */
		    delbuf_msg(VAR_10);	/* COMMENT_57 */
		    goto theend;
		}
		if (VAR_13 == VAR_38)		/* COMMENT_58 */
		{
		    /* COMMENT_64 */
		    /* COMMENT_65 */
		    if (VAR_72 && buf_valid(VAR_73))
			++VAR_73->b_nwindows;
		    if (win_valid_any_tab(VAR_6) && VAR_6->w_buffer == NULL)
			VAR_6->w_buffer = VAR_73;
		    VAR_9 = TRUE;
		}
		else
		{
#ifdef VAR_76
		    /* COMMENT_66 */
                                                
                                          
         
		    if (VAR_34->w_buffer == NULL
			    || VAR_34->w_s == &(VAR_34->w_buffer->b_s))
			VAR_34->w_s = &(VAR_13->b_s);
#endif
		    VAR_34->w_buffer = VAR_13;
		    VAR_38 = VAR_13;
		    ++VAR_38->b_nwindows;

		    /* COMMENT_70 */
		    if (!VAR_8 && VAR_3 != NULL)
		    {
			set_file_options(TRUE, VAR_3);
			set_forced_fenc(VAR_3);
		    }
		}

		/* COMMENT_71 */
		/* COMMENT_72 */
		/* COMMENT_73 */
		/* COMMENT_74 */
		get_winopts(VAR_38);
#ifdef VAR_29
		VAR_30 = TRUE;
#endif
	    }
	    vim_free(VAR_10);
	    VAR_69.br_buf = NULL;
	    VAR_69.br_buf_free_count = 0;
	}

	VAR_34->w_pcmark.lnum = 1;
	VAR_34->w_pcmark.col = 0;
    }
    else /* COMMENT_75 */
    {
	if ((VAR_5 & (VAR_46 | VAR_47)) || check_fname() == VAR_21)
	    goto theend;

	VAR_8 = (VAR_5 & VAR_49);
    }

    /* COMMENT_76 */
    /* COMMENT_77 */
    ++VAR_77;
    VAR_32 = TRUE;

    VAR_13 = VAR_38;
    if ((VAR_5 & VAR_66) || VAR_78)
    {
	prepare_help_buffer();
    }
    else
    {
	/* COMMENT_78 */
	/* COMMENT_79 */
	if (!VAR_38->b_help)
	    set_buflisted(TRUE);
    }

    /* COMMENT_80 */
    /* COMMENT_81 */
    if (VAR_13 != VAR_38)
	goto theend;
#ifdef VAR_11
    if (aborting())	    /* COMMENT_37 */
	goto theend;
#endif

    /* COMMENT_82 */
    /* COMMENT_83 */
    /* COMMENT_84 */
    VAR_79 = FALSE;

/* COMMENT_85 */
                    
                                                        
                                                     
                                                     
                                                                  
   
    if (!VAR_7 && !VAR_8)		/* COMMENT_92 */
    {
	set_last_cursor(VAR_34);	/* COMMENT_93 */
	if (VAR_4 == VAR_68 || VAR_4 == VAR_67)
	{
	    VAR_4 = VAR_34->w_cursor.lnum;
	    VAR_26 = VAR_34->w_cursor.col;
	}
	VAR_13 = VAR_38;
	if (VAR_13->b_fname != NULL)
	    VAR_10 = vim_strsave(VAR_13->b_fname);
	else
	    VAR_10 = NULL;
	set_bufref(&VAR_14, VAR_13);

	/* COMMENT_94 */
	/* COMMENT_95 */
	/* COMMENT_96 */
	if (!(VAR_38->b_flags & VAR_80)
		&& (VAR_81 < 0 || VAR_38->b_ml.ml_line_count <= VAR_81))
	{
	    /* COMMENT_97 */
	    u_sync(FALSE);
	    if (u_savecommon(0, VAR_38->b_ml.ml_line_count + 1, 0, TRUE)
								     == VAR_21)
	    {
		vim_free(VAR_10);
		goto theend;
	    }
	    u_unchanged(VAR_38);
	    buf_freeall(VAR_38, VAR_82);

	    /* COMMENT_98 */
	    VAR_31 = VAR_83;
	}
	else
	    buf_freeall(VAR_38, 0);   /* COMMENT_99 */

	/* COMMENT_100 */
	/* COMMENT_101 */
	if (!bufref_valid(&VAR_14))
	{
	    delbuf_msg(VAR_10);	/* COMMENT_57 */
	    goto theend;
	}
	vim_free(VAR_10);

	/* COMMENT_80 */
	/* COMMENT_102 */
	/* COMMENT_103 */
	if (VAR_13 != VAR_38)
	    goto theend;
#ifdef VAR_11
	if (aborting())	    /* COMMENT_37 */
	    goto theend;
#endif
	buf_clear_file(VAR_38);
	VAR_38->b_op_start.lnum = 0;	/* COMMENT_104 */
	VAR_38->b_op_end.lnum = 0;
    }

/* COMMENT_105 */
                                              
   
    /* COMMENT_108 */
    VAR_20 = VAR_39;

    /* COMMENT_109 */
                                                                       
       
    check_arg_idx(VAR_34);

    if (!VAR_9)
    {
	/* COMMENT_112 */
                                                                    
                                                                   
           
    
	curwin_init();

#ifdef VAR_84
	/* COMMENT_117 */
	/* COMMENT_118 */
	{
	    win_T	    *VAR_85;
	    tabpage_T	    *VAR_86;

	    FOR_ALL_TAB_WINDOWS(VAR_86, VAR_85)
		if (VAR_85->w_buffer == VAR_38)
		    foldUpdateAll(VAR_85);
	}
#endif

	/* COMMENT_119 */
	VAR_87;

	/* COMMENT_120 */
                                                                      
                      
    
	VAR_23 = VAR_34->w_cursor;
	VAR_24 = VAR_34->w_topline;
	if (!VAR_8)			    /* COMMENT_124 */
	{
#ifdef VAR_36
	    /* COMMENT_125 */
	    /* COMMENT_126 */
	    if (WIN_IS_POPUP(VAR_34))
		VAR_38->b_flags |= VAR_88;
#endif
	    VAR_89 = VAR_90;
	    VAR_38->b_flags |= VAR_91; /* COMMENT_127 */

	    /* COMMENT_128 */
                                          
        
#if defined(VAR_11)
	    if (should_abort(open_buffer(FALSE, VAR_3, VAR_31)))
		VAR_20 = VAR_21;
#else
	    (void)open_buffer(FALSE, VAR_3, VAR_31);
#endif

#ifdef VAR_36
	    VAR_38->b_flags &= ~VAR_88;
#endif
	    if (VAR_89 == VAR_92)
		VAR_20 = VAR_21;
	    handle_swap_exists(&VAR_15);
	}
	else
	{
	    /* COMMENT_131 */
	    /* COMMENT_132 */
	    /* COMMENT_133 */
	    do_modelines(VAR_93);

	    apply_autocmds_retval(VAR_94, NULL, NULL, FALSE, VAR_38,
								    &VAR_20);
	    apply_autocmds_retval(VAR_95, NULL, NULL, FALSE, VAR_38,
								    &VAR_20);
	}
	check_arg_idx(VAR_34);

	/* COMMENT_134 */
	/* COMMENT_135 */
	/* COMMENT_136 */
	if (!EQUAL_POS(VAR_34->w_cursor, VAR_23))
	{
	    char_u *VAR_96 = ml_get_curline();

	    if (VAR_34->w_cursor.lnum != VAR_23.lnum
		    || VAR_34->w_cursor.col != (int)(skipwhite(VAR_96) - VAR_96))
	    {
		VAR_4 = VAR_34->w_cursor.lnum;
		VAR_25 = VAR_34->w_cursor.col;
	    }
	}
	if (VAR_34->w_topline == VAR_24)
	    VAR_24 = 0;

	/* COMMENT_137 */
	changed_line_abv_curs();

#ifdef VAR_97
	maketitle();
#endif
#if defined(VAR_36) && defined(VAR_98)
	if (WIN_IS_POPUP(VAR_34) && VAR_34->w_p_pvw && VAR_20 != VAR_21)
	    popup_set_title(VAR_34);
#endif
    }

#ifdef VAR_99
    /* COMMENT_138 */
    /* COMMENT_139 */
    /* COMMENT_140 */
    if (VAR_34->w_p_diff)
    {
	diff_buf_add(VAR_38);
	diff_invalidate(VAR_38);
    }
#endif

#ifdef VAR_29
    /* COMMENT_141 */
    /* COMMENT_142 */
    if (VAR_30 && VAR_34->w_p_spell && *VAR_34->w_s->b_p_spl != VAR_48)
	(void)did_set_spelllang(VAR_34);
#endif

    if (VAR_28 == NULL)
    {
	if (VAR_25 >= 0)	/* COMMENT_143 */
	{
	    VAR_34->w_cursor.lnum = VAR_4;
	    VAR_34->w_cursor.col = VAR_25;
	    check_cursor();
	}
	else if (VAR_4 > 0)	/* COMMENT_144 */
	{
	    VAR_34->w_cursor.lnum = VAR_4;
	    check_cursor_lnum();
	    if (VAR_26 >= 0 && !VAR_100)
	    {
		/* COMMENT_145 */
		VAR_34->w_cursor.col = VAR_26;
		check_cursor_col();
		VAR_34->w_cursor.coladd = 0;
		VAR_34->w_set_curswant = TRUE;
	    }
	    else
		beginline(VAR_101 | VAR_102);
	}
	else			/* COMMENT_146 */
	{
	    if (VAR_103)
		VAR_34->w_cursor.lnum = VAR_38->b_ml.ml_line_count;
	    beginline(VAR_104 | VAR_102);
	}
    }

    /* COMMENT_147 */
    check_lnums(FALSE);

    /* COMMENT_148 */
                                                                    
                                        
       
    if (VAR_8 && !VAR_9)
    {
	int	VAR_105 = VAR_106;

	/* COMMENT_152 */
	/* COMMENT_153 */
	if (shortmess(VAR_107) && !VAR_42 && VAR_108 == 0)
	    VAR_106 = FALSE;
	if (!VAR_106)	/* COMMENT_154 */
	    check_for_delay(FALSE);
	msg_start();
	VAR_106 = VAR_105;
	VAR_109 = TRUE;

	if (!shortmess(VAR_110))
	    fileinfo(FALSE, TRUE, FALSE);

	VAR_109 = FALSE;
    }

#ifdef VAR_111
    VAR_38->b_last_used = vim_time();
#endif

    if (VAR_28 != NULL)
	do_cmdline(VAR_28, NULL, NULL, VAR_112|VAR_113);

#ifdef VAR_114
    if (VAR_38->b_kmap_state & VAR_115)
	(void)keymap_init();
#endif

    --VAR_77;
    VAR_32 = FALSE;
    if (!VAR_116)
    {
	VAR_22 = *VAR_33;
	if (VAR_24 == 0 && VAR_28 == NULL)
	    *VAR_33 = 9999;		/* COMMENT_155 */
	update_topline();
	VAR_34->w_scbind_pos = VAR_34->w_topline;
	*VAR_33 = VAR_22;
	redraw_curbuf_later(VAR_117);	/* COMMENT_156 */
    }

    if (VAR_118)
	VAR_119 = TRUE;

#ifdef VAR_120
    /* COMMENT_157 */
    /* COMMENT_158 */
    /* COMMENT_159 */
    if (VAR_121 && VAR_38->b_ffname != NULL)
    {
	char_u	VAR_122[VAR_123];
	char_u	VAR_124[VAR_123];

	vim_strncpy(VAR_124, VAR_38->b_ffname, VAR_123 - 1);
	*gettail_sep(VAR_124) = VAR_48;
	if (mch_dirname(VAR_122, VAR_123) != VAR_21
		&& vim_fnamecmp(VAR_122, VAR_124) != 0)
	    do_autochdir();
    }
#endif

#if defined(VAR_125)
    if (VAR_38->b_ffname != NULL)
    {
# ifdef VAR_125
	if ((VAR_5 & VAR_66) != VAR_66)
	    netbeans_file_opened(VAR_38);
# endif
    }
#endif

theend:
    if (VAR_32)
	--VAR_77;
#if defined(VAR_11)
    if (VAR_12)
	set_vim_var_string(VAR_57, NULL, -1);
#endif
#ifdef VAR_17
    vim_free(VAR_19);
#endif
    vim_free(VAR_16);
    return VAR_20;
}",vim/797e63b9f2baa1853e7063aac478d663cd02f207/ex_cmds.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -278,6 +278,8 @@
 	    else
 	    {
 		win_T	    *the_curwin = curwin;
+		int	    did_decrement;
+		buf_T	    *was_curbuf = curbuf;
 
 		// Set the w_closing flag to avoid that autocommands close the
 		// window.  And set b_locked for the same reason.
@@ -290,7 +292,7 @@
 		// Close the link to the current buffer. This will set
 		// oldwin->w_buffer to NULL.
 		u_sync(FALSE);
-		close_buffer(oldwin, curbuf,
+		did_decrement = close_buffer(oldwin, curbuf,
 			 (flags & ECMD_HIDE) ? 0 : DOBUF_UNLOAD, FALSE, FALSE);
 
 		the_curwin->w_closing = FALSE;
@@ -312,7 +314,15 @@
 		    goto theend;
 		}
 		if (buf == curbuf)		// already in new buffer
+		{
+		    // close_buffer() has decremented the window count,
+		    // increment it again here and restore w_buffer.
+		    if (did_decrement && buf_valid(was_curbuf))
+			++was_curbuf->b_nwindows;
+		    if (win_valid_any_tab(oldwin) && oldwin->w_buffer == NULL)
+			oldwin->w_buffer = was_curbuf;
 		    auto_buf = TRUE;
+		}
 		else
 		{
 #ifdef FEAT_SYN_HL","{'deleted_lines': ['\t\tclose_buffer(oldwin, curbuf,'], 'added_lines': ['\t\tint\t    did_decrement;', '\t\tbuf_T\t    *was_curbuf = curbuf;', '\t\tdid_decrement = close_buffer(oldwin, curbuf,', '\t\t{', '\t\t    // close_buffer() has decremented the window count,', '\t\t    // increment it again here and restore w_buffer.', '\t\t    if (did_decrement && buf_valid(was_curbuf))', '\t\t\t++was_curbuf->b_nwindows;', '\t\t    if (win_valid_any_tab(oldwin) && oldwin->w_buffer == NULL)', '\t\t\toldwin->w_buffer = was_curbuf;', '\t\t}']}",True,"vim 8.2.2348 is affected by null pointer dereference, allows local attackers to cause a denial of service (DoS) via the ex_buffer_all method.",5.5,MEDIUM,1,valid,2021-01-15T15:22:52Z,3
CVE-2021-3236,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,vim,"patch 8.2.2354: crash with a weird combination of autocommands

Problem:    Crash with a weird combination of autocommands.
Solution:   Increment b_nwindows when needed. (closes #7674)",797e63b9f2baa1853e7063aac478d663cd02f207,https://github.com/vim/vim/commit/797e63b9f2baa1853e7063aac478d663cd02f207,src/buffer.c,close_buffer,"void
close_buffer(
win_T*win,    buf_T*buf,
intaction,
intabort_if_last,
intignore_abort)
{
intis_curbuf;
intnwindows;
bufref_Tbufref;
intis_curwin = (curwin != NULL && curwin->w_buffer == buf);
win_T*the_curwin = curwin;
tabpage_T*the_curtab = curtab;
intunload_buf = (action != 0);
intwipe_buf = (action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);
intdel_buf = (action == DOBUF_DEL || wipe_buf);
CHECK_CURBUF;
if (buf->b_p_bh[0] == 'd')    {
del_buf = TRUE;
unload_buf = TRUE;
}
else if (buf->b_p_bh[0] == 'w')    {
del_buf = TRUE;
unload_buf = TRUE;
wipe_buf = TRUE;
}
else if (buf->b_p_bh[0] == 'u')unload_buf = TRUE;
#ifdef FEAT_TERMINAL
if (bt_terminal(buf) && (buf->b_nwindows == 1 || del_buf))
{
CHECK_CURBUF;
if (term_job_running(buf->b_term))
{
if (wipe_buf || unload_buf)
{
if (!can_unload_buffer(buf))
return;
free_terminal(buf);
}
else
{
del_buf = FALSE;
unload_buf = FALSE;
}
}
else if (buf->b_p_bh[0] == 'h' && !del_buf)
{
unload_buf = FALSE;
}
else
{
del_buf = TRUE;
unload_buf = TRUE;
wipe_buf = TRUE;
}
CHECK_CURBUF;
}
#endif
if ((del_buf || wipe_buf) && !can_unload_buffer(buf))
return;
if (win != NULL && win_valid_any_tab(win))
{
if (buf->b_nwindows == 1)
set_last_cursor(win);
buflist_setfpos(buf, win,
win->w_cursor.lnum == 1 ? 0 : win->w_cursor.lnum,
win->w_cursor.col, TRUE);
}
set_bufref(&bufref, buf);
if (buf->b_nwindows == 1)
{
++buf->b_locked;
if (apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname, buf->b_fname,
FALSE, buf)
&& !bufref_valid(&bufref))
{
aucmd_abort:
emsg(_(e_auabort));
return;
}
--buf->b_locked;
if (abort_if_last && one_window())
goto aucmd_abort;
if (!unload_buf)
{
++buf->b_locked;
if (apply_autocmds(EVENT_BUFHIDDEN, buf->b_fname, buf->b_fname,
FALSE, buf)
&& !bufref_valid(&bufref))
goto aucmd_abort;
--buf->b_locked;
if (abort_if_last && one_window())
goto aucmd_abort;
}
#ifdef FEAT_EVAL
if (!ignore_abort && aborting())
return;
#endif
}
if (is_curwin && curwin != the_curwin &&  win_valid_any_tab(the_curwin))
{
block_autocmds();
goto_tabpage_win(the_curtab, the_curwin);
unblock_autocmds();
}
nwindows = buf->b_nwindows;
if (buf->b_nwindows > 0)
--buf->b_nwindows;
#ifdef FEAT_DIFF
if (diffopt_hiddenoff() && !unload_buf && buf->b_nwindows == 0)
diff_buf_delete(buf);#endif
if (buf->b_nwindows > 0 || !unload_buf)
return;
if (buf->b_ffname == NULL)
del_buf = TRUE;
if (buf == curbuf && VIsual_active
#if defined(EXITFREE)
&& !entered_free_all_mem
#endif
)
end_visual_mode();
is_curbuf = (buf == curbuf);
buf->b_nwindows = nwindows;
buf_freeall(buf, (del_buf ? BFA_DEL : 0)
+ (wipe_buf ? BFA_WIPE : 0)
+ (ignore_abort ? BFA_IGNORE_ABORT : 0));
if (!bufref_valid(&bufref))
return;
#ifdef FEAT_EVAL
if (!ignore_abort && aborting())
return;
#endif
if (buf == curbuf && !is_curbuf)
return;
if (win_valid_any_tab(win) && win->w_buffer == buf)
win->w_buffer = NULL;  
if (buf->b_nwindows > 0)
--buf->b_nwindows;
if (wipe_buf)
{
if (action == DOBUF_WIPE_REUSE)
{
if (buf_reuse.ga_itemsize == 0)
ga_init2(&buf_reuse, sizeof(int), 50);
if (ga_grow(&buf_reuse, 1) == OK)
((int *)buf_reuse.ga_data)[buf_reuse.ga_len++] = buf->b_fnum;
}
if (buf->b_sfname != buf->b_ffname)
VIM_CLEAR(buf->b_sfname);
else
buf->b_sfname = NULL;
VIM_CLEAR(buf->b_ffname);
if (buf->b_prev == NULL)
firstbuf = buf->b_next;
else
buf->b_prev->b_next = buf->b_next;
if (buf->b_next == NULL)
lastbuf = buf->b_prev;
else
buf->b_next->b_prev = buf->b_prev;
free_buffer(buf);
}
else
{
if (del_buf)
{
free_buffer_stuff(buf, TRUE);
buf->b_flags = BF_CHECK_RO | BF_NEVERLOADED;
buf->b_p_initialized = FALSE;
}
buf_clear_file(buf);
if (del_buf)
buf->b_p_bl = FALSE;
}
}","void
close_buffer(
win_T*VAR_0,
buf_T*VAR_1,
intVAR_2,
intVAR_3,
intVAR_4)
{
intVAR_5;
intVAR_6;
bufref_TVAR_7;
intVAR_8 = (VAR_9 != NULL && VAR_9->w_buffer == VAR_1);
win_T*VAR_10 = VAR_9;
tabpage_T*VAR_11 = VAR_12;
intVAR_13 = (VAR_2 != 0);
intVAR_14 = (VAR_2 == VAR_15 || VAR_2 == VAR_16);
intVAR_17 = (VAR_2 == VAR_18 || VAR_14);
VAR_19;
if (VAR_1->b_p_bh[0] == 'd')
{
VAR_17 = TRUE;
VAR_13 = TRUE;
}
else if (VAR_1->b_p_bh[0] == 'w')
{
VAR_17 = TRUE;
VAR_13 = TRUE;
VAR_14 = TRUE;
}
else if (VAR_1->b_p_bh[0] == 'u')
VAR_13 = TRUE;
#ifdef VAR_20
if (bt_terminal(VAR_1) && (VAR_1->b_nwindows == 1 || VAR_17))
{
VAR_19;
if (term_job_running(VAR_1->b_term))
{
if (VAR_14 || VAR_13)
{
if (!can_unload_buffer(VAR_1))
return;
free_terminal(VAR_1);
}
else
{
VAR_17 = FALSE;
VAR_13 = FALSE;
}
}
else if (VAR_1->b_p_bh[0] == 'h' && !VAR_17)
{
VAR_13 = FALSE;
}
else
{
VAR_17 = TRUE;
VAR_13 = TRUE;
VAR_14 = TRUE;
}
VAR_19;
}
#endif
if ((VAR_17 || VAR_14) && !can_unload_buffer(VAR_1))
return;
if (VAR_0 != NULL && win_valid_any_tab(VAR_0))
{
if (VAR_1->b_nwindows == 1)
set_last_cursor(VAR_0);
buflist_setfpos(VAR_1, VAR_0,
VAR_0->w_cursor.lnum == 1 ? 0 : VAR_0->w_cursor.lnum,
VAR_0->w_cursor.col, TRUE);
}
set_bufref(&VAR_7, VAR_1);
if (VAR_1->b_nwindows == 1)
{
++VAR_1->b_locked;
if (apply_autocmds(VAR_21, VAR_1->b_fname, VAR_1->b_fname,
FALSE, VAR_1)
&& !bufref_valid(&VAR_7))
{
aucmd_abort:
emsg(_(VAR_22));
return;
}
--VAR_1->b_locked;
if (VAR_3 && one_window())
goto aucmd_abort;
if (!VAR_13)
{
++VAR_1->b_locked;
if (apply_autocmds(VAR_23, VAR_1->b_fname, VAR_1->b_fname,
FALSE, VAR_1)
&& !bufref_valid(&VAR_7))
goto aucmd_abort;
--VAR_1->b_locked;
if (VAR_3 && one_window())
goto aucmd_abort;
}
#ifdef VAR_24
if (!VAR_4 && aborting())
return;
#endif
}
if (VAR_8 && VAR_9 != VAR_10 &&  win_valid_any_tab(VAR_10))
{
block_autocmds();
goto_tabpage_win(VAR_11, VAR_10);
unblock_autocmds();
}
VAR_6 = VAR_1->b_nwindows;
if (VAR_1->b_nwindows > 0)
--VAR_1->b_nwindows;
#ifdef VAR_25
if (diffopt_hiddenoff() && !VAR_13 && VAR_1->b_nwindows == 0)
diff_buf_delete(VAR_1);
#endif
if (VAR_1->b_nwindows > 0 || !VAR_13)
return;
if (VAR_1->b_ffname == NULL)
VAR_17 = TRUE;
if (VAR_1 == VAR_26 && VAR_27
#if defined(VAR_28)
&& !VAR_29
#endif
)
end_visual_mode();
VAR_5 = (VAR_1 == VAR_26);
VAR_1->b_nwindows = VAR_6;
buf_freeall(VAR_1, (VAR_17 ? VAR_30 : 0)
+ (VAR_14 ? VAR_31 : 0)
+ (VAR_4 ? VAR_32 : 0));
if (!bufref_valid(&VAR_7))
return;
#ifdef VAR_24
if (!VAR_4 && aborting())
return;
#endif
if (VAR_1 == VAR_26 && !VAR_5)
return;
if (win_valid_any_tab(VAR_0) && VAR_0->w_buffer == VAR_1)
VAR_0->w_buffer = NULL;  
if (VAR_1->b_nwindows > 0)
--VAR_1->b_nwindows;
if (VAR_14)
{
if (VAR_2 == VAR_16)
{
if (VAR_33.ga_itemsize == 0)
ga_init2(&VAR_33, sizeof(int), 50);
if (ga_grow(&VAR_33, 1) == VAR_34)
((int *)VAR_33.ga_data)[VAR_33.ga_len++] = VAR_1->b_fnum;
}
if (VAR_1->b_sfname != VAR_1->b_ffname)
VIM_CLEAR(VAR_1->b_sfname);
else
VAR_1->b_sfname = NULL;
VIM_CLEAR(VAR_1->b_ffname);
if (VAR_1->b_prev == NULL)
VAR_35 = VAR_1->b_next;
else
VAR_1->b_prev->b_next = VAR_1->b_next;
if (VAR_1->b_next == NULL)
VAR_36 = VAR_1->b_prev;
else
VAR_1->b_next->b_prev = VAR_1->b_prev;
free_buffer(VAR_1);
}
else
{
if (VAR_17)
{
free_buffer_stuff(VAR_1, TRUE);
VAR_1->b_flags = VAR_37 | VAR_38;
VAR_1->b_p_initialized = FALSE;
}
buf_clear_file(VAR_1);
if (VAR_17)
VAR_1->b_p_bl = FALSE;
}
}",vim/797e63b9f2baa1853e7063aac478d663cd02f207/buffer.c/vul/before/0.json,"int
close_buffer(
    win_T	*win,		// if not NULL, set b_last_cursor
    buf_T	*buf,
    int		action,
    int		abort_if_last,
    int		ignore_abort)
{
    int		is_curbuf;
    int		nwindows;
    bufref_T	bufref;
    int		is_curwin = (curwin != NULL && curwin->w_buffer == buf);
    win_T	*the_curwin = curwin;
    tabpage_T	*the_curtab = curtab;
    int		unload_buf = (action != 0);
    int		wipe_buf = (action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);
    int		del_buf = (action == DOBUF_DEL || wipe_buf);

    CHECK_CURBUF;
    /*
     * Force unloading or deleting when 'bufhidden' says so.
     * The caller must take care of NOT deleting/freeing when 'bufhidden' is
     * ""hide"" (otherwise we could never free or delete a buffer).
     */
    if (buf->b_p_bh[0] == 'd')		// 'bufhidden' == ""delete""
    {
	del_buf = TRUE;
	unload_buf = TRUE;
    }
    else if (buf->b_p_bh[0] == 'w')	// 'bufhidden' == ""wipe""
    {
	del_buf = TRUE;
	unload_buf = TRUE;
	wipe_buf = TRUE;
    }
    else if (buf->b_p_bh[0] == 'u')	// 'bufhidden' == ""unload""
	unload_buf = TRUE;

#ifdef FEAT_TERMINAL
    if (bt_terminal(buf) && (buf->b_nwindows == 1 || del_buf))
    {
	CHECK_CURBUF;
	if (term_job_running(buf->b_term))
	{
	    if (wipe_buf || unload_buf)
	    {
		if (!can_unload_buffer(buf))
		    return FALSE;

		// Wiping out or unloading a terminal buffer kills the job.
		free_terminal(buf);
	    }
	    else
	    {
		// The job keeps running, hide the buffer.
		del_buf = FALSE;
		unload_buf = FALSE;
	    }
	}
	else if (buf->b_p_bh[0] == 'h' && !del_buf)
	{
	    // Hide a terminal buffer.
	    unload_buf = FALSE;
	}
	else
	{
	    // A terminal buffer is wiped out if the job has finished.
	    del_buf = TRUE;
	    unload_buf = TRUE;
	    wipe_buf = TRUE;
	}
	CHECK_CURBUF;
    }
#endif

    // Disallow deleting the buffer when it is locked (already being closed or
    // halfway a command that relies on it). Unloading is allowed.
    if ((del_buf || wipe_buf) && !can_unload_buffer(buf))
	return FALSE;

    // check no autocommands closed the window
    if (win != NULL && win_valid_any_tab(win))
    {
	// Set b_last_cursor when closing the last window for the buffer.
	// Remember the last cursor position and window options of the buffer.
	// This used to be only for the current window, but then options like
	// 'foldmethod' may be lost with a "":only"" command.
	if (buf->b_nwindows == 1)
	    set_last_cursor(win);
	buflist_setfpos(buf, win,
		    win->w_cursor.lnum == 1 ? 0 : win->w_cursor.lnum,
		    win->w_cursor.col, TRUE);
    }

    set_bufref(&bufref, buf);

    // When the buffer is no longer in a window, trigger BufWinLeave
    if (buf->b_nwindows == 1)
    {
	++buf->b_locked;
	if (apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname, buf->b_fname,
								  FALSE, buf)
		&& !bufref_valid(&bufref))
	{
	    // Autocommands deleted the buffer.
aucmd_abort:
	    emsg(_(e_auabort));
	    return FALSE;
	}
	--buf->b_locked;
	if (abort_if_last && one_window())
	    // Autocommands made this the only window.
	    goto aucmd_abort;

	// When the buffer becomes hidden, but is not unloaded, trigger
	// BufHidden
	if (!unload_buf)
	{
	    ++buf->b_locked;
	    if (apply_autocmds(EVENT_BUFHIDDEN, buf->b_fname, buf->b_fname,
								  FALSE, buf)
		    && !bufref_valid(&bufref))
		// Autocommands deleted the buffer.
		goto aucmd_abort;
	    --buf->b_locked;
	    if (abort_if_last && one_window())
		// Autocommands made this the only window.
		goto aucmd_abort;
	}
#ifdef FEAT_EVAL
	// autocmds may abort script processing
	if (!ignore_abort && aborting())
	    return FALSE;
#endif
    }

    // If the buffer was in curwin and the window has changed, go back to that
    // window, if it still exists.  This avoids that "":edit x"" triggering a
    // ""tabnext"" BufUnload autocmd leaves a window behind without a buffer.
    if (is_curwin && curwin != the_curwin &&  win_valid_any_tab(the_curwin))
    {
	block_autocmds();
	goto_tabpage_win(the_curtab, the_curwin);
	unblock_autocmds();
    }

    nwindows = buf->b_nwindows;

    // decrease the link count from windows (unless not in any window)
    if (buf->b_nwindows > 0)
	--buf->b_nwindows;

#ifdef FEAT_DIFF
    if (diffopt_hiddenoff() && !unload_buf && buf->b_nwindows == 0)
	diff_buf_delete(buf);	// Clear 'diff' for hidden buffer.
#endif

    // Return when a window is displaying the buffer or when it's not
    // unloaded.
    if (buf->b_nwindows > 0 || !unload_buf)
	return FALSE;

    // Always remove the buffer when there is no file name.
    if (buf->b_ffname == NULL)
	del_buf = TRUE;

    // When closing the current buffer stop Visual mode before freeing
    // anything.
    if (buf == curbuf && VIsual_active
#if defined(EXITFREE)
	    && !entered_free_all_mem
#endif
	    )
	end_visual_mode();

    /*
     * Free all things allocated for this buffer.
     * Also calls the ""BufDelete"" autocommands when del_buf is TRUE.
     */
    // Remember if we are closing the current buffer.  Restore the number of
    // windows, so that autocommands in buf_freeall() don't get confused.
    is_curbuf = (buf == curbuf);
    buf->b_nwindows = nwindows;

    buf_freeall(buf, (del_buf ? BFA_DEL : 0)
		   + (wipe_buf ? BFA_WIPE : 0)
		   + (ignore_abort ? BFA_IGNORE_ABORT : 0));

    // Autocommands may have deleted the buffer.
    if (!bufref_valid(&bufref))
	return FALSE;
#ifdef FEAT_EVAL
    // autocmds may abort script processing
    if (!ignore_abort && aborting())
	return FALSE;
#endif

    /*
     * It's possible that autocommands change curbuf to the one being deleted.
     * This might cause the previous curbuf to be deleted unexpectedly.  But
     * in some cases it's OK to delete the curbuf, because a new one is
     * obtained anyway.  Therefore only return if curbuf changed to the
     * deleted buffer.
     */
    if (buf == curbuf && !is_curbuf)
	return FALSE;

    if (win_valid_any_tab(win) && win->w_buffer == buf)
	win->w_buffer = NULL;  // make sure we don't use the buffer now

    // Autocommands may have opened or closed windows for this buffer.
    // Decrement the count for the close we do here.
    if (buf->b_nwindows > 0)
	--buf->b_nwindows;

    /*
     * Remove the buffer from the list.
     */
    if (wipe_buf)
    {
	if (action == DOBUF_WIPE_REUSE)
	{
	    // we can re-use this buffer number, store it
	    if (buf_reuse.ga_itemsize == 0)
		ga_init2(&buf_reuse, sizeof(int), 50);
	    if (ga_grow(&buf_reuse, 1) == OK)
		((int *)buf_reuse.ga_data)[buf_reuse.ga_len++] = buf->b_fnum;
	}
	if (buf->b_sfname != buf->b_ffname)
	    VIM_CLEAR(buf->b_sfname);
	else
	    buf->b_sfname = NULL;
	VIM_CLEAR(buf->b_ffname);
	if (buf->b_prev == NULL)
	    firstbuf = buf->b_next;
	else
	    buf->b_prev->b_next = buf->b_next;
	if (buf->b_next == NULL)
	    lastbuf = buf->b_prev;
	else
	    buf->b_next->b_prev = buf->b_prev;
	free_buffer(buf);
    }
    else
    {
	if (del_buf)
	{
	    // Free all internal variables and reset option values, to make
	    // "":bdel"" compatible with Vim 5.7.
	    free_buffer_stuff(buf, TRUE);

	    // Make it look like a new buffer.
	    buf->b_flags = BF_CHECK_RO | BF_NEVERLOADED;

	    // Init the options when loaded again.
	    buf->b_p_initialized = FALSE;
	}
	buf_clear_file(buf);
	if (del_buf)
	    buf->b_p_bl = FALSE;
    }
    // NOTE: at this point ""curbuf"" may be invalid!
    return TRUE;
}","int
close_buffer(
    win_T	*VAR_0,		/* COMMENT_0 */
    buf_T	*VAR_1,
    int		VAR_2,
    int		VAR_3,
    int		VAR_4)
{
    int		VAR_5;
    int		VAR_6;
    bufref_T	VAR_7;
    int		VAR_8 = (VAR_9 != NULL && VAR_9->w_buffer == VAR_1);
    win_T	*VAR_10 = VAR_9;
    tabpage_T	*VAR_11 = VAR_12;
    int		VAR_13 = (VAR_2 != 0);
    int		VAR_14 = (VAR_2 == VAR_15 || VAR_2 == VAR_16);
    int		VAR_17 = (VAR_2 == VAR_18 || VAR_14);

    VAR_19;
    /* COMMENT_1 */
                                                            
                                                                            
                                                                 
       
    if (VAR_1->b_p_bh[0] == 'd')		/* COMMENT_6 */
    {
	VAR_17 = TRUE;
	VAR_13 = TRUE;
    }
    else if (VAR_1->b_p_bh[0] == 'w')	/* COMMENT_7 */
    {
	VAR_17 = TRUE;
	VAR_13 = TRUE;
	VAR_14 = TRUE;
    }
    else if (VAR_1->b_p_bh[0] == 'u')	/* COMMENT_8 */
	VAR_13 = TRUE;

#ifdef VAR_20
    if (bt_terminal(VAR_1) && (VAR_1->b_nwindows == 1 || VAR_17))
    {
	VAR_19;
	if (term_job_running(VAR_1->b_term))
	{
	    if (VAR_14 || VAR_13)
	    {
		if (!can_unload_buffer(VAR_1))
		    return FALSE;

		/* COMMENT_9 */
		free_terminal(VAR_1);
	    }
	    else
	    {
		/* COMMENT_10 */
		VAR_17 = FALSE;
		VAR_13 = FALSE;
	    }
	}
	else if (VAR_1->b_p_bh[0] == 'h' && !VAR_17)
	{
	    /* COMMENT_11 */
	    VAR_13 = FALSE;
	}
	else
	{
	    /* COMMENT_12 */
	    VAR_17 = TRUE;
	    VAR_13 = TRUE;
	    VAR_14 = TRUE;
	}
	VAR_19;
    }
#endif

    /* COMMENT_13 */
    /* COMMENT_14 */
    if ((VAR_17 || VAR_14) && !can_unload_buffer(VAR_1))
	return FALSE;

    /* COMMENT_15 */
    if (VAR_0 != NULL && win_valid_any_tab(VAR_0))
    {
	/* COMMENT_16 */
	/* COMMENT_17 */
	/* COMMENT_18 */
	/* COMMENT_19 */
	if (VAR_1->b_nwindows == 1)
	    set_last_cursor(VAR_0);
	buflist_setfpos(VAR_1, VAR_0,
		    VAR_0->w_cursor.lnum == 1 ? 0 : VAR_0->w_cursor.lnum,
		    VAR_0->w_cursor.col, TRUE);
    }

    set_bufref(&VAR_7, VAR_1);

    /* COMMENT_20 */
    if (VAR_1->b_nwindows == 1)
    {
	++VAR_1->b_locked;
	if (apply_autocmds(VAR_21, VAR_1->b_fname, VAR_1->b_fname,
								  FALSE, VAR_1)
		&& !bufref_valid(&VAR_7))
	{
	    /* COMMENT_21 */
aucmd_abort:
	    emsg(_(VAR_22));
	    return FALSE;
	}
	--VAR_1->b_locked;
	if (VAR_3 && one_window())
	    /* COMMENT_22 */
	    goto aucmd_abort;

	/* COMMENT_23 */
	/* COMMENT_24 */
	if (!VAR_13)
	{
	    ++VAR_1->b_locked;
	    if (apply_autocmds(VAR_23, VAR_1->b_fname, VAR_1->b_fname,
								  FALSE, VAR_1)
		    && !bufref_valid(&VAR_7))
		/* COMMENT_21 */
		goto aucmd_abort;
	    --VAR_1->b_locked;
	    if (VAR_3 && one_window())
		/* COMMENT_22 */
		goto aucmd_abort;
	}
#ifdef VAR_24
	/* COMMENT_25 */
	if (!VAR_4 && aborting())
	    return FALSE;
#endif
    }

    /* COMMENT_26 */
    /* COMMENT_27 */
    /* COMMENT_28 */
    if (VAR_8 && VAR_9 != VAR_10 &&  win_valid_any_tab(VAR_10))
    {
	block_autocmds();
	goto_tabpage_win(VAR_11, VAR_10);
	unblock_autocmds();
    }

    VAR_6 = VAR_1->b_nwindows;

    /* COMMENT_29 */
    if (VAR_1->b_nwindows > 0)
	--VAR_1->b_nwindows;

#ifdef VAR_25
    if (diffopt_hiddenoff() && !VAR_13 && VAR_1->b_nwindows == 0)
	diff_buf_delete(VAR_1);	/* COMMENT_30 */
#endif

    /* COMMENT_31 */
    /* COMMENT_32 */
    if (VAR_1->b_nwindows > 0 || !VAR_13)
	return FALSE;

    /* COMMENT_33 */
    if (VAR_1->b_ffname == NULL)
	VAR_17 = TRUE;

    /* COMMENT_34 */
    /* COMMENT_35 */
    if (VAR_1 == VAR_26 && VAR_27
#if defined(VAR_28)
	    && !VAR_29
#endif
	    )
	end_visual_mode();

    /* COMMENT_36 */
                                                 
                                                                    
       
    /* COMMENT_40 */
    /* COMMENT_41 */
    VAR_5 = (VAR_1 == VAR_26);
    VAR_1->b_nwindows = VAR_6;

    buf_freeall(VAR_1, (VAR_17 ? VAR_30 : 0)
		   + (VAR_14 ? VAR_31 : 0)
		   + (VAR_4 ? VAR_32 : 0));

    /* COMMENT_42 */
    if (!bufref_valid(&VAR_7))
	return FALSE;
#ifdef VAR_24
    /* COMMENT_25 */
    if (!VAR_4 && aborting())
	return FALSE;
#endif

    /* COMMENT_43 */
                                                                              
                                                                            
                                                                       
                                                                       
                      
       
    if (VAR_1 == VAR_26 && !VAR_5)
	return FALSE;

    if (win_valid_any_tab(VAR_0) && VAR_0->w_buffer == VAR_1)
	VAR_0->w_buffer = NULL;  /* COMMENT_50 */

    /* COMMENT_51 */
    /* COMMENT_52 */
    if (VAR_1->b_nwindows > 0)
	--VAR_1->b_nwindows;

    /* COMMENT_53 */
                                       
       
    if (VAR_14)
    {
	if (VAR_2 == VAR_16)
	{
	    /* COMMENT_56 */
	    if (VAR_33.ga_itemsize == 0)
		ga_init2(&VAR_33, sizeof(int), 50);
	    if (ga_grow(&VAR_33, 1) == VAR_34)
		((int *)VAR_33.ga_data)[VAR_33.ga_len++] = VAR_1->b_fnum;
	}
	if (VAR_1->b_sfname != VAR_1->b_ffname)
	    VIM_CLEAR(VAR_1->b_sfname);
	else
	    VAR_1->b_sfname = NULL;
	VIM_CLEAR(VAR_1->b_ffname);
	if (VAR_1->b_prev == NULL)
	    VAR_35 = VAR_1->b_next;
	else
	    VAR_1->b_prev->b_next = VAR_1->b_next;
	if (VAR_1->b_next == NULL)
	    VAR_36 = VAR_1->b_prev;
	else
	    VAR_1->b_next->b_prev = VAR_1->b_prev;
	free_buffer(VAR_1);
    }
    else
    {
	if (VAR_17)
	{
	    /* COMMENT_57 */
	    /* COMMENT_58 */
	    free_buffer_stuff(VAR_1, TRUE);

	    /* COMMENT_59 */
	    VAR_1->b_flags = VAR_37 | VAR_38;

	    /* COMMENT_60 */
	    VAR_1->b_p_initialized = FALSE;
	}
	buf_clear_file(VAR_1);
	if (VAR_17)
	    VAR_1->b_p_bl = FALSE;
    }
    /* COMMENT_61 */
    return TRUE;
}",vim/797e63b9f2baa1853e7063aac478d663cd02f207/buffer.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-void
+int
 close_buffer(
     win_T	*win,		// if not NULL, set b_last_cursor
     buf_T	*buf,
@@ -45,7 +45,7 @@
 	    if (wipe_buf || unload_buf)
 	    {
 		if (!can_unload_buffer(buf))
-		    return;
+		    return FALSE;
 
 		// Wiping out or unloading a terminal buffer kills the job.
 		free_terminal(buf);
@@ -76,7 +76,7 @@
     // Disallow deleting the buffer when it is locked (already being closed or
     // halfway a command that relies on it). Unloading is allowed.
     if ((del_buf || wipe_buf) && !can_unload_buffer(buf))
-	return;
+	return FALSE;
 
     // check no autocommands closed the window
     if (win != NULL && win_valid_any_tab(win))
@@ -105,7 +105,7 @@
 	    // Autocommands deleted the buffer.
 aucmd_abort:
 	    emsg(_(e_auabort));
-	    return;
+	    return FALSE;
 	}
 	--buf->b_locked;
 	if (abort_if_last && one_window())
@@ -130,7 +130,7 @@
 #ifdef FEAT_EVAL
 	// autocmds may abort script processing
 	if (!ignore_abort && aborting())
-	    return;
+	    return FALSE;
 #endif
     }
 
@@ -158,7 +158,7 @@
     // Return when a window is displaying the buffer or when it's not
     // unloaded.
     if (buf->b_nwindows > 0 || !unload_buf)
-	return;
+	return FALSE;
 
     // Always remove the buffer when there is no file name.
     if (buf->b_ffname == NULL)
@@ -188,11 +188,11 @@
 
     // Autocommands may have deleted the buffer.
     if (!bufref_valid(&bufref))
-	return;
+	return FALSE;
 #ifdef FEAT_EVAL
     // autocmds may abort script processing
     if (!ignore_abort && aborting())
-	return;
+	return FALSE;
 #endif
 
     /*
@@ -203,7 +203,7 @@
      * deleted buffer.
      */
     if (buf == curbuf && !is_curbuf)
-	return;
+	return FALSE;
 
     if (win_valid_any_tab(win) && win->w_buffer == buf)
 	win->w_buffer = NULL;  // make sure we don't use the buffer now
@@ -260,4 +260,5 @@
 	    buf->b_p_bl = FALSE;
     }
     // NOTE: at this point ""curbuf"" may be invalid!
+    return TRUE;
 }","{'deleted_lines': ['void', '\t\t    return;', '\treturn;', '\t    return;', '\t    return;', '\treturn;', '\treturn;', '\treturn;', '\treturn;'], 'added_lines': ['int', '\t\t    return FALSE;', '\treturn FALSE;', '\t    return FALSE;', '\t    return FALSE;', '\treturn FALSE;', '\treturn FALSE;', '\treturn FALSE;', '\treturn FALSE;', '    return TRUE;']}",True,"vim 8.2.2348 is affected by null pointer dereference, allows local attackers to cause a denial of service (DoS) via the ex_buffer_all method.",5.5,MEDIUM,1,valid,2021-01-15T15:22:52Z,3
CVE-2021-3177,['CWE-120'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,python/cpython,closes bpo-42938: Replace snprintf with Python unicode formatting in ctypes param reprs.,298cc0231a271b5d5c6d55273297b9541353ecc3,https://github.com/python/cpython/commit/298cc0231a271b5d5c6d55273297b9541353ecc3,Modules/_ctypes/callproc.c,PyCArg_repr,"static PyObject *
PyCArg_repr(PyCArgObject *self)
{
char buffer[256];
switch(self->tag) {
case 'b':
case 'B':
sprintf(buffer, ""<cparam '%c' (%d)>"",
self->tag, self->value.b);
break;
case 'h':
case 'H':
sprintf(buffer, ""<cparam '%c' (%d)>"",
self->tag, self->value.h);
break;
case 'i':
case 'I':
sprintf(buffer, ""<cparam '%c' (%d)>"",
self->tag, self->value.i);
break;
case 'l':
case 'L':
sprintf(buffer, ""<cparam '%c' (%ld)>"",
self->tag, self->value.l);
break;
case 'q':
case 'Q':
sprintf(buffer,
#ifdef MS_WIN32
""<cparam '%c' (%I64d)>"",
#else
""<cparam '%c' (%lld)>"",
#endif
self->tag, self->value.q);
break;
case 'd':
sprintf(buffer, ""<cparam '%c' (%f)>"",
self->tag, self->value.d);
break;
case 'f':
sprintf(buffer, ""<cparam '%c' (%f)>"",
self->tag, self->value.f);
break;
case 'c':
if (is_literal_char((unsigned char)self->value.c)) {
sprintf(buffer, ""<cparam '%c' ('%c')>"",
self->tag, self->value.c);
}
else {
sprintf(buffer, ""<cparam '%c' ('\\x%02x')>"",
self->tag, (unsigned char)self->value.c);
}
break;
case 'z':
case 'Z':
case 'P':
sprintf(buffer, ""<cparam '%c' (%p)>"",
self->tag, self->value.p);
break;
default:
if (is_literal_char((unsigned char)self->tag)) {
sprintf(buffer, ""<cparam '%c' at %p>"",
(unsigned char)self->tag, (void *)self);
}
else {
sprintf(buffer, ""<cparam 0x%02x at %p>"",
(unsigned char)self->tag, (void *)self);
}
break;
}
return PyUnicode_FromString(buffer);
}","static PyObject *
PyCArg_repr(PyCArgObject *VAR_0)
{
char VAR_1[256];
switch(VAR_0->tag) {
case 'b':
case 'B':
sprintf(VAR_1, ""<cparam '%c' (%d)>"",
VAR_0->tag, VAR_0->value.b);
break;
case 'h':
case 'H':
sprintf(VAR_1, ""<cparam '%c' (%d)>"",
VAR_0->tag, VAR_0->value.h);
break;
case 'i':
case 'I':
sprintf(VAR_1, ""<cparam '%c' (%d)>"",
VAR_0->tag, VAR_0->value.i);
break;
case 'l':
case 'L':
sprintf(VAR_1, ""<cparam '%c' (%ld)>"",
VAR_0->tag, VAR_0->value.l);
break;
case 'q':
case 'Q':
VAR_2(VAR_1,
#ifdef VAR_3
""<cparam '%c' (%I64d)>"",
#else
""<cparam '%c' (%lld)>"",
#endif
VAR_0->tag, VAR_0->value.q);
break;
case 'd':
VAR_2(VAR_1, ""<cparam '%c' (%f)>"",
VAR_0->tag, VAR_0->value.d);
break;
case 'f':
VAR_2(VAR_1, ""<cparam '%c' (%f)>"",
VAR_0->tag, VAR_0->value.f);
break;
case 'c':
if (is_literal_char((unsigned char)VAR_0->value.c)) {
VAR_2(VAR_1, ""<cparam '%c' ('%c')>"",
VAR_0->tag, VAR_0->value.c);
}
else {
VAR_2(VAR_1, ""<cparam '%c' ('\\x%02x')>"",
VAR_0->tag, (unsigned char)VAR_0->value.c);
}
break;
case 'z':
case 'Z':
case 'P':
VAR_2(VAR_1, ""<cparam '%c' (%p)>"",
VAR_0->tag, VAR_0->value.p);
break;
default:
if (is_literal_char((unsigned char)VAR_0->tag)) {
VAR_2(VAR_1, ""<cparam '%c' at %p>"",
(unsigned char)VAR_0->tag, (void *)VAR_0);
}
else {
VAR_2(VAR_1, ""<cparam 0x%02x at %p>"",
(unsigned char)VAR_0->tag, (void *)VAR_0);
}
break;
}
return PyUnicode_FromString(VAR_1);
}",python/cpython/298cc0231a271b5d5c6d55273297b9541353ecc3/callproc.c/vul/before/0.json,"static PyObject *
PyCArg_repr(PyCArgObject *self)
{
    switch(self->tag) {
    case 'b':
    case 'B':
        return PyUnicode_FromFormat(""<cparam '%c' (%d)>"",
            self->tag, self->value.b);
    case 'h':
    case 'H':
        return PyUnicode_FromFormat(""<cparam '%c' (%d)>"",
            self->tag, self->value.h);
    case 'i':
    case 'I':
        return PyUnicode_FromFormat(""<cparam '%c' (%d)>"",
            self->tag, self->value.i);
    case 'l':
    case 'L':
        return PyUnicode_FromFormat(""<cparam '%c' (%ld)>"",
            self->tag, self->value.l);

    case 'q':
    case 'Q':
        return PyUnicode_FromFormat(""<cparam '%c' (%lld)>"",
            self->tag, self->value.q);
    case 'd':
    case 'f': {
        PyObject *f = PyFloat_FromDouble((self->tag == 'f') ? self->value.f : self->value.d);
        if (f == NULL) {
            return NULL;
        }
        PyObject *result = PyUnicode_FromFormat(""<cparam '%c' (%R)>"", self->tag, f);
        Py_DECREF(f);
        return result;
    }
    case 'c':
        if (is_literal_char((unsigned char)self->value.c)) {
            return PyUnicode_FromFormat(""<cparam '%c' ('%c')>"",
                self->tag, self->value.c);
        }
        else {
            return PyUnicode_FromFormat(""<cparam '%c' ('\\x%02x')>"",
                self->tag, (unsigned char)self->value.c);
        }

/* Hm, are these 'z' and 'Z' codes useful at all?
   Shouldn't they be replaced by the functionality of c_string
   and c_wstring ?
*/
    case 'z':
    case 'Z':
    case 'P':
        return PyUnicode_FromFormat(""<cparam '%c' (%p)>"",
            self->tag, self->value.p);
        break;

    default:
        if (is_literal_char((unsigned char)self->tag)) {
            return PyUnicode_FromFormat(""<cparam '%c' at %p>"",
                (unsigned char)self->tag, (void *)self);
        }
        else {
            return PyUnicode_FromFormat(""<cparam 0x%02x at %p>"",
                (unsigned char)self->tag, (void *)self);
        }
    }
}","static PyObject *
PyCArg_repr(PyCArgObject *VAR_0)
{
    switch(VAR_0->tag) {
    case 'b':
    case 'B':
        return PyUnicode_FromFormat(""<cparam '%c' (%d)>"",
            VAR_0->tag, VAR_0->value.b);
    case 'h':
    case 'H':
        return PyUnicode_FromFormat(""<cparam '%c' (%d)>"",
            VAR_0->tag, VAR_0->value.h);
    case 'i':
    case 'I':
        return PyUnicode_FromFormat(""<cparam '%c' (%d)>"",
            VAR_0->tag, VAR_0->value.i);
    case 'l':
    case 'L':
        return PyUnicode_FromFormat(""<cparam '%c' (%ld)>"",
            VAR_0->tag, VAR_0->value.l);

    case 'q':
    case 'Q':
        return PyUnicode_FromFormat(""<cparam '%c' (%lld)>"",
            VAR_0->tag, VAR_0->value.q);
    case 'd':
    case 'f': {
        PyObject *VAR_1 = PyFloat_FromDouble((VAR_0->tag == 'f') ? VAR_0->value.f : VAR_0->value.d);
        if (VAR_1 == NULL) {
            return NULL;
        }
        PyObject *VAR_2 = PyUnicode_FromFormat(""<cparam '%c' (%R)>"", VAR_0->tag, VAR_1);
        Py_DECREF(VAR_1);
        return VAR_2;
    }
    case 'c':
        if (is_literal_char((unsigned char)VAR_0->value.c)) {
            return PyUnicode_FromFormat(""<cparam '%c' ('%c')>"",
                VAR_0->tag, VAR_0->value.c);
        }
        else {
            return PyUnicode_FromFormat(""<cparam '%c' ('\\x%02x')>"",
                VAR_0->tag, (unsigned char)VAR_0->value.c);
        }

/* COMMENT_0 */
                                                              
                  
  
    case 'z':
    case 'Z':
    case 'P':
        return PyUnicode_FromFormat(""<cparam '%c' (%p)>"",
            VAR_0->tag, VAR_0->value.p);
        break;

    default:
        if (is_literal_char((unsigned char)VAR_0->tag)) {
            return PyUnicode_FromFormat(""<cparam '%c' at %p>"",
                (unsigned char)VAR_0->tag, (void *)VAR_0);
        }
        else {
            return PyUnicode_FromFormat(""<cparam 0x%02x at %p>"",
                (unsigned char)VAR_0->tag, (void *)VAR_0);
        }
    }
}",python/cpython/298cc0231a271b5d5c6d55273297b9541353ecc3/callproc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,58 +1,47 @@
 static PyObject *
 PyCArg_repr(PyCArgObject *self)
 {
-    char buffer[256];
     switch(self->tag) {
     case 'b':
     case 'B':
-        sprintf(buffer, ""<cparam '%c' (%d)>"",
+        return PyUnicode_FromFormat(""<cparam '%c' (%d)>"",
             self->tag, self->value.b);
-        break;
     case 'h':
     case 'H':
-        sprintf(buffer, ""<cparam '%c' (%d)>"",
+        return PyUnicode_FromFormat(""<cparam '%c' (%d)>"",
             self->tag, self->value.h);
-        break;
     case 'i':
     case 'I':
-        sprintf(buffer, ""<cparam '%c' (%d)>"",
+        return PyUnicode_FromFormat(""<cparam '%c' (%d)>"",
             self->tag, self->value.i);
-        break;
     case 'l':
     case 'L':
-        sprintf(buffer, ""<cparam '%c' (%ld)>"",
+        return PyUnicode_FromFormat(""<cparam '%c' (%ld)>"",
             self->tag, self->value.l);
-        break;
 
     case 'q':
     case 'Q':
-        sprintf(buffer,
-#ifdef MS_WIN32
-            ""<cparam '%c' (%I64d)>"",
-#else
-            ""<cparam '%c' (%lld)>"",
-#endif
+        return PyUnicode_FromFormat(""<cparam '%c' (%lld)>"",
             self->tag, self->value.q);
-        break;
     case 'd':
-        sprintf(buffer, ""<cparam '%c' (%f)>"",
-            self->tag, self->value.d);
-        break;
-    case 'f':
-        sprintf(buffer, ""<cparam '%c' (%f)>"",
-            self->tag, self->value.f);
-        break;
-
+    case 'f': {
+        PyObject *f = PyFloat_FromDouble((self->tag == 'f') ? self->value.f : self->value.d);
+        if (f == NULL) {
+            return NULL;
+        }
+        PyObject *result = PyUnicode_FromFormat(""<cparam '%c' (%R)>"", self->tag, f);
+        Py_DECREF(f);
+        return result;
+    }
     case 'c':
         if (is_literal_char((unsigned char)self->value.c)) {
-            sprintf(buffer, ""<cparam '%c' ('%c')>"",
+            return PyUnicode_FromFormat(""<cparam '%c' ('%c')>"",
                 self->tag, self->value.c);
         }
         else {
-            sprintf(buffer, ""<cparam '%c' ('\\x%02x')>"",
+            return PyUnicode_FromFormat(""<cparam '%c' ('\\x%02x')>"",
                 self->tag, (unsigned char)self->value.c);
         }
-        break;
 
 /* Hm, are these 'z' and 'Z' codes useful at all?
    Shouldn't they be replaced by the functionality of c_string
@@ -61,20 +50,18 @@
     case 'z':
     case 'Z':
     case 'P':
-        sprintf(buffer, ""<cparam '%c' (%p)>"",
+        return PyUnicode_FromFormat(""<cparam '%c' (%p)>"",
             self->tag, self->value.p);
         break;
 
     default:
         if (is_literal_char((unsigned char)self->tag)) {
-            sprintf(buffer, ""<cparam '%c' at %p>"",
+            return PyUnicode_FromFormat(""<cparam '%c' at %p>"",
                 (unsigned char)self->tag, (void *)self);
         }
         else {
-            sprintf(buffer, ""<cparam 0x%02x at %p>"",
+            return PyUnicode_FromFormat(""<cparam 0x%02x at %p>"",
                 (unsigned char)self->tag, (void *)self);
         }
-        break;
     }
-    return PyUnicode_FromString(buffer);
 }","{'deleted_lines': ['    char buffer[256];', '        sprintf(buffer, ""<cparam \'%c\' (%d)>"",', '        break;', '        sprintf(buffer, ""<cparam \'%c\' (%d)>"",', '        break;', '        sprintf(buffer, ""<cparam \'%c\' (%d)>"",', '        break;', '        sprintf(buffer, ""<cparam \'%c\' (%ld)>"",', '        break;', '        sprintf(buffer,', '#ifdef MS_WIN32', '            ""<cparam \'%c\' (%I64d)>"",', '#else', '            ""<cparam \'%c\' (%lld)>"",', '#endif', '        break;', '        sprintf(buffer, ""<cparam \'%c\' (%f)>"",', '            self->tag, self->value.d);', '        break;', ""    case 'f':"", '        sprintf(buffer, ""<cparam \'%c\' (%f)>"",', '            self->tag, self->value.f);', '        break;', '', '            sprintf(buffer, ""<cparam \'%c\' (\'%c\')>"",', '            sprintf(buffer, ""<cparam \'%c\' (\'\\\\x%02x\')>"",', '        break;', '        sprintf(buffer, ""<cparam \'%c\' (%p)>"",', '            sprintf(buffer, ""<cparam \'%c\' at %p>"",', '            sprintf(buffer, ""<cparam 0x%02x at %p>"",', '        break;', '    return PyUnicode_FromString(buffer);'], 'added_lines': ['        return PyUnicode_FromFormat(""<cparam \'%c\' (%d)>"",', '        return PyUnicode_FromFormat(""<cparam \'%c\' (%d)>"",', '        return PyUnicode_FromFormat(""<cparam \'%c\' (%d)>"",', '        return PyUnicode_FromFormat(""<cparam \'%c\' (%ld)>"",', '        return PyUnicode_FromFormat(""<cparam \'%c\' (%lld)>"",', ""    case 'f': {"", ""        PyObject *f = PyFloat_FromDouble((self->tag == 'f') ? self->value.f : self->value.d);"", '        if (f == NULL) {', '            return NULL;', '        }', '        PyObject *result = PyUnicode_FromFormat(""<cparam \'%c\' (%R)>"", self->tag, f);', '        Py_DECREF(f);', '        return result;', '    }', '            return PyUnicode_FromFormat(""<cparam \'%c\' (\'%c\')>"",', '            return PyUnicode_FromFormat(""<cparam \'%c\' (\'\\\\x%02x\')>"",', '        return PyUnicode_FromFormat(""<cparam \'%c\' (%p)>"",', '            return PyUnicode_FromFormat(""<cparam \'%c\' at %p>"",', '            return PyUnicode_FromFormat(""<cparam 0x%02x at %p>"",']}",True,"Python 3.x through 3.9.1 has a buffer overflow in PyCArg_repr in _ctypes/callproc.c, which may lead to remote code execution in certain Python applications that accept floating-point numbers as untrusted input, as demonstrated by a 1e300 argument to c_double.from_param. This occurs because sprintf is used unsafely.",9.8,CRITICAL,3,valid,2021-01-18T15:28:15Z,3
CVE-2021-3308,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,xen-project/xen,"x86/dpci: do not remove pirqs from domain tree on unbind

A fix for a previous issue removed the pirqs from the domain tree when
they are unbound in order to prevent shared pirqs from triggering a
BUG_ON in __pirq_guest_unbind if they are unbound multiple times. That
caused free_domain_pirqs to no longer unmap the pirqs because they
are gone from the domain pirq tree, thus leaving stale unbound pirqs
after domain destruction if the domain had mapped dpci pirqs after
shutdown.

Take a different approach to fix the original issue, instead of
removing the pirq from d->pirq_tree clear the flags of the dpci pirq
struct to signal that the pirq is now unbound. This prevents calling
pirq_guest_unbind multiple times for the same pirq without having to
remove it from the domain pirq tree.

This is XSA-360.

Fixes: 5b58dad089 ('x86/pass-through: avoid double IRQ unbind during domain cleanup')
Reported-by: Samuel Verschelde <samuel.verschelde@vates.fr>
Signed-off-by: Roger Pau Monn <roger.pau@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",58427889f5a420cc5226f88524b3228f90b72a58,https://github.com/xen-project/xen/commit/58427889f5a420cc5226f88524b3228f90b72a58,xen/drivers/passthrough/x86/hvm.c,pci_clean_dpci_irq,"static int pci_clean_dpci_irq(struct domain *d,
struct hvm_pirq_dpci *pirq_dpci, void *arg)
{
struct dev_intx_gsi_link *digl, *tmp;
pirq_guest_unbind(d, dpci_pirq(pirq_dpci));
if ( pt_irq_need_timer(pirq_dpci->flags) )
kill_timer(&pirq_dpci->timer);
list_for_each_entry_safe ( digl, tmp, &pirq_dpci->digl_list, list )
{
list_del(&digl->list);
xfree(digl);
}
radix_tree_delete(&d->pirq_tree, dpci_pirq(pirq_dpci)->pirq);
if ( !pt_pirq_softirq_active(pirq_dpci) )
return 0;
domain_get_irq_dpci(d)->pending_pirq_dpci = pirq_dpci;
return -ERESTART;
}","static int pci_clean_dpci_irq(struct domain *VAR_0,
struct hvm_pirq_dpci *VAR_1, void *VAR_2)
{
struct dev_intx_gsi_link *VAR_3, *VAR_4;
pirq_guest_unbind(VAR_0, dpci_pirq(VAR_1));
if ( pt_irq_need_timer(VAR_1->flags) )
kill_timer(&VAR_1->timer);
list_for_each_entry_safe ( VAR_3, VAR_4, &VAR_1->digl_list, VAR_5 )
{
list_del(&VAR_3->list);
xfree(VAR_3);
}
radix_tree_delete(&VAR_0->pirq_tree, dpci_pirq(VAR_1)->pirq);
if ( !pt_pirq_softirq_active(VAR_1) )
return 0;
domain_get_irq_dpci(VAR_0)->pending_pirq_dpci = VAR_1;
return -VAR_6;
}",xen-project/xen/58427889f5a420cc5226f88524b3228f90b72a58/hvm.c/vul/before/1.json,"static int pci_clean_dpci_irq(struct domain *d,
                              struct hvm_pirq_dpci *pirq_dpci, void *arg)
{
    struct dev_intx_gsi_link *digl, *tmp;

    if ( !pirq_dpci->flags )
        /* Already processed. */
        return 0;

    pirq_guest_unbind(d, dpci_pirq(pirq_dpci));

    if ( pt_irq_need_timer(pirq_dpci->flags) )
        kill_timer(&pirq_dpci->timer);

    list_for_each_entry_safe ( digl, tmp, &pirq_dpci->digl_list, list )
    {
        list_del(&digl->list);
        xfree(digl);
    }
    /* Note the pirq is now unbound. */
    pirq_dpci->flags = 0;

    return pt_pirq_softirq_active(pirq_dpci) ? -ERESTART : 0;
}","static int pci_clean_dpci_irq(struct domain *VAR_0,
                              struct hvm_pirq_dpci *VAR_1, void *VAR_2)
{
    struct dev_intx_gsi_link *VAR_3, *VAR_4;

    if ( !VAR_1->flags )
        /* COMMENT_0 */
        return 0;

    pirq_guest_unbind(VAR_0, dpci_pirq(VAR_1));

    if ( pt_irq_need_timer(VAR_1->flags) )
        kill_timer(&VAR_1->timer);

    list_for_each_entry_safe ( VAR_3, VAR_4, &VAR_1->digl_list, VAR_5 )
    {
        list_del(&VAR_3->list);
        xfree(VAR_3);
    }
    /* COMMENT_1 */
    VAR_1->flags = 0;

    return pt_pirq_softirq_active(VAR_1) ? -VAR_6 : 0;
}",xen-project/xen/58427889f5a420cc5226f88524b3228f90b72a58/hvm.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,6 +2,10 @@
                               struct hvm_pirq_dpci *pirq_dpci, void *arg)
 {
     struct dev_intx_gsi_link *digl, *tmp;
+
+    if ( !pirq_dpci->flags )
+        /* Already processed. */
+        return 0;
 
     pirq_guest_unbind(d, dpci_pirq(pirq_dpci));
 
@@ -13,13 +17,8 @@
         list_del(&digl->list);
         xfree(digl);
     }
+    /* Note the pirq is now unbound. */
+    pirq_dpci->flags = 0;
 
-    radix_tree_delete(&d->pirq_tree, dpci_pirq(pirq_dpci)->pirq);
-
-    if ( !pt_pirq_softirq_active(pirq_dpci) )
-        return 0;
-
-    domain_get_irq_dpci(d)->pending_pirq_dpci = pirq_dpci;
-
-    return -ERESTART;
+    return pt_pirq_softirq_active(pirq_dpci) ? -ERESTART : 0;
 }","{'deleted_lines': ['    radix_tree_delete(&d->pirq_tree, dpci_pirq(pirq_dpci)->pirq);', '', '    if ( !pt_pirq_softirq_active(pirq_dpci) )', '        return 0;', '', '    domain_get_irq_dpci(d)->pending_pirq_dpci = pirq_dpci;', '', '    return -ERESTART;'], 'added_lines': ['', '    if ( !pirq_dpci->flags )', '        /* Already processed. */', '        return 0;', '    /* Note the pirq is now unbound. */', '    pirq_dpci->flags = 0;', '    return pt_pirq_softirq_active(pirq_dpci) ? -ERESTART : 0;']}",True,"An issue was discovered in Xen 4.12.3 through 4.12.4 and 4.13.1 through 4.14.x. An x86 HVM guest with PCI pass through devices can force the allocation of all IDT vectors on the system by rebooting itself with MSI or MSI-X capabilities enabled and entries setup. Such reboots will leak any vectors used by the MSI(-X) entries that the guest might had enabled, and hence will lead to vector exhaustion on the system, not allowing further PCI pass through devices to work properly. HVM guests with PCI pass through devices can mount a Denial of Service (DoS) attack affecting the pass through of PCI devices to other guests or the hardware domain. In the latter case, this would affect the entire host.",5.5,MEDIUM,1,valid,2021-01-21T15:11:41Z,3
CVE-2021-3308,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,xen-project/xen,"x86/dpci: do not remove pirqs from domain tree on unbind

A fix for a previous issue removed the pirqs from the domain tree when
they are unbound in order to prevent shared pirqs from triggering a
BUG_ON in __pirq_guest_unbind if they are unbound multiple times. That
caused free_domain_pirqs to no longer unmap the pirqs because they
are gone from the domain pirq tree, thus leaving stale unbound pirqs
after domain destruction if the domain had mapped dpci pirqs after
shutdown.

Take a different approach to fix the original issue, instead of
removing the pirq from d->pirq_tree clear the flags of the dpci pirq
struct to signal that the pirq is now unbound. This prevents calling
pirq_guest_unbind multiple times for the same pirq without having to
remove it from the domain pirq tree.

This is XSA-360.

Fixes: 5b58dad089 ('x86/pass-through: avoid double IRQ unbind during domain cleanup')
Reported-by: Samuel Verschelde <samuel.verschelde@vates.fr>
Signed-off-by: Roger Pau Monn <roger.pau@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>",58427889f5a420cc5226f88524b3228f90b72a58,https://github.com/xen-project/xen/commit/58427889f5a420cc5226f88524b3228f90b72a58,xen/drivers/passthrough/x86/hvm.c,arch_pci_clean_pirqs,"int arch_pci_clean_pirqs(struct domain *d)
{
struct hvm_irq_dpci *hvm_irq_dpci = NULL;
if ( !is_iommu_enabled(d) )
return 0;
if ( !is_hvm_domain(d) )
return 0;
spin_lock(&d->event_lock);
hvm_irq_dpci = domain_get_irq_dpci(d);
if ( hvm_irq_dpci != NULL )
{
int ret = 0;
if ( hvm_irq_dpci->pending_pirq_dpci )
{
if ( pt_pirq_softirq_active(hvm_irq_dpci->pending_pirq_dpci) )
ret = -ERESTART;
else
hvm_irq_dpci->pending_pirq_dpci = NULL;
}
if ( !ret )
ret = pt_pirq_iterate(d, pci_clean_dpci_irq, NULL);
if ( ret )
{
spin_unlock(&d->event_lock);
return ret;
}
hvm_domain_irq(d)->dpci = NULL;
free_hvm_irq_dpci(hvm_irq_dpci);
}
spin_unlock(&d->event_lock);
return 0;
}","int arch_pci_clean_pirqs(struct domain *VAR_0)
{
struct hvm_irq_dpci *hvm_irq_dpci = NULL;
if ( !is_iommu_enabled(VAR_0) )
return 0;
if ( !is_hvm_domain(VAR_0) )
return 0;
spin_lock(&VAR_0->event_lock);
hvm_irq_dpci = domain_get_irq_dpci(VAR_0);
if ( hvm_irq_dpci != NULL )
{
int VAR_1 = 0;
if ( hvm_irq_dpci->pending_pirq_dpci )
{
if ( pt_pirq_softirq_active(hvm_irq_dpci->pending_pirq_dpci) )
VAR_1 = -VAR_2;
else
hvm_irq_dpci->pending_pirq_dpci = NULL;
}
if ( !VAR_1 )
VAR_1 = pt_pirq_iterate(VAR_0, VAR_3, NULL);
if ( VAR_1 )
{
spin_unlock(&VAR_0->event_lock);
return VAR_1;
}
hvm_domain_irq(VAR_0)->dpci = NULL;
free_hvm_irq_dpci(hvm_irq_dpci);
}
spin_unlock(&VAR_0->event_lock);
return 0;
}",xen-project/xen/58427889f5a420cc5226f88524b3228f90b72a58/hvm.c/vul/before/0.json,"int arch_pci_clean_pirqs(struct domain *d)
{
    struct hvm_irq_dpci *hvm_irq_dpci = NULL;

    if ( !is_iommu_enabled(d) )
        return 0;

    if ( !is_hvm_domain(d) )
        return 0;

    spin_lock(&d->event_lock);
    hvm_irq_dpci = domain_get_irq_dpci(d);
    if ( hvm_irq_dpci != NULL )
    {
        int ret = pt_pirq_iterate(d, pci_clean_dpci_irq, NULL);

        if ( ret )
        {
            spin_unlock(&d->event_lock);
            return ret;
        }

        hvm_domain_irq(d)->dpci = NULL;
        free_hvm_irq_dpci(hvm_irq_dpci);
    }
    spin_unlock(&d->event_lock);

    return 0;
}","int arch_pci_clean_pirqs(struct domain *VAR_0)
{
    struct hvm_irq_dpci *hvm_irq_dpci = NULL;

    if ( !is_iommu_enabled(VAR_0) )
        return 0;

    if ( !is_hvm_domain(VAR_0) )
        return 0;

    spin_lock(&VAR_0->event_lock);
    hvm_irq_dpci = domain_get_irq_dpci(VAR_0);
    if ( hvm_irq_dpci != NULL )
    {
        int VAR_1 = pt_pirq_iterate(VAR_0, VAR_2, NULL);

        if ( VAR_1 )
        {
            spin_unlock(&VAR_0->event_lock);
            return VAR_1;
        }

        hvm_domain_irq(VAR_0)->dpci = NULL;
        free_hvm_irq_dpci(hvm_irq_dpci);
    }
    spin_unlock(&VAR_0->event_lock);

    return 0;
}",xen-project/xen/58427889f5a420cc5226f88524b3228f90b72a58/hvm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,18 +12,8 @@
     hvm_irq_dpci = domain_get_irq_dpci(d);
     if ( hvm_irq_dpci != NULL )
     {
-        int ret = 0;
+        int ret = pt_pirq_iterate(d, pci_clean_dpci_irq, NULL);
 
-        if ( hvm_irq_dpci->pending_pirq_dpci )
-        {
-            if ( pt_pirq_softirq_active(hvm_irq_dpci->pending_pirq_dpci) )
-                 ret = -ERESTART;
-            else
-                 hvm_irq_dpci->pending_pirq_dpci = NULL;
-        }
-
-        if ( !ret )
-            ret = pt_pirq_iterate(d, pci_clean_dpci_irq, NULL);
         if ( ret )
         {
             spin_unlock(&d->event_lock);","{'deleted_lines': ['        int ret = 0;', '        if ( hvm_irq_dpci->pending_pirq_dpci )', '        {', '            if ( pt_pirq_softirq_active(hvm_irq_dpci->pending_pirq_dpci) )', '                 ret = -ERESTART;', '            else', '                 hvm_irq_dpci->pending_pirq_dpci = NULL;', '        }', '', '        if ( !ret )', '            ret = pt_pirq_iterate(d, pci_clean_dpci_irq, NULL);'], 'added_lines': ['        int ret = pt_pirq_iterate(d, pci_clean_dpci_irq, NULL);']}",True,"An issue was discovered in Xen 4.12.3 through 4.12.4 and 4.13.1 through 4.14.x. An x86 HVM guest with PCI pass through devices can force the allocation of all IDT vectors on the system by rebooting itself with MSI or MSI-X capabilities enabled and entries setup. Such reboots will leak any vectors used by the MSI(-X) entries that the guest might had enabled, and hence will lead to vector exhaustion on the system, not allowing further PCI pass through devices to work properly. HVM guests with PCI pass through devices can mount a Denial of Service (DoS) attack affecting the pass through of PCI devices to other guests or the hardware domain. In the latter case, this would affect the entire host.",5.5,MEDIUM,1,valid,2021-01-21T15:11:41Z,3
CVE-2021-26948,['CWE-476'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,michaelrsweet/htmldoc,"Fix crash bug with data: URIs (Issue #410)

Fix URL regression caused by Coverity changes (Issue #409)",008861d8339c6ec777e487770b70b95b1ed0c1d2,https://github.com/michaelrsweet/htmldoc/commit/008861d8339c6ec777e487770b70b95b1ed0c1d2,htmldoc/file.c,file_find,"const char *
file_find(const char *path,
const char *s)
{
inti;
char*temp;
const char*sptr;
intch;
charbasename[HTTP_MAX_URI];
const char*realname;
static charfilename[HTTP_MAX_URI];
if (s == NULL)
return (NULL);
DEBUG_printf((""file_find(path=\""%s\"", s=\""%s\"")\n"", path ? path : ""(null)"", s));
for (i = 0; i < (int)web_files; i ++)
if (strcmp(s, web_cache[i].name) == 0)
{
DEBUG_printf((""file_find: Returning cache file \""%s\""!\n"", s));
return (web_cache[i].name);
}
DEBUG_printf((""file_find: \""%s\"" not in web cache of %d files...\n"", s, (int)web_files));
if (strchr(s, '%') == NULL)
strlcpy(basename, s, sizeof(basename));
else
{
for (sptr = s, temp = basename;
*sptr && temp < (basename + sizeof(basename) - 1);)
if (*sptr == '%' && isxdigit(sptr[1]) && isxdigit(sptr[2]))
{
if (isalpha(sptr[1]))
ch = (tolower(sptr[1]) - 'a' + 10) << 4;
else
ch = (sptr[1] - '0') << 4;
if (isalpha(sptr[2]))
ch |= tolower(sptr[2]) - 'a' + 10;
else
ch |= sptr[2] - '0';
*temp++ = (char)ch;
sptr += 3;
}
else
*temp++ = *sptr++;
*temp = '\0';
}
if (path != NULL && !path[0])
{
DEBUG_puts(""file_find: Resetting path to NULL since path is empty..."");
path = NULL;
}
if (strncmp(s, ""http:"", 5) == 0 ||
strncmp(s, ""https:"", 6) == 0 ||
strncmp(s, ""  {
DEBUG_puts(""file_find: Resetting path to NULL since filename is a URL..."");
path = NULL;
}
if (path != NULL)
{
filename[sizeof(filename) - 1] = '\0';
while (*path != '\0')
{
temp = filename;
while (*path != ';' && *path && temp < (filename + sizeof(filename) - 1))
*temp++ = *path++;
if (*path == ';')
path ++;
if (temp > filename && temp < (filename + sizeof(filename) - 1) &&
basename[0] != '/')
*temp++ = '/';
strlcpy(temp, basename, sizeof(filename) - (size_t)(temp - filename));
if ((realname = file_find_check(filename)) != NULL)
return (realname);
}
}
if (file_find_check(s))
{
strlcpy(filename, s, sizeof(filename));
return (filename);
}
else
return (NULL);
}","const char *
file_find(const char *VAR_0,
const char *VAR_1)
{
intVAR_2;
char*VAR_3;
const char*VAR_4;
intVAR_5;
charVAR_6[VAR_7];
const char*VAR_8;
static charVAR_9[VAR_7];
if (VAR_1 == NULL)
return (NULL);
DEBUG_printf((""file_find(path=\""%s\"", s=\""%s\"")\n"", VAR_0 ? VAR_0 : ""(null)"", VAR_1));
for (VAR_2 = 0; VAR_2 < (int)VAR_10; VAR_2 ++)
if (strcmp(VAR_1, VAR_11[VAR_2].name) == 0)
{
DEBUG_printf((""file_find: Returning cache file \""%s\""!\n"", VAR_1));
return (VAR_11[VAR_2].name);
}
DEBUG_printf((""file_find: \""%s\"" not in web cache of %d files...\n"", VAR_1, (int)VAR_10));
if (strchr(VAR_1, '%') == NULL)
strlcpy(VAR_6, VAR_1, sizeof(VAR_6));
else
{
for (VAR_4 = VAR_1, VAR_3 = VAR_6;
*VAR_4 && VAR_3 < (VAR_6 + sizeof(VAR_6) - 1);)
if (*VAR_4 == '%' && isxdigit(VAR_4[1]) && isxdigit(VAR_4[2]))
{
if (isalpha(VAR_4[1]))
VAR_5 = (tolower(VAR_4[1]) - 'a' + 10) << 4;
else
VAR_5 = (VAR_4[1] - '0') << 4;
if (isalpha(VAR_4[2]))
VAR_5 |= tolower(VAR_4[2]) - 'a' + 10;
else
VAR_5 |= VAR_4[2] - '0';
*VAR_3++ = (char)VAR_5;
VAR_4 += 3;
}
else
*VAR_3++ = *VAR_4++;
*VAR_3 = '\0';
}
if (VAR_0 != NULL && !VAR_0[0])
{
DEBUG_puts(""file_find: Resetting path to NULL since path is empty..."");
VAR_0 = NULL;
}
if (strncmp(VAR_1, ""http:"", 5) == 0 ||
strncmp(VAR_1, ""https:"", 6) == 0 ||
strncmp(VAR_1, ""//"", 2) == 0)
{
DEBUG_puts(""file_find: Resetting path to NULL since filename is a URL..."");
VAR_0 = NULL;
}
if (VAR_0 != NULL)
{
VAR_9[sizeof(VAR_9) - 1] = '\0';
while (*VAR_0 != '\0')
{
VAR_3 = VAR_9;
while (*VAR_0 != ';' && *VAR_0 && VAR_3 < (VAR_9 + sizeof(VAR_9) - 1))
*VAR_3++ = *VAR_0++;
if (*VAR_0 == ';')
VAR_0 ++;
if (VAR_3 > VAR_9 && VAR_3 < (VAR_9 + sizeof(VAR_9) - 1) &&
VAR_6[0] != '/')
*VAR_3++ = '/';
strlcpy(VAR_3, VAR_6, sizeof(VAR_9) - (size_t)(VAR_3 - VAR_9));
if ((VAR_8 = file_find_check(VAR_9)) != NULL)
return (VAR_8);
}
}
if (file_find_check(VAR_1))
{
strlcpy(VAR_9, VAR_1, sizeof(VAR_9));
return (VAR_9);
}
else
return (NULL);
}",michaelrsweet/htmldoc/008861d8339c6ec777e487770b70b95b1ed0c1d2/file.c/vul/before/0.json,"const char *				/* O - Pathname or NULL */
file_find(const char *path,		/* I - Path ""dir;dir;dir"" */
          const char *s)		/* I - File to find */
{
  int		i;			/* Looping var */
  char		*temp;			/* Current position in filename */
  const char	*sptr;			/* Pointer into ""s"" */
  int		ch;			/* Quoted character */
  char		basename[HTTP_MAX_URI];	/* Base (unquoted) filename */
  const char	*realname;		/* Real filename */
  static char	filename[HTTP_MAX_URI];	/* Current filename */


 /*
  * If the filename is NULL, return NULL...
  */

  if (s == NULL)
    return (NULL);

  DEBUG_printf((""file_find(path=\""%s\"", s=\""%s\"")\n"", path ? path : ""(null)"", s));

 /*
  * See if this is a cached remote file...
  */

  for (i = 0; i < (int)web_files; i ++)
  {
    if (strcmp(s, web_cache[i].name) == 0)
    {
      DEBUG_printf((""file_find: Returning cache file \""%s\""!\n"", s));
      return (web_cache[i].name);
    }
  }

  DEBUG_printf((""file_find: \""%s\"" not in web cache of %d files...\n"", s, (int)web_files));

 /*
  * Make sure the filename is not quoted...
  */

  if (strchr(s, '%') == NULL)
  {
    strlcpy(basename, s, sizeof(basename));
  }
  else
  {
    for (sptr = s, temp = basename;
	 *sptr && temp < (basename + sizeof(basename) - 1);)
    {
      if (*sptr == '%' && isxdigit(sptr[1]) && isxdigit(sptr[2]))
      {
       /*
	* Dequote %HH...
	*/

	if (isalpha(sptr[1]))
	  ch = (tolower(sptr[1]) - 'a' + 10) << 4;
	else
	  ch = (sptr[1] - '0') << 4;

	if (isalpha(sptr[2]))
	  ch |= tolower(sptr[2]) - 'a' + 10;
	else
	  ch |= sptr[2] - '0';

	*temp++ = (char)ch;

	sptr += 3;
      }
      else
	*temp++ = *sptr++;
    }

    *temp = '\0';
  }

 /*
  * If we got a complete URL, we don't use the path...
  */

  if (path != NULL && !path[0])
  {
    DEBUG_puts(""file_find: Resetting path to NULL since path is empty..."");
    path = NULL;
  }

  if (strncmp(s, ""http:"", 5) == 0 ||
      strncmp(s, ""https:"", 6) == 0 ||
      strncmp(s, ""//"", 2) == 0)
  {
    DEBUG_puts(""file_find: Resetting path to NULL since filename is a URL..."");
    path = NULL;
  }

 /*
  * Loop through the path as needed...
  */

  if (path != NULL)
  {
    filename[sizeof(filename) - 1] = '\0';

    while (*path != '\0')
    {
     /*
      * Copy the path directory...
      */

      temp = filename;

      while (*path != ';' && *path && temp < (filename + sizeof(filename) - 1))
	*temp++ = *path++;

      if (*path == ';')
	path ++;

     /*
      * Append a slash as needed, then the filename...
      */

      if (temp > filename && temp < (filename + sizeof(filename) - 1) &&
          basename[0] != '/')
	*temp++ = '/';

      strlcpy(temp, basename, sizeof(filename) - (size_t)(temp - filename));

     /*
      * See if the file or URL exists...
      */

      if ((realname = file_find_check(filename)) != NULL)
	return (realname);
    }
  }

  return (file_find_check(s));
}","const char *				/* COMMENT_0 */
file_find(const char *VAR_0,		/* COMMENT_1 */
          const char *VAR_1)		/* COMMENT_2 */
{
  int		VAR_2;			/* COMMENT_3 */
  char		*VAR_3;			/* COMMENT_4 */
  const char	*VAR_4;			/* COMMENT_5 */
  int		VAR_5;			/* COMMENT_6 */
  char		VAR_6[VAR_7];	/* COMMENT_7 */
  const char	*VAR_8;		/* COMMENT_8 */
  static char	VAR_9[VAR_7];	/* COMMENT_9 */


 /* COMMENT_10 */
                                           
    

  if (VAR_1 == NULL)
    return (NULL);

  DEBUG_printf((""file_find(path=\""%s\"", s=\""%s\"")\n"", VAR_0 ? VAR_0 : ""(null)"", VAR_1));

 /* COMMENT_13 */
                                          
    

  for (VAR_2 = 0; VAR_2 < (int)VAR_10; VAR_2 ++)
  {
    if (strcmp(VAR_1, VAR_11[VAR_2].name) == 0)
    {
      DEBUG_printf((""file_find: Returning cache file \""%s\""!\n"", VAR_1));
      return (VAR_11[VAR_2].name);
    }
  }

  DEBUG_printf((""file_find: \""%s\"" not in web cache of %d files...\n"", VAR_1, (int)VAR_10));

 /* COMMENT_16 */
                                           
    

  if (strchr(VAR_1, '%') == NULL)
  {
    strlcpy(VAR_6, VAR_1, sizeof(VAR_6));
  }
  else
  {
    for (VAR_4 = VAR_1, VAR_3 = VAR_6;
	 *VAR_4 && VAR_3 < (VAR_6 + sizeof(VAR_6) - 1);)
    {
      if (*VAR_4 == '%' && isxdigit(VAR_4[1]) && isxdigit(VAR_4[2]))
      {
       /* COMMENT_19 */
                 
   

	if (isalpha(VAR_4[1]))
	  VAR_5 = (tolower(VAR_4[1]) - 'a' + 10) << 4;
	else
	  VAR_5 = (VAR_4[1] - '0') << 4;

	if (isalpha(VAR_4[2]))
	  VAR_5 |= tolower(VAR_4[2]) - 'a' + 10;
	else
	  VAR_5 |= VAR_4[2] - '0';

	*VAR_3++ = (char)VAR_5;

	VAR_4 += 3;
      }
      else
	*VAR_3++ = *VAR_4++;
    }

    *VAR_3 = '\0';
  }

 /* COMMENT_22 */
                                                      
    

  if (VAR_0 != NULL && !VAR_0[0])
  {
    DEBUG_puts(""file_find: Resetting path to NULL since path is empty..."");
    VAR_0 = NULL;
  }

  if (strncmp(VAR_1, ""http:"", 5) == 0 ||
      strncmp(VAR_1, ""https:"", 6) == 0 ||
      strncmp(VAR_1, ""//"", 2) == 0)
  {
    DEBUG_puts(""file_find: Resetting path to NULL since filename is a URL..."");
    VAR_0 = NULL;
  }

 /* COMMENT_25 */
                                      
    

  if (VAR_0 != NULL)
  {
    VAR_9[sizeof(VAR_9) - 1] = '\0';

    while (*VAR_0 != '\0')
    {
     /* COMMENT_28 */
                                  
        

      VAR_3 = VAR_9;

      while (*VAR_0 != ';' && *VAR_0 && VAR_3 < (VAR_9 + sizeof(VAR_9) - 1))
	*VAR_3++ = *VAR_0++;

      if (*VAR_0 == ';')
	VAR_0 ++;

     /* COMMENT_31 */
                                                      
        

      if (VAR_3 > VAR_9 && VAR_3 < (VAR_9 + sizeof(VAR_9) - 1) &&
          VAR_6[0] != '/')
	*VAR_3++ = '/';

      strlcpy(VAR_3, VAR_6, sizeof(VAR_9) - (size_t)(VAR_3 - VAR_9));

     /* COMMENT_34 */
                                        
        

      if ((VAR_8 = file_find_check(VAR_9)) != NULL)
	return (VAR_8);
    }
  }

  return (file_find_check(VAR_1));
}",michaelrsweet/htmldoc/008861d8339c6ec777e487770b70b95b1ed0c1d2/file.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -25,11 +25,13 @@
   */
 
   for (i = 0; i < (int)web_files; i ++)
+  {
     if (strcmp(s, web_cache[i].name) == 0)
     {
       DEBUG_printf((""file_find: Returning cache file \""%s\""!\n"", s));
       return (web_cache[i].name);
     }
+  }
 
   DEBUG_printf((""file_find: \""%s\"" not in web cache of %d files...\n"", s, (int)web_files));
 
@@ -38,11 +40,14 @@
   */
 
   if (strchr(s, '%') == NULL)
+  {
     strlcpy(basename, s, sizeof(basename));
+  }
   else
   {
     for (sptr = s, temp = basename;
 	 *sptr && temp < (basename + sizeof(basename) - 1);)
+    {
       if (*sptr == '%' && isxdigit(sptr[1]) && isxdigit(sptr[2]))
       {
        /*
@@ -65,6 +70,7 @@
       }
       else
 	*temp++ = *sptr++;
+    }
 
     *temp = '\0';
   }
@@ -128,11 +134,5 @@
     }
   }
 
-  if (file_find_check(s))
-  {
-    strlcpy(filename, s, sizeof(filename));
-    return (filename);
-  }
-  else
-    return (NULL);
+  return (file_find_check(s));
 }","{'deleted_lines': ['  if (file_find_check(s))', '  {', '    strlcpy(filename, s, sizeof(filename));', '    return (filename);', '  }', '  else', '    return (NULL);'], 'added_lines': ['  {', '  }', '  {', '  }', '    {', '    }', '  return (file_find_check(s));']}",True,Null pointer dereference in the htmldoc v1.9.11 and before may allow attackers to execute arbitrary code and cause a denial of service via a crafted html file.,7.8,HIGH,2,valid,2021-01-23T23:37:10Z,3
CVE-2021-26948,['CWE-476'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,michaelrsweet/htmldoc,"Fix crash bug with data: URIs (Issue #410)

Fix URL regression caused by Coverity changes (Issue #409)",008861d8339c6ec777e487770b70b95b1ed0c1d2,https://github.com/michaelrsweet/htmldoc/commit/008861d8339c6ec777e487770b70b95b1ed0c1d2,htmldoc/file.c,file_method,"const char *
file_method(const char *s)
{
if (strncmp(s, ""http:"", 5) == 0)
return (""http"");
else if (strncmp(s, ""https:"", 6) == 0)
return (""https"");
else if (strncmp(s, ""ftp:"", 4) == 0)
return (""ftp"");
else if (strncmp(s, ""mailto:"", 7) == 0)
return (""mailto"");
else
return (NULL);
}","const char *
file_method(const char *VAR_0)
{
if (strncmp(VAR_0, ""http:"", 5) == 0)
return (""http"");
else if (strncmp(VAR_0, ""https:"", 6) == 0)
return (""https"");
else if (strncmp(VAR_0, ""ftp:"", 4) == 0)
return (""ftp"");
else if (strncmp(VAR_0, ""mailto:"", 7) == 0)
return (""mailto"");
else
return (NULL);
}",michaelrsweet/htmldoc/008861d8339c6ec777e487770b70b95b1ed0c1d2/file.c/vul/before/1.json,"const char *			/* O - Method string (""http"", ""ftp"", etc.) */
file_method(const char *s)	/* I - Filename or URL */
{
  if (strncmp(s, ""data:"", 5) == 0)
    return (""data"");
  else if (strncmp(s, ""http:"", 5) == 0)
    return (""http"");
  else if (strncmp(s, ""https:"", 6) == 0)
    return (""https"");
  else if (strncmp(s, ""ftp:"", 4) == 0)
    return (""ftp"");
  else if (strncmp(s, ""mailto:"", 7) == 0)
    return (""mailto"");
  else
    return (NULL);
}","const char *			/* COMMENT_0 */
file_method(const char *VAR_0)	/* COMMENT_1 */
{
  if (strncmp(VAR_0, ""data:"", 5) == 0)
    return (""data"");
  else if (strncmp(VAR_0, ""http:"", 5) == 0)
    return (""http"");
  else if (strncmp(VAR_0, ""https:"", 6) == 0)
    return (""https"");
  else if (strncmp(VAR_0, ""ftp:"", 4) == 0)
    return (""ftp"");
  else if (strncmp(VAR_0, ""mailto:"", 7) == 0)
    return (""mailto"");
  else
    return (NULL);
}",michaelrsweet/htmldoc/008861d8339c6ec777e487770b70b95b1ed0c1d2/file.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,7 +1,9 @@
 const char *			/* O - Method string (""http"", ""ftp"", etc.) */
 file_method(const char *s)	/* I - Filename or URL */
 {
-  if (strncmp(s, ""http:"", 5) == 0)
+  if (strncmp(s, ""data:"", 5) == 0)
+    return (""data"");
+  else if (strncmp(s, ""http:"", 5) == 0)
     return (""http"");
   else if (strncmp(s, ""https:"", 6) == 0)
     return (""https"");","{'deleted_lines': ['  if (strncmp(s, ""http:"", 5) == 0)'], 'added_lines': ['  if (strncmp(s, ""data:"", 5) == 0)', '    return (""data"");', '  else if (strncmp(s, ""http:"", 5) == 0)']}",True,Null pointer dereference in the htmldoc v1.9.11 and before may allow attackers to execute arbitrary code and cause a denial of service via a crafted html file.,7.8,HIGH,2,valid,2021-01-23T23:37:10Z,3
CVE-2021-26805,['CWE-120'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,justdan96/tsMuxer,Fix an invalid delete error,ce0a0972aad04bedd779de38b78f13b2f740178d,https://github.com/justdan96/tsMuxer/commit/ce0a0972aad04bedd779de38b78f13b2f740178d,tsMuxer/vc1Parser.h,vc1_unescape_buffer,"inline int vc1_unescape_buffer(uint8_t* src, int size)
{
if (m_nalBuffer != 0)
delete m_nalBuffer;
m_nalBuffer = new uint8_t[size];
int dsize = 0, i;
if (size < 4)
{
for (dsize = 0; dsize < size; dsize++) *m_nalBuffer++ = *src++;
m_nalBufferLen = size;
return size;
}
for (i = 0; i < size; i++, src++)
{
if (src[0] == 3 && i >= 2 && !src[-1] && !src[-2] && i < size - 1 && src[1] < 4)
{
m_nalBuffer[dsize++] = src[1];
src++;
i++;
}
else
m_nalBuffer[dsize++] = *src;
}
m_nalBufferLen = dsize;
return dsize;
}","inline int vc1_unescape_buffer(uint8_t* VAR_0, int VAR_1)
{
if (VAR_2 != 0)
delete VAR_2;
VAR_2 = new uint8_t[VAR_1];
int VAR_3 = 0, VAR_4;
if (VAR_1 < 4)
{
for (VAR_3 = 0; VAR_3 < VAR_1; VAR_3++) *VAR_2++ = *VAR_0++;
VAR_5 = VAR_1;
return VAR_1;
}
for (VAR_4 = 0; VAR_4 < VAR_1; VAR_4++, VAR_0++)
{
if (VAR_0[0] == 3 && VAR_4 >= 2 && !VAR_0[-1] && !VAR_0[-2] && VAR_4 < VAR_1 - 1 && VAR_0[1] < 4)
{
VAR_2[VAR_3++] = VAR_0[1];
VAR_0++;
VAR_4++;
}
else
VAR_2[VAR_3++] = *VAR_0;
}
VAR_5 = VAR_3;
return VAR_3;
}",justdan96/tsMuxer/ce0a0972aad04bedd779de38b78f13b2f740178d/vc1Parser.h/vul/before/1.json,"inline int vc1_unescape_buffer(uint8_t* src, int size)
    {
        if (m_nalBuffer != 0)
            delete m_nalBuffer;
        m_nalBuffer = new uint8_t[size];
        int dsize = 0, i;
        if (size < 4)
        {
            std::copy(src, src + size, m_nalBuffer);
            m_nalBufferLen = size;
            return size;
        }
        for (i = 0; i < size; i++, src++)
        {
            if (src[0] == 3 && i >= 2 && !src[-1] && !src[-2] && i < size - 1 && src[1] < 4)
            {
                m_nalBuffer[dsize++] = src[1];
                src++;
                i++;
            }
            else
                m_nalBuffer[dsize++] = *src;
        }
        m_nalBufferLen = dsize;
        return dsize;
    }","inline int vc1_unescape_buffer(uint8_t* VAR_0, int VAR_1)
    {
        if (VAR_2 != 0)
            delete VAR_2;
        VAR_2 = new uint8_t[VAR_1];
        int VAR_3 = 0, VAR_4;
        if (VAR_1 < 4)
        {
            std::copy(VAR_0, VAR_0 + VAR_1, VAR_2);
            VAR_5 = VAR_1;
            return VAR_1;
        }
        for (VAR_4 = 0; VAR_4 < VAR_1; VAR_4++, VAR_0++)
        {
            if (VAR_0[0] == 3 && VAR_4 >= 2 && !VAR_0[-1] && !VAR_0[-2] && VAR_4 < VAR_1 - 1 && VAR_0[1] < 4)
            {
                VAR_2[VAR_3++] = VAR_0[1];
                VAR_0++;
                VAR_4++;
            }
            else
                VAR_2[VAR_3++] = *VAR_0;
        }
        VAR_5 = VAR_3;
        return VAR_3;
    }",justdan96/tsMuxer/ce0a0972aad04bedd779de38b78f13b2f740178d/vc1Parser.h/vul/after/1.json,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
         int dsize = 0, i;
         if (size < 4)
         {
-            for (dsize = 0; dsize < size; dsize++) *m_nalBuffer++ = *src++;
+            std::copy(src, src + size, m_nalBuffer);
             m_nalBufferLen = size;
             return size;
         }","{'deleted_lines': ['            for (dsize = 0; dsize < size; dsize++) *m_nalBuffer++ = *src++;'], 'added_lines': ['            std::copy(src, src + size, m_nalBuffer);']}",True,Buffer Overflow in tsMuxer 2.6.16 allows attackers to cause a Denial of Service (DoS) by running the application with a malicious WAV file.,5.5,MEDIUM,1,valid,2021-02-03T19:20:09Z,3
CVE-2021-26805,['CWE-120'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,justdan96/tsMuxer,Fix an invalid delete error,ce0a0972aad04bedd779de38b78f13b2f740178d,https://github.com/justdan96/tsMuxer/commit/ce0a0972aad04bedd779de38b78f13b2f740178d,tsMuxer/vc1Parser.h,~VC1Unit,~VC1Unit() { delete m_nalBuffer; },~VAR_0() { delete VAR_1; },,~VC1Unit() { delete[] m_nalBuffer; },~VAR_0() { delete[] VAR_1; },,"--- func_before
+++ func_after
@@ -1 +1 @@
-~VC1Unit() { delete m_nalBuffer; }
+~VC1Unit() { delete[] m_nalBuffer; }","{'deleted_lines': ['~VC1Unit() { delete m_nalBuffer; }'], 'added_lines': ['~VC1Unit() { delete[] m_nalBuffer; }']}",True,Buffer Overflow in tsMuxer 2.6.16 allows attackers to cause a Denial of Service (DoS) by running the application with a malicious WAV file.,5.5,MEDIUM,1,valid,2021-02-03T19:20:09Z,3
CVE-2021-29539,['CWE-681'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,tensorflow,"Allowlist certain data types to avoid a seg fault.

PiperOrigin-RevId: 356326671
Change-Id: I23b65b52e93798cb5a6744632d31b0f88c6b6b31",4f663d4b8f0bec1b48da6fa091a7d29609980fa4,https://github.com/tensorflow/tensorflow/commit/4f663d4b8f0bec1b48da6fa091a7d29609980fa4,tensorflow/core/kernels/immutable_constant_op.cc,ImmutableConstantOp::ImmutableConstantOp,"ImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* context)
: OpKernel(context) {
OP_REQUIRES_OK(context,
context->GetAttr(kMemoryRegionNameAttr, &region_name_));
OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_));
OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_));
}","ImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* VAR_0)
: OpKernel(VAR_0) {
OP_REQUIRES_OK(VAR_0,
VAR_0->GetAttr(VAR_1, &VAR_2));
OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(VAR_3, &VAR_4));
OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(VAR_5, &VAR_6));
}",tensorflow/4f663d4b8f0bec1b48da6fa091a7d29609980fa4/immutable_constant_op.cc/vul/before/0.json,"ImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* context)
    : OpKernel(context) {
  OP_REQUIRES_OK(context,
                 context->GetAttr(kMemoryRegionNameAttr, &region_name_));
  OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_));
  OP_REQUIRES(context, dtype_ != DT_RESOURCE && dtype_ != DT_VARIANT,
              errors::InvalidArgument(
                  ""Resource and variant dtypes are invalid for this op.""));
  OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_));
}","ImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* VAR_0)
    : OpKernel(VAR_0) {
  OP_REQUIRES_OK(VAR_0,
                 VAR_0->GetAttr(VAR_1, &VAR_2));
  OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(VAR_3, &VAR_4));
  OP_REQUIRES(VAR_0, VAR_4 != VAR_5 && VAR_4 != VAR_6,
              errors::InvalidArgument(
                  ""Resource and variant dtypes are invalid for this op.""));
  OP_REQUIRES_OK(VAR_0, VAR_0->GetAttr(VAR_7, &VAR_8));
}",tensorflow/4f663d4b8f0bec1b48da6fa091a7d29609980fa4/immutable_constant_op.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,5 +3,8 @@
   OP_REQUIRES_OK(context,
                  context->GetAttr(kMemoryRegionNameAttr, &region_name_));
   OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_));
+  OP_REQUIRES(context, dtype_ != DT_RESOURCE && dtype_ != DT_VARIANT,
+              errors::InvalidArgument(
+                  ""Resource and variant dtypes are invalid for this op.""));
   OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_));
 }","{'deleted_lines': [], 'added_lines': ['  OP_REQUIRES(context, dtype_ != DT_RESOURCE && dtype_ != DT_VARIANT,', '              errors::InvalidArgument(', '                  ""Resource and variant dtypes are invalid for this op.""));']}",True,"TensorFlow is an end-to-end open source platform for machine learning. Calling `tf.raw_ops.ImmutableConst`(https://www.tensorflow.org/api_docs/python/tf/raw_ops/ImmutableConst) with a `dtype` of `tf.resource` or `tf.variant` results in a segfault in the implementation as code assumes that the tensor contents are pure scalars. We have patched the issue in 4f663d4b8f0bec1b48da6fa091a7d29609980fa4 and will release TensorFlow 2.5.0 containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved. If using `tf.raw_ops.ImmutableConst` in code, you can prevent the segfault by inserting a filter for the `dtype` argument.",2.5,LOW,0,valid,2021-02-08T20:29:30Z,3
CVE-2021-27097,['CWE-Other'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,u-boot,"fdt_region: Check for a single root node of the correct name

At present fdt_find_regions() assumes that the FIT is a valid devicetree.
If the FIT has two root nodes this is currently not detected in this
function, nor does libfdt's fdt_check_full() notice. Also it is possible
for the root node to have a name even though it should not.

Add checks for these and return -FDT_ERR_BADSTRUCTURE if a problem is
detected.

CVE-2021-27097

Signed-off-by: Simon Glass <sjg@chromium.org>
Reported-by: Bruce Monroe <bruce.monroe@intel.com>
Reported-by: Arie Haenel <arie.haenel@intel.com>
Reported-by: Julien Lenoir <julien.lenoir@intel.com>",8a7d4cf9820ea16fabd25a6379351b4dc291204b,https://github.com/u-boot/u-boot/commit/8a7d4cf9820ea16fabd25a6379351b4dc291204b,common/fdt_region.c,fdt_find_regions,"int fdt_find_regions(const void *fdt, char * const inc[], int inc_count,
char * const exc_prop[], int exc_prop_count,
struct fdt_region region[], int max_regions,
char *path, int path_len, int add_string_tab)
{
int stack[FDT_MAX_DEPTH] = { 0 };
char *end;
int nextoffset = 0;
uint32_t tag;
int count = 0;
int start = -1;
int depth = -1;
int want = 0;
int base = fdt_off_dt_struct(fdt);
end = path;
*end = '\0';
do {
const struct fdt_property *prop;
const char *name;
const char *str;
int include = 0;
int stop_at = 0;
int offset;
int len;
offset = nextoffset;
tag = fdt_next_tag(fdt, offset, &nextoffset);
stop_at = nextoffset;
switch (tag) {
case FDT_PROP:
include = want >= 2;
stop_at = offset;
prop = fdt_get_property_by_offset(fdt, offset, NULL);
str = fdt_string(fdt, fdt32_to_cpu(prop->nameoff));
if (!str)
return -FDT_ERR_BADSTRUCTURE;
if (str_in_list(str, exc_prop, exc_prop_count))
include = 0;
break;
case FDT_NOP:
include = want >= 2;
stop_at = offset;
break;
case FDT_BEGIN_NODE:
depth++;
if (depth == FDT_MAX_DEPTH)
return -FDT_ERR_BADSTRUCTURE;
name = fdt_get_name(fdt, offset, &len);
if (end - path + 2 + len >= path_len)
return -FDT_ERR_NOSPACE;
if (end != path + 1)
*end++ = '/';
strcpy(end, name);
end += len;
stack[depth] = want;
if (want == 1)
stop_at = offset;
if (str_in_list(path, inc, inc_count))
want = 2;
else if (want)
want--;
else
stop_at = offset;
include = want;
break;
case FDT_END_NODE:
if (depth < 0)
return -FDT_ERR_BADSTRUCTURE;
include = want;
want = stack[depth--];
while (end > path && *--end != '/')
;
*end = '\0';
break;
case FDT_END:
include = 1;
break;
}
if (include && start == -1) {
if (count && count <= max_regions &&
offset == region[count - 1].offset +
region[count - 1].size - base)
start = region[--count].offset - base;
else
start = offset;
}
if (!include && start != -1) {
if (count < max_regions) {
region[count].offset = base + start;
region[count].size = stop_at - start;
}
count++;
start = -1;
}
} while (tag != FDT_END);
if (nextoffset != fdt_size_dt_struct(fdt))
return -FDT_ERR_BADLAYOUT;
if (count < max_regions) {
region[count].offset = base + start;
region[count].size = nextoffset - start;
if (add_string_tab)
region[count].size += fdt_size_dt_strings(fdt);
}
count++;
return count;
}","int fdt_find_regions(const void *VAR_0, char * const VAR_1[], int VAR_2,
char * const VAR_3[], int VAR_4,
struct fdt_region VAR_5[], int VAR_6,
char *VAR_7, int VAR_8, int VAR_9)
{
int VAR_10[VAR_11] = { 0 };
char *VAR_12;
int VAR_13 = 0;
uint32_t VAR_14;
int VAR_15 = 0;
int VAR_16 = -1;
int VAR_17 = -1;
int VAR_18 = 0;
int VAR_19 = fdt_off_dt_struct(VAR_0);
VAR_12 = VAR_7;
*VAR_12 = '\0';
do {
const struct fdt_property *VAR_20;
const char *VAR_21;
const char *VAR_22;
int VAR_23 = 0;
int VAR_24 = 0;
int VAR_25;
int VAR_26;
VAR_25 = VAR_13;
VAR_14 = fdt_next_tag(VAR_0, VAR_25, &VAR_13);
VAR_24 = VAR_13;
switch (VAR_14) {
case VAR_27:
VAR_23 = VAR_18 >= 2;
VAR_24 = VAR_25;
VAR_20 = fdt_get_property_by_offset(VAR_0, VAR_25, NULL);
VAR_22 = fdt_string(VAR_0, fdt32_to_cpu(VAR_20->nameoff));
if (!VAR_22)
return -VAR_28;
if (str_in_list(VAR_22, VAR_3, VAR_4))
VAR_23 = 0;
break;
case VAR_29:
VAR_23 = VAR_18 >= 2;
VAR_24 = VAR_25;
break;
case VAR_30:
VAR_17++;
if (VAR_17 == VAR_11)
return -VAR_28;
VAR_21 = fdt_get_name(VAR_0, VAR_25, &VAR_26);
if (VAR_12 - VAR_7 + 2 + VAR_26 >= VAR_8)
return -VAR_31;
if (VAR_12 != VAR_7 + 1)
*VAR_12++ = '/';
strcpy(VAR_12, VAR_21);
VAR_12 += VAR_26;
VAR_10[VAR_17] = VAR_18;
if (VAR_18 == 1)
VAR_24 = VAR_25;
if (str_in_list(VAR_7, VAR_1, VAR_2))
VAR_18 = 2;
else if (VAR_18)
VAR_18--;
else
VAR_24 = VAR_25;
VAR_23 = VAR_18;
break;
case VAR_32:
if (VAR_17 < 0)
return -VAR_28;
VAR_23 = VAR_18;
VAR_18 = VAR_10[VAR_17--];
while (VAR_12 > VAR_7 && *--VAR_12 != '/')
;
*VAR_12 = '\0';
break;
case VAR_33:
VAR_23 = 1;
break;
}
if (VAR_23 && VAR_16 == -1) {
if (VAR_15 && VAR_15 <= VAR_6 &&
VAR_25 == VAR_5[VAR_15 - 1].offset +
VAR_5[VAR_15 - 1].size - VAR_19)
VAR_16 = VAR_5[--VAR_15].offset - VAR_19;
else
VAR_16 = VAR_25;
}
if (!VAR_23 && VAR_16 != -1) {
if (VAR_15 < VAR_6) {
VAR_5[VAR_15].offset = VAR_19 + VAR_16;
VAR_5[VAR_15].size = VAR_24 - VAR_16;
}
VAR_15++;
VAR_16 = -1;
}
} while (VAR_14 != VAR_33);
if (VAR_13 != fdt_size_dt_struct(VAR_0))
return -VAR_34;
if (VAR_15 < VAR_6) {
VAR_5[VAR_15].offset = VAR_19 + VAR_16;
VAR_5[VAR_15].size = VAR_13 - VAR_16;
if (VAR_9)
VAR_5[VAR_15].size += fdt_size_dt_strings(VAR_0);
}
VAR_15++;
return VAR_15;
}",u-boot/8a7d4cf9820ea16fabd25a6379351b4dc291204b/fdt_region.c/vul/before/0.json,"int fdt_find_regions(const void *fdt, char * const inc[], int inc_count,
		     char * const exc_prop[], int exc_prop_count,
		     struct fdt_region region[], int max_regions,
		     char *path, int path_len, int add_string_tab)
{
	int stack[FDT_MAX_DEPTH] = { 0 };
	char *end;
	int nextoffset = 0;
	uint32_t tag;
	int count = 0;
	int start = -1;
	int depth = -1;
	int want = 0;
	int base = fdt_off_dt_struct(fdt);
	bool expect_end = false;

	end = path;
	*end = '\0';
	do {
		const struct fdt_property *prop;
		const char *name;
		const char *str;
		int include = 0;
		int stop_at = 0;
		int offset;
		int len;

		offset = nextoffset;
		tag = fdt_next_tag(fdt, offset, &nextoffset);
		stop_at = nextoffset;

		/* If we see two root nodes, something is wrong */
		if (expect_end && tag != FDT_END)
			return -FDT_ERR_BADLAYOUT;

		switch (tag) {
		case FDT_PROP:
			include = want >= 2;
			stop_at = offset;
			prop = fdt_get_property_by_offset(fdt, offset, NULL);
			str = fdt_string(fdt, fdt32_to_cpu(prop->nameoff));
			if (!str)
				return -FDT_ERR_BADSTRUCTURE;
			if (str_in_list(str, exc_prop, exc_prop_count))
				include = 0;
			break;

		case FDT_NOP:
			include = want >= 2;
			stop_at = offset;
			break;

		case FDT_BEGIN_NODE:
			depth++;
			if (depth == FDT_MAX_DEPTH)
				return -FDT_ERR_BADSTRUCTURE;
			name = fdt_get_name(fdt, offset, &len);

			/* The root node must have an empty name */
			if (!depth && *name)
				return -FDT_ERR_BADLAYOUT;
			if (end - path + 2 + len >= path_len)
				return -FDT_ERR_NOSPACE;
			if (end != path + 1)
				*end++ = '/';
			strcpy(end, name);
			end += len;
			stack[depth] = want;
			if (want == 1)
				stop_at = offset;
			if (str_in_list(path, inc, inc_count))
				want = 2;
			else if (want)
				want--;
			else
				stop_at = offset;
			include = want;
			break;

		case FDT_END_NODE:
			/* Depth must never go below -1 */
			if (depth < 0)
				return -FDT_ERR_BADSTRUCTURE;
			include = want;
			want = stack[depth--];
			while (end > path && *--end != '/')
				;
			*end = '\0';
			if (depth == -1)
				expect_end = true;
			break;

		case FDT_END:
			include = 1;
			break;
		}

		if (include && start == -1) {
			/* Should we merge with previous? */
			if (count && count <= max_regions &&
			    offset == region[count - 1].offset +
					region[count - 1].size - base)
				start = region[--count].offset - base;
			else
				start = offset;
		}

		if (!include && start != -1) {
			if (count < max_regions) {
				region[count].offset = base + start;
				region[count].size = stop_at - start;
			}
			count++;
			start = -1;
		}
	} while (tag != FDT_END);

	if (nextoffset != fdt_size_dt_struct(fdt))
		return -FDT_ERR_BADLAYOUT;

	/* Add a region for the END tag and the string table */
	if (count < max_regions) {
		region[count].offset = base + start;
		region[count].size = nextoffset - start;
		if (add_string_tab)
			region[count].size += fdt_size_dt_strings(fdt);
	}
	count++;

	return count;
}","int fdt_find_regions(const void *VAR_0, char * const VAR_1[], int VAR_2,
		     char * const VAR_3[], int VAR_4,
		     struct fdt_region VAR_5[], int VAR_6,
		     char *VAR_7, int VAR_8, int VAR_9)
{
	int VAR_10[VAR_11] = { 0 };
	char *VAR_12;
	int VAR_13 = 0;
	uint32_t VAR_14;
	int VAR_15 = 0;
	int VAR_16 = -1;
	int VAR_17 = -1;
	int VAR_18 = 0;
	int VAR_19 = fdt_off_dt_struct(VAR_0);
	bool VAR_20 = false;

	VAR_12 = VAR_7;
	*VAR_12 = '\0';
	do {
		const struct fdt_property *VAR_21;
		const char *VAR_22;
		const char *VAR_23;
		int VAR_24 = 0;
		int VAR_25 = 0;
		int VAR_26;
		int VAR_27;

		VAR_26 = VAR_13;
		VAR_14 = fdt_next_tag(VAR_0, VAR_26, &VAR_13);
		VAR_25 = VAR_13;

		/* COMMENT_0 */
		if (VAR_20 && VAR_14 != VAR_28)
			return -VAR_29;

		switch (VAR_14) {
		case VAR_30:
			VAR_24 = VAR_18 >= 2;
			VAR_25 = VAR_26;
			VAR_21 = fdt_get_property_by_offset(VAR_0, VAR_26, NULL);
			VAR_23 = fdt_string(VAR_0, fdt32_to_cpu(VAR_21->nameoff));
			if (!VAR_23)
				return -VAR_31;
			if (str_in_list(VAR_23, VAR_3, VAR_4))
				VAR_24 = 0;
			break;

		case VAR_32:
			VAR_24 = VAR_18 >= 2;
			VAR_25 = VAR_26;
			break;

		case VAR_33:
			VAR_17++;
			if (VAR_17 == VAR_11)
				return -VAR_31;
			VAR_22 = fdt_get_name(VAR_0, VAR_26, &VAR_27);

			/* COMMENT_1 */
			if (!VAR_17 && *VAR_22)
				return -VAR_29;
			if (VAR_12 - VAR_7 + 2 + VAR_27 >= VAR_8)
				return -VAR_34;
			if (VAR_12 != VAR_7 + 1)
				*VAR_12++ = '/';
			strcpy(VAR_12, VAR_22);
			VAR_12 += VAR_27;
			VAR_10[VAR_17] = VAR_18;
			if (VAR_18 == 1)
				VAR_25 = VAR_26;
			if (str_in_list(VAR_7, VAR_1, VAR_2))
				VAR_18 = 2;
			else if (VAR_18)
				VAR_18--;
			else
				VAR_25 = VAR_26;
			VAR_24 = VAR_18;
			break;

		case VAR_35:
			/* COMMENT_2 */
			if (VAR_17 < 0)
				return -VAR_31;
			VAR_24 = VAR_18;
			VAR_18 = VAR_10[VAR_17--];
			while (VAR_12 > VAR_7 && *--VAR_12 != '/')
				;
			*VAR_12 = '\0';
			if (VAR_17 == -1)
				VAR_20 = true;
			break;

		case VAR_28:
			VAR_24 = 1;
			break;
		}

		if (VAR_24 && VAR_16 == -1) {
			/* COMMENT_3 */
			if (VAR_15 && VAR_15 <= VAR_6 &&
			    VAR_26 == VAR_5[VAR_15 - 1].offset +
					VAR_5[VAR_15 - 1].size - VAR_19)
				VAR_16 = VAR_5[--VAR_15].offset - VAR_19;
			else
				VAR_16 = VAR_26;
		}

		if (!VAR_24 && VAR_16 != -1) {
			if (VAR_15 < VAR_6) {
				VAR_5[VAR_15].offset = VAR_19 + VAR_16;
				VAR_5[VAR_15].size = VAR_25 - VAR_16;
			}
			VAR_15++;
			VAR_16 = -1;
		}
	} while (VAR_14 != VAR_28);

	if (VAR_13 != fdt_size_dt_struct(VAR_0))
		return -VAR_29;

	/* COMMENT_4 */
	if (VAR_15 < VAR_6) {
		VAR_5[VAR_15].offset = VAR_19 + VAR_16;
		VAR_5[VAR_15].size = VAR_13 - VAR_16;
		if (VAR_9)
			VAR_5[VAR_15].size += fdt_size_dt_strings(VAR_0);
	}
	VAR_15++;

	return VAR_15;
}",u-boot/8a7d4cf9820ea16fabd25a6379351b4dc291204b/fdt_region.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,6 +12,7 @@
 	int depth = -1;
 	int want = 0;
 	int base = fdt_off_dt_struct(fdt);
+	bool expect_end = false;
 
 	end = path;
 	*end = '\0';
@@ -27,6 +28,10 @@
 		offset = nextoffset;
 		tag = fdt_next_tag(fdt, offset, &nextoffset);
 		stop_at = nextoffset;
+
+		/* If we see two root nodes, something is wrong */
+		if (expect_end && tag != FDT_END)
+			return -FDT_ERR_BADLAYOUT;
 
 		switch (tag) {
 		case FDT_PROP:
@@ -50,6 +55,10 @@
 			if (depth == FDT_MAX_DEPTH)
 				return -FDT_ERR_BADSTRUCTURE;
 			name = fdt_get_name(fdt, offset, &len);
+
+			/* The root node must have an empty name */
+			if (!depth && *name)
+				return -FDT_ERR_BADLAYOUT;
 			if (end - path + 2 + len >= path_len)
 				return -FDT_ERR_NOSPACE;
 			if (end != path + 1)
@@ -77,6 +86,8 @@
 			while (end > path && *--end != '/')
 				;
 			*end = '\0';
+			if (depth == -1)
+				expect_end = true;
 			break;
 
 		case FDT_END:","{'deleted_lines': [], 'added_lines': ['\tbool expect_end = false;', '', '\t\t/* If we see two root nodes, something is wrong */', '\t\tif (expect_end && tag != FDT_END)', '\t\t\treturn -FDT_ERR_BADLAYOUT;', '', '\t\t\t/* The root node must have an empty name */', '\t\t\tif (!depth && *name)', '\t\t\t\treturn -FDT_ERR_BADLAYOUT;', '\t\t\tif (depth == -1)', '\t\t\t\texpect_end = true;']}",True,The boot loader in Das U-Boot before 2021.04-rc2 mishandles a modified FIT.,7.8,HIGH,2,valid,2021-02-16T00:08:05Z,3
CVE-2021-27097,['CWE-Other'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,u-boot,"image: Add an option to do a full check of the FIT

Some strange modifications of the FIT can introduce security risks. Add an
option to check it thoroughly, using libfdt's fdt_check_full() function.

Enable this by default if signature verification is enabled.

CVE-2021-27097

Signed-off-by: Simon Glass <sjg@chromium.org>
Reported-by: Bruce Monroe <bruce.monroe@intel.com>
Reported-by: Arie Haenel <arie.haenel@intel.com>
Reported-by: Julien Lenoir <julien.lenoir@intel.com>",6f3c2d8aa5e6cbd80b5e869bbbddecb66c329d01,https://github.com/u-boot/u-boot/commit/6f3c2d8aa5e6cbd80b5e869bbbddecb66c329d01,common/image-fit.c,fit_check_format,"int fit_check_format(const void *fit, ulong size)
{
int ret;
ret = fdt_check_header(fit);
if (ret) {
log_debug(""Wrong FIT format: not a flattened device tree (err=%d)\n"",
ret);
return -ENOEXEC;
}
if (!fdt_getprop(fit, 0, FIT_DESC_PROP, NULL)) {
log_debug(""Wrong FIT format: no description\n"");
return -ENOMSG;
}
if (IMAGE_ENABLE_TIMESTAMP) {
if (!fdt_getprop(fit, 0, FIT_TIMESTAMP_PROP, NULL)) {
log_debug(""Wrong FIT format: no timestamp\n"");
return -ENODATA;
}
}
if (fdt_path_offset(fit, FIT_IMAGES_PATH) < 0) {
log_debug(""Wrong FIT format: no images parent node\n"");
return -ENOENT;
}
return 0;
}","int fit_check_format(const void *VAR_0, ulong VAR_1)
{
int VAR_2;
VAR_2 = fdt_check_header(VAR_0);
if (VAR_2) {
log_debug(""Wrong FIT format: not a flattened device tree (err=%d)\n"",
VAR_2);
return -VAR_3;
}
if (!fdt_getprop(VAR_0, 0, VAR_4, NULL)) {
log_debug(""Wrong FIT format: no description\n"");
return -VAR_5;
}
if (VAR_6) {
if (!fdt_getprop(VAR_0, 0, VAR_7, NULL)) {
log_debug(""Wrong FIT format: no timestamp\n"");
return -VAR_8;
}
}
if (fdt_path_offset(VAR_0, VAR_9) < 0) {
log_debug(""Wrong FIT format: no images parent node\n"");
return -VAR_10;
}
return 0;
}",u-boot/6f3c2d8aa5e6cbd80b5e869bbbddecb66c329d01/image-fit.c/vul/before/0.json,"int fit_check_format(const void *fit, ulong size)
{
	int ret;

	/* A FIT image must be a valid FDT */
	ret = fdt_check_header(fit);
	if (ret) {
		log_debug(""Wrong FIT format: not a flattened device tree (err=%d)\n"",
			  ret);
		return -ENOEXEC;
	}

	if (CONFIG_IS_ENABLED(FIT_FULL_CHECK)) {
		/*
		 * If we are not given the size, make do wtih calculating it.
		 * This is not as secure, so we should consider a flag to
		 * control this.
		 */
		if (size == IMAGE_SIZE_INVAL)
			size = fdt_totalsize(fit);
		ret = fdt_check_full(fit, size);

		if (ret) {
			log_debug(""FIT check error %d\n"", ret);
			return -EINVAL;
		}
	}

	/* mandatory / node 'description' property */
	if (!fdt_getprop(fit, 0, FIT_DESC_PROP, NULL)) {
		log_debug(""Wrong FIT format: no description\n"");
		return -ENOMSG;
	}

	if (IMAGE_ENABLE_TIMESTAMP) {
		/* mandatory / node 'timestamp' property */
		if (!fdt_getprop(fit, 0, FIT_TIMESTAMP_PROP, NULL)) {
			log_debug(""Wrong FIT format: no timestamp\n"");
			return -ENODATA;
		}
	}

	/* mandatory subimages parent '/images' node */
	if (fdt_path_offset(fit, FIT_IMAGES_PATH) < 0) {
		log_debug(""Wrong FIT format: no images parent node\n"");
		return -ENOENT;
	}

	return 0;
}","int fit_check_format(const void *VAR_0, ulong VAR_1)
{
	int VAR_2;

	/* COMMENT_0 */
	VAR_2 = fdt_check_header(VAR_0);
	if (VAR_2) {
		log_debug(""Wrong FIT format: not a flattened device tree (err=%d)\n"",
			  VAR_2);
		return -VAR_3;
	}

	if (CONFIG_IS_ENABLED(VAR_4)) {
		/* COMMENT_1 */
                                                               
                                                           
                  
     
		if (VAR_1 == VAR_5)
			VAR_1 = fdt_totalsize(VAR_0);
		VAR_2 = fdt_check_full(VAR_0, VAR_1);

		if (VAR_2) {
			log_debug(""FIT check error %d\n"", VAR_2);
			return -VAR_6;
		}
	}

	/* COMMENT_6 */
	if (!fdt_getprop(VAR_0, 0, VAR_7, NULL)) {
		log_debug(""Wrong FIT format: no description\n"");
		return -VAR_8;
	}

	if (VAR_9) {
		/* COMMENT_7 */
		if (!fdt_getprop(VAR_0, 0, VAR_10, NULL)) {
			log_debug(""Wrong FIT format: no timestamp\n"");
			return -VAR_11;
		}
	}

	/* COMMENT_8 */
	if (fdt_path_offset(VAR_0, VAR_12) < 0) {
		log_debug(""Wrong FIT format: no images parent node\n"");
		return -VAR_13;
	}

	return 0;
}",u-boot/6f3c2d8aa5e6cbd80b5e869bbbddecb66c329d01/image-fit.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,6 +8,22 @@
 		log_debug(""Wrong FIT format: not a flattened device tree (err=%d)\n"",
 			  ret);
 		return -ENOEXEC;
+	}
+
+	if (CONFIG_IS_ENABLED(FIT_FULL_CHECK)) {
+		/*
+		 * If we are not given the size, make do wtih calculating it.
+		 * This is not as secure, so we should consider a flag to
+		 * control this.
+		 */
+		if (size == IMAGE_SIZE_INVAL)
+			size = fdt_totalsize(fit);
+		ret = fdt_check_full(fit, size);
+
+		if (ret) {
+			log_debug(""FIT check error %d\n"", ret);
+			return -EINVAL;
+		}
 	}
 
 	/* mandatory / node 'description' property */","{'deleted_lines': [], 'added_lines': ['\t}', '', '\tif (CONFIG_IS_ENABLED(FIT_FULL_CHECK)) {', '\t\t/*', '\t\t * If we are not given the size, make do wtih calculating it.', '\t\t * This is not as secure, so we should consider a flag to', '\t\t * control this.', '\t\t */', '\t\tif (size == IMAGE_SIZE_INVAL)', '\t\t\tsize = fdt_totalsize(fit);', '\t\tret = fdt_check_full(fit, size);', '', '\t\tif (ret) {', '\t\t\tlog_debug(""FIT check error %d\\n"", ret);', '\t\t\treturn -EINVAL;', '\t\t}']}",True,The boot loader in Das U-Boot before 2021.04-rc2 mishandles a modified FIT.,7.8,HIGH,2,valid,2021-02-16T00:08:10Z,3
CVE-2021-27697,['CWE-120'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,RIOT-OS/RIOT,gnrc_rpl: harden validation routine for options,72337ebb9b9832e0fb513590191b9ad99623f0d3,https://github.com/RIOT-OS/RIOT/commit/72337ebb9b9832e0fb513590191b9ad99623f0d3,sys/net/gnrc/routing/rpl/gnrc_rpl_validation.c,gnrc_rpl_validation_options,"bool gnrc_rpl_validation_options(int msg_type, gnrc_rpl_instance_t *inst,
gnrc_rpl_opt_t *opt, uint16_t len)
{
uint16_t expected_len = 0;
while(expected_len < len) {
switch(opt->type) {
case (GNRC_RPL_OPT_PAD1):
expected_len += 1;
opt = (gnrc_rpl_opt_t *) (((uint8_t *) opt) + 1);
continue;
case (GNRC_RPL_OPT_DODAG_CONF):
if (msg_type != GNRC_RPL_ICMPV6_CODE_DIO) {
DEBUG(""RPL: DODAG CONF DIO option not expected\n"");
return false;
}
if (opt->length != GNRC_RPL_OPT_DODAG_CONF_LEN) {
DEBUG(""RPL: wrong DIO option (DODAG CONF) len: %d, expected: %d\n"",
opt->length, GNRC_RPL_OPT_DODAG_CONF_LEN);
return false;
}
break;
case (GNRC_RPL_OPT_PREFIX_INFO):
if (msg_type != GNRC_RPL_ICMPV6_CODE_DIO) {
DEBUG(""RPL: PREFIX INFO DIO option not expected\n"");
return false;
}
if (opt->length != GNRC_RPL_OPT_PREFIX_INFO_LEN) {
DEBUG(""RPL: wrong DIO option (PREFIX INFO) len: %d, expected: %d\n"",
opt->length, GNRC_RPL_OPT_PREFIX_INFO_LEN);
return false;
}
break;
case (GNRC_RPL_OPT_TARGET):
if (msg_type != GNRC_RPL_ICMPV6_CODE_DAO) {
DEBUG(""RPL: RPL TARGET DAO option not expected\n"");
return false;
}
if (opt->length > GNRC_RPL_OPT_TARGET_LEN) {
DEBUG(""RPL: wrong DAO option (RPL TARGET) len: %d, expected (max): %d\n"",
opt->length, GNRC_RPL_OPT_TARGET_LEN);
return false;
}
break;
case (GNRC_RPL_OPT_TRANSIT):
if (msg_type != GNRC_RPL_ICMPV6_CODE_DAO) {
DEBUG(""RPL: RPL TRANSIT INFO DAO option not expected\n"");
return false;
}
uint8_t parent_addr = 0;
if (inst->mop == GNRC_RPL_MOP_NON_STORING_MODE) {
parent_addr = sizeof(ipv6_addr_t);
}
if (opt->length != (GNRC_RPL_OPT_TRANSIT_INFO_LEN + parent_addr)) {
DEBUG(""RPL: wrong DAO option (TRANSIT INFO) len: %d, expected: %d\n"",
opt->length, (GNRC_RPL_OPT_TRANSIT_INFO_LEN + parent_addr));
return false;
}
break;
default:
break;
}
expected_len += opt->length + sizeof(gnrc_rpl_opt_t);
opt = (gnrc_rpl_opt_t *) (((uint8_t *) (opt + 1)) + opt->length);
}
if (expected_len == len) {
return true;
}
DEBUG(""RPL: wrong options len: %d, expected: %d\n"", len, expected_len);
return false;
}","bool gnrc_rpl_validation_options(int VAR_0, gnrc_rpl_instance_t *VAR_1,
gnrc_rpl_opt_t *VAR_2, uint16_t VAR_3)
{
uint16_t VAR_4 = 0;
while(VAR_4 < VAR_3) {
switch(VAR_2->type) {
case (VAR_5):
VAR_4 += 1;
VAR_2 = (gnrc_rpl_opt_t *) (((uint8_t *) VAR_2) + 1);
continue;
case (VAR_6):
if (VAR_0 != VAR_7) {
DEBUG(""RPL: DODAG CONF DIO option not expected\n"");
return false;
}
if (VAR_2->length != VAR_8) {
DEBUG(""RPL: wrong DIO option (DODAG CONF) len: %d, expected: %d\n"",
VAR_2->length, VAR_8);
return false;
}
break;
case (VAR_9):
if (VAR_0 != VAR_7) {
DEBUG(""RPL: PREFIX INFO DIO option not expected\n"");
return false;
}
if (VAR_2->length != VAR_10) {
DEBUG(""RPL: wrong DIO option (PREFIX INFO) len: %d, expected: %d\n"",
VAR_2->length, VAR_10);
return false;
}
break;
case (VAR_11):
if (VAR_0 != VAR_12) {
DEBUG(""RPL: RPL TARGET DAO option not expected\n"");
return false;
}
if (VAR_2->length > VAR_13) {
DEBUG(""RPL: wrong DAO option (RPL TARGET) len: %d, expected (max): %d\n"",
VAR_2->length, VAR_13);
return false;
}
break;
case (VAR_14):
if (VAR_0 != VAR_12) {
DEBUG(""RPL: RPL TRANSIT INFO DAO option not expected\n"");
return false;
}
uint8_t VAR_15 = 0;
if (VAR_1->mop == VAR_16) {
VAR_15 = sizeof(VAR_17);
}
if (VAR_2->length != (VAR_18 + VAR_15)) {
DEBUG(""RPL: wrong DAO option (TRANSIT INFO) len: %d, expected: %d\n"",
VAR_2->length, (VAR_18 + VAR_15));
return false;
}
break;
default:
break;
}
VAR_4 += VAR_2->length + sizeof(gnrc_rpl_opt_t);
VAR_2 = (gnrc_rpl_opt_t *) (((uint8_t *) (VAR_2 + 1)) + VAR_2->length);
}
if (VAR_4 == VAR_3) {
return true;
}
DEBUG(""RPL: wrong options len: %d, expected: %d\n"", VAR_3, VAR_4);
return false;
}",RIOT-OS/RIOT/72337ebb9b9832e0fb513590191b9ad99623f0d3/gnrc_rpl_validation.c/vul/before/0.json,"bool gnrc_rpl_validation_options(int msg_type, gnrc_rpl_instance_t *inst,
                                 gnrc_rpl_opt_t *opt, uint16_t len)
{
    uint16_t expected_len = 0;

    while(expected_len < len) {
        if (opt->type == GNRC_RPL_OPT_PAD1) {
            expected_len += 1;
            opt = (gnrc_rpl_opt_t *) (((uint8_t *) opt) + 1);
            continue;
        }

        if ((expected_len + sizeof(gnrc_rpl_opt_t)) > len) {
            break;
        }

        switch(opt->type) {
            case (GNRC_RPL_OPT_DODAG_CONF):
                if (msg_type != GNRC_RPL_ICMPV6_CODE_DIO) {
                    DEBUG(""RPL: DODAG CONF DIO option not expected\n"");
                    return false;
                }

                if (opt->length != GNRC_RPL_OPT_DODAG_CONF_LEN) {
                    DEBUG(""RPL: wrong DIO option (DODAG CONF) len: %d, expected: %d\n"",
                           opt->length, GNRC_RPL_OPT_DODAG_CONF_LEN);
                    return false;
                }
                break;

            case (GNRC_RPL_OPT_PREFIX_INFO):
                if (msg_type != GNRC_RPL_ICMPV6_CODE_DIO) {
                    DEBUG(""RPL: PREFIX INFO DIO option not expected\n"");
                    return false;
                }

                if (opt->length != GNRC_RPL_OPT_PREFIX_INFO_LEN) {
                    DEBUG(""RPL: wrong DIO option (PREFIX INFO) len: %d, expected: %d\n"",
                           opt->length, GNRC_RPL_OPT_PREFIX_INFO_LEN);
                    return false;
                }
                break;

            case (GNRC_RPL_OPT_TARGET):
                if (msg_type != GNRC_RPL_ICMPV6_CODE_DAO) {
                    DEBUG(""RPL: RPL TARGET DAO option not expected\n"");
                    return false;
                }

                if (opt->length > GNRC_RPL_OPT_TARGET_LEN) {
                    DEBUG(""RPL: wrong DAO option (RPL TARGET) len: %d, expected (max): %d\n"",
                           opt->length, GNRC_RPL_OPT_TARGET_LEN);
                    return false;
                }
                break;

            case (GNRC_RPL_OPT_TRANSIT):
                if (msg_type != GNRC_RPL_ICMPV6_CODE_DAO) {
                    DEBUG(""RPL: RPL TRANSIT INFO DAO option not expected\n"");
                    return false;
                }

                uint8_t parent_addr = 0;
                if (inst->mop == GNRC_RPL_MOP_NON_STORING_MODE) {
                    parent_addr = sizeof(ipv6_addr_t);
                }

                if (opt->length != (GNRC_RPL_OPT_TRANSIT_INFO_LEN + parent_addr)) {
                    DEBUG(""RPL: wrong DAO option (TRANSIT INFO) len: %d, expected: %d\n"",
                           opt->length, (GNRC_RPL_OPT_TRANSIT_INFO_LEN + parent_addr));
                    return false;
                }
                break;

            default:
                break;

        }
        expected_len += opt->length + sizeof(gnrc_rpl_opt_t);

        if (expected_len >= len) {
          break;
        }

        opt = (gnrc_rpl_opt_t *) (((uint8_t *) (opt + 1)) + opt->length);
    }

    if (expected_len == len) {
        return true;
    }

    DEBUG(""RPL: wrong options len: %d, expected: %d\n"", len, expected_len);

    return false;
}","bool gnrc_rpl_validation_options(int VAR_0, gnrc_rpl_instance_t *VAR_1,
                                 gnrc_rpl_opt_t *VAR_2, uint16_t VAR_3)
{
    uint16_t VAR_4 = 0;

    while(VAR_4 < VAR_3) {
        if (VAR_2->type == VAR_5) {
            VAR_4 += 1;
            VAR_2 = (gnrc_rpl_opt_t *) (((uint8_t *) VAR_2) + 1);
            continue;
        }

        if ((VAR_4 + sizeof(gnrc_rpl_opt_t)) > VAR_3) {
            break;
        }

        switch(VAR_2->type) {
            case (VAR_6):
                if (VAR_0 != VAR_7) {
                    DEBUG(""RPL: DODAG CONF DIO option not expected\n"");
                    return false;
                }

                if (VAR_2->length != VAR_8) {
                    DEBUG(""RPL: wrong DIO option (DODAG CONF) len: %d, expected: %d\n"",
                           VAR_2->length, VAR_8);
                    return false;
                }
                break;

            case (VAR_9):
                if (VAR_0 != VAR_7) {
                    DEBUG(""RPL: PREFIX INFO DIO option not expected\n"");
                    return false;
                }

                if (VAR_2->length != VAR_10) {
                    DEBUG(""RPL: wrong DIO option (PREFIX INFO) len: %d, expected: %d\n"",
                           VAR_2->length, VAR_10);
                    return false;
                }
                break;

            case (VAR_11):
                if (VAR_0 != VAR_12) {
                    DEBUG(""RPL: RPL TARGET DAO option not expected\n"");
                    return false;
                }

                if (VAR_2->length > VAR_13) {
                    DEBUG(""RPL: wrong DAO option (RPL TARGET) len: %d, expected (max): %d\n"",
                           VAR_2->length, VAR_13);
                    return false;
                }
                break;

            case (VAR_14):
                if (VAR_0 != VAR_12) {
                    DEBUG(""RPL: RPL TRANSIT INFO DAO option not expected\n"");
                    return false;
                }

                uint8_t VAR_15 = 0;
                if (VAR_1->mop == VAR_16) {
                    VAR_15 = sizeof(VAR_17);
                }

                if (VAR_2->length != (VAR_18 + VAR_15)) {
                    DEBUG(""RPL: wrong DAO option (TRANSIT INFO) len: %d, expected: %d\n"",
                           VAR_2->length, (VAR_18 + VAR_15));
                    return false;
                }
                break;

            default:
                break;

        }
        VAR_4 += VAR_2->length + sizeof(gnrc_rpl_opt_t);

        if (VAR_4 >= VAR_3) {
          break;
        }

        VAR_2 = (gnrc_rpl_opt_t *) (((uint8_t *) (VAR_2 + 1)) + VAR_2->length);
    }

    if (VAR_4 == VAR_3) {
        return true;
    }

    DEBUG(""RPL: wrong options len: %d, expected: %d\n"", VAR_3, VAR_4);

    return false;
}",RIOT-OS/RIOT/72337ebb9b9832e0fb513590191b9ad99623f0d3/gnrc_rpl_validation.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,12 +4,17 @@
     uint16_t expected_len = 0;
 
     while(expected_len < len) {
+        if (opt->type == GNRC_RPL_OPT_PAD1) {
+            expected_len += 1;
+            opt = (gnrc_rpl_opt_t *) (((uint8_t *) opt) + 1);
+            continue;
+        }
+
+        if ((expected_len + sizeof(gnrc_rpl_opt_t)) > len) {
+            break;
+        }
+
         switch(opt->type) {
-            case (GNRC_RPL_OPT_PAD1):
-                expected_len += 1;
-                opt = (gnrc_rpl_opt_t *) (((uint8_t *) opt) + 1);
-                continue;
-
             case (GNRC_RPL_OPT_DODAG_CONF):
                 if (msg_type != GNRC_RPL_ICMPV6_CODE_DIO) {
                     DEBUG(""RPL: DODAG CONF DIO option not expected\n"");
@@ -72,6 +77,11 @@
 
         }
         expected_len += opt->length + sizeof(gnrc_rpl_opt_t);
+
+        if (expected_len >= len) {
+          break;
+        }
+
         opt = (gnrc_rpl_opt_t *) (((uint8_t *) (opt + 1)) + opt->length);
     }
 ","{'deleted_lines': ['            case (GNRC_RPL_OPT_PAD1):', '                expected_len += 1;', '                opt = (gnrc_rpl_opt_t *) (((uint8_t *) opt) + 1);', '                continue;', ''], 'added_lines': ['        if (opt->type == GNRC_RPL_OPT_PAD1) {', '            expected_len += 1;', '            opt = (gnrc_rpl_opt_t *) (((uint8_t *) opt) + 1);', '            continue;', '        }', '', '        if ((expected_len + sizeof(gnrc_rpl_opt_t)) > len) {', '            break;', '        }', '', '', '        if (expected_len >= len) {', '          break;', '        }', '']}",True,RIOT-OS 2021.01 contains a buffer overflow vulnerability in sys/net/gnrc/routing/rpl/gnrc_rpl_validation.c through the gnrc_rpl_validation_options() function.,9.8,CRITICAL,3,valid,2021-02-23T17:50:57Z,3
CVE-2021-28650,['CWE-59'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,GNOME/gnome-autoar,"extractor: Do not allow symlink in parents

Currently, it is still possible that some files are extracted outside of
the destination dir in case of malicious archives. The checks from commit
adb067e6 can be still bypassed in certain cases. See GNOME/file-roller#108
for more details. After some investigation, I am convinced that it would be
best to	simply disallow symlinks in parents. For example, `tar` fails to
extract such files with the `ENOTDIR` error. Let's do the same here.

Fixes: https://gitlab.gnome.org/GNOME/gnome-autoar/-/issues/12",8109c368c6cfdb593faaf698c2bf5da32bb1ace4,https://github.com/GNOME/gnome-autoar/commit/8109c368c6cfdb593faaf698c2bf5da32bb1ace4,gnome-autoar/autoar-extractor.c,autoar_extractor_check_file_conflict,"static gboolean
autoar_extractor_check_file_conflict (GFile  *file,
mode_t  extracted_filetype)
{
GFileType file_type;
file_type = g_file_query_file_type (file,
G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
NULL);
if (file_type == G_FILE_TYPE_UNKNOWN) {
return FALSE;
}
if (file_type == G_FILE_TYPE_DIRECTORY &&
extracted_filetype == AE_IFDIR) {
return FALSE;
}
return TRUE;
}","static gboolean
autoar_extractor_check_file_conflict (GFile  *VAR_0,
mode_t  VAR_1)
{
GFileType VAR_2;
VAR_2 = g_file_query_file_type (VAR_0,
VAR_3,
NULL);
if (VAR_2 == VAR_4) {
return FALSE;
}
if (VAR_2 == VAR_5 &&
VAR_1 == VAR_6) {
return FALSE;
}
return TRUE;
}",GNOME/gnome-autoar/8109c368c6cfdb593faaf698c2bf5da32bb1ace4/autoar-extractor.c/vul/before/0.json,"static GFile *
autoar_extractor_check_file_conflict (AutoarExtractor *self,
                                      GFile  *file,
                                      mode_t  extracted_filetype)
{
  GFileType file_type;
  g_autoptr (GFile) parent = NULL;

  file_type = g_file_query_file_type (file,
                                      G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
                                      NULL);

  /* It is a conflict if the file already exists with an exception for already
   * existing directories.
   */
  if (file_type != G_FILE_TYPE_UNKNOWN &&
      (file_type != G_FILE_TYPE_DIRECTORY ||
       extracted_filetype != AE_IFDIR)) {
    return g_object_ref (file);
  }

  if ((self->new_prefix && g_file_equal (self->new_prefix, file)) ||
      (!self->new_prefix && g_file_equal (self->destination_dir, file))) {
    return NULL;
  }

  /* Check also parents for conflict to be sure it is directory. */
  parent = g_file_get_parent (file);
  return autoar_extractor_check_file_conflict (self, parent, AE_IFDIR);
}","static GFile *
autoar_extractor_check_file_conflict (AutoarExtractor *VAR_0,
                                      GFile  *VAR_1,
                                      mode_t  VAR_2)
{
  GFileType VAR_3;
  VAR_4 (GFile) VAR_5 = NULL;

  VAR_3 = g_file_query_file_type (VAR_1,
                                      VAR_6,
                                      NULL);

  /* COMMENT_0 */
                          
     
  if (VAR_3 != VAR_7 &&
      (VAR_3 != VAR_8 ||
       VAR_2 != VAR_9)) {
    return g_object_ref (VAR_1);
  }

  if ((VAR_0->new_prefix && g_file_equal (VAR_0->new_prefix, VAR_1)) ||
      (!VAR_0->new_prefix && g_file_equal (VAR_0->destination_dir, VAR_1))) {
    return NULL;
  }

  /* COMMENT_3 */
  VAR_5 = g_file_get_parent (VAR_1);
  return autoar_extractor_check_file_conflict (VAR_0, VAR_5, VAR_9);
}",GNOME/gnome-autoar/8109c368c6cfdb593faaf698c2bf5da32bb1ace4/autoar-extractor.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,22 +1,30 @@
-static gboolean
-autoar_extractor_check_file_conflict (GFile  *file,
+static GFile *
+autoar_extractor_check_file_conflict (AutoarExtractor *self,
+                                      GFile  *file,
                                       mode_t  extracted_filetype)
 {
   GFileType file_type;
+  g_autoptr (GFile) parent = NULL;
 
   file_type = g_file_query_file_type (file,
                                       G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
                                       NULL);
-  /* If there is no file with the given name, there will be no conflict */
-  if (file_type == G_FILE_TYPE_UNKNOWN) {
-    return FALSE;
+
+  /* It is a conflict if the file already exists with an exception for already
+   * existing directories.
+   */
+  if (file_type != G_FILE_TYPE_UNKNOWN &&
+      (file_type != G_FILE_TYPE_DIRECTORY ||
+       extracted_filetype != AE_IFDIR)) {
+    return g_object_ref (file);
   }
 
-  /* It is not problem if the directory already exists */
-  if (file_type == G_FILE_TYPE_DIRECTORY &&
-      extracted_filetype == AE_IFDIR) {
-    return FALSE;
+  if ((self->new_prefix && g_file_equal (self->new_prefix, file)) ||
+      (!self->new_prefix && g_file_equal (self->destination_dir, file))) {
+    return NULL;
   }
 
-  return TRUE;
+  /* Check also parents for conflict to be sure it is directory. */
+  parent = g_file_get_parent (file);
+  return autoar_extractor_check_file_conflict (self, parent, AE_IFDIR);
 }","{'deleted_lines': ['static gboolean', 'autoar_extractor_check_file_conflict (GFile  *file,', '  /* If there is no file with the given name, there will be no conflict */', '  if (file_type == G_FILE_TYPE_UNKNOWN) {', '    return FALSE;', '  /* It is not problem if the directory already exists */', '  if (file_type == G_FILE_TYPE_DIRECTORY &&', '      extracted_filetype == AE_IFDIR) {', '    return FALSE;', '  return TRUE;'], 'added_lines': ['static GFile *', 'autoar_extractor_check_file_conflict (AutoarExtractor *self,', '                                      GFile  *file,', '  g_autoptr (GFile) parent = NULL;', '', '  /* It is a conflict if the file already exists with an exception for already', '   * existing directories.', '   */', '  if (file_type != G_FILE_TYPE_UNKNOWN &&', '      (file_type != G_FILE_TYPE_DIRECTORY ||', '       extracted_filetype != AE_IFDIR)) {', '    return g_object_ref (file);', '  if ((self->new_prefix && g_file_equal (self->new_prefix, file)) ||', '      (!self->new_prefix && g_file_equal (self->destination_dir, file))) {', '    return NULL;', '  /* Check also parents for conflict to be sure it is directory. */', '  parent = g_file_get_parent (file);', '  return autoar_extractor_check_file_conflict (self, parent, AE_IFDIR);']}",True,"autoar-extractor.c in GNOME gnome-autoar before 0.3.1, as used by GNOME Shell, Nautilus, and other software, allows Directory Traversal during extraction because it lacks a check of whether a file's parent is a symlink in certain complex situations. NOTE: this issue exists because of an incomplete fix for CVE-2020-36241.",5.5,MEDIUM,1,valid,2021-03-01T16:16:27Z,3
CVE-2021-28650,['CWE-59'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,GNOME/gnome-autoar,"extractor: Do not allow symlink in parents

Currently, it is still possible that some files are extracted outside of
the destination dir in case of malicious archives. The checks from commit
adb067e6 can be still bypassed in certain cases. See GNOME/file-roller#108
for more details. After some investigation, I am convinced that it would be
best to	simply disallow symlinks in parents. For example, `tar` fails to
extract such files with the `ENOTDIR` error. Let's do the same here.

Fixes: https://gitlab.gnome.org/GNOME/gnome-autoar/-/issues/12",8109c368c6cfdb593faaf698c2bf5da32bb1ace4,https://github.com/GNOME/gnome-autoar/commit/8109c368c6cfdb593faaf698c2bf5da32bb1ace4,gnome-autoar/autoar-extractor.c,autoar_extractor_step_extract,"static void
autoar_extractor_step_extract (AutoarExtractor *self) {
struct archive *a;
struct archive_entry *entry;
int r;
g_debug (""autoar_extractor_step_extract: called"");
r = libarchive_create_read_object (self->use_raw_format, self, &a);
if (r != ARCHIVE_OK) {
if (self->error == NULL) {
self->error =
autoar_common_g_error_new_a (a, self->source_basename);
}
archive_read_free (a);
return;
}
while ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {
const char *pathname;
const char *hardlink;
g_autoptr (GFile) extracted_filename = NULL;
g_autoptr (GFile) hardlink_filename = NULL;
AutoarConflictAction action;
gboolean file_conflict;
if (g_cancellable_is_cancelled (self->cancellable)) {
archive_read_free (a);
return;
}
pathname = archive_entry_pathname (entry);
hardlink = archive_entry_hardlink (entry);
extracted_filename =
autoar_extractor_do_sanitize_pathname (self, pathname);
if (hardlink != NULL) {
hardlink_filename =
autoar_extractor_do_sanitize_pathname (self, hardlink);
}
file_conflict = autoar_extractor_check_file_conflict (extracted_filename,
archive_entry_filetype (entry));
while (file_conflict) {
GFile *new_extracted_filename = NULL;
action = autoar_extractor_signal_conflict (self,
extracted_filename,
&new_extracted_filename);
switch (action) {
case AUTOAR_CONFLICT_OVERWRITE:
g_file_delete (extracted_filename, self->cancellable, &self->error);
if (self->error != NULL) {
archive_read_free (a);
return;
}
break;
case AUTOAR_CONFLICT_CHANGE_DESTINATION:
g_assert_nonnull (new_extracted_filename);
g_clear_object (&extracted_filename);
extracted_filename = new_extracted_filename;
break;
case AUTOAR_CONFLICT_SKIP:
archive_read_data_skip (a);
break;
default:
g_assert_not_reached ();
break;
}
if (action != AUTOAR_CONFLICT_CHANGE_DESTINATION) {
break;
}
file_conflict = autoar_extractor_check_file_conflict (extracted_filename,
archive_entry_filetype (entry));
}
if (file_conflict && action == AUTOAR_CONFLICT_SKIP) {
self->total_files -= 1;
self->total_size -= archive_entry_size (entry);
continue;
}
autoar_extractor_do_write_entry (self, a, entry,
extracted_filename, hardlink_filename);
if (self->error != NULL) {
archive_read_free (a);
return;
}
self->completed_files++;
autoar_extractor_signal_progress (self);
}
if (r != ARCHIVE_EOF) {
if (self->error == NULL) {
self->error =
autoar_common_g_error_new_a (a, self->source_basename);
}
archive_read_free (a);
return;
}
archive_read_free (a);
}","static void
autoar_extractor_step_extract (AutoarExtractor *VAR_0) {
struct archive *VAR_1;
struct archive_entry *VAR_2;
int VAR_3;
g_debug (""autoar_extractor_step_extract: called"");
VAR_3 = libarchive_create_read_object (VAR_0->use_raw_format, VAR_0, &VAR_1);
if (VAR_3 != VAR_4) {
if (VAR_0->error == NULL) {
VAR_0->error =
autoar_common_g_error_new_a (VAR_1, VAR_0->source_basename);
}
archive_read_free (VAR_1);
return;
}
while ((VAR_3 = archive_read_next_header (VAR_1, &VAR_2)) == VAR_4) {
const char *VAR_5;
const char *VAR_6;
VAR_7 (GFile) VAR_8 = NULL;
VAR_7 (GFile) VAR_9 = NULL;
AutoarConflictAction VAR_10;
gboolean VAR_11;
if (g_cancellable_is_cancelled (VAR_0->cancellable)) {
archive_read_free (VAR_1);
return;
}
VAR_5 = archive_entry_pathname (VAR_2);
VAR_6 = archive_entry_hardlink (VAR_2);
VAR_8 =
autoar_extractor_do_sanitize_pathname (VAR_0, VAR_5);
if (VAR_6 != NULL) {
VAR_9 =
autoar_extractor_do_sanitize_pathname (VAR_0, VAR_6);
}
VAR_11 = autoar_extractor_check_file_conflict (VAR_8,
archive_entry_filetype (VAR_2));
while (VAR_11) {
GFile *VAR_12 = NULL;
VAR_10 = autoar_extractor_signal_conflict (VAR_0,
VAR_8,
&VAR_12);
switch (VAR_10) {
case VAR_13:
g_file_delete (VAR_8, VAR_0->cancellable, &VAR_0->error);
if (VAR_0->error != NULL) {
archive_read_free (VAR_1);
return;
}
break;
case VAR_14:
g_assert_nonnull (VAR_12);
g_clear_object (&VAR_8);
VAR_8 = VAR_12;
break;
case VAR_15:
archive_read_data_skip (VAR_1);
break;
default:
g_assert_not_reached ();
break;
}
if (VAR_10 != VAR_14) {
break;
}
VAR_11 = autoar_extractor_check_file_conflict (VAR_8,
archive_entry_filetype (VAR_2));
}
if (VAR_11 && VAR_10 == VAR_15) {
VAR_0->total_files -= 1;
VAR_0->total_size -= archive_entry_size (VAR_2);
continue;
}
autoar_extractor_do_write_entry (VAR_0, VAR_1, VAR_2,
VAR_8, VAR_9);
if (VAR_0->error != NULL) {
archive_read_free (VAR_1);
return;
}
VAR_0->completed_files++;
autoar_extractor_signal_progress (VAR_0);
}
if (VAR_3 != VAR_16) {
if (VAR_0->error == NULL) {
VAR_0->error =
autoar_common_g_error_new_a (VAR_1, VAR_0->source_basename);
}
archive_read_free (VAR_1);
return;
}
archive_read_free (VAR_1);
}",GNOME/gnome-autoar/8109c368c6cfdb593faaf698c2bf5da32bb1ace4/autoar-extractor.c/vul/before/1.json,"static void
autoar_extractor_step_extract (AutoarExtractor *self) {
  /* Step 3: Extract files
   * We have to re-open the archive to extract files
   */

  struct archive *a;
  struct archive_entry *entry;

  int r;

  g_debug (""autoar_extractor_step_extract: called"");

  r = libarchive_create_read_object (self->use_raw_format, self, &a);
  if (r != ARCHIVE_OK) {
    if (self->error == NULL) {
      self->error =
        autoar_common_g_error_new_a (a, self->source_basename);
    }
    archive_read_free (a);
    return;
  }

  while ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {
    const char *pathname;
    const char *hardlink;
    g_autoptr (GFile) extracted_filename = NULL;
    g_autoptr (GFile) hardlink_filename = NULL;
    AutoarConflictAction action;
    g_autoptr (GFile) file_conflict = NULL;

    if (g_cancellable_is_cancelled (self->cancellable)) {
      archive_read_free (a);
      return;
    }

    pathname = archive_entry_pathname (entry);
    hardlink = archive_entry_hardlink (entry);

    extracted_filename =
      autoar_extractor_do_sanitize_pathname (self, pathname);

    if (hardlink != NULL) {
      hardlink_filename =
        autoar_extractor_do_sanitize_pathname (self, hardlink);
    }

    /* Attempt to solve any name conflict before doing any operations */
    file_conflict = autoar_extractor_check_file_conflict (self,
                                                          extracted_filename,
                                                          archive_entry_filetype (entry));
    while (file_conflict) {
      GFile *new_extracted_filename = NULL;

      /* Do not try to solve any conflicts in parents for now. Especially
       * symlinks in parents are dangerous as it can easily happen that files
       * are written outside of the destination. The tar cmd fails to extract
       * such archives with ENOTDIR. Let's do the same here. This is most
       * probably malicious, or corrupted archive if the conflict was caused
       * only by files from the archive...
       */
      if (!g_file_equal (file_conflict, extracted_filename)) {
        self->error = g_error_new (G_IO_ERROR,
                                   G_IO_ERROR_NOT_DIRECTORY,
                                   ""The file is not a directory"");
        archive_read_free (a);
        return;
      }

      action = autoar_extractor_signal_conflict (self,
                                                 extracted_filename,
                                                 &new_extracted_filename);

      switch (action) {
        case AUTOAR_CONFLICT_OVERWRITE:
          /* It is expected that this will fail for non-empty directories to
           * prevent data loss.
           */
          g_file_delete (extracted_filename, self->cancellable, &self->error);
          if (self->error != NULL) {
            archive_read_free (a);
            return;
          }
          break;
        case AUTOAR_CONFLICT_CHANGE_DESTINATION:
          /* FIXME: If the destination is changed for directory, it should be
           * changed also for its children...
           */
          g_assert_nonnull (new_extracted_filename);
          g_clear_object (&extracted_filename);
          extracted_filename = new_extracted_filename;
          break;
        case AUTOAR_CONFLICT_SKIP:
          archive_read_data_skip (a);
          break;
        default:
          g_assert_not_reached ();
          break;
      }

      if (action != AUTOAR_CONFLICT_CHANGE_DESTINATION) {
        break;
      }

      g_clear_object (&file_conflict);
      file_conflict = autoar_extractor_check_file_conflict (self,
                                                            extracted_filename,
                                                            archive_entry_filetype (entry));
    }

    if (file_conflict && action == AUTOAR_CONFLICT_SKIP) {
      self->total_files -= 1;
      self->total_size -= archive_entry_size (entry);
      continue;
    }

    autoar_extractor_do_write_entry (self, a, entry,
                                     extracted_filename, hardlink_filename);

    if (self->error != NULL) {
      archive_read_free (a);
      return;
    }

    self->completed_files++;
    autoar_extractor_signal_progress (self);
  }

  if (r != ARCHIVE_EOF) {
    if (self->error == NULL) {
      self->error =
        autoar_common_g_error_new_a (a, self->source_basename);
    }
    archive_read_free (a);
    return;
  }

  archive_read_free (a);
}","static void
autoar_extractor_step_extract (AutoarExtractor *VAR_0) {
  /* COMMENT_0 */
                                                    
     

  struct archive *VAR_1;
  struct archive_entry *VAR_2;

  int VAR_3;

  g_debug (""autoar_extractor_step_extract: called"");

  VAR_3 = libarchive_create_read_object (VAR_0->use_raw_format, VAR_0, &VAR_1);
  if (VAR_3 != VAR_4) {
    if (VAR_0->error == NULL) {
      VAR_0->error =
        autoar_common_g_error_new_a (VAR_1, VAR_0->source_basename);
    }
    archive_read_free (VAR_1);
    return;
  }

  while ((VAR_3 = archive_read_next_header (VAR_1, &VAR_2)) == VAR_4) {
    const char *VAR_5;
    const char *VAR_6;
    VAR_7 (GFile) VAR_8 = NULL;
    VAR_7 (GFile) VAR_9 = NULL;
    AutoarConflictAction VAR_10;
    VAR_7 (GFile) VAR_11 = NULL;

    if (g_cancellable_is_cancelled (VAR_0->cancellable)) {
      archive_read_free (VAR_1);
      return;
    }

    VAR_5 = archive_entry_pathname (VAR_2);
    VAR_6 = archive_entry_hardlink (VAR_2);

    VAR_8 =
      autoar_extractor_do_sanitize_pathname (VAR_0, VAR_5);

    if (VAR_6 != NULL) {
      VAR_9 =
        autoar_extractor_do_sanitize_pathname (VAR_0, VAR_6);
    }

    /* COMMENT_3 */
    VAR_11 = autoar_extractor_check_file_conflict (VAR_0,
                                                          VAR_8,
                                                          archive_entry_filetype (VAR_2));
    while (VAR_11) {
      GFile *VAR_12 = NULL;

      /* COMMENT_4 */
                                                                             
                                                                             
                                                                         
                                                                            
                                          
         
      if (!g_file_equal (VAR_11, VAR_8)) {
        VAR_0->error = g_error_new (VAR_13,
                                   VAR_14,
                                   ""The file is not a directory"");
        archive_read_free (VAR_1);
        return;
      }

      VAR_10 = autoar_extractor_signal_conflict (VAR_0,
                                                 VAR_8,
                                                 &VAR_12);

      switch (VAR_10) {
        case VAR_15:
          /* COMMENT_11 */
                               
             
          g_file_delete (VAR_8, VAR_0->cancellable, &VAR_0->error);
          if (VAR_0->error != NULL) {
            archive_read_free (VAR_1);
            return;
          }
          break;
        case VAR_16:
          /* COMMENT_14 */
                                             
             
          g_assert_nonnull (VAR_12);
          g_clear_object (&VAR_8);
          VAR_8 = VAR_12;
          break;
        case VAR_17:
          archive_read_data_skip (VAR_1);
          break;
        default:
          g_assert_not_reached ();
          break;
      }

      if (VAR_10 != VAR_16) {
        break;
      }

      g_clear_object (&VAR_11);
      VAR_11 = autoar_extractor_check_file_conflict (VAR_0,
                                                            VAR_8,
                                                            archive_entry_filetype (VAR_2));
    }

    if (VAR_11 && VAR_10 == VAR_17) {
      VAR_0->total_files -= 1;
      VAR_0->total_size -= archive_entry_size (VAR_2);
      continue;
    }

    autoar_extractor_do_write_entry (VAR_0, VAR_1, VAR_2,
                                     VAR_8, VAR_9);

    if (VAR_0->error != NULL) {
      archive_read_free (VAR_1);
      return;
    }

    VAR_0->completed_files++;
    autoar_extractor_signal_progress (VAR_0);
  }

  if (VAR_3 != VAR_18) {
    if (VAR_0->error == NULL) {
      VAR_0->error =
        autoar_common_g_error_new_a (VAR_1, VAR_0->source_basename);
    }
    archive_read_free (VAR_1);
    return;
  }

  archive_read_free (VAR_1);
}",GNOME/gnome-autoar/8109c368c6cfdb593faaf698c2bf5da32bb1ace4/autoar-extractor.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -27,7 +27,7 @@
     g_autoptr (GFile) extracted_filename = NULL;
     g_autoptr (GFile) hardlink_filename = NULL;
     AutoarConflictAction action;
-    gboolean file_conflict;
+    g_autoptr (GFile) file_conflict = NULL;
 
     if (g_cancellable_is_cancelled (self->cancellable)) {
       archive_read_free (a);
@@ -46,10 +46,26 @@
     }
 
     /* Attempt to solve any name conflict before doing any operations */
-    file_conflict = autoar_extractor_check_file_conflict (extracted_filename,
+    file_conflict = autoar_extractor_check_file_conflict (self,
+                                                          extracted_filename,
                                                           archive_entry_filetype (entry));
     while (file_conflict) {
       GFile *new_extracted_filename = NULL;
+
+      /* Do not try to solve any conflicts in parents for now. Especially
+       * symlinks in parents are dangerous as it can easily happen that files
+       * are written outside of the destination. The tar cmd fails to extract
+       * such archives with ENOTDIR. Let's do the same here. This is most
+       * probably malicious, or corrupted archive if the conflict was caused
+       * only by files from the archive...
+       */
+      if (!g_file_equal (file_conflict, extracted_filename)) {
+        self->error = g_error_new (G_IO_ERROR,
+                                   G_IO_ERROR_NOT_DIRECTORY,
+                                   ""The file is not a directory"");
+        archive_read_free (a);
+        return;
+      }
 
       action = autoar_extractor_signal_conflict (self,
                                                  extracted_filename,
@@ -86,7 +102,9 @@
         break;
       }
 
-      file_conflict = autoar_extractor_check_file_conflict (extracted_filename,
+      g_clear_object (&file_conflict);
+      file_conflict = autoar_extractor_check_file_conflict (self,
+                                                            extracted_filename,
                                                             archive_entry_filetype (entry));
     }
 ","{'deleted_lines': ['    gboolean file_conflict;', '    file_conflict = autoar_extractor_check_file_conflict (extracted_filename,', '      file_conflict = autoar_extractor_check_file_conflict (extracted_filename,'], 'added_lines': ['    g_autoptr (GFile) file_conflict = NULL;', '    file_conflict = autoar_extractor_check_file_conflict (self,', '                                                          extracted_filename,', '', '      /* Do not try to solve any conflicts in parents for now. Especially', '       * symlinks in parents are dangerous as it can easily happen that files', '       * are written outside of the destination. The tar cmd fails to extract', ""       * such archives with ENOTDIR. Let's do the same here. This is most"", '       * probably malicious, or corrupted archive if the conflict was caused', '       * only by files from the archive...', '       */', '      if (!g_file_equal (file_conflict, extracted_filename)) {', '        self->error = g_error_new (G_IO_ERROR,', '                                   G_IO_ERROR_NOT_DIRECTORY,', '                                   ""The file is not a directory"");', '        archive_read_free (a);', '        return;', '      }', '      g_clear_object (&file_conflict);', '      file_conflict = autoar_extractor_check_file_conflict (self,', '                                                            extracted_filename,']}",True,"autoar-extractor.c in GNOME gnome-autoar before 0.3.1, as used by GNOME Shell, Nautilus, and other software, allows Directory Traversal during extraction because it lacks a check of whether a file's parent is a symlink in certain complex situations. NOTE: this issue exists because of an incomplete fix for CVE-2020-36241.",5.5,MEDIUM,1,valid,2021-03-01T16:16:27Z,3
CVE-2021-37848,['CWE-203'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0,barebox,"password: Use crypto_memneq() to compare hashes

Cryptographic verifications should be time-constant so that an attacker
cannot get information about the secrets used by observing the system,
so use crypto_memneq() rather than memcmp() to compare password hashes.

Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>",a3337563c705bc8e0cf32f910b3e9e3c43d962ff,https://github.com/barebox/barebox/commit/a3337563c705bc8e0cf32f910b3e9e3c43d962ff,common/password.c,check_passwd,"static int check_passwd(unsigned char *passwd, size_t length)
{
struct digest *d = NULL;
unsigned char *passwd1_sum;
unsigned char *passwd2_sum;
int ret = 0;
int hash_len;
if (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {
hash_len = PBKDF2_LENGTH;
} else {
d = digest_alloc(PASSWD_SUM);
if (!d) {
pr_err(""No such digest: %s\n"",
PASSWD_SUM ? PASSWD_SUM : ""NULL"");
return -ENOENT;
}
hash_len = digest_length(d);
}
passwd1_sum = calloc(hash_len * 2, sizeof(unsigned char));
if (!passwd1_sum)
return -ENOMEM;
passwd2_sum = passwd1_sum + hash_len;
if (is_passwd_env_enable())
ret = read_env_passwd(passwd2_sum, hash_len);
else if (is_passwd_default_enable())
ret = read_default_passwd(passwd2_sum, hash_len);
else
ret = -EINVAL;
if (ret < 0)
goto err;
if (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {
char *key = passwd2_sum + PBKDF2_SALT_LEN;
char *salt = passwd2_sum;
int keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN;
ret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt,
PBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, passwd1_sum);
if (ret)
goto err;
if (strncmp(passwd1_sum, key, keylen) == 0)
ret = 1;
} else {
ret = digest_digest(d, passwd, length, passwd1_sum);
if (ret)
goto err;
if (strncmp(passwd1_sum, passwd2_sum, hash_len) == 0)
ret = 1;
}
err:
free(passwd1_sum);
digest_free(d);
return ret;
}","static int check_passwd(unsigned char *VAR_0, size_t VAR_1)
{
struct digest *VAR_2 = NULL;
unsigned char *VAR_3;
unsigned char *VAR_4;
int VAR_5 = 0;
int VAR_6;
if (IS_ENABLED(VAR_7)) {
VAR_6 = VAR_8;
} else {
VAR_2 = digest_alloc(VAR_9);
if (!VAR_2) {
pr_err(""No such digest: %s\n"",
VAR_9 ? VAR_9 : ""NULL"");
return -VAR_10;
}
VAR_6 = digest_length(VAR_2);
}
VAR_3 = calloc(VAR_6 * 2, sizeof(unsigned char));
if (!VAR_3)
return -VAR_11;
VAR_4 = VAR_3 + VAR_6;
if (is_passwd_env_enable())
VAR_5 = read_env_passwd(VAR_4, VAR_6);
else if (is_passwd_default_enable())
VAR_5 = read_default_passwd(VAR_4, VAR_6);
else
VAR_5 = -VAR_12;
if (VAR_5 < 0)
goto err;
if (IS_ENABLED(VAR_7)) {
char *VAR_13 = VAR_4 + VAR_14;
char *VAR_15 = VAR_4;
int VAR_16 = VAR_8 - VAR_14;
VAR_5 = pkcs5_pbkdf2_hmac_sha1(VAR_0, VAR_1, VAR_15,
VAR_14, VAR_17, VAR_16, VAR_3);
if (VAR_5)
goto err;
if (strncmp(VAR_3, VAR_13, VAR_16) == 0)
VAR_5 = 1;
} else {
VAR_5 = digest_digest(VAR_2, VAR_0, VAR_1, VAR_3);
if (VAR_5)
goto err;
if (strncmp(VAR_3, VAR_4, VAR_6) == 0)
VAR_5 = 1;
}
err:
free(VAR_3);
digest_free(VAR_2);
return VAR_5;
}",barebox/a3337563c705bc8e0cf32f910b3e9e3c43d962ff/password.c/vul/before/0.json,"static int check_passwd(unsigned char *passwd, size_t length)
{
	struct digest *d = NULL;
	unsigned char *passwd1_sum;
	unsigned char *passwd2_sum;
	int ret = 0;
	int hash_len;

	if (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {
		hash_len = PBKDF2_LENGTH;
	} else {
		d = digest_alloc(PASSWD_SUM);
		if (!d) {
			pr_err(""No such digest: %s\n"",
			       PASSWD_SUM ? PASSWD_SUM : ""NULL"");
			return -ENOENT;
		}

		hash_len = digest_length(d);
	}

	passwd1_sum = calloc(hash_len * 2, sizeof(unsigned char));
	if (!passwd1_sum)
		return -ENOMEM;

	passwd2_sum = passwd1_sum + hash_len;

	if (is_passwd_env_enable())
		ret = read_env_passwd(passwd2_sum, hash_len);
	else if (is_passwd_default_enable())
		ret = read_default_passwd(passwd2_sum, hash_len);
	else
		ret = -EINVAL;

	if (ret < 0)
		goto err;

	if (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {
		char *key = passwd2_sum + PBKDF2_SALT_LEN;
		char *salt = passwd2_sum;
		int keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN;

		ret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt,
			PBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, passwd1_sum);
		if (ret)
			goto err;

		if (!crypto_memneq(passwd1_sum, key, keylen))
			ret = 1;
	} else {
		ret = digest_digest(d, passwd, length, passwd1_sum);

		if (ret)
			goto err;

		if (!crypto_memneq(passwd1_sum, passwd2_sum, hash_len))
			ret = 1;
	}

err:
	free(passwd1_sum);
	digest_free(d);

	return ret;
}","static int check_passwd(unsigned char *VAR_0, size_t VAR_1)
{
	struct digest *VAR_2 = NULL;
	unsigned char *VAR_3;
	unsigned char *VAR_4;
	int VAR_5 = 0;
	int VAR_6;

	if (IS_ENABLED(VAR_7)) {
		VAR_6 = VAR_8;
	} else {
		VAR_2 = digest_alloc(VAR_9);
		if (!VAR_2) {
			pr_err(""No such digest: %s\n"",
			       VAR_9 ? VAR_9 : ""NULL"");
			return -VAR_10;
		}

		VAR_6 = digest_length(VAR_2);
	}

	VAR_3 = calloc(VAR_6 * 2, sizeof(unsigned char));
	if (!VAR_3)
		return -VAR_11;

	VAR_4 = VAR_3 + VAR_6;

	if (is_passwd_env_enable())
		VAR_5 = read_env_passwd(VAR_4, VAR_6);
	else if (is_passwd_default_enable())
		VAR_5 = read_default_passwd(VAR_4, VAR_6);
	else
		VAR_5 = -VAR_12;

	if (VAR_5 < 0)
		goto err;

	if (IS_ENABLED(VAR_7)) {
		char *VAR_13 = VAR_4 + VAR_14;
		char *VAR_15 = VAR_4;
		int VAR_16 = VAR_8 - VAR_14;

		VAR_5 = pkcs5_pbkdf2_hmac_sha1(VAR_0, VAR_1, VAR_15,
			VAR_14, VAR_17, VAR_16, VAR_3);
		if (VAR_5)
			goto err;

		if (!crypto_memneq(VAR_3, VAR_13, VAR_16))
			VAR_5 = 1;
	} else {
		VAR_5 = digest_digest(VAR_2, VAR_0, VAR_1, VAR_3);

		if (VAR_5)
			goto err;

		if (!crypto_memneq(VAR_3, VAR_4, VAR_6))
			VAR_5 = 1;
	}

err:
	free(VAR_3);
	digest_free(VAR_2);

	return VAR_5;
}",barebox/a3337563c705bc8e0cf32f910b3e9e3c43d962ff/password.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -45,7 +45,7 @@
 		if (ret)
 			goto err;
 
-		if (strncmp(passwd1_sum, key, keylen) == 0)
+		if (!crypto_memneq(passwd1_sum, key, keylen))
 			ret = 1;
 	} else {
 		ret = digest_digest(d, passwd, length, passwd1_sum);
@@ -53,7 +53,7 @@
 		if (ret)
 			goto err;
 
-		if (strncmp(passwd1_sum, passwd2_sum, hash_len) == 0)
+		if (!crypto_memneq(passwd1_sum, passwd2_sum, hash_len))
 			ret = 1;
 	}
 ","{'deleted_lines': ['\t\tif (strncmp(passwd1_sum, key, keylen) == 0)', '\t\tif (strncmp(passwd1_sum, passwd2_sum, hash_len) == 0)'], 'added_lines': ['\t\tif (!crypto_memneq(passwd1_sum, key, keylen))', '\t\tif (!crypto_memneq(passwd1_sum, passwd2_sum, hash_len))']}",True,common/password.c in Pengutronix barebox through 2021.07.0 leaks timing information because strncmp is used during hash comparison.,7.5,HIGH,2,valid,2021-03-05T09:08:04Z,3
CVE-2021-21375,['CWE-754'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,pjsip/pjproject,Merge pull request from GHSA-hvq6-f89p-frvp,97b3d7addbaa720b7ddb0af9bf6f3e443e664365,https://github.com/pjsip/pjproject/commit/97b3d7addbaa720b7ddb0af9bf6f3e443e664365,pjmedia/src/pjmedia/sdp_neg.c,pjmedia_sdp_neg_modify_local_offer2,"PJ_DEF(pj_status_t) pjmedia_sdp_neg_modify_local_offer2(
pj_pool_t *pool,
pjmedia_sdp_neg *neg,
unsigned flags,
const pjmedia_sdp_session *local)
{
pjmedia_sdp_session *new_offer;
pjmedia_sdp_session *old_offer;
char media_used[PJMEDIA_MAX_SDP_MEDIA];
unsigned oi; 
pj_status_t status;
PJ_ASSERT_RETURN(pool && neg && local, PJ_EINVAL);
PJ_ASSERT_RETURN(neg->state == PJMEDIA_SDP_NEG_STATE_DONE, 
PJMEDIA_SDPNEG_EINSTATE);
status = pjmedia_sdp_validate(local);
if (status != PJ_SUCCESS)
return status;
neg->state = PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER;
pj_bzero(media_used, sizeof(media_used));
old_offer = neg->active_local_sdp;
new_offer = pjmedia_sdp_session_clone(pool, local);
pj_strdup(pool, &new_offer->origin.user, &old_offer->origin.user);
new_offer->origin.id = old_offer->origin.id;
pj_strdup(pool, &new_offer->origin.net_type, &old_offer->origin.net_type);
pj_strdup(pool, &new_offer->origin.addr_type,&old_offer->origin.addr_type);
pj_strdup(pool, &new_offer->origin.addr, &old_offer->origin.addr);
if ((flags & PJMEDIA_SDP_NEG_ALLOW_MEDIA_CHANGE) == 0) {
for (oi = 0; oi < old_offer->media_count; ++oi) {
pjmedia_sdp_media *om;
pjmedia_sdp_media *nm;
unsigned ni; 
pj_bool_t found = PJ_FALSE;
om = old_offer->media[oi];
for (ni = oi; ni < new_offer->media_count; ++ni) {
nm = new_offer->media[ni];
if (pj_strcmp(&nm->desc.media, &om->desc.media) == 0) {
if (ni != oi) {
pj_array_insert(
new_offer->media, 
sizeof(new_offer->media[0]), 
ni, 
oi, 
&nm); 
}
found = PJ_TRUE;
break;
}
}
if (!found) {
pjmedia_sdp_media *m;
m = sdp_media_clone_deactivate(pool, om, om, local);
pj_array_insert(new_offer->media, sizeof(new_offer->media[0]),
new_offer->media_count++, oi, &m);
}
}
} else {
for (oi = new_offer->media_count; oi < old_offer->media_count; ++oi) {
pjmedia_sdp_media *m;
m = sdp_media_clone_deactivate(pool, old_offer->media[oi],
old_offer->media[oi], local);
pj_array_insert(new_offer->media, sizeof(new_offer->media[0]),
new_offer->media_count++, oi, &m);
}
}
#if PJMEDIA_SDP_NEG_COMPARE_BEFORE_INC_VERSION
new_offer->origin.version = old_offer->origin.version;
if (pjmedia_sdp_session_cmp(new_offer, neg->initial_sdp, 0) != PJ_SUCCESS)
{
++new_offer->origin.version;
}    
#else
new_offer->origin.version = old_offer->origin.version + 1;
#endif
neg->initial_sdp_tmp = neg->initial_sdp;
neg->initial_sdp = new_offer;
neg->neg_local_sdp = pjmedia_sdp_session_clone(pool, new_offer);
return PJ_SUCCESS;
}","VAR_0(pj_status_t) pjmedia_sdp_neg_modify_local_offer2(
pj_pool_t *VAR_1,
pjmedia_sdp_neg *VAR_2,
unsigned VAR_3,
const pjmedia_sdp_session *VAR_4)
{
pjmedia_sdp_session *VAR_5;
pjmedia_sdp_session *VAR_6;
char VAR_7[VAR_8];
unsigned VAR_9; 
pj_status_t VAR_10;
PJ_ASSERT_RETURN(VAR_1 && VAR_2 && VAR_4, VAR_11);
PJ_ASSERT_RETURN(VAR_2->state == VAR_12, 
VAR_13);
VAR_10 = pjmedia_sdp_validate(VAR_4);
if (VAR_10 != VAR_14)
return VAR_10;
VAR_2->state = VAR_15;
pj_bzero(VAR_7, sizeof(VAR_7));
VAR_6 = VAR_2->active_local_sdp;
VAR_5 = pjmedia_sdp_session_clone(VAR_1, VAR_4);
pj_strdup(VAR_1, &VAR_5->origin.user, &VAR_6->origin.user);
VAR_5->origin.id = VAR_6->origin.id;
pj_strdup(VAR_1, &VAR_5->origin.net_type, &VAR_6->origin.net_type);
pj_strdup(VAR_1, &VAR_5->origin.addr_type,&VAR_6->origin.addr_type);
pj_strdup(VAR_1, &VAR_5->origin.addr, &VAR_6->origin.addr);
if ((VAR_3 & VAR_16) == 0) {
for (VAR_9 = 0; VAR_9 < VAR_6->media_count; ++VAR_9) {
pjmedia_sdp_media *VAR_17;
pjmedia_sdp_media *VAR_18;
unsigned VAR_19; 
pj_bool_t VAR_20 = VAR_21;
VAR_17 = VAR_6->media[VAR_9];
for (VAR_19 = VAR_9; VAR_19 < VAR_5->media_count; ++VAR_19) {
VAR_18 = VAR_5->media[VAR_19];
if (pj_strcmp(&VAR_18->desc.media, &VAR_17->desc.media) == 0) {
if (VAR_19 != VAR_9) {
pj_array_insert(
VAR_5->media, 
sizeof(VAR_5->media[0]), 
VAR_19, 
VAR_9, 
&VAR_18); 
}
VAR_20 = VAR_22;
break;
}
}
if (!VAR_20) {
pjmedia_sdp_media *VAR_23;
VAR_23 = sdp_media_clone_deactivate(VAR_1, VAR_17, VAR_17, VAR_4);
pj_array_insert(VAR_5->media, sizeof(VAR_5->media[0]),
VAR_5->media_count++, VAR_9, &VAR_23);
}
}
} else {
for (VAR_9 = VAR_5->media_count; VAR_9 < VAR_6->media_count; ++VAR_9) {
pjmedia_sdp_media *VAR_23;
VAR_23 = sdp_media_clone_deactivate(VAR_1, VAR_6->media[VAR_9],
VAR_6->media[VAR_9], VAR_4);
pj_array_insert(VAR_5->media, sizeof(VAR_5->media[0]),
VAR_5->media_count++, VAR_9, &VAR_23);
}
}
#if VAR_24
VAR_5->origin.version = VAR_6->origin.version;
if (pjmedia_sdp_session_cmp(VAR_5, VAR_2->initial_sdp, 0) != VAR_14)
{
++VAR_5->origin.version;
}    
#else
VAR_5->origin.version = VAR_6->origin.version + 1;
#endif
VAR_2->initial_sdp_tmp = VAR_2->initial_sdp;
VAR_2->initial_sdp = VAR_5;
VAR_2->neg_local_sdp = pjmedia_sdp_session_clone(VAR_1, VAR_5);
return VAR_14;
}",,"PJ_DEF(pj_status_t) pjmedia_sdp_neg_modify_local_offer2(
                                    pj_pool_t *pool,
				    pjmedia_sdp_neg *neg,
                                    unsigned flags,
				    const pjmedia_sdp_session *local)
{
    pjmedia_sdp_session *new_offer;
    pjmedia_sdp_session *old_offer;
    unsigned oi; /* old offer media index */
    pj_status_t status;

    /* Check arguments are valid. */
    PJ_ASSERT_RETURN(pool && neg && local, PJ_EINVAL);

    /* Can only do this in STATE_DONE. */
    PJ_ASSERT_RETURN(neg->state == PJMEDIA_SDP_NEG_STATE_DONE, 
		     PJMEDIA_SDPNEG_EINSTATE);

    /* Validate the new offer */
    status = pjmedia_sdp_validate(local);
    if (status != PJ_SUCCESS)
	return status;

    /* Change state to STATE_LOCAL_OFFER */
    neg->state = PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER;

    /* When there is no active local SDP in state PJMEDIA_SDP_NEG_STATE_DONE,
     * it means that the previous initial SDP nego must have been failed,
     * so we'll just set the local SDP offer here.
     */
    if (!neg->active_local_sdp) {
	neg->initial_sdp_tmp = NULL;
	neg->initial_sdp = pjmedia_sdp_session_clone(pool, local);
	neg->neg_local_sdp = pjmedia_sdp_session_clone(pool, local);

	return PJ_SUCCESS;
    }

    /* Init vars */
    old_offer = neg->active_local_sdp;
    new_offer = pjmedia_sdp_session_clone(pool, local);

    /* RFC 3264 Section 8: When issuing an offer that modifies the session,
     * the ""o="" line of the new SDP MUST be identical to that in the
     * previous SDP, except that the version in the origin field MUST
     * increment by one from the previous SDP.
     */
    pj_strdup(pool, &new_offer->origin.user, &old_offer->origin.user);
    new_offer->origin.id = old_offer->origin.id;

    pj_strdup(pool, &new_offer->origin.net_type, &old_offer->origin.net_type);
    pj_strdup(pool, &new_offer->origin.addr_type,&old_offer->origin.addr_type);
    pj_strdup(pool, &new_offer->origin.addr, &old_offer->origin.addr);

    if ((flags & PJMEDIA_SDP_NEG_ALLOW_MEDIA_CHANGE) == 0) {
       /* Generating the new offer, in the case media lines doesn't match the
        * active SDP (e.g. current/active SDP's have m=audio and m=video lines,
        * and the new offer only has m=audio line), the negotiator will fix 
        * the new offer by reordering and adding the missing media line with 
        * port number set to zero.
        */
        for (oi = 0; oi < old_offer->media_count; ++oi) {
	    pjmedia_sdp_media *om;
	    pjmedia_sdp_media *nm;
	    unsigned ni; /* new offer media index */
	    pj_bool_t found = PJ_FALSE;

	    om = old_offer->media[oi];
	    for (ni = oi; ni < new_offer->media_count; ++ni) {
	        nm = new_offer->media[ni];
	        if (pj_strcmp(&nm->desc.media, &om->desc.media) == 0) {
		    if (ni != oi) {
		        /* The same media found but the position unmatched to
                         * the old offer, so let's put this media in the right
                         * place, and keep the order of the rest.
		         */
		        pj_array_insert(
                            new_offer->media,		 /* array    */
			    sizeof(new_offer->media[0]), /* elmt size*/
			    ni,				 /* count    */
		            oi,				 /* pos      */
			    &nm);			 /* new elmt */
		    }
		    found = PJ_TRUE;
		    break;
	        }
	    }
	    if (!found) {
	        pjmedia_sdp_media *m;

	        m = sdp_media_clone_deactivate(pool, om, om, local);

	        pj_array_insert(new_offer->media, sizeof(new_offer->media[0]),
			        new_offer->media_count++, oi, &m);
	    }
        }
    } else {
        /* If media type change is allowed, the negotiator only needs to fix 
         * the new offer by adding the missing media line(s) with port number
         * set to zero.
         */
        for (oi = new_offer->media_count; oi < old_offer->media_count; ++oi) {
            pjmedia_sdp_media *m;

	    m = sdp_media_clone_deactivate(pool, old_offer->media[oi],
                                           old_offer->media[oi], local);

	    pj_array_insert(new_offer->media, sizeof(new_offer->media[0]),
	                    new_offer->media_count++, oi, &m);

        }
    }

    /* New_offer fixed */
#if PJMEDIA_SDP_NEG_COMPARE_BEFORE_INC_VERSION
    new_offer->origin.version = old_offer->origin.version;

    if (pjmedia_sdp_session_cmp(new_offer, neg->initial_sdp, 0) != PJ_SUCCESS)
    {
	++new_offer->origin.version;
    }    
#else
    new_offer->origin.version = old_offer->origin.version + 1;
#endif
    
    neg->initial_sdp_tmp = neg->initial_sdp;
    neg->initial_sdp = new_offer;
    neg->neg_local_sdp = pjmedia_sdp_session_clone(pool, new_offer);

    return PJ_SUCCESS;
}","VAR_0(pj_status_t) pjmedia_sdp_neg_modify_local_offer2(
                                    pj_pool_t *VAR_1,
				    pjmedia_sdp_neg *VAR_2,
                                    unsigned VAR_3,
				    const pjmedia_sdp_session *VAR_4)
{
    pjmedia_sdp_session *VAR_5;
    pjmedia_sdp_session *VAR_6;
    unsigned VAR_7; /* COMMENT_0 */
    pj_status_t VAR_8;

    /* COMMENT_1 */
    PJ_ASSERT_RETURN(VAR_1 && VAR_2 && VAR_4, VAR_9);

    /* COMMENT_2 */
    PJ_ASSERT_RETURN(VAR_2->state == VAR_10, 
		     VAR_11);

    /* COMMENT_3 */
    VAR_8 = pjmedia_sdp_validate(VAR_4);
    if (VAR_8 != VAR_12)
	return VAR_8;

    /* COMMENT_4 */
    VAR_2->state = VAR_13;

    /* COMMENT_5 */
                                                                         
                                                  
       
    if (!VAR_2->active_local_sdp) {
	VAR_2->initial_sdp_tmp = NULL;
	VAR_2->initial_sdp = pjmedia_sdp_session_clone(VAR_1, VAR_4);
	VAR_2->neg_local_sdp = pjmedia_sdp_session_clone(VAR_1, VAR_4);

	return VAR_12;
    }

    /* COMMENT_9 */
    VAR_6 = VAR_2->active_local_sdp;
    VAR_5 = pjmedia_sdp_session_clone(VAR_1, VAR_4);

    /* COMMENT_10 */
                                                                    
                                                                     
                                              
       
    pj_strdup(VAR_1, &VAR_5->origin.user, &VAR_6->origin.user);
    VAR_5->origin.id = VAR_6->origin.id;

    pj_strdup(VAR_1, &VAR_5->origin.net_type, &VAR_6->origin.net_type);
    pj_strdup(VAR_1, &VAR_5->origin.addr_type,&VAR_6->origin.addr_type);
    pj_strdup(VAR_1, &VAR_5->origin.addr, &VAR_6->origin.addr);

    if ((VAR_3 & VAR_14) == 0) {
       /* COMMENT_15 */
                                                                               
                                                                            
                                                                             
                                  
          
        for (VAR_7 = 0; VAR_7 < VAR_6->media_count; ++VAR_7) {
	    pjmedia_sdp_media *VAR_15;
	    pjmedia_sdp_media *VAR_16;
	    unsigned VAR_17; /* COMMENT_21 */
	    pj_bool_t VAR_18 = VAR_19;

	    VAR_15 = VAR_6->media[VAR_7];
	    for (VAR_17 = VAR_7; VAR_17 < VAR_5->media_count; ++VAR_17) {
	        VAR_16 = VAR_5->media[VAR_17];
	        if (pj_strcmp(&VAR_16->desc.media, &VAR_15->desc.media) == 0) {
		    if (VAR_17 != VAR_7) {
		        /* COMMENT_22 */
                                                                              
                                                                 
             
		        pj_array_insert(
                            VAR_5->media,		 /* COMMENT_26 */
			    sizeof(VAR_5->media[0]), /* COMMENT_27 */
			    VAR_17,				 /* COMMENT_28 */
		            VAR_7,				 /* COMMENT_29 */
			    &VAR_16);			 /* COMMENT_30 */
		    }
		    VAR_18 = VAR_20;
		    break;
	        }
	    }
	    if (!VAR_18) {
	        pjmedia_sdp_media *VAR_21;

	        VAR_21 = sdp_media_clone_deactivate(VAR_1, VAR_15, VAR_15, VAR_4);

	        pj_array_insert(VAR_5->media, sizeof(VAR_5->media[0]),
			        VAR_5->media_count++, VAR_7, &VAR_21);
	    }
        }
    } else {
        /* COMMENT_31 */
                                                                             
                       
           
        for (VAR_7 = VAR_5->media_count; VAR_7 < VAR_6->media_count; ++VAR_7) {
            pjmedia_sdp_media *VAR_21;

	    VAR_21 = sdp_media_clone_deactivate(VAR_1, VAR_6->media[VAR_7],
                                           VAR_6->media[VAR_7], VAR_4);

	    pj_array_insert(VAR_5->media, sizeof(VAR_5->media[0]),
	                    VAR_5->media_count++, VAR_7, &VAR_21);

        }
    }

    /* COMMENT_35 */
#if VAR_22
    VAR_5->origin.version = VAR_6->origin.version;

    if (pjmedia_sdp_session_cmp(VAR_5, VAR_2->initial_sdp, 0) != VAR_12)
    {
	++VAR_5->origin.version;
    }    
#else
    VAR_5->origin.version = VAR_6->origin.version + 1;
#endif
    
    VAR_2->initial_sdp_tmp = VAR_2->initial_sdp;
    VAR_2->initial_sdp = VAR_5;
    VAR_2->neg_local_sdp = pjmedia_sdp_session_clone(VAR_1, VAR_5);

    return VAR_12;
}",,"--- func_before
+++ func_after
@@ -6,7 +6,6 @@
 {
     pjmedia_sdp_session *new_offer;
     pjmedia_sdp_session *old_offer;
-    char media_used[PJMEDIA_MAX_SDP_MEDIA];
     unsigned oi; /* old offer media index */
     pj_status_t status;
 
@@ -25,8 +24,19 @@
     /* Change state to STATE_LOCAL_OFFER */
     neg->state = PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER;
 
+    /* When there is no active local SDP in state PJMEDIA_SDP_NEG_STATE_DONE,
+     * it means that the previous initial SDP nego must have been failed,
+     * so we'll just set the local SDP offer here.
+     */
+    if (!neg->active_local_sdp) {
+	neg->initial_sdp_tmp = NULL;
+	neg->initial_sdp = pjmedia_sdp_session_clone(pool, local);
+	neg->neg_local_sdp = pjmedia_sdp_session_clone(pool, local);
+
+	return PJ_SUCCESS;
+    }
+
     /* Init vars */
-    pj_bzero(media_used, sizeof(media_used));
     old_offer = neg->active_local_sdp;
     new_offer = pjmedia_sdp_session_clone(pool, local);
 ","{'deleted_lines': ['    char media_used[PJMEDIA_MAX_SDP_MEDIA];', '    pj_bzero(media_used, sizeof(media_used));'], 'added_lines': ['    /* When there is no active local SDP in state PJMEDIA_SDP_NEG_STATE_DONE,', '     * it means that the previous initial SDP nego must have been failed,', ""     * so we'll just set the local SDP offer here."", '     */', '    if (!neg->active_local_sdp) {', '\tneg->initial_sdp_tmp = NULL;', '\tneg->initial_sdp = pjmedia_sdp_session_clone(pool, local);', '\tneg->neg_local_sdp = pjmedia_sdp_session_clone(pool, local);', '', '\treturn PJ_SUCCESS;', '    }', '']}",True,"PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In PJSIP version 2.10 and earlier, after an initial INVITE has been sent, when two 183 responses are received, with the first one causing negotiation failure, a crash will occur. This results in a denial of service.",6.5,MEDIUM,1,valid,2021-03-08T09:09:34Z,3
CVE-2020-15260,['CWE-295'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,pjsip/pjproject,"Merge pull request from GHSA-8hcp-hm38-mfph

* Check hostname during TLS transport selection

* revision based on feedback

* remove the code in create_request that has been moved",67e46c1ac45ad784db5b9080f5ed8b133c122872,https://github.com/pjsip/pjproject/commit/67e46c1ac45ad784db5b9080f5ed8b133c122872,pjsip/src/pjsip/sip_util.c,pjsip_endpt_send_request_stateless,"PJ_DEF(pj_status_t) pjsip_endpt_send_request_stateless(pjsip_endpoint *endpt, 
pjsip_tx_data *tdata,
void *token,
pjsip_send_callback cb)
{
pjsip_host_info dest_info;
pjsip_send_state *stateless_data;
pj_status_t status;
PJ_ASSERT_RETURN(endpt && tdata, PJ_EINVAL);
status = pjsip_process_route_set(tdata, &dest_info);
if (status != PJ_SUCCESS)
return status;
stateless_data = PJ_POOL_ZALLOC_T(tdata->pool, pjsip_send_state);
stateless_data->token = token;
stateless_data->endpt = endpt;
stateless_data->tdata = tdata;
stateless_data->app_cb = cb;
if (tdata->dest_info.addr.count == 0) {
pj_strdup(tdata->pool, &tdata->dest_info.name, &dest_info.addr.host);
pjsip_endpt_resolve( endpt, tdata->pool, &dest_info, stateless_data,
&stateless_send_resolver_callback);
} else {
PJ_LOG(5,(THIS_FILE, ""%s: skipping target resolution because ""
""address is already set"",
pjsip_tx_data_get_info(tdata)));
stateless_send_resolver_callback(PJ_SUCCESS, stateless_data,
&tdata->dest_info.addr);
}
return PJ_SUCCESS;
}","VAR_0(pj_status_t) pjsip_endpt_send_request_stateless(pjsip_endpoint *VAR_1, 
pjsip_tx_data *VAR_2,
void *VAR_3,
pjsip_send_callback VAR_4)
{
pjsip_host_info VAR_5;
pjsip_send_state *VAR_6;
pj_status_t VAR_7;
PJ_ASSERT_RETURN(VAR_1 && VAR_2, VAR_8);
VAR_7 = pjsip_process_route_set(VAR_2, &VAR_5);
if (VAR_7 != VAR_9)
return VAR_7;
VAR_6 = PJ_POOL_ZALLOC_T(VAR_2->pool, pjsip_send_state);
VAR_6->token = VAR_3;
VAR_6->endpt = VAR_1;
VAR_6->tdata = VAR_2;
VAR_6->app_cb = VAR_4;
if (VAR_2->dest_info.addr.count == 0) {
pj_strdup(VAR_2->pool, &VAR_2->dest_info.name, &VAR_5.addr.host);
pjsip_endpt_resolve( VAR_1, VAR_2->pool, &VAR_5, VAR_6,
&VAR_10);
} else {
PJ_LOG(5,(VAR_11, ""%s: skipping target resolution because ""
""address is already set"",
pjsip_tx_data_get_info(VAR_2)));
VAR_10(VAR_9, VAR_6,
&VAR_2->dest_info.addr);
}
return VAR_9;
}",,"PJ_DEF(pj_status_t) pjsip_endpt_send_request_stateless(pjsip_endpoint *endpt, 
				   pjsip_tx_data *tdata,
				   void *token,
				   pjsip_send_callback cb)
{
    pjsip_host_info dest_info;
    pjsip_send_state *stateless_data;
    pj_status_t status;

    PJ_ASSERT_RETURN(endpt && tdata, PJ_EINVAL);

    /* Get destination name to contact. */
    status = pjsip_process_route_set(tdata, &dest_info);
    if (status != PJ_SUCCESS)
	return status;

    /* Keep stateless data. */
    stateless_data = PJ_POOL_ZALLOC_T(tdata->pool, pjsip_send_state);
    stateless_data->token = token;
    stateless_data->endpt = endpt;
    stateless_data->tdata = tdata;
    stateless_data->app_cb = cb;

    /* If destination info has not been initialized (this applies for most
     * all requests except CANCEL), resolve destination host. The processing
     * then resumed when the resolving callback is called. For CANCEL, the
     * destination info must have been copied from the original INVITE so
     * proceed to sending the request directly.
     */
    if (tdata->dest_info.addr.count == 0) {
	/* Copy the destination host name to TX data */
	if (!tdata->dest_info.name.slen) {
	    pj_strdup(tdata->pool, &tdata->dest_info.name,
	    	      &dest_info.addr.host);
	}

	pjsip_endpt_resolve( endpt, tdata->pool, &dest_info, stateless_data,
			     &stateless_send_resolver_callback);
    } else {
	PJ_LOG(5,(THIS_FILE, ""%s: skipping target resolution because ""
	                     ""address is already set"",
			     pjsip_tx_data_get_info(tdata)));
	stateless_send_resolver_callback(PJ_SUCCESS, stateless_data,
					 &tdata->dest_info.addr);
    }
    return PJ_SUCCESS;
}","VAR_0(pj_status_t) pjsip_endpt_send_request_stateless(pjsip_endpoint *VAR_1, 
				   pjsip_tx_data *VAR_2,
				   void *VAR_3,
				   pjsip_send_callback VAR_4)
{
    pjsip_host_info VAR_5;
    pjsip_send_state *VAR_6;
    pj_status_t VAR_7;

    PJ_ASSERT_RETURN(VAR_1 && VAR_2, VAR_8);

    /* COMMENT_0 */
    VAR_7 = pjsip_process_route_set(VAR_2, &VAR_5);
    if (VAR_7 != VAR_9)
	return VAR_7;

    /* COMMENT_1 */
    VAR_6 = PJ_POOL_ZALLOC_T(VAR_2->pool, pjsip_send_state);
    VAR_6->token = VAR_3;
    VAR_6->endpt = VAR_1;
    VAR_6->tdata = VAR_2;
    VAR_6->app_cb = VAR_4;

    /* COMMENT_2 */
                                                                            
                                                                          
                                                                         
                                               
       
    if (VAR_2->dest_info.addr.count == 0) {
	/* COMMENT_8 */
	if (!VAR_2->dest_info.name.slen) {
	    pj_strdup(VAR_2->pool, &VAR_2->dest_info.name,
	    	      &VAR_5.addr.host);
	}

	pjsip_endpt_resolve( VAR_1, VAR_2->pool, &VAR_5, VAR_6,
			     &VAR_10);
    } else {
	PJ_LOG(5,(VAR_11, ""%s: skipping target resolution because ""
	                     ""address is already set"",
			     pjsip_tx_data_get_info(VAR_2)));
	VAR_10(VAR_9, VAR_6,
					 &VAR_2->dest_info.addr);
    }
    return VAR_9;
}",,"--- func_before
+++ func_after
@@ -29,7 +29,10 @@
      */
     if (tdata->dest_info.addr.count == 0) {
 	/* Copy the destination host name to TX data */
-	pj_strdup(tdata->pool, &tdata->dest_info.name, &dest_info.addr.host);
+	if (!tdata->dest_info.name.slen) {
+	    pj_strdup(tdata->pool, &tdata->dest_info.name,
+	    	      &dest_info.addr.host);
+	}
 
 	pjsip_endpt_resolve( endpt, tdata->pool, &dest_info, stateless_data,
 			     &stateless_send_resolver_callback);","{'deleted_lines': ['\tpj_strdup(tdata->pool, &tdata->dest_info.name, &dest_info.addr.host);'], 'added_lines': ['\tif (!tdata->dest_info.name.slen) {', '\t    pj_strdup(tdata->pool, &tdata->dest_info.name,', '\t    \t      &dest_info.addr.host);', '\t}']}",True,"PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In version 2.10 and earlier, PJSIP transport can be reused if they have the same IP address + port + protocol. However, this is insufficient for secure transport since it lacks remote hostname authentication. Suppose we have created a TLS connection to `sip.foo.com`, which has an IP address `100.1.1.1`. If we want to create a TLS connection to another hostname, say `sip.bar.com`, which has the same IP address, then it will reuse that existing connection, even though `100.1.1.1` does not have certificate to authenticate as `sip.bar.com`. The vulnerability allows for an insecure interaction without user awareness. It affects users who need access to connections to different destinations that translate to the same address, and allows man-in-the-middle attack if attacker can route a connection to another destination such as in the case of DNS spoofing.",6.8,MEDIUM,1,valid,2021-03-08T09:39:36Z,3
CVE-2020-15260,['CWE-295'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,pjsip/pjproject,"Merge pull request from GHSA-8hcp-hm38-mfph

* Check hostname during TLS transport selection

* revision based on feedback

* remove the code in create_request that has been moved",67e46c1ac45ad784db5b9080f5ed8b133c122872,https://github.com/pjsip/pjproject/commit/67e46c1ac45ad784db5b9080f5ed8b133c122872,pjsip/src/pjsip/sip_transport.c,pjsip_tpmgr_acquire_transport2,"PJ_DEF(pj_status_t) pjsip_tpmgr_acquire_transport2(pjsip_tpmgr *mgr,
pjsip_transport_type_e type,
const pj_sockaddr_t *remote,
int addr_len,
const pjsip_tpselector *sel,
pjsip_tx_data *tdata,
pjsip_transport **tp)
{
pjsip_tpfactory *factory;
pj_status_t status;
TRACE_((THIS_FILE,""Acquiring transport type=%s, sel=%s remote=%s:%d"",
pjsip_transport_get_type_name(type),
print_tpsel_info(sel),
addr_string(remote),
pj_sockaddr_get_port(remote)));
pj_lock_acquire(mgr->lock);
if (sel && sel->type == PJSIP_TPSELECTOR_TRANSPORT &&
sel->u.transport) 
{
pjsip_transport *seltp = sel->u.transport;
if (seltp->key.type != type) {
pj_lock_release(mgr->lock);
TRACE_((THIS_FILE, ""Transport type in tpsel not matched""));
return PJSIP_ETPNOTSUITABLE;
}
if (seltp->is_destroying) {
pj_lock_release(mgr->lock);
TRACE_((THIS_FILE,""Transport to be acquired is being destroyed""));
return PJ_ENOTFOUND;
}
pjsip_transport_add_ref(seltp);
pj_lock_release(mgr->lock);
*tp = seltp;
TRACE_((THIS_FILE, ""Transport %s acquired"", seltp->obj_name));
return PJ_SUCCESS;
} else {
pjsip_transport_key key;
int key_len;
pjsip_transport *tp_ref = NULL;
transport *tp_entry = NULL;
if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener)
{
if (sel->u.listener->type != type) {
pj_lock_release(mgr->lock);
TRACE_((THIS_FILE, ""Listener type in tpsel not matched""));
return PJSIP_ETPNOTSUITABLE;
}
}
if (!sel || sel->disable_connection_reuse == PJ_FALSE) {
pj_bzero(&key, sizeof(key));
key_len = sizeof(key.type) + addr_len;
key.type = type;
pj_memcpy(&key.rem_addr, remote, addr_len);
tp_entry = (transport *)pj_hash_get(mgr->table, &key, key_len,
NULL);
if (tp_entry) {
transport *tp_iter = tp_entry;
do {
if (!tp_iter->tp->is_shutdown &&
!tp_iter->tp->is_destroying)
{
if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER &&
sel->u.listener)
{
if (tp_iter->tp->factory == sel->u.listener) {
tp_ref = tp_iter->tp;
break;
}
} else {
tp_ref = tp_iter->tp;
break;
}
}
tp_iter = tp_iter->next;
} while (tp_iter != tp_entry);
}
}
if (tp_ref == NULL &&
(!sel || sel->disable_connection_reuse == PJ_FALSE))
{
unsigned flag = pjsip_transport_get_flag_from_type(type);
const pj_sockaddr *remote_addr = (const pj_sockaddr*)remote;
if (type == PJSIP_TRANSPORT_LOOP ||
type == PJSIP_TRANSPORT_LOOP_DGRAM)
{
pj_sockaddr *addr = &key.rem_addr;
pj_bzero(addr, addr_len);
key_len = sizeof(key.type) + addr_len;
tp_entry = (transport *) pj_hash_get(mgr->table, &key,
key_len, NULL);
if (tp_entry) {
tp_ref = tp_entry->tp;
}
}
else if (flag & PJSIP_TRANSPORT_DATAGRAM)
{
pj_sockaddr *addr = &key.rem_addr;
pj_bzero(addr, addr_len);
addr->addr.sa_family = remote_addr->addr.sa_family;
key_len = sizeof(key.type) + addr_len;
tp_entry = (transport *) pj_hash_get(mgr->table, &key,
key_len, NULL);
if (tp_entry) {
tp_ref = tp_entry->tp;
}
}
}
else if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER &&
sel->u.listener && tp_ref->factory != sel->u.listener)
{
tp_ref = NULL;
TRACE_((THIS_FILE, ""Transport found but from different listener""));
}
if (tp_ref!=NULL && !tp_ref->is_shutdown && !tp_ref->is_destroying) {
pjsip_transport_add_ref(tp_ref);
pj_lock_release(mgr->lock);
*tp = tp_ref;
TRACE_((THIS_FILE, ""Transport %s acquired"", tp_ref->obj_name));
return PJ_SUCCESS;
}
if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener)
{
factory = sel->u.listener;
if (!pjsip_tpmgr_is_tpfactory_valid(mgr, factory)) {
pj_lock_release(mgr->lock);
PJ_LOG(3,(THIS_FILE, ""Specified factory for creating ""
""transport is not found""));
return PJ_ENOTFOUND;
}
} else {
factory = mgr->factory_list.next;
while (factory != &mgr->factory_list) {
if (factory->type == type)
break;
factory = factory->next;
}
if (factory == &mgr->factory_list) {
pj_lock_release(mgr->lock);
TRACE_((THIS_FILE, ""No suitable factory was found either""));
return PJSIP_EUNSUPTRANSPORT;
}
}
}
TRACE_((THIS_FILE, ""Creating new transport from factory""));
if (factory->create_transport2) {
status = factory->create_transport2(factory, mgr, mgr->endpt,
(const pj_sockaddr*) remote,
addr_len, tdata, tp);
} else {
status = factory->create_transport(factory, mgr, mgr->endpt,
(const pj_sockaddr*) remote,
addr_len, tp);
}
if (status == PJ_SUCCESS) {
PJ_ASSERT_ON_FAIL(tp!=NULL,
{pj_lock_release(mgr->lock); return PJ_EBUG;});
pjsip_transport_add_ref(*tp);
(*tp)->factory = factory;
}","VAR_0(pj_status_t) pjsip_tpmgr_acquire_transport2(pjsip_tpmgr *VAR_1,
pjsip_transport_type_e VAR_2,
const pj_sockaddr_t *VAR_3,
int VAR_4,
const pjsip_tpselector *VAR_5,
pjsip_tx_data *VAR_6,
pjsip_transport **VAR_7)
{
pjsip_tpfactory *VAR_8;
pj_status_t VAR_9;
TRACE_((VAR_10,""Acquiring transport type=%s, sel=%s remote=%s:%d"",
pjsip_transport_get_type_name(VAR_2),
print_tpsel_info(VAR_5),
addr_string(VAR_3),
pj_sockaddr_get_port(VAR_3)));
pj_lock_acquire(VAR_1->lock);
if (VAR_5 && VAR_5->type == VAR_11 &&
VAR_5->u.transport) 
{
pjsip_transport *VAR_12 = VAR_5->u.transport;
if (VAR_12->key.type != VAR_2) {
pj_lock_release(VAR_1->lock);
TRACE_((VAR_10, ""Transport type in tpsel not matched""));
return VAR_13;
}
if (VAR_12->is_destroying) {
pj_lock_release(VAR_1->lock);
TRACE_((VAR_10,""Transport to be acquired is being destroyed""));
return VAR_14;
}
pjsip_transport_add_ref(VAR_12);
pj_lock_release(VAR_1->lock);
*VAR_7 = VAR_12;
TRACE_((VAR_10, ""Transport %s acquired"", VAR_12->obj_name));
return VAR_15;
} else {
pjsip_transport_key VAR_16;
int VAR_17;
pjsip_transport *VAR_18 = NULL;
transport *VAR_19 = NULL;
if (VAR_5 && VAR_5->type == VAR_20 && VAR_5->u.listener)
{
if (VAR_5->u.listener->type != VAR_2) {
pj_lock_release(VAR_1->lock);
TRACE_((VAR_10, ""Listener type in tpsel not matched""));
return VAR_13;
}
}
if (!VAR_5 || VAR_5->disable_connection_reuse == VAR_21) {
pj_bzero(&VAR_16, sizeof(VAR_16));
VAR_17 = sizeof(VAR_16.type) + VAR_4;
VAR_16.type = VAR_2;
pj_memcpy(&VAR_16.rem_addr, VAR_3, VAR_4);
VAR_19 = (transport *)pj_hash_get(VAR_1->table, &VAR_16, VAR_17,
NULL);
if (VAR_19) {
transport *VAR_22 = VAR_19;
do {
if (!VAR_22->tp->is_shutdown &&
!VAR_22->tp->is_destroying)
{
if (VAR_5 && VAR_5->type == VAR_20 &&
VAR_5->u.listener)
{
if (VAR_22->tp->factory == VAR_5->u.listener) {
VAR_18 = VAR_22->tp;
break;
}
} else {
VAR_18 = VAR_22->tp;
break;
}
}
VAR_22 = VAR_22->next;
} while (VAR_22 != VAR_19);
}
}
if (VAR_18 == NULL &&
(!VAR_5 || VAR_5->disable_connection_reuse == VAR_21))
{
unsigned VAR_23 = pjsip_transport_get_flag_from_type(VAR_2);
const pj_sockaddr *VAR_24 = (const pj_sockaddr*)VAR_3;
if (VAR_2 == VAR_25 ||
VAR_2 == VAR_26)
{
pj_sockaddr *VAR_27 = &VAR_16.rem_addr;
pj_bzero(VAR_27, VAR_4);
VAR_17 = sizeof(VAR_16.type) + VAR_4;
VAR_19 = (transport *) pj_hash_get(VAR_1->table, &VAR_16,
VAR_17, NULL);
if (VAR_19) {
VAR_18 = VAR_19->tp;
}
}
else if (VAR_23 & VAR_28)
{
pj_sockaddr *VAR_27 = &VAR_16.rem_addr;
pj_bzero(VAR_27, VAR_4);
VAR_27->addr.sa_family = VAR_24->addr.sa_family;
VAR_17 = sizeof(VAR_16.type) + VAR_4;
VAR_19 = (transport *) pj_hash_get(VAR_1->table, &VAR_16,
VAR_17, NULL);
if (VAR_19) {
VAR_18 = VAR_19->tp;
}
}
}
else if (VAR_5 && VAR_5->type == VAR_20 &&
VAR_5->u.listener && VAR_18->factory != VAR_5->u.listener)
{
VAR_18 = NULL;
TRACE_((VAR_10, ""Transport found but from different listener""));
}
if (VAR_18!=NULL && !VAR_18->is_shutdown && !VAR_18->is_destroying) {
pjsip_transport_add_ref(VAR_18);
pj_lock_release(VAR_1->lock);
*VAR_7 = VAR_18;
TRACE_((VAR_10, ""Transport %s acquired"", VAR_18->obj_name));
return VAR_15;
}
if (VAR_5 && VAR_5->type == VAR_20 && VAR_5->u.listener)
{
VAR_8 = VAR_5->u.listener;
if (!pjsip_tpmgr_is_tpfactory_valid(VAR_1, VAR_8)) {
pj_lock_release(VAR_1->lock);
PJ_LOG(3,(VAR_10, ""Specified factory for creating ""
""transport is not found""));
return VAR_14;
}
} else {
VAR_8 = VAR_1->factory_list.next;
while (VAR_8 != &VAR_1->factory_list) {
if (VAR_8->type == VAR_2)
break;
VAR_8 = VAR_8->next;
}
if (VAR_8 == &VAR_1->factory_list) {
pj_lock_release(VAR_1->lock);
TRACE_((VAR_10, ""No suitable factory was found either""));
return VAR_29;
}
}
}
TRACE_((VAR_10, ""Creating new transport from factory""));
if (VAR_8->create_transport2) {
VAR_9 = VAR_8->create_transport2(VAR_8, VAR_1, VAR_1->endpt,
(const pj_sockaddr*) VAR_3,
VAR_4, VAR_6, VAR_7);
} else {
VAR_9 = VAR_8->create_transport(VAR_8, VAR_1, VAR_1->endpt,
(const pj_sockaddr*) VAR_3,
VAR_4, VAR_7);
}
if (VAR_9 == VAR_15) {
PJ_ASSERT_ON_FAIL(VAR_7!=NULL,
{pj_lock_release(VAR_1->lock); return VAR_30;});
pjsip_transport_add_ref(*VAR_7);
(*VAR_7)->factory = VAR_8;
}",,"PJ_DEF(pj_status_t) pjsip_tpmgr_acquire_transport2(pjsip_tpmgr *mgr,
						   pjsip_transport_type_e type,
						   const pj_sockaddr_t *remote,
						   int addr_len,
						   const pjsip_tpselector *sel,
						   pjsip_tx_data *tdata,
						   pjsip_transport **tp)
{
    pjsip_tpfactory *factory;
    pj_status_t status;

    TRACE_((THIS_FILE,""Acquiring transport type=%s, sel=%s remote=%s:%d"",
		       pjsip_transport_get_type_name(type),
		       print_tpsel_info(sel),
		       addr_string(remote),
		       pj_sockaddr_get_port(remote)));

    pj_lock_acquire(mgr->lock);

    /* If transport is specified, then just use it if it is suitable
     * for the destination.
     */
    if (sel && sel->type == PJSIP_TPSELECTOR_TRANSPORT &&
	sel->u.transport) 
    {
	pjsip_transport *seltp = sel->u.transport;

	/* See if the transport is (not) suitable */
	if (seltp->key.type != type) {
	    pj_lock_release(mgr->lock);
	    TRACE_((THIS_FILE, ""Transport type in tpsel not matched""));
	    return PJSIP_ETPNOTSUITABLE;
	}

	/* Make sure the transport is not being destroyed */
	if (seltp->is_destroying) {
	    pj_lock_release(mgr->lock);
	    TRACE_((THIS_FILE,""Transport to be acquired is being destroyed""));
	    return PJ_ENOTFOUND;
	}

	/* We could also verify that the destination address is reachable
	 * from this transport (i.e. both are equal), but if application
	 * has requested a specific transport to be used, assume that
	 * it knows what to do.
	 *
	 * In other words, I don't think destination verification is a good
	 * idea for now.
	 */

	/* Transport looks to be suitable to use, so just use it. */
	pjsip_transport_add_ref(seltp);
	pj_lock_release(mgr->lock);
	*tp = seltp;

	TRACE_((THIS_FILE, ""Transport %s acquired"", seltp->obj_name));
	return PJ_SUCCESS;

    } else {

	/*
	 * This is the ""normal"" flow, where application doesn't specify
	 * specific transport to be used to send message to.
	 * In this case, lookup the transport from the hash table.
	 */
	pjsip_transport_key key;
	int key_len;
	pjsip_transport *tp_ref = NULL;
	transport *tp_entry = NULL;


	/* If listener is specified, verify that the listener type matches
	 * the destination type.
	 */
	if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener)
	{
	    if (sel->u.listener->type != type) {
		pj_lock_release(mgr->lock);
		TRACE_((THIS_FILE, ""Listener type in tpsel not matched""));
		return PJSIP_ETPNOTSUITABLE;
	    }
	}

	if (!sel || sel->disable_connection_reuse == PJ_FALSE) {
	    pj_bzero(&key, sizeof(key));
	    key_len = sizeof(key.type) + addr_len;

	    /* First try to get exact destination. */
	    key.type = type;
	    pj_memcpy(&key.rem_addr, remote, addr_len);

	    tp_entry = (transport *)pj_hash_get(mgr->table, &key, key_len,
						NULL);
	    if (tp_entry) {
		transport *tp_iter = tp_entry;
		do {
		    /* Don't use transport being shutdown/destroyed */
		    if (!tp_iter->tp->is_shutdown &&
			!tp_iter->tp->is_destroying)
		    {
			if ((type & PJSIP_TRANSPORT_SECURE) && tdata) {
			    /* For secure transport, make sure tdata's
			     * destination host matches the transport's
			     * remote host.
			     */
			    if (pj_stricmp(&tdata->dest_info.name,
				  	   &tp_iter->tp->remote_name.host))
			    {
			    	tp_iter = tp_iter->next;
			    	continue;
			    }
			}

			if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER &&
			    sel->u.listener)
			{
			    /* Match listener if selector is set */
			    if (tp_iter->tp->factory == sel->u.listener) {
				tp_ref = tp_iter->tp;
				break;
			    }
			} else {
			    tp_ref = tp_iter->tp;
			    break;
			}
		    }
		    tp_iter = tp_iter->next;
		} while (tp_iter != tp_entry);
	    }
	}

	if (tp_ref == NULL &&
	    (!sel || sel->disable_connection_reuse == PJ_FALSE))
	{
	    unsigned flag = pjsip_transport_get_flag_from_type(type);
	    const pj_sockaddr *remote_addr = (const pj_sockaddr*)remote;


	    /* Ignore address for loop transports. */
	    if (type == PJSIP_TRANSPORT_LOOP ||
		type == PJSIP_TRANSPORT_LOOP_DGRAM)
	    {
		pj_sockaddr *addr = &key.rem_addr;

		pj_bzero(addr, addr_len);
		key_len = sizeof(key.type) + addr_len;
		tp_entry = (transport *) pj_hash_get(mgr->table, &key,
						     key_len, NULL);
		if (tp_entry) {
		    tp_ref = tp_entry->tp;
		}
	    }
	    /* For datagram transports, try lookup with zero address.
	     */
	    else if (flag & PJSIP_TRANSPORT_DATAGRAM)
	    {
		pj_sockaddr *addr = &key.rem_addr;

		pj_bzero(addr, addr_len);
		addr->addr.sa_family = remote_addr->addr.sa_family;

		key_len = sizeof(key.type) + addr_len;
		tp_entry = (transport *) pj_hash_get(mgr->table, &key,
						     key_len, NULL);
		if (tp_entry) {
		    tp_ref = tp_entry->tp;
		}
	    }
	}

	/* If transport is found and listener is specified, verify listener */
	else if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER &&
		 sel->u.listener && tp_ref->factory != sel->u.listener)
	{
	    tp_ref = NULL;
	    /* This will cause a new transport to be created which will be a
	     * 'duplicate' of the existing transport (same type & remote addr,
	     * but different factory).
	     */
	    TRACE_((THIS_FILE, ""Transport found but from different listener""));
	}

	if (tp_ref!=NULL && !tp_ref->is_shutdown && !tp_ref->is_destroying) {
	    /*
	     * Transport found!
	     */
	    pjsip_transport_add_ref(tp_ref);
	    pj_lock_release(mgr->lock);
	    *tp = tp_ref;

	    TRACE_((THIS_FILE, ""Transport %s acquired"", tp_ref->obj_name));
	    return PJ_SUCCESS;
	}


	/*
	 * Either transport not found, or we don't want to use the existing
	 * transport (such as in the case of different factory or
	 * if connection reuse is disabled). So we need to create one,
	 * find factory that can create such transport.
	 *
	 * If there's an existing transport, its place in the hash table
	 * will be replaced by this new one. And eventually the existing
	 * transport will still be freed (by application or #1774).
	 */
	if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener)
	{
	    /* Application has requested that a specific listener is to
	     * be used.
	     */

	    /* Verify that the listener type matches the destination type */
	    /* Already checked above. */
	    /*
	    if (sel->u.listener->type != type) {
		pj_lock_release(mgr->lock);
		return PJSIP_ETPNOTSUITABLE;
	    }
	    */

	    /* We'll use this listener to create transport */
	    factory = sel->u.listener;

	    /* Verify if listener is still valid */
	    if (!pjsip_tpmgr_is_tpfactory_valid(mgr, factory)) {
		pj_lock_release(mgr->lock);
		PJ_LOG(3,(THIS_FILE, ""Specified factory for creating ""
				     ""transport is not found""));
		return PJ_ENOTFOUND;
	    }

	} else {

	    /* Find factory with type matches the destination type */
	    factory = mgr->factory_list.next;
	    while (factory != &mgr->factory_list) {
		if (factory->type == type)
		    break;
		factory = factory->next;
	    }

	    if (factory == &mgr->factory_list) {
		/* No factory can create the transport! */
		pj_lock_release(mgr->lock);
		TRACE_((THIS_FILE, ""No suitable factory was found either""));
		return PJSIP_EUNSUPTRANSPORT;
	    }
	}
    }

    TRACE_((THIS_FILE, ""Creating new transport from factory""));

    /* Request factory to create transport. */
    if (factory->create_transport2) {
	status = factory->create_transport2(factory, mgr, mgr->endpt,
					    (const pj_sockaddr*) remote,
					    addr_len, tdata, tp);
    } else {
	status = factory->create_transport(factory, mgr, mgr->endpt,
					   (const pj_sockaddr*) remote,
					   addr_len, tp);
    }
    if (status == PJ_SUCCESS) {
	PJ_ASSERT_ON_FAIL(tp!=NULL,
	    {pj_lock_release(mgr->lock); return PJ_EBUG;});
	pjsip_transport_add_ref(*tp);
	(*tp)->factory = factory;
    }","VAR_0(pj_status_t) pjsip_tpmgr_acquire_transport2(pjsip_tpmgr *VAR_1,
						   pjsip_transport_type_e VAR_2,
						   const pj_sockaddr_t *VAR_3,
						   int VAR_4,
						   const pjsip_tpselector *VAR_5,
						   pjsip_tx_data *VAR_6,
						   pjsip_transport **VAR_7)
{
    pjsip_tpfactory *VAR_8;
    pj_status_t VAR_9;

    TRACE_((VAR_10,""Acquiring transport type=%s, sel=%s remote=%s:%d"",
		       pjsip_transport_get_type_name(VAR_2),
		       print_tpsel_info(VAR_5),
		       addr_string(VAR_3),
		       pj_sockaddr_get_port(VAR_3)));

    pj_lock_acquire(VAR_1->lock);

    /* COMMENT_0 */
                           
       
    if (VAR_5 && VAR_5->type == VAR_11 &&
	VAR_5->u.transport) 
    {
	pjsip_transport *VAR_12 = VAR_5->u.transport;

	/* COMMENT_3 */
	if (VAR_12->key.type != VAR_2) {
	    pj_lock_release(VAR_1->lock);
	    TRACE_((VAR_10, ""Transport type in tpsel not matched""));
	    return VAR_13;
	}

	/* COMMENT_4 */
	if (VAR_12->is_destroying) {
	    pj_lock_release(VAR_1->lock);
	    TRACE_((VAR_10,""Transport to be acquired is being destroyed""));
	    return VAR_14;
	}

	/* COMMENT_5 */
                                                                 
                                                              
                        
   
                                                                    
                 
    

	/* COMMENT_13 */
	pjsip_transport_add_ref(VAR_12);
	pj_lock_release(VAR_1->lock);
	*VAR_7 = VAR_12;

	TRACE_((VAR_10, ""Transport %s acquired"", VAR_12->obj_name));
	return VAR_15;

    } else {

	/* COMMENT_14 */
                                                                
                                                     
                                                           
    
	pjsip_transport_key VAR_16;
	int VAR_17;
	pjsip_transport *VAR_18 = NULL;
	transport *VAR_19 = NULL;


	/* COMMENT_19 */
                         
    
	if (VAR_5 && VAR_5->type == VAR_20 && VAR_5->u.listener)
	{
	    if (VAR_5->u.listener->type != VAR_2) {
		pj_lock_release(VAR_1->lock);
		TRACE_((VAR_10, ""Listener type in tpsel not matched""));
		return VAR_13;
	    }
	}

	if (!VAR_5 || VAR_5->disable_connection_reuse == VAR_21) {
	    pj_bzero(&VAR_16, sizeof(VAR_16));
	    VAR_17 = sizeof(VAR_16.type) + VAR_4;

	    /* COMMENT_22 */
	    VAR_16.type = VAR_2;
	    pj_memcpy(&VAR_16.rem_addr, VAR_3, VAR_4);

	    VAR_19 = (transport *)pj_hash_get(VAR_1->table, &VAR_16, VAR_17,
						NULL);
	    if (VAR_19) {
		transport *VAR_22 = VAR_19;
		do {
		    /* COMMENT_23 */
		    if (!VAR_22->tp->is_shutdown &&
			!VAR_22->tp->is_destroying)
		    {
			if ((VAR_2 & VAR_23) && VAR_6) {
			    /* COMMENT_24 */
                                                  
                      
          
			    if (pj_stricmp(&VAR_6->dest_info.name,
				  	   &VAR_22->tp->remote_name.host))
			    {
			    	VAR_22 = VAR_22->next;
			    	continue;
			    }
			}

			if (VAR_5 && VAR_5->type == VAR_20 &&
			    VAR_5->u.listener)
			{
			    /* COMMENT_28 */
			    if (VAR_22->tp->factory == VAR_5->u.listener) {
				VAR_18 = VAR_22->tp;
				break;
			    }
			} else {
			    VAR_18 = VAR_22->tp;
			    break;
			}
		    }
		    VAR_22 = VAR_22->next;
		} while (VAR_22 != VAR_19);
	    }
	}

	if (VAR_18 == NULL &&
	    (!VAR_5 || VAR_5->disable_connection_reuse == VAR_21))
	{
	    unsigned VAR_24 = pjsip_transport_get_flag_from_type(VAR_2);
	    const pj_sockaddr *VAR_25 = (const pj_sockaddr*)VAR_3;


	    /* COMMENT_29 */
	    if (VAR_2 == VAR_26 ||
		VAR_2 == VAR_27)
	    {
		pj_sockaddr *VAR_28 = &VAR_16.rem_addr;

		pj_bzero(VAR_28, VAR_4);
		VAR_17 = sizeof(VAR_16.type) + VAR_4;
		VAR_19 = (transport *) pj_hash_get(VAR_1->table, &VAR_16,
						     VAR_17, NULL);
		if (VAR_19) {
		    VAR_18 = VAR_19->tp;
		}
	    }
	    /* COMMENT_30 */
        
	    else if (VAR_24 & VAR_29)
	    {
		pj_sockaddr *VAR_28 = &VAR_16.rem_addr;

		pj_bzero(VAR_28, VAR_4);
		VAR_28->addr.sa_family = VAR_25->addr.sa_family;

		VAR_17 = sizeof(VAR_16.type) + VAR_4;
		VAR_19 = (transport *) pj_hash_get(VAR_1->table, &VAR_16,
						     VAR_17, NULL);
		if (VAR_19) {
		    VAR_18 = VAR_19->tp;
		}
	    }
	}

	/* COMMENT_32 */
	else if (VAR_5 && VAR_5->type == VAR_20 &&
		 VAR_5->u.listener && VAR_18->factory != VAR_5->u.listener)
	{
	    VAR_18 = NULL;
	    /* COMMENT_33 */
                                                                       
                               
        
	    TRACE_((VAR_10, ""Transport found but from different listener""));
	}

	if (VAR_18!=NULL && !VAR_18->is_shutdown && !VAR_18->is_destroying) {
	    /* COMMENT_37 */
                        
        
	    pjsip_transport_add_ref(VAR_18);
	    pj_lock_release(VAR_1->lock);
	    *VAR_7 = VAR_18;

	    TRACE_((VAR_10, ""Transport %s acquired"", VAR_18->obj_name));
	    return VAR_15;
	}


	/* COMMENT_40 */
                                                                    
                                                          
                                                               
                                                
   
                                                                 
                                                                 
                                                            
    
	if (VAR_5 && VAR_5->type == VAR_20 && VAR_5->u.listener)
	{
	    /* COMMENT_50 */
                
        

	    /* COMMENT_53 */
	    /* COMMENT_54 */
	    /* COMMENT_55 */
                                         
                             
                              
      
       

	    /* COMMENT_61 */
	    VAR_8 = VAR_5->u.listener;

	    /* COMMENT_62 */
	    if (!pjsip_tpmgr_is_tpfactory_valid(VAR_1, VAR_8)) {
		pj_lock_release(VAR_1->lock);
		PJ_LOG(3,(VAR_10, ""Specified factory for creating ""
				     ""transport is not found""));
		return VAR_14;
	    }

	} else {

	    /* COMMENT_63 */
	    VAR_8 = VAR_1->factory_list.next;
	    while (VAR_8 != &VAR_1->factory_list) {
		if (VAR_8->type == VAR_2)
		    break;
		VAR_8 = VAR_8->next;
	    }

	    if (VAR_8 == &VAR_1->factory_list) {
		/* COMMENT_64 */
		pj_lock_release(VAR_1->lock);
		TRACE_((VAR_10, ""No suitable factory was found either""));
		return VAR_30;
	    }
	}
    }

    TRACE_((VAR_10, ""Creating new transport from factory""));

    /* COMMENT_65 */
    if (VAR_8->create_transport2) {
	VAR_9 = VAR_8->create_transport2(VAR_8, VAR_1, VAR_1->endpt,
					    (const pj_sockaddr*) VAR_3,
					    VAR_4, VAR_6, VAR_7);
    } else {
	VAR_9 = VAR_8->create_transport(VAR_8, VAR_1, VAR_1->endpt,
					   (const pj_sockaddr*) VAR_3,
					   VAR_4, VAR_7);
    }
    if (VAR_9 == VAR_15) {
	PJ_ASSERT_ON_FAIL(VAR_7!=NULL,
	    {pj_lock_release(VAR_1->lock); return VAR_31;});
	pjsip_transport_add_ref(*VAR_7);
	(*VAR_7)->factory = VAR_8;
    }",,"--- func_before
+++ func_after
@@ -98,6 +98,19 @@
 		    if (!tp_iter->tp->is_shutdown &&
 			!tp_iter->tp->is_destroying)
 		    {
+			if ((type & PJSIP_TRANSPORT_SECURE) && tdata) {
+			    /* For secure transport, make sure tdata's
+			     * destination host matches the transport's
+			     * remote host.
+			     */
+			    if (pj_stricmp(&tdata->dest_info.name,
+				  	   &tp_iter->tp->remote_name.host))
+			    {
+			    	tp_iter = tp_iter->next;
+			    	continue;
+			    }
+			}
+
 			if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER &&
 			    sel->u.listener)
 			{","{'deleted_lines': [], 'added_lines': ['\t\t\tif ((type & PJSIP_TRANSPORT_SECURE) && tdata) {', ""\t\t\t    /* For secure transport, make sure tdata's"", ""\t\t\t     * destination host matches the transport's"", '\t\t\t     * remote host.', '\t\t\t     */', '\t\t\t    if (pj_stricmp(&tdata->dest_info.name,', '\t\t\t\t  \t   &tp_iter->tp->remote_name.host))', '\t\t\t    {', '\t\t\t    \ttp_iter = tp_iter->next;', '\t\t\t    \tcontinue;', '\t\t\t    }', '\t\t\t}', '']}",True,"PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In version 2.10 and earlier, PJSIP transport can be reused if they have the same IP address + port + protocol. However, this is insufficient for secure transport since it lacks remote hostname authentication. Suppose we have created a TLS connection to `sip.foo.com`, which has an IP address `100.1.1.1`. If we want to create a TLS connection to another hostname, say `sip.bar.com`, which has the same IP address, then it will reuse that existing connection, even though `100.1.1.1` does not have certificate to authenticate as `sip.bar.com`. The vulnerability allows for an insecure interaction without user awareness. It affects users who need access to connections to different destinations that translate to the same address, and allows man-in-the-middle attack if attacker can route a connection to another destination such as in the case of DNS spoofing.",6.8,MEDIUM,1,valid,2021-03-08T09:39:36Z,3
CVE-2020-15260,['CWE-295'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,pjsip/pjproject,"Merge pull request from GHSA-8hcp-hm38-mfph

* Check hostname during TLS transport selection

* revision based on feedback

* remove the code in create_request that has been moved",67e46c1ac45ad784db5b9080f5ed8b133c122872,https://github.com/pjsip/pjproject/commit/67e46c1ac45ad784db5b9080f5ed8b133c122872,pjsip/src/pjsip/sip_dialog.c,dlg_update_routeset,"static void dlg_update_routeset(pjsip_dialog *dlg, const pjsip_rx_data *rdata)
{
const pjsip_hdr *hdr, *end_hdr;
const pjsip_msg *msg;
const pjsip_method update = { PJSIP_OTHER_METHOD, {""UPDATE"", 6}};
msg = rdata->msg_info.msg;
if (dlg->route_set_frozen)
return;
if (pjsip_method_cmp(&rdata->msg_info.cseq->method, &update) == 0)
return;
if (dlg->role == PJSIP_ROLE_UAC) {
if (msg->type != PJSIP_RESPONSE_MSG)
return;
} else {
pj_assert(!""Should not happen"");
}
pj_assert(msg->type == PJSIP_RESPONSE_MSG);
if (msg->line.status.code >= 300)
return;
pj_list_init(&dlg->route_set);
end_hdr = &msg->hdr;
for (hdr=msg->hdr.prev; hdr!=end_hdr; hdr=hdr->prev) {
if (hdr->type == PJSIP_H_RECORD_ROUTE) {
pjsip_route_hdr *r;
r = (pjsip_route_hdr*) pjsip_hdr_clone(dlg->pool, hdr);
pjsip_routing_hdr_set_route(r);
pj_list_push_back(&dlg->route_set, r);
}
}
PJ_LOG(5,(dlg->obj_name, ""Route-set updated""));
if (pjsip_method_creates_dialog(&rdata->msg_info.cseq->method) &&
PJSIP_IS_STATUS_IN_CLASS(msg->line.status.code, 200))
{
dlg->route_set_frozen = PJ_TRUE;
PJ_LOG(5,(dlg->obj_name, ""Route-set frozen""));
}
}","static void dlg_update_routeset(pjsip_dialog *VAR_0, const pjsip_rx_data *VAR_1)
{
const pjsip_hdr *VAR_2, *VAR_3;
const pjsip_msg *VAR_4;
const pjsip_method VAR_5 = { VAR_6, {""UPDATE"", 6}};
VAR_4 = VAR_1->msg_info.msg;
if (VAR_0->route_set_frozen)
return;
if (pjsip_method_cmp(&VAR_1->msg_info.cseq->method, &VAR_5) == 0)
return;
if (VAR_0->role == VAR_7) {
if (VAR_4->type != VAR_8)
return;
} else {
pj_assert(!""Should not happen"");
}
pj_assert(VAR_4->type == VAR_8);
if (VAR_4->line.status.code >= 300)
return;
pj_list_init(&VAR_0->route_set);
VAR_3 = &VAR_4->hdr;
for (VAR_2=VAR_4->hdr.prev; VAR_2!=VAR_3; VAR_2=VAR_2->prev) {
if (VAR_2->type == VAR_9) {
pjsip_route_hdr *VAR_10;
VAR_10 = (pjsip_route_hdr*) pjsip_hdr_clone(VAR_0->pool, VAR_2);
pjsip_routing_hdr_set_route(VAR_10);
pj_list_push_back(&VAR_0->route_set, VAR_10);
}
}
PJ_LOG(5,(VAR_0->obj_name, ""Route-set updated""));
if (pjsip_method_creates_dialog(&VAR_1->msg_info.cseq->method) &&
PJSIP_IS_STATUS_IN_CLASS(VAR_4->line.status.code, 200))
{
VAR_0->route_set_frozen = VAR_11;
PJ_LOG(5,(VAR_0->obj_name, ""Route-set frozen""));
}
}",pjsip/pjproject/67e46c1ac45ad784db5b9080f5ed8b133c122872/sip_dialog.c/vul/before/2.json,"static void dlg_update_routeset(pjsip_dialog *dlg, const pjsip_rx_data *rdata)
{
    const pjsip_hdr *hdr, *end_hdr;
    //pj_int32_t msg_cseq;
    const pjsip_msg *msg;
    const pjsip_method update = { PJSIP_OTHER_METHOD, {""UPDATE"", 6}};

    msg = rdata->msg_info.msg;
    //msg_cseq = rdata->msg_info.cseq->cseq;

    /* Ignore if route set has been frozen */
    if (dlg->route_set_frozen)
	return;

    /* Ignore if the message is an UPDATE response (see ticket #1781) */
    if (pjsip_method_cmp(&rdata->msg_info.cseq->method, &update) == 0)
	return;

    /* Only update route set if this message belongs to the same
     * transaction as the initial transaction that establishes dialog.
     */
    if (dlg->role == PJSIP_ROLE_UAC) {
    	/* Save initial destination host from transport's info. */
    	if (!dlg->initial_dest.slen) {
    	    pj_strdup(dlg->pool, &dlg->initial_dest,
    	      	      &rdata->tp_info.transport->remote_name.host);
    	}

	/* Ignore subsequent request from remote */
	if (msg->type != PJSIP_RESPONSE_MSG)
	    return;

	/* Ignore subsequent responses with higher CSeq than initial CSeq.
	 * Unfortunately this would be broken when the first request is
	 * challenged!
	 */
	//if (msg_cseq != dlg->local.first_cseq)
	//    return;

    } else {

	/* For callee dialog, route set should have been set by initial
	 * request and it will have been rejected by dlg->route_set_frozen
	 * check above.
	 */
	pj_assert(!""Should not happen"");

    }

    /* Based on the checks above, we should only get response message here */
    pj_assert(msg->type == PJSIP_RESPONSE_MSG);

    /* Ignore if this is not 1xx or 2xx response */
    if (msg->line.status.code >= 300)
	return;

    /* Reset route set */
    pj_list_init(&dlg->route_set);

    /* Update route set */
    end_hdr = &msg->hdr;
    for (hdr=msg->hdr.prev; hdr!=end_hdr; hdr=hdr->prev) {
	if (hdr->type == PJSIP_H_RECORD_ROUTE) {
	    pjsip_route_hdr *r;
	    r = (pjsip_route_hdr*) pjsip_hdr_clone(dlg->pool, hdr);
	    pjsip_routing_hdr_set_route(r);
	    pj_list_push_back(&dlg->route_set, r);
	}
    }

    PJ_LOG(5,(dlg->obj_name, ""Route-set updated""));

    /* Freeze the route set only when the route set comes in 2xx response.
     * If it is in 1xx response, prepare to recompute the route set when
     * the 2xx response comes in.
     *
     * There is a debate whether route set should be frozen when the dialog
     * is established with reliable provisional response, but I think
     * it is safer to not freeze the route set (thus recompute the route set
     * upon receiving 2xx response). Also RFC 3261 says so in 13.2.2.4.
     *
     * The pjsip_method_creates_dialog() check protects from wrongly
     * freezing the route set upon receiving 200/OK response for PRACK.
     */
    if (pjsip_method_creates_dialog(&rdata->msg_info.cseq->method) &&
	PJSIP_IS_STATUS_IN_CLASS(msg->line.status.code, 200))
    {
	dlg->route_set_frozen = PJ_TRUE;
	PJ_LOG(5,(dlg->obj_name, ""Route-set frozen""));
    }
}","static void dlg_update_routeset(pjsip_dialog *VAR_0, const pjsip_rx_data *VAR_1)
{
    const pjsip_hdr *VAR_2, *VAR_3;
    /* COMMENT_0 */
    const pjsip_msg *VAR_4;
    const pjsip_method VAR_5 = { VAR_6, {""UPDATE"", 6}};

    VAR_4 = VAR_1->msg_info.msg;
    /* COMMENT_1 */

    /* COMMENT_2 */
    if (VAR_0->route_set_frozen)
	return;

    /* COMMENT_3 */
    if (pjsip_method_cmp(&VAR_1->msg_info.cseq->method, &VAR_5) == 0)
	return;

    /* COMMENT_4 */
                                                                      
       
    if (VAR_0->role == VAR_7) {
    	/* COMMENT_7 */
    	if (!VAR_0->initial_dest.slen) {
    	    pj_strdup(VAR_0->pool, &VAR_0->initial_dest,
    	      	      &VAR_1->tp_info.transport->remote_name.host);
    	}

	/* COMMENT_8 */
	if (VAR_4->type != VAR_8)
	    return;

	/* COMMENT_9 */
                                                                
               
    
	/* COMMENT_13 */
	/* COMMENT_14 */

    } else {

	/* COMMENT_15 */
                                                                   
                
    
	pj_assert(!""Should not happen"");

    }

    /* COMMENT_19 */
    pj_assert(VAR_4->type == VAR_8);

    /* COMMENT_20 */
    if (VAR_4->line.status.code >= 300)
	return;

    /* COMMENT_21 */
    pj_list_init(&VAR_0->route_set);

    /* COMMENT_22 */
    VAR_3 = &VAR_4->hdr;
    for (VAR_2=VAR_4->hdr.prev; VAR_2!=VAR_3; VAR_2=VAR_2->prev) {
	if (VAR_2->type == VAR_9) {
	    pjsip_route_hdr *VAR_10;
	    VAR_10 = (pjsip_route_hdr*) pjsip_hdr_clone(VAR_0->pool, VAR_2);
	    pjsip_routing_hdr_set_route(VAR_10);
	    pj_list_push_back(&VAR_0->route_set, VAR_10);
	}
    }

    PJ_LOG(5,(VAR_0->obj_name, ""Route-set updated""));

    /* COMMENT_23 */
                                                                        
                                 
      
                                                                           
                                                                     
                                                                            
                                                                       
      
                                                                    
                                                                       
       
    if (pjsip_method_creates_dialog(&VAR_1->msg_info.cseq->method) &&
	PJSIP_IS_STATUS_IN_CLASS(VAR_4->line.status.code, 200))
    {
	VAR_0->route_set_frozen = VAR_11;
	PJ_LOG(5,(VAR_0->obj_name, ""Route-set frozen""));
    }
}",pjsip/pjproject/67e46c1ac45ad784db5b9080f5ed8b133c122872/sip_dialog.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -20,6 +20,11 @@
      * transaction as the initial transaction that establishes dialog.
      */
     if (dlg->role == PJSIP_ROLE_UAC) {
+    	/* Save initial destination host from transport's info. */
+    	if (!dlg->initial_dest.slen) {
+    	    pj_strdup(dlg->pool, &dlg->initial_dest,
+    	      	      &rdata->tp_info.transport->remote_name.host);
+    	}
 
 	/* Ignore subsequent request from remote */
 	if (msg->type != PJSIP_RESPONSE_MSG)","{'deleted_lines': [], 'added_lines': [""    \t/* Save initial destination host from transport's info. */"", '    \tif (!dlg->initial_dest.slen) {', '    \t    pj_strdup(dlg->pool, &dlg->initial_dest,', '    \t      \t      &rdata->tp_info.transport->remote_name.host);', '    \t}']}",True,"PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In version 2.10 and earlier, PJSIP transport can be reused if they have the same IP address + port + protocol. However, this is insufficient for secure transport since it lacks remote hostname authentication. Suppose we have created a TLS connection to `sip.foo.com`, which has an IP address `100.1.1.1`. If we want to create a TLS connection to another hostname, say `sip.bar.com`, which has the same IP address, then it will reuse that existing connection, even though `100.1.1.1` does not have certificate to authenticate as `sip.bar.com`. The vulnerability allows for an insecure interaction without user awareness. It affects users who need access to connections to different destinations that translate to the same address, and allows man-in-the-middle attack if attacker can route a connection to another destination such as in the case of DNS spoofing.",6.8,MEDIUM,1,valid,2021-03-08T09:39:36Z,3
CVE-2020-15260,['CWE-295'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,pjsip/pjproject,"Merge pull request from GHSA-8hcp-hm38-mfph

* Check hostname during TLS transport selection

* revision based on feedback

* remove the code in create_request that has been moved",67e46c1ac45ad784db5b9080f5ed8b133c122872,https://github.com/pjsip/pjproject/commit/67e46c1ac45ad784db5b9080f5ed8b133c122872,pjsip/src/pjsip/sip_dialog.c,create_uas_dialog,"pj_status_t create_uas_dialog( pjsip_user_agent *ua,
pjsip_rx_data *rdata,
const pj_str_t *contact,
pj_bool_t inc_lock,
pjsip_dialog **p_dlg)
{
pj_status_t status;
pjsip_hdr *pos = NULL;
pjsip_contact_hdr *contact_hdr;
pjsip_rr_hdr *rr;
pjsip_transaction *tsx = NULL;
pj_str_t tmp;
enum { TMP_LEN=PJSIP_MAX_URL_SIZE };
pj_ssize_t len;
pjsip_dialog *dlg;
pj_bool_t lock_incremented = PJ_FALSE;
PJ_ASSERT_RETURN(ua && rdata && p_dlg, PJ_EINVAL);
PJ_ASSERT_RETURN(rdata->msg_info.msg->type == PJSIP_REQUEST_MSG,
PJSIP_ENOTREQUESTMSG);
PJ_ASSERT_RETURN(rdata->msg_info.to->tag.slen == 0, PJ_EINVALIDOP);
PJ_ASSERT_RETURN(
pjsip_method_creates_dialog(&rdata->msg_info.msg->line.req.method),
PJ_EINVALIDOP);
status = create_dialog(ua, NULL, &dlg);
if (status != PJ_SUCCESS)
return status;
tmp.ptr = (char*) pj_pool_alloc(rdata->tp_info.pool, TMP_LEN);
dlg->local.info = (pjsip_fromto_hdr*)
pjsip_hdr_clone(dlg->pool, rdata->msg_info.to);
pjsip_fromto_hdr_set_from(dlg->local.info);
pj_create_unique_string(dlg->pool, &dlg->local.info->tag);
len = pjsip_uri_print(PJSIP_URI_IN_FROMTO_HDR,
dlg->local.info->uri, tmp.ptr, TMP_LEN);
if (len < 1) {
pj_ansi_strcpy(tmp.ptr, ""<-error: uri too long->"");
tmp.slen = pj_ansi_strlen(tmp.ptr);
} else
tmp.slen = len;
pj_strdup(dlg->pool, &dlg->local.info_str, &tmp);
dlg->local.tag_hval = pj_hash_calc_tolower(0, NULL, &dlg->local.info->tag);
dlg->local.first_cseq = pj_rand() & 0x7FFF;
dlg->local.cseq = dlg->local.first_cseq;
if (contact) {
pj_str_t tmp2;
pj_strdup_with_null(dlg->pool, &tmp2, contact);
dlg->local.contact = (pjsip_contact_hdr*)
pjsip_parse_hdr(dlg->pool, &HCONTACT, tmp2.ptr,
tmp2.slen, NULL);
if (!dlg->local.contact) {
status = PJSIP_EINVALIDURI;
goto on_error;
}
} else {
dlg->local.contact = pjsip_contact_hdr_create(dlg->pool);
dlg->local.contact->uri = dlg->local.info->uri;
}
dlg->remote.info = (pjsip_fromto_hdr*)
pjsip_hdr_clone(dlg->pool, rdata->msg_info.from);
pjsip_fromto_hdr_set_to(dlg->remote.info);
len = pjsip_uri_print(PJSIP_URI_IN_FROMTO_HDR,
dlg->remote.info->uri, tmp.ptr, TMP_LEN);
if (len < 1) {
pj_ansi_strcpy(tmp.ptr, ""<-error: uri too long->"");
tmp.slen = pj_ansi_strlen(tmp.ptr);
} else
tmp.slen = len;
pj_strdup(dlg->pool, &dlg->remote.info_str, &tmp);
do {
contact_hdr = (pjsip_contact_hdr*)
pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT,
pos);
if (contact_hdr) {
if (!contact_hdr->uri ||
(!PJSIP_URI_SCHEME_IS_SIP(contact_hdr->uri) &&
!PJSIP_URI_SCHEME_IS_SIPS(contact_hdr->uri)))
{
pos = (pjsip_hdr*)contact_hdr->next;
if (pos == &rdata->msg_info.msg->hdr)
contact_hdr = NULL;
} else {
break;
}
}
} while (contact_hdr);
if (!contact_hdr) {
status = PJSIP_ERRNO_FROM_SIP_STATUS(PJSIP_SC_BAD_REQUEST);
goto on_error;
}
dlg->remote.contact = (pjsip_contact_hdr*)
pjsip_hdr_clone(dlg->pool, (pjsip_hdr*)contact_hdr);
dlg->remote.cseq = dlg->remote.first_cseq = rdata->msg_info.cseq->cseq;
dlg->target = dlg->remote.contact->uri;
dlg->role = PJSIP_ROLE_UAS;
dlg->secure = PJSIP_TRANSPORT_IS_SECURE(rdata->tp_info.transport) &&
PJSIP_URI_SCHEME_IS_SIPS(rdata->msg_info.msg->line.req.uri);
dlg->call_id = (pjsip_cid_hdr*)
pjsip_hdr_clone(dlg->pool, rdata->msg_info.cid);
pj_list_init(&dlg->route_set);
rr = rdata->msg_info.record_route;
while (rr != NULL) {
pjsip_route_hdr *route;
route = (pjsip_route_hdr*) pjsip_hdr_clone(dlg->pool, rr);
pjsip_routing_hdr_set_route(route);
pj_list_push_back(&dlg->route_set, route);
rr = rr->next;
if (rr == (void*)&rdata->msg_info.msg->hdr)
break;
rr = (pjsip_route_hdr*) pjsip_msg_find_hdr(rdata->msg_info.msg,
PJSIP_H_RECORD_ROUTE, rr);
}
dlg->route_set_frozen = PJ_TRUE;
if (inc_lock) {
pjsip_dlg_inc_lock(dlg);
lock_incremented = PJ_TRUE;
}
status = pjsip_tsx_create_uas(dlg->ua, rdata, &tsx);
if (status != PJ_SUCCESS)
goto on_error;
tsx->mod_data[dlg->ua->id] = dlg;
++dlg->tsx_count;
dlg->remote.tag_hval = pj_hash_calc_tolower(0, NULL, &dlg->remote.info->tag);
pjsip_dlg_update_remote_cap(dlg, rdata->msg_info.msg, PJ_TRUE);
status = pjsip_ua_register_dlg( ua, dlg );
if (status != PJ_SUCCESS)
goto on_error;
rdata->endpt_info.mod_data[ua->id] = dlg;
PJ_TODO(DIALOG_APP_TIMER);
pjsip_tsx_recv_msg(tsx, rdata);
*p_dlg = dlg;
PJ_LOG(5,(dlg->obj_name, ""UAS dialog created""));
return PJ_SUCCESS;
on_error:
if (tsx) {
pjsip_tsx_terminate(tsx, 500);
pj_assert(dlg->tsx_count>0);
--dlg->tsx_count;
}
if (lock_incremented) {
pjsip_dlg_dec_lock(dlg);
} else {
destroy_dialog(dlg, PJ_FALSE);
}
return status;
}","pj_status_t create_uas_dialog( pjsip_user_agent *VAR_0,
pjsip_rx_data *VAR_1,
const pj_str_t *VAR_2,
pj_bool_t VAR_3,
pjsip_dialog **VAR_4)
{
pj_status_t VAR_5;
pjsip_hdr *VAR_6 = NULL;
pjsip_contact_hdr *VAR_7;
pjsip_rr_hdr *VAR_8;
pjsip_transaction *VAR_9 = NULL;
pj_str_t VAR_10;
enum { VAR_11=VAR_12 };
pj_ssize_t VAR_13;
pjsip_dialog *VAR_14;
pj_bool_t VAR_15 = VAR_16;
PJ_ASSERT_RETURN(VAR_0 && VAR_1 && VAR_4, VAR_17);
PJ_ASSERT_RETURN(VAR_1->msg_info.msg->type == VAR_18,
VAR_19);
PJ_ASSERT_RETURN(VAR_1->msg_info.to->tag.slen == 0, VAR_20);
PJ_ASSERT_RETURN(
pjsip_method_creates_dialog(&VAR_1->msg_info.msg->line.req.method),
VAR_20);
VAR_5 = create_dialog(VAR_0, NULL, &VAR_14);
if (VAR_5 != VAR_21)
return VAR_5;
VAR_10.ptr = (char*) pj_pool_alloc(VAR_1->tp_info.pool, VAR_11);
VAR_14->local.info = (pjsip_fromto_hdr*)
pjsip_hdr_clone(VAR_14->pool, VAR_1->msg_info.to);
pjsip_fromto_hdr_set_from(VAR_14->local.info);
pj_create_unique_string(VAR_14->pool, &VAR_14->local.info->tag);
VAR_13 = pjsip_uri_print(VAR_22,
VAR_14->local.info->uri, VAR_10.ptr, VAR_11);
if (VAR_13 < 1) {
pj_ansi_strcpy(VAR_10.ptr, ""<-error: uri too long->"");
VAR_10.slen = pj_ansi_strlen(VAR_10.ptr);
} else
VAR_10.slen = VAR_13;
pj_strdup(VAR_14->pool, &VAR_14->local.info_str, &VAR_10);
VAR_14->local.tag_hval = pj_hash_calc_tolower(0, NULL, &VAR_14->local.info->tag);
VAR_14->local.first_cseq = pj_rand() & 0x7FFF;
VAR_14->local.cseq = VAR_14->local.first_cseq;
if (VAR_2) {
pj_str_t VAR_23;
pj_strdup_with_null(VAR_14->pool, &VAR_23, VAR_2);
VAR_14->local.contact = (pjsip_contact_hdr*)
pjsip_parse_hdr(VAR_14->pool, &VAR_24, VAR_23.ptr,
VAR_23.slen, NULL);
if (!VAR_14->local.contact) {
VAR_5 = VAR_25;
goto on_error;
}
} else {
VAR_14->local.contact = pjsip_contact_hdr_create(VAR_14->pool);
VAR_14->local.contact->uri = VAR_14->local.info->uri;
}
VAR_14->remote.info = (pjsip_fromto_hdr*)
pjsip_hdr_clone(VAR_14->pool, VAR_1->msg_info.from);
pjsip_fromto_hdr_set_to(VAR_14->remote.info);
VAR_13 = pjsip_uri_print(VAR_22,
VAR_14->remote.info->uri, VAR_10.ptr, VAR_11);
if (VAR_13 < 1) {
pj_ansi_strcpy(VAR_10.ptr, ""<-error: uri too long->"");
VAR_10.slen = pj_ansi_strlen(VAR_10.ptr);
} else
VAR_10.slen = VAR_13;
pj_strdup(VAR_14->pool, &VAR_14->remote.info_str, &VAR_10);
do {
VAR_7 = (pjsip_contact_hdr*)
pjsip_msg_find_hdr(VAR_1->msg_info.msg, VAR_26,
VAR_6);
if (VAR_7) {
if (!VAR_7->uri ||
(!PJSIP_URI_SCHEME_IS_SIP(VAR_7->uri) &&
!PJSIP_URI_SCHEME_IS_SIPS(VAR_7->uri)))
{
VAR_6 = (pjsip_hdr*)VAR_7->next;
if (VAR_6 == &VAR_1->msg_info.msg->hdr)
VAR_7 = NULL;
} else {
break;
}
}
} while (VAR_7);
if (!VAR_7) {
VAR_5 = PJSIP_ERRNO_FROM_SIP_STATUS(VAR_27);
goto on_error;
}
VAR_14->remote.contact = (pjsip_contact_hdr*)
pjsip_hdr_clone(VAR_14->pool, (pjsip_hdr*)VAR_7);
VAR_14->remote.cseq = VAR_14->remote.first_cseq = VAR_1->msg_info.cseq->cseq;
VAR_14->target = VAR_14->remote.contact->uri;
VAR_14->role = VAR_28;
VAR_14->secure = PJSIP_TRANSPORT_IS_SECURE(VAR_1->tp_info.transport) &&
PJSIP_URI_SCHEME_IS_SIPS(VAR_1->msg_info.msg->line.req.uri);
VAR_14->call_id = (pjsip_cid_hdr*)
pjsip_hdr_clone(VAR_14->pool, VAR_1->msg_info.cid);
pj_list_init(&VAR_14->route_set);
VAR_8 = VAR_1->msg_info.record_route;
while (VAR_8 != NULL) {
pjsip_route_hdr *VAR_29;
VAR_29 = (pjsip_route_hdr*) pjsip_hdr_clone(VAR_14->pool, VAR_8);
pjsip_routing_hdr_set_route(VAR_29);
pj_list_push_back(&VAR_14->route_set, VAR_29);
VAR_8 = VAR_8->next;
if (VAR_8 == (void*)&VAR_1->msg_info.msg->hdr)
break;
VAR_8 = (pjsip_route_hdr*) pjsip_msg_find_hdr(VAR_1->msg_info.msg,
VAR_30, VAR_8);
}
VAR_14->route_set_frozen = VAR_31;
if (VAR_3) {
pjsip_dlg_inc_lock(VAR_14);
VAR_15 = VAR_31;
}
VAR_5 = pjsip_tsx_create_uas(VAR_14->ua, VAR_1, &VAR_9);
if (VAR_5 != VAR_21)
goto on_error;
VAR_9->mod_data[VAR_14->ua->id] = VAR_14;
++VAR_14->tsx_count;
VAR_14->remote.tag_hval = pj_hash_calc_tolower(0, NULL, &VAR_14->remote.info->tag);
pjsip_dlg_update_remote_cap(VAR_14, VAR_1->msg_info.msg, VAR_31);
VAR_5 = pjsip_ua_register_dlg( VAR_0, VAR_14 );
if (VAR_5 != VAR_21)
goto on_error;
VAR_1->endpt_info.mod_data[VAR_0->id] = VAR_14;
PJ_TODO(VAR_32);
pjsip_tsx_recv_msg(VAR_9, VAR_1);
*VAR_4 = VAR_14;
PJ_LOG(5,(VAR_14->obj_name, ""UAS dialog created""));
return VAR_21;
on_error:
if (VAR_9) {
pjsip_tsx_terminate(VAR_9, 500);
pj_assert(VAR_14->tsx_count>0);
--VAR_14->tsx_count;
}
if (VAR_15) {
pjsip_dlg_dec_lock(VAR_14);
} else {
destroy_dialog(VAR_14, VAR_16);
}
return VAR_5;
}",pjsip/pjproject/67e46c1ac45ad784db5b9080f5ed8b133c122872/sip_dialog.c/vul/before/1.json,"pj_status_t create_uas_dialog( pjsip_user_agent *ua,
			       pjsip_rx_data *rdata,
			       const pj_str_t *contact,
			       pj_bool_t inc_lock,
			       pjsip_dialog **p_dlg)
{
    pj_status_t status;
    pjsip_hdr *pos = NULL;
    pjsip_contact_hdr *contact_hdr;
    pjsip_rr_hdr *rr;
    pjsip_transaction *tsx = NULL;
    pj_str_t tmp;
    enum { TMP_LEN=PJSIP_MAX_URL_SIZE };
    pj_ssize_t len;
    pjsip_dialog *dlg;
    pj_bool_t lock_incremented = PJ_FALSE;

    /* Check arguments. */
    PJ_ASSERT_RETURN(ua && rdata && p_dlg, PJ_EINVAL);

    /* rdata must have request message. */
    PJ_ASSERT_RETURN(rdata->msg_info.msg->type == PJSIP_REQUEST_MSG,
		     PJSIP_ENOTREQUESTMSG);

    /* Request must not have To tag.
     * This should have been checked in the user agent (or application?).
     */
    PJ_ASSERT_RETURN(rdata->msg_info.to->tag.slen == 0, PJ_EINVALIDOP);

    /* The request must be a dialog establishing request. */
    PJ_ASSERT_RETURN(
	pjsip_method_creates_dialog(&rdata->msg_info.msg->line.req.method),
	PJ_EINVALIDOP);

    /* Create dialog instance. */
    status = create_dialog(ua, NULL, &dlg);
    if (status != PJ_SUCCESS)
	return status;

    /* Temprary string for getting the string representation of
     * both local and remote URI.
     */
    tmp.ptr = (char*) pj_pool_alloc(rdata->tp_info.pool, TMP_LEN);

    /* Init local info from the To header. */
    dlg->local.info = (pjsip_fromto_hdr*)
    		      pjsip_hdr_clone(dlg->pool, rdata->msg_info.to);
    pjsip_fromto_hdr_set_from(dlg->local.info);

    /* Generate local tag. */
    pj_create_unique_string(dlg->pool, &dlg->local.info->tag);


    /* Print the local info. */
    len = pjsip_uri_print(PJSIP_URI_IN_FROMTO_HDR,
			  dlg->local.info->uri, tmp.ptr, TMP_LEN);
    if (len < 1) {
	pj_ansi_strcpy(tmp.ptr, ""<-error: uri too long->"");
	tmp.slen = pj_ansi_strlen(tmp.ptr);
    } else
	tmp.slen = len;

    /* Save the local info. */
    pj_strdup(dlg->pool, &dlg->local.info_str, &tmp);

    /* Calculate hash value of local tag. */
    dlg->local.tag_hval = pj_hash_calc_tolower(0, NULL, &dlg->local.info->tag);


    /* Randomize local cseq */
    dlg->local.first_cseq = pj_rand() & 0x7FFF;
    dlg->local.cseq = dlg->local.first_cseq;

    /* Init local contact. */
    /* TODO:
     *  Section 12.1.1, paragraph about using SIPS URI in Contact.
     *  If the request that initiated the dialog contained a SIPS URI
     *  in the Request-URI or in the top Record-Route header field value,
     *  if there was any, or the Contact header field if there was no
     *  Record-Route header field, the Contact header field in the response
     *  MUST be a SIPS URI.
     */
    if (contact) {
	pj_str_t tmp2;

	pj_strdup_with_null(dlg->pool, &tmp2, contact);
	dlg->local.contact = (pjsip_contact_hdr*)
			     pjsip_parse_hdr(dlg->pool, &HCONTACT, tmp2.ptr,
					     tmp2.slen, NULL);
	if (!dlg->local.contact) {
	    status = PJSIP_EINVALIDURI;
	    goto on_error;
	}

    } else {
	dlg->local.contact = pjsip_contact_hdr_create(dlg->pool);
	dlg->local.contact->uri = dlg->local.info->uri;
    }

    /* Init remote info from the From header. */
    dlg->remote.info = (pjsip_fromto_hdr*)
    		       pjsip_hdr_clone(dlg->pool, rdata->msg_info.from);
    pjsip_fromto_hdr_set_to(dlg->remote.info);

    /* Print the remote info. */
    len = pjsip_uri_print(PJSIP_URI_IN_FROMTO_HDR,
			  dlg->remote.info->uri, tmp.ptr, TMP_LEN);
    if (len < 1) {
	pj_ansi_strcpy(tmp.ptr, ""<-error: uri too long->"");
	tmp.slen = pj_ansi_strlen(tmp.ptr);
    } else
	tmp.slen = len;

    /* Save the remote info. */
    pj_strdup(dlg->pool, &dlg->remote.info_str, &tmp);
    
    /* Save initial destination host from transport's info */
    pj_strdup(dlg->pool, &dlg->initial_dest,
    	      &rdata->tp_info.transport->remote_name.host);


    /* Init remote's contact from Contact header.
     * Iterate the Contact URI until we find sip: or sips: scheme.
     */
    do {
	contact_hdr = (pjsip_contact_hdr*)
		      pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT,
				         pos);
	if (contact_hdr) {
	    if (!contact_hdr->uri ||
		(!PJSIP_URI_SCHEME_IS_SIP(contact_hdr->uri) &&
		 !PJSIP_URI_SCHEME_IS_SIPS(contact_hdr->uri)))
	    {
		pos = (pjsip_hdr*)contact_hdr->next;
		if (pos == &rdata->msg_info.msg->hdr)
		    contact_hdr = NULL;
	    } else {
		break;
	    }
	}
    } while (contact_hdr);

    if (!contact_hdr) {
	status = PJSIP_ERRNO_FROM_SIP_STATUS(PJSIP_SC_BAD_REQUEST);
	goto on_error;
    }

    dlg->remote.contact = (pjsip_contact_hdr*)
    			  pjsip_hdr_clone(dlg->pool, (pjsip_hdr*)contact_hdr);

    /* Init remote's CSeq from CSeq header */
    dlg->remote.cseq = dlg->remote.first_cseq = rdata->msg_info.cseq->cseq;

    /* Set initial target to remote's Contact. */
    dlg->target = dlg->remote.contact->uri;

    /* Initial role is UAS */
    dlg->role = PJSIP_ROLE_UAS;

    /* Secure?
     *  RFC 3261 Section 12.1.1:
     *  If the request arrived over TLS, and the Request-URI contained a
     *  SIPS URI, the 'secure' flag is set to TRUE.
     */
    dlg->secure = PJSIP_TRANSPORT_IS_SECURE(rdata->tp_info.transport) &&
		  PJSIP_URI_SCHEME_IS_SIPS(rdata->msg_info.msg->line.req.uri);

    /* Call-ID */
    dlg->call_id = (pjsip_cid_hdr*)
    		   pjsip_hdr_clone(dlg->pool, rdata->msg_info.cid);

    /* Route set.
     *  RFC 3261 Section 12.1.1:
     *  The route set MUST be set to the list of URIs in the Record-Route
     *  header field from the request, taken in order and preserving all URI
     *  parameters. If no Record-Route header field is present in the request,
     * the route set MUST be set to the empty set.
     */
    pj_list_init(&dlg->route_set);
    rr = rdata->msg_info.record_route;
    while (rr != NULL) {
	pjsip_route_hdr *route;

	/* Clone the Record-Route, change the type to Route header. */
	route = (pjsip_route_hdr*) pjsip_hdr_clone(dlg->pool, rr);
	pjsip_routing_hdr_set_route(route);

	/* Add to route set. */
	pj_list_push_back(&dlg->route_set, route);

	/* Find next Record-Route header. */
	rr = rr->next;
	if (rr == (void*)&rdata->msg_info.msg->hdr)
	    break;
	rr = (pjsip_route_hdr*) pjsip_msg_find_hdr(rdata->msg_info.msg,
						   PJSIP_H_RECORD_ROUTE, rr);
    }
    dlg->route_set_frozen = PJ_TRUE;

    /* Increment the dialog's lock since tsx may cause the dialog to be
     * destroyed prematurely (such as in case of transport error).
     */
    if (inc_lock) {
        pjsip_dlg_inc_lock(dlg);
        lock_incremented = PJ_TRUE;
    }

    /* Create UAS transaction for this request. */
    status = pjsip_tsx_create_uas(dlg->ua, rdata, &tsx);
    if (status != PJ_SUCCESS)
	goto on_error;

    /* Associate this dialog to the transaction. */
    tsx->mod_data[dlg->ua->id] = dlg;

    /* Increment tsx counter */
    ++dlg->tsx_count;

    /* Calculate hash value of remote tag. */
    dlg->remote.tag_hval = pj_hash_calc_tolower(0, NULL, &dlg->remote.info->tag);

    /* Update remote capabilities info */
    pjsip_dlg_update_remote_cap(dlg, rdata->msg_info.msg, PJ_TRUE);

    /* Register this dialog to user agent. */
    status = pjsip_ua_register_dlg( ua, dlg );
    if (status != PJ_SUCCESS)
	goto on_error;

    /* Put this dialog in rdata's mod_data */
    rdata->endpt_info.mod_data[ua->id] = dlg;

    PJ_TODO(DIALOG_APP_TIMER);

    /* Feed the first request to the transaction. */
    pjsip_tsx_recv_msg(tsx, rdata);

    /* Done. */
    *p_dlg = dlg;
    PJ_LOG(5,(dlg->obj_name, ""UAS dialog created""));
    return PJ_SUCCESS;

on_error:
    if (tsx) {
	pjsip_tsx_terminate(tsx, 500);
	pj_assert(dlg->tsx_count>0);
	--dlg->tsx_count;
    }

    if (lock_incremented) {
        pjsip_dlg_dec_lock(dlg);
    } else {
        destroy_dialog(dlg, PJ_FALSE);
    }

    return status;
}","pj_status_t create_uas_dialog( pjsip_user_agent *VAR_0,
			       pjsip_rx_data *VAR_1,
			       const pj_str_t *VAR_2,
			       pj_bool_t VAR_3,
			       pjsip_dialog **VAR_4)
{
    pj_status_t VAR_5;
    pjsip_hdr *VAR_6 = NULL;
    pjsip_contact_hdr *VAR_7;
    pjsip_rr_hdr *VAR_8;
    pjsip_transaction *VAR_9 = NULL;
    pj_str_t VAR_10;
    enum { VAR_11=VAR_12 };
    pj_ssize_t VAR_13;
    pjsip_dialog *VAR_14;
    pj_bool_t VAR_15 = VAR_16;

    /* COMMENT_0 */
    PJ_ASSERT_RETURN(VAR_0 && VAR_1 && VAR_4, VAR_17);

    /* COMMENT_1 */
    PJ_ASSERT_RETURN(VAR_1->msg_info.msg->type == VAR_18,
		     VAR_19);

    /* COMMENT_2 */
                                                                         
       
    PJ_ASSERT_RETURN(VAR_1->msg_info.to->tag.slen == 0, VAR_20);

    /* COMMENT_5 */
    PJ_ASSERT_RETURN(
	pjsip_method_creates_dialog(&VAR_1->msg_info.msg->line.req.method),
	VAR_20);

    /* COMMENT_6 */
    VAR_5 = create_dialog(VAR_0, NULL, &VAR_14);
    if (VAR_5 != VAR_21)
	return VAR_5;

    /* COMMENT_7 */
                                 
       
    VAR_10.ptr = (char*) pj_pool_alloc(VAR_1->tp_info.pool, VAR_11);

    /* COMMENT_10 */
    VAR_14->local.info = (pjsip_fromto_hdr*)
    		      pjsip_hdr_clone(VAR_14->pool, VAR_1->msg_info.to);
    pjsip_fromto_hdr_set_from(VAR_14->local.info);

    /* COMMENT_11 */
    pj_create_unique_string(VAR_14->pool, &VAR_14->local.info->tag);


    /* COMMENT_12 */
    VAR_13 = pjsip_uri_print(VAR_22,
			  VAR_14->local.info->uri, VAR_10.ptr, VAR_11);
    if (VAR_13 < 1) {
	pj_ansi_strcpy(VAR_10.ptr, ""<-error: uri too long->"");
	VAR_10.slen = pj_ansi_strlen(VAR_10.ptr);
    } else
	VAR_10.slen = VAR_13;

    /* COMMENT_13 */
    pj_strdup(VAR_14->pool, &VAR_14->local.info_str, &VAR_10);

    /* COMMENT_14 */
    VAR_14->local.tag_hval = pj_hash_calc_tolower(0, NULL, &VAR_14->local.info->tag);


    /* COMMENT_15 */
    VAR_14->local.first_cseq = pj_rand() & 0x7FFF;
    VAR_14->local.cseq = VAR_14->local.first_cseq;

    /* COMMENT_16 */
    /* COMMENT_17 */
                                                                  
                                                                     
                                                                         
                                                                     
                                                                           
                           
       
    if (VAR_2) {
	pj_str_t VAR_23;

	pj_strdup_with_null(VAR_14->pool, &VAR_23, VAR_2);
	VAR_14->local.contact = (pjsip_contact_hdr*)
			     pjsip_parse_hdr(VAR_14->pool, &VAR_24, VAR_23.ptr,
					     VAR_23.slen, NULL);
	if (!VAR_14->local.contact) {
	    VAR_5 = VAR_25;
	    goto on_error;
	}

    } else {
	VAR_14->local.contact = pjsip_contact_hdr_create(VAR_14->pool);
	VAR_14->local.contact->uri = VAR_14->local.info->uri;
    }

    /* COMMENT_25 */
    VAR_14->remote.info = (pjsip_fromto_hdr*)
    		       pjsip_hdr_clone(VAR_14->pool, VAR_1->msg_info.from);
    pjsip_fromto_hdr_set_to(VAR_14->remote.info);

    /* COMMENT_26 */
    VAR_13 = pjsip_uri_print(VAR_22,
			  VAR_14->remote.info->uri, VAR_10.ptr, VAR_11);
    if (VAR_13 < 1) {
	pj_ansi_strcpy(VAR_10.ptr, ""<-error: uri too long->"");
	VAR_10.slen = pj_ansi_strlen(VAR_10.ptr);
    } else
	VAR_10.slen = VAR_13;

    /* COMMENT_27 */
    pj_strdup(VAR_14->pool, &VAR_14->remote.info_str, &VAR_10);
    
    /* COMMENT_28 */
    pj_strdup(VAR_14->pool, &VAR_14->initial_dest,
    	      &VAR_1->tp_info.transport->remote_name.host);


    /* COMMENT_29 */
                                                                  
       
    do {
	VAR_7 = (pjsip_contact_hdr*)
		      pjsip_msg_find_hdr(VAR_1->msg_info.msg, VAR_26,
				         VAR_6);
	if (VAR_7) {
	    if (!VAR_7->uri ||
		(!PJSIP_URI_SCHEME_IS_SIP(VAR_7->uri) &&
		 !PJSIP_URI_SCHEME_IS_SIPS(VAR_7->uri)))
	    {
		VAR_6 = (pjsip_hdr*)VAR_7->next;
		if (VAR_6 == &VAR_1->msg_info.msg->hdr)
		    VAR_7 = NULL;
	    } else {
		break;
	    }
	}
    } while (VAR_7);

    if (!VAR_7) {
	VAR_5 = PJSIP_ERRNO_FROM_SIP_STATUS(VAR_27);
	goto on_error;
    }

    VAR_14->remote.contact = (pjsip_contact_hdr*)
    			  pjsip_hdr_clone(VAR_14->pool, (pjsip_hdr*)VAR_7);

    /* COMMENT_32 */
    VAR_14->remote.cseq = VAR_14->remote.first_cseq = VAR_1->msg_info.cseq->cseq;

    /* COMMENT_33 */
    VAR_14->target = VAR_14->remote.contact->uri;

    /* COMMENT_34 */
    VAR_14->role = VAR_28;

    /* COMMENT_35 */
                                
                                                                        
                                                   
       
    VAR_14->secure = PJSIP_TRANSPORT_IS_SECURE(VAR_1->tp_info.transport) &&
		  PJSIP_URI_SCHEME_IS_SIPS(VAR_1->msg_info.msg->line.req.uri);

    /* COMMENT_40 */
    VAR_14->call_id = (pjsip_cid_hdr*)
    		   pjsip_hdr_clone(VAR_14->pool, VAR_1->msg_info.cid);

    /* COMMENT_41 */
                                
                                                                         
                                                                            
                                                                              
                                                  
       
    pj_list_init(&VAR_14->route_set);
    VAR_8 = VAR_1->msg_info.record_route;
    while (VAR_8 != NULL) {
	pjsip_route_hdr *VAR_29;

	/* COMMENT_48 */
	VAR_29 = (pjsip_route_hdr*) pjsip_hdr_clone(VAR_14->pool, VAR_8);
	pjsip_routing_hdr_set_route(VAR_29);

	/* COMMENT_49 */
	pj_list_push_back(&VAR_14->route_set, VAR_29);

	/* COMMENT_50 */
	VAR_8 = VAR_8->next;
	if (VAR_8 == (void*)&VAR_1->msg_info.msg->hdr)
	    break;
	VAR_8 = (pjsip_route_hdr*) pjsip_msg_find_hdr(VAR_1->msg_info.msg,
						   VAR_30, VAR_8);
    }
    VAR_14->route_set_frozen = VAR_31;

    /* COMMENT_51 */
                                                                  
       
    if (VAR_3) {
        pjsip_dlg_inc_lock(VAR_14);
        VAR_15 = VAR_31;
    }

    /* COMMENT_54 */
    VAR_5 = pjsip_tsx_create_uas(VAR_14->ua, VAR_1, &VAR_9);
    if (VAR_5 != VAR_21)
	goto on_error;

    /* COMMENT_55 */
    VAR_9->mod_data[VAR_14->ua->id] = VAR_14;

    /* COMMENT_56 */
    ++VAR_14->tsx_count;

    /* COMMENT_57 */
    VAR_14->remote.tag_hval = pj_hash_calc_tolower(0, NULL, &VAR_14->remote.info->tag);

    /* COMMENT_58 */
    pjsip_dlg_update_remote_cap(VAR_14, VAR_1->msg_info.msg, VAR_31);

    /* COMMENT_59 */
    VAR_5 = pjsip_ua_register_dlg( VAR_0, VAR_14 );
    if (VAR_5 != VAR_21)
	goto on_error;

    /* COMMENT_60 */
    VAR_1->endpt_info.mod_data[VAR_0->id] = VAR_14;

    PJ_TODO(VAR_32);

    /* COMMENT_61 */
    pjsip_tsx_recv_msg(VAR_9, VAR_1);

    /* COMMENT_62 */
    *VAR_4 = VAR_14;
    PJ_LOG(5,(VAR_14->obj_name, ""UAS dialog created""));
    return VAR_21;

on_error:
    if (VAR_9) {
	pjsip_tsx_terminate(VAR_9, 500);
	pj_assert(VAR_14->tsx_count>0);
	--VAR_14->tsx_count;
    }

    if (VAR_15) {
        pjsip_dlg_dec_lock(VAR_14);
    } else {
        destroy_dialog(VAR_14, VAR_16);
    }

    return VAR_5;
}",pjsip/pjproject/67e46c1ac45ad784db5b9080f5ed8b133c122872/sip_dialog.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -113,6 +113,10 @@
 
     /* Save the remote info. */
     pj_strdup(dlg->pool, &dlg->remote.info_str, &tmp);
+    
+    /* Save initial destination host from transport's info */
+    pj_strdup(dlg->pool, &dlg->initial_dest,
+    	      &rdata->tp_info.transport->remote_name.host);
 
 
     /* Init remote's contact from Contact header.","{'deleted_lines': [], 'added_lines': ['    ', ""    /* Save initial destination host from transport's info */"", '    pj_strdup(dlg->pool, &dlg->initial_dest,', '    \t      &rdata->tp_info.transport->remote_name.host);']}",True,"PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In version 2.10 and earlier, PJSIP transport can be reused if they have the same IP address + port + protocol. However, this is insufficient for secure transport since it lacks remote hostname authentication. Suppose we have created a TLS connection to `sip.foo.com`, which has an IP address `100.1.1.1`. If we want to create a TLS connection to another hostname, say `sip.bar.com`, which has the same IP address, then it will reuse that existing connection, even though `100.1.1.1` does not have certificate to authenticate as `sip.bar.com`. The vulnerability allows for an insecure interaction without user awareness. It affects users who need access to connections to different destinations that translate to the same address, and allows man-in-the-middle attack if attacker can route a connection to another destination such as in the case of DNS spoofing.",6.8,MEDIUM,1,valid,2021-03-08T09:39:36Z,3
CVE-2020-15260,['CWE-295'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,pjsip/pjproject,"Merge pull request from GHSA-8hcp-hm38-mfph

* Check hostname during TLS transport selection

* revision based on feedback

* remove the code in create_request that has been moved",67e46c1ac45ad784db5b9080f5ed8b133c122872,https://github.com/pjsip/pjproject/commit/67e46c1ac45ad784db5b9080f5ed8b133c122872,pjsip/src/pjsip/sip_dialog.c,dlg_create_request_throw,"static pj_status_t dlg_create_request_throw( pjsip_dialog *dlg,
const pjsip_method *method,
int cseq,
pjsip_tx_data **p_tdata )
{
pjsip_tx_data *tdata;
pjsip_contact_hdr *contact;
pjsip_route_hdr *route, *end_list;
pj_status_t status;
if (pjsip_method_creates_dialog(method))
contact = dlg->local.contact;
else
contact = NULL;
status = pjsip_endpt_create_request_from_hdr(dlg->endpt,
method,
dlg->target,
dlg->local.info,
dlg->remote.info,
contact,
dlg->call_id,
cseq,
NULL,
&tdata);
if (status != PJ_SUCCESS)
return status;
tdata->mod_data[dlg->ua->id] = dlg;
route = dlg->route_set.next;
end_list = &dlg->route_set;
for (; route != end_list; route = route->next ) {
pjsip_route_hdr *r;
r = (pjsip_route_hdr*) pjsip_hdr_shallow_clone( tdata->pool, route );
pjsip_routing_hdr_set_route(r);
pjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)r);
}
if (method->id != PJSIP_ACK_METHOD && method->id != PJSIP_CANCEL_METHOD) {
status = pjsip_auth_clt_init_req( &dlg->auth_sess, tdata );
if (status != PJ_SUCCESS)
return status;
}
*p_tdata = tdata;
return PJ_SUCCESS;
}","static pj_status_t dlg_create_request_throw( pjsip_dialog *VAR_0,
const pjsip_method *VAR_1,
int VAR_2,
pjsip_tx_data **VAR_3 )
{
pjsip_tx_data *VAR_4;
pjsip_contact_hdr *VAR_5;
pjsip_route_hdr *VAR_6, *VAR_7;
pj_status_t VAR_8;
if (pjsip_method_creates_dialog(VAR_1))
VAR_5 = VAR_0->local.contact;
else
VAR_5 = NULL;
VAR_8 = pjsip_endpt_create_request_from_hdr(VAR_0->endpt,
VAR_1,
VAR_0->target,
VAR_0->local.info,
VAR_0->remote.info,
VAR_5,
VAR_0->call_id,
VAR_2,
NULL,
&VAR_4);
if (VAR_8 != VAR_9)
return VAR_8;
VAR_4->mod_data[VAR_0->ua->id] = VAR_0;
VAR_6 = VAR_0->route_set.next;
VAR_7 = &VAR_0->route_set;
for (; VAR_6 != VAR_7; VAR_6 = VAR_6->next ) {
pjsip_route_hdr *VAR_10;
VAR_10 = (pjsip_route_hdr*) pjsip_hdr_shallow_clone( VAR_4->pool, VAR_6 );
pjsip_routing_hdr_set_route(VAR_10);
pjsip_msg_add_hdr(VAR_4->msg, (pjsip_hdr*)VAR_10);
}
if (VAR_1->id != VAR_11 && VAR_1->id != VAR_12) {
VAR_8 = pjsip_auth_clt_init_req( &VAR_0->auth_sess, VAR_4 );
if (VAR_8 != VAR_9)
return VAR_8;
}
*VAR_3 = VAR_4;
return VAR_9;
}",pjsip/pjproject/67e46c1ac45ad784db5b9080f5ed8b133c122872/sip_dialog.c/vul/before/0.json,"static pj_status_t dlg_create_request_throw( pjsip_dialog *dlg,
					     const pjsip_method *method,
					     int cseq,
					     pjsip_tx_data **p_tdata )
{
    pjsip_tx_data *tdata;
    pjsip_contact_hdr *contact;
    pjsip_route_hdr *route, *end_list;
    pj_status_t status;

    /* Contact Header field.
     * Contact can only be present in requests that establish dialog (in the
     * core SIP spec, only INVITE).
     */
    if (pjsip_method_creates_dialog(method))
	contact = dlg->local.contact;
    else
	contact = NULL;

    /*
     * Create the request by cloning from the headers in the
     * dialog.
     */
    status = pjsip_endpt_create_request_from_hdr(dlg->endpt,
						 method,
						 dlg->target,
						 dlg->local.info,
						 dlg->remote.info,
						 contact,
						 dlg->call_id,
						 cseq,
						 NULL,
						 &tdata);
    if (status != PJ_SUCCESS)
	return status;

    /* Put this dialog in tdata's mod_data */
    tdata->mod_data[dlg->ua->id] = dlg;

    /* Just copy dialog route-set to Route header.
     * The transaction will do the processing as specified in Section 12.2.1
     * of RFC 3261 in function tsx_process_route() in sip_transaction.c.
     */
    route = dlg->route_set.next;
    end_list = &dlg->route_set;
    for (; route != end_list; route = route->next ) {
	pjsip_route_hdr *r;
	r = (pjsip_route_hdr*) pjsip_hdr_shallow_clone( tdata->pool, route );
	pjsip_routing_hdr_set_route(r);
	pjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)r);
    }

    /* Copy authorization headers, if request is not ACK or CANCEL. */
    if (method->id != PJSIP_ACK_METHOD && method->id != PJSIP_CANCEL_METHOD) {
	status = pjsip_auth_clt_init_req( &dlg->auth_sess, tdata );
	if (status != PJ_SUCCESS)
	    return status;
    }

    /* Copy the initial destination host to tdata. This information can be
     * used later by transport for transport selection.
     */
    if (dlg->initial_dest.slen)
    	pj_strdup(tdata->pool, &tdata->dest_info.name, &dlg->initial_dest);

    /* Done. */
    *p_tdata = tdata;

    return PJ_SUCCESS;
}","static pj_status_t dlg_create_request_throw( pjsip_dialog *VAR_0,
					     const pjsip_method *VAR_1,
					     int VAR_2,
					     pjsip_tx_data **VAR_3 )
{
    pjsip_tx_data *VAR_4;
    pjsip_contact_hdr *VAR_5;
    pjsip_route_hdr *VAR_6, *VAR_7;
    pj_status_t VAR_8;

    /* COMMENT_0 */
                                                                            
                                   
       
    if (pjsip_method_creates_dialog(VAR_1))
	VAR_5 = VAR_0->local.contact;
    else
	VAR_5 = NULL;

    /* COMMENT_4 */
                                                            
              
       
    VAR_8 = pjsip_endpt_create_request_from_hdr(VAR_0->endpt,
						 VAR_1,
						 VAR_0->target,
						 VAR_0->local.info,
						 VAR_0->remote.info,
						 VAR_5,
						 VAR_0->call_id,
						 VAR_2,
						 NULL,
						 &VAR_4);
    if (VAR_8 != VAR_9)
	return VAR_8;

    /* COMMENT_8 */
    VAR_4->mod_data[VAR_0->ua->id] = VAR_0;

    /* COMMENT_9 */
                                                                            
                                                                        
       
    VAR_6 = VAR_0->route_set.next;
    VAR_7 = &VAR_0->route_set;
    for (; VAR_6 != VAR_7; VAR_6 = VAR_6->next ) {
	pjsip_route_hdr *VAR_10;
	VAR_10 = (pjsip_route_hdr*) pjsip_hdr_shallow_clone( VAR_4->pool, VAR_6 );
	pjsip_routing_hdr_set_route(VAR_10);
	pjsip_msg_add_hdr(VAR_4->msg, (pjsip_hdr*)VAR_10);
    }

    /* COMMENT_13 */
    if (VAR_1->id != VAR_11 && VAR_1->id != VAR_12) {
	VAR_8 = pjsip_auth_clt_init_req( &VAR_0->auth_sess, VAR_4 );
	if (VAR_8 != VAR_9)
	    return VAR_8;
    }

    /* COMMENT_14 */
                                                       
       
    if (VAR_0->initial_dest.slen)
    	pj_strdup(VAR_4->pool, &VAR_4->dest_info.name, &VAR_0->initial_dest);

    /* COMMENT_17 */
    *VAR_3 = VAR_4;

    return VAR_9;
}",pjsip/pjproject/67e46c1ac45ad784db5b9080f5ed8b133c122872/sip_dialog.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -57,6 +57,12 @@
 	    return status;
     }
 
+    /* Copy the initial destination host to tdata. This information can be
+     * used later by transport for transport selection.
+     */
+    if (dlg->initial_dest.slen)
+    	pj_strdup(tdata->pool, &tdata->dest_info.name, &dlg->initial_dest);
+
     /* Done. */
     *p_tdata = tdata;
 ","{'deleted_lines': [], 'added_lines': ['    /* Copy the initial destination host to tdata. This information can be', '     * used later by transport for transport selection.', '     */', '    if (dlg->initial_dest.slen)', '    \tpj_strdup(tdata->pool, &tdata->dest_info.name, &dlg->initial_dest);', '']}",True,"PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In version 2.10 and earlier, PJSIP transport can be reused if they have the same IP address + port + protocol. However, this is insufficient for secure transport since it lacks remote hostname authentication. Suppose we have created a TLS connection to `sip.foo.com`, which has an IP address `100.1.1.1`. If we want to create a TLS connection to another hostname, say `sip.bar.com`, which has the same IP address, then it will reuse that existing connection, even though `100.1.1.1` does not have certificate to authenticate as `sip.bar.com`. The vulnerability allows for an insecure interaction without user awareness. It affects users who need access to connections to different destinations that translate to the same address, and allows man-in-the-middle attack if attacker can route a connection to another destination such as in the case of DNS spoofing.",6.8,MEDIUM,1,valid,2021-03-08T09:39:36Z,3
CVE-2020-15260,['CWE-295'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,pjsip/pjproject,"Merge pull request from GHSA-8hcp-hm38-mfph

* Check hostname during TLS transport selection

* revision based on feedback

* remove the code in create_request that has been moved",67e46c1ac45ad784db5b9080f5ed8b133c122872,https://github.com/pjsip/pjproject/commit/67e46c1ac45ad784db5b9080f5ed8b133c122872,pjsip/src/pjsip/sip_util.c,pjsip_endpt_send_response,"PJ_DEF(pj_status_t) pjsip_endpt_send_response( pjsip_endpoint *endpt,
pjsip_response_addr *res_addr,
pjsip_tx_data *tdata,
void *token,
pjsip_send_callback cb)
{
pjsip_send_state *send_state;
pj_status_t status;
send_state = PJ_POOL_ZALLOC_T(tdata->pool, pjsip_send_state);
send_state->endpt = endpt;
send_state->tdata = tdata;
send_state->token = token;
send_state->app_cb = cb;
if (res_addr->transport != NULL) {
send_state->cur_transport = res_addr->transport;
pjsip_transport_add_ref(send_state->cur_transport);
status = pjsip_transport_send( send_state->cur_transport, tdata, 
&res_addr->addr,
res_addr->addr_len,
send_state,
&send_response_transport_cb );
if (status == PJ_SUCCESS) {
pj_ssize_t sent = tdata->buf.cur - tdata->buf.start;
send_response_transport_cb(send_state, tdata, sent);
return PJ_SUCCESS;
} else if (status == PJ_EPENDING) {
return PJ_SUCCESS;
} else {
pjsip_transport_dec_ref(send_state->cur_transport);
return status;
}
} else {
pj_strdup(tdata->pool, &tdata->dest_info.name, 
&res_addr->dst_host.addr.host);
pjsip_endpt_resolve(endpt, tdata->pool, &res_addr->dst_host, 
send_state, &send_response_resolver_cb);
return PJ_SUCCESS;
}
}","VAR_0(pj_status_t) pjsip_endpt_send_response( pjsip_endpoint *VAR_1,
pjsip_response_addr *VAR_2,
pjsip_tx_data *VAR_3,
void *VAR_4,
pjsip_send_callback VAR_5)
{
pjsip_send_state *VAR_6;
pj_status_t VAR_7;
VAR_6 = PJ_POOL_ZALLOC_T(VAR_3->pool, pjsip_send_state);
VAR_6->endpt = VAR_1;
VAR_6->tdata = VAR_3;
VAR_6->token = VAR_4;
VAR_6->app_cb = VAR_5;
if (VAR_2->transport != NULL) {
VAR_6->cur_transport = VAR_2->transport;
pjsip_transport_add_ref(VAR_6->cur_transport);
VAR_7 = pjsip_transport_send( VAR_6->cur_transport, VAR_3, 
&VAR_2->addr,
VAR_2->addr_len,
VAR_6,
&VAR_8 );
if (VAR_7 == VAR_9) {
pj_ssize_t VAR_10 = VAR_3->buf.cur - VAR_3->buf.start;
VAR_8(VAR_6, VAR_3, VAR_10);
return VAR_9;
} else if (VAR_7 == VAR_11) {
return VAR_9;
} else {
pjsip_transport_dec_ref(VAR_6->cur_transport);
return VAR_7;
}
} else {
pj_strdup(VAR_3->pool, &VAR_3->dest_info.name, 
&VAR_2->dst_host.addr.host);
pjsip_endpt_resolve(VAR_1, VAR_3->pool, &VAR_2->dst_host, 
VAR_6, &VAR_12);
return VAR_9;
}
}",,"PJ_DEF(pj_status_t) pjsip_endpt_send_response( pjsip_endpoint *endpt,
					       pjsip_response_addr *res_addr,
					       pjsip_tx_data *tdata,
					       void *token,
					       pjsip_send_callback cb)
{
    /* Determine which transports and addresses to send the response,
     * based on Section 18.2.2 of RFC 3261.
     */
    pjsip_send_state *send_state;
    pj_status_t status;

    /* Create structure to keep the sending state. */
    send_state = PJ_POOL_ZALLOC_T(tdata->pool, pjsip_send_state);
    send_state->endpt = endpt;
    send_state->tdata = tdata;
    send_state->token = token;
    send_state->app_cb = cb;

    if (res_addr->transport != NULL) {
	send_state->cur_transport = res_addr->transport;
	pjsip_transport_add_ref(send_state->cur_transport);

	status = pjsip_transport_send( send_state->cur_transport, tdata, 
				       &res_addr->addr,
				       res_addr->addr_len,
				       send_state,
				       &send_response_transport_cb );
	if (status == PJ_SUCCESS) {
	    pj_ssize_t sent = tdata->buf.cur - tdata->buf.start;
	    send_response_transport_cb(send_state, tdata, sent);
	    return PJ_SUCCESS;
	} else if (status == PJ_EPENDING) {
	    /* Callback will be called later. */
	    return PJ_SUCCESS;
	} else {
	    pjsip_transport_dec_ref(send_state->cur_transport);
	    return status;
	}
    } else {
	/* Copy the destination host name to TX data */
	if (!tdata->dest_info.name.slen) {
	    pj_strdup(tdata->pool, &tdata->dest_info.name, 
		      &res_addr->dst_host.addr.host);
	}

	pjsip_endpt_resolve(endpt, tdata->pool, &res_addr->dst_host, 
			    send_state, &send_response_resolver_cb);
	return PJ_SUCCESS;
    }
}","VAR_0(pj_status_t) pjsip_endpt_send_response( pjsip_endpoint *VAR_1,
					       pjsip_response_addr *VAR_2,
					       pjsip_tx_data *VAR_3,
					       void *VAR_4,
					       pjsip_send_callback VAR_5)
{
    /* COMMENT_0 */
                                           
       
    pjsip_send_state *VAR_6;
    pj_status_t VAR_7;

    /* COMMENT_3 */
    VAR_6 = PJ_POOL_ZALLOC_T(VAR_3->pool, pjsip_send_state);
    VAR_6->endpt = VAR_1;
    VAR_6->tdata = VAR_3;
    VAR_6->token = VAR_4;
    VAR_6->app_cb = VAR_5;

    if (VAR_2->transport != NULL) {
	VAR_6->cur_transport = VAR_2->transport;
	pjsip_transport_add_ref(VAR_6->cur_transport);

	VAR_7 = pjsip_transport_send( VAR_6->cur_transport, VAR_3, 
				       &VAR_2->addr,
				       VAR_2->addr_len,
				       VAR_6,
				       &VAR_8 );
	if (VAR_7 == VAR_9) {
	    pj_ssize_t VAR_10 = VAR_3->buf.cur - VAR_3->buf.start;
	    VAR_8(VAR_6, VAR_3, VAR_10);
	    return VAR_9;
	} else if (VAR_7 == VAR_11) {
	    /* COMMENT_4 */
	    return VAR_9;
	} else {
	    pjsip_transport_dec_ref(VAR_6->cur_transport);
	    return VAR_7;
	}
    } else {
	/* COMMENT_5 */
	if (!VAR_3->dest_info.name.slen) {
	    pj_strdup(VAR_3->pool, &VAR_3->dest_info.name, 
		      &VAR_2->dst_host.addr.host);
	}

	pjsip_endpt_resolve(VAR_1, VAR_3->pool, &VAR_2->dst_host, 
			    VAR_6, &VAR_12);
	return VAR_9;
    }
}",,"--- func_before
+++ func_after
@@ -39,8 +39,10 @@
 	}
     } else {
 	/* Copy the destination host name to TX data */
-	pj_strdup(tdata->pool, &tdata->dest_info.name, 
-		  &res_addr->dst_host.addr.host);
+	if (!tdata->dest_info.name.slen) {
+	    pj_strdup(tdata->pool, &tdata->dest_info.name, 
+		      &res_addr->dst_host.addr.host);
+	}
 
 	pjsip_endpt_resolve(endpt, tdata->pool, &res_addr->dst_host, 
 			    send_state, &send_response_resolver_cb);","{'deleted_lines': ['\tpj_strdup(tdata->pool, &tdata->dest_info.name, ', '\t\t  &res_addr->dst_host.addr.host);'], 'added_lines': ['\tif (!tdata->dest_info.name.slen) {', '\t    pj_strdup(tdata->pool, &tdata->dest_info.name, ', '\t\t      &res_addr->dst_host.addr.host);', '\t}']}",True,"PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In version 2.10 and earlier, PJSIP transport can be reused if they have the same IP address + port + protocol. However, this is insufficient for secure transport since it lacks remote hostname authentication. Suppose we have created a TLS connection to `sip.foo.com`, which has an IP address `100.1.1.1`. If we want to create a TLS connection to another hostname, say `sip.bar.com`, which has the same IP address, then it will reuse that existing connection, even though `100.1.1.1` does not have certificate to authenticate as `sip.bar.com`. The vulnerability allows for an insecure interaction without user awareness. It affects users who need access to connections to different destinations that translate to the same address, and allows man-in-the-middle attack if attacker can route a connection to another destination such as in the case of DNS spoofing.",6.8,MEDIUM,1,valid,2021-03-08T09:39:36Z,3
CVE-2021-21417,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,FluidSynth/fluidsynth,"Invalid generator were not removed from list

fluid_list_remove() should receive the beginning of a list, so it can adjust the predecessor of the element to be removed. Otherwise the element would remain in the list, which in this case led to a use-after-free afterwards.",67596a87731dc593551975ca0268a438ab7410a2,https://github.com/FluidSynth/fluidsynth/commit/67596a87731dc593551975ca0268a438ab7410a2,src/sfloader/fluid_sffile.c,load_pgen,"static int load_pgen(SFData *sf, int size)
{
fluid_list_t *p, *p2, *p3, *dup, **hz = NULL;
SFZone *z;
SFGen *g;
SFGenAmount genval;
unsigned short genid;
int level, skip, drop, gzone, discarded;
p = sf->preset;
while(p)
{
gzone = FALSE;
discarded = FALSE;
p2 = ((SFPreset *)(p->data))->zone;
if(p2)
{
hz = &p2;
}
while(p2)
{
level = 0;
z = (SFZone *)(p2->data);
p3 = z->gen;
while(p3)
{
dup = NULL;
skip = FALSE;
drop = FALSE;
if((size -= SF_GEN_SIZE) < 0)
{
FLUID_LOG(FLUID_ERR, ""Preset generator chunk size mismatch"");
return FALSE;
}
READW(sf, genid);
if(genid == Gen_KeyRange)
{
if(level == 0)
{
level = 1;
READB(sf, genval.range.lo);
READB(sf, genval.range.hi);
}
else
{
skip = TRUE;
}
}
else if(genid == Gen_VelRange)
{
if(level <= 1)
{
level = 2;
READB(sf, genval.range.lo);
READB(sf, genval.range.hi);
}
else
{
skip = TRUE;
}
}
else if(genid == Gen_Instrument)
{
level = 3;
READW(sf, genval.uword);
((SFZone *)(p2->data))->instsamp = FLUID_INT_TO_POINTER(genval.uword + 1);
break; 
}
else
{
level = 2;
if(valid_preset_genid(genid))
{
READW(sf, genval.sword);
dup = find_gen_by_id(genid, z->gen);
}
else
{
skip = TRUE;
}
}
if(!skip)
{
if(!dup)
{
if((g = FLUID_NEW(SFGen)) == NULL)
{
FLUID_LOG(FLUID_ERR, ""Out of memory"");
return FALSE;
}
p3->data = g;
g->id = genid;
}
else
{
g = (SFGen *)(dup->data); 
drop = TRUE;
}
g->amount = genval;
}
else
{
discarded = TRUE;
drop = TRUE;
FSKIPW(sf);
}
if(!drop)
{
p3 = fluid_list_next(p3);    
}
else
{
SLADVREM(z->gen, p3);    
}
} 
if(level == 3)
{
SLADVREM(z->gen, p3);    
}
else
{
if(!gzone)
{
gzone = TRUE;
if(*hz != p2)
{
void *save = p2->data;
FLUID_LOG(FLUID_WARN, ""Preset '%s': Global zone is not first zone"",
((SFPreset *)(p->data))->name);
SLADVREM(*hz, p2);
*hz = fluid_list_prepend(*hz, save);
continue;
}
}
else
{
FLUID_LOG(FLUID_WARN, ""Preset '%s': Discarding invalid global zone"",
((SFPreset *)(p->data))->name);
*hz = fluid_list_remove(*hz, p2->data);
delete_zone((SFZone *)fluid_list_get(p2));
}
}
while(p3)
{
discarded = TRUE;
if((size -= SF_GEN_SIZE) < 0)
{
FLUID_LOG(FLUID_ERR, ""Preset generator chunk size mismatch"");
return FALSE;
}
FSKIP(sf, SF_GEN_SIZE);
SLADVREM(z->gen, p3);
}
p2 = fluid_list_next(p2); 
}
if(discarded)
{
FLUID_LOG(FLUID_WARN,
""Preset '%s': Some invalid generators were discarded"",
((SFPreset *)(p->data))->name);
}
p = fluid_list_next(p);
}
if(size == 0)
{
return TRUE;
}
size -= SF_GEN_SIZE;
if(size != 0)
{
FLUID_LOG(FLUID_ERR, ""Preset generator chunk size mismatch"");
return FALSE;
}
FSKIP(sf, SF_GEN_SIZE); 
return TRUE;
}","static int load_pgen(SFData *VAR_0, int VAR_1)
{
fluid_list_t *VAR_2, *VAR_3, *VAR_4, *VAR_5, **VAR_6 = NULL;
SFZone *VAR_7;
SFGen *VAR_8;
SFGenAmount VAR_9;
unsigned short VAR_10;
int VAR_11, VAR_12, VAR_13, VAR_14, VAR_15;
VAR_2 = VAR_0->preset;
while(VAR_2)
{
VAR_14 = FALSE;
VAR_15 = FALSE;
VAR_3 = ((SFPreset *)(VAR_2->data))->zone;
if(VAR_3)
{
VAR_6 = &VAR_3;
}
while(VAR_3)
{
VAR_11 = 0;
VAR_7 = (SFZone *)(VAR_3->data);
VAR_4 = VAR_7->gen;
while(VAR_4)
{
VAR_5 = NULL;
VAR_12 = FALSE;
VAR_13 = FALSE;
if((VAR_1 -= VAR_16) < 0)
{
FLUID_LOG(VAR_17, ""Preset generator chunk size mismatch"");
return FALSE;
}
READW(VAR_0, VAR_10);
if(VAR_10 == VAR_18)
{
if(VAR_11 == 0)
{
VAR_11 = 1;
READB(VAR_0, VAR_9.range.lo);
READB(VAR_0, VAR_9.range.hi);
}
else
{
VAR_12 = TRUE;
}
}
else if(VAR_10 == VAR_19)
{
if(VAR_11 <= 1)
{
VAR_11 = 2;
READB(VAR_0, VAR_9.range.lo);
READB(VAR_0, VAR_9.range.hi);
}
else
{
VAR_12 = TRUE;
}
}
else if(VAR_10 == VAR_20)
{
VAR_11 = 3;
READW(VAR_0, VAR_9.uword);
((SFZone *)(VAR_3->data))->instsamp = FLUID_INT_TO_POINTER(VAR_9.uword + 1);
break; 
}
else
{
VAR_11 = 2;
if(valid_preset_genid(VAR_10))
{
READW(VAR_0, VAR_9.sword);
VAR_5 = find_gen_by_id(VAR_10, VAR_7->gen);
}
else
{
VAR_12 = TRUE;
}
}
if(!VAR_12)
{
if(!VAR_5)
{
if((VAR_8 = FLUID_NEW(SFGen)) == NULL)
{
FLUID_LOG(VAR_17, ""Out of memory"");
return FALSE;
}
VAR_4->data = VAR_8;
VAR_8->id = VAR_10;
}
else
{
VAR_8 = (SFGen *)(VAR_5->data); 
VAR_13 = TRUE;
}
VAR_8->amount = VAR_9;
}
else
{
VAR_15 = TRUE;
VAR_13 = TRUE;
FSKIPW(VAR_0);
}
if(!VAR_13)
{
VAR_4 = fluid_list_next(VAR_4);    
}
else
{
SLADVREM(VAR_7->gen, VAR_4);    
}
} 
if(VAR_11 == 3)
{
SLADVREM(VAR_7->gen, VAR_4);    
}
else
{
if(!VAR_14)
{
VAR_14 = TRUE;
if(*VAR_6 != VAR_3)
{
void *VAR_21 = VAR_3->data;
FLUID_LOG(VAR_22, ""Preset '%s': Global zone is not first zone"",
((SFPreset *)(VAR_2->data))->name);
SLADVREM(*VAR_6, VAR_3);
*VAR_6 = fluid_list_prepend(*VAR_6, VAR_21);
continue;
}
}
else
{
FLUID_LOG(VAR_22, ""Preset '%s': Discarding invalid global zone"",
((SFPreset *)(VAR_2->data))->name);
*VAR_6 = fluid_list_remove(*VAR_6, VAR_3->data);
delete_zone((SFZone *)fluid_list_get(VAR_3));
}
}
while(VAR_4)
{
VAR_15 = TRUE;
if((VAR_1 -= VAR_16) < 0)
{
FLUID_LOG(VAR_17, ""Preset generator chunk size mismatch"");
return FALSE;
}
FSKIP(VAR_0, VAR_16);
SLADVREM(VAR_7->gen, VAR_4);
}
VAR_3 = fluid_list_next(VAR_3); 
}
if(VAR_15)
{
FLUID_LOG(VAR_22,
""Preset '%s': Some invalid generators were discarded"",
((SFPreset *)(VAR_2->data))->name);
}
VAR_2 = fluid_list_next(VAR_2);
}
if(VAR_1 == 0)
{
return TRUE;
}
VAR_1 -= VAR_16;
if(VAR_1 != 0)
{
FLUID_LOG(VAR_17, ""Preset generator chunk size mismatch"");
return FALSE;
}
FSKIP(VAR_0, VAR_16); 
return TRUE;
}",FluidSynth/fluidsynth/67596a87731dc593551975ca0268a438ab7410a2/fluid_sffile.c/vul/before/1.json,"static int load_pgen(SFData *sf, int size)
{
    fluid_list_t *p, *p2, *p3, *dup, **hz = NULL, *start_of_zone_list;
    SFZone *z;
    SFGen *g;
    SFGenAmount genval;
    unsigned short genid;
    int level, skip, drop, gzone, discarded;

    p = sf->preset;

    while(p)
    {
        /* traverse through all presets */
        gzone = FALSE;
        discarded = FALSE;
        start_of_zone_list = p2 = ((SFPreset *)(p->data))->zone;

        if(p2)
        {
            hz = &p2;
        }

        while(p2)
        {
            /* traverse preset's zones */
            level = 0;
            z = (SFZone *)(p2->data);
            p3 = z->gen;

            while(p3)
            {
                /* load zone's generators */
                dup = NULL;
                skip = FALSE;
                drop = FALSE;

                if((size -= SF_GEN_SIZE) < 0)
                {
                    FLUID_LOG(FLUID_ERR, ""Preset generator chunk size mismatch"");
                    return FALSE;
                }

                READW(sf, genid);

                if(genid == Gen_KeyRange)
                {
                    /* nothing precedes */
                    if(level == 0)
                    {
                        level = 1;
                        READB(sf, genval.range.lo);
                        READB(sf, genval.range.hi);
                    }
                    else
                    {
                        skip = TRUE;
                    }
                }
                else if(genid == Gen_VelRange)
                {
                    /* only KeyRange precedes */
                    if(level <= 1)
                    {
                        level = 2;
                        READB(sf, genval.range.lo);
                        READB(sf, genval.range.hi);
                    }
                    else
                    {
                        skip = TRUE;
                    }
                }
                else if(genid == Gen_Instrument)
                {
                    /* inst is last gen */
                    level = 3;
                    READW(sf, genval.uword);
                    ((SFZone *)(p2->data))->instsamp = FLUID_INT_TO_POINTER(genval.uword + 1);
                    break; /* break out of generator loop */
                }
                else
                {
                    level = 2;

                    if(valid_preset_genid(genid))
                    {
                        /* generator valid? */
                        READW(sf, genval.sword);
                        dup = find_gen_by_id(genid, z->gen);
                    }
                    else
                    {
                        skip = TRUE;
                    }
                }

                if(!skip)
                {
                    if(!dup)
                    {
                        /* if gen ! dup alloc new */
                        if((g = FLUID_NEW(SFGen)) == NULL)
                        {
                            FLUID_LOG(FLUID_ERR, ""Out of memory"");
                            return FALSE;
                        }

                        p3->data = g;
                        g->id = genid;
                    }
                    else
                    {
                        g = (SFGen *)(dup->data); /* ptr to orig gen */
                        drop = TRUE;
                    }

                    g->amount = genval;
                }
                else
                {
                    /* Skip this generator */
                    discarded = TRUE;
                    drop = TRUE;
                    FSKIPW(sf);
                }

                if(!drop)
                {
                    p3 = fluid_list_next(p3);    /* next gen */
                }
                else
                {
                    SLADVREM(z->gen, p3);    /* drop place holder */
                }

            } /* generator loop */

            if(level == 3)
            {
                SLADVREM(z->gen, p3);    /* zone has inst? */
            }
            else
            {
                /* congratulations its a global zone */
                if(!gzone)
                {
                    /* Prior global zones? */
                    gzone = TRUE;

                    /* if global zone is not 1st zone, relocate */
                    if(*hz != p2)
                    {
                        void *save = p2->data;
                        FLUID_LOG(FLUID_WARN, ""Preset '%s': Global zone is not first zone"",
                                  ((SFPreset *)(p->data))->name);
                        SLADVREM(*hz, p2);
                        *hz = fluid_list_prepend(*hz, save);
                        continue;
                    }
                }
                else
                {
                    SFZone * pzone = fluid_list_get(p2);
                    /* previous global zone exists, discard */
                    FLUID_LOG(FLUID_WARN, ""Preset '%s': Discarding invalid global zone"",
                              ((SFPreset *)(p->data))->name);
                    *hz = fluid_list_remove(start_of_zone_list, pzone);
                    delete_zone(pzone);
                }
            }

            while(p3)
            {
                /* Kill any zones following an instrument */
                discarded = TRUE;

                if((size -= SF_GEN_SIZE) < 0)
                {
                    FLUID_LOG(FLUID_ERR, ""Preset generator chunk size mismatch"");
                    return FALSE;
                }

                FSKIP(sf, SF_GEN_SIZE);
                SLADVREM(z->gen, p3);
            }

            p2 = fluid_list_next(p2); /* next zone */
        }

        if(discarded)
        {
            FLUID_LOG(FLUID_WARN,
                      ""Preset '%s': Some invalid generators were discarded"",
                      ((SFPreset *)(p->data))->name);
        }

        p = fluid_list_next(p);
    }

    /* in case there isn't a terminal record */
    if(size == 0)
    {
        return TRUE;
    }

    size -= SF_GEN_SIZE;

    if(size != 0)
    {
        FLUID_LOG(FLUID_ERR, ""Preset generator chunk size mismatch"");
        return FALSE;
    }

    FSKIP(sf, SF_GEN_SIZE); /* terminal gen */

    return TRUE;
}","static int load_pgen(SFData *VAR_0, int VAR_1)
{
    fluid_list_t *VAR_2, *VAR_3, *VAR_4, *VAR_5, **VAR_6 = NULL, *VAR_7;
    SFZone *VAR_8;
    SFGen *VAR_9;
    SFGenAmount VAR_10;
    unsigned short VAR_11;
    int VAR_12, VAR_13, VAR_14, VAR_15, VAR_16;

    VAR_2 = VAR_0->preset;

    while(VAR_2)
    {
        /* COMMENT_0 */
        VAR_15 = FALSE;
        VAR_16 = FALSE;
        VAR_7 = VAR_3 = ((SFPreset *)(VAR_2->data))->zone;

        if(VAR_3)
        {
            VAR_6 = &VAR_3;
        }

        while(VAR_3)
        {
            /* COMMENT_1 */
            VAR_12 = 0;
            VAR_8 = (SFZone *)(VAR_3->data);
            VAR_4 = VAR_8->gen;

            while(VAR_4)
            {
                /* COMMENT_2 */
                VAR_5 = NULL;
                VAR_13 = FALSE;
                VAR_14 = FALSE;

                if((VAR_1 -= VAR_17) < 0)
                {
                    FLUID_LOG(VAR_18, ""Preset generator chunk size mismatch"");
                    return FALSE;
                }

                READW(VAR_0, VAR_11);

                if(VAR_11 == VAR_19)
                {
                    /* COMMENT_3 */
                    if(VAR_12 == 0)
                    {
                        VAR_12 = 1;
                        READB(VAR_0, VAR_10.range.lo);
                        READB(VAR_0, VAR_10.range.hi);
                    }
                    else
                    {
                        VAR_13 = TRUE;
                    }
                }
                else if(VAR_11 == VAR_20)
                {
                    /* COMMENT_4 */
                    if(VAR_12 <= 1)
                    {
                        VAR_12 = 2;
                        READB(VAR_0, VAR_10.range.lo);
                        READB(VAR_0, VAR_10.range.hi);
                    }
                    else
                    {
                        VAR_13 = TRUE;
                    }
                }
                else if(VAR_11 == VAR_21)
                {
                    /* COMMENT_5 */
                    VAR_12 = 3;
                    READW(VAR_0, VAR_10.uword);
                    ((SFZone *)(VAR_3->data))->instsamp = FLUID_INT_TO_POINTER(VAR_10.uword + 1);
                    break; /* COMMENT_6 */
                }
                else
                {
                    VAR_12 = 2;

                    if(valid_preset_genid(VAR_11))
                    {
                        /* COMMENT_7 */
                        READW(VAR_0, VAR_10.sword);
                        VAR_5 = find_gen_by_id(VAR_11, VAR_8->gen);
                    }
                    else
                    {
                        VAR_13 = TRUE;
                    }
                }

                if(!VAR_13)
                {
                    if(!VAR_5)
                    {
                        /* COMMENT_8 */
                        if((VAR_9 = FLUID_NEW(SFGen)) == NULL)
                        {
                            FLUID_LOG(VAR_18, ""Out of memory"");
                            return FALSE;
                        }

                        VAR_4->data = VAR_9;
                        VAR_9->id = VAR_11;
                    }
                    else
                    {
                        VAR_9 = (SFGen *)(VAR_5->data); /* COMMENT_9 */
                        VAR_14 = TRUE;
                    }

                    VAR_9->amount = VAR_10;
                }
                else
                {
                    /* COMMENT_10 */
                    VAR_16 = TRUE;
                    VAR_14 = TRUE;
                    FSKIPW(VAR_0);
                }

                if(!VAR_14)
                {
                    VAR_4 = fluid_list_next(VAR_4);    /* COMMENT_11 */
                }
                else
                {
                    SLADVREM(VAR_8->gen, VAR_4);    /* COMMENT_12 */
                }

            } /* COMMENT_13 */

            if(VAR_12 == 3)
            {
                SLADVREM(VAR_8->gen, VAR_4);    /* COMMENT_14 */
            }
            else
            {
                /* COMMENT_15 */
                if(!VAR_15)
                {
                    /* COMMENT_16 */
                    VAR_15 = TRUE;

                    /* COMMENT_17 */
                    if(*VAR_6 != VAR_3)
                    {
                        void *VAR_22 = VAR_3->data;
                        FLUID_LOG(VAR_23, ""Preset '%s': Global zone is not first zone"",
                                  ((SFPreset *)(VAR_2->data))->name);
                        SLADVREM(*VAR_6, VAR_3);
                        *VAR_6 = fluid_list_prepend(*VAR_6, VAR_22);
                        continue;
                    }
                }
                else
                {
                    SFZone * VAR_24 = fluid_list_get(VAR_3);
                    /* COMMENT_18 */
                    FLUID_LOG(VAR_23, ""Preset '%s': Discarding invalid global zone"",
                              ((SFPreset *)(VAR_2->data))->name);
                    *VAR_6 = fluid_list_remove(VAR_7, VAR_24);
                    delete_zone(VAR_24);
                }
            }

            while(VAR_4)
            {
                /* COMMENT_19 */
                VAR_16 = TRUE;

                if((VAR_1 -= VAR_17) < 0)
                {
                    FLUID_LOG(VAR_18, ""Preset generator chunk size mismatch"");
                    return FALSE;
                }

                FSKIP(VAR_0, VAR_17);
                SLADVREM(VAR_8->gen, VAR_4);
            }

            VAR_3 = fluid_list_next(VAR_3); /* COMMENT_20 */
        }

        if(VAR_16)
        {
            FLUID_LOG(VAR_23,
                      ""Preset '%s': Some invalid generators were discarded"",
                      ((SFPreset *)(VAR_2->data))->name);
        }

        VAR_2 = fluid_list_next(VAR_2);
    }

    /* COMMENT_21 */
    if(VAR_1 == 0)
    {
        return TRUE;
    }

    VAR_1 -= VAR_17;

    if(VAR_1 != 0)
    {
        FLUID_LOG(VAR_18, ""Preset generator chunk size mismatch"");
        return FALSE;
    }

    FSKIP(VAR_0, VAR_17); /* COMMENT_22 */

    return TRUE;
}",FluidSynth/fluidsynth/67596a87731dc593551975ca0268a438ab7410a2/fluid_sffile.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int load_pgen(SFData *sf, int size)
 {
-    fluid_list_t *p, *p2, *p3, *dup, **hz = NULL;
+    fluid_list_t *p, *p2, *p3, *dup, **hz = NULL, *start_of_zone_list;
     SFZone *z;
     SFGen *g;
     SFGenAmount genval;
@@ -14,7 +14,7 @@
         /* traverse through all presets */
         gzone = FALSE;
         discarded = FALSE;
-        p2 = ((SFPreset *)(p->data))->zone;
+        start_of_zone_list = p2 = ((SFPreset *)(p->data))->zone;
 
         if(p2)
         {
@@ -161,11 +161,12 @@
                 }
                 else
                 {
+                    SFZone * pzone = fluid_list_get(p2);
                     /* previous global zone exists, discard */
                     FLUID_LOG(FLUID_WARN, ""Preset '%s': Discarding invalid global zone"",
                               ((SFPreset *)(p->data))->name);
-                    *hz = fluid_list_remove(*hz, p2->data);
-                    delete_zone((SFZone *)fluid_list_get(p2));
+                    *hz = fluid_list_remove(start_of_zone_list, pzone);
+                    delete_zone(pzone);
                 }
             }
 ","{'deleted_lines': ['    fluid_list_t *p, *p2, *p3, *dup, **hz = NULL;', '        p2 = ((SFPreset *)(p->data))->zone;', '                    *hz = fluid_list_remove(*hz, p2->data);', '                    delete_zone((SFZone *)fluid_list_get(p2));'], 'added_lines': ['    fluid_list_t *p, *p2, *p3, *dup, **hz = NULL, *start_of_zone_list;', '        start_of_zone_list = p2 = ((SFPreset *)(p->data))->zone;', '                    SFZone * pzone = fluid_list_get(p2);', '                    *hz = fluid_list_remove(start_of_zone_list, pzone);', '                    delete_zone(pzone);']}",True,"fluidsynth is a software synthesizer based on the SoundFont 2 specifications. A use after free violation was discovered in fluidsynth, that can be triggered when loading an invalid SoundFont file.",7.2,HIGH,2,valid,2021-03-14T09:58:13Z,3
CVE-2021-21417,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,FluidSynth/fluidsynth,"Invalid generator were not removed from list

fluid_list_remove() should receive the beginning of a list, so it can adjust the predecessor of the element to be removed. Otherwise the element would remain in the list, which in this case led to a use-after-free afterwards.",67596a87731dc593551975ca0268a438ab7410a2,https://github.com/FluidSynth/fluidsynth/commit/67596a87731dc593551975ca0268a438ab7410a2,src/sfloader/fluid_sffile.c,load_igen,"static int load_igen(SFData *sf, int size)
{
fluid_list_t *p, *p2, *p3, *dup, **hz = NULL;
SFZone *z;
SFGen *g;
SFGenAmount genval;
unsigned short genid;
int level, skip, drop, gzone, discarded;
p = sf->inst;
while(p)
{
gzone = FALSE;
discarded = FALSE;
p2 = ((SFInst *)(p->data))->zone;
if(p2)
{
hz = &p2;
}
while(p2)
{
level = 0;
z = (SFZone *)(p2->data);
p3 = z->gen;
while(p3)
{
dup = NULL;
skip = FALSE;
drop = FALSE;
if((size -= SF_GEN_SIZE) < 0)
{
FLUID_LOG(FLUID_ERR, ""IGEN chunk size mismatch"");
return FALSE;
}
READW(sf, genid);
if(genid == Gen_KeyRange)
{
if(level == 0)
{
level = 1;
READB(sf, genval.range.lo);
READB(sf, genval.range.hi);
}
else
{
skip = TRUE;
}
}
else if(genid == Gen_VelRange)
{
if(level <= 1)
{
level = 2;
READB(sf, genval.range.lo);
READB(sf, genval.range.hi);
}
else
{
skip = TRUE;
}
}
else if(genid == Gen_SampleId)
{
level = 3;
READW(sf, genval.uword);
((SFZone *)(p2->data))->instsamp = FLUID_INT_TO_POINTER(genval.uword + 1);
break; 
}
else
{
level = 2;
if(valid_inst_genid(genid))
{
READW(sf, genval.sword);
dup = find_gen_by_id(genid, z->gen);
}
else
{
skip = TRUE;
}
}
if(!skip)
{
if(!dup)
{
if((g = FLUID_NEW(SFGen)) == NULL)
{
FLUID_LOG(FLUID_ERR, ""Out of memory"");
return FALSE;
}
p3->data = g;
g->id = genid;
}
else
{
g = (SFGen *)(dup->data);
drop = TRUE;
}
g->amount = genval;
}
else
{
discarded = TRUE;
drop = TRUE;
FSKIPW(sf);
}
if(!drop)
{
p3 = fluid_list_next(p3);    
}
else
{
SLADVREM(z->gen, p3);
}
} 
if(level == 3)
{
SLADVREM(z->gen, p3);    
}
else
{
if(!gzone)
{
gzone = TRUE;
if(*hz != p2)
{
void *save = p2->data;
FLUID_LOG(FLUID_WARN, ""Instrument '%s': Global zone is not first zone"",
((SFPreset *)(p->data))->name);
SLADVREM(*hz, p2);
*hz = fluid_list_prepend(*hz, save);
continue;
}
}
else
{
FLUID_LOG(FLUID_WARN, ""Instrument '%s': Discarding invalid global zone"",
((SFInst *)(p->data))->name);
*hz = fluid_list_remove(*hz, p2->data);
delete_zone((SFZone *)fluid_list_get(p2));
}
}
while(p3)
{
discarded = TRUE;
if((size -= SF_GEN_SIZE) < 0)
{
FLUID_LOG(FLUID_ERR, ""Instrument generator chunk size mismatch"");
return FALSE;
}
FSKIP(sf, SF_GEN_SIZE);
SLADVREM(z->gen, p3);
}
p2 = fluid_list_next(p2); 
}
if(discarded)
{
FLUID_LOG(FLUID_WARN,
""Instrument '%s': Some invalid generators were discarded"",
((SFInst *)(p->data))->name);
}
p = fluid_list_next(p);
}
if(size == 0)
{
return TRUE;
}
size -= SF_GEN_SIZE;
if(size != 0)
{
FLUID_LOG(FLUID_ERR, ""IGEN chunk size mismatch"");
return FALSE;
}
FSKIP(sf, SF_GEN_SIZE); 
return TRUE;
}","static int load_igen(SFData *VAR_0, int VAR_1)
{
fluid_list_t *VAR_2, *VAR_3, *VAR_4, *VAR_5, **VAR_6 = NULL;
SFZone *VAR_7;
SFGen *VAR_8;
SFGenAmount VAR_9;
unsigned short VAR_10;
int VAR_11, VAR_12, VAR_13, VAR_14, VAR_15;
VAR_2 = VAR_0->inst;
while(VAR_2)
{
VAR_14 = FALSE;
VAR_15 = FALSE;
VAR_3 = ((SFInst *)(VAR_2->data))->zone;
if(VAR_3)
{
VAR_6 = &VAR_3;
}
while(VAR_3)
{
VAR_11 = 0;
VAR_7 = (SFZone *)(VAR_3->data);
VAR_4 = VAR_7->gen;
while(VAR_4)
{
VAR_5 = NULL;
VAR_12 = FALSE;
VAR_13 = FALSE;
if((VAR_1 -= VAR_16) < 0)
{
FLUID_LOG(VAR_17, ""IGEN chunk size mismatch"");
return FALSE;
}
READW(VAR_0, VAR_10);
if(VAR_10 == VAR_18)
{
if(VAR_11 == 0)
{
VAR_11 = 1;
READB(VAR_0, VAR_9.range.lo);
READB(VAR_0, VAR_9.range.hi);
}
else
{
VAR_12 = TRUE;
}
}
else if(VAR_10 == VAR_19)
{
if(VAR_11 <= 1)
{
VAR_11 = 2;
READB(VAR_0, VAR_9.range.lo);
READB(VAR_0, VAR_9.range.hi);
}
else
{
VAR_12 = TRUE;
}
}
else if(VAR_10 == VAR_20)
{
VAR_11 = 3;
READW(VAR_0, VAR_9.uword);
((SFZone *)(VAR_3->data))->instsamp = FLUID_INT_TO_POINTER(VAR_9.uword + 1);
break; 
}
else
{
VAR_11 = 2;
if(valid_inst_genid(VAR_10))
{
READW(VAR_0, VAR_9.sword);
VAR_5 = find_gen_by_id(VAR_10, VAR_7->gen);
}
else
{
VAR_12 = TRUE;
}
}
if(!VAR_12)
{
if(!VAR_5)
{
if((VAR_8 = FLUID_NEW(SFGen)) == NULL)
{
FLUID_LOG(VAR_17, ""Out of memory"");
return FALSE;
}
VAR_4->data = VAR_8;
VAR_8->id = VAR_10;
}
else
{
VAR_8 = (SFGen *)(VAR_5->data);
VAR_13 = TRUE;
}
VAR_8->amount = VAR_9;
}
else
{
VAR_15 = TRUE;
VAR_13 = TRUE;
FSKIPW(VAR_0);
}
if(!VAR_13)
{
VAR_4 = fluid_list_next(VAR_4);    
}
else
{
SLADVREM(VAR_7->gen, VAR_4);
}
} 
if(VAR_11 == 3)
{
SLADVREM(VAR_7->gen, VAR_4);    
}
else
{
if(!VAR_14)
{
VAR_14 = TRUE;
if(*VAR_6 != VAR_3)
{
void *VAR_21 = VAR_3->data;
FLUID_LOG(VAR_22, ""Instrument '%s': Global zone is not first zone"",
((SFPreset *)(VAR_2->data))->name);
SLADVREM(*VAR_6, VAR_3);
*VAR_6 = fluid_list_prepend(*VAR_6, VAR_21);
continue;
}
}
else
{
FLUID_LOG(VAR_22, ""Instrument '%s': Discarding invalid global zone"",
((SFInst *)(VAR_2->data))->name);
*VAR_6 = fluid_list_remove(*VAR_6, VAR_3->data);
delete_zone((SFZone *)fluid_list_get(VAR_3));
}
}
while(VAR_4)
{
VAR_15 = TRUE;
if((VAR_1 -= VAR_16) < 0)
{
FLUID_LOG(VAR_17, ""Instrument generator chunk size mismatch"");
return FALSE;
}
FSKIP(VAR_0, VAR_16);
SLADVREM(VAR_7->gen, VAR_4);
}
VAR_3 = fluid_list_next(VAR_3); 
}
if(VAR_15)
{
FLUID_LOG(VAR_22,
""Instrument '%s': Some invalid generators were discarded"",
((SFInst *)(VAR_2->data))->name);
}
VAR_2 = fluid_list_next(VAR_2);
}
if(VAR_1 == 0)
{
return TRUE;
}
VAR_1 -= VAR_16;
if(VAR_1 != 0)
{
FLUID_LOG(VAR_17, ""IGEN chunk size mismatch"");
return FALSE;
}
FSKIP(VAR_0, VAR_16); 
return TRUE;
}",FluidSynth/fluidsynth/67596a87731dc593551975ca0268a438ab7410a2/fluid_sffile.c/vul/before/0.json,"static int load_igen(SFData *sf, int size)
{
    fluid_list_t *p, *p2, *p3, *dup, **hz = NULL, *start_of_zone_list;
    SFZone *z;
    SFGen *g;
    SFGenAmount genval;
    unsigned short genid;
    int level, skip, drop, gzone, discarded;

    p = sf->inst;

    while(p)
    {
        /* traverse through all instruments */
        gzone = FALSE;
        discarded = FALSE;
        start_of_zone_list = p2 = ((SFInst *)(p->data))->zone;

        if(p2)
        {
            hz = &p2;
        }

        while(p2)
        {
            /* traverse this instrument's zones */
            level = 0;
            z = (SFZone *)(p2->data);
            p3 = z->gen;

            while(p3)
            {
                /* load zone's generators */
                dup = NULL;
                skip = FALSE;
                drop = FALSE;

                if((size -= SF_GEN_SIZE) < 0)
                {
                    FLUID_LOG(FLUID_ERR, ""IGEN chunk size mismatch"");
                    return FALSE;
                }

                READW(sf, genid);

                if(genid == Gen_KeyRange)
                {
                    /* nothing precedes */
                    if(level == 0)
                    {
                        level = 1;
                        READB(sf, genval.range.lo);
                        READB(sf, genval.range.hi);
                    }
                    else
                    {
                        skip = TRUE;
                    }
                }
                else if(genid == Gen_VelRange)
                {
                    /* only KeyRange precedes */
                    if(level <= 1)
                    {
                        level = 2;
                        READB(sf, genval.range.lo);
                        READB(sf, genval.range.hi);
                    }
                    else
                    {
                        skip = TRUE;
                    }
                }
                else if(genid == Gen_SampleId)
                {
                    /* sample is last gen */
                    level = 3;
                    READW(sf, genval.uword);
                    ((SFZone *)(p2->data))->instsamp = FLUID_INT_TO_POINTER(genval.uword + 1);
                    break; /* break out of generator loop */
                }
                else
                {
                    level = 2;

                    if(valid_inst_genid(genid))
                    {
                        /* gen valid? */
                        READW(sf, genval.sword);
                        dup = find_gen_by_id(genid, z->gen);
                    }
                    else
                    {
                        skip = TRUE;
                    }
                }

                if(!skip)
                {
                    if(!dup)
                    {
                        /* if gen ! dup alloc new */
                        if((g = FLUID_NEW(SFGen)) == NULL)
                        {
                            FLUID_LOG(FLUID_ERR, ""Out of memory"");
                            return FALSE;
                        }

                        p3->data = g;
                        g->id = genid;
                    }
                    else
                    {
                        g = (SFGen *)(dup->data);
                        drop = TRUE;
                    }

                    g->amount = genval;
                }
                else
                {
                    /* skip this generator */
                    discarded = TRUE;
                    drop = TRUE;
                    FSKIPW(sf);
                }

                if(!drop)
                {
                    p3 = fluid_list_next(p3);    /* next gen */
                }
                else
                {
                    SLADVREM(z->gen, p3);
                }

            } /* generator loop */

            if(level == 3)
            {
                SLADVREM(z->gen, p3);    /* zone has sample? */
            }
            else
            {
                /* its a global zone */
                if(!gzone)
                {
                    gzone = TRUE;

                    /* if global zone is not 1st zone, relocate */
                    if(*hz != p2)
                    {
                        void *save = p2->data;
                        FLUID_LOG(FLUID_WARN, ""Instrument '%s': Global zone is not first zone"",
                                  ((SFPreset *)(p->data))->name);
                        SLADVREM(*hz, p2);
                        *hz = fluid_list_prepend(*hz, save);
                        continue;
                    }
                }
                else
                {
                    SFZone * izone = fluid_list_get(p2);
                    /* previous global zone exists, discard */
                    FLUID_LOG(FLUID_WARN, ""Instrument '%s': Discarding invalid global zone"",
                              ((SFInst *)(p->data))->name);
                    *hz = fluid_list_remove(start_of_zone_list, izone);
                    delete_zone(izone);
                }
            }

            while(p3)
            {
                /* Kill any zones following a sample */
                discarded = TRUE;

                if((size -= SF_GEN_SIZE) < 0)
                {
                    FLUID_LOG(FLUID_ERR, ""Instrument generator chunk size mismatch"");
                    return FALSE;
                }

                FSKIP(sf, SF_GEN_SIZE);
                SLADVREM(z->gen, p3);
            }

            p2 = fluid_list_next(p2); /* next zone */
        }

        if(discarded)
        {
            FLUID_LOG(FLUID_WARN,
                      ""Instrument '%s': Some invalid generators were discarded"",
                      ((SFInst *)(p->data))->name);
        }

        p = fluid_list_next(p);
    }

    /* for those non-terminal record cases, grr! */
    if(size == 0)
    {
        return TRUE;
    }

    size -= SF_GEN_SIZE;

    if(size != 0)
    {
        FLUID_LOG(FLUID_ERR, ""IGEN chunk size mismatch"");
        return FALSE;
    }

    FSKIP(sf, SF_GEN_SIZE); /* terminal gen */

    return TRUE;
}","static int load_igen(SFData *VAR_0, int VAR_1)
{
    fluid_list_t *VAR_2, *VAR_3, *VAR_4, *VAR_5, **VAR_6 = NULL, *VAR_7;
    SFZone *VAR_8;
    SFGen *VAR_9;
    SFGenAmount VAR_10;
    unsigned short VAR_11;
    int VAR_12, VAR_13, VAR_14, VAR_15, VAR_16;

    VAR_2 = VAR_0->inst;

    while(VAR_2)
    {
        /* COMMENT_0 */
        VAR_15 = FALSE;
        VAR_16 = FALSE;
        VAR_7 = VAR_3 = ((SFInst *)(VAR_2->data))->zone;

        if(VAR_3)
        {
            VAR_6 = &VAR_3;
        }

        while(VAR_3)
        {
            /* COMMENT_1 */
            VAR_12 = 0;
            VAR_8 = (SFZone *)(VAR_3->data);
            VAR_4 = VAR_8->gen;

            while(VAR_4)
            {
                /* COMMENT_2 */
                VAR_5 = NULL;
                VAR_13 = FALSE;
                VAR_14 = FALSE;

                if((VAR_1 -= VAR_17) < 0)
                {
                    FLUID_LOG(VAR_18, ""IGEN chunk size mismatch"");
                    return FALSE;
                }

                READW(VAR_0, VAR_11);

                if(VAR_11 == VAR_19)
                {
                    /* COMMENT_3 */
                    if(VAR_12 == 0)
                    {
                        VAR_12 = 1;
                        READB(VAR_0, VAR_10.range.lo);
                        READB(VAR_0, VAR_10.range.hi);
                    }
                    else
                    {
                        VAR_13 = TRUE;
                    }
                }
                else if(VAR_11 == VAR_20)
                {
                    /* COMMENT_4 */
                    if(VAR_12 <= 1)
                    {
                        VAR_12 = 2;
                        READB(VAR_0, VAR_10.range.lo);
                        READB(VAR_0, VAR_10.range.hi);
                    }
                    else
                    {
                        VAR_13 = TRUE;
                    }
                }
                else if(VAR_11 == VAR_21)
                {
                    /* COMMENT_5 */
                    VAR_12 = 3;
                    READW(VAR_0, VAR_10.uword);
                    ((SFZone *)(VAR_3->data))->instsamp = FLUID_INT_TO_POINTER(VAR_10.uword + 1);
                    break; /* COMMENT_6 */
                }
                else
                {
                    VAR_12 = 2;

                    if(valid_inst_genid(VAR_11))
                    {
                        /* COMMENT_7 */
                        READW(VAR_0, VAR_10.sword);
                        VAR_5 = find_gen_by_id(VAR_11, VAR_8->gen);
                    }
                    else
                    {
                        VAR_13 = TRUE;
                    }
                }

                if(!VAR_13)
                {
                    if(!VAR_5)
                    {
                        /* COMMENT_8 */
                        if((VAR_9 = FLUID_NEW(SFGen)) == NULL)
                        {
                            FLUID_LOG(VAR_18, ""Out of memory"");
                            return FALSE;
                        }

                        VAR_4->data = VAR_9;
                        VAR_9->id = VAR_11;
                    }
                    else
                    {
                        VAR_9 = (SFGen *)(VAR_5->data);
                        VAR_14 = TRUE;
                    }

                    VAR_9->amount = VAR_10;
                }
                else
                {
                    /* COMMENT_9 */
                    VAR_16 = TRUE;
                    VAR_14 = TRUE;
                    FSKIPW(VAR_0);
                }

                if(!VAR_14)
                {
                    VAR_4 = fluid_list_next(VAR_4);    /* COMMENT_10 */
                }
                else
                {
                    SLADVREM(VAR_8->gen, VAR_4);
                }

            } /* COMMENT_11 */

            if(VAR_12 == 3)
            {
                SLADVREM(VAR_8->gen, VAR_4);    /* COMMENT_12 */
            }
            else
            {
                /* COMMENT_13 */
                if(!VAR_15)
                {
                    VAR_15 = TRUE;

                    /* COMMENT_14 */
                    if(*VAR_6 != VAR_3)
                    {
                        void *VAR_22 = VAR_3->data;
                        FLUID_LOG(VAR_23, ""Instrument '%s': Global zone is not first zone"",
                                  ((SFPreset *)(VAR_2->data))->name);
                        SLADVREM(*VAR_6, VAR_3);
                        *VAR_6 = fluid_list_prepend(*VAR_6, VAR_22);
                        continue;
                    }
                }
                else
                {
                    SFZone * VAR_24 = fluid_list_get(VAR_3);
                    /* COMMENT_15 */
                    FLUID_LOG(VAR_23, ""Instrument '%s': Discarding invalid global zone"",
                              ((SFInst *)(VAR_2->data))->name);
                    *VAR_6 = fluid_list_remove(VAR_7, VAR_24);
                    delete_zone(VAR_24);
                }
            }

            while(VAR_4)
            {
                /* COMMENT_16 */
                VAR_16 = TRUE;

                if((VAR_1 -= VAR_17) < 0)
                {
                    FLUID_LOG(VAR_18, ""Instrument generator chunk size mismatch"");
                    return FALSE;
                }

                FSKIP(VAR_0, VAR_17);
                SLADVREM(VAR_8->gen, VAR_4);
            }

            VAR_3 = fluid_list_next(VAR_3); /* COMMENT_17 */
        }

        if(VAR_16)
        {
            FLUID_LOG(VAR_23,
                      ""Instrument '%s': Some invalid generators were discarded"",
                      ((SFInst *)(VAR_2->data))->name);
        }

        VAR_2 = fluid_list_next(VAR_2);
    }

    /* COMMENT_18 */
    if(VAR_1 == 0)
    {
        return TRUE;
    }

    VAR_1 -= VAR_17;

    if(VAR_1 != 0)
    {
        FLUID_LOG(VAR_18, ""IGEN chunk size mismatch"");
        return FALSE;
    }

    FSKIP(VAR_0, VAR_17); /* COMMENT_19 */

    return TRUE;
}",FluidSynth/fluidsynth/67596a87731dc593551975ca0268a438ab7410a2/fluid_sffile.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int load_igen(SFData *sf, int size)
 {
-    fluid_list_t *p, *p2, *p3, *dup, **hz = NULL;
+    fluid_list_t *p, *p2, *p3, *dup, **hz = NULL, *start_of_zone_list;
     SFZone *z;
     SFGen *g;
     SFGenAmount genval;
@@ -14,7 +14,7 @@
         /* traverse through all instruments */
         gzone = FALSE;
         discarded = FALSE;
-        p2 = ((SFInst *)(p->data))->zone;
+        start_of_zone_list = p2 = ((SFInst *)(p->data))->zone;
 
         if(p2)
         {
@@ -160,11 +160,12 @@
                 }
                 else
                 {
+                    SFZone * izone = fluid_list_get(p2);
                     /* previous global zone exists, discard */
                     FLUID_LOG(FLUID_WARN, ""Instrument '%s': Discarding invalid global zone"",
                               ((SFInst *)(p->data))->name);
-                    *hz = fluid_list_remove(*hz, p2->data);
-                    delete_zone((SFZone *)fluid_list_get(p2));
+                    *hz = fluid_list_remove(start_of_zone_list, izone);
+                    delete_zone(izone);
                 }
             }
 ","{'deleted_lines': ['    fluid_list_t *p, *p2, *p3, *dup, **hz = NULL;', '        p2 = ((SFInst *)(p->data))->zone;', '                    *hz = fluid_list_remove(*hz, p2->data);', '                    delete_zone((SFZone *)fluid_list_get(p2));'], 'added_lines': ['    fluid_list_t *p, *p2, *p3, *dup, **hz = NULL, *start_of_zone_list;', '        start_of_zone_list = p2 = ((SFInst *)(p->data))->zone;', '                    SFZone * izone = fluid_list_get(p2);', '                    *hz = fluid_list_remove(start_of_zone_list, izone);', '                    delete_zone(izone);']}",True,"fluidsynth is a software synthesizer based on the SoundFont 2 specifications. A use after free violation was discovered in fluidsynth, that can be triggered when loading an invalid SoundFont file.",7.2,HIGH,2,valid,2021-03-14T09:58:13Z,3
CVE-2021-21417,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,FluidSynth/fluidsynth,Update fluid_sffile.c,6673a5f73c0484f8462b4b33860d2b1c68c24684,https://github.com/FluidSynth/fluidsynth/commit/6673a5f73c0484f8462b4b33860d2b1c68c24684,src/sfloader/fluid_sffile.c,load_pgen,"static int load_pgen(SFData *sf, int size)
{
fluid_list_t *p, *p2, *p3, *dup, **hz = NULL, *start_of_zone_list;
SFZone *z;
SFGen *g;
SFGenAmount genval;
unsigned short genid;
int level, skip, drop, gzone, discarded;
p = sf->preset;
while(p)
{
gzone = FALSE;
discarded = FALSE;
start_of_zone_list = p2 = ((SFPreset *)(p->data))->zone;
if(p2)
{
hz = &p2;
}
while(p2)
{
level = 0;
z = (SFZone *)(p2->data);
p3 = z->gen;
while(p3)
{
dup = NULL;
skip = FALSE;
drop = FALSE;
if((size -= SF_GEN_SIZE) < 0)
{
FLUID_LOG(FLUID_ERR, ""Preset generator chunk size mismatch"");
return FALSE;
}
READW(sf, genid);
if(genid == Gen_KeyRange)
{
if(level == 0)
{
level = 1;
READB(sf, genval.range.lo);
READB(sf, genval.range.hi);
}
else
{
skip = TRUE;
}
}
else if(genid == Gen_VelRange)
{
if(level <= 1)
{
level = 2;
READB(sf, genval.range.lo);
READB(sf, genval.range.hi);
}
else
{
skip = TRUE;
}
}
else if(genid == Gen_Instrument)
{
level = 3;
READW(sf, genval.uword);
((SFZone *)(p2->data))->instsamp = FLUID_INT_TO_POINTER(genval.uword + 1);
break; 
}
else
{
level = 2;
if(valid_preset_genid(genid))
{
READW(sf, genval.sword);
dup = find_gen_by_id(genid, z->gen);
}
else
{
skip = TRUE;
}
}
if(!skip)
{
if(!dup)
{
if((g = FLUID_NEW(SFGen)) == NULL)
{
FLUID_LOG(FLUID_ERR, ""Out of memory"");
return FALSE;
}
p3->data = g;
g->id = genid;
}
else
{
g = (SFGen *)(dup->data); 
drop = TRUE;
}
g->amount = genval;
}
else
{
discarded = TRUE;
drop = TRUE;
FSKIPW(sf);
}
if(!drop)
{
p3 = fluid_list_next(p3);    
}
else
{
SLADVREM(z->gen, p3);    
}
} 
if(level == 3)
{
SLADVREM(z->gen, p3);    
}
else
{
if(!gzone)
{
gzone = TRUE;
if(*hz != p2)
{
void *save = p2->data;
FLUID_LOG(FLUID_WARN, ""Preset '%s': Global zone is not first zone"",
((SFPreset *)(p->data))->name);
SLADVREM(*hz, p2);
*hz = fluid_list_prepend(*hz, save);
continue;
}
}
else
{
SFZone * pzone = fluid_list_get(p2);
FLUID_LOG(FLUID_WARN, ""Preset '%s': Discarding invalid global zone"",
((SFPreset *)(p->data))->name);
*hz = fluid_list_remove(start_of_zone_list, pzone);
delete_zone(pzone);
}
}
while(p3)
{
discarded = TRUE;
if((size -= SF_GEN_SIZE) < 0)
{
FLUID_LOG(FLUID_ERR, ""Preset generator chunk size mismatch"");
return FALSE;
}
FSKIP(sf, SF_GEN_SIZE);
SLADVREM(z->gen, p3);
}
p2 = fluid_list_next(p2); 
}
if(discarded)
{
FLUID_LOG(FLUID_WARN,
""Preset '%s': Some invalid generators were discarded"",
((SFPreset *)(p->data))->name);
}
p = fluid_list_next(p);
}
if(size == 0)
{
return TRUE;
}
size -= SF_GEN_SIZE;
if(size != 0)
{
FLUID_LOG(FLUID_ERR, ""Preset generator chunk size mismatch"");
return FALSE;
}
FSKIP(sf, SF_GEN_SIZE); 
return TRUE;
}","static int load_pgen(SFData *VAR_0, int VAR_1)
{
fluid_list_t *VAR_2, *VAR_3, *VAR_4, *VAR_5, **VAR_6 = NULL, *VAR_7;
SFZone *VAR_8;
SFGen *VAR_9;
SFGenAmount VAR_10;
unsigned short VAR_11;
int VAR_12, VAR_13, VAR_14, VAR_15, VAR_16;
VAR_2 = VAR_0->preset;
while(VAR_2)
{
VAR_15 = FALSE;
VAR_16 = FALSE;
VAR_7 = VAR_3 = ((SFPreset *)(VAR_2->data))->zone;
if(VAR_3)
{
VAR_6 = &VAR_3;
}
while(VAR_3)
{
VAR_12 = 0;
VAR_8 = (SFZone *)(VAR_3->data);
VAR_4 = VAR_8->gen;
while(VAR_4)
{
VAR_5 = NULL;
VAR_13 = FALSE;
VAR_14 = FALSE;
if((VAR_1 -= VAR_17) < 0)
{
FLUID_LOG(VAR_18, ""Preset generator chunk size mismatch"");
return FALSE;
}
READW(VAR_0, VAR_11);
if(VAR_11 == VAR_19)
{
if(VAR_12 == 0)
{
VAR_12 = 1;
READB(VAR_0, VAR_10.range.lo);
READB(VAR_0, VAR_10.range.hi);
}
else
{
VAR_13 = TRUE;
}
}
else if(VAR_11 == VAR_20)
{
if(VAR_12 <= 1)
{
VAR_12 = 2;
READB(VAR_0, VAR_10.range.lo);
READB(VAR_0, VAR_10.range.hi);
}
else
{
VAR_13 = TRUE;
}
}
else if(VAR_11 == VAR_21)
{
VAR_12 = 3;
READW(VAR_0, VAR_10.uword);
((SFZone *)(VAR_3->data))->instsamp = FLUID_INT_TO_POINTER(VAR_10.uword + 1);
break; 
}
else
{
VAR_12 = 2;
if(valid_preset_genid(VAR_11))
{
READW(VAR_0, VAR_10.sword);
VAR_5 = find_gen_by_id(VAR_11, VAR_8->gen);
}
else
{
VAR_13 = TRUE;
}
}
if(!VAR_13)
{
if(!VAR_5)
{
if((VAR_9 = FLUID_NEW(SFGen)) == NULL)
{
FLUID_LOG(VAR_18, ""Out of memory"");
return FALSE;
}
VAR_4->data = VAR_9;
VAR_9->id = VAR_11;
}
else
{
VAR_9 = (SFGen *)(VAR_5->data); 
VAR_14 = TRUE;
}
VAR_9->amount = VAR_10;
}
else
{
VAR_16 = TRUE;
VAR_14 = TRUE;
FSKIPW(VAR_0);
}
if(!VAR_14)
{
VAR_4 = fluid_list_next(VAR_4);    
}
else
{
SLADVREM(VAR_8->gen, VAR_4);    
}
} 
if(VAR_12 == 3)
{
SLADVREM(VAR_8->gen, VAR_4);    
}
else
{
if(!VAR_15)
{
VAR_15 = TRUE;
if(*VAR_6 != VAR_3)
{
void *VAR_22 = VAR_3->data;
FLUID_LOG(VAR_23, ""Preset '%s': Global zone is not first zone"",
((SFPreset *)(VAR_2->data))->name);
SLADVREM(*VAR_6, VAR_3);
*VAR_6 = fluid_list_prepend(*VAR_6, VAR_22);
continue;
}
}
else
{
SFZone * VAR_24 = fluid_list_get(VAR_3);
FLUID_LOG(VAR_23, ""Preset '%s': Discarding invalid global zone"",
((SFPreset *)(VAR_2->data))->name);
*VAR_6 = fluid_list_remove(VAR_7, VAR_24);
delete_zone(VAR_24);
}
}
while(VAR_4)
{
VAR_16 = TRUE;
if((VAR_1 -= VAR_17) < 0)
{
FLUID_LOG(VAR_18, ""Preset generator chunk size mismatch"");
return FALSE;
}
FSKIP(VAR_0, VAR_17);
SLADVREM(VAR_8->gen, VAR_4);
}
VAR_3 = fluid_list_next(VAR_3); 
}
if(VAR_16)
{
FLUID_LOG(VAR_23,
""Preset '%s': Some invalid generators were discarded"",
((SFPreset *)(VAR_2->data))->name);
}
VAR_2 = fluid_list_next(VAR_2);
}
if(VAR_1 == 0)
{
return TRUE;
}
VAR_1 -= VAR_17;
if(VAR_1 != 0)
{
FLUID_LOG(VAR_18, ""Preset generator chunk size mismatch"");
return FALSE;
}
FSKIP(VAR_0, VAR_17); 
return TRUE;
}",FluidSynth/fluidsynth/6673a5f73c0484f8462b4b33860d2b1c68c24684/fluid_sffile.c/vul/before/1.json,"static int load_pgen(SFData *sf, int size)
{
    fluid_list_t *p, *p2, *p3, *dup, **hz = NULL, *start_of_zone_list;
    SFZone *z;
    SFGen *g;
    SFGenAmount genval;
    unsigned short genid;
    int level, skip, drop, gzone, discarded;

    p = sf->preset;

    while(p)
    {
        /* traverse through all presets */
        gzone = FALSE;
        discarded = FALSE;
        start_of_zone_list = p2 = ((SFPreset *)(p->data))->zone;

        if(p2)
        {
            hz = &p2;
        }

        while(p2)
        {
            /* traverse preset's zones */
            level = 0;
            z = (SFZone *)(p2->data);
            p3 = z->gen;

            while(p3)
            {
                /* load zone's generators */
                dup = NULL;
                skip = FALSE;
                drop = FALSE;

                if((size -= SF_GEN_SIZE) < 0)
                {
                    FLUID_LOG(FLUID_ERR, ""Preset generator chunk size mismatch"");
                    return FALSE;
                }

                READW(sf, genid);

                if(genid == Gen_KeyRange)
                {
                    /* nothing precedes */
                    if(level == 0)
                    {
                        level = 1;
                        READB(sf, genval.range.lo);
                        READB(sf, genval.range.hi);
                    }
                    else
                    {
                        skip = TRUE;
                    }
                }
                else if(genid == Gen_VelRange)
                {
                    /* only KeyRange precedes */
                    if(level <= 1)
                    {
                        level = 2;
                        READB(sf, genval.range.lo);
                        READB(sf, genval.range.hi);
                    }
                    else
                    {
                        skip = TRUE;
                    }
                }
                else if(genid == Gen_Instrument)
                {
                    /* inst is last gen */
                    level = 3;
                    READW(sf, genval.uword);
                    ((SFZone *)(p2->data))->instsamp = FLUID_INT_TO_POINTER(genval.uword + 1);
                    break; /* break out of generator loop */
                }
                else
                {
                    level = 2;

                    if(valid_preset_genid(genid))
                    {
                        /* generator valid? */
                        READW(sf, genval.sword);
                        dup = find_gen_by_id(genid, z->gen);
                    }
                    else
                    {
                        skip = TRUE;
                    }
                }

                if(!skip)
                {
                    if(!dup)
                    {
                        /* if gen ! dup alloc new */
                        if((g = FLUID_NEW(SFGen)) == NULL)
                        {
                            FLUID_LOG(FLUID_ERR, ""Out of memory"");
                            return FALSE;
                        }

                        p3->data = g;
                        g->id = genid;
                    }
                    else
                    {
                        g = (SFGen *)(dup->data); /* ptr to orig gen */
                        drop = TRUE;
                    }

                    g->amount = genval;
                }
                else
                {
                    /* Skip this generator */
                    discarded = TRUE;
                    drop = TRUE;
                    FSKIPW(sf);
                }

                if(!drop)
                {
                    p3 = fluid_list_next(p3);    /* next gen */
                }
                else
                {
                    SLADVREM(z->gen, p3);    /* drop place holder */
                }

            } /* generator loop */

            if(level == 3)
            {
                SLADVREM(z->gen, p3);    /* zone has inst? */
            }
            else
            {
                /* congratulations its a global zone */
                if(!gzone)
                {
                    /* Prior global zones? */
                    gzone = TRUE;

                    /* if global zone is not 1st zone, relocate */
                    if(*hz != p2)
                    {
                        void *save = p2->data;
                        FLUID_LOG(FLUID_WARN, ""Preset '%s': Global zone is not first zone"",
                                  ((SFPreset *)(p->data))->name);
                        SLADVREM(*hz, p2);
                        *hz = fluid_list_prepend(*hz, save);
                        continue;
                    }
                }
                else
                {
                    p2 = fluid_list_next(p2); /* advance to next zone before deleting the current list element */
                    /* previous global zone exists, discard */
                    FLUID_LOG(FLUID_WARN, ""Preset '%s': Discarding invalid global zone"",
                              ((SFPreset *)(p->data))->name);
                    fluid_list_remove(start_of_zone_list, z);
                    delete_zone(z);
                    continue;
                }
            }

            while(p3)
            {
                /* Kill any zones following an instrument */
                discarded = TRUE;

                if((size -= SF_GEN_SIZE) < 0)
                {
                    FLUID_LOG(FLUID_ERR, ""Preset generator chunk size mismatch"");
                    return FALSE;
                }

                FSKIP(sf, SF_GEN_SIZE);
                SLADVREM(z->gen, p3);
            }

            p2 = fluid_list_next(p2); /* next zone */
        }

        if(discarded)
        {
            FLUID_LOG(FLUID_WARN,
                      ""Preset '%s': Some invalid generators were discarded"",
                      ((SFPreset *)(p->data))->name);
        }

        p = fluid_list_next(p);
    }

    /* in case there isn't a terminal record */
    if(size == 0)
    {
        return TRUE;
    }

    size -= SF_GEN_SIZE;

    if(size != 0)
    {
        FLUID_LOG(FLUID_ERR, ""Preset generator chunk size mismatch"");
        return FALSE;
    }

    FSKIP(sf, SF_GEN_SIZE); /* terminal gen */

    return TRUE;
}","static int load_pgen(SFData *VAR_0, int VAR_1)
{
    fluid_list_t *VAR_2, *VAR_3, *VAR_4, *VAR_5, **VAR_6 = NULL, *VAR_7;
    SFZone *VAR_8;
    SFGen *VAR_9;
    SFGenAmount VAR_10;
    unsigned short VAR_11;
    int VAR_12, VAR_13, VAR_14, VAR_15, VAR_16;

    VAR_2 = VAR_0->preset;

    while(VAR_2)
    {
        /* COMMENT_0 */
        VAR_15 = FALSE;
        VAR_16 = FALSE;
        VAR_7 = VAR_3 = ((SFPreset *)(VAR_2->data))->zone;

        if(VAR_3)
        {
            VAR_6 = &VAR_3;
        }

        while(VAR_3)
        {
            /* COMMENT_1 */
            VAR_12 = 0;
            VAR_8 = (SFZone *)(VAR_3->data);
            VAR_4 = VAR_8->gen;

            while(VAR_4)
            {
                /* COMMENT_2 */
                VAR_5 = NULL;
                VAR_13 = FALSE;
                VAR_14 = FALSE;

                if((VAR_1 -= VAR_17) < 0)
                {
                    FLUID_LOG(VAR_18, ""Preset generator chunk size mismatch"");
                    return FALSE;
                }

                READW(VAR_0, VAR_11);

                if(VAR_11 == VAR_19)
                {
                    /* COMMENT_3 */
                    if(VAR_12 == 0)
                    {
                        VAR_12 = 1;
                        READB(VAR_0, VAR_10.range.lo);
                        READB(VAR_0, VAR_10.range.hi);
                    }
                    else
                    {
                        VAR_13 = TRUE;
                    }
                }
                else if(VAR_11 == VAR_20)
                {
                    /* COMMENT_4 */
                    if(VAR_12 <= 1)
                    {
                        VAR_12 = 2;
                        READB(VAR_0, VAR_10.range.lo);
                        READB(VAR_0, VAR_10.range.hi);
                    }
                    else
                    {
                        VAR_13 = TRUE;
                    }
                }
                else if(VAR_11 == VAR_21)
                {
                    /* COMMENT_5 */
                    VAR_12 = 3;
                    READW(VAR_0, VAR_10.uword);
                    ((SFZone *)(VAR_3->data))->instsamp = FLUID_INT_TO_POINTER(VAR_10.uword + 1);
                    break; /* COMMENT_6 */
                }
                else
                {
                    VAR_12 = 2;

                    if(valid_preset_genid(VAR_11))
                    {
                        /* COMMENT_7 */
                        READW(VAR_0, VAR_10.sword);
                        VAR_5 = find_gen_by_id(VAR_11, VAR_8->gen);
                    }
                    else
                    {
                        VAR_13 = TRUE;
                    }
                }

                if(!VAR_13)
                {
                    if(!VAR_5)
                    {
                        /* COMMENT_8 */
                        if((VAR_9 = FLUID_NEW(SFGen)) == NULL)
                        {
                            FLUID_LOG(VAR_18, ""Out of memory"");
                            return FALSE;
                        }

                        VAR_4->data = VAR_9;
                        VAR_9->id = VAR_11;
                    }
                    else
                    {
                        VAR_9 = (SFGen *)(VAR_5->data); /* COMMENT_9 */
                        VAR_14 = TRUE;
                    }

                    VAR_9->amount = VAR_10;
                }
                else
                {
                    /* COMMENT_10 */
                    VAR_16 = TRUE;
                    VAR_14 = TRUE;
                    FSKIPW(VAR_0);
                }

                if(!VAR_14)
                {
                    VAR_4 = fluid_list_next(VAR_4);    /* COMMENT_11 */
                }
                else
                {
                    SLADVREM(VAR_8->gen, VAR_4);    /* COMMENT_12 */
                }

            } /* COMMENT_13 */

            if(VAR_12 == 3)
            {
                SLADVREM(VAR_8->gen, VAR_4);    /* COMMENT_14 */
            }
            else
            {
                /* COMMENT_15 */
                if(!VAR_15)
                {
                    /* COMMENT_16 */
                    VAR_15 = TRUE;

                    /* COMMENT_17 */
                    if(*VAR_6 != VAR_3)
                    {
                        void *VAR_22 = VAR_3->data;
                        FLUID_LOG(VAR_23, ""Preset '%s': Global zone is not first zone"",
                                  ((SFPreset *)(VAR_2->data))->name);
                        SLADVREM(*VAR_6, VAR_3);
                        *VAR_6 = fluid_list_prepend(*VAR_6, VAR_22);
                        continue;
                    }
                }
                else
                {
                    VAR_3 = fluid_list_next(VAR_3); /* COMMENT_18 */
                    /* COMMENT_19 */
                    FLUID_LOG(VAR_23, ""Preset '%s': Discarding invalid global zone"",
                              ((SFPreset *)(VAR_2->data))->name);
                    fluid_list_remove(VAR_7, VAR_8);
                    delete_zone(VAR_8);
                    continue;
                }
            }

            while(VAR_4)
            {
                /* COMMENT_20 */
                VAR_16 = TRUE;

                if((VAR_1 -= VAR_17) < 0)
                {
                    FLUID_LOG(VAR_18, ""Preset generator chunk size mismatch"");
                    return FALSE;
                }

                FSKIP(VAR_0, VAR_17);
                SLADVREM(VAR_8->gen, VAR_4);
            }

            VAR_3 = fluid_list_next(VAR_3); /* COMMENT_21 */
        }

        if(VAR_16)
        {
            FLUID_LOG(VAR_23,
                      ""Preset '%s': Some invalid generators were discarded"",
                      ((SFPreset *)(VAR_2->data))->name);
        }

        VAR_2 = fluid_list_next(VAR_2);
    }

    /* COMMENT_22 */
    if(VAR_1 == 0)
    {
        return TRUE;
    }

    VAR_1 -= VAR_17;

    if(VAR_1 != 0)
    {
        FLUID_LOG(VAR_18, ""Preset generator chunk size mismatch"");
        return FALSE;
    }

    FSKIP(VAR_0, VAR_17); /* COMMENT_23 */

    return TRUE;
}",FluidSynth/fluidsynth/6673a5f73c0484f8462b4b33860d2b1c68c24684/fluid_sffile.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -161,12 +161,13 @@
                 }
                 else
                 {
-                    SFZone * pzone = fluid_list_get(p2);
+                    p2 = fluid_list_next(p2); /* advance to next zone before deleting the current list element */
                     /* previous global zone exists, discard */
                     FLUID_LOG(FLUID_WARN, ""Preset '%s': Discarding invalid global zone"",
                               ((SFPreset *)(p->data))->name);
-                    *hz = fluid_list_remove(start_of_zone_list, pzone);
-                    delete_zone(pzone);
+                    fluid_list_remove(start_of_zone_list, z);
+                    delete_zone(z);
+                    continue;
                 }
             }
 ","{'deleted_lines': ['                    SFZone * pzone = fluid_list_get(p2);', '                    *hz = fluid_list_remove(start_of_zone_list, pzone);', '                    delete_zone(pzone);'], 'added_lines': ['                    p2 = fluid_list_next(p2); /* advance to next zone before deleting the current list element */', '                    fluid_list_remove(start_of_zone_list, z);', '                    delete_zone(z);', '                    continue;']}",True,"fluidsynth is a software synthesizer based on the SoundFont 2 specifications. A use after free violation was discovered in fluidsynth, that can be triggered when loading an invalid SoundFont file.",7.2,HIGH,2,valid,2021-03-14T19:23:38Z,3
CVE-2021-21417,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,FluidSynth/fluidsynth,Update fluid_sffile.c,6673a5f73c0484f8462b4b33860d2b1c68c24684,https://github.com/FluidSynth/fluidsynth/commit/6673a5f73c0484f8462b4b33860d2b1c68c24684,src/sfloader/fluid_sffile.c,load_igen,"static int load_igen(SFData *sf, int size)
{
fluid_list_t *p, *p2, *p3, *dup, **hz = NULL, *start_of_zone_list;
SFZone *z;
SFGen *g;
SFGenAmount genval;
unsigned short genid;
int level, skip, drop, gzone, discarded;
p = sf->inst;
while(p)
{
gzone = FALSE;
discarded = FALSE;
start_of_zone_list = p2 = ((SFInst *)(p->data))->zone;
if(p2)
{
hz = &p2;
}
while(p2)
{
level = 0;
z = (SFZone *)(p2->data);
p3 = z->gen;
while(p3)
{
dup = NULL;
skip = FALSE;
drop = FALSE;
if((size -= SF_GEN_SIZE) < 0)
{
FLUID_LOG(FLUID_ERR, ""IGEN chunk size mismatch"");
return FALSE;
}
READW(sf, genid);
if(genid == Gen_KeyRange)
{
if(level == 0)
{
level = 1;
READB(sf, genval.range.lo);
READB(sf, genval.range.hi);
}
else
{
skip = TRUE;
}
}
else if(genid == Gen_VelRange)
{
if(level <= 1)
{
level = 2;
READB(sf, genval.range.lo);
READB(sf, genval.range.hi);
}
else
{
skip = TRUE;
}
}
else if(genid == Gen_SampleId)
{
level = 3;
READW(sf, genval.uword);
((SFZone *)(p2->data))->instsamp = FLUID_INT_TO_POINTER(genval.uword + 1);
break; 
}
else
{
level = 2;
if(valid_inst_genid(genid))
{
READW(sf, genval.sword);
dup = find_gen_by_id(genid, z->gen);
}
else
{
skip = TRUE;
}
}
if(!skip)
{
if(!dup)
{
if((g = FLUID_NEW(SFGen)) == NULL)
{
FLUID_LOG(FLUID_ERR, ""Out of memory"");
return FALSE;
}
p3->data = g;
g->id = genid;
}
else
{
g = (SFGen *)(dup->data);
drop = TRUE;
}
g->amount = genval;
}
else
{
discarded = TRUE;
drop = TRUE;
FSKIPW(sf);
}
if(!drop)
{
p3 = fluid_list_next(p3);    
}
else
{
SLADVREM(z->gen, p3);
}
} 
if(level == 3)
{
SLADVREM(z->gen, p3);    
}
else
{
if(!gzone)
{
gzone = TRUE;
if(*hz != p2)
{
void *save = p2->data;
FLUID_LOG(FLUID_WARN, ""Instrument '%s': Global zone is not first zone"",
((SFPreset *)(p->data))->name);
SLADVREM(*hz, p2);
*hz = fluid_list_prepend(*hz, save);
continue;
}
}
else
{
SFZone * izone = fluid_list_get(p2);
FLUID_LOG(FLUID_WARN, ""Instrument '%s': Discarding invalid global zone"",
((SFInst *)(p->data))->name);
*hz = fluid_list_remove(start_of_zone_list, izone);
delete_zone(izone);
}
}
while(p3)
{
discarded = TRUE;
if((size -= SF_GEN_SIZE) < 0)
{
FLUID_LOG(FLUID_ERR, ""Instrument generator chunk size mismatch"");
return FALSE;
}
FSKIP(sf, SF_GEN_SIZE);
SLADVREM(z->gen, p3);
}
p2 = fluid_list_next(p2); 
}
if(discarded)
{
FLUID_LOG(FLUID_WARN,
""Instrument '%s': Some invalid generators were discarded"",
((SFInst *)(p->data))->name);
}
p = fluid_list_next(p);
}
if(size == 0)
{
return TRUE;
}
size -= SF_GEN_SIZE;
if(size != 0)
{
FLUID_LOG(FLUID_ERR, ""IGEN chunk size mismatch"");
return FALSE;
}
FSKIP(sf, SF_GEN_SIZE); 
return TRUE;
}","static int load_igen(SFData *VAR_0, int VAR_1)
{
fluid_list_t *VAR_2, *VAR_3, *VAR_4, *VAR_5, **VAR_6 = NULL, *VAR_7;
SFZone *VAR_8;
SFGen *VAR_9;
SFGenAmount VAR_10;
unsigned short VAR_11;
int VAR_12, VAR_13, VAR_14, VAR_15, VAR_16;
VAR_2 = VAR_0->inst;
while(VAR_2)
{
VAR_15 = FALSE;
VAR_16 = FALSE;
VAR_7 = VAR_3 = ((SFInst *)(VAR_2->data))->zone;
if(VAR_3)
{
VAR_6 = &VAR_3;
}
while(VAR_3)
{
VAR_12 = 0;
VAR_8 = (SFZone *)(VAR_3->data);
VAR_4 = VAR_8->gen;
while(VAR_4)
{
VAR_5 = NULL;
VAR_13 = FALSE;
VAR_14 = FALSE;
if((VAR_1 -= VAR_17) < 0)
{
FLUID_LOG(VAR_18, ""IGEN chunk size mismatch"");
return FALSE;
}
READW(VAR_0, VAR_11);
if(VAR_11 == VAR_19)
{
if(VAR_12 == 0)
{
VAR_12 = 1;
READB(VAR_0, VAR_10.range.lo);
READB(VAR_0, VAR_10.range.hi);
}
else
{
VAR_13 = TRUE;
}
}
else if(VAR_11 == VAR_20)
{
if(VAR_12 <= 1)
{
VAR_12 = 2;
READB(VAR_0, VAR_10.range.lo);
READB(VAR_0, VAR_10.range.hi);
}
else
{
VAR_13 = TRUE;
}
}
else if(VAR_11 == VAR_21)
{
VAR_12 = 3;
READW(VAR_0, VAR_10.uword);
((SFZone *)(VAR_3->data))->instsamp = FLUID_INT_TO_POINTER(VAR_10.uword + 1);
break; 
}
else
{
VAR_12 = 2;
if(valid_inst_genid(VAR_11))
{
READW(VAR_0, VAR_10.sword);
VAR_5 = find_gen_by_id(VAR_11, VAR_8->gen);
}
else
{
VAR_13 = TRUE;
}
}
if(!VAR_13)
{
if(!VAR_5)
{
if((VAR_9 = FLUID_NEW(SFGen)) == NULL)
{
FLUID_LOG(VAR_18, ""Out of memory"");
return FALSE;
}
VAR_4->data = VAR_9;
VAR_9->id = VAR_11;
}
else
{
VAR_9 = (SFGen *)(VAR_5->data);
VAR_14 = TRUE;
}
VAR_9->amount = VAR_10;
}
else
{
VAR_16 = TRUE;
VAR_14 = TRUE;
FSKIPW(VAR_0);
}
if(!VAR_14)
{
VAR_4 = fluid_list_next(VAR_4);    
}
else
{
SLADVREM(VAR_8->gen, VAR_4);
}
} 
if(VAR_12 == 3)
{
SLADVREM(VAR_8->gen, VAR_4);    
}
else
{
if(!VAR_15)
{
VAR_15 = TRUE;
if(*VAR_6 != VAR_3)
{
void *VAR_22 = VAR_3->data;
FLUID_LOG(VAR_23, ""Instrument '%s': Global zone is not first zone"",
((SFPreset *)(VAR_2->data))->name);
SLADVREM(*VAR_6, VAR_3);
*VAR_6 = fluid_list_prepend(*VAR_6, VAR_22);
continue;
}
}
else
{
SFZone * VAR_24 = fluid_list_get(VAR_3);
FLUID_LOG(VAR_23, ""Instrument '%s': Discarding invalid global zone"",
((SFInst *)(VAR_2->data))->name);
*VAR_6 = fluid_list_remove(VAR_7, VAR_24);
delete_zone(VAR_24);
}
}
while(VAR_4)
{
VAR_16 = TRUE;
if((VAR_1 -= VAR_17) < 0)
{
FLUID_LOG(VAR_18, ""Instrument generator chunk size mismatch"");
return FALSE;
}
FSKIP(VAR_0, VAR_17);
SLADVREM(VAR_8->gen, VAR_4);
}
VAR_3 = fluid_list_next(VAR_3); 
}
if(VAR_16)
{
FLUID_LOG(VAR_23,
""Instrument '%s': Some invalid generators were discarded"",
((SFInst *)(VAR_2->data))->name);
}
VAR_2 = fluid_list_next(VAR_2);
}
if(VAR_1 == 0)
{
return TRUE;
}
VAR_1 -= VAR_17;
if(VAR_1 != 0)
{
FLUID_LOG(VAR_18, ""IGEN chunk size mismatch"");
return FALSE;
}
FSKIP(VAR_0, VAR_17); 
return TRUE;
}",FluidSynth/fluidsynth/6673a5f73c0484f8462b4b33860d2b1c68c24684/fluid_sffile.c/vul/before/0.json,"static int load_igen(SFData *sf, int size)
{
    fluid_list_t *p, *p2, *p3, *dup, **hz = NULL, *start_of_zone_list;
    SFZone *z;
    SFGen *g;
    SFGenAmount genval;
    unsigned short genid;
    int level, skip, drop, gzone, discarded;

    p = sf->inst;

    while(p)
    {
        /* traverse through all instruments */
        gzone = FALSE;
        discarded = FALSE;
        start_of_zone_list = p2 = ((SFInst *)(p->data))->zone;

        if(p2)
        {
            hz = &p2;
        }

        while(p2)
        {
            /* traverse this instrument's zones */
            level = 0;
            z = (SFZone *)(p2->data);
            p3 = z->gen;

            while(p3)
            {
                /* load zone's generators */
                dup = NULL;
                skip = FALSE;
                drop = FALSE;

                if((size -= SF_GEN_SIZE) < 0)
                {
                    FLUID_LOG(FLUID_ERR, ""IGEN chunk size mismatch"");
                    return FALSE;
                }

                READW(sf, genid);

                if(genid == Gen_KeyRange)
                {
                    /* nothing precedes */
                    if(level == 0)
                    {
                        level = 1;
                        READB(sf, genval.range.lo);
                        READB(sf, genval.range.hi);
                    }
                    else
                    {
                        skip = TRUE;
                    }
                }
                else if(genid == Gen_VelRange)
                {
                    /* only KeyRange precedes */
                    if(level <= 1)
                    {
                        level = 2;
                        READB(sf, genval.range.lo);
                        READB(sf, genval.range.hi);
                    }
                    else
                    {
                        skip = TRUE;
                    }
                }
                else if(genid == Gen_SampleId)
                {
                    /* sample is last gen */
                    level = 3;
                    READW(sf, genval.uword);
                    ((SFZone *)(p2->data))->instsamp = FLUID_INT_TO_POINTER(genval.uword + 1);
                    break; /* break out of generator loop */
                }
                else
                {
                    level = 2;

                    if(valid_inst_genid(genid))
                    {
                        /* gen valid? */
                        READW(sf, genval.sword);
                        dup = find_gen_by_id(genid, z->gen);
                    }
                    else
                    {
                        skip = TRUE;
                    }
                }

                if(!skip)
                {
                    if(!dup)
                    {
                        /* if gen ! dup alloc new */
                        if((g = FLUID_NEW(SFGen)) == NULL)
                        {
                            FLUID_LOG(FLUID_ERR, ""Out of memory"");
                            return FALSE;
                        }

                        p3->data = g;
                        g->id = genid;
                    }
                    else
                    {
                        g = (SFGen *)(dup->data);
                        drop = TRUE;
                    }

                    g->amount = genval;
                }
                else
                {
                    /* skip this generator */
                    discarded = TRUE;
                    drop = TRUE;
                    FSKIPW(sf);
                }

                if(!drop)
                {
                    p3 = fluid_list_next(p3);    /* next gen */
                }
                else
                {
                    SLADVREM(z->gen, p3);
                }

            } /* generator loop */

            if(level == 3)
            {
                SLADVREM(z->gen, p3);    /* zone has sample? */
            }
            else
            {
                /* its a global zone */
                if(!gzone)
                {
                    gzone = TRUE;

                    /* if global zone is not 1st zone, relocate */
                    if(*hz != p2)
                    {
                        void *save = p2->data;
                        FLUID_LOG(FLUID_WARN, ""Instrument '%s': Global zone is not first zone"",
                                  ((SFPreset *)(p->data))->name);
                        SLADVREM(*hz, p2);
                        *hz = fluid_list_prepend(*hz, save);
                        continue;
                    }
                }
                else
                {
                    p2 = fluid_list_next(p2); /* advance to next zone before deleting the current list element */
                    /* previous global zone exists, discard */
                    FLUID_LOG(FLUID_WARN, ""Instrument '%s': Discarding invalid global zone"",
                              ((SFInst *)(p->data))->name);
                    fluid_list_remove(start_of_zone_list, z);
                    delete_zone(z);
                    continue;
                }
            }

            while(p3)
            {
                /* Kill any zones following a sample */
                discarded = TRUE;

                if((size -= SF_GEN_SIZE) < 0)
                {
                    FLUID_LOG(FLUID_ERR, ""Instrument generator chunk size mismatch"");
                    return FALSE;
                }

                FSKIP(sf, SF_GEN_SIZE);
                SLADVREM(z->gen, p3);
            }

            p2 = fluid_list_next(p2); /* next zone */
        }

        if(discarded)
        {
            FLUID_LOG(FLUID_WARN,
                      ""Instrument '%s': Some invalid generators were discarded"",
                      ((SFInst *)(p->data))->name);
        }

        p = fluid_list_next(p);
    }

    /* for those non-terminal record cases, grr! */
    if(size == 0)
    {
        return TRUE;
    }

    size -= SF_GEN_SIZE;

    if(size != 0)
    {
        FLUID_LOG(FLUID_ERR, ""IGEN chunk size mismatch"");
        return FALSE;
    }

    FSKIP(sf, SF_GEN_SIZE); /* terminal gen */

    return TRUE;
}","static int load_igen(SFData *VAR_0, int VAR_1)
{
    fluid_list_t *VAR_2, *VAR_3, *VAR_4, *VAR_5, **VAR_6 = NULL, *VAR_7;
    SFZone *VAR_8;
    SFGen *VAR_9;
    SFGenAmount VAR_10;
    unsigned short VAR_11;
    int VAR_12, VAR_13, VAR_14, VAR_15, VAR_16;

    VAR_2 = VAR_0->inst;

    while(VAR_2)
    {
        /* COMMENT_0 */
        VAR_15 = FALSE;
        VAR_16 = FALSE;
        VAR_7 = VAR_3 = ((SFInst *)(VAR_2->data))->zone;

        if(VAR_3)
        {
            VAR_6 = &VAR_3;
        }

        while(VAR_3)
        {
            /* COMMENT_1 */
            VAR_12 = 0;
            VAR_8 = (SFZone *)(VAR_3->data);
            VAR_4 = VAR_8->gen;

            while(VAR_4)
            {
                /* COMMENT_2 */
                VAR_5 = NULL;
                VAR_13 = FALSE;
                VAR_14 = FALSE;

                if((VAR_1 -= VAR_17) < 0)
                {
                    FLUID_LOG(VAR_18, ""IGEN chunk size mismatch"");
                    return FALSE;
                }

                READW(VAR_0, VAR_11);

                if(VAR_11 == VAR_19)
                {
                    /* COMMENT_3 */
                    if(VAR_12 == 0)
                    {
                        VAR_12 = 1;
                        READB(VAR_0, VAR_10.range.lo);
                        READB(VAR_0, VAR_10.range.hi);
                    }
                    else
                    {
                        VAR_13 = TRUE;
                    }
                }
                else if(VAR_11 == VAR_20)
                {
                    /* COMMENT_4 */
                    if(VAR_12 <= 1)
                    {
                        VAR_12 = 2;
                        READB(VAR_0, VAR_10.range.lo);
                        READB(VAR_0, VAR_10.range.hi);
                    }
                    else
                    {
                        VAR_13 = TRUE;
                    }
                }
                else if(VAR_11 == VAR_21)
                {
                    /* COMMENT_5 */
                    VAR_12 = 3;
                    READW(VAR_0, VAR_10.uword);
                    ((SFZone *)(VAR_3->data))->instsamp = FLUID_INT_TO_POINTER(VAR_10.uword + 1);
                    break; /* COMMENT_6 */
                }
                else
                {
                    VAR_12 = 2;

                    if(valid_inst_genid(VAR_11))
                    {
                        /* COMMENT_7 */
                        READW(VAR_0, VAR_10.sword);
                        VAR_5 = find_gen_by_id(VAR_11, VAR_8->gen);
                    }
                    else
                    {
                        VAR_13 = TRUE;
                    }
                }

                if(!VAR_13)
                {
                    if(!VAR_5)
                    {
                        /* COMMENT_8 */
                        if((VAR_9 = FLUID_NEW(SFGen)) == NULL)
                        {
                            FLUID_LOG(VAR_18, ""Out of memory"");
                            return FALSE;
                        }

                        VAR_4->data = VAR_9;
                        VAR_9->id = VAR_11;
                    }
                    else
                    {
                        VAR_9 = (SFGen *)(VAR_5->data);
                        VAR_14 = TRUE;
                    }

                    VAR_9->amount = VAR_10;
                }
                else
                {
                    /* COMMENT_9 */
                    VAR_16 = TRUE;
                    VAR_14 = TRUE;
                    FSKIPW(VAR_0);
                }

                if(!VAR_14)
                {
                    VAR_4 = fluid_list_next(VAR_4);    /* COMMENT_10 */
                }
                else
                {
                    SLADVREM(VAR_8->gen, VAR_4);
                }

            } /* COMMENT_11 */

            if(VAR_12 == 3)
            {
                SLADVREM(VAR_8->gen, VAR_4);    /* COMMENT_12 */
            }
            else
            {
                /* COMMENT_13 */
                if(!VAR_15)
                {
                    VAR_15 = TRUE;

                    /* COMMENT_14 */
                    if(*VAR_6 != VAR_3)
                    {
                        void *VAR_22 = VAR_3->data;
                        FLUID_LOG(VAR_23, ""Instrument '%s': Global zone is not first zone"",
                                  ((SFPreset *)(VAR_2->data))->name);
                        SLADVREM(*VAR_6, VAR_3);
                        *VAR_6 = fluid_list_prepend(*VAR_6, VAR_22);
                        continue;
                    }
                }
                else
                {
                    VAR_3 = fluid_list_next(VAR_3); /* COMMENT_15 */
                    /* COMMENT_16 */
                    FLUID_LOG(VAR_23, ""Instrument '%s': Discarding invalid global zone"",
                              ((SFInst *)(VAR_2->data))->name);
                    fluid_list_remove(VAR_7, VAR_8);
                    delete_zone(VAR_8);
                    continue;
                }
            }

            while(VAR_4)
            {
                /* COMMENT_17 */
                VAR_16 = TRUE;

                if((VAR_1 -= VAR_17) < 0)
                {
                    FLUID_LOG(VAR_18, ""Instrument generator chunk size mismatch"");
                    return FALSE;
                }

                FSKIP(VAR_0, VAR_17);
                SLADVREM(VAR_8->gen, VAR_4);
            }

            VAR_3 = fluid_list_next(VAR_3); /* COMMENT_18 */
        }

        if(VAR_16)
        {
            FLUID_LOG(VAR_23,
                      ""Instrument '%s': Some invalid generators were discarded"",
                      ((SFInst *)(VAR_2->data))->name);
        }

        VAR_2 = fluid_list_next(VAR_2);
    }

    /* COMMENT_19 */
    if(VAR_1 == 0)
    {
        return TRUE;
    }

    VAR_1 -= VAR_17;

    if(VAR_1 != 0)
    {
        FLUID_LOG(VAR_18, ""IGEN chunk size mismatch"");
        return FALSE;
    }

    FSKIP(VAR_0, VAR_17); /* COMMENT_20 */

    return TRUE;
}",FluidSynth/fluidsynth/6673a5f73c0484f8462b4b33860d2b1c68c24684/fluid_sffile.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -160,12 +160,13 @@
                 }
                 else
                 {
-                    SFZone * izone = fluid_list_get(p2);
+                    p2 = fluid_list_next(p2); /* advance to next zone before deleting the current list element */
                     /* previous global zone exists, discard */
                     FLUID_LOG(FLUID_WARN, ""Instrument '%s': Discarding invalid global zone"",
                               ((SFInst *)(p->data))->name);
-                    *hz = fluid_list_remove(start_of_zone_list, izone);
-                    delete_zone(izone);
+                    fluid_list_remove(start_of_zone_list, z);
+                    delete_zone(z);
+                    continue;
                 }
             }
 ","{'deleted_lines': ['                    SFZone * izone = fluid_list_get(p2);', '                    *hz = fluid_list_remove(start_of_zone_list, izone);', '                    delete_zone(izone);'], 'added_lines': ['                    p2 = fluid_list_next(p2); /* advance to next zone before deleting the current list element */', '                    fluid_list_remove(start_of_zone_list, z);', '                    delete_zone(z);', '                    continue;']}",True,"fluidsynth is a software synthesizer based on the SoundFont 2 specifications. A use after free violation was discovered in fluidsynth, that can be triggered when loading an invalid SoundFont file.",7.2,HIGH,2,valid,2021-03-14T19:23:38Z,3
CVE-2021-31916,['CWE-787'],AV:L/AC:L/Au:N/C:P/I:P/A:C,0,torvalds/linux,"dm ioctl: fix out of bounds array access when no devices

If there are not any dm devices, we need to zero the ""dev"" argument in
the first structure dm_name_list. However, this can cause out of
bounds write, because the ""needed"" variable is zero and len may be
less than eight.

Fix this bug by reporting DM_BUFFER_FULL_FLAG if the result buffer is
too small to hold the ""nl->dev"" value.

Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
Cc: stable@vger.kernel.org
Signed-off-by: Mike Snitzer <snitzer@redhat.com>",4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a,https://github.com/torvalds/linux/commit/4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a,drivers/md/dm-ioctl.c,list_devices,"static int list_devices(struct file *filp, struct dm_ioctl *param, size_t param_size)
{
unsigned int i;
struct hash_cell *hc;
size_t len, needed = 0;
struct gendisk *disk;
struct dm_name_list *orig_nl, *nl, *old_nl = NULL;
uint32_t *event_nr;
down_write(&_hash_lock);
for (i = 0; i < NUM_BUCKETS; i++) {
list_for_each_entry (hc, _name_buckets + i, name_list) {
needed += align_val(offsetof(struct dm_name_list, name) + strlen(hc->name) + 1);
needed += align_val(sizeof(uint32_t));
}
}
nl = orig_nl = get_result_buffer(param, param_size, &len);
if (len < needed) {
param->flags |= DM_BUFFER_FULL_FLAG;
goto out;
}
param->data_size = param->data_start + needed;
nl->dev = 0;
for (i = 0; i < NUM_BUCKETS; i++) {
list_for_each_entry (hc, _name_buckets + i, name_list) {
if (old_nl)
old_nl->next = (uint32_t) ((void *) nl -
(void *) old_nl);
disk = dm_disk(hc->md);
nl->dev = huge_encode_dev(disk_devt(disk));
nl->next = 0;
strcpy(nl->name, hc->name);
old_nl = nl;
event_nr = align_ptr(nl->name + strlen(hc->name) + 1);
*event_nr = dm_get_event_nr(hc->md);
nl = align_ptr(event_nr + 1);
}
}
BUG_ON((char *)nl - (char *)orig_nl != needed);
out:
up_write(&_hash_lock);
return 0;
}","static int list_devices(struct file *VAR_0, struct dm_ioctl *VAR_1, size_t VAR_2)
{
unsigned int VAR_3;
struct hash_cell *VAR_4;
size_t VAR_5, VAR_6 = 0;
struct gendisk *VAR_7;
struct dm_name_list *VAR_8, *VAR_9, *VAR_10 = NULL;
uint32_t *VAR_11;
down_write(&VAR_12);
for (VAR_3 = 0; VAR_3 < VAR_13; VAR_3++) {
list_for_each_entry (VAR_4, VAR_14 + VAR_3, VAR_15) {
VAR_6 += align_val(offsetof(struct dm_name_list, VAR_16) + strlen(VAR_4->name) + 1);
VAR_6 += align_val(sizeof(uint32_t));
}
}
VAR_9 = VAR_8 = get_result_buffer(VAR_1, VAR_2, &VAR_5);
if (VAR_5 < VAR_6) {
VAR_1->flags |= VAR_17;
goto out;
}
VAR_1->data_size = VAR_1->data_start + VAR_6;
VAR_9->dev = 0;
for (VAR_3 = 0; VAR_3 < VAR_13; VAR_3++) {
list_for_each_entry (VAR_4, VAR_14 + VAR_3, VAR_15) {
if (VAR_10)
VAR_10->next = (uint32_t) ((void *) VAR_9 -
(void *) VAR_10);
VAR_7 = dm_disk(VAR_4->md);
VAR_9->dev = huge_encode_dev(disk_devt(VAR_7));
VAR_9->next = 0;
strcpy(VAR_9->name, VAR_4->name);
VAR_10 = VAR_9;
VAR_11 = align_ptr(VAR_9->name + strlen(VAR_4->name) + 1);
*VAR_11 = dm_get_event_nr(VAR_4->md);
VAR_9 = align_ptr(VAR_11 + 1);
}
}
BUG_ON((char *)VAR_9 - (char *)VAR_8 != VAR_6);
out:
up_write(&VAR_12);
return 0;
}",torvalds/linux/4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a/dm-ioctl.c/vul/before/0.json,"static int list_devices(struct file *filp, struct dm_ioctl *param, size_t param_size)
{
	unsigned int i;
	struct hash_cell *hc;
	size_t len, needed = 0;
	struct gendisk *disk;
	struct dm_name_list *orig_nl, *nl, *old_nl = NULL;
	uint32_t *event_nr;

	down_write(&_hash_lock);

	/*
	 * Loop through all the devices working out how much
	 * space we need.
	 */
	for (i = 0; i < NUM_BUCKETS; i++) {
		list_for_each_entry (hc, _name_buckets + i, name_list) {
			needed += align_val(offsetof(struct dm_name_list, name) + strlen(hc->name) + 1);
			needed += align_val(sizeof(uint32_t));
		}
	}

	/*
	 * Grab our output buffer.
	 */
	nl = orig_nl = get_result_buffer(param, param_size, &len);
	if (len < needed || len < sizeof(nl->dev)) {
		param->flags |= DM_BUFFER_FULL_FLAG;
		goto out;
	}
	param->data_size = param->data_start + needed;

	nl->dev = 0;	/* Flags no data */

	/*
	 * Now loop through filling out the names.
	 */
	for (i = 0; i < NUM_BUCKETS; i++) {
		list_for_each_entry (hc, _name_buckets + i, name_list) {
			if (old_nl)
				old_nl->next = (uint32_t) ((void *) nl -
							   (void *) old_nl);
			disk = dm_disk(hc->md);
			nl->dev = huge_encode_dev(disk_devt(disk));
			nl->next = 0;
			strcpy(nl->name, hc->name);

			old_nl = nl;
			event_nr = align_ptr(nl->name + strlen(hc->name) + 1);
			*event_nr = dm_get_event_nr(hc->md);
			nl = align_ptr(event_nr + 1);
		}
	}
	/*
	 * If mismatch happens, security may be compromised due to buffer
	 * overflow, so it's better to crash.
	 */
	BUG_ON((char *)nl - (char *)orig_nl != needed);

 out:
	up_write(&_hash_lock);
	return 0;
}","static int list_devices(struct file *VAR_0, struct dm_ioctl *VAR_1, size_t VAR_2)
{
	unsigned int VAR_3;
	struct hash_cell *VAR_4;
	size_t VAR_5, VAR_6 = 0;
	struct gendisk *VAR_7;
	struct dm_name_list *VAR_8, *VAR_9, *VAR_10 = NULL;
	uint32_t *VAR_11;

	down_write(&VAR_12);

	/* COMMENT_0 */
                                                     
                  
    
	for (VAR_3 = 0; VAR_3 < VAR_13; VAR_3++) {
		list_for_each_entry (VAR_4, VAR_14 + VAR_3, VAR_15) {
			VAR_6 += align_val(offsetof(struct dm_name_list, VAR_16) + strlen(VAR_4->name) + 1);
			VAR_6 += align_val(sizeof(uint32_t));
		}
	}

	/* COMMENT_4 */
                           
    
	VAR_9 = VAR_8 = get_result_buffer(VAR_1, VAR_2, &VAR_5);
	if (VAR_5 < VAR_6 || VAR_5 < sizeof(VAR_9->dev)) {
		VAR_1->flags |= VAR_17;
		goto out;
	}
	VAR_1->data_size = VAR_1->data_start + VAR_6;

	VAR_9->dev = 0;	/* COMMENT_7 */

	/* COMMENT_8 */
                                           
    
	for (VAR_3 = 0; VAR_3 < VAR_13; VAR_3++) {
		list_for_each_entry (VAR_4, VAR_14 + VAR_3, VAR_15) {
			if (VAR_10)
				VAR_10->next = (uint32_t) ((void *) VAR_9 -
							   (void *) VAR_10);
			VAR_7 = dm_disk(VAR_4->md);
			VAR_9->dev = huge_encode_dev(disk_devt(VAR_7));
			VAR_9->next = 0;
			strcpy(VAR_9->name, VAR_4->name);

			VAR_10 = VAR_9;
			VAR_11 = align_ptr(VAR_9->name + strlen(VAR_4->name) + 1);
			*VAR_11 = dm_get_event_nr(VAR_4->md);
			VAR_9 = align_ptr(VAR_11 + 1);
		}
	}
	/* COMMENT_11 */
                                                                  
                                      
    
	BUG_ON((char *)VAR_9 - (char *)VAR_8 != VAR_6);

 out:
	up_write(&VAR_12);
	return 0;
}",torvalds/linux/4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a/dm-ioctl.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -24,7 +24,7 @@
 	 * Grab our output buffer.
 	 */
 	nl = orig_nl = get_result_buffer(param, param_size, &len);
-	if (len < needed) {
+	if (len < needed || len < sizeof(nl->dev)) {
 		param->flags |= DM_BUFFER_FULL_FLAG;
 		goto out;
 	}","{'deleted_lines': ['\tif (len < needed) {'], 'added_lines': ['\tif (len < needed || len < sizeof(nl->dev)) {']}",True,An out-of-bounds (OOB) memory write flaw was found in list_devices in drivers/md/dm-ioctl.c in the Multi-device driver module in the Linux kernel before 5.12. A bound check failure allows an attacker with special user (CAP_SYS_ADMIN) privilege to gain access to out-of-bounds memory leading to a system crash or a leak of internal kernel information. The highest threat from this vulnerability is to system availability.,6.7,MEDIUM,1,valid,2021-03-26T18:32:32Z,3
CVE-2021-36979,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,unicorn-engine/unicorn,Add arm ite blocks samples from #853 (#1381),bf1713d9e011b55ca1f502a6779fc4722b4bb077,https://github.com/unicorn-engine/unicorn/commit/bf1713d9e011b55ca1f502a6779fc4722b4bb077,samples/sample_arm.c,main,"int main(int argc, char **argv, char **envp)
{
#ifdef DYNLOAD
if (!uc_dyn_load(NULL, 0)) {
printf(""Error dynamically loading shared library.\n"");
printf(""Please check that unicorn.dll/unicorn.so is available as well as\n"");
printf(""any other dependent dll/so files.\n"");
printf(""The easiest way is to place them in the same directory as this app.\n"");
return 1;
}
#endif
test_arm();
printf(""==========================\n"");
test_thumb();
#ifdef DYNLOAD
uc_dyn_free();
#endif
return 0;
}","int main(int VAR_0, char **VAR_1, char **VAR_2)
{
#ifdef VAR_3
if (!uc_dyn_load(NULL, 0)) {
printf(""Error dynamically loading shared library.\n"");
printf(""Please check that unicorn.dll/unicorn.so is available as well as\n"");
printf(""any other dependent dll/so files.\n"");
printf(""The easiest way is to place them in the same directory as this app.\n"");
return 1;
}
#endif
test_arm();
printf(""==========================\n"");
test_thumb();
#ifdef VAR_3
uc_dyn_free();
#endif
return 0;
}",unicorn-engine/unicorn/bf1713d9e011b55ca1f502a6779fc4722b4bb077/sample_arm.c/vul/before/0.json,"int main(int argc, char **argv, char **envp)
{
    // dynamically load shared library
#ifdef DYNLOAD
    if (!uc_dyn_load(NULL, 0)) {
        printf(""Error dynamically loading shared library.\n"");
        printf(""Please check that unicorn.dll/unicorn.so is available as well as\n"");
        printf(""any other dependent dll/so files.\n"");
        printf(""The easiest way is to place them in the same directory as this app.\n"");
        return 1;
    }
#endif
    
    test_arm();
    printf(""==========================\n"");
    test_thumb();
    printf(""==========================\n"");
    test_thumb_ite();
    // dynamically free shared library
#ifdef DYNLOAD
    uc_dyn_free();
#endif
    
    return 0;
}","int main(int VAR_0, char **VAR_1, char **VAR_2)
{
    /* COMMENT_0 */
#ifdef VAR_3
    if (!uc_dyn_load(NULL, 0)) {
        printf(""Error dynamically loading shared library.\n"");
        printf(""Please check that unicorn.dll/unicorn.so is available as well as\n"");
        printf(""any other dependent dll/so files.\n"");
        printf(""The easiest way is to place them in the same directory as this app.\n"");
        return 1;
    }
#endif
    
    test_arm();
    printf(""==========================\n"");
    test_thumb();
    printf(""==========================\n"");
    test_thumb_ite();
    /* COMMENT_1 */
#ifdef VAR_3
    uc_dyn_free();
#endif
    
    return 0;
}",unicorn-engine/unicorn/bf1713d9e011b55ca1f502a6779fc4722b4bb077/sample_arm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,7 +14,8 @@
     test_arm();
     printf(""==========================\n"");
     test_thumb();
-
+    printf(""==========================\n"");
+    test_thumb_ite();
     // dynamically free shared library
 #ifdef DYNLOAD
     uc_dyn_free();","{'deleted_lines': [''], 'added_lines': ['    printf(""==========================\\n"");', '    test_thumb_ite();']}",True,Unicorn Engine 1.0.2 has an out-of-bounds write in tb_flush_armeb (called from cpu_arm_exec_armeb and tcg_cpu_exec_armeb).,5.5,MEDIUM,1,valid,2021-03-30T04:06:26Z,3
CVE-2021-23165,['CWE-787'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,michaelrsweet/htmldoc,Fix a number-up crash bug (Issue #413),6e8a95561988500b5b5ae4861b3b0cbf4fba517f,https://github.com/michaelrsweet/htmldoc/commit/6e8a95561988500b5b5ae4861b3b0cbf4fba517f,htmldoc/ps-pdf.cxx,pspdf_prepare_outpages,"static void
pspdf_prepare_outpages()
{
intc, i, j;
intnup;
page_t*page;
outpage_t*outpage;
outpages = (outpage_t *)malloc(sizeof(outpage_t) * num_pages);
memset(outpages, -1, sizeof(outpage_t) * num_pages);
num_outpages = 0;
outpage      = outpages;
if (TitlePage)
{
for (i = 0, j = 0, nup = -1, page = pages;
i < chapter_starts[1];
i ++, page ++)
{
if (nup != page->nup)
{
if (j)
{
outpage ++;
num_outpages ++;
}
nup = page->nup;
j   = 0;
}
if (!j)
outpage->nup = nup;
pspdf_transform_page(num_outpages, j, i);
j ++;
if (j >= nup)
{
j = 0;
outpage ++;
num_outpages ++;
}
}
if (j)
{
outpage ++;
num_outpages ++;
}
}
if (OutputType == OUTPUT_BOOK && TocLevels > 0)
c = 0;
else
c = 1;
for (; c <= TocDocCount; c ++)
{
if (chapter_starts[c] < 0)
continue;
chapter_outstarts[c] = num_outpages;
for (i = chapter_starts[c], j = 0, nup = -1, page = pages + i;
i <= chapter_ends[c];
i ++, page ++)
{
if (nup != page->nup)
{
if (j)
{
outpage ++;
num_outpages ++;
}
nup = page->nup;
j   = 0;
}
if (!j)
outpage->nup = nup;
pspdf_transform_page(num_outpages, j, i);
j ++;
if (j >= nup)
{
j = 0;
outpage ++;
num_outpages ++;
}
}
if (j)
{
outpage ++;
num_outpages ++;
}
chapter_outends[c] = num_outpages;
}
#ifdef DEBUG
for (c = 0; c <= TocDocCount; c ++)
printf(""chapter_outstarts[%d] = %d, chapter_outends[%d] = %d\n"",
c, chapter_outstarts[c], c, chapter_outends[c]);
printf(""num_outpages = %d\n"", (int)num_outpages);
for (i = 0, outpage = outpages; i < (int)num_outpages; i ++, outpage ++)
{
printf(""outpage[%d]:\tnup=%d, pages=["", i, outpage->nup);
for (j = 0; j < outpage->nup; j ++)
printf("" %d"", outpage->pages[j]);
puts("" ]"");
page = pages + outpage->pages[0];
printf(""\t\twidth = %d, length = %d\n"", page->width, page->length);
}
for (c = 0; c <= TocDocCount; c ++)
printf(""chapter_starts[%d] = %d, chapter_ends[%d] = %d\n"",
c, chapter_starts[c], c, chapter_ends[c]);
for (i = 0; i < (int)num_pages; i ++)
printf(""pages[%d]->outpage = %d\n"", i, pages[i].outpage);
for (i = 0; i < (int)num_headings; i ++)
printf(""heading_pages[%d] = %d\n"", i, heading_pages[i]);
for (i = 0; i < (int)num_links; i ++)
printf(""links[%d].name = \""%s\"", page = %d\n"", i,
links[i].name, links[i].page);
#endif }","static void
pspdf_prepare_outpages()
{
intVAR_0, VAR_1, VAR_2;
intVAR_3;
page_t*VAR_4;
outpage_t*VAR_5;
VAR_6 = (outpage_t *)malloc(sizeof(outpage_t) * VAR_7);
memset(VAR_6, -1, sizeof(outpage_t) * VAR_7);
VAR_8 = 0;
VAR_5      = VAR_6;
if (VAR_9)
{
for (VAR_1 = 0, VAR_2 = 0, VAR_3 = -1, VAR_4 = VAR_10;
VAR_1 < VAR_11[1];
VAR_1 ++, VAR_4 ++)
{
if (VAR_3 != VAR_4->nup)
{
if (VAR_2)
{
VAR_5 ++;
VAR_8 ++;
}
VAR_3 = VAR_4->nup;
VAR_2   = 0;
}
if (!VAR_2)
VAR_5->nup = VAR_3;
pspdf_transform_page(VAR_8, VAR_2, VAR_1);
VAR_2 ++;
if (VAR_2 >= VAR_3)
{
VAR_2 = 0;
VAR_5 ++;
VAR_8 ++;
}
}
if (VAR_2)
{
VAR_5 ++;
VAR_8 ++;
}
}
if (VAR_12 == VAR_13 && VAR_14 > 0)
VAR_0 = 0;
else
VAR_0 = 1;
for (; VAR_0 <= VAR_15; VAR_0 ++)
{
if (VAR_11[VAR_0] < 0)
continue;
VAR_16[VAR_0] = VAR_8;
for (VAR_1 = VAR_11[VAR_0], VAR_2 = 0, VAR_3 = -1, VAR_4 = VAR_10 + VAR_1;
VAR_1 <= VAR_17[VAR_0];
VAR_1 ++, VAR_4 ++)
{
if (VAR_3 != VAR_4->nup)
{
if (VAR_2)
{
VAR_5 ++;
VAR_8 ++;
}
VAR_3 = VAR_4->nup;
VAR_2   = 0;
}
if (!VAR_2)
VAR_5->nup = VAR_3;
pspdf_transform_page(VAR_8, VAR_2, VAR_1);
VAR_2 ++;
if (VAR_2 >= VAR_3)
{
VAR_2 = 0;
VAR_5 ++;
VAR_8 ++;
}
}
if (VAR_2)
{
VAR_5 ++;
VAR_8 ++;
}
VAR_18[VAR_0] = VAR_8;
}
#ifdef VAR_19
for (VAR_0 = 0; VAR_0 <= VAR_15; VAR_0 ++)
printf(""chapter_outstarts[%d] = %d, chapter_outends[%d] = %d\n"",
VAR_0, VAR_16[VAR_0], VAR_0, VAR_18[VAR_0]);
printf(""num_outpages = %d\n"", (int)VAR_8);
for (VAR_1 = 0, VAR_5 = VAR_6; VAR_1 < (int)VAR_8; VAR_1 ++, VAR_5 ++)
{
printf(""outpage[%d]:\tnup=%d, pages=["", VAR_1, VAR_5->nup);
for (VAR_2 = 0; VAR_2 < VAR_5->nup; VAR_2 ++)
printf("" %d"", VAR_5->pages[VAR_2]);
puts("" ]"");
VAR_4 = VAR_10 + VAR_5->pages[0];
printf(""\t\twidth = %d, length = %d\n"", VAR_4->width, VAR_4->length);
}
for (VAR_0 = 0; VAR_0 <= VAR_15; VAR_0 ++)
printf(""chapter_starts[%d] = %d, chapter_ends[%d] = %d\n"",
VAR_0, VAR_11[VAR_0], VAR_0, VAR_17[VAR_0]);
for (VAR_1 = 0; VAR_1 < (int)VAR_7; VAR_1 ++)
printf(""pages[%d]->outpage = %d\n"", VAR_1, VAR_10[VAR_1].outpage);
for (VAR_1 = 0; VAR_1 < (int)VAR_20; VAR_1 ++)
printf(""heading_pages[%d] = %d\n"", VAR_1, VAR_21[VAR_1]);
for (VAR_1 = 0; VAR_1 < (int)VAR_22; VAR_1 ++)
printf(""links[%d].name = \""%s\"", page = %d\n"", VAR_1,
VAR_23[VAR_1].name, VAR_23[VAR_1].page);
#endif 
}",michaelrsweet/htmldoc/6e8a95561988500b5b5ae4861b3b0cbf4fba517f/ps-pdf.cxx/vul/before/0.json,"static void
pspdf_prepare_outpages()
{
  int		c, i, j;	/* Looping vars */
  int		nup;		/* Current number-up value */
  page_t	*page;		/* Current page */
  outpage_t	*outpage;	/* Current output page */


  // Allocate an output page array...
  outpages = (outpage_t *)malloc(sizeof(outpage_t) * num_pages);

  memset(outpages, -1, sizeof(outpage_t) * num_pages);

  num_outpages = 0;
  outpage      = outpages;

  // Handle the title page, as needed...
  if (TitlePage)
  {
    for (i = 0, j = 0, nup = -1, page = pages;
         i < chapter_starts[1];
	 i ++, page ++)
    {
      if (nup != page->nup)
      {
        if (j)
	{
	  // Break the current output page...
	  outpage ++;
	  num_outpages ++;
	}

	nup = page->nup;
	j   = 0;
      }

      if (!j)
	outpage->nup = nup;

      pspdf_transform_page(num_outpages, j, i);
      j ++;

      if (j >= nup)
      {
        j = 0;
	outpage ++;
	num_outpages ++;
      }
    }

    if (j)
    {
      // Break the current output page...
      outpage ++;
      num_outpages ++;
    }
  }

  // Loop through each chapter, adding pages as needed...
  if (OutputType == OUTPUT_BOOK && TocLevels > 0)
    c = 0;
  else
    c = 1;

  for (; c <= TocDocCount; c ++)
  {
    if (chapter_starts[c] < 0)
      continue;

    chapter_outstarts[c] = num_outpages;

    for (i = chapter_starts[c], j = 0, nup = -1, page = pages + i;
         i <= chapter_ends[c] && num_outpages < num_pages;
	 i ++, page ++)
    {
      if (nup != page->nup)
      {
        if (j)
	{
	  // Break the current output page...
	  outpage ++;
	  num_outpages ++;
	}

	nup = page->nup;
	j   = 0;
      }

      if (!j)
	outpage->nup = nup;

      pspdf_transform_page(num_outpages, j, i);
      j ++;

      if (j >= nup)
      {
        j = 0;
	outpage ++;
	num_outpages ++;
      }
    }

    if (j)
    {
      // Break the current output page...
      outpage ++;
      num_outpages ++;
    }

    chapter_outends[c] = num_outpages;
  }

#ifdef DEBUG
  for (c = 0; c <= TocDocCount; c ++)
    printf(""chapter_outstarts[%d] = %d, chapter_outends[%d] = %d\n"",
           c, chapter_outstarts[c], c, chapter_outends[c]);

  printf(""num_outpages = %d\n"", (int)num_outpages);
  for (i = 0, outpage = outpages; i < (int)num_outpages; i ++, outpage ++)
  {
    printf(""outpage[%d]:\tnup=%d, pages=["", i, outpage->nup);
    for (j = 0; j < outpage->nup; j ++)
      printf("" %d"", outpage->pages[j]);
    puts("" ]"");
    page = pages + outpage->pages[0];
    printf(""\t\twidth = %d, length = %d\n"", page->width, page->length);
  }

  for (c = 0; c <= TocDocCount; c ++)
    printf(""chapter_starts[%d] = %d, chapter_ends[%d] = %d\n"",
           c, chapter_starts[c], c, chapter_ends[c]);

  for (i = 0; i < (int)num_pages; i ++)
    printf(""pages[%d]->outpage = %d\n"", i, pages[i].outpage);

  for (i = 0; i < (int)num_headings; i ++)
    printf(""heading_pages[%d] = %d\n"", i, heading_pages[i]);

  for (i = 0; i < (int)num_links; i ++)
    printf(""links[%d].name = \""%s\"", page = %d\n"", i,
           links[i].name, links[i].page);
#endif // DEBUG
}","static void
pspdf_prepare_outpages()
{
  int		VAR_0, VAR_1, VAR_2;	/* COMMENT_0 */
  int		VAR_3;		/* COMMENT_1 */
  page_t	*VAR_4;		/* COMMENT_2 */
  outpage_t	*VAR_5;	/* COMMENT_3 */


  /* COMMENT_4 */
  VAR_6 = (outpage_t *)malloc(sizeof(outpage_t) * VAR_7);

  memset(VAR_6, -1, sizeof(outpage_t) * VAR_7);

  VAR_8 = 0;
  VAR_5      = VAR_6;

  /* COMMENT_5 */
  if (VAR_9)
  {
    for (VAR_1 = 0, VAR_2 = 0, VAR_3 = -1, VAR_4 = VAR_10;
         VAR_1 < VAR_11[1];
	 VAR_1 ++, VAR_4 ++)
    {
      if (VAR_3 != VAR_4->nup)
      {
        if (VAR_2)
	{
	  /* COMMENT_6 */
	  VAR_5 ++;
	  VAR_8 ++;
	}

	VAR_3 = VAR_4->nup;
	VAR_2   = 0;
      }

      if (!VAR_2)
	VAR_5->nup = VAR_3;

      pspdf_transform_page(VAR_8, VAR_2, VAR_1);
      VAR_2 ++;

      if (VAR_2 >= VAR_3)
      {
        VAR_2 = 0;
	VAR_5 ++;
	VAR_8 ++;
      }
    }

    if (VAR_2)
    {
      /* COMMENT_6 */
      VAR_5 ++;
      VAR_8 ++;
    }
  }

  /* COMMENT_7 */
  if (VAR_12 == VAR_13 && VAR_14 > 0)
    VAR_0 = 0;
  else
    VAR_0 = 1;

  for (; VAR_0 <= VAR_15; VAR_0 ++)
  {
    if (VAR_11[VAR_0] < 0)
      continue;

    VAR_16[VAR_0] = VAR_8;

    for (VAR_1 = VAR_11[VAR_0], VAR_2 = 0, VAR_3 = -1, VAR_4 = VAR_10 + VAR_1;
         VAR_1 <= VAR_17[VAR_0] && VAR_8 < VAR_7;
	 VAR_1 ++, VAR_4 ++)
    {
      if (VAR_3 != VAR_4->nup)
      {
        if (VAR_2)
	{
	  /* COMMENT_6 */
	  VAR_5 ++;
	  VAR_8 ++;
	}

	VAR_3 = VAR_4->nup;
	VAR_2   = 0;
      }

      if (!VAR_2)
	VAR_5->nup = VAR_3;

      pspdf_transform_page(VAR_8, VAR_2, VAR_1);
      VAR_2 ++;

      if (VAR_2 >= VAR_3)
      {
        VAR_2 = 0;
	VAR_5 ++;
	VAR_8 ++;
      }
    }

    if (VAR_2)
    {
      /* COMMENT_6 */
      VAR_5 ++;
      VAR_8 ++;
    }

    VAR_18[VAR_0] = VAR_8;
  }

#ifdef VAR_19
  for (VAR_0 = 0; VAR_0 <= VAR_15; VAR_0 ++)
    printf(""chapter_outstarts[%d] = %d, chapter_outends[%d] = %d\n"",
           VAR_0, VAR_16[VAR_0], VAR_0, VAR_18[VAR_0]);

  printf(""num_outpages = %d\n"", (int)VAR_8);
  for (VAR_1 = 0, VAR_5 = VAR_6; VAR_1 < (int)VAR_8; VAR_1 ++, VAR_5 ++)
  {
    printf(""outpage[%d]:\tnup=%d, pages=["", VAR_1, VAR_5->nup);
    for (VAR_2 = 0; VAR_2 < VAR_5->nup; VAR_2 ++)
      printf("" %d"", VAR_5->pages[VAR_2]);
    puts("" ]"");
    VAR_4 = VAR_10 + VAR_5->pages[0];
    printf(""\t\twidth = %d, length = %d\n"", VAR_4->width, VAR_4->length);
  }

  for (VAR_0 = 0; VAR_0 <= VAR_15; VAR_0 ++)
    printf(""chapter_starts[%d] = %d, chapter_ends[%d] = %d\n"",
           VAR_0, VAR_11[VAR_0], VAR_0, VAR_17[VAR_0]);

  for (VAR_1 = 0; VAR_1 < (int)VAR_7; VAR_1 ++)
    printf(""pages[%d]->outpage = %d\n"", VAR_1, VAR_10[VAR_1].outpage);

  for (VAR_1 = 0; VAR_1 < (int)VAR_20; VAR_1 ++)
    printf(""heading_pages[%d] = %d\n"", VAR_1, VAR_21[VAR_1]);

  for (VAR_1 = 0; VAR_1 < (int)VAR_22; VAR_1 ++)
    printf(""links[%d].name = \""%s\"", page = %d\n"", VAR_1,
           VAR_23[VAR_1].name, VAR_23[VAR_1].page);
#endif /* COMMENT_8 */
}",michaelrsweet/htmldoc/6e8a95561988500b5b5ae4861b3b0cbf4fba517f/ps-pdf.cxx/vul/after/0.json,"--- func_before
+++ func_after
@@ -71,7 +71,7 @@
     chapter_outstarts[c] = num_outpages;
 
     for (i = chapter_starts[c], j = 0, nup = -1, page = pages + i;
-         i <= chapter_ends[c];
+         i <= chapter_ends[c] && num_outpages < num_pages;
 	 i ++, page ++)
     {
       if (nup != page->nup)","{'deleted_lines': ['         i <= chapter_ends[c];'], 'added_lines': ['         i <= chapter_ends[c] && num_outpages < num_pages;']}",True,"A flaw was found in htmldoc before v1.9.12. Heap buffer overflow in pspdf_prepare_outpages(), in ps-pdf.cxx may lead to execute arbitrary code and denial of service.",9.8,CRITICAL,3,valid,2021-04-01T13:47:56Z,3
CVE-2021-22547,['CWE-120'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,GoogleCloudPlatform/iot-device-sdk-embedded-c,calloc limits,46cccccb7bf94d935890a177f6160ede91780ef3,https://github.com/GoogleCloudPlatform/iot-device-sdk-embedded-c/commit/46cccccb7bf94d935890a177f6160ede91780ef3,src/libiotc/memory/iotc_allocator.c,__iotc_calloc,"void* __iotc_calloc(size_t num, size_t byte_count) {
const size_t size_to_allocate = num * byte_count;
void* ret = iotc_bsp_mem_alloc(size_to_allocate);
if (NULL != ret) {
memset(ret, 0, size_to_allocate);
}
return ret;
}","void* __iotc_calloc(size_t VAR_0, size_t VAR_1) {
const size_t VAR_2 = VAR_0 * VAR_1;
void* VAR_3 = iotc_bsp_mem_alloc(VAR_2);
if (NULL != VAR_3) {
memset(VAR_3, 0, VAR_2);
}
return VAR_3;
}",GoogleCloudPlatform/iot-device-sdk-embedded-c/46cccccb7bf94d935890a177f6160ede91780ef3/iotc_allocator.c/vul/before/0.json,"void* __iotc_calloc(size_t num, size_t byte_count) {
  const size_t size_to_allocate = num * byte_count;

  /* Prevent overflow. */
  if (size_to_allocate == 0 || num  > SIZE_MAX / byte_count) {
    return NULL;
  }

  void* ret = iotc_bsp_mem_alloc(size_to_allocate);

  /* It's unspecified if memset works with NULL pointer. */
  if (NULL != ret) {
    memset(ret, 0, size_to_allocate);
  }
  return ret;
}","void* __iotc_calloc(size_t VAR_0, size_t VAR_1) {
  const size_t VAR_2 = VAR_0 * VAR_1;

  /* COMMENT_0 */
  if (VAR_2 == 0 || VAR_0  > VAR_3 / VAR_1) {
    return NULL;
  }

  void* VAR_4 = iotc_bsp_mem_alloc(VAR_2);

  /* COMMENT_1 */
  if (NULL != VAR_4) {
    memset(VAR_4, 0, VAR_2);
  }
  return VAR_4;
}",GoogleCloudPlatform/iot-device-sdk-embedded-c/46cccccb7bf94d935890a177f6160ede91780ef3/iotc_allocator.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,11 +1,16 @@
 void* __iotc_calloc(size_t num, size_t byte_count) {
   const size_t size_to_allocate = num * byte_count;
+
+  /* Prevent overflow. */
+  if (size_to_allocate == 0 || num  > SIZE_MAX / byte_count) {
+    return NULL;
+  }
+
   void* ret = iotc_bsp_mem_alloc(size_to_allocate);
 
   /* It's unspecified if memset works with NULL pointer. */
   if (NULL != ret) {
     memset(ret, 0, size_to_allocate);
   }
-
   return ret;
 }","{'deleted_lines': [''], 'added_lines': ['', '  /* Prevent overflow. */', '  if (size_to_allocate == 0 || num  > SIZE_MAX / byte_count) {', '    return NULL;', '  }', '']}",True,"In IoT Devices SDK, there is an implementation of calloc() that doesn't have a length check. An attacker could pass in memory objects larger than the buffer and wrap around to have a smaller buffer than required, allowing the attacker access to the other parts of the heap. We recommend upgrading the Google Cloud IoT Device SDK for Embedded C used to 1.0.3 or greater.",7.8,HIGH,2,valid,2021-04-06T20:02:06Z,3
CVE-2021-36084,['CWE-416'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,SELinuxProject/selinux,"libsepol/cil: Destroy classperms list when resetting classpermission

Nicolas Iooss reports:
  A few months ago, OSS-Fuzz found a crash in the CIL compiler, which
  got reported as
  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=28648 (the title
  is misleading, or is caused by another issue that conflicts with the
  one I report in this message). Here is a minimized CIL policy which
  reproduces the issue:

  (class CLASS (PERM))
  (classorder (CLASS))
  (sid SID)
  (sidorder (SID))
  (user USER)
  (role ROLE)
  (type TYPE)
  (category CAT)
  (categoryorder (CAT))
  (sensitivity SENS)
  (sensitivityorder (SENS))
  (sensitivitycategory SENS (CAT))
  (allow TYPE self (CLASS (PERM)))
  (roletype ROLE TYPE)
  (userrole USER ROLE)
  (userlevel USER (SENS))
  (userrange USER ((SENS)(SENS (CAT))))
  (sidcontext SID (USER ROLE TYPE ((SENS)(SENS))))

  (classpermission CLAPERM)

  (optional OPT
      (roletype nonexistingrole nonexistingtype)
      (classpermissionset CLAPERM (CLASS (PERM)))
  )

  The CIL policy fuzzer (which mimics secilc built with clang Address
  Sanitizer) reports:

  ==36541==ERROR: AddressSanitizer: heap-use-after-free on address
  0x603000004f98 at pc 0x56445134c842 bp 0x7ffe2a256590 sp
  0x7ffe2a256588
  READ of size 8 at 0x603000004f98 thread T0
      #0 0x56445134c841 in __cil_verify_classperms
  /selinux/libsepol/src/../cil/src/cil_verify.c:1620:8
      #1 0x56445134a43e in __cil_verify_classpermission
  /selinux/libsepol/src/../cil/src/cil_verify.c:1650:9
      #2 0x56445134a43e in __cil_pre_verify_helper
  /selinux/libsepol/src/../cil/src/cil_verify.c:1715:8
      #3 0x5644513225ac in cil_tree_walk_core
  /selinux/libsepol/src/../cil/src/cil_tree.c:272:9
      #4 0x564451322ab1 in cil_tree_walk
  /selinux/libsepol/src/../cil/src/cil_tree.c:316:7
      #5 0x5644513226af in cil_tree_walk_core
  /selinux/libsepol/src/../cil/src/cil_tree.c:284:9
      #6 0x564451322ab1 in cil_tree_walk
  /selinux/libsepol/src/../cil/src/cil_tree.c:316:7
      #7 0x5644512b88fd in cil_pre_verify
  /selinux/libsepol/src/../cil/src/cil_post.c:2510:7
      #8 0x5644512b88fd in cil_post_process
  /selinux/libsepol/src/../cil/src/cil_post.c:2524:7
      #9 0x5644511856ff in cil_compile
  /selinux/libsepol/src/../cil/src/cil.c:564:7

The classperms list of a classpermission rule is created and filled
in when classpermissionset rules are processed, so it doesn't own any
part of the list and shouldn't retain any of it when it is reset.

Destroy the classperms list (without destroying the data in it)  when
resetting a classpermission rule.

Reported-by: Nicolas Iooss <nicolas.iooss@m4x.org>
Signed-off-by: James Carter <jwcart2@gmail.com>",f34d3d30c8325e4847a6b696fe7a3936a8a361f3,https://github.com/SELinuxProject/selinux/commit/f34d3d30c8325e4847a6b696fe7a3936a8a361f3,libsepol/cil/src/cil_reset_ast.c,cil_reset_classpermission,"static void cil_reset_classpermission(struct cil_classpermission *cp)
{
if (cp == NULL) {
return;
}
cil_reset_classperms_list(cp->classperms);
}","static void cil_reset_classpermission(struct cil_classpermission *VAR_0)
{
if (VAR_0 == NULL) {
return;
}
cil_reset_classperms_list(VAR_0->classperms);
}",SELinuxProject/selinux/f34d3d30c8325e4847a6b696fe7a3936a8a361f3/cil_reset_ast.c/vul/before/0.json,"static void cil_reset_classpermission(struct cil_classpermission *cp)
{
	if (cp == NULL) {
		return;
	}

	cil_list_destroy(&cp->classperms, CIL_FALSE);
}","static void cil_reset_classpermission(struct cil_classpermission *VAR_0)
{
	if (VAR_0 == NULL) {
		return;
	}

	cil_list_destroy(&VAR_0->classperms, VAR_1);
}",SELinuxProject/selinux/f34d3d30c8325e4847a6b696fe7a3936a8a361f3/cil_reset_ast.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,5 +4,5 @@
 		return;
 	}
 
-	cil_reset_classperms_list(cp->classperms);
+	cil_list_destroy(&cp->classperms, CIL_FALSE);
 }","{'deleted_lines': ['\tcil_reset_classperms_list(cp->classperms);'], 'added_lines': ['\tcil_list_destroy(&cp->classperms, CIL_FALSE);']}",True,The CIL compiler in SELinux 3.2 has a use-after-free in __cil_verify_classperms (called from __cil_verify_classpermission and __cil_pre_verify_helper).,3.3,LOW,0,valid,2021-04-08T17:32:01Z,3
CVE-2021-29464,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,Exiv2/exiv2,Better bounds checking in Jp2Image::encodeJp2Header(),f9308839198aca5e68a65194f151a1de92398f54,https://github.com/Exiv2/exiv2/commit/f9308839198aca5e68a65194f151a1de92398f54,src/jp2image.cpp,Jp2Image::encodeJp2Header,"void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf)
{
DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100);         int     outlen = sizeof(Jp2BoxHeader) ;         int      inlen = sizeof(Jp2BoxHeader) ;         Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;
int32_t       length = getLong((byte*)&pBox->length, bigEndian);
int32_t       count  = sizeof (Jp2BoxHeader);
char*         p      = (char*) boxBuf.pData_;
bool          bWroteColor = false ;
while ( count < length || !bWroteColor ) {
Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ;
Jp2BoxHeader   subBox ; memcpy(&subBox,pSubBox,sizeof(subBox));
Jp2BoxHeader   newBox =  subBox;
if ( count < length ) {
subBox.length = getLong((byte*)&subBox.length, bigEndian);
subBox.type   = getLong((byte*)&subBox.type  , bigEndian);
#ifdef EXIV2_DEBUG_MESSAGES
std::cout << ""Jp2Image::encodeJp2Header subbox: ""<< toAscii(subBox.type) << "" length = "" << subBox.length << std::endl;
#endif
count        += subBox.length;
newBox.type   = subBox.type;
} else {
subBox.length=0;
newBox.type = kJp2BoxTypeColorHeader;
count = length;
}
int32_t newlen = subBox.length;
if ( newBox.type == kJp2BoxTypeColorHeader ) {
bWroteColor = true ;
if ( ! iccProfileDefined() ) {
const char* pad   = ""\x01\x00\x00\x00\x00\x00\x10\x00\x00\x05\x1cuuid"";
uint32_t    psize = 15;
newlen            = sizeof(newBox) + psize ;
ul2Data((byte*)&newBox.length,psize      ,bigEndian);
ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);
::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));
::memcpy(output.pData_+outlen+sizeof(newBox)      ,pad                ,psize         );
} else {
const char* pad   = ""\x02\x00\x00"";
uint32_t    psize = 3;
newlen            = sizeof(newBox) + psize + iccProfile_.size_;
ul2Data((byte*)&newBox.length,newlen,bigEndian);
ul2Data((byte*)&newBox.type,newBox.type,bigEndian);
::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );
::memcpy(output.pData_+outlen+sizeof(newBox)      , pad               ,psize           );
::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);
}
} else {
::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);
}
outlen += newlen;
inlen  += subBox.length;
}
outBuf.alloc(outlen);
::memcpy(outBuf.pData_,output.pData_,outlen);
pBox   = (Jp2BoxHeader*) outBuf.pData_;
ul2Data((byte*)&pBox->type,kJp2BoxTypeJp2Header,bigEndian);
ul2Data((byte*)&pBox->length,outlen,bigEndian);
}","void Jp2Image::encodeJp2Header(const DataBuf& VAR_0,DataBuf& VAR_1)
{
DataBuf VAR_2(VAR_0.size_ + VAR_3.size_ + 100); 
int     VAR_4 = sizeof(VAR_5) ; 
int      VAR_6 = sizeof(VAR_5) ; 
Jp2BoxHeader* VAR_7   = (Jp2BoxHeader*) VAR_0.pData_;
int32_t       VAR_8 = getLong((byte*)&VAR_7->length, VAR_9);
int32_t       VAR_10  = sizeof (Jp2BoxHeader);
char*         VAR_11      = (char*) VAR_0.pData_;
bool          VAR_12 = false ;
while ( VAR_10 < VAR_8 || !VAR_12 ) {
Jp2BoxHeader* VAR_13 = (Jp2BoxHeader*) (VAR_11+VAR_10) ;
Jp2BoxHeader   VAR_14 ; memcpy(&VAR_14,VAR_13,sizeof(VAR_14));
Jp2BoxHeader   VAR_15 =  VAR_14;
if ( VAR_10 < VAR_8 ) {
VAR_14.length = getLong((byte*)&VAR_14.length, VAR_9);
VAR_14.type   = getLong((byte*)&VAR_14.type  , VAR_9);
#ifdef VAR_16
std::cout << ""Jp2Image::encodeJp2Header subbox: ""<< toAscii(VAR_14.type) << "" length = "" << VAR_14.length << std::endl;
#endif
VAR_10        += VAR_14.length;
VAR_15.type   = VAR_14.type;
} else {
VAR_14.length=0;
VAR_15.type = VAR_17;
VAR_10 = VAR_8;
}
int32_t VAR_18 = VAR_14.length;
if ( VAR_15.type == VAR_17 ) {
VAR_12 = true ;
if ( ! iccProfileDefined() ) {
const char* VAR_19   = ""\x01\x00\x00\x00\x00\x00\x10\x00\x00\x05\x1cuuid"";
uint32_t    VAR_20 = 15;
VAR_18            = sizeof(VAR_15) + VAR_20 ;
ul2Data((byte*)&VAR_15.length,VAR_20      ,VAR_9);
ul2Data((byte*)&VAR_15.type  ,VAR_15.type,VAR_9);
::memcpy(VAR_2.pData_+VAR_4                     ,&VAR_15            ,sizeof(VAR_15));
::memcpy(VAR_2.pData_+VAR_4+sizeof(VAR_15)      ,VAR_19                ,VAR_20         );
} else {
const char* VAR_19   = ""\x02\x00\x00"";
uint32_t    VAR_20 = 3;
VAR_18            = sizeof(VAR_15) + VAR_20 + VAR_3.size_;
ul2Data((byte*)&VAR_15.length,VAR_18,VAR_9);
ul2Data((byte*)&VAR_15.type,VAR_15.type,VAR_9);
::memcpy(VAR_2.pData_+VAR_4                     ,&VAR_15            ,sizeof(VAR_15)  );
::memcpy(VAR_2.pData_+VAR_4+sizeof(VAR_15)      , VAR_19               ,VAR_20           );
::memcpy(VAR_2.pData_+VAR_4+sizeof(VAR_15)+VAR_20,VAR_3.pData_,VAR_3.size_);
}
} else {
::memcpy(VAR_2.pData_+VAR_4,VAR_0.pData_+VAR_6,VAR_14.length);
}
VAR_4 += VAR_18;
VAR_6  += VAR_14.length;
}
VAR_1.alloc(VAR_4);
::memcpy(VAR_1.pData_,VAR_2.pData_,VAR_4);
VAR_7   = (Jp2BoxHeader*) VAR_1.pData_;
ul2Data((byte*)&VAR_7->type,VAR_21,VAR_9);
ul2Data((byte*)&VAR_7->length,VAR_4,VAR_9);
}",Exiv2/exiv2/f9308839198aca5e68a65194f151a1de92398f54/jp2image.cpp/vul/before/0.json,"void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf)
    {
        DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100); // allocate sufficient space
        long    outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?
        long    inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?
        Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;
        uint32_t      length = getLong((byte*)&pBox->length, bigEndian);
        uint32_t      count  = sizeof (Jp2BoxHeader);
        char*         p      = (char*) boxBuf.pData_;
        bool          bWroteColor = false ;

        while ( count < length || !bWroteColor ) {
            Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ;

            // copy data.  pointer could be into a memory mapped file which we will decode!
            Jp2BoxHeader   subBox ; memcpy(&subBox,pSubBox,sizeof(subBox));
            Jp2BoxHeader   newBox =  subBox;

            if ( count < length ) {
                subBox.length = getLong((byte*)&subBox.length, bigEndian);
                subBox.type   = getLong((byte*)&subBox.type  , bigEndian);
#ifdef EXIV2_DEBUG_MESSAGES
                std::cout << ""Jp2Image::encodeJp2Header subbox: ""<< toAscii(subBox.type) << "" length = "" << subBox.length << std::endl;
#endif
                enforce(subBox.length <= length - count, Exiv2::kerCorruptedMetadata);
                count        += subBox.length;
                newBox.type   = subBox.type;
            } else {
                subBox.length=0;
                newBox.type = kJp2BoxTypeColorHeader;
                count = length;
            }

            uint32_t newlen = subBox.length;
            if ( newBox.type == kJp2BoxTypeColorHeader ) {
                bWroteColor = true ;
                if ( ! iccProfileDefined() ) {
                    const char* pad   = ""\x01\x00\x00\x00\x00\x00\x10\x00\x00\x05\x1cuuid"";
                    uint32_t    psize = 15;
                    newlen            = sizeof(newBox) + psize ;
                    enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);
                    ul2Data((byte*)&newBox.length,psize      ,bigEndian);
                    ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);
                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));
                    ::memcpy(output.pData_+outlen+sizeof(newBox)      ,pad                ,psize         );
                } else {
                    const char* pad   = ""\x02\x00\x00"";
                    uint32_t    psize = 3;
                    newlen            = sizeof(newBox) + psize + iccProfile_.size_;
                    enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);
                    ul2Data((byte*)&newBox.length,newlen,bigEndian);
                    ul2Data((byte*)&newBox.type,newBox.type,bigEndian);
                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );
                    ::memcpy(output.pData_+outlen+sizeof(newBox)      , pad               ,psize           );
                    ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);
                }
            } else {
                enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);
                ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);
            }

            outlen += newlen;
            inlen  += subBox.length;
        }

        // allocate the correct number of bytes, copy the data and update the box header
        outBuf.alloc(outlen);
        ::memcpy(outBuf.pData_,output.pData_,outlen);
        pBox   = (Jp2BoxHeader*) outBuf.pData_;
        ul2Data((byte*)&pBox->type,kJp2BoxTypeJp2Header,bigEndian);
        ul2Data((byte*)&pBox->length,outlen,bigEndian);
    }","void Jp2Image::encodeJp2Header(const DataBuf& VAR_0,DataBuf& VAR_1)
    {
        DataBuf VAR_2(VAR_0.size_ + VAR_3.size_ + 100); /* COMMENT_0 */
        long    VAR_4 = sizeof(VAR_5) ; /* COMMENT_1 */
        long    VAR_6 = sizeof(VAR_5) ; /* COMMENT_2 */
        Jp2BoxHeader* VAR_7   = (Jp2BoxHeader*) VAR_0.pData_;
        uint32_t      VAR_8 = getLong((byte*)&VAR_7->length, VAR_9);
        uint32_t      VAR_10  = sizeof (Jp2BoxHeader);
        char*         VAR_11      = (char*) VAR_0.pData_;
        bool          VAR_12 = false ;

        while ( VAR_10 < VAR_8 || !VAR_12 ) {
            Jp2BoxHeader* VAR_13 = (Jp2BoxHeader*) (VAR_11+VAR_10) ;

            /* COMMENT_3 */
            Jp2BoxHeader   VAR_14 ; memcpy(&VAR_14,VAR_13,sizeof(VAR_14));
            Jp2BoxHeader   VAR_15 =  VAR_14;

            if ( VAR_10 < VAR_8 ) {
                VAR_14.length = getLong((byte*)&VAR_14.length, VAR_9);
                VAR_14.type   = getLong((byte*)&VAR_14.type  , VAR_9);
#ifdef VAR_16
                std::cout << ""Jp2Image::encodeJp2Header subbox: ""<< toAscii(VAR_14.type) << "" length = "" << VAR_14.length << std::endl;
#endif
                enforce(VAR_14.length <= VAR_8 - VAR_10, Exiv2::kerCorruptedMetadata);
                VAR_10        += VAR_14.length;
                VAR_15.type   = VAR_14.type;
            } else {
                VAR_14.length=0;
                VAR_15.type = VAR_17;
                VAR_10 = VAR_8;
            }

            uint32_t VAR_18 = VAR_14.length;
            if ( VAR_15.type == VAR_17 ) {
                VAR_12 = true ;
                if ( ! iccProfileDefined() ) {
                    const char* VAR_19   = ""\x01\x00\x00\x00\x00\x00\x10\x00\x00\x05\x1cuuid"";
                    uint32_t    VAR_20 = 15;
                    VAR_18            = sizeof(VAR_15) + VAR_20 ;
                    enforce(VAR_18 <= VAR_2.size_ - VAR_4, Exiv2::kerCorruptedMetadata);
                    ul2Data((byte*)&VAR_15.length,VAR_20      ,VAR_9);
                    ul2Data((byte*)&VAR_15.type  ,VAR_15.type,VAR_9);
                    ::memcpy(VAR_2.pData_+VAR_4                     ,&VAR_15            ,sizeof(VAR_15));
                    ::memcpy(VAR_2.pData_+VAR_4+sizeof(VAR_15)      ,VAR_19                ,VAR_20         );
                } else {
                    const char* VAR_19   = ""\x02\x00\x00"";
                    uint32_t    VAR_20 = 3;
                    VAR_18            = sizeof(VAR_15) + VAR_20 + VAR_3.size_;
                    enforce(VAR_18 <= VAR_2.size_ - VAR_4, Exiv2::kerCorruptedMetadata);
                    ul2Data((byte*)&VAR_15.length,VAR_18,VAR_9);
                    ul2Data((byte*)&VAR_15.type,VAR_15.type,VAR_9);
                    ::memcpy(VAR_2.pData_+VAR_4                     ,&VAR_15            ,sizeof(VAR_15)  );
                    ::memcpy(VAR_2.pData_+VAR_4+sizeof(VAR_15)      , VAR_19               ,VAR_20           );
                    ::memcpy(VAR_2.pData_+VAR_4+sizeof(VAR_15)+VAR_20,VAR_3.pData_,VAR_3.size_);
                }
            } else {
                enforce(VAR_18 <= VAR_2.size_ - VAR_4, Exiv2::kerCorruptedMetadata);
                ::memcpy(VAR_2.pData_+VAR_4,VAR_0.pData_+VAR_6,VAR_14.length);
            }

            VAR_4 += VAR_18;
            VAR_6  += VAR_14.length;
        }

        /* COMMENT_4 */
        VAR_1.alloc(VAR_4);
        ::memcpy(VAR_1.pData_,VAR_2.pData_,VAR_4);
        VAR_7   = (Jp2BoxHeader*) VAR_1.pData_;
        ul2Data((byte*)&VAR_7->type,VAR_21,VAR_9);
        ul2Data((byte*)&VAR_7->length,VAR_4,VAR_9);
    }",Exiv2/exiv2/f9308839198aca5e68a65194f151a1de92398f54/jp2image.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,11 +1,11 @@
 void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf)
     {
         DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100); // allocate sufficient space
-        int     outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?
-        int      inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?
+        long    outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?
+        long    inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?
         Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;
-        int32_t       length = getLong((byte*)&pBox->length, bigEndian);
-        int32_t       count  = sizeof (Jp2BoxHeader);
+        uint32_t      length = getLong((byte*)&pBox->length, bigEndian);
+        uint32_t      count  = sizeof (Jp2BoxHeader);
         char*         p      = (char*) boxBuf.pData_;
         bool          bWroteColor = false ;
 
@@ -22,6 +22,7 @@
 #ifdef EXIV2_DEBUG_MESSAGES
                 std::cout << ""Jp2Image::encodeJp2Header subbox: ""<< toAscii(subBox.type) << "" length = "" << subBox.length << std::endl;
 #endif
+                enforce(subBox.length <= length - count, Exiv2::kerCorruptedMetadata);
                 count        += subBox.length;
                 newBox.type   = subBox.type;
             } else {
@@ -30,13 +31,14 @@
                 count = length;
             }
 
-            int32_t newlen = subBox.length;
+            uint32_t newlen = subBox.length;
             if ( newBox.type == kJp2BoxTypeColorHeader ) {
                 bWroteColor = true ;
                 if ( ! iccProfileDefined() ) {
                     const char* pad   = ""\x01\x00\x00\x00\x00\x00\x10\x00\x00\x05\x1cuuid"";
                     uint32_t    psize = 15;
                     newlen            = sizeof(newBox) + psize ;
+                    enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);
                     ul2Data((byte*)&newBox.length,psize      ,bigEndian);
                     ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);
                     ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));
@@ -45,6 +47,7 @@
                     const char* pad   = ""\x02\x00\x00"";
                     uint32_t    psize = 3;
                     newlen            = sizeof(newBox) + psize + iccProfile_.size_;
+                    enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);
                     ul2Data((byte*)&newBox.length,newlen,bigEndian);
                     ul2Data((byte*)&newBox.type,newBox.type,bigEndian);
                     ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );
@@ -52,6 +55,7 @@
                     ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);
                 }
             } else {
+                enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);
                 ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);
             }
 ","{'deleted_lines': ['        int     outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?', '        int      inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?', '        int32_t       length = getLong((byte*)&pBox->length, bigEndian);', '        int32_t       count  = sizeof (Jp2BoxHeader);', '            int32_t newlen = subBox.length;'], 'added_lines': ['        long    outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?', '        long    inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?', '        uint32_t      length = getLong((byte*)&pBox->length, bigEndian);', '        uint32_t      count  = sizeof (Jp2BoxHeader);', '                enforce(subBox.length <= length - count, Exiv2::kerCorruptedMetadata);', '            uint32_t newlen = subBox.length;', '                    enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);', '                    enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);', '                enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);']}",True,"Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. A heap buffer overflow was found in Exiv2 versions v0.27.3 and earlier. The heap overflow is triggered when Exiv2 is used to write metadata into a crafted image file. An attacker could potentially exploit the vulnerability to gain code execution, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when writing the metadata, which is a less frequently used Exiv2 operation than reading the metadata. For example, to trigger the bug in the Exiv2 command-line application, you need to add an extra command-line argument such as `insert`. The bug is fixed in version v0.27.4.",3.3,LOW,0,valid,2021-04-20T11:04:13Z,3
CVE-2021-29530,['CWE-476'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"Remove `OP_REQUIRES` call from helper function.

Since `OP_REQUIRES` macro expands to a `return;` (among other), calling it in a helper function only ends the helper function's execution earlier, but the kernel will still run from start to end. Thus, all the expected validations are actually broken/useless as the code ploughs through the next crash anyway.

PiperOrigin-RevId: 369524386
Change-Id: I54f6cf9328445675ccc392e661b04336b229c9da",e6a7c7cc18c3aaad1ae0872cb0a959f5c923d2bd,https://github.com/tensorflow/tensorflow/commit/e6a7c7cc18c3aaad1ae0872cb0a959f5c923d2bd,tensorflow/core/kernels/sparse/sparse_cholesky_op.cc,ValidateInputs,"void ValidateInputs(OpKernelContext* ctx,
const CSRSparseMatrix& sparse_matrix,
const Tensor& permutation_indices, int* batch_size,
int64* num_rows) {
OP_REQUIRES(ctx, sparse_matrix.dtype() == DataTypeToEnum<T>::value,
errors::InvalidArgument(
""Asked for a CSRSparseMatrix of type "",
DataTypeString(DataTypeToEnum<T>::value),
"" but saw dtype: "", DataTypeString(sparse_matrix.dtype())));
const Tensor& dense_shape = sparse_matrix.dense_shape();
const int rank = dense_shape.dim_size(0);
OP_REQUIRES(ctx, rank == 2 || rank == 3,
errors::InvalidArgument(""sparse matrix must have rank 2 or 3; "",
""but dense_shape has size "", rank));
const int row_dim = (rank == 2) ? 0 : 1;
auto dense_shape_vec = dense_shape.vec<int64>();
*num_rows = dense_shape_vec(row_dim);
const int64 num_cols = dense_shape_vec(row_dim + 1);
OP_REQUIRES(ctx, *num_rows == num_cols,
errors::InvalidArgument(""sparse matrix must be square; got: "",
*num_rows, "" != "", num_cols));
const TensorShape& perm_shape = permutation_indices.shape();
OP_REQUIRES(
ctx, perm_shape.dims() + 1 == rank,
errors::InvalidArgument(
""sparse matrix must have the same rank as permutation; got: "", rank,
"" != "", perm_shape.dims(), "" + 1.""));
OP_REQUIRES(
ctx, perm_shape.dim_size(rank - 2) == *num_rows,
errors::InvalidArgument(
""permutation must have the same number of elements in each batch ""
""as the number of rows in sparse matrix; got: "",
perm_shape.dim_size(rank - 2), "" != "", *num_rows));
*batch_size = sparse_matrix.batch_size();
if (*batch_size > 1) {
OP_REQUIRES(
ctx, perm_shape.dim_size(0) == *batch_size,
errors::InvalidArgument(""permutation must have the same batch size ""
""as sparse matrix; got: "",
perm_shape.dim_size(0), "" != "", *batch_size));
}
}","void ValidateInputs(OpKernelContext* VAR_0,
const CSRSparseMatrix& VAR_1,
const Tensor& VAR_2, int* VAR_3,
int64* VAR_4) {
OP_REQUIRES(VAR_0, VAR_1.dtype() == DataTypeToEnum<T>::value,
errors::InvalidArgument(
""Asked for a CSRSparseMatrix of type "",
DataTypeString(DataTypeToEnum<T>::value),
"" but saw dtype: "", DataTypeString(VAR_1.dtype())));
const Tensor& VAR_5 = VAR_1.dense_shape();
const int VAR_6 = VAR_5.dim_size(0);
OP_REQUIRES(VAR_0, VAR_6 == 2 || VAR_6 == 3,
errors::InvalidArgument(""sparse matrix must have rank 2 or 3; "",
""but dense_shape has size "", VAR_6));
const int VAR_7 = (VAR_6 == 2) ? 0 : 1;
auto VAR_8 = VAR_5.vec<int64>();
*VAR_4 = VAR_8(VAR_7);
const int64 VAR_9 = VAR_8(VAR_7 + 1);
OP_REQUIRES(VAR_0, *VAR_4 == VAR_9,
errors::InvalidArgument(""sparse matrix must be square; got: "",
*VAR_4, "" != "", VAR_9));
const TensorShape& VAR_10 = VAR_2.shape();
OP_REQUIRES(
VAR_0, VAR_10.dims() + 1 == VAR_6,
errors::InvalidArgument(
""sparse matrix must have the same rank as permutation; got: "", VAR_6,
"" != "", VAR_10.dims(), "" + 1.""));
OP_REQUIRES(
VAR_0, VAR_10.dim_size(VAR_6 - 2) == *VAR_4,
errors::InvalidArgument(
""permutation must have the same number of elements in each batch ""
""as the number of rows in sparse matrix; got: "",
VAR_10.dim_size(VAR_6 - 2), "" != "", *VAR_4));
*VAR_3 = VAR_1.batch_size();
if (*VAR_3 > 1) {
OP_REQUIRES(
VAR_0, VAR_10.dim_size(0) == *VAR_3,
errors::InvalidArgument(""permutation must have the same batch size ""
""as sparse matrix; got: "",
VAR_10.dim_size(0), "" != "", *VAR_3));
}
}",tensorflow/e6a7c7cc18c3aaad1ae0872cb0a959f5c923d2bd/sparse_cholesky_op.cc/vul/before/1.json,"Status ValidateInputs(const CSRSparseMatrix& sparse_matrix,
                        const Tensor& permutation_indices, int* batch_size,
                        int64* num_rows) {
    if (sparse_matrix.dtype() != DataTypeToEnum<T>::value)
      return errors::InvalidArgument(
          ""Asked for a CSRSparseMatrix of type "",
          DataTypeString(DataTypeToEnum<T>::value),
          "" but saw dtype: "", DataTypeString(sparse_matrix.dtype()));

    const Tensor& dense_shape = sparse_matrix.dense_shape();
    const int rank = dense_shape.dim_size(0);
    if (rank < 2 || rank > 3)
      return errors::InvalidArgument(""sparse matrix must have rank 2 or 3; "",
                                     ""but dense_shape has size "", rank);
    const int row_dim = (rank == 2) ? 0 : 1;
    auto dense_shape_vec = dense_shape.vec<int64>();
    *num_rows = dense_shape_vec(row_dim);
    const int64 num_cols = dense_shape_vec(row_dim + 1);
    if (*num_rows != num_cols)
      return errors::InvalidArgument(
          ""sparse matrix must be square; got: "", *num_rows, "" != "", num_cols);
    const TensorShape& perm_shape = permutation_indices.shape();
    if (perm_shape.dims() + 1 != rank)
      return errors::InvalidArgument(
          ""sparse matrix must have the same rank as permutation; got: "", rank,
          "" != "", perm_shape.dims(), "" + 1."");
    if (perm_shape.dim_size(rank - 2) != *num_rows)
      return errors::InvalidArgument(
          ""permutation must have the same number of elements in each batch ""
          ""as the number of rows in sparse matrix; got: "",
          perm_shape.dim_size(rank - 2), "" != "", *num_rows);

    *batch_size = sparse_matrix.batch_size();
    if (*batch_size > 1) {
      if (perm_shape.dim_size(0) != *batch_size)
        return errors::InvalidArgument(
            ""permutation must have the same batch size ""
            ""as sparse matrix; got: "",
            perm_shape.dim_size(0), "" != "", *batch_size);
    }

    return Status::OK();
  }","Status ValidateInputs(const CSRSparseMatrix& VAR_0,
                        const Tensor& VAR_1, int* VAR_2,
                        int64* VAR_3) {
    if (VAR_0.dtype() != DataTypeToEnum<T>::value)
      return errors::InvalidArgument(
          ""Asked for a CSRSparseMatrix of type "",
          DataTypeString(DataTypeToEnum<T>::value),
          "" but saw dtype: "", DataTypeString(VAR_0.dtype()));

    const Tensor& VAR_4 = VAR_0.dense_shape();
    const int VAR_5 = VAR_4.dim_size(0);
    if (VAR_5 < 2 || VAR_5 > 3)
      return errors::InvalidArgument(""sparse matrix must have rank 2 or 3; "",
                                     ""but dense_shape has size "", VAR_5);
    const int VAR_6 = (VAR_5 == 2) ? 0 : 1;
    auto VAR_7 = VAR_4.vec<int64>();
    *VAR_3 = VAR_7(VAR_6);
    const int64 VAR_8 = VAR_7(VAR_6 + 1);
    if (*VAR_3 != VAR_8)
      return errors::InvalidArgument(
          ""sparse matrix must be square; got: "", *VAR_3, "" != "", VAR_8);
    const TensorShape& VAR_9 = VAR_1.shape();
    if (VAR_9.dims() + 1 != VAR_5)
      return errors::InvalidArgument(
          ""sparse matrix must have the same rank as permutation; got: "", VAR_5,
          "" != "", VAR_9.dims(), "" + 1."");
    if (VAR_9.dim_size(VAR_5 - 2) != *VAR_3)
      return errors::InvalidArgument(
          ""permutation must have the same number of elements in each batch ""
          ""as the number of rows in sparse matrix; got: "",
          VAR_9.dim_size(VAR_5 - 2), "" != "", *VAR_3);

    *VAR_2 = VAR_0.batch_size();
    if (*VAR_2 > 1) {
      if (VAR_9.dim_size(0) != *VAR_2)
        return errors::InvalidArgument(
            ""permutation must have the same batch size ""
            ""as sparse matrix; got: "",
            VAR_9.dim_size(0), "" != "", *VAR_2);
    }

    return Status::OK();
  }",tensorflow/e6a7c7cc18c3aaad1ae0872cb0a959f5c923d2bd/sparse_cholesky_op.cc/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,44 +1,43 @@
-void ValidateInputs(OpKernelContext* ctx,
-                      const CSRSparseMatrix& sparse_matrix,
-                      const Tensor& permutation_indices, int* batch_size,
-                      int64* num_rows) {
-    OP_REQUIRES(ctx, sparse_matrix.dtype() == DataTypeToEnum<T>::value,
-                errors::InvalidArgument(
-                    ""Asked for a CSRSparseMatrix of type "",
-                    DataTypeString(DataTypeToEnum<T>::value),
-                    "" but saw dtype: "", DataTypeString(sparse_matrix.dtype())));
+Status ValidateInputs(const CSRSparseMatrix& sparse_matrix,
+                        const Tensor& permutation_indices, int* batch_size,
+                        int64* num_rows) {
+    if (sparse_matrix.dtype() != DataTypeToEnum<T>::value)
+      return errors::InvalidArgument(
+          ""Asked for a CSRSparseMatrix of type "",
+          DataTypeString(DataTypeToEnum<T>::value),
+          "" but saw dtype: "", DataTypeString(sparse_matrix.dtype()));
 
     const Tensor& dense_shape = sparse_matrix.dense_shape();
     const int rank = dense_shape.dim_size(0);
-    OP_REQUIRES(ctx, rank == 2 || rank == 3,
-                errors::InvalidArgument(""sparse matrix must have rank 2 or 3; "",
-                                        ""but dense_shape has size "", rank));
+    if (rank < 2 || rank > 3)
+      return errors::InvalidArgument(""sparse matrix must have rank 2 or 3; "",
+                                     ""but dense_shape has size "", rank);
     const int row_dim = (rank == 2) ? 0 : 1;
     auto dense_shape_vec = dense_shape.vec<int64>();
     *num_rows = dense_shape_vec(row_dim);
     const int64 num_cols = dense_shape_vec(row_dim + 1);
-    OP_REQUIRES(ctx, *num_rows == num_cols,
-                errors::InvalidArgument(""sparse matrix must be square; got: "",
-                                        *num_rows, "" != "", num_cols));
+    if (*num_rows != num_cols)
+      return errors::InvalidArgument(
+          ""sparse matrix must be square; got: "", *num_rows, "" != "", num_cols);
     const TensorShape& perm_shape = permutation_indices.shape();
-    OP_REQUIRES(
-        ctx, perm_shape.dims() + 1 == rank,
-        errors::InvalidArgument(
-            ""sparse matrix must have the same rank as permutation; got: "", rank,
-            "" != "", perm_shape.dims(), "" + 1.""));
-    OP_REQUIRES(
-        ctx, perm_shape.dim_size(rank - 2) == *num_rows,
-        errors::InvalidArgument(
-            ""permutation must have the same number of elements in each batch ""
-            ""as the number of rows in sparse matrix; got: "",
-            perm_shape.dim_size(rank - 2), "" != "", *num_rows));
+    if (perm_shape.dims() + 1 != rank)
+      return errors::InvalidArgument(
+          ""sparse matrix must have the same rank as permutation; got: "", rank,
+          "" != "", perm_shape.dims(), "" + 1."");
+    if (perm_shape.dim_size(rank - 2) != *num_rows)
+      return errors::InvalidArgument(
+          ""permutation must have the same number of elements in each batch ""
+          ""as the number of rows in sparse matrix; got: "",
+          perm_shape.dim_size(rank - 2), "" != "", *num_rows);
 
     *batch_size = sparse_matrix.batch_size();
     if (*batch_size > 1) {
-      OP_REQUIRES(
-          ctx, perm_shape.dim_size(0) == *batch_size,
-          errors::InvalidArgument(""permutation must have the same batch size ""
-                                  ""as sparse matrix; got: "",
-                                  perm_shape.dim_size(0), "" != "", *batch_size));
+      if (perm_shape.dim_size(0) != *batch_size)
+        return errors::InvalidArgument(
+            ""permutation must have the same batch size ""
+            ""as sparse matrix; got: "",
+            perm_shape.dim_size(0), "" != "", *batch_size);
     }
+
+    return Status::OK();
   }","{'deleted_lines': ['void ValidateInputs(OpKernelContext* ctx,', '                      const CSRSparseMatrix& sparse_matrix,', '                      const Tensor& permutation_indices, int* batch_size,', '                      int64* num_rows) {', '    OP_REQUIRES(ctx, sparse_matrix.dtype() == DataTypeToEnum<T>::value,', '                errors::InvalidArgument(', '                    ""Asked for a CSRSparseMatrix of type "",', '                    DataTypeString(DataTypeToEnum<T>::value),', '                    "" but saw dtype: "", DataTypeString(sparse_matrix.dtype())));', '    OP_REQUIRES(ctx, rank == 2 || rank == 3,', '                errors::InvalidArgument(""sparse matrix must have rank 2 or 3; "",', '                                        ""but dense_shape has size "", rank));', '    OP_REQUIRES(ctx, *num_rows == num_cols,', '                errors::InvalidArgument(""sparse matrix must be square; got: "",', '                                        *num_rows, "" != "", num_cols));', '    OP_REQUIRES(', '        ctx, perm_shape.dims() + 1 == rank,', '        errors::InvalidArgument(', '            ""sparse matrix must have the same rank as permutation; got: "", rank,', '            "" != "", perm_shape.dims(), "" + 1.""));', '    OP_REQUIRES(', '        ctx, perm_shape.dim_size(rank - 2) == *num_rows,', '        errors::InvalidArgument(', '            ""permutation must have the same number of elements in each batch ""', '            ""as the number of rows in sparse matrix; got: "",', '            perm_shape.dim_size(rank - 2), "" != "", *num_rows));', '      OP_REQUIRES(', '          ctx, perm_shape.dim_size(0) == *batch_size,', '          errors::InvalidArgument(""permutation must have the same batch size ""', '                                  ""as sparse matrix; got: "",', '                                  perm_shape.dim_size(0), "" != "", *batch_size));'], 'added_lines': ['Status ValidateInputs(const CSRSparseMatrix& sparse_matrix,', '                        const Tensor& permutation_indices, int* batch_size,', '                        int64* num_rows) {', '    if (sparse_matrix.dtype() != DataTypeToEnum<T>::value)', '      return errors::InvalidArgument(', '          ""Asked for a CSRSparseMatrix of type "",', '          DataTypeString(DataTypeToEnum<T>::value),', '          "" but saw dtype: "", DataTypeString(sparse_matrix.dtype()));', '    if (rank < 2 || rank > 3)', '      return errors::InvalidArgument(""sparse matrix must have rank 2 or 3; "",', '                                     ""but dense_shape has size "", rank);', '    if (*num_rows != num_cols)', '      return errors::InvalidArgument(', '          ""sparse matrix must be square; got: "", *num_rows, "" != "", num_cols);', '    if (perm_shape.dims() + 1 != rank)', '      return errors::InvalidArgument(', '          ""sparse matrix must have the same rank as permutation; got: "", rank,', '          "" != "", perm_shape.dims(), "" + 1."");', '    if (perm_shape.dim_size(rank - 2) != *num_rows)', '      return errors::InvalidArgument(', '          ""permutation must have the same number of elements in each batch ""', '          ""as the number of rows in sparse matrix; got: "",', '          perm_shape.dim_size(rank - 2), "" != "", *num_rows);', '      if (perm_shape.dim_size(0) != *batch_size)', '        return errors::InvalidArgument(', '            ""permutation must have the same batch size ""', '            ""as sparse matrix; got: "",', '            perm_shape.dim_size(0), "" != "", *batch_size);', '', '    return Status::OK();']}",True,"TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference by providing an invalid `permutation` to `tf.raw_ops.SparseMatrixSparseCholesky`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/080f1d9e257589f78b3ffb75debf584168aa6062/tensorflow/core/kernels/sparse/sparse_cholesky_op.cc#L85-L86) fails to properly validate the input arguments. Although `ValidateInputs` is called and there are checks in the body of this function, the code proceeds to the next line in `ValidateInputs` since `OP_REQUIRES`(https://github.com/tensorflow/tensorflow/blob/080f1d9e257589f78b3ffb75debf584168aa6062/tensorflow/core/framework/op_requires.h#L41-L48) is a macro that only exits the current function. Thus, the first validation condition that fails in `ValidateInputs` will cause an early return from that function. However, the caller will continue execution from the next line. The fix is to either explicitly check `context->status()` or to convert `ValidateInputs` to return a `Status`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",2.5,LOW,0,valid,2021-04-20T21:45:33Z,3
CVE-2021-29530,['CWE-476'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"Remove `OP_REQUIRES` call from helper function.

Since `OP_REQUIRES` macro expands to a `return;` (among other), calling it in a helper function only ends the helper function's execution earlier, but the kernel will still run from start to end. Thus, all the expected validations are actually broken/useless as the code ploughs through the next crash anyway.

PiperOrigin-RevId: 369524386
Change-Id: I54f6cf9328445675ccc392e661b04336b229c9da",e6a7c7cc18c3aaad1ae0872cb0a959f5c923d2bd,https://github.com/tensorflow/tensorflow/commit/e6a7c7cc18c3aaad1ae0872cb0a959f5c923d2bd,tensorflow/core/kernels/sparse/sparse_cholesky_op.cc,Compute,"void Compute(OpKernelContext* ctx) final {
const CSRSparseMatrix* input_matrix;
OP_REQUIRES_OK(ctx, ExtractVariantFromInput(ctx, 0, &input_matrix));
const Tensor& input_permutation_indices = ctx->input(1);
int64 num_rows;
int batch_size;
ValidateInputs(ctx, *input_matrix, input_permutation_indices, &batch_size,
&num_rows);
Tensor batch_ptr(cpu_allocator(), DT_INT32, TensorShape({batch_size + 1}));
auto batch_ptr_vec = batch_ptr.vec<int32>();
batch_ptr_vec(0) = 0;
std::vector<SparseMatrix> sparse_cholesky_factors(batch_size);
const double nnz_per_row =
(input_matrix->total_nnz() / batch_size) / num_rows;
const int64 sparse_cholesky_cost_per_batch =
nnz_per_row * nnz_per_row * num_rows;
auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads());
std::atomic<int64> invalid_input_index(-1);
Shard(worker_threads.num_threads, worker_threads.workers, batch_size,
sparse_cholesky_cost_per_batch,
[&](int64 batch_begin, int64 batch_end) {
for (int64 batch_index = batch_begin; batch_index < batch_end;
++batch_index) {
Eigen::Map<const SparseMatrix> sparse_matrix(
num_rows, num_rows, input_matrix->nnz(batch_index),
input_matrix->row_pointers_vec(batch_index).data(),
input_matrix->col_indices_vec(batch_index).data(),
input_matrix->values_vec<T>(batch_index).data());
Eigen::SimplicialLLT<SparseMatrix, Eigen::Upper,
Eigen::NaturalOrdering<int>>
solver;
auto permutation_indices_flat =
input_permutation_indices.flat<int32>().data();
Eigen::Map<
Eigen::PermutationMatrix<Eigen::Dynamic, Eigen::Dynamic, int>>
permutation(permutation_indices_flat + batch_index * num_rows,
num_rows);
auto permutation_inverse = permutation.inverse();
SparseMatrix permuted_sparse_matrix;
permuted_sparse_matrix.template selfadjointView<Eigen::Upper>() =
sparse_matrix.template selfadjointView<Eigen::Upper>()
.twistedBy(permutation_inverse);
solver.compute(permuted_sparse_matrix);
if (solver.info() != Eigen::Success) {
invalid_input_index = batch_index;
return;
}
sparse_cholesky_factors[batch_index] =
std::move(solver.matrixU());
batch_ptr_vec(batch_index + 1) =
sparse_cholesky_factors[batch_index].nonZeros();
}
});
OP_REQUIRES(
ctx, invalid_input_index == -1,
errors::InvalidArgument(
""Sparse Cholesky factorization failed for batch index "",
invalid_input_index.load(), "". The input might not be valid.""));
std::partial_sum(batch_ptr_vec.data(),
batch_ptr_vec.data() + batch_size + 1,
batch_ptr_vec.data());
const int64 total_nnz = batch_ptr_vec(batch_size);
Tensor output_row_ptr(cpu_allocator(), DT_INT32,
TensorShape({(num_rows + 1) * batch_size}));
Tensor output_col_ind(cpu_allocator(), DT_INT32, TensorShape({total_nnz}));
Tensor output_values(cpu_allocator(), DataTypeToEnum<T>::value,
TensorShape({total_nnz}));
auto output_row_ptr_ptr = output_row_ptr.flat<int32>().data();
auto output_col_ind_ptr = output_col_ind.flat<int32>().data();
auto output_values_ptr = output_values.flat<T>().data();
Shard(worker_threads.num_threads, worker_threads.workers, batch_size,
(3 * total_nnz) / batch_size ,
[&](int64 batch_begin, int64 batch_end) {
for (int64 batch_index = batch_begin; batch_index < batch_end;
++batch_index) {
const SparseMatrix& cholesky_factor =
sparse_cholesky_factors[batch_index];
const int64 nnz = cholesky_factor.nonZeros();
std::copy(cholesky_factor.outerIndexPtr(),
cholesky_factor.outerIndexPtr() + num_rows + 1,
output_row_ptr_ptr + batch_index * (num_rows + 1));
std::copy(cholesky_factor.innerIndexPtr(),
cholesky_factor.innerIndexPtr() + nnz,
output_col_ind_ptr + batch_ptr_vec(batch_index));
std::copy(cholesky_factor.valuePtr(),
cholesky_factor.valuePtr() + nnz,
output_values_ptr + batch_ptr_vec(batch_index));
}
});
CSRSparseMatrix output_csr_matrix;
OP_REQUIRES_OK(
ctx,
CSRSparseMatrix::CreateCSRSparseMatrix(
DataTypeToEnum<T>::value, input_matrix->dense_shape(), batch_ptr,
output_row_ptr, output_col_ind, output_values, &output_csr_matrix));
Tensor* output_csr_matrix_tensor;
AllocatorAttributes cpu_alloc;
cpu_alloc.set_on_host(true);
OP_REQUIRES_OK(
ctx, ctx->allocate_output(0, TensorShape({}), &output_csr_matrix_tensor,
cpu_alloc));
output_csr_matrix_tensor->scalar<Variant>()() =
std::move(output_csr_matrix);
}","void Compute(OpKernelContext* VAR_0) final {
const CSRSparseMatrix* VAR_1;
OP_REQUIRES_OK(VAR_0, ExtractVariantFromInput(VAR_0, 0, &VAR_1));
const Tensor& VAR_2 = VAR_0->input(1);
int64 VAR_3;
int VAR_4;
ValidateInputs(VAR_0, *VAR_1, VAR_2, &VAR_4,
&VAR_3);
Tensor VAR_5(cpu_allocator(), VAR_6, TensorShape({VAR_4 + 1}));
auto VAR_7 = VAR_5.vec<int32>();
VAR_7(0) = 0;
std::vector<SparseMatrix> sparse_cholesky_factors(batch_size);
const double VAR_8 =
(VAR_1->total_nnz() / batch_size) / VAR_3;
const int64 VAR_9 =
VAR_8 * VAR_8 * VAR_3;
auto VAR_10 = *(VAR_0->device()->tensorflow_cpu_worker_threads());
std::atomic<int64> VAR_11(-1);
Shard(VAR_10.num_threads, VAR_10.workers, batch_size,
VAR_9,
[&](int64 VAR_12, int64 VAR_13) {
for (int64 VAR_14 = VAR_12; VAR_14 < VAR_13;
++VAR_14) {
Eigen::Map<const SparseMatrix> VAR_15(
VAR_3, VAR_3, VAR_1->nnz(VAR_14),
VAR_1->row_pointers_vec(VAR_14).data(),
VAR_1->col_indices_vec(VAR_14).data(),
VAR_1->values_vec<T>(VAR_14).data());
Eigen::SimplicialLLT<SparseMatrix, Eigen::Upper,
Eigen::NaturalOrdering<int>>
VAR_16;
auto VAR_17 =
VAR_2.flat<int32>().data();
Eigen::Map<
Eigen::PermutationMatrix<Eigen::Dynamic, Eigen::Dynamic, int>>
VAR_18(VAR_17 + VAR_14 * VAR_3,
VAR_3);
auto VAR_19 = VAR_18.inverse();
SparseMatrix VAR_20;
VAR_20.template selfadjointView<Eigen::Upper>() =
VAR_15.template selfadjointView<Eigen::Upper>()
.twistedBy(VAR_19);
VAR_16.compute(VAR_20);
if (VAR_16.info() != Eigen::Success) {
VAR_11 = VAR_14;
return;
}
VAR_21[VAR_14] =
std::move(VAR_16.matrixU());
VAR_7(VAR_14 + 1) =
VAR_21[VAR_14].nonZeros();
}
});
OP_REQUIRES(
VAR_0, VAR_11 == -1,
errors::InvalidArgument(
""Sparse Cholesky factorization failed for batch index "",
VAR_11.load(), "". The input might not be valid.""));
std::partial_sum(VAR_7.data(),
VAR_7.data() + batch_size + 1,
VAR_7.data());
const int64 VAR_22 = VAR_7(batch_size);
Tensor VAR_23(cpu_allocator(), VAR_6,
TensorShape({(VAR_3 + 1) * batch_size}));
Tensor VAR_24(cpu_allocator(), VAR_6, TensorShape({VAR_22}));
Tensor VAR_25(cpu_allocator(), DataTypeToEnum<T>::value,
TensorShape({VAR_22}));
auto VAR_26 = VAR_23.flat<int32>().data();
auto VAR_27 = VAR_24.flat<int32>().data();
auto VAR_28 = VAR_25.flat<T>().data();
Shard(VAR_10.num_threads, VAR_10.workers, batch_size,
(3 * VAR_22) / batch_size ,
[&](int64 VAR_12, int64 VAR_13) {
for (int64 VAR_14 = VAR_12; VAR_14 < VAR_13;
++VAR_14) {
const SparseMatrix& VAR_29 =
VAR_21[VAR_14];
const int64 VAR_30 = VAR_29.nonZeros();
std::copy(VAR_29.outerIndexPtr(),
VAR_29.outerIndexPtr() + VAR_3 + 1,
VAR_26 + VAR_14 * (VAR_3 + 1));
std::copy(VAR_29.innerIndexPtr(),
VAR_29.innerIndexPtr() + VAR_30,
VAR_27 + VAR_7(VAR_14));
std::copy(VAR_29.valuePtr(),
VAR_29.valuePtr() + VAR_30,
VAR_28 + VAR_7(VAR_14));
}
});
CSRSparseMatrix VAR_31;
OP_REQUIRES_OK(
VAR_0,
CSRSparseMatrix::CreateCSRSparseMatrix(
DataTypeToEnum<T>::value, VAR_1->dense_shape(), VAR_5,
VAR_23, VAR_24, VAR_25, &VAR_31));
Tensor* VAR_32;
AllocatorAttributes VAR_33;
VAR_33.set_on_host(true);
OP_REQUIRES_OK(
VAR_0, VAR_0->allocate_output(0, TensorShape({}), &VAR_32,
VAR_33));
VAR_32->scalar<Variant>()() =
std::move(VAR_31);
}",,"void Compute(OpKernelContext* ctx) final {
    // Extract inputs and validate shapes and types.
    const CSRSparseMatrix* input_matrix;
    OP_REQUIRES_OK(ctx, ExtractVariantFromInput(ctx, 0, &input_matrix));
    const Tensor& input_permutation_indices = ctx->input(1);

    int64 num_rows;
    int batch_size;
    OP_REQUIRES_OK(ctx, ValidateInputs(*input_matrix, input_permutation_indices,
                                       &batch_size, &num_rows));

    // Allocate batch pointers.
    Tensor batch_ptr(cpu_allocator(), DT_INT32, TensorShape({batch_size + 1}));
    auto batch_ptr_vec = batch_ptr.vec<int32>();
    batch_ptr_vec(0) = 0;

    // Temporary vector of Eigen SparseMatrices to store the Sparse Cholesky
    // factors.
    // Note: we use column-compressed (CSC) SparseMatrix because SimplicialLLT
    // returns the factors in column major format. Since our input should be
    // symmetric, column major and row major is identical in storage. We just
    // have to switch to reading the upper triangular part of the input, which
    // corresponds to the lower triangular part in row major format.
    std::vector<SparseMatrix> sparse_cholesky_factors(batch_size);

    // TODO(anudhyan): Tune the cost per unit based on benchmarks.
    const double nnz_per_row =
        (input_matrix->total_nnz() / batch_size) / num_rows;
    const int64 sparse_cholesky_cost_per_batch =
        nnz_per_row * nnz_per_row * num_rows;
    // Perform sparse Cholesky factorization of each batch in parallel.
    auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads());
    std::atomic<int64> invalid_input_index(-1);
    Shard(worker_threads.num_threads, worker_threads.workers, batch_size,
          sparse_cholesky_cost_per_batch,
          [&](int64 batch_begin, int64 batch_end) {
            for (int64 batch_index = batch_begin; batch_index < batch_end;
                 ++batch_index) {
              // Define an Eigen SparseMatrix Map to operate on the
              // CSRSparseMatrix component without copying the data.
              Eigen::Map<const SparseMatrix> sparse_matrix(
                  num_rows, num_rows, input_matrix->nnz(batch_index),
                  input_matrix->row_pointers_vec(batch_index).data(),
                  input_matrix->col_indices_vec(batch_index).data(),
                  input_matrix->values_vec<T>(batch_index).data());

              Eigen::SimplicialLLT<SparseMatrix, Eigen::Upper,
                                   Eigen::NaturalOrdering<int>>
                  solver;
              auto permutation_indices_flat =
                  input_permutation_indices.flat<int32>().data();

              // Invert the fill-in reducing ordering and apply it to the input
              // sparse matrix.
              Eigen::Map<
                  Eigen::PermutationMatrix<Eigen::Dynamic, Eigen::Dynamic, int>>
                  permutation(permutation_indices_flat + batch_index * num_rows,
                              num_rows);
              auto permutation_inverse = permutation.inverse();

              SparseMatrix permuted_sparse_matrix;
              permuted_sparse_matrix.template selfadjointView<Eigen::Upper>() =
                  sparse_matrix.template selfadjointView<Eigen::Upper>()
                      .twistedBy(permutation_inverse);

              // Compute the Cholesky decomposition.
              solver.compute(permuted_sparse_matrix);
              if (solver.info() != Eigen::Success) {
                invalid_input_index = batch_index;
                return;
              }

              // Get the upper triangular factor, which would end up in the
              // lower triangular part of the output CSRSparseMatrix when
              // interpreted in row major format.
              sparse_cholesky_factors[batch_index] =
                  std::move(solver.matrixU());
              // For now, batch_ptr contains the number of nonzeros in each
              // batch.
              batch_ptr_vec(batch_index + 1) =
                  sparse_cholesky_factors[batch_index].nonZeros();
            }
          });

    // Check for invalid input.
    OP_REQUIRES(
        ctx, invalid_input_index == -1,
        errors::InvalidArgument(
            ""Sparse Cholesky factorization failed for batch index "",
            invalid_input_index.load(), "". The input might not be valid.""));

    // Compute a cumulative sum to obtain the batch pointers.
    std::partial_sum(batch_ptr_vec.data(),
                     batch_ptr_vec.data() + batch_size + 1,
                     batch_ptr_vec.data());

    // Allocate output Tensors.
    const int64 total_nnz = batch_ptr_vec(batch_size);
    Tensor output_row_ptr(cpu_allocator(), DT_INT32,
                          TensorShape({(num_rows + 1) * batch_size}));
    Tensor output_col_ind(cpu_allocator(), DT_INT32, TensorShape({total_nnz}));
    Tensor output_values(cpu_allocator(), DataTypeToEnum<T>::value,
                         TensorShape({total_nnz}));
    auto output_row_ptr_ptr = output_row_ptr.flat<int32>().data();
    auto output_col_ind_ptr = output_col_ind.flat<int32>().data();
    auto output_values_ptr = output_values.flat<T>().data();

    // Copy the output matrices from each batch into the CSRSparseMatrix
    // Tensors.
    // TODO(b/129906419): Factor out the copy from Eigen SparseMatrix to
    // CSRSparseMatrix into common utils. This is also used in
    // SparseMatrixSparseMatMul.
    Shard(worker_threads.num_threads, worker_threads.workers, batch_size,
          (3 * total_nnz) / batch_size /* cost per unit */,
          [&](int64 batch_begin, int64 batch_end) {
            for (int64 batch_index = batch_begin; batch_index < batch_end;
                 ++batch_index) {
              const SparseMatrix& cholesky_factor =
                  sparse_cholesky_factors[batch_index];
              const int64 nnz = cholesky_factor.nonZeros();

              std::copy(cholesky_factor.outerIndexPtr(),
                        cholesky_factor.outerIndexPtr() + num_rows + 1,
                        output_row_ptr_ptr + batch_index * (num_rows + 1));
              std::copy(cholesky_factor.innerIndexPtr(),
                        cholesky_factor.innerIndexPtr() + nnz,
                        output_col_ind_ptr + batch_ptr_vec(batch_index));
              std::copy(cholesky_factor.valuePtr(),
                        cholesky_factor.valuePtr() + nnz,
                        output_values_ptr + batch_ptr_vec(batch_index));
            }
          });

    // Create the CSRSparseMatrix instance from its component Tensors and
    // prepare the Variant output Tensor.
    CSRSparseMatrix output_csr_matrix;
    OP_REQUIRES_OK(
        ctx,
        CSRSparseMatrix::CreateCSRSparseMatrix(
            DataTypeToEnum<T>::value, input_matrix->dense_shape(), batch_ptr,
            output_row_ptr, output_col_ind, output_values, &output_csr_matrix));
    Tensor* output_csr_matrix_tensor;
    AllocatorAttributes cpu_alloc;
    cpu_alloc.set_on_host(true);
    OP_REQUIRES_OK(
        ctx, ctx->allocate_output(0, TensorShape({}), &output_csr_matrix_tensor,
                                  cpu_alloc));
    output_csr_matrix_tensor->scalar<Variant>()() =
        std::move(output_csr_matrix);
  }","void Compute(OpKernelContext* VAR_0) final {
    /* COMMENT_0 */
    const CSRSparseMatrix* VAR_1;
    OP_REQUIRES_OK(VAR_0, ExtractVariantFromInput(VAR_0, 0, &VAR_1));
    const Tensor& VAR_2 = VAR_0->input(1);

    int64 VAR_3;
    int VAR_4;
    OP_REQUIRES_OK(VAR_0, ValidateInputs(*VAR_1, VAR_2,
                                       &VAR_4, &VAR_3));

    /* COMMENT_1 */
    Tensor VAR_5(cpu_allocator(), VAR_6, TensorShape({VAR_4 + 1}));
    auto VAR_7 = VAR_5.vec<int32>();
    VAR_7(0) = 0;

    /* COMMENT_2 */
    /* COMMENT_3 */
    /* COMMENT_4 */
    /* COMMENT_5 */
    /* COMMENT_6 */
    /* COMMENT_7 */
    /* COMMENT_8 */
    std::vector<SparseMatrix> sparse_cholesky_factors(batch_size);

    /* COMMENT_9 */
    const double VAR_8 =
        (VAR_1->total_nnz() / batch_size) / VAR_3;
    const int64 VAR_9 =
        VAR_8 * VAR_8 * VAR_3;
    /* COMMENT_10 */
    auto VAR_10 = *(VAR_0->device()->tensorflow_cpu_worker_threads());
    std::atomic<int64> VAR_11(-1);
    Shard(VAR_10.num_threads, VAR_10.workers, batch_size,
          VAR_9,
          [&](int64 VAR_12, int64 VAR_13) {
            for (int64 VAR_14 = VAR_12; VAR_14 < VAR_13;
                 ++VAR_14) {
              /* COMMENT_11 */
              /* COMMENT_12 */
              Eigen::Map<const SparseMatrix> VAR_15(
                  VAR_3, VAR_3, VAR_1->nnz(VAR_14),
                  VAR_1->row_pointers_vec(VAR_14).data(),
                  VAR_1->col_indices_vec(VAR_14).data(),
                  VAR_1->values_vec<T>(VAR_14).data());

              Eigen::SimplicialLLT<SparseMatrix, Eigen::Upper,
                                   Eigen::NaturalOrdering<int>>
                  VAR_16;
              auto VAR_17 =
                  VAR_2.flat<int32>().data();

              /* COMMENT_13 */
              /* COMMENT_14 */
              Eigen::Map<
                  Eigen::PermutationMatrix<Eigen::Dynamic, Eigen::Dynamic, int>>
                  VAR_18(VAR_17 + VAR_14 * VAR_3,
                              VAR_3);
              auto VAR_19 = VAR_18.inverse();

              SparseMatrix VAR_20;
              VAR_20.template selfadjointView<Eigen::Upper>() =
                  VAR_15.template selfadjointView<Eigen::Upper>()
                      .twistedBy(VAR_19);

              /* COMMENT_15 */
              VAR_16.compute(VAR_20);
              if (VAR_16.info() != Eigen::Success) {
                VAR_11 = VAR_14;
                return;
              }

              /* COMMENT_16 */
              /* COMMENT_17 */
              /* COMMENT_18 */
              VAR_21[VAR_14] =
                  std::move(VAR_16.matrixU());
              /* COMMENT_19 */
              /* COMMENT_20 */
              VAR_7(VAR_14 + 1) =
                  VAR_21[VAR_14].nonZeros();
            }
          });

    /* COMMENT_21 */
    OP_REQUIRES(
        VAR_0, VAR_11 == -1,
        errors::InvalidArgument(
            ""Sparse Cholesky factorization failed for batch index "",
            VAR_11.load(), "". The input might not be valid.""));

    /* COMMENT_22 */
    std::partial_sum(VAR_7.data(),
                     VAR_7.data() + batch_size + 1,
                     VAR_7.data());

    /* COMMENT_23 */
    const int64 VAR_22 = VAR_7(batch_size);
    Tensor VAR_23(cpu_allocator(), VAR_6,
                          TensorShape({(VAR_3 + 1) * batch_size}));
    Tensor VAR_24(cpu_allocator(), VAR_6, TensorShape({VAR_22}));
    Tensor VAR_25(cpu_allocator(), DataTypeToEnum<T>::value,
                         TensorShape({VAR_22}));
    auto VAR_26 = VAR_23.flat<int32>().data();
    auto VAR_27 = VAR_24.flat<int32>().data();
    auto VAR_28 = VAR_25.flat<T>().data();

    /* COMMENT_24 */
    /* COMMENT_25 */
    /* COMMENT_26 */
    /* COMMENT_27 */
    /* COMMENT_28 */
    Shard(VAR_10.num_threads, VAR_10.workers, batch_size,
          (3 * VAR_22) / batch_size /* COMMENT_29 */,
          [&](int64 VAR_12, int64 VAR_13) {
            for (int64 VAR_14 = VAR_12; VAR_14 < VAR_13;
                 ++VAR_14) {
              const SparseMatrix& VAR_29 =
                  VAR_21[VAR_14];
              const int64 VAR_30 = VAR_29.nonZeros();

              std::copy(VAR_29.outerIndexPtr(),
                        VAR_29.outerIndexPtr() + VAR_3 + 1,
                        VAR_26 + VAR_14 * (VAR_3 + 1));
              std::copy(VAR_29.innerIndexPtr(),
                        VAR_29.innerIndexPtr() + VAR_30,
                        VAR_27 + VAR_7(VAR_14));
              std::copy(VAR_29.valuePtr(),
                        VAR_29.valuePtr() + VAR_30,
                        VAR_28 + VAR_7(VAR_14));
            }
          });

    /* COMMENT_30 */
    /* COMMENT_31 */
    CSRSparseMatrix VAR_31;
    OP_REQUIRES_OK(
        VAR_0,
        CSRSparseMatrix::CreateCSRSparseMatrix(
            DataTypeToEnum<T>::value, VAR_1->dense_shape(), VAR_5,
            VAR_23, VAR_24, VAR_25, &VAR_31));
    Tensor* VAR_32;
    AllocatorAttributes VAR_33;
    VAR_33.set_on_host(true);
    OP_REQUIRES_OK(
        VAR_0, VAR_0->allocate_output(0, TensorShape({}), &VAR_32,
                                  VAR_33));
    VAR_32->scalar<Variant>()() =
        std::move(VAR_31);
  }",,"--- func_before
+++ func_after
@@ -6,8 +6,8 @@
 
     int64 num_rows;
     int batch_size;
-    ValidateInputs(ctx, *input_matrix, input_permutation_indices, &batch_size,
-                   &num_rows);
+    OP_REQUIRES_OK(ctx, ValidateInputs(*input_matrix, input_permutation_indices,
+                                       &batch_size, &num_rows));
 
     // Allocate batch pointers.
     Tensor batch_ptr(cpu_allocator(), DT_INT32, TensorShape({batch_size + 1}));","{'deleted_lines': ['    ValidateInputs(ctx, *input_matrix, input_permutation_indices, &batch_size,', '                   &num_rows);'], 'added_lines': ['    OP_REQUIRES_OK(ctx, ValidateInputs(*input_matrix, input_permutation_indices,', '                                       &batch_size, &num_rows));']}",True,"TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference by providing an invalid `permutation` to `tf.raw_ops.SparseMatrixSparseCholesky`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/080f1d9e257589f78b3ffb75debf584168aa6062/tensorflow/core/kernels/sparse/sparse_cholesky_op.cc#L85-L86) fails to properly validate the input arguments. Although `ValidateInputs` is called and there are checks in the body of this function, the code proceeds to the next line in `ValidateInputs` since `OP_REQUIRES`(https://github.com/tensorflow/tensorflow/blob/080f1d9e257589f78b3ffb75debf584168aa6062/tensorflow/core/framework/op_requires.h#L41-L48) is a macro that only exits the current function. Thus, the first validation condition that fails in `ValidateInputs` will cause an early return from that function. However, the caller will continue execution from the next line. The fix is to either explicitly check `context->status()` or to convert `ValidateInputs` to return a `Status`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",2.5,LOW,0,valid,2021-04-20T21:45:33Z,3
CVE-2021-29536,['CWE-787'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"Validate arguments to `QuantizedReshape`.

Ensure that validations from `Reshape` also terminate `QuantizedReshape` on failure.

PiperOrigin-RevId: 369775421
Change-Id: If8c5342267aceea65b7cb83a4b183304886f1ce8",a324ac84e573fba362a5e53d4e74d5de6729933e,https://github.com/tensorflow/tensorflow/commit/a324ac84e573fba362a5e53d4e74d5de6729933e,tensorflow/core/kernels/quantized_reshape_op.cc,Compute,"void Compute(OpKernelContext* ctx) override {
ReshapeOp::Compute(ctx);
const float input_min_float = ctx->input(2).flat<float>()(0);
const float input_max_float = ctx->input(3).flat<float>()(0);
Tensor* output_min = nullptr;
OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));
output_min->flat<float>()(0) = input_min_float;
Tensor* output_max = nullptr;
OP_REQUIRES_OK(ctx, ctx->allocate_output(2, TensorShape({}), &output_max));
output_max->flat<float>()(0) = input_max_float;
}","void Compute(OpKernelContext* VAR_0) override {
ReshapeOp::Compute(VAR_0);
const float VAR_1 = VAR_0->input(2).flat<float>()(0);
const float VAR_2 = VAR_0->input(3).flat<float>()(0);
Tensor* VAR_3 = nullptr;
OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(1, TensorShape({}), &VAR_3));
VAR_3->flat<float>()(0) = VAR_1;
Tensor* VAR_4 = nullptr;
OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(2, TensorShape({}), &VAR_4));
VAR_4->flat<float>()(0) = VAR_2;
}",,"void Compute(OpKernelContext* ctx) override {
    // This call processes inputs 1 and 2 to write output 0.
    ReshapeOp::Compute(ctx);
    if (!ctx->status().ok()) {
      return;
    }

    const auto& input_min_float_tensor = ctx->input(2);
    const auto& input_min_float_shape = input_min_float_tensor.shape();
    OP_REQUIRES(ctx,
                TensorShapeUtils::IsScalar(input_min_float_shape) ||
                    (TensorShapeUtils::IsVector(input_min_float_shape) &&
                     (input_min_float_shape.dim_size(0) == 1)),
                errors::InvalidArgument(
                    ""input_min must be a scalar or a vector of 1 element""));
    const float input_min_float = input_min_float_tensor.flat<float>()(0);
    const auto& input_max_float_tensor = ctx->input(3);
    const auto& input_max_float_shape = input_max_float_tensor.shape();
    OP_REQUIRES(ctx,
                TensorShapeUtils::IsScalar(input_max_float_shape) ||
                    (TensorShapeUtils::IsVector(input_max_float_shape) &&
                     (input_max_float_shape.dim_size(0) == 1)),
                errors::InvalidArgument(
                    ""input_max must be a scalar or a vector of 1 element""));
    const float input_max_float = input_max_float_tensor.flat<float>()(0);

    Tensor* output_min = nullptr;
    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));
    output_min->flat<float>()(0) = input_min_float;

    Tensor* output_max = nullptr;
    OP_REQUIRES_OK(ctx, ctx->allocate_output(2, TensorShape({}), &output_max));
    output_max->flat<float>()(0) = input_max_float;
  }","void Compute(OpKernelContext* VAR_0) override {
    /* COMMENT_0 */
    ReshapeOp::Compute(VAR_0);
    if (!VAR_0->status().ok()) {
      return;
    }

    const auto& VAR_1 = VAR_0->input(2);
    const auto& VAR_2 = VAR_1.shape();
    OP_REQUIRES(VAR_0,
                TensorShapeUtils::IsScalar(VAR_2) ||
                    (TensorShapeUtils::IsVector(VAR_2) &&
                     (VAR_2.dim_size(0) == 1)),
                errors::InvalidArgument(
                    ""input_min must be a scalar or a vector of 1 element""));
    const float VAR_3 = VAR_1.flat<float>()(0);
    const auto& VAR_4 = VAR_0->input(3);
    const auto& VAR_5 = VAR_4.shape();
    OP_REQUIRES(VAR_0,
                TensorShapeUtils::IsScalar(VAR_5) ||
                    (TensorShapeUtils::IsVector(VAR_5) &&
                     (VAR_5.dim_size(0) == 1)),
                errors::InvalidArgument(
                    ""input_max must be a scalar or a vector of 1 element""));
    const float VAR_6 = VAR_4.flat<float>()(0);

    Tensor* VAR_7 = nullptr;
    OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(1, TensorShape({}), &VAR_7));
    VAR_7->flat<float>()(0) = VAR_3;

    Tensor* VAR_8 = nullptr;
    OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(2, TensorShape({}), &VAR_8));
    VAR_8->flat<float>()(0) = VAR_6;
  }",,"--- func_before
+++ func_after
@@ -1,9 +1,29 @@
 void Compute(OpKernelContext* ctx) override {
     // This call processes inputs 1 and 2 to write output 0.
     ReshapeOp::Compute(ctx);
+    if (!ctx->status().ok()) {
+      return;
+    }
 
-    const float input_min_float = ctx->input(2).flat<float>()(0);
-    const float input_max_float = ctx->input(3).flat<float>()(0);
+    const auto& input_min_float_tensor = ctx->input(2);
+    const auto& input_min_float_shape = input_min_float_tensor.shape();
+    OP_REQUIRES(ctx,
+                TensorShapeUtils::IsScalar(input_min_float_shape) ||
+                    (TensorShapeUtils::IsVector(input_min_float_shape) &&
+                     (input_min_float_shape.dim_size(0) == 1)),
+                errors::InvalidArgument(
+                    ""input_min must be a scalar or a vector of 1 element""));
+    const float input_min_float = input_min_float_tensor.flat<float>()(0);
+    const auto& input_max_float_tensor = ctx->input(3);
+    const auto& input_max_float_shape = input_max_float_tensor.shape();
+    OP_REQUIRES(ctx,
+                TensorShapeUtils::IsScalar(input_max_float_shape) ||
+                    (TensorShapeUtils::IsVector(input_max_float_shape) &&
+                     (input_max_float_shape.dim_size(0) == 1)),
+                errors::InvalidArgument(
+                    ""input_max must be a scalar or a vector of 1 element""));
+    const float input_max_float = input_max_float_tensor.flat<float>()(0);
+
     Tensor* output_min = nullptr;
     OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));
     output_min->flat<float>()(0) = input_min_float;","{'deleted_lines': ['    const float input_min_float = ctx->input(2).flat<float>()(0);', '    const float input_max_float = ctx->input(3).flat<float>()(0);'], 'added_lines': ['    if (!ctx->status().ok()) {', '      return;', '    }', '    const auto& input_min_float_tensor = ctx->input(2);', '    const auto& input_min_float_shape = input_min_float_tensor.shape();', '    OP_REQUIRES(ctx,', '                TensorShapeUtils::IsScalar(input_min_float_shape) ||', '                    (TensorShapeUtils::IsVector(input_min_float_shape) &&', '                     (input_min_float_shape.dim_size(0) == 1)),', '                errors::InvalidArgument(', '                    ""input_min must be a scalar or a vector of 1 element""));', '    const float input_min_float = input_min_float_tensor.flat<float>()(0);', '    const auto& input_max_float_tensor = ctx->input(3);', '    const auto& input_max_float_shape = input_max_float_tensor.shape();', '    OP_REQUIRES(ctx,', '                TensorShapeUtils::IsScalar(input_max_float_shape) ||', '                    (TensorShapeUtils::IsVector(input_max_float_shape) &&', '                     (input_max_float_shape.dim_size(0) == 1)),', '                errors::InvalidArgument(', '                    ""input_max must be a scalar or a vector of 1 element""));', '    const float input_max_float = input_max_float_tensor.flat<float>()(0);', '']}",True,"TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedReshape` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a324ac84e573fba362a5e53d4e74d5de6729933e/tensorflow/core/kernels/quantized_reshape_op.cc#L38-L55) assumes that the 2 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat<T>()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",2.5,LOW,0,valid,2021-04-22T01:11:15Z,3
CVE-2021-31294,['CWE-617'],CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H,1,redis,"Prevent replicas from sending commands that interact with keyspace (#8868)

This solves an issue reported in #8712 in which a replica would bypass
the client write pause check and cause an assertion due to executing a
write command during failover.

The fact is that we don't expect replicas to execute any command other
than maybe REPLCONF and PING, etc. but matching against the ADMIN
command flag is insufficient, so instead i just block keyspace access
for now.

(cherry picked from commit 46f4ebbe842620f0976a36741a72482620aa4b48)",6cbea7d29b5285692843bc1c351abba1a7ef326f,https://github.com/redis/redis/commit/6cbea7d29b5285692843bc1c351abba1a7ef326f,src/server.c,processCommand,"int processCommand(client *c) {
if (!server.lua_timedout) {
serverAssert(!server.propagate_in_transaction);
serverAssert(!server.in_exec);
serverAssert(!server.in_eval);
}
moduleCallCommandFilters(c);
if (!strcasecmp(c->argv[0]->ptr,""quit"")) {
addReply(c,shared.ok);
c->flags |= CLIENT_CLOSE_AFTER_REPLY;
return C_ERR;
}
c->cmd = c->lastcmd = lookupCommand(c->argv[0]->ptr);
if (!c->cmd) {
sds args = sdsempty();
int i;
for (i=1; i < c->argc && sdslen(args) < 128; i++)
args = sdscatprintf(args, ""`%.*s`, "", 128-(int)sdslen(args), (char*)c->argv[i]->ptr);
rejectCommandFormat(c,""unknown command `%s`, with args beginning with: %s"",
(char*)c->argv[0]->ptr, args);
sdsfree(args);
return C_OK;
} else if ((c->cmd->arity > 0 && c->cmd->arity != c->argc) ||
(c->argc < -c->cmd->arity)) {
rejectCommandFormat(c,""wrong number of arguments for '%s' command"",
c->cmd->name);
return C_OK;
}
int is_write_command = (c->cmd->flags & CMD_WRITE) ||
(c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_WRITE));
int is_denyoom_command = (c->cmd->flags & CMD_DENYOOM) ||
(c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_DENYOOM));
int is_denystale_command = !(c->cmd->flags & CMD_STALE) ||
(c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_STALE));
int is_denyloading_command = !(c->cmd->flags & CMD_LOADING) ||
(c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_LOADING));
int is_may_replicate_command = (c->cmd->flags & (CMD_WRITE | CMD_MAY_REPLICATE)) ||
(c->cmd->proc == execCommand && (c->mstate.cmd_flags & (CMD_WRITE | CMD_MAY_REPLICATE)));
int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||
(DefaultUser->flags & USER_FLAG_DISABLED)) &&
!c->authenticated;
if (auth_required) {
if (!(c->cmd->flags & CMD_NO_AUTH)) {
rejectCommand(c,shared.noautherr);
return C_OK;
}
}
int acl_errpos;
int acl_retval = ACLCheckAllPerm(c,&acl_errpos);
if (acl_retval != ACL_OK) {
addACLLogEntry(c,acl_retval,acl_errpos,NULL);
switch (acl_retval) {
case ACL_DENIED_CMD:
rejectCommandFormat(c,
""-NOPERM this user has no permissions to run ""
""the '%s' command or its subcommand"", c->cmd->name);
break;
case ACL_DENIED_KEY:
rejectCommandFormat(c,
""-NOPERM this user has no permissions to access ""
""one of the keys used as arguments"");
break;
case ACL_DENIED_CHANNEL:
rejectCommandFormat(c,
""-NOPERM this user has no permissions to access ""
""one of the channels used as arguments"");
break;
default:
rejectCommandFormat(c, ""no permission"");
break;
}
return C_OK;
}
if (server.cluster_enabled &&
!(c->flags & CLIENT_MASTER) &&
!(c->flags & CLIENT_LUA &&
server.lua_caller->flags & CLIENT_MASTER) &&
!(!cmdHasMovableKeys(c->cmd) && c->cmd->firstkey == 0 &&
c->cmd->proc != execCommand))
{
int hashslot;
int error_code;
clusterNode *n = getNodeByQuery(c,c->cmd,c->argv,c->argc,
&hashslot,&error_code);
if (n == NULL || n != server.cluster->myself) {
if (c->cmd->proc == execCommand) {
discardTransaction(c);
} else {
flagTransaction(c);
}
clusterRedirectClient(c,n,hashslot,error_code);
c->cmd->rejected_calls++;
return C_OK;
}
}
if (server.maxmemory && !server.lua_timedout) {
int out_of_memory = (performEvictions() == EVICT_FAIL);
if (server.current_client == NULL) return C_ERR;
int reject_cmd_on_oom = is_denyoom_command;
if (c->flags & CLIENT_MULTI &&
c->cmd->proc != execCommand &&
c->cmd->proc != discardCommand &&
c->cmd->proc != resetCommand) {
reject_cmd_on_oom = 1;
}
if (out_of_memory && reject_cmd_on_oom) {
rejectCommand(c, shared.oomerr);
return C_OK;
}
if (c->cmd->proc == evalCommand || c->cmd->proc == evalShaCommand) {
server.lua_oom = out_of_memory;
}
}
if (server.tracking_clients) trackingLimitUsedSlots();
int deny_write_type = writeCommandsDeniedByDiskError();
if (deny_write_type != DISK_ERROR_TYPE_NONE &&
server.masterhost == NULL &&
(is_write_command ||c->cmd->proc == pingCommand))
{
if (deny_write_type == DISK_ERROR_TYPE_RDB)
rejectCommand(c, shared.bgsaveerr);
else
rejectCommandFormat(c,
""-MISCONF Errors writing to the AOF file: %s"",
strerror(server.aof_last_write_errno));
return C_OK;
}
if (server.masterhost == NULL &&
server.repl_min_slaves_to_write &&
server.repl_min_slaves_max_lag &&
is_write_command &&
server.repl_good_slaves_count < server.repl_min_slaves_to_write)
{
rejectCommand(c, shared.noreplicaserr);
return C_OK;
}
if (server.masterhost && server.repl_slave_ro &&
!(c->flags & CLIENT_MASTER) &&
is_write_command)
{
rejectCommand(c, shared.roslaveerr);
return C_OK;
}
if ((c->flags & CLIENT_PUBSUB && c->resp == 2) &&
c->cmd->proc != pingCommand &&
c->cmd->proc != subscribeCommand &&
c->cmd->proc != unsubscribeCommand &&
c->cmd->proc != psubscribeCommand &&
c->cmd->proc != punsubscribeCommand &&
c->cmd->proc != resetCommand) {
rejectCommandFormat(c,
""Can't execute '%s': only (P)SUBSCRIBE / ""
""(P)UNSUBSCRIBE / PING / QUIT / RESET are allowed in this context"",
c->cmd->name);
return C_OK;
}
if (server.masterhost && server.repl_state != REPL_STATE_CONNECTED &&
server.repl_serve_stale_data == 0 &&
is_denystale_command)
{
rejectCommand(c, shared.masterdownerr);
return C_OK;
}
if (server.loading && is_denyloading_command) {
rejectCommand(c, shared.loadingerr);
return C_OK;
}
if (server.lua_timedout &&
c->cmd->proc != authCommand &&
c->cmd->proc != helloCommand &&
c->cmd->proc != replconfCommand &&
c->cmd->proc != multiCommand &&
c->cmd->proc != discardCommand &&
c->cmd->proc != watchCommand &&
c->cmd->proc != unwatchCommand &&
c->cmd->proc != resetCommand &&
!(c->cmd->proc == shutdownCommand &&
c->argc == 2 &&
tolower(((char*)c->argv[1]->ptr)[0]) == 'n') &&
!(c->cmd->proc == scriptCommand &&
c->argc == 2 &&
tolower(((char*)c->argv[1]->ptr)[0]) == 'k'))
{
rejectCommand(c, shared.slowscripterr);
return C_OK;
}
if (!(c->flags & CLIENT_SLAVE) && 
((server.client_pause_type == CLIENT_PAUSE_ALL) ||
(server.client_pause_type == CLIENT_PAUSE_WRITE && is_may_replicate_command)))
{
c->bpop.timeout = 0;
blockClient(c,BLOCKED_PAUSE);
return C_OK;       
}
if (c->flags & CLIENT_MULTI &&
c->cmd->proc != execCommand && c->cmd->proc != discardCommand &&
c->cmd->proc != multiCommand && c->cmd->proc != watchCommand &&
c->cmd->proc != resetCommand)
{
queueMultiCommand(c);
addReply(c,shared.queued);
} else {
call(c,CMD_CALL_FULL);
c->woff = server.master_repl_offset;
if (listLength(server.ready_keys))
handleClientsBlockedOnKeys();
}
return C_OK;
}","int processCommand(client *VAR_0) {
if (!VAR_1.lua_timedout) {
serverAssert(!VAR_1.propagate_in_transaction);
serverAssert(!VAR_1.in_exec);
serverAssert(!VAR_1.in_eval);
}
moduleCallCommandFilters(VAR_0);
if (!strcasecmp(VAR_0->argv[0]->ptr,""quit"")) {
addReply(VAR_0,VAR_2.ok);
VAR_0->flags |= VAR_3;
return VAR_4;
}
VAR_0->cmd = VAR_0->lastcmd = lookupCommand(VAR_0->argv[0]->ptr);
if (!VAR_0->cmd) {
sds VAR_5 = sdsempty();
int VAR_6;
for (VAR_6=1; VAR_6 < VAR_0->argc && sdslen(VAR_5) < 128; VAR_6++)
VAR_5 = sdscatprintf(VAR_5, ""`%.*s`, "", 128-(int)sdslen(VAR_5), (char*)VAR_0->argv[VAR_6]->ptr);
rejectCommandFormat(VAR_0,""unknown command `%s`, with args beginning with: %s"",
(char*)VAR_0->argv[0]->ptr, VAR_5);
sdsfree(VAR_5);
return VAR_7;
} else if ((VAR_0->cmd->arity > 0 && VAR_0->cmd->arity != VAR_0->argc) ||
(VAR_0->argc < -VAR_0->cmd->arity)) {
rejectCommandFormat(VAR_0,""wrong number of arguments for '%s' command"",
VAR_0->cmd->name);
return VAR_7;
}
int VAR_8 = (VAR_0->cmd->flags & VAR_9) ||
(VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_flags & VAR_9));
int VAR_11 = (VAR_0->cmd->flags & VAR_12) ||
(VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_flags & VAR_12));
int VAR_13 = !(VAR_0->cmd->flags & VAR_14) ||
(VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_inv_flags & VAR_14));
int VAR_15 = !(VAR_0->cmd->flags & VAR_16) ||
(VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_inv_flags & VAR_16));
int VAR_17 = (VAR_0->cmd->flags & (VAR_9 | VAR_18)) ||
(VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_flags & (VAR_9 | VAR_18)));
int VAR_19 = (!(VAR_20->flags & VAR_21) ||
(VAR_20->flags & VAR_22)) &&
!VAR_0->authenticated;
if (VAR_19) {
if (!(VAR_0->cmd->flags & VAR_23)) {
rejectCommand(VAR_0,VAR_2.noautherr);
return VAR_7;
}
}
int VAR_24;
int VAR_25 = ACLCheckAllPerm(VAR_0,&VAR_24);
if (VAR_25 != VAR_26) {
addACLLogEntry(VAR_0,VAR_25,VAR_24,NULL);
switch (VAR_25) {
case VAR_27:
rejectCommandFormat(VAR_0,
""-NOPERM this user has no permissions to run ""
""the '%s' command or its subcommand"", VAR_0->cmd->name);
break;
case VAR_28:
rejectCommandFormat(VAR_0,
""-NOPERM this user has no permissions to access ""
""one of the keys used as arguments"");
break;
case VAR_29:
rejectCommandFormat(VAR_0,
""-NOPERM this user has no permissions to access ""
""one of the channels used as arguments"");
break;
default:
rejectCommandFormat(VAR_0, ""no permission"");
break;
}
return VAR_7;
}
if (VAR_1.cluster_enabled &&
!(VAR_0->flags & VAR_30) &&
!(VAR_0->flags & VAR_31 &&
VAR_1.lua_caller->flags & VAR_30) &&
!(!cmdHasMovableKeys(VAR_0->cmd) && VAR_0->cmd->firstkey == 0 &&
VAR_0->cmd->proc != VAR_10))
{
int VAR_32;
int VAR_33;
clusterNode *VAR_34 = getNodeByQuery(VAR_0,VAR_0->cmd,VAR_0->argv,VAR_0->argc,
&VAR_32,&VAR_33);
if (VAR_34 == NULL || VAR_34 != VAR_1.cluster->myself) {
if (VAR_0->cmd->proc == VAR_10) {
discardTransaction(VAR_0);
} else {
flagTransaction(VAR_0);
}
clusterRedirectClient(VAR_0,VAR_34,VAR_32,VAR_33);
VAR_0->cmd->rejected_calls++;
return VAR_7;
}
}
if (VAR_1.maxmemory && !VAR_1.lua_timedout) {
int VAR_35 = (performEvictions() == VAR_36);
if (VAR_1.current_client == NULL) return VAR_4;
int VAR_37 = VAR_11;
if (VAR_0->flags & VAR_38 &&
VAR_0->cmd->proc != VAR_10 &&
VAR_0->cmd->proc != VAR_39 &&
VAR_0->cmd->proc != VAR_40) {
VAR_37 = 1;
}
if (VAR_35 && VAR_37) {
rejectCommand(VAR_0, VAR_2.oomerr);
return VAR_7;
}
if (VAR_0->cmd->proc == VAR_41 || VAR_0->cmd->proc == VAR_42) {
VAR_1.lua_oom = VAR_35;
}
}
if (VAR_1.tracking_clients) trackingLimitUsedSlots();
int VAR_43 = writeCommandsDeniedByDiskError();
if (VAR_43 != VAR_44 &&
VAR_1.masterhost == NULL &&
(VAR_8 ||VAR_0->cmd->proc == VAR_45))
{
if (VAR_43 == VAR_46)
rejectCommand(VAR_0, VAR_2.bgsaveerr);
else
rejectCommandFormat(VAR_0,
""-MISCONF Errors writing to the AOF file: %s"",
strerror(VAR_1.aof_last_write_errno));
return VAR_7;
}
if (VAR_1.masterhost == NULL &&
VAR_1.repl_min_slaves_to_write &&
VAR_1.repl_min_slaves_max_lag &&
VAR_8 &&
VAR_1.repl_good_slaves_count < VAR_1.repl_min_slaves_to_write)
{
rejectCommand(VAR_0, VAR_2.noreplicaserr);
return VAR_7;
}
if (VAR_1.masterhost && VAR_1.repl_slave_ro &&
!(VAR_0->flags & VAR_30) &&
VAR_8)
{
rejectCommand(VAR_0, VAR_2.roslaveerr);
return VAR_7;
}
if ((VAR_0->flags & VAR_47 && VAR_0->resp == 2) &&
VAR_0->cmd->proc != VAR_45 &&
VAR_0->cmd->proc != VAR_48 &&
VAR_0->cmd->proc != VAR_49 &&
VAR_0->cmd->proc != VAR_50 &&
VAR_0->cmd->proc != VAR_51 &&
VAR_0->cmd->proc != VAR_40) {
rejectCommandFormat(VAR_0,
""Can't execute '%s': only (P)SUBSCRIBE / ""
""(P)UNSUBSCRIBE / PING / QUIT / RESET are allowed in this context"",
VAR_0->cmd->name);
return VAR_7;
}
if (VAR_1.masterhost && VAR_1.repl_state != VAR_52 &&
VAR_1.repl_serve_stale_data == 0 &&
VAR_13)
{
rejectCommand(VAR_0, VAR_2.masterdownerr);
return VAR_7;
}
if (VAR_1.loading && VAR_15) {
rejectCommand(VAR_0, VAR_2.loadingerr);
return VAR_7;
}
if (VAR_1.lua_timedout &&
VAR_0->cmd->proc != VAR_53 &&
VAR_0->cmd->proc != VAR_54 &&
VAR_0->cmd->proc != VAR_55 &&
VAR_0->cmd->proc != VAR_56 &&
VAR_0->cmd->proc != VAR_39 &&
VAR_0->cmd->proc != VAR_57 &&
VAR_0->cmd->proc != VAR_58 &&
VAR_0->cmd->proc != VAR_40 &&
!(VAR_0->cmd->proc == VAR_59 &&
VAR_0->argc == 2 &&
tolower(((char*)VAR_0->argv[1]->ptr)[0]) == 'n') &&
!(VAR_0->cmd->proc == VAR_60 &&
VAR_0->argc == 2 &&
tolower(((char*)VAR_0->argv[1]->ptr)[0]) == 'k'))
{
rejectCommand(VAR_0, VAR_2.slowscripterr);
return VAR_7;
}
if (!(VAR_0->flags & VAR_61) && 
((VAR_1.client_pause_type == VAR_62) ||
(VAR_1.client_pause_type == VAR_63 && VAR_17)))
{
VAR_0->bpop.timeout = 0;
blockClient(VAR_0,VAR_64);
return VAR_7;       
}
if (VAR_0->flags & VAR_38 &&
VAR_0->cmd->proc != VAR_10 && VAR_0->cmd->proc != VAR_39 &&
VAR_0->cmd->proc != VAR_56 && VAR_0->cmd->proc != VAR_57 &&
VAR_0->cmd->proc != VAR_40)
{
queueMultiCommand(VAR_0);
addReply(VAR_0,VAR_2.queued);
} else {
call(VAR_0,VAR_65);
VAR_0->woff = VAR_1.master_repl_offset;
if (listLength(VAR_1.ready_keys))
handleClientsBlockedOnKeys();
}
return VAR_7;
}",redis/6cbea7d29b5285692843bc1c351abba1a7ef326f/server.c/vul/before/0.json,"int processCommand(client *c) {
    if (!server.lua_timedout) {
        /* Both EXEC and EVAL call call() directly so there should be
         * no way in_exec or in_eval or propagate_in_transaction is 1.
         * That is unless lua_timedout, in which case client may run
         * some commands. */
        serverAssert(!server.propagate_in_transaction);
        serverAssert(!server.in_exec);
        serverAssert(!server.in_eval);
    }

    moduleCallCommandFilters(c);

    /* The QUIT command is handled separately. Normal command procs will
     * go through checking for replication and QUIT will cause trouble
     * when FORCE_REPLICATION is enabled and would be implemented in
     * a regular command proc. */
    if (!strcasecmp(c->argv[0]->ptr,""quit"")) {
        addReply(c,shared.ok);
        c->flags |= CLIENT_CLOSE_AFTER_REPLY;
        return C_ERR;
    }

    /* Now lookup the command and check ASAP about trivial error conditions
     * such as wrong arity, bad command name and so forth. */
    c->cmd = c->lastcmd = lookupCommand(c->argv[0]->ptr);
    if (!c->cmd) {
        sds args = sdsempty();
        int i;
        for (i=1; i < c->argc && sdslen(args) < 128; i++)
            args = sdscatprintf(args, ""`%.*s`, "", 128-(int)sdslen(args), (char*)c->argv[i]->ptr);
        rejectCommandFormat(c,""unknown command `%s`, with args beginning with: %s"",
            (char*)c->argv[0]->ptr, args);
        sdsfree(args);
        return C_OK;
    } else if ((c->cmd->arity > 0 && c->cmd->arity != c->argc) ||
               (c->argc < -c->cmd->arity)) {
        rejectCommandFormat(c,""wrong number of arguments for '%s' command"",
            c->cmd->name);
        return C_OK;
    }

    int is_read_command = (c->cmd->flags & CMD_READONLY) ||
                           (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_READONLY));
    int is_write_command = (c->cmd->flags & CMD_WRITE) ||
                           (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_WRITE));
    int is_denyoom_command = (c->cmd->flags & CMD_DENYOOM) ||
                             (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_DENYOOM));
    int is_denystale_command = !(c->cmd->flags & CMD_STALE) ||
                               (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_STALE));
    int is_denyloading_command = !(c->cmd->flags & CMD_LOADING) ||
                                 (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_LOADING));
    int is_may_replicate_command = (c->cmd->flags & (CMD_WRITE | CMD_MAY_REPLICATE)) ||
                                   (c->cmd->proc == execCommand && (c->mstate.cmd_flags & (CMD_WRITE | CMD_MAY_REPLICATE)));

    /* Check if the user is authenticated. This check is skipped in case
     * the default user is flagged as ""nopass"" and is active. */
    int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||
                          (DefaultUser->flags & USER_FLAG_DISABLED)) &&
                        !c->authenticated;
    if (auth_required) {
        /* AUTH and HELLO and no auth modules are valid even in
         * non-authenticated state. */
        if (!(c->cmd->flags & CMD_NO_AUTH)) {
            rejectCommand(c,shared.noautherr);
            return C_OK;
        }
    }

    /* Check if the user can run this command according to the current
     * ACLs. */
    int acl_errpos;
    int acl_retval = ACLCheckAllPerm(c,&acl_errpos);
    if (acl_retval != ACL_OK) {
        addACLLogEntry(c,acl_retval,acl_errpos,NULL);
        switch (acl_retval) {
        case ACL_DENIED_CMD:
            rejectCommandFormat(c,
                ""-NOPERM this user has no permissions to run ""
                ""the '%s' command or its subcommand"", c->cmd->name);
            break;
        case ACL_DENIED_KEY:
            rejectCommandFormat(c,
                ""-NOPERM this user has no permissions to access ""
                ""one of the keys used as arguments"");
            break;
        case ACL_DENIED_CHANNEL:
            rejectCommandFormat(c,
                ""-NOPERM this user has no permissions to access ""
                ""one of the channels used as arguments"");
            break;
        default:
            rejectCommandFormat(c, ""no permission"");
            break;
        }
        return C_OK;
    }

    /* If cluster is enabled perform the cluster redirection here.
     * However we don't perform the redirection if:
     * 1) The sender of this command is our master.
     * 2) The command has no key arguments. */
    if (server.cluster_enabled &&
        !(c->flags & CLIENT_MASTER) &&
        !(c->flags & CLIENT_LUA &&
          server.lua_caller->flags & CLIENT_MASTER) &&
        !(!cmdHasMovableKeys(c->cmd) && c->cmd->firstkey == 0 &&
          c->cmd->proc != execCommand))
    {
        int hashslot;
        int error_code;
        clusterNode *n = getNodeByQuery(c,c->cmd,c->argv,c->argc,
                                        &hashslot,&error_code);
        if (n == NULL || n != server.cluster->myself) {
            if (c->cmd->proc == execCommand) {
                discardTransaction(c);
            } else {
                flagTransaction(c);
            }
            clusterRedirectClient(c,n,hashslot,error_code);
            c->cmd->rejected_calls++;
            return C_OK;
        }
    }

    /* Handle the maxmemory directive.
     *
     * Note that we do not want to reclaim memory if we are here re-entering
     * the event loop since there is a busy Lua script running in timeout
     * condition, to avoid mixing the propagation of scripts with the
     * propagation of DELs due to eviction. */
    if (server.maxmemory && !server.lua_timedout) {
        int out_of_memory = (performEvictions() == EVICT_FAIL);
        /* performEvictions may flush slave output buffers. This may result
         * in a slave, that may be the active client, to be freed. */
        if (server.current_client == NULL) return C_ERR;

        int reject_cmd_on_oom = is_denyoom_command;
        /* If client is in MULTI/EXEC context, queuing may consume an unlimited
         * amount of memory, so we want to stop that.
         * However, we never want to reject DISCARD, or even EXEC (unless it
         * contains denied commands, in which case is_denyoom_command is already
         * set. */
        if (c->flags & CLIENT_MULTI &&
            c->cmd->proc != execCommand &&
            c->cmd->proc != discardCommand &&
            c->cmd->proc != resetCommand) {
            reject_cmd_on_oom = 1;
        }

        if (out_of_memory && reject_cmd_on_oom) {
            rejectCommand(c, shared.oomerr);
            return C_OK;
        }

        /* Save out_of_memory result at script start, otherwise if we check OOM
         * until first write within script, memory used by lua stack and
         * arguments might interfere. */
        if (c->cmd->proc == evalCommand || c->cmd->proc == evalShaCommand) {
            server.lua_oom = out_of_memory;
        }
    }

    /* Make sure to use a reasonable amount of memory for client side
     * caching metadata. */
    if (server.tracking_clients) trackingLimitUsedSlots();

    /* Don't accept write commands if there are problems persisting on disk
     * and if this is a master instance. */
    int deny_write_type = writeCommandsDeniedByDiskError();
    if (deny_write_type != DISK_ERROR_TYPE_NONE &&
        server.masterhost == NULL &&
        (is_write_command ||c->cmd->proc == pingCommand))
    {
        if (deny_write_type == DISK_ERROR_TYPE_RDB)
            rejectCommand(c, shared.bgsaveerr);
        else
            rejectCommandFormat(c,
                ""-MISCONF Errors writing to the AOF file: %s"",
                strerror(server.aof_last_write_errno));
        return C_OK;
    }

    /* Don't accept write commands if there are not enough good slaves and
     * user configured the min-slaves-to-write option. */
    if (server.masterhost == NULL &&
        server.repl_min_slaves_to_write &&
        server.repl_min_slaves_max_lag &&
        is_write_command &&
        server.repl_good_slaves_count < server.repl_min_slaves_to_write)
    {
        rejectCommand(c, shared.noreplicaserr);
        return C_OK;
    }

    /* Don't accept write commands if this is a read only slave. But
     * accept write commands if this is our master. */
    if (server.masterhost && server.repl_slave_ro &&
        !(c->flags & CLIENT_MASTER) &&
        is_write_command)
    {
        rejectCommand(c, shared.roslaveerr);
        return C_OK;
    }

    /* Only allow a subset of commands in the context of Pub/Sub if the
     * connection is in RESP2 mode. With RESP3 there are no limits. */
    if ((c->flags & CLIENT_PUBSUB && c->resp == 2) &&
        c->cmd->proc != pingCommand &&
        c->cmd->proc != subscribeCommand &&
        c->cmd->proc != unsubscribeCommand &&
        c->cmd->proc != psubscribeCommand &&
        c->cmd->proc != punsubscribeCommand &&
        c->cmd->proc != resetCommand) {
        rejectCommandFormat(c,
            ""Can't execute '%s': only (P)SUBSCRIBE / ""
            ""(P)UNSUBSCRIBE / PING / QUIT / RESET are allowed in this context"",
            c->cmd->name);
        return C_OK;
    }

    /* Only allow commands with flag ""t"", such as INFO, SLAVEOF and so on,
     * when slave-serve-stale-data is no and we are a slave with a broken
     * link with master. */
    if (server.masterhost && server.repl_state != REPL_STATE_CONNECTED &&
        server.repl_serve_stale_data == 0 &&
        is_denystale_command)
    {
        rejectCommand(c, shared.masterdownerr);
        return C_OK;
    }

    /* Loading DB? Return an error if the command has not the
     * CMD_LOADING flag. */
    if (server.loading && is_denyloading_command) {
        rejectCommand(c, shared.loadingerr);
        return C_OK;
    }

    /* Lua script too slow? Only allow a limited number of commands.
     * Note that we need to allow the transactions commands, otherwise clients
     * sending a transaction with pipelining without error checking, may have
     * the MULTI plus a few initial commands refused, then the timeout
     * condition resolves, and the bottom-half of the transaction gets
     * executed, see Github PR #7022. */
    if (server.lua_timedout &&
          c->cmd->proc != authCommand &&
          c->cmd->proc != helloCommand &&
          c->cmd->proc != replconfCommand &&
          c->cmd->proc != multiCommand &&
          c->cmd->proc != discardCommand &&
          c->cmd->proc != watchCommand &&
          c->cmd->proc != unwatchCommand &&
          c->cmd->proc != resetCommand &&
        !(c->cmd->proc == shutdownCommand &&
          c->argc == 2 &&
          tolower(((char*)c->argv[1]->ptr)[0]) == 'n') &&
        !(c->cmd->proc == scriptCommand &&
          c->argc == 2 &&
          tolower(((char*)c->argv[1]->ptr)[0]) == 'k'))
    {
        rejectCommand(c, shared.slowscripterr);
        return C_OK;
    }

    /* Prevent a replica from sending commands that access the keyspace.
     * The main objective here is to prevent abuse of client pause check
     * from which replicas are exempt. */
    if ((c->flags & CLIENT_SLAVE) && (is_may_replicate_command || is_write_command || is_read_command)) {
        rejectCommandFormat(c, ""Replica can't interract with the keyspace"");
        return C_OK;
    }

    /* If the server is paused, block the client until
     * the pause has ended. Replicas are never paused. */
    if (!(c->flags & CLIENT_SLAVE) && 
        ((server.client_pause_type == CLIENT_PAUSE_ALL) ||
        (server.client_pause_type == CLIENT_PAUSE_WRITE && is_may_replicate_command)))
    {
        c->bpop.timeout = 0;
        blockClient(c,BLOCKED_PAUSE);
        return C_OK;       
    }

    /* Exec the command */
    if (c->flags & CLIENT_MULTI &&
        c->cmd->proc != execCommand && c->cmd->proc != discardCommand &&
        c->cmd->proc != multiCommand && c->cmd->proc != watchCommand &&
        c->cmd->proc != resetCommand)
    {
        queueMultiCommand(c);
        addReply(c,shared.queued);
    } else {
        call(c,CMD_CALL_FULL);
        c->woff = server.master_repl_offset;
        if (listLength(server.ready_keys))
            handleClientsBlockedOnKeys();
    }

    return C_OK;
}","int processCommand(client *VAR_0) {
    if (!VAR_1.lua_timedout) {
        /* COMMENT_0 */
                                                                      
                                                                    
                            
        serverAssert(!VAR_1.propagate_in_transaction);
        serverAssert(!VAR_1.in_exec);
        serverAssert(!VAR_1.in_eval);
    }

    moduleCallCommandFilters(VAR_0);

    /* COMMENT_4 */
                                                                      
                                                                    
                                 
    if (!strcasecmp(VAR_0->argv[0]->ptr,""quit"")) {
        addReply(VAR_0,VAR_2.ok);
        VAR_0->flags |= VAR_3;
        return VAR_4;
    }

    /* COMMENT_8 */
                                                             
    VAR_0->cmd = VAR_0->lastcmd = lookupCommand(VAR_0->argv[0]->ptr);
    if (!VAR_0->cmd) {
        sds VAR_5 = sdsempty();
        int VAR_6;
        for (VAR_6=1; VAR_6 < VAR_0->argc && sdslen(VAR_5) < 128; VAR_6++)
            VAR_5 = sdscatprintf(VAR_5, ""`%.*s`, "", 128-(int)sdslen(VAR_5), (char*)VAR_0->argv[VAR_6]->ptr);
        rejectCommandFormat(VAR_0,""unknown command `%s`, with args beginning with: %s"",
            (char*)VAR_0->argv[0]->ptr, VAR_5);
        sdsfree(VAR_5);
        return VAR_7;
    } else if ((VAR_0->cmd->arity > 0 && VAR_0->cmd->arity != VAR_0->argc) ||
               (VAR_0->argc < -VAR_0->cmd->arity)) {
        rejectCommandFormat(VAR_0,""wrong number of arguments for '%s' command"",
            VAR_0->cmd->name);
        return VAR_7;
    }

    int VAR_8 = (VAR_0->cmd->flags & VAR_9) ||
                           (VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_flags & VAR_9));
    int VAR_11 = (VAR_0->cmd->flags & VAR_12) ||
                           (VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_flags & VAR_12));
    int VAR_13 = (VAR_0->cmd->flags & VAR_14) ||
                             (VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_flags & VAR_14));
    int VAR_15 = !(VAR_0->cmd->flags & VAR_16) ||
                               (VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_inv_flags & VAR_16));
    int VAR_17 = !(VAR_0->cmd->flags & VAR_18) ||
                                 (VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_inv_flags & VAR_18));
    int VAR_19 = (VAR_0->cmd->flags & (VAR_12 | VAR_20)) ||
                                   (VAR_0->cmd->proc == VAR_10 && (VAR_0->mstate.cmd_flags & (VAR_12 | VAR_20)));

    /* COMMENT_10 */
                                                                
    int VAR_21 = (!(VAR_22->flags & VAR_23) ||
                          (VAR_22->flags & VAR_24)) &&
                        !VAR_0->authenticated;
    if (VAR_21) {
        /* COMMENT_12 */
                                      
        if (!(VAR_0->cmd->flags & VAR_25)) {
            rejectCommand(VAR_0,VAR_2.noautherr);
            return VAR_7;
        }
    }

    /* COMMENT_14 */
               
    int VAR_26;
    int VAR_27 = ACLCheckAllPerm(VAR_0,&VAR_26);
    if (VAR_27 != VAR_28) {
        addACLLogEntry(VAR_0,VAR_27,VAR_26,NULL);
        switch (VAR_27) {
        case VAR_29:
            rejectCommandFormat(VAR_0,
                ""-NOPERM this user has no permissions to run ""
                ""the '%s' command or its subcommand"", VAR_0->cmd->name);
            break;
        case VAR_30:
            rejectCommandFormat(VAR_0,
                ""-NOPERM this user has no permissions to access ""
                ""one of the keys used as arguments"");
            break;
        case VAR_31:
            rejectCommandFormat(VAR_0,
                ""-NOPERM this user has no permissions to access ""
                ""one of the channels used as arguments"");
            break;
        default:
            rejectCommandFormat(VAR_0, ""no permission"");
            break;
        }
        return VAR_7;
    }

    /* COMMENT_16 */
                                                   
                                                   
                                              
    if (VAR_1.cluster_enabled &&
        !(VAR_0->flags & VAR_32) &&
        !(VAR_0->flags & VAR_33 &&
          VAR_1.lua_caller->flags & VAR_32) &&
        !(!cmdHasMovableKeys(VAR_0->cmd) && VAR_0->cmd->firstkey == 0 &&
          VAR_0->cmd->proc != VAR_10))
    {
        int VAR_34;
        int VAR_35;
        clusterNode *VAR_36 = getNodeByQuery(VAR_0,VAR_0->cmd,VAR_0->argv,VAR_0->argc,
                                        &VAR_34,&VAR_35);
        if (VAR_36 == NULL || VAR_36 != VAR_1.cluster->myself) {
            if (VAR_0->cmd->proc == VAR_10) {
                discardTransaction(VAR_0);
            } else {
                flagTransaction(VAR_0);
            }
            clusterRedirectClient(VAR_0,VAR_36,VAR_34,VAR_35);
            VAR_0->cmd->rejected_calls++;
            return VAR_7;
        }
    }

    /* COMMENT_20 */
      
                                                                            
                                                                         
                                                                     
                                              
    if (VAR_1.maxmemory && !VAR_1.lua_timedout) {
        int VAR_37 = (performEvictions() == VAR_38);
        /* COMMENT_26 */
                                                                     
        if (VAR_1.current_client == NULL) return VAR_4;

        int VAR_39 = VAR_13;
        /* COMMENT_28 */
                                                     
                                                                            
                                                                                
                  
        if (VAR_0->flags & VAR_40 &&
            VAR_0->cmd->proc != VAR_10 &&
            VAR_0->cmd->proc != VAR_41 &&
            VAR_0->cmd->proc != VAR_42) {
            VAR_39 = 1;
        }

        if (VAR_37 && VAR_39) {
            rejectCommand(VAR_0, VAR_2.oomerr);
            return VAR_7;
        }

        /* COMMENT_33 */
                                                                        
                                        
        if (VAR_0->cmd->proc == VAR_43 || VAR_0->cmd->proc == VAR_44) {
            VAR_1.lua_oom = VAR_37;
        }
    }

    /* COMMENT_36 */
                           
    if (VAR_1.tracking_clients) trackingLimitUsedSlots();

    /* COMMENT_38 */
                                           
    int VAR_45 = writeCommandsDeniedByDiskError();
    if (VAR_45 != VAR_46 &&
        VAR_1.masterhost == NULL &&
        (VAR_11 ||VAR_0->cmd->proc == VAR_47))
    {
        if (VAR_45 == VAR_48)
            rejectCommand(VAR_0, VAR_2.bgsaveerr);
        else
            rejectCommandFormat(VAR_0,
                ""-MISCONF Errors writing to the AOF file: %s"",
                strerror(VAR_1.aof_last_write_errno));
        return VAR_7;
    }

    /* COMMENT_40 */
                                                         
    if (VAR_1.masterhost == NULL &&
        VAR_1.repl_min_slaves_to_write &&
        VAR_1.repl_min_slaves_max_lag &&
        VAR_11 &&
        VAR_1.repl_good_slaves_count < VAR_1.repl_min_slaves_to_write)
    {
        rejectCommand(VAR_0, VAR_2.noreplicaserr);
        return VAR_7;
    }

    /* COMMENT_42 */
                                                      
    if (VAR_1.masterhost && VAR_1.repl_slave_ro &&
        !(VAR_0->flags & VAR_32) &&
        VAR_11)
    {
        rejectCommand(VAR_0, VAR_2.roslaveerr);
        return VAR_7;
    }

    /* COMMENT_44 */
                                                                      
    if ((VAR_0->flags & VAR_49 && VAR_0->resp == 2) &&
        VAR_0->cmd->proc != VAR_47 &&
        VAR_0->cmd->proc != VAR_50 &&
        VAR_0->cmd->proc != VAR_51 &&
        VAR_0->cmd->proc != VAR_52 &&
        VAR_0->cmd->proc != VAR_53 &&
        VAR_0->cmd->proc != VAR_42) {
        rejectCommandFormat(VAR_0,
            ""Can't execute '%s': only (P)SUBSCRIBE / ""
            ""(P)UNSUBSCRIBE / PING / QUIT / RESET are allowed in this context"",
            VAR_0->cmd->name);
        return VAR_7;
    }

    /* COMMENT_46 */
                                                                         
                           
    if (VAR_1.masterhost && VAR_1.repl_state != VAR_54 &&
        VAR_1.repl_serve_stale_data == 0 &&
        VAR_15)
    {
        rejectCommand(VAR_0, VAR_2.masterdownerr);
        return VAR_7;
    }

    /* COMMENT_49 */
                           
    if (VAR_1.loading && VAR_17) {
        rejectCommand(VAR_0, VAR_2.loadingerr);
        return VAR_7;
    }

    /* COMMENT_51 */
                                                                              
                                                                             
                                                                      
                                                                      
                                        
    if (VAR_1.lua_timedout &&
          VAR_0->cmd->proc != VAR_55 &&
          VAR_0->cmd->proc != VAR_56 &&
          VAR_0->cmd->proc != VAR_57 &&
          VAR_0->cmd->proc != VAR_58 &&
          VAR_0->cmd->proc != VAR_41 &&
          VAR_0->cmd->proc != VAR_59 &&
          VAR_0->cmd->proc != VAR_60 &&
          VAR_0->cmd->proc != VAR_42 &&
        !(VAR_0->cmd->proc == VAR_61 &&
          VAR_0->argc == 2 &&
          tolower(((char*)VAR_0->argv[1]->ptr)[0]) == 'n') &&
        !(VAR_0->cmd->proc == VAR_62 &&
          VAR_0->argc == 2 &&
          tolower(((char*)VAR_0->argv[1]->ptr)[0]) == 'k'))
    {
        rejectCommand(VAR_0, VAR_2.slowscripterr);
        return VAR_7;
    }

    /* COMMENT_57 */
                                                                        
                                         
    if ((VAR_0->flags & VAR_63) && (VAR_19 || VAR_11 || VAR_8)) {
        rejectCommandFormat(VAR_0, ""Replica can't interract with the keyspace"");
        return VAR_7;
    }

    /* COMMENT_60 */
                                                         
    if (!(VAR_0->flags & VAR_63) && 
        ((VAR_1.client_pause_type == VAR_64) ||
        (VAR_1.client_pause_type == VAR_65 && VAR_19)))
    {
        VAR_0->bpop.timeout = 0;
        blockClient(VAR_0,VAR_66);
        return VAR_7;       
    }

    /* COMMENT_62 */
    if (VAR_0->flags & VAR_40 &&
        VAR_0->cmd->proc != VAR_10 && VAR_0->cmd->proc != VAR_41 &&
        VAR_0->cmd->proc != VAR_58 && VAR_0->cmd->proc != VAR_59 &&
        VAR_0->cmd->proc != VAR_42)
    {
        queueMultiCommand(VAR_0);
        addReply(VAR_0,VAR_2.queued);
    } else {
        call(VAR_0,VAR_67);
        VAR_0->woff = VAR_1.master_repl_offset;
        if (listLength(VAR_1.ready_keys))
            handleClientsBlockedOnKeys();
    }

    return VAR_7;
}",redis/6cbea7d29b5285692843bc1c351abba1a7ef326f/server.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -40,6 +40,8 @@
         return C_OK;
     }
 
+    int is_read_command = (c->cmd->flags & CMD_READONLY) ||
+                           (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_READONLY));
     int is_write_command = (c->cmd->flags & CMD_WRITE) ||
                            (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_WRITE));
     int is_denyoom_command = (c->cmd->flags & CMD_DENYOOM) ||
@@ -249,7 +251,7 @@
           c->cmd->proc != discardCommand &&
           c->cmd->proc != watchCommand &&
           c->cmd->proc != unwatchCommand &&
-	  c->cmd->proc != resetCommand &&
+          c->cmd->proc != resetCommand &&
         !(c->cmd->proc == shutdownCommand &&
           c->argc == 2 &&
           tolower(((char*)c->argv[1]->ptr)[0]) == 'n') &&
@@ -258,6 +260,14 @@
           tolower(((char*)c->argv[1]->ptr)[0]) == 'k'))
     {
         rejectCommand(c, shared.slowscripterr);
+        return C_OK;
+    }
+
+    /* Prevent a replica from sending commands that access the keyspace.
+     * The main objective here is to prevent abuse of client pause check
+     * from which replicas are exempt. */
+    if ((c->flags & CLIENT_SLAVE) && (is_may_replicate_command || is_write_command || is_read_command)) {
+        rejectCommandFormat(c, ""Replica can't interract with the keyspace"");
         return C_OK;
     }
 ","{'deleted_lines': ['\t  c->cmd->proc != resetCommand &&'], 'added_lines': ['    int is_read_command = (c->cmd->flags & CMD_READONLY) ||', '                           (c->cmd->proc == execCommand && (c->mstate.cmd_flags & CMD_READONLY));', '          c->cmd->proc != resetCommand &&', '        return C_OK;', '    }', '', '    /* Prevent a replica from sending commands that access the keyspace.', '     * The main objective here is to prevent abuse of client pause check', '     * from which replicas are exempt. */', '    if ((c->flags & CLIENT_SLAVE) && (is_may_replicate_command || is_write_command || is_read_command)) {', '        rejectCommandFormat(c, ""Replica can\'t interract with the keyspace"");']}",True,"Redis before 6cbea7d allows a replica to cause an assertion failure in a primary server by sending a non-administrative command (specifically, a SET command). NOTE: this was fixed for Redis 6.2.x and 7.x in 2021. Versions before 6.2 were not intended to have safety guarantees related to this.",5.9,MEDIUM,1,valid,2021-04-27T05:15:10Z,3
CVE-2021-32434,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,lewdlime/abcm2ps,"fix: array overflow when wrong duration in voice overlay

Issue #83,",2f56e1179cab6affeb8afa9d6c324008fe40d8e3,https://github.com/lewdlime/abcm2ps/commit/2f56e1179cab6affeb8afa9d6c324008fe40d8e3,parse.c,get_over,"static void get_over(struct SYMBOL *s)
{
struct VOICE_S *p_voice, *p_voice2, *p_voice3;
int range, voice, voice2, voice3;
static char tx_wrong_dur[] = ""Wrong duration in voice overlay"";
static char txt_no_note[] = ""No note in voice overlay"";
p_voice = curvoice;
if (p_voice->ignore)
return;
if (s->abc_type == ABC_T_BAR
|| s->u.v_over.type == V_OVER_E)  {
if (!p_voice->last_sym) {
error(1, s, txt_no_note);
return;
}
p_voice->last_sym->sflags |= S_BEAM_END;
over_bar = 0;
if (over_time < 0) {
error(1, s, ""Erroneous end of voice overlap"");
return;
}
if (p_voice->time != over_mxtime)
error(1, s, tx_wrong_dur);
curvoice = &voice_tb[over_voice];
over_mxtime = 0;
over_voice = -1;
over_time = -1;
return;
}
if (s->u.v_over.type == V_OVER_S) {
over_voice = p_voice - voice_tb;
over_time = p_voice->time;
return;
}
if (!p_voice->last_sym) {
error(1, s, txt_no_note);
return;
}
p_voice->last_sym->sflags |= S_BEAM_END;
voice2 = s->u.v_over.voice;
p_voice2 = &voice_tb[voice2];
if (parsys->voice[voice2].range < 0) {
int clone;
if (cfmt.abc2pscompat) {
error(1, s, ""Cannot have %%%%abc2pscompat"");
cfmt.abc2pscompat = 0;
}
clone = p_voice->clone >= 0;
p_voice2->id[0] = '&';
p_voice2->id[1] = '\0';
p_voice2->second = 1;
parsys->voice[voice2].second = 1;
p_voice2->scale = p_voice->scale;
p_voice2->octave = p_voice->octave;
p_voice2->transpose = p_voice->transpose;
memcpy(&p_voice2->key, &p_voice->key,
sizeof p_voice2->key);
memcpy(&p_voice2->ckey, &p_voice->ckey,
sizeof p_voice2->ckey);
memcpy(&p_voice2->okey, &p_voice->okey,
sizeof p_voice2->okey);
p_voice2->posit = p_voice->posit;
p_voice2->staff = p_voice->staff;
p_voice2->cstaff = p_voice->cstaff;
p_voice2->color = p_voice->color;
p_voice2->map_name = p_voice->map_name;
range = parsys->voice[p_voice - voice_tb].range;
for (voice = 0; voice < MAXVOICE; voice++) {
if (parsys->voice[voice].range > range)
parsys->voice[voice].range += clone + 1;
}
parsys->voice[voice2].range = range + 1;
voice_link(p_voice2);
if (clone) {
for (voice3 = MAXVOICE; --voice3 >= 0; ) {
if (parsys->voice[voice3].range < 0)
break;
}
if (voice3 > 0) {
p_voice3 = &voice_tb[voice3];
strcpy(p_voice3->id, p_voice2->id);
p_voice3->second = 1;
parsys->voice[voice3].second = 1;
p_voice3->scale = voice_tb[p_voice->clone].scale;
parsys->voice[voice3].range = range + 2;
voice_link(p_voice3);
p_voice2->clone = voice3;
} else {
error(1, s,
""Too many voices for overlay cloning"");
}
}
}
voice = p_voice - voice_tb;
if (over_time < 0) {
int time;
over_bar = 1;
over_mxtime = p_voice->time;
over_voice = voice;
time = p_voice2->time;
for (s = p_voice->last_sym; ; s = s->prev) {
if (s->type == BAR
|| s->time <= time)
break;
}
over_time = s->time;
} else {
if (over_mxtime == 0)
over_mxtime = p_voice->time;
else if (p_voice->time != over_mxtime)
error(1, s, tx_wrong_dur);
}
p_voice2->time = over_time;
curvoice = p_voice2;
}","static void get_over(struct SYMBOL *VAR_0)
{
struct VOICE_S *VAR_1, *VAR_2, *VAR_3;
int VAR_4, VAR_5, VAR_6, VAR_7;
static char VAR_8[] = ""Wrong duration in voice overlay"";
static char VAR_9[] = ""No note in voice overlay"";
VAR_1 = VAR_10;
if (VAR_1->ignore)
return;
if (VAR_0->abc_type == VAR_11
|| VAR_0->u.v_over.type == VAR_12)  {
if (!VAR_1->last_sym) {
error(1, VAR_0, VAR_9);
return;
}
VAR_1->last_sym->sflags |= VAR_13;
VAR_14 = 0;
if (VAR_15 < 0) {
error(1, VAR_0, ""Erroneous end of voice overlap"");
return;
}
if (VAR_1->time != VAR_16)
error(1, VAR_0, VAR_8);
VAR_10 = &VAR_17[VAR_18];
VAR_16 = 0;
VAR_18 = -1;
VAR_15 = -1;
return;
}
if (VAR_0->u.v_over.type == VAR_19) {
VAR_18 = VAR_1 - VAR_17;
VAR_15 = VAR_1->time;
return;
}
if (!VAR_1->last_sym) {
error(1, VAR_0, VAR_9);
return;
}
VAR_1->last_sym->sflags |= VAR_13;
VAR_6 = VAR_0->u.v_over.voice;
VAR_2 = &VAR_17[VAR_6];
if (VAR_20->voice[VAR_6].range < 0) {
int VAR_21;
if (VAR_22.abc2pscompat) {
error(1, VAR_0, ""Cannot have %%%%abc2pscompat"");
VAR_22.abc2pscompat = 0;
}
VAR_21 = VAR_1->clone >= 0;
VAR_2->id[0] = '&';
VAR_2->id[1] = '\0';
VAR_2->second = 1;
VAR_20->voice[VAR_6].second = 1;
VAR_2->scale = VAR_1->scale;
VAR_2->octave = VAR_1->octave;
VAR_2->transpose = VAR_1->transpose;
memcpy(&VAR_2->key, &VAR_1->key,
sizeof VAR_2->key);
memcpy(&VAR_2->ckey, &VAR_1->ckey,
sizeof VAR_2->ckey);
memcpy(&VAR_2->okey, &VAR_1->okey,
sizeof VAR_2->okey);
VAR_2->posit = VAR_1->posit;
VAR_2->staff = VAR_1->staff;
VAR_2->cstaff = VAR_1->cstaff;
VAR_2->color = VAR_1->color;
VAR_2->map_name = VAR_1->map_name;
VAR_4 = VAR_20->voice[VAR_1 - VAR_17].range;
for (VAR_5 = 0; VAR_5 < VAR_23; VAR_5++) {
if (VAR_20->voice[VAR_5].range > VAR_4)
VAR_20->voice[VAR_5].range += VAR_21 + 1;
}
VAR_20->voice[VAR_6].range = VAR_4 + 1;
voice_link(VAR_2);
if (VAR_21) {
for (VAR_7 = VAR_23; --VAR_7 >= 0; ) {
if (VAR_20->voice[VAR_7].range < 0)
break;
}
if (VAR_7 > 0) {
VAR_3 = &VAR_17[VAR_7];
strcpy(VAR_3->id, VAR_2->id);
VAR_3->second = 1;
VAR_20->voice[VAR_7].second = 1;
VAR_3->scale = VAR_17[VAR_1->clone].scale;
VAR_20->voice[VAR_7].range = VAR_4 + 2;
voice_link(VAR_3);
VAR_2->clone = VAR_7;
} else {
error(1, VAR_0,
""Too many voices for overlay cloning"");
}
}
}
VAR_5 = VAR_1 - VAR_17;
if (VAR_15 < 0) {
int VAR_24;
VAR_14 = 1;
VAR_16 = VAR_1->time;
VAR_18 = VAR_5;
VAR_24 = VAR_2->time;
for (VAR_0 = VAR_1->last_sym; ; VAR_0 = VAR_0->prev) {
if (VAR_0->type == VAR_25
|| VAR_0->time <= VAR_24)
break;
}
VAR_15 = VAR_0->time;
} else {
if (VAR_16 == 0)
VAR_16 = VAR_1->time;
else if (VAR_1->time != VAR_16)
error(1, VAR_0, VAR_8);
}
VAR_2->time = VAR_15;
VAR_10 = VAR_2;
}",lewdlime/abcm2ps/2f56e1179cab6affeb8afa9d6c324008fe40d8e3/parse.c/vul/before/0.json,"static void get_over(struct SYMBOL *s)
{
	struct VOICE_S *p_voice, *p_voice2, *p_voice3;
	int range, voice, voice2, voice3;
static char tx_wrong_dur[] = ""Wrong duration in voice overlay"";
static char txt_no_note[] = ""No note in voice overlay"";

	/* treat the end of overlay */
	p_voice = curvoice;
	if (p_voice->ignore)
		return;
	if (s->abc_type == ABC_T_BAR
	 || s->u.v_over.type == V_OVER_E)  {
		if (!p_voice->last_sym) {
			error(1, s, txt_no_note);
			return;
		}
		p_voice->last_sym->sflags |= S_BEAM_END;
		over_bar = 0;
		if (over_time < 0) {
			error(1, s, ""Erroneous end of voice overlap"");
			return;
		}
		curvoice = &voice_tb[over_voice];
		if (p_voice->time != over_mxtime) {
			error(1, s, tx_wrong_dur);
			if (p_voice->time > over_mxtime)
				curvoice->time = p_voice->time;
			else
				p_voice->time = curvoice->time;
		}
		over_mxtime = 0;
		over_voice = -1;
		over_time = -1;
		return;
	}

	/* treat the full overlay start */
	if (s->u.v_over.type == V_OVER_S) {
		over_voice = p_voice - voice_tb;
		over_time = p_voice->time;
		return;
	}

	/* (here is treated a new overlay - '&') */
	/* create the extra voice if not done yet */
	if (!p_voice->last_sym) {
		error(1, s, txt_no_note);
		return;
	}
	p_voice->last_sym->sflags |= S_BEAM_END;
	voice2 = s->u.v_over.voice;
	p_voice2 = &voice_tb[voice2];
	if (parsys->voice[voice2].range < 0) {
		int clone;

		if (cfmt.abc2pscompat) {
			error(1, s, ""Cannot have %%%%abc2pscompat"");
			cfmt.abc2pscompat = 0;
		}
		clone = p_voice->clone >= 0;
		p_voice2->id[0] = '&';
		p_voice2->id[1] = '\0';
		p_voice2->second = 1;
		parsys->voice[voice2].second = 1;
		p_voice2->scale = p_voice->scale;
		p_voice2->octave = p_voice->octave;
		p_voice2->transpose = p_voice->transpose;
		memcpy(&p_voice2->key, &p_voice->key,
					sizeof p_voice2->key);
		memcpy(&p_voice2->ckey, &p_voice->ckey,
					sizeof p_voice2->ckey);
		memcpy(&p_voice2->okey, &p_voice->okey,
					sizeof p_voice2->okey);
		p_voice2->posit = p_voice->posit;
		p_voice2->staff = p_voice->staff;
		p_voice2->cstaff = p_voice->cstaff;
		p_voice2->color = p_voice->color;
		p_voice2->map_name = p_voice->map_name;
		range = parsys->voice[p_voice - voice_tb].range;
		for (voice = 0; voice < MAXVOICE; voice++) {
			if (parsys->voice[voice].range > range)
				parsys->voice[voice].range += clone + 1;
		}
		parsys->voice[voice2].range = range + 1;
		voice_link(p_voice2);
		if (clone) {
			for (voice3 = MAXVOICE; --voice3 >= 0; ) {
				if (parsys->voice[voice3].range < 0)
					break;
			}
			if (voice3 > 0) {
				p_voice3 = &voice_tb[voice3];
				strcpy(p_voice3->id, p_voice2->id);
				p_voice3->second = 1;
				parsys->voice[voice3].second = 1;
				p_voice3->scale = voice_tb[p_voice->clone].scale;
				parsys->voice[voice3].range = range + 2;
				voice_link(p_voice3);
				p_voice2->clone = voice3;
			} else {
				error(1, s,
				      ""Too many voices for overlay cloning"");
			}
		}
	}
	voice = p_voice - voice_tb;
//	p_voice2->cstaff = p_voice2->staff = parsys->voice[voice2].staff
//			= parsys->voice[voice].staff;
//	if ((voice3 = p_voice2->clone) >= 0) {
//		p_voice3 = &voice_tb[voice3];
//		p_voice3->cstaff = p_voice3->staff
//				= parsys->voice[voice3].staff
//				= parsys->voice[p_voice->clone].staff;
//	}

	if (over_time < 0) {			/* first '&' in a measure */
		int time;

		over_bar = 1;
		over_mxtime = p_voice->time;
		over_voice = voice;
		time = p_voice2->time;
		for (s = p_voice->last_sym; /*s*/; s = s->prev) {
			if (s->type == BAR
			 || s->time <= time)	/* (if start of tune) */
				break;
		}
		over_time = s->time;
	} else {
		if (over_mxtime == 0)
			over_mxtime = p_voice->time;
		else if (p_voice->time != over_mxtime)
			error(1, s, tx_wrong_dur);
	}
	p_voice2->time = over_time;
	curvoice = p_voice2;
}","static void get_over(struct SYMBOL *VAR_0)
{
	struct VOICE_S *VAR_1, *VAR_2, *VAR_3;
	int VAR_4, VAR_5, VAR_6, VAR_7;
static char VAR_8[] = ""Wrong duration in voice overlay"";
static char VAR_9[] = ""No note in voice overlay"";

	/* COMMENT_0 */
	VAR_1 = VAR_10;
	if (VAR_1->ignore)
		return;
	if (VAR_0->abc_type == VAR_11
	 || VAR_0->u.v_over.type == VAR_12)  {
		if (!VAR_1->last_sym) {
			error(1, VAR_0, VAR_9);
			return;
		}
		VAR_1->last_sym->sflags |= VAR_13;
		VAR_14 = 0;
		if (VAR_15 < 0) {
			error(1, VAR_0, ""Erroneous end of voice overlap"");
			return;
		}
		VAR_10 = &VAR_16[VAR_17];
		if (VAR_1->time != VAR_18) {
			error(1, VAR_0, VAR_8);
			if (VAR_1->time > VAR_18)
				VAR_10->time = VAR_1->time;
			else
				VAR_1->time = VAR_10->time;
		}
		VAR_18 = 0;
		VAR_17 = -1;
		VAR_15 = -1;
		return;
	}

	/* COMMENT_1 */
	if (VAR_0->u.v_over.type == VAR_19) {
		VAR_17 = VAR_1 - VAR_16;
		VAR_15 = VAR_1->time;
		return;
	}

	/* COMMENT_2 */
	/* COMMENT_3 */
	if (!VAR_1->last_sym) {
		error(1, VAR_0, VAR_9);
		return;
	}
	VAR_1->last_sym->sflags |= VAR_13;
	VAR_6 = VAR_0->u.v_over.voice;
	VAR_2 = &VAR_16[VAR_6];
	if (VAR_20->voice[VAR_6].range < 0) {
		int VAR_21;

		if (VAR_22.abc2pscompat) {
			error(1, VAR_0, ""Cannot have %%%%abc2pscompat"");
			VAR_22.abc2pscompat = 0;
		}
		VAR_21 = VAR_1->clone >= 0;
		VAR_2->id[0] = '&';
		VAR_2->id[1] = '\0';
		VAR_2->second = 1;
		VAR_20->voice[VAR_6].second = 1;
		VAR_2->scale = VAR_1->scale;
		VAR_2->octave = VAR_1->octave;
		VAR_2->transpose = VAR_1->transpose;
		memcpy(&VAR_2->key, &VAR_1->key,
					sizeof VAR_2->key);
		memcpy(&VAR_2->ckey, &VAR_1->ckey,
					sizeof VAR_2->ckey);
		memcpy(&VAR_2->okey, &VAR_1->okey,
					sizeof VAR_2->okey);
		VAR_2->posit = VAR_1->posit;
		VAR_2->staff = VAR_1->staff;
		VAR_2->cstaff = VAR_1->cstaff;
		VAR_2->color = VAR_1->color;
		VAR_2->map_name = VAR_1->map_name;
		VAR_4 = VAR_20->voice[VAR_1 - VAR_16].range;
		for (VAR_5 = 0; VAR_5 < VAR_23; VAR_5++) {
			if (VAR_20->voice[VAR_5].range > VAR_4)
				VAR_20->voice[VAR_5].range += VAR_21 + 1;
		}
		VAR_20->voice[VAR_6].range = VAR_4 + 1;
		voice_link(VAR_2);
		if (VAR_21) {
			for (VAR_7 = VAR_23; --VAR_7 >= 0; ) {
				if (VAR_20->voice[VAR_7].range < 0)
					break;
			}
			if (VAR_7 > 0) {
				VAR_3 = &VAR_16[VAR_7];
				strcpy(VAR_3->id, VAR_2->id);
				VAR_3->second = 1;
				VAR_20->voice[VAR_7].second = 1;
				VAR_3->scale = VAR_16[VAR_1->clone].scale;
				VAR_20->voice[VAR_7].range = VAR_4 + 2;
				voice_link(VAR_3);
				VAR_2->clone = VAR_7;
			} else {
				error(1, VAR_0,
				      ""Too many voices for overlay cloning"");
			}
		}
	}
	VAR_5 = VAR_1 - VAR_16;
/* COMMENT_4 */
/* COMMENT_5 */
/* COMMENT_6 */
/* COMMENT_7 */
/* COMMENT_8 */
/* COMMENT_9 */
/* COMMENT_10 */
/* COMMENT_11 */

	if (VAR_15 < 0) {			/* COMMENT_12 */
		int VAR_24;

		VAR_14 = 1;
		VAR_18 = VAR_1->time;
		VAR_17 = VAR_5;
		VAR_24 = VAR_2->time;
		for (VAR_0 = VAR_1->last_sym; /* COMMENT_13 */; VAR_0 = VAR_0->prev) {
			if (VAR_0->type == VAR_25
			 || VAR_0->time <= VAR_24)	/* COMMENT_14 */
				break;
		}
		VAR_15 = VAR_0->time;
	} else {
		if (VAR_18 == 0)
			VAR_18 = VAR_1->time;
		else if (VAR_1->time != VAR_18)
			error(1, VAR_0, VAR_8);
	}
	VAR_2->time = VAR_15;
	VAR_10 = VAR_2;
}",lewdlime/abcm2ps/2f56e1179cab6affeb8afa9d6c324008fe40d8e3/parse.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,9 +21,14 @@
 			error(1, s, ""Erroneous end of voice overlap"");
 			return;
 		}
-		if (p_voice->time != over_mxtime)
+		curvoice = &voice_tb[over_voice];
+		if (p_voice->time != over_mxtime) {
 			error(1, s, tx_wrong_dur);
-		curvoice = &voice_tb[over_voice];
+			if (p_voice->time > over_mxtime)
+				curvoice->time = p_voice->time;
+			else
+				p_voice->time = curvoice->time;
+		}
 		over_mxtime = 0;
 		over_voice = -1;
 		over_time = -1;","{'deleted_lines': ['\t\tif (p_voice->time != over_mxtime)', '\t\tcurvoice = &voice_tb[over_voice];'], 'added_lines': ['\t\tcurvoice = &voice_tb[over_voice];', '\t\tif (p_voice->time != over_mxtime) {', '\t\t\tif (p_voice->time > over_mxtime)', '\t\t\t\tcurvoice->time = p_voice->time;', '\t\t\telse', '\t\t\t\tp_voice->time = curvoice->time;', '\t\t}']}",True,abcm2ps v8.14.11 was discovered to contain an out-of-bounds read in the function calculate_beam at draw.c.,5.5,MEDIUM,1,valid,2021-04-27T09:52:27Z,3
CVE-2021-29552,['CWE-617'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,tensorflow,"Fix overflow CHECK issue with `tf.raw_ops.UnsortedSegmentJoin`.

PiperOrigin-RevId: 370766155
Change-Id: I33e7c6626224e1060a8a4ab51ad5d861c6d4c63e",704866eabe03a9aeda044ec91a8d0c83fc1ebdbe,https://github.com/tensorflow/tensorflow/commit/704866eabe03a9aeda044ec91a8d0c83fc1ebdbe,tensorflow/core/kernels/unsorted_segment_join_op.cc,Compute,"void Compute(OpKernelContext* context) override {
const Tensor& input = context->input(0);
const TensorShape& input_shape = input.shape();
const int32 input_dims = input_shape.dims();
const Tensor& segment_id = context->input(1);
const TensorShape& segment_id_shape = segment_id.shape();
const int32 segment_dims = segment_id_shape.dims();
const Tensor& num_segments_tensor = context->input(2);
auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();
OP_REQUIRES(context, segment_dims != 0,
errors::InvalidArgument(""Segment_id cannot have rank 0""));
OP_REQUIRES(
context, segment_dims <= input_dims,
errors::OutOfRange(""Invalid segment_id rank "", segment_dims,
"" for input with "", input_dims, "" dimension(s)""));
for (auto i = 0; i < segment_dims; i++) {
OP_REQUIRES(
context, segment_id_shape.dim_size(i) == input_shape.dim_size(i),
errors::InvalidArgument(
""Segment dimension is "", segment_id_shape.dim_size(i),
"" while input dimension is "", input_dims, "" in rank "", i));
}
Tensor* output_tensor = nullptr;
TensorShape output_shape =
GetOutputShape(input_shape, segment_id_shape, num_segments);
OP_REQUIRES_OK(context, context->allocate_output(""output"", output_shape,
&output_tensor));
auto output_flat = output_tensor->flat<tstring>();
auto flat_segment_id = segment_id.flat<INDICES_TYPE>();
auto flat_input = input.flat<tstring>();
for (int i = 0; i < flat_segment_id.size(); i++) {
OP_REQUIRES(
context,
((flat_segment_id(i) < num_segments) && (flat_segment_id(i) >= 0)),
errors::InvalidArgument(
""segment_ids are not allowed to exceed num_segments or""
"" to have negative values.""));
}
int64 big_stride;
int64 small_stride;
std::tie(big_stride, small_stride) =
GetStrides<INDICES_TYPE>(input_shape, segment_id_shape);
auto relative_offset_set =
GetFlattenedRelativeOffsets<INDICES_TYPE>(small_stride, big_stride);
for (auto start_offset = 0; start_offset < big_stride; start_offset++) {
for (auto i = 0; i < relative_offset_set.size(); i++) {
auto output_index = start_offset + flat_segment_id(i) * big_stride;
auto offset = start_offset + relative_offset_set[i];
if (output_flat(output_index).length() != 0)
output_flat(output_index).append(separator_.c_str());
output_flat(output_index).append(flat_input(offset));
}
}
}","void Compute(OpKernelContext* VAR_0) override {
const Tensor& VAR_1 = VAR_0->input(0);
const TensorShape& VAR_2 = VAR_1.shape();
const int32 VAR_3 = VAR_2.dims();
const Tensor& VAR_4 = VAR_0->input(1);
const TensorShape& VAR_5 = VAR_4.shape();
const int32 VAR_6 = VAR_5.dims();
const Tensor& VAR_7 = VAR_0->input(2);
auto VAR_8 = VAR_7.scalar<NUM_SEGMENTS_TYPE>()();
OP_REQUIRES(VAR_0, VAR_6 != 0,
errors::InvalidArgument(""Segment_id cannot have rank 0""));
OP_REQUIRES(
VAR_0, VAR_6 <= VAR_3,
errors::OutOfRange(""Invalid segment_id rank "", VAR_6,
"" for input with "", VAR_3, "" dimension(s)""));
for (auto VAR_9 = 0; VAR_9 < VAR_6; VAR_9++) {
OP_REQUIRES(
VAR_0, VAR_5.dim_size(VAR_9) == VAR_2.dim_size(VAR_9),
errors::InvalidArgument(
""Segment dimension is "", VAR_5.dim_size(VAR_9),
"" while input dimension is "", VAR_3, "" in rank "", VAR_9));
}
Tensor* VAR_10 = nullptr;
TensorShape VAR_11 =
GetOutputShape(VAR_2, VAR_5, VAR_8);
OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(""output"", VAR_11,
&VAR_10));
auto VAR_12 = VAR_10->flat<tstring>();
auto VAR_13 = VAR_4.flat<INDICES_TYPE>();
auto VAR_14 = VAR_1.flat<tstring>();
for (int VAR_9 = 0; VAR_9 < VAR_13.size(); VAR_9++) {
OP_REQUIRES(
VAR_0,
((VAR_13(VAR_9) < VAR_8) && (VAR_13(VAR_9) >= 0)),
errors::InvalidArgument(
""segment_ids are not allowed to exceed num_segments or""
"" to have negative values.""));
}
int64 VAR_15;
int64 VAR_16;
std::tie(VAR_15, VAR_16) =
VAR_17<INDICES_TYPE>(VAR_2, VAR_5);
auto VAR_18 =
VAR_19<INDICES_TYPE>(VAR_16, VAR_15);
for (auto VAR_20 = 0; VAR_20 < VAR_15; VAR_20++) {
for (auto VAR_9 = 0; VAR_9 < VAR_18.size(); VAR_9++) {
auto VAR_21 = VAR_20 + VAR_13(VAR_9) * VAR_15;
auto VAR_22 = VAR_20 + VAR_18[VAR_9];
if (VAR_12(VAR_21).length() != 0)
VAR_12(VAR_21).append(VAR_23.c_str());
VAR_12(VAR_21).append(VAR_14(VAR_22));
}
}
}",,"void Compute(OpKernelContext* context) override {
    const Tensor& input = context->input(0);
    const TensorShape& input_shape = input.shape();
    const int32 input_dims = input_shape.dims();

    const Tensor& segment_id = context->input(1);
    const TensorShape& segment_id_shape = segment_id.shape();
    const int32 segment_dims = segment_id_shape.dims();

    const Tensor& num_segments_tensor = context->input(2);
    OP_REQUIRES(context, num_segments_tensor.NumElements() != 0,
                errors::InvalidArgument(""Number of segments cannot be empty.""));
    auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();

    OP_REQUIRES(context, segment_dims != 0,
                errors::InvalidArgument(""Segment_id cannot have rank 0""));

    OP_REQUIRES(
        context, segment_dims <= input_dims,
        errors::OutOfRange(""Invalid segment_id rank "", segment_dims,
                           "" for input with "", input_dims, "" dimension(s)""));
    for (auto i = 0; i < segment_dims; i++) {
      OP_REQUIRES(
          context, segment_id_shape.dim_size(i) == input_shape.dim_size(i),
          errors::InvalidArgument(
              ""Segment dimension is "", segment_id_shape.dim_size(i),
              "" while input dimension is "", input_dims, "" in rank "", i));
    }

    // Making output tensor.
    Tensor* output_tensor = nullptr;
    TensorShape output_shape =
        GetOutputShape(input_shape, segment_id_shape, num_segments);
    OP_REQUIRES_OK(context, context->allocate_output(""output"", output_shape,
                                                     &output_tensor));

    // Preparating flat tensors.
    auto output_flat = output_tensor->flat<tstring>();
    auto flat_segment_id = segment_id.flat<INDICES_TYPE>();
    auto flat_input = input.flat<tstring>();

    for (int i = 0; i < flat_segment_id.size(); i++) {
      OP_REQUIRES(
          context,
          ((flat_segment_id(i) < num_segments) && (flat_segment_id(i) >= 0)),
          errors::InvalidArgument(
              ""segment_ids are not allowed to exceed num_segments or""
              "" to have negative values.""));
    }

    int64 big_stride;
    int64 small_stride;
    std::tie(big_stride, small_stride) =
        GetStrides<INDICES_TYPE>(input_shape, segment_id_shape);
    auto relative_offset_set =
        GetFlattenedRelativeOffsets<INDICES_TYPE>(small_stride, big_stride);
    for (auto start_offset = 0; start_offset < big_stride; start_offset++) {
      for (auto i = 0; i < relative_offset_set.size(); i++) {
        auto output_index = start_offset + flat_segment_id(i) * big_stride;
        auto offset = start_offset + relative_offset_set[i];
        if (output_flat(output_index).length() != 0)
          output_flat(output_index).append(separator_.c_str());
        output_flat(output_index).append(flat_input(offset));
      }
    }
  }","void Compute(OpKernelContext* VAR_0) override {
    const Tensor& VAR_1 = VAR_0->input(0);
    const TensorShape& VAR_2 = VAR_1.shape();
    const int32 VAR_3 = VAR_2.dims();

    const Tensor& VAR_4 = VAR_0->input(1);
    const TensorShape& VAR_5 = VAR_4.shape();
    const int32 VAR_6 = VAR_5.dims();

    const Tensor& VAR_7 = VAR_0->input(2);
    OP_REQUIRES(VAR_0, VAR_7.NumElements() != 0,
                errors::InvalidArgument(""Number of segments cannot be empty.""));
    auto VAR_8 = VAR_7.scalar<NUM_SEGMENTS_TYPE>()();

    OP_REQUIRES(VAR_0, VAR_6 != 0,
                errors::InvalidArgument(""Segment_id cannot have rank 0""));

    OP_REQUIRES(
        VAR_0, VAR_6 <= VAR_3,
        errors::OutOfRange(""Invalid segment_id rank "", VAR_6,
                           "" for input with "", VAR_3, "" dimension(s)""));
    for (auto VAR_9 = 0; VAR_9 < VAR_6; VAR_9++) {
      OP_REQUIRES(
          VAR_0, VAR_5.dim_size(VAR_9) == VAR_2.dim_size(VAR_9),
          errors::InvalidArgument(
              ""Segment dimension is "", VAR_5.dim_size(VAR_9),
              "" while input dimension is "", VAR_3, "" in rank "", VAR_9));
    }

    /* COMMENT_0 */
    Tensor* VAR_10 = nullptr;
    TensorShape VAR_11 =
        GetOutputShape(VAR_2, VAR_5, VAR_8);
    OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(""output"", VAR_11,
                                                     &VAR_10));

    /* COMMENT_1 */
    auto VAR_12 = VAR_10->flat<tstring>();
    auto VAR_13 = VAR_4.flat<INDICES_TYPE>();
    auto VAR_14 = VAR_1.flat<tstring>();

    for (int VAR_9 = 0; VAR_9 < VAR_13.size(); VAR_9++) {
      OP_REQUIRES(
          VAR_0,
          ((VAR_13(VAR_9) < VAR_8) && (VAR_13(VAR_9) >= 0)),
          errors::InvalidArgument(
              ""segment_ids are not allowed to exceed num_segments or""
              "" to have negative values.""));
    }

    int64 VAR_15;
    int64 VAR_16;
    std::tie(VAR_15, VAR_16) =
        VAR_17<INDICES_TYPE>(VAR_2, VAR_5);
    auto VAR_18 =
        VAR_19<INDICES_TYPE>(VAR_16, VAR_15);
    for (auto VAR_20 = 0; VAR_20 < VAR_15; VAR_20++) {
      for (auto VAR_9 = 0; VAR_9 < VAR_18.size(); VAR_9++) {
        auto VAR_21 = VAR_20 + VAR_13(VAR_9) * VAR_15;
        auto VAR_22 = VAR_20 + VAR_18[VAR_9];
        if (VAR_12(VAR_21).length() != 0)
          VAR_12(VAR_21).append(VAR_23.c_str());
        VAR_12(VAR_21).append(VAR_14(VAR_22));
      }
    }
  }",,"--- func_before
+++ func_after
@@ -8,6 +8,8 @@
     const int32 segment_dims = segment_id_shape.dims();
 
     const Tensor& num_segments_tensor = context->input(2);
+    OP_REQUIRES(context, num_segments_tensor.NumElements() != 0,
+                errors::InvalidArgument(""Number of segments cannot be empty.""));
     auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();
 
     OP_REQUIRES(context, segment_dims != 0,","{'deleted_lines': [], 'added_lines': ['    OP_REQUIRES(context, num_segments_tensor.NumElements() != 0,', '                errors::InvalidArgument(""Number of segments cannot be empty.""));']}",True,"TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by controlling the values of `num_segments` tensor argument for `UnsortedSegmentJoin`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a2a607db15c7cd01d754d37e5448d72a13491bdb/tensorflow/core/kernels/unsorted_segment_join_op.cc#L92-L93) assumes that the `num_segments` tensor is a valid scalar. Since the tensor is empty the `CHECK` involved in `.scalar<T>()()` that checks that the number of elements is exactly 1 will be invalidated and this would result in process termination. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",2.5,LOW,0,valid,2021-04-27T21:41:40Z,3
CVE-2021-29589,['CWE-369'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"Handle one more division by 0 in TFLite.

PiperOrigin-RevId: 370800140
Change-Id: I9ab42e5aaccf02f226d1282611490a54cf7d273e",8e45822aa0b9f5df4b4c64f221e64dc930a70a9d,https://github.com/tensorflow/tensorflow/commit/8e45822aa0b9f5df4b4c64f221e64dc930a70a9d,tensorflow/lite/kernels/gather_nd.cc,Eval,"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
const TfLiteTensor* params;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kParams, &params));
const TfLiteTensor* indices;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kIndices, &indices));
TfLiteTensor* output;
TF_LITE_ENSURE_OK(context,
GetOutputSafe(context, node, kOutputTensor, &output));
switch (indices->type) {
case kTfLiteInt32:
return EvalGatherNd<int32_t>(context, params, indices, output);
case kTfLiteInt64:
return EvalGatherNd<int64_t>(context, params, indices, output);
default:
context->ReportError(
context, ""Indices of type '%s' are not supported by gather_nd."",
TfLiteTypeGetName(indices->type));
return kTfLiteError;
}
}","TfLiteStatus Eval(TfLiteContext* VAR_0, TfLiteNode* VAR_1) {
const TfLiteTensor* VAR_2;
TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_3, &VAR_2));
const TfLiteTensor* VAR_4;
TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_5, &VAR_4));
TfLiteTensor* VAR_6;
TF_LITE_ENSURE_OK(VAR_0,
GetOutputSafe(VAR_0, VAR_1, VAR_7, &VAR_6));
switch (VAR_4->type) {
case VAR_8:
return VAR_9<int32_t>(VAR_0, VAR_2, VAR_4, VAR_6);
case VAR_10:
return VAR_9<int64_t>(VAR_0, VAR_2, VAR_4, VAR_6);
default:
VAR_0->ReportError(
VAR_0, ""Indices of type '%s' are not supported by gather_nd."",
TfLiteTypeGetName(VAR_4->type));
return VAR_11;
}
}",tensorflow/8e45822aa0b9f5df4b4c64f221e64dc930a70a9d/gather_nd.cc/vul/before/0.json,"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
  const TfLiteTensor* params;
  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kParams, &params));
  const TfLiteTensor* indices;
  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kIndices, &indices));
  TfLiteTensor* output;
  TF_LITE_ENSURE_OK(context,
                    GetOutputSafe(context, node, kOutputTensor, &output));

  // Prevent division by 0 in the helper
  TF_LITE_ENSURE(context, NumElements(params) > 0);

  switch (indices->type) {
    case kTfLiteInt32:
      return EvalGatherNd<int32_t>(context, params, indices, output);
    case kTfLiteInt64:
      return EvalGatherNd<int64_t>(context, params, indices, output);
    default:
      context->ReportError(
          context, ""Indices of type '%s' are not supported by gather_nd."",
          TfLiteTypeGetName(indices->type));
      return kTfLiteError;
  }
}","TfLiteStatus Eval(TfLiteContext* VAR_0, TfLiteNode* VAR_1) {
  const TfLiteTensor* VAR_2;
  TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_3, &VAR_2));
  const TfLiteTensor* VAR_4;
  TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_5, &VAR_4));
  TfLiteTensor* VAR_6;
  TF_LITE_ENSURE_OK(VAR_0,
                    GetOutputSafe(VAR_0, VAR_1, VAR_7, &VAR_6));

  /* COMMENT_0 */
  TF_LITE_ENSURE(VAR_0, NumElements(VAR_2) > 0);

  switch (VAR_4->type) {
    case VAR_8:
      return VAR_9<int32_t>(VAR_0, VAR_2, VAR_4, VAR_6);
    case VAR_10:
      return VAR_9<int64_t>(VAR_0, VAR_2, VAR_4, VAR_6);
    default:
      VAR_0->ReportError(
          VAR_0, ""Indices of type '%s' are not supported by gather_nd."",
          TfLiteTypeGetName(VAR_4->type));
      return VAR_11;
  }
}",tensorflow/8e45822aa0b9f5df4b4c64f221e64dc930a70a9d/gather_nd.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,9 @@
   TfLiteTensor* output;
   TF_LITE_ENSURE_OK(context,
                     GetOutputSafe(context, node, kOutputTensor, &output));
+
+  // Prevent division by 0 in the helper
+  TF_LITE_ENSURE(context, NumElements(params) > 0);
 
   switch (indices->type) {
     case kTfLiteInt32:","{'deleted_lines': [], 'added_lines': ['', '  // Prevent division by 0 in the helper', '  TF_LITE_ENSURE(context, NumElements(params) > 0);']}",True,"TensorFlow is an end-to-end open source platform for machine learning. The reference implementation of the `GatherNd` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/internal/reference/reference_ops.h#L966). An attacker can craft a model such that `params` input would be an empty tensor. In turn, `params_shape.Dims(.)` would be zero, in at least one dimension. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",2.5,LOW,0,valid,2021-04-28T00:46:10Z,3
CVE-2021-29591,"['CWE-674', 'CWE-835']",AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"Prevent infinite loop/stack overflow in TFLite `while` op.

PiperOrigin-RevId: 370800333
Change-Id: I6a2e4ff849da339545c449db2af7e11ce6ff02c3",9c1dc920d8ffb4893d6c9d27d1f039607b326743,https://github.com/tensorflow/tensorflow/commit/9c1dc920d8ffb4893d6c9d27d1f039607b326743,tensorflow/lite/kernels/while.cc,Prepare,"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
OpData* op_data = reinterpret_cast<OpData*>(node->user_data);
int num_inputs = node->inputs->size;
TF_LITE_ENSURE_EQ(context, node->outputs->size, num_inputs);
Subgraph* this_subgraph = reinterpret_cast<Subgraph*>(context->impl_);
auto* subgraphs = this_subgraph->GetSubgraphs();
TF_LITE_ENSURE(context, op_data->cond_subgraph_index < subgraphs->size());
TF_LITE_ENSURE(context, op_data->body_subgraph_index < subgraphs->size());
Subgraph* cond_subgraph = (*subgraphs)[op_data->cond_subgraph_index].get();
Subgraph* body_subgraph = (*subgraphs)[op_data->body_subgraph_index].get();
TF_LITE_ENSURE_EQ(context, cond_subgraph->inputs().size(), num_inputs);
TF_LITE_ENSURE_EQ(context, cond_subgraph->outputs().size(), 1);
TF_LITE_ENSURE_EQ(context, body_subgraph->inputs().size(), num_inputs);
TF_LITE_ENSURE_EQ(context, body_subgraph->outputs().size(), num_inputs);
TF_LITE_ENSURE_OK(
context, CopyTensorsShapeAndType(
context, this_subgraph, TfLiteIntArrayView(node->inputs),
cond_subgraph, cond_subgraph->inputs(), true));
TF_LITE_ENSURE_OK(context, cond_subgraph->AllocateTensors());
TfLiteTensor* cond_output =
cond_subgraph->tensor(cond_subgraph->outputs()[0]);
if (IsDynamicTensor(cond_output)) {
op_data->cond_has_dynamic_output_tensors = true;
} else {
TF_LITE_ENSURE_STATUS(CheckCondOutput(context, cond_output));
}
TF_LITE_ENSURE_OK(
context, CopyTensorsShapeAndType(
context, this_subgraph, TfLiteIntArrayView(node->inputs),
body_subgraph, body_subgraph->inputs(), true));
TF_LITE_ENSURE_OK(context, body_subgraph->AllocateTensors());
if (body_subgraph->HasDynamicTensors()) {
op_data->body_has_dynamic_output_tensors = true;
} else {
for (int i = 0; i < num_inputs; ++i) {
TfLiteTensor* body_input =
body_subgraph->tensor(body_subgraph->inputs()[i]);
TfLiteTensor* body_output =
body_subgraph->tensor(body_subgraph->outputs()[i]);
TF_LITE_ENSURE_TYPES_EQ(context, body_input->type, body_output->type);
TF_LITE_ENSURE(context, !IsDynamicTensor(body_output));
if (!TfLiteIntArrayEqual(body_input->dims, body_output->dims)) {
op_data->body_has_dynamic_output_tensors = true;
break;
}
}
}
for (int i = 0; i < num_inputs; ++i) {
TfLiteTensor* output;
TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));
if (op_data->body_has_dynamic_output_tensors) {
SetTensorToDynamic(output);
} else {
TfLiteTensor* body_output =
body_subgraph->tensor(body_subgraph->outputs()[i]);
TfLiteIntArray* output_size = TfLiteIntArrayCopy(body_output->dims);
TF_LITE_ENSURE_OK(context,
context->ResizeTensor(context, output, output_size));
}
}
return kTfLiteOk;
}","TfLiteStatus Prepare(TfLiteContext* VAR_0, TfLiteNode* VAR_1) {
OpData* VAR_2 = VAR_3<OpData*>(VAR_1->user_data);
int VAR_4 = VAR_1->inputs->size;
TF_LITE_ENSURE_EQ(VAR_0, VAR_1->outputs->size, VAR_4);
Subgraph* VAR_5 = VAR_3<Subgraph*>(VAR_0->impl_);
auto* VAR_6 = VAR_5->GetSubgraphs();
TF_LITE_ENSURE(VAR_0, VAR_2->cond_subgraph_index < VAR_6->size());
TF_LITE_ENSURE(VAR_0, VAR_2->body_subgraph_index < VAR_6->size());
Subgraph* VAR_7 = (*VAR_6)[VAR_2->cond_subgraph_index].get();
Subgraph* VAR_8 = (*VAR_6)[VAR_2->body_subgraph_index].get();
TF_LITE_ENSURE_EQ(VAR_0, VAR_7->inputs().size(), VAR_4);
TF_LITE_ENSURE_EQ(VAR_0, VAR_7->outputs().size(), 1);
TF_LITE_ENSURE_EQ(VAR_0, VAR_8->inputs().size(), VAR_4);
TF_LITE_ENSURE_EQ(VAR_0, VAR_8->outputs().size(), VAR_4);
TF_LITE_ENSURE_OK(
VAR_0, CopyTensorsShapeAndType(
VAR_0, VAR_5, TfLiteIntArrayView(VAR_1->inputs),
VAR_7, VAR_7->inputs(), true));
TF_LITE_ENSURE_OK(VAR_0, VAR_7->AllocateTensors());
TfLiteTensor* VAR_9 =
VAR_7->tensor(VAR_7->outputs()[0]);
if (IsDynamicTensor(VAR_9)) {
VAR_2->cond_has_dynamic_output_tensors = true;
} else {
TF_LITE_ENSURE_STATUS(CheckCondOutput(VAR_0, VAR_9));
}
TF_LITE_ENSURE_OK(
VAR_0, CopyTensorsShapeAndType(
VAR_0, VAR_5, TfLiteIntArrayView(VAR_1->inputs),
VAR_8, VAR_8->inputs(), true));
TF_LITE_ENSURE_OK(VAR_0, VAR_8->AllocateTensors());
if (VAR_8->HasDynamicTensors()) {
VAR_2->body_has_dynamic_output_tensors = true;
} else {
for (int VAR_10 = 0; VAR_10 < VAR_4; ++VAR_10) {
TfLiteTensor* VAR_11 =
VAR_8->tensor(VAR_8->inputs()[VAR_10]);
TfLiteTensor* VAR_12 =
VAR_8->tensor(VAR_8->outputs()[VAR_10]);
TF_LITE_ENSURE_TYPES_EQ(VAR_0, VAR_11->type, VAR_12->type);
TF_LITE_ENSURE(VAR_0, !IsDynamicTensor(VAR_12));
if (!TfLiteIntArrayEqual(VAR_11->dims, VAR_12->dims)) {
VAR_2->body_has_dynamic_output_tensors = true;
break;
}
}
}
for (int VAR_10 = 0; VAR_10 < VAR_4; ++VAR_10) {
TfLiteTensor* VAR_13;
TF_LITE_ENSURE_OK(VAR_0, GetOutputSafe(VAR_0, VAR_1, VAR_10, &VAR_13));
if (VAR_2->body_has_dynamic_output_tensors) {
SetTensorToDynamic(VAR_13);
} else {
TfLiteTensor* VAR_12 =
VAR_8->tensor(VAR_8->outputs()[VAR_10]);
TfLiteIntArray* VAR_14 = TfLiteIntArrayCopy(VAR_12->dims);
TF_LITE_ENSURE_OK(VAR_0,
VAR_0->ResizeTensor(VAR_0, VAR_13, VAR_14));
}
}
return VAR_15;
}",tensorflow/9c1dc920d8ffb4893d6c9d27d1f039607b326743/while.cc/vul/before/0.json,"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);
  int num_inputs = node->inputs->size;
  // The number of outputs should be the same as number of inputs.
  TF_LITE_ENSURE_EQ(context, node->outputs->size, num_inputs);

  // Check subgraph indices and get subgraphs.
  Subgraph* this_subgraph = reinterpret_cast<Subgraph*>(context->impl_);
  auto* subgraphs = this_subgraph->GetSubgraphs();
  TF_LITE_ENSURE(context, op_data->cond_subgraph_index < subgraphs->size());
  TF_LITE_ENSURE(context, op_data->body_subgraph_index < subgraphs->size());
  TF_LITE_ENSURE(context,
                 op_data->cond_subgraph_index != op_data->body_subgraph_index);

  Subgraph* cond_subgraph = (*subgraphs)[op_data->cond_subgraph_index].get();
  Subgraph* body_subgraph = (*subgraphs)[op_data->body_subgraph_index].get();

  // Check input & output count of the condition subgraph.
  TF_LITE_ENSURE_EQ(context, cond_subgraph->inputs().size(), num_inputs);
  TF_LITE_ENSURE_EQ(context, cond_subgraph->outputs().size(), 1);

  // Check input & output count of the body subgraph.
  TF_LITE_ENSURE_EQ(context, body_subgraph->inputs().size(), num_inputs);
  TF_LITE_ENSURE_EQ(context, body_subgraph->outputs().size(), num_inputs);

  // Prepare and check the condition subgraph.
  TF_LITE_ENSURE_OK(
      context, CopyTensorsShapeAndType(
                   context, this_subgraph, TfLiteIntArrayView(node->inputs),
                   cond_subgraph, cond_subgraph->inputs(), true));
  TF_LITE_ENSURE_OK(context, cond_subgraph->AllocateTensors());
  TfLiteTensor* cond_output =
      cond_subgraph->tensor(cond_subgraph->outputs()[0]);
  // This should rarely happens. In most cases the output is static with shape
  // [1]. However theoretically intermediate tensors in the cond subgraph
  // can be dynamic.
  if (IsDynamicTensor(cond_output)) {
    op_data->cond_has_dynamic_output_tensors = true;
  } else {
    TF_LITE_ENSURE_STATUS(CheckCondOutput(context, cond_output));
  }

  // Prepare and check the body subgraph.
  TF_LITE_ENSURE_OK(
      context, CopyTensorsShapeAndType(
                   context, this_subgraph, TfLiteIntArrayView(node->inputs),
                   body_subgraph, body_subgraph->inputs(), true));
  TF_LITE_ENSURE_OK(context, body_subgraph->AllocateTensors());
  if (body_subgraph->HasDynamicTensors()) {
    op_data->body_has_dynamic_output_tensors = true;
  } else {
    for (int i = 0; i < num_inputs; ++i) {
      TfLiteTensor* body_input =
          body_subgraph->tensor(body_subgraph->inputs()[i]);
      TfLiteTensor* body_output =
          body_subgraph->tensor(body_subgraph->outputs()[i]);
      TF_LITE_ENSURE_TYPES_EQ(context, body_input->type, body_output->type);

      TF_LITE_ENSURE(context, !IsDynamicTensor(body_output));
      if (!TfLiteIntArrayEqual(body_input->dims, body_output->dims)) {
        // If the output shape of the body subgraph is static w.r.t. a fixed
        // input size, but it's different from input size, it's still considered
        // dynamic. For example: If a subgraph keeps padding its input with a
        // fixed padding, the output shape is static w.r.t the input shape and
        // padding, but running it in a loop will keep bloating the tensor.
        op_data->body_has_dynamic_output_tensors = true;
        break;
      }
    }
  }
  for (int i = 0; i < num_inputs; ++i) {
    TfLiteTensor* output;
    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));
    if (op_data->body_has_dynamic_output_tensors) {
      SetTensorToDynamic(output);
    } else {
      TfLiteTensor* body_output =
          body_subgraph->tensor(body_subgraph->outputs()[i]);
      TfLiteIntArray* output_size = TfLiteIntArrayCopy(body_output->dims);
      TF_LITE_ENSURE_OK(context,
                        context->ResizeTensor(context, output, output_size));
    }
  }
  return kTfLiteOk;
}","TfLiteStatus Prepare(TfLiteContext* VAR_0, TfLiteNode* VAR_1) {
  OpData* VAR_2 = VAR_3<OpData*>(VAR_1->user_data);
  int VAR_4 = VAR_1->inputs->size;
  /* COMMENT_0 */
  TF_LITE_ENSURE_EQ(VAR_0, VAR_1->outputs->size, VAR_4);

  /* COMMENT_1 */
  Subgraph* VAR_5 = VAR_3<Subgraph*>(VAR_0->impl_);
  auto* VAR_6 = VAR_5->GetSubgraphs();
  TF_LITE_ENSURE(VAR_0, VAR_2->cond_subgraph_index < VAR_6->size());
  TF_LITE_ENSURE(VAR_0, VAR_2->body_subgraph_index < VAR_6->size());
  TF_LITE_ENSURE(VAR_0,
                 VAR_2->cond_subgraph_index != VAR_2->body_subgraph_index);

  Subgraph* VAR_7 = (*VAR_6)[VAR_2->cond_subgraph_index].get();
  Subgraph* VAR_8 = (*VAR_6)[VAR_2->body_subgraph_index].get();

  /* COMMENT_2 */
  TF_LITE_ENSURE_EQ(VAR_0, VAR_7->inputs().size(), VAR_4);
  TF_LITE_ENSURE_EQ(VAR_0, VAR_7->outputs().size(), 1);

  /* COMMENT_3 */
  TF_LITE_ENSURE_EQ(VAR_0, VAR_8->inputs().size(), VAR_4);
  TF_LITE_ENSURE_EQ(VAR_0, VAR_8->outputs().size(), VAR_4);

  /* COMMENT_4 */
  TF_LITE_ENSURE_OK(
      VAR_0, CopyTensorsShapeAndType(
                   VAR_0, VAR_5, TfLiteIntArrayView(VAR_1->inputs),
                   VAR_7, VAR_7->inputs(), true));
  TF_LITE_ENSURE_OK(VAR_0, VAR_7->AllocateTensors());
  TfLiteTensor* VAR_9 =
      VAR_7->tensor(VAR_7->outputs()[0]);
  /* COMMENT_5 */
  /* COMMENT_6 */
  /* COMMENT_7 */
  if (IsDynamicTensor(VAR_9)) {
    VAR_2->cond_has_dynamic_output_tensors = true;
  } else {
    TF_LITE_ENSURE_STATUS(CheckCondOutput(VAR_0, VAR_9));
  }

  /* COMMENT_8 */
  TF_LITE_ENSURE_OK(
      VAR_0, CopyTensorsShapeAndType(
                   VAR_0, VAR_5, TfLiteIntArrayView(VAR_1->inputs),
                   VAR_8, VAR_8->inputs(), true));
  TF_LITE_ENSURE_OK(VAR_0, VAR_8->AllocateTensors());
  if (VAR_8->HasDynamicTensors()) {
    VAR_2->body_has_dynamic_output_tensors = true;
  } else {
    for (int VAR_10 = 0; VAR_10 < VAR_4; ++VAR_10) {
      TfLiteTensor* VAR_11 =
          VAR_8->tensor(VAR_8->inputs()[VAR_10]);
      TfLiteTensor* VAR_12 =
          VAR_8->tensor(VAR_8->outputs()[VAR_10]);
      TF_LITE_ENSURE_TYPES_EQ(VAR_0, VAR_11->type, VAR_12->type);

      TF_LITE_ENSURE(VAR_0, !IsDynamicTensor(VAR_12));
      if (!TfLiteIntArrayEqual(VAR_11->dims, VAR_12->dims)) {
        /* COMMENT_9 */
        /* COMMENT_10 */
        /* COMMENT_11 */
        /* COMMENT_12 */
        /* COMMENT_13 */
        VAR_2->body_has_dynamic_output_tensors = true;
        break;
      }
    }
  }
  for (int VAR_10 = 0; VAR_10 < VAR_4; ++VAR_10) {
    TfLiteTensor* VAR_13;
    TF_LITE_ENSURE_OK(VAR_0, GetOutputSafe(VAR_0, VAR_1, VAR_10, &VAR_13));
    if (VAR_2->body_has_dynamic_output_tensors) {
      SetTensorToDynamic(VAR_13);
    } else {
      TfLiteTensor* VAR_12 =
          VAR_8->tensor(VAR_8->outputs()[VAR_10]);
      TfLiteIntArray* VAR_14 = TfLiteIntArrayCopy(VAR_12->dims);
      TF_LITE_ENSURE_OK(VAR_0,
                        VAR_0->ResizeTensor(VAR_0, VAR_13, VAR_14));
    }
  }
  return VAR_15;
}",tensorflow/9c1dc920d8ffb4893d6c9d27d1f039607b326743/while.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,6 +9,8 @@
   auto* subgraphs = this_subgraph->GetSubgraphs();
   TF_LITE_ENSURE(context, op_data->cond_subgraph_index < subgraphs->size());
   TF_LITE_ENSURE(context, op_data->body_subgraph_index < subgraphs->size());
+  TF_LITE_ENSURE(context,
+                 op_data->cond_subgraph_index != op_data->body_subgraph_index);
 
   Subgraph* cond_subgraph = (*subgraphs)[op_data->cond_subgraph_index].get();
   Subgraph* body_subgraph = (*subgraphs)[op_data->body_subgraph_index].get();","{'deleted_lines': [], 'added_lines': ['  TF_LITE_ENSURE(context,', '                 op_data->cond_subgraph_index != op_data->body_subgraph_index);']}",True,"TensorFlow is an end-to-end open source platform for machine learning. TFlite graphs must not have loops between nodes. However, this condition was not checked and an attacker could craft models that would result in infinite loop during evaluation. In certain cases, the infinite loop would be replaced by stack overflow due to too many recursive calls. For example, the `While` implementation(https://github.com/tensorflow/tensorflow/blob/106d8f4fb89335a2c52d7c895b7a7485465ca8d9/tensorflow/lite/kernels/while.cc) could be tricked into a scneario where both the body and the loop subgraphs are the same. Evaluating one of the subgraphs means calling the `Eval` function for the other and this quickly exhaust all stack space. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range. Please consult our security guide(https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.",7.3,HIGH,2,valid,2021-04-28T00:47:46Z,3
CVE-2021-29599,['CWE-369'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"Prevent division by 0

PiperOrigin-RevId: 370998952
Change-Id: I6b1d49079624ee1447d2d9b53a8976fb356cc8f5",b22786e7e9b7bdb6a56936ff29cc7e9968d7bc1d,https://github.com/tensorflow/tensorflow/commit/b22786e7e9b7bdb6a56936ff29cc7e9968d7bc1d,tensorflow/lite/kernels/split.cc,ResizeOutputTensors,"TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,
const TfLiteTensor* axis,
const TfLiteTensor* input, int num_splits) {
int axis_value = GetTensorData<int>(axis)[0];
if (axis_value < 0) {
axis_value += NumDimensions(input);
}
TF_LITE_ENSURE(context, axis_value >= 0);
TF_LITE_ENSURE(context, axis_value < NumDimensions(input));
const int input_size = SizeOfDimension(input, axis_value);
TF_LITE_ENSURE_MSG(context, input_size % num_splits == 0,
""Not an even split"");
const int slice_size = input_size / num_splits;
for (int i = 0; i < NumOutputs(node); ++i) {
TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);
output_dims->data[axis_value] = slice_size;
TfLiteTensor* output;
TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));
TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims));
}
return kTfLiteOk;
}","TfLiteStatus ResizeOutputTensors(TfLiteContext* VAR_0, TfLiteNode* VAR_1,
const TfLiteTensor* VAR_2,
const TfLiteTensor* VAR_3, int VAR_4) {
int VAR_5 = VAR_6<int>(VAR_2)[0];
if (VAR_5 < 0) {
VAR_5 += NumDimensions(VAR_3);
}
TF_LITE_ENSURE(VAR_0, VAR_5 >= 0);
TF_LITE_ENSURE(VAR_0, VAR_5 < NumDimensions(VAR_3));
const int VAR_7 = SizeOfDimension(VAR_3, VAR_5);
TF_LITE_ENSURE_MSG(VAR_0, VAR_7 % VAR_4 == 0,
""Not an even split"");
const int VAR_8 = VAR_7 / VAR_4;
for (int VAR_9 = 0; VAR_9 < NumOutputs(VAR_1); ++VAR_9) {
TfLiteIntArray* VAR_10 = TfLiteIntArrayCopy(VAR_3->dims);
VAR_10->data[VAR_5] = VAR_8;
TfLiteTensor* VAR_11;
TF_LITE_ENSURE_OK(VAR_0, GetOutputSafe(VAR_0, VAR_1, VAR_9, &VAR_11));
TF_LITE_ENSURE_STATUS(VAR_0->ResizeTensor(VAR_0, VAR_11, VAR_10));
}
return VAR_12;
}",tensorflow/b22786e7e9b7bdb6a56936ff29cc7e9968d7bc1d/split.cc/vul/before/0.json,"TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,
                                 const TfLiteTensor* axis,
                                 const TfLiteTensor* input, int num_splits) {
  int axis_value = GetTensorData<int>(axis)[0];
  if (axis_value < 0) {
    axis_value += NumDimensions(input);
  }

  TF_LITE_ENSURE(context, axis_value >= 0);
  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));

  const int input_size = SizeOfDimension(input, axis_value);
  TF_LITE_ENSURE(context, num_splits != 0);
  TF_LITE_ENSURE_MSG(context, input_size % num_splits == 0,
                     ""Not an even split"");
  const int slice_size = input_size / num_splits;

  for (int i = 0; i < NumOutputs(node); ++i) {
    TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);
    output_dims->data[axis_value] = slice_size;
    TfLiteTensor* output;
    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));
    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims));
  }

  return kTfLiteOk;
}","TfLiteStatus ResizeOutputTensors(TfLiteContext* VAR_0, TfLiteNode* VAR_1,
                                 const TfLiteTensor* VAR_2,
                                 const TfLiteTensor* VAR_3, int VAR_4) {
  int VAR_5 = VAR_6<int>(VAR_2)[0];
  if (VAR_5 < 0) {
    VAR_5 += NumDimensions(VAR_3);
  }

  TF_LITE_ENSURE(VAR_0, VAR_5 >= 0);
  TF_LITE_ENSURE(VAR_0, VAR_5 < NumDimensions(VAR_3));

  const int VAR_7 = SizeOfDimension(VAR_3, VAR_5);
  TF_LITE_ENSURE(VAR_0, VAR_4 != 0);
  TF_LITE_ENSURE_MSG(VAR_0, VAR_7 % VAR_4 == 0,
                     ""Not an even split"");
  const int VAR_8 = VAR_7 / VAR_4;

  for (int VAR_9 = 0; VAR_9 < NumOutputs(VAR_1); ++VAR_9) {
    TfLiteIntArray* VAR_10 = TfLiteIntArrayCopy(VAR_3->dims);
    VAR_10->data[VAR_5] = VAR_8;
    TfLiteTensor* VAR_11;
    TF_LITE_ENSURE_OK(VAR_0, GetOutputSafe(VAR_0, VAR_1, VAR_9, &VAR_11));
    TF_LITE_ENSURE_STATUS(VAR_0->ResizeTensor(VAR_0, VAR_11, VAR_10));
  }

  return VAR_12;
}",tensorflow/b22786e7e9b7bdb6a56936ff29cc7e9968d7bc1d/split.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,6 +10,7 @@
   TF_LITE_ENSURE(context, axis_value < NumDimensions(input));
 
   const int input_size = SizeOfDimension(input, axis_value);
+  TF_LITE_ENSURE(context, num_splits != 0);
   TF_LITE_ENSURE_MSG(context, input_size % num_splits == 0,
                      ""Not an even split"");
   const int slice_size = input_size / num_splits;","{'deleted_lines': [], 'added_lines': ['  TF_LITE_ENSURE(context, num_splits != 0);']}",True,"TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `Split` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/e2752089ef7ce9bcf3db0ec618ebd23ea119d0c7/tensorflow/lite/kernels/split.cc#L63-L65). An attacker can craft a model such that `num_splits` would be 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",2.5,LOW,0,valid,2021-04-28T22:31:26Z,3
CVE-2021-29607,"['CWE-787', 'CWE-754']",AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"Fix OOB issue with `tf.raw_ops.SparseSparseMinimum`.

PiperOrigin-RevId: 371005787
Change-Id: Ib686ccc077836e8b980b8b5a03936d36a8ecaf71",ba6822bd7b7324ba201a28b2f278c29a98edbef2,https://github.com/tensorflow/tensorflow/commit/ba6822bd7b7324ba201a28b2f278c29a98edbef2,tensorflow/core/kernels/sparse_sparse_binary_op_shared.cc,Compute,"void Compute(OpKernelContext *ctx) override {
const Tensor *a_indices_t, *a_values_t, *a_shape_t, *b_indices_t,
*b_values_t, *b_shape_t;
OP_REQUIRES_OK(ctx, ctx->input(""a_indices"", &a_indices_t));
OP_REQUIRES_OK(ctx, ctx->input(""a_values"", &a_values_t));
OP_REQUIRES_OK(ctx, ctx->input(""a_shape"", &a_shape_t));
OP_REQUIRES_OK(ctx, ctx->input(""b_indices"", &b_indices_t));
OP_REQUIRES_OK(ctx, ctx->input(""b_values"", &b_values_t));
OP_REQUIRES_OK(ctx, ctx->input(""b_shape"", &b_shape_t));
OP_REQUIRES(
ctx,
TensorShapeUtils::IsMatrix(a_indices_t->shape()) &&
TensorShapeUtils::IsMatrix(b_indices_t->shape()),
errors::InvalidArgument(""Inputs a_indices and b_indices should be ""
""matrices but received shapes: "",
a_indices_t->shape().DebugString(), "", "",
b_indices_t->shape().DebugString()));
OP_REQUIRES(ctx,
TensorShapeUtils::IsVector(a_values_t->shape()) &&
TensorShapeUtils::IsVector(b_values_t->shape()),
errors::InvalidArgument(
""Inputs a_values and b_values should be vectors ""
""but received shapes: "",
a_values_t->shape().DebugString(), "" and "",
b_values_t->shape().DebugString()));
const int64 a_nnz = a_indices_t->dim_size(0);
const int64 b_nnz = b_indices_t->dim_size(0);
const auto a_values = a_values_t->vec<T>();
const auto b_values = b_values_t->vec<T>();
OP_REQUIRES(
ctx, a_values.size() == a_nnz && b_values.size() == b_nnz,
errors::InvalidArgument(""Expected "", a_nnz, "" and "", b_nnz,
"" non-empty input values, got "",
a_values.size(), "" and "", b_values.size()));
OP_REQUIRES(ctx,
TensorShapeUtils::IsVector(a_shape_t->shape()) &&
TensorShapeUtils::IsVector(b_shape_t->shape()),
errors::InvalidArgument(
""Input shapes should be a vector but received shapes "",
a_shape_t->shape().DebugString(), "" and "",
b_shape_t->shape().DebugString()));
OP_REQUIRES(ctx, a_shape_t->IsSameSize(*b_shape_t),
errors::InvalidArgument(
""Operands do not have the same ranks; got shapes: "",
a_shape_t->SummarizeValue(10), "" and "",
b_shape_t->SummarizeValue(10)));
const auto a_shape = a_shape_t->flat<int64>();
const auto b_shape = b_shape_t->flat<int64>();
for (int i = 0; i < a_shape_t->NumElements(); ++i) {
OP_REQUIRES(ctx, a_shape(i) == b_shape(i),
errors::InvalidArgument(""Operands' shapes do not match: got "",
a_shape(i), "" and "", b_shape(i),
"" for dimension "", i));
}
const int num_dims = a_indices_t->dim_size(1);
const auto a_indices_mat = a_indices_t->matrix<int64>();
const auto b_indices_mat = b_indices_t->matrix<int64>();
std::vector<T> a_augmented_values, b_augmented_values;
std::vector<std::pair<bool, int64>> entries_to_copy;      UnionSparseIndicesAndValues(a_indices_mat, a_values, a_nnz, b_indices_mat,
b_values, b_nnz, num_dims, &a_augmented_values,
&b_augmented_values, &entries_to_copy);
const int64 sum_nnz = a_augmented_values.size();
Tensor *output_indices_t, *output_values_t;
OP_REQUIRES_OK(ctx,
ctx->allocate_output(0, TensorShape({sum_nnz, num_dims}),
&output_indices_t));
OP_REQUIRES_OK(
ctx, ctx->allocate_output(1, TensorShape({sum_nnz}), &output_values_t));
auto output_indices_mat = output_indices_t->matrix<int64>();
for (int64 i = 0; i < sum_nnz; ++i) {
const bool from_a = entries_to_copy[i].first;
const int64 idx = entries_to_copy[i].second;
output_indices_mat.chip<0>(i) =
from_a ? a_indices_mat.chip<0>(idx) : b_indices_mat.chip<0>(idx);
}
using UnalignedTensorMap =
Eigen::TensorMap<Eigen::Tensor<const T, 1, Eigen::RowMajor>,
Eigen::Unaligned>;
auto a_augmented_values_t =
UnalignedTensorMap(a_augmented_values.data(), sum_nnz);
auto b_augmented_values_t =
UnalignedTensorMap(b_augmented_values.data(), sum_nnz);
output_values_t->flat<T>().device(ctx->eigen_device<Device>()) =
a_augmented_values_t.binaryExpr(b_augmented_values_t,
typename Functor::func());
}","void Compute(OpKernelContext *VAR_0) override {
const Tensor *VAR_1, *VAR_2, *VAR_3, *VAR_4,
*VAR_5, *VAR_6;
OP_REQUIRES_OK(VAR_0, VAR_0->input(""a_indices"", &VAR_1));
OP_REQUIRES_OK(VAR_0, VAR_0->input(""a_values"", &VAR_2));
OP_REQUIRES_OK(VAR_0, VAR_0->input(""a_shape"", &VAR_3));
OP_REQUIRES_OK(VAR_0, VAR_0->input(""b_indices"", &VAR_4));
OP_REQUIRES_OK(VAR_0, VAR_0->input(""b_values"", &VAR_5));
OP_REQUIRES_OK(VAR_0, VAR_0->input(""b_shape"", &VAR_6));
OP_REQUIRES(
VAR_0,
TensorShapeUtils::IsMatrix(VAR_1->shape()) &&
TensorShapeUtils::IsMatrix(VAR_4->shape()),
errors::InvalidArgument(""Inputs a_indices and b_indices should be ""
""matrices but received shapes: "",
VAR_1->shape().DebugString(), "", "",
VAR_4->shape().DebugString()));
OP_REQUIRES(VAR_0,
TensorShapeUtils::IsVector(VAR_2->shape()) &&
TensorShapeUtils::IsVector(VAR_5->shape()),
errors::InvalidArgument(
""Inputs a_values and b_values should be vectors ""
""but received shapes: "",
VAR_2->shape().DebugString(), "" and "",
VAR_5->shape().DebugString()));
const int64 VAR_7 = VAR_1->dim_size(0);
const int64 VAR_8 = VAR_4->dim_size(0);
const auto VAR_9 = VAR_2->vec<T>();
const auto VAR_10 = VAR_5->vec<T>();
OP_REQUIRES(
VAR_0, VAR_9.size() == VAR_7 && VAR_10.size() == VAR_8,
errors::InvalidArgument(""Expected "", VAR_7, "" and "", VAR_8,
"" non-empty input values, got "",
VAR_9.size(), "" and "", VAR_10.size()));
OP_REQUIRES(VAR_0,
TensorShapeUtils::IsVector(VAR_3->shape()) &&
TensorShapeUtils::IsVector(VAR_6->shape()),
errors::InvalidArgument(
""Input shapes should be a vector but received shapes "",
VAR_3->shape().DebugString(), "" and "",
VAR_6->shape().DebugString()));
OP_REQUIRES(VAR_0, VAR_3->IsSameSize(*VAR_6),
errors::InvalidArgument(
""Operands do not have the same ranks; got shapes: "",
VAR_3->SummarizeValue(10), "" and "",
VAR_6->SummarizeValue(10)));
const auto VAR_11 = VAR_3->flat<int64>();
const auto VAR_12 = VAR_6->flat<int64>();
for (int VAR_13 = 0; VAR_13 < VAR_3->NumElements(); ++VAR_13) {
OP_REQUIRES(VAR_0, VAR_11(VAR_13) == VAR_12(VAR_13),
errors::InvalidArgument(""Operands' shapes do not match: got "",
VAR_11(VAR_13), "" and "", VAR_12(VAR_13),
"" for dimension "", VAR_13));
}
const int VAR_14 = VAR_1->dim_size(1);
const auto VAR_15 = VAR_1->matrix<int64>();
const auto VAR_16 = VAR_4->matrix<int64>();
std::vector<T> VAR_17, VAR_18;
std::vector<std::pair<bool, int64>> VAR_19;  
UnionSparseIndicesAndValues(VAR_15, VAR_9, VAR_7, VAR_16,
VAR_10, VAR_8, VAR_14, &VAR_17,
&VAR_18, &VAR_19);
const int64 VAR_20 = VAR_17.size();
Tensor *VAR_21, *VAR_22;
OP_REQUIRES_OK(VAR_0,
VAR_0->allocate_output(0, TensorShape({VAR_20, VAR_14}),
&VAR_21));
OP_REQUIRES_OK(
VAR_0, VAR_0->allocate_output(1, TensorShape({VAR_20}), &VAR_22));
auto VAR_23 = VAR_21->matrix<int64>();
for (int64 VAR_13 = 0; VAR_13 < VAR_20; ++VAR_13) {
const bool VAR_24 = VAR_19[VAR_13].first;
const int64 VAR_25 = VAR_19[VAR_13].second;
VAR_23.chip<0>(VAR_13) =
VAR_24 ? VAR_15.chip<0>(VAR_25) : VAR_16.chip<0>(VAR_25);
}
using UnalignedTensorMap =
Eigen::TensorMap<Eigen::Tensor<const T, 1, Eigen::RowMajor>,
Eigen::Unaligned>;
auto VAR_26 =
UnalignedTensorMap(VAR_17.data(), VAR_20);
auto VAR_27 =
UnalignedTensorMap(VAR_18.data(), VAR_20);
VAR_22->flat<T>().device(VAR_0->eigen_device<Device>()) =
VAR_26.binaryExpr(VAR_27,
VAR_28 Functor::func());
}",,"void Compute(OpKernelContext *ctx) override {
    const Tensor *a_indices_t, *a_values_t, *a_shape_t, *b_indices_t,
        *b_values_t, *b_shape_t;
    OP_REQUIRES_OK(ctx, ctx->input(""a_indices"", &a_indices_t));
    OP_REQUIRES_OK(ctx, ctx->input(""a_values"", &a_values_t));
    OP_REQUIRES_OK(ctx, ctx->input(""a_shape"", &a_shape_t));
    OP_REQUIRES_OK(ctx, ctx->input(""b_indices"", &b_indices_t));
    OP_REQUIRES_OK(ctx, ctx->input(""b_values"", &b_values_t));
    OP_REQUIRES_OK(ctx, ctx->input(""b_shape"", &b_shape_t));

    // Validations.
    OP_REQUIRES(
        ctx,
        TensorShapeUtils::IsMatrix(a_indices_t->shape()) &&
            TensorShapeUtils::IsMatrix(b_indices_t->shape()),
        errors::InvalidArgument(""Inputs a_indices and b_indices should be ""
                                ""matrices but received shapes: "",
                                a_indices_t->shape().DebugString(), "", "",
                                b_indices_t->shape().DebugString()));
    OP_REQUIRES(ctx,
                TensorShapeUtils::IsVector(a_values_t->shape()) &&
                    TensorShapeUtils::IsVector(b_values_t->shape()),
                errors::InvalidArgument(
                    ""Inputs a_values and b_values should be vectors ""
                    ""but received shapes: "",
                    a_values_t->shape().DebugString(), "" and "",
                    b_values_t->shape().DebugString()));

    const int64 a_nnz = a_indices_t->dim_size(0);
    const int64 b_nnz = b_indices_t->dim_size(0);
    const auto a_values = a_values_t->vec<T>();
    const auto b_values = b_values_t->vec<T>();

    OP_REQUIRES(
        ctx, a_values.size() == a_nnz && b_values.size() == b_nnz,
        errors::InvalidArgument(""Expected "", a_nnz, "" and "", b_nnz,
                                "" non-empty input values, got "",
                                a_values.size(), "" and "", b_values.size()));

    OP_REQUIRES(ctx,
                TensorShapeUtils::IsVector(a_shape_t->shape()) &&
                    TensorShapeUtils::IsVector(b_shape_t->shape()),
                errors::InvalidArgument(
                    ""Input shapes should be a vector but received shapes "",
                    a_shape_t->shape().DebugString(), "" and "",
                    b_shape_t->shape().DebugString()));
    OP_REQUIRES(ctx, a_shape_t->IsSameSize(*b_shape_t),
                errors::InvalidArgument(
                    ""Operands do not have the same ranks; got shapes: "",
                    a_shape_t->SummarizeValue(10), "" and "",
                    b_shape_t->SummarizeValue(10)));
    const auto a_shape = a_shape_t->flat<int64>();
    const auto b_shape = b_shape_t->flat<int64>();
    for (int i = 0; i < a_shape_t->NumElements(); ++i) {
      OP_REQUIRES(ctx, a_shape(i) == b_shape(i),
                  errors::InvalidArgument(""Operands' shapes do not match: got "",
                                          a_shape(i), "" and "", b_shape(i),
                                          "" for dimension "", i));
    }

    OP_REQUIRES(
        ctx, a_indices_t->dim_size(1) == b_indices_t->dim_size(1),
        errors::InvalidArgument(
            ""Indices' dimensions do not match: got "", a_indices_t->dim_size(1),
            "" and "", b_indices_t->dim_size(1), "" for the second dimension.""));
    const int num_dims = a_indices_t->dim_size(1);
    const auto a_indices_mat = a_indices_t->matrix<int64>();
    const auto b_indices_mat = b_indices_t->matrix<int64>();
    std::vector<T> a_augmented_values, b_augmented_values;
    std::vector<std::pair<bool, int64>> entries_to_copy;  // from_a?, idx
    UnionSparseIndicesAndValues(a_indices_mat, a_values, a_nnz, b_indices_mat,
                                b_values, b_nnz, num_dims, &a_augmented_values,
                                &b_augmented_values, &entries_to_copy);

    // Allocates and fills output tensors.
    const int64 sum_nnz = a_augmented_values.size();
    Tensor *output_indices_t, *output_values_t;
    OP_REQUIRES_OK(ctx,
                   ctx->allocate_output(0, TensorShape({sum_nnz, num_dims}),
                                        &output_indices_t));
    OP_REQUIRES_OK(
        ctx, ctx->allocate_output(1, TensorShape({sum_nnz}), &output_values_t));
    auto output_indices_mat = output_indices_t->matrix<int64>();

    for (int64 i = 0; i < sum_nnz; ++i) {
      const bool from_a = entries_to_copy[i].first;
      const int64 idx = entries_to_copy[i].second;
      output_indices_mat.chip<0>(i) =
          from_a ? a_indices_mat.chip<0>(idx) : b_indices_mat.chip<0>(idx);
    }

    // Performs the functor operation using Eigen.
    //
    // Note that the two stack-allocated std::vector's may not be aligned. Using
    // allocate_temp() would've given us aligned storage, but we do not know
    // their sizes in advance, so we couldn't use allocate_temp() anyway.
    //
    // TODO(zongheng): measure if it's worthwhile to somehow force alignment.
    using UnalignedTensorMap =
        Eigen::TensorMap<Eigen::Tensor<const T, 1, Eigen::RowMajor>,
                         Eigen::Unaligned>;
    auto a_augmented_values_t =
        UnalignedTensorMap(a_augmented_values.data(), sum_nnz);
    auto b_augmented_values_t =
        UnalignedTensorMap(b_augmented_values.data(), sum_nnz);
    output_values_t->flat<T>().device(ctx->eigen_device<Device>()) =
        a_augmented_values_t.binaryExpr(b_augmented_values_t,
                                        typename Functor::func());
  }","void Compute(OpKernelContext *VAR_0) override {
    const Tensor *VAR_1, *VAR_2, *VAR_3, *VAR_4,
        *VAR_5, *VAR_6;
    OP_REQUIRES_OK(VAR_0, VAR_0->input(""a_indices"", &VAR_1));
    OP_REQUIRES_OK(VAR_0, VAR_0->input(""a_values"", &VAR_2));
    OP_REQUIRES_OK(VAR_0, VAR_0->input(""a_shape"", &VAR_3));
    OP_REQUIRES_OK(VAR_0, VAR_0->input(""b_indices"", &VAR_4));
    OP_REQUIRES_OK(VAR_0, VAR_0->input(""b_values"", &VAR_5));
    OP_REQUIRES_OK(VAR_0, VAR_0->input(""b_shape"", &VAR_6));

    /* COMMENT_0 */
    OP_REQUIRES(
        VAR_0,
        TensorShapeUtils::IsMatrix(VAR_1->shape()) &&
            TensorShapeUtils::IsMatrix(VAR_4->shape()),
        errors::InvalidArgument(""Inputs a_indices and b_indices should be ""
                                ""matrices but received shapes: "",
                                VAR_1->shape().DebugString(), "", "",
                                VAR_4->shape().DebugString()));
    OP_REQUIRES(VAR_0,
                TensorShapeUtils::IsVector(VAR_2->shape()) &&
                    TensorShapeUtils::IsVector(VAR_5->shape()),
                errors::InvalidArgument(
                    ""Inputs a_values and b_values should be vectors ""
                    ""but received shapes: "",
                    VAR_2->shape().DebugString(), "" and "",
                    VAR_5->shape().DebugString()));

    const int64 VAR_7 = VAR_1->dim_size(0);
    const int64 VAR_8 = VAR_4->dim_size(0);
    const auto VAR_9 = VAR_2->vec<T>();
    const auto VAR_10 = VAR_5->vec<T>();

    OP_REQUIRES(
        VAR_0, VAR_9.size() == VAR_7 && VAR_10.size() == VAR_8,
        errors::InvalidArgument(""Expected "", VAR_7, "" and "", VAR_8,
                                "" non-empty input values, got "",
                                VAR_9.size(), "" and "", VAR_10.size()));

    OP_REQUIRES(VAR_0,
                TensorShapeUtils::IsVector(VAR_3->shape()) &&
                    TensorShapeUtils::IsVector(VAR_6->shape()),
                errors::InvalidArgument(
                    ""Input shapes should be a vector but received shapes "",
                    VAR_3->shape().DebugString(), "" and "",
                    VAR_6->shape().DebugString()));
    OP_REQUIRES(VAR_0, VAR_3->IsSameSize(*VAR_6),
                errors::InvalidArgument(
                    ""Operands do not have the same ranks; got shapes: "",
                    VAR_3->SummarizeValue(10), "" and "",
                    VAR_6->SummarizeValue(10)));
    const auto VAR_11 = VAR_3->flat<int64>();
    const auto VAR_12 = VAR_6->flat<int64>();
    for (int VAR_13 = 0; VAR_13 < VAR_3->NumElements(); ++VAR_13) {
      OP_REQUIRES(VAR_0, VAR_11(VAR_13) == VAR_12(VAR_13),
                  errors::InvalidArgument(""Operands' shapes do not match: got "",
                                          VAR_11(VAR_13), "" and "", VAR_12(VAR_13),
                                          "" for dimension "", VAR_13));
    }

    OP_REQUIRES(
        VAR_0, VAR_1->dim_size(1) == VAR_4->dim_size(1),
        errors::InvalidArgument(
            ""Indices' dimensions do not match: got "", VAR_1->dim_size(1),
            "" and "", VAR_4->dim_size(1), "" for the second dimension.""));
    const int VAR_14 = VAR_1->dim_size(1);
    const auto VAR_15 = VAR_1->matrix<int64>();
    const auto VAR_16 = VAR_4->matrix<int64>();
    std::vector<T> VAR_17, VAR_18;
    std::vector<std::pair<bool, int64>> VAR_19;  /* COMMENT_1 */
    UnionSparseIndicesAndValues(VAR_15, VAR_9, VAR_7, VAR_16,
                                VAR_10, VAR_8, VAR_14, &VAR_17,
                                &VAR_18, &VAR_19);

    /* COMMENT_2 */
    const int64 VAR_20 = VAR_17.size();
    Tensor *VAR_21, *VAR_22;
    OP_REQUIRES_OK(VAR_0,
                   VAR_0->allocate_output(0, TensorShape({VAR_20, VAR_14}),
                                        &VAR_21));
    OP_REQUIRES_OK(
        VAR_0, VAR_0->allocate_output(1, TensorShape({VAR_20}), &VAR_22));
    auto VAR_23 = VAR_21->matrix<int64>();

    for (int64 VAR_13 = 0; VAR_13 < VAR_20; ++VAR_13) {
      const bool VAR_24 = VAR_19[VAR_13].first;
      const int64 VAR_25 = VAR_19[VAR_13].second;
      VAR_23.chip<0>(VAR_13) =
          VAR_24 ? VAR_15.chip<0>(VAR_25) : VAR_16.chip<0>(VAR_25);
    }

    /* COMMENT_3 */
    /* COMMENT_4 */
    /* COMMENT_5 */
    /* COMMENT_6 */
    /* COMMENT_7 */
    /* COMMENT_4 */
    /* COMMENT_8 */
    using UnalignedTensorMap =
        Eigen::TensorMap<Eigen::Tensor<const T, 1, Eigen::RowMajor>,
                         Eigen::Unaligned>;
    auto VAR_26 =
        UnalignedTensorMap(VAR_17.data(), VAR_20);
    auto VAR_27 =
        UnalignedTensorMap(VAR_18.data(), VAR_20);
    VAR_22->flat<T>().device(VAR_0->eigen_device<Device>()) =
        VAR_26.binaryExpr(VAR_27,
                                        VAR_28 Functor::func());
  }",,"--- func_before
+++ func_after
@@ -58,6 +58,11 @@
                                           "" for dimension "", i));
     }
 
+    OP_REQUIRES(
+        ctx, a_indices_t->dim_size(1) == b_indices_t->dim_size(1),
+        errors::InvalidArgument(
+            ""Indices' dimensions do not match: got "", a_indices_t->dim_size(1),
+            "" and "", b_indices_t->dim_size(1), "" for the second dimension.""));
     const int num_dims = a_indices_t->dim_size(1);
     const auto a_indices_mat = a_indices_t->matrix<int64>();
     const auto b_indices_mat = b_indices_t->matrix<int64>();","{'deleted_lines': [], 'added_lines': ['    OP_REQUIRES(', '        ctx, a_indices_t->dim_size(1) == b_indices_t->dim_size(1),', '        errors::InvalidArgument(', '            ""Indices\' dimensions do not match: got "", a_indices_t->dim_size(1),', '            "" and "", b_indices_t->dim_size(1), "" for the second dimension.""));']}",True,"TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseAdd` results in allowing attackers to exploit undefined behavior (dereferencing null pointers) as well as write outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/sparse_sparse_binary_op_shared.cc) has a large set of validation for the two sparse tensor inputs (6 tensors in total), but does not validate that the tensors are not empty or that the second dimension of `*_indices` matches the size of corresponding `*_shape`. This allows attackers to send tensor triples that represent invalid sparse tensors to abuse code assumptions that are not protected by validation. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",5.3,MEDIUM,1,valid,2021-04-28T23:06:54Z,3
CVE-2021-29601,['CWE-190'],AV:L/AC:L/Au:N/C:N/I:P/A:P,0,tensorflow,"Fix integer overflow in TFLite concat

PiperOrigin-RevId: 371013841
Change-Id: I6a4782ce7ca753e23ff31e7fb6aeb7f9d412cd29",4253f96a58486ffe84b61c0415bb234a4632ee73,https://github.com/tensorflow/tensorflow/commit/4253f96a58486ffe84b61c0415bb234a4632ee73,tensorflow/lite/kernels/concatenation.cc,Prepare,"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
auto* params =
reinterpret_cast<TfLiteConcatenationParams*>(node->builtin_data);
int axis = params->axis;
int num_inputs = node->inputs->size;
const TfLiteTensor* t0;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &t0));
TfLiteType input_type = t0->type;
if (axis < 0) axis += t0->dims->size;
TF_LITE_ENSURE(context, axis >= 0);
TF_LITE_ENSURE(context, axis < t0->dims->size);
TF_LITE_ENSURE_EQ(context, params->activation, kTfLiteActNone);
TF_LITE_ENSURE(context,
input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 ||
input_type == kTfLiteInt8 || input_type == kTfLiteInt16 ||
input_type == kTfLiteInt32 || input_type == kTfLiteInt64 ||
input_type == kTfLiteBool);
int sum_axis = t0->dims->data[axis];
for (int i = 1; i < num_inputs; ++i) {
const TfLiteTensor* t;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &t));
TF_LITE_ENSURE_EQ(context, t->dims->size, t0->dims->size);
TF_LITE_ENSURE_EQ(context, t->type, input_type);
for (int d = 0; d < t0->dims->size; ++d) {
if (d == axis) {
sum_axis += t->dims->data[axis];
} else {
TF_LITE_ENSURE_EQ(context, t->dims->data[d], t0->dims->data[d]);
}
}
}
TfLiteIntArray* output_size = TfLiteIntArrayCreate(t0->dims->size);
for (int d = 0; d < t0->dims->size; ++d) {
output_size->data[d] = (d == axis) ? sum_axis : t0->dims->data[d];
}
TfLiteTensor* output;
TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));
TF_LITE_ENSURE_TYPES_EQ(context, output->type, input_type);
if (input_type == kTfLiteInt8) {
VectorOfTensors<int8_t> all_inputs(*context, *node->inputs);
for (int i = 0; i < node->inputs->size; ++i) {
const TfLiteTensor* t;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &t));
TF_LITE_ENSURE_EQ(context, t->params.scale, output->params.scale);
TF_LITE_ENSURE_EQ(context, t->params.zero_point,
output->params.zero_point);
}
}
if (input_type == kTfLiteInt16) {
for (int i = 0; i < node->inputs->size; ++i) {
const TfLiteTensor* t = GetInput(context, node, i);
TF_LITE_ENSURE_EQ(context, t->params.zero_point, 0);
}
TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);
}
return context->ResizeTensor(context, output, output_size);
}","TfLiteStatus Prepare(TfLiteContext* VAR_0, TfLiteNode* VAR_1) {
auto* VAR_2 =
VAR_3<TfLiteConcatenationParams*>(VAR_1->builtin_data);
int VAR_4 = VAR_2->axis;
int VAR_5 = VAR_1->inputs->size;
const TfLiteTensor* VAR_6;
TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, 0, &VAR_6));
TfLiteType VAR_7 = VAR_6->type;
if (VAR_4 < 0) VAR_4 += VAR_6->dims->size;
TF_LITE_ENSURE(VAR_0, VAR_4 >= 0);
TF_LITE_ENSURE(VAR_0, VAR_4 < VAR_6->dims->size);
TF_LITE_ENSURE_EQ(VAR_0, VAR_2->activation, VAR_8);
TF_LITE_ENSURE(VAR_0,
VAR_7 == VAR_9 || VAR_7 == VAR_10 ||
VAR_7 == VAR_11 || VAR_7 == VAR_12 ||
VAR_7 == VAR_13 || VAR_7 == VAR_14 ||
VAR_7 == VAR_15);
int VAR_16 = VAR_6->dims->data[VAR_4];
for (int VAR_17 = 1; VAR_17 < VAR_5; ++VAR_17) {
const TfLiteTensor* VAR_18;
TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_17, &VAR_18));
TF_LITE_ENSURE_EQ(VAR_0, VAR_18->dims->size, VAR_6->dims->size);
TF_LITE_ENSURE_EQ(VAR_0, VAR_18->type, VAR_7);
for (int VAR_19 = 0; VAR_19 < VAR_6->dims->size; ++VAR_19) {
if (VAR_19 == VAR_4) {
VAR_16 += VAR_18->dims->data[VAR_4];
} else {
TF_LITE_ENSURE_EQ(VAR_0, VAR_18->dims->data[VAR_19], VAR_6->dims->data[VAR_19]);
}
}
}
TfLiteIntArray* VAR_20 = TfLiteIntArrayCreate(VAR_6->dims->size);
for (int VAR_19 = 0; VAR_19 < VAR_6->dims->size; ++VAR_19) {
VAR_20->data[VAR_19] = (VAR_19 == VAR_4) ? VAR_16 : VAR_6->dims->data[VAR_19];
}
TfLiteTensor* VAR_21;
TF_LITE_ENSURE_OK(VAR_0, GetOutputSafe(VAR_0, VAR_1, 0, &VAR_21));
TF_LITE_ENSURE_TYPES_EQ(VAR_0, VAR_21->type, VAR_7);
if (VAR_7 == VAR_11) {
VectorOfTensors<int8_t> VAR_22(*VAR_0, *VAR_1->inputs);
for (int VAR_17 = 0; VAR_17 < VAR_1->inputs->size; ++VAR_17) {
const TfLiteTensor* VAR_18;
TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_17, &VAR_18));
TF_LITE_ENSURE_EQ(VAR_0, VAR_18->params.scale, VAR_21->params.scale);
TF_LITE_ENSURE_EQ(VAR_0, VAR_18->params.zero_point,
VAR_21->params.zero_point);
}
}
if (VAR_7 == VAR_12) {
for (int VAR_17 = 0; VAR_17 < VAR_1->inputs->size; ++VAR_17) {
const TfLiteTensor* VAR_18 = GetInput(VAR_0, VAR_1, VAR_17);
TF_LITE_ENSURE_EQ(VAR_0, VAR_18->params.zero_point, 0);
}
TF_LITE_ENSURE_EQ(VAR_0, VAR_21->params.zero_point, 0);
}
return VAR_0->ResizeTensor(VAR_0, VAR_21, VAR_20);
}",tensorflow/4253f96a58486ffe84b61c0415bb234a4632ee73/concatenation.cc/vul/before/0.json,"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
  auto* params =
      reinterpret_cast<TfLiteConcatenationParams*>(node->builtin_data);
  int axis = params->axis;
  int num_inputs = node->inputs->size;

  // The number of dimensions of the input tensors must match, and all
  // dimensions except 'axis' must be equal.
  const TfLiteTensor* t0;
  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &t0));
  TfLiteType input_type = t0->type;
  if (axis < 0) axis += t0->dims->size;
  TF_LITE_ENSURE(context, axis >= 0);
  TF_LITE_ENSURE(context, axis < t0->dims->size);

  TF_LITE_ENSURE_EQ(context, params->activation, kTfLiteActNone);
  TF_LITE_ENSURE(context,
                 input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 ||
                     input_type == kTfLiteInt8 || input_type == kTfLiteInt16 ||
                     input_type == kTfLiteInt32 || input_type == kTfLiteInt64 ||
                     input_type == kTfLiteBool);

  // Output dimensions will match input dimensions, except 'axis', which
  // will be the sum of inputs
  int sum_axis = t0->dims->data[axis];
  for (int i = 1; i < num_inputs; ++i) {
    const TfLiteTensor* t;
    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &t));
    TF_LITE_ENSURE_EQ(context, t->dims->size, t0->dims->size);
    TF_LITE_ENSURE_EQ(context, t->type, input_type);
    for (int d = 0; d < t0->dims->size; ++d) {
      if (d == axis) {
        // Avoid integer overflow in sum_axis below
        TF_LITE_ENSURE(context, t->dims->data[axis] >= 0);
        TF_LITE_ENSURE(context, t->dims->data[axis] <=
                                    std::numeric_limits<int>::max() - sum_axis);
        sum_axis += t->dims->data[axis];
      } else {
        TF_LITE_ENSURE_EQ(context, t->dims->data[d], t0->dims->data[d]);
      }
    }
  }

  TfLiteIntArray* output_size = TfLiteIntArrayCreate(t0->dims->size);
  for (int d = 0; d < t0->dims->size; ++d) {
    output_size->data[d] = (d == axis) ? sum_axis : t0->dims->data[d];
  }

  TfLiteTensor* output;
  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));
  TF_LITE_ENSURE_TYPES_EQ(context, output->type, input_type);

  if (input_type == kTfLiteInt8) {
    // Make sure there is no re-scaling needed for Int8 quantized kernel. This
    // is a restriction we introduced to Int8 kernels.
    VectorOfTensors<int8_t> all_inputs(*context, *node->inputs);
    for (int i = 0; i < node->inputs->size; ++i) {
      const TfLiteTensor* t;
      TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &t));
      TF_LITE_ENSURE_EQ(context, t->params.scale, output->params.scale);
      TF_LITE_ENSURE_EQ(context, t->params.zero_point,
                        output->params.zero_point);
    }
  }

  if (input_type == kTfLiteInt16) {
    // Make sure that all Int16 inputs have a null zero-point.
    for (int i = 0; i < node->inputs->size; ++i) {
      const TfLiteTensor* t = GetInput(context, node, i);
      TF_LITE_ENSURE_EQ(context, t->params.zero_point, 0);
    }
    TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);
  }

  return context->ResizeTensor(context, output, output_size);
}","TfLiteStatus Prepare(TfLiteContext* VAR_0, TfLiteNode* VAR_1) {
  auto* VAR_2 =
      VAR_3<TfLiteConcatenationParams*>(VAR_1->builtin_data);
  int VAR_4 = VAR_2->axis;
  int VAR_5 = VAR_1->inputs->size;

  /* COMMENT_0 */
  /* COMMENT_1 */
  const TfLiteTensor* VAR_6;
  TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, 0, &VAR_6));
  TfLiteType VAR_7 = VAR_6->type;
  if (VAR_4 < 0) VAR_4 += VAR_6->dims->size;
  TF_LITE_ENSURE(VAR_0, VAR_4 >= 0);
  TF_LITE_ENSURE(VAR_0, VAR_4 < VAR_6->dims->size);

  TF_LITE_ENSURE_EQ(VAR_0, VAR_2->activation, VAR_8);
  TF_LITE_ENSURE(VAR_0,
                 VAR_7 == VAR_9 || VAR_7 == VAR_10 ||
                     VAR_7 == VAR_11 || VAR_7 == VAR_12 ||
                     VAR_7 == VAR_13 || VAR_7 == VAR_14 ||
                     VAR_7 == VAR_15);

  /* COMMENT_2 */
  /* COMMENT_3 */
  int VAR_16 = VAR_6->dims->data[VAR_4];
  for (int VAR_17 = 1; VAR_17 < VAR_5; ++VAR_17) {
    const TfLiteTensor* VAR_18;
    TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_17, &VAR_18));
    TF_LITE_ENSURE_EQ(VAR_0, VAR_18->dims->size, VAR_6->dims->size);
    TF_LITE_ENSURE_EQ(VAR_0, VAR_18->type, VAR_7);
    for (int VAR_19 = 0; VAR_19 < VAR_6->dims->size; ++VAR_19) {
      if (VAR_19 == VAR_4) {
        /* COMMENT_4 */
        TF_LITE_ENSURE(VAR_0, VAR_18->dims->data[VAR_4] >= 0);
        TF_LITE_ENSURE(VAR_0, VAR_18->dims->data[VAR_4] <=
                                    std::numeric_limits<int>::max() - VAR_16);
        VAR_16 += VAR_18->dims->data[VAR_4];
      } else {
        TF_LITE_ENSURE_EQ(VAR_0, VAR_18->dims->data[VAR_19], VAR_6->dims->data[VAR_19]);
      }
    }
  }

  TfLiteIntArray* VAR_20 = TfLiteIntArrayCreate(VAR_6->dims->size);
  for (int VAR_19 = 0; VAR_19 < VAR_6->dims->size; ++VAR_19) {
    VAR_20->data[VAR_19] = (VAR_19 == VAR_4) ? VAR_16 : VAR_6->dims->data[VAR_19];
  }

  TfLiteTensor* VAR_21;
  TF_LITE_ENSURE_OK(VAR_0, GetOutputSafe(VAR_0, VAR_1, 0, &VAR_21));
  TF_LITE_ENSURE_TYPES_EQ(VAR_0, VAR_21->type, VAR_7);

  if (VAR_7 == VAR_11) {
    /* COMMENT_5 */
    /* COMMENT_6 */
    VectorOfTensors<int8_t> VAR_22(*VAR_0, *VAR_1->inputs);
    for (int VAR_17 = 0; VAR_17 < VAR_1->inputs->size; ++VAR_17) {
      const TfLiteTensor* VAR_18;
      TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_17, &VAR_18));
      TF_LITE_ENSURE_EQ(VAR_0, VAR_18->params.scale, VAR_21->params.scale);
      TF_LITE_ENSURE_EQ(VAR_0, VAR_18->params.zero_point,
                        VAR_21->params.zero_point);
    }
  }

  if (VAR_7 == VAR_12) {
    /* COMMENT_7 */
    for (int VAR_17 = 0; VAR_17 < VAR_1->inputs->size; ++VAR_17) {
      const TfLiteTensor* VAR_18 = GetInput(VAR_0, VAR_1, VAR_17);
      TF_LITE_ENSURE_EQ(VAR_0, VAR_18->params.zero_point, 0);
    }
    TF_LITE_ENSURE_EQ(VAR_0, VAR_21->params.zero_point, 0);
  }

  return VAR_0->ResizeTensor(VAR_0, VAR_21, VAR_20);
}",tensorflow/4253f96a58486ffe84b61c0415bb234a4632ee73/concatenation.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -30,6 +30,10 @@
     TF_LITE_ENSURE_EQ(context, t->type, input_type);
     for (int d = 0; d < t0->dims->size; ++d) {
       if (d == axis) {
+        // Avoid integer overflow in sum_axis below
+        TF_LITE_ENSURE(context, t->dims->data[axis] >= 0);
+        TF_LITE_ENSURE(context, t->dims->data[axis] <=
+                                    std::numeric_limits<int>::max() - sum_axis);
         sum_axis += t->dims->data[axis];
       } else {
         TF_LITE_ENSURE_EQ(context, t->dims->data[d], t0->dims->data[d]);","{'deleted_lines': [], 'added_lines': ['        // Avoid integer overflow in sum_axis below', '        TF_LITE_ENSURE(context, t->dims->data[axis] >= 0);', '        TF_LITE_ENSURE(context, t->dims->data[axis] <=', '                                    std::numeric_limits<int>::max() - sum_axis);']}",True,"TensorFlow is an end-to-end open source platform for machine learning. The TFLite implementation of concatenation is vulnerable to an integer overflow issue(https://github.com/tensorflow/tensorflow/blob/7b7352a724b690b11bfaae2cd54bc3907daf6285/tensorflow/lite/kernels/concatenation.cc#L70-L76). An attacker can craft a model such that the dimensions of one of the concatenation input overflow the values of `int`. TFLite uses `int` to represent tensor dimensions, whereas TF uses `int64`. Hence, valid TF models can trigger an integer overflow when converted to TFLite format. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",6.3,MEDIUM,1,valid,2021-04-28T23:50:55Z,3
CVE-2021-29605,['CWE-190'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,tensorflow,"Fix a dangerous integer overflow and a malloc of negative size.

PiperOrigin-RevId: 371254154
Change-Id: I250a98a3df26328770167025670235a963a72da0",7c8cc4ec69cd348e44ad6a2699057ca88faad3e5,https://github.com/tensorflow/tensorflow/commit/7c8cc4ec69cd348e44ad6a2699057ca88faad3e5,tensorflow/lite/kernels/embedding_lookup_sparse.cc,Eval,"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
auto* params =
reinterpret_cast<TfLiteEmbeddingLookupSparseParams*>(node->builtin_data);
TfLiteTensor* output;
TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));
const TfLiteTensor* ids;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &ids));
const TfLiteTensor* indices;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &indices));
const TfLiteTensor* dense_shape;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &dense_shape));
const TfLiteTensor* weights;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 3, &weights));
const TfLiteTensor* value;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 4, &value));
const int lookup_rank = SizeOfDimension(indices, 1);
const int embedding_rank = NumDimensions(value);
const int num_lookups = SizeOfDimension(ids, 0);
const int num_rows = SizeOfDimension(value, 0);
const int output_rank = (lookup_rank - 1) + (embedding_rank - 1);
TF_LITE_ENSURE_EQ(context, SizeOfDimension(dense_shape, 0), lookup_rank);
TfLiteIntArray* output_shape = TfLiteIntArrayCreate(output_rank);
int k = 0;
int embedding_size = 1;
int lookup_size = 1;
for (int i = 0; i < lookup_rank - 1; i++, k++) {
const int dim = dense_shape->data.i32[i];
lookup_size *= dim;
output_shape->data[k] = dim;
}
for (int i = 1; i < embedding_rank; i++, k++) {
const int dim = SizeOfDimension(value, i);
embedding_size *= dim;
output_shape->data[k] = dim;
}
TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_shape));
const int output_size = lookup_size * embedding_size;
TfLiteTensorRealloc(output_size * sizeof(float), output);
float* output_ptr = GetTensorData<float>(output);
const float* weights_ptr = GetTensorData<float>(weights);
const float* value_ptr = GetTensorData<float>(value);
std::fill_n(output_ptr, output_size, 0.0f);
int current_output_offset = 0;
float current_total_weight = 0.0;
float current_squares_weight = 0.0;
int num_elements = 0;
for (int i = 0; i < num_lookups; i++) {
int idx = ids->data.i32[i];
if (idx >= num_rows || idx < 0) {
context->ReportError(context,
""Embedding Lookup Sparse: index out of bounds. ""
""Got %d, and bounds are [0, %d]"",
idx, num_rows - 1);
return kTfLiteError;
}
const int example_indices_offset = i * lookup_rank;
int output_bucket = 0;
int stride = 1;
for (int k = (lookup_rank - 1) - 1; k >= 0; k--) {
output_bucket += indices->data.i32[example_indices_offset + k] * stride;
stride *= dense_shape->data.i32[k];
}
const int output_offset = output_bucket * embedding_size;
if (output_offset != current_output_offset) {
FinalizeAggregation(params->combiner, num_elements, current_total_weight,
current_squares_weight, embedding_size,
&output_ptr[current_output_offset]);
num_elements = 0;
current_total_weight = 0.0;
current_squares_weight = 0.0;
current_output_offset = output_offset;
}
++num_elements;
const int example_embedding_offset = idx * embedding_size;
const float w = weights_ptr[i];
current_squares_weight += w * w;
current_total_weight += w;
for (int k = 0; k < embedding_size; k++) {
output_ptr[current_output_offset + k] +=
value_ptr[example_embedding_offset + k] * w;
}
}
FinalizeAggregation(params->combiner, num_elements, current_total_weight,
current_squares_weight, embedding_size,
&GetTensorData<float>(output)[current_output_offset]);
return kTfLiteOk;
}","TfLiteStatus Eval(TfLiteContext* VAR_0, TfLiteNode* VAR_1) {
auto* VAR_2 =
VAR_3<TfLiteEmbeddingLookupSparseParams*>(VAR_1->builtin_data);
TfLiteTensor* VAR_4;
TF_LITE_ENSURE_OK(VAR_0, GetOutputSafe(VAR_0, VAR_1, 0, &VAR_4));
const TfLiteTensor* VAR_5;
TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, 0, &VAR_5));
const TfLiteTensor* VAR_6;
TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, 1, &VAR_6));
const TfLiteTensor* VAR_7;
TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, 2, &VAR_7));
const TfLiteTensor* VAR_8;
TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, 3, &VAR_8));
const TfLiteTensor* VAR_9;
TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, 4, &VAR_9));
const int VAR_10 = SizeOfDimension(VAR_6, 1);
const int VAR_11 = NumDimensions(VAR_9);
const int VAR_12 = SizeOfDimension(VAR_5, 0);
const int VAR_13 = SizeOfDimension(VAR_9, 0);
const int VAR_14 = (VAR_10 - 1) + (VAR_11 - 1);
TF_LITE_ENSURE_EQ(VAR_0, SizeOfDimension(VAR_7, 0), VAR_10);
TfLiteIntArray* VAR_15 = TfLiteIntArrayCreate(VAR_14);
int VAR_16 = 0;
int VAR_17 = 1;
int VAR_18 = 1;
for (int VAR_19 = 0; VAR_19 < VAR_10 - 1; VAR_19++, VAR_16++) {
const int VAR_20 = VAR_7->data.i32[VAR_19];
VAR_18 *= VAR_20;
VAR_15->data[VAR_16] = VAR_20;
}
for (int VAR_19 = 1; VAR_19 < VAR_11; VAR_19++, VAR_16++) {
const int VAR_20 = SizeOfDimension(VAR_9, VAR_19);
VAR_17 *= VAR_20;
VAR_15->data[VAR_16] = VAR_20;
}
TF_LITE_ENSURE_STATUS(VAR_0->ResizeTensor(VAR_0, VAR_4, VAR_15));
const int VAR_21 = VAR_18 * VAR_17;
TfLiteTensorRealloc(VAR_21 * sizeof(float), VAR_4);
float* VAR_22 = VAR_23<float>(VAR_4);
const float* VAR_24 = VAR_23<float>(VAR_8);
const float* VAR_25 = VAR_23<float>(VAR_9);
std::fill_n(VAR_22, VAR_21, 0.0f);
int VAR_26 = 0;
float VAR_27 = 0.0;
float VAR_28 = 0.0;
int VAR_29 = 0;
for (int VAR_19 = 0; VAR_19 < VAR_12; VAR_19++) {
int VAR_30 = VAR_5->data.i32[VAR_19];
if (VAR_30 >= VAR_13 || VAR_30 < 0) {
VAR_0->ReportError(VAR_0,
""Embedding Lookup Sparse: index out of bounds. ""
""Got %d, and bounds are [0, %d]"",
VAR_30, VAR_13 - 1);
return VAR_31;
}
const int VAR_32 = VAR_19 * VAR_10;
int VAR_33 = 0;
int VAR_34 = 1;
for (int VAR_16 = (VAR_10 - 1) - 1; VAR_16 >= 0; VAR_16--) {
VAR_33 += VAR_6->data.i32[VAR_32 + VAR_16] * VAR_34;
VAR_34 *= VAR_7->data.i32[VAR_16];
}
const int VAR_35 = VAR_33 * VAR_17;
if (VAR_35 != VAR_26) {
FinalizeAggregation(VAR_2->combiner, VAR_29, VAR_27,
VAR_28, VAR_17,
&VAR_22[VAR_26]);
VAR_29 = 0;
VAR_27 = 0.0;
VAR_28 = 0.0;
VAR_26 = VAR_35;
}
++VAR_29;
const int VAR_36 = VAR_30 * VAR_17;
const float VAR_37 = VAR_24[VAR_19];
VAR_28 += VAR_37 * VAR_37;
VAR_27 += VAR_37;
for (int VAR_16 = 0; VAR_16 < VAR_17; VAR_16++) {
VAR_22[VAR_26 + VAR_16] +=
VAR_25[VAR_36 + VAR_16] * VAR_37;
}
}
FinalizeAggregation(VAR_2->combiner, VAR_29, VAR_27,
VAR_28, VAR_17,
&VAR_23<float>(VAR_4)[VAR_26]);
return VAR_38;
}",tensorflow/7c8cc4ec69cd348e44ad6a2699057ca88faad3e5/embedding_lookup_sparse.cc/vul/before/0.json,"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
  auto* params =
      reinterpret_cast<TfLiteEmbeddingLookupSparseParams*>(node->builtin_data);
  TfLiteTensor* output;
  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));
  const TfLiteTensor* ids;
  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &ids));
  const TfLiteTensor* indices;
  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &indices));
  const TfLiteTensor* dense_shape;
  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &dense_shape));
  const TfLiteTensor* weights;
  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 3, &weights));
  const TfLiteTensor* value;
  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 4, &value));

  const int lookup_rank = SizeOfDimension(indices, 1);
  const int embedding_rank = NumDimensions(value);
  const int num_lookups = SizeOfDimension(ids, 0);
  const int num_rows = SizeOfDimension(value, 0);

  // The last dimension gets replaced by the embedding.
  const int output_rank = (lookup_rank - 1) + (embedding_rank - 1);

  // Make sure that the actual dense shape of the sparse tensor represented by
  // (loopkup, indices, dense_shape) is consistent.
  TF_LITE_ENSURE_EQ(context, SizeOfDimension(dense_shape, 0), lookup_rank);

  // Resize output tensor.
  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(output_rank);
  TF_LITE_ENSURE(context, output_shape != nullptr);
  int k = 0;
  int embedding_size = 1;
  int lookup_size = 1;
  for (int i = 0; i < lookup_rank - 1; i++, k++) {
    const int dim = dense_shape->data.i32[i];
    lookup_size *= dim;
    output_shape->data[k] = dim;
  }
  for (int i = 1; i < embedding_rank; i++, k++) {
    const int dim = SizeOfDimension(value, i);
    embedding_size *= dim;
    output_shape->data[k] = dim;
  }
  TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_shape));
  const int output_size = lookup_size * embedding_size;
  TfLiteTensorRealloc(output_size * sizeof(float), output);

  float* output_ptr = GetTensorData<float>(output);
  const float* weights_ptr = GetTensorData<float>(weights);
  const float* value_ptr = GetTensorData<float>(value);

  std::fill_n(output_ptr, output_size, 0.0f);

  // Keep track of the current bucket for aggregation/combination.
  int current_output_offset = 0;
  float current_total_weight = 0.0;
  float current_squares_weight = 0.0;
  int num_elements = 0;

  for (int i = 0; i < num_lookups; i++) {
    int idx = ids->data.i32[i];
    if (idx >= num_rows || idx < 0) {
      context->ReportError(context,
                           ""Embedding Lookup Sparse: index out of bounds. ""
                           ""Got %d, and bounds are [0, %d]"",
                           idx, num_rows - 1);
      return kTfLiteError;
    }

    // Check where we need to aggregate.
    const int example_indices_offset = i * lookup_rank;
    int output_bucket = 0;
    int stride = 1;
    for (int k = (lookup_rank - 1) - 1; k >= 0; k--) {
      output_bucket += indices->data.i32[example_indices_offset + k] * stride;
      stride *= dense_shape->data.i32[k];
    }
    const int output_offset = output_bucket * embedding_size;

    // If we are in a new aggregation bucket and the combiner is not the sum,
    // go back and finalize the result of the previous bucket.
    if (output_offset != current_output_offset) {
      FinalizeAggregation(params->combiner, num_elements, current_total_weight,
                          current_squares_weight, embedding_size,
                          &output_ptr[current_output_offset]);

      // Track next bucket.
      num_elements = 0;
      current_total_weight = 0.0;
      current_squares_weight = 0.0;
      current_output_offset = output_offset;
    }

    // Add element to aggregation.
    ++num_elements;
    const int example_embedding_offset = idx * embedding_size;
    const float w = weights_ptr[i];
    current_squares_weight += w * w;
    current_total_weight += w;
    for (int k = 0; k < embedding_size; k++) {
      output_ptr[current_output_offset + k] +=
          value_ptr[example_embedding_offset + k] * w;
    }
  }

  // Finalize last bucket.
  FinalizeAggregation(params->combiner, num_elements, current_total_weight,
                      current_squares_weight, embedding_size,
                      &GetTensorData<float>(output)[current_output_offset]);

  return kTfLiteOk;
}","TfLiteStatus Eval(TfLiteContext* VAR_0, TfLiteNode* VAR_1) {
  auto* VAR_2 =
      VAR_3<TfLiteEmbeddingLookupSparseParams*>(VAR_1->builtin_data);
  TfLiteTensor* VAR_4;
  TF_LITE_ENSURE_OK(VAR_0, GetOutputSafe(VAR_0, VAR_1, 0, &VAR_4));
  const TfLiteTensor* VAR_5;
  TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, 0, &VAR_5));
  const TfLiteTensor* VAR_6;
  TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, 1, &VAR_6));
  const TfLiteTensor* VAR_7;
  TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, 2, &VAR_7));
  const TfLiteTensor* VAR_8;
  TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, 3, &VAR_8));
  const TfLiteTensor* VAR_9;
  TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, 4, &VAR_9));

  const int VAR_10 = SizeOfDimension(VAR_6, 1);
  const int VAR_11 = NumDimensions(VAR_9);
  const int VAR_12 = SizeOfDimension(VAR_5, 0);
  const int VAR_13 = SizeOfDimension(VAR_9, 0);

  /* COMMENT_0 */
  const int VAR_14 = (VAR_10 - 1) + (VAR_11 - 1);

  /* COMMENT_1 */
  /* COMMENT_2 */
  TF_LITE_ENSURE_EQ(VAR_0, SizeOfDimension(VAR_7, 0), VAR_10);

  /* COMMENT_3 */
  TfLiteIntArray* VAR_15 = TfLiteIntArrayCreate(VAR_14);
  TF_LITE_ENSURE(VAR_0, VAR_15 != nullptr);
  int VAR_16 = 0;
  int VAR_17 = 1;
  int VAR_18 = 1;
  for (int VAR_19 = 0; VAR_19 < VAR_10 - 1; VAR_19++, VAR_16++) {
    const int VAR_20 = VAR_7->data.i32[VAR_19];
    VAR_18 *= VAR_20;
    VAR_15->data[VAR_16] = VAR_20;
  }
  for (int VAR_19 = 1; VAR_19 < VAR_11; VAR_19++, VAR_16++) {
    const int VAR_20 = SizeOfDimension(VAR_9, VAR_19);
    VAR_17 *= VAR_20;
    VAR_15->data[VAR_16] = VAR_20;
  }
  TF_LITE_ENSURE_STATUS(VAR_0->ResizeTensor(VAR_0, VAR_4, VAR_15));
  const int VAR_21 = VAR_18 * VAR_17;
  TfLiteTensorRealloc(VAR_21 * sizeof(float), VAR_4);

  float* VAR_22 = VAR_23<float>(VAR_4);
  const float* VAR_24 = VAR_23<float>(VAR_8);
  const float* VAR_25 = VAR_23<float>(VAR_9);

  std::fill_n(VAR_22, VAR_21, 0.0f);

  /* COMMENT_4 */
  int VAR_26 = 0;
  float VAR_27 = 0.0;
  float VAR_28 = 0.0;
  int VAR_29 = 0;

  for (int VAR_19 = 0; VAR_19 < VAR_12; VAR_19++) {
    int VAR_30 = VAR_5->data.i32[VAR_19];
    if (VAR_30 >= VAR_13 || VAR_30 < 0) {
      VAR_0->ReportError(VAR_0,
                           ""Embedding Lookup Sparse: index out of bounds. ""
                           ""Got %d, and bounds are [0, %d]"",
                           VAR_30, VAR_13 - 1);
      return VAR_31;
    }

    /* COMMENT_5 */
    const int VAR_32 = VAR_19 * VAR_10;
    int VAR_33 = 0;
    int VAR_34 = 1;
    for (int VAR_16 = (VAR_10 - 1) - 1; VAR_16 >= 0; VAR_16--) {
      VAR_33 += VAR_6->data.i32[VAR_32 + VAR_16] * VAR_34;
      VAR_34 *= VAR_7->data.i32[VAR_16];
    }
    const int VAR_35 = VAR_33 * VAR_17;

    /* COMMENT_6 */
    /* COMMENT_7 */
    if (VAR_35 != VAR_26) {
      FinalizeAggregation(VAR_2->combiner, VAR_29, VAR_27,
                          VAR_28, VAR_17,
                          &VAR_22[VAR_26]);

      /* COMMENT_8 */
      VAR_29 = 0;
      VAR_27 = 0.0;
      VAR_28 = 0.0;
      VAR_26 = VAR_35;
    }

    /* COMMENT_9 */
    ++VAR_29;
    const int VAR_36 = VAR_30 * VAR_17;
    const float VAR_37 = VAR_24[VAR_19];
    VAR_28 += VAR_37 * VAR_37;
    VAR_27 += VAR_37;
    for (int VAR_16 = 0; VAR_16 < VAR_17; VAR_16++) {
      VAR_22[VAR_26 + VAR_16] +=
          VAR_25[VAR_36 + VAR_16] * VAR_37;
    }
  }

  /* COMMENT_10 */
  FinalizeAggregation(VAR_2->combiner, VAR_29, VAR_27,
                      VAR_28, VAR_17,
                      &VAR_23<float>(VAR_4)[VAR_26]);

  return VAR_38;
}",tensorflow/7c8cc4ec69cd348e44ad6a2699057ca88faad3e5/embedding_lookup_sparse.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -28,6 +28,7 @@
 
   // Resize output tensor.
   TfLiteIntArray* output_shape = TfLiteIntArrayCreate(output_rank);
+  TF_LITE_ENSURE(context, output_shape != nullptr);
   int k = 0;
   int embedding_size = 1;
   int lookup_size = 1;","{'deleted_lines': [], 'added_lines': ['  TF_LITE_ENSURE(context, output_shape != nullptr);']}",True,"TensorFlow is an end-to-end open source platform for machine learning. The TFLite code for allocating `TFLiteIntArray`s is vulnerable to an integer overflow issue(https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L24-L27). An attacker can craft a model such that the `size` multiplier is so large that the return value overflows the `int` datatype and becomes negative. In turn, this results in invalid value being given to `malloc`(https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L47-L52). In this case, `ret->size` would dereference an invalid pointer. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",7.1,HIGH,2,valid,2021-04-30T02:43:09Z,3
CVE-2021-29605,['CWE-190'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,tensorflow,"Fix a dangerous integer overflow and a malloc of negative size.

PiperOrigin-RevId: 371254154
Change-Id: I250a98a3df26328770167025670235a963a72da0",7c8cc4ec69cd348e44ad6a2699057ca88faad3e5,https://github.com/tensorflow/tensorflow/commit/7c8cc4ec69cd348e44ad6a2699057ca88faad3e5,tensorflow/lite/c/common.c,TfLiteIntArrayCreate,"TfLiteIntArray* TfLiteIntArrayCreate(int size) {
TfLiteIntArray* ret =
(TfLiteIntArray*)malloc(TfLiteIntArrayGetSizeInBytes(size));
ret->size = size;
return ret;
}","TfLiteIntArray* TfLiteIntArrayCreate(int VAR_0) {
TfLiteIntArray* VAR_1 =
(TfLiteIntArray*)malloc(TfLiteIntArrayGetSizeInBytes(VAR_0));
VAR_1->size = VAR_0;
return VAR_1;
}",tensorflow/7c8cc4ec69cd348e44ad6a2699057ca88faad3e5/common.c/vul/before/0.json,"TfLiteIntArray* TfLiteIntArrayCreate(int size) {
  int alloc_size = TfLiteIntArrayGetSizeInBytes(size);
  if (alloc_size <= 0) return NULL;
  TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);
  if (!ret) return ret;
  ret->size = size;
  return ret;
}","TfLiteIntArray* TfLiteIntArrayCreate(int VAR_0) {
  int VAR_1 = TfLiteIntArrayGetSizeInBytes(VAR_0);
  if (VAR_1 <= 0) return NULL;
  TfLiteIntArray* VAR_2 = (TfLiteIntArray*)malloc(VAR_1);
  if (!VAR_2) return VAR_2;
  VAR_2->size = VAR_0;
  return VAR_2;
}",tensorflow/7c8cc4ec69cd348e44ad6a2699057ca88faad3e5/common.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,8 @@
 TfLiteIntArray* TfLiteIntArrayCreate(int size) {
-  TfLiteIntArray* ret =
-      (TfLiteIntArray*)malloc(TfLiteIntArrayGetSizeInBytes(size));
+  int alloc_size = TfLiteIntArrayGetSizeInBytes(size);
+  if (alloc_size <= 0) return NULL;
+  TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);
+  if (!ret) return ret;
   ret->size = size;
   return ret;
 }","{'deleted_lines': ['  TfLiteIntArray* ret =', '      (TfLiteIntArray*)malloc(TfLiteIntArrayGetSizeInBytes(size));'], 'added_lines': ['  int alloc_size = TfLiteIntArrayGetSizeInBytes(size);', '  if (alloc_size <= 0) return NULL;', '  TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);', '  if (!ret) return ret;']}",True,"TensorFlow is an end-to-end open source platform for machine learning. The TFLite code for allocating `TFLiteIntArray`s is vulnerable to an integer overflow issue(https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L24-L27). An attacker can craft a model such that the `size` multiplier is so large that the return value overflows the `int` datatype and becomes negative. In turn, this results in invalid value being given to `malloc`(https://github.com/tensorflow/tensorflow/blob/4ceffae632721e52bf3501b736e4fe9d1221cdfa/tensorflow/lite/c/common.c#L47-L52). In this case, `ret->size` would dereference an invalid pointer. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",7.1,HIGH,2,valid,2021-04-30T02:43:09Z,3
CVE-2021-3798,['CWE-200'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N,1,opencryptoki,"SOFT: Check the EC Key on C_CreateObject and C_DeriveKey

When constructing an OpenSSL EC public or private key from PKCS#11
attributes or ECDH public data, check that the key is valid, i.e. that
the point is on the curve.

This prevents one from creating an EC key object via C_CreateObject with
invalid key data. It also prevents C_DeriveKey to derive a secret using
ECDH with an EC public key (public data) that uses a different curve
or is invalid by other means.

Signed-off-by: Ingo Franzki <ifranzki@linux.ibm.com>",4e3b43c3d8844402c04a66b55c6c940f965109f0,https://github.com/opencryptoki/opencryptoki/commit/4e3b43c3d8844402c04a66b55c6c940f965109f0,usr/lib/soft_stdll/soft_specific.c,fill_ec_key_from_pubkey,"static CK_RV fill_ec_key_from_pubkey(EC_KEY *ec_key, const CK_BYTE *data,
CK_ULONG data_len, CK_BBOOL allow_raw)
{
CK_BYTE *ecpoint = NULL;
CK_ULONG ecpoint_len, privlen;
CK_BBOOL allocated = FALSE;
CK_RV rc;
privlen = (EC_GROUP_order_bits(EC_KEY_get0_group(ec_key)) + 7) / 8;
rc = ec_point_from_public_data(data, data_len, privlen, allow_raw,
&allocated, &ecpoint, &ecpoint_len);
if (rc != CKR_OK) {
TRACE_DEVEL(""ec_point_from_public_data failed\n"");
goto out;
}
if (!EC_KEY_oct2key(ec_key, ecpoint, ecpoint_len, NULL)) {
TRACE_ERROR(""EC_KEY_oct2key failed\n"");
rc = CKR_FUNCTION_FAILED;
goto out;
}
out:
if (allocated && ecpoint != NULL)
free(ecpoint);
return rc;
}","static CK_RV fill_ec_key_from_pubkey(EC_KEY *VAR_0, const CK_BYTE *VAR_1,
CK_ULONG VAR_2, CK_BBOOL VAR_3)
{
CK_BYTE *VAR_4 = NULL;
CK_ULONG VAR_5, VAR_6;
CK_BBOOL VAR_7 = FALSE;
CK_RV VAR_8;
VAR_6 = (EC_GROUP_order_bits(EC_KEY_get0_group(VAR_0)) + 7) / 8;
VAR_8 = ec_point_from_public_data(VAR_1, VAR_2, VAR_6, VAR_3,
&VAR_7, &VAR_4, &VAR_5);
if (VAR_8 != VAR_9) {
TRACE_DEVEL(""ec_point_from_public_data failed\n"");
goto out;
}
if (!EC_KEY_oct2key(VAR_0, VAR_4, VAR_5, NULL)) {
TRACE_ERROR(""EC_KEY_oct2key failed\n"");
VAR_8 = VAR_10;
goto out;
}
out:
if (VAR_7 && VAR_4 != NULL)
free(VAR_4);
return VAR_8;
}",opencryptoki/4e3b43c3d8844402c04a66b55c6c940f965109f0/soft_specific.c/vul/before/0.json,"static CK_RV fill_ec_key_from_pubkey(EC_KEY *ec_key, const CK_BYTE *data,
                                     CK_ULONG data_len, CK_BBOOL allow_raw)
{
    CK_BYTE *ecpoint = NULL;
    CK_ULONG ecpoint_len, privlen;
    CK_BBOOL allocated = FALSE;
    CK_RV rc;

    privlen = (EC_GROUP_order_bits(EC_KEY_get0_group(ec_key)) + 7) / 8;

    rc = ec_point_from_public_data(data, data_len, privlen, allow_raw,
                                   &allocated, &ecpoint, &ecpoint_len);
    if (rc != CKR_OK) {
        TRACE_DEVEL(""ec_point_from_public_data failed\n"");
        goto out;
    }

    if (!EC_KEY_oct2key(ec_key, ecpoint, ecpoint_len, NULL)) {
        TRACE_ERROR(""EC_KEY_oct2key failed\n"");
        rc = CKR_FUNCTION_FAILED;
        goto out;
    }

    if (!EC_KEY_check_key(ec_key)) {
        TRACE_ERROR(""EC_KEY_check_key failed\n"");
        rc = CKR_PUBLIC_KEY_INVALID;
        goto out;
    }

out:
    if (allocated && ecpoint != NULL)
        free(ecpoint);

    return rc;
}","static CK_RV fill_ec_key_from_pubkey(EC_KEY *VAR_0, const CK_BYTE *VAR_1,
                                     CK_ULONG VAR_2, CK_BBOOL VAR_3)
{
    CK_BYTE *VAR_4 = NULL;
    CK_ULONG VAR_5, VAR_6;
    CK_BBOOL VAR_7 = FALSE;
    CK_RV VAR_8;

    VAR_6 = (EC_GROUP_order_bits(EC_KEY_get0_group(VAR_0)) + 7) / 8;

    VAR_8 = ec_point_from_public_data(VAR_1, VAR_2, VAR_6, VAR_3,
                                   &VAR_7, &VAR_4, &VAR_5);
    if (VAR_8 != VAR_9) {
        TRACE_DEVEL(""ec_point_from_public_data failed\n"");
        goto out;
    }

    if (!EC_KEY_oct2key(VAR_0, VAR_4, VAR_5, NULL)) {
        TRACE_ERROR(""EC_KEY_oct2key failed\n"");
        VAR_8 = VAR_10;
        goto out;
    }

    if (!EC_KEY_check_key(VAR_0)) {
        TRACE_ERROR(""EC_KEY_check_key failed\n"");
        VAR_8 = VAR_11;
        goto out;
    }

out:
    if (VAR_7 && VAR_4 != NULL)
        free(VAR_4);

    return VAR_8;
}",opencryptoki/4e3b43c3d8844402c04a66b55c6c940f965109f0/soft_specific.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,6 +21,12 @@
         goto out;
     }
 
+    if (!EC_KEY_check_key(ec_key)) {
+        TRACE_ERROR(""EC_KEY_check_key failed\n"");
+        rc = CKR_PUBLIC_KEY_INVALID;
+        goto out;
+    }
+
 out:
     if (allocated && ecpoint != NULL)
         free(ecpoint);","{'deleted_lines': [], 'added_lines': ['    if (!EC_KEY_check_key(ec_key)) {', '        TRACE_ERROR(""EC_KEY_check_key failed\\n"");', '        rc = CKR_PUBLIC_KEY_INVALID;', '        goto out;', '    }', '']}",True,"A flaw was found in openCryptoki. The openCryptoki Soft token does not check if an EC key is valid when an EC key is created via C_CreateObject, nor when C_DeriveKey is used with ECDH public data. This may allow a malicious user to extract the private key by performing an invalid curve attack.",5.5,MEDIUM,1,valid,2021-05-03T08:05:07Z,3
CVE-2021-3798,['CWE-200'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N,1,opencryptoki,"SOFT: Check the EC Key on C_CreateObject and C_DeriveKey

When constructing an OpenSSL EC public or private key from PKCS#11
attributes or ECDH public data, check that the key is valid, i.e. that
the point is on the curve.

This prevents one from creating an EC key object via C_CreateObject with
invalid key data. It also prevents C_DeriveKey to derive a secret using
ECDH with an EC public key (public data) that uses a different curve
or is invalid by other means.

Signed-off-by: Ingo Franzki <ifranzki@linux.ibm.com>",4e3b43c3d8844402c04a66b55c6c940f965109f0,https://github.com/opencryptoki/opencryptoki/commit/4e3b43c3d8844402c04a66b55c6c940f965109f0,usr/lib/soft_stdll/soft_specific.c,fill_ec_key_from_privkey,"static CK_RV fill_ec_key_from_privkey(EC_KEY *ec_key, const CK_BYTE *data,
CK_ULONG data_len)
{
EC_POINT *point = NULL;
CK_RV rc = CKR_OK;
if (!EC_KEY_oct2priv(ec_key, data, data_len)) {
TRACE_ERROR(""EC_KEY_oct2priv failed\n"");
rc = CKR_FUNCTION_FAILED;
goto out;
}
point = EC_POINT_new(EC_KEY_get0_group(ec_key));
if (point == NULL) {
TRACE_ERROR(""EC_POINT_new failed\n"");
rc = CKR_FUNCTION_FAILED;
goto out;
}
if (!EC_POINT_mul(EC_KEY_get0_group(ec_key), point,
EC_KEY_get0_private_key(ec_key), NULL, NULL, NULL)) {
TRACE_ERROR(""EC_POINT_mul failed\n"");
rc = CKR_FUNCTION_FAILED;
goto out;
}
if (!EC_KEY_set_public_key(ec_key, point)) {
TRACE_ERROR(""EC_KEY_set_public_key failed\n"");
rc = CKR_FUNCTION_FAILED;
goto out;
}
out:
if (point != NULL)
EC_POINT_free(point);
return rc;
}","static CK_RV fill_ec_key_from_privkey(EC_KEY *VAR_0, const CK_BYTE *VAR_1,
CK_ULONG VAR_2)
{
EC_POINT *VAR_3 = NULL;
CK_RV VAR_4 = VAR_5;
if (!EC_KEY_oct2priv(VAR_0, VAR_1, VAR_2)) {
TRACE_ERROR(""EC_KEY_oct2priv failed\n"");
VAR_4 = VAR_6;
goto out;
}
VAR_3 = EC_POINT_new(EC_KEY_get0_group(VAR_0));
if (VAR_3 == NULL) {
TRACE_ERROR(""EC_POINT_new failed\n"");
VAR_4 = VAR_6;
goto out;
}
if (!EC_POINT_mul(EC_KEY_get0_group(VAR_0), VAR_3,
EC_KEY_get0_private_key(VAR_0), NULL, NULL, NULL)) {
TRACE_ERROR(""EC_POINT_mul failed\n"");
VAR_4 = VAR_6;
goto out;
}
if (!EC_KEY_set_public_key(VAR_0, VAR_3)) {
TRACE_ERROR(""EC_KEY_set_public_key failed\n"");
VAR_4 = VAR_6;
goto out;
}
out:
if (VAR_3 != NULL)
EC_POINT_free(VAR_3);
return VAR_4;
}",opencryptoki/4e3b43c3d8844402c04a66b55c6c940f965109f0/soft_specific.c/vul/before/1.json,"static CK_RV fill_ec_key_from_privkey(EC_KEY *ec_key, const CK_BYTE *data,
                                      CK_ULONG data_len)
{
    EC_POINT *point = NULL;
    CK_RV rc = CKR_OK;

    if (!EC_KEY_oct2priv(ec_key, data, data_len)) {
        TRACE_ERROR(""EC_KEY_oct2priv failed\n"");
        rc = CKR_FUNCTION_FAILED;
        goto out;
    }

    point = EC_POINT_new(EC_KEY_get0_group(ec_key));
    if (point == NULL) {
        TRACE_ERROR(""EC_POINT_new failed\n"");
        rc = CKR_FUNCTION_FAILED;
        goto out;
    }

    if (!EC_POINT_mul(EC_KEY_get0_group(ec_key), point,
                      EC_KEY_get0_private_key(ec_key), NULL, NULL, NULL)) {
        TRACE_ERROR(""EC_POINT_mul failed\n"");
        rc = CKR_FUNCTION_FAILED;
        goto out;
    }

    if (!EC_KEY_set_public_key(ec_key, point)) {
        TRACE_ERROR(""EC_KEY_set_public_key failed\n"");
        rc = CKR_FUNCTION_FAILED;
        goto out;
    }

    if (!EC_KEY_check_key(ec_key)) {
        TRACE_ERROR(""EC_KEY_check_key failed\n"");
        rc = CKR_FUNCTION_FAILED;
        goto out;
    }

out:
    if (point != NULL)
        EC_POINT_free(point);

    return rc;
}","static CK_RV fill_ec_key_from_privkey(EC_KEY *VAR_0, const CK_BYTE *VAR_1,
                                      CK_ULONG VAR_2)
{
    EC_POINT *VAR_3 = NULL;
    CK_RV VAR_4 = VAR_5;

    if (!EC_KEY_oct2priv(VAR_0, VAR_1, VAR_2)) {
        TRACE_ERROR(""EC_KEY_oct2priv failed\n"");
        VAR_4 = VAR_6;
        goto out;
    }

    VAR_3 = EC_POINT_new(EC_KEY_get0_group(VAR_0));
    if (VAR_3 == NULL) {
        TRACE_ERROR(""EC_POINT_new failed\n"");
        VAR_4 = VAR_6;
        goto out;
    }

    if (!EC_POINT_mul(EC_KEY_get0_group(VAR_0), VAR_3,
                      EC_KEY_get0_private_key(VAR_0), NULL, NULL, NULL)) {
        TRACE_ERROR(""EC_POINT_mul failed\n"");
        VAR_4 = VAR_6;
        goto out;
    }

    if (!EC_KEY_set_public_key(VAR_0, VAR_3)) {
        TRACE_ERROR(""EC_KEY_set_public_key failed\n"");
        VAR_4 = VAR_6;
        goto out;
    }

    if (!EC_KEY_check_key(VAR_0)) {
        TRACE_ERROR(""EC_KEY_check_key failed\n"");
        VAR_4 = VAR_6;
        goto out;
    }

out:
    if (VAR_3 != NULL)
        EC_POINT_free(VAR_3);

    return VAR_4;
}",opencryptoki/4e3b43c3d8844402c04a66b55c6c940f965109f0/soft_specific.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -30,6 +30,12 @@
         goto out;
     }
 
+    if (!EC_KEY_check_key(ec_key)) {
+        TRACE_ERROR(""EC_KEY_check_key failed\n"");
+        rc = CKR_FUNCTION_FAILED;
+        goto out;
+    }
+
 out:
     if (point != NULL)
         EC_POINT_free(point);","{'deleted_lines': [], 'added_lines': ['    if (!EC_KEY_check_key(ec_key)) {', '        TRACE_ERROR(""EC_KEY_check_key failed\\n"");', '        rc = CKR_FUNCTION_FAILED;', '        goto out;', '    }', '']}",True,"A flaw was found in openCryptoki. The openCryptoki Soft token does not check if an EC key is valid when an EC key is created via C_CreateObject, nor when C_DeriveKey is used with ECDH public data. This may allow a malicious user to extract the private key by performing an invalid curve attack.",5.5,MEDIUM,1,valid,2021-05-03T08:05:07Z,3
CVE-2021-29591,"['CWE-674', 'CWE-835']",AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"TFLite: Error out when the graph has a recurion.

Recursion is currently unsupported.

PiperOrigin-RevId: 371708957
Change-Id: I8dfad0d85cbfe08e39ae8ea7bad21254ddee5003",c6173f5fe66cdbab74f4f869311fe6aae2ba35f4,https://github.com/tensorflow/tensorflow/commit/c6173f5fe66cdbab74f4f869311fe6aae2ba35f4,tensorflow/lite/core/subgraph.cc,Subgraph::AllocateTensors,"TfLiteStatus Subgraph::AllocateTensors() {
TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(profiler_.get(), ""AllocateTensors"");
if (!consistent_) {
ReportError(""AllocateTensors() called on inconsistent model."");
return kTfLiteError;
}
TF_LITE_ENSURE_STATUS(RedoAllDelegates());
if (state_ != kStateUninvokable &&
!HasDynamicTensorImpl(context_, inputs())) {
if (memory_planner_ && !memory_planner_->HasNonPersistentMemory()) {
memory_planner_->AcquireNonPersistentMemory();
}
return kTfLiteOk;
}
next_execution_plan_index_to_prepare_ = 0;
next_execution_plan_index_to_plan_allocation_ = 0;
next_original_execution_plan_index_to_prepare_ = 0;
if (memory_planner_) {
TF_LITE_ENSURE_STATUS(memory_planner_->ResetAllocations());
}
TF_LITE_ENSURE_STATUS(PrepareOpsAndTensors());
state_ = kStateInvokable;
ResetVariableTensors();
return kTfLiteOk;
}","TfLiteStatus Subgraph::AllocateTensors() {
TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(VAR_0.get(), ""AllocateTensors"");
if (!VAR_1) {
ReportError(""AllocateTensors() called on inconsistent model."");
return VAR_2;
}
TF_LITE_ENSURE_STATUS(RedoAllDelegates());
if (VAR_3 != VAR_4 &&
!HasDynamicTensorImpl(VAR_5, inputs())) {
if (VAR_6 && !VAR_6->HasNonPersistentMemory()) {
VAR_6->AcquireNonPersistentMemory();
}
return VAR_7;
}
VAR_8 = 0;
VAR_9 = 0;
VAR_10 = 0;
if (VAR_6) {
TF_LITE_ENSURE_STATUS(VAR_6->ResetAllocations());
}
TF_LITE_ENSURE_STATUS(PrepareOpsAndTensors());
VAR_3 = VAR_11;
ResetVariableTensors();
return VAR_7;
}",tensorflow/c6173f5fe66cdbab74f4f869311fe6aae2ba35f4/subgraph.cc/vul/before/0.json,"TfLiteStatus Subgraph::AllocateTensors() {
  TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(profiler_.get(), ""AllocateTensors"");

  if (!consistent_) {
    ReportError(""AllocateTensors() called on inconsistent model."");
    return kTfLiteError;
  }

  // Restore delegation state if applicable.
  TF_LITE_ENSURE_STATUS(RedoAllDelegates());

  // Explicit (re)allocation is necessary if nodes have been changed or tensors
  // have been resized. For inputs marked as dynamic, we can't short-circuit the
  // allocation as the client may have done the resize manually.
  if (state_ != kStateUninvokable &&
      !HasDynamicTensorImpl(context_, inputs())) {
    if (memory_planner_ && !memory_planner_->HasNonPersistentMemory()) {
      // If the only change was the release of non-persistent memory via
      // ReleaseNonPersistentMemory(), just re-allocate it. For any other type
      // of memory-planning change (for eg, ResizeInputTensor), the state would
      // be kStateUninvokable.
      memory_planner_->AcquireNonPersistentMemory();
    }
    return kTfLiteOk;
  }

  // Note `AllocateTensors` sometimes calls itself recursively above
  // for delegates. Therefore only the logic below need to be guarded
  // by `SubgraphGuard`.
  SubgraphGuard guard(&context_, &is_subgraph_in_use_);
  TF_LITE_ENSURE_OK(&context_, guard.status());

  next_execution_plan_index_to_prepare_ = 0;
  next_execution_plan_index_to_plan_allocation_ = 0;
  next_original_execution_plan_index_to_prepare_ = 0;
  if (memory_planner_) {
    TF_LITE_ENSURE_STATUS(memory_planner_->ResetAllocations());
  }

  TF_LITE_ENSURE_STATUS(PrepareOpsAndTensors());

  state_ = kStateInvokable;

  // Reset the variable tensors to zero after (re)allocating the tensors.
  // Developers shouldn't rely on the side effect of this function to reset
  // variable tensors. They should call `ResetVariableTensors` directly
  // instead.
  ResetVariableTensors();

  return kTfLiteOk;
}","TfLiteStatus Subgraph::AllocateTensors() {
  TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(VAR_0.get(), ""AllocateTensors"");

  if (!VAR_1) {
    ReportError(""AllocateTensors() called on inconsistent model."");
    return VAR_2;
  }

  /* COMMENT_0 */
  TF_LITE_ENSURE_STATUS(RedoAllDelegates());

  /* COMMENT_1 */
  /* COMMENT_2 */
  /* COMMENT_3 */
  if (VAR_3 != VAR_4 &&
      !HasDynamicTensorImpl(VAR_5, inputs())) {
    if (VAR_6 && !VAR_6->HasNonPersistentMemory()) {
      /* COMMENT_4 */
      /* COMMENT_5 */
      /* COMMENT_6 */
      /* COMMENT_7 */
      VAR_6->AcquireNonPersistentMemory();
    }
    return VAR_7;
  }

  /* COMMENT_8 */
  /* COMMENT_9 */
  /* COMMENT_10 */
  SubgraphGuard VAR_8(&VAR_5, &VAR_9);
  TF_LITE_ENSURE_OK(&VAR_5, VAR_8.status());

  VAR_10 = 0;
  VAR_11 = 0;
  VAR_12 = 0;
  if (VAR_6) {
    TF_LITE_ENSURE_STATUS(VAR_6->ResetAllocations());
  }

  TF_LITE_ENSURE_STATUS(PrepareOpsAndTensors());

  VAR_3 = VAR_13;

  /* COMMENT_11 */
  /* COMMENT_12 */
  /* COMMENT_13 */
  /* COMMENT_14 */
  ResetVariableTensors();

  return VAR_7;
}",tensorflow/c6173f5fe66cdbab74f4f869311fe6aae2ba35f4/subgraph.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,6 @@
 TfLiteStatus Subgraph::AllocateTensors() {
   TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(profiler_.get(), ""AllocateTensors"");
+
   if (!consistent_) {
     ReportError(""AllocateTensors() called on inconsistent model."");
     return kTfLiteError;
@@ -23,6 +24,12 @@
     return kTfLiteOk;
   }
 
+  // Note `AllocateTensors` sometimes calls itself recursively above
+  // for delegates. Therefore only the logic below need to be guarded
+  // by `SubgraphGuard`.
+  SubgraphGuard guard(&context_, &is_subgraph_in_use_);
+  TF_LITE_ENSURE_OK(&context_, guard.status());
+
   next_execution_plan_index_to_prepare_ = 0;
   next_execution_plan_index_to_plan_allocation_ = 0;
   next_original_execution_plan_index_to_prepare_ = 0;","{'deleted_lines': [], 'added_lines': ['', '  // Note `AllocateTensors` sometimes calls itself recursively above', '  // for delegates. Therefore only the logic below need to be guarded', '  // by `SubgraphGuard`.', '  SubgraphGuard guard(&context_, &is_subgraph_in_use_);', '  TF_LITE_ENSURE_OK(&context_, guard.status());', '']}",True,"TensorFlow is an end-to-end open source platform for machine learning. TFlite graphs must not have loops between nodes. However, this condition was not checked and an attacker could craft models that would result in infinite loop during evaluation. In certain cases, the infinite loop would be replaced by stack overflow due to too many recursive calls. For example, the `While` implementation(https://github.com/tensorflow/tensorflow/blob/106d8f4fb89335a2c52d7c895b7a7485465ca8d9/tensorflow/lite/kernels/while.cc) could be tricked into a scneario where both the body and the loop subgraphs are the same. Evaluating one of the subgraphs means calling the `Eval` function for the other and this quickly exhaust all stack space. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range. Please consult our security guide(https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.",7.3,HIGH,2,valid,2021-05-03T16:07:42Z,3
CVE-2021-29591,"['CWE-674', 'CWE-835']",AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"TFLite: Error out when the graph has a recurion.

Recursion is currently unsupported.

PiperOrigin-RevId: 371708957
Change-Id: I8dfad0d85cbfe08e39ae8ea7bad21254ddee5003",c6173f5fe66cdbab74f4f869311fe6aae2ba35f4,https://github.com/tensorflow/tensorflow/commit/c6173f5fe66cdbab74f4f869311fe6aae2ba35f4,tensorflow/lite/core/subgraph.cc,Subgraph::Invoke,"TfLiteStatus Subgraph::Invoke() {
if (!consistent_) {
ReportError(""Invoke called on model that is not consistent."");
return kTfLiteError;
}
TfLiteStatus status = kTfLiteOk;
if (state_ == kStateUninvokable) {
ReportError(""Invoke called on model that is not ready."");
return kTfLiteError;
} else if (memory_planner_ && !memory_planner_->HasNonPersistentMemory()) {
ReportError(""Non-persistent memory is not available."");
return kTfLiteError;
}
TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(profiler_.get(), ""Invoke"");
for (int execution_plan_index = 0;
execution_plan_index < execution_plan_.size(); execution_plan_index++) {
if (execution_plan_index == next_execution_plan_index_to_prepare_) {
TF_LITE_ENSURE_STATUS(PrepareOpsAndTensors());
TF_LITE_ENSURE(&context_, next_execution_plan_index_to_prepare_ >=
execution_plan_index);
}
int node_index = execution_plan_[execution_plan_index];
TfLiteNode& node = nodes_and_registration_[node_index].first;
const TfLiteRegistration& registration =
nodes_and_registration_[node_index].second;
const char* op_name = nullptr;
if (profiler_) op_name = GetTFLiteOpName(registration);
TFLITE_SCOPED_TAGGED_OPERATOR_PROFILE(profiler_.get(), op_name, node_index);
for (int i = 0; i < node.inputs->size; ++i) {
int tensor_index = node.inputs->data[i];
if (tensor_index == kTfLiteOptionalTensor) {
continue;
}
TfLiteTensor* tensor = &tensors_[tensor_index];
if (tensor->delegate && tensor->delegate != node.delegate &&
tensor->data_is_stale) {
TF_LITE_ENSURE_STATUS(EnsureTensorDataIsReadable(tensor_index));
}
if (tensor->data.raw == nullptr && tensor->bytes > 0) {
if (registration.builtin_code == kTfLiteBuiltinReshape && i == 1 &&
tensor->dims->size != 1) {
continue;
} else {
ReportError(""Input tensor %d lacks data"", tensor_index);
return kTfLiteError;
}
}
}
if (check_cancelled_func_ != nullptr &&
check_cancelled_func_(cancellation_data_)) {
ReportError(""Client requested cancel during Invoke()"");
return kTfLiteError;
}
EnsureTensorsVectorCapacity();
tensor_resized_since_op_invoke_ = false;
if (OpInvoke(registration, &node) != kTfLiteOk) {
return ReportOpError(&context_, node, registration, node_index,
""failed to invoke"");
}
if (tensor_resized_since_op_invoke_ &&
HasDynamicTensor(context_, node.outputs)) {
next_execution_plan_index_to_prepare_ = execution_plan_index + 1;
if (next_execution_plan_index_to_plan_allocation_ >
next_execution_plan_index_to_prepare_) {
next_execution_plan_index_to_plan_allocation_ =
next_execution_plan_index_to_prepare_;
if (memory_planner_) {
TF_LITE_ENSURE_STATUS(memory_planner_->ResetAllocationsAfter(
next_execution_plan_index_to_plan_allocation_ - 1));
}
}
}
}
return status;
}","TfLiteStatus Subgraph::Invoke() {
if (!VAR_0) {
ReportError(""Invoke called on model that is not consistent."");
return VAR_1;
}
TfLiteStatus VAR_2 = VAR_3;
if (VAR_4 == VAR_5) {
ReportError(""Invoke called on model that is not ready."");
return VAR_1;
} else if (VAR_6 && !VAR_6->HasNonPersistentMemory()) {
ReportError(""Non-persistent memory is not available."");
return VAR_1;
}
TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(VAR_7.get(), ""Invoke"");
for (int VAR_8 = 0;
VAR_8 < VAR_9.size(); VAR_8++) {
if (VAR_8 == VAR_10) {
TF_LITE_ENSURE_STATUS(PrepareOpsAndTensors());
TF_LITE_ENSURE(&VAR_11, VAR_10 >=
VAR_8);
}
int VAR_12 = VAR_9[VAR_8];
TfLiteNode& VAR_13 = VAR_14[VAR_12].first;
const TfLiteRegistration& VAR_15 =
VAR_14[VAR_12].second;
const char* VAR_16 = nullptr;
if (VAR_7) VAR_16 = GetTFLiteOpName(VAR_15);
TFLITE_SCOPED_TAGGED_OPERATOR_PROFILE(VAR_7.get(), VAR_16, VAR_12);
for (int VAR_17 = 0; VAR_17 < VAR_13.inputs->size; ++VAR_17) {
int VAR_18 = VAR_13.inputs->data[VAR_17];
if (VAR_18 == VAR_19) {
continue;
}
TfLiteTensor* VAR_20 = &VAR_21[VAR_18];
if (VAR_20->delegate && VAR_20->delegate != VAR_13.delegate &&
VAR_20->data_is_stale) {
TF_LITE_ENSURE_STATUS(EnsureTensorDataIsReadable(VAR_18));
}
if (VAR_20->data.raw == nullptr && VAR_20->bytes > 0) {
if (VAR_15.builtin_code == VAR_22 && VAR_17 == 1 &&
VAR_20->dims->size != 1) {
continue;
} else {
ReportError(""Input tensor %d lacks data"", VAR_18);
return VAR_1;
}
}
}
if (VAR_23 != nullptr &&
VAR_23(VAR_24)) {
ReportError(""Client requested cancel during Invoke()"");
return VAR_1;
}
EnsureTensorsVectorCapacity();
VAR_25 = false;
if (OpInvoke(VAR_15, &VAR_13) != VAR_3) {
return ReportOpError(&VAR_11, VAR_13, VAR_15, VAR_12,
""failed to invoke"");
}
if (VAR_25 &&
HasDynamicTensor(VAR_11, VAR_13.outputs)) {
VAR_10 = VAR_8 + 1;
if (VAR_26 >
VAR_10) {
VAR_26 =
VAR_10;
if (VAR_6) {
TF_LITE_ENSURE_STATUS(VAR_6->ResetAllocationsAfter(
VAR_26 - 1));
}
}
}
}
return VAR_2;
}",tensorflow/c6173f5fe66cdbab74f4f869311fe6aae2ba35f4/subgraph.cc/vul/before/1.json,"TfLiteStatus Subgraph::Invoke() {
  SubgraphGuard guard(&context_, &is_subgraph_in_use_);
  TF_LITE_ENSURE_OK(&context_, guard.status());

  if (!consistent_) {
    ReportError(""Invoke called on model that is not consistent."");
    return kTfLiteError;
  }

  TfLiteStatus status = kTfLiteOk;
  if (state_ == kStateUninvokable) {
    ReportError(""Invoke called on model that is not ready."");
    return kTfLiteError;
  } else if (memory_planner_ && !memory_planner_->HasNonPersistentMemory()) {
    ReportError(""Non-persistent memory is not available."");
    return kTfLiteError;
  }
  TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(profiler_.get(), ""Invoke"");

  // Invocations are always done in node order.
  // Note that calling Invoke repeatedly will cause the original memory plan to
  // be reused, unless either ResizeInputTensor() or AllocateTensors() has been
  // called.
  for (int execution_plan_index = 0;
       execution_plan_index < execution_plan_.size(); execution_plan_index++) {
    if (execution_plan_index == next_execution_plan_index_to_prepare_) {
      TF_LITE_ENSURE_STATUS(PrepareOpsAndTensors());
      TF_LITE_ENSURE(&context_, next_execution_plan_index_to_prepare_ >=
                                    execution_plan_index);
    }
    int node_index = execution_plan_[execution_plan_index];
    TfLiteNode& node = nodes_and_registration_[node_index].first;
    const TfLiteRegistration& registration =
        nodes_and_registration_[node_index].second;

    const char* op_name = nullptr;
    if (profiler_) op_name = GetTFLiteOpName(registration);
    TFLITE_SCOPED_TAGGED_OPERATOR_PROFILE(profiler_.get(), op_name, node_index);

    for (int i = 0; i < node.inputs->size; ++i) {
      int tensor_index = node.inputs->data[i];
      if (tensor_index == kTfLiteOptionalTensor) {
        continue;
      }
      TfLiteTensor* tensor = &tensors_[tensor_index];
      if (tensor->delegate && tensor->delegate != node.delegate &&
          tensor->data_is_stale) {
        TF_LITE_ENSURE_STATUS(EnsureTensorDataIsReadable(tensor_index));
      }
      if (tensor->data.raw == nullptr && tensor->bytes > 0) {
        if (registration.builtin_code == kTfLiteBuiltinReshape && i == 1 &&
            tensor->dims->size != 1) {
          // In general, having a tensor here with no buffer will be an error.
          // However, for the reshape operator, the second input tensor is
          // sometimes only used for the shape, not for the data. Thus, null
          // buffer is ok in this situation.
          // The situation where null buffer is not ok for reshape operator is
          // only when there are 2 inputs given to the node and the one
          // corresponding to the shape (i == 1) is a vector that contains all
          // dimensions. See `GetOutputShape()` function in
          // `tensorflow/lite/kernels/reshape.cc`
          continue;
        } else {
          // In all other cases, we need to return an error as otherwise we will
          // trigger a null pointer dereference (likely).
          ReportError(""Input tensor %d lacks data"", tensor_index);
          return kTfLiteError;
        }
      }
    }

    if (check_cancelled_func_ != nullptr &&
        check_cancelled_func_(cancellation_data_)) {
      ReportError(""Client requested cancel during Invoke()"");
      return kTfLiteError;
    }

    EnsureTensorsVectorCapacity();
    tensor_resized_since_op_invoke_ = false;
    if (OpInvoke(registration, &node) != kTfLiteOk) {
      return ReportOpError(&context_, node, registration, node_index,
                           ""failed to invoke"");
    }

    // Force execution prep for downstream ops if the latest op triggered the
    // resize of a dynamic tensor.
    if (tensor_resized_since_op_invoke_ &&
        HasDynamicTensor(context_, node.outputs)) {
      next_execution_plan_index_to_prepare_ = execution_plan_index + 1;

      // This happens when an intermediate dynamic tensor is resized.
      // We don't have to prepare all the ops, but we need to recompute
      // the allocation plan.
      if (next_execution_plan_index_to_plan_allocation_ >
          next_execution_plan_index_to_prepare_) {
        next_execution_plan_index_to_plan_allocation_ =
            next_execution_plan_index_to_prepare_;
        if (memory_planner_) {
          TF_LITE_ENSURE_STATUS(memory_planner_->ResetAllocationsAfter(
              next_execution_plan_index_to_plan_allocation_ - 1));
        }
      }
    }
  }

  return status;
}","TfLiteStatus Subgraph::Invoke() {
  SubgraphGuard VAR_0(&VAR_1, &VAR_2);
  TF_LITE_ENSURE_OK(&VAR_1, VAR_0.status());

  if (!VAR_3) {
    ReportError(""Invoke called on model that is not consistent."");
    return VAR_4;
  }

  TfLiteStatus VAR_5 = VAR_6;
  if (VAR_7 == VAR_8) {
    ReportError(""Invoke called on model that is not ready."");
    return VAR_4;
  } else if (VAR_9 && !VAR_9->HasNonPersistentMemory()) {
    ReportError(""Non-persistent memory is not available."");
    return VAR_4;
  }
  TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(VAR_10.get(), ""Invoke"");

  /* COMMENT_0 */
  /* COMMENT_1 */
  /* COMMENT_2 */
  /* COMMENT_3 */
  for (int VAR_11 = 0;
       VAR_11 < VAR_12.size(); VAR_11++) {
    if (VAR_11 == VAR_13) {
      TF_LITE_ENSURE_STATUS(PrepareOpsAndTensors());
      TF_LITE_ENSURE(&VAR_1, VAR_13 >=
                                    VAR_11);
    }
    int VAR_14 = VAR_12[VAR_11];
    TfLiteNode& VAR_15 = VAR_16[VAR_14].first;
    const TfLiteRegistration& VAR_17 =
        VAR_16[VAR_14].second;

    const char* VAR_18 = nullptr;
    if (VAR_10) VAR_18 = GetTFLiteOpName(VAR_17);
    TFLITE_SCOPED_TAGGED_OPERATOR_PROFILE(VAR_10.get(), VAR_18, VAR_14);

    for (int VAR_19 = 0; VAR_19 < VAR_15.inputs->size; ++VAR_19) {
      int VAR_20 = VAR_15.inputs->data[VAR_19];
      if (VAR_20 == VAR_21) {
        continue;
      }
      TfLiteTensor* VAR_22 = &VAR_23[VAR_20];
      if (VAR_22->delegate && VAR_22->delegate != VAR_15.delegate &&
          VAR_22->data_is_stale) {
        TF_LITE_ENSURE_STATUS(EnsureTensorDataIsReadable(VAR_20));
      }
      if (VAR_22->data.raw == nullptr && VAR_22->bytes > 0) {
        if (VAR_17.builtin_code == VAR_24 && VAR_19 == 1 &&
            VAR_22->dims->size != 1) {
          /* COMMENT_4 */
          /* COMMENT_5 */
          /* COMMENT_6 */
          /* COMMENT_7 */
          /* COMMENT_8 */
          /* COMMENT_9 */
          /* COMMENT_10 */
          /* COMMENT_11 */
          /* COMMENT_12 */
          continue;
        } else {
          /* COMMENT_13 */
          /* COMMENT_14 */
          ReportError(""Input tensor %d lacks data"", VAR_20);
          return VAR_4;
        }
      }
    }

    if (VAR_25 != nullptr &&
        VAR_25(VAR_26)) {
      ReportError(""Client requested cancel during Invoke()"");
      return VAR_4;
    }

    EnsureTensorsVectorCapacity();
    VAR_27 = false;
    if (OpInvoke(VAR_17, &VAR_15) != VAR_6) {
      return ReportOpError(&VAR_1, VAR_15, VAR_17, VAR_14,
                           ""failed to invoke"");
    }

    /* COMMENT_15 */
    /* COMMENT_16 */
    if (VAR_27 &&
        HasDynamicTensor(VAR_1, VAR_15.outputs)) {
      VAR_13 = VAR_11 + 1;

      /* COMMENT_17 */
      /* COMMENT_18 */
      /* COMMENT_19 */
      if (VAR_28 >
          VAR_13) {
        VAR_28 =
            VAR_13;
        if (VAR_9) {
          TF_LITE_ENSURE_STATUS(VAR_9->ResetAllocationsAfter(
              VAR_28 - 1));
        }
      }
    }
  }

  return VAR_5;
}",tensorflow/c6173f5fe66cdbab74f4f869311fe6aae2ba35f4/subgraph.cc/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,4 +1,7 @@
 TfLiteStatus Subgraph::Invoke() {
+  SubgraphGuard guard(&context_, &is_subgraph_in_use_);
+  TF_LITE_ENSURE_OK(&context_, guard.status());
+
   if (!consistent_) {
     ReportError(""Invoke called on model that is not consistent."");
     return kTfLiteError;","{'deleted_lines': [], 'added_lines': ['  SubgraphGuard guard(&context_, &is_subgraph_in_use_);', '  TF_LITE_ENSURE_OK(&context_, guard.status());', '']}",True,"TensorFlow is an end-to-end open source platform for machine learning. TFlite graphs must not have loops between nodes. However, this condition was not checked and an attacker could craft models that would result in infinite loop during evaluation. In certain cases, the infinite loop would be replaced by stack overflow due to too many recursive calls. For example, the `While` implementation(https://github.com/tensorflow/tensorflow/blob/106d8f4fb89335a2c52d7c895b7a7485465ca8d9/tensorflow/lite/kernels/while.cc) could be tricked into a scneario where both the body and the loop subgraphs are the same. Evaluating one of the subgraphs means calling the `Eval` function for the other and this quickly exhaust all stack space. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range. Please consult our security guide(https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.",7.3,HIGH,2,valid,2021-05-03T16:07:42Z,3
CVE-2021-29591,"['CWE-674', 'CWE-835']",AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"TFLite: Error out when the graph has a recurion.

Recursion is currently unsupported.

PiperOrigin-RevId: 371708957
Change-Id: I8dfad0d85cbfe08e39ae8ea7bad21254ddee5003",c6173f5fe66cdbab74f4f869311fe6aae2ba35f4,https://github.com/tensorflow/tensorflow/commit/c6173f5fe66cdbab74f4f869311fe6aae2ba35f4,tensorflow/lite/kernels/while.cc,Prepare,"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
OpData* op_data = reinterpret_cast<OpData*>(node->user_data);
int num_inputs = node->inputs->size;
TF_LITE_ENSURE_EQ(context, node->outputs->size, num_inputs);
Subgraph* this_subgraph = reinterpret_cast<Subgraph*>(context->impl_);
auto* subgraphs = this_subgraph->GetSubgraphs();
TF_LITE_ENSURE(context, op_data->cond_subgraph_index < subgraphs->size());
TF_LITE_ENSURE(context, op_data->body_subgraph_index < subgraphs->size());
TF_LITE_ENSURE(context,
op_data->cond_subgraph_index != op_data->body_subgraph_index);
Subgraph* cond_subgraph = (*subgraphs)[op_data->cond_subgraph_index].get();
Subgraph* body_subgraph = (*subgraphs)[op_data->body_subgraph_index].get();
TF_LITE_ENSURE_EQ(context, cond_subgraph->inputs().size(), num_inputs);
TF_LITE_ENSURE_EQ(context, cond_subgraph->outputs().size(), 1);
TF_LITE_ENSURE_EQ(context, body_subgraph->inputs().size(), num_inputs);
TF_LITE_ENSURE_EQ(context, body_subgraph->outputs().size(), num_inputs);
TF_LITE_ENSURE_OK(
context, CopyTensorsShapeAndType(
context, this_subgraph, TfLiteIntArrayView(node->inputs),
cond_subgraph, cond_subgraph->inputs(), true));
TF_LITE_ENSURE_OK(context, cond_subgraph->AllocateTensors());
TfLiteTensor* cond_output =
cond_subgraph->tensor(cond_subgraph->outputs()[0]);
if (IsDynamicTensor(cond_output)) {
op_data->cond_has_dynamic_output_tensors = true;
} else {
TF_LITE_ENSURE_STATUS(CheckCondOutput(context, cond_output));
}
TF_LITE_ENSURE_OK(
context, CopyTensorsShapeAndType(
context, this_subgraph, TfLiteIntArrayView(node->inputs),
body_subgraph, body_subgraph->inputs(), true));
TF_LITE_ENSURE_OK(context, body_subgraph->AllocateTensors());
if (body_subgraph->HasDynamicTensors()) {
op_data->body_has_dynamic_output_tensors = true;
} else {
for (int i = 0; i < num_inputs; ++i) {
TfLiteTensor* body_input =
body_subgraph->tensor(body_subgraph->inputs()[i]);
TfLiteTensor* body_output =
body_subgraph->tensor(body_subgraph->outputs()[i]);
TF_LITE_ENSURE_TYPES_EQ(context, body_input->type, body_output->type);
TF_LITE_ENSURE(context, !IsDynamicTensor(body_output));
if (!TfLiteIntArrayEqual(body_input->dims, body_output->dims)) {
op_data->body_has_dynamic_output_tensors = true;
break;
}
}
}
for (int i = 0; i < num_inputs; ++i) {
TfLiteTensor* output;
TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));
if (op_data->body_has_dynamic_output_tensors) {
SetTensorToDynamic(output);
} else {
TfLiteTensor* body_output =
body_subgraph->tensor(body_subgraph->outputs()[i]);
TfLiteIntArray* output_size = TfLiteIntArrayCopy(body_output->dims);
TF_LITE_ENSURE_OK(context,
context->ResizeTensor(context, output, output_size));
}
}
return kTfLiteOk;
}","TfLiteStatus Prepare(TfLiteContext* VAR_0, TfLiteNode* VAR_1) {
OpData* VAR_2 = VAR_3<OpData*>(VAR_1->user_data);
int VAR_4 = VAR_1->inputs->size;
TF_LITE_ENSURE_EQ(VAR_0, VAR_1->outputs->size, VAR_4);
Subgraph* VAR_5 = VAR_3<Subgraph*>(VAR_0->impl_);
auto* VAR_6 = VAR_5->GetSubgraphs();
TF_LITE_ENSURE(VAR_0, VAR_2->cond_subgraph_index < VAR_6->size());
TF_LITE_ENSURE(VAR_0, VAR_2->body_subgraph_index < VAR_6->size());
TF_LITE_ENSURE(VAR_0,
VAR_2->cond_subgraph_index != VAR_2->body_subgraph_index);
Subgraph* VAR_7 = (*VAR_6)[VAR_2->cond_subgraph_index].get();
Subgraph* VAR_8 = (*VAR_6)[VAR_2->body_subgraph_index].get();
TF_LITE_ENSURE_EQ(VAR_0, VAR_7->inputs().size(), VAR_4);
TF_LITE_ENSURE_EQ(VAR_0, VAR_7->outputs().size(), 1);
TF_LITE_ENSURE_EQ(VAR_0, VAR_8->inputs().size(), VAR_4);
TF_LITE_ENSURE_EQ(VAR_0, VAR_8->outputs().size(), VAR_4);
TF_LITE_ENSURE_OK(
VAR_0, CopyTensorsShapeAndType(
VAR_0, VAR_5, TfLiteIntArrayView(VAR_1->inputs),
VAR_7, VAR_7->inputs(), true));
TF_LITE_ENSURE_OK(VAR_0, VAR_7->AllocateTensors());
TfLiteTensor* VAR_9 =
VAR_7->tensor(VAR_7->outputs()[0]);
if (IsDynamicTensor(VAR_9)) {
VAR_2->cond_has_dynamic_output_tensors = true;
} else {
TF_LITE_ENSURE_STATUS(CheckCondOutput(VAR_0, VAR_9));
}
TF_LITE_ENSURE_OK(
VAR_0, CopyTensorsShapeAndType(
VAR_0, VAR_5, TfLiteIntArrayView(VAR_1->inputs),
VAR_8, VAR_8->inputs(), true));
TF_LITE_ENSURE_OK(VAR_0, VAR_8->AllocateTensors());
if (VAR_8->HasDynamicTensors()) {
VAR_2->body_has_dynamic_output_tensors = true;
} else {
for (int VAR_10 = 0; VAR_10 < VAR_4; ++VAR_10) {
TfLiteTensor* VAR_11 =
VAR_8->tensor(VAR_8->inputs()[VAR_10]);
TfLiteTensor* VAR_12 =
VAR_8->tensor(VAR_8->outputs()[VAR_10]);
TF_LITE_ENSURE_TYPES_EQ(VAR_0, VAR_11->type, VAR_12->type);
TF_LITE_ENSURE(VAR_0, !IsDynamicTensor(VAR_12));
if (!TfLiteIntArrayEqual(VAR_11->dims, VAR_12->dims)) {
VAR_2->body_has_dynamic_output_tensors = true;
break;
}
}
}
for (int VAR_10 = 0; VAR_10 < VAR_4; ++VAR_10) {
TfLiteTensor* VAR_13;
TF_LITE_ENSURE_OK(VAR_0, GetOutputSafe(VAR_0, VAR_1, VAR_10, &VAR_13));
if (VAR_2->body_has_dynamic_output_tensors) {
SetTensorToDynamic(VAR_13);
} else {
TfLiteTensor* VAR_12 =
VAR_8->tensor(VAR_8->outputs()[VAR_10]);
TfLiteIntArray* VAR_14 = TfLiteIntArrayCopy(VAR_12->dims);
TF_LITE_ENSURE_OK(VAR_0,
VAR_0->ResizeTensor(VAR_0, VAR_13, VAR_14));
}
}
return VAR_15;
}",tensorflow/c6173f5fe66cdbab74f4f869311fe6aae2ba35f4/while.cc/vul/before/0.json,"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);
  int num_inputs = node->inputs->size;
  // The number of outputs should be the same as number of inputs.
  TF_LITE_ENSURE_EQ(context, node->outputs->size, num_inputs);

  // Check subgraph indices and get subgraphs.
  Subgraph* this_subgraph = reinterpret_cast<Subgraph*>(context->impl_);
  auto* subgraphs = this_subgraph->GetSubgraphs();
  TF_LITE_ENSURE(context, op_data->cond_subgraph_index < subgraphs->size());
  TF_LITE_ENSURE(context, op_data->body_subgraph_index < subgraphs->size());

  Subgraph* cond_subgraph = (*subgraphs)[op_data->cond_subgraph_index].get();
  Subgraph* body_subgraph = (*subgraphs)[op_data->body_subgraph_index].get();

  // Check input & output count of the condition subgraph.
  TF_LITE_ENSURE_EQ(context, cond_subgraph->inputs().size(), num_inputs);
  TF_LITE_ENSURE_EQ(context, cond_subgraph->outputs().size(), 1);

  // Check input & output count of the body subgraph.
  TF_LITE_ENSURE_EQ(context, body_subgraph->inputs().size(), num_inputs);
  TF_LITE_ENSURE_EQ(context, body_subgraph->outputs().size(), num_inputs);

  // Prepare and check the condition subgraph.
  TF_LITE_ENSURE_OK(
      context, CopyTensorsShapeAndType(
                   context, this_subgraph, TfLiteIntArrayView(node->inputs),
                   cond_subgraph, cond_subgraph->inputs(), true));
  TF_LITE_ENSURE_OK(context, cond_subgraph->AllocateTensors());
  TfLiteTensor* cond_output =
      cond_subgraph->tensor(cond_subgraph->outputs()[0]);
  // This should rarely happens. In most cases the output is static with shape
  // [1]. However theoretically intermediate tensors in the cond subgraph
  // can be dynamic.
  if (IsDynamicTensor(cond_output)) {
    op_data->cond_has_dynamic_output_tensors = true;
  } else {
    TF_LITE_ENSURE_STATUS(CheckCondOutput(context, cond_output));
  }

  // Prepare and check the body subgraph.
  TF_LITE_ENSURE_OK(
      context, CopyTensorsShapeAndType(
                   context, this_subgraph, TfLiteIntArrayView(node->inputs),
                   body_subgraph, body_subgraph->inputs(), true));
  TF_LITE_ENSURE_OK(context, body_subgraph->AllocateTensors());
  if (body_subgraph->HasDynamicTensors()) {
    op_data->body_has_dynamic_output_tensors = true;
  } else {
    for (int i = 0; i < num_inputs; ++i) {
      TfLiteTensor* body_input =
          body_subgraph->tensor(body_subgraph->inputs()[i]);
      TfLiteTensor* body_output =
          body_subgraph->tensor(body_subgraph->outputs()[i]);
      TF_LITE_ENSURE_TYPES_EQ(context, body_input->type, body_output->type);

      TF_LITE_ENSURE(context, !IsDynamicTensor(body_output));
      if (!TfLiteIntArrayEqual(body_input->dims, body_output->dims)) {
        // If the output shape of the body subgraph is static w.r.t. a fixed
        // input size, but it's different from input size, it's still considered
        // dynamic. For example: If a subgraph keeps padding its input with a
        // fixed padding, the output shape is static w.r.t the input shape and
        // padding, but running it in a loop will keep bloating the tensor.
        op_data->body_has_dynamic_output_tensors = true;
        break;
      }
    }
  }
  for (int i = 0; i < num_inputs; ++i) {
    TfLiteTensor* output;
    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));
    if (op_data->body_has_dynamic_output_tensors) {
      SetTensorToDynamic(output);
    } else {
      TfLiteTensor* body_output =
          body_subgraph->tensor(body_subgraph->outputs()[i]);
      TfLiteIntArray* output_size = TfLiteIntArrayCopy(body_output->dims);
      TF_LITE_ENSURE_OK(context,
                        context->ResizeTensor(context, output, output_size));
    }
  }
  return kTfLiteOk;
}","TfLiteStatus Prepare(TfLiteContext* VAR_0, TfLiteNode* VAR_1) {
  OpData* VAR_2 = VAR_3<OpData*>(VAR_1->user_data);
  int VAR_4 = VAR_1->inputs->size;
  /* COMMENT_0 */
  TF_LITE_ENSURE_EQ(VAR_0, VAR_1->outputs->size, VAR_4);

  /* COMMENT_1 */
  Subgraph* VAR_5 = VAR_3<Subgraph*>(VAR_0->impl_);
  auto* VAR_6 = VAR_5->GetSubgraphs();
  TF_LITE_ENSURE(VAR_0, VAR_2->cond_subgraph_index < VAR_6->size());
  TF_LITE_ENSURE(VAR_0, VAR_2->body_subgraph_index < VAR_6->size());

  Subgraph* VAR_7 = (*VAR_6)[VAR_2->cond_subgraph_index].get();
  Subgraph* VAR_8 = (*VAR_6)[VAR_2->body_subgraph_index].get();

  /* COMMENT_2 */
  TF_LITE_ENSURE_EQ(VAR_0, VAR_7->inputs().size(), VAR_4);
  TF_LITE_ENSURE_EQ(VAR_0, VAR_7->outputs().size(), 1);

  /* COMMENT_3 */
  TF_LITE_ENSURE_EQ(VAR_0, VAR_8->inputs().size(), VAR_4);
  TF_LITE_ENSURE_EQ(VAR_0, VAR_8->outputs().size(), VAR_4);

  /* COMMENT_4 */
  TF_LITE_ENSURE_OK(
      VAR_0, CopyTensorsShapeAndType(
                   VAR_0, VAR_5, TfLiteIntArrayView(VAR_1->inputs),
                   VAR_7, VAR_7->inputs(), true));
  TF_LITE_ENSURE_OK(VAR_0, VAR_7->AllocateTensors());
  TfLiteTensor* VAR_9 =
      VAR_7->tensor(VAR_7->outputs()[0]);
  /* COMMENT_5 */
  /* COMMENT_6 */
  /* COMMENT_7 */
  if (IsDynamicTensor(VAR_9)) {
    VAR_2->cond_has_dynamic_output_tensors = true;
  } else {
    TF_LITE_ENSURE_STATUS(CheckCondOutput(VAR_0, VAR_9));
  }

  /* COMMENT_8 */
  TF_LITE_ENSURE_OK(
      VAR_0, CopyTensorsShapeAndType(
                   VAR_0, VAR_5, TfLiteIntArrayView(VAR_1->inputs),
                   VAR_8, VAR_8->inputs(), true));
  TF_LITE_ENSURE_OK(VAR_0, VAR_8->AllocateTensors());
  if (VAR_8->HasDynamicTensors()) {
    VAR_2->body_has_dynamic_output_tensors = true;
  } else {
    for (int VAR_10 = 0; VAR_10 < VAR_4; ++VAR_10) {
      TfLiteTensor* VAR_11 =
          VAR_8->tensor(VAR_8->inputs()[VAR_10]);
      TfLiteTensor* VAR_12 =
          VAR_8->tensor(VAR_8->outputs()[VAR_10]);
      TF_LITE_ENSURE_TYPES_EQ(VAR_0, VAR_11->type, VAR_12->type);

      TF_LITE_ENSURE(VAR_0, !IsDynamicTensor(VAR_12));
      if (!TfLiteIntArrayEqual(VAR_11->dims, VAR_12->dims)) {
        /* COMMENT_9 */
        /* COMMENT_10 */
        /* COMMENT_11 */
        /* COMMENT_12 */
        /* COMMENT_13 */
        VAR_2->body_has_dynamic_output_tensors = true;
        break;
      }
    }
  }
  for (int VAR_10 = 0; VAR_10 < VAR_4; ++VAR_10) {
    TfLiteTensor* VAR_13;
    TF_LITE_ENSURE_OK(VAR_0, GetOutputSafe(VAR_0, VAR_1, VAR_10, &VAR_13));
    if (VAR_2->body_has_dynamic_output_tensors) {
      SetTensorToDynamic(VAR_13);
    } else {
      TfLiteTensor* VAR_12 =
          VAR_8->tensor(VAR_8->outputs()[VAR_10]);
      TfLiteIntArray* VAR_14 = TfLiteIntArrayCopy(VAR_12->dims);
      TF_LITE_ENSURE_OK(VAR_0,
                        VAR_0->ResizeTensor(VAR_0, VAR_13, VAR_14));
    }
  }
  return VAR_15;
}",tensorflow/c6173f5fe66cdbab74f4f869311fe6aae2ba35f4/while.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,8 +9,6 @@
   auto* subgraphs = this_subgraph->GetSubgraphs();
   TF_LITE_ENSURE(context, op_data->cond_subgraph_index < subgraphs->size());
   TF_LITE_ENSURE(context, op_data->body_subgraph_index < subgraphs->size());
-  TF_LITE_ENSURE(context,
-                 op_data->cond_subgraph_index != op_data->body_subgraph_index);
 
   Subgraph* cond_subgraph = (*subgraphs)[op_data->cond_subgraph_index].get();
   Subgraph* body_subgraph = (*subgraphs)[op_data->body_subgraph_index].get();","{'deleted_lines': ['  TF_LITE_ENSURE(context,', '                 op_data->cond_subgraph_index != op_data->body_subgraph_index);'], 'added_lines': []}",True,"TensorFlow is an end-to-end open source platform for machine learning. TFlite graphs must not have loops between nodes. However, this condition was not checked and an attacker could craft models that would result in infinite loop during evaluation. In certain cases, the infinite loop would be replaced by stack overflow due to too many recursive calls. For example, the `While` implementation(https://github.com/tensorflow/tensorflow/blob/106d8f4fb89335a2c52d7c895b7a7485465ca8d9/tensorflow/lite/kernels/while.cc) could be tricked into a scneario where both the body and the loop subgraphs are the same. Evaluating one of the subgraphs means calling the `Eval` function for the other and this quickly exhaust all stack space. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range. Please consult our security guide(https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.",7.3,HIGH,2,valid,2021-05-03T16:07:42Z,3
CVE-2021-29565,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,tensorflow,"Fix heap-buffer-overflow issue with `tf.raw_ops.SparseFillEmptyRows`.

PiperOrigin-RevId: 372009178
Change-Id: Ia1a9e9691ecaa072f32fb39a0887b2aabd399210",faa76f39014ed3b5e2c158593b1335522e573c7f,https://github.com/tensorflow/tensorflow/commit/faa76f39014ed3b5e2c158593b1335522e573c7f,tensorflow/core/kernels/sparse_fill_empty_rows_op.cc,SparseFillEmptyRowsOpImpl,"void SparseFillEmptyRowsOpImpl(OpKernelContext* context,
AsyncOpKernel::DoneCallback done = nullptr) {
if (!done) {
done = [] {};
}
const int kIndicesInput = 0;
const int kValuesInput = 1;
const int kDenseShapeInput = 2;
const int kDefaultValueInput = 3;
const Tensor& indices_t = context->input(kIndicesInput);
const Tensor& values_t = context->input(kValuesInput);
const Tensor& dense_shape_t = context->input(kDenseShapeInput);
const Tensor& default_value_t = context->input(kDefaultValueInput);
OP_REQUIRES_ASYNC(
context, TensorShapeUtils::IsVector(dense_shape_t.shape()),
errors::InvalidArgument(""dense_shape must be a vector, saw: "",
dense_shape_t.shape().DebugString()),
done);
OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),
errors::InvalidArgument(""indices must be a matrix, saw: "",
indices_t.shape().DebugString()),
done);
OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),
errors::InvalidArgument(""values must be a vector, saw: "",
values_t.shape().DebugString()),
done);
OP_REQUIRES_ASYNC(
context, TensorShapeUtils::IsScalar(default_value_t.shape()),
errors::InvalidArgument(""default_value must be a scalar, saw: "",
default_value_t.shape().DebugString()),
done);
using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;
OP_REQUIRES_OK_ASYNC(context,
FunctorType()(context, default_value_t, indices_t,
values_t, dense_shape_t, done),
done);
}","void SparseFillEmptyRowsOpImpl(OpKernelContext* VAR_0,
AsyncOpKernel::DoneCallback VAR_1 = nullptr) {
if (!VAR_1) {
VAR_1 = [] {};
}
const int VAR_2 = 0;
const int VAR_3 = 1;
const int VAR_4 = 2;
const int VAR_5 = 3;
const Tensor& VAR_6 = VAR_0->input(VAR_2);
const Tensor& VAR_7 = VAR_0->input(VAR_3);
const Tensor& VAR_8 = VAR_0->input(VAR_4);
const Tensor& VAR_9 = VAR_0->input(VAR_5);
OP_REQUIRES_ASYNC(
VAR_0, TensorShapeUtils::IsVector(VAR_8.shape()),
errors::InvalidArgument(""dense_shape must be a vector, saw: "",
VAR_8.shape().DebugString()),
VAR_1);
OP_REQUIRES_ASYNC(VAR_0, TensorShapeUtils::IsMatrix(VAR_6.shape()),
errors::InvalidArgument(""indices must be a matrix, saw: "",
VAR_6.shape().DebugString()),
VAR_1);
OP_REQUIRES_ASYNC(VAR_0, TensorShapeUtils::IsVector(VAR_7.shape()),
errors::InvalidArgument(""values must be a vector, saw: "",
VAR_7.shape().DebugString()),
VAR_1);
OP_REQUIRES_ASYNC(
VAR_0, TensorShapeUtils::IsScalar(VAR_9.shape()),
errors::InvalidArgument(""default_value must be a scalar, saw: "",
VAR_9.shape().DebugString()),
VAR_1);
using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;
OP_REQUIRES_OK_ASYNC(VAR_0,
FunctorType()(VAR_0, VAR_9, VAR_6,
VAR_7, VAR_8, VAR_1),
VAR_1);
}",tensorflow/faa76f39014ed3b5e2c158593b1335522e573c7f/sparse_fill_empty_rows_op.cc/vul/before/0.json,"void SparseFillEmptyRowsOpImpl(OpKernelContext* context,
                               AsyncOpKernel::DoneCallback done = nullptr) {
  // Note that setting this empty lambda as the default parameter value directly
  // can cause strange compiler/linker errors, so we do it like this instead.
  if (!done) {
    done = [] {};
  }

  const int kIndicesInput = 0;
  const int kValuesInput = 1;
  const int kDenseShapeInput = 2;
  const int kDefaultValueInput = 3;

  const Tensor& indices_t = context->input(kIndicesInput);
  const Tensor& values_t = context->input(kValuesInput);
  const Tensor& dense_shape_t = context->input(kDenseShapeInput);
  const Tensor& default_value_t = context->input(kDefaultValueInput);

  OP_REQUIRES_ASYNC(
      context, TensorShapeUtils::IsVector(dense_shape_t.shape()),
      errors::InvalidArgument(""dense_shape must be a vector, saw: "",
                              dense_shape_t.shape().DebugString()),
      done);
  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),
                    errors::InvalidArgument(""indices must be a matrix, saw: "",
                                            indices_t.shape().DebugString()),
                    done);
  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),
                    errors::InvalidArgument(""values must be a vector, saw: "",
                                            values_t.shape().DebugString()),
                    done);
  OP_REQUIRES_ASYNC(
      context, TensorShapeUtils::IsScalar(default_value_t.shape()),
      errors::InvalidArgument(""default_value must be a scalar, saw: "",
                              default_value_t.shape().DebugString()),
      done);
  // TODO(ebrevdo): add shape checks between values, indices,
  // Also add check that dense rank > 0.
  OP_REQUIRES_ASYNC(context, dense_shape_t.NumElements() != 0,
                    errors::InvalidArgument(""Dense shape cannot be empty.""),
                    done);

  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;
  OP_REQUIRES_OK_ASYNC(context,
                       FunctorType()(context, default_value_t, indices_t,
                                     values_t, dense_shape_t, done),
                       done);
}","void SparseFillEmptyRowsOpImpl(OpKernelContext* VAR_0,
                               AsyncOpKernel::DoneCallback VAR_1 = nullptr) {
  /* COMMENT_0 */
  /* COMMENT_1 */
  if (!VAR_1) {
    VAR_1 = [] {};
  }

  const int VAR_2 = 0;
  const int VAR_3 = 1;
  const int VAR_4 = 2;
  const int VAR_5 = 3;

  const Tensor& VAR_6 = VAR_0->input(VAR_2);
  const Tensor& VAR_7 = VAR_0->input(VAR_3);
  const Tensor& VAR_8 = VAR_0->input(VAR_4);
  const Tensor& VAR_9 = VAR_0->input(VAR_5);

  OP_REQUIRES_ASYNC(
      VAR_0, TensorShapeUtils::IsVector(VAR_8.shape()),
      errors::InvalidArgument(""dense_shape must be a vector, saw: "",
                              VAR_8.shape().DebugString()),
      VAR_1);
  OP_REQUIRES_ASYNC(VAR_0, TensorShapeUtils::IsMatrix(VAR_6.shape()),
                    errors::InvalidArgument(""indices must be a matrix, saw: "",
                                            VAR_6.shape().DebugString()),
                    VAR_1);
  OP_REQUIRES_ASYNC(VAR_0, TensorShapeUtils::IsVector(VAR_7.shape()),
                    errors::InvalidArgument(""values must be a vector, saw: "",
                                            VAR_7.shape().DebugString()),
                    VAR_1);
  OP_REQUIRES_ASYNC(
      VAR_0, TensorShapeUtils::IsScalar(VAR_9.shape()),
      errors::InvalidArgument(""default_value must be a scalar, saw: "",
                              VAR_9.shape().DebugString()),
      VAR_1);
  /* COMMENT_2 */
  /* COMMENT_3 */
  OP_REQUIRES_ASYNC(VAR_0, VAR_8.NumElements() != 0,
                    errors::InvalidArgument(""Dense shape cannot be empty.""),
                    VAR_1);

  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;
  OP_REQUIRES_OK_ASYNC(VAR_0,
                       FunctorType()(VAR_0, VAR_9, VAR_6,
                                     VAR_7, VAR_8, VAR_1),
                       VAR_1);
}",tensorflow/faa76f39014ed3b5e2c158593b1335522e573c7f/sparse_fill_empty_rows_op.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -35,7 +35,10 @@
                               default_value_t.shape().DebugString()),
       done);
   // TODO(ebrevdo): add shape checks between values, indices,
-  // dense_shape.  Also add check that dense rank > 0.
+  // Also add check that dense rank > 0.
+  OP_REQUIRES_ASYNC(context, dense_shape_t.NumElements() != 0,
+                    errors::InvalidArgument(""Dense shape cannot be empty.""),
+                    done);
 
   using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;
   OP_REQUIRES_OK_ASYNC(context,","{'deleted_lines': ['  // dense_shape.  Also add check that dense rank > 0.'], 'added_lines': ['  // Also add check that dense rank > 0.', '  OP_REQUIRES_ASYNC(context, dense_shape_t.NumElements() != 0,', '                    errors::InvalidArgument(""Dense shape cannot be empty.""),', '                    done);']}",True,"TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference in the implementation of `tf.raw_ops.SparseFillEmptyRows`. This is because of missing validation(https://github.com/tensorflow/tensorflow/blob/fdc82089d206e281c628a93771336bf87863d5e8/tensorflow/core/kernels/sparse_fill_empty_rows_op.cc#L230-L231) that was covered under a `TODO`. If the `dense_shape` tensor is empty, then `dense_shape_t.vec<>()` would cause a null pointer dereference in the implementation of the op. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",2.5,LOW,0,valid,2021-05-04T22:35:39Z,3
CVE-2021-36088,['CWE-415'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,fluent/fluent-bit,"parser: json: fix double-free (#3453)

Signed-off-by: davkor <david@adalogics.com>",22346a74c07ceb90296be872be2d53eb92252a54,https://github.com/fluent/fluent-bit/commit/22346a74c07ceb90296be872be2d53eb92252a54,src/flb_parser_json.c,flb_parser_json_do,"int flb_parser_json_do(struct flb_parser *parser,
const char *in_buf, size_t in_size,
void **out_buf, size_t *out_size,
struct flb_time *out_time)
{
int i;
int skip;
int ret;
int slen;
int root_type;
int records;
double tmfrac = 0;
char *mp_buf = NULL;
char *time_key;
char *tmp_out_buf = NULL;
char tmp[255];
size_t tmp_out_size = 0;
size_t off = 0;
size_t map_size;
size_t mp_size;
size_t len;
msgpack_sbuffer mp_sbuf;
msgpack_packer  mp_pck;
msgpack_unpacked result;
msgpack_object map;
msgpack_object *k = NULL;
msgpack_object *v = NULL;
time_t time_lookup;
struct tm tm = {0};
struct flb_time *t;
ret = flb_pack_json_recs(in_buf, in_size, &mp_buf, &mp_size, &root_type,
&records);
if (ret != 0) {
return -1;
}
if (records != 1) {
flb_free(mp_buf);
return -1;
}
msgpack_unpacked_init(&result);
if (msgpack_unpack_next(&result, mp_buf, mp_size, &off) == MSGPACK_UNPACK_SUCCESS) {
map = result.data;
if (map.type != MSGPACK_OBJECT_MAP) {
flb_free(mp_buf);
msgpack_unpacked_destroy(&result);
return -1;
}
}
else {
if (mp_size > 0) {
flb_free(mp_buf);
}
msgpack_unpacked_destroy(&result);
return -1;
}
tmp_out_buf = mp_buf;
tmp_out_size = mp_size;
if (parser->decoders) {
ret = flb_parser_decoder_do(parser->decoders,
mp_buf, mp_size,
&tmp_out_buf, &tmp_out_size);
if (ret == 0) {
off = 0;
msgpack_unpacked_destroy(&result);
msgpack_unpacked_init(&result);
msgpack_unpack_next(&result, tmp_out_buf, tmp_out_size, &off);
map = result.data;
}
}
*out_buf = tmp_out_buf;
*out_size = tmp_out_size;
if (mp_buf != tmp_out_buf) {
flb_free(mp_buf);
}
if (!parser->time_fmt) {
msgpack_unpacked_destroy(&result);
return *out_size;
}
if (parser->time_key) {
time_key = parser->time_key;
}
else {
time_key = ""time"";
}
slen = strlen(time_key);
map_size = map.via.map.size;
skip = map_size;
for (i = 0; i < map_size; i++) {
k = &map.via.map.ptr[i].key;
v = &map.via.map.ptr[i].val;
if (k->via.str.size != slen) {
continue;
}
if (k->via.str.ptr == NULL) {
flb_free(mp_buf);
*out_buf = NULL;
msgpack_unpacked_destroy(&result);
return -1;
}
if (strncmp(k->via.str.ptr, time_key, k->via.str.size) == 0) {
if (parser->time_keep == FLB_FALSE) {
skip = i;
break;
}
else {
skip = -1;
}
break;
}
k = NULL;
v = NULL;
}
if (i >= map_size || !k || !v) {
msgpack_unpacked_destroy(&result);
return *out_size;
}
if (v->type != MSGPACK_OBJECT_STR) {
msgpack_unpacked_destroy(&result);
return *out_size;
}
ret = flb_parser_time_lookup(v->via.str.ptr, v->via.str.size,
0, parser, &tm, &tmfrac);
if (ret == -1) {
len = v->via.str.size;
if (len > sizeof(tmp) - 1) {
len = sizeof(tmp) - 1;
}
memcpy(tmp, v->via.str.ptr, len);
tmp[len] = '\0';
flb_warn(""[parser:%s] invalid time format %s for '%s'"",
parser->name, parser->time_fmt_full, tmp);
time_lookup = 0;
}
else {
time_lookup = flb_parser_tm2time(&tm);
}
msgpack_sbuffer_init(&mp_sbuf);
msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);
if (parser->time_keep == FLB_FALSE) {
msgpack_pack_map(&mp_pck, map_size - 1);
}
else {
msgpack_pack_map(&mp_pck, map_size);
}
for (i = 0; i < map_size; i++) {
if (i == skip) {
continue;
}
msgpack_pack_object(&mp_pck, map.via.map.ptr[i].key);
msgpack_pack_object(&mp_pck, map.via.map.ptr[i].val);
}
flb_free(tmp_out_buf);
*out_buf = mp_sbuf.data;
*out_size = mp_sbuf.size;
t = out_time;
t->tm.tv_sec  = time_lookup;
t->tm.tv_nsec = (tmfrac * 1000000000);
msgpack_unpacked_destroy(&result);
return *out_size;
}","int flb_parser_json_do(struct flb_parser *VAR_0,
const char *VAR_1, size_t VAR_2,
void **VAR_3, size_t *VAR_4,
struct flb_time *VAR_5)
{
int VAR_6;
int VAR_7;
int VAR_8;
int VAR_9;
int VAR_10;
int VAR_11;
double VAR_12 = 0;
char *VAR_13 = NULL;
char *VAR_14;
char *VAR_15 = NULL;
char VAR_16[255];
size_t VAR_17 = 0;
size_t VAR_18 = 0;
size_t VAR_19;
size_t VAR_20;
size_t VAR_21;
msgpack_sbuffer VAR_22;
msgpack_packer  VAR_23;
msgpack_unpacked VAR_24;
msgpack_object VAR_25;
msgpack_object *VAR_26 = NULL;
msgpack_object *VAR_27 = NULL;
time_t VAR_28;
struct tm tm = {0};
struct flb_time *VAR_29;
VAR_8 = flb_pack_json_recs(VAR_1, VAR_2, &VAR_13, &VAR_20, &VAR_10,
&VAR_11);
if (VAR_8 != 0) {
return -1;
}
if (VAR_11 != 1) {
flb_free(VAR_13);
return -1;
}
msgpack_unpacked_init(&VAR_24);
if (msgpack_unpack_next(&VAR_24, VAR_13, VAR_20, &VAR_18) == VAR_30) {
VAR_25 = VAR_24.data;
if (VAR_25.type != VAR_31) {
flb_free(VAR_13);
msgpack_unpacked_destroy(&VAR_24);
return -1;
}
}
else {
if (VAR_20 > 0) {
flb_free(VAR_13);
}
msgpack_unpacked_destroy(&VAR_24);
return -1;
}
VAR_15 = VAR_13;
VAR_17 = VAR_20;
if (VAR_0->decoders) {
VAR_8 = flb_parser_decoder_do(VAR_0->decoders,
VAR_13, VAR_20,
&VAR_15, &VAR_17);
if (VAR_8 == 0) {
VAR_18 = 0;
msgpack_unpacked_destroy(&VAR_24);
msgpack_unpacked_init(&VAR_24);
msgpack_unpack_next(&VAR_24, VAR_15, VAR_17, &VAR_18);
VAR_25 = VAR_24.data;
}
}
*VAR_3 = VAR_15;
*VAR_4 = VAR_17;
if (VAR_13 != VAR_15) {
flb_free(VAR_13);
}
if (!VAR_0->time_fmt) {
msgpack_unpacked_destroy(&VAR_24);
return *VAR_4;
}
if (VAR_0->time_key) {
VAR_14 = VAR_0->time_key;
}
else {
VAR_14 = ""time"";
}
VAR_9 = strlen(VAR_14);
VAR_19 = VAR_25.via.map.size;
VAR_7 = VAR_19;
for (VAR_6 = 0; VAR_6 < VAR_19; VAR_6++) {
VAR_26 = &VAR_25.via.map.ptr[VAR_6].key;
VAR_27 = &VAR_25.via.map.ptr[VAR_6].val;
if (VAR_26->via.str.size != VAR_9) {
continue;
}
if (VAR_26->via.str.ptr == NULL) {
flb_free(VAR_13);
*VAR_3 = NULL;
msgpack_unpacked_destroy(&VAR_24);
return -1;
}
if (strncmp(VAR_26->via.str.ptr, VAR_14, VAR_26->via.str.size) == 0) {
if (VAR_0->time_keep == VAR_32) {
VAR_7 = VAR_6;
break;
}
else {
VAR_7 = -1;
}
break;
}
VAR_26 = NULL;
VAR_27 = NULL;
}
if (VAR_6 >= VAR_19 || !VAR_26 || !VAR_27) {
msgpack_unpacked_destroy(&VAR_24);
return *VAR_4;
}
if (VAR_27->type != VAR_33) {
msgpack_unpacked_destroy(&VAR_24);
return *VAR_4;
}
VAR_8 = flb_parser_time_lookup(VAR_27->via.str.ptr, VAR_27->via.str.size,
0, VAR_0, &tm, &VAR_12);
if (VAR_8 == -1) {
VAR_21 = VAR_27->via.str.size;
if (VAR_21 > sizeof(VAR_16) - 1) {
VAR_21 = sizeof(VAR_16) - 1;
}
memcpy(VAR_16, VAR_27->via.str.ptr, VAR_21);
VAR_16[VAR_21] = '\0';
flb_warn(""[parser:%s] invalid time format %s for '%s'"",
VAR_0->name, VAR_0->time_fmt_full, VAR_16);
VAR_28 = 0;
}
else {
VAR_28 = flb_parser_tm2time(&tm);
}
msgpack_sbuffer_init(&VAR_22);
msgpack_packer_init(&VAR_23, &VAR_22, VAR_34);
if (VAR_0->time_keep == VAR_32) {
msgpack_pack_map(&VAR_23, VAR_19 - 1);
}
else {
msgpack_pack_map(&VAR_23, VAR_19);
}
for (VAR_6 = 0; VAR_6 < VAR_19; VAR_6++) {
if (VAR_6 == VAR_7) {
continue;
}
msgpack_pack_object(&VAR_23, VAR_25.via.map.ptr[VAR_6].key);
msgpack_pack_object(&VAR_23, VAR_25.via.map.ptr[VAR_6].val);
}
flb_free(VAR_15);
*VAR_3 = VAR_22.data;
*VAR_4 = VAR_22.size;
VAR_29 = VAR_5;
VAR_29->tm.tv_sec  = VAR_28;
VAR_29->tm.tv_nsec = (VAR_12 * 1000000000);
msgpack_unpacked_destroy(&VAR_24);
return *VAR_4;
}",fluent/fluent-bit/22346a74c07ceb90296be872be2d53eb92252a54/flb_parser_json.c/vul/before/0.json,"int flb_parser_json_do(struct flb_parser *parser,
                       const char *in_buf, size_t in_size,
                       void **out_buf, size_t *out_size,
                       struct flb_time *out_time)
{
    int i;
    int skip;
    int ret;
    int slen;
    int root_type;
    int records;
    double tmfrac = 0;
    char *mp_buf = NULL;
    char *time_key;
    char *tmp_out_buf = NULL;
    char tmp[255];
    size_t tmp_out_size = 0;
    size_t off = 0;
    size_t map_size;
    size_t mp_size;
    size_t len;
    msgpack_sbuffer mp_sbuf;
    msgpack_packer  mp_pck;
    msgpack_unpacked result;
    msgpack_object map;
    msgpack_object *k = NULL;
    msgpack_object *v = NULL;
    time_t time_lookup;
    struct tm tm = {0};
    struct flb_time *t;

    /* Convert incoming in_buf JSON message to message pack format */
    ret = flb_pack_json_recs(in_buf, in_size, &mp_buf, &mp_size, &root_type,
                             &records);
    if (ret != 0) {
        return -1;
    }

    if (records != 1) {
        flb_free(mp_buf);
        return -1;
    }

    /* Make sure object is a map */
    msgpack_unpacked_init(&result);
    if (msgpack_unpack_next(&result, mp_buf, mp_size, &off) == MSGPACK_UNPACK_SUCCESS) {
        map = result.data;
        if (map.type != MSGPACK_OBJECT_MAP) {
            flb_free(mp_buf);
            msgpack_unpacked_destroy(&result);
            return -1;
        }
    }
    else {
        if (mp_size > 0) {
            flb_free(mp_buf);
        }
        msgpack_unpacked_destroy(&result);
        return -1;
    }

    /* Export results (might change later) */
    tmp_out_buf = mp_buf;
    tmp_out_size = mp_size;

    /* Do we have some decoders set ? */
    if (parser->decoders) {
        ret = flb_parser_decoder_do(parser->decoders,
                                    mp_buf, mp_size,
                                    &tmp_out_buf, &tmp_out_size);
        if (ret == 0) {
            /* re-process the unpack context */
            off = 0;
            msgpack_unpacked_destroy(&result);
            msgpack_unpacked_init(&result);
            msgpack_unpack_next(&result, tmp_out_buf, tmp_out_size, &off);
            map = result.data;
        }
    }

    /* Set the possible outgoing buffer */
    *out_buf = tmp_out_buf;
    *out_size = tmp_out_size;
    if (mp_buf != tmp_out_buf) {
        flb_free(mp_buf);
        mp_buf = NULL;
    }

    /* Do time resolution ? */
    if (!parser->time_fmt) {
        msgpack_unpacked_destroy(&result);
        return *out_size;
    }

    if (parser->time_key) {
        time_key = parser->time_key;
    }
    else {
        time_key = ""time"";
    }
    slen = strlen(time_key);

    /* Lookup time field */
    map_size = map.via.map.size;
    skip = map_size;
    for (i = 0; i < map_size; i++) {
        k = &map.via.map.ptr[i].key;
        v = &map.via.map.ptr[i].val;

        if (k->via.str.size != slen) {
            continue;
        }

        /* Ensure the pointer we are about to read is not NULL */
        if (k->via.str.ptr == NULL) {
            flb_free(mp_buf);
            flb_free(tmp_out_buf);
            *out_buf = NULL;
            msgpack_unpacked_destroy(&result);
            return -1;
        }

        if (strncmp(k->via.str.ptr, time_key, k->via.str.size) == 0) {
            /* We found the key, break the loop and keep the index */
            if (parser->time_keep == FLB_FALSE) {
                skip = i;
                break;
            }
            else {
                skip = -1;
            }
            break;
        }

        k = NULL;
        v = NULL;
    }

    /* No time_key field found */
    if (i >= map_size || !k || !v) {
        msgpack_unpacked_destroy(&result);
        return *out_size;
    }

    /* Ensure we have an accurate type */
    if (v->type != MSGPACK_OBJECT_STR) {
        msgpack_unpacked_destroy(&result);
        return *out_size;
    }

    /* Lookup time */
    ret = flb_parser_time_lookup(v->via.str.ptr, v->via.str.size,
                                 0, parser, &tm, &tmfrac);
    if (ret == -1) {
        len = v->via.str.size;
        if (len > sizeof(tmp) - 1) {
            len = sizeof(tmp) - 1;
        }
        memcpy(tmp, v->via.str.ptr, len);
        tmp[len] = '\0';
        flb_warn(""[parser:%s] invalid time format %s for '%s'"",
                 parser->name, parser->time_fmt_full, tmp);
        time_lookup = 0;
    }
    else {
        time_lookup = flb_parser_tm2time(&tm);
    }

    /* Compose a new map without the time_key field */
    msgpack_sbuffer_init(&mp_sbuf);
    msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);

    if (parser->time_keep == FLB_FALSE) {
        msgpack_pack_map(&mp_pck, map_size - 1);
    }
    else {
        msgpack_pack_map(&mp_pck, map_size);
    }

    for (i = 0; i < map_size; i++) {
        if (i == skip) {
            continue;
        }
        msgpack_pack_object(&mp_pck, map.via.map.ptr[i].key);
        msgpack_pack_object(&mp_pck, map.via.map.ptr[i].val);
    }

    /* Export the proper buffer */
    flb_free(tmp_out_buf);
    *out_buf = mp_sbuf.data;
    *out_size = mp_sbuf.size;

    t = out_time;
    t->tm.tv_sec  = time_lookup;
    t->tm.tv_nsec = (tmfrac * 1000000000);

    msgpack_unpacked_destroy(&result);
    return *out_size;
}","int flb_parser_json_do(struct flb_parser *VAR_0,
                       const char *VAR_1, size_t VAR_2,
                       void **VAR_3, size_t *VAR_4,
                       struct flb_time *VAR_5)
{
    int VAR_6;
    int VAR_7;
    int VAR_8;
    int VAR_9;
    int VAR_10;
    int VAR_11;
    double VAR_12 = 0;
    char *VAR_13 = NULL;
    char *VAR_14;
    char *VAR_15 = NULL;
    char VAR_16[255];
    size_t VAR_17 = 0;
    size_t VAR_18 = 0;
    size_t VAR_19;
    size_t VAR_20;
    size_t VAR_21;
    msgpack_sbuffer VAR_22;
    msgpack_packer  VAR_23;
    msgpack_unpacked VAR_24;
    msgpack_object VAR_25;
    msgpack_object *VAR_26 = NULL;
    msgpack_object *VAR_27 = NULL;
    time_t VAR_28;
    struct tm tm = {0};
    struct flb_time *VAR_29;

    /* COMMENT_0 */
    VAR_8 = flb_pack_json_recs(VAR_1, VAR_2, &VAR_13, &VAR_20, &VAR_10,
                             &VAR_11);
    if (VAR_8 != 0) {
        return -1;
    }

    if (VAR_11 != 1) {
        flb_free(VAR_13);
        return -1;
    }

    /* COMMENT_1 */
    msgpack_unpacked_init(&VAR_24);
    if (msgpack_unpack_next(&VAR_24, VAR_13, VAR_20, &VAR_18) == VAR_30) {
        VAR_25 = VAR_24.data;
        if (VAR_25.type != VAR_31) {
            flb_free(VAR_13);
            msgpack_unpacked_destroy(&VAR_24);
            return -1;
        }
    }
    else {
        if (VAR_20 > 0) {
            flb_free(VAR_13);
        }
        msgpack_unpacked_destroy(&VAR_24);
        return -1;
    }

    /* COMMENT_2 */
    VAR_15 = VAR_13;
    VAR_17 = VAR_20;

    /* COMMENT_3 */
    if (VAR_0->decoders) {
        VAR_8 = flb_parser_decoder_do(VAR_0->decoders,
                                    VAR_13, VAR_20,
                                    &VAR_15, &VAR_17);
        if (VAR_8 == 0) {
            /* COMMENT_4 */
            VAR_18 = 0;
            msgpack_unpacked_destroy(&VAR_24);
            msgpack_unpacked_init(&VAR_24);
            msgpack_unpack_next(&VAR_24, VAR_15, VAR_17, &VAR_18);
            VAR_25 = VAR_24.data;
        }
    }

    /* COMMENT_5 */
    *VAR_3 = VAR_15;
    *VAR_4 = VAR_17;
    if (VAR_13 != VAR_15) {
        flb_free(VAR_13);
        VAR_13 = NULL;
    }

    /* COMMENT_6 */
    if (!VAR_0->time_fmt) {
        msgpack_unpacked_destroy(&VAR_24);
        return *VAR_4;
    }

    if (VAR_0->time_key) {
        VAR_14 = VAR_0->time_key;
    }
    else {
        VAR_14 = ""time"";
    }
    VAR_9 = strlen(VAR_14);

    /* COMMENT_7 */
    VAR_19 = VAR_25.via.map.size;
    VAR_7 = VAR_19;
    for (VAR_6 = 0; VAR_6 < VAR_19; VAR_6++) {
        VAR_26 = &VAR_25.via.map.ptr[VAR_6].key;
        VAR_27 = &VAR_25.via.map.ptr[VAR_6].val;

        if (VAR_26->via.str.size != VAR_9) {
            continue;
        }

        /* COMMENT_8 */
        if (VAR_26->via.str.ptr == NULL) {
            flb_free(VAR_13);
            flb_free(VAR_15);
            *VAR_3 = NULL;
            msgpack_unpacked_destroy(&VAR_24);
            return -1;
        }

        if (strncmp(VAR_26->via.str.ptr, VAR_14, VAR_26->via.str.size) == 0) {
            /* COMMENT_9 */
            if (VAR_0->time_keep == VAR_32) {
                VAR_7 = VAR_6;
                break;
            }
            else {
                VAR_7 = -1;
            }
            break;
        }

        VAR_26 = NULL;
        VAR_27 = NULL;
    }

    /* COMMENT_10 */
    if (VAR_6 >= VAR_19 || !VAR_26 || !VAR_27) {
        msgpack_unpacked_destroy(&VAR_24);
        return *VAR_4;
    }

    /* COMMENT_11 */
    if (VAR_27->type != VAR_33) {
        msgpack_unpacked_destroy(&VAR_24);
        return *VAR_4;
    }

    /* COMMENT_12 */
    VAR_8 = flb_parser_time_lookup(VAR_27->via.str.ptr, VAR_27->via.str.size,
                                 0, VAR_0, &tm, &VAR_12);
    if (VAR_8 == -1) {
        VAR_21 = VAR_27->via.str.size;
        if (VAR_21 > sizeof(VAR_16) - 1) {
            VAR_21 = sizeof(VAR_16) - 1;
        }
        memcpy(VAR_16, VAR_27->via.str.ptr, VAR_21);
        VAR_16[VAR_21] = '\0';
        flb_warn(""[parser:%s] invalid time format %s for '%s'"",
                 VAR_0->name, VAR_0->time_fmt_full, VAR_16);
        VAR_28 = 0;
    }
    else {
        VAR_28 = flb_parser_tm2time(&tm);
    }

    /* COMMENT_13 */
    msgpack_sbuffer_init(&VAR_22);
    msgpack_packer_init(&VAR_23, &VAR_22, VAR_34);

    if (VAR_0->time_keep == VAR_32) {
        msgpack_pack_map(&VAR_23, VAR_19 - 1);
    }
    else {
        msgpack_pack_map(&VAR_23, VAR_19);
    }

    for (VAR_6 = 0; VAR_6 < VAR_19; VAR_6++) {
        if (VAR_6 == VAR_7) {
            continue;
        }
        msgpack_pack_object(&VAR_23, VAR_25.via.map.ptr[VAR_6].key);
        msgpack_pack_object(&VAR_23, VAR_25.via.map.ptr[VAR_6].val);
    }

    /* COMMENT_14 */
    flb_free(VAR_15);
    *VAR_3 = VAR_22.data;
    *VAR_4 = VAR_22.size;

    VAR_29 = VAR_5;
    VAR_29->tm.tv_sec  = VAR_28;
    VAR_29->tm.tv_nsec = (VAR_12 * 1000000000);

    msgpack_unpacked_destroy(&VAR_24);
    return *VAR_4;
}",fluent/fluent-bit/22346a74c07ceb90296be872be2d53eb92252a54/flb_parser_json.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -83,6 +83,7 @@
     *out_size = tmp_out_size;
     if (mp_buf != tmp_out_buf) {
         flb_free(mp_buf);
+        mp_buf = NULL;
     }
 
     /* Do time resolution ? */
@@ -113,6 +114,7 @@
         /* Ensure the pointer we are about to read is not NULL */
         if (k->via.str.ptr == NULL) {
             flb_free(mp_buf);
+            flb_free(tmp_out_buf);
             *out_buf = NULL;
             msgpack_unpacked_destroy(&result);
             return -1;","{'deleted_lines': [], 'added_lines': ['        mp_buf = NULL;', '            flb_free(tmp_out_buf);']}",True,"Fluent Bit (aka fluent-bit) 1.7.0 through 1.7,4 has a double free in flb_free (called from flb_parser_json_do and flb_parser_do).",9.8,CRITICAL,3,valid,2021-05-06T18:52:11Z,3
CVE-2021-36144,['CWE-416'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,projectacrn/acrn-hypervisor,"dm: Reset virtio device before release

With virtio polling mode enabled, a timer is running in the virtio
backend service. And the timer will also be triggered if its frondend
driver didn't do the device reset in shutdown. A freed virtio device
will be accessed in the polling timer handler.

Do the virtio reset() callback specifically to clear the polling timer
before the free.

Tracked-On: #6147
Signed-off-by: Shuo A Liu <shuo.a.liu@intel.com>
Signed-off-by: Yonghua Huang <yonghua.huang@intel.com>",dd88504804e186029f845a166dc5c31695e2cca2,https://github.com/projectacrn/acrn-hypervisor/commit/dd88504804e186029f845a166dc5c31695e2cca2,devicemodel/hw/pci/virtio/virtio_mei.c,vmei_reset_teardown,"static void
vmei_reset_teardown(void *param)
{
struct virtio_mei *vmei = param;
vmei->reset_mevp = NULL;
pthread_mutex_destroy(&vmei->mutex);
free(vmei->config);
free(vmei);
}","static void
vmei_reset_teardown(void *VAR_0)
{
struct virtio_mei *VAR_1 = VAR_0;
VAR_1->reset_mevp = NULL;
pthread_mutex_destroy(&VAR_1->mutex);
free(VAR_1->config);
free(VAR_1);
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_mei.c/vul/before/0.json,"static void
vmei_reset_teardown(void *param)
{
	struct virtio_mei *vmei = param;
	vmei->reset_mevp = NULL;

	pthread_mutex_destroy(&vmei->mutex);
	virtio_reset_dev(&vmei->base);
	free(vmei->config);
	free(vmei);
}","static void
vmei_reset_teardown(void *VAR_0)
{
	struct virtio_mei *VAR_1 = VAR_0;
	VAR_1->reset_mevp = NULL;

	pthread_mutex_destroy(&VAR_1->mutex);
	virtio_reset_dev(&VAR_1->base);
	free(VAR_1->config);
	free(VAR_1);
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_mei.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,6 +5,7 @@
 	vmei->reset_mevp = NULL;
 
 	pthread_mutex_destroy(&vmei->mutex);
+	virtio_reset_dev(&vmei->base);
 	free(vmei->config);
 	free(vmei);
 }","{'deleted_lines': [], 'added_lines': ['\tvirtio_reset_dev(&vmei->base);']}",True,"The polling timer handler in ACRN before 2.5 has a use-after-free for a freed virtio device, related to devicemodel/hw/pci/virtio/*.c.",7.5,HIGH,2,valid,2021-05-10T05:31:25Z,3
CVE-2021-36144,['CWE-416'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,projectacrn/acrn-hypervisor,"dm: Reset virtio device before release

With virtio polling mode enabled, a timer is running in the virtio
backend service. And the timer will also be triggered if its frondend
driver didn't do the device reset in shutdown. A freed virtio device
will be accessed in the polling timer handler.

Do the virtio reset() callback specifically to clear the polling timer
before the free.

Tracked-On: #6147
Signed-off-by: Shuo A Liu <shuo.a.liu@intel.com>
Signed-off-by: Yonghua Huang <yonghua.huang@intel.com>",dd88504804e186029f845a166dc5c31695e2cca2,https://github.com/projectacrn/acrn-hypervisor/commit/dd88504804e186029f845a166dc5c31695e2cca2,devicemodel/hw/pci/virtio/virtio_input.c,virtio_input_teardown,"static void
virtio_input_teardown(void *param)
{
struct virtio_input *vi;
vi = (struct virtio_input *)param;
if (vi) {
pthread_mutex_destroy(&vi->mtx);
if (vi->event_queue)
free(vi->event_queue);
if (vi->fd > 0)
close(vi->fd);
if (vi->evdev)
free(vi->evdev);
if (vi->serial)
free(vi->serial);
free(vi);
vi = NULL;
}
}","static void
virtio_input_teardown(void *VAR_0)
{
struct virtio_input *VAR_1;
VAR_1 = (struct virtio_input *)VAR_0;
if (VAR_1) {
pthread_mutex_destroy(&VAR_1->mtx);
if (VAR_1->event_queue)
free(VAR_1->event_queue);
if (VAR_1->fd > 0)
close(VAR_1->fd);
if (VAR_1->evdev)
free(VAR_1->evdev);
if (VAR_1->serial)
free(VAR_1->serial);
free(VAR_1);
VAR_1 = NULL;
}
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_input.c/vul/before/0.json,"static void
virtio_input_teardown(void *param)
{
	struct virtio_input *vi;

	vi = (struct virtio_input *)param;
	if (vi) {
		pthread_mutex_destroy(&vi->mtx);
		if (vi->event_queue)
			free(vi->event_queue);
		if (vi->fd > 0)
			close(vi->fd);
		if (vi->evdev)
			free(vi->evdev);
		if (vi->serial)
			free(vi->serial);

		virtio_input_reset(vi);
		free(vi);
		vi = NULL;
	}
}","static void
virtio_input_teardown(void *VAR_0)
{
	struct virtio_input *VAR_1;

	VAR_1 = (struct virtio_input *)VAR_0;
	if (VAR_1) {
		pthread_mutex_destroy(&VAR_1->mtx);
		if (VAR_1->event_queue)
			free(VAR_1->event_queue);
		if (VAR_1->fd > 0)
			close(VAR_1->fd);
		if (VAR_1->evdev)
			free(VAR_1->evdev);
		if (VAR_1->serial)
			free(VAR_1->serial);

		virtio_input_reset(VAR_1);
		free(VAR_1);
		VAR_1 = NULL;
	}
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_input.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,6 +14,8 @@
 			free(vi->evdev);
 		if (vi->serial)
 			free(vi->serial);
+
+		virtio_input_reset(vi);
 		free(vi);
 		vi = NULL;
 	}","{'deleted_lines': [], 'added_lines': ['', '\t\tvirtio_input_reset(vi);']}",True,"The polling timer handler in ACRN before 2.5 has a use-after-free for a freed virtio device, related to devicemodel/hw/pci/virtio/*.c.",7.5,HIGH,2,valid,2021-05-10T05:31:25Z,3
CVE-2021-36144,['CWE-416'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,projectacrn/acrn-hypervisor,"dm: Reset virtio device before release

With virtio polling mode enabled, a timer is running in the virtio
backend service. And the timer will also be triggered if its frondend
driver didn't do the device reset in shutdown. A freed virtio device
will be accessed in the polling timer handler.

Do the virtio reset() callback specifically to clear the polling timer
before the free.

Tracked-On: #6147
Signed-off-by: Shuo A Liu <shuo.a.liu@intel.com>
Signed-off-by: Yonghua Huang <yonghua.huang@intel.com>",dd88504804e186029f845a166dc5c31695e2cca2,https://github.com/projectacrn/acrn-hypervisor/commit/dd88504804e186029f845a166dc5c31695e2cca2,devicemodel/hw/pci/virtio/virtio_block.c,virtio_blk_deinit,"static void
virtio_blk_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
struct blockif_ctxt *bctxt;
struct virtio_blk *blk;
if (dev->arg) {
DPRINTF((""virtio_blk: deinit\n""));
blk = (struct virtio_blk *) dev->arg;
if (!blk->dummy_bctxt) {
bctxt = blk->bc;
if (blockif_flush_all(bctxt))
WPRINTF((""vrito_blk: Failed to flush before close\n""));
blockif_close(bctxt);
}
free(blk);
}
}","static void
virtio_blk_deinit(struct vmctx *VAR_0, struct pci_vdev *VAR_1, char *VAR_2)
{
struct blockif_ctxt *VAR_3;
struct virtio_blk *VAR_4;
if (VAR_1->arg) {
DPRINTF((""virtio_blk: deinit\n""));
VAR_4 = (struct virtio_blk *) VAR_1->arg;
if (!VAR_4->dummy_bctxt) {
VAR_3 = VAR_4->bc;
if (blockif_flush_all(VAR_3))
WPRINTF((""vrito_blk: Failed to flush before close\n""));
blockif_close(VAR_3);
}
free(VAR_4);
}
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_block.c/vul/before/0.json,"static void
virtio_blk_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
	struct blockif_ctxt *bctxt;
	struct virtio_blk *blk;

	if (dev->arg) {
		DPRINTF((""virtio_blk: deinit\n""));
		blk = (struct virtio_blk *) dev->arg;
		/* De-init virtio-blk device only on valid bctxt*/
		if (!blk->dummy_bctxt) {
			bctxt = blk->bc;
			if (blockif_flush_all(bctxt))
				WPRINTF((""vrito_blk: Failed to flush before close\n""));
			blockif_close(bctxt);
		}
		virtio_reset_dev(&blk->base);
		free(blk);
	}
}","static void
virtio_blk_deinit(struct vmctx *VAR_0, struct pci_vdev *VAR_1, char *VAR_2)
{
	struct blockif_ctxt *VAR_3;
	struct virtio_blk *VAR_4;

	if (VAR_1->arg) {
		DPRINTF((""virtio_blk: deinit\n""));
		VAR_4 = (struct virtio_blk *) VAR_1->arg;
		/* COMMENT_0 */
		if (!VAR_4->dummy_bctxt) {
			VAR_3 = VAR_4->bc;
			if (blockif_flush_all(VAR_3))
				WPRINTF((""vrito_blk: Failed to flush before close\n""));
			blockif_close(VAR_3);
		}
		virtio_reset_dev(&VAR_4->base);
		free(VAR_4);
	}
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_block.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,6 +14,7 @@
 				WPRINTF((""vrito_blk: Failed to flush before close\n""));
 			blockif_close(bctxt);
 		}
+		virtio_reset_dev(&blk->base);
 		free(blk);
 	}
 }","{'deleted_lines': [], 'added_lines': ['\t\tvirtio_reset_dev(&blk->base);']}",True,"The polling timer handler in ACRN before 2.5 has a use-after-free for a freed virtio device, related to devicemodel/hw/pci/virtio/*.c.",7.5,HIGH,2,valid,2021-05-10T05:31:25Z,3
CVE-2021-36144,['CWE-416'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,projectacrn/acrn-hypervisor,"dm: Reset virtio device before release

With virtio polling mode enabled, a timer is running in the virtio
backend service. And the timer will also be triggered if its frondend
driver didn't do the device reset in shutdown. A freed virtio device
will be accessed in the polling timer handler.

Do the virtio reset() callback specifically to clear the polling timer
before the free.

Tracked-On: #6147
Signed-off-by: Shuo A Liu <shuo.a.liu@intel.com>
Signed-off-by: Yonghua Huang <yonghua.huang@intel.com>",dd88504804e186029f845a166dc5c31695e2cca2,https://github.com/projectacrn/acrn-hypervisor/commit/dd88504804e186029f845a166dc5c31695e2cca2,devicemodel/hw/pci/virtio/virtio_coreu.c,virtio_coreu_deinit,"static void
virtio_coreu_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
struct virtio_coreu *vcoreu = (struct virtio_coreu *)dev->arg;
if (!vcoreu)
return;
pthread_mutex_destroy(&vcoreu->mtx);
pthread_mutex_destroy(&vcoreu->rx_mtx);
pthread_cond_destroy(&vcoreu->rx_cond);
pthread_join(vcoreu->rx_tid, NULL);
free(vcoreu);
}","static void
virtio_coreu_deinit(struct vmctx *VAR_0, struct pci_vdev *VAR_1, char *VAR_2)
{
struct virtio_coreu *VAR_3 = (struct virtio_coreu *)VAR_1->arg;
if (!VAR_3)
return;
pthread_mutex_destroy(&VAR_3->mtx);
pthread_mutex_destroy(&VAR_3->rx_mtx);
pthread_cond_destroy(&VAR_3->rx_cond);
pthread_join(VAR_3->rx_tid, NULL);
free(VAR_3);
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_coreu.c/vul/before/0.json,"static void
virtio_coreu_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
	struct virtio_coreu *vcoreu = (struct virtio_coreu *)dev->arg;

	if (!vcoreu)
		return;

	pthread_mutex_destroy(&vcoreu->mtx);
	pthread_mutex_destroy(&vcoreu->rx_mtx);
	pthread_cond_destroy(&vcoreu->rx_cond);
	pthread_join(vcoreu->rx_tid, NULL);

	virtio_coreu_reset(vcoreu);
	free(vcoreu);
}","static void
virtio_coreu_deinit(struct vmctx *VAR_0, struct pci_vdev *VAR_1, char *VAR_2)
{
	struct virtio_coreu *VAR_3 = (struct virtio_coreu *)VAR_1->arg;

	if (!VAR_3)
		return;

	pthread_mutex_destroy(&VAR_3->mtx);
	pthread_mutex_destroy(&VAR_3->rx_mtx);
	pthread_cond_destroy(&VAR_3->rx_cond);
	pthread_join(VAR_3->rx_tid, NULL);

	virtio_coreu_reset(VAR_3);
	free(VAR_3);
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_coreu.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,5 +11,6 @@
 	pthread_cond_destroy(&vcoreu->rx_cond);
 	pthread_join(vcoreu->rx_tid, NULL);
 
+	virtio_coreu_reset(vcoreu);
 	free(vcoreu);
 }","{'deleted_lines': [], 'added_lines': ['\tvirtio_coreu_reset(vcoreu);']}",True,"The polling timer handler in ACRN before 2.5 has a use-after-free for a freed virtio device, related to devicemodel/hw/pci/virtio/*.c.",7.5,HIGH,2,valid,2021-05-10T05:31:25Z,3
CVE-2021-36144,['CWE-416'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,projectacrn/acrn-hypervisor,"dm: Reset virtio device before release

With virtio polling mode enabled, a timer is running in the virtio
backend service. And the timer will also be triggered if its frondend
driver didn't do the device reset in shutdown. A freed virtio device
will be accessed in the polling timer handler.

Do the virtio reset() callback specifically to clear the polling timer
before the free.

Tracked-On: #6147
Signed-off-by: Shuo A Liu <shuo.a.liu@intel.com>
Signed-off-by: Yonghua Huang <yonghua.huang@intel.com>",dd88504804e186029f845a166dc5c31695e2cca2,https://github.com/projectacrn/acrn-hypervisor/commit/dd88504804e186029f845a166dc5c31695e2cca2,devicemodel/hw/pci/virtio/virtio_console.c,virtio_console_destroy,"static void
virtio_console_destroy(struct virtio_console *console)
{
if (console) {
if (console->config)
free(console->config);
free(console);
console = NULL;
}
}","static void
virtio_console_destroy(struct virtio_console *VAR_0)
{
if (VAR_0) {
if (VAR_0->config)
free(VAR_0->config);
free(VAR_0);
VAR_0 = NULL;
}
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_console.c/vul/before/0.json,"static void
virtio_console_destroy(struct virtio_console *console)
{
	if (console) {
		virtio_console_reset(console);
		if (console->config)
			free(console->config);
		free(console);
		console = NULL;
	}
}","static void
virtio_console_destroy(struct virtio_console *VAR_0)
{
	if (VAR_0) {
		virtio_console_reset(VAR_0);
		if (VAR_0->config)
			free(VAR_0->config);
		free(VAR_0);
		VAR_0 = NULL;
	}
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_console.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,6 +2,7 @@
 virtio_console_destroy(struct virtio_console *console)
 {
 	if (console) {
+		virtio_console_reset(console);
 		if (console->config)
 			free(console->config);
 		free(console);","{'deleted_lines': [], 'added_lines': ['\t\tvirtio_console_reset(console);']}",True,"The polling timer handler in ACRN before 2.5 has a use-after-free for a freed virtio device, related to devicemodel/hw/pci/virtio/*.c.",7.5,HIGH,2,valid,2021-05-10T05:31:25Z,3
CVE-2021-36144,['CWE-416'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,projectacrn/acrn-hypervisor,"dm: Reset virtio device before release

With virtio polling mode enabled, a timer is running in the virtio
backend service. And the timer will also be triggered if its frondend
driver didn't do the device reset in shutdown. A freed virtio device
will be accessed in the polling timer handler.

Do the virtio reset() callback specifically to clear the polling timer
before the free.

Tracked-On: #6147
Signed-off-by: Shuo A Liu <shuo.a.liu@intel.com>
Signed-off-by: Yonghua Huang <yonghua.huang@intel.com>",dd88504804e186029f845a166dc5c31695e2cca2,https://github.com/projectacrn/acrn-hypervisor/commit/dd88504804e186029f845a166dc5c31695e2cca2,devicemodel/hw/pci/virtio/virtio_audio.c,virtio_audio_deinit,"static void
virtio_audio_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
struct virtio_audio *virt_audio;
virt_audio = dev->arg;
if (!virt_audio) {
DPRINTF((""%s: virtio_audio is NULL!\n"", __func__));
return;
}
if (virt_audio->vbs_k.kstatus == VIRTIO_DEV_STARTED) {
DPRINTF((""%s: deinit virtio_audio_k!\n"", __func__));
virtio_audio_kernel_stop(virt_audio);
virtio_audio_kernel_reset(virt_audio);
virt_audio->vbs_k.kstatus = VIRTIO_DEV_INITIAL;
if (virt_audio->vbs_k.audio_fd < 0) {
WPRINTF((""virtio_audio: %s  doesn't open!\n"",
vbs_k_audio_dev_path));
return;
}
close(virt_audio->vbs_k.audio_fd);
virt_audio->vbs_k.audio_fd = -1;
}
pthread_mutex_destroy(&virt_audio->mtx);
DPRINTF((""%s: free struct virtio_audio!\n"", __func__));
free((struct virtio_audio *)dev->arg);
}","static void
virtio_audio_deinit(struct vmctx *VAR_0, struct pci_vdev *VAR_1, char *VAR_2)
{
struct virtio_audio *VAR_3;
VAR_3 = VAR_1->arg;
if (!VAR_3) {
DPRINTF((""%s: virtio_audio is NULL!\n"", VAR_4));
return;
}
if (VAR_3->vbs_k.kstatus == VAR_5) {
DPRINTF((""%s: deinit virtio_audio_k!\n"", VAR_4));
virtio_audio_kernel_stop(VAR_3);
virtio_audio_kernel_reset(VAR_3);
VAR_3->vbs_k.kstatus = VAR_6;
if (VAR_3->vbs_k.audio_fd < 0) {
WPRINTF((""virtio_audio: %s  doesn't open!\n"",
VAR_7));
return;
}
close(VAR_3->vbs_k.audio_fd);
VAR_3->vbs_k.audio_fd = -1;
}
pthread_mutex_destroy(&VAR_3->mtx);
DPRINTF((""%s: free struct virtio_audio!\n"", VAR_4));
free((struct virtio_audio *)VAR_1->arg);
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_audio.c/vul/before/0.json,"static void
virtio_audio_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
	struct virtio_audio *virt_audio;

	virt_audio = dev->arg;
	if (!virt_audio) {
		DPRINTF((""%s: virtio_audio is NULL!\n"", __func__));
		return;
	}
	if (virt_audio->vbs_k.kstatus == VIRTIO_DEV_STARTED) {
		DPRINTF((""%s: deinit virtio_audio_k!\n"", __func__));
		virtio_audio_kernel_stop(virt_audio);
		virtio_audio_kernel_reset(virt_audio);
		virt_audio->vbs_k.kstatus = VIRTIO_DEV_INITIAL;
		if (virt_audio->vbs_k.audio_fd < 0) {
			WPRINTF((""virtio_audio: %s  doesn't open!\n"",
				vbs_k_audio_dev_path));
			return;
		}
		close(virt_audio->vbs_k.audio_fd);
		virt_audio->vbs_k.audio_fd = -1;
	}
	virtio_audio_reset(virt_audio);
	pthread_mutex_destroy(&virt_audio->mtx);
	DPRINTF((""%s: free struct virtio_audio!\n"", __func__));
	free((struct virtio_audio *)dev->arg);
}","static void
virtio_audio_deinit(struct vmctx *VAR_0, struct pci_vdev *VAR_1, char *VAR_2)
{
	struct virtio_audio *VAR_3;

	VAR_3 = VAR_1->arg;
	if (!VAR_3) {
		DPRINTF((""%s: virtio_audio is NULL!\n"", VAR_4));
		return;
	}
	if (VAR_3->vbs_k.kstatus == VAR_5) {
		DPRINTF((""%s: deinit virtio_audio_k!\n"", VAR_4));
		virtio_audio_kernel_stop(VAR_3);
		virtio_audio_kernel_reset(VAR_3);
		VAR_3->vbs_k.kstatus = VAR_6;
		if (VAR_3->vbs_k.audio_fd < 0) {
			WPRINTF((""virtio_audio: %s  doesn't open!\n"",
				VAR_7));
			return;
		}
		close(VAR_3->vbs_k.audio_fd);
		VAR_3->vbs_k.audio_fd = -1;
	}
	virtio_audio_reset(VAR_3);
	pthread_mutex_destroy(&VAR_3->mtx);
	DPRINTF((""%s: free struct virtio_audio!\n"", VAR_4));
	free((struct virtio_audio *)VAR_1->arg);
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_audio.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,6 +21,7 @@
 		close(virt_audio->vbs_k.audio_fd);
 		virt_audio->vbs_k.audio_fd = -1;
 	}
+	virtio_audio_reset(virt_audio);
 	pthread_mutex_destroy(&virt_audio->mtx);
 	DPRINTF((""%s: free struct virtio_audio!\n"", __func__));
 	free((struct virtio_audio *)dev->arg);","{'deleted_lines': [], 'added_lines': ['\tvirtio_audio_reset(virt_audio);']}",True,"The polling timer handler in ACRN before 2.5 has a use-after-free for a freed virtio device, related to devicemodel/hw/pci/virtio/*.c.",7.5,HIGH,2,valid,2021-05-10T05:31:25Z,3
CVE-2021-36144,['CWE-416'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,projectacrn/acrn-hypervisor,"dm: Reset virtio device before release

With virtio polling mode enabled, a timer is running in the virtio
backend service. And the timer will also be triggered if its frondend
driver didn't do the device reset in shutdown. A freed virtio device
will be accessed in the polling timer handler.

Do the virtio reset() callback specifically to clear the polling timer
before the free.

Tracked-On: #6147
Signed-off-by: Shuo A Liu <shuo.a.liu@intel.com>
Signed-off-by: Yonghua Huang <yonghua.huang@intel.com>",dd88504804e186029f845a166dc5c31695e2cca2,https://github.com/projectacrn/acrn-hypervisor/commit/dd88504804e186029f845a166dc5c31695e2cca2,devicemodel/hw/pci/virtio/virtio_net.c,virtio_net_teardown,"static void
virtio_net_teardown(void *param)
{
struct virtio_net *net;
net = (struct virtio_net *)param;
if (!net)
return;
if (net->tapfd >= 0) {
close(net->tapfd);
net->tapfd = -1;
} else
pr_err(""net->tapfd is -1!\n"");
free(net);
}","static void
virtio_net_teardown(void *VAR_0)
{
struct virtio_net *VAR_1;
VAR_1 = (struct virtio_net *)VAR_0;
if (!VAR_1)
return;
if (VAR_1->tapfd >= 0) {
close(VAR_1->tapfd);
VAR_1->tapfd = -1;
} else
pr_err(""net->tapfd is -1!\n"");
free(VAR_1);
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_net.c/vul/before/0.json,"static void
virtio_net_teardown(void *param)
{
	struct virtio_net *net;

	net = (struct virtio_net *)param;
	if (!net)
		return;

	if (net->tapfd >= 0) {
		close(net->tapfd);
		net->tapfd = -1;
	} else
		pr_err(""net->tapfd is -1!\n"");

	virtio_reset_dev(&net->base);
	free(net);
}","static void
virtio_net_teardown(void *VAR_0)
{
	struct virtio_net *VAR_1;

	VAR_1 = (struct virtio_net *)VAR_0;
	if (!VAR_1)
		return;

	if (VAR_1->tapfd >= 0) {
		close(VAR_1->tapfd);
		VAR_1->tapfd = -1;
	} else
		pr_err(""net->tapfd is -1!\n"");

	virtio_reset_dev(&VAR_1->base);
	free(VAR_1);
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_net.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,5 +13,6 @@
 	} else
 		pr_err(""net->tapfd is -1!\n"");
 
+	virtio_reset_dev(&net->base);
 	free(net);
 }","{'deleted_lines': [], 'added_lines': ['\tvirtio_reset_dev(&net->base);']}",True,"The polling timer handler in ACRN before 2.5 has a use-after-free for a freed virtio device, related to devicemodel/hw/pci/virtio/*.c.",7.5,HIGH,2,valid,2021-05-10T05:31:25Z,3
CVE-2021-36144,['CWE-416'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,projectacrn/acrn-hypervisor,"dm: Reset virtio device before release

With virtio polling mode enabled, a timer is running in the virtio
backend service. And the timer will also be triggered if its frondend
driver didn't do the device reset in shutdown. A freed virtio device
will be accessed in the polling timer handler.

Do the virtio reset() callback specifically to clear the polling timer
before the free.

Tracked-On: #6147
Signed-off-by: Shuo A Liu <shuo.a.liu@intel.com>
Signed-off-by: Yonghua Huang <yonghua.huang@intel.com>",dd88504804e186029f845a166dc5c31695e2cca2,https://github.com/projectacrn/acrn-hypervisor/commit/dd88504804e186029f845a166dc5c31695e2cca2,devicemodel/hw/pci/virtio/virtio_gpio.c,virtio_gpio_deinit,"static void
virtio_gpio_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
struct virtio_gpio *gpio;
int i;
DPRINTF((""%s"", ""virtio gpio: pci_gpio_deinit\r\n""));
virtio_gpio_is_active = false;
gpio = (struct virtio_gpio *)dev->arg;
if (gpio) {
pthread_mutex_destroy(&gpio->mtx);
gpio_irq_deinit(gpio);
for (i = 0; i < gpio->nchip; i++)
native_gpio_close_chip(&gpio->chips[i]);
free(gpio);
dev->arg = NULL;
}
}","static void
virtio_gpio_deinit(struct vmctx *VAR_0, struct pci_vdev *VAR_1, char *VAR_2)
{
struct virtio_gpio *VAR_3;
int VAR_4;
DPRINTF((""%s"", ""virtio gpio: pci_gpio_deinit\r\n""));
VAR_5 = false;
VAR_3 = (struct virtio_gpio *)VAR_1->arg;
if (VAR_3) {
pthread_mutex_destroy(&VAR_3->mtx);
gpio_irq_deinit(VAR_3);
for (VAR_4 = 0; VAR_4 < VAR_3->nchip; VAR_4++)
native_gpio_close_chip(&VAR_3->chips[VAR_4]);
free(VAR_3);
VAR_1->arg = NULL;
}
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_gpio.c/vul/before/0.json,"static void
virtio_gpio_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
	struct virtio_gpio *gpio;
	int i;

	DPRINTF((""%s"", ""virtio gpio: pci_gpio_deinit\r\n""));
	virtio_gpio_is_active = false;
	gpio = (struct virtio_gpio *)dev->arg;
	if (gpio) {
		pthread_mutex_destroy(&gpio->mtx);
		gpio_irq_deinit(gpio);
		for (i = 0; i < gpio->nchip; i++)
			native_gpio_close_chip(&gpio->chips[i]);
		virtio_gpio_reset(gpio);
		free(gpio);
		dev->arg = NULL;
	}
}","static void
virtio_gpio_deinit(struct vmctx *VAR_0, struct pci_vdev *VAR_1, char *VAR_2)
{
	struct virtio_gpio *VAR_3;
	int VAR_4;

	DPRINTF((""%s"", ""virtio gpio: pci_gpio_deinit\r\n""));
	VAR_5 = false;
	VAR_3 = (struct virtio_gpio *)VAR_1->arg;
	if (VAR_3) {
		pthread_mutex_destroy(&VAR_3->mtx);
		gpio_irq_deinit(VAR_3);
		for (VAR_4 = 0; VAR_4 < VAR_3->nchip; VAR_4++)
			native_gpio_close_chip(&VAR_3->chips[VAR_4]);
		virtio_gpio_reset(VAR_3);
		free(VAR_3);
		VAR_1->arg = NULL;
	}
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_gpio.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,6 +12,7 @@
 		gpio_irq_deinit(gpio);
 		for (i = 0; i < gpio->nchip; i++)
 			native_gpio_close_chip(&gpio->chips[i]);
+		virtio_gpio_reset(gpio);
 		free(gpio);
 		dev->arg = NULL;
 	}","{'deleted_lines': [], 'added_lines': ['\t\tvirtio_gpio_reset(gpio);']}",True,"The polling timer handler in ACRN before 2.5 has a use-after-free for a freed virtio device, related to devicemodel/hw/pci/virtio/*.c.",7.5,HIGH,2,valid,2021-05-10T05:31:25Z,3
CVE-2021-36144,['CWE-416'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,projectacrn/acrn-hypervisor,"dm: Reset virtio device before release

With virtio polling mode enabled, a timer is running in the virtio
backend service. And the timer will also be triggered if its frondend
driver didn't do the device reset in shutdown. A freed virtio device
will be accessed in the polling timer handler.

Do the virtio reset() callback specifically to clear the polling timer
before the free.

Tracked-On: #6147
Signed-off-by: Shuo A Liu <shuo.a.liu@intel.com>
Signed-off-by: Yonghua Huang <yonghua.huang@intel.com>",dd88504804e186029f845a166dc5c31695e2cca2,https://github.com/projectacrn/acrn-hypervisor/commit/dd88504804e186029f845a166dc5c31695e2cca2,devicemodel/hw/pci/virtio/virtio_rpmb.c,virtio_rpmb_deinit,"static void
virtio_rpmb_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
if (dev->arg) {
DPRINTF((""virtio_rpmb_be_deinit: free struct virtio_rpmb!\n""));
free((struct virtio_rpmb *)dev->arg);
}
}","static void
virtio_rpmb_deinit(struct vmctx *VAR_0, struct pci_vdev *VAR_1, char *VAR_2)
{
if (VAR_1->arg) {
DPRINTF((""virtio_rpmb_be_deinit: free struct virtio_rpmb!\n""));
free((struct virtio_rpmb *)VAR_1->arg);
}
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_rpmb.c/vul/before/0.json,"static void
virtio_rpmb_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
	if (dev->arg) {
		DPRINTF((""virtio_rpmb_be_deinit: free struct virtio_rpmb!\n""));
		virtio_rpmb_reset(dev->arg);
		free((struct virtio_rpmb *)dev->arg);
	}
}","static void
virtio_rpmb_deinit(struct vmctx *VAR_0, struct pci_vdev *VAR_1, char *VAR_2)
{
	if (VAR_1->arg) {
		DPRINTF((""virtio_rpmb_be_deinit: free struct virtio_rpmb!\n""));
		virtio_rpmb_reset(VAR_1->arg);
		free((struct virtio_rpmb *)VAR_1->arg);
	}
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_rpmb.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,6 +3,7 @@
 {
 	if (dev->arg) {
 		DPRINTF((""virtio_rpmb_be_deinit: free struct virtio_rpmb!\n""));
+		virtio_rpmb_reset(dev->arg);
 		free((struct virtio_rpmb *)dev->arg);
 	}
 }","{'deleted_lines': [], 'added_lines': ['\t\tvirtio_rpmb_reset(dev->arg);']}",True,"The polling timer handler in ACRN before 2.5 has a use-after-free for a freed virtio device, related to devicemodel/hw/pci/virtio/*.c.",7.5,HIGH,2,valid,2021-05-10T05:31:25Z,3
CVE-2021-36144,['CWE-416'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,projectacrn/acrn-hypervisor,"dm: Reset virtio device before release

With virtio polling mode enabled, a timer is running in the virtio
backend service. And the timer will also be triggered if its frondend
driver didn't do the device reset in shutdown. A freed virtio device
will be accessed in the polling timer handler.

Do the virtio reset() callback specifically to clear the polling timer
before the free.

Tracked-On: #6147
Signed-off-by: Shuo A Liu <shuo.a.liu@intel.com>
Signed-off-by: Yonghua Huang <yonghua.huang@intel.com>",dd88504804e186029f845a166dc5c31695e2cca2,https://github.com/projectacrn/acrn-hypervisor/commit/dd88504804e186029f845a166dc5c31695e2cca2,devicemodel/hw/pci/virtio/virtio_hdcp.c,virtio_hdcp_deinit,"static void
virtio_hdcp_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
struct virtio_hdcp *vhdcp = (struct virtio_hdcp *)dev->arg;
if (vhdcp) {
DPRINTF((""free struct virtio_hdcp\n""));
free(vhdcp);
}
}","static void
virtio_hdcp_deinit(struct vmctx *VAR_0, struct pci_vdev *VAR_1, char *VAR_2)
{
struct virtio_hdcp *VAR_3 = (struct virtio_hdcp *)VAR_1->arg;
if (VAR_3) {
DPRINTF((""free struct virtio_hdcp\n""));
free(VAR_3);
}
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_hdcp.c/vul/before/0.json,"static void
virtio_hdcp_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
	struct virtio_hdcp *vhdcp = (struct virtio_hdcp *)dev->arg;

	if (vhdcp) {
		DPRINTF((""free struct virtio_hdcp\n""));
		virtio_hdcp_reset(vhdcp);
		free(vhdcp);
	}
}","static void
virtio_hdcp_deinit(struct vmctx *VAR_0, struct pci_vdev *VAR_1, char *VAR_2)
{
	struct virtio_hdcp *VAR_3 = (struct virtio_hdcp *)VAR_1->arg;

	if (VAR_3) {
		DPRINTF((""free struct virtio_hdcp\n""));
		virtio_hdcp_reset(VAR_3);
		free(VAR_3);
	}
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_hdcp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,6 +5,7 @@
 
 	if (vhdcp) {
 		DPRINTF((""free struct virtio_hdcp\n""));
+		virtio_hdcp_reset(vhdcp);
 		free(vhdcp);
 	}
 }","{'deleted_lines': [], 'added_lines': ['\t\tvirtio_hdcp_reset(vhdcp);']}",True,"The polling timer handler in ACRN before 2.5 has a use-after-free for a freed virtio device, related to devicemodel/hw/pci/virtio/*.c.",7.5,HIGH,2,valid,2021-05-10T05:31:25Z,3
CVE-2021-36144,['CWE-416'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,projectacrn/acrn-hypervisor,"dm: Reset virtio device before release

With virtio polling mode enabled, a timer is running in the virtio
backend service. And the timer will also be triggered if its frondend
driver didn't do the device reset in shutdown. A freed virtio device
will be accessed in the polling timer handler.

Do the virtio reset() callback specifically to clear the polling timer
before the free.

Tracked-On: #6147
Signed-off-by: Shuo A Liu <shuo.a.liu@intel.com>
Signed-off-by: Yonghua Huang <yonghua.huang@intel.com>",dd88504804e186029f845a166dc5c31695e2cca2,https://github.com/projectacrn/acrn-hypervisor/commit/dd88504804e186029f845a166dc5c31695e2cca2,devicemodel/hw/pci/virtio/virtio_rnd.c,virtio_rnd_deinit,"static void
virtio_rnd_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
struct virtio_rnd *rnd;
void *jval;
rnd = dev->arg;
if (rnd == NULL) {
DPRINTF((""%s: rnd is NULL\n"", __func__));
return;
}
pthread_cancel(rnd->rx_tid);
pthread_join(rnd->rx_tid, &jval);
if (rnd->vbs_k.status == VIRTIO_DEV_STARTED) {
DPRINTF((""%s: deinit virtio_rnd_k!\n"", __func__));
virtio_rnd_kernel_stop(rnd);
virtio_rnd_kernel_reset(rnd);
rnd->vbs_k.status = VIRTIO_DEV_INITIAL;
if (rnd->vbs_k.fd >= 0) {
close(rnd->vbs_k.fd);
rnd->vbs_k.fd = -1;
}
}
if (rnd->fd >= 0) {
close(rnd->fd);
rnd->fd = -1;
}
DPRINTF((""%s: free struct virtio_rnd!\n"", __func__));
free(rnd);
}","static void
virtio_rnd_deinit(struct vmctx *VAR_0, struct pci_vdev *VAR_1, char *VAR_2)
{
struct virtio_rnd *VAR_3;
void *VAR_4;
VAR_3 = VAR_1->arg;
if (VAR_3 == NULL) {
DPRINTF((""%s: rnd is NULL\n"", VAR_5));
return;
}
pthread_cancel(VAR_3->rx_tid);
pthread_join(VAR_3->rx_tid, &VAR_4);
if (VAR_3->vbs_k.status == VAR_6) {
DPRINTF((""%s: deinit virtio_rnd_k!\n"", VAR_5));
virtio_rnd_kernel_stop(VAR_3);
virtio_rnd_kernel_reset(VAR_3);
VAR_3->vbs_k.status = VAR_7;
if (VAR_3->vbs_k.fd >= 0) {
close(VAR_3->vbs_k.fd);
VAR_3->vbs_k.fd = -1;
}
}
if (VAR_3->fd >= 0) {
close(VAR_3->fd);
VAR_3->fd = -1;
}
DPRINTF((""%s: free struct virtio_rnd!\n"", VAR_5));
free(VAR_3);
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_rnd.c/vul/before/0.json,"static void
virtio_rnd_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
	struct virtio_rnd *rnd;
	void *jval;

	rnd = dev->arg;
	if (rnd == NULL) {
		DPRINTF((""%s: rnd is NULL\n"", __func__));
		return;
	}

	pthread_cancel(rnd->rx_tid);
	pthread_join(rnd->rx_tid, &jval);

	if (rnd->vbs_k.status == VIRTIO_DEV_STARTED) {
		DPRINTF((""%s: deinit virtio_rnd_k!\n"", __func__));
		virtio_rnd_kernel_stop(rnd);
		virtio_rnd_kernel_reset(rnd);
		rnd->vbs_k.status = VIRTIO_DEV_INITIAL;
		if (rnd->vbs_k.fd >= 0) {
			close(rnd->vbs_k.fd);
			rnd->vbs_k.fd = -1;
		}
	}

	if (rnd->fd >= 0) {
		close(rnd->fd);
		rnd->fd = -1;
	}
	virtio_rnd_reset(rnd);
	DPRINTF((""%s: free struct virtio_rnd!\n"", __func__));
	free(rnd);
}","static void
virtio_rnd_deinit(struct vmctx *VAR_0, struct pci_vdev *VAR_1, char *VAR_2)
{
	struct virtio_rnd *VAR_3;
	void *VAR_4;

	VAR_3 = VAR_1->arg;
	if (VAR_3 == NULL) {
		DPRINTF((""%s: rnd is NULL\n"", VAR_5));
		return;
	}

	pthread_cancel(VAR_3->rx_tid);
	pthread_join(VAR_3->rx_tid, &VAR_4);

	if (VAR_3->vbs_k.status == VAR_6) {
		DPRINTF((""%s: deinit virtio_rnd_k!\n"", VAR_5));
		virtio_rnd_kernel_stop(VAR_3);
		virtio_rnd_kernel_reset(VAR_3);
		VAR_3->vbs_k.status = VAR_7;
		if (VAR_3->vbs_k.fd >= 0) {
			close(VAR_3->vbs_k.fd);
			VAR_3->vbs_k.fd = -1;
		}
	}

	if (VAR_3->fd >= 0) {
		close(VAR_3->fd);
		VAR_3->fd = -1;
	}
	virtio_rnd_reset(VAR_3);
	DPRINTF((""%s: free struct virtio_rnd!\n"", VAR_5));
	free(VAR_3);
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_rnd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -28,6 +28,7 @@
 		close(rnd->fd);
 		rnd->fd = -1;
 	}
+	virtio_rnd_reset(rnd);
 	DPRINTF((""%s: free struct virtio_rnd!\n"", __func__));
 	free(rnd);
 }","{'deleted_lines': [], 'added_lines': ['\tvirtio_rnd_reset(rnd);']}",True,"The polling timer handler in ACRN before 2.5 has a use-after-free for a freed virtio device, related to devicemodel/hw/pci/virtio/*.c.",7.5,HIGH,2,valid,2021-05-10T05:31:25Z,3
CVE-2021-36144,['CWE-416'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,projectacrn/acrn-hypervisor,"dm: Reset virtio device before release

With virtio polling mode enabled, a timer is running in the virtio
backend service. And the timer will also be triggered if its frondend
driver didn't do the device reset in shutdown. A freed virtio device
will be accessed in the polling timer handler.

Do the virtio reset() callback specifically to clear the polling timer
before the free.

Tracked-On: #6147
Signed-off-by: Shuo A Liu <shuo.a.liu@intel.com>
Signed-off-by: Yonghua Huang <yonghua.huang@intel.com>",dd88504804e186029f845a166dc5c31695e2cca2,https://github.com/projectacrn/acrn-hypervisor/commit/dd88504804e186029f845a166dc5c31695e2cca2,devicemodel/hw/pci/virtio/virtio_hyper_dmabuf.c,virtio_hyper_dmabuf_deinit,"static void
virtio_hyper_dmabuf_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
if (kstatus == VIRTIO_DEV_STARTED) {
DPRINTF(""virtio_hyper_dmabuf: deinitializing\n"");
virtio_hyper_dmabuf_k_stop();
virtio_hyper_dmabuf_k_reset();
kstatus = VIRTIO_DEV_INITIAL;
if (vbs_k_hyper_dmabuf_fd >= 0) {
close(vbs_k_hyper_dmabuf_fd);
}
vbs_k_hyper_dmabuf_fd = -1;
}
if (dev->arg)
free((struct virtio_hyper_dmabuf *)dev->arg);
}","static void
virtio_hyper_dmabuf_deinit(struct vmctx *VAR_0, struct pci_vdev *VAR_1, char *VAR_2)
{
if (VAR_3 == VAR_4) {
DPRINTF(""virtio_hyper_dmabuf: deinitializing\n"");
virtio_hyper_dmabuf_k_stop();
virtio_hyper_dmabuf_k_reset();
VAR_3 = VAR_5;
if (VAR_6 >= 0) {
close(VAR_6);
}
VAR_6 = -1;
}
if (VAR_1->arg)
free((struct virtio_hyper_dmabuf *)VAR_1->arg);
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_hyper_dmabuf.c/vul/before/0.json,"static void
virtio_hyper_dmabuf_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
	if (kstatus == VIRTIO_DEV_STARTED) {
		DPRINTF(""virtio_hyper_dmabuf: deinitializing\n"");
		virtio_hyper_dmabuf_k_stop();
		virtio_hyper_dmabuf_k_reset();
		kstatus = VIRTIO_DEV_INITIAL;
		if (vbs_k_hyper_dmabuf_fd >= 0) {
			close(vbs_k_hyper_dmabuf_fd);
		}
		vbs_k_hyper_dmabuf_fd = -1;
	}

	if (dev->arg) {
		virtio_hyper_dmabuf_reset(dev->arg);
		free((struct virtio_hyper_dmabuf *)dev->arg);
	}
}","static void
virtio_hyper_dmabuf_deinit(struct vmctx *VAR_0, struct pci_vdev *VAR_1, char *VAR_2)
{
	if (VAR_3 == VAR_4) {
		DPRINTF(""virtio_hyper_dmabuf: deinitializing\n"");
		virtio_hyper_dmabuf_k_stop();
		virtio_hyper_dmabuf_k_reset();
		VAR_3 = VAR_5;
		if (VAR_6 >= 0) {
			close(VAR_6);
		}
		VAR_6 = -1;
	}

	if (VAR_1->arg) {
		virtio_hyper_dmabuf_reset(VAR_1->arg);
		free((struct virtio_hyper_dmabuf *)VAR_1->arg);
	}
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_hyper_dmabuf.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,6 +12,8 @@
 		vbs_k_hyper_dmabuf_fd = -1;
 	}
 
-	if (dev->arg)
+	if (dev->arg) {
+		virtio_hyper_dmabuf_reset(dev->arg);
 		free((struct virtio_hyper_dmabuf *)dev->arg);
+	}
 }","{'deleted_lines': ['\tif (dev->arg)'], 'added_lines': ['\tif (dev->arg) {', '\t\tvirtio_hyper_dmabuf_reset(dev->arg);', '\t}']}",True,"The polling timer handler in ACRN before 2.5 has a use-after-free for a freed virtio device, related to devicemodel/hw/pci/virtio/*.c.",7.5,HIGH,2,valid,2021-05-10T05:31:25Z,3
CVE-2021-36144,['CWE-416'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,projectacrn/acrn-hypervisor,"dm: Reset virtio device before release

With virtio polling mode enabled, a timer is running in the virtio
backend service. And the timer will also be triggered if its frondend
driver didn't do the device reset in shutdown. A freed virtio device
will be accessed in the polling timer handler.

Do the virtio reset() callback specifically to clear the polling timer
before the free.

Tracked-On: #6147
Signed-off-by: Shuo A Liu <shuo.a.liu@intel.com>
Signed-off-by: Yonghua Huang <yonghua.huang@intel.com>",dd88504804e186029f845a166dc5c31695e2cca2,https://github.com/projectacrn/acrn-hypervisor/commit/dd88504804e186029f845a166dc5c31695e2cca2,devicemodel/hw/pci/virtio/virtio_ipu.c,virtio_ipu_deinit,"static void
virtio_ipu_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
struct virtio_ipu *ipu;
ipu = (struct virtio_ipu *)dev->arg;
if (!ipu) {
IPRINTF(LDBG, ""is NULL!\n"");
return;
}
if (ipu->vbs_k.ipu_kstatus == VIRTIO_DEV_STARTED) {
IPRINTF(LDBG, ""deinitializing\n"");
virtio_ipu_k_stop(ipu);
virtio_ipu_k_reset(ipu);
ipu->vbs_k.ipu_kstatus = VIRTIO_DEV_INITIAL;
if (ipu->vbs_k.ipu_fd >= 0)
close(ipu->vbs_k.ipu_fd);
ipu->vbs_k.ipu_fd = -1;
}
pthread_mutex_destroy(&ipu->mtx);
free(ipu);
}","static void
virtio_ipu_deinit(struct vmctx *VAR_0, struct pci_vdev *VAR_1, char *VAR_2)
{
struct virtio_ipu *VAR_3;
VAR_3 = (struct virtio_ipu *)VAR_1->arg;
if (!VAR_3) {
IPRINTF(VAR_4, ""is NULL!\n"");
return;
}
if (VAR_3->vbs_k.ipu_kstatus == VAR_5) {
IPRINTF(VAR_4, ""deinitializing\n"");
virtio_ipu_k_stop(VAR_3);
virtio_ipu_k_reset(VAR_3);
VAR_3->vbs_k.ipu_kstatus = VAR_6;
if (VAR_3->vbs_k.ipu_fd >= 0)
close(VAR_3->vbs_k.ipu_fd);
VAR_3->vbs_k.ipu_fd = -1;
}
pthread_mutex_destroy(&VAR_3->mtx);
free(VAR_3);
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_ipu.c/vul/before/0.json,"static void
virtio_ipu_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{

	struct virtio_ipu *ipu;

	ipu = (struct virtio_ipu *)dev->arg;
	if (!ipu) {
		IPRINTF(LDBG, ""is NULL!\n"");
		return;
	}

	if (ipu->vbs_k.ipu_kstatus == VIRTIO_DEV_STARTED) {
		IPRINTF(LDBG, ""deinitializing\n"");
		virtio_ipu_k_stop(ipu);
		virtio_ipu_k_reset(ipu);
		ipu->vbs_k.ipu_kstatus = VIRTIO_DEV_INITIAL;
		if (ipu->vbs_k.ipu_fd >= 0)
			close(ipu->vbs_k.ipu_fd);
		ipu->vbs_k.ipu_fd = -1;
	}
	virtio_ipu_reset(ipu);
	pthread_mutex_destroy(&ipu->mtx);
	free(ipu);
}","static void
virtio_ipu_deinit(struct vmctx *VAR_0, struct pci_vdev *VAR_1, char *VAR_2)
{

	struct virtio_ipu *VAR_3;

	VAR_3 = (struct virtio_ipu *)VAR_1->arg;
	if (!VAR_3) {
		IPRINTF(VAR_4, ""is NULL!\n"");
		return;
	}

	if (VAR_3->vbs_k.ipu_kstatus == VAR_5) {
		IPRINTF(VAR_4, ""deinitializing\n"");
		virtio_ipu_k_stop(VAR_3);
		virtio_ipu_k_reset(VAR_3);
		VAR_3->vbs_k.ipu_kstatus = VAR_6;
		if (VAR_3->vbs_k.ipu_fd >= 0)
			close(VAR_3->vbs_k.ipu_fd);
		VAR_3->vbs_k.ipu_fd = -1;
	}
	virtio_ipu_reset(VAR_3);
	pthread_mutex_destroy(&VAR_3->mtx);
	free(VAR_3);
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_ipu.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -19,6 +19,7 @@
 			close(ipu->vbs_k.ipu_fd);
 		ipu->vbs_k.ipu_fd = -1;
 	}
+	virtio_ipu_reset(ipu);
 	pthread_mutex_destroy(&ipu->mtx);
 	free(ipu);
 }","{'deleted_lines': [], 'added_lines': ['\tvirtio_ipu_reset(ipu);']}",True,"The polling timer handler in ACRN before 2.5 has a use-after-free for a freed virtio device, related to devicemodel/hw/pci/virtio/*.c.",7.5,HIGH,2,valid,2021-05-10T05:31:25Z,3
CVE-2021-36144,['CWE-416'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,projectacrn/acrn-hypervisor,"dm: Reset virtio device before release

With virtio polling mode enabled, a timer is running in the virtio
backend service. And the timer will also be triggered if its frondend
driver didn't do the device reset in shutdown. A freed virtio device
will be accessed in the polling timer handler.

Do the virtio reset() callback specifically to clear the polling timer
before the free.

Tracked-On: #6147
Signed-off-by: Shuo A Liu <shuo.a.liu@intel.com>
Signed-off-by: Yonghua Huang <yonghua.huang@intel.com>",dd88504804e186029f845a166dc5c31695e2cca2,https://github.com/projectacrn/acrn-hypervisor/commit/dd88504804e186029f845a166dc5c31695e2cca2,devicemodel/hw/pci/virtio/virtio_i2c.c,virtio_i2c_deinit,"static void
virtio_i2c_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
struct virtio_i2c *vi2c;
if (dev->arg) {
DPRINTF(""deinit\n"");
vi2c = (struct virtio_i2c *) dev->arg;
virtio_i2c_req_stop(vi2c);
native_adapter_remove(vi2c);
pthread_mutex_destroy(&vi2c->req_mtx);
pthread_mutex_destroy(&vi2c->mtx);
free(vi2c);
dev->arg = NULL;
}
}","static void
virtio_i2c_deinit(struct vmctx *VAR_0, struct pci_vdev *VAR_1, char *VAR_2)
{
struct virtio_i2c *VAR_3;
if (VAR_1->arg) {
DPRINTF(""deinit\n"");
VAR_3 = (struct virtio_i2c *) VAR_1->arg;
virtio_i2c_req_stop(VAR_3);
native_adapter_remove(VAR_3);
pthread_mutex_destroy(&VAR_3->req_mtx);
pthread_mutex_destroy(&VAR_3->mtx);
free(VAR_3);
VAR_1->arg = NULL;
}
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_i2c.c/vul/before/0.json,"static void
virtio_i2c_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
	struct virtio_i2c *vi2c;

	if (dev->arg) {
		DPRINTF(""deinit\n"");
		vi2c = (struct virtio_i2c *) dev->arg;
		virtio_i2c_req_stop(vi2c);
		native_adapter_remove(vi2c);
		pthread_mutex_destroy(&vi2c->req_mtx);
		pthread_mutex_destroy(&vi2c->mtx);
		virtio_i2c_reset(vi2c);
		free(vi2c);
		dev->arg = NULL;
	}
}","static void
virtio_i2c_deinit(struct vmctx *VAR_0, struct pci_vdev *VAR_1, char *VAR_2)
{
	struct virtio_i2c *VAR_3;

	if (VAR_1->arg) {
		DPRINTF(""deinit\n"");
		VAR_3 = (struct virtio_i2c *) VAR_1->arg;
		virtio_i2c_req_stop(VAR_3);
		native_adapter_remove(VAR_3);
		pthread_mutex_destroy(&VAR_3->req_mtx);
		pthread_mutex_destroy(&VAR_3->mtx);
		virtio_i2c_reset(VAR_3);
		free(VAR_3);
		VAR_1->arg = NULL;
	}
}",projectacrn/acrn-hypervisor/dd88504804e186029f845a166dc5c31695e2cca2/virtio_i2c.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,6 +10,7 @@
 		native_adapter_remove(vi2c);
 		pthread_mutex_destroy(&vi2c->req_mtx);
 		pthread_mutex_destroy(&vi2c->mtx);
+		virtio_i2c_reset(vi2c);
 		free(vi2c);
 		dev->arg = NULL;
 	}","{'deleted_lines': [], 'added_lines': ['\t\tvirtio_i2c_reset(vi2c);']}",True,"The polling timer handler in ACRN before 2.5 has a use-after-free for a freed virtio device, related to devicemodel/hw/pci/virtio/*.c.",7.5,HIGH,2,valid,2021-05-10T05:31:25Z,3
CVE-2021-29607,"['CWE-787', 'CWE-754']",AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"Validate that a and b are proper sparse tensors

PiperOrigin-RevId: 373274848
Change-Id: I3a665ac3a29dee9fb69bdf408a939330cb93ea75",f6fde895ef9c77d848061c0517f19d0ec2682f3a,https://github.com/tensorflow/tensorflow/commit/f6fde895ef9c77d848061c0517f19d0ec2682f3a,tensorflow/core/kernels/sparse_sparse_binary_op_shared.cc,Compute,"void Compute(OpKernelContext *ctx) override {
const Tensor *a_indices_t, *a_values_t, *a_shape_t, *b_indices_t,
*b_values_t, *b_shape_t;
OP_REQUIRES_OK(ctx, ctx->input(""a_indices"", &a_indices_t));
OP_REQUIRES_OK(ctx, ctx->input(""a_values"", &a_values_t));
OP_REQUIRES_OK(ctx, ctx->input(""a_shape"", &a_shape_t));
OP_REQUIRES_OK(ctx, ctx->input(""b_indices"", &b_indices_t));
OP_REQUIRES_OK(ctx, ctx->input(""b_values"", &b_values_t));
OP_REQUIRES_OK(ctx, ctx->input(""b_shape"", &b_shape_t));
OP_REQUIRES(
ctx,
TensorShapeUtils::IsMatrix(a_indices_t->shape()) &&
TensorShapeUtils::IsMatrix(b_indices_t->shape()),
errors::InvalidArgument(""Inputs a_indices and b_indices should be ""
""matrices but received shapes: "",
a_indices_t->shape().DebugString(), "", "",
b_indices_t->shape().DebugString()));
OP_REQUIRES(ctx,
TensorShapeUtils::IsVector(a_values_t->shape()) &&
TensorShapeUtils::IsVector(b_values_t->shape()),
errors::InvalidArgument(
""Inputs a_values and b_values should be vectors ""
""but received shapes: "",
a_values_t->shape().DebugString(), "" and "",
b_values_t->shape().DebugString()));
const int64 a_nnz = a_indices_t->dim_size(0);
const int64 b_nnz = b_indices_t->dim_size(0);
const auto a_values = a_values_t->vec<T>();
const auto b_values = b_values_t->vec<T>();
OP_REQUIRES(
ctx, a_values.size() == a_nnz && b_values.size() == b_nnz,
errors::InvalidArgument(""Expected "", a_nnz, "" and "", b_nnz,
"" non-empty input values, got "",
a_values.size(), "" and "", b_values.size()));
OP_REQUIRES(ctx,
TensorShapeUtils::IsVector(a_shape_t->shape()) &&
TensorShapeUtils::IsVector(b_shape_t->shape()),
errors::InvalidArgument(
""Input shapes should be a vector but received shapes "",
a_shape_t->shape().DebugString(), "" and "",
b_shape_t->shape().DebugString()));
OP_REQUIRES(ctx, a_shape_t->IsSameSize(*b_shape_t),
errors::InvalidArgument(
""Operands do not have the same ranks; got shapes: "",
a_shape_t->SummarizeValue(10), "" and "",
b_shape_t->SummarizeValue(10)));
const auto a_shape = a_shape_t->flat<int64>();
const auto b_shape = b_shape_t->flat<int64>();
for (int i = 0; i < a_shape_t->NumElements(); ++i) {
OP_REQUIRES(ctx, a_shape(i) == b_shape(i),
errors::InvalidArgument(""Operands' shapes do not match: got "",
a_shape(i), "" and "", b_shape(i),
"" for dimension "", i));
}
OP_REQUIRES(
ctx, a_indices_t->dim_size(1) == b_indices_t->dim_size(1),
errors::InvalidArgument(
""Indices' dimensions do not match: got "", a_indices_t->dim_size(1),
"" and "", b_indices_t->dim_size(1), "" for the second dimension.""));
const int num_dims = a_indices_t->dim_size(1);
const auto a_indices_mat = a_indices_t->matrix<int64>();
const auto b_indices_mat = b_indices_t->matrix<int64>();
std::vector<T> a_augmented_values, b_augmented_values;
std::vector<std::pair<bool, int64>> entries_to_copy;      UnionSparseIndicesAndValues(a_indices_mat, a_values, a_nnz, b_indices_mat,
b_values, b_nnz, num_dims, &a_augmented_values,
&b_augmented_values, &entries_to_copy);
const int64 sum_nnz = a_augmented_values.size();
Tensor *output_indices_t, *output_values_t;
OP_REQUIRES_OK(ctx,
ctx->allocate_output(0, TensorShape({sum_nnz, num_dims}),
&output_indices_t));
OP_REQUIRES_OK(
ctx, ctx->allocate_output(1, TensorShape({sum_nnz}), &output_values_t));
auto output_indices_mat = output_indices_t->matrix<int64>();
for (int64 i = 0; i < sum_nnz; ++i) {
const bool from_a = entries_to_copy[i].first;
const int64 idx = entries_to_copy[i].second;
output_indices_mat.chip<0>(i) =
from_a ? a_indices_mat.chip<0>(idx) : b_indices_mat.chip<0>(idx);
}
using UnalignedTensorMap =
Eigen::TensorMap<Eigen::Tensor<const T, 1, Eigen::RowMajor>,
Eigen::Unaligned>;
auto a_augmented_values_t =
UnalignedTensorMap(a_augmented_values.data(), sum_nnz);
auto b_augmented_values_t =
UnalignedTensorMap(b_augmented_values.data(), sum_nnz);
output_values_t->flat<T>().device(ctx->eigen_device<Device>()) =
a_augmented_values_t.binaryExpr(b_augmented_values_t,
typename Functor::func());
}","void Compute(OpKernelContext *VAR_0) override {
const Tensor *VAR_1, *VAR_2, *VAR_3, *VAR_4,
*VAR_5, *VAR_6;
OP_REQUIRES_OK(VAR_0, VAR_0->input(""a_indices"", &VAR_1));
OP_REQUIRES_OK(VAR_0, VAR_0->input(""a_values"", &VAR_2));
OP_REQUIRES_OK(VAR_0, VAR_0->input(""a_shape"", &VAR_3));
OP_REQUIRES_OK(VAR_0, VAR_0->input(""b_indices"", &VAR_4));
OP_REQUIRES_OK(VAR_0, VAR_0->input(""b_values"", &VAR_5));
OP_REQUIRES_OK(VAR_0, VAR_0->input(""b_shape"", &VAR_6));
OP_REQUIRES(
VAR_0,
TensorShapeUtils::IsMatrix(VAR_1->shape()) &&
TensorShapeUtils::IsMatrix(VAR_4->shape()),
errors::InvalidArgument(""Inputs a_indices and b_indices should be ""
""matrices but received shapes: "",
VAR_1->shape().DebugString(), "", "",
VAR_4->shape().DebugString()));
OP_REQUIRES(VAR_0,
TensorShapeUtils::IsVector(VAR_2->shape()) &&
TensorShapeUtils::IsVector(VAR_5->shape()),
errors::InvalidArgument(
""Inputs a_values and b_values should be vectors ""
""but received shapes: "",
VAR_2->shape().DebugString(), "" and "",
VAR_5->shape().DebugString()));
const int64 VAR_7 = VAR_1->dim_size(0);
const int64 VAR_8 = VAR_4->dim_size(0);
const auto VAR_9 = VAR_2->vec<T>();
const auto VAR_10 = VAR_5->vec<T>();
OP_REQUIRES(
VAR_0, VAR_9.size() == VAR_7 && VAR_10.size() == VAR_8,
errors::InvalidArgument(""Expected "", VAR_7, "" and "", VAR_8,
"" non-empty input values, got "",
VAR_9.size(), "" and "", VAR_10.size()));
OP_REQUIRES(VAR_0,
TensorShapeUtils::IsVector(VAR_3->shape()) &&
TensorShapeUtils::IsVector(VAR_6->shape()),
errors::InvalidArgument(
""Input shapes should be a vector but received shapes "",
VAR_3->shape().DebugString(), "" and "",
VAR_6->shape().DebugString()));
OP_REQUIRES(VAR_0, VAR_3->IsSameSize(*VAR_6),
errors::InvalidArgument(
""Operands do not have the same ranks; got shapes: "",
VAR_3->SummarizeValue(10), "" and "",
VAR_6->SummarizeValue(10)));
const auto VAR_11 = VAR_3->flat<int64>();
const auto VAR_12 = VAR_6->flat<int64>();
for (int VAR_13 = 0; VAR_13 < VAR_3->NumElements(); ++VAR_13) {
OP_REQUIRES(VAR_0, VAR_11(VAR_13) == VAR_12(VAR_13),
errors::InvalidArgument(""Operands' shapes do not match: got "",
VAR_11(VAR_13), "" and "", VAR_12(VAR_13),
"" for dimension "", VAR_13));
}
OP_REQUIRES(
VAR_0, VAR_1->dim_size(1) == VAR_4->dim_size(1),
errors::InvalidArgument(
""Indices' dimensions do not match: got "", VAR_1->dim_size(1),
"" and "", VAR_4->dim_size(1), "" for the second dimension.""));
const int VAR_14 = VAR_1->dim_size(1);
const auto VAR_15 = VAR_1->matrix<int64>();
const auto VAR_16 = VAR_4->matrix<int64>();
std::vector<T> VAR_17, VAR_18;
std::vector<std::pair<bool, int64>> VAR_19;  
UnionSparseIndicesAndValues(VAR_15, VAR_9, VAR_7, VAR_16,
VAR_10, VAR_8, VAR_14, &VAR_17,
&VAR_18, &VAR_19);
const int64 VAR_20 = VAR_17.size();
Tensor *VAR_21, *VAR_22;
OP_REQUIRES_OK(VAR_0,
VAR_0->allocate_output(0, TensorShape({VAR_20, VAR_14}),
&VAR_21));
OP_REQUIRES_OK(
VAR_0, VAR_0->allocate_output(1, TensorShape({VAR_20}), &VAR_22));
auto VAR_23 = VAR_21->matrix<int64>();
for (int64 VAR_13 = 0; VAR_13 < VAR_20; ++VAR_13) {
const bool VAR_24 = VAR_19[VAR_13].first;
const int64 VAR_25 = VAR_19[VAR_13].second;
VAR_23.chip<0>(VAR_13) =
VAR_24 ? VAR_15.chip<0>(VAR_25) : VAR_16.chip<0>(VAR_25);
}
using UnalignedTensorMap =
Eigen::TensorMap<Eigen::Tensor<const T, 1, Eigen::RowMajor>,
Eigen::Unaligned>;
auto VAR_26 =
UnalignedTensorMap(VAR_17.data(), VAR_20);
auto VAR_27 =
UnalignedTensorMap(VAR_18.data(), VAR_20);
VAR_22->flat<T>().device(VAR_0->eigen_device<Device>()) =
VAR_26.binaryExpr(VAR_27,
VAR_28 Functor::func());
}",,"void Compute(OpKernelContext *ctx) override {
    const Tensor *a_indices_t, *a_values_t, *a_shape_t, *b_indices_t,
        *b_values_t, *b_shape_t;
    OP_REQUIRES_OK(ctx, ctx->input(""a_indices"", &a_indices_t));
    OP_REQUIRES_OK(ctx, ctx->input(""a_values"", &a_values_t));
    OP_REQUIRES_OK(ctx, ctx->input(""a_shape"", &a_shape_t));
    OP_REQUIRES_OK(ctx, ctx->input(""b_indices"", &b_indices_t));
    OP_REQUIRES_OK(ctx, ctx->input(""b_values"", &b_values_t));
    OP_REQUIRES_OK(ctx, ctx->input(""b_shape"", &b_shape_t));

    // Validations.
    OP_REQUIRES(
        ctx,
        TensorShapeUtils::IsMatrix(a_indices_t->shape()) &&
            TensorShapeUtils::IsMatrix(b_indices_t->shape()),
        errors::InvalidArgument(""Inputs a_indices and b_indices should be ""
                                ""matrices but received shapes: "",
                                a_indices_t->shape().DebugString(), "", "",
                                b_indices_t->shape().DebugString()));
    OP_REQUIRES(ctx,
                TensorShapeUtils::IsVector(a_values_t->shape()) &&
                    TensorShapeUtils::IsVector(b_values_t->shape()),
                errors::InvalidArgument(
                    ""Inputs a_values and b_values should be vectors ""
                    ""but received shapes: "",
                    a_values_t->shape().DebugString(), "" and "",
                    b_values_t->shape().DebugString()));

    const int64 a_nnz = a_indices_t->dim_size(0);
    const int64 b_nnz = b_indices_t->dim_size(0);

    const auto a_values = a_values_t->vec<T>();
    const auto b_values = b_values_t->vec<T>();

    OP_REQUIRES(
        ctx, a_values.size() == a_nnz && b_values.size() == b_nnz,
        errors::InvalidArgument(""Expected "", a_nnz, "" and "", b_nnz,
                                "" non-empty input values, got "",
                                a_values.size(), "" and "", b_values.size()));

    OP_REQUIRES(ctx,
                TensorShapeUtils::IsVector(a_shape_t->shape()) &&
                    TensorShapeUtils::IsVector(b_shape_t->shape()),
                errors::InvalidArgument(
                    ""Input shapes should be a vector but received shapes "",
                    a_shape_t->shape().DebugString(), "" and "",
                    b_shape_t->shape().DebugString()));
    const int num_dims = a_indices_t->dim_size(1);
    OP_REQUIRES(
        ctx, a_shape_t->NumElements() == num_dims,
        errors::InvalidArgument(""Second dimension of a_indices and length of ""
                                ""a_shape must match, got "",
                                num_dims, "" and "", a_shape_t->NumElements()));
    OP_REQUIRES(ctx, num_dims > 0,
                errors::InvalidArgument(""Tensors must not be empty""));
    OP_REQUIRES(ctx, a_shape_t->IsSameSize(*b_shape_t),
                errors::InvalidArgument(
                    ""Operands do not have the same ranks; got shapes: "",
                    a_shape_t->SummarizeValue(10), "" and "",
                    b_shape_t->SummarizeValue(10)));
    const auto a_shape = a_shape_t->flat<int64>();
    const auto b_shape = b_shape_t->flat<int64>();
    for (int i = 0; i < a_shape_t->NumElements(); ++i) {
      OP_REQUIRES(ctx, a_shape(i) == b_shape(i),
                  errors::InvalidArgument(""Operands' shapes do not match: got "",
                                          a_shape(i), "" and "", b_shape(i),
                                          "" for dimension "", i));
    }

    const auto a_indices_mat = a_indices_t->matrix<int64>();
    const auto b_indices_mat = b_indices_t->matrix<int64>();
    std::vector<T> a_augmented_values, b_augmented_values;
    std::vector<std::pair<bool, int64>> entries_to_copy;  // from_a?, idx
    UnionSparseIndicesAndValues(a_indices_mat, a_values, a_nnz, b_indices_mat,
                                b_values, b_nnz, num_dims, &a_augmented_values,
                                &b_augmented_values, &entries_to_copy);

    // Allocates and fills output tensors.
    const int64 sum_nnz = a_augmented_values.size();
    Tensor *output_indices_t, *output_values_t;
    OP_REQUIRES_OK(ctx,
                   ctx->allocate_output(0, TensorShape({sum_nnz, num_dims}),
                                        &output_indices_t));
    OP_REQUIRES_OK(
        ctx, ctx->allocate_output(1, TensorShape({sum_nnz}), &output_values_t));
    auto output_indices_mat = output_indices_t->matrix<int64>();

    for (int64 i = 0; i < sum_nnz; ++i) {
      const bool from_a = entries_to_copy[i].first;
      const int64 idx = entries_to_copy[i].second;
      output_indices_mat.chip<0>(i) =
          from_a ? a_indices_mat.chip<0>(idx) : b_indices_mat.chip<0>(idx);
    }

    // Performs the functor operation using Eigen.
    //
    // Note that the two stack-allocated std::vector's may not be aligned. Using
    // allocate_temp() would've given us aligned storage, but we do not know
    // their sizes in advance, so we couldn't use allocate_temp() anyway.
    //
    // TODO(zongheng): measure if it's worthwhile to somehow force alignment.
    using UnalignedTensorMap =
        Eigen::TensorMap<Eigen::Tensor<const T, 1, Eigen::RowMajor>,
                         Eigen::Unaligned>;
    auto a_augmented_values_t =
        UnalignedTensorMap(a_augmented_values.data(), sum_nnz);
    auto b_augmented_values_t =
        UnalignedTensorMap(b_augmented_values.data(), sum_nnz);
    output_values_t->flat<T>().device(ctx->eigen_device<Device>()) =
        a_augmented_values_t.binaryExpr(b_augmented_values_t,
                                        typename Functor::func());
  }","void Compute(OpKernelContext *VAR_0) override {
    const Tensor *VAR_1, *VAR_2, *VAR_3, *VAR_4,
        *VAR_5, *VAR_6;
    OP_REQUIRES_OK(VAR_0, VAR_0->input(""a_indices"", &VAR_1));
    OP_REQUIRES_OK(VAR_0, VAR_0->input(""a_values"", &VAR_2));
    OP_REQUIRES_OK(VAR_0, VAR_0->input(""a_shape"", &VAR_3));
    OP_REQUIRES_OK(VAR_0, VAR_0->input(""b_indices"", &VAR_4));
    OP_REQUIRES_OK(VAR_0, VAR_0->input(""b_values"", &VAR_5));
    OP_REQUIRES_OK(VAR_0, VAR_0->input(""b_shape"", &VAR_6));

    /* COMMENT_0 */
    OP_REQUIRES(
        VAR_0,
        TensorShapeUtils::IsMatrix(VAR_1->shape()) &&
            TensorShapeUtils::IsMatrix(VAR_4->shape()),
        errors::InvalidArgument(""Inputs a_indices and b_indices should be ""
                                ""matrices but received shapes: "",
                                VAR_1->shape().DebugString(), "", "",
                                VAR_4->shape().DebugString()));
    OP_REQUIRES(VAR_0,
                TensorShapeUtils::IsVector(VAR_2->shape()) &&
                    TensorShapeUtils::IsVector(VAR_5->shape()),
                errors::InvalidArgument(
                    ""Inputs a_values and b_values should be vectors ""
                    ""but received shapes: "",
                    VAR_2->shape().DebugString(), "" and "",
                    VAR_5->shape().DebugString()));

    const int64 VAR_7 = VAR_1->dim_size(0);
    const int64 VAR_8 = VAR_4->dim_size(0);

    const auto VAR_9 = VAR_2->vec<T>();
    const auto VAR_10 = VAR_5->vec<T>();

    OP_REQUIRES(
        VAR_0, VAR_9.size() == VAR_7 && VAR_10.size() == VAR_8,
        errors::InvalidArgument(""Expected "", VAR_7, "" and "", VAR_8,
                                "" non-empty input values, got "",
                                VAR_9.size(), "" and "", VAR_10.size()));

    OP_REQUIRES(VAR_0,
                TensorShapeUtils::IsVector(VAR_3->shape()) &&
                    TensorShapeUtils::IsVector(VAR_6->shape()),
                errors::InvalidArgument(
                    ""Input shapes should be a vector but received shapes "",
                    VAR_3->shape().DebugString(), "" and "",
                    VAR_6->shape().DebugString()));
    const int VAR_11 = VAR_1->dim_size(1);
    OP_REQUIRES(
        VAR_0, VAR_3->NumElements() == VAR_11,
        errors::InvalidArgument(""Second dimension of a_indices and length of ""
                                ""a_shape must match, got "",
                                VAR_11, "" and "", VAR_3->NumElements()));
    OP_REQUIRES(VAR_0, VAR_11 > 0,
                errors::InvalidArgument(""Tensors must not be empty""));
    OP_REQUIRES(VAR_0, VAR_3->IsSameSize(*VAR_6),
                errors::InvalidArgument(
                    ""Operands do not have the same ranks; got shapes: "",
                    VAR_3->SummarizeValue(10), "" and "",
                    VAR_6->SummarizeValue(10)));
    const auto VAR_12 = VAR_3->flat<int64>();
    const auto VAR_13 = VAR_6->flat<int64>();
    for (int VAR_14 = 0; VAR_14 < VAR_3->NumElements(); ++VAR_14) {
      OP_REQUIRES(VAR_0, VAR_12(VAR_14) == VAR_13(VAR_14),
                  errors::InvalidArgument(""Operands' shapes do not match: got "",
                                          VAR_12(VAR_14), "" and "", VAR_13(VAR_14),
                                          "" for dimension "", VAR_14));
    }

    const auto VAR_15 = VAR_1->matrix<int64>();
    const auto VAR_16 = VAR_4->matrix<int64>();
    std::vector<T> VAR_17, VAR_18;
    std::vector<std::pair<bool, int64>> VAR_19;  /* COMMENT_1 */
    UnionSparseIndicesAndValues(VAR_15, VAR_9, VAR_7, VAR_16,
                                VAR_10, VAR_8, VAR_11, &VAR_17,
                                &VAR_18, &VAR_19);

    /* COMMENT_2 */
    const int64 VAR_20 = VAR_17.size();
    Tensor *VAR_21, *VAR_22;
    OP_REQUIRES_OK(VAR_0,
                   VAR_0->allocate_output(0, TensorShape({VAR_20, VAR_11}),
                                        &VAR_21));
    OP_REQUIRES_OK(
        VAR_0, VAR_0->allocate_output(1, TensorShape({VAR_20}), &VAR_22));
    auto VAR_23 = VAR_21->matrix<int64>();

    for (int64 VAR_14 = 0; VAR_14 < VAR_20; ++VAR_14) {
      const bool VAR_24 = VAR_19[VAR_14].first;
      const int64 VAR_25 = VAR_19[VAR_14].second;
      VAR_23.chip<0>(VAR_14) =
          VAR_24 ? VAR_15.chip<0>(VAR_25) : VAR_16.chip<0>(VAR_25);
    }

    /* COMMENT_3 */
    /* COMMENT_4 */
    /* COMMENT_5 */
    /* COMMENT_6 */
    /* COMMENT_7 */
    /* COMMENT_4 */
    /* COMMENT_8 */
    using UnalignedTensorMap =
        Eigen::TensorMap<Eigen::Tensor<const T, 1, Eigen::RowMajor>,
                         Eigen::Unaligned>;
    auto VAR_26 =
        UnalignedTensorMap(VAR_17.data(), VAR_20);
    auto VAR_27 =
        UnalignedTensorMap(VAR_18.data(), VAR_20);
    VAR_22->flat<T>().device(VAR_0->eigen_device<Device>()) =
        VAR_26.binaryExpr(VAR_27,
                                        VAR_28 Functor::func());
  }",,"--- func_before
+++ func_after
@@ -28,6 +28,7 @@
 
     const int64 a_nnz = a_indices_t->dim_size(0);
     const int64 b_nnz = b_indices_t->dim_size(0);
+
     const auto a_values = a_values_t->vec<T>();
     const auto b_values = b_values_t->vec<T>();
 
@@ -44,6 +45,14 @@
                     ""Input shapes should be a vector but received shapes "",
                     a_shape_t->shape().DebugString(), "" and "",
                     b_shape_t->shape().DebugString()));
+    const int num_dims = a_indices_t->dim_size(1);
+    OP_REQUIRES(
+        ctx, a_shape_t->NumElements() == num_dims,
+        errors::InvalidArgument(""Second dimension of a_indices and length of ""
+                                ""a_shape must match, got "",
+                                num_dims, "" and "", a_shape_t->NumElements()));
+    OP_REQUIRES(ctx, num_dims > 0,
+                errors::InvalidArgument(""Tensors must not be empty""));
     OP_REQUIRES(ctx, a_shape_t->IsSameSize(*b_shape_t),
                 errors::InvalidArgument(
                     ""Operands do not have the same ranks; got shapes: "",
@@ -58,12 +67,6 @@
                                           "" for dimension "", i));
     }
 
-    OP_REQUIRES(
-        ctx, a_indices_t->dim_size(1) == b_indices_t->dim_size(1),
-        errors::InvalidArgument(
-            ""Indices' dimensions do not match: got "", a_indices_t->dim_size(1),
-            "" and "", b_indices_t->dim_size(1), "" for the second dimension.""));
-    const int num_dims = a_indices_t->dim_size(1);
     const auto a_indices_mat = a_indices_t->matrix<int64>();
     const auto b_indices_mat = b_indices_t->matrix<int64>();
     std::vector<T> a_augmented_values, b_augmented_values;","{'deleted_lines': ['    OP_REQUIRES(', '        ctx, a_indices_t->dim_size(1) == b_indices_t->dim_size(1),', '        errors::InvalidArgument(', '            ""Indices\' dimensions do not match: got "", a_indices_t->dim_size(1),', '            "" and "", b_indices_t->dim_size(1), "" for the second dimension.""));', '    const int num_dims = a_indices_t->dim_size(1);'], 'added_lines': ['', '    const int num_dims = a_indices_t->dim_size(1);', '    OP_REQUIRES(', '        ctx, a_shape_t->NumElements() == num_dims,', '        errors::InvalidArgument(""Second dimension of a_indices and length of ""', '                                ""a_shape must match, got "",', '                                num_dims, "" and "", a_shape_t->NumElements()));', '    OP_REQUIRES(ctx, num_dims > 0,', '                errors::InvalidArgument(""Tensors must not be empty""));']}",True,"TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseAdd` results in allowing attackers to exploit undefined behavior (dereferencing null pointers) as well as write outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/sparse_sparse_binary_op_shared.cc) has a large set of validation for the two sparse tensor inputs (6 tensors in total), but does not validate that the tensors are not empty or that the second dimension of `*_indices` matches the size of corresponding `*_shape`. This allows attackers to send tensor triples that represent invalid sparse tensors to abuse code assumptions that are not protected by validation. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",5.3,MEDIUM,1,valid,2021-05-12T01:32:03Z,3
CVE-2021-36082,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ntop/nDPI,Added further checks,1ec621c85b9411cc611652fd57a892cfef478af3,https://github.com/ntop/nDPI/commit/1ec621c85b9411cc611652fd57a892cfef478af3,src/lib/protocols/netbios.c,ndpi_netbios_name_interpret,"int ndpi_netbios_name_interpret(char *in, size_t in_len, char *out, u_int out_len) {
u_int ret = 0, len, idx = in_len, out_idx = 0;
len = (*in++)/2;
out_len--;
out[out_idx] = 0;
if((len > out_len) || (len < 1) || ((2*len) > in_len))
return(-1);
while((len--) && (out_idx < out_len)) {
if((idx < 2) || (in[0] < 'A') || (in[0] > 'P') || (in[1] < 'A') || (in[1] > 'P')) {
out[out_idx] = 0;
break;
}
out[out_idx] = ((in[0] - 'A') << 4) + (in[1] - 'A');
in += 2, idx -= 2;
if(isprint(out[out_idx]))
out_idx++, ret++;
}
if(out_idx > 0) {
out[out_idx] = 0;
out_idx--;
while((out_idx > 0) && (out[out_idx] == ' ')) {
out[out_idx] = 0;
out_idx--;
}
}
return(ret);
}","int ndpi_netbios_name_interpret(char *VAR_0, size_t VAR_1, char *VAR_2, u_int VAR_3) {
u_int VAR_4 = 0, VAR_5, VAR_6 = VAR_1, VAR_7 = 0;
VAR_5 = (*VAR_0++)/2;
VAR_3--;
VAR_2[VAR_7] = 0;
if((VAR_5 > VAR_3) || (VAR_5 < 1) || ((2*VAR_5) > VAR_1))
return(-1);
while((VAR_5--) && (VAR_7 < VAR_3)) {
if((VAR_6 < 2) || (VAR_0[0] < 'A') || (VAR_0[0] > 'P') || (VAR_0[1] < 'A') || (VAR_0[1] > 'P')) {
VAR_2[VAR_7] = 0;
break;
}
VAR_2[VAR_7] = ((VAR_0[0] - 'A') << 4) + (VAR_0[1] - 'A');
VAR_0 += 2, VAR_6 -= 2;
if(isprint(VAR_2[VAR_7]))
VAR_7++, VAR_4++;
}
if(VAR_7 > 0) {
VAR_2[VAR_7] = 0;
VAR_7--;
while((VAR_7 > 0) && (VAR_2[VAR_7] == ' ')) {
VAR_2[VAR_7] = 0;
VAR_7--;
}
}
return(VAR_4);
}",ntop/nDPI/1ec621c85b9411cc611652fd57a892cfef478af3/netbios.c/vul/before/0.json,"int ndpi_netbios_name_interpret(char *in, size_t in_len, char *out, u_int out_len) {
  u_int ret = 0, len, idx = in_len, out_idx = 0;

  len = (*in++)/2, in_len--;
  out_len--;
  out[out_idx] = 0;

  if((len > out_len) || (len < 1) || ((2*len) > in_len))
    return(-1);

  while((len--) && (out_idx < out_len)) {
    if((idx < 2) || (in[0] < 'A') || (in[0] > 'P') || (in[1] < 'A') || (in[1] > 'P')) {
      out[out_idx] = 0;
      break;
    }

    out[out_idx] = ((in[0] - 'A') << 4) + (in[1] - 'A');
    in += 2, idx -= 2;

    if(isprint(out[out_idx]))
      out_idx++, ret++;
  }

  /* Trim trailing whitespace from the returned string */
  if(out_idx > 0) {
    out[out_idx] = 0;
    out_idx--;

    while((out_idx > 0) && (out[out_idx] == ' ')) {
      out[out_idx] = 0;
      out_idx--;
    }

  }

  return(ret);
}","int ndpi_netbios_name_interpret(char *VAR_0, size_t VAR_1, char *VAR_2, u_int VAR_3) {
  u_int VAR_4 = 0, VAR_5, VAR_6 = VAR_1, VAR_7 = 0;

  VAR_5 = (*VAR_0++)/2, VAR_1--;
  VAR_3--;
  VAR_2[VAR_7] = 0;

  if((VAR_5 > VAR_3) || (VAR_5 < 1) || ((2*VAR_5) > VAR_1))
    return(-1);

  while((VAR_5--) && (VAR_7 < VAR_3)) {
    if((VAR_6 < 2) || (VAR_0[0] < 'A') || (VAR_0[0] > 'P') || (VAR_0[1] < 'A') || (VAR_0[1] > 'P')) {
      VAR_2[VAR_7] = 0;
      break;
    }

    VAR_2[VAR_7] = ((VAR_0[0] - 'A') << 4) + (VAR_0[1] - 'A');
    VAR_0 += 2, VAR_6 -= 2;

    if(isprint(VAR_2[VAR_7]))
      VAR_7++, VAR_4++;
  }

  /* COMMENT_0 */
  if(VAR_7 > 0) {
    VAR_2[VAR_7] = 0;
    VAR_7--;

    while((VAR_7 > 0) && (VAR_2[VAR_7] == ' ')) {
      VAR_2[VAR_7] = 0;
      VAR_7--;
    }

  }

  return(VAR_4);
}",ntop/nDPI/1ec621c85b9411cc611652fd57a892cfef478af3/netbios.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 int ndpi_netbios_name_interpret(char *in, size_t in_len, char *out, u_int out_len) {
   u_int ret = 0, len, idx = in_len, out_idx = 0;
 
-  len = (*in++)/2;
+  len = (*in++)/2, in_len--;
   out_len--;
   out[out_idx] = 0;
 ","{'deleted_lines': ['  len = (*in++)/2;'], 'added_lines': ['  len = (*in++)/2, in_len--;']}",True,ntop nDPI 3.4 has a stack-based buffer overflow in processClientServerHello.,8.8,HIGH,2,valid,2021-05-15T17:53:46Z,3
CVE-2021-36147,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,projectacrn/acrn-hypervisor,"dm: NULL check of vq->used in virtio_net_ping_rxq

Add a check on this place to avoid NULL access issue.

Tracked-On: #6100
Signed-off-by: Jie Deng <jie.deng@intel.com>",131116b15b0e35a62085d23686b43ed1c12c1331,https://github.com/projectacrn/acrn-hypervisor/commit/131116b15b0e35a62085d23686b43ed1c12c1331,devicemodel/hw/pci/virtio/virtio_net.c,virtio_net_ping_rxq,"static void
virtio_net_ping_rxq(void *vdev, struct virtio_vq_info *vq)
{
struct virtio_net *net = vdev;
if (net->rx_ready == 0) {
net->rx_ready = 1;
vq->used->flags |= VRING_USED_F_NO_NOTIFY;
}
}","static void
virtio_net_ping_rxq(void *VAR_0, struct virtio_vq_info *VAR_1)
{
struct virtio_net *VAR_2 = VAR_0;
if (VAR_2->rx_ready == 0) {
VAR_2->rx_ready = 1;
VAR_1->used->flags |= VAR_3;
}
}",projectacrn/acrn-hypervisor/131116b15b0e35a62085d23686b43ed1c12c1331/virtio_net.c/vul/before/0.json,"static void
virtio_net_ping_rxq(void *vdev, struct virtio_vq_info *vq)
{
	struct virtio_net *net = vdev;

	/*
	 * A qnotify means that the rx process can now begin
	 */
	if (net->rx_ready == 0) {
		net->rx_ready = 1;
		if (vq->used != NULL) {
			vq->used->flags |= VRING_USED_F_NO_NOTIFY;
		}
	}
}","static void
virtio_net_ping_rxq(void *VAR_0, struct virtio_vq_info *VAR_1)
{
	struct virtio_net *VAR_2 = VAR_0;

	/* COMMENT_0 */
                                                     
    
	if (VAR_2->rx_ready == 0) {
		VAR_2->rx_ready = 1;
		if (VAR_1->used != NULL) {
			VAR_1->used->flags |= VAR_3;
		}
	}
}",projectacrn/acrn-hypervisor/131116b15b0e35a62085d23686b43ed1c12c1331/virtio_net.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,6 +8,8 @@
 	 */
 	if (net->rx_ready == 0) {
 		net->rx_ready = 1;
-		vq->used->flags |= VRING_USED_F_NO_NOTIFY;
+		if (vq->used != NULL) {
+			vq->used->flags |= VRING_USED_F_NO_NOTIFY;
+		}
 	}
 }","{'deleted_lines': ['\t\tvq->used->flags |= VRING_USED_F_NO_NOTIFY;'], 'added_lines': ['\t\tif (vq->used != NULL) {', '\t\t\tvq->used->flags |= VRING_USED_F_NO_NOTIFY;', '\t\t}']}",True,An issue was discovered in ACRN before 2.5. It allows a devicemodel/hw/pci/virtio/virtio_net.c virtio_net_ping_rxq NULL pointer dereference for vq->used.,7.5,HIGH,2,valid,2021-05-24T05:57:49Z,3
CVE-2021-33815,['CWE-129'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ffmpeg,"avcodec/exr: More strictly check dc_count

Fixes: out of array access
Fixes: exr/deneme

Found-by: Burak ark <burakcarikci@crypttech.com>
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",26d3c81bc5ef2f8c3f09d45eaeacfb4b1139a777,https://github.com/FFmpeg/FFmpeg/commit/26d3c81bc5ef2f8c3f09d45eaeacfb4b1139a777,libavcodec/exr.c,dwa_uncompress,"static int dwa_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,
int uncompressed_size, EXRThreadData *td)
{
int64_t version, lo_usize, lo_size;
int64_t ac_size, dc_size, rle_usize, rle_csize, rle_raw_size;
int64_t ac_count, dc_count, ac_compression;
const int dc_w = td->xsize >> 3;
const int dc_h = td->ysize >> 3;
GetByteContext gb, agb;
int skip, ret;
if (compressed_size <= 88)
return AVERROR_INVALIDDATA;
version = AV_RL64(src + 0);
if (version != 2)
return AVERROR_INVALIDDATA;
lo_usize = AV_RL64(src + 8);
lo_size = AV_RL64(src + 16);
ac_size = AV_RL64(src + 24);
dc_size = AV_RL64(src + 32);
rle_csize = AV_RL64(src + 40);
rle_usize = AV_RL64(src + 48);
rle_raw_size = AV_RL64(src + 56);
ac_count = AV_RL64(src + 64);
dc_count = AV_RL64(src + 72);
ac_compression = AV_RL64(src + 80);
if (compressed_size < 88LL + lo_size + ac_size + dc_size + rle_csize)
return AVERROR_INVALIDDATA;
bytestream2_init(&gb, src + 88, compressed_size - 88);
skip = bytestream2_get_le16(&gb);
if (skip < 2)
return AVERROR_INVALIDDATA;
bytestream2_skip(&gb, skip - 2);
if (lo_size > 0) {
if (lo_usize > uncompressed_size)
return AVERROR_INVALIDDATA;
bytestream2_skip(&gb, lo_size);
}
if (ac_size > 0) {
unsigned long dest_len = ac_count * 2LL;
GetByteContext agb = gb;
if (ac_count > 3LL * td->xsize * s->scan_lines_per_block)
return AVERROR_INVALIDDATA;
av_fast_padded_malloc(&td->ac_data, &td->ac_size, dest_len);
if (!td->ac_data)
return AVERROR(ENOMEM);
switch (ac_compression) {
case 0:
ret = huf_uncompress(s, td, &agb, (int16_t *)td->ac_data, ac_count);
if (ret < 0)
return ret;
break;
case 1:
if (uncompress(td->ac_data, &dest_len, agb.buffer, ac_size) != Z_OK ||
dest_len != ac_count * 2LL)
return AVERROR_INVALIDDATA;
break;
default:
return AVERROR_INVALIDDATA;
}
bytestream2_skip(&gb, ac_size);
}
if (dc_size > 0) {
unsigned long dest_len = dc_count * 2LL;
GetByteContext agb = gb;
if (dc_count > (6LL * td->xsize * td->ysize + 63) / 64)
return AVERROR_INVALIDDATA;
av_fast_padded_malloc(&td->dc_data, &td->dc_size, FFALIGN(dest_len, 64) * 2);
if (!td->dc_data)
return AVERROR(ENOMEM);
if (uncompress(td->dc_data + FFALIGN(dest_len, 64), &dest_len, agb.buffer, dc_size) != Z_OK ||
(dest_len != dc_count * 2LL))
return AVERROR_INVALIDDATA;
s->dsp.predictor(td->dc_data + FFALIGN(dest_len, 64), dest_len);
s->dsp.reorder_pixels(td->dc_data, td->dc_data + FFALIGN(dest_len, 64), dest_len);
bytestream2_skip(&gb, dc_size);
}
if (rle_raw_size > 0 && rle_csize > 0 && rle_usize > 0) {
unsigned long dest_len = rle_usize;
av_fast_padded_malloc(&td->rle_data, &td->rle_size, rle_usize);
if (!td->rle_data)
return AVERROR(ENOMEM);
av_fast_padded_malloc(&td->rle_raw_data, &td->rle_raw_size, rle_raw_size);
if (!td->rle_raw_data)
return AVERROR(ENOMEM);
if (uncompress(td->rle_data, &dest_len, gb.buffer, rle_csize) != Z_OK ||
(dest_len != rle_usize))
return AVERROR_INVALIDDATA;
ret = rle(td->rle_raw_data, td->rle_data, rle_usize, rle_raw_size);
if (ret < 0)
return ret;
bytestream2_skip(&gb, rle_csize);
}
bytestream2_init(&agb, td->ac_data, ac_count * 2);
for (int y = 0; y < td->ysize; y += 8) {
for (int x = 0; x < td->xsize; x += 8) {
memset(td->block, 0, sizeof(td->block));
for (int j = 0; j < 3; j++) {
float *block = td->block[j];
const int idx = (x >> 3) + (y >> 3) * dc_w + dc_w * dc_h * j;
uint16_t *dc = (uint16_t *)td->dc_data;
union av_intfloat32 dc_val;
dc_val.i = half2float(dc[idx], s->mantissatable,
s->exponenttable, s->offsettable);
block[0] = dc_val.f;
ac_uncompress(s, &agb, block);
dct_inverse(block);
}
{
const float scale = s->pixel_type == EXR_FLOAT ? 2.f : 1.f;
const int o = s->nb_channels == 4;
float *bo = ((float *)td->uncompressed_data) +
y * td->xsize * s->nb_channels + td->xsize * (o + 0) + x;
float *go = ((float *)td->uncompressed_data) +
y * td->xsize * s->nb_channels + td->xsize * (o + 1) + x;
float *ro = ((float *)td->uncompressed_data) +
y * td->xsize * s->nb_channels + td->xsize * (o + 2) + x;
float *yb = td->block[0];
float *ub = td->block[1];
float *vb = td->block[2];
for (int yy = 0; yy < 8; yy++) {
for (int xx = 0; xx < 8; xx++) {
const int idx = xx + yy * 8;
convert(yb[idx], ub[idx], vb[idx], &bo[xx], &go[xx], &ro[xx]);
bo[xx] = to_linear(bo[xx], scale);
go[xx] = to_linear(go[xx], scale);
ro[xx] = to_linear(ro[xx], scale);
}
bo += td->xsize * s->nb_channels;
go += td->xsize * s->nb_channels;
ro += td->xsize * s->nb_channels;
}
}
}
}
if (s->nb_channels < 4)
return 0;
for (int y = 0; y < td->ysize && td->rle_raw_data; y++) {
uint32_t *ao = ((uint32_t *)td->uncompressed_data) + y * td->xsize * s->nb_channels;
uint8_t *ai0 = td->rle_raw_data + y * td->xsize;
uint8_t *ai1 = td->rle_raw_data + y * td->xsize + rle_raw_size / 2;
for (int x = 0; x < td->xsize; x++) {
uint16_t ha = ai0[x] | (ai1[x] << 8);
ao[x] = half2float(ha, s->mantissatable, s->exponenttable, s->offsettable);
}
}
return 0;
}","static int dwa_uncompress(EXRContext *VAR_0, const uint8_t *VAR_1, int VAR_2,
int VAR_3, EXRThreadData *VAR_4)
{
int64_t VAR_5, VAR_6, VAR_7;
int64_t VAR_8, VAR_9, VAR_10, VAR_11, VAR_12;
int64_t VAR_13, VAR_14, VAR_15;
const int VAR_16 = VAR_4->xsize >> 3;
const int VAR_17 = VAR_4->ysize >> 3;
GetByteContext VAR_18, VAR_19;
int VAR_20, VAR_21;
if (VAR_2 <= 88)
return VAR_22;
VAR_5 = AV_RL64(VAR_1 + 0);
if (VAR_5 != 2)
return VAR_22;
VAR_6 = AV_RL64(VAR_1 + 8);
VAR_7 = AV_RL64(VAR_1 + 16);
VAR_8 = AV_RL64(VAR_1 + 24);
VAR_9 = AV_RL64(VAR_1 + 32);
VAR_11 = AV_RL64(VAR_1 + 40);
VAR_10 = AV_RL64(VAR_1 + 48);
VAR_12 = AV_RL64(VAR_1 + 56);
VAR_13 = AV_RL64(VAR_1 + 64);
VAR_14 = AV_RL64(VAR_1 + 72);
VAR_15 = AV_RL64(VAR_1 + 80);
if (VAR_2 < 88LL + VAR_7 + VAR_8 + VAR_9 + VAR_11)
return VAR_22;
bytestream2_init(&VAR_18, VAR_1 + 88, VAR_2 - 88);
VAR_20 = bytestream2_get_le16(&VAR_18);
if (VAR_20 < 2)
return VAR_22;
bytestream2_skip(&VAR_18, VAR_20 - 2);
if (VAR_7 > 0) {
if (VAR_6 > VAR_3)
return VAR_22;
bytestream2_skip(&VAR_18, VAR_7);
}
if (VAR_8 > 0) {
unsigned long VAR_23 = VAR_13 * 2LL;
GetByteContext VAR_19 = VAR_18;
if (VAR_13 > 3LL * VAR_4->xsize * VAR_0->scan_lines_per_block)
return VAR_22;
av_fast_padded_malloc(&VAR_4->ac_data, &VAR_4->ac_size, VAR_23);
if (!VAR_4->ac_data)
return AVERROR(VAR_24);
switch (VAR_15) {
case 0:
VAR_21 = huf_uncompress(VAR_0, VAR_4, &VAR_19, (int16_t *)VAR_4->ac_data, VAR_13);
if (VAR_21 < 0)
return VAR_21;
break;
case 1:
if (uncompress(VAR_4->ac_data, &VAR_23, VAR_19.buffer, VAR_8) != VAR_25 ||
VAR_23 != VAR_13 * 2LL)
return VAR_22;
break;
default:
return VAR_22;
}
bytestream2_skip(&VAR_18, VAR_8);
}
if (VAR_9 > 0) {
unsigned long VAR_23 = VAR_14 * 2LL;
GetByteContext VAR_19 = VAR_18;
if (VAR_14 > (6LL * VAR_4->xsize * VAR_4->ysize + 63) / 64)
return VAR_22;
av_fast_padded_malloc(&VAR_4->dc_data, &VAR_4->dc_size, FFALIGN(VAR_23, 64) * 2);
if (!VAR_4->dc_data)
return AVERROR(VAR_24);
if (uncompress(VAR_4->dc_data + FFALIGN(VAR_23, 64), &VAR_23, VAR_19.buffer, VAR_9) != VAR_25 ||
(VAR_23 != VAR_14 * 2LL))
return VAR_22;
VAR_0->dsp.predictor(VAR_4->dc_data + FFALIGN(VAR_23, 64), VAR_23);
VAR_0->dsp.reorder_pixels(VAR_4->dc_data, VAR_4->dc_data + FFALIGN(VAR_23, 64), VAR_23);
bytestream2_skip(&VAR_18, VAR_9);
}
if (VAR_12 > 0 && VAR_11 > 0 && VAR_10 > 0) {
unsigned long VAR_23 = VAR_10;
av_fast_padded_malloc(&VAR_4->rle_data, &VAR_4->rle_size, VAR_10);
if (!VAR_4->rle_data)
return AVERROR(VAR_24);
av_fast_padded_malloc(&VAR_4->rle_raw_data, &VAR_4->rle_raw_size, VAR_12);
if (!VAR_4->rle_raw_data)
return AVERROR(VAR_24);
if (uncompress(VAR_4->rle_data, &VAR_23, VAR_18.buffer, VAR_11) != VAR_25 ||
(VAR_23 != VAR_10))
return VAR_22;
VAR_21 = rle(VAR_4->rle_raw_data, VAR_4->rle_data, VAR_10, VAR_12);
if (VAR_21 < 0)
return VAR_21;
bytestream2_skip(&VAR_18, VAR_11);
}
bytestream2_init(&VAR_19, VAR_4->ac_data, VAR_13 * 2);
for (int VAR_26 = 0; VAR_26 < VAR_4->ysize; VAR_26 += 8) {
for (int VAR_27 = 0; VAR_27 < VAR_4->xsize; VAR_27 += 8) {
memset(VAR_4->block, 0, sizeof(VAR_4->block));
for (int VAR_28 = 0; VAR_28 < 3; VAR_28++) {
float *VAR_29 = VAR_4->block[VAR_28];
const int VAR_30 = (VAR_27 >> 3) + (VAR_26 >> 3) * VAR_16 + VAR_16 * VAR_17 * VAR_28;
uint16_t *VAR_31 = (uint16_t *)VAR_4->dc_data;
union av_intfloat32 VAR_32;
VAR_32.i = half2float(VAR_31[VAR_30], VAR_0->mantissatable,
VAR_0->exponenttable, VAR_0->offsettable);
VAR_29[0] = VAR_32.f;
ac_uncompress(VAR_0, &VAR_19, VAR_29);
dct_inverse(VAR_29);
}
{
const float VAR_33 = VAR_0->pixel_type == VAR_34 ? 2.f : 1.f;
const int VAR_35 = VAR_0->nb_channels == 4;
float *VAR_36 = ((float *)VAR_4->uncompressed_data) +
VAR_26 * VAR_4->xsize * VAR_0->nb_channels + VAR_4->xsize * (VAR_35 + 0) + VAR_27;
float *VAR_37 = ((float *)VAR_4->uncompressed_data) +
VAR_26 * VAR_4->xsize * VAR_0->nb_channels + VAR_4->xsize * (VAR_35 + 1) + VAR_27;
float *VAR_38 = ((float *)VAR_4->uncompressed_data) +
VAR_26 * VAR_4->xsize * VAR_0->nb_channels + VAR_4->xsize * (VAR_35 + 2) + VAR_27;
float *VAR_39 = VAR_4->block[0];
float *VAR_40 = VAR_4->block[1];
float *VAR_41 = VAR_4->block[2];
for (int VAR_42 = 0; VAR_42 < 8; VAR_42++) {
for (int VAR_43 = 0; VAR_43 < 8; VAR_43++) {
const int VAR_30 = VAR_43 + VAR_42 * 8;
convert(VAR_39[VAR_30], VAR_40[VAR_30], VAR_41[VAR_30], &VAR_36[VAR_43], &VAR_37[VAR_43], &VAR_38[VAR_43]);
VAR_36[VAR_43] = to_linear(VAR_36[VAR_43], VAR_33);
VAR_37[VAR_43] = to_linear(VAR_37[VAR_43], VAR_33);
VAR_38[VAR_43] = to_linear(VAR_38[VAR_43], VAR_33);
}
VAR_36 += VAR_4->xsize * VAR_0->nb_channels;
VAR_37 += VAR_4->xsize * VAR_0->nb_channels;
VAR_38 += VAR_4->xsize * VAR_0->nb_channels;
}
}
}
}
if (VAR_0->nb_channels < 4)
return 0;
for (int VAR_26 = 0; VAR_26 < VAR_4->ysize && VAR_4->rle_raw_data; VAR_26++) {
uint32_t *VAR_44 = ((uint32_t *)VAR_4->uncompressed_data) + VAR_26 * VAR_4->xsize * VAR_0->nb_channels;
uint8_t *VAR_45 = VAR_4->rle_raw_data + VAR_26 * VAR_4->xsize;
uint8_t *VAR_46 = VAR_4->rle_raw_data + VAR_26 * VAR_4->xsize + VAR_12 / 2;
for (int VAR_27 = 0; VAR_27 < VAR_4->xsize; VAR_27++) {
uint16_t VAR_47 = VAR_45[VAR_27] | (VAR_46[VAR_27] << 8);
VAR_44[VAR_27] = half2float(VAR_47, VAR_0->mantissatable, VAR_0->exponenttable, VAR_0->offsettable);
}
}
return 0;
}",ffmpeg/26d3c81bc5ef2f8c3f09d45eaeacfb4b1139a777/exr.c/vul/before/0.json,"static int dwa_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,
                          int uncompressed_size, EXRThreadData *td)
{
    int64_t version, lo_usize, lo_size;
    int64_t ac_size, dc_size, rle_usize, rle_csize, rle_raw_size;
    int64_t ac_count, dc_count, ac_compression;
    const int dc_w = td->xsize >> 3;
    const int dc_h = td->ysize >> 3;
    GetByteContext gb, agb;
    int skip, ret;

    if (compressed_size <= 88)
        return AVERROR_INVALIDDATA;

    version = AV_RL64(src + 0);
    if (version != 2)
        return AVERROR_INVALIDDATA;

    lo_usize = AV_RL64(src + 8);
    lo_size = AV_RL64(src + 16);
    ac_size = AV_RL64(src + 24);
    dc_size = AV_RL64(src + 32);
    rle_csize = AV_RL64(src + 40);
    rle_usize = AV_RL64(src + 48);
    rle_raw_size = AV_RL64(src + 56);
    ac_count = AV_RL64(src + 64);
    dc_count = AV_RL64(src + 72);
    ac_compression = AV_RL64(src + 80);

    if (compressed_size < 88LL + lo_size + ac_size + dc_size + rle_csize)
        return AVERROR_INVALIDDATA;

    bytestream2_init(&gb, src + 88, compressed_size - 88);
    skip = bytestream2_get_le16(&gb);
    if (skip < 2)
        return AVERROR_INVALIDDATA;

    bytestream2_skip(&gb, skip - 2);

    if (lo_size > 0) {
        if (lo_usize > uncompressed_size)
            return AVERROR_INVALIDDATA;
        bytestream2_skip(&gb, lo_size);
    }

    if (ac_size > 0) {
        unsigned long dest_len = ac_count * 2LL;
        GetByteContext agb = gb;

        if (ac_count > 3LL * td->xsize * s->scan_lines_per_block)
            return AVERROR_INVALIDDATA;

        av_fast_padded_malloc(&td->ac_data, &td->ac_size, dest_len);
        if (!td->ac_data)
            return AVERROR(ENOMEM);

        switch (ac_compression) {
        case 0:
            ret = huf_uncompress(s, td, &agb, (int16_t *)td->ac_data, ac_count);
            if (ret < 0)
                return ret;
            break;
        case 1:
            if (uncompress(td->ac_data, &dest_len, agb.buffer, ac_size) != Z_OK ||
                dest_len != ac_count * 2LL)
                return AVERROR_INVALIDDATA;
            break;
        default:
            return AVERROR_INVALIDDATA;
        }

        bytestream2_skip(&gb, ac_size);
    }

    {
        unsigned long dest_len = dc_count * 2LL;
        GetByteContext agb = gb;

        if (dc_count != dc_w * dc_h * 3)
            return AVERROR_INVALIDDATA;

        av_fast_padded_malloc(&td->dc_data, &td->dc_size, FFALIGN(dest_len, 64) * 2);
        if (!td->dc_data)
            return AVERROR(ENOMEM);

        if (uncompress(td->dc_data + FFALIGN(dest_len, 64), &dest_len, agb.buffer, dc_size) != Z_OK ||
            (dest_len != dc_count * 2LL))
            return AVERROR_INVALIDDATA;

        s->dsp.predictor(td->dc_data + FFALIGN(dest_len, 64), dest_len);
        s->dsp.reorder_pixels(td->dc_data, td->dc_data + FFALIGN(dest_len, 64), dest_len);

        bytestream2_skip(&gb, dc_size);
    }

    if (rle_raw_size > 0 && rle_csize > 0 && rle_usize > 0) {
        unsigned long dest_len = rle_usize;

        av_fast_padded_malloc(&td->rle_data, &td->rle_size, rle_usize);
        if (!td->rle_data)
            return AVERROR(ENOMEM);

        av_fast_padded_malloc(&td->rle_raw_data, &td->rle_raw_size, rle_raw_size);
        if (!td->rle_raw_data)
            return AVERROR(ENOMEM);

        if (uncompress(td->rle_data, &dest_len, gb.buffer, rle_csize) != Z_OK ||
            (dest_len != rle_usize))
            return AVERROR_INVALIDDATA;

        ret = rle(td->rle_raw_data, td->rle_data, rle_usize, rle_raw_size);
        if (ret < 0)
            return ret;
        bytestream2_skip(&gb, rle_csize);
    }

    bytestream2_init(&agb, td->ac_data, ac_count * 2);

    for (int y = 0; y < td->ysize; y += 8) {
        for (int x = 0; x < td->xsize; x += 8) {
            memset(td->block, 0, sizeof(td->block));

            for (int j = 0; j < 3; j++) {
                float *block = td->block[j];
                const int idx = (x >> 3) + (y >> 3) * dc_w + dc_w * dc_h * j;
                uint16_t *dc = (uint16_t *)td->dc_data;
                union av_intfloat32 dc_val;

                dc_val.i = half2float(dc[idx], s->mantissatable,
                                      s->exponenttable, s->offsettable);

                block[0] = dc_val.f;
                ac_uncompress(s, &agb, block);
                dct_inverse(block);
            }

            {
                const float scale = s->pixel_type == EXR_FLOAT ? 2.f : 1.f;
                const int o = s->nb_channels == 4;
                float *bo = ((float *)td->uncompressed_data) +
                    y * td->xsize * s->nb_channels + td->xsize * (o + 0) + x;
                float *go = ((float *)td->uncompressed_data) +
                    y * td->xsize * s->nb_channels + td->xsize * (o + 1) + x;
                float *ro = ((float *)td->uncompressed_data) +
                    y * td->xsize * s->nb_channels + td->xsize * (o + 2) + x;
                float *yb = td->block[0];
                float *ub = td->block[1];
                float *vb = td->block[2];

                for (int yy = 0; yy < 8; yy++) {
                    for (int xx = 0; xx < 8; xx++) {
                        const int idx = xx + yy * 8;

                        convert(yb[idx], ub[idx], vb[idx], &bo[xx], &go[xx], &ro[xx]);

                        bo[xx] = to_linear(bo[xx], scale);
                        go[xx] = to_linear(go[xx], scale);
                        ro[xx] = to_linear(ro[xx], scale);
                    }

                    bo += td->xsize * s->nb_channels;
                    go += td->xsize * s->nb_channels;
                    ro += td->xsize * s->nb_channels;
                }
            }
        }
    }

    if (s->nb_channels < 4)
        return 0;

    for (int y = 0; y < td->ysize && td->rle_raw_data; y++) {
        uint32_t *ao = ((uint32_t *)td->uncompressed_data) + y * td->xsize * s->nb_channels;
        uint8_t *ai0 = td->rle_raw_data + y * td->xsize;
        uint8_t *ai1 = td->rle_raw_data + y * td->xsize + rle_raw_size / 2;

        for (int x = 0; x < td->xsize; x++) {
            uint16_t ha = ai0[x] | (ai1[x] << 8);

            ao[x] = half2float(ha, s->mantissatable, s->exponenttable, s->offsettable);
        }
    }

    return 0;
}","static int dwa_uncompress(EXRContext *VAR_0, const uint8_t *VAR_1, int VAR_2,
                          int VAR_3, EXRThreadData *VAR_4)
{
    int64_t VAR_5, VAR_6, VAR_7;
    int64_t VAR_8, VAR_9, VAR_10, VAR_11, VAR_12;
    int64_t VAR_13, VAR_14, VAR_15;
    const int VAR_16 = VAR_4->xsize >> 3;
    const int VAR_17 = VAR_4->ysize >> 3;
    GetByteContext VAR_18, VAR_19;
    int VAR_20, VAR_21;

    if (VAR_2 <= 88)
        return VAR_22;

    VAR_5 = AV_RL64(VAR_1 + 0);
    if (VAR_5 != 2)
        return VAR_22;

    VAR_6 = AV_RL64(VAR_1 + 8);
    VAR_7 = AV_RL64(VAR_1 + 16);
    VAR_8 = AV_RL64(VAR_1 + 24);
    VAR_9 = AV_RL64(VAR_1 + 32);
    VAR_11 = AV_RL64(VAR_1 + 40);
    VAR_10 = AV_RL64(VAR_1 + 48);
    VAR_12 = AV_RL64(VAR_1 + 56);
    VAR_13 = AV_RL64(VAR_1 + 64);
    VAR_14 = AV_RL64(VAR_1 + 72);
    VAR_15 = AV_RL64(VAR_1 + 80);

    if (VAR_2 < 88LL + VAR_7 + VAR_8 + VAR_9 + VAR_11)
        return VAR_22;

    bytestream2_init(&VAR_18, VAR_1 + 88, VAR_2 - 88);
    VAR_20 = bytestream2_get_le16(&VAR_18);
    if (VAR_20 < 2)
        return VAR_22;

    bytestream2_skip(&VAR_18, VAR_20 - 2);

    if (VAR_7 > 0) {
        if (VAR_6 > VAR_3)
            return VAR_22;
        bytestream2_skip(&VAR_18, VAR_7);
    }

    if (VAR_8 > 0) {
        unsigned long VAR_23 = VAR_13 * 2LL;
        GetByteContext VAR_19 = VAR_18;

        if (VAR_13 > 3LL * VAR_4->xsize * VAR_0->scan_lines_per_block)
            return VAR_22;

        av_fast_padded_malloc(&VAR_4->ac_data, &VAR_4->ac_size, VAR_23);
        if (!VAR_4->ac_data)
            return AVERROR(VAR_24);

        switch (VAR_15) {
        case 0:
            VAR_21 = huf_uncompress(VAR_0, VAR_4, &VAR_19, (int16_t *)VAR_4->ac_data, VAR_13);
            if (VAR_21 < 0)
                return VAR_21;
            break;
        case 1:
            if (uncompress(VAR_4->ac_data, &VAR_23, VAR_19.buffer, VAR_8) != VAR_25 ||
                VAR_23 != VAR_13 * 2LL)
                return VAR_22;
            break;
        default:
            return VAR_22;
        }

        bytestream2_skip(&VAR_18, VAR_8);
    }

    {
        unsigned long VAR_23 = VAR_14 * 2LL;
        GetByteContext VAR_19 = VAR_18;

        if (VAR_14 != VAR_16 * VAR_17 * 3)
            return VAR_22;

        av_fast_padded_malloc(&VAR_4->dc_data, &VAR_4->dc_size, FFALIGN(VAR_23, 64) * 2);
        if (!VAR_4->dc_data)
            return AVERROR(VAR_24);

        if (uncompress(VAR_4->dc_data + FFALIGN(VAR_23, 64), &VAR_23, VAR_19.buffer, VAR_9) != VAR_25 ||
            (VAR_23 != VAR_14 * 2LL))
            return VAR_22;

        VAR_0->dsp.predictor(VAR_4->dc_data + FFALIGN(VAR_23, 64), VAR_23);
        VAR_0->dsp.reorder_pixels(VAR_4->dc_data, VAR_4->dc_data + FFALIGN(VAR_23, 64), VAR_23);

        bytestream2_skip(&VAR_18, VAR_9);
    }

    if (VAR_12 > 0 && VAR_11 > 0 && VAR_10 > 0) {
        unsigned long VAR_23 = VAR_10;

        av_fast_padded_malloc(&VAR_4->rle_data, &VAR_4->rle_size, VAR_10);
        if (!VAR_4->rle_data)
            return AVERROR(VAR_24);

        av_fast_padded_malloc(&VAR_4->rle_raw_data, &VAR_4->rle_raw_size, VAR_12);
        if (!VAR_4->rle_raw_data)
            return AVERROR(VAR_24);

        if (uncompress(VAR_4->rle_data, &VAR_23, VAR_18.buffer, VAR_11) != VAR_25 ||
            (VAR_23 != VAR_10))
            return VAR_22;

        VAR_21 = rle(VAR_4->rle_raw_data, VAR_4->rle_data, VAR_10, VAR_12);
        if (VAR_21 < 0)
            return VAR_21;
        bytestream2_skip(&VAR_18, VAR_11);
    }

    bytestream2_init(&VAR_19, VAR_4->ac_data, VAR_13 * 2);

    for (int VAR_26 = 0; VAR_26 < VAR_4->ysize; VAR_26 += 8) {
        for (int VAR_27 = 0; VAR_27 < VAR_4->xsize; VAR_27 += 8) {
            memset(VAR_4->block, 0, sizeof(VAR_4->block));

            for (int VAR_28 = 0; VAR_28 < 3; VAR_28++) {
                float *VAR_29 = VAR_4->block[VAR_28];
                const int VAR_30 = (VAR_27 >> 3) + (VAR_26 >> 3) * VAR_16 + VAR_16 * VAR_17 * VAR_28;
                uint16_t *VAR_31 = (uint16_t *)VAR_4->dc_data;
                union av_intfloat32 VAR_32;

                VAR_32.i = half2float(VAR_31[VAR_30], VAR_0->mantissatable,
                                      VAR_0->exponenttable, VAR_0->offsettable);

                VAR_29[0] = VAR_32.f;
                ac_uncompress(VAR_0, &VAR_19, VAR_29);
                dct_inverse(VAR_29);
            }

            {
                const float VAR_33 = VAR_0->pixel_type == VAR_34 ? 2.f : 1.f;
                const int VAR_35 = VAR_0->nb_channels == 4;
                float *VAR_36 = ((float *)VAR_4->uncompressed_data) +
                    VAR_26 * VAR_4->xsize * VAR_0->nb_channels + VAR_4->xsize * (VAR_35 + 0) + VAR_27;
                float *VAR_37 = ((float *)VAR_4->uncompressed_data) +
                    VAR_26 * VAR_4->xsize * VAR_0->nb_channels + VAR_4->xsize * (VAR_35 + 1) + VAR_27;
                float *VAR_38 = ((float *)VAR_4->uncompressed_data) +
                    VAR_26 * VAR_4->xsize * VAR_0->nb_channels + VAR_4->xsize * (VAR_35 + 2) + VAR_27;
                float *VAR_39 = VAR_4->block[0];
                float *VAR_40 = VAR_4->block[1];
                float *VAR_41 = VAR_4->block[2];

                for (int VAR_42 = 0; VAR_42 < 8; VAR_42++) {
                    for (int VAR_43 = 0; VAR_43 < 8; VAR_43++) {
                        const int VAR_30 = VAR_43 + VAR_42 * 8;

                        convert(VAR_39[VAR_30], VAR_40[VAR_30], VAR_41[VAR_30], &VAR_36[VAR_43], &VAR_37[VAR_43], &VAR_38[VAR_43]);

                        VAR_36[VAR_43] = to_linear(VAR_36[VAR_43], VAR_33);
                        VAR_37[VAR_43] = to_linear(VAR_37[VAR_43], VAR_33);
                        VAR_38[VAR_43] = to_linear(VAR_38[VAR_43], VAR_33);
                    }

                    VAR_36 += VAR_4->xsize * VAR_0->nb_channels;
                    VAR_37 += VAR_4->xsize * VAR_0->nb_channels;
                    VAR_38 += VAR_4->xsize * VAR_0->nb_channels;
                }
            }
        }
    }

    if (VAR_0->nb_channels < 4)
        return 0;

    for (int VAR_26 = 0; VAR_26 < VAR_4->ysize && VAR_4->rle_raw_data; VAR_26++) {
        uint32_t *VAR_44 = ((uint32_t *)VAR_4->uncompressed_data) + VAR_26 * VAR_4->xsize * VAR_0->nb_channels;
        uint8_t *VAR_45 = VAR_4->rle_raw_data + VAR_26 * VAR_4->xsize;
        uint8_t *VAR_46 = VAR_4->rle_raw_data + VAR_26 * VAR_4->xsize + VAR_12 / 2;

        for (int VAR_27 = 0; VAR_27 < VAR_4->xsize; VAR_27++) {
            uint16_t VAR_47 = VAR_45[VAR_27] | (VAR_46[VAR_27] << 8);

            VAR_44[VAR_27] = half2float(VAR_47, VAR_0->mantissatable, VAR_0->exponenttable, VAR_0->offsettable);
        }
    }

    return 0;
}",ffmpeg/26d3c81bc5ef2f8c3f09d45eaeacfb4b1139a777/exr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -72,11 +72,11 @@
         bytestream2_skip(&gb, ac_size);
     }
 
-    if (dc_size > 0) {
+    {
         unsigned long dest_len = dc_count * 2LL;
         GetByteContext agb = gb;
 
-        if (dc_count > (6LL * td->xsize * td->ysize + 63) / 64)
+        if (dc_count != dc_w * dc_h * 3)
             return AVERROR_INVALIDDATA;
 
         av_fast_padded_malloc(&td->dc_data, &td->dc_size, FFALIGN(dest_len, 64) * 2);","{'deleted_lines': ['    if (dc_size > 0) {', '        if (dc_count > (6LL * td->xsize * td->ysize + 63) / 64)'], 'added_lines': ['    {', '        if (dc_count != dc_w * dc_h * 3)']}",True,dwa_uncompress in libavcodec/exr.c in FFmpeg 4.4 allows an out-of-bounds array access because dc_count is not strictly checked.,8.8,HIGH,2,valid,2021-05-25T17:29:18Z,3
CVE-2021-32845,['CWE-252'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,moby/hyperkit,"Fix vtrnd pci_vtrnd_notify uninitialized memory use (GHSL-2021-056)

Signed-off-by: Frederic Dalleau <frederic.dalleau@docker.com>",41272a980197917df8e58ff90642d14dec8fe948,https://github.com/moby/hyperkit/commit/41272a980197917df8e58ff90642d14dec8fe948,src/lib/pci_virtio_rnd.c,pci_vtrnd_notify,"static void
pci_vtrnd_notify(void *vsc, struct vqueue_info *vq)
{
struct iovec iov;
struct pci_vtrnd_softc *sc;
int len;
uint16_t idx;
sc = vsc;
if (sc->vrsc_fd < 0) {
vq_endchains(vq, 0);
return;
}
while (vq_has_descs(vq)) {
vq_getchain(vq, &idx, &iov, 1, NULL);
len = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);
DPRINTF((""vtrnd: vtrnd_notify(): %d\r\n"", len));
assert(len > 0);
vq_relchain(vq, idx, (uint32_t)len);
}
vq_endchains(vq, 1);
}","static void
pci_vtrnd_notify(void *VAR_0, struct vqueue_info *VAR_1)
{
struct iovec VAR_2;
struct pci_vtrnd_softc *VAR_3;
int VAR_4;
uint16_t VAR_5;
VAR_3 = VAR_0;
if (VAR_3->vrsc_fd < 0) {
vq_endchains(VAR_1, 0);
return;
}
while (vq_has_descs(VAR_1)) {
vq_getchain(VAR_1, &VAR_5, &VAR_2, 1, NULL);
VAR_4 = (int) read(VAR_3->vrsc_fd, VAR_2.iov_base, VAR_2.iov_len);
DPRINTF((""vtrnd: vtrnd_notify(): %d\r\n"", VAR_4));
assert(VAR_4 > 0);
vq_relchain(VAR_1, VAR_5, (uint32_t)VAR_4);
}
vq_endchains(VAR_1, 1);
}",moby/hyperkit/41272a980197917df8e58ff90642d14dec8fe948/pci_virtio_rnd.c/vul/before/0.json,"static void
pci_vtrnd_notify(void *vsc, struct vqueue_info *vq)
{
	struct iovec iov;
	struct pci_vtrnd_softc *sc;
	int len, n;
	uint16_t idx;

	sc = vsc;

	if (sc->vrsc_fd < 0) {
		vq_endchains(vq, 0);
		return;
	}

	while (vq_has_descs(vq)) {
		n = vq_getchain(vq, &idx, &iov, 1, NULL);
		if (n < 0) {
			fprintf(stderr, ""vtrnd: vtrnd_notify(): n %d\r\n"", n);
			return;
		}

		len = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);

		DPRINTF((""vtrnd: vtrnd_notify(): %d\r\n"", len));

		/* Catastrophe if unable to read from /dev/random */
		assert(len > 0);

		/*
		 * Release this chain and handle more
		 */
		vq_relchain(vq, idx, (uint32_t)len);
	}
	vq_endchains(vq, 1);	/* Generate interrupt if appropriate. */
}","static void
pci_vtrnd_notify(void *VAR_0, struct vqueue_info *VAR_1)
{
	struct iovec VAR_2;
	struct pci_vtrnd_softc *VAR_3;
	int VAR_4, VAR_5;
	uint16_t VAR_6;

	VAR_3 = VAR_0;

	if (VAR_3->vrsc_fd < 0) {
		vq_endchains(VAR_1, 0);
		return;
	}

	while (vq_has_descs(VAR_1)) {
		VAR_5 = vq_getchain(VAR_1, &VAR_6, &VAR_2, 1, NULL);
		if (VAR_5 < 0) {
			fprintf(VAR_7, ""vtrnd: vtrnd_notify(): n %d\r\n"", VAR_5);
			return;
		}

		VAR_4 = (int) read(VAR_3->vrsc_fd, VAR_2.iov_base, VAR_2.iov_len);

		DPRINTF((""vtrnd: vtrnd_notify(): %d\r\n"", VAR_4));

		/* COMMENT_0 */
		assert(VAR_4 > 0);

		/* COMMENT_1 */
                                       
     
		vq_relchain(VAR_1, VAR_6, (uint32_t)VAR_4);
	}
	vq_endchains(VAR_1, 1);	/* COMMENT_4 */
}",moby/hyperkit/41272a980197917df8e58ff90642d14dec8fe948/pci_virtio_rnd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 {
 	struct iovec iov;
 	struct pci_vtrnd_softc *sc;
-	int len;
+	int len, n;
 	uint16_t idx;
 
 	sc = vsc;
@@ -14,7 +14,11 @@
 	}
 
 	while (vq_has_descs(vq)) {
-		vq_getchain(vq, &idx, &iov, 1, NULL);
+		n = vq_getchain(vq, &idx, &iov, 1, NULL);
+		if (n < 0) {
+			fprintf(stderr, ""vtrnd: vtrnd_notify(): n %d\r\n"", n);
+			return;
+		}
 
 		len = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);
 ","{'deleted_lines': ['\tint len;', '\t\tvq_getchain(vq, &idx, &iov, 1, NULL);'], 'added_lines': ['\tint len, n;', '\t\tn = vq_getchain(vq, &idx, &iov, 1, NULL);', '\t\tif (n < 0) {', '\t\t\tfprintf(stderr, ""vtrnd: vtrnd_notify(): n %d\\r\\n"", n);', '\t\t\treturn;', '\t\t}']}",True,"HyperKit is a toolkit for embedding hypervisor capabilities in an application. In versions 0.20210107 and prior of HyperKit, the implementation of `qnotify` at `pci_vtrnd_notify` fails to check the return value of `vq_getchain`. This leads to `struct iovec iov;` being uninitialized and used to read memory in `len = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);` when an attacker is able to make `vq_getchain` fail. This issue may lead to a guest crashing the host causing a denial of service and, under certain circumstance, memory corruption. This issue is fixed in commit 41272a980197917df8e58ff90642d14dec8fe948.",7.7,HIGH,2,valid,2021-06-02T10:02:47Z,3
CVE-2021-32846,['CWE-754'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,moby/hyperkit,"Fix virtio-sock pci_vtsock_proc_tx uninitialized memory use (GHSL-2021-057)

Signed-off-by: Frederic Dalleau <frederic.dalleau@docker.com>",af5eba2360a7351c08dfd9767d9be863a50ebaba,https://github.com/moby/hyperkit/commit/af5eba2360a7351c08dfd9767d9be863a50ebaba,src/lib/pci_virtio_sock.c,pci_vtsock_proc_tx,"static void pci_vtsock_proc_tx(struct pci_vtsock_softc *sc,
struct vqueue_info *vq)
{
struct pci_vtsock_sock *sock;
struct iovec iov_array[VTSOCK_MAXSEGS], *iov = iov_array;
uint16_t idx, flags[VTSOCK_MAXSEGS];
struct virtio_sock_hdr hdr;
int iovec_len;
size_t pulled;
iovec_len = vq_getchain(vq, &idx, iov, VTSOCK_MAXSEGS, flags);
assert(iovec_len <= VTSOCK_MAXSEGS);
DPRINTF((""TX: chain with %d buffers at idx %""PRIx16""\n"",
iovec_len, idx));
dprint_chain(iov, iovec_len, ""TX"");
pulled = iovec_pull(&iov, &iovec_len, &hdr, sizeof(hdr));
assert(pulled == sizeof(hdr));
dprint_header(&hdr, 1, ""TX"");
dprint_iovec(iov, iovec_len, ""TX"");
if (hdr.src_cid != sc->vssc_cfg.guest_cid ||
hdr.dst_cid != VMADDR_CID_HOST ||
hdr.type != VIRTIO_VSOCK_TYPE_STREAM) {
DPRINTF((""TX: Bad src/dst address/type\n""));
send_response_nosock(sc, VIRTIO_VSOCK_OP_RST,
hdr.type,
(struct vsock_addr) {
.cid = hdr.dst_cid,
.port =hdr.dst_port
},
(struct vsock_addr) {
.cid = hdr.src_cid,
.port =hdr.src_port
});
vq_relchain(vq, idx, 0);
return;
}
sock = lookup_sock(sc, VIRTIO_VSOCK_TYPE_STREAM,
(struct vsock_addr) {
.cid = hdr.dst_cid,
.port =hdr.dst_port
},
(struct vsock_addr) {
.cid = hdr.src_cid,
.port =hdr.src_port
});
if (sock) {
sock->peer_buf_alloc = hdr.buf_alloc;
sock->peer_fwd_cnt = hdr.fwd_cnt;
}
switch (hdr.op) {
case VIRTIO_VSOCK_OP_INVALID:
PPRINTF((""TX: => INVALID\n""));
goto do_rst;
case VIRTIO_VSOCK_OP_REQUEST:
if (sock) {
PPRINTF((""TX: Attempt to reconnect sock\n""));
goto do_rst;
}
if (hdr.dst_cid == sc->vssc_cfg.guest_cid) {
PPRINTF((""TX: Attempt to connect back to guest\n!""));
goto do_rst;
}
sock = connect_sock(sc,
(struct vsock_addr){
.cid = hdr.dst_cid, .port = hdr.dst_port
},
(struct vsock_addr){
.cid = hdr.src_cid, .port = hdr.src_port
}, hdr.buf_alloc, hdr.fwd_cnt);
if (!sock) {
PPRINTF((""TX: Failed to open sock\n""));
goto do_rst;
}
send_response_sock(sc, VIRTIO_VSOCK_OP_RESPONSE, 0, sock);
vq_relchain(vq, idx, 0);
break;
case VIRTIO_VSOCK_OP_RESPONSE:
if (!sock) {
PPRINTF((""TX: RESPONSE to non-existent sock\n""));
goto do_rst;
}
if (sock->state != SOCK_CONNECTING) {
PPRINTF((""TX: RESPONSE to non-connecting sock (state %d)\n"",
sock->state));
goto do_rst;
}
PPRINTF((""TX: SOCK connected (%d) ""PRIaddr"" <=> ""PRIaddr""\n"",
sock->fd, FMTADDR(sock->local_addr), FMTADDR(sock->peer_addr)));
sock->state = SOCK_CONNECTED;
vq_relchain(vq, idx, 0);
kick_rx(sc, ""new outgoing sock"");
break;
case VIRTIO_VSOCK_OP_RST:
if (!sock)
PPRINTF((""TX: RST to non-existent sock\n""));
close_sock(sc, sock, ""TX"");
vq_relchain(vq, idx, 0);
break;
case VIRTIO_VSOCK_OP_SHUTDOWN:
if (!sock) {
DPRINTF((""TX: SHUTDOWN to non-existent sock ""PRIcid"".""PRIport""\n"",
hdr.dst_cid, hdr.dst_port));
goto do_rst;
}
if (sock->state != SOCK_CONNECTED) {
PPRINTF((""TX: SHUTDOWN to non-connected sock (state %d)\n"",
sock->state));
goto do_rst;
}
if (hdr.flags & ~VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL) {
PPRINTF((""TX: SHUTDOWN with reserved flags %""PRIx32""\n"",
hdr.flags));
goto do_rst; 
}
if (!(hdr.flags & VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL)) {
PPRINTF((""TX: SHUTDOWN with no flags %""PRIx32""\n"",
hdr.flags));
goto do_rst; 
}
shutdown_peer_local_fd(sock, hdr.flags, ""TX"");
if (sock->peer_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL)
goto do_rst;
vq_relchain(vq, idx, 0);
break;
case VIRTIO_VSOCK_OP_RW:
{
int rc;
if (!sock) {
PPRINTF((""TX: RW with no sock\n""));
goto do_rst;
}
if (sock->state != SOCK_CONNECTED) {
PPRINTF((""TX: RW to non-connected sock (state %d)\n"",
sock->state));
goto do_rst;
}
if (sock->peer_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_TX) {
PPRINTF((""TX: RW to socket with peer_shutdown.TX\n""));
goto do_rst;
}
if (sock->local_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_RX) {
PPRINTF((""TX: RW to socket with local_shutdown.RX\n""));
goto do_rst;
}
rc = handle_write(sc, sock, hdr.len, iov, iovec_len);
if (rc < 0) goto do_rst;
vq_relchain(vq, idx, 0);
if (rc == 1)
set_credit_update_required(sc, sock);
break;
}
case VIRTIO_VSOCK_OP_CREDIT_UPDATE:
if (!sock) {
PPRINTF((""TX: CREDIT_UPDATE to non-existent sock\n""));
goto do_rst;
}
if (sock->state != SOCK_CONNECTED) {
PPRINTF((""TX: CREDIT_UPDATE to non-connected sock (state %d)\n"",
sock->state));
goto do_rst;
}
vq_relchain(vq, idx, 0);
sc->rx_kick_pending = true;
break;
case VIRTIO_VSOCK_OP_CREDIT_REQUEST:
if (!sock) {
PPRINTF((""TX: CREDIT_REQUEST to non-existent sock\n""));
goto do_rst;
}
if (sock->state != SOCK_CONNECTED) {
PPRINTF((""TX: CREDIT_REQUEST to non-connected sock (state %d)\n"",
sock->state));
goto do_rst;
}
vq_relchain(vq, idx, 0);
set_credit_update_required(sc, sock);
break;
}
if (sock)
put_sock(sock);
return;
do_rst:
if (sock)
send_response_sock(sc, VIRTIO_VSOCK_OP_RST, 0, sock);
else
send_response_nosock(sc, VIRTIO_VSOCK_OP_RST, hdr.type,
(struct vsock_addr) {
.cid = hdr.dst_cid,
.port =hdr.dst_port
},
(struct vsock_addr) {
.cid = hdr.src_cid,
.port =hdr.src_port
});
vq_relchain(vq, idx, 0);
close_sock(sc, sock, ""TX"");
if (sock) put_sock(sock);
return;
}","static void pci_vtsock_proc_tx(struct pci_vtsock_softc *VAR_0,
struct vqueue_info *VAR_1)
{
struct pci_vtsock_sock *VAR_2;
struct iovec VAR_3[VAR_4], *VAR_5 = VAR_3;
uint16_t VAR_6, VAR_7[VAR_4];
struct virtio_sock_hdr VAR_8;
int VAR_9;
size_t VAR_10;
VAR_9 = vq_getchain(VAR_1, &VAR_6, VAR_5, VAR_4, VAR_7);
assert(VAR_9 <= VAR_4);
DPRINTF((""TX: chain with %d buffers at idx %""VAR_11""\n"",
VAR_9, VAR_6));
dprint_chain(VAR_5, VAR_9, ""TX"");
VAR_10 = iovec_pull(&VAR_5, &VAR_9, &VAR_8, sizeof(VAR_8));
assert(VAR_10 == sizeof(VAR_8));
dprint_header(&VAR_8, 1, ""TX"");
dprint_iovec(VAR_5, VAR_9, ""TX"");
if (VAR_8.src_cid != VAR_0->vssc_cfg.guest_cid ||
VAR_8.dst_cid != VAR_12 ||
VAR_8.type != VAR_13) {
DPRINTF((""TX: Bad src/dst address/type\n""));
send_response_nosock(VAR_0, VAR_14,
VAR_8.type,
(struct vsock_addr) {
.cid = VAR_8.dst_cid,
.port =VAR_8.dst_port
},
(struct vsock_addr) {
.cid = VAR_8.src_cid,
.port =VAR_8.src_port
});
vq_relchain(VAR_1, VAR_6, 0);
return;
}
VAR_2 = lookup_sock(VAR_0, VAR_13,
(struct vsock_addr) {
.cid = VAR_8.dst_cid,
.port =VAR_8.dst_port
},
(struct vsock_addr) {
.cid = VAR_8.src_cid,
.port =VAR_8.src_port
});
if (VAR_2) {
VAR_2->peer_buf_alloc = VAR_8.buf_alloc;
VAR_2->peer_fwd_cnt = VAR_8.fwd_cnt;
}
switch (VAR_8.op) {
case VAR_15:
PPRINTF((""TX: => INVALID\n""));
goto do_rst;
case VAR_16:
if (VAR_2) {
PPRINTF((""TX: Attempt to reconnect sock\n""));
goto do_rst;
}
if (VAR_8.dst_cid == VAR_0->vssc_cfg.guest_cid) {
PPRINTF((""TX: Attempt to connect back to guest\n!""));
goto do_rst;
}
VAR_2 = connect_sock(VAR_0,
(struct vsock_addr){
.cid = VAR_8.dst_cid, .port = VAR_8.dst_port
},
(struct vsock_addr){
.cid = VAR_8.src_cid, .port = VAR_8.src_port
}, VAR_8.buf_alloc, VAR_8.fwd_cnt);
if (!VAR_2) {
PPRINTF((""TX: Failed to open sock\n""));
goto do_rst;
}
send_response_sock(VAR_0, VAR_17, 0, VAR_2);
vq_relchain(VAR_1, VAR_6, 0);
break;
case VAR_17:
if (!VAR_2) {
PPRINTF((""TX: RESPONSE to non-existent sock\n""));
goto do_rst;
}
if (VAR_2->state != VAR_18) {
PPRINTF((""TX: RESPONSE to non-connecting sock (state %d)\n"",
VAR_2->state));
goto do_rst;
}
PPRINTF((""TX: SOCK connected (%d) ""VAR_19"" <=> ""VAR_19""\n"",
VAR_2->fd, FMTADDR(VAR_2->local_addr), FMTADDR(VAR_2->peer_addr)));
VAR_2->state = VAR_20;
vq_relchain(VAR_1, VAR_6, 0);
kick_rx(VAR_0, ""new outgoing sock"");
break;
case VAR_14:
if (!VAR_2)
PPRINTF((""TX: RST to non-existent sock\n""));
close_sock(VAR_0, VAR_2, ""TX"");
vq_relchain(VAR_1, VAR_6, 0);
break;
case VAR_21:
if (!VAR_2) {
DPRINTF((""TX: SHUTDOWN to non-existent sock ""VAR_22"".""VAR_23""\n"",
VAR_8.dst_cid, VAR_8.dst_port));
goto do_rst;
}
if (VAR_2->state != VAR_20) {
PPRINTF((""TX: SHUTDOWN to non-connected sock (state %d)\n"",
VAR_2->state));
goto do_rst;
}
if (VAR_8.flags & ~VAR_24) {
PPRINTF((""TX: SHUTDOWN with reserved flags %""VAR_25""\n"",
VAR_8.flags));
goto do_rst; 
}
if (!(VAR_8.flags & VAR_24)) {
PPRINTF((""TX: SHUTDOWN with no flags %""VAR_25""\n"",
VAR_8.flags));
goto do_rst; 
}
shutdown_peer_local_fd(VAR_2, VAR_8.flags, ""TX"");
if (VAR_2->peer_shutdown == VAR_24)
goto do_rst;
vq_relchain(VAR_1, VAR_6, 0);
break;
case VAR_26:
{
int VAR_27;
if (!VAR_2) {
PPRINTF((""TX: RW with no sock\n""));
goto do_rst;
}
if (VAR_2->state != VAR_20) {
PPRINTF((""TX: RW to non-connected sock (state %d)\n"",
VAR_2->state));
goto do_rst;
}
if (VAR_2->peer_shutdown & VAR_28) {
PPRINTF((""TX: RW to socket with peer_shutdown.TX\n""));
goto do_rst;
}
if (VAR_2->local_shutdown & VAR_29) {
PPRINTF((""TX: RW to socket with local_shutdown.RX\n""));
goto do_rst;
}
VAR_27 = handle_write(VAR_0, VAR_2, VAR_8.len, VAR_5, VAR_9);
if (VAR_27 < 0) goto do_rst;
vq_relchain(VAR_1, VAR_6, 0);
if (VAR_27 == 1)
set_credit_update_required(VAR_0, VAR_2);
break;
}
case VAR_30:
if (!VAR_2) {
PPRINTF((""TX: CREDIT_UPDATE to non-existent sock\n""));
goto do_rst;
}
if (VAR_2->state != VAR_20) {
PPRINTF((""TX: CREDIT_UPDATE to non-connected sock (state %d)\n"",
VAR_2->state));
goto do_rst;
}
vq_relchain(VAR_1, VAR_6, 0);
VAR_0->rx_kick_pending = true;
break;
case VAR_31:
if (!VAR_2) {
PPRINTF((""TX: CREDIT_REQUEST to non-existent sock\n""));
goto do_rst;
}
if (VAR_2->state != VAR_20) {
PPRINTF((""TX: CREDIT_REQUEST to non-connected sock (state %d)\n"",
VAR_2->state));
goto do_rst;
}
vq_relchain(VAR_1, VAR_6, 0);
set_credit_update_required(VAR_0, VAR_2);
break;
}
if (VAR_2)
put_sock(VAR_2);
return;
do_rst:
if (VAR_2)
send_response_sock(VAR_0, VAR_14, 0, VAR_2);
else
send_response_nosock(VAR_0, VAR_14, VAR_8.type,
(struct vsock_addr) {
.cid = VAR_8.dst_cid,
.port =VAR_8.dst_port
},
(struct vsock_addr) {
.cid = VAR_8.src_cid,
.port =VAR_8.src_port
});
vq_relchain(VAR_1, VAR_6, 0);
close_sock(VAR_0, VAR_2, ""TX"");
if (VAR_2) put_sock(VAR_2);
return;
}",moby/hyperkit/af5eba2360a7351c08dfd9767d9be863a50ebaba/pci_virtio_sock.c/vul/before/0.json,"static void pci_vtsock_proc_tx(struct pci_vtsock_softc *sc,
			       struct vqueue_info *vq)
{
	struct pci_vtsock_sock *sock;
	struct iovec iov_array[VTSOCK_MAXSEGS], *iov = iov_array;
	uint16_t idx, flags[VTSOCK_MAXSEGS];
	struct virtio_sock_hdr hdr;
	int iovec_len;
	size_t pulled;

	iovec_len = vq_getchain(vq, &idx, iov, VTSOCK_MAXSEGS, flags);
	if (iovec_len < 0) {
		fprintf(stderr, ""TX: failed to get chain at idx %""PRIx16""\n"", idx);
		return;
	}

	assert(iovec_len <= VTSOCK_MAXSEGS);

	DPRINTF((""TX: chain with %d buffers at idx %""PRIx16""\n"",
		 iovec_len, idx));
	dprint_chain(iov, iovec_len, ""TX"");
	//assert(iov[0].iov_len >= sizeof(*hdr));
	//hdr = iov[0].iov_base;

	pulled = iovec_pull(&iov, &iovec_len, &hdr, sizeof(hdr));
	assert(pulled == sizeof(hdr));

	dprint_header(&hdr, 1, ""TX"");

	dprint_iovec(iov, iovec_len, ""TX"");

	if (hdr.src_cid != sc->vssc_cfg.guest_cid ||
	    hdr.dst_cid != VMADDR_CID_HOST ||
	    hdr.type != VIRTIO_VSOCK_TYPE_STREAM) {
		DPRINTF((""TX: Bad src/dst address/type\n""));
		send_response_nosock(sc, VIRTIO_VSOCK_OP_RST,
				     hdr.type,
				     (struct vsock_addr) {
					     .cid = hdr.dst_cid,
					     .port =hdr.dst_port
				     },
				     (struct vsock_addr) {
					     .cid = hdr.src_cid,
					     .port =hdr.src_port
				     });
		vq_relchain(vq, idx, 0);
		return;
	}

	sock = lookup_sock(sc, VIRTIO_VSOCK_TYPE_STREAM,
			   (struct vsock_addr) {
				   .cid = hdr.dst_cid,
					   .port =hdr.dst_port
			   },
			   (struct vsock_addr) {
				   .cid = hdr.src_cid,
					   .port =hdr.src_port
			   });

	if (sock) {
		sock->peer_buf_alloc = hdr.buf_alloc;
		sock->peer_fwd_cnt = hdr.fwd_cnt;
	}

	switch (hdr.op) {
	case VIRTIO_VSOCK_OP_INVALID:
		PPRINTF((""TX: => INVALID\n""));
		goto do_rst;

	case VIRTIO_VSOCK_OP_REQUEST:
		/* Attempt to (re)connect existing sock? Naughty! */
		/* Or is it -- what are the semantics? */
		if (sock) {
			PPRINTF((""TX: Attempt to reconnect sock\n""));
			goto do_rst;
		}

		if (hdr.dst_cid == sc->vssc_cfg.guest_cid) {
			PPRINTF((""TX: Attempt to connect back to guest\n!""));
			goto do_rst;
		}

		sock = connect_sock(sc,
				    (struct vsock_addr){
					    .cid = hdr.dst_cid, .port = hdr.dst_port
				    },
				    (struct vsock_addr){
					    .cid = hdr.src_cid, .port = hdr.src_port
				    }, hdr.buf_alloc, hdr.fwd_cnt);
		if (!sock) {
			PPRINTF((""TX: Failed to open sock\n""));
			goto do_rst;
		}

		send_response_sock(sc, VIRTIO_VSOCK_OP_RESPONSE, 0, sock);
		vq_relchain(vq, idx, 0);
		/* No rx kick required, send_response_sock did one */
		break;

	case VIRTIO_VSOCK_OP_RESPONSE:
		if (!sock) {
			PPRINTF((""TX: RESPONSE to non-existent sock\n""));
			goto do_rst;
		}
		if (sock->state != SOCK_CONNECTING) {
			PPRINTF((""TX: RESPONSE to non-connecting sock (state %d)\n"",
				 sock->state));
			goto do_rst;
		}
		PPRINTF((""TX: SOCK connected (%d) ""PRIaddr"" <=> ""PRIaddr""\n"",
			 sock->fd, FMTADDR(sock->local_addr), FMTADDR(sock->peer_addr)));
		sock->state = SOCK_CONNECTED;
		vq_relchain(vq, idx, 0);
		kick_rx(sc, ""new outgoing sock"");
		break;

	case VIRTIO_VSOCK_OP_RST:
		/* No response */
		if (!sock)
			PPRINTF((""TX: RST to non-existent sock\n""));
		close_sock(sc, sock, ""TX"");
		vq_relchain(vq, idx, 0);
		break;

	case VIRTIO_VSOCK_OP_SHUTDOWN:
		if (!sock) {
			DPRINTF((""TX: SHUTDOWN to non-existent sock ""PRIcid"".""PRIport""\n"",
				 hdr.dst_cid, hdr.dst_port));
			goto do_rst;
		}
		if (sock->state != SOCK_CONNECTED) {
			PPRINTF((""TX: SHUTDOWN to non-connected sock (state %d)\n"",
				 sock->state));
			goto do_rst;
		}
		if (hdr.flags & ~VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL) {
			PPRINTF((""TX: SHUTDOWN with reserved flags %""PRIx32""\n"",
				 hdr.flags));
			goto do_rst; /* ??? */
		}
		if (!(hdr.flags & VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL)) {
			PPRINTF((""TX: SHUTDOWN with no flags %""PRIx32""\n"",
				 hdr.flags));
			goto do_rst; /* ??? */
		}

		shutdown_peer_local_fd(sock, hdr.flags, ""TX"");

		/* If the peer is now SHUTDOWN_ALL then we should send
		 * a RST to the peer to finalise the shutdown.
		 */
		if (sock->peer_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL)
			goto do_rst;

		vq_relchain(vq, idx, 0);
		break;

	case VIRTIO_VSOCK_OP_RW:
	{
		int rc;

		if (!sock) {
			PPRINTF((""TX: RW with no sock\n""));
			goto do_rst;
		}
		if (sock->state != SOCK_CONNECTED) {
			PPRINTF((""TX: RW to non-connected sock (state %d)\n"",
				 sock->state));
			goto do_rst;
		}
		if (sock->peer_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_TX) {
			PPRINTF((""TX: RW to socket with peer_shutdown.TX\n""));
			goto do_rst;
		}
		if (sock->local_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_RX) {
			PPRINTF((""TX: RW to socket with local_shutdown.RX\n""));
			goto do_rst;
		}
		rc = handle_write(sc, sock, hdr.len, iov, iovec_len);
		if (rc < 0) goto do_rst;
		vq_relchain(vq, idx, 0);
		if (rc == 1)
			set_credit_update_required(sc, sock);
		break;
	}

	case VIRTIO_VSOCK_OP_CREDIT_UPDATE:
		if (!sock) {
			PPRINTF((""TX: CREDIT_UPDATE to non-existent sock\n""));
			goto do_rst;
		}
		if (sock->state != SOCK_CONNECTED) {
			PPRINTF((""TX: CREDIT_UPDATE to non-connected sock (state %d)\n"",
				 sock->state));
			goto do_rst;
		}
		/* No response needed, we updated above */
		vq_relchain(vq, idx, 0);
		/* But kick rx thread to attempt to send more */
		sc->rx_kick_pending = true;
		break;

	case VIRTIO_VSOCK_OP_CREDIT_REQUEST:
		if (!sock) {
			PPRINTF((""TX: CREDIT_REQUEST to non-existent sock\n""));
			goto do_rst;
		}
		if (sock->state != SOCK_CONNECTED) {
			PPRINTF((""TX: CREDIT_REQUEST to non-connected sock (state %d)\n"",
				 sock->state));
			goto do_rst;
		}
		vq_relchain(vq, idx, 0);
		set_credit_update_required(sc, sock);
		break;
	}

	if (sock)
		put_sock(sock);

	return;

do_rst:
	if (sock)
		send_response_sock(sc, VIRTIO_VSOCK_OP_RST, 0, sock);
	else
		send_response_nosock(sc, VIRTIO_VSOCK_OP_RST, hdr.type,
				     (struct vsock_addr) {
					     .cid = hdr.dst_cid,
					     .port =hdr.dst_port
				     },
				     (struct vsock_addr) {
					     .cid = hdr.src_cid,
					     .port =hdr.src_port
				     });
	vq_relchain(vq, idx, 0);
	close_sock(sc, sock, ""TX"");
	if (sock) put_sock(sock);
	return;
}","static void pci_vtsock_proc_tx(struct pci_vtsock_softc *VAR_0,
			       struct vqueue_info *VAR_1)
{
	struct pci_vtsock_sock *VAR_2;
	struct iovec VAR_3[VAR_4], *VAR_5 = VAR_3;
	uint16_t VAR_6, VAR_7[VAR_4];
	struct virtio_sock_hdr VAR_8;
	int VAR_9;
	size_t VAR_10;

	VAR_9 = vq_getchain(VAR_1, &VAR_6, VAR_5, VAR_4, VAR_7);
	if (VAR_9 < 0) {
		fprintf(VAR_11, ""TX: failed to get chain at idx %""VAR_12""\n"", VAR_6);
		return;
	}

	assert(VAR_9 <= VAR_4);

	DPRINTF((""TX: chain with %d buffers at idx %""VAR_12""\n"",
		 VAR_9, VAR_6));
	dprint_chain(VAR_5, VAR_9, ""TX"");
	/* COMMENT_0 */
	/* COMMENT_1 */

	VAR_10 = iovec_pull(&VAR_5, &VAR_9, &VAR_8, sizeof(VAR_8));
	assert(VAR_10 == sizeof(VAR_8));

	dprint_header(&VAR_8, 1, ""TX"");

	dprint_iovec(VAR_5, VAR_9, ""TX"");

	if (VAR_8.src_cid != VAR_0->vssc_cfg.guest_cid ||
	    VAR_8.dst_cid != VAR_13 ||
	    VAR_8.type != VAR_14) {
		DPRINTF((""TX: Bad src/dst address/type\n""));
		send_response_nosock(VAR_0, VAR_15,
				     VAR_8.type,
				     (struct vsock_addr) {
					     .cid = VAR_8.dst_cid,
					     .port =VAR_8.dst_port
				     },
				     (struct vsock_addr) {
					     .cid = VAR_8.src_cid,
					     .port =VAR_8.src_port
				     });
		vq_relchain(VAR_1, VAR_6, 0);
		return;
	}

	VAR_2 = lookup_sock(VAR_0, VAR_14,
			   (struct vsock_addr) {
				   .cid = VAR_8.dst_cid,
					   .port =VAR_8.dst_port
			   },
			   (struct vsock_addr) {
				   .cid = VAR_8.src_cid,
					   .port =VAR_8.src_port
			   });

	if (VAR_2) {
		VAR_2->peer_buf_alloc = VAR_8.buf_alloc;
		VAR_2->peer_fwd_cnt = VAR_8.fwd_cnt;
	}

	switch (VAR_8.op) {
	case VAR_16:
		PPRINTF((""TX: => INVALID\n""));
		goto do_rst;

	case VAR_17:
		/* COMMENT_2 */
		/* COMMENT_3 */
		if (VAR_2) {
			PPRINTF((""TX: Attempt to reconnect sock\n""));
			goto do_rst;
		}

		if (VAR_8.dst_cid == VAR_0->vssc_cfg.guest_cid) {
			PPRINTF((""TX: Attempt to connect back to guest\n!""));
			goto do_rst;
		}

		VAR_2 = connect_sock(VAR_0,
				    (struct vsock_addr){
					    .cid = VAR_8.dst_cid, .port = VAR_8.dst_port
				    },
				    (struct vsock_addr){
					    .cid = VAR_8.src_cid, .port = VAR_8.src_port
				    }, VAR_8.buf_alloc, VAR_8.fwd_cnt);
		if (!VAR_2) {
			PPRINTF((""TX: Failed to open sock\n""));
			goto do_rst;
		}

		send_response_sock(VAR_0, VAR_18, 0, VAR_2);
		vq_relchain(VAR_1, VAR_6, 0);
		/* COMMENT_4 */
		break;

	case VAR_18:
		if (!VAR_2) {
			PPRINTF((""TX: RESPONSE to non-existent sock\n""));
			goto do_rst;
		}
		if (VAR_2->state != VAR_19) {
			PPRINTF((""TX: RESPONSE to non-connecting sock (state %d)\n"",
				 VAR_2->state));
			goto do_rst;
		}
		PPRINTF((""TX: SOCK connected (%d) ""VAR_20"" <=> ""VAR_20""\n"",
			 VAR_2->fd, FMTADDR(VAR_2->local_addr), FMTADDR(VAR_2->peer_addr)));
		VAR_2->state = VAR_21;
		vq_relchain(VAR_1, VAR_6, 0);
		kick_rx(VAR_0, ""new outgoing sock"");
		break;

	case VAR_15:
		/* COMMENT_5 */
		if (!VAR_2)
			PPRINTF((""TX: RST to non-existent sock\n""));
		close_sock(VAR_0, VAR_2, ""TX"");
		vq_relchain(VAR_1, VAR_6, 0);
		break;

	case VAR_22:
		if (!VAR_2) {
			DPRINTF((""TX: SHUTDOWN to non-existent sock ""VAR_23"".""VAR_24""\n"",
				 VAR_8.dst_cid, VAR_8.dst_port));
			goto do_rst;
		}
		if (VAR_2->state != VAR_21) {
			PPRINTF((""TX: SHUTDOWN to non-connected sock (state %d)\n"",
				 VAR_2->state));
			goto do_rst;
		}
		if (VAR_8.flags & ~VAR_25) {
			PPRINTF((""TX: SHUTDOWN with reserved flags %""VAR_26""\n"",
				 VAR_8.flags));
			goto do_rst; /* COMMENT_6 */
		}
		if (!(VAR_8.flags & VAR_25)) {
			PPRINTF((""TX: SHUTDOWN with no flags %""VAR_26""\n"",
				 VAR_8.flags));
			goto do_rst; /* COMMENT_6 */
		}

		shutdown_peer_local_fd(VAR_2, VAR_8.flags, ""TX"");

		/* COMMENT_7 */
                                                
     
		if (VAR_2->peer_shutdown == VAR_25)
			goto do_rst;

		vq_relchain(VAR_1, VAR_6, 0);
		break;

	case VAR_27:
	{
		int VAR_28;

		if (!VAR_2) {
			PPRINTF((""TX: RW with no sock\n""));
			goto do_rst;
		}
		if (VAR_2->state != VAR_21) {
			PPRINTF((""TX: RW to non-connected sock (state %d)\n"",
				 VAR_2->state));
			goto do_rst;
		}
		if (VAR_2->peer_shutdown & VAR_29) {
			PPRINTF((""TX: RW to socket with peer_shutdown.TX\n""));
			goto do_rst;
		}
		if (VAR_2->local_shutdown & VAR_30) {
			PPRINTF((""TX: RW to socket with local_shutdown.RX\n""));
			goto do_rst;
		}
		VAR_28 = handle_write(VAR_0, VAR_2, VAR_8.len, VAR_5, VAR_9);
		if (VAR_28 < 0) goto do_rst;
		vq_relchain(VAR_1, VAR_6, 0);
		if (VAR_28 == 1)
			set_credit_update_required(VAR_0, VAR_2);
		break;
	}

	case VAR_31:
		if (!VAR_2) {
			PPRINTF((""TX: CREDIT_UPDATE to non-existent sock\n""));
			goto do_rst;
		}
		if (VAR_2->state != VAR_21) {
			PPRINTF((""TX: CREDIT_UPDATE to non-connected sock (state %d)\n"",
				 VAR_2->state));
			goto do_rst;
		}
		/* COMMENT_10 */
		vq_relchain(VAR_1, VAR_6, 0);
		/* COMMENT_11 */
		VAR_0->rx_kick_pending = true;
		break;

	case VAR_32:
		if (!VAR_2) {
			PPRINTF((""TX: CREDIT_REQUEST to non-existent sock\n""));
			goto do_rst;
		}
		if (VAR_2->state != VAR_21) {
			PPRINTF((""TX: CREDIT_REQUEST to non-connected sock (state %d)\n"",
				 VAR_2->state));
			goto do_rst;
		}
		vq_relchain(VAR_1, VAR_6, 0);
		set_credit_update_required(VAR_0, VAR_2);
		break;
	}

	if (VAR_2)
		put_sock(VAR_2);

	return;

do_rst:
	if (VAR_2)
		send_response_sock(VAR_0, VAR_15, 0, VAR_2);
	else
		send_response_nosock(VAR_0, VAR_15, VAR_8.type,
				     (struct vsock_addr) {
					     .cid = VAR_8.dst_cid,
					     .port =VAR_8.dst_port
				     },
				     (struct vsock_addr) {
					     .cid = VAR_8.src_cid,
					     .port =VAR_8.src_port
				     });
	vq_relchain(VAR_1, VAR_6, 0);
	close_sock(VAR_0, VAR_2, ""TX"");
	if (VAR_2) put_sock(VAR_2);
	return;
}",moby/hyperkit/af5eba2360a7351c08dfd9767d9be863a50ebaba/pci_virtio_sock.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,6 +9,11 @@
 	size_t pulled;
 
 	iovec_len = vq_getchain(vq, &idx, iov, VTSOCK_MAXSEGS, flags);
+	if (iovec_len < 0) {
+		fprintf(stderr, ""TX: failed to get chain at idx %""PRIx16""\n"", idx);
+		return;
+	}
+
 	assert(iovec_len <= VTSOCK_MAXSEGS);
 
 	DPRINTF((""TX: chain with %d buffers at idx %""PRIx16""\n"",","{'deleted_lines': [], 'added_lines': ['\tif (iovec_len < 0) {', '\t\tfprintf(stderr, ""TX: failed to get chain at idx %""PRIx16""\\n"", idx);', '\t\treturn;', '\t}', '']}",True,"HyperKit is a toolkit for embedding hypervisor capabilities in an application. In versions 0.20210107, function `pci_vtsock_proc_tx` in `virtio-sock` can lead to to uninitialized memory use. In this situation, there is a check for the return value to be less or equal to `VTSOCK_MAXSEGS`, but that check is not sufficient because the function can return `-1` if it finds an error it cannot recover from. Moreover, the negative return value will be used by `iovec_pull` in a while condition that can further lead to more corruption because the function is not designed to handle a negative `iov_len`. This issue may lead to a guest crashing the host causing a denial of service and, under certain circumstance, memory corruption. This issue is fixed in commit af5eba2360a7351c08dfd9767d9be863a50ebaba.",7.7,HIGH,2,valid,2021-06-02T10:13:56Z,3
CVE-2021-38199,['CWE-Other'],AV:A/AC:L/Au:N/C:N/I:N/A:P,0,torvalds/linux,"NFSv4: Initialise connection to the server in nfs4_alloc_client()

Set up the connection to the NFSv4 server in nfs4_alloc_client(), before
we've added the struct nfs_client to the net-namespace's nfs_client_list
so that a downed server won't cause other mounts to hang in the trunking
detection code.

Reported-by: Michael Wakabayashi <mwakabayashi@vmware.com>
Fixes: 5c6e5b60aae4 (""NFS: Fix an Oops in the pNFS files and flexfiles connection setup to the DS"")
Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>",dd99e9f98fbf423ff6d365b37a98e8879170f17c,https://github.com/torvalds/linux/commit/dd99e9f98fbf423ff6d365b37a98e8879170f17c,fs/nfs/nfs4client.c,nfs4_alloc_client,"struct nfs_client *nfs4_alloc_client(const struct nfs_client_initdata *cl_init)
{
int err;
struct nfs_client *clp = nfs_alloc_client(cl_init);
if (IS_ERR(clp))
return clp;
err = nfs_get_cb_ident_idr(clp, cl_init->minorversion);
if (err)
goto error;
if (cl_init->minorversion > NFS4_MAX_MINOR_VERSION) {
err = -EINVAL;
goto error;
}
spin_lock_init(&clp->cl_lock);
INIT_DELAYED_WORK(&clp->cl_renewd, nfs4_renew_state);
INIT_LIST_HEAD(&clp->cl_ds_clients);
rpc_init_wait_queue(&clp->cl_rpcwaitq, ""NFS client"");
clp->cl_state = 1 << NFS4CLNT_LEASE_EXPIRED;
clp->cl_mvops = nfs_v4_minor_ops[cl_init->minorversion];
clp->cl_mig_gen = 1;
#if IS_ENABLED(CONFIG_NFS_V4_1)
init_waitqueue_head(&clp->cl_lock_waitq);
#endif
INIT_LIST_HEAD(&clp->pending_cb_stateids);
return clp;
error:
nfs_free_client(clp);
return ERR_PTR(err);
}","struct nfs_client *nfs4_alloc_client(const struct nfs_client_initdata *VAR_0)
{
int VAR_1;
struct nfs_client *VAR_2 = nfs_alloc_client(VAR_0);
if (IS_ERR(VAR_2))
return VAR_2;
VAR_1 = nfs_get_cb_ident_idr(VAR_2, VAR_0->minorversion);
if (VAR_1)
goto error;
if (VAR_0->minorversion > VAR_3) {
VAR_1 = -VAR_4;
goto error;
}
spin_lock_init(&VAR_2->cl_lock);
INIT_DELAYED_WORK(&VAR_2->cl_renewd, VAR_5);
INIT_LIST_HEAD(&VAR_2->cl_ds_clients);
rpc_init_wait_queue(&VAR_2->cl_rpcwaitq, ""NFS client"");
VAR_2->cl_state = 1 << VAR_6;
VAR_2->cl_mvops = VAR_7[VAR_0->minorversion];
VAR_2->cl_mig_gen = 1;
#if IS_ENABLED(VAR_8)
init_waitqueue_head(&VAR_2->cl_lock_waitq);
#endif
INIT_LIST_HEAD(&VAR_2->pending_cb_stateids);
return VAR_2;
error:
nfs_free_client(VAR_2);
return ERR_PTR(VAR_1);
}",torvalds/linux/dd99e9f98fbf423ff6d365b37a98e8879170f17c/nfs4client.c/vul/before/1.json,"struct nfs_client *nfs4_alloc_client(const struct nfs_client_initdata *cl_init)
{
	char buf[INET6_ADDRSTRLEN + 1];
	const char *ip_addr = cl_init->ip_addr;
	struct nfs_client *clp = nfs_alloc_client(cl_init);
	int err;

	if (IS_ERR(clp))
		return clp;

	err = nfs_get_cb_ident_idr(clp, cl_init->minorversion);
	if (err)
		goto error;

	if (cl_init->minorversion > NFS4_MAX_MINOR_VERSION) {
		err = -EINVAL;
		goto error;
	}

	spin_lock_init(&clp->cl_lock);
	INIT_DELAYED_WORK(&clp->cl_renewd, nfs4_renew_state);
	INIT_LIST_HEAD(&clp->cl_ds_clients);
	rpc_init_wait_queue(&clp->cl_rpcwaitq, ""NFS client"");
	clp->cl_state = 1 << NFS4CLNT_LEASE_EXPIRED;
	clp->cl_mvops = nfs_v4_minor_ops[cl_init->minorversion];
	clp->cl_mig_gen = 1;
#if IS_ENABLED(CONFIG_NFS_V4_1)
	init_waitqueue_head(&clp->cl_lock_waitq);
#endif
	INIT_LIST_HEAD(&clp->pending_cb_stateids);

	if (cl_init->minorversion != 0)
		__set_bit(NFS_CS_INFINITE_SLOTS, &clp->cl_flags);
	__set_bit(NFS_CS_DISCRTRY, &clp->cl_flags);
	__set_bit(NFS_CS_NO_RETRANS_TIMEOUT, &clp->cl_flags);

	/*
	 * Set up the connection to the server before we add add to the
	 * global list.
	 */
	err = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_GSS_KRB5I);
	if (err == -EINVAL)
		err = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_UNIX);
	if (err < 0)
		goto error;

	/* If no clientaddr= option was specified, find a usable cb address */
	if (ip_addr == NULL) {
		struct sockaddr_storage cb_addr;
		struct sockaddr *sap = (struct sockaddr *)&cb_addr;

		err = rpc_localaddr(clp->cl_rpcclient, sap, sizeof(cb_addr));
		if (err < 0)
			goto error;
		err = rpc_ntop(sap, buf, sizeof(buf));
		if (err < 0)
			goto error;
		ip_addr = (const char *)buf;
	}
	strlcpy(clp->cl_ipaddr, ip_addr, sizeof(clp->cl_ipaddr));

	err = nfs_idmap_new(clp);
	if (err < 0) {
		dprintk(""%s: failed to create idmapper. Error = %d\n"",
			__func__, err);
		goto error;
	}
	__set_bit(NFS_CS_IDMAP, &clp->cl_res_state);
	return clp;

error:
	nfs_free_client(clp);
	return ERR_PTR(err);
}","struct nfs_client *nfs4_alloc_client(const struct nfs_client_initdata *VAR_0)
{
	char VAR_1[VAR_2 + 1];
	const char *VAR_3 = VAR_0->ip_addr;
	struct nfs_client *VAR_4 = nfs_alloc_client(VAR_0);
	int VAR_5;

	if (IS_ERR(VAR_4))
		return VAR_4;

	VAR_5 = nfs_get_cb_ident_idr(VAR_4, VAR_0->minorversion);
	if (VAR_5)
		goto error;

	if (VAR_0->minorversion > VAR_6) {
		VAR_5 = -VAR_7;
		goto error;
	}

	spin_lock_init(&VAR_4->cl_lock);
	INIT_DELAYED_WORK(&VAR_4->cl_renewd, VAR_8);
	INIT_LIST_HEAD(&VAR_4->cl_ds_clients);
	rpc_init_wait_queue(&VAR_4->cl_rpcwaitq, ""NFS client"");
	VAR_4->cl_state = 1 << VAR_9;
	VAR_4->cl_mvops = VAR_10[VAR_0->minorversion];
	VAR_4->cl_mig_gen = 1;
#if IS_ENABLED(VAR_11)
	init_waitqueue_head(&VAR_4->cl_lock_waitq);
#endif
	INIT_LIST_HEAD(&VAR_4->pending_cb_stateids);

	if (VAR_0->minorversion != 0)
		__set_bit(VAR_12, &VAR_4->cl_flags);
	__set_bit(VAR_13, &VAR_4->cl_flags);
	__set_bit(VAR_14, &VAR_4->cl_flags);

	/* COMMENT_0 */
                                                                
                
    
	VAR_5 = nfs_create_rpc_client(VAR_4, VAR_0, VAR_15);
	if (VAR_5 == -VAR_7)
		VAR_5 = nfs_create_rpc_client(VAR_4, VAR_0, VAR_16);
	if (VAR_5 < 0)
		goto error;

	/* COMMENT_4 */
	if (VAR_3 == NULL) {
		struct sockaddr_storage VAR_17;
		struct sockaddr *VAR_18 = (struct sockaddr *)&VAR_17;

		VAR_5 = rpc_localaddr(VAR_4->cl_rpcclient, VAR_18, sizeof(VAR_17));
		if (VAR_5 < 0)
			goto error;
		VAR_5 = rpc_ntop(VAR_18, VAR_1, sizeof(VAR_1));
		if (VAR_5 < 0)
			goto error;
		VAR_3 = (const char *)VAR_1;
	}
	strlcpy(VAR_4->cl_ipaddr, VAR_3, sizeof(VAR_4->cl_ipaddr));

	VAR_5 = nfs_idmap_new(VAR_4);
	if (VAR_5 < 0) {
		dprintk(""%s: failed to create idmapper. Error = %d\n"",
			VAR_19, VAR_5);
		goto error;
	}
	__set_bit(VAR_20, &VAR_4->cl_res_state);
	return VAR_4;

error:
	nfs_free_client(VAR_4);
	return ERR_PTR(VAR_5);
}",torvalds/linux/dd99e9f98fbf423ff6d365b37a98e8879170f17c/nfs4client.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,7 +1,10 @@
 struct nfs_client *nfs4_alloc_client(const struct nfs_client_initdata *cl_init)
 {
+	char buf[INET6_ADDRSTRLEN + 1];
+	const char *ip_addr = cl_init->ip_addr;
+	struct nfs_client *clp = nfs_alloc_client(cl_init);
 	int err;
-	struct nfs_client *clp = nfs_alloc_client(cl_init);
+
 	if (IS_ERR(clp))
 		return clp;
 
@@ -25,6 +28,44 @@
 	init_waitqueue_head(&clp->cl_lock_waitq);
 #endif
 	INIT_LIST_HEAD(&clp->pending_cb_stateids);
+
+	if (cl_init->minorversion != 0)
+		__set_bit(NFS_CS_INFINITE_SLOTS, &clp->cl_flags);
+	__set_bit(NFS_CS_DISCRTRY, &clp->cl_flags);
+	__set_bit(NFS_CS_NO_RETRANS_TIMEOUT, &clp->cl_flags);
+
+	/*
+	 * Set up the connection to the server before we add add to the
+	 * global list.
+	 */
+	err = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_GSS_KRB5I);
+	if (err == -EINVAL)
+		err = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_UNIX);
+	if (err < 0)
+		goto error;
+
+	/* If no clientaddr= option was specified, find a usable cb address */
+	if (ip_addr == NULL) {
+		struct sockaddr_storage cb_addr;
+		struct sockaddr *sap = (struct sockaddr *)&cb_addr;
+
+		err = rpc_localaddr(clp->cl_rpcclient, sap, sizeof(cb_addr));
+		if (err < 0)
+			goto error;
+		err = rpc_ntop(sap, buf, sizeof(buf));
+		if (err < 0)
+			goto error;
+		ip_addr = (const char *)buf;
+	}
+	strlcpy(clp->cl_ipaddr, ip_addr, sizeof(clp->cl_ipaddr));
+
+	err = nfs_idmap_new(clp);
+	if (err < 0) {
+		dprintk(""%s: failed to create idmapper. Error = %d\n"",
+			__func__, err);
+		goto error;
+	}
+	__set_bit(NFS_CS_IDMAP, &clp->cl_res_state);
 	return clp;
 
 error:","{'deleted_lines': ['\tstruct nfs_client *clp = nfs_alloc_client(cl_init);'], 'added_lines': ['\tchar buf[INET6_ADDRSTRLEN + 1];', '\tconst char *ip_addr = cl_init->ip_addr;', '\tstruct nfs_client *clp = nfs_alloc_client(cl_init);', '', '', '\tif (cl_init->minorversion != 0)', '\t\t__set_bit(NFS_CS_INFINITE_SLOTS, &clp->cl_flags);', '\t__set_bit(NFS_CS_DISCRTRY, &clp->cl_flags);', '\t__set_bit(NFS_CS_NO_RETRANS_TIMEOUT, &clp->cl_flags);', '', '\t/*', '\t * Set up the connection to the server before we add add to the', '\t * global list.', '\t */', '\terr = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_GSS_KRB5I);', '\tif (err == -EINVAL)', '\t\terr = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_UNIX);', '\tif (err < 0)', '\t\tgoto error;', '', '\t/* If no clientaddr= option was specified, find a usable cb address */', '\tif (ip_addr == NULL) {', '\t\tstruct sockaddr_storage cb_addr;', '\t\tstruct sockaddr *sap = (struct sockaddr *)&cb_addr;', '', '\t\terr = rpc_localaddr(clp->cl_rpcclient, sap, sizeof(cb_addr));', '\t\tif (err < 0)', '\t\t\tgoto error;', '\t\terr = rpc_ntop(sap, buf, sizeof(buf));', '\t\tif (err < 0)', '\t\t\tgoto error;', '\t\tip_addr = (const char *)buf;', '\t}', '\tstrlcpy(clp->cl_ipaddr, ip_addr, sizeof(clp->cl_ipaddr));', '', '\terr = nfs_idmap_new(clp);', '\tif (err < 0) {', '\t\tdprintk(""%s: failed to create idmapper. Error = %d\\n"",', '\t\t\t__func__, err);', '\t\tgoto error;', '\t}', '\t__set_bit(NFS_CS_IDMAP, &clp->cl_res_state);']}",True,"fs/nfs/nfs4client.c in the Linux kernel before 5.13.4 has incorrect connection-setup ordering, which allows operators of remote NFSv4 servers to cause a denial of service (hanging of mounts) by arranging for those servers to be unreachable during trunking detection.",6.5,MEDIUM,1,valid,2021-06-09T14:04:46Z,3
CVE-2021-38199,['CWE-Other'],AV:A/AC:L/Au:N/C:N/I:N/A:P,0,torvalds/linux,"NFSv4: Initialise connection to the server in nfs4_alloc_client()

Set up the connection to the NFSv4 server in nfs4_alloc_client(), before
we've added the struct nfs_client to the net-namespace's nfs_client_list
so that a downed server won't cause other mounts to hang in the trunking
detection code.

Reported-by: Michael Wakabayashi <mwakabayashi@vmware.com>
Fixes: 5c6e5b60aae4 (""NFS: Fix an Oops in the pNFS files and flexfiles connection setup to the DS"")
Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>",dd99e9f98fbf423ff6d365b37a98e8879170f17c,https://github.com/torvalds/linux/commit/dd99e9f98fbf423ff6d365b37a98e8879170f17c,fs/nfs/nfs4client.c,nfs4_init_client,"struct nfs_client *nfs4_init_client(struct nfs_client *clp,
const struct nfs_client_initdata *cl_init)
{
char buf[INET6_ADDRSTRLEN + 1];
const char *ip_addr = cl_init->ip_addr;
struct nfs_client *old;
int error;
if (clp->cl_cons_state == NFS_CS_READY)
return clp;
clp->rpc_ops = &nfs_v4_clientops;
if (clp->cl_minorversion != 0)
__set_bit(NFS_CS_INFINITE_SLOTS, &clp->cl_flags);
__set_bit(NFS_CS_DISCRTRY, &clp->cl_flags);
__set_bit(NFS_CS_NO_RETRANS_TIMEOUT, &clp->cl_flags);
error = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_GSS_KRB5I);
if (error == -EINVAL)
error = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_UNIX);
if (error < 0)
goto error;
if (ip_addr == NULL) {
struct sockaddr_storage cb_addr;
struct sockaddr *sap = (struct sockaddr *)&cb_addr;
error = rpc_localaddr(clp->cl_rpcclient, sap, sizeof(cb_addr));
if (error < 0)
goto error;
error = rpc_ntop(sap, buf, sizeof(buf));
if (error < 0)
goto error;
ip_addr = (const char *)buf;
}
strlcpy(clp->cl_ipaddr, ip_addr, sizeof(clp->cl_ipaddr));
error = nfs_idmap_new(clp);
if (error < 0) {
dprintk(""%s: failed to create idmapper. Error = %d\n"",
__func__, error);
goto error;
}
__set_bit(NFS_CS_IDMAP, &clp->cl_res_state);
error = nfs4_init_client_minor_version(clp);
if (error < 0)
goto error;
error = nfs4_discover_server_trunking(clp, &old);
if (error < 0)
goto error;
if (clp != old) {
clp->cl_preserve_clid = true;
nfs_mark_client_ready(clp, -EPERM);
}
clear_bit(NFS_CS_TSM_POSSIBLE, &clp->cl_flags);
nfs_put_client(clp);
return old;
error:
nfs_mark_client_ready(clp, error);
nfs_put_client(clp);
return ERR_PTR(error);
}","struct nfs_client *nfs4_init_client(struct nfs_client *VAR_0,
const struct nfs_client_initdata *VAR_1)
{
char VAR_2[VAR_3 + 1];
const char *VAR_4 = VAR_1->ip_addr;
struct nfs_client *VAR_5;
int VAR_6;
if (VAR_0->cl_cons_state == VAR_7)
return VAR_0;
VAR_0->rpc_ops = &VAR_8;
if (VAR_0->cl_minorversion != 0)
__set_bit(VAR_9, &VAR_0->cl_flags);
__set_bit(VAR_10, &VAR_0->cl_flags);
__set_bit(VAR_11, &VAR_0->cl_flags);
VAR_6 = nfs_create_rpc_client(VAR_0, VAR_1, VAR_12);
if (VAR_6 == -VAR_13)
VAR_6 = nfs_create_rpc_client(VAR_0, VAR_1, VAR_14);
if (VAR_6 < 0)
goto error;
if (VAR_4 == NULL) {
struct sockaddr_storage VAR_15;
struct sockaddr *VAR_16 = (struct sockaddr *)&VAR_15;
VAR_6 = rpc_localaddr(VAR_0->cl_rpcclient, VAR_16, sizeof(VAR_15));
if (VAR_6 < 0)
goto error;
VAR_6 = rpc_ntop(VAR_16, VAR_2, sizeof(VAR_2));
if (VAR_6 < 0)
goto error;
VAR_4 = (const char *)VAR_2;
}
strlcpy(VAR_0->cl_ipaddr, VAR_4, sizeof(VAR_0->cl_ipaddr));
VAR_6 = nfs_idmap_new(VAR_0);
if (VAR_6 < 0) {
dprintk(""%s: failed to create idmapper. Error = %d\n"",
VAR_17, VAR_6);
goto error;
}
__set_bit(VAR_18, &VAR_0->cl_res_state);
VAR_6 = nfs4_init_client_minor_version(VAR_0);
if (VAR_6 < 0)
goto error;
VAR_6 = nfs4_discover_server_trunking(VAR_0, &VAR_5);
if (VAR_6 < 0)
goto error;
if (VAR_0 != VAR_5) {
VAR_0->cl_preserve_clid = true;
nfs_mark_client_ready(VAR_0, -VAR_19);
}
clear_bit(VAR_20, &VAR_0->cl_flags);
nfs_put_client(VAR_0);
return VAR_5;
error:
nfs_mark_client_ready(VAR_0, VAR_6);
nfs_put_client(VAR_0);
return ERR_PTR(VAR_6);
}",torvalds/linux/dd99e9f98fbf423ff6d365b37a98e8879170f17c/nfs4client.c/vul/before/0.json,"struct nfs_client *nfs4_init_client(struct nfs_client *clp,
				    const struct nfs_client_initdata *cl_init)
{
	struct nfs_client *old;
	int error;

	if (clp->cl_cons_state == NFS_CS_READY)
		/* the client is initialised already */
		return clp;

	error = nfs4_init_client_minor_version(clp);
	if (error < 0)
		goto error;

	error = nfs4_discover_server_trunking(clp, &old);
	if (error < 0)
		goto error;

	if (clp != old) {
		clp->cl_preserve_clid = true;
		/*
		 * Mark the client as having failed initialization so other
		 * processes walking the nfs_client_list in nfs_match_client()
		 * won't try to use it.
		 */
		nfs_mark_client_ready(clp, -EPERM);
	}
	clear_bit(NFS_CS_TSM_POSSIBLE, &clp->cl_flags);
	nfs_put_client(clp);
	return old;

error:
	nfs_mark_client_ready(clp, error);
	nfs_put_client(clp);
	return ERR_PTR(error);
}","struct nfs_client *nfs4_init_client(struct nfs_client *VAR_0,
				    const struct nfs_client_initdata *VAR_1)
{
	struct nfs_client *VAR_2;
	int VAR_3;

	if (VAR_0->cl_cons_state == VAR_4)
		/* COMMENT_0 */
		return VAR_0;

	VAR_3 = nfs4_init_client_minor_version(VAR_0);
	if (VAR_3 < 0)
		goto error;

	VAR_3 = nfs4_discover_server_trunking(VAR_0, &VAR_2);
	if (VAR_3 < 0)
		goto error;

	if (VAR_0 != VAR_2) {
		VAR_0->cl_preserve_clid = true;
		/* COMMENT_1 */
                                                             
                                                                
                         
     
		nfs_mark_client_ready(VAR_0, -VAR_5);
	}
	clear_bit(VAR_6, &VAR_0->cl_flags);
	nfs_put_client(VAR_0);
	return VAR_2;

error:
	nfs_mark_client_ready(VAR_0, VAR_3);
	nfs_put_client(VAR_0);
	return ERR_PTR(VAR_3);
}",torvalds/linux/dd99e9f98fbf423ff6d365b37a98e8879170f17c/nfs4client.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,51 +1,12 @@
 struct nfs_client *nfs4_init_client(struct nfs_client *clp,
 				    const struct nfs_client_initdata *cl_init)
 {
-	char buf[INET6_ADDRSTRLEN + 1];
-	const char *ip_addr = cl_init->ip_addr;
 	struct nfs_client *old;
 	int error;
 
 	if (clp->cl_cons_state == NFS_CS_READY)
 		/* the client is initialised already */
 		return clp;
-
-	/* Check NFS protocol revision and initialize RPC op vector */
-	clp->rpc_ops = &nfs_v4_clientops;
-
-	if (clp->cl_minorversion != 0)
-		__set_bit(NFS_CS_INFINITE_SLOTS, &clp->cl_flags);
-	__set_bit(NFS_CS_DISCRTRY, &clp->cl_flags);
-	__set_bit(NFS_CS_NO_RETRANS_TIMEOUT, &clp->cl_flags);
-
-	error = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_GSS_KRB5I);
-	if (error == -EINVAL)
-		error = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_UNIX);
-	if (error < 0)
-		goto error;
-
-	/* If no clientaddr= option was specified, find a usable cb address */
-	if (ip_addr == NULL) {
-		struct sockaddr_storage cb_addr;
-		struct sockaddr *sap = (struct sockaddr *)&cb_addr;
-
-		error = rpc_localaddr(clp->cl_rpcclient, sap, sizeof(cb_addr));
-		if (error < 0)
-			goto error;
-		error = rpc_ntop(sap, buf, sizeof(buf));
-		if (error < 0)
-			goto error;
-		ip_addr = (const char *)buf;
-	}
-	strlcpy(clp->cl_ipaddr, ip_addr, sizeof(clp->cl_ipaddr));
-
-	error = nfs_idmap_new(clp);
-	if (error < 0) {
-		dprintk(""%s: failed to create idmapper. Error = %d\n"",
-			__func__, error);
-		goto error;
-	}
-	__set_bit(NFS_CS_IDMAP, &clp->cl_res_state);
 
 	error = nfs4_init_client_minor_version(clp);
 	if (error < 0)","{'deleted_lines': ['\tchar buf[INET6_ADDRSTRLEN + 1];', '\tconst char *ip_addr = cl_init->ip_addr;', '', '\t/* Check NFS protocol revision and initialize RPC op vector */', '\tclp->rpc_ops = &nfs_v4_clientops;', '', '\tif (clp->cl_minorversion != 0)', '\t\t__set_bit(NFS_CS_INFINITE_SLOTS, &clp->cl_flags);', '\t__set_bit(NFS_CS_DISCRTRY, &clp->cl_flags);', '\t__set_bit(NFS_CS_NO_RETRANS_TIMEOUT, &clp->cl_flags);', '', '\terror = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_GSS_KRB5I);', '\tif (error == -EINVAL)', '\t\terror = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_UNIX);', '\tif (error < 0)', '\t\tgoto error;', '', '\t/* If no clientaddr= option was specified, find a usable cb address */', '\tif (ip_addr == NULL) {', '\t\tstruct sockaddr_storage cb_addr;', '\t\tstruct sockaddr *sap = (struct sockaddr *)&cb_addr;', '', '\t\terror = rpc_localaddr(clp->cl_rpcclient, sap, sizeof(cb_addr));', '\t\tif (error < 0)', '\t\t\tgoto error;', '\t\terror = rpc_ntop(sap, buf, sizeof(buf));', '\t\tif (error < 0)', '\t\t\tgoto error;', '\t\tip_addr = (const char *)buf;', '\t}', '\tstrlcpy(clp->cl_ipaddr, ip_addr, sizeof(clp->cl_ipaddr));', '', '\terror = nfs_idmap_new(clp);', '\tif (error < 0) {', '\t\tdprintk(""%s: failed to create idmapper. Error = %d\\n"",', '\t\t\t__func__, error);', '\t\tgoto error;', '\t}', '\t__set_bit(NFS_CS_IDMAP, &clp->cl_res_state);'], 'added_lines': []}",True,"fs/nfs/nfs4client.c in the Linux kernel before 5.13.4 has incorrect connection-setup ordering, which allows operators of remote NFSv4 servers to cause a denial of service (hanging of mounts) by arranging for those servers to be unreachable during trunking detection.",6.5,MEDIUM,1,valid,2021-06-09T14:04:46Z,3
CVE-2021-32626,"['CWE-787', 'CWE-122']",AV:N/AC:L/Au:S/C:P/I:P/A:P,0,redis,"Fix invalid memory write on lua stack overflow {CVE-2021-32626}

When LUA call our C code, by default, the LUA stack has room for 20
elements. In most cases, this is more than enough but sometimes it's not
and the caller must verify the LUA stack size before he pushes elements.

On 3 places in the code, there was no verification of the LUA stack size.
On specific inputs this missing verification could have lead to invalid
memory write:
1. On 'luaReplyToRedisReply', one might return a nested reply that will
   explode the LUA stack.
2. On 'redisProtocolToLuaType', the Redis reply might be deep enough
 to explode the LUA stack (notice that currently there is no such
 command in Redis that returns such a nested reply, but modules might
 do it)
3. On 'ldbRedis', one might give a command with enough arguments to
 explode the LUA stack (all the arguments will be pushed to the LUA
 stack)

This commit is solving all those 3 issues by calling 'lua_checkstack' and
verify that there is enough room in the LUA stack to push elements. In
case 'lua_checkstack' returns an error (there is not enough room in the
LUA stack and it's not possible to increase the stack), we will do the
following:
1. On 'luaReplyToRedisReply', we will return an error to the user.
2. On 'redisProtocolToLuaType' we will exit with panic (we assume this
   scenario is rare because it can only happen with a module).
3. On 'ldbRedis', we return an error.",666ed7facf4524bf6d19b11b20faa2cf93fdf591,https://github.com/redis/redis/commit/666ed7facf4524bf6d19b11b20faa2cf93fdf591,src/scripting.c,ldbRedis,"void ldbRedis(lua_State *lua, sds *argv, int argc) {
int j, saved_rc = server.lua_replicate_commands;
lua_getglobal(lua,""redis"");
lua_pushstring(lua,""call"");
lua_gettable(lua,-2);       
for (j = 1; j < argc; j++)
lua_pushlstring(lua,argv[j],sdslen(argv[j]));
ldb.step = 1;               
server.lua_replicate_commands = 1;
lua_pcall(lua,argc-1,1,0);  
ldb.step = 0;               
server.lua_replicate_commands = saved_rc;
lua_pop(lua,2);             
}","void ldbRedis(lua_State *VAR_0, sds *VAR_1, int VAR_2) {
int VAR_3, VAR_4 = VAR_5.lua_replicate_commands;
lua_getglobal(VAR_0,""redis"");
lua_pushstring(VAR_0,""call"");
lua_gettable(VAR_0,-2);       
for (VAR_3 = 1; VAR_3 < VAR_2; VAR_3++)
lua_pushlstring(VAR_0,VAR_1[VAR_3],sdslen(VAR_1[VAR_3]));
VAR_6.step = 1;               
VAR_5.lua_replicate_commands = 1;
lua_pcall(VAR_0,VAR_2-1,1,0);  
VAR_6.step = 0;               
VAR_5.lua_replicate_commands = VAR_4;
lua_pop(VAR_0,2);             
}",redis/666ed7facf4524bf6d19b11b20faa2cf93fdf591/scripting.c/vul/before/0.json,"void ldbRedis(lua_State *lua, sds *argv, int argc) {
    int j, saved_rc = server.lua_replicate_commands;

    if (!lua_checkstack(lua, argc + 1)) {
        /* Increase the Lua stack if needed to make sure there is enough room
         * to push 'argc + 1' elements to the stack. On failure, return error.
    * Notice that we need, in worst case, 'argc + 1' elements because we push all the arguments
    * given by the user (without the first argument) and we also push the 'redis' global table and
    * 'redis.call' function so:
    * (1 (redis table)) + (1 (redis.call function)) + (argc - 1 (all arguments without the first)) = argc + 1*/
        ldbLogRedisReply(""max lua stack reached"");
        return;
    }

    lua_getglobal(lua,""redis"");
    lua_pushstring(lua,""call"");
    lua_gettable(lua,-2);       /* Stack: redis, redis.call */
    for (j = 1; j < argc; j++)
        lua_pushlstring(lua,argv[j],sdslen(argv[j]));
    ldb.step = 1;               /* Force redis.call() to log. */
    server.lua_replicate_commands = 1;
    lua_pcall(lua,argc-1,1,0);  /* Stack: redis, result */
    ldb.step = 0;               /* Disable logging. */
    server.lua_replicate_commands = saved_rc;
    lua_pop(lua,2);             /* Discard the result and clean the stack. */
}","void ldbRedis(lua_State *VAR_0, sds *VAR_1, int VAR_2) {
    int VAR_3, VAR_4 = VAR_5.lua_replicate_commands;

    if (!lua_checkstack(VAR_0, VAR_2 + 1)) {
        /* COMMENT_0 */
                                                                              
                                                                                                    
                                                                                                       
                                    
                                                                                                                    
        ldbLogRedisReply(""max lua stack reached"");
        return;
    }

    lua_getglobal(VAR_0,""redis"");
    lua_pushstring(VAR_0,""call"");
    lua_gettable(VAR_0,-2);       /* COMMENT_6 */
    for (VAR_3 = 1; VAR_3 < VAR_2; VAR_3++)
        lua_pushlstring(VAR_0,VAR_1[VAR_3],sdslen(VAR_1[VAR_3]));
    VAR_6.step = 1;               /* COMMENT_7 */
    VAR_5.lua_replicate_commands = 1;
    lua_pcall(VAR_0,VAR_2-1,1,0);  /* COMMENT_8 */
    VAR_6.step = 0;               /* COMMENT_9 */
    VAR_5.lua_replicate_commands = VAR_4;
    lua_pop(VAR_0,2);             /* COMMENT_10 */
}",redis/666ed7facf4524bf6d19b11b20faa2cf93fdf591/scripting.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,16 @@
 void ldbRedis(lua_State *lua, sds *argv, int argc) {
     int j, saved_rc = server.lua_replicate_commands;
+
+    if (!lua_checkstack(lua, argc + 1)) {
+        /* Increase the Lua stack if needed to make sure there is enough room
+         * to push 'argc + 1' elements to the stack. On failure, return error.
+    * Notice that we need, in worst case, 'argc + 1' elements because we push all the arguments
+    * given by the user (without the first argument) and we also push the 'redis' global table and
+    * 'redis.call' function so:
+    * (1 (redis table)) + (1 (redis.call function)) + (argc - 1 (all arguments without the first)) = argc + 1*/
+        ldbLogRedisReply(""max lua stack reached"");
+        return;
+    }
 
     lua_getglobal(lua,""redis"");
     lua_pushstring(lua,""call"");","{'deleted_lines': [], 'added_lines': ['', '    if (!lua_checkstack(lua, argc + 1)) {', '        /* Increase the Lua stack if needed to make sure there is enough room', ""         * to push 'argc + 1' elements to the stack. On failure, return error."", ""\xa0 \xa0 \xa0 \xa0 \xa0* Notice that we need, in worst case, 'argc + 1' elements because we push all the arguments"", ""\xa0 \xa0 \xa0 \xa0 \xa0* given by the user (without the first argument) and we also push the 'redis' global table and"", ""\xa0 \xa0 \xa0 \xa0 \xa0* 'redis.call' function so:"", '\xa0 \xa0 \xa0 \xa0 \xa0* (1 (redis table)) + (1 (redis.call function)) + (argc - 1 (all arguments without the first)) = argc + 1*/', '        ldbLogRedisReply(""max lua stack reached"");', '        return;', '    }']}",True,"Redis is an open source, in-memory database that persists on disk. In affected versions specially crafted Lua scripts executing in Redis can cause the heap-based Lua stack to be overflowed, due to incomplete checks for this condition. This can result with heap corruption and potentially remote code execution. This problem exists in all versions of Redis with Lua scripting support, starting from 2.6. The problem is fixed in versions 6.2.6, 6.0.16 and 5.0.14. For users unable to update an additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from executing Lua scripts. This can be done using ACL to restrict EVAL and EVALSHA commands.",7.5,HIGH,2,valid,2021-06-13T11:27:18Z,3
CVE-2021-32626,"['CWE-787', 'CWE-122']",AV:N/AC:L/Au:S/C:P/I:P/A:P,0,redis,"Fix invalid memory write on lua stack overflow {CVE-2021-32626}

When LUA call our C code, by default, the LUA stack has room for 20
elements. In most cases, this is more than enough but sometimes it's not
and the caller must verify the LUA stack size before he pushes elements.

On 3 places in the code, there was no verification of the LUA stack size.
On specific inputs this missing verification could have lead to invalid
memory write:
1. On 'luaReplyToRedisReply', one might return a nested reply that will
   explode the LUA stack.
2. On 'redisProtocolToLuaType', the Redis reply might be deep enough
 to explode the LUA stack (notice that currently there is no such
 command in Redis that returns such a nested reply, but modules might
 do it)
3. On 'ldbRedis', one might give a command with enough arguments to
 explode the LUA stack (all the arguments will be pushed to the LUA
 stack)

This commit is solving all those 3 issues by calling 'lua_checkstack' and
verify that there is enough room in the LUA stack to push elements. In
case 'lua_checkstack' returns an error (there is not enough room in the
LUA stack and it's not possible to increase the stack), we will do the
following:
1. On 'luaReplyToRedisReply', we will return an error to the user.
2. On 'redisProtocolToLuaType' we will exit with panic (we assume this
   scenario is rare because it can only happen with a module).
3. On 'ldbRedis', we return an error.",666ed7facf4524bf6d19b11b20faa2cf93fdf591,https://github.com/redis/redis/commit/666ed7facf4524bf6d19b11b20faa2cf93fdf591,src/scripting.c,luaReplyToRedisReply,"void luaReplyToRedisReply(client *c, lua_State *lua) {
int t = lua_type(lua,-1);
switch(t) {
case LUA_TSTRING:
addReplyBulkCBuffer(c,(char*)lua_tostring(lua,-1),lua_strlen(lua,-1));
break;
case LUA_TBOOLEAN:
if (server.lua_client->resp == 2)
addReply(c,lua_toboolean(lua,-1) ? shared.cone :
shared.null[c->resp]);
else
addReplyBool(c,lua_toboolean(lua,-1));
break;
case LUA_TNUMBER:
addReplyLongLong(c,(long long)lua_tonumber(lua,-1));
break;
case LUA_TTABLE:
lua_pushstring(lua,""err"");
lua_gettable(lua,-2);
t = lua_type(lua,-1);
if (t == LUA_TSTRING) {
sds err = sdsnew(lua_tostring(lua,-1));
sdsmapchars(err,""\r\n"",""  "",2);
addReplySds(c,sdscatprintf(sdsempty(),""-%s\r\n"",err));
sdsfree(err);
lua_pop(lua,2);
return;
}
lua_pop(lua,1); 
lua_pushstring(lua,""ok"");
lua_gettable(lua,-2);
t = lua_type(lua,-1);
if (t == LUA_TSTRING) {
sds ok = sdsnew(lua_tostring(lua,-1));
sdsmapchars(ok,""\r\n"",""  "",2);
addReplySds(c,sdscatprintf(sdsempty(),""+%s\r\n"",ok));
sdsfree(ok);
lua_pop(lua,2);
return;
}
lua_pop(lua,1); 
lua_pushstring(lua,""double"");
lua_gettable(lua,-2);
t = lua_type(lua,-1);
if (t == LUA_TNUMBER) {
addReplyDouble(c,lua_tonumber(lua,-1));
lua_pop(lua,2);
return;
}
lua_pop(lua,1); 
lua_pushstring(lua,""map"");
lua_gettable(lua,-2);
t = lua_type(lua,-1);
if (t == LUA_TTABLE) {
int maplen = 0;
void *replylen = addReplyDeferredLen(c);
lua_pushnil(lua); 
while (lua_next(lua,-2)) {
lua_pushvalue(lua,-2);        
luaReplyToRedisReply(c, lua); 
luaReplyToRedisReply(c, lua); 
maplen++;
}
setDeferredMapLen(c,replylen,maplen);
lua_pop(lua,2);
return;
}
lua_pop(lua,1); 
lua_pushstring(lua,""set"");
lua_gettable(lua,-2);
t = lua_type(lua,-1);
if (t == LUA_TTABLE) {
int setlen = 0;
void *replylen = addReplyDeferredLen(c);
lua_pushnil(lua); 
while (lua_next(lua,-2)) {
lua_pop(lua,1);               
lua_pushvalue(lua,-1);        
luaReplyToRedisReply(c, lua); 
setlen++;
}
setDeferredSetLen(c,replylen,setlen);
lua_pop(lua,2);
return;
}
lua_pop(lua,1); 
void *replylen = addReplyDeferredLen(c);
int j = 1, mbulklen = 0;
while(1) {
lua_pushnumber(lua,j++);
lua_gettable(lua,-2);
t = lua_type(lua,-1);
if (t == LUA_TNIL) {
lua_pop(lua,1);
break;
}
luaReplyToRedisReply(c, lua);
mbulklen++;
}
setDeferredArrayLen(c,replylen,mbulklen);
break;
default:
addReplyNull(c);
}
lua_pop(lua,1);
}","void luaReplyToRedisReply(client *VAR_0, lua_State *VAR_1) {
int VAR_2 = lua_type(VAR_1,-1);
switch(VAR_2) {
case VAR_3:
addReplyBulkCBuffer(VAR_0,(char*)lua_tostring(VAR_1,-1),lua_strlen(VAR_1,-1));
break;
case VAR_4:
if (VAR_5.lua_client->resp == 2)
addReply(VAR_0,lua_toboolean(VAR_1,-1) ? VAR_6.cone :
VAR_6.null[VAR_0->resp]);
else
addReplyBool(VAR_0,lua_toboolean(VAR_1,-1));
break;
case VAR_7:
addReplyLongLong(VAR_0,(long long)lua_tonumber(VAR_1,-1));
break;
case VAR_8:
lua_pushstring(VAR_1,""err"");
lua_gettable(VAR_1,-2);
VAR_2 = lua_type(VAR_1,-1);
if (VAR_2 == VAR_3) {
sds VAR_9 = sdsnew(lua_tostring(VAR_1,-1));
sdsmapchars(VAR_9,""\r\n"",""  "",2);
addReplySds(VAR_0,sdscatprintf(sdsempty(),""-%s\r\n"",VAR_9));
sdsfree(VAR_9);
lua_pop(VAR_1,2);
return;
}
lua_pop(VAR_1,1); 
lua_pushstring(VAR_1,""ok"");
lua_gettable(VAR_1,-2);
VAR_2 = lua_type(VAR_1,-1);
if (VAR_2 == VAR_3) {
sds VAR_10 = sdsnew(lua_tostring(VAR_1,-1));
sdsmapchars(VAR_10,""\r\n"",""  "",2);
addReplySds(VAR_0,sdscatprintf(sdsempty(),""+%s\r\n"",VAR_10));
sdsfree(VAR_10);
lua_pop(VAR_1,2);
return;
}
lua_pop(VAR_1,1); 
lua_pushstring(VAR_1,""double"");
lua_gettable(VAR_1,-2);
VAR_2 = lua_type(VAR_1,-1);
if (VAR_2 == VAR_7) {
addReplyDouble(VAR_0,lua_tonumber(VAR_1,-1));
lua_pop(VAR_1,2);
return;
}
lua_pop(VAR_1,1); 
lua_pushstring(VAR_1,""map"");
lua_gettable(VAR_1,-2);
VAR_2 = lua_type(VAR_1,-1);
if (VAR_2 == VAR_8) {
int VAR_11 = 0;
void *VAR_12 = addReplyDeferredLen(VAR_0);
lua_pushnil(VAR_1); 
while (lua_next(VAR_1,-2)) {
lua_pushvalue(VAR_1,-2);        
luaReplyToRedisReply(VAR_0, VAR_1); 
luaReplyToRedisReply(VAR_0, VAR_1); 
VAR_11++;
}
setDeferredMapLen(VAR_0,VAR_12,VAR_11);
lua_pop(VAR_1,2);
return;
}
lua_pop(VAR_1,1); 
lua_pushstring(VAR_1,""set"");
lua_gettable(VAR_1,-2);
VAR_2 = lua_type(VAR_1,-1);
if (VAR_2 == VAR_8) {
int VAR_13 = 0;
void *VAR_12 = addReplyDeferredLen(VAR_0);
lua_pushnil(VAR_1); 
while (lua_next(VAR_1,-2)) {
lua_pop(VAR_1,1);               
lua_pushvalue(VAR_1,-1);        
luaReplyToRedisReply(VAR_0, VAR_1); 
VAR_13++;
}
setDeferredSetLen(VAR_0,VAR_12,VAR_13);
lua_pop(VAR_1,2);
return;
}
lua_pop(VAR_1,1); 
void *VAR_12 = addReplyDeferredLen(VAR_0);
int VAR_14 = 1, VAR_15 = 0;
while(1) {
lua_pushnumber(VAR_1,VAR_14++);
lua_gettable(VAR_1,-2);
VAR_2 = lua_type(VAR_1,-1);
if (VAR_2 == VAR_16) {
lua_pop(VAR_1,1);
break;
}
luaReplyToRedisReply(VAR_0, VAR_1);
VAR_15++;
}
setDeferredArrayLen(VAR_0,VAR_12,VAR_15);
break;
default:
addReplyNull(VAR_0);
}
lua_pop(VAR_1,1);
}",redis/666ed7facf4524bf6d19b11b20faa2cf93fdf591/scripting.c/vul/before/1.json,"void luaReplyToRedisReply(client *c, lua_State *lua) {

    if (!lua_checkstack(lua, 4)) {
        /* Increase the Lua stack if needed to make sure there is enough room
         * to push 4 elements to the stack. On failure, return error.
    * Notice that we need, in the worst case, 4 elements because returning a map might
         * require push 4 elements to the Lua stack.*/
        addReplyErrorFormat(c, ""reached lua stack limit"");
        lua_pop(lua,1); // pop the element from the stack
        return;
    }

    int t = lua_type(lua,-1);

    switch(t) {
    case LUA_TSTRING:
        addReplyBulkCBuffer(c,(char*)lua_tostring(lua,-1),lua_strlen(lua,-1));
        break;
    case LUA_TBOOLEAN:
        if (server.lua_client->resp == 2)
            addReply(c,lua_toboolean(lua,-1) ? shared.cone :
                                               shared.null[c->resp]);
        else
            addReplyBool(c,lua_toboolean(lua,-1));
        break;
    case LUA_TNUMBER:
        addReplyLongLong(c,(long long)lua_tonumber(lua,-1));
        break;
    case LUA_TTABLE:
        /* We need to check if it is an array, an error, or a status reply.
         * Error are returned as a single element table with 'err' field.
         * Status replies are returned as single element table with 'ok'
         * field. */

        /* Handle error reply. */
        // we took care of the stack size on function start
        lua_pushstring(lua,""err"");
        lua_gettable(lua,-2);
        t = lua_type(lua,-1);
        if (t == LUA_TSTRING) {
            sds err = sdsnew(lua_tostring(lua,-1));
            sdsmapchars(err,""\r\n"",""  "",2);
            addReplySds(c,sdscatprintf(sdsempty(),""-%s\r\n"",err));
            sdsfree(err);
            lua_pop(lua,2);
            return;
        }
        lua_pop(lua,1); /* Discard field name pushed before. */

        /* Handle status reply. */
        lua_pushstring(lua,""ok"");
        lua_gettable(lua,-2);
        t = lua_type(lua,-1);
        if (t == LUA_TSTRING) {
            sds ok = sdsnew(lua_tostring(lua,-1));
            sdsmapchars(ok,""\r\n"",""  "",2);
            addReplySds(c,sdscatprintf(sdsempty(),""+%s\r\n"",ok));
            sdsfree(ok);
            lua_pop(lua,2);
            return;
        }
        lua_pop(lua,1); /* Discard field name pushed before. */

        /* Handle double reply. */
        lua_pushstring(lua,""double"");
        lua_gettable(lua,-2);
        t = lua_type(lua,-1);
        if (t == LUA_TNUMBER) {
            addReplyDouble(c,lua_tonumber(lua,-1));
            lua_pop(lua,2);
            return;
        }
        lua_pop(lua,1); /* Discard field name pushed before. */

        /* Handle map reply. */
        lua_pushstring(lua,""map"");
        lua_gettable(lua,-2);
        t = lua_type(lua,-1);
        if (t == LUA_TTABLE) {
            int maplen = 0;
            void *replylen = addReplyDeferredLen(c);
            /* we took care of the stack size on function start */
            lua_pushnil(lua); /* Use nil to start iteration. */
            while (lua_next(lua,-2)) {
                /* Stack now: table, key, value */
                lua_pushvalue(lua,-2);        /* Dup key before consuming. */
                luaReplyToRedisReply(c, lua); /* Return key. */
                luaReplyToRedisReply(c, lua); /* Return value. */
                /* Stack now: table, key. */
                maplen++;
            }
            setDeferredMapLen(c,replylen,maplen);
            lua_pop(lua,2);
            return;
        }
        lua_pop(lua,1); /* Discard field name pushed before. */

        /* Handle set reply. */
        lua_pushstring(lua,""set"");
        lua_gettable(lua,-2);
        t = lua_type(lua,-1);
        if (t == LUA_TTABLE) {
            int setlen = 0;
            void *replylen = addReplyDeferredLen(c);
            /* we took care of the stack size on function start */
            lua_pushnil(lua); /* Use nil to start iteration. */
            while (lua_next(lua,-2)) {
                /* Stack now: table, key, true */
                lua_pop(lua,1);               /* Discard the boolean value. */
                lua_pushvalue(lua,-1);        /* Dup key before consuming. */
                luaReplyToRedisReply(c, lua); /* Return key. */
                /* Stack now: table, key. */
                setlen++;
            }
            setDeferredSetLen(c,replylen,setlen);
            lua_pop(lua,2);
            return;
        }
        lua_pop(lua,1); /* Discard field name pushed before. */

        /* Handle the array reply. */
        void *replylen = addReplyDeferredLen(c);
        int j = 1, mbulklen = 0;
        while(1) {
            /* we took care of the stack size on function start */
            lua_pushnumber(lua,j++);
            lua_gettable(lua,-2);
            t = lua_type(lua,-1);
            if (t == LUA_TNIL) {
                lua_pop(lua,1);
                break;
            }
            luaReplyToRedisReply(c, lua);
            mbulklen++;
        }
        setDeferredArrayLen(c,replylen,mbulklen);
        break;
    default:
        addReplyNull(c);
    }
    lua_pop(lua,1);
}","void luaReplyToRedisReply(client *VAR_0, lua_State *VAR_1) {

    if (!lua_checkstack(VAR_1, 4)) {
        /* COMMENT_0 */
                                                                     
                                                                                           
                                                      
        addReplyErrorFormat(VAR_0, ""reached lua stack limit"");
        lua_pop(VAR_1,1); /* COMMENT_4 */
        return;
    }

    int VAR_2 = lua_type(VAR_1,-1);

    switch(VAR_2) {
    case VAR_3:
        addReplyBulkCBuffer(VAR_0,(char*)lua_tostring(VAR_1,-1),lua_strlen(VAR_1,-1));
        break;
    case VAR_4:
        if (VAR_5.lua_client->resp == 2)
            addReply(VAR_0,lua_toboolean(VAR_1,-1) ? VAR_6.cone :
                                               VAR_6.null[VAR_0->resp]);
        else
            addReplyBool(VAR_0,lua_toboolean(VAR_1,-1));
        break;
    case VAR_7:
        addReplyLongLong(VAR_0,(long long)lua_tonumber(VAR_1,-1));
        break;
    case VAR_8:
        /* COMMENT_5 */
                                                                         
                                                                        
                    

        /* COMMENT_9 */
        /* COMMENT_10 */
        lua_pushstring(VAR_1,""err"");
        lua_gettable(VAR_1,-2);
        VAR_2 = lua_type(VAR_1,-1);
        if (VAR_2 == VAR_3) {
            sds VAR_9 = sdsnew(lua_tostring(VAR_1,-1));
            sdsmapchars(VAR_9,""\r\n"",""  "",2);
            addReplySds(VAR_0,sdscatprintf(sdsempty(),""-%s\r\n"",VAR_9));
            sdsfree(VAR_9);
            lua_pop(VAR_1,2);
            return;
        }
        lua_pop(VAR_1,1); /* COMMENT_11 */

        /* COMMENT_12 */
        lua_pushstring(VAR_1,""ok"");
        lua_gettable(VAR_1,-2);
        VAR_2 = lua_type(VAR_1,-1);
        if (VAR_2 == VAR_3) {
            sds VAR_10 = sdsnew(lua_tostring(VAR_1,-1));
            sdsmapchars(VAR_10,""\r\n"",""  "",2);
            addReplySds(VAR_0,sdscatprintf(sdsempty(),""+%s\r\n"",VAR_10));
            sdsfree(VAR_10);
            lua_pop(VAR_1,2);
            return;
        }
        lua_pop(VAR_1,1); /* COMMENT_11 */

        /* COMMENT_13 */
        lua_pushstring(VAR_1,""double"");
        lua_gettable(VAR_1,-2);
        VAR_2 = lua_type(VAR_1,-1);
        if (VAR_2 == VAR_7) {
            addReplyDouble(VAR_0,lua_tonumber(VAR_1,-1));
            lua_pop(VAR_1,2);
            return;
        }
        lua_pop(VAR_1,1); /* COMMENT_11 */

        /* COMMENT_14 */
        lua_pushstring(VAR_1,""map"");
        lua_gettable(VAR_1,-2);
        VAR_2 = lua_type(VAR_1,-1);
        if (VAR_2 == VAR_8) {
            int VAR_11 = 0;
            void *VAR_12 = addReplyDeferredLen(VAR_0);
            /* COMMENT_15 */
            lua_pushnil(VAR_1); /* COMMENT_16 */
            while (lua_next(VAR_1,-2)) {
                /* COMMENT_17 */
                lua_pushvalue(VAR_1,-2);        /* COMMENT_18 */
                luaReplyToRedisReply(VAR_0, VAR_1); /* COMMENT_19 */
                luaReplyToRedisReply(VAR_0, VAR_1); /* COMMENT_20 */
                /* COMMENT_21 */
                VAR_11++;
            }
            setDeferredMapLen(VAR_0,VAR_12,VAR_11);
            lua_pop(VAR_1,2);
            return;
        }
        lua_pop(VAR_1,1); /* COMMENT_11 */

        /* COMMENT_22 */
        lua_pushstring(VAR_1,""set"");
        lua_gettable(VAR_1,-2);
        VAR_2 = lua_type(VAR_1,-1);
        if (VAR_2 == VAR_8) {
            int VAR_13 = 0;
            void *VAR_12 = addReplyDeferredLen(VAR_0);
            /* COMMENT_15 */
            lua_pushnil(VAR_1); /* COMMENT_16 */
            while (lua_next(VAR_1,-2)) {
                /* COMMENT_23 */
                lua_pop(VAR_1,1);               /* COMMENT_24 */
                lua_pushvalue(VAR_1,-1);        /* COMMENT_18 */
                luaReplyToRedisReply(VAR_0, VAR_1); /* COMMENT_19 */
                /* COMMENT_21 */
                VAR_13++;
            }
            setDeferredSetLen(VAR_0,VAR_12,VAR_13);
            lua_pop(VAR_1,2);
            return;
        }
        lua_pop(VAR_1,1); /* COMMENT_11 */

        /* COMMENT_25 */
        void *VAR_12 = addReplyDeferredLen(VAR_0);
        int VAR_14 = 1, VAR_15 = 0;
        while(1) {
            /* COMMENT_15 */
            lua_pushnumber(VAR_1,VAR_14++);
            lua_gettable(VAR_1,-2);
            VAR_2 = lua_type(VAR_1,-1);
            if (VAR_2 == VAR_16) {
                lua_pop(VAR_1,1);
                break;
            }
            luaReplyToRedisReply(VAR_0, VAR_1);
            VAR_15++;
        }
        setDeferredArrayLen(VAR_0,VAR_12,VAR_15);
        break;
    default:
        addReplyNull(VAR_0);
    }
    lua_pop(VAR_1,1);
}",redis/666ed7facf4524bf6d19b11b20faa2cf93fdf591/scripting.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,4 +1,15 @@
 void luaReplyToRedisReply(client *c, lua_State *lua) {
+
+    if (!lua_checkstack(lua, 4)) {
+        /* Increase the Lua stack if needed to make sure there is enough room
+         * to push 4 elements to the stack. On failure, return error.
+    * Notice that we need, in the worst case, 4 elements because returning a map might
+         * require push 4 elements to the Lua stack.*/
+        addReplyErrorFormat(c, ""reached lua stack limit"");
+        lua_pop(lua,1); // pop the element from the stack
+        return;
+    }
+
     int t = lua_type(lua,-1);
 
     switch(t) {
@@ -22,6 +33,7 @@
          * field. */
 
         /* Handle error reply. */
+        // we took care of the stack size on function start
         lua_pushstring(lua,""err"");
         lua_gettable(lua,-2);
         t = lua_type(lua,-1);
@@ -67,6 +79,7 @@
         if (t == LUA_TTABLE) {
             int maplen = 0;
             void *replylen = addReplyDeferredLen(c);
+            /* we took care of the stack size on function start */
             lua_pushnil(lua); /* Use nil to start iteration. */
             while (lua_next(lua,-2)) {
                 /* Stack now: table, key, value */
@@ -89,6 +102,7 @@
         if (t == LUA_TTABLE) {
             int setlen = 0;
             void *replylen = addReplyDeferredLen(c);
+            /* we took care of the stack size on function start */
             lua_pushnil(lua); /* Use nil to start iteration. */
             while (lua_next(lua,-2)) {
                 /* Stack now: table, key, true */
@@ -108,6 +122,7 @@
         void *replylen = addReplyDeferredLen(c);
         int j = 1, mbulklen = 0;
         while(1) {
+            /* we took care of the stack size on function start */
             lua_pushnumber(lua,j++);
             lua_gettable(lua,-2);
             t = lua_type(lua,-1);","{'deleted_lines': [], 'added_lines': ['', '    if (!lua_checkstack(lua, 4)) {', '        /* Increase the Lua stack if needed to make sure there is enough room', '         * to push 4 elements to the stack. On failure, return error.', '\xa0 \xa0 \xa0 \xa0 \xa0* Notice that we need, in the worst case, 4 elements because returning a map might', '         * require push 4 elements to the Lua stack.*/', '        addReplyErrorFormat(c, ""reached lua stack limit"");', '        lua_pop(lua,1); // pop the element from the stack', '        return;', '    }', '', '        // we took care of the stack size on function start', '            /* we took care of the stack size on function start */', '            /* we took care of the stack size on function start */', '            /* we took care of the stack size on function start */']}",True,"Redis is an open source, in-memory database that persists on disk. In affected versions specially crafted Lua scripts executing in Redis can cause the heap-based Lua stack to be overflowed, due to incomplete checks for this condition. This can result with heap corruption and potentially remote code execution. This problem exists in all versions of Redis with Lua scripting support, starting from 2.6. The problem is fixed in versions 6.2.6, 6.0.16 and 5.0.14. For users unable to update an additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from executing Lua scripts. This can be done using ACL to restrict EVAL and EVALSHA commands.",7.5,HIGH,2,valid,2021-06-13T11:27:18Z,3
CVE-2021-32626,"['CWE-787', 'CWE-122']",AV:N/AC:L/Au:S/C:P/I:P/A:P,0,redis,"Fix invalid memory write on lua stack overflow {CVE-2021-32626}

When LUA call our C code, by default, the LUA stack has room for 20
elements. In most cases, this is more than enough but sometimes it's not
and the caller must verify the LUA stack size before he pushes elements.

On 3 places in the code, there was no verification of the LUA stack size.
On specific inputs this missing verification could have lead to invalid
memory write:
1. On 'luaReplyToRedisReply', one might return a nested reply that will
   explode the LUA stack.
2. On 'redisProtocolToLuaType', the Redis reply might be deep enough
 to explode the LUA stack (notice that currently there is no such
 command in Redis that returns such a nested reply, but modules might
 do it)
3. On 'ldbRedis', one might give a command with enough arguments to
 explode the LUA stack (all the arguments will be pushed to the LUA
 stack)

This commit is solving all those 3 issues by calling 'lua_checkstack' and
verify that there is enough room in the LUA stack to push elements. In
case 'lua_checkstack' returns an error (there is not enough room in the
LUA stack and it's not possible to increase the stack), we will do the
following:
1. On 'luaReplyToRedisReply', we will return an error to the user.
2. On 'redisProtocolToLuaType' we will exit with panic (we assume this
   scenario is rare because it can only happen with a module).
3. On 'ldbRedis', we return an error.",666ed7facf4524bf6d19b11b20faa2cf93fdf591,https://github.com/redis/redis/commit/666ed7facf4524bf6d19b11b20faa2cf93fdf591,src/scripting.c,redisProtocolToLuaType,"char *redisProtocolToLuaType(lua_State *lua, char* reply) {
char *p = reply;
switch(*p) {
case ':': p = redisProtocolToLuaType_Int(lua,reply); break;
case '$': p = redisProtocolToLuaType_Bulk(lua,reply); break;
case '+': p = redisProtocolToLuaType_Status(lua,reply); break;
case '-': p = redisProtocolToLuaType_Error(lua,reply); break;
case '*': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;
case '%': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;
case '~': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;
case '_': p = redisProtocolToLuaType_Null(lua,reply); break;
case '#': p = redisProtocolToLuaType_Bool(lua,reply,p[1]); break;
case ',': p = redisProtocolToLuaType_Double(lua,reply); break;
}
return p;
}","char *redisProtocolToLuaType(lua_State *VAR_0, char* VAR_1) {
char *VAR_2 = VAR_1;
switch(*VAR_2) {
case ':': VAR_2 = redisProtocolToLuaType_Int(VAR_0,VAR_1); break;
case '$': VAR_2 = redisProtocolToLuaType_Bulk(VAR_0,VAR_1); break;
case '+': VAR_2 = redisProtocolToLuaType_Status(VAR_0,VAR_1); break;
case '-': VAR_2 = redisProtocolToLuaType_Error(VAR_0,VAR_1); break;
case '*': VAR_2 = redisProtocolToLuaType_Aggregate(VAR_0,VAR_1,*VAR_2); break;
case '%': VAR_2 = redisProtocolToLuaType_Aggregate(VAR_0,VAR_1,*VAR_2); break;
case '~': VAR_2 = redisProtocolToLuaType_Aggregate(VAR_0,VAR_1,*VAR_2); break;
case '_': VAR_2 = redisProtocolToLuaType_Null(VAR_0,VAR_1); break;
case '#': VAR_2 = redisProtocolToLuaType_Bool(VAR_0,VAR_1,VAR_2[1]); break;
case ',': VAR_2 = redisProtocolToLuaType_Double(VAR_0,VAR_1); break;
}
return VAR_2;
}",redis/666ed7facf4524bf6d19b11b20faa2cf93fdf591/scripting.c/vul/before/2.json,"char *redisProtocolToLuaType(lua_State *lua, char* reply) {

    if (!lua_checkstack(lua, 5)) {
        /*
         * Increase the Lua stack if needed, to make sure there is enough room
         * to push 5 elements to the stack. On failure, exit with panic.
    * Notice that we need, in the worst case, 5 elements because redisProtocolToLuaType_Aggregate
    * might push 5 elements to the Lua stack.*/
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }

    char *p = reply;

    switch(*p) {
    case ':': p = redisProtocolToLuaType_Int(lua,reply); break;
    case '$': p = redisProtocolToLuaType_Bulk(lua,reply); break;
    case '+': p = redisProtocolToLuaType_Status(lua,reply); break;
    case '-': p = redisProtocolToLuaType_Error(lua,reply); break;
    case '*': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;
    case '%': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;
    case '~': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;
    case '_': p = redisProtocolToLuaType_Null(lua,reply); break;
    case '#': p = redisProtocolToLuaType_Bool(lua,reply,p[1]); break;
    case ',': p = redisProtocolToLuaType_Double(lua,reply); break;
    }
    return p;
}","char *redisProtocolToLuaType(lua_State *VAR_0, char* VAR_1) {

    if (!lua_checkstack(VAR_0, 5)) {
        /* COMMENT_0 */
                                                                              
                                                                        
                                                                                                      
                                                    
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }

    char *VAR_2 = VAR_1;

    switch(*VAR_2) {
    case ':': VAR_2 = redisProtocolToLuaType_Int(VAR_0,VAR_1); break;
    case '$': VAR_2 = redisProtocolToLuaType_Bulk(VAR_0,VAR_1); break;
    case '+': VAR_2 = redisProtocolToLuaType_Status(VAR_0,VAR_1); break;
    case '-': VAR_2 = redisProtocolToLuaType_Error(VAR_0,VAR_1); break;
    case '*': VAR_2 = redisProtocolToLuaType_Aggregate(VAR_0,VAR_1,*VAR_2); break;
    case '%': VAR_2 = redisProtocolToLuaType_Aggregate(VAR_0,VAR_1,*VAR_2); break;
    case '~': VAR_2 = redisProtocolToLuaType_Aggregate(VAR_0,VAR_1,*VAR_2); break;
    case '_': VAR_2 = redisProtocolToLuaType_Null(VAR_0,VAR_1); break;
    case '#': VAR_2 = redisProtocolToLuaType_Bool(VAR_0,VAR_1,VAR_2[1]); break;
    case ',': VAR_2 = redisProtocolToLuaType_Double(VAR_0,VAR_1); break;
    }
    return VAR_2;
}",redis/666ed7facf4524bf6d19b11b20faa2cf93fdf591/scripting.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,4 +1,14 @@
 char *redisProtocolToLuaType(lua_State *lua, char* reply) {
+
+    if (!lua_checkstack(lua, 5)) {
+        /*
+         * Increase the Lua stack if needed, to make sure there is enough room
+         * to push 5 elements to the stack. On failure, exit with panic.
+    * Notice that we need, in the worst case, 5 elements because redisProtocolToLuaType_Aggregate
+    * might push 5 elements to the Lua stack.*/
+        serverPanic(""lua stack limit reach when parsing redis.call reply"");
+    }
+
     char *p = reply;
 
     switch(*p) {","{'deleted_lines': [], 'added_lines': ['', '    if (!lua_checkstack(lua, 5)) {', '        /*', '         * Increase the Lua stack if needed, to make sure there is enough room', '         * to push 5 elements to the stack. On failure, exit with panic.', '\xa0 \xa0 \xa0 \xa0 \xa0* Notice that we need, in the worst case, 5 elements because redisProtocolToLuaType_Aggregate', '\xa0 \xa0 \xa0 \xa0 \xa0* might push 5 elements to the Lua stack.*/', '        serverPanic(""lua stack limit reach when parsing redis.call reply"");', '    }', '']}",True,"Redis is an open source, in-memory database that persists on disk. In affected versions specially crafted Lua scripts executing in Redis can cause the heap-based Lua stack to be overflowed, due to incomplete checks for this condition. This can result with heap corruption and potentially remote code execution. This problem exists in all versions of Redis with Lua scripting support, starting from 2.6. The problem is fixed in versions 6.2.6, 6.0.16 and 5.0.14. For users unable to update an additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from executing Lua scripts. This can be done using ACL to restrict EVAL and EVALSHA commands.",7.5,HIGH,2,valid,2021-06-13T11:27:18Z,3
CVE-2021-32626,"['CWE-787', 'CWE-122']",AV:N/AC:L/Au:S/C:P/I:P/A:P,0,redis,"Fix invalid memory write on lua stack overflow {CVE-2021-32626}

When LUA call our C code, by default, the LUA stack has room for 20
elements. In most cases, this is more than enough but sometimes it's not
and the caller must verify the LUA stack size before he pushes elements.

On 3 places in the code, there was no verification of the LUA stack size.
On specific inputs this missing verification could have lead to invalid
memory write:
1. On 'luaReplyToRedisReply', one might return a nested reply that will
   explode the LUA stack.
2. On 'redisProtocolToLuaType', the Redis reply might be deep enough
 to explode the LUA stack (notice that currently there is no such
 command in Redis that returns such a nested reply, but modules might
 do it)
3. On 'ldbRedis', one might give a command with enough arguments to
 explode the LUA stack (all the arguments will be pushed to the LUA
 stack)

This commit is solving all those 3 issues by calling 'lua_checkstack' and
verify that there is enough room in the LUA stack to push elements. In
case 'lua_checkstack' returns an error (there is not enough room in the
LUA stack and it's not possible to increase the stack), we will do the
following:
1. On 'luaReplyToRedisReply', we will return an error to the user.
2. On 'redisProtocolToLuaType' we will exit with panic (we assume this
   scenario is rare because it can only happen with a module).
3. On 'ldbRedis', we return an error.",666ed7facf4524bf6d19b11b20faa2cf93fdf591,https://github.com/redis/redis/commit/666ed7facf4524bf6d19b11b20faa2cf93fdf591,src/scripting.c,redisProtocolToLuaType_Aggregate,"char *redisProtocolToLuaType_Aggregate(lua_State *lua, char *reply, int atype) {
char *p = strchr(reply+1,'\r');
long long mbulklen;
int j = 0;
string2ll(reply+1,p-reply-1,&mbulklen);
if (server.lua_client->resp == 2 || atype == '*') {
p += 2;
if (mbulklen == -1) {
lua_pushboolean(lua,0);
return p;
}
lua_newtable(lua);
for (j = 0; j < mbulklen; j++) {
lua_pushnumber(lua,j+1);
p = redisProtocolToLuaType(lua,p);
lua_settable(lua,-3);
}
} else if (server.lua_client->resp == 3) {
p += 2;
lua_newtable(lua);
lua_pushstring(lua,atype == '%' ? ""map"" : ""set"");
lua_newtable(lua);
for (j = 0; j < mbulklen; j++) {
p = redisProtocolToLuaType(lua,p);
if (atype == '%') {
p = redisProtocolToLuaType(lua,p);
} else {
lua_pushboolean(lua,1);
}
lua_settable(lua,-3);
}
lua_settable(lua,-3);
}
return p;
}","char *redisProtocolToLuaType_Aggregate(lua_State *VAR_0, char *VAR_1, int VAR_2) {
char *VAR_3 = strchr(VAR_1+1,'\r');
long long VAR_4;
int VAR_5 = 0;
string2ll(VAR_1+1,VAR_3-VAR_1-1,&VAR_4);
if (VAR_6.lua_client->resp == 2 || VAR_2 == '*') {
VAR_3 += 2;
if (VAR_4 == -1) {
lua_pushboolean(VAR_0,0);
return VAR_3;
}
lua_newtable(VAR_0);
for (VAR_5 = 0; VAR_5 < VAR_4; VAR_5++) {
lua_pushnumber(VAR_0,VAR_5+1);
VAR_3 = redisProtocolToLuaType(VAR_0,VAR_3);
lua_settable(VAR_0,-3);
}
} else if (VAR_6.lua_client->resp == 3) {
VAR_3 += 2;
lua_newtable(VAR_0);
lua_pushstring(VAR_0,VAR_2 == '%' ? ""map"" : ""set"");
lua_newtable(VAR_0);
for (VAR_5 = 0; VAR_5 < VAR_4; VAR_5++) {
VAR_3 = redisProtocolToLuaType(VAR_0,VAR_3);
if (VAR_2 == '%') {
VAR_3 = redisProtocolToLuaType(VAR_0,VAR_3);
} else {
lua_pushboolean(VAR_0,1);
}
lua_settable(VAR_0,-3);
}
lua_settable(VAR_0,-3);
}
return VAR_3;
}",redis/666ed7facf4524bf6d19b11b20faa2cf93fdf591/scripting.c/vul/before/3.json,"char *redisProtocolToLuaType_Aggregate(lua_State *lua, char *reply, int atype) {
    char *p = strchr(reply+1,'\r');
    long long mbulklen;
    int j = 0;

    string2ll(reply+1,p-reply-1,&mbulklen);
    if (server.lua_client->resp == 2 || atype == '*') {
        p += 2;
        if (mbulklen == -1) {
            lua_pushboolean(lua,0);
            return p;
        }
        lua_newtable(lua);
        for (j = 0; j < mbulklen; j++) {
            lua_pushnumber(lua,j+1);
            p = redisProtocolToLuaType(lua,p);
            lua_settable(lua,-3);
        }
    } else if (server.lua_client->resp == 3) {
        /* Here we handle only Set and Map replies in RESP3 mode, since arrays
         * follow the above RESP2 code path. Note that those are represented
         * as a table with the ""map"" or ""set"" field populated with the actual
         * table representing the set or the map type. */
        p += 2;
        lua_newtable(lua);
        lua_pushstring(lua,atype == '%' ? ""map"" : ""set"");
        lua_newtable(lua);
        for (j = 0; j < mbulklen; j++) {
            p = redisProtocolToLuaType(lua,p);
            if (atype == '%') {
                p = redisProtocolToLuaType(lua,p);
            } else {
                if (!lua_checkstack(lua, 1)) {
                    /* Notice that here we need to check the stack again because the recursive
                     * call to redisProtocolToLuaType might have use the room allocated in the stack */
                    serverPanic(""lua stack limit reach when parsing redis.call reply"");
                }
                lua_pushboolean(lua,1);
            }
            lua_settable(lua,-3);
        }
        lua_settable(lua,-3);
    }
    return p;
}","char *redisProtocolToLuaType_Aggregate(lua_State *VAR_0, char *VAR_1, int VAR_2) {
    char *VAR_3 = strchr(VAR_1+1,'\r');
    long long VAR_4;
    int VAR_5 = 0;

    string2ll(VAR_1+1,VAR_3-VAR_1-1,&VAR_4);
    if (VAR_6.lua_client->resp == 2 || VAR_2 == '*') {
        VAR_3 += 2;
        if (VAR_4 == -1) {
            lua_pushboolean(VAR_0,0);
            return VAR_3;
        }
        lua_newtable(VAR_0);
        for (VAR_5 = 0; VAR_5 < VAR_4; VAR_5++) {
            lua_pushnumber(VAR_0,VAR_5+1);
            VAR_3 = redisProtocolToLuaType(VAR_0,VAR_3);
            lua_settable(VAR_0,-3);
        }
    } else if (VAR_6.lua_client->resp == 3) {
        /* COMMENT_0 */
                                                                            
                                                                             
                                                         
        VAR_3 += 2;
        lua_newtable(VAR_0);
        lua_pushstring(VAR_0,VAR_2 == '%' ? ""map"" : ""set"");
        lua_newtable(VAR_0);
        for (VAR_5 = 0; VAR_5 < VAR_4; VAR_5++) {
            VAR_3 = redisProtocolToLuaType(VAR_0,VAR_3);
            if (VAR_2 == '%') {
                VAR_3 = redisProtocolToLuaType(VAR_0,VAR_3);
            } else {
                if (!lua_checkstack(VAR_0, 1)) {
                    /* COMMENT_4 */
                                                                                                       
                    serverPanic(""lua stack limit reach when parsing redis.call reply"");
                }
                lua_pushboolean(VAR_0,1);
            }
            lua_settable(VAR_0,-3);
        }
        lua_settable(VAR_0,-3);
    }
    return VAR_3;
}",redis/666ed7facf4524bf6d19b11b20faa2cf93fdf591/scripting.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -30,6 +30,11 @@
             if (atype == '%') {
                 p = redisProtocolToLuaType(lua,p);
             } else {
+                if (!lua_checkstack(lua, 1)) {
+                    /* Notice that here we need to check the stack again because the recursive
+                     * call to redisProtocolToLuaType might have use the room allocated in the stack */
+                    serverPanic(""lua stack limit reach when parsing redis.call reply"");
+                }
                 lua_pushboolean(lua,1);
             }
             lua_settable(lua,-3);","{'deleted_lines': [], 'added_lines': ['                if (!lua_checkstack(lua, 1)) {', '                    /* Notice that here we need to check the stack again because the recursive', '                     * call to redisProtocolToLuaType might have use the room allocated in the stack */', '                    serverPanic(""lua stack limit reach when parsing redis.call reply"");', '                }']}",True,"Redis is an open source, in-memory database that persists on disk. In affected versions specially crafted Lua scripts executing in Redis can cause the heap-based Lua stack to be overflowed, due to incomplete checks for this condition. This can result with heap corruption and potentially remote code execution. This problem exists in all versions of Redis with Lua scripting support, starting from 2.6. The problem is fixed in versions 6.2.6, 6.0.16 and 5.0.14. For users unable to update an additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from executing Lua scripts. This can be done using ACL to restrict EVAL and EVALSHA commands.",7.5,HIGH,2,valid,2021-06-13T11:27:18Z,3
CVE-2021-36357,['CWE-681'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,open-power/skiboot,"secvar: fix endian conversion

unpack_timestamp() calls le32_to_cpu() for endian conversion of
uint16_t ""year"" value. This patch fixes the code to use le16_to_cpu().

Signed-off-by: Nayna Jain <nayna@linux.ibm.com>
Reviewed-by: Daniel Axtens <dja@axtens.net>
Signed-off-by: Vasant Hegde <hegdevasant@linux.vnet.ibm.com>",5be38b672c1410e2f10acd3ad2eecfdc81d5daf7,https://github.com/open-power/skiboot/commit/5be38b672c1410e2f10acd3ad2eecfdc81d5daf7,libstb/secvar/backend/edk2-compat-process.c,unpack_timestamp,"static uint64_t unpack_timestamp(const struct efi_time *timestamp)
{
uint64_t val = 0;
uint16_t year = le32_to_cpu(timestamp->year);
val |= ((uint64_t) timestamp->pad1 & 0xFF) << 0;
val |= ((uint64_t) timestamp->second & 0xFF) << (1*8);
val |= ((uint64_t) timestamp->minute & 0xFF) << (2*8);
val |= ((uint64_t) timestamp->hour & 0xFF) << (3*8);
val |= ((uint64_t) timestamp->day & 0xFF) << (4*8);
val |= ((uint64_t) timestamp->month & 0xFF) << (5*8);
val |= ((uint64_t) year) << (6*8);
return val;
}","static uint64_t unpack_timestamp(const struct efi_time *VAR_0)
{
uint64_t VAR_1 = 0;
uint16_t VAR_2 = le32_to_cpu(VAR_0->year);
VAR_1 |= ((uint64_t) VAR_0->pad1 & 0xFF) << 0;
VAR_1 |= ((uint64_t) VAR_0->second & 0xFF) << (1*8);
VAR_1 |= ((uint64_t) VAR_0->minute & 0xFF) << (2*8);
VAR_1 |= ((uint64_t) VAR_0->hour & 0xFF) << (3*8);
VAR_1 |= ((uint64_t) VAR_0->day & 0xFF) << (4*8);
VAR_1 |= ((uint64_t) VAR_0->month & 0xFF) << (5*8);
VAR_1 |= ((uint64_t) VAR_2) << (6*8);
return VAR_1;
}",open-power/skiboot/5be38b672c1410e2f10acd3ad2eecfdc81d5daf7/edk2-compat-process.c/vul/before/0.json,"static uint64_t unpack_timestamp(const struct efi_time *timestamp)
{
	uint64_t val = 0;
	uint16_t year = le16_to_cpu(timestamp->year);

	/* pad1, nanosecond, timezone, daylight and pad2 are meant to be zero */
	val |= ((uint64_t) timestamp->pad1 & 0xFF) << 0;
	val |= ((uint64_t) timestamp->second & 0xFF) << (1*8);
	val |= ((uint64_t) timestamp->minute & 0xFF) << (2*8);
	val |= ((uint64_t) timestamp->hour & 0xFF) << (3*8);
	val |= ((uint64_t) timestamp->day & 0xFF) << (4*8);
	val |= ((uint64_t) timestamp->month & 0xFF) << (5*8);
	val |= ((uint64_t) year) << (6*8);

	return val;
}","static uint64_t unpack_timestamp(const struct efi_time *VAR_0)
{
	uint64_t VAR_1 = 0;
	uint16_t VAR_2 = le16_to_cpu(VAR_0->year);

	/* COMMENT_0 */
	VAR_1 |= ((uint64_t) VAR_0->pad1 & 0xFF) << 0;
	VAR_1 |= ((uint64_t) VAR_0->second & 0xFF) << (1*8);
	VAR_1 |= ((uint64_t) VAR_0->minute & 0xFF) << (2*8);
	VAR_1 |= ((uint64_t) VAR_0->hour & 0xFF) << (3*8);
	VAR_1 |= ((uint64_t) VAR_0->day & 0xFF) << (4*8);
	VAR_1 |= ((uint64_t) VAR_0->month & 0xFF) << (5*8);
	VAR_1 |= ((uint64_t) VAR_2) << (6*8);

	return VAR_1;
}",open-power/skiboot/5be38b672c1410e2f10acd3ad2eecfdc81d5daf7/edk2-compat-process.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 static uint64_t unpack_timestamp(const struct efi_time *timestamp)
 {
 	uint64_t val = 0;
-	uint16_t year = le32_to_cpu(timestamp->year);
+	uint16_t year = le16_to_cpu(timestamp->year);
 
 	/* pad1, nanosecond, timezone, daylight and pad2 are meant to be zero */
 	val |= ((uint64_t) timestamp->pad1 & 0xFF) << 0;","{'deleted_lines': ['\tuint16_t year = le32_to_cpu(timestamp->year);'], 'added_lines': ['\tuint16_t year = le16_to_cpu(timestamp->year);']}",True,"An issue was discovered in OpenPOWER 2.6 firmware. unpack_timestamp() calls le32_to_cpu() for endian conversion of a uint16_t ""year"" value, resulting in a type mismatch that can truncate a higher integer value to a smaller one, and bypass a timestamp check. The fix is to use the right endian conversion function.",9.8,CRITICAL,3,valid,2021-06-20T15:13:47Z,3
CVE-2021-37616,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,Exiv2/exiv2,Check that findKey didn't return end().,3ac426b2c04004422c290425259082281e090116,https://github.com/Exiv2/exiv2/commit/3ac426b2c04004422c290425259082281e090116,src/crwimage_int.cpp,CrwMap::encode0x080a,"void CrwMap::encode0x080a(const Image&      image,
const CrwMapping* pCrwMapping,
CiffHeader* pHead)
{
assert(pCrwMapping != 0);
assert(pHead != 0);
const ExifKey k1(""Exif.Image.Make"");
const ExifKey k2(""Exif.Image.Model"");
const ExifData::const_iterator ed1 = image.exifData().findKey(k1);
const ExifData::const_iterator ed2 = image.exifData().findKey(k2);
const ExifData::const_iterator edEnd = image.exifData().end();
long size = 0;
if (ed1 != edEnd) size += ed1->size();
if (ed2 != edEnd) size += ed2->size();
if (size != 0) {
DataBuf buf(size);
if (ed1 != edEnd) ed1->copy(buf.pData_, pHead->byteOrder());
if (ed2 != edEnd) ed2->copy(buf.pData_ + ed1->size(), pHead->byteOrder());
pHead->add(pCrwMapping->crwTagId_, pCrwMapping->crwDir_, buf);
}
else {
pHead->remove(pCrwMapping->crwTagId_, pCrwMapping->crwDir_);
}
}","void CrwMap::encode0x080a(const Image&      VAR_0,
const CrwMapping* VAR_1,
CiffHeader* VAR_2)
{
assert(VAR_1 != 0);
assert(VAR_2 != 0);
const ExifKey VAR_3(""Exif.Image.Make"");
const ExifKey VAR_4(""Exif.Image.Model"");
const ExifData::const_iterator VAR_5 = VAR_0.exifData().findKey(VAR_3);
const ExifData::const_iterator VAR_6 = VAR_0.exifData().findKey(VAR_4);
const ExifData::const_iterator VAR_7 = VAR_0.exifData().end();
long VAR_8 = 0;
if (VAR_5 != VAR_7) VAR_8 += VAR_5->size();
if (VAR_6 != VAR_7) VAR_8 += VAR_6->size();
if (VAR_8 != 0) {
DataBuf buf(size);
if (VAR_5 != VAR_7) VAR_5->copy(VAR_9.pData_, VAR_2->byteOrder());
if (VAR_6 != VAR_7) VAR_6->copy(VAR_9.pData_ + VAR_5->size(), VAR_2->byteOrder());
VAR_2->add(VAR_1->crwTagId_, VAR_1->crwDir_, VAR_9);
}
else {
VAR_2->remove(VAR_1->crwTagId_, VAR_1->crwDir_);
}
}",Exiv2/exiv2/3ac426b2c04004422c290425259082281e090116/crwimage_int.cpp/vul/before/0.json,"void CrwMap::encode0x080a(const Image&      image,
                              const CrwMapping* pCrwMapping,
                                    CiffHeader* pHead)
    {
        assert(pCrwMapping != 0);
        assert(pHead != 0);

        const ExifKey k1(""Exif.Image.Make"");
        const ExifKey k2(""Exif.Image.Model"");
        const ExifData::const_iterator ed1 = image.exifData().findKey(k1);
        const ExifData::const_iterator ed2 = image.exifData().findKey(k2);
        const ExifData::const_iterator edEnd = image.exifData().end();

        long size = 0;
        if (ed1 != edEnd) size += ed1->size();
        if (ed2 != edEnd) size += ed2->size();
        if (size != 0) {
            DataBuf buf(size);
            long pos = 0;
            if (ed1 != edEnd) {
                ed1->copy(buf.pData_, pHead->byteOrder());
                pos += ed1->size();
            }
            if (ed2 != edEnd) {
                ed2->copy(buf.pData_ + pos, pHead->byteOrder());
                pos += ed2->size();
            }
            assert(pos == size);
            pHead->add(pCrwMapping->crwTagId_, pCrwMapping->crwDir_, buf);
        }
        else {
            pHead->remove(pCrwMapping->crwTagId_, pCrwMapping->crwDir_);
        }
    }","void CrwMap::encode0x080a(const Image&      VAR_0,
                              const CrwMapping* VAR_1,
                                    CiffHeader* VAR_2)
    {
        assert(VAR_1 != 0);
        assert(VAR_2 != 0);

        const ExifKey VAR_3(""Exif.Image.Make"");
        const ExifKey VAR_4(""Exif.Image.Model"");
        const ExifData::const_iterator VAR_5 = VAR_0.exifData().findKey(VAR_3);
        const ExifData::const_iterator VAR_6 = VAR_0.exifData().findKey(VAR_4);
        const ExifData::const_iterator VAR_7 = VAR_0.exifData().end();

        long VAR_8 = 0;
        if (VAR_5 != VAR_7) VAR_8 += VAR_5->size();
        if (VAR_6 != VAR_7) VAR_8 += VAR_6->size();
        if (VAR_8 != 0) {
            DataBuf buf(size);
            long VAR_9 = 0;
            if (VAR_5 != VAR_7) {
                VAR_5->copy(VAR_10.pData_, VAR_2->byteOrder());
                VAR_9 += VAR_5->size();
            }
            if (VAR_6 != VAR_7) {
                VAR_6->copy(VAR_10.pData_ + VAR_9, VAR_2->byteOrder());
                VAR_9 += VAR_6->size();
            }
            assert(VAR_9 == size);
            VAR_2->add(VAR_1->crwTagId_, VAR_1->crwDir_, VAR_10);
        }
        else {
            VAR_2->remove(VAR_1->crwTagId_, VAR_1->crwDir_);
        }
    }",Exiv2/exiv2/3ac426b2c04004422c290425259082281e090116/crwimage_int.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -16,8 +16,16 @@
         if (ed2 != edEnd) size += ed2->size();
         if (size != 0) {
             DataBuf buf(size);
-            if (ed1 != edEnd) ed1->copy(buf.pData_, pHead->byteOrder());
-            if (ed2 != edEnd) ed2->copy(buf.pData_ + ed1->size(), pHead->byteOrder());
+            long pos = 0;
+            if (ed1 != edEnd) {
+                ed1->copy(buf.pData_, pHead->byteOrder());
+                pos += ed1->size();
+            }
+            if (ed2 != edEnd) {
+                ed2->copy(buf.pData_ + pos, pHead->byteOrder());
+                pos += ed2->size();
+            }
+            assert(pos == size);
             pHead->add(pCrwMapping->crwTagId_, pCrwMapping->crwDir_, buf);
         }
         else {","{'deleted_lines': ['            if (ed1 != edEnd) ed1->copy(buf.pData_, pHead->byteOrder());', '            if (ed2 != edEnd) ed2->copy(buf.pData_ + ed1->size(), pHead->byteOrder());'], 'added_lines': ['            long pos = 0;', '            if (ed1 != edEnd) {', '                ed1->copy(buf.pData_, pHead->byteOrder());', '                pos += ed1->size();', '            }', '            if (ed2 != edEnd) {', '                ed2->copy(buf.pData_ + pos, pHead->byteOrder());', '                pos += ed2->size();', '            }', '            assert(pos == size);']}",True,"Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. A null pointer dereference was found in Exiv2 versions v0.27.4 and earlier. The null pointer dereference is triggered when Exiv2 is used to print the metadata of a crafted image file. An attacker could potentially exploit the vulnerability to cause a denial of service, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when printing the interpreted (translated) data, which is a less frequently used Exiv2 operation that requires an extra command line option (`-p t` or `-P t`). The bug is fixed in version v0.27.5.",5.5,MEDIUM,1,valid,2021-07-03T21:36:53Z,3
CVE-2021-37616,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,Exiv2/exiv2,Check that findKey didn't return end().,3ac426b2c04004422c290425259082281e090116,https://github.com/Exiv2/exiv2/commit/3ac426b2c04004422c290425259082281e090116,src/convert.cpp,Converter::cnvExifDate,"void Converter::cnvExifDate(const char* from, const char* to)
{
Exiv2::ExifData::iterator pos = exifData_->findKey(ExifKey(from));
if (pos == exifData_->end()) return;
if (!prepareXmpTarget(to)) return;
int year=0, month=0, day=0, hour=0, min=0, sec=0;
std::string subsec;
char buf[30];
if (std::string(from) != ""Exif.GPSInfo.GPSTimeStamp"") {
std::string value = pos->toString();
if (!pos->value().ok()) {
#ifndef SUPPRESS_WARNINGS
EXV_WARNING << ""Failed to convert "" << from << "" to "" << to << ""\n"";
#endif
return;
}
if (sscanf(value.c_str(), ""%d:%d:%d %d:%d:%d"", &year, &month, &day, &hour, &min, &sec) != 6) {
#ifndef SUPPRESS_WARNINGS
EXV_WARNING << ""Failed to convert "" << from << "" to "" << to
<< "", unable to parse '"" << value << ""'\n"";
#endif
return;
}
}
else { 
bool ok = true;
if (pos->count() != 3) ok = false;
if (ok) {
for (int i = 0; i < 3; ++i) {
if (pos->toRational(i).second == 0) {
ok = false;
break;
}
}
}
if (!ok) {
#ifndef SUPPRESS_WARNINGS
EXV_WARNING << ""Failed to convert "" << from << "" to "" << to << ""\n"";
#endif
return;
}
double dhour = pos->toFloat(0);
double dmin = pos->toFloat(1);
Rational r = pos->toRational(2);
double dsec = static_cast<double>(r.first)/r.second;
if (!pos->value().ok()) {
#ifndef SUPPRESS_WARNINGS
EXV_WARNING << ""Failed to convert "" << from << "" to "" << to << ""\n"";
#endif
return;
}
dsec = dhour * 3600.0 + dmin * 60.0 + dsec;
hour = static_cast<int>(dsec / 3600.0);
dsec -= hour * 3600;
min = static_cast<int>(dsec / 60.0);
dsec -= min * 60;
sec = static_cast<int>(dsec);
dsec -= sec;
snprintf(buf, sizeof(buf), ""%.9f"", dsec);
buf[sizeof(buf) - 1] = 0;
buf[1] = '.';             subsec = buf + 1;
Exiv2::ExifData::iterator datePos = exifData_->findKey(ExifKey(""Exif.GPSInfo.GPSDateStamp""));
if (datePos == exifData_->end()) {
datePos = exifData_->findKey(ExifKey(""Exif.Photo.DateTimeOriginal""));
}
if (datePos == exifData_->end()) {
datePos = exifData_->findKey(ExifKey(""Exif.Photo.DateTimeDigitized""));
}
if (datePos == exifData_->end()) {
#ifndef SUPPRESS_WARNINGS
EXV_WARNING << ""Failed to convert "" << from << "" to "" << to << ""\n"";
#endif
return;
}
std::string value = datePos->toString();
if (sscanf(value.c_str(), ""%d:%d:%d"", &year, &month, &day) != 3) {
#ifndef SUPPRESS_WARNINGS
EXV_WARNING << ""Failed to convert "" << from << "" to "" << to
<< "", unable to parse '"" << value << ""'\n"";
#endif
return;
}
}
const char* subsecTag = 0;
if (std::string(from) == ""Exif.Image.DateTime"") {
subsecTag = ""Exif.Photo.SubSecTime"";
}
else if (std::string(from) == ""Exif.Photo.DateTimeOriginal"") {
subsecTag = ""Exif.Photo.SubSecTimeOriginal"";
}
else if (std::string(from) == ""Exif.Photo.DateTimeDigitized"") {
subsecTag = ""Exif.Photo.SubSecTimeDigitized"";
}
if (subsecTag) {
ExifData::iterator subsec_pos = exifData_->findKey(ExifKey(subsecTag));
if (   subsec_pos != exifData_->end()
&& subsec_pos->typeId() == asciiString) {
std::string ss = subsec_pos->toString();
if (!ss.empty()) {
bool ok = false;
stringTo<long>(ss, ok);
if (ok) subsec = std::string(""."") + ss;
}
}
if (erase_) exifData_->erase(subsec_pos);
}
if (subsec.size() > 10) subsec = subsec.substr(0, 10);
snprintf(buf, sizeof(buf), ""%4d-%02d-%02dT%02d:%02d:%02d%s"",
year, month, day, hour, min, sec, subsec.c_str());
buf[sizeof(buf) - 1] = 0;
(*xmpData_)[to] = buf;
if (erase_) exifData_->erase(pos);
}","void Converter::cnvExifDate(const char* VAR_0, const char* VAR_1)
{
Exiv2::ExifData::iterator VAR_2 = VAR_3->findKey(ExifKey(VAR_0));
if (VAR_2 == VAR_3->end()) return;
if (!prepareXmpTarget(VAR_1)) return;
int VAR_4=0, VAR_5=0, VAR_6=0, VAR_7=0, VAR_8=0, VAR_9=0;
std::string VAR_10;
char VAR_11[30];
if (std::string(VAR_0) != ""Exif.GPSInfo.GPSTimeStamp"") {
std::string VAR_12 = VAR_2->toString();
if (!VAR_2->value().ok()) {
#ifndef VAR_13
VAR_14 << ""Failed to convert "" << VAR_0 << "" to "" << VAR_1 << ""\n"";
#endif
return;
}
if (sscanf(VAR_12.c_str(), ""%d:%d:%d %d:%d:%d"", &VAR_4, &VAR_5, &VAR_6, &VAR_7, &VAR_8, &VAR_9) != 6) {
#ifndef VAR_13
VAR_14 << ""Failed to convert "" << VAR_0 << "" to "" << VAR_1
<< "", unable to parse '"" << VAR_12 << ""'\n"";
#endif
return;
}
}
else { 
bool VAR_15 = true;
if (VAR_2->count() != 3) VAR_15 = false;
if (VAR_15) {
for (int VAR_16 = 0; VAR_16 < 3; ++VAR_16) {
if (VAR_2->toRational(VAR_16).second == 0) {
VAR_15 = false;
break;
}
}
}
if (!VAR_15) {
#ifndef VAR_13
VAR_14 << ""Failed to convert "" << VAR_0 << "" to "" << VAR_1 << ""\n"";
#endif
return;
}
double VAR_17 = VAR_2->toFloat(0);
double VAR_18 = VAR_2->toFloat(1);
Rational VAR_19 = VAR_2->toRational(2);
double VAR_20 = VAR_21<double>(VAR_19.first)/VAR_19.second;
if (!VAR_2->value().ok()) {
#ifndef VAR_13
VAR_14 << ""Failed to convert "" << VAR_0 << "" to "" << VAR_1 << ""\n"";
#endif
return;
}
VAR_20 = VAR_17 * 3600.0 + VAR_18 * 60.0 + VAR_20;
VAR_7 = VAR_21<int>(VAR_20 / 3600.0);
VAR_20 -= VAR_7 * 3600;
VAR_8 = VAR_21<int>(VAR_20 / 60.0);
VAR_20 -= VAR_8 * 60;
VAR_9 = VAR_21<int>(VAR_20);
VAR_20 -= VAR_9;
snprintf(VAR_11, sizeof(VAR_11), ""%.9f"", VAR_20);
VAR_11[sizeof(VAR_11) - 1] = 0;
VAR_11[1] = '.'; 
VAR_10 = VAR_11 + 1;
Exiv2::ExifData::iterator VAR_22 = VAR_3->findKey(ExifKey(""Exif.GPSInfo.GPSDateStamp""));
if (VAR_22 == VAR_3->end()) {
VAR_22 = VAR_3->findKey(ExifKey(""Exif.Photo.DateTimeOriginal""));
}
if (VAR_22 == VAR_3->end()) {
VAR_22 = VAR_3->findKey(ExifKey(""Exif.Photo.DateTimeDigitized""));
}
if (VAR_22 == VAR_3->end()) {
#ifndef VAR_13
VAR_14 << ""Failed to convert "" << VAR_0 << "" to "" << VAR_1 << ""\n"";
#endif
return;
}
std::string VAR_12 = VAR_22->toString();
if (sscanf(VAR_12.c_str(), ""%d:%d:%d"", &VAR_4, &VAR_5, &VAR_6) != 3) {
#ifndef VAR_13
VAR_14 << ""Failed to convert "" << VAR_0 << "" to "" << VAR_1
<< "", unable to parse '"" << VAR_12 << ""'\n"";
#endif
return;
}
}
const char* VAR_23 = 0;
if (std::string(VAR_0) == ""Exif.Image.DateTime"") {
VAR_23 = ""Exif.Photo.SubSecTime"";
}
else if (std::string(VAR_0) == ""Exif.Photo.DateTimeOriginal"") {
VAR_23 = ""Exif.Photo.SubSecTimeOriginal"";
}
else if (std::string(VAR_0) == ""Exif.Photo.DateTimeDigitized"") {
VAR_23 = ""Exif.Photo.SubSecTimeDigitized"";
}
if (VAR_23) {
ExifData::iterator VAR_24 = VAR_3->findKey(ExifKey(VAR_23));
if (   VAR_24 != VAR_3->end()
&& VAR_24->typeId() == VAR_25) {
std::string VAR_26 = VAR_24->toString();
if (!VAR_26.empty()) {
bool VAR_15 = false;
VAR_27<long>(VAR_26, VAR_15);
if (VAR_15) VAR_10 = std::string(""."") + VAR_26;
}
}
if (VAR_28) VAR_3->erase(VAR_24);
}
if (VAR_10.size() > 10) VAR_10 = VAR_10.substr(0, 10);
snprintf(VAR_11, sizeof(VAR_11), ""%4d-%02d-%02dT%02d:%02d:%02d%s"",
VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10.c_str());
VAR_11[sizeof(VAR_11) - 1] = 0;
(*VAR_29)[VAR_1] = VAR_11;
if (VAR_28) VAR_3->erase(VAR_2);
}",Exiv2/exiv2/3ac426b2c04004422c290425259082281e090116/convert.cpp/vul/before/0.json,"void Converter::cnvExifDate(const char* from, const char* to)
    {
        Exiv2::ExifData::iterator pos = exifData_->findKey(ExifKey(from));
        if (pos == exifData_->end()) return;
        if (!prepareXmpTarget(to)) return;
        int year=0, month=0, day=0, hour=0, min=0, sec=0;
        std::string subsec;
        char buf[30];

        if (std::string(from) != ""Exif.GPSInfo.GPSTimeStamp"") {
            std::string value = pos->toString();
            if (!pos->value().ok()) {
#ifndef SUPPRESS_WARNINGS
                EXV_WARNING << ""Failed to convert "" << from << "" to "" << to << ""\n"";
#endif
                return;
            }
            if (sscanf(value.c_str(), ""%d:%d:%d %d:%d:%d"", &year, &month, &day, &hour, &min, &sec) != 6) {
#ifndef SUPPRESS_WARNINGS
                EXV_WARNING << ""Failed to convert "" << from << "" to "" << to
                            << "", unable to parse '"" << value << ""'\n"";
#endif
                return;
            }
        }
        else { // ""Exif.GPSInfo.GPSTimeStamp""

            bool ok = true;
            if (pos->count() != 3) ok = false;
            if (ok) {
                for (int i = 0; i < 3; ++i) {
                    if (pos->toRational(i).second == 0) {
                        ok = false;
                        break;
                    }
                }
            }
            if (!ok) {
#ifndef SUPPRESS_WARNINGS
                EXV_WARNING << ""Failed to convert "" << from << "" to "" << to << ""\n"";
#endif
                return;
            }

            double dhour = pos->toFloat(0);
            double dmin = pos->toFloat(1);
            // Hack: Need Value::toDouble
            Rational r = pos->toRational(2);
            double dsec = static_cast<double>(r.first)/r.second;

            if (!pos->value().ok()) {
#ifndef SUPPRESS_WARNINGS
                EXV_WARNING << ""Failed to convert "" << from << "" to "" << to << ""\n"";
#endif
                return;
            }

            dsec = dhour * 3600.0 + dmin * 60.0 + dsec;

            hour = static_cast<int>(dsec / 3600.0);
            dsec -= hour * 3600;
            min = static_cast<int>(dsec / 60.0);
            dsec -= min * 60;
            sec = static_cast<int>(dsec);
            dsec -= sec;

            snprintf(buf, sizeof(buf), ""%.9f"", dsec);
            buf[sizeof(buf) - 1] = 0;
            buf[1] = '.'; // some locales use ','
            subsec = buf + 1;

            Exiv2::ExifData::iterator datePos = exifData_->findKey(ExifKey(""Exif.GPSInfo.GPSDateStamp""));
            if (datePos == exifData_->end()) {
                datePos = exifData_->findKey(ExifKey(""Exif.Photo.DateTimeOriginal""));
            }
            if (datePos == exifData_->end()) {
                datePos = exifData_->findKey(ExifKey(""Exif.Photo.DateTimeDigitized""));
            }
            if (datePos == exifData_->end()) {
#ifndef SUPPRESS_WARNINGS
                EXV_WARNING << ""Failed to convert "" << from << "" to "" << to << ""\n"";
#endif
                return;
            }
            std::string value = datePos->toString();
            if (sscanf(value.c_str(), ""%d:%d:%d"", &year, &month, &day) != 3) {
#ifndef SUPPRESS_WARNINGS
                EXV_WARNING << ""Failed to convert "" << from << "" to "" << to
                            << "", unable to parse '"" << value << ""'\n"";
#endif
                return;
            }
        }

        const char* subsecTag = 0;
        if (std::string(from) == ""Exif.Image.DateTime"") {
            subsecTag = ""Exif.Photo.SubSecTime"";
        }
        else if (std::string(from) == ""Exif.Photo.DateTimeOriginal"") {
            subsecTag = ""Exif.Photo.SubSecTimeOriginal"";
        }
        else if (std::string(from) == ""Exif.Photo.DateTimeDigitized"") {
            subsecTag = ""Exif.Photo.SubSecTimeDigitized"";
        }

        if (subsecTag) {
            ExifData::iterator subsec_pos = exifData_->findKey(ExifKey(subsecTag));
            if (subsec_pos != exifData_->end()) {
                if (subsec_pos->typeId() == asciiString) {
                    std::string ss = subsec_pos->toString();
                    if (!ss.empty()) {
                        bool ok = false;
                        stringTo<long>(ss, ok);
                        if (ok) subsec = std::string(""."") + ss;
                    }
                }
                if (erase_) exifData_->erase(subsec_pos);
            }
        }

        if (subsec.size() > 10) subsec = subsec.substr(0, 10);
        snprintf(buf, sizeof(buf), ""%4d-%02d-%02dT%02d:%02d:%02d%s"",
                 year, month, day, hour, min, sec, subsec.c_str());
        buf[sizeof(buf) - 1] = 0;

        (*xmpData_)[to] = buf;
        if (erase_) exifData_->erase(pos);
    }","void Converter::cnvExifDate(const char* VAR_0, const char* VAR_1)
    {
        Exiv2::ExifData::iterator VAR_2 = VAR_3->findKey(ExifKey(VAR_0));
        if (VAR_2 == VAR_3->end()) return;
        if (!prepareXmpTarget(VAR_1)) return;
        int VAR_4=0, VAR_5=0, VAR_6=0, VAR_7=0, VAR_8=0, VAR_9=0;
        std::string VAR_10;
        char VAR_11[30];

        if (std::string(VAR_0) != ""Exif.GPSInfo.GPSTimeStamp"") {
            std::string VAR_12 = VAR_2->toString();
            if (!VAR_2->value().ok()) {
#ifndef VAR_13
                VAR_14 << ""Failed to convert "" << VAR_0 << "" to "" << VAR_1 << ""\n"";
#endif
                return;
            }
            if (sscanf(VAR_12.c_str(), ""%d:%d:%d %d:%d:%d"", &VAR_4, &VAR_5, &VAR_6, &VAR_7, &VAR_8, &VAR_9) != 6) {
#ifndef VAR_13
                VAR_14 << ""Failed to convert "" << VAR_0 << "" to "" << VAR_1
                            << "", unable to parse '"" << VAR_12 << ""'\n"";
#endif
                return;
            }
        }
        else { /* COMMENT_0 */

            bool VAR_15 = true;
            if (VAR_2->count() != 3) VAR_15 = false;
            if (VAR_15) {
                for (int VAR_16 = 0; VAR_16 < 3; ++VAR_16) {
                    if (VAR_2->toRational(VAR_16).second == 0) {
                        VAR_15 = false;
                        break;
                    }
                }
            }
            if (!VAR_15) {
#ifndef VAR_13
                VAR_14 << ""Failed to convert "" << VAR_0 << "" to "" << VAR_1 << ""\n"";
#endif
                return;
            }

            double VAR_17 = VAR_2->toFloat(0);
            double VAR_18 = VAR_2->toFloat(1);
            /* COMMENT_1 */
            Rational VAR_19 = VAR_2->toRational(2);
            double VAR_20 = VAR_21<double>(VAR_19.first)/VAR_19.second;

            if (!VAR_2->value().ok()) {
#ifndef VAR_13
                VAR_14 << ""Failed to convert "" << VAR_0 << "" to "" << VAR_1 << ""\n"";
#endif
                return;
            }

            VAR_20 = VAR_17 * 3600.0 + VAR_18 * 60.0 + VAR_20;

            VAR_7 = VAR_21<int>(VAR_20 / 3600.0);
            VAR_20 -= VAR_7 * 3600;
            VAR_8 = VAR_21<int>(VAR_20 / 60.0);
            VAR_20 -= VAR_8 * 60;
            VAR_9 = VAR_21<int>(VAR_20);
            VAR_20 -= VAR_9;

            snprintf(VAR_11, sizeof(VAR_11), ""%.9f"", VAR_20);
            VAR_11[sizeof(VAR_11) - 1] = 0;
            VAR_11[1] = '.'; /* COMMENT_2 */
            VAR_10 = VAR_11 + 1;

            Exiv2::ExifData::iterator VAR_22 = VAR_3->findKey(ExifKey(""Exif.GPSInfo.GPSDateStamp""));
            if (VAR_22 == VAR_3->end()) {
                VAR_22 = VAR_3->findKey(ExifKey(""Exif.Photo.DateTimeOriginal""));
            }
            if (VAR_22 == VAR_3->end()) {
                VAR_22 = VAR_3->findKey(ExifKey(""Exif.Photo.DateTimeDigitized""));
            }
            if (VAR_22 == VAR_3->end()) {
#ifndef VAR_13
                VAR_14 << ""Failed to convert "" << VAR_0 << "" to "" << VAR_1 << ""\n"";
#endif
                return;
            }
            std::string VAR_12 = VAR_22->toString();
            if (sscanf(VAR_12.c_str(), ""%d:%d:%d"", &VAR_4, &VAR_5, &VAR_6) != 3) {
#ifndef VAR_13
                VAR_14 << ""Failed to convert "" << VAR_0 << "" to "" << VAR_1
                            << "", unable to parse '"" << VAR_12 << ""'\n"";
#endif
                return;
            }
        }

        const char* VAR_23 = 0;
        if (std::string(VAR_0) == ""Exif.Image.DateTime"") {
            VAR_23 = ""Exif.Photo.SubSecTime"";
        }
        else if (std::string(VAR_0) == ""Exif.Photo.DateTimeOriginal"") {
            VAR_23 = ""Exif.Photo.SubSecTimeOriginal"";
        }
        else if (std::string(VAR_0) == ""Exif.Photo.DateTimeDigitized"") {
            VAR_23 = ""Exif.Photo.SubSecTimeDigitized"";
        }

        if (VAR_23) {
            ExifData::iterator VAR_24 = VAR_3->findKey(ExifKey(VAR_23));
            if (VAR_24 != VAR_3->end()) {
                if (VAR_24->typeId() == VAR_25) {
                    std::string VAR_26 = VAR_24->toString();
                    if (!VAR_26.empty()) {
                        bool VAR_15 = false;
                        VAR_27<long>(VAR_26, VAR_15);
                        if (VAR_15) VAR_10 = std::string(""."") + VAR_26;
                    }
                }
                if (VAR_28) VAR_3->erase(VAR_24);
            }
        }

        if (VAR_10.size() > 10) VAR_10 = VAR_10.substr(0, 10);
        snprintf(VAR_11, sizeof(VAR_11), ""%4d-%02d-%02dT%02d:%02d:%02d%s"",
                 VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10.c_str());
        VAR_11[sizeof(VAR_11) - 1] = 0;

        (*VAR_29)[VAR_1] = VAR_11;
        if (VAR_28) VAR_3->erase(VAR_2);
    }",Exiv2/exiv2/3ac426b2c04004422c290425259082281e090116/convert.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -105,16 +105,17 @@
 
         if (subsecTag) {
             ExifData::iterator subsec_pos = exifData_->findKey(ExifKey(subsecTag));
-            if (   subsec_pos != exifData_->end()
-                && subsec_pos->typeId() == asciiString) {
-                std::string ss = subsec_pos->toString();
-                if (!ss.empty()) {
-                    bool ok = false;
-                    stringTo<long>(ss, ok);
-                    if (ok) subsec = std::string(""."") + ss;
+            if (subsec_pos != exifData_->end()) {
+                if (subsec_pos->typeId() == asciiString) {
+                    std::string ss = subsec_pos->toString();
+                    if (!ss.empty()) {
+                        bool ok = false;
+                        stringTo<long>(ss, ok);
+                        if (ok) subsec = std::string(""."") + ss;
+                    }
                 }
+                if (erase_) exifData_->erase(subsec_pos);
             }
-            if (erase_) exifData_->erase(subsec_pos);
         }
 
         if (subsec.size() > 10) subsec = subsec.substr(0, 10);","{'deleted_lines': ['            if (   subsec_pos != exifData_->end()', '                && subsec_pos->typeId() == asciiString) {', '                std::string ss = subsec_pos->toString();', '                if (!ss.empty()) {', '                    bool ok = false;', '                    stringTo<long>(ss, ok);', '                    if (ok) subsec = std::string(""."") + ss;', '            if (erase_) exifData_->erase(subsec_pos);'], 'added_lines': ['            if (subsec_pos != exifData_->end()) {', '                if (subsec_pos->typeId() == asciiString) {', '                    std::string ss = subsec_pos->toString();', '                    if (!ss.empty()) {', '                        bool ok = false;', '                        stringTo<long>(ss, ok);', '                        if (ok) subsec = std::string(""."") + ss;', '                    }', '                if (erase_) exifData_->erase(subsec_pos);']}",True,"Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. A null pointer dereference was found in Exiv2 versions v0.27.4 and earlier. The null pointer dereference is triggered when Exiv2 is used to print the metadata of a crafted image file. An attacker could potentially exploit the vulnerability to cause a denial of service, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when printing the interpreted (translated) data, which is a less frequently used Exiv2 operation that requires an extra command line option (`-p t` or `-P t`). The bug is fixed in version v0.27.5.",5.5,MEDIUM,1,valid,2021-07-03T21:36:53Z,3
CVE-2021-37616,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,Exiv2/exiv2,Check that findKey didn't return end().,3ac426b2c04004422c290425259082281e090116,https://github.com/Exiv2/exiv2/commit/3ac426b2c04004422c290425259082281e090116,src/convert.cpp,Converter::cnvXmpFlash,"void Converter::cnvXmpFlash(const char* from, const char* to)
{
Exiv2::XmpData::iterator pos = xmpData_->findKey(XmpKey(std::string(from) + ""/exif:Fired""));
if (pos == xmpData_->end()) return;
if (!prepareExifTarget(to)) return;
unsigned short value = 0;
if (pos != xmpData_->end() && pos->count() > 0) {
int fired = pos->toLong();
if (pos->value().ok())
value |= fired & 1;
#ifndef SUPPRESS_WARNINGS
else
EXV_WARNING << ""Failed to convert "" << std::string(from) + ""/exif:Fired"" << "" to "" << to << ""\n"";
#endif
}
pos = xmpData_->findKey(XmpKey(std::string(from) + ""/exif:Return""));
if (pos != xmpData_->end() && pos->count() > 0) {
int ret = pos->toLong();
if (pos->value().ok())
value |= (ret & 3) << 1;
#ifndef SUPPRESS_WARNINGS
else
EXV_WARNING << ""Failed to convert "" << std::string(from) + ""/exif:Return"" << "" to "" << to << ""\n"";
#endif
}
pos = xmpData_->findKey(XmpKey(std::string(from) + ""/exif:Mode""));
if (pos != xmpData_->end() && pos->count() > 0) {
int mode = pos->toLong();
if (pos->value().ok())
value |= (mode & 3) << 3;
#ifndef SUPPRESS_WARNINGS
else
EXV_WARNING << ""Failed to convert "" << std::string(from) + ""/exif:Mode"" << "" to "" << to << ""\n"";
#endif
}
pos = xmpData_->findKey(XmpKey(std::string(from) + ""/exif:Function""));
if (pos != xmpData_->end() && pos->count() > 0) {
int function = pos->toLong();
if (pos->value().ok())
value |= (function & 1) << 5;
#ifndef SUPPRESS_WARNINGS
else
EXV_WARNING << ""Failed to convert "" << std::string(from) + ""/exif:Function"" << "" to "" << to << ""\n"";
#endif
}
pos = xmpData_->findKey(XmpKey(std::string(from) + ""/exif:RedEyeMode""));
if (pos != xmpData_->end() && pos->count() > 0) {
int red = pos->toLong();
if (pos->value().ok())
value |= (red & 1) << 6;
#ifndef SUPPRESS_WARNINGS
else
EXV_WARNING << ""Failed to convert "" << std::string(from) + ""/exif:RedEyeMode"" << "" to "" << to << ""\n"";
#endif
}
(*exifData_)[to] = value;
if (erase_) xmpData_->erase(pos);
}","void Converter::cnvXmpFlash(const char* VAR_0, const char* VAR_1)
{
Exiv2::XmpData::iterator VAR_2 = VAR_3->findKey(XmpKey(std::string(VAR_0) + ""/exif:Fired""));
if (VAR_2 == VAR_3->end()) return;
if (!prepareExifTarget(VAR_1)) return;
unsigned short VAR_4 = 0;
if (VAR_2 != VAR_3->end() && VAR_2->count() > 0) {
int VAR_5 = VAR_2->toLong();
if (VAR_2->value().ok())
VAR_4 |= VAR_5 & 1;
#ifndef VAR_6
else
VAR_7 << ""Failed to convert "" << std::string(VAR_0) + ""/exif:Fired"" << "" to "" << VAR_1 << ""\n"";
#endif
}
VAR_2 = VAR_3->findKey(XmpKey(std::string(VAR_0) + ""/exif:Return""));
if (VAR_2 != VAR_3->end() && VAR_2->count() > 0) {
int VAR_8 = VAR_2->toLong();
if (VAR_2->value().ok())
VAR_4 |= (VAR_8 & 3) << 1;
#ifndef VAR_6
else
VAR_7 << ""Failed to convert "" << std::string(VAR_0) + ""/exif:Return"" << "" to "" << VAR_1 << ""\n"";
#endif
}
VAR_2 = VAR_3->findKey(XmpKey(std::string(VAR_0) + ""/exif:Mode""));
if (VAR_2 != VAR_3->end() && VAR_2->count() > 0) {
int VAR_9 = VAR_2->toLong();
if (VAR_2->value().ok())
VAR_4 |= (VAR_9 & 3) << 3;
#ifndef VAR_6
else
VAR_7 << ""Failed to convert "" << std::string(VAR_0) + ""/exif:Mode"" << "" to "" << VAR_1 << ""\n"";
#endif
}
VAR_2 = VAR_3->findKey(XmpKey(std::string(VAR_0) + ""/exif:Function""));
if (VAR_2 != VAR_3->end() && VAR_2->count() > 0) {
int VAR_10 = VAR_2->toLong();
if (VAR_2->value().ok())
VAR_4 |= (VAR_10 & 1) << 5;
#ifndef VAR_6
else
VAR_7 << ""Failed to convert "" << std::string(VAR_0) + ""/exif:Function"" << "" to "" << VAR_1 << ""\n"";
#endif
}
VAR_2 = VAR_3->findKey(XmpKey(std::string(VAR_0) + ""/exif:RedEyeMode""));
if (VAR_2 != VAR_3->end() && VAR_2->count() > 0) {
int VAR_11 = VAR_2->toLong();
if (VAR_2->value().ok())
VAR_4 |= (VAR_11 & 1) << 6;
#ifndef VAR_6
else
VAR_7 << ""Failed to convert "" << std::string(VAR_0) + ""/exif:RedEyeMode"" << "" to "" << VAR_1 << ""\n"";
#endif
}
(*VAR_12)[VAR_1] = VAR_4;
if (VAR_13) VAR_3->erase(VAR_2);
}",Exiv2/exiv2/3ac426b2c04004422c290425259082281e090116/convert.cpp/vul/before/1.json,"void Converter::cnvXmpFlash(const char* from, const char* to)
    {
        Exiv2::XmpData::iterator pos = xmpData_->findKey(XmpKey(std::string(from) + ""/exif:Fired""));
        if (pos == xmpData_->end()) return;
        if (!prepareExifTarget(to)) return;
        unsigned short value = 0;

        if (pos != xmpData_->end() && pos->count() > 0) {
            int fired = pos->toLong();
            if (pos->value().ok())
                value |= fired & 1;
#ifndef SUPPRESS_WARNINGS
            else
                EXV_WARNING << ""Failed to convert "" << std::string(from) + ""/exif:Fired"" << "" to "" << to << ""\n"";
#endif
        }
        pos = xmpData_->findKey(XmpKey(std::string(from) + ""/exif:Return""));
        if (pos != xmpData_->end() && pos->count() > 0) {
            int ret = pos->toLong();
            if (pos->value().ok())
                value |= (ret & 3) << 1;
#ifndef SUPPRESS_WARNINGS
            else
                EXV_WARNING << ""Failed to convert "" << std::string(from) + ""/exif:Return"" << "" to "" << to << ""\n"";
#endif
        }
        pos = xmpData_->findKey(XmpKey(std::string(from) + ""/exif:Mode""));
        if (pos != xmpData_->end() && pos->count() > 0) {
            int mode = pos->toLong();
            if (pos->value().ok())
                value |= (mode & 3) << 3;
#ifndef SUPPRESS_WARNINGS
            else
                EXV_WARNING << ""Failed to convert "" << std::string(from) + ""/exif:Mode"" << "" to "" << to << ""\n"";
#endif
        }
        pos = xmpData_->findKey(XmpKey(std::string(from) + ""/exif:Function""));
        if (pos != xmpData_->end() && pos->count() > 0) {
            int function = pos->toLong();
            if (pos->value().ok())
                value |= (function & 1) << 5;
#ifndef SUPPRESS_WARNINGS
            else
                EXV_WARNING << ""Failed to convert "" << std::string(from) + ""/exif:Function"" << "" to "" << to << ""\n"";
#endif
        }
        pos = xmpData_->findKey(XmpKey(std::string(from) + ""/exif:RedEyeMode""));
        if (pos != xmpData_->end()) {
            if (pos->count() > 0) {
                int red = pos->toLong();
                if (pos->value().ok())
                    value |= (red & 1) << 6;
#ifndef SUPPRESS_WARNINGS
                else
                    EXV_WARNING << ""Failed to convert "" << std::string(from) + ""/exif:RedEyeMode"" << "" to "" << to << ""\n"";
#endif
            }
            if (erase_) xmpData_->erase(pos);
        }

        (*exifData_)[to] = value;
    }","void Converter::cnvXmpFlash(const char* VAR_0, const char* VAR_1)
    {
        Exiv2::XmpData::iterator VAR_2 = VAR_3->findKey(XmpKey(std::string(VAR_0) + ""/exif:Fired""));
        if (VAR_2 == VAR_3->end()) return;
        if (!prepareExifTarget(VAR_1)) return;
        unsigned short VAR_4 = 0;

        if (VAR_2 != VAR_3->end() && VAR_2->count() > 0) {
            int VAR_5 = VAR_2->toLong();
            if (VAR_2->value().ok())
                VAR_4 |= VAR_5 & 1;
#ifndef VAR_6
            else
                VAR_7 << ""Failed to convert "" << std::string(VAR_0) + ""/exif:Fired"" << "" to "" << VAR_1 << ""\n"";
#endif
        }
        VAR_2 = VAR_3->findKey(XmpKey(std::string(VAR_0) + ""/exif:Return""));
        if (VAR_2 != VAR_3->end() && VAR_2->count() > 0) {
            int VAR_8 = VAR_2->toLong();
            if (VAR_2->value().ok())
                VAR_4 |= (VAR_8 & 3) << 1;
#ifndef VAR_6
            else
                VAR_7 << ""Failed to convert "" << std::string(VAR_0) + ""/exif:Return"" << "" to "" << VAR_1 << ""\n"";
#endif
        }
        VAR_2 = VAR_3->findKey(XmpKey(std::string(VAR_0) + ""/exif:Mode""));
        if (VAR_2 != VAR_3->end() && VAR_2->count() > 0) {
            int VAR_9 = VAR_2->toLong();
            if (VAR_2->value().ok())
                VAR_4 |= (VAR_9 & 3) << 3;
#ifndef VAR_6
            else
                VAR_7 << ""Failed to convert "" << std::string(VAR_0) + ""/exif:Mode"" << "" to "" << VAR_1 << ""\n"";
#endif
        }
        VAR_2 = VAR_3->findKey(XmpKey(std::string(VAR_0) + ""/exif:Function""));
        if (VAR_2 != VAR_3->end() && VAR_2->count() > 0) {
            int VAR_10 = VAR_2->toLong();
            if (VAR_2->value().ok())
                VAR_4 |= (VAR_10 & 1) << 5;
#ifndef VAR_6
            else
                VAR_7 << ""Failed to convert "" << std::string(VAR_0) + ""/exif:Function"" << "" to "" << VAR_1 << ""\n"";
#endif
        }
        VAR_2 = VAR_3->findKey(XmpKey(std::string(VAR_0) + ""/exif:RedEyeMode""));
        if (VAR_2 != VAR_3->end()) {
            if (VAR_2->count() > 0) {
                int VAR_11 = VAR_2->toLong();
                if (VAR_2->value().ok())
                    VAR_4 |= (VAR_11 & 1) << 6;
#ifndef VAR_6
                else
                    VAR_7 << ""Failed to convert "" << std::string(VAR_0) + ""/exif:RedEyeMode"" << "" to "" << VAR_1 << ""\n"";
#endif
            }
            if (VAR_12) VAR_3->erase(VAR_2);
        }

        (*VAR_13)[VAR_1] = VAR_4;
    }",Exiv2/exiv2/3ac426b2c04004422c290425259082281e090116/convert.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -45,16 +45,18 @@
 #endif
         }
         pos = xmpData_->findKey(XmpKey(std::string(from) + ""/exif:RedEyeMode""));
-        if (pos != xmpData_->end() && pos->count() > 0) {
-            int red = pos->toLong();
-            if (pos->value().ok())
-                value |= (red & 1) << 6;
+        if (pos != xmpData_->end()) {
+            if (pos->count() > 0) {
+                int red = pos->toLong();
+                if (pos->value().ok())
+                    value |= (red & 1) << 6;
 #ifndef SUPPRESS_WARNINGS
-            else
-                EXV_WARNING << ""Failed to convert "" << std::string(from) + ""/exif:RedEyeMode"" << "" to "" << to << ""\n"";
+                else
+                    EXV_WARNING << ""Failed to convert "" << std::string(from) + ""/exif:RedEyeMode"" << "" to "" << to << ""\n"";
 #endif
+            }
+            if (erase_) xmpData_->erase(pos);
         }
 
         (*exifData_)[to] = value;
-        if (erase_) xmpData_->erase(pos);
     }","{'deleted_lines': ['        if (pos != xmpData_->end() && pos->count() > 0) {', '            int red = pos->toLong();', '            if (pos->value().ok())', '                value |= (red & 1) << 6;', '            else', '                EXV_WARNING << ""Failed to convert "" << std::string(from) + ""/exif:RedEyeMode"" << "" to "" << to << ""\\n"";', '        if (erase_) xmpData_->erase(pos);'], 'added_lines': ['        if (pos != xmpData_->end()) {', '            if (pos->count() > 0) {', '                int red = pos->toLong();', '                if (pos->value().ok())', '                    value |= (red & 1) << 6;', '                else', '                    EXV_WARNING << ""Failed to convert "" << std::string(from) + ""/exif:RedEyeMode"" << "" to "" << to << ""\\n"";', '            }', '            if (erase_) xmpData_->erase(pos);']}",True,"Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. A null pointer dereference was found in Exiv2 versions v0.27.4 and earlier. The null pointer dereference is triggered when Exiv2 is used to print the metadata of a crafted image file. An attacker could potentially exploit the vulnerability to cause a denial of service, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when printing the interpreted (translated) data, which is a less frequently used Exiv2 operation that requires an extra command line option (`-p t` or `-P t`). The bug is fixed in version v0.27.5.",5.5,MEDIUM,1,valid,2021-07-03T21:36:53Z,3
CVE-2021-37682,['CWE-908'],AV:L/AC:L/Au:N/C:N/I:P/A:P,0,tensorflow,"Fix a null pointer exception caused by branching on uninitialized data.

This is due to not checking that the params for the quantization exists. If there is no quantization, we should not access the `.params` field.

PiperOrigin-RevId: 385163909
Change-Id: I2beb8d50649b6542db224c163033fbcbaa49314f",537bc7c723439b9194a358f64d871dd326c18887,https://github.com/tensorflow/tensorflow/commit/537bc7c723439b9194a358f64d871dd326c18887,tensorflow/lite/kernels/svdf.cc,Prepare,"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
const auto* params = reinterpret_cast<TfLiteSVDFParams*>(node->builtin_data);
OpData* op_data = reinterpret_cast<OpData*>(node->user_data);
int scratch_tensor_index = op_data->scratch_tensor_index;
TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);
TF_LITE_ENSURE_EQ(context, node->inputs->size, 5);
const TfLiteTensor* input;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));
const TfLiteTensor* weights_feature;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kWeightsFeatureTensor,
&weights_feature));
const TfLiteTensor* weights_time;
TF_LITE_ENSURE_OK(
context, GetInputSafe(context, node, kWeightsTimeTensor, &weights_time));
TF_LITE_ENSURE(context,
input->type == kTfLiteFloat32 || input->type == kTfLiteInt8);
const int rank = params->rank;
const int batch_size = input->dims->data[0];
const int num_filters = weights_feature->dims->data[0];
TF_LITE_ENSURE(context, rank != 0);
TF_LITE_ENSURE_EQ(context, num_filters % rank, 0);
const int num_units = num_filters / rank;
const int memory_size = weights_time->dims->data[1];
TF_LITE_ENSURE_EQ(context, input->dims->data[1],
weights_feature->dims->data[1]);
TF_LITE_ENSURE_EQ(context, weights_time->dims->data[0], num_filters);
const TfLiteTensor* bias = GetOptionalInputTensor(context, node, kBiasTensor);
if (bias) {
TF_LITE_ENSURE_EQ(context, bias->dims->data[0], num_units);
}
const TfLiteTensor* state;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kStateTensor, &state));
TfLiteTensor* output;
TF_LITE_ENSURE_OK(context,
GetOutputSafe(context, node, kOutputTensor, &output));
TF_LITE_ENSURE_EQ(context, NumDimensions(state), 2);
TF_LITE_ENSURE_EQ(context, SizeOfDimension(state, 0), batch_size);
TF_LITE_ENSURE_EQ(context, SizeOfDimension(state, 1),
memory_size * num_filters);
TfLiteIntArray* output_size_array = TfLiteIntArrayCreate(2);
output_size_array->data[0] = batch_size;
output_size_array->data[1] = num_units;
TF_LITE_ENSURE_OK(context,
context->ResizeTensor(context, output, output_size_array));
const bool is_hybrid_op = IsHybridOp(input, weights_feature);
const bool is_full_integer = input->type == kTfLiteInt8;
TfLiteIntArrayFree(node->temporaries);
if (is_hybrid_op) {
node->temporaries = TfLiteIntArrayCreate(6);
} else if (is_full_integer) {
node->temporaries = TfLiteIntArrayCreate(2);
} else {
node->temporaries = TfLiteIntArrayCreate(1);
}
node->temporaries->data[0] = scratch_tensor_index;
TfLiteIntArray* scratch_size_array = TfLiteIntArrayCreate(2);
scratch_size_array->data[0] = batch_size;
scratch_size_array->data[1] = num_filters;
TfLiteTensor* scratch_tensor;
TF_LITE_ENSURE_OK(
context, GetTemporarySafe(context, node, 0, &scratch_tensor));
if (is_full_integer) {
scratch_tensor->type = kTfLiteInt32;
} else {
scratch_tensor->type = kTfLiteFloat32;
}
scratch_tensor->allocation_type = kTfLiteArenaRw;
TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scratch_tensor,
scratch_size_array));
if (is_hybrid_op) {
op_data->compute_row_sums = true;
node->temporaries->data[1] = scratch_tensor_index + 1;
TfLiteTensor* input_quantized;
TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, 1,
&input_quantized));
input_quantized->type = weights_feature->type;
input_quantized->allocation_type = kTfLiteArenaRw;
if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {
TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);
TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,
input_quantized_size));
}
node->temporaries->data[2] = scratch_tensor_index + 2;
TfLiteTensor* scaling_factors;
TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, 2,
&scaling_factors));
scaling_factors->type = kTfLiteFloat32;
scaling_factors->allocation_type = kTfLiteArenaRw;
int scaling_dims[1] = {batch_size};
if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {
TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);
scaling_factors_size->data[0] = batch_size;
TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,
scaling_factors_size));
}
node->temporaries->data[3] = scratch_tensor_index + 3;
TfLiteTensor* float_weights_time;
TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, 3,
&float_weights_time));
float_weights_time->type = kTfLiteFloat32;
float_weights_time->allocation_type = kTfLiteArenaRwPersistent;
if (!TfLiteIntArrayEqual(float_weights_time->dims, weights_time->dims)) {
TfLiteIntArray* float_weights_time_size =
TfLiteIntArrayCopy(weights_time->dims);
TF_LITE_ENSURE_OK(context,
context->ResizeTensor(context, float_weights_time,
float_weights_time_size));
}
node->temporaries->data[4] = scratch_tensor_index + 4;
TfLiteTensor* zero_points;
TF_LITE_ENSURE_OK(
context, GetTemporarySafe(context, node, 4, &zero_points));
zero_points->type = kTfLiteFloat32;
zero_points->allocation_type = kTfLiteArenaRw;
int zero_points_dims[1] = {batch_size};
if (!TfLiteIntArrayEqualsArray(zero_points->dims, 1, zero_points_dims)) {
TfLiteIntArray* zero_points_size = TfLiteIntArrayCreate(1);
zero_points_size->data[0] = zero_points_dims[0];
TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, zero_points,
zero_points_size));
}
node->temporaries->data[5] = scratch_tensor_index + 5;
TfLiteTensor* row_sums;
TF_LITE_ENSURE_OK(context,
GetTemporarySafe(context, node, 5, &row_sums));
row_sums->type = kTfLiteFloat32;
row_sums->allocation_type = kTfLiteArenaRwPersistent;
int row_sums_dims[1] = {num_filters};
if (!TfLiteIntArrayEqualsArray(row_sums->dims, 1, row_sums_dims)) {
TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(1);
row_sums_size->data[0] = row_sums_dims[0];
TF_LITE_ENSURE_OK(
context, context->ResizeTensor(context, row_sums, row_sums_size));
}
}
if (is_full_integer) {
TfLiteIntArray* output_temp_size_array = TfLiteIntArrayCreate(2);
output_temp_size_array->data[0] = num_units;
output_temp_size_array->data[1] = batch_size;
node->temporaries->data[1] = scratch_tensor_index + 1;
TfLiteTensor* output_temp;
TF_LITE_ENSURE_OK(
context, GetTemporarySafe(context, node, 1, &output_temp));
output_temp->type = kTfLiteInt32;
output_temp->allocation_type = kTfLiteArenaRw;
TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, output_temp,
output_temp_size_array));
auto* input_params =
reinterpret_cast<TfLiteAffineQuantization*>(input->quantization.params);
auto* weights_feature_params = reinterpret_cast<TfLiteAffineQuantization*>(
weights_feature->quantization.params);
auto* state_params =
reinterpret_cast<TfLiteAffineQuantization*>(state->quantization.params);
auto* weight_time_params = reinterpret_cast<TfLiteAffineQuantization*>(
weights_time->quantization.params);
auto* output_params = reinterpret_cast<TfLiteAffineQuantization*>(
output->quantization.params);
const double effective_scale_1 = input_params->scale->data[0] *
weights_feature_params->scale->data[0] /
state_params->scale->data[0];
const double effective_scale_2 = state_params->scale->data[0] *
weight_time_params->scale->data[0] /
output_params->scale->data[0];
QuantizeMultiplier(effective_scale_1, &op_data->effective_scale_1_a,
&op_data->effective_scale_1_b);
QuantizeMultiplier(effective_scale_2, &op_data->effective_scale_2_a,
&op_data->effective_scale_2_b);
}
return kTfLiteOk;
}","TfLiteStatus Prepare(TfLiteContext* VAR_0, TfLiteNode* VAR_1) {
const auto* VAR_2 = VAR_3<TfLiteSVDFParams*>(VAR_1->builtin_data);
OpData* VAR_4 = VAR_3<OpData*>(VAR_1->user_data);
int VAR_5 = VAR_4->scratch_tensor_index;
TF_LITE_ENSURE_EQ(VAR_0, VAR_1->outputs->size, 1);
TF_LITE_ENSURE_EQ(VAR_0, VAR_1->inputs->size, 5);
const TfLiteTensor* VAR_6;
TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_7, &VAR_6));
const TfLiteTensor* VAR_8;
TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_9,
&VAR_8));
const TfLiteTensor* VAR_10;
TF_LITE_ENSURE_OK(
VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_11, &VAR_10));
TF_LITE_ENSURE(VAR_0,
VAR_6->type == VAR_12 || VAR_6->type == VAR_13);
const int VAR_14 = VAR_2->rank;
const int VAR_15 = VAR_6->dims->data[0];
const int VAR_16 = VAR_8->dims->data[0];
TF_LITE_ENSURE(VAR_0, VAR_14 != 0);
TF_LITE_ENSURE_EQ(VAR_0, VAR_16 % VAR_14, 0);
const int VAR_17 = VAR_16 / VAR_14;
const int VAR_18 = VAR_10->dims->data[1];
TF_LITE_ENSURE_EQ(VAR_0, VAR_6->dims->data[1],
VAR_8->dims->data[1]);
TF_LITE_ENSURE_EQ(VAR_0, VAR_10->dims->data[0], VAR_16);
const TfLiteTensor* VAR_19 = GetOptionalInputTensor(VAR_0, VAR_1, VAR_20);
if (VAR_19) {
TF_LITE_ENSURE_EQ(VAR_0, VAR_19->dims->data[0], VAR_17);
}
const TfLiteTensor* VAR_21;
TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_22, &VAR_21));
TfLiteTensor* VAR_23;
TF_LITE_ENSURE_OK(VAR_0,
GetOutputSafe(VAR_0, VAR_1, VAR_24, &VAR_23));
TF_LITE_ENSURE_EQ(VAR_0, NumDimensions(VAR_21), 2);
TF_LITE_ENSURE_EQ(VAR_0, SizeOfDimension(VAR_21, 0), VAR_15);
TF_LITE_ENSURE_EQ(VAR_0, SizeOfDimension(VAR_21, 1),
VAR_18 * VAR_16);
TfLiteIntArray* VAR_25 = TfLiteIntArrayCreate(2);
VAR_25->data[0] = VAR_15;
VAR_25->data[1] = VAR_17;
TF_LITE_ENSURE_OK(VAR_0,
VAR_0->ResizeTensor(VAR_0, VAR_23, VAR_25));
const bool VAR_26 = IsHybridOp(VAR_6, VAR_8);
const bool VAR_27 = VAR_6->type == VAR_13;
TfLiteIntArrayFree(VAR_1->temporaries);
if (VAR_26) {
VAR_1->temporaries = TfLiteIntArrayCreate(6);
} else if (VAR_27) {
VAR_1->temporaries = TfLiteIntArrayCreate(2);
} else {
VAR_1->temporaries = TfLiteIntArrayCreate(1);
}
VAR_1->temporaries->data[0] = VAR_5;
TfLiteIntArray* VAR_28 = TfLiteIntArrayCreate(2);
VAR_28->data[0] = VAR_15;
VAR_28->data[1] = VAR_16;
TfLiteTensor* VAR_29;
TF_LITE_ENSURE_OK(
VAR_0, GetTemporarySafe(VAR_0, VAR_1, 0, &VAR_29));
if (VAR_27) {
VAR_29->type = VAR_30;
} else {
VAR_29->type = VAR_12;
}
VAR_29->allocation_type = VAR_31;
TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_29,
VAR_28));
if (VAR_26) {
VAR_4->compute_row_sums = true;
VAR_1->temporaries->data[1] = VAR_5 + 1;
TfLiteTensor* VAR_32;
TF_LITE_ENSURE_OK(VAR_0, GetTemporarySafe(VAR_0, VAR_1, 1,
&VAR_32));
VAR_32->type = VAR_8->type;
VAR_32->allocation_type = VAR_31;
if (!TfLiteIntArrayEqual(VAR_32->dims, VAR_6->dims)) {
TfLiteIntArray* VAR_33 = TfLiteIntArrayCopy(VAR_6->dims);
TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_32,
VAR_33));
}
VAR_1->temporaries->data[2] = VAR_5 + 2;
TfLiteTensor* VAR_34;
TF_LITE_ENSURE_OK(VAR_0, GetTemporarySafe(VAR_0, VAR_1, 2,
&VAR_34));
VAR_34->type = VAR_12;
VAR_34->allocation_type = VAR_31;
int VAR_35[1] = {VAR_15};
if (!TfLiteIntArrayEqualsArray(VAR_34->dims, 1, VAR_35)) {
TfLiteIntArray* VAR_36 = TfLiteIntArrayCreate(1);
VAR_36->data[0] = VAR_15;
TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_34,
VAR_36));
}
VAR_1->temporaries->data[3] = VAR_5 + 3;
TfLiteTensor* VAR_37;
TF_LITE_ENSURE_OK(VAR_0, GetTemporarySafe(VAR_0, VAR_1, 3,
&VAR_37));
VAR_37->type = VAR_12;
VAR_37->allocation_type = VAR_38;
if (!TfLiteIntArrayEqual(VAR_37->dims, VAR_10->dims)) {
TfLiteIntArray* VAR_39 =
TfLiteIntArrayCopy(VAR_10->dims);
TF_LITE_ENSURE_OK(VAR_0,
VAR_0->ResizeTensor(VAR_0, VAR_37,
VAR_39));
}
VAR_1->temporaries->data[4] = VAR_5 + 4;
TfLiteTensor* VAR_40;
TF_LITE_ENSURE_OK(
VAR_0, GetTemporarySafe(VAR_0, VAR_1, 4, &VAR_40));
VAR_40->type = VAR_12;
VAR_40->allocation_type = VAR_31;
int VAR_41[1] = {VAR_15};
if (!TfLiteIntArrayEqualsArray(VAR_40->dims, 1, VAR_41)) {
TfLiteIntArray* VAR_42 = TfLiteIntArrayCreate(1);
VAR_42->data[0] = VAR_41[0];
TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_40,
VAR_42));
}
VAR_1->temporaries->data[5] = VAR_5 + 5;
TfLiteTensor* VAR_43;
TF_LITE_ENSURE_OK(VAR_0,
GetTemporarySafe(VAR_0, VAR_1, 5, &VAR_43));
VAR_43->type = VAR_12;
VAR_43->allocation_type = VAR_38;
int VAR_44[1] = {VAR_16};
if (!TfLiteIntArrayEqualsArray(VAR_43->dims, 1, VAR_44)) {
TfLiteIntArray* VAR_45 = TfLiteIntArrayCreate(1);
VAR_45->data[0] = VAR_44[0];
TF_LITE_ENSURE_OK(
VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_43, VAR_45));
}
}
if (VAR_27) {
TfLiteIntArray* VAR_46 = TfLiteIntArrayCreate(2);
VAR_46->data[0] = VAR_17;
VAR_46->data[1] = VAR_15;
VAR_1->temporaries->data[1] = VAR_5 + 1;
TfLiteTensor* VAR_47;
TF_LITE_ENSURE_OK(
VAR_0, GetTemporarySafe(VAR_0, VAR_1, 1, &VAR_47));
VAR_47->type = VAR_30;
VAR_47->allocation_type = VAR_31;
TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_47,
VAR_46));
auto* VAR_48 =
VAR_3<TfLiteAffineQuantization*>(VAR_6->quantization.params);
auto* VAR_49 = VAR_3<TfLiteAffineQuantization*>(
VAR_8->quantization.params);
auto* VAR_50 =
VAR_3<TfLiteAffineQuantization*>(VAR_21->quantization.params);
auto* VAR_51 = VAR_3<TfLiteAffineQuantization*>(
VAR_10->quantization.params);
auto* VAR_52 = VAR_3<TfLiteAffineQuantization*>(
VAR_23->quantization.params);
const double VAR_53 = VAR_48->scale->data[0] *
VAR_49->scale->data[0] /
VAR_50->scale->data[0];
const double VAR_54 = VAR_50->scale->data[0] *
VAR_51->scale->data[0] /
VAR_52->scale->data[0];
QuantizeMultiplier(VAR_53, &VAR_4->effective_scale_1_a,
&VAR_4->effective_scale_1_b);
QuantizeMultiplier(VAR_54, &VAR_4->effective_scale_2_a,
&VAR_4->effective_scale_2_b);
}
return VAR_55;
}",tensorflow/537bc7c723439b9194a358f64d871dd326c18887/svdf.cc/vul/before/0.json,"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
  const auto* params = reinterpret_cast<TfLiteSVDFParams*>(node->builtin_data);
  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);
  int scratch_tensor_index = op_data->scratch_tensor_index;

  // Check we have all the inputs and outputs we need.
  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);
  TF_LITE_ENSURE_EQ(context, node->inputs->size, 5);

  const TfLiteTensor* input;
  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));
  const TfLiteTensor* weights_feature;
  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kWeightsFeatureTensor,
                                          &weights_feature));
  const TfLiteTensor* weights_time;
  TF_LITE_ENSURE_OK(
      context, GetInputSafe(context, node, kWeightsTimeTensor, &weights_time));

  TF_LITE_ENSURE(context,
                 input->type == kTfLiteFloat32 || input->type == kTfLiteInt8);

  // Check all the parameters of tensor match within themselves and match the
  // input configuration.
  const int rank = params->rank;
  const int batch_size = input->dims->data[0];
  const int num_filters = weights_feature->dims->data[0];
  TF_LITE_ENSURE(context, rank != 0);
  TF_LITE_ENSURE_EQ(context, num_filters % rank, 0);
  const int num_units = num_filters / rank;
  const int memory_size = weights_time->dims->data[1];
  TF_LITE_ENSURE_EQ(context, input->dims->data[1],
                    weights_feature->dims->data[1]);
  TF_LITE_ENSURE_EQ(context, weights_time->dims->data[0], num_filters);

  const TfLiteTensor* bias = GetOptionalInputTensor(context, node, kBiasTensor);
  if (bias) {
    TF_LITE_ENSURE_EQ(context, bias->dims->data[0], num_units);
  }

  const TfLiteTensor* state;
  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kStateTensor, &state));
  TfLiteTensor* output;
  TF_LITE_ENSURE_OK(context,
                    GetOutputSafe(context, node, kOutputTensor, &output));

  // Check the shape of input state tensors.
  TF_LITE_ENSURE_EQ(context, NumDimensions(state), 2);
  TF_LITE_ENSURE_EQ(context, SizeOfDimension(state, 0), batch_size);
  TF_LITE_ENSURE_EQ(context, SizeOfDimension(state, 1),
                    memory_size * num_filters);

  // Resize output.
  TfLiteIntArray* output_size_array = TfLiteIntArrayCreate(2);
  output_size_array->data[0] = batch_size;
  output_size_array->data[1] = num_units;
  TF_LITE_ENSURE_OK(context,
                    context->ResizeTensor(context, output, output_size_array));

  // The weights are of consistent type, so it suffices to check one.
  const bool is_hybrid_op = IsHybridOp(input, weights_feature);
  const bool is_full_integer = input->type == kTfLiteInt8;

  // Resize scratch.
  TfLiteIntArrayFree(node->temporaries);
  if (is_hybrid_op) {
    node->temporaries = TfLiteIntArrayCreate(6);
  } else if (is_full_integer) {
    node->temporaries = TfLiteIntArrayCreate(2);
  } else {
    node->temporaries = TfLiteIntArrayCreate(1);
  }
  node->temporaries->data[0] = scratch_tensor_index;

  TfLiteIntArray* scratch_size_array = TfLiteIntArrayCreate(2);
  scratch_size_array->data[0] = batch_size;
  scratch_size_array->data[1] = num_filters;

  TfLiteTensor* scratch_tensor;
  TF_LITE_ENSURE_OK(
      context, GetTemporarySafe(context, node, /*index=*/0, &scratch_tensor));

  // The scratch buffer is of type int32 for full integer svdf and it's of type
  // float32 for hybrid and float case.
  if (is_full_integer) {
    scratch_tensor->type = kTfLiteInt32;
  } else {
    scratch_tensor->type = kTfLiteFloat32;
  }
  scratch_tensor->allocation_type = kTfLiteArenaRw;
  TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scratch_tensor,
                                                   scratch_size_array));

  if (is_hybrid_op) {
    op_data->compute_row_sums = true;
    // Tell interpreter to allocate temporary tensors to store quantized values
    // of input tensors.
    node->temporaries->data[1] = scratch_tensor_index + 1;
    TfLiteTensor* input_quantized;
    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/1,
                                                &input_quantized));
    input_quantized->type = weights_feature->type;
    input_quantized->allocation_type = kTfLiteArenaRw;
    if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {
      TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);
      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,
                                                       input_quantized_size));
    }

    // Tell interpreter to allocate temporary tensors to store scaling factors.
    node->temporaries->data[2] = scratch_tensor_index + 2;
    TfLiteTensor* scaling_factors;
    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/2,
                                                &scaling_factors));
    scaling_factors->type = kTfLiteFloat32;
    scaling_factors->allocation_type = kTfLiteArenaRw;
    int scaling_dims[1] = {batch_size};
    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {
      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);
      scaling_factors_size->data[0] = batch_size;
      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,
                                                       scaling_factors_size));
    }

    // Used to store dequantized weights_time matrix for hybrid computation of
    // matmul(state, weights_time), which occurs in floating point.
    node->temporaries->data[3] = scratch_tensor_index + 3;
    TfLiteTensor* float_weights_time;
    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/3,
                                                &float_weights_time));
    float_weights_time->type = kTfLiteFloat32;
    // Persistent so that we can compute the dequantized weights only once.
    float_weights_time->allocation_type = kTfLiteArenaRwPersistent;
    if (!TfLiteIntArrayEqual(float_weights_time->dims, weights_time->dims)) {
      TfLiteIntArray* float_weights_time_size =
          TfLiteIntArrayCopy(weights_time->dims);
      TF_LITE_ENSURE_OK(context,
                        context->ResizeTensor(context, float_weights_time,
                                              float_weights_time_size));
    }

    node->temporaries->data[4] = scratch_tensor_index + 4;
    TfLiteTensor* zero_points;
    TF_LITE_ENSURE_OK(
        context, GetTemporarySafe(context, node, /*index=*/4, &zero_points));
    zero_points->type = kTfLiteFloat32;
    zero_points->allocation_type = kTfLiteArenaRw;
    int zero_points_dims[1] = {batch_size};
    if (!TfLiteIntArrayEqualsArray(zero_points->dims, 1, zero_points_dims)) {
      TfLiteIntArray* zero_points_size = TfLiteIntArrayCreate(1);
      zero_points_size->data[0] = zero_points_dims[0];
      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, zero_points,
                                                       zero_points_size));
    }

    node->temporaries->data[5] = scratch_tensor_index + 5;
    TfLiteTensor* row_sums;
    TF_LITE_ENSURE_OK(context,
                      GetTemporarySafe(context, node, /*index=*/5, &row_sums));
    row_sums->type = kTfLiteFloat32;
    row_sums->allocation_type = kTfLiteArenaRwPersistent;
    int row_sums_dims[1] = {num_filters};
    if (!TfLiteIntArrayEqualsArray(row_sums->dims, 1, row_sums_dims)) {
      TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(1);
      row_sums_size->data[0] = row_sums_dims[0];
      TF_LITE_ENSURE_OK(
          context, context->ResizeTensor(context, row_sums, row_sums_size));
    }
  }
  if (is_full_integer) {
    // Allocated one extra tensor.
    TfLiteIntArray* output_temp_size_array = TfLiteIntArrayCreate(2);
    output_temp_size_array->data[0] = num_units;
    output_temp_size_array->data[1] = batch_size;
    node->temporaries->data[1] = scratch_tensor_index + 1;
    TfLiteTensor* output_temp;
    TF_LITE_ENSURE_OK(
        context, GetTemporarySafe(context, node, /*index=*/1, &output_temp));
    output_temp->type = kTfLiteInt32;
    output_temp->allocation_type = kTfLiteArenaRw;
    TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, output_temp,
                                                     output_temp_size_array));

    // Calculate effective scales.
    TF_LITE_ENSURE(context, input->quantization.type != kTfLiteNoQuantization);
    auto* input_params =
        reinterpret_cast<TfLiteAffineQuantization*>(input->quantization.params);
    TF_LITE_ENSURE(context,
                   weights_feature->quantization.type != kTfLiteNoQuantization);
    auto* weights_feature_params = reinterpret_cast<TfLiteAffineQuantization*>(
        weights_feature->quantization.params);
    TF_LITE_ENSURE(context, state->quantization.type != kTfLiteNoQuantization);
    auto* state_params =
        reinterpret_cast<TfLiteAffineQuantization*>(state->quantization.params);
    TF_LITE_ENSURE(context,
                   weights_time->quantization.type != kTfLiteNoQuantization);
    auto* weight_time_params = reinterpret_cast<TfLiteAffineQuantization*>(
        weights_time->quantization.params);
    TF_LITE_ENSURE(context, output->quantization.type != kTfLiteNoQuantization);
    auto* output_params = reinterpret_cast<TfLiteAffineQuantization*>(
        output->quantization.params);
    const double effective_scale_1 = input_params->scale->data[0] *
                                     weights_feature_params->scale->data[0] /
                                     state_params->scale->data[0];
    const double effective_scale_2 = state_params->scale->data[0] *
                                     weight_time_params->scale->data[0] /
                                     output_params->scale->data[0];
    QuantizeMultiplier(effective_scale_1, &op_data->effective_scale_1_a,
                       &op_data->effective_scale_1_b);
    QuantizeMultiplier(effective_scale_2, &op_data->effective_scale_2_a,
                       &op_data->effective_scale_2_b);
  }
  return kTfLiteOk;
}","TfLiteStatus Prepare(TfLiteContext* VAR_0, TfLiteNode* VAR_1) {
  const auto* VAR_2 = VAR_3<TfLiteSVDFParams*>(VAR_1->builtin_data);
  OpData* VAR_4 = VAR_3<OpData*>(VAR_1->user_data);
  int VAR_5 = VAR_4->scratch_tensor_index;

  /* COMMENT_0 */
  TF_LITE_ENSURE_EQ(VAR_0, VAR_1->outputs->size, 1);
  TF_LITE_ENSURE_EQ(VAR_0, VAR_1->inputs->size, 5);

  const TfLiteTensor* VAR_6;
  TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_7, &VAR_6));
  const TfLiteTensor* VAR_8;
  TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_9,
                                          &VAR_8));
  const TfLiteTensor* VAR_10;
  TF_LITE_ENSURE_OK(
      VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_11, &VAR_10));

  TF_LITE_ENSURE(VAR_0,
                 VAR_6->type == VAR_12 || VAR_6->type == VAR_13);

  /* COMMENT_1 */
  /* COMMENT_2 */
  const int VAR_14 = VAR_2->rank;
  const int VAR_15 = VAR_6->dims->data[0];
  const int VAR_16 = VAR_8->dims->data[0];
  TF_LITE_ENSURE(VAR_0, VAR_14 != 0);
  TF_LITE_ENSURE_EQ(VAR_0, VAR_16 % VAR_14, 0);
  const int VAR_17 = VAR_16 / VAR_14;
  const int VAR_18 = VAR_10->dims->data[1];
  TF_LITE_ENSURE_EQ(VAR_0, VAR_6->dims->data[1],
                    VAR_8->dims->data[1]);
  TF_LITE_ENSURE_EQ(VAR_0, VAR_10->dims->data[0], VAR_16);

  const TfLiteTensor* VAR_19 = GetOptionalInputTensor(VAR_0, VAR_1, VAR_20);
  if (VAR_19) {
    TF_LITE_ENSURE_EQ(VAR_0, VAR_19->dims->data[0], VAR_17);
  }

  const TfLiteTensor* VAR_21;
  TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_22, &VAR_21));
  TfLiteTensor* VAR_23;
  TF_LITE_ENSURE_OK(VAR_0,
                    GetOutputSafe(VAR_0, VAR_1, VAR_24, &VAR_23));

  /* COMMENT_3 */
  TF_LITE_ENSURE_EQ(VAR_0, NumDimensions(VAR_21), 2);
  TF_LITE_ENSURE_EQ(VAR_0, SizeOfDimension(VAR_21, 0), VAR_15);
  TF_LITE_ENSURE_EQ(VAR_0, SizeOfDimension(VAR_21, 1),
                    VAR_18 * VAR_16);

  /* COMMENT_4 */
  TfLiteIntArray* VAR_25 = TfLiteIntArrayCreate(2);
  VAR_25->data[0] = VAR_15;
  VAR_25->data[1] = VAR_17;
  TF_LITE_ENSURE_OK(VAR_0,
                    VAR_0->ResizeTensor(VAR_0, VAR_23, VAR_25));

  /* COMMENT_5 */
  const bool VAR_26 = IsHybridOp(VAR_6, VAR_8);
  const bool VAR_27 = VAR_6->type == VAR_13;

  /* COMMENT_6 */
  TfLiteIntArrayFree(VAR_1->temporaries);
  if (VAR_26) {
    VAR_1->temporaries = TfLiteIntArrayCreate(6);
  } else if (VAR_27) {
    VAR_1->temporaries = TfLiteIntArrayCreate(2);
  } else {
    VAR_1->temporaries = TfLiteIntArrayCreate(1);
  }
  VAR_1->temporaries->data[0] = VAR_5;

  TfLiteIntArray* VAR_28 = TfLiteIntArrayCreate(2);
  VAR_28->data[0] = VAR_15;
  VAR_28->data[1] = VAR_16;

  TfLiteTensor* VAR_29;
  TF_LITE_ENSURE_OK(
      VAR_0, GetTemporarySafe(VAR_0, VAR_1, /* COMMENT_7 */0, &VAR_29));

  /* COMMENT_8 */
  /* COMMENT_9 */
  if (VAR_27) {
    VAR_29->type = VAR_30;
  } else {
    VAR_29->type = VAR_12;
  }
  VAR_29->allocation_type = VAR_31;
  TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_29,
                                                   VAR_28));

  if (VAR_26) {
    VAR_4->compute_row_sums = true;
    /* COMMENT_10 */
    /* COMMENT_11 */
    VAR_1->temporaries->data[1] = VAR_5 + 1;
    TfLiteTensor* VAR_32;
    TF_LITE_ENSURE_OK(VAR_0, GetTemporarySafe(VAR_0, VAR_1, /* COMMENT_7 */1,
                                                &VAR_32));
    VAR_32->type = VAR_8->type;
    VAR_32->allocation_type = VAR_31;
    if (!TfLiteIntArrayEqual(VAR_32->dims, VAR_6->dims)) {
      TfLiteIntArray* VAR_33 = TfLiteIntArrayCopy(VAR_6->dims);
      TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_32,
                                                       VAR_33));
    }

    /* COMMENT_12 */
    VAR_1->temporaries->data[2] = VAR_5 + 2;
    TfLiteTensor* VAR_34;
    TF_LITE_ENSURE_OK(VAR_0, GetTemporarySafe(VAR_0, VAR_1, /* COMMENT_7 */2,
                                                &VAR_34));
    VAR_34->type = VAR_12;
    VAR_34->allocation_type = VAR_31;
    int VAR_35[1] = {VAR_15};
    if (!TfLiteIntArrayEqualsArray(VAR_34->dims, 1, VAR_35)) {
      TfLiteIntArray* VAR_36 = TfLiteIntArrayCreate(1);
      VAR_36->data[0] = VAR_15;
      TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_34,
                                                       VAR_36));
    }

    /* COMMENT_13 */
    /* COMMENT_14 */
    VAR_1->temporaries->data[3] = VAR_5 + 3;
    TfLiteTensor* VAR_37;
    TF_LITE_ENSURE_OK(VAR_0, GetTemporarySafe(VAR_0, VAR_1, /* COMMENT_7 */3,
                                                &VAR_37));
    VAR_37->type = VAR_12;
    /* COMMENT_15 */
    VAR_37->allocation_type = VAR_38;
    if (!TfLiteIntArrayEqual(VAR_37->dims, VAR_10->dims)) {
      TfLiteIntArray* VAR_39 =
          TfLiteIntArrayCopy(VAR_10->dims);
      TF_LITE_ENSURE_OK(VAR_0,
                        VAR_0->ResizeTensor(VAR_0, VAR_37,
                                              VAR_39));
    }

    VAR_1->temporaries->data[4] = VAR_5 + 4;
    TfLiteTensor* VAR_40;
    TF_LITE_ENSURE_OK(
        VAR_0, GetTemporarySafe(VAR_0, VAR_1, /* COMMENT_7 */4, &VAR_40));
    VAR_40->type = VAR_12;
    VAR_40->allocation_type = VAR_31;
    int VAR_41[1] = {VAR_15};
    if (!TfLiteIntArrayEqualsArray(VAR_40->dims, 1, VAR_41)) {
      TfLiteIntArray* VAR_42 = TfLiteIntArrayCreate(1);
      VAR_42->data[0] = VAR_41[0];
      TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_40,
                                                       VAR_42));
    }

    VAR_1->temporaries->data[5] = VAR_5 + 5;
    TfLiteTensor* VAR_43;
    TF_LITE_ENSURE_OK(VAR_0,
                      GetTemporarySafe(VAR_0, VAR_1, /* COMMENT_7 */5, &VAR_43));
    VAR_43->type = VAR_12;
    VAR_43->allocation_type = VAR_38;
    int VAR_44[1] = {VAR_16};
    if (!TfLiteIntArrayEqualsArray(VAR_43->dims, 1, VAR_44)) {
      TfLiteIntArray* VAR_45 = TfLiteIntArrayCreate(1);
      VAR_45->data[0] = VAR_44[0];
      TF_LITE_ENSURE_OK(
          VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_43, VAR_45));
    }
  }
  if (VAR_27) {
    /* COMMENT_16 */
    TfLiteIntArray* VAR_46 = TfLiteIntArrayCreate(2);
    VAR_46->data[0] = VAR_17;
    VAR_46->data[1] = VAR_15;
    VAR_1->temporaries->data[1] = VAR_5 + 1;
    TfLiteTensor* VAR_47;
    TF_LITE_ENSURE_OK(
        VAR_0, GetTemporarySafe(VAR_0, VAR_1, /* COMMENT_7 */1, &VAR_47));
    VAR_47->type = VAR_30;
    VAR_47->allocation_type = VAR_31;
    TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_47,
                                                     VAR_46));

    /* COMMENT_17 */
    TF_LITE_ENSURE(VAR_0, VAR_6->quantization.type != VAR_48);
    auto* VAR_49 =
        VAR_3<TfLiteAffineQuantization*>(VAR_6->quantization.params);
    TF_LITE_ENSURE(VAR_0,
                   VAR_8->quantization.type != VAR_48);
    auto* VAR_50 = VAR_3<TfLiteAffineQuantization*>(
        VAR_8->quantization.params);
    TF_LITE_ENSURE(VAR_0, VAR_21->quantization.type != VAR_48);
    auto* VAR_51 =
        VAR_3<TfLiteAffineQuantization*>(VAR_21->quantization.params);
    TF_LITE_ENSURE(VAR_0,
                   VAR_10->quantization.type != VAR_48);
    auto* VAR_52 = VAR_3<TfLiteAffineQuantization*>(
        VAR_10->quantization.params);
    TF_LITE_ENSURE(VAR_0, VAR_23->quantization.type != VAR_48);
    auto* VAR_53 = VAR_3<TfLiteAffineQuantization*>(
        VAR_23->quantization.params);
    const double VAR_54 = VAR_49->scale->data[0] *
                                     VAR_50->scale->data[0] /
                                     VAR_51->scale->data[0];
    const double VAR_55 = VAR_51->scale->data[0] *
                                     VAR_52->scale->data[0] /
                                     VAR_53->scale->data[0];
    QuantizeMultiplier(VAR_54, &VAR_4->effective_scale_1_a,
                       &VAR_4->effective_scale_1_b);
    QuantizeMultiplier(VAR_55, &VAR_4->effective_scale_2_a,
                       &VAR_4->effective_scale_2_b);
  }
  return VAR_56;
}",tensorflow/537bc7c723439b9194a358f64d871dd326c18887/svdf.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -181,14 +181,21 @@
                                                      output_temp_size_array));
 
     // Calculate effective scales.
+    TF_LITE_ENSURE(context, input->quantization.type != kTfLiteNoQuantization);
     auto* input_params =
         reinterpret_cast<TfLiteAffineQuantization*>(input->quantization.params);
+    TF_LITE_ENSURE(context,
+                   weights_feature->quantization.type != kTfLiteNoQuantization);
     auto* weights_feature_params = reinterpret_cast<TfLiteAffineQuantization*>(
         weights_feature->quantization.params);
+    TF_LITE_ENSURE(context, state->quantization.type != kTfLiteNoQuantization);
     auto* state_params =
         reinterpret_cast<TfLiteAffineQuantization*>(state->quantization.params);
+    TF_LITE_ENSURE(context,
+                   weights_time->quantization.type != kTfLiteNoQuantization);
     auto* weight_time_params = reinterpret_cast<TfLiteAffineQuantization*>(
         weights_time->quantization.params);
+    TF_LITE_ENSURE(context, output->quantization.type != kTfLiteNoQuantization);
     auto* output_params = reinterpret_cast<TfLiteAffineQuantization*>(
         output->quantization.params);
     const double effective_scale_1 = input_params->scale->data[0] *","{'deleted_lines': [], 'added_lines': ['    TF_LITE_ENSURE(context, input->quantization.type != kTfLiteNoQuantization);', '    TF_LITE_ENSURE(context,', '                   weights_feature->quantization.type != kTfLiteNoQuantization);', '    TF_LITE_ENSURE(context, state->quantization.type != kTfLiteNoQuantization);', '    TF_LITE_ENSURE(context,', '                   weights_time->quantization.type != kTfLiteNoQuantization);', '    TF_LITE_ENSURE(context, output->quantization.type != kTfLiteNoQuantization);']}",True,"TensorFlow is an end-to-end open source platform for machine learning. In affected versions all TFLite operations that use quantization can be made to use unitialized values. [For example](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/depthwise_conv.cc#L198-L200). The issue stems from the fact that `quantization.params` is only valid if `quantization.type` is different that `kTfLiteNoQuantization`. However, these checks are missing in large parts of the code. We have patched the issue in GitHub commits 537bc7c723439b9194a358f64d871dd326c18887, 4a91f2069f7145aab6ba2d8cfe41be8a110c18a5 and 8933b8a21280696ab119b63263babdb54c298538. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",4.4,MEDIUM,1,valid,2021-07-16T16:35:48Z,3
CVE-2021-37682,['CWE-908'],AV:L/AC:L/Au:N/C:N/I:P/A:P,0,tensorflow,"Fix a null pointer exception caused by branching on uninitialized data.

This is due to not checking that the params for the quantization exists. If there is no quantization, we should not access the `.params` field.

PiperOrigin-RevId: 385168337
Change-Id: I28661e4f12ba1c92cfeae23d22a3fb2df2a2c6a4",4a91f2069f7145aab6ba2d8cfe41be8a110c18a5,https://github.com/tensorflow/tensorflow/commit/4a91f2069f7145aab6ba2d8cfe41be8a110c18a5,tensorflow/lite/kernels/unidirectional_sequence_lstm.cc,PopulatePrecomputedZPTimesWeightsWithBias,"TfLiteStatus PopulatePrecomputedZPTimesWeightsWithBias(TfLiteContext* context,
OpData* op_data,
TfLiteNode* node) {
const TfLiteTensor* input;
TF_LITE_ENSURE_OK(
context, GetInputSafe(context, node, lstm::full::kInputTensor, &input));
const TfLiteTensor* output_state =
GetVariableInput(context, node, lstm::full::kOutputStateTensor);
TF_LITE_ENSURE(context, output_state != nullptr);
const int32_t input_zero_point = -input->params.zero_point;
const int32_t output_state_zero_point = -output_state->params.zero_point;
const TfLiteTensor* input_to_input_weights = GetOptionalInputTensor(
context, node, lstm::full::kInputToInputWeightsTensor);
const TfLiteTensor* input_to_forget_weights;
TF_LITE_ENSURE_OK(
context,
GetInputSafe(context, node, lstm::full::kInputToForgetWeightsTensor,
&input_to_forget_weights));
const TfLiteTensor* input_to_cell_weights;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node,
lstm::full::kInputToCellWeightsTensor,
&input_to_cell_weights));
const TfLiteTensor* input_to_output_weights;
TF_LITE_ENSURE_OK(
context,
GetInputSafe(context, node, lstm::full::kInputToOutputWeightsTensor,
&input_to_output_weights));
const TfLiteTensor* recurrent_to_input_weights = GetOptionalInputTensor(
context, node, lstm::full::kRecurrentToInputWeightsTensor);
const TfLiteTensor* recurrent_to_forget_weights;
TF_LITE_ENSURE_OK(
context,
GetInputSafe(context, node, lstm::full::kRecurrentToForgetWeightsTensor,
&recurrent_to_forget_weights));
const TfLiteTensor* recurrent_to_cell_weights;
TF_LITE_ENSURE_OK(
context,
GetInputSafe(context, node, lstm::full::kRecurrentToCellWeightsTensor,
&recurrent_to_cell_weights));
const TfLiteTensor* recurrent_to_output_weights;
TF_LITE_ENSURE_OK(
context,
GetInputSafe(context, node, lstm::full::kRecurrentToOutputWeightsTensor,
&recurrent_to_output_weights));
const TfLiteTensor* projection_weights = GetOptionalInputTensor(
context, node, lstm::full::kProjectionWeightsTensor);
const TfLiteTensor* projection_bias =
GetOptionalInputTensor(context, node, lstm::full::kProjectionBiasTensor);
lstm_eval::IntegerLstmParameter* integer_lstm_params =
&op_data->integer_lstm_param;
const TfLiteTensor* intermediate =
&context->tensors[node->intermediates->data[4]];
const auto* params =
static_cast<TfLiteAffineQuantization*>(intermediate->quantization.params);
const int32_t hidden_zp = params->zero_point->data[0];
const bool is_layer_norm = op_data->use_layer_norm;
const TfLiteTensor* forget_gate_bias =
is_layer_norm
? nullptr
: GetInput(context, node, lstm::full::kForgetGateBiasTensor);
TF_LITE_ENSURE_OK(
context,
PrecomputeZeroPointTimesWeightWithBias(
context, input_zero_point, input_to_forget_weights, forget_gate_bias,
&(integer_lstm_params->input_to_forget_effective_bias)));
TF_LITE_ENSURE_OK(
context,
PrecomputeZeroPointTimesWeightWithBias(
context, output_state_zero_point, recurrent_to_forget_weights,
nullptr, &(integer_lstm_params->recurrent_to_forget_effective_bias)));
const TfLiteTensor* cell_gate_bias =
is_layer_norm ? nullptr
: GetInput(context, node, lstm::full::kCellGateBiasTensor);
TF_LITE_ENSURE_OK(
context,
PrecomputeZeroPointTimesWeightWithBias(
context, input_zero_point, input_to_cell_weights, cell_gate_bias,
&(integer_lstm_params->input_to_cell_effective_bias)));
TF_LITE_ENSURE_OK(
context,
PrecomputeZeroPointTimesWeightWithBias(
context, output_state_zero_point, recurrent_to_cell_weights, nullptr,
&(integer_lstm_params->recurrent_to_cell_effective_bias)));
const TfLiteTensor* output_gate_bias =
is_layer_norm
? nullptr
: GetInput(context, node, lstm::full::kOutputGateBiasTensor);
TF_LITE_ENSURE_OK(
context,
PrecomputeZeroPointTimesWeightWithBias(
context, input_zero_point, input_to_output_weights, output_gate_bias,
&(integer_lstm_params->input_to_output_effective_bias)));
TF_LITE_ENSURE_OK(
context,
PrecomputeZeroPointTimesWeightWithBias(
context, output_state_zero_point, recurrent_to_output_weights,
nullptr, &(integer_lstm_params->recurrent_to_output_effective_bias)));
const TfLiteTensor* input_gate_bias =
is_layer_norm ? nullptr
: GetInput(context, node, lstm::full::kInputGateBiasTensor);
TF_LITE_ENSURE_OK(
context,
PrecomputeZeroPointTimesWeightWithBias(
context, input_zero_point, input_to_input_weights, input_gate_bias,
&(integer_lstm_params->input_to_input_effective_bias)));
TF_LITE_ENSURE_OK(
context,
PrecomputeZeroPointTimesWeightWithBias(
context, output_state_zero_point, recurrent_to_input_weights, nullptr,
&(integer_lstm_params->recurrent_to_input_effective_bias)));
TF_LITE_ENSURE_OK(context,
PrecomputeZeroPointTimesWeightWithBias(
context, hidden_zp, projection_weights, projection_bias,
&(integer_lstm_params->projection_effective_bias)));
return kTfLiteOk;
}","TfLiteStatus PopulatePrecomputedZPTimesWeightsWithBias(TfLiteContext* VAR_0,
OpData* VAR_1,
TfLiteNode* VAR_2) {
const TfLiteTensor* VAR_3;
TF_LITE_ENSURE_OK(
VAR_0, GetInputSafe(VAR_0, VAR_2, lstm::full::kInputTensor, &VAR_3));
const TfLiteTensor* VAR_4 =
GetVariableInput(VAR_0, VAR_2, lstm::full::kOutputStateTensor);
TF_LITE_ENSURE(VAR_0, VAR_4 != nullptr);
const int32_t VAR_5 = -VAR_3->params.zero_point;
const int32_t VAR_6 = -VAR_4->params.zero_point;
const TfLiteTensor* VAR_7 = GetOptionalInputTensor(
VAR_0, VAR_2, lstm::full::kInputToInputWeightsTensor);
const TfLiteTensor* VAR_8;
TF_LITE_ENSURE_OK(
VAR_0,
GetInputSafe(VAR_0, VAR_2, lstm::full::kInputToForgetWeightsTensor,
&VAR_8));
const TfLiteTensor* VAR_9;
TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_2,
lstm::full::kInputToCellWeightsTensor,
&VAR_9));
const TfLiteTensor* VAR_10;
TF_LITE_ENSURE_OK(
VAR_0,
GetInputSafe(VAR_0, VAR_2, lstm::full::kInputToOutputWeightsTensor,
&VAR_10));
const TfLiteTensor* VAR_11 = GetOptionalInputTensor(
VAR_0, VAR_2, lstm::full::kRecurrentToInputWeightsTensor);
const TfLiteTensor* VAR_12;
TF_LITE_ENSURE_OK(
VAR_0,
GetInputSafe(VAR_0, VAR_2, lstm::full::kRecurrentToForgetWeightsTensor,
&VAR_12));
const TfLiteTensor* VAR_13;
TF_LITE_ENSURE_OK(
VAR_0,
GetInputSafe(VAR_0, VAR_2, lstm::full::kRecurrentToCellWeightsTensor,
&VAR_13));
const TfLiteTensor* VAR_14;
TF_LITE_ENSURE_OK(
VAR_0,
GetInputSafe(VAR_0, VAR_2, lstm::full::kRecurrentToOutputWeightsTensor,
&VAR_14));
const TfLiteTensor* VAR_15 = GetOptionalInputTensor(
VAR_0, VAR_2, lstm::full::kProjectionWeightsTensor);
const TfLiteTensor* VAR_16 =
GetOptionalInputTensor(VAR_0, VAR_2, lstm::full::kProjectionBiasTensor);
lstm_eval::IntegerLstmParameter* VAR_17 =
&VAR_1->integer_lstm_param;
const TfLiteTensor* VAR_18 =
&VAR_0->tensors[VAR_2->intermediates->data[4]];
const auto* VAR_19 =
VAR_20<TfLiteAffineQuantization*>(VAR_18->quantization.params);
const int32_t VAR_21 = VAR_19->zero_point->data[0];
const bool VAR_22 = VAR_1->use_layer_norm;
const TfLiteTensor* VAR_23 =
VAR_22
? nullptr
: GetInput(VAR_0, VAR_2, lstm::full::kForgetGateBiasTensor);
TF_LITE_ENSURE_OK(
VAR_0,
PrecomputeZeroPointTimesWeightWithBias(
VAR_0, VAR_5, VAR_8, VAR_23,
&(VAR_17->input_to_forget_effective_bias)));
TF_LITE_ENSURE_OK(
VAR_0,
PrecomputeZeroPointTimesWeightWithBias(
VAR_0, VAR_6, VAR_12,
nullptr, &(VAR_17->recurrent_to_forget_effective_bias)));
const TfLiteTensor* VAR_24 =
VAR_22 ? nullptr
: GetInput(VAR_0, VAR_2, lstm::full::kCellGateBiasTensor);
TF_LITE_ENSURE_OK(
VAR_0,
PrecomputeZeroPointTimesWeightWithBias(
VAR_0, VAR_5, VAR_9, VAR_24,
&(VAR_17->input_to_cell_effective_bias)));
TF_LITE_ENSURE_OK(
VAR_0,
PrecomputeZeroPointTimesWeightWithBias(
VAR_0, VAR_6, VAR_13, nullptr,
&(VAR_17->recurrent_to_cell_effective_bias)));
const TfLiteTensor* VAR_25 =
VAR_22
? nullptr
: GetInput(VAR_0, VAR_2, lstm::full::kOutputGateBiasTensor);
TF_LITE_ENSURE_OK(
VAR_0,
PrecomputeZeroPointTimesWeightWithBias(
VAR_0, VAR_5, VAR_10, VAR_25,
&(VAR_17->input_to_output_effective_bias)));
TF_LITE_ENSURE_OK(
VAR_0,
PrecomputeZeroPointTimesWeightWithBias(
VAR_0, VAR_6, VAR_14,
nullptr, &(VAR_17->recurrent_to_output_effective_bias)));
const TfLiteTensor* VAR_26 =
VAR_22 ? nullptr
: GetInput(VAR_0, VAR_2, lstm::full::kInputGateBiasTensor);
TF_LITE_ENSURE_OK(
VAR_0,
PrecomputeZeroPointTimesWeightWithBias(
VAR_0, VAR_5, VAR_7, VAR_26,
&(VAR_17->input_to_input_effective_bias)));
TF_LITE_ENSURE_OK(
VAR_0,
PrecomputeZeroPointTimesWeightWithBias(
VAR_0, VAR_6, VAR_11, nullptr,
&(VAR_17->recurrent_to_input_effective_bias)));
TF_LITE_ENSURE_OK(VAR_0,
PrecomputeZeroPointTimesWeightWithBias(
VAR_0, VAR_21, VAR_15, VAR_16,
&(VAR_17->projection_effective_bias)));
return VAR_27;
}",tensorflow/4a91f2069f7145aab6ba2d8cfe41be8a110c18a5/unidirectional_sequence_lstm.cc/vul/before/0.json,"TfLiteStatus PopulatePrecomputedZPTimesWeightsWithBias(TfLiteContext* context,
                                                       OpData* op_data,
                                                       TfLiteNode* node) {
  const TfLiteTensor* input;
  TF_LITE_ENSURE_OK(
      context, GetInputSafe(context, node, lstm::full::kInputTensor, &input));
  const TfLiteTensor* output_state =
      GetVariableInput(context, node, lstm::full::kOutputStateTensor);
  TF_LITE_ENSURE(context, output_state != nullptr);

  const int32_t input_zero_point = -input->params.zero_point;
  const int32_t output_state_zero_point = -output_state->params.zero_point;

  const TfLiteTensor* input_to_input_weights = GetOptionalInputTensor(
      context, node, lstm::full::kInputToInputWeightsTensor);
  const TfLiteTensor* input_to_forget_weights;
  TF_LITE_ENSURE_OK(
      context,
      GetInputSafe(context, node, lstm::full::kInputToForgetWeightsTensor,
                   &input_to_forget_weights));
  const TfLiteTensor* input_to_cell_weights;
  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node,
                                          lstm::full::kInputToCellWeightsTensor,
                                          &input_to_cell_weights));
  const TfLiteTensor* input_to_output_weights;
  TF_LITE_ENSURE_OK(
      context,
      GetInputSafe(context, node, lstm::full::kInputToOutputWeightsTensor,
                   &input_to_output_weights));

  const TfLiteTensor* recurrent_to_input_weights = GetOptionalInputTensor(
      context, node, lstm::full::kRecurrentToInputWeightsTensor);
  const TfLiteTensor* recurrent_to_forget_weights;
  TF_LITE_ENSURE_OK(
      context,
      GetInputSafe(context, node, lstm::full::kRecurrentToForgetWeightsTensor,
                   &recurrent_to_forget_weights));
  const TfLiteTensor* recurrent_to_cell_weights;
  TF_LITE_ENSURE_OK(
      context,
      GetInputSafe(context, node, lstm::full::kRecurrentToCellWeightsTensor,
                   &recurrent_to_cell_weights));
  const TfLiteTensor* recurrent_to_output_weights;
  TF_LITE_ENSURE_OK(
      context,
      GetInputSafe(context, node, lstm::full::kRecurrentToOutputWeightsTensor,
                   &recurrent_to_output_weights));

  const TfLiteTensor* projection_weights = GetOptionalInputTensor(
      context, node, lstm::full::kProjectionWeightsTensor);
  const TfLiteTensor* projection_bias =
      GetOptionalInputTensor(context, node, lstm::full::kProjectionBiasTensor);

  lstm_eval::IntegerLstmParameter* integer_lstm_params =
      &op_data->integer_lstm_param;

  const TfLiteTensor* intermediate =
      &context->tensors[node->intermediates->data[4]];
  TF_LITE_ENSURE(context,
                 intermediate->quantization.type != kTfLiteNoQuantization);
  const auto* params =
      static_cast<TfLiteAffineQuantization*>(intermediate->quantization.params);
  const int32_t hidden_zp = params->zero_point->data[0];

  // Get bias and perform zero point calculation.
  // When there is layer normalization, the gate bias does not apply to matmul
  // directly:
  //      y = ln(w * x + w * r + w * c) + b.
  const bool is_layer_norm = op_data->use_layer_norm;

  // Forget gate.
  const TfLiteTensor* forget_gate_bias =
      is_layer_norm
          ? nullptr
          : GetInput(context, node, lstm::full::kForgetGateBiasTensor);
  TF_LITE_ENSURE_OK(
      context,
      PrecomputeZeroPointTimesWeightWithBias(
          context, input_zero_point, input_to_forget_weights, forget_gate_bias,
          &(integer_lstm_params->input_to_forget_effective_bias)));

  TF_LITE_ENSURE_OK(
      context,
      PrecomputeZeroPointTimesWeightWithBias(
          context, output_state_zero_point, recurrent_to_forget_weights,
          nullptr, &(integer_lstm_params->recurrent_to_forget_effective_bias)));

  // Modulation gate.
  const TfLiteTensor* cell_gate_bias =
      is_layer_norm ? nullptr
                    : GetInput(context, node, lstm::full::kCellGateBiasTensor);
  TF_LITE_ENSURE_OK(
      context,
      PrecomputeZeroPointTimesWeightWithBias(
          context, input_zero_point, input_to_cell_weights, cell_gate_bias,
          &(integer_lstm_params->input_to_cell_effective_bias)));
  TF_LITE_ENSURE_OK(
      context,
      PrecomputeZeroPointTimesWeightWithBias(
          context, output_state_zero_point, recurrent_to_cell_weights, nullptr,
          &(integer_lstm_params->recurrent_to_cell_effective_bias)));

  // Output gate.
  const TfLiteTensor* output_gate_bias =
      is_layer_norm
          ? nullptr
          : GetInput(context, node, lstm::full::kOutputGateBiasTensor);
  TF_LITE_ENSURE_OK(
      context,
      PrecomputeZeroPointTimesWeightWithBias(
          context, input_zero_point, input_to_output_weights, output_gate_bias,
          &(integer_lstm_params->input_to_output_effective_bias)));

  TF_LITE_ENSURE_OK(
      context,
      PrecomputeZeroPointTimesWeightWithBias(
          context, output_state_zero_point, recurrent_to_output_weights,
          nullptr, &(integer_lstm_params->recurrent_to_output_effective_bias)));

  // Input gate. The calculation is only meaningful for non-cifg case.
  const TfLiteTensor* input_gate_bias =
      is_layer_norm ? nullptr
                    : GetInput(context, node, lstm::full::kInputGateBiasTensor);
  TF_LITE_ENSURE_OK(
      context,
      PrecomputeZeroPointTimesWeightWithBias(
          context, input_zero_point, input_to_input_weights, input_gate_bias,
          &(integer_lstm_params->input_to_input_effective_bias)));
  TF_LITE_ENSURE_OK(
      context,
      PrecomputeZeroPointTimesWeightWithBias(
          context, output_state_zero_point, recurrent_to_input_weights, nullptr,
          &(integer_lstm_params->recurrent_to_input_effective_bias)));

  // Projection bias. The calculation is only meaningful for with projection.
  TF_LITE_ENSURE_OK(context,
                    PrecomputeZeroPointTimesWeightWithBias(
                        context, hidden_zp, projection_weights, projection_bias,
                        &(integer_lstm_params->projection_effective_bias)));
  return kTfLiteOk;
}","TfLiteStatus PopulatePrecomputedZPTimesWeightsWithBias(TfLiteContext* VAR_0,
                                                       OpData* VAR_1,
                                                       TfLiteNode* VAR_2) {
  const TfLiteTensor* VAR_3;
  TF_LITE_ENSURE_OK(
      VAR_0, GetInputSafe(VAR_0, VAR_2, lstm::full::kInputTensor, &VAR_3));
  const TfLiteTensor* VAR_4 =
      GetVariableInput(VAR_0, VAR_2, lstm::full::kOutputStateTensor);
  TF_LITE_ENSURE(VAR_0, VAR_4 != nullptr);

  const int32_t VAR_5 = -VAR_3->params.zero_point;
  const int32_t VAR_6 = -VAR_4->params.zero_point;

  const TfLiteTensor* VAR_7 = GetOptionalInputTensor(
      VAR_0, VAR_2, lstm::full::kInputToInputWeightsTensor);
  const TfLiteTensor* VAR_8;
  TF_LITE_ENSURE_OK(
      VAR_0,
      GetInputSafe(VAR_0, VAR_2, lstm::full::kInputToForgetWeightsTensor,
                   &VAR_8));
  const TfLiteTensor* VAR_9;
  TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_2,
                                          lstm::full::kInputToCellWeightsTensor,
                                          &VAR_9));
  const TfLiteTensor* VAR_10;
  TF_LITE_ENSURE_OK(
      VAR_0,
      GetInputSafe(VAR_0, VAR_2, lstm::full::kInputToOutputWeightsTensor,
                   &VAR_10));

  const TfLiteTensor* VAR_11 = GetOptionalInputTensor(
      VAR_0, VAR_2, lstm::full::kRecurrentToInputWeightsTensor);
  const TfLiteTensor* VAR_12;
  TF_LITE_ENSURE_OK(
      VAR_0,
      GetInputSafe(VAR_0, VAR_2, lstm::full::kRecurrentToForgetWeightsTensor,
                   &VAR_12));
  const TfLiteTensor* VAR_13;
  TF_LITE_ENSURE_OK(
      VAR_0,
      GetInputSafe(VAR_0, VAR_2, lstm::full::kRecurrentToCellWeightsTensor,
                   &VAR_13));
  const TfLiteTensor* VAR_14;
  TF_LITE_ENSURE_OK(
      VAR_0,
      GetInputSafe(VAR_0, VAR_2, lstm::full::kRecurrentToOutputWeightsTensor,
                   &VAR_14));

  const TfLiteTensor* VAR_15 = GetOptionalInputTensor(
      VAR_0, VAR_2, lstm::full::kProjectionWeightsTensor);
  const TfLiteTensor* VAR_16 =
      GetOptionalInputTensor(VAR_0, VAR_2, lstm::full::kProjectionBiasTensor);

  lstm_eval::IntegerLstmParameter* VAR_17 =
      &VAR_1->integer_lstm_param;

  const TfLiteTensor* VAR_18 =
      &VAR_0->tensors[VAR_2->intermediates->data[4]];
  TF_LITE_ENSURE(VAR_0,
                 VAR_18->quantization.type != VAR_19);
  const auto* VAR_20 =
      VAR_21<TfLiteAffineQuantization*>(VAR_18->quantization.params);
  const int32_t VAR_22 = VAR_20->zero_point->data[0];

  /* COMMENT_0 */
  /* COMMENT_1 */
  /* COMMENT_2 */
  /* COMMENT_3 */
  const bool VAR_23 = VAR_1->use_layer_norm;

  /* COMMENT_4 */
  const TfLiteTensor* VAR_24 =
      VAR_23
          ? nullptr
          : GetInput(VAR_0, VAR_2, lstm::full::kForgetGateBiasTensor);
  TF_LITE_ENSURE_OK(
      VAR_0,
      PrecomputeZeroPointTimesWeightWithBias(
          VAR_0, VAR_5, VAR_8, VAR_24,
          &(VAR_17->input_to_forget_effective_bias)));

  TF_LITE_ENSURE_OK(
      VAR_0,
      PrecomputeZeroPointTimesWeightWithBias(
          VAR_0, VAR_6, VAR_12,
          nullptr, &(VAR_17->recurrent_to_forget_effective_bias)));

  /* COMMENT_5 */
  const TfLiteTensor* VAR_25 =
      VAR_23 ? nullptr
                    : GetInput(VAR_0, VAR_2, lstm::full::kCellGateBiasTensor);
  TF_LITE_ENSURE_OK(
      VAR_0,
      PrecomputeZeroPointTimesWeightWithBias(
          VAR_0, VAR_5, VAR_9, VAR_25,
          &(VAR_17->input_to_cell_effective_bias)));
  TF_LITE_ENSURE_OK(
      VAR_0,
      PrecomputeZeroPointTimesWeightWithBias(
          VAR_0, VAR_6, VAR_13, nullptr,
          &(VAR_17->recurrent_to_cell_effective_bias)));

  /* COMMENT_6 */
  const TfLiteTensor* VAR_26 =
      VAR_23
          ? nullptr
          : GetInput(VAR_0, VAR_2, lstm::full::kOutputGateBiasTensor);
  TF_LITE_ENSURE_OK(
      VAR_0,
      PrecomputeZeroPointTimesWeightWithBias(
          VAR_0, VAR_5, VAR_10, VAR_26,
          &(VAR_17->input_to_output_effective_bias)));

  TF_LITE_ENSURE_OK(
      VAR_0,
      PrecomputeZeroPointTimesWeightWithBias(
          VAR_0, VAR_6, VAR_14,
          nullptr, &(VAR_17->recurrent_to_output_effective_bias)));

  /* COMMENT_7 */
  const TfLiteTensor* VAR_27 =
      VAR_23 ? nullptr
                    : GetInput(VAR_0, VAR_2, lstm::full::kInputGateBiasTensor);
  TF_LITE_ENSURE_OK(
      VAR_0,
      PrecomputeZeroPointTimesWeightWithBias(
          VAR_0, VAR_5, VAR_7, VAR_27,
          &(VAR_17->input_to_input_effective_bias)));
  TF_LITE_ENSURE_OK(
      VAR_0,
      PrecomputeZeroPointTimesWeightWithBias(
          VAR_0, VAR_6, VAR_11, nullptr,
          &(VAR_17->recurrent_to_input_effective_bias)));

  /* COMMENT_8 */
  TF_LITE_ENSURE_OK(VAR_0,
                    PrecomputeZeroPointTimesWeightWithBias(
                        VAR_0, VAR_22, VAR_15, VAR_16,
                        &(VAR_17->projection_effective_bias)));
  return VAR_28;
}",tensorflow/4a91f2069f7145aab6ba2d8cfe41be8a110c18a5/unidirectional_sequence_lstm.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -56,6 +56,8 @@
 
   const TfLiteTensor* intermediate =
       &context->tensors[node->intermediates->data[4]];
+  TF_LITE_ENSURE(context,
+                 intermediate->quantization.type != kTfLiteNoQuantization);
   const auto* params =
       static_cast<TfLiteAffineQuantization*>(intermediate->quantization.params);
   const int32_t hidden_zp = params->zero_point->data[0];","{'deleted_lines': [], 'added_lines': ['  TF_LITE_ENSURE(context,', '                 intermediate->quantization.type != kTfLiteNoQuantization);']}",True,"TensorFlow is an end-to-end open source platform for machine learning. In affected versions all TFLite operations that use quantization can be made to use unitialized values. [For example](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/depthwise_conv.cc#L198-L200). The issue stems from the fact that `quantization.params` is only valid if `quantization.type` is different that `kTfLiteNoQuantization`. However, these checks are missing in large parts of the code. We have patched the issue in GitHub commits 537bc7c723439b9194a358f64d871dd326c18887, 4a91f2069f7145aab6ba2d8cfe41be8a110c18a5 and 8933b8a21280696ab119b63263babdb54c298538. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",4.4,MEDIUM,1,valid,2021-07-16T16:59:39Z,3
CVE-2021-37682,['CWE-908'],AV:L/AC:L/Au:N/C:N/I:P/A:P,0,tensorflow,"Fix a null pointer exception caused by branching on uninitialized data.

This is due to not checking that the params for the quantization exists. If there is no quantization, we should not access the `.params` field.

PiperOrigin-RevId: 385168337
Change-Id: I28661e4f12ba1c92cfeae23d22a3fb2df2a2c6a4",4a91f2069f7145aab6ba2d8cfe41be8a110c18a5,https://github.com/tensorflow/tensorflow/commit/4a91f2069f7145aab6ba2d8cfe41be8a110c18a5,tensorflow/lite/kernels/unidirectional_sequence_lstm.cc,PopulateQuantizedLstmParams8x8_16,"TfLiteStatus PopulateQuantizedLstmParams8x8_16(
TfLiteContext* context, TfLiteNode* node,
lstm_eval::IntegerLstmParameter* integer_lstm_param) {
const auto* params =
static_cast<TfLiteUnidirectionalSequenceLSTMParams*>(node->builtin_data);
const float cell_clip = params->cell_clip;
const float proj_clip = params->proj_clip;
const TfLiteTensor* cell_state =
GetVariableInput(context, node, lstm::full::kCellStateTensor);
TF_LITE_ENSURE(context, cell_state != nullptr);
TfLiteTensor* output_tensor;
TF_LITE_ENSURE_OK(
context,
GetOutputSafe(context, node, lstm::full::kOutputTensor, &output_tensor));
auto* cell_state_params =
static_cast<TfLiteAffineQuantization*>(cell_state->quantization.params);
auto* proj_params = static_cast<TfLiteAffineQuantization*>(
output_tensor->quantization.params);
if (cell_clip > 0.0) {
integer_lstm_param->quantized_cell_clip = static_cast<int16_t>(std::min(
std::max(cell_clip / cell_state_params->scale->data[0], -32768.0f),
32767.0f));
} else {
integer_lstm_param->quantized_cell_clip = 0;
}
if (proj_clip > 0.0) {
integer_lstm_param->quantized_proj_clip = static_cast<int8_t>(std::min(
std::max(proj_clip / proj_params->scale->data[0], -128.0f), 127.0f));
} else {
integer_lstm_param->quantized_proj_clip = 0;
}
OpData* op_data = static_cast<OpData*>(node->user_data);
const bool use_layer_norm = op_data->use_layer_norm;
const TfLiteTensor* input;
TF_LITE_ENSURE_OK(
context, GetInputSafe(context, node, lstm::full::kInputTensor, &input));
const TfLiteTensor* input_to_input_weights = GetOptionalInputTensor(
context, node, lstm::full::kInputToInputWeightsTensor);
const TfLiteTensor* input_to_forget_weights;
TF_LITE_ENSURE_OK(
context,
GetInputSafe(context, node, lstm::full::kInputToForgetWeightsTensor,
&input_to_forget_weights));
const TfLiteTensor* input_to_cell_weights;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node,
lstm::full::kInputToCellWeightsTensor,
&input_to_cell_weights));
const TfLiteTensor* input_to_output_weights;
TF_LITE_ENSURE_OK(
context,
GetInputSafe(context, node, lstm::full::kInputToOutputWeightsTensor,
&input_to_output_weights));
const TfLiteTensor* recurrent_to_input_weights = GetOptionalInputTensor(
context, node, lstm::full::kRecurrentToInputWeightsTensor);
const TfLiteTensor* recurrent_to_forget_weights;
TF_LITE_ENSURE_OK(
context,
GetInputSafe(context, node, lstm::full::kRecurrentToForgetWeightsTensor,
&recurrent_to_forget_weights));
const TfLiteTensor* recurrent_to_cell_weights;
TF_LITE_ENSURE_OK(
context,
GetInputSafe(context, node, lstm::full::kRecurrentToCellWeightsTensor,
&recurrent_to_cell_weights));
const TfLiteTensor* recurrent_to_output_weights;
TF_LITE_ENSURE_OK(
context,
GetInputSafe(context, node, lstm::full::kRecurrentToOutputWeightsTensor,
&recurrent_to_output_weights));
const TfLiteTensor* cell_to_input_weights = GetOptionalInputTensor(
context, node, lstm::full::kCellToInputWeightsTensor);
const TfLiteTensor* cell_to_forget_weights = GetOptionalInputTensor(
context, node, lstm::full::kCellToForgetWeightsTensor);
const TfLiteTensor* cell_to_output_weights = GetOptionalInputTensor(
context, node, lstm::full::kCellToOutputWeightsTensor);
const TfLiteTensor* input_layer_norm_coefficients = GetOptionalInputTensor(
context, node, lstm::full::kInputLayerNormCoefficientsTensor);
const TfLiteTensor* forget_layer_norm_coefficients = GetOptionalInputTensor(
context, node, lstm::full::kForgetLayerNormCoefficientsTensor);
const TfLiteTensor* cell_layer_norm_coefficients = GetOptionalInputTensor(
context, node, lstm::full::kCellLayerNormCoefficientsTensor);
const TfLiteTensor* output_layer_norm_coefficients = GetOptionalInputTensor(
context, node, lstm::full::kOutputLayerNormCoefficientsTensor);
const TfLiteTensor* projection_weights = GetOptionalInputTensor(
context, node, lstm::full::kProjectionWeightsTensor);
TfLiteTensor* output_state =
GetVariableInput(context, node, lstm::full::kOutputStateTensor);
TF_LITE_ENSURE(context, output_state != nullptr);
const bool use_cifg = (input_to_input_weights == nullptr);
const bool use_peephole = (cell_to_output_weights != nullptr);
const bool use_projection = (projection_weights != nullptr);
std::vector<float> intermediate_scale;
std::vector<int32> intermediate_zp;
for (int i = 0; i < 4; ++i) {
if (use_layer_norm) {
TfLiteTensor* intermediate;
TF_LITE_ENSURE_OK(context,
GetIntermediatesSafe(context, node, i, &intermediate));
auto* params = static_cast<TfLiteAffineQuantization*>(
intermediate->quantization.params);
intermediate_scale.push_back(params->scale->data[0]);
intermediate_zp.push_back(params->zero_point->data[0]);
} else {
intermediate_scale.push_back(std::pow(2, -12));
intermediate_zp.push_back(0);
}
}
TfLiteTensor* hidden;
TF_LITE_ENSURE_OK(context, GetIntermediatesSafe(context, node, 4, &hidden));
auto* hidden_params =
static_cast<TfLiteAffineQuantization*>(hidden->quantization.params);
intermediate_scale.push_back(hidden_params->scale->data[0]);
intermediate_zp.push_back(hidden_params->zero_point->data[0]);
const float default_scale = 1.0;
float input_scale = default_scale;
float input_to_input_weight_scale = default_scale;
float recurrent_to_input_weight_scale = default_scale;
float cell_to_input_weight_scale = default_scale;
float input_to_forget_weight_scale = default_scale;
float recurrent_to_forget_weight_scale = default_scale;
float cell_to_forget_weight_scale = default_scale;
float input_to_cell_weight_scale = default_scale;
float recurrent_to_cell_weight_scale = default_scale;
float input_to_output_weight_scale = default_scale;
float recurrent_to_output_weight_scale = default_scale;
float cell_to_output_weight_scale = default_scale;
float projection_weight_scale = default_scale;
float layer_norm_input_scale = default_scale;
float layer_norm_forget_scale = default_scale;
float layer_norm_cell_scale = default_scale;
float layer_norm_output_scale = default_scale;
float output_state_scale = default_scale;
int cell_scale = 1;
float effective_input_to_input_scale = default_scale;
float effective_recurrent_to_input_scale = default_scale;
float effective_cell_to_input_scale = default_scale;
float effective_input_to_forget_scale = default_scale;
float effective_recurrent_to_forget_scale = default_scale;
float effective_cell_to_forget_scale = default_scale;
float effective_input_to_cell_scale = default_scale;
float effective_recurrent_to_cell_scale = default_scale;
float effective_input_to_output_scale = default_scale;
float effective_recurrent_to_output_scale = default_scale;
float effective_cell_to_output_scale = default_scale;
float effective_proj_scale = default_scale;
float effective_hidden_scale = default_scale;
if (!use_cifg) {
input_to_input_weight_scale = input_to_input_weights->params.scale;
recurrent_to_input_weight_scale = recurrent_to_input_weights->params.scale;
}
if (use_peephole) {
if (!use_cifg) {
cell_to_input_weight_scale = cell_to_input_weights->params.scale;
}
cell_to_forget_weight_scale = cell_to_forget_weights->params.scale;
cell_to_output_weight_scale = cell_to_output_weights->params.scale;
}
if (use_layer_norm) {
if (!use_cifg) {
layer_norm_input_scale = input_layer_norm_coefficients->params.scale;
}
layer_norm_forget_scale = forget_layer_norm_coefficients->params.scale;
layer_norm_cell_scale = cell_layer_norm_coefficients->params.scale;
layer_norm_output_scale = output_layer_norm_coefficients->params.scale;
}
if (use_projection) {
projection_weight_scale = projection_weights->params.scale;
}
output_state_scale = output_state->params.scale;
input_to_forget_weight_scale = input_to_forget_weights->params.scale;
input_to_cell_weight_scale = input_to_cell_weights->params.scale;
input_to_output_weight_scale = input_to_output_weights->params.scale;
recurrent_to_forget_weight_scale = recurrent_to_forget_weights->params.scale;
recurrent_to_cell_weight_scale = recurrent_to_cell_weights->params.scale;
recurrent_to_output_weight_scale = recurrent_to_output_weights->params.scale;
TF_LITE_ENSURE(context, CheckedLog2(cell_state->params.scale, &cell_scale));
integer_lstm_param->cell_scale = cell_scale;
input_scale = input->params.scale;
if (!use_cifg) {
effective_input_to_input_scale =
input_to_input_weight_scale * input_scale / intermediate_scale[0];
effective_recurrent_to_input_scale = recurrent_to_input_weight_scale *
output_state_scale /
intermediate_scale[0];
}
effective_input_to_forget_scale =
input_to_forget_weight_scale * input_scale / intermediate_scale[1];
effective_recurrent_to_forget_scale = recurrent_to_forget_weight_scale *
output_state_scale /
intermediate_scale[1];
effective_input_to_cell_scale =
input_to_cell_weight_scale * input_scale / intermediate_scale[2];
effective_recurrent_to_cell_scale = recurrent_to_cell_weight_scale *
output_state_scale /
intermediate_scale[2];
effective_input_to_output_scale =
input_to_output_weight_scale * input_scale / intermediate_scale[3];
effective_recurrent_to_output_scale = recurrent_to_output_weight_scale *
output_state_scale /
intermediate_scale[3];
effective_hidden_scale =
std::pow(2, -15) / intermediate_scale[4] * std::pow(2, -15);
effective_proj_scale =
projection_weight_scale * intermediate_scale[4] / output_state_scale;
if (use_peephole) {
if (!use_cifg) {
effective_cell_to_input_scale = std::pow(2, cell_scale) *                                        cell_to_input_weight_scale /
intermediate_scale[0];
}
effective_cell_to_forget_scale = std::pow(2, cell_scale) *                                       cell_to_forget_weight_scale /
intermediate_scale[1];
effective_cell_to_output_scale = std::pow(2, cell_scale) *                                       cell_to_output_weight_scale /
intermediate_scale[3];
}
QuantizeMultiplier(effective_input_to_input_scale,
&integer_lstm_param->effective_input_to_input_scale_a,
&integer_lstm_param->effective_input_to_input_scale_b);
QuantizeMultiplier(effective_recurrent_to_input_scale,
&integer_lstm_param->effective_recurrent_to_input_scale_a,
&integer_lstm_param->effective_recurrent_to_input_scale_b);
QuantizeMultiplier(effective_cell_to_input_scale,
&integer_lstm_param->effective_cell_to_input_scale_a,
&integer_lstm_param->effective_cell_to_input_scale_b);
QuantizeMultiplier(effective_input_to_forget_scale,
&integer_lstm_param->effective_input_to_forget_scale_a,
&integer_lstm_param->effective_input_to_forget_scale_b);
QuantizeMultiplier(
effective_recurrent_to_forget_scale,
&integer_lstm_param->effective_recurrent_to_forget_scale_a,
&integer_lstm_param->effective_recurrent_to_forget_scale_b);
QuantizeMultiplier(effective_cell_to_forget_scale,
&integer_lstm_param->effective_cell_to_forget_scale_a,
&integer_lstm_param->effective_cell_to_forget_scale_b);
QuantizeMultiplier(effective_input_to_cell_scale,
&integer_lstm_param->effective_input_to_cell_scale_a,
&integer_lstm_param->effective_input_to_cell_scale_b);
QuantizeMultiplier(effective_recurrent_to_cell_scale,
&integer_lstm_param->effective_recurrent_to_cell_scale_a,
&integer_lstm_param->effective_recurrent_to_cell_scale_b);
QuantizeMultiplier(effective_input_to_output_scale,
&integer_lstm_param->effective_input_to_output_scale_a,
&integer_lstm_param->effective_input_to_output_scale_b);
QuantizeMultiplier(
effective_recurrent_to_output_scale,
&integer_lstm_param->effective_recurrent_to_output_scale_a,
&integer_lstm_param->effective_recurrent_to_output_scale_b);
QuantizeMultiplier(effective_cell_to_output_scale,
&integer_lstm_param->effective_cell_to_output_scale_a,
&integer_lstm_param->effective_cell_to_output_scale_b);
QuantizeMultiplier(effective_proj_scale,
&integer_lstm_param->effective_proj_scale_a,
&integer_lstm_param->effective_proj_scale_b);
QuantizeMultiplier(effective_hidden_scale,
&integer_lstm_param->effective_hidden_scale_a,
&integer_lstm_param->effective_hidden_scale_b);
QuantizeMultiplier(layer_norm_input_scale,
&integer_lstm_param->layer_norm_input_scale_a,
&integer_lstm_param->layer_norm_input_scale_b);
QuantizeMultiplier(layer_norm_forget_scale,
&integer_lstm_param->layer_norm_forget_scale_a,
&integer_lstm_param->layer_norm_forget_scale_b);
QuantizeMultiplier(layer_norm_cell_scale,
&integer_lstm_param->layer_norm_cell_scale_a,
&integer_lstm_param->layer_norm_cell_scale_b);
QuantizeMultiplier(layer_norm_output_scale,
&integer_lstm_param->layer_norm_output_scale_a,
&integer_lstm_param->layer_norm_output_scale_b);
integer_lstm_param->hidden_zp = intermediate_zp[4];
if (!use_cifg) {
integer_lstm_param->input_variance_guard =
std::max(1, static_cast<int32_t>(10000 * layer_norm_input_scale));
}
integer_lstm_param->forget_variance_guard =
std::max(1, static_cast<int32_t>(10000 * layer_norm_forget_scale));
integer_lstm_param->cell_variance_guard =
std::max(1, static_cast<int32_t>(10000 * layer_norm_cell_scale));
integer_lstm_param->output_variance_guard =
std::max(1, static_cast<int32_t>(10000 * layer_norm_output_scale));
return kTfLiteOk;
}","TfLiteStatus PopulateQuantizedLstmParams8x8_16(
TfLiteContext* VAR_0, TfLiteNode* VAR_1,
lstm_eval::IntegerLstmParameter* VAR_2) {
const auto* VAR_3 =
VAR_4<TfLiteUnidirectionalSequenceLSTMParams*>(VAR_1->builtin_data);
const float VAR_5 = VAR_3->cell_clip;
const float VAR_6 = VAR_3->proj_clip;
const TfLiteTensor* VAR_7 =
GetVariableInput(VAR_0, VAR_1, lstm::full::kCellStateTensor);
TF_LITE_ENSURE(VAR_0, VAR_7 != nullptr);
TfLiteTensor* VAR_8;
TF_LITE_ENSURE_OK(
VAR_0,
GetOutputSafe(VAR_0, VAR_1, lstm::full::kOutputTensor, &VAR_8));
auto* VAR_9 =
VAR_4<TfLiteAffineQuantization*>(VAR_7->quantization.params);
auto* VAR_10 = VAR_4<TfLiteAffineQuantization*>(
VAR_8->quantization.params);
if (VAR_5 > 0.0) {
VAR_2->quantized_cell_clip = VAR_4<int16_t>(std::min(
std::max(VAR_5 / VAR_9->scale->data[0], -32768.0f),
32767.0f));
} else {
VAR_2->quantized_cell_clip = 0;
}
if (VAR_6 > 0.0) {
VAR_2->quantized_proj_clip = VAR_4<int8_t>(std::min(
std::max(VAR_6 / VAR_10->scale->data[0], -128.0f), 127.0f));
} else {
VAR_2->quantized_proj_clip = 0;
}
OpData* VAR_11 = VAR_4<OpData*>(VAR_1->user_data);
const bool VAR_12 = VAR_11->use_layer_norm;
const TfLiteTensor* VAR_13;
TF_LITE_ENSURE_OK(
VAR_0, GetInputSafe(VAR_0, VAR_1, lstm::full::kInputTensor, &VAR_13));
const TfLiteTensor* VAR_14 = GetOptionalInputTensor(
VAR_0, VAR_1, lstm::full::kInputToInputWeightsTensor);
const TfLiteTensor* VAR_15;
TF_LITE_ENSURE_OK(
VAR_0,
GetInputSafe(VAR_0, VAR_1, lstm::full::kInputToForgetWeightsTensor,
&VAR_15));
const TfLiteTensor* VAR_16;
TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1,
lstm::full::kInputToCellWeightsTensor,
&VAR_16));
const TfLiteTensor* VAR_17;
TF_LITE_ENSURE_OK(
VAR_0,
GetInputSafe(VAR_0, VAR_1, lstm::full::kInputToOutputWeightsTensor,
&VAR_17));
const TfLiteTensor* VAR_18 = GetOptionalInputTensor(
VAR_0, VAR_1, lstm::full::kRecurrentToInputWeightsTensor);
const TfLiteTensor* VAR_19;
TF_LITE_ENSURE_OK(
VAR_0,
GetInputSafe(VAR_0, VAR_1, lstm::full::kRecurrentToForgetWeightsTensor,
&VAR_19));
const TfLiteTensor* VAR_20;
TF_LITE_ENSURE_OK(
VAR_0,
GetInputSafe(VAR_0, VAR_1, lstm::full::kRecurrentToCellWeightsTensor,
&VAR_20));
const TfLiteTensor* VAR_21;
TF_LITE_ENSURE_OK(
VAR_0,
GetInputSafe(VAR_0, VAR_1, lstm::full::kRecurrentToOutputWeightsTensor,
&VAR_21));
const TfLiteTensor* VAR_22 = GetOptionalInputTensor(
VAR_0, VAR_1, lstm::full::kCellToInputWeightsTensor);
const TfLiteTensor* VAR_23 = GetOptionalInputTensor(
VAR_0, VAR_1, lstm::full::kCellToForgetWeightsTensor);
const TfLiteTensor* VAR_24 = GetOptionalInputTensor(
VAR_0, VAR_1, lstm::full::kCellToOutputWeightsTensor);
const TfLiteTensor* VAR_25 = GetOptionalInputTensor(
VAR_0, VAR_1, lstm::full::kInputLayerNormCoefficientsTensor);
const TfLiteTensor* VAR_26 = GetOptionalInputTensor(
VAR_0, VAR_1, lstm::full::kForgetLayerNormCoefficientsTensor);
const TfLiteTensor* VAR_27 = GetOptionalInputTensor(
VAR_0, VAR_1, lstm::full::kCellLayerNormCoefficientsTensor);
const TfLiteTensor* VAR_28 = GetOptionalInputTensor(
VAR_0, VAR_1, lstm::full::kOutputLayerNormCoefficientsTensor);
const TfLiteTensor* VAR_29 = GetOptionalInputTensor(
VAR_0, VAR_1, lstm::full::kProjectionWeightsTensor);
TfLiteTensor* VAR_30 =
GetVariableInput(VAR_0, VAR_1, lstm::full::kOutputStateTensor);
TF_LITE_ENSURE(VAR_0, VAR_30 != nullptr);
const bool VAR_31 = (VAR_14 == nullptr);
const bool VAR_32 = (VAR_24 != nullptr);
const bool VAR_33 = (VAR_29 != nullptr);
std::vector<float> VAR_34;
std::vector<int32> VAR_35;
for (int VAR_36 = 0; VAR_36 < 4; ++VAR_36) {
if (VAR_12) {
TfLiteTensor* VAR_37;
TF_LITE_ENSURE_OK(VAR_0,
GetIntermediatesSafe(VAR_0, VAR_1, VAR_36, &VAR_37));
auto* VAR_3 = VAR_4<TfLiteAffineQuantization*>(
VAR_37->quantization.params);
VAR_34.push_back(VAR_3->scale->data[0]);
VAR_35.push_back(VAR_3->zero_point->data[0]);
} else {
VAR_34.push_back(std::pow(2, -12));
VAR_35.push_back(0);
}
}
TfLiteTensor* VAR_38;
TF_LITE_ENSURE_OK(VAR_0, GetIntermediatesSafe(VAR_0, VAR_1, 4, &VAR_38));
auto* VAR_39 =
VAR_4<TfLiteAffineQuantization*>(VAR_38->quantization.params);
VAR_34.push_back(VAR_39->scale->data[0]);
VAR_35.push_back(VAR_39->zero_point->data[0]);
const float VAR_40 = 1.0;
float VAR_41 = VAR_40;
float VAR_42 = VAR_40;
float VAR_43 = VAR_40;
float VAR_44 = VAR_40;
float VAR_45 = VAR_40;
float VAR_46 = VAR_40;
float VAR_47 = VAR_40;
float VAR_48 = VAR_40;
float VAR_49 = VAR_40;
float VAR_50 = VAR_40;
float VAR_51 = VAR_40;
float VAR_52 = VAR_40;
float VAR_53 = VAR_40;
float VAR_54 = VAR_40;
float VAR_55 = VAR_40;
float VAR_56 = VAR_40;
float VAR_57 = VAR_40;
float VAR_58 = VAR_40;
int VAR_59 = 1;
float VAR_60 = VAR_40;
float VAR_61 = VAR_40;
float VAR_62 = VAR_40;
float VAR_63 = VAR_40;
float VAR_64 = VAR_40;
float VAR_65 = VAR_40;
float VAR_66 = VAR_40;
float VAR_67 = VAR_40;
float VAR_68 = VAR_40;
float VAR_69 = VAR_40;
float VAR_70 = VAR_40;
float VAR_71 = VAR_40;
float VAR_72 = VAR_40;
if (!VAR_31) {
VAR_42 = VAR_14->params.scale;
VAR_43 = VAR_18->params.scale;
}
if (VAR_32) {
if (!VAR_31) {
VAR_44 = VAR_22->params.scale;
}
VAR_47 = VAR_23->params.scale;
VAR_52 = VAR_24->params.scale;
}
if (VAR_12) {
if (!VAR_31) {
VAR_54 = VAR_25->params.scale;
}
VAR_55 = VAR_26->params.scale;
VAR_56 = VAR_27->params.scale;
VAR_57 = VAR_28->params.scale;
}
if (VAR_33) {
VAR_53 = VAR_29->params.scale;
}
VAR_58 = VAR_30->params.scale;
VAR_45 = VAR_15->params.scale;
VAR_48 = VAR_16->params.scale;
VAR_50 = VAR_17->params.scale;
VAR_46 = VAR_19->params.scale;
VAR_49 = VAR_20->params.scale;
VAR_51 = VAR_21->params.scale;
TF_LITE_ENSURE(VAR_0, CheckedLog2(VAR_7->params.scale, &VAR_59));
VAR_2->cell_scale = VAR_59;
VAR_41 = VAR_13->params.scale;
if (!VAR_31) {
VAR_60 =
VAR_42 * VAR_41 / VAR_34[0];
VAR_61 = VAR_43 *
VAR_58 /
VAR_34[0];
}
VAR_63 =
VAR_45 * VAR_41 / VAR_34[1];
VAR_64 = VAR_46 *
VAR_58 /
VAR_34[1];
VAR_66 =
VAR_48 * VAR_41 / VAR_34[2];
VAR_67 = VAR_49 *
VAR_58 /
VAR_34[2];
VAR_68 =
VAR_50 * VAR_41 / VAR_34[3];
VAR_69 = VAR_51 *
VAR_58 /
VAR_34[3];
VAR_72 =
std::pow(2, -15) / VAR_34[4] * std::pow(2, -15);
VAR_71 =
VAR_53 * VAR_34[4] / VAR_58;
if (VAR_32) {
if (!VAR_31) {
VAR_62 = std::pow(2, VAR_59) *  
VAR_44 /
VAR_34[0];
}
VAR_65 = std::pow(2, VAR_59) *  
VAR_47 /
VAR_34[1];
VAR_70 = std::pow(2, VAR_59) *  
VAR_52 /
VAR_34[3];
}
QuantizeMultiplier(VAR_60,
&VAR_2->effective_input_to_input_scale_a,
&VAR_2->effective_input_to_input_scale_b);
QuantizeMultiplier(VAR_61,
&VAR_2->effective_recurrent_to_input_scale_a,
&VAR_2->effective_recurrent_to_input_scale_b);
QuantizeMultiplier(VAR_62,
&VAR_2->effective_cell_to_input_scale_a,
&VAR_2->effective_cell_to_input_scale_b);
QuantizeMultiplier(VAR_63,
&VAR_2->effective_input_to_forget_scale_a,
&VAR_2->effective_input_to_forget_scale_b);
QuantizeMultiplier(
VAR_64,
&VAR_2->effective_recurrent_to_forget_scale_a,
&VAR_2->effective_recurrent_to_forget_scale_b);
QuantizeMultiplier(VAR_65,
&VAR_2->effective_cell_to_forget_scale_a,
&VAR_2->effective_cell_to_forget_scale_b);
QuantizeMultiplier(VAR_66,
&VAR_2->effective_input_to_cell_scale_a,
&VAR_2->effective_input_to_cell_scale_b);
QuantizeMultiplier(VAR_67,
&VAR_2->effective_recurrent_to_cell_scale_a,
&VAR_2->effective_recurrent_to_cell_scale_b);
QuantizeMultiplier(VAR_68,
&VAR_2->effective_input_to_output_scale_a,
&VAR_2->effective_input_to_output_scale_b);
QuantizeMultiplier(
VAR_69,
&VAR_2->effective_recurrent_to_output_scale_a,
&VAR_2->effective_recurrent_to_output_scale_b);
QuantizeMultiplier(VAR_70,
&VAR_2->effective_cell_to_output_scale_a,
&VAR_2->effective_cell_to_output_scale_b);
QuantizeMultiplier(VAR_71,
&VAR_2->effective_proj_scale_a,
&VAR_2->effective_proj_scale_b);
QuantizeMultiplier(VAR_72,
&VAR_2->effective_hidden_scale_a,
&VAR_2->effective_hidden_scale_b);
QuantizeMultiplier(VAR_54,
&VAR_2->layer_norm_input_scale_a,
&VAR_2->layer_norm_input_scale_b);
QuantizeMultiplier(VAR_55,
&VAR_2->layer_norm_forget_scale_a,
&VAR_2->layer_norm_forget_scale_b);
QuantizeMultiplier(VAR_56,
&VAR_2->layer_norm_cell_scale_a,
&VAR_2->layer_norm_cell_scale_b);
QuantizeMultiplier(VAR_57,
&VAR_2->layer_norm_output_scale_a,
&VAR_2->layer_norm_output_scale_b);
VAR_2->hidden_zp = VAR_35[4];
if (!VAR_31) {
VAR_2->input_variance_guard =
std::max(1, VAR_4<int32_t>(10000 * VAR_54));
}
VAR_2->forget_variance_guard =
std::max(1, VAR_4<int32_t>(10000 * VAR_55));
VAR_2->cell_variance_guard =
std::max(1, VAR_4<int32_t>(10000 * VAR_56));
VAR_2->output_variance_guard =
std::max(1, VAR_4<int32_t>(10000 * VAR_57));
return VAR_73;
}",tensorflow/4a91f2069f7145aab6ba2d8cfe41be8a110c18a5/unidirectional_sequence_lstm.cc/vul/before/1.json,"TfLiteStatus PopulateQuantizedLstmParams8x8_16(
    TfLiteContext* context, TfLiteNode* node,
    lstm_eval::IntegerLstmParameter* integer_lstm_param) {
  // Calculate quantized clip for projection and cell.
  const auto* params =
      static_cast<TfLiteUnidirectionalSequenceLSTMParams*>(node->builtin_data);
  const float cell_clip = params->cell_clip;
  const float proj_clip = params->proj_clip;

  const TfLiteTensor* cell_state =
      GetVariableInput(context, node, lstm::full::kCellStateTensor);
  TF_LITE_ENSURE(context, cell_state != nullptr);
  TfLiteTensor* output_tensor;
  TF_LITE_ENSURE_OK(
      context,
      GetOutputSafe(context, node, lstm::full::kOutputTensor, &output_tensor));

  TF_LITE_ENSURE(context,
                 cell_state->quantization.type != kTfLiteNoQuantization);
  auto* cell_state_params =
      static_cast<TfLiteAffineQuantization*>(cell_state->quantization.params);
  TF_LITE_ENSURE(context,
                 output_tensor->quantization.type != kTfLiteNoQuantization);
  auto* proj_params = static_cast<TfLiteAffineQuantization*>(
      output_tensor->quantization.params);
  if (cell_clip > 0.0) {
    integer_lstm_param->quantized_cell_clip = static_cast<int16_t>(std::min(
        std::max(cell_clip / cell_state_params->scale->data[0], -32768.0f),
        32767.0f));
  } else {
    integer_lstm_param->quantized_cell_clip = 0;
  }
  if (proj_clip > 0.0) {
    integer_lstm_param->quantized_proj_clip = static_cast<int8_t>(std::min(
        std::max(proj_clip / proj_params->scale->data[0], -128.0f), 127.0f));
  } else {
    integer_lstm_param->quantized_proj_clip = 0;
  }

  // Calculate effective scales.
  OpData* op_data = static_cast<OpData*>(node->user_data);
  const bool use_layer_norm = op_data->use_layer_norm;

  const TfLiteTensor* input;
  TF_LITE_ENSURE_OK(
      context, GetInputSafe(context, node, lstm::full::kInputTensor, &input));

  const TfLiteTensor* input_to_input_weights = GetOptionalInputTensor(
      context, node, lstm::full::kInputToInputWeightsTensor);
  const TfLiteTensor* input_to_forget_weights;
  TF_LITE_ENSURE_OK(
      context,
      GetInputSafe(context, node, lstm::full::kInputToForgetWeightsTensor,
                   &input_to_forget_weights));
  const TfLiteTensor* input_to_cell_weights;
  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node,
                                          lstm::full::kInputToCellWeightsTensor,
                                          &input_to_cell_weights));
  const TfLiteTensor* input_to_output_weights;
  TF_LITE_ENSURE_OK(
      context,
      GetInputSafe(context, node, lstm::full::kInputToOutputWeightsTensor,
                   &input_to_output_weights));

  const TfLiteTensor* recurrent_to_input_weights = GetOptionalInputTensor(
      context, node, lstm::full::kRecurrentToInputWeightsTensor);
  const TfLiteTensor* recurrent_to_forget_weights;
  TF_LITE_ENSURE_OK(
      context,
      GetInputSafe(context, node, lstm::full::kRecurrentToForgetWeightsTensor,
                   &recurrent_to_forget_weights));
  const TfLiteTensor* recurrent_to_cell_weights;
  TF_LITE_ENSURE_OK(
      context,
      GetInputSafe(context, node, lstm::full::kRecurrentToCellWeightsTensor,
                   &recurrent_to_cell_weights));
  const TfLiteTensor* recurrent_to_output_weights;
  TF_LITE_ENSURE_OK(
      context,
      GetInputSafe(context, node, lstm::full::kRecurrentToOutputWeightsTensor,
                   &recurrent_to_output_weights));

  const TfLiteTensor* cell_to_input_weights = GetOptionalInputTensor(
      context, node, lstm::full::kCellToInputWeightsTensor);
  const TfLiteTensor* cell_to_forget_weights = GetOptionalInputTensor(
      context, node, lstm::full::kCellToForgetWeightsTensor);
  const TfLiteTensor* cell_to_output_weights = GetOptionalInputTensor(
      context, node, lstm::full::kCellToOutputWeightsTensor);

  const TfLiteTensor* input_layer_norm_coefficients = GetOptionalInputTensor(
      context, node, lstm::full::kInputLayerNormCoefficientsTensor);
  const TfLiteTensor* forget_layer_norm_coefficients = GetOptionalInputTensor(
      context, node, lstm::full::kForgetLayerNormCoefficientsTensor);
  const TfLiteTensor* cell_layer_norm_coefficients = GetOptionalInputTensor(
      context, node, lstm::full::kCellLayerNormCoefficientsTensor);
  const TfLiteTensor* output_layer_norm_coefficients = GetOptionalInputTensor(
      context, node, lstm::full::kOutputLayerNormCoefficientsTensor);

  const TfLiteTensor* projection_weights = GetOptionalInputTensor(
      context, node, lstm::full::kProjectionWeightsTensor);

  TfLiteTensor* output_state =
      GetVariableInput(context, node, lstm::full::kOutputStateTensor);
  TF_LITE_ENSURE(context, output_state != nullptr);

  // Since we have already checked that weights are all there or none, we can
  // check the existence of only one to get the condition.
  const bool use_cifg = (input_to_input_weights == nullptr);
  const bool use_peephole = (cell_to_output_weights != nullptr);
  const bool use_projection = (projection_weights != nullptr);

  // Get intermediate scales and zero points.
  std::vector<float> intermediate_scale;
  std::vector<int32> intermediate_zp;
  for (int i = 0; i < 4; ++i) {
    if (use_layer_norm) {
      TfLiteTensor* intermediate;
      TF_LITE_ENSURE_OK(context,
                        GetIntermediatesSafe(context, node, i, &intermediate));
      TF_LITE_ENSURE(context,
                     intermediate->quantization.type != kTfLiteNoQuantization);
      auto* params = static_cast<TfLiteAffineQuantization*>(
          intermediate->quantization.params);
      intermediate_scale.push_back(params->scale->data[0]);
      intermediate_zp.push_back(params->zero_point->data[0]);
    } else {
      // Q3.12 for activation functions.
      intermediate_scale.push_back(std::pow(2, -12));
      intermediate_zp.push_back(0);
    }
  }
  // In the absence of projection, hidden becomes otuput and this intermediate
  // is ignored.
  TfLiteTensor* hidden;
  TF_LITE_ENSURE_OK(context, GetIntermediatesSafe(context, node, 4, &hidden));
  TF_LITE_ENSURE(context, hidden->quantization.type != kTfLiteNoQuantization);
  auto* hidden_params =
      static_cast<TfLiteAffineQuantization*>(hidden->quantization.params);
  intermediate_scale.push_back(hidden_params->scale->data[0]);
  intermediate_zp.push_back(hidden_params->zero_point->data[0]);

  // Scales.
  const float default_scale = 1.0;
  float input_scale = default_scale;
  float input_to_input_weight_scale = default_scale;
  float recurrent_to_input_weight_scale = default_scale;
  float cell_to_input_weight_scale = default_scale;
  float input_to_forget_weight_scale = default_scale;
  float recurrent_to_forget_weight_scale = default_scale;
  float cell_to_forget_weight_scale = default_scale;
  float input_to_cell_weight_scale = default_scale;
  float recurrent_to_cell_weight_scale = default_scale;
  float input_to_output_weight_scale = default_scale;
  float recurrent_to_output_weight_scale = default_scale;
  float cell_to_output_weight_scale = default_scale;
  float projection_weight_scale = default_scale;
  float layer_norm_input_scale = default_scale;
  float layer_norm_forget_scale = default_scale;
  float layer_norm_cell_scale = default_scale;
  float layer_norm_output_scale = default_scale;
  float output_state_scale = default_scale;
  int cell_scale = 1;

  // Effective scales.
  float effective_input_to_input_scale = default_scale;
  float effective_recurrent_to_input_scale = default_scale;
  float effective_cell_to_input_scale = default_scale;
  float effective_input_to_forget_scale = default_scale;
  float effective_recurrent_to_forget_scale = default_scale;
  float effective_cell_to_forget_scale = default_scale;
  float effective_input_to_cell_scale = default_scale;
  float effective_recurrent_to_cell_scale = default_scale;
  float effective_input_to_output_scale = default_scale;
  float effective_recurrent_to_output_scale = default_scale;
  float effective_cell_to_output_scale = default_scale;
  float effective_proj_scale = default_scale;
  float effective_hidden_scale = default_scale;

  // Populate scales.
  if (!use_cifg) {
    input_to_input_weight_scale = input_to_input_weights->params.scale;
    recurrent_to_input_weight_scale = recurrent_to_input_weights->params.scale;
  }

  if (use_peephole) {
    if (!use_cifg) {
      cell_to_input_weight_scale = cell_to_input_weights->params.scale;
    }
    cell_to_forget_weight_scale = cell_to_forget_weights->params.scale;
    cell_to_output_weight_scale = cell_to_output_weights->params.scale;
  }

  if (use_layer_norm) {
    if (!use_cifg) {
      layer_norm_input_scale = input_layer_norm_coefficients->params.scale;
    }
    layer_norm_forget_scale = forget_layer_norm_coefficients->params.scale;
    layer_norm_cell_scale = cell_layer_norm_coefficients->params.scale;
    layer_norm_output_scale = output_layer_norm_coefficients->params.scale;
  }

  if (use_projection) {
    projection_weight_scale = projection_weights->params.scale;
  }
  output_state_scale = output_state->params.scale;

  input_to_forget_weight_scale = input_to_forget_weights->params.scale;
  input_to_cell_weight_scale = input_to_cell_weights->params.scale;
  input_to_output_weight_scale = input_to_output_weights->params.scale;
  recurrent_to_forget_weight_scale = recurrent_to_forget_weights->params.scale;
  recurrent_to_cell_weight_scale = recurrent_to_cell_weights->params.scale;
  recurrent_to_output_weight_scale = recurrent_to_output_weights->params.scale;

  // Check cell state (already used above)
  TF_LITE_ENSURE(context, CheckedLog2(cell_state->params.scale, &cell_scale));
  // TF_LITE_ENSURE(context, cell_scale <= -9);
  integer_lstm_param->cell_scale = cell_scale;
  input_scale = input->params.scale;

  // Calculate effective scales.
  if (!use_cifg) {
    effective_input_to_input_scale =
        input_to_input_weight_scale * input_scale / intermediate_scale[0];
    effective_recurrent_to_input_scale = recurrent_to_input_weight_scale *
                                         output_state_scale /
                                         intermediate_scale[0];
  }
  effective_input_to_forget_scale =
      input_to_forget_weight_scale * input_scale / intermediate_scale[1];
  effective_recurrent_to_forget_scale = recurrent_to_forget_weight_scale *
                                        output_state_scale /
                                        intermediate_scale[1];

  effective_input_to_cell_scale =
      input_to_cell_weight_scale * input_scale / intermediate_scale[2];
  effective_recurrent_to_cell_scale = recurrent_to_cell_weight_scale *
                                      output_state_scale /
                                      intermediate_scale[2];

  effective_input_to_output_scale =
      input_to_output_weight_scale * input_scale / intermediate_scale[3];
  effective_recurrent_to_output_scale = recurrent_to_output_weight_scale *
                                        output_state_scale /
                                        intermediate_scale[3];

  effective_hidden_scale =
      std::pow(2, -15) / intermediate_scale[4] * std::pow(2, -15);

  effective_proj_scale =
      projection_weight_scale * intermediate_scale[4] / output_state_scale;

  if (use_peephole) {
    if (!use_cifg) {
      effective_cell_to_input_scale = std::pow(2, cell_scale) *  // NOLINT
                                      cell_to_input_weight_scale /
                                      intermediate_scale[0];
    }
    effective_cell_to_forget_scale = std::pow(2, cell_scale) *  // NOLINT
                                     cell_to_forget_weight_scale /
                                     intermediate_scale[1];
    effective_cell_to_output_scale = std::pow(2, cell_scale) *  // NOLINT
                                     cell_to_output_weight_scale /
                                     intermediate_scale[3];
  }

  // Decompose scales.
  QuantizeMultiplier(effective_input_to_input_scale,
                     &integer_lstm_param->effective_input_to_input_scale_a,
                     &integer_lstm_param->effective_input_to_input_scale_b);
  QuantizeMultiplier(effective_recurrent_to_input_scale,
                     &integer_lstm_param->effective_recurrent_to_input_scale_a,
                     &integer_lstm_param->effective_recurrent_to_input_scale_b);
  QuantizeMultiplier(effective_cell_to_input_scale,
                     &integer_lstm_param->effective_cell_to_input_scale_a,
                     &integer_lstm_param->effective_cell_to_input_scale_b);
  QuantizeMultiplier(effective_input_to_forget_scale,
                     &integer_lstm_param->effective_input_to_forget_scale_a,
                     &integer_lstm_param->effective_input_to_forget_scale_b);
  QuantizeMultiplier(
      effective_recurrent_to_forget_scale,
      &integer_lstm_param->effective_recurrent_to_forget_scale_a,
      &integer_lstm_param->effective_recurrent_to_forget_scale_b);
  QuantizeMultiplier(effective_cell_to_forget_scale,
                     &integer_lstm_param->effective_cell_to_forget_scale_a,
                     &integer_lstm_param->effective_cell_to_forget_scale_b);
  QuantizeMultiplier(effective_input_to_cell_scale,
                     &integer_lstm_param->effective_input_to_cell_scale_a,
                     &integer_lstm_param->effective_input_to_cell_scale_b);
  QuantizeMultiplier(effective_recurrent_to_cell_scale,
                     &integer_lstm_param->effective_recurrent_to_cell_scale_a,
                     &integer_lstm_param->effective_recurrent_to_cell_scale_b);
  QuantizeMultiplier(effective_input_to_output_scale,
                     &integer_lstm_param->effective_input_to_output_scale_a,
                     &integer_lstm_param->effective_input_to_output_scale_b);
  QuantizeMultiplier(
      effective_recurrent_to_output_scale,
      &integer_lstm_param->effective_recurrent_to_output_scale_a,
      &integer_lstm_param->effective_recurrent_to_output_scale_b);
  QuantizeMultiplier(effective_cell_to_output_scale,
                     &integer_lstm_param->effective_cell_to_output_scale_a,
                     &integer_lstm_param->effective_cell_to_output_scale_b);
  QuantizeMultiplier(effective_proj_scale,
                     &integer_lstm_param->effective_proj_scale_a,
                     &integer_lstm_param->effective_proj_scale_b);
  QuantizeMultiplier(effective_hidden_scale,
                     &integer_lstm_param->effective_hidden_scale_a,
                     &integer_lstm_param->effective_hidden_scale_b);
  QuantizeMultiplier(layer_norm_input_scale,
                     &integer_lstm_param->layer_norm_input_scale_a,
                     &integer_lstm_param->layer_norm_input_scale_b);
  QuantizeMultiplier(layer_norm_forget_scale,
                     &integer_lstm_param->layer_norm_forget_scale_a,
                     &integer_lstm_param->layer_norm_forget_scale_b);
  QuantizeMultiplier(layer_norm_cell_scale,
                     &integer_lstm_param->layer_norm_cell_scale_a,
                     &integer_lstm_param->layer_norm_cell_scale_b);
  QuantizeMultiplier(layer_norm_output_scale,
                     &integer_lstm_param->layer_norm_output_scale_a,
                     &integer_lstm_param->layer_norm_output_scale_b);

  integer_lstm_param->hidden_zp = intermediate_zp[4];

  // 10000 is used to make sure the kernel logic does not overflow.
  if (!use_cifg) {
    integer_lstm_param->input_variance_guard =
        std::max(1, static_cast<int32_t>(10000 * layer_norm_input_scale));
  }
  integer_lstm_param->forget_variance_guard =
      std::max(1, static_cast<int32_t>(10000 * layer_norm_forget_scale));
  integer_lstm_param->cell_variance_guard =
      std::max(1, static_cast<int32_t>(10000 * layer_norm_cell_scale));
  integer_lstm_param->output_variance_guard =
      std::max(1, static_cast<int32_t>(10000 * layer_norm_output_scale));

  return kTfLiteOk;
}","TfLiteStatus PopulateQuantizedLstmParams8x8_16(
    TfLiteContext* VAR_0, TfLiteNode* VAR_1,
    lstm_eval::IntegerLstmParameter* VAR_2) {
  /* COMMENT_0 */
  const auto* VAR_3 =
      VAR_4<TfLiteUnidirectionalSequenceLSTMParams*>(VAR_1->builtin_data);
  const float VAR_5 = VAR_3->cell_clip;
  const float VAR_6 = VAR_3->proj_clip;

  const TfLiteTensor* VAR_7 =
      GetVariableInput(VAR_0, VAR_1, lstm::full::kCellStateTensor);
  TF_LITE_ENSURE(VAR_0, VAR_7 != nullptr);
  TfLiteTensor* VAR_8;
  TF_LITE_ENSURE_OK(
      VAR_0,
      GetOutputSafe(VAR_0, VAR_1, lstm::full::kOutputTensor, &VAR_8));

  TF_LITE_ENSURE(VAR_0,
                 VAR_7->quantization.type != VAR_9);
  auto* VAR_10 =
      VAR_4<TfLiteAffineQuantization*>(VAR_7->quantization.params);
  TF_LITE_ENSURE(VAR_0,
                 VAR_8->quantization.type != VAR_9);
  auto* VAR_11 = VAR_4<TfLiteAffineQuantization*>(
      VAR_8->quantization.params);
  if (VAR_5 > 0.0) {
    VAR_2->quantized_cell_clip = VAR_4<int16_t>(std::min(
        std::max(VAR_5 / VAR_10->scale->data[0], -32768.0f),
        32767.0f));
  } else {
    VAR_2->quantized_cell_clip = 0;
  }
  if (VAR_6 > 0.0) {
    VAR_2->quantized_proj_clip = VAR_4<int8_t>(std::min(
        std::max(VAR_6 / VAR_11->scale->data[0], -128.0f), 127.0f));
  } else {
    VAR_2->quantized_proj_clip = 0;
  }

  /* COMMENT_1 */
  OpData* VAR_12 = VAR_4<OpData*>(VAR_1->user_data);
  const bool VAR_13 = VAR_12->use_layer_norm;

  const TfLiteTensor* VAR_14;
  TF_LITE_ENSURE_OK(
      VAR_0, GetInputSafe(VAR_0, VAR_1, lstm::full::kInputTensor, &VAR_14));

  const TfLiteTensor* VAR_15 = GetOptionalInputTensor(
      VAR_0, VAR_1, lstm::full::kInputToInputWeightsTensor);
  const TfLiteTensor* VAR_16;
  TF_LITE_ENSURE_OK(
      VAR_0,
      GetInputSafe(VAR_0, VAR_1, lstm::full::kInputToForgetWeightsTensor,
                   &VAR_16));
  const TfLiteTensor* VAR_17;
  TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1,
                                          lstm::full::kInputToCellWeightsTensor,
                                          &VAR_17));
  const TfLiteTensor* VAR_18;
  TF_LITE_ENSURE_OK(
      VAR_0,
      GetInputSafe(VAR_0, VAR_1, lstm::full::kInputToOutputWeightsTensor,
                   &VAR_18));

  const TfLiteTensor* VAR_19 = GetOptionalInputTensor(
      VAR_0, VAR_1, lstm::full::kRecurrentToInputWeightsTensor);
  const TfLiteTensor* VAR_20;
  TF_LITE_ENSURE_OK(
      VAR_0,
      GetInputSafe(VAR_0, VAR_1, lstm::full::kRecurrentToForgetWeightsTensor,
                   &VAR_20));
  const TfLiteTensor* VAR_21;
  TF_LITE_ENSURE_OK(
      VAR_0,
      GetInputSafe(VAR_0, VAR_1, lstm::full::kRecurrentToCellWeightsTensor,
                   &VAR_21));
  const TfLiteTensor* VAR_22;
  TF_LITE_ENSURE_OK(
      VAR_0,
      GetInputSafe(VAR_0, VAR_1, lstm::full::kRecurrentToOutputWeightsTensor,
                   &VAR_22));

  const TfLiteTensor* VAR_23 = GetOptionalInputTensor(
      VAR_0, VAR_1, lstm::full::kCellToInputWeightsTensor);
  const TfLiteTensor* VAR_24 = GetOptionalInputTensor(
      VAR_0, VAR_1, lstm::full::kCellToForgetWeightsTensor);
  const TfLiteTensor* VAR_25 = GetOptionalInputTensor(
      VAR_0, VAR_1, lstm::full::kCellToOutputWeightsTensor);

  const TfLiteTensor* VAR_26 = GetOptionalInputTensor(
      VAR_0, VAR_1, lstm::full::kInputLayerNormCoefficientsTensor);
  const TfLiteTensor* VAR_27 = GetOptionalInputTensor(
      VAR_0, VAR_1, lstm::full::kForgetLayerNormCoefficientsTensor);
  const TfLiteTensor* VAR_28 = GetOptionalInputTensor(
      VAR_0, VAR_1, lstm::full::kCellLayerNormCoefficientsTensor);
  const TfLiteTensor* VAR_29 = GetOptionalInputTensor(
      VAR_0, VAR_1, lstm::full::kOutputLayerNormCoefficientsTensor);

  const TfLiteTensor* VAR_30 = GetOptionalInputTensor(
      VAR_0, VAR_1, lstm::full::kProjectionWeightsTensor);

  TfLiteTensor* VAR_31 =
      GetVariableInput(VAR_0, VAR_1, lstm::full::kOutputStateTensor);
  TF_LITE_ENSURE(VAR_0, VAR_31 != nullptr);

  /* COMMENT_2 */
  /* COMMENT_3 */
  const bool VAR_32 = (VAR_15 == nullptr);
  const bool VAR_33 = (VAR_25 != nullptr);
  const bool VAR_34 = (VAR_30 != nullptr);

  /* COMMENT_4 */
  std::vector<float> VAR_35;
  std::vector<int32> VAR_36;
  for (int VAR_37 = 0; VAR_37 < 4; ++VAR_37) {
    if (VAR_13) {
      TfLiteTensor* VAR_38;
      TF_LITE_ENSURE_OK(VAR_0,
                        GetIntermediatesSafe(VAR_0, VAR_1, VAR_37, &VAR_38));
      TF_LITE_ENSURE(VAR_0,
                     VAR_38->quantization.type != VAR_9);
      auto* VAR_3 = VAR_4<TfLiteAffineQuantization*>(
          VAR_38->quantization.params);
      VAR_35.push_back(VAR_3->scale->data[0]);
      VAR_36.push_back(VAR_3->zero_point->data[0]);
    } else {
      /* COMMENT_5 */
      VAR_35.push_back(std::pow(2, -12));
      VAR_36.push_back(0);
    }
  }
  /* COMMENT_6 */
  /* COMMENT_7 */
  TfLiteTensor* VAR_39;
  TF_LITE_ENSURE_OK(VAR_0, GetIntermediatesSafe(VAR_0, VAR_1, 4, &VAR_39));
  TF_LITE_ENSURE(VAR_0, VAR_39->quantization.type != VAR_9);
  auto* VAR_40 =
      VAR_4<TfLiteAffineQuantization*>(VAR_39->quantization.params);
  VAR_35.push_back(VAR_40->scale->data[0]);
  VAR_36.push_back(VAR_40->zero_point->data[0]);

  /* COMMENT_8 */
  const float VAR_41 = 1.0;
  float VAR_42 = VAR_41;
  float VAR_43 = VAR_41;
  float VAR_44 = VAR_41;
  float VAR_45 = VAR_41;
  float VAR_46 = VAR_41;
  float VAR_47 = VAR_41;
  float VAR_48 = VAR_41;
  float VAR_49 = VAR_41;
  float VAR_50 = VAR_41;
  float VAR_51 = VAR_41;
  float VAR_52 = VAR_41;
  float VAR_53 = VAR_41;
  float VAR_54 = VAR_41;
  float VAR_55 = VAR_41;
  float VAR_56 = VAR_41;
  float VAR_57 = VAR_41;
  float VAR_58 = VAR_41;
  float VAR_59 = VAR_41;
  int VAR_60 = 1;

  /* COMMENT_9 */
  float VAR_61 = VAR_41;
  float VAR_62 = VAR_41;
  float VAR_63 = VAR_41;
  float VAR_64 = VAR_41;
  float VAR_65 = VAR_41;
  float VAR_66 = VAR_41;
  float VAR_67 = VAR_41;
  float VAR_68 = VAR_41;
  float VAR_69 = VAR_41;
  float VAR_70 = VAR_41;
  float VAR_71 = VAR_41;
  float VAR_72 = VAR_41;
  float VAR_73 = VAR_41;

  /* COMMENT_10 */
  if (!VAR_32) {
    VAR_43 = VAR_15->params.scale;
    VAR_44 = VAR_19->params.scale;
  }

  if (VAR_33) {
    if (!VAR_32) {
      VAR_45 = VAR_23->params.scale;
    }
    VAR_48 = VAR_24->params.scale;
    VAR_53 = VAR_25->params.scale;
  }

  if (VAR_13) {
    if (!VAR_32) {
      VAR_55 = VAR_26->params.scale;
    }
    VAR_56 = VAR_27->params.scale;
    VAR_57 = VAR_28->params.scale;
    VAR_58 = VAR_29->params.scale;
  }

  if (VAR_34) {
    VAR_54 = VAR_30->params.scale;
  }
  VAR_59 = VAR_31->params.scale;

  VAR_46 = VAR_16->params.scale;
  VAR_49 = VAR_17->params.scale;
  VAR_51 = VAR_18->params.scale;
  VAR_47 = VAR_20->params.scale;
  VAR_50 = VAR_21->params.scale;
  VAR_52 = VAR_22->params.scale;

  /* COMMENT_11 */
  TF_LITE_ENSURE(VAR_0, CheckedLog2(VAR_7->params.scale, &VAR_60));
  /* COMMENT_12 */
  VAR_2->cell_scale = VAR_60;
  VAR_42 = VAR_14->params.scale;

  /* COMMENT_1 */
  if (!VAR_32) {
    VAR_61 =
        VAR_43 * VAR_42 / VAR_35[0];
    VAR_62 = VAR_44 *
                                         VAR_59 /
                                         VAR_35[0];
  }
  VAR_64 =
      VAR_46 * VAR_42 / VAR_35[1];
  VAR_65 = VAR_47 *
                                        VAR_59 /
                                        VAR_35[1];

  VAR_67 =
      VAR_49 * VAR_42 / VAR_35[2];
  VAR_68 = VAR_50 *
                                      VAR_59 /
                                      VAR_35[2];

  VAR_69 =
      VAR_51 * VAR_42 / VAR_35[3];
  VAR_70 = VAR_52 *
                                        VAR_59 /
                                        VAR_35[3];

  VAR_73 =
      std::pow(2, -15) / VAR_35[4] * std::pow(2, -15);

  VAR_72 =
      VAR_54 * VAR_35[4] / VAR_59;

  if (VAR_33) {
    if (!VAR_32) {
      VAR_63 = std::pow(2, VAR_60) *  /* COMMENT_13 */
                                      VAR_45 /
                                      VAR_35[0];
    }
    VAR_66 = std::pow(2, VAR_60) *  /* COMMENT_13 */
                                     VAR_48 /
                                     VAR_35[1];
    VAR_71 = std::pow(2, VAR_60) *  /* COMMENT_13 */
                                     VAR_53 /
                                     VAR_35[3];
  }

  /* COMMENT_14 */
  QuantizeMultiplier(VAR_61,
                     &VAR_2->effective_input_to_input_scale_a,
                     &VAR_2->effective_input_to_input_scale_b);
  QuantizeMultiplier(VAR_62,
                     &VAR_2->effective_recurrent_to_input_scale_a,
                     &VAR_2->effective_recurrent_to_input_scale_b);
  QuantizeMultiplier(VAR_63,
                     &VAR_2->effective_cell_to_input_scale_a,
                     &VAR_2->effective_cell_to_input_scale_b);
  QuantizeMultiplier(VAR_64,
                     &VAR_2->effective_input_to_forget_scale_a,
                     &VAR_2->effective_input_to_forget_scale_b);
  QuantizeMultiplier(
      VAR_65,
      &VAR_2->effective_recurrent_to_forget_scale_a,
      &VAR_2->effective_recurrent_to_forget_scale_b);
  QuantizeMultiplier(VAR_66,
                     &VAR_2->effective_cell_to_forget_scale_a,
                     &VAR_2->effective_cell_to_forget_scale_b);
  QuantizeMultiplier(VAR_67,
                     &VAR_2->effective_input_to_cell_scale_a,
                     &VAR_2->effective_input_to_cell_scale_b);
  QuantizeMultiplier(VAR_68,
                     &VAR_2->effective_recurrent_to_cell_scale_a,
                     &VAR_2->effective_recurrent_to_cell_scale_b);
  QuantizeMultiplier(VAR_69,
                     &VAR_2->effective_input_to_output_scale_a,
                     &VAR_2->effective_input_to_output_scale_b);
  QuantizeMultiplier(
      VAR_70,
      &VAR_2->effective_recurrent_to_output_scale_a,
      &VAR_2->effective_recurrent_to_output_scale_b);
  QuantizeMultiplier(VAR_71,
                     &VAR_2->effective_cell_to_output_scale_a,
                     &VAR_2->effective_cell_to_output_scale_b);
  QuantizeMultiplier(VAR_72,
                     &VAR_2->effective_proj_scale_a,
                     &VAR_2->effective_proj_scale_b);
  QuantizeMultiplier(VAR_73,
                     &VAR_2->effective_hidden_scale_a,
                     &VAR_2->effective_hidden_scale_b);
  QuantizeMultiplier(VAR_55,
                     &VAR_2->layer_norm_input_scale_a,
                     &VAR_2->layer_norm_input_scale_b);
  QuantizeMultiplier(VAR_56,
                     &VAR_2->layer_norm_forget_scale_a,
                     &VAR_2->layer_norm_forget_scale_b);
  QuantizeMultiplier(VAR_57,
                     &VAR_2->layer_norm_cell_scale_a,
                     &VAR_2->layer_norm_cell_scale_b);
  QuantizeMultiplier(VAR_58,
                     &VAR_2->layer_norm_output_scale_a,
                     &VAR_2->layer_norm_output_scale_b);

  VAR_2->hidden_zp = VAR_36[4];

  /* COMMENT_15 */
  if (!VAR_32) {
    VAR_2->input_variance_guard =
        std::max(1, VAR_4<int32_t>(10000 * VAR_55));
  }
  VAR_2->forget_variance_guard =
      std::max(1, VAR_4<int32_t>(10000 * VAR_56));
  VAR_2->cell_variance_guard =
      std::max(1, VAR_4<int32_t>(10000 * VAR_57));
  VAR_2->output_variance_guard =
      std::max(1, VAR_4<int32_t>(10000 * VAR_58));

  return VAR_74;
}",tensorflow/4a91f2069f7145aab6ba2d8cfe41be8a110c18a5/unidirectional_sequence_lstm.cc/vul/after/1.json,"--- func_before
+++ func_after
@@ -15,8 +15,12 @@
       context,
       GetOutputSafe(context, node, lstm::full::kOutputTensor, &output_tensor));
 
+  TF_LITE_ENSURE(context,
+                 cell_state->quantization.type != kTfLiteNoQuantization);
   auto* cell_state_params =
       static_cast<TfLiteAffineQuantization*>(cell_state->quantization.params);
+  TF_LITE_ENSURE(context,
+                 output_tensor->quantization.type != kTfLiteNoQuantization);
   auto* proj_params = static_cast<TfLiteAffineQuantization*>(
       output_tensor->quantization.params);
   if (cell_clip > 0.0) {
@@ -113,6 +117,8 @@
       TfLiteTensor* intermediate;
       TF_LITE_ENSURE_OK(context,
                         GetIntermediatesSafe(context, node, i, &intermediate));
+      TF_LITE_ENSURE(context,
+                     intermediate->quantization.type != kTfLiteNoQuantization);
       auto* params = static_cast<TfLiteAffineQuantization*>(
           intermediate->quantization.params);
       intermediate_scale.push_back(params->scale->data[0]);
@@ -127,6 +133,7 @@
   // is ignored.
   TfLiteTensor* hidden;
   TF_LITE_ENSURE_OK(context, GetIntermediatesSafe(context, node, 4, &hidden));
+  TF_LITE_ENSURE(context, hidden->quantization.type != kTfLiteNoQuantization);
   auto* hidden_params =
       static_cast<TfLiteAffineQuantization*>(hidden->quantization.params);
   intermediate_scale.push_back(hidden_params->scale->data[0]);","{'deleted_lines': [], 'added_lines': ['  TF_LITE_ENSURE(context,', '                 cell_state->quantization.type != kTfLiteNoQuantization);', '  TF_LITE_ENSURE(context,', '                 output_tensor->quantization.type != kTfLiteNoQuantization);', '      TF_LITE_ENSURE(context,', '                     intermediate->quantization.type != kTfLiteNoQuantization);', '  TF_LITE_ENSURE(context, hidden->quantization.type != kTfLiteNoQuantization);']}",True,"TensorFlow is an end-to-end open source platform for machine learning. In affected versions all TFLite operations that use quantization can be made to use unitialized values. [For example](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/depthwise_conv.cc#L198-L200). The issue stems from the fact that `quantization.params` is only valid if `quantization.type` is different that `kTfLiteNoQuantization`. However, these checks are missing in large parts of the code. We have patched the issue in GitHub commits 537bc7c723439b9194a358f64d871dd326c18887, 4a91f2069f7145aab6ba2d8cfe41be8a110c18a5 and 8933b8a21280696ab119b63263babdb54c298538. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",4.4,MEDIUM,1,valid,2021-07-16T16:59:39Z,3
CVE-2021-37682,['CWE-908'],AV:L/AC:L/Au:N/C:N/I:P/A:P,0,tensorflow,"Fix a null pointer exception caused by branching on uninitialized data.

This is due to not checking that the params for the quantization exists. If there is no quantization, we should not access the `.params` field.

PiperOrigin-RevId: 385173491
Change-Id: I8fc476c4b274fdb21ba741caa0fbc6d1b8840663",8933b8a21280696ab119b63263babdb54c298538,https://github.com/tensorflow/tensorflow/commit/8933b8a21280696ab119b63263babdb54c298538,tensorflow/lite/kernels/depthwise_conv.cc,EvalHybridPerChannel,"TfLiteStatus EvalHybridPerChannel(TfLiteContext* context, TfLiteNode* node,
TfLiteDepthwiseConvParams* params,
OpData* data, const TfLiteTensor* input,
const TfLiteTensor* filter,
const TfLiteTensor* bias,
TfLiteTensor* output) {
float output_activation_min, output_activation_max;
CalculateActivationRange(params->activation, &output_activation_min,
&output_activation_max);
const int batch_size = SizeOfDimension(input, 0);
TF_LITE_ENSURE(context, batch_size != 0);
const int input_size = NumElements(input) / batch_size;
TfLiteTensor* input_quantized;
TF_LITE_ENSURE_OK(context,
GetTemporarySafe(context, node, data->input_quantized_index,
&input_quantized));
int8_t* quantized_input_ptr_batch = input_quantized->data.int8;
TfLiteTensor* scaling_factors_tensor;
TF_LITE_ENSURE_OK(context,
GetTemporarySafe(context, node, data->scaling_factors_index,
&scaling_factors_tensor));
float* scaling_factors_ptr = GetTensorData<float>(scaling_factors_tensor);
TfLiteTensor* input_offset_tensor;
TF_LITE_ENSURE_OK(context,
GetTemporarySafe(context, node, data->input_offset_index,
&input_offset_tensor));
int32_t* input_offset_ptr = GetTensorData<int32_t>(input_offset_tensor);
for (int b = 0; b < batch_size; ++b) {
const int offset = b * input_size;
tensor_utils::AsymmetricQuantizeFloats(
GetTensorData<float>(input) + offset, input_size,
quantized_input_ptr_batch + offset, &scaling_factors_ptr[b],
&input_offset_ptr[b]);
}
DepthwiseParams op_params;
op_params.padding_type = PaddingType::kSame;
op_params.padding_values.width = data->padding.width;
op_params.padding_values.height = data->padding.height;
op_params.stride_width = params->stride_width;
op_params.stride_height = params->stride_height;
op_params.dilation_width_factor = params->dilation_width_factor;
op_params.dilation_height_factor = params->dilation_height_factor;
op_params.depth_multiplier = params->depth_multiplier;
op_params.weights_offset = 0;
op_params.float_activation_min = output_activation_min;
op_params.float_activation_max = output_activation_max;
const auto* affine_quantization =
reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params);
if (kernel_type == kReference) {
reference_integer_ops::DepthwiseConvHybridPerChannel(
op_params, scaling_factors_ptr, GetTensorShape(input),
quantized_input_ptr_batch, GetTensorShape(filter),
GetTensorData<int8>(filter), GetTensorShape(bias),
GetTensorData<float>(bias), GetTensorShape(output),
GetTensorData<float>(output), affine_quantization->scale->data,
input_offset_ptr);
} else {
optimized_integer_ops::DepthwiseConvHybridPerChannel(
op_params, scaling_factors_ptr, GetTensorShape(input),
quantized_input_ptr_batch, GetTensorShape(filter),
GetTensorData<int8>(filter), GetTensorShape(bias),
GetTensorData<float>(bias), GetTensorShape(output),
GetTensorData<float>(output), affine_quantization->scale->data,
input_offset_ptr, CpuBackendContext::GetFromContext(context));
}
return kTfLiteOk;
}","TfLiteStatus EvalHybridPerChannel(TfLiteContext* VAR_0, TfLiteNode* VAR_1,
TfLiteDepthwiseConvParams* VAR_2,
OpData* VAR_3, const TfLiteTensor* VAR_4,
const TfLiteTensor* VAR_5,
const TfLiteTensor* VAR_6,
TfLiteTensor* VAR_7) {
float VAR_8, VAR_9;
CalculateActivationRange(VAR_2->activation, &VAR_8,
&VAR_9);
const int VAR_10 = SizeOfDimension(VAR_4, 0);
TF_LITE_ENSURE(VAR_0, VAR_10 != 0);
const int VAR_11 = NumElements(VAR_4) / VAR_10;
TfLiteTensor* VAR_12;
TF_LITE_ENSURE_OK(VAR_0,
GetTemporarySafe(VAR_0, VAR_1, VAR_3->input_quantized_index,
&VAR_12));
int8_t* VAR_13 = VAR_12->data.int8;
TfLiteTensor* VAR_14;
TF_LITE_ENSURE_OK(VAR_0,
GetTemporarySafe(VAR_0, VAR_1, VAR_3->scaling_factors_index,
&VAR_14));
float* VAR_15 = VAR_16<float>(VAR_14);
TfLiteTensor* VAR_17;
TF_LITE_ENSURE_OK(VAR_0,
GetTemporarySafe(VAR_0, VAR_1, VAR_3->input_offset_index,
&VAR_17));
int32_t* VAR_18 = VAR_16<int32_t>(VAR_17);
for (int VAR_19 = 0; VAR_19 < VAR_10; ++VAR_19) {
const int VAR_20 = VAR_19 * VAR_11;
tensor_utils::AsymmetricQuantizeFloats(
VAR_16<float>(VAR_4) + VAR_20, VAR_11,
VAR_13 + VAR_20, &VAR_15[VAR_19],
&VAR_18[VAR_19]);
}
DepthwiseParams VAR_21;
VAR_21.padding_type = PaddingType::kSame;
VAR_21.padding_values.width = VAR_3->padding.width;
VAR_21.padding_values.height = VAR_3->padding.height;
VAR_21.stride_width = VAR_2->stride_width;
VAR_21.stride_height = VAR_2->stride_height;
VAR_21.dilation_width_factor = VAR_2->dilation_width_factor;
VAR_21.dilation_height_factor = VAR_2->dilation_height_factor;
VAR_21.depth_multiplier = VAR_2->depth_multiplier;
VAR_21.weights_offset = 0;
VAR_21.float_activation_min = VAR_8;
VAR_21.float_activation_max = VAR_9;
const auto* VAR_22 =
VAR_23<TfLiteAffineQuantization*>(VAR_5->quantization.params);
if (VAR_24 == VAR_25) {
reference_integer_ops::DepthwiseConvHybridPerChannel(
VAR_21, VAR_15, GetTensorShape(VAR_4),
VAR_13, GetTensorShape(VAR_5),
VAR_16<int8>(VAR_5), GetTensorShape(VAR_6),
VAR_16<float>(VAR_6), GetTensorShape(VAR_7),
VAR_16<float>(VAR_7), VAR_22->scale->data,
VAR_18);
} else {
optimized_integer_ops::DepthwiseConvHybridPerChannel(
VAR_21, VAR_15, GetTensorShape(VAR_4),
VAR_13, GetTensorShape(VAR_5),
VAR_16<int8>(VAR_5), GetTensorShape(VAR_6),
VAR_16<float>(VAR_6), GetTensorShape(VAR_7),
VAR_16<float>(VAR_7), VAR_22->scale->data,
VAR_18, CpuBackendContext::GetFromContext(VAR_0));
}
return VAR_26;
}",tensorflow/8933b8a21280696ab119b63263babdb54c298538/depthwise_conv.cc/vul/before/0.json,"TfLiteStatus EvalHybridPerChannel(TfLiteContext* context, TfLiteNode* node,
                                  TfLiteDepthwiseConvParams* params,
                                  OpData* data, const TfLiteTensor* input,
                                  const TfLiteTensor* filter,
                                  const TfLiteTensor* bias,
                                  TfLiteTensor* output) {
  float output_activation_min, output_activation_max;
  CalculateActivationRange(params->activation, &output_activation_min,
                           &output_activation_max);
  const int batch_size = SizeOfDimension(input, 0);
  TF_LITE_ENSURE(context, batch_size != 0);
  const int input_size = NumElements(input) / batch_size;
  TfLiteTensor* input_quantized;
  TF_LITE_ENSURE_OK(context,
                    GetTemporarySafe(context, node, data->input_quantized_index,
                                     &input_quantized));
  int8_t* quantized_input_ptr_batch = input_quantized->data.int8;
  TfLiteTensor* scaling_factors_tensor;
  TF_LITE_ENSURE_OK(context,
                    GetTemporarySafe(context, node, data->scaling_factors_index,
                                     &scaling_factors_tensor));
  float* scaling_factors_ptr = GetTensorData<float>(scaling_factors_tensor);
  TfLiteTensor* input_offset_tensor;
  TF_LITE_ENSURE_OK(context,
                    GetTemporarySafe(context, node, data->input_offset_index,
                                     &input_offset_tensor));
  int32_t* input_offset_ptr = GetTensorData<int32_t>(input_offset_tensor);

  for (int b = 0; b < batch_size; ++b) {
    const int offset = b * input_size;
    tensor_utils::AsymmetricQuantizeFloats(
        GetTensorData<float>(input) + offset, input_size,
        quantized_input_ptr_batch + offset, &scaling_factors_ptr[b],
        &input_offset_ptr[b]);
  }

  DepthwiseParams op_params;
  op_params.padding_type = PaddingType::kSame;
  op_params.padding_values.width = data->padding.width;
  op_params.padding_values.height = data->padding.height;
  op_params.stride_width = params->stride_width;
  op_params.stride_height = params->stride_height;
  op_params.dilation_width_factor = params->dilation_width_factor;
  op_params.dilation_height_factor = params->dilation_height_factor;
  op_params.depth_multiplier = params->depth_multiplier;

  op_params.weights_offset = 0;
  op_params.float_activation_min = output_activation_min;
  op_params.float_activation_max = output_activation_max;
  TF_LITE_ENSURE(context, filter->quantization.type != kTfLiteNoQuantization);
  const auto* affine_quantization =
      reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params);
  if (kernel_type == kReference) {
    reference_integer_ops::DepthwiseConvHybridPerChannel(
        op_params, scaling_factors_ptr, GetTensorShape(input),
        quantized_input_ptr_batch, GetTensorShape(filter),
        GetTensorData<int8>(filter), GetTensorShape(bias),
        GetTensorData<float>(bias), GetTensorShape(output),
        GetTensorData<float>(output), affine_quantization->scale->data,
        input_offset_ptr);
  } else {
    optimized_integer_ops::DepthwiseConvHybridPerChannel(
        op_params, scaling_factors_ptr, GetTensorShape(input),
        quantized_input_ptr_batch, GetTensorShape(filter),
        GetTensorData<int8>(filter), GetTensorShape(bias),
        GetTensorData<float>(bias), GetTensorShape(output),
        GetTensorData<float>(output), affine_quantization->scale->data,
        input_offset_ptr, CpuBackendContext::GetFromContext(context));
  }

  return kTfLiteOk;
}","TfLiteStatus EvalHybridPerChannel(TfLiteContext* VAR_0, TfLiteNode* VAR_1,
                                  TfLiteDepthwiseConvParams* VAR_2,
                                  OpData* VAR_3, const TfLiteTensor* VAR_4,
                                  const TfLiteTensor* VAR_5,
                                  const TfLiteTensor* VAR_6,
                                  TfLiteTensor* VAR_7) {
  float VAR_8, VAR_9;
  CalculateActivationRange(VAR_2->activation, &VAR_8,
                           &VAR_9);
  const int VAR_10 = SizeOfDimension(VAR_4, 0);
  TF_LITE_ENSURE(VAR_0, VAR_10 != 0);
  const int VAR_11 = NumElements(VAR_4) / VAR_10;
  TfLiteTensor* VAR_12;
  TF_LITE_ENSURE_OK(VAR_0,
                    GetTemporarySafe(VAR_0, VAR_1, VAR_3->input_quantized_index,
                                     &VAR_12));
  int8_t* VAR_13 = VAR_12->data.int8;
  TfLiteTensor* VAR_14;
  TF_LITE_ENSURE_OK(VAR_0,
                    GetTemporarySafe(VAR_0, VAR_1, VAR_3->scaling_factors_index,
                                     &VAR_14));
  float* VAR_15 = VAR_16<float>(VAR_14);
  TfLiteTensor* VAR_17;
  TF_LITE_ENSURE_OK(VAR_0,
                    GetTemporarySafe(VAR_0, VAR_1, VAR_3->input_offset_index,
                                     &VAR_17));
  int32_t* VAR_18 = VAR_16<int32_t>(VAR_17);

  for (int VAR_19 = 0; VAR_19 < VAR_10; ++VAR_19) {
    const int VAR_20 = VAR_19 * VAR_11;
    tensor_utils::AsymmetricQuantizeFloats(
        VAR_16<float>(VAR_4) + VAR_20, VAR_11,
        VAR_13 + VAR_20, &VAR_15[VAR_19],
        &VAR_18[VAR_19]);
  }

  DepthwiseParams VAR_21;
  VAR_21.padding_type = PaddingType::kSame;
  VAR_21.padding_values.width = VAR_3->padding.width;
  VAR_21.padding_values.height = VAR_3->padding.height;
  VAR_21.stride_width = VAR_2->stride_width;
  VAR_21.stride_height = VAR_2->stride_height;
  VAR_21.dilation_width_factor = VAR_2->dilation_width_factor;
  VAR_21.dilation_height_factor = VAR_2->dilation_height_factor;
  VAR_21.depth_multiplier = VAR_2->depth_multiplier;

  VAR_21.weights_offset = 0;
  VAR_21.float_activation_min = VAR_8;
  VAR_21.float_activation_max = VAR_9;
  TF_LITE_ENSURE(VAR_0, VAR_5->quantization.type != VAR_22);
  const auto* VAR_23 =
      VAR_24<TfLiteAffineQuantization*>(VAR_5->quantization.params);
  if (VAR_25 == VAR_26) {
    reference_integer_ops::DepthwiseConvHybridPerChannel(
        VAR_21, VAR_15, GetTensorShape(VAR_4),
        VAR_13, GetTensorShape(VAR_5),
        VAR_16<int8>(VAR_5), GetTensorShape(VAR_6),
        VAR_16<float>(VAR_6), GetTensorShape(VAR_7),
        VAR_16<float>(VAR_7), VAR_23->scale->data,
        VAR_18);
  } else {
    optimized_integer_ops::DepthwiseConvHybridPerChannel(
        VAR_21, VAR_15, GetTensorShape(VAR_4),
        VAR_13, GetTensorShape(VAR_5),
        VAR_16<int8>(VAR_5), GetTensorShape(VAR_6),
        VAR_16<float>(VAR_6), GetTensorShape(VAR_7),
        VAR_16<float>(VAR_7), VAR_23->scale->data,
        VAR_18, CpuBackendContext::GetFromContext(VAR_0));
  }

  return VAR_27;
}",tensorflow/8933b8a21280696ab119b63263babdb54c298538/depthwise_conv.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -47,6 +47,7 @@
   op_params.weights_offset = 0;
   op_params.float_activation_min = output_activation_min;
   op_params.float_activation_max = output_activation_max;
+  TF_LITE_ENSURE(context, filter->quantization.type != kTfLiteNoQuantization);
   const auto* affine_quantization =
       reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params);
   if (kernel_type == kReference) {","{'deleted_lines': [], 'added_lines': ['  TF_LITE_ENSURE(context, filter->quantization.type != kTfLiteNoQuantization);']}",True,"TensorFlow is an end-to-end open source platform for machine learning. In affected versions all TFLite operations that use quantization can be made to use unitialized values. [For example](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/depthwise_conv.cc#L198-L200). The issue stems from the fact that `quantization.params` is only valid if `quantization.type` is different that `kTfLiteNoQuantization`. However, these checks are missing in large parts of the code. We have patched the issue in GitHub commits 537bc7c723439b9194a358f64d871dd326c18887, 4a91f2069f7145aab6ba2d8cfe41be8a110c18a5 and 8933b8a21280696ab119b63263babdb54c298538. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",4.4,MEDIUM,1,valid,2021-07-16T17:22:37Z,3
CVE-2021-37682,['CWE-908'],AV:L/AC:L/Au:N/C:N/I:P/A:P,0,tensorflow,"Fix a null pointer exception caused by branching on uninitialized data.

This is due to not checking that the params for the quantization exists. If there is no quantization, we should not access the `.params` field.

PiperOrigin-RevId: 385173491
Change-Id: I8fc476c4b274fdb21ba741caa0fbc6d1b8840663",8933b8a21280696ab119b63263babdb54c298538,https://github.com/tensorflow/tensorflow/commit/8933b8a21280696ab119b63263babdb54c298538,tensorflow/lite/kernels/depthwise_conv.cc,Prepare,"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
auto* params =
reinterpret_cast<TfLiteDepthwiseConvParams*>(node->builtin_data);
OpData* data = reinterpret_cast<OpData*>(node->user_data);
bool has_bias = NumInputs(node) == 3;
TF_LITE_ENSURE(context, has_bias || NumInputs(node) == 2);
const TfLiteTensor* input;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));
const TfLiteTensor* filter;
TF_LITE_ENSURE_OK(context,
GetInputSafe(context, node, kFilterTensor, &filter));
const TfLiteTensor* bias = nullptr;
TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);
TfLiteTensor* output;
TF_LITE_ENSURE_OK(context,
GetOutputSafe(context, node, kOutputTensor, &output));
TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);
TF_LITE_ENSURE_EQ(context, NumDimensions(filter), 4);
const TfLiteType data_type = input->type;
const TfLiteType filter_type = filter->type;
const bool is_hybrid =
data_type == kTfLiteFloat32 && filter_type == kTfLiteInt8;
TF_LITE_ENSURE(context,
data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 ||
data_type == kTfLiteInt8 || data_type == kTfLiteInt16);
TF_LITE_ENSURE_TYPES_EQ(context, output->type, data_type);
if (!is_hybrid) {
TF_LITE_ENSURE(context,
filter->type == data_type || data_type == kTfLiteInt16);
}
if (data_type == kTfLiteInt16) {
TF_LITE_ENSURE_EQ(context, input->params.zero_point, 0);
TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);
}
TF_LITE_ENSURE_EQ(context, SizeOfDimension(filter, 0), 1);
if (has_bias) {
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kBiasTensor, &bias));
if (data_type == kTfLiteUInt8 || data_type == kTfLiteInt8) {
TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt32);
TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0);
} else if (data_type == kTfLiteInt16) {
TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt64);
TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0);
} else {
TF_LITE_ENSURE_TYPES_EQ(context, bias->type, data_type);
}
TF_LITE_ENSURE_EQ(context, NumDimensions(bias), 1);
TF_LITE_ENSURE_EQ(context, SizeOfDimension(filter, 3),
SizeOfDimension(bias, 0));
}
int channels_out = SizeOfDimension(filter, 3);
int width = SizeOfDimension(input, 2);
int height = SizeOfDimension(input, 1);
int filter_width = SizeOfDimension(filter, 2);
int filter_height = SizeOfDimension(filter, 1);
int batches = SizeOfDimension(input, 0);
auto padding = params->padding;
int out_width, out_height;
data->padding = ComputePaddingHeightWidth(
params->stride_height, params->stride_width,
params->dilation_height_factor, params->dilation_width_factor, height,
width, filter_height, filter_width, padding, &out_height, &out_width);
if (data_type != kTfLiteFloat32) {
TF_LITE_ENSURE_EQ(context, filter->quantization.type,
kTfLiteAffineQuantization);
const auto* affine_quantization =
reinterpret_cast<TfLiteAffineQuantization*>(
filter->quantization.params);
TF_LITE_ENSURE(context, affine_quantization);
TF_LITE_ENSURE(context, affine_quantization->scale);
TF_LITE_ENSURE(context, (affine_quantization->scale->size == 1 ||
affine_quantization->scale->size == channels_out));
data->per_channel_output_multiplier.resize(channels_out);
data->per_channel_output_shift.resize(channels_out);
TF_LITE_ENSURE_STATUS(tflite::PopulateConvolutionQuantizationParams(
context, input, filter, bias, output, params->activation,
&data->output_multiplier, &data->output_shift,
&data->output_activation_min, &data->output_activation_max,
data->per_channel_output_multiplier.data(),
data->per_channel_output_shift.data(), channels_out));
}
if (is_hybrid) {
const auto* affine_quantization =
reinterpret_cast<TfLiteAffineQuantization*>(
filter->quantization.params);
TF_LITE_ENSURE(context, affine_quantization);
TF_LITE_ENSURE(context, affine_quantization->scale);
TF_LITE_ENSURE_EQ(
context, affine_quantization->scale->size,
filter->dims->data[affine_quantization->quantized_dimension]);
int temporaries_count = 0;
data->input_quantized_index = temporaries_count;
if (data->input_quantized_id == kTensorNotAllocated) {
TF_LITE_ENSURE_OK(
context, context->AddTensors(context, 1, &data->input_quantized_id));
}
++temporaries_count;
data->scaling_factors_index = temporaries_count;
if (data->scaling_factors_id == kTensorNotAllocated) {
TF_LITE_ENSURE_OK(
context, context->AddTensors(context, 1, &data->scaling_factors_id));
}
++temporaries_count;
data->input_offset_index = temporaries_count;
if (data->input_offset_id == kTensorNotAllocated) {
TF_LITE_ENSURE_OK(
context, context->AddTensors(context, 1, &data->input_offset_id));
}
++temporaries_count;
TfLiteIntArrayFree(node->temporaries);
node->temporaries = TfLiteIntArrayCreate(temporaries_count);
node->temporaries->data[data->input_quantized_index] =
data->input_quantized_id;
TfLiteTensor* input_quantized;
TF_LITE_ENSURE_OK(
context, GetTemporarySafe(context, node, data->input_quantized_index,
&input_quantized));
input_quantized->type = kTfLiteInt8;
input_quantized->allocation_type = kTfLiteArenaRw;
if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {
TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);
TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,
input_quantized_size));
}
node->temporaries->data[data->scaling_factors_index] =
data->scaling_factors_id;
TfLiteTensor* scaling_factors;
TF_LITE_ENSURE_OK(
context, GetTemporarySafe(context, node, data->scaling_factors_index,
&scaling_factors));
scaling_factors->type = kTfLiteFloat32;
scaling_factors->allocation_type = kTfLiteArenaRw;
const int batch_size = SizeOfDimension(input, 0);
int scaling_dims[1] = {batch_size};
if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {
TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);
scaling_factors_size->data[0] = batch_size;
TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,
scaling_factors_size));
}
node->temporaries->data[data->input_offset_index] = data->input_offset_id;
TfLiteTensor* input_offsets;
TF_LITE_ENSURE_OK(context,
GetTemporarySafe(context, node, data->input_offset_index,
&input_offsets));
input_offsets->type = kTfLiteInt32;
input_offsets->allocation_type = kTfLiteArenaRw;
if (!TfLiteIntArrayEqualsArray(input_offsets->dims, 1, scaling_dims)) {
TfLiteIntArray* input_offsets_size = TfLiteIntArrayCreate(1);
input_offsets_size->data[0] = batch_size;
TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_offsets,
input_offsets_size));
}
}
TfLiteIntArray* outputSize = TfLiteIntArrayCreate(4);
outputSize->data[0] = batches;
outputSize->data[1] = out_height;
outputSize->data[2] = out_width;
outputSize->data[3] = channels_out;
return context->ResizeTensor(context, output, outputSize);
}","TfLiteStatus Prepare(TfLiteContext* VAR_0, TfLiteNode* VAR_1) {
auto* VAR_2 =
VAR_3<TfLiteDepthwiseConvParams*>(VAR_1->builtin_data);
OpData* VAR_4 = VAR_3<OpData*>(VAR_1->user_data);
bool VAR_5 = NumInputs(VAR_1) == 3;
TF_LITE_ENSURE(VAR_0, VAR_5 || NumInputs(VAR_1) == 2);
const TfLiteTensor* VAR_6;
TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_7, &VAR_6));
const TfLiteTensor* VAR_8;
TF_LITE_ENSURE_OK(VAR_0,
GetInputSafe(VAR_0, VAR_1, VAR_9, &VAR_8));
const TfLiteTensor* VAR_10 = nullptr;
TF_LITE_ENSURE_EQ(VAR_0, NumOutputs(VAR_1), 1);
TfLiteTensor* VAR_11;
TF_LITE_ENSURE_OK(VAR_0,
GetOutputSafe(VAR_0, VAR_1, VAR_12, &VAR_11));
TF_LITE_ENSURE_EQ(VAR_0, NumDimensions(VAR_6), 4);
TF_LITE_ENSURE_EQ(VAR_0, NumDimensions(VAR_8), 4);
const TfLiteType VAR_13 = VAR_6->type;
const TfLiteType VAR_14 = VAR_8->type;
const bool VAR_15 =
VAR_13 == VAR_16 && VAR_14 == VAR_17;
TF_LITE_ENSURE(VAR_0,
VAR_13 == VAR_16 || VAR_13 == VAR_18 ||
VAR_13 == VAR_17 || VAR_13 == VAR_19);
TF_LITE_ENSURE_TYPES_EQ(VAR_0, VAR_11->type, VAR_13);
if (!VAR_15) {
TF_LITE_ENSURE(VAR_0,
VAR_8->type == VAR_13 || VAR_13 == VAR_19);
}
if (VAR_13 == VAR_19) {
TF_LITE_ENSURE_EQ(VAR_0, VAR_6->params.zero_point, 0);
TF_LITE_ENSURE_EQ(VAR_0, VAR_11->params.zero_point, 0);
}
TF_LITE_ENSURE_EQ(VAR_0, SizeOfDimension(VAR_8, 0), 1);
if (VAR_5) {
TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_20, &VAR_10));
if (VAR_13 == VAR_18 || VAR_13 == VAR_17) {
TF_LITE_ENSURE_TYPES_EQ(VAR_0, VAR_10->type, VAR_21);
TF_LITE_ENSURE_EQ(VAR_0, VAR_10->params.zero_point, 0);
} else if (VAR_13 == VAR_19) {
TF_LITE_ENSURE_TYPES_EQ(VAR_0, VAR_10->type, VAR_22);
TF_LITE_ENSURE_EQ(VAR_0, VAR_10->params.zero_point, 0);
} else {
TF_LITE_ENSURE_TYPES_EQ(VAR_0, VAR_10->type, VAR_13);
}
TF_LITE_ENSURE_EQ(VAR_0, NumDimensions(VAR_10), 1);
TF_LITE_ENSURE_EQ(VAR_0, SizeOfDimension(VAR_8, 3),
SizeOfDimension(VAR_10, 0));
}
int VAR_23 = SizeOfDimension(VAR_8, 3);
int VAR_24 = SizeOfDimension(VAR_6, 2);
int VAR_25 = SizeOfDimension(VAR_6, 1);
int VAR_26 = SizeOfDimension(VAR_8, 2);
int VAR_27 = SizeOfDimension(VAR_8, 1);
int VAR_28 = SizeOfDimension(VAR_6, 0);
auto VAR_29 = VAR_2->padding;
int VAR_30, VAR_31;
VAR_4->padding = ComputePaddingHeightWidth(
VAR_2->stride_height, VAR_2->stride_width,
VAR_2->dilation_height_factor, VAR_2->dilation_width_factor, VAR_25,
VAR_24, VAR_27, VAR_26, VAR_29, &VAR_31, &VAR_30);
if (VAR_13 != VAR_16) {
TF_LITE_ENSURE_EQ(VAR_0, VAR_8->quantization.type,
VAR_32);
const auto* VAR_33 =
VAR_3<TfLiteAffineQuantization*>(
VAR_8->quantization.params);
TF_LITE_ENSURE(VAR_0, VAR_33);
TF_LITE_ENSURE(VAR_0, VAR_33->scale);
TF_LITE_ENSURE(VAR_0, (VAR_33->scale->size == 1 ||
VAR_33->scale->size == VAR_23));
VAR_4->per_channel_output_multiplier.resize(VAR_23);
VAR_4->per_channel_output_shift.resize(VAR_23);
TF_LITE_ENSURE_STATUS(tflite::PopulateConvolutionQuantizationParams(
VAR_0, VAR_6, VAR_8, VAR_10, VAR_11, VAR_2->activation,
&VAR_4->output_multiplier, &VAR_4->output_shift,
&VAR_4->output_activation_min, &VAR_4->output_activation_max,
VAR_4->per_channel_output_multiplier.data(),
VAR_4->per_channel_output_shift.data(), VAR_23));
}
if (VAR_15) {
const auto* VAR_33 =
VAR_3<TfLiteAffineQuantization*>(
VAR_8->quantization.params);
TF_LITE_ENSURE(VAR_0, VAR_33);
TF_LITE_ENSURE(VAR_0, VAR_33->scale);
TF_LITE_ENSURE_EQ(
VAR_0, VAR_33->scale->size,
VAR_8->dims->data[VAR_33->quantized_dimension]);
int VAR_34 = 0;
VAR_4->input_quantized_index = VAR_34;
if (VAR_4->input_quantized_id == VAR_35) {
TF_LITE_ENSURE_OK(
VAR_0, VAR_0->AddTensors(VAR_0, 1, &VAR_4->input_quantized_id));
}
++VAR_34;
VAR_4->scaling_factors_index = VAR_34;
if (VAR_4->scaling_factors_id == VAR_35) {
TF_LITE_ENSURE_OK(
VAR_0, VAR_0->AddTensors(VAR_0, 1, &VAR_4->scaling_factors_id));
}
++VAR_34;
VAR_4->input_offset_index = VAR_34;
if (VAR_4->input_offset_id == VAR_35) {
TF_LITE_ENSURE_OK(
VAR_0, VAR_0->AddTensors(VAR_0, 1, &VAR_4->input_offset_id));
}
++VAR_34;
TfLiteIntArrayFree(VAR_1->temporaries);
VAR_1->temporaries = TfLiteIntArrayCreate(VAR_34);
VAR_1->temporaries->data[VAR_4->input_quantized_index] =
VAR_4->input_quantized_id;
TfLiteTensor* VAR_36;
TF_LITE_ENSURE_OK(
VAR_0, GetTemporarySafe(VAR_0, VAR_1, VAR_4->input_quantized_index,
&VAR_36));
VAR_36->type = VAR_17;
VAR_36->allocation_type = VAR_37;
if (!TfLiteIntArrayEqual(VAR_36->dims, VAR_6->dims)) {
TfLiteIntArray* VAR_38 = TfLiteIntArrayCopy(VAR_6->dims);
TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_36,
VAR_38));
}
VAR_1->temporaries->data[VAR_4->scaling_factors_index] =
VAR_4->scaling_factors_id;
TfLiteTensor* VAR_39;
TF_LITE_ENSURE_OK(
VAR_0, GetTemporarySafe(VAR_0, VAR_1, VAR_4->scaling_factors_index,
&VAR_39));
VAR_39->type = VAR_16;
VAR_39->allocation_type = VAR_37;
const int VAR_40 = SizeOfDimension(VAR_6, 0);
int VAR_41[1] = {VAR_40};
if (!TfLiteIntArrayEqualsArray(VAR_39->dims, 1, VAR_41)) {
TfLiteIntArray* VAR_42 = TfLiteIntArrayCreate(1);
VAR_42->data[0] = VAR_40;
TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_39,
VAR_42));
}
VAR_1->temporaries->data[VAR_4->input_offset_index] = VAR_4->input_offset_id;
TfLiteTensor* VAR_43;
TF_LITE_ENSURE_OK(VAR_0,
GetTemporarySafe(VAR_0, VAR_1, VAR_4->input_offset_index,
&VAR_43));
VAR_43->type = VAR_21;
VAR_43->allocation_type = VAR_37;
if (!TfLiteIntArrayEqualsArray(VAR_43->dims, 1, VAR_41)) {
TfLiteIntArray* VAR_44 = TfLiteIntArrayCreate(1);
VAR_44->data[0] = VAR_40;
TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_43,
VAR_44));
}
}
TfLiteIntArray* VAR_45 = TfLiteIntArrayCreate(4);
VAR_45->data[0] = VAR_28;
VAR_45->data[1] = VAR_31;
VAR_45->data[2] = VAR_30;
VAR_45->data[3] = VAR_23;
return VAR_0->ResizeTensor(VAR_0, VAR_11, VAR_45);
}",tensorflow/8933b8a21280696ab119b63263babdb54c298538/depthwise_conv.cc/vul/before/1.json,"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
  auto* params =
      reinterpret_cast<TfLiteDepthwiseConvParams*>(node->builtin_data);
  OpData* data = reinterpret_cast<OpData*>(node->user_data);

  bool has_bias = NumInputs(node) == 3;

  TF_LITE_ENSURE(context, has_bias || NumInputs(node) == 2);
  const TfLiteTensor* input;
  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));
  const TfLiteTensor* filter;
  TF_LITE_ENSURE_OK(context,
                    GetInputSafe(context, node, kFilterTensor, &filter));
  const TfLiteTensor* bias = nullptr;

  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);
  TfLiteTensor* output;
  TF_LITE_ENSURE_OK(context,
                    GetOutputSafe(context, node, kOutputTensor, &output));

  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);
  TF_LITE_ENSURE_EQ(context, NumDimensions(filter), 4);

  const TfLiteType data_type = input->type;

  const TfLiteType filter_type = filter->type;
  const bool is_hybrid =
      data_type == kTfLiteFloat32 && filter_type == kTfLiteInt8;
  TF_LITE_ENSURE(context,
                 data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 ||
                     data_type == kTfLiteInt8 || data_type == kTfLiteInt16);
  TF_LITE_ENSURE_TYPES_EQ(context, output->type, data_type);
  if (!is_hybrid) {
    TF_LITE_ENSURE(context,
                   filter->type == data_type || data_type == kTfLiteInt16);
  }

  if (data_type == kTfLiteInt16) {
    TF_LITE_ENSURE_EQ(context, input->params.zero_point, 0);
    TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);
  }

  // Filter in DepthwiseConv is expected to be [1, H, W, O].
  TF_LITE_ENSURE_EQ(context, SizeOfDimension(filter, 0), 1);

  if (has_bias) {
    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kBiasTensor, &bias));
    if (data_type == kTfLiteUInt8 || data_type == kTfLiteInt8) {
      TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt32);
      TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0);
    } else if (data_type == kTfLiteInt16) {
      TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt64);
      TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0);
    } else {
      TF_LITE_ENSURE_TYPES_EQ(context, bias->type, data_type);
    }
    TF_LITE_ENSURE_EQ(context, NumDimensions(bias), 1);
    TF_LITE_ENSURE_EQ(context, SizeOfDimension(filter, 3),
                      SizeOfDimension(bias, 0));
  }

  int channels_out = SizeOfDimension(filter, 3);
  int width = SizeOfDimension(input, 2);
  int height = SizeOfDimension(input, 1);
  int filter_width = SizeOfDimension(filter, 2);
  int filter_height = SizeOfDimension(filter, 1);
  int batches = SizeOfDimension(input, 0);

  // Matching GetWindowedOutputSize in TensorFlow.
  auto padding = params->padding;
  int out_width, out_height;

  data->padding = ComputePaddingHeightWidth(
      params->stride_height, params->stride_width,
      params->dilation_height_factor, params->dilation_width_factor, height,
      width, filter_height, filter_width, padding, &out_height, &out_width);

  // Note that quantized inference requires that all tensors have their
  // parameters set. This is usually done during quantized training or
  // calibration.
  if (data_type != kTfLiteFloat32) {
    TF_LITE_ENSURE_EQ(context, filter->quantization.type,
                      kTfLiteAffineQuantization);
    TF_LITE_ENSURE(context, filter->quantization.type != kTfLiteNoQuantization);
    const auto* affine_quantization =
        reinterpret_cast<TfLiteAffineQuantization*>(
            filter->quantization.params);
    TF_LITE_ENSURE(context, affine_quantization);
    TF_LITE_ENSURE(context, affine_quantization->scale);
    TF_LITE_ENSURE(context, (affine_quantization->scale->size == 1 ||
                             affine_quantization->scale->size == channels_out));

    data->per_channel_output_multiplier.resize(channels_out);
    data->per_channel_output_shift.resize(channels_out);
    TF_LITE_ENSURE_STATUS(tflite::PopulateConvolutionQuantizationParams(
        context, input, filter, bias, output, params->activation,
        &data->output_multiplier, &data->output_shift,
        &data->output_activation_min, &data->output_activation_max,
        data->per_channel_output_multiplier.data(),
        data->per_channel_output_shift.data(), channels_out));
  }

  if (is_hybrid) {
    TF_LITE_ENSURE(context, filter->quantization.type != kTfLiteNoQuantization);
    const auto* affine_quantization =
        reinterpret_cast<TfLiteAffineQuantization*>(
            filter->quantization.params);
    TF_LITE_ENSURE(context, affine_quantization);
    TF_LITE_ENSURE(context, affine_quantization->scale);
    TF_LITE_ENSURE_EQ(
        context, affine_quantization->scale->size,
        filter->dims->data[affine_quantization->quantized_dimension]);

    int temporaries_count = 0;
    data->input_quantized_index = temporaries_count;
    if (data->input_quantized_id == kTensorNotAllocated) {
      TF_LITE_ENSURE_OK(
          context, context->AddTensors(context, 1, &data->input_quantized_id));
    }
    ++temporaries_count;
    data->scaling_factors_index = temporaries_count;
    if (data->scaling_factors_id == kTensorNotAllocated) {
      TF_LITE_ENSURE_OK(
          context, context->AddTensors(context, 1, &data->scaling_factors_id));
    }
    ++temporaries_count;
    data->input_offset_index = temporaries_count;
    if (data->input_offset_id == kTensorNotAllocated) {
      TF_LITE_ENSURE_OK(
          context, context->AddTensors(context, 1, &data->input_offset_id));
    }
    ++temporaries_count;

    TfLiteIntArrayFree(node->temporaries);
    node->temporaries = TfLiteIntArrayCreate(temporaries_count);

    node->temporaries->data[data->input_quantized_index] =
        data->input_quantized_id;
    TfLiteTensor* input_quantized;
    TF_LITE_ENSURE_OK(
        context, GetTemporarySafe(context, node, data->input_quantized_index,
                                  &input_quantized));
    input_quantized->type = kTfLiteInt8;
    input_quantized->allocation_type = kTfLiteArenaRw;
    if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {
      TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);
      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,
                                                       input_quantized_size));
    }
    node->temporaries->data[data->scaling_factors_index] =
        data->scaling_factors_id;
    TfLiteTensor* scaling_factors;
    TF_LITE_ENSURE_OK(
        context, GetTemporarySafe(context, node, data->scaling_factors_index,
                                  &scaling_factors));
    scaling_factors->type = kTfLiteFloat32;
    scaling_factors->allocation_type = kTfLiteArenaRw;
    const int batch_size = SizeOfDimension(input, 0);
    int scaling_dims[1] = {batch_size};
    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {
      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);
      scaling_factors_size->data[0] = batch_size;
      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,
                                                       scaling_factors_size));
    }
    node->temporaries->data[data->input_offset_index] = data->input_offset_id;
    TfLiteTensor* input_offsets;
    TF_LITE_ENSURE_OK(context,
                      GetTemporarySafe(context, node, data->input_offset_index,
                                       &input_offsets));
    input_offsets->type = kTfLiteInt32;
    input_offsets->allocation_type = kTfLiteArenaRw;
    if (!TfLiteIntArrayEqualsArray(input_offsets->dims, 1, scaling_dims)) {
      TfLiteIntArray* input_offsets_size = TfLiteIntArrayCreate(1);
      input_offsets_size->data[0] = batch_size;
      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_offsets,
                                                       input_offsets_size));
    }
  }

  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(4);
  outputSize->data[0] = batches;
  outputSize->data[1] = out_height;
  outputSize->data[2] = out_width;
  outputSize->data[3] = channels_out;
  return context->ResizeTensor(context, output, outputSize);
}","TfLiteStatus Prepare(TfLiteContext* VAR_0, TfLiteNode* VAR_1) {
  auto* VAR_2 =
      VAR_3<TfLiteDepthwiseConvParams*>(VAR_1->builtin_data);
  OpData* VAR_4 = VAR_3<OpData*>(VAR_1->user_data);

  bool VAR_5 = NumInputs(VAR_1) == 3;

  TF_LITE_ENSURE(VAR_0, VAR_5 || NumInputs(VAR_1) == 2);
  const TfLiteTensor* VAR_6;
  TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_7, &VAR_6));
  const TfLiteTensor* VAR_8;
  TF_LITE_ENSURE_OK(VAR_0,
                    GetInputSafe(VAR_0, VAR_1, VAR_9, &VAR_8));
  const TfLiteTensor* VAR_10 = nullptr;

  TF_LITE_ENSURE_EQ(VAR_0, NumOutputs(VAR_1), 1);
  TfLiteTensor* VAR_11;
  TF_LITE_ENSURE_OK(VAR_0,
                    GetOutputSafe(VAR_0, VAR_1, VAR_12, &VAR_11));

  TF_LITE_ENSURE_EQ(VAR_0, NumDimensions(VAR_6), 4);
  TF_LITE_ENSURE_EQ(VAR_0, NumDimensions(VAR_8), 4);

  const TfLiteType VAR_13 = VAR_6->type;

  const TfLiteType VAR_14 = VAR_8->type;
  const bool VAR_15 =
      VAR_13 == VAR_16 && VAR_14 == VAR_17;
  TF_LITE_ENSURE(VAR_0,
                 VAR_13 == VAR_16 || VAR_13 == VAR_18 ||
                     VAR_13 == VAR_17 || VAR_13 == VAR_19);
  TF_LITE_ENSURE_TYPES_EQ(VAR_0, VAR_11->type, VAR_13);
  if (!VAR_15) {
    TF_LITE_ENSURE(VAR_0,
                   VAR_8->type == VAR_13 || VAR_13 == VAR_19);
  }

  if (VAR_13 == VAR_19) {
    TF_LITE_ENSURE_EQ(VAR_0, VAR_6->params.zero_point, 0);
    TF_LITE_ENSURE_EQ(VAR_0, VAR_11->params.zero_point, 0);
  }

  /* COMMENT_0 */
  TF_LITE_ENSURE_EQ(VAR_0, SizeOfDimension(VAR_8, 0), 1);

  if (VAR_5) {
    TF_LITE_ENSURE_OK(VAR_0, GetInputSafe(VAR_0, VAR_1, VAR_20, &VAR_10));
    if (VAR_13 == VAR_18 || VAR_13 == VAR_17) {
      TF_LITE_ENSURE_TYPES_EQ(VAR_0, VAR_10->type, VAR_21);
      TF_LITE_ENSURE_EQ(VAR_0, VAR_10->params.zero_point, 0);
    } else if (VAR_13 == VAR_19) {
      TF_LITE_ENSURE_TYPES_EQ(VAR_0, VAR_10->type, VAR_22);
      TF_LITE_ENSURE_EQ(VAR_0, VAR_10->params.zero_point, 0);
    } else {
      TF_LITE_ENSURE_TYPES_EQ(VAR_0, VAR_10->type, VAR_13);
    }
    TF_LITE_ENSURE_EQ(VAR_0, NumDimensions(VAR_10), 1);
    TF_LITE_ENSURE_EQ(VAR_0, SizeOfDimension(VAR_8, 3),
                      SizeOfDimension(VAR_10, 0));
  }

  int VAR_23 = SizeOfDimension(VAR_8, 3);
  int VAR_24 = SizeOfDimension(VAR_6, 2);
  int VAR_25 = SizeOfDimension(VAR_6, 1);
  int VAR_26 = SizeOfDimension(VAR_8, 2);
  int VAR_27 = SizeOfDimension(VAR_8, 1);
  int VAR_28 = SizeOfDimension(VAR_6, 0);

  /* COMMENT_1 */
  auto VAR_29 = VAR_2->padding;
  int VAR_30, VAR_31;

  VAR_4->padding = ComputePaddingHeightWidth(
      VAR_2->stride_height, VAR_2->stride_width,
      VAR_2->dilation_height_factor, VAR_2->dilation_width_factor, VAR_25,
      VAR_24, VAR_27, VAR_26, VAR_29, &VAR_31, &VAR_30);

  /* COMMENT_2 */
  /* COMMENT_3 */
  /* COMMENT_4 */
  if (VAR_13 != VAR_16) {
    TF_LITE_ENSURE_EQ(VAR_0, VAR_8->quantization.type,
                      VAR_32);
    TF_LITE_ENSURE(VAR_0, VAR_8->quantization.type != VAR_33);
    const auto* VAR_34 =
        VAR_3<TfLiteAffineQuantization*>(
            VAR_8->quantization.params);
    TF_LITE_ENSURE(VAR_0, VAR_34);
    TF_LITE_ENSURE(VAR_0, VAR_34->scale);
    TF_LITE_ENSURE(VAR_0, (VAR_34->scale->size == 1 ||
                             VAR_34->scale->size == VAR_23));

    VAR_4->per_channel_output_multiplier.resize(VAR_23);
    VAR_4->per_channel_output_shift.resize(VAR_23);
    TF_LITE_ENSURE_STATUS(tflite::PopulateConvolutionQuantizationParams(
        VAR_0, VAR_6, VAR_8, VAR_10, VAR_11, VAR_2->activation,
        &VAR_4->output_multiplier, &VAR_4->output_shift,
        &VAR_4->output_activation_min, &VAR_4->output_activation_max,
        VAR_4->per_channel_output_multiplier.data(),
        VAR_4->per_channel_output_shift.data(), VAR_23));
  }

  if (VAR_15) {
    TF_LITE_ENSURE(VAR_0, VAR_8->quantization.type != VAR_33);
    const auto* VAR_34 =
        VAR_3<TfLiteAffineQuantization*>(
            VAR_8->quantization.params);
    TF_LITE_ENSURE(VAR_0, VAR_34);
    TF_LITE_ENSURE(VAR_0, VAR_34->scale);
    TF_LITE_ENSURE_EQ(
        VAR_0, VAR_34->scale->size,
        VAR_8->dims->data[VAR_34->quantized_dimension]);

    int VAR_35 = 0;
    VAR_4->input_quantized_index = VAR_35;
    if (VAR_4->input_quantized_id == VAR_36) {
      TF_LITE_ENSURE_OK(
          VAR_0, VAR_0->AddTensors(VAR_0, 1, &VAR_4->input_quantized_id));
    }
    ++VAR_35;
    VAR_4->scaling_factors_index = VAR_35;
    if (VAR_4->scaling_factors_id == VAR_36) {
      TF_LITE_ENSURE_OK(
          VAR_0, VAR_0->AddTensors(VAR_0, 1, &VAR_4->scaling_factors_id));
    }
    ++VAR_35;
    VAR_4->input_offset_index = VAR_35;
    if (VAR_4->input_offset_id == VAR_36) {
      TF_LITE_ENSURE_OK(
          VAR_0, VAR_0->AddTensors(VAR_0, 1, &VAR_4->input_offset_id));
    }
    ++VAR_35;

    TfLiteIntArrayFree(VAR_1->temporaries);
    VAR_1->temporaries = TfLiteIntArrayCreate(VAR_35);

    VAR_1->temporaries->data[VAR_4->input_quantized_index] =
        VAR_4->input_quantized_id;
    TfLiteTensor* VAR_37;
    TF_LITE_ENSURE_OK(
        VAR_0, GetTemporarySafe(VAR_0, VAR_1, VAR_4->input_quantized_index,
                                  &VAR_37));
    VAR_37->type = VAR_17;
    VAR_37->allocation_type = VAR_38;
    if (!TfLiteIntArrayEqual(VAR_37->dims, VAR_6->dims)) {
      TfLiteIntArray* VAR_39 = TfLiteIntArrayCopy(VAR_6->dims);
      TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_37,
                                                       VAR_39));
    }
    VAR_1->temporaries->data[VAR_4->scaling_factors_index] =
        VAR_4->scaling_factors_id;
    TfLiteTensor* VAR_40;
    TF_LITE_ENSURE_OK(
        VAR_0, GetTemporarySafe(VAR_0, VAR_1, VAR_4->scaling_factors_index,
                                  &VAR_40));
    VAR_40->type = VAR_16;
    VAR_40->allocation_type = VAR_38;
    const int VAR_41 = SizeOfDimension(VAR_6, 0);
    int VAR_42[1] = {VAR_41};
    if (!TfLiteIntArrayEqualsArray(VAR_40->dims, 1, VAR_42)) {
      TfLiteIntArray* VAR_43 = TfLiteIntArrayCreate(1);
      VAR_43->data[0] = VAR_41;
      TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_40,
                                                       VAR_43));
    }
    VAR_1->temporaries->data[VAR_4->input_offset_index] = VAR_4->input_offset_id;
    TfLiteTensor* VAR_44;
    TF_LITE_ENSURE_OK(VAR_0,
                      GetTemporarySafe(VAR_0, VAR_1, VAR_4->input_offset_index,
                                       &VAR_44));
    VAR_44->type = VAR_21;
    VAR_44->allocation_type = VAR_38;
    if (!TfLiteIntArrayEqualsArray(VAR_44->dims, 1, VAR_42)) {
      TfLiteIntArray* VAR_45 = TfLiteIntArrayCreate(1);
      VAR_45->data[0] = VAR_41;
      TF_LITE_ENSURE_OK(VAR_0, VAR_0->ResizeTensor(VAR_0, VAR_44,
                                                       VAR_45));
    }
  }

  TfLiteIntArray* VAR_46 = TfLiteIntArrayCreate(4);
  VAR_46->data[0] = VAR_28;
  VAR_46->data[1] = VAR_31;
  VAR_46->data[2] = VAR_30;
  VAR_46->data[3] = VAR_23;
  return VAR_0->ResizeTensor(VAR_0, VAR_11, VAR_46);
}",tensorflow/8933b8a21280696ab119b63263babdb54c298538/depthwise_conv.cc/vul/after/1.json,"--- func_before
+++ func_after
@@ -81,6 +81,7 @@
   if (data_type != kTfLiteFloat32) {
     TF_LITE_ENSURE_EQ(context, filter->quantization.type,
                       kTfLiteAffineQuantization);
+    TF_LITE_ENSURE(context, filter->quantization.type != kTfLiteNoQuantization);
     const auto* affine_quantization =
         reinterpret_cast<TfLiteAffineQuantization*>(
             filter->quantization.params);
@@ -100,6 +101,7 @@
   }
 
   if (is_hybrid) {
+    TF_LITE_ENSURE(context, filter->quantization.type != kTfLiteNoQuantization);
     const auto* affine_quantization =
         reinterpret_cast<TfLiteAffineQuantization*>(
             filter->quantization.params);","{'deleted_lines': [], 'added_lines': ['    TF_LITE_ENSURE(context, filter->quantization.type != kTfLiteNoQuantization);', '    TF_LITE_ENSURE(context, filter->quantization.type != kTfLiteNoQuantization);']}",True,"TensorFlow is an end-to-end open source platform for machine learning. In affected versions all TFLite operations that use quantization can be made to use unitialized values. [For example](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/depthwise_conv.cc#L198-L200). The issue stems from the fact that `quantization.params` is only valid if `quantization.type` is different that `kTfLiteNoQuantization`. However, these checks are missing in large parts of the code. We have patched the issue in GitHub commits 537bc7c723439b9194a358f64d871dd326c18887, 4a91f2069f7145aab6ba2d8cfe41be8a110c18a5 and 8933b8a21280696ab119b63263babdb54c298538. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.",4.4,MEDIUM,1,valid,2021-07-16T17:22:37Z,3
CVE-2021-37789,['CWE-787'],CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H,1,nothings/stb,"stb_image: Reject fractional JPEG component subsampling ratios

The component resamplers are not written to support this and I've
never seen it happen in a real (non-crafted) JPEG file so I'm
fine rejecting this as outright corrupt.

Fixes issue #1178.",94be770ef6d5e1091290e3af217a0fbd1ef1172e,https://github.com/nothings/stb/commit/94be770ef6d5e1091290e3af217a0fbd1ef1172e,stb_image.h,stbi__process_frame_header,"static int stbi__process_frame_header(stbi__jpeg *z, int scan)
{
stbi__context *s = z->s;
int Lf,p,i,q, h_max=1,v_max=1,c;
Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err(""bad SOF len"",""Corrupt JPEG"");    p  = stbi__get8(s);            if (p != 8) return stbi__err(""only 8-bit"",""JPEG format not supported: 8-bit only"");    s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err(""no header height"", ""JPEG format not supported: delayed height"");    s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err(""0 width"",""Corrupt JPEG"");    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
c = stbi__get8(s);
if (c != 3 && c != 1 && c != 4) return stbi__err(""bad component count"",""Corrupt JPEG"");
s->img_n = c;
for (i=0; i < c; ++i) {
z->img_comp[i].data = NULL;
z->img_comp[i].linebuf = NULL;
}
if (Lf != 8+3*s->img_n) return stbi__err(""bad SOF len"",""Corrupt JPEG"");
z->rgb = 0;
for (i=0; i < s->img_n; ++i) {
static const unsigned char rgb[3] = { 'R', 'G', 'B' };
z->img_comp[i].id = stbi__get8(s);
if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
++z->rgb;
q = stbi__get8(s);
z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err(""bad H"",""Corrupt JPEG"");
z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err(""bad V"",""Corrupt JPEG"");
z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err(""bad TQ"",""Corrupt JPEG"");
}
if (scan != STBI__SCAN_load) return 1;
if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err(""too large"", ""Image too large to decode"");
for (i=0; i < s->img_n; ++i) {
if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
}
z->img_h_max = h_max;
z->img_v_max = v_max;
z->img_mcu_w = h_max * 8;
z->img_mcu_h = v_max * 8;
z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;
for (i=0; i < s->img_n; ++i) {
z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
z->img_comp[i].coeff = 0;
z->img_comp[i].raw_coeff = 0;
z->img_comp[i].linebuf = NULL;
z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
if (z->img_comp[i].raw_data == NULL)
return stbi__free_jpeg_components(z, i+1, stbi__err(""outofmem"", ""Out of memory""));
z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
if (z->progressive) {
z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
if (z->img_comp[i].raw_coeff == NULL)
return stbi__free_jpeg_components(z, i+1, stbi__err(""outofmem"", ""Out of memory""));
z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
}
}
return 1;
}","static int stbi__process_frame_header(stbi__jpeg *VAR_0, int VAR_1)
{
stbi__context *VAR_2 = VAR_0->s;
int VAR_3,VAR_4,VAR_5,VAR_6, VAR_7=1,VAR_8=1,VAR_9;
VAR_3 = stbi__get16be(VAR_2);         if (VAR_3 < 11) return stbi__err(""bad SOF len"",""Corrupt JPEG""); 
VAR_4  = stbi__get8(VAR_2);            if (VAR_4 != 8) return stbi__err(""only 8-bit"",""JPEG format not supported: 8-bit only""); 
VAR_2->img_y = stbi__get16be(VAR_2);   if (VAR_2->img_y == 0) return stbi__err(""no header height"", ""JPEG format not supported: delayed height""); 
VAR_2->img_x = stbi__get16be(VAR_2);   if (VAR_2->img_x == 0) return stbi__err(""0 width"",""Corrupt JPEG""); 
if (VAR_2->img_y > VAR_10) return stbi__err(""too large"",""Very large image (corrupt?)"");
if (VAR_2->img_x > VAR_10) return stbi__err(""too large"",""Very large image (corrupt?)"");
VAR_9 = stbi__get8(VAR_2);
if (VAR_9 != 3 && VAR_9 != 1 && VAR_9 != 4) return stbi__err(""bad component count"",""Corrupt JPEG"");
VAR_2->img_n = VAR_9;
for (VAR_5=0; VAR_5 < VAR_9; ++VAR_5) {
VAR_0->img_comp[VAR_5].data = NULL;
VAR_0->img_comp[VAR_5].linebuf = NULL;
}
if (VAR_3 != 8+3*VAR_2->img_n) return stbi__err(""bad SOF len"",""Corrupt JPEG"");
VAR_0->rgb = 0;
for (VAR_5=0; VAR_5 < VAR_2->img_n; ++VAR_5) {
static const unsigned char VAR_11[3] = { 'R', 'G', 'B' };
VAR_0->img_comp[VAR_5].id = stbi__get8(VAR_2);
if (VAR_2->img_n == 3 && VAR_0->img_comp[VAR_5].id == VAR_11[VAR_5])
++VAR_0->rgb;
VAR_6 = stbi__get8(VAR_2);
VAR_0->img_comp[VAR_5].h = (VAR_6 >> 4);  if (!VAR_0->img_comp[VAR_5].h || VAR_0->img_comp[VAR_5].h > 4) return stbi__err(""bad H"",""Corrupt JPEG"");
VAR_0->img_comp[VAR_5].v = VAR_6 & 15;    if (!VAR_0->img_comp[VAR_5].v || VAR_0->img_comp[VAR_5].v > 4) return stbi__err(""bad V"",""Corrupt JPEG"");
VAR_0->img_comp[VAR_5].tq = stbi__get8(VAR_2);  if (VAR_0->img_comp[VAR_5].tq > 3) return stbi__err(""bad TQ"",""Corrupt JPEG"");
}
if (VAR_1 != VAR_12) return 1;
if (!stbi__mad3sizes_valid(VAR_2->img_x, VAR_2->img_y, VAR_2->img_n, 0)) return stbi__err(""too large"", ""Image too large to decode"");
for (VAR_5=0; VAR_5 < VAR_2->img_n; ++VAR_5) {
if (VAR_0->img_comp[VAR_5].h > VAR_7) VAR_7 = VAR_0->img_comp[VAR_5].h;
if (VAR_0->img_comp[VAR_5].v > VAR_8) VAR_8 = VAR_0->img_comp[VAR_5].v;
}
VAR_0->img_h_max = VAR_7;
VAR_0->img_v_max = VAR_8;
VAR_0->img_mcu_w = VAR_7 * 8;
VAR_0->img_mcu_h = VAR_8 * 8;
VAR_0->img_mcu_x = (VAR_2->img_x + VAR_0->img_mcu_w-1) / VAR_0->img_mcu_w;
VAR_0->img_mcu_y = (VAR_2->img_y + VAR_0->img_mcu_h-1) / VAR_0->img_mcu_h;
for (VAR_5=0; VAR_5 < VAR_2->img_n; ++VAR_5) {
VAR_0->img_comp[VAR_5].x = (VAR_2->img_x * VAR_0->img_comp[VAR_5].h + VAR_7-1) / VAR_7;
VAR_0->img_comp[VAR_5].y = (VAR_2->img_y * VAR_0->img_comp[VAR_5].v + VAR_8-1) / VAR_8;
VAR_0->img_comp[VAR_5].w2 = VAR_0->img_mcu_x * VAR_0->img_comp[VAR_5].h * 8;
VAR_0->img_comp[VAR_5].h2 = VAR_0->img_mcu_y * VAR_0->img_comp[VAR_5].v * 8;
VAR_0->img_comp[VAR_5].coeff = 0;
VAR_0->img_comp[VAR_5].raw_coeff = 0;
VAR_0->img_comp[VAR_5].linebuf = NULL;
VAR_0->img_comp[VAR_5].raw_data = stbi__malloc_mad2(VAR_0->img_comp[VAR_5].w2, VAR_0->img_comp[VAR_5].h2, 15);
if (VAR_0->img_comp[VAR_5].raw_data == NULL)
return stbi__free_jpeg_components(VAR_0, VAR_5+1, stbi__err(""outofmem"", ""Out of memory""));
VAR_0->img_comp[VAR_5].data = (stbi_uc*) (((size_t) VAR_0->img_comp[VAR_5].raw_data + 15) & ~15);
if (VAR_0->progressive) {
VAR_0->img_comp[VAR_5].coeff_w = VAR_0->img_comp[VAR_5].w2 / 8;
VAR_0->img_comp[VAR_5].coeff_h = VAR_0->img_comp[VAR_5].h2 / 8;
VAR_0->img_comp[VAR_5].raw_coeff = stbi__malloc_mad3(VAR_0->img_comp[VAR_5].w2, VAR_0->img_comp[VAR_5].h2, sizeof(short), 15);
if (VAR_0->img_comp[VAR_5].raw_coeff == NULL)
return stbi__free_jpeg_components(VAR_0, VAR_5+1, stbi__err(""outofmem"", ""Out of memory""));
VAR_0->img_comp[VAR_5].coeff = (short*) (((size_t) VAR_0->img_comp[VAR_5].raw_coeff + 15) & ~15);
}
}
return 1;
}",nothings/stb/94be770ef6d5e1091290e3af217a0fbd1ef1172e/stb_image.h/vul/before/0.json,"static int stbi__process_frame_header(stbi__jpeg *z, int scan)
{
   stbi__context *s = z->s;
   int Lf,p,i,q, h_max=1,v_max=1,c;
   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err(""bad SOF len"",""Corrupt JPEG""); // JPEG
   p  = stbi__get8(s);            if (p != 8) return stbi__err(""only 8-bit"",""JPEG format not supported: 8-bit only""); // JPEG baseline
   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err(""no header height"", ""JPEG format not supported: delayed height""); // Legal, but we don't handle it--but neither does IJG
   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err(""0 width"",""Corrupt JPEG""); // JPEG requires
   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)"");
   c = stbi__get8(s);
   if (c != 3 && c != 1 && c != 4) return stbi__err(""bad component count"",""Corrupt JPEG"");
   s->img_n = c;
   for (i=0; i < c; ++i) {
      z->img_comp[i].data = NULL;
      z->img_comp[i].linebuf = NULL;
   }

   if (Lf != 8+3*s->img_n) return stbi__err(""bad SOF len"",""Corrupt JPEG"");

   z->rgb = 0;
   for (i=0; i < s->img_n; ++i) {
      static const unsigned char rgb[3] = { 'R', 'G', 'B' };
      z->img_comp[i].id = stbi__get8(s);
      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
         ++z->rgb;
      q = stbi__get8(s);
      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err(""bad H"",""Corrupt JPEG"");
      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err(""bad V"",""Corrupt JPEG"");
      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err(""bad TQ"",""Corrupt JPEG"");
   }

   if (scan != STBI__SCAN_load) return 1;

   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err(""too large"", ""Image too large to decode"");

   for (i=0; i < s->img_n; ++i) {
      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
   }

   // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
   // and I've never seen a non-corrupted JPEG file actually use them
   for (i=0; i < s->img_n; ++i) {
      if (h_max % z->img_comp[i].h != 0) return stbi__err(""bad H"",""Corrupt JPEG"");
      if (v_max % z->img_comp[i].v != 0) return stbi__err(""bad V"",""Corrupt JPEG"");
   }

   // compute interleaved mcu info
   z->img_h_max = h_max;
   z->img_v_max = v_max;
   z->img_mcu_w = h_max * 8;
   z->img_mcu_h = v_max * 8;
   // these sizes can't be more than 17 bits
   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

   for (i=0; i < s->img_n; ++i) {
      // number of effective pixels (e.g. for non-interleaved MCU)
      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
      // to simplify generation, we'll allocate enough memory to decode
      // the bogus oversized data from using interleaved MCUs and their
      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
      // discard the extra data until colorspace conversion
      //
      // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
      // so these muls can't overflow with 32-bit ints (which we require)
      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
      z->img_comp[i].coeff = 0;
      z->img_comp[i].raw_coeff = 0;
      z->img_comp[i].linebuf = NULL;
      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
      if (z->img_comp[i].raw_data == NULL)
         return stbi__free_jpeg_components(z, i+1, stbi__err(""outofmem"", ""Out of memory""));
      // align blocks for idct using mmx/sse
      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
      if (z->progressive) {
         // w2, h2 are multiples of 8 (see above)
         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
         if (z->img_comp[i].raw_coeff == NULL)
            return stbi__free_jpeg_components(z, i+1, stbi__err(""outofmem"", ""Out of memory""));
         z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
      }
   }

   return 1;
}","static int stbi__process_frame_header(stbi__jpeg *VAR_0, int VAR_1)
{
   stbi__context *VAR_2 = VAR_0->s;
   int VAR_3,VAR_4,VAR_5,VAR_6, VAR_7=1,VAR_8=1,VAR_9;
   VAR_3 = stbi__get16be(VAR_2);         if (VAR_3 < 11) return stbi__err(""bad SOF len"",""Corrupt JPEG""); /* COMMENT_0 */
   VAR_4  = stbi__get8(VAR_2);            if (VAR_4 != 8) return stbi__err(""only 8-bit"",""JPEG format not supported: 8-bit only""); /* COMMENT_1 */
   VAR_2->img_y = stbi__get16be(VAR_2);   if (VAR_2->img_y == 0) return stbi__err(""no header height"", ""JPEG format not supported: delayed height""); /* COMMENT_2 */
   VAR_2->img_x = stbi__get16be(VAR_2);   if (VAR_2->img_x == 0) return stbi__err(""0 width"",""Corrupt JPEG""); /* COMMENT_3 */
   if (VAR_2->img_y > VAR_10) return stbi__err(""too large"",""Very large image (corrupt?)"");
   if (VAR_2->img_x > VAR_10) return stbi__err(""too large"",""Very large image (corrupt?)"");
   VAR_9 = stbi__get8(VAR_2);
   if (VAR_9 != 3 && VAR_9 != 1 && VAR_9 != 4) return stbi__err(""bad component count"",""Corrupt JPEG"");
   VAR_2->img_n = VAR_9;
   for (VAR_5=0; VAR_5 < VAR_9; ++VAR_5) {
      VAR_0->img_comp[VAR_5].data = NULL;
      VAR_0->img_comp[VAR_5].linebuf = NULL;
   }

   if (VAR_3 != 8+3*VAR_2->img_n) return stbi__err(""bad SOF len"",""Corrupt JPEG"");

   VAR_0->rgb = 0;
   for (VAR_5=0; VAR_5 < VAR_2->img_n; ++VAR_5) {
      static const unsigned char VAR_11[3] = { 'R', 'G', 'B' };
      VAR_0->img_comp[VAR_5].id = stbi__get8(VAR_2);
      if (VAR_2->img_n == 3 && VAR_0->img_comp[VAR_5].id == VAR_11[VAR_5])
         ++VAR_0->rgb;
      VAR_6 = stbi__get8(VAR_2);
      VAR_0->img_comp[VAR_5].h = (VAR_6 >> 4);  if (!VAR_0->img_comp[VAR_5].h || VAR_0->img_comp[VAR_5].h > 4) return stbi__err(""bad H"",""Corrupt JPEG"");
      VAR_0->img_comp[VAR_5].v = VAR_6 & 15;    if (!VAR_0->img_comp[VAR_5].v || VAR_0->img_comp[VAR_5].v > 4) return stbi__err(""bad V"",""Corrupt JPEG"");
      VAR_0->img_comp[VAR_5].tq = stbi__get8(VAR_2);  if (VAR_0->img_comp[VAR_5].tq > 3) return stbi__err(""bad TQ"",""Corrupt JPEG"");
   }

   if (VAR_1 != VAR_12) return 1;

   if (!stbi__mad3sizes_valid(VAR_2->img_x, VAR_2->img_y, VAR_2->img_n, 0)) return stbi__err(""too large"", ""Image too large to decode"");

   for (VAR_5=0; VAR_5 < VAR_2->img_n; ++VAR_5) {
      if (VAR_0->img_comp[VAR_5].h > VAR_7) VAR_7 = VAR_0->img_comp[VAR_5].h;
      if (VAR_0->img_comp[VAR_5].v > VAR_8) VAR_8 = VAR_0->img_comp[VAR_5].v;
   }

   /* COMMENT_4 */
   /* COMMENT_5 */
   for (VAR_5=0; VAR_5 < VAR_2->img_n; ++VAR_5) {
      if (VAR_7 % VAR_0->img_comp[VAR_5].h != 0) return stbi__err(""bad H"",""Corrupt JPEG"");
      if (VAR_8 % VAR_0->img_comp[VAR_5].v != 0) return stbi__err(""bad V"",""Corrupt JPEG"");
   }

   /* COMMENT_6 */
   VAR_0->img_h_max = VAR_7;
   VAR_0->img_v_max = VAR_8;
   VAR_0->img_mcu_w = VAR_7 * 8;
   VAR_0->img_mcu_h = VAR_8 * 8;
   /* COMMENT_7 */
   VAR_0->img_mcu_x = (VAR_2->img_x + VAR_0->img_mcu_w-1) / VAR_0->img_mcu_w;
   VAR_0->img_mcu_y = (VAR_2->img_y + VAR_0->img_mcu_h-1) / VAR_0->img_mcu_h;

   for (VAR_5=0; VAR_5 < VAR_2->img_n; ++VAR_5) {
      /* COMMENT_8 */
      VAR_0->img_comp[VAR_5].x = (VAR_2->img_x * VAR_0->img_comp[VAR_5].h + VAR_7-1) / VAR_7;
      VAR_0->img_comp[VAR_5].y = (VAR_2->img_y * VAR_0->img_comp[VAR_5].v + VAR_8-1) / VAR_8;
      /* COMMENT_9 */
      /* COMMENT_10 */
      /* COMMENT_11 */
      /* COMMENT_12 */
      /* COMMENT_13 */
      /* COMMENT_14 */
      /* COMMENT_15 */
      VAR_0->img_comp[VAR_5].w2 = VAR_0->img_mcu_x * VAR_0->img_comp[VAR_5].h * 8;
      VAR_0->img_comp[VAR_5].h2 = VAR_0->img_mcu_y * VAR_0->img_comp[VAR_5].v * 8;
      VAR_0->img_comp[VAR_5].coeff = 0;
      VAR_0->img_comp[VAR_5].raw_coeff = 0;
      VAR_0->img_comp[VAR_5].linebuf = NULL;
      VAR_0->img_comp[VAR_5].raw_data = stbi__malloc_mad2(VAR_0->img_comp[VAR_5].w2, VAR_0->img_comp[VAR_5].h2, 15);
      if (VAR_0->img_comp[VAR_5].raw_data == NULL)
         return stbi__free_jpeg_components(VAR_0, VAR_5+1, stbi__err(""outofmem"", ""Out of memory""));
      /* COMMENT_16 */
      VAR_0->img_comp[VAR_5].data = (stbi_uc*) (((size_t) VAR_0->img_comp[VAR_5].raw_data + 15) & ~15);
      if (VAR_0->progressive) {
         /* COMMENT_17 */
         VAR_0->img_comp[VAR_5].coeff_w = VAR_0->img_comp[VAR_5].w2 / 8;
         VAR_0->img_comp[VAR_5].coeff_h = VAR_0->img_comp[VAR_5].h2 / 8;
         VAR_0->img_comp[VAR_5].raw_coeff = stbi__malloc_mad3(VAR_0->img_comp[VAR_5].w2, VAR_0->img_comp[VAR_5].h2, sizeof(short), 15);
         if (VAR_0->img_comp[VAR_5].raw_coeff == NULL)
            return stbi__free_jpeg_components(VAR_0, VAR_5+1, stbi__err(""outofmem"", ""Out of memory""));
         VAR_0->img_comp[VAR_5].coeff = (short*) (((size_t) VAR_0->img_comp[VAR_5].raw_coeff + 15) & ~15);
      }
   }

   return 1;
}",nothings/stb/94be770ef6d5e1091290e3af217a0fbd1ef1172e/stb_image.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -37,6 +37,13 @@
    for (i=0; i < s->img_n; ++i) {
       if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
       if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
+   }
+
+   // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
+   // and I've never seen a non-corrupted JPEG file actually use them
+   for (i=0; i < s->img_n; ++i) {
+      if (h_max % z->img_comp[i].h != 0) return stbi__err(""bad H"",""Corrupt JPEG"");
+      if (v_max % z->img_comp[i].v != 0) return stbi__err(""bad V"",""Corrupt JPEG"");
    }
 
    // compute interleaved mcu info","{'deleted_lines': [], 'added_lines': ['   }', '', ""   // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios"", ""   // and I've never seen a non-corrupted JPEG file actually use them"", '   for (i=0; i < s->img_n; ++i) {', '      if (h_max % z->img_comp[i].h != 0) return stbi__err(""bad H"",""Corrupt JPEG"");', '      if (v_max % z->img_comp[i].v != 0) return stbi__err(""bad V"",""Corrupt JPEG"");']}",True,"stb_image.h 2.27 has a heap-based buffer over in stbi__jpeg_load, leading to Information Disclosure or Denial of Service.",8.1,HIGH,2,valid,2021-07-26T03:24:10Z,3
CVE-2021-37750,['CWE-476'],AV:N/AC:L/Au:S/C:N/I:N/A:P,0,krb5,"Fix KDC null deref on TGS inner body null server

After the KDC decodes a FAST inner body, it does not check for a null
server.  Prior to commit 39548a5b17bbda9eeb63625a201cfd19b9de1c5b this
would typically result in an error from krb5_unparse_name(), but with
the addition of get_local_tgt() it results in a null dereference.  Add
a null check.

Reported by Joseph Sutton of Catalyst.

CVE-2021-37750:

In MIT krb5 releases 1.14 and later, an authenticated attacker can
cause a null dereference in the KDC by sending a FAST TGS request with
no server field.

ticket: 9008 (new)
tags: pullup
target_version: 1.19-next
target_version: 1.18-next",d775c95af7606a51bf79547a94fa52ddd1cb7f49,https://github.com/krb5/krb5/commit/d775c95af7606a51bf79547a94fa52ddd1cb7f49,src/kdc/do_tgs_req.c,process_tgs_req,"krb5_error_code
process_tgs_req(krb5_kdc_req *request, krb5_data *pkt,
const krb5_fulladdr *from, kdc_realm_t *kdc_active_realm,
krb5_data **response)
{
krb5_keyblock * subkey = 0;
krb5_keyblock *header_key = NULL;
krb5_keyblock *stkt_server_key = NULL;
krb5_keyblock *subject_key;
krb5_db_entry *server = NULL;
krb5_db_entry *stkt_server = NULL;
krb5_db_entry *subject_server;
krb5_kdc_rep reply;
krb5_enc_kdc_rep_part reply_encpart;
krb5_ticket ticket_reply, *header_ticket = 0;
const krb5_ticket *stkt = NULL;
krb5_enc_tkt_part enc_tkt_reply;
int newtransited = 0;
krb5_error_code retval = 0;
krb5_keyblock server_keyblock, *encrypting_key;
krb5_timestamp kdc_time, authtime = 0;
krb5_keyblock session_key, local_tgt_key;
krb5_keyblock *reply_key = NULL;
krb5_principal cprinc = NULL, sprinc = NULL, altcprinc = NULL;
krb5_const_principal authdata_client;
krb5_principal stkt_authdata_client = NULL;
krb5_last_req_entry *nolrarray[2], nolrentry;
int errcode;
const char        *status = 0;
krb5_enc_tkt_part *header_enc_tkt = NULL; 
krb5_enc_tkt_part *subject_tkt = NULL; 
krb5_db_entry *client = NULL, *header_server = NULL;
krb5_db_entry *local_tgt, *local_tgt_storage = NULL;
krb5_pa_s4u_x509_user *s4u_x509_user = NULL; 
krb5_authdata **kdc_issued_auth_data = NULL; 
unsigned int c_flags = 0, s_flags = 0;       
krb5_boolean is_referral, is_crossrealm;
const char *emsg = NULL;
krb5_kvno ticket_kvno = 0;
struct kdc_request_state *state = NULL;
krb5_pa_data *pa_tgs_req; 
krb5_data scratch;
krb5_pa_data **e_data = NULL;
krb5_audit_state *au_state = NULL;
krb5_data **auth_indicators = NULL;
void *ad_info = NULL, *stkt_ad_info = NULL;
memset(&reply, 0, sizeof(reply));
memset(&reply_encpart, 0, sizeof(reply_encpart));
memset(&ticket_reply, 0, sizeof(ticket_reply));
memset(&enc_tkt_reply, 0, sizeof(enc_tkt_reply));
memset(&server_keyblock, 0, sizeof(server_keyblock));
memset(&local_tgt_key, 0, sizeof(local_tgt_key));
session_key.contents = NULL;
sprinc = request->server;
if (request->msg_type != KRB5_TGS_REQ) {
krb5_free_kdc_req(kdc_context, request);
return KRB5_BADMSGTYPE;
}
errcode = kdc_make_rstate(kdc_active_realm, &state);
if (errcode != 0)
goto cleanup;
errcode = kau_init_kdc_req(kdc_context, request, from, &au_state);
if (errcode)
goto cleanup;
kau_tgs_req(kdc_context, TRUE, au_state);
errcode = kdc_process_tgs_req(kdc_active_realm,
request, from, pkt, &header_ticket,
&header_server, &header_key, &subkey,
&pa_tgs_req);
if (header_ticket && header_ticket->enc_part2)
cprinc = header_ticket->enc_part2->client;
if (errcode) {
status = ""PROCESS_TGS"";
goto cleanup;
}
if (!header_ticket) {
errcode = KRB5_NO_TKT_SUPPLIED;        
goto cleanup;
}
errcode = kau_make_tkt_id(kdc_context, header_ticket,
&au_state->tkt_in_id);
if (errcode)
goto cleanup;
scratch.length = pa_tgs_req->length;
scratch.data = (char *) pa_tgs_req->contents;
errcode = kdc_find_fast(&request, &scratch, subkey,
header_ticket->enc_part2->session, state, NULL);
sprinc = request->server;
if (errcode !=0) {
status = ""FIND_FAST"";
goto cleanup;
}
errcode = get_local_tgt(kdc_context, &sprinc->realm, header_server,
&local_tgt, &local_tgt_storage, &local_tgt_key);
if (errcode) {
status = ""GET_LOCAL_TGT"";
goto cleanup;
}
au_state->request = request;
header_enc_tkt = header_ticket->enc_part2;
au_state->stage = SRVC_PRINC;
if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE)) {
setflag(c_flags, KRB5_KDB_FLAG_CANONICALIZE);
setflag(s_flags, KRB5_KDB_FLAG_CANONICALIZE);
}
errcode = search_sprinc(kdc_active_realm, request, s_flags, &server,
&status);
if (errcode != 0)
goto cleanup;
sprinc = server->princ;
is_referral = is_cross_tgs_principal(server->princ) &&
!krb5_principal_compare(kdc_context, request->server, server->princ);
au_state->stage = VALIDATE_POL;
if ((errcode = krb5_timeofday(kdc_context, &kdc_time)))
goto cleanup;
is_crossrealm = !data_eq(header_server->princ->realm, sprinc->realm);
if (is_crossrealm)
setflag(c_flags, KRB5_KDB_FLAG_CROSS_REALM);
if (is_referral)
setflag(c_flags, KRB5_KDB_FLAG_ISSUING_REFERRAL);
errcode = kdc_process_s4u2self_req(kdc_active_realm, request, server,
subkey, header_enc_tkt->session,
&s4u_x509_user, &client, &status);
if (s4u_x509_user != NULL || errcode != 0) {
if (s4u_x509_user != NULL)
au_state->s4u2self_user = s4u_x509_user->user_id.user;
au_state->status = status;
kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);
au_state->s4u2self_user = NULL;
}
errcode = decrypt_2ndtkt(kdc_active_realm, request, c_flags,
&stkt, &stkt_server, &stkt_server_key, &status);
if (errcode)
goto cleanup;
retval = validate_tgs_request(kdc_active_realm, request, server,
header_ticket, stkt, stkt_server, kdc_time,
s4u_x509_user, client, is_crossrealm,
is_referral, &status, &e_data);
if (retval) {
if (retval == KDC_ERR_POLICY || retval == KDC_ERR_BADOPTION)
au_state->violation = PROT_CONSTRAINT;
errcode = retval + ERROR_TABLE_BASE_krb5;
goto cleanup;
}
if (errcode)
goto cleanup;
if (s4u_x509_user != NULL && client == NULL) {
setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);
authdata_client = s4u_x509_user->user_id.user;
} else {
authdata_client = header_enc_tkt->client;
}
errcode = krb5_db_get_authdata_info(kdc_context, c_flags,
header_enc_tkt->authorization_data,
authdata_client, request->server,
header_key, &local_tgt_key, local_tgt,
header_enc_tkt->times.authtime,
&ad_info, NULL);
if (errcode && errcode != KRB5_PLUGIN_OP_NOTSUPP)
goto cleanup;
if (s4u_x509_user != NULL)
setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);
if (isflagset(request->kdc_options, KDC_OPT_CNAME_IN_ADDL_TKT)) {
setflag(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION);
errcode = kdc_process_s4u2proxy_req(kdc_active_realm, c_flags, request,
stkt->enc_part2, local_tgt,
&local_tgt_key, stkt_server,
stkt_server_key,
header_ticket->enc_part2->client,
server, request->server, ad_info,
&stkt_ad_info,
&stkt_authdata_client,
&status);
if (errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION)
au_state->violation = PROT_CONSTRAINT;
else if (errcode)
au_state->violation = LOCAL_POLICY;
au_state->status = status;
retval = kau_make_tkt_id(kdc_context, stkt, &au_state->evid_tkt_id);
if (retval) {
errcode = retval;
goto cleanup;
}
kau_s4u2proxy(kdc_context, errcode ? FALSE : TRUE, au_state);
if (errcode)
goto cleanup;
assert(krb5_is_tgs_principal(header_ticket->server));
krb5_db_free_authdata_info(kdc_context, ad_info);
ad_info = stkt_ad_info;
stkt_ad_info = NULL;
}
au_state->stage = ISSUE_TKT;
errcode = gen_session_key(kdc_active_realm, request, server, &session_key,
&status);
if (errcode)
goto cleanup;
if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {
subject_tkt = stkt->enc_part2;
subject_server = stkt_server;
subject_key = stkt_server_key;
} else {
subject_tkt = header_enc_tkt;
subject_server = header_server;
subject_key = header_key;
}
authtime = subject_tkt->times.authtime;
if (s4u_x509_user == NULL) {
errcode = get_auth_indicators(kdc_context, subject_tkt, local_tgt,
&local_tgt_key, &auth_indicators);
if (errcode) {
status = ""GET_AUTH_INDICATORS"";
goto cleanup;
}
errcode = check_indicators(kdc_context, server, auth_indicators);
if (errcode) {
status = ""HIGHER_AUTHENTICATION_REQUIRED"";
goto cleanup;
}
}
if (is_referral)
ticket_reply.server = server->princ;
else
ticket_reply.server = request->server; 
enc_tkt_reply.flags = get_ticket_flags(request->kdc_options, client,
server, header_enc_tkt);
enc_tkt_reply.times.starttime = 0;
if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&
!is_referral &&
!isflagset(server->attributes, KRB5_KDB_OK_TO_AUTH_AS_DELEGATE))
clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);
enc_tkt_reply.caddrs = header_enc_tkt->caddrs;
reply_encpart.caddrs = 0;
reply_encpart.enc_padata = NULL;
if (isflagset(request->kdc_options, KDC_OPT_FORWARDED) ||
isflagset(request->kdc_options, KDC_OPT_PROXY)) {
enc_tkt_reply.caddrs = request->addresses;
reply_encpart.caddrs = request->addresses;
}
if (isflagset(request->kdc_options, KDC_OPT_POSTDATED))
enc_tkt_reply.times.starttime = request->from;
else
enc_tkt_reply.times.starttime = kdc_time;
if (isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {
assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);
ticket_reply = *(header_ticket);
enc_tkt_reply = *(header_ticket->enc_part2);
enc_tkt_reply.authorization_data = NULL;
clear(enc_tkt_reply.flags, TKT_FLG_INVALID);
}
if (isflagset(request->kdc_options, KDC_OPT_RENEW)) {
krb5_timestamp old_starttime;
krb5_deltat old_life;
assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);
ticket_reply = *(header_ticket);
enc_tkt_reply = *(header_ticket->enc_part2);
enc_tkt_reply.authorization_data = NULL;
old_starttime = enc_tkt_reply.times.starttime ?
enc_tkt_reply.times.starttime : enc_tkt_reply.times.authtime;
old_life = ts_delta(enc_tkt_reply.times.endtime, old_starttime);
enc_tkt_reply.times.starttime = kdc_time;
enc_tkt_reply.times.endtime =
ts_min(header_ticket->enc_part2->times.renew_till,
ts_incr(kdc_time, old_life));
} else {
enc_tkt_reply.times.starttime = kdc_time;
kdc_get_ticket_endtime(kdc_active_realm, enc_tkt_reply.times.starttime,
header_enc_tkt->times.endtime, request->till,
client, server, &enc_tkt_reply.times.endtime);
}
kdc_get_ticket_renewtime(kdc_active_realm, request, header_enc_tkt, client,
server, &enc_tkt_reply);
errcode = check_kdcpolicy_tgs(kdc_context, request, server, header_ticket,
auth_indicators, kdc_time,
&enc_tkt_reply.times, &status);
if (errcode)
goto cleanup;
enc_tkt_reply.times.authtime = authtime;
if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)
enc_tkt_reply.times.starttime = 0;
if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {
altcprinc = s4u_x509_user->user_id.user;
} else if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {
altcprinc = is_crossrealm ? stkt_authdata_client : subject_tkt->client;
} else {
altcprinc = NULL;
}
if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {
encrypting_key = stkt->enc_part2->session;
} else {
errcode = get_first_current_key(kdc_context, server, &server_keyblock);
if (errcode) {
status = ""FINDING_SERVER_KEY"";
goto cleanup;
}
encrypting_key = &server_keyblock;
}
if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {
clear(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED);
}
if (isflagset(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED) == 0) {
if (!isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {
setflag(c_flags, KRB5_KDB_FLAG_INCLUDE_PAC);
setflag(c_flags, KRB5_KDB_FLAG_MAP_PRINCIPALS);
assert(client == NULL); 
errcode = krb5_db_get_principal(kdc_context, subject_tkt->client,
c_flags, &client);
}
}
if (isflagset(c_flags, KRB5_KDB_FLAGS_S4U) && !is_referral)
enc_tkt_reply.client = altcprinc;
else
enc_tkt_reply.client = header_enc_tkt->client;
enc_tkt_reply.session = &session_key;
enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;
enc_tkt_reply.transited.tr_contents = empty_string; 
if (!is_crossrealm ||
krb5_realm_compare(kdc_context, header_ticket->server,
enc_tkt_reply.client)) {
enc_tkt_reply.transited = header_enc_tkt->transited;
} else {
if (header_enc_tkt->transited.tr_type !=
KRB5_DOMAIN_X500_COMPRESS) {
status = ""VALIDATE_TRANSIT_TYPE"";
errcode = KRB5KDC_ERR_TRTYPE_NOSUPP;
goto cleanup;
}
memset(&enc_tkt_reply.transited, 0, sizeof(enc_tkt_reply.transited));
enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;
if ((errcode =
add_to_transited(&header_enc_tkt->transited.tr_contents,
&enc_tkt_reply.transited.tr_contents,
header_ticket->server,
enc_tkt_reply.client,
request->server))) {
status = ""ADD_TO_TRANSITED_LIST"";
goto cleanup;
}
newtransited = 1;
}
if (!isflagset (request->kdc_options, KDC_OPT_DISABLE_TRANSITED_CHECK)) {
errcode = kdc_check_transited_list (kdc_active_realm,
&enc_tkt_reply.transited.tr_contents,
krb5_princ_realm (kdc_context, header_enc_tkt->client),
krb5_princ_realm (kdc_context, request->server));
if (errcode == 0) {
setflag (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED);
} else {
log_tgs_badtrans(kdc_context, cprinc, sprinc,
&enc_tkt_reply.transited.tr_contents, errcode);
}
} else
krb5_klog_syslog(LOG_INFO, _(""not checking transit path""));
if (kdc_active_realm->realm_reject_bad_transit &&
!isflagset(enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED)) {
errcode = KRB5KDC_ERR_POLICY;
status = ""BAD_TRANSIT"";
au_state->violation = LOCAL_POLICY;
goto cleanup;
}
errcode = handle_authdata(kdc_context, c_flags, client, server,
subject_server, local_tgt, &local_tgt_key,
subkey != NULL ? subkey :
header_ticket->enc_part2->session,
encrypting_key, subject_key, pkt, request,
altcprinc, ad_info, subject_tkt,
&auth_indicators, &enc_tkt_reply);
if (errcode) {
krb5_klog_syslog(LOG_INFO, _(""TGS_REQ : handle_authdata (%d)""),
errcode);
status = ""HANDLE_AUTHDATA"";
goto cleanup;
}
ticket_reply.enc_part2 = &enc_tkt_reply;
if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {
ticket_kvno = 0;
ticket_reply.enc_part.enctype = stkt->enc_part2->session->enctype;
kau_u2u(kdc_context, TRUE, au_state);
} else {
ticket_kvno = current_kvno(server);
}
errcode = krb5_encrypt_tkt_part(kdc_context, encrypting_key,
&ticket_reply);
if (errcode)
goto cleanup;
ticket_reply.enc_part.kvno = ticket_kvno;
au_state->stage = ENCR_REP;
reply.msg_type = KRB5_TGS_REP;
if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&
krb5int_find_pa_data(kdc_context, request->padata,
KRB5_PADATA_S4U_X509_USER) != NULL) {
errcode = kdc_make_s4u2self_rep(kdc_context,
subkey,
header_ticket->enc_part2->session,
s4u_x509_user,
&reply,
&reply_encpart);
if (errcode)
au_state->status = status;
kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);
if (errcode)
goto cleanup;
}
reply.client = enc_tkt_reply.client;
reply.enc_part.kvno = 0;
reply.ticket = &ticket_reply;
reply_encpart.session = &session_key;
reply_encpart.nonce = request->nonce;
reply_encpart.times = enc_tkt_reply.times;
nolrentry.lr_type = KRB5_LRQ_NONE;
nolrentry.value = 0;
nolrentry.magic = 0;
nolrarray[0] = &nolrentry;
nolrarray[1] = 0;
reply_encpart.last_req = nolrarray;        
reply_encpart.key_exp = 0;
reply_encpart.flags = enc_tkt_reply.flags;
reply_encpart.server = ticket_reply.server;
reply.enc_part.enctype = subkey ? subkey->enctype :
header_ticket->enc_part2->session->enctype;
errcode  = kdc_fast_response_handle_padata(state, request, &reply,
subkey ? subkey->enctype : header_ticket->enc_part2->session->enctype);
if (errcode)
goto cleanup;
errcode =kdc_fast_handle_reply_key(state,
subkey?subkey:header_ticket->enc_part2->session, &reply_key);
if (errcode)
goto cleanup;
errcode = return_enc_padata(kdc_context, pkt, request,
reply_key, server, &reply_encpart,
is_referral &&
isflagset(s_flags,
KRB5_KDB_FLAG_CANONICALIZE));
if (errcode) {
status = ""KDC_RETURN_ENC_PADATA"";
goto cleanup;
}
errcode = kau_make_tkt_id(kdc_context, &ticket_reply, &au_state->tkt_out_id);
if (errcode)
goto cleanup;
if (kdc_fast_hide_client(state))
reply.client = (krb5_principal)krb5_anonymous_principal();
errcode = krb5_encode_kdc_rep(kdc_context, KRB5_TGS_REP, &reply_encpart,
subkey ? 1 : 0,
reply_key,
&reply, response);
if (!errcode)
status = ""ISSUE"";
memset(ticket_reply.enc_part.ciphertext.data, 0,
ticket_reply.enc_part.ciphertext.length);
free(ticket_reply.enc_part.ciphertext.data);
memset(reply.enc_part.ciphertext.data, 0,
reply.enc_part.ciphertext.length);
free(reply.enc_part.ciphertext.data);
cleanup:
if (status == NULL)
status = ""UNKNOWN_REASON"";
krb5_free_keyblock_contents(kdc_context, &server_keyblock);
if (reply_key)
krb5_free_keyblock(kdc_context, reply_key);
if (stkt_server_key)
krb5_free_keyblock(kdc_context, stkt_server_key);
if (errcode)
emsg = krb5_get_error_message (kdc_context, errcode);
if (au_state != NULL) {
au_state->status = status;
if (!errcode)
au_state->reply = &reply;
kau_tgs_req(kdc_context, errcode ? FALSE : TRUE, au_state);
kau_free_kdc_req(au_state);
}
log_tgs_req(kdc_context, from, request, &reply, cprinc,
sprinc, altcprinc, authtime,
c_flags, status, errcode, emsg);
if (errcode) {
krb5_free_error_message (kdc_context, emsg);
emsg = NULL;
}
if (errcode && state != NULL) {
int got_err = 0;
if (status == 0) {
status = krb5_get_error_message (kdc_context, errcode);
got_err = 1;
}
errcode -= ERROR_TABLE_BASE_krb5;
if (errcode < 0 || errcode > KRB_ERR_MAX)
errcode = KRB_ERR_GENERIC;
retval = prepare_error_tgs(state, request, header_ticket, errcode,
(server != NULL) ? server->princ : NULL,
response, status, e_data);
if (got_err) {
krb5_free_error_message (kdc_context, status);
status = 0;
}
}
if (header_ticket != NULL)
krb5_free_ticket(kdc_context, header_ticket);
if (request != NULL)
krb5_free_kdc_req(kdc_context, request);
if (state)
kdc_free_rstate(state);
krb5_db_free_principal(kdc_context, server);
krb5_db_free_principal(kdc_context, stkt_server);
krb5_db_free_principal(kdc_context, header_server);
krb5_db_free_principal(kdc_context, client);
krb5_db_free_principal(kdc_context, local_tgt_storage);
if (local_tgt_key.contents != NULL)
krb5_free_keyblock_contents(kdc_context, &local_tgt_key);
if (session_key.contents != NULL)
krb5_free_keyblock_contents(kdc_context, &session_key);
if (newtransited)
free(enc_tkt_reply.transited.tr_contents.data);
if (s4u_x509_user != NULL)
krb5_free_pa_s4u_x509_user(kdc_context, s4u_x509_user);
if (kdc_issued_auth_data != NULL)
krb5_free_authdata(kdc_context, kdc_issued_auth_data);
if (subkey != NULL)
krb5_free_keyblock(kdc_context, subkey);
if (header_key != NULL)
krb5_free_keyblock(kdc_context, header_key);
if (reply.padata)
krb5_free_pa_data(kdc_context, reply.padata);
if (reply_encpart.enc_padata)
krb5_free_pa_data(kdc_context, reply_encpart.enc_padata);
if (enc_tkt_reply.authorization_data != NULL)
krb5_free_authdata(kdc_context, enc_tkt_reply.authorization_data);
krb5_free_pa_data(kdc_context, e_data);
k5_free_data_ptr_list(auth_indicators);
krb5_db_free_authdata_info(kdc_context, ad_info);
krb5_db_free_authdata_info(kdc_context, stkt_ad_info);
krb5_free_principal(kdc_context, stkt_authdata_client);
return retval;
}","krb5_error_code
process_tgs_req(krb5_kdc_req *VAR_0, krb5_data *VAR_1,
const krb5_fulladdr *VAR_2, kdc_realm_t *VAR_3,
krb5_data **VAR_4)
{
krb5_keyblock * VAR_5 = 0;
krb5_keyblock *VAR_6 = NULL;
krb5_keyblock *VAR_7 = NULL;
krb5_keyblock *VAR_8;
krb5_db_entry *VAR_9 = NULL;
krb5_db_entry *VAR_10 = NULL;
krb5_db_entry *VAR_11;
krb5_kdc_rep VAR_12;
krb5_enc_kdc_rep_part VAR_13;
krb5_ticket VAR_14, *VAR_15 = 0;
const krb5_ticket *VAR_16 = NULL;
krb5_enc_tkt_part VAR_17;
int VAR_18 = 0;
krb5_error_code VAR_19 = 0;
krb5_keyblock VAR_20, *VAR_21;
krb5_timestamp VAR_22, VAR_23 = 0;
krb5_keyblock VAR_24, VAR_25;
krb5_keyblock *VAR_26 = NULL;
krb5_principal VAR_27 = NULL, VAR_28 = NULL, VAR_29 = NULL;
krb5_const_principal VAR_30;
krb5_principal VAR_31 = NULL;
krb5_last_req_entry *VAR_32[2], VAR_33;
int VAR_34;
const char        *VAR_35 = 0;
krb5_enc_tkt_part *VAR_36 = NULL; 
krb5_enc_tkt_part *VAR_37 = NULL; 
krb5_db_entry *VAR_38 = NULL, *VAR_39 = NULL;
krb5_db_entry *VAR_40, *VAR_41 = NULL;
krb5_pa_s4u_x509_user *VAR_42 = NULL; 
krb5_authdata **VAR_43 = NULL; 
unsigned int VAR_44 = 0, VAR_45 = 0;       
krb5_boolean VAR_46, VAR_47;
const char *VAR_48 = NULL;
krb5_kvno VAR_49 = 0;
struct kdc_request_state *VAR_50 = NULL;
krb5_pa_data *VAR_51; 
krb5_data VAR_52;
krb5_pa_data **VAR_53 = NULL;
krb5_audit_state *VAR_54 = NULL;
krb5_data **VAR_55 = NULL;
void *VAR_56 = NULL, *VAR_57 = NULL;
memset(&VAR_12, 0, sizeof(VAR_12));
memset(&VAR_13, 0, sizeof(VAR_13));
memset(&VAR_14, 0, sizeof(VAR_14));
memset(&VAR_17, 0, sizeof(VAR_17));
memset(&VAR_20, 0, sizeof(VAR_20));
memset(&VAR_25, 0, sizeof(VAR_25));
VAR_24.contents = NULL;
VAR_28 = VAR_0->server;
if (VAR_0->msg_type != VAR_58) {
krb5_free_kdc_req(VAR_59, VAR_0);
return VAR_60;
}
VAR_34 = kdc_make_rstate(VAR_3, &VAR_50);
if (VAR_34 != 0)
goto cleanup;
VAR_34 = kau_init_kdc_req(VAR_59, VAR_0, VAR_2, &VAR_54);
if (VAR_34)
goto cleanup;
kau_tgs_req(VAR_59, TRUE, VAR_54);
VAR_34 = kdc_process_tgs_req(VAR_3,
VAR_0, VAR_2, VAR_1, &VAR_15,
&VAR_39, &VAR_6, &VAR_5,
&VAR_51);
if (VAR_15 && VAR_15->enc_part2)
VAR_27 = VAR_15->enc_part2->client;
if (VAR_34) {
VAR_35 = ""PROCESS_TGS"";
goto cleanup;
}
if (!VAR_15) {
VAR_34 = VAR_61;        
goto cleanup;
}
VAR_34 = kau_make_tkt_id(VAR_59, VAR_15,
&VAR_54->tkt_in_id);
if (VAR_34)
goto cleanup;
VAR_52.length = VAR_51->length;
VAR_52.data = (char *) VAR_51->contents;
VAR_34 = kdc_find_fast(&VAR_0, &VAR_52, VAR_5,
VAR_15->enc_part2->session, VAR_50, NULL);
VAR_28 = VAR_0->server;
if (VAR_34 !=0) {
VAR_35 = ""FIND_FAST"";
goto cleanup;
}
VAR_34 = get_local_tgt(VAR_59, &VAR_28->realm, VAR_39,
&VAR_40, &VAR_41, &VAR_25);
if (VAR_34) {
VAR_35 = ""GET_LOCAL_TGT"";
goto cleanup;
}
VAR_54->request = VAR_0;
VAR_36 = VAR_15->enc_part2;
VAR_54->stage = VAR_62;
if (isflagset(VAR_0->kdc_options, VAR_63)) {
setflag(VAR_44, VAR_64);
setflag(VAR_45, VAR_64);
}
VAR_34 = search_sprinc(VAR_3, VAR_0, VAR_45, &VAR_9,
&VAR_35);
if (VAR_34 != 0)
goto cleanup;
VAR_28 = VAR_9->princ;
VAR_46 = is_cross_tgs_principal(VAR_9->princ) &&
!krb5_principal_compare(VAR_59, VAR_0->server, VAR_9->princ);
VAR_54->stage = VAR_65;
if ((VAR_34 = krb5_timeofday(VAR_59, &VAR_22)))
goto cleanup;
VAR_47 = !data_eq(VAR_39->princ->realm, VAR_28->realm);
if (VAR_47)
setflag(VAR_44, VAR_66);
if (VAR_46)
setflag(VAR_44, VAR_67);
VAR_34 = kdc_process_s4u2self_req(VAR_3, VAR_0, VAR_9,
VAR_5, VAR_36->session,
&VAR_42, &VAR_38, &VAR_35);
if (VAR_42 != NULL || VAR_34 != 0) {
if (VAR_42 != NULL)
VAR_54->s4u2self_user = VAR_42->user_id.user;
VAR_54->status = VAR_35;
kau_s4u2self(VAR_59, VAR_34 ? FALSE : TRUE, VAR_54);
VAR_54->s4u2self_user = NULL;
}
VAR_34 = decrypt_2ndtkt(VAR_3, VAR_0, VAR_44,
&VAR_16, &VAR_10, &VAR_7, &VAR_35);
if (VAR_34)
goto cleanup;
VAR_19 = validate_tgs_request(VAR_3, VAR_0, VAR_9,
VAR_15, VAR_16, VAR_10, VAR_22,
VAR_42, VAR_38, VAR_47,
VAR_46, &VAR_35, &VAR_53);
if (VAR_19) {
if (VAR_19 == VAR_68 || VAR_19 == VAR_69)
VAR_54->violation = VAR_70;
VAR_34 = VAR_19 + VAR_71;
goto cleanup;
}
if (VAR_34)
goto cleanup;
if (VAR_42 != NULL && VAR_38 == NULL) {
setflag(VAR_44, VAR_72);
VAR_30 = VAR_42->user_id.user;
} else {
VAR_30 = VAR_36->client;
}
VAR_34 = krb5_db_get_authdata_info(VAR_59, VAR_44,
VAR_36->authorization_data,
VAR_30, VAR_0->server,
VAR_6, &VAR_25, VAR_40,
VAR_36->times.authtime,
&VAR_56, NULL);
if (VAR_34 && VAR_34 != VAR_73)
goto cleanup;
if (VAR_42 != NULL)
setflag(VAR_44, VAR_72);
if (isflagset(VAR_0->kdc_options, VAR_74)) {
setflag(VAR_44, VAR_75);
VAR_34 = kdc_process_s4u2proxy_req(VAR_3, VAR_44, VAR_0,
VAR_16->enc_part2, VAR_40,
&VAR_25, VAR_10,
VAR_7,
VAR_15->enc_part2->client,
VAR_9, VAR_0->server, VAR_56,
&VAR_57,
&VAR_31,
&VAR_35);
if (VAR_34 == VAR_68 || VAR_34 == VAR_69)
VAR_54->violation = VAR_70;
else if (VAR_34)
VAR_54->violation = VAR_76;
VAR_54->status = VAR_35;
VAR_19 = kau_make_tkt_id(VAR_59, VAR_16, &VAR_54->evid_tkt_id);
if (VAR_19) {
VAR_34 = VAR_19;
goto cleanup;
}
kau_s4u2proxy(VAR_59, VAR_34 ? FALSE : TRUE, VAR_54);
if (VAR_34)
goto cleanup;
assert(krb5_is_tgs_principal(VAR_15->server));
krb5_db_free_authdata_info(VAR_59, VAR_56);
VAR_56 = VAR_57;
VAR_57 = NULL;
}
VAR_54->stage = VAR_77;
VAR_34 = gen_session_key(VAR_3, VAR_0, VAR_9, &VAR_24,
&VAR_35);
if (VAR_34)
goto cleanup;
if (isflagset(VAR_44, VAR_75)) {
VAR_37 = VAR_16->enc_part2;
VAR_11 = VAR_10;
VAR_8 = VAR_7;
} else {
VAR_37 = VAR_36;
VAR_11 = VAR_39;
VAR_8 = VAR_6;
}
VAR_23 = VAR_37->times.authtime;
if (VAR_42 == NULL) {
VAR_34 = get_auth_indicators(VAR_59, VAR_37, VAR_40,
&VAR_25, &VAR_55);
if (VAR_34) {
VAR_35 = ""GET_AUTH_INDICATORS"";
goto cleanup;
}
VAR_34 = check_indicators(VAR_59, VAR_9, VAR_55);
if (VAR_34) {
VAR_35 = ""HIGHER_AUTHENTICATION_REQUIRED"";
goto cleanup;
}
}
if (VAR_46)
VAR_14.server = VAR_9->princ;
else
VAR_14.server = VAR_0->server; 
VAR_17.flags = get_ticket_flags(VAR_0->kdc_options, VAR_38,
VAR_9, VAR_36);
VAR_17.times.starttime = 0;
if (isflagset(VAR_44, VAR_72) &&
!VAR_46 &&
!isflagset(VAR_9->attributes, VAR_78))
clear(VAR_17.flags, VAR_79);
VAR_17.caddrs = VAR_36->caddrs;
VAR_13.caddrs = 0;
VAR_13.enc_padata = NULL;
if (isflagset(VAR_0->kdc_options, VAR_80) ||
isflagset(VAR_0->kdc_options, VAR_81)) {
VAR_17.caddrs = VAR_0->addresses;
VAR_13.caddrs = VAR_0->addresses;
}
if (isflagset(VAR_0->kdc_options, VAR_82))
VAR_17.times.starttime = VAR_0->from;
else
VAR_17.times.starttime = VAR_22;
if (isflagset(VAR_0->kdc_options, VAR_83)) {
assert(isflagset(VAR_44, VAR_84) == 0);
VAR_14 = *(VAR_15);
VAR_17 = *(VAR_15->enc_part2);
VAR_17.authorization_data = NULL;
clear(VAR_17.flags, VAR_85);
}
if (isflagset(VAR_0->kdc_options, VAR_86)) {
krb5_timestamp VAR_87;
krb5_deltat VAR_88;
assert(isflagset(VAR_44, VAR_84) == 0);
VAR_14 = *(VAR_15);
VAR_17 = *(VAR_15->enc_part2);
VAR_17.authorization_data = NULL;
VAR_87 = VAR_17.times.starttime ?
VAR_17.times.starttime : VAR_17.times.authtime;
VAR_88 = ts_delta(VAR_17.times.endtime, VAR_87);
VAR_17.times.starttime = VAR_22;
VAR_17.times.endtime =
ts_min(VAR_15->enc_part2->times.renew_till,
ts_incr(VAR_22, VAR_88));
} else {
VAR_17.times.starttime = VAR_22;
kdc_get_ticket_endtime(VAR_3, VAR_17.times.starttime,
VAR_36->times.endtime, VAR_0->till,
VAR_38, VAR_9, &VAR_17.times.endtime);
}
kdc_get_ticket_renewtime(VAR_3, VAR_0, VAR_36, VAR_38,
VAR_9, &VAR_17);
VAR_34 = check_kdcpolicy_tgs(VAR_59, VAR_0, VAR_9, VAR_15,
VAR_55, VAR_22,
&VAR_17.times, &VAR_35);
if (VAR_34)
goto cleanup;
VAR_17.times.authtime = VAR_23;
if (VAR_17.times.starttime == VAR_17.times.authtime)
VAR_17.times.starttime = 0;
if (isflagset(VAR_44, VAR_72)) {
VAR_29 = VAR_42->user_id.user;
} else if (isflagset(VAR_44, VAR_75)) {
VAR_29 = VAR_47 ? VAR_31 : VAR_37->client;
} else {
VAR_29 = NULL;
}
if (isflagset(VAR_0->kdc_options, VAR_89)) {
VAR_21 = VAR_16->enc_part2->session;
} else {
VAR_34 = get_first_current_key(VAR_59, VAR_9, &VAR_20);
if (VAR_34) {
VAR_35 = ""FINDING_SERVER_KEY"";
goto cleanup;
}
VAR_21 = &VAR_20;
}
if (isflagset(VAR_44, VAR_75)) {
clear(VAR_9->attributes, VAR_90);
}
if (isflagset(VAR_9->attributes, VAR_90) == 0) {
if (!isflagset(VAR_44, VAR_72)) {
setflag(VAR_44, VAR_91);
setflag(VAR_44, VAR_92);
assert(VAR_38 == NULL); 
VAR_34 = krb5_db_get_principal(VAR_59, VAR_37->client,
VAR_44, &VAR_38);
}
}
if (isflagset(VAR_44, VAR_84) && !VAR_46)
VAR_17.client = VAR_29;
else
VAR_17.client = VAR_36->client;
VAR_17.session = &VAR_24;
VAR_17.transited.tr_type = VAR_93;
VAR_17.transited.tr_contents = VAR_94; 
if (!VAR_47 ||
krb5_realm_compare(VAR_59, VAR_15->server,
VAR_17.client)) {
VAR_17.transited = VAR_36->transited;
} else {
if (VAR_36->transited.tr_type !=
VAR_93) {
VAR_35 = ""VALIDATE_TRANSIT_TYPE"";
VAR_34 = VAR_95;
goto cleanup;
}
memset(&VAR_17.transited, 0, sizeof(VAR_17.transited));
VAR_17.transited.tr_type = VAR_93;
if ((VAR_34 =
add_to_transited(&VAR_36->transited.tr_contents,
&VAR_17.transited.tr_contents,
VAR_15->server,
VAR_17.client,
VAR_0->server))) {
VAR_35 = ""ADD_TO_TRANSITED_LIST"";
goto cleanup;
}
VAR_18 = 1;
}
if (!isflagset (VAR_0->kdc_options, VAR_96)) {
VAR_34 = kdc_check_transited_list (VAR_3,
&VAR_17.transited.tr_contents,
krb5_princ_realm (VAR_59, VAR_36->client),
krb5_princ_realm (VAR_59, VAR_0->server));
if (VAR_34 == 0) {
setflag (VAR_17.flags, VAR_97);
} else {
log_tgs_badtrans(VAR_59, VAR_27, VAR_28,
&VAR_17.transited.tr_contents, VAR_34);
}
} else
krb5_klog_syslog(VAR_98, _(""not checking transit path""));
if (VAR_3->realm_reject_bad_transit &&
!isflagset(VAR_17.flags, VAR_97)) {
VAR_34 = VAR_99;
VAR_35 = ""BAD_TRANSIT"";
VAR_54->violation = VAR_76;
goto cleanup;
}
VAR_34 = handle_authdata(VAR_59, VAR_44, VAR_38, VAR_9,
VAR_11, VAR_40, &VAR_25,
VAR_5 != NULL ? VAR_5 :
VAR_15->enc_part2->session,
VAR_21, VAR_8, VAR_1, VAR_0,
VAR_29, VAR_56, VAR_37,
&VAR_55, &VAR_17);
if (VAR_34) {
krb5_klog_syslog(VAR_98, _(""TGS_REQ : handle_authdata (%d)""),
VAR_34);
VAR_35 = ""HANDLE_AUTHDATA"";
goto cleanup;
}
VAR_14.enc_part2 = &VAR_17;
if (isflagset(VAR_0->kdc_options, VAR_89)) {
VAR_49 = 0;
VAR_14.enc_part.enctype = VAR_16->enc_part2->session->enctype;
kau_u2u(VAR_59, TRUE, VAR_54);
} else {
VAR_49 = current_kvno(VAR_9);
}
VAR_34 = krb5_encrypt_tkt_part(VAR_59, VAR_21,
&VAR_14);
if (VAR_34)
goto cleanup;
VAR_14.enc_part.kvno = VAR_49;
VAR_54->stage = VAR_100;
VAR_12.msg_type = VAR_101;
if (isflagset(VAR_44, VAR_72) &&
krb5int_find_pa_data(VAR_59, VAR_0->padata,
VAR_102) != NULL) {
VAR_34 = kdc_make_s4u2self_rep(VAR_59,
VAR_5,
VAR_15->enc_part2->session,
VAR_42,
&VAR_12,
&VAR_13);
if (VAR_34)
VAR_54->status = VAR_35;
kau_s4u2self(VAR_59, VAR_34 ? FALSE : TRUE, VAR_54);
if (VAR_34)
goto cleanup;
}
VAR_12.client = VAR_17.client;
VAR_12.enc_part.kvno = 0;
VAR_12.ticket = &VAR_14;
VAR_13.session = &VAR_24;
VAR_13.nonce = VAR_0->nonce;
VAR_13.times = VAR_17.times;
VAR_33.lr_type = VAR_103;
VAR_33.value = 0;
VAR_33.magic = 0;
VAR_32[0] = &VAR_33;
VAR_32[1] = 0;
VAR_13.last_req = VAR_32;        
VAR_13.key_exp = 0;
VAR_13.flags = VAR_17.flags;
VAR_13.server = VAR_14.server;
VAR_12.enc_part.enctype = VAR_5 ? VAR_5->enctype :
VAR_15->enc_part2->session->enctype;
VAR_34  = kdc_fast_response_handle_padata(VAR_50, VAR_0, &VAR_12,
VAR_5 ? VAR_5->enctype : VAR_15->enc_part2->session->enctype);
if (VAR_34)
goto cleanup;
VAR_34 =kdc_fast_handle_reply_key(VAR_50,
VAR_5?VAR_5:VAR_15->enc_part2->session, &VAR_26);
if (VAR_34)
goto cleanup;
VAR_34 = return_enc_padata(VAR_59, VAR_1, VAR_0,
VAR_26, VAR_9, &VAR_13,
VAR_46 &&
isflagset(VAR_45,
VAR_64));
if (VAR_34) {
VAR_35 = ""KDC_RETURN_ENC_PADATA"";
goto cleanup;
}
VAR_34 = kau_make_tkt_id(VAR_59, &VAR_14, &VAR_54->tkt_out_id);
if (VAR_34)
goto cleanup;
if (kdc_fast_hide_client(VAR_50))
VAR_12.client = (krb5_principal)krb5_anonymous_principal();
VAR_34 = krb5_encode_kdc_rep(VAR_59, VAR_101, &VAR_13,
VAR_5 ? 1 : 0,
VAR_26,
&VAR_12, VAR_4);
if (!VAR_34)
VAR_35 = ""ISSUE"";
memset(VAR_14.enc_part.ciphertext.data, 0,
VAR_14.enc_part.ciphertext.length);
free(VAR_14.enc_part.ciphertext.data);
memset(VAR_12.enc_part.ciphertext.data, 0,
VAR_12.enc_part.ciphertext.length);
free(VAR_12.enc_part.ciphertext.data);
cleanup:
if (VAR_35 == NULL)
VAR_35 = ""UNKNOWN_REASON"";
krb5_free_keyblock_contents(VAR_59, &VAR_20);
if (VAR_26)
krb5_free_keyblock(VAR_59, VAR_26);
if (VAR_7)
krb5_free_keyblock(VAR_59, VAR_7);
if (VAR_34)
VAR_48 = krb5_get_error_message (VAR_59, VAR_34);
if (VAR_54 != NULL) {
VAR_54->status = VAR_35;
if (!VAR_34)
VAR_54->reply = &VAR_12;
kau_tgs_req(VAR_59, VAR_34 ? FALSE : TRUE, VAR_54);
kau_free_kdc_req(VAR_54);
}
log_tgs_req(VAR_59, VAR_2, VAR_0, &VAR_12, VAR_27,
VAR_28, VAR_29, VAR_23,
VAR_44, VAR_35, VAR_34, VAR_48);
if (VAR_34) {
krb5_free_error_message (VAR_59, VAR_48);
VAR_48 = NULL;
}
if (VAR_34 && VAR_50 != NULL) {
int VAR_104 = 0;
if (VAR_35 == 0) {
VAR_35 = krb5_get_error_message (VAR_59, VAR_34);
VAR_104 = 1;
}
VAR_34 -= VAR_71;
if (VAR_34 < 0 || VAR_34 > VAR_105)
VAR_34 = VAR_106;
VAR_19 = prepare_error_tgs(VAR_50, VAR_0, VAR_15, VAR_34,
(VAR_9 != NULL) ? VAR_9->princ : NULL,
VAR_4, VAR_35, VAR_53);
if (VAR_104) {
krb5_free_error_message (VAR_59, VAR_35);
VAR_35 = 0;
}
}
if (VAR_15 != NULL)
krb5_free_ticket(VAR_59, VAR_15);
if (VAR_0 != NULL)
krb5_free_kdc_req(VAR_59, VAR_0);
if (VAR_50)
kdc_free_rstate(VAR_50);
krb5_db_free_principal(VAR_59, VAR_9);
krb5_db_free_principal(VAR_59, VAR_10);
krb5_db_free_principal(VAR_59, VAR_39);
krb5_db_free_principal(VAR_59, VAR_38);
krb5_db_free_principal(VAR_59, VAR_41);
if (VAR_25.contents != NULL)
krb5_free_keyblock_contents(VAR_59, &VAR_25);
if (VAR_24.contents != NULL)
krb5_free_keyblock_contents(VAR_59, &VAR_24);
if (VAR_18)
free(VAR_17.transited.tr_contents.data);
if (VAR_42 != NULL)
krb5_free_pa_s4u_x509_user(VAR_59, VAR_42);
if (VAR_43 != NULL)
krb5_free_authdata(VAR_59, VAR_43);
if (VAR_5 != NULL)
krb5_free_keyblock(VAR_59, VAR_5);
if (VAR_6 != NULL)
krb5_free_keyblock(VAR_59, VAR_6);
if (VAR_12.padata)
krb5_free_pa_data(VAR_59, VAR_12.padata);
if (VAR_13.enc_padata)
krb5_free_pa_data(VAR_59, VAR_13.enc_padata);
if (VAR_17.authorization_data != NULL)
krb5_free_authdata(VAR_59, VAR_17.authorization_data);
krb5_free_pa_data(VAR_59, VAR_53);
k5_free_data_ptr_list(VAR_55);
krb5_db_free_authdata_info(VAR_59, VAR_56);
krb5_db_free_authdata_info(VAR_59, VAR_57);
krb5_free_principal(VAR_59, VAR_31);
return VAR_19;
}",krb5/d775c95af7606a51bf79547a94fa52ddd1cb7f49/do_tgs_req.c/vul/before/0.json,"krb5_error_code
process_tgs_req(krb5_kdc_req *request, krb5_data *pkt,
                const krb5_fulladdr *from, kdc_realm_t *kdc_active_realm,
                krb5_data **response)
{
    krb5_keyblock * subkey = 0;
    krb5_keyblock *header_key = NULL;
    krb5_keyblock *stkt_server_key = NULL;
    krb5_keyblock *subject_key;
    krb5_db_entry *server = NULL;
    krb5_db_entry *stkt_server = NULL;
    krb5_db_entry *subject_server;
    krb5_kdc_rep reply;
    krb5_enc_kdc_rep_part reply_encpart;
    krb5_ticket ticket_reply, *header_ticket = 0;
    const krb5_ticket *stkt = NULL;
    krb5_enc_tkt_part enc_tkt_reply;
    int newtransited = 0;
    krb5_error_code retval = 0;
    krb5_keyblock server_keyblock, *encrypting_key;
    krb5_timestamp kdc_time, authtime = 0;
    krb5_keyblock session_key, local_tgt_key;
    krb5_keyblock *reply_key = NULL;
    krb5_principal cprinc = NULL, sprinc = NULL, altcprinc = NULL;
    krb5_const_principal authdata_client;
    krb5_principal stkt_authdata_client = NULL;
    krb5_last_req_entry *nolrarray[2], nolrentry;
    int errcode;
    const char        *status = 0;
    krb5_enc_tkt_part *header_enc_tkt = NULL; /* TGT */
    krb5_enc_tkt_part *subject_tkt = NULL; /* TGT or evidence ticket */
    krb5_db_entry *client = NULL, *header_server = NULL;
    krb5_db_entry *local_tgt, *local_tgt_storage = NULL;
    krb5_pa_s4u_x509_user *s4u_x509_user = NULL; /* protocol transition request */
    krb5_authdata **kdc_issued_auth_data = NULL; /* auth data issued by KDC */
    unsigned int c_flags = 0, s_flags = 0;       /* client/server KDB flags */
    krb5_boolean is_referral, is_crossrealm;
    const char *emsg = NULL;
    krb5_kvno ticket_kvno = 0;
    struct kdc_request_state *state = NULL;
    krb5_pa_data *pa_tgs_req; /*points into request*/
    krb5_data scratch;
    krb5_pa_data **e_data = NULL;
    krb5_audit_state *au_state = NULL;
    krb5_data **auth_indicators = NULL;
    void *ad_info = NULL, *stkt_ad_info = NULL;

    memset(&reply, 0, sizeof(reply));
    memset(&reply_encpart, 0, sizeof(reply_encpart));
    memset(&ticket_reply, 0, sizeof(ticket_reply));
    memset(&enc_tkt_reply, 0, sizeof(enc_tkt_reply));
    memset(&server_keyblock, 0, sizeof(server_keyblock));
    memset(&local_tgt_key, 0, sizeof(local_tgt_key));
    session_key.contents = NULL;

    /* Save pointer to client-requested service principal, in case of
     * errors before a successful call to search_sprinc(). */
    sprinc = request->server;

    if (request->msg_type != KRB5_TGS_REQ) {
        krb5_free_kdc_req(kdc_context, request);
        return KRB5_BADMSGTYPE;
    }

    errcode = kdc_make_rstate(kdc_active_realm, &state);
    if (errcode != 0)
        goto cleanup;

    /* Initialize audit state. */
    errcode = kau_init_kdc_req(kdc_context, request, from, &au_state);
    if (errcode)
        goto cleanup;

    /* Seed the audit trail with the request ID and basic information. */
    kau_tgs_req(kdc_context, TRUE, au_state);

    errcode = kdc_process_tgs_req(kdc_active_realm,
                                  request, from, pkt, &header_ticket,
                                  &header_server, &header_key, &subkey,
                                  &pa_tgs_req);
    if (header_ticket && header_ticket->enc_part2)
        cprinc = header_ticket->enc_part2->client;

    if (errcode) {
        status = ""PROCESS_TGS"";
        goto cleanup;
    }

    if (!header_ticket) {
        errcode = KRB5_NO_TKT_SUPPLIED;        /* XXX? */
        goto cleanup;
    }
    errcode = kau_make_tkt_id(kdc_context, header_ticket,
                              &au_state->tkt_in_id);
    if (errcode)
        goto cleanup;

    scratch.length = pa_tgs_req->length;
    scratch.data = (char *) pa_tgs_req->contents;
    errcode = kdc_find_fast(&request, &scratch, subkey,
                            header_ticket->enc_part2->session, state, NULL);
    /* Reset sprinc because kdc_find_fast() can replace request. */
    sprinc = request->server;
    if (errcode !=0) {
        status = ""FIND_FAST"";
        goto cleanup;
    }
    if (sprinc == NULL) {
        status = ""NULL_SERVER"";
        errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;
        goto cleanup;
    }

    errcode = get_local_tgt(kdc_context, &sprinc->realm, header_server,
                            &local_tgt, &local_tgt_storage, &local_tgt_key);
    if (errcode) {
        status = ""GET_LOCAL_TGT"";
        goto cleanup;
    }

    /* Ignore (for now) the request modification due to FAST processing. */
    au_state->request = request;

    /*
     * Pointer to the encrypted part of the header ticket, which may be
     * replaced to point to the encrypted part of the evidence ticket
     * if constrained delegation is used. This simplifies the number of
     * special cases for constrained delegation.
     */
    header_enc_tkt = header_ticket->enc_part2;

    /*
     * We've already dealt with the AP_REQ authentication, so we can
     * use header_ticket freely.  The encrypted part (if any) has been
     * decrypted with the session key.
     */

    au_state->stage = SRVC_PRINC;

    /* XXX make sure server here has the proper realm...taken from AP_REQ
       header? */

    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE)) {
        setflag(c_flags, KRB5_KDB_FLAG_CANONICALIZE);
        setflag(s_flags, KRB5_KDB_FLAG_CANONICALIZE);
    }

    errcode = search_sprinc(kdc_active_realm, request, s_flags, &server,
                            &status);
    if (errcode != 0)
        goto cleanup;
    sprinc = server->princ;

    /* If we got a cross-realm TGS which is not the requested server, we are
     * issuing a referral (or alternate TGT, which we treat similarly). */
    is_referral = is_cross_tgs_principal(server->princ) &&
        !krb5_principal_compare(kdc_context, request->server, server->princ);

    au_state->stage = VALIDATE_POL;

    if ((errcode = krb5_timeofday(kdc_context, &kdc_time)))
        goto cleanup;

    is_crossrealm = !data_eq(header_server->princ->realm, sprinc->realm);
    if (is_crossrealm)
        setflag(c_flags, KRB5_KDB_FLAG_CROSS_REALM);
    if (is_referral)
        setflag(c_flags, KRB5_KDB_FLAG_ISSUING_REFERRAL);

    /* Check for protocol transition */
    errcode = kdc_process_s4u2self_req(kdc_active_realm, request, server,
                                       subkey, header_enc_tkt->session,
                                       &s4u_x509_user, &client, &status);
    if (s4u_x509_user != NULL || errcode != 0) {
        if (s4u_x509_user != NULL)
            au_state->s4u2self_user = s4u_x509_user->user_id.user;
        au_state->status = status;
        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);
        au_state->s4u2self_user = NULL;
    }

    /* For user-to-user and S4U2Proxy requests, decrypt the second ticket. */
    errcode = decrypt_2ndtkt(kdc_active_realm, request, c_flags,
                             &stkt, &stkt_server, &stkt_server_key, &status);
    if (errcode)
        goto cleanup;

    retval = validate_tgs_request(kdc_active_realm, request, server,
                                  header_ticket, stkt, stkt_server, kdc_time,
                                  s4u_x509_user, client, is_crossrealm,
                                  is_referral, &status, &e_data);
    if (retval) {
        if (retval == KDC_ERR_POLICY || retval == KDC_ERR_BADOPTION)
            au_state->violation = PROT_CONSTRAINT;
        errcode = retval + ERROR_TABLE_BASE_krb5;
        goto cleanup;
    }

    if (errcode)
        goto cleanup;

    if (s4u_x509_user != NULL && client == NULL) {
        /*
         * For an S4U2Self referral request (the requesting service is
         * following a referral back to its own realm), the authdata in the
         * header ticket should be for the requested client.
         */
        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);
        authdata_client = s4u_x509_user->user_id.user;
    } else {
        /* Otherwise (including for initial S4U2Self requests), the authdata
         * should be for the header ticket client. */
        authdata_client = header_enc_tkt->client;
    }
    errcode = krb5_db_get_authdata_info(kdc_context, c_flags,
                                        header_enc_tkt->authorization_data,
                                        authdata_client, request->server,
                                        header_key, &local_tgt_key, local_tgt,
                                        header_enc_tkt->times.authtime,
                                        &ad_info, NULL);
    if (errcode && errcode != KRB5_PLUGIN_OP_NOTSUPP)
        goto cleanup;

    /* Flag all S4U2Self requests now that we have checked the authdata. */
    if (s4u_x509_user != NULL)
        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);

    if (isflagset(request->kdc_options, KDC_OPT_CNAME_IN_ADDL_TKT)) {
        /* Do constrained delegation protocol and authorization checks. */
        setflag(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION);

        errcode = kdc_process_s4u2proxy_req(kdc_active_realm, c_flags, request,
                                            stkt->enc_part2, local_tgt,
                                            &local_tgt_key, stkt_server,
                                            stkt_server_key,
                                            header_ticket->enc_part2->client,
                                            server, request->server, ad_info,
                                            &stkt_ad_info,
                                            &stkt_authdata_client,
                                            &status);
        if (errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION)
            au_state->violation = PROT_CONSTRAINT;
        else if (errcode)
            au_state->violation = LOCAL_POLICY;
        au_state->status = status;
        retval = kau_make_tkt_id(kdc_context, stkt, &au_state->evid_tkt_id);
        if (retval) {
            errcode = retval;
            goto cleanup;
        }
        kau_s4u2proxy(kdc_context, errcode ? FALSE : TRUE, au_state);
        if (errcode)
            goto cleanup;

        assert(krb5_is_tgs_principal(header_ticket->server));

        /* Use the parsed authdata from the second ticket during authdata
         * handling. */
        krb5_db_free_authdata_info(kdc_context, ad_info);
        ad_info = stkt_ad_info;
        stkt_ad_info = NULL;
    }

    au_state->stage = ISSUE_TKT;

    errcode = gen_session_key(kdc_active_realm, request, server, &session_key,
                              &status);
    if (errcode)
        goto cleanup;

    /*
     * subject_tkt will refer to the evidence ticket (for constrained
     * delegation) or the TGT. The distinction from header_enc_tkt is
     * necessary because the TGS signature only protects some fields:
     * the others could be forged by a malicious server.
     */

    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {
        subject_tkt = stkt->enc_part2;
        subject_server = stkt_server;
        subject_key = stkt_server_key;
    } else {
        subject_tkt = header_enc_tkt;
        subject_server = header_server;
        subject_key = header_key;
    }
    authtime = subject_tkt->times.authtime;

    /* Extract and check auth indicators from the subject ticket, except for
     * S4U2Self requests (where the client didn't authenticate). */
    if (s4u_x509_user == NULL) {
        errcode = get_auth_indicators(kdc_context, subject_tkt, local_tgt,
                                      &local_tgt_key, &auth_indicators);
        if (errcode) {
            status = ""GET_AUTH_INDICATORS"";
            goto cleanup;
        }

        errcode = check_indicators(kdc_context, server, auth_indicators);
        if (errcode) {
            status = ""HIGHER_AUTHENTICATION_REQUIRED"";
            goto cleanup;
        }
    }

    if (is_referral)
        ticket_reply.server = server->princ;
    else
        ticket_reply.server = request->server; /* XXX careful for realm... */

    enc_tkt_reply.flags = get_ticket_flags(request->kdc_options, client,
                                           server, header_enc_tkt);
    enc_tkt_reply.times.starttime = 0;

    /* OK_TO_AUTH_AS_DELEGATE must be set on the service requesting S4U2Self
     * for forwardable tickets to be issued. */
    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&
        !is_referral &&
        !isflagset(server->attributes, KRB5_KDB_OK_TO_AUTH_AS_DELEGATE))
        clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);

    /* don't use new addresses unless forwarded, see below */

    enc_tkt_reply.caddrs = header_enc_tkt->caddrs;
    /* noaddrarray[0] = 0; */
    reply_encpart.caddrs = 0;/* optional...don't put it in */
    reply_encpart.enc_padata = NULL;

    /*
     * It should be noted that local policy may affect the
     * processing of any of these flags.  For example, some
     * realms may refuse to issue renewable tickets
     */

    if (isflagset(request->kdc_options, KDC_OPT_FORWARDED) ||
        isflagset(request->kdc_options, KDC_OPT_PROXY)) {

        /* include new addresses in ticket & reply */

        enc_tkt_reply.caddrs = request->addresses;
        reply_encpart.caddrs = request->addresses;
    }

    if (isflagset(request->kdc_options, KDC_OPT_POSTDATED))
        enc_tkt_reply.times.starttime = request->from;
    else
        enc_tkt_reply.times.starttime = kdc_time;

    if (isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {
        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);
        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs
           to the caller */
        ticket_reply = *(header_ticket);
        enc_tkt_reply = *(header_ticket->enc_part2);
        enc_tkt_reply.authorization_data = NULL;
        clear(enc_tkt_reply.flags, TKT_FLG_INVALID);
    }

    if (isflagset(request->kdc_options, KDC_OPT_RENEW)) {
        krb5_timestamp old_starttime;
        krb5_deltat old_life;

        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);
        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs
           to the caller */
        ticket_reply = *(header_ticket);
        enc_tkt_reply = *(header_ticket->enc_part2);
        enc_tkt_reply.authorization_data = NULL;

        old_starttime = enc_tkt_reply.times.starttime ?
            enc_tkt_reply.times.starttime : enc_tkt_reply.times.authtime;
        old_life = ts_delta(enc_tkt_reply.times.endtime, old_starttime);

        enc_tkt_reply.times.starttime = kdc_time;
        enc_tkt_reply.times.endtime =
            ts_min(header_ticket->enc_part2->times.renew_till,
                   ts_incr(kdc_time, old_life));
    } else {
        /* not a renew request */
        enc_tkt_reply.times.starttime = kdc_time;

        kdc_get_ticket_endtime(kdc_active_realm, enc_tkt_reply.times.starttime,
                               header_enc_tkt->times.endtime, request->till,
                               client, server, &enc_tkt_reply.times.endtime);
    }

    kdc_get_ticket_renewtime(kdc_active_realm, request, header_enc_tkt, client,
                             server, &enc_tkt_reply);

    errcode = check_kdcpolicy_tgs(kdc_context, request, server, header_ticket,
                                  auth_indicators, kdc_time,
                                  &enc_tkt_reply.times, &status);
    if (errcode)
        goto cleanup;

    /*
     * Set authtime to be the same as header or evidence ticket's
     */
    enc_tkt_reply.times.authtime = authtime;

    /* starttime is optional, and treated as authtime if not present.
       so we can nuke it if it matches */
    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)
        enc_tkt_reply.times.starttime = 0;

    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {
        altcprinc = s4u_x509_user->user_id.user;
    } else if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {
        /* kdc_process_s4u2proxy_req() only allows cross-realm requests if
         * stkt_authdata_client is set. */
        altcprinc = is_crossrealm ? stkt_authdata_client : subject_tkt->client;
    } else {
        altcprinc = NULL;
    }
    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {
        encrypting_key = stkt->enc_part2->session;
    } else {
        errcode = get_first_current_key(kdc_context, server, &server_keyblock);
        if (errcode) {
            status = ""FINDING_SERVER_KEY"";
            goto cleanup;
        }
        encrypting_key = &server_keyblock;
    }

    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {
        /*
         * Don't allow authorization data to be disabled if constrained
         * delegation is requested. We don't want to deny the server
         * the ability to validate that delegation was used.
         */
        clear(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED);
    }
    if (isflagset(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED) == 0) {
        /* If we are not doing protocol transition, try to look up the subject
         * principal so that KDB modules can add additional authdata. */
        if (!isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {
            /* Generate authorization data so we can include it in ticket */
            setflag(c_flags, KRB5_KDB_FLAG_INCLUDE_PAC);
            /* Map principals from foreign (possibly non-AD) realms */
            setflag(c_flags, KRB5_KDB_FLAG_MAP_PRINCIPALS);

            assert(client == NULL); /* should not have been set already */

            errcode = krb5_db_get_principal(kdc_context, subject_tkt->client,
                                            c_flags, &client);
        }
    }

    if (isflagset(c_flags, KRB5_KDB_FLAGS_S4U) && !is_referral)
        enc_tkt_reply.client = altcprinc;
    else
        enc_tkt_reply.client = header_enc_tkt->client;

    enc_tkt_reply.session = &session_key;
    enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;
    enc_tkt_reply.transited.tr_contents = empty_string; /* equivalent of """" */

    /*
     * Only add the realm of the presented tgt to the transited list if
     * it is different than the server realm (cross-realm) and it is different
     * than the realm of the client (since the realm of the client is already
     * implicitly part of the transited list and should not be explicitly
     * listed).
     */
    if (!is_crossrealm ||
        krb5_realm_compare(kdc_context, header_ticket->server,
                           enc_tkt_reply.client)) {
        /* tgt issued by local realm or issued by realm of client */
        enc_tkt_reply.transited = header_enc_tkt->transited;
    } else {
        /* tgt issued by some other realm and not the realm of the client */
        /* assemble new transited field into allocated storage */
        if (header_enc_tkt->transited.tr_type !=
            KRB5_DOMAIN_X500_COMPRESS) {
            status = ""VALIDATE_TRANSIT_TYPE"";
            errcode = KRB5KDC_ERR_TRTYPE_NOSUPP;
            goto cleanup;
        }
        memset(&enc_tkt_reply.transited, 0, sizeof(enc_tkt_reply.transited));
        enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;
        if ((errcode =
             add_to_transited(&header_enc_tkt->transited.tr_contents,
                              &enc_tkt_reply.transited.tr_contents,
                              header_ticket->server,
                              enc_tkt_reply.client,
                              request->server))) {
            status = ""ADD_TO_TRANSITED_LIST"";
            goto cleanup;
        }
        newtransited = 1;
    }
    if (!isflagset (request->kdc_options, KDC_OPT_DISABLE_TRANSITED_CHECK)) {
        errcode = kdc_check_transited_list (kdc_active_realm,
                                            &enc_tkt_reply.transited.tr_contents,
                                            krb5_princ_realm (kdc_context, header_enc_tkt->client),
                                            krb5_princ_realm (kdc_context, request->server));
        if (errcode == 0) {
            setflag (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED);
        } else {
            log_tgs_badtrans(kdc_context, cprinc, sprinc,
                             &enc_tkt_reply.transited.tr_contents, errcode);
        }
    } else
        krb5_klog_syslog(LOG_INFO, _(""not checking transit path""));
    if (kdc_active_realm->realm_reject_bad_transit &&
        !isflagset(enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED)) {
        errcode = KRB5KDC_ERR_POLICY;
        status = ""BAD_TRANSIT"";
        au_state->violation = LOCAL_POLICY;
        goto cleanup;
    }

    errcode = handle_authdata(kdc_context, c_flags, client, server,
                              subject_server, local_tgt, &local_tgt_key,
                              subkey != NULL ? subkey :
                              header_ticket->enc_part2->session,
                              encrypting_key, subject_key, pkt, request,
                              altcprinc, ad_info, subject_tkt,
                              &auth_indicators, &enc_tkt_reply);
    if (errcode) {
        krb5_klog_syslog(LOG_INFO, _(""TGS_REQ : handle_authdata (%d)""),
                         errcode);
        status = ""HANDLE_AUTHDATA"";
        goto cleanup;
    }

    ticket_reply.enc_part2 = &enc_tkt_reply;

    /* If we are doing user-to-user authentication, encrypt the ticket using
     * the session key of the second ticket. */
    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {
        ticket_kvno = 0;
        ticket_reply.enc_part.enctype = stkt->enc_part2->session->enctype;
        kau_u2u(kdc_context, TRUE, au_state);
    } else {
        ticket_kvno = current_kvno(server);
    }

    errcode = krb5_encrypt_tkt_part(kdc_context, encrypting_key,
                                    &ticket_reply);
    if (errcode)
        goto cleanup;
    ticket_reply.enc_part.kvno = ticket_kvno;
    /* Start assembling the response */
    au_state->stage = ENCR_REP;
    reply.msg_type = KRB5_TGS_REP;
    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&
        krb5int_find_pa_data(kdc_context, request->padata,
                             KRB5_PADATA_S4U_X509_USER) != NULL) {
        errcode = kdc_make_s4u2self_rep(kdc_context,
                                        subkey,
                                        header_ticket->enc_part2->session,
                                        s4u_x509_user,
                                        &reply,
                                        &reply_encpart);
        if (errcode)
            au_state->status = status;
        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);
        if (errcode)
            goto cleanup;
    }

    reply.client = enc_tkt_reply.client;
    reply.enc_part.kvno = 0;/* We are using the session key */
    reply.ticket = &ticket_reply;

    reply_encpart.session = &session_key;
    reply_encpart.nonce = request->nonce;

    /* copy the time fields */
    reply_encpart.times = enc_tkt_reply.times;

    nolrentry.lr_type = KRB5_LRQ_NONE;
    nolrentry.value = 0;
    nolrentry.magic = 0;
    nolrarray[0] = &nolrentry;
    nolrarray[1] = 0;
    reply_encpart.last_req = nolrarray;        /* not available for TGS reqs */
    reply_encpart.key_exp = 0;/* ditto */
    reply_encpart.flags = enc_tkt_reply.flags;
    reply_encpart.server = ticket_reply.server;

    /* use the session key in the ticket, unless there's a subsession key
       in the AP_REQ */
    reply.enc_part.enctype = subkey ? subkey->enctype :
        header_ticket->enc_part2->session->enctype;
    errcode  = kdc_fast_response_handle_padata(state, request, &reply,
                                               subkey ? subkey->enctype : header_ticket->enc_part2->session->enctype);
    if (errcode)
        goto cleanup;
    errcode =kdc_fast_handle_reply_key(state,
                                       subkey?subkey:header_ticket->enc_part2->session, &reply_key);
    if (errcode)
        goto cleanup;
    errcode = return_enc_padata(kdc_context, pkt, request,
                                reply_key, server, &reply_encpart,
                                is_referral &&
                                isflagset(s_flags,
                                          KRB5_KDB_FLAG_CANONICALIZE));
    if (errcode) {
        status = ""KDC_RETURN_ENC_PADATA"";
        goto cleanup;
    }

    errcode = kau_make_tkt_id(kdc_context, &ticket_reply, &au_state->tkt_out_id);
    if (errcode)
        goto cleanup;

    if (kdc_fast_hide_client(state))
        reply.client = (krb5_principal)krb5_anonymous_principal();
    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_TGS_REP, &reply_encpart,
                                  subkey ? 1 : 0,
                                  reply_key,
                                  &reply, response);
    if (!errcode)
        status = ""ISSUE"";

    memset(ticket_reply.enc_part.ciphertext.data, 0,
           ticket_reply.enc_part.ciphertext.length);
    free(ticket_reply.enc_part.ciphertext.data);
    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we
       can use them in raw form if needed.  But, we don't... */
    memset(reply.enc_part.ciphertext.data, 0,
           reply.enc_part.ciphertext.length);
    free(reply.enc_part.ciphertext.data);

cleanup:
    if (status == NULL)
        status = ""UNKNOWN_REASON"";
    krb5_free_keyblock_contents(kdc_context, &server_keyblock);
    if (reply_key)
        krb5_free_keyblock(kdc_context, reply_key);
    if (stkt_server_key)
        krb5_free_keyblock(kdc_context, stkt_server_key);
    if (errcode)
        emsg = krb5_get_error_message (kdc_context, errcode);

    if (au_state != NULL) {
        au_state->status = status;
        if (!errcode)
            au_state->reply = &reply;
        kau_tgs_req(kdc_context, errcode ? FALSE : TRUE, au_state);
        kau_free_kdc_req(au_state);
    }

    log_tgs_req(kdc_context, from, request, &reply, cprinc,
                sprinc, altcprinc, authtime,
                c_flags, status, errcode, emsg);
    if (errcode) {
        krb5_free_error_message (kdc_context, emsg);
        emsg = NULL;
    }

    if (errcode && state != NULL) {
        int got_err = 0;
        if (status == 0) {
            status = krb5_get_error_message (kdc_context, errcode);
            got_err = 1;
        }
        errcode -= ERROR_TABLE_BASE_krb5;
        if (errcode < 0 || errcode > KRB_ERR_MAX)
            errcode = KRB_ERR_GENERIC;

        retval = prepare_error_tgs(state, request, header_ticket, errcode,
                                   (server != NULL) ? server->princ : NULL,
                                   response, status, e_data);
        if (got_err) {
            krb5_free_error_message (kdc_context, status);
            status = 0;
        }
    }

    if (header_ticket != NULL)
        krb5_free_ticket(kdc_context, header_ticket);
    if (request != NULL)
        krb5_free_kdc_req(kdc_context, request);
    if (state)
        kdc_free_rstate(state);
    krb5_db_free_principal(kdc_context, server);
    krb5_db_free_principal(kdc_context, stkt_server);
    krb5_db_free_principal(kdc_context, header_server);
    krb5_db_free_principal(kdc_context, client);
    krb5_db_free_principal(kdc_context, local_tgt_storage);
    if (local_tgt_key.contents != NULL)
        krb5_free_keyblock_contents(kdc_context, &local_tgt_key);
    if (session_key.contents != NULL)
        krb5_free_keyblock_contents(kdc_context, &session_key);
    if (newtransited)
        free(enc_tkt_reply.transited.tr_contents.data);
    if (s4u_x509_user != NULL)
        krb5_free_pa_s4u_x509_user(kdc_context, s4u_x509_user);
    if (kdc_issued_auth_data != NULL)
        krb5_free_authdata(kdc_context, kdc_issued_auth_data);
    if (subkey != NULL)
        krb5_free_keyblock(kdc_context, subkey);
    if (header_key != NULL)
        krb5_free_keyblock(kdc_context, header_key);
    if (reply.padata)
        krb5_free_pa_data(kdc_context, reply.padata);
    if (reply_encpart.enc_padata)
        krb5_free_pa_data(kdc_context, reply_encpart.enc_padata);
    if (enc_tkt_reply.authorization_data != NULL)
        krb5_free_authdata(kdc_context, enc_tkt_reply.authorization_data);
    krb5_free_pa_data(kdc_context, e_data);
    k5_free_data_ptr_list(auth_indicators);
    krb5_db_free_authdata_info(kdc_context, ad_info);
    krb5_db_free_authdata_info(kdc_context, stkt_ad_info);
    krb5_free_principal(kdc_context, stkt_authdata_client);

    return retval;
}","krb5_error_code
process_tgs_req(krb5_kdc_req *VAR_0, krb5_data *VAR_1,
                const krb5_fulladdr *VAR_2, kdc_realm_t *VAR_3,
                krb5_data **VAR_4)
{
    krb5_keyblock * VAR_5 = 0;
    krb5_keyblock *VAR_6 = NULL;
    krb5_keyblock *VAR_7 = NULL;
    krb5_keyblock *VAR_8;
    krb5_db_entry *VAR_9 = NULL;
    krb5_db_entry *VAR_10 = NULL;
    krb5_db_entry *VAR_11;
    krb5_kdc_rep VAR_12;
    krb5_enc_kdc_rep_part VAR_13;
    krb5_ticket VAR_14, *VAR_15 = 0;
    const krb5_ticket *VAR_16 = NULL;
    krb5_enc_tkt_part VAR_17;
    int VAR_18 = 0;
    krb5_error_code VAR_19 = 0;
    krb5_keyblock VAR_20, *VAR_21;
    krb5_timestamp VAR_22, VAR_23 = 0;
    krb5_keyblock VAR_24, VAR_25;
    krb5_keyblock *VAR_26 = NULL;
    krb5_principal VAR_27 = NULL, VAR_28 = NULL, VAR_29 = NULL;
    krb5_const_principal VAR_30;
    krb5_principal VAR_31 = NULL;
    krb5_last_req_entry *VAR_32[2], VAR_33;
    int VAR_34;
    const char        *VAR_35 = 0;
    krb5_enc_tkt_part *VAR_36 = NULL; /* COMMENT_0 */
    krb5_enc_tkt_part *VAR_37 = NULL; /* COMMENT_1 */
    krb5_db_entry *VAR_38 = NULL, *VAR_39 = NULL;
    krb5_db_entry *VAR_40, *VAR_41 = NULL;
    krb5_pa_s4u_x509_user *VAR_42 = NULL; /* COMMENT_2 */
    krb5_authdata **VAR_43 = NULL; /* COMMENT_3 */
    unsigned int VAR_44 = 0, VAR_45 = 0;       /* COMMENT_4 */
    krb5_boolean VAR_46, VAR_47;
    const char *VAR_48 = NULL;
    krb5_kvno VAR_49 = 0;
    struct kdc_request_state *VAR_50 = NULL;
    krb5_pa_data *VAR_51; /* COMMENT_5 */
    krb5_data VAR_52;
    krb5_pa_data **VAR_53 = NULL;
    krb5_audit_state *VAR_54 = NULL;
    krb5_data **VAR_55 = NULL;
    void *VAR_56 = NULL, *VAR_57 = NULL;

    memset(&VAR_12, 0, sizeof(VAR_12));
    memset(&VAR_13, 0, sizeof(VAR_13));
    memset(&VAR_14, 0, sizeof(VAR_14));
    memset(&VAR_17, 0, sizeof(VAR_17));
    memset(&VAR_20, 0, sizeof(VAR_20));
    memset(&VAR_25, 0, sizeof(VAR_25));
    VAR_24.contents = NULL;

    /* COMMENT_6 */
                                                             
    VAR_28 = VAR_0->server;

    if (VAR_0->msg_type != VAR_58) {
        krb5_free_kdc_req(VAR_59, VAR_0);
        return VAR_60;
    }

    VAR_34 = kdc_make_rstate(VAR_3, &VAR_50);
    if (VAR_34 != 0)
        goto cleanup;

    /* COMMENT_8 */
    VAR_34 = kau_init_kdc_req(VAR_59, VAR_0, VAR_2, &VAR_54);
    if (VAR_34)
        goto cleanup;

    /* COMMENT_9 */
    kau_tgs_req(VAR_59, TRUE, VAR_54);

    VAR_34 = kdc_process_tgs_req(VAR_3,
                                  VAR_0, VAR_2, VAR_1, &VAR_15,
                                  &VAR_39, &VAR_6, &VAR_5,
                                  &VAR_51);
    if (VAR_15 && VAR_15->enc_part2)
        VAR_27 = VAR_15->enc_part2->client;

    if (VAR_34) {
        VAR_35 = ""PROCESS_TGS"";
        goto cleanup;
    }

    if (!VAR_15) {
        VAR_34 = VAR_61;        /* COMMENT_10 */
        goto cleanup;
    }
    VAR_34 = kau_make_tkt_id(VAR_59, VAR_15,
                              &VAR_54->tkt_in_id);
    if (VAR_34)
        goto cleanup;

    VAR_52.length = VAR_51->length;
    VAR_52.data = (char *) VAR_51->contents;
    VAR_34 = kdc_find_fast(&VAR_0, &VAR_52, VAR_5,
                            VAR_15->enc_part2->session, VAR_50, NULL);
    /* COMMENT_11 */
    VAR_28 = VAR_0->server;
    if (VAR_34 !=0) {
        VAR_35 = ""FIND_FAST"";
        goto cleanup;
    }
    if (VAR_28 == NULL) {
        VAR_35 = ""NULL_SERVER"";
        VAR_34 = VAR_62;
        goto cleanup;
    }

    VAR_34 = get_local_tgt(VAR_59, &VAR_28->realm, VAR_39,
                            &VAR_40, &VAR_41, &VAR_25);
    if (VAR_34) {
        VAR_35 = ""GET_LOCAL_TGT"";
        goto cleanup;
    }

    /* COMMENT_12 */
    VAR_54->request = VAR_0;

    /* COMMENT_13 */
                                                                       
                                                                     
                                                                       
                                                
       
    VAR_36 = VAR_15->enc_part2;

    /* COMMENT_19 */
                                                                    
                                                                      
                                      
       

    VAR_54->stage = VAR_63;

    /* COMMENT_24 */
                 

    if (isflagset(VAR_0->kdc_options, VAR_64)) {
        setflag(VAR_44, VAR_65);
        setflag(VAR_45, VAR_65);
    }

    VAR_34 = search_sprinc(VAR_3, VAR_0, VAR_45, &VAR_9,
                            &VAR_35);
    if (VAR_34 != 0)
        goto cleanup;
    VAR_28 = VAR_9->princ;

    /* COMMENT_26 */
                                                                          
    VAR_46 = is_cross_tgs_principal(VAR_9->princ) &&
        !krb5_principal_compare(VAR_59, VAR_0->server, VAR_9->princ);

    VAR_54->stage = VAR_66;

    if ((VAR_34 = krb5_timeofday(VAR_59, &VAR_22)))
        goto cleanup;

    VAR_47 = !data_eq(VAR_39->princ->realm, VAR_28->realm);
    if (VAR_47)
        setflag(VAR_44, VAR_67);
    if (VAR_46)
        setflag(VAR_44, VAR_68);

    /* COMMENT_28 */
    VAR_34 = kdc_process_s4u2self_req(VAR_3, VAR_0, VAR_9,
                                       VAR_5, VAR_36->session,
                                       &VAR_42, &VAR_38, &VAR_35);
    if (VAR_42 != NULL || VAR_34 != 0) {
        if (VAR_42 != NULL)
            VAR_54->s4u2self_user = VAR_42->user_id.user;
        VAR_54->status = VAR_35;
        kau_s4u2self(VAR_59, VAR_34 ? FALSE : TRUE, VAR_54);
        VAR_54->s4u2self_user = NULL;
    }

    /* COMMENT_29 */
    VAR_34 = decrypt_2ndtkt(VAR_3, VAR_0, VAR_44,
                             &VAR_16, &VAR_10, &VAR_7, &VAR_35);
    if (VAR_34)
        goto cleanup;

    VAR_19 = validate_tgs_request(VAR_3, VAR_0, VAR_9,
                                  VAR_15, VAR_16, VAR_10, VAR_22,
                                  VAR_42, VAR_38, VAR_47,
                                  VAR_46, &VAR_35, &VAR_53);
    if (VAR_19) {
        if (VAR_19 == VAR_69 || VAR_19 == VAR_70)
            VAR_54->violation = VAR_71;
        VAR_34 = VAR_19 + VAR_72;
        goto cleanup;
    }

    if (VAR_34)
        goto cleanup;

    if (VAR_42 != NULL && VAR_38 == NULL) {
        /* COMMENT_30 */
                                                                      
                                                                           
                                                            
           
        setflag(VAR_44, VAR_73);
        VAR_30 = VAR_42->user_id.user;
    } else {
        /* COMMENT_35 */
                                                     
        VAR_30 = VAR_36->client;
    }
    VAR_34 = krb5_db_get_authdata_info(VAR_59, VAR_44,
                                        VAR_36->authorization_data,
                                        VAR_30, VAR_0->server,
                                        VAR_6, &VAR_25, VAR_40,
                                        VAR_36->times.authtime,
                                        &VAR_56, NULL);
    if (VAR_34 && VAR_34 != VAR_74)
        goto cleanup;

    /* COMMENT_37 */
    if (VAR_42 != NULL)
        setflag(VAR_44, VAR_73);

    if (isflagset(VAR_0->kdc_options, VAR_75)) {
        /* COMMENT_38 */
        setflag(VAR_44, VAR_76);

        VAR_34 = kdc_process_s4u2proxy_req(VAR_3, VAR_44, VAR_0,
                                            VAR_16->enc_part2, VAR_40,
                                            &VAR_25, VAR_10,
                                            VAR_7,
                                            VAR_15->enc_part2->client,
                                            VAR_9, VAR_0->server, VAR_56,
                                            &VAR_57,
                                            &VAR_31,
                                            &VAR_35);
        if (VAR_34 == VAR_69 || VAR_34 == VAR_70)
            VAR_54->violation = VAR_71;
        else if (VAR_34)
            VAR_54->violation = VAR_77;
        VAR_54->status = VAR_35;
        VAR_19 = kau_make_tkt_id(VAR_59, VAR_16, &VAR_54->evid_tkt_id);
        if (VAR_19) {
            VAR_34 = VAR_19;
            goto cleanup;
        }
        kau_s4u2proxy(VAR_59, VAR_34 ? FALSE : TRUE, VAR_54);
        if (VAR_34)
            goto cleanup;

        assert(krb5_is_tgs_principal(VAR_15->server));

        /* COMMENT_39 */
                       
        krb5_db_free_authdata_info(VAR_59, VAR_56);
        VAR_56 = VAR_57;
        VAR_57 = NULL;
    }

    VAR_54->stage = VAR_78;

    VAR_34 = gen_session_key(VAR_3, VAR_0, VAR_9, &VAR_24,
                              &VAR_35);
    if (VAR_34)
        goto cleanup;

    /* COMMENT_41 */
                                                                     
                                                                     
                                                                     
                                                        
       

    if (isflagset(VAR_44, VAR_76)) {
        VAR_37 = VAR_16->enc_part2;
        VAR_11 = VAR_10;
        VAR_8 = VAR_7;
    } else {
        VAR_37 = VAR_36;
        VAR_11 = VAR_39;
        VAR_8 = VAR_6;
    }
    VAR_23 = VAR_37->times.authtime;

    /* COMMENT_47 */
                                                                   
    if (VAR_42 == NULL) {
        VAR_34 = get_auth_indicators(VAR_59, VAR_37, VAR_40,
                                      &VAR_25, &VAR_55);
        if (VAR_34) {
            VAR_35 = ""GET_AUTH_INDICATORS"";
            goto cleanup;
        }

        VAR_34 = check_indicators(VAR_59, VAR_9, VAR_55);
        if (VAR_34) {
            VAR_35 = ""HIGHER_AUTHENTICATION_REQUIRED"";
            goto cleanup;
        }
    }

    if (VAR_46)
        VAR_14.server = VAR_9->princ;
    else
        VAR_14.server = VAR_0->server; /* COMMENT_49 */

    VAR_17.flags = get_ticket_flags(VAR_0->kdc_options, VAR_38,
                                           VAR_9, VAR_36);
    VAR_17.times.starttime = 0;

    /* COMMENT_50 */
                                               
    if (isflagset(VAR_44, VAR_73) &&
        !VAR_46 &&
        !isflagset(VAR_9->attributes, VAR_79))
        clear(VAR_17.flags, VAR_80);

    /* COMMENT_52 */

    VAR_17.caddrs = VAR_36->caddrs;
    /* COMMENT_53 */
    VAR_13.caddrs = 0;/* COMMENT_54 */
    VAR_13.enc_padata = NULL;

    /* COMMENT_55 */
                                                          
                                                           
                                                   
       

    if (isflagset(VAR_0->kdc_options, VAR_81) ||
        isflagset(VAR_0->kdc_options, VAR_82)) {

        /* COMMENT_60 */

        VAR_17.caddrs = VAR_0->addresses;
        VAR_13.caddrs = VAR_0->addresses;
    }

    if (isflagset(VAR_0->kdc_options, VAR_83))
        VAR_17.times.starttime = VAR_0->from;
    else
        VAR_17.times.starttime = VAR_22;

    if (isflagset(VAR_0->kdc_options, VAR_84)) {
        assert(isflagset(VAR_44, VAR_85) == 0);
        /* COMMENT_61 */
                           
        VAR_14 = *(VAR_15);
        VAR_17 = *(VAR_15->enc_part2);
        VAR_17.authorization_data = NULL;
        clear(VAR_17.flags, VAR_86);
    }

    if (isflagset(VAR_0->kdc_options, VAR_87)) {
        krb5_timestamp VAR_88;
        krb5_deltat VAR_89;

        assert(isflagset(VAR_44, VAR_85) == 0);
        /* COMMENT_63 */
                           
        VAR_14 = *(VAR_15);
        VAR_17 = *(VAR_15->enc_part2);
        VAR_17.authorization_data = NULL;

        VAR_88 = VAR_17.times.starttime ?
            VAR_17.times.starttime : VAR_17.times.authtime;
        VAR_89 = ts_delta(VAR_17.times.endtime, VAR_88);

        VAR_17.times.starttime = VAR_22;
        VAR_17.times.endtime =
            ts_min(VAR_15->enc_part2->times.renew_till,
                   ts_incr(VAR_22, VAR_89));
    } else {
        /* COMMENT_65 */
        VAR_17.times.starttime = VAR_22;

        kdc_get_ticket_endtime(VAR_3, VAR_17.times.starttime,
                               VAR_36->times.endtime, VAR_0->till,
                               VAR_38, VAR_9, &VAR_17.times.endtime);
    }

    kdc_get_ticket_renewtime(VAR_3, VAR_0, VAR_36, VAR_38,
                             VAR_9, &VAR_17);

    VAR_34 = check_kdcpolicy_tgs(VAR_59, VAR_0, VAR_9, VAR_15,
                                  VAR_55, VAR_22,
                                  &VAR_17.times, &VAR_35);
    if (VAR_34)
        goto cleanup;

    /* COMMENT_66 */
                                                                 
       
    VAR_17.times.authtime = VAR_23;

    /* COMMENT_69 */
                                         
    if (VAR_17.times.starttime == VAR_17.times.authtime)
        VAR_17.times.starttime = 0;

    if (isflagset(VAR_44, VAR_73)) {
        VAR_29 = VAR_42->user_id.user;
    } else if (isflagset(VAR_44, VAR_76)) {
        /* COMMENT_71 */
                                          
        VAR_29 = VAR_47 ? VAR_31 : VAR_37->client;
    } else {
        VAR_29 = NULL;
    }
    if (isflagset(VAR_0->kdc_options, VAR_90)) {
        VAR_21 = VAR_16->enc_part2->session;
    } else {
        VAR_34 = get_first_current_key(VAR_59, VAR_9, &VAR_20);
        if (VAR_34) {
            VAR_35 = ""FINDING_SERVER_KEY"";
            goto cleanup;
        }
        VAR_21 = &VAR_20;
    }

    if (isflagset(VAR_44, VAR_76)) {
        /* COMMENT_73 */
                                                                       
                                                                    
                                                            
           
        clear(VAR_9->attributes, VAR_91);
    }
    if (isflagset(VAR_9->attributes, VAR_91) == 0) {
        /* COMMENT_78 */
                                                                        
        if (!isflagset(VAR_44, VAR_73)) {
            /* COMMENT_80 */
            setflag(VAR_44, VAR_92);
            /* COMMENT_81 */
            setflag(VAR_44, VAR_93);

            assert(VAR_38 == NULL); /* COMMENT_82 */

            VAR_34 = krb5_db_get_principal(VAR_59, VAR_37->client,
                                            VAR_44, &VAR_38);
        }
    }

    if (isflagset(VAR_44, VAR_85) && !VAR_46)
        VAR_17.client = VAR_29;
    else
        VAR_17.client = VAR_36->client;

    VAR_17.session = &VAR_24;
    VAR_17.transited.tr_type = VAR_94;
    VAR_17.transited.tr_contents = VAR_95; /* COMMENT_83 */

    /* COMMENT_84 */
                                                                       
                                                                              
                                                                             
                                                                         
               
       
    if (!VAR_47 ||
        krb5_realm_compare(VAR_59, VAR_15->server,
                           VAR_17.client)) {
        /* COMMENT_91 */
        VAR_17.transited = VAR_36->transited;
    } else {
        /* COMMENT_92 */
        /* COMMENT_93 */
        if (VAR_36->transited.tr_type !=
            VAR_94) {
            VAR_35 = ""VALIDATE_TRANSIT_TYPE"";
            VAR_34 = VAR_96;
            goto cleanup;
        }
        memset(&VAR_17.transited, 0, sizeof(VAR_17.transited));
        VAR_17.transited.tr_type = VAR_94;
        if ((VAR_34 =
             add_to_transited(&VAR_36->transited.tr_contents,
                              &VAR_17.transited.tr_contents,
                              VAR_15->server,
                              VAR_17.client,
                              VAR_0->server))) {
            VAR_35 = ""ADD_TO_TRANSITED_LIST"";
            goto cleanup;
        }
        VAR_18 = 1;
    }
    if (!isflagset (VAR_0->kdc_options, VAR_97)) {
        VAR_34 = kdc_check_transited_list (VAR_3,
                                            &VAR_17.transited.tr_contents,
                                            krb5_princ_realm (VAR_59, VAR_36->client),
                                            krb5_princ_realm (VAR_59, VAR_0->server));
        if (VAR_34 == 0) {
            setflag (VAR_17.flags, VAR_98);
        } else {
            log_tgs_badtrans(VAR_59, VAR_27, VAR_28,
                             &VAR_17.transited.tr_contents, VAR_34);
        }
    } else
        krb5_klog_syslog(VAR_99, _(""not checking transit path""));
    if (VAR_3->realm_reject_bad_transit &&
        !isflagset(VAR_17.flags, VAR_98)) {
        VAR_34 = VAR_100;
        VAR_35 = ""BAD_TRANSIT"";
        VAR_54->violation = VAR_77;
        goto cleanup;
    }

    VAR_34 = handle_authdata(VAR_59, VAR_44, VAR_38, VAR_9,
                              VAR_11, VAR_40, &VAR_25,
                              VAR_5 != NULL ? VAR_5 :
                              VAR_15->enc_part2->session,
                              VAR_21, VAR_8, VAR_1, VAR_0,
                              VAR_29, VAR_56, VAR_37,
                              &VAR_55, &VAR_17);
    if (VAR_34) {
        krb5_klog_syslog(VAR_99, _(""TGS_REQ : handle_authdata (%d)""),
                         VAR_34);
        VAR_35 = ""HANDLE_AUTHDATA"";
        goto cleanup;
    }

    VAR_14.enc_part2 = &VAR_17;

    /* COMMENT_94 */
                                               
    if (isflagset(VAR_0->kdc_options, VAR_90)) {
        VAR_49 = 0;
        VAR_14.enc_part.enctype = VAR_16->enc_part2->session->enctype;
        kau_u2u(VAR_59, TRUE, VAR_54);
    } else {
        VAR_49 = current_kvno(VAR_9);
    }

    VAR_34 = krb5_encrypt_tkt_part(VAR_59, VAR_21,
                                    &VAR_14);
    if (VAR_34)
        goto cleanup;
    VAR_14.enc_part.kvno = VAR_49;
    /* COMMENT_96 */
    VAR_54->stage = VAR_101;
    VAR_12.msg_type = VAR_102;
    if (isflagset(VAR_44, VAR_73) &&
        krb5int_find_pa_data(VAR_59, VAR_0->padata,
                             VAR_103) != NULL) {
        VAR_34 = kdc_make_s4u2self_rep(VAR_59,
                                        VAR_5,
                                        VAR_15->enc_part2->session,
                                        VAR_42,
                                        &VAR_12,
                                        &VAR_13);
        if (VAR_34)
            VAR_54->status = VAR_35;
        kau_s4u2self(VAR_59, VAR_34 ? FALSE : TRUE, VAR_54);
        if (VAR_34)
            goto cleanup;
    }

    VAR_12.client = VAR_17.client;
    VAR_12.enc_part.kvno = 0;/* COMMENT_97 */
    VAR_12.ticket = &VAR_14;

    VAR_13.session = &VAR_24;
    VAR_13.nonce = VAR_0->nonce;

    /* COMMENT_98 */
    VAR_13.times = VAR_17.times;

    VAR_33.lr_type = VAR_104;
    VAR_33.value = 0;
    VAR_33.magic = 0;
    VAR_32[0] = &VAR_33;
    VAR_32[1] = 0;
    VAR_13.last_req = VAR_32;        /* COMMENT_99 */
    VAR_13.key_exp = 0;/* COMMENT_100 */
    VAR_13.flags = VAR_17.flags;
    VAR_13.server = VAR_14.server;

    /* COMMENT_101 */
                       
    VAR_12.enc_part.enctype = VAR_5 ? VAR_5->enctype :
        VAR_15->enc_part2->session->enctype;
    VAR_34  = kdc_fast_response_handle_padata(VAR_50, VAR_0, &VAR_12,
                                               VAR_5 ? VAR_5->enctype : VAR_15->enc_part2->session->enctype);
    if (VAR_34)
        goto cleanup;
    VAR_34 =kdc_fast_handle_reply_key(VAR_50,
                                       VAR_5?VAR_5:VAR_15->enc_part2->session, &VAR_26);
    if (VAR_34)
        goto cleanup;
    VAR_34 = return_enc_padata(VAR_59, VAR_1, VAR_0,
                                VAR_26, VAR_9, &VAR_13,
                                VAR_46 &&
                                isflagset(VAR_45,
                                          VAR_65));
    if (VAR_34) {
        VAR_35 = ""KDC_RETURN_ENC_PADATA"";
        goto cleanup;
    }

    VAR_34 = kau_make_tkt_id(VAR_59, &VAR_14, &VAR_54->tkt_out_id);
    if (VAR_34)
        goto cleanup;

    if (kdc_fast_hide_client(VAR_50))
        VAR_12.client = (krb5_principal)krb5_anonymous_principal();
    VAR_34 = krb5_encode_kdc_rep(VAR_59, VAR_102, &VAR_13,
                                  VAR_5 ? 1 : 0,
                                  VAR_26,
                                  &VAR_12, VAR_4);
    if (!VAR_34)
        VAR_35 = ""ISSUE"";

    memset(VAR_14.enc_part.ciphertext.data, 0,
           VAR_14.enc_part.ciphertext.length);
    free(VAR_14.enc_part.ciphertext.data);
    /* COMMENT_103 */
                                                               
    memset(VAR_12.enc_part.ciphertext.data, 0,
           VAR_12.enc_part.ciphertext.length);
    free(VAR_12.enc_part.ciphertext.data);

cleanup:
    if (VAR_35 == NULL)
        VAR_35 = ""UNKNOWN_REASON"";
    krb5_free_keyblock_contents(VAR_59, &VAR_20);
    if (VAR_26)
        krb5_free_keyblock(VAR_59, VAR_26);
    if (VAR_7)
        krb5_free_keyblock(VAR_59, VAR_7);
    if (VAR_34)
        VAR_48 = krb5_get_error_message (VAR_59, VAR_34);

    if (VAR_54 != NULL) {
        VAR_54->status = VAR_35;
        if (!VAR_34)
            VAR_54->reply = &VAR_12;
        kau_tgs_req(VAR_59, VAR_34 ? FALSE : TRUE, VAR_54);
        kau_free_kdc_req(VAR_54);
    }

    log_tgs_req(VAR_59, VAR_2, VAR_0, &VAR_12, VAR_27,
                VAR_28, VAR_29, VAR_23,
                VAR_44, VAR_35, VAR_34, VAR_48);
    if (VAR_34) {
        krb5_free_error_message (VAR_59, VAR_48);
        VAR_48 = NULL;
    }

    if (VAR_34 && VAR_50 != NULL) {
        int VAR_105 = 0;
        if (VAR_35 == 0) {
            VAR_35 = krb5_get_error_message (VAR_59, VAR_34);
            VAR_105 = 1;
        }
        VAR_34 -= VAR_72;
        if (VAR_34 < 0 || VAR_34 > VAR_106)
            VAR_34 = VAR_107;

        VAR_19 = prepare_error_tgs(VAR_50, VAR_0, VAR_15, VAR_34,
                                   (VAR_9 != NULL) ? VAR_9->princ : NULL,
                                   VAR_4, VAR_35, VAR_53);
        if (VAR_105) {
            krb5_free_error_message (VAR_59, VAR_35);
            VAR_35 = 0;
        }
    }

    if (VAR_15 != NULL)
        krb5_free_ticket(VAR_59, VAR_15);
    if (VAR_0 != NULL)
        krb5_free_kdc_req(VAR_59, VAR_0);
    if (VAR_50)
        kdc_free_rstate(VAR_50);
    krb5_db_free_principal(VAR_59, VAR_9);
    krb5_db_free_principal(VAR_59, VAR_10);
    krb5_db_free_principal(VAR_59, VAR_39);
    krb5_db_free_principal(VAR_59, VAR_38);
    krb5_db_free_principal(VAR_59, VAR_41);
    if (VAR_25.contents != NULL)
        krb5_free_keyblock_contents(VAR_59, &VAR_25);
    if (VAR_24.contents != NULL)
        krb5_free_keyblock_contents(VAR_59, &VAR_24);
    if (VAR_18)
        free(VAR_17.transited.tr_contents.data);
    if (VAR_42 != NULL)
        krb5_free_pa_s4u_x509_user(VAR_59, VAR_42);
    if (VAR_43 != NULL)
        krb5_free_authdata(VAR_59, VAR_43);
    if (VAR_5 != NULL)
        krb5_free_keyblock(VAR_59, VAR_5);
    if (VAR_6 != NULL)
        krb5_free_keyblock(VAR_59, VAR_6);
    if (VAR_12.padata)
        krb5_free_pa_data(VAR_59, VAR_12.padata);
    if (VAR_13.enc_padata)
        krb5_free_pa_data(VAR_59, VAR_13.enc_padata);
    if (VAR_17.authorization_data != NULL)
        krb5_free_authdata(VAR_59, VAR_17.authorization_data);
    krb5_free_pa_data(VAR_59, VAR_53);
    k5_free_data_ptr_list(VAR_55);
    krb5_db_free_authdata_info(VAR_59, VAR_56);
    krb5_db_free_authdata_info(VAR_59, VAR_57);
    krb5_free_principal(VAR_59, VAR_31);

    return VAR_19;
}",krb5/d775c95af7606a51bf79547a94fa52ddd1cb7f49/do_tgs_req.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -105,6 +105,11 @@
         status = ""FIND_FAST"";
         goto cleanup;
     }
+    if (sprinc == NULL) {
+        status = ""NULL_SERVER"";
+        errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;
+        goto cleanup;
+    }
 
     errcode = get_local_tgt(kdc_context, &sprinc->realm, header_server,
                             &local_tgt, &local_tgt_storage, &local_tgt_key);","{'deleted_lines': [], 'added_lines': ['    if (sprinc == NULL) {', '        status = ""NULL_SERVER"";', '        errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;', '        goto cleanup;', '    }']}",True,The Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.18.5 and 1.19.x before 1.19.3 has a NULL pointer dereference in kdc/do_tgs_req.c via a FAST inner body that lacks a server field.,6.5,MEDIUM,1,valid,2021-08-03T05:15:27Z,3
CVE-2021-46854,['CWE-401'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N,1,proftpd,mod_radius: copy _only_ the password,10a227b4d50e0a2cd2faf87926f58d865da44e43,https://github.com/proftpd/proftpd/commit/10a227b4d50e0a2cd2faf87926f58d865da44e43,contrib/mod_radius.c,radius_add_passwd,"static void radius_add_passwd(radius_packet_t *packet, unsigned char type,
const unsigned char *passwd, unsigned char *secret, size_t secret_len) {
MD5_CTX ctx, secret_ctx;
radius_attrib_t *attrib = NULL;
unsigned char calculated[RADIUS_VECTOR_LEN];
unsigned char pwhash[PR_TUNABLE_BUFFER_SIZE];
unsigned char *digest = NULL;
register unsigned int i = 0;
size_t pwlen;
pwlen = strlen((const char *) passwd);
if (pwlen == 0) {
pwlen = RADIUS_PASSWD_LEN;
} if ((pwlen & (RADIUS_PASSWD_LEN - 1)) != 0) {
pwlen += (RADIUS_PASSWD_LEN - 1);
pwlen &= ~(RADIUS_PASSWD_LEN - 1);
}
memset(pwhash, '\0', sizeof(pwhash));
memcpy(pwhash, passwd, pwlen);
attrib = radius_get_attrib(packet, RADIUS_PASSWORD);
if (type == RADIUS_PASSWORD) {
digest = packet->digest;
} else {
digest = attrib->data;
}
MD5_Init(&secret_ctx);
MD5_Update(&secret_ctx, secret, secret_len);
ctx = secret_ctx;
MD5_Update(&ctx, digest, RADIUS_VECTOR_LEN);
MD5_Final(calculated, &ctx);
radius_xor(pwhash, calculated, RADIUS_PASSWD_LEN);
for (i = 1; i < (pwlen >> 4); i++) {
ctx = secret_ctx;
MD5_Update(&ctx, &pwhash[(i-1) * RADIUS_PASSWD_LEN], RADIUS_PASSWD_LEN);
MD5_Final(calculated, &ctx);
radius_xor(&pwhash[i * RADIUS_PASSWD_LEN], calculated, RADIUS_PASSWD_LEN);
}
if (type == RADIUS_OLD_PASSWORD) {
attrib = radius_get_attrib(packet, RADIUS_OLD_PASSWORD);
}
if (attrib == NULL) {
radius_add_attrib(packet, type, pwhash, pwlen);
} else {
memcpy(attrib->data, pwhash, pwlen);
}
pr_memscrub(pwhash, sizeof(pwhash));
}","static void radius_add_passwd(radius_packet_t *VAR_0, unsigned char VAR_1,
const unsigned char *VAR_2, unsigned char *VAR_3, size_t VAR_4) {
MD5_CTX VAR_5, VAR_6;
radius_attrib_t *VAR_7 = NULL;
unsigned char VAR_8[VAR_9];
unsigned char VAR_10[VAR_11];
unsigned char *VAR_12 = NULL;
register unsigned int VAR_13 = 0;
size_t VAR_14;
VAR_14 = strlen((const char *) VAR_2);
if (VAR_14 == 0) {
VAR_14 = VAR_15;
} if ((VAR_14 & (VAR_15 - 1)) != 0) {
VAR_14 += (VAR_15 - 1);
VAR_14 &= ~(VAR_15 - 1);
}
memset(VAR_10, '\0', sizeof(VAR_10));
memcpy(VAR_10, VAR_2, VAR_14);
VAR_7 = radius_get_attrib(VAR_0, VAR_16);
if (VAR_1 == VAR_16) {
VAR_12 = VAR_0->digest;
} else {
VAR_12 = VAR_7->data;
}
MD5_Init(&VAR_6);
MD5_Update(&VAR_6, VAR_3, VAR_4);
VAR_5 = VAR_6;
MD5_Update(&VAR_5, VAR_12, VAR_9);
MD5_Final(VAR_8, &VAR_5);
radius_xor(VAR_10, VAR_8, VAR_15);
for (VAR_13 = 1; VAR_13 < (VAR_14 >> 4); VAR_13++) {
VAR_5 = VAR_6;
MD5_Update(&VAR_5, &VAR_10[(VAR_13-1) * VAR_15], VAR_15);
MD5_Final(VAR_8, &VAR_5);
radius_xor(&VAR_10[VAR_13 * VAR_15], VAR_8, VAR_15);
}
if (VAR_1 == VAR_17) {
VAR_7 = radius_get_attrib(VAR_0, VAR_17);
}
if (VAR_7 == NULL) {
radius_add_attrib(VAR_0, VAR_1, VAR_10, VAR_14);
} else {
memcpy(VAR_7->data, VAR_10, VAR_14);
}
pr_memscrub(VAR_10, sizeof(VAR_10));
}",proftpd/10a227b4d50e0a2cd2faf87926f58d865da44e43/mod_radius.c/vul/before/0.json,"static void radius_add_passwd(radius_packet_t *packet, unsigned char type,
    const unsigned char *passwd, unsigned char *secret, size_t secret_len) {
  MD5_CTX ctx, secret_ctx;
  radius_attrib_t *attrib = NULL;
  unsigned char calculated[RADIUS_VECTOR_LEN];
  unsigned char pwhash[PR_TUNABLE_BUFFER_SIZE];
  unsigned char *digest = NULL;
  register unsigned int i = 0;
  size_t pwlen;

  pwlen = strlen((const char *) passwd);

  /* Clear the buffers. */
  memset(pwhash, '\0', sizeof(pwhash));

  if (pwlen == 0) {
    pwlen = RADIUS_PASSWD_LEN;

  } if ((pwlen & (RADIUS_PASSWD_LEN - 1)) != 0) {
    /* pwlen is not a multiple of RADIUS_PASSWD_LEN, need to prepare a proper buffer */
    memcpy(pwhash, passwd, pwlen);

    /* Round up the length. */
    pwlen += (RADIUS_PASSWD_LEN - 1);

    /* Truncate the length, as necessary. */
    pwlen &= ~(RADIUS_PASSWD_LEN - 1);
  } else {
    /* pwlen is a multiple of RADIUS_PASSWD_LEN, we can just use it. */
    memcpy(pwhash, passwd, pwlen);
  }


  /* Find the password attribute. */
  attrib = radius_get_attrib(packet, RADIUS_PASSWORD);

  if (type == RADIUS_PASSWORD) {
    digest = packet->digest;

  } else {
    digest = attrib->data;
  }

  /* Encrypt the password.  Password: c[0] = p[0] ^ MD5(secret + digest) */
  MD5_Init(&secret_ctx);
  MD5_Update(&secret_ctx, secret, secret_len);

  /* Save this hash for later. */
  ctx = secret_ctx;

  MD5_Update(&ctx, digest, RADIUS_VECTOR_LEN);

  /* Set the calculated digest. */
  MD5_Final(calculated, &ctx);

  /* XOR the results. */
  radius_xor(pwhash, calculated, RADIUS_PASSWD_LEN);
  
  /* For each step through: e[i] = p[i] ^ MD5(secret + e[i-1]) */
  for (i = 1; i < (pwlen >> 4); i++) {

    /* Start with the old value of the MD5 sum. */
    ctx = secret_ctx;

    MD5_Update(&ctx, &pwhash[(i-1) * RADIUS_PASSWD_LEN], RADIUS_PASSWD_LEN);

    /* Set the calculated digest. */
    MD5_Final(calculated, &ctx);

    /* XOR the results. */
    radius_xor(&pwhash[i * RADIUS_PASSWD_LEN], calculated, RADIUS_PASSWD_LEN);
  }

  if (type == RADIUS_OLD_PASSWORD) {
    attrib = radius_get_attrib(packet, RADIUS_OLD_PASSWORD);
  }
 
  if (attrib == NULL) {
    radius_add_attrib(packet, type, pwhash, pwlen);

  } else {
    /* Overwrite the packet data. */
    memcpy(attrib->data, pwhash, pwlen);
  }

  pr_memscrub(pwhash, sizeof(pwhash));
}","static void radius_add_passwd(radius_packet_t *VAR_0, unsigned char VAR_1,
    const unsigned char *VAR_2, unsigned char *VAR_3, size_t VAR_4) {
  MD5_CTX VAR_5, VAR_6;
  radius_attrib_t *VAR_7 = NULL;
  unsigned char VAR_8[VAR_9];
  unsigned char VAR_10[VAR_11];
  unsigned char *VAR_12 = NULL;
  register unsigned int VAR_13 = 0;
  size_t VAR_14;

  VAR_14 = strlen((const char *) VAR_2);

  /* COMMENT_0 */
  memset(VAR_10, '\0', sizeof(VAR_10));

  if (VAR_14 == 0) {
    VAR_14 = VAR_15;

  } if ((VAR_14 & (VAR_15 - 1)) != 0) {
    /* COMMENT_1 */
    memcpy(VAR_10, VAR_2, VAR_14);

    /* COMMENT_2 */
    VAR_14 += (VAR_15 - 1);

    /* COMMENT_3 */
    VAR_14 &= ~(VAR_15 - 1);
  } else {
    /* COMMENT_4 */
    memcpy(VAR_10, VAR_2, VAR_14);
  }


  /* COMMENT_5 */
  VAR_7 = radius_get_attrib(VAR_0, VAR_16);

  if (VAR_1 == VAR_16) {
    VAR_12 = VAR_0->digest;

  } else {
    VAR_12 = VAR_7->data;
  }

  /* COMMENT_6 */
  MD5_Init(&VAR_6);
  MD5_Update(&VAR_6, VAR_3, VAR_4);

  /* COMMENT_7 */
  VAR_5 = VAR_6;

  MD5_Update(&VAR_5, VAR_12, VAR_9);

  /* COMMENT_8 */
  MD5_Final(VAR_8, &VAR_5);

  /* COMMENT_9 */
  radius_xor(VAR_10, VAR_8, VAR_15);
  
  /* COMMENT_10 */
  for (VAR_13 = 1; VAR_13 < (VAR_14 >> 4); VAR_13++) {

    /* COMMENT_11 */
    VAR_5 = VAR_6;

    MD5_Update(&VAR_5, &VAR_10[(VAR_13-1) * VAR_15], VAR_15);

    /* COMMENT_8 */
    MD5_Final(VAR_8, &VAR_5);

    /* COMMENT_9 */
    radius_xor(&VAR_10[VAR_13 * VAR_15], VAR_8, VAR_15);
  }

  if (VAR_1 == VAR_17) {
    VAR_7 = radius_get_attrib(VAR_0, VAR_17);
  }
 
  if (VAR_7 == NULL) {
    radius_add_attrib(VAR_0, VAR_1, VAR_10, VAR_14);

  } else {
    /* COMMENT_12 */
    memcpy(VAR_7->data, VAR_10, VAR_14);
  }

  pr_memscrub(VAR_10, sizeof(VAR_10));
}",proftpd/10a227b4d50e0a2cd2faf87926f58d865da44e43/mod_radius.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,21 +10,26 @@
 
   pwlen = strlen((const char *) passwd);
 
+  /* Clear the buffers. */
+  memset(pwhash, '\0', sizeof(pwhash));
+
   if (pwlen == 0) {
     pwlen = RADIUS_PASSWD_LEN;
 
   } if ((pwlen & (RADIUS_PASSWD_LEN - 1)) != 0) {
+    /* pwlen is not a multiple of RADIUS_PASSWD_LEN, need to prepare a proper buffer */
+    memcpy(pwhash, passwd, pwlen);
 
     /* Round up the length. */
     pwlen += (RADIUS_PASSWD_LEN - 1);
 
     /* Truncate the length, as necessary. */
     pwlen &= ~(RADIUS_PASSWD_LEN - 1);
+  } else {
+    /* pwlen is a multiple of RADIUS_PASSWD_LEN, we can just use it. */
+    memcpy(pwhash, passwd, pwlen);
   }
 
-  /* Clear the buffers. */
-  memset(pwhash, '\0', sizeof(pwhash));
-  memcpy(pwhash, passwd, pwlen);
 
   /* Find the password attribute. */
   attrib = radius_get_attrib(packet, RADIUS_PASSWORD);","{'deleted_lines': ['  /* Clear the buffers. */', ""  memset(pwhash, '\\0', sizeof(pwhash));"", '  memcpy(pwhash, passwd, pwlen);'], 'added_lines': ['  /* Clear the buffers. */', ""  memset(pwhash, '\\0', sizeof(pwhash));"", '', '    /* pwlen is not a multiple of RADIUS_PASSWD_LEN, need to prepare a proper buffer */', '    memcpy(pwhash, passwd, pwlen);', '  } else {', '    /* pwlen is a multiple of RADIUS_PASSWD_LEN, we can just use it. */', '    memcpy(pwhash, passwd, pwlen);']}",True,mod_radius in ProFTPD before 1.3.7c allows memory disclosure to RADIUS servers because it copies blocks of 16 characters.,7.5,HIGH,2,valid,2021-08-03T19:53:28Z,3
CVE-2021-45931,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,harfbuzz,"[set] Make all operators null-safe again

Changed my mind.

Also for hb_map_clear().

Part of https://github.com/harfbuzz/harfbuzz/pull/3162",d3e09bf4654fe5478b6dbf2b26ebab6271317d81,https://github.com/harfbuzz/harfbuzz/commit/d3e09bf4654fe5478b6dbf2b26ebab6271317d81,src/hb-map.cc,hb_map_clear,"void
hb_map_clear (hb_map_t *map)
{
if (unlikely (hb_object_is_immutable (map)))
return;
return map->clear ();
}","void
hb_map_clear (hb_map_t *VAR_0)
{
if (unlikely (hb_object_is_immutable (VAR_0)))
return;
return VAR_0->clear ();
}",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-map.cc/vul/before/0.json,"void
hb_map_clear (hb_map_t *map)
{
  return map->clear ();
}","void
hb_map_clear (hb_map_t *VAR_0)
{
  return VAR_0->clear ();
}",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-map.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,8 +1,5 @@
 void
 hb_map_clear (hb_map_t *map)
 {
-  if (unlikely (hb_object_is_immutable (map)))
-    return;
-
   return map->clear ();
 }","{'deleted_lines': ['  if (unlikely (hb_object_is_immutable (map)))', '    return;', ''], 'added_lines': []}",True,HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy).,6.5,MEDIUM,1,valid,2021-08-24T16:31:49Z,3
CVE-2021-45931,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,harfbuzz,"[set] Make all operators null-safe again

Changed my mind.

Also for hb_map_clear().

Part of https://github.com/harfbuzz/harfbuzz/pull/3162",d3e09bf4654fe5478b6dbf2b26ebab6271317d81,https://github.com/harfbuzz/harfbuzz/commit/d3e09bf4654fe5478b6dbf2b26ebab6271317d81,src/hb-set.cc,hb_set_subtract,"void
hb_set_subtract (hb_set_t       *set,
const hb_set_t *other)
{
if (unlikely (hb_object_is_immutable (set)))
return;
set->subtract (*other);
}","void
hb_set_subtract (hb_set_t       *VAR_0,
const hb_set_t *VAR_1)
{
if (unlikely (hb_object_is_immutable (VAR_0)))
return;
VAR_0->subtract (*VAR_1);
}",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-set.cc/vul/before/6.json,"void
hb_set_subtract (hb_set_t       *set,
		 const hb_set_t *other)
{
  /* Immutible-safe. */
  set->subtract (*other);
}","void
hb_set_subtract (hb_set_t       *VAR_0,
		 const hb_set_t *VAR_1)
{
  /* COMMENT_0 */
  VAR_0->subtract (*VAR_1);
}",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-set.cc/vul/after/6.json,"--- func_before
+++ func_after
@@ -2,8 +2,6 @@
 hb_set_subtract (hb_set_t       *set,
 		 const hb_set_t *other)
 {
-  if (unlikely (hb_object_is_immutable (set)))
-    return;
-
+  /* Immutible-safe. */
   set->subtract (*other);
 }","{'deleted_lines': ['  if (unlikely (hb_object_is_immutable (set)))', '    return;', ''], 'added_lines': ['  /* Immutible-safe. */']}",True,HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy).,6.5,MEDIUM,1,valid,2021-08-24T16:31:49Z,3
CVE-2021-45931,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,harfbuzz,"[set] Make all operators null-safe again

Changed my mind.

Also for hb_map_clear().

Part of https://github.com/harfbuzz/harfbuzz/pull/3162",d3e09bf4654fe5478b6dbf2b26ebab6271317d81,https://github.com/harfbuzz/harfbuzz/commit/d3e09bf4654fe5478b6dbf2b26ebab6271317d81,src/hb-set.cc,hb_set_symmetric_difference,"void
hb_set_symmetric_difference (hb_set_t       *set,
const hb_set_t *other)
{
if (unlikely (hb_object_is_immutable (set)))
return;
set->symmetric_difference (*other);
}","void
hb_set_symmetric_difference (hb_set_t       *VAR_0,
const hb_set_t *VAR_1)
{
if (unlikely (hb_object_is_immutable (VAR_0)))
return;
VAR_0->symmetric_difference (*VAR_1);
}",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-set.cc/vul/before/5.json,"void
hb_set_symmetric_difference (hb_set_t       *set,
			     const hb_set_t *other)
{
  /* Immutible-safe. */
  set->symmetric_difference (*other);
}","void
hb_set_symmetric_difference (hb_set_t       *VAR_0,
			     const hb_set_t *VAR_1)
{
  /* COMMENT_0 */
  VAR_0->symmetric_difference (*VAR_1);
}",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-set.cc/vul/after/5.json,"--- func_before
+++ func_after
@@ -2,8 +2,6 @@
 hb_set_symmetric_difference (hb_set_t       *set,
 			     const hb_set_t *other)
 {
-  if (unlikely (hb_object_is_immutable (set)))
-    return;
-
+  /* Immutible-safe. */
   set->symmetric_difference (*other);
 }","{'deleted_lines': ['  if (unlikely (hb_object_is_immutable (set)))', '    return;', ''], 'added_lines': ['  /* Immutible-safe. */']}",True,HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy).,6.5,MEDIUM,1,valid,2021-08-24T16:31:49Z,3
CVE-2021-45931,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,harfbuzz,"[set] Make all operators null-safe again

Changed my mind.

Also for hb_map_clear().

Part of https://github.com/harfbuzz/harfbuzz/pull/3162",d3e09bf4654fe5478b6dbf2b26ebab6271317d81,https://github.com/harfbuzz/harfbuzz/commit/d3e09bf4654fe5478b6dbf2b26ebab6271317d81,src/hb-set.cc,hb_set_clear,"void
hb_set_clear (hb_set_t *set)
{
if (unlikely (hb_object_is_immutable (set)))
return;
set->clear ();
}","void
hb_set_clear (hb_set_t *VAR_0)
{
if (unlikely (hb_object_is_immutable (VAR_0)))
return;
VAR_0->clear ();
}",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-set.cc/vul/before/4.json,"void
hb_set_clear (hb_set_t *set)
{
  /* Immutible-safe. */
  set->clear ();
}","void
hb_set_clear (hb_set_t *VAR_0)
{
  /* COMMENT_0 */
  VAR_0->clear ();
}",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-set.cc/vul/after/4.json,"--- func_before
+++ func_after
@@ -1,8 +1,6 @@
 void
 hb_set_clear (hb_set_t *set)
 {
-  if (unlikely (hb_object_is_immutable (set)))
-    return;
-
+  /* Immutible-safe. */
   set->clear ();
 }","{'deleted_lines': ['  if (unlikely (hb_object_is_immutable (set)))', '    return;', ''], 'added_lines': ['  /* Immutible-safe. */']}",True,HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy).,6.5,MEDIUM,1,valid,2021-08-24T16:31:49Z,3
CVE-2021-45931,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,harfbuzz,"[set] Make all operators null-safe again

Changed my mind.

Also for hb_map_clear().

Part of https://github.com/harfbuzz/harfbuzz/pull/3162",d3e09bf4654fe5478b6dbf2b26ebab6271317d81,https://github.com/harfbuzz/harfbuzz/commit/d3e09bf4654fe5478b6dbf2b26ebab6271317d81,src/hb-set.cc,hb_set_union,"void
hb_set_union (hb_set_t       *set,
const hb_set_t *other)
{
if (unlikely (hb_object_is_immutable (set)))
return;
set->union_ (*other);
}","void
hb_set_union (hb_set_t       *VAR_0,
const hb_set_t *VAR_1)
{
if (unlikely (hb_object_is_immutable (VAR_0)))
return;
VAR_0->union_ (*VAR_1);
}",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-set.cc/vul/before/3.json,"void
hb_set_union (hb_set_t       *set,
	      const hb_set_t *other)
{
  /* Immutible-safe. */
  set->union_ (*other);
}","void
hb_set_union (hb_set_t       *VAR_0,
	      const hb_set_t *VAR_1)
{
  /* COMMENT_0 */
  VAR_0->union_ (*VAR_1);
}",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-set.cc/vul/after/3.json,"--- func_before
+++ func_after
@@ -2,8 +2,6 @@
 hb_set_union (hb_set_t       *set,
 	      const hb_set_t *other)
 {
-  if (unlikely (hb_object_is_immutable (set)))
-    return;
-
+  /* Immutible-safe. */
   set->union_ (*other);
 }","{'deleted_lines': ['  if (unlikely (hb_object_is_immutable (set)))', '    return;', ''], 'added_lines': ['  /* Immutible-safe. */']}",True,HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy).,6.5,MEDIUM,1,valid,2021-08-24T16:31:49Z,3
CVE-2021-45931,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,harfbuzz,"[set] Make all operators null-safe again

Changed my mind.

Also for hb_map_clear().

Part of https://github.com/harfbuzz/harfbuzz/pull/3162",d3e09bf4654fe5478b6dbf2b26ebab6271317d81,https://github.com/harfbuzz/harfbuzz/commit/d3e09bf4654fe5478b6dbf2b26ebab6271317d81,src/hb-set.cc,hb_set_invert,"void
hb_set_invert (hb_set_t *set)
{
if (unlikely (hb_object_is_immutable (set)))
return;
set->invert ();
}","void
hb_set_invert (hb_set_t *VAR_0)
{
if (unlikely (hb_object_is_immutable (VAR_0)))
return;
VAR_0->invert ();
}",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-set.cc/vul/before/2.json,"void
hb_set_invert (hb_set_t *set)
{
  /* Immutible-safe. */
  set->invert ();
}","void
hb_set_invert (hb_set_t *VAR_0)
{
  /* COMMENT_0 */
  VAR_0->invert ();
}",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-set.cc/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,8 +1,6 @@
 void
 hb_set_invert (hb_set_t *set)
 {
-  if (unlikely (hb_object_is_immutable (set)))
-    return;
-
+  /* Immutible-safe. */
   set->invert ();
 }","{'deleted_lines': ['  if (unlikely (hb_object_is_immutable (set)))', '    return;', ''], 'added_lines': ['  /* Immutible-safe. */']}",True,HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy).,6.5,MEDIUM,1,valid,2021-08-24T16:31:49Z,3
CVE-2021-45931,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,harfbuzz,"[set] Make all operators null-safe again

Changed my mind.

Also for hb_map_clear().

Part of https://github.com/harfbuzz/harfbuzz/pull/3162",d3e09bf4654fe5478b6dbf2b26ebab6271317d81,https://github.com/harfbuzz/harfbuzz/commit/d3e09bf4654fe5478b6dbf2b26ebab6271317d81,src/hb-set.cc,hb_set_intersect,"void
hb_set_intersect (hb_set_t       *set,
const hb_set_t *other)
{
if (unlikely (hb_object_is_immutable (set)))
return;
set->intersect (*other);
}","void
hb_set_intersect (hb_set_t       *VAR_0,
const hb_set_t *VAR_1)
{
if (unlikely (hb_object_is_immutable (VAR_0)))
return;
VAR_0->intersect (*VAR_1);
}",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-set.cc/vul/before/0.json,"void
hb_set_intersect (hb_set_t       *set,
		  const hb_set_t *other)
{
  /* Immutible-safe. */
  set->intersect (*other);
}","void
hb_set_intersect (hb_set_t       *VAR_0,
		  const hb_set_t *VAR_1)
{
  /* COMMENT_0 */
  VAR_0->intersect (*VAR_1);
}",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-set.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,8 +2,6 @@
 hb_set_intersect (hb_set_t       *set,
 		  const hb_set_t *other)
 {
-  if (unlikely (hb_object_is_immutable (set)))
-    return;
-
+  /* Immutible-safe. */
   set->intersect (*other);
 }","{'deleted_lines': ['  if (unlikely (hb_object_is_immutable (set)))', '    return;', ''], 'added_lines': ['  /* Immutible-safe. */']}",True,HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy).,6.5,MEDIUM,1,valid,2021-08-24T16:31:49Z,3
CVE-2021-45931,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,harfbuzz,"[set] Make all operators null-safe again

Changed my mind.

Also for hb_map_clear().

Part of https://github.com/harfbuzz/harfbuzz/pull/3162",d3e09bf4654fe5478b6dbf2b26ebab6271317d81,https://github.com/harfbuzz/harfbuzz/commit/d3e09bf4654fe5478b6dbf2b26ebab6271317d81,src/hb-map.hh,clear,"void clear ()
{
if (items)
for (auto &_ : hb_iter (items, mask + 1))
_.clear ();
population = occupancy = 0;
}","void clear ()
{
if (VAR_0)
for (auto &VAR_1 : hb_iter (VAR_0, VAR_2 + 1))
VAR_1.clear ();
VAR_3 = VAR_4 = 0;
}",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-map.hh/vul/before/0.json,"void clear ()
  {
    if (unlikely (!successful)) return;

    if (items)
      for (auto &_ : hb_iter (items, mask + 1))
	_.clear ();

    population = occupancy = 0;
  }","void clear ()
  {
    if (unlikely (!VAR_0)) return;

    if (VAR_1)
      for (auto &VAR_2 : hb_iter (VAR_1, VAR_3 + 1))
	VAR_2.clear ();

    VAR_4 = VAR_5 = 0;
  }",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-map.hh/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,7 @@
 void clear ()
   {
+    if (unlikely (!successful)) return;
+
     if (items)
       for (auto &_ : hb_iter (items, mask + 1))
 	_.clear ();","{'deleted_lines': [], 'added_lines': ['    if (unlikely (!successful)) return;', '']}",True,HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy).,6.5,MEDIUM,1,valid,2021-08-24T16:31:49Z,3
CVE-2021-45931,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,harfbuzz,"[set] Make all operators null-safe again

Changed my mind.

Also for hb_map_clear().

Part of https://github.com/harfbuzz/harfbuzz/pull/3162",d3e09bf4654fe5478b6dbf2b26ebab6271317d81,https://github.com/harfbuzz/harfbuzz/commit/d3e09bf4654fe5478b6dbf2b26ebab6271317d81,src/hb-set.cc,hb_set_set,"void
hb_set_set (hb_set_t       *set,
const hb_set_t *other)
{
if (unlikely (hb_object_is_immutable (set)))
return;
set->set (*other);
}","void
hb_set_set (hb_set_t       *VAR_0,
const hb_set_t *VAR_1)
{
if (unlikely (hb_object_is_immutable (VAR_0)))
return;
VAR_0->set (*VAR_1);
}",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-set.cc/vul/before/1.json,"void
hb_set_set (hb_set_t       *set,
	    const hb_set_t *other)
{
  /* Immutible-safe. */
  set->set (*other);
}","void
hb_set_set (hb_set_t       *VAR_0,
	    const hb_set_t *VAR_1)
{
  /* COMMENT_0 */
  VAR_0->set (*VAR_1);
}",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-set.cc/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,8 +2,6 @@
 hb_set_set (hb_set_t       *set,
 	    const hb_set_t *other)
 {
-  if (unlikely (hb_object_is_immutable (set)))
-    return;
-
+  /* Immutible-safe. */
   set->set (*other);
 }","{'deleted_lines': ['  if (unlikely (hb_object_is_immutable (set)))', '    return;', ''], 'added_lines': ['  /* Immutible-safe. */']}",True,HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy).,6.5,MEDIUM,1,valid,2021-08-24T16:31:49Z,3
CVE-2021-45931,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,harfbuzz,"[set] Make all operators null-safe again

Changed my mind.

Also for hb_map_clear().

Part of https://github.com/harfbuzz/harfbuzz/pull/3162",d3e09bf4654fe5478b6dbf2b26ebab6271317d81,https://github.com/harfbuzz/harfbuzz/commit/d3e09bf4654fe5478b6dbf2b26ebab6271317d81,src/hb-bit-set-invertible.hh,intersect,"void intersect (const hb_bit_set_invertible_t &other)
{
if (likely (inverted == other.inverted))
{
if (unlikely (inverted))
process (hb_bitwise_or, other);
else
process (hb_bitwise_and, other); 
}
else
{
if (unlikely (inverted))
process (hb_bitwise_lt, other);
else
process (hb_bitwise_gt, other);
}
inverted = inverted && other.inverted;
}","void intersect (const hb_bit_set_invertible_t &VAR_0)
{
if (likely (VAR_1 == VAR_0.inverted))
{
if (unlikely (VAR_1))
process (VAR_2, VAR_0);
else
process (VAR_3, VAR_0); 
}
else
{
if (unlikely (VAR_1))
process (VAR_4, VAR_0);
else
process (VAR_5, VAR_0);
}
VAR_1 = VAR_1 && VAR_0.inverted;
}",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-bit-set-invertible.hh/vul/before/7.json,"void intersect (const hb_bit_set_invertible_t &other)
  {
    if (likely (inverted == other.inverted))
    {
      if (unlikely (inverted))
	process (hb_bitwise_or, other);
      else
	process (hb_bitwise_and, other); /* Main branch. */
    }
    else
    {
      if (unlikely (inverted))
	process (hb_bitwise_lt, other);
      else
	process (hb_bitwise_gt, other);
    }
    if (likely (s.successful))
      inverted = inverted && other.inverted;
  }","void intersect (const hb_bit_set_invertible_t &VAR_0)
  {
    if (likely (VAR_1 == VAR_0.inverted))
    {
      if (unlikely (VAR_1))
	process (VAR_2, VAR_0);
      else
	process (VAR_3, VAR_0); /* COMMENT_0 */
    }
    else
    {
      if (unlikely (VAR_1))
	process (VAR_4, VAR_0);
      else
	process (VAR_5, VAR_0);
    }
    if (likely (VAR_6.successful))
      VAR_1 = VAR_1 && VAR_0.inverted;
  }",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-bit-set-invertible.hh/vul/after/7.json,"--- func_before
+++ func_after
@@ -14,5 +14,6 @@
       else
 	process (hb_bitwise_gt, other);
     }
-    inverted = inverted && other.inverted;
+    if (likely (s.successful))
+      inverted = inverted && other.inverted;
   }","{'deleted_lines': ['    inverted = inverted && other.inverted;'], 'added_lines': ['    if (likely (s.successful))', '      inverted = inverted && other.inverted;']}",True,HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy).,6.5,MEDIUM,1,valid,2021-08-24T16:31:49Z,3
CVE-2021-45931,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,harfbuzz,"[set] Make all operators null-safe again

Changed my mind.

Also for hb_map_clear().

Part of https://github.com/harfbuzz/harfbuzz/pull/3162",d3e09bf4654fe5478b6dbf2b26ebab6271317d81,https://github.com/harfbuzz/harfbuzz/commit/d3e09bf4654fe5478b6dbf2b26ebab6271317d81,src/hb-bit-set-invertible.hh,subtract,"void subtract (const hb_bit_set_invertible_t &other)
{
if (likely (inverted == other.inverted))
{
if (unlikely (inverted))
process (hb_bitwise_lt, other);
else
process (hb_bitwise_gt, other); 
}
else
{
if (unlikely (inverted))
process (hb_bitwise_or, other);
else
process (hb_bitwise_and, other);
}
inverted = inverted && !other.inverted;
}","void subtract (const hb_bit_set_invertible_t &VAR_0)
{
if (likely (VAR_1 == VAR_0.inverted))
{
if (unlikely (VAR_1))
process (VAR_2, VAR_0);
else
process (VAR_3, VAR_0); 
}
else
{
if (unlikely (VAR_1))
process (VAR_4, VAR_0);
else
process (VAR_5, VAR_0);
}
VAR_1 = VAR_1 && !VAR_0.inverted;
}",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-bit-set-invertible.hh/vul/before/0.json,"void subtract (const hb_bit_set_invertible_t &other)
  {
    if (likely (inverted == other.inverted))
    {
      if (unlikely (inverted))
	process (hb_bitwise_lt, other);
      else
	process (hb_bitwise_gt, other); /* Main branch. */
    }
    else
    {
      if (unlikely (inverted))
	process (hb_bitwise_or, other);
      else
	process (hb_bitwise_and, other);
    }
    if (likely (s.successful))
      inverted = inverted && !other.inverted;
  }","void subtract (const hb_bit_set_invertible_t &VAR_0)
  {
    if (likely (VAR_1 == VAR_0.inverted))
    {
      if (unlikely (VAR_1))
	process (VAR_2, VAR_0);
      else
	process (VAR_3, VAR_0); /* COMMENT_0 */
    }
    else
    {
      if (unlikely (VAR_1))
	process (VAR_4, VAR_0);
      else
	process (VAR_5, VAR_0);
    }
    if (likely (VAR_6.successful))
      VAR_1 = VAR_1 && !VAR_0.inverted;
  }",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-bit-set-invertible.hh/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,5 +14,6 @@
       else
 	process (hb_bitwise_and, other);
     }
-    inverted = inverted && !other.inverted;
+    if (likely (s.successful))
+      inverted = inverted && !other.inverted;
   }","{'deleted_lines': ['    inverted = inverted && !other.inverted;'], 'added_lines': ['    if (likely (s.successful))', '      inverted = inverted && !other.inverted;']}",True,HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy).,6.5,MEDIUM,1,valid,2021-08-24T16:31:49Z,3
CVE-2021-45931,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,harfbuzz,"[set] Make all operators null-safe again

Changed my mind.

Also for hb_map_clear().

Part of https://github.com/harfbuzz/harfbuzz/pull/3162",d3e09bf4654fe5478b6dbf2b26ebab6271317d81,https://github.com/harfbuzz/harfbuzz/commit/d3e09bf4654fe5478b6dbf2b26ebab6271317d81,src/hb-bit-set-invertible.hh,reset,void reset () { s.reset (); inverted = false; },void reset () { VAR_0.reset (); VAR_1 = false; },harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-bit-set-invertible.hh/vul/before/1.json,"void reset ()
  {
    s.reset ();
    inverted = false;
  }","void reset ()
  {
    VAR_0.reset ();
    VAR_1 = false;
  }",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-bit-set-invertible.hh/vul/after/1.json,"--- func_before
+++ func_after
@@ -1 +1,5 @@
-void reset () { s.reset (); inverted = false; }
+void reset ()
+  {
+    s.reset ();
+    inverted = false;
+  }","{'deleted_lines': ['void reset () { s.reset (); inverted = false; }'], 'added_lines': ['void reset ()', '  {', '    s.reset ();', '    inverted = false;', '  }']}",True,HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy).,6.5,MEDIUM,1,valid,2021-08-24T16:31:49Z,3
CVE-2021-45931,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,harfbuzz,"[set] Make all operators null-safe again

Changed my mind.

Also for hb_map_clear().

Part of https://github.com/harfbuzz/harfbuzz/pull/3162",d3e09bf4654fe5478b6dbf2b26ebab6271317d81,https://github.com/harfbuzz/harfbuzz/commit/d3e09bf4654fe5478b6dbf2b26ebab6271317d81,src/hb-bit-set-invertible.hh,clear,void clear () { s.clear (); inverted = false; },void clear () { VAR_0.clear (); VAR_1 = false; },harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-bit-set-invertible.hh/vul/before/6.json,"void clear ()
  {
    s.clear ();
    if (likely (s.successful))
      inverted = false;
  }","void clear ()
  {
    VAR_0.clear ();
    if (likely (VAR_0.successful))
      VAR_1 = false;
  }",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-bit-set-invertible.hh/vul/after/6.json,"--- func_before
+++ func_after
@@ -1 +1,6 @@
-void clear () { s.clear (); inverted = false; }
+void clear ()
+  {
+    s.clear ();
+    if (likely (s.successful))
+      inverted = false;
+  }","{'deleted_lines': ['void clear () { s.clear (); inverted = false; }'], 'added_lines': ['void clear ()', '  {', '    s.clear ();', '    if (likely (s.successful))', '      inverted = false;', '  }']}",True,HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy).,6.5,MEDIUM,1,valid,2021-08-24T16:31:49Z,3
CVE-2021-45931,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,harfbuzz,"[set] Make all operators null-safe again

Changed my mind.

Also for hb_map_clear().

Part of https://github.com/harfbuzz/harfbuzz/pull/3162",d3e09bf4654fe5478b6dbf2b26ebab6271317d81,https://github.com/harfbuzz/harfbuzz/commit/d3e09bf4654fe5478b6dbf2b26ebab6271317d81,src/hb-bit-set-invertible.hh,symmetric_difference,"void symmetric_difference (const hb_bit_set_invertible_t &other)
{
process (hb_bitwise_xor, other);
inverted = inverted ^ other.inverted;
}","void symmetric_difference (const hb_bit_set_invertible_t &VAR_0)
{
process (VAR_1, VAR_0);
VAR_2 = VAR_2 ^ VAR_0.inverted;
}",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-bit-set-invertible.hh/vul/before/2.json,"void symmetric_difference (const hb_bit_set_invertible_t &other)
  {
    process (hb_bitwise_xor, other);
    if (likely (s.successful))
      inverted = inverted ^ other.inverted;
  }","void symmetric_difference (const hb_bit_set_invertible_t &VAR_0)
  {
    process (VAR_1, VAR_0);
    if (likely (VAR_2.successful))
      VAR_3 = VAR_3 ^ VAR_0.inverted;
  }",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-bit-set-invertible.hh/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,5 +1,6 @@
 void symmetric_difference (const hb_bit_set_invertible_t &other)
   {
     process (hb_bitwise_xor, other);
-    inverted = inverted ^ other.inverted;
+    if (likely (s.successful))
+      inverted = inverted ^ other.inverted;
   }","{'deleted_lines': ['    inverted = inverted ^ other.inverted;'], 'added_lines': ['    if (likely (s.successful))', '      inverted = inverted ^ other.inverted;']}",True,HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy).,6.5,MEDIUM,1,valid,2021-08-24T16:31:49Z,3
CVE-2021-45931,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,harfbuzz,"[set] Make all operators null-safe again

Changed my mind.

Also for hb_map_clear().

Part of https://github.com/harfbuzz/harfbuzz/pull/3162",d3e09bf4654fe5478b6dbf2b26ebab6271317d81,https://github.com/harfbuzz/harfbuzz/commit/d3e09bf4654fe5478b6dbf2b26ebab6271317d81,src/hb-bit-set-invertible.hh,union_,"void union_ (const hb_bit_set_invertible_t &other)
{
if (likely (inverted == other.inverted))
{
if (unlikely (inverted))
process (hb_bitwise_and, other);
else
process (hb_bitwise_or, other); 
}
else
{
if (unlikely (inverted))
process (hb_bitwise_gt, other);
else
process (hb_bitwise_lt, other);
}
inverted = inverted || other.inverted;
}","void union_ (const hb_bit_set_invertible_t &VAR_0)
{
if (likely (VAR_1 == VAR_0.inverted))
{
if (unlikely (VAR_1))
process (VAR_2, VAR_0);
else
process (VAR_3, VAR_0); 
}
else
{
if (unlikely (VAR_1))
process (VAR_4, VAR_0);
else
process (VAR_5, VAR_0);
}
VAR_1 = VAR_1 || VAR_0.inverted;
}",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-bit-set-invertible.hh/vul/before/3.json,"void union_ (const hb_bit_set_invertible_t &other)
  {
    if (likely (inverted == other.inverted))
    {
      if (unlikely (inverted))
	process (hb_bitwise_and, other);
      else
	process (hb_bitwise_or, other); /* Main branch. */
    }
    else
    {
      if (unlikely (inverted))
	process (hb_bitwise_gt, other);
      else
	process (hb_bitwise_lt, other);
    }
    if (likely (s.successful))
      inverted = inverted || other.inverted;
  }","void union_ (const hb_bit_set_invertible_t &VAR_0)
  {
    if (likely (VAR_1 == VAR_0.inverted))
    {
      if (unlikely (VAR_1))
	process (VAR_2, VAR_0);
      else
	process (VAR_3, VAR_0); /* COMMENT_0 */
    }
    else
    {
      if (unlikely (VAR_1))
	process (VAR_4, VAR_0);
      else
	process (VAR_5, VAR_0);
    }
    if (likely (VAR_6.successful))
      VAR_1 = VAR_1 || VAR_0.inverted;
  }",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-bit-set-invertible.hh/vul/after/3.json,"--- func_before
+++ func_after
@@ -14,5 +14,6 @@
       else
 	process (hb_bitwise_lt, other);
     }
-    inverted = inverted || other.inverted;
+    if (likely (s.successful))
+      inverted = inverted || other.inverted;
   }","{'deleted_lines': ['    inverted = inverted || other.inverted;'], 'added_lines': ['    if (likely (s.successful))', '      inverted = inverted || other.inverted;']}",True,HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy).,6.5,MEDIUM,1,valid,2021-08-24T16:31:49Z,3
CVE-2021-45931,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,harfbuzz,"[set] Make all operators null-safe again

Changed my mind.

Also for hb_map_clear().

Part of https://github.com/harfbuzz/harfbuzz/pull/3162",d3e09bf4654fe5478b6dbf2b26ebab6271317d81,https://github.com/harfbuzz/harfbuzz/commit/d3e09bf4654fe5478b6dbf2b26ebab6271317d81,src/hb-bit-set-invertible.hh,set,void set (const hb_bit_set_invertible_t &other) { s.set (other.s); inverted = other.inverted; },void set (const hb_bit_set_invertible_t &VAR_0) { VAR_1.set (VAR_0.s); VAR_2 = VAR_0.inverted; },harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-bit-set-invertible.hh/vul/before/5.json,"void set (const hb_bit_set_invertible_t &other)
  {
    s.set (other.s);
    if (likely (s.successful))
      inverted = other.inverted;
  }","void set (const hb_bit_set_invertible_t &VAR_0)
  {
    VAR_1.set (VAR_0.s);
    if (likely (VAR_1.successful))
      VAR_2 = VAR_0.inverted;
  }",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-bit-set-invertible.hh/vul/after/5.json,"--- func_before
+++ func_after
@@ -1 +1,6 @@
-void set (const hb_bit_set_invertible_t &other) { s.set (other.s); inverted = other.inverted; }
+void set (const hb_bit_set_invertible_t &other)
+  {
+    s.set (other.s);
+    if (likely (s.successful))
+      inverted = other.inverted;
+  }","{'deleted_lines': ['void set (const hb_bit_set_invertible_t &other) { s.set (other.s); inverted = other.inverted; }'], 'added_lines': ['void set (const hb_bit_set_invertible_t &other)', '  {', '    s.set (other.s);', '    if (likely (s.successful))', '      inverted = other.inverted;', '  }']}",True,HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy).,6.5,MEDIUM,1,valid,2021-08-24T16:31:49Z,3
CVE-2021-45931,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,harfbuzz,"[set] Make all operators null-safe again

Changed my mind.

Also for hb_map_clear().

Part of https://github.com/harfbuzz/harfbuzz/pull/3162",d3e09bf4654fe5478b6dbf2b26ebab6271317d81,https://github.com/harfbuzz/harfbuzz/commit/d3e09bf4654fe5478b6dbf2b26ebab6271317d81,src/hb-bit-set-invertible.hh,invert,void invert () { inverted = !inverted; },void invert () { VAR_0 = !VAR_0; },harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-bit-set-invertible.hh/vul/before/4.json,"void invert ()
  {
    if (likely (s.successful))
      inverted = !inverted;
  }","void invert ()
  {
    if (likely (VAR_0.successful))
      VAR_1 = !VAR_1;
  }",harfbuzz/d3e09bf4654fe5478b6dbf2b26ebab6271317d81/hb-bit-set-invertible.hh/vul/after/4.json,"--- func_before
+++ func_after
@@ -1 +1,5 @@
-void invert () { inverted = !inverted; }
+void invert ()
+  {
+    if (likely (s.successful))
+      inverted = !inverted;
+  }","{'deleted_lines': ['void invert () { inverted = !inverted; }'], 'added_lines': ['void invert ()', '  {', '    if (likely (s.successful))', '      inverted = !inverted;', '  }']}",True,HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy).,6.5,MEDIUM,1,valid,2021-08-24T16:31:49Z,3
CVE-2021-40607,['CWE-770'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #1879,f19668964bf422cf5a63e4dbe1d3c6c75edadcbb,https://github.com/gpac/gpac/commit/f19668964bf422cf5a63e4dbe1d3c6c75edadcbb,src/isomedia/box_code_drm.c,schm_box_read,"GF_Err schm_box_read(GF_Box *s, GF_BitStream *bs)
{
GF_SchemeTypeBox *ptr = (GF_SchemeTypeBox *)s;
ISOM_DECREASE_SIZE(ptr, 8);
ptr->scheme_type = gf_bs_read_u32(bs);
ptr->scheme_version = gf_bs_read_u32(bs);
if (ptr->size && (ptr->flags & 0x000001)) {
u32 len = (u32) (ptr->size);
ptr->URI = (char*)gf_malloc(sizeof(char)*len);
if (!ptr->URI) return GF_OUT_OF_MEM;
gf_bs_read_data(bs, ptr->URI, len);
}
return GF_OK;
}","GF_Err schm_box_read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
GF_SchemeTypeBox *VAR_2 = (GF_SchemeTypeBox *)VAR_0;
ISOM_DECREASE_SIZE(VAR_2, 8);
VAR_2->scheme_type = gf_bs_read_u32(VAR_1);
VAR_2->scheme_version = gf_bs_read_u32(VAR_1);
if (VAR_2->size && (VAR_2->flags & 0x000001)) {
u32 VAR_3 = (u32) (VAR_2->size);
VAR_2->URI = (char*)gf_malloc(sizeof(char)*VAR_3);
if (!VAR_2->URI) return VAR_4;
gf_bs_read_data(VAR_1, VAR_2->URI, VAR_3);
}
return VAR_5;
}",gpac/f19668964bf422cf5a63e4dbe1d3c6c75edadcbb/box_code_drm.c/vul/before/0.json,"GF_Err schm_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_SchemeTypeBox *ptr = (GF_SchemeTypeBox *)s;

	ISOM_DECREASE_SIZE(ptr, 8);
	ptr->scheme_type = gf_bs_read_u32(bs);
	ptr->scheme_version = gf_bs_read_u32(bs);

	if (ptr->size && (ptr->flags & 0x000001)) {
		u32 len = (u32) (ptr->size);
		ptr->URI = (char*)gf_malloc(sizeof(char)*(len+1));
		if (!ptr->URI) return GF_OUT_OF_MEM;
		gf_bs_read_data(bs, ptr->URI, len);
		ptr->URI[len] = 0;
	}
	return GF_OK;
}","GF_Err schm_box_read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
	GF_SchemeTypeBox *VAR_2 = (GF_SchemeTypeBox *)VAR_0;

	ISOM_DECREASE_SIZE(VAR_2, 8);
	VAR_2->scheme_type = gf_bs_read_u32(VAR_1);
	VAR_2->scheme_version = gf_bs_read_u32(VAR_1);

	if (VAR_2->size && (VAR_2->flags & 0x000001)) {
		u32 VAR_3 = (u32) (VAR_2->size);
		VAR_2->URI = (char*)gf_malloc(sizeof(char)*(VAR_3+1));
		if (!VAR_2->URI) return VAR_4;
		gf_bs_read_data(VAR_1, VAR_2->URI, VAR_3);
		VAR_2->URI[VAR_3] = 0;
	}
	return VAR_5;
}",gpac/f19668964bf422cf5a63e4dbe1d3c6c75edadcbb/box_code_drm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,9 +8,10 @@
 
 	if (ptr->size && (ptr->flags & 0x000001)) {
 		u32 len = (u32) (ptr->size);
-		ptr->URI = (char*)gf_malloc(sizeof(char)*len);
+		ptr->URI = (char*)gf_malloc(sizeof(char)*(len+1));
 		if (!ptr->URI) return GF_OUT_OF_MEM;
 		gf_bs_read_data(bs, ptr->URI, len);
+		ptr->URI[len] = 0;
 	}
 	return GF_OK;
 }","{'deleted_lines': ['\t\tptr->URI = (char*)gf_malloc(sizeof(char)*len);'], 'added_lines': ['\t\tptr->URI = (char*)gf_malloc(sizeof(char)*(len+1));', '\t\tptr->URI[len] = 0;']}",True,The schm_box_size function in GPAC 1.0.1 allows attackers to cause a denial of service via a crafted file in the MP4Box command.,5.5,MEDIUM,1,valid,2021-08-30T12:34:37Z,3
CVE-2021-40566,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #1887,96047e0e6166407c40cc19f4e94fb35cd7624391,https://github.com/gpac/gpac/commit/96047e0e6166407c40cc19f4e94fb35cd7624391,src/filters/dec_xvid.c,xviddec_configure_pid,"static GF_Err xviddec_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)
{
const GF_PropertyValue *p;
GF_M4VDecSpecInfo dsi;
GF_Err e;
Bool is_first = GF_FALSE;
#ifdef XVID_USE_OLD_API
XVID_DEC_FRAME frame;
XVID_DEC_PARAM par;
#else
xvid_dec_frame_t frame;
xvid_dec_create_t par;
#endif
GF_XVIDCtx *ctx = gf_filter_get_udta(filter);
if (is_remove) {
if (ctx->opid) {
gf_filter_pid_remove(ctx->opid);
ctx->opid = NULL;
}
ctx->ipid = NULL;
return GF_OK;
}
if (! gf_filter_pid_check_caps(pid))
return GF_NOT_SUPPORTED;
ctx->ipid = pid;
if (!ctx->opid) {
ctx->opid = gf_filter_pid_new(filter);
gf_filter_pid_set_framing_mode(ctx->ipid, GF_TRUE);
is_first = GF_TRUE;
}
gf_filter_pid_copy_properties(ctx->opid, ctx->ipid);
gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_RAW) );
p = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG);
if (p && p->value.data.ptr && p->value.data.size) {
u32 ex_crc = gf_crc_32(p->value.data.ptr, p->value.data.size);
if (ctx->cfg_crc == ex_crc) return GF_OK;
if (ctx->codec) xvid_decore(ctx->codec, XVID_DEC_DESTROY, NULL, NULL);
ctx->codec = NULL;
ctx->cfg_crc = ex_crc;
} else if (!is_first) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (""[XVID] Reconfiguring without DSI not yet supported\n""));
return GF_NOT_SUPPORTED;
} else {
return GF_OK;
}
e = gf_m4v_get_config(p->value.data.ptr, p->value.data.size, &dsi);
if (e) return e;
if (!dsi.width || !dsi.height) return GF_NON_COMPLIANT_BITSTREAM;
memset(&par, 0, sizeof(par));
par.width = dsi.width;
par.height = dsi.height;
ctx->FPS = dsi.clock_rate;
ctx->FPS /= 1000;
if (!ctx->FPS) ctx->FPS = 30.0f;
ctx->pixel_ar.num = dsi.par_num;
ctx->pixel_ar.den = dsi.par_den;
#ifndef XVID_USE_OLD_API
par.version = XVID_VERSION;
#endif
if (xvid_decore(NULL, XVID_DEC_CREATE, &par, NULL) < 0) return GF_NON_COMPLIANT_BITSTREAM;
ctx->width = par.width;
ctx->height = par.height;
ctx->codec = par.handle;
memset(&frame, 0, sizeof(frame));
frame.bitstream = (void *) p->value.data.ptr;
frame.length = p->value.data.size;
#ifndef XVID_USE_OLD_API
frame.version = XVID_VERSION;
xvid_decore(ctx->codec, XVID_DEC_DECODE, &frame, NULL);
#else
xvid_decore(ctx->codec, XVID_DEC_DECODE, &frame, NULL);
#endif
ctx->first_frame = GF_TRUE;
ctx->out_size = ctx->width * ctx->height * 3 / 2;
gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(ctx->width) );
gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(ctx->height) );
gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STRIDE, &PROP_UINT(ctx->width) );
gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PAR, &PROP_FRAC(ctx->pixel_ar) );
gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PIXFMT, &PROP_UINT(GF_PIXEL_YUV) );
return GF_OK;
}","static GF_Err xviddec_configure_pid(GF_Filter *VAR_0, GF_FilterPid *VAR_1, Bool VAR_2)
{
const GF_PropertyValue *VAR_3;
GF_M4VDecSpecInfo VAR_4;
GF_Err VAR_5;
Bool VAR_6 = VAR_7;
#ifdef VAR_8
XVID_DEC_FRAME VAR_9;
XVID_DEC_PARAM VAR_10;
#else
xvid_dec_frame_t VAR_9;
xvid_dec_create_t VAR_10;
#endif
GF_XVIDCtx *VAR_11 = gf_filter_get_udta(VAR_0);
if (VAR_2) {
if (VAR_11->opid) {
gf_filter_pid_remove(VAR_11->opid);
VAR_11->opid = NULL;
}
VAR_11->ipid = NULL;
return VAR_12;
}
if (! gf_filter_pid_check_caps(VAR_1))
return VAR_13;
VAR_11->ipid = VAR_1;
if (!VAR_11->opid) {
VAR_11->opid = gf_filter_pid_new(VAR_0);
gf_filter_pid_set_framing_mode(VAR_11->ipid, VAR_14);
VAR_6 = VAR_14;
}
gf_filter_pid_copy_properties(VAR_11->opid, VAR_11->ipid);
gf_filter_pid_set_property(VAR_11->opid, VAR_15, &PROP_UINT(VAR_16) );
VAR_3 = gf_filter_pid_get_property(VAR_1, VAR_17);
if (VAR_3 && VAR_3->value.data.ptr && VAR_3->value.data.size) {
u32 VAR_18 = gf_crc_32(VAR_3->value.data.ptr, VAR_3->value.data.size);
if (VAR_11->cfg_crc == VAR_18) return VAR_12;
if (VAR_11->codec) xvid_decore(VAR_11->codec, VAR_19, NULL, NULL);
VAR_11->codec = NULL;
VAR_11->cfg_crc = VAR_18;
} else if (!VAR_6) {
GF_LOG(VAR_20, VAR_21, (""[XVID] Reconfiguring without DSI not yet supported\n""));
return VAR_13;
} else {
return VAR_12;
}
VAR_5 = gf_m4v_get_config(VAR_3->value.data.ptr, VAR_3->value.data.size, &VAR_4);
if (VAR_5) return VAR_5;
if (!VAR_4.width || !VAR_4.height) return VAR_22;
memset(&VAR_10, 0, sizeof(VAR_10));
VAR_10.width = VAR_4.width;
VAR_10.height = VAR_4.height;
VAR_11->FPS = VAR_4.clock_rate;
VAR_11->FPS /= 1000;
if (!VAR_11->FPS) VAR_11->FPS = 30.0f;
VAR_11->pixel_ar.num = VAR_4.par_num;
VAR_11->pixel_ar.den = VAR_4.par_den;
#ifndef VAR_8
VAR_10.version = VAR_23;
#endif
if (xvid_decore(NULL, VAR_24, &VAR_10, NULL) < 0) return VAR_22;
VAR_11->width = VAR_10.width;
VAR_11->height = VAR_10.height;
VAR_11->codec = VAR_10.handle;
memset(&VAR_9, 0, sizeof(VAR_9));
VAR_9.bitstream = (void *) VAR_3->value.data.ptr;
VAR_9.length = VAR_3->value.data.size;
#ifndef VAR_8
VAR_9.version = VAR_23;
xvid_decore(VAR_11->codec, VAR_25, &VAR_9, NULL);
#else
xvid_decore(VAR_11->codec, VAR_25, &VAR_9, NULL);
#endif
VAR_11->first_frame = VAR_14;
VAR_11->out_size = VAR_11->width * VAR_11->height * 3 / 2;
gf_filter_pid_set_property(VAR_11->opid, VAR_26, &PROP_UINT(VAR_11->width) );
gf_filter_pid_set_property(VAR_11->opid, VAR_27, &PROP_UINT(VAR_11->height) );
gf_filter_pid_set_property(VAR_11->opid, VAR_28, &PROP_UINT(VAR_11->width) );
gf_filter_pid_set_property(VAR_11->opid, VAR_29, &PROP_FRAC(VAR_11->pixel_ar) );
gf_filter_pid_set_property(VAR_11->opid, VAR_30, &PROP_UINT(VAR_31) );
return VAR_12;
}",gpac/96047e0e6166407c40cc19f4e94fb35cd7624391/dec_xvid.c/vul/before/0.json,"static GF_Err xviddec_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)
{
	const GF_PropertyValue *p;
	GF_M4VDecSpecInfo dsi;
	GF_Err e;
	Bool is_first = GF_FALSE;
#ifdef XVID_USE_OLD_API
	XVID_DEC_FRAME frame;
	XVID_DEC_PARAM par;
#else
	xvid_dec_frame_t frame;
	xvid_dec_create_t par;
#endif
	GF_XVIDCtx *ctx = gf_filter_get_udta(filter);

	if (is_remove) {
		if (ctx->opid) {
			gf_filter_pid_remove(ctx->opid);
			ctx->opid = NULL;
		}
		ctx->ipid = NULL;
		return GF_OK;
	}
	if (! gf_filter_pid_check_caps(pid))
		return GF_NOT_SUPPORTED;

	ctx->ipid = pid;
	if (!ctx->opid) {
		ctx->opid = gf_filter_pid_new(filter);
		gf_filter_pid_set_framing_mode(ctx->ipid, GF_TRUE);
		is_first = GF_TRUE;
	}
	//copy properties at init or reconfig
	gf_filter_pid_copy_properties(ctx->opid, ctx->ipid);
	gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_RAW) );

	p = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG);
	if (p && p->value.data.ptr && p->value.data.size) {
		u32 ex_crc = gf_crc_32(p->value.data.ptr, p->value.data.size);
		if (ctx->cfg_crc == ex_crc) return GF_OK;

		//shoud we flush ?
		if (ctx->codec) xvid_decore(ctx->codec, XVID_DEC_DESTROY, NULL, NULL);
		ctx->codec = NULL;

		ctx->cfg_crc = ex_crc;
	} else if (!is_first) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CODEC, (""[XVID] Reconfiguring without DSI not yet supported\n""));
		return GF_NOT_SUPPORTED;
	} else {
		return GF_OK;
	}

	/*decode DSI*/
	e = gf_m4v_get_config(p->value.data.ptr, p->value.data.size, &dsi);
	if (e) return e;
	if (!dsi.width || (dsi.width%2) || !dsi.height) return GF_NON_COMPLIANT_BITSTREAM;

	memset(&par, 0, sizeof(par));
	par.width = dsi.width;
	par.height = dsi.height;
	/*note that this may be irrelevant when used through systems (FPS is driven by systems CTS)*/
	ctx->FPS = dsi.clock_rate;
	ctx->FPS /= 1000;
	if (!ctx->FPS) ctx->FPS = 30.0f;
	ctx->pixel_ar.num = dsi.par_num;
	ctx->pixel_ar.den = dsi.par_den;

#ifndef XVID_USE_OLD_API
	par.version = XVID_VERSION;
#endif

	if (xvid_decore(NULL, XVID_DEC_CREATE, &par, NULL) < 0) return GF_NON_COMPLIANT_BITSTREAM;

	ctx->width = par.width;
	ctx->height = par.height;
	ctx->codec = par.handle;

	/*init decoder*/
	memset(&frame, 0, sizeof(frame));
	frame.bitstream = (void *) p->value.data.ptr;
	frame.length = p->value.data.size;
#ifndef XVID_USE_OLD_API
	frame.version = XVID_VERSION;
	xvid_decore(ctx->codec, XVID_DEC_DECODE, &frame, NULL);
#else
	/*don't perform error check, XviD doesn't like DSI only frame ...*/
	xvid_decore(ctx->codec, XVID_DEC_DECODE, &frame, NULL);
#endif

	ctx->first_frame = GF_TRUE;
	ctx->out_size = ctx->width * ctx->height * 3 / 2;

	gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(ctx->width) );
	gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(ctx->height) );
	gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STRIDE, &PROP_UINT(ctx->width) );
	gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PAR, &PROP_FRAC(ctx->pixel_ar) );
	gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PIXFMT, &PROP_UINT(GF_PIXEL_YUV) );

	return GF_OK;
}","static GF_Err xviddec_configure_pid(GF_Filter *VAR_0, GF_FilterPid *VAR_1, Bool VAR_2)
{
	const GF_PropertyValue *VAR_3;
	GF_M4VDecSpecInfo VAR_4;
	GF_Err VAR_5;
	Bool VAR_6 = VAR_7;
#ifdef VAR_8
	XVID_DEC_FRAME VAR_9;
	XVID_DEC_PARAM VAR_10;
#else
	xvid_dec_frame_t VAR_9;
	xvid_dec_create_t VAR_10;
#endif
	GF_XVIDCtx *VAR_11 = gf_filter_get_udta(VAR_0);

	if (VAR_2) {
		if (VAR_11->opid) {
			gf_filter_pid_remove(VAR_11->opid);
			VAR_11->opid = NULL;
		}
		VAR_11->ipid = NULL;
		return VAR_12;
	}
	if (! gf_filter_pid_check_caps(VAR_1))
		return VAR_13;

	VAR_11->ipid = VAR_1;
	if (!VAR_11->opid) {
		VAR_11->opid = gf_filter_pid_new(VAR_0);
		gf_filter_pid_set_framing_mode(VAR_11->ipid, VAR_14);
		VAR_6 = VAR_14;
	}
	/* COMMENT_0 */
	gf_filter_pid_copy_properties(VAR_11->opid, VAR_11->ipid);
	gf_filter_pid_set_property(VAR_11->opid, VAR_15, &PROP_UINT(VAR_16) );

	VAR_3 = gf_filter_pid_get_property(VAR_1, VAR_17);
	if (VAR_3 && VAR_3->value.data.ptr && VAR_3->value.data.size) {
		u32 VAR_18 = gf_crc_32(VAR_3->value.data.ptr, VAR_3->value.data.size);
		if (VAR_11->cfg_crc == VAR_18) return VAR_12;

		/* COMMENT_1 */
		if (VAR_11->codec) xvid_decore(VAR_11->codec, VAR_19, NULL, NULL);
		VAR_11->codec = NULL;

		VAR_11->cfg_crc = VAR_18;
	} else if (!VAR_6) {
		GF_LOG(VAR_20, VAR_21, (""[XVID] Reconfiguring without DSI not yet supported\n""));
		return VAR_13;
	} else {
		return VAR_12;
	}

	/* COMMENT_2 */
	VAR_5 = gf_m4v_get_config(VAR_3->value.data.ptr, VAR_3->value.data.size, &VAR_4);
	if (VAR_5) return VAR_5;
	if (!VAR_4.width || (VAR_4.width%2) || !VAR_4.height) return VAR_22;

	memset(&VAR_10, 0, sizeof(VAR_10));
	VAR_10.width = VAR_4.width;
	VAR_10.height = VAR_4.height;
	/* COMMENT_3 */
	VAR_11->FPS = VAR_4.clock_rate;
	VAR_11->FPS /= 1000;
	if (!VAR_11->FPS) VAR_11->FPS = 30.0f;
	VAR_11->pixel_ar.num = VAR_4.par_num;
	VAR_11->pixel_ar.den = VAR_4.par_den;

#ifndef VAR_8
	VAR_10.version = VAR_23;
#endif

	if (xvid_decore(NULL, VAR_24, &VAR_10, NULL) < 0) return VAR_22;

	VAR_11->width = VAR_10.width;
	VAR_11->height = VAR_10.height;
	VAR_11->codec = VAR_10.handle;

	/* COMMENT_4 */
	memset(&VAR_9, 0, sizeof(VAR_9));
	VAR_9.bitstream = (void *) VAR_3->value.data.ptr;
	VAR_9.length = VAR_3->value.data.size;
#ifndef VAR_8
	VAR_9.version = VAR_23;
	xvid_decore(VAR_11->codec, VAR_25, &VAR_9, NULL);
#else
	/* COMMENT_5 */
	xvid_decore(VAR_11->codec, VAR_25, &VAR_9, NULL);
#endif

	VAR_11->first_frame = VAR_14;
	VAR_11->out_size = VAR_11->width * VAR_11->height * 3 / 2;

	gf_filter_pid_set_property(VAR_11->opid, VAR_26, &PROP_UINT(VAR_11->width) );
	gf_filter_pid_set_property(VAR_11->opid, VAR_27, &PROP_UINT(VAR_11->height) );
	gf_filter_pid_set_property(VAR_11->opid, VAR_28, &PROP_UINT(VAR_11->width) );
	gf_filter_pid_set_property(VAR_11->opid, VAR_29, &PROP_FRAC(VAR_11->pixel_ar) );
	gf_filter_pid_set_property(VAR_11->opid, VAR_30, &PROP_UINT(VAR_31) );

	return VAR_12;
}",gpac/96047e0e6166407c40cc19f4e94fb35cd7624391/dec_xvid.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -54,7 +54,7 @@
 	/*decode DSI*/
 	e = gf_m4v_get_config(p->value.data.ptr, p->value.data.size, &dsi);
 	if (e) return e;
-	if (!dsi.width || !dsi.height) return GF_NON_COMPLIANT_BITSTREAM;
+	if (!dsi.width || (dsi.width%2) || !dsi.height) return GF_NON_COMPLIANT_BITSTREAM;
 
 	memset(&par, 0, sizeof(par));
 	par.width = dsi.width;","{'deleted_lines': ['\tif (!dsi.width || !dsi.height) return GF_NON_COMPLIANT_BITSTREAM;'], 'added_lines': ['\tif (!dsi.width || (dsi.width%2) || !dsi.height) return GF_NON_COMPLIANT_BITSTREAM;']}",True,"A Segmentation fault casued by heap use after free vulnerability exists in Gpac through 1.0.1 via the mpgviddmx_process function in reframe_mpgvid.c when using mp4box, which causes a denial of service.",5.5,MEDIUM,1,valid,2021-08-30T13:46:16Z,3
CVE-2021-40566,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #1887,96047e0e6166407c40cc19f4e94fb35cd7624391,https://github.com/gpac/gpac/commit/96047e0e6166407c40cc19f4e94fb35cd7624391,src/filters/reframe_mpgvid.c,mpgviddmx_process,"GF_Err mpgviddmx_process(GF_Filter *filter)
{
GF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);
GF_FilterPacket *pck, *dst_pck;
u64 byte_offset;
s64 vosh_start = -1;
s64 vosh_end = -1;
GF_Err e;
char *data;
u8 *start;
u32 pck_size;
s32 remain;
if (!ctx->duration.num)
mpgviddmx_check_dur(filter, ctx);
pck = gf_filter_pid_get_packet(ctx->ipid);
if (!pck) {
if (gf_filter_pid_is_eos(ctx->ipid)) {
mpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_TRUE);
if (ctx->opid)
gf_filter_pid_set_eos(ctx->opid);
if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
ctx->src_pck = NULL;
return GF_EOS;
}
return GF_OK;
}
data = (char *) gf_filter_pck_get_data(pck, &pck_size);
byte_offset = gf_filter_pck_get_byte_offset(pck);
start = data;
remain = pck_size;
if (!ctx->resume_from && ctx->timescale) {
u64 ts = gf_filter_pck_get_cts(pck);
if (ts != GF_FILTER_NO_TS) {
if (!ctx->cts || !ctx->recompute_cts)
ctx->cts = ts;
}
ts = gf_filter_pck_get_dts(pck);
if (ts != GF_FILTER_NO_TS) {
if (!ctx->dts || !ctx->recompute_cts)
ctx->dts = ts;
if (!ctx->prev_dts) ctx->prev_dts = ts;
else if (ctx->prev_dts != ts) {
u64 diff = ts;
diff -= ctx->prev_dts;
if (!ctx->cur_fps.den) ctx->cur_fps.den = (u32) diff;
else if (ctx->cur_fps.den > diff)
ctx->cur_fps.den = (u32) diff;
}
}
gf_filter_pck_get_framing(pck, &ctx->input_is_au_start, &ctx->input_is_au_end);
if (ctx->recompute_cts) ctx->input_is_au_start = GF_FALSE;
if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
ctx->src_pck = pck;
gf_filter_pck_ref_props(&ctx->src_pck);
}
if (!ctx->resume_from && ctx->hdr_store_size) {
if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) {
ctx->hdr_store_alloc = ctx->hdr_store_size + pck_size;
ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
}
memcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);
if (byte_offset != GF_FILTER_NO_BO) {
if (byte_offset >= ctx->hdr_store_size)
byte_offset -= ctx->hdr_store_size;
else
byte_offset = GF_FILTER_NO_BO;
}
ctx->hdr_store_size += pck_size;
start = data = ctx->hdr_store;
remain = pck_size = ctx->hdr_store_size;
}
if (ctx->resume_from) {
if (gf_filter_pid_would_block(ctx->opid))
return GF_OK;
if (ctx->hdr_store_size) {
assert(ctx->resume_from <= ctx->hdr_store_size);
start = data = ctx->hdr_store + ctx->resume_from;
remain = pck_size = ctx->hdr_store_size - ctx->resume_from;
} else {
assert(remain >= (s32) ctx->resume_from);
start += ctx->resume_from;
remain -= ctx->resume_from;
}
ctx->resume_from = 0;
}
if (!ctx->bs) {
ctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);
} else {
gf_bs_reassign_buffer(ctx->bs, start, remain);
}
if (!ctx->vparser) {
ctx->vparser = gf_m4v_parser_bs_new(ctx->bs, ctx->is_mpg12);
}
while (remain) {
Bool full_frame;
u8 *pck_data;
s32 current;
u8 sc_type, forced_sc_type=0;
Bool sc_type_forced = GF_FALSE;
Bool skip_pck = GF_FALSE;
u8 ftype;
u32 tinc;
u64 size=0;
u64 fstart;
Bool is_coded;
u32 bytes_from_store = 0;
u32 hdr_offset = 0;
Bool copy_last_bytes = GF_FALSE;
if (remain<5) {
memcpy(ctx->hdr_store, start, remain);
ctx->bytes_in_header = remain;
break;
}
current = -1;
if (ctx->bytes_in_header) {
memcpy(ctx->hdr_store + ctx->bytes_in_header, start, 8 - ctx->bytes_in_header);
current = mpgviddmx_next_start_code(ctx->hdr_store, 8);
if ((current<0) || (current >= (s32) ctx->bytes_in_header) )  {
if (ctx->opid) {
dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);
if (!dst_pck) return GF_OUT_OF_MEM;
if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
memcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);
gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);
}
mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
}
if (current<0) current = -1;
else current -= ctx->bytes_in_header;
ctx->bytes_in_header = 0;
} else {
hdr_offset = 4 - ctx->bytes_in_header + current;
bytes_from_store = ctx->bytes_in_header;
ctx->bytes_in_header = 0;
if (!hdr_offset) {
forced_sc_type = ctx->hdr_store[current+3];
} else {
forced_sc_type = start[hdr_offset-1];
}
sc_type_forced = GF_TRUE;
}
}
if (current == -1) {
current = mpgviddmx_next_start_code(start, remain);
if (current<0) {
u8 b3, b2, b1;
if (! ctx->frame_started) {
GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (""[MPGVid] no start code in block and no frame started, discarding data\n"" ));
break;
}
size = remain;
b3 = start[remain-3];
b2 = start[remain-2];
b1 = start[remain-1];
if (!b1 || !b2 || !b3) {
copy_last_bytes = GF_TRUE;
assert(size >= 3);
size -= 3;
ctx->bytes_in_header = 3;
}
dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);
if (!dst_pck) return GF_OUT_OF_MEM;
if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
memcpy(pck_data, start, (size_t) size);
gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
}
mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
if (copy_last_bytes) {
memcpy(ctx->hdr_store, start+remain-3, 3);
}
break;
}
}
assert(current>=0);
if ((vosh_start>=0) && current) {
assert(remain>=current);
start += current;
remain -= current;
current = 0;
}
if (!ctx->opid && current) {
assert(remain>=current);
start += current;
remain -= current;
current = 0;
}
if (current>0) {
dst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data);
if (!dst_pck) return GF_OUT_OF_MEM;
if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_TRUE);
if (bytes_from_store) {
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);
}
assert(bytes_from_store>=(u32) current);
bytes_from_store -= current;
memcpy(pck_data, ctx->hdr_store, current);
} else {
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
}
memcpy(pck_data, start, current);
assert(remain>=current);
start += current;
remain -= current;
current = 0;
}
gf_filter_pck_set_carousel_version(dst_pck, 1);
mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
}
if (sc_type_forced) {
gf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset);
sc_type = forced_sc_type;
} else {
gf_bs_reassign_buffer(ctx->bs, start, remain);
gf_bs_read_int(ctx->bs, 24);
sc_type = gf_bs_read_int(ctx->bs, 8);
}
if (ctx->is_mpg12) {
switch (sc_type) {
case M2V_SEQ_START_CODE:
case M2V_EXT_START_CODE:
gf_bs_reassign_buffer(ctx->bs, start, remain);
e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);
if (e==GF_EOS) {
if (vosh_start<0) vosh_start = 0;
if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);
ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
}
memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
ctx->hdr_store_size += pck_size - (u32) vosh_start;
gf_filter_pid_drop_packet(ctx->ipid);
return GF_OK;
} else if (e != GF_OK) {
GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""[MPGVid] Failed to parse VOS header: %s\n"", gf_error_to_string(e) ));
} else {
mpgviddmx_check_pid(filter, ctx, 0, NULL);
}
break;
case M2V_PIC_START_CODE:
break;
default:
break;
}
} else {
u8 PL;
switch (sc_type) {
case M4V_VOS_START_CODE:
ctx->dsi.VideoPL = (u8) gf_bs_read_u8(ctx->bs);
vosh_start = start - (u8 *)data;
skip_pck = GF_TRUE;
assert(remain>=5);
start += 5;
remain -= 5;
break;
case M4V_VOL_START_CODE:
gf_bs_reassign_buffer(ctx->bs, start, remain);
PL = ctx->dsi.VideoPL;
e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);
ctx->dsi.VideoPL = PL;
if (e==GF_EOS) {
if (vosh_start<0) vosh_start = 0;
if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);
ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
}
memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
ctx->hdr_store_size += pck_size - (u32) vosh_start;
gf_filter_pid_drop_packet(ctx->ipid);
return GF_OK;
} else if (e != GF_OK) {
GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""[MPGVid] Failed to parse VOS header: %s\n"", gf_error_to_string(e) ));
} else {
u32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);
if (vosh_start<0) vosh_start = 0;
vosh_end = start - (u8 *)data + obj_size;
vosh_end -= vosh_start;
mpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);
skip_pck = GF_TRUE;
assert(remain>=(s32) obj_size);
start += obj_size;
remain -= obj_size;
}
break;
case M4V_VOP_START_CODE:
case M4V_GOV_START_CODE:
break;
case M4V_VO_START_CODE:
case M4V_VISOBJ_START_CODE:
default:
if (vosh_start>=0) {
skip_pck = GF_TRUE;
assert(remain>=4);
start += 4;
remain -= 4;
}
break;
}
}
if (skip_pck) {
continue;
}
if (!ctx->opid) {
assert(remain>=4);
start += 4;
remain -= 4;
continue;
}
if (!ctx->is_playing) {
ctx->resume_from = (u32) ((char *)start -  (char *)data);
return GF_OK;
}
ctx->hdr_store_size = 0;
if (ctx->in_seek) {
u64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num);
if (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) {
ctx->in_seek = GF_FALSE;
}
}
if (remain<5)
continue;
gf_m4v_parser_reset(ctx->vparser, sc_type_forced ? forced_sc_type + 1 : 0);
size = 0;
e = gf_m4v_parse_frame(ctx->vparser, &ctx->dsi, &ftype, &tinc, &size, &fstart, &is_coded);
if (bytes_from_store) {
size += bytes_from_store + hdr_offset;
}
if ((e == GF_EOS) && !ctx->input_is_au_end) {
u8 b3 = start[remain-3];
u8 b2 = start[remain-2];
u8 b1 = start[remain-1];
if (!b1 || !b2 || !b3) {
copy_last_bytes = GF_TRUE;
assert(size >= 3);
size -= 3;
ctx->bytes_in_header = 3;
}
full_frame = GF_FALSE;
} else {
full_frame = GF_TRUE;
}
if (!is_coded) {
if (ctx->forced_packed && ctx->b_frames) {
ctx->is_packed = GF_TRUE;
assert(remain>=size);
start += size;
remain -= (s32) size;
continue;
}
if (ctx->vfr) {
ctx->is_vfr = GF_TRUE;
mpgviddmx_update_time(ctx);
assert(remain>=size);
start += size;
remain -= (s32) size;
continue;
}
}
if (ftype==2) {
ctx->b_frames++;
ctx->nb_b++;
} else {
mpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);
ctx->last_ref_cts = ctx->cts;
if (ctx->max_b < ctx->b_frames) ctx->max_b = ctx->b_frames;
ctx->b_frames = 0;
if (ftype)
ctx->nb_p++;
else
ctx->nb_i++;
}
ctx->nb_frames++;
dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);
if (!dst_pck) return GF_OUT_OF_MEM;
if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
if (bytes_from_store) {
memcpy(pck_data, ctx->hdr_store+current, bytes_from_store);
assert(size >= bytes_from_store);
size -= bytes_from_store;
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);
}
memcpy(pck_data + bytes_from_store, start, (size_t) size);
} else {
memcpy(pck_data, start, (size_t) size);
if (byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data);
}
}
assert(pck_data[0] == 0);
assert(pck_data[1] == 0);
assert(pck_data[2] == 0x01);
gf_filter_pck_set_framing(dst_pck, GF_TRUE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE);
gf_filter_pck_set_cts(dst_pck, ctx->cts);
gf_filter_pck_set_dts(dst_pck, ctx->dts);
if (ctx->input_is_au_start) {
ctx->input_is_au_start = GF_FALSE;
} else {
gf_filter_pck_set_carousel_version(dst_pck, 1);
}
gf_filter_pck_set_sap(dst_pck, ftype ? GF_FILTER_SAP_NONE : GF_FILTER_SAP_1);
gf_filter_pck_set_duration(dst_pck, ctx->cur_fps.den);
if (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);
ctx->frame_started = GF_TRUE;
mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
mpgviddmx_update_time(ctx);
if (!full_frame) {
if (copy_last_bytes) {
memcpy(ctx->hdr_store, start+remain-3, 3);
}
break;
}
assert(remain>=size);
start += size;
remain -= (s32) size;
}
gf_filter_pid_drop_packet(ctx->ipid);
return GF_OK;
}","GF_Err mpgviddmx_process(GF_Filter *VAR_0)
{
GF_MPGVidDmxCtx *VAR_1 = gf_filter_get_udta(VAR_0);
GF_FilterPacket *VAR_2, *VAR_3;
u64 VAR_4;
s64 VAR_5 = -1;
s64 VAR_6 = -1;
GF_Err VAR_7;
char *VAR_8;
u8 *VAR_9;
u32 VAR_10;
s32 VAR_11;
if (!VAR_1->duration.num)
mpgviddmx_check_dur(VAR_0, VAR_1);
VAR_2 = gf_filter_pid_get_packet(VAR_1->ipid);
if (!VAR_2) {
if (gf_filter_pid_is_eos(VAR_1->ipid)) {
mpgviddmx_enqueue_or_dispatch(VAR_1, NULL, VAR_12, VAR_12);
if (VAR_1->opid)
gf_filter_pid_set_eos(VAR_1->opid);
if (VAR_1->src_pck) gf_filter_pck_unref(VAR_1->src_pck);
VAR_1->src_pck = NULL;
return VAR_13;
}
return VAR_14;
}
VAR_8 = (char *) gf_filter_pck_get_data(VAR_2, &VAR_10);
VAR_4 = gf_filter_pck_get_byte_offset(VAR_2);
VAR_9 = VAR_8;
VAR_11 = VAR_10;
if (!VAR_1->resume_from && VAR_1->timescale) {
u64 VAR_15 = gf_filter_pck_get_cts(VAR_2);
if (VAR_15 != VAR_16) {
if (!VAR_1->cts || !VAR_1->recompute_cts)
VAR_1->cts = VAR_15;
}
VAR_15 = gf_filter_pck_get_dts(VAR_2);
if (VAR_15 != VAR_16) {
if (!VAR_1->dts || !VAR_1->recompute_cts)
VAR_1->dts = VAR_15;
if (!VAR_1->prev_dts) VAR_1->prev_dts = VAR_15;
else if (VAR_1->prev_dts != VAR_15) {
u64 VAR_17 = VAR_15;
VAR_17 -= VAR_1->prev_dts;
if (!VAR_1->cur_fps.den) VAR_1->cur_fps.den = (u32) VAR_17;
else if (VAR_1->cur_fps.den > VAR_17)
VAR_1->cur_fps.den = (u32) VAR_17;
}
}
gf_filter_pck_get_framing(VAR_2, &VAR_1->input_is_au_start, &VAR_1->input_is_au_end);
if (VAR_1->recompute_cts) VAR_1->input_is_au_start = VAR_18;
if (VAR_1->src_pck) gf_filter_pck_unref(VAR_1->src_pck);
VAR_1->src_pck = VAR_2;
gf_filter_pck_ref_props(&VAR_1->src_pck);
}
if (!VAR_1->resume_from && VAR_1->hdr_store_size) {
if (VAR_1->hdr_store_alloc < VAR_1->hdr_store_size + VAR_10) {
VAR_1->hdr_store_alloc = VAR_1->hdr_store_size + VAR_10;
VAR_1->hdr_store = gf_realloc(VAR_1->hdr_store, sizeof(char)*VAR_1->hdr_store_alloc);
}
memcpy(VAR_1->hdr_store + VAR_1->hdr_store_size, VAR_8, sizeof(char)*VAR_10);
if (VAR_4 != VAR_19) {
if (VAR_4 >= VAR_1->hdr_store_size)
VAR_4 -= VAR_1->hdr_store_size;
else
VAR_4 = VAR_19;
}
VAR_1->hdr_store_size += VAR_10;
VAR_9 = VAR_8 = VAR_1->hdr_store;
VAR_11 = VAR_10 = VAR_1->hdr_store_size;
}
if (VAR_1->resume_from) {
if (gf_filter_pid_would_block(VAR_1->opid))
return VAR_14;
if (VAR_1->hdr_store_size) {
assert(VAR_1->resume_from <= VAR_1->hdr_store_size);
VAR_9 = VAR_8 = VAR_1->hdr_store + VAR_1->resume_from;
VAR_11 = VAR_10 = VAR_1->hdr_store_size - VAR_1->resume_from;
} else {
assert(VAR_11 >= (s32) VAR_1->resume_from);
VAR_9 += VAR_1->resume_from;
VAR_11 -= VAR_1->resume_from;
}
VAR_1->resume_from = 0;
}
if (!VAR_1->bs) {
VAR_1->bs = gf_bs_new(VAR_9, VAR_11, VAR_20);
} else {
gf_bs_reassign_buffer(VAR_1->bs, VAR_9, VAR_11);
}
if (!VAR_1->vparser) {
VAR_1->vparser = gf_m4v_parser_bs_new(VAR_1->bs, VAR_1->is_mpg12);
}
while (VAR_11) {
Bool VAR_21;
u8 *VAR_22;
s32 VAR_23;
u8 VAR_24, VAR_25=0;
Bool VAR_26 = VAR_18;
Bool VAR_27 = VAR_18;
u8 VAR_28;
u32 VAR_29;
u64 VAR_30=0;
u64 VAR_31;
Bool VAR_32;
u32 VAR_33 = 0;
u32 VAR_34 = 0;
Bool VAR_35 = VAR_18;
if (VAR_11<5) {
memcpy(VAR_1->hdr_store, VAR_9, VAR_11);
VAR_1->bytes_in_header = VAR_11;
break;
}
VAR_23 = -1;
if (VAR_1->bytes_in_header) {
memcpy(VAR_1->hdr_store + VAR_1->bytes_in_header, VAR_9, 8 - VAR_1->bytes_in_header);
VAR_23 = mpgviddmx_next_start_code(VAR_1->hdr_store, 8);
if ((VAR_23<0) || (VAR_23 >= (s32) VAR_1->bytes_in_header) )  {
if (VAR_1->opid) {
VAR_3 = gf_filter_pck_new_alloc(VAR_1->opid, VAR_1->bytes_in_header, &VAR_22);
if (!VAR_3) return VAR_36;
if (VAR_1->src_pck) gf_filter_pck_merge_properties(VAR_1->src_pck, VAR_3);
gf_filter_pck_set_cts(VAR_3, VAR_16);
gf_filter_pck_set_dts(VAR_3, VAR_16);
memcpy(VAR_22, VAR_1->hdr_store, VAR_1->bytes_in_header);
gf_filter_pck_set_framing(VAR_3, VAR_18, VAR_18);
if (VAR_4 != VAR_19) {
gf_filter_pck_set_byte_offset(VAR_3, VAR_4 - VAR_1->bytes_in_header);
}
mpgviddmx_enqueue_or_dispatch(VAR_1, VAR_3, VAR_18, VAR_18);
}
if (VAR_23<0) VAR_23 = -1;
else VAR_23 -= VAR_1->bytes_in_header;
VAR_1->bytes_in_header = 0;
} else {
VAR_34 = 4 - VAR_1->bytes_in_header + VAR_23;
VAR_33 = VAR_1->bytes_in_header;
VAR_1->bytes_in_header = 0;
if (!VAR_34) {
VAR_25 = VAR_1->hdr_store[VAR_23+3];
} else {
VAR_25 = VAR_9[VAR_34-1];
}
VAR_26 = VAR_12;
}
}
if (VAR_23 == -1) {
VAR_23 = mpgviddmx_next_start_code(VAR_9, VAR_11);
if (VAR_23<0) {
u8 VAR_37, VAR_38, VAR_39;
if (! VAR_1->frame_started) {
GF_LOG(VAR_40, VAR_41, (""[MPGVid] no start code in block and no frame started, discarding data\n"" ));
break;
}
VAR_30 = VAR_11;
VAR_37 = VAR_9[VAR_11-3];
VAR_38 = VAR_9[VAR_11-2];
VAR_39 = VAR_9[VAR_11-1];
if (!VAR_39 || !VAR_38 || !VAR_37) {
VAR_35 = VAR_12;
assert(VAR_30 >= 3);
VAR_30 -= 3;
VAR_1->bytes_in_header = 3;
}
VAR_3 = gf_filter_pck_new_alloc(VAR_1->opid, (u32) VAR_30, &VAR_22);
if (!VAR_3) return VAR_36;
if (VAR_1->src_pck) gf_filter_pck_merge_properties(VAR_1->src_pck, VAR_3);
memcpy(VAR_22, VAR_9, (size_t) VAR_30);
gf_filter_pck_set_framing(VAR_3, VAR_18, VAR_18);
gf_filter_pck_set_cts(VAR_3, VAR_16);
gf_filter_pck_set_dts(VAR_3, VAR_16);
if (VAR_4 != VAR_19) {
gf_filter_pck_set_byte_offset(VAR_3, VAR_4);
}
mpgviddmx_enqueue_or_dispatch(VAR_1, VAR_3, VAR_18, VAR_18);
if (VAR_35) {
memcpy(VAR_1->hdr_store, VAR_9+VAR_11-3, 3);
}
break;
}
}
assert(VAR_23>=0);
if ((VAR_5>=0) && VAR_23) {
assert(VAR_11>=VAR_23);
VAR_9 += VAR_23;
VAR_11 -= VAR_23;
VAR_23 = 0;
}
if (!VAR_1->opid && VAR_23) {
assert(VAR_11>=VAR_23);
VAR_9 += VAR_23;
VAR_11 -= VAR_23;
VAR_23 = 0;
}
if (VAR_23>0) {
VAR_3 = gf_filter_pck_new_alloc(VAR_1->opid, VAR_23, &VAR_22);
if (!VAR_3) return VAR_36;
if (VAR_1->src_pck) gf_filter_pck_merge_properties(VAR_1->src_pck, VAR_3);
gf_filter_pck_set_cts(VAR_3, VAR_16);
gf_filter_pck_set_dts(VAR_3, VAR_16);
gf_filter_pck_set_framing(VAR_3, VAR_18, VAR_12);
if (VAR_33) {
if (VAR_4 != VAR_19) {
gf_filter_pck_set_byte_offset(VAR_3, VAR_4 - VAR_33);
}
assert(VAR_33>=(u32) VAR_23);
VAR_33 -= VAR_23;
memcpy(VAR_22, VAR_1->hdr_store, VAR_23);
} else {
if (VAR_4 != VAR_19) {
gf_filter_pck_set_byte_offset(VAR_3, VAR_4);
}
memcpy(VAR_22, VAR_9, VAR_23);
assert(VAR_11>=VAR_23);
VAR_9 += VAR_23;
VAR_11 -= VAR_23;
VAR_23 = 0;
}
gf_filter_pck_set_carousel_version(VAR_3, 1);
mpgviddmx_enqueue_or_dispatch(VAR_1, VAR_3, VAR_18, VAR_18);
}
if (VAR_26) {
gf_bs_reassign_buffer(VAR_1->bs, VAR_9 + VAR_34, VAR_11 - VAR_34);
VAR_24 = VAR_25;
} else {
gf_bs_reassign_buffer(VAR_1->bs, VAR_9, VAR_11);
gf_bs_read_int(VAR_1->bs, 24);
VAR_24 = gf_bs_read_int(VAR_1->bs, 8);
}
if (VAR_1->is_mpg12) {
switch (VAR_24) {
case VAR_42:
case VAR_43:
gf_bs_reassign_buffer(VAR_1->bs, VAR_9, VAR_11);
VAR_7 = gf_m4v_parse_config(VAR_1->vparser, &VAR_1->dsi);
if (VAR_7==VAR_13) {
if (VAR_5<0) VAR_5 = 0;
if (VAR_1->hdr_store_alloc < VAR_1->hdr_store_size + VAR_10 - VAR_5) {
VAR_1->hdr_store_alloc = (u32) (VAR_1->hdr_store_size + VAR_10 - VAR_5);
VAR_1->hdr_store = gf_realloc(VAR_1->hdr_store, sizeof(char)*VAR_1->hdr_store_alloc);
}
memcpy(VAR_1->hdr_store + VAR_1->hdr_store_size, VAR_8 + VAR_5, (size_t) (VAR_10 - VAR_5) );
VAR_1->hdr_store_size += VAR_10 - (u32) VAR_5;
gf_filter_pid_drop_packet(VAR_1->ipid);
return VAR_14;
} else if (VAR_7 != VAR_14) {
GF_LOG(VAR_44, VAR_41, (""[MPGVid] Failed to parse VOS header: %s\n"", gf_error_to_string(VAR_7) ));
} else {
mpgviddmx_check_pid(VAR_0, VAR_1, 0, NULL);
}
break;
case VAR_45:
break;
default:
break;
}
} else {
u8 VAR_46;
switch (VAR_24) {
case VAR_47:
VAR_1->dsi.VideoPL = (u8) gf_bs_read_u8(VAR_1->bs);
VAR_5 = VAR_9 - (u8 *)VAR_8;
VAR_27 = VAR_12;
assert(VAR_11>=5);
VAR_9 += 5;
VAR_11 -= 5;
break;
case VAR_48:
gf_bs_reassign_buffer(VAR_1->bs, VAR_9, VAR_11);
VAR_46 = VAR_1->dsi.VideoPL;
VAR_7 = gf_m4v_parse_config(VAR_1->vparser, &VAR_1->dsi);
VAR_1->dsi.VideoPL = VAR_46;
if (VAR_7==VAR_13) {
if (VAR_5<0) VAR_5 = 0;
if (VAR_1->hdr_store_alloc < VAR_1->hdr_store_size + VAR_10 - VAR_5) {
VAR_1->hdr_store_alloc = (u32) (VAR_1->hdr_store_size + VAR_10 - (u32) VAR_5);
VAR_1->hdr_store = gf_realloc(VAR_1->hdr_store, sizeof(char)*VAR_1->hdr_store_alloc);
}
memcpy(VAR_1->hdr_store + VAR_1->hdr_store_size, VAR_8 + VAR_5, (size_t) (VAR_10 - VAR_5) );
VAR_1->hdr_store_size += VAR_10 - (u32) VAR_5;
gf_filter_pid_drop_packet(VAR_1->ipid);
return VAR_14;
} else if (VAR_7 != VAR_14) {
GF_LOG(VAR_44, VAR_41, (""[MPGVid] Failed to parse VOS header: %s\n"", gf_error_to_string(VAR_7) ));
} else {
u32 VAR_49 = (u32) gf_m4v_get_object_start(VAR_1->vparser);
if (VAR_5<0) VAR_5 = 0;
VAR_6 = VAR_9 - (u8 *)VAR_8 + VAR_49;
VAR_6 -= VAR_5;
mpgviddmx_check_pid(VAR_0, VAR_1,(u32)  VAR_6, VAR_8+VAR_5);
VAR_27 = VAR_12;
assert(VAR_11>=(s32) VAR_49);
VAR_9 += VAR_49;
VAR_11 -= VAR_49;
}
break;
case VAR_50:
case VAR_51:
break;
case VAR_52:
case VAR_53:
default:
if (VAR_5>=0) {
VAR_27 = VAR_12;
assert(VAR_11>=4);
VAR_9 += 4;
VAR_11 -= 4;
}
break;
}
}
if (VAR_27) {
continue;
}
if (!VAR_1->opid) {
assert(VAR_11>=4);
VAR_9 += 4;
VAR_11 -= 4;
continue;
}
if (!VAR_1->is_playing) {
VAR_1->resume_from = (u32) ((char *)VAR_9 -  (char *)VAR_8);
return VAR_14;
}
VAR_1->hdr_store_size = 0;
if (VAR_1->in_seek) {
u64 VAR_54 = (u64) (VAR_1->start_range * VAR_1->cur_fps.num);
if (VAR_1->cts + VAR_1->cur_fps.den >= VAR_54) {
VAR_1->in_seek = VAR_18;
}
}
if (VAR_11<5)
continue;
gf_m4v_parser_reset(VAR_1->vparser, VAR_26 ? VAR_25 + 1 : 0);
VAR_30 = 0;
VAR_7 = gf_m4v_parse_frame(VAR_1->vparser, &VAR_1->dsi, &VAR_28, &VAR_29, &VAR_30, &VAR_31, &VAR_32);
if (VAR_33) {
VAR_30 += VAR_33 + VAR_34;
}
if ((VAR_7 == VAR_13) && !VAR_1->input_is_au_end) {
u8 VAR_37 = VAR_9[VAR_11-3];
u8 VAR_38 = VAR_9[VAR_11-2];
u8 VAR_39 = VAR_9[VAR_11-1];
if (!VAR_39 || !VAR_38 || !VAR_37) {
VAR_35 = VAR_12;
assert(VAR_30 >= 3);
VAR_30 -= 3;
VAR_1->bytes_in_header = 3;
}
VAR_21 = VAR_18;
} else {
VAR_21 = VAR_12;
}
if (!VAR_32) {
if (VAR_1->forced_packed && VAR_1->b_frames) {
VAR_1->is_packed = VAR_12;
assert(VAR_11>=VAR_30);
VAR_9 += VAR_30;
VAR_11 -= (s32) VAR_30;
continue;
}
if (VAR_1->vfr) {
VAR_1->is_vfr = VAR_12;
mpgviddmx_update_time(VAR_1);
assert(VAR_11>=VAR_30);
VAR_9 += VAR_30;
VAR_11 -= (s32) VAR_30;
continue;
}
}
if (VAR_28==2) {
VAR_1->b_frames++;
VAR_1->nb_b++;
} else {
mpgviddmx_enqueue_or_dispatch(VAR_1, NULL, VAR_12, VAR_18);
VAR_1->last_ref_cts = VAR_1->cts;
if (VAR_1->max_b < VAR_1->b_frames) VAR_1->max_b = VAR_1->b_frames;
VAR_1->b_frames = 0;
if (VAR_28)
VAR_1->nb_p++;
else
VAR_1->nb_i++;
}
VAR_1->nb_frames++;
VAR_3 = gf_filter_pck_new_alloc(VAR_1->opid, (u32) VAR_30, &VAR_22);
if (!VAR_3) return VAR_36;
if (VAR_1->src_pck) gf_filter_pck_merge_properties(VAR_1->src_pck, VAR_3);
if (VAR_33) {
memcpy(VAR_22, VAR_1->hdr_store+VAR_23, VAR_33);
assert(VAR_30 >= VAR_33);
VAR_30 -= VAR_33;
if (VAR_4 != VAR_19) {
gf_filter_pck_set_byte_offset(VAR_3, VAR_4 - VAR_33);
}
memcpy(VAR_22 + VAR_33, VAR_9, (size_t) VAR_30);
} else {
memcpy(VAR_22, VAR_9, (size_t) VAR_30);
if (VAR_4 != VAR_19) {
gf_filter_pck_set_byte_offset(VAR_3, VAR_4 + VAR_9 - (u8 *) VAR_8);
}
}
assert(VAR_22[0] == 0);
assert(VAR_22[1] == 0);
assert(VAR_22[2] == 0x01);
gf_filter_pck_set_framing(VAR_3, VAR_12, (VAR_21 || VAR_1->input_is_au_end) ? VAR_12 : VAR_18);
gf_filter_pck_set_cts(VAR_3, VAR_1->cts);
gf_filter_pck_set_dts(VAR_3, VAR_1->dts);
if (VAR_1->input_is_au_start) {
VAR_1->input_is_au_start = VAR_18;
} else {
gf_filter_pck_set_carousel_version(VAR_3, 1);
}
gf_filter_pck_set_sap(VAR_3, VAR_28 ? VAR_55 : VAR_56);
gf_filter_pck_set_duration(VAR_3, VAR_1->cur_fps.den);
if (VAR_1->in_seek) gf_filter_pck_set_seek_flag(VAR_3, VAR_12);
VAR_1->frame_started = VAR_12;
mpgviddmx_enqueue_or_dispatch(VAR_1, VAR_3, VAR_18, VAR_18);
mpgviddmx_update_time(VAR_1);
if (!VAR_21) {
if (VAR_35) {
memcpy(VAR_1->hdr_store, VAR_9+VAR_11-3, 3);
}
break;
}
assert(VAR_11>=VAR_30);
VAR_9 += VAR_30;
VAR_11 -= (s32) VAR_30;
}
gf_filter_pid_drop_packet(VAR_1->ipid);
return VAR_14;
}",gpac/96047e0e6166407c40cc19f4e94fb35cd7624391/reframe_mpgvid.c/vul/before/0.json,"GF_Err mpgviddmx_process(GF_Filter *filter)
{
	GF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);
	GF_FilterPacket *pck, *dst_pck;
	u64 byte_offset;
	s64 vosh_start = -1;
	s64 vosh_end = -1;
	GF_Err e;
	char *data;
	u8 *start;
	u32 pck_size;
	s32 remain;

	//always reparse duration
	if (!ctx->duration.num)
		mpgviddmx_check_dur(filter, ctx);

	pck = gf_filter_pid_get_packet(ctx->ipid);
	if (!pck) {
		if (gf_filter_pid_is_eos(ctx->ipid)) {
			mpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_TRUE);
			if (ctx->opid)
				gf_filter_pid_set_eos(ctx->opid);
			if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
			ctx->src_pck = NULL;
			return GF_EOS;
		}
		return GF_OK;
	}

	data = (char *) gf_filter_pck_get_data(pck, &pck_size);
	byte_offset = gf_filter_pck_get_byte_offset(pck);

	start = data;
	remain = pck_size;

	//input pid sets some timescale - we flushed pending data , update cts
	if (!ctx->resume_from && ctx->timescale) {
		u64 ts = gf_filter_pck_get_cts(pck);
		if (ts != GF_FILTER_NO_TS) {
			if (!ctx->cts || !ctx->recompute_cts)
				ctx->cts = ts;
		}
		ts = gf_filter_pck_get_dts(pck);
		if (ts != GF_FILTER_NO_TS) {
			if (!ctx->dts || !ctx->recompute_cts)
				ctx->dts = ts;

			if (!ctx->prev_dts) ctx->prev_dts = ts;
			else if (ctx->prev_dts != ts) {
				u64 diff = ts;
				diff -= ctx->prev_dts;
				if (!ctx->cur_fps.den) ctx->cur_fps.den = (u32) diff;
				else if (ctx->cur_fps.den > diff)
					ctx->cur_fps.den = (u32) diff;
			}
		}
		gf_filter_pck_get_framing(pck, &ctx->input_is_au_start, &ctx->input_is_au_end);
		//this will force CTS recomput of each frame
		if (ctx->recompute_cts) ctx->input_is_au_start = GF_FALSE;
		if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
		ctx->src_pck = pck;
		gf_filter_pck_ref_props(&ctx->src_pck);
	}

	//we stored some data to find the complete vosh, aggregate this packet with current one
	if (!ctx->resume_from && ctx->hdr_store_size) {
		if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) {
			ctx->hdr_store_alloc = ctx->hdr_store_size + pck_size;
			ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
		}
		memcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);
		if (byte_offset != GF_FILTER_NO_BO) {
			if (byte_offset >= ctx->hdr_store_size)
				byte_offset -= ctx->hdr_store_size;
			else
				byte_offset = GF_FILTER_NO_BO;
		}
		ctx->hdr_store_size += pck_size;
		start = data = ctx->hdr_store;
		remain = pck_size = ctx->hdr_store_size;
	}

	if (ctx->resume_from) {
		if (gf_filter_pid_would_block(ctx->opid))
			return GF_OK;

		//resume from data copied internally
		if (ctx->hdr_store_size) {
			assert(ctx->resume_from <= ctx->hdr_store_size);
			start = data = ctx->hdr_store + ctx->resume_from;
			remain = pck_size = ctx->hdr_store_size - ctx->resume_from;
		} else {
			assert(remain >= (s32) ctx->resume_from);
			start += ctx->resume_from;
			remain -= ctx->resume_from;
		}
		ctx->resume_from = 0;
	}

	if (!ctx->bs) {
		ctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);
	} else {
		gf_bs_reassign_buffer(ctx->bs, start, remain);
	}
	if (!ctx->vparser) {
		ctx->vparser = gf_m4v_parser_bs_new(ctx->bs, ctx->is_mpg12);
	}


	while (remain) {
		Bool full_frame;
		u8 *pck_data;
		s32 current;
		u8 sc_type, forced_sc_type=0;
		Bool sc_type_forced = GF_FALSE;
		Bool skip_pck = GF_FALSE;
		u8 ftype;
		u32 tinc;
		u64 size=0;
		u64 fstart;
		Bool is_coded;
		u32 bytes_from_store = 0;
		u32 hdr_offset = 0;
		Bool copy_last_bytes = GF_FALSE;

		//not enough bytes to parse start code
		if (remain<5) {
			memcpy(ctx->hdr_store, start, remain);
			ctx->bytes_in_header = remain;
			break;
		}
		current = -1;

		//we have some potential bytes of a start code in the store, copy some more bytes and check if valid start code.
		//if not, dispatch these bytes as continuation of the data
		if (ctx->bytes_in_header) {

			memcpy(ctx->hdr_store + ctx->bytes_in_header, start, 8 - ctx->bytes_in_header);
			current = mpgviddmx_next_start_code(ctx->hdr_store, 8);

			//no start code in stored buffer
			if ((current<0) || (current >= (s32) ctx->bytes_in_header) )  {
				if (ctx->opid) {
					dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);
					if (!dst_pck) return GF_OUT_OF_MEM;

					if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
					gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
					gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
					memcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);
					gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);

					if (byte_offset != GF_FILTER_NO_BO) {
						gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);
					}

					mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
				}

				if (current<0) current = -1;
				else current -= ctx->bytes_in_header;
				ctx->bytes_in_header = 0;
			} else {
				//we have a valid start code, check which byte in our store or in the packet payload is the start code type
				//and remember its location to reinit the parser from there
				hdr_offset = 4 - ctx->bytes_in_header + current;
				//bytes still to dispatch
				bytes_from_store = ctx->bytes_in_header;
				ctx->bytes_in_header = 0;
				if (!hdr_offset) {
					forced_sc_type = ctx->hdr_store[current+3];
				} else {
					forced_sc_type = start[hdr_offset-1];
				}
				sc_type_forced = GF_TRUE;
			}
		}
		//no starcode in store, look for startcode in packet
		if (current == -1) {
			//locate next start code
			current = mpgviddmx_next_start_code(start, remain);
			//no start code, dispatch the block
			if (current<0) {
				u8 b3, b2, b1;
				if (! ctx->frame_started) {
					GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (""[MPGVid] no start code in block and no frame started, discarding data\n"" ));
					break;
				}
				size = remain;
				b3 = start[remain-3];
				b2 = start[remain-2];
				b1 = start[remain-1];
				//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !
				if (!b1 || !b2 || !b3) {
					copy_last_bytes = GF_TRUE;
					assert(size >= 3);
					size -= 3;
					ctx->bytes_in_header = 3;
				}

				dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);
				if (!dst_pck) return GF_OUT_OF_MEM;

				if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
				memcpy(pck_data, start, (size_t) size);
				gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);
				gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
				gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);

				if (byte_offset != GF_FILTER_NO_BO) {
					gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
				}

				mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
				if (copy_last_bytes) {
					memcpy(ctx->hdr_store, start+remain-3, 3);
				}
				break;
			}
		}

		assert(current>=0);

		//if we are in the middle of parsing the vosh, skip over bytes remaining from previous obj not parsed
		if ((vosh_start>=0) && current) {
			assert(remain>=current);
			start += current;
			remain -= current;
			current = 0;
		}
		//also skip if no output pid
		if (!ctx->opid && current) {
			assert(remain>=current);
			start += current;
			remain -= current;
			current = 0;
		}
		//dispatch remaining bytes
		if (current>0) {
			//flush remaining
			dst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data);
			if (!dst_pck) return GF_OUT_OF_MEM;

			if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
			gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);
			gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);
			gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_TRUE);
			//bytes were partly in store, partly in packet
			if (bytes_from_store) {
				if (byte_offset != GF_FILTER_NO_BO) {
					gf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);
				}
				assert(bytes_from_store>=(u32) current);
				bytes_from_store -= current;
				memcpy(pck_data, ctx->hdr_store, current);
			} else {
				//bytes were only in packet
				if (byte_offset != GF_FILTER_NO_BO) {
					gf_filter_pck_set_byte_offset(dst_pck, byte_offset);
				}
				memcpy(pck_data, start, current);
				assert(remain>=current);
				start += current;
				remain -= current;
				current = 0;
			}
			gf_filter_pck_set_carousel_version(dst_pck, 1);

			mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);
		}

		//parse headers

		//we have a start code loaded, eg the data packet does not have a full start code at the beginning
		if (sc_type_forced) {
			gf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset);
			sc_type = forced_sc_type;
		} else {
			gf_bs_reassign_buffer(ctx->bs, start, remain);
			gf_bs_read_int(ctx->bs, 24);
			sc_type = gf_bs_read_int(ctx->bs, 8);
		}

		if (ctx->is_mpg12) {
			switch (sc_type) {
			case M2V_SEQ_START_CODE:
			case M2V_EXT_START_CODE:
				gf_bs_reassign_buffer(ctx->bs, start, remain);
				e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);
				//not enough data, accumulate until we can parse the full header
				if (e==GF_EOS) {
					if (vosh_start<0) vosh_start = 0;
					if (data == ctx->hdr_store) {
						memmove(ctx->hdr_store, start, remain);
						ctx->hdr_store_size = remain;
					} else {
						if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
							ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);
							ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
						}
						memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
						ctx->hdr_store_size += pck_size - (u32) vosh_start;
					}
					gf_filter_pid_drop_packet(ctx->ipid);
					return GF_OK;
				} else if (e != GF_OK) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""[MPGVid] Failed to parse VOS header: %s\n"", gf_error_to_string(e) ));
				} else {
					mpgviddmx_check_pid(filter, ctx, 0, NULL);
				}
				break;
			case M2V_PIC_START_CODE:
				break;
			default:
				break;
			}

		} else {
			u8 PL;
			switch (sc_type) {
			case M4V_VOS_START_CODE:
				ctx->dsi.VideoPL = (u8) gf_bs_read_u8(ctx->bs);
				vosh_start = start - (u8 *)data;
				skip_pck = GF_TRUE;
				assert(remain>=5);
				start += 5;
				remain -= 5;
				break;
			case M4V_VOL_START_CODE:
				gf_bs_reassign_buffer(ctx->bs, start, remain);
				PL = ctx->dsi.VideoPL;
				e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);
				ctx->dsi.VideoPL = PL;
				//not enough data, accumulate until we can parse the full header
				if (e==GF_EOS) {
					if (vosh_start<0) vosh_start = 0;
					if (data == ctx->hdr_store) {
						memmove(ctx->hdr_store, start, remain);
						ctx->hdr_store_size = remain;
					} else {
						if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
							ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);
							ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
						}
						memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
						ctx->hdr_store_size += pck_size - (u32) vosh_start;
					}
					gf_filter_pid_drop_packet(ctx->ipid);
					return GF_OK;
				} else if (e != GF_OK) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""[MPGVid] Failed to parse VOS header: %s\n"", gf_error_to_string(e) ));
				} else {
					u32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);
					if (vosh_start<0) vosh_start = 0;
					vosh_end = start - (u8 *)data + obj_size;
					vosh_end -= vosh_start;
					mpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);
					skip_pck = GF_TRUE;
					assert(remain>=(s32) obj_size);
					start += obj_size;
					remain -= obj_size;
				}
				break;
			case M4V_VOP_START_CODE:
			case M4V_GOV_START_CODE:
				break;

			case M4V_VO_START_CODE:
			case M4V_VISOBJ_START_CODE:
			default:
				if (vosh_start>=0) {
					skip_pck = GF_TRUE;
					assert(remain>=4);
					start += 4;
					remain -= 4;
				}
				break;
			}
		}

		if (skip_pck) {
			continue;
		}

		if (!ctx->opid) {
			assert(remain>=4);
			start += 4;
			remain -= 4;
			continue;
		}

		if (!ctx->is_playing) {
			ctx->resume_from = (u32) ((char *)start -  (char *)data);
			return GF_OK;
		}
		//at this point, we no longer reaggregate packets
		ctx->hdr_store_size = 0;

		if (ctx->in_seek) {
			u64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num);
			if (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) {
				//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;
				ctx->in_seek = GF_FALSE;
			}
		}
		//may happen that after all our checks, only 4 bytes are left, continue to store these 4 bytes
		if (remain<5)
			continue;

		//good to go
		gf_m4v_parser_reset(ctx->vparser, sc_type_forced ? forced_sc_type + 1 : 0);
		size = 0;
		e = gf_m4v_parse_frame(ctx->vparser, &ctx->dsi, &ftype, &tinc, &size, &fstart, &is_coded);
		//true if we strip VO and VISOBJ assert(!fstart);

		//we skipped bytes already in store + end of start code present in packet, so the size of the first object
		//needs adjustement
		if (bytes_from_store) {
			size += bytes_from_store + hdr_offset;
		}

		if ((e == GF_EOS) && !ctx->input_is_au_end) {
			u8 b3 = start[remain-3];
			u8 b2 = start[remain-2];
			u8 b1 = start[remain-1];

			//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !
			if (!b1 || !b2 || !b3) {
				copy_last_bytes = GF_TRUE;
				assert(size >= 3);
				size -= 3;
				ctx->bytes_in_header = 3;
			}
			full_frame = GF_FALSE;
		} else {
			full_frame = GF_TRUE;
		}

		if (!is_coded) {
			/*if prev is B and we're parsing a packed bitstream discard n-vop*/
			if (ctx->forced_packed && ctx->b_frames) {
				ctx->is_packed = GF_TRUE;
				assert(remain>=size);
				start += size;
				remain -= (s32) size;
				continue;
			}
			/*policy is to import at variable frame rate, skip*/
			if (ctx->vfr) {
				ctx->is_vfr = GF_TRUE;
				mpgviddmx_update_time(ctx);
				assert(remain>=size);
				start += size;
				remain -= (s32) size;
				continue;
			}
			/*policy is to keep non coded frame (constant frame rate), add*/
		}

		if (ftype==2) {
			//count number of B-frames since last ref
			ctx->b_frames++;
			ctx->nb_b++;
		} else {
			//flush all pending packets
			mpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);
			//remeber the CTS of the last ref
			ctx->last_ref_cts = ctx->cts;
			if (ctx->max_b < ctx->b_frames) ctx->max_b = ctx->b_frames;
			
			ctx->b_frames = 0;
			if (ftype)
				ctx->nb_p++;
			else
				ctx->nb_i++;
		}
		ctx->nb_frames++;

		dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);
		if (!dst_pck) return GF_OUT_OF_MEM;

		if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);
		//bytes come from both our store and the data packet
		if (bytes_from_store) {
			memcpy(pck_data, ctx->hdr_store+current, bytes_from_store);
			assert(size >= bytes_from_store);
			size -= bytes_from_store;
			if (byte_offset != GF_FILTER_NO_BO) {
				gf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);
			}
			memcpy(pck_data + bytes_from_store, start, (size_t) size);
		} else {
			//bytes only come the data packet
			memcpy(pck_data, start, (size_t) size);
			if (byte_offset != GF_FILTER_NO_BO) {
				gf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data);
			}
		}
		assert(pck_data[0] == 0);
		assert(pck_data[1] == 0);
		assert(pck_data[2] == 0x01);

		gf_filter_pck_set_framing(dst_pck, GF_TRUE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE);
		gf_filter_pck_set_cts(dst_pck, ctx->cts);
		gf_filter_pck_set_dts(dst_pck, ctx->dts);
		if (ctx->input_is_au_start) {
			ctx->input_is_au_start = GF_FALSE;
		} else {
			//we use the carousel flag temporarly to indicate the cts must be recomputed
			gf_filter_pck_set_carousel_version(dst_pck, 1);
		}
		gf_filter_pck_set_sap(dst_pck, ftype ? GF_FILTER_SAP_NONE : GF_FILTER_SAP_1);
		gf_filter_pck_set_duration(dst_pck, ctx->cur_fps.den);
		if (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);
		ctx->frame_started = GF_TRUE;

		mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);

		mpgviddmx_update_time(ctx);

		if (!full_frame) {
			if (copy_last_bytes) {
				memcpy(ctx->hdr_store, start+remain-3, 3);
			}
			break;
		}
		assert(remain>=size);
		start += size;
		remain -= (s32) size;
	}
	gf_filter_pid_drop_packet(ctx->ipid);

	return GF_OK;
}","GF_Err mpgviddmx_process(GF_Filter *VAR_0)
{
	GF_MPGVidDmxCtx *VAR_1 = gf_filter_get_udta(VAR_0);
	GF_FilterPacket *VAR_2, *VAR_3;
	u64 VAR_4;
	s64 VAR_5 = -1;
	s64 VAR_6 = -1;
	GF_Err VAR_7;
	char *VAR_8;
	u8 *VAR_9;
	u32 VAR_10;
	s32 VAR_11;

	/* COMMENT_0 */
	if (!VAR_1->duration.num)
		mpgviddmx_check_dur(VAR_0, VAR_1);

	VAR_2 = gf_filter_pid_get_packet(VAR_1->ipid);
	if (!VAR_2) {
		if (gf_filter_pid_is_eos(VAR_1->ipid)) {
			mpgviddmx_enqueue_or_dispatch(VAR_1, NULL, VAR_12, VAR_12);
			if (VAR_1->opid)
				gf_filter_pid_set_eos(VAR_1->opid);
			if (VAR_1->src_pck) gf_filter_pck_unref(VAR_1->src_pck);
			VAR_1->src_pck = NULL;
			return VAR_13;
		}
		return VAR_14;
	}

	VAR_8 = (char *) gf_filter_pck_get_data(VAR_2, &VAR_10);
	VAR_4 = gf_filter_pck_get_byte_offset(VAR_2);

	VAR_9 = VAR_8;
	VAR_11 = VAR_10;

	/* COMMENT_1 */
	if (!VAR_1->resume_from && VAR_1->timescale) {
		u64 VAR_15 = gf_filter_pck_get_cts(VAR_2);
		if (VAR_15 != VAR_16) {
			if (!VAR_1->cts || !VAR_1->recompute_cts)
				VAR_1->cts = VAR_15;
		}
		VAR_15 = gf_filter_pck_get_dts(VAR_2);
		if (VAR_15 != VAR_16) {
			if (!VAR_1->dts || !VAR_1->recompute_cts)
				VAR_1->dts = VAR_15;

			if (!VAR_1->prev_dts) VAR_1->prev_dts = VAR_15;
			else if (VAR_1->prev_dts != VAR_15) {
				u64 VAR_17 = VAR_15;
				VAR_17 -= VAR_1->prev_dts;
				if (!VAR_1->cur_fps.den) VAR_1->cur_fps.den = (u32) VAR_17;
				else if (VAR_1->cur_fps.den > VAR_17)
					VAR_1->cur_fps.den = (u32) VAR_17;
			}
		}
		gf_filter_pck_get_framing(VAR_2, &VAR_1->input_is_au_start, &VAR_1->input_is_au_end);
		/* COMMENT_2 */
		if (VAR_1->recompute_cts) VAR_1->input_is_au_start = VAR_18;
		if (VAR_1->src_pck) gf_filter_pck_unref(VAR_1->src_pck);
		VAR_1->src_pck = VAR_2;
		gf_filter_pck_ref_props(&VAR_1->src_pck);
	}

	/* COMMENT_3 */
	if (!VAR_1->resume_from && VAR_1->hdr_store_size) {
		if (VAR_1->hdr_store_alloc < VAR_1->hdr_store_size + VAR_10) {
			VAR_1->hdr_store_alloc = VAR_1->hdr_store_size + VAR_10;
			VAR_1->hdr_store = gf_realloc(VAR_1->hdr_store, sizeof(char)*VAR_1->hdr_store_alloc);
		}
		memcpy(VAR_1->hdr_store + VAR_1->hdr_store_size, VAR_8, sizeof(char)*VAR_10);
		if (VAR_4 != VAR_19) {
			if (VAR_4 >= VAR_1->hdr_store_size)
				VAR_4 -= VAR_1->hdr_store_size;
			else
				VAR_4 = VAR_19;
		}
		VAR_1->hdr_store_size += VAR_10;
		VAR_9 = VAR_8 = VAR_1->hdr_store;
		VAR_11 = VAR_10 = VAR_1->hdr_store_size;
	}

	if (VAR_1->resume_from) {
		if (gf_filter_pid_would_block(VAR_1->opid))
			return VAR_14;

		/* COMMENT_4 */
		if (VAR_1->hdr_store_size) {
			assert(VAR_1->resume_from <= VAR_1->hdr_store_size);
			VAR_9 = VAR_8 = VAR_1->hdr_store + VAR_1->resume_from;
			VAR_11 = VAR_10 = VAR_1->hdr_store_size - VAR_1->resume_from;
		} else {
			assert(VAR_11 >= (s32) VAR_1->resume_from);
			VAR_9 += VAR_1->resume_from;
			VAR_11 -= VAR_1->resume_from;
		}
		VAR_1->resume_from = 0;
	}

	if (!VAR_1->bs) {
		VAR_1->bs = gf_bs_new(VAR_9, VAR_11, VAR_20);
	} else {
		gf_bs_reassign_buffer(VAR_1->bs, VAR_9, VAR_11);
	}
	if (!VAR_1->vparser) {
		VAR_1->vparser = gf_m4v_parser_bs_new(VAR_1->bs, VAR_1->is_mpg12);
	}


	while (VAR_11) {
		Bool VAR_21;
		u8 *VAR_22;
		s32 VAR_23;
		u8 VAR_24, VAR_25=0;
		Bool VAR_26 = VAR_18;
		Bool VAR_27 = VAR_18;
		u8 VAR_28;
		u32 VAR_29;
		u64 VAR_30=0;
		u64 VAR_31;
		Bool VAR_32;
		u32 VAR_33 = 0;
		u32 VAR_34 = 0;
		Bool VAR_35 = VAR_18;

		/* COMMENT_5 */
		if (VAR_11<5) {
			memcpy(VAR_1->hdr_store, VAR_9, VAR_11);
			VAR_1->bytes_in_header = VAR_11;
			break;
		}
		VAR_23 = -1;

		/* COMMENT_6 */
		/* COMMENT_7 */
		if (VAR_1->bytes_in_header) {

			memcpy(VAR_1->hdr_store + VAR_1->bytes_in_header, VAR_9, 8 - VAR_1->bytes_in_header);
			VAR_23 = mpgviddmx_next_start_code(VAR_1->hdr_store, 8);

			/* COMMENT_8 */
			if ((VAR_23<0) || (VAR_23 >= (s32) VAR_1->bytes_in_header) )  {
				if (VAR_1->opid) {
					VAR_3 = gf_filter_pck_new_alloc(VAR_1->opid, VAR_1->bytes_in_header, &VAR_22);
					if (!VAR_3) return VAR_36;

					if (VAR_1->src_pck) gf_filter_pck_merge_properties(VAR_1->src_pck, VAR_3);
					gf_filter_pck_set_cts(VAR_3, VAR_16);
					gf_filter_pck_set_dts(VAR_3, VAR_16);
					memcpy(VAR_22, VAR_1->hdr_store, VAR_1->bytes_in_header);
					gf_filter_pck_set_framing(VAR_3, VAR_18, VAR_18);

					if (VAR_4 != VAR_19) {
						gf_filter_pck_set_byte_offset(VAR_3, VAR_4 - VAR_1->bytes_in_header);
					}

					mpgviddmx_enqueue_or_dispatch(VAR_1, VAR_3, VAR_18, VAR_18);
				}

				if (VAR_23<0) VAR_23 = -1;
				else VAR_23 -= VAR_1->bytes_in_header;
				VAR_1->bytes_in_header = 0;
			} else {
				/* COMMENT_9 */
				/* COMMENT_10 */
				VAR_34 = 4 - VAR_1->bytes_in_header + VAR_23;
				/* COMMENT_11 */
				VAR_33 = VAR_1->bytes_in_header;
				VAR_1->bytes_in_header = 0;
				if (!VAR_34) {
					VAR_25 = VAR_1->hdr_store[VAR_23+3];
				} else {
					VAR_25 = VAR_9[VAR_34-1];
				}
				VAR_26 = VAR_12;
			}
		}
		/* COMMENT_12 */
		if (VAR_23 == -1) {
			/* COMMENT_13 */
			VAR_23 = mpgviddmx_next_start_code(VAR_9, VAR_11);
			/* COMMENT_14 */
			if (VAR_23<0) {
				u8 VAR_37, VAR_38, VAR_39;
				if (! VAR_1->frame_started) {
					GF_LOG(VAR_40, VAR_41, (""[MPGVid] no start code in block and no frame started, discarding data\n"" ));
					break;
				}
				VAR_30 = VAR_11;
				VAR_37 = VAR_9[VAR_11-3];
				VAR_38 = VAR_9[VAR_11-2];
				VAR_39 = VAR_9[VAR_11-1];
				/* COMMENT_15 */
				if (!VAR_39 || !VAR_38 || !VAR_37) {
					VAR_35 = VAR_12;
					assert(VAR_30 >= 3);
					VAR_30 -= 3;
					VAR_1->bytes_in_header = 3;
				}

				VAR_3 = gf_filter_pck_new_alloc(VAR_1->opid, (u32) VAR_30, &VAR_22);
				if (!VAR_3) return VAR_36;

				if (VAR_1->src_pck) gf_filter_pck_merge_properties(VAR_1->src_pck, VAR_3);
				memcpy(VAR_22, VAR_9, (size_t) VAR_30);
				gf_filter_pck_set_framing(VAR_3, VAR_18, VAR_18);
				gf_filter_pck_set_cts(VAR_3, VAR_16);
				gf_filter_pck_set_dts(VAR_3, VAR_16);

				if (VAR_4 != VAR_19) {
					gf_filter_pck_set_byte_offset(VAR_3, VAR_4);
				}

				mpgviddmx_enqueue_or_dispatch(VAR_1, VAR_3, VAR_18, VAR_18);
				if (VAR_35) {
					memcpy(VAR_1->hdr_store, VAR_9+VAR_11-3, 3);
				}
				break;
			}
		}

		assert(VAR_23>=0);

		/* COMMENT_16 */
		if ((VAR_5>=0) && VAR_23) {
			assert(VAR_11>=VAR_23);
			VAR_9 += VAR_23;
			VAR_11 -= VAR_23;
			VAR_23 = 0;
		}
		/* COMMENT_17 */
		if (!VAR_1->opid && VAR_23) {
			assert(VAR_11>=VAR_23);
			VAR_9 += VAR_23;
			VAR_11 -= VAR_23;
			VAR_23 = 0;
		}
		/* COMMENT_18 */
		if (VAR_23>0) {
			/* COMMENT_19 */
			VAR_3 = gf_filter_pck_new_alloc(VAR_1->opid, VAR_23, &VAR_22);
			if (!VAR_3) return VAR_36;

			if (VAR_1->src_pck) gf_filter_pck_merge_properties(VAR_1->src_pck, VAR_3);
			gf_filter_pck_set_cts(VAR_3, VAR_16);
			gf_filter_pck_set_dts(VAR_3, VAR_16);
			gf_filter_pck_set_framing(VAR_3, VAR_18, VAR_12);
			/* COMMENT_20 */
			if (VAR_33) {
				if (VAR_4 != VAR_19) {
					gf_filter_pck_set_byte_offset(VAR_3, VAR_4 - VAR_33);
				}
				assert(VAR_33>=(u32) VAR_23);
				VAR_33 -= VAR_23;
				memcpy(VAR_22, VAR_1->hdr_store, VAR_23);
			} else {
				/* COMMENT_21 */
				if (VAR_4 != VAR_19) {
					gf_filter_pck_set_byte_offset(VAR_3, VAR_4);
				}
				memcpy(VAR_22, VAR_9, VAR_23);
				assert(VAR_11>=VAR_23);
				VAR_9 += VAR_23;
				VAR_11 -= VAR_23;
				VAR_23 = 0;
			}
			gf_filter_pck_set_carousel_version(VAR_3, 1);

			mpgviddmx_enqueue_or_dispatch(VAR_1, VAR_3, VAR_18, VAR_18);
		}

		/* COMMENT_22 */

		/* COMMENT_23 */
		if (VAR_26) {
			gf_bs_reassign_buffer(VAR_1->bs, VAR_9 + VAR_34, VAR_11 - VAR_34);
			VAR_24 = VAR_25;
		} else {
			gf_bs_reassign_buffer(VAR_1->bs, VAR_9, VAR_11);
			gf_bs_read_int(VAR_1->bs, 24);
			VAR_24 = gf_bs_read_int(VAR_1->bs, 8);
		}

		if (VAR_1->is_mpg12) {
			switch (VAR_24) {
			case VAR_42:
			case VAR_43:
				gf_bs_reassign_buffer(VAR_1->bs, VAR_9, VAR_11);
				VAR_7 = gf_m4v_parse_config(VAR_1->vparser, &VAR_1->dsi);
				/* COMMENT_24 */
				if (VAR_7==VAR_13) {
					if (VAR_5<0) VAR_5 = 0;
					if (VAR_8 == VAR_1->hdr_store) {
						memmove(VAR_1->hdr_store, VAR_9, VAR_11);
						VAR_1->hdr_store_size = VAR_11;
					} else {
						if (VAR_1->hdr_store_alloc < VAR_1->hdr_store_size + VAR_10 - VAR_5) {
							VAR_1->hdr_store_alloc = (u32) (VAR_1->hdr_store_size + VAR_10 - VAR_5);
							VAR_1->hdr_store = gf_realloc(VAR_1->hdr_store, sizeof(char)*VAR_1->hdr_store_alloc);
						}
						memcpy(VAR_1->hdr_store + VAR_1->hdr_store_size, VAR_8 + VAR_5, (size_t) (VAR_10 - VAR_5) );
						VAR_1->hdr_store_size += VAR_10 - (u32) VAR_5;
					}
					gf_filter_pid_drop_packet(VAR_1->ipid);
					return VAR_14;
				} else if (VAR_7 != VAR_14) {
					GF_LOG(VAR_44, VAR_41, (""[MPGVid] Failed to parse VOS header: %s\n"", gf_error_to_string(VAR_7) ));
				} else {
					mpgviddmx_check_pid(VAR_0, VAR_1, 0, NULL);
				}
				break;
			case VAR_45:
				break;
			default:
				break;
			}

		} else {
			u8 VAR_46;
			switch (VAR_24) {
			case VAR_47:
				VAR_1->dsi.VideoPL = (u8) gf_bs_read_u8(VAR_1->bs);
				VAR_5 = VAR_9 - (u8 *)VAR_8;
				VAR_27 = VAR_12;
				assert(VAR_11>=5);
				VAR_9 += 5;
				VAR_11 -= 5;
				break;
			case VAR_48:
				gf_bs_reassign_buffer(VAR_1->bs, VAR_9, VAR_11);
				VAR_46 = VAR_1->dsi.VideoPL;
				VAR_7 = gf_m4v_parse_config(VAR_1->vparser, &VAR_1->dsi);
				VAR_1->dsi.VideoPL = VAR_46;
				/* COMMENT_24 */
				if (VAR_7==VAR_13) {
					if (VAR_5<0) VAR_5 = 0;
					if (VAR_8 == VAR_1->hdr_store) {
						memmove(VAR_1->hdr_store, VAR_9, VAR_11);
						VAR_1->hdr_store_size = VAR_11;
					} else {
						if (VAR_1->hdr_store_alloc < VAR_1->hdr_store_size + VAR_10 - VAR_5) {
							VAR_1->hdr_store_alloc = (u32) (VAR_1->hdr_store_size + VAR_10 - (u32) VAR_5);
							VAR_1->hdr_store = gf_realloc(VAR_1->hdr_store, sizeof(char)*VAR_1->hdr_store_alloc);
						}
						memcpy(VAR_1->hdr_store + VAR_1->hdr_store_size, VAR_8 + VAR_5, (size_t) (VAR_10 - VAR_5) );
						VAR_1->hdr_store_size += VAR_10 - (u32) VAR_5;
					}
					gf_filter_pid_drop_packet(VAR_1->ipid);
					return VAR_14;
				} else if (VAR_7 != VAR_14) {
					GF_LOG(VAR_44, VAR_41, (""[MPGVid] Failed to parse VOS header: %s\n"", gf_error_to_string(VAR_7) ));
				} else {
					u32 VAR_49 = (u32) gf_m4v_get_object_start(VAR_1->vparser);
					if (VAR_5<0) VAR_5 = 0;
					VAR_6 = VAR_9 - (u8 *)VAR_8 + VAR_49;
					VAR_6 -= VAR_5;
					mpgviddmx_check_pid(VAR_0, VAR_1,(u32)  VAR_6, VAR_8+VAR_5);
					VAR_27 = VAR_12;
					assert(VAR_11>=(s32) VAR_49);
					VAR_9 += VAR_49;
					VAR_11 -= VAR_49;
				}
				break;
			case VAR_50:
			case VAR_51:
				break;

			case VAR_52:
			case VAR_53:
			default:
				if (VAR_5>=0) {
					VAR_27 = VAR_12;
					assert(VAR_11>=4);
					VAR_9 += 4;
					VAR_11 -= 4;
				}
				break;
			}
		}

		if (VAR_27) {
			continue;
		}

		if (!VAR_1->opid) {
			assert(VAR_11>=4);
			VAR_9 += 4;
			VAR_11 -= 4;
			continue;
		}

		if (!VAR_1->is_playing) {
			VAR_1->resume_from = (u32) ((char *)VAR_9 -  (char *)VAR_8);
			return VAR_14;
		}
		/* COMMENT_25 */
		VAR_1->hdr_store_size = 0;

		if (VAR_1->in_seek) {
			u64 VAR_54 = (u64) (VAR_1->start_range * VAR_1->cur_fps.num);
			if (VAR_1->cts + VAR_1->cur_fps.den >= VAR_54) {
				/* COMMENT_26 */
				VAR_1->in_seek = VAR_18;
			}
		}
		/* COMMENT_27 */
		if (VAR_11<5)
			continue;

		/* COMMENT_28 */
		gf_m4v_parser_reset(VAR_1->vparser, VAR_26 ? VAR_25 + 1 : 0);
		VAR_30 = 0;
		VAR_7 = gf_m4v_parse_frame(VAR_1->vparser, &VAR_1->dsi, &VAR_28, &VAR_29, &VAR_30, &VAR_31, &VAR_32);
		/* COMMENT_29 */

		/* COMMENT_30 */
		/* COMMENT_31 */
		if (VAR_33) {
			VAR_30 += VAR_33 + VAR_34;
		}

		if ((VAR_7 == VAR_13) && !VAR_1->input_is_au_end) {
			u8 VAR_37 = VAR_9[VAR_11-3];
			u8 VAR_38 = VAR_9[VAR_11-2];
			u8 VAR_39 = VAR_9[VAR_11-1];

			/* COMMENT_15 */
			if (!VAR_39 || !VAR_38 || !VAR_37) {
				VAR_35 = VAR_12;
				assert(VAR_30 >= 3);
				VAR_30 -= 3;
				VAR_1->bytes_in_header = 3;
			}
			VAR_21 = VAR_18;
		} else {
			VAR_21 = VAR_12;
		}

		if (!VAR_32) {
			/* COMMENT_32 */
			if (VAR_1->forced_packed && VAR_1->b_frames) {
				VAR_1->is_packed = VAR_12;
				assert(VAR_11>=VAR_30);
				VAR_9 += VAR_30;
				VAR_11 -= (s32) VAR_30;
				continue;
			}
			/* COMMENT_33 */
			if (VAR_1->vfr) {
				VAR_1->is_vfr = VAR_12;
				mpgviddmx_update_time(VAR_1);
				assert(VAR_11>=VAR_30);
				VAR_9 += VAR_30;
				VAR_11 -= (s32) VAR_30;
				continue;
			}
			/* COMMENT_34 */
		}

		if (VAR_28==2) {
			/* COMMENT_35 */
			VAR_1->b_frames++;
			VAR_1->nb_b++;
		} else {
			/* COMMENT_36 */
			mpgviddmx_enqueue_or_dispatch(VAR_1, NULL, VAR_12, VAR_18);
			/* COMMENT_37 */
			VAR_1->last_ref_cts = VAR_1->cts;
			if (VAR_1->max_b < VAR_1->b_frames) VAR_1->max_b = VAR_1->b_frames;
			
			VAR_1->b_frames = 0;
			if (VAR_28)
				VAR_1->nb_p++;
			else
				VAR_1->nb_i++;
		}
		VAR_1->nb_frames++;

		VAR_3 = gf_filter_pck_new_alloc(VAR_1->opid, (u32) VAR_30, &VAR_22);
		if (!VAR_3) return VAR_36;

		if (VAR_1->src_pck) gf_filter_pck_merge_properties(VAR_1->src_pck, VAR_3);
		/* COMMENT_38 */
		if (VAR_33) {
			memcpy(VAR_22, VAR_1->hdr_store+VAR_23, VAR_33);
			assert(VAR_30 >= VAR_33);
			VAR_30 -= VAR_33;
			if (VAR_4 != VAR_19) {
				gf_filter_pck_set_byte_offset(VAR_3, VAR_4 - VAR_33);
			}
			memcpy(VAR_22 + VAR_33, VAR_9, (size_t) VAR_30);
		} else {
			/* COMMENT_39 */
			memcpy(VAR_22, VAR_9, (size_t) VAR_30);
			if (VAR_4 != VAR_19) {
				gf_filter_pck_set_byte_offset(VAR_3, VAR_4 + VAR_9 - (u8 *) VAR_8);
			}
		}
		assert(VAR_22[0] == 0);
		assert(VAR_22[1] == 0);
		assert(VAR_22[2] == 0x01);

		gf_filter_pck_set_framing(VAR_3, VAR_12, (VAR_21 || VAR_1->input_is_au_end) ? VAR_12 : VAR_18);
		gf_filter_pck_set_cts(VAR_3, VAR_1->cts);
		gf_filter_pck_set_dts(VAR_3, VAR_1->dts);
		if (VAR_1->input_is_au_start) {
			VAR_1->input_is_au_start = VAR_18;
		} else {
			/* COMMENT_40 */
			gf_filter_pck_set_carousel_version(VAR_3, 1);
		}
		gf_filter_pck_set_sap(VAR_3, VAR_28 ? VAR_55 : VAR_56);
		gf_filter_pck_set_duration(VAR_3, VAR_1->cur_fps.den);
		if (VAR_1->in_seek) gf_filter_pck_set_seek_flag(VAR_3, VAR_12);
		VAR_1->frame_started = VAR_12;

		mpgviddmx_enqueue_or_dispatch(VAR_1, VAR_3, VAR_18, VAR_18);

		mpgviddmx_update_time(VAR_1);

		if (!VAR_21) {
			if (VAR_35) {
				memcpy(VAR_1->hdr_store, VAR_9+VAR_11-3, 3);
			}
			break;
		}
		assert(VAR_11>=VAR_30);
		VAR_9 += VAR_30;
		VAR_11 -= (s32) VAR_30;
	}
	gf_filter_pid_drop_packet(VAR_1->ipid);

	return VAR_14;
}",gpac/96047e0e6166407c40cc19f4e94fb35cd7624391/reframe_mpgvid.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -291,12 +291,17 @@
 				//not enough data, accumulate until we can parse the full header
 				if (e==GF_EOS) {
 					if (vosh_start<0) vosh_start = 0;
-					if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
-						ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);
-						ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
+					if (data == ctx->hdr_store) {
+						memmove(ctx->hdr_store, start, remain);
+						ctx->hdr_store_size = remain;
+					} else {
+						if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
+							ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);
+							ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
+						}
+						memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
+						ctx->hdr_store_size += pck_size - (u32) vosh_start;
 					}
-					memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
-					ctx->hdr_store_size += pck_size - (u32) vosh_start;
 					gf_filter_pid_drop_packet(ctx->ipid);
 					return GF_OK;
 				} else if (e != GF_OK) {
@@ -330,12 +335,17 @@
 				//not enough data, accumulate until we can parse the full header
 				if (e==GF_EOS) {
 					if (vosh_start<0) vosh_start = 0;
-					if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
-						ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);
-						ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
+					if (data == ctx->hdr_store) {
+						memmove(ctx->hdr_store, start, remain);
+						ctx->hdr_store_size = remain;
+					} else {
+						if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {
+							ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);
+							ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);
+						}
+						memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
+						ctx->hdr_store_size += pck_size - (u32) vosh_start;
 					}
-					memcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );
-					ctx->hdr_store_size += pck_size - (u32) vosh_start;
 					gf_filter_pid_drop_packet(ctx->ipid);
 					return GF_OK;
 				} else if (e != GF_OK) {","{'deleted_lines': ['\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {', '\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);', '\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);', '\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );', '\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;', '\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {', '\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);', '\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);', '\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );', '\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;'], 'added_lines': ['\t\t\t\t\tif (data == ctx->hdr_store) {', '\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);', '\t\t\t\t\t\tctx->hdr_store_size = remain;', '\t\t\t\t\t} else {', '\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {', '\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);', '\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);', '\t\t\t\t\t\t}', '\t\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );', '\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;', '\t\t\t\t\tif (data == ctx->hdr_store) {', '\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);', '\t\t\t\t\t\tctx->hdr_store_size = remain;', '\t\t\t\t\t} else {', '\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {', '\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);', '\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);', '\t\t\t\t\t\t}', '\t\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );', '\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;']}",True,"A Segmentation fault casued by heap use after free vulnerability exists in Gpac through 1.0.1 via the mpgviddmx_process function in reframe_mpgvid.c when using mp4box, which causes a denial of service.",5.5,MEDIUM,1,valid,2021-08-30T13:46:16Z,3
CVE-2021-40569,['CWE-415'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,gpac,fixed #1890,b03c9f252526bb42fbd1b87b9f5e339c3cf2390a,https://github.com/gpac/gpac/commit/b03c9f252526bb42fbd1b87b9f5e339c3cf2390a,src/isomedia/box_code_meta.c,iloc_box_read,"GF_Err iloc_box_read(GF_Box *s, GF_BitStream *bs)
{
u32 item_count, extent_count, i, j;
GF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;
ISOM_DECREASE_SIZE(ptr, 2)
ptr->offset_size = gf_bs_read_int(bs, 4);
ptr->length_size = gf_bs_read_int(bs, 4);
ptr->base_offset_size = gf_bs_read_int(bs, 4);
if (ptr->version == 1 || ptr->version == 2) {
ptr->index_size = gf_bs_read_int(bs, 4);
} else {
gf_bs_read_int(bs, 4);
}
if (ptr->version < 2) {
ISOM_DECREASE_SIZE(ptr, 2)
item_count = gf_bs_read_u16(bs);
} else {
ISOM_DECREASE_SIZE(ptr, 4)
item_count = gf_bs_read_u32(bs);
}
for (i = 0; i < item_count; i++) {
GF_ItemLocationEntry *location_entry = (GF_ItemLocationEntry *)gf_malloc(sizeof(GF_ItemLocationEntry));
if (!location_entry) return GF_OUT_OF_MEM;
gf_list_add(ptr->location_entries, location_entry);
if (ptr->version < 2) {
ISOM_DECREASE_SIZE(ptr, 2)
location_entry->item_ID = gf_bs_read_u16(bs);
} else {
ISOM_DECREASE_SIZE(ptr, 4)
location_entry->item_ID = gf_bs_read_u32(bs);
}
if (ptr->version == 1 || ptr->version == 2) {
ISOM_DECREASE_SIZE(ptr, 2)
location_entry->construction_method = gf_bs_read_u16(bs);
}
else {
location_entry->construction_method = 0;
}
ISOM_DECREASE_SIZE(ptr, (2 + ptr->base_offset_size) )
location_entry->data_reference_index = gf_bs_read_u16(bs);
location_entry->base_offset = gf_bs_read_int(bs, 8*ptr->base_offset_size);
#ifndef GPAC_DISABLE_ISOM_WRITE
location_entry->original_base_offset = location_entry->base_offset;
#endif
ISOM_DECREASE_SIZE(ptr, 2)
extent_count = gf_bs_read_u16(bs);
location_entry->extent_entries = gf_list_new();
for (j = 0; j < extent_count; j++) {
GF_ItemExtentEntry *extent_entry = (GF_ItemExtentEntry *)gf_malloc(sizeof(GF_ItemExtentEntry));
if (!extent_entry) return GF_OUT_OF_MEM;
gf_list_add(location_entry->extent_entries, extent_entry);
if ((ptr->version == 1 || ptr->version == 2) && ptr->index_size > 0) {
ISOM_DECREASE_SIZE(ptr, ptr->index_size)
extent_entry->extent_index = gf_bs_read_int(bs, 8 * ptr->index_size);
}
else {
extent_entry->extent_index = 0;
}
ISOM_DECREASE_SIZE(ptr, (ptr->offset_size+ptr->length_size) )
extent_entry->extent_offset = gf_bs_read_int(bs, 8*ptr->offset_size);
extent_entry->extent_length = gf_bs_read_int(bs, 8*ptr->length_size);
#ifndef GPAC_DISABLE_ISOM_WRITE
extent_entry->original_extent_offset = extent_entry->extent_offset;
#endif
}
}
return GF_OK;
}","GF_Err iloc_box_read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
u32 VAR_2, VAR_3, VAR_4, VAR_5;
GF_ItemLocationBox *VAR_6 = (GF_ItemLocationBox *)VAR_0;
ISOM_DECREASE_SIZE(VAR_6, 2)
VAR_6->offset_size = gf_bs_read_int(VAR_1, 4);
VAR_6->length_size = gf_bs_read_int(VAR_1, 4);
VAR_6->base_offset_size = gf_bs_read_int(VAR_1, 4);
if (VAR_6->version == 1 || VAR_6->version == 2) {
VAR_6->index_size = gf_bs_read_int(VAR_1, 4);
} else {
gf_bs_read_int(VAR_1, 4);
}
if (VAR_6->version < 2) {
ISOM_DECREASE_SIZE(VAR_6, 2)
VAR_2 = gf_bs_read_u16(VAR_1);
} else {
ISOM_DECREASE_SIZE(VAR_6, 4)
VAR_2 = gf_bs_read_u32(VAR_1);
}
for (VAR_4 = 0; VAR_4 < VAR_2; VAR_4++) {
GF_ItemLocationEntry *VAR_7 = (GF_ItemLocationEntry *)gf_malloc(sizeof(GF_ItemLocationEntry));
if (!VAR_7) return VAR_8;
gf_list_add(VAR_6->location_entries, VAR_7);
if (VAR_6->version < 2) {
ISOM_DECREASE_SIZE(VAR_6, 2)
VAR_7->item_ID = gf_bs_read_u16(VAR_1);
} else {
ISOM_DECREASE_SIZE(VAR_6, 4)
VAR_7->item_ID = gf_bs_read_u32(VAR_1);
}
if (VAR_6->version == 1 || VAR_6->version == 2) {
ISOM_DECREASE_SIZE(VAR_6, 2)
VAR_7->construction_method = gf_bs_read_u16(VAR_1);
}
else {
VAR_7->construction_method = 0;
}
ISOM_DECREASE_SIZE(VAR_6, (2 + VAR_6->base_offset_size) )
VAR_7->data_reference_index = gf_bs_read_u16(VAR_1);
VAR_7->base_offset = gf_bs_read_int(VAR_1, 8*VAR_6->base_offset_size);
#ifndef VAR_9
VAR_7->original_base_offset = VAR_7->base_offset;
#endif
ISOM_DECREASE_SIZE(VAR_6, 2)
VAR_3 = gf_bs_read_u16(VAR_1);
VAR_7->extent_entries = gf_list_new();
for (VAR_5 = 0; VAR_5 < VAR_3; VAR_5++) {
GF_ItemExtentEntry *VAR_10 = (GF_ItemExtentEntry *)gf_malloc(sizeof(GF_ItemExtentEntry));
if (!VAR_10) return VAR_8;
gf_list_add(VAR_7->extent_entries, VAR_10);
if ((VAR_6->version == 1 || VAR_6->version == 2) && VAR_6->index_size > 0) {
ISOM_DECREASE_SIZE(VAR_6, VAR_6->index_size)
VAR_10->extent_index = gf_bs_read_int(VAR_1, 8 * VAR_6->index_size);
}
else {
VAR_10->extent_index = 0;
}
ISOM_DECREASE_SIZE(VAR_6, (VAR_6->offset_size+VAR_6->length_size) )
VAR_10->extent_offset = gf_bs_read_int(VAR_1, 8*VAR_6->offset_size);
VAR_10->extent_length = gf_bs_read_int(VAR_1, 8*VAR_6->length_size);
#ifndef VAR_9
VAR_10->original_extent_offset = VAR_10->extent_offset;
#endif
}
}
return VAR_11;
}",gpac/b03c9f252526bb42fbd1b87b9f5e339c3cf2390a/box_code_meta.c/vul/before/0.json,"GF_Err iloc_box_read(GF_Box *s, GF_BitStream *bs)
{
	u32 item_count, extent_count, i, j;
	GF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;

	ISOM_DECREASE_SIZE(ptr, 2)
	ptr->offset_size = gf_bs_read_int(bs, 4);
	ptr->length_size = gf_bs_read_int(bs, 4);
	ptr->base_offset_size = gf_bs_read_int(bs, 4);
	if (ptr->version == 1 || ptr->version == 2) {
		ptr->index_size = gf_bs_read_int(bs, 4);
	} else {
		gf_bs_read_int(bs, 4);
	}
	if (ptr->version < 2) {
		ISOM_DECREASE_SIZE(ptr, 2)
		item_count = gf_bs_read_u16(bs);
	} else {
		ISOM_DECREASE_SIZE(ptr, 4)
		item_count = gf_bs_read_u32(bs);
	}

	for (i = 0; i < item_count; i++) {
		GF_ItemLocationEntry *location_entry;
		GF_SAFEALLOC(location_entry, GF_ItemLocationEntry);
		if (!location_entry) return GF_OUT_OF_MEM;

		gf_list_add(ptr->location_entries, location_entry);
		if (ptr->version < 2) {
			ISOM_DECREASE_SIZE(ptr, 2)
			location_entry->item_ID = gf_bs_read_u16(bs);
		} else {
			ISOM_DECREASE_SIZE(ptr, 4)
			location_entry->item_ID = gf_bs_read_u32(bs);
		}
		if (ptr->version == 1 || ptr->version == 2) {
			ISOM_DECREASE_SIZE(ptr, 2)
			location_entry->construction_method = gf_bs_read_u16(bs);
		}
		else {
			location_entry->construction_method = 0;
		}
		ISOM_DECREASE_SIZE(ptr, (2 + ptr->base_offset_size) )
		location_entry->data_reference_index = gf_bs_read_u16(bs);
		location_entry->base_offset = gf_bs_read_int(bs, 8*ptr->base_offset_size);
#ifndef GPAC_DISABLE_ISOM_WRITE
		location_entry->original_base_offset = location_entry->base_offset;
#endif

		ISOM_DECREASE_SIZE(ptr, 2)
		extent_count = gf_bs_read_u16(bs);
		location_entry->extent_entries = gf_list_new();
		for (j = 0; j < extent_count; j++) {
			GF_ItemExtentEntry *extent_entry;
			GF_SAFEALLOC(extent_entry, GF_ItemExtentEntry);
			if (!extent_entry) return GF_OUT_OF_MEM;
			
			gf_list_add(location_entry->extent_entries, extent_entry);
			if ((ptr->version == 1 || ptr->version == 2) && ptr->index_size > 0) {
				ISOM_DECREASE_SIZE(ptr, ptr->index_size)
				extent_entry->extent_index = gf_bs_read_int(bs, 8 * ptr->index_size);
			}
			else {
				extent_entry->extent_index = 0;
			}
			ISOM_DECREASE_SIZE(ptr, (ptr->offset_size+ptr->length_size) )

			extent_entry->extent_offset = gf_bs_read_int(bs, 8*ptr->offset_size);
			extent_entry->extent_length = gf_bs_read_int(bs, 8*ptr->length_size);
#ifndef GPAC_DISABLE_ISOM_WRITE
			extent_entry->original_extent_offset = extent_entry->extent_offset;
#endif
		}
	}
	return GF_OK;
}","GF_Err iloc_box_read(GF_Box *VAR_0, GF_BitStream *VAR_1)
{
	u32 VAR_2, VAR_3, VAR_4, VAR_5;
	GF_ItemLocationBox *VAR_6 = (GF_ItemLocationBox *)VAR_0;

	ISOM_DECREASE_SIZE(VAR_6, 2)
	VAR_6->offset_size = gf_bs_read_int(VAR_1, 4);
	VAR_6->length_size = gf_bs_read_int(VAR_1, 4);
	VAR_6->base_offset_size = gf_bs_read_int(VAR_1, 4);
	if (VAR_6->version == 1 || VAR_6->version == 2) {
		VAR_6->index_size = gf_bs_read_int(VAR_1, 4);
	} else {
		gf_bs_read_int(VAR_1, 4);
	}
	if (VAR_6->version < 2) {
		ISOM_DECREASE_SIZE(VAR_6, 2)
		VAR_2 = gf_bs_read_u16(VAR_1);
	} else {
		ISOM_DECREASE_SIZE(VAR_6, 4)
		VAR_2 = gf_bs_read_u32(VAR_1);
	}

	for (VAR_4 = 0; VAR_4 < VAR_2; VAR_4++) {
		GF_ItemLocationEntry *VAR_7;
		GF_SAFEALLOC(VAR_7, GF_ItemLocationEntry);
		if (!VAR_7) return VAR_8;

		gf_list_add(VAR_6->location_entries, VAR_7);
		if (VAR_6->version < 2) {
			ISOM_DECREASE_SIZE(VAR_6, 2)
			VAR_7->item_ID = gf_bs_read_u16(VAR_1);
		} else {
			ISOM_DECREASE_SIZE(VAR_6, 4)
			VAR_7->item_ID = gf_bs_read_u32(VAR_1);
		}
		if (VAR_6->version == 1 || VAR_6->version == 2) {
			ISOM_DECREASE_SIZE(VAR_6, 2)
			VAR_7->construction_method = gf_bs_read_u16(VAR_1);
		}
		else {
			VAR_7->construction_method = 0;
		}
		ISOM_DECREASE_SIZE(VAR_6, (2 + VAR_6->base_offset_size) )
		VAR_7->data_reference_index = gf_bs_read_u16(VAR_1);
		VAR_7->base_offset = gf_bs_read_int(VAR_1, 8*VAR_6->base_offset_size);
#ifndef VAR_9
		VAR_7->original_base_offset = VAR_7->base_offset;
#endif

		ISOM_DECREASE_SIZE(VAR_6, 2)
		VAR_3 = gf_bs_read_u16(VAR_1);
		VAR_7->extent_entries = gf_list_new();
		for (VAR_5 = 0; VAR_5 < VAR_3; VAR_5++) {
			GF_ItemExtentEntry *VAR_10;
			GF_SAFEALLOC(VAR_10, GF_ItemExtentEntry);
			if (!VAR_10) return VAR_8;
			
			gf_list_add(VAR_7->extent_entries, VAR_10);
			if ((VAR_6->version == 1 || VAR_6->version == 2) && VAR_6->index_size > 0) {
				ISOM_DECREASE_SIZE(VAR_6, VAR_6->index_size)
				VAR_10->extent_index = gf_bs_read_int(VAR_1, 8 * VAR_6->index_size);
			}
			else {
				VAR_10->extent_index = 0;
			}
			ISOM_DECREASE_SIZE(VAR_6, (VAR_6->offset_size+VAR_6->length_size) )

			VAR_10->extent_offset = gf_bs_read_int(VAR_1, 8*VAR_6->offset_size);
			VAR_10->extent_length = gf_bs_read_int(VAR_1, 8*VAR_6->length_size);
#ifndef VAR_9
			VAR_10->original_extent_offset = VAR_10->extent_offset;
#endif
		}
	}
	return VAR_11;
}",gpac/b03c9f252526bb42fbd1b87b9f5e339c3cf2390a/box_code_meta.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,7 +21,8 @@
 	}
 
 	for (i = 0; i < item_count; i++) {
-		GF_ItemLocationEntry *location_entry = (GF_ItemLocationEntry *)gf_malloc(sizeof(GF_ItemLocationEntry));
+		GF_ItemLocationEntry *location_entry;
+		GF_SAFEALLOC(location_entry, GF_ItemLocationEntry);
 		if (!location_entry) return GF_OUT_OF_MEM;
 
 		gf_list_add(ptr->location_entries, location_entry);
@@ -50,7 +51,8 @@
 		extent_count = gf_bs_read_u16(bs);
 		location_entry->extent_entries = gf_list_new();
 		for (j = 0; j < extent_count; j++) {
-			GF_ItemExtentEntry *extent_entry = (GF_ItemExtentEntry *)gf_malloc(sizeof(GF_ItemExtentEntry));
+			GF_ItemExtentEntry *extent_entry;
+			GF_SAFEALLOC(extent_entry, GF_ItemExtentEntry);
 			if (!extent_entry) return GF_OUT_OF_MEM;
 			
 			gf_list_add(location_entry->extent_entries, extent_entry);","{'deleted_lines': ['\t\tGF_ItemLocationEntry *location_entry = (GF_ItemLocationEntry *)gf_malloc(sizeof(GF_ItemLocationEntry));', '\t\t\tGF_ItemExtentEntry *extent_entry = (GF_ItemExtentEntry *)gf_malloc(sizeof(GF_ItemExtentEntry));'], 'added_lines': ['\t\tGF_ItemLocationEntry *location_entry;', '\t\tGF_SAFEALLOC(location_entry, GF_ItemLocationEntry);', '\t\t\tGF_ItemExtentEntry *extent_entry;', '\t\t\tGF_SAFEALLOC(extent_entry, GF_ItemExtentEntry);']}",True,"The binary MP4Box in Gpac through 1.0.1 has a double-free vulnerability in the iloc_entry_del funciton in box_code_meta.c, which allows attackers to cause a denial of service.",5.5,MEDIUM,1,valid,2021-08-30T13:55:13Z,3
CVE-2021-40570,['CWE-415'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,gpac,fixed #1899,04dbf08bff4d61948bab80c3f9096ecc60c7f302,https://github.com/gpac/gpac/commit/04dbf08bff4d61948bab80c3f9096ecc60c7f302,src/media_tools/av_parsers.c,gf_avc_read_sps_bs_internal,"static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)
{
AVC_SPS *sps;
s32 mb_width, mb_height, sps_id = -1;
u32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;
u8 separate_colour_plane_flag = 0;
if (!vui_flag_pos) {
gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);
}
if (!bs) {
return -1;
}
if (!nal_hdr) {
gf_bs_read_int_log(bs, 1, ""forbidden_zero_bit"");
gf_bs_read_int_log(bs, 2, ""nal_ref_idc"");
gf_bs_read_int_log(bs, 5, ""nal_unit_type"");
}
profile_idc = gf_bs_read_int_log(bs, 8, ""profile_idc"");
pcomp = gf_bs_read_int_log(bs, 8, ""profile_compatibility"");
if (pcomp & 0x3)
return -1;
level_idc = gf_bs_read_int_log(bs, 8, ""level_idc"");
sps_id = gf_bs_read_ue_log(bs, ""sps_id"") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;
if ((sps_id < 0) || (sps_id >= 32)) {
return -1;
}
luma_bd = chroma_bd = 0;
sps = &avc->sps[sps_id];
chroma_format_idc = sps->ChromaArrayType = 1;
sps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;
switch (profile_idc) {
case 100:
case 110:
case 122:
case 244:
case 44:
if (pcomp & 0xE0)
return -1;
case 83:
case 86:
case 118:
case 128:
chroma_format_idc = gf_bs_read_ue_log(bs, ""chroma_format_idc"");
sps->ChromaArrayType = chroma_format_idc;
if (chroma_format_idc == 3) {
separate_colour_plane_flag = gf_bs_read_int_log(bs, 1, ""separate_colour_plane_flag"");
if (separate_colour_plane_flag) sps->ChromaArrayType = 0;
}
luma_bd = gf_bs_read_ue_log(bs, ""luma_bit_depth"");
chroma_bd = gf_bs_read_ue_log(bs, ""chroma_bit_depth"");
gf_bs_read_int_log(bs, 1, ""qpprime_y_zero_transform_bypass_flag"");
if (gf_bs_read_int_log(bs, 1, ""seq_scaling_matrix_present_flag"")) {
u32 k;
for (k = 0; k < 8; k++) {
if (gf_bs_read_int_log_idx(bs, 1, ""seq_scaling_list_present_flag"", k)) {
u32 z, last = 8, next = 8;
u32 sl = k < 6 ? 16 : 64;
for (z = 0; z < sl; z++) {
if (next) {
s32 delta = gf_bs_read_se(bs);
next = (last + delta + 256) % 256;
}
last = next ? next : last;
}
}
}
}
break;
}
sps->profile_idc = profile_idc;
sps->level_idc = level_idc;
sps->prof_compat = pcomp;
sps->log2_max_frame_num = gf_bs_read_ue_log(bs, ""log2_max_frame_num"") + 4;
sps->poc_type = gf_bs_read_ue_log(bs, ""poc_type"");
sps->chroma_format = chroma_format_idc;
sps->luma_bit_depth_m8 = luma_bd;
sps->chroma_bit_depth_m8 = chroma_bd;
if (sps->poc_type == 0) {
sps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, ""log2_max_poc_lsb"") + 4;
}
else if (sps->poc_type == 1) {
sps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, ""delta_pic_order_always_zero_flag"");
sps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, ""offset_for_non_ref_pic"");
sps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, ""offset_for_top_to_bottom_field"");
sps->poc_cycle_length = gf_bs_read_ue_log(bs, ""poc_cycle_length"");
if (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\n""));
return -1;
}
for (i = 0; i < sps->poc_cycle_length; i++)
sps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, ""offset_for_ref_frame"", i);
}
if (sps->poc_type > 2) {
return -1;
}
sps->max_num_ref_frames = gf_bs_read_ue_log(bs, ""max_num_ref_frames"");
sps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, ""gaps_in_frame_num_value_allowed_flag"");
mb_width = gf_bs_read_ue_log(bs, ""pic_width_in_mbs_minus1"") + 1;
mb_height = gf_bs_read_ue_log(bs, ""pic_height_in_map_units_minus1"") + 1;
sps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, ""frame_mbs_only_flag"");
sps->width = mb_width * 16;
sps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;
if (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, ""mb_adaptive_frame_field_flag"");
gf_bs_read_int_log(bs, 1, ""direct_8x8_inference_flag"");
if (gf_bs_read_int_log(bs, 1, ""frame_cropping_flag"")) {
int CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;
if (chroma_format_idc == 1) {
SubWidthC = 2; SubHeightC = 2;
}
else if (chroma_format_idc == 2) {
SubWidthC = 2; SubHeightC = 1;
}
else if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {
SubWidthC = 1; SubHeightC = 1;
}
if (sps->ChromaArrayType == 0) {
assert(SubWidthC == -1);
CropUnitX = 1;
CropUnitY = 2 - sps->frame_mbs_only_flag;
}
else {
CropUnitX = SubWidthC;
CropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);
}
cl = gf_bs_read_ue_log(bs, ""frame_crop_left_offset"");
cr = gf_bs_read_ue_log(bs, ""frame_crop_right_offset"");
ct = gf_bs_read_ue_log(bs, ""frame_crop_top_offset"");
cb = gf_bs_read_ue_log(bs, ""frame_crop_bottom_offset"");
sps->width -= CropUnitX * (cl + cr);
sps->height -= CropUnitY * (ct + cb);
cl *= CropUnitX;
cr *= CropUnitX;
ct *= CropUnitY;
cb *= CropUnitY;
}
sps->crop.left = cl;
sps->crop.right = cr;
sps->crop.top = ct;
sps->crop.bottom = cb;
if (vui_flag_pos) {
*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);
}
sps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_parameters_present_flag"");
if (sps->vui_parameters_present_flag) {
sps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, ""aspect_ratio_info_present_flag"");
if (sps->vui.aspect_ratio_info_present_flag) {
s32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, ""aspect_ratio_idc"");
if (aspect_ratio_idc == 255) {
sps->vui.par_num = gf_bs_read_int_log(bs, 16, ""aspect_ratio_num"");
sps->vui.par_den = gf_bs_read_int_log(bs, 16, ""aspect_ratio_den"");
}
else if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {
sps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;
sps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;
}
else {
GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\n""));
}
}
sps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, ""overscan_info_present_flag"");
if (sps->vui.overscan_info_present_flag)
gf_bs_read_int_log(bs, 1, ""overscan_appropriate_flag"");
sps->vui.video_format = 5;
sps->vui.colour_primaries = 2;
sps->vui.transfer_characteristics = 2;
sps->vui.matrix_coefficients = 2;
sps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, ""video_signal_type_present_flag"");
if (sps->vui.video_signal_type_present_flag) {
sps->vui.video_format = gf_bs_read_int_log(bs, 3, ""video_format"");
sps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, ""video_full_range_flag"");
sps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, ""colour_description_present_flag"");
if (sps->vui.colour_description_present_flag) {
sps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, ""colour_primaries"");
sps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, ""transfer_characteristics"");
sps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, ""matrix_coefficients"");
}
}
if (gf_bs_read_int_log(bs, 1, ""chroma_location_info_present_flag"")) {
gf_bs_read_ue_log(bs, ""chroma_sample_location_type_top_field"");
gf_bs_read_ue_log(bs, ""chroma_sample_location_type_bottom_field"");
}
sps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, ""timing_info_present_flag"");
if (sps->vui.timing_info_present_flag) {
sps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, ""num_units_in_tick"");
sps->vui.time_scale = gf_bs_read_int_log(bs, 32, ""time_scale"");
sps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, ""fixed_frame_rate_flag"");
}
sps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""nal_hrd_parameters_present_flag"");
if (sps->vui.nal_hrd_parameters_present_flag)
avc_parse_hrd_parameters(bs, &sps->vui.hrd);
sps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vcl_hrd_parameters_present_flag"");
if (sps->vui.vcl_hrd_parameters_present_flag)
avc_parse_hrd_parameters(bs, &sps->vui.hrd);
if (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)
sps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, ""low_delay_hrd_flag"");
sps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, ""pic_struct_present_flag"");
}
if (subseq_sps) {
if ((profile_idc == 83) || (profile_idc == 86)) {
u8 extended_spatial_scalability_idc;
gf_bs_read_int_log(bs, 1, ""inter_layer_deblocking_filter_control_present_flag"");
extended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, ""extended_spatial_scalability_idc"");
if (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {
gf_bs_read_int_log(bs, 1, ""chroma_phase_x_plus1_flag"");
}
if (sps->ChromaArrayType == 1) {
gf_bs_read_int_log(bs, 2, ""chroma_phase_y_plus1"");
}
if (extended_spatial_scalability_idc == 1) {
if (sps->ChromaArrayType > 0) {
gf_bs_read_int_log(bs, 1, ""seq_ref_layer_chroma_phase_x_plus1_flag"");
gf_bs_read_int_log(bs, 2, ""seq_ref_layer_chroma_phase_y_plus1"");
}
gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_left_offset"");
gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_top_offset"");
gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_right_offset"");
gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_bottom_offset"");
}
if (gf_bs_read_int_log(bs, 1, ""seq_tcoeff_level_prediction_flag"")) {
gf_bs_read_int_log(bs, 1, ""adaptive_tcoeff_level_prediction_flag"");
}
gf_bs_read_int_log(bs, 1, ""slice_header_restriction_flag"");
if (gf_bs_read_int_log(bs, 1, ""svc_vui_parameters_present"")) {
u32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, ""vui_ext_num_entries_minus1"");
for (i = 0; i <= vui_ext_num_entries_minus1; i++) {
u8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;
gf_bs_read_int_log(bs, 3, ""vui_ext_dependency_id"");
gf_bs_read_int_log(bs, 4, ""vui_ext_quality_id"");
gf_bs_read_int_log(bs, 3, ""vui_ext_temporal_id"");
vui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_timing_info_present_flag"");
if (vui_ext_timing_info_present_flag) {
gf_bs_read_int_log(bs, 32, ""vui_ext_num_units_in_tick"");
gf_bs_read_int_log(bs, 32, ""vui_ext_time_scale"");
gf_bs_read_int_log(bs, 1, ""vui_ext_fixed_frame_rate_flag"");
}
vui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_nal_hrd_parameters_present_flag"");
if (vui_ext_nal_hrd_parameters_present_flag) {
}
vui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_vcl_hrd_parameters_present_flag"");
if (vui_ext_vcl_hrd_parameters_present_flag) {
}
if (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {
gf_bs_read_int_log(bs, 1, ""vui_ext_low_delay_hrd_flag"");
}
gf_bs_read_int_log(bs, 1, ""vui_ext_pic_struct_present_flag"");
}
}
}
else if ((profile_idc == 118) || (profile_idc == 128)) {
GF_LOG(GF_LOG_INFO, GF_LOG_CODING, (""[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\n""));
return sps_id;
}
if (gf_bs_read_int_log(bs, 1, ""additional_extension2"")) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\n""));
return sps_id;
}
}
return sps_id;
}","static s32 gf_avc_read_sps_bs_internal(GF_BitStream *VAR_0, AVCState *VAR_1, u32 VAR_2, u32 *VAR_3, u32 VAR_4)
{
AVC_SPS *VAR_5;
s32 VAR_6, VAR_7, VAR_8 = -1;
u32 VAR_9, VAR_10, VAR_11, VAR_12, VAR_13, VAR_14 = 0, VAR_15 = 0, VAR_16 = 0, VAR_17 = 0, VAR_18, VAR_19;
u8 VAR_20 = 0;
if (!VAR_3) {
gf_bs_enable_emulation_byte_removal(VAR_0, VAR_21);
}
if (!VAR_0) {
return -1;
}
if (!VAR_4) {
gf_bs_read_int_log(VAR_0, 1, ""forbidden_zero_bit"");
gf_bs_read_int_log(VAR_0, 2, ""nal_ref_idc"");
gf_bs_read_int_log(VAR_0, 5, ""nal_unit_type"");
}
VAR_9 = gf_bs_read_int_log(VAR_0, 8, ""profile_idc"");
VAR_11 = gf_bs_read_int_log(VAR_0, 8, ""profile_compatibility"");
if (VAR_11 & 0x3)
return -1;
VAR_10 = gf_bs_read_int_log(VAR_0, 8, ""level_idc"");
VAR_8 = gf_bs_read_ue_log(VAR_0, ""sps_id"") + VAR_22 * VAR_2;
if ((VAR_8 < 0) || (VAR_8 >= 32)) {
return -1;
}
VAR_18 = VAR_19 = 0;
VAR_5 = &VAR_1->sps[VAR_8];
VAR_13 = VAR_5->ChromaArrayType = 1;
VAR_5->state |= VAR_2 ? VAR_23 : VAR_24;
switch (VAR_9) {
case 100:
case 110:
case 122:
case 244:
case 44:
if (VAR_11 & 0xE0)
return -1;
case 83:
case 86:
case 118:
case 128:
VAR_13 = gf_bs_read_ue_log(VAR_0, ""chroma_format_idc"");
VAR_5->ChromaArrayType = VAR_13;
if (VAR_13 == 3) {
VAR_20 = gf_bs_read_int_log(VAR_0, 1, ""separate_colour_plane_flag"");
if (VAR_20) VAR_5->ChromaArrayType = 0;
}
VAR_18 = gf_bs_read_ue_log(VAR_0, ""luma_bit_depth"");
VAR_19 = gf_bs_read_ue_log(VAR_0, ""chroma_bit_depth"");
gf_bs_read_int_log(VAR_0, 1, ""qpprime_y_zero_transform_bypass_flag"");
if (gf_bs_read_int_log(VAR_0, 1, ""seq_scaling_matrix_present_flag"")) {
u32 VAR_25;
for (VAR_25 = 0; VAR_25 < 8; VAR_25++) {
if (gf_bs_read_int_log_idx(VAR_0, 1, ""seq_scaling_list_present_flag"", VAR_25)) {
u32 VAR_26, VAR_27 = 8, VAR_28 = 8;
u32 VAR_29 = VAR_25 < 6 ? 16 : 64;
for (VAR_26 = 0; VAR_26 < VAR_29; VAR_26++) {
if (VAR_28) {
s32 VAR_30 = gf_bs_read_se(VAR_0);
VAR_28 = (VAR_27 + VAR_30 + 256) % 256;
}
VAR_27 = VAR_28 ? VAR_28 : VAR_27;
}
}
}
}
break;
}
VAR_5->profile_idc = VAR_9;
VAR_5->level_idc = VAR_10;
VAR_5->prof_compat = VAR_11;
VAR_5->log2_max_frame_num = gf_bs_read_ue_log(VAR_0, ""log2_max_frame_num"") + 4;
VAR_5->poc_type = gf_bs_read_ue_log(VAR_0, ""poc_type"");
VAR_5->chroma_format = VAR_13;
VAR_5->luma_bit_depth_m8 = VAR_18;
VAR_5->chroma_bit_depth_m8 = VAR_19;
if (VAR_5->poc_type == 0) {
VAR_5->log2_max_poc_lsb = gf_bs_read_ue_log(VAR_0, ""log2_max_poc_lsb"") + 4;
}
else if (VAR_5->poc_type == 1) {
VAR_5->delta_pic_order_always_zero_flag = gf_bs_read_int_log(VAR_0, 1, ""delta_pic_order_always_zero_flag"");
VAR_5->offset_for_non_ref_pic = gf_bs_read_se_log(VAR_0, ""offset_for_non_ref_pic"");
VAR_5->offset_for_top_to_bottom_field = gf_bs_read_se_log(VAR_0, ""offset_for_top_to_bottom_field"");
VAR_5->poc_cycle_length = gf_bs_read_ue_log(VAR_0, ""poc_cycle_length"");
if (VAR_5->poc_cycle_length > GF_ARRAY_LENGTH(VAR_5->offset_for_ref_frame)) {
GF_LOG(VAR_31, VAR_32, (""[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\n""));
return -1;
}
for (VAR_12 = 0; VAR_12 < VAR_5->poc_cycle_length; VAR_12++)
VAR_5->offset_for_ref_frame[VAR_12] = gf_bs_read_se_log_idx(VAR_0, ""offset_for_ref_frame"", VAR_12);
}
if (VAR_5->poc_type > 2) {
return -1;
}
VAR_5->max_num_ref_frames = gf_bs_read_ue_log(VAR_0, ""max_num_ref_frames"");
VAR_5->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(VAR_0, 1, ""gaps_in_frame_num_value_allowed_flag"");
VAR_6 = gf_bs_read_ue_log(VAR_0, ""pic_width_in_mbs_minus1"") + 1;
VAR_7 = gf_bs_read_ue_log(VAR_0, ""pic_height_in_map_units_minus1"") + 1;
VAR_5->frame_mbs_only_flag = gf_bs_read_int_log(VAR_0, 1, ""frame_mbs_only_flag"");
VAR_5->width = VAR_6 * 16;
VAR_5->height = (2 - VAR_5->frame_mbs_only_flag) * VAR_7 * 16;
if (!VAR_5->frame_mbs_only_flag) VAR_5->mb_adaptive_frame_field_flag = gf_bs_read_int_log(VAR_0, 1, ""mb_adaptive_frame_field_flag"");
gf_bs_read_int_log(VAR_0, 1, ""direct_8x8_inference_flag"");
if (gf_bs_read_int_log(VAR_0, 1, ""frame_cropping_flag"")) {
int VAR_33, VAR_34, VAR_35 = -1, VAR_36 = -1;
if (VAR_13 == 1) {
VAR_35 = 2; VAR_36 = 2;
}
else if (VAR_13 == 2) {
VAR_35 = 2; VAR_36 = 1;
}
else if ((VAR_13 == 3) && (VAR_20 == 0)) {
VAR_35 = 1; VAR_36 = 1;
}
if (VAR_5->ChromaArrayType == 0) {
assert(VAR_35 == -1);
VAR_33 = 1;
VAR_34 = 2 - VAR_5->frame_mbs_only_flag;
}
else {
VAR_33 = VAR_35;
VAR_34 = VAR_36 * (2 - VAR_5->frame_mbs_only_flag);
}
VAR_14 = gf_bs_read_ue_log(VAR_0, ""frame_crop_left_offset"");
VAR_15 = gf_bs_read_ue_log(VAR_0, ""frame_crop_right_offset"");
VAR_16 = gf_bs_read_ue_log(VAR_0, ""frame_crop_top_offset"");
VAR_17 = gf_bs_read_ue_log(VAR_0, ""frame_crop_bottom_offset"");
VAR_5->width -= VAR_33 * (VAR_14 + VAR_15);
VAR_5->height -= VAR_34 * (VAR_16 + VAR_17);
VAR_14 *= VAR_33;
VAR_15 *= VAR_33;
VAR_16 *= VAR_34;
VAR_17 *= VAR_34;
}
VAR_5->crop.left = VAR_14;
VAR_5->crop.right = VAR_15;
VAR_5->crop.top = VAR_16;
VAR_5->crop.bottom = VAR_17;
if (VAR_3) {
*VAR_3 = (u32)gf_bs_get_bit_offset(VAR_0);
}
VAR_5->vui_parameters_present_flag = gf_bs_read_int_log(VAR_0, 1, ""vui_parameters_present_flag"");
if (VAR_5->vui_parameters_present_flag) {
VAR_5->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(VAR_0, 1, ""aspect_ratio_info_present_flag"");
if (VAR_5->vui.aspect_ratio_info_present_flag) {
s32 VAR_37 = gf_bs_read_int_log(VAR_0, 8, ""aspect_ratio_idc"");
if (VAR_37 == 255) {
VAR_5->vui.par_num = gf_bs_read_int_log(VAR_0, 16, ""aspect_ratio_num"");
VAR_5->vui.par_den = gf_bs_read_int_log(VAR_0, 16, ""aspect_ratio_den"");
}
else if (VAR_37 < GF_ARRAY_LENGTH(VAR_38) ) {
VAR_5->vui.par_num = VAR_38[VAR_37].w;
VAR_5->vui.par_den = VAR_38[VAR_37].h;
}
else {
GF_LOG(VAR_39, VAR_32, (""[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\n""));
}
}
VAR_5->vui.overscan_info_present_flag = gf_bs_read_int_log(VAR_0, 1, ""overscan_info_present_flag"");
if (VAR_5->vui.overscan_info_present_flag)
gf_bs_read_int_log(VAR_0, 1, ""overscan_appropriate_flag"");
VAR_5->vui.video_format = 5;
VAR_5->vui.colour_primaries = 2;
VAR_5->vui.transfer_characteristics = 2;
VAR_5->vui.matrix_coefficients = 2;
VAR_5->vui.video_signal_type_present_flag = gf_bs_read_int_log(VAR_0, 1, ""video_signal_type_present_flag"");
if (VAR_5->vui.video_signal_type_present_flag) {
VAR_5->vui.video_format = gf_bs_read_int_log(VAR_0, 3, ""video_format"");
VAR_5->vui.video_full_range_flag = gf_bs_read_int_log(VAR_0, 1, ""video_full_range_flag"");
VAR_5->vui.colour_description_present_flag = gf_bs_read_int_log(VAR_0, 1, ""colour_description_present_flag"");
if (VAR_5->vui.colour_description_present_flag) {
VAR_5->vui.colour_primaries = gf_bs_read_int_log(VAR_0, 8, ""colour_primaries"");
VAR_5->vui.transfer_characteristics = gf_bs_read_int_log(VAR_0, 8, ""transfer_characteristics"");
VAR_5->vui.matrix_coefficients = gf_bs_read_int_log(VAR_0, 8, ""matrix_coefficients"");
}
}
if (gf_bs_read_int_log(VAR_0, 1, ""chroma_location_info_present_flag"")) {
gf_bs_read_ue_log(VAR_0, ""chroma_sample_location_type_top_field"");
gf_bs_read_ue_log(VAR_0, ""chroma_sample_location_type_bottom_field"");
}
VAR_5->vui.timing_info_present_flag = gf_bs_read_int_log(VAR_0, 1, ""timing_info_present_flag"");
if (VAR_5->vui.timing_info_present_flag) {
VAR_5->vui.num_units_in_tick = gf_bs_read_int_log(VAR_0, 32, ""num_units_in_tick"");
VAR_5->vui.time_scale = gf_bs_read_int_log(VAR_0, 32, ""time_scale"");
VAR_5->vui.fixed_frame_rate_flag = gf_bs_read_int_log(VAR_0, 1, ""fixed_frame_rate_flag"");
}
VAR_5->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(VAR_0, 1, ""nal_hrd_parameters_present_flag"");
if (VAR_5->vui.nal_hrd_parameters_present_flag)
avc_parse_hrd_parameters(VAR_0, &VAR_5->vui.hrd);
VAR_5->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(VAR_0, 1, ""vcl_hrd_parameters_present_flag"");
if (VAR_5->vui.vcl_hrd_parameters_present_flag)
avc_parse_hrd_parameters(VAR_0, &VAR_5->vui.hrd);
if (VAR_5->vui.nal_hrd_parameters_present_flag || VAR_5->vui.vcl_hrd_parameters_present_flag)
VAR_5->vui.low_delay_hrd_flag = gf_bs_read_int_log(VAR_0, 1, ""low_delay_hrd_flag"");
VAR_5->vui.pic_struct_present_flag = gf_bs_read_int_log(VAR_0, 1, ""pic_struct_present_flag"");
}
if (VAR_2) {
if ((VAR_9 == 83) || (VAR_9 == 86)) {
u8 VAR_40;
gf_bs_read_int_log(VAR_0, 1, ""inter_layer_deblocking_filter_control_present_flag"");
VAR_40 = gf_bs_read_int_log(VAR_0, 2, ""extended_spatial_scalability_idc"");
if (VAR_5->ChromaArrayType == 1 || VAR_5->ChromaArrayType == 2) {
gf_bs_read_int_log(VAR_0, 1, ""chroma_phase_x_plus1_flag"");
}
if (VAR_5->ChromaArrayType == 1) {
gf_bs_read_int_log(VAR_0, 2, ""chroma_phase_y_plus1"");
}
if (VAR_40 == 1) {
if (VAR_5->ChromaArrayType > 0) {
gf_bs_read_int_log(VAR_0, 1, ""seq_ref_layer_chroma_phase_x_plus1_flag"");
gf_bs_read_int_log(VAR_0, 2, ""seq_ref_layer_chroma_phase_y_plus1"");
}
gf_bs_read_se_log(VAR_0, ""seq_scaled_ref_layer_left_offset"");
gf_bs_read_se_log(VAR_0, ""seq_scaled_ref_layer_top_offset"");
gf_bs_read_se_log(VAR_0, ""seq_scaled_ref_layer_right_offset"");
gf_bs_read_se_log(VAR_0, ""seq_scaled_ref_layer_bottom_offset"");
}
if (gf_bs_read_int_log(VAR_0, 1, ""seq_tcoeff_level_prediction_flag"")) {
gf_bs_read_int_log(VAR_0, 1, ""adaptive_tcoeff_level_prediction_flag"");
}
gf_bs_read_int_log(VAR_0, 1, ""slice_header_restriction_flag"");
if (gf_bs_read_int_log(VAR_0, 1, ""svc_vui_parameters_present"")) {
u32 VAR_41 = gf_bs_read_ue_log(VAR_0, ""vui_ext_num_entries_minus1"");
for (VAR_12 = 0; VAR_12 <= VAR_41; VAR_12++) {
u8 VAR_42, VAR_43, VAR_44;
gf_bs_read_int_log(VAR_0, 3, ""vui_ext_dependency_id"");
gf_bs_read_int_log(VAR_0, 4, ""vui_ext_quality_id"");
gf_bs_read_int_log(VAR_0, 3, ""vui_ext_temporal_id"");
VAR_44 = gf_bs_read_int_log(VAR_0, 1, ""vui_ext_timing_info_present_flag"");
if (VAR_44) {
gf_bs_read_int_log(VAR_0, 32, ""vui_ext_num_units_in_tick"");
gf_bs_read_int_log(VAR_0, 32, ""vui_ext_time_scale"");
gf_bs_read_int_log(VAR_0, 1, ""vui_ext_fixed_frame_rate_flag"");
}
VAR_42 = gf_bs_read_int_log(VAR_0, 1, ""vui_ext_nal_hrd_parameters_present_flag"");
if (VAR_42) {
}
VAR_43 = gf_bs_read_int_log(VAR_0, 1, ""vui_ext_vcl_hrd_parameters_present_flag"");
if (VAR_43) {
}
if (VAR_42 || VAR_43) {
gf_bs_read_int_log(VAR_0, 1, ""vui_ext_low_delay_hrd_flag"");
}
gf_bs_read_int_log(VAR_0, 1, ""vui_ext_pic_struct_present_flag"");
}
}
}
else if ((VAR_9 == 118) || (VAR_9 == 128)) {
GF_LOG(VAR_45, VAR_32, (""[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\n""));
return VAR_8;
}
if (gf_bs_read_int_log(VAR_0, 1, ""additional_extension2"")) {
GF_LOG(VAR_39, VAR_32, (""[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\n""));
return VAR_8;
}
}
return VAR_8;
}",gpac/04dbf08bff4d61948bab80c3f9096ecc60c7f302/av_parsers.c/vul/before/0.json,"static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)
{
	AVC_SPS *sps;
	s32 mb_width, mb_height, sps_id = -1;
	u32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;
	u8 separate_colour_plane_flag = 0;

	if (!vui_flag_pos) {
		gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);
	}

	if (!bs) {
		return -1;
	}

	if (!nal_hdr) {
		gf_bs_read_int_log(bs, 1, ""forbidden_zero_bit"");
		gf_bs_read_int_log(bs, 2, ""nal_ref_idc"");
		gf_bs_read_int_log(bs, 5, ""nal_unit_type"");
	}
	profile_idc = gf_bs_read_int_log(bs, 8, ""profile_idc"");

	pcomp = gf_bs_read_int_log(bs, 8, ""profile_compatibility"");
	/*sanity checks*/
	if (pcomp & 0x3)
		return -1;

	level_idc = gf_bs_read_int_log(bs, 8, ""level_idc"");

	/*SubsetSps is used to be sure that AVC SPS are not going to be scratched
	by subset SPS. According to the SVC standard, subset SPS can have the same sps_id
	than its base layer, but it does not refer to the same SPS. */
	sps_id = gf_bs_read_ue_log(bs, ""sps_id"") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;
	if ((sps_id < 0) || (sps_id >= 32)) {
		return -1;
	}

	luma_bd = chroma_bd = 0;
	sps = &avc->sps[sps_id];
	chroma_format_idc = sps->ChromaArrayType = 1;
	sps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;

	/*High Profile and SVC*/
	switch (profile_idc) {
	case 100:
	case 110:
	case 122:
	case 244:
	case 44:
		/*sanity checks: note1 from 7.4.2.1.1 of iso/iec 14496-10-N11084*/
		if (pcomp & 0xE0)
			return -1;
	case 83:
	case 86:
	case 118:
	case 128:
		chroma_format_idc = gf_bs_read_ue_log(bs, ""chroma_format_idc"");
		sps->ChromaArrayType = chroma_format_idc;
		if (chroma_format_idc == 3) {
			separate_colour_plane_flag = gf_bs_read_int_log(bs, 1, ""separate_colour_plane_flag"");
			/*
			Depending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows.
			\96	If separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.
			\96	Otherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.
			*/
			if (separate_colour_plane_flag) sps->ChromaArrayType = 0;
		}
		luma_bd = gf_bs_read_ue_log(bs, ""luma_bit_depth"");
		chroma_bd = gf_bs_read_ue_log(bs, ""chroma_bit_depth"");
		/*qpprime_y_zero_transform_bypass_flag = */ gf_bs_read_int_log(bs, 1, ""qpprime_y_zero_transform_bypass_flag"");
		/*seq_scaling_matrix_present_flag*/
		if (gf_bs_read_int_log(bs, 1, ""seq_scaling_matrix_present_flag"")) {
			u32 k;
			for (k = 0; k < 8; k++) {
				if (gf_bs_read_int_log_idx(bs, 1, ""seq_scaling_list_present_flag"", k)) {
					u32 z, last = 8, next = 8;
					u32 sl = k < 6 ? 16 : 64;
					for (z = 0; z < sl; z++) {
						if (next) {
							s32 delta = gf_bs_read_se(bs);
							next = (last + delta + 256) % 256;
						}
						last = next ? next : last;
					}
				}
			}
		}
		break;
	}

	sps->profile_idc = profile_idc;
	sps->level_idc = level_idc;
	sps->prof_compat = pcomp;
	sps->log2_max_frame_num = gf_bs_read_ue_log(bs, ""log2_max_frame_num"") + 4;
	sps->poc_type = gf_bs_read_ue_log(bs, ""poc_type"");
	sps->chroma_format = chroma_format_idc;
	sps->luma_bit_depth_m8 = luma_bd;
	sps->chroma_bit_depth_m8 = chroma_bd;

	if (sps->poc_type == 0) {
		sps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, ""log2_max_poc_lsb"") + 4;
	}
	else if (sps->poc_type == 1) {
		sps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, ""delta_pic_order_always_zero_flag"");
		sps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, ""offset_for_non_ref_pic"");
		sps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, ""offset_for_top_to_bottom_field"");
		sps->poc_cycle_length = gf_bs_read_ue_log(bs, ""poc_cycle_length"");
		if (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {
			sps->poc_cycle_length = 255;
			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\n""));
			return -1;
		}
		for (i = 0; i < sps->poc_cycle_length; i++)
			sps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, ""offset_for_ref_frame"", i);
	}
	if (sps->poc_type > 2) {
		return -1;
	}
	sps->max_num_ref_frames = gf_bs_read_ue_log(bs, ""max_num_ref_frames"");
	sps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, ""gaps_in_frame_num_value_allowed_flag"");
	mb_width = gf_bs_read_ue_log(bs, ""pic_width_in_mbs_minus1"") + 1;
	mb_height = gf_bs_read_ue_log(bs, ""pic_height_in_map_units_minus1"") + 1;

	sps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, ""frame_mbs_only_flag"");

	sps->width = mb_width * 16;
	sps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;

	if (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, ""mb_adaptive_frame_field_flag"");
	gf_bs_read_int_log(bs, 1, ""direct_8x8_inference_flag"");

	if (gf_bs_read_int_log(bs, 1, ""frame_cropping_flag"")) {
		int CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;

		if (chroma_format_idc == 1) {
			SubWidthC = 2; SubHeightC = 2;
		}
		else if (chroma_format_idc == 2) {
			SubWidthC = 2; SubHeightC = 1;
		}
		else if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {
			SubWidthC = 1; SubHeightC = 1;
		}

		if (sps->ChromaArrayType == 0) {
			assert(SubWidthC == -1);
			CropUnitX = 1;
			CropUnitY = 2 - sps->frame_mbs_only_flag;
		}
		else {
			CropUnitX = SubWidthC;
			CropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);
		}

		cl = gf_bs_read_ue_log(bs, ""frame_crop_left_offset"");
		cr = gf_bs_read_ue_log(bs, ""frame_crop_right_offset"");
		ct = gf_bs_read_ue_log(bs, ""frame_crop_top_offset"");
		cb = gf_bs_read_ue_log(bs, ""frame_crop_bottom_offset"");

		sps->width -= CropUnitX * (cl + cr);
		sps->height -= CropUnitY * (ct + cb);
		cl *= CropUnitX;
		cr *= CropUnitX;
		ct *= CropUnitY;
		cb *= CropUnitY;
	}
	sps->crop.left = cl;
	sps->crop.right = cr;
	sps->crop.top = ct;
	sps->crop.bottom = cb;

	if (vui_flag_pos) {
		*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);
	}
	/*vui_parameters_present_flag*/
	sps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_parameters_present_flag"");
	if (sps->vui_parameters_present_flag) {
		sps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, ""aspect_ratio_info_present_flag"");
		if (sps->vui.aspect_ratio_info_present_flag) {
			s32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, ""aspect_ratio_idc"");
			if (aspect_ratio_idc == 255) {
				sps->vui.par_num = gf_bs_read_int_log(bs, 16, ""aspect_ratio_num"");
				sps->vui.par_den = gf_bs_read_int_log(bs, 16, ""aspect_ratio_den"");
			}
			else if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {
				sps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;
				sps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;
			}
			else {
				GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\n""));
			}
		}
		sps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, ""overscan_info_present_flag"");
		if (sps->vui.overscan_info_present_flag)
			gf_bs_read_int_log(bs, 1, ""overscan_appropriate_flag"");

		/* default values */
		sps->vui.video_format = 5;
		sps->vui.colour_primaries = 2;
		sps->vui.transfer_characteristics = 2;
		sps->vui.matrix_coefficients = 2;
		/* now read values if possible */
		sps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, ""video_signal_type_present_flag"");
		if (sps->vui.video_signal_type_present_flag) {
			sps->vui.video_format = gf_bs_read_int_log(bs, 3, ""video_format"");
			sps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, ""video_full_range_flag"");
			sps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, ""colour_description_present_flag"");
			if (sps->vui.colour_description_present_flag) {
				sps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, ""colour_primaries"");
				sps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, ""transfer_characteristics"");
				sps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, ""matrix_coefficients"");
			}
		}

		if (gf_bs_read_int_log(bs, 1, ""chroma_location_info_present_flag"")) {
			gf_bs_read_ue_log(bs, ""chroma_sample_location_type_top_field"");
			gf_bs_read_ue_log(bs, ""chroma_sample_location_type_bottom_field"");
		}

		sps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, ""timing_info_present_flag"");
		if (sps->vui.timing_info_present_flag) {
			sps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, ""num_units_in_tick"");
			sps->vui.time_scale = gf_bs_read_int_log(bs, 32, ""time_scale"");
			sps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, ""fixed_frame_rate_flag"");
		}

		sps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""nal_hrd_parameters_present_flag"");
		if (sps->vui.nal_hrd_parameters_present_flag)
			avc_parse_hrd_parameters(bs, &sps->vui.hrd);

		sps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vcl_hrd_parameters_present_flag"");
		if (sps->vui.vcl_hrd_parameters_present_flag)
			avc_parse_hrd_parameters(bs, &sps->vui.hrd);

		if (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)
			sps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, ""low_delay_hrd_flag"");

		sps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, ""pic_struct_present_flag"");
	}
	/*end of seq_parameter_set_data*/

	if (subseq_sps) {
		if ((profile_idc == 83) || (profile_idc == 86)) {
			u8 extended_spatial_scalability_idc;
			/*parsing seq_parameter_set_svc_extension*/

			gf_bs_read_int_log(bs, 1, ""inter_layer_deblocking_filter_control_present_flag"");
			extended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, ""extended_spatial_scalability_idc"");
			if (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {
				gf_bs_read_int_log(bs, 1, ""chroma_phase_x_plus1_flag"");
			}
			if (sps->ChromaArrayType == 1) {
				gf_bs_read_int_log(bs, 2, ""chroma_phase_y_plus1"");
			}
			if (extended_spatial_scalability_idc == 1) {
				if (sps->ChromaArrayType > 0) {
					gf_bs_read_int_log(bs, 1, ""seq_ref_layer_chroma_phase_x_plus1_flag"");
					gf_bs_read_int_log(bs, 2, ""seq_ref_layer_chroma_phase_y_plus1"");
				}
				gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_left_offset"");
				gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_top_offset"");
				gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_right_offset"");
				gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_bottom_offset"");
			}
			if (gf_bs_read_int_log(bs, 1, ""seq_tcoeff_level_prediction_flag"")) {
				gf_bs_read_int_log(bs, 1, ""adaptive_tcoeff_level_prediction_flag"");
			}
			gf_bs_read_int_log(bs, 1, ""slice_header_restriction_flag"");

			if (gf_bs_read_int_log(bs, 1, ""svc_vui_parameters_present"")) {
				u32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, ""vui_ext_num_entries_minus1"");

				for (i = 0; i <= vui_ext_num_entries_minus1; i++) {
					u8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;
					gf_bs_read_int_log(bs, 3, ""vui_ext_dependency_id"");
					gf_bs_read_int_log(bs, 4, ""vui_ext_quality_id"");
					gf_bs_read_int_log(bs, 3, ""vui_ext_temporal_id"");
					vui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_timing_info_present_flag"");
					if (vui_ext_timing_info_present_flag) {
						gf_bs_read_int_log(bs, 32, ""vui_ext_num_units_in_tick"");
						gf_bs_read_int_log(bs, 32, ""vui_ext_time_scale"");
						gf_bs_read_int_log(bs, 1, ""vui_ext_fixed_frame_rate_flag"");
					}
					vui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_nal_hrd_parameters_present_flag"");
					if (vui_ext_nal_hrd_parameters_present_flag) {
						//hrd_parameters( )
					}
					vui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_vcl_hrd_parameters_present_flag"");
					if (vui_ext_vcl_hrd_parameters_present_flag) {
						//hrd_parameters( )
					}
					if (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {
						gf_bs_read_int_log(bs, 1, ""vui_ext_low_delay_hrd_flag"");
					}
					gf_bs_read_int_log(bs, 1, ""vui_ext_pic_struct_present_flag"");
				}
			}
		}
		else if ((profile_idc == 118) || (profile_idc == 128)) {
			GF_LOG(GF_LOG_INFO, GF_LOG_CODING, (""[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\n""));
			return sps_id;
		}

		if (gf_bs_read_int_log(bs, 1, ""additional_extension2"")) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\n""));
			return sps_id;
		}
	}
	return sps_id;
}","static s32 gf_avc_read_sps_bs_internal(GF_BitStream *VAR_0, AVCState *VAR_1, u32 VAR_2, u32 *VAR_3, u32 VAR_4)
{
	AVC_SPS *VAR_5;
	s32 VAR_6, VAR_7, VAR_8 = -1;
	u32 VAR_9, VAR_10, VAR_11, VAR_12, VAR_13, VAR_14 = 0, VAR_15 = 0, VAR_16 = 0, VAR_17 = 0, VAR_18, VAR_19;
	u8 VAR_20 = 0;

	if (!VAR_3) {
		gf_bs_enable_emulation_byte_removal(VAR_0, VAR_21);
	}

	if (!VAR_0) {
		return -1;
	}

	if (!VAR_4) {
		gf_bs_read_int_log(VAR_0, 1, ""forbidden_zero_bit"");
		gf_bs_read_int_log(VAR_0, 2, ""nal_ref_idc"");
		gf_bs_read_int_log(VAR_0, 5, ""nal_unit_type"");
	}
	VAR_9 = gf_bs_read_int_log(VAR_0, 8, ""profile_idc"");

	VAR_11 = gf_bs_read_int_log(VAR_0, 8, ""profile_compatibility"");
	/* COMMENT_0 */
	if (VAR_11 & 0x3)
		return -1;

	VAR_10 = gf_bs_read_int_log(VAR_0, 8, ""level_idc"");

	/* COMMENT_1 */
                                                                                  
                                                               
	VAR_8 = gf_bs_read_ue_log(VAR_0, ""sps_id"") + VAR_22 * VAR_2;
	if ((VAR_8 < 0) || (VAR_8 >= 32)) {
		return -1;
	}

	VAR_18 = VAR_19 = 0;
	VAR_5 = &VAR_1->sps[VAR_8];
	VAR_13 = VAR_5->ChromaArrayType = 1;
	VAR_5->state |= VAR_2 ? VAR_23 : VAR_24;

	/* COMMENT_4 */
	switch (VAR_9) {
	case 100:
	case 110:
	case 122:
	case 244:
	case 44:
		/* COMMENT_5 */
		if (VAR_11 & 0xE0)
			return -1;
	case 83:
	case 86:
	case 118:
	case 128:
		VAR_13 = gf_bs_read_ue_log(VAR_0, ""chroma_format_idc"");
		VAR_5->ChromaArrayType = VAR_13;
		if (VAR_13 == 3) {
			VAR_20 = gf_bs_read_int_log(VAR_0, 1, ""separate_colour_plane_flag"");
			/* COMMENT_6 */
                                                                                                                          
                                                                                                      
                                                                                               
     
			if (VAR_20) VAR_5->ChromaArrayType = 0;
		}
		VAR_18 = gf_bs_read_ue_log(VAR_0, ""luma_bit_depth"");
		VAR_19 = gf_bs_read_ue_log(VAR_0, ""chroma_bit_depth"");
		/* COMMENT_11 */ gf_bs_read_int_log(VAR_0, 1, ""qpprime_y_zero_transform_bypass_flag"");
		/* COMMENT_12 */
		if (gf_bs_read_int_log(VAR_0, 1, ""seq_scaling_matrix_present_flag"")) {
			u32 VAR_25;
			for (VAR_25 = 0; VAR_25 < 8; VAR_25++) {
				if (gf_bs_read_int_log_idx(VAR_0, 1, ""seq_scaling_list_present_flag"", VAR_25)) {
					u32 VAR_26, VAR_27 = 8, VAR_28 = 8;
					u32 VAR_29 = VAR_25 < 6 ? 16 : 64;
					for (VAR_26 = 0; VAR_26 < VAR_29; VAR_26++) {
						if (VAR_28) {
							s32 VAR_30 = gf_bs_read_se(VAR_0);
							VAR_28 = (VAR_27 + VAR_30 + 256) % 256;
						}
						VAR_27 = VAR_28 ? VAR_28 : VAR_27;
					}
				}
			}
		}
		break;
	}

	VAR_5->profile_idc = VAR_9;
	VAR_5->level_idc = VAR_10;
	VAR_5->prof_compat = VAR_11;
	VAR_5->log2_max_frame_num = gf_bs_read_ue_log(VAR_0, ""log2_max_frame_num"") + 4;
	VAR_5->poc_type = gf_bs_read_ue_log(VAR_0, ""poc_type"");
	VAR_5->chroma_format = VAR_13;
	VAR_5->luma_bit_depth_m8 = VAR_18;
	VAR_5->chroma_bit_depth_m8 = VAR_19;

	if (VAR_5->poc_type == 0) {
		VAR_5->log2_max_poc_lsb = gf_bs_read_ue_log(VAR_0, ""log2_max_poc_lsb"") + 4;
	}
	else if (VAR_5->poc_type == 1) {
		VAR_5->delta_pic_order_always_zero_flag = gf_bs_read_int_log(VAR_0, 1, ""delta_pic_order_always_zero_flag"");
		VAR_5->offset_for_non_ref_pic = gf_bs_read_se_log(VAR_0, ""offset_for_non_ref_pic"");
		VAR_5->offset_for_top_to_bottom_field = gf_bs_read_se_log(VAR_0, ""offset_for_top_to_bottom_field"");
		VAR_5->poc_cycle_length = gf_bs_read_ue_log(VAR_0, ""poc_cycle_length"");
		if (VAR_5->poc_cycle_length > GF_ARRAY_LENGTH(VAR_5->offset_for_ref_frame)) {
			VAR_5->poc_cycle_length = 255;
			GF_LOG(VAR_31, VAR_32, (""[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\n""));
			return -1;
		}
		for (VAR_12 = 0; VAR_12 < VAR_5->poc_cycle_length; VAR_12++)
			VAR_5->offset_for_ref_frame[VAR_12] = gf_bs_read_se_log_idx(VAR_0, ""offset_for_ref_frame"", VAR_12);
	}
	if (VAR_5->poc_type > 2) {
		return -1;
	}
	VAR_5->max_num_ref_frames = gf_bs_read_ue_log(VAR_0, ""max_num_ref_frames"");
	VAR_5->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(VAR_0, 1, ""gaps_in_frame_num_value_allowed_flag"");
	VAR_6 = gf_bs_read_ue_log(VAR_0, ""pic_width_in_mbs_minus1"") + 1;
	VAR_7 = gf_bs_read_ue_log(VAR_0, ""pic_height_in_map_units_minus1"") + 1;

	VAR_5->frame_mbs_only_flag = gf_bs_read_int_log(VAR_0, 1, ""frame_mbs_only_flag"");

	VAR_5->width = VAR_6 * 16;
	VAR_5->height = (2 - VAR_5->frame_mbs_only_flag) * VAR_7 * 16;

	if (!VAR_5->frame_mbs_only_flag) VAR_5->mb_adaptive_frame_field_flag = gf_bs_read_int_log(VAR_0, 1, ""mb_adaptive_frame_field_flag"");
	gf_bs_read_int_log(VAR_0, 1, ""direct_8x8_inference_flag"");

	if (gf_bs_read_int_log(VAR_0, 1, ""frame_cropping_flag"")) {
		int VAR_33, VAR_34, VAR_35 = -1, VAR_36 = -1;

		if (VAR_13 == 1) {
			VAR_35 = 2; VAR_36 = 2;
		}
		else if (VAR_13 == 2) {
			VAR_35 = 2; VAR_36 = 1;
		}
		else if ((VAR_13 == 3) && (VAR_20 == 0)) {
			VAR_35 = 1; VAR_36 = 1;
		}

		if (VAR_5->ChromaArrayType == 0) {
			assert(VAR_35 == -1);
			VAR_33 = 1;
			VAR_34 = 2 - VAR_5->frame_mbs_only_flag;
		}
		else {
			VAR_33 = VAR_35;
			VAR_34 = VAR_36 * (2 - VAR_5->frame_mbs_only_flag);
		}

		VAR_14 = gf_bs_read_ue_log(VAR_0, ""frame_crop_left_offset"");
		VAR_15 = gf_bs_read_ue_log(VAR_0, ""frame_crop_right_offset"");
		VAR_16 = gf_bs_read_ue_log(VAR_0, ""frame_crop_top_offset"");
		VAR_17 = gf_bs_read_ue_log(VAR_0, ""frame_crop_bottom_offset"");

		VAR_5->width -= VAR_33 * (VAR_14 + VAR_15);
		VAR_5->height -= VAR_34 * (VAR_16 + VAR_17);
		VAR_14 *= VAR_33;
		VAR_15 *= VAR_33;
		VAR_16 *= VAR_34;
		VAR_17 *= VAR_34;
	}
	VAR_5->crop.left = VAR_14;
	VAR_5->crop.right = VAR_15;
	VAR_5->crop.top = VAR_16;
	VAR_5->crop.bottom = VAR_17;

	if (VAR_3) {
		*VAR_3 = (u32)gf_bs_get_bit_offset(VAR_0);
	}
	/* COMMENT_13 */
	VAR_5->vui_parameters_present_flag = gf_bs_read_int_log(VAR_0, 1, ""vui_parameters_present_flag"");
	if (VAR_5->vui_parameters_present_flag) {
		VAR_5->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(VAR_0, 1, ""aspect_ratio_info_present_flag"");
		if (VAR_5->vui.aspect_ratio_info_present_flag) {
			s32 VAR_37 = gf_bs_read_int_log(VAR_0, 8, ""aspect_ratio_idc"");
			if (VAR_37 == 255) {
				VAR_5->vui.par_num = gf_bs_read_int_log(VAR_0, 16, ""aspect_ratio_num"");
				VAR_5->vui.par_den = gf_bs_read_int_log(VAR_0, 16, ""aspect_ratio_den"");
			}
			else if (VAR_37 < GF_ARRAY_LENGTH(VAR_38) ) {
				VAR_5->vui.par_num = VAR_38[VAR_37].w;
				VAR_5->vui.par_den = VAR_38[VAR_37].h;
			}
			else {
				GF_LOG(VAR_39, VAR_32, (""[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\n""));
			}
		}
		VAR_5->vui.overscan_info_present_flag = gf_bs_read_int_log(VAR_0, 1, ""overscan_info_present_flag"");
		if (VAR_5->vui.overscan_info_present_flag)
			gf_bs_read_int_log(VAR_0, 1, ""overscan_appropriate_flag"");

		/* COMMENT_14 */
		VAR_5->vui.video_format = 5;
		VAR_5->vui.colour_primaries = 2;
		VAR_5->vui.transfer_characteristics = 2;
		VAR_5->vui.matrix_coefficients = 2;
		/* COMMENT_15 */
		VAR_5->vui.video_signal_type_present_flag = gf_bs_read_int_log(VAR_0, 1, ""video_signal_type_present_flag"");
		if (VAR_5->vui.video_signal_type_present_flag) {
			VAR_5->vui.video_format = gf_bs_read_int_log(VAR_0, 3, ""video_format"");
			VAR_5->vui.video_full_range_flag = gf_bs_read_int_log(VAR_0, 1, ""video_full_range_flag"");
			VAR_5->vui.colour_description_present_flag = gf_bs_read_int_log(VAR_0, 1, ""colour_description_present_flag"");
			if (VAR_5->vui.colour_description_present_flag) {
				VAR_5->vui.colour_primaries = gf_bs_read_int_log(VAR_0, 8, ""colour_primaries"");
				VAR_5->vui.transfer_characteristics = gf_bs_read_int_log(VAR_0, 8, ""transfer_characteristics"");
				VAR_5->vui.matrix_coefficients = gf_bs_read_int_log(VAR_0, 8, ""matrix_coefficients"");
			}
		}

		if (gf_bs_read_int_log(VAR_0, 1, ""chroma_location_info_present_flag"")) {
			gf_bs_read_ue_log(VAR_0, ""chroma_sample_location_type_top_field"");
			gf_bs_read_ue_log(VAR_0, ""chroma_sample_location_type_bottom_field"");
		}

		VAR_5->vui.timing_info_present_flag = gf_bs_read_int_log(VAR_0, 1, ""timing_info_present_flag"");
		if (VAR_5->vui.timing_info_present_flag) {
			VAR_5->vui.num_units_in_tick = gf_bs_read_int_log(VAR_0, 32, ""num_units_in_tick"");
			VAR_5->vui.time_scale = gf_bs_read_int_log(VAR_0, 32, ""time_scale"");
			VAR_5->vui.fixed_frame_rate_flag = gf_bs_read_int_log(VAR_0, 1, ""fixed_frame_rate_flag"");
		}

		VAR_5->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(VAR_0, 1, ""nal_hrd_parameters_present_flag"");
		if (VAR_5->vui.nal_hrd_parameters_present_flag)
			avc_parse_hrd_parameters(VAR_0, &VAR_5->vui.hrd);

		VAR_5->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(VAR_0, 1, ""vcl_hrd_parameters_present_flag"");
		if (VAR_5->vui.vcl_hrd_parameters_present_flag)
			avc_parse_hrd_parameters(VAR_0, &VAR_5->vui.hrd);

		if (VAR_5->vui.nal_hrd_parameters_present_flag || VAR_5->vui.vcl_hrd_parameters_present_flag)
			VAR_5->vui.low_delay_hrd_flag = gf_bs_read_int_log(VAR_0, 1, ""low_delay_hrd_flag"");

		VAR_5->vui.pic_struct_present_flag = gf_bs_read_int_log(VAR_0, 1, ""pic_struct_present_flag"");
	}
	/* COMMENT_16 */

	if (VAR_2) {
		if ((VAR_9 == 83) || (VAR_9 == 86)) {
			u8 VAR_40;
			/* COMMENT_17 */

			gf_bs_read_int_log(VAR_0, 1, ""inter_layer_deblocking_filter_control_present_flag"");
			VAR_40 = gf_bs_read_int_log(VAR_0, 2, ""extended_spatial_scalability_idc"");
			if (VAR_5->ChromaArrayType == 1 || VAR_5->ChromaArrayType == 2) {
				gf_bs_read_int_log(VAR_0, 1, ""chroma_phase_x_plus1_flag"");
			}
			if (VAR_5->ChromaArrayType == 1) {
				gf_bs_read_int_log(VAR_0, 2, ""chroma_phase_y_plus1"");
			}
			if (VAR_40 == 1) {
				if (VAR_5->ChromaArrayType > 0) {
					gf_bs_read_int_log(VAR_0, 1, ""seq_ref_layer_chroma_phase_x_plus1_flag"");
					gf_bs_read_int_log(VAR_0, 2, ""seq_ref_layer_chroma_phase_y_plus1"");
				}
				gf_bs_read_se_log(VAR_0, ""seq_scaled_ref_layer_left_offset"");
				gf_bs_read_se_log(VAR_0, ""seq_scaled_ref_layer_top_offset"");
				gf_bs_read_se_log(VAR_0, ""seq_scaled_ref_layer_right_offset"");
				gf_bs_read_se_log(VAR_0, ""seq_scaled_ref_layer_bottom_offset"");
			}
			if (gf_bs_read_int_log(VAR_0, 1, ""seq_tcoeff_level_prediction_flag"")) {
				gf_bs_read_int_log(VAR_0, 1, ""adaptive_tcoeff_level_prediction_flag"");
			}
			gf_bs_read_int_log(VAR_0, 1, ""slice_header_restriction_flag"");

			if (gf_bs_read_int_log(VAR_0, 1, ""svc_vui_parameters_present"")) {
				u32 VAR_41 = gf_bs_read_ue_log(VAR_0, ""vui_ext_num_entries_minus1"");

				for (VAR_12 = 0; VAR_12 <= VAR_41; VAR_12++) {
					u8 VAR_42, VAR_43, VAR_44;
					gf_bs_read_int_log(VAR_0, 3, ""vui_ext_dependency_id"");
					gf_bs_read_int_log(VAR_0, 4, ""vui_ext_quality_id"");
					gf_bs_read_int_log(VAR_0, 3, ""vui_ext_temporal_id"");
					VAR_44 = gf_bs_read_int_log(VAR_0, 1, ""vui_ext_timing_info_present_flag"");
					if (VAR_44) {
						gf_bs_read_int_log(VAR_0, 32, ""vui_ext_num_units_in_tick"");
						gf_bs_read_int_log(VAR_0, 32, ""vui_ext_time_scale"");
						gf_bs_read_int_log(VAR_0, 1, ""vui_ext_fixed_frame_rate_flag"");
					}
					VAR_42 = gf_bs_read_int_log(VAR_0, 1, ""vui_ext_nal_hrd_parameters_present_flag"");
					if (VAR_42) {
						/* COMMENT_18 */
					}
					VAR_43 = gf_bs_read_int_log(VAR_0, 1, ""vui_ext_vcl_hrd_parameters_present_flag"");
					if (VAR_43) {
						/* COMMENT_18 */
					}
					if (VAR_42 || VAR_43) {
						gf_bs_read_int_log(VAR_0, 1, ""vui_ext_low_delay_hrd_flag"");
					}
					gf_bs_read_int_log(VAR_0, 1, ""vui_ext_pic_struct_present_flag"");
				}
			}
		}
		else if ((VAR_9 == 118) || (VAR_9 == 128)) {
			GF_LOG(VAR_45, VAR_32, (""[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\n""));
			return VAR_8;
		}

		if (gf_bs_read_int_log(VAR_0, 1, ""additional_extension2"")) {
			GF_LOG(VAR_39, VAR_32, (""[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\n""));
			return VAR_8;
		}
	}
	return VAR_8;
}",gpac/04dbf08bff4d61948bab80c3f9096ecc60c7f302/av_parsers.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -106,6 +106,7 @@
 		sps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, ""offset_for_top_to_bottom_field"");
 		sps->poc_cycle_length = gf_bs_read_ue_log(bs, ""poc_cycle_length"");
 		if (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {
+			sps->poc_cycle_length = 255;
 			GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\n""));
 			return -1;
 		}","{'deleted_lines': [], 'added_lines': ['\t\t\tsps->poc_cycle_length = 255;']}",True,"The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the avc_compute_poc function in av_parsers.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.",7.8,HIGH,2,valid,2021-08-30T15:15:34Z,3
CVE-2021-3796,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,vim,"patch 8.2.3428: using freed memory when replacing

Problem:    Using freed memory when replacing. (Dhiraj Mishra)
Solution:   Get the line pointer after calling ins_copychar().",35a9a00afcb20897d462a766793ff45534810dc3,https://github.com/vim/vim/commit/35a9a00afcb20897d462a766793ff45534810dc3,src/normal.c,nv_replace,"static void
nv_replace(cmdarg_T *cap)
{
char_u*ptr;
inthad_ctrl_v;
longn;
if (checkclearop(cap->oap))
return;
#ifdef FEAT_JOB_CHANNEL
if (bt_prompt(curbuf) && !prompt_curpos_editable())
{
clearopbeep(cap->oap);
return;
}
#endif
if (cap->nchar == Ctrl_V)
{
had_ctrl_v = Ctrl_V;
cap->nchar = get_literal(FALSE);
if (cap->nchar > DEL)
had_ctrl_v = NUL;
}
else
had_ctrl_v = NUL;
if (IS_SPECIAL(cap->nchar))
{
clearopbeep(cap->oap);
return;
}
if (VIsual_active)
{
if (got_int)
reset_VIsual();
if (had_ctrl_v)
{
if (cap->nchar == CAR)
cap->nchar = REPLACE_CR_NCHAR;
else if (cap->nchar == NL)
cap->nchar = REPLACE_NL_NCHAR;
}
nv_operator(cap);
return;
}
if (virtual_active())
{
if (u_save_cursor() == FAIL)
return;
if (gchar_cursor() == NUL)
{
coladvance_force((colnr_T)(getviscol() + cap->count1));
curwin->w_cursor.col -= cap->count1;
}
else if (gchar_cursor() == TAB)
coladvance_force(getviscol());
}
ptr = ml_get_cursor();
if (STRLEN(ptr) < (unsigned)cap->count1
|| (has_mbyte && mb_charlen(ptr) < cap->count1))
{
clearopbeep(cap->oap);
return;
}
if (had_ctrl_v != Ctrl_V && cap->nchar == '\t' && (curbuf->b_p_et || p_sta))
{
stuffnumReadbuff(cap->count1);
stuffcharReadbuff('R');
stuffcharReadbuff('\t');
stuffcharReadbuff(ESC);
return;
}
if (u_save_cursor() == FAIL)
return;
if (had_ctrl_v != Ctrl_V && (cap->nchar == '\r' || cap->nchar == '\n'))
{
(void)del_chars(cap->count1, FALSE);stuffcharReadbuff('\r');
stuffcharReadbuff(ESC);
invoke_edit(cap, TRUE, 'r', FALSE);
}
else
{
prep_redo(cap->oap->regname, cap->count1,
NUL, 'r', NUL, had_ctrl_v, cap->nchar);
curbuf->b_op_start = curwin->w_cursor;
if (has_mbyte)
{
intold_State = State;
if (cap->ncharC1 != 0)
AppendCharToRedobuff(cap->ncharC1);
if (cap->ncharC2 != 0)
AppendCharToRedobuff(cap->ncharC2);
for (n = cap->count1; n > 0; --n)
{
State = REPLACE;
if (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)
{
int c = ins_copychar(curwin->w_cursor.lnum
+ (cap->nchar == Ctrl_Y ? -1 : 1));
if (c != NUL)
ins_char(c);
else
++curwin->w_cursor.col;
}
else
ins_char(cap->nchar);
State = old_State;
if (cap->ncharC1 != 0)
ins_char(cap->ncharC1);
if (cap->ncharC2 != 0)
ins_char(cap->ncharC2);
}
}
else
{
for (n = cap->count1; n > 0; --n)
{
ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);
if (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)
{
int c = ins_copychar(curwin->w_cursor.lnum
+ (cap->nchar == Ctrl_Y ? -1 : 1));
if (c != NUL)
ptr[curwin->w_cursor.col] = c;
}
else
ptr[curwin->w_cursor.col] = cap->nchar;
if (p_sm && msg_silent == 0)
showmatch(cap->nchar);
++curwin->w_cursor.col;
}
#ifdef FEAT_NETBEANS_INTG
if (netbeans_active())
{
colnr_T  start = (colnr_T)(curwin->w_cursor.col - cap->count1);
netbeans_removed(curbuf, curwin->w_cursor.lnum, start,
(long)cap->count1);
netbeans_inserted(curbuf, curwin->w_cursor.lnum, start,
&ptr[start], (int)cap->count1);
}
#endif
changed_bytes(curwin->w_cursor.lnum,
(colnr_T)(curwin->w_cursor.col - cap->count1));
}
--curwin->w_cursor.col;    if (has_mbyte)
mb_adjust_cursor();
curbuf->b_op_end = curwin->w_cursor;
curwin->w_set_curswant = TRUE;
set_last_insert(cap->nchar);
}
}","static void
nv_replace(cmdarg_T *VAR_0)
{
char_u*VAR_1;
intVAR_2;
longVAR_3;
if (checkclearop(VAR_0->oap))
return;
#ifdef VAR_4
if (bt_prompt(VAR_5) && !prompt_curpos_editable())
{
clearopbeep(VAR_0->oap);
return;
}
#endif
if (VAR_0->nchar == VAR_6)
{
VAR_2 = VAR_6;
VAR_0->nchar = get_literal(FALSE);
if (VAR_0->nchar > VAR_7)
VAR_2 = VAR_8;
}
else
VAR_2 = VAR_8;
if (IS_SPECIAL(VAR_0->nchar))
{
clearopbeep(VAR_0->oap);
return;
}
if (VAR_9)
{
if (VAR_10)
reset_VIsual();
if (VAR_2)
{
if (VAR_0->nchar == VAR_11)
VAR_0->nchar = VAR_12;
else if (VAR_0->nchar == VAR_13)
VAR_0->nchar = VAR_14;
}
nv_operator(VAR_0);
return;
}
if (virtual_active())
{
if (u_save_cursor() == VAR_15)
return;
if (gchar_cursor() == VAR_8)
{
coladvance_force((VAR_16)(getviscol() + VAR_0->count1));
VAR_17->w_cursor.col -= VAR_0->count1;
}
else if (gchar_cursor() == VAR_18)
coladvance_force(getviscol());
}
VAR_1 = ml_get_cursor();
if (STRLEN(VAR_1) < (unsigned)VAR_0->count1
|| (VAR_19 && mb_charlen(VAR_1) < VAR_0->count1))
{
clearopbeep(VAR_0->oap);
return;
}
if (VAR_2 != VAR_6 && VAR_0->nchar == '\t' && (VAR_5->b_p_et || VAR_20))
{
stuffnumReadbuff(VAR_0->count1);
stuffcharReadbuff('R');
stuffcharReadbuff('\t');
stuffcharReadbuff(VAR_21);
return;
}
if (u_save_cursor() == VAR_15)
return;
if (VAR_2 != VAR_6 && (VAR_0->nchar == '\r' || VAR_0->nchar == '\n'))
{
(void)del_chars(VAR_0->count1, FALSE);
stuffcharReadbuff('\r');
stuffcharReadbuff(VAR_21);
invoke_edit(VAR_0, TRUE, 'r', FALSE);
}
else
{
prep_redo(VAR_0->oap->regname, VAR_0->count1,
VAR_8, 'r', VAR_8, VAR_2, VAR_0->nchar);
VAR_5->b_op_start = VAR_17->w_cursor;
if (VAR_19)
{
intVAR_22 = VAR_23;
if (VAR_0->ncharC1 != 0)
AppendCharToRedobuff(VAR_0->ncharC1);
if (VAR_0->ncharC2 != 0)
AppendCharToRedobuff(VAR_0->ncharC2);
for (VAR_3 = VAR_0->count1; VAR_3 > 0; --VAR_3)
{
VAR_23 = VAR_24;
if (VAR_0->nchar == VAR_25 || VAR_0->nchar == VAR_26)
{
int VAR_27 = ins_copychar(VAR_17->w_cursor.lnum
+ (VAR_0->nchar == VAR_26 ? -1 : 1));
if (VAR_27 != VAR_8)
ins_char(VAR_27);
else
++VAR_17->w_cursor.col;
}
else
ins_char(VAR_0->nchar);
VAR_23 = VAR_22;
if (VAR_0->ncharC1 != 0)
ins_char(VAR_0->ncharC1);
if (VAR_0->ncharC2 != 0)
ins_char(VAR_0->ncharC2);
}
}
else
{
for (VAR_3 = VAR_0->count1; VAR_3 > 0; --VAR_3)
{
VAR_1 = ml_get_buf(VAR_5, VAR_17->w_cursor.lnum, TRUE);
if (VAR_0->nchar == VAR_25 || VAR_0->nchar == VAR_26)
{
int VAR_27 = ins_copychar(VAR_17->w_cursor.lnum
+ (VAR_0->nchar == VAR_26 ? -1 : 1));
if (VAR_27 != VAR_8)
VAR_1[VAR_17->w_cursor.col] = VAR_27;
}
else
VAR_1[VAR_17->w_cursor.col] = VAR_0->nchar;
if (VAR_28 && VAR_29 == 0)
showmatch(VAR_0->nchar);
++VAR_17->w_cursor.col;
}
#ifdef VAR_30
if (netbeans_active())
{
colnr_T  VAR_31 = (colnr_T)(VAR_17->w_cursor.col - VAR_0->count1);
netbeans_removed(VAR_5, VAR_17->w_cursor.lnum, VAR_31,
(long)VAR_0->count1);
netbeans_inserted(VAR_5, VAR_17->w_cursor.lnum, VAR_31,
&VAR_1[VAR_31], (int)VAR_0->count1);
}
#endif
changed_bytes(VAR_17->w_cursor.lnum,
(colnr_T)(VAR_17->w_cursor.col - VAR_0->count1));
}
--VAR_17->w_cursor.col;    
if (VAR_19)
mb_adjust_cursor();
VAR_5->b_op_end = VAR_17->w_cursor;
VAR_17->w_set_curswant = TRUE;
set_last_insert(VAR_0->nchar);
}
}",vim/35a9a00afcb20897d462a766793ff45534810dc3/normal.c/vul/before/0.json,"static void
nv_replace(cmdarg_T *cap)
{
    char_u	*ptr;
    int		had_ctrl_v;
    long	n;

    if (checkclearop(cap->oap))
	return;
#ifdef FEAT_JOB_CHANNEL
    if (bt_prompt(curbuf) && !prompt_curpos_editable())
    {
	clearopbeep(cap->oap);
	return;
    }
#endif

    // get another character
    if (cap->nchar == Ctrl_V)
    {
	had_ctrl_v = Ctrl_V;
	cap->nchar = get_literal(FALSE);
	// Don't redo a multibyte character with CTRL-V.
	if (cap->nchar > DEL)
	    had_ctrl_v = NUL;
    }
    else
	had_ctrl_v = NUL;

    // Abort if the character is a special key.
    if (IS_SPECIAL(cap->nchar))
    {
	clearopbeep(cap->oap);
	return;
    }

    // Visual mode ""r""
    if (VIsual_active)
    {
	if (got_int)
	    reset_VIsual();
	if (had_ctrl_v)
	{
	    // Use a special (negative) number to make a difference between a
	    // literal CR or NL and a line break.
	    if (cap->nchar == CAR)
		cap->nchar = REPLACE_CR_NCHAR;
	    else if (cap->nchar == NL)
		cap->nchar = REPLACE_NL_NCHAR;
	}
	nv_operator(cap);
	return;
    }

    // Break tabs, etc.
    if (virtual_active())
    {
	if (u_save_cursor() == FAIL)
	    return;
	if (gchar_cursor() == NUL)
	{
	    // Add extra space and put the cursor on the first one.
	    coladvance_force((colnr_T)(getviscol() + cap->count1));
	    curwin->w_cursor.col -= cap->count1;
	}
	else if (gchar_cursor() == TAB)
	    coladvance_force(getviscol());
    }

    // Abort if not enough characters to replace.
    ptr = ml_get_cursor();
    if (STRLEN(ptr) < (unsigned)cap->count1
	    || (has_mbyte && mb_charlen(ptr) < cap->count1))
    {
	clearopbeep(cap->oap);
	return;
    }

    /*
     * Replacing with a TAB is done by edit() when it is complicated because
     * 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.
     * Other characters are done below to avoid problems with things like
     * CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).
     */
    if (had_ctrl_v != Ctrl_V && cap->nchar == '\t' && (curbuf->b_p_et || p_sta))
    {
	stuffnumReadbuff(cap->count1);
	stuffcharReadbuff('R');
	stuffcharReadbuff('\t');
	stuffcharReadbuff(ESC);
	return;
    }

    // save line for undo
    if (u_save_cursor() == FAIL)
	return;

    if (had_ctrl_v != Ctrl_V && (cap->nchar == '\r' || cap->nchar == '\n'))
    {
	/*
	 * Replace character(s) by a single newline.
	 * Strange vi behaviour: Only one newline is inserted.
	 * Delete the characters here.
	 * Insert the newline with an insert command, takes care of
	 * autoindent.	The insert command depends on being on the last
	 * character of a line or not.
	 */
	(void)del_chars(cap->count1, FALSE);	// delete the characters
	stuffcharReadbuff('\r');
	stuffcharReadbuff(ESC);

	// Give 'r' to edit(), to get the redo command right.
	invoke_edit(cap, TRUE, 'r', FALSE);
    }
    else
    {
	prep_redo(cap->oap->regname, cap->count1,
				       NUL, 'r', NUL, had_ctrl_v, cap->nchar);

	curbuf->b_op_start = curwin->w_cursor;
	if (has_mbyte)
	{
	    int		old_State = State;

	    if (cap->ncharC1 != 0)
		AppendCharToRedobuff(cap->ncharC1);
	    if (cap->ncharC2 != 0)
		AppendCharToRedobuff(cap->ncharC2);

	    // This is slow, but it handles replacing a single-byte with a
	    // multi-byte and the other way around.  Also handles adding
	    // composing characters for utf-8.
	    for (n = cap->count1; n > 0; --n)
	    {
		State = REPLACE;
		if (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)
		{
		    int c = ins_copychar(curwin->w_cursor.lnum
					   + (cap->nchar == Ctrl_Y ? -1 : 1));
		    if (c != NUL)
			ins_char(c);
		    else
			// will be decremented further down
			++curwin->w_cursor.col;
		}
		else
		    ins_char(cap->nchar);
		State = old_State;
		if (cap->ncharC1 != 0)
		    ins_char(cap->ncharC1);
		if (cap->ncharC2 != 0)
		    ins_char(cap->ncharC2);
	    }
	}
	else
	{
	    /*
	     * Replace the characters within one line.
	     */
	    for (n = cap->count1; n > 0; --n)
	    {
		/*
		 * Get ptr again, because u_save and/or showmatch() will have
		 * released the line.  This may also happen in ins_copychar().
		 * At the same time we let know that the line will be changed.
		 */
		if (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)
		{
		  int c = ins_copychar(curwin->w_cursor.lnum
					   + (cap->nchar == Ctrl_Y ? -1 : 1));

		  ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);
		  if (c != NUL)
		    ptr[curwin->w_cursor.col] = c;
		}
		else
		{
		    ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);
		    ptr[curwin->w_cursor.col] = cap->nchar;
		}
		if (p_sm && msg_silent == 0)
		    showmatch(cap->nchar);
		++curwin->w_cursor.col;
	    }
#ifdef FEAT_NETBEANS_INTG
	    if (netbeans_active())
	    {
		colnr_T  start = (colnr_T)(curwin->w_cursor.col - cap->count1);

		netbeans_removed(curbuf, curwin->w_cursor.lnum, start,
							   (long)cap->count1);
		netbeans_inserted(curbuf, curwin->w_cursor.lnum, start,
					       &ptr[start], (int)cap->count1);
	    }
#endif

	    // mark the buffer as changed and prepare for displaying
	    changed_bytes(curwin->w_cursor.lnum,
			       (colnr_T)(curwin->w_cursor.col - cap->count1));
	}
	--curwin->w_cursor.col;	    // cursor on the last replaced char
	// if the character on the left of the current cursor is a multi-byte
	// character, move two characters left
	if (has_mbyte)
	    mb_adjust_cursor();
	curbuf->b_op_end = curwin->w_cursor;
	curwin->w_set_curswant = TRUE;
	set_last_insert(cap->nchar);
    }
}","static void
nv_replace(cmdarg_T *VAR_0)
{
    char_u	*VAR_1;
    int		VAR_2;
    long	VAR_3;

    if (checkclearop(VAR_0->oap))
	return;
#ifdef VAR_4
    if (bt_prompt(VAR_5) && !prompt_curpos_editable())
    {
	clearopbeep(VAR_0->oap);
	return;
    }
#endif

    /* COMMENT_0 */
    if (VAR_0->nchar == VAR_6)
    {
	VAR_2 = VAR_6;
	VAR_0->nchar = get_literal(FALSE);
	/* COMMENT_1 */
	if (VAR_0->nchar > VAR_7)
	    VAR_2 = VAR_8;
    }
    else
	VAR_2 = VAR_8;

    /* COMMENT_2 */
    if (IS_SPECIAL(VAR_0->nchar))
    {
	clearopbeep(VAR_0->oap);
	return;
    }

    /* COMMENT_3 */
    if (VAR_9)
    {
	if (VAR_10)
	    reset_VIsual();
	if (VAR_2)
	{
	    /* COMMENT_4 */
	    /* COMMENT_5 */
	    if (VAR_0->nchar == VAR_11)
		VAR_0->nchar = VAR_12;
	    else if (VAR_0->nchar == VAR_13)
		VAR_0->nchar = VAR_14;
	}
	nv_operator(VAR_0);
	return;
    }

    /* COMMENT_6 */
    if (virtual_active())
    {
	if (u_save_cursor() == VAR_15)
	    return;
	if (gchar_cursor() == VAR_8)
	{
	    /* COMMENT_7 */
	    coladvance_force((VAR_16)(getviscol() + VAR_0->count1));
	    VAR_17->w_cursor.col -= VAR_0->count1;
	}
	else if (gchar_cursor() == VAR_18)
	    coladvance_force(getviscol());
    }

    /* COMMENT_8 */
    VAR_1 = ml_get_cursor();
    if (STRLEN(VAR_1) < (unsigned)VAR_0->count1
	    || (VAR_19 && mb_charlen(VAR_1) < VAR_0->count1))
    {
	clearopbeep(VAR_0->oap);
	return;
    }

    /* COMMENT_9 */
                                                                            
                                                                           
                                                                         
                                                            
       
    if (VAR_2 != VAR_6 && VAR_0->nchar == '\t' && (VAR_5->b_p_et || VAR_20))
    {
	stuffnumReadbuff(VAR_0->count1);
	stuffcharReadbuff('R');
	stuffcharReadbuff('\t');
	stuffcharReadbuff(VAR_21);
	return;
    }

    /* COMMENT_15 */
    if (u_save_cursor() == VAR_15)
	return;

    if (VAR_2 != VAR_6 && (VAR_0->nchar == '\r' || VAR_0->nchar == '\n'))
    {
	/* COMMENT_16 */
                                             
                                                       
                               
                                                            
                                                               
                               
    
	(void)del_chars(VAR_0->count1, FALSE);	/* COMMENT_24 */
	stuffcharReadbuff('\r');
	stuffcharReadbuff(VAR_21);

	/* COMMENT_25 */
	invoke_edit(VAR_0, TRUE, 'r', FALSE);
    }
    else
    {
	prep_redo(VAR_0->oap->regname, VAR_0->count1,
				       VAR_8, 'r', VAR_8, VAR_2, VAR_0->nchar);

	VAR_5->b_op_start = VAR_17->w_cursor;
	if (VAR_19)
	{
	    int		VAR_22 = VAR_23;

	    if (VAR_0->ncharC1 != 0)
		AppendCharToRedobuff(VAR_0->ncharC1);
	    if (VAR_0->ncharC2 != 0)
		AppendCharToRedobuff(VAR_0->ncharC2);

	    /* COMMENT_26 */
	    /* COMMENT_27 */
	    /* COMMENT_28 */
	    for (VAR_3 = VAR_0->count1; VAR_3 > 0; --VAR_3)
	    {
		VAR_23 = VAR_24;
		if (VAR_0->nchar == VAR_25 || VAR_0->nchar == VAR_26)
		{
		    int VAR_27 = ins_copychar(VAR_17->w_cursor.lnum
					   + (VAR_0->nchar == VAR_26 ? -1 : 1));
		    if (VAR_27 != VAR_8)
			ins_char(VAR_27);
		    else
			/* COMMENT_29 */
			++VAR_17->w_cursor.col;
		}
		else
		    ins_char(VAR_0->nchar);
		VAR_23 = VAR_22;
		if (VAR_0->ncharC1 != 0)
		    ins_char(VAR_0->ncharC1);
		if (VAR_0->ncharC2 != 0)
		    ins_char(VAR_0->ncharC2);
	    }
	}
	else
	{
	    /* COMMENT_30 */
                                               
        
	    for (VAR_3 = VAR_0->count1; VAR_3 > 0; --VAR_3)
	    {
		/* COMMENT_33 */
                                                               
                                                                
                                                                
     
		if (VAR_0->nchar == VAR_25 || VAR_0->nchar == VAR_26)
		{
		  int VAR_27 = ins_copychar(VAR_17->w_cursor.lnum
					   + (VAR_0->nchar == VAR_26 ? -1 : 1));

		  VAR_1 = ml_get_buf(VAR_5, VAR_17->w_cursor.lnum, TRUE);
		  if (VAR_27 != VAR_8)
		    VAR_1[VAR_17->w_cursor.col] = VAR_27;
		}
		else
		{
		    VAR_1 = ml_get_buf(VAR_5, VAR_17->w_cursor.lnum, TRUE);
		    VAR_1[VAR_17->w_cursor.col] = VAR_0->nchar;
		}
		if (VAR_28 && VAR_29 == 0)
		    showmatch(VAR_0->nchar);
		++VAR_17->w_cursor.col;
	    }
#ifdef VAR_30
	    if (netbeans_active())
	    {
		colnr_T  VAR_31 = (colnr_T)(VAR_17->w_cursor.col - VAR_0->count1);

		netbeans_removed(VAR_5, VAR_17->w_cursor.lnum, VAR_31,
							   (long)VAR_0->count1);
		netbeans_inserted(VAR_5, VAR_17->w_cursor.lnum, VAR_31,
					       &VAR_1[VAR_31], (int)VAR_0->count1);
	    }
#endif

	    /* COMMENT_38 */
	    changed_bytes(VAR_17->w_cursor.lnum,
			       (colnr_T)(VAR_17->w_cursor.col - VAR_0->count1));
	}
	--VAR_17->w_cursor.col;	    /* COMMENT_39 */
	/* COMMENT_40 */
	/* COMMENT_41 */
	if (VAR_19)
	    mb_adjust_cursor();
	VAR_5->b_op_end = VAR_17->w_cursor;
	VAR_17->w_set_curswant = TRUE;
	set_last_insert(VAR_0->nchar);
    }
}",vim/35a9a00afcb20897d462a766793ff45534810dc3/normal.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -161,19 +161,23 @@
 	    {
 		/*
 		 * Get ptr again, because u_save and/or showmatch() will have
-		 * released the line.  At the same time we let know that the
-		 * line will be changed.
+		 * released the line.  This may also happen in ins_copychar().
+		 * At the same time we let know that the line will be changed.
 		 */
-		ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);
 		if (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)
 		{
 		  int c = ins_copychar(curwin->w_cursor.lnum
 					   + (cap->nchar == Ctrl_Y ? -1 : 1));
+
+		  ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);
 		  if (c != NUL)
 		    ptr[curwin->w_cursor.col] = c;
 		}
 		else
+		{
+		    ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);
 		    ptr[curwin->w_cursor.col] = cap->nchar;
+		}
 		if (p_sm && msg_silent == 0)
 		    showmatch(cap->nchar);
 		++curwin->w_cursor.col;","{'deleted_lines': ['\t\t * released the line.  At the same time we let know that the', '\t\t * line will be changed.', '\t\tptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);'], 'added_lines': ['\t\t * released the line.  This may also happen in ins_copychar().', '\t\t * At the same time we let know that the line will be changed.', '', '\t\t  ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);', '\t\t{', '\t\t    ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);', '\t\t}']}",True,vim is vulnerable to Use After Free,7.3,HIGH,2,valid,2021-09-11T19:14:20Z,3
CVE-2022-31621,['CWE-667'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,MariaDB/server,"MDEV-26574 An improper locking bug due to unreleased lock in the ds_xbstream.cc

release lock in all as cases n xbstream_open, also fix the case where malloc would return NULL.",b1351c15946349f9daa7e5297fb2ac6f3139e4a8,https://github.com/MariaDB/server/commit/b1351c15946349f9daa7e5297fb2ac6f3139e4a8,extra/mariabackup/ds_xbstream.cc,xbstream_open,"static
ds_file_t *
xbstream_open(ds_ctxt_t *ctxt, const char *path, MY_STAT *mystat)
{
ds_file_t*file;
ds_stream_file_t*stream_file;
ds_stream_ctxt_t*stream_ctxt;
ds_ctxt_t*dest_ctxt;
xb_wstream_t*xbstream;
xb_wstream_file_t*xbstream_file;
xb_ad(ctxt->pipe_ctxt != NULL);
dest_ctxt = ctxt->pipe_ctxt;
stream_ctxt = (ds_stream_ctxt_t *) ctxt->ptr;
pthread_mutex_lock(&stream_ctxt->mutex);
if (stream_ctxt->dest_file == NULL) {
stream_ctxt->dest_file = ds_open(dest_ctxt, path, mystat);
if (stream_ctxt->dest_file == NULL) {
return NULL;
}
}
pthread_mutex_unlock(&stream_ctxt->mutex);
file = (ds_file_t *) my_malloc(sizeof(ds_file_t) +
sizeof(ds_stream_file_t),
MYF(MY_FAE));
stream_file = (ds_stream_file_t *) (file + 1);
xbstream = stream_ctxt->xbstream;
xbstream_file = xb_stream_write_open(xbstream, path, mystat,
stream_ctxt,
my_xbstream_write_callback);
if (xbstream_file == NULL) {
msg(""xb_stream_write_open() failed."");
goto err;
}
stream_file->xbstream_file = xbstream_file;
stream_file->stream_ctxt = stream_ctxt;
file->ptr = stream_file;
file->path = stream_ctxt->dest_file->path;
return file;
err:
if (stream_ctxt->dest_file) {
ds_close(stream_ctxt->dest_file);
stream_ctxt->dest_file = NULL;
}
my_free(file);
return NULL;
}","static
ds_file_t *
xbstream_open(ds_ctxt_t *VAR_0, const char *VAR_1, MY_STAT *VAR_2)
{
ds_file_t*VAR_3;
ds_stream_file_t*VAR_4;
ds_stream_ctxt_t*VAR_5;
ds_ctxt_t*VAR_6;
xb_wstream_t*VAR_7;
xb_wstream_file_t*VAR_8;
xb_ad(VAR_0->pipe_ctxt != NULL);
VAR_6 = VAR_0->pipe_ctxt;
VAR_5 = (ds_stream_ctxt_t *) VAR_0->ptr;
pthread_mutex_lock(&VAR_5->mutex);
if (VAR_5->dest_file == NULL) {
VAR_5->dest_file = ds_open(VAR_6, VAR_1, VAR_2);
if (VAR_5->dest_file == NULL) {
return NULL;
}
}
pthread_mutex_unlock(&VAR_5->mutex);
VAR_3 = (ds_file_t *) my_malloc(sizeof(ds_file_t) +
sizeof(ds_stream_file_t),
MYF(VAR_9));
VAR_4 = (ds_stream_file_t *) (VAR_3 + 1);
VAR_7 = VAR_5->xbstream;
VAR_8 = xb_stream_write_open(VAR_7, VAR_1, VAR_2,
VAR_5,
VAR_10);
if (VAR_8 == NULL) {
msg(""xb_stream_write_open() failed."");
goto err;
}
VAR_4->xbstream_file = VAR_8;
VAR_4->stream_ctxt = VAR_5;
VAR_3->ptr = VAR_4;
VAR_3->path = VAR_5->dest_file->path;
return VAR_3;
err:
if (VAR_5->dest_file) {
ds_close(VAR_5->dest_file);
VAR_5->dest_file = NULL;
}
my_free(VAR_3);
return NULL;
}",MariaDB/server/b1351c15946349f9daa7e5297fb2ac6f3139e4a8/ds_xbstream.cc/vul/before/0.json,"static
ds_file_t *
xbstream_open(ds_ctxt_t *ctxt, const char *path, MY_STAT *mystat)
{
	ds_file_t		*file;
	ds_stream_file_t	*stream_file;
	ds_stream_ctxt_t	*stream_ctxt;
	ds_ctxt_t		*dest_ctxt;
	xb_wstream_t		*xbstream;
	xb_wstream_file_t	*xbstream_file;


	xb_ad(ctxt->pipe_ctxt != NULL);
	dest_ctxt = ctxt->pipe_ctxt;

	stream_ctxt = (ds_stream_ctxt_t *) ctxt->ptr;

	pthread_mutex_lock(&stream_ctxt->mutex);
	if (stream_ctxt->dest_file == NULL) {
		stream_ctxt->dest_file = ds_open(dest_ctxt, path, mystat);
	}
	pthread_mutex_unlock(&stream_ctxt->mutex);
	if (stream_ctxt->dest_file == NULL) {
		return NULL;
	}

	file = (ds_file_t *) my_malloc(sizeof(ds_file_t) +
				       sizeof(ds_stream_file_t),
				       MYF(MY_FAE));
	if (!file) {
		msg(""my_malloc() failed."");
		goto err;
	}
	stream_file = (ds_stream_file_t *) (file + 1);

	xbstream = stream_ctxt->xbstream;

	xbstream_file = xb_stream_write_open(xbstream, path, mystat,
		                             stream_ctxt,
					     my_xbstream_write_callback);

	if (xbstream_file == NULL) {
		msg(""xb_stream_write_open() failed."");
		goto err;
	}

	stream_file->xbstream_file = xbstream_file;
	stream_file->stream_ctxt = stream_ctxt;
	file->ptr = stream_file;
	file->path = stream_ctxt->dest_file->path;

	return file;

err:
	if (stream_ctxt->dest_file) {
		ds_close(stream_ctxt->dest_file);
		stream_ctxt->dest_file = NULL;
	}
	my_free(file);

	return NULL;
}","static
ds_file_t *
xbstream_open(ds_ctxt_t *VAR_0, const char *VAR_1, MY_STAT *VAR_2)
{
	ds_file_t		*VAR_3;
	ds_stream_file_t	*VAR_4;
	ds_stream_ctxt_t	*VAR_5;
	ds_ctxt_t		*VAR_6;
	xb_wstream_t		*VAR_7;
	xb_wstream_file_t	*VAR_8;


	xb_ad(VAR_0->pipe_ctxt != NULL);
	VAR_6 = VAR_0->pipe_ctxt;

	VAR_5 = (ds_stream_ctxt_t *) VAR_0->ptr;

	pthread_mutex_lock(&VAR_5->mutex);
	if (VAR_5->dest_file == NULL) {
		VAR_5->dest_file = ds_open(VAR_6, VAR_1, VAR_2);
	}
	pthread_mutex_unlock(&VAR_5->mutex);
	if (VAR_5->dest_file == NULL) {
		return NULL;
	}

	VAR_3 = (ds_file_t *) my_malloc(sizeof(ds_file_t) +
				       sizeof(ds_stream_file_t),
				       MYF(VAR_9));
	if (!VAR_3) {
		msg(""my_malloc() failed."");
		goto err;
	}
	VAR_4 = (ds_stream_file_t *) (VAR_3 + 1);

	VAR_7 = VAR_5->xbstream;

	VAR_8 = xb_stream_write_open(VAR_7, VAR_1, VAR_2,
		                             VAR_5,
					     VAR_10);

	if (VAR_8 == NULL) {
		msg(""xb_stream_write_open() failed."");
		goto err;
	}

	VAR_4->xbstream_file = VAR_8;
	VAR_4->stream_ctxt = VAR_5;
	VAR_3->ptr = VAR_4;
	VAR_3->path = VAR_5->dest_file->path;

	return VAR_3;

err:
	if (VAR_5->dest_file) {
		ds_close(VAR_5->dest_file);
		VAR_5->dest_file = NULL;
	}
	my_free(VAR_3);

	return NULL;
}",MariaDB/server/b1351c15946349f9daa7e5297fb2ac6f3139e4a8/ds_xbstream.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -18,15 +18,19 @@
 	pthread_mutex_lock(&stream_ctxt->mutex);
 	if (stream_ctxt->dest_file == NULL) {
 		stream_ctxt->dest_file = ds_open(dest_ctxt, path, mystat);
-		if (stream_ctxt->dest_file == NULL) {
-			return NULL;
-		}
 	}
 	pthread_mutex_unlock(&stream_ctxt->mutex);
+	if (stream_ctxt->dest_file == NULL) {
+		return NULL;
+	}
 
 	file = (ds_file_t *) my_malloc(sizeof(ds_file_t) +
 				       sizeof(ds_stream_file_t),
 				       MYF(MY_FAE));
+	if (!file) {
+		msg(""my_malloc() failed."");
+		goto err;
+	}
 	stream_file = (ds_stream_file_t *) (file + 1);
 
 	xbstream = stream_ctxt->xbstream;","{'deleted_lines': ['\t\tif (stream_ctxt->dest_file == NULL) {', '\t\t\treturn NULL;', '\t\t}'], 'added_lines': ['\tif (stream_ctxt->dest_file == NULL) {', '\t\treturn NULL;', '\t}', '\tif (!file) {', '\t\tmsg(""my_malloc() failed."");', '\t\tgoto err;', '\t}']}",True,"MariaDB Server before 10.7 is vulnerable to Denial of Service. In extra/mariabackup/ds_xbstream.cc, when an error occurs (stream_ctxt->dest_file == NULL) while executing the method xbstream_open, the held lock is not released correctly, which allows local users to trigger a denial of service due to the deadlock.",5.5,MEDIUM,1,valid,2021-09-15T12:55:45Z,3
CVE-2021-41220,['CWE-416'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"Fix undefined behavior in CollectiveReduceV2 and others

We should not call done after it's moved.

PiperOrigin-RevId: 400838185
Change-Id: Ifc979740054b8f8c6f4d50acc89472fe60c4fdb1",ca38dab9d3ee66c5de06f11af9a4b1200da5ef75,https://github.com/tensorflow/tensorflow/commit/ca38dab9d3ee66c5de06f11af9a4b1200da5ef75,tensorflow/core/kernels/collective_ops.cc,CheckInputs,"Status CheckInputs(Tensor group_size_t, Tensor group_key_t) {
if (group_size_t.dims() > 0) {
return errors::Internal(
""Unexpected dimensions on input group_size. ""
""It shoulbe a scalar, got tensor with shape "",
group_size_t.shape().DebugString());
}
if (group_key_t.dims() > 0) {
return errors::Internal(""Unexpected dimensions on input group_key, got "",
group_key_t.shape().DebugString());
}
auto group_size = group_size_t.unaligned_flat<int32>()(0);
if (group_size <= 0) {
return errors::InvalidArgument(
""group_size must be positive integer but got "", group_size);
}
return Status::OK();
}","Status CheckInputs(Tensor VAR_0, Tensor VAR_1) {
if (VAR_0.dims() > 0) {
return errors::Internal(
""Unexpected dimensions on input group_size. ""
""It shoulbe a scalar, got tensor with shape "",
VAR_0.shape().DebugString());
}
if (VAR_1.dims() > 0) {
return errors::Internal(""Unexpected dimensions on input group_key, got "",
VAR_1.shape().DebugString());
}
auto VAR_2 = VAR_0.unaligned_flat<int32>()(0);
if (VAR_2 <= 0) {
return errors::InvalidArgument(
""group_size must be positive integer but got "", VAR_2);
}
return Status::OK();
}",tensorflow/ca38dab9d3ee66c5de06f11af9a4b1200da5ef75/collective_ops.cc/vul/before/1.json,"Status CheckInputs(Tensor group_size_t, Tensor group_key_t) {
    if (group_size_t.dims() > 0) {
      return errors::InvalidArgument(
          ""Unexpected dimensions on input group_size. ""
          ""It shoulbe a scalar, got tensor with shape "",
          group_size_t.shape().DebugString());
    }
    if (group_key_t.dims() > 0) {
      return errors::InvalidArgument(
          ""Unexpected dimensions on input group_key, got "",
          group_key_t.shape().DebugString());
    }

    auto group_size = group_size_t.unaligned_flat<int32>()(0);
    if (group_size <= 0) {
      return errors::InvalidArgument(
          ""group_size must be positive integer but got "", group_size);
    }
    return Status::OK();
  }","Status CheckInputs(Tensor VAR_0, Tensor VAR_1) {
    if (VAR_0.dims() > 0) {
      return errors::InvalidArgument(
          ""Unexpected dimensions on input group_size. ""
          ""It shoulbe a scalar, got tensor with shape "",
          VAR_0.shape().DebugString());
    }
    if (VAR_1.dims() > 0) {
      return errors::InvalidArgument(
          ""Unexpected dimensions on input group_key, got "",
          VAR_1.shape().DebugString());
    }

    auto VAR_2 = VAR_0.unaligned_flat<int32>()(0);
    if (VAR_2 <= 0) {
      return errors::InvalidArgument(
          ""group_size must be positive integer but got "", VAR_2);
    }
    return Status::OK();
  }",tensorflow/ca38dab9d3ee66c5de06f11af9a4b1200da5ef75/collective_ops.cc/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,13 +1,14 @@
 Status CheckInputs(Tensor group_size_t, Tensor group_key_t) {
     if (group_size_t.dims() > 0) {
-      return errors::Internal(
+      return errors::InvalidArgument(
           ""Unexpected dimensions on input group_size. ""
           ""It shoulbe a scalar, got tensor with shape "",
           group_size_t.shape().DebugString());
     }
     if (group_key_t.dims() > 0) {
-      return errors::Internal(""Unexpected dimensions on input group_key, got "",
-                              group_key_t.shape().DebugString());
+      return errors::InvalidArgument(
+          ""Unexpected dimensions on input group_key, got "",
+          group_key_t.shape().DebugString());
     }
 
     auto group_size = group_size_t.unaligned_flat<int32>()(0);","{'deleted_lines': ['      return errors::Internal(', '      return errors::Internal(""Unexpected dimensions on input group_key, got "",', '                              group_key_t.shape().DebugString());'], 'added_lines': ['      return errors::InvalidArgument(', '      return errors::InvalidArgument(', '          ""Unexpected dimensions on input group_key, got "",', '          group_key_t.shape().DebugString());']}",True,"TensorFlow is an open source platform for machine learning. In affected versions the async implementation of `CollectiveReduceV2` suffers from a memory leak and a use after free. This occurs due to the asynchronous computation and the fact that objects that have been `std::move()`d from are still accessed. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, as this version is the only one that is also affected.",7.8,HIGH,2,valid,2021-10-04T23:09:45Z,3
CVE-2021-41220,['CWE-416'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"Fix undefined behavior in CollectiveReduceV2 and others

We should not call done after it's moved.

PiperOrigin-RevId: 400838185
Change-Id: Ifc979740054b8f8c6f4d50acc89472fe60c4fdb1",ca38dab9d3ee66c5de06f11af9a4b1200da5ef75,https://github.com/tensorflow/tensorflow/commit/ca38dab9d3ee66c5de06f11af9a4b1200da5ef75,tensorflow/core/kernels/collective_ops.cc,FillCollectiveParams,"Status FillCollectiveParams(CollectiveParams* col_params,
CollectiveType collective_type,
const Tensor& group_size, const Tensor& group_key,
const Tensor& instance_key) {
if (group_size.dims() > 0) {
return errors::Internal(""Unexpected dimensions on input group_size, got "",
group_size.shape().DebugString());
}
if (group_key.dims() > 0) {
return errors::Internal(""Unexpected dimensions on input group_key, got "",
group_key.shape().DebugString());
}
if (instance_key.dims() > 0) {
return errors::Internal(
""Unexpected dimensions on input instance_key, got "",
instance_key.shape().DebugString());
}
col_params->name = name_;
col_params->group.device_type = device_type_;
col_params->group.group_size = group_size.unaligned_flat<int32>()(0);
if (col_params->group.group_size <= 0) {
return errors::InvalidArgument(
""group_size must be positive integer but got "",
col_params->group.group_size);
}
col_params->group.group_key = group_key.unaligned_flat<int32>()(0);
col_params->instance.type = collective_type;
col_params->instance.instance_key = instance_key.unaligned_flat<int32>()(0);
col_params->instance.data_type = data_type_;
col_params->instance.impl_details.communication_hint = communication_hint_;
col_params->instance.impl_details.timeout_seconds = timeout_seconds_;
return Status::OK();
}","Status FillCollectiveParams(CollectiveParams* VAR_0,
CollectiveType VAR_1,
const Tensor& VAR_2, const Tensor& VAR_3,
const Tensor& VAR_4) {
if (VAR_2.dims() > 0) {
return errors::Internal(""Unexpected dimensions on input group_size, got "",
VAR_2.shape().DebugString());
}
if (VAR_3.dims() > 0) {
return errors::Internal(""Unexpected dimensions on input group_key, got "",
VAR_3.shape().DebugString());
}
if (VAR_4.dims() > 0) {
return errors::Internal(
""Unexpected dimensions on input instance_key, got "",
VAR_4.shape().DebugString());
}
VAR_0->name = VAR_5;
VAR_0->group.device_type = VAR_6;
VAR_0->group.group_size = VAR_2.unaligned_flat<int32>()(0);
if (VAR_0->group.group_size <= 0) {
return errors::InvalidArgument(
""group_size must be positive integer but got "",
VAR_0->group.group_size);
}
VAR_0->group.group_key = VAR_3.unaligned_flat<int32>()(0);
VAR_0->instance.type = VAR_1;
VAR_0->instance.instance_key = VAR_4.unaligned_flat<int32>()(0);
VAR_0->instance.data_type = VAR_7;
VAR_0->instance.impl_details.communication_hint = VAR_8;
VAR_0->instance.impl_details.timeout_seconds = VAR_9;
return Status::OK();
}",tensorflow/ca38dab9d3ee66c5de06f11af9a4b1200da5ef75/collective_ops.cc/vul/before/2.json,"Status FillCollectiveParams(CollectiveParams* col_params,
                              CollectiveType collective_type,
                              const Tensor& group_size, const Tensor& group_key,
                              const Tensor& instance_key) {
    if (group_size.dims() > 0) {
      return errors::InvalidArgument(
          ""Unexpected dimensions on input group_size, got "",
          group_size.shape().DebugString());
    }
    if (group_key.dims() > 0) {
      return errors::InvalidArgument(
          ""Unexpected dimensions on input group_key, got "",
          group_key.shape().DebugString());
    }
    if (instance_key.dims() > 0) {
      return errors::InvalidArgument(
          ""Unexpected dimensions on input instance_key, got "",
          instance_key.shape().DebugString());
    }
    col_params->name = name_;
    col_params->group.device_type = device_type_;
    col_params->group.group_size = group_size.unaligned_flat<int32>()(0);
    if (col_params->group.group_size <= 0) {
      return errors::InvalidArgument(
          ""group_size must be positive integer but got "",
          col_params->group.group_size);
    }
    col_params->group.group_key = group_key.unaligned_flat<int32>()(0);
    col_params->instance.type = collective_type;
    col_params->instance.instance_key = instance_key.unaligned_flat<int32>()(0);
    col_params->instance.data_type = data_type_;
    col_params->instance.impl_details.communication_hint = communication_hint_;
    col_params->instance.impl_details.timeout_seconds = timeout_seconds_;
    return Status::OK();
  }","Status FillCollectiveParams(CollectiveParams* VAR_0,
                              CollectiveType VAR_1,
                              const Tensor& VAR_2, const Tensor& VAR_3,
                              const Tensor& VAR_4) {
    if (VAR_2.dims() > 0) {
      return errors::InvalidArgument(
          ""Unexpected dimensions on input group_size, got "",
          VAR_2.shape().DebugString());
    }
    if (VAR_3.dims() > 0) {
      return errors::InvalidArgument(
          ""Unexpected dimensions on input group_key, got "",
          VAR_3.shape().DebugString());
    }
    if (VAR_4.dims() > 0) {
      return errors::InvalidArgument(
          ""Unexpected dimensions on input instance_key, got "",
          VAR_4.shape().DebugString());
    }
    VAR_0->name = VAR_5;
    VAR_0->group.device_type = VAR_6;
    VAR_0->group.group_size = VAR_2.unaligned_flat<int32>()(0);
    if (VAR_0->group.group_size <= 0) {
      return errors::InvalidArgument(
          ""group_size must be positive integer but got "",
          VAR_0->group.group_size);
    }
    VAR_0->group.group_key = VAR_3.unaligned_flat<int32>()(0);
    VAR_0->instance.type = VAR_1;
    VAR_0->instance.instance_key = VAR_4.unaligned_flat<int32>()(0);
    VAR_0->instance.data_type = VAR_7;
    VAR_0->instance.impl_details.communication_hint = VAR_8;
    VAR_0->instance.impl_details.timeout_seconds = VAR_9;
    return Status::OK();
  }",tensorflow/ca38dab9d3ee66c5de06f11af9a4b1200da5ef75/collective_ops.cc/vul/after/2.json,"--- func_before
+++ func_after
@@ -3,15 +3,17 @@
                               const Tensor& group_size, const Tensor& group_key,
                               const Tensor& instance_key) {
     if (group_size.dims() > 0) {
-      return errors::Internal(""Unexpected dimensions on input group_size, got "",
-                              group_size.shape().DebugString());
+      return errors::InvalidArgument(
+          ""Unexpected dimensions on input group_size, got "",
+          group_size.shape().DebugString());
     }
     if (group_key.dims() > 0) {
-      return errors::Internal(""Unexpected dimensions on input group_key, got "",
-                              group_key.shape().DebugString());
+      return errors::InvalidArgument(
+          ""Unexpected dimensions on input group_key, got "",
+          group_key.shape().DebugString());
     }
     if (instance_key.dims() > 0) {
-      return errors::Internal(
+      return errors::InvalidArgument(
           ""Unexpected dimensions on input instance_key, got "",
           instance_key.shape().DebugString());
     }","{'deleted_lines': ['      return errors::Internal(""Unexpected dimensions on input group_size, got "",', '                              group_size.shape().DebugString());', '      return errors::Internal(""Unexpected dimensions on input group_key, got "",', '                              group_key.shape().DebugString());', '      return errors::Internal('], 'added_lines': ['      return errors::InvalidArgument(', '          ""Unexpected dimensions on input group_size, got "",', '          group_size.shape().DebugString());', '      return errors::InvalidArgument(', '          ""Unexpected dimensions on input group_key, got "",', '          group_key.shape().DebugString());', '      return errors::InvalidArgument(']}",True,"TensorFlow is an open source platform for machine learning. In affected versions the async implementation of `CollectiveReduceV2` suffers from a memory leak and a use after free. This occurs due to the asynchronous computation and the fact that objects that have been `std::move()`d from are still accessed. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, as this version is the only one that is also affected.",7.8,HIGH,2,valid,2021-10-04T23:09:45Z,3
CVE-2021-41220,['CWE-416'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"Fix undefined behavior in CollectiveReduceV2 and others

We should not call done after it's moved.

PiperOrigin-RevId: 400838185
Change-Id: Ifc979740054b8f8c6f4d50acc89472fe60c4fdb1",ca38dab9d3ee66c5de06f11af9a4b1200da5ef75,https://github.com/tensorflow/tensorflow/commit/ca38dab9d3ee66c5de06f11af9a4b1200da5ef75,tensorflow/core/kernels/collective_ops.cc,ComputeAsync,"void ComputeAsync(OpKernelContext* c, DoneCallback done) override {
auto col_params = new CollectiveParams();
auto done_with_cleanup = [col_params, done = std::move(done)]() {
done();
col_params->Unref();
};
core::RefCountPtr<CollectiveGroupResource> resource;
OP_REQUIRES_OK_ASYNC(c, LookupResource(c, HandleFromInput(c, 1), &resource),
done);
Tensor group_assignment = c->input(2);
OP_REQUIRES_OK_ASYNC(
c,
FillCollectiveParams(col_params, group_assignment,
ALL_TO_ALL_COLLECTIVE, resource.get()),
done);
col_params->instance.shape = c->input(0).shape();
VLOG(1) << ""CollectiveAllToAll group_size "" << col_params->group.group_size
<< "" group_key "" << col_params->group.group_key << "" instance_key ""
<< col_params->instance.instance_key;
Tensor* output = nullptr;
OP_REQUIRES_OK_ASYNC(c,
c->forward_input_or_allocate_output(
{0}, 0, col_params->instance.shape, &output),
done_with_cleanup);
Run(c, col_params, std::move(done_with_cleanup));
}","void ComputeAsync(OpKernelContext* VAR_0, DoneCallback VAR_1) override {
auto VAR_2 = new CollectiveParams();
auto VAR_3 = [VAR_2, VAR_1 = std::move(VAR_1)]() {
VAR_1();
VAR_2->Unref();
};
core::RefCountPtr<CollectiveGroupResource> VAR_4;
OP_REQUIRES_OK_ASYNC(VAR_0, LookupResource(VAR_0, HandleFromInput(VAR_0, 1), &VAR_4),
VAR_1);
Tensor VAR_5 = VAR_0->input(2);
OP_REQUIRES_OK_ASYNC(
VAR_0,
FillCollectiveParams(VAR_2, VAR_5,
VAR_6, VAR_4.get()),
VAR_1);
VAR_2->instance.shape = VAR_0->input(0).shape();
VLOG(1) << ""CollectiveAllToAll group_size "" << VAR_2->group.group_size
<< "" group_key "" << VAR_2->group.group_key << "" instance_key ""
<< VAR_2->instance.instance_key;
Tensor* VAR_7 = nullptr;
OP_REQUIRES_OK_ASYNC(VAR_0,
VAR_0->forward_input_or_allocate_output(
{0}, 0, VAR_2->instance.shape, &VAR_7),
VAR_3);
Run(VAR_0, VAR_2, std::move(VAR_3));
}",,"void ComputeAsync(OpKernelContext* c, DoneCallback done) override {
    auto col_params = new CollectiveParams();
    auto done_with_cleanup = [col_params, done = std::move(done)]() {
      done();
      col_params->Unref();
    };
    core::RefCountPtr<CollectiveGroupResource> resource;
    OP_REQUIRES_OK_ASYNC(c, LookupResource(c, HandleFromInput(c, 1), &resource),
                         done_with_cleanup);

    Tensor group_assignment = c->input(2);

    OP_REQUIRES_OK_ASYNC(
        c,
        FillCollectiveParams(col_params, group_assignment,
                             ALL_TO_ALL_COLLECTIVE, resource.get()),
        done);
    col_params->instance.shape = c->input(0).shape();
    VLOG(1) << ""CollectiveAllToAll group_size "" << col_params->group.group_size
            << "" group_key "" << col_params->group.group_key << "" instance_key ""
            << col_params->instance.instance_key;
    // Allocate the output tensor, trying to reuse the input.
    Tensor* output = nullptr;
    OP_REQUIRES_OK_ASYNC(c,
                         c->forward_input_or_allocate_output(
                             {0}, 0, col_params->instance.shape, &output),
                         done_with_cleanup);
    Run(c, col_params, std::move(done_with_cleanup));
  }","void ComputeAsync(OpKernelContext* VAR_0, DoneCallback VAR_1) override {
    auto VAR_2 = new CollectiveParams();
    auto VAR_3 = [VAR_2, VAR_1 = std::move(VAR_1)]() {
      VAR_1();
      VAR_2->Unref();
    };
    core::RefCountPtr<CollectiveGroupResource> VAR_4;
    OP_REQUIRES_OK_ASYNC(VAR_0, LookupResource(VAR_0, HandleFromInput(VAR_0, 1), &VAR_4),
                         VAR_3);

    Tensor VAR_5 = VAR_0->input(2);

    OP_REQUIRES_OK_ASYNC(
        VAR_0,
        FillCollectiveParams(VAR_2, VAR_5,
                             VAR_6, VAR_4.get()),
        VAR_1);
    VAR_2->instance.shape = VAR_0->input(0).shape();
    VLOG(1) << ""CollectiveAllToAll group_size "" << VAR_2->group.group_size
            << "" group_key "" << VAR_2->group.group_key << "" instance_key ""
            << VAR_2->instance.instance_key;
    /* COMMENT_0 */
    Tensor* VAR_7 = nullptr;
    OP_REQUIRES_OK_ASYNC(VAR_0,
                         VAR_0->forward_input_or_allocate_output(
                             {0}, 0, VAR_2->instance.shape, &VAR_7),
                         VAR_3);
    Run(VAR_0, VAR_2, std::move(VAR_3));
  }",,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
     };
     core::RefCountPtr<CollectiveGroupResource> resource;
     OP_REQUIRES_OK_ASYNC(c, LookupResource(c, HandleFromInput(c, 1), &resource),
-                         done);
+                         done_with_cleanup);
 
     Tensor group_assignment = c->input(2);
 ","{'deleted_lines': ['                         done);'], 'added_lines': ['                         done_with_cleanup);']}",True,"TensorFlow is an open source platform for machine learning. In affected versions the async implementation of `CollectiveReduceV2` suffers from a memory leak and a use after free. This occurs due to the asynchronous computation and the fact that objects that have been `std::move()`d from are still accessed. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, as this version is the only one that is also affected.",7.8,HIGH,2,valid,2021-10-04T23:09:45Z,3
CVE-2021-45098,['CWE-Other'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,OISF/suricata,"stream/tcp: handle RST with MD5 or AO header

Special handling for RST packets if they have an TCP MD5 or AO header option.
The options hash can't be validated. The end host might be able to validate
it, as it can have a key/password that was communicated out of band.

The sender could use this to move the TCP state to 'CLOSED', leading to
a desync of the TCP session.

This patch builds on top of
843d0b7a10bb (""stream: support RST getting lost/ignored"")

It flags the receiver as having received an RST and moves the TCP state
into the CLOSED state. It then reverts this if the sender continues to
send traffic. In this case it sets the following event:

    stream-event:suspected_rst_inject;

Bug: #4710.",50e2b973eeec7172991bf8f544ab06fb782b97df,https://github.com/OISF/suricata/commit/50e2b973eeec7172991bf8f544ab06fb782b97df,src/stream-tcp.c,StreamTcpValidateRst,"static int StreamTcpValidateRst(TcpSession *ssn, Packet *p)
{
uint8_t os_policy;
if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {
if (!StreamTcpValidateTimestamp(ssn, p)) {
SCReturnInt(0);
}
}
if (PKT_IS_TOSERVER(p)) {
if (ssn->server.os_policy == 0)
StreamTcpSetOSPolicy(&ssn->server, p);
os_policy = ssn->server.os_policy;
if (p->tcph->th_flags & TH_ACK &&
TCP_GET_ACK(p) && StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {
SCLogDebug(""ssn %p: rejecting because of invalid ack value"", ssn);
StreamTcpSetEvent(p, STREAM_RST_INVALID_ACK);
SCReturnInt(0);
}
} else {
if (ssn->client.os_policy == 0)
StreamTcpSetOSPolicy(&ssn->client, p);
os_policy = ssn->client.os_policy;
if (p->tcph->th_flags & TH_ACK &&
TCP_GET_ACK(p) && StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {
SCLogDebug(""ssn %p: rejecting because of invalid ack value"", ssn);
StreamTcpSetEvent(p, STREAM_RST_INVALID_ACK);
SCReturnInt(0);
}
}
if (ssn->flags & STREAMTCP_FLAG_ASYNC) {
if (PKT_IS_TOSERVER(p)) {
if (SEQ_GEQ(TCP_GET_SEQ(p), ssn->client.next_seq)) {
SCLogDebug(""ssn %p: ASYNC accept RST"", ssn);
return 1;
}
} else {
if (SEQ_GEQ(TCP_GET_SEQ(p), ssn->server.next_seq)) {
SCLogDebug(""ssn %p: ASYNC accept RST"", ssn);
return 1;
}
}
SCLogDebug(""ssn %p: ASYNC reject RST"", ssn);
return 0;
}
switch (os_policy) {
case OS_POLICY_HPUX11:
if(PKT_IS_TOSERVER(p)){
if(SEQ_GEQ(TCP_GET_SEQ(p), ssn->client.next_seq)) {
SCLogDebug(""reset is Valid! Packet SEQ: %"" PRIu32 """",
TCP_GET_SEQ(p));
return 1;
} else {
SCLogDebug(""reset is not Valid! Packet SEQ: %"" PRIu32 "" ""
""and server SEQ: %"" PRIu32 """", TCP_GET_SEQ(p),
ssn->client.next_seq);
return 0;
}
} else { 
if(SEQ_GEQ(TCP_GET_SEQ(p), ssn->server.next_seq)) {
SCLogDebug(""reset is valid! Packet SEQ: %"" PRIu32 """",
TCP_GET_SEQ(p));
return 1;
} else {
SCLogDebug(""reset is not valid! Packet SEQ: %"" PRIu32 "" ""
""and client SEQ: %"" PRIu32 """", TCP_GET_SEQ(p),
ssn->server.next_seq);
return 0;
}
}
break;
case OS_POLICY_OLD_LINUX:
case OS_POLICY_LINUX:
case OS_POLICY_SOLARIS:
if(PKT_IS_TOSERVER(p)){
if(SEQ_GEQ((TCP_GET_SEQ(p)+p->payload_len),
ssn->client.last_ack))
{ 
if(SEQ_LT(TCP_GET_SEQ(p),
(ssn->client.next_seq + ssn->client.window)))
{
SCLogDebug(""reset is Valid! Packet SEQ: %"" PRIu32 """",
TCP_GET_SEQ(p));
return 1;
}
} else {
SCLogDebug(""reset is not valid! Packet SEQ: %"" PRIu32 "" and""
"" server SEQ: %"" PRIu32 """", TCP_GET_SEQ(p),
ssn->client.next_seq);
return 0;
}
} else { 
if(SEQ_GEQ((TCP_GET_SEQ(p) + p->payload_len),
ssn->server.last_ack))
{ 
if(SEQ_LT(TCP_GET_SEQ(p),
(ssn->server.next_seq + ssn->server.window)))
{
SCLogDebug(""reset is Valid! Packet SEQ: %"" PRIu32 """",
TCP_GET_SEQ(p));
return 1;
}
} else {
SCLogDebug(""reset is not valid! Packet SEQ: %"" PRIu32 "" and""
"" client SEQ: %"" PRIu32 """", TCP_GET_SEQ(p),
ssn->server.next_seq);
return 0;
}
}
break;
default:
case OS_POLICY_BSD:
case OS_POLICY_FIRST:
case OS_POLICY_HPUX10:
case OS_POLICY_IRIX:
case OS_POLICY_MACOS:
case OS_POLICY_LAST:
case OS_POLICY_WINDOWS:
case OS_POLICY_WINDOWS2K3:
case OS_POLICY_VISTA:
if(PKT_IS_TOSERVER(p)) {
if(SEQ_EQ(TCP_GET_SEQ(p), ssn->client.next_seq)) {
SCLogDebug(""reset is valid! Packet SEQ: %"" PRIu32 """",
TCP_GET_SEQ(p));
return 1;
} else {
SCLogDebug(""reset is not valid! Packet SEQ: %"" PRIu32 "" ""
""and server SEQ: %"" PRIu32 """", TCP_GET_SEQ(p),
ssn->client.next_seq);
return 0;
}
} else { 
if (SEQ_EQ(TCP_GET_SEQ(p), ssn->server.next_seq)) {
SCLogDebug(""reset is valid! Packet SEQ: %"" PRIu32 "" Stream %u"",
TCP_GET_SEQ(p), ssn->server.next_seq);
return 1;
} else {
SCLogDebug(""reset is not valid! Packet SEQ: %"" PRIu32 "" and""
"" client SEQ: %"" PRIu32 """",
TCP_GET_SEQ(p), ssn->server.next_seq);
return 0;
}
}
break;
}
return 0;
}","static int StreamTcpValidateRst(TcpSession *VAR_0, Packet *VAR_1)
{
uint8_t VAR_2;
if (VAR_0->flags & VAR_3) {
if (!StreamTcpValidateTimestamp(VAR_0, VAR_1)) {
SCReturnInt(0);
}
}
if (PKT_IS_TOSERVER(VAR_1)) {
if (VAR_0->server.os_policy == 0)
StreamTcpSetOSPolicy(&VAR_0->server, VAR_1);
VAR_2 = VAR_0->server.os_policy;
if (VAR_1->tcph->th_flags & VAR_4 &&
TCP_GET_ACK(VAR_1) && StreamTcpValidateAck(VAR_0, &VAR_0->server, VAR_1) == -1) {
SCLogDebug(""ssn %p: rejecting because of invalid ack value"", VAR_0);
StreamTcpSetEvent(VAR_1, VAR_5);
SCReturnInt(0);
}
} else {
if (VAR_0->client.os_policy == 0)
StreamTcpSetOSPolicy(&VAR_0->client, VAR_1);
VAR_2 = VAR_0->client.os_policy;
if (VAR_1->tcph->th_flags & VAR_4 &&
TCP_GET_ACK(VAR_1) && StreamTcpValidateAck(VAR_0, &VAR_0->client, VAR_1) == -1) {
SCLogDebug(""ssn %p: rejecting because of invalid ack value"", VAR_0);
StreamTcpSetEvent(VAR_1, VAR_5);
SCReturnInt(0);
}
}
if (VAR_0->flags & VAR_6) {
if (PKT_IS_TOSERVER(VAR_1)) {
if (SEQ_GEQ(TCP_GET_SEQ(VAR_1), VAR_0->client.next_seq)) {
SCLogDebug(""ssn %p: ASYNC accept RST"", VAR_0);
return 1;
}
} else {
if (SEQ_GEQ(TCP_GET_SEQ(VAR_1), VAR_0->server.next_seq)) {
SCLogDebug(""ssn %p: ASYNC accept RST"", VAR_0);
return 1;
}
}
SCLogDebug(""ssn %p: ASYNC reject RST"", VAR_0);
return 0;
}
switch (VAR_2) {
case VAR_7:
if(PKT_IS_TOSERVER(VAR_1)){
if(SEQ_GEQ(TCP_GET_SEQ(VAR_1), VAR_0->client.next_seq)) {
SCLogDebug(""reset is Valid! Packet SEQ: %"" VAR_8 """",
TCP_GET_SEQ(VAR_1));
return 1;
} else {
SCLogDebug(""reset is not Valid! Packet SEQ: %"" VAR_8 "" ""
""and server SEQ: %"" VAR_8 """", TCP_GET_SEQ(VAR_1),
VAR_0->client.next_seq);
return 0;
}
} else { 
if(SEQ_GEQ(TCP_GET_SEQ(VAR_1), VAR_0->server.next_seq)) {
SCLogDebug(""reset is valid! Packet SEQ: %"" VAR_8 """",
TCP_GET_SEQ(VAR_1));
return 1;
} else {
SCLogDebug(""reset is not valid! Packet SEQ: %"" VAR_8 "" ""
""and client SEQ: %"" VAR_8 """", TCP_GET_SEQ(VAR_1),
VAR_0->server.next_seq);
return 0;
}
}
break;
case VAR_9:
case VAR_10:
case VAR_11:
if(PKT_IS_TOSERVER(VAR_1)){
if(SEQ_GEQ((TCP_GET_SEQ(VAR_1)+VAR_1->payload_len),
VAR_0->client.last_ack))
{ 
if(SEQ_LT(TCP_GET_SEQ(VAR_1),
(VAR_0->client.next_seq + VAR_0->client.window)))
{
SCLogDebug(""reset is Valid! Packet SEQ: %"" VAR_8 """",
TCP_GET_SEQ(VAR_1));
return 1;
}
} else {
SCLogDebug(""reset is not valid! Packet SEQ: %"" VAR_8 "" and""
"" server SEQ: %"" VAR_8 """", TCP_GET_SEQ(VAR_1),
VAR_0->client.next_seq);
return 0;
}
} else { 
if(SEQ_GEQ((TCP_GET_SEQ(VAR_1) + VAR_1->payload_len),
VAR_0->server.last_ack))
{ 
if(SEQ_LT(TCP_GET_SEQ(VAR_1),
(VAR_0->server.next_seq + VAR_0->server.window)))
{
SCLogDebug(""reset is Valid! Packet SEQ: %"" VAR_8 """",
TCP_GET_SEQ(VAR_1));
return 1;
}
} else {
SCLogDebug(""reset is not valid! Packet SEQ: %"" VAR_8 "" and""
"" client SEQ: %"" VAR_8 """", TCP_GET_SEQ(VAR_1),
VAR_0->server.next_seq);
return 0;
}
}
break;
default:
case VAR_12:
case VAR_13:
case VAR_14:
case VAR_15:
case VAR_16:
case VAR_17:
case VAR_18:
case VAR_19:
case VAR_20:
if(PKT_IS_TOSERVER(VAR_1)) {
if(SEQ_EQ(TCP_GET_SEQ(VAR_1), VAR_0->client.next_seq)) {
SCLogDebug(""reset is valid! Packet SEQ: %"" VAR_8 """",
TCP_GET_SEQ(VAR_1));
return 1;
} else {
SCLogDebug(""reset is not valid! Packet SEQ: %"" VAR_8 "" ""
""and server SEQ: %"" VAR_8 """", TCP_GET_SEQ(VAR_1),
VAR_0->client.next_seq);
return 0;
}
} else { 
if (SEQ_EQ(TCP_GET_SEQ(VAR_1), VAR_0->server.next_seq)) {
SCLogDebug(""reset is valid! Packet SEQ: %"" VAR_8 "" Stream %u"",
TCP_GET_SEQ(VAR_1), VAR_0->server.next_seq);
return 1;
} else {
SCLogDebug(""reset is not valid! Packet SEQ: %"" VAR_8 "" and""
"" client SEQ: %"" VAR_8 """",
TCP_GET_SEQ(VAR_1), VAR_0->server.next_seq);
return 0;
}
}
break;
}
return 0;
}",OISF/suricata/50e2b973eeec7172991bf8f544ab06fb782b97df/stream-tcp.c/vul/before/0.json,"static int StreamTcpValidateRst(TcpSession *ssn, Packet *p)
{
    uint8_t os_policy;

    if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {
        if (!StreamTcpValidateTimestamp(ssn, p)) {
            SCReturnInt(0);
        }
    }

    /* Set up the os_policy to be used in validating the RST packets based on
       target system */
    if (PKT_IS_TOSERVER(p)) {
        if (ssn->server.os_policy == 0)
            StreamTcpSetOSPolicy(&ssn->server, p);

        os_policy = ssn->server.os_policy;

        if (p->tcph->th_flags & TH_ACK &&
                TCP_GET_ACK(p) && StreamTcpValidateAck(ssn, &ssn->server, p) == -1) {
            SCLogDebug(""ssn %p: rejecting because of invalid ack value"", ssn);
            StreamTcpSetEvent(p, STREAM_RST_INVALID_ACK);
            SCReturnInt(0);
        }

    } else {
        if (ssn->client.os_policy == 0)
            StreamTcpSetOSPolicy(&ssn->client, p);

        os_policy = ssn->client.os_policy;

        if (p->tcph->th_flags & TH_ACK &&
                TCP_GET_ACK(p) && StreamTcpValidateAck(ssn, &ssn->client, p) == -1) {
            SCLogDebug(""ssn %p: rejecting because of invalid ack value"", ssn);
            StreamTcpSetEvent(p, STREAM_RST_INVALID_ACK);
            SCReturnInt(0);
        }
    }

    /* RFC 2385 md5 signature header or RFC 5925 TCP AO headerpresent. Since we can't
     * validate these (requires key that is set/transfered out of band), we can't know
     * if the RST will be accepted or rejected by the end host. We accept it, but keep
     * tracking if the sender of it ignores it, which would be a sign of injection. */
    if (p->tcpvars.md5_option_present || p->tcpvars.ao_option_present) {
        TcpStream *receiver_stream;
        if (PKT_IS_TOSERVER(p)) {
            receiver_stream = &ssn->server;
        } else {
            receiver_stream = &ssn->client;
        }
        SCLogDebug(""ssn %p: setting STREAMTCP_STREAM_FLAG_RST_RECV on receiver stream"", ssn);
        receiver_stream->flags |= STREAMTCP_STREAM_FLAG_RST_RECV;
    }

    if (ssn->flags & STREAMTCP_FLAG_ASYNC) {
        if (PKT_IS_TOSERVER(p)) {
            if (SEQ_GEQ(TCP_GET_SEQ(p), ssn->client.next_seq)) {
                SCLogDebug(""ssn %p: ASYNC accept RST"", ssn);
                return 1;
            }
        } else {
            if (SEQ_GEQ(TCP_GET_SEQ(p), ssn->server.next_seq)) {
                SCLogDebug(""ssn %p: ASYNC accept RST"", ssn);
                return 1;
            }
        }
        SCLogDebug(""ssn %p: ASYNC reject RST"", ssn);
        return 0;
    }

    switch (os_policy) {
        case OS_POLICY_HPUX11:
            if(PKT_IS_TOSERVER(p)){
                if(SEQ_GEQ(TCP_GET_SEQ(p), ssn->client.next_seq)) {
                    SCLogDebug(""reset is Valid! Packet SEQ: %"" PRIu32 """",
                                TCP_GET_SEQ(p));
                    return 1;
                } else {
                    SCLogDebug(""reset is not Valid! Packet SEQ: %"" PRIu32 "" ""
                               ""and server SEQ: %"" PRIu32 """", TCP_GET_SEQ(p),
                                ssn->client.next_seq);
                    return 0;
                }
            } else { /* implied to client */
                if(SEQ_GEQ(TCP_GET_SEQ(p), ssn->server.next_seq)) {
                    SCLogDebug(""reset is valid! Packet SEQ: %"" PRIu32 """",
                                TCP_GET_SEQ(p));
                    return 1;
                } else {
                    SCLogDebug(""reset is not valid! Packet SEQ: %"" PRIu32 "" ""
                               ""and client SEQ: %"" PRIu32 """", TCP_GET_SEQ(p),
                                ssn->server.next_seq);
                    return 0;
                }
            }
            break;
        case OS_POLICY_OLD_LINUX:
        case OS_POLICY_LINUX:
        case OS_POLICY_SOLARIS:
            if(PKT_IS_TOSERVER(p)){
                if(SEQ_GEQ((TCP_GET_SEQ(p)+p->payload_len),
                            ssn->client.last_ack))
                { /*window base is needed !!*/
                    if(SEQ_LT(TCP_GET_SEQ(p),
                              (ssn->client.next_seq + ssn->client.window)))
                    {
                        SCLogDebug(""reset is Valid! Packet SEQ: %"" PRIu32 """",
                                    TCP_GET_SEQ(p));
                        return 1;
                    }
                } else {
                    SCLogDebug(""reset is not valid! Packet SEQ: %"" PRIu32 "" and""
                               "" server SEQ: %"" PRIu32 """", TCP_GET_SEQ(p),
                                ssn->client.next_seq);
                    return 0;
                }
            } else { /* implied to client */
                if(SEQ_GEQ((TCP_GET_SEQ(p) + p->payload_len),
                            ssn->server.last_ack))
                { /*window base is needed !!*/
                    if(SEQ_LT(TCP_GET_SEQ(p),
                                (ssn->server.next_seq + ssn->server.window)))
                    {
                        SCLogDebug(""reset is Valid! Packet SEQ: %"" PRIu32 """",
                                    TCP_GET_SEQ(p));
                        return 1;
                    }
                } else {
                    SCLogDebug(""reset is not valid! Packet SEQ: %"" PRIu32 "" and""
                               "" client SEQ: %"" PRIu32 """", TCP_GET_SEQ(p),
                                 ssn->server.next_seq);
                    return 0;
                }
            }
            break;
        default:
        case OS_POLICY_BSD:
        case OS_POLICY_FIRST:
        case OS_POLICY_HPUX10:
        case OS_POLICY_IRIX:
        case OS_POLICY_MACOS:
        case OS_POLICY_LAST:
        case OS_POLICY_WINDOWS:
        case OS_POLICY_WINDOWS2K3:
        case OS_POLICY_VISTA:
            if(PKT_IS_TOSERVER(p)) {
                if(SEQ_EQ(TCP_GET_SEQ(p), ssn->client.next_seq)) {
                    SCLogDebug(""reset is valid! Packet SEQ: %"" PRIu32 """",
                               TCP_GET_SEQ(p));
                    return 1;
                } else {
                    SCLogDebug(""reset is not valid! Packet SEQ: %"" PRIu32 "" ""
                               ""and server SEQ: %"" PRIu32 """", TCP_GET_SEQ(p),
                               ssn->client.next_seq);
                    return 0;
                }
            } else { /* implied to client */
                if (SEQ_EQ(TCP_GET_SEQ(p), ssn->server.next_seq)) {
                    SCLogDebug(""reset is valid! Packet SEQ: %"" PRIu32 "" Stream %u"",
                                TCP_GET_SEQ(p), ssn->server.next_seq);
                    return 1;
                } else {
                    SCLogDebug(""reset is not valid! Packet SEQ: %"" PRIu32 "" and""
                               "" client SEQ: %"" PRIu32 """",
                               TCP_GET_SEQ(p), ssn->server.next_seq);
                    return 0;
                }
            }
            break;
    }
    return 0;
}","static int StreamTcpValidateRst(TcpSession *VAR_0, Packet *VAR_1)
{
    uint8_t VAR_2;

    if (VAR_0->flags & VAR_3) {
        if (!StreamTcpValidateTimestamp(VAR_0, VAR_1)) {
            SCReturnInt(0);
        }
    }

    /* COMMENT_0 */
                       
    if (PKT_IS_TOSERVER(VAR_1)) {
        if (VAR_0->server.os_policy == 0)
            StreamTcpSetOSPolicy(&VAR_0->server, VAR_1);

        VAR_2 = VAR_0->server.os_policy;

        if (VAR_1->tcph->th_flags & VAR_4 &&
                TCP_GET_ACK(VAR_1) && StreamTcpValidateAck(VAR_0, &VAR_0->server, VAR_1) == -1) {
            SCLogDebug(""ssn %p: rejecting because of invalid ack value"", VAR_0);
            StreamTcpSetEvent(VAR_1, VAR_5);
            SCReturnInt(0);
        }

    } else {
        if (VAR_0->client.os_policy == 0)
            StreamTcpSetOSPolicy(&VAR_0->client, VAR_1);

        VAR_2 = VAR_0->client.os_policy;

        if (VAR_1->tcph->th_flags & VAR_4 &&
                TCP_GET_ACK(VAR_1) && StreamTcpValidateAck(VAR_0, &VAR_0->client, VAR_1) == -1) {
            SCLogDebug(""ssn %p: rejecting because of invalid ack value"", VAR_0);
            StreamTcpSetEvent(VAR_1, VAR_5);
            SCReturnInt(0);
        }
    }

    /* COMMENT_2 */
                                                                                      
                                                                                      
                                                                                      
    if (VAR_1->tcpvars.md5_option_present || VAR_1->tcpvars.ao_option_present) {
        TcpStream *VAR_6;
        if (PKT_IS_TOSERVER(VAR_1)) {
            VAR_6 = &VAR_0->server;
        } else {
            VAR_6 = &VAR_0->client;
        }
        SCLogDebug(""ssn %p: setting STREAMTCP_STREAM_FLAG_RST_RECV on receiver stream"", VAR_0);
        VAR_6->flags |= VAR_7;
    }

    if (VAR_0->flags & VAR_8) {
        if (PKT_IS_TOSERVER(VAR_1)) {
            if (SEQ_GEQ(TCP_GET_SEQ(VAR_1), VAR_0->client.next_seq)) {
                SCLogDebug(""ssn %p: ASYNC accept RST"", VAR_0);
                return 1;
            }
        } else {
            if (SEQ_GEQ(TCP_GET_SEQ(VAR_1), VAR_0->server.next_seq)) {
                SCLogDebug(""ssn %p: ASYNC accept RST"", VAR_0);
                return 1;
            }
        }
        SCLogDebug(""ssn %p: ASYNC reject RST"", VAR_0);
        return 0;
    }

    switch (VAR_2) {
        case VAR_9:
            if(PKT_IS_TOSERVER(VAR_1)){
                if(SEQ_GEQ(TCP_GET_SEQ(VAR_1), VAR_0->client.next_seq)) {
                    SCLogDebug(""reset is Valid! Packet SEQ: %"" VAR_10 """",
                                TCP_GET_SEQ(VAR_1));
                    return 1;
                } else {
                    SCLogDebug(""reset is not Valid! Packet SEQ: %"" VAR_10 "" ""
                               ""and server SEQ: %"" VAR_10 """", TCP_GET_SEQ(VAR_1),
                                VAR_0->client.next_seq);
                    return 0;
                }
            } else { /* COMMENT_6 */
                if(SEQ_GEQ(TCP_GET_SEQ(VAR_1), VAR_0->server.next_seq)) {
                    SCLogDebug(""reset is valid! Packet SEQ: %"" VAR_10 """",
                                TCP_GET_SEQ(VAR_1));
                    return 1;
                } else {
                    SCLogDebug(""reset is not valid! Packet SEQ: %"" VAR_10 "" ""
                               ""and client SEQ: %"" VAR_10 """", TCP_GET_SEQ(VAR_1),
                                VAR_0->server.next_seq);
                    return 0;
                }
            }
            break;
        case VAR_11:
        case VAR_12:
        case VAR_13:
            if(PKT_IS_TOSERVER(VAR_1)){
                if(SEQ_GEQ((TCP_GET_SEQ(VAR_1)+VAR_1->payload_len),
                            VAR_0->client.last_ack))
                { /* COMMENT_7 */
                    if(SEQ_LT(TCP_GET_SEQ(VAR_1),
                              (VAR_0->client.next_seq + VAR_0->client.window)))
                    {
                        SCLogDebug(""reset is Valid! Packet SEQ: %"" VAR_10 """",
                                    TCP_GET_SEQ(VAR_1));
                        return 1;
                    }
                } else {
                    SCLogDebug(""reset is not valid! Packet SEQ: %"" VAR_10 "" and""
                               "" server SEQ: %"" VAR_10 """", TCP_GET_SEQ(VAR_1),
                                VAR_0->client.next_seq);
                    return 0;
                }
            } else { /* COMMENT_6 */
                if(SEQ_GEQ((TCP_GET_SEQ(VAR_1) + VAR_1->payload_len),
                            VAR_0->server.last_ack))
                { /* COMMENT_7 */
                    if(SEQ_LT(TCP_GET_SEQ(VAR_1),
                                (VAR_0->server.next_seq + VAR_0->server.window)))
                    {
                        SCLogDebug(""reset is Valid! Packet SEQ: %"" VAR_10 """",
                                    TCP_GET_SEQ(VAR_1));
                        return 1;
                    }
                } else {
                    SCLogDebug(""reset is not valid! Packet SEQ: %"" VAR_10 "" and""
                               "" client SEQ: %"" VAR_10 """", TCP_GET_SEQ(VAR_1),
                                 VAR_0->server.next_seq);
                    return 0;
                }
            }
            break;
        default:
        case VAR_14:
        case VAR_15:
        case VAR_16:
        case VAR_17:
        case VAR_18:
        case VAR_19:
        case VAR_20:
        case VAR_21:
        case VAR_22:
            if(PKT_IS_TOSERVER(VAR_1)) {
                if(SEQ_EQ(TCP_GET_SEQ(VAR_1), VAR_0->client.next_seq)) {
                    SCLogDebug(""reset is valid! Packet SEQ: %"" VAR_10 """",
                               TCP_GET_SEQ(VAR_1));
                    return 1;
                } else {
                    SCLogDebug(""reset is not valid! Packet SEQ: %"" VAR_10 "" ""
                               ""and server SEQ: %"" VAR_10 """", TCP_GET_SEQ(VAR_1),
                               VAR_0->client.next_seq);
                    return 0;
                }
            } else { /* COMMENT_6 */
                if (SEQ_EQ(TCP_GET_SEQ(VAR_1), VAR_0->server.next_seq)) {
                    SCLogDebug(""reset is valid! Packet SEQ: %"" VAR_10 "" Stream %u"",
                                TCP_GET_SEQ(VAR_1), VAR_0->server.next_seq);
                    return 1;
                } else {
                    SCLogDebug(""reset is not valid! Packet SEQ: %"" VAR_10 "" and""
                               "" client SEQ: %"" VAR_10 """",
                               TCP_GET_SEQ(VAR_1), VAR_0->server.next_seq);
                    return 0;
                }
            }
            break;
    }
    return 0;
}",OISF/suricata/50e2b973eeec7172991bf8f544ab06fb782b97df/stream-tcp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,5 @@
 static int StreamTcpValidateRst(TcpSession *ssn, Packet *p)
 {
-
     uint8_t os_policy;
 
     if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) {
@@ -36,6 +35,21 @@
             StreamTcpSetEvent(p, STREAM_RST_INVALID_ACK);
             SCReturnInt(0);
         }
+    }
+
+    /* RFC 2385 md5 signature header or RFC 5925 TCP AO headerpresent. Since we can't
+     * validate these (requires key that is set/transfered out of band), we can't know
+     * if the RST will be accepted or rejected by the end host. We accept it, but keep
+     * tracking if the sender of it ignores it, which would be a sign of injection. */
+    if (p->tcpvars.md5_option_present || p->tcpvars.ao_option_present) {
+        TcpStream *receiver_stream;
+        if (PKT_IS_TOSERVER(p)) {
+            receiver_stream = &ssn->server;
+        } else {
+            receiver_stream = &ssn->client;
+        }
+        SCLogDebug(""ssn %p: setting STREAMTCP_STREAM_FLAG_RST_RECV on receiver stream"", ssn);
+        receiver_stream->flags |= STREAMTCP_STREAM_FLAG_RST_RECV;
     }
 
     if (ssn->flags & STREAMTCP_FLAG_ASYNC) {","{'deleted_lines': [''], 'added_lines': ['    }', '', ""    /* RFC 2385 md5 signature header or RFC 5925 TCP AO headerpresent. Since we can't"", ""     * validate these (requires key that is set/transfered out of band), we can't know"", '     * if the RST will be accepted or rejected by the end host. We accept it, but keep', '     * tracking if the sender of it ignores it, which would be a sign of injection. */', '    if (p->tcpvars.md5_option_present || p->tcpvars.ao_option_present) {', '        TcpStream *receiver_stream;', '        if (PKT_IS_TOSERVER(p)) {', '            receiver_stream = &ssn->server;', '        } else {', '            receiver_stream = &ssn->client;', '        }', '        SCLogDebug(""ssn %p: setting STREAMTCP_STREAM_FLAG_RST_RECV on receiver stream"", ssn);', '        receiver_stream->flags |= STREAMTCP_STREAM_FLAG_RST_RECV;']}",True,"An issue was discovered in Suricata before 6.0.4. It is possible to bypass/evade any HTTP-based signature by faking an RST TCP packet with random TCP options of the md5header from the client side. After the three-way handshake, it's possible to inject an RST ACK with a random TCP md5header option. Then, the client can send an HTTP GET request with a forbidden URL. The server will ignore the RST ACK and send the response HTTP packet for the client's request. These packets will not trigger a Suricata reject action.",7.5,HIGH,2,valid,2021-10-05T12:48:27Z,3
CVE-2021-45098,['CWE-Other'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,OISF/suricata,"stream/tcp: handle RST with MD5 or AO header

Special handling for RST packets if they have an TCP MD5 or AO header option.
The options hash can't be validated. The end host might be able to validate
it, as it can have a key/password that was communicated out of band.

The sender could use this to move the TCP state to 'CLOSED', leading to
a desync of the TCP session.

This patch builds on top of
843d0b7a10bb (""stream: support RST getting lost/ignored"")

It flags the receiver as having received an RST and moves the TCP state
into the CLOSED state. It then reverts this if the sender continues to
send traffic. In this case it sets the following event:

    stream-event:suspected_rst_inject;

Bug: #4710.",50e2b973eeec7172991bf8f544ab06fb782b97df,https://github.com/OISF/suricata/commit/50e2b973eeec7172991bf8f544ab06fb782b97df,src/decode-tcp.c,DecodeTCPOptions,"static void DecodeTCPOptions(Packet *p, const uint8_t *pkt, uint16_t pktlen)
{
uint8_t tcp_opt_cnt = 0;
TCPOpt tcp_opts[TCP_OPTMAX];
uint16_t plen = pktlen;
while (plen)
{
const uint8_t type = *pkt;
if (type == TCP_OPT_EOL) {
break;
} else if (type == TCP_OPT_NOP) {
pkt++;
plen--;
} else {
if (plen < 2) {
break;
}
const uint8_t olen = *(pkt+1);
if (unlikely(olen > plen || olen < 2)) {
ENGINE_SET_INVALID_EVENT(p, TCP_OPT_INVALID_LEN);
return;
}
tcp_opts[tcp_opt_cnt].type = type;
tcp_opts[tcp_opt_cnt].len  = olen;
tcp_opts[tcp_opt_cnt].data = (olen > 2) ? (pkt+2) : NULL;
switch (type) {
case TCP_OPT_WS:
if (olen != TCP_OPT_WS_LEN) {
ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);
} else {
if (p->tcpvars.ws.type != 0) {
ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);
} else {
SET_OPTS(p->tcpvars.ws, tcp_opts[tcp_opt_cnt]);
}
}
break;
case TCP_OPT_MSS:
if (olen != TCP_OPT_MSS_LEN) {
ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);
} else {
if (p->tcpvars.mss.type != 0) {
ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);
} else {
SET_OPTS(p->tcpvars.mss, tcp_opts[tcp_opt_cnt]);
}
}
break;
case TCP_OPT_SACKOK:
if (olen != TCP_OPT_SACKOK_LEN) {
ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);
} else {
if (p->tcpvars.sackok.type != 0) {
ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);
} else {
SET_OPTS(p->tcpvars.sackok, tcp_opts[tcp_opt_cnt]);
}
}
break;
case TCP_OPT_TS:
if (olen != TCP_OPT_TS_LEN) {
ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);
} else {
if (p->tcpvars.ts_set) {
ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);
} else {
uint32_t values[2];
memcpy(&values, tcp_opts[tcp_opt_cnt].data, sizeof(values));
p->tcpvars.ts_val = SCNtohl(values[0]);
p->tcpvars.ts_ecr = SCNtohl(values[1]);
p->tcpvars.ts_set = true;
}
}
break;
case TCP_OPT_SACK:
SCLogDebug(""SACK option, len %u"", olen);
if ((olen != 2) &&
(olen < TCP_OPT_SACK_MIN_LEN ||
olen > TCP_OPT_SACK_MAX_LEN ||
!((olen - 2) % 8 == 0)))
{
ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);
} else {
if (p->tcpvars.sack.type != 0) {
ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);
} else {
SET_OPTS(p->tcpvars.sack, tcp_opts[tcp_opt_cnt]);
}
}
break;
case TCP_OPT_TFO:
SCLogDebug(""TFO option, len %u"", olen);
if ((olen != 2) && (olen < TCP_OPT_TFO_MIN_LEN || olen > TCP_OPT_TFO_MAX_LEN ||
!(((olen - 2) & 0x1) == 0))) {
ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);
} else {
if (p->tcpvars.tfo.type != 0) {
ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);
} else {
SET_OPTS(p->tcpvars.tfo, tcp_opts[tcp_opt_cnt]);
}
}
break;
case TCP_OPT_EXP1:
case TCP_OPT_EXP2:
SCLogDebug(""TCP EXP option, len %u"", olen);
if (olen == 4 || olen == 12) {
uint16_t magic = SCNtohs(*(uint16_t *)tcp_opts[tcp_opt_cnt].data);
if (magic == 0xf989) {
if (p->tcpvars.tfo.type != 0) {
ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);
} else {
SET_OPTS(p->tcpvars.tfo, tcp_opts[tcp_opt_cnt]);
p->tcpvars.tfo.type = TCP_OPT_TFO;                             }
}
} else {
ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);
}
break;
}
pkt += olen;
plen -= olen;
tcp_opt_cnt++;
}
}
}","static void DecodeTCPOptions(Packet *VAR_0, const uint8_t *VAR_1, uint16_t VAR_2)
{
uint8_t VAR_3 = 0;
TCPOpt VAR_4[VAR_5];
uint16_t VAR_6 = VAR_2;
while (VAR_6)
{
const uint8_t VAR_7 = *VAR_1;
if (VAR_7 == VAR_8) {
break;
} else if (VAR_7 == VAR_9) {
VAR_1++;
VAR_6--;
} else {
if (VAR_6 < 2) {
break;
}
const uint8_t VAR_10 = *(VAR_1+1);
if (unlikely(VAR_10 > VAR_6 || VAR_10 < 2)) {
ENGINE_SET_INVALID_EVENT(VAR_0, VAR_11);
return;
}
VAR_4[VAR_3].type = VAR_7;
VAR_4[VAR_3].len  = VAR_10;
VAR_4[VAR_3].data = (VAR_10 > 2) ? (VAR_1+2) : NULL;
switch (VAR_7) {
case VAR_12:
if (VAR_10 != VAR_13) {
ENGINE_SET_EVENT(VAR_0,VAR_11);
} else {
if (VAR_0->tcpvars.ws.type != 0) {
ENGINE_SET_EVENT(VAR_0,VAR_14);
} else {
SET_OPTS(VAR_0->tcpvars.ws, VAR_4[VAR_3]);
}
}
break;
case VAR_15:
if (VAR_10 != VAR_16) {
ENGINE_SET_EVENT(VAR_0,VAR_11);
} else {
if (VAR_0->tcpvars.mss.type != 0) {
ENGINE_SET_EVENT(VAR_0,VAR_14);
} else {
SET_OPTS(VAR_0->tcpvars.mss, VAR_4[VAR_3]);
}
}
break;
case VAR_17:
if (VAR_10 != VAR_18) {
ENGINE_SET_EVENT(VAR_0,VAR_11);
} else {
if (VAR_0->tcpvars.sackok.type != 0) {
ENGINE_SET_EVENT(VAR_0,VAR_14);
} else {
SET_OPTS(VAR_0->tcpvars.sackok, VAR_4[VAR_3]);
}
}
break;
case VAR_19:
if (VAR_10 != VAR_20) {
ENGINE_SET_EVENT(VAR_0,VAR_11);
} else {
if (VAR_0->tcpvars.ts_set) {
ENGINE_SET_EVENT(VAR_0,VAR_14);
} else {
uint32_t VAR_21[2];
memcpy(&VAR_21, VAR_4[VAR_3].data, sizeof(VAR_21));
VAR_0->tcpvars.ts_val = SCNtohl(VAR_21[0]);
VAR_0->tcpvars.ts_ecr = SCNtohl(VAR_21[1]);
VAR_0->tcpvars.ts_set = true;
}
}
break;
case VAR_22:
SCLogDebug(""SACK option, len %u"", VAR_10);
if ((VAR_10 != 2) &&
(VAR_10 < VAR_23 ||
VAR_10 > VAR_24 ||
!((VAR_10 - 2) % 8 == 0)))
{
ENGINE_SET_EVENT(VAR_0,VAR_11);
} else {
if (VAR_0->tcpvars.sack.type != 0) {
ENGINE_SET_EVENT(VAR_0,VAR_14);
} else {
SET_OPTS(VAR_0->tcpvars.sack, VAR_4[VAR_3]);
}
}
break;
case VAR_25:
SCLogDebug(""TFO option, len %u"", VAR_10);
if ((VAR_10 != 2) && (VAR_10 < VAR_26 || VAR_10 > VAR_27 ||
!(((VAR_10 - 2) & 0x1) == 0))) {
ENGINE_SET_EVENT(VAR_0,VAR_11);
} else {
if (VAR_0->tcpvars.tfo.type != 0) {
ENGINE_SET_EVENT(VAR_0,VAR_14);
} else {
SET_OPTS(VAR_0->tcpvars.tfo, VAR_4[VAR_3]);
}
}
break;
case VAR_28:
case VAR_29:
SCLogDebug(""TCP EXP option, len %u"", VAR_10);
if (VAR_10 == 4 || VAR_10 == 12) {
uint16_t VAR_30 = SCNtohs(*(uint16_t *)VAR_4[VAR_3].data);
if (VAR_30 == 0xf989) {
if (VAR_0->tcpvars.tfo.type != 0) {
ENGINE_SET_EVENT(VAR_0,VAR_14);
} else {
SET_OPTS(VAR_0->tcpvars.tfo, VAR_4[VAR_3]);
VAR_0->tcpvars.tfo.type = VAR_25; 
}
}
} else {
ENGINE_SET_EVENT(VAR_0,VAR_11);
}
break;
}
VAR_1 += VAR_10;
VAR_6 -= VAR_10;
VAR_3++;
}
}
}",OISF/suricata/50e2b973eeec7172991bf8f544ab06fb782b97df/decode-tcp.c/vul/before/0.json,"static void DecodeTCPOptions(Packet *p, const uint8_t *pkt, uint16_t pktlen)
{
    uint8_t tcp_opt_cnt = 0;
    TCPOpt tcp_opts[TCP_OPTMAX];

    uint16_t plen = pktlen;
    while (plen)
    {
        const uint8_t type = *pkt;

        /* single byte options */
        if (type == TCP_OPT_EOL) {
            break;
        } else if (type == TCP_OPT_NOP) {
            pkt++;
            plen--;

        /* multibyte options */
        } else {
            if (plen < 2) {
                break;
            }

            const uint8_t olen = *(pkt+1);

            /* we already know that the total options len is valid,
             * so here the len of the specific option must be bad.
             * Also check for invalid lengths 0 and 1. */
            if (unlikely(olen > plen || olen < 2)) {
                ENGINE_SET_INVALID_EVENT(p, TCP_OPT_INVALID_LEN);
                return;
            }

            tcp_opts[tcp_opt_cnt].type = type;
            tcp_opts[tcp_opt_cnt].len  = olen;
            tcp_opts[tcp_opt_cnt].data = (olen > 2) ? (pkt+2) : NULL;

            /* we are parsing the most commonly used opts to prevent
             * us from having to walk the opts list for these all the
             * time. */
            switch (type) {
                case TCP_OPT_WS:
                    if (olen != TCP_OPT_WS_LEN) {
                        ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);
                    } else {
                        if (p->tcpvars.ws.type != 0) {
                            ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);
                        } else {
                            SET_OPTS(p->tcpvars.ws, tcp_opts[tcp_opt_cnt]);
                        }
                    }
                    break;
                case TCP_OPT_MSS:
                    if (olen != TCP_OPT_MSS_LEN) {
                        ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);
                    } else {
                        if (p->tcpvars.mss.type != 0) {
                            ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);
                        } else {
                            SET_OPTS(p->tcpvars.mss, tcp_opts[tcp_opt_cnt]);
                        }
                    }
                    break;
                case TCP_OPT_SACKOK:
                    if (olen != TCP_OPT_SACKOK_LEN) {
                        ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);
                    } else {
                        if (p->tcpvars.sackok.type != 0) {
                            ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);
                        } else {
                            SET_OPTS(p->tcpvars.sackok, tcp_opts[tcp_opt_cnt]);
                        }
                    }
                    break;
                case TCP_OPT_TS:
                    if (olen != TCP_OPT_TS_LEN) {
                        ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);
                    } else {
                        if (p->tcpvars.ts_set) {
                            ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);
                        } else {
                            uint32_t values[2];
                            memcpy(&values, tcp_opts[tcp_opt_cnt].data, sizeof(values));
                            p->tcpvars.ts_val = SCNtohl(values[0]);
                            p->tcpvars.ts_ecr = SCNtohl(values[1]);
                            p->tcpvars.ts_set = true;
                        }
                    }
                    break;
                case TCP_OPT_SACK:
                    SCLogDebug(""SACK option, len %u"", olen);
                    if ((olen != 2) &&
                           (olen < TCP_OPT_SACK_MIN_LEN ||
                            olen > TCP_OPT_SACK_MAX_LEN ||
                            !((olen - 2) % 8 == 0)))
                    {
                        ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);
                    } else {
                        if (p->tcpvars.sack.type != 0) {
                            ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);
                        } else {
                            SET_OPTS(p->tcpvars.sack, tcp_opts[tcp_opt_cnt]);
                        }
                    }
                    break;
                case TCP_OPT_TFO:
                    SCLogDebug(""TFO option, len %u"", olen);
                    if ((olen != 2) && (olen < TCP_OPT_TFO_MIN_LEN || olen > TCP_OPT_TFO_MAX_LEN ||
                                               !(((olen - 2) & 0x1) == 0))) {
                        ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);
                    } else {
                        if (p->tcpvars.tfo.type != 0) {
                            ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);
                        } else {
                            SET_OPTS(p->tcpvars.tfo, tcp_opts[tcp_opt_cnt]);
                        }
                    }
                    break;
                /* experimental options, could be TFO */
                case TCP_OPT_EXP1:
                case TCP_OPT_EXP2:
                    SCLogDebug(""TCP EXP option, len %u"", olen);
                    if (olen == 4 || olen == 12) {
                        uint16_t magic = SCNtohs(*(uint16_t *)tcp_opts[tcp_opt_cnt].data);
                        if (magic == 0xf989) {
                            if (p->tcpvars.tfo.type != 0) {
                                ENGINE_SET_EVENT(p,TCP_OPT_DUPLICATE);
                            } else {
                                SET_OPTS(p->tcpvars.tfo, tcp_opts[tcp_opt_cnt]);
                                p->tcpvars.tfo.type = TCP_OPT_TFO; // treat as regular TFO
                            }
                        }
                    } else {
                        ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);
                    }
                    break;
                /* RFC 2385 MD5 option */
                case TCP_OPT_MD5:
                    SCLogDebug(""MD5 option, len %u"", olen);
                    if (olen != 18) {
                        ENGINE_SET_INVALID_EVENT(p,TCP_OPT_INVALID_LEN);
                    } else {
                        /* we can't validate the option as the key is out of band */
                        p->tcpvars.md5_option_present = true;
                    }
                    break;
                /* RFC 5925 AO option */
                case TCP_OPT_AO:
                    SCLogDebug(""AU option, len %u"", olen);
                    if (olen < 4) {
                        ENGINE_SET_INVALID_EVENT(p,TCP_OPT_INVALID_LEN);
                    } else {
                        /* we can't validate the option as the key is out of band */
                        p->tcpvars.ao_option_present = true;
                    }
                    break;
            }

            pkt += olen;
            plen -= olen;
            tcp_opt_cnt++;
        }
    }
}","static void DecodeTCPOptions(Packet *VAR_0, const uint8_t *VAR_1, uint16_t VAR_2)
{
    uint8_t VAR_3 = 0;
    TCPOpt VAR_4[VAR_5];

    uint16_t VAR_6 = VAR_2;
    while (VAR_6)
    {
        const uint8_t VAR_7 = *VAR_1;

        /* COMMENT_0 */
        if (VAR_7 == VAR_8) {
            break;
        } else if (VAR_7 == VAR_9) {
            VAR_1++;
            VAR_6--;

        /* COMMENT_1 */
        } else {
            if (VAR_6 < 2) {
                break;
            }

            const uint8_t VAR_10 = *(VAR_1+1);

            /* COMMENT_2 */
                                                                  
                                                         
            if (unlikely(VAR_10 > VAR_6 || VAR_10 < 2)) {
                ENGINE_SET_INVALID_EVENT(VAR_0, VAR_11);
                return;
            }

            VAR_4[VAR_3].type = VAR_7;
            VAR_4[VAR_3].len  = VAR_10;
            VAR_4[VAR_3].data = (VAR_10 > 2) ? (VAR_1+2) : NULL;

            /* COMMENT_5 */
                                                                     
                       
            switch (VAR_7) {
                case VAR_12:
                    if (VAR_10 != VAR_13) {
                        ENGINE_SET_EVENT(VAR_0,VAR_11);
                    } else {
                        if (VAR_0->tcpvars.ws.type != 0) {
                            ENGINE_SET_EVENT(VAR_0,VAR_14);
                        } else {
                            SET_OPTS(VAR_0->tcpvars.ws, VAR_4[VAR_3]);
                        }
                    }
                    break;
                case VAR_15:
                    if (VAR_10 != VAR_16) {
                        ENGINE_SET_EVENT(VAR_0,VAR_11);
                    } else {
                        if (VAR_0->tcpvars.mss.type != 0) {
                            ENGINE_SET_EVENT(VAR_0,VAR_14);
                        } else {
                            SET_OPTS(VAR_0->tcpvars.mss, VAR_4[VAR_3]);
                        }
                    }
                    break;
                case VAR_17:
                    if (VAR_10 != VAR_18) {
                        ENGINE_SET_EVENT(VAR_0,VAR_11);
                    } else {
                        if (VAR_0->tcpvars.sackok.type != 0) {
                            ENGINE_SET_EVENT(VAR_0,VAR_14);
                        } else {
                            SET_OPTS(VAR_0->tcpvars.sackok, VAR_4[VAR_3]);
                        }
                    }
                    break;
                case VAR_19:
                    if (VAR_10 != VAR_20) {
                        ENGINE_SET_EVENT(VAR_0,VAR_11);
                    } else {
                        if (VAR_0->tcpvars.ts_set) {
                            ENGINE_SET_EVENT(VAR_0,VAR_14);
                        } else {
                            uint32_t VAR_21[2];
                            memcpy(&VAR_21, VAR_4[VAR_3].data, sizeof(VAR_21));
                            VAR_0->tcpvars.ts_val = SCNtohl(VAR_21[0]);
                            VAR_0->tcpvars.ts_ecr = SCNtohl(VAR_21[1]);
                            VAR_0->tcpvars.ts_set = true;
                        }
                    }
                    break;
                case VAR_22:
                    SCLogDebug(""SACK option, len %u"", VAR_10);
                    if ((VAR_10 != 2) &&
                           (VAR_10 < VAR_23 ||
                            VAR_10 > VAR_24 ||
                            !((VAR_10 - 2) % 8 == 0)))
                    {
                        ENGINE_SET_EVENT(VAR_0,VAR_11);
                    } else {
                        if (VAR_0->tcpvars.sack.type != 0) {
                            ENGINE_SET_EVENT(VAR_0,VAR_14);
                        } else {
                            SET_OPTS(VAR_0->tcpvars.sack, VAR_4[VAR_3]);
                        }
                    }
                    break;
                case VAR_25:
                    SCLogDebug(""TFO option, len %u"", VAR_10);
                    if ((VAR_10 != 2) && (VAR_10 < VAR_26 || VAR_10 > VAR_27 ||
                                               !(((VAR_10 - 2) & 0x1) == 0))) {
                        ENGINE_SET_EVENT(VAR_0,VAR_11);
                    } else {
                        if (VAR_0->tcpvars.tfo.type != 0) {
                            ENGINE_SET_EVENT(VAR_0,VAR_14);
                        } else {
                            SET_OPTS(VAR_0->tcpvars.tfo, VAR_4[VAR_3]);
                        }
                    }
                    break;
                /* COMMENT_8 */
                case VAR_28:
                case VAR_29:
                    SCLogDebug(""TCP EXP option, len %u"", VAR_10);
                    if (VAR_10 == 4 || VAR_10 == 12) {
                        uint16_t VAR_30 = SCNtohs(*(uint16_t *)VAR_4[VAR_3].data);
                        if (VAR_30 == 0xf989) {
                            if (VAR_0->tcpvars.tfo.type != 0) {
                                ENGINE_SET_EVENT(VAR_0,VAR_14);
                            } else {
                                SET_OPTS(VAR_0->tcpvars.tfo, VAR_4[VAR_3]);
                                VAR_0->tcpvars.tfo.type = VAR_25; /* COMMENT_9 */
                            }
                        }
                    } else {
                        ENGINE_SET_EVENT(VAR_0,VAR_11);
                    }
                    break;
                /* COMMENT_10 */
                case VAR_31:
                    SCLogDebug(""MD5 option, len %u"", VAR_10);
                    if (VAR_10 != 18) {
                        ENGINE_SET_INVALID_EVENT(VAR_0,VAR_11);
                    } else {
                        /* COMMENT_11 */
                        VAR_0->tcpvars.md5_option_present = true;
                    }
                    break;
                /* COMMENT_12 */
                case VAR_32:
                    SCLogDebug(""AU option, len %u"", VAR_10);
                    if (VAR_10 < 4) {
                        ENGINE_SET_INVALID_EVENT(VAR_0,VAR_11);
                    } else {
                        /* COMMENT_11 */
                        VAR_0->tcpvars.ao_option_present = true;
                    }
                    break;
            }

            VAR_1 += VAR_10;
            VAR_6 -= VAR_10;
            VAR_3++;
        }
    }
}",OISF/suricata/50e2b973eeec7172991bf8f544ab06fb782b97df/decode-tcp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -134,6 +134,26 @@
                         ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);
                     }
                     break;
+                /* RFC 2385 MD5 option */
+                case TCP_OPT_MD5:
+                    SCLogDebug(""MD5 option, len %u"", olen);
+                    if (olen != 18) {
+                        ENGINE_SET_INVALID_EVENT(p,TCP_OPT_INVALID_LEN);
+                    } else {
+                        /* we can't validate the option as the key is out of band */
+                        p->tcpvars.md5_option_present = true;
+                    }
+                    break;
+                /* RFC 5925 AO option */
+                case TCP_OPT_AO:
+                    SCLogDebug(""AU option, len %u"", olen);
+                    if (olen < 4) {
+                        ENGINE_SET_INVALID_EVENT(p,TCP_OPT_INVALID_LEN);
+                    } else {
+                        /* we can't validate the option as the key is out of band */
+                        p->tcpvars.ao_option_present = true;
+                    }
+                    break;
             }
 
             pkt += olen;","{'deleted_lines': [], 'added_lines': ['                /* RFC 2385 MD5 option */', '                case TCP_OPT_MD5:', '                    SCLogDebug(""MD5 option, len %u"", olen);', '                    if (olen != 18) {', '                        ENGINE_SET_INVALID_EVENT(p,TCP_OPT_INVALID_LEN);', '                    } else {', ""                        /* we can't validate the option as the key is out of band */"", '                        p->tcpvars.md5_option_present = true;', '                    }', '                    break;', '                /* RFC 5925 AO option */', '                case TCP_OPT_AO:', '                    SCLogDebug(""AU option, len %u"", olen);', '                    if (olen < 4) {', '                        ENGINE_SET_INVALID_EVENT(p,TCP_OPT_INVALID_LEN);', '                    } else {', ""                        /* we can't validate the option as the key is out of band */"", '                        p->tcpvars.ao_option_present = true;', '                    }', '                    break;']}",True,"An issue was discovered in Suricata before 6.0.4. It is possible to bypass/evade any HTTP-based signature by faking an RST TCP packet with random TCP options of the md5header from the client side. After the three-way handshake, it's possible to inject an RST ACK with a random TCP md5header option. Then, the client can send an HTTP GET request with a forbidden URL. The server will ignore the RST ACK and send the response HTTP packet for the client's request. These packets will not trigger a Suricata reject action.",7.5,HIGH,2,valid,2021-10-05T12:48:27Z,3
CVE-2021-45098,['CWE-Other'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,OISF/suricata,"stream/tcp: handle RST with MD5 or AO header

Special handling for RST packets if they have an TCP MD5 or AO header option.
The options hash can't be validated. The end host might be able to validate
it, as it can have a key/password that was communicated out of band.

The sender could use this to move the TCP state to 'CLOSED', leading to
a desync of the TCP session.

This patch builds on top of
843d0b7a10bb (""stream: support RST getting lost/ignored"")

It flags the receiver as having received an RST and moves the TCP state
into the CLOSED state. It then reverts this if the sender continues to
send traffic. In this case it sets the following event:

    stream-event:suspected_rst_inject;

Bug: #4710.",50e2b973eeec7172991bf8f544ab06fb782b97df,https://github.com/OISF/suricata/commit/50e2b973eeec7172991bf8f544ab06fb782b97df,src/stream-tcp.c,StreamTcpPacketStateClosed,"static int StreamTcpPacketStateClosed(ThreadVars *tv, Packet *p,
StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq)
{
if (ssn == NULL)
return -1;
if (p->tcph->th_flags & TH_RST) {
SCLogDebug(""RST on closed state"");
return 0;
}
TcpStream *stream = NULL, *ostream = NULL;
if (PKT_IS_TOSERVER(p)) {
stream = &ssn->client;
ostream = &ssn->server;
} else {
stream = &ssn->server;
ostream = &ssn->client;
}
SCLogDebug(""stream %s ostream %s"",
stream->flags & STREAMTCP_STREAM_FLAG_RST_RECV?""true"":""false"",
ostream->flags & STREAMTCP_STREAM_FLAG_RST_RECV ? ""true"":""false"");
if ((stream->flags & STREAMTCP_STREAM_FLAG_RST_RECV) == 0) {
if (ostream->flags & STREAMTCP_STREAM_FLAG_RST_RECV) {
if (StreamTcpStateDispatch(tv, p, stt, ssn, &stt->pseudo_queue, ssn->pstate) < 0)
return -1;
}
}
return 0;
}","static int StreamTcpPacketStateClosed(ThreadVars *VAR_0, Packet *VAR_1,
StreamTcpThread *VAR_2, TcpSession *VAR_3, PacketQueueNoLock *VAR_4)
{
if (VAR_3 == NULL)
return -1;
if (VAR_1->tcph->th_flags & VAR_5) {
SCLogDebug(""RST on closed state"");
return 0;
}
TcpStream *VAR_6 = NULL, *VAR_7 = NULL;
if (PKT_IS_TOSERVER(VAR_1)) {
VAR_6 = &VAR_3->client;
VAR_7 = &VAR_3->server;
} else {
VAR_6 = &VAR_3->server;
VAR_7 = &VAR_3->client;
}
SCLogDebug(""stream %s ostream %s"",
VAR_6->flags & VAR_8?""true"":""false"",
VAR_7->flags & VAR_8 ? ""true"":""false"");
if ((VAR_6->flags & VAR_8) == 0) {
if (VAR_7->flags & VAR_8) {
if (StreamTcpStateDispatch(VAR_0, VAR_1, VAR_2, VAR_3, &VAR_2->pseudo_queue, VAR_3->pstate) < 0)
return -1;
}
}
return 0;
}",OISF/suricata/50e2b973eeec7172991bf8f544ab06fb782b97df/stream-tcp.c/vul/before/1.json,"static int StreamTcpPacketStateClosed(ThreadVars *tv, Packet *p,
        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq)
{
    if (ssn == NULL)
        return -1;

    if (p->tcph->th_flags & TH_RST) {
        SCLogDebug(""RST on closed state"");
        return 0;
    }

    TcpStream *stream = NULL, *ostream = NULL;
    if (PKT_IS_TOSERVER(p)) {
        stream = &ssn->client;
        ostream = &ssn->server;
    } else {
        stream = &ssn->server;
        ostream = &ssn->client;
    }

    SCLogDebug(""stream %s ostream %s"",
            stream->flags & STREAMTCP_STREAM_FLAG_RST_RECV?""true"":""false"",
            ostream->flags & STREAMTCP_STREAM_FLAG_RST_RECV ? ""true"":""false"");

    /* if we've seen a RST on our direction, but not on the other
     * see if we perhaps need to continue processing anyway. */
    if ((stream->flags & STREAMTCP_STREAM_FLAG_RST_RECV) == 0) {
        if (ostream->flags & STREAMTCP_STREAM_FLAG_RST_RECV) {
            if (StreamTcpStateDispatch(tv, p, stt, ssn, &stt->pseudo_queue, ssn->pstate) < 0)
                return -1;
            /* if state is still ""closed"", it wasn't updated by our dispatch. */
            if (ssn->state == TCP_CLOSED)
                ssn->state = ssn->pstate;
        }
    }
    return 0;
}","static int StreamTcpPacketStateClosed(ThreadVars *VAR_0, Packet *VAR_1,
        StreamTcpThread *VAR_2, TcpSession *VAR_3, PacketQueueNoLock *VAR_4)
{
    if (VAR_3 == NULL)
        return -1;

    if (VAR_1->tcph->th_flags & VAR_5) {
        SCLogDebug(""RST on closed state"");
        return 0;
    }

    TcpStream *VAR_6 = NULL, *VAR_7 = NULL;
    if (PKT_IS_TOSERVER(VAR_1)) {
        VAR_6 = &VAR_3->client;
        VAR_7 = &VAR_3->server;
    } else {
        VAR_6 = &VAR_3->server;
        VAR_7 = &VAR_3->client;
    }

    SCLogDebug(""stream %s ostream %s"",
            VAR_6->flags & VAR_8?""true"":""false"",
            VAR_7->flags & VAR_8 ? ""true"":""false"");

    /* COMMENT_0 */
                                                               
    if ((VAR_6->flags & VAR_8) == 0) {
        if (VAR_7->flags & VAR_8) {
            if (StreamTcpStateDispatch(VAR_0, VAR_1, VAR_2, VAR_3, &VAR_2->pseudo_queue, VAR_3->pstate) < 0)
                return -1;
            /* COMMENT_2 */
            if (VAR_3->state == VAR_9)
                VAR_3->state = VAR_3->pstate;
        }
    }
    return 0;
}",OISF/suricata/50e2b973eeec7172991bf8f544ab06fb782b97df/stream-tcp.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -28,6 +28,9 @@
         if (ostream->flags & STREAMTCP_STREAM_FLAG_RST_RECV) {
             if (StreamTcpStateDispatch(tv, p, stt, ssn, &stt->pseudo_queue, ssn->pstate) < 0)
                 return -1;
+            /* if state is still ""closed"", it wasn't updated by our dispatch. */
+            if (ssn->state == TCP_CLOSED)
+                ssn->state = ssn->pstate;
         }
     }
     return 0;","{'deleted_lines': [], 'added_lines': ['            /* if state is still ""closed"", it wasn\'t updated by our dispatch. */', '            if (ssn->state == TCP_CLOSED)', '                ssn->state = ssn->pstate;']}",True,"An issue was discovered in Suricata before 6.0.4. It is possible to bypass/evade any HTTP-based signature by faking an RST TCP packet with random TCP options of the md5header from the client side. After the three-way handshake, it's possible to inject an RST ACK with a random TCP md5header option. Then, the client can send an HTTP GET request with a forbidden URL. The server will ignore the RST ACK and send the response HTTP packet for the client's request. These packets will not trigger a Suricata reject action.",7.5,HIGH,2,valid,2021-10-05T12:48:27Z,3
CVE-2021-41219,['CWE-125'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"Validate that matrix dimension sizes in SparseMatMul are positive.

PiperOrigin-RevId: 401149683
Change-Id: Ib33eafc561a39c8741ece80b2edce6d4aae9a57d",e6cf28c72ba2eb949ca950d834dd6d66bb01cfae,https://github.com/tensorflow/tensorflow/commit/e6cf28c72ba2eb949ca950d834dd6d66bb01cfae,tensorflow/core/kernels/sparse_matmul_op.cc,Compute,"void Compute(OpKernelContext* ctx) override {
const Tensor& a = ctx->input(0);
const Tensor& b = ctx->input(1);
OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(a.shape()),
errors::InvalidArgument(""a is not a matrix""));
OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(b.shape()),
errors::InvalidArgument(""b is not a matrix""));
const int m = transpose_a_ ? a.dim_size(1) : a.dim_size(0);
const int k = transpose_a_ ? a.dim_size(0) : a.dim_size(1);
const int n = transpose_b_ ? b.dim_size(0) : b.dim_size(1);
const int k2 = transpose_b_ ? b.dim_size(1) : b.dim_size(0);
OP_REQUIRES(ctx, k == k2,
errors::InvalidArgument(
""Matrix size incompatible: a: "", a.shape().DebugString(),
"", b: "", b.shape().DebugString()));
Tensor* output = nullptr;
OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({m, n}), &output));
if (k == 0) {
functor::SetZeroFunctor<CPUDevice, float> f;
f(ctx->eigen_device<CPUDevice>(), output->flat<float>());
return;
}
auto out = output->matrix<float>();
std::unique_ptr<Tensor> a_float;
std::unique_ptr<Tensor> b_float;
if (!a_is_sparse_ && !b_is_sparse_) {
auto left = &a;
auto right = &b;
if (std::is_same<TL, bfloat16>::value) {
a_float.reset(new Tensor(DT_FLOAT, a.shape()));
BFloat16ToFloat(a.flat<bfloat16>().data(),
a_float->flat<float>().data(), a.NumElements());
left = a_float.get();
}
if (std::is_same<TR, bfloat16>::value) {
b_float.reset(new Tensor(DT_FLOAT, b.shape()));
BFloat16ToFloat(b.flat<bfloat16>().data(),
b_float->flat<float>().data(), b.NumElements());
right = b_float.get();
}
Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> dim_pair;
dim_pair[0].first = transpose_a_ ? 0 : 1;
dim_pair[0].second = transpose_b_ ? 1 : 0;
out.device(ctx->template eigen_device<CPUDevice>()) =
left->matrix<float>().contract(right->matrix<float>(), dim_pair);
return;
}
auto left = &a;
auto right = &b;
bool transpose_output = false;
bool transpose_a = transpose_a_;
bool transpose_b = transpose_b_;
if (!a_is_sparse_) {
std::swap(left, right);
std::swap(transpose_a, transpose_b);
transpose_a = !transpose_a;
transpose_b = !transpose_b;
transpose_output = !transpose_output;
}
std::unique_ptr<Tensor> right_tr;
if (transpose_b) {
OP_REQUIRES(ctx, right->dim_size(0) != 0,
errors::InvalidArgument(""b has an entry 0 in it's shape.""));
OP_REQUIRES(ctx, right->dim_size(1) != 0,
errors::InvalidArgument(""b has an entry 0 in it's shape.""));
right_tr.reset(
new Tensor(right->dtype(),
TensorShape({right->dim_size(1), right->dim_size(0)})));
const auto perm = dsizes_10();
if (transpose_output) {
right_tr->matrix<TL>().device(ctx->template eigen_device<CPUDevice>()) =
right->matrix<TL>().shuffle(perm);
} else {
right_tr->matrix<TR>().device(ctx->template eigen_device<CPUDevice>()) =
right->matrix<TR>().shuffle(perm);
}
right = right_tr.get();
}
if (transpose_output) {
DoMatMul<TR, TL>::Compute(&this->cache_tr_, left->matrix<TR>(),
right->matrix<TL>(), transpose_a,
ctx->device()->tensorflow_cpu_worker_threads(),
transpose_output, &out);
} else {
DoMatMul<TL, TR>::Compute(&this->cache_nt_, left->matrix<TL>(),
right->matrix<TR>(), transpose_a,
ctx->device()->tensorflow_cpu_worker_threads(),
transpose_output, &out);
}
}","void Compute(OpKernelContext* VAR_0) override {
const Tensor& VAR_1 = VAR_0->input(0);
const Tensor& VAR_2 = VAR_0->input(1);
OP_REQUIRES(VAR_0, TensorShapeUtils::IsMatrix(VAR_1.shape()),
errors::InvalidArgument(""a is not a matrix""));
OP_REQUIRES(VAR_0, TensorShapeUtils::IsMatrix(VAR_2.shape()),
errors::InvalidArgument(""b is not a matrix""));
const int VAR_3 = VAR_4 ? VAR_1.dim_size(1) : VAR_1.dim_size(0);
const int VAR_5 = VAR_4 ? VAR_1.dim_size(0) : VAR_1.dim_size(1);
const int VAR_6 = VAR_7 ? VAR_2.dim_size(0) : VAR_2.dim_size(1);
const int VAR_8 = VAR_7 ? VAR_2.dim_size(1) : VAR_2.dim_size(0);
OP_REQUIRES(VAR_0, VAR_5 == VAR_8,
errors::InvalidArgument(
""Matrix size incompatible: a: "", VAR_1.shape().DebugString(),
"", b: "", VAR_2.shape().DebugString()));
Tensor* VAR_9 = nullptr;
OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(0, TensorShape({VAR_3, VAR_6}), &VAR_9));
if (VAR_5 == 0) {
functor::SetZeroFunctor<CPUDevice, float> VAR_10;
VAR_10(VAR_0->eigen_device<CPUDevice>(), VAR_9->flat<float>());
return;
}
auto VAR_11 = VAR_9->matrix<float>();
std::unique_ptr<Tensor> VAR_12;
std::unique_ptr<Tensor> VAR_13;
if (!VAR_14 && !VAR_15) {
auto VAR_16 = &VAR_1;
auto VAR_17 = &VAR_2;
if (std::is_same<TL, bfloat16>::value) {
VAR_12.reset(new Tensor(VAR_18, VAR_1.shape()));
BFloat16ToFloat(VAR_1.flat<bfloat16>().data(),
VAR_12->flat<float>().data(), VAR_1.NumElements());
VAR_16 = VAR_12.get();
}
if (std::is_same<TR, bfloat16>::value) {
VAR_13.reset(new Tensor(VAR_18, VAR_2.shape()));
BFloat16ToFloat(VAR_2.flat<bfloat16>().data(),
VAR_13->flat<float>().data(), VAR_2.NumElements());
VAR_17 = VAR_13.get();
}
Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> VAR_19;
VAR_19[0].first = VAR_4 ? 0 : 1;
VAR_19[0].second = VAR_7 ? 1 : 0;
VAR_11.device(VAR_0->template eigen_device<CPUDevice>()) =
VAR_16->matrix<float>().contract(VAR_17->matrix<float>(), VAR_19);
return;
}
auto VAR_16 = &VAR_1;
auto VAR_17 = &VAR_2;
bool VAR_20 = false;
bool VAR_21 = VAR_4;
bool VAR_22 = VAR_7;
if (!VAR_14) {
std::swap(VAR_16, VAR_17);
std::swap(VAR_21, VAR_22);
VAR_21 = !VAR_21;
VAR_22 = !VAR_22;
VAR_20 = !VAR_20;
}
std::unique_ptr<Tensor> VAR_23;
if (VAR_22) {
OP_REQUIRES(VAR_0, VAR_17->dim_size(0) != 0,
errors::InvalidArgument(""b has an entry 0 in it's shape.""));
OP_REQUIRES(VAR_0, VAR_17->dim_size(1) != 0,
errors::InvalidArgument(""b has an entry 0 in it's shape.""));
VAR_23.reset(
new Tensor(VAR_17->dtype(),
TensorShape({VAR_17->dim_size(1), VAR_17->dim_size(0)})));
const auto VAR_24 = dsizes_10();
if (VAR_20) {
VAR_23->matrix<TL>().device(VAR_0->template eigen_device<CPUDevice>()) =
VAR_17->matrix<TL>().shuffle(VAR_24);
} else {
VAR_23->matrix<TR>().device(VAR_0->template eigen_device<CPUDevice>()) =
VAR_17->matrix<TR>().shuffle(VAR_24);
}
VAR_17 = VAR_23.get();
}
if (VAR_20) {
DoMatMul<TR, TL>::Compute(&this->cache_tr_, VAR_16->matrix<TR>(),
VAR_17->matrix<TL>(), VAR_21,
VAR_0->device()->tensorflow_cpu_worker_threads(),
VAR_20, &VAR_11);
} else {
DoMatMul<TL, TR>::Compute(&this->cache_nt_, VAR_16->matrix<TL>(),
VAR_17->matrix<TR>(), VAR_21,
VAR_0->device()->tensorflow_cpu_worker_threads(),
VAR_20, &VAR_11);
}
}",,"void Compute(OpKernelContext* ctx) override {
    const Tensor& a = ctx->input(0);
    const Tensor& b = ctx->input(1);
    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(a.shape()),
                errors::InvalidArgument(""a is not a matrix""));
    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(b.shape()),
                errors::InvalidArgument(""b is not a matrix""));

    const int m = transpose_a_ ? a.dim_size(1) : a.dim_size(0);
    const int k = transpose_a_ ? a.dim_size(0) : a.dim_size(1);
    const int n = transpose_b_ ? b.dim_size(0) : b.dim_size(1);
    const int k2 = transpose_b_ ? b.dim_size(1) : b.dim_size(0);

    OP_REQUIRES(ctx, k == k2,
                errors::InvalidArgument(
                    ""Matrix size incompatible: a: "", a.shape().DebugString(),
                    "", b: "", b.shape().DebugString()));
    OP_REQUIRES(ctx, m >= 0 && n >= 0 && k >= 0,
                errors::InvalidArgument(
                    ""Matrix dimensions cannot be negative: a: "",
                    a.shape().DebugString(), "", b: "", b.shape().DebugString()));
    Tensor* output = nullptr;
    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({m, n}), &output));

    // Return early if at least one of the output dimension size is 0.
    if (m == 0 || n == 0) {
      return;
    }

    if (k == 0) {
      // If the inner dimension k in the matrix multiplication is zero, we fill
      // the output with zeros.
      functor::SetZeroFunctor<CPUDevice, float> f;
      f(ctx->eigen_device<CPUDevice>(), output->flat<float>());
      return;
    }

    auto out = output->matrix<float>();

    std::unique_ptr<Tensor> a_float;
    std::unique_ptr<Tensor> b_float;
    if (!a_is_sparse_ && !b_is_sparse_) {
      auto left = &a;
      auto right = &b;
      // TODO(agarwal): multi-thread the conversions from bfloat16 to float.
      if (std::is_same<TL, bfloat16>::value) {
        a_float.reset(new Tensor(DT_FLOAT, a.shape()));
        BFloat16ToFloat(a.flat<bfloat16>().data(),
                        a_float->flat<float>().data(), a.NumElements());
        left = a_float.get();
      }
      if (std::is_same<TR, bfloat16>::value) {
        b_float.reset(new Tensor(DT_FLOAT, b.shape()));
        BFloat16ToFloat(b.flat<bfloat16>().data(),
                        b_float->flat<float>().data(), b.NumElements());
        right = b_float.get();
      }
      Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> dim_pair;
      dim_pair[0].first = transpose_a_ ? 0 : 1;
      dim_pair[0].second = transpose_b_ ? 1 : 0;

      out.device(ctx->template eigen_device<CPUDevice>()) =
          left->matrix<float>().contract(right->matrix<float>(), dim_pair);
      return;
    }

    auto left = &a;
    auto right = &b;
    bool transpose_output = false;
    bool transpose_a = transpose_a_;
    bool transpose_b = transpose_b_;
    if (!a_is_sparse_) {
      // Swap the order of multiplications using the identity:
      // A * B = (B' *  A')'.
      std::swap(left, right);
      std::swap(transpose_a, transpose_b);
      transpose_a = !transpose_a;
      transpose_b = !transpose_b;
      transpose_output = !transpose_output;
    }

    std::unique_ptr<Tensor> right_tr;
    if (transpose_b) {
      // TODO(agarwal): avoid transposing the matrix here and directly handle
      // transpose in CreateDenseSlices.
      OP_REQUIRES(ctx, right->dim_size(0) != 0,
                  errors::InvalidArgument(""b has an entry 0 in it's shape.""));
      OP_REQUIRES(ctx, right->dim_size(1) != 0,
                  errors::InvalidArgument(""b has an entry 0 in it's shape.""));
      right_tr.reset(
          new Tensor(right->dtype(),
                     TensorShape({right->dim_size(1), right->dim_size(0)})));

      const auto perm = dsizes_10();
      if (transpose_output) {
        right_tr->matrix<TL>().device(ctx->template eigen_device<CPUDevice>()) =
            right->matrix<TL>().shuffle(perm);
      } else {
        right_tr->matrix<TR>().device(ctx->template eigen_device<CPUDevice>()) =
            right->matrix<TR>().shuffle(perm);
      }
      right = right_tr.get();
    }

    if (transpose_output) {
      DoMatMul<TR, TL>::Compute(&this->cache_tr_, left->matrix<TR>(),
                                right->matrix<TL>(), transpose_a,
                                ctx->device()->tensorflow_cpu_worker_threads(),
                                transpose_output, &out);
    } else {
      DoMatMul<TL, TR>::Compute(&this->cache_nt_, left->matrix<TL>(),
                                right->matrix<TR>(), transpose_a,
                                ctx->device()->tensorflow_cpu_worker_threads(),
                                transpose_output, &out);
    }
  }","void Compute(OpKernelContext* VAR_0) override {
    const Tensor& VAR_1 = VAR_0->input(0);
    const Tensor& VAR_2 = VAR_0->input(1);
    OP_REQUIRES(VAR_0, TensorShapeUtils::IsMatrix(VAR_1.shape()),
                errors::InvalidArgument(""a is not a matrix""));
    OP_REQUIRES(VAR_0, TensorShapeUtils::IsMatrix(VAR_2.shape()),
                errors::InvalidArgument(""b is not a matrix""));

    const int VAR_3 = VAR_4 ? VAR_1.dim_size(1) : VAR_1.dim_size(0);
    const int VAR_5 = VAR_4 ? VAR_1.dim_size(0) : VAR_1.dim_size(1);
    const int VAR_6 = VAR_7 ? VAR_2.dim_size(0) : VAR_2.dim_size(1);
    const int VAR_8 = VAR_7 ? VAR_2.dim_size(1) : VAR_2.dim_size(0);

    OP_REQUIRES(VAR_0, VAR_5 == VAR_8,
                errors::InvalidArgument(
                    ""Matrix size incompatible: a: "", VAR_1.shape().DebugString(),
                    "", b: "", VAR_2.shape().DebugString()));
    OP_REQUIRES(VAR_0, VAR_3 >= 0 && VAR_6 >= 0 && VAR_5 >= 0,
                errors::InvalidArgument(
                    ""Matrix dimensions cannot be negative: a: "",
                    VAR_1.shape().DebugString(), "", b: "", VAR_2.shape().DebugString()));
    Tensor* VAR_9 = nullptr;
    OP_REQUIRES_OK(VAR_0, VAR_0->allocate_output(0, TensorShape({VAR_3, VAR_6}), &VAR_9));

    /* COMMENT_0 */
    if (VAR_3 == 0 || VAR_6 == 0) {
      return;
    }

    if (VAR_5 == 0) {
      /* COMMENT_1 */
      /* COMMENT_2 */
      functor::SetZeroFunctor<CPUDevice, float> VAR_10;
      VAR_10(VAR_0->eigen_device<CPUDevice>(), VAR_9->flat<float>());
      return;
    }

    auto VAR_11 = VAR_9->matrix<float>();

    std::unique_ptr<Tensor> VAR_12;
    std::unique_ptr<Tensor> VAR_13;
    if (!VAR_14 && !VAR_15) {
      auto VAR_16 = &VAR_1;
      auto VAR_17 = &VAR_2;
      /* COMMENT_3 */
      if (std::is_same<TL, bfloat16>::value) {
        VAR_12.reset(new Tensor(VAR_18, VAR_1.shape()));
        BFloat16ToFloat(VAR_1.flat<bfloat16>().data(),
                        VAR_12->flat<float>().data(), VAR_1.NumElements());
        VAR_16 = VAR_12.get();
      }
      if (std::is_same<TR, bfloat16>::value) {
        VAR_13.reset(new Tensor(VAR_18, VAR_2.shape()));
        BFloat16ToFloat(VAR_2.flat<bfloat16>().data(),
                        VAR_13->flat<float>().data(), VAR_2.NumElements());
        VAR_17 = VAR_13.get();
      }
      Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> VAR_19;
      VAR_19[0].first = VAR_4 ? 0 : 1;
      VAR_19[0].second = VAR_7 ? 1 : 0;

      VAR_11.device(VAR_0->template eigen_device<CPUDevice>()) =
          VAR_16->matrix<float>().contract(VAR_17->matrix<float>(), VAR_19);
      return;
    }

    auto VAR_16 = &VAR_1;
    auto VAR_17 = &VAR_2;
    bool VAR_20 = false;
    bool VAR_21 = VAR_4;
    bool VAR_22 = VAR_7;
    if (!VAR_14) {
      /* COMMENT_4 */
      /* COMMENT_5 */
      std::swap(VAR_16, VAR_17);
      std::swap(VAR_21, VAR_22);
      VAR_21 = !VAR_21;
      VAR_22 = !VAR_22;
      VAR_20 = !VAR_20;
    }

    std::unique_ptr<Tensor> VAR_23;
    if (VAR_22) {
      /* COMMENT_6 */
      /* COMMENT_7 */
      OP_REQUIRES(VAR_0, VAR_17->dim_size(0) != 0,
                  errors::InvalidArgument(""b has an entry 0 in it's shape.""));
      OP_REQUIRES(VAR_0, VAR_17->dim_size(1) != 0,
                  errors::InvalidArgument(""b has an entry 0 in it's shape.""));
      VAR_23.reset(
          new Tensor(VAR_17->dtype(),
                     TensorShape({VAR_17->dim_size(1), VAR_17->dim_size(0)})));

      const auto VAR_24 = dsizes_10();
      if (VAR_20) {
        VAR_23->matrix<TL>().device(VAR_0->template eigen_device<CPUDevice>()) =
            VAR_17->matrix<TL>().shuffle(VAR_24);
      } else {
        VAR_23->matrix<TR>().device(VAR_0->template eigen_device<CPUDevice>()) =
            VAR_17->matrix<TR>().shuffle(VAR_24);
      }
      VAR_17 = VAR_23.get();
    }

    if (VAR_20) {
      DoMatMul<TR, TL>::Compute(&this->cache_tr_, VAR_16->matrix<TR>(),
                                VAR_17->matrix<TL>(), VAR_21,
                                VAR_0->device()->tensorflow_cpu_worker_threads(),
                                VAR_20, &VAR_11);
    } else {
      DoMatMul<TL, TR>::Compute(&this->cache_nt_, VAR_16->matrix<TL>(),
                                VAR_17->matrix<TR>(), VAR_21,
                                VAR_0->device()->tensorflow_cpu_worker_threads(),
                                VAR_20, &VAR_11);
    }
  }",,"--- func_before
+++ func_after
@@ -15,8 +15,17 @@
                 errors::InvalidArgument(
                     ""Matrix size incompatible: a: "", a.shape().DebugString(),
                     "", b: "", b.shape().DebugString()));
+    OP_REQUIRES(ctx, m >= 0 && n >= 0 && k >= 0,
+                errors::InvalidArgument(
+                    ""Matrix dimensions cannot be negative: a: "",
+                    a.shape().DebugString(), "", b: "", b.shape().DebugString()));
     Tensor* output = nullptr;
     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({m, n}), &output));
+
+    // Return early if at least one of the output dimension size is 0.
+    if (m == 0 || n == 0) {
+      return;
+    }
 
     if (k == 0) {
       // If the inner dimension k in the matrix multiplication is zero, we fill","{'deleted_lines': [], 'added_lines': ['    OP_REQUIRES(ctx, m >= 0 && n >= 0 && k >= 0,', '                errors::InvalidArgument(', '                    ""Matrix dimensions cannot be negative: a: "",', '                    a.shape().DebugString(), "", b: "", b.shape().DebugString()));', '', '    // Return early if at least one of the output dimension size is 0.', '    if (m == 0 || n == 0) {', '      return;', '    }']}",True,"TensorFlow is an open source platform for machine learning. In affected versions the code for sparse matrix multiplication is vulnerable to undefined behavior via binding a reference to `nullptr`. This occurs whenever the dimensions of `a` or `b` are 0 or less. In the case on one of these is 0, an empty output tensor should be allocated (to conserve the invariant that output tensors are always allocated when the operation is successful) but nothing should be written to it (that is, we should return early from the kernel implementation). Otherwise, attempts to write to this empty tensor would result in heap OOB access. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",7.8,HIGH,2,valid,2021-10-06T04:54:15Z,3
CVE-2020-12140,['CWE-120'],AV:A/AC:L/Au:N/C:C/I:C/A:C,0,contiki-ng,Fix buffer overflow in ble-l2cap,82356e516a91200857f52ed3e9945739cba2c051,https://github.com/contiki-ng/contiki-ng/commit/82356e516a91200857f52ed3e9945739cba2c051,os/net/mac/ble/ble-l2cap.c,input_l2cap_frame_flow_channel,"static void
input_l2cap_frame_flow_channel(l2cap_channel_t *channel, uint8_t *data, uint16_t data_len)
{
uint16_t frame_len;
uint16_t payload_len;
if(data_len < 4) {
LOG_WARN(""l2cap_frame: illegal L2CAP frame data_len: %d\n"", data_len);
return;
}
if(channel->rx_buffer.sdu_length == 0) {
memcpy(&frame_len, &data[0], 2);
memcpy(&channel->rx_buffer.sdu_length, &data[4], 2);
payload_len = frame_len - 2;
memcpy(channel->rx_buffer.sdu, &data[6], payload_len);
channel->rx_buffer.current_index = payload_len;
} else {
memcpy(&frame_len, &data[0], 2);
payload_len = frame_len;
memcpy(&channel->rx_buffer.sdu[channel->rx_buffer.current_index], &data[4], payload_len);
channel->rx_buffer.current_index += payload_len;
}
if((channel->rx_buffer.sdu_length > 0) &&
(channel->rx_buffer.sdu_length == channel->rx_buffer.current_index)) {
memcpy(packetbuf_dataptr(), channel->rx_buffer.sdu, channel->rx_buffer.sdu_length);
packetbuf_set_datalen(channel->rx_buffer.sdu_length);
NETSTACK_NETWORK.input();
channel->rx_buffer.sdu_length = 0;
channel->rx_buffer.current_index = 0;
}
}","static void
input_l2cap_frame_flow_channel(l2cap_channel_t *VAR_0, uint8_t *VAR_1, uint16_t VAR_2)
{
uint16_t VAR_3;
uint16_t VAR_4;
if(VAR_2 < 4) {
LOG_WARN(""l2cap_frame: illegal L2CAP frame data_len: %d\n"", VAR_2);
return;
}
if(VAR_0->rx_buffer.sdu_length == 0) {
memcpy(&VAR_3, &VAR_1[0], 2);
memcpy(&VAR_0->rx_buffer.sdu_length, &VAR_1[4], 2);
VAR_4 = VAR_3 - 2;
memcpy(VAR_0->rx_buffer.sdu, &VAR_1[6], VAR_4);
VAR_0->rx_buffer.current_index = VAR_4;
} else {
memcpy(&VAR_3, &VAR_1[0], 2);
VAR_4 = VAR_3;
memcpy(&VAR_0->rx_buffer.sdu[VAR_0->rx_buffer.current_index], &VAR_1[4], VAR_4);
VAR_0->rx_buffer.current_index += VAR_4;
}
if((VAR_0->rx_buffer.sdu_length > 0) &&
(VAR_0->rx_buffer.sdu_length == VAR_0->rx_buffer.current_index)) {
memcpy(packetbuf_dataptr(), VAR_0->rx_buffer.sdu, VAR_0->rx_buffer.sdu_length);
packetbuf_set_datalen(VAR_0->rx_buffer.sdu_length);
VAR_5.input();
VAR_0->rx_buffer.sdu_length = 0;
VAR_0->rx_buffer.current_index = 0;
}
}",contiki-ng/82356e516a91200857f52ed3e9945739cba2c051/ble-l2cap.c/vul/before/0.json,"static void
input_l2cap_frame_flow_channel(l2cap_channel_t *channel, uint8_t *data, uint16_t data_len)
{
  uint16_t frame_len;
  uint16_t payload_len;

  if(data_len < 4) {
    LOG_WARN(""l2cap_frame: illegal L2CAP frame data_len: %d\n"", data_len);
    /* a L2CAP frame has a minimum length of 4 */
    return;
  }

  if(channel->rx_buffer.sdu_length == 0) {
    /* handle first fragment */
    memcpy(&frame_len, &data[0], 2);
    payload_len = frame_len - 2;

    if(payload_len > BLE_L2CAP_NODE_MTU) {
    	LOG_WARN(""l2cap_frame: illegal L2CAP frame payload_len: %d\n"", payload_len);
    	/* the payload length may not be larger than the destination buffer */
    	return;
    }

    memcpy(&channel->rx_buffer.sdu_length, &data[4], 2);

    memcpy(channel->rx_buffer.sdu, &data[6], payload_len);
    channel->rx_buffer.current_index = payload_len;
  } else {
    /* subsequent fragment */
    memcpy(&frame_len, &data[0], 2);
    payload_len = frame_len;
    
    if(channel->rx_buffer.current_index + payload_len > BLE_L2CAP_NODE_MTU) {
    	LOG_WARN(""l2cap_frame: illegal L2CAP frame payload_len: %d\n"", payload_len);
    	/* the current index plus the payload length may not be larger than 
	 * the destination buffer */
    	return;
    }

    memcpy(&channel->rx_buffer.sdu[channel->rx_buffer.current_index], &data[4], payload_len);
    channel->rx_buffer.current_index += payload_len;
  }

  if((channel->rx_buffer.sdu_length > 0) &&
     (channel->rx_buffer.sdu_length == channel->rx_buffer.current_index)) {
    /* do not use packetbuf_copyfrom here because the packetbuf_attr
     * must not be cleared */
    memcpy(packetbuf_dataptr(), channel->rx_buffer.sdu, channel->rx_buffer.sdu_length);
    packetbuf_set_datalen(channel->rx_buffer.sdu_length);
    NETSTACK_NETWORK.input();

    /* reset counters */
    channel->rx_buffer.sdu_length = 0;
    channel->rx_buffer.current_index = 0;
  }
}","static void
input_l2cap_frame_flow_channel(l2cap_channel_t *VAR_0, uint8_t *VAR_1, uint16_t VAR_2)
{
  uint16_t VAR_3;
  uint16_t VAR_4;

  if(VAR_2 < 4) {
    LOG_WARN(""l2cap_frame: illegal L2CAP frame data_len: %d\n"", VAR_2);
    /* COMMENT_0 */
    return;
  }

  if(VAR_0->rx_buffer.sdu_length == 0) {
    /* COMMENT_1 */
    memcpy(&VAR_3, &VAR_1[0], 2);
    VAR_4 = VAR_3 - 2;

    if(VAR_4 > VAR_5) {
    	LOG_WARN(""l2cap_frame: illegal L2CAP frame payload_len: %d\n"", VAR_4);
    	/* COMMENT_2 */
    	return;
    }

    memcpy(&VAR_0->rx_buffer.sdu_length, &VAR_1[4], 2);

    memcpy(VAR_0->rx_buffer.sdu, &VAR_1[6], VAR_4);
    VAR_0->rx_buffer.current_index = VAR_4;
  } else {
    /* COMMENT_3 */
    memcpy(&VAR_3, &VAR_1[0], 2);
    VAR_4 = VAR_3;
    
    if(VAR_0->rx_buffer.current_index + VAR_4 > VAR_5) {
    	LOG_WARN(""l2cap_frame: illegal L2CAP frame payload_len: %d\n"", VAR_4);
    	/* COMMENT_4 */
                             
    	return;
    }

    memcpy(&VAR_0->rx_buffer.sdu[VAR_0->rx_buffer.current_index], &VAR_1[4], VAR_4);
    VAR_0->rx_buffer.current_index += VAR_4;
  }

  if((VAR_0->rx_buffer.sdu_length > 0) &&
     (VAR_0->rx_buffer.sdu_length == VAR_0->rx_buffer.current_index)) {
    /* COMMENT_6 */
                             
    memcpy(packetbuf_dataptr(), VAR_0->rx_buffer.sdu, VAR_0->rx_buffer.sdu_length);
    packetbuf_set_datalen(VAR_0->rx_buffer.sdu_length);
    VAR_6.input();

    /* COMMENT_8 */
    VAR_0->rx_buffer.sdu_length = 0;
    VAR_0->rx_buffer.current_index = 0;
  }
}",contiki-ng/82356e516a91200857f52ed3e9945739cba2c051/ble-l2cap.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,8 +13,15 @@
   if(channel->rx_buffer.sdu_length == 0) {
     /* handle first fragment */
     memcpy(&frame_len, &data[0], 2);
+    payload_len = frame_len - 2;
+
+    if(payload_len > BLE_L2CAP_NODE_MTU) {
+    	LOG_WARN(""l2cap_frame: illegal L2CAP frame payload_len: %d\n"", payload_len);
+    	/* the payload length may not be larger than the destination buffer */
+    	return;
+    }
+
     memcpy(&channel->rx_buffer.sdu_length, &data[4], 2);
-    payload_len = frame_len - 2;
 
     memcpy(channel->rx_buffer.sdu, &data[6], payload_len);
     channel->rx_buffer.current_index = payload_len;
@@ -22,6 +29,13 @@
     /* subsequent fragment */
     memcpy(&frame_len, &data[0], 2);
     payload_len = frame_len;
+    
+    if(channel->rx_buffer.current_index + payload_len > BLE_L2CAP_NODE_MTU) {
+    	LOG_WARN(""l2cap_frame: illegal L2CAP frame payload_len: %d\n"", payload_len);
+    	/* the current index plus the payload length may not be larger than 
+	 * the destination buffer */
+    	return;
+    }
 
     memcpy(&channel->rx_buffer.sdu[channel->rx_buffer.current_index], &data[4], payload_len);
     channel->rx_buffer.current_index += payload_len;","{'deleted_lines': ['    payload_len = frame_len - 2;'], 'added_lines': ['    payload_len = frame_len - 2;', '', '    if(payload_len > BLE_L2CAP_NODE_MTU) {', '    \tLOG_WARN(""l2cap_frame: illegal L2CAP frame payload_len: %d\\n"", payload_len);', '    \t/* the payload length may not be larger than the destination buffer */', '    \treturn;', '    }', '', '    ', '    if(channel->rx_buffer.current_index + payload_len > BLE_L2CAP_NODE_MTU) {', '    \tLOG_WARN(""l2cap_frame: illegal L2CAP frame payload_len: %d\\n"", payload_len);', '    \t/* the current index plus the payload length may not be larger than ', '\t * the destination buffer */', '    \treturn;', '    }']}",True,A buffer overflow in os/net/mac/ble/ble-l2cap.c in the BLE stack in Contiki-NG 4.4 and earlier allows an attacker to execute arbitrary code via malicious L2CAP frames.,8.8,HIGH,2,valid,2021-10-08T15:26:09Z,3
CVE-2020-12140,['CWE-120'],AV:A/AC:L/Au:N/C:C/I:C/A:C,0,contiki-ng,Changed the second overflow check to prevent integer overflows,280019dce685bd5cfa217880762976980aeecf30,https://github.com/contiki-ng/contiki-ng/commit/280019dce685bd5cfa217880762976980aeecf30,os/net/mac/ble/ble-l2cap.c,input_l2cap_frame_flow_channel,"static void
input_l2cap_frame_flow_channel(l2cap_channel_t *channel, uint8_t *data, uint16_t data_len)
{
uint16_t frame_len;
uint16_t payload_len;
if(data_len < 4) {
LOG_WARN(""l2cap_frame: illegal L2CAP frame data_len: %d\n"", data_len);
return;
}
if(channel->rx_buffer.sdu_length == 0) {
memcpy(&frame_len, &data[0], 2);
payload_len = frame_len - 2;
if(payload_len > BLE_L2CAP_NODE_MTU) {
LOG_WARN(""l2cap_frame: illegal L2CAP frame payload_len: %d\n"", payload_len);
return;
}
memcpy(&channel->rx_buffer.sdu_length, &data[4], 2);
memcpy(channel->rx_buffer.sdu, &data[6], payload_len);
channel->rx_buffer.current_index = payload_len;
} else {
memcpy(&frame_len, &data[0], 2);
payload_len = frame_len;
if(channel->rx_buffer.current_index + payload_len > BLE_L2CAP_NODE_MTU) {
LOG_WARN(""l2cap_frame: illegal L2CAP frame payload_len: %d\n"", payload_len);
return;
}
memcpy(&channel->rx_buffer.sdu[channel->rx_buffer.current_index], &data[4], payload_len);
channel->rx_buffer.current_index += payload_len;
}
if((channel->rx_buffer.sdu_length > 0) &&
(channel->rx_buffer.sdu_length == channel->rx_buffer.current_index)) {
memcpy(packetbuf_dataptr(), channel->rx_buffer.sdu, channel->rx_buffer.sdu_length);
packetbuf_set_datalen(channel->rx_buffer.sdu_length);
NETSTACK_NETWORK.input();
channel->rx_buffer.sdu_length = 0;
channel->rx_buffer.current_index = 0;
}
}","static void
input_l2cap_frame_flow_channel(l2cap_channel_t *VAR_0, uint8_t *VAR_1, uint16_t VAR_2)
{
uint16_t VAR_3;
uint16_t VAR_4;
if(VAR_2 < 4) {
LOG_WARN(""l2cap_frame: illegal L2CAP frame data_len: %d\n"", VAR_2);
return;
}
if(VAR_0->rx_buffer.sdu_length == 0) {
memcpy(&VAR_3, &VAR_1[0], 2);
VAR_4 = VAR_3 - 2;
if(VAR_4 > VAR_5) {
LOG_WARN(""l2cap_frame: illegal L2CAP frame payload_len: %d\n"", VAR_4);
return;
}
memcpy(&VAR_0->rx_buffer.sdu_length, &VAR_1[4], 2);
memcpy(VAR_0->rx_buffer.sdu, &VAR_1[6], VAR_4);
VAR_0->rx_buffer.current_index = VAR_4;
} else {
memcpy(&VAR_3, &VAR_1[0], 2);
VAR_4 = VAR_3;
if(VAR_0->rx_buffer.current_index + VAR_4 > VAR_5) {
LOG_WARN(""l2cap_frame: illegal L2CAP frame payload_len: %d\n"", VAR_4);
return;
}
memcpy(&VAR_0->rx_buffer.sdu[VAR_0->rx_buffer.current_index], &VAR_1[4], VAR_4);
VAR_0->rx_buffer.current_index += VAR_4;
}
if((VAR_0->rx_buffer.sdu_length > 0) &&
(VAR_0->rx_buffer.sdu_length == VAR_0->rx_buffer.current_index)) {
memcpy(packetbuf_dataptr(), VAR_0->rx_buffer.sdu, VAR_0->rx_buffer.sdu_length);
packetbuf_set_datalen(VAR_0->rx_buffer.sdu_length);
VAR_6.input();
VAR_0->rx_buffer.sdu_length = 0;
VAR_0->rx_buffer.current_index = 0;
}
}",contiki-ng/280019dce685bd5cfa217880762976980aeecf30/ble-l2cap.c/vul/before/0.json,"static void
input_l2cap_frame_flow_channel(l2cap_channel_t *channel, uint8_t *data, uint16_t data_len)
{
  uint16_t frame_len;
  uint16_t payload_len;

  if(data_len < 4) {
    LOG_WARN(""l2cap_frame: illegal L2CAP frame data_len: %d\n"", data_len);
    /* a L2CAP frame has a minimum length of 4 */
    return;
  }

  if(channel->rx_buffer.sdu_length == 0) {
    /* handle first fragment */
    memcpy(&frame_len, &data[0], 2);
    payload_len = frame_len - 2;

    if(payload_len > BLE_L2CAP_NODE_MTU) {
    	LOG_WARN(""l2cap_frame: illegal L2CAP frame payload_len: %d\n"", payload_len);
    	/* the payload length may not be larger than the destination buffer */
    	return;
    }

    memcpy(&channel->rx_buffer.sdu_length, &data[4], 2);

    memcpy(channel->rx_buffer.sdu, &data[6], payload_len);
    channel->rx_buffer.current_index = payload_len;
  } else {
    /* subsequent fragment */
    memcpy(&frame_len, &data[0], 2);
    payload_len = frame_len;
    
    if(payload_len > BLE_L2CAP_NODE_MTU - channel->rx_buffer.current_index) {
    	LOG_WARN(""l2cap_frame: illegal L2CAP frame payload_len: %d\n"", payload_len);
    	/* the current index plus the payload length may not be larger than 
	 * the destination buffer */
    	return;
    }

    memcpy(&channel->rx_buffer.sdu[channel->rx_buffer.current_index], &data[4], payload_len);
    channel->rx_buffer.current_index += payload_len;
  }

  if((channel->rx_buffer.sdu_length > 0) &&
     (channel->rx_buffer.sdu_length == channel->rx_buffer.current_index)) {
    /* do not use packetbuf_copyfrom here because the packetbuf_attr
     * must not be cleared */
    memcpy(packetbuf_dataptr(), channel->rx_buffer.sdu, channel->rx_buffer.sdu_length);
    packetbuf_set_datalen(channel->rx_buffer.sdu_length);
    NETSTACK_NETWORK.input();

    /* reset counters */
    channel->rx_buffer.sdu_length = 0;
    channel->rx_buffer.current_index = 0;
  }
}","static void
input_l2cap_frame_flow_channel(l2cap_channel_t *VAR_0, uint8_t *VAR_1, uint16_t VAR_2)
{
  uint16_t VAR_3;
  uint16_t VAR_4;

  if(VAR_2 < 4) {
    LOG_WARN(""l2cap_frame: illegal L2CAP frame data_len: %d\n"", VAR_2);
    /* COMMENT_0 */
    return;
  }

  if(VAR_0->rx_buffer.sdu_length == 0) {
    /* COMMENT_1 */
    memcpy(&VAR_3, &VAR_1[0], 2);
    VAR_4 = VAR_3 - 2;

    if(VAR_4 > VAR_5) {
    	LOG_WARN(""l2cap_frame: illegal L2CAP frame payload_len: %d\n"", VAR_4);
    	/* COMMENT_2 */
    	return;
    }

    memcpy(&VAR_0->rx_buffer.sdu_length, &VAR_1[4], 2);

    memcpy(VAR_0->rx_buffer.sdu, &VAR_1[6], VAR_4);
    VAR_0->rx_buffer.current_index = VAR_4;
  } else {
    /* COMMENT_3 */
    memcpy(&VAR_3, &VAR_1[0], 2);
    VAR_4 = VAR_3;
    
    if(VAR_4 > VAR_5 - VAR_0->rx_buffer.current_index) {
    	LOG_WARN(""l2cap_frame: illegal L2CAP frame payload_len: %d\n"", VAR_4);
    	/* COMMENT_4 */
                             
    	return;
    }

    memcpy(&VAR_0->rx_buffer.sdu[VAR_0->rx_buffer.current_index], &VAR_1[4], VAR_4);
    VAR_0->rx_buffer.current_index += VAR_4;
  }

  if((VAR_0->rx_buffer.sdu_length > 0) &&
     (VAR_0->rx_buffer.sdu_length == VAR_0->rx_buffer.current_index)) {
    /* COMMENT_6 */
                             
    memcpy(packetbuf_dataptr(), VAR_0->rx_buffer.sdu, VAR_0->rx_buffer.sdu_length);
    packetbuf_set_datalen(VAR_0->rx_buffer.sdu_length);
    VAR_6.input();

    /* COMMENT_8 */
    VAR_0->rx_buffer.sdu_length = 0;
    VAR_0->rx_buffer.current_index = 0;
  }
}",contiki-ng/280019dce685bd5cfa217880762976980aeecf30/ble-l2cap.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -30,7 +30,7 @@
     memcpy(&frame_len, &data[0], 2);
     payload_len = frame_len;
     
-    if(channel->rx_buffer.current_index + payload_len > BLE_L2CAP_NODE_MTU) {
+    if(payload_len > BLE_L2CAP_NODE_MTU - channel->rx_buffer.current_index) {
     	LOG_WARN(""l2cap_frame: illegal L2CAP frame payload_len: %d\n"", payload_len);
     	/* the current index plus the payload length may not be larger than 
 	 * the destination buffer */","{'deleted_lines': ['    if(channel->rx_buffer.current_index + payload_len > BLE_L2CAP_NODE_MTU) {'], 'added_lines': ['    if(payload_len > BLE_L2CAP_NODE_MTU - channel->rx_buffer.current_index) {']}",True,A buffer overflow in os/net/mac/ble/ble-l2cap.c in the BLE stack in Contiki-NG 4.4 and earlier allows an attacker to execute arbitrary code via malicious L2CAP frames.,8.8,HIGH,2,valid,2021-10-12T11:21:14Z,3
CVE-2021-41216,['CWE-787'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"Make Transpose's shape inference function validate that negative `perm` values are within the tensor's rank.

PiperOrigin-RevId: 403252853
Change-Id: Ia6b31b45b237312668bb31c2c3b3c7bbce2d2610",c79ba87153ee343401dbe9d1954d7f79e521eb14,https://github.com/tensorflow/tensorflow/commit/c79ba87153ee343401dbe9d1954d7f79e521eb14,tensorflow/core/ops/array_ops.cc,TransposeShapeFn,"Status TransposeShapeFn(InferenceContext* c) {
ShapeHandle input = c->input(0);
ShapeHandle perm_shape = c->input(1);
const Tensor* perm = c->input_tensor(1);
DimensionHandle perm_elems = c->NumElements(perm_shape);
if (!c->RankKnown(input) && !c->ValueKnown(perm_elems) && perm == nullptr) {
c->set_output(0, c->UnknownShape());
return Status::OK();
}
int64_t rank;
if (c->RankKnown(input)) {
rank = c->Rank(input);
} else if (c->ValueKnown(perm_elems)) {
rank = c->Value(perm_elems);
} else {
rank = perm->NumElements();
}
if (!c->RankKnown(input) && rank < 2) {
c->set_output(0, input);
return Status::OK();
}
std::vector<DimensionHandle> dims;
dims.resize(rank);
TF_RETURN_IF_ERROR(c->WithRank(input, rank, &input));
TF_RETURN_IF_ERROR(c->WithRank(perm_shape, 1, &perm_shape));
TF_RETURN_IF_ERROR(c->WithValue(perm_elems, rank, &perm_elems));
if (perm != nullptr) {
std::vector<int64_t> data;
if (perm->dtype() == DT_INT32) {
data = AsInt64<int32>(perm, rank);
} else {
data = AsInt64<int64_t>(perm, rank);
}
for (int32_t i = 0; i < rank; ++i) {
int64_t in_idx = data[i];
if (in_idx >= rank) {
return errors::InvalidArgument(""perm dim "", in_idx,
"" is out of range of input rank "", rank);
}
dims[i] = c->Dim(input, in_idx);
}
} else {
for (int i = 0; i < rank; ++i) {
dims[i] = c->UnknownDim();
}
}
c->set_output(0, c->MakeShape(dims));
return Status::OK();
}","Status TransposeShapeFn(InferenceContext* VAR_0) {
ShapeHandle VAR_1 = VAR_0->input(0);
ShapeHandle VAR_2 = VAR_0->input(1);
const Tensor* VAR_3 = VAR_0->input_tensor(1);
DimensionHandle VAR_4 = VAR_0->NumElements(VAR_2);
if (!VAR_0->RankKnown(VAR_1) && !VAR_0->ValueKnown(VAR_4) && VAR_3 == nullptr) {
VAR_0->set_output(0, VAR_0->UnknownShape());
return Status::OK();
}
int64_t VAR_5;
if (VAR_0->RankKnown(VAR_1)) {
VAR_5 = VAR_0->Rank(VAR_1);
} else if (VAR_0->ValueKnown(VAR_4)) {
VAR_5 = VAR_0->Value(VAR_4);
} else {
VAR_5 = VAR_3->NumElements();
}
if (!VAR_0->RankKnown(VAR_1) && VAR_5 < 2) {
VAR_0->set_output(0, VAR_1);
return Status::OK();
}
std::vector<DimensionHandle> VAR_6;
VAR_6.resize(VAR_5);
TF_RETURN_IF_ERROR(VAR_0->WithRank(VAR_1, VAR_5, &VAR_1));
TF_RETURN_IF_ERROR(VAR_0->WithRank(VAR_2, 1, &VAR_2));
TF_RETURN_IF_ERROR(VAR_0->WithValue(VAR_4, VAR_5, &VAR_4));
if (VAR_3 != nullptr) {
std::vector<int64_t> VAR_7;
if (VAR_3->dtype() == VAR_8) {
VAR_7 = VAR_9<int32>(VAR_3, VAR_5);
} else {
VAR_7 = VAR_9<int64_t>(VAR_3, VAR_5);
}
for (int32_t VAR_10 = 0; VAR_10 < VAR_5; ++VAR_10) {
int64_t VAR_11 = VAR_7[VAR_10];
if (VAR_11 >= VAR_5) {
return errors::InvalidArgument(""perm dim "", VAR_11,
"" is out of range of input rank "", VAR_5);
}
VAR_6[VAR_10] = VAR_0->Dim(VAR_1, VAR_11);
}
} else {
for (int VAR_10 = 0; VAR_10 < VAR_5; ++VAR_10) {
VAR_6[VAR_10] = VAR_0->UnknownDim();
}
}
VAR_0->set_output(0, VAR_0->MakeShape(VAR_6));
return Status::OK();
}",tensorflow/c79ba87153ee343401dbe9d1954d7f79e521eb14/array_ops.cc/vul/before/0.json,"Status TransposeShapeFn(InferenceContext* c) {
  ShapeHandle input = c->input(0);
  ShapeHandle perm_shape = c->input(1);
  const Tensor* perm = c->input_tensor(1);
  DimensionHandle perm_elems = c->NumElements(perm_shape);
  // If we don't have rank information on the input or value information on
  // perm we can't return any shape information, otherwise we have enough
  // information to at least find the rank of the output.
  if (!c->RankKnown(input) && !c->ValueKnown(perm_elems) && perm == nullptr) {
    c->set_output(0, c->UnknownShape());
    return Status::OK();
  }

  // Find our value of the rank.
  int64_t rank;
  if (c->RankKnown(input)) {
    rank = c->Rank(input);
  } else if (c->ValueKnown(perm_elems)) {
    rank = c->Value(perm_elems);
  } else {
    rank = perm->NumElements();
  }
  if (!c->RankKnown(input) && rank < 2) {
    // A permutation array containing a single element is ambiguous. It could
    // indicate either a scalar or a 1-dimensional array, both of which the
    // transpose op returns unchanged.
    c->set_output(0, input);
    return Status::OK();
  }

  std::vector<DimensionHandle> dims;
  dims.resize(rank);
  TF_RETURN_IF_ERROR(c->WithRank(input, rank, &input));
  // Ensure that perm is a vector and has rank elements.
  TF_RETURN_IF_ERROR(c->WithRank(perm_shape, 1, &perm_shape));
  TF_RETURN_IF_ERROR(c->WithValue(perm_elems, rank, &perm_elems));

  // If we know the rank of the input and the value of perm, we can return
  // all shape information, otherwise we can only return rank information,
  // but no information for the dimensions.
  if (perm != nullptr) {
    std::vector<int64_t> data;
    if (perm->dtype() == DT_INT32) {
      data = AsInt64<int32>(perm, rank);
    } else {
      data = AsInt64<int64_t>(perm, rank);
    }

    for (int32_t i = 0; i < rank; ++i) {
      int64_t in_idx = data[i];
      if (in_idx >= rank || in_idx <= -rank) {
        return errors::InvalidArgument(""perm dim "", in_idx,
                                       "" is out of range of input rank "", rank);
      }
      dims[i] = c->Dim(input, in_idx);
    }
  } else {
    for (int i = 0; i < rank; ++i) {
      dims[i] = c->UnknownDim();
    }
  }

  c->set_output(0, c->MakeShape(dims));
  return Status::OK();
}","Status TransposeShapeFn(InferenceContext* VAR_0) {
  ShapeHandle VAR_1 = VAR_0->input(0);
  ShapeHandle VAR_2 = VAR_0->input(1);
  const Tensor* VAR_3 = VAR_0->input_tensor(1);
  DimensionHandle VAR_4 = VAR_0->NumElements(VAR_2);
  /* COMMENT_0 */
  /* COMMENT_1 */
  /* COMMENT_2 */
  if (!VAR_0->RankKnown(VAR_1) && !VAR_0->ValueKnown(VAR_4) && VAR_3 == nullptr) {
    VAR_0->set_output(0, VAR_0->UnknownShape());
    return Status::OK();
  }

  /* COMMENT_3 */
  int64_t VAR_5;
  if (VAR_0->RankKnown(VAR_1)) {
    VAR_5 = VAR_0->Rank(VAR_1);
  } else if (VAR_0->ValueKnown(VAR_4)) {
    VAR_5 = VAR_0->Value(VAR_4);
  } else {
    VAR_5 = VAR_3->NumElements();
  }
  if (!VAR_0->RankKnown(VAR_1) && VAR_5 < 2) {
    /* COMMENT_4 */
    /* COMMENT_5 */
    /* COMMENT_6 */
    VAR_0->set_output(0, VAR_1);
    return Status::OK();
  }

  std::vector<DimensionHandle> VAR_6;
  VAR_6.resize(VAR_5);
  TF_RETURN_IF_ERROR(VAR_0->WithRank(VAR_1, VAR_5, &VAR_1));
  /* COMMENT_7 */
  TF_RETURN_IF_ERROR(VAR_0->WithRank(VAR_2, 1, &VAR_2));
  TF_RETURN_IF_ERROR(VAR_0->WithValue(VAR_4, VAR_5, &VAR_4));

  /* COMMENT_8 */
  /* COMMENT_9 */
  /* COMMENT_10 */
  if (VAR_3 != nullptr) {
    std::vector<int64_t> VAR_7;
    if (VAR_3->dtype() == VAR_8) {
      VAR_7 = VAR_9<int32>(VAR_3, VAR_5);
    } else {
      VAR_7 = VAR_9<int64_t>(VAR_3, VAR_5);
    }

    for (int32_t VAR_10 = 0; VAR_10 < VAR_5; ++VAR_10) {
      int64_t VAR_11 = VAR_7[VAR_10];
      if (VAR_11 >= VAR_5 || VAR_11 <= -VAR_5) {
        return errors::InvalidArgument(""perm dim "", VAR_11,
                                       "" is out of range of input rank "", VAR_5);
      }
      VAR_6[VAR_10] = VAR_0->Dim(VAR_1, VAR_11);
    }
  } else {
    for (int VAR_10 = 0; VAR_10 < VAR_5; ++VAR_10) {
      VAR_6[VAR_10] = VAR_0->UnknownDim();
    }
  }

  VAR_0->set_output(0, VAR_0->MakeShape(VAR_6));
  return Status::OK();
}",tensorflow/c79ba87153ee343401dbe9d1954d7f79e521eb14/array_ops.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -48,7 +48,7 @@
 
     for (int32_t i = 0; i < rank; ++i) {
       int64_t in_idx = data[i];
-      if (in_idx >= rank) {
+      if (in_idx >= rank || in_idx <= -rank) {
         return errors::InvalidArgument(""perm dim "", in_idx,
                                        "" is out of range of input rank "", rank);
       }","{'deleted_lines': ['      if (in_idx >= rank) {'], 'added_lines': ['      if (in_idx >= rank || in_idx <= -rank) {']}",True,"TensorFlow is an open source platform for machine learning. In affected versions the shape inference function for `Transpose` is vulnerable to a heap buffer overflow. This occurs whenever `perm` contains negative elements. The shape inference function does not validate that the indices in `perm` are all valid. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",5.5,MEDIUM,1,valid,2021-10-15T02:39:00Z,3
CVE-2022-24949,"['CWE-362', 'CWE-120']",CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,MisterTea/EternalTerminal,"red fixes (#468)

* red fixes

* remove magic number",900348bb8bc96e1c7ba4888ac8480f643c43d3c3,https://github.com/MisterTea/EternalTerminal/commit/900348bb8bc96e1c7ba4888ac8480f643c43d3c3,src/terminal/UserTerminalRouter.cpp,UserTerminalRouter::getInfoForId,"TerminalUserInfo UserTerminalRouter::getInfoForId(const string &id) {
auto it = idInfoMap.find(id);
if (it == idInfoMap.end()) {
STFATAL << "" Tried to read from an id that no longer exists"";
}
return it->second;
}","TerminalUserInfo UserTerminalRouter::getInfoForId(const string &VAR_0) {
auto VAR_1 = VAR_2.find(VAR_0);
if (VAR_1 == VAR_2.end()) {
VAR_3 << "" Tried to read from an id that no longer exists"";
}
return VAR_1->second;
}",MisterTea/EternalTerminal/900348bb8bc96e1c7ba4888ac8480f643c43d3c3/UserTerminalRouter.cpp/vul/before/1.json,"TerminalUserInfo UserTerminalRouter::getInfoForId(const string &id) {
  lock_guard<recursive_mutex> guard(routerMutex);
  auto it = idInfoMap.find(id);
  if (it == idInfoMap.end()) {
    STFATAL << "" Tried to read from an id that no longer exists"";
  }
  return it->second;
}","TerminalUserInfo UserTerminalRouter::getInfoForId(const string &VAR_0) {
  lock_guard<recursive_mutex> guard(routerMutex);
  auto VAR_1 = VAR_2.find(VAR_0);
  if (VAR_1 == VAR_2.end()) {
    VAR_3 << "" Tried to read from an id that no longer exists"";
  }
  return VAR_1->second;
}",MisterTea/EternalTerminal/900348bb8bc96e1c7ba4888ac8480f643c43d3c3/UserTerminalRouter.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,4 +1,5 @@
 TerminalUserInfo UserTerminalRouter::getInfoForId(const string &id) {
+  lock_guard<recursive_mutex> guard(routerMutex);
   auto it = idInfoMap.find(id);
   if (it == idInfoMap.end()) {
     STFATAL << "" Tried to read from an id that no longer exists"";","{'deleted_lines': [], 'added_lines': ['  lock_guard<recursive_mutex> guard(routerMutex);']}",True,"A privilege escalation to root exists in Eternal Terminal prior to version 6.2.0. This is due to the combination of a race condition, buffer overflow, and logic bug all in PipeSocketHandler::listen().",7.5,HIGH,2,valid,2021-11-03T17:09:01Z,3
CVE-2022-24949,"['CWE-362', 'CWE-120']",CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,MisterTea/EternalTerminal,"red fixes (#468)

* red fixes

* remove magic number",900348bb8bc96e1c7ba4888ac8480f643c43d3c3,https://github.com/MisterTea/EternalTerminal/commit/900348bb8bc96e1c7ba4888ac8480f643c43d3c3,src/terminal/TerminalClient.cpp,parseRangesToRequests,"vector<PortForwardSourceRequest> parseRangesToRequests(const string& input) {
vector<PortForwardSourceRequest> pfsrs;
auto j = split(input, ',');
for (auto& pair : j) {
vector<string> sourceDestination = split(pair, ':');
try {
if (sourceDestination[0].find_first_not_of(""0123456789-"") !=
string::npos &&
sourceDestination[1].find_first_not_of(""0123456789-"") !=
string::npos) {
PortForwardSourceRequest pfsr;
pfsr.mutable_source()->set_name(sourceDestination[0]);
pfsr.mutable_destination()->set_name(sourceDestination[1]);
pfsrs.push_back(pfsr);
} else if (sourceDestination[0].find('-') != string::npos &&
sourceDestination[1].find('-') != string::npos) {
vector<string> sourcePortRange = split(sourceDestination[0], '-');
int sourcePortStart = stoi(sourcePortRange[0]);
int sourcePortEnd = stoi(sourcePortRange[1]);
vector<string> destinationPortRange = split(sourceDestination[1], '-');
int destinationPortStart = stoi(destinationPortRange[0]);
int destinationPortEnd = stoi(destinationPortRange[1]);
if (sourcePortEnd - sourcePortStart !=
destinationPortEnd - destinationPortStart) {
STFATAL << ""source/destination port range mismatch"";
exit(1);
} else {
int portRangeLength = sourcePortEnd - sourcePortStart + 1;
for (int i = 0; i < portRangeLength; ++i) {
PortForwardSourceRequest pfsr;
pfsr.mutable_source()->set_port(sourcePortStart + i);
pfsr.mutable_destination()->set_port(destinationPortStart + i);
pfsrs.push_back(pfsr);
}
}
} else if (sourceDestination[0].find('-') != string::npos ||
sourceDestination[1].find('-') != string::npos) {
STFATAL << ""Invalid port range syntax: if source is range, ""
""destination must be range"";
} else {
PortForwardSourceRequest pfsr;
pfsr.mutable_source()->set_port(stoi(sourceDestination[0]));
pfsr.mutable_destination()->set_port(stoi(sourceDestination[1]));
pfsrs.push_back(pfsr);
}
} catch (const std::logic_error& lr) {
STFATAL << ""Logic error: "" << lr.what();
exit(1);
}
}
return pfsrs;
}","vector<PortForwardSourceRequest> parseRangesToRequests(const string& VAR_0) {
vector<PortForwardSourceRequest> VAR_1;
auto VAR_2 = split(VAR_0, ',');
for (auto& VAR_3 : VAR_2) {
vector<string> VAR_4 = split(VAR_3, ':');
try {
if (VAR_4[0].find_first_not_of(""0123456789-"") !=
string::npos &&
VAR_4[1].find_first_not_of(""0123456789-"") !=
string::npos) {
PortForwardSourceRequest VAR_5;
VAR_5.mutable_source()->set_name(VAR_4[0]);
VAR_5.mutable_destination()->set_name(VAR_4[1]);
VAR_1.push_back(VAR_5);
} else if (VAR_4[0].find('-') != string::npos &&
VAR_4[1].find('-') != string::npos) {
vector<string> VAR_6 = split(VAR_4[0], '-');
int VAR_7 = stoi(VAR_6[0]);
int VAR_8 = stoi(VAR_6[1]);
vector<string> VAR_9 = split(VAR_4[1], '-');
int VAR_10 = stoi(VAR_9[0]);
int VAR_11 = stoi(VAR_9[1]);
if (VAR_8 - VAR_7 !=
VAR_11 - VAR_10) {
VAR_12 << ""source/destination port range mismatch"";
exit(1);
} else {
int VAR_13 = VAR_8 - VAR_7 + 1;
for (int VAR_14 = 0; VAR_14 < VAR_13; ++VAR_14) {
PortForwardSourceRequest VAR_5;
VAR_5.mutable_source()->set_port(VAR_7 + VAR_14);
VAR_5.mutable_destination()->set_port(VAR_10 + VAR_14);
VAR_1.push_back(VAR_5);
}
}
} else if (VAR_4[0].find('-') != string::npos ||
VAR_4[1].find('-') != string::npos) {
VAR_12 << ""Invalid port range syntax: if source is range, ""
""destination must be range"";
} else {
PortForwardSourceRequest VAR_5;
VAR_5.mutable_source()->set_port(stoi(VAR_4[0]));
VAR_5.mutable_destination()->set_port(stoi(VAR_4[1]));
VAR_1.push_back(VAR_5);
}
} catch (const std::logic_error& VAR_15) {
VAR_12 << ""Logic error: "" << VAR_15.what();
exit(1);
}
}
return VAR_1;
}",MisterTea/EternalTerminal/900348bb8bc96e1c7ba4888ac8480f643c43d3c3/TerminalClient.cpp/vul/before/0.json,"vector<PortForwardSourceRequest> parseRangesToRequests(const string& input) {
  vector<PortForwardSourceRequest> pfsrs;
  auto j = split(input, ',');
  for (auto& pair : j) {
    vector<string> sourceDestination = split(pair, ':');
    try {
      if (sourceDestination[0].find_first_not_of(""0123456789-"") !=
              string::npos &&
          sourceDestination[1].find_first_not_of(""0123456789-"") !=
              string::npos) {
        PortForwardSourceRequest pfsr;
        pfsr.set_environmentvariable(sourceDestination[0]);
        pfsr.mutable_destination()->set_name(sourceDestination[1]);
        pfsrs.push_back(pfsr);
      } else if (sourceDestination[0].find('-') != string::npos &&
                 sourceDestination[1].find('-') != string::npos) {
        vector<string> sourcePortRange = split(sourceDestination[0], '-');
        int sourcePortStart = stoi(sourcePortRange[0]);
        int sourcePortEnd = stoi(sourcePortRange[1]);

        vector<string> destinationPortRange = split(sourceDestination[1], '-');
        int destinationPortStart = stoi(destinationPortRange[0]);
        int destinationPortEnd = stoi(destinationPortRange[1]);

        if (sourcePortEnd - sourcePortStart !=
            destinationPortEnd - destinationPortStart) {
          STFATAL << ""source/destination port range mismatch"";
          exit(1);
        } else {
          int portRangeLength = sourcePortEnd - sourcePortStart + 1;
          for (int i = 0; i < portRangeLength; ++i) {
            PortForwardSourceRequest pfsr;
            pfsr.mutable_source()->set_port(sourcePortStart + i);
            pfsr.mutable_destination()->set_port(destinationPortStart + i);
            pfsrs.push_back(pfsr);
          }
        }
      } else if (sourceDestination[0].find('-') != string::npos ||
                 sourceDestination[1].find('-') != string::npos) {
        STFATAL << ""Invalid port range syntax: if source is range, ""
                   ""destination must be range"";
      } else {
        PortForwardSourceRequest pfsr;
        pfsr.mutable_source()->set_port(stoi(sourceDestination[0]));
        pfsr.mutable_destination()->set_port(stoi(sourceDestination[1]));
        pfsrs.push_back(pfsr);
      }
    } catch (const std::logic_error& lr) {
      STFATAL << ""Logic error: "" << lr.what();
      exit(1);
    }
  }
  return pfsrs;
}","vector<PortForwardSourceRequest> parseRangesToRequests(const string& VAR_0) {
  vector<PortForwardSourceRequest> VAR_1;
  auto VAR_2 = split(VAR_0, ',');
  for (auto& VAR_3 : VAR_2) {
    vector<string> VAR_4 = split(VAR_3, ':');
    try {
      if (VAR_4[0].find_first_not_of(""0123456789-"") !=
              string::npos &&
          VAR_4[1].find_first_not_of(""0123456789-"") !=
              string::npos) {
        PortForwardSourceRequest VAR_5;
        VAR_5.set_environmentvariable(VAR_4[0]);
        VAR_5.mutable_destination()->set_name(VAR_4[1]);
        VAR_1.push_back(VAR_5);
      } else if (VAR_4[0].find('-') != string::npos &&
                 VAR_4[1].find('-') != string::npos) {
        vector<string> VAR_6 = split(VAR_4[0], '-');
        int VAR_7 = stoi(VAR_6[0]);
        int VAR_8 = stoi(VAR_6[1]);

        vector<string> VAR_9 = split(VAR_4[1], '-');
        int VAR_10 = stoi(VAR_9[0]);
        int VAR_11 = stoi(VAR_9[1]);

        if (VAR_8 - VAR_7 !=
            VAR_11 - VAR_10) {
          VAR_12 << ""source/destination port range mismatch"";
          exit(1);
        } else {
          int VAR_13 = VAR_8 - VAR_7 + 1;
          for (int VAR_14 = 0; VAR_14 < VAR_13; ++VAR_14) {
            PortForwardSourceRequest VAR_5;
            VAR_5.mutable_source()->set_port(VAR_7 + VAR_14);
            VAR_5.mutable_destination()->set_port(VAR_10 + VAR_14);
            VAR_1.push_back(VAR_5);
          }
        }
      } else if (VAR_4[0].find('-') != string::npos ||
                 VAR_4[1].find('-') != string::npos) {
        VAR_12 << ""Invalid port range syntax: if source is range, ""
                   ""destination must be range"";
      } else {
        PortForwardSourceRequest VAR_5;
        VAR_5.mutable_source()->set_port(stoi(VAR_4[0]));
        VAR_5.mutable_destination()->set_port(stoi(VAR_4[1]));
        VAR_1.push_back(VAR_5);
      }
    } catch (const std::logic_error& VAR_15) {
      VAR_12 << ""Logic error: "" << VAR_15.what();
      exit(1);
    }
  }
  return VAR_1;
}",MisterTea/EternalTerminal/900348bb8bc96e1c7ba4888ac8480f643c43d3c3/TerminalClient.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,7 +9,7 @@
           sourceDestination[1].find_first_not_of(""0123456789-"") !=
               string::npos) {
         PortForwardSourceRequest pfsr;
-        pfsr.mutable_source()->set_name(sourceDestination[0]);
+        pfsr.set_environmentvariable(sourceDestination[0]);
         pfsr.mutable_destination()->set_name(sourceDestination[1]);
         pfsrs.push_back(pfsr);
       } else if (sourceDestination[0].find('-') != string::npos &&","{'deleted_lines': ['        pfsr.mutable_source()->set_name(sourceDestination[0]);'], 'added_lines': ['        pfsr.set_environmentvariable(sourceDestination[0]);']}",True,"A privilege escalation to root exists in Eternal Terminal prior to version 6.2.0. This is due to the combination of a race condition, buffer overflow, and logic bug all in PipeSocketHandler::listen().",7.5,HIGH,2,valid,2021-11-03T17:09:01Z,3
CVE-2022-24949,"['CWE-362', 'CWE-120']",CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,MisterTea/EternalTerminal,"red fixes (#468)

* red fixes

* remove magic number",900348bb8bc96e1c7ba4888ac8480f643c43d3c3,https://github.com/MisterTea/EternalTerminal/commit/900348bb8bc96e1c7ba4888ac8480f643c43d3c3,src/terminal/UserTerminalRouter.cpp,UserTerminalRouter::acceptNewConnection,"IdKeyPair UserTerminalRouter::acceptNewConnection() {
LOG(INFO) << ""Listening to id/key FIFO"";
int terminalFd = socketHandler->accept(serverFd);
if (terminalFd < 0) {
if (GetErrno() != EAGAIN && GetErrno() != EWOULDBLOCK) {
FATAL_FAIL(-1);      } else {
return IdKeyPair({"""", """"});      }
}
LOG(INFO) << ""Connected"";
try {
Packet packet;
if (!socketHandler->readPacket(terminalFd, &packet)) {
STFATAL << ""Missing user info packet"";
}
if (packet.getHeader() != TerminalPacketType::TERMINAL_USER_INFO) {
STFATAL << ""Got an invalid packet header: "" << int(packet.getHeader());
}
TerminalUserInfo tui = stringToProto<TerminalUserInfo>(packet.getPayload());
tui.set_fd(terminalFd);
idInfoMap[tui.id()] = tui;
return IdKeyPair({tui.id(), tui.passkey()});
} catch (const std::runtime_error &re) {
STFATAL << ""Router can't talk to terminal: "" << re.what();
}
STFATAL << ""Should never get here"";
return IdKeyPair({"""", """"});
}","IdKeyPair UserTerminalRouter::acceptNewConnection() {
LOG(VAR_0) << ""Listening to id/key FIFO"";
int VAR_1 = VAR_2->accept(VAR_3);
if (VAR_1 < 0) {
if (GetErrno() != VAR_4 && GetErrno() != VAR_5) {
FATAL_FAIL(-1);  
} else {
return IdKeyPair({"""", """"});  
}
}
LOG(VAR_0) << ""Connected"";
try {
Packet VAR_6;
if (!VAR_2->readPacket(VAR_1, &VAR_6)) {
VAR_7 << ""Missing user info packet"";
}
if (VAR_6.getHeader() != TerminalPacketType::TERMINAL_USER_INFO) {
VAR_7 << ""Got an invalid packet header: "" << int(VAR_6.getHeader());
}
TerminalUserInfo VAR_8 = VAR_9<TerminalUserInfo>(VAR_6.getPayload());
VAR_8.set_fd(VAR_1);
VAR_10[VAR_8.id()] = VAR_8;
return IdKeyPair({VAR_8.id(), VAR_8.passkey()});
} catch (const std::runtime_error &VAR_11) {
VAR_7 << ""Router can't talk to terminal: "" << VAR_11.what();
}
VAR_7 << ""Should never get here"";
return IdKeyPair({"""", """"});
}",MisterTea/EternalTerminal/900348bb8bc96e1c7ba4888ac8480f643c43d3c3/UserTerminalRouter.cpp/vul/before/0.json,"IdKeyPair UserTerminalRouter::acceptNewConnection() {
  lock_guard<recursive_mutex> guard(routerMutex);
  LOG(INFO) << ""Listening to id/key FIFO"";
  int terminalFd = socketHandler->accept(serverFd);
  if (terminalFd < 0) {
    if (GetErrno() != EAGAIN && GetErrno() != EWOULDBLOCK) {
      FATAL_FAIL(-1);  // STFATAL with the error
    } else {
      return IdKeyPair({"""", """"});  // Nothing to accept this time
    }
  }

  LOG(INFO) << ""Connected"";

  try {
    Packet packet;
    if (!socketHandler->readPacket(terminalFd, &packet)) {
      STFATAL << ""Missing user info packet"";
    }
    if (packet.getHeader() != TerminalPacketType::TERMINAL_USER_INFO) {
      STFATAL << ""Got an invalid packet header: "" << int(packet.getHeader());
    }
    TerminalUserInfo tui = stringToProto<TerminalUserInfo>(packet.getPayload());
    tui.set_fd(terminalFd);
    idInfoMap[tui.id()] = tui;
    return IdKeyPair({tui.id(), tui.passkey()});
  } catch (const std::runtime_error &re) {
    STFATAL << ""Router can't talk to terminal: "" << re.what();
  }

  STFATAL << ""Should never get here"";
  return IdKeyPair({"""", """"});
}","IdKeyPair UserTerminalRouter::acceptNewConnection() {
  lock_guard<recursive_mutex> guard(routerMutex);
  LOG(VAR_0) << ""Listening to id/key FIFO"";
  int VAR_1 = VAR_2->accept(VAR_3);
  if (VAR_1 < 0) {
    if (GetErrno() != VAR_4 && GetErrno() != VAR_5) {
      FATAL_FAIL(-1);  /* COMMENT_0 */
    } else {
      return IdKeyPair({"""", """"});  /* COMMENT_1 */
    }
  }

  LOG(VAR_0) << ""Connected"";

  try {
    Packet VAR_6;
    if (!VAR_2->readPacket(VAR_1, &VAR_6)) {
      VAR_7 << ""Missing user info packet"";
    }
    if (VAR_6.getHeader() != TerminalPacketType::TERMINAL_USER_INFO) {
      VAR_7 << ""Got an invalid packet header: "" << int(VAR_6.getHeader());
    }
    TerminalUserInfo VAR_8 = VAR_9<TerminalUserInfo>(VAR_6.getPayload());
    VAR_8.set_fd(VAR_1);
    VAR_10[VAR_8.id()] = VAR_8;
    return IdKeyPair({VAR_8.id(), VAR_8.passkey()});
  } catch (const std::runtime_error &VAR_11) {
    VAR_7 << ""Router can't talk to terminal: "" << VAR_11.what();
  }

  VAR_7 << ""Should never get here"";
  return IdKeyPair({"""", """"});
}",MisterTea/EternalTerminal/900348bb8bc96e1c7ba4888ac8480f643c43d3c3/UserTerminalRouter.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,5 @@
 IdKeyPair UserTerminalRouter::acceptNewConnection() {
+  lock_guard<recursive_mutex> guard(routerMutex);
   LOG(INFO) << ""Listening to id/key FIFO"";
   int terminalFd = socketHandler->accept(serverFd);
   if (terminalFd < 0) {","{'deleted_lines': [], 'added_lines': ['  lock_guard<recursive_mutex> guard(routerMutex);']}",True,"A privilege escalation to root exists in Eternal Terminal prior to version 6.2.0. This is due to the combination of a race condition, buffer overflow, and logic bug all in PipeSocketHandler::listen().",7.5,HIGH,2,valid,2021-11-03T17:09:01Z,3
CVE-2022-24949,"['CWE-362', 'CWE-120']",CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,MisterTea/EternalTerminal,"red fixes (#468)

* red fixes

* remove magic number",900348bb8bc96e1c7ba4888ac8480f643c43d3c3,https://github.com/MisterTea/EternalTerminal/commit/900348bb8bc96e1c7ba4888ac8480f643c43d3c3,src/base/PipeSocketHandler.cpp,PipeSocketHandler::connect,"int PipeSocketHandler::connect(const SocketEndpoint& endpoint) {
lock_guard<std::recursive_mutex> mutexGuard(globalMutex);
string pipePath = endpoint.name();
sockaddr_un remote;
int sockFd = ::socket(AF_UNIX, SOCK_STREAM, 0);
FATAL_FAIL(sockFd);
initSocket(sockFd);
remote.sun_family = AF_UNIX;
strcpy(remote.sun_path, pipePath.c_str());
VLOG(3) << ""Connecting to "" << endpoint << "" with fd "" << sockFd;
int result =
::connect(sockFd, (struct sockaddr*)&remote, sizeof(sockaddr_un));
auto localErrno = GetErrno();
if (result < 0 && localErrno != EINPROGRESS) {
VLOG(3) << ""Connection result: "" << result << "" ("" << strerror(localErrno)
<< "")"";
#ifdef WIN32
::shutdown(sockFd, SD_BOTH);
#else
::shutdown(sockFd, SHUT_RDWR);
#endif
#ifdef _MSC_VER
FATAL_FAIL(::closesocket(sockFd));
#else
FATAL_FAIL(::close(sockFd));
#endif
sockFd = -1;
SetErrno(localErrno);
return sockFd;
}
fd_set fdset;
FD_ZERO(&fdset);
FD_SET(sockFd, &fdset);
timeval tv;
tv.tv_sec = 3; 
tv.tv_usec = 0;
VLOG(4) << ""Before selecting sockFd"";
select(sockFd + 1, NULL, &fdset, NULL, &tv);
if (FD_ISSET(sockFd, &fdset)) {
VLOG(4) << ""sockFd "" << sockFd << "" is selected"";
int so_error;
socklen_t len = sizeof so_error;
FATAL_FAIL(
::getsockopt(sockFd, SOL_SOCKET, SO_ERROR, (char*)&so_error, &len));
if (so_error == 0) {
LOG(INFO) << ""Connected to endpoint "" << endpoint;
initSocket(sockFd);
} else {
LOG(INFO) << ""Error connecting to "" << endpoint << "": "" << so_error << "" ""
<< strerror(so_error);
#ifdef _MSC_VER
FATAL_FAIL(::closesocket(sockFd));
#else
FATAL_FAIL(::close(sockFd));
#endif
sockFd = -1;
}
} else {
auto localErrno = GetErrno();
LOG(INFO) << ""Error connecting to "" << endpoint << "": "" << localErrno << "" ""
<< strerror(localErrno);
#ifdef _MSC_VER
FATAL_FAIL(::closesocket(sockFd));
#else
FATAL_FAIL(::close(sockFd));
#endif
sockFd = -1;
}
LOG(INFO) << sockFd << "" is a good socket"";
if (sockFd >= 0) {
addToActiveSockets(sockFd);
}
return sockFd;
}","int PipeSocketHandler::connect(const SocketEndpoint& VAR_0) {
lock_guard<std::recursive_mutex> mutexGuard(globalMutex);
string VAR_1 = VAR_0.name();
sockaddr_un VAR_2;
int VAR_3 = ::socket(VAR_4, VAR_5, 0);
FATAL_FAIL(VAR_3);
initSocket(VAR_3);
VAR_2.sun_family = VAR_4;
strcpy(VAR_2.sun_path, VAR_1.c_str());
VLOG(3) << ""Connecting to "" << VAR_0 << "" with fd "" << VAR_3;
int VAR_6 =
::connect(VAR_3, (struct sockaddr*)&VAR_2, sizeof(sockaddr_un));
auto VAR_7 = GetErrno();
if (VAR_6 < 0 && VAR_7 != VAR_8) {
VLOG(3) << ""Connection result: "" << VAR_6 << "" ("" << strerror(VAR_7)
<< "")"";
#ifdef VAR_9
::shutdown(VAR_3, VAR_10);
#else
::shutdown(VAR_3, VAR_11);
#endif
#ifdef VAR_12
FATAL_FAIL(::closesocket(VAR_3));
#else
FATAL_FAIL(::close(VAR_3));
#endif
VAR_3 = -1;
SetErrno(VAR_7);
return VAR_3;
}
fd_set VAR_13;
FD_ZERO(&VAR_13);
FD_SET(VAR_3, &VAR_13);
timeval VAR_14;
VAR_14.tv_sec = 3; 
VAR_14.tv_usec = 0;
VLOG(4) << ""Before selecting sockFd"";
select(VAR_3 + 1, NULL, &VAR_13, NULL, &VAR_14);
if (FD_ISSET(VAR_3, &VAR_13)) {
VLOG(4) << ""sockFd "" << VAR_3 << "" is selected"";
int VAR_15;
socklen_t VAR_16 = sizeof VAR_15;
FATAL_FAIL(
::getsockopt(VAR_3, VAR_17, VAR_18, (char*)&VAR_15, &VAR_16));
if (VAR_15 == 0) {
LOG(VAR_19) << ""Connected to endpoint "" << VAR_0;
initSocket(VAR_3);
} else {
LOG(VAR_19) << ""Error connecting to "" << VAR_0 << "": "" << VAR_15 << "" ""
<< strerror(VAR_15);
#ifdef VAR_12
FATAL_FAIL(::closesocket(VAR_3));
#else
FATAL_FAIL(::close(VAR_3));
#endif
VAR_3 = -1;
}
} else {
auto VAR_7 = GetErrno();
LOG(VAR_19) << ""Error connecting to "" << VAR_0 << "": "" << VAR_7 << "" ""
<< strerror(VAR_7);
#ifdef VAR_12
FATAL_FAIL(::closesocket(VAR_3));
#else
FATAL_FAIL(::close(VAR_3));
#endif
VAR_3 = -1;
}
LOG(VAR_19) << VAR_3 << "" is a good socket"";
if (VAR_3 >= 0) {
addToActiveSockets(VAR_3);
}
return VAR_3;
}",MisterTea/EternalTerminal/900348bb8bc96e1c7ba4888ac8480f643c43d3c3/PipeSocketHandler.cpp/vul/before/0.json,"int PipeSocketHandler::connect(const SocketEndpoint& endpoint) {
  lock_guard<std::recursive_mutex> mutexGuard(globalMutex);

  string pipePath = endpoint.name();
  sockaddr_un remote;

  int sockFd = ::socket(AF_UNIX, SOCK_STREAM, 0);
  FATAL_FAIL(sockFd);
  initSocket(sockFd);
  remote.sun_family = AF_UNIX;
  strncpy(remote.sun_path, pipePath.c_str(), sizeof(remote.sun_path));

  VLOG(3) << ""Connecting to "" << endpoint << "" with fd "" << sockFd;
  int result =
      ::connect(sockFd, (struct sockaddr*)&remote, sizeof(sockaddr_un));
  auto localErrno = GetErrno();
  if (result < 0 && localErrno != EINPROGRESS) {
    VLOG(3) << ""Connection result: "" << result << "" ("" << strerror(localErrno)
            << "")"";
#ifdef WIN32
    ::shutdown(sockFd, SD_BOTH);
#else
    ::shutdown(sockFd, SHUT_RDWR);
#endif
#ifdef _MSC_VER
    FATAL_FAIL(::closesocket(sockFd));
#else
    FATAL_FAIL(::close(sockFd));
#endif
    sockFd = -1;
    SetErrno(localErrno);
    return sockFd;
  }

  fd_set fdset;
  FD_ZERO(&fdset);
  FD_SET(sockFd, &fdset);
  timeval tv;
  tv.tv_sec = 3; /* 3 second timeout */
  tv.tv_usec = 0;
  VLOG(4) << ""Before selecting sockFd"";
  select(sockFd + 1, NULL, &fdset, NULL, &tv);

  if (FD_ISSET(sockFd, &fdset)) {
    VLOG(4) << ""sockFd "" << sockFd << "" is selected"";
    int so_error;
    socklen_t len = sizeof so_error;

    FATAL_FAIL(
        ::getsockopt(sockFd, SOL_SOCKET, SO_ERROR, (char*)&so_error, &len));

    if (so_error == 0) {
      LOG(INFO) << ""Connected to endpoint "" << endpoint;
      // Initialize the socket again once it's blocking to make sure timeouts
      // are set
      initSocket(sockFd);

      // if we get here, we must have connected successfully
    } else {
      LOG(INFO) << ""Error connecting to "" << endpoint << "": "" << so_error << "" ""
                << strerror(so_error);
#ifdef _MSC_VER
      FATAL_FAIL(::closesocket(sockFd));
#else
      FATAL_FAIL(::close(sockFd));
#endif
      sockFd = -1;
    }
  } else {
    auto localErrno = GetErrno();
    LOG(INFO) << ""Error connecting to "" << endpoint << "": "" << localErrno << "" ""
              << strerror(localErrno);
#ifdef _MSC_VER
    FATAL_FAIL(::closesocket(sockFd));
#else
    FATAL_FAIL(::close(sockFd));
#endif
    sockFd = -1;
  }

  LOG(INFO) << sockFd << "" is a good socket"";
  if (sockFd >= 0) {
    addToActiveSockets(sockFd);
  }
  return sockFd;
}","int PipeSocketHandler::connect(const SocketEndpoint& VAR_0) {
  lock_guard<std::recursive_mutex> mutexGuard(globalMutex);

  string VAR_1 = VAR_0.name();
  sockaddr_un VAR_2;

  int VAR_3 = ::socket(VAR_4, VAR_5, 0);
  FATAL_FAIL(VAR_3);
  initSocket(VAR_3);
  VAR_2.sun_family = VAR_4;
  strncpy(VAR_2.sun_path, VAR_1.c_str(), sizeof(VAR_2.sun_path));

  VLOG(3) << ""Connecting to "" << VAR_0 << "" with fd "" << VAR_3;
  int VAR_6 =
      ::connect(VAR_3, (struct sockaddr*)&VAR_2, sizeof(sockaddr_un));
  auto VAR_7 = GetErrno();
  if (VAR_6 < 0 && VAR_7 != VAR_8) {
    VLOG(3) << ""Connection result: "" << VAR_6 << "" ("" << strerror(VAR_7)
            << "")"";
#ifdef VAR_9
    ::shutdown(VAR_3, VAR_10);
#else
    ::shutdown(VAR_3, VAR_11);
#endif
#ifdef VAR_12
    FATAL_FAIL(::closesocket(VAR_3));
#else
    FATAL_FAIL(::close(VAR_3));
#endif
    VAR_3 = -1;
    SetErrno(VAR_7);
    return VAR_3;
  }

  fd_set VAR_13;
  FD_ZERO(&VAR_13);
  FD_SET(VAR_3, &VAR_13);
  timeval VAR_14;
  VAR_14.tv_sec = 3; /* COMMENT_0 */
  VAR_14.tv_usec = 0;
  VLOG(4) << ""Before selecting sockFd"";
  select(VAR_3 + 1, NULL, &VAR_13, NULL, &VAR_14);

  if (FD_ISSET(VAR_3, &VAR_13)) {
    VLOG(4) << ""sockFd "" << VAR_3 << "" is selected"";
    int VAR_15;
    socklen_t VAR_16 = sizeof VAR_15;

    FATAL_FAIL(
        ::getsockopt(VAR_3, VAR_17, VAR_18, (char*)&VAR_15, &VAR_16));

    if (VAR_15 == 0) {
      LOG(VAR_19) << ""Connected to endpoint "" << VAR_0;
      /* COMMENT_1 */
      /* COMMENT_2 */
      initSocket(VAR_3);

      /* COMMENT_3 */
    } else {
      LOG(VAR_19) << ""Error connecting to "" << VAR_0 << "": "" << VAR_15 << "" ""
                << strerror(VAR_15);
#ifdef VAR_12
      FATAL_FAIL(::closesocket(VAR_3));
#else
      FATAL_FAIL(::close(VAR_3));
#endif
      VAR_3 = -1;
    }
  } else {
    auto VAR_7 = GetErrno();
    LOG(VAR_19) << ""Error connecting to "" << VAR_0 << "": "" << VAR_7 << "" ""
              << strerror(VAR_7);
#ifdef VAR_12
    FATAL_FAIL(::closesocket(VAR_3));
#else
    FATAL_FAIL(::close(VAR_3));
#endif
    VAR_3 = -1;
  }

  LOG(VAR_19) << VAR_3 << "" is a good socket"";
  if (VAR_3 >= 0) {
    addToActiveSockets(VAR_3);
  }
  return VAR_3;
}",MisterTea/EternalTerminal/900348bb8bc96e1c7ba4888ac8480f643c43d3c3/PipeSocketHandler.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,7 +8,7 @@
   FATAL_FAIL(sockFd);
   initSocket(sockFd);
   remote.sun_family = AF_UNIX;
-  strcpy(remote.sun_path, pipePath.c_str());
+  strncpy(remote.sun_path, pipePath.c_str(), sizeof(remote.sun_path));
 
   VLOG(3) << ""Connecting to "" << endpoint << "" with fd "" << sockFd;
   int result =","{'deleted_lines': ['  strcpy(remote.sun_path, pipePath.c_str());'], 'added_lines': ['  strncpy(remote.sun_path, pipePath.c_str(), sizeof(remote.sun_path));']}",True,"A privilege escalation to root exists in Eternal Terminal prior to version 6.2.0. This is due to the combination of a race condition, buffer overflow, and logic bug all in PipeSocketHandler::listen().",7.5,HIGH,2,valid,2021-11-03T17:09:01Z,3
CVE-2022-24949,"['CWE-362', 'CWE-120']",CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,MisterTea/EternalTerminal,"red fixes (#468)

* red fixes

* remove magic number",900348bb8bc96e1c7ba4888ac8480f643c43d3c3,https://github.com/MisterTea/EternalTerminal/commit/900348bb8bc96e1c7ba4888ac8480f643c43d3c3,src/base/PipeSocketHandler.cpp,PipeSocketHandler::listen,"set<int> PipeSocketHandler::listen(const SocketEndpoint& endpoint) {
lock_guard<std::recursive_mutex> guard(globalMutex);
string pipePath = endpoint.name();
if (pipeServerSockets.find(pipePath) != pipeServerSockets.end()) {
throw runtime_error(""Tried to listen twice on the same path"");
}
sockaddr_un local;
int fd = socket(AF_UNIX, SOCK_STREAM, 0);
FATAL_FAIL(fd);
initServerSocket(fd);
local.sun_family = AF_UNIX; 
strcpy(local.sun_path, pipePath.c_str());
unlink(local.sun_path);
FATAL_FAIL(::bind(fd, (struct sockaddr*)&local, sizeof(sockaddr_un)));
::listen(fd, 5);
#ifndef WIN32
FATAL_FAIL(::chmod(local.sun_path, S_IRUSR | S_IWUSR | S_IXUSR));
#endif
pipeServerSockets[pipePath] = set<int>({fd});
return pipeServerSockets[pipePath];
}","set<int> PipeSocketHandler::listen(const SocketEndpoint& VAR_0) {
lock_guard<std::recursive_mutex> guard(globalMutex);
string VAR_1 = VAR_0.name();
if (VAR_2.find(VAR_1) != VAR_2.end()) {
throw runtime_error(""Tried to listen twice on the same path"");
}
sockaddr_un VAR_3;
int VAR_4 = socket(VAR_5, VAR_6, 0);
FATAL_FAIL(VAR_4);
initServerSocket(VAR_4);
VAR_3.sun_family = VAR_5; 
strcpy(VAR_3.sun_path, VAR_1.c_str());
unlink(VAR_3.sun_path);
FATAL_FAIL(::bind(VAR_4, (struct sockaddr*)&VAR_3, sizeof(sockaddr_un)));
::listen(VAR_4, 5);
#ifndef VAR_7
FATAL_FAIL(::chmod(VAR_3.sun_path, VAR_8 | VAR_9 | VAR_10));
#endif
VAR_2[VAR_1] = set<int>({VAR_4});
return VAR_2[VAR_1];
}",MisterTea/EternalTerminal/900348bb8bc96e1c7ba4888ac8480f643c43d3c3/PipeSocketHandler.cpp/vul/before/1.json,"set<int> PipeSocketHandler::listen(const SocketEndpoint& endpoint) {
  lock_guard<std::recursive_mutex> guard(globalMutex);

  string pipePath = endpoint.name();
  if (pipeServerSockets.find(pipePath) != pipeServerSockets.end()) {
    throw runtime_error(""Tried to listen twice on the same path"");
  }

  sockaddr_un local;

  int fd = socket(AF_UNIX, SOCK_STREAM, 0);
  FATAL_FAIL(fd);
  initServerSocket(fd);
  local.sun_family = AF_UNIX; /* local is declared before socket() ^ */
  strncpy(local.sun_path, pipePath.c_str(), sizeof(local.sun_path));
  unlink(local.sun_path);

  FATAL_FAIL(::bind(fd, (struct sockaddr*)&local, sizeof(sockaddr_un)));
  ::listen(fd, 5);
#ifndef WIN32
  FATAL_FAIL(::chmod(local.sun_path, S_IRUSR | S_IWUSR | S_IXUSR));
#endif

  pipeServerSockets[pipePath] = set<int>({fd});
  return pipeServerSockets[pipePath];
}","set<int> PipeSocketHandler::listen(const SocketEndpoint& VAR_0) {
  lock_guard<std::recursive_mutex> guard(globalMutex);

  string VAR_1 = VAR_0.name();
  if (VAR_2.find(VAR_1) != VAR_2.end()) {
    throw runtime_error(""Tried to listen twice on the same path"");
  }

  sockaddr_un VAR_3;

  int VAR_4 = socket(VAR_5, VAR_6, 0);
  FATAL_FAIL(VAR_4);
  initServerSocket(VAR_4);
  VAR_3.sun_family = VAR_5; /* COMMENT_0 */
  strncpy(VAR_3.sun_path, VAR_1.c_str(), sizeof(VAR_3.sun_path));
  unlink(VAR_3.sun_path);

  FATAL_FAIL(::bind(VAR_4, (struct sockaddr*)&VAR_3, sizeof(sockaddr_un)));
  ::listen(VAR_4, 5);
#ifndef VAR_7
  FATAL_FAIL(::chmod(VAR_3.sun_path, VAR_8 | VAR_9 | VAR_10));
#endif

  VAR_2[VAR_1] = set<int>({VAR_4});
  return VAR_2[VAR_1];
}",MisterTea/EternalTerminal/900348bb8bc96e1c7ba4888ac8480f643c43d3c3/PipeSocketHandler.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -12,7 +12,7 @@
   FATAL_FAIL(fd);
   initServerSocket(fd);
   local.sun_family = AF_UNIX; /* local is declared before socket() ^ */
-  strcpy(local.sun_path, pipePath.c_str());
+  strncpy(local.sun_path, pipePath.c_str(), sizeof(local.sun_path));
   unlink(local.sun_path);
 
   FATAL_FAIL(::bind(fd, (struct sockaddr*)&local, sizeof(sockaddr_un)));","{'deleted_lines': ['  strcpy(local.sun_path, pipePath.c_str());'], 'added_lines': ['  strncpy(local.sun_path, pipePath.c_str(), sizeof(local.sun_path));']}",True,"A privilege escalation to root exists in Eternal Terminal prior to version 6.2.0. This is due to the combination of a race condition, buffer overflow, and logic bug all in PipeSocketHandler::listen().",7.5,HIGH,2,valid,2021-11-03T17:09:01Z,3
CVE-2021-43395,['CWE-667'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,illumos/illumos-gate,"14424 tmpfs can be induced to deadlock
Reviewed by: Robert Mustacchi <rm@fingolfin.org>
Reviewed by: Andy Fiddaman <andy@omnios.org>
Reviewed by: Mike Zeller <mike.zeller@joyent.com>
Approved by: Robert Mustacchi <rm@fingolfin.org>",f859e7171bb5db34321e45585839c6c3200ebb90,https://github.com/illumos/illumos-gate/commit/f859e7171bb5db34321e45585839c6c3200ebb90,usr/src/uts/common/fs/tmpfs/tmp_dir.c,tdirenter,"int
tdirenter(
struct tmount*tm,
struct tmpnode*dir,
char*name,
enum de_opop,
struct tmpnode*fromparent,
struct tmpnode*tp,
struct vattr*va,
struct tmpnode**tpp,
struct cred*cred,
caller_context_t *ctp)
{
struct tdirent *tdp;
struct tmpnode *found = NULL;
int error = 0;
char *s;
ASSERT(RW_WRITE_HELD(&dir->tn_rwlock));
ASSERT(dir->tn_type == VDIR);
for (s = name; *s; s++)
if (*s == '/')
return (EACCES);
if (name[0] == '\0')
panic(""tdirenter: NULL name"");
if (op == DE_LINK || op == DE_RENAME) {
if (tp != dir)
rw_enter(&tp->tn_rwlock, RW_WRITER);
mutex_enter(&tp->tn_tlock);
if (tp->tn_nlink == 0) {
mutex_exit(&tp->tn_tlock);
if (tp != dir)
rw_exit(&tp->tn_rwlock);
return (ENOENT);
}
if (tp->tn_nlink == MAXLINK) {
mutex_exit(&tp->tn_tlock);
if (tp != dir)
rw_exit(&tp->tn_rwlock);
return (EMLINK);
}
tp->tn_nlink++;
gethrestime(&tp->tn_ctime);
mutex_exit(&tp->tn_tlock);
if (tp != dir)
rw_exit(&tp->tn_rwlock);
}
if (dir->tn_nlink == 0) {
error = ENOENT;
goto out;
}
if (op == DE_RENAME) {
if (tp == dir) {
error = EINVAL;
goto out;
}
if (tp->tn_type == VDIR) {
if ((fromparent != dir) &&
(error = tdircheckpath(tp, dir, cred))) {
goto out;
}
}
}
tdp = tmpfs_hash_lookup(name, dir, 1, &found);
if (tdp) {
ASSERT(found);
switch (op) {
case DE_CREATE:
case DE_MKDIR:
if (tpp) {
*tpp = found;
error = EEXIST;
} else {
tmpnode_rele(found);
}
break;
case DE_RENAME:
error = tdirrename(fromparent, tp,
dir, name, found, tdp, cred);
if (error == 0) {
if (found != NULL) {
vnevent_rename_dest(TNTOV(found),
TNTOV(dir), name, ctp);
}
}
tmpnode_rele(found);
break;
case DE_LINK:
error = EEXIST;
tmpnode_rele(found);
break;
}
} else {
if (error = tmp_taccess(dir, VWRITE, cred))
goto out;
if (op == DE_CREATE || op == DE_MKDIR) {
error = tdirmaketnode(dir, tm, va, op, &tp, cred);
if (error)
goto out;
}
if (error = tdiraddentry(dir, tp, name, op, fromparent)) {
if (op == DE_CREATE || op == DE_MKDIR) {
rw_enter(&tp->tn_rwlock, RW_WRITER);
if ((tp->tn_type) == VDIR) {
ASSERT(tdp == NULL);
tdirtrunc(tp);
}
mutex_enter(&tp->tn_tlock);
tp->tn_nlink = 0;
mutex_exit(&tp->tn_tlock);
gethrestime(&tp->tn_ctime);
rw_exit(&tp->tn_rwlock);
tmpnode_rele(tp);
tp = NULL;
}
} else if (tpp) {
*tpp = tp;
} else if (op == DE_CREATE || op == DE_MKDIR) {
tmpnode_rele(tp);
}
}
out:
if (error && (op == DE_LINK || op == DE_RENAME)) {
DECR_COUNT(&tp->tn_nlink, &tp->tn_tlock);
gethrestime(&tp->tn_ctime);
}
return (error);
}","int
tdirenter(
struct tmount*VAR_0,
struct tmpnode*VAR_1,
char*VAR_2,
enum de_opVAR_3,
struct tmpnode*VAR_4,
struct tmpnode*VAR_5,
struct vattr*VAR_6,
struct tmpnode**VAR_7,
struct cred*cred,
caller_context_t *VAR_8)
{
struct tdirent *VAR_9;
struct tmpnode *VAR_10 = NULL;
int VAR_11 = 0;
char *VAR_12;
ASSERT(RW_WRITE_HELD(&VAR_1->tn_rwlock));
ASSERT(VAR_1->tn_type == VAR_13);
for (VAR_12 = VAR_2; *VAR_12; VAR_12++)
if (*VAR_12 == '/')
return (VAR_14);
if (VAR_2[0] == '\0')
panic(""tdirenter: NULL name"");
if (VAR_3 == VAR_15 || VAR_3 == VAR_16) {
if (VAR_5 != VAR_1)
rw_enter(&VAR_5->tn_rwlock, VAR_17);
mutex_enter(&VAR_5->tn_tlock);
if (VAR_5->tn_nlink == 0) {
mutex_exit(&VAR_5->tn_tlock);
if (VAR_5 != VAR_1)
rw_exit(&VAR_5->tn_rwlock);
return (VAR_18);
}
if (VAR_5->tn_nlink == VAR_19) {
mutex_exit(&VAR_5->tn_tlock);
if (VAR_5 != VAR_1)
rw_exit(&VAR_5->tn_rwlock);
return (VAR_20);
}
VAR_5->tn_nlink++;
gethrestime(&VAR_5->tn_ctime);
mutex_exit(&VAR_5->tn_tlock);
if (VAR_5 != VAR_1)
rw_exit(&VAR_5->tn_rwlock);
}
if (VAR_1->tn_nlink == 0) {
VAR_11 = VAR_18;
goto out;
}
if (VAR_3 == VAR_16) {
if (VAR_5 == VAR_1) {
VAR_11 = VAR_21;
goto out;
}
if (VAR_5->tn_type == VAR_13) {
if ((VAR_4 != VAR_1) &&
(VAR_11 = tdircheckpath(VAR_5, VAR_1, cred))) {
goto out;
}
}
}
VAR_9 = tmpfs_hash_lookup(VAR_2, VAR_1, 1, &VAR_10);
if (VAR_9) {
ASSERT(VAR_10);
switch (VAR_3) {
case VAR_22:
case VAR_23:
if (VAR_7) {
*VAR_7 = VAR_10;
VAR_11 = VAR_24;
} else {
tmpnode_rele(VAR_10);
}
break;
case VAR_16:
VAR_11 = tdirrename(VAR_4, VAR_5,
VAR_1, VAR_2, VAR_10, VAR_9, cred);
if (VAR_11 == 0) {
if (VAR_10 != NULL) {
vnevent_rename_dest(TNTOV(VAR_10),
TNTOV(VAR_1), VAR_2, VAR_8);
}
}
tmpnode_rele(VAR_10);
break;
case VAR_15:
VAR_11 = VAR_24;
tmpnode_rele(VAR_10);
break;
}
} else {
if (VAR_11 = tmp_taccess(VAR_1, VAR_25, cred))
goto out;
if (VAR_3 == VAR_22 || VAR_3 == VAR_23) {
VAR_11 = tdirmaketnode(VAR_1, VAR_0, VAR_6, VAR_3, &VAR_5, cred);
if (VAR_11)
goto out;
}
if (VAR_11 = tdiraddentry(VAR_1, VAR_5, VAR_2, VAR_3, VAR_4)) {
if (VAR_3 == VAR_22 || VAR_3 == VAR_23) {
rw_enter(&VAR_5->tn_rwlock, VAR_17);
if ((VAR_5->tn_type) == VAR_13) {
ASSERT(VAR_9 == NULL);
tdirtrunc(VAR_5);
}
mutex_enter(&VAR_5->tn_tlock);
VAR_5->tn_nlink = 0;
mutex_exit(&VAR_5->tn_tlock);
gethrestime(&VAR_5->tn_ctime);
rw_exit(&VAR_5->tn_rwlock);
tmpnode_rele(VAR_5);
VAR_5 = NULL;
}
} else if (VAR_7) {
*VAR_7 = VAR_5;
} else if (VAR_3 == VAR_22 || VAR_3 == VAR_23) {
tmpnode_rele(VAR_5);
}
}
out:
if (VAR_11 && (VAR_3 == VAR_15 || VAR_3 == VAR_16)) {
DECR_COUNT(&VAR_5->tn_nlink, &VAR_5->tn_tlock);
gethrestime(&VAR_5->tn_ctime);
}
return (VAR_11);
}",illumos/illumos-gate/f859e7171bb5db34321e45585839c6c3200ebb90/tmp_dir.c/vul/before/0.json,"int
tdirenter(
	struct tmount	*tm,
	struct tmpnode	*dir,		/* target directory to make entry in */
	char		*name,		/* name of entry */
	enum de_op	op,		/* entry operation */
	struct tmpnode	*fromparent,	/* source directory if rename */
	struct tmpnode	*tp,		/* source tmpnode, if link/rename */
	struct vattr	*va,
	struct tmpnode	**tpp,		/* return tmpnode, if create/mkdir */
	struct cred	*cred,
	caller_context_t *ctp)
{
	struct tdirent *tdp;
	struct tmpnode *found = NULL;
	int error = 0;
	char *s;

	/*
	 * tn_rwlock is held to serialize direnter and dirdeletes
	 */
	ASSERT(RW_WRITE_HELD(&dir->tn_rwlock));
	ASSERT(dir->tn_type == VDIR);

	/*
	 * Don't allow '/' characters in pathname component
	 * (thus in ufs_direnter()).
	 */
	for (s = name; *s; s++)
		if (*s == '/')
			return (EACCES);

	if (name[0] == '\0')
		panic(""tdirenter: NULL name"");

	/*
	 * For link and rename lock the source entry and check the link count
	 * to see if it has been removed while it was unlocked.
	 */
	if (op == DE_LINK || op == DE_RENAME) {
		if (tp != dir) {
			unsigned int tries = 0;

			/*
			 * If we are acquiring tp->tn_rwlock (for SOURCE)
			 * inside here, we must consider the following:
			 *
			 * - dir->tn_rwlock (TARGET) is already HELD (see
			 * above ASSERT()).
			 *
			 * - It is possible our SOURCE is a parent of our
			 * TARGET. Yes it's unusual, but it will return an
			 * error below via tdircheckpath().
			 *
			 * - It is also possible that another thread,
			 * concurrent to this one, is performing
			 * rmdir(TARGET), which means it will first acquire
			 * SOURCE's lock, THEN acquire TARGET's lock, which
			 * could result in this thread holding TARGET and
			 * trying for SOURCE, but the other thread holding
			 * SOURCE and trying for TARGET.  This is deadlock,
			 * and it's inducible.
			 *
			 * To prevent this, we borrow some techniques from UFS
			 * and rw_tryenter(), delaying if we fail, and
			 * if someone tweaks the number of backoff tries to be
			 * nonzero, return EBUSY after that number of tries.
			 */
			while (!rw_tryenter(&tp->tn_rwlock, RW_WRITER)) {
				/*
				 * Sloppy, but this is a diagnostic so atomic
				 * increment would be overkill.
				 */
				tmpfs_rename_loops++;

				if (tmpfs_rename_backoff_tries != 0) {
					if (tries > tmpfs_rename_backoff_tries)
						return (EBUSY);
					tries++;
				}
				/*
				 * NOTE: We're still holding dir->tn_rwlock,
				 * so drop it over the delay, so any other
				 * thread can get its business done.
				 *
				 * No state change or state inspection happens
				 * prior to here, so it is not wholly dangerous
				 * to release-and-reacquire dir->tn_rwlock.
				 *
				 * Hold the vnode of dir in case it gets
				 * released by another thread, though.
				 */
				VN_HOLD(TNTOV(dir));
				rw_exit(&dir->tn_rwlock);
				delay(tmpfs_rename_backoff_delay);
				rw_enter(&dir->tn_rwlock, RW_WRITER);
				VN_RELE(TNTOV(dir));
			}
		}
		mutex_enter(&tp->tn_tlock);
		if (tp->tn_nlink == 0) {
			mutex_exit(&tp->tn_tlock);
			if (tp != dir)
				rw_exit(&tp->tn_rwlock);
			return (ENOENT);
		}

		if (tp->tn_nlink == MAXLINK) {
			mutex_exit(&tp->tn_tlock);
			if (tp != dir)
				rw_exit(&tp->tn_rwlock);
			return (EMLINK);
		}
		tp->tn_nlink++;
		gethrestime(&tp->tn_ctime);
		mutex_exit(&tp->tn_tlock);
		if (tp != dir)
			rw_exit(&tp->tn_rwlock);
	}

	/*
	 * This might be a ""dangling detached directory"".
	 * it could have been removed, but a reference
	 * to it kept in u_cwd.  don't bother searching
	 * it, and with any luck the user will get tired
	 * of dealing with us and cd to some absolute
	 * pathway.  *sigh*, thus in ufs, too.
	 */
	if (dir->tn_nlink == 0) {
		error = ENOENT;
		goto out;
	}

	/*
	 * If this is a rename of a directory and the parent is
	 * different ("".."" must be changed), then the source
	 * directory must not be in the directory hierarchy
	 * above the target, as this would orphan everything
	 * below the source directory.
	 */
	if (op == DE_RENAME) {
		if (tp == dir) {
			error = EINVAL;
			goto out;
		}
		if (tp->tn_type == VDIR) {
			if ((fromparent != dir) &&
			    (error = tdircheckpath(tp, dir, cred))) {
				goto out;
			}
		}
	}

	/*
	 * Search for the entry.  Return ""found"" if it exists.
	 */
	tdp = tmpfs_hash_lookup(name, dir, 1, &found);

	if (tdp) {
		ASSERT(found);
		switch (op) {
		case DE_CREATE:
		case DE_MKDIR:
			if (tpp) {
				*tpp = found;
				error = EEXIST;
			} else {
				tmpnode_rele(found);
			}
			break;

		case DE_RENAME:
			error = tdirrename(fromparent, tp,
			    dir, name, found, tdp, cred);
			if (error == 0) {
				if (found != NULL) {
					vnevent_rename_dest(TNTOV(found),
					    TNTOV(dir), name, ctp);
				}
			}

			tmpnode_rele(found);
			break;

		case DE_LINK:
			/*
			 * Can't link to an existing file.
			 */
			error = EEXIST;
			tmpnode_rele(found);
			break;
		}
	} else {

		/*
		 * The entry does not exist. Check write permission in
		 * directory to see if entry can be created.
		 */
		if (error = tmp_taccess(dir, VWRITE, cred))
			goto out;
		if (op == DE_CREATE || op == DE_MKDIR) {
			/*
			 * Make new tmpnode and directory entry as required.
			 */
			error = tdirmaketnode(dir, tm, va, op, &tp, cred);
			if (error)
				goto out;
		}
		if (error = tdiraddentry(dir, tp, name, op, fromparent)) {
			if (op == DE_CREATE || op == DE_MKDIR) {
				/*
				 * Unmake the inode we just made.
				 */
				rw_enter(&tp->tn_rwlock, RW_WRITER);
				if ((tp->tn_type) == VDIR) {
					ASSERT(tdp == NULL);
					/*
					 * cleanup allocs made by tdirinit()
					 */
					tdirtrunc(tp);
				}
				mutex_enter(&tp->tn_tlock);
				tp->tn_nlink = 0;
				mutex_exit(&tp->tn_tlock);
				gethrestime(&tp->tn_ctime);
				rw_exit(&tp->tn_rwlock);
				tmpnode_rele(tp);
				tp = NULL;
			}
		} else if (tpp) {
			*tpp = tp;
		} else if (op == DE_CREATE || op == DE_MKDIR) {
			tmpnode_rele(tp);
		}
	}

out:
	if (error && (op == DE_LINK || op == DE_RENAME)) {
		/*
		 * Undo bumped link count.
		 */
		DECR_COUNT(&tp->tn_nlink, &tp->tn_tlock);
		gethrestime(&tp->tn_ctime);
	}
	return (error);
}","int
tdirenter(
	struct tmount	*VAR_0,
	struct tmpnode	*VAR_1,		/* COMMENT_0 */
	char		*VAR_2,		/* COMMENT_1 */
	enum de_op	VAR_3,		/* COMMENT_2 */
	struct tmpnode	*VAR_4,	/* COMMENT_3 */
	struct tmpnode	*VAR_5,		/* COMMENT_4 */
	struct vattr	*VAR_6,
	struct tmpnode	**VAR_7,		/* COMMENT_5 */
	struct cred	*cred,
	caller_context_t *VAR_8)
{
	struct tdirent *VAR_9;
	struct tmpnode *VAR_10 = NULL;
	int VAR_11 = 0;
	char *VAR_12;

	/* COMMENT_6 */
                                                          
    
	ASSERT(RW_WRITE_HELD(&VAR_1->tn_rwlock));
	ASSERT(VAR_1->tn_type == VAR_13);

	/* COMMENT_9 */
                                                    
                             
    
	for (VAR_12 = VAR_2; *VAR_12; VAR_12++)
		if (*VAR_12 == '/')
			return (VAR_14);

	if (VAR_2[0] == '\0')
		panic(""tdirenter: NULL name"");

	/* COMMENT_13 */
                                                                      
                                                        
    
	if (VAR_3 == VAR_15 || VAR_3 == VAR_16) {
		if (VAR_5 != VAR_1) {
			unsigned int VAR_17 = 0;

			/* COMMENT_17 */
                                                    
                                                  
     
                                                    
                      
     
                                                    
                                                     
                                      
     
                                                
                                           
                                                      
                                                      
                                                    
                                                     
                                                      
                         
     
                                                         
                                                 
                                                         
                                                       
      
			while (!rw_tryenter(&VAR_5->tn_rwlock, VAR_18)) {
				/* COMMENT_39 */
                                                 
                                   
       
				VAR_19++;

				if (VAR_20 != 0) {
					if (VAR_17 > VAR_20)
						return (VAR_21);
					VAR_17++;
				}
				/* COMMENT_43 */
                                                
                                              
                                        
      
                                                  
                                                   
                                               
      
                                            
                                          
       
				VN_HOLD(TNTOV(VAR_1));
				rw_exit(&VAR_1->tn_rwlock);
				delay(VAR_22);
				rw_enter(&VAR_1->tn_rwlock, VAR_18);
				VN_RELE(TNTOV(VAR_1));
			}
		}
		mutex_enter(&VAR_5->tn_tlock);
		if (VAR_5->tn_nlink == 0) {
			mutex_exit(&VAR_5->tn_tlock);
			if (VAR_5 != VAR_1)
				rw_exit(&VAR_5->tn_rwlock);
			return (VAR_23);
		}

		if (VAR_5->tn_nlink == VAR_24) {
			mutex_exit(&VAR_5->tn_tlock);
			if (VAR_5 != VAR_1)
				rw_exit(&VAR_5->tn_rwlock);
			return (VAR_25);
		}
		VAR_5->tn_nlink++;
		gethrestime(&VAR_5->tn_ctime);
		mutex_exit(&VAR_5->tn_tlock);
		if (VAR_5 != VAR_1)
			rw_exit(&VAR_5->tn_rwlock);
	}

	/* COMMENT_54 */
                                                  
                                               
                                                
                                                 
                                              
                                       
    
	if (VAR_1->tn_nlink == 0) {
		VAR_11 = VAR_23;
		goto out;
	}

	/* COMMENT_62 */
                                                        
                                                     
                                                    
                                                     
                               
    
	if (VAR_3 == VAR_16) {
		if (VAR_5 == VAR_1) {
			VAR_11 = VAR_26;
			goto out;
		}
		if (VAR_5->tn_type == VAR_13) {
			if ((VAR_4 != VAR_1) &&
			    (VAR_11 = tdircheckpath(VAR_5, VAR_1, cred))) {
				goto out;
			}
		}
	}

	/* COMMENT_69 */
                                                       
    
	VAR_9 = tmpfs_hash_lookup(VAR_2, VAR_1, 1, &VAR_10);

	if (VAR_9) {
		ASSERT(VAR_10);
		switch (VAR_3) {
		case VAR_27:
		case VAR_28:
			if (VAR_7) {
				*VAR_7 = VAR_10;
				VAR_11 = VAR_29;
			} else {
				tmpnode_rele(VAR_10);
			}
			break;

		case VAR_16:
			VAR_11 = tdirrename(VAR_4, VAR_5,
			    VAR_1, VAR_2, VAR_10, VAR_9, cred);
			if (VAR_11 == 0) {
				if (VAR_10 != NULL) {
					vnevent_rename_dest(TNTOV(VAR_10),
					    TNTOV(VAR_1), VAR_2, VAR_8);
				}
			}

			tmpnode_rele(VAR_10);
			break;

		case VAR_15:
			/* COMMENT_72 */
                                     
      
			VAR_11 = VAR_29;
			tmpnode_rele(VAR_10);
			break;
		}
	} else {

		/* COMMENT_75 */
                                                        
                                              
     
		if (VAR_11 = tmp_taccess(VAR_1, VAR_30, cred))
			goto out;
		if (VAR_3 == VAR_27 || VAR_3 == VAR_28) {
			/* COMMENT_79 */
                                                       
      
			VAR_11 = tdirmaketnode(VAR_1, VAR_0, VAR_6, VAR_3, &VAR_5, cred);
			if (VAR_11)
				goto out;
		}
		if (VAR_11 = tdiraddentry(VAR_1, VAR_5, VAR_2, VAR_3, VAR_4)) {
			if (VAR_3 == VAR_27 || VAR_3 == VAR_28) {
				/* COMMENT_82 */
                                     
       
				rw_enter(&VAR_5->tn_rwlock, VAR_18);
				if ((VAR_5->tn_type) == VAR_13) {
					ASSERT(VAR_9 == NULL);
					/* COMMENT_85 */
                                         
        
					tdirtrunc(VAR_5);
				}
				mutex_enter(&VAR_5->tn_tlock);
				VAR_5->tn_nlink = 0;
				mutex_exit(&VAR_5->tn_tlock);
				gethrestime(&VAR_5->tn_ctime);
				rw_exit(&VAR_5->tn_rwlock);
				tmpnode_rele(VAR_5);
				VAR_5 = NULL;
			}
		} else if (VAR_7) {
			*VAR_7 = VAR_5;
		} else if (VAR_3 == VAR_27 || VAR_3 == VAR_28) {
			tmpnode_rele(VAR_5);
		}
	}

out:
	if (VAR_11 && (VAR_3 == VAR_15 || VAR_3 == VAR_16)) {
		/* COMMENT_88 */
                            
     
		DECR_COUNT(&VAR_5->tn_nlink, &VAR_5->tn_tlock);
		gethrestime(&VAR_5->tn_ctime);
	}
	return (VAR_11);
}",illumos/illumos-gate/f859e7171bb5db34321e45585839c6c3200ebb90/tmp_dir.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -38,8 +38,65 @@
 	 * to see if it has been removed while it was unlocked.
 	 */
 	if (op == DE_LINK || op == DE_RENAME) {
-		if (tp != dir)
-			rw_enter(&tp->tn_rwlock, RW_WRITER);
+		if (tp != dir) {
+			unsigned int tries = 0;
+
+			/*
+			 * If we are acquiring tp->tn_rwlock (for SOURCE)
+			 * inside here, we must consider the following:
+			 *
+			 * - dir->tn_rwlock (TARGET) is already HELD (see
+			 * above ASSERT()).
+			 *
+			 * - It is possible our SOURCE is a parent of our
+			 * TARGET. Yes it's unusual, but it will return an
+			 * error below via tdircheckpath().
+			 *
+			 * - It is also possible that another thread,
+			 * concurrent to this one, is performing
+			 * rmdir(TARGET), which means it will first acquire
+			 * SOURCE's lock, THEN acquire TARGET's lock, which
+			 * could result in this thread holding TARGET and
+			 * trying for SOURCE, but the other thread holding
+			 * SOURCE and trying for TARGET.  This is deadlock,
+			 * and it's inducible.
+			 *
+			 * To prevent this, we borrow some techniques from UFS
+			 * and rw_tryenter(), delaying if we fail, and
+			 * if someone tweaks the number of backoff tries to be
+			 * nonzero, return EBUSY after that number of tries.
+			 */
+			while (!rw_tryenter(&tp->tn_rwlock, RW_WRITER)) {
+				/*
+				 * Sloppy, but this is a diagnostic so atomic
+				 * increment would be overkill.
+				 */
+				tmpfs_rename_loops++;
+
+				if (tmpfs_rename_backoff_tries != 0) {
+					if (tries > tmpfs_rename_backoff_tries)
+						return (EBUSY);
+					tries++;
+				}
+				/*
+				 * NOTE: We're still holding dir->tn_rwlock,
+				 * so drop it over the delay, so any other
+				 * thread can get its business done.
+				 *
+				 * No state change or state inspection happens
+				 * prior to here, so it is not wholly dangerous
+				 * to release-and-reacquire dir->tn_rwlock.
+				 *
+				 * Hold the vnode of dir in case it gets
+				 * released by another thread, though.
+				 */
+				VN_HOLD(TNTOV(dir));
+				rw_exit(&dir->tn_rwlock);
+				delay(tmpfs_rename_backoff_delay);
+				rw_enter(&dir->tn_rwlock, RW_WRITER);
+				VN_RELE(TNTOV(dir));
+			}
+		}
 		mutex_enter(&tp->tn_tlock);
 		if (tp->tn_nlink == 0) {
 			mutex_exit(&tp->tn_tlock);","{'deleted_lines': ['\t\tif (tp != dir)', '\t\t\trw_enter(&tp->tn_rwlock, RW_WRITER);'], 'added_lines': ['\t\tif (tp != dir) {', '\t\t\tunsigned int tries = 0;', '', '\t\t\t/*', '\t\t\t * If we are acquiring tp->tn_rwlock (for SOURCE)', '\t\t\t * inside here, we must consider the following:', '\t\t\t *', '\t\t\t * - dir->tn_rwlock (TARGET) is already HELD (see', '\t\t\t * above ASSERT()).', '\t\t\t *', '\t\t\t * - It is possible our SOURCE is a parent of our', ""\t\t\t * TARGET. Yes it's unusual, but it will return an"", '\t\t\t * error below via tdircheckpath().', '\t\t\t *', '\t\t\t * - It is also possible that another thread,', '\t\t\t * concurrent to this one, is performing', '\t\t\t * rmdir(TARGET), which means it will first acquire', ""\t\t\t * SOURCE's lock, THEN acquire TARGET's lock, which"", '\t\t\t * could result in this thread holding TARGET and', '\t\t\t * trying for SOURCE, but the other thread holding', '\t\t\t * SOURCE and trying for TARGET.  This is deadlock,', ""\t\t\t * and it's inducible."", '\t\t\t *', '\t\t\t * To prevent this, we borrow some techniques from UFS', '\t\t\t * and rw_tryenter(), delaying if we fail, and', '\t\t\t * if someone tweaks the number of backoff tries to be', '\t\t\t * nonzero, return EBUSY after that number of tries.', '\t\t\t */', '\t\t\twhile (!rw_tryenter(&tp->tn_rwlock, RW_WRITER)) {', '\t\t\t\t/*', '\t\t\t\t * Sloppy, but this is a diagnostic so atomic', '\t\t\t\t * increment would be overkill.', '\t\t\t\t */', '\t\t\t\ttmpfs_rename_loops++;', '', '\t\t\t\tif (tmpfs_rename_backoff_tries != 0) {', '\t\t\t\t\tif (tries > tmpfs_rename_backoff_tries)', '\t\t\t\t\t\treturn (EBUSY);', '\t\t\t\t\ttries++;', '\t\t\t\t}', '\t\t\t\t/*', ""\t\t\t\t * NOTE: We're still holding dir->tn_rwlock,"", '\t\t\t\t * so drop it over the delay, so any other', '\t\t\t\t * thread can get its business done.', '\t\t\t\t *', '\t\t\t\t * No state change or state inspection happens', '\t\t\t\t * prior to here, so it is not wholly dangerous', '\t\t\t\t * to release-and-reacquire dir->tn_rwlock.', '\t\t\t\t *', '\t\t\t\t * Hold the vnode of dir in case it gets', '\t\t\t\t * released by another thread, though.', '\t\t\t\t */', '\t\t\t\tVN_HOLD(TNTOV(dir));', '\t\t\t\trw_exit(&dir->tn_rwlock);', '\t\t\t\tdelay(tmpfs_rename_backoff_delay);', '\t\t\t\trw_enter(&dir->tn_rwlock, RW_WRITER);', '\t\t\t\tVN_RELE(TNTOV(dir));', '\t\t\t}', '\t\t}']}",True,"An issue was discovered in illumos before f859e7171bb5db34321e45585839c6c3200ebb90, OmniOS Community Edition r151038, OpenIndiana Hipster 2021.04, and SmartOS 20210923. A local unprivileged user can cause a deadlock and kernel panic via crafted rename and rmdir calls on tmpfs filesystems. Oracle Solaris 10 and 11 is also affected.",5.5,MEDIUM,1,valid,2021-11-05T01:55:12Z,3
CVE-2022-23565,['CWE-617'],AV:N/AC:L/Au:S/C:N/I:N/A:P,0,tensorflow,"Remove a `DCHECK`-fail, log an error instead.

`DCHECK` in debug mode results in crashes. TensorFlow has had multiple vulnerabilities due to this.

Outside of debug mode, `DCHECK` is a no-op.

A better alternative is to report an error to the log buffer and continue. This should happen both in debug mode and in prod mode.

PiperOrigin-RevId: 408375925
Change-Id: Id5b3e19c73f3fbe0cc4bba26ca44ff9607bb6356",c2b31ff2d3151acb230edc3f5b1832d2c713a9e0,https://github.com/tensorflow/tensorflow/commit/c2b31ff2d3151acb230edc3f5b1832d2c713a9e0,tensorflow/core/framework/op_def_util.cc,RepeatedAttrDefEqual,"bool RepeatedAttrDefEqual(
const protobuf::RepeatedPtrField<OpDef::AttrDef>& a1,
const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {
std::unordered_map<string, const OpDef::AttrDef*> a1_set;
for (const OpDef::AttrDef& def : a1) {
DCHECK(a1_set.find(def.name()) == a1_set.end())
<< ""AttrDef names must be unique, but '"" << def.name()
<< ""' appears more than once"";
a1_set[def.name()] = &def;
}
for (const OpDef::AttrDef& def : a2) {
auto iter = a1_set.find(def.name());
if (iter == a1_set.end()) return false;
if (!AttrDefEqual(*iter->second, def)) return false;
a1_set.erase(iter);
}
if (!a1_set.empty()) return false;
return true;
}","bool RepeatedAttrDefEqual(
const protobuf::RepeatedPtrField<OpDef::AttrDef>& VAR_0,
const protobuf::RepeatedPtrField<OpDef::AttrDef>& VAR_1) {
std::unordered_map<string, const OpDef::AttrDef*> VAR_2;
for (const OpDef::AttrDef& VAR_3 : VAR_0) {
DCHECK(VAR_2.find(VAR_3.name()) == VAR_2.end())
<< ""AttrDef names must be unique, but '"" << VAR_3.name()
<< ""' appears more than once"";
VAR_2[VAR_3.name()] = &VAR_3;
}
for (const OpDef::AttrDef& VAR_3 : VAR_1) {
auto VAR_4 = VAR_2.find(VAR_3.name());
if (VAR_4 == VAR_2.end()) return false;
if (!AttrDefEqual(*VAR_4->second, VAR_3)) return false;
VAR_2.erase(VAR_4);
}
if (!VAR_2.empty()) return false;
return true;
}",tensorflow/c2b31ff2d3151acb230edc3f5b1832d2c713a9e0/op_def_util.cc/vul/before/0.json,"bool RepeatedAttrDefEqual(
    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a1,
    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {
  std::unordered_map<string, const OpDef::AttrDef*> a1_set;
  for (const OpDef::AttrDef& def : a1) {
    if (a1_set.find(def.name()) != a1_set.end()) {
      LOG(ERROR) << ""AttrDef names must be unique, but '"" << def.name()
                 << ""' appears more than once"";
    }
    a1_set[def.name()] = &def;
  }
  for (const OpDef::AttrDef& def : a2) {
    auto iter = a1_set.find(def.name());
    if (iter == a1_set.end()) return false;
    if (!AttrDefEqual(*iter->second, def)) return false;
    a1_set.erase(iter);
  }
  if (!a1_set.empty()) return false;
  return true;
}","bool RepeatedAttrDefEqual(
    const protobuf::RepeatedPtrField<OpDef::AttrDef>& VAR_0,
    const protobuf::RepeatedPtrField<OpDef::AttrDef>& VAR_1) {
  std::unordered_map<string, const OpDef::AttrDef*> VAR_2;
  for (const OpDef::AttrDef& VAR_3 : VAR_0) {
    if (VAR_2.find(VAR_3.name()) != VAR_2.end()) {
      LOG(VAR_4) << ""AttrDef names must be unique, but '"" << VAR_3.name()
                 << ""' appears more than once"";
    }
    VAR_2[VAR_3.name()] = &VAR_3;
  }
  for (const OpDef::AttrDef& VAR_3 : VAR_1) {
    auto VAR_5 = VAR_2.find(VAR_3.name());
    if (VAR_5 == VAR_2.end()) return false;
    if (!AttrDefEqual(*VAR_5->second, VAR_3)) return false;
    VAR_2.erase(VAR_5);
  }
  if (!VAR_2.empty()) return false;
  return true;
}",tensorflow/c2b31ff2d3151acb230edc3f5b1832d2c713a9e0/op_def_util.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,9 +3,10 @@
     const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {
   std::unordered_map<string, const OpDef::AttrDef*> a1_set;
   for (const OpDef::AttrDef& def : a1) {
-    DCHECK(a1_set.find(def.name()) == a1_set.end())
-        << ""AttrDef names must be unique, but '"" << def.name()
-        << ""' appears more than once"";
+    if (a1_set.find(def.name()) != a1_set.end()) {
+      LOG(ERROR) << ""AttrDef names must be unique, but '"" << def.name()
+                 << ""' appears more than once"";
+    }
     a1_set[def.name()] = &def;
   }
   for (const OpDef::AttrDef& def : a2) {","{'deleted_lines': ['    DCHECK(a1_set.find(def.name()) == a1_set.end())', '        << ""AttrDef names must be unique, but \'"" << def.name()', '        << ""\' appears more than once"";'], 'added_lines': ['    if (a1_set.find(def.name()) != a1_set.end()) {', '      LOG(ERROR) << ""AttrDef names must be unique, but \'"" << def.name()', '                 << ""\' appears more than once"";', '    }']}",True,"Tensorflow is an Open Source Machine Learning Framework. An attacker can trigger denial of service via assertion failure by altering a `SavedModel` on disk such that `AttrDef`s of some operation are duplicated. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.",6.5,MEDIUM,1,valid,2021-11-08T18:14:10Z,3
CVE-2022-23572,['CWE-617'],AV:N/AC:L/Au:S/C:N/I:N/A:P,0,tensorflow,"Properly handle the case where `SpecializeType()` returns an error `Status`.

If the error case in `SpecializeType()` is reached, then we would get a crash when trying to access the value of an errorenous `StatusOr` object

PiperOrigin-RevId: 408380069
Change-Id: If3c3fc876dcf9384d5ec7a4985adc68c23ea7318",cb164786dc891ea11d3a900e90367c339305dc7b,https://github.com/tensorflow/tensorflow/commit/cb164786dc891ea11d3a900e90367c339305dc7b,tensorflow/core/framework/shape_inference.cc,InferenceContext::PreInputInit,"void InferenceContext::PreInputInit(
const OpDef& op_def, const std::vector<const Tensor*>& input_tensors,
const std::vector<ShapeHandle>& input_tensors_as_shapes) {
const auto ret = full_type::SpecializeType(attrs_, op_def);
DCHECK(ret.status().ok()) << ""while instantiating types: "" << ret.status();
ret_types_ = ret.ValueOrDie();
input_tensors_ = input_tensors;
input_tensors_as_shapes_ = input_tensors_as_shapes;
construction_status_ =
NameRangesForNode(attrs_, op_def, &input_name_map_, &output_name_map_);
if (!construction_status_.ok()) return;
int num_outputs = 0;
for (const auto& e : output_name_map_) {
num_outputs = std::max(num_outputs, e.second.second);
}
outputs_.assign(num_outputs, nullptr);
output_handle_shapes_and_types_.resize(num_outputs);
}","void InferenceContext::PreInputInit(
const OpDef& VAR_0, const std::vector<const Tensor*>& VAR_1,
const std::vector<ShapeHandle>& VAR_2) {
const auto VAR_3 = full_type::SpecializeType(VAR_4, VAR_0);
DCHECK(VAR_3.status().ok()) << ""while instantiating types: "" << VAR_3.status();
VAR_5 = VAR_3.ValueOrDie();
VAR_6 = VAR_1;
VAR_7 = VAR_2;
VAR_8 =
NameRangesForNode(VAR_4, VAR_0, &VAR_9, &VAR_10);
if (!VAR_8.ok()) return;
int VAR_11 = 0;
for (const auto& VAR_12 : VAR_10) {
VAR_11 = std::max(VAR_11, VAR_12.second.second);
}
VAR_13.assign(VAR_11, nullptr);
VAR_14.resize(VAR_11);
}",tensorflow/cb164786dc891ea11d3a900e90367c339305dc7b/shape_inference.cc/vul/before/0.json,"void InferenceContext::PreInputInit(
    const OpDef& op_def, const std::vector<const Tensor*>& input_tensors,
    const std::vector<ShapeHandle>& input_tensors_as_shapes) {
  // TODO(mdan): This is also done at graph construction. Run only here instead?
  const auto ret = full_type::SpecializeType(attrs_, op_def);
  if (!ret.status().ok()) {
    construction_status_ = ret.status();
    return;
  }
  ret_types_ = ret.ValueOrDie();

  input_tensors_ = input_tensors;
  input_tensors_as_shapes_ = input_tensors_as_shapes;

  construction_status_ =
      NameRangesForNode(attrs_, op_def, &input_name_map_, &output_name_map_);
  if (!construction_status_.ok()) return;

  int num_outputs = 0;
  for (const auto& e : output_name_map_) {
    num_outputs = std::max(num_outputs, e.second.second);
  }
  outputs_.assign(num_outputs, nullptr);
  output_handle_shapes_and_types_.resize(num_outputs);
}","void InferenceContext::PreInputInit(
    const OpDef& VAR_0, const std::vector<const Tensor*>& VAR_1,
    const std::vector<ShapeHandle>& VAR_2) {
  /* COMMENT_0 */
  const auto VAR_3 = full_type::SpecializeType(VAR_4, VAR_0);
  if (!VAR_3.status().ok()) {
    VAR_5 = VAR_3.status();
    return;
  }
  VAR_6 = VAR_3.ValueOrDie();

  VAR_7 = VAR_1;
  VAR_8 = VAR_2;

  VAR_5 =
      NameRangesForNode(VAR_4, VAR_0, &VAR_9, &VAR_10);
  if (!VAR_5.ok()) return;

  int VAR_11 = 0;
  for (const auto& VAR_12 : VAR_10) {
    VAR_11 = std::max(VAR_11, VAR_12.second.second);
  }
  VAR_13.assign(VAR_11, nullptr);
  VAR_14.resize(VAR_11);
}",tensorflow/cb164786dc891ea11d3a900e90367c339305dc7b/shape_inference.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,10 @@
     const std::vector<ShapeHandle>& input_tensors_as_shapes) {
   // TODO(mdan): This is also done at graph construction. Run only here instead?
   const auto ret = full_type::SpecializeType(attrs_, op_def);
-  DCHECK(ret.status().ok()) << ""while instantiating types: "" << ret.status();
+  if (!ret.status().ok()) {
+    construction_status_ = ret.status();
+    return;
+  }
   ret_types_ = ret.ValueOrDie();
 
   input_tensors_ = input_tensors;","{'deleted_lines': ['  DCHECK(ret.status().ok()) << ""while instantiating types: "" << ret.status();'], 'added_lines': ['  if (!ret.status().ok()) {', '    construction_status_ = ret.status();', '    return;', '  }']}",True,"Tensorflow is an Open Source Machine Learning Framework. Under certain scenarios, TensorFlow can fail to specialize a type during shape inference. This case is covered by the `DCHECK` function however, `DCHECK` is a no-op in production builds and an assertion failure in debug builds. In the first case execution proceeds to the `ValueOrDie` line. This results in an assertion failure as `ret` contains an error `Status`, not a value. In the second case we also get a crash due to the assertion failure. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, and TensorFlow 2.6.3, as these are also affected and still in supported range.",6.5,MEDIUM,1,valid,2021-11-08T18:28:34Z,3
CVE-2022-23587,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,tensorflow,"Prevent overflow in grappler cost estimation of crop&resize op.

The crop parameters are user controlled, so we should make sure a user can not trigger an overflow maliciously.

PiperOrigin-RevId: 409670234
Change-Id: I7994734a98b037c5642e051240329d16f959aae4",0aaaae6eca5a7175a193696383f582f53adab23f,https://github.com/tensorflow/tensorflow/commit/0aaaae6eca5a7175a193696383f582f53adab23f,tensorflow/core/grappler/costs/op_level_cost_estimator.cc,OpLevelCostEstimator::PredictCropAndResize,"Status OpLevelCostEstimator::PredictCropAndResize(const OpContext& op_context,
NodeCosts* node_costs) const {
bool found_unknown_shapes = false;
const auto method = op_context.op_info.attr().find(""method"");
bool use_bilinear_interp;
if (method == op_context.op_info.attr().end() ||
method->second.s() == ""bilinear"") {
use_bilinear_interp = true;
} else if (method->second.s() == ""nearest"") {
use_bilinear_interp = false;
} else {
LOG(WARNING) << ""method attr in CropAndResize invalid; expected bilinear ""
""or nearest."";
return PredictCostOfAnUnknownOp(op_context, node_costs);
}
const int64_t num_boxes = op_context.op_info.inputs(1).shape().dim(0).size();
const auto crop_shape = MaybeGetMinimumShape(
op_context.op_info.outputs(0).shape(), 4, &found_unknown_shapes);
const int64_t crop_height = crop_shape.dim(1).size();
const int64_t crop_width = crop_shape.dim(2).size();
const int64_t output_elements = CalculateTensorElementCount(
op_context.op_info.outputs(0), &found_unknown_shapes);
#define EIGEN_COST(X) Eigen::internal::functor_traits<Eigen::internal::X>::Cost
const auto sub_cost = EIGEN_COST(scalar_difference_op<float>);
const auto add_cost = EIGEN_COST(scalar_sum_op<float>);
const auto mul_cost = EIGEN_COST(scalar_product_op<float>);
auto div_cost = EIGEN_COST(scalar_div_cost<float>);
const auto floor_cost = EIGEN_COST(scalar_floor_op<float>);
const auto ceil_cost = EIGEN_COST(scalar_ceil_op<float>);
auto round_cost = EIGEN_COST(scalar_round_op<float>);
const auto cast_to_float_cost = Eigen::internal::functor_traits<
Eigen::internal::scalar_cast_op<int64_t, float>>::Cost;
#undef EIGEN_COST
int64_t ops = (sub_cost * 6 + mul_cost * 2 + div_cost * 2) * num_boxes;
ops += (mul_cost * 2 + sub_cost + add_cost) * crop_height * num_boxes;
ops += (mul_cost * 2 + sub_cost + add_cost) * crop_height * crop_width *
num_boxes;
if (use_bilinear_interp) {
ops += (floor_cost + ceil_cost + sub_cost) * crop_height * num_boxes;
ops += (floor_cost + ceil_cost + sub_cost) * crop_height * crop_width *
num_boxes;
ops +=
(cast_to_float_cost * 4 + add_cost * 3 + sub_cost * 3 + mul_cost * 3) *
output_elements;
} else  {
ops += round_cost * 2 * crop_height * crop_width * num_boxes;
ops += cast_to_float_cost * output_elements;
}
return PredictDefaultNodeCosts(ops, op_context, &found_unknown_shapes,
node_costs);
}","Status OpLevelCostEstimator::PredictCropAndResize(const OpContext& VAR_0,
NodeCosts* VAR_1) const {
bool VAR_2 = false;
const auto VAR_3 = VAR_0.op_info.attr().find(""method"");
bool VAR_4;
if (VAR_3 == VAR_0.op_info.attr().end() ||
VAR_3->second.s() == ""bilinear"") {
VAR_4 = true;
} else if (VAR_3->second.s() == ""nearest"") {
VAR_4 = false;
} else {
LOG(VAR_5) << ""method attr in CropAndResize invalid; expected bilinear ""
""or nearest."";
return PredictCostOfAnUnknownOp(VAR_0, VAR_1);
}
const int64_t VAR_6 = VAR_0.op_info.inputs(1).shape().dim(0).size();
const auto VAR_7 = MaybeGetMinimumShape(
VAR_0.op_info.outputs(0).shape(), 4, &VAR_2);
const int64_t VAR_8 = VAR_7.dim(1).size();
const int64_t VAR_9 = VAR_7.dim(2).size();
const int64_t VAR_10 = CalculateTensorElementCount(
VAR_0.op_info.outputs(0), &VAR_2);
#define EIGEN_COST(VAR_11) Eigen::internal::functor_traits<Eigen::internal::X>::Cost
const auto VAR_12 = EIGEN_COST(VAR_13<float>);
const auto VAR_14 = EIGEN_COST(VAR_15<float>);
const auto VAR_16 = EIGEN_COST(VAR_17<float>);
auto VAR_18 = EIGEN_COST(VAR_19<float>);
const auto VAR_20 = EIGEN_COST(VAR_21<float>);
const auto VAR_22 = EIGEN_COST(VAR_23<float>);
auto VAR_24 = EIGEN_COST(VAR_25<float>);
const auto VAR_26 = Eigen::internal::functor_traits<
Eigen::internal::scalar_cast_op<int64_t, float>>::Cost;
#undef EIGEN_COST
int64_t VAR_27 = (VAR_12 * 6 + VAR_16 * 2 + VAR_18 * 2) * VAR_6;
VAR_27 += (VAR_16 * 2 + VAR_12 + VAR_14) * VAR_8 * VAR_6;
VAR_27 += (VAR_16 * 2 + VAR_12 + VAR_14) * VAR_8 * VAR_9 *
VAR_6;
if (VAR_4) {
VAR_27 += (VAR_20 + VAR_22 + VAR_12) * VAR_8 * VAR_6;
VAR_27 += (VAR_20 + VAR_22 + VAR_12) * VAR_8 * VAR_9 *
VAR_6;
VAR_27 +=
(VAR_26 * 4 + VAR_14 * 3 + VAR_12 * 3 + VAR_16 * 3) *
VAR_10;
} else  {
VAR_27 += VAR_24 * 2 * VAR_8 * VAR_9 * VAR_6;
VAR_27 += VAR_26 * VAR_10;
}
return PredictDefaultNodeCosts(VAR_27, VAR_0, &VAR_2,
VAR_1);
}",tensorflow/0aaaae6eca5a7175a193696383f582f53adab23f/op_level_cost_estimator.cc/vul/before/0.json,"Status OpLevelCostEstimator::PredictCropAndResize(const OpContext& op_context,
                                                  NodeCosts* node_costs) const {
  bool found_unknown_shapes = false;

  const auto method = op_context.op_info.attr().find(""method"");
  bool use_bilinear_interp;
  if (method == op_context.op_info.attr().end() ||
      method->second.s() == ""bilinear"") {
    use_bilinear_interp = true;
  } else if (method->second.s() == ""nearest"") {
    use_bilinear_interp = false;
  } else {
    LOG(WARNING) << ""method attr in CropAndResize invalid; expected bilinear ""
                    ""or nearest."";
    return PredictCostOfAnUnknownOp(op_context, node_costs);
  }

  const int64_t num_boxes = op_context.op_info.inputs(1).shape().dim(0).size();
  const auto crop_shape = MaybeGetMinimumShape(
      op_context.op_info.outputs(0).shape(), 4, &found_unknown_shapes);
  const int64_t crop_height = crop_shape.dim(1).size();
  const int64_t crop_width = crop_shape.dim(2).size();
  const int64_t output_elements = CalculateTensorElementCount(
      op_context.op_info.outputs(0), &found_unknown_shapes);

#define EIGEN_COST(X) Eigen::internal::functor_traits<Eigen::internal::X>::Cost
  const auto sub_cost = EIGEN_COST(scalar_difference_op<float>);
  const auto add_cost = EIGEN_COST(scalar_sum_op<float>);
  const auto mul_cost = EIGEN_COST(scalar_product_op<float>);
  auto div_cost = EIGEN_COST(scalar_div_cost<float>);
  const auto floor_cost = EIGEN_COST(scalar_floor_op<float>);
  const auto ceil_cost = EIGEN_COST(scalar_ceil_op<float>);
  auto round_cost = EIGEN_COST(scalar_round_op<float>);
  const auto cast_to_float_cost = Eigen::internal::functor_traits<
      Eigen::internal::scalar_cast_op<int64_t, float>>::Cost;
#undef EIGEN_COST

  // Computing ops following
  // tensorflow/core/kernels/image/crop_and_resize_op.cc at 08/25/2020. Op
  // calculation differs from rough estimate in implementation, as it separates
  // out cost per box from cost per pixel and cost per element.

  // Since crop arguments are user controlled, check for overflow.
  int64_t crop_area = MultiplyWithoutOverflow(crop_height, crop_width);
  if (crop_area < 0)
    return errors::InvalidArgument(""Cannot estimate cost, multiplying "",
                                   crop_height, "" with "", crop_width,
                                   "" would overflow"");
  int64_t crop_volume = MultiplyWithoutOverflow(crop_area, num_boxes);
  if (crop_volume < 0)
    return errors::InvalidArgument(""Cannot estimate cost, multiplying "",
                                   crop_area, "" with "", num_boxes,
                                   "" would overflow"");
  int64_t crop_depth = MultiplyWithoutOverflow(crop_height, num_boxes);
  if (crop_depth < 0)
    return errors::InvalidArgument(""Cannot estimate cost, multiplying "",
                                   crop_height, "" with "", num_boxes,
                                   "" would overflow"");

  // Ops for variables height_scale and width_scale.
  int64_t ops = (sub_cost * 6 + mul_cost * 2 + div_cost * 2) * num_boxes;
  // Ops for variable in_y.
  ops += (mul_cost * 2 + sub_cost + add_cost) * crop_depth;
  // Ops for variable in_x (same computation across both branches).
  ops += (mul_cost * 2 + sub_cost + add_cost) * crop_volume;
  // Specify op_cost based on the method.
  if (use_bilinear_interp) {
    // Ops for variables top_y_index, bottom_y_index, y_lerp.
    ops += (floor_cost + ceil_cost + sub_cost) * crop_depth;
    // Ops for variables left_x, right_x, x_lerp;
    ops += (floor_cost + ceil_cost + sub_cost) * crop_volume;
    // Ops for innermost loop across depth.
    ops +=
        (cast_to_float_cost * 4 + add_cost * 3 + sub_cost * 3 + mul_cost * 3) *
        output_elements;
  } else /* method == ""nearest"" */ {
    // Ops for variables closest_x_index and closest_y_index.
    ops += round_cost * 2 * crop_volume;
    // Ops for innermost loop across depth.
    ops += cast_to_float_cost * output_elements;
  }
  return PredictDefaultNodeCosts(ops, op_context, &found_unknown_shapes,
                                 node_costs);
}","Status OpLevelCostEstimator::PredictCropAndResize(const OpContext& VAR_0,
                                                  NodeCosts* VAR_1) const {
  bool VAR_2 = false;

  const auto VAR_3 = VAR_0.op_info.attr().find(""method"");
  bool VAR_4;
  if (VAR_3 == VAR_0.op_info.attr().end() ||
      VAR_3->second.s() == ""bilinear"") {
    VAR_4 = true;
  } else if (VAR_3->second.s() == ""nearest"") {
    VAR_4 = false;
  } else {
    LOG(VAR_5) << ""method attr in CropAndResize invalid; expected bilinear ""
                    ""or nearest."";
    return PredictCostOfAnUnknownOp(VAR_0, VAR_1);
  }

  const int64_t VAR_6 = VAR_0.op_info.inputs(1).shape().dim(0).size();
  const auto VAR_7 = MaybeGetMinimumShape(
      VAR_0.op_info.outputs(0).shape(), 4, &VAR_2);
  const int64_t VAR_8 = VAR_7.dim(1).size();
  const int64_t VAR_9 = VAR_7.dim(2).size();
  const int64_t VAR_10 = CalculateTensorElementCount(
      VAR_0.op_info.outputs(0), &VAR_2);

#define EIGEN_COST(VAR_11) Eigen::internal::functor_traits<Eigen::internal::X>::Cost
  const auto VAR_12 = EIGEN_COST(VAR_13<float>);
  const auto VAR_14 = EIGEN_COST(VAR_15<float>);
  const auto VAR_16 = EIGEN_COST(VAR_17<float>);
  auto VAR_18 = EIGEN_COST(VAR_19<float>);
  const auto VAR_20 = EIGEN_COST(VAR_21<float>);
  const auto VAR_22 = EIGEN_COST(VAR_23<float>);
  auto VAR_24 = EIGEN_COST(VAR_25<float>);
  const auto VAR_26 = Eigen::internal::functor_traits<
      Eigen::internal::scalar_cast_op<int64_t, float>>::Cost;
#undef EIGEN_COST

  /* COMMENT_0 */
  /* COMMENT_1 */
  /* COMMENT_2 */
  /* COMMENT_3 */

  /* COMMENT_4 */
  int64_t VAR_27 = MultiplyWithoutOverflow(VAR_8, VAR_9);
  if (VAR_27 < 0)
    return errors::InvalidArgument(""Cannot estimate cost, multiplying "",
                                   VAR_8, "" with "", VAR_9,
                                   "" would overflow"");
  int64_t VAR_28 = MultiplyWithoutOverflow(VAR_27, VAR_6);
  if (VAR_28 < 0)
    return errors::InvalidArgument(""Cannot estimate cost, multiplying "",
                                   VAR_27, "" with "", VAR_6,
                                   "" would overflow"");
  int64_t VAR_29 = MultiplyWithoutOverflow(VAR_8, VAR_6);
  if (VAR_29 < 0)
    return errors::InvalidArgument(""Cannot estimate cost, multiplying "",
                                   VAR_8, "" with "", VAR_6,
                                   "" would overflow"");

  /* COMMENT_5 */
  int64_t VAR_30 = (VAR_12 * 6 + VAR_16 * 2 + VAR_18 * 2) * VAR_6;
  /* COMMENT_6 */
  VAR_30 += (VAR_16 * 2 + VAR_12 + VAR_14) * VAR_29;
  /* COMMENT_7 */
  VAR_30 += (VAR_16 * 2 + VAR_12 + VAR_14) * VAR_28;
  /* COMMENT_8 */
  if (VAR_4) {
    /* COMMENT_9 */
    VAR_30 += (VAR_20 + VAR_22 + VAR_12) * VAR_29;
    /* COMMENT_10 */
    VAR_30 += (VAR_20 + VAR_22 + VAR_12) * VAR_28;
    /* COMMENT_11 */
    VAR_30 +=
        (VAR_26 * 4 + VAR_14 * 3 + VAR_12 * 3 + VAR_16 * 3) *
        VAR_10;
  } else /* COMMENT_12 */ {
    /* COMMENT_13 */
    VAR_30 += VAR_24 * 2 * VAR_28;
    /* COMMENT_11 */
    VAR_30 += VAR_26 * VAR_10;
  }
  return PredictDefaultNodeCosts(VAR_30, VAR_0, &VAR_2,
                                 VAR_1);
}",tensorflow/0aaaae6eca5a7175a193696383f582f53adab23f/op_level_cost_estimator.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -40,27 +40,42 @@
   // calculation differs from rough estimate in implementation, as it separates
   // out cost per box from cost per pixel and cost per element.
 
+  // Since crop arguments are user controlled, check for overflow.
+  int64_t crop_area = MultiplyWithoutOverflow(crop_height, crop_width);
+  if (crop_area < 0)
+    return errors::InvalidArgument(""Cannot estimate cost, multiplying "",
+                                   crop_height, "" with "", crop_width,
+                                   "" would overflow"");
+  int64_t crop_volume = MultiplyWithoutOverflow(crop_area, num_boxes);
+  if (crop_volume < 0)
+    return errors::InvalidArgument(""Cannot estimate cost, multiplying "",
+                                   crop_area, "" with "", num_boxes,
+                                   "" would overflow"");
+  int64_t crop_depth = MultiplyWithoutOverflow(crop_height, num_boxes);
+  if (crop_depth < 0)
+    return errors::InvalidArgument(""Cannot estimate cost, multiplying "",
+                                   crop_height, "" with "", num_boxes,
+                                   "" would overflow"");
+
   // Ops for variables height_scale and width_scale.
   int64_t ops = (sub_cost * 6 + mul_cost * 2 + div_cost * 2) * num_boxes;
   // Ops for variable in_y.
-  ops += (mul_cost * 2 + sub_cost + add_cost) * crop_height * num_boxes;
+  ops += (mul_cost * 2 + sub_cost + add_cost) * crop_depth;
   // Ops for variable in_x (same computation across both branches).
-  ops += (mul_cost * 2 + sub_cost + add_cost) * crop_height * crop_width *
-         num_boxes;
+  ops += (mul_cost * 2 + sub_cost + add_cost) * crop_volume;
   // Specify op_cost based on the method.
   if (use_bilinear_interp) {
     // Ops for variables top_y_index, bottom_y_index, y_lerp.
-    ops += (floor_cost + ceil_cost + sub_cost) * crop_height * num_boxes;
+    ops += (floor_cost + ceil_cost + sub_cost) * crop_depth;
     // Ops for variables left_x, right_x, x_lerp;
-    ops += (floor_cost + ceil_cost + sub_cost) * crop_height * crop_width *
-           num_boxes;
+    ops += (floor_cost + ceil_cost + sub_cost) * crop_volume;
     // Ops for innermost loop across depth.
     ops +=
         (cast_to_float_cost * 4 + add_cost * 3 + sub_cost * 3 + mul_cost * 3) *
         output_elements;
   } else /* method == ""nearest"" */ {
     // Ops for variables closest_x_index and closest_y_index.
-    ops += round_cost * 2 * crop_height * crop_width * num_boxes;
+    ops += round_cost * 2 * crop_volume;
     // Ops for innermost loop across depth.
     ops += cast_to_float_cost * output_elements;
   }","{'deleted_lines': ['  ops += (mul_cost * 2 + sub_cost + add_cost) * crop_height * num_boxes;', '  ops += (mul_cost * 2 + sub_cost + add_cost) * crop_height * crop_width *', '         num_boxes;', '    ops += (floor_cost + ceil_cost + sub_cost) * crop_height * num_boxes;', '    ops += (floor_cost + ceil_cost + sub_cost) * crop_height * crop_width *', '           num_boxes;', '    ops += round_cost * 2 * crop_height * crop_width * num_boxes;'], 'added_lines': ['  // Since crop arguments are user controlled, check for overflow.', '  int64_t crop_area = MultiplyWithoutOverflow(crop_height, crop_width);', '  if (crop_area < 0)', '    return errors::InvalidArgument(""Cannot estimate cost, multiplying "",', '                                   crop_height, "" with "", crop_width,', '                                   "" would overflow"");', '  int64_t crop_volume = MultiplyWithoutOverflow(crop_area, num_boxes);', '  if (crop_volume < 0)', '    return errors::InvalidArgument(""Cannot estimate cost, multiplying "",', '                                   crop_area, "" with "", num_boxes,', '                                   "" would overflow"");', '  int64_t crop_depth = MultiplyWithoutOverflow(crop_height, num_boxes);', '  if (crop_depth < 0)', '    return errors::InvalidArgument(""Cannot estimate cost, multiplying "",', '                                   crop_height, "" with "", num_boxes,', '                                   "" would overflow"");', '', '  ops += (mul_cost * 2 + sub_cost + add_cost) * crop_depth;', '  ops += (mul_cost * 2 + sub_cost + add_cost) * crop_volume;', '    ops += (floor_cost + ceil_cost + sub_cost) * crop_depth;', '    ops += (floor_cost + ceil_cost + sub_cost) * crop_volume;', '    ops += round_cost * 2 * crop_volume;']}",True,"Tensorflow is an Open Source Machine Learning Framework. Under certain scenarios, Grappler component of TensorFlow is vulnerable to an integer overflow during cost estimation for crop and resize. Since the cropping parameters are user controlled, a malicious person can trigger undefined behavior. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.",8.8,HIGH,2,valid,2021-11-13T16:19:05Z,3
