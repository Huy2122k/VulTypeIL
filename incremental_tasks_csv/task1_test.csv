cve_id,cwe_ids,cvss_vector,cvss_is_v3,repo_name,commit_msg,commit_hash,git_url,file_path,func_name,func_before,abstract_func_before,func_graph_path_before,func,abstract_func,func_graph_path,diff_func,diff_line_info,is_vul,description,Base Score,Base Severity,severity,source,commit_time,task
CVE-2010-5331,['CWE-193'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"drivers/gpu/drm/radeon/radeon_atombios.c: range check issues

This change makes the array larger, ""MAX_SUPPORTED_TV_TIMING_V1_2"" is 3
and the original size ""MAX_SUPPORTED_TV_TIMING"" is 2.

Also there were checks that were off by one.

Signed-off-by: Dan Carpenter <error27@gmail.com>
Acked-by: Alex Deucher <alexdeucher@gmail.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Dave Airlie <airlied@redhat.com>",0031c41be5c529f8329e327b63cde92ba1284842,https://github.com/torvalds/linux/commit/0031c41be5c529f8329e327b63cde92ba1284842,drivers/gpu/drm/radeon/radeon_atombios.c,radeon_atom_get_tv_timings,"bool radeon_atom_get_tv_timings(struct radeon_device *rdev, int index,
struct drm_display_mode *mode)
{
struct radeon_mode_info *mode_info = &rdev->mode_info;
ATOM_ANALOG_TV_INFO *tv_info;
ATOM_ANALOG_TV_INFO_V1_2 *tv_info_v1_2;
ATOM_DTD_FORMAT *dtd_timings;
int data_index = GetIndexIntoMasterTable(DATA, AnalogTV_Info);
u8 frev, crev;
u16 data_offset, misc;
if (!atom_parse_data_header(mode_info->atom_context, data_index, NULL,
&frev, &crev, &data_offset))
return false;
switch (crev) {
case 1:
tv_info = (ATOM_ANALOG_TV_INFO *)(mode_info->atom_context->bios + data_offset);
if (index > MAX_SUPPORTED_TV_TIMING)
return false;
mode->crtc_htotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Total);
mode->crtc_hdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Disp);
mode->crtc_hsync_start = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncStart);
mode->crtc_hsync_end = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncStart) +
le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncWidth);
mode->crtc_vtotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_Total);
mode->crtc_vdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_Disp);
mode->crtc_vsync_start = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart);
mode->crtc_vsync_end = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart) +
le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncWidth);
mode->flags = 0;
misc = le16_to_cpu(tv_info->aModeTimings[index].susModeMiscInfo.usAccess);
if (misc & ATOM_VSYNC_POLARITY)
mode->flags |= DRM_MODE_FLAG_NVSYNC;
if (misc & ATOM_HSYNC_POLARITY)
mode->flags |= DRM_MODE_FLAG_NHSYNC;
if (misc & ATOM_COMPOSITESYNC)
mode->flags |= DRM_MODE_FLAG_CSYNC;
if (misc & ATOM_INTERLACE)
mode->flags |= DRM_MODE_FLAG_INTERLACE;
if (misc & ATOM_DOUBLE_CLOCK_MODE)
mode->flags |= DRM_MODE_FLAG_DBLSCAN;
mode->clock = le16_to_cpu(tv_info->aModeTimings[index].usPixelClock) * 10;
if (index == 1) {
mode->crtc_htotal -= 1;
mode->crtc_vtotal -= 1;
}
break;
case 2:
tv_info_v1_2 = (ATOM_ANALOG_TV_INFO_V1_2 *)(mode_info->atom_context->bios + data_offset);
if (index > MAX_SUPPORTED_TV_TIMING_V1_2)
return false;
dtd_timings = &tv_info_v1_2->aModeTimings[index];
mode->crtc_htotal = le16_to_cpu(dtd_timings->usHActive) +
le16_to_cpu(dtd_timings->usHBlanking_Time);
mode->crtc_hdisplay = le16_to_cpu(dtd_timings->usHActive);
mode->crtc_hsync_start = le16_to_cpu(dtd_timings->usHActive) +
le16_to_cpu(dtd_timings->usHSyncOffset);
mode->crtc_hsync_end = mode->crtc_hsync_start +
le16_to_cpu(dtd_timings->usHSyncWidth);
mode->crtc_vtotal = le16_to_cpu(dtd_timings->usVActive) +
le16_to_cpu(dtd_timings->usVBlanking_Time);
mode->crtc_vdisplay = le16_to_cpu(dtd_timings->usVActive);
mode->crtc_vsync_start = le16_to_cpu(dtd_timings->usVActive) +
le16_to_cpu(dtd_timings->usVSyncOffset);
mode->crtc_vsync_end = mode->crtc_vsync_start +
le16_to_cpu(dtd_timings->usVSyncWidth);
mode->flags = 0;
misc = le16_to_cpu(dtd_timings->susModeMiscInfo.usAccess);
if (misc & ATOM_VSYNC_POLARITY)
mode->flags |= DRM_MODE_FLAG_NVSYNC;
if (misc & ATOM_HSYNC_POLARITY)
mode->flags |= DRM_MODE_FLAG_NHSYNC;
if (misc & ATOM_COMPOSITESYNC)
mode->flags |= DRM_MODE_FLAG_CSYNC;
if (misc & ATOM_INTERLACE)
mode->flags |= DRM_MODE_FLAG_INTERLACE;
if (misc & ATOM_DOUBLE_CLOCK_MODE)
mode->flags |= DRM_MODE_FLAG_DBLSCAN;
mode->clock = le16_to_cpu(dtd_timings->usPixClk) * 10;
break;
}
return true;
}","bool radeon_atom_get_tv_timings(struct radeon_device *VAR_0, int VAR_1,
struct drm_display_mode *VAR_2)
{
struct radeon_mode_info *VAR_3 = &VAR_0->mode_info;
ATOM_ANALOG_TV_INFO *VAR_4;
ATOM_ANALOG_TV_INFO_V1_2 *VAR_5;
ATOM_DTD_FORMAT *VAR_6;
int VAR_7 = GetIndexIntoMasterTable(VAR_8, VAR_9);
u8 VAR_10, VAR_11;
u16 VAR_12, VAR_13;
if (!atom_parse_data_header(VAR_3->atom_context, VAR_7, NULL,
&VAR_10, &VAR_11, &VAR_12))
return false;
switch (VAR_11) {
case 1:
VAR_4 = (ATOM_ANALOG_TV_INFO *)(VAR_3->atom_context->bios + VAR_12);
if (VAR_1 > VAR_14)
return false;
VAR_2->crtc_htotal = le16_to_cpu(VAR_4->aModeTimings[VAR_1].usCRTC_H_Total);
VAR_2->crtc_hdisplay = le16_to_cpu(VAR_4->aModeTimings[VAR_1].usCRTC_H_Disp);
VAR_2->crtc_hsync_start = le16_to_cpu(VAR_4->aModeTimings[VAR_1].usCRTC_H_SyncStart);
VAR_2->crtc_hsync_end = le16_to_cpu(VAR_4->aModeTimings[VAR_1].usCRTC_H_SyncStart) +
le16_to_cpu(VAR_4->aModeTimings[VAR_1].usCRTC_H_SyncWidth);
VAR_2->crtc_vtotal = le16_to_cpu(VAR_4->aModeTimings[VAR_1].usCRTC_V_Total);
VAR_2->crtc_vdisplay = le16_to_cpu(VAR_4->aModeTimings[VAR_1].usCRTC_V_Disp);
VAR_2->crtc_vsync_start = le16_to_cpu(VAR_4->aModeTimings[VAR_1].usCRTC_V_SyncStart);
VAR_2->crtc_vsync_end = le16_to_cpu(VAR_4->aModeTimings[VAR_1].usCRTC_V_SyncStart) +
le16_to_cpu(VAR_4->aModeTimings[VAR_1].usCRTC_V_SyncWidth);
VAR_2->flags = 0;
VAR_13 = le16_to_cpu(VAR_4->aModeTimings[VAR_1].susModeMiscInfo.usAccess);
if (VAR_13 & VAR_15)
VAR_2->flags |= VAR_16;
if (VAR_13 & VAR_17)
VAR_2->flags |= VAR_18;
if (VAR_13 & VAR_19)
VAR_2->flags |= VAR_20;
if (VAR_13 & VAR_21)
VAR_2->flags |= VAR_22;
if (VAR_13 & VAR_23)
VAR_2->flags |= VAR_24;
VAR_2->clock = le16_to_cpu(VAR_4->aModeTimings[VAR_1].usPixelClock) * 10;
if (VAR_1 == 1) {
VAR_2->crtc_htotal -= 1;
VAR_2->crtc_vtotal -= 1;
}
break;
case 2:
VAR_5 = (ATOM_ANALOG_TV_INFO_V1_2 *)(VAR_3->atom_context->bios + VAR_12);
if (VAR_1 > VAR_25)
return false;
VAR_6 = &VAR_5->aModeTimings[VAR_1];
VAR_2->crtc_htotal = le16_to_cpu(VAR_6->usHActive) +
le16_to_cpu(VAR_6->usHBlanking_Time);
VAR_2->crtc_hdisplay = le16_to_cpu(VAR_6->usHActive);
VAR_2->crtc_hsync_start = le16_to_cpu(VAR_6->usHActive) +
le16_to_cpu(VAR_6->usHSyncOffset);
VAR_2->crtc_hsync_end = VAR_2->crtc_hsync_start +
le16_to_cpu(VAR_6->usHSyncWidth);
VAR_2->crtc_vtotal = le16_to_cpu(VAR_6->usVActive) +
le16_to_cpu(VAR_6->usVBlanking_Time);
VAR_2->crtc_vdisplay = le16_to_cpu(VAR_6->usVActive);
VAR_2->crtc_vsync_start = le16_to_cpu(VAR_6->usVActive) +
le16_to_cpu(VAR_6->usVSyncOffset);
VAR_2->crtc_vsync_end = VAR_2->crtc_vsync_start +
le16_to_cpu(VAR_6->usVSyncWidth);
VAR_2->flags = 0;
VAR_13 = le16_to_cpu(VAR_6->susModeMiscInfo.usAccess);
if (VAR_13 & VAR_15)
VAR_2->flags |= VAR_16;
if (VAR_13 & VAR_17)
VAR_2->flags |= VAR_18;
if (VAR_13 & VAR_19)
VAR_2->flags |= VAR_20;
if (VAR_13 & VAR_21)
VAR_2->flags |= VAR_22;
if (VAR_13 & VAR_23)
VAR_2->flags |= VAR_24;
VAR_2->clock = le16_to_cpu(VAR_6->usPixClk) * 10;
break;
}
return true;
}",torvalds/linux/0031c41be5c529f8329e327b63cde92ba1284842/radeon_atombios.c/vul/before/0.json,"bool radeon_atom_get_tv_timings(struct radeon_device *rdev, int index,
				struct drm_display_mode *mode)
{
	struct radeon_mode_info *mode_info = &rdev->mode_info;
	ATOM_ANALOG_TV_INFO *tv_info;
	ATOM_ANALOG_TV_INFO_V1_2 *tv_info_v1_2;
	ATOM_DTD_FORMAT *dtd_timings;
	int data_index = GetIndexIntoMasterTable(DATA, AnalogTV_Info);
	u8 frev, crev;
	u16 data_offset, misc;

	if (!atom_parse_data_header(mode_info->atom_context, data_index, NULL,
				    &frev, &crev, &data_offset))
		return false;

	switch (crev) {
	case 1:
		tv_info = (ATOM_ANALOG_TV_INFO *)(mode_info->atom_context->bios + data_offset);
		if (index >= MAX_SUPPORTED_TV_TIMING)
			return false;

		mode->crtc_htotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Total);
		mode->crtc_hdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Disp);
		mode->crtc_hsync_start = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncStart);
		mode->crtc_hsync_end = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncStart) +
			le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncWidth);

		mode->crtc_vtotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_Total);
		mode->crtc_vdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_Disp);
		mode->crtc_vsync_start = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart);
		mode->crtc_vsync_end = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart) +
			le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncWidth);

		mode->flags = 0;
		misc = le16_to_cpu(tv_info->aModeTimings[index].susModeMiscInfo.usAccess);
		if (misc & ATOM_VSYNC_POLARITY)
			mode->flags |= DRM_MODE_FLAG_NVSYNC;
		if (misc & ATOM_HSYNC_POLARITY)
			mode->flags |= DRM_MODE_FLAG_NHSYNC;
		if (misc & ATOM_COMPOSITESYNC)
			mode->flags |= DRM_MODE_FLAG_CSYNC;
		if (misc & ATOM_INTERLACE)
			mode->flags |= DRM_MODE_FLAG_INTERLACE;
		if (misc & ATOM_DOUBLE_CLOCK_MODE)
			mode->flags |= DRM_MODE_FLAG_DBLSCAN;

		mode->clock = le16_to_cpu(tv_info->aModeTimings[index].usPixelClock) * 10;

		if (index == 1) {
			/* PAL timings appear to have wrong values for totals */
			mode->crtc_htotal -= 1;
			mode->crtc_vtotal -= 1;
		}
		break;
	case 2:
		tv_info_v1_2 = (ATOM_ANALOG_TV_INFO_V1_2 *)(mode_info->atom_context->bios + data_offset);
		if (index >= MAX_SUPPORTED_TV_TIMING_V1_2)
			return false;

		dtd_timings = &tv_info_v1_2->aModeTimings[index];
		mode->crtc_htotal = le16_to_cpu(dtd_timings->usHActive) +
			le16_to_cpu(dtd_timings->usHBlanking_Time);
		mode->crtc_hdisplay = le16_to_cpu(dtd_timings->usHActive);
		mode->crtc_hsync_start = le16_to_cpu(dtd_timings->usHActive) +
			le16_to_cpu(dtd_timings->usHSyncOffset);
		mode->crtc_hsync_end = mode->crtc_hsync_start +
			le16_to_cpu(dtd_timings->usHSyncWidth);

		mode->crtc_vtotal = le16_to_cpu(dtd_timings->usVActive) +
			le16_to_cpu(dtd_timings->usVBlanking_Time);
		mode->crtc_vdisplay = le16_to_cpu(dtd_timings->usVActive);
		mode->crtc_vsync_start = le16_to_cpu(dtd_timings->usVActive) +
			le16_to_cpu(dtd_timings->usVSyncOffset);
		mode->crtc_vsync_end = mode->crtc_vsync_start +
			le16_to_cpu(dtd_timings->usVSyncWidth);

		mode->flags = 0;
		misc = le16_to_cpu(dtd_timings->susModeMiscInfo.usAccess);
		if (misc & ATOM_VSYNC_POLARITY)
			mode->flags |= DRM_MODE_FLAG_NVSYNC;
		if (misc & ATOM_HSYNC_POLARITY)
			mode->flags |= DRM_MODE_FLAG_NHSYNC;
		if (misc & ATOM_COMPOSITESYNC)
			mode->flags |= DRM_MODE_FLAG_CSYNC;
		if (misc & ATOM_INTERLACE)
			mode->flags |= DRM_MODE_FLAG_INTERLACE;
		if (misc & ATOM_DOUBLE_CLOCK_MODE)
			mode->flags |= DRM_MODE_FLAG_DBLSCAN;

		mode->clock = le16_to_cpu(dtd_timings->usPixClk) * 10;
		break;
	}
	return true;
}","bool radeon_atom_get_tv_timings(struct radeon_device *VAR_0, int VAR_1,
				struct drm_display_mode *VAR_2)
{
	struct radeon_mode_info *VAR_3 = &VAR_0->mode_info;
	ATOM_ANALOG_TV_INFO *VAR_4;
	ATOM_ANALOG_TV_INFO_V1_2 *VAR_5;
	ATOM_DTD_FORMAT *VAR_6;
	int VAR_7 = GetIndexIntoMasterTable(VAR_8, VAR_9);
	u8 VAR_10, VAR_11;
	u16 VAR_12, VAR_13;

	if (!atom_parse_data_header(VAR_3->atom_context, VAR_7, NULL,
				    &VAR_10, &VAR_11, &VAR_12))
		return false;

	switch (VAR_11) {
	case 1:
		VAR_4 = (ATOM_ANALOG_TV_INFO *)(VAR_3->atom_context->bios + VAR_12);
		if (VAR_1 >= VAR_14)
			return false;

		VAR_2->crtc_htotal = le16_to_cpu(VAR_4->aModeTimings[VAR_1].usCRTC_H_Total);
		VAR_2->crtc_hdisplay = le16_to_cpu(VAR_4->aModeTimings[VAR_1].usCRTC_H_Disp);
		VAR_2->crtc_hsync_start = le16_to_cpu(VAR_4->aModeTimings[VAR_1].usCRTC_H_SyncStart);
		VAR_2->crtc_hsync_end = le16_to_cpu(VAR_4->aModeTimings[VAR_1].usCRTC_H_SyncStart) +
			le16_to_cpu(VAR_4->aModeTimings[VAR_1].usCRTC_H_SyncWidth);

		VAR_2->crtc_vtotal = le16_to_cpu(VAR_4->aModeTimings[VAR_1].usCRTC_V_Total);
		VAR_2->crtc_vdisplay = le16_to_cpu(VAR_4->aModeTimings[VAR_1].usCRTC_V_Disp);
		VAR_2->crtc_vsync_start = le16_to_cpu(VAR_4->aModeTimings[VAR_1].usCRTC_V_SyncStart);
		VAR_2->crtc_vsync_end = le16_to_cpu(VAR_4->aModeTimings[VAR_1].usCRTC_V_SyncStart) +
			le16_to_cpu(VAR_4->aModeTimings[VAR_1].usCRTC_V_SyncWidth);

		VAR_2->flags = 0;
		VAR_13 = le16_to_cpu(VAR_4->aModeTimings[VAR_1].susModeMiscInfo.usAccess);
		if (VAR_13 & VAR_15)
			VAR_2->flags |= VAR_16;
		if (VAR_13 & VAR_17)
			VAR_2->flags |= VAR_18;
		if (VAR_13 & VAR_19)
			VAR_2->flags |= VAR_20;
		if (VAR_13 & VAR_21)
			VAR_2->flags |= VAR_22;
		if (VAR_13 & VAR_23)
			VAR_2->flags |= VAR_24;

		VAR_2->clock = le16_to_cpu(VAR_4->aModeTimings[VAR_1].usPixelClock) * 10;

		if (VAR_1 == 1) {
			/* COMMENT_0 */
			VAR_2->crtc_htotal -= 1;
			VAR_2->crtc_vtotal -= 1;
		}
		break;
	case 2:
		VAR_5 = (ATOM_ANALOG_TV_INFO_V1_2 *)(VAR_3->atom_context->bios + VAR_12);
		if (VAR_1 >= VAR_25)
			return false;

		VAR_6 = &VAR_5->aModeTimings[VAR_1];
		VAR_2->crtc_htotal = le16_to_cpu(VAR_6->usHActive) +
			le16_to_cpu(VAR_6->usHBlanking_Time);
		VAR_2->crtc_hdisplay = le16_to_cpu(VAR_6->usHActive);
		VAR_2->crtc_hsync_start = le16_to_cpu(VAR_6->usHActive) +
			le16_to_cpu(VAR_6->usHSyncOffset);
		VAR_2->crtc_hsync_end = VAR_2->crtc_hsync_start +
			le16_to_cpu(VAR_6->usHSyncWidth);

		VAR_2->crtc_vtotal = le16_to_cpu(VAR_6->usVActive) +
			le16_to_cpu(VAR_6->usVBlanking_Time);
		VAR_2->crtc_vdisplay = le16_to_cpu(VAR_6->usVActive);
		VAR_2->crtc_vsync_start = le16_to_cpu(VAR_6->usVActive) +
			le16_to_cpu(VAR_6->usVSyncOffset);
		VAR_2->crtc_vsync_end = VAR_2->crtc_vsync_start +
			le16_to_cpu(VAR_6->usVSyncWidth);

		VAR_2->flags = 0;
		VAR_13 = le16_to_cpu(VAR_6->susModeMiscInfo.usAccess);
		if (VAR_13 & VAR_15)
			VAR_2->flags |= VAR_16;
		if (VAR_13 & VAR_17)
			VAR_2->flags |= VAR_18;
		if (VAR_13 & VAR_19)
			VAR_2->flags |= VAR_20;
		if (VAR_13 & VAR_21)
			VAR_2->flags |= VAR_22;
		if (VAR_13 & VAR_23)
			VAR_2->flags |= VAR_24;

		VAR_2->clock = le16_to_cpu(VAR_6->usPixClk) * 10;
		break;
	}
	return true;
}",torvalds/linux/0031c41be5c529f8329e327b63cde92ba1284842/radeon_atombios.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -16,7 +16,7 @@
 	switch (crev) {
 	case 1:
 		tv_info = (ATOM_ANALOG_TV_INFO *)(mode_info->atom_context->bios + data_offset);
-		if (index > MAX_SUPPORTED_TV_TIMING)
+		if (index >= MAX_SUPPORTED_TV_TIMING)
 			return false;
 
 		mode->crtc_htotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Total);
@@ -54,7 +54,7 @@
 		break;
 	case 2:
 		tv_info_v1_2 = (ATOM_ANALOG_TV_INFO_V1_2 *)(mode_info->atom_context->bios + data_offset);
-		if (index > MAX_SUPPORTED_TV_TIMING_V1_2)
+		if (index >= MAX_SUPPORTED_TV_TIMING_V1_2)
 			return false;
 
 		dtd_timings = &tv_info_v1_2->aModeTimings[index];","{'deleted_lines': ['\t\tif (index > MAX_SUPPORTED_TV_TIMING)', '\t\tif (index > MAX_SUPPORTED_TV_TIMING_V1_2)'], 'added_lines': ['\t\tif (index >= MAX_SUPPORTED_TV_TIMING)', '\t\tif (index >= MAX_SUPPORTED_TV_TIMING_V1_2)']}",True,"In the Linux kernel before 2.6.34, a range check issue in drivers/gpu/drm/radeon/atombios.c could cause an off by one (buffer overflow) problem. NOTE: At least one Linux maintainer believes that this CVE is incorrectly assigned and should be rejected because the value is hard coded and are not user-controllable where it is used",7.8,HIGH,2,test,2010-04-27T21:11:04Z,1
CVE-2012-6712,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"iwlwifi: Sanity check for sta_id

On my testing, I saw some strange behavior

[  421.739708] iwlwifi 0000:01:00.0: ACTIVATE a non DRIVER active station id 148 addr 00:00:00:00:00:00
[  421.739719] iwlwifi 0000:01:00.0: iwl_sta_ucode_activate Added STA id 148 addr 00:00:00:00:00:00 to uCode

not sure how it happen, but adding the sanity check to prevent memory
corruption

Signed-off-by: Wey-Yi Guy <wey-yi.w.guy@intel.com>
Signed-off-by: John W. Linville <linville@tuxdriver.com>",2da424b0773cea3db47e1e81db71eeebde8269d4,https://github.com/torvalds/linux/commit/2da424b0773cea3db47e1e81db71eeebde8269d4,drivers/net/wireless/iwlwifi/iwl-agn-sta.c,iwl_sta_ucode_activate,"static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)
{
if (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))
IWL_ERR(priv, ""ACTIVATE a non DRIVER active station id %u ""
""addr %pM\n"",
sta_id, priv->stations[sta_id].sta.sta.addr);
if (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {
IWL_DEBUG_ASSOC(priv,
""STA id %u addr %pM already present in uCode ""
""(according to driver)\n"",
sta_id, priv->stations[sta_id].sta.sta.addr);
} else {
priv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;
IWL_DEBUG_ASSOC(priv, ""Added STA id %u addr %pM to uCode\n"",
sta_id, priv->stations[sta_id].sta.sta.addr);
}
}","static void iwl_sta_ucode_activate(struct iwl_priv *VAR_0, u8 VAR_1)
{
if (!(VAR_0->stations[VAR_1].used & VAR_2))
IWL_ERR(VAR_0, ""ACTIVATE a non DRIVER active station id %u ""
""addr %pM\n"",
VAR_1, VAR_0->stations[VAR_1].sta.sta.addr);
if (VAR_0->stations[VAR_1].used & VAR_3) {
IWL_DEBUG_ASSOC(VAR_0,
""STA id %u addr %pM already present in uCode ""
""(according to driver)\n"",
VAR_1, VAR_0->stations[VAR_1].sta.sta.addr);
} else {
VAR_0->stations[VAR_1].used |= VAR_3;
IWL_DEBUG_ASSOC(VAR_0, ""Added STA id %u addr %pM to uCode\n"",
VAR_1, VAR_0->stations[VAR_1].sta.sta.addr);
}
}",torvalds/linux/2da424b0773cea3db47e1e81db71eeebde8269d4/iwl-agn-sta.c/vul/before/1.json,"static int iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)
{
	if (sta_id >= IWLAGN_STATION_COUNT) {
		IWL_ERR(priv, ""invalid sta_id %u"", sta_id);
		return -EINVAL;
	}
	if (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))
		IWL_ERR(priv, ""ACTIVATE a non DRIVER active station id %u ""
			""addr %pM\n"",
			sta_id, priv->stations[sta_id].sta.sta.addr);

	if (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {
		IWL_DEBUG_ASSOC(priv,
				""STA id %u addr %pM already present in uCode ""
				""(according to driver)\n"",
				sta_id, priv->stations[sta_id].sta.sta.addr);
	} else {
		priv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;
		IWL_DEBUG_ASSOC(priv, ""Added STA id %u addr %pM to uCode\n"",
				sta_id, priv->stations[sta_id].sta.sta.addr);
	}
	return 0;
}","static int iwl_sta_ucode_activate(struct iwl_priv *VAR_0, u8 VAR_1)
{
	if (VAR_1 >= VAR_2) {
		IWL_ERR(VAR_0, ""invalid sta_id %u"", VAR_1);
		return -VAR_3;
	}
	if (!(VAR_0->stations[VAR_1].used & VAR_4))
		IWL_ERR(VAR_0, ""ACTIVATE a non DRIVER active station id %u ""
			""addr %pM\n"",
			VAR_1, VAR_0->stations[VAR_1].sta.sta.addr);

	if (VAR_0->stations[VAR_1].used & VAR_5) {
		IWL_DEBUG_ASSOC(VAR_0,
				""STA id %u addr %pM already present in uCode ""
				""(according to driver)\n"",
				VAR_1, VAR_0->stations[VAR_1].sta.sta.addr);
	} else {
		VAR_0->stations[VAR_1].used |= VAR_5;
		IWL_DEBUG_ASSOC(VAR_0, ""Added STA id %u addr %pM to uCode\n"",
				VAR_1, VAR_0->stations[VAR_1].sta.sta.addr);
	}
	return 0;
}",torvalds/linux/2da424b0773cea3db47e1e81db71eeebde8269d4/iwl-agn-sta.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,6 +1,9 @@
-static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)
+static int iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)
 {
-
+	if (sta_id >= IWLAGN_STATION_COUNT) {
+		IWL_ERR(priv, ""invalid sta_id %u"", sta_id);
+		return -EINVAL;
+	}
 	if (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))
 		IWL_ERR(priv, ""ACTIVATE a non DRIVER active station id %u ""
 			""addr %pM\n"",
@@ -16,4 +19,5 @@
 		IWL_DEBUG_ASSOC(priv, ""Added STA id %u addr %pM to uCode\n"",
 				sta_id, priv->stations[sta_id].sta.sta.addr);
 	}
+	return 0;
 }","{'deleted_lines': ['static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)', ''], 'added_lines': ['static int iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)', '\tif (sta_id >= IWLAGN_STATION_COUNT) {', '\t\tIWL_ERR(priv, ""invalid sta_id %u"", sta_id);', '\t\treturn -EINVAL;', '\t}', '\treturn 0;']}",True,"In the Linux kernel before 3.4, a buffer overflow occurs in drivers/net/wireless/iwlwifi/iwl-agn-sta.c, which will cause at least memory corruption.",9.8,CRITICAL,3,test,2012-01-06T21:16:28Z,1
CVE-2012-6712,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"iwlwifi: Sanity check for sta_id

On my testing, I saw some strange behavior

[  421.739708] iwlwifi 0000:01:00.0: ACTIVATE a non DRIVER active station id 148 addr 00:00:00:00:00:00
[  421.739719] iwlwifi 0000:01:00.0: iwl_sta_ucode_activate Added STA id 148 addr 00:00:00:00:00:00 to uCode

not sure how it happen, but adding the sanity check to prevent memory
corruption

Signed-off-by: Wey-Yi Guy <wey-yi.w.guy@intel.com>
Signed-off-by: John W. Linville <linville@tuxdriver.com>",2da424b0773cea3db47e1e81db71eeebde8269d4,https://github.com/torvalds/linux/commit/2da424b0773cea3db47e1e81db71eeebde8269d4,drivers/net/wireless/iwlwifi/iwl-agn-sta.c,iwl_process_add_sta_resp,"static int iwl_process_add_sta_resp(struct iwl_priv *priv,
struct iwl_addsta_cmd *addsta,
struct iwl_rx_packet *pkt)
{
u8 sta_id = addsta->sta.sta_id;
unsigned long flags;
int ret = -EIO;
if (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {
IWL_ERR(priv, ""Bad return from REPLY_ADD_STA (0x%08X)\n"",
pkt->hdr.flags);
return ret;
}
IWL_DEBUG_INFO(priv, ""Processing response for adding station %u\n"",
sta_id);
spin_lock_irqsave(&priv->shrd->sta_lock, flags);
switch (pkt->u.add_sta.status) {
case ADD_STA_SUCCESS_MSK:
IWL_DEBUG_INFO(priv, ""REPLY_ADD_STA PASSED\n"");
iwl_sta_ucode_activate(priv, sta_id);
ret = 0;
break;
case ADD_STA_NO_ROOM_IN_TABLE:
IWL_ERR(priv, ""Adding station %d failed, no room in table.\n"",
sta_id);
break;
case ADD_STA_NO_BLOCK_ACK_RESOURCE:
IWL_ERR(priv, ""Adding station %d failed, no block ack ""
""resource.\n"", sta_id);
break;
case ADD_STA_MODIFY_NON_EXIST_STA:
IWL_ERR(priv, ""Attempting to modify non-existing station %d\n"",
sta_id);
break;
default:
IWL_DEBUG_ASSOC(priv, ""Received REPLY_ADD_STA:(0x%08X)\n"",
pkt->u.add_sta.status);
break;
}
IWL_DEBUG_INFO(priv, ""%s station id %u addr %pM\n"",
priv->stations[sta_id].sta.mode ==
STA_CONTROL_MODIFY_MSK ?  ""Modified"" : ""Added"",
sta_id, priv->stations[sta_id].sta.sta.addr);
IWL_DEBUG_INFO(priv, ""%s station according to cmd buffer %pM\n"",
priv->stations[sta_id].sta.mode ==
STA_CONTROL_MODIFY_MSK ? ""Modified"" : ""Added"",
addsta->sta.addr);
spin_unlock_irqrestore(&priv->shrd->sta_lock, flags);
return ret;
}","static int iwl_process_add_sta_resp(struct iwl_priv *VAR_0,
struct iwl_addsta_cmd *VAR_1,
struct iwl_rx_packet *VAR_2)
{
u8 VAR_3 = VAR_1->sta.sta_id;
unsigned long VAR_4;
int VAR_5 = -VAR_6;
if (VAR_2->hdr.flags & VAR_7) {
IWL_ERR(VAR_0, ""Bad return from REPLY_ADD_STA (0x%08X)\n"",
VAR_2->hdr.flags);
return VAR_5;
}
IWL_DEBUG_INFO(VAR_0, ""Processing response for adding station %u\n"",
VAR_3);
spin_lock_irqsave(&VAR_0->shrd->sta_lock, VAR_4);
switch (VAR_2->u.add_sta.status) {
case VAR_8:
IWL_DEBUG_INFO(VAR_0, ""REPLY_ADD_STA PASSED\n"");
iwl_sta_ucode_activate(VAR_0, VAR_3);
VAR_5 = 0;
break;
case VAR_9:
IWL_ERR(VAR_0, ""Adding station %d failed, no room in table.\n"",
VAR_3);
break;
case VAR_10:
IWL_ERR(VAR_0, ""Adding station %d failed, no block ack ""
""resource.\n"", VAR_3);
break;
case VAR_11:
IWL_ERR(VAR_0, ""Attempting to modify non-existing station %d\n"",
VAR_3);
break;
default:
IWL_DEBUG_ASSOC(VAR_0, ""Received REPLY_ADD_STA:(0x%08X)\n"",
VAR_2->u.add_sta.status);
break;
}
IWL_DEBUG_INFO(VAR_0, ""%s station id %u addr %pM\n"",
VAR_0->stations[VAR_3].sta.mode ==
VAR_12 ?  ""Modified"" : ""Added"",
VAR_3, VAR_0->stations[VAR_3].sta.sta.addr);
IWL_DEBUG_INFO(VAR_0, ""%s station according to cmd buffer %pM\n"",
VAR_0->stations[VAR_3].sta.mode ==
VAR_12 ? ""Modified"" : ""Added"",
VAR_1->sta.addr);
spin_unlock_irqrestore(&VAR_0->shrd->sta_lock, VAR_4);
return VAR_5;
}",torvalds/linux/2da424b0773cea3db47e1e81db71eeebde8269d4/iwl-agn-sta.c/vul/before/0.json,"static int iwl_process_add_sta_resp(struct iwl_priv *priv,
				    struct iwl_addsta_cmd *addsta,
				    struct iwl_rx_packet *pkt)
{
	u8 sta_id = addsta->sta.sta_id;
	unsigned long flags;
	int ret = -EIO;

	if (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {
		IWL_ERR(priv, ""Bad return from REPLY_ADD_STA (0x%08X)\n"",
			pkt->hdr.flags);
		return ret;
	}

	IWL_DEBUG_INFO(priv, ""Processing response for adding station %u\n"",
		       sta_id);

	spin_lock_irqsave(&priv->shrd->sta_lock, flags);

	switch (pkt->u.add_sta.status) {
	case ADD_STA_SUCCESS_MSK:
		IWL_DEBUG_INFO(priv, ""REPLY_ADD_STA PASSED\n"");
		ret = iwl_sta_ucode_activate(priv, sta_id);
		break;
	case ADD_STA_NO_ROOM_IN_TABLE:
		IWL_ERR(priv, ""Adding station %d failed, no room in table.\n"",
			sta_id);
		break;
	case ADD_STA_NO_BLOCK_ACK_RESOURCE:
		IWL_ERR(priv, ""Adding station %d failed, no block ack ""
			""resource.\n"", sta_id);
		break;
	case ADD_STA_MODIFY_NON_EXIST_STA:
		IWL_ERR(priv, ""Attempting to modify non-existing station %d\n"",
			sta_id);
		break;
	default:
		IWL_DEBUG_ASSOC(priv, ""Received REPLY_ADD_STA:(0x%08X)\n"",
				pkt->u.add_sta.status);
		break;
	}

	IWL_DEBUG_INFO(priv, ""%s station id %u addr %pM\n"",
		       priv->stations[sta_id].sta.mode ==
		       STA_CONTROL_MODIFY_MSK ?  ""Modified"" : ""Added"",
		       sta_id, priv->stations[sta_id].sta.sta.addr);

	/*
	 * XXX: The MAC address in the command buffer is often changed from
	 * the original sent to the device. That is, the MAC address
	 * written to the command buffer often is not the same MAC address
	 * read from the command buffer when the command returns. This
	 * issue has not yet been resolved and this debugging is left to
	 * observe the problem.
	 */
	IWL_DEBUG_INFO(priv, ""%s station according to cmd buffer %pM\n"",
		       priv->stations[sta_id].sta.mode ==
		       STA_CONTROL_MODIFY_MSK ? ""Modified"" : ""Added"",
		       addsta->sta.addr);
	spin_unlock_irqrestore(&priv->shrd->sta_lock, flags);

	return ret;
}","static int iwl_process_add_sta_resp(struct iwl_priv *VAR_0,
				    struct iwl_addsta_cmd *VAR_1,
				    struct iwl_rx_packet *VAR_2)
{
	u8 VAR_3 = VAR_1->sta.sta_id;
	unsigned long VAR_4;
	int VAR_5 = -VAR_6;

	if (VAR_2->hdr.flags & VAR_7) {
		IWL_ERR(VAR_0, ""Bad return from REPLY_ADD_STA (0x%08X)\n"",
			VAR_2->hdr.flags);
		return VAR_5;
	}

	IWL_DEBUG_INFO(VAR_0, ""Processing response for adding station %u\n"",
		       VAR_3);

	spin_lock_irqsave(&VAR_0->shrd->sta_lock, VAR_4);

	switch (VAR_2->u.add_sta.status) {
	case VAR_8:
		IWL_DEBUG_INFO(VAR_0, ""REPLY_ADD_STA PASSED\n"");
		VAR_5 = iwl_sta_ucode_activate(VAR_0, VAR_3);
		break;
	case VAR_9:
		IWL_ERR(VAR_0, ""Adding station %d failed, no room in table.\n"",
			VAR_3);
		break;
	case VAR_10:
		IWL_ERR(VAR_0, ""Adding station %d failed, no block ack ""
			""resource.\n"", VAR_3);
		break;
	case VAR_11:
		IWL_ERR(VAR_0, ""Attempting to modify non-existing station %d\n"",
			VAR_3);
		break;
	default:
		IWL_DEBUG_ASSOC(VAR_0, ""Received REPLY_ADD_STA:(0x%08X)\n"",
				VAR_2->u.add_sta.status);
		break;
	}

	IWL_DEBUG_INFO(VAR_0, ""%s station id %u addr %pM\n"",
		       VAR_0->stations[VAR_3].sta.mode ==
		       VAR_12 ?  ""Modified"" : ""Added"",
		       VAR_3, VAR_0->stations[VAR_3].sta.sta.addr);

	/* COMMENT_0 */
                                                                    
                                                             
                                                                   
                                                               
                                                                 
                        
    
	IWL_DEBUG_INFO(VAR_0, ""%s station according to cmd buffer %pM\n"",
		       VAR_0->stations[VAR_3].sta.mode ==
		       VAR_12 ? ""Modified"" : ""Added"",
		       VAR_1->sta.addr);
	spin_unlock_irqrestore(&VAR_0->shrd->sta_lock, VAR_4);

	return VAR_5;
}",torvalds/linux/2da424b0773cea3db47e1e81db71eeebde8269d4/iwl-agn-sta.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -20,8 +20,7 @@
 	switch (pkt->u.add_sta.status) {
 	case ADD_STA_SUCCESS_MSK:
 		IWL_DEBUG_INFO(priv, ""REPLY_ADD_STA PASSED\n"");
-		iwl_sta_ucode_activate(priv, sta_id);
-		ret = 0;
+		ret = iwl_sta_ucode_activate(priv, sta_id);
 		break;
 	case ADD_STA_NO_ROOM_IN_TABLE:
 		IWL_ERR(priv, ""Adding station %d failed, no room in table.\n"",","{'deleted_lines': ['\t\tiwl_sta_ucode_activate(priv, sta_id);', '\t\tret = 0;'], 'added_lines': ['\t\tret = iwl_sta_ucode_activate(priv, sta_id);']}",True,"In the Linux kernel before 3.4, a buffer overflow occurs in drivers/net/wireless/iwlwifi/iwl-agn-sta.c, which will cause at least memory corruption.",9.8,CRITICAL,3,test,2012-01-06T21:16:28Z,1
CVE-2012-6696,['CWE-20'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,inspircd,Fixed out of bounds memory access from malformed DNS queries that have an invalid length label. Introduced in a6a07de0daa353bcd29056a4535a9c4784c113c8.,ed28c1ba666b39581adb860bf51cdde43c84cc89,https://github.com/inspircd/inspircd/commit/ed28c1ba666b39581adb860bf51cdde43c84cc89,src/dns.cpp,DNSRequest::ResultIsReady,"DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, unsigned length)
{
unsigned i = 0, o;
int q = 0;
int curanswer;
ResourceRecord rr;
unsigned short ptr;
rr.type = DNS_QUERY_NONE;
rr.rdlength = 0;
rr.ttl = 1;
rr.rr_class = 0; 
if (!(header.flags1 & FLAGS_MASK_QR))
return std::make_pair((unsigned char*)NULL,""Not a query result"");
if (header.flags1 & FLAGS_MASK_OPCODE)
return std::make_pair((unsigned char*)NULL,""Unexpected value in DNS reply packet"");
if (header.flags2 & FLAGS_MASK_RCODE)
return std::make_pair((unsigned char*)NULL,""Domain name not found"");
if (header.ancount < 1)
return std::make_pair((unsigned char*)NULL,""No resource records returned"");
length -= 12;
while ((unsigned int)q < header.qdcount && i < length)
{
if (header.payload[i] > 63)
{
i += 6;
q++;
}
else
{
if (header.payload[i] == 0)
{
q++;
i += 5;
}
else i += header.payload[i] + 1;
}
}
curanswer = 0;
while ((unsigned)curanswer < header.ancount)
{
q = 0;
while (q == 0 && i < length)
{
if (header.payload[i] > 63)
{
i += 2;
q = 1;
}
else
{
if (header.payload[i] == 0)
{
i++;
q = 1;
}
else i += header.payload[i] + 1; 
}
}
if (length - i < 10)
return std::make_pair((unsigned char*)NULL,""Incorrectly sized DNS reply"");
DNS::FillResourceRecord(&rr,&header.payload[i]);
i += 10;
ServerInstance->Logs->Log(""RESOLVER"",DEBUG,""Resolver: rr.type is %d and this.type is %d rr.class %d this.class %d"", rr.type, this->type, rr.rr_class, this->rr_class);
if (rr.type != this->type)
{
curanswer++;
i += rr.rdlength;
continue;
}
if (rr.rr_class != this->rr_class)
{
curanswer++;
i += rr.rdlength;
continue;
}
break;
}
if ((unsigned int)curanswer == header.ancount)
return std::make_pair((unsigned char*)NULL,""No A, AAAA or PTR type answers ("" + ConvToStr(header.ancount) + "" answers)"");
if (i + rr.rdlength > (unsigned int)length)
return std::make_pair((unsigned char*)NULL,""Resource record larger than stated"");
if (rr.rdlength > 1023)
return std::make_pair((unsigned char*)NULL,""Resource record too large"");
this->ttl = rr.ttl;
switch (rr.type)
{
case DNS_QUERY_CNAME:
case DNS_QUERY_PTR:
o = 0;
q = 0;
while (q == 0 && i < length && o + 256 < 1023)
{
if (header.payload[i] > 63)
{
memcpy(&ptr,&header.payload[i],2);
i = ntohs(ptr);
if (!(i & DN_COMP_BITMASK))
return std::make_pair((unsigned char *) NULL, ""DN label decompression header is bogus"");
i &= ~DN_COMP_BITMASK;
i =- 12;
}
else
{
if (header.payload[i] == 0)
{
q = 1;
}
else
{
res[o] = 0;
if (o != 0)
res[o++] = '.';
if (o + header.payload[i] > sizeof(DNSHeader))
return std::make_pair((unsigned char *) NULL, ""DN label decompression is impossible -- malformed/hostile packet?"");
memcpy(&res[o], &header.payload[i + 1], header.payload[i]);
o += header.payload[i];
i += header.payload[i] + 1;
}
}
}
res[o] = 0;
break;
case DNS_QUERY_AAAA:
if (rr.rdlength != sizeof(struct in6_addr))
return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 16 bytes for an ipv6 entry -- malformed/hostile packet?"");
memcpy(res,&header.payload[i],rr.rdlength);
res[rr.rdlength] = 0;
break;
case DNS_QUERY_A:
if (rr.rdlength != sizeof(struct in_addr))
return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 4 bytes for an ipv4 entry -- malformed/hostile packet?"");
memcpy(res,&header.payload[i],rr.rdlength);
res[rr.rdlength] = 0;
break;
default:
return std::make_pair((unsigned char *) NULL, ""don't know how to handle undefined type ("" + ConvToStr(rr.type) + "") -- rejecting"");
break;
}
return std::make_pair(res,""No error"");
}","DNSInfo DNSRequest::ResultIsReady(DNSHeader &VAR_0, unsigned VAR_1)
{
unsigned VAR_2 = 0, VAR_3;
int VAR_4 = 0;
int VAR_5;
ResourceRecord VAR_6;
unsigned short VAR_7;
VAR_6.type = VAR_8;
VAR_6.rdlength = 0;
VAR_6.ttl = 1;
VAR_6.rr_class = 0; 
if (!(VAR_0.flags1 & VAR_9))
return std::make_pair((unsigned char*)NULL,""Not a query result"");
if (VAR_0.flags1 & VAR_10)
return std::make_pair((unsigned char*)NULL,""Unexpected value in DNS reply packet"");
if (VAR_0.flags2 & VAR_11)
return std::make_pair((unsigned char*)NULL,""Domain name not found"");
if (VAR_0.ancount < 1)
return std::make_pair((unsigned char*)NULL,""No resource records returned"");
VAR_1 -= 12;
while ((unsigned int)VAR_4 < VAR_0.qdcount && VAR_2 < VAR_1)
{
if (VAR_0.payload[VAR_2] > 63)
{
VAR_2 += 6;
VAR_4++;
}
else
{
if (VAR_0.payload[VAR_2] == 0)
{
VAR_4++;
VAR_2 += 5;
}
else VAR_2 += VAR_0.payload[VAR_2] + 1;
}
}
VAR_5 = 0;
while ((unsigned)VAR_5 < VAR_0.ancount)
{
VAR_4 = 0;
while (VAR_4 == 0 && VAR_2 < VAR_1)
{
if (VAR_0.payload[VAR_2] > 63)
{
VAR_2 += 2;
VAR_4 = 1;
}
else
{
if (VAR_0.payload[VAR_2] == 0)
{
VAR_2++;
VAR_4 = 1;
}
else VAR_2 += VAR_0.payload[VAR_2] + 1; 
}
}
if (VAR_1 - VAR_2 < 10)
return std::make_pair((unsigned char*)NULL,""Incorrectly sized DNS reply"");
DNS::FillResourceRecord(&VAR_6,&VAR_0.payload[VAR_2]);
VAR_2 += 10;
VAR_12->Logs->Log(""RESOLVER"",VAR_13,""Resolver: rr.type is %d and this.type is %d rr.class %d this.class %d"", VAR_6.type, this->type, VAR_6.rr_class, this->rr_class);
if (VAR_6.type != this->type)
{
VAR_5++;
VAR_2 += VAR_6.rdlength;
continue;
}
if (VAR_6.rr_class != this->rr_class)
{
VAR_5++;
VAR_2 += VAR_6.rdlength;
continue;
}
break;
}
if ((unsigned int)VAR_5 == VAR_0.ancount)
return std::make_pair((unsigned char*)NULL,""No A, AAAA or PTR type answers ("" + ConvToStr(VAR_0.ancount) + "" answers)"");
if (VAR_2 + VAR_6.rdlength > (unsigned int)VAR_1)
return std::make_pair((unsigned char*)NULL,""Resource record larger than stated"");
if (VAR_6.rdlength > 1023)
return std::make_pair((unsigned char*)NULL,""Resource record too large"");
this->ttl = VAR_6.ttl;
switch (VAR_6.type)
{
case VAR_14:
case VAR_15:
VAR_3 = 0;
VAR_4 = 0;
while (VAR_4 == 0 && VAR_2 < VAR_1 && VAR_3 + 256 < 1023)
{
if (VAR_0.payload[VAR_2] > 63)
{
memcpy(&VAR_7,&VAR_0.payload[VAR_2],2);
VAR_2 = ntohs(VAR_7);
if (!(VAR_2 & VAR_16))
return std::make_pair((unsigned char *) NULL, ""DN label decompression header is bogus"");
VAR_2 &= ~VAR_16;
VAR_2 =- 12;
}
else
{
if (VAR_0.payload[VAR_2] == 0)
{
VAR_4 = 1;
}
else
{
VAR_17[VAR_3] = 0;
if (VAR_3 != 0)
VAR_17[VAR_3++] = '.';
if (VAR_3 + VAR_0.payload[VAR_2] > sizeof(DNSHeader))
return std::make_pair((unsigned char *) NULL, ""DN label decompression is impossible -- malformed/hostile packet?"");
memcpy(&VAR_17[VAR_3], &VAR_0.payload[VAR_2 + 1], VAR_0.payload[VAR_2]);
VAR_3 += VAR_0.payload[VAR_2];
VAR_2 += VAR_0.payload[VAR_2] + 1;
}
}
}
VAR_17[VAR_3] = 0;
break;
case VAR_18:
if (VAR_6.rdlength != sizeof(struct in6_addr))
return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 16 bytes for an ipv6 entry -- malformed/hostile packet?"");
memcpy(VAR_17,&VAR_0.payload[VAR_2],VAR_6.rdlength);
VAR_17[VAR_6.rdlength] = 0;
break;
case VAR_19:
if (VAR_6.rdlength != sizeof(struct in_addr))
return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 4 bytes for an ipv4 entry -- malformed/hostile packet?"");
memcpy(VAR_17,&VAR_0.payload[VAR_2],VAR_6.rdlength);
VAR_17[VAR_6.rdlength] = 0;
break;
default:
return std::make_pair((unsigned char *) NULL, ""don't know how to handle undefined type ("" + ConvToStr(VAR_6.type) + "") -- rejecting"");
break;
}
return std::make_pair(VAR_17,""No error"");
}",inspircd/ed28c1ba666b39581adb860bf51cdde43c84cc89/dns.cpp/vul/before/0.json,"DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, unsigned length)
{
	unsigned i = 0, o;
	int q = 0;
	int curanswer;
	ResourceRecord rr;
 	unsigned short ptr;

	/* This is just to keep _FORTIFY_SOURCE happy */
	rr.type = DNS_QUERY_NONE;
	rr.rdlength = 0;
	rr.ttl = 1;	/* GCC is a whiney bastard -- see the XXX below. */
	rr.rr_class = 0; /* Same for VC++ */

	if (!(header.flags1 & FLAGS_MASK_QR))
		return std::make_pair((unsigned char*)NULL,""Not a query result"");

	if (header.flags1 & FLAGS_MASK_OPCODE)
		return std::make_pair((unsigned char*)NULL,""Unexpected value in DNS reply packet"");

	if (header.flags2 & FLAGS_MASK_RCODE)
		return std::make_pair((unsigned char*)NULL,""Domain name not found"");

	if (header.ancount < 1)
		return std::make_pair((unsigned char*)NULL,""No resource records returned"");

	/* Subtract the length of the header from the length of the packet */
	length -= 12;

	while ((unsigned int)q < header.qdcount && i < length)
	{
		if (header.payload[i] > 63)
		{
			i += 6;
			q++;
		}
		else
		{
			if (header.payload[i] == 0)
			{
				q++;
				i += 5;
			}
			else i += header.payload[i] + 1;
		}
	}
	curanswer = 0;
	while ((unsigned)curanswer < header.ancount)
	{
		q = 0;
		while (q == 0 && i < length)
		{
			if (header.payload[i] > 63)
			{
				i += 2;
				q = 1;
			}
			else
			{
				if (header.payload[i] == 0)
				{
					i++;
					q = 1;
				}
				else i += header.payload[i] + 1; /* skip length and label */
			}
		}
		if (static_cast<int>(length - i) < 10)
			return std::make_pair((unsigned char*)NULL,""Incorrectly sized DNS reply"");

		/* XXX: We actually initialise 'rr' here including its ttl field */
		DNS::FillResourceRecord(&rr,&header.payload[i]);

		i += 10;
		ServerInstance->Logs->Log(""RESOLVER"",DEBUG,""Resolver: rr.type is %d and this.type is %d rr.class %d this.class %d"", rr.type, this->type, rr.rr_class, this->rr_class);
		if (rr.type != this->type)
		{
			curanswer++;
			i += rr.rdlength;
			continue;
		}
		if (rr.rr_class != this->rr_class)
		{
			curanswer++;
			i += rr.rdlength;
			continue;
		}
		break;
	}
	if ((unsigned int)curanswer == header.ancount)
		return std::make_pair((unsigned char*)NULL,""No A, AAAA or PTR type answers ("" + ConvToStr(header.ancount) + "" answers)"");

	if (i + rr.rdlength > (unsigned int)length)
		return std::make_pair((unsigned char*)NULL,""Resource record larger than stated"");

	if (rr.rdlength > 1023)
		return std::make_pair((unsigned char*)NULL,""Resource record too large"");

	this->ttl = rr.ttl;

	switch (rr.type)
	{
		/*
		 * CNAME and PTR are compressed.  We need to decompress them.
		 */
		case DNS_QUERY_CNAME:
		case DNS_QUERY_PTR:
			o = 0;
			q = 0;
			while (q == 0 && i < length && o + 256 < 1023)
			{
				/* DN label found (byte over 63) */
				if (header.payload[i] > 63)
				{
					memcpy(&ptr,&header.payload[i],2);

					i = ntohs(ptr);

					/* check that highest two bits are set. if not, we've been had */
					if (!(i & DN_COMP_BITMASK))
						return std::make_pair((unsigned char *) NULL, ""DN label decompression header is bogus"");

					/* mask away the two highest bits. */
					i &= ~DN_COMP_BITMASK;

					/* and decrease length by 12 bytes. */
					i =- 12;
				}
				else
				{
					if (header.payload[i] == 0)
					{
						q = 1;
					}
					else
					{
						res[o] = 0;
						if (o != 0)
							res[o++] = '.';

						if (o + header.payload[i] > sizeof(DNSHeader))
							return std::make_pair((unsigned char *) NULL, ""DN label decompression is impossible -- malformed/hostile packet?"");

						memcpy(&res[o], &header.payload[i + 1], header.payload[i]);
						o += header.payload[i];
						i += header.payload[i] + 1;
					}
				}
			}
			res[o] = 0;
		break;
		case DNS_QUERY_AAAA:
			if (rr.rdlength != sizeof(struct in6_addr))
				return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 16 bytes for an ipv6 entry -- malformed/hostile packet?"");

			memcpy(res,&header.payload[i],rr.rdlength);
			res[rr.rdlength] = 0;
		break;
		case DNS_QUERY_A:
			if (rr.rdlength != sizeof(struct in_addr))
				return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 4 bytes for an ipv4 entry -- malformed/hostile packet?"");

			memcpy(res,&header.payload[i],rr.rdlength);
			res[rr.rdlength] = 0;
		break;
		default:
			return std::make_pair((unsigned char *) NULL, ""don't know how to handle undefined type ("" + ConvToStr(rr.type) + "") -- rejecting"");
		break;
	}
	return std::make_pair(res,""No error"");
}","DNSInfo DNSRequest::ResultIsReady(DNSHeader &VAR_0, unsigned VAR_1)
{
	unsigned VAR_2 = 0, VAR_3;
	int VAR_4 = 0;
	int VAR_5;
	ResourceRecord VAR_6;
 	unsigned short VAR_7;

	/* COMMENT_0 */
	VAR_6.type = VAR_8;
	VAR_6.rdlength = 0;
	VAR_6.ttl = 1;	/* COMMENT_1 */
	VAR_6.rr_class = 0; /* COMMENT_2 */

	if (!(VAR_0.flags1 & VAR_9))
		return std::make_pair((unsigned char*)NULL,""Not a query result"");

	if (VAR_0.flags1 & VAR_10)
		return std::make_pair((unsigned char*)NULL,""Unexpected value in DNS reply packet"");

	if (VAR_0.flags2 & VAR_11)
		return std::make_pair((unsigned char*)NULL,""Domain name not found"");

	if (VAR_0.ancount < 1)
		return std::make_pair((unsigned char*)NULL,""No resource records returned"");

	/* COMMENT_3 */
	VAR_1 -= 12;

	while ((unsigned int)VAR_4 < VAR_0.qdcount && VAR_2 < VAR_1)
	{
		if (VAR_0.payload[VAR_2] > 63)
		{
			VAR_2 += 6;
			VAR_4++;
		}
		else
		{
			if (VAR_0.payload[VAR_2] == 0)
			{
				VAR_4++;
				VAR_2 += 5;
			}
			else VAR_2 += VAR_0.payload[VAR_2] + 1;
		}
	}
	VAR_5 = 0;
	while ((unsigned)VAR_5 < VAR_0.ancount)
	{
		VAR_4 = 0;
		while (VAR_4 == 0 && VAR_2 < VAR_1)
		{
			if (VAR_0.payload[VAR_2] > 63)
			{
				VAR_2 += 2;
				VAR_4 = 1;
			}
			else
			{
				if (VAR_0.payload[VAR_2] == 0)
				{
					VAR_2++;
					VAR_4 = 1;
				}
				else VAR_2 += VAR_0.payload[VAR_2] + 1; /* COMMENT_4 */
			}
		}
		if (VAR_12<int>(VAR_1 - VAR_2) < 10)
			return std::make_pair((unsigned char*)NULL,""Incorrectly sized DNS reply"");

		/* COMMENT_5 */
		DNS::FillResourceRecord(&VAR_6,&VAR_0.payload[VAR_2]);

		VAR_2 += 10;
		VAR_13->Logs->Log(""RESOLVER"",VAR_14,""Resolver: rr.type is %d and this.type is %d rr.class %d this.class %d"", VAR_6.type, this->type, VAR_6.rr_class, this->rr_class);
		if (VAR_6.type != this->type)
		{
			VAR_5++;
			VAR_2 += VAR_6.rdlength;
			continue;
		}
		if (VAR_6.rr_class != this->rr_class)
		{
			VAR_5++;
			VAR_2 += VAR_6.rdlength;
			continue;
		}
		break;
	}
	if ((unsigned int)VAR_5 == VAR_0.ancount)
		return std::make_pair((unsigned char*)NULL,""No A, AAAA or PTR type answers ("" + ConvToStr(VAR_0.ancount) + "" answers)"");

	if (VAR_2 + VAR_6.rdlength > (unsigned int)VAR_1)
		return std::make_pair((unsigned char*)NULL,""Resource record larger than stated"");

	if (VAR_6.rdlength > 1023)
		return std::make_pair((unsigned char*)NULL,""Resource record too large"");

	this->ttl = VAR_6.ttl;

	switch (VAR_6.type)
	{
		/* COMMENT_6 */
                                                               
     
		case VAR_15:
		case VAR_16:
			VAR_3 = 0;
			VAR_4 = 0;
			while (VAR_4 == 0 && VAR_2 < VAR_1 && VAR_3 + 256 < 1023)
			{
				/* COMMENT_9 */
				if (VAR_0.payload[VAR_2] > 63)
				{
					memcpy(&VAR_7,&VAR_0.payload[VAR_2],2);

					VAR_2 = ntohs(VAR_7);

					/* COMMENT_10 */
					if (!(VAR_2 & VAR_17))
						return std::make_pair((unsigned char *) NULL, ""DN label decompression header is bogus"");

					/* COMMENT_11 */
					VAR_2 &= ~VAR_17;

					/* COMMENT_12 */
					VAR_2 =- 12;
				}
				else
				{
					if (VAR_0.payload[VAR_2] == 0)
					{
						VAR_4 = 1;
					}
					else
					{
						VAR_18[VAR_3] = 0;
						if (VAR_3 != 0)
							VAR_18[VAR_3++] = '.';

						if (VAR_3 + VAR_0.payload[VAR_2] > sizeof(DNSHeader))
							return std::make_pair((unsigned char *) NULL, ""DN label decompression is impossible -- malformed/hostile packet?"");

						memcpy(&VAR_18[VAR_3], &VAR_0.payload[VAR_2 + 1], VAR_0.payload[VAR_2]);
						VAR_3 += VAR_0.payload[VAR_2];
						VAR_2 += VAR_0.payload[VAR_2] + 1;
					}
				}
			}
			VAR_18[VAR_3] = 0;
		break;
		case VAR_19:
			if (VAR_6.rdlength != sizeof(struct in6_addr))
				return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 16 bytes for an ipv6 entry -- malformed/hostile packet?"");

			memcpy(VAR_18,&VAR_0.payload[VAR_2],VAR_6.rdlength);
			VAR_18[VAR_6.rdlength] = 0;
		break;
		case VAR_20:
			if (VAR_6.rdlength != sizeof(struct in_addr))
				return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 4 bytes for an ipv4 entry -- malformed/hostile packet?"");

			memcpy(VAR_18,&VAR_0.payload[VAR_2],VAR_6.rdlength);
			VAR_18[VAR_6.rdlength] = 0;
		break;
		default:
			return std::make_pair((unsigned char *) NULL, ""don't know how to handle undefined type ("" + ConvToStr(VAR_6.type) + "") -- rejecting"");
		break;
	}
	return std::make_pair(VAR_18,""No error"");
}",inspircd/ed28c1ba666b39581adb860bf51cdde43c84cc89/dns.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -65,7 +65,7 @@
 				else i += header.payload[i] + 1; /* skip length and label */
 			}
 		}
-		if (length - i < 10)
+		if (static_cast<int>(length - i) < 10)
 			return std::make_pair((unsigned char*)NULL,""Incorrectly sized DNS reply"");
 
 		/* XXX: We actually initialise 'rr' here including its ttl field */","{'deleted_lines': ['\t\tif (length - i < 10)'], 'added_lines': ['\t\tif (static_cast<int>(length - i) < 10)']}",True,inspircd in Debian before 2.0.7 does not properly handle unsigned integers.  NOTE: This vulnerability exists because of an incomplete fix to CVE-2012-1836.,9.8,CRITICAL,3,test,2012-03-26T08:59:13Z,1
CVE-2012-6697,['CWE-399'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,inspircd,Fixed infinite loop cauesd by invalid dns packets,58c893e834ff20495d00770922,https://github.com/inspircd/inspircd/commit/58c893e834ff20495d007709220881a3ff13f423,src/dns.cpp,DNSRequest::ResultIsReady,"DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, unsigned length)
{
unsigned i = 0, o;
int q = 0;
int curanswer;
ResourceRecord rr;
unsigned short ptr;
rr.type = DNS_QUERY_NONE;
rr.rdlength = 0;
rr.ttl = 1;
rr.rr_class = 0; 
if (!(header.flags1 & FLAGS_MASK_QR))
return std::make_pair((unsigned char*)NULL,""Not a query result"");
if (header.flags1 & FLAGS_MASK_OPCODE)
return std::make_pair((unsigned char*)NULL,""Unexpected value in DNS reply packet"");
if (header.flags2 & FLAGS_MASK_RCODE)
return std::make_pair((unsigned char*)NULL,""Domain name not found"");
if (header.ancount < 1)
return std::make_pair((unsigned char*)NULL,""No resource records returned"");
length -= 12;
while ((unsigned int)q < header.qdcount && i < length)
{
if (header.payload[i] > 63)
{
i += 6;
q++;
}
else
{
if (header.payload[i] == 0)
{
q++;
i += 5;
}
else i += header.payload[i] + 1;
}
}
curanswer = 0;
while ((unsigned)curanswer < header.ancount)
{
q = 0;
while (q == 0 && i < length)
{
if (header.payload[i] > 63)
{
i += 2;
q = 1;
}
else
{
if (header.payload[i] == 0)
{
i++;
q = 1;
}
else i += header.payload[i] + 1; 
}
}
if (static_cast<int>(length - i) < 10)
return std::make_pair((unsigned char*)NULL,""Incorrectly sized DNS reply"");
DNS::FillResourceRecord(&rr,&header.payload[i]);
i += 10;
ServerInstance->Logs->Log(""RESOLVER"",DEBUG,""Resolver: rr.type is %d and this.type is %d rr.class %d this.class %d"", rr.type, this->type, rr.rr_class, this->rr_class);
if (rr.type != this->type)
{
curanswer++;
i += rr.rdlength;
continue;
}
if (rr.rr_class != this->rr_class)
{
curanswer++;
i += rr.rdlength;
continue;
}
break;
}
if ((unsigned int)curanswer == header.ancount)
return std::make_pair((unsigned char*)NULL,""No A, AAAA or PTR type answers ("" + ConvToStr(header.ancount) + "" answers)"");
if (i + rr.rdlength > (unsigned int)length)
return std::make_pair((unsigned char*)NULL,""Resource record larger than stated"");
if (rr.rdlength > 1023)
return std::make_pair((unsigned char*)NULL,""Resource record too large"");
this->ttl = rr.ttl;
switch (rr.type)
{
case DNS_QUERY_CNAME:
case DNS_QUERY_PTR:
o = 0;
q = 0;
while (q == 0 && i < length && o + 256 < 1023)
{
if (header.payload[i] > 63)
{
memcpy(&ptr,&header.payload[i],2);
i = ntohs(ptr);
if (!(i & DN_COMP_BITMASK))
return std::make_pair((unsigned char *) NULL, ""DN label decompression header is bogus"");
i &= ~DN_COMP_BITMASK;
i =- 12;
}
else
{
if (header.payload[i] == 0)
{
q = 1;
}
else
{
res[o] = 0;
if (o != 0)
res[o++] = '.';
if (o + header.payload[i] > sizeof(DNSHeader))
return std::make_pair((unsigned char *) NULL, ""DN label decompression is impossible -- malformed/hostile packet?"");
memcpy(&res[o], &header.payload[i + 1], header.payload[i]);
o += header.payload[i];
i += header.payload[i] + 1;
}
}
}
res[o] = 0;
break;
case DNS_QUERY_AAAA:
if (rr.rdlength != sizeof(struct in6_addr))
return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 16 bytes for an ipv6 entry -- malformed/hostile packet?"");
memcpy(res,&header.payload[i],rr.rdlength);
res[rr.rdlength] = 0;
break;
case DNS_QUERY_A:
if (rr.rdlength != sizeof(struct in_addr))
return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 4 bytes for an ipv4 entry -- malformed/hostile packet?"");
memcpy(res,&header.payload[i],rr.rdlength);
res[rr.rdlength] = 0;
break;
default:
return std::make_pair((unsigned char *) NULL, ""don't know how to handle undefined type ("" + ConvToStr(rr.type) + "") -- rejecting"");
break;
}
return std::make_pair(res,""No error"");
}","DNSInfo DNSRequest::ResultIsReady(DNSHeader &VAR_0, unsigned VAR_1)
{
unsigned VAR_2 = 0, VAR_3;
int VAR_4 = 0;
int VAR_5;
ResourceRecord VAR_6;
unsigned short VAR_7;
VAR_6.type = VAR_8;
VAR_6.rdlength = 0;
VAR_6.ttl = 1;
VAR_6.rr_class = 0; 
if (!(VAR_0.flags1 & VAR_9))
return std::make_pair((unsigned char*)NULL,""Not a query result"");
if (VAR_0.flags1 & VAR_10)
return std::make_pair((unsigned char*)NULL,""Unexpected value in DNS reply packet"");
if (VAR_0.flags2 & VAR_11)
return std::make_pair((unsigned char*)NULL,""Domain name not found"");
if (VAR_0.ancount < 1)
return std::make_pair((unsigned char*)NULL,""No resource records returned"");
VAR_1 -= 12;
while ((unsigned int)VAR_4 < VAR_0.qdcount && VAR_2 < VAR_1)
{
if (VAR_0.payload[VAR_2] > 63)
{
VAR_2 += 6;
VAR_4++;
}
else
{
if (VAR_0.payload[VAR_2] == 0)
{
VAR_4++;
VAR_2 += 5;
}
else VAR_2 += VAR_0.payload[VAR_2] + 1;
}
}
VAR_5 = 0;
while ((unsigned)VAR_5 < VAR_0.ancount)
{
VAR_4 = 0;
while (VAR_4 == 0 && VAR_2 < VAR_1)
{
if (VAR_0.payload[VAR_2] > 63)
{
VAR_2 += 2;
VAR_4 = 1;
}
else
{
if (VAR_0.payload[VAR_2] == 0)
{
VAR_2++;
VAR_4 = 1;
}
else VAR_2 += VAR_0.payload[VAR_2] + 1; 
}
}
if (VAR_12<int>(VAR_1 - VAR_2) < 10)
return std::make_pair((unsigned char*)NULL,""Incorrectly sized DNS reply"");
DNS::FillResourceRecord(&VAR_6,&VAR_0.payload[VAR_2]);
VAR_2 += 10;
VAR_13->Logs->Log(""RESOLVER"",VAR_14,""Resolver: rr.type is %d and this.type is %d rr.class %d this.class %d"", VAR_6.type, this->type, VAR_6.rr_class, this->rr_class);
if (VAR_6.type != this->type)
{
VAR_5++;
VAR_2 += VAR_6.rdlength;
continue;
}
if (VAR_6.rr_class != this->rr_class)
{
VAR_5++;
VAR_2 += VAR_6.rdlength;
continue;
}
break;
}
if ((unsigned int)VAR_5 == VAR_0.ancount)
return std::make_pair((unsigned char*)NULL,""No A, AAAA or PTR type answers ("" + ConvToStr(VAR_0.ancount) + "" answers)"");
if (VAR_2 + VAR_6.rdlength > (unsigned int)VAR_1)
return std::make_pair((unsigned char*)NULL,""Resource record larger than stated"");
if (VAR_6.rdlength > 1023)
return std::make_pair((unsigned char*)NULL,""Resource record too large"");
this->ttl = VAR_6.ttl;
switch (VAR_6.type)
{
case VAR_15:
case VAR_16:
VAR_3 = 0;
VAR_4 = 0;
while (VAR_4 == 0 && VAR_2 < VAR_1 && VAR_3 + 256 < 1023)
{
if (VAR_0.payload[VAR_2] > 63)
{
memcpy(&VAR_7,&VAR_0.payload[VAR_2],2);
VAR_2 = ntohs(VAR_7);
if (!(VAR_2 & VAR_17))
return std::make_pair((unsigned char *) NULL, ""DN label decompression header is bogus"");
VAR_2 &= ~VAR_17;
VAR_2 =- 12;
}
else
{
if (VAR_0.payload[VAR_2] == 0)
{
VAR_4 = 1;
}
else
{
VAR_18[VAR_3] = 0;
if (VAR_3 != 0)
VAR_18[VAR_3++] = '.';
if (VAR_3 + VAR_0.payload[VAR_2] > sizeof(DNSHeader))
return std::make_pair((unsigned char *) NULL, ""DN label decompression is impossible -- malformed/hostile packet?"");
memcpy(&VAR_18[VAR_3], &VAR_0.payload[VAR_2 + 1], VAR_0.payload[VAR_2]);
VAR_3 += VAR_0.payload[VAR_2];
VAR_2 += VAR_0.payload[VAR_2] + 1;
}
}
}
VAR_18[VAR_3] = 0;
break;
case VAR_19:
if (VAR_6.rdlength != sizeof(struct in6_addr))
return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 16 bytes for an ipv6 entry -- malformed/hostile packet?"");
memcpy(VAR_18,&VAR_0.payload[VAR_2],VAR_6.rdlength);
VAR_18[VAR_6.rdlength] = 0;
break;
case VAR_20:
if (VAR_6.rdlength != sizeof(struct in_addr))
return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 4 bytes for an ipv4 entry -- malformed/hostile packet?"");
memcpy(VAR_18,&VAR_0.payload[VAR_2],VAR_6.rdlength);
VAR_18[VAR_6.rdlength] = 0;
break;
default:
return std::make_pair((unsigned char *) NULL, ""don't know how to handle undefined type ("" + ConvToStr(VAR_6.type) + "") -- rejecting"");
break;
}
return std::make_pair(VAR_18,""No error"");
}",inspircd/58c893e834ff20495d00770922/dns.cpp/vul/before/0.json,"DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, unsigned length)
{
	unsigned i = 0, o;
	int q = 0;
	int curanswer;
	ResourceRecord rr;
 	unsigned short ptr;

	/* This is just to keep _FORTIFY_SOURCE happy */
	rr.type = DNS_QUERY_NONE;
	rr.rdlength = 0;
	rr.ttl = 1;	/* GCC is a whiney bastard -- see the XXX below. */
	rr.rr_class = 0; /* Same for VC++ */

	if (!(header.flags1 & FLAGS_MASK_QR))
		return std::make_pair((unsigned char*)NULL,""Not a query result"");

	if (header.flags1 & FLAGS_MASK_OPCODE)
		return std::make_pair((unsigned char*)NULL,""Unexpected value in DNS reply packet"");

	if (header.flags2 & FLAGS_MASK_RCODE)
		return std::make_pair((unsigned char*)NULL,""Domain name not found"");

	if (header.ancount < 1)
		return std::make_pair((unsigned char*)NULL,""No resource records returned"");

	/* Subtract the length of the header from the length of the packet */
	length -= 12;

	while ((unsigned int)q < header.qdcount && i < length)
	{
		if (header.payload[i] > 63)
		{
			i += 6;
			q++;
		}
		else
		{
			if (header.payload[i] == 0)
			{
				q++;
				i += 5;
			}
			else i += header.payload[i] + 1;
		}
	}
	curanswer = 0;
	while ((unsigned)curanswer < header.ancount)
	{
		q = 0;
		while (q == 0 && i < length)
		{
			if (header.payload[i] > 63)
			{
				i += 2;
				q = 1;
			}
			else
			{
				if (header.payload[i] == 0)
				{
					i++;
					q = 1;
				}
				else i += header.payload[i] + 1; /* skip length and label */
			}
		}
		if (static_cast<int>(length - i) < 10)
			return std::make_pair((unsigned char*)NULL,""Incorrectly sized DNS reply"");

		/* XXX: We actually initialise 'rr' here including its ttl field */
		DNS::FillResourceRecord(&rr,&header.payload[i]);

		i += 10;
		ServerInstance->Logs->Log(""RESOLVER"",DEBUG,""Resolver: rr.type is %d and this.type is %d rr.class %d this.class %d"", rr.type, this->type, rr.rr_class, this->rr_class);
		if (rr.type != this->type)
		{
			curanswer++;
			i += rr.rdlength;
			continue;
		}
		if (rr.rr_class != this->rr_class)
		{
			curanswer++;
			i += rr.rdlength;
			continue;
		}
		break;
	}
	if ((unsigned int)curanswer == header.ancount)
		return std::make_pair((unsigned char*)NULL,""No A, AAAA or PTR type answers ("" + ConvToStr(header.ancount) + "" answers)"");

	if (i + rr.rdlength > (unsigned int)length)
		return std::make_pair((unsigned char*)NULL,""Resource record larger than stated"");

	if (rr.rdlength > 1023)
		return std::make_pair((unsigned char*)NULL,""Resource record too large"");

	this->ttl = rr.ttl;

	switch (rr.type)
	{
		/*
		 * CNAME and PTR are compressed.  We need to decompress them.
		 */
		case DNS_QUERY_CNAME:
		case DNS_QUERY_PTR:
		{
			unsigned short lowest_pos = length;
			o = 0;
			q = 0;
			while (q == 0 && i < length && o + 256 < 1023)
			{
				/* DN label found (byte over 63) */
				if (header.payload[i] > 63)
				{
					memcpy(&ptr,&header.payload[i],2);

					i = ntohs(ptr);

					/* check that highest two bits are set. if not, we've been had */
					if ((i & DN_COMP_BITMASK) != DN_COMP_BITMASK)
						return std::make_pair((unsigned char *) NULL, ""DN label decompression header is bogus"");

					/* mask away the two highest bits. */
					i &= ~DN_COMP_BITMASK;

					/* and decrease length by 12 bytes. */
					i -= 12;

					if (i >= lowest_pos)
						return std::make_pair((unsigned char *) NULL, ""Invalid decompression pointer"");
					lowest_pos = i;
				}
				else
				{
					if (header.payload[i] == 0)
					{
						q = 1;
					}
					else
					{
						res[o] = 0;
						if (o != 0)
							res[o++] = '.';

						if (o + header.payload[i] > sizeof(DNSHeader))
							return std::make_pair((unsigned char *) NULL, ""DN label decompression is impossible -- malformed/hostile packet?"");

						memcpy(&res[o], &header.payload[i + 1], header.payload[i]);
						o += header.payload[i];
						i += header.payload[i] + 1;
					}
				}
			}
			res[o] = 0;
		}
		break;
		case DNS_QUERY_AAAA:
			if (rr.rdlength != sizeof(struct in6_addr))
				return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 16 bytes for an ipv6 entry -- malformed/hostile packet?"");

			memcpy(res,&header.payload[i],rr.rdlength);
			res[rr.rdlength] = 0;
		break;
		case DNS_QUERY_A:
			if (rr.rdlength != sizeof(struct in_addr))
				return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 4 bytes for an ipv4 entry -- malformed/hostile packet?"");

			memcpy(res,&header.payload[i],rr.rdlength);
			res[rr.rdlength] = 0;
		break;
		default:
			return std::make_pair((unsigned char *) NULL, ""don't know how to handle undefined type ("" + ConvToStr(rr.type) + "") -- rejecting"");
		break;
	}
	return std::make_pair(res,""No error"");
}","DNSInfo DNSRequest::ResultIsReady(DNSHeader &VAR_0, unsigned VAR_1)
{
	unsigned VAR_2 = 0, VAR_3;
	int VAR_4 = 0;
	int VAR_5;
	ResourceRecord VAR_6;
 	unsigned short VAR_7;

	/* COMMENT_0 */
	VAR_6.type = VAR_8;
	VAR_6.rdlength = 0;
	VAR_6.ttl = 1;	/* COMMENT_1 */
	VAR_6.rr_class = 0; /* COMMENT_2 */

	if (!(VAR_0.flags1 & VAR_9))
		return std::make_pair((unsigned char*)NULL,""Not a query result"");

	if (VAR_0.flags1 & VAR_10)
		return std::make_pair((unsigned char*)NULL,""Unexpected value in DNS reply packet"");

	if (VAR_0.flags2 & VAR_11)
		return std::make_pair((unsigned char*)NULL,""Domain name not found"");

	if (VAR_0.ancount < 1)
		return std::make_pair((unsigned char*)NULL,""No resource records returned"");

	/* COMMENT_3 */
	VAR_1 -= 12;

	while ((unsigned int)VAR_4 < VAR_0.qdcount && VAR_2 < VAR_1)
	{
		if (VAR_0.payload[VAR_2] > 63)
		{
			VAR_2 += 6;
			VAR_4++;
		}
		else
		{
			if (VAR_0.payload[VAR_2] == 0)
			{
				VAR_4++;
				VAR_2 += 5;
			}
			else VAR_2 += VAR_0.payload[VAR_2] + 1;
		}
	}
	VAR_5 = 0;
	while ((unsigned)VAR_5 < VAR_0.ancount)
	{
		VAR_4 = 0;
		while (VAR_4 == 0 && VAR_2 < VAR_1)
		{
			if (VAR_0.payload[VAR_2] > 63)
			{
				VAR_2 += 2;
				VAR_4 = 1;
			}
			else
			{
				if (VAR_0.payload[VAR_2] == 0)
				{
					VAR_2++;
					VAR_4 = 1;
				}
				else VAR_2 += VAR_0.payload[VAR_2] + 1; /* COMMENT_4 */
			}
		}
		if (VAR_12<int>(VAR_1 - VAR_2) < 10)
			return std::make_pair((unsigned char*)NULL,""Incorrectly sized DNS reply"");

		/* COMMENT_5 */
		DNS::FillResourceRecord(&VAR_6,&VAR_0.payload[VAR_2]);

		VAR_2 += 10;
		VAR_13->Logs->Log(""RESOLVER"",VAR_14,""Resolver: rr.type is %d and this.type is %d rr.class %d this.class %d"", VAR_6.type, this->type, VAR_6.rr_class, this->rr_class);
		if (VAR_6.type != this->type)
		{
			VAR_5++;
			VAR_2 += VAR_6.rdlength;
			continue;
		}
		if (VAR_6.rr_class != this->rr_class)
		{
			VAR_5++;
			VAR_2 += VAR_6.rdlength;
			continue;
		}
		break;
	}
	if ((unsigned int)VAR_5 == VAR_0.ancount)
		return std::make_pair((unsigned char*)NULL,""No A, AAAA or PTR type answers ("" + ConvToStr(VAR_0.ancount) + "" answers)"");

	if (VAR_2 + VAR_6.rdlength > (unsigned int)VAR_1)
		return std::make_pair((unsigned char*)NULL,""Resource record larger than stated"");

	if (VAR_6.rdlength > 1023)
		return std::make_pair((unsigned char*)NULL,""Resource record too large"");

	this->ttl = VAR_6.ttl;

	switch (VAR_6.type)
	{
		/* COMMENT_6 */
                                                               
     
		case VAR_15:
		case VAR_16:
		{
			unsigned short VAR_17 = VAR_1;
			VAR_3 = 0;
			VAR_4 = 0;
			while (VAR_4 == 0 && VAR_2 < VAR_1 && VAR_3 + 256 < 1023)
			{
				/* COMMENT_9 */
				if (VAR_0.payload[VAR_2] > 63)
				{
					memcpy(&VAR_7,&VAR_0.payload[VAR_2],2);

					VAR_2 = ntohs(VAR_7);

					/* COMMENT_10 */
					if ((VAR_2 & VAR_18) != VAR_18)
						return std::make_pair((unsigned char *) NULL, ""DN label decompression header is bogus"");

					/* COMMENT_11 */
					VAR_2 &= ~VAR_18;

					/* COMMENT_12 */
					VAR_2 -= 12;

					if (VAR_2 >= VAR_17)
						return std::make_pair((unsigned char *) NULL, ""Invalid decompression pointer"");
					VAR_17 = VAR_2;
				}
				else
				{
					if (VAR_0.payload[VAR_2] == 0)
					{
						VAR_4 = 1;
					}
					else
					{
						VAR_19[VAR_3] = 0;
						if (VAR_3 != 0)
							VAR_19[VAR_3++] = '.';

						if (VAR_3 + VAR_0.payload[VAR_2] > sizeof(DNSHeader))
							return std::make_pair((unsigned char *) NULL, ""DN label decompression is impossible -- malformed/hostile packet?"");

						memcpy(&VAR_19[VAR_3], &VAR_0.payload[VAR_2 + 1], VAR_0.payload[VAR_2]);
						VAR_3 += VAR_0.payload[VAR_2];
						VAR_2 += VAR_0.payload[VAR_2] + 1;
					}
				}
			}
			VAR_19[VAR_3] = 0;
		}
		break;
		case VAR_20:
			if (VAR_6.rdlength != sizeof(struct in6_addr))
				return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 16 bytes for an ipv6 entry -- malformed/hostile packet?"");

			memcpy(VAR_19,&VAR_0.payload[VAR_2],VAR_6.rdlength);
			VAR_19[VAR_6.rdlength] = 0;
		break;
		case VAR_21:
			if (VAR_6.rdlength != sizeof(struct in_addr))
				return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 4 bytes for an ipv4 entry -- malformed/hostile packet?"");

			memcpy(VAR_19,&VAR_0.payload[VAR_2],VAR_6.rdlength);
			VAR_19[VAR_6.rdlength] = 0;
		break;
		default:
			return std::make_pair((unsigned char *) NULL, ""don't know how to handle undefined type ("" + ConvToStr(VAR_6.type) + "") -- rejecting"");
		break;
	}
	return std::make_pair(VAR_19,""No error"");
}",inspircd/58c893e834ff20495d00770922/dns.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -105,6 +105,8 @@
 		 */
 		case DNS_QUERY_CNAME:
 		case DNS_QUERY_PTR:
+		{
+			unsigned short lowest_pos = length;
 			o = 0;
 			q = 0;
 			while (q == 0 && i < length && o + 256 < 1023)
@@ -117,14 +119,18 @@
 					i = ntohs(ptr);
 
 					/* check that highest two bits are set. if not, we've been had */
-					if (!(i & DN_COMP_BITMASK))
+					if ((i & DN_COMP_BITMASK) != DN_COMP_BITMASK)
 						return std::make_pair((unsigned char *) NULL, ""DN label decompression header is bogus"");
 
 					/* mask away the two highest bits. */
 					i &= ~DN_COMP_BITMASK;
 
 					/* and decrease length by 12 bytes. */
-					i =- 12;
+					i -= 12;
+
+					if (i >= lowest_pos)
+						return std::make_pair((unsigned char *) NULL, ""Invalid decompression pointer"");
+					lowest_pos = i;
 				}
 				else
 				{
@@ -148,6 +154,7 @@
 				}
 			}
 			res[o] = 0;
+		}
 		break;
 		case DNS_QUERY_AAAA:
 			if (rr.rdlength != sizeof(struct in6_addr))","{'deleted_lines': ['\t\t\t\t\tif (!(i & DN_COMP_BITMASK))', '\t\t\t\t\ti =- 12;'], 'added_lines': ['\t\t{', '\t\t\tunsigned short lowest_pos = length;', '\t\t\t\t\tif ((i & DN_COMP_BITMASK) != DN_COMP_BITMASK)', '\t\t\t\t\ti -= 12;', '', '\t\t\t\t\tif (i >= lowest_pos)', '\t\t\t\t\t\treturn std::make_pair((unsigned char *) NULL, ""Invalid decompression pointer"");', '\t\t\t\t\tlowest_pos = i;', '\t\t}']}",True,InspIRCd before 2.0.7 allows remote attackers to cause a denial of service (infinite loop).,7.5,HIGH,2,test,2012-03-28T01:39:50Z,1
CVE-2012-6701,['CWE-190'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"vfs: make AIO use the proper rw_verify_area() area helpers

We had for some reason overlooked the AIO interface, and it didn't use
the proper rw_verify_area() helper function that checks (for example)
mandatory locking on the file, and that the size of the access doesn't
cause us to overflow the provided offset limits etc.

Instead, AIO did just the security_file_permission() thing (that
rw_verify_area() also does) directly.

This fixes it to do all the proper helper functions, which not only
means that now mandatory file locking works with AIO too, we can
actually remove lines of code.

Reported-by: Manish Honap <manish_honap_vit@yahoo.co.in>
Cc: stable@vger.kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",a70b52ec1aaeaf60f4739edb1b422827cb6f3893,https://github.com/torvalds/linux/commit/a70b52ec1aaeaf60f4739edb1b422827cb6f3893,fs/aio.c,aio_setup_vectored_rw,"static ssize_t aio_setup_vectored_rw(int type, struct kiocb *kiocb, bool compat)
{
ssize_t ret;
#ifdef CONFIG_COMPAT
if (compat)
ret = compat_rw_copy_check_uvector(type,
(struct compat_iovec __user *)kiocb->ki_buf,
kiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,
&kiocb->ki_iovec, 1);
else
#endif
ret = rw_copy_check_uvector(type,
(struct iovec __user *)kiocb->ki_buf,
kiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,
&kiocb->ki_iovec, 1);
if (ret < 0)
goto out;
kiocb->ki_nr_segs = kiocb->ki_nbytes;
kiocb->ki_cur_seg = 0;
kiocb->ki_nbytes = ret;
kiocb->ki_left = ret;
ret = 0;
out:
return ret;
}","static ssize_t aio_setup_vectored_rw(int VAR_0, struct kiocb *kiocb, bool VAR_1)
{
ssize_t VAR_2;
#ifdef VAR_3
if (VAR_1)
VAR_2 = compat_rw_copy_check_uvector(VAR_0,
(struct compat_iovec __user *)kiocb->ki_buf,
kiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,
&kiocb->ki_iovec, 1);
else
#endif
VAR_2 = rw_copy_check_uvector(VAR_0,
(struct iovec __user *)kiocb->ki_buf,
kiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,
&kiocb->ki_iovec, 1);
if (VAR_2 < 0)
goto out;
kiocb->ki_nr_segs = kiocb->ki_nbytes;
kiocb->ki_cur_seg = 0;
kiocb->ki_nbytes = VAR_2;
kiocb->ki_left = VAR_2;
VAR_2 = 0;
out:
return VAR_2;
}",torvalds/linux/a70b52ec1aaeaf60f4739edb1b422827cb6f3893/aio.c/vul/before/0.json,"static ssize_t aio_setup_vectored_rw(int type, struct kiocb *kiocb, bool compat)
{
	ssize_t ret;

#ifdef CONFIG_COMPAT
	if (compat)
		ret = compat_rw_copy_check_uvector(type,
				(struct compat_iovec __user *)kiocb->ki_buf,
				kiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,
				&kiocb->ki_iovec, 1);
	else
#endif
		ret = rw_copy_check_uvector(type,
				(struct iovec __user *)kiocb->ki_buf,
				kiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,
				&kiocb->ki_iovec, 1);
	if (ret < 0)
		goto out;

	ret = rw_verify_area(type, kiocb->ki_filp, &kiocb->ki_pos, ret);
	if (ret < 0)
		goto out;

	kiocb->ki_nr_segs = kiocb->ki_nbytes;
	kiocb->ki_cur_seg = 0;
	/* ki_nbytes/left now reflect bytes instead of segs */
	kiocb->ki_nbytes = ret;
	kiocb->ki_left = ret;

	ret = 0;
out:
	return ret;
}","static ssize_t aio_setup_vectored_rw(int VAR_0, struct kiocb *kiocb, bool VAR_1)
{
	ssize_t VAR_2;

#ifdef VAR_3
	if (VAR_1)
		VAR_2 = compat_rw_copy_check_uvector(VAR_0,
				(struct compat_iovec __user *)kiocb->ki_buf,
				kiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,
				&kiocb->ki_iovec, 1);
	else
#endif
		VAR_2 = rw_copy_check_uvector(VAR_0,
				(struct iovec __user *)kiocb->ki_buf,
				kiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,
				&kiocb->ki_iovec, 1);
	if (VAR_2 < 0)
		goto out;

	VAR_2 = rw_verify_area(VAR_0, kiocb->ki_filp, &kiocb->ki_pos, VAR_2);
	if (VAR_2 < 0)
		goto out;

	kiocb->ki_nr_segs = kiocb->ki_nbytes;
	kiocb->ki_cur_seg = 0;
	/* COMMENT_0 */
	kiocb->ki_nbytes = VAR_2;
	kiocb->ki_left = VAR_2;

	VAR_2 = 0;
out:
	return VAR_2;
}",torvalds/linux/a70b52ec1aaeaf60f4739edb1b422827cb6f3893/aio.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,6 +17,10 @@
 	if (ret < 0)
 		goto out;
 
+	ret = rw_verify_area(type, kiocb->ki_filp, &kiocb->ki_pos, ret);
+	if (ret < 0)
+		goto out;
+
 	kiocb->ki_nr_segs = kiocb->ki_nbytes;
 	kiocb->ki_cur_seg = 0;
 	/* ki_nbytes/left now reflect bytes instead of segs */","{'deleted_lines': [], 'added_lines': ['\tret = rw_verify_area(type, kiocb->ki_filp, &kiocb->ki_pos, ret);', '\tif (ret < 0)', '\t\tgoto out;', '']}",True,Integer overflow in fs/aio.c in the Linux kernel before 3.4.1 allows local users to cause a denial of service or possibly have unspecified other impact via a large AIO iovec.,7.8,HIGH,2,test,2012-05-21T23:06:20Z,1
CVE-2012-6701,['CWE-190'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"vfs: make AIO use the proper rw_verify_area() area helpers

We had for some reason overlooked the AIO interface, and it didn't use
the proper rw_verify_area() helper function that checks (for example)
mandatory locking on the file, and that the size of the access doesn't
cause us to overflow the provided offset limits etc.

Instead, AIO did just the security_file_permission() thing (that
rw_verify_area() also does) directly.

This fixes it to do all the proper helper functions, which not only
means that now mandatory file locking works with AIO too, we can
actually remove lines of code.

Reported-by: Manish Honap <manish_honap_vit@yahoo.co.in>
Cc: stable@vger.kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",a70b52ec1aaeaf60f4739edb1b422827cb6f3893,https://github.com/torvalds/linux/commit/a70b52ec1aaeaf60f4739edb1b422827cb6f3893,fs/aio.c,aio_setup_single_vector,"static ssize_t aio_setup_single_vector(struct kiocb *kiocb)
{
kiocb->ki_iovec = &kiocb->ki_inline_vec;
kiocb->ki_iovec->iov_base = kiocb->ki_buf;
kiocb->ki_iovec->iov_len = kiocb->ki_left;
kiocb->ki_nr_segs = 1;
kiocb->ki_cur_seg = 0;
return 0;
}","static ssize_t aio_setup_single_vector(struct kiocb *kiocb)
{
kiocb->ki_iovec = &kiocb->ki_inline_vec;
kiocb->ki_iovec->iov_base = kiocb->ki_buf;
kiocb->ki_iovec->iov_len = kiocb->ki_left;
kiocb->ki_nr_segs = 1;
kiocb->ki_cur_seg = 0;
return 0;
}",torvalds/linux/a70b52ec1aaeaf60f4739edb1b422827cb6f3893/aio.c/vul/before/2.json,"static ssize_t aio_setup_single_vector(int type, struct file * file, struct kiocb *kiocb)
{
	int bytes;

	bytes = rw_verify_area(type, file, &kiocb->ki_pos, kiocb->ki_left);
	if (bytes < 0)
		return bytes;

	kiocb->ki_iovec = &kiocb->ki_inline_vec;
	kiocb->ki_iovec->iov_base = kiocb->ki_buf;
	kiocb->ki_iovec->iov_len = bytes;
	kiocb->ki_nr_segs = 1;
	kiocb->ki_cur_seg = 0;
	return 0;
}","static ssize_t aio_setup_single_vector(int VAR_0, struct file * file, struct kiocb *kiocb)
{
	int VAR_1;

	VAR_1 = rw_verify_area(VAR_0, file, &kiocb->ki_pos, kiocb->ki_left);
	if (VAR_1 < 0)
		return VAR_1;

	kiocb->ki_iovec = &kiocb->ki_inline_vec;
	kiocb->ki_iovec->iov_base = kiocb->ki_buf;
	kiocb->ki_iovec->iov_len = VAR_1;
	kiocb->ki_nr_segs = 1;
	kiocb->ki_cur_seg = 0;
	return 0;
}",torvalds/linux/a70b52ec1aaeaf60f4739edb1b422827cb6f3893/aio.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,8 +1,14 @@
-static ssize_t aio_setup_single_vector(struct kiocb *kiocb)
+static ssize_t aio_setup_single_vector(int type, struct file * file, struct kiocb *kiocb)
 {
+	int bytes;
+
+	bytes = rw_verify_area(type, file, &kiocb->ki_pos, kiocb->ki_left);
+	if (bytes < 0)
+		return bytes;
+
 	kiocb->ki_iovec = &kiocb->ki_inline_vec;
 	kiocb->ki_iovec->iov_base = kiocb->ki_buf;
-	kiocb->ki_iovec->iov_len = kiocb->ki_left;
+	kiocb->ki_iovec->iov_len = bytes;
 	kiocb->ki_nr_segs = 1;
 	kiocb->ki_cur_seg = 0;
 	return 0;","{'deleted_lines': ['static ssize_t aio_setup_single_vector(struct kiocb *kiocb)', '\tkiocb->ki_iovec->iov_len = kiocb->ki_left;'], 'added_lines': ['static ssize_t aio_setup_single_vector(int type, struct file * file, struct kiocb *kiocb)', '\tint bytes;', '', '\tbytes = rw_verify_area(type, file, &kiocb->ki_pos, kiocb->ki_left);', '\tif (bytes < 0)', '\t\treturn bytes;', '', '\tkiocb->ki_iovec->iov_len = bytes;']}",True,Integer overflow in fs/aio.c in the Linux kernel before 3.4.1 allows local users to cause a denial of service or possibly have unspecified other impact via a large AIO iovec.,7.8,HIGH,2,test,2012-05-21T23:06:20Z,1
CVE-2012-6701,['CWE-190'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"vfs: make AIO use the proper rw_verify_area() area helpers

We had for some reason overlooked the AIO interface, and it didn't use
the proper rw_verify_area() helper function that checks (for example)
mandatory locking on the file, and that the size of the access doesn't
cause us to overflow the provided offset limits etc.

Instead, AIO did just the security_file_permission() thing (that
rw_verify_area() also does) directly.

This fixes it to do all the proper helper functions, which not only
means that now mandatory file locking works with AIO too, we can
actually remove lines of code.

Reported-by: Manish Honap <manish_honap_vit@yahoo.co.in>
Cc: stable@vger.kernel.org
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",a70b52ec1aaeaf60f4739edb1b422827cb6f3893,https://github.com/torvalds/linux/commit/a70b52ec1aaeaf60f4739edb1b422827cb6f3893,fs/aio.c,aio_setup_iocb,"static ssize_t aio_setup_iocb(struct kiocb *kiocb, bool compat)
{
struct file *file = kiocb->ki_filp;
ssize_t ret = 0;
switch (kiocb->ki_opcode) {
case IOCB_CMD_PREAD:
ret = -EBADF;
if (unlikely(!(file->f_mode & FMODE_READ)))
break;
ret = -EFAULT;
if (unlikely(!access_ok(VERIFY_WRITE, kiocb->ki_buf,
kiocb->ki_left)))
break;
ret = security_file_permission(file, MAY_READ);
if (unlikely(ret))
break;
ret = aio_setup_single_vector(kiocb);
if (ret)
break;
ret = -EINVAL;
if (file->f_op->aio_read)
kiocb->ki_retry = aio_rw_vect_retry;
break;
case IOCB_CMD_PWRITE:
ret = -EBADF;
if (unlikely(!(file->f_mode & FMODE_WRITE)))
break;
ret = -EFAULT;
if (unlikely(!access_ok(VERIFY_READ, kiocb->ki_buf,
kiocb->ki_left)))
break;
ret = security_file_permission(file, MAY_WRITE);
if (unlikely(ret))
break;
ret = aio_setup_single_vector(kiocb);
if (ret)
break;
ret = -EINVAL;
if (file->f_op->aio_write)
kiocb->ki_retry = aio_rw_vect_retry;
break;
case IOCB_CMD_PREADV:
ret = -EBADF;
if (unlikely(!(file->f_mode & FMODE_READ)))
break;
ret = security_file_permission(file, MAY_READ);
if (unlikely(ret))
break;
ret = aio_setup_vectored_rw(READ, kiocb, compat);
if (ret)
break;
ret = -EINVAL;
if (file->f_op->aio_read)
kiocb->ki_retry = aio_rw_vect_retry;
break;
case IOCB_CMD_PWRITEV:
ret = -EBADF;
if (unlikely(!(file->f_mode & FMODE_WRITE)))
break;
ret = security_file_permission(file, MAY_WRITE);
if (unlikely(ret))
break;
ret = aio_setup_vectored_rw(WRITE, kiocb, compat);
if (ret)
break;
ret = -EINVAL;
if (file->f_op->aio_write)
kiocb->ki_retry = aio_rw_vect_retry;
break;
case IOCB_CMD_FDSYNC:
ret = -EINVAL;
if (file->f_op->aio_fsync)
kiocb->ki_retry = aio_fdsync;
break;
case IOCB_CMD_FSYNC:
ret = -EINVAL;
if (file->f_op->aio_fsync)
kiocb->ki_retry = aio_fsync;
break;
default:
dprintk(""EINVAL: io_submit: no operation provided\n"");
ret = -EINVAL;
}
if (!kiocb->ki_retry)
return ret;
return 0;
}","static ssize_t aio_setup_iocb(struct kiocb *kiocb, bool VAR_0)
{
struct file *file = kiocb->ki_filp;
ssize_t VAR_1 = 0;
switch (kiocb->ki_opcode) {
case VAR_2:
VAR_1 = -VAR_3;
if (unlikely(!(file->f_mode & VAR_4)))
break;
VAR_1 = -VAR_5;
if (unlikely(!access_ok(VAR_6, kiocb->ki_buf,
kiocb->ki_left)))
break;
VAR_1 = security_file_permission(file, VAR_7);
if (unlikely(VAR_1))
break;
VAR_1 = aio_setup_single_vector(kiocb);
if (VAR_1)
break;
VAR_1 = -VAR_8;
if (file->f_op->aio_read)
kiocb->ki_retry = VAR_9;
break;
case VAR_10:
VAR_1 = -VAR_3;
if (unlikely(!(file->f_mode & VAR_11)))
break;
VAR_1 = -VAR_5;
if (unlikely(!access_ok(VAR_12, kiocb->ki_buf,
kiocb->ki_left)))
break;
VAR_1 = security_file_permission(file, VAR_13);
if (unlikely(VAR_1))
break;
VAR_1 = aio_setup_single_vector(kiocb);
if (VAR_1)
break;
VAR_1 = -VAR_8;
if (file->f_op->aio_write)
kiocb->ki_retry = VAR_9;
break;
case VAR_14:
VAR_1 = -VAR_3;
if (unlikely(!(file->f_mode & VAR_4)))
break;
VAR_1 = security_file_permission(file, VAR_7);
if (unlikely(VAR_1))
break;
VAR_1 = aio_setup_vectored_rw(VAR_15, kiocb, VAR_0);
if (VAR_1)
break;
VAR_1 = -VAR_8;
if (file->f_op->aio_read)
kiocb->ki_retry = VAR_9;
break;
case VAR_16:
VAR_1 = -VAR_3;
if (unlikely(!(file->f_mode & VAR_11)))
break;
VAR_1 = security_file_permission(file, VAR_13);
if (unlikely(VAR_1))
break;
VAR_1 = aio_setup_vectored_rw(VAR_17, kiocb, VAR_0);
if (VAR_1)
break;
VAR_1 = -VAR_8;
if (file->f_op->aio_write)
kiocb->ki_retry = VAR_9;
break;
case VAR_18:
VAR_1 = -VAR_8;
if (file->f_op->aio_fsync)
kiocb->ki_retry = VAR_19;
break;
case VAR_20:
VAR_1 = -VAR_8;
if (file->f_op->aio_fsync)
kiocb->ki_retry = VAR_21;
break;
default:
dprintk(""EINVAL: io_submit: no operation provided\n"");
VAR_1 = -VAR_8;
}
if (!kiocb->ki_retry)
return VAR_1;
return 0;
}",torvalds/linux/a70b52ec1aaeaf60f4739edb1b422827cb6f3893/aio.c/vul/before/1.json,"static ssize_t aio_setup_iocb(struct kiocb *kiocb, bool compat)
{
	struct file *file = kiocb->ki_filp;
	ssize_t ret = 0;

	switch (kiocb->ki_opcode) {
	case IOCB_CMD_PREAD:
		ret = -EBADF;
		if (unlikely(!(file->f_mode & FMODE_READ)))
			break;
		ret = -EFAULT;
		if (unlikely(!access_ok(VERIFY_WRITE, kiocb->ki_buf,
			kiocb->ki_left)))
			break;
		ret = aio_setup_single_vector(READ, file, kiocb);
		if (ret)
			break;
		ret = -EINVAL;
		if (file->f_op->aio_read)
			kiocb->ki_retry = aio_rw_vect_retry;
		break;
	case IOCB_CMD_PWRITE:
		ret = -EBADF;
		if (unlikely(!(file->f_mode & FMODE_WRITE)))
			break;
		ret = -EFAULT;
		if (unlikely(!access_ok(VERIFY_READ, kiocb->ki_buf,
			kiocb->ki_left)))
			break;
		ret = aio_setup_single_vector(WRITE, file, kiocb);
		if (ret)
			break;
		ret = -EINVAL;
		if (file->f_op->aio_write)
			kiocb->ki_retry = aio_rw_vect_retry;
		break;
	case IOCB_CMD_PREADV:
		ret = -EBADF;
		if (unlikely(!(file->f_mode & FMODE_READ)))
			break;
		ret = aio_setup_vectored_rw(READ, kiocb, compat);
		if (ret)
			break;
		ret = -EINVAL;
		if (file->f_op->aio_read)
			kiocb->ki_retry = aio_rw_vect_retry;
		break;
	case IOCB_CMD_PWRITEV:
		ret = -EBADF;
		if (unlikely(!(file->f_mode & FMODE_WRITE)))
			break;
		ret = aio_setup_vectored_rw(WRITE, kiocb, compat);
		if (ret)
			break;
		ret = -EINVAL;
		if (file->f_op->aio_write)
			kiocb->ki_retry = aio_rw_vect_retry;
		break;
	case IOCB_CMD_FDSYNC:
		ret = -EINVAL;
		if (file->f_op->aio_fsync)
			kiocb->ki_retry = aio_fdsync;
		break;
	case IOCB_CMD_FSYNC:
		ret = -EINVAL;
		if (file->f_op->aio_fsync)
			kiocb->ki_retry = aio_fsync;
		break;
	default:
		dprintk(""EINVAL: io_submit: no operation provided\n"");
		ret = -EINVAL;
	}

	if (!kiocb->ki_retry)
		return ret;

	return 0;
}","static ssize_t aio_setup_iocb(struct kiocb *kiocb, bool VAR_0)
{
	struct file *file = kiocb->ki_filp;
	ssize_t VAR_1 = 0;

	switch (kiocb->ki_opcode) {
	case VAR_2:
		VAR_1 = -VAR_3;
		if (unlikely(!(file->f_mode & VAR_4)))
			break;
		VAR_1 = -VAR_5;
		if (unlikely(!access_ok(VAR_6, kiocb->ki_buf,
			kiocb->ki_left)))
			break;
		VAR_1 = aio_setup_single_vector(VAR_7, file, kiocb);
		if (VAR_1)
			break;
		VAR_1 = -VAR_8;
		if (file->f_op->aio_read)
			kiocb->ki_retry = VAR_9;
		break;
	case VAR_10:
		VAR_1 = -VAR_3;
		if (unlikely(!(file->f_mode & VAR_11)))
			break;
		VAR_1 = -VAR_5;
		if (unlikely(!access_ok(VAR_12, kiocb->ki_buf,
			kiocb->ki_left)))
			break;
		VAR_1 = aio_setup_single_vector(VAR_13, file, kiocb);
		if (VAR_1)
			break;
		VAR_1 = -VAR_8;
		if (file->f_op->aio_write)
			kiocb->ki_retry = VAR_9;
		break;
	case VAR_14:
		VAR_1 = -VAR_3;
		if (unlikely(!(file->f_mode & VAR_4)))
			break;
		VAR_1 = aio_setup_vectored_rw(VAR_7, kiocb, VAR_0);
		if (VAR_1)
			break;
		VAR_1 = -VAR_8;
		if (file->f_op->aio_read)
			kiocb->ki_retry = VAR_9;
		break;
	case VAR_15:
		VAR_1 = -VAR_3;
		if (unlikely(!(file->f_mode & VAR_11)))
			break;
		VAR_1 = aio_setup_vectored_rw(VAR_13, kiocb, VAR_0);
		if (VAR_1)
			break;
		VAR_1 = -VAR_8;
		if (file->f_op->aio_write)
			kiocb->ki_retry = VAR_9;
		break;
	case VAR_16:
		VAR_1 = -VAR_8;
		if (file->f_op->aio_fsync)
			kiocb->ki_retry = VAR_17;
		break;
	case VAR_18:
		VAR_1 = -VAR_8;
		if (file->f_op->aio_fsync)
			kiocb->ki_retry = VAR_19;
		break;
	default:
		dprintk(""EINVAL: io_submit: no operation provided\n"");
		VAR_1 = -VAR_8;
	}

	if (!kiocb->ki_retry)
		return VAR_1;

	return 0;
}",torvalds/linux/a70b52ec1aaeaf60f4739edb1b422827cb6f3893/aio.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -12,10 +12,7 @@
 		if (unlikely(!access_ok(VERIFY_WRITE, kiocb->ki_buf,
 			kiocb->ki_left)))
 			break;
-		ret = security_file_permission(file, MAY_READ);
-		if (unlikely(ret))
-			break;
-		ret = aio_setup_single_vector(kiocb);
+		ret = aio_setup_single_vector(READ, file, kiocb);
 		if (ret)
 			break;
 		ret = -EINVAL;
@@ -30,10 +27,7 @@
 		if (unlikely(!access_ok(VERIFY_READ, kiocb->ki_buf,
 			kiocb->ki_left)))
 			break;
-		ret = security_file_permission(file, MAY_WRITE);
-		if (unlikely(ret))
-			break;
-		ret = aio_setup_single_vector(kiocb);
+		ret = aio_setup_single_vector(WRITE, file, kiocb);
 		if (ret)
 			break;
 		ret = -EINVAL;
@@ -43,9 +37,6 @@
 	case IOCB_CMD_PREADV:
 		ret = -EBADF;
 		if (unlikely(!(file->f_mode & FMODE_READ)))
-			break;
-		ret = security_file_permission(file, MAY_READ);
-		if (unlikely(ret))
 			break;
 		ret = aio_setup_vectored_rw(READ, kiocb, compat);
 		if (ret)
@@ -57,9 +48,6 @@
 	case IOCB_CMD_PWRITEV:
 		ret = -EBADF;
 		if (unlikely(!(file->f_mode & FMODE_WRITE)))
-			break;
-		ret = security_file_permission(file, MAY_WRITE);
-		if (unlikely(ret))
 			break;
 		ret = aio_setup_vectored_rw(WRITE, kiocb, compat);
 		if (ret)","{'deleted_lines': ['\t\tret = security_file_permission(file, MAY_READ);', '\t\tif (unlikely(ret))', '\t\t\tbreak;', '\t\tret = aio_setup_single_vector(kiocb);', '\t\tret = security_file_permission(file, MAY_WRITE);', '\t\tif (unlikely(ret))', '\t\t\tbreak;', '\t\tret = aio_setup_single_vector(kiocb);', '\t\t\tbreak;', '\t\tret = security_file_permission(file, MAY_READ);', '\t\tif (unlikely(ret))', '\t\t\tbreak;', '\t\tret = security_file_permission(file, MAY_WRITE);', '\t\tif (unlikely(ret))'], 'added_lines': ['\t\tret = aio_setup_single_vector(READ, file, kiocb);', '\t\tret = aio_setup_single_vector(WRITE, file, kiocb);']}",True,Integer overflow in fs/aio.c in the Linux kernel before 3.4.1 allows local users to cause a denial of service or possibly have unspecified other impact via a large AIO iovec.,7.8,HIGH,2,test,2012-05-21T23:06:20Z,1
CVE-2012-6689,['CWE-284'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"netlink: fix possible spoofing from non-root processes

Non-root user-space processes can send Netlink messages to other
processes that are well-known for being subscribed to Netlink
asynchronous notifications. This allows ilegitimate non-root
process to send forged messages to Netlink subscribers.

The userspace process usually verifies the legitimate origin in
two ways:

a) Socket credentials. If UID != 0, then the message comes from
   some ilegitimate process and the message needs to be dropped.

b) Netlink portID. In general, portID == 0 means that the origin
   of the messages comes from the kernel. Thus, discarding any
   message not coming from the kernel.

However, ctnetlink sets the portID in event messages that has
been triggered by some user-space process, eg. conntrack utility.
So other processes subscribed to ctnetlink events, eg. conntrackd,
know that the event was triggered by some user-space action.

Neither of the two ways to discard ilegitimate messages coming
from non-root processes can help for ctnetlink.

This patch adds capability validation in case that dst_pid is set
in netlink_sendmsg(). This approach is aggressive since existing
applications using any Netlink bus to deliver messages between
two user-space processes will break. Note that the exception is
NETLINK_USERSOCK, since it is reserved for netlink-to-netlink
userspace communication.

Still, if anyone wants that his Netlink bus allows netlink-to-netlink
userspace, then they can set NL_NONROOT_SEND. However, by default,
I don't think it makes sense to allow to use NETLINK_ROUTE to
communicate two processes that are sending no matter what information
that is not related to link/neighbouring/routing. They should be using
NETLINK_USERSOCK instead for that.

Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",20e1db19db5d6b9e4e83021595eab0dc8f107bef,https://github.com/torvalds/linux/commit/20e1db19db5d6b9e4e83021595eab0dc8f107bef,net/netlink/af_netlink.c,netlink_sendmsg,"static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
struct msghdr *msg, size_t len)
{
struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
struct sock *sk = sock->sk;
struct netlink_sock *nlk = nlk_sk(sk);
struct sockaddr_nl *addr = msg->msg_name;
u32 dst_pid;
u32 dst_group;
struct sk_buff *skb;
int err;
struct scm_cookie scm;
if (msg->msg_flags&MSG_OOB)
return -EOPNOTSUPP;
if (NULL == siocb->scm)
siocb->scm = &scm;
err = scm_send(sock, msg, siocb->scm, true);
if (err < 0)
return err;
if (msg->msg_namelen) {
err = -EINVAL;
if (addr->nl_family != AF_NETLINK)
goto out;
dst_pid = addr->nl_pid;
dst_group = ffs(addr->nl_groups);
err =  -EPERM;
if (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))
goto out;
} else {
dst_pid = nlk->dst_pid;
dst_group = nlk->dst_group;
}
if (!nlk->pid) {
err = netlink_autobind(sock);
if (err)
goto out;
}
err = -EMSGSIZE;
if (len > sk->sk_sndbuf - 32)
goto out;
err = -ENOBUFS;
skb = alloc_skb(len, GFP_KERNEL);
if (skb == NULL)
goto out;
NETLINK_CB(skb).pid= nlk->pid;
NETLINK_CB(skb).dst_group = dst_group;
memcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));
err = -EFAULT;
if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
kfree_skb(skb);
goto out;
}
err = security_netlink_send(sk, skb);
if (err) {
kfree_skb(skb);
goto out;
}
if (dst_group) {
atomic_inc(&skb->users);
netlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);
}
err = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);
out:
scm_destroy(siocb->scm);
return err;
}","static int netlink_sendmsg(struct kiocb *kiocb, struct socket *VAR_0,
struct msghdr *VAR_1, size_t VAR_2)
{
struct sock_iocb *VAR_3 = kiocb_to_siocb(kiocb);
struct sock *VAR_4 = sock->sk;
struct netlink_sock *VAR_5 = nlk_sk(VAR_4);
struct sockaddr_nl *VAR_6 = VAR_1->msg_name;
u32 VAR_7;
u32 VAR_8;
struct sk_buff *VAR_9;
int VAR_10;
struct scm_cookie VAR_11;
if (VAR_1->msg_flags&VAR_12)
return -VAR_13;
if (NULL == VAR_3->scm)
VAR_3->scm = &VAR_11;
VAR_10 = scm_send(sock, VAR_1, VAR_3->scm, true);
if (VAR_10 < 0)
return VAR_10;
if (VAR_1->msg_namelen) {
VAR_10 = -VAR_14;
if (VAR_6->nl_family != VAR_15)
goto out;
VAR_7 = VAR_6->nl_pid;
VAR_8 = ffs(VAR_6->nl_groups);
VAR_10 =  -VAR_16;
if (VAR_8 && !netlink_capable(sock, VAR_17))
goto out;
} else {
VAR_7 = VAR_5->dst_pid;
VAR_8 = VAR_5->dst_group;
}
if (!VAR_5->pid) {
VAR_10 = netlink_autobind(sock);
if (VAR_10)
goto out;
}
VAR_10 = -VAR_18;
if (VAR_2 > VAR_4->sk_sndbuf - 32)
goto out;
VAR_10 = -VAR_19;
VAR_9 = alloc_skb(VAR_2, VAR_20);
if (VAR_9 == NULL)
goto out;
NETLINK_CB(VAR_9).pid= VAR_5->pid;
NETLINK_CB(VAR_9).dst_group = VAR_8;
memcpy(NETLINK_CREDS(VAR_9), &VAR_3->scm->creds, sizeof(struct ucred));
VAR_10 = -VAR_21;
if (memcpy_fromiovec(skb_put(VAR_9, VAR_2), VAR_1->msg_iov, VAR_2)) {
kfree_skb(VAR_9);
goto out;
}
VAR_10 = security_netlink_send(VAR_4, VAR_9);
if (VAR_10) {
kfree_skb(VAR_9);
goto out;
}
if (VAR_8) {
atomic_inc(&VAR_9->users);
netlink_broadcast(VAR_4, VAR_9, VAR_7, VAR_8, VAR_20);
}
VAR_10 = netlink_unicast(VAR_4, VAR_9, VAR_7, VAR_1->msg_flags&VAR_22);
out:
scm_destroy(VAR_3->scm);
return VAR_10;
}",torvalds/linux/20e1db19db5d6b9e4e83021595eab0dc8f107bef/af_netlink.c/vul/before/1.json,"static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
			   struct msghdr *msg, size_t len)
{
	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
	struct sock *sk = sock->sk;
	struct netlink_sock *nlk = nlk_sk(sk);
	struct sockaddr_nl *addr = msg->msg_name;
	u32 dst_pid;
	u32 dst_group;
	struct sk_buff *skb;
	int err;
	struct scm_cookie scm;

	if (msg->msg_flags&MSG_OOB)
		return -EOPNOTSUPP;

	if (NULL == siocb->scm)
		siocb->scm = &scm;

	err = scm_send(sock, msg, siocb->scm, true);
	if (err < 0)
		return err;

	if (msg->msg_namelen) {
		err = -EINVAL;
		if (addr->nl_family != AF_NETLINK)
			goto out;
		dst_pid = addr->nl_pid;
		dst_group = ffs(addr->nl_groups);
		err =  -EPERM;
		if ((dst_group || dst_pid) &&
		    !netlink_capable(sock, NL_NONROOT_SEND))
			goto out;
	} else {
		dst_pid = nlk->dst_pid;
		dst_group = nlk->dst_group;
	}

	if (!nlk->pid) {
		err = netlink_autobind(sock);
		if (err)
			goto out;
	}

	err = -EMSGSIZE;
	if (len > sk->sk_sndbuf - 32)
		goto out;
	err = -ENOBUFS;
	skb = alloc_skb(len, GFP_KERNEL);
	if (skb == NULL)
		goto out;

	NETLINK_CB(skb).pid	= nlk->pid;
	NETLINK_CB(skb).dst_group = dst_group;
	memcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));

	err = -EFAULT;
	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
		kfree_skb(skb);
		goto out;
	}

	err = security_netlink_send(sk, skb);
	if (err) {
		kfree_skb(skb);
		goto out;
	}

	if (dst_group) {
		atomic_inc(&skb->users);
		netlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);
	}
	err = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);

out:
	scm_destroy(siocb->scm);
	return err;
}","static int netlink_sendmsg(struct kiocb *kiocb, struct socket *VAR_0,
			   struct msghdr *VAR_1, size_t VAR_2)
{
	struct sock_iocb *VAR_3 = kiocb_to_siocb(kiocb);
	struct sock *VAR_4 = sock->sk;
	struct netlink_sock *VAR_5 = nlk_sk(VAR_4);
	struct sockaddr_nl *VAR_6 = VAR_1->msg_name;
	u32 VAR_7;
	u32 VAR_8;
	struct sk_buff *VAR_9;
	int VAR_10;
	struct scm_cookie VAR_11;

	if (VAR_1->msg_flags&VAR_12)
		return -VAR_13;

	if (NULL == VAR_3->scm)
		VAR_3->scm = &VAR_11;

	VAR_10 = scm_send(sock, VAR_1, VAR_3->scm, true);
	if (VAR_10 < 0)
		return VAR_10;

	if (VAR_1->msg_namelen) {
		VAR_10 = -VAR_14;
		if (VAR_6->nl_family != VAR_15)
			goto out;
		VAR_7 = VAR_6->nl_pid;
		VAR_8 = ffs(VAR_6->nl_groups);
		VAR_10 =  -VAR_16;
		if ((VAR_8 || VAR_7) &&
		    !netlink_capable(sock, VAR_17))
			goto out;
	} else {
		VAR_7 = VAR_5->dst_pid;
		VAR_8 = VAR_5->dst_group;
	}

	if (!VAR_5->pid) {
		VAR_10 = netlink_autobind(sock);
		if (VAR_10)
			goto out;
	}

	VAR_10 = -VAR_18;
	if (VAR_2 > VAR_4->sk_sndbuf - 32)
		goto out;
	VAR_10 = -VAR_19;
	VAR_9 = alloc_skb(VAR_2, VAR_20);
	if (VAR_9 == NULL)
		goto out;

	NETLINK_CB(VAR_9).pid	= VAR_5->pid;
	NETLINK_CB(VAR_9).dst_group = VAR_8;
	memcpy(NETLINK_CREDS(VAR_9), &VAR_3->scm->creds, sizeof(struct ucred));

	VAR_10 = -VAR_21;
	if (memcpy_fromiovec(skb_put(VAR_9, VAR_2), VAR_1->msg_iov, VAR_2)) {
		kfree_skb(VAR_9);
		goto out;
	}

	VAR_10 = security_netlink_send(VAR_4, VAR_9);
	if (VAR_10) {
		kfree_skb(VAR_9);
		goto out;
	}

	if (VAR_8) {
		atomic_inc(&VAR_9->users);
		netlink_broadcast(VAR_4, VAR_9, VAR_7, VAR_8, VAR_20);
	}
	VAR_10 = netlink_unicast(VAR_4, VAR_9, VAR_7, VAR_1->msg_flags&VAR_22);

out:
	scm_destroy(VAR_3->scm);
	return VAR_10;
}",torvalds/linux/20e1db19db5d6b9e4e83021595eab0dc8f107bef/af_netlink.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -28,7 +28,8 @@
 		dst_pid = addr->nl_pid;
 		dst_group = ffs(addr->nl_groups);
 		err =  -EPERM;
-		if (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))
+		if ((dst_group || dst_pid) &&
+		    !netlink_capable(sock, NL_NONROOT_SEND))
 			goto out;
 	} else {
 		dst_pid = nlk->dst_pid;","{'deleted_lines': ['\t\tif (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))'], 'added_lines': ['\t\tif ((dst_group || dst_pid) &&', '\t\t    !netlink_capable(sock, NL_NONROOT_SEND))']}",True,"The netlink_sendmsg function in net/netlink/af_netlink.c in the Linux kernel before 3.5.5 does not validate the dst_pid field, which allows local users to have an unspecified impact by spoofing Netlink messages.",7.8,HIGH,2,test,2012-08-23T02:09:11Z,1
CVE-2012-6689,['CWE-284'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"netlink: fix possible spoofing from non-root processes

Non-root user-space processes can send Netlink messages to other
processes that are well-known for being subscribed to Netlink
asynchronous notifications. This allows ilegitimate non-root
process to send forged messages to Netlink subscribers.

The userspace process usually verifies the legitimate origin in
two ways:

a) Socket credentials. If UID != 0, then the message comes from
   some ilegitimate process and the message needs to be dropped.

b) Netlink portID. In general, portID == 0 means that the origin
   of the messages comes from the kernel. Thus, discarding any
   message not coming from the kernel.

However, ctnetlink sets the portID in event messages that has
been triggered by some user-space process, eg. conntrack utility.
So other processes subscribed to ctnetlink events, eg. conntrackd,
know that the event was triggered by some user-space action.

Neither of the two ways to discard ilegitimate messages coming
from non-root processes can help for ctnetlink.

This patch adds capability validation in case that dst_pid is set
in netlink_sendmsg(). This approach is aggressive since existing
applications using any Netlink bus to deliver messages between
two user-space processes will break. Note that the exception is
NETLINK_USERSOCK, since it is reserved for netlink-to-netlink
userspace communication.

Still, if anyone wants that his Netlink bus allows netlink-to-netlink
userspace, then they can set NL_NONROOT_SEND. However, by default,
I don't think it makes sense to allow to use NETLINK_ROUTE to
communicate two processes that are sending no matter what information
that is not related to link/neighbouring/routing. They should be using
NETLINK_USERSOCK instead for that.

Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",20e1db19db5d6b9e4e83021595eab0dc8f107bef,https://github.com/torvalds/linux/commit/20e1db19db5d6b9e4e83021595eab0dc8f107bef,net/netlink/af_netlink.c,netlink_add_usersock_entry,"static void __init netlink_add_usersock_entry(void)
{
struct listeners *listeners;
int groups = 32;
listeners = kzalloc(sizeof(*listeners) + NLGRPSZ(groups), GFP_KERNEL);
if (!listeners)
panic(""netlink_add_usersock_entry: Cannot allocate listeners\n"");
netlink_table_grab();
nl_table[NETLINK_USERSOCK].groups = groups;
rcu_assign_pointer(nl_table[NETLINK_USERSOCK].listeners, listeners);
nl_table[NETLINK_USERSOCK].module = THIS_MODULE;
nl_table[NETLINK_USERSOCK].registered = 1;
netlink_table_ungrab();
}","static void __init netlink_add_usersock_entry(void)
{
struct listeners *listeners;
int VAR_0 = 32;
listeners = kzalloc(sizeof(*listeners) + NLGRPSZ(VAR_0), VAR_1);
if (!listeners)
panic(""netlink_add_usersock_entry: Cannot allocate listeners\n"");
netlink_table_grab();
VAR_2[VAR_3].groups = VAR_0;
rcu_assign_pointer(VAR_2[VAR_3].listeners, listeners);
VAR_2[VAR_3].module = VAR_4;
VAR_2[VAR_3].registered = 1;
netlink_table_ungrab();
}",,"static void __init netlink_add_usersock_entry(void)
{
	struct listeners *listeners;
	int groups = 32;

	listeners = kzalloc(sizeof(*listeners) + NLGRPSZ(groups), GFP_KERNEL);
	if (!listeners)
		panic(""netlink_add_usersock_entry: Cannot allocate listeners\n"");

	netlink_table_grab();

	nl_table[NETLINK_USERSOCK].groups = groups;
	rcu_assign_pointer(nl_table[NETLINK_USERSOCK].listeners, listeners);
	nl_table[NETLINK_USERSOCK].module = THIS_MODULE;
	nl_table[NETLINK_USERSOCK].registered = 1;
	nl_table[NETLINK_USERSOCK].nl_nonroot = NL_NONROOT_SEND;

	netlink_table_ungrab();
}","static void __init netlink_add_usersock_entry(void)
{
	struct listeners *listeners;
	int VAR_0 = 32;

	listeners = kzalloc(sizeof(*listeners) + NLGRPSZ(VAR_0), VAR_1);
	if (!listeners)
		panic(""netlink_add_usersock_entry: Cannot allocate listeners\n"");

	netlink_table_grab();

	VAR_2[VAR_3].groups = VAR_0;
	rcu_assign_pointer(VAR_2[VAR_3].listeners, listeners);
	VAR_2[VAR_3].module = VAR_4;
	VAR_2[VAR_3].registered = 1;
	VAR_2[VAR_3].nl_nonroot = VAR_5;

	netlink_table_ungrab();
}",,"--- func_before
+++ func_after
@@ -13,6 +13,7 @@
 	rcu_assign_pointer(nl_table[NETLINK_USERSOCK].listeners, listeners);
 	nl_table[NETLINK_USERSOCK].module = THIS_MODULE;
 	nl_table[NETLINK_USERSOCK].registered = 1;
+	nl_table[NETLINK_USERSOCK].nl_nonroot = NL_NONROOT_SEND;
 
 	netlink_table_ungrab();
 }","{'deleted_lines': [], 'added_lines': ['\tnl_table[NETLINK_USERSOCK].nl_nonroot = NL_NONROOT_SEND;']}",True,"The netlink_sendmsg function in net/netlink/af_netlink.c in the Linux kernel before 3.5.5 does not validate the dst_pid field, which allows local users to have an unspecified impact by spoofing Netlink messages.",7.8,HIGH,2,test,2012-08-23T02:09:11Z,1
CVE-2013-7455,['CWE-Other'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,mm2/Little-CMS,Fix a double free on error recovering,fefaaa43c382eee632ea3ad0cfa915335140e1db,https://github.com/mm2/Little-CMS/commit/fefaaa43c382eee632ea3ad0cfa915335140e1db,src/cmscnvrt.c,DefaultICCintents,"static
cmsPipeline* DefaultICCintents(cmsContext       ContextID,
cmsUInt32Number  nProfiles,
cmsUInt32Number  TheIntents[],
cmsHPROFILE      hProfiles[],
cmsBool          BPC[],
cmsFloat64Number AdaptationStates[],
cmsUInt32Number  dwFlags)
{
cmsPipeline* Lut = NULL;
cmsPipeline* Result;
cmsHPROFILE hProfile;
cmsMAT3 m;
cmsVEC3 off;
cmsColorSpaceSignature ColorSpaceIn, ColorSpaceOut, CurrentColorSpace;
cmsProfileClassSignature ClassSig;
cmsUInt32Number  i, Intent;
if (nProfiles == 0) return NULL;
Result = cmsPipelineAlloc(ContextID, 0, 0);
if (Result == NULL) return NULL;
CurrentColorSpace = cmsGetColorSpace(hProfiles[0]);
for (i=0; i < nProfiles; i++) {
cmsBool  lIsDeviceLink, lIsInput;
hProfile      = hProfiles[i];
ClassSig      = cmsGetDeviceClass(hProfile);
lIsDeviceLink = (ClassSig == cmsSigLinkClass || ClassSig == cmsSigAbstractClass );
if ((i == 0) && !lIsDeviceLink) {
lIsInput = TRUE;
}
else {
lIsInput      = (CurrentColorSpace != cmsSigXYZData) &&
(CurrentColorSpace != cmsSigLabData);
}
Intent        = TheIntents[i];
if (lIsInput || lIsDeviceLink) {
ColorSpaceIn    = cmsGetColorSpace(hProfile);
ColorSpaceOut   = cmsGetPCS(hProfile);
}
else {
ColorSpaceIn    = cmsGetPCS(hProfile);
ColorSpaceOut   = cmsGetColorSpace(hProfile);
}
if (!ColorSpaceIsCompatible(ColorSpaceIn, CurrentColorSpace)) {
cmsSignalError(ContextID, cmsERROR_COLORSPACE_CHECK, ""ColorSpace mismatch"");
goto Error;
}
if (lIsDeviceLink || ((ClassSig == cmsSigNamedColorClass) && (nProfiles == 1))) {
Lut = _cmsReadDevicelinkLUT(hProfile, Intent);
if (Lut == NULL) goto Error;
if (ClassSig == cmsSigAbstractClass && i > 0) {
if (!ComputeConversion(i, hProfiles, Intent, BPC[i], AdaptationStates[i], &m, &off)) goto Error;
}
else {
_cmsMAT3identity(&m);
_cmsVEC3init(&off, 0, 0, 0);
}
if (!AddConversion(Result, CurrentColorSpace, ColorSpaceIn, &m, &off)) goto Error;
}
else {
if (lIsInput) {
Lut = _cmsReadInputLUT(hProfile, Intent);
if (Lut == NULL) goto Error;
}
else {
Lut = _cmsReadOutputLUT(hProfile, Intent);
if (Lut == NULL) goto Error;
if (!ComputeConversion(i, hProfiles, Intent, BPC[i], AdaptationStates[i], &m, &off)) goto Error;
if (!AddConversion(Result, CurrentColorSpace, ColorSpaceIn, &m, &off)) goto Error;
}
}
if (!cmsPipelineCat(Result, Lut))
goto Error;
cmsPipelineFree(Lut);
CurrentColorSpace = ColorSpaceOut;
}
return Result;
Error:
cmsPipelineFree(Lut);
if (Result != NULL) cmsPipelineFree(Result);
return NULL;
cmsUNUSED_PARAMETER(dwFlags);
}","static
cmsPipeline* DefaultICCintents(cmsContext       VAR_0,
cmsUInt32Number  VAR_1,
cmsUInt32Number  VAR_2[],
cmsHPROFILE      VAR_3[],
cmsBool          VAR_4[],
cmsFloat64Number VAR_5[],
cmsUInt32Number  VAR_6)
{
cmsPipeline* VAR_7 = NULL;
cmsPipeline* VAR_8;
cmsHPROFILE VAR_9;
cmsMAT3 VAR_10;
cmsVEC3 VAR_11;
cmsColorSpaceSignature VAR_12, VAR_13, VAR_14;
cmsProfileClassSignature VAR_15;
cmsUInt32Number  VAR_16, VAR_17;
if (VAR_1 == 0) return NULL;
VAR_8 = cmsPipelineAlloc(VAR_0, 0, 0);
if (VAR_8 == NULL) return NULL;
VAR_14 = cmsGetColorSpace(VAR_3[0]);
for (VAR_16=0; VAR_16 < VAR_1; VAR_16++) {
cmsBool  VAR_18, VAR_19;
VAR_9      = VAR_3[VAR_16];
VAR_15      = cmsGetDeviceClass(VAR_9);
VAR_18 = (VAR_15 == VAR_20 || VAR_15 == VAR_21 );
if ((VAR_16 == 0) && !VAR_18) {
VAR_19 = TRUE;
}
else {
VAR_19      = (VAR_14 != VAR_22) &&
(VAR_14 != VAR_23);
}
VAR_17        = VAR_2[VAR_16];
if (VAR_19 || VAR_18) {
VAR_12    = cmsGetColorSpace(VAR_9);
VAR_13   = cmsGetPCS(VAR_9);
}
else {
VAR_12    = cmsGetPCS(VAR_9);
VAR_13   = cmsGetColorSpace(VAR_9);
}
if (!ColorSpaceIsCompatible(VAR_12, VAR_14)) {
cmsSignalError(VAR_0, VAR_24, ""ColorSpace mismatch"");
goto Error;
}
if (VAR_18 || ((VAR_15 == VAR_25) && (VAR_1 == 1))) {
VAR_7 = _cmsReadDevicelinkLUT(VAR_9, VAR_17);
if (VAR_7 == NULL) goto Error;
if (VAR_15 == VAR_21 && VAR_16 > 0) {
if (!ComputeConversion(VAR_16, VAR_3, VAR_17, VAR_4[VAR_16], VAR_5[VAR_16], &VAR_10, &VAR_11)) goto Error;
}
else {
_cmsMAT3identity(&VAR_10);
_cmsVEC3init(&VAR_11, 0, 0, 0);
}
if (!AddConversion(VAR_8, VAR_14, VAR_12, &VAR_10, &VAR_11)) goto Error;
}
else {
if (VAR_19) {
VAR_7 = _cmsReadInputLUT(VAR_9, VAR_17);
if (VAR_7 == NULL) goto Error;
}
else {
VAR_7 = _cmsReadOutputLUT(VAR_9, VAR_17);
if (VAR_7 == NULL) goto Error;
if (!ComputeConversion(VAR_16, VAR_3, VAR_17, VAR_4[VAR_16], VAR_5[VAR_16], &VAR_10, &VAR_11)) goto Error;
if (!AddConversion(VAR_8, VAR_14, VAR_12, &VAR_10, &VAR_11)) goto Error;
}
}
if (!cmsPipelineCat(VAR_8, VAR_7))
goto Error;
cmsPipelineFree(VAR_7);
VAR_14 = VAR_13;
}
return VAR_8;
Error:
cmsPipelineFree(VAR_7);
if (VAR_8 != NULL) cmsPipelineFree(VAR_8);
return NULL;
cmsUNUSED_PARAMETER(VAR_6);
}",mm2/Little-CMS/fefaaa43c382eee632ea3ad0cfa915335140e1db/cmscnvrt.c/vul/before/0.json,"static
cmsPipeline* DefaultICCintents(cmsContext       ContextID,
                               cmsUInt32Number  nProfiles,
                               cmsUInt32Number  TheIntents[],
                               cmsHPROFILE      hProfiles[],
                               cmsBool          BPC[],
                               cmsFloat64Number AdaptationStates[],
                               cmsUInt32Number  dwFlags)
{
    cmsPipeline* Lut = NULL;
    cmsPipeline* Result;
    cmsHPROFILE hProfile;
    cmsMAT3 m;
    cmsVEC3 off;
    cmsColorSpaceSignature ColorSpaceIn, ColorSpaceOut, CurrentColorSpace;
    cmsProfileClassSignature ClassSig;
    cmsUInt32Number  i, Intent;

    // For safety
    if (nProfiles == 0) return NULL;

    // Allocate an empty LUT for holding the result. 0 as channel count means 'undefined'
    Result = cmsPipelineAlloc(ContextID, 0, 0);
    if (Result == NULL) return NULL;

    CurrentColorSpace = cmsGetColorSpace(hProfiles[0]);

    for (i=0; i < nProfiles; i++) {

        cmsBool  lIsDeviceLink, lIsInput;

        hProfile      = hProfiles[i];
        ClassSig      = cmsGetDeviceClass(hProfile);
        lIsDeviceLink = (ClassSig == cmsSigLinkClass || ClassSig == cmsSigAbstractClass );

        // First profile is used as input unless devicelink or abstract
        if ((i == 0) && !lIsDeviceLink) {
            lIsInput = TRUE;
        }
        else {
          // Else use profile in the input direction if current space is not PCS
        lIsInput      = (CurrentColorSpace != cmsSigXYZData) &&
                        (CurrentColorSpace != cmsSigLabData);
        }

        Intent        = TheIntents[i];

        if (lIsInput || lIsDeviceLink) {

            ColorSpaceIn    = cmsGetColorSpace(hProfile);
            ColorSpaceOut   = cmsGetPCS(hProfile);
        }
        else {

            ColorSpaceIn    = cmsGetPCS(hProfile);
            ColorSpaceOut   = cmsGetColorSpace(hProfile);
        }

        if (!ColorSpaceIsCompatible(ColorSpaceIn, CurrentColorSpace)) {

            cmsSignalError(ContextID, cmsERROR_COLORSPACE_CHECK, ""ColorSpace mismatch"");
            goto Error;
        }

        // If devicelink is found, then no custom intent is allowed and we can
        // read the LUT to be applied. Settings don't apply here.
        if (lIsDeviceLink || ((ClassSig == cmsSigNamedColorClass) && (nProfiles == 1))) {

            // Get the involved LUT from the profile
            Lut = _cmsReadDevicelinkLUT(hProfile, Intent);
            if (Lut == NULL) goto Error;

            // What about abstract profiles?
             if (ClassSig == cmsSigAbstractClass && i > 0) {
                if (!ComputeConversion(i, hProfiles, Intent, BPC[i], AdaptationStates[i], &m, &off)) goto Error;
             }
             else {
                _cmsMAT3identity(&m);
                _cmsVEC3init(&off, 0, 0, 0);
             }


            if (!AddConversion(Result, CurrentColorSpace, ColorSpaceIn, &m, &off)) goto Error;

        }
        else {

            if (lIsInput) {
                // Input direction means non-pcs connection, so proceed like devicelinks
                Lut = _cmsReadInputLUT(hProfile, Intent);
                if (Lut == NULL) goto Error;
            }
            else {

                // Output direction means PCS connection. Intent may apply here
                Lut = _cmsReadOutputLUT(hProfile, Intent);
                if (Lut == NULL) goto Error;


                if (!ComputeConversion(i, hProfiles, Intent, BPC[i], AdaptationStates[i], &m, &off)) goto Error;
                if (!AddConversion(Result, CurrentColorSpace, ColorSpaceIn, &m, &off)) goto Error;

            }
        }

        // Concatenate to the output LUT
        if (!cmsPipelineCat(Result, Lut))
            goto Error;

        cmsPipelineFree(Lut);
        Lut = NULL;

        // Update current space
        CurrentColorSpace = ColorSpaceOut;
    }

    return Result;

Error:

    if (Lut != NULL) cmsPipelineFree(Lut);
    if (Result != NULL) cmsPipelineFree(Result);
    return NULL;

    cmsUNUSED_PARAMETER(dwFlags);
}","static
cmsPipeline* DefaultICCintents(cmsContext       VAR_0,
                               cmsUInt32Number  VAR_1,
                               cmsUInt32Number  VAR_2[],
                               cmsHPROFILE      VAR_3[],
                               cmsBool          VAR_4[],
                               cmsFloat64Number VAR_5[],
                               cmsUInt32Number  VAR_6)
{
    cmsPipeline* VAR_7 = NULL;
    cmsPipeline* VAR_8;
    cmsHPROFILE VAR_9;
    cmsMAT3 VAR_10;
    cmsVEC3 VAR_11;
    cmsColorSpaceSignature VAR_12, VAR_13, VAR_14;
    cmsProfileClassSignature VAR_15;
    cmsUInt32Number  VAR_16, VAR_17;

    /* COMMENT_0 */
    if (VAR_1 == 0) return NULL;

    /* COMMENT_1 */
    VAR_8 = cmsPipelineAlloc(VAR_0, 0, 0);
    if (VAR_8 == NULL) return NULL;

    VAR_14 = cmsGetColorSpace(VAR_3[0]);

    for (VAR_16=0; VAR_16 < VAR_1; VAR_16++) {

        cmsBool  VAR_18, VAR_19;

        VAR_9      = VAR_3[VAR_16];
        VAR_15      = cmsGetDeviceClass(VAR_9);
        VAR_18 = (VAR_15 == VAR_20 || VAR_15 == VAR_21 );

        /* COMMENT_2 */
        if ((VAR_16 == 0) && !VAR_18) {
            VAR_19 = TRUE;
        }
        else {
          /* COMMENT_3 */
        VAR_19      = (VAR_14 != VAR_22) &&
                        (VAR_14 != VAR_23);
        }

        VAR_17        = VAR_2[VAR_16];

        if (VAR_19 || VAR_18) {

            VAR_12    = cmsGetColorSpace(VAR_9);
            VAR_13   = cmsGetPCS(VAR_9);
        }
        else {

            VAR_12    = cmsGetPCS(VAR_9);
            VAR_13   = cmsGetColorSpace(VAR_9);
        }

        if (!ColorSpaceIsCompatible(VAR_12, VAR_14)) {

            cmsSignalError(VAR_0, VAR_24, ""ColorSpace mismatch"");
            goto Error;
        }

        /* COMMENT_4 */
        /* COMMENT_5 */
        if (VAR_18 || ((VAR_15 == VAR_25) && (VAR_1 == 1))) {

            /* COMMENT_6 */
            VAR_7 = _cmsReadDevicelinkLUT(VAR_9, VAR_17);
            if (VAR_7 == NULL) goto Error;

            /* COMMENT_7 */
             if (VAR_15 == VAR_21 && VAR_16 > 0) {
                if (!ComputeConversion(VAR_16, VAR_3, VAR_17, VAR_4[VAR_16], VAR_5[VAR_16], &VAR_10, &VAR_11)) goto Error;
             }
             else {
                _cmsMAT3identity(&VAR_10);
                _cmsVEC3init(&VAR_11, 0, 0, 0);
             }


            if (!AddConversion(VAR_8, VAR_14, VAR_12, &VAR_10, &VAR_11)) goto Error;

        }
        else {

            if (VAR_19) {
                /* COMMENT_8 */
                VAR_7 = _cmsReadInputLUT(VAR_9, VAR_17);
                if (VAR_7 == NULL) goto Error;
            }
            else {

                /* COMMENT_9 */
                VAR_7 = _cmsReadOutputLUT(VAR_9, VAR_17);
                if (VAR_7 == NULL) goto Error;


                if (!ComputeConversion(VAR_16, VAR_3, VAR_17, VAR_4[VAR_16], VAR_5[VAR_16], &VAR_10, &VAR_11)) goto Error;
                if (!AddConversion(VAR_8, VAR_14, VAR_12, &VAR_10, &VAR_11)) goto Error;

            }
        }

        /* COMMENT_10 */
        if (!cmsPipelineCat(VAR_8, VAR_7))
            goto Error;

        cmsPipelineFree(VAR_7);
        VAR_7 = NULL;

        /* COMMENT_11 */
        VAR_14 = VAR_13;
    }

    return VAR_8;

Error:

    if (VAR_7 != NULL) cmsPipelineFree(VAR_7);
    if (VAR_8 != NULL) cmsPipelineFree(VAR_8);
    return NULL;

    cmsUNUSED_PARAMETER(VAR_6);
}",mm2/Little-CMS/fefaaa43c382eee632ea3ad0cfa915335140e1db/cmscnvrt.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -106,7 +106,9 @@
         // Concatenate to the output LUT
         if (!cmsPipelineCat(Result, Lut))
             goto Error;
+
         cmsPipelineFree(Lut);
+        Lut = NULL;
 
         // Update current space
         CurrentColorSpace = ColorSpaceOut;
@@ -116,7 +118,7 @@
 
 Error:
 
-    cmsPipelineFree(Lut);
+    if (Lut != NULL) cmsPipelineFree(Lut);
     if (Result != NULL) cmsPipelineFree(Result);
     return NULL;
 ","{'deleted_lines': ['    cmsPipelineFree(Lut);'], 'added_lines': ['', '        Lut = NULL;', '    if (Lut != NULL) cmsPipelineFree(Lut);']}",True,Double free vulnerability in the DefaultICCintents function in cmscnvrt.c in liblcms2 in Little CMS 2.x before 2.6 allows remote attackers to execute arbitrary code via a malformed ICC profile that triggers an error in the default intent handler.,9.8,CRITICAL,3,test,2013-07-10T08:04:36Z,1
CVE-2013-7456,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,libgd,"Fixed memory overrun bug in gdImageScaleTwoPass

_gdContributionsCalc would compute a window size and then adjust
the left and right positions of the window to make a window within
that size.  However, it was storing the values in the struct *before*
it made the adjustment.  This change fixes that.",4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a,https://github.com/libgd/libgd/commit/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a,src/gd_interpolation.c,_gdContributionsCalc,"static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter)
{
double width_d;
double scale_f_d = 1.0;
const double filter_width_d = DEFAULT_BOX_RADIUS;
int windows_size;
unsigned int u;
LineContribType *res;
if (scale_d < 1.0) {
width_d = filter_width_d / scale_d;
scale_f_d = scale_d;
}  else {
width_d= filter_width_d;
}
windows_size = 2 * (int)ceil(width_d) + 1;
res = _gdContributionsAlloc(line_size, windows_size);
for (u = 0; u < line_size; u++) {
const double dCenter = (double)u / scale_d;
register int iLeft = MAX(0, (int)floor (dCenter - width_d));
int iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);
double dTotalWeight = 0.0;
int iSrc;
res->ContribRow[u].Left = iLeft;
res->ContribRow[u].Right = iRight;
if (iRight - iLeft + 1 > windows_size)  {
if (iLeft < ((int)src_size - 1 / 2))  {
iLeft++;
} else {
iRight--;
}
}
for (iSrc = iLeft; iSrc <= iRight; iSrc++) {
dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));
}
if (dTotalWeight < 0.0) {
_gdContributionsFree(res);
return NULL;
}
if (dTotalWeight > 0.0) {
for (iSrc = iLeft; iSrc <= iRight; iSrc++) {
res->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight;
}
}
}
return res;
}","static inline LineContribType *_gdContributionsCalc(unsigned int VAR_0, unsigned int VAR_1, double VAR_2,  const interpolation_method VAR_3)
{
double VAR_4;
double VAR_5 = 1.0;
const double VAR_6 = VAR_7;
int VAR_8;
unsigned int VAR_9;
LineContribType *VAR_10;
if (VAR_2 < 1.0) {
VAR_4 = VAR_6 / VAR_2;
VAR_5 = VAR_2;
}  else {
VAR_4= VAR_6;
}
VAR_8 = 2 * (int)ceil(VAR_4) + 1;
VAR_10 = _gdContributionsAlloc(VAR_0, VAR_8);
for (VAR_9 = 0; VAR_9 < VAR_0; VAR_9++) {
const double VAR_11 = (double)VAR_9 / VAR_2;
register int VAR_12 = MAX(0, (int)floor (VAR_11 - VAR_4));
int VAR_13 = MIN((int)ceil(VAR_11 + VAR_4), (int)VAR_1 - 1);
double VAR_14 = 0.0;
int VAR_15;
VAR_10->ContribRow[VAR_9].Left = VAR_12;
VAR_10->ContribRow[VAR_9].Right = VAR_13;
if (VAR_13 - VAR_12 + 1 > VAR_8)  {
if (VAR_12 < ((int)VAR_1 - 1 / 2))  {
VAR_12++;
} else {
VAR_13--;
}
}
for (VAR_15 = VAR_12; VAR_15 <= VAR_13; VAR_15++) {
VAR_14 += (VAR_10->ContribRow[VAR_9].Weights[VAR_15-VAR_12] =  VAR_5 * (*VAR_3)(VAR_5 * (VAR_11 - (double)VAR_15)));
}
if (VAR_14 < 0.0) {
_gdContributionsFree(VAR_10);
return NULL;
}
if (VAR_14 > 0.0) {
for (VAR_15 = VAR_12; VAR_15 <= VAR_13; VAR_15++) {
VAR_10->ContribRow[VAR_9].Weights[VAR_15-VAR_12] /= VAR_14;
}
}
}
return VAR_10;
}",libgd/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a/gd_interpolation.c/vul/before/0.json,"static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter)
{
	double width_d;
	double scale_f_d = 1.0;
	const double filter_width_d = DEFAULT_BOX_RADIUS;
	int windows_size;
	unsigned int u;
	LineContribType *res;

	if (scale_d < 1.0) {
		width_d = filter_width_d / scale_d;
		scale_f_d = scale_d;
	}  else {
		width_d= filter_width_d;
	}

	windows_size = 2 * (int)ceil(width_d) + 1;
	res = _gdContributionsAlloc(line_size, windows_size);

	for (u = 0; u < line_size; u++) {
		const double dCenter = (double)u / scale_d;
		/* get the significant edge points affecting the pixel */
		register int iLeft = MAX(0, (int)floor (dCenter - width_d));
		int iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);
		double dTotalWeight = 0.0;
		int iSrc;

		/* Cut edge points to fit in filter window in case of spill-off */
		if (iRight - iLeft + 1 > windows_size)  {
			if (iLeft < ((int)src_size - 1 / 2))  {
				iLeft++;
			} else {
				iRight--;
			}
		}

		res->ContribRow[u].Left = iLeft;
		res->ContribRow[u].Right = iRight;

		for (iSrc = iLeft; iSrc <= iRight; iSrc++) {
			dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));
		}

		if (dTotalWeight < 0.0) {
			_gdContributionsFree(res);
			return NULL;
		}

		if (dTotalWeight > 0.0) {
			for (iSrc = iLeft; iSrc <= iRight; iSrc++) {
				res->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight;
			}
		}
	}
	return res;
}","static inline LineContribType *_gdContributionsCalc(unsigned int VAR_0, unsigned int VAR_1, double VAR_2,  const interpolation_method VAR_3)
{
	double VAR_4;
	double VAR_5 = 1.0;
	const double VAR_6 = VAR_7;
	int VAR_8;
	unsigned int VAR_9;
	LineContribType *VAR_10;

	if (VAR_2 < 1.0) {
		VAR_4 = VAR_6 / VAR_2;
		VAR_5 = VAR_2;
	}  else {
		VAR_4= VAR_6;
	}

	VAR_8 = 2 * (int)ceil(VAR_4) + 1;
	VAR_10 = _gdContributionsAlloc(VAR_0, VAR_8);

	for (VAR_9 = 0; VAR_9 < VAR_0; VAR_9++) {
		const double VAR_11 = (double)VAR_9 / VAR_2;
		/* COMMENT_0 */
		register int VAR_12 = MAX(0, (int)floor (VAR_11 - VAR_4));
		int VAR_13 = MIN((int)ceil(VAR_11 + VAR_4), (int)VAR_1 - 1);
		double VAR_14 = 0.0;
		int VAR_15;

		/* COMMENT_1 */
		if (VAR_13 - VAR_12 + 1 > VAR_8)  {
			if (VAR_12 < ((int)VAR_1 - 1 / 2))  {
				VAR_12++;
			} else {
				VAR_13--;
			}
		}

		VAR_10->ContribRow[VAR_9].Left = VAR_12;
		VAR_10->ContribRow[VAR_9].Right = VAR_13;

		for (VAR_15 = VAR_12; VAR_15 <= VAR_13; VAR_15++) {
			VAR_14 += (VAR_10->ContribRow[VAR_9].Weights[VAR_15-VAR_12] =  VAR_5 * (*VAR_3)(VAR_5 * (VAR_11 - (double)VAR_15)));
		}

		if (VAR_14 < 0.0) {
			_gdContributionsFree(VAR_10);
			return NULL;
		}

		if (VAR_14 > 0.0) {
			for (VAR_15 = VAR_12; VAR_15 <= VAR_13; VAR_15++) {
				VAR_10->ContribRow[VAR_9].Weights[VAR_15-VAR_12] /= VAR_14;
			}
		}
	}
	return VAR_10;
}",libgd/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a/gd_interpolation.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -25,9 +25,6 @@
 		double dTotalWeight = 0.0;
 		int iSrc;
 
-		res->ContribRow[u].Left = iLeft;
-		res->ContribRow[u].Right = iRight;
-
 		/* Cut edge points to fit in filter window in case of spill-off */
 		if (iRight - iLeft + 1 > windows_size)  {
 			if (iLeft < ((int)src_size - 1 / 2))  {
@@ -36,6 +33,9 @@
 				iRight--;
 			}
 		}
+
+		res->ContribRow[u].Left = iLeft;
+		res->ContribRow[u].Right = iRight;
 
 		for (iSrc = iLeft; iSrc <= iRight; iSrc++) {
 			dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));","{'deleted_lines': ['\t\tres->ContribRow[u].Left = iLeft;', '\t\tres->ContribRow[u].Right = iRight;', ''], 'added_lines': ['', '\t\tres->ContribRow[u].Left = iLeft;', '\t\tres->ContribRow[u].Right = iRight;']}",True,"gd_interpolation.c in the GD Graphics Library (aka libgd) before 2.1.1, as used in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7, allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted image that is mishandled by the imagescale function.",7.6,HIGH,2,test,2013-09-23T22:03:08Z,1
CVE-2015-5239,['CWE-835'],AV:N/AC:L/Au:S/C:N/I:N/A:P,0,qemu,"ui/vnc: limit client_cut_text msg payload size

currently a malicious client could define a payload
size of 2^32 - 1 bytes and send up to that size of
data to the vnc server. The server would allocated
that amount of memory which could easily create an
out of memory condition.

This patch limits the payload size to 1MB max.

Please note that client_cut_text messages are currently
silently ignored.

Signed-off-by: Peter Lieven <pl@kamp.de>
Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>",f9a70e79391f6d7c2a912d785239ee8effc1922d,https://github.com/qemu/qemu/commit/f9a70e79391f6d7c2a912d785239ee8effc1922d,ui/vnc.c,protocol_client_msg,"static int protocol_client_msg(VncState *vs, uint8_t *data, size_t len)
{
int i;
uint16_t limit;
VncDisplay *vd = vs->vd;
if (data[0] > 3) {
update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);
}
switch (data[0]) {
case VNC_MSG_CLIENT_SET_PIXEL_FORMAT:
if (len == 1)
return 20;
set_pixel_format(vs, read_u8(data, 4), read_u8(data, 5),
read_u8(data, 6), read_u8(data, 7),
read_u16(data, 8), read_u16(data, 10),
read_u16(data, 12), read_u8(data, 14),
read_u8(data, 15), read_u8(data, 16));
break;
case VNC_MSG_CLIENT_SET_ENCODINGS:
if (len == 1)
return 4;
if (len == 4) {
limit = read_u16(data, 2);
if (limit > 0)
return 4 + (limit * 4);
} else
limit = read_u16(data, 2);
for (i = 0; i < limit; i++) {
int32_t val = read_s32(data, 4 + (i * 4));
memcpy(data + 4 + (i * 4), &val, sizeof(val));
}
set_encodings(vs, (int32_t *)(data + 4), limit);
break;
case VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST:
if (len == 1)
return 10;
framebuffer_update_request(vs,
read_u8(data, 1), read_u16(data, 2), read_u16(data, 4),
read_u16(data, 6), read_u16(data, 8));
break;
case VNC_MSG_CLIENT_KEY_EVENT:
if (len == 1)
return 8;
key_event(vs, read_u8(data, 1), read_u32(data, 4));
break;
case VNC_MSG_CLIENT_POINTER_EVENT:
if (len == 1)
return 6;
pointer_event(vs, read_u8(data, 1), read_u16(data, 2), read_u16(data, 4));
break;
case VNC_MSG_CLIENT_CUT_TEXT:
if (len == 1)
return 8;
if (len == 8) {
uint32_t dlen = read_u32(data, 4);
if (dlen > 0)
return 8 + dlen;
}
client_cut_text(vs, read_u32(data, 4), data + 8);
break;
case VNC_MSG_CLIENT_QEMU:
if (len == 1)
return 2;
switch (read_u8(data, 1)) {
case VNC_MSG_CLIENT_QEMU_EXT_KEY_EVENT:
if (len == 2)
return 12;
ext_key_event(vs, read_u16(data, 2),
read_u32(data, 4), read_u32(data, 8));
break;
case VNC_MSG_CLIENT_QEMU_AUDIO:
if (len == 2)
return 4;
switch (read_u16 (data, 2)) {
case VNC_MSG_CLIENT_QEMU_AUDIO_ENABLE:
audio_add(vs);
break;
case VNC_MSG_CLIENT_QEMU_AUDIO_DISABLE:
audio_del(vs);
break;
case VNC_MSG_CLIENT_QEMU_AUDIO_SET_FORMAT:
if (len == 4)
return 10;
switch (read_u8(data, 4)) {
case 0: vs->as.fmt = AUD_FMT_U8; break;
case 1: vs->as.fmt = AUD_FMT_S8; break;
case 2: vs->as.fmt = AUD_FMT_U16; break;
case 3: vs->as.fmt = AUD_FMT_S16; break;
case 4: vs->as.fmt = AUD_FMT_U32; break;
case 5: vs->as.fmt = AUD_FMT_S32; break;
default:
printf(""Invalid audio format %d\n"", read_u8(data, 4));
vnc_client_error(vs);
break;
}
vs->as.nchannels = read_u8(data, 5);
if (vs->as.nchannels != 1 && vs->as.nchannels != 2) {
printf(""Invalid audio channel coount %d\n"",
read_u8(data, 5));
vnc_client_error(vs);
break;
}
vs->as.freq = read_u32(data, 6);
break;
default:
printf (""Invalid audio message %d\n"", read_u8(data, 4));
vnc_client_error(vs);
break;
}
break;
default:
printf(""Msg: %d\n"", read_u16(data, 0));
vnc_client_error(vs);
break;
}
break;
default:
printf(""Msg: %d\n"", data[0]);
vnc_client_error(vs);
break;
}
vnc_read_when(vs, protocol_client_msg, 1);
return 0;
}","static int protocol_client_msg(VncState *VAR_0, uint8_t *VAR_1, size_t VAR_2)
{
int VAR_3;
uint16_t VAR_4;
VncDisplay *VAR_5 = VAR_0->vd;
if (VAR_1[0] > 3) {
update_displaychangelistener(&VAR_5->dcl, VAR_6);
}
switch (VAR_1[0]) {
case VAR_7:
if (VAR_2 == 1)
return 20;
set_pixel_format(VAR_0, read_u8(VAR_1, 4), read_u8(VAR_1, 5),
read_u8(VAR_1, 6), read_u8(VAR_1, 7),
read_u16(VAR_1, 8), read_u16(VAR_1, 10),
read_u16(VAR_1, 12), read_u8(VAR_1, 14),
read_u8(VAR_1, 15), read_u8(VAR_1, 16));
break;
case VAR_8:
if (VAR_2 == 1)
return 4;
if (VAR_2 == 4) {
VAR_4 = read_u16(VAR_1, 2);
if (VAR_4 > 0)
return 4 + (VAR_4 * 4);
} else
VAR_4 = read_u16(VAR_1, 2);
for (VAR_3 = 0; VAR_3 < VAR_4; VAR_3++) {
int32_t VAR_9 = read_s32(VAR_1, 4 + (VAR_3 * 4));
memcpy(VAR_1 + 4 + (VAR_3 * 4), &VAR_9, sizeof(VAR_9));
}
set_encodings(VAR_0, (int32_t *)(VAR_1 + 4), VAR_4);
break;
case VAR_10:
if (VAR_2 == 1)
return 10;
framebuffer_update_request(VAR_0,
read_u8(VAR_1, 1), read_u16(VAR_1, 2), read_u16(VAR_1, 4),
read_u16(VAR_1, 6), read_u16(VAR_1, 8));
break;
case VAR_11:
if (VAR_2 == 1)
return 8;
key_event(VAR_0, read_u8(VAR_1, 1), read_u32(VAR_1, 4));
break;
case VAR_12:
if (VAR_2 == 1)
return 6;
pointer_event(VAR_0, read_u8(VAR_1, 1), read_u16(VAR_1, 2), read_u16(VAR_1, 4));
break;
case VAR_13:
if (VAR_2 == 1)
return 8;
if (VAR_2 == 8) {
uint32_t VAR_14 = read_u32(VAR_1, 4);
if (VAR_14 > 0)
return 8 + VAR_14;
}
client_cut_text(VAR_0, read_u32(VAR_1, 4), VAR_1 + 8);
break;
case VAR_15:
if (VAR_2 == 1)
return 2;
switch (read_u8(VAR_1, 1)) {
case VAR_16:
if (VAR_2 == 2)
return 12;
ext_key_event(VAR_0, read_u16(VAR_1, 2),
read_u32(VAR_1, 4), read_u32(VAR_1, 8));
break;
case VAR_17:
if (VAR_2 == 2)
return 4;
switch (read_u16 (VAR_1, 2)) {
case VAR_18:
audio_add(VAR_0);
break;
case VAR_19:
audio_del(VAR_0);
break;
case VAR_20:
if (VAR_2 == 4)
return 10;
switch (read_u8(VAR_1, 4)) {
case 0: VAR_0->as.fmt = VAR_21; break;
case 1: VAR_0->as.fmt = VAR_22; break;
case 2: VAR_0->as.fmt = VAR_23; break;
case 3: VAR_0->as.fmt = VAR_24; break;
case 4: VAR_0->as.fmt = VAR_25; break;
case 5: VAR_0->as.fmt = VAR_26; break;
default:
printf(""Invalid audio format %d\n"", read_u8(VAR_1, 4));
vnc_client_error(VAR_0);
break;
}
VAR_0->as.nchannels = read_u8(VAR_1, 5);
if (VAR_0->as.nchannels != 1 && VAR_0->as.nchannels != 2) {
printf(""Invalid audio channel coount %d\n"",
read_u8(VAR_1, 5));
vnc_client_error(VAR_0);
break;
}
VAR_0->as.freq = read_u32(VAR_1, 6);
break;
default:
printf (""Invalid audio message %d\n"", read_u8(VAR_1, 4));
vnc_client_error(VAR_0);
break;
}
break;
default:
printf(""Msg: %d\n"", read_u16(VAR_1, 0));
vnc_client_error(VAR_0);
break;
}
break;
default:
printf(""Msg: %d\n"", VAR_1[0]);
vnc_client_error(VAR_0);
break;
}
vnc_read_when(VAR_0, VAR_27, 1);
return 0;
}",qemu/f9a70e79391f6d7c2a912d785239ee8effc1922d/vnc.c/vul/before/0.json,"static int protocol_client_msg(VncState *vs, uint8_t *data, size_t len)
{
    int i;
    uint16_t limit;
    VncDisplay *vd = vs->vd;

    if (data[0] > 3) {
        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);
    }

    switch (data[0]) {
    case VNC_MSG_CLIENT_SET_PIXEL_FORMAT:
        if (len == 1)
            return 20;

        set_pixel_format(vs, read_u8(data, 4), read_u8(data, 5),
                         read_u8(data, 6), read_u8(data, 7),
                         read_u16(data, 8), read_u16(data, 10),
                         read_u16(data, 12), read_u8(data, 14),
                         read_u8(data, 15), read_u8(data, 16));
        break;
    case VNC_MSG_CLIENT_SET_ENCODINGS:
        if (len == 1)
            return 4;

        if (len == 4) {
            limit = read_u16(data, 2);
            if (limit > 0)
                return 4 + (limit * 4);
        } else
            limit = read_u16(data, 2);

        for (i = 0; i < limit; i++) {
            int32_t val = read_s32(data, 4 + (i * 4));
            memcpy(data + 4 + (i * 4), &val, sizeof(val));
        }

        set_encodings(vs, (int32_t *)(data + 4), limit);
        break;
    case VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST:
        if (len == 1)
            return 10;

        framebuffer_update_request(vs,
                                   read_u8(data, 1), read_u16(data, 2), read_u16(data, 4),
                                   read_u16(data, 6), read_u16(data, 8));
        break;
    case VNC_MSG_CLIENT_KEY_EVENT:
        if (len == 1)
            return 8;

        key_event(vs, read_u8(data, 1), read_u32(data, 4));
        break;
    case VNC_MSG_CLIENT_POINTER_EVENT:
        if (len == 1)
            return 6;

        pointer_event(vs, read_u8(data, 1), read_u16(data, 2), read_u16(data, 4));
        break;
    case VNC_MSG_CLIENT_CUT_TEXT:
        if (len == 1) {
            return 8;
        }
        if (len == 8) {
            uint32_t dlen = read_u32(data, 4);
            if (dlen > (1 << 20)) {
                error_report(""vnc: client_cut_text msg payload has %u bytes""
                             "" which exceeds our limit of 1MB."", dlen);
                vnc_client_error(vs);
                break;
            }
            if (dlen > 0) {
                return 8 + dlen;
            }
        }

        client_cut_text(vs, read_u32(data, 4), data + 8);
        break;
    case VNC_MSG_CLIENT_QEMU:
        if (len == 1)
            return 2;

        switch (read_u8(data, 1)) {
        case VNC_MSG_CLIENT_QEMU_EXT_KEY_EVENT:
            if (len == 2)
                return 12;

            ext_key_event(vs, read_u16(data, 2),
                          read_u32(data, 4), read_u32(data, 8));
            break;
        case VNC_MSG_CLIENT_QEMU_AUDIO:
            if (len == 2)
                return 4;

            switch (read_u16 (data, 2)) {
            case VNC_MSG_CLIENT_QEMU_AUDIO_ENABLE:
                audio_add(vs);
                break;
            case VNC_MSG_CLIENT_QEMU_AUDIO_DISABLE:
                audio_del(vs);
                break;
            case VNC_MSG_CLIENT_QEMU_AUDIO_SET_FORMAT:
                if (len == 4)
                    return 10;
                switch (read_u8(data, 4)) {
                case 0: vs->as.fmt = AUD_FMT_U8; break;
                case 1: vs->as.fmt = AUD_FMT_S8; break;
                case 2: vs->as.fmt = AUD_FMT_U16; break;
                case 3: vs->as.fmt = AUD_FMT_S16; break;
                case 4: vs->as.fmt = AUD_FMT_U32; break;
                case 5: vs->as.fmt = AUD_FMT_S32; break;
                default:
                    printf(""Invalid audio format %d\n"", read_u8(data, 4));
                    vnc_client_error(vs);
                    break;
                }
                vs->as.nchannels = read_u8(data, 5);
                if (vs->as.nchannels != 1 && vs->as.nchannels != 2) {
                    printf(""Invalid audio channel coount %d\n"",
                           read_u8(data, 5));
                    vnc_client_error(vs);
                    break;
                }
                vs->as.freq = read_u32(data, 6);
                break;
            default:
                printf (""Invalid audio message %d\n"", read_u8(data, 4));
                vnc_client_error(vs);
                break;
            }
            break;

        default:
            printf(""Msg: %d\n"", read_u16(data, 0));
            vnc_client_error(vs);
            break;
        }
        break;
    default:
        printf(""Msg: %d\n"", data[0]);
        vnc_client_error(vs);
        break;
    }

    vnc_read_when(vs, protocol_client_msg, 1);
    return 0;
}","static int protocol_client_msg(VncState *VAR_0, uint8_t *VAR_1, size_t VAR_2)
{
    int VAR_3;
    uint16_t VAR_4;
    VncDisplay *VAR_5 = VAR_0->vd;

    if (VAR_1[0] > 3) {
        update_displaychangelistener(&VAR_5->dcl, VAR_6);
    }

    switch (VAR_1[0]) {
    case VAR_7:
        if (VAR_2 == 1)
            return 20;

        set_pixel_format(VAR_0, read_u8(VAR_1, 4), read_u8(VAR_1, 5),
                         read_u8(VAR_1, 6), read_u8(VAR_1, 7),
                         read_u16(VAR_1, 8), read_u16(VAR_1, 10),
                         read_u16(VAR_1, 12), read_u8(VAR_1, 14),
                         read_u8(VAR_1, 15), read_u8(VAR_1, 16));
        break;
    case VAR_8:
        if (VAR_2 == 1)
            return 4;

        if (VAR_2 == 4) {
            VAR_4 = read_u16(VAR_1, 2);
            if (VAR_4 > 0)
                return 4 + (VAR_4 * 4);
        } else
            VAR_4 = read_u16(VAR_1, 2);

        for (VAR_3 = 0; VAR_3 < VAR_4; VAR_3++) {
            int32_t VAR_9 = read_s32(VAR_1, 4 + (VAR_3 * 4));
            memcpy(VAR_1 + 4 + (VAR_3 * 4), &VAR_9, sizeof(VAR_9));
        }

        set_encodings(VAR_0, (int32_t *)(VAR_1 + 4), VAR_4);
        break;
    case VAR_10:
        if (VAR_2 == 1)
            return 10;

        framebuffer_update_request(VAR_0,
                                   read_u8(VAR_1, 1), read_u16(VAR_1, 2), read_u16(VAR_1, 4),
                                   read_u16(VAR_1, 6), read_u16(VAR_1, 8));
        break;
    case VAR_11:
        if (VAR_2 == 1)
            return 8;

        key_event(VAR_0, read_u8(VAR_1, 1), read_u32(VAR_1, 4));
        break;
    case VAR_12:
        if (VAR_2 == 1)
            return 6;

        pointer_event(VAR_0, read_u8(VAR_1, 1), read_u16(VAR_1, 2), read_u16(VAR_1, 4));
        break;
    case VAR_13:
        if (VAR_2 == 1) {
            return 8;
        }
        if (VAR_2 == 8) {
            uint32_t VAR_14 = read_u32(VAR_1, 4);
            if (VAR_14 > (1 << 20)) {
                error_report(""vnc: client_cut_text msg payload has %u bytes""
                             "" which exceeds our limit of 1MB."", VAR_14);
                vnc_client_error(VAR_0);
                break;
            }
            if (VAR_14 > 0) {
                return 8 + VAR_14;
            }
        }

        client_cut_text(VAR_0, read_u32(VAR_1, 4), VAR_1 + 8);
        break;
    case VAR_15:
        if (VAR_2 == 1)
            return 2;

        switch (read_u8(VAR_1, 1)) {
        case VAR_16:
            if (VAR_2 == 2)
                return 12;

            ext_key_event(VAR_0, read_u16(VAR_1, 2),
                          read_u32(VAR_1, 4), read_u32(VAR_1, 8));
            break;
        case VAR_17:
            if (VAR_2 == 2)
                return 4;

            switch (read_u16 (VAR_1, 2)) {
            case VAR_18:
                audio_add(VAR_0);
                break;
            case VAR_19:
                audio_del(VAR_0);
                break;
            case VAR_20:
                if (VAR_2 == 4)
                    return 10;
                switch (read_u8(VAR_1, 4)) {
                case 0: VAR_0->as.fmt = VAR_21; break;
                case 1: VAR_0->as.fmt = VAR_22; break;
                case 2: VAR_0->as.fmt = VAR_23; break;
                case 3: VAR_0->as.fmt = VAR_24; break;
                case 4: VAR_0->as.fmt = VAR_25; break;
                case 5: VAR_0->as.fmt = VAR_26; break;
                default:
                    printf(""Invalid audio format %d\n"", read_u8(VAR_1, 4));
                    vnc_client_error(VAR_0);
                    break;
                }
                VAR_0->as.nchannels = read_u8(VAR_1, 5);
                if (VAR_0->as.nchannels != 1 && VAR_0->as.nchannels != 2) {
                    printf(""Invalid audio channel coount %d\n"",
                           read_u8(VAR_1, 5));
                    vnc_client_error(VAR_0);
                    break;
                }
                VAR_0->as.freq = read_u32(VAR_1, 6);
                break;
            default:
                printf (""Invalid audio message %d\n"", read_u8(VAR_1, 4));
                vnc_client_error(VAR_0);
                break;
            }
            break;

        default:
            printf(""Msg: %d\n"", read_u16(VAR_1, 0));
            vnc_client_error(VAR_0);
            break;
        }
        break;
    default:
        printf(""Msg: %d\n"", VAR_1[0]);
        vnc_client_error(VAR_0);
        break;
    }

    vnc_read_when(VAR_0, VAR_27, 1);
    return 0;
}",qemu/f9a70e79391f6d7c2a912d785239ee8effc1922d/vnc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -58,13 +58,20 @@
         pointer_event(vs, read_u8(data, 1), read_u16(data, 2), read_u16(data, 4));
         break;
     case VNC_MSG_CLIENT_CUT_TEXT:
-        if (len == 1)
+        if (len == 1) {
             return 8;
-
+        }
         if (len == 8) {
             uint32_t dlen = read_u32(data, 4);
-            if (dlen > 0)
+            if (dlen > (1 << 20)) {
+                error_report(""vnc: client_cut_text msg payload has %u bytes""
+                             "" which exceeds our limit of 1MB."", dlen);
+                vnc_client_error(vs);
+                break;
+            }
+            if (dlen > 0) {
                 return 8 + dlen;
+            }
         }
 
         client_cut_text(vs, read_u32(data, 4), data + 8);","{'deleted_lines': ['        if (len == 1)', '', '            if (dlen > 0)'], 'added_lines': ['        if (len == 1) {', '        }', '            if (dlen > (1 << 20)) {', '                error_report(""vnc: client_cut_text msg payload has %u bytes""', '                             "" which exceeds our limit of 1MB."", dlen);', '                vnc_client_error(vs);', '                break;', '            }', '            if (dlen > 0) {', '            }']}",True,"Integer overflow in the VNC display driver in QEMU before 2.1.0 allows attachers to cause a denial of service (process crash) via a CLIENT_CUT_TEXT message, which triggers an infinite loop.",6.5,MEDIUM,1,test,2014-06-30T08:07:54Z,1
CVE-2016-6129,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,libtom/libtomcrypt,rsa_verify_hash: fix possible bleichenbacher signature attack,5eb9743410ce4657e9d54fef26a2ee31a1b5dd0,https://github.com/libtom/libtomcrypt/commit/5eb9743410ce4657e9d54fef26a2ee31a1b5dd09,src/pk/rsa/rsa_verify_hash.c,rsa_verify_hash_ex,"int rsa_verify_hash_ex(const unsigned char *sig,      unsigned long siglen,
const unsigned char *hash,     unsigned long hashlen,
int            padding,
int            hash_idx, unsigned long saltlen,
int           *stat,     rsa_key      *key)
{
unsigned long modulus_bitlen, modulus_bytelen, x;
int           err;
unsigned char *tmpbuf;
LTC_ARGCHK(hash  != NULL);
LTC_ARGCHK(sig   != NULL);
LTC_ARGCHK(stat  != NULL);
LTC_ARGCHK(key   != NULL);
*stat = 0;
if ((padding != LTC_PKCS_1_V1_5) &&
(padding != LTC_PKCS_1_PSS)) {
return CRYPT_PK_INVALID_PADDING;
}
if (padding == LTC_PKCS_1_PSS) {
if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {
return err;
}
}
modulus_bitlen = mp_count_bits( (key->N));
modulus_bytelen = mp_unsigned_bin_size( (key->N));
if (modulus_bytelen != siglen) {
return CRYPT_INVALID_PACKET;
}
tmpbuf = XMALLOC(siglen);
if (tmpbuf == NULL) {
return CRYPT_MEM;
}
x = siglen;
if ((err = ltc_mp.rsa_me(sig, siglen, tmpbuf, &x, PK_PUBLIC, key)) != CRYPT_OK) {
XFREE(tmpbuf);
return err;
}
if (x != siglen) {
XFREE(tmpbuf);
return CRYPT_INVALID_PACKET;
}
if (padding == LTC_PKCS_1_PSS) {
if(modulus_bitlen%8 == 1){
err = pkcs_1_pss_decode(hash, hashlen, tmpbuf+1, x-1, saltlen, hash_idx, modulus_bitlen, stat);
}
else{
err = pkcs_1_pss_decode(hash, hashlen, tmpbuf, x, saltlen, hash_idx, modulus_bitlen, stat);
}
} else {
unsigned char *out;
unsigned long outlen, loid[16];
int           decoded;
ltc_asn1_list digestinfo[2], siginfo[2];
if (hash_descriptor[hash_idx].OIDlen == 0) {
err = CRYPT_INVALID_ARG;
goto bail_2;
}
outlen = ((modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0)) - 3;
out    = XMALLOC(outlen);
if (out == NULL) {
err = CRYPT_MEM;
goto bail_2;
}
if ((err = pkcs_1_v1_5_decode(tmpbuf, x, LTC_PKCS_1_EMSA, modulus_bitlen, out, &outlen, &decoded)) != CRYPT_OK) {
XFREE(out);
goto bail_2;
}
LTC_SET_ASN1(digestinfo, 0, LTC_ASN1_OBJECT_IDENTIFIER, loid, sizeof(loid)/sizeof(loid[0]));
LTC_SET_ASN1(digestinfo, 1, LTC_ASN1_NULL,              NULL,                          0);
LTC_SET_ASN1(siginfo,    0, LTC_ASN1_SEQUENCE,          digestinfo,                    2);
LTC_SET_ASN1(siginfo,    1, LTC_ASN1_OCTET_STRING,      tmpbuf,                        siglen);
if ((err = der_decode_sequence(out, outlen, siginfo, 2)) != CRYPT_OK) {
XFREE(out);
goto bail_2;
}
if ((digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&
(XMEMCMP(digestinfo[0].data, hash_descriptor[hash_idx].OID, sizeof(unsigned long) * hash_descriptor[hash_idx].OIDlen) == 0) &&
(siginfo[1].size == hashlen) &&
(XMEMCMP(siginfo[1].data, hash, hashlen) == 0)) {
*stat = 1;
}
#ifdef LTC_CLEAN_STACK
zeromem(out, outlen);
#endif
XFREE(out);
}
bail_2:
#ifdef LTC_CLEAN_STACK
zeromem(tmpbuf, siglen);
#endif
XFREE(tmpbuf);
return err;
}","int rsa_verify_hash_ex(const unsigned char *VAR_0,      unsigned long VAR_1,
const unsigned char *VAR_2,     unsigned long VAR_3,
int            VAR_4,
int            VAR_5, unsigned long VAR_6,
int           *VAR_7,     rsa_key      *VAR_8)
{
unsigned long VAR_9, VAR_10, VAR_11;
int           VAR_12;
unsigned char *VAR_13;
LTC_ARGCHK(VAR_2  != NULL);
LTC_ARGCHK(VAR_0   != NULL);
LTC_ARGCHK(VAR_7  != NULL);
LTC_ARGCHK(VAR_8   != NULL);
*VAR_7 = 0;
if ((VAR_4 != VAR_14) &&
(VAR_4 != VAR_15)) {
return VAR_16;
}
if (VAR_4 == VAR_15) {
if ((VAR_12 = hash_is_valid(VAR_5)) != VAR_17) {
return VAR_12;
}
}
VAR_9 = mp_count_bits( (VAR_8->N));
VAR_10 = mp_unsigned_bin_size( (VAR_8->N));
if (VAR_10 != VAR_1) {
return VAR_18;
}
VAR_13 = XMALLOC(VAR_1);
if (VAR_13 == NULL) {
return VAR_19;
}
VAR_11 = VAR_1;
if ((VAR_12 = VAR_20.rsa_me(VAR_0, VAR_1, VAR_13, &VAR_11, VAR_21, VAR_8)) != VAR_17) {
XFREE(VAR_13);
return VAR_12;
}
if (VAR_11 != VAR_1) {
XFREE(VAR_13);
return VAR_18;
}
if (VAR_4 == VAR_15) {
if(VAR_9%8 == 1){
VAR_12 = pkcs_1_pss_decode(VAR_2, VAR_3, VAR_13+1, VAR_11-1, VAR_6, VAR_5, VAR_9, VAR_7);
}
else{
VAR_12 = pkcs_1_pss_decode(VAR_2, VAR_3, VAR_13, VAR_11, VAR_6, VAR_5, VAR_9, VAR_7);
}
} else {
unsigned char *VAR_22;
unsigned long VAR_23, VAR_24[16];
int           VAR_25;
ltc_asn1_list VAR_26[2], VAR_27[2];
if (VAR_28[VAR_5].OIDlen == 0) {
VAR_12 = VAR_29;
goto bail_2;
}
VAR_23 = ((VAR_9 >> 3) + (VAR_9 & 7 ? 1 : 0)) - 3;
VAR_22    = XMALLOC(VAR_23);
if (VAR_22 == NULL) {
VAR_12 = VAR_19;
goto bail_2;
}
if ((VAR_12 = pkcs_1_v1_5_decode(VAR_13, VAR_11, VAR_30, VAR_9, VAR_22, &VAR_23, &VAR_25)) != VAR_17) {
XFREE(VAR_22);
goto bail_2;
}
LTC_SET_ASN1(VAR_26, 0, VAR_31, VAR_24, sizeof(loid)/sizeof(loid[0]));
LTC_SET_ASN1(VAR_26, 1, VAR_32,              NULL,                          0);
LTC_SET_ASN1(VAR_27,    0, VAR_33,          VAR_26,                    2);
LTC_SET_ASN1(VAR_27,    1, VAR_34,      VAR_13,                        VAR_1);
if ((VAR_12 = der_decode_sequence(VAR_22, VAR_23, VAR_27, 2)) != VAR_17) {
XFREE(VAR_22);
goto bail_2;
}
if ((VAR_26[0].size == VAR_28[VAR_5].OIDlen) &&
(XMEMCMP(VAR_26[0].data, VAR_28[VAR_5].OID, sizeof(unsigned long) * VAR_28[VAR_5].OIDlen) == 0) &&
(VAR_27[1].size == VAR_3) &&
(XMEMCMP(VAR_27[1].data, VAR_2, VAR_3) == 0)) {
*VAR_7 = 1;
}
#ifdef VAR_35
zeromem(VAR_22, VAR_23);
#endif
XFREE(VAR_22);
}
bail_2:
#ifdef VAR_35
zeromem(VAR_13, VAR_1);
#endif
XFREE(VAR_13);
return VAR_12;
}",libtom/libtomcrypt/5eb9743410ce4657e9d54fef26a2ee31a1b5dd0/rsa_verify_hash.c/vul/before/0.json,"int rsa_verify_hash_ex(const unsigned char *sig,      unsigned long siglen,
                       const unsigned char *hash,     unsigned long hashlen,
                             int            padding,
                             int            hash_idx, unsigned long saltlen,
                             int           *stat,     rsa_key      *key)
{
  unsigned long modulus_bitlen, modulus_bytelen, x;
  int           err;
  unsigned char *tmpbuf;

  LTC_ARGCHK(hash  != NULL);
  LTC_ARGCHK(sig   != NULL);
  LTC_ARGCHK(stat  != NULL);
  LTC_ARGCHK(key   != NULL);

  /* default to invalid */
  *stat = 0;

  /* valid padding? */

  if ((padding != LTC_PKCS_1_V1_5) &&
      (padding != LTC_PKCS_1_PSS)) {
    return CRYPT_PK_INVALID_PADDING;
  }

  if (padding == LTC_PKCS_1_PSS) {
    /* valid hash ? */
    if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {
       return err;
    }
  }

  /* get modulus len in bits */
  modulus_bitlen = mp_count_bits( (key->N));

  /* outlen must be at least the size of the modulus */
  modulus_bytelen = mp_unsigned_bin_size( (key->N));
  if (modulus_bytelen != siglen) {
     return CRYPT_INVALID_PACKET;
  }

  /* allocate temp buffer for decoded sig */
  tmpbuf = XMALLOC(siglen);
  if (tmpbuf == NULL) {
     return CRYPT_MEM;
  }

  /* RSA decode it  */
  x = siglen;
  if ((err = ltc_mp.rsa_me(sig, siglen, tmpbuf, &x, PK_PUBLIC, key)) != CRYPT_OK) {
     XFREE(tmpbuf);
     return err;
  }

  /* make sure the output is the right size */
  if (x != siglen) {
     XFREE(tmpbuf);
     return CRYPT_INVALID_PACKET;
  }

  if (padding == LTC_PKCS_1_PSS) {
    /* PSS decode and verify it */

    if(modulus_bitlen%8 == 1){
      err = pkcs_1_pss_decode(hash, hashlen, tmpbuf+1, x-1, saltlen, hash_idx, modulus_bitlen, stat);
    }
    else{
      err = pkcs_1_pss_decode(hash, hashlen, tmpbuf, x, saltlen, hash_idx, modulus_bitlen, stat);
    }

  } else {
    /* PKCS #1 v1.5 decode it */
    unsigned char *out;
    unsigned long outlen, loid[16], reallen;
    int           decoded;
    ltc_asn1_list digestinfo[2], siginfo[2];

    /* not all hashes have OIDs... so sad */
    if (hash_descriptor[hash_idx].OIDlen == 0) {
       err = CRYPT_INVALID_ARG;
       goto bail_2;
    }

    /* allocate temp buffer for decoded hash */
    outlen = ((modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0)) - 3;
    out    = XMALLOC(outlen);
    if (out == NULL) {
      err = CRYPT_MEM;
      goto bail_2;
    }

    if ((err = pkcs_1_v1_5_decode(tmpbuf, x, LTC_PKCS_1_EMSA, modulus_bitlen, out, &outlen, &decoded)) != CRYPT_OK) {
      XFREE(out);
      goto bail_2;
    }

    /* now we must decode out[0...outlen-1] using ASN.1, test the OID and then test the hash */
    /* construct the SEQUENCE
      SEQUENCE {
         SEQUENCE {hashoid OID
                   blah    NULL
         }
         hash    OCTET STRING
      }
   */
    LTC_SET_ASN1(digestinfo, 0, LTC_ASN1_OBJECT_IDENTIFIER, loid, sizeof(loid)/sizeof(loid[0]));
    LTC_SET_ASN1(digestinfo, 1, LTC_ASN1_NULL,              NULL,                          0);
    LTC_SET_ASN1(siginfo,    0, LTC_ASN1_SEQUENCE,          digestinfo,                    2);
    LTC_SET_ASN1(siginfo,    1, LTC_ASN1_OCTET_STRING,      tmpbuf,                        siglen);

    if ((err = der_decode_sequence(out, outlen, siginfo, 2)) != CRYPT_OK) {
       XFREE(out);
       goto bail_2;
    }

    if ((err = der_length_sequence(siginfo, 2, &reallen)) != CRYPT_OK) {
       XFREE(out);
       goto bail_2;
    }

    /* test OID */
    if ((reallen == outlen) &&
        (digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&
        (XMEMCMP(digestinfo[0].data, hash_descriptor[hash_idx].OID, sizeof(unsigned long) * hash_descriptor[hash_idx].OIDlen) == 0) &&
        (siginfo[1].size == hashlen) &&
        (XMEMCMP(siginfo[1].data, hash, hashlen) == 0)) {
       *stat = 1;
    }

#ifdef LTC_CLEAN_STACK
    zeromem(out, outlen);
#endif
    XFREE(out);
  }

bail_2:
#ifdef LTC_CLEAN_STACK
  zeromem(tmpbuf, siglen);
#endif
  XFREE(tmpbuf);
  return err;
}","int rsa_verify_hash_ex(const unsigned char *VAR_0,      unsigned long VAR_1,
                       const unsigned char *VAR_2,     unsigned long VAR_3,
                             int            VAR_4,
                             int            VAR_5, unsigned long VAR_6,
                             int           *VAR_7,     rsa_key      *VAR_8)
{
  unsigned long VAR_9, VAR_10, VAR_11;
  int           VAR_12;
  unsigned char *VAR_13;

  LTC_ARGCHK(VAR_2  != NULL);
  LTC_ARGCHK(VAR_0   != NULL);
  LTC_ARGCHK(VAR_7  != NULL);
  LTC_ARGCHK(VAR_8   != NULL);

  /* COMMENT_0 */
  *VAR_7 = 0;

  /* COMMENT_1 */

  if ((VAR_4 != VAR_14) &&
      (VAR_4 != VAR_15)) {
    return VAR_16;
  }

  if (VAR_4 == VAR_15) {
    /* COMMENT_2 */
    if ((VAR_12 = hash_is_valid(VAR_5)) != VAR_17) {
       return VAR_12;
    }
  }

  /* COMMENT_3 */
  VAR_9 = mp_count_bits( (VAR_8->N));

  /* COMMENT_4 */
  VAR_10 = mp_unsigned_bin_size( (VAR_8->N));
  if (VAR_10 != VAR_1) {
     return VAR_18;
  }

  /* COMMENT_5 */
  VAR_13 = XMALLOC(VAR_1);
  if (VAR_13 == NULL) {
     return VAR_19;
  }

  /* COMMENT_6 */
  VAR_11 = VAR_1;
  if ((VAR_12 = VAR_20.rsa_me(VAR_0, VAR_1, VAR_13, &VAR_11, VAR_21, VAR_8)) != VAR_17) {
     XFREE(VAR_13);
     return VAR_12;
  }

  /* COMMENT_7 */
  if (VAR_11 != VAR_1) {
     XFREE(VAR_13);
     return VAR_18;
  }

  if (VAR_4 == VAR_15) {
    /* COMMENT_8 */

    if(VAR_9%8 == 1){
      VAR_12 = pkcs_1_pss_decode(VAR_2, VAR_3, VAR_13+1, VAR_11-1, VAR_6, VAR_5, VAR_9, VAR_7);
    }
    else{
      VAR_12 = pkcs_1_pss_decode(VAR_2, VAR_3, VAR_13, VAR_11, VAR_6, VAR_5, VAR_9, VAR_7);
    }

  } else {
    /* COMMENT_9 */
    unsigned char *VAR_22;
    unsigned long VAR_23, VAR_24[16], VAR_25;
    int           VAR_26;
    ltc_asn1_list VAR_27[2], VAR_28[2];

    /* COMMENT_10 */
    if (VAR_29[VAR_5].OIDlen == 0) {
       VAR_12 = VAR_30;
       goto bail_2;
    }

    /* COMMENT_11 */
    VAR_23 = ((VAR_9 >> 3) + (VAR_9 & 7 ? 1 : 0)) - 3;
    VAR_22    = XMALLOC(VAR_23);
    if (VAR_22 == NULL) {
      VAR_12 = VAR_19;
      goto bail_2;
    }

    if ((VAR_12 = pkcs_1_v1_5_decode(VAR_13, VAR_11, VAR_31, VAR_9, VAR_22, &VAR_23, &VAR_26)) != VAR_17) {
      XFREE(VAR_22);
      goto bail_2;
    }

    /* COMMENT_12 */
    /* COMMENT_13 */
                
                              
                               
          
                             
       
     
    LTC_SET_ASN1(VAR_27, 0, VAR_32, VAR_24, sizeof(loid)/sizeof(loid[0]));
    LTC_SET_ASN1(VAR_27, 1, VAR_33,              NULL,                          0);
    LTC_SET_ASN1(VAR_28,    0, VAR_34,          VAR_27,                    2);
    LTC_SET_ASN1(VAR_28,    1, VAR_35,      VAR_13,                        VAR_1);

    if ((VAR_12 = der_decode_sequence(VAR_22, VAR_23, VAR_28, 2)) != VAR_17) {
       XFREE(VAR_22);
       goto bail_2;
    }

    if ((VAR_12 = der_length_sequence(VAR_28, 2, &VAR_25)) != VAR_17) {
       XFREE(VAR_22);
       goto bail_2;
    }

    /* COMMENT_21 */
    if ((VAR_25 == VAR_23) &&
        (VAR_27[0].size == VAR_29[VAR_5].OIDlen) &&
        (XMEMCMP(VAR_27[0].data, VAR_29[VAR_5].OID, sizeof(unsigned long) * VAR_29[VAR_5].OIDlen) == 0) &&
        (VAR_28[1].size == VAR_3) &&
        (XMEMCMP(VAR_28[1].data, VAR_2, VAR_3) == 0)) {
       *VAR_7 = 1;
    }

#ifdef VAR_36
    zeromem(VAR_22, VAR_23);
#endif
    XFREE(VAR_22);
  }

bail_2:
#ifdef VAR_36
  zeromem(VAR_13, VAR_1);
#endif
  XFREE(VAR_13);
  return VAR_12;
}",libtom/libtomcrypt/5eb9743410ce4657e9d54fef26a2ee31a1b5dd0/rsa_verify_hash.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -71,7 +71,7 @@
   } else {
     /* PKCS #1 v1.5 decode it */
     unsigned char *out;
-    unsigned long outlen, loid[16];
+    unsigned long outlen, loid[16], reallen;
     int           decoded;
     ltc_asn1_list digestinfo[2], siginfo[2];
 
@@ -113,8 +113,14 @@
        goto bail_2;
     }
 
+    if ((err = der_length_sequence(siginfo, 2, &reallen)) != CRYPT_OK) {
+       XFREE(out);
+       goto bail_2;
+    }
+
     /* test OID */
-    if ((digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&
+    if ((reallen == outlen) &&
+        (digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&
         (XMEMCMP(digestinfo[0].data, hash_descriptor[hash_idx].OID, sizeof(unsigned long) * hash_descriptor[hash_idx].OIDlen) == 0) &&
         (siginfo[1].size == hashlen) &&
         (XMEMCMP(siginfo[1].data, hash, hashlen) == 0)) {","{'deleted_lines': ['    unsigned long outlen, loid[16];', '    if ((digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&'], 'added_lines': ['    unsigned long outlen, loid[16], reallen;', '    if ((err = der_length_sequence(siginfo, 2, &reallen)) != CRYPT_OK) {', '       XFREE(out);', '       goto bail_2;', '    }', '', '    if ((reallen == outlen) &&', '        (digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&']}",True,"The rsa_verify_hash_ex function in rsa_verify_hash.c in LibTomCrypt, as used in OP-TEE before 2.2.0, does not validate that the message length is equal to the ASN.1 encoded data length, which makes it easier for remote attackers to forge RSA signatures or public certificates by leveraging a Bleichenbacher signature forgery attack.",7.5,HIGH,2,test,2014-08-06T13:03:46Z,1
CVE-2014-3611,['CWE-362'],AV:L/AC:M/Au:N/C:N/I:N/A:C,0,torvalds/linux,"KVM: x86: Improve thread safety in pit

There's a race condition in the PIT emulation code in KVM.  In
__kvm_migrate_pit_timer the pit_timer object is accessed without
synchronization.  If the race condition occurs at the wrong time this
can crash the host kernel.

This fixes CVE-2014-3611.

Cc: stable@vger.kernel.org
Signed-off-by: Andrew Honig <ahonig@google.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>",2febc839133280d5a5e8e1179c94ea674489dae2,https://github.com/torvalds/linux/commit/2febc839133280d5a5e8e1179c94ea674489dae2,arch/x86/kvm/i8254.c,__kvm_migrate_pit_timer,"void __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)
{
struct kvm_pit *pit = vcpu->kvm->arch.vpit;
struct hrtimer *timer;
if (!kvm_vcpu_is_bsp(vcpu) || !pit)
return;
timer = &pit->pit_state.timer;
if (hrtimer_cancel(timer))
hrtimer_start_expires(timer, HRTIMER_MODE_ABS);
}","void __kvm_migrate_pit_timer(struct kvm_vcpu *VAR_0)
{
struct kvm_pit *VAR_1 = VAR_0->kvm->arch.vpit;
struct hrtimer *VAR_2;
if (!kvm_vcpu_is_bsp(VAR_0) || !VAR_1)
return;
VAR_2 = &VAR_1->pit_state.timer;
if (hrtimer_cancel(VAR_2))
hrtimer_start_expires(VAR_2, VAR_3);
}",torvalds/linux/2febc839133280d5a5e8e1179c94ea674489dae2/i8254.c/vul/before/0.json,"void __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)
{
	struct kvm_pit *pit = vcpu->kvm->arch.vpit;
	struct hrtimer *timer;

	if (!kvm_vcpu_is_bsp(vcpu) || !pit)
		return;

	timer = &pit->pit_state.timer;
	mutex_lock(&pit->pit_state.lock);
	if (hrtimer_cancel(timer))
		hrtimer_start_expires(timer, HRTIMER_MODE_ABS);
	mutex_unlock(&pit->pit_state.lock);
}","void __kvm_migrate_pit_timer(struct kvm_vcpu *VAR_0)
{
	struct kvm_pit *VAR_1 = VAR_0->kvm->arch.vpit;
	struct hrtimer *VAR_2;

	if (!kvm_vcpu_is_bsp(VAR_0) || !VAR_1)
		return;

	VAR_2 = &VAR_1->pit_state.timer;
	mutex_lock(&VAR_1->pit_state.lock);
	if (hrtimer_cancel(VAR_2))
		hrtimer_start_expires(VAR_2, VAR_3);
	mutex_unlock(&VAR_1->pit_state.lock);
}",torvalds/linux/2febc839133280d5a5e8e1179c94ea674489dae2/i8254.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,6 +7,8 @@
 		return;
 
 	timer = &pit->pit_state.timer;
+	mutex_lock(&pit->pit_state.lock);
 	if (hrtimer_cancel(timer))
 		hrtimer_start_expires(timer, HRTIMER_MODE_ABS);
+	mutex_unlock(&pit->pit_state.lock);
 }","{'deleted_lines': [], 'added_lines': ['\tmutex_lock(&pit->pit_state.lock);', '\tmutex_unlock(&pit->pit_state.lock);']}",True,Race condition in the __kvm_migrate_pit_timer function in arch/x86/kvm/i8254.c in the KVM subsystem in the Linux kernel through 3.17.2 allows guest OS users to cause a denial of service (host OS crash) by leveraging incorrect PIT emulation.,4.7,MEDIUM,1,test,2014-08-27T21:42:54Z,1
CVE-2014-3690,['CWE-400'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"x86,kvm,vmx: Preserve CR4 across VM entry

CR4 isn't constant; at least the TSD and PCE bits can vary.

TBH, treating CR0 and CR3 as constant scares me a bit, too, but it looks
like it's correct.

This adds a branch and a read from cr4 to each vm entry.  Because it is
extremely likely that consecutive entries into the same vcpu will have
the same host cr4 value, this fixes up the vmcs instead of restoring cr4
after the fact.  A subsequent patch will add a kernel-wide cr4 shadow,
reducing the overhead in the common case to just two memory reads and a
branch.

Signed-off-by: Andy Lutomirski <luto@amacapital.net>
Acked-by: Paolo Bonzini <pbonzini@redhat.com>
Cc: stable@vger.kernel.org
Cc: Petr Matousek <pmatouse@redhat.com>
Cc: Gleb Natapov <gleb@kernel.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",d974baa398f34393db76be45f7d4d04fbdbb4a0a,https://github.com/torvalds/linux/commit/d974baa398f34393db76be45f7d4d04fbdbb4a0a,arch/x86/kvm/vmx.c,vmx_vcpu_run,"static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)
{
struct vcpu_vmx *vmx = to_vmx(vcpu);
unsigned long debugctlmsr;
if (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked))
vmx->entry_time = ktime_get();
if (vmx->emulation_required)
return;
if (vmx->ple_window_dirty) {
vmx->ple_window_dirty = false;
vmcs_write32(PLE_WINDOW, vmx->ple_window);
}
if (vmx->nested.sync_shadow_vmcs) {
copy_vmcs12_to_shadow(vmx);
vmx->nested.sync_shadow_vmcs = false;
}
if (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))
vmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);
if (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))
vmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);
if (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)
vmx_set_interrupt_shadow(vcpu, 0);
atomic_switch_perf_msrs(vmx);
debugctlmsr = get_debugctlmsr();
vmx->__launched = vmx->loaded_vmcs->launched;
asm(
""push %%"" _ASM_DX ""; push %%"" _ASM_BP "";""
""push %%"" _ASM_CX "" \n\t"" 
""push %%"" _ASM_CX "" \n\t""
""cmp %%"" _ASM_SP "", %c[host_rsp](%0) \n\t""
""je 1f \n\t""
""mov %%"" _ASM_SP "", %c[host_rsp](%0) \n\t""
__ex(ASM_VMX_VMWRITE_RSP_RDX) ""\n\t""
""1: \n\t""
""mov %c[cr2](%0), %%"" _ASM_AX "" \n\t""
""mov %%cr2, %%"" _ASM_DX "" \n\t""
""cmp %%"" _ASM_AX "", %%"" _ASM_DX "" \n\t""
""je 2f \n\t""
""mov %%"" _ASM_AX"", %%cr2 \n\t""
""2: \n\t""
""cmpl $0, %c[launched](%0) \n\t""
""mov %c[rax](%0), %%"" _ASM_AX "" \n\t""
""mov %c[rbx](%0), %%"" _ASM_BX "" \n\t""
""mov %c[rdx](%0), %%"" _ASM_DX "" \n\t""
""mov %c[rsi](%0), %%"" _ASM_SI "" \n\t""
""mov %c[rdi](%0), %%"" _ASM_DI "" \n\t""
""mov %c[rbp](%0), %%"" _ASM_BP "" \n\t""
#ifdef CONFIG_X86_64
""mov %c[r8](%0),  %%r8  \n\t""
""mov %c[r9](%0),  %%r9  \n\t""
""mov %c[r10](%0), %%r10 \n\t""
""mov %c[r11](%0), %%r11 \n\t""
""mov %c[r12](%0), %%r12 \n\t""
""mov %c[r13](%0), %%r13 \n\t""
""mov %c[r14](%0), %%r14 \n\t""
""mov %c[r15](%0), %%r15 \n\t""
#endif
""mov %c[rcx](%0), %%"" _ASM_CX "" \n\t"" 
""jne 1f \n\t""
__ex(ASM_VMX_VMLAUNCH) ""\n\t""
""jmp 2f \n\t""
""1: "" __ex(ASM_VMX_VMRESUME) ""\n\t""
""2: ""
""mov %0, %c[wordsize](%%"" _ASM_SP "") \n\t""
""pop %0 \n\t""
""mov %%"" _ASM_AX "", %c[rax](%0) \n\t""
""mov %%"" _ASM_BX "", %c[rbx](%0) \n\t""
__ASM_SIZE(pop) "" %c[rcx](%0) \n\t""
""mov %%"" _ASM_DX "", %c[rdx](%0) \n\t""
""mov %%"" _ASM_SI "", %c[rsi](%0) \n\t""
""mov %%"" _ASM_DI "", %c[rdi](%0) \n\t""
""mov %%"" _ASM_BP "", %c[rbp](%0) \n\t""
#ifdef CONFIG_X86_64
""mov %%r8,  %c[r8](%0) \n\t""
""mov %%r9,  %c[r9](%0) \n\t""
""mov %%r10, %c[r10](%0) \n\t""
""mov %%r11, %c[r11](%0) \n\t""
""mov %%r12, %c[r12](%0) \n\t""
""mov %%r13, %c[r13](%0) \n\t""
""mov %%r14, %c[r14](%0) \n\t""
""mov %%r15, %c[r15](%0) \n\t""
#endif
""mov %%cr2, %%"" _ASM_AX ""   \n\t""
""mov %%"" _ASM_AX "", %c[cr2](%0) \n\t""
""pop  %%"" _ASM_BP ""; pop  %%"" _ASM_DX "" \n\t""
""setbe %c[fail](%0) \n\t""
"".pushsection .rodata \n\t""
"".global vmx_return \n\t""
""vmx_return: "" _ASM_PTR "" 2b \n\t""
"".popsection""
: : ""c""(vmx), ""d""((unsigned long)HOST_RSP),
[launched]""i""(offsetof(struct vcpu_vmx, __launched)),
[fail]""i""(offsetof(struct vcpu_vmx, fail)),
[host_rsp]""i""(offsetof(struct vcpu_vmx, host_rsp)),
[rax]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RAX])),
[rbx]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBX])),
[rcx]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RCX])),
[rdx]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDX])),
[rsi]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RSI])),
[rdi]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDI])),
[rbp]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBP])),
#ifdef CONFIG_X86_64
[r8]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R8])),
[r9]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R9])),
[r10]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R10])),
[r11]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R11])),
[r12]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R12])),
[r13]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R13])),
[r14]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R14])),
[r15]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R15])),
#endif
[cr2]""i""(offsetof(struct vcpu_vmx, vcpu.arch.cr2)),
[wordsize]""i""(sizeof(ulong))
: ""cc"", ""memory""
#ifdef CONFIG_X86_64
, ""rax"", ""rbx"", ""rdi"", ""rsi""
, ""r8"", ""r9"", ""r10"", ""r11"", ""r12"", ""r13"", ""r14"", ""r15""
#else
, ""eax"", ""ebx"", ""edi"", ""esi""
#endif
);
if (debugctlmsr)
update_debugctlmsr(debugctlmsr);
#ifndef CONFIG_X86_64
loadsegment(ds, __USER_DS);
loadsegment(es, __USER_DS);
#endif
vcpu->arch.regs_avail = ~((1 << VCPU_REGS_RIP) | (1 << VCPU_REGS_RSP)
| (1 << VCPU_EXREG_RFLAGS)
| (1 << VCPU_EXREG_PDPTR)
| (1 << VCPU_EXREG_SEGMENTS)
| (1 << VCPU_EXREG_CR3));
vcpu->arch.regs_dirty = 0;
vmx->idt_vectoring_info = vmcs_read32(IDT_VECTORING_INFO_FIELD);
vmx->loaded_vmcs->launched = 1;
vmx->exit_reason = vmcs_read32(VM_EXIT_REASON);
trace_kvm_exit(vmx->exit_reason, vcpu, KVM_ISA_VMX);
if (vmx->nested.nested_run_pending)
kvm_make_request(KVM_REQ_EVENT, vcpu);
vmx->nested.nested_run_pending = 0;
vmx_complete_atomic_exit(vmx);
vmx_recover_nmi_blocking(vmx);
vmx_complete_interrupts(vmx);
}","static void VAR_0 vmx_vcpu_run(struct kvm_vcpu *VAR_1)
{
struct vcpu_vmx *VAR_2 = to_vmx(VAR_1);
unsigned long VAR_3;
if (unlikely(!cpu_has_virtual_nmis() && VAR_2->soft_vnmi_blocked))
VAR_2->entry_time = ktime_get();
if (VAR_2->emulation_required)
return;
if (VAR_2->ple_window_dirty) {
VAR_2->ple_window_dirty = false;
vmcs_write32(VAR_4, VAR_2->ple_window);
}
if (VAR_2->nested.sync_shadow_vmcs) {
copy_vmcs12_to_shadow(VAR_2);
VAR_2->nested.sync_shadow_vmcs = false;
}
if (test_bit(VAR_5, (unsigned long *)&VAR_1->arch.regs_dirty))
vmcs_writel(VAR_6, VAR_1->arch.regs[VAR_5]);
if (test_bit(VAR_7, (unsigned long *)&VAR_1->arch.regs_dirty))
vmcs_writel(VAR_8, VAR_1->arch.regs[VAR_7]);
if (VAR_1->guest_debug & VAR_9)
vmx_set_interrupt_shadow(VAR_1, 0);
atomic_switch_perf_msrs(VAR_2);
VAR_3 = get_debugctlmsr();
VAR_2->__launched = VAR_2->loaded_vmcs->launched;
asm(
""push %%"" VAR_10 ""; push %%"" VAR_11 "";""
""push %%"" VAR_12 "" \n\t"" 
""push %%"" VAR_12 "" \n\t""
""cmp %%"" VAR_13 "", %c[host_rsp](%0) \n\t""
""je 1f \n\t""
""mov %%"" VAR_13 "", %c[host_rsp](%0) \n\t""
VAR_14(VAR_15) ""\n\t""
""1: \n\t""
""mov %c[cr2](%0), %%"" VAR_16 "" \n\t""
""mov %%cr2, %%"" VAR_10 "" \n\t""
""cmp %%"" VAR_16 "", %%"" VAR_10 "" \n\t""
""je 2f \n\t""
""mov %%"" VAR_16"", %%cr2 \n\t""
""2: \n\t""
""cmpl $0, %c[launched](%0) \n\t""
""mov %c[rax](%0), %%"" VAR_16 "" \n\t""
""mov %c[rbx](%0), %%"" VAR_17 "" \n\t""
""mov %c[rdx](%0), %%"" VAR_10 "" \n\t""
""mov %c[rsi](%0), %%"" VAR_18 "" \n\t""
""mov %c[rdi](%0), %%"" VAR_19 "" \n\t""
""mov %c[rbp](%0), %%"" VAR_11 "" \n\t""
#ifdef VAR_20
""mov %c[r8](%0),  %%r8  \n\t""
""mov %c[r9](%0),  %%r9  \n\t""
""mov %c[r10](%0), %%r10 \n\t""
""mov %c[r11](%0), %%r11 \n\t""
""mov %c[r12](%0), %%r12 \n\t""
""mov %c[r13](%0), %%r13 \n\t""
""mov %c[r14](%0), %%r14 \n\t""
""mov %c[r15](%0), %%r15 \n\t""
#endif
""mov %c[rcx](%0), %%"" VAR_12 "" \n\t"" 
""jne 1f \n\t""
VAR_14(ASM_VMX_VMLAUNCH) ""\n\t""
""jmp 2f \n\t""
""1: "" VAR_14(ASM_VMX_VMRESUME) ""\n\t""
""2: ""
""mov %0, %c[wordsize](%%"" VAR_13 "") \n\t""
""pop %0 \n\t""
""mov %%"" VAR_16 "", %c[rax](%0) \n\t""
""mov %%"" VAR_17 "", %c[rbx](%0) \n\t""
VAR_21(pop) "" %c[rcx](%0) \n\t""
""mov %%"" VAR_10 "", %c[rdx](%0) \n\t""
""mov %%"" VAR_18 "", %c[rsi](%0) \n\t""
""mov %%"" VAR_19 "", %c[rdi](%0) \n\t""
""mov %%"" VAR_11 "", %c[rbp](%0) \n\t""
#ifdef VAR_20
""mov %%r8,  %c[r8](%0) \n\t""
""mov %%r9,  %c[r9](%0) \n\t""
""mov %%r10, %c[r10](%0) \n\t""
""mov %%r11, %c[r11](%0) \n\t""
""mov %%r12, %c[r12](%0) \n\t""
""mov %%r13, %c[r13](%0) \n\t""
""mov %%r14, %c[r14](%0) \n\t""
""mov %%r15, %c[r15](%0) \n\t""
#endif
""mov %%cr2, %%"" VAR_16 ""   \n\t""
""mov %%"" VAR_16 "", %c[cr2](%0) \n\t""
""pop  %%"" VAR_11 ""; pop  %%"" VAR_10 "" \n\t""
""setbe %c[fail](%0) \n\t""
"".pushsection .rodata \n\t""
"".global vmx_return \n\t""
""vmx_return: "" VAR_22 "" 2b \n\t""
"".popsection""
: : ""VAR_23""(VAR_2), ""d""((unsigned long)VAR_24),
[VAR_25]""i""(offsetof(struct vcpu_vmx, VAR_26)),
[VAR_27]""i""(offsetof(struct vcpu_vmx, VAR_27)),
[VAR_28]""i""(offsetof(struct vcpu_vmx, VAR_28)),
[VAR_29]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_30])),
[VAR_31]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_32])),
[VAR_33]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_34])),
[VAR_35]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_36])),
[VAR_37]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_38])),
[VAR_39]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_40])),
[VAR_41]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_42])),
#ifdef VAR_20
[VAR_43]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_44])),VAR_45
[VAR_46]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_47])),
[VAR_48]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_49])),
[VAR_50]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_51])),
[VAR_52]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_53])),
[VAR_54]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_55])),
[VAR_56]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_57])),
[VAR_58]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_59])),
#endif
[VAR_60]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.cr2)),
[VAR_61]""i""(sizeof(VAR_62))
: ""cc"", ""memory""
#ifdef VAR_20
, ""rax"", ""rbx"", ""rdi"", ""rsi""
, ""r8"", ""r9"", ""r10"", ""r11"", ""r12"", ""r13"", ""r14"", ""r15""
#else
, ""eax"", ""ebx"", ""edi"", ""esi""
#endif
);
if (VAR_3)
update_debugctlmsr(VAR_3);
#ifndef VAR_20
loadsegment(VAR_63, VAR_64);
loadsegment(VAR_65, VAR_64);
#endif
VAR_1->arch.regs_avail = ~((1 << VAR_7) | (1 << VAR_5)
| (1 << VAR_66)
| (1 << VAR_67)
| (1 << VAR_68)
| (1 << VAR_69));
VAR_1->arch.regs_dirty = 0;
VAR_2->idt_vectoring_info = vmcs_read32(VAR_70);
VAR_2->loaded_vmcs->launched = 1;
VAR_2->exit_reason = vmcs_read32(VAR_71);
trace_kvm_exit(VAR_2->exit_reason, VAR_1, VAR_72);
if (VAR_2->nested.nested_run_pending)
kvm_make_request(VAR_73, VAR_1);
VAR_2->nested.nested_run_pending = 0;
vmx_complete_atomic_exit(VAR_2);
vmx_recover_nmi_blocking(VAR_2);
vmx_complete_interrupts(VAR_2);
}",,"static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	unsigned long debugctlmsr, cr4;

	/* Record the guest's net vcpu time for enforced NMI injections. */
	if (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked))
		vmx->entry_time = ktime_get();

	/* Don't enter VMX if guest state is invalid, let the exit handler
	   start emulation until we arrive back to a valid state */
	if (vmx->emulation_required)
		return;

	if (vmx->ple_window_dirty) {
		vmx->ple_window_dirty = false;
		vmcs_write32(PLE_WINDOW, vmx->ple_window);
	}

	if (vmx->nested.sync_shadow_vmcs) {
		copy_vmcs12_to_shadow(vmx);
		vmx->nested.sync_shadow_vmcs = false;
	}

	if (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))
		vmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);
	if (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))
		vmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);

	cr4 = read_cr4();
	if (unlikely(cr4 != vmx->host_state.vmcs_host_cr4)) {
		vmcs_writel(HOST_CR4, cr4);
		vmx->host_state.vmcs_host_cr4 = cr4;
	}

	/* When single-stepping over STI and MOV SS, we must clear the
	 * corresponding interruptibility bits in the guest state. Otherwise
	 * vmentry fails as it then expects bit 14 (BS) in pending debug
	 * exceptions being set, but that's not correct for the guest debugging
	 * case. */
	if (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)
		vmx_set_interrupt_shadow(vcpu, 0);

	atomic_switch_perf_msrs(vmx);
	debugctlmsr = get_debugctlmsr();

	vmx->__launched = vmx->loaded_vmcs->launched;
	asm(
		/* Store host registers */
		""push %%"" _ASM_DX ""; push %%"" _ASM_BP "";""
		""push %%"" _ASM_CX "" \n\t"" /* placeholder for guest rcx */
		""push %%"" _ASM_CX "" \n\t""
		""cmp %%"" _ASM_SP "", %c[host_rsp](%0) \n\t""
		""je 1f \n\t""
		""mov %%"" _ASM_SP "", %c[host_rsp](%0) \n\t""
		__ex(ASM_VMX_VMWRITE_RSP_RDX) ""\n\t""
		""1: \n\t""
		/* Reload cr2 if changed */
		""mov %c[cr2](%0), %%"" _ASM_AX "" \n\t""
		""mov %%cr2, %%"" _ASM_DX "" \n\t""
		""cmp %%"" _ASM_AX "", %%"" _ASM_DX "" \n\t""
		""je 2f \n\t""
		""mov %%"" _ASM_AX"", %%cr2 \n\t""
		""2: \n\t""
		/* Check if vmlaunch of vmresume is needed */
		""cmpl $0, %c[launched](%0) \n\t""
		/* Load guest registers.  Don't clobber flags. */
		""mov %c[rax](%0), %%"" _ASM_AX "" \n\t""
		""mov %c[rbx](%0), %%"" _ASM_BX "" \n\t""
		""mov %c[rdx](%0), %%"" _ASM_DX "" \n\t""
		""mov %c[rsi](%0), %%"" _ASM_SI "" \n\t""
		""mov %c[rdi](%0), %%"" _ASM_DI "" \n\t""
		""mov %c[rbp](%0), %%"" _ASM_BP "" \n\t""
#ifdef CONFIG_X86_64
		""mov %c[r8](%0),  %%r8  \n\t""
		""mov %c[r9](%0),  %%r9  \n\t""
		""mov %c[r10](%0), %%r10 \n\t""
		""mov %c[r11](%0), %%r11 \n\t""
		""mov %c[r12](%0), %%r12 \n\t""
		""mov %c[r13](%0), %%r13 \n\t""
		""mov %c[r14](%0), %%r14 \n\t""
		""mov %c[r15](%0), %%r15 \n\t""
#endif
		""mov %c[rcx](%0), %%"" _ASM_CX "" \n\t"" /* kills %0 (ecx) */

		/* Enter guest mode */
		""jne 1f \n\t""
		__ex(ASM_VMX_VMLAUNCH) ""\n\t""
		""jmp 2f \n\t""
		""1: "" __ex(ASM_VMX_VMRESUME) ""\n\t""
		""2: ""
		/* Save guest registers, load host registers, keep flags */
		""mov %0, %c[wordsize](%%"" _ASM_SP "") \n\t""
		""pop %0 \n\t""
		""mov %%"" _ASM_AX "", %c[rax](%0) \n\t""
		""mov %%"" _ASM_BX "", %c[rbx](%0) \n\t""
		__ASM_SIZE(pop) "" %c[rcx](%0) \n\t""
		""mov %%"" _ASM_DX "", %c[rdx](%0) \n\t""
		""mov %%"" _ASM_SI "", %c[rsi](%0) \n\t""
		""mov %%"" _ASM_DI "", %c[rdi](%0) \n\t""
		""mov %%"" _ASM_BP "", %c[rbp](%0) \n\t""
#ifdef CONFIG_X86_64
		""mov %%r8,  %c[r8](%0) \n\t""
		""mov %%r9,  %c[r9](%0) \n\t""
		""mov %%r10, %c[r10](%0) \n\t""
		""mov %%r11, %c[r11](%0) \n\t""
		""mov %%r12, %c[r12](%0) \n\t""
		""mov %%r13, %c[r13](%0) \n\t""
		""mov %%r14, %c[r14](%0) \n\t""
		""mov %%r15, %c[r15](%0) \n\t""
#endif
		""mov %%cr2, %%"" _ASM_AX ""   \n\t""
		""mov %%"" _ASM_AX "", %c[cr2](%0) \n\t""

		""pop  %%"" _ASM_BP ""; pop  %%"" _ASM_DX "" \n\t""
		""setbe %c[fail](%0) \n\t""
		"".pushsection .rodata \n\t""
		"".global vmx_return \n\t""
		""vmx_return: "" _ASM_PTR "" 2b \n\t""
		"".popsection""
	      : : ""c""(vmx), ""d""((unsigned long)HOST_RSP),
		[launched]""i""(offsetof(struct vcpu_vmx, __launched)),
		[fail]""i""(offsetof(struct vcpu_vmx, fail)),
		[host_rsp]""i""(offsetof(struct vcpu_vmx, host_rsp)),
		[rax]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RAX])),
		[rbx]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBX])),
		[rcx]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RCX])),
		[rdx]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDX])),
		[rsi]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RSI])),
		[rdi]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDI])),
		[rbp]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBP])),
#ifdef CONFIG_X86_64
		[r8]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R8])),
		[r9]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R9])),
		[r10]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R10])),
		[r11]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R11])),
		[r12]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R12])),
		[r13]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R13])),
		[r14]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R14])),
		[r15]""i""(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R15])),
#endif
		[cr2]""i""(offsetof(struct vcpu_vmx, vcpu.arch.cr2)),
		[wordsize]""i""(sizeof(ulong))
	      : ""cc"", ""memory""
#ifdef CONFIG_X86_64
		, ""rax"", ""rbx"", ""rdi"", ""rsi""
		, ""r8"", ""r9"", ""r10"", ""r11"", ""r12"", ""r13"", ""r14"", ""r15""
#else
		, ""eax"", ""ebx"", ""edi"", ""esi""
#endif
	      );

	/* MSR_IA32_DEBUGCTLMSR is zeroed on vmexit. Restore it if needed */
	if (debugctlmsr)
		update_debugctlmsr(debugctlmsr);

#ifndef CONFIG_X86_64
	/*
	 * The sysexit path does not restore ds/es, so we must set them to
	 * a reasonable value ourselves.
	 *
	 * We can't defer this to vmx_load_host_state() since that function
	 * may be executed in interrupt context, which saves and restore segments
	 * around it, nullifying its effect.
	 */
	loadsegment(ds, __USER_DS);
	loadsegment(es, __USER_DS);
#endif

	vcpu->arch.regs_avail = ~((1 << VCPU_REGS_RIP) | (1 << VCPU_REGS_RSP)
				  | (1 << VCPU_EXREG_RFLAGS)
				  | (1 << VCPU_EXREG_PDPTR)
				  | (1 << VCPU_EXREG_SEGMENTS)
				  | (1 << VCPU_EXREG_CR3));
	vcpu->arch.regs_dirty = 0;

	vmx->idt_vectoring_info = vmcs_read32(IDT_VECTORING_INFO_FIELD);

	vmx->loaded_vmcs->launched = 1;

	vmx->exit_reason = vmcs_read32(VM_EXIT_REASON);
	trace_kvm_exit(vmx->exit_reason, vcpu, KVM_ISA_VMX);

	/*
	 * the KVM_REQ_EVENT optimization bit is only on for one entry, and if
	 * we did not inject a still-pending event to L1 now because of
	 * nested_run_pending, we need to re-enable this bit.
	 */
	if (vmx->nested.nested_run_pending)
		kvm_make_request(KVM_REQ_EVENT, vcpu);

	vmx->nested.nested_run_pending = 0;

	vmx_complete_atomic_exit(vmx);
	vmx_recover_nmi_blocking(vmx);
	vmx_complete_interrupts(vmx);
}","static void VAR_0 vmx_vcpu_run(struct kvm_vcpu *VAR_1)
{
	struct vcpu_vmx *VAR_2 = to_vmx(VAR_1);
	unsigned long VAR_3, VAR_4;

	/* COMMENT_0 */
	if (unlikely(!cpu_has_virtual_nmis() && VAR_2->soft_vnmi_blocked))
		VAR_2->entry_time = ktime_get();

	/* COMMENT_1 */
                                                            
	if (VAR_2->emulation_required)
		return;

	if (VAR_2->ple_window_dirty) {
		VAR_2->ple_window_dirty = false;
		vmcs_write32(VAR_5, VAR_2->ple_window);
	}

	if (VAR_2->nested.sync_shadow_vmcs) {
		copy_vmcs12_to_shadow(VAR_2);
		VAR_2->nested.sync_shadow_vmcs = false;
	}

	if (test_bit(VAR_6, (unsigned long *)&VAR_1->arch.regs_dirty))
		vmcs_writel(VAR_7, VAR_1->arch.regs[VAR_6]);
	if (test_bit(VAR_8, (unsigned long *)&VAR_1->arch.regs_dirty))
		vmcs_writel(VAR_9, VAR_1->arch.regs[VAR_8]);

	VAR_4 = read_cr4();
	if (unlikely(VAR_4 != VAR_2->host_state.vmcs_host_cr4)) {
		vmcs_writel(VAR_10, VAR_4);
		VAR_2->host_state.vmcs_host_cr4 = VAR_4;
	}

	/* COMMENT_3 */
                                                                     
                                                                 
                                                                        
            
	if (VAR_1->guest_debug & VAR_11)
		vmx_set_interrupt_shadow(VAR_1, 0);

	atomic_switch_perf_msrs(VAR_2);
	VAR_3 = get_debugctlmsr();

	VAR_2->__launched = VAR_2->loaded_vmcs->launched;
	asm(
		/* COMMENT_8 */
		""push %%"" VAR_12 ""; push %%"" VAR_13 "";""
		""push %%"" VAR_14 "" \n\t"" /* COMMENT_9 */
		""push %%"" VAR_14 "" \n\t""
		""cmp %%"" VAR_15 "", %c[host_rsp](%0) \n\t""
		""je 1f \n\t""
		""mov %%"" VAR_15 "", %c[host_rsp](%0) \n\t""
		VAR_16(VAR_17) ""\n\t""
		""1: \n\t""
		/* COMMENT_10 */
		""mov %c[cr2](%0), %%"" VAR_18 "" \n\t""
		""mov %%cr2, %%"" VAR_12 "" \n\t""
		""cmp %%"" VAR_18 "", %%"" VAR_12 "" \n\t""
		""je 2f \n\t""
		""mov %%"" VAR_18"", %%cr2 \n\t""
		""2: \n\t""
		/* COMMENT_11 */
		""cmpl $0, %c[launched](%0) \n\t""
		/* COMMENT_12 */
		""mov %c[rax](%0), %%"" VAR_18 "" \n\t""
		""mov %c[rbx](%0), %%"" VAR_19 "" \n\t""
		""mov %c[rdx](%0), %%"" VAR_12 "" \n\t""
		""mov %c[rsi](%0), %%"" VAR_20 "" \n\t""
		""mov %c[rdi](%0), %%"" VAR_21 "" \n\t""
		""mov %c[rbp](%0), %%"" VAR_13 "" \n\t""
#ifdef VAR_22
		""mov %c[r8](%0),  %%r8  \n\t""
		""mov %c[r9](%0),  %%r9  \n\t""
		""mov %c[r10](%0), %%r10 \n\t""
		""mov %c[r11](%0), %%r11 \n\t""
		""mov %c[r12](%0), %%r12 \n\t""
		""mov %c[r13](%0), %%r13 \n\t""
		""mov %c[r14](%0), %%r14 \n\t""
		""mov %c[r15](%0), %%r15 \n\t""
#endif
		""mov %c[rcx](%0), %%"" VAR_14 "" \n\t"" /* COMMENT_13 */

		/* COMMENT_14 */
		""jne 1f \n\t""
		VAR_16(ASM_VMX_VMLAUNCH) ""\n\t""
		""jmp 2f \n\t""
		""1: "" VAR_16(ASM_VMX_VMRESUME) ""\n\t""
		""2: ""
		/* COMMENT_15 */
		""mov %0, %c[wordsize](%%"" VAR_15 "") \n\t""
		""pop %0 \n\t""
		""mov %%"" VAR_18 "", %c[rax](%0) \n\t""
		""mov %%"" VAR_19 "", %c[rbx](%0) \n\t""
		VAR_23(pop) "" %c[rcx](%0) \n\t""
		""mov %%"" VAR_12 "", %c[rdx](%0) \n\t""
		""mov %%"" VAR_20 "", %c[rsi](%0) \n\t""
		""mov %%"" VAR_21 "", %c[rdi](%0) \n\t""
		""mov %%"" VAR_13 "", %c[rbp](%0) \n\t""
#ifdef VAR_22
		""mov %%r8,  %c[r8](%0) \n\t""
		""mov %%r9,  %c[r9](%0) \n\t""
		""mov %%r10, %c[r10](%0) \n\t""
		""mov %%r11, %c[r11](%0) \n\t""
		""mov %%r12, %c[r12](%0) \n\t""
		""mov %%r13, %c[r13](%0) \n\t""
		""mov %%r14, %c[r14](%0) \n\t""
		""mov %%r15, %c[r15](%0) \n\t""
#endif
		""mov %%cr2, %%"" VAR_18 ""   \n\t""
		""mov %%"" VAR_18 "", %c[cr2](%0) \n\t""

		""pop  %%"" VAR_13 ""; pop  %%"" VAR_12 "" \n\t""
		""setbe %c[fail](%0) \n\t""
		"".pushsection .rodata \n\t""
		"".global vmx_return \n\t""
		""vmx_return: "" VAR_24 "" 2b \n\t""
		"".popsection""
	      : : ""VAR_25""(VAR_2), ""d""((unsigned long)VAR_26),
		[VAR_27]""i""(offsetof(struct vcpu_vmx, VAR_28)),
		[VAR_29]""i""(offsetof(struct vcpu_vmx, VAR_29)),
		[VAR_30]""i""(offsetof(struct vcpu_vmx, VAR_30)),
		[VAR_31]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_32])),
		[VAR_33]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_34])),
		[VAR_35]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_36])),
		[VAR_37]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_38])),
		[VAR_39]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_40])),
		[VAR_41]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_42])),
		[VAR_43]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_44])),
#ifdef VAR_22
		[VAR_45]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_46])),VAR_47
		[VAR_48]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_49])),
		[VAR_50]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_51])),
		[VAR_52]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_53])),
		[VAR_54]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_55])),
		[VAR_56]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_57])),
		[VAR_58]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_59])),
		[VAR_60]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.regs[VAR_61])),
#endif
		[VAR_62]""i""(offsetof(struct vcpu_vmx, VAR_1.arch.cr2)),
		[VAR_63]""i""(sizeof(VAR_64))
	      : ""cc"", ""memory""
#ifdef VAR_22
		, ""rax"", ""rbx"", ""rdi"", ""rsi""
		, ""r8"", ""r9"", ""r10"", ""r11"", ""r12"", ""r13"", ""r14"", ""r15""
#else
		, ""eax"", ""ebx"", ""edi"", ""esi""
#endif
	      );

	/* COMMENT_16 */
	if (VAR_3)
		update_debugctlmsr(VAR_3);

#ifndef VAR_22
	/* COMMENT_17 */
                                                                   
                                 
   
                                                                    
                                                                          
                                     
    
	loadsegment(VAR_65, VAR_66);
	loadsegment(VAR_67, VAR_66);
#endif

	VAR_1->arch.regs_avail = ~((1 << VAR_8) | (1 << VAR_6)
				  | (1 << VAR_68)
				  | (1 << VAR_69)
				  | (1 << VAR_70)
				  | (1 << VAR_71));
	VAR_1->arch.regs_dirty = 0;

	VAR_2->idt_vectoring_info = vmcs_read32(VAR_72);

	VAR_2->loaded_vmcs->launched = 1;

	VAR_2->exit_reason = vmcs_read32(VAR_73);
	trace_kvm_exit(VAR_2->exit_reason, VAR_1, VAR_74);

	/* COMMENT_25 */
                                                                       
                                                                
                                                      
    
	if (VAR_2->nested.nested_run_pending)
		kvm_make_request(VAR_75, VAR_1);

	VAR_2->nested.nested_run_pending = 0;

	vmx_complete_atomic_exit(VAR_2);
	vmx_recover_nmi_blocking(VAR_2);
	vmx_complete_interrupts(VAR_2);
}",,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)
 {
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
-	unsigned long debugctlmsr;
+	unsigned long debugctlmsr, cr4;
 
 	/* Record the guest's net vcpu time for enforced NMI injections. */
 	if (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked))
@@ -26,6 +26,12 @@
 		vmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);
 	if (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))
 		vmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);
+
+	cr4 = read_cr4();
+	if (unlikely(cr4 != vmx->host_state.vmcs_host_cr4)) {
+		vmcs_writel(HOST_CR4, cr4);
+		vmx->host_state.vmcs_host_cr4 = cr4;
+	}
 
 	/* When single-stepping over STI and MOV SS, we must clear the
 	 * corresponding interruptibility bits in the guest state. Otherwise","{'deleted_lines': ['\tunsigned long debugctlmsr;'], 'added_lines': ['\tunsigned long debugctlmsr, cr4;', '', '\tcr4 = read_cr4();', '\tif (unlikely(cr4 != vmx->host_state.vmcs_host_cr4)) {', '\t\tvmcs_writel(HOST_CR4, cr4);', '\t\tvmx->host_state.vmcs_host_cr4 = cr4;', '\t}']}",True,"arch/x86/kvm/vmx.c in the KVM subsystem in the Linux kernel before 3.17.2 on Intel processors does not ensure that the value in the CR4 control register remains the same after a VM entry, which allows host OS users to kill arbitrary processes or cause a denial of service (system disruption) by leveraging /dev/kvm access, as demonstrated by PR_SET_TSC prctl calls within a modified copy of QEMU.",5.5,MEDIUM,1,test,2014-10-08T16:02:13Z,1
CVE-2014-3690,['CWE-400'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"x86,kvm,vmx: Preserve CR4 across VM entry

CR4 isn't constant; at least the TSD and PCE bits can vary.

TBH, treating CR0 and CR3 as constant scares me a bit, too, but it looks
like it's correct.

This adds a branch and a read from cr4 to each vm entry.  Because it is
extremely likely that consecutive entries into the same vcpu will have
the same host cr4 value, this fixes up the vmcs instead of restoring cr4
after the fact.  A subsequent patch will add a kernel-wide cr4 shadow,
reducing the overhead in the common case to just two memory reads and a
branch.

Signed-off-by: Andy Lutomirski <luto@amacapital.net>
Acked-by: Paolo Bonzini <pbonzini@redhat.com>
Cc: stable@vger.kernel.org
Cc: Petr Matousek <pmatouse@redhat.com>
Cc: Gleb Natapov <gleb@kernel.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",d974baa398f34393db76be45f7d4d04fbdbb4a0a,https://github.com/torvalds/linux/commit/d974baa398f34393db76be45f7d4d04fbdbb4a0a,arch/x86/kvm/vmx.c,vmx_set_constant_host_state,"static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)
{
u32 low32, high32;
unsigned long tmpl;
struct desc_ptr dt;
vmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  
vmcs_writel(HOST_CR4, read_cr4());  
vmcs_writel(HOST_CR3, read_cr3());  
vmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  
#ifdef CONFIG_X86_64
vmcs_write16(HOST_DS_SELECTOR, 0);
vmcs_write16(HOST_ES_SELECTOR, 0);
#else
vmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  
vmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  
#endif
vmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  
vmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  
native_store_idt(&dt);
vmcs_writel(HOST_IDTR_BASE, dt.address);   
vmx->host_idt_base = dt.address;
vmcs_writel(HOST_RIP, vmx_return); 
rdmsr(MSR_IA32_SYSENTER_CS, low32, high32);
vmcs_write32(HOST_IA32_SYSENTER_CS, low32);
rdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);
vmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   
if (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {
rdmsr(MSR_IA32_CR_PAT, low32, high32);
vmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));
}
}","static void vmx_set_constant_host_state(struct vcpu_vmx *VAR_0)
{
u32 VAR_1, VAR_2;
unsigned long VAR_3;
struct desc_ptr VAR_4;
vmcs_writel(VAR_5, read_cr0() & ~VAR_6);  
vmcs_writel(VAR_7, read_cr4());  
vmcs_writel(VAR_8, read_cr3());  
vmcs_write16(VAR_9, VAR_10);  
#ifdef VAR_11
vmcs_write16(VAR_12, 0);
vmcs_write16(VAR_13, 0);
#else
vmcs_write16(VAR_12, VAR_14);  
vmcs_write16(VAR_13, VAR_14);  
#endif
vmcs_write16(VAR_15, VAR_14);  
vmcs_write16(VAR_16, VAR_17*8);  
native_store_idt(&VAR_4);
vmcs_writel(VAR_18, VAR_4.address);   
VAR_0->host_idt_base = VAR_4.address;
vmcs_writel(VAR_19, VAR_20); 
rdmsr(VAR_21, VAR_1, VAR_2);
vmcs_write32(VAR_22, VAR_1);
rdmsrl(VAR_23, VAR_3);
vmcs_writel(VAR_24, VAR_3);   
if (VAR_25.vmexit_ctrl & VAR_26) {
rdmsr(VAR_27, VAR_1, VAR_2);
vmcs_write64(VAR_28, VAR_1 | ((u64) VAR_2 << 32));
}
}",torvalds/linux/d974baa398f34393db76be45f7d4d04fbdbb4a0a/vmx.c/vul/before/0.json,"static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)
{
	u32 low32, high32;
	unsigned long tmpl;
	struct desc_ptr dt;
	unsigned long cr4;

	vmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  /* 22.2.3 */
	vmcs_writel(HOST_CR3, read_cr3());  /* 22.2.3  FIXME: shadow tables */

	/* Save the most likely value for this task's CR4 in the VMCS. */
	cr4 = read_cr4();
	vmcs_writel(HOST_CR4, cr4);			/* 22.2.3, 22.2.5 */
	vmx->host_state.vmcs_host_cr4 = cr4;

	vmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */
#ifdef CONFIG_X86_64
	/*
	 * Load null selectors, so we can avoid reloading them in
	 * __vmx_load_host_state(), in case userspace uses the null selectors
	 * too (the expected case).
	 */
	vmcs_write16(HOST_DS_SELECTOR, 0);
	vmcs_write16(HOST_ES_SELECTOR, 0);
#else
	vmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */
	vmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  /* 22.2.4 */
#endif
	vmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */
	vmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  /* 22.2.4 */

	native_store_idt(&dt);
	vmcs_writel(HOST_IDTR_BASE, dt.address);   /* 22.2.4 */
	vmx->host_idt_base = dt.address;

	vmcs_writel(HOST_RIP, vmx_return); /* 22.2.5 */

	rdmsr(MSR_IA32_SYSENTER_CS, low32, high32);
	vmcs_write32(HOST_IA32_SYSENTER_CS, low32);
	rdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);
	vmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   /* 22.2.3 */

	if (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {
		rdmsr(MSR_IA32_CR_PAT, low32, high32);
		vmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));
	}
}","static void vmx_set_constant_host_state(struct vcpu_vmx *VAR_0)
{
	u32 VAR_1, VAR_2;
	unsigned long VAR_3;
	struct desc_ptr VAR_4;
	unsigned long VAR_5;

	vmcs_writel(VAR_6, read_cr0() & ~VAR_7);  /* COMMENT_0 */
	vmcs_writel(VAR_8, read_cr3());  /* COMMENT_1 */

	/* COMMENT_2 */
	VAR_5 = read_cr4();
	vmcs_writel(VAR_9, VAR_5);			/* COMMENT_3 */
	VAR_0->host_state.vmcs_host_cr4 = VAR_5;

	vmcs_write16(VAR_10, VAR_11);  /* COMMENT_4 */
#ifdef VAR_12
	/* COMMENT_5 */
                                                          
                                                                      
                            
    
	vmcs_write16(VAR_13, 0);
	vmcs_write16(VAR_14, 0);
#else
	vmcs_write16(VAR_13, VAR_15);  /* COMMENT_4 */
	vmcs_write16(VAR_14, VAR_15);  /* COMMENT_4 */
#endif
	vmcs_write16(VAR_16, VAR_15);  /* COMMENT_4 */
	vmcs_write16(VAR_17, VAR_18*8);  /* COMMENT_4 */

	native_store_idt(&VAR_4);
	vmcs_writel(VAR_19, VAR_4.address);   /* COMMENT_4 */
	VAR_0->host_idt_base = VAR_4.address;

	vmcs_writel(VAR_20, VAR_21); /* COMMENT_10 */

	rdmsr(VAR_22, VAR_1, VAR_2);
	vmcs_write32(VAR_23, VAR_1);
	rdmsrl(VAR_24, VAR_3);
	vmcs_writel(VAR_25, VAR_3);   /* COMMENT_0 */

	if (VAR_26.vmexit_ctrl & VAR_27) {
		rdmsr(VAR_28, VAR_1, VAR_2);
		vmcs_write64(VAR_29, VAR_1 | ((u64) VAR_2 << 32));
	}
}",torvalds/linux/d974baa398f34393db76be45f7d4d04fbdbb4a0a/vmx.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,10 +3,15 @@
 	u32 low32, high32;
 	unsigned long tmpl;
 	struct desc_ptr dt;
+	unsigned long cr4;
 
 	vmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  /* 22.2.3 */
-	vmcs_writel(HOST_CR4, read_cr4());  /* 22.2.3, 22.2.5 */
 	vmcs_writel(HOST_CR3, read_cr3());  /* 22.2.3  FIXME: shadow tables */
+
+	/* Save the most likely value for this task's CR4 in the VMCS. */
+	cr4 = read_cr4();
+	vmcs_writel(HOST_CR4, cr4);			/* 22.2.3, 22.2.5 */
+	vmx->host_state.vmcs_host_cr4 = cr4;
 
 	vmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */
 #ifdef CONFIG_X86_64","{'deleted_lines': ['\tvmcs_writel(HOST_CR4, read_cr4());  /* 22.2.3, 22.2.5 */'], 'added_lines': ['\tunsigned long cr4;', '', ""\t/* Save the most likely value for this task's CR4 in the VMCS. */"", '\tcr4 = read_cr4();', '\tvmcs_writel(HOST_CR4, cr4);\t\t\t/* 22.2.3, 22.2.5 */', '\tvmx->host_state.vmcs_host_cr4 = cr4;']}",True,"arch/x86/kvm/vmx.c in the KVM subsystem in the Linux kernel before 3.17.2 on Intel processors does not ensure that the value in the CR4 control register remains the same after a VM entry, which allows host OS users to kill arbitrary processes or cause a denial of service (system disruption) by leveraging /dev/kvm access, as demonstrated by PR_SET_TSC prctl calls within a modified copy of QEMU.",5.5,MEDIUM,1,test,2014-10-08T16:02:13Z,1
CVE-2014-9629,['CWE-120'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,videolan/vlc,"codec: schroedinger: fix potential buffer overflow.

The variable len is a raw 32 bit value read using GetDWBE. If this
value is larger than UINT32_MAX - sizeof(eos), this will cause an
integer overflow in the subsequent call to malloc, and finally a
buffer overflow when calling memcpy. We fix this by checking len
accordingly.

Signed-off-by: Jean-Baptiste Kempf <jb@videolan.org>",9bb0353a5c63a7f8c6fc853faa3df4b4df1f5eb5,https://github.com/videolan/vlc/commit/9bb0353a5c63a7f8c6fc853faa3df4b4df1f5eb5,modules/codec/schroedinger.c,Encode,"static block_t *Encode( encoder_t *p_enc, picture_t *p_pic )
{
encoder_sys_t *p_sys = p_enc->p_sys;
block_t *p_block, *p_output_chain = NULL;
SchroFrame *p_frame;
bool b_go = true;
if( !p_pic ) {
if( !p_sys->started || p_sys->b_eos_pulled )
return NULL;
if( !p_sys->b_eos_signalled ) {
p_sys->b_eos_signalled = 1;
schro_encoder_end_of_stream( p_sys->p_schro );
}
} else {
p_sys->p_format->interlaced = !p_pic->b_progressive;
p_sys->p_format->top_field_first = p_pic->b_top_field_first;
if( p_sys->b_auto_field_coding )
schro_encoder_setting_set_double( p_sys->p_schro, ""interlaced_coding"", !p_pic->b_progressive );
}
if( !p_sys->started ) {
date_t date;
if( p_pic->format.i_chroma != p_enc->fmt_in.i_codec ) {
char chroma_in[5], chroma_out[5];
vlc_fourcc_to_char( p_pic->format.i_chroma, chroma_in );
chroma_in[4]  = '\0';
chroma_out[4] = '\0';
vlc_fourcc_to_char( p_enc->fmt_in.i_codec, chroma_out );
msg_Warn( p_enc, ""Resetting chroma from %s to %s"", chroma_out, chroma_in );
if( !SetEncChromaFormat( p_enc, p_pic->format.i_chroma ) ) {
msg_Err( p_enc, ""Could not reset chroma format to %s"", chroma_in );
return NULL;
}
}
date_Init( &date, p_enc->fmt_in.video.i_frame_rate, p_enc->fmt_in.video.i_frame_rate_base );
date_Increment( &date, 1 );
p_sys->i_pts_offset = date_Get( &date );
if( schro_encoder_setting_get_double( p_sys->p_schro, ""interlaced_coding"" ) > 0.0 ) {
date_Set( &date, 0 );
date_Increment( &date, 1);
p_sys->i_field_time = date_Get( &date ) / 2;
}
schro_video_format_set_std_signal_range( p_sys->p_format, SCHRO_SIGNAL_RANGE_8BIT_VIDEO );
schro_encoder_set_video_format( p_sys->p_schro, p_sys->p_format );
schro_encoder_start( p_sys->p_schro );
p_sys->started = 1;
}
if( !p_sys->b_eos_signalled ) {
picture_Hold( p_pic );
p_frame = CreateSchroFrameFromInputPic( p_enc, p_pic );
if( !p_frame )
return NULL;
schro_encoder_push_frame( p_sys->p_schro, p_frame );
StorePicturePTS( p_enc, p_sys->i_input_picnum, p_pic->date );
p_sys->i_input_picnum++;
p_block = block_Alloc( 1 );
if( !p_block )
return NULL;
p_block->i_dts = p_pic->date - p_sys->i_pts_offset;
block_FifoPut( p_sys->p_dts_fifo, p_block );
p_block = NULL;
if( schro_encoder_setting_get_double( p_sys->p_schro, ""interlaced_coding"" ) > 0.0 ) {
StorePicturePTS( p_enc, p_sys->i_input_picnum, p_pic->date + p_sys->i_field_time );
p_sys->i_input_picnum++;
p_block = block_Alloc( 1 );
if( !p_block )
return NULL;
p_block->i_dts = p_pic->date - p_sys->i_pts_offset + p_sys->i_field_time;
block_FifoPut( p_sys->p_dts_fifo, p_block );
p_block = NULL;
}
}
do
{
SchroStateEnum state;
state = schro_encoder_wait( p_sys->p_schro );
switch( state )
{
case SCHRO_STATE_NEED_FRAME:
b_go = false;
break;
case SCHRO_STATE_AGAIN:
break;
case SCHRO_STATE_END_OF_STREAM:
p_sys->b_eos_pulled = 1;
b_go = false;
break;
case SCHRO_STATE_HAVE_BUFFER:
{
SchroBuffer *p_enc_buf;
uint32_t u_pic_num;
int i_presentation_frame;
p_enc_buf = schro_encoder_pull( p_sys->p_schro, &i_presentation_frame );
p_block = block_Alloc( p_enc_buf->length );
if( !p_block )
return NULL;
memcpy( p_block->p_buffer, p_enc_buf->data, p_enc_buf->length );
schro_buffer_unref( p_enc_buf );
if( 0 == p_block->p_buffer[4] )
{
p_block->i_flags |= BLOCK_FLAG_TYPE_I;
if( !p_enc->fmt_out.p_extra ) {
const uint8_t eos[] = { 'B','B','C','D',0x10,0,0,0,13,0,0,0,0 };
uint32_t len = GetDWBE( p_block->p_buffer + 5 );
p_enc->fmt_out.p_extra = malloc( len + sizeof( eos ) );
if( !p_enc->fmt_out.p_extra )
return NULL;
memcpy( p_enc->fmt_out.p_extra, p_block->p_buffer, len );
memcpy( (uint8_t*)p_enc->fmt_out.p_extra + len, eos, sizeof( eos ) );
SetDWBE( (uint8_t*)p_enc->fmt_out.p_extra + len + sizeof(eos) - 4, len );
p_enc->fmt_out.i_extra = len + sizeof( eos );
}
}
if( ReadDiracPictureNumber( &u_pic_num, p_block ) ) {
block_t *p_dts_block = block_FifoGet( p_sys->p_dts_fifo );
p_block->i_dts = p_dts_block->i_dts;
p_block->i_pts = GetPicturePTS( p_enc, u_pic_num );
block_Release( p_dts_block );
block_ChainAppend( &p_output_chain, p_block );
} else {
block_ChainAppend( &p_output_chain, p_block );
}
break;
}
default:
break;
}
} while( b_go );
return p_output_chain;
}","static block_t *Encode( encoder_t *VAR_0, picture_t *VAR_1 )
{
encoder_sys_t *VAR_2 = VAR_0->p_sys;
block_t *VAR_3, *VAR_4 = NULL;
SchroFrame *VAR_5;
bool VAR_6 = true;
if( !VAR_1 ) {
if( !VAR_2->started || VAR_2->b_eos_pulled )
return NULL;
if( !VAR_2->b_eos_signalled ) {
VAR_2->b_eos_signalled = 1;
schro_encoder_end_of_stream( VAR_2->p_schro );
}
} else {
VAR_2->p_format->interlaced = !VAR_1->b_progressive;
VAR_2->p_format->top_field_first = VAR_1->b_top_field_first;
if( VAR_2->b_auto_field_coding )
schro_encoder_setting_set_double( VAR_2->p_schro, ""interlaced_coding"", !VAR_1->b_progressive );
}
if( !VAR_2->started ) {
date_t VAR_7;
if( VAR_1->format.i_chroma != VAR_0->fmt_in.i_codec ) {
char VAR_8[5], VAR_9[5];
vlc_fourcc_to_char( VAR_1->format.i_chroma, VAR_8 );
VAR_8[4]  = '\0';
VAR_9[4] = '\0';
vlc_fourcc_to_char( VAR_0->fmt_in.i_codec, VAR_9 );
msg_Warn( VAR_0, ""Resetting chroma from %s to %s"", VAR_9, VAR_8 );
if( !SetEncChromaFormat( VAR_0, VAR_1->format.i_chroma ) ) {
msg_Err( VAR_0, ""Could not reset chroma format to %s"", VAR_8 );
return NULL;
}
}
date_Init( &VAR_7, VAR_0->fmt_in.video.i_frame_rate, VAR_0->fmt_in.video.i_frame_rate_base );
date_Increment( &VAR_7, 1 );
VAR_2->i_pts_offset = date_Get( &VAR_7 );
if( schro_encoder_setting_get_double( VAR_2->p_schro, ""interlaced_coding"" ) > 0.0 ) {
date_Set( &VAR_7, 0 );
date_Increment( &VAR_7, 1);
VAR_2->i_field_time = date_Get( &VAR_7 ) / 2;
}
schro_video_format_set_std_signal_range( VAR_2->p_format, VAR_10 );
schro_encoder_set_video_format( VAR_2->p_schro, VAR_2->p_format );
schro_encoder_start( VAR_2->p_schro );
VAR_2->started = 1;
}
if( !VAR_2->b_eos_signalled ) {
picture_Hold( VAR_1 );
VAR_5 = CreateSchroFrameFromInputPic( VAR_0, VAR_1 );
if( !VAR_5 )
return NULL;
schro_encoder_push_frame( VAR_2->p_schro, VAR_5 );
StorePicturePTS( VAR_0, VAR_2->i_input_picnum, VAR_1->date );
VAR_2->i_input_picnum++;
VAR_3 = block_Alloc( 1 );
if( !VAR_3 )
return NULL;
VAR_3->i_dts = VAR_1->date - VAR_2->i_pts_offset;
block_FifoPut( VAR_2->p_dts_fifo, VAR_3 );
VAR_3 = NULL;
if( schro_encoder_setting_get_double( VAR_2->p_schro, ""interlaced_coding"" ) > 0.0 ) {
StorePicturePTS( VAR_0, VAR_2->i_input_picnum, VAR_1->date + VAR_2->i_field_time );
VAR_2->i_input_picnum++;
VAR_3 = block_Alloc( 1 );
if( !VAR_3 )
return NULL;
VAR_3->i_dts = VAR_1->date - VAR_2->i_pts_offset + VAR_2->i_field_time;
block_FifoPut( VAR_2->p_dts_fifo, VAR_3 );
VAR_3 = NULL;
}
}
do
{
SchroStateEnum VAR_11;
VAR_11 = schro_encoder_wait( VAR_2->p_schro );
switch( VAR_11 )
{
case VAR_12:
VAR_6 = false;
break;
case VAR_13:
break;
case VAR_14:
VAR_2->b_eos_pulled = 1;
VAR_6 = false;
break;
case VAR_15:
{
SchroBuffer *VAR_16;
uint32_t VAR_17;
int VAR_18;
VAR_16 = schro_encoder_pull( VAR_2->p_schro, &VAR_18 );
VAR_3 = block_Alloc( VAR_16->length );
if( !VAR_3 )
return NULL;
memcpy( VAR_3->p_buffer, VAR_16->data, VAR_16->length );
schro_buffer_unref( VAR_16 );
if( 0 == VAR_3->p_buffer[4] )
{
VAR_3->i_flags |= VAR_19;
if( !VAR_0->fmt_out.p_extra ) {
const uint8_t VAR_20[] = { 'B','B','C','D',0x10,0,0,0,13,0,0,0,0 };
uint32_t VAR_21 = GetDWBE( VAR_3->p_buffer + 5 );
VAR_0->fmt_out.p_extra = malloc( VAR_21 + sizeof( VAR_20 ) );
if( !VAR_0->fmt_out.p_extra )
return NULL;
memcpy( VAR_0->fmt_out.p_extra, VAR_3->p_buffer, VAR_21 );
memcpy( (uint8_t*)VAR_0->fmt_out.p_extra + VAR_21, VAR_20, sizeof( VAR_20 ) );
SetDWBE( (uint8_t*)VAR_0->fmt_out.p_extra + VAR_21 + sizeof(VAR_20) - 4, VAR_21 );
VAR_0->fmt_out.i_extra = VAR_21 + sizeof( VAR_20 );
}
}
if( ReadDiracPictureNumber( &VAR_17, VAR_3 ) ) {
block_t *VAR_22 = block_FifoGet( VAR_2->p_dts_fifo );
VAR_3->i_dts = VAR_22->i_dts;
VAR_3->i_pts = GetPicturePTS( VAR_0, VAR_17 );
block_Release( VAR_22 );
block_ChainAppend( &VAR_4, VAR_3 );
} else {
block_ChainAppend( &VAR_4, VAR_3 );
}
break;
}
default:
break;
}
} while( VAR_6 );
return VAR_4;
}",videolan/vlc/9bb0353a5c63a7f8c6fc853faa3df4b4df1f5eb5/schroedinger.c/vul/before/0.json,"static block_t *Encode( encoder_t *p_enc, picture_t *p_pic )
{
    encoder_sys_t *p_sys = p_enc->p_sys;
    block_t *p_block, *p_output_chain = NULL;
    SchroFrame *p_frame;
    bool b_go = true;

    if( !p_pic ) {
        if( !p_sys->started || p_sys->b_eos_pulled )
            return NULL;

        if( !p_sys->b_eos_signalled ) {
            p_sys->b_eos_signalled = 1;
            schro_encoder_end_of_stream( p_sys->p_schro );
        }
    } else {
        /* we only know if the sequence is interlaced when the first
         * picture arrives, so final setup is done here */
        /* XXX todo, detect change of interlace */
        p_sys->p_format->interlaced = !p_pic->b_progressive;
        p_sys->p_format->top_field_first = p_pic->b_top_field_first;

        if( p_sys->b_auto_field_coding )
            schro_encoder_setting_set_double( p_sys->p_schro, ""interlaced_coding"", !p_pic->b_progressive );
    }

    if( !p_sys->started ) {
        date_t date;

        if( p_pic->format.i_chroma != p_enc->fmt_in.i_codec ) {
            char chroma_in[5], chroma_out[5];
            vlc_fourcc_to_char( p_pic->format.i_chroma, chroma_in );
            chroma_in[4]  = '\0';
            chroma_out[4] = '\0';
            vlc_fourcc_to_char( p_enc->fmt_in.i_codec, chroma_out );
            msg_Warn( p_enc, ""Resetting chroma from %s to %s"", chroma_out, chroma_in );
            if( !SetEncChromaFormat( p_enc, p_pic->format.i_chroma ) ) {
                msg_Err( p_enc, ""Could not reset chroma format to %s"", chroma_in );
                return NULL;
            }
        }

        date_Init( &date, p_enc->fmt_in.video.i_frame_rate, p_enc->fmt_in.video.i_frame_rate_base );
        /* FIXME - Unlike dirac-research codec Schro doesn't have a function that returns the delay in pics yet.
         *   Use a default of 1
         */
        date_Increment( &date, 1 );
        p_sys->i_pts_offset = date_Get( &date );
        if( schro_encoder_setting_get_double( p_sys->p_schro, ""interlaced_coding"" ) > 0.0 ) {
            date_Set( &date, 0 );
            date_Increment( &date, 1);
            p_sys->i_field_time = date_Get( &date ) / 2;
        }

        schro_video_format_set_std_signal_range( p_sys->p_format, SCHRO_SIGNAL_RANGE_8BIT_VIDEO );
        schro_encoder_set_video_format( p_sys->p_schro, p_sys->p_format );
        schro_encoder_start( p_sys->p_schro );
        p_sys->started = 1;
    }

    if( !p_sys->b_eos_signalled ) {
        /* create a schro frame from the input pic and load */
        /* Increase ref count by 1 so that the picture is not freed until
           Schro finishes with it */
        picture_Hold( p_pic );

        p_frame = CreateSchroFrameFromInputPic( p_enc, p_pic );
        if( !p_frame )
            return NULL;
        schro_encoder_push_frame( p_sys->p_schro, p_frame );


        /* store pts in a lookaside buffer, so that the same pts may
        * be used for the picture in coded order */
        StorePicturePTS( p_enc, p_sys->i_input_picnum, p_pic->date );
        p_sys->i_input_picnum++;

        /* store dts in a queue, so that they appear in order in
         * coded order */
        p_block = block_Alloc( 1 );
        if( !p_block )
            return NULL;
        p_block->i_dts = p_pic->date - p_sys->i_pts_offset;
        block_FifoPut( p_sys->p_dts_fifo, p_block );
        p_block = NULL;

        /* for field coding mode, insert an extra value into both the
         * pts lookaside buffer and dts queue, offset to correspond
         * to a one field delay. */
        if( schro_encoder_setting_get_double( p_sys->p_schro, ""interlaced_coding"" ) > 0.0 ) {
            StorePicturePTS( p_enc, p_sys->i_input_picnum, p_pic->date + p_sys->i_field_time );
            p_sys->i_input_picnum++;

            p_block = block_Alloc( 1 );
            if( !p_block )
                return NULL;
            p_block->i_dts = p_pic->date - p_sys->i_pts_offset + p_sys->i_field_time;
            block_FifoPut( p_sys->p_dts_fifo, p_block );
            p_block = NULL;
        }
    }

    do
    {
        SchroStateEnum state;
        state = schro_encoder_wait( p_sys->p_schro );
        switch( state )
        {
        case SCHRO_STATE_NEED_FRAME:
            b_go = false;
            break;
        case SCHRO_STATE_AGAIN:
            break;
        case SCHRO_STATE_END_OF_STREAM:
            p_sys->b_eos_pulled = 1;
            b_go = false;
            break;
        case SCHRO_STATE_HAVE_BUFFER:
        {
            SchroBuffer *p_enc_buf;
            uint32_t u_pic_num;
            int i_presentation_frame;
            p_enc_buf = schro_encoder_pull( p_sys->p_schro, &i_presentation_frame );
            p_block = block_Alloc( p_enc_buf->length );
            if( !p_block )
                return NULL;

            memcpy( p_block->p_buffer, p_enc_buf->data, p_enc_buf->length );
            schro_buffer_unref( p_enc_buf );

            /* Presence of a Sequence header indicates a seek point */
            if( 0 == p_block->p_buffer[4] )
            {
                p_block->i_flags |= BLOCK_FLAG_TYPE_I;

                if( !p_enc->fmt_out.p_extra ) {
                    const uint8_t eos[] = { 'B','B','C','D',0x10,0,0,0,13,0,0,0,0 };
                    uint32_t len = GetDWBE( p_block->p_buffer + 5 );
                    /* if it hasn't been done so far, stash a copy of the
                     * sequence header for muxers such as ogg */
                    /* The OggDirac spec advises that a Dirac EOS DataUnit
                     * is appended to the sequence header to allow guard
                     * against poor streaming servers */
                    /* XXX, should this be done using the packetizer ? */

                    if( len > UINT32_MAX - sizeof( eos ) )
                        return NULL;

                    p_enc->fmt_out.p_extra = malloc( len + sizeof( eos ) );
                    if( !p_enc->fmt_out.p_extra )
                        return NULL;
                    memcpy( p_enc->fmt_out.p_extra, p_block->p_buffer, len );
                    memcpy( (uint8_t*)p_enc->fmt_out.p_extra + len, eos, sizeof( eos ) );
                    SetDWBE( (uint8_t*)p_enc->fmt_out.p_extra + len + sizeof(eos) - 4, len );
                    p_enc->fmt_out.i_extra = len + sizeof( eos );
                }
            }

            if( ReadDiracPictureNumber( &u_pic_num, p_block ) ) {
                block_t *p_dts_block = block_FifoGet( p_sys->p_dts_fifo );
                p_block->i_dts = p_dts_block->i_dts;
                   p_block->i_pts = GetPicturePTS( p_enc, u_pic_num );
                block_Release( p_dts_block );
                block_ChainAppend( &p_output_chain, p_block );
            } else {
                /* End of sequence */
                block_ChainAppend( &p_output_chain, p_block );
            }
            break;
        }
        default:
            break;
        }
    } while( b_go );

    return p_output_chain;
}","static block_t *Encode( encoder_t *VAR_0, picture_t *VAR_1 )
{
    encoder_sys_t *VAR_2 = VAR_0->p_sys;
    block_t *VAR_3, *VAR_4 = NULL;
    SchroFrame *VAR_5;
    bool VAR_6 = true;

    if( !VAR_1 ) {
        if( !VAR_2->started || VAR_2->b_eos_pulled )
            return NULL;

        if( !VAR_2->b_eos_signalled ) {
            VAR_2->b_eos_signalled = 1;
            schro_encoder_end_of_stream( VAR_2->p_schro );
        }
    } else {
        /* COMMENT_0 */
                                                          
        /* COMMENT_2 */
        VAR_2->p_format->interlaced = !VAR_1->b_progressive;
        VAR_2->p_format->top_field_first = VAR_1->b_top_field_first;

        if( VAR_2->b_auto_field_coding )
            schro_encoder_setting_set_double( VAR_2->p_schro, ""interlaced_coding"", !VAR_1->b_progressive );
    }

    if( !VAR_2->started ) {
        date_t VAR_7;

        if( VAR_1->format.i_chroma != VAR_0->fmt_in.i_codec ) {
            char VAR_8[5], VAR_9[5];
            vlc_fourcc_to_char( VAR_1->format.i_chroma, VAR_8 );
            VAR_8[4]  = '\0';
            VAR_9[4] = '\0';
            vlc_fourcc_to_char( VAR_0->fmt_in.i_codec, VAR_9 );
            msg_Warn( VAR_0, ""Resetting chroma from %s to %s"", VAR_9, VAR_8 );
            if( !SetEncChromaFormat( VAR_0, VAR_1->format.i_chroma ) ) {
                msg_Err( VAR_0, ""Could not reset chroma format to %s"", VAR_8 );
                return NULL;
            }
        }

        date_Init( &VAR_7, VAR_0->fmt_in.video.i_frame_rate, VAR_0->fmt_in.video.i_frame_rate_base );
        /* COMMENT_3 */
                               
           
        date_Increment( &VAR_7, 1 );
        VAR_2->i_pts_offset = date_Get( &VAR_7 );
        if( schro_encoder_setting_get_double( VAR_2->p_schro, ""interlaced_coding"" ) > 0.0 ) {
            date_Set( &VAR_7, 0 );
            date_Increment( &VAR_7, 1);
            VAR_2->i_field_time = date_Get( &VAR_7 ) / 2;
        }

        schro_video_format_set_std_signal_range( VAR_2->p_format, VAR_10 );
        schro_encoder_set_video_format( VAR_2->p_schro, VAR_2->p_format );
        schro_encoder_start( VAR_2->p_schro );
        VAR_2->started = 1;
    }

    if( !VAR_2->b_eos_signalled ) {
        /* COMMENT_6 */
        /* COMMENT_7 */
                                    
        picture_Hold( VAR_1 );

        VAR_5 = CreateSchroFrameFromInputPic( VAR_0, VAR_1 );
        if( !VAR_5 )
            return NULL;
        schro_encoder_push_frame( VAR_2->p_schro, VAR_5 );


        /* COMMENT_9 */
                                                   
        StorePicturePTS( VAR_0, VAR_2->i_input_picnum, VAR_1->date );
        VAR_2->i_input_picnum++;

        /* COMMENT_11 */
                         
        VAR_3 = block_Alloc( 1 );
        if( !VAR_3 )
            return NULL;
        VAR_3->i_dts = VAR_1->date - VAR_2->i_pts_offset;
        block_FifoPut( VAR_2->p_dts_fifo, VAR_3 );
        VAR_3 = NULL;

        /* COMMENT_13 */
                                                                   
                                   
        if( schro_encoder_setting_get_double( VAR_2->p_schro, ""interlaced_coding"" ) > 0.0 ) {
            StorePicturePTS( VAR_0, VAR_2->i_input_picnum, VAR_1->date + VAR_2->i_field_time );
            VAR_2->i_input_picnum++;

            VAR_3 = block_Alloc( 1 );
            if( !VAR_3 )
                return NULL;
            VAR_3->i_dts = VAR_1->date - VAR_2->i_pts_offset + VAR_2->i_field_time;
            block_FifoPut( VAR_2->p_dts_fifo, VAR_3 );
            VAR_3 = NULL;
        }
    }

    do
    {
        SchroStateEnum VAR_11;
        VAR_11 = schro_encoder_wait( VAR_2->p_schro );
        switch( VAR_11 )
        {
        case VAR_12:
            VAR_6 = false;
            break;
        case VAR_13:
            break;
        case VAR_14:
            VAR_2->b_eos_pulled = 1;
            VAR_6 = false;
            break;
        case VAR_15:
        {
            SchroBuffer *VAR_16;
            uint32_t VAR_17;
            int VAR_18;
            VAR_16 = schro_encoder_pull( VAR_2->p_schro, &VAR_18 );
            VAR_3 = block_Alloc( VAR_16->length );
            if( !VAR_3 )
                return NULL;

            memcpy( VAR_3->p_buffer, VAR_16->data, VAR_16->length );
            schro_buffer_unref( VAR_16 );

            /* COMMENT_16 */
            if( 0 == VAR_3->p_buffer[4] )
            {
                VAR_3->i_flags |= VAR_19;

                if( !VAR_0->fmt_out.p_extra ) {
                    const uint8_t VAR_20[] = { 'B','B','C','D',0x10,0,0,0,13,0,0,0,0 };
                    uint32_t VAR_21 = GetDWBE( VAR_3->p_buffer + 5 );
                    /* COMMENT_17 */
                                                                
                    /* COMMENT_19 */
                                                                        
                                                        
                    /* COMMENT_22 */

                    if( VAR_21 > VAR_22 - sizeof( VAR_20 ) )
                        return NULL;

                    VAR_0->fmt_out.p_extra = malloc( VAR_21 + sizeof( VAR_20 ) );
                    if( !VAR_0->fmt_out.p_extra )
                        return NULL;
                    memcpy( VAR_0->fmt_out.p_extra, VAR_3->p_buffer, VAR_21 );
                    memcpy( (uint8_t*)VAR_0->fmt_out.p_extra + VAR_21, VAR_20, sizeof( VAR_20 ) );
                    SetDWBE( (uint8_t*)VAR_0->fmt_out.p_extra + VAR_21 + sizeof(VAR_20) - 4, VAR_21 );
                    VAR_0->fmt_out.i_extra = VAR_21 + sizeof( VAR_20 );
                }
            }

            if( ReadDiracPictureNumber( &VAR_17, VAR_3 ) ) {
                block_t *VAR_23 = block_FifoGet( VAR_2->p_dts_fifo );
                VAR_3->i_dts = VAR_23->i_dts;
                   VAR_3->i_pts = GetPicturePTS( VAR_0, VAR_17 );
                block_Release( VAR_23 );
                block_ChainAppend( &VAR_4, VAR_3 );
            } else {
                /* COMMENT_23 */
                block_ChainAppend( &VAR_4, VAR_3 );
            }
            break;
        }
        default:
            break;
        }
    } while( VAR_6 );

    return VAR_4;
}",videolan/vlc/9bb0353a5c63a7f8c6fc853faa3df4b4df1f5eb5/schroedinger.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -142,6 +142,10 @@
                      * is appended to the sequence header to allow guard
                      * against poor streaming servers */
                     /* XXX, should this be done using the packetizer ? */
+
+                    if( len > UINT32_MAX - sizeof( eos ) )
+                        return NULL;
+
                     p_enc->fmt_out.p_extra = malloc( len + sizeof( eos ) );
                     if( !p_enc->fmt_out.p_extra )
                         return NULL;","{'deleted_lines': [], 'added_lines': ['', '                    if( len > UINT32_MAX - sizeof( eos ) )', '                        return NULL;', '']}",True,Integer overflow in the Encode function in modules/codec/schroedinger.c in VideoLAN VLC media player before 2.1.6 and 2.2.x before 2.2.1 allows remote attackers to conduct buffer overflow attacks and execute arbitrary code via a crafted length value.,7.8,HIGH,2,test,2014-12-05T14:18:22Z,1
CVE-2017-15868,['CWE-20'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"Bluetooth: bnep: bnep_add_connection() should verify that it's dealing with l2cap socket

same story as cmtp

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
Signed-off-by: Marcel Holtmann <marcel@holtmann.org>",71bb99a02b32b4cc4265118e85f6035ca72923f0,https://github.com/torvalds/linux/commit/71bb99a02b32b4cc4265118e85f6035ca72923f0,net/bluetooth/bnep/core.c,bnep_add_connection,"int bnep_add_connection(struct bnep_connadd_req *req, struct socket *sock)
{
struct net_device *dev;
struct bnep_session *s, *ss;
u8 dst[ETH_ALEN], src[ETH_ALEN];
int err;
BT_DBG("""");
baswap((void *) dst, &l2cap_pi(sock->sk)->chan->dst);
baswap((void *) src, &l2cap_pi(sock->sk)->chan->src);
dev = alloc_netdev(sizeof(struct bnep_session),
(*req->device) ? req->device : ""bnep%d"",
NET_NAME_UNKNOWN,
bnep_net_setup);
if (!dev)
return -ENOMEM;
down_write(&bnep_session_sem);
ss = __bnep_get_session(dst);
if (ss && ss->state == BT_CONNECTED) {
err = -EEXIST;
goto failed;
}
s = netdev_priv(dev);
memcpy(s->eh.h_dest,   &src, ETH_ALEN);
memcpy(s->eh.h_source, &dst, ETH_ALEN);
memcpy(dev->dev_addr, s->eh.h_dest, ETH_ALEN);
s->dev   = dev;
s->sock  = sock;
s->role  = req->role;
s->state = BT_CONNECTED;
s->msg.msg_flags = MSG_NOSIGNAL;
#ifdef CONFIG_BT_BNEP_MC_FILTER
set_bit(bnep_mc_hash(dev->broadcast), (ulong *) &s->mc_filter);
#endif
#ifdef CONFIG_BT_BNEP_PROTO_FILTER
bnep_set_default_proto_filter(s);
#endif
SET_NETDEV_DEV(dev, bnep_get_device(s));
SET_NETDEV_DEVTYPE(dev, &bnep_type);
err = register_netdev(dev);
if (err)
goto failed;
__bnep_link_session(s);
__module_get(THIS_MODULE);
s->task = kthread_run(bnep_session, s, ""kbnepd %s"", dev->name);
if (IS_ERR(s->task)) {
module_put(THIS_MODULE);
unregister_netdev(dev);
__bnep_unlink_session(s);
err = PTR_ERR(s->task);
goto failed;
}
up_write(&bnep_session_sem);
strcpy(req->device, dev->name);
return 0;
failed:
up_write(&bnep_session_sem);
free_netdev(dev);
return err;
}","int bnep_add_connection(struct bnep_connadd_req *VAR_0, struct socket *VAR_1)
{
struct net_device *VAR_2;
struct bnep_session *VAR_3, *VAR_4;
u8 VAR_5[VAR_6], VAR_7[VAR_6];
int VAR_8;
BT_DBG("""");
baswap((void *) VAR_5, &l2cap_pi(VAR_1->sk)->chan->dst);
baswap((void *) VAR_7, &l2cap_pi(VAR_1->sk)->chan->src);
VAR_2 = alloc_netdev(sizeof(struct bnep_session),
(*VAR_0->device) ? VAR_0->device : ""bnep%d"",
VAR_9,
VAR_10);
if (!VAR_2)
return -VAR_11;
down_write(&VAR_12);
VAR_4 = __bnep_get_session(VAR_5);
if (VAR_4 && VAR_4->state == VAR_13) {
VAR_8 = -VAR_14;
goto failed;
}
VAR_3 = netdev_priv(VAR_2);
memcpy(VAR_3->eh.h_dest,   &VAR_7, VAR_6);
memcpy(VAR_3->eh.h_source, &VAR_5, VAR_6);
memcpy(VAR_2->dev_addr, VAR_3->eh.h_dest, VAR_6);
VAR_3->dev   = VAR_2;
VAR_3->sock  = VAR_1;
VAR_3->role  = VAR_0->role;
VAR_3->state = VAR_13;
VAR_3->msg.msg_flags = VAR_15;
#ifdef VAR_16
set_bit(bnep_mc_hash(VAR_2->broadcast), (ulong *) &VAR_3->mc_filter);
#endif
#ifdef VAR_17
bnep_set_default_proto_filter(VAR_3);
#endif
SET_NETDEV_DEV(VAR_2, bnep_get_device(VAR_3));
SET_NETDEV_DEVTYPE(VAR_2, &VAR_18);
VAR_8 = register_netdev(VAR_2);
if (VAR_8)
goto failed;
__bnep_link_session(VAR_3);
__module_get(VAR_19);
VAR_3->task = kthread_run(bnep_session, VAR_3, ""kbnepd %s"", VAR_2->name);
if (IS_ERR(VAR_3->task)) {
module_put(VAR_19);
unregister_netdev(VAR_2);
__bnep_unlink_session(VAR_3);
VAR_8 = PTR_ERR(VAR_3->task);
goto failed;
}
up_write(&VAR_12);
strcpy(VAR_0->device, VAR_2->name);
return 0;
failed:
up_write(&VAR_12);
free_netdev(VAR_2);
return VAR_8;
}",torvalds/linux/71bb99a02b32b4cc4265118e85f6035ca72923f0/core.c/vul/before/0.json,"int bnep_add_connection(struct bnep_connadd_req *req, struct socket *sock)
{
	struct net_device *dev;
	struct bnep_session *s, *ss;
	u8 dst[ETH_ALEN], src[ETH_ALEN];
	int err;

	BT_DBG("""");

	if (!l2cap_is_socket(sock))
		return -EBADFD;

	baswap((void *) dst, &l2cap_pi(sock->sk)->chan->dst);
	baswap((void *) src, &l2cap_pi(sock->sk)->chan->src);

	/* session struct allocated as private part of net_device */
	dev = alloc_netdev(sizeof(struct bnep_session),
			   (*req->device) ? req->device : ""bnep%d"",
			   NET_NAME_UNKNOWN,
			   bnep_net_setup);
	if (!dev)
		return -ENOMEM;

	down_write(&bnep_session_sem);

	ss = __bnep_get_session(dst);
	if (ss && ss->state == BT_CONNECTED) {
		err = -EEXIST;
		goto failed;
	}

	s = netdev_priv(dev);

	/* This is rx header therefore addresses are swapped.
	 * ie. eh.h_dest is our local address. */
	memcpy(s->eh.h_dest,   &src, ETH_ALEN);
	memcpy(s->eh.h_source, &dst, ETH_ALEN);
	memcpy(dev->dev_addr, s->eh.h_dest, ETH_ALEN);

	s->dev   = dev;
	s->sock  = sock;
	s->role  = req->role;
	s->state = BT_CONNECTED;

	s->msg.msg_flags = MSG_NOSIGNAL;

#ifdef CONFIG_BT_BNEP_MC_FILTER
	/* Set default mc filter */
	set_bit(bnep_mc_hash(dev->broadcast), (ulong *) &s->mc_filter);
#endif

#ifdef CONFIG_BT_BNEP_PROTO_FILTER
	/* Set default protocol filter */
	bnep_set_default_proto_filter(s);
#endif

	SET_NETDEV_DEV(dev, bnep_get_device(s));
	SET_NETDEV_DEVTYPE(dev, &bnep_type);

	err = register_netdev(dev);
	if (err)
		goto failed;

	__bnep_link_session(s);

	__module_get(THIS_MODULE);
	s->task = kthread_run(bnep_session, s, ""kbnepd %s"", dev->name);
	if (IS_ERR(s->task)) {
		/* Session thread start failed, gotta cleanup. */
		module_put(THIS_MODULE);
		unregister_netdev(dev);
		__bnep_unlink_session(s);
		err = PTR_ERR(s->task);
		goto failed;
	}

	up_write(&bnep_session_sem);
	strcpy(req->device, dev->name);
	return 0;

failed:
	up_write(&bnep_session_sem);
	free_netdev(dev);
	return err;
}","int bnep_add_connection(struct bnep_connadd_req *VAR_0, struct socket *VAR_1)
{
	struct net_device *VAR_2;
	struct bnep_session *VAR_3, *VAR_4;
	u8 VAR_5[VAR_6], VAR_7[VAR_6];
	int VAR_8;

	BT_DBG("""");

	if (!l2cap_is_socket(VAR_1))
		return -VAR_9;

	baswap((void *) VAR_5, &l2cap_pi(VAR_1->sk)->chan->dst);
	baswap((void *) VAR_7, &l2cap_pi(VAR_1->sk)->chan->src);

	/* COMMENT_0 */
	VAR_2 = alloc_netdev(sizeof(struct bnep_session),
			   (*VAR_0->device) ? VAR_0->device : ""bnep%d"",
			   VAR_10,
			   VAR_11);
	if (!VAR_2)
		return -VAR_12;

	down_write(&VAR_13);

	VAR_4 = __bnep_get_session(VAR_5);
	if (VAR_4 && VAR_4->state == VAR_14) {
		VAR_8 = -VAR_15;
		goto failed;
	}

	VAR_3 = netdev_priv(VAR_2);

	/* COMMENT_1 */
                                          
	memcpy(VAR_3->eh.h_dest,   &VAR_7, VAR_6);
	memcpy(VAR_3->eh.h_source, &VAR_5, VAR_6);
	memcpy(VAR_2->dev_addr, VAR_3->eh.h_dest, VAR_6);

	VAR_3->dev   = VAR_2;
	VAR_3->sock  = VAR_1;
	VAR_3->role  = VAR_0->role;
	VAR_3->state = VAR_14;

	VAR_3->msg.msg_flags = VAR_16;

#ifdef VAR_17
	/* COMMENT_3 */
	set_bit(bnep_mc_hash(VAR_2->broadcast), (ulong *) &VAR_3->mc_filter);
#endif

#ifdef VAR_18
	/* COMMENT_4 */
	bnep_set_default_proto_filter(VAR_3);
#endif

	SET_NETDEV_DEV(VAR_2, bnep_get_device(VAR_3));
	SET_NETDEV_DEVTYPE(VAR_2, &VAR_19);

	VAR_8 = register_netdev(VAR_2);
	if (VAR_8)
		goto failed;

	__bnep_link_session(VAR_3);

	__module_get(VAR_20);
	VAR_3->task = kthread_run(bnep_session, VAR_3, ""kbnepd %s"", VAR_2->name);
	if (IS_ERR(VAR_3->task)) {
		/* COMMENT_5 */
		module_put(VAR_20);
		unregister_netdev(VAR_2);
		__bnep_unlink_session(VAR_3);
		VAR_8 = PTR_ERR(VAR_3->task);
		goto failed;
	}

	up_write(&VAR_13);
	strcpy(VAR_0->device, VAR_2->name);
	return 0;

failed:
	up_write(&VAR_13);
	free_netdev(VAR_2);
	return VAR_8;
}",torvalds/linux/71bb99a02b32b4cc4265118e85f6035ca72923f0/core.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,9 @@
 	int err;
 
 	BT_DBG("""");
+
+	if (!l2cap_is_socket(sock))
+		return -EBADFD;
 
 	baswap((void *) dst, &l2cap_pi(sock->sk)->chan->dst);
 	baswap((void *) src, &l2cap_pi(sock->sk)->chan->src);","{'deleted_lines': [], 'added_lines': ['', '\tif (!l2cap_is_socket(sock))', '\t\treturn -EBADFD;']}",True,"The bnep_add_connection function in net/bluetooth/bnep/core.c in the Linux kernel before 3.19 does not ensure that an l2cap socket is available, which allows local users to gain privileges via a crafted application.",7.8,HIGH,2,test,2014-12-19T06:20:59Z,1
CVE-2015-4177,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"mnt: Fail collect_mounts when applied to unmounted mounts

The only users of collect_mounts are in audit_tree.c

In audit_trim_trees and audit_add_tree_rule the path passed into
collect_mounts is generated from kern_path passed an audit_tree
pathname which is guaranteed to be an absolute path.   In those cases
collect_mounts is obviously intended to work on mounted paths and
if a race results in paths that are unmounted when collect_mounts
it is reasonable to fail early.

The paths passed into audit_tag_tree don't have the absolute path
check.  But are used to play with fsnotify and otherwise interact with
the audit_trees, so again operating only on mounted paths appears
reasonable.

Avoid having to worry about what happens when we try and audit
unmounted filesystems by restricting collect_mounts to mounts
that appear in the mount tree.

Signed-off-by: ""Eric W. Biederman"" <ebiederm@xmission.com>",cd4a40174b71acd021877341684d8bb1dc8ea4ae,https://github.com/torvalds/linux/commit/cd4a40174b71acd021877341684d8bb1dc8ea4ae,fs/namespace.c,collect_mounts,"struct vfsmount *collect_mounts(struct path *path)
{
struct mount *tree;
namespace_lock();
tree = copy_tree(real_mount(path->mnt), path->dentry,
CL_COPY_ALL | CL_PRIVATE);
namespace_unlock();
if (IS_ERR(tree))
return ERR_CAST(tree);
return &tree->mnt;
}","struct vfsmount *collect_mounts(struct path *path)
{
struct mount *VAR_0;
namespace_lock();
VAR_0 = copy_tree(real_mount(path->mnt), path->dentry,
VAR_1 | VAR_2);
namespace_unlock();
if (IS_ERR(VAR_0))
return ERR_CAST(VAR_0);
return &VAR_0->mnt;
}",torvalds/linux/cd4a40174b71acd021877341684d8bb1dc8ea4ae/namespace.c/vul/before/0.json,"struct vfsmount *collect_mounts(struct path *path)
{
	struct mount *tree;
	namespace_lock();
	if (!check_mnt(real_mount(path->mnt)))
		tree = ERR_PTR(-EINVAL);
	else
		tree = copy_tree(real_mount(path->mnt), path->dentry,
				 CL_COPY_ALL | CL_PRIVATE);
	namespace_unlock();
	if (IS_ERR(tree))
		return ERR_CAST(tree);
	return &tree->mnt;
}","struct vfsmount *collect_mounts(struct path *path)
{
	struct mount *VAR_0;
	namespace_lock();
	if (!check_mnt(real_mount(path->mnt)))
		VAR_0 = ERR_PTR(-VAR_1);
	else
		VAR_0 = copy_tree(real_mount(path->mnt), path->dentry,
				 VAR_2 | VAR_3);
	namespace_unlock();
	if (IS_ERR(VAR_0))
		return ERR_CAST(VAR_0);
	return &VAR_0->mnt;
}",torvalds/linux/cd4a40174b71acd021877341684d8bb1dc8ea4ae/namespace.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,8 +2,11 @@
 {
 	struct mount *tree;
 	namespace_lock();
-	tree = copy_tree(real_mount(path->mnt), path->dentry,
-			 CL_COPY_ALL | CL_PRIVATE);
+	if (!check_mnt(real_mount(path->mnt)))
+		tree = ERR_PTR(-EINVAL);
+	else
+		tree = copy_tree(real_mount(path->mnt), path->dentry,
+				 CL_COPY_ALL | CL_PRIVATE);
 	namespace_unlock();
 	if (IS_ERR(tree))
 		return ERR_CAST(tree);","{'deleted_lines': ['\ttree = copy_tree(real_mount(path->mnt), path->dentry,', '\t\t\t CL_COPY_ALL | CL_PRIVATE);'], 'added_lines': ['\tif (!check_mnt(real_mount(path->mnt)))', '\t\ttree = ERR_PTR(-EINVAL);', '\telse', '\t\ttree = copy_tree(real_mount(path->mnt), path->dentry,', '\t\t\t\t CL_COPY_ALL | CL_PRIVATE);']}",True,"The collect_mounts function in fs/namespace.c in the Linux kernel before 4.0.5 does not properly consider that it may execute after a path has been unmounted, which allows local users to cause a denial of service (system crash) by leveraging user-namespace root access for an MNT_DETACH umount2 system call.",5.5,MEDIUM,1,test,2015-01-07T20:28:26Z,1
CVE-2015-8852,['CWE-Other'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,varnish/Varnish-Cache,"Do not consider a CR by itself as a valid line terminator

Varnish (prior to version 4.0) was not following the standard with
regard to line separator.

Spotted and analyzed by: Rgis Leroy [regilero] regis.leroy@makina-corpus.com",85e8468bec9416bd7e16b0d80cb820ecd2b330c3,https://github.com/varnish/Varnish-Cache/commit/85e8468bec9416bd7e16b0d80cb820ecd2b330c3,bin/varnishd/cache_http.c,http_splitline,"static uint16_t
http_splitline(struct worker *w, int fd, struct http *hp,
const struct http_conn *htc, int h1, int h2, int h3)
{
char *p, *q;
CHECK_OBJ_NOTNULL(htc, HTTP_CONN_MAGIC);
CHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);
Tcheck(htc->rxbuf);
for (p = htc->rxbuf.b ; vct_islws(*p); p++)
continue;
q = p;
for (; !vct_issp(*p); p++) {
if (vct_isctl(*p))
return (400);
}
hp->hd[h1].b = q;
hp->hd[h1].e = p;
for (; vct_issp(*p); p++) {
if (vct_isctl(*p))
return (400);
}
q = p;
for (; !vct_islws(*p); p++) {
if (vct_isctl(*p))
return (400);
}
hp->hd[h2].b = q;
hp->hd[h2].e = p;
if (!Tlen(hp->hd[h2]))
return (400);
for (; vct_issp(*p); p++) {
if (vct_isctl(*p))
return (400);
}
q = p;
if (!vct_iscrlf(*p)) {
for (; !vct_iscrlf(*p); p++)
if (!vct_issep(*p) && vct_isctl(*p))
return (400);
}
hp->hd[h3].b = q;
hp->hd[h3].e = p;
p += vct_skipcrlf(p);
*hp->hd[h1].e = '\0';
WSLH(w, fd, hp, h1);
*hp->hd[h2].e = '\0';
WSLH(w, fd, hp, h2);
if (hp->hd[h3].e != NULL) {
*hp->hd[h3].e = '\0';
WSLH(w, fd, hp, h3);
}
return (http_dissect_hdrs(w, hp, fd, p, htc));
}","static uint16_t
http_splitline(struct worker *VAR_0, int VAR_1, struct http *VAR_2,
const struct http_conn *VAR_3, int VAR_4, int VAR_5, int VAR_6)
{
char *VAR_7, *VAR_8;
CHECK_OBJ_NOTNULL(VAR_3, VAR_9);
CHECK_OBJ_NOTNULL(VAR_2, VAR_10);
Tcheck(VAR_3->rxbuf);
for (VAR_7 = VAR_3->rxbuf.b ; vct_islws(*VAR_7); VAR_7++)
continue;
VAR_8 = VAR_7;
for (; !vct_issp(*VAR_7); VAR_7++) {
if (vct_isctl(*VAR_7))
return (400);
}
VAR_2->hd[VAR_4].b = VAR_8;
VAR_2->hd[VAR_4].e = VAR_7;
for (; vct_issp(*VAR_7); VAR_7++) {
if (vct_isctl(*VAR_7))
return (400);
}
VAR_8 = VAR_7;
for (; !vct_islws(*VAR_7); VAR_7++) {
if (vct_isctl(*VAR_7))
return (400);
}
VAR_2->hd[VAR_5].b = VAR_8;
VAR_2->hd[VAR_5].e = VAR_7;
if (!Tlen(VAR_2->hd[VAR_5]))
return (400);
for (; vct_issp(*VAR_7); VAR_7++) {
if (vct_isctl(*VAR_7))
return (400);
}
VAR_8 = VAR_7;
if (!vct_iscrlf(*VAR_7)) {
for (; !vct_iscrlf(*VAR_7); VAR_7++)
if (!vct_issep(*VAR_7) && vct_isctl(*VAR_7))
return (400);
}
VAR_2->hd[VAR_6].b = VAR_8;
VAR_2->hd[VAR_6].e = VAR_7;
VAR_7 += vct_skipcrlf(VAR_7);
*VAR_2->hd[VAR_4].e = '\0';
WSLH(VAR_0, VAR_1, VAR_2, VAR_4);
*VAR_2->hd[VAR_5].e = '\0';
WSLH(VAR_0, VAR_1, VAR_2, VAR_5);
if (VAR_2->hd[VAR_6].e != NULL) {
*VAR_2->hd[VAR_6].e = '\0';
WSLH(VAR_0, VAR_1, VAR_2, VAR_6);
}
return (http_dissect_hdrs(VAR_0, VAR_2, VAR_1, VAR_7, VAR_3));
}",varnish/Varnish-Cache/85e8468bec9416bd7e16b0d80cb820ecd2b330c3/cache_http.c/vul/before/1.json,"static uint16_t
http_splitline(struct worker *w, int fd, struct http *hp,
    const struct http_conn *htc, int h1, int h2, int h3)
{
	char *p, *q;

	CHECK_OBJ_NOTNULL(htc, HTTP_CONN_MAGIC);
	CHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);

	/* XXX: Assert a NUL at rx.e ? */
	Tcheck(htc->rxbuf);

	/* Skip leading LWS */
	for (p = htc->rxbuf.b ; vct_islws(*p); p++)
		continue;

	/* First field cannot contain SP, CRLF or CTL */
	q = p;
	for (; !vct_issp(*p); p++) {
		if (vct_isctl(*p))
			return (400);
	}
	hp->hd[h1].b = q;
	hp->hd[h1].e = p;

	/* Skip SP */
	for (; vct_issp(*p); p++) {
		if (vct_isctl(*p))
			return (400);
	}

	/* Second field cannot contain LWS or CTL */
	q = p;
	for (; !vct_islws(*p); p++) {
		if (vct_isctl(*p))
			return (400);
	}
	hp->hd[h2].b = q;
	hp->hd[h2].e = p;

	if (!Tlen(hp->hd[h2]))
		return (400);

	/* Skip SP */
	for (; vct_issp(*p); p++) {
		if (vct_isctl(*p))
			return (400);
	}

	/* Third field is optional and cannot contain CTL */
	q = p;
	if (!vct_iscrlf(p)) {
		for (; !vct_iscrlf(p); p++)
			if (!vct_issep(*p) && vct_isctl(*p))
				return (400);
	}
	hp->hd[h3].b = q;
	hp->hd[h3].e = p;

	/* Skip CRLF */
	p += vct_skipcrlf(p);

	*hp->hd[h1].e = '\0';
	WSLH(w, fd, hp, h1);

	*hp->hd[h2].e = '\0';
	WSLH(w, fd, hp, h2);

	if (hp->hd[h3].e != NULL) {
		*hp->hd[h3].e = '\0';
		WSLH(w, fd, hp, h3);
	}

	return (http_dissect_hdrs(w, hp, fd, p, htc));
}","static uint16_t
http_splitline(struct worker *VAR_0, int VAR_1, struct http *VAR_2,
    const struct http_conn *VAR_3, int VAR_4, int VAR_5, int VAR_6)
{
	char *VAR_7, *VAR_8;

	CHECK_OBJ_NOTNULL(VAR_3, VAR_9);
	CHECK_OBJ_NOTNULL(VAR_2, VAR_10);

	/* COMMENT_0 */
	Tcheck(VAR_3->rxbuf);

	/* COMMENT_1 */
	for (VAR_7 = VAR_3->rxbuf.b ; vct_islws(*VAR_7); VAR_7++)
		continue;

	/* COMMENT_2 */
	VAR_8 = VAR_7;
	for (; !vct_issp(*VAR_7); VAR_7++) {
		if (vct_isctl(*VAR_7))
			return (400);
	}
	VAR_2->hd[VAR_4].b = VAR_8;
	VAR_2->hd[VAR_4].e = VAR_7;

	/* COMMENT_3 */
	for (; vct_issp(*VAR_7); VAR_7++) {
		if (vct_isctl(*VAR_7))
			return (400);
	}

	/* COMMENT_4 */
	VAR_8 = VAR_7;
	for (; !vct_islws(*VAR_7); VAR_7++) {
		if (vct_isctl(*VAR_7))
			return (400);
	}
	VAR_2->hd[VAR_5].b = VAR_8;
	VAR_2->hd[VAR_5].e = VAR_7;

	if (!Tlen(VAR_2->hd[VAR_5]))
		return (400);

	/* COMMENT_3 */
	for (; vct_issp(*VAR_7); VAR_7++) {
		if (vct_isctl(*VAR_7))
			return (400);
	}

	/* COMMENT_5 */
	VAR_8 = VAR_7;
	if (!vct_iscrlf(VAR_7)) {
		for (; !vct_iscrlf(VAR_7); VAR_7++)
			if (!vct_issep(*VAR_7) && vct_isctl(*VAR_7))
				return (400);
	}
	VAR_2->hd[VAR_6].b = VAR_8;
	VAR_2->hd[VAR_6].e = VAR_7;

	/* COMMENT_6 */
	VAR_7 += vct_skipcrlf(VAR_7);

	*VAR_2->hd[VAR_4].e = '\0';
	WSLH(VAR_0, VAR_1, VAR_2, VAR_4);

	*VAR_2->hd[VAR_5].e = '\0';
	WSLH(VAR_0, VAR_1, VAR_2, VAR_5);

	if (VAR_2->hd[VAR_6].e != NULL) {
		*VAR_2->hd[VAR_6].e = '\0';
		WSLH(VAR_0, VAR_1, VAR_2, VAR_6);
	}

	return (http_dissect_hdrs(VAR_0, VAR_2, VAR_1, VAR_7, VAR_3));
}",varnish/Varnish-Cache/85e8468bec9416bd7e16b0d80cb820ecd2b330c3/cache_http.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -49,8 +49,8 @@
 
 	/* Third field is optional and cannot contain CTL */
 	q = p;
-	if (!vct_iscrlf(*p)) {
-		for (; !vct_iscrlf(*p); p++)
+	if (!vct_iscrlf(p)) {
+		for (; !vct_iscrlf(p); p++)
 			if (!vct_issep(*p) && vct_isctl(*p))
 				return (400);
 	}","{'deleted_lines': ['\tif (!vct_iscrlf(*p)) {', '\t\tfor (; !vct_iscrlf(*p); p++)'], 'added_lines': ['\tif (!vct_iscrlf(p)) {', '\t\tfor (; !vct_iscrlf(p); p++)']}",True,"Varnish 3.x before 3.0.7, when used in certain stacked installations, allows remote attackers to inject arbitrary HTTP headers and conduct HTTP response splitting attacks via a header line terminated by a \r (carriage return) character in conjunction with multiple Content-Length headers in an HTTP request.",7.5,HIGH,2,test,2015-03-12T14:41:51Z,1
CVE-2015-8852,['CWE-Other'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,varnish/Varnish-Cache,"Do not consider a CR by itself as a valid line terminator

Varnish (prior to version 4.0) was not following the standard with
regard to line separator.

Spotted and analyzed by: Rgis Leroy [regilero] regis.leroy@makina-corpus.com",85e8468bec9416bd7e16b0d80cb820ecd2b330c3,https://github.com/varnish/Varnish-Cache/commit/85e8468bec9416bd7e16b0d80cb820ecd2b330c3,bin/varnishd/cache_http.c,http_dissect_hdrs,"static uint16_t
http_dissect_hdrs(struct worker *w, struct http *hp, int fd, char *p,
const struct http_conn *htc)
{
char *q, *r;
txt t = htc->rxbuf;
if (*p == '\r')
p++;
hp->nhd = HTTP_HDR_FIRST;
hp->conds = 0;
r = NULL;
for (; p < t.e; p = r) {
q = r = p;
while (r < t.e) {
if (!vct_iscrlf(*r)) {
r++;
continue;
}
q = r;
assert(r < t.e);
r += vct_skipcrlf(r);
if (r >= t.e)
break;
if (!vct_issp(*r))
break;
while (vct_islws(*q))
*q++ = ' ';
}
if (q - p > htc->maxhdr) {
VSC_C_main->losthdr++;
WSL(w, SLT_LostHeader, fd, ""%.*s"",
q - p > 20 ? 20 : q - p, p);
return (413);
}
if (p == q)
break;
if ((p[0] == 'i' || p[0] == 'I') &&
(p[1] == 'f' || p[1] == 'F') &&
p[2] == '-')
hp->conds = 1;
while (q > p && vct_issp(q[-1]))
q--;
*q = '\0';
if (hp->nhd < hp->shd) {
hp->hdf[hp->nhd] = 0;
hp->hd[hp->nhd].b = p;
hp->hd[hp->nhd].e = q;
WSLH(w, fd, hp, hp->nhd);
hp->nhd++;
} else {
VSC_C_main->losthdr++;
WSL(w, SLT_LostHeader, fd, ""%.*s"",
q - p > 20 ? 20 : q - p, p);
return (413);
}
}
return (0);
}","static uint16_t
http_dissect_hdrs(struct worker *VAR_0, struct http *VAR_1, int VAR_2, char *VAR_3,
const struct http_conn *VAR_4)
{
char *VAR_5, *VAR_6;
txt VAR_7 = VAR_4->rxbuf;
if (*VAR_3 == '\r')
VAR_3++;
VAR_1->nhd = VAR_8;
VAR_1->conds = 0;
VAR_6 = NULL;
for (; VAR_3 < VAR_7.e; VAR_3 = VAR_6) {
VAR_5 = VAR_6 = VAR_3;
while (VAR_6 < VAR_7.e) {
if (!vct_iscrlf(*VAR_6)) {
VAR_6++;
continue;
}
VAR_5 = VAR_6;
assert(VAR_6 < VAR_7.e);
VAR_6 += vct_skipcrlf(VAR_6);
if (VAR_6 >= VAR_7.e)
break;
if (!vct_issp(*VAR_6))
break;
while (vct_islws(*VAR_5))
*VAR_5++ = ' ';
}
if (VAR_5 - VAR_3 > VAR_4->maxhdr) {
VAR_9->losthdr++;
WSL(VAR_0, VAR_10, VAR_2, ""%.*s"",
VAR_5 - VAR_3 > 20 ? 20 : VAR_5 - VAR_3, VAR_3);
return (413);
}
if (VAR_3 == VAR_5)
break;
if ((VAR_3[0] == 'i' || VAR_3[0] == 'I') &&
(VAR_3[1] == 'f' || VAR_3[1] == 'F') &&
VAR_3[2] == '-')
VAR_1->conds = 1;
while (VAR_5 > VAR_3 && vct_issp(VAR_5[-1]))
VAR_5--;
*VAR_5 = '\0';
if (VAR_1->nhd < VAR_1->shd) {
VAR_1->hdf[VAR_1->nhd] = 0;
VAR_1->hd[VAR_1->nhd].b = VAR_3;
VAR_1->hd[VAR_1->nhd].e = VAR_5;
WSLH(VAR_0, VAR_2, VAR_1, VAR_1->nhd);
VAR_1->nhd++;
} else {
VAR_9->losthdr++;
WSL(VAR_0, VAR_10, VAR_2, ""%.*s"",
VAR_5 - VAR_3 > 20 ? 20 : VAR_5 - VAR_3, VAR_3);
return (413);
}
}
return (0);
}",varnish/Varnish-Cache/85e8468bec9416bd7e16b0d80cb820ecd2b330c3/cache_http.c/vul/before/0.json,"static uint16_t
http_dissect_hdrs(struct worker *w, struct http *hp, int fd, char *p,
    const struct http_conn *htc)
{
	char *q, *r;
	txt t = htc->rxbuf;

	if (*p == '\r')
		p++;

	hp->nhd = HTTP_HDR_FIRST;
	hp->conds = 0;
	r = NULL;		/* For FlexeLint */
	for (; p < t.e; p = r) {

		/* Find end of next header */
		q = r = p;
		while (r < t.e) {
			if (!vct_iscrlf(r)) {
				r++;
				continue;
			}
			q = r;
			assert(r < t.e);
			r += vct_skipcrlf(r);
			if (r >= t.e)
				break;
			/* If line does not continue: got it. */
			if (!vct_issp(*r))
				break;

			/* Clear line continuation LWS to spaces */
			while (vct_islws(*q))
				*q++ = ' ';
		}

		if (q - p > htc->maxhdr) {
			VSC_C_main->losthdr++;
			WSL(w, SLT_LostHeader, fd, ""%.*s"",
			    q - p > 20 ? 20 : q - p, p);
			return (413);
		}

		/* Empty header = end of headers */
		if (p == q)
			break;

		if ((p[0] == 'i' || p[0] == 'I') &&
		    (p[1] == 'f' || p[1] == 'F') &&
		    p[2] == '-')
			hp->conds = 1;

		while (q > p && vct_issp(q[-1]))
			q--;
		*q = '\0';

		if (hp->nhd < hp->shd) {
			hp->hdf[hp->nhd] = 0;
			hp->hd[hp->nhd].b = p;
			hp->hd[hp->nhd].e = q;
			WSLH(w, fd, hp, hp->nhd);
			hp->nhd++;
		} else {
			VSC_C_main->losthdr++;
			WSL(w, SLT_LostHeader, fd, ""%.*s"",
			    q - p > 20 ? 20 : q - p, p);
			return (413);
		}
	}
	return (0);
}","static uint16_t
http_dissect_hdrs(struct worker *VAR_0, struct http *VAR_1, int VAR_2, char *VAR_3,
    const struct http_conn *VAR_4)
{
	char *VAR_5, *VAR_6;
	txt VAR_7 = VAR_4->rxbuf;

	if (*VAR_3 == '\r')
		VAR_3++;

	VAR_1->nhd = VAR_8;
	VAR_1->conds = 0;
	VAR_6 = NULL;		/* COMMENT_0 */
	for (; VAR_3 < VAR_7.e; VAR_3 = VAR_6) {

		/* COMMENT_1 */
		VAR_5 = VAR_6 = VAR_3;
		while (VAR_6 < VAR_7.e) {
			if (!vct_iscrlf(VAR_6)) {
				VAR_6++;
				continue;
			}
			VAR_5 = VAR_6;
			assert(VAR_6 < VAR_7.e);
			VAR_6 += vct_skipcrlf(VAR_6);
			if (VAR_6 >= VAR_7.e)
				break;
			/* COMMENT_2 */
			if (!vct_issp(*VAR_6))
				break;

			/* COMMENT_3 */
			while (vct_islws(*VAR_5))
				*VAR_5++ = ' ';
		}

		if (VAR_5 - VAR_3 > VAR_4->maxhdr) {
			VAR_9->losthdr++;
			WSL(VAR_0, VAR_10, VAR_2, ""%.*s"",
			    VAR_5 - VAR_3 > 20 ? 20 : VAR_5 - VAR_3, VAR_3);
			return (413);
		}

		/* COMMENT_4 */
		if (VAR_3 == VAR_5)
			break;

		if ((VAR_3[0] == 'i' || VAR_3[0] == 'I') &&
		    (VAR_3[1] == 'f' || VAR_3[1] == 'F') &&
		    VAR_3[2] == '-')
			VAR_1->conds = 1;

		while (VAR_5 > VAR_3 && vct_issp(VAR_5[-1]))
			VAR_5--;
		*VAR_5 = '\0';

		if (VAR_1->nhd < VAR_1->shd) {
			VAR_1->hdf[VAR_1->nhd] = 0;
			VAR_1->hd[VAR_1->nhd].b = VAR_3;
			VAR_1->hd[VAR_1->nhd].e = VAR_5;
			WSLH(VAR_0, VAR_2, VAR_1, VAR_1->nhd);
			VAR_1->nhd++;
		} else {
			VAR_9->losthdr++;
			WSL(VAR_0, VAR_10, VAR_2, ""%.*s"",
			    VAR_5 - VAR_3 > 20 ? 20 : VAR_5 - VAR_3, VAR_3);
			return (413);
		}
	}
	return (0);
}",varnish/Varnish-Cache/85e8468bec9416bd7e16b0d80cb820ecd2b330c3/cache_http.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -16,7 +16,7 @@
 		/* Find end of next header */
 		q = r = p;
 		while (r < t.e) {
-			if (!vct_iscrlf(*r)) {
+			if (!vct_iscrlf(r)) {
 				r++;
 				continue;
 			}","{'deleted_lines': ['\t\t\tif (!vct_iscrlf(*r)) {'], 'added_lines': ['\t\t\tif (!vct_iscrlf(r)) {']}",True,"Varnish 3.x before 3.0.7, when used in certain stacked installations, allows remote attackers to inject arbitrary HTTP headers and conduct HTTP response splitting attacks via a header line terminated by a \r (carriage return) character in conjunction with multiple Content-Length headers in an HTTP request.",7.5,HIGH,2,test,2015-03-12T14:41:51Z,1
CVE-2015-8852,['CWE-Other'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,varnish/Varnish-Cache,"Check for duplicate Content-Length headers in requests

If a duplicate CL header is in the request, we fail the request with a
400 (Bad Request)

Fix a test case that was sending duplicate CL by misstake and would
not fail because of that.",29870c8fe95e4e8a672f6f28c5fbe692bea09e9c,https://github.com/varnish/Varnish-Cache/commit/29870c8fe95e4e8a672f6f28c5fbe692bea09e9c,bin/varnishd/cache_http.c,http_DissectRequest,"uint16_t
http_DissectRequest(struct sess *sp)
{
struct http_conn *htc;
struct http *hp;
uint16_t retval;
CHECK_OBJ_NOTNULL(sp, SESS_MAGIC);
htc = sp->htc;
CHECK_OBJ_NOTNULL(htc, HTTP_CONN_MAGIC);
hp = sp->http;
CHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);
hp->logtag = HTTP_Rx;
retval = http_splitline(sp->wrk, sp->fd, hp, htc,
HTTP_HDR_REQ, HTTP_HDR_URL, HTTP_HDR_PROTO);
if (retval != 0) {
WSPR(sp, SLT_HttpGarbage, htc->rxbuf);
return (retval);
}
http_ProtoVer(hp);
retval = htc_request_check_host_hdr(hp);
if (retval != 0) {
WSP(sp, SLT_Error, ""Duplicated Host header"");
return (retval);
}
return (retval);
}","uint16_t
http_DissectRequest(struct sess *VAR_0)
{
struct http_conn *VAR_1;
struct http *VAR_2;
uint16_t VAR_3;
CHECK_OBJ_NOTNULL(VAR_0, VAR_4);
VAR_1 = VAR_0->htc;
CHECK_OBJ_NOTNULL(VAR_1, VAR_5);
VAR_2 = VAR_0->http;
CHECK_OBJ_NOTNULL(VAR_2, VAR_6);
VAR_2->logtag = VAR_7;
VAR_3 = http_splitline(VAR_0->wrk, VAR_0->fd, VAR_2, VAR_1,
VAR_8, VAR_9, VAR_10);
if (VAR_3 != 0) {
WSPR(VAR_0, VAR_11, VAR_1->rxbuf);
return (VAR_3);
}
http_ProtoVer(VAR_2);
VAR_3 = htc_request_check_host_hdr(VAR_2);
if (VAR_3 != 0) {
WSP(VAR_0, VAR_12, ""Duplicated Host header"");
return (VAR_3);
}
return (VAR_3);
}",varnish/Varnish-Cache/29870c8fe95e4e8a672f6f28c5fbe692bea09e9c/cache_http.c/vul/before/0.json,"uint16_t
http_DissectRequest(struct sess *sp)
{
	struct http_conn *htc;
	struct http *hp;
	uint16_t retval;

	CHECK_OBJ_NOTNULL(sp, SESS_MAGIC);
	htc = sp->htc;
	CHECK_OBJ_NOTNULL(htc, HTTP_CONN_MAGIC);
	hp = sp->http;
	CHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);

	hp->logtag = HTTP_Rx;

	retval = http_splitline(sp->wrk, sp->fd, hp, htc,
	    HTTP_HDR_REQ, HTTP_HDR_URL, HTTP_HDR_PROTO);
	if (retval != 0) {
		WSPR(sp, SLT_HttpGarbage, htc->rxbuf);
		return (retval);
	}
	http_ProtoVer(hp);

	retval = htc_request_check_hdrs(sp, hp);
	return (retval);
}","uint16_t
http_DissectRequest(struct sess *VAR_0)
{
	struct http_conn *VAR_1;
	struct http *VAR_2;
	uint16_t VAR_3;

	CHECK_OBJ_NOTNULL(VAR_0, VAR_4);
	VAR_1 = VAR_0->htc;
	CHECK_OBJ_NOTNULL(VAR_1, VAR_5);
	VAR_2 = VAR_0->http;
	CHECK_OBJ_NOTNULL(VAR_2, VAR_6);

	VAR_2->logtag = VAR_7;

	VAR_3 = http_splitline(VAR_0->wrk, VAR_0->fd, VAR_2, VAR_1,
	    VAR_8, VAR_9, VAR_10);
	if (VAR_3 != 0) {
		WSPR(VAR_0, VAR_11, VAR_1->rxbuf);
		return (VAR_3);
	}
	http_ProtoVer(VAR_2);

	VAR_3 = htc_request_check_hdrs(VAR_0, VAR_2);
	return (VAR_3);
}",varnish/Varnish-Cache/29870c8fe95e4e8a672f6f28c5fbe692bea09e9c/cache_http.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,10 +21,6 @@
 	}
 	http_ProtoVer(hp);
 
-	retval = htc_request_check_host_hdr(hp);
-	if (retval != 0) {
-		WSP(sp, SLT_Error, ""Duplicated Host header"");
-		return (retval);
-	}
+	retval = htc_request_check_hdrs(sp, hp);
 	return (retval);
 }","{'deleted_lines': ['\tretval = htc_request_check_host_hdr(hp);', '\tif (retval != 0) {', '\t\tWSP(sp, SLT_Error, ""Duplicated Host header"");', '\t\treturn (retval);', '\t}'], 'added_lines': ['\tretval = htc_request_check_hdrs(sp, hp);']}",True,"Varnish 3.x before 3.0.7, when used in certain stacked installations, allows remote attackers to inject arbitrary HTTP headers and conduct HTTP response splitting attacks via a header line terminated by a \r (carriage return) character in conjunction with multiple Content-Length headers in an HTTP request.",7.5,HIGH,2,test,2015-03-13T11:57:39Z,1
CVE-2015-8702,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,inspircd,"Reject replies to DNS PTR requests that contain invalid characters

Fixes issue #1033 reported by @ping86",6058483d9fbc1b904d5ae7cfea47bfcde5c5b559,https://github.com/inspircd/inspircd/commit/6058483d9fbc1b904d5ae7cfea47bfcde5c5b559,src/dns.cpp,DNS::GetResult,"DNSResult DNS::GetResult()
{
DNSHeader header;
DNSRequest *req;
unsigned char buffer[sizeof(DNSHeader)];
irc::sockets::sockaddrs from;
memset(&from, 0, sizeof(from));
socklen_t x = sizeof(from);
int length = ServerInstance->SE->RecvFrom(this, (char*)buffer, sizeof(DNSHeader), 0, &from.sa, &x);
if (length < 12)
{
ServerInstance->Logs->Log(""RESOLVER"",DEBUG,""GetResult didn't get a full packet (len=%d)"", length);
return DNSResult(-1,"""",0,"""");
}
if (from != myserver)
{
std::string server1 = from.str();
std::string server2 = myserver.str();
ServerInstance->Logs->Log(""RESOLVER"",DEBUG,""Got a result from the wrong server! Bad NAT or DNS forging attempt? '%s' != '%s'"",
server1.c_str(), server2.c_str());
return DNSResult(-1,"""",0,"""");
}
DNS::FillHeader(&header,buffer,length - 12);
unsigned long this_id = header.id[1] + (header.id[0] << 8);
if (!requests[this_id])
{
ServerInstance->Logs->Log(""RESOLVER"",DEBUG,""Hmm, got a result that we didn't ask for (id=%lx). Ignoring."", this_id);
return DNSResult(-1,"""",0,"""");
}
else
{
req = requests[this_id];
requests[this_id] = NULL;
}
DNSInfo data = req->ResultIsReady(header, length);
std::string resultstr;
if (data.first == NULL)
{
std::string ro = req->orig;
delete req;
return DNSResult(this_id | ERROR_MASK, data.second, 0, ro);
}
else
{
unsigned long ttl = req->ttl;
char formatted[128];
switch (req->type)
{
case DNS_QUERY_A:
snprintf(formatted,16,""%u.%u.%u.%u"",data.first[0],data.first[1],data.first[2],data.first[3]);
resultstr = formatted;
break;
case DNS_QUERY_AAAA:
{
if (!inet_ntop(AF_INET6, data.first, formatted, sizeof(formatted)))
{
std::string ro = req->orig;
delete req;
return DNSResult(this_id | ERROR_MASK, ""inet_ntop() failed"", 0, ro);
}
resultstr = formatted;
if (*formatted == ':')
resultstr.insert(0, ""0"");
}
break;
case DNS_QUERY_CNAME:
case DNS_QUERY_PTR:
resultstr = std::string((const char*)data.first);
break;
default:
break;
}
std::string ro = req->orig;
DNSResult result = DNSResult(this_id,resultstr,ttl,ro,req->type);
delete req;
return result;
}
}","DNSResult DNS::GetResult()
{
DNSHeader VAR_0;
DNSRequest *VAR_1;
unsigned char VAR_2[sizeof(DNSHeader)];
irc::sockets::sockaddrs VAR_3;
memset(&VAR_3, 0, sizeof(VAR_3));
socklen_t VAR_4 = sizeof(VAR_3);
int VAR_5 = VAR_6->SE->RecvFrom(this, (char*)VAR_2, sizeof(DNSHeader), 0, &VAR_3.sa, &VAR_4);
if (VAR_5 < 12)
{
VAR_6->Logs->Log(""RESOLVER"",VAR_7,""GetResult didn't get a full packet (len=%d)"", VAR_5);
return DNSResult(-1,"""",0,"""");
}
if (VAR_3 != VAR_8)
{
std::string VAR_9 = VAR_3.str();
std::string VAR_10 = VAR_8.str();
VAR_6->Logs->Log(""RESOLVER"",VAR_7,""Got a result from the wrong server! Bad NAT or DNS forging attempt? '%s' != '%s'"",
VAR_9.c_str(), VAR_10.c_str());
return DNSResult(-1,"""",0,"""");
}
DNS::FillHeader(&VAR_0,VAR_2,VAR_5 - 12);
unsigned long VAR_11 = VAR_0.id[1] + (VAR_0.id[0] << 8);
if (!VAR_12[VAR_11])
{
VAR_6->Logs->Log(""RESOLVER"",VAR_7,""Hmm, got a result that we didn't ask for (id=%lx). Ignoring."", VAR_11);
return DNSResult(-1,"""",0,"""");
}
else
{
VAR_1 = VAR_12[VAR_11];
VAR_12[VAR_11] = NULL;
}
DNSInfo VAR_13 = VAR_1->ResultIsReady(VAR_0, VAR_5);
std::string VAR_14;
if (VAR_13.first == NULL)
{
std::string VAR_15 = VAR_1->orig;
delete VAR_1;
return DNSResult(VAR_11 | VAR_16, VAR_13.second, 0, VAR_15);
}
else
{
unsigned long VAR_17 = VAR_1->ttl;
char VAR_18[128];
switch (VAR_1->type)
{
case VAR_19:
snprintf(VAR_18,16,""%u.%u.%u.%u"",VAR_13.first[0],VAR_13.first[1],VAR_13.first[2],VAR_13.first[3]);
VAR_14 = VAR_18;
break;
case VAR_20:
{
if (!inet_ntop(VAR_21, VAR_13.first, VAR_18, sizeof(VAR_18)))
{
std::string VAR_15 = VAR_1->orig;
delete VAR_1;
return DNSResult(VAR_11 | VAR_16, ""inet_ntop() failed"", 0, VAR_15);
}
VAR_14 = VAR_18;
if (*VAR_18 == ':')
VAR_14.insert(0, ""0"");
}
break;
case VAR_22:
case VAR_23:
VAR_14 = std::string((const char*)VAR_13.first);
break;
default:
break;
}
std::string VAR_15 = VAR_1->orig;
DNSResult VAR_24 = DNSResult(VAR_11,VAR_14,VAR_17,VAR_15,VAR_1->type);
delete VAR_1;
return VAR_24;
}
}",inspircd/6058483d9fbc1b904d5ae7cfea47bfcde5c5b559/dns.cpp/vul/before/0.json,"DNSResult DNS::GetResult()
{
	/* Fetch dns query response and decide where it belongs */
	DNSHeader header;
	DNSRequest *req;
	unsigned char buffer[sizeof(DNSHeader)];
	irc::sockets::sockaddrs from;
	memset(&from, 0, sizeof(from));
	socklen_t x = sizeof(from);

	int length = ServerInstance->SE->RecvFrom(this, (char*)buffer, sizeof(DNSHeader), 0, &from.sa, &x);

	/* Did we get the whole header? */
	if (length < 12)
	{
		ServerInstance->Logs->Log(""RESOLVER"",DEBUG,""GetResult didn't get a full packet (len=%d)"", length);
		/* Nope - something screwed up. */
		return DNSResult(-1,"""",0,"""");
	}

	/* Check wether the reply came from a different DNS
	 * server to the one we sent it to, or the source-port
	 * is not 53.
	 * A user could in theory still spoof dns packets anyway
	 * but this is less trivial than just sending garbage
	 * to the server, which is possible without this check.
	 *
	 * -- Thanks jilles for pointing this one out.
	 */
	if (from != myserver)
	{
		std::string server1 = from.str();
		std::string server2 = myserver.str();
		ServerInstance->Logs->Log(""RESOLVER"",DEBUG,""Got a result from the wrong server! Bad NAT or DNS forging attempt? '%s' != '%s'"",
			server1.c_str(), server2.c_str());
		return DNSResult(-1,"""",0,"""");
	}

	/* Put the read header info into a header class */
	DNS::FillHeader(&header,buffer,length - 12);

	/* Get the id of this request.
	 * Its a 16 bit value stored in two char's,
	 * so we use logic shifts to create the value.
	 */
	unsigned long this_id = header.id[1] + (header.id[0] << 8);

	/* Do we have a pending request matching this id? */
	if (!requests[this_id])
	{
		/* Somehow we got a DNS response for a request we never made... */
		ServerInstance->Logs->Log(""RESOLVER"",DEBUG,""Hmm, got a result that we didn't ask for (id=%lx). Ignoring."", this_id);
		return DNSResult(-1,"""",0,"""");
	}
	else
	{
		/* Remove the query from the list of pending queries */
		req = requests[this_id];
		requests[this_id] = NULL;
	}

	/* Inform the DNSRequest class that it has a result to be read.
	 * When its finished it will return a DNSInfo which is a pair of
	 * unsigned char* resource record data, and an error message.
	 */
	DNSInfo data = req->ResultIsReady(header, length);
	std::string resultstr;

	/* Check if we got a result, if we didnt, its an error */
	if (data.first == NULL)
	{
		/* An error.
		 * Mask the ID with the value of ERROR_MASK, so that
		 * the dns_deal_with_classes() function knows that its
		 * an error response and needs to be treated uniquely.
		 * Put the error message in the second field.
		 */
		std::string ro = req->orig;
		delete req;
		return DNSResult(this_id | ERROR_MASK, data.second, 0, ro);
	}
	else
	{
		unsigned long ttl = req->ttl;
		char formatted[128];

		/* Forward lookups come back as binary data. We must format them into ascii */
		switch (req->type)
		{
			case DNS_QUERY_A:
				snprintf(formatted,16,""%u.%u.%u.%u"",data.first[0],data.first[1],data.first[2],data.first[3]);
				resultstr = formatted;
			break;

			case DNS_QUERY_AAAA:
			{
				if (!inet_ntop(AF_INET6, data.first, formatted, sizeof(formatted)))
				{
					std::string ro = req->orig;
					delete req;
					return DNSResult(this_id | ERROR_MASK, ""inet_ntop() failed"", 0, ro);
				}

				resultstr = formatted;

				/* Special case. Sending ::1 around between servers
				 * and to clients is dangerous, because the : on the
				 * start makes the client or server interpret the IP
				 * as the last parameter on the line with a value "":1"".
				 */
				if (*formatted == ':')
					resultstr.insert(0, ""0"");
			}
			break;

			case DNS_QUERY_CNAME:
				/* Identical handling to PTR */

			case DNS_QUERY_PTR:
			{
				/* Reverse lookups just come back as char* */
				resultstr = std::string((const char*)data.first);
				if (resultstr.find_first_not_of(""0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-"") != std::string::npos)
				{
					std::string ro = req->orig;
					delete req;
					return DNSResult(this_id | ERROR_MASK, ""Invalid char(s) in reply"", 0, ro);
				}
			}
			break;

			default:
			break;
		}

		/* Build the reply with the id and hostname/ip in it */
		std::string ro = req->orig;
		DNSResult result = DNSResult(this_id,resultstr,ttl,ro,req->type);
		delete req;
		return result;
	}
}","DNSResult DNS::GetResult()
{
	/* COMMENT_0 */
	DNSHeader VAR_0;
	DNSRequest *VAR_1;
	unsigned char VAR_2[sizeof(DNSHeader)];
	irc::sockets::sockaddrs VAR_3;
	memset(&VAR_3, 0, sizeof(VAR_3));
	socklen_t VAR_4 = sizeof(VAR_3);

	int VAR_5 = VAR_6->SE->RecvFrom(this, (char*)VAR_2, sizeof(DNSHeader), 0, &VAR_3.sa, &VAR_4);

	/* COMMENT_1 */
	if (VAR_5 < 12)
	{
		VAR_6->Logs->Log(""RESOLVER"",VAR_7,""GetResult didn't get a full packet (len=%d)"", VAR_5);
		/* COMMENT_2 */
		return DNSResult(-1,"""",0,"""");
	}

	/* COMMENT_3 */
                                                       
              
                                                         
                                                      
                                                        
   
                                               
    
	if (VAR_3 != VAR_8)
	{
		std::string VAR_9 = VAR_3.str();
		std::string VAR_10 = VAR_8.str();
		VAR_6->Logs->Log(""RESOLVER"",VAR_7,""Got a result from the wrong server! Bad NAT or DNS forging attempt? '%s' != '%s'"",
			VAR_9.c_str(), VAR_10.c_str());
		return DNSResult(-1,"""",0,"""");
	}

	/* COMMENT_12 */
	DNS::FillHeader(&VAR_0,VAR_2,VAR_5 - 12);

	/* COMMENT_13 */
                                            
                                               
    
	unsigned long VAR_11 = VAR_0.id[1] + (VAR_0.id[0] << 8);

	/* COMMENT_17 */
	if (!VAR_12[VAR_11])
	{
		/* COMMENT_18 */
		VAR_6->Logs->Log(""RESOLVER"",VAR_7,""Hmm, got a result that we didn't ask for (id=%lx). Ignoring."", VAR_11);
		return DNSResult(-1,"""",0,"""");
	}
	else
	{
		/* COMMENT_19 */
		VAR_1 = VAR_12[VAR_11];
		VAR_12[VAR_11] = NULL;
	}

	/* COMMENT_20 */
                                                                 
                                                              
    
	DNSInfo VAR_13 = VAR_1->ResultIsReady(VAR_0, VAR_5);
	std::string VAR_14;

	/* COMMENT_24 */
	if (VAR_13.first == NULL)
	{
		/* COMMENT_25 */
                                                      
                                                        
                                                        
                                               
     
		std::string VAR_15 = VAR_1->orig;
		delete VAR_1;
		return DNSResult(VAR_11 | VAR_16, VAR_13.second, 0, VAR_15);
	}
	else
	{
		unsigned long VAR_17 = VAR_1->ttl;
		char VAR_18[128];

		/* COMMENT_31 */
		switch (VAR_1->type)
		{
			case VAR_19:
				snprintf(VAR_18,16,""%u.%u.%u.%u"",VAR_13.first[0],VAR_13.first[1],VAR_13.first[2],VAR_13.first[3]);
				VAR_14 = VAR_18;
			break;

			case VAR_20:
			{
				if (!inet_ntop(VAR_21, VAR_13.first, VAR_18, sizeof(VAR_18)))
				{
					std::string VAR_15 = VAR_1->orig;
					delete VAR_1;
					return DNSResult(VAR_11 | VAR_16, ""inet_ntop() failed"", 0, VAR_15);
				}

				VAR_14 = VAR_18;

				/* COMMENT_32 */
                                                        
                                                        
                                                           
       
				if (*VAR_18 == ':')
					VAR_14.insert(0, ""0"");
			}
			break;

			case VAR_22:
				/* COMMENT_37 */

			case VAR_23:
			{
				/* COMMENT_38 */
				VAR_14 = std::string((const char*)VAR_13.first);
				if (VAR_14.find_first_not_of(""0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-"") != std::string::npos)
				{
					std::string VAR_15 = VAR_1->orig;
					delete VAR_1;
					return DNSResult(VAR_11 | VAR_16, ""Invalid char(s) in reply"", 0, VAR_15);
				}
			}
			break;

			default:
			break;
		}

		/* COMMENT_39 */
		std::string VAR_15 = VAR_1->orig;
		DNSResult VAR_24 = DNSResult(VAR_11,VAR_14,VAR_17,VAR_15,VAR_1->type);
		delete VAR_1;
		return VAR_24;
	}
}",inspircd/6058483d9fbc1b904d5ae7cfea47bfcde5c5b559/dns.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -117,8 +117,16 @@
 				/* Identical handling to PTR */
 
 			case DNS_QUERY_PTR:
+			{
 				/* Reverse lookups just come back as char* */
 				resultstr = std::string((const char*)data.first);
+				if (resultstr.find_first_not_of(""0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-"") != std::string::npos)
+				{
+					std::string ro = req->orig;
+					delete req;
+					return DNSResult(this_id | ERROR_MASK, ""Invalid char(s) in reply"", 0, ro);
+				}
+			}
 			break;
 
 			default:","{'deleted_lines': [], 'added_lines': ['\t\t\t{', '\t\t\t\tif (resultstr.find_first_not_of(""0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-"") != std::string::npos)', '\t\t\t\t{', '\t\t\t\t\tstd::string ro = req->orig;', '\t\t\t\t\tdelete req;', '\t\t\t\t\treturn DNSResult(this_id | ERROR_MASK, ""Invalid char(s) in reply"", 0, ro);', '\t\t\t\t}', '\t\t\t}']}",True,"The DNS::GetResult function in dns.cpp in InspIRCd before 2.0.19 allows remote DNS servers to cause a denial of service (netsplit) via an invalid character in a PTR response, as demonstrated by a ""\032"" (whitespace) character in a hostname.",8.6,HIGH,2,test,2015-04-16T16:04:03Z,1
CVE-2015-8865,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,file,"PR/454: Fix memory corruption when the continuation level jumps by more than
20 in a single step.",6713ca45e7757297381f4b4cdb9cf5e624a9ad36,https://github.com/file/file/commit/6713ca45e7757297381f4b4cdb9cf5e624a9ad36,src/funcs.c,file_check_mem,"protected int
file_check_mem(struct magic_set *ms, unsigned int level)
{
size_t len;
if (level >= ms->c.len) {
len = (ms->c.len += 20) * sizeof(*ms->c.li);
ms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?
malloc(len) :
realloc(ms->c.li, len));
if (ms->c.li == NULL) {
file_oomem(ms, len);
return -1;
}
}
ms->c.li[level].got_match = 0;
#ifdef ENABLE_CONDITIONALS
ms->c.li[level].last_match = 0;
ms->c.li[level].last_cond = COND_NONE;
#endif 
return 0;
}","protected VAR_0
file_check_mem(struct magic_set *VAR_1, unsigned int VAR_2)
{
size_t VAR_3;
if (VAR_2 >= VAR_1->c.len) {
VAR_3 = (VAR_1->c.len += 20) * sizeof(*VAR_1->c.li);
VAR_1->c.li = CAST(struct VAR_4 *, (VAR_1->c.li == NULL) ?
malloc(VAR_3) :
realloc(VAR_1->c.li, VAR_3));
if (VAR_1->c.li == NULL) {
file_oomem(VAR_1, VAR_3);
return -1;
}
}
VAR_1->c.li[VAR_2].got_match = 0;
#ifdef VAR_5
VAR_1->c.li[VAR_2].last_match = 0;
VAR_1->c.li[VAR_2].last_cond = VAR_6;
#endif 
return 0;
}",,"protected int
file_check_mem(struct magic_set *ms, unsigned int level)
{
	size_t len;

	if (level >= ms->c.len) {
		len = (ms->c.len = 20 + level) * sizeof(*ms->c.li);
		ms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?
		    malloc(len) :
		    realloc(ms->c.li, len));
		if (ms->c.li == NULL) {
			file_oomem(ms, len);
			return -1;
		}
	}
	ms->c.li[level].got_match = 0;
#ifdef ENABLE_CONDITIONALS
	ms->c.li[level].last_match = 0;
	ms->c.li[level].last_cond = COND_NONE;
#endif /* ENABLE_CONDITIONALS */
	return 0;
}","protected VAR_0
file_check_mem(struct magic_set *VAR_1, unsigned int VAR_2)
{
	size_t VAR_3;

	if (VAR_2 >= VAR_1->c.len) {
		VAR_3 = (VAR_1->c.len = 20 + VAR_2) * sizeof(*VAR_1->c.li);
		VAR_1->c.li = CAST(struct VAR_4 *, (VAR_1->c.li == NULL) ?
		    malloc(VAR_3) :
		    realloc(VAR_1->c.li, VAR_3));
		if (VAR_1->c.li == NULL) {
			file_oomem(VAR_1, VAR_3);
			return -1;
		}
	}
	VAR_1->c.li[VAR_2].got_match = 0;
#ifdef VAR_5
	VAR_1->c.li[VAR_2].last_match = 0;
	VAR_1->c.li[VAR_2].last_cond = VAR_6;
#endif /* COMMENT_0 */
	return 0;
}",,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
 	size_t len;
 
 	if (level >= ms->c.len) {
-		len = (ms->c.len += 20) * sizeof(*ms->c.li);
+		len = (ms->c.len = 20 + level) * sizeof(*ms->c.li);
 		ms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?
 		    malloc(len) :
 		    realloc(ms->c.li, len));","{'deleted_lines': ['\t\tlen = (ms->c.len += 20) * sizeof(*ms->c.li);'], 'added_lines': ['\t\tlen = (ms->c.len = 20 + level) * sizeof(*ms->c.li);']}",True,"The file_check_mem function in funcs.c in file before 5.23, as used in the Fileinfo component in PHP before 5.5.34, 5.6.x before 5.6.20, and 7.x before 7.0.5, mishandles continuation-level jumps, which allows context-dependent attackers to cause a denial of service (buffer overflow and application crash) or possibly execute arbitrary code via a crafted magic file.",7.3,HIGH,2,test,2015-06-03T18:01:20Z,1
CVE-2015-5070,['CWE-200'],AV:N/AC:M/Au:S/C:P/I:N/A:N,0,wesnoth,"Use looks_like_pbl() to disallow .pbl file inclusion (bug #23504)

This function is implemented using case-insensitive pattern matching,
unlike filesystem::ends_with(). I missed this when writing my original
fix, so the vulnerability still applied to .pbl files on a
case-insensitive filesystem (e.g. NTFS and FAT* on Windows) by using
different case to bypass the check.",b2738ffb2fdd2550ececb74f76f75583c43c8b59,https://github.com/wesnoth/wesnoth/commit/b2738ffb2fdd2550ececb74f76f75583c43c8b59,src/filesystem.cpp,get_wml_location,"std::string get_wml_location(const std::string &filename, const std::string &current_dir)
{
DBG_FS << ""Looking for '"" << filename << ""'."" << std::endl;
assert(game_config::path.empty() == false);
std::string result;
if (filename.empty()) {
LOG_FS << ""  invalid filename"" << std::endl;
return result;
}
if (filename.find("".."") != std::string::npos) {
ERR_FS << ""Illegal path '"" << filename << ""' (\""..\"" not allowed)."" << std::endl;
return result;
}
if (ends_with(filename, "".pbl"")) {
ERR_FS << ""Illegal path '"" << filename << ""' (.pbl files are not allowed)."" << std::endl;
return result;
}
bool already_found = false;
if (filename[0] == '~')
{
result = get_user_data_dir() + ""/data/"" + filename.substr(1);
DBG_FS << ""  trying '"" << result << ""'"" << std::endl;
already_found = file_exists(result) || is_directory(result);
}
else if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '/')
{
if (!current_dir.empty())
{
result = current_dir;
}
else
{
result = game_config::path;
}
result += filename.substr(2);
}
else if (!game_config::path.empty())
result = game_config::path + ""/data/"" + filename;
DBG_FS << ""  trying '"" << result << ""'"" << std::endl;
if (result.empty() ||
(!already_found && !file_exists(result) && !is_directory(result)))
{
DBG_FS << ""  not found"" << std::endl;
result.clear();
}
else
DBG_FS << ""  found: '"" << result << ""'"" << std::endl;
return result;
}","std::string get_wml_location(const std::string &VAR_0, const std::string &VAR_1)
{
VAR_2 << ""Looking for '"" << VAR_0 << ""'."" << std::endl;
assert(game_config::path.empty() == false);
std::string VAR_3;
if (VAR_0.empty()) {
VAR_4 << ""  invalid filename"" << std::endl;
return VAR_3;
}
if (VAR_0.find("".."") != std::string::npos) {
VAR_5 << ""Illegal path '"" << VAR_0 << ""' (\""..\"" not allowed)."" << std::endl;
return VAR_3;
}
if (ends_with(VAR_0, "".pbl"")) {
VAR_5 << ""Illegal path '"" << VAR_0 << ""' (.pbl files are not allowed)."" << std::endl;
return VAR_3;
}
bool VAR_6 = false;
if (VAR_0[0] == '~')
{
VAR_3 = get_user_data_dir() + ""/data/"" + VAR_0.substr(1);
VAR_2 << ""  trying '"" << VAR_3 << ""'"" << std::endl;
VAR_6 = file_exists(VAR_3) || is_directory(VAR_3);
}
else if (VAR_0.size() >= 2 && VAR_0[0] == '.' && VAR_0[1] == '/')
{
if (!VAR_1.empty())
{
VAR_3 = VAR_1;
}
else
{
VAR_3 = game_config::path;
}
VAR_3 += VAR_0.substr(2);
}
else if (!game_config::path.empty())
VAR_3 = game_config::path + ""/data/"" + VAR_0;
VAR_2 << ""  trying '"" << VAR_3 << ""'"" << std::endl;
if (VAR_3.empty() ||
(!VAR_6 && !file_exists(VAR_3) && !is_directory(VAR_3)))
{
VAR_2 << ""  not found"" << std::endl;
VAR_3.clear();
}
else
VAR_2 << ""  found: '"" << VAR_3 << ""'"" << std::endl;
return VAR_3;
}",wesnoth/b2738ffb2fdd2550ececb74f76f75583c43c8b59/filesystem.cpp/vul/before/0.json,"std::string get_wml_location(const std::string &filename, const std::string &current_dir)
{
	DBG_FS << ""Looking for '"" << filename << ""'."" << std::endl;

	assert(game_config::path.empty() == false);

	std::string result;

	if (filename.empty()) {
		LOG_FS << ""  invalid filename"" << std::endl;
		return result;
	}

	if (filename.find("".."") != std::string::npos) {
		ERR_FS << ""Illegal path '"" << filename << ""' (\""..\"" not allowed)."" << std::endl;
		return result;
	}

	if (looks_like_pbl(filename)) {
		ERR_FS << ""Illegal path '"" << filename << ""' (.pbl files are not allowed)."" << std::endl;
		return result;
	}

	bool already_found = false;

	if (filename[0] == '~')
	{
		// If the filename starts with '~', look in the user data directory.
		result = get_user_data_dir() + ""/data/"" + filename.substr(1);
		DBG_FS << ""  trying '"" << result << ""'"" << std::endl;

		already_found = file_exists(result) || is_directory(result);
	}
	else if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '/')
	{
		// If the filename begins with a ""./"", look in the same directory
		// as the file currently being preprocessed.

		if (!current_dir.empty())
		{
			result = current_dir;
		}
		else
		{
			result = game_config::path;
		}

		result += filename.substr(2);
	}
	else if (!game_config::path.empty())
		result = game_config::path + ""/data/"" + filename;

	DBG_FS << ""  trying '"" << result << ""'"" << std::endl;

	if (result.empty() ||
	    (!already_found && !file_exists(result) && !is_directory(result)))
	{
		DBG_FS << ""  not found"" << std::endl;
		result.clear();
	}
	else
		DBG_FS << ""  found: '"" << result << ""'"" << std::endl;

	return result;
}","std::string get_wml_location(const std::string &VAR_0, const std::string &VAR_1)
{
	VAR_2 << ""Looking for '"" << VAR_0 << ""'."" << std::endl;

	assert(game_config::path.empty() == false);

	std::string VAR_3;

	if (VAR_0.empty()) {
		VAR_4 << ""  invalid filename"" << std::endl;
		return VAR_3;
	}

	if (VAR_0.find("".."") != std::string::npos) {
		VAR_5 << ""Illegal path '"" << VAR_0 << ""' (\""..\"" not allowed)."" << std::endl;
		return VAR_3;
	}

	if (looks_like_pbl(VAR_0)) {
		VAR_5 << ""Illegal path '"" << VAR_0 << ""' (.pbl files are not allowed)."" << std::endl;
		return VAR_3;
	}

	bool VAR_6 = false;

	if (VAR_0[0] == '~')
	{
		/* COMMENT_0 */
		VAR_3 = get_user_data_dir() + ""/data/"" + VAR_0.substr(1);
		VAR_2 << ""  trying '"" << VAR_3 << ""'"" << std::endl;

		VAR_6 = file_exists(VAR_3) || is_directory(VAR_3);
	}
	else if (VAR_0.size() >= 2 && VAR_0[0] == '.' && VAR_0[1] == '/')
	{
		/* COMMENT_1 */
		/* COMMENT_2 */

		if (!VAR_1.empty())
		{
			VAR_3 = VAR_1;
		}
		else
		{
			VAR_3 = game_config::path;
		}

		VAR_3 += VAR_0.substr(2);
	}
	else if (!game_config::path.empty())
		VAR_3 = game_config::path + ""/data/"" + VAR_0;

	VAR_2 << ""  trying '"" << VAR_3 << ""'"" << std::endl;

	if (VAR_3.empty() ||
	    (!VAR_6 && !file_exists(VAR_3) && !is_directory(VAR_3)))
	{
		VAR_2 << ""  not found"" << std::endl;
		VAR_3.clear();
	}
	else
		VAR_2 << ""  found: '"" << VAR_3 << ""'"" << std::endl;

	return VAR_3;
}",wesnoth/b2738ffb2fdd2550ececb74f76f75583c43c8b59/filesystem.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -16,7 +16,7 @@
 		return result;
 	}
 
-	if (ends_with(filename, "".pbl"")) {
+	if (looks_like_pbl(filename)) {
 		ERR_FS << ""Illegal path '"" << filename << ""' (.pbl files are not allowed)."" << std::endl;
 		return result;
 	}","{'deleted_lines': ['\tif (ends_with(filename, "".pbl"")) {'], 'added_lines': ['\tif (looks_like_pbl(filename)) {']}",True,"The (1) filesystem::get_wml_location function in filesystem.cpp and (2) is_legal_file function in filesystem_boost.cpp in Battle for Wesnoth before 1.12.4 and 1.13.x before 1.13.1, when a case-insensitive filesystem is used, allow remote attackers to obtain sensitive information via vectors related to inclusion of .pbl files from WML.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-5069.",3.1,LOW,0,test,2015-06-17T02:08:52Z,1
CVE-2015-5070,['CWE-200'],AV:N/AC:M/Au:S/C:P/I:N/A:N,0,wesnoth,"Use looks_like_pbl() to disallow .pbl file inclusion (bug #23504)

This function is implemented using case-insensitive pattern matching,
unlike filesystem::ends_with(). I missed this when writing my original
fix, so the vulnerability still applied to .pbl files on a
case-insensitive filesystem (e.g. NTFS and FAT* on Windows) by using
different case to bypass the check.",b2738ffb2fdd2550ececb74f76f75583c43c8b59,https://github.com/wesnoth/wesnoth/commit/b2738ffb2fdd2550ececb74f76f75583c43c8b59,src/filesystem_boost.cpp,is_legal_file,"static bool is_legal_file(const std::string &filename)
{
DBG_FS << ""Looking for '"" << filename << ""'.\n"";
if (filename.empty()) {
LOG_FS << ""  invalid filename\n"";
return false;
}
if (filename.find("".."") != std::string::npos) {
ERR_FS << ""Illegal path '"" << filename << ""' (\""..\"" not allowed).\n"";
return false;
}
if (ends_with(filename, "".pbl"")) {
ERR_FS << ""Illegal path '"" << filename << ""' (.pbl files are not allowed)."" << std::endl;
return false;
}
return true;
}","static bool is_legal_file(const std::string &VAR_0)
{
VAR_1 << ""Looking for '"" << VAR_0 << ""'.\n"";
if (VAR_0.empty()) {
VAR_2 << ""  invalid filename\n"";
return false;
}
if (VAR_0.find("".."") != std::string::npos) {
VAR_3 << ""Illegal path '"" << VAR_0 << ""' (\""..\"" not allowed).\n"";
return false;
}
if (ends_with(VAR_0, "".pbl"")) {
VAR_3 << ""Illegal path '"" << VAR_0 << ""' (.pbl files are not allowed)."" << std::endl;
return false;
}
return true;
}",wesnoth/b2738ffb2fdd2550ececb74f76f75583c43c8b59/filesystem_boost.cpp/vul/before/0.json,"static bool is_legal_file(const std::string &filename)
{
	DBG_FS << ""Looking for '"" << filename << ""'.\n"";

	if (filename.empty()) {
		LOG_FS << ""  invalid filename\n"";
		return false;
	}

	if (filename.find("".."") != std::string::npos) {
		ERR_FS << ""Illegal path '"" << filename << ""' (\""..\"" not allowed).\n"";
		return false;
	}

	if (looks_like_pbl(filename)) {
		ERR_FS << ""Illegal path '"" << filename << ""' (.pbl files are not allowed)."" << std::endl;
		return false;
	}

	return true;
}","static bool is_legal_file(const std::string &VAR_0)
{
	VAR_1 << ""Looking for '"" << VAR_0 << ""'.\n"";

	if (VAR_0.empty()) {
		VAR_2 << ""  invalid filename\n"";
		return false;
	}

	if (VAR_0.find("".."") != std::string::npos) {
		VAR_3 << ""Illegal path '"" << VAR_0 << ""' (\""..\"" not allowed).\n"";
		return false;
	}

	if (looks_like_pbl(VAR_0)) {
		VAR_3 << ""Illegal path '"" << VAR_0 << ""' (.pbl files are not allowed)."" << std::endl;
		return false;
	}

	return true;
}",wesnoth/b2738ffb2fdd2550ececb74f76f75583c43c8b59/filesystem_boost.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,7 +12,7 @@
 		return false;
 	}
 
-	if (ends_with(filename, "".pbl"")) {
+	if (looks_like_pbl(filename)) {
 		ERR_FS << ""Illegal path '"" << filename << ""' (.pbl files are not allowed)."" << std::endl;
 		return false;
 	}","{'deleted_lines': ['\tif (ends_with(filename, "".pbl"")) {'], 'added_lines': ['\tif (looks_like_pbl(filename)) {']}",True,"The (1) filesystem::get_wml_location function in filesystem.cpp and (2) is_legal_file function in filesystem_boost.cpp in Battle for Wesnoth before 1.12.4 and 1.13.x before 1.13.1, when a case-insensitive filesystem is used, allow remote attackers to obtain sensitive information via vectors related to inclusion of .pbl files from WML.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-5069.",3.1,LOW,0,test,2015-06-17T02:08:52Z,1
CVE-2016-7515,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,Fixed check for the number of pixels that will be allocated.,2ad6d33493750a28a5a655d319a8e0b16c392de1,https://github.com/ImageMagick/ImageMagick/commit/2ad6d33493750a28a5a655d319a8e0b16c392de1,coders/rle.c,ReadRLEImage,"static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define SkipLinesOp  0x01
#define SetColorOp  0x02
#define SkipPixelsOp  0x03
#define ByteDataOp  0x05
#define RunDataOp  0x06
#define EOFOp  0x07
char
magick[12];
Image
*image;
int
opcode,
operand,
status;
MagickStatusType
flags;
MagickSizeType
number_pixels;
MemoryInfo
*pixel_info;
Quantum
index;
register ssize_t
x;
register Quantum
*q;
register ssize_t
i;
register unsigned char
*p;
size_t
bits_per_pixel,
map_length,
number_colormaps,
number_planes,
one,
offset,
pixel_info_length;
ssize_t
count,
y;
unsigned char
background_color[256],
*colormap,
pixel,
plane,
*pixels;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
image=AcquireImage(image_info,exception);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
return(DestroyImageList(image));
count=ReadBlob(image,2,(unsigned char *) magick);
if ((count != 2) || (memcmp(magick,""\122\314"",2) != 0))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
do
{
image->page.x=ReadBlobLSBShort(image);
image->page.y=ReadBlobLSBShort(image);
image->columns=ReadBlobLSBShort(image);
image->rows=ReadBlobLSBShort(image);
flags=(MagickStatusType) ReadBlobByte(image);
image->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;
number_planes=(size_t) ReadBlobByte(image);
bits_per_pixel=(size_t) ReadBlobByte(image);
number_colormaps=(size_t) ReadBlobByte(image);
map_length=(unsigned char) ReadBlobByte(image);
if (map_length >= 64)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
one=1;
map_length=one << map_length;
if ((number_planes == 0) || (number_planes == 2) || (bits_per_pixel != 8) ||
(image->columns == 0))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if (flags & 0x02)
{
for (i=0; i < (ssize_t) number_planes; i++)
background_color[i]=0;
(void) ReadBlobByte(image);
}
else
{
p=background_color;
for (i=0; i < (ssize_t) number_planes; i++)
*p++=(unsigned char) ReadBlobByte(image);
}
if ((number_planes & 0x01) == 0)
(void) ReadBlobByte(image);
if (EOFBlob(image) != MagickFalse)
{
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
break;
}
colormap=(unsigned char *) NULL;
if (number_colormaps != 0)
{
colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,
3*map_length*sizeof(*colormap));
if (colormap == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
p=colormap;
for (i=0; i < (ssize_t) number_colormaps; i++)
for (x=0; x < (ssize_t) map_length; x++)
*p++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(image));
}
if ((flags & 0x08) != 0)
{
char
*comment;
size_t
length;
length=ReadBlobLSBShort(image);
if (length != 0)
{
comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));
if (comment == (char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
count=ReadBlob(image,length-1,(unsigned char *) comment);
comment[length-1]='\0';
(void) SetImageProperty(image,""comment"",comment,exception);
comment=DestroyString(comment);
if ((length & 0x01) == 0)
(void) ReadBlobByte(image);
}
}
if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
if (image->scene >= (image_info->scene+image_info->number_scenes-1))
break;
status=SetImageExtent(image,image->columns,image->rows,exception);
if (status == MagickFalse)
return(DestroyImageList(image));
if (image->alpha_trait != UndefinedPixelTrait)
number_planes++;
number_pixels=(MagickSizeType) image->columns*image->rows;
if ((number_pixels*number_planes) != (size_t) (number_pixels*number_planes))
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
pixel_info_length=image->columns*image->rows*MagickMax(number_planes,4);
pixel_info=AcquireVirtualMemory(pixel_info_length,sizeof(*pixels));
if (pixel_info == (MemoryInfo *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
if ((flags & 0x01) && !(flags & 0x02))
{
ssize_t
j;
p=pixels;
for (i=0; i < (ssize_t) number_pixels; i++)
{
if (image->alpha_trait == UndefinedPixelTrait)
for (j=0; j < (ssize_t) number_planes; j++)
*p++=background_color[j];
else
{
for (j=0; j < (ssize_t) (number_planes-1); j++)
*p++=background_color[j];
*p++=0;  
}
}
}
plane=0;
x=0;
y=0;
opcode=ReadBlobByte(image);
do
{
switch (opcode & 0x3f)
{
case SkipLinesOp:
{
operand=ReadBlobByte(image);
if (opcode & 0x40)
operand=(int) ReadBlobLSBShort(image);
x=0;
y+=operand;
break;
}
case SetColorOp:
{
operand=ReadBlobByte(image);
plane=(unsigned char) operand;
if (plane == 255)
plane=(unsigned char) (number_planes-1);
x=0;
break;
}
case SkipPixelsOp:
{
operand=ReadBlobByte(image);
if (opcode & 0x40)
operand=(int) ReadBlobLSBShort(image);
x+=operand;
break;
}
case ByteDataOp:
{
operand=ReadBlobByte(image);
if (opcode & 0x40)
operand=(int) ReadBlobLSBShort(image);
offset=((image->rows-y-1)*image->columns*number_planes)+x*
number_planes+plane;
operand++;
if (offset+((size_t) operand*number_planes) > pixel_info_length)
{
if (number_colormaps != 0)
colormap=(unsigned char *) RelinquishMagickMemory(colormap);
pixel_info=RelinquishVirtualMemory(pixel_info);
ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
}
p=pixels+offset;
for (i=0; i < (ssize_t) operand; i++)
{
pixel=(unsigned char) ReadBlobByte(image);
if ((y < (ssize_t) image->rows) &&
((x+i) < (ssize_t) image->columns))
*p=pixel;
p+=number_planes;
}
if (operand & 0x01)
(void) ReadBlobByte(image);
x+=operand;
break;
}
case RunDataOp:
{
operand=ReadBlobByte(image);
if (opcode & 0x40)
operand=(int) ReadBlobLSBShort(image);
pixel=(unsigned char) ReadBlobByte(image);
(void) ReadBlobByte(image);
offset=((image->rows-y-1)*image->columns*number_planes)+x*
number_planes+plane;
operand++;
if (offset+((size_t) operand*number_planes) > pixel_info_length)
{
if (number_colormaps != 0)
colormap=(unsigned char *) RelinquishMagickMemory(colormap);
pixel_info=RelinquishVirtualMemory(pixel_info);
ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
}
p=pixels+offset;
for (i=0; i < (ssize_t) operand; i++)
{
if ((y < (ssize_t) image->rows) &&
((x+i) < (ssize_t) image->columns))
*p=pixel;
p+=number_planes;
}
x+=operand;
break;
}
default:
break;
}
opcode=ReadBlobByte(image);
} while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));
if (number_colormaps != 0)
{
MagickStatusType
mask;
mask=(MagickStatusType) (map_length-1);
p=pixels;
x=(ssize_t) number_planes;
if (number_colormaps == 1)
for (i=0; i < (ssize_t) number_pixels; i++)
{
if (IsValidColormapIndex(image,*p & mask,&index,exception) ==
MagickFalse)
break;
*p=colormap[(ssize_t) index];
p++;
}
else
if ((number_planes >= 3) && (number_colormaps >= 3))
for (i=0; i < (ssize_t) number_pixels; i++)
for (x=0; x < (ssize_t) number_planes; x++)
{
if (IsValidColormapIndex(image,(size_t) (x*map_length+
(*p & mask)),&index,exception) == MagickFalse)
break;
*p=colormap[(ssize_t) index];
p++;
}
if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))
{
colormap=(unsigned char *) RelinquishMagickMemory(colormap);
pixel_info=RelinquishVirtualMemory(pixel_info);
ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
}
}
if (number_planes >= 3)
{
p=pixels;
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
SetPixelRed(image,ScaleCharToQuantum(*p++),q);
SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
if (image->alpha_trait != UndefinedPixelTrait)
SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
q+=GetPixelChannels(image);
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
}
else
{
if (number_colormaps == 0)
map_length=256;
if (AcquireImageColormap(image,map_length,exception) == MagickFalse)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
p=colormap;
if (number_colormaps == 1)
for (i=0; i < (ssize_t) image->colors; i++)
{
image->colormap[i].red=(MagickRealType)
ScaleCharToQuantum((unsigned char) i);
image->colormap[i].green=(MagickRealType)
ScaleCharToQuantum((unsigned char) i);
image->colormap[i].blue=(MagickRealType)
ScaleCharToQuantum((unsigned char) i);
}
else
if (number_colormaps > 1)
for (i=0; i < (ssize_t) image->colors; i++)
{
image->colormap[i].red=(MagickRealType)
ScaleCharToQuantum(*p);
image->colormap[i].green=(MagickRealType)
ScaleCharToQuantum(*(p+map_length));
image->colormap[i].blue=(MagickRealType)
ScaleCharToQuantum(*(p+map_length*2));
p++;
}
p=pixels;
if (image->alpha_trait == UndefinedPixelTrait)
{
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
SetPixelIndex(image,*p++,q);
q+=GetPixelChannels(image);
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
y,image->rows);
if (status == MagickFalse)
break;
}
}
(void) SyncImage(image,exception);
}
else
{
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
if (IsValidColormapIndex(image,(ssize_t) *p++,&index,
exception) == MagickFalse)
break;
SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)
index].red),q);
if (IsValidColormapIndex(image,(ssize_t) *p++,&index,
exception) == MagickFalse)
break;
SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)
index].green),q);
if (IsValidColormapIndex(image,(ssize_t) *p++,&index,
exception) == MagickFalse)
break;
SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)
index].blue),q);
SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
q+=GetPixelChannels(image);
}
if (x < (ssize_t) image->columns)
break;
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
y,image->rows);
if (status == MagickFalse)
break;
}
}
image->colormap=(PixelInfo *) RelinquishMagickMemory(
image->colormap);
image->storage_class=DirectClass;
image->colors=0;
}
}
if (number_colormaps != 0)
colormap=(unsigned char *) RelinquishMagickMemory(colormap);
pixel_info=RelinquishVirtualMemory(pixel_info);
if (EOFBlob(image) != MagickFalse)
{
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
break;
}
if (image_info->number_scenes != 0)
if (image->scene >= (image_info->scene+image_info->number_scenes-1))
break;
(void) ReadBlobByte(image);
count=ReadBlob(image,2,(unsigned char *) magick);
if ((count != 0) && (memcmp(magick,""\122\314"",2) == 0))
{
AcquireNextImage(image_info,image,exception);
if (GetNextImageInList(image) == (Image *) NULL)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
image=SyncNextImageInList(image);
status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
GetBlobSize(image));
if (status == MagickFalse)
break;
}
} while ((count != 0) && (memcmp(magick,""\122\314"",2) == 0));
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}","static Image *ReadRLEImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define VAR_2  0x01
#define VAR_3  0x02
#define VAR_4  0x03
#define VAR_5  0x05
#define VAR_6  0x06
#define VAR_7  0x07
char
VAR_8[12];
Image
*VAR_9;
int
VAR_10,
VAR_11,
VAR_12;
MagickStatusType
VAR_13;
MagickSizeType
VAR_14;
MemoryInfo
*VAR_15;
Quantum
VAR_16;
register ssize_t
VAR_17;
register Quantum
*VAR_18;
register ssize_t
VAR_19;
register unsigned char
*VAR_20;
size_t
VAR_21,
VAR_22,
VAR_23,
VAR_24,
VAR_25,
VAR_26,
VAR_27;
ssize_t
VAR_28,
VAR_29;
unsigned char
VAR_30[256],
*VAR_31,
VAR_32,
VAR_33,
*VAR_34;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_35);
if (VAR_0->debug != VAR_36)
(void) LogMagickEvent(VAR_37,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_35);
VAR_9=AcquireImage(VAR_0,VAR_1);
VAR_12=OpenBlob(VAR_0,VAR_9,VAR_38,VAR_1);
if (VAR_12 == VAR_36)
return(DestroyImageList(VAR_9));
VAR_28=ReadBlob(VAR_9,2,(unsigned char *) VAR_8);
if ((VAR_28 != 2) || (memcmp(VAR_8,""\122\314"",2) != 0))
ThrowReaderException(VAR_39,""ImproperImageHeader"");
do
{
VAR_9->page.x=ReadBlobLSBShort(VAR_9);
VAR_9->page.y=ReadBlobLSBShort(VAR_9);
VAR_9->columns=ReadBlobLSBShort(VAR_9);
VAR_9->rows=ReadBlobLSBShort(VAR_9);
VAR_13=(MagickStatusType) ReadBlobByte(VAR_9);
VAR_9->alpha_trait=VAR_13 & 0x04 ? VAR_40 : VAR_41;
VAR_24=(size_t) ReadBlobByte(VAR_9);
VAR_21=(size_t) ReadBlobByte(VAR_9);
VAR_23=(size_t) ReadBlobByte(VAR_9);
VAR_22=(unsigned char) ReadBlobByte(VAR_9);
if (VAR_22 >= 64)
ThrowReaderException(VAR_39,""ImproperImageHeader"");
VAR_25=1;
VAR_22=VAR_25 << VAR_22;
if ((VAR_24 == 0) || (VAR_24 == 2) || (VAR_21 != 8) ||
(VAR_9->columns == 0))
ThrowReaderException(VAR_39,""ImproperImageHeader"");
if (VAR_13 & 0x02)
{
for (VAR_19=0; VAR_19 < (ssize_t) VAR_24; VAR_19++)
VAR_30[VAR_19]=0;
(void) ReadBlobByte(VAR_9);
}
else
{
VAR_20=VAR_30;
for (VAR_19=0; VAR_19 < (ssize_t) VAR_24; VAR_19++)
*VAR_20++=(unsigned char) ReadBlobByte(VAR_9);
}
if ((VAR_24 & 0x01) == 0)
(void) ReadBlobByte(VAR_9);
if (EOFBlob(VAR_9) != VAR_36)
{
ThrowFileException(VAR_1,VAR_39,""UnexpectedEndOfFile"",
VAR_9->filename);
break;
}
VAR_31=(unsigned char *) NULL;
if (VAR_23 != 0)
{
VAR_31=(unsigned char *) AcquireQuantumMemory(VAR_23,
3*VAR_22*sizeof(*VAR_31));
if (VAR_31 == (unsigned char *) NULL)
ThrowReaderException(VAR_42,""MemoryAllocationFailed"");
VAR_20=VAR_31;
for (VAR_19=0; VAR_19 < (ssize_t) VAR_23; VAR_19++)
for (VAR_17=0; VAR_17 < (ssize_t) VAR_22; VAR_17++)
*VAR_20++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(VAR_9));
}
if ((VAR_13 & 0x08) != 0)
{
char
*VAR_43;
size_t
VAR_44;
VAR_44=ReadBlobLSBShort(VAR_9);
if (VAR_44 != 0)
{
VAR_43=(char *) AcquireQuantumMemory(VAR_44,sizeof(*VAR_43));
if (VAR_43 == (char *) NULL)
ThrowReaderException(VAR_42,""MemoryAllocationFailed"");
VAR_28=ReadBlob(VAR_9,VAR_44-1,(unsigned char *) VAR_43);
VAR_43[VAR_44-1]='\0';
(void) SetImageProperty(VAR_9,""comment"",VAR_43,VAR_1);
VAR_43=DestroyString(VAR_43);
if ((VAR_44 & 0x01) == 0)
(void) ReadBlobByte(VAR_9);
}
}
if ((VAR_0->ping != VAR_36) && (VAR_0->number_scenes != 0))
if (VAR_9->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
break;
VAR_12=SetImageExtent(VAR_9,VAR_9->columns,VAR_9->rows,VAR_1);
if (VAR_12 == VAR_36)
return(DestroyImageList(VAR_9));
if (VAR_9->alpha_trait != VAR_41)
VAR_24++;
VAR_14=(MagickSizeType) VAR_9->columns*VAR_9->rows;
if ((VAR_14*VAR_24) != (size_t) (VAR_14*VAR_24))
ThrowReaderException(VAR_42,""MemoryAllocationFailed"");
VAR_27=VAR_9->columns*VAR_9->rows*MagickMax(VAR_24,4);
VAR_15=AcquireVirtualMemory(VAR_27,sizeof(*VAR_34));
if (VAR_15 == (MemoryInfo *) NULL)
ThrowReaderException(VAR_42,""MemoryAllocationFailed"");
VAR_34=(unsigned char *) GetVirtualMemoryBlob(VAR_15);
if ((VAR_13 & 0x01) && !(VAR_13 & 0x02))
{
ssize_t
VAR_45;
VAR_20=VAR_34;
for (VAR_19=0; VAR_19 < (ssize_t) VAR_14; VAR_19++)
{
if (VAR_9->alpha_trait == VAR_41)
for (VAR_45=0; VAR_45 < (ssize_t) VAR_24; VAR_45++)
*VAR_20++=VAR_30[VAR_45];
else
{
for (VAR_45=0; VAR_45 < (ssize_t) (VAR_24-1); VAR_45++)
*VAR_20++=VAR_30[VAR_45];
*VAR_20++=0;  
}
}
}
VAR_33=0;
VAR_17=0;
VAR_29=0;
VAR_10=ReadBlobByte(VAR_9);
do
{
switch (VAR_10 & 0x3f)
{
case VAR_2:
{
VAR_11=ReadBlobByte(VAR_9);
if (VAR_10 & 0x40)
VAR_11=(int) ReadBlobLSBShort(VAR_9);
VAR_17=0;
VAR_29+=VAR_11;
break;
}
case VAR_3:
{
VAR_11=ReadBlobByte(VAR_9);
VAR_33=(unsigned char) VAR_11;
if (VAR_33 == 255)
VAR_33=(unsigned char) (VAR_24-1);
VAR_17=0;
break;
}
case VAR_4:
{
VAR_11=ReadBlobByte(VAR_9);
if (VAR_10 & 0x40)
VAR_11=(int) ReadBlobLSBShort(VAR_9);
VAR_17+=VAR_11;
break;
}
case VAR_5:
{
VAR_11=ReadBlobByte(VAR_9);
if (VAR_10 & 0x40)
VAR_11=(int) ReadBlobLSBShort(VAR_9);
VAR_26=((VAR_9->rows-VAR_29-1)*VAR_9->columns*VAR_24)+VAR_17*
VAR_24+VAR_33;
VAR_11++;
if (VAR_26+((size_t) VAR_11*VAR_24) > VAR_27)
{
if (VAR_23 != 0)
VAR_31=(unsigned char *) RelinquishMagickMemory(VAR_31);
VAR_15=RelinquishVirtualMemory(VAR_15);
ThrowReaderException(VAR_39,""UnableToReadImageData"");
}
VAR_20=VAR_34+VAR_26;
for (VAR_19=0; VAR_19 < (ssize_t) VAR_11; VAR_19++)
{
VAR_32=(unsigned char) ReadBlobByte(VAR_9);
if ((VAR_29 < (ssize_t) VAR_9->rows) &&
((VAR_17+VAR_19) < (ssize_t) VAR_9->columns))
*VAR_20=VAR_32;
VAR_20+=VAR_24;
}
if (VAR_11 & 0x01)
(void) ReadBlobByte(VAR_9);
VAR_17+=VAR_11;
break;
}
case VAR_6:
{
VAR_11=ReadBlobByte(VAR_9);
if (VAR_10 & 0x40)
VAR_11=(int) ReadBlobLSBShort(VAR_9);
VAR_32=(unsigned char) ReadBlobByte(VAR_9);
(void) ReadBlobByte(VAR_9);
VAR_26=((VAR_9->rows-VAR_29-1)*VAR_9->columns*VAR_24)+VAR_17*
VAR_24+VAR_33;
VAR_11++;
if (VAR_26+((size_t) VAR_11*VAR_24) > VAR_27)
{
if (VAR_23 != 0)
VAR_31=(unsigned char *) RelinquishMagickMemory(VAR_31);
VAR_15=RelinquishVirtualMemory(VAR_15);
ThrowReaderException(VAR_39,""UnableToReadImageData"");
}
VAR_20=VAR_34+VAR_26;
for (VAR_19=0; VAR_19 < (ssize_t) VAR_11; VAR_19++)
{
if ((VAR_29 < (ssize_t) VAR_9->rows) &&
((VAR_17+VAR_19) < (ssize_t) VAR_9->columns))
*VAR_20=VAR_32;
VAR_20+=VAR_24;
}
VAR_17+=VAR_11;
break;
}
default:
break;
}
VAR_10=ReadBlobByte(VAR_9);
} while (((VAR_10 & 0x3f) != VAR_7) && (VAR_10 != VAR_46));
if (VAR_23 != 0)
{
MagickStatusType
VAR_47;
VAR_47=(MagickStatusType) (VAR_22-1);
VAR_20=VAR_34;
VAR_17=(ssize_t) VAR_24;
if (VAR_23 == 1)
for (VAR_19=0; VAR_19 < (ssize_t) VAR_14; VAR_19++)
{
if (IsValidColormapIndex(VAR_9,*VAR_20 & VAR_47,&VAR_16,VAR_1) ==
VAR_36)
break;
*VAR_20=VAR_31[(ssize_t) VAR_16];
VAR_20++;
}
else
if ((VAR_24 >= 3) && (VAR_23 >= 3))
for (VAR_19=0; VAR_19 < (ssize_t) VAR_14; VAR_19++)
for (VAR_17=0; VAR_17 < (ssize_t) VAR_24; VAR_17++)
{
if (IsValidColormapIndex(VAR_9,(size_t) (VAR_17*VAR_22+
(*VAR_20 & VAR_47)),&VAR_16,VAR_1) == VAR_36)
break;
*VAR_20=VAR_31[(ssize_t) VAR_16];
VAR_20++;
}
if ((VAR_19 < (ssize_t) VAR_14) || (VAR_17 < (ssize_t) VAR_24))
{
VAR_31=(unsigned char *) RelinquishMagickMemory(VAR_31);
VAR_15=RelinquishVirtualMemory(VAR_15);
ThrowReaderException(VAR_39,""UnableToReadImageData"");
}
}
if (VAR_24 >= 3)
{
VAR_20=VAR_34;
for (VAR_29=0; VAR_29 < (ssize_t) VAR_9->rows; VAR_29++)
{
VAR_18=QueueAuthenticPixels(VAR_9,0,VAR_29,VAR_9->columns,1,VAR_1);
if (VAR_18 == (Quantum *) NULL)
break;
for (VAR_17=0; VAR_17 < (ssize_t) VAR_9->columns; VAR_17++)
{
SetPixelRed(VAR_9,ScaleCharToQuantum(*VAR_20++),VAR_18);
SetPixelGreen(VAR_9,ScaleCharToQuantum(*VAR_20++),VAR_18);
SetPixelBlue(VAR_9,ScaleCharToQuantum(*VAR_20++),VAR_18);
if (VAR_9->alpha_trait != VAR_41)
SetPixelAlpha(VAR_9,ScaleCharToQuantum(*VAR_20++),VAR_18);
VAR_18+=GetPixelChannels(VAR_9);
}
if (SyncAuthenticPixels(VAR_9,VAR_1) == VAR_36)
break;
if (VAR_9->previous == (Image *) NULL)
{
VAR_12=SetImageProgress(VAR_9,VAR_48,(MagickOffsetType) VAR_29,
VAR_9->rows);
if (VAR_12 == VAR_36)
break;
}
}
}
else
{
if (VAR_23 == 0)
VAR_22=256;
if (AcquireImageColormap(VAR_9,VAR_22,VAR_1) == VAR_36)
ThrowReaderException(VAR_42,""MemoryAllocationFailed"");
VAR_20=VAR_31;
if (VAR_23 == 1)
for (VAR_19=0; VAR_19 < (ssize_t) VAR_9->colors; VAR_19++)
{
VAR_9->colormap[VAR_19].red=(MagickRealType)
ScaleCharToQuantum((unsigned char) VAR_19);
VAR_9->colormap[VAR_19].green=(MagickRealType)
ScaleCharToQuantum((unsigned char) VAR_19);
VAR_9->colormap[VAR_19].blue=(MagickRealType)
ScaleCharToQuantum((unsigned char) VAR_19);
}
else
if (VAR_23 > 1)
for (VAR_19=0; VAR_19 < (ssize_t) VAR_9->colors; VAR_19++)
{
VAR_9->colormap[VAR_19].red=(MagickRealType)
ScaleCharToQuantum(*VAR_20);
VAR_9->colormap[VAR_19].green=(MagickRealType)
ScaleCharToQuantum(*(VAR_20+VAR_22));
VAR_9->colormap[VAR_19].blue=(MagickRealType)
ScaleCharToQuantum(*(VAR_20+VAR_22*2));
VAR_20++;
}
VAR_20=VAR_34;
if (VAR_9->alpha_trait == VAR_41)
{
for (VAR_29=0; VAR_29 < (ssize_t) VAR_9->rows; VAR_29++)
{
VAR_18=QueueAuthenticPixels(VAR_9,0,VAR_29,VAR_9->columns,1,VAR_1);
if (VAR_18 == (Quantum *) NULL)
break;
for (VAR_17=0; VAR_17 < (ssize_t) VAR_9->columns; VAR_17++)
{
SetPixelIndex(VAR_9,*VAR_20++,VAR_18);
VAR_18+=GetPixelChannels(VAR_9);
}
if (SyncAuthenticPixels(VAR_9,VAR_1) == VAR_36)
break;
if (VAR_9->previous == (Image *) NULL)
{
VAR_12=SetImageProgress(VAR_9,VAR_48,(MagickOffsetType)
VAR_29,VAR_9->rows);
if (VAR_12 == VAR_36)
break;
}
}
(void) SyncImage(VAR_9,VAR_1);
}
else
{
for (VAR_29=0; VAR_29 < (ssize_t) VAR_9->rows; VAR_29++)
{
VAR_18=QueueAuthenticPixels(VAR_9,0,VAR_29,VAR_9->columns,1,VAR_1);
if (VAR_18 == (Quantum *) NULL)
break;
for (VAR_17=0; VAR_17 < (ssize_t) VAR_9->columns; VAR_17++)
{
if (IsValidColormapIndex(VAR_9,(ssize_t) *VAR_20++,&VAR_16,
VAR_1) == VAR_36)
break;
SetPixelRed(VAR_9,ClampToQuantum(VAR_9->colormap[(ssize_t)
VAR_16].red),VAR_18);
if (IsValidColormapIndex(VAR_9,(ssize_t) *VAR_20++,&VAR_16,
VAR_1) == VAR_36)
break;
SetPixelGreen(VAR_9,ClampToQuantum(VAR_9->colormap[(ssize_t)
VAR_16].green),VAR_18);
if (IsValidColormapIndex(VAR_9,(ssize_t) *VAR_20++,&VAR_16,
VAR_1) == VAR_36)
break;
SetPixelBlue(VAR_9,ClampToQuantum(VAR_9->colormap[(ssize_t)
VAR_16].blue),VAR_18);
SetPixelAlpha(VAR_9,ScaleCharToQuantum(*VAR_20++),VAR_18);
VAR_18+=GetPixelChannels(VAR_9);
}
if (VAR_17 < (ssize_t) VAR_9->columns)
break;
if (SyncAuthenticPixels(VAR_9,VAR_1) == VAR_36)
break;
if (VAR_9->previous == (Image *) NULL)
{
VAR_12=SetImageProgress(VAR_9,VAR_48,(MagickOffsetType)
VAR_29,VAR_9->rows);
if (VAR_12 == VAR_36)
break;
}
}
VAR_9->colormap=(PixelInfo *) RelinquishMagickMemory(
VAR_9->colormap);
VAR_9->storage_class=VAR_49;
VAR_9->colors=0;
}
}
if (VAR_23 != 0)
VAR_31=(unsigned char *) RelinquishMagickMemory(VAR_31);
VAR_15=RelinquishVirtualMemory(VAR_15);
if (EOFBlob(VAR_9) != VAR_36)
{
ThrowFileException(VAR_1,VAR_39,""UnexpectedEndOfFile"",
VAR_9->filename);
break;
}
if (VAR_0->number_scenes != 0)
if (VAR_9->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
break;
(void) ReadBlobByte(VAR_9);
VAR_28=ReadBlob(VAR_9,2,(unsigned char *) VAR_8);
if ((VAR_28 != 0) && (memcmp(VAR_8,""\122\314"",2) == 0))
{
AcquireNextImage(VAR_0,VAR_9,VAR_1);
if (GetNextImageInList(VAR_9) == (Image *) NULL)
{
VAR_9=DestroyImageList(VAR_9);
return((Image *) NULL);
}
VAR_9=SyncNextImageInList(VAR_9);
VAR_12=SetImageProgress(VAR_9,VAR_50,TellBlob(VAR_9),
GetBlobSize(VAR_9));
if (VAR_12 == VAR_36)
break;
}
} while ((VAR_28 != 0) && (memcmp(VAR_8,""\122\314"",2) == 0));
(void) CloseBlob(VAR_9);
return(GetFirstImageInList(VAR_9));
}",ImageMagick/2ad6d33493750a28a5a655d319a8e0b16c392de1/rle.c/vul/before/0.json,"static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define SkipLinesOp  0x01
#define SetColorOp  0x02
#define SkipPixelsOp  0x03
#define ByteDataOp  0x05
#define RunDataOp  0x06
#define EOFOp  0x07

  char
    magick[12];

  Image
    *image;

  int
    opcode,
    operand,
    status;

  MagickStatusType
    flags;

  MagickSizeType
    number_pixels;

  MemoryInfo
    *pixel_info;

  Quantum
    index;

  register ssize_t
    x;

  register Quantum
    *q;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    bits_per_pixel,
    map_length,
    number_colormaps,
    number_planes,
    number_planes_filled,
    one,
    offset,
    pixel_info_length;

  ssize_t
    count,
    y;

  unsigned char
    background_color[256],
    *colormap,
    pixel,
    plane,
    *pixels;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  /*
    Determine if this a RLE file.
  */
  count=ReadBlob(image,2,(unsigned char *) magick);
  if ((count != 2) || (memcmp(magick,""\122\314"",2) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  do
  {
    /*
      Read image header.
    */
    image->page.x=ReadBlobLSBShort(image);
    image->page.y=ReadBlobLSBShort(image);
    image->columns=ReadBlobLSBShort(image);
    image->rows=ReadBlobLSBShort(image);
    flags=(MagickStatusType) ReadBlobByte(image);
    image->alpha_trait=flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait;
    number_planes=(size_t) ReadBlobByte(image);
    bits_per_pixel=(size_t) ReadBlobByte(image);
    number_colormaps=(size_t) ReadBlobByte(image);
    map_length=(unsigned char) ReadBlobByte(image);
    if (map_length >= 64)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    one=1;
    map_length=one << map_length;
    if ((number_planes == 0) || (number_planes == 2) || (bits_per_pixel != 8) ||
        (image->columns == 0))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if (flags & 0x02)
      {
        /*
          No background color-- initialize to black.
        */
        for (i=0; i < (ssize_t) number_planes; i++)
          background_color[i]=0;
        (void) ReadBlobByte(image);
      }
    else
      {
        /*
          Initialize background color.
        */
        p=background_color;
        for (i=0; i < (ssize_t) number_planes; i++)
          *p++=(unsigned char) ReadBlobByte(image);
      }
    if ((number_planes & 0x01) == 0)
      (void) ReadBlobByte(image);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    colormap=(unsigned char *) NULL;
    if (number_colormaps != 0)
      {
        /*
          Read image colormaps.
        */
        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,
          3*map_length*sizeof(*colormap));
        if (colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        p=colormap;
        for (i=0; i < (ssize_t) number_colormaps; i++)
          for (x=0; x < (ssize_t) map_length; x++)
            *p++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(image));
      }
    if ((flags & 0x08) != 0)
      {
        char
          *comment;

        size_t
          length;

        /*
          Read image comment.
        */
        length=ReadBlobLSBShort(image);
        if (length != 0)
          {
            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));
            if (comment == (char *) NULL)
              ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
            count=ReadBlob(image,length-1,(unsigned char *) comment);
            comment[length-1]='\0';
            (void) SetImageProperty(image,""comment"",comment,exception);
            comment=DestroyString(comment);
            if ((length & 0x01) == 0)
              (void) ReadBlobByte(image);
          }
      }
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    /*
      Allocate RLE pixels.
    */
    if (image->alpha_trait != UndefinedPixelTrait)
      number_planes++;
    number_pixels=(MagickSizeType) image->columns*image->rows;
    number_planes_filled=(number_planes % 2 == 0) ? number_planes :
      number_planes+1;
    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*
         number_planes_filled))
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    pixel_info_length=image->columns*image->rows*number_planes_filled;
    pixel_info=AcquireVirtualMemory(pixel_info_length,sizeof(*pixels));
    if (pixel_info == (MemoryInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
    if ((flags & 0x01) && !(flags & 0x02))
      {
        ssize_t
          j;

        /*
          Set background color.
        */
        p=pixels;
        for (i=0; i < (ssize_t) number_pixels; i++)
        {
          if (image->alpha_trait == UndefinedPixelTrait)
            for (j=0; j < (ssize_t) number_planes; j++)
              *p++=background_color[j];
          else
            {
              for (j=0; j < (ssize_t) (number_planes-1); j++)
                *p++=background_color[j];
              *p++=0;  /* initialize matte channel */
            }
        }
      }
    /*
      Read runlength-encoded image.
    */
    plane=0;
    x=0;
    y=0;
    opcode=ReadBlobByte(image);
    do
    {
      switch (opcode & 0x3f)
      {
        case SkipLinesOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=(int) ReadBlobLSBShort(image);
          x=0;
          y+=operand;
          break;
        }
        case SetColorOp:
        {
          operand=ReadBlobByte(image);
          plane=(unsigned char) operand;
          if (plane == 255)
            plane=(unsigned char) (number_planes-1);
          x=0;
          break;
        }
        case SkipPixelsOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=(int) ReadBlobLSBShort(image);
          x+=operand;
          break;
        }
        case ByteDataOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=(int) ReadBlobLSBShort(image);
          offset=((image->rows-y-1)*image->columns*number_planes)+x*
            number_planes+plane;
          operand++;
          if (offset+((size_t) operand*number_planes) > pixel_info_length)
            {
              if (number_colormaps != 0)
                colormap=(unsigned char *) RelinquishMagickMemory(colormap);
              pixel_info=RelinquishVirtualMemory(pixel_info);
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            }
          p=pixels+offset;
          for (i=0; i < (ssize_t) operand; i++)
          {
            pixel=(unsigned char) ReadBlobByte(image);
            if ((y < (ssize_t) image->rows) &&
                ((x+i) < (ssize_t) image->columns))
              *p=pixel;
            p+=number_planes;
          }
          if (operand & 0x01)
            (void) ReadBlobByte(image);
          x+=operand;
          break;
        }
        case RunDataOp:
        {
          operand=ReadBlobByte(image);
          if (opcode & 0x40)
            operand=(int) ReadBlobLSBShort(image);
          pixel=(unsigned char) ReadBlobByte(image);
          (void) ReadBlobByte(image);
          offset=((image->rows-y-1)*image->columns*number_planes)+x*
            number_planes+plane;
          operand++;
          if (offset+((size_t) operand*number_planes) > pixel_info_length)
            {
              if (number_colormaps != 0)
                colormap=(unsigned char *) RelinquishMagickMemory(colormap);
              pixel_info=RelinquishVirtualMemory(pixel_info);
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            }
          p=pixels+offset;
          for (i=0; i < (ssize_t) operand; i++)
          {
            if ((y < (ssize_t) image->rows) &&
                ((x+i) < (ssize_t) image->columns))
              *p=pixel;
            p+=number_planes;
          }
          x+=operand;
          break;
        }
        default:
          break;
      }
      opcode=ReadBlobByte(image);
    } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));
    if (number_colormaps != 0)
      {
        MagickStatusType
          mask;

        /*
          Apply colormap affineation to image.
        */
        mask=(MagickStatusType) (map_length-1);
        p=pixels;
        x=(ssize_t) number_planes;
        if (number_colormaps == 1)
          for (i=0; i < (ssize_t) number_pixels; i++)
          {
            if (IsValidColormapIndex(image,*p & mask,&index,exception) ==
                MagickFalse)
              break;
            *p=colormap[(ssize_t) index];
            p++;
          }
        else
          if ((number_planes >= 3) && (number_colormaps >= 3))
            for (i=0; i < (ssize_t) number_pixels; i++)
              for (x=0; x < (ssize_t) number_planes; x++)
              {
                if (IsValidColormapIndex(image,(size_t) (x*map_length+
                    (*p & mask)),&index,exception) == MagickFalse)
                  break;
                *p=colormap[(ssize_t) index];
                p++;
              }
        if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))
          {
            colormap=(unsigned char *) RelinquishMagickMemory(colormap);
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
          }
      }
    /*
      Initialize image structure.
    */
    if (number_planes >= 3)
      {
        /*
          Convert raster image to DirectClass pixel packets.
        */
        p=pixels;
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelRed(image,ScaleCharToQuantum(*p++),q);
            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
            if (image->alpha_trait != UndefinedPixelTrait)
              SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      }
    else
      {
        /*
          Create colormap.
        */
        if (number_colormaps == 0)
          map_length=256;
        if (AcquireImageColormap(image,map_length,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        p=colormap;
        if (number_colormaps == 1)
          for (i=0; i < (ssize_t) image->colors; i++)
          {
            /*
              Pseudocolor.
            */
            image->colormap[i].red=(MagickRealType)
              ScaleCharToQuantum((unsigned char) i);
            image->colormap[i].green=(MagickRealType)
              ScaleCharToQuantum((unsigned char) i);
            image->colormap[i].blue=(MagickRealType)
              ScaleCharToQuantum((unsigned char) i);
          }
        else
          if (number_colormaps > 1)
            for (i=0; i < (ssize_t) image->colors; i++)
            {
              image->colormap[i].red=(MagickRealType)
                ScaleCharToQuantum(*p);
              image->colormap[i].green=(MagickRealType)
                ScaleCharToQuantum(*(p+map_length));
              image->colormap[i].blue=(MagickRealType)
                ScaleCharToQuantum(*(p+map_length*2));
              p++;
            }
        p=pixels;
        if (image->alpha_trait == UndefinedPixelTrait)
          {
            /*
              Convert raster image to PseudoClass pixel packets.
            */
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                SetPixelIndex(image,*p++,q);
                q+=GetPixelChannels(image);
              }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
            (void) SyncImage(image,exception);
          }
        else
          {
            /*
              Image has a matte channel-- promote to DirectClass.
            */
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                if (IsValidColormapIndex(image,(ssize_t) *p++,&index,
                    exception) == MagickFalse)
                  break;
                SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)
                  index].red),q);
                if (IsValidColormapIndex(image,(ssize_t) *p++,&index,
                    exception) == MagickFalse)
                  break;
                SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)
                  index].green),q);
                if (IsValidColormapIndex(image,(ssize_t) *p++,&index,
                    exception) == MagickFalse)
                  break;
                SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)
                  index].blue),q);
                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
                q+=GetPixelChannels(image);
              }
              if (x < (ssize_t) image->columns)
                break;
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
            image->colormap=(PixelInfo *) RelinquishMagickMemory(
              image->colormap);
            image->storage_class=DirectClass;
            image->colors=0;
          }
      }
    if (number_colormaps != 0)
      colormap=(unsigned char *) RelinquishMagickMemory(colormap);
    pixel_info=RelinquishVirtualMemory(pixel_info);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    /*
      Proceed to next image.
    */
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    (void) ReadBlobByte(image);
    count=ReadBlob(image,2,(unsigned char *) magick);
    if ((count != 0) && (memcmp(magick,""\122\314"",2) == 0))
      {
        /*
          Allocate next image structure.
        */
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while ((count != 0) && (memcmp(magick,""\122\314"",2) == 0));
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}","static Image *ReadRLEImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define VAR_2  0x01
#define VAR_3  0x02
#define VAR_4  0x03
#define VAR_5  0x05
#define VAR_6  0x06
#define VAR_7  0x07

  char
    VAR_8[12];

  Image
    *VAR_9;

  int
    VAR_10,
    VAR_11,
    VAR_12;

  MagickStatusType
    VAR_13;

  MagickSizeType
    VAR_14;

  MemoryInfo
    *VAR_15;

  Quantum
    VAR_16;

  register ssize_t
    VAR_17;

  register Quantum
    *VAR_18;

  register ssize_t
    VAR_19;

  register unsigned char
    *VAR_20;

  size_t
    VAR_21,
    VAR_22,
    VAR_23,
    VAR_24,
    VAR_25,
    VAR_26,
    VAR_27,
    VAR_28;

  ssize_t
    VAR_29,
    VAR_30;

  unsigned char
    VAR_31[256],
    *VAR_32,
    VAR_33,
    VAR_34,
    *VAR_35;

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_36);
  if (VAR_0->debug != VAR_37)
    (void) LogMagickEvent(VAR_38,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_36);
  VAR_9=AcquireImage(VAR_0,VAR_1);
  VAR_12=OpenBlob(VAR_0,VAR_9,VAR_39,VAR_1);
  if (VAR_12 == VAR_37)
    return(DestroyImageList(VAR_9));
  /* COMMENT_3 */
                                 
    
  VAR_29=ReadBlob(VAR_9,2,(unsigned char *) VAR_8);
  if ((VAR_29 != 2) || (memcmp(VAR_8,""\122\314"",2) != 0))
    ThrowReaderException(VAR_40,""ImproperImageHeader"");
  do
  {
    /* COMMENT_6 */
                        
      
    VAR_9->page.x=ReadBlobLSBShort(VAR_9);
    VAR_9->page.y=ReadBlobLSBShort(VAR_9);
    VAR_9->columns=ReadBlobLSBShort(VAR_9);
    VAR_9->rows=ReadBlobLSBShort(VAR_9);
    VAR_13=(MagickStatusType) ReadBlobByte(VAR_9);
    VAR_9->alpha_trait=VAR_13 & 0x04 ? VAR_41 : VAR_42;
    VAR_24=(size_t) ReadBlobByte(VAR_9);
    VAR_21=(size_t) ReadBlobByte(VAR_9);
    VAR_23=(size_t) ReadBlobByte(VAR_9);
    VAR_22=(unsigned char) ReadBlobByte(VAR_9);
    if (VAR_22 >= 64)
      ThrowReaderException(VAR_40,""ImproperImageHeader"");
    VAR_26=1;
    VAR_22=VAR_26 << VAR_22;
    if ((VAR_24 == 0) || (VAR_24 == 2) || (VAR_21 != 8) ||
        (VAR_9->columns == 0))
      ThrowReaderException(VAR_40,""ImproperImageHeader"");
    if (VAR_13 & 0x02)
      {
        /* COMMENT_9 */
                                                    
          
        for (VAR_19=0; VAR_19 < (ssize_t) VAR_24; VAR_19++)
          VAR_31[VAR_19]=0;
        (void) ReadBlobByte(VAR_9);
      }
    else
      {
        /* COMMENT_12 */
                                      
          
        VAR_20=VAR_31;
        for (VAR_19=0; VAR_19 < (ssize_t) VAR_24; VAR_19++)
          *VAR_20++=(unsigned char) ReadBlobByte(VAR_9);
      }
    if ((VAR_24 & 0x01) == 0)
      (void) ReadBlobByte(VAR_9);
    if (EOFBlob(VAR_9) != VAR_37)
      {
        ThrowFileException(VAR_1,VAR_40,""UnexpectedEndOfFile"",
          VAR_9->filename);
        break;
      }
    VAR_32=(unsigned char *) NULL;
    if (VAR_23 != 0)
      {
        /* COMMENT_15 */
                               
          
        VAR_32=(unsigned char *) AcquireQuantumMemory(VAR_23,
          3*VAR_22*sizeof(*VAR_32));
        if (VAR_32 == (unsigned char *) NULL)
          ThrowReaderException(VAR_43,""MemoryAllocationFailed"");
        VAR_20=VAR_32;
        for (VAR_19=0; VAR_19 < (ssize_t) VAR_23; VAR_19++)
          for (VAR_17=0; VAR_17 < (ssize_t) VAR_22; VAR_17++)
            *VAR_20++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(VAR_9));
      }
    if ((VAR_13 & 0x08) != 0)
      {
        char
          *VAR_44;

        size_t
          VAR_45;

        /* COMMENT_18 */
                             
          
        VAR_45=ReadBlobLSBShort(VAR_9);
        if (VAR_45 != 0)
          {
            VAR_44=(char *) AcquireQuantumMemory(VAR_45,sizeof(*VAR_44));
            if (VAR_44 == (char *) NULL)
              ThrowReaderException(VAR_43,""MemoryAllocationFailed"");
            VAR_29=ReadBlob(VAR_9,VAR_45-1,(unsigned char *) VAR_44);
            VAR_44[VAR_45-1]='\0';
            (void) SetImageProperty(VAR_9,""comment"",VAR_44,VAR_1);
            VAR_44=DestroyString(VAR_44);
            if ((VAR_45 & 0x01) == 0)
              (void) ReadBlobByte(VAR_9);
          }
      }
    if ((VAR_0->ping != VAR_37) && (VAR_0->number_scenes != 0))
      if (VAR_9->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
        break;
    VAR_12=SetImageExtent(VAR_9,VAR_9->columns,VAR_9->rows,VAR_1);
    if (VAR_12 == VAR_37)
      return(DestroyImageList(VAR_9));
    /* COMMENT_21 */
                          
      
    if (VAR_9->alpha_trait != VAR_42)
      VAR_24++;
    VAR_14=(MagickSizeType) VAR_9->columns*VAR_9->rows;
    VAR_25=(VAR_24 % 2 == 0) ? VAR_24 :
      VAR_24+1;
    if ((VAR_14*VAR_25) != (size_t) (VAR_14*
         VAR_25))
      ThrowReaderException(VAR_43,""MemoryAllocationFailed"");
    VAR_28=VAR_9->columns*VAR_9->rows*VAR_25;
    VAR_15=AcquireVirtualMemory(VAR_28,sizeof(*VAR_35));
    if (VAR_15 == (MemoryInfo *) NULL)
      ThrowReaderException(VAR_43,""MemoryAllocationFailed"");
    VAR_35=(unsigned char *) GetVirtualMemoryBlob(VAR_15);
    if ((VAR_13 & 0x01) && !(VAR_13 & 0x02))
      {
        ssize_t
          VAR_46;

        /* COMMENT_24 */
                               
          
        VAR_20=VAR_35;
        for (VAR_19=0; VAR_19 < (ssize_t) VAR_14; VAR_19++)
        {
          if (VAR_9->alpha_trait == VAR_42)
            for (VAR_46=0; VAR_46 < (ssize_t) VAR_24; VAR_46++)
              *VAR_20++=VAR_31[VAR_46];
          else
            {
              for (VAR_46=0; VAR_46 < (ssize_t) (VAR_24-1); VAR_46++)
                *VAR_20++=VAR_31[VAR_46];
              *VAR_20++=0;  /* COMMENT_27 */
            }
        }
      }
    /* COMMENT_28 */
                                   
      
    VAR_34=0;
    VAR_17=0;
    VAR_30=0;
    VAR_10=ReadBlobByte(VAR_9);
    do
    {
      switch (VAR_10 & 0x3f)
      {
        case VAR_2:
        {
          VAR_11=ReadBlobByte(VAR_9);
          if (VAR_10 & 0x40)
            VAR_11=(int) ReadBlobLSBShort(VAR_9);
          VAR_17=0;
          VAR_30+=VAR_11;
          break;
        }
        case VAR_3:
        {
          VAR_11=ReadBlobByte(VAR_9);
          VAR_34=(unsigned char) VAR_11;
          if (VAR_34 == 255)
            VAR_34=(unsigned char) (VAR_24-1);
          VAR_17=0;
          break;
        }
        case VAR_4:
        {
          VAR_11=ReadBlobByte(VAR_9);
          if (VAR_10 & 0x40)
            VAR_11=(int) ReadBlobLSBShort(VAR_9);
          VAR_17+=VAR_11;
          break;
        }
        case VAR_5:
        {
          VAR_11=ReadBlobByte(VAR_9);
          if (VAR_10 & 0x40)
            VAR_11=(int) ReadBlobLSBShort(VAR_9);
          VAR_27=((VAR_9->rows-VAR_30-1)*VAR_9->columns*VAR_24)+VAR_17*
            VAR_24+VAR_34;
          VAR_11++;
          if (VAR_27+((size_t) VAR_11*VAR_24) > VAR_28)
            {
              if (VAR_23 != 0)
                VAR_32=(unsigned char *) RelinquishMagickMemory(VAR_32);
              VAR_15=RelinquishVirtualMemory(VAR_15);
              ThrowReaderException(VAR_40,""UnableToReadImageData"");
            }
          VAR_20=VAR_35+VAR_27;
          for (VAR_19=0; VAR_19 < (ssize_t) VAR_11; VAR_19++)
          {
            VAR_33=(unsigned char) ReadBlobByte(VAR_9);
            if ((VAR_30 < (ssize_t) VAR_9->rows) &&
                ((VAR_17+VAR_19) < (ssize_t) VAR_9->columns))
              *VAR_20=VAR_33;
            VAR_20+=VAR_24;
          }
          if (VAR_11 & 0x01)
            (void) ReadBlobByte(VAR_9);
          VAR_17+=VAR_11;
          break;
        }
        case VAR_6:
        {
          VAR_11=ReadBlobByte(VAR_9);
          if (VAR_10 & 0x40)
            VAR_11=(int) ReadBlobLSBShort(VAR_9);
          VAR_33=(unsigned char) ReadBlobByte(VAR_9);
          (void) ReadBlobByte(VAR_9);
          VAR_27=((VAR_9->rows-VAR_30-1)*VAR_9->columns*VAR_24)+VAR_17*
            VAR_24+VAR_34;
          VAR_11++;
          if (VAR_27+((size_t) VAR_11*VAR_24) > VAR_28)
            {
              if (VAR_23 != 0)
                VAR_32=(unsigned char *) RelinquishMagickMemory(VAR_32);
              VAR_15=RelinquishVirtualMemory(VAR_15);
              ThrowReaderException(VAR_40,""UnableToReadImageData"");
            }
          VAR_20=VAR_35+VAR_27;
          for (VAR_19=0; VAR_19 < (ssize_t) VAR_11; VAR_19++)
          {
            if ((VAR_30 < (ssize_t) VAR_9->rows) &&
                ((VAR_17+VAR_19) < (ssize_t) VAR_9->columns))
              *VAR_20=VAR_33;
            VAR_20+=VAR_24;
          }
          VAR_17+=VAR_11;
          break;
        }
        default:
          break;
      }
      VAR_10=ReadBlobByte(VAR_9);
    } while (((VAR_10 & 0x3f) != VAR_7) && (VAR_10 != VAR_47));
    if (VAR_23 != 0)
      {
        MagickStatusType
          VAR_48;

        /* COMMENT_31 */
                                              
          
        VAR_48=(MagickStatusType) (VAR_22-1);
        VAR_20=VAR_35;
        VAR_17=(ssize_t) VAR_24;
        if (VAR_23 == 1)
          for (VAR_19=0; VAR_19 < (ssize_t) VAR_14; VAR_19++)
          {
            if (IsValidColormapIndex(VAR_9,*VAR_20 & VAR_48,&VAR_16,VAR_1) ==
                VAR_37)
              break;
            *VAR_20=VAR_32[(ssize_t) VAR_16];
            VAR_20++;
          }
        else
          if ((VAR_24 >= 3) && (VAR_23 >= 3))
            for (VAR_19=0; VAR_19 < (ssize_t) VAR_14; VAR_19++)
              for (VAR_17=0; VAR_17 < (ssize_t) VAR_24; VAR_17++)
              {
                if (IsValidColormapIndex(VAR_9,(size_t) (VAR_17*VAR_22+
                    (*VAR_20 & VAR_48)),&VAR_16,VAR_1) == VAR_37)
                  break;
                *VAR_20=VAR_32[(ssize_t) VAR_16];
                VAR_20++;
              }
        if ((VAR_19 < (ssize_t) VAR_14) || (VAR_17 < (ssize_t) VAR_24))
          {
            VAR_32=(unsigned char *) RelinquishMagickMemory(VAR_32);
            VAR_15=RelinquishVirtualMemory(VAR_15);
            ThrowReaderException(VAR_40,""UnableToReadImageData"");
          }
      }
    /* COMMENT_34 */
                                 
      
    if (VAR_24 >= 3)
      {
        /* COMMENT_37 */
                                                            
          
        VAR_20=VAR_35;
        for (VAR_30=0; VAR_30 < (ssize_t) VAR_9->rows; VAR_30++)
        {
          VAR_18=QueueAuthenticPixels(VAR_9,0,VAR_30,VAR_9->columns,1,VAR_1);
          if (VAR_18 == (Quantum *) NULL)
            break;
          for (VAR_17=0; VAR_17 < (ssize_t) VAR_9->columns; VAR_17++)
          {
            SetPixelRed(VAR_9,ScaleCharToQuantum(*VAR_20++),VAR_18);
            SetPixelGreen(VAR_9,ScaleCharToQuantum(*VAR_20++),VAR_18);
            SetPixelBlue(VAR_9,ScaleCharToQuantum(*VAR_20++),VAR_18);
            if (VAR_9->alpha_trait != VAR_42)
              SetPixelAlpha(VAR_9,ScaleCharToQuantum(*VAR_20++),VAR_18);
            VAR_18+=GetPixelChannels(VAR_9);
          }
          if (SyncAuthenticPixels(VAR_9,VAR_1) == VAR_37)
            break;
          if (VAR_9->previous == (Image *) NULL)
            {
              VAR_12=SetImageProgress(VAR_9,VAR_49,(MagickOffsetType) VAR_30,
                VAR_9->rows);
              if (VAR_12 == VAR_37)
                break;
            }
        }
      }
    else
      {
        /* COMMENT_40 */
                          
          
        if (VAR_23 == 0)
          VAR_22=256;
        if (AcquireImageColormap(VAR_9,VAR_22,VAR_1) == VAR_37)
          ThrowReaderException(VAR_43,""MemoryAllocationFailed"");
        VAR_20=VAR_32;
        if (VAR_23 == 1)
          for (VAR_19=0; VAR_19 < (ssize_t) VAR_9->colors; VAR_19++)
          {
            /* COMMENT_43 */
                          
              
            VAR_9->colormap[VAR_19].red=(MagickRealType)
              ScaleCharToQuantum((unsigned char) VAR_19);
            VAR_9->colormap[VAR_19].green=(MagickRealType)
              ScaleCharToQuantum((unsigned char) VAR_19);
            VAR_9->colormap[VAR_19].blue=(MagickRealType)
              ScaleCharToQuantum((unsigned char) VAR_19);
          }
        else
          if (VAR_23 > 1)
            for (VAR_19=0; VAR_19 < (ssize_t) VAR_9->colors; VAR_19++)
            {
              VAR_9->colormap[VAR_19].red=(MagickRealType)
                ScaleCharToQuantum(*VAR_20);
              VAR_9->colormap[VAR_19].green=(MagickRealType)
                ScaleCharToQuantum(*(VAR_20+VAR_22));
              VAR_9->colormap[VAR_19].blue=(MagickRealType)
                ScaleCharToQuantum(*(VAR_20+VAR_22*2));
              VAR_20++;
            }
        VAR_20=VAR_35;
        if (VAR_9->alpha_trait == VAR_42)
          {
            /* COMMENT_46 */
                                                                
              
            for (VAR_30=0; VAR_30 < (ssize_t) VAR_9->rows; VAR_30++)
            {
              VAR_18=QueueAuthenticPixels(VAR_9,0,VAR_30,VAR_9->columns,1,VAR_1);
              if (VAR_18 == (Quantum *) NULL)
                break;
              for (VAR_17=0; VAR_17 < (ssize_t) VAR_9->columns; VAR_17++)
              {
                SetPixelIndex(VAR_9,*VAR_20++,VAR_18);
                VAR_18+=GetPixelChannels(VAR_9);
              }
              if (SyncAuthenticPixels(VAR_9,VAR_1) == VAR_37)
                break;
              if (VAR_9->previous == (Image *) NULL)
                {
                  VAR_12=SetImageProgress(VAR_9,VAR_49,(MagickOffsetType)
                    VAR_30,VAR_9->rows);
                  if (VAR_12 == VAR_37)
                    break;
                }
            }
            (void) SyncImage(VAR_9,VAR_1);
          }
        else
          {
            /* COMMENT_49 */
                                                                 
              
            for (VAR_30=0; VAR_30 < (ssize_t) VAR_9->rows; VAR_30++)
            {
              VAR_18=QueueAuthenticPixels(VAR_9,0,VAR_30,VAR_9->columns,1,VAR_1);
              if (VAR_18 == (Quantum *) NULL)
                break;
              for (VAR_17=0; VAR_17 < (ssize_t) VAR_9->columns; VAR_17++)
              {
                if (IsValidColormapIndex(VAR_9,(ssize_t) *VAR_20++,&VAR_16,
                    VAR_1) == VAR_37)
                  break;
                SetPixelRed(VAR_9,ClampToQuantum(VAR_9->colormap[(ssize_t)
                  VAR_16].red),VAR_18);
                if (IsValidColormapIndex(VAR_9,(ssize_t) *VAR_20++,&VAR_16,
                    VAR_1) == VAR_37)
                  break;
                SetPixelGreen(VAR_9,ClampToQuantum(VAR_9->colormap[(ssize_t)
                  VAR_16].green),VAR_18);
                if (IsValidColormapIndex(VAR_9,(ssize_t) *VAR_20++,&VAR_16,
                    VAR_1) == VAR_37)
                  break;
                SetPixelBlue(VAR_9,ClampToQuantum(VAR_9->colormap[(ssize_t)
                  VAR_16].blue),VAR_18);
                SetPixelAlpha(VAR_9,ScaleCharToQuantum(*VAR_20++),VAR_18);
                VAR_18+=GetPixelChannels(VAR_9);
              }
              if (VAR_17 < (ssize_t) VAR_9->columns)
                break;
              if (SyncAuthenticPixels(VAR_9,VAR_1) == VAR_37)
                break;
              if (VAR_9->previous == (Image *) NULL)
                {
                  VAR_12=SetImageProgress(VAR_9,VAR_49,(MagickOffsetType)
                    VAR_30,VAR_9->rows);
                  if (VAR_12 == VAR_37)
                    break;
                }
            }
            VAR_9->colormap=(PixelInfo *) RelinquishMagickMemory(
              VAR_9->colormap);
            VAR_9->storage_class=VAR_50;
            VAR_9->colors=0;
          }
      }
    if (VAR_23 != 0)
      VAR_32=(unsigned char *) RelinquishMagickMemory(VAR_32);
    VAR_15=RelinquishVirtualMemory(VAR_15);
    if (EOFBlob(VAR_9) != VAR_37)
      {
        ThrowFileException(VAR_1,VAR_40,""UnexpectedEndOfFile"",
          VAR_9->filename);
        break;
      }
    /* COMMENT_52 */
                            
      
    if (VAR_0->number_scenes != 0)
      if (VAR_9->scene >= (VAR_0->scene+VAR_0->number_scenes-1))
        break;
    (void) ReadBlobByte(VAR_9);
    VAR_29=ReadBlob(VAR_9,2,(unsigned char *) VAR_8);
    if ((VAR_29 != 0) && (memcmp(VAR_8,""\122\314"",2) == 0))
      {
        /* COMMENT_55 */
                                        
          
        AcquireNextImage(VAR_0,VAR_9,VAR_1);
        if (GetNextImageInList(VAR_9) == (Image *) NULL)
          {
            VAR_9=DestroyImageList(VAR_9);
            return((Image *) NULL);
          }
        VAR_9=SyncNextImageInList(VAR_9);
        VAR_12=SetImageProgress(VAR_9,VAR_51,TellBlob(VAR_9),
          GetBlobSize(VAR_9));
        if (VAR_12 == VAR_37)
          break;
      }
  } while ((VAR_29 != 0) && (memcmp(VAR_8,""\122\314"",2) == 0));
  (void) CloseBlob(VAR_9);
  return(GetFirstImageInList(VAR_9));
}",ImageMagick/2ad6d33493750a28a5a655d319a8e0b16c392de1/rle.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -47,6 +47,7 @@
     map_length,
     number_colormaps,
     number_planes,
+    number_planes_filled,
     one,
     offset,
     pixel_info_length;
@@ -182,9 +183,12 @@
     if (image->alpha_trait != UndefinedPixelTrait)
       number_planes++;
     number_pixels=(MagickSizeType) image->columns*image->rows;
-    if ((number_pixels*number_planes) != (size_t) (number_pixels*number_planes))
+    number_planes_filled=(number_planes % 2 == 0) ? number_planes :
+      number_planes+1;
+    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*
+         number_planes_filled))
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
-    pixel_info_length=image->columns*image->rows*MagickMax(number_planes,4);
+    pixel_info_length=image->columns*image->rows*number_planes_filled;
     pixel_info=AcquireVirtualMemory(pixel_info_length,sizeof(*pixels));
     if (pixel_info == (MemoryInfo *) NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");","{'deleted_lines': ['    if ((number_pixels*number_planes) != (size_t) (number_pixels*number_planes))', '    pixel_info_length=image->columns*image->rows*MagickMax(number_planes,4);'], 'added_lines': ['    number_planes_filled,', '    number_planes_filled=(number_planes % 2 == 0) ? number_planes :', '      number_planes+1;', '    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*', '         number_planes_filled))', '    pixel_info_length=image->columns*image->rows*number_planes_filled;']}",True,The ReadRLEImage function in coders/rle.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via vectors related to the number of pixels.,6.5,MEDIUM,1,test,2015-10-05T20:11:31Z,1
CVE-2015-8374,['CWE-200'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,torvalds/linux,"Btrfs: fix truncation of compressed and inlined extents

When truncating a file to a smaller size which consists of an inline
extent that is compressed, we did not discard (or made unusable) the
data between the new file size and the old file size, wasting metadata
space and allowing for the truncated data to be leaked and the data
corruption/loss mentioned below.
We were also not correctly decrementing the number of bytes used by the
inode, we were setting it to zero, giving a wrong report for callers of
the stat(2) syscall. The fsck tool also reported an error about a mismatch
between the nbytes of the file versus the real space used by the file.

Now because we weren't discarding the truncated region of the file, it
was possible for a caller of the clone ioctl to actually read the data
that was truncated, allowing for a security breach without requiring root
access to the system, using only standard filesystem operations. The
scenario is the following:

   1) User A creates a file which consists of an inline and compressed
      extent with a size of 2000 bytes - the file is not accessible to
      any other users (no read, write or execution permission for anyone
      else);

   2) The user truncates the file to a size of 1000 bytes;

   3) User A makes the file world readable;

   4) User B creates a file consisting of an inline extent of 2000 bytes;

   5) User B issues a clone operation from user A's file into its own
      file (using a length argument of 0, clone the whole range);

   6) User B now gets to see the 1000 bytes that user A truncated from
      its file before it made its file world readbale. User B also lost
      the bytes in the range [1000, 2000[ bytes from its own file, but
      that might be ok if his/her intention was reading stale data from
      user A that was never supposed to be public.

Note that this contrasts with the case where we truncate a file from 2000
bytes to 1000 bytes and then truncate it back from 1000 to 2000 bytes. In
this case reading any byte from the range [1000, 2000[ will return a value
of 0x00, instead of the original data.

This problem exists since the clone ioctl was added and happens both with
and without my recent data loss and file corruption fixes for the clone
ioctl (patch ""Btrfs: fix file corruption and data loss after cloning
inline extents"").

So fix this by truncating the compressed inline extents as we do for the
non-compressed case, which involves decompressing, if the data isn't already
in the page cache, compressing the truncated version of the extent, writing
the compressed content into the inline extent and then truncate it.

The following test case for fstests reproduces the problem. In order for
the test to pass both this fix and my previous fix for the clone ioctl
that forbids cloning a smaller inline extent into a larger one,
which is titled ""Btrfs: fix file corruption and data loss after cloning
inline extents"", are needed. Without that other fix the test fails in a
different way that does not leak the truncated data, instead part of
destination file gets replaced with zeroes (because the destination file
has a larger inline extent than the source).

  seq=`basename $0`
  seqres=$RESULT_DIR/$seq
  echo ""QA output created by $seq""
  tmp=/tmp/$$
  status=1	# failure is the default!
  trap ""_cleanup; exit \$status"" 0 1 2 3 15

  _cleanup()
  {
      rm -f $tmp.*
  }

  # get standard environment, filters and checks
  . ./common/rc
  . ./common/filter

  # real QA test starts here
  _need_to_be_root
  _supported_fs btrfs
  _supported_os Linux
  _require_scratch
  _require_cloner

  rm -f $seqres.full

  _scratch_mkfs >>$seqres.full 2>&1
  _scratch_mount ""-o compress""

  # Create our test files. File foo is going to be the source of a clone operation
  # and consists of a single inline extent with an uncompressed size of 512 bytes,
  # while file bar consists of a single inline extent with an uncompressed size of
  # 256 bytes. For our test's purpose, it's important that file bar has an inline
  # extent with a size smaller than foo's inline extent.
  $XFS_IO_PROG -f -c ""pwrite -S 0xa1 0 128""   \
          -c ""pwrite -S 0x2a 128 384"" \
          $SCRATCH_MNT/foo | _filter_xfs_io
  $XFS_IO_PROG -f -c ""pwrite -S 0xbb 0 256"" $SCRATCH_MNT/bar | _filter_xfs_io

  # Now durably persist all metadata and data. We do this to make sure that we get
  # on disk an inline extent with a size of 512 bytes for file foo.
  sync

  # Now truncate our file foo to a smaller size. Because it consists of a
  # compressed and inline extent, btrfs did not shrink the inline extent to the
  # new size (if the extent was not compressed, btrfs would shrink it to 128
  # bytes), it only updates the inode's i_size to 128 bytes.
  $XFS_IO_PROG -c ""truncate 128"" $SCRATCH_MNT/foo

  # Now clone foo's inline extent into bar.
  # This clone operation should fail with errno EOPNOTSUPP because the source
  # file consists only of an inline extent and the file's size is smaller than
  # the inline extent of the destination (128 bytes < 256 bytes). However the
  # clone ioctl was not prepared to deal with a file that has a size smaller
  # than the size of its inline extent (something that happens only for compressed
  # inline extents), resulting in copying the full inline extent from the source
  # file into the destination file.
  #
  # Note that btrfs' clone operation for inline extents consists of removing the
  # inline extent from the destination inode and copy the inline extent from the
  # source inode into the destination inode, meaning that if the destination
  # inode's inline extent is larger (N bytes) than the source inode's inline
  # extent (M bytes), some bytes (N - M bytes) will be lost from the destination
  # file. Btrfs could copy the source inline extent's data into the destination's
  # inline extent so that we would not lose any data, but that's currently not
  # done due to the complexity that would be needed to deal with such cases
  # (specially when one or both extents are compressed), returning EOPNOTSUPP, as
  # it's normally not a very common case to clone very small files (only case
  # where we get inline extents) and copying inline extents does not save any
  # space (unlike for normal, non-inlined extents).
  $CLONER_PROG -s 0 -d 0 -l 0 $SCRATCH_MNT/foo $SCRATCH_MNT/bar

  # Now because the above clone operation used to succeed, and due to foo's inline
  # extent not being shinked by the truncate operation, our file bar got the whole
  # inline extent copied from foo, making us lose the last 128 bytes from bar
  # which got replaced by the bytes in range [128, 256[ from foo before foo was
  # truncated - in other words, data loss from bar and being able to read old and
  # stale data from foo that should not be possible to read anymore through normal
  # filesystem operations. Contrast with the case where we truncate a file from a
  # size N to a smaller size M, truncate it back to size N and then read the range
  # [M, N[, we should always get the value 0x00 for all the bytes in that range.

  # We expected the clone operation to fail with errno EOPNOTSUPP and therefore
  # not modify our file's bar data/metadata. So its content should be 256 bytes
  # long with all bytes having the value 0xbb.
  #
  # Without the btrfs bug fix, the clone operation succeeded and resulted in
  # leaking truncated data from foo, the bytes that belonged to its range
  # [128, 256[, and losing data from bar in that same range. So reading the
  # file gave us the following content:
  #
  # 0000000 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1
  # *
  # 0000200 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a
  # *
  # 0000400
  echo ""File bar's content after the clone operation:""
  od -t x1 $SCRATCH_MNT/bar

  # Also because the foo's inline extent was not shrunk by the truncate
  # operation, btrfs' fsck, which is run by the fstests framework everytime a
  # test completes, failed reporting the following error:
  #
  #  root 5 inode 257 errors 400, nbytes wrong

  status=0
  exit

Cc: stable@vger.kernel.org
Signed-off-by: Filipe Manana <fdmanana@suse.com>",0305cd5f7fca85dae392b9ba85b116896eb7c1c7,https://github.com/torvalds/linux/commit/0305cd5f7fca85dae392b9ba85b116896eb7c1c7,fs/btrfs/inode.c,btrfs_truncate_inode_items,"int btrfs_truncate_inode_items(struct btrfs_trans_handle *trans,
struct btrfs_root *root,
struct inode *inode,
u64 new_size, u32 min_type)
{
struct btrfs_path *path;
struct extent_buffer *leaf;
struct btrfs_file_extent_item *fi;
struct btrfs_key key;
struct btrfs_key found_key;
u64 extent_start = 0;
u64 extent_num_bytes = 0;
u64 extent_offset = 0;
u64 item_end = 0;
u64 last_size = new_size;
u32 found_type = (u8)-1;
int found_extent;
int del_item;
int pending_del_nr = 0;
int pending_del_slot = 0;
int extent_type = -1;
int ret;
int err = 0;
u64 ino = btrfs_ino(inode);
u64 bytes_deleted = 0;
bool be_nice = 0;
bool should_throttle = 0;
bool should_end = 0;
BUG_ON(new_size > 0 && min_type != BTRFS_EXTENT_DATA_KEY);
if (!btrfs_is_free_space_inode(inode) &&
test_bit(BTRFS_ROOT_REF_COWS, &root->state))
be_nice = 1;
path = btrfs_alloc_path();
if (!path)
return -ENOMEM;
path->reada = -1;
if (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||
root == root->fs_info->tree_root)
btrfs_drop_extent_cache(inode, ALIGN(new_size,
root->sectorsize), (u64)-1, 0);
if (min_type == 0 && root == BTRFS_I(inode)->root)
btrfs_kill_delayed_inode_items(inode);
key.objectid = ino;
key.offset = (u64)-1;
key.type = (u8)-1;
search_again:
if (be_nice && bytes_deleted > 32 * 1024 * 1024) {
if (btrfs_should_end_transaction(trans, root)) {
err = -EAGAIN;
goto error;
}
}
path->leave_spinning = 1;
ret = btrfs_search_slot(trans, root, &key, path, -1, 1);
if (ret < 0) {
err = ret;
goto out;
}
if (ret > 0) {
if (path->slots[0] == 0)
goto out;
path->slots[0]--;
}
while (1) {
fi = NULL;
leaf = path->nodes[0];
btrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);
found_type = found_key.type;
if (found_key.objectid != ino)
break;
if (found_type < min_type)
break;
item_end = found_key.offset;
if (found_type == BTRFS_EXTENT_DATA_KEY) {
fi = btrfs_item_ptr(leaf, path->slots[0],
struct btrfs_file_extent_item);
extent_type = btrfs_file_extent_type(leaf, fi);
if (extent_type != BTRFS_FILE_EXTENT_INLINE) {
item_end +=
btrfs_file_extent_num_bytes(leaf, fi);
} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {
item_end += btrfs_file_extent_inline_len(leaf,
path->slots[0], fi);
}
item_end--;
}
if (found_type > min_type) {
del_item = 1;
} else {
if (item_end < new_size)
break;
if (found_key.offset >= new_size)
del_item = 1;
else
del_item = 0;
}
found_extent = 0;
if (found_type != BTRFS_EXTENT_DATA_KEY)
goto delete;
if (del_item)
last_size = found_key.offset;
else
last_size = new_size;
if (extent_type != BTRFS_FILE_EXTENT_INLINE) {
u64 num_dec;
extent_start = btrfs_file_extent_disk_bytenr(leaf, fi);
if (!del_item) {
u64 orig_num_bytes =
btrfs_file_extent_num_bytes(leaf, fi);
extent_num_bytes = ALIGN(new_size -
found_key.offset,
root->sectorsize);
btrfs_set_file_extent_num_bytes(leaf, fi,
extent_num_bytes);
num_dec = (orig_num_bytes -
extent_num_bytes);
if (test_bit(BTRFS_ROOT_REF_COWS,
&root->state) &&
extent_start != 0)
inode_sub_bytes(inode, num_dec);
btrfs_mark_buffer_dirty(leaf);
} else {
extent_num_bytes =
btrfs_file_extent_disk_num_bytes(leaf,
fi);
extent_offset = found_key.offset -
btrfs_file_extent_offset(leaf, fi);
num_dec = btrfs_file_extent_num_bytes(leaf, fi);
if (extent_start != 0) {
found_extent = 1;
if (test_bit(BTRFS_ROOT_REF_COWS,
&root->state))
inode_sub_bytes(inode, num_dec);
}
}
} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {
if (!del_item &&
btrfs_file_extent_compression(leaf, fi) == 0 &&
btrfs_file_extent_encryption(leaf, fi) == 0 &&
btrfs_file_extent_other_encoding(leaf, fi) == 0) {
u32 size = new_size - found_key.offset;
if (test_bit(BTRFS_ROOT_REF_COWS, &root->state))
inode_sub_bytes(inode, item_end + 1 -
new_size);
btrfs_set_file_extent_ram_bytes(leaf, fi, size);
size =
btrfs_file_extent_calc_inline_size(size);
btrfs_truncate_item(root, path, size, 1);
} else if (test_bit(BTRFS_ROOT_REF_COWS,
&root->state)) {
inode_sub_bytes(inode, item_end + 1 -
found_key.offset);
}
}
delete:
if (del_item) {
if (!pending_del_nr) {
pending_del_slot = path->slots[0];
pending_del_nr = 1;
} else if (pending_del_nr &&
path->slots[0] + 1 == pending_del_slot) {
pending_del_nr++;
pending_del_slot = path->slots[0];
} else {
BUG();
}
} else {
break;
}
should_throttle = 0;
if (found_extent &&
(test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||
root == root->fs_info->tree_root)) {
btrfs_set_path_blocking(path);
bytes_deleted += extent_num_bytes;
ret = btrfs_free_extent(trans, root, extent_start,
extent_num_bytes, 0,
btrfs_header_owner(leaf),
ino, extent_offset, 0);
BUG_ON(ret);
if (btrfs_should_throttle_delayed_refs(trans, root))
btrfs_async_run_delayed_refs(root,
trans->delayed_ref_updates * 2, 0);
if (be_nice) {
if (truncate_space_check(trans, root,
extent_num_bytes)) {
should_end = 1;
}
if (btrfs_should_throttle_delayed_refs(trans,
root)) {
should_throttle = 1;
}
}
}
if (found_type == BTRFS_INODE_ITEM_KEY)
break;
if (path->slots[0] == 0 ||
path->slots[0] != pending_del_slot ||
should_throttle || should_end) {
if (pending_del_nr) {
ret = btrfs_del_items(trans, root, path,
pending_del_slot,
pending_del_nr);
if (ret) {
btrfs_abort_transaction(trans,
root, ret);
goto error;
}
pending_del_nr = 0;
}
btrfs_release_path(path);
if (should_throttle) {
unsigned long updates = trans->delayed_ref_updates;
if (updates) {
trans->delayed_ref_updates = 0;
ret = btrfs_run_delayed_refs(trans, root, updates * 2);
if (ret && !err)
err = ret;
}
}
if (should_end) {
err = -EAGAIN;
goto error;
}
goto search_again;
} else {
path->slots[0]--;
}
}
out:
if (pending_del_nr) {
ret = btrfs_del_items(trans, root, path, pending_del_slot,
pending_del_nr);
if (ret)
btrfs_abort_transaction(trans, root, ret);
}
error:
if (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)
btrfs_ordered_update_i_size(inode, last_size, NULL);
btrfs_free_path(path);
if (be_nice && bytes_deleted > 32 * 1024 * 1024) {
unsigned long updates = trans->delayed_ref_updates;
if (updates) {
trans->delayed_ref_updates = 0;
ret = btrfs_run_delayed_refs(trans, root, updates * 2);
if (ret && !err)
err = ret;
}
}
return err;
}","int btrfs_truncate_inode_items(struct btrfs_trans_handle *VAR_0,
struct btrfs_root *VAR_1,
struct inode *inode,
u64 VAR_2, u32 VAR_3)
{
struct btrfs_path *VAR_4;
struct extent_buffer *VAR_5;
struct btrfs_file_extent_item *VAR_6;
struct btrfs_key VAR_7;
struct btrfs_key VAR_8;
u64 VAR_9 = 0;
u64 VAR_10 = 0;
u64 VAR_11 = 0;
u64 VAR_12 = 0;
u64 VAR_13 = VAR_2;
u32 VAR_14 = (VAR_15)-1;
int VAR_16;
int VAR_17;
int VAR_18 = 0;
int VAR_19 = 0;
int VAR_20 = -1;
int VAR_21;
int VAR_22 = 0;
u64 VAR_23 = btrfs_ino(inode);
u64 VAR_24 = 0;
bool VAR_25 = 0;
bool VAR_26 = 0;
bool VAR_27 = 0;
BUG_ON(VAR_2 > 0 && VAR_3 != VAR_28);
if (!btrfs_is_free_space_inode(inode) &&
test_bit(VAR_29, &VAR_1->state))
VAR_25 = 1;
VAR_4 = btrfs_alloc_path();
if (!VAR_4)
return -VAR_30;
VAR_4->reada = -1;
if (test_bit(VAR_29, &VAR_1->state) ||
VAR_1 == VAR_1->fs_info->tree_root)
btrfs_drop_extent_cache(inode, ALIGN(VAR_2,
VAR_1->sectorsize), (u64)-1, 0);
if (VAR_3 == 0 && VAR_1 == BTRFS_I(inode)->root)
btrfs_kill_delayed_inode_items(inode);
VAR_7.objectid = VAR_23;
VAR_7.offset = (u64)-1;
VAR_7.type = (VAR_15)-1;
search_again:
if (VAR_25 && VAR_24 > 32 * 1024 * 1024) {
if (btrfs_should_end_transaction(VAR_0, VAR_1)) {
VAR_22 = -VAR_31;
goto error;
}
}
VAR_4->leave_spinning = 1;
VAR_21 = btrfs_search_slot(VAR_0, VAR_1, &VAR_7, VAR_4, -1, 1);
if (VAR_21 < 0) {
VAR_22 = VAR_21;
goto out;
}
if (VAR_21 > 0) {
if (VAR_4->slots[0] == 0)
goto out;
VAR_4->slots[0]--;
}
while (1) {
VAR_6 = NULL;
VAR_5 = VAR_4->nodes[0];
btrfs_item_key_to_cpu(VAR_5, &VAR_8, VAR_4->slots[0]);
VAR_14 = VAR_8.type;
if (VAR_8.objectid != VAR_23)
break;
if (VAR_14 < VAR_3)
break;
VAR_12 = VAR_8.offset;
if (VAR_14 == VAR_28) {
VAR_6 = btrfs_item_ptr(VAR_5, VAR_4->slots[0],
struct btrfs_file_extent_item);
VAR_20 = btrfs_file_extent_type(VAR_5, VAR_6);
if (VAR_20 != VAR_32) {
VAR_12 +=
btrfs_file_extent_num_bytes(VAR_5, VAR_6);
} else if (VAR_20 == VAR_32) {
VAR_12 += btrfs_file_extent_inline_len(VAR_5,
VAR_4->slots[0], VAR_6);
}
VAR_12--;
}
if (VAR_14 > VAR_3) {
VAR_17 = 1;
} else {
if (VAR_12 < VAR_2)
break;
if (VAR_8.offset >= VAR_2)
VAR_17 = 1;
else
VAR_17 = 0;
}
VAR_16 = 0;
if (VAR_14 != VAR_28)
goto delete;
if (VAR_17)
VAR_13 = VAR_8.offset;
else
VAR_13 = VAR_2;
if (VAR_20 != VAR_32) {
u64 VAR_33;
VAR_9 = btrfs_file_extent_disk_bytenr(VAR_5, VAR_6);
if (!VAR_17) {
u64 VAR_34 =
btrfs_file_extent_num_bytes(VAR_5, VAR_6);
VAR_10 = ALIGN(VAR_2 -
VAR_8.offset,
VAR_1->sectorsize);
btrfs_set_file_extent_num_bytes(VAR_5, VAR_6,
VAR_10);
VAR_33 = (VAR_34 -
VAR_10);
if (test_bit(VAR_29,
&VAR_1->state) &&
VAR_9 != 0)
inode_sub_bytes(inode, VAR_33);
btrfs_mark_buffer_dirty(VAR_5);
} else {
VAR_10 =
btrfs_file_extent_disk_num_bytes(VAR_5,
VAR_6);
VAR_11 = VAR_8.offset -
btrfs_file_extent_offset(VAR_5, VAR_6);
VAR_33 = btrfs_file_extent_num_bytes(VAR_5, VAR_6);
if (VAR_9 != 0) {
VAR_16 = 1;
if (test_bit(VAR_29,
&VAR_1->state))
inode_sub_bytes(inode, VAR_33);
}
}
} else if (VAR_20 == VAR_32) {
if (!VAR_17 &&
btrfs_file_extent_compression(VAR_5, VAR_6) == 0 &&
btrfs_file_extent_encryption(VAR_5, VAR_6) == 0 &&
btrfs_file_extent_other_encoding(VAR_5, VAR_6) == 0) {
u32 VAR_35 = VAR_2 - VAR_8.offset;
if (test_bit(VAR_29, &VAR_1->state))
inode_sub_bytes(inode, VAR_12 + 1 -
VAR_2);
btrfs_set_file_extent_ram_bytes(VAR_5, VAR_6, VAR_35);
VAR_35 =
btrfs_file_extent_calc_inline_size(VAR_35);
btrfs_truncate_item(VAR_1, VAR_4, VAR_35, 1);
} else if (test_bit(VAR_29,
&VAR_1->state)) {
inode_sub_bytes(inode, VAR_12 + 1 -
VAR_8.offset);
}
}
delete:
if (VAR_17) {
if (!VAR_18) {
VAR_19 = VAR_4->slots[0];
VAR_18 = 1;
} else if (VAR_18 &&
VAR_4->slots[0] + 1 == VAR_19) {
VAR_18++;
VAR_19 = VAR_4->slots[0];
} else {
BUG();
}
} else {
break;
}
VAR_26 = 0;
if (VAR_16 &&
(test_bit(VAR_29, &VAR_1->state) ||
VAR_1 == VAR_1->fs_info->tree_root)) {
btrfs_set_path_blocking(VAR_4);
VAR_24 += VAR_10;
VAR_21 = btrfs_free_extent(VAR_0, VAR_1, VAR_9,
VAR_10, 0,
btrfs_header_owner(VAR_5),
VAR_23, VAR_11, 0);
BUG_ON(VAR_21);
if (btrfs_should_throttle_delayed_refs(VAR_0, VAR_1))
btrfs_async_run_delayed_refs(VAR_1,
VAR_0->delayed_ref_updates * 2, 0);
if (VAR_25) {
if (truncate_space_check(VAR_0, VAR_1,
VAR_10)) {
VAR_27 = 1;
}
if (btrfs_should_throttle_delayed_refs(VAR_0,
VAR_1)) {
VAR_26 = 1;
}
}
}
if (VAR_14 == VAR_36)
break;
if (VAR_4->slots[0] == 0 ||
VAR_4->slots[0] != VAR_19 ||
VAR_26 || VAR_27) {
if (VAR_18) {
VAR_21 = btrfs_del_items(VAR_0, VAR_1, VAR_4,
VAR_19,
VAR_18);
if (VAR_21) {
btrfs_abort_transaction(VAR_0,
VAR_1, VAR_21);
goto error;
}
VAR_18 = 0;
}
btrfs_release_path(VAR_4);
if (VAR_26) {
unsigned long VAR_37 = VAR_0->delayed_ref_updates;
if (VAR_37) {
VAR_0->delayed_ref_updates = 0;
VAR_21 = btrfs_run_delayed_refs(VAR_0, VAR_1, VAR_37 * 2);
if (VAR_21 && !VAR_22)
VAR_22 = VAR_21;
}
}
if (VAR_27) {
VAR_22 = -VAR_31;
goto error;
}
goto search_again;
} else {
VAR_4->slots[0]--;
}
}
out:
if (VAR_18) {
VAR_21 = btrfs_del_items(VAR_0, VAR_1, VAR_4, VAR_19,
VAR_18);
if (VAR_21)
btrfs_abort_transaction(VAR_0, VAR_1, VAR_21);
}
error:
if (VAR_1->root_key.objectid != VAR_38)
btrfs_ordered_update_i_size(inode, VAR_13, NULL);
btrfs_free_path(VAR_4);
if (VAR_25 && VAR_24 > 32 * 1024 * 1024) {
unsigned long VAR_37 = VAR_0->delayed_ref_updates;
if (VAR_37) {
VAR_0->delayed_ref_updates = 0;
VAR_21 = btrfs_run_delayed_refs(VAR_0, VAR_1, VAR_37 * 2);
if (VAR_21 && !VAR_22)
VAR_22 = VAR_21;
}
}
return VAR_22;
}",torvalds/linux/0305cd5f7fca85dae392b9ba85b116896eb7c1c7/inode.c/vul/before/0.json,"int btrfs_truncate_inode_items(struct btrfs_trans_handle *trans,
			       struct btrfs_root *root,
			       struct inode *inode,
			       u64 new_size, u32 min_type)
{
	struct btrfs_path *path;
	struct extent_buffer *leaf;
	struct btrfs_file_extent_item *fi;
	struct btrfs_key key;
	struct btrfs_key found_key;
	u64 extent_start = 0;
	u64 extent_num_bytes = 0;
	u64 extent_offset = 0;
	u64 item_end = 0;
	u64 last_size = new_size;
	u32 found_type = (u8)-1;
	int found_extent;
	int del_item;
	int pending_del_nr = 0;
	int pending_del_slot = 0;
	int extent_type = -1;
	int ret;
	int err = 0;
	u64 ino = btrfs_ino(inode);
	u64 bytes_deleted = 0;
	bool be_nice = 0;
	bool should_throttle = 0;
	bool should_end = 0;

	BUG_ON(new_size > 0 && min_type != BTRFS_EXTENT_DATA_KEY);

	/*
	 * for non-free space inodes and ref cows, we want to back off from
	 * time to time
	 */
	if (!btrfs_is_free_space_inode(inode) &&
	    test_bit(BTRFS_ROOT_REF_COWS, &root->state))
		be_nice = 1;

	path = btrfs_alloc_path();
	if (!path)
		return -ENOMEM;
	path->reada = -1;

	/*
	 * We want to drop from the next block forward in case this new size is
	 * not block aligned since we will be keeping the last block of the
	 * extent just the way it is.
	 */
	if (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||
	    root == root->fs_info->tree_root)
		btrfs_drop_extent_cache(inode, ALIGN(new_size,
					root->sectorsize), (u64)-1, 0);

	/*
	 * This function is also used to drop the items in the log tree before
	 * we relog the inode, so if root != BTRFS_I(inode)->root, it means
	 * it is used to drop the loged items. So we shouldn't kill the delayed
	 * items.
	 */
	if (min_type == 0 && root == BTRFS_I(inode)->root)
		btrfs_kill_delayed_inode_items(inode);

	key.objectid = ino;
	key.offset = (u64)-1;
	key.type = (u8)-1;

search_again:
	/*
	 * with a 16K leaf size and 128MB extents, you can actually queue
	 * up a huge file in a single leaf.  Most of the time that
	 * bytes_deleted is > 0, it will be huge by the time we get here
	 */
	if (be_nice && bytes_deleted > 32 * 1024 * 1024) {
		if (btrfs_should_end_transaction(trans, root)) {
			err = -EAGAIN;
			goto error;
		}
	}


	path->leave_spinning = 1;
	ret = btrfs_search_slot(trans, root, &key, path, -1, 1);
	if (ret < 0) {
		err = ret;
		goto out;
	}

	if (ret > 0) {
		/* there are no items in the tree for us to truncate, we're
		 * done
		 */
		if (path->slots[0] == 0)
			goto out;
		path->slots[0]--;
	}

	while (1) {
		fi = NULL;
		leaf = path->nodes[0];
		btrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);
		found_type = found_key.type;

		if (found_key.objectid != ino)
			break;

		if (found_type < min_type)
			break;

		item_end = found_key.offset;
		if (found_type == BTRFS_EXTENT_DATA_KEY) {
			fi = btrfs_item_ptr(leaf, path->slots[0],
					    struct btrfs_file_extent_item);
			extent_type = btrfs_file_extent_type(leaf, fi);
			if (extent_type != BTRFS_FILE_EXTENT_INLINE) {
				item_end +=
				    btrfs_file_extent_num_bytes(leaf, fi);
			} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {
				item_end += btrfs_file_extent_inline_len(leaf,
							 path->slots[0], fi);
			}
			item_end--;
		}
		if (found_type > min_type) {
			del_item = 1;
		} else {
			if (item_end < new_size)
				break;
			if (found_key.offset >= new_size)
				del_item = 1;
			else
				del_item = 0;
		}
		found_extent = 0;
		/* FIXME, shrink the extent if the ref count is only 1 */
		if (found_type != BTRFS_EXTENT_DATA_KEY)
			goto delete;

		if (del_item)
			last_size = found_key.offset;
		else
			last_size = new_size;

		if (extent_type != BTRFS_FILE_EXTENT_INLINE) {
			u64 num_dec;
			extent_start = btrfs_file_extent_disk_bytenr(leaf, fi);
			if (!del_item) {
				u64 orig_num_bytes =
					btrfs_file_extent_num_bytes(leaf, fi);
				extent_num_bytes = ALIGN(new_size -
						found_key.offset,
						root->sectorsize);
				btrfs_set_file_extent_num_bytes(leaf, fi,
							 extent_num_bytes);
				num_dec = (orig_num_bytes -
					   extent_num_bytes);
				if (test_bit(BTRFS_ROOT_REF_COWS,
					     &root->state) &&
				    extent_start != 0)
					inode_sub_bytes(inode, num_dec);
				btrfs_mark_buffer_dirty(leaf);
			} else {
				extent_num_bytes =
					btrfs_file_extent_disk_num_bytes(leaf,
									 fi);
				extent_offset = found_key.offset -
					btrfs_file_extent_offset(leaf, fi);

				/* FIXME blocksize != 4096 */
				num_dec = btrfs_file_extent_num_bytes(leaf, fi);
				if (extent_start != 0) {
					found_extent = 1;
					if (test_bit(BTRFS_ROOT_REF_COWS,
						     &root->state))
						inode_sub_bytes(inode, num_dec);
				}
			}
		} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {
			/*
			 * we can't truncate inline items that have had
			 * special encodings
			 */
			if (!del_item &&
			    btrfs_file_extent_encryption(leaf, fi) == 0 &&
			    btrfs_file_extent_other_encoding(leaf, fi) == 0) {

				/*
				 * Need to release path in order to truncate a
				 * compressed extent. So delete any accumulated
				 * extent items so far.
				 */
				if (btrfs_file_extent_compression(leaf, fi) !=
				    BTRFS_COMPRESS_NONE && pending_del_nr) {
					err = btrfs_del_items(trans, root, path,
							      pending_del_slot,
							      pending_del_nr);
					if (err) {
						btrfs_abort_transaction(trans,
									root,
									err);
						goto error;
					}
					pending_del_nr = 0;
				}

				err = truncate_inline_extent(inode, path,
							     &found_key,
							     item_end,
							     new_size);
				if (err) {
					btrfs_abort_transaction(trans,
								root, err);
					goto error;
				}
			} else if (test_bit(BTRFS_ROOT_REF_COWS,
					    &root->state)) {
				inode_sub_bytes(inode, item_end + 1 - new_size);
			}
		}
delete:
		if (del_item) {
			if (!pending_del_nr) {
				/* no pending yet, add ourselves */
				pending_del_slot = path->slots[0];
				pending_del_nr = 1;
			} else if (pending_del_nr &&
				   path->slots[0] + 1 == pending_del_slot) {
				/* hop on the pending chunk */
				pending_del_nr++;
				pending_del_slot = path->slots[0];
			} else {
				BUG();
			}
		} else {
			break;
		}
		should_throttle = 0;

		if (found_extent &&
		    (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||
		     root == root->fs_info->tree_root)) {
			btrfs_set_path_blocking(path);
			bytes_deleted += extent_num_bytes;
			ret = btrfs_free_extent(trans, root, extent_start,
						extent_num_bytes, 0,
						btrfs_header_owner(leaf),
						ino, extent_offset, 0);
			BUG_ON(ret);
			if (btrfs_should_throttle_delayed_refs(trans, root))
				btrfs_async_run_delayed_refs(root,
					trans->delayed_ref_updates * 2, 0);
			if (be_nice) {
				if (truncate_space_check(trans, root,
							 extent_num_bytes)) {
					should_end = 1;
				}
				if (btrfs_should_throttle_delayed_refs(trans,
								       root)) {
					should_throttle = 1;
				}
			}
		}

		if (found_type == BTRFS_INODE_ITEM_KEY)
			break;

		if (path->slots[0] == 0 ||
		    path->slots[0] != pending_del_slot ||
		    should_throttle || should_end) {
			if (pending_del_nr) {
				ret = btrfs_del_items(trans, root, path,
						pending_del_slot,
						pending_del_nr);
				if (ret) {
					btrfs_abort_transaction(trans,
								root, ret);
					goto error;
				}
				pending_del_nr = 0;
			}
			btrfs_release_path(path);
			if (should_throttle) {
				unsigned long updates = trans->delayed_ref_updates;
				if (updates) {
					trans->delayed_ref_updates = 0;
					ret = btrfs_run_delayed_refs(trans, root, updates * 2);
					if (ret && !err)
						err = ret;
				}
			}
			/*
			 * if we failed to refill our space rsv, bail out
			 * and let the transaction restart
			 */
			if (should_end) {
				err = -EAGAIN;
				goto error;
			}
			goto search_again;
		} else {
			path->slots[0]--;
		}
	}
out:
	if (pending_del_nr) {
		ret = btrfs_del_items(trans, root, path, pending_del_slot,
				      pending_del_nr);
		if (ret)
			btrfs_abort_transaction(trans, root, ret);
	}
error:
	if (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)
		btrfs_ordered_update_i_size(inode, last_size, NULL);

	btrfs_free_path(path);

	if (be_nice && bytes_deleted > 32 * 1024 * 1024) {
		unsigned long updates = trans->delayed_ref_updates;
		if (updates) {
			trans->delayed_ref_updates = 0;
			ret = btrfs_run_delayed_refs(trans, root, updates * 2);
			if (ret && !err)
				err = ret;
		}
	}
	return err;
}","int btrfs_truncate_inode_items(struct btrfs_trans_handle *VAR_0,
			       struct btrfs_root *VAR_1,
			       struct inode *inode,
			       u64 VAR_2, u32 VAR_3)
{
	struct btrfs_path *VAR_4;
	struct extent_buffer *VAR_5;
	struct btrfs_file_extent_item *VAR_6;
	struct btrfs_key VAR_7;
	struct btrfs_key VAR_8;
	u64 VAR_9 = 0;
	u64 VAR_10 = 0;
	u64 VAR_11 = 0;
	u64 VAR_12 = 0;
	u64 VAR_13 = VAR_2;
	u32 VAR_14 = (VAR_15)-1;
	int VAR_16;
	int VAR_17;
	int VAR_18 = 0;
	int VAR_19 = 0;
	int VAR_20 = -1;
	int VAR_21;
	int VAR_22 = 0;
	u64 VAR_23 = btrfs_ino(inode);
	u64 VAR_24 = 0;
	bool VAR_25 = 0;
	bool VAR_26 = 0;
	bool VAR_27 = 0;

	BUG_ON(VAR_2 > 0 && VAR_3 != VAR_28);

	/* COMMENT_0 */
                                                                    
                
    
	if (!btrfs_is_free_space_inode(inode) &&
	    test_bit(VAR_29, &VAR_1->state))
		VAR_25 = 1;

	VAR_4 = btrfs_alloc_path();
	if (!VAR_4)
		return -VAR_30;
	VAR_4->reada = -1;

	/* COMMENT_4 */
                                                                        
                                                                    
                              
    
	if (test_bit(VAR_29, &VAR_1->state) ||
	    VAR_1 == VAR_1->fs_info->tree_root)
		btrfs_drop_extent_cache(inode, ALIGN(VAR_2,
					VAR_1->sectorsize), (u64)-1, 0);

	/* COMMENT_9 */
                                                                       
                                                                    
                                                                        
          
    
	if (VAR_3 == 0 && VAR_1 == BTRFS_I(inode)->root)
		btrfs_kill_delayed_inode_items(inode);

	VAR_7.objectid = VAR_23;
	VAR_7.offset = (u64)-1;
	VAR_7.type = (VAR_15)-1;

search_again:
	/* COMMENT_15 */
                                                                  
                                                           
                                                                 
    
	if (VAR_25 && VAR_24 > 32 * 1024 * 1024) {
		if (btrfs_should_end_transaction(VAR_0, VAR_1)) {
			VAR_22 = -VAR_31;
			goto error;
		}
	}


	VAR_4->leave_spinning = 1;
	VAR_21 = btrfs_search_slot(VAR_0, VAR_1, &VAR_7, VAR_4, -1, 1);
	if (VAR_21 < 0) {
		VAR_22 = VAR_21;
		goto out;
	}

	if (VAR_21 > 0) {
		/* COMMENT_20 */
         
     
		if (VAR_4->slots[0] == 0)
			goto out;
		VAR_4->slots[0]--;
	}

	while (1) {
		VAR_6 = NULL;
		VAR_5 = VAR_4->nodes[0];
		btrfs_item_key_to_cpu(VAR_5, &VAR_8, VAR_4->slots[0]);
		VAR_14 = VAR_8.type;

		if (VAR_8.objectid != VAR_23)
			break;

		if (VAR_14 < VAR_3)
			break;

		VAR_12 = VAR_8.offset;
		if (VAR_14 == VAR_28) {
			VAR_6 = btrfs_item_ptr(VAR_5, VAR_4->slots[0],
					    struct btrfs_file_extent_item);
			VAR_20 = btrfs_file_extent_type(VAR_5, VAR_6);
			if (VAR_20 != VAR_32) {
				VAR_12 +=
				    btrfs_file_extent_num_bytes(VAR_5, VAR_6);
			} else if (VAR_20 == VAR_32) {
				VAR_12 += btrfs_file_extent_inline_len(VAR_5,
							 VAR_4->slots[0], VAR_6);
			}
			VAR_12--;
		}
		if (VAR_14 > VAR_3) {
			VAR_17 = 1;
		} else {
			if (VAR_12 < VAR_2)
				break;
			if (VAR_8.offset >= VAR_2)
				VAR_17 = 1;
			else
				VAR_17 = 0;
		}
		VAR_16 = 0;
		/* COMMENT_23 */
		if (VAR_14 != VAR_28)
			goto delete;

		if (VAR_17)
			VAR_13 = VAR_8.offset;
		else
			VAR_13 = VAR_2;

		if (VAR_20 != VAR_32) {
			u64 VAR_33;
			VAR_9 = btrfs_file_extent_disk_bytenr(VAR_5, VAR_6);
			if (!VAR_17) {
				u64 VAR_34 =
					btrfs_file_extent_num_bytes(VAR_5, VAR_6);
				VAR_10 = ALIGN(VAR_2 -
						VAR_8.offset,
						VAR_1->sectorsize);
				btrfs_set_file_extent_num_bytes(VAR_5, VAR_6,
							 VAR_10);
				VAR_33 = (VAR_34 -
					   VAR_10);
				if (test_bit(VAR_29,
					     &VAR_1->state) &&
				    VAR_9 != 0)
					inode_sub_bytes(inode, VAR_33);
				btrfs_mark_buffer_dirty(VAR_5);
			} else {
				VAR_10 =
					btrfs_file_extent_disk_num_bytes(VAR_5,
									 VAR_6);
				VAR_11 = VAR_8.offset -
					btrfs_file_extent_offset(VAR_5, VAR_6);

				/* COMMENT_24 */
				VAR_33 = btrfs_file_extent_num_bytes(VAR_5, VAR_6);
				if (VAR_9 != 0) {
					VAR_16 = 1;
					if (test_bit(VAR_29,
						     &VAR_1->state))
						inode_sub_bytes(inode, VAR_33);
				}
			}
		} else if (VAR_20 == VAR_32) {
			/* COMMENT_25 */
                                                  
                       
      
			if (!VAR_17 &&
			    btrfs_file_extent_encryption(VAR_5, VAR_6) == 0 &&
			    btrfs_file_extent_other_encoding(VAR_5, VAR_6) == 0) {

				/* COMMENT_29 */
                                                  
                                                   
                           
       
				if (btrfs_file_extent_compression(VAR_5, VAR_6) !=
				    VAR_35 && VAR_18) {
					VAR_22 = btrfs_del_items(VAR_0, VAR_1, VAR_4,
							      VAR_19,
							      VAR_18);
					if (VAR_22) {
						btrfs_abort_transaction(VAR_0,
									VAR_1,
									VAR_22);
						goto error;
					}
					VAR_18 = 0;
				}

				VAR_22 = truncate_inline_extent(inode, VAR_4,
							     &VAR_8,
							     VAR_12,
							     VAR_2);
				if (VAR_22) {
					btrfs_abort_transaction(VAR_0,
								VAR_1, VAR_22);
					goto error;
				}
			} else if (test_bit(VAR_29,
					    &VAR_1->state)) {
				inode_sub_bytes(inode, VAR_12 + 1 - VAR_2);
			}
		}
delete:
		if (VAR_17) {
			if (!VAR_18) {
				/* COMMENT_34 */
				VAR_19 = VAR_4->slots[0];
				VAR_18 = 1;
			} else if (VAR_18 &&
				   VAR_4->slots[0] + 1 == VAR_19) {
				/* COMMENT_35 */
				VAR_18++;
				VAR_19 = VAR_4->slots[0];
			} else {
				BUG();
			}
		} else {
			break;
		}
		VAR_26 = 0;

		if (VAR_16 &&
		    (test_bit(VAR_29, &VAR_1->state) ||
		     VAR_1 == VAR_1->fs_info->tree_root)) {
			btrfs_set_path_blocking(VAR_4);
			VAR_24 += VAR_10;
			VAR_21 = btrfs_free_extent(VAR_0, VAR_1, VAR_9,
						VAR_10, 0,
						btrfs_header_owner(VAR_5),
						VAR_23, VAR_11, 0);
			BUG_ON(VAR_21);
			if (btrfs_should_throttle_delayed_refs(VAR_0, VAR_1))
				btrfs_async_run_delayed_refs(VAR_1,
					VAR_0->delayed_ref_updates * 2, 0);
			if (VAR_25) {
				if (truncate_space_check(VAR_0, VAR_1,
							 VAR_10)) {
					VAR_27 = 1;
				}
				if (btrfs_should_throttle_delayed_refs(VAR_0,
								       VAR_1)) {
					VAR_26 = 1;
				}
			}
		}

		if (VAR_14 == VAR_36)
			break;

		if (VAR_4->slots[0] == 0 ||
		    VAR_4->slots[0] != VAR_19 ||
		    VAR_26 || VAR_27) {
			if (VAR_18) {
				VAR_21 = btrfs_del_items(VAR_0, VAR_1, VAR_4,
						VAR_19,
						VAR_18);
				if (VAR_21) {
					btrfs_abort_transaction(VAR_0,
								VAR_1, VAR_21);
					goto error;
				}
				VAR_18 = 0;
			}
			btrfs_release_path(VAR_4);
			if (VAR_26) {
				unsigned long VAR_37 = VAR_0->delayed_ref_updates;
				if (VAR_37) {
					VAR_0->delayed_ref_updates = 0;
					VAR_21 = btrfs_run_delayed_refs(VAR_0, VAR_1, VAR_37 * 2);
					if (VAR_21 && !VAR_22)
						VAR_22 = VAR_21;
				}
			}
			/* COMMENT_36 */
                                                    
                                     
      
			if (VAR_27) {
				VAR_22 = -VAR_31;
				goto error;
			}
			goto search_again;
		} else {
			VAR_4->slots[0]--;
		}
	}
out:
	if (VAR_18) {
		VAR_21 = btrfs_del_items(VAR_0, VAR_1, VAR_4, VAR_19,
				      VAR_18);
		if (VAR_21)
			btrfs_abort_transaction(VAR_0, VAR_1, VAR_21);
	}
error:
	if (VAR_1->root_key.objectid != VAR_38)
		btrfs_ordered_update_i_size(inode, VAR_13, NULL);

	btrfs_free_path(VAR_4);

	if (VAR_25 && VAR_24 > 32 * 1024 * 1024) {
		unsigned long VAR_37 = VAR_0->delayed_ref_updates;
		if (VAR_37) {
			VAR_0->delayed_ref_updates = 0;
			VAR_21 = btrfs_run_delayed_refs(VAR_0, VAR_1, VAR_37 * 2);
			if (VAR_21 && !VAR_22)
				VAR_22 = VAR_21;
		}
	}
	return VAR_22;
}",torvalds/linux/0305cd5f7fca85dae392b9ba85b116896eb7c1c7/inode.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -181,27 +181,40 @@
 			 * special encodings
 			 */
 			if (!del_item &&
-			    btrfs_file_extent_compression(leaf, fi) == 0 &&
 			    btrfs_file_extent_encryption(leaf, fi) == 0 &&
 			    btrfs_file_extent_other_encoding(leaf, fi) == 0) {
-				u32 size = new_size - found_key.offset;
-
-				if (test_bit(BTRFS_ROOT_REF_COWS, &root->state))
-					inode_sub_bytes(inode, item_end + 1 -
-							new_size);
 
 				/*
-				 * update the ram bytes to properly reflect
-				 * the new size of our item
+				 * Need to release path in order to truncate a
+				 * compressed extent. So delete any accumulated
+				 * extent items so far.
 				 */
-				btrfs_set_file_extent_ram_bytes(leaf, fi, size);
-				size =
-				    btrfs_file_extent_calc_inline_size(size);
-				btrfs_truncate_item(root, path, size, 1);
+				if (btrfs_file_extent_compression(leaf, fi) !=
+				    BTRFS_COMPRESS_NONE && pending_del_nr) {
+					err = btrfs_del_items(trans, root, path,
+							      pending_del_slot,
+							      pending_del_nr);
+					if (err) {
+						btrfs_abort_transaction(trans,
+									root,
+									err);
+						goto error;
+					}
+					pending_del_nr = 0;
+				}
+
+				err = truncate_inline_extent(inode, path,
+							     &found_key,
+							     item_end,
+							     new_size);
+				if (err) {
+					btrfs_abort_transaction(trans,
+								root, err);
+					goto error;
+				}
 			} else if (test_bit(BTRFS_ROOT_REF_COWS,
 					    &root->state)) {
-				inode_sub_bytes(inode, item_end + 1 -
-						found_key.offset);
+				inode_sub_bytes(inode, item_end + 1 - new_size);
 			}
 		}
 delete:","{'deleted_lines': ['\t\t\t    btrfs_file_extent_compression(leaf, fi) == 0 &&', '\t\t\t\tu32 size = new_size - found_key.offset;', '', '\t\t\t\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state))', '\t\t\t\t\tinode_sub_bytes(inode, item_end + 1 -', '\t\t\t\t\t\t\tnew_size);', '\t\t\t\t * update the ram bytes to properly reflect', '\t\t\t\t * the new size of our item', '\t\t\t\tbtrfs_set_file_extent_ram_bytes(leaf, fi, size);', '\t\t\t\tsize =', '\t\t\t\t    btrfs_file_extent_calc_inline_size(size);', '\t\t\t\tbtrfs_truncate_item(root, path, size, 1);', '\t\t\t\tinode_sub_bytes(inode, item_end + 1 -', '\t\t\t\t\t\tfound_key.offset);'], 'added_lines': ['\t\t\t\t * Need to release path in order to truncate a', '\t\t\t\t * compressed extent. So delete any accumulated', '\t\t\t\t * extent items so far.', '\t\t\t\tif (btrfs_file_extent_compression(leaf, fi) !=', '\t\t\t\t    BTRFS_COMPRESS_NONE && pending_del_nr) {', '\t\t\t\t\terr = btrfs_del_items(trans, root, path,', '\t\t\t\t\t\t\t      pending_del_slot,', '\t\t\t\t\t\t\t      pending_del_nr);', '\t\t\t\t\tif (err) {', '\t\t\t\t\t\tbtrfs_abort_transaction(trans,', '\t\t\t\t\t\t\t\t\troot,', '\t\t\t\t\t\t\t\t\terr);', '\t\t\t\t\t\tgoto error;', '\t\t\t\t\t}', '\t\t\t\t\tpending_del_nr = 0;', '\t\t\t\t}', '', '\t\t\t\terr = truncate_inline_extent(inode, path,', '\t\t\t\t\t\t\t     &found_key,', '\t\t\t\t\t\t\t     item_end,', '\t\t\t\t\t\t\t     new_size);', '\t\t\t\tif (err) {', '\t\t\t\t\tbtrfs_abort_transaction(trans,', '\t\t\t\t\t\t\t\troot, err);', '\t\t\t\t\tgoto error;', '\t\t\t\t}', '\t\t\t\tinode_sub_bytes(inode, item_end + 1 - new_size);']}",True,"fs/btrfs/inode.c in the Linux kernel before 4.3.3 mishandles compressed inline extents, which allows local users to obtain sensitive pre-truncation information from a file via a clone action.",4.0,MEDIUM,1,test,2015-10-16T11:34:25Z,1
CVE-2015-8869,"['CWE-119', 'CWE-200']",AV:N/AC:L/Au:N/C:P/I:N/A:P,0,ocaml,"fix PR#7003 and a few other bugs caused by misuse of Int_val

git-svn-id: http://caml.inria.fr/svn/ocaml/trunk@16525 f963ae5c-01c2-4b8c-9fe0-0dff7051ff02",659615c7b100a89eafe6253e7a5b9d84d0e8df74,https://github.com/ocaml/ocaml/commit/659615c7b100a89eafe6253e7a5b9d84d0e8df74,byterun/str.c,caml_blit_string,"CAMLprim value caml_blit_string(value s1, value ofs1, value s2, value ofs2,
value n)
{
memmove(&Byte(s2, Long_val(ofs2)), &Byte(s1, Long_val(ofs1)), Int_val(n));
return Val_unit;
}","CAMLprim VAR_0 caml_blit_string(value VAR_1, value VAR_2, value VAR_3, value VAR_4,
value VAR_5)
{
memmove(&Byte(VAR_3, Long_val(VAR_4)), &Byte(VAR_1, Long_val(VAR_2)), Int_val(VAR_5));
return VAR_6;
}",,"CAMLprim value caml_blit_string(value s1, value ofs1, value s2, value ofs2,
                                value n)
{
  memmove(&Byte(s2, Long_val(ofs2)), &Byte(s1, Long_val(ofs1)), Long_val(n));
  return Val_unit;
}","CAMLprim VAR_0 caml_blit_string(value VAR_1, value VAR_2, value VAR_3, value VAR_4,
                                value VAR_5)
{
  memmove(&Byte(VAR_3, Long_val(VAR_4)), &Byte(VAR_1, Long_val(VAR_2)), Long_val(VAR_5));
  return VAR_6;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 CAMLprim value caml_blit_string(value s1, value ofs1, value s2, value ofs2,
                                 value n)
 {
-  memmove(&Byte(s2, Long_val(ofs2)), &Byte(s1, Long_val(ofs1)), Int_val(n));
+  memmove(&Byte(s2, Long_val(ofs2)), &Byte(s1, Long_val(ofs1)), Long_val(n));
   return Val_unit;
 }","{'deleted_lines': ['  memmove(&Byte(s2, Long_val(ofs2)), &Byte(s1, Long_val(ofs1)), Int_val(n));'], 'added_lines': ['  memmove(&Byte(s2, Long_val(ofs2)), &Byte(s1, Long_val(ofs1)), Long_val(n));']}",True,"OCaml before 4.03.0 does not properly handle sign extensions, which allows remote attackers to conduct buffer overflow attacks or obtain sensitive information as demonstrated by a long string to the String.copy function.",9.1,CRITICAL,3,test,2015-10-19T15:47:33Z,1
CVE-2015-8869,"['CWE-119', 'CWE-200']",AV:N/AC:L/Au:N/C:P/I:N/A:P,0,ocaml,"fix PR#7003 and a few other bugs caused by misuse of Int_val

git-svn-id: http://caml.inria.fr/svn/ocaml/trunk@16525 f963ae5c-01c2-4b8c-9fe0-0dff7051ff02",659615c7b100a89eafe6253e7a5b9d84d0e8df74,https://github.com/ocaml/ocaml/commit/659615c7b100a89eafe6253e7a5b9d84d0e8df74,byterun/intern.c,intern_rec,"static void intern_rec(value *dest)
{
unsigned int code;
tag_t tag;
mlsize_t size, len, ofs_ind;
value v;
asize_t ofs;
header_t header;
unsigned char digest[16];
struct custom_operations * ops;
char * codeptr;
struct intern_item * sp;
sp = intern_stack;
ReadItems(dest, 1);
while(sp != intern_stack) {
dest = sp->dest;
switch (sp->op) {
case OFreshOID:
if (Int_val(Field((value)dest, 1)) >= 0)
caml_set_oo_id((value)dest);
sp--;
break;
case OShift:
*dest += sp->arg;
sp--;
break;
case OReadItems:
sp->dest++;
if (--(sp->arg) == 0) sp--;
code = read8u();
if (code >= PREFIX_SMALL_INT) {
if (code >= PREFIX_SMALL_BLOCK) {
tag = code & 0xF;
size = (code >> 4) & 0x7;
read_block:
if (size == 0) {
v = Atom(tag);
} else {
v = Val_hp(intern_dest);
if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v;
*intern_dest = Make_header(size, tag, intern_color);
intern_dest += 1 + size;
if (tag == Object_tag) {
Assert(size >= 2);
ReadItems(&Field(v, 2), size - 2);
PushItem();
sp->op = OFreshOID;
sp->dest = (value*) v;
sp->arg = 1;
ReadItems(&Field(v, 0), 2);
} else
ReadItems(&Field(v, 0), size);
}
} else {
v = Val_int(code & 0x3F);
}
} else {
if (code >= PREFIX_SMALL_STRING) {
len = (code & 0x1F);
read_string:
size = (len + sizeof(value)) / sizeof(value);
v = Val_hp(intern_dest);
if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v;
*intern_dest = Make_header(size, String_tag, intern_color);
intern_dest += 1 + size;
Field(v, size - 1) = 0;
ofs_ind = Bsize_wsize(size) - 1;
Byte(v, ofs_ind) = ofs_ind - len;
readblock(String_val(v), len);
} else {
switch(code) {
case CODE_INT8:
v = Val_long(read8s());
break;
case CODE_INT16:
v = Val_long(read16s());
break;
case CODE_INT32:
v = Val_long(read32s());
break;
case CODE_INT64:
#ifdef ARCH_SIXTYFOUR
v = Val_long(read64s());
break;
#else
intern_cleanup();
caml_failwith(""input_value: integer too large"");
break;
#endif
case CODE_SHARED8:
ofs = read8u();
read_shared:
Assert (ofs > 0);
Assert (ofs <= obj_counter);
Assert (intern_obj_table != NULL);
v = intern_obj_table[obj_counter - ofs];
break;
case CODE_SHARED16:
ofs = read16u();
goto read_shared;
case CODE_SHARED32:
ofs = read32u();
goto read_shared;
case CODE_BLOCK32:
header = (header_t) read32u();
tag = Tag_hd(header);
size = Wosize_hd(header);
goto read_block;
case CODE_BLOCK64:
#ifdef ARCH_SIXTYFOUR
header = (header_t) read64s();
tag = Tag_hd(header);
size = Wosize_hd(header);
goto read_block;
#else
intern_cleanup();
caml_failwith(""input_value: data block too large"");
break;
#endif
case CODE_STRING8:
len = read8u();
goto read_string;
case CODE_STRING32:
len = read32u();
goto read_string;
case CODE_DOUBLE_LITTLE:
case CODE_DOUBLE_BIG:
v = Val_hp(intern_dest);
if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v;
*intern_dest = Make_header(Double_wosize, Double_tag, intern_color);
intern_dest += 1 + Double_wosize;
readfloat((double *) v, code);
break;
case CODE_DOUBLE_ARRAY8_LITTLE:
case CODE_DOUBLE_ARRAY8_BIG:
len = read8u();
read_double_array:
size = len * Double_wosize;
v = Val_hp(intern_dest);
if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v;
*intern_dest = Make_header(size, Double_array_tag, intern_color);
intern_dest += 1 + size;
readfloats((double *) v, len, code);
break;
case CODE_DOUBLE_ARRAY32_LITTLE:
case CODE_DOUBLE_ARRAY32_BIG:
len = read32u();
goto read_double_array;
case CODE_CODEPOINTER:
ofs = read32u();
readblock(digest, 16);
codeptr = intern_resolve_code_pointer(digest, ofs);
if (codeptr != NULL) {
v = (value) codeptr;
} else {
value * function_placeholder =
caml_named_value (""Debugger.function_placeholder"");
if (function_placeholder != NULL) {
v = *function_placeholder;
} else {
intern_cleanup();
intern_bad_code_pointer(digest);
}
}
break;
case CODE_INFIXPOINTER:
ofs = read32u();
PushItem();
sp->dest = dest;
sp->op = OShift;
sp->arg = ofs;
ReadItems(dest, 1);
continue;  
case CODE_CUSTOM:
ops = caml_find_custom_operations((char *) intern_src);
if (ops == NULL) {
intern_cleanup();
caml_failwith(""input_value: unknown custom block identifier"");
}
while (*intern_src++ != 0) ;  
size = ops->deserialize((void *) (intern_dest + 2));
size = 1 + (size + sizeof(value) - 1) / sizeof(value);
v = Val_hp(intern_dest);
if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v;
*intern_dest = Make_header(size, Custom_tag, intern_color);
Custom_ops_val(v) = ops;
if (ops->finalize != NULL && Is_young(v)) {
if (caml_finalize_table.ptr >= caml_finalize_table.limit){
CAMLassert (caml_finalize_table.ptr == caml_finalize_table.limit);
caml_realloc_ref_table (&caml_finalize_table);
}
*caml_finalize_table.ptr++ = (value *)v;
}
intern_dest += 1 + size;
break;
default:
intern_cleanup();
caml_failwith(""input_value: ill-formed message"");
}
}
}
*dest = v;
break;
default:
Assert(0);
}
}
intern_free_stack();
}","static void intern_rec(value *VAR_0)
{
unsigned int VAR_1;
tag_t VAR_2;
mlsize_t VAR_3, VAR_4, VAR_5;
value VAR_6;
asize_t VAR_7;
header_t VAR_8;
unsigned char VAR_9[16];
struct custom_operations * VAR_10;
char * VAR_11;
struct intern_item * VAR_12;
VAR_12 = VAR_13;
ReadItems(VAR_0, 1);
while(VAR_12 != VAR_13) {
VAR_0 = VAR_12->dest;
switch (VAR_12->op) {
case VAR_14:
if (Int_val(Field((value)VAR_0, 1)) >= 0)
caml_set_oo_id((value)VAR_0);
VAR_12--;
break;
case VAR_15:
*VAR_0 += VAR_12->arg;
VAR_12--;
break;
case VAR_16:
VAR_12->dest++;
if (--(VAR_12->arg) == 0) VAR_12--;
VAR_1 = read8u();
if (VAR_1 >= VAR_17) {
if (VAR_1 >= VAR_18) {
VAR_2 = VAR_1 & 0xF;
VAR_3 = (VAR_1 >> 4) & 0x7;
read_block:
if (VAR_3 == 0) {
VAR_6 = Atom(VAR_2);
} else {
VAR_6 = Val_hp(VAR_19);
if (VAR_20 != NULL) VAR_20[VAR_21++] = VAR_6;
*VAR_19 = Make_header(VAR_3, VAR_2, VAR_22);
VAR_19 += 1 + VAR_3;
if (VAR_2 == VAR_23) {
Assert(VAR_3 >= 2);
ReadItems(&Field(VAR_6, 2), VAR_3 - 2);
PushItem();
VAR_12->op = VAR_14;
VAR_12->dest = (value*) VAR_6;
VAR_12->arg = 1;
ReadItems(&Field(VAR_6, 0), 2);
} else
ReadItems(&Field(VAR_6, 0), VAR_3);
}
} else {
VAR_6 = Val_int(VAR_1 & 0x3F);
}
} else {
if (VAR_1 >= VAR_24) {
VAR_4 = (VAR_1 & 0x1F);
read_string:
VAR_3 = (VAR_4 + sizeof(value)) / sizeof(value);
VAR_6 = Val_hp(VAR_19);
if (VAR_20 != NULL) VAR_20[VAR_21++] = VAR_6;
*VAR_19 = Make_header(VAR_3, VAR_25, VAR_22);
VAR_19 += 1 + VAR_3;
Field(VAR_6, VAR_3 - 1) = 0;
VAR_5 = Bsize_wsize(VAR_3) - 1;
Byte(VAR_6, VAR_5) = VAR_5 - VAR_4;
readblock(String_val(VAR_6), VAR_4);
} else {
switch(VAR_1) {
case VAR_26:
VAR_6 = Val_long(read8s());
break;
case VAR_27:
VAR_6 = Val_long(read16s());
break;
case VAR_28:
VAR_6 = Val_long(read32s());
break;
case VAR_29:
#ifdef VAR_30
VAR_6 = Val_long(read64s());
break;
#else
intern_cleanup();
caml_failwith(""input_value: integer too large"");
break;
#endif
case VAR_31:
VAR_7 = read8u();
read_shared:
Assert (VAR_7 > 0);
Assert (VAR_7 <= VAR_21);
Assert (VAR_20 != NULL);
VAR_6 = VAR_20[VAR_21 - VAR_7];
break;
case VAR_32:
VAR_7 = read16u();
goto read_shared;
case VAR_33:
VAR_7 = read32u();
goto read_shared;
case VAR_34:
VAR_8 = (header_t) read32u();
VAR_2 = Tag_hd(VAR_8);
VAR_3 = Wosize_hd(VAR_8);
goto read_block;
case VAR_35:
#ifdef VAR_30
VAR_8 = (header_t) read64s();
VAR_2 = Tag_hd(VAR_8);
VAR_3 = Wosize_hd(VAR_8);
goto read_block;
#else
intern_cleanup();
caml_failwith(""input_value: data block too large"");
break;
#endif
case VAR_36:
VAR_4 = read8u();
goto read_string;
case VAR_37:
VAR_4 = read32u();
goto read_string;
case VAR_38:
case VAR_39:
VAR_6 = Val_hp(VAR_19);
if (VAR_20 != NULL) VAR_20[VAR_21++] = VAR_6;
*VAR_19 = Make_header(VAR_40, VAR_41, VAR_22);
VAR_19 += 1 + VAR_40;
readfloat((double *) VAR_6, VAR_1);
break;
case VAR_42:
case VAR_43:
VAR_4 = read8u();
read_double_array:
VAR_3 = VAR_4 * VAR_40;
VAR_6 = Val_hp(VAR_19);
if (VAR_20 != NULL) VAR_20[VAR_21++] = VAR_6;
*VAR_19 = Make_header(VAR_3, VAR_44, VAR_22);
VAR_19 += 1 + VAR_3;
readfloats((double *) VAR_6, VAR_4, VAR_1);
break;
case VAR_45:
case VAR_46:
VAR_4 = read32u();
goto read_double_array;
case VAR_47:
VAR_7 = read32u();
readblock(VAR_9, 16);
VAR_11 = intern_resolve_code_pointer(VAR_9, VAR_7);
if (VAR_11 != NULL) {
VAR_6 = (value) VAR_11;
} else {
value * VAR_48 =
caml_named_value (""Debugger.function_placeholder"");
if (VAR_48 != NULL) {
VAR_6 = *VAR_48;
} else {
intern_cleanup();
intern_bad_code_pointer(VAR_9);
}
}
break;
case VAR_49:
VAR_7 = read32u();
PushItem();
VAR_12->dest = VAR_0;
VAR_12->op = VAR_15;
VAR_12->arg = VAR_7;
ReadItems(VAR_0, 1);
continue;  
case VAR_50:
VAR_10 = caml_find_custom_operations((char *) VAR_51);
if (VAR_10 == NULL) {
intern_cleanup();
caml_failwith(""input_value: unknown custom block identifier"");
}
while (*VAR_51++ != 0) ;  
VAR_3 = VAR_10->deserialize((void *) (VAR_19 + 2));
VAR_3 = 1 + (VAR_3 + sizeof(value) - 1) / sizeof(value);
VAR_6 = Val_hp(VAR_19);
if (VAR_20 != NULL) VAR_20[VAR_21++] = VAR_6;
*VAR_19 = Make_header(VAR_3, VAR_52, VAR_22);
Custom_ops_val(VAR_6) = VAR_10;
if (VAR_10->finalize != NULL && Is_young(VAR_6)) {
if (VAR_53.ptr >= VAR_53.limit){
CAMLassert (VAR_53.ptr == VAR_53.limit);
caml_realloc_ref_table (&VAR_53);
}
*VAR_53.ptr++ = (value *)VAR_6;
}
VAR_19 += 1 + VAR_3;
break;
default:
intern_cleanup();
caml_failwith(""input_value: ill-formed message"");
}
}
}
*VAR_0 = VAR_6;
break;
default:
Assert(0);
}
}
intern_free_stack();
}",ocaml/659615c7b100a89eafe6253e7a5b9d84d0e8df74/intern.c/vul/before/0.json,"static void intern_rec(value *dest)
{
  unsigned int code;
  tag_t tag;
  mlsize_t size, len, ofs_ind;
  value v;
  asize_t ofs;
  header_t header;
  unsigned char digest[16];
  struct custom_operations * ops;
  char * codeptr;
  struct intern_item * sp;

  sp = intern_stack;

  /* Initially let's try to read the first object from the stream */
  ReadItems(dest, 1);

  /* The un-marshaler loop, the recursion is unrolled */
  while(sp != intern_stack) {

  /* Interpret next item on the stack */
  dest = sp->dest;
  switch (sp->op) {
  case OFreshOID:
    /* Refresh the object ID */
    /* but do not do it for predefined exception slots */
    if (Long_val(Field((value)dest, 1)) >= 0)
      caml_set_oo_id((value)dest);
    /* Pop item and iterate */
    sp--;
    break;
  case OShift:
    /* Shift value by an offset */
    *dest += sp->arg;
    /* Pop item and iterate */
    sp--;
    break;
  case OReadItems:
    /* Pop item */
    sp->dest++;
    if (--(sp->arg) == 0) sp--;
    /* Read a value and set v to this value */
  code = read8u();
  if (code >= PREFIX_SMALL_INT) {
    if (code >= PREFIX_SMALL_BLOCK) {
      /* Small block */
      tag = code & 0xF;
      size = (code >> 4) & 0x7;
    read_block:
      if (size == 0) {
        v = Atom(tag);
      } else {
        v = Val_hp(intern_dest);
        if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v;
        *intern_dest = Make_header(size, tag, intern_color);
        intern_dest += 1 + size;
        /* For objects, we need to freshen the oid */
        if (tag == Object_tag) {
          Assert(size >= 2);
          /* Request to read rest of the elements of the block */
          ReadItems(&Field(v, 2), size - 2);
          /* Request freshing OID */
          PushItem();
          sp->op = OFreshOID;
          sp->dest = (value*) v;
          sp->arg = 1;
          /* Finally read first two block elements: method table and old OID */
          ReadItems(&Field(v, 0), 2);
        } else
          /* If it's not an object then read the contents of the block */
          ReadItems(&Field(v, 0), size);
      }
    } else {
      /* Small integer */
      v = Val_int(code & 0x3F);
    }
  } else {
    if (code >= PREFIX_SMALL_STRING) {
      /* Small string */
      len = (code & 0x1F);
    read_string:
      size = (len + sizeof(value)) / sizeof(value);
      v = Val_hp(intern_dest);
      if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v;
      *intern_dest = Make_header(size, String_tag, intern_color);
      intern_dest += 1 + size;
      Field(v, size - 1) = 0;
      ofs_ind = Bsize_wsize(size) - 1;
      Byte(v, ofs_ind) = ofs_ind - len;
      readblock(String_val(v), len);
    } else {
      switch(code) {
      case CODE_INT8:
        v = Val_long(read8s());
        break;
      case CODE_INT16:
        v = Val_long(read16s());
        break;
      case CODE_INT32:
        v = Val_long(read32s());
        break;
      case CODE_INT64:
#ifdef ARCH_SIXTYFOUR
        v = Val_long(read64s());
        break;
#else
        intern_cleanup();
        caml_failwith(""input_value: integer too large"");
        break;
#endif
      case CODE_SHARED8:
        ofs = read8u();
      read_shared:
        Assert (ofs > 0);
        Assert (ofs <= obj_counter);
        Assert (intern_obj_table != NULL);
        v = intern_obj_table[obj_counter - ofs];
        break;
      case CODE_SHARED16:
        ofs = read16u();
        goto read_shared;
      case CODE_SHARED32:
        ofs = read32u();
        goto read_shared;
      case CODE_BLOCK32:
        header = (header_t) read32u();
        tag = Tag_hd(header);
        size = Wosize_hd(header);
        goto read_block;
      case CODE_BLOCK64:
#ifdef ARCH_SIXTYFOUR
        header = (header_t) read64s();
        tag = Tag_hd(header);
        size = Wosize_hd(header);
        goto read_block;
#else
        intern_cleanup();
        caml_failwith(""input_value: data block too large"");
        break;
#endif
      case CODE_STRING8:
        len = read8u();
        goto read_string;
      case CODE_STRING32:
        len = read32u();
        goto read_string;
      case CODE_DOUBLE_LITTLE:
      case CODE_DOUBLE_BIG:
        v = Val_hp(intern_dest);
        if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v;
        *intern_dest = Make_header(Double_wosize, Double_tag, intern_color);
        intern_dest += 1 + Double_wosize;
        readfloat((double *) v, code);
        break;
      case CODE_DOUBLE_ARRAY8_LITTLE:
      case CODE_DOUBLE_ARRAY8_BIG:
        len = read8u();
      read_double_array:
        size = len * Double_wosize;
        v = Val_hp(intern_dest);
        if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v;
        *intern_dest = Make_header(size, Double_array_tag, intern_color);
        intern_dest += 1 + size;
        readfloats((double *) v, len, code);
        break;
      case CODE_DOUBLE_ARRAY32_LITTLE:
      case CODE_DOUBLE_ARRAY32_BIG:
        len = read32u();
        goto read_double_array;
      case CODE_CODEPOINTER:
        ofs = read32u();
        readblock(digest, 16);
        codeptr = intern_resolve_code_pointer(digest, ofs);
        if (codeptr != NULL) {
          v = (value) codeptr;
        } else {
          value * function_placeholder =
            caml_named_value (""Debugger.function_placeholder"");
          if (function_placeholder != NULL) {
            v = *function_placeholder;
          } else {
            intern_cleanup();
            intern_bad_code_pointer(digest);
          }
        }
        break;
      case CODE_INFIXPOINTER:
        ofs = read32u();
        /* Read a value to *dest, then offset *dest by ofs */
        PushItem();
        sp->dest = dest;
        sp->op = OShift;
        sp->arg = ofs;
        ReadItems(dest, 1);
        continue;  /* with next iteration of main loop, skipping *dest = v */
      case CODE_CUSTOM:
        ops = caml_find_custom_operations((char *) intern_src);
        if (ops == NULL) {
          intern_cleanup();
          caml_failwith(""input_value: unknown custom block identifier"");
        }
        while (*intern_src++ != 0) /*nothing*/;  /*skip identifier*/
        size = ops->deserialize((void *) (intern_dest + 2));
        size = 1 + (size + sizeof(value) - 1) / sizeof(value);
        v = Val_hp(intern_dest);
        if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v;
        *intern_dest = Make_header(size, Custom_tag, intern_color);
        Custom_ops_val(v) = ops;

        if (ops->finalize != NULL && Is_young(v)) {
          /* Remembered that the block has a finalizer */
          if (caml_finalize_table.ptr >= caml_finalize_table.limit){
            CAMLassert (caml_finalize_table.ptr == caml_finalize_table.limit);
            caml_realloc_ref_table (&caml_finalize_table);
          }
          *caml_finalize_table.ptr++ = (value *)v;
        }

        intern_dest += 1 + size;
        break;
      default:
        intern_cleanup();
        caml_failwith(""input_value: ill-formed message"");
      }
    }
  }
  /* end of case OReadItems */
  *dest = v;
  break;
  default:
    Assert(0);
  }
  }
  /* We are done. Cleanup the stack and leave the function */
  intern_free_stack();
}","static void intern_rec(value *VAR_0)
{
  unsigned int VAR_1;
  tag_t VAR_2;
  mlsize_t VAR_3, VAR_4, VAR_5;
  value VAR_6;
  asize_t VAR_7;
  header_t VAR_8;
  unsigned char VAR_9[16];
  struct custom_operations * VAR_10;
  char * VAR_11;
  struct intern_item * VAR_12;

  VAR_12 = VAR_13;

  /* COMMENT_0 */
  ReadItems(VAR_0, 1);

  /* COMMENT_1 */
  while(VAR_12 != VAR_13) {

  /* COMMENT_2 */
  VAR_0 = VAR_12->dest;
  switch (VAR_12->op) {
  case VAR_14:
    /* COMMENT_3 */
    /* COMMENT_4 */
    if (Long_val(Field((value)VAR_0, 1)) >= 0)
      caml_set_oo_id((value)VAR_0);
    /* COMMENT_5 */
    VAR_12--;
    break;
  case VAR_15:
    /* COMMENT_6 */
    *VAR_0 += VAR_12->arg;
    /* COMMENT_5 */
    VAR_12--;
    break;
  case VAR_16:
    /* COMMENT_7 */
    VAR_12->dest++;
    if (--(VAR_12->arg) == 0) VAR_12--;
    /* COMMENT_8 */
  VAR_1 = read8u();
  if (VAR_1 >= VAR_17) {
    if (VAR_1 >= VAR_18) {
      /* COMMENT_9 */
      VAR_2 = VAR_1 & 0xF;
      VAR_3 = (VAR_1 >> 4) & 0x7;
    read_block:
      if (VAR_3 == 0) {
        VAR_6 = Atom(VAR_2);
      } else {
        VAR_6 = Val_hp(VAR_19);
        if (VAR_20 != NULL) VAR_20[VAR_21++] = VAR_6;
        *VAR_19 = Make_header(VAR_3, VAR_2, VAR_22);
        VAR_19 += 1 + VAR_3;
        /* COMMENT_10 */
        if (VAR_2 == VAR_23) {
          Assert(VAR_3 >= 2);
          /* COMMENT_11 */
          ReadItems(&Field(VAR_6, 2), VAR_3 - 2);
          /* COMMENT_12 */
          PushItem();
          VAR_12->op = VAR_14;
          VAR_12->dest = (value*) VAR_6;
          VAR_12->arg = 1;
          /* COMMENT_13 */
          ReadItems(&Field(VAR_6, 0), 2);
        } else
          /* COMMENT_14 */
          ReadItems(&Field(VAR_6, 0), VAR_3);
      }
    } else {
      /* COMMENT_15 */
      VAR_6 = Val_int(VAR_1 & 0x3F);
    }
  } else {
    if (VAR_1 >= VAR_24) {
      /* COMMENT_16 */
      VAR_4 = (VAR_1 & 0x1F);
    read_string:
      VAR_3 = (VAR_4 + sizeof(value)) / sizeof(value);
      VAR_6 = Val_hp(VAR_19);
      if (VAR_20 != NULL) VAR_20[VAR_21++] = VAR_6;
      *VAR_19 = Make_header(VAR_3, VAR_25, VAR_22);
      VAR_19 += 1 + VAR_3;
      Field(VAR_6, VAR_3 - 1) = 0;
      VAR_5 = Bsize_wsize(VAR_3) - 1;
      Byte(VAR_6, VAR_5) = VAR_5 - VAR_4;
      readblock(String_val(VAR_6), VAR_4);
    } else {
      switch(VAR_1) {
      case VAR_26:
        VAR_6 = Val_long(read8s());
        break;
      case VAR_27:
        VAR_6 = Val_long(read16s());
        break;
      case VAR_28:
        VAR_6 = Val_long(read32s());
        break;
      case VAR_29:
#ifdef VAR_30
        VAR_6 = Val_long(read64s());
        break;
#else
        intern_cleanup();
        caml_failwith(""input_value: integer too large"");
        break;
#endif
      case VAR_31:
        VAR_7 = read8u();
      read_shared:
        Assert (VAR_7 > 0);
        Assert (VAR_7 <= VAR_21);
        Assert (VAR_20 != NULL);
        VAR_6 = VAR_20[VAR_21 - VAR_7];
        break;
      case VAR_32:
        VAR_7 = read16u();
        goto read_shared;
      case VAR_33:
        VAR_7 = read32u();
        goto read_shared;
      case VAR_34:
        VAR_8 = (header_t) read32u();
        VAR_2 = Tag_hd(VAR_8);
        VAR_3 = Wosize_hd(VAR_8);
        goto read_block;
      case VAR_35:
#ifdef VAR_30
        VAR_8 = (header_t) read64s();
        VAR_2 = Tag_hd(VAR_8);
        VAR_3 = Wosize_hd(VAR_8);
        goto read_block;
#else
        intern_cleanup();
        caml_failwith(""input_value: data block too large"");
        break;
#endif
      case VAR_36:
        VAR_4 = read8u();
        goto read_string;
      case VAR_37:
        VAR_4 = read32u();
        goto read_string;
      case VAR_38:
      case VAR_39:
        VAR_6 = Val_hp(VAR_19);
        if (VAR_20 != NULL) VAR_20[VAR_21++] = VAR_6;
        *VAR_19 = Make_header(VAR_40, VAR_41, VAR_22);
        VAR_19 += 1 + VAR_40;
        readfloat((double *) VAR_6, VAR_1);
        break;
      case VAR_42:
      case VAR_43:
        VAR_4 = read8u();
      read_double_array:
        VAR_3 = VAR_4 * VAR_40;
        VAR_6 = Val_hp(VAR_19);
        if (VAR_20 != NULL) VAR_20[VAR_21++] = VAR_6;
        *VAR_19 = Make_header(VAR_3, VAR_44, VAR_22);
        VAR_19 += 1 + VAR_3;
        readfloats((double *) VAR_6, VAR_4, VAR_1);
        break;
      case VAR_45:
      case VAR_46:
        VAR_4 = read32u();
        goto read_double_array;
      case VAR_47:
        VAR_7 = read32u();
        readblock(VAR_9, 16);
        VAR_11 = intern_resolve_code_pointer(VAR_9, VAR_7);
        if (VAR_11 != NULL) {
          VAR_6 = (value) VAR_11;
        } else {
          value * VAR_48 =
            caml_named_value (""Debugger.function_placeholder"");
          if (VAR_48 != NULL) {
            VAR_6 = *VAR_48;
          } else {
            intern_cleanup();
            intern_bad_code_pointer(VAR_9);
          }
        }
        break;
      case VAR_49:
        VAR_7 = read32u();
        /* COMMENT_17 */
        PushItem();
        VAR_12->dest = VAR_0;
        VAR_12->op = VAR_15;
        VAR_12->arg = VAR_7;
        ReadItems(VAR_0, 1);
        continue;  /* COMMENT_18 */
      case VAR_50:
        VAR_10 = caml_find_custom_operations((char *) VAR_51);
        if (VAR_10 == NULL) {
          intern_cleanup();
          caml_failwith(""input_value: unknown custom block identifier"");
        }
        while (*VAR_51++ != 0) /* COMMENT_19 */;  /* COMMENT_20 */
        VAR_3 = VAR_10->deserialize((void *) (VAR_19 + 2));
        VAR_3 = 1 + (VAR_3 + sizeof(value) - 1) / sizeof(value);
        VAR_6 = Val_hp(VAR_19);
        if (VAR_20 != NULL) VAR_20[VAR_21++] = VAR_6;
        *VAR_19 = Make_header(VAR_3, VAR_52, VAR_22);
        Custom_ops_val(VAR_6) = VAR_10;

        if (VAR_10->finalize != NULL && Is_young(VAR_6)) {
          /* COMMENT_21 */
          if (VAR_53.ptr >= VAR_53.limit){
            CAMLassert (VAR_53.ptr == VAR_53.limit);
            caml_realloc_ref_table (&VAR_53);
          }
          *VAR_53.ptr++ = (value *)VAR_6;
        }

        VAR_19 += 1 + VAR_3;
        break;
      default:
        intern_cleanup();
        caml_failwith(""input_value: ill-formed message"");
      }
    }
  }
  /* COMMENT_22 */
  *VAR_0 = VAR_6;
  break;
  default:
    Assert(0);
  }
  }
  /* COMMENT_23 */
  intern_free_stack();
}",ocaml/659615c7b100a89eafe6253e7a5b9d84d0e8df74/intern.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -25,7 +25,7 @@
   case OFreshOID:
     /* Refresh the object ID */
     /* but do not do it for predefined exception slots */
-    if (Int_val(Field((value)dest, 1)) >= 0)
+    if (Long_val(Field((value)dest, 1)) >= 0)
       caml_set_oo_id((value)dest);
     /* Pop item and iterate */
     sp--;","{'deleted_lines': ['    if (Int_val(Field((value)dest, 1)) >= 0)'], 'added_lines': ['    if (Long_val(Field((value)dest, 1)) >= 0)']}",True,"OCaml before 4.03.0 does not properly handle sign extensions, which allows remote attackers to conduct buffer overflow attacks or obtain sensitive information as demonstrated by a long string to the String.copy function.",9.1,CRITICAL,3,test,2015-10-19T15:47:33Z,1
CVE-2015-8869,"['CWE-119', 'CWE-200']",AV:N/AC:L/Au:N/C:P/I:N/A:P,0,ocaml,"fix PR#7003 and a few other bugs caused by misuse of Int_val

git-svn-id: http://caml.inria.fr/svn/ocaml/trunk@16525 f963ae5c-01c2-4b8c-9fe0-0dff7051ff02",659615c7b100a89eafe6253e7a5b9d84d0e8df74,https://github.com/ocaml/ocaml/commit/659615c7b100a89eafe6253e7a5b9d84d0e8df74,byterun/alloc.c,caml_alloc_dummy_float,"CAMLprim value caml_alloc_dummy_float (value size)
{
mlsize_t wosize = Int_val(size) * Double_wosize;
if (wosize == 0) return Atom(0);
return caml_alloc (wosize, 0);
}","CAMLprim VAR_0 caml_alloc_dummy_float (value VAR_1)
{
mlsize_t VAR_2 = Int_val(VAR_1) * VAR_3;
if (VAR_2 == 0) return Atom(0);
return caml_alloc (VAR_2, 0);
}",,"CAMLprim value caml_alloc_dummy_float (value size)
{
  mlsize_t wosize = Long_val(size) * Double_wosize;

  if (wosize == 0) return Atom(0);
  return caml_alloc (wosize, 0);
}","CAMLprim VAR_0 caml_alloc_dummy_float (value VAR_1)
{
  mlsize_t VAR_2 = Long_val(VAR_1) * VAR_3;

  if (VAR_2 == 0) return Atom(0);
  return caml_alloc (VAR_2, 0);
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 CAMLprim value caml_alloc_dummy_float (value size)
 {
-  mlsize_t wosize = Int_val(size) * Double_wosize;
+  mlsize_t wosize = Long_val(size) * Double_wosize;
 
   if (wosize == 0) return Atom(0);
   return caml_alloc (wosize, 0);","{'deleted_lines': ['  mlsize_t wosize = Int_val(size) * Double_wosize;'], 'added_lines': ['  mlsize_t wosize = Long_val(size) * Double_wosize;']}",True,"OCaml before 4.03.0 does not properly handle sign extensions, which allows remote attackers to conduct buffer overflow attacks or obtain sensitive information as demonstrated by a long string to the String.copy function.",9.1,CRITICAL,3,test,2015-10-19T15:47:33Z,1
CVE-2015-8869,"['CWE-119', 'CWE-200']",AV:N/AC:L/Au:N/C:P/I:N/A:P,0,ocaml,"fix PR#7003 and a few other bugs caused by misuse of Int_val

git-svn-id: http://caml.inria.fr/svn/ocaml/trunk@16525 f963ae5c-01c2-4b8c-9fe0-0dff7051ff02",659615c7b100a89eafe6253e7a5b9d84d0e8df74,https://github.com/ocaml/ocaml/commit/659615c7b100a89eafe6253e7a5b9d84d0e8df74,byterun/alloc.c,caml_alloc_dummy,"CAMLprim value caml_alloc_dummy(value size)
{
mlsize_t wosize = Int_val(size);
if (wosize == 0) return Atom(0);
return caml_alloc (wosize, 0);
}","CAMLprim VAR_0 caml_alloc_dummy(value VAR_1)
{
mlsize_t VAR_2 = Int_val(VAR_1);
if (VAR_2 == 0) return Atom(0);
return caml_alloc (VAR_2, 0);
}",,"CAMLprim value caml_alloc_dummy(value size)
{
  mlsize_t wosize = Long_val(size);

  if (wosize == 0) return Atom(0);
  return caml_alloc (wosize, 0);
}","CAMLprim VAR_0 caml_alloc_dummy(value VAR_1)
{
  mlsize_t VAR_2 = Long_val(VAR_1);

  if (VAR_2 == 0) return Atom(0);
  return caml_alloc (VAR_2, 0);
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 CAMLprim value caml_alloc_dummy(value size)
 {
-  mlsize_t wosize = Int_val(size);
+  mlsize_t wosize = Long_val(size);
 
   if (wosize == 0) return Atom(0);
   return caml_alloc (wosize, 0);","{'deleted_lines': ['  mlsize_t wosize = Int_val(size);'], 'added_lines': ['  mlsize_t wosize = Long_val(size);']}",True,"OCaml before 4.03.0 does not properly handle sign extensions, which allows remote attackers to conduct buffer overflow attacks or obtain sensitive information as demonstrated by a long string to the String.copy function.",9.1,CRITICAL,3,test,2015-10-19T15:47:33Z,1
CVE-2015-8792,"['CWE-119', 'CWE-200']",AV:N/AC:L/Au:N/C:P/I:N/A:N,0,Matroska-Org/libmatroska,KaxBlockInternal: check EBML lace sizes against available buffer space,0a2d3e3644a7453b6513db2f9bc270f77943573f,https://github.com/Matroska-Org/libmatroska/commit/0a2d3e3644a7453b6513db2f9bc270f77943573f,src/KaxBlock.cpp,KaxInternalBlock::ReadData,"filepos_t KaxInternalBlock::ReadData(IOCallback & input, ScopeMode ReadFully)
{
filepos_t Result;
FirstFrameLocation = input.getFilePointer(); 
SetValueIsSet(false);
try {
if (ReadFully == SCOPE_ALL_DATA) {
Result = EbmlBinary::ReadData(input, ReadFully);
if (Result != GetSize())
throw SafeReadIOCallback::EndOfStreamX(GetSize() - Result);
binary *BufferStart = EbmlBinary::GetBuffer();
SafeReadIOCallback Mem(*this);
uint8 BlockHeadSize = 4;
TrackNumber = Mem.GetUInt8();
if ((TrackNumber & 0x80) == 0) {
if ((TrackNumber & 0x40) == 0) {
throw SafeReadIOCallback::EndOfStreamX(0);
}
TrackNumber = (TrackNumber & 0x3F) << 8;
TrackNumber += Mem.GetUInt8();
BlockHeadSize++;
} else {
TrackNumber &= 0x7F;
}
LocalTimecode = int16(Mem.GetUInt16BE());
bLocalTimecodeUsed = true;
uint8 Flags = Mem.GetUInt8();
if (EbmlId(*this) == EBML_ID(KaxSimpleBlock)) {
bIsKeyframe = (Flags & 0x80) != 0;
bIsDiscardable = (Flags & 0x01) != 0;
}
mInvisible = (Flags & 0x08) >> 3;
mLacing = LacingType((Flags & 0x06) >> 1);
if (mLacing == LACING_NONE) {
FirstFrameLocation += Mem.GetPosition();
DataBuffer * soloFrame = new DataBuffer(BufferStart + Mem.GetPosition(), GetSize() - BlockHeadSize);
myBuffers.push_back(soloFrame);
SizeList.resize(1);
SizeList[0] = GetSize() - BlockHeadSize;
} else {
uint32 LastBufferSize = GetSize() - BlockHeadSize - 1;         uint8 FrameNum = Mem.GetUInt8();                 uint8 Index;
int32 FrameSize;
uint32 SizeRead;
uint64 SizeUnknown;
SizeList.resize(FrameNum + 1);
switch (mLacing) {
case LACING_XIPH:
for (Index=0; Index<FrameNum; Index++) {
FrameSize = 0;
uint8 Value;
do {
Value = Mem.GetUInt8();
FrameSize += Value;
LastBufferSize--;
} while (Value == 0xFF);
SizeList[Index] = FrameSize;
LastBufferSize -= FrameSize;
}
SizeList[Index] = LastBufferSize;
break;
case LACING_EBML:
SizeRead = LastBufferSize;
FrameSize = ReadCodedSizeValue(BufferStart + Mem.GetPosition(), SizeRead, SizeUnknown);
SizeList[0] = FrameSize;
Mem.Skip(SizeRead);
LastBufferSize -= FrameSize + SizeRead;
for (Index=1; Index<FrameNum; Index++) {
SizeRead = LastBufferSize;
FrameSize += ReadCodedSizeSignedValue(BufferStart + Mem.GetPosition(), SizeRead, SizeUnknown);
SizeList[Index] = FrameSize;
Mem.Skip(SizeRead);
LastBufferSize -= FrameSize + SizeRead;
}
if (Index <= FrameNum)               SizeList[Index] = LastBufferSize;
break;
case LACING_FIXED:
for (Index=0; Index<=FrameNum; Index++) {
SizeList[Index] = LastBufferSize / (FrameNum + 1);
}
break;
default:             assert(0);
}
FirstFrameLocation += Mem.GetPosition();
for (Index=0; Index<=FrameNum; Index++) {
DataBuffer * lacedFrame = new DataBuffer(BufferStart + Mem.GetPosition(), SizeList[Index]);
myBuffers.push_back(lacedFrame);
Mem.Skip(SizeList[Index]);
}
}
binary *BufferEnd = BufferStart + GetSize();
size_t NumFrames  = myBuffers.size();
for (size_t Index = 0; Index < NumFrames; ++Index) {
binary *FrameStart  = myBuffers[Index]->Buffer();
binary *FrameEnd    = FrameStart + myBuffers[Index]->Size();
binary *ExpectedEnd = (Index + 1) < NumFrames ? myBuffers[Index + 1]->Buffer() : BufferEnd;
if ((FrameStart < BufferStart) || (FrameEnd > BufferEnd) || (FrameEnd != ExpectedEnd))
throw SafeReadIOCallback::EndOfStreamX(0);
}
SetValueIsSet();
} else if (ReadFully == SCOPE_PARTIAL_DATA) {
binary _TempHead[5];
Result = input.read(_TempHead, 5);
if (Result != 5)
throw SafeReadIOCallback::EndOfStreamX(0);
binary *cursor = _TempHead;
binary *_tmpBuf;
uint8 BlockHeadSize = 4;
TrackNumber = *cursor++;
if ((TrackNumber & 0x80) == 0) {
if ((TrackNumber & 0x40) == 0) {
return Result;
}
TrackNumber = (TrackNumber & 0x3F) << 8;
TrackNumber += *cursor++;
BlockHeadSize++;
} else {
TrackNumber &= 0x7F;
}
big_int16 b16;
b16.Eval(cursor);
LocalTimecode = int16(b16);
bLocalTimecodeUsed = true;
cursor += 2;
if (EbmlId(*this) == EBML_ID(KaxSimpleBlock)) {
bIsKeyframe = (*cursor & 0x80) != 0;
bIsDiscardable = (*cursor & 0x01) != 0;
}
mInvisible = (*cursor & 0x08) >> 3;
mLacing = LacingType((*cursor++ & 0x06) >> 1);
if (cursor == &_TempHead[4]) {
_TempHead[0] = _TempHead[4];
} else {
Result += input.read(_TempHead, 1);
}
FirstFrameLocation += cursor - _TempHead;
if (mLacing != LACING_NONE) {
uint32 LastBufferSize = GetSize() - BlockHeadSize - 1;         uint8 FrameNum = _TempHead[0];                 uint8 Index;
int32 FrameSize;
uint32 SizeRead;
uint64 SizeUnknown;
SizeList.resize(FrameNum + 1);
switch (mLacing) {
case LACING_XIPH:
for (Index=0; Index<FrameNum; Index++) {
FrameSize = 0;
do {
Result += input.read(_TempHead, 1);
FrameSize += uint8(_TempHead[0]);
LastBufferSize--;
FirstFrameLocation++;
} while (_TempHead[0] == 0xFF);
FirstFrameLocation++;
SizeList[Index] = FrameSize;
LastBufferSize -= FrameSize;
}
SizeList[Index] = LastBufferSize;
break;
case LACING_EBML:
SizeRead = LastBufferSize;
cursor = _tmpBuf = new binary[FrameNum*4];             Result += input.read(cursor, FrameNum*4);
FrameSize = ReadCodedSizeValue(cursor, SizeRead, SizeUnknown);
SizeList[0] = FrameSize;
cursor += SizeRead;
LastBufferSize -= FrameSize + SizeRead;
for (Index=1; Index<FrameNum; Index++) {
SizeRead = LastBufferSize;
FrameSize += ReadCodedSizeSignedValue(cursor, SizeRead, SizeUnknown);
SizeList[Index] = FrameSize;
cursor += SizeRead;
LastBufferSize -= FrameSize + SizeRead;
}
FirstFrameLocation += cursor - _tmpBuf;
SizeList[Index] = LastBufferSize;
delete [] _tmpBuf;
break;
case LACING_FIXED:
for (Index=0; Index<=FrameNum; Index++) {
SizeList[Index] = LastBufferSize / (FrameNum + 1);
}
break;
default:             assert(0);
}
} else {
SizeList.resize(1);
SizeList[0] = GetSize() - BlockHeadSize;
}
SetValueIsSet(false);
Result = GetSize();
} else {
SetValueIsSet(false);
Result = GetSize();
}
} catch (SafeReadIOCallback::EndOfStreamX &) {
SetValueIsSet(false);
std::memset(EbmlBinary::GetBuffer(), 0, GetSize());
myBuffers.clear();
SizeList.clear();
Timecode           = 0;
LocalTimecode      = 0;
TrackNumber        = 0;
bLocalTimecodeUsed = false;
FirstFrameLocation = 0;
return 0;
}
return Result;
}","filepos_t KaxInternalBlock::ReadData(IOCallback & VAR_0, ScopeMode VAR_1)
{
filepos_t VAR_2;
VAR_3 = VAR_0.getFilePointer(); 
SetValueIsSet(false);
try {
if (VAR_1 == VAR_4) {
VAR_2 = EbmlBinary::ReadData(VAR_0, VAR_1);
if (VAR_2 != GetSize())
throw SafeReadIOCallback::EndOfStreamX(GetSize() - VAR_2);
binary *VAR_5 = EbmlBinary::GetBuffer();
SafeReadIOCallback VAR_6(*this);
uint8 VAR_7 = 4;
VAR_8 = VAR_6.GetUInt8();
if ((VAR_8 & 0x80) == 0) {
if ((VAR_8 & 0x40) == 0) {
throw SafeReadIOCallback::EndOfStreamX(0);
}
VAR_8 = (VAR_8 & 0x3F) << 8;
VAR_8 += VAR_6.GetUInt8();
VAR_7++;
} else {
VAR_8 &= 0x7F;
}
VAR_9 = int16(VAR_6.GetUInt16BE());
VAR_10 = true;
uint8 VAR_11 = VAR_6.GetUInt8();
if (EbmlId(*this) == EBML_ID(VAR_12)) {
VAR_13 = (VAR_11 & 0x80) != 0;
VAR_14 = (VAR_11 & 0x01) != 0;
}
VAR_15 = (VAR_11 & 0x08) >> 3;
VAR_16 = LacingType((VAR_11 & 0x06) >> 1);
if (VAR_16 == VAR_17) {
VAR_3 += VAR_6.GetPosition();
DataBuffer * VAR_18 = new DataBuffer(VAR_5 + VAR_6.GetPosition(), GetSize() - VAR_7);
VAR_19.push_back(VAR_18);
VAR_20.resize(1);
VAR_20[0] = GetSize() - VAR_7;
} else {
uint32 VAR_21 = GetSize() - VAR_7 - 1; 
uint8 VAR_22 = VAR_6.GetUInt8(); 
uint8 VAR_23;
int32 VAR_24;
uint32 VAR_25;
uint64 VAR_26;
VAR_20.resize(VAR_22 + 1);
switch (VAR_16) {
case VAR_27:
for (VAR_23=0; VAR_23<VAR_22; VAR_23++) {
VAR_24 = 0;
uint8 VAR_28;
do {
VAR_28 = VAR_6.GetUInt8();
VAR_24 += VAR_28;
VAR_21--;
} while (VAR_28 == 0xFF);
VAR_20[VAR_23] = VAR_24;
VAR_21 -= VAR_24;
}
VAR_20[VAR_23] = VAR_21;
break;
case VAR_29:
VAR_25 = VAR_21;
VAR_24 = ReadCodedSizeValue(VAR_5 + VAR_6.GetPosition(), VAR_25, VAR_26);
VAR_20[0] = VAR_24;
VAR_6.Skip(VAR_25);
VAR_21 -= VAR_24 + VAR_25;
for (VAR_23=1; VAR_23<VAR_22; VAR_23++) {
VAR_25 = VAR_21;
VAR_24 += ReadCodedSizeSignedValue(VAR_5 + VAR_6.GetPosition(), VAR_25, VAR_26);
VAR_20[VAR_23] = VAR_24;
VAR_6.Skip(VAR_25);
VAR_21 -= VAR_24 + VAR_25;
}
if (VAR_23 <= VAR_22) 
VAR_20[VAR_23] = VAR_21;
break;
case VAR_30:
for (VAR_23=0; VAR_23<=VAR_22; VAR_23++) {
VAR_20[VAR_23] = VAR_21 / (VAR_22 + 1);
}
break;
default: 
assert(0);
}
VAR_3 += VAR_6.GetPosition();
for (VAR_23=0; VAR_23<=VAR_22; VAR_23++) {
DataBuffer * VAR_31 = new DataBuffer(VAR_5 + VAR_6.GetPosition(), VAR_20[VAR_23]);
VAR_19.push_back(VAR_31);
VAR_6.Skip(VAR_20[VAR_23]);
}
}
binary *VAR_32 = VAR_5 + GetSize();
size_t VAR_33  = VAR_19.size();
for (size_t VAR_23 = 0; VAR_23 < VAR_33; ++VAR_23) {
binary *VAR_34  = VAR_19[VAR_23]->Buffer();
binary *VAR_35    = VAR_34 + VAR_19[VAR_23]->Size();
binary *VAR_36 = (VAR_23 + 1) < VAR_33 ? VAR_19[VAR_23 + 1]->Buffer() : VAR_32;
if ((VAR_34 < VAR_5) || (VAR_35 > VAR_32) || (VAR_35 != VAR_36))
throw SafeReadIOCallback::EndOfStreamX(0);
}
SetValueIsSet();
} else if (VAR_1 == VAR_37) {
binary VAR_38[5];
VAR_2 = VAR_0.read(VAR_38, 5);
if (VAR_2 != 5)
throw SafeReadIOCallback::EndOfStreamX(0);
binary *VAR_39 = VAR_38;
binary *VAR_40;
uint8 VAR_7 = 4;
VAR_8 = *VAR_39++;
if ((VAR_8 & 0x80) == 0) {
if ((VAR_8 & 0x40) == 0) {
return VAR_2;
}
VAR_8 = (VAR_8 & 0x3F) << 8;
VAR_8 += *VAR_39++;
VAR_7++;
} else {
VAR_8 &= 0x7F;
}
big_int16 VAR_41;
VAR_41.Eval(VAR_39);
VAR_9 = int16(VAR_41);
VAR_10 = true;
VAR_39 += 2;
if (EbmlId(*this) == EBML_ID(VAR_12)) {
VAR_13 = (*VAR_39 & 0x80) != 0;
VAR_14 = (*VAR_39 & 0x01) != 0;
}
VAR_15 = (*VAR_39 & 0x08) >> 3;
VAR_16 = LacingType((*VAR_39++ & 0x06) >> 1);
if (VAR_39 == &VAR_38[4]) {
VAR_38[0] = VAR_38[4];
} else {
VAR_2 += VAR_0.read(VAR_38, 1);
}
VAR_3 += VAR_39 - VAR_38;
if (VAR_16 != VAR_17) {
uint32 VAR_21 = GetSize() - VAR_7 - 1; 
uint8 VAR_22 = VAR_38[0]; 
uint8 VAR_23;
int32 VAR_24;
uint32 VAR_25;
uint64 VAR_26;
VAR_20.resize(VAR_22 + 1);
switch (VAR_16) {
case VAR_27:
for (VAR_23=0; VAR_23<VAR_22; VAR_23++) {
VAR_24 = 0;
do {
VAR_2 += VAR_0.read(VAR_38, 1);
VAR_24 += uint8(VAR_38[0]);
VAR_21--;
VAR_3++;
} while (VAR_38[0] == 0xFF);
VAR_3++;
VAR_20[VAR_23] = VAR_24;
VAR_21 -= VAR_24;
}
VAR_20[VAR_23] = VAR_21;
break;
case VAR_29:
VAR_25 = VAR_21;
VAR_39 = VAR_40 = new binary[VAR_22*4]; 
VAR_2 += VAR_0.read(VAR_39, VAR_22*4);
VAR_24 = ReadCodedSizeValue(VAR_39, VAR_25, VAR_26);
VAR_20[0] = VAR_24;
VAR_39 += VAR_25;
VAR_21 -= VAR_24 + VAR_25;
for (VAR_23=1; VAR_23<VAR_22; VAR_23++) {
VAR_25 = VAR_21;
VAR_24 += ReadCodedSizeSignedValue(VAR_39, VAR_25, VAR_26);
VAR_20[VAR_23] = VAR_24;
VAR_39 += VAR_25;
VAR_21 -= VAR_24 + VAR_25;
}
VAR_3 += VAR_39 - VAR_40;
VAR_20[VAR_23] = VAR_21;
delete [] VAR_40;
break;
case VAR_30:
for (VAR_23=0; VAR_23<=VAR_22; VAR_23++) {
VAR_20[VAR_23] = VAR_21 / (VAR_22 + 1);
}
break;
default: 
assert(0);
}
} else {
VAR_20.resize(1);
VAR_20[0] = GetSize() - VAR_7;
}
SetValueIsSet(false);
VAR_2 = GetSize();
} else {
SetValueIsSet(false);
VAR_2 = GetSize();
}
} catch (SafeReadIOCallback::EndOfStreamX &) {
SetValueIsSet(false);
std::memset(EbmlBinary::GetBuffer(), 0, GetSize());
VAR_19.clear();
VAR_20.clear();
VAR_42           = 0;
VAR_9      = 0;
VAR_8        = 0;
VAR_10 = false;
VAR_3 = 0;
return 0;
}
return VAR_2;
}",Matroska-Org/libmatroska/0a2d3e3644a7453b6513db2f9bc270f77943573f/KaxBlock.cpp/vul/before/0.json,"filepos_t KaxInternalBlock::ReadData(IOCallback & input, ScopeMode ReadFully)
{
  filepos_t Result;

  FirstFrameLocation = input.getFilePointer(); // will be updated accordingly below

  SetValueIsSet(false);

  try {
    if (ReadFully == SCOPE_ALL_DATA) {
      Result = EbmlBinary::ReadData(input, ReadFully);
      if (Result != GetSize())
        throw SafeReadIOCallback::EndOfStreamX(GetSize() - Result);

      binary *BufferStart = EbmlBinary::GetBuffer();

      SafeReadIOCallback Mem(*this);
      uint8 BlockHeadSize = 4;

      // update internal values
      TrackNumber = Mem.GetUInt8();
      if ((TrackNumber & 0x80) == 0) {
        // there is extra data
        if ((TrackNumber & 0x40) == 0) {
          // We don't support track numbers that large !
          throw SafeReadIOCallback::EndOfStreamX(0);
        }
        TrackNumber = (TrackNumber & 0x3F) << 8;
        TrackNumber += Mem.GetUInt8();
        BlockHeadSize++;
      } else {
        TrackNumber &= 0x7F;
      }

      LocalTimecode = int16(Mem.GetUInt16BE());
      bLocalTimecodeUsed = true;

      uint8 Flags = Mem.GetUInt8();
      if (EbmlId(*this) == EBML_ID(KaxSimpleBlock)) {
        bIsKeyframe = (Flags & 0x80) != 0;
        bIsDiscardable = (Flags & 0x01) != 0;
      }
      mInvisible = (Flags & 0x08) >> 3;
      mLacing = LacingType((Flags & 0x06) >> 1);

      // put all Frames in the list
      if (mLacing == LACING_NONE) {
        FirstFrameLocation += Mem.GetPosition();
        DataBuffer * soloFrame = new DataBuffer(BufferStart + Mem.GetPosition(), GetSize() - BlockHeadSize);
        myBuffers.push_back(soloFrame);
        SizeList.resize(1);
        SizeList[0] = GetSize() - BlockHeadSize;
      } else {
        // read the number of frames in the lace
        uint32 LastBufferSize = GetSize() - BlockHeadSize - 1; // 1 for number of frame
        uint8 FrameNum = Mem.GetUInt8(); // number of frames in the lace - 1
        // read the list of frame sizes
        uint8 Index;
        int32 FrameSize;
        uint32 SizeRead;
        uint64 SizeUnknown;

        SizeList.resize(FrameNum + 1);

        switch (mLacing) {
          case LACING_XIPH:
            for (Index=0; Index<FrameNum; Index++) {
              // get the size of the frame
              FrameSize = 0;
              uint8 Value;
              do {
                Value = Mem.GetUInt8();
                FrameSize += Value;
                LastBufferSize--;
              } while (Value == 0xFF);
              SizeList[Index] = FrameSize;
              LastBufferSize -= FrameSize;
            }
            SizeList[Index] = LastBufferSize;
            break;
          case LACING_EBML:
            SizeRead = LastBufferSize;
            FrameSize = ReadCodedSizeValue(BufferStart + Mem.GetPosition(), SizeRead, SizeUnknown);
            if (!FrameSize || (static_cast<uint32>(FrameSize + SizeRead) > LastBufferSize))
              throw SafeReadIOCallback::EndOfStreamX(SizeRead);
            SizeList[0] = FrameSize;
            Mem.Skip(SizeRead);
            LastBufferSize -= FrameSize + SizeRead;

            for (Index=1; Index<FrameNum; Index++) {
              // get the size of the frame
              SizeRead = LastBufferSize;
              FrameSize += ReadCodedSizeSignedValue(BufferStart + Mem.GetPosition(), SizeRead, SizeUnknown);
              if (!FrameSize || (static_cast<uint32>(FrameSize + SizeRead) > LastBufferSize))
                throw SafeReadIOCallback::EndOfStreamX(SizeRead);
              SizeList[Index] = FrameSize;
              Mem.Skip(SizeRead);
              LastBufferSize -= FrameSize + SizeRead;
            }
            if (Index <= FrameNum) // Safety check if FrameNum == 0
              SizeList[Index] = LastBufferSize;
            break;
          case LACING_FIXED:
            for (Index=0; Index<=FrameNum; Index++) {
              // get the size of the frame
              SizeList[Index] = LastBufferSize / (FrameNum + 1);
            }
            break;
          default: // other lacing not supported
            assert(0);
        }

        FirstFrameLocation += Mem.GetPosition();

        for (Index=0; Index<=FrameNum; Index++) {
          DataBuffer * lacedFrame = new DataBuffer(BufferStart + Mem.GetPosition(), SizeList[Index]);
          myBuffers.push_back(lacedFrame);
          Mem.Skip(SizeList[Index]);
        }
      }

      binary *BufferEnd = BufferStart + GetSize();
      size_t NumFrames  = myBuffers.size();

      // Sanity checks for frame pointers and boundaries.
      for (size_t Index = 0; Index < NumFrames; ++Index) {
        binary *FrameStart  = myBuffers[Index]->Buffer();
        binary *FrameEnd    = FrameStart + myBuffers[Index]->Size();
        binary *ExpectedEnd = (Index + 1) < NumFrames ? myBuffers[Index + 1]->Buffer() : BufferEnd;

        if ((FrameStart < BufferStart) || (FrameEnd > BufferEnd) || (FrameEnd != ExpectedEnd))
          throw SafeReadIOCallback::EndOfStreamX(0);
      }

      SetValueIsSet();
    } else if (ReadFully == SCOPE_PARTIAL_DATA) {
      binary _TempHead[5];
      Result = input.read(_TempHead, 5);
      if (Result != 5)
        throw SafeReadIOCallback::EndOfStreamX(0);
      binary *cursor = _TempHead;
      binary *_tmpBuf;
      uint8 BlockHeadSize = 4;

      // update internal values
      TrackNumber = *cursor++;
      if ((TrackNumber & 0x80) == 0) {
        // there is extra data
        if ((TrackNumber & 0x40) == 0) {
          // We don't support track numbers that large !
          return Result;
        }
        TrackNumber = (TrackNumber & 0x3F) << 8;
        TrackNumber += *cursor++;
        BlockHeadSize++;
      } else {
        TrackNumber &= 0x7F;
      }

      big_int16 b16;
      b16.Eval(cursor);
      LocalTimecode = int16(b16);
      bLocalTimecodeUsed = true;
      cursor += 2;

      if (EbmlId(*this) == EBML_ID(KaxSimpleBlock)) {
        bIsKeyframe = (*cursor & 0x80) != 0;
        bIsDiscardable = (*cursor & 0x01) != 0;
      }
      mInvisible = (*cursor & 0x08) >> 3;
      mLacing = LacingType((*cursor++ & 0x06) >> 1);
      if (cursor == &_TempHead[4]) {
        _TempHead[0] = _TempHead[4];
      } else {
        Result += input.read(_TempHead, 1);
      }

      FirstFrameLocation += cursor - _TempHead;

      // put all Frames in the list
      if (mLacing != LACING_NONE) {
        // read the number of frames in the lace
        uint32 LastBufferSize = GetSize() - BlockHeadSize - 1; // 1 for number of frame
        uint8 FrameNum = _TempHead[0]; // number of frames in the lace - 1
        // read the list of frame sizes
        uint8 Index;
        int32 FrameSize;
        uint32 SizeRead;
        uint64 SizeUnknown;

        SizeList.resize(FrameNum + 1);

        switch (mLacing) {
          case LACING_XIPH:
            for (Index=0; Index<FrameNum; Index++) {
              // get the size of the frame
              FrameSize = 0;
              do {
                Result += input.read(_TempHead, 1);
                FrameSize += uint8(_TempHead[0]);
                LastBufferSize--;

                FirstFrameLocation++;
              } while (_TempHead[0] == 0xFF);

              FirstFrameLocation++;
              SizeList[Index] = FrameSize;
              LastBufferSize -= FrameSize;
            }
            SizeList[Index] = LastBufferSize;
            break;
          case LACING_EBML:
            SizeRead = LastBufferSize;
            cursor = _tmpBuf = new binary[FrameNum*4]; /// \warning assume the mean size will be coded in less than 4 bytes
            Result += input.read(cursor, FrameNum*4);
            FrameSize = ReadCodedSizeValue(cursor, SizeRead, SizeUnknown);
            SizeList[0] = FrameSize;
            cursor += SizeRead;
            LastBufferSize -= FrameSize + SizeRead;

            for (Index=1; Index<FrameNum; Index++) {
              // get the size of the frame
              SizeRead = LastBufferSize;
              FrameSize += ReadCodedSizeSignedValue(cursor, SizeRead, SizeUnknown);
              SizeList[Index] = FrameSize;
              cursor += SizeRead;
              LastBufferSize -= FrameSize + SizeRead;
            }

            FirstFrameLocation += cursor - _tmpBuf;

            SizeList[Index] = LastBufferSize;
            delete [] _tmpBuf;
            break;
          case LACING_FIXED:
            for (Index=0; Index<=FrameNum; Index++) {
              // get the size of the frame
              SizeList[Index] = LastBufferSize / (FrameNum + 1);
            }
            break;
          default: // other lacing not supported
            assert(0);
        }
      } else {
        SizeList.resize(1);
        SizeList[0] = GetSize() - BlockHeadSize;
      }
      SetValueIsSet(false);
      Result = GetSize();
    } else {
      SetValueIsSet(false);
      Result = GetSize();
    }

  } catch (SafeReadIOCallback::EndOfStreamX &) {
    SetValueIsSet(false);

    std::memset(EbmlBinary::GetBuffer(), 0, GetSize());
    myBuffers.clear();
    SizeList.clear();
    Timecode           = 0;
    LocalTimecode      = 0;
    TrackNumber        = 0;
    bLocalTimecodeUsed = false;
    FirstFrameLocation = 0;

    return 0;
  }

  return Result;
}","filepos_t KaxInternalBlock::ReadData(IOCallback & VAR_0, ScopeMode VAR_1)
{
  filepos_t VAR_2;

  VAR_3 = VAR_0.getFilePointer(); /* COMMENT_0 */

  SetValueIsSet(false);

  try {
    if (VAR_1 == VAR_4) {
      VAR_2 = EbmlBinary::ReadData(VAR_0, VAR_1);
      if (VAR_2 != GetSize())
        throw SafeReadIOCallback::EndOfStreamX(GetSize() - VAR_2);

      binary *VAR_5 = EbmlBinary::GetBuffer();

      SafeReadIOCallback VAR_6(*this);
      uint8 VAR_7 = 4;

      /* COMMENT_1 */
      VAR_8 = VAR_6.GetUInt8();
      if ((VAR_8 & 0x80) == 0) {
        /* COMMENT_2 */
        if ((VAR_8 & 0x40) == 0) {
          /* COMMENT_3 */
          throw SafeReadIOCallback::EndOfStreamX(0);
        }
        VAR_8 = (VAR_8 & 0x3F) << 8;
        VAR_8 += VAR_6.GetUInt8();
        VAR_7++;
      } else {
        VAR_8 &= 0x7F;
      }

      VAR_9 = int16(VAR_6.GetUInt16BE());
      VAR_10 = true;

      uint8 VAR_11 = VAR_6.GetUInt8();
      if (EbmlId(*this) == EBML_ID(VAR_12)) {
        VAR_13 = (VAR_11 & 0x80) != 0;
        VAR_14 = (VAR_11 & 0x01) != 0;
      }
      VAR_15 = (VAR_11 & 0x08) >> 3;
      VAR_16 = LacingType((VAR_11 & 0x06) >> 1);

      /* COMMENT_4 */
      if (VAR_16 == VAR_17) {
        VAR_3 += VAR_6.GetPosition();
        DataBuffer * VAR_18 = new DataBuffer(VAR_5 + VAR_6.GetPosition(), GetSize() - VAR_7);
        VAR_19.push_back(VAR_18);
        VAR_20.resize(1);
        VAR_20[0] = GetSize() - VAR_7;
      } else {
        /* COMMENT_5 */
        uint32 VAR_21 = GetSize() - VAR_7 - 1; /* COMMENT_6 */
        uint8 VAR_22 = VAR_6.GetUInt8(); /* COMMENT_7 */
        /* COMMENT_8 */
        uint8 VAR_23;
        int32 VAR_24;
        uint32 VAR_25;
        uint64 VAR_26;

        VAR_20.resize(VAR_22 + 1);

        switch (VAR_16) {
          case VAR_27:
            for (VAR_23=0; VAR_23<VAR_22; VAR_23++) {
              /* COMMENT_9 */
              VAR_24 = 0;
              uint8 VAR_28;
              do {
                VAR_28 = VAR_6.GetUInt8();
                VAR_24 += VAR_28;
                VAR_21--;
              } while (VAR_28 == 0xFF);
              VAR_20[VAR_23] = VAR_24;
              VAR_21 -= VAR_24;
            }
            VAR_20[VAR_23] = VAR_21;
            break;
          case VAR_29:
            VAR_25 = VAR_21;
            VAR_24 = ReadCodedSizeValue(VAR_5 + VAR_6.GetPosition(), VAR_25, VAR_26);
            if (!VAR_24 || (VAR_30<uint32>(VAR_24 + VAR_25) > VAR_21))
              throw SafeReadIOCallback::EndOfStreamX(VAR_25);
            VAR_20[0] = VAR_24;
            VAR_6.Skip(VAR_25);
            VAR_21 -= VAR_24 + VAR_25;

            for (VAR_23=1; VAR_23<VAR_22; VAR_23++) {
              /* COMMENT_9 */
              VAR_25 = VAR_21;
              VAR_24 += ReadCodedSizeSignedValue(VAR_5 + VAR_6.GetPosition(), VAR_25, VAR_26);
              if (!VAR_24 || (VAR_30<uint32>(VAR_24 + VAR_25) > VAR_21))
                throw SafeReadIOCallback::EndOfStreamX(VAR_25);
              VAR_20[VAR_23] = VAR_24;
              VAR_6.Skip(VAR_25);
              VAR_21 -= VAR_24 + VAR_25;
            }
            if (VAR_23 <= VAR_22) /* COMMENT_10 */
              VAR_20[VAR_23] = VAR_21;
            break;
          case VAR_31:
            for (VAR_23=0; VAR_23<=VAR_22; VAR_23++) {
              /* COMMENT_9 */
              VAR_20[VAR_23] = VAR_21 / (VAR_22 + 1);
            }
            break;
          default: /* COMMENT_11 */
            assert(0);
        }

        VAR_3 += VAR_6.GetPosition();

        for (VAR_23=0; VAR_23<=VAR_22; VAR_23++) {
          DataBuffer * VAR_32 = new DataBuffer(VAR_5 + VAR_6.GetPosition(), VAR_20[VAR_23]);
          VAR_19.push_back(VAR_32);
          VAR_6.Skip(VAR_20[VAR_23]);
        }
      }

      binary *VAR_33 = VAR_5 + GetSize();
      size_t VAR_34  = VAR_19.size();

      /* COMMENT_12 */
      for (size_t VAR_23 = 0; VAR_23 < VAR_34; ++VAR_23) {
        binary *VAR_35  = VAR_19[VAR_23]->Buffer();
        binary *VAR_36    = VAR_35 + VAR_19[VAR_23]->Size();
        binary *VAR_37 = (VAR_23 + 1) < VAR_34 ? VAR_19[VAR_23 + 1]->Buffer() : VAR_33;

        if ((VAR_35 < VAR_5) || (VAR_36 > VAR_33) || (VAR_36 != VAR_37))
          throw SafeReadIOCallback::EndOfStreamX(0);
      }

      SetValueIsSet();
    } else if (VAR_1 == VAR_38) {
      binary VAR_39[5];
      VAR_2 = VAR_0.read(VAR_39, 5);
      if (VAR_2 != 5)
        throw SafeReadIOCallback::EndOfStreamX(0);
      binary *VAR_40 = VAR_39;
      binary *VAR_41;
      uint8 VAR_7 = 4;

      /* COMMENT_1 */
      VAR_8 = *VAR_40++;
      if ((VAR_8 & 0x80) == 0) {
        /* COMMENT_2 */
        if ((VAR_8 & 0x40) == 0) {
          /* COMMENT_3 */
          return VAR_2;
        }
        VAR_8 = (VAR_8 & 0x3F) << 8;
        VAR_8 += *VAR_40++;
        VAR_7++;
      } else {
        VAR_8 &= 0x7F;
      }

      big_int16 VAR_42;
      VAR_42.Eval(VAR_40);
      VAR_9 = int16(VAR_42);
      VAR_10 = true;
      VAR_40 += 2;

      if (EbmlId(*this) == EBML_ID(VAR_12)) {
        VAR_13 = (*VAR_40 & 0x80) != 0;
        VAR_14 = (*VAR_40 & 0x01) != 0;
      }
      VAR_15 = (*VAR_40 & 0x08) >> 3;
      VAR_16 = LacingType((*VAR_40++ & 0x06) >> 1);
      if (VAR_40 == &VAR_39[4]) {
        VAR_39[0] = VAR_39[4];
      } else {
        VAR_2 += VAR_0.read(VAR_39, 1);
      }

      VAR_3 += VAR_40 - VAR_39;

      /* COMMENT_4 */
      if (VAR_16 != VAR_17) {
        /* COMMENT_5 */
        uint32 VAR_21 = GetSize() - VAR_7 - 1; /* COMMENT_6 */
        uint8 VAR_22 = VAR_39[0]; /* COMMENT_7 */
        /* COMMENT_8 */
        uint8 VAR_23;
        int32 VAR_24;
        uint32 VAR_25;
        uint64 VAR_26;

        VAR_20.resize(VAR_22 + 1);

        switch (VAR_16) {
          case VAR_27:
            for (VAR_23=0; VAR_23<VAR_22; VAR_23++) {
              /* COMMENT_9 */
              VAR_24 = 0;
              do {
                VAR_2 += VAR_0.read(VAR_39, 1);
                VAR_24 += uint8(VAR_39[0]);
                VAR_21--;

                VAR_3++;
              } while (VAR_39[0] == 0xFF);

              VAR_3++;
              VAR_20[VAR_23] = VAR_24;
              VAR_21 -= VAR_24;
            }
            VAR_20[VAR_23] = VAR_21;
            break;
          case VAR_29:
            VAR_25 = VAR_21;
            VAR_40 = VAR_41 = new binary[VAR_22*4]; /* COMMENT_13 */
            VAR_2 += VAR_0.read(VAR_40, VAR_22*4);
            VAR_24 = ReadCodedSizeValue(VAR_40, VAR_25, VAR_26);
            VAR_20[0] = VAR_24;
            VAR_40 += VAR_25;
            VAR_21 -= VAR_24 + VAR_25;

            for (VAR_23=1; VAR_23<VAR_22; VAR_23++) {
              /* COMMENT_9 */
              VAR_25 = VAR_21;
              VAR_24 += ReadCodedSizeSignedValue(VAR_40, VAR_25, VAR_26);
              VAR_20[VAR_23] = VAR_24;
              VAR_40 += VAR_25;
              VAR_21 -= VAR_24 + VAR_25;
            }

            VAR_3 += VAR_40 - VAR_41;

            VAR_20[VAR_23] = VAR_21;
            delete [] VAR_41;
            break;
          case VAR_31:
            for (VAR_23=0; VAR_23<=VAR_22; VAR_23++) {
              /* COMMENT_9 */
              VAR_20[VAR_23] = VAR_21 / (VAR_22 + 1);
            }
            break;
          default: /* COMMENT_11 */
            assert(0);
        }
      } else {
        VAR_20.resize(1);
        VAR_20[0] = GetSize() - VAR_7;
      }
      SetValueIsSet(false);
      VAR_2 = GetSize();
    } else {
      SetValueIsSet(false);
      VAR_2 = GetSize();
    }

  } catch (SafeReadIOCallback::EndOfStreamX &) {
    SetValueIsSet(false);

    std::memset(EbmlBinary::GetBuffer(), 0, GetSize());
    VAR_19.clear();
    VAR_20.clear();
    VAR_43           = 0;
    VAR_9      = 0;
    VAR_8        = 0;
    VAR_10 = false;
    VAR_3 = 0;

    return 0;
  }

  return VAR_2;
}",Matroska-Org/libmatroska/0a2d3e3644a7453b6513db2f9bc270f77943573f/KaxBlock.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -81,6 +81,8 @@
           case LACING_EBML:
             SizeRead = LastBufferSize;
             FrameSize = ReadCodedSizeValue(BufferStart + Mem.GetPosition(), SizeRead, SizeUnknown);
+            if (!FrameSize || (static_cast<uint32>(FrameSize + SizeRead) > LastBufferSize))
+              throw SafeReadIOCallback::EndOfStreamX(SizeRead);
             SizeList[0] = FrameSize;
             Mem.Skip(SizeRead);
             LastBufferSize -= FrameSize + SizeRead;
@@ -89,6 +91,8 @@
               // get the size of the frame
               SizeRead = LastBufferSize;
               FrameSize += ReadCodedSizeSignedValue(BufferStart + Mem.GetPosition(), SizeRead, SizeUnknown);
+              if (!FrameSize || (static_cast<uint32>(FrameSize + SizeRead) > LastBufferSize))
+                throw SafeReadIOCallback::EndOfStreamX(SizeRead);
               SizeList[Index] = FrameSize;
               Mem.Skip(SizeRead);
               LastBufferSize -= FrameSize + SizeRead;","{'deleted_lines': [], 'added_lines': ['            if (!FrameSize || (static_cast<uint32>(FrameSize + SizeRead) > LastBufferSize))', '              throw SafeReadIOCallback::EndOfStreamX(SizeRead);', '              if (!FrameSize || (static_cast<uint32>(FrameSize + SizeRead) > LastBufferSize))', '                throw SafeReadIOCallback::EndOfStreamX(SizeRead);']}",True,"The KaxInternalBlock::ReadData function in libMatroska before 1.4.4 allows context-dependent attackers to obtain sensitive information from process heap memory via crafted EBML lacing, which triggers an invalid memory access.",5.3,MEDIUM,1,test,2015-10-20T10:00:53Z,1
CVE-2015-8729,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"Fix out-of-bounds read in ascend_seek.

Bug: 11794
Change-Id: I74517806b119729ae6d9780bbd4bb094701ff05e
Reviewed-on: https://code.wireshark.org/review/12266
Petri-Dish: Michael Mann <mmann78@netscape.net>
Reviewed-by: Peter Wu <peter@lekensteyn.nl>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Michael Mann <mmann78@netscape.net>",338da1c0ea0b2f8595d3a7b6d6c9548f7da3e27b,https://github.com/wireshark/wireshark/commit/338da1c0ea0b2f8595d3a7b6d6c9548f7da3e27b,wiretap/ascendtext.c,ascend_seek,"static gint64 ascend_seek(wtap *wth, int *err, gchar **err_info)
{
int byte;
gint64 date_off = -1, cur_off, packet_off;
size_t string_level[ASCEND_MAGIC_STRINGS];
guint string_i = 0, type = 0;
guint excessive_read_count = 262144;
memset(&string_level, 0, sizeof(string_level));
while (((byte = file_getc(wth->fh)) != EOF)) {
excessive_read_count--;
if (!excessive_read_count) {
*err = 0;
return -1;
}
for (string_i = 0; string_i < ASCEND_MAGIC_STRINGS; string_i++) {
const gchar *strptr = ascend_magic[string_i].strptr;
size_t len          = strlen(strptr);
if (byte == *(strptr + string_level[string_i])) {
string_level[string_i]++;
if (string_level[string_i] >= len) {
cur_off = file_tell(wth->fh);
if (cur_off == -1) {
*err = file_error(wth->fh, err_info);
return -1;
}
if (strcmp(strptr, ASCEND_DATE) == 0) {
date_off = cur_off - len;
} else {
if (date_off == -1) {
packet_off = cur_off - len;
} else {
packet_off = date_off;
}
type = ascend_magic[string_i].type;
goto found;
}
}
} else {
string_level[string_i] = 0;
}
}
}
*err = file_error(wth->fh, err_info);
return -1;
found:
if (file_seek(wth->fh, packet_off, SEEK_SET, err) == -1)
return -1;
wth->phdr.pseudo_header.ascend.type = type;
return packet_off;
}","static gint64 ascend_seek(wtap *VAR_0, int *VAR_1, gchar **VAR_2)
{
int VAR_3;
gint64 VAR_4 = -1, VAR_5, VAR_6;
size_t VAR_7[VAR_8];
guint VAR_9 = 0, VAR_10 = 0;
guint VAR_11 = 262144;
memset(&VAR_7, 0, sizeof(VAR_7));
while (((VAR_3 = file_getc(VAR_0->fh)) != VAR_12)) {
VAR_11--;
if (!VAR_11) {
*VAR_1 = 0;
return -1;
}
for (VAR_9 = 0; VAR_9 < VAR_8; VAR_9++) {
const gchar *VAR_13 = VAR_14[VAR_9].strptr;
size_t VAR_15          = strlen(VAR_13);
if (VAR_3 == *(VAR_13 + VAR_7[VAR_9])) {
VAR_7[VAR_9]++;
if (VAR_7[VAR_9] >= VAR_15) {
VAR_5 = file_tell(VAR_0->fh);
if (VAR_5 == -1) {
*VAR_1 = file_error(VAR_0->fh, VAR_2);
return -1;
}
if (strcmp(VAR_13, VAR_16) == 0) {
VAR_4 = VAR_5 - VAR_15;
} else {
if (VAR_4 == -1) {
VAR_6 = VAR_5 - VAR_15;
} else {
VAR_6 = VAR_4;
}
VAR_10 = VAR_14[VAR_9].type;
goto found;
}
}
} else {
VAR_7[VAR_9] = 0;
}
}
}
*VAR_1 = file_error(VAR_0->fh, VAR_2);
return -1;
found:
if (file_seek(VAR_0->fh, VAR_6, VAR_17, VAR_1) == -1)
return -1;
VAR_0->phdr.pseudo_header.ascend.type = VAR_10;
return VAR_6;
}",wireshark/338da1c0ea0b2f8595d3a7b6d6c9548f7da3e27b/ascendtext.c/vul/before/0.json,"static gint64 ascend_seek(wtap *wth, int *err, gchar **err_info)
{
  int byte;
  gint64 date_off = -1, cur_off, packet_off;
  size_t string_level[ASCEND_MAGIC_STRINGS];
  guint string_i = 0, type = 0;
  guint excessive_read_count = 262144;

  memset(&string_level, 0, sizeof(string_level));

  while (((byte = file_getc(wth->fh)) != EOF)) {
    excessive_read_count--;

    if (!excessive_read_count) {
      *err = 0;
      return -1;
    }

    for (string_i = 0; string_i < ASCEND_MAGIC_STRINGS; string_i++) {
      const gchar *strptr = ascend_magic[string_i].strptr;
      size_t len          = strlen(strptr);

      if (byte == *(strptr + string_level[string_i])) {
        string_level[string_i]++;
        if (string_level[string_i] >= len) {
          cur_off = file_tell(wth->fh);
          if (cur_off == -1) {
            /* Error. */
            *err = file_error(wth->fh, err_info);
            return -1;
          }

          /* Date: header is a special case. Remember the offset,
             but keep looking for other headers. */
          if (strcmp(strptr, ASCEND_DATE) == 0) {
            date_off = cur_off - len;
            string_level[string_i] = 0;
          } else {
            if (date_off == -1) {
              /* Back up over the header we just read; that's where a read
                 of this packet should start. */
              packet_off = cur_off - len;
            } else {
              /* This packet has a date/time header; a read of it should
                 start at the beginning of *that* header. */
              packet_off = date_off;
            }

            type = ascend_magic[string_i].type;
            goto found;
          }
        }
      } else {
        string_level[string_i] = 0;
      }
    }
  }

  *err = file_error(wth->fh, err_info);
  return -1;

found:
  /*
   * Move to where the read for this packet should start, and return
   * that seek offset.
   */
  if (file_seek(wth->fh, packet_off, SEEK_SET, err) == -1)
    return -1;

  wth->phdr.pseudo_header.ascend.type = type;

  return packet_off;
}","static gint64 ascend_seek(wtap *VAR_0, int *VAR_1, gchar **VAR_2)
{
  int VAR_3;
  gint64 VAR_4 = -1, VAR_5, VAR_6;
  size_t VAR_7[VAR_8];
  guint VAR_9 = 0, VAR_10 = 0;
  guint VAR_11 = 262144;

  memset(&VAR_7, 0, sizeof(VAR_7));

  while (((VAR_3 = file_getc(VAR_0->fh)) != VAR_12)) {
    VAR_11--;

    if (!VAR_11) {
      *VAR_1 = 0;
      return -1;
    }

    for (VAR_9 = 0; VAR_9 < VAR_8; VAR_9++) {
      const gchar *VAR_13 = VAR_14[VAR_9].strptr;
      size_t VAR_15          = strlen(VAR_13);

      if (VAR_3 == *(VAR_13 + VAR_7[VAR_9])) {
        VAR_7[VAR_9]++;
        if (VAR_7[VAR_9] >= VAR_15) {
          VAR_5 = file_tell(VAR_0->fh);
          if (VAR_5 == -1) {
            /* COMMENT_0 */
            *VAR_1 = file_error(VAR_0->fh, VAR_2);
            return -1;
          }

          /* COMMENT_1 */
                                                   
          if (strcmp(VAR_13, VAR_16) == 0) {
            VAR_4 = VAR_5 - VAR_15;
            VAR_7[VAR_9] = 0;
          } else {
            if (VAR_4 == -1) {
              /* COMMENT_3 */
                                                
              VAR_6 = VAR_5 - VAR_15;
            } else {
              /* COMMENT_5 */
                                                            
              VAR_6 = VAR_4;
            }

            VAR_10 = VAR_14[VAR_9].type;
            goto found;
          }
        }
      } else {
        VAR_7[VAR_9] = 0;
      }
    }
  }

  *VAR_1 = file_error(VAR_0->fh, VAR_2);
  return -1;

found:
  /* COMMENT_7 */
                                                                    
                      
     
  if (file_seek(VAR_0->fh, VAR_6, VAR_17, VAR_1) == -1)
    return -1;

  VAR_0->phdr.pseudo_header.ascend.type = VAR_10;

  return VAR_6;
}",wireshark/338da1c0ea0b2f8595d3a7b6d6c9548f7da3e27b/ascendtext.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -34,6 +34,7 @@
              but keep looking for other headers. */
           if (strcmp(strptr, ASCEND_DATE) == 0) {
             date_off = cur_off - len;
+            string_level[string_i] = 0;
           } else {
             if (date_off == -1) {
               /* Back up over the header we just read; that's where a read","{'deleted_lines': [], 'added_lines': ['            string_level[string_i] = 0;']}",True,"The ascend_seek function in wiretap/ascendtext.c in the Ascend file parser in Wireshark 1.12.x before 1.12.9 and 2.0.x before 2.0.1 does not ensure the presence of a '\0' character at the end of a date string, which allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted file.",5.5,MEDIUM,1,test,2015-11-28T21:17:22Z,1
CVE-2015-7551,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,ruby,"merge revision(s): 53153 and 23405@ruby_1_9_1

	* ext/fiddle/handle.c: check tainted string arguments.
	  Patch provided by tenderlove and nobu.

	* test/fiddle/test_handle.rb (class TestHandle): add test for above.

	* ext/dl/handle.c (rb_dlhandle_initialize): prohibits DL::dlopen
	  with a tainted name of library.
	  Patch by sheepman <sheepman AT sheepman.sakura.ne.jp>.

	* ext/dl/handle.c (rb_dlhandle_sym): ditto



git-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_2_1@53156 b2dd03c8-39d4-4d8f-98ff-823fe69b080e",339e11a7f178312d937b7c95dd3115ce7236597a,https://github.com/ruby/ruby/commit/339e11a7f178312d937b7c95dd3115ce7236597a,ext/fiddle/handle.c,fiddle_handle_sym,"static VALUE
fiddle_handle_sym(void *handle, const char *name)
{
#if defined(HAVE_DLERROR)
const char *err;
# define CHECK_DLERROR if( err = dlerror() ){ func = 0; }
#else
# define CHECK_DLERROR
#endif
void (*func)();
rb_secure(2);
#ifdef HAVE_DLERROR
dlerror();
#endif
func = (void (*)())(VALUE)dlsym(handle, name);
CHECK_DLERROR;
#if defined(FUNC_STDCALL)
if( !func ){
int  i;
int  len = (int)strlen(name);
char *name_n;
#if defined(__CYGWIN__) || defined(_WIN32) || defined(__MINGW32__)
{
char *name_a = (char*)xmalloc(len+2);
strcpy(name_a, name);
name_n = name_a;
name_a[len]   = 'A';
name_a[len+1] = '\0';
func = dlsym(handle, name_a);
CHECK_DLERROR;
if( func ) goto found;
name_n = xrealloc(name_a, len+6);
}
#else
name_n = (char*)xmalloc(len+6);
#endif
memcpy(name_n, name, len);
name_n[len++] = '@';
for( i = 0; i < 256; i += 4 ){
sprintf(name_n + len, ""%d"", i);
func = dlsym(handle, name_n);
CHECK_DLERROR;
if( func ) break;
}
if( func ) goto found;
name_n[len-1] = 'A';
name_n[len++] = '@';
for( i = 0; i < 256; i += 4 ){
sprintf(name_n + len, ""%d"", i);
func = dlsym(handle, name_n);
CHECK_DLERROR;
if( func ) break;
}
found:
xfree(name_n);
}
#endif
if( !func ){
rb_raise(rb_eFiddleError, ""unknown symbol \""%s\"""", name);
}
return PTR2NUM(func);
}","static VALUE
fiddle_handle_sym(void *VAR_0, const char *VAR_1)
{
#if defined(VAR_2)
const char *VAR_3;
# define VAR_4 if( err = dlerror() ){ func = 0; }
#else
# define VAR_4
#endif
void (*VAR_5)();
rb_secure(2);
#ifdef VAR_2
dlerror();
#endif
VAR_5 = (void (*)())(VALUE)dlsym(VAR_0, VAR_1);
VAR_4;
#if defined(VAR_6)
if( !VAR_5 ){
int  VAR_7;
int  VAR_8 = (int)strlen(VAR_1);
char *VAR_9;
#if defined(VAR_10) || defined(VAR_11) || defined(VAR_12)
{
char *VAR_13 = (char*)xmalloc(VAR_8+2);
strcpy(VAR_13, VAR_1);
VAR_9 = VAR_13;
VAR_13[VAR_8]   = 'A';
VAR_13[VAR_8+1] = '\0';
VAR_5 = dlsym(VAR_0, VAR_13);
VAR_4;
if( VAR_5 ) goto found;
VAR_9 = xrealloc(VAR_13, VAR_8+6);
}
#else
VAR_9 = (char*)xmalloc(VAR_8+6);
#endif
memcpy(VAR_9, VAR_1, VAR_8);
VAR_9[VAR_8++] = '@';
for( VAR_7 = 0; VAR_7 < 256; VAR_7 += 4 ){
sprintf(VAR_9 + VAR_8, ""%d"", VAR_7);
VAR_5 = dlsym(VAR_0, VAR_9);
VAR_4;
if( VAR_5 ) break;
}
if( VAR_5 ) goto found;
VAR_9[VAR_8-1] = 'A';
VAR_9[VAR_8++] = '@';
for( VAR_7 = 0; VAR_7 < 256; VAR_7 += 4 ){
sprintf(VAR_9 + VAR_8, ""%d"", VAR_7);
VAR_5 = dlsym(VAR_0, VAR_9);
VAR_4;
if( VAR_5 ) break;
}
found:
xfree(VAR_9);
}
#endif
if( !VAR_5 ){
rb_raise(VAR_14, ""unknown symbol \""%s\"""", VAR_1);
}
return PTR2NUM(VAR_5);
}",ruby/339e11a7f178312d937b7c95dd3115ce7236597a/handle.c/vul/before/3.json,"static VALUE
fiddle_handle_sym(void *handle, VALUE symbol)
{
#if defined(HAVE_DLERROR)
    const char *err;
# define CHECK_DLERROR if( err = dlerror() ){ func = 0; }
#else
# define CHECK_DLERROR
#endif
    void (*func)();
    const char *name = SafeStringValueCStr(symbol);

    rb_secure(2);
#ifdef HAVE_DLERROR
    dlerror();
#endif
    func = (void (*)())(VALUE)dlsym(handle, name);
    CHECK_DLERROR;
#if defined(FUNC_STDCALL)
    if( !func ){
	int  i;
	int  len = (int)strlen(name);
	char *name_n;
#if defined(__CYGWIN__) || defined(_WIN32) || defined(__MINGW32__)
	{
	    char *name_a = (char*)xmalloc(len+2);
	    strcpy(name_a, name);
	    name_n = name_a;
	    name_a[len]   = 'A';
	    name_a[len+1] = '\0';
	    func = dlsym(handle, name_a);
	    CHECK_DLERROR;
	    if( func ) goto found;
	    name_n = xrealloc(name_a, len+6);
	}
#else
	name_n = (char*)xmalloc(len+6);
#endif
	memcpy(name_n, name, len);
	name_n[len++] = '@';
	for( i = 0; i < 256; i += 4 ){
	    sprintf(name_n + len, ""%d"", i);
	    func = dlsym(handle, name_n);
	    CHECK_DLERROR;
	    if( func ) break;
	}
	if( func ) goto found;
	name_n[len-1] = 'A';
	name_n[len++] = '@';
	for( i = 0; i < 256; i += 4 ){
	    sprintf(name_n + len, ""%d"", i);
	    func = dlsym(handle, name_n);
	    CHECK_DLERROR;
	    if( func ) break;
	}
      found:
	xfree(name_n);
    }
#endif
    if( !func ){
	rb_raise(rb_eFiddleError, ""unknown symbol \""%""PRIsVALUE""\"""", symbol);
    }

    return PTR2NUM(func);
}","static VALUE
fiddle_handle_sym(void *VAR_0, VALUE VAR_1)
{
#if defined(VAR_2)
    const char *VAR_3;
# define VAR_4 if( err = dlerror() ){ func = 0; }
#else
# define VAR_4
#endif
    void (*VAR_5)();
    const char *VAR_6 = SafeStringValueCStr(VAR_1);

    rb_secure(2);
#ifdef VAR_2
    dlerror();
#endif
    VAR_5 = (void (*)())(VALUE)dlsym(VAR_0, VAR_6);
    VAR_4;
#if defined(VAR_7)
    if( !VAR_5 ){
	int  VAR_8;
	int  VAR_9 = (int)strlen(VAR_6);
	char *VAR_10;
#if defined(VAR_11) || defined(VAR_12) || defined(VAR_13)
	{
	    char *VAR_14 = (char*)xmalloc(VAR_9+2);
	    strcpy(VAR_14, VAR_6);
	    VAR_10 = VAR_14;
	    VAR_14[VAR_9]   = 'A';
	    VAR_14[VAR_9+1] = '\0';
	    VAR_5 = dlsym(VAR_0, VAR_14);
	    VAR_4;
	    if( VAR_5 ) goto found;
	    VAR_10 = xrealloc(VAR_14, VAR_9+6);
	}
#else
	VAR_10 = (char*)xmalloc(VAR_9+6);
#endif
	memcpy(VAR_10, VAR_6, VAR_9);
	VAR_10[VAR_9++] = '@';
	for( VAR_8 = 0; VAR_8 < 256; VAR_8 += 4 ){
	    sprintf(VAR_10 + VAR_9, ""%d"", VAR_8);
	    VAR_5 = dlsym(VAR_0, VAR_10);
	    VAR_4;
	    if( VAR_5 ) break;
	}
	if( VAR_5 ) goto found;
	VAR_10[VAR_9-1] = 'A';
	VAR_10[VAR_9++] = '@';
	for( VAR_8 = 0; VAR_8 < 256; VAR_8 += 4 ){
	    sprintf(VAR_10 + VAR_9, ""%d"", VAR_8);
	    VAR_5 = dlsym(VAR_0, VAR_10);
	    VAR_4;
	    if( VAR_5 ) break;
	}
      found:
	xfree(VAR_10);
    }
#endif
    if( !VAR_5 ){
	rb_raise(VAR_15, ""unknown symbol \""%""VAR_16""\"""", VAR_1);
    }

    return PTR2NUM(VAR_5);
}",ruby/339e11a7f178312d937b7c95dd3115ce7236597a/handle.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
 static VALUE
-fiddle_handle_sym(void *handle, const char *name)
+fiddle_handle_sym(void *handle, VALUE symbol)
 {
 #if defined(HAVE_DLERROR)
     const char *err;
@@ -8,6 +8,7 @@
 # define CHECK_DLERROR
 #endif
     void (*func)();
+    const char *name = SafeStringValueCStr(symbol);
 
     rb_secure(2);
 #ifdef HAVE_DLERROR
@@ -57,7 +58,7 @@
     }
 #endif
     if( !func ){
-	rb_raise(rb_eFiddleError, ""unknown symbol \""%s\"""", name);
+	rb_raise(rb_eFiddleError, ""unknown symbol \""%""PRIsVALUE""\"""", symbol);
     }
 
     return PTR2NUM(func);","{'deleted_lines': ['fiddle_handle_sym(void *handle, const char *name)', '\trb_raise(rb_eFiddleError, ""unknown symbol \\""%s\\"""", name);'], 'added_lines': ['fiddle_handle_sym(void *handle, VALUE symbol)', '    const char *name = SafeStringValueCStr(symbol);', '\trb_raise(rb_eFiddleError, ""unknown symbol \\""%""PRIsVALUE""\\"""", symbol);']}",True,"The Fiddle::Handle implementation in ext/fiddle/handle.c in Ruby before 2.0.0-p648, 2.1 before 2.1.8, and 2.2 before 2.2.4, as distributed in Apple OS X before 10.11.4 and other products, mishandles tainting, which allows context-dependent attackers to execute arbitrary code or cause a denial of service (application crash) via a crafted string, related to the DL module and the libffi library.  NOTE: this vulnerability exists because of a CVE-2009-5147 regression.",8.4,HIGH,2,test,2015-12-16T12:15:26Z,1
CVE-2015-7551,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,ruby,"merge revision(s): 53153 and 23405@ruby_1_9_1

	* ext/fiddle/handle.c: check tainted string arguments.
	  Patch provided by tenderlove and nobu.

	* test/fiddle/test_handle.rb (class TestHandle): add test for above.

	* ext/dl/handle.c (rb_dlhandle_initialize): prohibits DL::dlopen
	  with a tainted name of library.
	  Patch by sheepman <sheepman AT sheepman.sakura.ne.jp>.

	* ext/dl/handle.c (rb_dlhandle_sym): ditto



git-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_2_1@53156 b2dd03c8-39d4-4d8f-98ff-823fe69b080e",339e11a7f178312d937b7c95dd3115ce7236597a,https://github.com/ruby/ruby/commit/339e11a7f178312d937b7c95dd3115ce7236597a,ext/fiddle/handle.c,rb_fiddle_handle_sym,"static VALUE
rb_fiddle_handle_sym(VALUE self, VALUE sym)
{
struct dl_handle *fiddle_handle;
TypedData_Get_Struct(self, struct dl_handle, &fiddle_handle_data_type, fiddle_handle);
if( ! fiddle_handle->open ){
rb_raise(rb_eFiddleError, ""closed handle"");
}
return fiddle_handle_sym(fiddle_handle->ptr, StringValueCStr(sym));
}","static VALUE
rb_fiddle_handle_sym(VALUE VAR_0, VALUE VAR_1)
{
struct dl_handle *VAR_2;
TypedData_Get_Struct(VAR_0, struct dl_handle, &VAR_3, VAR_2);
if( ! VAR_2->open ){
rb_raise(VAR_4, ""closed handle"");
}
return fiddle_handle_sym(VAR_2->ptr, StringValueCStr(VAR_1));
}",ruby/339e11a7f178312d937b7c95dd3115ce7236597a/handle.c/vul/before/2.json,"static VALUE
rb_fiddle_handle_sym(VALUE self, VALUE sym)
{
    struct dl_handle *fiddle_handle;

    TypedData_Get_Struct(self, struct dl_handle, &fiddle_handle_data_type, fiddle_handle);
    if( ! fiddle_handle->open ){
	rb_raise(rb_eFiddleError, ""closed handle"");
    }

    return fiddle_handle_sym(fiddle_handle->ptr, sym);
}","static VALUE
rb_fiddle_handle_sym(VALUE VAR_0, VALUE VAR_1)
{
    struct dl_handle *VAR_2;

    TypedData_Get_Struct(VAR_0, struct dl_handle, &VAR_3, VAR_2);
    if( ! VAR_2->open ){
	rb_raise(VAR_4, ""closed handle"");
    }

    return fiddle_handle_sym(VAR_2->ptr, VAR_1);
}",ruby/339e11a7f178312d937b7c95dd3115ce7236597a/handle.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -8,5 +8,5 @@
 	rb_raise(rb_eFiddleError, ""closed handle"");
     }
 
-    return fiddle_handle_sym(fiddle_handle->ptr, StringValueCStr(sym));
+    return fiddle_handle_sym(fiddle_handle->ptr, sym);
 }","{'deleted_lines': ['    return fiddle_handle_sym(fiddle_handle->ptr, StringValueCStr(sym));'], 'added_lines': ['    return fiddle_handle_sym(fiddle_handle->ptr, sym);']}",True,"The Fiddle::Handle implementation in ext/fiddle/handle.c in Ruby before 2.0.0-p648, 2.1 before 2.1.8, and 2.2 before 2.2.4, as distributed in Apple OS X before 10.11.4 and other products, mishandles tainting, which allows context-dependent attackers to execute arbitrary code or cause a denial of service (application crash) via a crafted string, related to the DL module and the libffi library.  NOTE: this vulnerability exists because of a CVE-2009-5147 regression.",8.4,HIGH,2,test,2015-12-16T12:15:26Z,1
CVE-2015-7551,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,ruby,"merge revision(s): 53153 and 23405@ruby_1_9_1

	* ext/fiddle/handle.c: check tainted string arguments.
	  Patch provided by tenderlove and nobu.

	* test/fiddle/test_handle.rb (class TestHandle): add test for above.

	* ext/dl/handle.c (rb_dlhandle_initialize): prohibits DL::dlopen
	  with a tainted name of library.
	  Patch by sheepman <sheepman AT sheepman.sakura.ne.jp>.

	* ext/dl/handle.c (rb_dlhandle_sym): ditto



git-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_2_1@53156 b2dd03c8-39d4-4d8f-98ff-823fe69b080e",339e11a7f178312d937b7c95dd3115ce7236597a,https://github.com/ruby/ruby/commit/339e11a7f178312d937b7c95dd3115ce7236597a,ext/fiddle/handle.c,rb_fiddle_handle_s_sym,"static VALUE
rb_fiddle_handle_s_sym(VALUE self, VALUE sym)
{
return fiddle_handle_sym(RTLD_NEXT, StringValueCStr(sym));
}","static VALUE
rb_fiddle_handle_s_sym(VALUE VAR_0, VALUE VAR_1)
{
return fiddle_handle_sym(VAR_2, StringValueCStr(VAR_1));
}",ruby/339e11a7f178312d937b7c95dd3115ce7236597a/handle.c/vul/before/0.json,"static VALUE
rb_fiddle_handle_s_sym(VALUE self, VALUE sym)
{
    return fiddle_handle_sym(RTLD_NEXT, sym);
}","static VALUE
rb_fiddle_handle_s_sym(VALUE VAR_0, VALUE VAR_1)
{
    return fiddle_handle_sym(VAR_2, VAR_1);
}",ruby/339e11a7f178312d937b7c95dd3115ce7236597a/handle.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
 static VALUE
 rb_fiddle_handle_s_sym(VALUE self, VALUE sym)
 {
-    return fiddle_handle_sym(RTLD_NEXT, StringValueCStr(sym));
+    return fiddle_handle_sym(RTLD_NEXT, sym);
 }","{'deleted_lines': ['    return fiddle_handle_sym(RTLD_NEXT, StringValueCStr(sym));'], 'added_lines': ['    return fiddle_handle_sym(RTLD_NEXT, sym);']}",True,"The Fiddle::Handle implementation in ext/fiddle/handle.c in Ruby before 2.0.0-p648, 2.1 before 2.1.8, and 2.2 before 2.2.4, as distributed in Apple OS X before 10.11.4 and other products, mishandles tainting, which allows context-dependent attackers to execute arbitrary code or cause a denial of service (application crash) via a crafted string, related to the DL module and the libffi library.  NOTE: this vulnerability exists because of a CVE-2009-5147 regression.",8.4,HIGH,2,test,2015-12-16T12:15:26Z,1
CVE-2015-7551,['CWE-20'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,ruby,"merge revision(s): 53153 and 23405@ruby_1_9_1

	* ext/fiddle/handle.c: check tainted string arguments.
	  Patch provided by tenderlove and nobu.

	* test/fiddle/test_handle.rb (class TestHandle): add test for above.

	* ext/dl/handle.c (rb_dlhandle_initialize): prohibits DL::dlopen
	  with a tainted name of library.
	  Patch by sheepman <sheepman AT sheepman.sakura.ne.jp>.

	* ext/dl/handle.c (rb_dlhandle_sym): ditto



git-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_2_1@53156 b2dd03c8-39d4-4d8f-98ff-823fe69b080e",339e11a7f178312d937b7c95dd3115ce7236597a,https://github.com/ruby/ruby/commit/339e11a7f178312d937b7c95dd3115ce7236597a,ext/fiddle/handle.c,rb_fiddle_handle_initialize,"static VALUE
rb_fiddle_handle_initialize(int argc, VALUE argv[], VALUE self)
{
void *ptr;
struct dl_handle *fiddle_handle;
VALUE lib, flag;
char  *clib;
int   cflag;
const char *err;
switch( rb_scan_args(argc, argv, ""02"", &lib, &flag) ){
case 0:
clib = NULL;
cflag = RTLD_LAZY | RTLD_GLOBAL;
break;
case 1:
clib = NIL_P(lib) ? NULL : StringValuePtr(lib);
cflag = RTLD_LAZY | RTLD_GLOBAL;
break;
case 2:
clib = NIL_P(lib) ? NULL : StringValuePtr(lib);
cflag = NUM2INT(flag);
break;
default:
rb_bug(""rb_fiddle_handle_new"");
}
rb_secure(2);
#if defined(_WIN32)
if( !clib ){
HANDLE rb_libruby_handle(void);
ptr = rb_libruby_handle();
}
else if( STRCASECMP(clib, ""libc"") == 0
# ifdef RUBY_COREDLL
|| STRCASECMP(clib, RUBY_COREDLL) == 0
|| STRCASECMP(clib, RUBY_COREDLL"".dll"") == 0
# endif
){
# ifdef _WIN32_WCE
ptr = dlopen(""coredll.dll"", cflag);
# else
ptr = w32_coredll();
# endif
}
else
#endif
ptr = dlopen(clib, cflag);
#if defined(HAVE_DLERROR)
if( !ptr && (err = dlerror()) ){
rb_raise(rb_eFiddleError, ""%s"", err);
}
#else
if( !ptr ){
err = dlerror();
rb_raise(rb_eFiddleError, ""%s"", err);
}
#endif
TypedData_Get_Struct(self, struct dl_handle, &fiddle_handle_data_type, fiddle_handle);
if( fiddle_handle->ptr && fiddle_handle->open && fiddle_handle->enable_close ){
dlclose(fiddle_handle->ptr);
}
fiddle_handle->ptr = ptr;
fiddle_handle->open = 1;
fiddle_handle->enable_close = 0;
if( rb_block_given_p() ){
rb_ensure(rb_yield, self, rb_fiddle_handle_close, self);
}
return Qnil;
}","static VALUE
rb_fiddle_handle_initialize(int VAR_0, VALUE VAR_1[], VALUE VAR_2)
{
void *VAR_3;
struct dl_handle *VAR_4;
VALUE VAR_5, VAR_6;
char  *VAR_7;
int   VAR_8;
const char *VAR_9;
switch( rb_scan_args(VAR_0, VAR_1, ""02"", &VAR_5, &VAR_6) ){
case 0:
VAR_7 = NULL;
VAR_8 = VAR_10 | VAR_11;
break;
case 1:
VAR_7 = NIL_P(VAR_5) ? NULL : StringValuePtr(VAR_5);
VAR_8 = VAR_10 | VAR_11;
break;
case 2:
VAR_7 = NIL_P(VAR_5) ? NULL : StringValuePtr(VAR_5);
VAR_8 = NUM2INT(VAR_6);
break;
default:
rb_bug(""rb_fiddle_handle_new"");
}
rb_secure(2);
#if defined(VAR_12)
if( !VAR_7 ){
HANDLE rb_libruby_handle(void);
VAR_3 = rb_libruby_handle();
}
else if( STRCASECMP(VAR_7, ""libc"") == 0
# ifdef VAR_13
|| STRCASECMP(VAR_7, VAR_13) == 0
|| STRCASECMP(VAR_7, VAR_13"".dll"") == 0
# endif
){
# ifdef VAR_14
VAR_3 = dlopen(""coredll.dll"", VAR_8);
# else
VAR_3 = w32_coredll();
# endif
}
else
#endif
VAR_3 = dlopen(VAR_7, VAR_8);
#if defined(VAR_15)
if( !VAR_3 && (VAR_9 = dlerror()) ){
rb_raise(VAR_16, ""%s"", VAR_9);
}
#else
if( !VAR_3 ){
VAR_9 = dlerror();
rb_raise(VAR_16, ""%s"", VAR_9);
}
#endif
TypedData_Get_Struct(VAR_2, struct dl_handle, &VAR_17, VAR_4);
if( VAR_4->ptr && VAR_4->open && VAR_4->enable_close ){
dlclose(VAR_4->ptr);
}
VAR_4->ptr = VAR_3;
VAR_4->open = 1;
VAR_4->enable_close = 0;
if( rb_block_given_p() ){
rb_ensure(VAR_18, VAR_2, VAR_19, VAR_2);
}
return VAR_20;
}",ruby/339e11a7f178312d937b7c95dd3115ce7236597a/handle.c/vul/before/1.json,"static VALUE
rb_fiddle_handle_initialize(int argc, VALUE argv[], VALUE self)
{
    void *ptr;
    struct dl_handle *fiddle_handle;
    VALUE lib, flag;
    char  *clib;
    int   cflag;
    const char *err;

    switch( rb_scan_args(argc, argv, ""02"", &lib, &flag) ){
      case 0:
	clib = NULL;
	cflag = RTLD_LAZY | RTLD_GLOBAL;
	break;
      case 1:
	clib = NIL_P(lib) ? NULL : SafeStringValueCStr(lib);
	cflag = RTLD_LAZY | RTLD_GLOBAL;
	break;
      case 2:
	clib = NIL_P(lib) ? NULL : SafeStringValueCStr(lib);
	cflag = NUM2INT(flag);
	break;
      default:
	rb_bug(""rb_fiddle_handle_new"");
    }

    rb_secure(2);

#if defined(_WIN32)
    if( !clib ){
	HANDLE rb_libruby_handle(void);
	ptr = rb_libruby_handle();
    }
    else if( STRCASECMP(clib, ""libc"") == 0
# ifdef RUBY_COREDLL
	     || STRCASECMP(clib, RUBY_COREDLL) == 0
	     || STRCASECMP(clib, RUBY_COREDLL"".dll"") == 0
# endif
	){
# ifdef _WIN32_WCE
	ptr = dlopen(""coredll.dll"", cflag);
# else
	ptr = w32_coredll();
# endif
    }
    else
#endif
	ptr = dlopen(clib, cflag);
#if defined(HAVE_DLERROR)
    if( !ptr && (err = dlerror()) ){
	rb_raise(rb_eFiddleError, ""%s"", err);
    }
#else
    if( !ptr ){
	err = dlerror();
	rb_raise(rb_eFiddleError, ""%s"", err);
    }
#endif
    TypedData_Get_Struct(self, struct dl_handle, &fiddle_handle_data_type, fiddle_handle);
    if( fiddle_handle->ptr && fiddle_handle->open && fiddle_handle->enable_close ){
	dlclose(fiddle_handle->ptr);
    }
    fiddle_handle->ptr = ptr;
    fiddle_handle->open = 1;
    fiddle_handle->enable_close = 0;

    if( rb_block_given_p() ){
	rb_ensure(rb_yield, self, rb_fiddle_handle_close, self);
    }

    return Qnil;
}","static VALUE
rb_fiddle_handle_initialize(int VAR_0, VALUE VAR_1[], VALUE VAR_2)
{
    void *VAR_3;
    struct dl_handle *VAR_4;
    VALUE VAR_5, VAR_6;
    char  *VAR_7;
    int   VAR_8;
    const char *VAR_9;

    switch( rb_scan_args(VAR_0, VAR_1, ""02"", &VAR_5, &VAR_6) ){
      case 0:
	VAR_7 = NULL;
	VAR_8 = VAR_10 | VAR_11;
	break;
      case 1:
	VAR_7 = NIL_P(VAR_5) ? NULL : SafeStringValueCStr(VAR_5);
	VAR_8 = VAR_10 | VAR_11;
	break;
      case 2:
	VAR_7 = NIL_P(VAR_5) ? NULL : SafeStringValueCStr(VAR_5);
	VAR_8 = NUM2INT(VAR_6);
	break;
      default:
	rb_bug(""rb_fiddle_handle_new"");
    }

    rb_secure(2);

#if defined(VAR_12)
    if( !VAR_7 ){
	HANDLE rb_libruby_handle(void);
	VAR_3 = rb_libruby_handle();
    }
    else if( STRCASECMP(VAR_7, ""libc"") == 0
# ifdef VAR_13
	     || STRCASECMP(VAR_7, VAR_13) == 0
	     || STRCASECMP(VAR_7, VAR_13"".dll"") == 0
# endif
	){
# ifdef VAR_14
	VAR_3 = dlopen(""coredll.dll"", VAR_8);
# else
	VAR_3 = w32_coredll();
# endif
    }
    else
#endif
	VAR_3 = dlopen(VAR_7, VAR_8);
#if defined(VAR_15)
    if( !VAR_3 && (VAR_9 = dlerror()) ){
	rb_raise(VAR_16, ""%s"", VAR_9);
    }
#else
    if( !VAR_3 ){
	VAR_9 = dlerror();
	rb_raise(VAR_16, ""%s"", VAR_9);
    }
#endif
    TypedData_Get_Struct(VAR_2, struct dl_handle, &VAR_17, VAR_4);
    if( VAR_4->ptr && VAR_4->open && VAR_4->enable_close ){
	dlclose(VAR_4->ptr);
    }
    VAR_4->ptr = VAR_3;
    VAR_4->open = 1;
    VAR_4->enable_close = 0;

    if( rb_block_given_p() ){
	rb_ensure(VAR_18, VAR_2, VAR_19, VAR_2);
    }

    return VAR_20;
}",ruby/339e11a7f178312d937b7c95dd3115ce7236597a/handle.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -14,11 +14,11 @@
 	cflag = RTLD_LAZY | RTLD_GLOBAL;
 	break;
       case 1:
-	clib = NIL_P(lib) ? NULL : StringValuePtr(lib);
+	clib = NIL_P(lib) ? NULL : SafeStringValueCStr(lib);
 	cflag = RTLD_LAZY | RTLD_GLOBAL;
 	break;
       case 2:
-	clib = NIL_P(lib) ? NULL : StringValuePtr(lib);
+	clib = NIL_P(lib) ? NULL : SafeStringValueCStr(lib);
 	cflag = NUM2INT(flag);
 	break;
       default:","{'deleted_lines': ['\tclib = NIL_P(lib) ? NULL : StringValuePtr(lib);', '\tclib = NIL_P(lib) ? NULL : StringValuePtr(lib);'], 'added_lines': ['\tclib = NIL_P(lib) ? NULL : SafeStringValueCStr(lib);', '\tclib = NIL_P(lib) ? NULL : SafeStringValueCStr(lib);']}",True,"The Fiddle::Handle implementation in ext/fiddle/handle.c in Ruby before 2.0.0-p648, 2.1 before 2.1.8, and 2.2 before 2.2.4, as distributed in Apple OS X before 10.11.4 and other products, mishandles tainting, which allows context-dependent attackers to execute arbitrary code or cause a denial of service (application crash) via a crafted string, related to the DL module and the libffi library.  NOTE: this vulnerability exists because of a CVE-2009-5147 regression.",8.4,HIGH,2,test,2015-12-16T12:15:26Z,1
CVE-2015-8724,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"[airpdcap] check the length of the WPA broadcast key we calculated

return an error if our key is shorter than the key type required for the
encryption method we detected

this check prevents an out-of-bounds memory access when the key is copied

Bug: 11826
Change-Id: Ic779b5d87aa97a3b2d2b2c92ce12d0fff4a85adc
Reviewed-on: https://code.wireshark.org/review/12743
Petri-Dish: Michael Mann <mmann78@netscape.net>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Michael Mann <mmann78@netscape.net>",83f2818118ae255db949bb3a4b3a26ebd1c5f7c5,https://github.com/wireshark/wireshark/commit/83f2818118ae255db949bb3a4b3a26ebd1c5f7c5,epan/crypt/airpdcap.c,AirPDcapDecryptWPABroadcastKey,"static INT
AirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *pEAPKey, guint8  *decryption_key, PAIRPDCAP_SEC_ASSOCIATION sa, gboolean group_hshake)
{
guint8 key_version;
guint8  *szEncryptedKey;
guint16 key_bytes_len = 0; 
guint16 key_len;           
static AIRPDCAP_KEY_ITEM dummy_key; 
AIRPDCAP_SEC_ASSOCIATION *tmp_sa;
key_version = AIRPDCAP_EAP_KEY_DESCR_VER(pEAPKey->key_information[1]);
if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){
key_bytes_len = pntoh16(pEAPKey->key_length);
}else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){
key_bytes_len = pntoh16(pEAPKey->key_data_len);
if (key_bytes_len < 16) {
return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
}
}
if (key_bytes_len > TKIP_GROUP_KEYBYTES_LEN_MAX || key_bytes_len == 0) { 
return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
}
szEncryptedKey = (guint8 *)wmem_memdup(wmem_packet_scope(), pEAPKey->ie, key_bytes_len);
DEBUG_DUMP(""Encrypted Broadcast key:"", szEncryptedKey, key_bytes_len);
DEBUG_DUMP(""KeyIV:"", pEAPKey->key_iv, 16);
DEBUG_DUMP(""decryption_key:"", decryption_key, 16);
tmp_sa=(AIRPDCAP_SEC_ASSOCIATION *)g_malloc(sizeof(AIRPDCAP_SEC_ASSOCIATION));
memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));
sa->next=tmp_sa;
if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){
guint8 new_key[32];
guint8 dummy[256];
rc4_state_struct rc4_state;
sa->wpa.key_ver = (key_bytes_len >=TKIP_GROUP_KEY_LEN)?AIRPDCAP_WPA_KEY_VER_NOT_CCMP:AIRPDCAP_WPA_KEY_VER_AES_CCMP;
memcpy(new_key, pEAPKey->key_iv, 16);
memcpy(new_key+16, decryption_key, 16);
DEBUG_DUMP(""FullDecrKey:"", new_key, 32);
crypt_rc4_init(&rc4_state, new_key, sizeof(new_key));
crypt_rc4(&rc4_state, dummy, 256);
crypt_rc4(&rc4_state, szEncryptedKey, key_bytes_len);
} else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){
guint8 key_found;
guint16 key_index;
guint8 *decrypted_data;
if (group_hshake)
sa->wpa.key_ver = (key_bytes_len >= (TKIP_GROUP_KEYBYTES_LEN_GKEY))?AIRPDCAP_WPA_KEY_VER_NOT_CCMP:AIRPDCAP_WPA_KEY_VER_AES_CCMP;
else
sa->wpa.key_ver = (key_bytes_len >= (TKIP_GROUP_KEYBYTES_LEN))?AIRPDCAP_WPA_KEY_VER_NOT_CCMP:AIRPDCAP_WPA_KEY_VER_AES_CCMP;
decrypted_data = AES_unwrap(decryption_key, 16, szEncryptedKey,  key_bytes_len);
key_found = FALSE;
key_index = 0;
while(key_index < key_bytes_len && !key_found){
guint8 rsn_id;
rsn_id = decrypted_data[key_index];
if (rsn_id != 0xdd){
if (key_index+1 >= key_bytes_len){
return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
}
key_index += decrypted_data[key_index+1]+2;
}else{
key_found = TRUE;
}
}
if (key_found){
if (key_index+8 >= key_bytes_len)
return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
memcpy(szEncryptedKey, decrypted_data+key_index+8, key_bytes_len-key_index-8);
}
g_free(decrypted_data);
}
key_len = (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)?TKIP_GROUP_KEY_LEN:CCMP_GROUP_KEY_LEN;
DEBUG_DUMP(""Broadcast key:"", szEncryptedKey, key_len);
sa->key = &dummy_key;  
sa->validKey = TRUE;
memset(sa->wpa.ptk, 0, sizeof(sa->wpa.ptk));
memcpy(sa->wpa.ptk+32, szEncryptedKey, key_len);
return AIRPDCAP_RET_SUCCESS_HANDSHAKE;
}","static INT
AirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *VAR_0, guint8  *VAR_1, PAIRPDCAP_SEC_ASSOCIATION VAR_2, gboolean VAR_3)
{
guint8 VAR_4;
guint8  *VAR_5;
guint16 VAR_6 = 0; 
guint16 VAR_7;           
static AIRPDCAP_KEY_ITEM VAR_8; 
AIRPDCAP_SEC_ASSOCIATION *VAR_9;
VAR_4 = AIRPDCAP_EAP_KEY_DESCR_VER(VAR_0->key_information[1]);
if (VAR_4 == VAR_10){
VAR_6 = pntoh16(VAR_0->key_length);
}else if (VAR_4 == VAR_11){
VAR_6 = pntoh16(VAR_0->key_data_len);
if (VAR_6 < 16) {
return VAR_12;
}
}
if (VAR_6 > VAR_13 || VAR_6 == 0) { 
return VAR_12;
}
VAR_5 = (guint8 *)wmem_memdup(wmem_packet_scope(), VAR_0->ie, VAR_6);
DEBUG_DUMP(""Encrypted Broadcast key:"", VAR_5, VAR_6);
DEBUG_DUMP(""KeyIV:"", VAR_0->key_iv, 16);
DEBUG_DUMP(""decryption_key:"", VAR_1, 16);
VAR_9=(AIRPDCAP_SEC_ASSOCIATION *)g_malloc(sizeof(AIRPDCAP_SEC_ASSOCIATION));
memcpy(VAR_9, VAR_2, sizeof(AIRPDCAP_SEC_ASSOCIATION));
VAR_2->next=VAR_9;
if (VAR_4 == VAR_10){
guint8 VAR_14[32];
guint8 VAR_15[256];
rc4_state_struct VAR_16;
VAR_2->wpa.key_ver = (VAR_6 >=VAR_17)?VAR_10:VAR_11;
memcpy(VAR_14, VAR_0->key_iv, 16);
memcpy(VAR_14+16, VAR_1, 16);
DEBUG_DUMP(""FullDecrKey:"", VAR_14, 32);
crypt_rc4_init(&VAR_16, VAR_14, sizeof(VAR_14));
crypt_rc4(&VAR_16, VAR_15, 256);
crypt_rc4(&VAR_16, VAR_5, VAR_6);
} else if (VAR_4 == VAR_11){
guint8 VAR_18;
guint16 VAR_19;
guint8 *VAR_20;
if (VAR_3)
VAR_2->wpa.key_ver = (VAR_6 >= (VAR_21))?VAR_10:VAR_11;
else
VAR_2->wpa.key_ver = (VAR_6 >= (VAR_22))?VAR_10:VAR_11;
VAR_20 = AES_unwrap(VAR_1, 16, VAR_5,  VAR_6);
VAR_18 = FALSE;
VAR_19 = 0;
while(VAR_19 < VAR_6 && !VAR_18){
guint8 VAR_23;
VAR_23 = VAR_20[VAR_19];
if (VAR_23 != 0xdd){
if (VAR_19+1 >= VAR_6){
return VAR_12;
}
VAR_19 += VAR_20[VAR_19+1]+2;
}else{
VAR_18 = TRUE;
}
}
if (VAR_18){
if (VAR_19+8 >= VAR_6)
return VAR_12;
memcpy(VAR_5, VAR_20+VAR_19+8, VAR_6-VAR_19-8);
}
g_free(VAR_20);
}
VAR_7 = (VAR_2->wpa.key_ver==VAR_10)?VAR_17:VAR_24;
DEBUG_DUMP(""Broadcast key:"", VAR_5, VAR_7);
VAR_2->key = &VAR_8;  
VAR_2->validKey = TRUE;
memset(VAR_2->wpa.ptk, 0, sizeof(VAR_2->wpa.ptk));
memcpy(VAR_2->wpa.ptk+32, VAR_5, VAR_7);
return VAR_25;
}",wireshark/83f2818118ae255db949bb3a4b3a26ebd1c5f7c5/airpdcap.c/vul/before/0.json,"static INT
AirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *pEAPKey, guint8  *decryption_key, PAIRPDCAP_SEC_ASSOCIATION sa, gboolean group_hshake)
{
    guint8 key_version;
    guint8  *szEncryptedKey;
    guint16 key_bytes_len = 0; /* Length of the total key data field */
    guint16 key_len;           /* Actual group key length */
    static AIRPDCAP_KEY_ITEM dummy_key; /* needed in case AirPDcapRsnaMng() wants the key structure */
    AIRPDCAP_SEC_ASSOCIATION *tmp_sa;

    /* We skip verifying the MIC of the key. If we were implementing a WPA supplicant we'd want to verify, but for a sniffer it's not needed. */

    /* Preparation for decrypting the group key -  determine group key data length */
    /* depending on whether the pairwise key is TKIP or AES encryption key */
    key_version = AIRPDCAP_EAP_KEY_DESCR_VER(pEAPKey->key_information[1]);
    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){
        /* TKIP */
        key_bytes_len = pntoh16(pEAPKey->key_length);
    }else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){
        /* AES */
        key_bytes_len = pntoh16(pEAPKey->key_data_len);

        /* AES keys must be at least 128 bits = 16 bytes. */
        if (key_bytes_len < 16) {
            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
        }
    }

    if (key_bytes_len > TKIP_GROUP_KEYBYTES_LEN_MAX || key_bytes_len == 0) { /* Don't read past the end of pEAPKey->ie */
        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
    }

    /* Encrypted key is in the information element field of the EAPOL key packet */
    szEncryptedKey = (guint8 *)wmem_memdup(wmem_packet_scope(), pEAPKey->ie, key_bytes_len);

    DEBUG_DUMP(""Encrypted Broadcast key:"", szEncryptedKey, key_bytes_len);
    DEBUG_DUMP(""KeyIV:"", pEAPKey->key_iv, 16);
    DEBUG_DUMP(""decryption_key:"", decryption_key, 16);

    /* We are rekeying, save old sa */
    tmp_sa=(AIRPDCAP_SEC_ASSOCIATION *)g_malloc(sizeof(AIRPDCAP_SEC_ASSOCIATION));
    memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));
    sa->next=tmp_sa;

    /* As we have no concept of the prior association request at this point, we need to deduce the     */
    /* group key cipher from the length of the key bytes. In WPA this is straightforward as the        */
    /* keybytes just contain the GTK, and the GTK is only in the group handshake, NOT the M3.          */
    /* In WPA2 its a little more tricky as the M3 keybytes contain an RSN_IE, but the group handshake  */
    /* does not. Also there are other (variable length) items in the keybytes which we need to account */
    /* for to determine the true key length, and thus the group cipher.                                */

    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){
        guint8 new_key[32];
        guint8 dummy[256];
        /* TKIP key */
        /* Per 802.11i, Draft 3.0 spec, section 8.5.2, p. 97, line 4-8, */
        /* group key is decrypted using RC4.  Concatenate the IV with the 16 byte EK (PTK+16) to get the decryption key */

        rc4_state_struct rc4_state;

        /* The WPA group key just contains the GTK bytes so deducing the type is straightforward   */
        /* Note - WPA M3 doesn't contain a group key so we'll only be here for the group handshake */
        sa->wpa.key_ver = (key_bytes_len >=TKIP_GROUP_KEY_LEN)?AIRPDCAP_WPA_KEY_VER_NOT_CCMP:AIRPDCAP_WPA_KEY_VER_AES_CCMP;

        /* Build the full decryption key based on the IV and part of the pairwise key */
        memcpy(new_key, pEAPKey->key_iv, 16);
        memcpy(new_key+16, decryption_key, 16);
        DEBUG_DUMP(""FullDecrKey:"", new_key, 32);

        crypt_rc4_init(&rc4_state, new_key, sizeof(new_key));

        /* Do dummy 256 iterations of the RC4 algorithm (per 802.11i, Draft 3.0, p. 97 line 6) */
        crypt_rc4(&rc4_state, dummy, 256);
        crypt_rc4(&rc4_state, szEncryptedKey, key_bytes_len);

    } else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){
        /* AES CCMP key */

        guint8 key_found;
        guint16 key_index;
        guint8 *decrypted_data;

        /* If this EAPOL frame is part of a separate group key handshake then this contains no    */
        /* RSN IE, so we can deduct that from the calculation.                                    */
        if (group_hshake)
            sa->wpa.key_ver = (key_bytes_len >= (TKIP_GROUP_KEYBYTES_LEN_GKEY))?AIRPDCAP_WPA_KEY_VER_NOT_CCMP:AIRPDCAP_WPA_KEY_VER_AES_CCMP;
        else
            sa->wpa.key_ver = (key_bytes_len >= (TKIP_GROUP_KEYBYTES_LEN))?AIRPDCAP_WPA_KEY_VER_NOT_CCMP:AIRPDCAP_WPA_KEY_VER_AES_CCMP;

        /* Unwrap the key; the result is key_bytes_len in length */
        decrypted_data = AES_unwrap(decryption_key, 16, szEncryptedKey,  key_bytes_len);

        /* With WPA2 what we get after Broadcast Key decryption is an actual RSN structure.
           The key itself is stored as a GTK KDE
           WPA2 IE (1 byte) id = 0xdd, length (1 byte), GTK OUI (4 bytes), key index (1 byte) and 1 reserved byte. Thus we have to
           pass pointer to the actual key with 8 bytes offset */

        key_found = FALSE;
        key_index = 0;
        while(key_index < key_bytes_len && !key_found){
            guint8 rsn_id;

            /* Get RSN ID */
            rsn_id = decrypted_data[key_index];

            if (rsn_id != 0xdd){
                if (key_index+1 >= key_bytes_len){
                    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
                }
                key_index += decrypted_data[key_index+1]+2;
            }else{
                key_found = TRUE;
            }
        }

        if (key_found){
            if (key_index+8 >= key_bytes_len)
                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;

            /* Skip over the GTK header info, and don't copy past the end of the encrypted data */
            memcpy(szEncryptedKey, decrypted_data+key_index+8, key_bytes_len-key_index-8);
        }

        g_free(decrypted_data);
    }

    key_len = (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)?TKIP_GROUP_KEY_LEN:CCMP_GROUP_KEY_LEN;
    if (key_len > key_bytes_len) {
        /* the key required for this protocol is longer than the key that we just calculated */
        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
    }

    /* Decrypted key is now in szEncryptedKey with len of key_len */
    DEBUG_DUMP(""Broadcast key:"", szEncryptedKey, key_len);

    /* Load the proper key material info into the SA */
    sa->key = &dummy_key;  /* we just need key to be not null because it is checked in AirPDcapRsnaMng().  The WPA key materials are actually in the .wpa structure */
    sa->validKey = TRUE;

    /* Since this is a GTK and its size is only 32 bytes (vs. the 64 byte size of a PTK), we fake it and put it in at a 32-byte offset so the  */
    /* AirPDcapRsnaMng() function will extract the right piece of the GTK for decryption. (The first 16 bytes of the GTK are used for decryption.) */
    memset(sa->wpa.ptk, 0, sizeof(sa->wpa.ptk));
    memcpy(sa->wpa.ptk+32, szEncryptedKey, key_len);
    return AIRPDCAP_RET_SUCCESS_HANDSHAKE;
}","static INT
AirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *VAR_0, guint8  *VAR_1, PAIRPDCAP_SEC_ASSOCIATION VAR_2, gboolean VAR_3)
{
    guint8 VAR_4;
    guint8  *VAR_5;
    guint16 VAR_6 = 0; /* COMMENT_0 */
    guint16 VAR_7;           /* COMMENT_1 */
    static AIRPDCAP_KEY_ITEM VAR_8; /* COMMENT_2 */
    AIRPDCAP_SEC_ASSOCIATION *VAR_9;

    /* COMMENT_3 */

    /* COMMENT_4 */
    /* COMMENT_5 */
    VAR_4 = AIRPDCAP_EAP_KEY_DESCR_VER(VAR_0->key_information[1]);
    if (VAR_4 == VAR_10){
        /* COMMENT_6 */
        VAR_6 = pntoh16(VAR_0->key_length);
    }else if (VAR_4 == VAR_11){
        /* COMMENT_7 */
        VAR_6 = pntoh16(VAR_0->key_data_len);

        /* COMMENT_8 */
        if (VAR_6 < 16) {
            return VAR_12;
        }
    }

    if (VAR_6 > VAR_13 || VAR_6 == 0) { /* COMMENT_9 */
        return VAR_12;
    }

    /* COMMENT_10 */
    VAR_5 = (guint8 *)wmem_memdup(wmem_packet_scope(), VAR_0->ie, VAR_6);

    DEBUG_DUMP(""Encrypted Broadcast key:"", VAR_5, VAR_6);
    DEBUG_DUMP(""KeyIV:"", VAR_0->key_iv, 16);
    DEBUG_DUMP(""decryption_key:"", VAR_1, 16);

    /* COMMENT_11 */
    VAR_9=(AIRPDCAP_SEC_ASSOCIATION *)g_malloc(sizeof(AIRPDCAP_SEC_ASSOCIATION));
    memcpy(VAR_9, VAR_2, sizeof(AIRPDCAP_SEC_ASSOCIATION));
    VAR_2->next=VAR_9;

    /* COMMENT_12 */
    /* COMMENT_13 */
    /* COMMENT_14 */
    /* COMMENT_15 */
    /* COMMENT_16 */
    /* COMMENT_17 */

    if (VAR_4 == VAR_10){
        guint8 VAR_14[32];
        guint8 VAR_15[256];
        /* COMMENT_18 */
        /* COMMENT_19 */
        /* COMMENT_20 */

        rc4_state_struct VAR_16;

        /* COMMENT_21 */
        /* COMMENT_22 */
        VAR_2->wpa.key_ver = (VAR_6 >=VAR_17)?VAR_10:VAR_11;

        /* COMMENT_23 */
        memcpy(VAR_14, VAR_0->key_iv, 16);
        memcpy(VAR_14+16, VAR_1, 16);
        DEBUG_DUMP(""FullDecrKey:"", VAR_14, 32);

        crypt_rc4_init(&VAR_16, VAR_14, sizeof(VAR_14));

        /* COMMENT_24 */
        crypt_rc4(&VAR_16, VAR_15, 256);
        crypt_rc4(&VAR_16, VAR_5, VAR_6);

    } else if (VAR_4 == VAR_11){
        /* COMMENT_25 */

        guint8 VAR_18;
        guint16 VAR_19;
        guint8 *VAR_20;

        /* COMMENT_26 */
        /* COMMENT_27 */
        if (VAR_3)
            VAR_2->wpa.key_ver = (VAR_6 >= (VAR_21))?VAR_10:VAR_11;
        else
            VAR_2->wpa.key_ver = (VAR_6 >= (VAR_22))?VAR_10:VAR_11;

        /* COMMENT_28 */
        VAR_20 = AES_unwrap(VAR_1, 16, VAR_5,  VAR_6);

        /* COMMENT_29 */
                                                
                                                                                                                                  
                                                                

        VAR_18 = FALSE;
        VAR_19 = 0;
        while(VAR_19 < VAR_6 && !VAR_18){
            guint8 VAR_23;

            /* COMMENT_33 */
            VAR_23 = VAR_20[VAR_19];

            if (VAR_23 != 0xdd){
                if (VAR_19+1 >= VAR_6){
                    return VAR_12;
                }
                VAR_19 += VAR_20[VAR_19+1]+2;
            }else{
                VAR_18 = TRUE;
            }
        }

        if (VAR_18){
            if (VAR_19+8 >= VAR_6)
                return VAR_12;

            /* COMMENT_34 */
            memcpy(VAR_5, VAR_20+VAR_19+8, VAR_6-VAR_19-8);
        }

        g_free(VAR_20);
    }

    VAR_7 = (VAR_2->wpa.key_ver==VAR_10)?VAR_17:VAR_24;
    if (VAR_7 > VAR_6) {
        /* COMMENT_35 */
        return VAR_12;
    }

    /* COMMENT_36 */
    DEBUG_DUMP(""Broadcast key:"", VAR_5, VAR_7);

    /* COMMENT_37 */
    VAR_2->key = &VAR_8;  /* COMMENT_38 */
    VAR_2->validKey = TRUE;

    /* COMMENT_39 */
    /* COMMENT_40 */
    memset(VAR_2->wpa.ptk, 0, sizeof(VAR_2->wpa.ptk));
    memcpy(VAR_2->wpa.ptk+32, VAR_5, VAR_7);
    return VAR_25;
}",wireshark/83f2818118ae255db949bb3a4b3a26ebd1c5f7c5/airpdcap.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -125,6 +125,10 @@
     }
 
     key_len = (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)?TKIP_GROUP_KEY_LEN:CCMP_GROUP_KEY_LEN;
+    if (key_len > key_bytes_len) {
+        /* the key required for this protocol is longer than the key that we just calculated */
+        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
+    }
 
     /* Decrypted key is now in szEncryptedKey with len of key_len */
     DEBUG_DUMP(""Broadcast key:"", szEncryptedKey, key_len);","{'deleted_lines': [], 'added_lines': ['    if (key_len > key_bytes_len) {', '        /* the key required for this protocol is longer than the key that we just calculated */', '        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;', '    }']}",True,"The AirPDcapDecryptWPABroadcastKey function in epan/crypt/airpdcap.c in the 802.11 dissector in Wireshark 1.12.x before 1.12.9 and 2.0.x before 2.0.1 does not verify the WPA broadcast key length, which allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted packet.",5.5,MEDIUM,1,test,2015-12-20T14:47:28Z,1
CVE-2016-7539,['CWE-399'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,ImageMagick,http://www.imagemagick.org/discourse-server/viewtopic.php?f=2&t=28946,4e81ce8b07219c69a9aeccb0f7f7b927ca6db74c,https://github.com/ImageMagick/ImageMagick/commit/4e81ce8b07219c69a9aeccb0f7f7b927ca6db74c,magick/cache.c,OpenPixelCache,"static MagickBooleanType OpenPixelCache(Image *image,const MapMode mode,
ExceptionInfo *exception)
{
CacheInfo
*magick_restrict cache_info,
source_info;
char
format[MaxTextExtent],
message[MaxTextExtent];
const char
*type;
MagickSizeType
length,
number_pixels;
MagickStatusType
status;
size_t
columns,
packet_size;
assert(image != (const Image *) NULL);
assert(image->signature == MagickSignature);
assert(image->cache != (Cache) NULL);
if (image->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
if ((image->columns == 0) || (image->rows == 0))
ThrowBinaryException(CacheError,""NoPixelsDefinedInCache"",image->filename);
cache_info=(CacheInfo *) image->cache;
assert(cache_info->signature == MagickSignature);
if ((AcquireMagickResource(WidthResource,image->columns) == MagickFalse) ||
(AcquireMagickResource(HeightResource,image->rows) == MagickFalse))
ThrowBinaryException(ResourceLimitError,""PixelCacheAllocationFailed"",
image->filename);
source_info=(*cache_info);
source_info.file=(-1);
(void) FormatLocaleString(cache_info->filename,MaxTextExtent,""%s[%.20g]"",
image->filename,(double) GetImageIndexInList(image));
cache_info->mode=mode;
cache_info->rows=image->rows;
cache_info->columns=image->columns;
cache_info->channels=image->channels;
cache_info->active_index_channel=((image->storage_class == PseudoClass) ||
(image->colorspace == CMYKColorspace)) ? MagickTrue : MagickFalse;
number_pixels=(MagickSizeType) cache_info->columns*cache_info->rows;
packet_size=sizeof(PixelPacket);
if (cache_info->active_index_channel != MagickFalse)
packet_size+=sizeof(IndexPacket);
length=number_pixels*packet_size;
columns=(size_t) (length/cache_info->rows/packet_size);
if ((cache_info->columns != columns) || ((ssize_t) cache_info->columns < 0) ||
((ssize_t) cache_info->rows < 0))
ThrowBinaryException(ResourceLimitError,""PixelCacheAllocationFailed"",
image->filename);
cache_info->length=length;
if (image->ping != MagickFalse)
{
cache_info->storage_class=image->storage_class;
cache_info->colorspace=image->colorspace;
cache_info->type=PingCache;
return(MagickTrue);
}
status=AcquireMagickResource(AreaResource,cache_info->length);
length=number_pixels*(sizeof(PixelPacket)+sizeof(IndexPacket));
if ((status != MagickFalse) && (length == (MagickSizeType) ((size_t) length)))
{
status=AcquireMagickResource(MemoryResource,cache_info->length);
if (((cache_info->type == UndefinedCache) && (status != MagickFalse)) ||
(cache_info->type == MemoryCache))
{
AllocatePixelCachePixels(cache_info);
if (cache_info->pixels == (PixelPacket *) NULL)
cache_info->pixels=source_info.pixels;
else
{
cache_info->colorspace=image->colorspace;
cache_info->type=MemoryCache;
cache_info->indexes=(IndexPacket *) NULL;
if (cache_info->active_index_channel != MagickFalse)
cache_info->indexes=(IndexPacket *) (cache_info->pixels+
number_pixels);
if ((source_info.storage_class != UndefinedClass) &&
(mode != ReadMode))
{
status&=ClonePixelCacheRepository(cache_info,&source_info,
exception);
RelinquishPixelCachePixels(&source_info);
}
if (image->debug != MagickFalse)
{
(void) FormatMagickSize(cache_info->length,MagickTrue,format);
type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)
cache_info->type);
(void) FormatLocaleString(message,MaxTextExtent,
""open %s (%s %s, %.20gx%.20g %s)"",cache_info->filename,
cache_info->mapped != MagickFalse ? ""Anonymous"" : ""Heap"",
type,(double) cache_info->columns,(double) cache_info->rows,
format);
(void) LogMagickEvent(CacheEvent,GetMagickModule(),""%s"",
message);
}
cache_info->storage_class=image->storage_class;
return(MagickTrue);
}
}
RelinquishMagickResource(MemoryResource,cache_info->length);
}
status=AcquireMagickResource(DiskResource,cache_info->length);
if ((status == MagickFalse) || (cache_info->type == DistributedCache))
{
DistributeCacheInfo
*server_info;
if (cache_info->type == DistributedCache)
RelinquishMagickResource(DiskResource,cache_info->length);
server_info=AcquireDistributeCacheInfo(exception);
if (server_info != (DistributeCacheInfo *) NULL)
{
status=OpenDistributePixelCache(server_info,image);
if (status == MagickFalse)
{
ThrowFileException(exception,CacheError,""UnableToOpenPixelCache"",
GetDistributeCacheHostname(server_info));
server_info=DestroyDistributeCacheInfo(server_info);
}
else
{
cache_info->type=DistributedCache;
cache_info->storage_class=image->storage_class;
cache_info->colorspace=image->colorspace;
cache_info->server_info=server_info;
(void) FormatLocaleString(cache_info->cache_filename,
MaxTextExtent,""%s:%d"",GetDistributeCacheHostname(
(DistributeCacheInfo *) cache_info->server_info),
GetDistributeCachePort((DistributeCacheInfo *)
cache_info->server_info));
if ((source_info.storage_class != UndefinedClass) &&
(mode != ReadMode))
{
status=ClonePixelCacheRepository(cache_info,&source_info,
exception);
RelinquishPixelCachePixels(&source_info);
}
if (image->debug != MagickFalse)
{
(void) FormatMagickSize(cache_info->length,MagickFalse,
format);
type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)
cache_info->type);
(void) FormatLocaleString(message,MaxTextExtent,
""open %s (%s[%d], %s, %.20gx%.20g %s)"",cache_info->filename,
cache_info->cache_filename,GetDistributeCacheFile(
(DistributeCacheInfo *) cache_info->server_info),type,
(double) cache_info->columns,(double) cache_info->rows,
format);
(void) LogMagickEvent(CacheEvent,GetMagickModule(),""%s"",
message);
}
return(MagickTrue);
}
}
RelinquishMagickResource(DiskResource,cache_info->length);
(void) ThrowMagickException(exception,GetMagickModule(),CacheError,
""CacheResourcesExhausted"",""`%s'"",image->filename);
return(MagickFalse);
}
if ((source_info.storage_class != UndefinedClass) && (mode != ReadMode))
{
(void) ClosePixelCacheOnDisk(cache_info);
*cache_info->cache_filename='\0';
}
if (OpenPixelCacheOnDisk(cache_info,mode) == MagickFalse)
{
RelinquishMagickResource(DiskResource,cache_info->length);
ThrowFileException(exception,CacheError,""UnableToOpenPixelCache"",
image->filename);
return(MagickFalse);
}
status=SetPixelCacheExtent(image,(MagickSizeType) cache_info->offset+
cache_info->length);
if (status == MagickFalse)
{
ThrowFileException(exception,CacheError,""UnableToExtendCache"",
image->filename);
return(MagickFalse);
}
cache_info->storage_class=image->storage_class;
cache_info->colorspace=image->colorspace;
length=number_pixels*(sizeof(PixelPacket)+sizeof(IndexPacket));
if (length != (MagickSizeType) ((size_t) length))
cache_info->type=DiskCache;
else
{
status=AcquireMagickResource(MapResource,cache_info->length);
if ((status == MagickFalse) && (cache_info->type != MapCache) &&
(cache_info->type != MemoryCache))
cache_info->type=DiskCache;
else
{
cache_info->pixels=(PixelPacket *) MapBlob(cache_info->file,mode,
cache_info->offset,(size_t) cache_info->length);
if (cache_info->pixels == (PixelPacket *) NULL)
{
cache_info->pixels=source_info.pixels;
cache_info->type=DiskCache;
}
else
{
(void) ClosePixelCacheOnDisk(cache_info);
cache_info->type=MapCache;
cache_info->mapped=MagickTrue;
cache_info->indexes=(IndexPacket *) NULL;
if (cache_info->active_index_channel != MagickFalse)
cache_info->indexes=(IndexPacket *) (cache_info->pixels+
number_pixels);
if ((source_info.storage_class != UndefinedClass) &&
(mode != ReadMode))
{
status=ClonePixelCacheRepository(cache_info,&source_info,
exception);
RelinquishPixelCachePixels(&source_info);
}
if (image->debug != MagickFalse)
{
(void) FormatMagickSize(cache_info->length,MagickTrue,format);
type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)
cache_info->type);
(void) FormatLocaleString(message,MaxTextExtent,
""open %s (%s[%d], %s, %.20gx%.20g %s)"",
cache_info->filename,cache_info->cache_filename,
cache_info->file,type,(double) cache_info->columns,(double)
cache_info->rows,format);
(void) LogMagickEvent(CacheEvent,GetMagickModule(),""%s"",
message);
}
return(MagickTrue);
}
}
RelinquishMagickResource(MapResource,cache_info->length);
}
if ((source_info.storage_class != UndefinedClass) && (mode != ReadMode))
{
status=ClonePixelCacheRepository(cache_info,&source_info,exception);
RelinquishPixelCachePixels(&source_info);
}
if (image->debug != MagickFalse)
{
(void) FormatMagickSize(cache_info->length,MagickFalse,format);
type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)
cache_info->type);
(void) FormatLocaleString(message,MaxTextExtent,
""open %s (%s[%d], %s, %.20gx%.20g %s)"",cache_info->filename,
cache_info->cache_filename,cache_info->file,type,(double)
cache_info->columns,(double) cache_info->rows,format);
(void) LogMagickEvent(CacheEvent,GetMagickModule(),""%s"",message);
}
return(MagickTrue);
}","static MagickBooleanType OpenPixelCache(Image *VAR_0,const MapMode VAR_1,
ExceptionInfo *VAR_2)
{
CacheInfo
*magick_restrict VAR_3,
VAR_4;
char
VAR_5[VAR_6],
VAR_7[VAR_6];
const char
*VAR_8;
MagickSizeType
VAR_9,
VAR_10;
MagickStatusType
VAR_11;
size_t
VAR_12,
VAR_13;
assert(VAR_0 != (const Image *) NULL);
assert(VAR_0->signature == VAR_14);
assert(VAR_0->cache != (Cache) NULL);
if (VAR_0->debug != VAR_15)
(void) LogMagickEvent(VAR_16,GetMagickModule(),""%s"",VAR_0->filename);
if ((VAR_0->columns == 0) || (VAR_0->rows == 0))
ThrowBinaryException(VAR_17,""NoPixelsDefinedInCache"",VAR_0->filename);
VAR_3=(CacheInfo *) VAR_0->cache;
assert(VAR_3->signature == VAR_14);
if ((AcquireMagickResource(VAR_18,VAR_0->columns) == VAR_15) ||
(AcquireMagickResource(VAR_19,VAR_0->rows) == VAR_15))
ThrowBinaryException(VAR_20,""PixelCacheAllocationFailed"",
VAR_0->filename);
VAR_4=(*VAR_3);
VAR_4.file=(-1);
(void) FormatLocaleString(VAR_3->filename,VAR_6,""%s[%.20g]"",
VAR_0->filename,(double) GetImageIndexInList(VAR_0));
VAR_3->mode=VAR_1;
VAR_3->rows=VAR_0->rows;
VAR_3->columns=VAR_0->columns;
VAR_3->channels=VAR_0->channels;
VAR_3->active_index_channel=((VAR_0->storage_class == VAR_21) ||
(VAR_0->colorspace == VAR_22)) ? VAR_23 : VAR_15;
VAR_10=(MagickSizeType) VAR_3->columns*VAR_3->rows;
VAR_13=sizeof(VAR_24);
if (VAR_3->active_index_channel != VAR_15)
VAR_13+=sizeof(VAR_25);
VAR_9=VAR_10*VAR_13;
VAR_12=(size_t) (VAR_9/VAR_3->rows/VAR_13);
if ((VAR_3->columns != VAR_12) || ((ssize_t) VAR_3->columns < 0) ||
((ssize_t) VAR_3->rows < 0))
ThrowBinaryException(VAR_20,""PixelCacheAllocationFailed"",
VAR_0->filename);
VAR_3->length=VAR_9;
if (VAR_0->ping != VAR_15)
{
VAR_3->storage_class=VAR_0->storage_class;
VAR_3->colorspace=VAR_0->colorspace;
VAR_3->type=VAR_26;
return(VAR_23);
}
VAR_11=AcquireMagickResource(VAR_27,VAR_3->length);
VAR_9=VAR_10*(sizeof(VAR_24)+sizeof(VAR_25));
if ((VAR_11 != VAR_15) && (VAR_9 == (MagickSizeType) ((size_t) VAR_9)))
{
VAR_11=AcquireMagickResource(VAR_28,VAR_3->length);
if (((VAR_3->type == VAR_29) && (VAR_11 != VAR_15)) ||
(VAR_3->type == VAR_30))
{
AllocatePixelCachePixels(VAR_3);
if (VAR_3->pixels == (PixelPacket *) NULL)
VAR_3->pixels=VAR_4.pixels;
else
{
VAR_3->colorspace=VAR_0->colorspace;
VAR_3->type=VAR_30;
VAR_3->indexes=(IndexPacket *) NULL;
if (VAR_3->active_index_channel != VAR_15)
VAR_3->indexes=(IndexPacket *) (VAR_3->pixels+
VAR_10);
if ((VAR_4.storage_class != VAR_31) &&
(VAR_1 != VAR_32))
{
VAR_11&=ClonePixelCacheRepository(VAR_3,&VAR_4,
VAR_2);
RelinquishPixelCachePixels(&VAR_4);
}
if (VAR_0->debug != VAR_15)
{
(void) FormatMagickSize(VAR_3->length,VAR_23,VAR_5);
VAR_8=CommandOptionToMnemonic(VAR_33,(ssize_t)
VAR_3->type);
(void) FormatLocaleString(VAR_7,VAR_6,
""open %s (%s %s, %.20gx%.20g %s)"",VAR_3->filename,
VAR_3->mapped != VAR_15 ? ""Anonymous"" : ""Heap"",
VAR_8,(double) VAR_3->columns,(double) VAR_3->rows,
VAR_5);
(void) LogMagickEvent(VAR_34,GetMagickModule(),""%s"",
VAR_7);
}
VAR_3->storage_class=VAR_0->storage_class;
return(VAR_23);
}
}
RelinquishMagickResource(VAR_28,VAR_3->length);
}
VAR_11=AcquireMagickResource(VAR_35,VAR_3->length);
if ((VAR_11 == VAR_15) || (VAR_3->type == VAR_36))
{
DistributeCacheInfo
*VAR_37;
if (VAR_3->type == VAR_36)
RelinquishMagickResource(VAR_35,VAR_3->length);
VAR_37=AcquireDistributeCacheInfo(VAR_2);
if (VAR_37 != (DistributeCacheInfo *) NULL)
{
VAR_11=OpenDistributePixelCache(VAR_37,VAR_0);
if (VAR_11 == VAR_15)
{
ThrowFileException(VAR_2,VAR_17,""UnableToOpenPixelCache"",
GetDistributeCacheHostname(VAR_37));
VAR_37=DestroyDistributeCacheInfo(VAR_37);
}
else
{
VAR_3->type=VAR_36;
VAR_3->storage_class=VAR_0->storage_class;
VAR_3->colorspace=VAR_0->colorspace;
VAR_3->server_info=VAR_37;
(void) FormatLocaleString(VAR_3->cache_filename,
VAR_6,""%s:%d"",GetDistributeCacheHostname(
(DistributeCacheInfo *) VAR_3->server_info),
GetDistributeCachePort((DistributeCacheInfo *)
VAR_3->server_info));
if ((VAR_4.storage_class != VAR_31) &&
(VAR_1 != VAR_32))
{
VAR_11=ClonePixelCacheRepository(VAR_3,&VAR_4,
VAR_2);
RelinquishPixelCachePixels(&VAR_4);
}
if (VAR_0->debug != VAR_15)
{
(void) FormatMagickSize(VAR_3->length,VAR_15,
VAR_5);
VAR_8=CommandOptionToMnemonic(VAR_33,(ssize_t)
VAR_3->type);
(void) FormatLocaleString(VAR_7,VAR_6,
""open %s (%s[%d], %s, %.20gx%.20g %s)"",VAR_3->filename,
VAR_3->cache_filename,GetDistributeCacheFile(
(DistributeCacheInfo *) VAR_3->server_info),VAR_8,
(double) VAR_3->columns,(double) VAR_3->rows,
VAR_5);
(void) LogMagickEvent(VAR_34,GetMagickModule(),""%s"",
VAR_7);
}
return(VAR_23);
}
}
RelinquishMagickResource(VAR_35,VAR_3->length);
(void) ThrowMagickException(VAR_2,GetMagickModule(),VAR_17,
""CacheResourcesExhausted"",""`%s'"",VAR_0->filename);
return(VAR_15);
}
if ((VAR_4.storage_class != VAR_31) && (VAR_1 != VAR_32))
{
(void) ClosePixelCacheOnDisk(VAR_3);
*VAR_3->cache_filename='\0';
}
if (OpenPixelCacheOnDisk(VAR_3,VAR_1) == VAR_15)
{
RelinquishMagickResource(VAR_35,VAR_3->length);
ThrowFileException(VAR_2,VAR_17,""UnableToOpenPixelCache"",
VAR_0->filename);
return(VAR_15);
}
VAR_11=SetPixelCacheExtent(VAR_0,(MagickSizeType) VAR_3->offset+
VAR_3->length);
if (VAR_11 == VAR_15)
{
ThrowFileException(VAR_2,VAR_17,""UnableToExtendCache"",
VAR_0->filename);
return(VAR_15);
}
VAR_3->storage_class=VAR_0->storage_class;
VAR_3->colorspace=VAR_0->colorspace;
VAR_9=VAR_10*(sizeof(PixelPacket)+sizeof(IndexPacket));
if (VAR_9 != (MagickSizeType) ((size_t) VAR_9))
VAR_3->type=VAR_38;
else
{
VAR_11=AcquireMagickResource(VAR_39,VAR_3->length);
if ((VAR_11 == VAR_15) && (VAR_3->type != VAR_40) &&
(VAR_3->type != VAR_30))
VAR_3->type=VAR_38;
else
{
VAR_3->pixels=(PixelPacket *) MapBlob(VAR_3->file,VAR_1,
VAR_3->offset,(size_t) VAR_3->length);
if (VAR_3->pixels == (PixelPacket *) NULL)
{
VAR_3->pixels=VAR_4.pixels;
VAR_3->type=VAR_38;
}
else
{
(void) ClosePixelCacheOnDisk(VAR_3);
VAR_3->type=VAR_40;
VAR_3->mapped=VAR_23;
VAR_3->indexes=(IndexPacket *) NULL;
if (VAR_3->active_index_channel != VAR_15)
VAR_3->indexes=(IndexPacket *) (VAR_3->pixels+
VAR_10);
if ((VAR_4.storage_class != VAR_31) &&
(VAR_1 != VAR_32))
{
VAR_11=ClonePixelCacheRepository(VAR_3,&VAR_4,
VAR_2);
RelinquishPixelCachePixels(&VAR_4);
}
if (VAR_0->debug != VAR_15)
{
(void) FormatMagickSize(VAR_3->length,VAR_23,VAR_5);
VAR_8=CommandOptionToMnemonic(VAR_33,(ssize_t)
VAR_3->type);
(void) FormatLocaleString(VAR_7,VAR_6,
""open %s (%s[%d], %s, %.20gx%.20g %s)"",
VAR_3->filename,VAR_3->cache_filename,
VAR_3->file,VAR_8,(double) VAR_3->columns,(double)
VAR_3->rows,VAR_5);
(void) LogMagickEvent(VAR_34,GetMagickModule(),""%s"",
VAR_7);
}
return(VAR_23);
}
}
RelinquishMagickResource(VAR_39,VAR_3->length);
}
if ((VAR_4.storage_class != VAR_31) && (VAR_1 != VAR_32))
{
VAR_11=ClonePixelCacheRepository(VAR_3,&VAR_4,VAR_2);
RelinquishPixelCachePixels(&VAR_4);
}
if (VAR_0->debug != VAR_15)
{
(void) FormatMagickSize(VAR_3->length,VAR_15,VAR_5);
VAR_8=CommandOptionToMnemonic(VAR_33,(ssize_t)
VAR_3->type);
(void) FormatLocaleString(VAR_7,VAR_6,
""open %s (%s[%d], %s, %.20gx%.20g %s)"",VAR_3->filename,
VAR_3->cache_filename,VAR_3->file,VAR_8,(double)
VAR_3->columns,(double) VAR_3->rows,VAR_5);
(void) LogMagickEvent(VAR_34,GetMagickModule(),""%s"",VAR_7);
}
return(VAR_23);
}",ImageMagick/4e81ce8b07219c69a9aeccb0f7f7b927ca6db74c/cache.c/vul/before/0.json,"static MagickBooleanType OpenPixelCache(Image *image,const MapMode mode,
  ExceptionInfo *exception)
{
  CacheInfo
    *magick_restrict cache_info,
    source_info;

  char
    format[MaxTextExtent],
    message[MaxTextExtent];

  const char
    *type;

  MagickSizeType
    length,
    number_pixels;

  MagickStatusType
    status;

  size_t
    columns,
    packet_size;

  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  if ((image->columns == 0) || (image->rows == 0))
    ThrowBinaryException(CacheError,""NoPixelsDefinedInCache"",image->filename);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if ((AcquireMagickResource(WidthResource,image->columns) == MagickFalse) ||
      (AcquireMagickResource(HeightResource,image->rows) == MagickFalse))
    ThrowBinaryException(ResourceLimitError,""PixelCacheAllocationFailed"",
      image->filename);
  source_info=(*cache_info);
  source_info.file=(-1);
  (void) FormatLocaleString(cache_info->filename,MaxTextExtent,""%s[%.20g]"",
    image->filename,(double) GetImageIndexInList(image));
  cache_info->mode=mode;
  cache_info->rows=image->rows;
  cache_info->columns=image->columns;
  cache_info->channels=image->channels;
  cache_info->active_index_channel=((image->storage_class == PseudoClass) ||
    (image->colorspace == CMYKColorspace)) ? MagickTrue : MagickFalse;
  number_pixels=(MagickSizeType) cache_info->columns*cache_info->rows;
  packet_size=sizeof(PixelPacket);
  if (cache_info->active_index_channel != MagickFalse)
    packet_size+=sizeof(IndexPacket);
  length=number_pixels*packet_size;
  columns=(size_t) (length/cache_info->rows/packet_size);
  if ((cache_info->columns != columns) || ((ssize_t) cache_info->columns < 0) ||
      ((ssize_t) cache_info->rows < 0))
    ThrowBinaryException(ResourceLimitError,""PixelCacheAllocationFailed"",
      image->filename);
  cache_info->length=length;
  if (image->ping != MagickFalse)
    {
      cache_info->storage_class=image->storage_class;
      cache_info->colorspace=image->colorspace;
      cache_info->type=PingCache;
      return(MagickTrue);
    }
  status=AcquireMagickResource(AreaResource,cache_info->length);
  length=number_pixels*(sizeof(PixelPacket)+sizeof(IndexPacket));
  if ((status != MagickFalse) && (length == (MagickSizeType) ((size_t) length)))
    {
      status=AcquireMagickResource(MemoryResource,cache_info->length);
      if (((cache_info->type == UndefinedCache) && (status != MagickFalse)) ||
          (cache_info->type == MemoryCache))
        {
          cache_info->mapped=MagickFalse;
          cache_info->pixels=(PixelPacket *) MagickAssumeAligned(
            AcquireAlignedMemory(1,(size_t) cache_info->length));
          if (cache_info->pixels == (PixelPacket *) NULL)
            cache_info->pixels=source_info.pixels;
          else
            {
              /*
                Create memory pixel cache.
              */
              cache_info->colorspace=image->colorspace;
              cache_info->type=MemoryCache;
              cache_info->indexes=(IndexPacket *) NULL;
              if (cache_info->active_index_channel != MagickFalse)
                cache_info->indexes=(IndexPacket *) (cache_info->pixels+
                  number_pixels);
              if ((source_info.storage_class != UndefinedClass) &&
                  (mode != ReadMode))
                {
                  status&=ClonePixelCacheRepository(cache_info,&source_info,
                    exception);
                  RelinquishPixelCachePixels(&source_info);
                }
              if (image->debug != MagickFalse)
                {
                  (void) FormatMagickSize(cache_info->length,MagickTrue,format);
                  type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)
                    cache_info->type);
                  (void) FormatLocaleString(message,MaxTextExtent,
                    ""open %s (%s %s, %.20gx%.20g %s)"",cache_info->filename,
                    cache_info->mapped != MagickFalse ? ""Anonymous"" : ""Heap"",
                    type,(double) cache_info->columns,(double) cache_info->rows,
                    format);
                  (void) LogMagickEvent(CacheEvent,GetMagickModule(),""%s"",
                    message);
                }
              cache_info->storage_class=image->storage_class;
              return(MagickTrue);
            }
        }
      RelinquishMagickResource(MemoryResource,cache_info->length);
    }
  /*
    Create pixel cache on disk.
  */
  status=AcquireMagickResource(DiskResource,cache_info->length);
  if ((status == MagickFalse) || (cache_info->type == DistributedCache))
    {
      DistributeCacheInfo
        *server_info;

      if (cache_info->type == DistributedCache)
        RelinquishMagickResource(DiskResource,cache_info->length);
      server_info=AcquireDistributeCacheInfo(exception);
      if (server_info != (DistributeCacheInfo *) NULL)
        {
          status=OpenDistributePixelCache(server_info,image);
          if (status == MagickFalse)
            {
              ThrowFileException(exception,CacheError,""UnableToOpenPixelCache"",
                GetDistributeCacheHostname(server_info));
              server_info=DestroyDistributeCacheInfo(server_info);
            }
          else
            {
              /*
                Create a distributed pixel cache.
              */
              cache_info->type=DistributedCache;
              cache_info->storage_class=image->storage_class;
              cache_info->colorspace=image->colorspace;
              cache_info->server_info=server_info;
              (void) FormatLocaleString(cache_info->cache_filename,
                MaxTextExtent,""%s:%d"",GetDistributeCacheHostname(
                (DistributeCacheInfo *) cache_info->server_info),
                GetDistributeCachePort((DistributeCacheInfo *)
                cache_info->server_info));
              if ((source_info.storage_class != UndefinedClass) &&
                  (mode != ReadMode))
                {
                  status=ClonePixelCacheRepository(cache_info,&source_info,
                    exception);
                  RelinquishPixelCachePixels(&source_info);
                }
              if (image->debug != MagickFalse)
                {
                  (void) FormatMagickSize(cache_info->length,MagickFalse,
                    format);
                  type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)
                    cache_info->type);
                  (void) FormatLocaleString(message,MaxTextExtent,
                    ""open %s (%s[%d], %s, %.20gx%.20g %s)"",cache_info->filename,
                    cache_info->cache_filename,GetDistributeCacheFile(
                    (DistributeCacheInfo *) cache_info->server_info),type,
                    (double) cache_info->columns,(double) cache_info->rows,
                    format);
                  (void) LogMagickEvent(CacheEvent,GetMagickModule(),""%s"",
                    message);
                }
              return(MagickTrue);
            }
        }
      RelinquishMagickResource(DiskResource,cache_info->length);
      (void) ThrowMagickException(exception,GetMagickModule(),CacheError,
        ""CacheResourcesExhausted"",""`%s'"",image->filename);
      return(MagickFalse);
    }
  if ((source_info.storage_class != UndefinedClass) && (mode != ReadMode))
    {
      (void) ClosePixelCacheOnDisk(cache_info);
      *cache_info->cache_filename='\0';
    }
  if (OpenPixelCacheOnDisk(cache_info,mode) == MagickFalse)
    {
      RelinquishMagickResource(DiskResource,cache_info->length);
      ThrowFileException(exception,CacheError,""UnableToOpenPixelCache"",
        image->filename);
      return(MagickFalse);
    }
  status=SetPixelCacheExtent(image,(MagickSizeType) cache_info->offset+
    cache_info->length);
  if (status == MagickFalse)
    {
      ThrowFileException(exception,CacheError,""UnableToExtendCache"",
        image->filename);
      return(MagickFalse);
    }
  cache_info->storage_class=image->storage_class;
  cache_info->colorspace=image->colorspace;
  length=number_pixels*(sizeof(PixelPacket)+sizeof(IndexPacket));
  if (length != (MagickSizeType) ((size_t) length))
    cache_info->type=DiskCache;
  else
    {
      status=AcquireMagickResource(MapResource,cache_info->length);
      if ((status == MagickFalse) && (cache_info->type != MapCache) &&
          (cache_info->type != MemoryCache))
        cache_info->type=DiskCache;
      else
        {
          cache_info->pixels=(PixelPacket *) MapBlob(cache_info->file,mode,
            cache_info->offset,(size_t) cache_info->length);
          if (cache_info->pixels == (PixelPacket *) NULL)
            {
              cache_info->pixels=source_info.pixels;
              cache_info->type=DiskCache;
            }
          else
            {
              /*
                Create file-backed memory-mapped pixel cache.
              */
              (void) ClosePixelCacheOnDisk(cache_info);
              cache_info->type=MapCache;
              cache_info->mapped=MagickTrue;
              cache_info->indexes=(IndexPacket *) NULL;
              if (cache_info->active_index_channel != MagickFalse)
                cache_info->indexes=(IndexPacket *) (cache_info->pixels+
                  number_pixels);
              if ((source_info.storage_class != UndefinedClass) &&
                  (mode != ReadMode))
                {
                  status=ClonePixelCacheRepository(cache_info,&source_info,
                    exception);
                  RelinquishPixelCachePixels(&source_info);
                }
              if (image->debug != MagickFalse)
                {
                  (void) FormatMagickSize(cache_info->length,MagickTrue,format);
                  type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)
                    cache_info->type);
                  (void) FormatLocaleString(message,MaxTextExtent,
                    ""open %s (%s[%d], %s, %.20gx%.20g %s)"",
                    cache_info->filename,cache_info->cache_filename,
                    cache_info->file,type,(double) cache_info->columns,(double)
                    cache_info->rows,format);
                  (void) LogMagickEvent(CacheEvent,GetMagickModule(),""%s"",
                    message);
                }
              return(MagickTrue);
            }
        }
      RelinquishMagickResource(MapResource,cache_info->length);
    }
  if ((source_info.storage_class != UndefinedClass) && (mode != ReadMode))
    {
      status=ClonePixelCacheRepository(cache_info,&source_info,exception);
      RelinquishPixelCachePixels(&source_info);
    }
  if (image->debug != MagickFalse)
    {
      (void) FormatMagickSize(cache_info->length,MagickFalse,format);
      type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)
        cache_info->type);
      (void) FormatLocaleString(message,MaxTextExtent,
        ""open %s (%s[%d], %s, %.20gx%.20g %s)"",cache_info->filename,
        cache_info->cache_filename,cache_info->file,type,(double)
        cache_info->columns,(double) cache_info->rows,format);
      (void) LogMagickEvent(CacheEvent,GetMagickModule(),""%s"",message);
    }
  return(MagickTrue);
}","static MagickBooleanType OpenPixelCache(Image *VAR_0,const MapMode VAR_1,
  ExceptionInfo *VAR_2)
{
  CacheInfo
    *magick_restrict VAR_3,
    VAR_4;

  char
    VAR_5[VAR_6],
    VAR_7[VAR_6];

  const char
    *VAR_8;

  MagickSizeType
    VAR_9,
    VAR_10;

  MagickStatusType
    VAR_11;

  size_t
    VAR_12,
    VAR_13;

  assert(VAR_0 != (const Image *) NULL);
  assert(VAR_0->signature == VAR_14);
  assert(VAR_0->cache != (Cache) NULL);
  if (VAR_0->debug != VAR_15)
    (void) LogMagickEvent(VAR_16,GetMagickModule(),""%s"",VAR_0->filename);
  if ((VAR_0->columns == 0) || (VAR_0->rows == 0))
    ThrowBinaryException(VAR_17,""NoPixelsDefinedInCache"",VAR_0->filename);
  VAR_3=(CacheInfo *) VAR_0->cache;
  assert(VAR_3->signature == VAR_14);
  if ((AcquireMagickResource(VAR_18,VAR_0->columns) == VAR_15) ||
      (AcquireMagickResource(VAR_19,VAR_0->rows) == VAR_15))
    ThrowBinaryException(VAR_20,""PixelCacheAllocationFailed"",
      VAR_0->filename);
  VAR_4=(*VAR_3);
  VAR_4.file=(-1);
  (void) FormatLocaleString(VAR_3->filename,VAR_6,""%s[%.20g]"",
    VAR_0->filename,(double) GetImageIndexInList(VAR_0));
  VAR_3->mode=VAR_1;
  VAR_3->rows=VAR_0->rows;
  VAR_3->columns=VAR_0->columns;
  VAR_3->channels=VAR_0->channels;
  VAR_3->active_index_channel=((VAR_0->storage_class == VAR_21) ||
    (VAR_0->colorspace == VAR_22)) ? VAR_23 : VAR_15;
  VAR_10=(MagickSizeType) VAR_3->columns*VAR_3->rows;
  VAR_13=sizeof(VAR_24);
  if (VAR_3->active_index_channel != VAR_15)
    VAR_13+=sizeof(VAR_25);
  VAR_9=VAR_10*VAR_13;
  VAR_12=(size_t) (VAR_9/VAR_3->rows/VAR_13);
  if ((VAR_3->columns != VAR_12) || ((ssize_t) VAR_3->columns < 0) ||
      ((ssize_t) VAR_3->rows < 0))
    ThrowBinaryException(VAR_20,""PixelCacheAllocationFailed"",
      VAR_0->filename);
  VAR_3->length=VAR_9;
  if (VAR_0->ping != VAR_15)
    {
      VAR_3->storage_class=VAR_0->storage_class;
      VAR_3->colorspace=VAR_0->colorspace;
      VAR_3->type=VAR_26;
      return(VAR_23);
    }
  VAR_11=AcquireMagickResource(VAR_27,VAR_3->length);
  VAR_9=VAR_10*(sizeof(VAR_24)+sizeof(VAR_25));
  if ((VAR_11 != VAR_15) && (VAR_9 == (MagickSizeType) ((size_t) VAR_9)))
    {
      VAR_11=AcquireMagickResource(VAR_28,VAR_3->length);
      if (((VAR_3->type == VAR_29) && (VAR_11 != VAR_15)) ||
          (VAR_3->type == VAR_30))
        {
          VAR_3->mapped=VAR_15;
          VAR_3->pixels=(PixelPacket *) MagickAssumeAligned(
            AcquireAlignedMemory(1,(size_t) VAR_3->length));
          if (VAR_3->pixels == (PixelPacket *) NULL)
            VAR_3->pixels=VAR_4.pixels;
          else
            {
              /* COMMENT_0 */
                                          
                
              VAR_3->colorspace=VAR_0->colorspace;
              VAR_3->type=VAR_30;
              VAR_3->indexes=(IndexPacket *) NULL;
              if (VAR_3->active_index_channel != VAR_15)
                VAR_3->indexes=(IndexPacket *) (VAR_3->pixels+
                  VAR_10);
              if ((VAR_4.storage_class != VAR_31) &&
                  (VAR_1 != VAR_32))
                {
                  VAR_11&=ClonePixelCacheRepository(VAR_3,&VAR_4,
                    VAR_2);
                  RelinquishPixelCachePixels(&VAR_4);
                }
              if (VAR_0->debug != VAR_15)
                {
                  (void) FormatMagickSize(VAR_3->length,VAR_23,VAR_5);
                  VAR_8=CommandOptionToMnemonic(VAR_33,(ssize_t)
                    VAR_3->type);
                  (void) FormatLocaleString(VAR_7,VAR_6,
                    ""open %s (%s %s, %.20gx%.20g %s)"",VAR_3->filename,
                    VAR_3->mapped != VAR_15 ? ""Anonymous"" : ""Heap"",
                    VAR_8,(double) VAR_3->columns,(double) VAR_3->rows,
                    VAR_5);
                  (void) LogMagickEvent(VAR_34,GetMagickModule(),""%s"",
                    VAR_7);
                }
              VAR_3->storage_class=VAR_0->storage_class;
              return(VAR_23);
            }
        }
      RelinquishMagickResource(VAR_28,VAR_3->length);
    }
  /* COMMENT_3 */
                               
    
  VAR_11=AcquireMagickResource(VAR_35,VAR_3->length);
  if ((VAR_11 == VAR_15) || (VAR_3->type == VAR_36))
    {
      DistributeCacheInfo
        *VAR_37;

      if (VAR_3->type == VAR_36)
        RelinquishMagickResource(VAR_35,VAR_3->length);
      VAR_37=AcquireDistributeCacheInfo(VAR_2);
      if (VAR_37 != (DistributeCacheInfo *) NULL)
        {
          VAR_11=OpenDistributePixelCache(VAR_37,VAR_0);
          if (VAR_11 == VAR_15)
            {
              ThrowFileException(VAR_2,VAR_17,""UnableToOpenPixelCache"",
                GetDistributeCacheHostname(VAR_37));
              VAR_37=DestroyDistributeCacheInfo(VAR_37);
            }
          else
            {
              /* COMMENT_6 */
                                                 
                
              VAR_3->type=VAR_36;
              VAR_3->storage_class=VAR_0->storage_class;
              VAR_3->colorspace=VAR_0->colorspace;
              VAR_3->server_info=VAR_37;
              (void) FormatLocaleString(VAR_3->cache_filename,
                VAR_6,""%s:%d"",GetDistributeCacheHostname(
                (DistributeCacheInfo *) VAR_3->server_info),
                GetDistributeCachePort((DistributeCacheInfo *)
                VAR_3->server_info));
              if ((VAR_4.storage_class != VAR_31) &&
                  (VAR_1 != VAR_32))
                {
                  VAR_11=ClonePixelCacheRepository(VAR_3,&VAR_4,
                    VAR_2);
                  RelinquishPixelCachePixels(&VAR_4);
                }
              if (VAR_0->debug != VAR_15)
                {
                  (void) FormatMagickSize(VAR_3->length,VAR_15,
                    VAR_5);
                  VAR_8=CommandOptionToMnemonic(VAR_33,(ssize_t)
                    VAR_3->type);
                  (void) FormatLocaleString(VAR_7,VAR_6,
                    ""open %s (%s[%d], %s, %.20gx%.20g %s)"",VAR_3->filename,
                    VAR_3->cache_filename,GetDistributeCacheFile(
                    (DistributeCacheInfo *) VAR_3->server_info),VAR_8,
                    (double) VAR_3->columns,(double) VAR_3->rows,
                    VAR_5);
                  (void) LogMagickEvent(VAR_34,GetMagickModule(),""%s"",
                    VAR_7);
                }
              return(VAR_23);
            }
        }
      RelinquishMagickResource(VAR_35,VAR_3->length);
      (void) ThrowMagickException(VAR_2,GetMagickModule(),VAR_17,
        ""CacheResourcesExhausted"",""`%s'"",VAR_0->filename);
      return(VAR_15);
    }
  if ((VAR_4.storage_class != VAR_31) && (VAR_1 != VAR_32))
    {
      (void) ClosePixelCacheOnDisk(VAR_3);
      *VAR_3->cache_filename='\0';
    }
  if (OpenPixelCacheOnDisk(VAR_3,VAR_1) == VAR_15)
    {
      RelinquishMagickResource(VAR_35,VAR_3->length);
      ThrowFileException(VAR_2,VAR_17,""UnableToOpenPixelCache"",
        VAR_0->filename);
      return(VAR_15);
    }
  VAR_11=SetPixelCacheExtent(VAR_0,(MagickSizeType) VAR_3->offset+
    VAR_3->length);
  if (VAR_11 == VAR_15)
    {
      ThrowFileException(VAR_2,VAR_17,""UnableToExtendCache"",
        VAR_0->filename);
      return(VAR_15);
    }
  VAR_3->storage_class=VAR_0->storage_class;
  VAR_3->colorspace=VAR_0->colorspace;
  VAR_9=VAR_10*(sizeof(PixelPacket)+sizeof(IndexPacket));
  if (VAR_9 != (MagickSizeType) ((size_t) VAR_9))
    VAR_3->type=VAR_38;
  else
    {
      VAR_11=AcquireMagickResource(VAR_39,VAR_3->length);
      if ((VAR_11 == VAR_15) && (VAR_3->type != VAR_40) &&
          (VAR_3->type != VAR_30))
        VAR_3->type=VAR_38;
      else
        {
          VAR_3->pixels=(PixelPacket *) MapBlob(VAR_3->file,VAR_1,
            VAR_3->offset,(size_t) VAR_3->length);
          if (VAR_3->pixels == (PixelPacket *) NULL)
            {
              VAR_3->pixels=VAR_4.pixels;
              VAR_3->type=VAR_38;
            }
          else
            {
              /* COMMENT_9 */
                                                             
                
              (void) ClosePixelCacheOnDisk(VAR_3);
              VAR_3->type=VAR_40;
              VAR_3->mapped=VAR_23;
              VAR_3->indexes=(IndexPacket *) NULL;
              if (VAR_3->active_index_channel != VAR_15)
                VAR_3->indexes=(IndexPacket *) (VAR_3->pixels+
                  VAR_10);
              if ((VAR_4.storage_class != VAR_31) &&
                  (VAR_1 != VAR_32))
                {
                  VAR_11=ClonePixelCacheRepository(VAR_3,&VAR_4,
                    VAR_2);
                  RelinquishPixelCachePixels(&VAR_4);
                }
              if (VAR_0->debug != VAR_15)
                {
                  (void) FormatMagickSize(VAR_3->length,VAR_23,VAR_5);
                  VAR_8=CommandOptionToMnemonic(VAR_33,(ssize_t)
                    VAR_3->type);
                  (void) FormatLocaleString(VAR_7,VAR_6,
                    ""open %s (%s[%d], %s, %.20gx%.20g %s)"",
                    VAR_3->filename,VAR_3->cache_filename,
                    VAR_3->file,VAR_8,(double) VAR_3->columns,(double)
                    VAR_3->rows,VAR_5);
                  (void) LogMagickEvent(VAR_34,GetMagickModule(),""%s"",
                    VAR_7);
                }
              return(VAR_23);
            }
        }
      RelinquishMagickResource(VAR_39,VAR_3->length);
    }
  if ((VAR_4.storage_class != VAR_31) && (VAR_1 != VAR_32))
    {
      VAR_11=ClonePixelCacheRepository(VAR_3,&VAR_4,VAR_2);
      RelinquishPixelCachePixels(&VAR_4);
    }
  if (VAR_0->debug != VAR_15)
    {
      (void) FormatMagickSize(VAR_3->length,VAR_15,VAR_5);
      VAR_8=CommandOptionToMnemonic(VAR_33,(ssize_t)
        VAR_3->type);
      (void) FormatLocaleString(VAR_7,VAR_6,
        ""open %s (%s[%d], %s, %.20gx%.20g %s)"",VAR_3->filename,
        VAR_3->cache_filename,VAR_3->file,VAR_8,(double)
        VAR_3->columns,(double) VAR_3->rows,VAR_5);
      (void) LogMagickEvent(VAR_34,GetMagickModule(),""%s"",VAR_7);
    }
  return(VAR_23);
}",ImageMagick/4e81ce8b07219c69a9aeccb0f7f7b927ca6db74c/cache.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -72,7 +72,9 @@
       if (((cache_info->type == UndefinedCache) && (status != MagickFalse)) ||
           (cache_info->type == MemoryCache))
         {
-          AllocatePixelCachePixels(cache_info);
+          cache_info->mapped=MagickFalse;
+          cache_info->pixels=(PixelPacket *) MagickAssumeAligned(
+            AcquireAlignedMemory(1,(size_t) cache_info->length));
           if (cache_info->pixels == (PixelPacket *) NULL)
             cache_info->pixels=source_info.pixels;
           else","{'deleted_lines': ['          AllocatePixelCachePixels(cache_info);'], 'added_lines': ['          cache_info->mapped=MagickFalse;', '          cache_info->pixels=(PixelPacket *) MagickAssumeAligned(', '            AcquireAlignedMemory(1,(size_t) cache_info->length));']}",True,Memory leak in AcquireVirtualMemory in ImageMagick before 7 allows remote attackers to cause a denial of service (memory consumption) via unspecified vectors.,7.5,HIGH,2,test,2016-01-07T14:08:49Z,1
CVE-2016-2527,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"nettrace_3gpp_32_423 Protect from buffer overun.

Bug: 11982
Change-Id: Ib704d9128ab6427751edbf3a33f4b8fd14902562
Reviewed-on: https://code.wireshark.org/review/13233
Reviewed-by: Anders Broman <a.broman58@gmail.com>
Petri-Dish: Anders Broman <a.broman58@gmail.com>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Michael Mann <mmann78@netscape.net>",140aad08e081489b5cdb715cb5bca01db856fded,https://github.com/wireshark/wireshark/commit/140aad08e081489b5cdb715cb5bca01db856fded,wiretap/nettrace_3gpp_32_423.c,create_temp_pcapng_file,"static wtap_open_return_val
create_temp_pcapng_file(wtap *wth, int *err, gchar **err_info, nettrace_3gpp_32_423_file_info_t *file_info)
{
int import_file_fd;
wtap_dumper* wdh_exp_pdu;
int   exp_pdu_file_err;
wtap_open_return_val result = WTAP_OPEN_MINE;
wtapng_section_t            *shb_hdr = NULL;
wtapng_iface_descriptions_t *idb_inf = NULL;
wtapng_if_descr_t            int_data;
GString                     *os_info_str;
gint64 file_size;
int packet_size;
guint8 *packet_buf = NULL;
int wrt_err;
gchar *wrt_err_info = NULL;
struct wtap_pkthdr phdr;
time_t start_time;
int scan_found;
unsigned second, ms;
gboolean do_random = FALSE;
char *curr_pos, *next_msg_pos, *next_pos, *prev_pos;
exported_pdu_info_t  exported_pdu_info;
exported_pdu_info.precense_flags = 0;
exported_pdu_info.src_ipv4_d1 = 0;
exported_pdu_info.src_ipv4_d2 = 0;
exported_pdu_info.src_ipv4_d3 = 0;
exported_pdu_info.src_ipv4_d4 = 0;
exported_pdu_info.ptype = PT_NONE;
exported_pdu_info.src_port = 0;
exported_pdu_info.dst_ipv4_d1 = 0;
exported_pdu_info.dst_ipv4_d2 = 0;
exported_pdu_info.dst_ipv4_d3 = 0;
exported_pdu_info.dst_ipv4_d4 = 0;
exported_pdu_info.dst_port = 0;
import_file_fd = create_tempfile(&(file_info->tmpname), ""Wireshark_PDU_"");
os_info_str = g_string_new("""");
get_os_version_info(os_info_str);
shb_hdr = g_new(wtapng_section_t, 1);
shb_hdr->section_length = -1;
shb_hdr->opt_comment = g_strdup_printf(""File converted to Exported PDU format during opening"");
shb_hdr->shb_hardware = NULL;
shb_hdr->shb_os = g_string_free(os_info_str, FALSE);
shb_hdr->shb_user_appl = g_strdup_printf(""Wireshark %s"", get_ws_vcs_version_info());
idb_inf = g_new(wtapng_iface_descriptions_t, 1);
idb_inf->interface_data = g_array_new(FALSE, FALSE, sizeof(wtapng_if_descr_t));
int_data.wtap_encap = WTAP_ENCAP_WIRESHARK_UPPER_PDU;
int_data.time_units_per_second = 1000000; 
int_data.link_type = wtap_wtap_encap_to_pcap_encap(WTAP_ENCAP_WIRESHARK_UPPER_PDU);
int_data.snap_len = WTAP_MAX_PACKET_SIZE;
int_data.if_name = g_strdup(""Fake IF"");
int_data.opt_comment = NULL;
int_data.if_description = NULL;
int_data.if_speed = 0;
int_data.if_tsresol = 6;
int_data.if_filter_str = NULL;
int_data.bpf_filter_len = 0;
int_data.if_filter_bpf_bytes = NULL;
int_data.if_os = NULL;
int_data.if_fcslen = -1;
int_data.num_stat_entries = 0;          
int_data.interface_statistics = NULL;
g_array_append_val(idb_inf->interface_data, int_data);
wdh_exp_pdu = wtap_dump_fdopen_ng(import_file_fd, WTAP_FILE_TYPE_SUBTYPE_PCAPNG, WTAP_ENCAP_WIRESHARK_UPPER_PDU,
WTAP_MAX_PACKET_SIZE, FALSE, shb_hdr, idb_inf, NULL, &exp_pdu_file_err);
if (wdh_exp_pdu == NULL) {
result = WTAP_OPEN_ERROR;
goto end;
}
if ((file_size = wtap_file_size(wth, err)) == -1) {
result = WTAP_OPEN_ERROR;
goto end;
}
if (file_size > MAX_FILE_SIZE) {
*err = WTAP_ERR_BAD_FILE;
*err_info = g_strdup_printf(""mime_file: File has %"" G_GINT64_MODIFIER ""d-byte packet, bigger than maximum of %u"",
file_size, MAX_FILE_SIZE);
result = WTAP_OPEN_ERROR;
goto end;
}
packet_size = (int)file_size;
packet_buf = (guint8 *)g_malloc(packet_size + 12);
packet_buf[0] = 0;
packet_buf[1] = 12; 
packet_buf[2] = 0;
packet_buf[3] = 4;
packet_buf[4] = 0x78; 
packet_buf[5] = 0x6d; 
packet_buf[6] = 0x6c; 
packet_buf[7] = 0;
packet_buf[8] = 0;
packet_buf[9] = 0;
packet_buf[10] = 0;
packet_buf[11] = 0;
if (!wtap_read_bytes(wth->fh, packet_buf + 12, packet_size, &wrt_err, &wrt_err_info)){
result = WTAP_OPEN_ERROR;
goto end;
}
memset(&phdr, 0, sizeof(struct wtap_pkthdr));
curr_pos = packet_buf + 12;
curr_pos = strstr(curr_pos, ""<fileHeader"");
curr_pos = curr_pos + 11;
curr_pos = strstr(curr_pos, ""<traceCollec beginTime=\"""");
curr_pos = curr_pos + 24;
curr_pos = nettrace_parse_begin_time(curr_pos, &phdr);
start_time = phdr.ts.secs;
phdr.rec_type = REC_TYPE_PACKET;
phdr.caplen = packet_size + 12;
phdr.len = packet_size + 12;
if (!wtap_dump(wdh_exp_pdu, &phdr, packet_buf, &wrt_err, &wrt_err_info)) {
switch (wrt_err) {
case WTAP_ERR_UNWRITABLE_REC_DATA:
g_free(wrt_err_info);
wrt_err_info = NULL;
break;
default:
break;
}
result = WTAP_OPEN_ERROR;
goto end;
}
while ((curr_pos = strstr(curr_pos, ""<msg"")) != NULL){
wtap_open_return_val temp_val;
exported_pdu_info.precense_flags = 0;
exported_pdu_info.ptype = PT_NONE;
curr_pos = curr_pos + 4;
next_msg_pos = strstr(curr_pos, ""</msg>"");
if (!next_msg_pos){
break;
}
next_msg_pos = next_msg_pos + 6;
prev_pos = curr_pos;
ms = 0;
curr_pos = strstr(curr_pos, ""changeTime"");
if ((curr_pos)&&(curr_pos < next_msg_pos)){
curr_pos = curr_pos + 12;
scan_found = sscanf(curr_pos, ""%u.%u"",&second, &ms);
if ((scan_found == 2) && (start_time != 0)) {
start_time = start_time + second;
}
} else {
curr_pos = prev_pos;
}
prev_pos = curr_pos;
curr_pos = strstr(curr_pos, ""<initiator>"");
if ((curr_pos) && (curr_pos < next_msg_pos)) {
curr_pos = curr_pos + 11;
next_pos = strstr(curr_pos, ""</initiator>"");
curr_pos = strstr(curr_pos, ""address"");
if ((curr_pos) && (curr_pos < next_pos)) {
guint d1, d2, d3, d4, port;
char transp_str[5];
curr_pos = curr_pos + 7;
scan_found = sscanf(curr_pos, ""%*s %3u.%3u.%3u.%3u, %*s %*s %5u, %*s %*s %4s"",
&d1, &d2, &d3, &d4, &port, transp_str);
if (scan_found == 6) {
exported_pdu_info.precense_flags = exported_pdu_info.precense_flags + EXP_PDU_TAG_IP_SRC_BIT + EXP_PDU_TAG_SRC_PORT_BIT;
exported_pdu_info.src_ipv4_d1 = d1;
exported_pdu_info.src_ipv4_d2 = d2;
exported_pdu_info.src_ipv4_d3 = d3;
exported_pdu_info.src_ipv4_d4 = d4;
if(exported_pdu_info.ptype == PT_NONE){
if (g_ascii_strncasecmp(transp_str, ""udp"", 3) == 0)  exported_pdu_info.ptype = PT_UDP;
else if (g_ascii_strncasecmp(transp_str, ""tcp"", 3) == 0)  exported_pdu_info.ptype = PT_TCP;
else if (g_ascii_strncasecmp(transp_str, ""sctp"", 4) == 0)  exported_pdu_info.ptype = PT_SCTP;
}
exported_pdu_info.src_port = port;
} else {
g_warning(""scan_found:%u, %u.%u.%u.%u Port %u transport %s"", scan_found, d1, d2, d3, d4, port, transp_str);
}
} else {
curr_pos = next_pos;
}
} else {
curr_pos = prev_pos;
}
prev_pos = curr_pos;
curr_pos = strstr(curr_pos, ""<target>"");
if ((curr_pos) && (curr_pos < next_msg_pos)) {
curr_pos = curr_pos + 8;
next_pos = strstr(curr_pos, ""</target>"");
curr_pos = strstr(curr_pos, ""address"");
if ((curr_pos) && (curr_pos < next_pos)) {
guint d1, d2, d3, d4, port;
char transp_str[5];
curr_pos = curr_pos + 7;
scan_found = sscanf(curr_pos, ""%*s %3u.%3u.%3u.%3u, %*s %*s %5u, %*s %*s %4s"",
&d1, &d2, &d3, &d4, &port, transp_str);
if (scan_found == 6) {
exported_pdu_info.precense_flags = exported_pdu_info.precense_flags + EXP_PDU_TAG_IP_DST_BIT + EXP_PDU_TAG_DST_PORT_BIT;
exported_pdu_info.dst_ipv4_d1 = d1;
exported_pdu_info.dst_ipv4_d2 = d2;
exported_pdu_info.dst_ipv4_d3 = d3;
exported_pdu_info.dst_ipv4_d4 = d4;
if (exported_pdu_info.ptype == PT_NONE) {
if (g_ascii_strncasecmp(transp_str, ""udp"", 3) == 0)  exported_pdu_info.ptype = PT_UDP;
else if (g_ascii_strncasecmp(transp_str, ""tcp"", 3) == 0)  exported_pdu_info.ptype = PT_TCP;
else if (g_ascii_strncasecmp(transp_str, ""sctp"", 4) == 0)  exported_pdu_info.ptype = PT_SCTP;
}
exported_pdu_info.dst_port = port;
} else {
g_warning(""scan_found:%u, %u.%u.%u.%u Port %u transport %s"", scan_found, d1, d2, d3, d4, port, transp_str);
}
}
else {
curr_pos = next_pos;
}
} else {
curr_pos = prev_pos;
}
curr_pos = strstr(curr_pos, ""<rawMsg"");
if (!curr_pos){
curr_pos = next_msg_pos;
continue;
}
curr_pos = curr_pos + 7;
temp_val = write_packet_data(wdh_exp_pdu, &phdr, &wrt_err, &wrt_err_info, curr_pos, start_time, ms, &exported_pdu_info);
if (temp_val != WTAP_OPEN_MINE){
result = temp_val;
goto end;
}
curr_pos = next_msg_pos;
}
if (!wtap_dump_close(wdh_exp_pdu, err)){
result = WTAP_OPEN_ERROR;
goto end;
}
if (wth->random_fh){
do_random = TRUE;
}
file_info->wth_tmp_file =
wtap_open_offline(file_info->tmpname, WTAP_TYPE_AUTO, err, err_info, do_random);
if (!file_info->wth_tmp_file){
result = WTAP_OPEN_ERROR;
goto end;
}
end:
g_free(wrt_err_info);
g_free(packet_buf);
wtap_free_shb(shb_hdr);
wtap_free_idb_info(idb_inf);
return result;
}","static wtap_open_return_val
create_temp_pcapng_file(wtap *VAR_0, int *VAR_1, gchar **VAR_2, nettrace_3gpp_32_423_file_info_t *VAR_3)
{
int VAR_4;
wtap_dumper* VAR_5;
int   VAR_6;
wtap_open_return_val VAR_7 = VAR_8;
wtapng_section_t            *VAR_9 = NULL;
wtapng_iface_descriptions_t *VAR_10 = NULL;
wtapng_if_descr_t            VAR_11;
GString                     *VAR_12;
gint64 VAR_13;
int VAR_14;
guint8 *VAR_15 = NULL;
int VAR_16;
gchar *VAR_17 = NULL;
struct wtap_pkthdr VAR_18;
time_t VAR_19;
int VAR_20;
unsigned VAR_21, VAR_22;
gboolean VAR_23 = FALSE;
char *VAR_24, *VAR_25, *VAR_26, *VAR_27;
exported_pdu_info_t  VAR_28;
VAR_28.precense_flags = 0;
VAR_28.src_ipv4_d1 = 0;
VAR_28.src_ipv4_d2 = 0;
VAR_28.src_ipv4_d3 = 0;
VAR_28.src_ipv4_d4 = 0;
VAR_28.ptype = VAR_29;
VAR_28.src_port = 0;
VAR_28.dst_ipv4_d1 = 0;
VAR_28.dst_ipv4_d2 = 0;
VAR_28.dst_ipv4_d3 = 0;
VAR_28.dst_ipv4_d4 = 0;
VAR_28.dst_port = 0;
VAR_4 = create_tempfile(&(VAR_3->tmpname), ""Wireshark_PDU_"");
VAR_12 = g_string_new("""");
get_os_version_info(VAR_12);
VAR_9 = g_new(wtapng_section_t, 1);
VAR_9->section_length = -1;
VAR_9->opt_comment = g_strdup_printf(""File converted to Exported PDU format during opening"");
VAR_9->shb_hardware = NULL;
VAR_9->shb_os = g_string_free(VAR_12, FALSE);
VAR_9->shb_user_appl = g_strdup_printf(""Wireshark %s"", get_ws_vcs_version_info());
VAR_10 = g_new(wtapng_iface_descriptions_t, 1);
VAR_10->interface_data = g_array_new(FALSE, FALSE, sizeof(wtapng_if_descr_t));
VAR_11.wtap_encap = VAR_30;
VAR_11.time_units_per_second = 1000000; 
VAR_11.link_type = wtap_wtap_encap_to_pcap_encap(VAR_30);
VAR_11.snap_len = VAR_31;
VAR_11.if_name = g_strdup(""Fake IF"");
VAR_11.opt_comment = NULL;
VAR_11.if_description = NULL;
VAR_11.if_speed = 0;
VAR_11.if_tsresol = 6;
VAR_11.if_filter_str = NULL;
VAR_11.bpf_filter_len = 0;
VAR_11.if_filter_bpf_bytes = NULL;
VAR_11.if_os = NULL;
VAR_11.if_fcslen = -1;
VAR_11.num_stat_entries = 0;          
VAR_11.interface_statistics = NULL;
g_array_append_val(VAR_10->interface_data, VAR_11);
VAR_5 = wtap_dump_fdopen_ng(VAR_4, VAR_32, VAR_30,
VAR_31, FALSE, VAR_9, VAR_10, NULL, &VAR_6);
if (VAR_5 == NULL) {
VAR_7 = VAR_33;
goto end;
}
if ((VAR_13 = wtap_file_size(VAR_0, VAR_1)) == -1) {
VAR_7 = VAR_33;
goto end;
}
if (VAR_13 > VAR_34) {
*VAR_1 = VAR_35;
*VAR_2 = g_strdup_printf(""mime_file: File has %"" VAR_36 ""d-byte packet, bigger than maximum of %u"",
VAR_13, VAR_34);
VAR_7 = VAR_33;
goto end;
}
VAR_14 = (int)VAR_13;
VAR_15 = (guint8 *)g_malloc(VAR_14 + 12);
VAR_15[0] = 0;
VAR_15[1] = 12; 
VAR_15[2] = 0;
VAR_15[3] = 4;
VAR_15[4] = 0x78; 
VAR_15[5] = 0x6d; 
VAR_15[6] = 0x6c; 
VAR_15[7] = 0;
VAR_15[8] = 0;
VAR_15[9] = 0;
VAR_15[10] = 0;
VAR_15[11] = 0;
if (!wtap_read_bytes(VAR_0->fh, VAR_15 + 12, VAR_14, &VAR_16, &VAR_17)){
VAR_7 = VAR_33;
goto end;
}
memset(&VAR_18, 0, sizeof(struct wtap_pkthdr));
VAR_24 = VAR_15 + 12;
VAR_24 = strstr(VAR_24, ""<fileHeader"");
VAR_24 = VAR_24 + 11;
VAR_24 = strstr(VAR_24, ""<traceCollec beginTime=\"""");
VAR_24 = VAR_24 + 24;
VAR_24 = nettrace_parse_begin_time(VAR_24, &VAR_18);
VAR_19 = VAR_18.ts.secs;
VAR_18.rec_type = VAR_37;
VAR_18.caplen = VAR_14 + 12;
VAR_18.len = VAR_14 + 12;
if (!wtap_dump(VAR_5, &VAR_18, VAR_15, &VAR_16, &VAR_17)) {
switch (VAR_16) {
case VAR_38:
g_free(VAR_17);
VAR_17 = NULL;
break;
default:
break;
}
VAR_7 = VAR_33;
goto end;
}
while ((VAR_24 = strstr(VAR_24, ""<msg"")) != NULL){
wtap_open_return_val VAR_39;
VAR_28.precense_flags = 0;
VAR_28.ptype = VAR_29;
VAR_24 = VAR_24 + 4;
VAR_25 = strstr(VAR_24, ""</msg>"");
if (!VAR_25){
break;
}
VAR_25 = VAR_25 + 6;
VAR_27 = VAR_24;
VAR_22 = 0;
VAR_24 = strstr(VAR_24, ""changeTime"");
if ((VAR_24)&&(VAR_24 < VAR_25)){
VAR_24 = VAR_24 + 12;
VAR_20 = sscanf(VAR_24, ""%u.%u"",&VAR_21, &VAR_22);
if ((VAR_20 == 2) && (VAR_19 != 0)) {
VAR_19 = VAR_19 + VAR_21;
}
} else {
VAR_24 = VAR_27;
}
VAR_27 = VAR_24;
VAR_24 = strstr(VAR_24, ""<initiator>"");
if ((VAR_24) && (VAR_24 < VAR_25)) {
VAR_24 = VAR_24 + 11;
VAR_26 = strstr(VAR_24, ""</initiator>"");
VAR_24 = strstr(VAR_24, ""address"");
if ((VAR_24) && (VAR_24 < VAR_26)) {
guint VAR_40, VAR_41, VAR_42, VAR_43, VAR_44;
char VAR_45[5];
VAR_24 = VAR_24 + 7;
VAR_20 = sscanf(VAR_24, ""%*s %3u.%3u.%3u.%3u, %*s %*s %5u, %*s %*s %4s"",
&VAR_40, &VAR_41, &VAR_42, &VAR_43, &VAR_44, VAR_45);
if (VAR_20 == 6) {
VAR_28.precense_flags = VAR_28.precense_flags + VAR_46 + VAR_47;
VAR_28.src_ipv4_d1 = VAR_40;
VAR_28.src_ipv4_d2 = VAR_41;
VAR_28.src_ipv4_d3 = VAR_42;
VAR_28.src_ipv4_d4 = VAR_43;
if(VAR_28.ptype == VAR_29){
if (g_ascii_strncasecmp(VAR_45, ""udp"", 3) == 0)  VAR_28.ptype = VAR_48;
else if (g_ascii_strncasecmp(VAR_45, ""tcp"", 3) == 0)  VAR_28.ptype = VAR_49;
else if (g_ascii_strncasecmp(VAR_45, ""sctp"", 4) == 0)  VAR_28.ptype = VAR_50;
}
VAR_28.src_port = VAR_44;
} else {
g_warning(""scan_found:%u, %u.%u.%u.%u Port %u transport %s"", VAR_20, VAR_40, VAR_41, VAR_42, VAR_43, VAR_44, VAR_45);
}
} else {
VAR_24 = VAR_26;
}
} else {
VAR_24 = VAR_27;
}
VAR_27 = VAR_24;
VAR_24 = strstr(VAR_24, ""<target>"");
if ((VAR_24) && (VAR_24 < VAR_25)) {
VAR_24 = VAR_24 + 8;
VAR_26 = strstr(VAR_24, ""</target>"");
VAR_24 = strstr(VAR_24, ""address"");
if ((VAR_24) && (VAR_24 < VAR_26)) {
guint VAR_40, VAR_41, VAR_42, VAR_43, VAR_44;
char VAR_45[5];
VAR_24 = VAR_24 + 7;
VAR_20 = sscanf(VAR_24, ""%*s %3u.%3u.%3u.%3u, %*s %*s %5u, %*s %*s %4s"",
&VAR_40, &VAR_41, &VAR_42, &VAR_43, &VAR_44, VAR_45);
if (VAR_20 == 6) {
VAR_28.precense_flags = VAR_28.precense_flags + VAR_51 + VAR_52;
VAR_28.dst_ipv4_d1 = VAR_40;
VAR_28.dst_ipv4_d2 = VAR_41;
VAR_28.dst_ipv4_d3 = VAR_42;
VAR_28.dst_ipv4_d4 = VAR_43;
if (VAR_28.ptype == VAR_29) {
if (g_ascii_strncasecmp(VAR_45, ""udp"", 3) == 0)  VAR_28.ptype = VAR_48;
else if (g_ascii_strncasecmp(VAR_45, ""tcp"", 3) == 0)  VAR_28.ptype = VAR_49;
else if (g_ascii_strncasecmp(VAR_45, ""sctp"", 4) == 0)  VAR_28.ptype = VAR_50;
}
VAR_28.dst_port = VAR_44;
} else {
g_warning(""scan_found:%u, %u.%u.%u.%u Port %u transport %s"", VAR_20, VAR_40, VAR_41, VAR_42, VAR_43, VAR_44, VAR_45);
}
}
else {
VAR_24 = VAR_26;
}
} else {
VAR_24 = VAR_27;
}
VAR_24 = strstr(VAR_24, ""<rawMsg"");
if (!VAR_24){
VAR_24 = VAR_25;
continue;
}
VAR_24 = VAR_24 + 7;
VAR_39 = write_packet_data(VAR_5, &VAR_18, &VAR_16, &VAR_17, VAR_24, VAR_19, VAR_22, &VAR_28);
if (VAR_39 != VAR_8){
VAR_7 = VAR_39;
goto end;
}
VAR_24 = VAR_25;
}
if (!wtap_dump_close(VAR_5, VAR_1)){
VAR_7 = VAR_33;
goto end;
}
if (VAR_0->random_fh){
VAR_23 = TRUE;
}
VAR_3->wth_tmp_file =
wtap_open_offline(VAR_3->tmpname, VAR_53, VAR_1, VAR_2, VAR_23);
if (!VAR_3->wth_tmp_file){
VAR_7 = VAR_33;
goto end;
}
end:
g_free(VAR_17);
g_free(VAR_15);
wtap_free_shb(VAR_9);
wtap_free_idb_info(VAR_10);
return VAR_7;
}",wireshark/140aad08e081489b5cdb715cb5bca01db856fded/nettrace_3gpp_32_423.c/vul/before/0.json,"static wtap_open_return_val
create_temp_pcapng_file(wtap *wth, int *err, gchar **err_info, nettrace_3gpp_32_423_file_info_t *file_info)
{
	int import_file_fd;
	wtap_dumper* wdh_exp_pdu;
	int   exp_pdu_file_err;
	wtap_open_return_val result = WTAP_OPEN_MINE;

	/* pcapng defs */
	wtapng_section_t            *shb_hdr = NULL;
	wtapng_iface_descriptions_t *idb_inf = NULL;
	wtapng_if_descr_t            int_data;
	GString                     *os_info_str;
	gint64 file_size;
	int packet_size;
	guint8 *packet_buf = NULL;
	int wrt_err;
	gchar *wrt_err_info = NULL;
	struct wtap_pkthdr phdr;
	time_t start_time;
	int scan_found;
	unsigned second, ms;
	gboolean do_random = FALSE;
	char *curr_pos, *next_msg_pos, *next_pos, *prev_pos;
	/* Info to build exported_pdu tags*/
	exported_pdu_info_t  exported_pdu_info;

	exported_pdu_info.precense_flags = 0;
	exported_pdu_info.src_ipv4_d1 = 0;
	exported_pdu_info.src_ipv4_d2 = 0;
	exported_pdu_info.src_ipv4_d3 = 0;
	exported_pdu_info.src_ipv4_d4 = 0;
	exported_pdu_info.ptype = PT_NONE;
	exported_pdu_info.src_port = 0;
	exported_pdu_info.dst_ipv4_d1 = 0;
	exported_pdu_info.dst_ipv4_d2 = 0;
	exported_pdu_info.dst_ipv4_d3 = 0;
	exported_pdu_info.dst_ipv4_d4 = 0;
	exported_pdu_info.dst_port = 0;

	import_file_fd = create_tempfile(&(file_info->tmpname), ""Wireshark_PDU_"");

	/* Now open a file and dump to it */
	/* Create data for SHB  */
	os_info_str = g_string_new("""");
	get_os_version_info(os_info_str);

	shb_hdr = g_new(wtapng_section_t, 1);
	shb_hdr->section_length = -1;
	/* options */
	shb_hdr->opt_comment = g_strdup_printf(""File converted to Exported PDU format during opening"");
	/*
	* UTF-8 string containing the description of the hardware used to create
	* this section.
	*/
	shb_hdr->shb_hardware = NULL;
	/*
	* UTF-8 string containing the name of the operating system used to create
	* this section.
	*/
	shb_hdr->shb_os = g_string_free(os_info_str, FALSE);
	/*
	* UTF-8 string containing the name of the application used to create
	* this section.
	*/
	shb_hdr->shb_user_appl = g_strdup_printf(""Wireshark %s"", get_ws_vcs_version_info());

	/* Create fake IDB info */
	idb_inf = g_new(wtapng_iface_descriptions_t, 1);
	idb_inf->interface_data = g_array_new(FALSE, FALSE, sizeof(wtapng_if_descr_t));

	/* create the fake interface data */
	int_data.wtap_encap = WTAP_ENCAP_WIRESHARK_UPPER_PDU;
	int_data.time_units_per_second = 1000000; /* default microsecond resolution */
	int_data.link_type = wtap_wtap_encap_to_pcap_encap(WTAP_ENCAP_WIRESHARK_UPPER_PDU);
	int_data.snap_len = WTAP_MAX_PACKET_SIZE;
	int_data.if_name = g_strdup(""Fake IF"");
	int_data.opt_comment = NULL;
	int_data.if_description = NULL;
	int_data.if_speed = 0;
	int_data.if_tsresol = 6;
	int_data.if_filter_str = NULL;
	int_data.bpf_filter_len = 0;
	int_data.if_filter_bpf_bytes = NULL;
	int_data.if_os = NULL;
	int_data.if_fcslen = -1;
	int_data.num_stat_entries = 0;          /* Number of ISB:s */
	int_data.interface_statistics = NULL;

	g_array_append_val(idb_inf->interface_data, int_data);

	wdh_exp_pdu = wtap_dump_fdopen_ng(import_file_fd, WTAP_FILE_TYPE_SUBTYPE_PCAPNG, WTAP_ENCAP_WIRESHARK_UPPER_PDU,
					  WTAP_MAX_PACKET_SIZE, FALSE, shb_hdr, idb_inf, NULL, &exp_pdu_file_err);
	if (wdh_exp_pdu == NULL) {
		result = WTAP_OPEN_ERROR;
		goto end;
	}

	/* OK we've opend a new pcap-ng file and written the headers, time to do the packets, strt by finding the file size */

	if ((file_size = wtap_file_size(wth, err)) == -1) {
		result = WTAP_OPEN_ERROR;
		goto end;
	}

	if (file_size > MAX_FILE_SIZE) {
		/*
		* Don't blow up trying to allocate space for an
		* immensely-large file.
		*/
		*err = WTAP_ERR_BAD_FILE;
		*err_info = g_strdup_printf(""mime_file: File has %"" G_GINT64_MODIFIER ""d-byte packet, bigger than maximum of %u"",
			file_size, MAX_FILE_SIZE);
		result = WTAP_OPEN_ERROR;
		goto end;
	}
	packet_size = (int)file_size;
	/* Allocate the packet buffer
	* (the whole file + Exported PDU tag ""protocol"" and
	* the string ""xml"" + 1 filler to end on 4 byte boundary for the tag
	* + End of options 4 bytes
	*/
	/* XXX add the length of exported bdu tag(s) here */
	packet_buf = (guint8 *)g_malloc(packet_size + 12+1);
    /* Terminate buffer*/
    packet_buf[packet_size + 12] = 0;

	packet_buf[0] = 0;
	packet_buf[1] = 12; /* EXP_PDU_TAG_PROTO_NAME */
	packet_buf[2] = 0;
	packet_buf[3] = 4;
	packet_buf[4] = 0x78; /* ""x"" */
	packet_buf[5] = 0x6d; /* ""m"" */
	packet_buf[6] = 0x6c; /* ""l"" */
	packet_buf[7] = 0;
	/* End of options */
	packet_buf[8] = 0;
	packet_buf[9] = 0;
	packet_buf[10] = 0;
	packet_buf[11] = 0;


	if (!wtap_read_bytes(wth->fh, packet_buf + 12, packet_size, &wrt_err, &wrt_err_info)){
		result = WTAP_OPEN_ERROR;
		goto end;
	}

	/* Create the packet header */
	memset(&phdr, 0, sizeof(struct wtap_pkthdr));

	/* Read the file header of the input file, currently we only need the beginTime*/

	/* Advance *packet_buf to point at the raw file data */
	curr_pos = packet_buf + 12;
	/* Find the file header */
	curr_pos = strstr(curr_pos, ""<fileHeader"");
	curr_pos = curr_pos + 11;

	/* Find start time */
	curr_pos = strstr(curr_pos, ""<traceCollec beginTime=\"""");
	curr_pos = curr_pos + 24;

	curr_pos = nettrace_parse_begin_time(curr_pos, &phdr);

	start_time = phdr.ts.secs;

	/* set rest of the pkt hdr data */
	phdr.rec_type = REC_TYPE_PACKET;

	phdr.caplen = packet_size + 12;
	phdr.len = packet_size + 12;


	/* XXX: report errors! */
	if (!wtap_dump(wdh_exp_pdu, &phdr, packet_buf, &wrt_err, &wrt_err_info)) {
		switch (wrt_err) {

		case WTAP_ERR_UNWRITABLE_REC_DATA:
			g_free(wrt_err_info);
			wrt_err_info = NULL;
			break;

		default:
			break;
		}
		result = WTAP_OPEN_ERROR;
		goto end;
	}


	/* Lets add the raw messages as packets after the main ""packet"" with the whole file */
	while ((curr_pos = strstr(curr_pos, ""<msg"")) != NULL){
		wtap_open_return_val temp_val;
		/* Clear for each itteration */
		exported_pdu_info.precense_flags = 0;
		exported_pdu_info.ptype = PT_NONE;

		curr_pos = curr_pos + 4;
		next_msg_pos = strstr(curr_pos, ""</msg>"");
		if (!next_msg_pos){
			/* Somethings wrong, bail out */
			break;
		}
		next_msg_pos = next_msg_pos + 6;
		/* Check if we have a time stamp ""changeTime""
		 * expressed in number of seconds and milliseconds (nbsec.ms).
		 */
		prev_pos = curr_pos;
		ms = 0;
		curr_pos = strstr(curr_pos, ""changeTime"");
		/* Check if we have the tag or if we pased the end of the current message */
		if ((curr_pos)&&(curr_pos < next_msg_pos)){
			curr_pos = curr_pos + 12;
			scan_found = sscanf(curr_pos, ""%u.%u"",&second, &ms);

			if ((scan_found == 2) && (start_time != 0)) {
				start_time = start_time + second;
			}
		} else {
			curr_pos = prev_pos;
		}
		/* Check if we have ""<initiator>""
		*  It might contain an address
		*/
		prev_pos = curr_pos;
		curr_pos = strstr(curr_pos, ""<initiator>"");
		/* Check if we have the tag or if we pased the end of the current message */
		if ((curr_pos) && (curr_pos < next_msg_pos)) {
			curr_pos = curr_pos + 11;
			next_pos = strstr(curr_pos, ""</initiator>"");
			/* Find address*/
			curr_pos = strstr(curr_pos, ""address"");
			if ((curr_pos) && (curr_pos < next_pos)) {
				guint d1, d2, d3, d4, port;
				char transp_str[5];

				curr_pos = curr_pos + 7;
				/* Excample from one trace, unsure if it's generic...
				 * {address == 192.168.73.1, port == 5062, transport == Udp}
				 */
				scan_found = sscanf(curr_pos, ""%*s %3u.%3u.%3u.%3u, %*s %*s %5u, %*s %*s %4s"",
					&d1, &d2, &d3, &d4, &port, transp_str);
				if (scan_found == 6) {
					exported_pdu_info.precense_flags = exported_pdu_info.precense_flags + EXP_PDU_TAG_IP_SRC_BIT + EXP_PDU_TAG_SRC_PORT_BIT;
					exported_pdu_info.src_ipv4_d1 = d1;
					exported_pdu_info.src_ipv4_d2 = d2;
					exported_pdu_info.src_ipv4_d3 = d3;
					exported_pdu_info.src_ipv4_d4 = d4;

					/* Only add port_type once */
					if(exported_pdu_info.ptype == PT_NONE){
						if (g_ascii_strncasecmp(transp_str, ""udp"", 3) == 0)  exported_pdu_info.ptype = PT_UDP;
						else if (g_ascii_strncasecmp(transp_str, ""tcp"", 3) == 0)  exported_pdu_info.ptype = PT_TCP;
						else if (g_ascii_strncasecmp(transp_str, ""sctp"", 4) == 0)  exported_pdu_info.ptype = PT_SCTP;
					}
					exported_pdu_info.src_port = port;
				} else {
					g_warning(""scan_found:%u, %u.%u.%u.%u Port %u transport %s"", scan_found, d1, d2, d3, d4, port, transp_str);
				}
			} else {
				/* address not found*/
				curr_pos = next_pos;
			}
		} else {
			/*""<initiator>"" not found */
			curr_pos = prev_pos;
		}

		/* Check if we have ""<target>""
		*  It might contain an address
		*/
		prev_pos = curr_pos;
		curr_pos = strstr(curr_pos, ""<target>"");
		/* Check if we have the tag or if we pased the end of the current message */
		if ((curr_pos) && (curr_pos < next_msg_pos)) {
			curr_pos = curr_pos + 8;
			next_pos = strstr(curr_pos, ""</target>"");
			/* Find address*/
			curr_pos = strstr(curr_pos, ""address"");
			if ((curr_pos) && (curr_pos < next_pos)) {
				guint d1, d2, d3, d4, port;
				char transp_str[5];

				curr_pos = curr_pos + 7;
				/* Excample from one trace, unsure if it's generic...
				* {address == 192.168.73.1, port == 5062, transport == Udp}
				*/
				scan_found = sscanf(curr_pos, ""%*s %3u.%3u.%3u.%3u, %*s %*s %5u, %*s %*s %4s"",
					&d1, &d2, &d3, &d4, &port, transp_str);
				if (scan_found == 6) {
					exported_pdu_info.precense_flags = exported_pdu_info.precense_flags + EXP_PDU_TAG_IP_DST_BIT + EXP_PDU_TAG_DST_PORT_BIT;
					exported_pdu_info.dst_ipv4_d1 = d1;
					exported_pdu_info.dst_ipv4_d2 = d2;
					exported_pdu_info.dst_ipv4_d3 = d3;
					exported_pdu_info.dst_ipv4_d4 = d4;
					/* Only add port_type once */
					if (exported_pdu_info.ptype == PT_NONE) {
						if (g_ascii_strncasecmp(transp_str, ""udp"", 3) == 0)  exported_pdu_info.ptype = PT_UDP;
						else if (g_ascii_strncasecmp(transp_str, ""tcp"", 3) == 0)  exported_pdu_info.ptype = PT_TCP;
						else if (g_ascii_strncasecmp(transp_str, ""sctp"", 4) == 0)  exported_pdu_info.ptype = PT_SCTP;
					}
					exported_pdu_info.dst_port = port;
				} else {
					g_warning(""scan_found:%u, %u.%u.%u.%u Port %u transport %s"", scan_found, d1, d2, d3, d4, port, transp_str);
				}
			}
			else {
				/* address not found */
				curr_pos = next_pos;
			}
		} else {
			/* ""<target>"" not found */
			curr_pos = prev_pos;
		}

		/* Do we have a raw msg?) */
		curr_pos = strstr(curr_pos, ""<rawMsg"");
		if (!curr_pos){
			/* No rawMsg, continue */
			curr_pos = next_msg_pos;
			continue;
		}
		curr_pos = curr_pos + 7;
		/* Add the raw msg*/
		temp_val = write_packet_data(wdh_exp_pdu, &phdr, &wrt_err, &wrt_err_info, curr_pos, start_time, ms, &exported_pdu_info);
		if (temp_val != WTAP_OPEN_MINE){
			result = temp_val;
			goto end;
		}
		curr_pos = next_msg_pos;
	}

	/* Close the written file*/
	if (!wtap_dump_close(wdh_exp_pdu, err)){
		result = WTAP_OPEN_ERROR;
		goto end;
	}

	/* Now open the file for reading */

	/* Find out if random read was requested */
	if (wth->random_fh){
		do_random = TRUE;
	}
	file_info->wth_tmp_file =
		wtap_open_offline(file_info->tmpname, WTAP_TYPE_AUTO, err, err_info, do_random);

	if (!file_info->wth_tmp_file){
		result = WTAP_OPEN_ERROR;
		goto end;
	}

end:
	g_free(wrt_err_info);
	g_free(packet_buf);
	wtap_free_shb(shb_hdr);
	wtap_free_idb_info(idb_inf);

	return result;
}","static wtap_open_return_val
create_temp_pcapng_file(wtap *VAR_0, int *VAR_1, gchar **VAR_2, nettrace_3gpp_32_423_file_info_t *VAR_3)
{
	int VAR_4;
	wtap_dumper* VAR_5;
	int   VAR_6;
	wtap_open_return_val VAR_7 = VAR_8;

	/* COMMENT_0 */
	wtapng_section_t            *VAR_9 = NULL;
	wtapng_iface_descriptions_t *VAR_10 = NULL;
	wtapng_if_descr_t            VAR_11;
	GString                     *VAR_12;
	gint64 VAR_13;
	int VAR_14;
	guint8 *VAR_15 = NULL;
	int VAR_16;
	gchar *VAR_17 = NULL;
	struct wtap_pkthdr VAR_18;
	time_t VAR_19;
	int VAR_20;
	unsigned VAR_21, VAR_22;
	gboolean VAR_23 = FALSE;
	char *VAR_24, *VAR_25, *VAR_26, *VAR_27;
	/* COMMENT_1 */
	exported_pdu_info_t  VAR_28;

	VAR_28.precense_flags = 0;
	VAR_28.src_ipv4_d1 = 0;
	VAR_28.src_ipv4_d2 = 0;
	VAR_28.src_ipv4_d3 = 0;
	VAR_28.src_ipv4_d4 = 0;
	VAR_28.ptype = VAR_29;
	VAR_28.src_port = 0;
	VAR_28.dst_ipv4_d1 = 0;
	VAR_28.dst_ipv4_d2 = 0;
	VAR_28.dst_ipv4_d3 = 0;
	VAR_28.dst_ipv4_d4 = 0;
	VAR_28.dst_port = 0;

	VAR_4 = create_tempfile(&(VAR_3->tmpname), ""Wireshark_PDU_"");

	/* COMMENT_2 */
	/* COMMENT_3 */
	VAR_12 = g_string_new("""");
	get_os_version_info(VAR_12);

	VAR_9 = g_new(wtapng_section_t, 1);
	VAR_9->section_length = -1;
	/* COMMENT_4 */
	VAR_9->opt_comment = g_strdup_printf(""File converted to Exported PDU format during opening"");
	/* COMMENT_5 */
                                                                         
                
   
	VAR_9->shb_hardware = NULL;
	/* COMMENT_9 */
                                                                          
                
   
	VAR_9->shb_os = g_string_free(VAR_12, FALSE);
	/* COMMENT_13 */
                                                                     
                
   
	VAR_9->shb_user_appl = g_strdup_printf(""Wireshark %s"", get_ws_vcs_version_info());

	/* COMMENT_17 */
	VAR_10 = g_new(wtapng_iface_descriptions_t, 1);
	VAR_10->interface_data = g_array_new(FALSE, FALSE, sizeof(wtapng_if_descr_t));

	/* COMMENT_18 */
	VAR_11.wtap_encap = VAR_30;
	VAR_11.time_units_per_second = 1000000; /* COMMENT_19 */
	VAR_11.link_type = wtap_wtap_encap_to_pcap_encap(VAR_30);
	VAR_11.snap_len = VAR_31;
	VAR_11.if_name = g_strdup(""Fake IF"");
	VAR_11.opt_comment = NULL;
	VAR_11.if_description = NULL;
	VAR_11.if_speed = 0;
	VAR_11.if_tsresol = 6;
	VAR_11.if_filter_str = NULL;
	VAR_11.bpf_filter_len = 0;
	VAR_11.if_filter_bpf_bytes = NULL;
	VAR_11.if_os = NULL;
	VAR_11.if_fcslen = -1;
	VAR_11.num_stat_entries = 0;          /* COMMENT_20 */
	VAR_11.interface_statistics = NULL;

	g_array_append_val(VAR_10->interface_data, VAR_11);

	VAR_5 = wtap_dump_fdopen_ng(VAR_4, VAR_32, VAR_30,
					  VAR_31, FALSE, VAR_9, VAR_10, NULL, &VAR_6);
	if (VAR_5 == NULL) {
		VAR_7 = VAR_33;
		goto end;
	}

	/* COMMENT_21 */

	if ((VAR_13 = wtap_file_size(VAR_0, VAR_1)) == -1) {
		VAR_7 = VAR_33;
		goto end;
	}

	if (VAR_13 > VAR_34) {
		/* COMMENT_22 */
                                                 
                         
    
		*VAR_1 = VAR_35;
		*VAR_2 = g_strdup_printf(""mime_file: File has %"" VAR_36 ""d-byte packet, bigger than maximum of %u"",
			VAR_13, VAR_34);
		VAR_7 = VAR_33;
		goto end;
	}
	VAR_14 = (int)VAR_13;
	/* COMMENT_26 */
                                                    
                                                                    
                           
   
	/* COMMENT_31 */
	VAR_15 = (guint8 *)g_malloc(VAR_14 + 12+1);
    /* COMMENT_32 */
    VAR_15[VAR_14 + 12] = 0;

	VAR_15[0] = 0;
	VAR_15[1] = 12; /* COMMENT_33 */
	VAR_15[2] = 0;
	VAR_15[3] = 4;
	VAR_15[4] = 0x78; /* COMMENT_34 */
	VAR_15[5] = 0x6d; /* COMMENT_35 */
	VAR_15[6] = 0x6c; /* COMMENT_36 */
	VAR_15[7] = 0;
	/* COMMENT_37 */
	VAR_15[8] = 0;
	VAR_15[9] = 0;
	VAR_15[10] = 0;
	VAR_15[11] = 0;


	if (!wtap_read_bytes(VAR_0->fh, VAR_15 + 12, VAR_14, &VAR_16, &VAR_17)){
		VAR_7 = VAR_33;
		goto end;
	}

	/* COMMENT_38 */
	memset(&VAR_18, 0, sizeof(struct wtap_pkthdr));

	/* COMMENT_39 */

	/* COMMENT_40 */
	VAR_24 = VAR_15 + 12;
	/* COMMENT_41 */
	VAR_24 = strstr(VAR_24, ""<fileHeader"");
	VAR_24 = VAR_24 + 11;

	/* COMMENT_42 */
	VAR_24 = strstr(VAR_24, ""<traceCollec beginTime=\"""");
	VAR_24 = VAR_24 + 24;

	VAR_24 = nettrace_parse_begin_time(VAR_24, &VAR_18);

	VAR_19 = VAR_18.ts.secs;

	/* COMMENT_43 */
	VAR_18.rec_type = VAR_37;

	VAR_18.caplen = VAR_14 + 12;
	VAR_18.len = VAR_14 + 12;


	/* COMMENT_44 */
	if (!wtap_dump(VAR_5, &VAR_18, VAR_15, &VAR_16, &VAR_17)) {
		switch (VAR_16) {

		case VAR_38:
			g_free(VAR_17);
			VAR_17 = NULL;
			break;

		default:
			break;
		}
		VAR_7 = VAR_33;
		goto end;
	}


	/* COMMENT_45 */
	while ((VAR_24 = strstr(VAR_24, ""<msg"")) != NULL){
		wtap_open_return_val VAR_39;
		/* COMMENT_46 */
		VAR_28.precense_flags = 0;
		VAR_28.ptype = VAR_29;

		VAR_24 = VAR_24 + 4;
		VAR_25 = strstr(VAR_24, ""</msg>"");
		if (!VAR_25){
			/* COMMENT_47 */
			break;
		}
		VAR_25 = VAR_25 + 6;
		/* COMMENT_48 */
                                                                
     
		VAR_27 = VAR_24;
		VAR_22 = 0;
		VAR_24 = strstr(VAR_24, ""changeTime"");
		/* COMMENT_51 */
		if ((VAR_24)&&(VAR_24 < VAR_25)){
			VAR_24 = VAR_24 + 12;
			VAR_20 = sscanf(VAR_24, ""%u.%u"",&VAR_21, &VAR_22);

			if ((VAR_20 == 2) && (VAR_19 != 0)) {
				VAR_19 = VAR_19 + VAR_21;
			}
		} else {
			VAR_24 = VAR_27;
		}
		/* COMMENT_52 */
                                
    
		VAR_27 = VAR_24;
		VAR_24 = strstr(VAR_24, ""<initiator>"");
		/* COMMENT_51 */
		if ((VAR_24) && (VAR_24 < VAR_25)) {
			VAR_24 = VAR_24 + 11;
			VAR_26 = strstr(VAR_24, ""</initiator>"");
			/* COMMENT_55 */
			VAR_24 = strstr(VAR_24, ""address"");
			if ((VAR_24) && (VAR_24 < VAR_26)) {
				guint VAR_40, VAR_41, VAR_42, VAR_43, VAR_44;
				char VAR_45[5];

				VAR_24 = VAR_24 + 7;
				/* COMMENT_56 */
                                                                
       
				VAR_20 = sscanf(VAR_24, ""%*s %3u.%3u.%3u.%3u, %*s %*s %5u, %*s %*s %4s"",
					&VAR_40, &VAR_41, &VAR_42, &VAR_43, &VAR_44, VAR_45);
				if (VAR_20 == 6) {
					VAR_28.precense_flags = VAR_28.precense_flags + VAR_46 + VAR_47;
					VAR_28.src_ipv4_d1 = VAR_40;
					VAR_28.src_ipv4_d2 = VAR_41;
					VAR_28.src_ipv4_d3 = VAR_42;
					VAR_28.src_ipv4_d4 = VAR_43;

					/* COMMENT_59 */
					if(VAR_28.ptype == VAR_29){
						if (g_ascii_strncasecmp(VAR_45, ""udp"", 3) == 0)  VAR_28.ptype = VAR_48;
						else if (g_ascii_strncasecmp(VAR_45, ""tcp"", 3) == 0)  VAR_28.ptype = VAR_49;
						else if (g_ascii_strncasecmp(VAR_45, ""sctp"", 4) == 0)  VAR_28.ptype = VAR_50;
					}
					VAR_28.src_port = VAR_44;
				} else {
					g_warning(""scan_found:%u, %u.%u.%u.%u Port %u transport %s"", VAR_20, VAR_40, VAR_41, VAR_42, VAR_43, VAR_44, VAR_45);
				}
			} else {
				/* COMMENT_60 */
				VAR_24 = VAR_26;
			}
		} else {
			/* COMMENT_61 */
			VAR_24 = VAR_27;
		}

		/* COMMENT_62 */
                                
    
		VAR_27 = VAR_24;
		VAR_24 = strstr(VAR_24, ""<target>"");
		/* COMMENT_51 */
		if ((VAR_24) && (VAR_24 < VAR_25)) {
			VAR_24 = VAR_24 + 8;
			VAR_26 = strstr(VAR_24, ""</target>"");
			/* COMMENT_55 */
			VAR_24 = strstr(VAR_24, ""address"");
			if ((VAR_24) && (VAR_24 < VAR_26)) {
				guint VAR_40, VAR_41, VAR_42, VAR_43, VAR_44;
				char VAR_45[5];

				VAR_24 = VAR_24 + 7;
				/* COMMENT_65 */
                                                               
      
				VAR_20 = sscanf(VAR_24, ""%*s %3u.%3u.%3u.%3u, %*s %*s %5u, %*s %*s %4s"",
					&VAR_40, &VAR_41, &VAR_42, &VAR_43, &VAR_44, VAR_45);
				if (VAR_20 == 6) {
					VAR_28.precense_flags = VAR_28.precense_flags + VAR_51 + VAR_52;
					VAR_28.dst_ipv4_d1 = VAR_40;
					VAR_28.dst_ipv4_d2 = VAR_41;
					VAR_28.dst_ipv4_d3 = VAR_42;
					VAR_28.dst_ipv4_d4 = VAR_43;
					/* COMMENT_59 */
					if (VAR_28.ptype == VAR_29) {
						if (g_ascii_strncasecmp(VAR_45, ""udp"", 3) == 0)  VAR_28.ptype = VAR_48;
						else if (g_ascii_strncasecmp(VAR_45, ""tcp"", 3) == 0)  VAR_28.ptype = VAR_49;
						else if (g_ascii_strncasecmp(VAR_45, ""sctp"", 4) == 0)  VAR_28.ptype = VAR_50;
					}
					VAR_28.dst_port = VAR_44;
				} else {
					g_warning(""scan_found:%u, %u.%u.%u.%u Port %u transport %s"", VAR_20, VAR_40, VAR_41, VAR_42, VAR_43, VAR_44, VAR_45);
				}
			}
			else {
				/* COMMENT_68 */
				VAR_24 = VAR_26;
			}
		} else {
			/* COMMENT_69 */
			VAR_24 = VAR_27;
		}

		/* COMMENT_70 */
		VAR_24 = strstr(VAR_24, ""<rawMsg"");
		if (!VAR_24){
			/* COMMENT_71 */
			VAR_24 = VAR_25;
			continue;
		}
		VAR_24 = VAR_24 + 7;
		/* COMMENT_72 */
		VAR_39 = write_packet_data(VAR_5, &VAR_18, &VAR_16, &VAR_17, VAR_24, VAR_19, VAR_22, &VAR_28);
		if (VAR_39 != VAR_8){
			VAR_7 = VAR_39;
			goto end;
		}
		VAR_24 = VAR_25;
	}

	/* COMMENT_73 */
	if (!wtap_dump_close(VAR_5, VAR_1)){
		VAR_7 = VAR_33;
		goto end;
	}

	/* COMMENT_74 */

	/* COMMENT_75 */
	if (VAR_0->random_fh){
		VAR_23 = TRUE;
	}
	VAR_3->wth_tmp_file =
		wtap_open_offline(VAR_3->tmpname, VAR_53, VAR_1, VAR_2, VAR_23);

	if (!VAR_3->wth_tmp_file){
		VAR_7 = VAR_33;
		goto end;
	}

end:
	g_free(VAR_17);
	g_free(VAR_15);
	wtap_free_shb(VAR_9);
	wtap_free_idb_info(VAR_10);

	return VAR_7;
}",wireshark/140aad08e081489b5cdb715cb5bca01db856fded/nettrace_3gpp_32_423.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -121,7 +121,9 @@
 	* + End of options 4 bytes
 	*/
 	/* XXX add the length of exported bdu tag(s) here */
-	packet_buf = (guint8 *)g_malloc(packet_size + 12);
+	packet_buf = (guint8 *)g_malloc(packet_size + 12+1);
+    /* Terminate buffer*/
+    packet_buf[packet_size + 12] = 0;
 
 	packet_buf[0] = 0;
 	packet_buf[1] = 12; /* EXP_PDU_TAG_PROTO_NAME */","{'deleted_lines': ['\tpacket_buf = (guint8 *)g_malloc(packet_size + 12);'], 'added_lines': ['\tpacket_buf = (guint8 *)g_malloc(packet_size + 12+1);', '    /* Terminate buffer*/', '    packet_buf[packet_size + 12] = 0;']}",True,"wiretap/nettrace_3gpp_32_423.c in the 3GPP TS 32.423 Trace file parser in Wireshark 2.0.x before 2.0.2 does not ensure that a '\0' character is present at the end of certain strings, which allows remote attackers to cause a denial of service (stack-based buffer overflow and application crash) via a crafted file.",5.5,MEDIUM,1,test,2016-01-12T16:27:01Z,1
CVE-2016-2527,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"nettrace_3gpp_32_423 Protect from buffer overun.

Bug: 11982
Change-Id: Ib704d9128ab6427751edbf3a33f4b8fd14902562
Reviewed-on: https://code.wireshark.org/review/13233
Reviewed-by: Anders Broman <a.broman58@gmail.com>
Petri-Dish: Anders Broman <a.broman58@gmail.com>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Michael Mann <mmann78@netscape.net>",140aad08e081489b5cdb715cb5bca01db856fded,https://github.com/wireshark/wireshark/commit/140aad08e081489b5cdb715cb5bca01db856fded,wiretap/nettrace_3gpp_32_423.c,nettrace_3gpp_32_423_file_open,"wtap_open_return_val
nettrace_3gpp_32_423_file_open(wtap *wth, int *err, gchar **err_info)
{
char magic_buf[512]; 
int bytes_read;
char *curr_pos;
nettrace_3gpp_32_423_file_info_t *file_info;
wtap_open_return_val temp_val;
bytes_read = file_read(magic_buf, 512, wth->fh);
if (bytes_read < 0) {
*err = file_error(wth->fh, err_info);
return WTAP_OPEN_ERROR;
}
if (bytes_read == 0){
return WTAP_OPEN_NOT_MINE;
}
if (memcmp(magic_buf, xml_magic, sizeof(xml_magic)) != 0){
return WTAP_OPEN_NOT_MINE;
}
curr_pos = strstr(magic_buf, ""fileFormatVersion"");
if (!curr_pos){
return WTAP_OPEN_NOT_MINE;
}
curr_pos += 19;
if (memcmp(curr_pos, Threegpp_doc_no, sizeof(Threegpp_doc_no)) != 0){
return WTAP_OPEN_NOT_MINE;
}
if (file_seek(wth->fh, 0, SEEK_SET, err) == -1)
return WTAP_OPEN_ERROR;
file_info = g_new0(nettrace_3gpp_32_423_file_info_t, 1);
temp_val = create_temp_pcapng_file(wth, err, err_info, file_info);
if (temp_val != WTAP_OPEN_MINE){
return temp_val;
}
if (file_seek(wth->fh, 0, SEEK_SET, err) == -1)
return WTAP_OPEN_ERROR;
wth->shb_hdr.opt_comment = file_info->wth_tmp_file->shb_hdr.opt_comment;
wth->shb_hdr.shb_hardware = file_info->wth_tmp_file->shb_hdr.shb_hardware;
wth->shb_hdr.shb_os = file_info->wth_tmp_file->shb_hdr.shb_os;
wth->shb_hdr.shb_user_appl = file_info->wth_tmp_file->shb_hdr.shb_user_appl;
wth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_NETTRACE_3GPP_32_423;
wth->file_encap = file_info->wth_tmp_file->file_encap;
wth->file_tsprec = file_info->wth_tmp_file->file_tsprec;
wth->subtype_read = nettrace_read;
wth->subtype_seek_read = nettrace_seek_read;
wth->subtype_close = nettrace_close;
wth->snapshot_length = 0;
wth->priv = (void*)file_info;
return WTAP_OPEN_MINE;
}","wtap_open_return_val
nettrace_3gpp_32_423_file_open(wtap *VAR_0, int *VAR_1, gchar **VAR_2)
{
char VAR_3[512]; 
int VAR_4;
char *VAR_5;
nettrace_3gpp_32_423_file_info_t *VAR_6;
wtap_open_return_val VAR_7;
VAR_4 = file_read(VAR_3, 512, VAR_0->fh);
if (VAR_4 < 0) {
*VAR_1 = file_error(VAR_0->fh, VAR_2);
return VAR_8;
}
if (VAR_4 == 0){
return VAR_9;
}
if (memcmp(VAR_3, VAR_10, sizeof(VAR_10)) != 0){
return VAR_9;
}
VAR_5 = strstr(VAR_3, ""fileFormatVersion"");
if (!VAR_5){
return VAR_9;
}
VAR_5 += 19;
if (memcmp(VAR_5, VAR_11, sizeof(VAR_11)) != 0){
return VAR_9;
}
if (file_seek(VAR_0->fh, 0, VAR_12, VAR_1) == -1)
return VAR_8;
VAR_6 = g_new0(nettrace_3gpp_32_423_file_info_t, 1);
VAR_7 = create_temp_pcapng_file(VAR_0, VAR_1, VAR_2, VAR_6);
if (VAR_7 != VAR_13){
return VAR_7;
}
if (file_seek(VAR_0->fh, 0, VAR_12, VAR_1) == -1)
return VAR_8;
VAR_0->shb_hdr.opt_comment = VAR_6->wth_tmp_file->shb_hdr.opt_comment;
VAR_0->shb_hdr.shb_hardware = VAR_6->wth_tmp_file->shb_hdr.shb_hardware;
VAR_0->shb_hdr.shb_os = VAR_6->wth_tmp_file->shb_hdr.shb_os;
VAR_0->shb_hdr.shb_user_appl = VAR_6->wth_tmp_file->shb_hdr.shb_user_appl;
VAR_0->file_type_subtype = VAR_14;
VAR_0->file_encap = VAR_6->wth_tmp_file->file_encap;
VAR_0->file_tsprec = VAR_6->wth_tmp_file->file_tsprec;
VAR_0->subtype_read = VAR_15;
VAR_0->subtype_seek_read = VAR_16;
VAR_0->subtype_close = VAR_17;
VAR_0->snapshot_length = 0;
VAR_0->priv = (void*)VAR_6;
return VAR_13;
}",wireshark/140aad08e081489b5cdb715cb5bca01db856fded/nettrace_3gpp_32_423.c/vul/before/1.json,"wtap_open_return_val
nettrace_3gpp_32_423_file_open(wtap *wth, int *err, gchar **err_info)
{
	char magic_buf[512]; /* increase buffer size when needed */
	int bytes_read;
	char *curr_pos;
	nettrace_3gpp_32_423_file_info_t *file_info;
	wtap_open_return_val temp_val;


	bytes_read = file_read(magic_buf, 512, wth->fh);

	if (bytes_read < 0) {
		*err = file_error(wth->fh, err_info);
		return WTAP_OPEN_ERROR;
	}
	if (bytes_read == 0){
		return WTAP_OPEN_NOT_MINE;
	}

	if (memcmp(magic_buf, xml_magic, sizeof(xml_magic)) != 0){
		return WTAP_OPEN_NOT_MINE;
	}
	/* Protect from overrunning the buffer*/
	magic_buf[512 - 1] = 0;
	/* File header should contain something like fileFormatVersion=""32.423 V8.1.0"" */
	curr_pos = strstr(magic_buf, ""fileFormatVersion"");

	if (!curr_pos){
		return WTAP_OPEN_NOT_MINE;
	}
	curr_pos += 19;
	if (memcmp(curr_pos, Threegpp_doc_no, sizeof(Threegpp_doc_no)) != 0){
		return WTAP_OPEN_NOT_MINE;
	}

	if (file_seek(wth->fh, 0, SEEK_SET, err) == -1)
		return WTAP_OPEN_ERROR;

	/* Ok it's our file, open a temp file and do the conversion */
	file_info = g_new0(nettrace_3gpp_32_423_file_info_t, 1);
	temp_val = create_temp_pcapng_file(wth, err, err_info, file_info);

	if (temp_val != WTAP_OPEN_MINE){
		return temp_val;
	}

	if (file_seek(wth->fh, 0, SEEK_SET, err) == -1)
		return WTAP_OPEN_ERROR;

	/* Copy data from the temp file wth */
	wth->shb_hdr.opt_comment = file_info->wth_tmp_file->shb_hdr.opt_comment;
	wth->shb_hdr.shb_hardware = file_info->wth_tmp_file->shb_hdr.shb_hardware;
	wth->shb_hdr.shb_os = file_info->wth_tmp_file->shb_hdr.shb_os;
	wth->shb_hdr.shb_user_appl = file_info->wth_tmp_file->shb_hdr.shb_user_appl;

	wth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_NETTRACE_3GPP_32_423;
	wth->file_encap = file_info->wth_tmp_file->file_encap;
	wth->file_tsprec = file_info->wth_tmp_file->file_tsprec;
	wth->subtype_read = nettrace_read;
	wth->subtype_seek_read = nettrace_seek_read;
	wth->subtype_close = nettrace_close;
	wth->snapshot_length = 0;

	wth->priv = (void*)file_info;

	return WTAP_OPEN_MINE;

}","wtap_open_return_val
nettrace_3gpp_32_423_file_open(wtap *VAR_0, int *VAR_1, gchar **VAR_2)
{
	char VAR_3[512]; /* COMMENT_0 */
	int VAR_4;
	char *VAR_5;
	nettrace_3gpp_32_423_file_info_t *VAR_6;
	wtap_open_return_val VAR_7;


	VAR_4 = file_read(VAR_3, 512, VAR_0->fh);

	if (VAR_4 < 0) {
		*VAR_1 = file_error(VAR_0->fh, VAR_2);
		return VAR_8;
	}
	if (VAR_4 == 0){
		return VAR_9;
	}

	if (memcmp(VAR_3, VAR_10, sizeof(VAR_10)) != 0){
		return VAR_9;
	}
	/* COMMENT_1 */
	VAR_3[512 - 1] = 0;
	/* COMMENT_2 */
	VAR_5 = strstr(VAR_3, ""fileFormatVersion"");

	if (!VAR_5){
		return VAR_9;
	}
	VAR_5 += 19;
	if (memcmp(VAR_5, VAR_11, sizeof(VAR_11)) != 0){
		return VAR_9;
	}

	if (file_seek(VAR_0->fh, 0, VAR_12, VAR_1) == -1)
		return VAR_8;

	/* COMMENT_3 */
	VAR_6 = g_new0(nettrace_3gpp_32_423_file_info_t, 1);
	VAR_7 = create_temp_pcapng_file(VAR_0, VAR_1, VAR_2, VAR_6);

	if (VAR_7 != VAR_13){
		return VAR_7;
	}

	if (file_seek(VAR_0->fh, 0, VAR_12, VAR_1) == -1)
		return VAR_8;

	/* COMMENT_4 */
	VAR_0->shb_hdr.opt_comment = VAR_6->wth_tmp_file->shb_hdr.opt_comment;
	VAR_0->shb_hdr.shb_hardware = VAR_6->wth_tmp_file->shb_hdr.shb_hardware;
	VAR_0->shb_hdr.shb_os = VAR_6->wth_tmp_file->shb_hdr.shb_os;
	VAR_0->shb_hdr.shb_user_appl = VAR_6->wth_tmp_file->shb_hdr.shb_user_appl;

	VAR_0->file_type_subtype = VAR_14;
	VAR_0->file_encap = VAR_6->wth_tmp_file->file_encap;
	VAR_0->file_tsprec = VAR_6->wth_tmp_file->file_tsprec;
	VAR_0->subtype_read = VAR_15;
	VAR_0->subtype_seek_read = VAR_16;
	VAR_0->subtype_close = VAR_17;
	VAR_0->snapshot_length = 0;

	VAR_0->priv = (void*)VAR_6;

	return VAR_13;

}",wireshark/140aad08e081489b5cdb715cb5bca01db856fded/nettrace_3gpp_32_423.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -21,6 +21,8 @@
 	if (memcmp(magic_buf, xml_magic, sizeof(xml_magic)) != 0){
 		return WTAP_OPEN_NOT_MINE;
 	}
+	/* Protect from overrunning the buffer*/
+	magic_buf[512 - 1] = 0;
 	/* File header should contain something like fileFormatVersion=""32.423 V8.1.0"" */
 	curr_pos = strstr(magic_buf, ""fileFormatVersion"");
 ","{'deleted_lines': [], 'added_lines': ['\t/* Protect from overrunning the buffer*/', '\tmagic_buf[512 - 1] = 0;']}",True,"wiretap/nettrace_3gpp_32_423.c in the 3GPP TS 32.423 Trace file parser in Wireshark 2.0.x before 2.0.2 does not ensure that a '\0' character is present at the end of certain strings, which allows remote attackers to cause a denial of service (stack-based buffer overflow and application crash) via a crafted file.",5.5,MEDIUM,1,test,2016-01-12T16:27:01Z,1
CVE-2016-2522,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"[BER] Fix Wireshark heap-based out-of-bounds read in dissect_ber_constrained_bitstring

Bug: 11828
Change-Id: I43c493ed261e73e0f3b31892c161dcfc46071054
Reviewed-on: https://code.wireshark.org/review/13292
Petri-Dish: Anders Broman <a.broman58@gmail.com>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Anders Broman <a.broman58@gmail.com>",9b2f3f7c5c9205381cb72e42b66e97d8ed3abf63,https://github.com/wireshark/wireshark/commit/9b2f3f7c5c9205381cb72e42b66e97d8ed3abf63,epan/dissectors/packet-ber.c,proto_register_ber,"void
proto_register_ber(void)
{
static hf_register_info hf[] = {
{ &hf_ber_id_class, {
""Class"", ""ber.id.class"", FT_UINT8, BASE_DEC,
VALS(ber_class_codes), 0xc0, ""Class of BER TLV Identifier"", HFILL }},
{ &hf_ber_bitstring_padding, {
""Padding"", ""ber.bitstring.padding"", FT_UINT8, BASE_DEC,
NULL, 0x0, ""Number of unused bits in the last octet of the bitstring"", HFILL }},
{ &hf_ber_bitstring_empty, {
""Empty"", ""ber.bitstring.empty"", FT_UINT8, BASE_DEC,
NULL, 0x0, ""This is an empty bitstring"", HFILL }},
{ &hf_ber_id_pc, {
""P/C"", ""ber.id.pc"", FT_BOOLEAN, 8,
TFS(&ber_pc_codes), 0x20, ""Primitive or Constructed BER encoding"", HFILL }},
{ &hf_ber_id_uni_tag, {
""Tag"", ""ber.id.uni_tag"", FT_UINT8, BASE_DEC|BASE_EXT_STRING,
&ber_uni_tag_codes_ext, 0x1f, ""Universal tag type"", HFILL }},
{ &hf_ber_id_uni_tag_ext, {
""Tag"", ""ber.id.uni_tag"", FT_UINT32, BASE_DEC,
NULL, 0, ""Universal tag type"", HFILL }},
{ &hf_ber_id_tag, {
""Tag"", ""ber.id.tag"", FT_UINT8, BASE_DEC,
NULL, 0x1f, ""Tag value for non-Universal classes"", HFILL }},
{ &hf_ber_id_tag_ext, {
""Tag"", ""ber.id.tag"", FT_UINT32, BASE_DEC,
NULL, 0, ""Tag value for non-Universal classes"", HFILL }},
{ &hf_ber_length, {
""Length"", ""ber.length"", FT_UINT32, BASE_DEC,
NULL, 0, ""Length of contents"", HFILL }},
{ &hf_ber_unknown_OCTETSTRING, {
""OCTETSTRING"", ""ber.unknown.OCTETSTRING"", FT_BYTES, BASE_NONE,
NULL, 0, ""This is an unknown OCTETSTRING"", HFILL }},
{ &hf_ber_unknown_BER_OCTETSTRING, {
""OCTETSTRING [BER encoded]"", ""ber.unknown.OCTETSTRING"", FT_NONE, BASE_NONE,
NULL, 0, ""This is an BER encoded OCTETSTRING"", HFILL }},
{ &hf_ber_unknown_BER_primitive, {
""Primitive [BER encoded]"", ""ber.unknown.primitive"", FT_NONE, BASE_NONE,
NULL, 0, ""This is a BER encoded Primitive"", HFILL }},
{ &hf_ber_unknown_OID, {
""OID"", ""ber.unknown.OID"", FT_OID, BASE_NONE,
NULL, 0, ""This is an unknown Object Identifier"", HFILL }},
{ &hf_ber_unknown_relative_OID, {
""OID"", ""ber.unknown.relative_OID"", FT_REL_OID, BASE_NONE,
NULL, 0, ""This is an unknown relative Object Identifier"", HFILL }},
{ &hf_ber_unknown_GraphicString, {
""GRAPHICSTRING"", ""ber.unknown.GRAPHICSTRING"", FT_STRING, BASE_NONE,
NULL, 0, ""This is an unknown GRAPHICSTRING"", HFILL }},
{ &hf_ber_unknown_NumericString, {
""NumericString"", ""ber.unknown.NumericString"", FT_STRING, BASE_NONE,
NULL, 0, ""This is an unknown NumericString"", HFILL }},
{ &hf_ber_unknown_PrintableString, {
""PrintableString"", ""ber.unknown.PrintableString"", FT_STRING, BASE_NONE,
NULL, 0, ""This is an unknown PrintableString"", HFILL }},
{ &hf_ber_unknown_TeletexString, {
""TeletexString"", ""ber.unknown.TeletexString"", FT_STRING, BASE_NONE,
NULL, 0, ""This is an unknown TeletexString"", HFILL }},
{ &hf_ber_unknown_VisibleString, {
""VisibleString"", ""ber.unknown.VisibleString"", FT_STRING, BASE_NONE,
NULL, 0, ""This is an unknown VisibleString"", HFILL }},
{ &hf_ber_unknown_GeneralString, {
""GeneralString"", ""ber.unknown.GeneralString"", FT_STRING, BASE_NONE,
NULL, 0, ""This is an unknown GeneralString"", HFILL }},
{ &hf_ber_unknown_UniversalString, {
""UniversalString"", ""ber.unknown.UniversalString"", FT_STRING, BASE_NONE,
NULL, 0, ""This is an unknown UniversalString"", HFILL }},
{ &hf_ber_unknown_BMPString, {
""BMPString"", ""ber.unknown.BMPString"", FT_STRING, BASE_NONE,
NULL, 0, ""This is an unknown BMPString"", HFILL }},
{ &hf_ber_unknown_IA5String, {
""IA5String"", ""ber.unknown.IA5String"", FT_STRING, BASE_NONE,
NULL, 0, ""This is an unknown IA5String"", HFILL }},
{ &hf_ber_unknown_UTCTime, {
""UTCTime"", ""ber.unknown.UTCTime"", FT_STRING, BASE_NONE,
NULL, 0, ""This is an unknown UTCTime"", HFILL }},
{ &hf_ber_unknown_UTF8String, {
""UTF8String"", ""ber.unknown.UTF8String"", FT_STRING, BASE_NONE,
NULL, 0, ""This is an unknown UTF8String"", HFILL }},
{ &hf_ber_unknown_GeneralizedTime, {
""GeneralizedTime"", ""ber.unknown.GeneralizedTime"", FT_STRING, BASE_NONE,
NULL, 0, ""This is an unknown GeneralizedTime"", HFILL }},
{ &hf_ber_unknown_INTEGER, {
""INTEGER"", ""ber.unknown.INTEGER"", FT_INT64, BASE_DEC,
NULL, 0, ""This is an unknown INTEGER"", HFILL }},
{ &hf_ber_unknown_REAL, {
""REAL"", ""ber.unknown.REAL"", FT_DOUBLE, BASE_NONE,
NULL, 0, ""This is an unknown REAL"", HFILL }},
{ &hf_ber_unknown_BITSTRING, {
""BITSTRING"", ""ber.unknown.BITSTRING"", FT_BYTES, BASE_NONE,
NULL, 0, ""This is an unknown BITSTRING"", HFILL }},
{ &hf_ber_unknown_BOOLEAN, {
""BOOLEAN"", ""ber.unknown.BOOLEAN"", FT_UINT8, BASE_HEX,
NULL, 0, ""This is an unknown BOOLEAN"", HFILL }},
{ &hf_ber_unknown_ENUMERATED, {
""ENUMERATED"", ""ber.unknown.ENUMERATED"", FT_UINT32, BASE_DEC,
NULL, 0, ""This is an unknown ENUMERATED"", HFILL }},
{ &hf_ber_error, {
""BER Error"", ""ber.error"", FT_STRING, BASE_NONE,
NULL, 0, NULL, HFILL }},
{ &hf_ber_direct_reference,
{ ""direct-reference"", ""ber.direct_reference"",
FT_OID, BASE_NONE, NULL, 0,
""ber.OBJECT_IDENTIFIER"", HFILL }},
{ &hf_ber_indirect_reference,
{ ""indirect-reference"", ""ber.indirect_reference"",
FT_INT32, BASE_DEC, NULL, 0,
""ber.INTEGER"", HFILL }},
{ &hf_ber_data_value_descriptor,
{ ""data-value-descriptor"", ""ber.data_value_descriptor"",
FT_STRING, BASE_NONE, NULL, 0,
""ber.ObjectDescriptor"", HFILL }},
{ &hf_ber_encoding,
{ ""encoding"", ""ber.encoding"",
FT_UINT32, BASE_DEC, VALS(ber_T_encoding_vals), 0,
""ber.T_encoding"", HFILL }},
{ &hf_ber_octet_aligned,
{ ""octet-aligned"", ""ber.octet_aligned"",
FT_BYTES, BASE_NONE, NULL, 0,
""ber.T_octet_aligned"", HFILL }},
{ &hf_ber_arbitrary,
{ ""arbitrary"", ""ber.arbitrary"",
FT_BYTES, BASE_NONE, NULL, 0,
""ber.T_arbitrary"", HFILL }},
{ &hf_ber_single_ASN1_type,
{ ""single-ASN1-type"", ""ber.single_ASN1_type"",
FT_NONE, BASE_NONE, NULL, 0,
""ber.T_single_ASN1_type"", HFILL }},
{ &hf_ber_fragments,
{ ""OCTET STRING fragments"", ""ber.octet_string.fragments"", FT_NONE, BASE_NONE,
NULL, 0x00, NULL, HFILL } },
{ &hf_ber_fragment,
{ ""OCTET STRING fragment"", ""ber.octet_string.fragment"", FT_FRAMENUM, BASE_NONE,
NULL, 0x00, NULL, HFILL } },
{ &hf_ber_fragment_overlap,
{ ""OCTET STRING fragment overlap"", ""ber.octet_string.fragment.overlap"", FT_BOOLEAN,
BASE_NONE, NULL, 0x0, NULL, HFILL } },
{ &hf_ber_fragment_overlap_conflicts,
{ ""OCTET STRING fragment overlapping with conflicting data"",
""ber.octet_string.fragment.overlap.conflicts"", FT_BOOLEAN, BASE_NONE, NULL,
0x0, NULL, HFILL } },
{ &hf_ber_fragment_multiple_tails,
{ ""OCTET STRING has multiple tail fragments"",
""ber.octet_string.fragment.multiple_tails"", FT_BOOLEAN, BASE_NONE,
NULL, 0x0, NULL, HFILL } },
{ &hf_ber_fragment_too_long_fragment,
{ ""OCTET STRING fragment too long"", ""ber.octet_string.fragment.too_long_fragment"",
FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL,
HFILL } },
{ &hf_ber_fragment_error,
{ ""OCTET STRING defragmentation error"", ""ber.octet_string.fragment.error"", FT_FRAMENUM,
BASE_NONE, NULL, 0x00, NULL, HFILL } },
{ &hf_ber_fragment_count,
{ ""OCTET STRING fragment count"", ""ber.octet_string.fragment.count"", FT_UINT32, BASE_DEC,
NULL, 0x00, NULL, HFILL } },
{ &hf_ber_reassembled_in,
{ ""Reassembled in"", ""ber.octet_string.reassembled.in"", FT_FRAMENUM, BASE_NONE,
NULL, 0x00, NULL, HFILL } },
{ &hf_ber_reassembled_length,
{ ""Reassembled OCTET STRING length"", ""ber.octet_string.reassembled.length"", FT_UINT32, BASE_DEC,
NULL, 0x00, NULL, HFILL } },
{ &hf_ber_null_tag, { ""NULL tag"", ""ber.null_tag"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},
{ &hf_ber_unknown_data, { ""Unknown Data"", ""ber.unknown_data"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},
{ &hf_ber_unknown_octetstring, { ""Unknown OctetString"", ""ber.unknown_octetstring"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},
{ &hf_ber_seq_field_eoc, { ""SEQ FIELD EOC"", ""ber.seq_field_eoc"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},
{ &hf_ber_seq_eoc, { ""SEQ EOC"", ""ber.seq_eoc"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},
{ &hf_ber_set_field_eoc, { ""SET FIELD EOC"", ""ber.set_field_eoc"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},
{ &hf_ber_set_eoc, { ""SET EOC"", ""ber.set_eoc"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},
{ &hf_ber_choice_eoc, { ""CHOICE EOC"", ""ber.choice_eoc"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},
{ &hf_ber_seq_of_eoc, { ""SEQ OF EOC"", ""ber.seq_of_eoc"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},
{ &hf_ber_64bit_uint_as_bytes, { ""64bits unsigned integer"", ""ber.64bit_uint_as_bytes"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},
};
static gint *ett[] = {
&ett_ber_octet_string,
&ett_ber_reassembled_octet_string,
&ett_ber_primitive,
&ett_ber_unknown,
&ett_ber_SEQUENCE,
&ett_ber_EXTERNAL,
&ett_ber_T_encoding,
&ett_ber_fragment,
&ett_ber_fragments
};
static ei_register_info ei[] = {
{ &ei_ber_size_constraint_string, { ""ber.size_constraint.string"", PI_PROTOCOL, PI_WARN, ""Size constraint: string"", EXPFILL }},
{ &ei_ber_size_constraint_value, { ""ber.size_constraint.value"", PI_PROTOCOL, PI_WARN, ""Size constraint: values"", EXPFILL }},
{ &ei_ber_size_constraint_items, { ""ber.size_constraint.items"", PI_PROTOCOL, PI_WARN, ""Size constraint: items"", EXPFILL }},
{ &ei_ber_sequence_field_wrong, { ""ber.error.sequence.field_wrong"", PI_MALFORMED, PI_WARN, ""BER Error: Wrong field in SEQUENCE"", EXPFILL }},
{ &ei_ber_expected_octet_string, { ""ber.error.expected.octet_string"", PI_MALFORMED, PI_WARN, ""BER Error: OctetString expected"", EXPFILL }},
{ &ei_ber_expected_null, { ""ber.error.expected.null"", PI_MALFORMED, PI_WARN, ""BER Error: NULL expected"", EXPFILL }},
{ &ei_ber_expected_null_zero_length, { ""ber.error.expected.null_zero_length"", PI_MALFORMED, PI_WARN, ""BER Error: NULL expect zero length"", EXPFILL }},
{ &ei_ber_expected_sequence, { ""ber.error.expected.sequence"", PI_MALFORMED, PI_WARN, ""BER Error: Sequence expected"", EXPFILL }},
{ &ei_ber_expected_set, { ""ber.error.expected.set"", PI_MALFORMED, PI_WARN, ""BER Error: SET expected"", EXPFILL }},
{ &ei_ber_expected_string, { ""ber.error.expected.string"", PI_MALFORMED, PI_WARN, ""BER Error: String expected"", EXPFILL }},
{ &ei_ber_expected_object_identifier, { ""ber.error.expected.object_identifier"", PI_MALFORMED, PI_WARN, ""BER Error: Object Identifier expected"", EXPFILL }},
{ &ei_ber_expected_generalized_time, { ""ber.error.expected.generalized_time"", PI_MALFORMED, PI_WARN, ""BER Error: GeneralizedTime expected"", EXPFILL }},
{ &ei_ber_expected_utc_time, { ""ber.error.expected.utc_time"", PI_MALFORMED, PI_WARN, ""BER Error: UTCTime expected"", EXPFILL }},
{ &ei_ber_expected_bitstring, { ""ber.error.expected.bitstring"", PI_MALFORMED, PI_WARN, ""BER Error: BitString expected"", EXPFILL }},
{ &ei_ber_error_length, { ""ber.error.length"", PI_MALFORMED, PI_WARN, ""BER Error length"", EXPFILL }},
{ &ei_ber_wrong_tag_in_tagged_type, { ""ber.error.wrong_tag_in_tagged_type"", PI_MALFORMED, PI_WARN, ""BER Error: Wrong tag in tagged type"", EXPFILL }},
{ &ei_ber_universal_tag_unknown, { ""ber.error.universal_tag_unknown"", PI_MALFORMED, PI_WARN, ""BER Error: can not handle universal"", EXPFILL }},
{ &ei_ber_no_oid, { ""ber.error.no_oid"", PI_MALFORMED, PI_WARN, ""BER Error: No OID supplied to call_ber_oid_callback"", EXPFILL }},
{ &ei_ber_oid_not_implemented, { ""ber.error.oid_not_implemented"", PI_UNDECODED, PI_WARN, ""BER: Dissector for OID not implemented. Contact Wireshark developers if you want this supported"", EXPFILL }},
{ &ei_ber_syntax_not_implemented, { ""ber.error.syntax_not_implemented"", PI_UNDECODED, PI_WARN, ""BER: Syntax not implemented"", EXPFILL }},
{ &ei_ber_value_too_many_bytes, { ""ber.error.value_too_many_bytes"", PI_MALFORMED, PI_WARN, ""Value is encoded with too many bytes"", EXPFILL }},
{ &ei_ber_unknown_field_sequence, { ""ber.error.unknown_field.sequence"", PI_MALFORMED, PI_WARN, ""BER Error: Unknown field in Sequence"", EXPFILL }},
{ &ei_ber_unknown_field_set, { ""ber.error.unknown_field.set"", PI_MALFORMED, PI_WARN, ""BER Error: Unknown field in SET"", EXPFILL }},
{ &ei_ber_missing_field_set, { ""ber.error.missing_field.set"", PI_MALFORMED, PI_WARN, ""BER Error: Missing field in SET"", EXPFILL }},
{ &ei_ber_empty_choice, { ""ber.error.empty_choice"", PI_MALFORMED, PI_WARN, ""BER Error: Empty choice was found"", EXPFILL }},
{ &ei_ber_choice_not_found, { ""ber.error.choice_not_found"", PI_MALFORMED, PI_WARN, ""BER Error: This choice field was not found"", EXPFILL }},
{ &ei_ber_bits_unknown, { ""ber.error.bits_unknown"", PI_UNDECODED, PI_WARN, ""BER Error: Bits unknown"", EXPFILL }},
{ &ei_ber_bits_set_padded, { ""ber.error.bits_set_padded"", PI_UNDECODED, PI_WARN, ""BER Error: Bits set in padded area"", EXPFILL }},
{ &ei_ber_illegal_padding, { ""ber.error.illegal_padding"", PI_UNDECODED, PI_WARN, ""Illegal padding"", EXPFILL }},
{ &ei_ber_invalid_format_generalized_time, { ""ber.error.invalid_format.generalized_time"", PI_MALFORMED, PI_WARN, ""BER Error: GeneralizedTime invalid format"", EXPFILL }},
{ &ei_ber_invalid_format_utctime, { ""ber.error.invalid_format.utctime"", PI_MALFORMED, PI_WARN, ""BER Error: malformed UTCTime encoding"", EXPFILL }},
{ &ei_hf_field_not_integer_type, { ""ber.error.hf_field_not_integer_type"", PI_PROTOCOL, PI_ERROR, ""Was passed a HF field that was not integer type"", EXPFILL }},
};
static build_valid_func ber_da_build_value[1] = {ber_value};
static decode_as_value_t ber_da_values = {ber_prompt, 1, ber_da_build_value};
static decode_as_t ber_da = {""ber"", ""ASN.1"", ""ber.syntax"", 1, 0, &ber_da_values, NULL, NULL,
ber_populate_list, ber_decode_as_reset, ber_decode_as_change, NULL};
module_t *ber_module;
expert_module_t* expert_ber;
uat_t* users_uat = uat_new(""OID Tables"",
sizeof(oid_user_t),
""oid"",
FALSE,
&oid_users,
&num_oid_users,
UAT_AFFECTS_DISSECTION, 
""ChObjectIdentifiers"",
oid_copy_cb,
NULL,
oid_free_cb,
ber_update_oids,
users_flds);
proto_ber = proto_register_protocol(""Basic Encoding Rules (ASN.1 X.690)"", ""BER"", ""ber"");
ber_handle = register_dissector(""ber"", dissect_ber, proto_ber);
proto_register_field_array(proto_ber, hf, array_length(hf));
proto_register_subtree_array(ett, array_length(ett));
expert_ber = expert_register_protocol(proto_ber);
expert_register_field_array(expert_ber, ei, array_length(ei));
proto_set_cant_toggle(proto_ber);
ber_module = prefs_register_protocol(proto_ber, NULL);
prefs_register_bool_preference(ber_module, ""show_internals"",
""Show internal BER encapsulation tokens"",
""Whether the dissector should also display internal""
"" ASN.1 BER details such as Identifier and Length fields"", &show_internal_ber_fields);
prefs_register_bool_preference(ber_module, ""decode_unexpected"",
""Decode unexpected tags as BER encoded data"",
""Whether the dissector should decode unexpected tags as""
"" ASN.1 BER encoded data"", &decode_unexpected);
prefs_register_bool_preference(ber_module, ""decode_octetstring"",
""Decode OCTET STRING as BER encoded data"",
""Whether the dissector should try decoding OCTET STRINGs as""
"" constructed ASN.1 BER encoded data"", &decode_octetstring_as_ber);
prefs_register_bool_preference(ber_module, ""decode_primitive"",
""Decode Primitive as BER encoded data"",
""Whether the dissector should try decoding unknown primitive as""
"" constructed ASN.1 BER encoded data"", &decode_primitive_as_ber);
prefs_register_bool_preference(ber_module, ""warn_too_many_bytes"",
""Warn if too many leading zero bits in encoded data"",
""Whether the dissector should warn if excessive leading zero (0) bits"",
&decode_warning_leading_zero_bits);
prefs_register_uat_preference(ber_module, ""oid_table"", ""Object Identifiers"",
""A table that provides names for object identifiers""
"" and the syntax of any associated values"",
users_uat);
ber_oid_dissector_table = register_dissector_table(""ber.oid"", ""BER OID Dissectors"", FT_STRING, BASE_NONE, DISSECTOR_TABLE_ALLOW_DUPLICATE);
ber_syntax_dissector_table = register_dissector_table(""ber.syntax"", ""BER syntax"", FT_STRING, BASE_NONE, DISSECTOR_TABLE_ALLOW_DUPLICATE);
syntax_table = g_hash_table_new(g_str_hash, g_str_equal); 
register_ber_syntax_dissector(""ASN.1"", proto_ber, dissect_ber_syntax);
register_init_routine(ber_defragment_init);
register_cleanup_routine(ber_defragment_cleanup);
register_decode_as(&ber_da);
}","void
proto_register_ber(void)
{
static hf_register_info VAR_0[] = {
{ &VAR_1, {
""Class"", ""ber.id.class"", VAR_2, VAR_3,
VALS(VAR_4), 0xc0, ""Class of BER TLV Identifier"", VAR_5 }},
{ &VAR_6, {
""Padding"", ""ber.bitstring.padding"", VAR_2, VAR_3,
NULL, 0x0, ""Number of unused bits in the last octet of the bitstring"", VAR_5 }},
{ &VAR_7, {
""Empty"", ""ber.bitstring.empty"", VAR_2, VAR_3,
NULL, 0x0, ""This is an empty bitstring"", VAR_5 }},
{ &VAR_8, {
""P/C"", ""ber.id.pc"", VAR_9, 8,
TFS(&VAR_10), 0x20, ""Primitive or Constructed BER encoding"", VAR_5 }},
{ &VAR_11, {
""Tag"", ""ber.id.uni_tag"", VAR_2, VAR_3|VAR_12,
&VAR_13, 0x1f, ""Universal tag type"", VAR_5 }},
{ &VAR_14, {
""Tag"", ""ber.id.uni_tag"", VAR_15, VAR_3,
NULL, 0, ""Universal tag type"", VAR_5 }},
{ &VAR_16, {
""Tag"", ""ber.id.tag"", VAR_2, VAR_3,
NULL, 0x1f, ""Tag value for non-Universal classes"", VAR_5 }},
{ &VAR_17, {
""Tag"", ""ber.id.tag"", VAR_15, VAR_3,
NULL, 0, ""Tag value for non-Universal classes"", VAR_5 }},
{ &VAR_18, {
""Length"", ""ber.length"", VAR_15, VAR_3,
NULL, 0, ""Length of contents"", VAR_5 }},
{ &VAR_19, {
""OCTETSTRING"", ""ber.unknown.OCTETSTRING"", VAR_20, VAR_21,
NULL, 0, ""This is an unknown OCTETSTRING"", VAR_5 }},
{ &VAR_22, {
""OCTETSTRING [BER encoded]"", ""ber.unknown.OCTETSTRING"", VAR_23, VAR_21,
NULL, 0, ""This is an BER encoded OCTETSTRING"", VAR_5 }},
{ &VAR_24, {
""Primitive [BER encoded]"", ""ber.unknown.primitive"", VAR_23, VAR_21,
NULL, 0, ""This is a BER encoded Primitive"", VAR_5 }},
{ &VAR_25, {
""OID"", ""ber.unknown.OID"", VAR_26, VAR_21,
NULL, 0, ""This is an unknown Object Identifier"", VAR_5 }},
{ &VAR_27, {
""OID"", ""ber.unknown.relative_OID"", VAR_28, VAR_21,
NULL, 0, ""This is an unknown relative Object Identifier"", VAR_5 }},
{ &VAR_29, {
""GRAPHICSTRING"", ""ber.unknown.GRAPHICSTRING"", VAR_30, VAR_21,
NULL, 0, ""This is an unknown GRAPHICSTRING"", VAR_5 }},
{ &VAR_31, {
""NumericString"", ""ber.unknown.NumericString"", VAR_30, VAR_21,
NULL, 0, ""This is an unknown NumericString"", VAR_5 }},
{ &VAR_32, {
""PrintableString"", ""ber.unknown.PrintableString"", VAR_30, VAR_21,
NULL, 0, ""This is an unknown PrintableString"", VAR_5 }},
{ &VAR_33, {
""TeletexString"", ""ber.unknown.TeletexString"", VAR_30, VAR_21,
NULL, 0, ""This is an unknown TeletexString"", VAR_5 }},
{ &VAR_34, {
""VisibleString"", ""ber.unknown.VisibleString"", VAR_30, VAR_21,
NULL, 0, ""This is an unknown VisibleString"", VAR_5 }},
{ &VAR_35, {
""GeneralString"", ""ber.unknown.GeneralString"", VAR_30, VAR_21,
NULL, 0, ""This is an unknown GeneralString"", VAR_5 }},
{ &VAR_36, {
""UniversalString"", ""ber.unknown.UniversalString"", VAR_30, VAR_21,
NULL, 0, ""This is an unknown UniversalString"", VAR_5 }},
{ &VAR_37, {
""BMPString"", ""ber.unknown.BMPString"", VAR_30, VAR_21,
NULL, 0, ""This is an unknown BMPString"", VAR_5 }},
{ &VAR_38, {
""IA5String"", ""ber.unknown.IA5String"", VAR_30, VAR_21,
NULL, 0, ""This is an unknown IA5String"", VAR_5 }},
{ &VAR_39, {
""UTCTime"", ""ber.unknown.UTCTime"", VAR_30, VAR_21,
NULL, 0, ""This is an unknown UTCTime"", VAR_5 }},
{ &VAR_40, {
""UTF8String"", ""ber.unknown.UTF8String"", VAR_30, VAR_21,
NULL, 0, ""This is an unknown UTF8String"", VAR_5 }},
{ &VAR_41, {
""GeneralizedTime"", ""ber.unknown.GeneralizedTime"", VAR_30, VAR_21,
NULL, 0, ""This is an unknown GeneralizedTime"", VAR_5 }},
{ &VAR_42, {
""INTEGER"", ""ber.unknown.INTEGER"", VAR_43, VAR_3,
NULL, 0, ""This is an unknown INTEGER"", VAR_5 }},
{ &VAR_44, {
""REAL"", ""ber.unknown.REAL"", VAR_45, VAR_21,
NULL, 0, ""This is an unknown REAL"", VAR_5 }},
{ &VAR_46, {
""BITSTRING"", ""ber.unknown.BITSTRING"", VAR_20, VAR_21,
NULL, 0, ""This is an unknown BITSTRING"", VAR_5 }},
{ &VAR_47, {
""BOOLEAN"", ""ber.unknown.BOOLEAN"", VAR_2, VAR_48,
NULL, 0, ""This is an unknown BOOLEAN"", VAR_5 }},
{ &VAR_49, {
""ENUMERATED"", ""ber.unknown.ENUMERATED"", VAR_15, VAR_3,
NULL, 0, ""This is an unknown ENUMERATED"", VAR_5 }},
{ &VAR_50, {
""BER Error"", ""ber.error"", VAR_30, VAR_21,
NULL, 0, NULL, VAR_5 }},
{ &VAR_51,
{ ""direct-reference"", ""ber.direct_reference"",
VAR_26, VAR_21, NULL, 0,
""ber.OBJECT_IDENTIFIER"", VAR_5 }},
{ &VAR_52,
{ ""indirect-reference"", ""ber.indirect_reference"",
VAR_53, VAR_3, NULL, 0,
""ber.INTEGER"", VAR_5 }},
{ &VAR_54,
{ ""data-value-descriptor"", ""ber.data_value_descriptor"",
VAR_30, VAR_21, NULL, 0,
""ber.ObjectDescriptor"", VAR_5 }},
{ &VAR_55,
{ ""encoding"", ""ber.encoding"",
VAR_15, VAR_3, VALS(VAR_56), 0,
""ber.T_encoding"", VAR_5 }},
{ &VAR_57,
{ ""octet-aligned"", ""ber.octet_aligned"",
VAR_20, VAR_21, NULL, 0,
""ber.T_octet_aligned"", VAR_5 }},
{ &VAR_58,
{ ""arbitrary"", ""ber.arbitrary"",
VAR_20, VAR_21, NULL, 0,
""ber.T_arbitrary"", VAR_5 }},
{ &VAR_59,
{ ""single-ASN1-type"", ""ber.single_ASN1_type"",
VAR_23, VAR_21, NULL, 0,
""ber.T_single_ASN1_type"", VAR_5 }},
{ &VAR_60,
{ ""OCTET STRING fragments"", ""ber.octet_string.fragments"", VAR_23, VAR_21,
NULL, 0x00, NULL, VAR_5 } },
{ &VAR_61,
{ ""OCTET STRING fragment"", ""ber.octet_string.fragment"", VAR_62, VAR_21,
NULL, 0x00, NULL, VAR_5 } },
{ &VAR_63,
{ ""OCTET STRING fragment overlap"", ""ber.octet_string.fragment.overlap"", VAR_9,
VAR_21, NULL, 0x0, NULL, VAR_5 } },
{ &VAR_64,
{ ""OCTET STRING fragment overlapping with conflicting data"",
""ber.octet_string.fragment.overlap.conflicts"", VAR_9, VAR_21, NULL,
0x0, NULL, VAR_5 } },
{ &VAR_65,
{ ""OCTET STRING has multiple tail fragments"",
""ber.octet_string.fragment.multiple_tails"", VAR_9, VAR_21,
NULL, 0x0, NULL, VAR_5 } },
{ &VAR_66,
{ ""OCTET STRING fragment too long"", ""ber.octet_string.fragment.too_long_fragment"",
VAR_9, VAR_21, NULL, 0x0, NULL,
VAR_5 } },
{ &VAR_67,
{ ""OCTET STRING defragmentation error"", ""ber.octet_string.fragment.error"", VAR_62,
VAR_21, NULL, 0x00, NULL, VAR_5 } },
{ &VAR_68,
{ ""OCTET STRING fragment count"", ""ber.octet_string.fragment.count"", VAR_15, VAR_3,
NULL, 0x00, NULL, VAR_5 } },
{ &VAR_69,
{ ""Reassembled in"", ""ber.octet_string.reassembled.in"", VAR_62, VAR_21,
NULL, 0x00, NULL, VAR_5 } },
{ &VAR_70,
{ ""Reassembled OCTET STRING length"", ""ber.octet_string.reassembled.length"", VAR_15, VAR_3,
NULL, 0x00, NULL, VAR_5 } },
{ &VAR_71, { ""NULL tag"", ""ber.null_tag"", VAR_23, VAR_21, NULL, 0x0, NULL, VAR_5 }},
{ &VAR_72, { ""Unknown Data"", ""ber.unknown_data"", VAR_20, VAR_21, NULL, 0x0, NULL, VAR_5 }},
{ &VAR_73, { ""Unknown OctetString"", ""ber.unknown_octetstring"", VAR_20, VAR_21, NULL, 0x0, NULL, VAR_5 }},
{ &VAR_74, { ""SEQ FIELD EOC"", ""ber.seq_field_eoc"", VAR_20, VAR_21, NULL, 0x0, NULL, VAR_5 }},
{ &VAR_75, { ""SEQ EOC"", ""ber.seq_eoc"", VAR_20, VAR_21, NULL, 0x0, NULL, VAR_5 }},
{ &VAR_76, { ""SET FIELD EOC"", ""ber.set_field_eoc"", VAR_20, VAR_21, NULL, 0x0, NULL, VAR_5 }},
{ &VAR_77, { ""SET EOC"", ""ber.set_eoc"", VAR_20, VAR_21, NULL, 0x0, NULL, VAR_5 }},
{ &VAR_78, { ""CHOICE EOC"", ""ber.choice_eoc"", VAR_20, VAR_21, NULL, 0x0, NULL, VAR_5 }},
{ &VAR_79, { ""SEQ OF EOC"", ""ber.seq_of_eoc"", VAR_20, VAR_21, NULL, 0x0, NULL, VAR_5 }},
{ &VAR_80, { ""64bits unsigned integer"", ""ber.64bit_uint_as_bytes"", VAR_20, VAR_21, NULL, 0x0, NULL, VAR_5 }},
};
static gint *VAR_81[] = {
&VAR_82,
&VAR_83,
&VAR_84,
&VAR_85,
&VAR_86,
&VAR_87,
&VAR_88,
&VAR_89,
&VAR_90
};
static ei_register_info VAR_91[] = {
{ &VAR_92, { ""ber.size_constraint.string"", VAR_93, VAR_94, ""Size constraint: string"", VAR_95 }},
{ &VAR_96, { ""ber.size_constraint.value"", VAR_93, VAR_94, ""Size constraint: values"", VAR_95 }},
{ &VAR_97, { ""ber.size_constraint.items"", VAR_93, VAR_94, ""Size constraint: items"", VAR_95 }},
{ &VAR_98, { ""ber.error.sequence.field_wrong"", VAR_99, VAR_94, ""BER Error: Wrong field in SEQUENCE"", VAR_95 }},
{ &VAR_100, { ""ber.error.expected.octet_string"", VAR_99, VAR_94, ""BER Error: OctetString expected"", VAR_95 }},
{ &VAR_101, { ""ber.error.expected.null"", VAR_99, VAR_94, ""BER Error: NULL expected"", VAR_95 }},
{ &VAR_102, { ""ber.error.expected.null_zero_length"", VAR_99, VAR_94, ""BER Error: NULL expect zero length"", VAR_95 }},
{ &VAR_103, { ""ber.error.expected.sequence"", VAR_99, VAR_94, ""BER Error: Sequence expected"", VAR_95 }},
{ &VAR_104, { ""ber.error.expected.set"", VAR_99, VAR_94, ""BER Error: SET expected"", VAR_95 }},
{ &VAR_105, { ""ber.error.expected.string"", VAR_99, VAR_94, ""BER Error: String expected"", VAR_95 }},
{ &VAR_106, { ""ber.error.expected.object_identifier"", VAR_99, VAR_94, ""BER Error: Object Identifier expected"", VAR_95 }},
{ &VAR_107, { ""ber.error.expected.generalized_time"", VAR_99, VAR_94, ""BER Error: GeneralizedTime expected"", VAR_95 }},
{ &VAR_108, { ""ber.error.expected.utc_time"", VAR_99, VAR_94, ""BER Error: UTCTime expected"", VAR_95 }},
{ &VAR_109, { ""ber.error.expected.bitstring"", VAR_99, VAR_94, ""BER Error: BitString expected"", VAR_95 }},
{ &VAR_110, { ""ber.error.length"", VAR_99, VAR_94, ""BER Error length"", VAR_95 }},
{ &VAR_111, { ""ber.error.wrong_tag_in_tagged_type"", VAR_99, VAR_94, ""BER Error: Wrong tag in tagged type"", VAR_95 }},
{ &VAR_112, { ""ber.error.universal_tag_unknown"", VAR_99, VAR_94, ""BER Error: can not handle universal"", VAR_95 }},
{ &VAR_113, { ""ber.error.no_oid"", VAR_99, VAR_94, ""BER Error: No OID supplied to call_ber_oid_callback"", VAR_95 }},
{ &VAR_114, { ""ber.error.oid_not_implemented"", VAR_115, VAR_94, ""BER: Dissector for OID not implemented. Contact Wireshark developers if you want this supported"", VAR_95 }},
{ &VAR_116, { ""ber.error.syntax_not_implemented"", VAR_115, VAR_94, ""BER: Syntax not implemented"", VAR_95 }},
{ &VAR_117, { ""ber.error.value_too_many_bytes"", VAR_99, VAR_94, ""Value is encoded with too many bytes"", VAR_95 }},
{ &VAR_118, { ""ber.error.unknown_field.sequence"", VAR_99, VAR_94, ""BER Error: Unknown field in Sequence"", VAR_95 }},
{ &VAR_119, { ""ber.error.unknown_field.set"", VAR_99, VAR_94, ""BER Error: Unknown field in SET"", VAR_95 }},
{ &VAR_120, { ""ber.error.missing_field.set"", VAR_99, VAR_94, ""BER Error: Missing field in SET"", VAR_95 }},
{ &VAR_121, { ""ber.error.empty_choice"", VAR_99, VAR_94, ""BER Error: Empty choice was found"", VAR_95 }},
{ &VAR_122, { ""ber.error.choice_not_found"", VAR_99, VAR_94, ""BER Error: This choice field was not found"", VAR_95 }},
{ &VAR_123, { ""ber.error.bits_unknown"", VAR_115, VAR_94, ""BER Error: Bits unknown"", VAR_95 }},
{ &VAR_124, { ""ber.error.bits_set_padded"", VAR_115, VAR_94, ""BER Error: Bits set in padded area"", VAR_95 }},
{ &VAR_125, { ""ber.error.illegal_padding"", VAR_115, VAR_94, ""Illegal padding"", VAR_95 }},
{ &VAR_126, { ""ber.error.invalid_format.generalized_time"", VAR_99, VAR_94, ""BER Error: GeneralizedTime invalid format"", VAR_95 }},
{ &VAR_127, { ""ber.error.invalid_format.utctime"", VAR_99, VAR_94, ""BER Error: malformed UTCTime encoding"", VAR_95 }},
{ &VAR_128, { ""ber.error.hf_field_not_integer_type"", VAR_93, VAR_129, ""Was passed a HF field that was not integer type"", VAR_95 }},
};
static build_valid_func VAR_130[1] = {VAR_131};
static decode_as_value_t VAR_132 = {VAR_133, 1, VAR_130};
static decode_as_t VAR_134 = {""ber"", ""ASN.1"", ""ber.syntax"", 1, 0, &VAR_132, NULL, NULL,
VAR_135, VAR_136, VAR_137, NULL};
module_t *VAR_138;
expert_module_t* VAR_139;
uat_t* VAR_140 = uat_new(""OID Tables"",
sizeof(VAR_141),
""oid"",
FALSE,
&VAR_142,
&VAR_143,
VAR_144, 
""ChObjectIdentifiers"",
VAR_145,
NULL,
VAR_146,
VAR_147,
VAR_148);
VAR_149 = proto_register_protocol(""Basic Encoding Rules (ASN.1 X.690)"", ""BER"", ""ber"");
VAR_150 = register_dissector(""ber"", VAR_151, VAR_149);
proto_register_field_array(VAR_149, VAR_0, array_length(VAR_0));
proto_register_subtree_array(VAR_81, array_length(VAR_81));
VAR_139 = expert_register_protocol(VAR_149);
expert_register_field_array(VAR_139, VAR_91, array_length(VAR_91));
proto_set_cant_toggle(VAR_149);
VAR_138 = prefs_register_protocol(VAR_149, NULL);
prefs_register_bool_preference(VAR_138, ""show_internals"",
""Show internal BER encapsulation tokens"",
""Whether the dissector should also display internal""
"" ASN.1 BER details such as Identifier and Length fields"", &VAR_152);
prefs_register_bool_preference(VAR_138, ""decode_unexpected"",
""Decode unexpected tags as BER encoded data"",
""Whether the dissector should decode unexpected tags as""
"" ASN.1 BER encoded data"", &VAR_153);
prefs_register_bool_preference(VAR_138, ""decode_octetstring"",
""Decode OCTET STRING as BER encoded data"",
""Whether the dissector should try decoding OCTET STRINGs as""
"" constructed ASN.1 BER encoded data"", &VAR_154);
prefs_register_bool_preference(VAR_138, ""decode_primitive"",
""Decode Primitive as BER encoded data"",
""Whether the dissector should try decoding unknown primitive as""
"" constructed ASN.1 BER encoded data"", &VAR_155);
prefs_register_bool_preference(VAR_138, ""warn_too_many_bytes"",
""Warn if too many leading zero bits in encoded data"",
""Whether the dissector should warn if excessive leading zero (0) bits"",
&VAR_156);
prefs_register_uat_preference(VAR_138, ""oid_table"", ""Object Identifiers"",
""A table that provides names for object identifiers""
"" and the syntax of any associated values"",
VAR_140);
VAR_157 = register_dissector_table(""ber.oid"", ""BER OID Dissectors"", VAR_30, VAR_21, VAR_158);
VAR_159 = register_dissector_table(""ber.syntax"", ""BER syntax"", VAR_30, VAR_21, VAR_158);
VAR_160 = g_hash_table_new(VAR_161, VAR_162); 
register_ber_syntax_dissector(""ASN.1"", VAR_149, VAR_163);
register_init_routine(VAR_164);
register_cleanup_routine(VAR_165);
register_decode_as(&VAR_134);
}",wireshark/9b2f3f7c5c9205381cb72e42b66e97d8ed3abf63/packet-ber.c/vul/before/0.json,"void
proto_register_ber(void)
{
    static hf_register_info hf[] = {
        { &hf_ber_id_class, {
                ""Class"", ""ber.id.class"", FT_UINT8, BASE_DEC,
                VALS(ber_class_codes), 0xc0, ""Class of BER TLV Identifier"", HFILL }},
        { &hf_ber_bitstring_padding, {
                ""Padding"", ""ber.bitstring.padding"", FT_UINT8, BASE_DEC,
                NULL, 0x0, ""Number of unused bits in the last octet of the bitstring"", HFILL }},
        { &hf_ber_bitstring_empty, {
                ""Empty"", ""ber.bitstring.empty"", FT_UINT8, BASE_DEC,
                NULL, 0x0, ""This is an empty bitstring"", HFILL }},
        { &hf_ber_id_pc, {
                ""P/C"", ""ber.id.pc"", FT_BOOLEAN, 8,
                TFS(&ber_pc_codes), 0x20, ""Primitive or Constructed BER encoding"", HFILL }},
        { &hf_ber_id_uni_tag, {
                ""Tag"", ""ber.id.uni_tag"", FT_UINT8, BASE_DEC|BASE_EXT_STRING,
                &ber_uni_tag_codes_ext, 0x1f, ""Universal tag type"", HFILL }},
        { &hf_ber_id_uni_tag_ext, {
                ""Tag"", ""ber.id.uni_tag"", FT_UINT32, BASE_DEC,
                NULL, 0, ""Universal tag type"", HFILL }},
        { &hf_ber_id_tag, {
                ""Tag"", ""ber.id.tag"", FT_UINT8, BASE_DEC,
                NULL, 0x1f, ""Tag value for non-Universal classes"", HFILL }},
        { &hf_ber_id_tag_ext, {
                ""Tag"", ""ber.id.tag"", FT_UINT32, BASE_DEC,
                NULL, 0, ""Tag value for non-Universal classes"", HFILL }},
        { &hf_ber_length, {
                ""Length"", ""ber.length"", FT_UINT32, BASE_DEC,
                NULL, 0, ""Length of contents"", HFILL }},
        { &hf_ber_unknown_OCTETSTRING, {
                ""OCTETSTRING"", ""ber.unknown.OCTETSTRING"", FT_BYTES, BASE_NONE,
                NULL, 0, ""This is an unknown OCTETSTRING"", HFILL }},
        { &hf_ber_unknown_BER_OCTETSTRING, {
                ""OCTETSTRING [BER encoded]"", ""ber.unknown.OCTETSTRING"", FT_NONE, BASE_NONE,
                NULL, 0, ""This is an BER encoded OCTETSTRING"", HFILL }},
        { &hf_ber_unknown_BER_primitive, {
                ""Primitive [BER encoded]"", ""ber.unknown.primitive"", FT_NONE, BASE_NONE,
                NULL, 0, ""This is a BER encoded Primitive"", HFILL }},
        { &hf_ber_unknown_OID, {
                ""OID"", ""ber.unknown.OID"", FT_OID, BASE_NONE,
                NULL, 0, ""This is an unknown Object Identifier"", HFILL }},
        { &hf_ber_unknown_relative_OID, {
                ""OID"", ""ber.unknown.relative_OID"", FT_REL_OID, BASE_NONE,
                NULL, 0, ""This is an unknown relative Object Identifier"", HFILL }},
        { &hf_ber_unknown_GraphicString, {
                ""GRAPHICSTRING"", ""ber.unknown.GRAPHICSTRING"", FT_STRING, BASE_NONE,
                NULL, 0, ""This is an unknown GRAPHICSTRING"", HFILL }},
        { &hf_ber_unknown_NumericString, {
                ""NumericString"", ""ber.unknown.NumericString"", FT_STRING, BASE_NONE,
                NULL, 0, ""This is an unknown NumericString"", HFILL }},
        { &hf_ber_unknown_PrintableString, {
                ""PrintableString"", ""ber.unknown.PrintableString"", FT_STRING, BASE_NONE,
                NULL, 0, ""This is an unknown PrintableString"", HFILL }},
        { &hf_ber_unknown_TeletexString, {
                ""TeletexString"", ""ber.unknown.TeletexString"", FT_STRING, BASE_NONE,
                NULL, 0, ""This is an unknown TeletexString"", HFILL }},
        { &hf_ber_unknown_VisibleString, {
                ""VisibleString"", ""ber.unknown.VisibleString"", FT_STRING, BASE_NONE,
                NULL, 0, ""This is an unknown VisibleString"", HFILL }},
        { &hf_ber_unknown_GeneralString, {
                ""GeneralString"", ""ber.unknown.GeneralString"", FT_STRING, BASE_NONE,
                NULL, 0, ""This is an unknown GeneralString"", HFILL }},
        { &hf_ber_unknown_UniversalString, {
                ""UniversalString"", ""ber.unknown.UniversalString"", FT_STRING, BASE_NONE,
                NULL, 0, ""This is an unknown UniversalString"", HFILL }},
        { &hf_ber_unknown_BMPString, {
                ""BMPString"", ""ber.unknown.BMPString"", FT_STRING, BASE_NONE,
                NULL, 0, ""This is an unknown BMPString"", HFILL }},
        { &hf_ber_unknown_IA5String, {
                ""IA5String"", ""ber.unknown.IA5String"", FT_STRING, BASE_NONE,
                NULL, 0, ""This is an unknown IA5String"", HFILL }},
        { &hf_ber_unknown_UTCTime, {
                ""UTCTime"", ""ber.unknown.UTCTime"", FT_STRING, BASE_NONE,
                NULL, 0, ""This is an unknown UTCTime"", HFILL }},
        { &hf_ber_unknown_UTF8String, {
                ""UTF8String"", ""ber.unknown.UTF8String"", FT_STRING, BASE_NONE,
                NULL, 0, ""This is an unknown UTF8String"", HFILL }},
        { &hf_ber_unknown_GeneralizedTime, {
                ""GeneralizedTime"", ""ber.unknown.GeneralizedTime"", FT_STRING, BASE_NONE,
                NULL, 0, ""This is an unknown GeneralizedTime"", HFILL }},
        { &hf_ber_unknown_INTEGER, {
                ""INTEGER"", ""ber.unknown.INTEGER"", FT_INT64, BASE_DEC,
                NULL, 0, ""This is an unknown INTEGER"", HFILL }},
        { &hf_ber_unknown_REAL, {
                ""REAL"", ""ber.unknown.REAL"", FT_DOUBLE, BASE_NONE,
                NULL, 0, ""This is an unknown REAL"", HFILL }},
        { &hf_ber_unknown_BITSTRING, {
                ""BITSTRING"", ""ber.unknown.BITSTRING"", FT_BYTES, BASE_NONE,
                NULL, 0, ""This is an unknown BITSTRING"", HFILL }},
        { &hf_ber_unknown_BOOLEAN, {
                ""BOOLEAN"", ""ber.unknown.BOOLEAN"", FT_UINT8, BASE_HEX,
                NULL, 0, ""This is an unknown BOOLEAN"", HFILL }},
        { &hf_ber_unknown_ENUMERATED, {
                ""ENUMERATED"", ""ber.unknown.ENUMERATED"", FT_UINT32, BASE_DEC,
                NULL, 0, ""This is an unknown ENUMERATED"", HFILL }},
        { &hf_ber_error, {
                ""BER Error"", ""ber.error"", FT_STRING, BASE_NONE,
                NULL, 0, NULL, HFILL }},
        { &hf_ber_direct_reference,
          { ""direct-reference"", ""ber.direct_reference"",
            FT_OID, BASE_NONE, NULL, 0,
            ""ber.OBJECT_IDENTIFIER"", HFILL }},
        { &hf_ber_indirect_reference,
          { ""indirect-reference"", ""ber.indirect_reference"",
            FT_INT32, BASE_DEC, NULL, 0,
            ""ber.INTEGER"", HFILL }},
        { &hf_ber_data_value_descriptor,
          { ""data-value-descriptor"", ""ber.data_value_descriptor"",
            FT_STRING, BASE_NONE, NULL, 0,
            ""ber.ObjectDescriptor"", HFILL }},
        { &hf_ber_encoding,
          { ""encoding"", ""ber.encoding"",
            FT_UINT32, BASE_DEC, VALS(ber_T_encoding_vals), 0,
            ""ber.T_encoding"", HFILL }},
        { &hf_ber_octet_aligned,
          { ""octet-aligned"", ""ber.octet_aligned"",
            FT_BYTES, BASE_NONE, NULL, 0,
            ""ber.T_octet_aligned"", HFILL }},
        { &hf_ber_arbitrary,
          { ""arbitrary"", ""ber.arbitrary"",
            FT_BYTES, BASE_NONE, NULL, 0,
            ""ber.T_arbitrary"", HFILL }},
        { &hf_ber_single_ASN1_type,
          { ""single-ASN1-type"", ""ber.single_ASN1_type"",
            FT_NONE, BASE_NONE, NULL, 0,
            ""ber.T_single_ASN1_type"", HFILL }},

        /* Fragment entries */
        { &hf_ber_fragments,
          { ""OCTET STRING fragments"", ""ber.octet_string.fragments"", FT_NONE, BASE_NONE,
            NULL, 0x00, NULL, HFILL } },
        { &hf_ber_fragment,
          { ""OCTET STRING fragment"", ""ber.octet_string.fragment"", FT_FRAMENUM, BASE_NONE,
            NULL, 0x00, NULL, HFILL } },
        { &hf_ber_fragment_overlap,
          { ""OCTET STRING fragment overlap"", ""ber.octet_string.fragment.overlap"", FT_BOOLEAN,
            BASE_NONE, NULL, 0x0, NULL, HFILL } },
        { &hf_ber_fragment_overlap_conflicts,
          { ""OCTET STRING fragment overlapping with conflicting data"",
            ""ber.octet_string.fragment.overlap.conflicts"", FT_BOOLEAN, BASE_NONE, NULL,
            0x0, NULL, HFILL } },
        { &hf_ber_fragment_multiple_tails,
          { ""OCTET STRING has multiple tail fragments"",
            ""ber.octet_string.fragment.multiple_tails"", FT_BOOLEAN, BASE_NONE,
            NULL, 0x0, NULL, HFILL } },
        { &hf_ber_fragment_too_long_fragment,
          { ""OCTET STRING fragment too long"", ""ber.octet_string.fragment.too_long_fragment"",
            FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL,
            HFILL } },
        { &hf_ber_fragment_error,
          { ""OCTET STRING defragmentation error"", ""ber.octet_string.fragment.error"", FT_FRAMENUM,
            BASE_NONE, NULL, 0x00, NULL, HFILL } },
        { &hf_ber_fragment_count,
          { ""OCTET STRING fragment count"", ""ber.octet_string.fragment.count"", FT_UINT32, BASE_DEC,
            NULL, 0x00, NULL, HFILL } },
        { &hf_ber_reassembled_in,
          { ""Reassembled in"", ""ber.octet_string.reassembled.in"", FT_FRAMENUM, BASE_NONE,
            NULL, 0x00, NULL, HFILL } },
        { &hf_ber_reassembled_length,
          { ""Reassembled OCTET STRING length"", ""ber.octet_string.reassembled.length"", FT_UINT32, BASE_DEC,
            NULL, 0x00, NULL, HFILL } },

      /* Generated from convert_proto_tree_add_text.pl */
      { &hf_ber_null_tag, { ""NULL tag"", ""ber.null_tag"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},
      { &hf_ber_unknown_data, { ""Unknown Data"", ""ber.unknown_data"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},
      { &hf_ber_unknown_octetstring, { ""Unknown OctetString"", ""ber.unknown_octetstring"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},
      { &hf_ber_seq_field_eoc, { ""SEQ FIELD EOC"", ""ber.seq_field_eoc"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},
      { &hf_ber_seq_eoc, { ""SEQ EOC"", ""ber.seq_eoc"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},
      { &hf_ber_set_field_eoc, { ""SET FIELD EOC"", ""ber.set_field_eoc"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},
      { &hf_ber_set_eoc, { ""SET EOC"", ""ber.set_eoc"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},
      { &hf_ber_choice_eoc, { ""CHOICE EOC"", ""ber.choice_eoc"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},
      { &hf_ber_seq_of_eoc, { ""SEQ OF EOC"", ""ber.seq_of_eoc"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},
      { &hf_ber_64bit_uint_as_bytes, { ""64bits unsigned integer"", ""ber.64bit_uint_as_bytes"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},
    };


    static gint *ett[] = {
        &ett_ber_octet_string,
        &ett_ber_reassembled_octet_string,
        &ett_ber_primitive,
        &ett_ber_unknown,
        &ett_ber_SEQUENCE,
        &ett_ber_EXTERNAL,
        &ett_ber_T_encoding,
        &ett_ber_fragment,
        &ett_ber_fragments
    };
    static ei_register_info ei[] = {
        { &ei_ber_size_constraint_string, { ""ber.size_constraint.string"", PI_PROTOCOL, PI_WARN, ""Size constraint: string"", EXPFILL }},
        { &ei_ber_size_constraint_value, { ""ber.size_constraint.value"", PI_PROTOCOL, PI_WARN, ""Size constraint: values"", EXPFILL }},
        { &ei_ber_size_constraint_items, { ""ber.size_constraint.items"", PI_PROTOCOL, PI_WARN, ""Size constraint: items"", EXPFILL }},
        { &ei_ber_sequence_field_wrong, { ""ber.error.sequence.field_wrong"", PI_MALFORMED, PI_WARN, ""BER Error: Wrong field in SEQUENCE"", EXPFILL }},
        { &ei_ber_expected_octet_string, { ""ber.error.expected.octet_string"", PI_MALFORMED, PI_WARN, ""BER Error: OctetString expected"", EXPFILL }},
        { &ei_ber_expected_null, { ""ber.error.expected.null"", PI_MALFORMED, PI_WARN, ""BER Error: NULL expected"", EXPFILL }},
        { &ei_ber_expected_null_zero_length, { ""ber.error.expected.null_zero_length"", PI_MALFORMED, PI_WARN, ""BER Error: NULL expect zero length"", EXPFILL }},
        { &ei_ber_expected_sequence, { ""ber.error.expected.sequence"", PI_MALFORMED, PI_WARN, ""BER Error: Sequence expected"", EXPFILL }},
        { &ei_ber_expected_set, { ""ber.error.expected.set"", PI_MALFORMED, PI_WARN, ""BER Error: SET expected"", EXPFILL }},
        { &ei_ber_expected_string, { ""ber.error.expected.string"", PI_MALFORMED, PI_WARN, ""BER Error: String expected"", EXPFILL }},
        { &ei_ber_expected_object_identifier, { ""ber.error.expected.object_identifier"", PI_MALFORMED, PI_WARN, ""BER Error: Object Identifier expected"", EXPFILL }},
        { &ei_ber_expected_generalized_time, { ""ber.error.expected.generalized_time"", PI_MALFORMED, PI_WARN, ""BER Error: GeneralizedTime expected"", EXPFILL }},
        { &ei_ber_expected_utc_time, { ""ber.error.expected.utc_time"", PI_MALFORMED, PI_WARN, ""BER Error: UTCTime expected"", EXPFILL }},
        { &ei_ber_expected_bitstring, { ""ber.error.expected.bitstring"", PI_MALFORMED, PI_WARN, ""BER Error: BitString expected"", EXPFILL }},
        { &ei_ber_error_length, { ""ber.error.length"", PI_MALFORMED, PI_WARN, ""BER Error length"", EXPFILL }},
        { &ei_ber_wrong_tag_in_tagged_type, { ""ber.error.wrong_tag_in_tagged_type"", PI_MALFORMED, PI_WARN, ""BER Error: Wrong tag in tagged type"", EXPFILL }},
        { &ei_ber_universal_tag_unknown, { ""ber.error.universal_tag_unknown"", PI_MALFORMED, PI_WARN, ""BER Error: can not handle universal"", EXPFILL }},
        { &ei_ber_no_oid, { ""ber.error.no_oid"", PI_MALFORMED, PI_WARN, ""BER Error: No OID supplied to call_ber_oid_callback"", EXPFILL }},
        { &ei_ber_oid_not_implemented, { ""ber.error.oid_not_implemented"", PI_UNDECODED, PI_WARN, ""BER: Dissector for OID not implemented. Contact Wireshark developers if you want this supported"", EXPFILL }},
        { &ei_ber_syntax_not_implemented, { ""ber.error.syntax_not_implemented"", PI_UNDECODED, PI_WARN, ""BER: Syntax not implemented"", EXPFILL }},
        { &ei_ber_value_too_many_bytes, { ""ber.error.value_too_many_bytes"", PI_MALFORMED, PI_WARN, ""Value is encoded with too many bytes"", EXPFILL }},
        { &ei_ber_unknown_field_sequence, { ""ber.error.unknown_field.sequence"", PI_MALFORMED, PI_WARN, ""BER Error: Unknown field in Sequence"", EXPFILL }},
        { &ei_ber_unknown_field_set, { ""ber.error.unknown_field.set"", PI_MALFORMED, PI_WARN, ""BER Error: Unknown field in SET"", EXPFILL }},
        { &ei_ber_missing_field_set, { ""ber.error.missing_field.set"", PI_MALFORMED, PI_WARN, ""BER Error: Missing field in SET"", EXPFILL }},
        { &ei_ber_empty_choice, { ""ber.error.empty_choice"", PI_MALFORMED, PI_WARN, ""BER Error: Empty choice was found"", EXPFILL }},
        { &ei_ber_choice_not_found, { ""ber.error.choice_not_found"", PI_MALFORMED, PI_WARN, ""BER Error: This choice field was not found"", EXPFILL }},
        { &ei_ber_bits_unknown, { ""ber.error.bits_unknown"", PI_UNDECODED, PI_WARN, ""BER Error: Bits unknown"", EXPFILL }},
        { &ei_ber_bits_set_padded, { ""ber.error.bits_set_padded"", PI_UNDECODED, PI_WARN, ""BER Error: Bits set in padded area"", EXPFILL }},
        { &ei_ber_illegal_padding, { ""ber.error.illegal_padding"", PI_UNDECODED, PI_WARN, ""Illegal padding"", EXPFILL }},
        { &ei_ber_invalid_format_generalized_time, { ""ber.error.invalid_format.generalized_time"", PI_MALFORMED, PI_WARN, ""BER Error: GeneralizedTime invalid format"", EXPFILL }},
        { &ei_ber_invalid_format_utctime, { ""ber.error.invalid_format.utctime"", PI_MALFORMED, PI_WARN, ""BER Error: malformed UTCTime encoding"", EXPFILL }},
        { &ei_hf_field_not_integer_type, { ""ber.error.hf_field_not_integer_type"", PI_PROTOCOL, PI_ERROR, ""Was passed a HF field that was not integer type"", EXPFILL }},
        { &ei_ber_constr_bitstr,{ ""ber.error.constr_bitstr.len"", PI_MALFORMED, PI_WARN, ""BER Error: malformed Bitstring encoding"", EXPFILL } },
    };

    /* Decode As handling */
    static build_valid_func ber_da_build_value[1] = {ber_value};
    static decode_as_value_t ber_da_values = {ber_prompt, 1, ber_da_build_value};
    static decode_as_t ber_da = {""ber"", ""ASN.1"", ""ber.syntax"", 1, 0, &ber_da_values, NULL, NULL,
                                ber_populate_list, ber_decode_as_reset, ber_decode_as_change, NULL};

    module_t *ber_module;
    expert_module_t* expert_ber;
    uat_t* users_uat = uat_new(""OID Tables"",
                               sizeof(oid_user_t),
                               ""oid"",
                               FALSE,
                               &oid_users,
                               &num_oid_users,
                               UAT_AFFECTS_DISSECTION, /* affects dissection of packets, but not set of named fields */
                               ""ChObjectIdentifiers"",
                               oid_copy_cb,
                               NULL,
                               oid_free_cb,
                               ber_update_oids,
                               users_flds);

    proto_ber = proto_register_protocol(""Basic Encoding Rules (ASN.1 X.690)"", ""BER"", ""ber"");

    ber_handle = register_dissector(""ber"", dissect_ber, proto_ber);

    proto_register_field_array(proto_ber, hf, array_length(hf));
    proto_register_subtree_array(ett, array_length(ett));
    expert_ber = expert_register_protocol(proto_ber);
    expert_register_field_array(expert_ber, ei, array_length(ei));

    proto_set_cant_toggle(proto_ber);

    /* Register preferences */
    ber_module = prefs_register_protocol(proto_ber, NULL);

    prefs_register_bool_preference(ber_module, ""show_internals"",
                                   ""Show internal BER encapsulation tokens"",
                                   ""Whether the dissector should also display internal""
                                   "" ASN.1 BER details such as Identifier and Length fields"", &show_internal_ber_fields);
    prefs_register_bool_preference(ber_module, ""decode_unexpected"",
                                   ""Decode unexpected tags as BER encoded data"",
                                   ""Whether the dissector should decode unexpected tags as""
                                   "" ASN.1 BER encoded data"", &decode_unexpected);
    prefs_register_bool_preference(ber_module, ""decode_octetstring"",
                                   ""Decode OCTET STRING as BER encoded data"",
                                   ""Whether the dissector should try decoding OCTET STRINGs as""
                                   "" constructed ASN.1 BER encoded data"", &decode_octetstring_as_ber);

    prefs_register_bool_preference(ber_module, ""decode_primitive"",
                                   ""Decode Primitive as BER encoded data"",
                                   ""Whether the dissector should try decoding unknown primitive as""
                                   "" constructed ASN.1 BER encoded data"", &decode_primitive_as_ber);

    prefs_register_bool_preference(ber_module, ""warn_too_many_bytes"",
                                   ""Warn if too many leading zero bits in encoded data"",
                                   ""Whether the dissector should warn if excessive leading zero (0) bits"",
                                   &decode_warning_leading_zero_bits);

    prefs_register_uat_preference(ber_module, ""oid_table"", ""Object Identifiers"",
                                  ""A table that provides names for object identifiers""
                                  "" and the syntax of any associated values"",
                                  users_uat);

    ber_oid_dissector_table = register_dissector_table(""ber.oid"", ""BER OID Dissectors"", FT_STRING, BASE_NONE, DISSECTOR_TABLE_ALLOW_DUPLICATE);
    ber_syntax_dissector_table = register_dissector_table(""ber.syntax"", ""BER syntax"", FT_STRING, BASE_NONE, DISSECTOR_TABLE_ALLOW_DUPLICATE);
    syntax_table = g_hash_table_new(g_str_hash, g_str_equal); /* oid to syntax */

    register_ber_syntax_dissector(""ASN.1"", proto_ber, dissect_ber_syntax);

    register_init_routine(ber_defragment_init);
    register_cleanup_routine(ber_defragment_cleanup);

    register_decode_as(&ber_da);
}","void
proto_register_ber(void)
{
    static hf_register_info VAR_0[] = {
        { &VAR_1, {
                ""Class"", ""ber.id.class"", VAR_2, VAR_3,
                VALS(VAR_4), 0xc0, ""Class of BER TLV Identifier"", VAR_5 }},
        { &VAR_6, {
                ""Padding"", ""ber.bitstring.padding"", VAR_2, VAR_3,
                NULL, 0x0, ""Number of unused bits in the last octet of the bitstring"", VAR_5 }},
        { &VAR_7, {
                ""Empty"", ""ber.bitstring.empty"", VAR_2, VAR_3,
                NULL, 0x0, ""This is an empty bitstring"", VAR_5 }},
        { &VAR_8, {
                ""P/C"", ""ber.id.pc"", VAR_9, 8,
                TFS(&VAR_10), 0x20, ""Primitive or Constructed BER encoding"", VAR_5 }},
        { &VAR_11, {
                ""Tag"", ""ber.id.uni_tag"", VAR_2, VAR_3|VAR_12,
                &VAR_13, 0x1f, ""Universal tag type"", VAR_5 }},
        { &VAR_14, {
                ""Tag"", ""ber.id.uni_tag"", VAR_15, VAR_3,
                NULL, 0, ""Universal tag type"", VAR_5 }},
        { &VAR_16, {
                ""Tag"", ""ber.id.tag"", VAR_2, VAR_3,
                NULL, 0x1f, ""Tag value for non-Universal classes"", VAR_5 }},
        { &VAR_17, {
                ""Tag"", ""ber.id.tag"", VAR_15, VAR_3,
                NULL, 0, ""Tag value for non-Universal classes"", VAR_5 }},
        { &VAR_18, {
                ""Length"", ""ber.length"", VAR_15, VAR_3,
                NULL, 0, ""Length of contents"", VAR_5 }},
        { &VAR_19, {
                ""OCTETSTRING"", ""ber.unknown.OCTETSTRING"", VAR_20, VAR_21,
                NULL, 0, ""This is an unknown OCTETSTRING"", VAR_5 }},
        { &VAR_22, {
                ""OCTETSTRING [BER encoded]"", ""ber.unknown.OCTETSTRING"", VAR_23, VAR_21,
                NULL, 0, ""This is an BER encoded OCTETSTRING"", VAR_5 }},
        { &VAR_24, {
                ""Primitive [BER encoded]"", ""ber.unknown.primitive"", VAR_23, VAR_21,
                NULL, 0, ""This is a BER encoded Primitive"", VAR_5 }},
        { &VAR_25, {
                ""OID"", ""ber.unknown.OID"", VAR_26, VAR_21,
                NULL, 0, ""This is an unknown Object Identifier"", VAR_5 }},
        { &VAR_27, {
                ""OID"", ""ber.unknown.relative_OID"", VAR_28, VAR_21,
                NULL, 0, ""This is an unknown relative Object Identifier"", VAR_5 }},
        { &VAR_29, {
                ""GRAPHICSTRING"", ""ber.unknown.GRAPHICSTRING"", VAR_30, VAR_21,
                NULL, 0, ""This is an unknown GRAPHICSTRING"", VAR_5 }},
        { &VAR_31, {
                ""NumericString"", ""ber.unknown.NumericString"", VAR_30, VAR_21,
                NULL, 0, ""This is an unknown NumericString"", VAR_5 }},
        { &VAR_32, {
                ""PrintableString"", ""ber.unknown.PrintableString"", VAR_30, VAR_21,
                NULL, 0, ""This is an unknown PrintableString"", VAR_5 }},
        { &VAR_33, {
                ""TeletexString"", ""ber.unknown.TeletexString"", VAR_30, VAR_21,
                NULL, 0, ""This is an unknown TeletexString"", VAR_5 }},
        { &VAR_34, {
                ""VisibleString"", ""ber.unknown.VisibleString"", VAR_30, VAR_21,
                NULL, 0, ""This is an unknown VisibleString"", VAR_5 }},
        { &VAR_35, {
                ""GeneralString"", ""ber.unknown.GeneralString"", VAR_30, VAR_21,
                NULL, 0, ""This is an unknown GeneralString"", VAR_5 }},
        { &VAR_36, {
                ""UniversalString"", ""ber.unknown.UniversalString"", VAR_30, VAR_21,
                NULL, 0, ""This is an unknown UniversalString"", VAR_5 }},
        { &VAR_37, {
                ""BMPString"", ""ber.unknown.BMPString"", VAR_30, VAR_21,
                NULL, 0, ""This is an unknown BMPString"", VAR_5 }},
        { &VAR_38, {
                ""IA5String"", ""ber.unknown.IA5String"", VAR_30, VAR_21,
                NULL, 0, ""This is an unknown IA5String"", VAR_5 }},
        { &VAR_39, {
                ""UTCTime"", ""ber.unknown.UTCTime"", VAR_30, VAR_21,
                NULL, 0, ""This is an unknown UTCTime"", VAR_5 }},
        { &VAR_40, {
                ""UTF8String"", ""ber.unknown.UTF8String"", VAR_30, VAR_21,
                NULL, 0, ""This is an unknown UTF8String"", VAR_5 }},
        { &VAR_41, {
                ""GeneralizedTime"", ""ber.unknown.GeneralizedTime"", VAR_30, VAR_21,
                NULL, 0, ""This is an unknown GeneralizedTime"", VAR_5 }},
        { &VAR_42, {
                ""INTEGER"", ""ber.unknown.INTEGER"", VAR_43, VAR_3,
                NULL, 0, ""This is an unknown INTEGER"", VAR_5 }},
        { &VAR_44, {
                ""REAL"", ""ber.unknown.REAL"", VAR_45, VAR_21,
                NULL, 0, ""This is an unknown REAL"", VAR_5 }},
        { &VAR_46, {
                ""BITSTRING"", ""ber.unknown.BITSTRING"", VAR_20, VAR_21,
                NULL, 0, ""This is an unknown BITSTRING"", VAR_5 }},
        { &VAR_47, {
                ""BOOLEAN"", ""ber.unknown.BOOLEAN"", VAR_2, VAR_48,
                NULL, 0, ""This is an unknown BOOLEAN"", VAR_5 }},
        { &VAR_49, {
                ""ENUMERATED"", ""ber.unknown.ENUMERATED"", VAR_15, VAR_3,
                NULL, 0, ""This is an unknown ENUMERATED"", VAR_5 }},
        { &VAR_50, {
                ""BER Error"", ""ber.error"", VAR_30, VAR_21,
                NULL, 0, NULL, VAR_5 }},
        { &VAR_51,
          { ""direct-reference"", ""ber.direct_reference"",
            VAR_26, VAR_21, NULL, 0,
            ""ber.OBJECT_IDENTIFIER"", VAR_5 }},
        { &VAR_52,
          { ""indirect-reference"", ""ber.indirect_reference"",
            VAR_53, VAR_3, NULL, 0,
            ""ber.INTEGER"", VAR_5 }},
        { &VAR_54,
          { ""data-value-descriptor"", ""ber.data_value_descriptor"",
            VAR_30, VAR_21, NULL, 0,
            ""ber.ObjectDescriptor"", VAR_5 }},
        { &VAR_55,
          { ""encoding"", ""ber.encoding"",
            VAR_15, VAR_3, VALS(VAR_56), 0,
            ""ber.T_encoding"", VAR_5 }},
        { &VAR_57,
          { ""octet-aligned"", ""ber.octet_aligned"",
            VAR_20, VAR_21, NULL, 0,
            ""ber.T_octet_aligned"", VAR_5 }},
        { &VAR_58,
          { ""arbitrary"", ""ber.arbitrary"",
            VAR_20, VAR_21, NULL, 0,
            ""ber.T_arbitrary"", VAR_5 }},
        { &VAR_59,
          { ""single-ASN1-type"", ""ber.single_ASN1_type"",
            VAR_23, VAR_21, NULL, 0,
            ""ber.T_single_ASN1_type"", VAR_5 }},

        /* COMMENT_0 */
        { &VAR_60,
          { ""OCTET STRING fragments"", ""ber.octet_string.fragments"", VAR_23, VAR_21,
            NULL, 0x00, NULL, VAR_5 } },
        { &VAR_61,
          { ""OCTET STRING fragment"", ""ber.octet_string.fragment"", VAR_62, VAR_21,
            NULL, 0x00, NULL, VAR_5 } },
        { &VAR_63,
          { ""OCTET STRING fragment overlap"", ""ber.octet_string.fragment.overlap"", VAR_9,
            VAR_21, NULL, 0x0, NULL, VAR_5 } },
        { &VAR_64,
          { ""OCTET STRING fragment overlapping with conflicting data"",
            ""ber.octet_string.fragment.overlap.conflicts"", VAR_9, VAR_21, NULL,
            0x0, NULL, VAR_5 } },
        { &VAR_65,
          { ""OCTET STRING has multiple tail fragments"",
            ""ber.octet_string.fragment.multiple_tails"", VAR_9, VAR_21,
            NULL, 0x0, NULL, VAR_5 } },
        { &VAR_66,
          { ""OCTET STRING fragment too long"", ""ber.octet_string.fragment.too_long_fragment"",
            VAR_9, VAR_21, NULL, 0x0, NULL,
            VAR_5 } },
        { &VAR_67,
          { ""OCTET STRING defragmentation error"", ""ber.octet_string.fragment.error"", VAR_62,
            VAR_21, NULL, 0x00, NULL, VAR_5 } },
        { &VAR_68,
          { ""OCTET STRING fragment count"", ""ber.octet_string.fragment.count"", VAR_15, VAR_3,
            NULL, 0x00, NULL, VAR_5 } },
        { &VAR_69,
          { ""Reassembled in"", ""ber.octet_string.reassembled.in"", VAR_62, VAR_21,
            NULL, 0x00, NULL, VAR_5 } },
        { &VAR_70,
          { ""Reassembled OCTET STRING length"", ""ber.octet_string.reassembled.length"", VAR_15, VAR_3,
            NULL, 0x00, NULL, VAR_5 } },

      /* COMMENT_1 */
      { &VAR_71, { ""NULL tag"", ""ber.null_tag"", VAR_23, VAR_21, NULL, 0x0, NULL, VAR_5 }},
      { &VAR_72, { ""Unknown Data"", ""ber.unknown_data"", VAR_20, VAR_21, NULL, 0x0, NULL, VAR_5 }},
      { &VAR_73, { ""Unknown OctetString"", ""ber.unknown_octetstring"", VAR_20, VAR_21, NULL, 0x0, NULL, VAR_5 }},
      { &VAR_74, { ""SEQ FIELD EOC"", ""ber.seq_field_eoc"", VAR_20, VAR_21, NULL, 0x0, NULL, VAR_5 }},
      { &VAR_75, { ""SEQ EOC"", ""ber.seq_eoc"", VAR_20, VAR_21, NULL, 0x0, NULL, VAR_5 }},
      { &VAR_76, { ""SET FIELD EOC"", ""ber.set_field_eoc"", VAR_20, VAR_21, NULL, 0x0, NULL, VAR_5 }},
      { &VAR_77, { ""SET EOC"", ""ber.set_eoc"", VAR_20, VAR_21, NULL, 0x0, NULL, VAR_5 }},
      { &VAR_78, { ""CHOICE EOC"", ""ber.choice_eoc"", VAR_20, VAR_21, NULL, 0x0, NULL, VAR_5 }},
      { &VAR_79, { ""SEQ OF EOC"", ""ber.seq_of_eoc"", VAR_20, VAR_21, NULL, 0x0, NULL, VAR_5 }},
      { &VAR_80, { ""64bits unsigned integer"", ""ber.64bit_uint_as_bytes"", VAR_20, VAR_21, NULL, 0x0, NULL, VAR_5 }},
    };


    static gint *VAR_81[] = {
        &VAR_82,
        &VAR_83,
        &VAR_84,
        &VAR_85,
        &VAR_86,
        &VAR_87,
        &VAR_88,
        &VAR_89,
        &VAR_90
    };
    static ei_register_info VAR_91[] = {
        { &VAR_92, { ""ber.size_constraint.string"", VAR_93, VAR_94, ""Size constraint: string"", VAR_95 }},
        { &VAR_96, { ""ber.size_constraint.value"", VAR_93, VAR_94, ""Size constraint: values"", VAR_95 }},
        { &VAR_97, { ""ber.size_constraint.items"", VAR_93, VAR_94, ""Size constraint: items"", VAR_95 }},
        { &VAR_98, { ""ber.error.sequence.field_wrong"", VAR_99, VAR_94, ""BER Error: Wrong field in SEQUENCE"", VAR_95 }},
        { &VAR_100, { ""ber.error.expected.octet_string"", VAR_99, VAR_94, ""BER Error: OctetString expected"", VAR_95 }},
        { &VAR_101, { ""ber.error.expected.null"", VAR_99, VAR_94, ""BER Error: NULL expected"", VAR_95 }},
        { &VAR_102, { ""ber.error.expected.null_zero_length"", VAR_99, VAR_94, ""BER Error: NULL expect zero length"", VAR_95 }},
        { &VAR_103, { ""ber.error.expected.sequence"", VAR_99, VAR_94, ""BER Error: Sequence expected"", VAR_95 }},
        { &VAR_104, { ""ber.error.expected.set"", VAR_99, VAR_94, ""BER Error: SET expected"", VAR_95 }},
        { &VAR_105, { ""ber.error.expected.string"", VAR_99, VAR_94, ""BER Error: String expected"", VAR_95 }},
        { &VAR_106, { ""ber.error.expected.object_identifier"", VAR_99, VAR_94, ""BER Error: Object Identifier expected"", VAR_95 }},
        { &VAR_107, { ""ber.error.expected.generalized_time"", VAR_99, VAR_94, ""BER Error: GeneralizedTime expected"", VAR_95 }},
        { &VAR_108, { ""ber.error.expected.utc_time"", VAR_99, VAR_94, ""BER Error: UTCTime expected"", VAR_95 }},
        { &VAR_109, { ""ber.error.expected.bitstring"", VAR_99, VAR_94, ""BER Error: BitString expected"", VAR_95 }},
        { &VAR_110, { ""ber.error.length"", VAR_99, VAR_94, ""BER Error length"", VAR_95 }},
        { &VAR_111, { ""ber.error.wrong_tag_in_tagged_type"", VAR_99, VAR_94, ""BER Error: Wrong tag in tagged type"", VAR_95 }},
        { &VAR_112, { ""ber.error.universal_tag_unknown"", VAR_99, VAR_94, ""BER Error: can not handle universal"", VAR_95 }},
        { &VAR_113, { ""ber.error.no_oid"", VAR_99, VAR_94, ""BER Error: No OID supplied to call_ber_oid_callback"", VAR_95 }},
        { &VAR_114, { ""ber.error.oid_not_implemented"", VAR_115, VAR_94, ""BER: Dissector for OID not implemented. Contact Wireshark developers if you want this supported"", VAR_95 }},
        { &VAR_116, { ""ber.error.syntax_not_implemented"", VAR_115, VAR_94, ""BER: Syntax not implemented"", VAR_95 }},
        { &VAR_117, { ""ber.error.value_too_many_bytes"", VAR_99, VAR_94, ""Value is encoded with too many bytes"", VAR_95 }},
        { &VAR_118, { ""ber.error.unknown_field.sequence"", VAR_99, VAR_94, ""BER Error: Unknown field in Sequence"", VAR_95 }},
        { &VAR_119, { ""ber.error.unknown_field.set"", VAR_99, VAR_94, ""BER Error: Unknown field in SET"", VAR_95 }},
        { &VAR_120, { ""ber.error.missing_field.set"", VAR_99, VAR_94, ""BER Error: Missing field in SET"", VAR_95 }},
        { &VAR_121, { ""ber.error.empty_choice"", VAR_99, VAR_94, ""BER Error: Empty choice was found"", VAR_95 }},
        { &VAR_122, { ""ber.error.choice_not_found"", VAR_99, VAR_94, ""BER Error: This choice field was not found"", VAR_95 }},
        { &VAR_123, { ""ber.error.bits_unknown"", VAR_115, VAR_94, ""BER Error: Bits unknown"", VAR_95 }},
        { &VAR_124, { ""ber.error.bits_set_padded"", VAR_115, VAR_94, ""BER Error: Bits set in padded area"", VAR_95 }},
        { &VAR_125, { ""ber.error.illegal_padding"", VAR_115, VAR_94, ""Illegal padding"", VAR_95 }},
        { &VAR_126, { ""ber.error.invalid_format.generalized_time"", VAR_99, VAR_94, ""BER Error: GeneralizedTime invalid format"", VAR_95 }},
        { &VAR_127, { ""ber.error.invalid_format.utctime"", VAR_99, VAR_94, ""BER Error: malformed UTCTime encoding"", VAR_95 }},
        { &VAR_128, { ""ber.error.hf_field_not_integer_type"", VAR_93, VAR_129, ""Was passed a HF field that was not integer type"", VAR_95 }},
        { &VAR_130,{ ""ber.error.constr_bitstr.len"", VAR_99, VAR_94, ""BER Error: malformed Bitstring encoding"", VAR_95 } },
    };

    /* COMMENT_2 */
    static build_valid_func VAR_131[1] = {VAR_132};
    static decode_as_value_t VAR_133 = {VAR_134, 1, VAR_131};
    static decode_as_t VAR_135 = {""ber"", ""ASN.1"", ""ber.syntax"", 1, 0, &VAR_133, NULL, NULL,
                                VAR_136, VAR_137, VAR_138, NULL};

    module_t *VAR_139;
    expert_module_t* VAR_140;
    uat_t* VAR_141 = uat_new(""OID Tables"",
                               sizeof(VAR_142),
                               ""oid"",
                               FALSE,
                               &VAR_143,
                               &VAR_144,
                               VAR_145, /* COMMENT_3 */
                               ""ChObjectIdentifiers"",
                               VAR_146,
                               NULL,
                               VAR_147,
                               VAR_148,
                               VAR_149);

    VAR_150 = proto_register_protocol(""Basic Encoding Rules (ASN.1 X.690)"", ""BER"", ""ber"");

    VAR_151 = register_dissector(""ber"", VAR_152, VAR_150);

    proto_register_field_array(VAR_150, VAR_0, array_length(VAR_0));
    proto_register_subtree_array(VAR_81, array_length(VAR_81));
    VAR_140 = expert_register_protocol(VAR_150);
    expert_register_field_array(VAR_140, VAR_91, array_length(VAR_91));

    proto_set_cant_toggle(VAR_150);

    /* COMMENT_4 */
    VAR_139 = prefs_register_protocol(VAR_150, NULL);

    prefs_register_bool_preference(VAR_139, ""show_internals"",
                                   ""Show internal BER encapsulation tokens"",
                                   ""Whether the dissector should also display internal""
                                   "" ASN.1 BER details such as Identifier and Length fields"", &VAR_153);
    prefs_register_bool_preference(VAR_139, ""decode_unexpected"",
                                   ""Decode unexpected tags as BER encoded data"",
                                   ""Whether the dissector should decode unexpected tags as""
                                   "" ASN.1 BER encoded data"", &VAR_154);
    prefs_register_bool_preference(VAR_139, ""decode_octetstring"",
                                   ""Decode OCTET STRING as BER encoded data"",
                                   ""Whether the dissector should try decoding OCTET STRINGs as""
                                   "" constructed ASN.1 BER encoded data"", &VAR_155);

    prefs_register_bool_preference(VAR_139, ""decode_primitive"",
                                   ""Decode Primitive as BER encoded data"",
                                   ""Whether the dissector should try decoding unknown primitive as""
                                   "" constructed ASN.1 BER encoded data"", &VAR_156);

    prefs_register_bool_preference(VAR_139, ""warn_too_many_bytes"",
                                   ""Warn if too many leading zero bits in encoded data"",
                                   ""Whether the dissector should warn if excessive leading zero (0) bits"",
                                   &VAR_157);

    prefs_register_uat_preference(VAR_139, ""oid_table"", ""Object Identifiers"",
                                  ""A table that provides names for object identifiers""
                                  "" and the syntax of any associated values"",
                                  VAR_141);

    VAR_158 = register_dissector_table(""ber.oid"", ""BER OID Dissectors"", VAR_30, VAR_21, VAR_159);
    VAR_160 = register_dissector_table(""ber.syntax"", ""BER syntax"", VAR_30, VAR_21, VAR_159);
    VAR_161 = g_hash_table_new(VAR_162, VAR_163); /* COMMENT_5 */

    register_ber_syntax_dissector(""ASN.1"", VAR_150, VAR_164);

    register_init_routine(VAR_165);
    register_cleanup_routine(VAR_166);

    register_decode_as(&VAR_135);
}",wireshark/9b2f3f7c5c9205381cb72e42b66e97d8ed3abf63/packet-ber.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -220,6 +220,7 @@
         { &ei_ber_invalid_format_generalized_time, { ""ber.error.invalid_format.generalized_time"", PI_MALFORMED, PI_WARN, ""BER Error: GeneralizedTime invalid format"", EXPFILL }},
         { &ei_ber_invalid_format_utctime, { ""ber.error.invalid_format.utctime"", PI_MALFORMED, PI_WARN, ""BER Error: malformed UTCTime encoding"", EXPFILL }},
         { &ei_hf_field_not_integer_type, { ""ber.error.hf_field_not_integer_type"", PI_PROTOCOL, PI_ERROR, ""Was passed a HF field that was not integer type"", EXPFILL }},
+        { &ei_ber_constr_bitstr,{ ""ber.error.constr_bitstr.len"", PI_MALFORMED, PI_WARN, ""BER Error: malformed Bitstring encoding"", EXPFILL } },
     };
 
     /* Decode As handling */","{'deleted_lines': [], 'added_lines': ['        { &ei_ber_constr_bitstr,{ ""ber.error.constr_bitstr.len"", PI_MALFORMED, PI_WARN, ""BER Error: malformed Bitstring encoding"", EXPFILL } },']}",True,"The dissect_ber_constrained_bitstring function in epan/dissectors/packet-ber.c in the ASN.1 BER dissector in Wireshark 2.0.x before 2.0.2 does not verify that a certain length is nonzero, which allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted packet.",5.9,MEDIUM,1,test,2016-01-14T14:56:06Z,1
CVE-2016-2522,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"[BER] Fix Wireshark heap-based out-of-bounds read in dissect_ber_constrained_bitstring

Bug: 11828
Change-Id: I43c493ed261e73e0f3b31892c161dcfc46071054
Reviewed-on: https://code.wireshark.org/review/13292
Petri-Dish: Anders Broman <a.broman58@gmail.com>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Anders Broman <a.broman58@gmail.com>",9b2f3f7c5c9205381cb72e42b66e97d8ed3abf63,https://github.com/wireshark/wireshark/commit/9b2f3f7c5c9205381cb72e42b66e97d8ed3abf63,epan/dissectors/packet-ber.c,dissect_ber_constrained_bitstring,"int
dissect_ber_constrained_bitstring(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, const asn_namedbit *named_bits, gint hf_id, gint ett_id, tvbuff_t **out_tvb)
{
gint8       ber_class;
gboolean    pc, ind;
gint32      tag;
guint32     len, byteno;
guint8      pad  = 0, b0, b1, val, *bitstring;
int         end_offset;
int         hoffset;
proto_item *item = NULL;
proto_item *cause;
proto_tree *tree = NULL;
const char *sep;
gboolean    term;
const asn_namedbit *nb;
if (!implicit_tag) {
hoffset = offset;
offset = dissect_ber_identifier(actx->pinfo, parent_tree, tvb, offset, &ber_class, &pc, &tag);
offset = dissect_ber_length(actx->pinfo, parent_tree, tvb, offset, &len, &ind);
end_offset = offset + len;
if (!implicit_tag && (ber_class != BER_CLASS_APP)) {
if ( (ber_class != BER_CLASS_UNI)
|| (tag != BER_UNI_TAG_BITSTRING) ) {
tvb_ensure_bytes_exist(tvb, hoffset, 2);
cause = proto_tree_add_string_format_value(
parent_tree, hf_ber_error, tvb, offset, len, ""bitstring_expected"",
""BitString expected but class:%s(%d) %s tag:%d was unexpected"",
val_to_str_const(ber_class, ber_class_codes, ""Unknown""),
ber_class, pc ? ber_pc_codes_short.true_string : ber_pc_codes_short.false_string,
tag);
expert_add_info(actx->pinfo, cause, &ei_ber_expected_bitstring);
if (decode_unexpected) {
proto_tree *unknown_tree = proto_item_add_subtree(cause, ett_ber_unknown);
dissect_unknown_ber(actx->pinfo, tvb, hoffset, unknown_tree);
}
return end_offset;
}
}
} else {
pc=0;
len = tvb_reported_length_remaining(tvb, offset);
end_offset = offset+len;
}
actx->created_item = NULL;
if (pc) {
} else {
pad = tvb_get_guint8(tvb, offset);
if ((pad == 0) && (len == 1)) {
proto_tree_add_item(parent_tree, hf_ber_bitstring_empty, tvb, offset, 1, ENC_BIG_ENDIAN);
} else {
proto_item *pad_item = proto_tree_add_item(parent_tree, hf_ber_bitstring_padding, tvb, offset, 1, ENC_BIG_ENDIAN);
if (pad > 7) {
expert_add_info_format(
actx->pinfo, pad_item, &ei_ber_illegal_padding,
""Illegal padding (0 .. 7): %d"", pad);
}
}
offset++;
len--;
if (hf_id >= 0) {
item = proto_tree_add_item(parent_tree, hf_id, tvb, offset, len, ENC_BIG_ENDIAN);
actx->created_item = item;
if (ett_id != -1) {
tree = proto_item_add_subtree(item, ett_id);
}
}
if (out_tvb) {
*out_tvb = ber_tvb_new_subset_length(tvb, offset, len);
}
}
if (named_bits) {
sep  = "" ("";
term = FALSE;
nb = named_bits;
bitstring = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, offset, len);
while (nb->p_id) {
if ((len > 0) && (pad < 8*len) && (nb->bit < (8*len-pad))) {
val = tvb_get_guint8(tvb, offset + nb->bit/8);
bitstring[(nb->bit/8)] &= ~(0x80 >> (nb->bit%8));
val &= 0x80 >> (nb->bit%8);
b0 = (nb->gb0 == -1) ? nb->bit/8 :
((guint32)nb->gb0)/8;
b1 = (nb->gb1 == -1) ? nb->bit/8 :
((guint32)nb->gb1)/8;
proto_tree_add_item(tree, *(nb->p_id), tvb, offset + b0, b1 - b0 + 1, ENC_BIG_ENDIAN);
} else {  
val = 0;
proto_tree_add_boolean(tree, *(nb->p_id), tvb, offset + len, 0, 0x00);
}
if (val) {
if (item && nb->tstr) {
proto_item_append_text(item, ""%s%s"", sep, nb->tstr);
sep  = "", "";
term = TRUE;
}
} else {
if (item && nb->fstr) {
proto_item_append_text(item, ""%s%s"", sep, nb->fstr);
sep  = "", "";
term = TRUE;
}
}
nb++;
}
if (term)
proto_item_append_text(item, "")"");
for (byteno = 0; byteno < len; byteno++) {
if (bitstring[byteno]) {
expert_add_info_format(
actx->pinfo, item, &ei_ber_bits_unknown,
""Unknown bit(s): 0x%s"", bytes_to_str(wmem_packet_scope(), bitstring, len));
break;
}
}
}
if ((pad > 0) && (pad < 8) && (len > 0)) {
guint8 bits_in_pad = tvb_get_guint8(tvb, offset + len - 1) & (0xFF >> (8-pad));
if (bits_in_pad) {
expert_add_info_format(
actx->pinfo, item, &ei_ber_bits_set_padded,
""Bits set in padded area: 0x%02x"", bits_in_pad);
}
}
ber_check_length(8*len-pad, min_len, max_len, actx, item, TRUE);
return end_offset;
}","int
dissect_ber_constrained_bitstring(gboolean VAR_0, asn1_ctx_t *VAR_1, proto_tree *VAR_2, tvbuff_t *VAR_3, int VAR_4, gint32 VAR_5, gint32 VAR_6, const asn_namedbit *VAR_7, gint VAR_8, gint VAR_9, tvbuff_t **VAR_10)
{
gint8       VAR_11;
gboolean    VAR_12, VAR_13;
gint32      VAR_14;
guint32     VAR_15, VAR_16;
guint8      VAR_17  = 0, VAR_18, VAR_19, VAR_20, *VAR_21;
int         VAR_22;
int         VAR_23;
proto_item *VAR_24 = NULL;
proto_item *VAR_25;
proto_tree *VAR_26 = NULL;
const char *VAR_27;
gboolean    VAR_28;
const asn_namedbit *VAR_29;
if (!VAR_0) {
VAR_23 = VAR_4;
VAR_4 = dissect_ber_identifier(VAR_1->pinfo, VAR_2, VAR_3, VAR_4, &VAR_11, &VAR_12, &VAR_14);
VAR_4 = dissect_ber_length(VAR_1->pinfo, VAR_2, VAR_3, VAR_4, &VAR_15, &VAR_13);
VAR_22 = VAR_4 + VAR_15;
if (!VAR_0 && (VAR_11 != VAR_30)) {
if ( (VAR_11 != VAR_31)
|| (VAR_14 != VAR_32) ) {
tvb_ensure_bytes_exist(VAR_3, VAR_23, 2);
VAR_25 = proto_tree_add_string_format_value(
VAR_2, VAR_33, VAR_3, VAR_4, VAR_15, ""bitstring_expected"",
""BitString expected but class:%s(%d) %s tag:%d was unexpected"",
val_to_str_const(VAR_11, VAR_34, ""Unknown""),
VAR_11, VAR_12 ? VAR_35.true_string : VAR_35.false_string,
VAR_14);
expert_add_info(VAR_1->pinfo, VAR_25, &VAR_36);
if (VAR_37) {
proto_tree *VAR_38 = proto_item_add_subtree(VAR_25, VAR_39);
dissect_unknown_ber(VAR_1->pinfo, VAR_3, VAR_23, VAR_38);
}
return VAR_22;
}
}
} else {
VAR_12=0;
VAR_15 = tvb_reported_length_remaining(VAR_3, VAR_4);
VAR_22 = VAR_4+VAR_15;
}
VAR_1->created_item = NULL;
if (VAR_12) {
} else {
VAR_17 = tvb_get_guint8(VAR_3, VAR_4);
if ((VAR_17 == 0) && (VAR_15 == 1)) {
proto_tree_add_item(VAR_2, VAR_40, VAR_3, VAR_4, 1, VAR_41);
} else {
proto_item *VAR_42 = proto_tree_add_item(VAR_2, VAR_43, VAR_3, VAR_4, 1, VAR_41);
if (VAR_17 > 7) {
expert_add_info_format(
VAR_1->pinfo, VAR_42, &VAR_44,
""Illegal padding (0 .. 7): %d"", VAR_17);
}
}
VAR_4++;
VAR_15--;
if (VAR_8 >= 0) {
VAR_24 = proto_tree_add_item(VAR_2, VAR_8, VAR_3, VAR_4, VAR_15, VAR_41);
VAR_1->created_item = VAR_24;
if (VAR_9 != -1) {
VAR_26 = proto_item_add_subtree(VAR_24, VAR_9);
}
}
if (VAR_10) {
*VAR_10 = ber_tvb_new_subset_length(VAR_3, VAR_4, VAR_15);
}
}
if (VAR_7) {
VAR_27  = "" ("";
VAR_28 = FALSE;
VAR_29 = VAR_7;
VAR_21 = (guint8 *)tvb_memdup(wmem_packet_scope(), VAR_3, VAR_4, VAR_15);
while (VAR_29->p_id) {
if ((VAR_15 > 0) && (VAR_17 < 8*VAR_15) && (VAR_29->bit < (8*VAR_15-VAR_17))) {
VAR_20 = tvb_get_guint8(VAR_3, VAR_4 + VAR_29->bit/8);
VAR_21[(VAR_29->bit/8)] &= ~(0x80 >> (VAR_29->bit%8));
VAR_20 &= 0x80 >> (VAR_29->bit%8);
VAR_18 = (VAR_29->gb0 == -1) ? VAR_29->bit/8 :
((guint32)VAR_29->gb0)/8;
VAR_19 = (VAR_29->gb1 == -1) ? VAR_29->bit/8 :
((guint32)VAR_29->gb1)/8;
proto_tree_add_item(VAR_26, *(VAR_29->p_id), VAR_3, VAR_4 + VAR_18, VAR_19 - VAR_18 + 1, VAR_41);
} else {  
VAR_20 = 0;
proto_tree_add_boolean(VAR_26, *(VAR_29->p_id), VAR_3, VAR_4 + VAR_15, 0, 0x00);
}
if (VAR_20) {
if (VAR_24 && VAR_29->tstr) {
proto_item_append_text(VAR_24, ""%s%s"", VAR_27, VAR_29->tstr);
VAR_27  = "", "";
VAR_28 = TRUE;
}
} else {
if (VAR_24 && VAR_29->fstr) {
proto_item_append_text(VAR_24, ""%s%s"", VAR_27, VAR_29->fstr);
VAR_27  = "", "";
VAR_28 = TRUE;
}
}
VAR_29++;
}
if (VAR_28)
proto_item_append_text(VAR_24, "")"");
for (VAR_16 = 0; VAR_16 < VAR_15; VAR_16++) {
if (VAR_21[VAR_16]) {
expert_add_info_format(
VAR_1->pinfo, VAR_24, &VAR_45,
""Unknown bit(s): 0x%s"", bytes_to_str(wmem_packet_scope(), VAR_21, VAR_15));
break;
}
}
}
if ((VAR_17 > 0) && (VAR_17 < 8) && (VAR_15 > 0)) {
guint8 VAR_46 = tvb_get_guint8(VAR_3, VAR_4 + VAR_15 - 1) & (0xFF >> (8-VAR_17));
if (VAR_46) {
expert_add_info_format(
VAR_1->pinfo, VAR_24, &VAR_47,
""Bits set in padded area: 0x%02x"", VAR_46);
}
}
ber_check_length(8*VAR_15-VAR_17, VAR_5, VAR_6, VAR_1, VAR_24, TRUE);
return VAR_22;
}",wireshark/9b2f3f7c5c9205381cb72e42b66e97d8ed3abf63/packet-ber.c/vul/before/1.json,"int
dissect_ber_constrained_bitstring(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, const asn_namedbit *named_bits, gint hf_id, gint ett_id, tvbuff_t **out_tvb)
{
    gint8       ber_class;
    gboolean    pc, ind;
    gint32      tag;
    guint32     len, byteno;
    guint8      pad  = 0, b0, b1, val, *bitstring;
    int         end_offset;
    int         hoffset;
    proto_item *item = NULL;
    proto_item *cause;
    proto_tree *tree = NULL;
    const char *sep;
    gboolean    term;
    const asn_namedbit *nb;

    if (!implicit_tag) {
        hoffset = offset;
        /* read header and len for the octet string */
        offset = dissect_ber_identifier(actx->pinfo, parent_tree, tvb, offset, &ber_class, &pc, &tag);
        offset = dissect_ber_length(actx->pinfo, parent_tree, tvb, offset, &len, &ind);
        end_offset = offset + len;

        /* sanity check: we only handle Universal BitStrings */

        /* for an IMPLICIT APPLICATION tag asn2eth seems to call this
           function with implicit_tag = FALSE. BER_FLAGS_NOOWNTAG was
           set so the APPLICATION tag was still present.
           So here we relax it for APPLICATION tags. CONTEXT tags may
           still cause a problem. */

        if (!implicit_tag && (ber_class != BER_CLASS_APP)) {
            if ( (ber_class != BER_CLASS_UNI)
              || (tag != BER_UNI_TAG_BITSTRING) ) {
                tvb_ensure_bytes_exist(tvb, hoffset, 2);
                cause = proto_tree_add_string_format_value(
                    parent_tree, hf_ber_error, tvb, offset, len, ""bitstring_expected"",
                    ""BitString expected but class:%s(%d) %s tag:%d was unexpected"",
                    val_to_str_const(ber_class, ber_class_codes, ""Unknown""),
                    ber_class, pc ? ber_pc_codes_short.true_string : ber_pc_codes_short.false_string,
                    tag);
                expert_add_info(actx->pinfo, cause, &ei_ber_expected_bitstring);
                if (decode_unexpected) {
                    proto_tree *unknown_tree = proto_item_add_subtree(cause, ett_ber_unknown);
                    dissect_unknown_ber(actx->pinfo, tvb, hoffset, unknown_tree);
                }
                return end_offset;
            }
        }
    } else {
        pc=0;
        len = tvb_reported_length_remaining(tvb, offset);
        end_offset = offset+len;
    }
    if (len == 0) {
        proto_tree_add_expert_format(
            parent_tree, actx->pinfo, &ei_ber_constr_bitstr, tvb, offset, len,
            ""dissect_ber_constrained_bitstring(): frame:%u offset:%d Was passed an illegal length of 0"",
            actx->pinfo->fd->num, offset);
        return offset;
    }
    actx->created_item = NULL;

    if (pc) {
        /* constructed */
        /* TO DO */
    } else {
        /* primitive */
        pad = tvb_get_guint8(tvb, offset);
        if ((pad == 0) && (len == 1)) {
            /* empty */
            proto_tree_add_item(parent_tree, hf_ber_bitstring_empty, tvb, offset, 1, ENC_BIG_ENDIAN);
        } else {
            /* padding */
            proto_item *pad_item = proto_tree_add_item(parent_tree, hf_ber_bitstring_padding, tvb, offset, 1, ENC_BIG_ENDIAN);
            if (pad > 7) {
                expert_add_info_format(
                    actx->pinfo, pad_item, &ei_ber_illegal_padding,
                    ""Illegal padding (0 .. 7): %d"", pad);
            }
        }
        offset++;
        len--;
        if (hf_id >= 0) {
            item = proto_tree_add_item(parent_tree, hf_id, tvb, offset, len, ENC_BIG_ENDIAN);
            actx->created_item = item;
            if (ett_id != -1) {
                tree = proto_item_add_subtree(item, ett_id);
            }
        }
        if (out_tvb) {
            *out_tvb = ber_tvb_new_subset_length(tvb, offset, len);
        }
    }

    if (named_bits) {
        sep  = "" ("";
        term = FALSE;
        nb = named_bits;
        bitstring = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, offset, len);

        while (nb->p_id) {
            if ((len > 0) && (pad < 8*len) && (nb->bit < (8*len-pad))) {
                val = tvb_get_guint8(tvb, offset + nb->bit/8);
                bitstring[(nb->bit/8)] &= ~(0x80 >> (nb->bit%8));
                val &= 0x80 >> (nb->bit%8);
                b0 = (nb->gb0 == -1) ? nb->bit/8 :
                               ((guint32)nb->gb0)/8;
                b1 = (nb->gb1 == -1) ? nb->bit/8 :
                               ((guint32)nb->gb1)/8;
                proto_tree_add_item(tree, *(nb->p_id), tvb, offset + b0, b1 - b0 + 1, ENC_BIG_ENDIAN);
            } else {  /* 8.6.2.4 */
                val = 0;
                proto_tree_add_boolean(tree, *(nb->p_id), tvb, offset + len, 0, 0x00);
            }
            if (val) {
                if (item && nb->tstr) {
                    proto_item_append_text(item, ""%s%s"", sep, nb->tstr);
                    sep  = "", "";
                    term = TRUE;
                }
            } else {
                if (item && nb->fstr) {
                    proto_item_append_text(item, ""%s%s"", sep, nb->fstr);
                    sep  = "", "";
                    term = TRUE;
                }
            }
            nb++;
        }
        if (term)
            proto_item_append_text(item, "")"");

        for (byteno = 0; byteno < len; byteno++) {
            if (bitstring[byteno]) {
                expert_add_info_format(
                    actx->pinfo, item, &ei_ber_bits_unknown,
                    ""Unknown bit(s): 0x%s"", bytes_to_str(wmem_packet_scope(), bitstring, len));
                break;
            }
        }
    }

    if ((pad > 0) && (pad < 8) && (len > 0)) {
        guint8 bits_in_pad = tvb_get_guint8(tvb, offset + len - 1) & (0xFF >> (8-pad));
        if (bits_in_pad) {
            expert_add_info_format(
                actx->pinfo, item, &ei_ber_bits_set_padded,
                ""Bits set in padded area: 0x%02x"", bits_in_pad);
        }
    }

    ber_check_length(8*len-pad, min_len, max_len, actx, item, TRUE);

    return end_offset;
}","int
dissect_ber_constrained_bitstring(gboolean VAR_0, asn1_ctx_t *VAR_1, proto_tree *VAR_2, tvbuff_t *VAR_3, int VAR_4, gint32 VAR_5, gint32 VAR_6, const asn_namedbit *VAR_7, gint VAR_8, gint VAR_9, tvbuff_t **VAR_10)
{
    gint8       VAR_11;
    gboolean    VAR_12, VAR_13;
    gint32      VAR_14;
    guint32     VAR_15, VAR_16;
    guint8      VAR_17  = 0, VAR_18, VAR_19, VAR_20, *VAR_21;
    int         VAR_22;
    int         VAR_23;
    proto_item *VAR_24 = NULL;
    proto_item *VAR_25;
    proto_tree *VAR_26 = NULL;
    const char *VAR_27;
    gboolean    VAR_28;
    const asn_namedbit *VAR_29;

    if (!VAR_0) {
        VAR_23 = VAR_4;
        /* COMMENT_0 */
        VAR_4 = dissect_ber_identifier(VAR_1->pinfo, VAR_2, VAR_3, VAR_4, &VAR_11, &VAR_12, &VAR_14);
        VAR_4 = dissect_ber_length(VAR_1->pinfo, VAR_2, VAR_3, VAR_4, &VAR_15, &VAR_13);
        VAR_22 = VAR_4 + VAR_15;

        /* COMMENT_1 */

        /* COMMENT_2 */
                                                                     
                                                        
                                                                     
                                    

        if (!VAR_0 && (VAR_11 != VAR_30)) {
            if ( (VAR_11 != VAR_31)
              || (VAR_14 != VAR_32) ) {
                tvb_ensure_bytes_exist(VAR_3, VAR_23, 2);
                VAR_25 = proto_tree_add_string_format_value(
                    VAR_2, VAR_33, VAR_3, VAR_4, VAR_15, ""bitstring_expected"",
                    ""BitString expected but class:%s(%d) %s tag:%d was unexpected"",
                    val_to_str_const(VAR_11, VAR_34, ""Unknown""),
                    VAR_11, VAR_12 ? VAR_35.true_string : VAR_35.false_string,
                    VAR_14);
                expert_add_info(VAR_1->pinfo, VAR_25, &VAR_36);
                if (VAR_37) {
                    proto_tree *VAR_38 = proto_item_add_subtree(VAR_25, VAR_39);
                    dissect_unknown_ber(VAR_1->pinfo, VAR_3, VAR_23, VAR_38);
                }
                return VAR_22;
            }
        }
    } else {
        VAR_12=0;
        VAR_15 = tvb_reported_length_remaining(VAR_3, VAR_4);
        VAR_22 = VAR_4+VAR_15;
    }
    if (VAR_15 == 0) {
        proto_tree_add_expert_format(
            VAR_2, VAR_1->pinfo, &VAR_40, VAR_3, VAR_4, VAR_15,
            ""dissect_ber_constrained_bitstring(): frame:%u offset:%d Was passed an illegal length of 0"",
            VAR_1->pinfo->fd->num, VAR_4);
        return VAR_4;
    }
    VAR_1->created_item = NULL;

    if (VAR_12) {
        /* COMMENT_7 */
        /* COMMENT_8 */
    } else {
        /* COMMENT_9 */
        VAR_17 = tvb_get_guint8(VAR_3, VAR_4);
        if ((VAR_17 == 0) && (VAR_15 == 1)) {
            /* COMMENT_10 */
            proto_tree_add_item(VAR_2, VAR_41, VAR_3, VAR_4, 1, VAR_42);
        } else {
            /* COMMENT_11 */
            proto_item *VAR_43 = proto_tree_add_item(VAR_2, VAR_44, VAR_3, VAR_4, 1, VAR_42);
            if (VAR_17 > 7) {
                expert_add_info_format(
                    VAR_1->pinfo, VAR_43, &VAR_45,
                    ""Illegal padding (0 .. 7): %d"", VAR_17);
            }
        }
        VAR_4++;
        VAR_15--;
        if (VAR_8 >= 0) {
            VAR_24 = proto_tree_add_item(VAR_2, VAR_8, VAR_3, VAR_4, VAR_15, VAR_42);
            VAR_1->created_item = VAR_24;
            if (VAR_9 != -1) {
                VAR_26 = proto_item_add_subtree(VAR_24, VAR_9);
            }
        }
        if (VAR_10) {
            *VAR_10 = ber_tvb_new_subset_length(VAR_3, VAR_4, VAR_15);
        }
    }

    if (VAR_7) {
        VAR_27  = "" ("";
        VAR_28 = FALSE;
        VAR_29 = VAR_7;
        VAR_21 = (guint8 *)tvb_memdup(wmem_packet_scope(), VAR_3, VAR_4, VAR_15);

        while (VAR_29->p_id) {
            if ((VAR_15 > 0) && (VAR_17 < 8*VAR_15) && (VAR_29->bit < (8*VAR_15-VAR_17))) {
                VAR_20 = tvb_get_guint8(VAR_3, VAR_4 + VAR_29->bit/8);
                VAR_21[(VAR_29->bit/8)] &= ~(0x80 >> (VAR_29->bit%8));
                VAR_20 &= 0x80 >> (VAR_29->bit%8);
                VAR_18 = (VAR_29->gb0 == -1) ? VAR_29->bit/8 :
                               ((guint32)VAR_29->gb0)/8;
                VAR_19 = (VAR_29->gb1 == -1) ? VAR_29->bit/8 :
                               ((guint32)VAR_29->gb1)/8;
                proto_tree_add_item(VAR_26, *(VAR_29->p_id), VAR_3, VAR_4 + VAR_18, VAR_19 - VAR_18 + 1, VAR_42);
            } else {  /* COMMENT_12 */
                VAR_20 = 0;
                proto_tree_add_boolean(VAR_26, *(VAR_29->p_id), VAR_3, VAR_4 + VAR_15, 0, 0x00);
            }
            if (VAR_20) {
                if (VAR_24 && VAR_29->tstr) {
                    proto_item_append_text(VAR_24, ""%s%s"", VAR_27, VAR_29->tstr);
                    VAR_27  = "", "";
                    VAR_28 = TRUE;
                }
            } else {
                if (VAR_24 && VAR_29->fstr) {
                    proto_item_append_text(VAR_24, ""%s%s"", VAR_27, VAR_29->fstr);
                    VAR_27  = "", "";
                    VAR_28 = TRUE;
                }
            }
            VAR_29++;
        }
        if (VAR_28)
            proto_item_append_text(VAR_24, "")"");

        for (VAR_16 = 0; VAR_16 < VAR_15; VAR_16++) {
            if (VAR_21[VAR_16]) {
                expert_add_info_format(
                    VAR_1->pinfo, VAR_24, &VAR_46,
                    ""Unknown bit(s): 0x%s"", bytes_to_str(wmem_packet_scope(), VAR_21, VAR_15));
                break;
            }
        }
    }

    if ((VAR_17 > 0) && (VAR_17 < 8) && (VAR_15 > 0)) {
        guint8 VAR_47 = tvb_get_guint8(VAR_3, VAR_4 + VAR_15 - 1) & (0xFF >> (8-VAR_17));
        if (VAR_47) {
            expert_add_info_format(
                VAR_1->pinfo, VAR_24, &VAR_48,
                ""Bits set in padded area: 0x%02x"", VAR_47);
        }
    }

    ber_check_length(8*VAR_15-VAR_17, VAR_5, VAR_6, VAR_1, VAR_24, TRUE);

    return VAR_22;
}",wireshark/9b2f3f7c5c9205381cb72e42b66e97d8ed3abf63/packet-ber.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -53,7 +53,13 @@
         len = tvb_reported_length_remaining(tvb, offset);
         end_offset = offset+len;
     }
-
+    if (len == 0) {
+        proto_tree_add_expert_format(
+            parent_tree, actx->pinfo, &ei_ber_constr_bitstr, tvb, offset, len,
+            ""dissect_ber_constrained_bitstring(): frame:%u offset:%d Was passed an illegal length of 0"",
+            actx->pinfo->fd->num, offset);
+        return offset;
+    }
     actx->created_item = NULL;
 
     if (pc) {","{'deleted_lines': [''], 'added_lines': ['    if (len == 0) {', '        proto_tree_add_expert_format(', '            parent_tree, actx->pinfo, &ei_ber_constr_bitstr, tvb, offset, len,', '            ""dissect_ber_constrained_bitstring(): frame:%u offset:%d Was passed an illegal length of 0"",', '            actx->pinfo->fd->num, offset);', '        return offset;', '    }']}",True,"The dissect_ber_constrained_bitstring function in epan/dissectors/packet-ber.c in the ASN.1 BER dissector in Wireshark 2.0.x before 2.0.2 does not verify that a certain length is nonzero, which allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted packet.",5.9,MEDIUM,1,test,2016-01-14T14:56:06Z,1
CVE-2016-2529,['CWE-119'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"[iseries] fix iseries_check_file_type()

check that we have a line that contains OBJECT PROTOCOL ETHERNET
(at the moment, we fail if there's a line containing OBJECT PROTOCOL but
 not ETHERNET and succeed otherwise
 -> a file with some random lines will be identified as iseries)

initialize our line buffer with 0s to make sure we don't access uninitialized
data while parsing

don't set wth->priv unless the file is really an iseries file

free the iseries struct if the file is not our type

Bug: 11985
Change-Id: I0ac7003c047f54ca025d02e59b56d1ff4e2a6be7
Reviewed-on: https://code.wireshark.org/review/13360
Petri-Dish: Martin Kaiser <wireshark@kaiser.cx>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Alexis La Goutte <alexis.lagoutte@gmail.com>",96d585a5e9baef21e1eea8505d78305b034dc80e,https://github.com/wireshark/wireshark/commit/96d585a5e9baef21e1eea8505d78305b034dc80e,wiretap/iseries.c,iseries_check_file_type,"static gboolean
iseries_check_file_type (wtap * wth, int *err, gchar **err_info, int format)
{
guint      line;
int        num_items_scanned;
char       buf[ISERIES_LINE_LENGTH], protocol[9];
iseries_t *iseries;
iseries                = (iseries_t *) g_malloc (sizeof (iseries_t));
wth->priv              = (void *) iseries;
iseries->have_date     = FALSE;
iseries->format        = format;
for (line = 0; line < ISERIES_HDR_LINES_TO_CHECK; line++)
{
if (file_gets (buf, ISERIES_LINE_LENGTH, wth->fh) == NULL)
{
*err = file_error (wth->fh, err_info);
if (*err == WTAP_ERR_SHORT_READ)
*err = 0;
return FALSE;
}
if (iseries->format == ISERIES_FORMAT_UNICODE)
{
iseries_UNICODE_to_ASCII ((guint8 *)buf, ISERIES_LINE_LENGTH);
}
ascii_strup_inplace (buf);
num_items_scanned = sscanf (buf,
""%*[ \n\t]OBJECT PROTOCOL%*[ .:\n\t]%8s"",
protocol);
if (num_items_scanned == 1)
{
if (memcmp (protocol, ""ETHERNET"", 8) != 0)
return FALSE;
}
num_items_scanned = sscanf (buf,
""%*[ \n\t]START DATE/TIME%*[ .:\n\t]%2d/%2d/%2d"",
&iseries->month, &iseries->day,
&iseries->year);
if (num_items_scanned == 3)
{
iseries->have_date = TRUE;
}
}
*err = 0;
return TRUE;
}","static gboolean
iseries_check_file_type (wtap * VAR_0, int *VAR_1, gchar **VAR_2, int VAR_3)
{
guint      VAR_4;
int        VAR_5;
char       VAR_6[VAR_7], VAR_8[9];
iseries_t *VAR_9;
VAR_9                = (iseries_t *) g_malloc (sizeof (iseries_t));
VAR_0->priv              = (void *) VAR_9;
VAR_9->have_date     = FALSE;
VAR_9->format        = VAR_3;
for (VAR_4 = 0; VAR_4 < VAR_10; VAR_4++)
{
if (file_gets (VAR_6, VAR_7, VAR_0->fh) == NULL)
{
*VAR_1 = file_error (VAR_0->fh, VAR_2);
if (*VAR_1 == VAR_11)
*VAR_1 = 0;
return FALSE;
}
if (VAR_9->format == VAR_12)
{
iseries_UNICODE_to_ASCII ((guint8 *)VAR_6, VAR_7);
}
ascii_strup_inplace (VAR_6);
VAR_5 = sscanf (VAR_6,
""%*[ \n\t]OBJECT PROTOCOL%*[ .:\n\t]%8s"",
VAR_8);
if (VAR_5 == 1)
{
if (memcmp (VAR_8, ""ETHERNET"", 8) != 0)
return FALSE;
}
VAR_5 = sscanf (VAR_6,
""%*[ \n\t]START DATE/TIME%*[ .:\n\t]%2d/%2d/%2d"",
&VAR_9->month, &VAR_9->day,
&VAR_9->year);
if (VAR_5 == 3)
{
VAR_9->have_date = TRUE;
}
}
*VAR_1 = 0;
return TRUE;
}",wireshark/96d585a5e9baef21e1eea8505d78305b034dc80e/iseries.c/vul/before/0.json,"static gboolean
iseries_check_file_type (wtap * wth, int *err, gchar **err_info, int format)
{
  gboolean   is_iseries = FALSE;
  guint      line;
  int        num_items_scanned;
  char       buf[ISERIES_LINE_LENGTH], protocol[9];
  iseries_t *iseries;

  /* Save trace format for passing between packets */
  iseries                = (iseries_t *) g_malloc (sizeof (iseries_t));
  iseries->have_date     = FALSE;
  iseries->format        = format;

  for (line = 0; line < ISERIES_HDR_LINES_TO_CHECK; line++)
    {
      memset(buf, 0x0, sizeof(buf));
      if (file_gets (buf, ISERIES_LINE_LENGTH, wth->fh) == NULL)
        {
          /* EOF or error. */
          *err = file_error (wth->fh, err_info);
          if (*err == WTAP_ERR_SHORT_READ)
            *err = 0;
          break;
        }

        /*
         * Check that we are dealing with an ETHERNET trace
         */
        if (iseries->format == ISERIES_FORMAT_UNICODE)
          {
            iseries_UNICODE_to_ASCII ((guint8 *)buf, ISERIES_LINE_LENGTH);
          }
        ascii_strup_inplace (buf);
        num_items_scanned = sscanf (buf,
                                   ""%*[ \n\t]OBJECT PROTOCOL%*[ .:\n\t]%8s"",
                                   protocol);
        if (num_items_scanned == 1)
          {
            if (memcmp (protocol, ""ETHERNET"", 8) == 0)
              {
                *err = 0;
                is_iseries = TRUE;
              }
          }

        /*
         * The header is the only place where the date part of the timestamp is held, so
         * extract it here and store for all packets to access
         */
        num_items_scanned = sscanf (buf,
                                    ""%*[ \n\t]START DATE/TIME%*[ .:\n\t]%2d/%2d/%2d"",
                                    &iseries->month, &iseries->day,
                                    &iseries->year);
        if (num_items_scanned == 3)
          {
            iseries->have_date = TRUE;
          }
    }

  if (is_iseries)
    wth->priv = (void *) iseries;
  else
    g_free(iseries);

  return is_iseries;
}","static gboolean
iseries_check_file_type (wtap * VAR_0, int *VAR_1, gchar **VAR_2, int VAR_3)
{
  gboolean   VAR_4 = FALSE;
  guint      VAR_5;
  int        VAR_6;
  char       VAR_7[VAR_8], VAR_9[9];
  iseries_t *VAR_10;

  /* COMMENT_0 */
  VAR_10                = (iseries_t *) g_malloc (sizeof (iseries_t));
  VAR_10->have_date     = FALSE;
  VAR_10->format        = VAR_3;

  for (VAR_5 = 0; VAR_5 < VAR_11; VAR_5++)
    {
      memset(VAR_7, 0x0, sizeof(VAR_7));
      if (file_gets (VAR_7, VAR_8, VAR_0->fh) == NULL)
        {
          /* COMMENT_1 */
          *VAR_1 = file_error (VAR_0->fh, VAR_2);
          if (*VAR_1 == VAR_12)
            *VAR_1 = 0;
          break;
        }

        /* COMMENT_2 */
                                                           
           
        if (VAR_10->format == VAR_13)
          {
            iseries_UNICODE_to_ASCII ((guint8 *)VAR_7, VAR_8);
          }
        ascii_strup_inplace (VAR_7);
        VAR_6 = sscanf (VAR_7,
                                   ""%*[ \n\t]OBJECT PROTOCOL%*[ .:\n\t]%8s"",
                                   VAR_9);
        if (VAR_6 == 1)
          {
            if (memcmp (VAR_9, ""ETHERNET"", 8) == 0)
              {
                *VAR_1 = 0;
                VAR_4 = TRUE;
              }
          }

        /* COMMENT_5 */
                                                                                        
                                                              
           
        VAR_6 = sscanf (VAR_7,
                                    ""%*[ \n\t]START DATE/TIME%*[ .:\n\t]%2d/%2d/%2d"",
                                    &VAR_10->month, &VAR_10->day,
                                    &VAR_10->year);
        if (VAR_6 == 3)
          {
            VAR_10->have_date = TRUE;
          }
    }

  if (VAR_4)
    VAR_0->priv = (void *) VAR_10;
  else
    g_free(VAR_10);

  return VAR_4;
}",wireshark/96d585a5e9baef21e1eea8505d78305b034dc80e/iseries.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,7 @@
 static gboolean
 iseries_check_file_type (wtap * wth, int *err, gchar **err_info, int format)
 {
+  gboolean   is_iseries = FALSE;
   guint      line;
   int        num_items_scanned;
   char       buf[ISERIES_LINE_LENGTH], protocol[9];
@@ -8,19 +9,19 @@
 
   /* Save trace format for passing between packets */
   iseries                = (iseries_t *) g_malloc (sizeof (iseries_t));
-  wth->priv              = (void *) iseries;
   iseries->have_date     = FALSE;
   iseries->format        = format;
 
   for (line = 0; line < ISERIES_HDR_LINES_TO_CHECK; line++)
     {
+      memset(buf, 0x0, sizeof(buf));
       if (file_gets (buf, ISERIES_LINE_LENGTH, wth->fh) == NULL)
         {
           /* EOF or error. */
           *err = file_error (wth->fh, err_info);
           if (*err == WTAP_ERR_SHORT_READ)
             *err = 0;
-          return FALSE;
+          break;
         }
 
         /*
@@ -36,8 +37,11 @@
                                    protocol);
         if (num_items_scanned == 1)
           {
-            if (memcmp (protocol, ""ETHERNET"", 8) != 0)
-              return FALSE;
+            if (memcmp (protocol, ""ETHERNET"", 8) == 0)
+              {
+                *err = 0;
+                is_iseries = TRUE;
+              }
           }
 
         /*
@@ -53,6 +57,11 @@
             iseries->have_date = TRUE;
           }
     }
-  *err = 0;
-  return TRUE;
+
+  if (is_iseries)
+    wth->priv = (void *) iseries;
+  else
+    g_free(iseries);
+
+  return is_iseries;
 }","{'deleted_lines': ['  wth->priv              = (void *) iseries;', '          return FALSE;', '            if (memcmp (protocol, ""ETHERNET"", 8) != 0)', '              return FALSE;', '  *err = 0;', '  return TRUE;'], 'added_lines': ['  gboolean   is_iseries = FALSE;', '      memset(buf, 0x0, sizeof(buf));', '          break;', '            if (memcmp (protocol, ""ETHERNET"", 8) == 0)', '              {', '                *err = 0;', '                is_iseries = TRUE;', '              }', '', '  if (is_iseries)', '    wth->priv = (void *) iseries;', '  else', '    g_free(iseries);', '', '  return is_iseries;']}",True,"The iseries_check_file_type function in wiretap/iseries.c in the iSeries file parser in Wireshark 2.0.x before 2.0.2 does not consider that a line may lack the ""OBJECT PROTOCOL"" substring, which allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted file.",5.5,MEDIUM,1,test,2016-01-17T16:03:50Z,1
CVE-2016-2549,['CWE-20'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,torvalds/linux,"ALSA: hrtimer: Fix stall by hrtimer_cancel()

hrtimer_cancel() waits for the completion from the callback, thus it
must not be called inside the callback itself.  This was already a
problem in the past with ALSA hrtimer driver, and the early commit
[fcfdebe70759: ALSA: hrtimer - Fix lock-up] tried to address it.

However, the previous fix is still insufficient: it may still cause a
lockup when the ALSA timer instance reprograms itself in its callback.
Then it invokes the start function even in snd_timer_interrupt() that
is called in hrtimer callback itself, results in a CPU stall.  This is
no hypothetical problem but actually triggered by syzkaller fuzzer.

This patch tries to fix the issue again.  Now we call
hrtimer_try_to_cancel() at both start and stop functions so that it
won't fall into a deadlock, yet giving some chance to cancel the queue
if the functions have been called outside the callback.  The proper
hrtimer_cancel() is called in anyway at closing, so this should be
enough.

Reported-and-tested-by: Dmitry Vyukov <dvyukov@google.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>",2ba1fe7a06d3624f9a7586d672b55f08f7c670f3,https://github.com/torvalds/linux/commit/2ba1fe7a06d3624f9a7586d672b55f08f7c670f3,sound/core/hrtimer.c,snd_hrtimer_stop,"static int snd_hrtimer_stop(struct snd_timer *t)
{
struct snd_hrtimer *stime = t->private_data;
atomic_set(&stime->running, 0);
return 0;
}","static int snd_hrtimer_stop(struct snd_timer *VAR_0)
{
struct snd_hrtimer *VAR_1 = VAR_0->private_data;
atomic_set(&VAR_1->running, 0);
return 0;
}",torvalds/linux/2ba1fe7a06d3624f9a7586d672b55f08f7c670f3/hrtimer.c/vul/before/1.json,"static int snd_hrtimer_stop(struct snd_timer *t)
{
	struct snd_hrtimer *stime = t->private_data;
	atomic_set(&stime->running, 0);
	hrtimer_try_to_cancel(&stime->hrt);
	return 0;
}","static int snd_hrtimer_stop(struct snd_timer *VAR_0)
{
	struct snd_hrtimer *VAR_1 = VAR_0->private_data;
	atomic_set(&VAR_1->running, 0);
	hrtimer_try_to_cancel(&VAR_1->hrt);
	return 0;
}",torvalds/linux/2ba1fe7a06d3624f9a7586d672b55f08f7c670f3/hrtimer.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,5 +2,6 @@
 {
 	struct snd_hrtimer *stime = t->private_data;
 	atomic_set(&stime->running, 0);
+	hrtimer_try_to_cancel(&stime->hrt);
 	return 0;
 }","{'deleted_lines': [], 'added_lines': ['\thrtimer_try_to_cancel(&stime->hrt);']}",True,"sound/core/hrtimer.c in the Linux kernel before 4.4.1 does not prevent recursive callback access, which allows local users to cause a denial of service (deadlock) via a crafted ioctl call.",6.2,MEDIUM,1,test,2016-01-18T12:52:47Z,1
CVE-2016-2549,['CWE-20'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,torvalds/linux,"ALSA: hrtimer: Fix stall by hrtimer_cancel()

hrtimer_cancel() waits for the completion from the callback, thus it
must not be called inside the callback itself.  This was already a
problem in the past with ALSA hrtimer driver, and the early commit
[fcfdebe70759: ALSA: hrtimer - Fix lock-up] tried to address it.

However, the previous fix is still insufficient: it may still cause a
lockup when the ALSA timer instance reprograms itself in its callback.
Then it invokes the start function even in snd_timer_interrupt() that
is called in hrtimer callback itself, results in a CPU stall.  This is
no hypothetical problem but actually triggered by syzkaller fuzzer.

This patch tries to fix the issue again.  Now we call
hrtimer_try_to_cancel() at both start and stop functions so that it
won't fall into a deadlock, yet giving some chance to cancel the queue
if the functions have been called outside the callback.  The proper
hrtimer_cancel() is called in anyway at closing, so this should be
enough.

Reported-and-tested-by: Dmitry Vyukov <dvyukov@google.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>",2ba1fe7a06d3624f9a7586d672b55f08f7c670f3,https://github.com/torvalds/linux/commit/2ba1fe7a06d3624f9a7586d672b55f08f7c670f3,sound/core/hrtimer.c,snd_hrtimer_start,"static int snd_hrtimer_start(struct snd_timer *t)
{
struct snd_hrtimer *stime = t->private_data;
atomic_set(&stime->running, 0);
hrtimer_cancel(&stime->hrt);
hrtimer_start(&stime->hrt, ns_to_ktime(t->sticks * resolution),
HRTIMER_MODE_REL);
atomic_set(&stime->running, 1);
return 0;
}","static int snd_hrtimer_start(struct snd_timer *VAR_0)
{
struct snd_hrtimer *VAR_1 = VAR_0->private_data;
atomic_set(&VAR_1->running, 0);
hrtimer_cancel(&VAR_1->hrt);
hrtimer_start(&VAR_1->hrt, ns_to_ktime(VAR_0->sticks * VAR_2),
VAR_3);
atomic_set(&VAR_1->running, 1);
return 0;
}",torvalds/linux/2ba1fe7a06d3624f9a7586d672b55f08f7c670f3/hrtimer.c/vul/before/0.json,"static int snd_hrtimer_start(struct snd_timer *t)
{
	struct snd_hrtimer *stime = t->private_data;

	atomic_set(&stime->running, 0);
	hrtimer_try_to_cancel(&stime->hrt);
	hrtimer_start(&stime->hrt, ns_to_ktime(t->sticks * resolution),
		      HRTIMER_MODE_REL);
	atomic_set(&stime->running, 1);
	return 0;
}","static int snd_hrtimer_start(struct snd_timer *VAR_0)
{
	struct snd_hrtimer *VAR_1 = VAR_0->private_data;

	atomic_set(&VAR_1->running, 0);
	hrtimer_try_to_cancel(&VAR_1->hrt);
	hrtimer_start(&VAR_1->hrt, ns_to_ktime(VAR_0->sticks * VAR_2),
		      VAR_3);
	atomic_set(&VAR_1->running, 1);
	return 0;
}",torvalds/linux/2ba1fe7a06d3624f9a7586d672b55f08f7c670f3/hrtimer.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 	struct snd_hrtimer *stime = t->private_data;
 
 	atomic_set(&stime->running, 0);
-	hrtimer_cancel(&stime->hrt);
+	hrtimer_try_to_cancel(&stime->hrt);
 	hrtimer_start(&stime->hrt, ns_to_ktime(t->sticks * resolution),
 		      HRTIMER_MODE_REL);
 	atomic_set(&stime->running, 1);","{'deleted_lines': ['\thrtimer_cancel(&stime->hrt);'], 'added_lines': ['\thrtimer_try_to_cancel(&stime->hrt);']}",True,"sound/core/hrtimer.c in the Linux kernel before 4.4.1 does not prevent recursive callback access, which allows local users to cause a denial of service (deadlock) via a crafted ioctl call.",6.2,MEDIUM,1,test,2016-01-18T12:52:47Z,1
CVE-2016-2847,['CWE-399'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"pipe: limit the per-user amount of pages allocated in pipes

On no-so-small systems, it is possible for a single process to cause an
OOM condition by filling large pipes with data that are never read. A
typical process filling 4000 pipes with 1 MB of data will use 4 GB of
memory. On small systems it may be tricky to set the pipe max size to
prevent this from happening.

This patch makes it possible to enforce a per-user soft limit above
which new pipes will be limited to a single page, effectively limiting
them to 4 kB each, as well as a hard limit above which no new pipes may
be created for this user. This has the effect of protecting the system
against memory abuse without hurting other users, and still allowing
pipes to work correctly though with less data at once.

The limit are controlled by two new sysctls : pipe-user-pages-soft, and
pipe-user-pages-hard. Both may be disabled by setting them to zero. The
default soft limit allows the default number of FDs per process (1024)
to create pipes of the default size (64kB), thus reaching a limit of 64MB
before starting to create only smaller pipes. With 256 processes limited
to 1024 FDs each, this results in 1024*64kB + (256*1024 - 1024) * 4kB =
1084 MB of memory allocated for a user. The hard limit is disabled by
default to avoid breaking existing applications that make intensive use
of pipes (eg: for splicing).

Reported-by: socketpair@gmail.com
Reported-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Mitigates: CVE-2013-4312 (Linux 2.0+)
Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Willy Tarreau <w@1wt.eu>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",759c01142a5d0f364a462346168a56de28a80f52,https://github.com/torvalds/linux/commit/759c01142a5d0f364a462346168a56de28a80f52,fs/pipe.c,alloc_pipe_info,"struct pipe_inode_info *alloc_pipe_info(void)
{
struct pipe_inode_info *pipe;
pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);
if (pipe) {
pipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);
if (pipe->bufs) {
init_waitqueue_head(&pipe->wait);
pipe->r_counter = pipe->w_counter = 1;
pipe->buffers = PIPE_DEF_BUFFERS;
mutex_init(&pipe->mutex);
return pipe;
}
kfree(pipe);
}
return NULL;
}","struct pipe_inode_info *alloc_pipe_info(void)
{
struct pipe_inode_info *VAR_0;
VAR_0 = kzalloc(sizeof(struct pipe_inode_info), VAR_1);
if (VAR_0) {
VAR_0->bufs = kzalloc(sizeof(struct pipe_buffer) * VAR_2, VAR_1);
if (VAR_0->bufs) {
init_waitqueue_head(&VAR_0->wait);
VAR_0->r_counter = VAR_0->w_counter = 1;
VAR_0->buffers = VAR_2;
mutex_init(&VAR_0->mutex);
return VAR_0;
}
kfree(VAR_0);
}
return NULL;
}",torvalds/linux/759c01142a5d0f364a462346168a56de28a80f52/pipe.c/vul/before/2.json,"struct pipe_inode_info *alloc_pipe_info(void)
{
	struct pipe_inode_info *pipe;

	pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);
	if (pipe) {
		unsigned long pipe_bufs = PIPE_DEF_BUFFERS;
		struct user_struct *user = get_current_user();

		if (!too_many_pipe_buffers_hard(user)) {
			if (too_many_pipe_buffers_soft(user))
				pipe_bufs = 1;
			pipe->bufs = kzalloc(sizeof(struct pipe_buffer) * pipe_bufs, GFP_KERNEL);
		}

		if (pipe->bufs) {
			init_waitqueue_head(&pipe->wait);
			pipe->r_counter = pipe->w_counter = 1;
			pipe->buffers = pipe_bufs;
			pipe->user = user;
			account_pipe_buffers(pipe, 0, pipe_bufs);
			mutex_init(&pipe->mutex);
			return pipe;
		}
		free_uid(user);
		kfree(pipe);
	}

	return NULL;
}","struct pipe_inode_info *alloc_pipe_info(void)
{
	struct pipe_inode_info *VAR_0;

	VAR_0 = kzalloc(sizeof(struct pipe_inode_info), VAR_1);
	if (VAR_0) {
		unsigned long VAR_2 = VAR_3;
		struct user_struct *VAR_4 = get_current_user();

		if (!too_many_pipe_buffers_hard(VAR_4)) {
			if (too_many_pipe_buffers_soft(VAR_4))
				VAR_2 = 1;
			VAR_0->bufs = kzalloc(sizeof(struct pipe_buffer) * VAR_2, VAR_1);
		}

		if (VAR_0->bufs) {
			init_waitqueue_head(&VAR_0->wait);
			VAR_0->r_counter = VAR_0->w_counter = 1;
			VAR_0->buffers = VAR_2;
			VAR_0->user = VAR_4;
			account_pipe_buffers(VAR_0, 0, VAR_2);
			mutex_init(&VAR_0->mutex);
			return VAR_0;
		}
		free_uid(VAR_4);
		kfree(VAR_0);
	}

	return NULL;
}",torvalds/linux/759c01142a5d0f364a462346168a56de28a80f52/pipe.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -4,14 +4,25 @@
 
 	pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);
 	if (pipe) {
-		pipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);
+		unsigned long pipe_bufs = PIPE_DEF_BUFFERS;
+		struct user_struct *user = get_current_user();
+
+		if (!too_many_pipe_buffers_hard(user)) {
+			if (too_many_pipe_buffers_soft(user))
+				pipe_bufs = 1;
+			pipe->bufs = kzalloc(sizeof(struct pipe_buffer) * pipe_bufs, GFP_KERNEL);
+		}
+
 		if (pipe->bufs) {
 			init_waitqueue_head(&pipe->wait);
 			pipe->r_counter = pipe->w_counter = 1;
-			pipe->buffers = PIPE_DEF_BUFFERS;
+			pipe->buffers = pipe_bufs;
+			pipe->user = user;
+			account_pipe_buffers(pipe, 0, pipe_bufs);
 			mutex_init(&pipe->mutex);
 			return pipe;
 		}
+		free_uid(user);
 		kfree(pipe);
 	}
 ","{'deleted_lines': ['\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);', '\t\t\tpipe->buffers = PIPE_DEF_BUFFERS;'], 'added_lines': ['\t\tunsigned long pipe_bufs = PIPE_DEF_BUFFERS;', '\t\tstruct user_struct *user = get_current_user();', '', '\t\tif (!too_many_pipe_buffers_hard(user)) {', '\t\t\tif (too_many_pipe_buffers_soft(user))', '\t\t\t\tpipe_bufs = 1;', '\t\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * pipe_bufs, GFP_KERNEL);', '\t\t}', '', '\t\t\tpipe->buffers = pipe_bufs;', '\t\t\tpipe->user = user;', '\t\t\taccount_pipe_buffers(pipe, 0, pipe_bufs);', '\t\tfree_uid(user);']}",True,"fs/pipe.c in the Linux kernel before 4.5 does not limit the amount of unread data in pipes, which allows local users to cause a denial of service (memory consumption) by creating many pipes with non-default sizes.",6.2,MEDIUM,1,test,2016-01-18T15:36:09Z,1
CVE-2016-2847,['CWE-399'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"pipe: limit the per-user amount of pages allocated in pipes

On no-so-small systems, it is possible for a single process to cause an
OOM condition by filling large pipes with data that are never read. A
typical process filling 4000 pipes with 1 MB of data will use 4 GB of
memory. On small systems it may be tricky to set the pipe max size to
prevent this from happening.

This patch makes it possible to enforce a per-user soft limit above
which new pipes will be limited to a single page, effectively limiting
them to 4 kB each, as well as a hard limit above which no new pipes may
be created for this user. This has the effect of protecting the system
against memory abuse without hurting other users, and still allowing
pipes to work correctly though with less data at once.

The limit are controlled by two new sysctls : pipe-user-pages-soft, and
pipe-user-pages-hard. Both may be disabled by setting them to zero. The
default soft limit allows the default number of FDs per process (1024)
to create pipes of the default size (64kB), thus reaching a limit of 64MB
before starting to create only smaller pipes. With 256 processes limited
to 1024 FDs each, this results in 1024*64kB + (256*1024 - 1024) * 4kB =
1084 MB of memory allocated for a user. The hard limit is disabled by
default to avoid breaking existing applications that make intensive use
of pipes (eg: for splicing).

Reported-by: socketpair@gmail.com
Reported-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Mitigates: CVE-2013-4312 (Linux 2.0+)
Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Willy Tarreau <w@1wt.eu>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",759c01142a5d0f364a462346168a56de28a80f52,https://github.com/torvalds/linux/commit/759c01142a5d0f364a462346168a56de28a80f52,fs/pipe.c,pipe_set_size,"static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)
{
struct pipe_buffer *bufs;
if (nr_pages < pipe->nrbufs)
return -EBUSY;
bufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);
if (unlikely(!bufs))
return -ENOMEM;
if (pipe->nrbufs) {
unsigned int tail;
unsigned int head;
tail = pipe->curbuf + pipe->nrbufs;
if (tail < pipe->buffers)
tail = 0;
else
tail &= (pipe->buffers - 1);
head = pipe->nrbufs - tail;
if (head)
memcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));
if (tail)
memcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));
}
pipe->curbuf = 0;
kfree(pipe->bufs);
pipe->bufs = bufs;
pipe->buffers = nr_pages;
return nr_pages * PAGE_SIZE;
}","static long pipe_set_size(struct pipe_inode_info *VAR_0, unsigned long VAR_1)
{
struct pipe_buffer *VAR_2;
if (VAR_1 < VAR_0->nrbufs)
return -VAR_3;
VAR_2 = kcalloc(VAR_1, sizeof(*VAR_2), VAR_4 | VAR_5);
if (unlikely(!VAR_2))
return -VAR_6;
if (VAR_0->nrbufs) {
unsigned int VAR_7;
unsigned int VAR_8;
VAR_7 = VAR_0->curbuf + VAR_0->nrbufs;
if (VAR_7 < VAR_0->buffers)
VAR_7 = 0;
else
VAR_7 &= (VAR_0->buffers - 1);
VAR_8 = VAR_0->nrbufs - VAR_7;
if (VAR_8)
memcpy(VAR_2, VAR_0->bufs + VAR_0->curbuf, VAR_8 * sizeof(struct pipe_buffer));
if (VAR_7)
memcpy(VAR_2 + VAR_8, VAR_0->bufs, VAR_7 * sizeof(struct pipe_buffer));
}
VAR_0->curbuf = 0;
kfree(VAR_0->bufs);
VAR_0->bufs = VAR_2;
VAR_0->buffers = VAR_1;
return VAR_1 * VAR_9;
}",torvalds/linux/759c01142a5d0f364a462346168a56de28a80f52/pipe.c/vul/before/0.json,"static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)
{
	struct pipe_buffer *bufs;

	/*
	 * We can shrink the pipe, if arg >= pipe->nrbufs. Since we don't
	 * expect a lot of shrink+grow operations, just free and allocate
	 * again like we would do for growing. If the pipe currently
	 * contains more buffers than arg, then return busy.
	 */
	if (nr_pages < pipe->nrbufs)
		return -EBUSY;

	bufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);
	if (unlikely(!bufs))
		return -ENOMEM;

	/*
	 * The pipe array wraps around, so just start the new one at zero
	 * and adjust the indexes.
	 */
	if (pipe->nrbufs) {
		unsigned int tail;
		unsigned int head;

		tail = pipe->curbuf + pipe->nrbufs;
		if (tail < pipe->buffers)
			tail = 0;
		else
			tail &= (pipe->buffers - 1);

		head = pipe->nrbufs - tail;
		if (head)
			memcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));
		if (tail)
			memcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));
	}

	account_pipe_buffers(pipe, pipe->buffers, nr_pages);
	pipe->curbuf = 0;
	kfree(pipe->bufs);
	pipe->bufs = bufs;
	pipe->buffers = nr_pages;
	return nr_pages * PAGE_SIZE;
}","static long pipe_set_size(struct pipe_inode_info *VAR_0, unsigned long VAR_1)
{
	struct pipe_buffer *VAR_2;

	/* COMMENT_0 */
                                                                  
                                                                  
                                                             
                                                     
    
	if (VAR_1 < VAR_0->nrbufs)
		return -VAR_3;

	VAR_2 = kcalloc(VAR_1, sizeof(*VAR_2), VAR_4 | VAR_5);
	if (unlikely(!VAR_2))
		return -VAR_6;

	/* COMMENT_6 */
                                                                  
                           
    
	if (VAR_0->nrbufs) {
		unsigned int VAR_7;
		unsigned int VAR_8;

		VAR_7 = VAR_0->curbuf + VAR_0->nrbufs;
		if (VAR_7 < VAR_0->buffers)
			VAR_7 = 0;
		else
			VAR_7 &= (VAR_0->buffers - 1);

		VAR_8 = VAR_0->nrbufs - VAR_7;
		if (VAR_8)
			memcpy(VAR_2, VAR_0->bufs + VAR_0->curbuf, VAR_8 * sizeof(struct pipe_buffer));
		if (VAR_7)
			memcpy(VAR_2 + VAR_8, VAR_0->bufs, VAR_7 * sizeof(struct pipe_buffer));
	}

	account_pipe_buffers(VAR_0, VAR_0->buffers, VAR_1);
	VAR_0->curbuf = 0;
	kfree(VAR_0->bufs);
	VAR_0->bufs = VAR_2;
	VAR_0->buffers = VAR_1;
	return VAR_1 * VAR_9;
}",torvalds/linux/759c01142a5d0f364a462346168a56de28a80f52/pipe.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -36,6 +36,7 @@
 			memcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));
 	}
 
+	account_pipe_buffers(pipe, pipe->buffers, nr_pages);
 	pipe->curbuf = 0;
 	kfree(pipe->bufs);
 	pipe->bufs = bufs;","{'deleted_lines': [], 'added_lines': ['\taccount_pipe_buffers(pipe, pipe->buffers, nr_pages);']}",True,"fs/pipe.c in the Linux kernel before 4.5 does not limit the amount of unread data in pipes, which allows local users to cause a denial of service (memory consumption) by creating many pipes with non-default sizes.",6.2,MEDIUM,1,test,2016-01-18T15:36:09Z,1
CVE-2016-2847,['CWE-399'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"pipe: limit the per-user amount of pages allocated in pipes

On no-so-small systems, it is possible for a single process to cause an
OOM condition by filling large pipes with data that are never read. A
typical process filling 4000 pipes with 1 MB of data will use 4 GB of
memory. On small systems it may be tricky to set the pipe max size to
prevent this from happening.

This patch makes it possible to enforce a per-user soft limit above
which new pipes will be limited to a single page, effectively limiting
them to 4 kB each, as well as a hard limit above which no new pipes may
be created for this user. This has the effect of protecting the system
against memory abuse without hurting other users, and still allowing
pipes to work correctly though with less data at once.

The limit are controlled by two new sysctls : pipe-user-pages-soft, and
pipe-user-pages-hard. Both may be disabled by setting them to zero. The
default soft limit allows the default number of FDs per process (1024)
to create pipes of the default size (64kB), thus reaching a limit of 64MB
before starting to create only smaller pipes. With 256 processes limited
to 1024 FDs each, this results in 1024*64kB + (256*1024 - 1024) * 4kB =
1084 MB of memory allocated for a user. The hard limit is disabled by
default to avoid breaking existing applications that make intensive use
of pipes (eg: for splicing).

Reported-by: socketpair@gmail.com
Reported-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Mitigates: CVE-2013-4312 (Linux 2.0+)
Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Willy Tarreau <w@1wt.eu>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",759c01142a5d0f364a462346168a56de28a80f52,https://github.com/torvalds/linux/commit/759c01142a5d0f364a462346168a56de28a80f52,fs/pipe.c,pipe_fcntl,"long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)
{
struct pipe_inode_info *pipe;
long ret;
pipe = get_pipe_info(file);
if (!pipe)
return -EBADF;
__pipe_lock(pipe);
switch (cmd) {
case F_SETPIPE_SZ: {
unsigned int size, nr_pages;
size = round_pipe_size(arg);
nr_pages = size >> PAGE_SHIFT;
ret = -EINVAL;
if (!nr_pages)
goto out;
if (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {
ret = -EPERM;
goto out;
}
ret = pipe_set_size(pipe, nr_pages);
break;
}
case F_GETPIPE_SZ:
ret = pipe->buffers * PAGE_SIZE;
break;
default:
ret = -EINVAL;
break;
}
out:
__pipe_unlock(pipe);
return ret;
}","long pipe_fcntl(struct file *file, unsigned int VAR_0, unsigned long VAR_1)
{
struct pipe_inode_info *VAR_2;
long VAR_3;
VAR_2 = get_pipe_info(file);
if (!VAR_2)
return -VAR_4;
__pipe_lock(VAR_2);
switch (VAR_0) {
case VAR_5: {
unsigned int VAR_6, VAR_7;
VAR_6 = round_pipe_size(VAR_1);
VAR_7 = VAR_6 >> VAR_8;
VAR_3 = -VAR_9;
if (!VAR_7)
goto out;
if (!capable(VAR_10) && VAR_6 > VAR_11) {
VAR_3 = -VAR_12;
goto out;
}
VAR_3 = pipe_set_size(VAR_2, VAR_7);
break;
}
case VAR_13:
VAR_3 = VAR_2->buffers * VAR_14;
break;
default:
VAR_3 = -VAR_9;
break;
}
out:
__pipe_unlock(VAR_2);
return VAR_3;
}",torvalds/linux/759c01142a5d0f364a462346168a56de28a80f52/pipe.c/vul/before/1.json,"long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)
{
	struct pipe_inode_info *pipe;
	long ret;

	pipe = get_pipe_info(file);
	if (!pipe)
		return -EBADF;

	__pipe_lock(pipe);

	switch (cmd) {
	case F_SETPIPE_SZ: {
		unsigned int size, nr_pages;

		size = round_pipe_size(arg);
		nr_pages = size >> PAGE_SHIFT;

		ret = -EINVAL;
		if (!nr_pages)
			goto out;

		if (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {
			ret = -EPERM;
			goto out;
		} else if ((too_many_pipe_buffers_hard(pipe->user) ||
			    too_many_pipe_buffers_soft(pipe->user)) &&
		           !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {
			ret = -EPERM;
			goto out;
		}
		ret = pipe_set_size(pipe, nr_pages);
		break;
		}
	case F_GETPIPE_SZ:
		ret = pipe->buffers * PAGE_SIZE;
		break;
	default:
		ret = -EINVAL;
		break;
	}

out:
	__pipe_unlock(pipe);
	return ret;
}","long pipe_fcntl(struct file *file, unsigned int VAR_0, unsigned long VAR_1)
{
	struct pipe_inode_info *VAR_2;
	long VAR_3;

	VAR_2 = get_pipe_info(file);
	if (!VAR_2)
		return -VAR_4;

	__pipe_lock(VAR_2);

	switch (VAR_0) {
	case VAR_5: {
		unsigned int VAR_6, VAR_7;

		VAR_6 = round_pipe_size(VAR_1);
		VAR_7 = VAR_6 >> VAR_8;

		VAR_3 = -VAR_9;
		if (!VAR_7)
			goto out;

		if (!capable(VAR_10) && VAR_6 > VAR_11) {
			VAR_3 = -VAR_12;
			goto out;
		} else if ((too_many_pipe_buffers_hard(VAR_2->user) ||
			    too_many_pipe_buffers_soft(VAR_2->user)) &&
		           !capable(VAR_10) && !capable(VAR_13)) {
			VAR_3 = -VAR_12;
			goto out;
		}
		VAR_3 = pipe_set_size(VAR_2, VAR_7);
		break;
		}
	case VAR_14:
		VAR_3 = VAR_2->buffers * VAR_15;
		break;
	default:
		VAR_3 = -VAR_9;
		break;
	}

out:
	__pipe_unlock(VAR_2);
	return VAR_3;
}",torvalds/linux/759c01142a5d0f364a462346168a56de28a80f52/pipe.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -23,6 +23,11 @@
 		if (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {
 			ret = -EPERM;
 			goto out;
+		} else if ((too_many_pipe_buffers_hard(pipe->user) ||
+			    too_many_pipe_buffers_soft(pipe->user)) &&
+		           !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {
+			ret = -EPERM;
+			goto out;
 		}
 		ret = pipe_set_size(pipe, nr_pages);
 		break;","{'deleted_lines': [], 'added_lines': ['\t\t} else if ((too_many_pipe_buffers_hard(pipe->user) ||', '\t\t\t    too_many_pipe_buffers_soft(pipe->user)) &&', '\t\t           !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {', '\t\t\tret = -EPERM;', '\t\t\tgoto out;']}",True,"fs/pipe.c in the Linux kernel before 4.5 does not limit the amount of unread data in pipes, which allows local users to cause a denial of service (memory consumption) by creating many pipes with non-default sizes.",6.2,MEDIUM,1,test,2016-01-18T15:36:09Z,1
CVE-2016-2847,['CWE-399'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"pipe: limit the per-user amount of pages allocated in pipes

On no-so-small systems, it is possible for a single process to cause an
OOM condition by filling large pipes with data that are never read. A
typical process filling 4000 pipes with 1 MB of data will use 4 GB of
memory. On small systems it may be tricky to set the pipe max size to
prevent this from happening.

This patch makes it possible to enforce a per-user soft limit above
which new pipes will be limited to a single page, effectively limiting
them to 4 kB each, as well as a hard limit above which no new pipes may
be created for this user. This has the effect of protecting the system
against memory abuse without hurting other users, and still allowing
pipes to work correctly though with less data at once.

The limit are controlled by two new sysctls : pipe-user-pages-soft, and
pipe-user-pages-hard. Both may be disabled by setting them to zero. The
default soft limit allows the default number of FDs per process (1024)
to create pipes of the default size (64kB), thus reaching a limit of 64MB
before starting to create only smaller pipes. With 256 processes limited
to 1024 FDs each, this results in 1024*64kB + (256*1024 - 1024) * 4kB =
1084 MB of memory allocated for a user. The hard limit is disabled by
default to avoid breaking existing applications that make intensive use
of pipes (eg: for splicing).

Reported-by: socketpair@gmail.com
Reported-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Mitigates: CVE-2013-4312 (Linux 2.0+)
Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Willy Tarreau <w@1wt.eu>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",759c01142a5d0f364a462346168a56de28a80f52,https://github.com/torvalds/linux/commit/759c01142a5d0f364a462346168a56de28a80f52,fs/pipe.c,free_pipe_info,"void free_pipe_info(struct pipe_inode_info *pipe)
{
int i;
for (i = 0; i < pipe->buffers; i++) {
struct pipe_buffer *buf = pipe->bufs + i;
if (buf->ops)
buf->ops->release(pipe, buf);
}
if (pipe->tmp_page)
__free_page(pipe->tmp_page);
kfree(pipe->bufs);
kfree(pipe);
}","void free_pipe_info(struct pipe_inode_info *VAR_0)
{
int VAR_1;
for (VAR_1 = 0; VAR_1 < VAR_0->buffers; VAR_1++) {
struct pipe_buffer *VAR_2 = VAR_0->bufs + VAR_1;
if (VAR_2->ops)
VAR_2->ops->release(VAR_0, VAR_2);
}
if (VAR_0->tmp_page)
__free_page(VAR_0->tmp_page);
kfree(VAR_0->bufs);
kfree(VAR_0);
}",torvalds/linux/759c01142a5d0f364a462346168a56de28a80f52/pipe.c/vul/before/3.json,"void free_pipe_info(struct pipe_inode_info *pipe)
{
	int i;

	account_pipe_buffers(pipe, pipe->buffers, 0);
	free_uid(pipe->user);
	for (i = 0; i < pipe->buffers; i++) {
		struct pipe_buffer *buf = pipe->bufs + i;
		if (buf->ops)
			buf->ops->release(pipe, buf);
	}
	if (pipe->tmp_page)
		__free_page(pipe->tmp_page);
	kfree(pipe->bufs);
	kfree(pipe);
}","void free_pipe_info(struct pipe_inode_info *VAR_0)
{
	int VAR_1;

	account_pipe_buffers(VAR_0, VAR_0->buffers, 0);
	free_uid(VAR_0->user);
	for (VAR_1 = 0; VAR_1 < VAR_0->buffers; VAR_1++) {
		struct pipe_buffer *VAR_2 = VAR_0->bufs + VAR_1;
		if (VAR_2->ops)
			VAR_2->ops->release(VAR_0, VAR_2);
	}
	if (VAR_0->tmp_page)
		__free_page(VAR_0->tmp_page);
	kfree(VAR_0->bufs);
	kfree(VAR_0);
}",torvalds/linux/759c01142a5d0f364a462346168a56de28a80f52/pipe.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -2,6 +2,8 @@
 {
 	int i;
 
+	account_pipe_buffers(pipe, pipe->buffers, 0);
+	free_uid(pipe->user);
 	for (i = 0; i < pipe->buffers; i++) {
 		struct pipe_buffer *buf = pipe->bufs + i;
 		if (buf->ops)","{'deleted_lines': [], 'added_lines': ['\taccount_pipe_buffers(pipe, pipe->buffers, 0);', '\tfree_uid(pipe->user);']}",True,"fs/pipe.c in the Linux kernel before 4.5 does not limit the amount of unread data in pipes, which allows local users to cause a denial of service (memory consumption) by creating many pipes with non-default sizes.",6.2,MEDIUM,1,test,2016-01-18T15:36:09Z,1
CVE-2016-2524,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"X509AF: make a local copy of algorithm_id in file scope for later use

Bug: 12002
Change-Id: Iff48863c1954f76d6fc34150d315d15295dc1f5c
Reviewed-on: https://code.wireshark.org/review/13406
Petri-Dish: Pascal Quantin <pascal.quantin@gmail.com>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Pascal Quantin <pascal.quantin@gmail.com>",5a8020a1b6bb73fcb8bb7eb7d53177bc8a9fc703,https://github.com/wireshark/wireshark/commit/5a8020a1b6bb73fcb8bb7eb7d53177bc8a9fc703,epan/dissectors/packet-x509af.c,dissect_x509af_SubjectPublicKeyInfo,"int
dissect_x509af_SubjectPublicKeyInfo(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 85 ""../../asn1/x509af/x509af.cnf""
int orig_offset = offset;
offset = dissect_ber_sequence(implicit_tag, actx, tree, tvb, offset,
SubjectPublicKeyInfo_sequence, hf_index, ett_x509af_SubjectPublicKeyInfo);
#line 87 ""../../asn1/x509af/x509af.cnf""
x509af_export_publickey(tvb, actx, orig_offset, offset - orig_offset);
return offset;
}","int
dissect_x509af_SubjectPublicKeyInfo(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 85 ""../../asn1/x509af/x509af.cnf""
int VAR_6 = VAR_2;
VAR_2 = dissect_ber_sequence(VAR_0, VAR_3, VAR_4, VAR_1, VAR_2,
VAR_7, VAR_5, VAR_8);
#line 87 ""../../asn1/x509af/x509af.cnf""
x509af_export_publickey(VAR_1, VAR_3, VAR_6, VAR_2 - VAR_6);
return VAR_2;
}",,"int
dissect_x509af_SubjectPublicKeyInfo(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 91 ""../../asn1/x509af/x509af.cnf""
  int orig_offset = offset;

  offset = dissect_ber_sequence(implicit_tag, actx, tree, tvb, offset,
                                   SubjectPublicKeyInfo_sequence, hf_index, ett_x509af_SubjectPublicKeyInfo);

#line 93 ""../../asn1/x509af/x509af.cnf""
  x509af_export_publickey(tvb, actx, orig_offset, offset - orig_offset);

  return offset;
}","int
dissect_x509af_SubjectPublicKeyInfo(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 91 ""../../asn1/x509af/x509af.cnf""
  int VAR_6 = VAR_2;

  VAR_2 = dissect_ber_sequence(VAR_0, VAR_3, VAR_4, VAR_1, VAR_2,
                                   VAR_7, VAR_5, VAR_8);

#line 93 ""../../asn1/x509af/x509af.cnf""
  x509af_export_publickey(VAR_1, VAR_3, VAR_6, VAR_2 - VAR_6);

  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -1,12 +1,12 @@
 int
 dissect_x509af_SubjectPublicKeyInfo(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
-#line 85 ""../../asn1/x509af/x509af.cnf""
+#line 91 ""../../asn1/x509af/x509af.cnf""
   int orig_offset = offset;
 
   offset = dissect_ber_sequence(implicit_tag, actx, tree, tvb, offset,
                                    SubjectPublicKeyInfo_sequence, hf_index, ett_x509af_SubjectPublicKeyInfo);
 
-#line 87 ""../../asn1/x509af/x509af.cnf""
+#line 93 ""../../asn1/x509af/x509af.cnf""
   x509af_export_publickey(tvb, actx, orig_offset, offset - orig_offset);
 
   return offset;","{'deleted_lines': ['#line 85 ""../../asn1/x509af/x509af.cnf""', '#line 87 ""../../asn1/x509af/x509af.cnf""'], 'added_lines': ['#line 91 ""../../asn1/x509af/x509af.cnf""', '#line 93 ""../../asn1/x509af/x509af.cnf""']}",True,"epan/dissectors/packet-x509af.c in the X.509AF dissector in Wireshark 2.0.x before 2.0.2 mishandles the algorithm ID, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.",5.9,MEDIUM,1,test,2016-01-18T21:08:38Z,1
CVE-2016-2524,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"X509AF: make a local copy of algorithm_id in file scope for later use

Bug: 12002
Change-Id: Iff48863c1954f76d6fc34150d315d15295dc1f5c
Reviewed-on: https://code.wireshark.org/review/13406
Petri-Dish: Pascal Quantin <pascal.quantin@gmail.com>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Pascal Quantin <pascal.quantin@gmail.com>",5a8020a1b6bb73fcb8bb7eb7d53177bc8a9fc703,https://github.com/wireshark/wireshark/commit/5a8020a1b6bb73fcb8bb7eb7d53177bc8a9fc703,epan/dissectors/packet-x509af.c,dissect_x509af_T_algorithmId,"static int
dissect_x509af_T_algorithmId(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 69 ""../../asn1/x509af/x509af.cnf""
const char *name;
offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_x509af_algorithm_id, &actx->external.direct_reference);
algorithm_id = actx->external.direct_reference;
if(actx->external.direct_reference) {
name = oid_resolved_from_string(wmem_packet_scope(), actx->external.direct_reference);
proto_item_append_text(tree, "" (%s)"", name ? name : actx->external.direct_reference);
}
return offset;
}","static int
dissect_x509af_T_algorithmId(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 69 ""../../asn1/x509af/x509af.cnf""
const char *VAR_6;
VAR_2 = dissect_ber_object_identifier_str(VAR_0, VAR_3, VAR_4, VAR_1, VAR_2, VAR_7, &VAR_3->external.direct_reference);
VAR_8 = VAR_3->external.direct_reference;
if(VAR_3->external.direct_reference) {
VAR_6 = oid_resolved_from_string(wmem_packet_scope(), VAR_3->external.direct_reference);
proto_item_append_text(VAR_4, "" (%s)"", VAR_6 ? VAR_6 : VAR_3->external.direct_reference);
}
return VAR_2;
}",,"static int
dissect_x509af_T_algorithmId(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 69 ""../../asn1/x509af/x509af.cnf""
  const char *name;

    offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_x509af_algorithm_id, &actx->external.direct_reference);


  if (algorithm_id) {
    wmem_free(wmem_file_scope(), (void*)algorithm_id);
  }

  if(actx->external.direct_reference) {
    algorithm_id = (const char *)wmem_strdup(wmem_file_scope(), actx->external.direct_reference);

    name = oid_resolved_from_string(wmem_packet_scope(), actx->external.direct_reference);

    proto_item_append_text(tree, "" (%s)"", name ? name : actx->external.direct_reference);
  } else {
    algorithm_id = NULL;
  }



  return offset;
}","static int
dissect_x509af_T_algorithmId(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 69 ""../../asn1/x509af/x509af.cnf""
  const char *VAR_6;

    VAR_2 = dissect_ber_object_identifier_str(VAR_0, VAR_3, VAR_4, VAR_1, VAR_2, VAR_7, &VAR_3->external.direct_reference);


  if (VAR_8) {
    wmem_free(wmem_file_scope(), (void*)VAR_8);
  }

  if(VAR_3->external.direct_reference) {
    VAR_8 = (const char *)wmem_strdup(wmem_file_scope(), VAR_3->external.direct_reference);

    VAR_6 = oid_resolved_from_string(wmem_packet_scope(), VAR_3->external.direct_reference);

    proto_item_append_text(VAR_4, "" (%s)"", VAR_6 ? VAR_6 : VAR_3->external.direct_reference);
  } else {
    VAR_8 = NULL;
  }



  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -6,12 +6,18 @@
     offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_x509af_algorithm_id, &actx->external.direct_reference);
 
 
-  algorithm_id = actx->external.direct_reference;
+  if (algorithm_id) {
+    wmem_free(wmem_file_scope(), (void*)algorithm_id);
+  }
 
   if(actx->external.direct_reference) {
+    algorithm_id = (const char *)wmem_strdup(wmem_file_scope(), actx->external.direct_reference);
+
     name = oid_resolved_from_string(wmem_packet_scope(), actx->external.direct_reference);
 
     proto_item_append_text(tree, "" (%s)"", name ? name : actx->external.direct_reference);
+  } else {
+    algorithm_id = NULL;
   }
 
 ","{'deleted_lines': ['  algorithm_id = actx->external.direct_reference;'], 'added_lines': ['  if (algorithm_id) {', '    wmem_free(wmem_file_scope(), (void*)algorithm_id);', '  }', '    algorithm_id = (const char *)wmem_strdup(wmem_file_scope(), actx->external.direct_reference);', '', '  } else {', '    algorithm_id = NULL;']}",True,"epan/dissectors/packet-x509af.c in the X.509AF dissector in Wireshark 2.0.x before 2.0.2 mishandles the algorithm ID, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.",5.9,MEDIUM,1,test,2016-01-18T21:08:38Z,1
CVE-2016-2524,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"X509AF: make a local copy of algorithm_id in file scope for later use

Bug: 12002
Change-Id: Iff48863c1954f76d6fc34150d315d15295dc1f5c
Reviewed-on: https://code.wireshark.org/review/13406
Petri-Dish: Pascal Quantin <pascal.quantin@gmail.com>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Pascal Quantin <pascal.quantin@gmail.com>",5a8020a1b6bb73fcb8bb7eb7d53177bc8a9fc703,https://github.com/wireshark/wireshark/commit/5a8020a1b6bb73fcb8bb7eb7d53177bc8a9fc703,epan/dissectors/packet-x509af.c,dissect_x509af_T_extnId,"static int
dissect_x509af_T_extnId(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 120 ""../../asn1/x509af/x509af.cnf""
const char *name;
offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_x509af_extension_id, &actx->external.direct_reference);
if(actx->external.direct_reference) {
name = oid_resolved_from_string(wmem_packet_scope(), actx->external.direct_reference);
proto_item_append_text(tree, "" (%s)"", name ? name : actx->external.direct_reference);
}
return offset;
}","static int
dissect_x509af_T_extnId(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 120 ""../../asn1/x509af/x509af.cnf""
const char *VAR_6;
VAR_2 = dissect_ber_object_identifier_str(VAR_0, VAR_3, VAR_4, VAR_1, VAR_2, VAR_7, &VAR_3->external.direct_reference);
if(VAR_3->external.direct_reference) {
VAR_6 = oid_resolved_from_string(wmem_packet_scope(), VAR_3->external.direct_reference);
proto_item_append_text(VAR_4, "" (%s)"", VAR_6 ? VAR_6 : VAR_3->external.direct_reference);
}
return VAR_2;
}",,"static int
dissect_x509af_T_extnId(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 126 ""../../asn1/x509af/x509af.cnf""
  const char *name;

    offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_x509af_extension_id, &actx->external.direct_reference);


  if(actx->external.direct_reference) {
    name = oid_resolved_from_string(wmem_packet_scope(), actx->external.direct_reference);

    proto_item_append_text(tree, "" (%s)"", name ? name : actx->external.direct_reference);
  }



  return offset;
}","static int
dissect_x509af_T_extnId(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 126 ""../../asn1/x509af/x509af.cnf""
  const char *VAR_6;

    VAR_2 = dissect_ber_object_identifier_str(VAR_0, VAR_3, VAR_4, VAR_1, VAR_2, VAR_7, &VAR_3->external.direct_reference);


  if(VAR_3->external.direct_reference) {
    VAR_6 = oid_resolved_from_string(wmem_packet_scope(), VAR_3->external.direct_reference);

    proto_item_append_text(VAR_4, "" (%s)"", VAR_6 ? VAR_6 : VAR_3->external.direct_reference);
  }



  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int
 dissect_x509af_T_extnId(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
-#line 120 ""../../asn1/x509af/x509af.cnf""
+#line 126 ""../../asn1/x509af/x509af.cnf""
   const char *name;
 
     offset = dissect_ber_object_identifier_str(implicit_tag, actx, tree, tvb, offset, hf_x509af_extension_id, &actx->external.direct_reference);","{'deleted_lines': ['#line 120 ""../../asn1/x509af/x509af.cnf""'], 'added_lines': ['#line 126 ""../../asn1/x509af/x509af.cnf""']}",True,"epan/dissectors/packet-x509af.c in the X.509AF dissector in Wireshark 2.0.x before 2.0.2 mishandles the algorithm ID, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.",5.9,MEDIUM,1,test,2016-01-18T21:08:38Z,1
CVE-2016-2524,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"X509AF: make a local copy of algorithm_id in file scope for later use

Bug: 12002
Change-Id: Iff48863c1954f76d6fc34150d315d15295dc1f5c
Reviewed-on: https://code.wireshark.org/review/13406
Petri-Dish: Pascal Quantin <pascal.quantin@gmail.com>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Pascal Quantin <pascal.quantin@gmail.com>",5a8020a1b6bb73fcb8bb7eb7d53177bc8a9fc703,https://github.com/wireshark/wireshark/commit/5a8020a1b6bb73fcb8bb7eb7d53177bc8a9fc703,epan/dissectors/packet-x509af.c,dissect_x509af_T_parameters,"static int
dissect_x509af_T_parameters(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 82 ""../../asn1/x509af/x509af.cnf""
offset=call_ber_oid_callback(actx->external.direct_reference, tvb, offset, actx->pinfo, tree, NULL);
return offset;
}","static int
dissect_x509af_T_parameters(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 82 ""../../asn1/x509af/x509af.cnf""
VAR_2=call_ber_oid_callback(VAR_3->external.direct_reference, VAR_1, VAR_2, VAR_3->pinfo, VAR_4, NULL);
return VAR_2;
}",,"static int
dissect_x509af_T_parameters(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 88 ""../../asn1/x509af/x509af.cnf""
  offset=call_ber_oid_callback(actx->external.direct_reference, tvb, offset, actx->pinfo, tree, NULL);



  return offset;
}","static int
dissect_x509af_T_parameters(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 88 ""../../asn1/x509af/x509af.cnf""
  VAR_2=call_ber_oid_callback(VAR_3->external.direct_reference, VAR_1, VAR_2, VAR_3->pinfo, VAR_4, NULL);



  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int
 dissect_x509af_T_parameters(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
-#line 82 ""../../asn1/x509af/x509af.cnf""
+#line 88 ""../../asn1/x509af/x509af.cnf""
   offset=call_ber_oid_callback(actx->external.direct_reference, tvb, offset, actx->pinfo, tree, NULL);
 
 ","{'deleted_lines': ['#line 82 ""../../asn1/x509af/x509af.cnf""'], 'added_lines': ['#line 88 ""../../asn1/x509af/x509af.cnf""']}",True,"epan/dissectors/packet-x509af.c in the X.509AF dissector in Wireshark 2.0.x before 2.0.2 mishandles the algorithm ID, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.",5.9,MEDIUM,1,test,2016-01-18T21:08:38Z,1
CVE-2016-2524,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"X509AF: make a local copy of algorithm_id in file scope for later use

Bug: 12002
Change-Id: Iff48863c1954f76d6fc34150d315d15295dc1f5c
Reviewed-on: https://code.wireshark.org/review/13406
Petri-Dish: Pascal Quantin <pascal.quantin@gmail.com>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Pascal Quantin <pascal.quantin@gmail.com>",5a8020a1b6bb73fcb8bb7eb7d53177bc8a9fc703,https://github.com/wireshark/wireshark/commit/5a8020a1b6bb73fcb8bb7eb7d53177bc8a9fc703,epan/dissectors/packet-x509af.c,dissect_x509af_T_extnValue,"static int
dissect_x509af_T_extnValue(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 131 ""../../asn1/x509af/x509af.cnf""
gint8 ber_class;
gboolean pc, ind;
gint32 tag;
guint32 len;
offset = dissect_ber_identifier(actx->pinfo, tree, tvb, offset, &ber_class, &pc, &tag);
offset = dissect_ber_length(actx->pinfo, tree, tvb, offset, &len, &ind);
offset=call_ber_oid_callback(actx->external.direct_reference, tvb, offset, actx->pinfo, tree, NULL);
return offset;
}","static int
dissect_x509af_T_extnValue(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 131 ""../../asn1/x509af/x509af.cnf""
gint8 VAR_6;
gboolean VAR_7, VAR_8;
gint32 VAR_9;
guint32 VAR_10;
VAR_2 = dissect_ber_identifier(VAR_3->pinfo, VAR_4, VAR_1, VAR_2, &VAR_6, &VAR_7, &VAR_9);
VAR_2 = dissect_ber_length(VAR_3->pinfo, VAR_4, VAR_1, VAR_2, &VAR_10, &VAR_8);
VAR_2=call_ber_oid_callback(VAR_3->external.direct_reference, VAR_1, VAR_2, VAR_3->pinfo, VAR_4, NULL);
return VAR_2;
}",,"static int
dissect_x509af_T_extnValue(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 137 ""../../asn1/x509af/x509af.cnf""
  gint8 ber_class;
  gboolean pc, ind;
  gint32 tag;
  guint32 len;
  /* skip past the T and L  */
  offset = dissect_ber_identifier(actx->pinfo, tree, tvb, offset, &ber_class, &pc, &tag);
  offset = dissect_ber_length(actx->pinfo, tree, tvb, offset, &len, &ind);
  offset=call_ber_oid_callback(actx->external.direct_reference, tvb, offset, actx->pinfo, tree, NULL);



  return offset;
}","static int
dissect_x509af_T_extnValue(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 137 ""../../asn1/x509af/x509af.cnf""
  gint8 VAR_6;
  gboolean VAR_7, VAR_8;
  gint32 VAR_9;
  guint32 VAR_10;
  /* COMMENT_0 */
  VAR_2 = dissect_ber_identifier(VAR_3->pinfo, VAR_4, VAR_1, VAR_2, &VAR_6, &VAR_7, &VAR_9);
  VAR_2 = dissect_ber_length(VAR_3->pinfo, VAR_4, VAR_1, VAR_2, &VAR_10, &VAR_8);
  VAR_2=call_ber_oid_callback(VAR_3->external.direct_reference, VAR_1, VAR_2, VAR_3->pinfo, VAR_4, NULL);



  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int
 dissect_x509af_T_extnValue(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
-#line 131 ""../../asn1/x509af/x509af.cnf""
+#line 137 ""../../asn1/x509af/x509af.cnf""
   gint8 ber_class;
   gboolean pc, ind;
   gint32 tag;","{'deleted_lines': ['#line 131 ""../../asn1/x509af/x509af.cnf""'], 'added_lines': ['#line 137 ""../../asn1/x509af/x509af.cnf""']}",True,"epan/dissectors/packet-x509af.c in the X.509AF dissector in Wireshark 2.0.x before 2.0.2 mishandles the algorithm ID, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.",5.9,MEDIUM,1,test,2016-01-18T21:08:38Z,1
CVE-2016-2524,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"X509AF: make a local copy of algorithm_id in file scope for later use

Bug: 12002
Change-Id: Iff48863c1954f76d6fc34150d315d15295dc1f5c
Reviewed-on: https://code.wireshark.org/review/13406
Petri-Dish: Pascal Quantin <pascal.quantin@gmail.com>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Pascal Quantin <pascal.quantin@gmail.com>",5a8020a1b6bb73fcb8bb7eb7d53177bc8a9fc703,https://github.com/wireshark/wireshark/commit/5a8020a1b6bb73fcb8bb7eb7d53177bc8a9fc703,epan/dissectors/packet-x509af.c,dissect_x509af_SubjectName,"static int
dissect_x509af_SubjectName(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 141 ""../../asn1/x509af/x509af.cnf""
const char* str;
offset = dissect_ber_choice(actx, tree, tvb, offset,
SubjectName_choice, hf_index, ett_x509af_SubjectName,
NULL);
str = x509if_get_last_dn();
proto_item_append_text(proto_item_get_parent(tree), "" (%s)"", str?str:"""");
return offset;
}","static int
dissect_x509af_SubjectName(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 141 ""../../asn1/x509af/x509af.cnf""
const char* VAR_6;
VAR_2 = dissect_ber_choice(VAR_3, VAR_4, VAR_1, VAR_2,
VAR_7, VAR_5, VAR_8,
NULL);
VAR_6 = x509if_get_last_dn();
proto_item_append_text(proto_item_get_parent(VAR_4), "" (%s)"", VAR_6?VAR_6:"""");
return VAR_2;
}",,"static int
dissect_x509af_SubjectName(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 147 ""../../asn1/x509af/x509af.cnf""

  const char* str;
    offset = dissect_ber_choice(actx, tree, tvb, offset,
                                 SubjectName_choice, hf_index, ett_x509af_SubjectName,
                                 NULL);


  str = x509if_get_last_dn();
  proto_item_append_text(proto_item_get_parent(tree), "" (%s)"", str?str:"""");



  return offset;
}","static int
dissect_x509af_SubjectName(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 147 ""../../asn1/x509af/x509af.cnf""

  const char* VAR_6;
    VAR_2 = dissect_ber_choice(VAR_3, VAR_4, VAR_1, VAR_2,
                                 VAR_7, VAR_5, VAR_8,
                                 NULL);


  VAR_6 = x509if_get_last_dn();
  proto_item_append_text(proto_item_get_parent(VAR_4), "" (%s)"", VAR_6?VAR_6:"""");



  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int
 dissect_x509af_SubjectName(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
-#line 141 ""../../asn1/x509af/x509af.cnf""
+#line 147 ""../../asn1/x509af/x509af.cnf""
 
   const char* str;
     offset = dissect_ber_choice(actx, tree, tvb, offset,","{'deleted_lines': ['#line 141 ""../../asn1/x509af/x509af.cnf""'], 'added_lines': ['#line 147 ""../../asn1/x509af/x509af.cnf""']}",True,"epan/dissectors/packet-x509af.c in the X.509AF dissector in Wireshark 2.0.x before 2.0.2 mishandles the algorithm ID, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.",5.9,MEDIUM,1,test,2016-01-18T21:08:38Z,1
CVE-2016-2524,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"X509AF: make a local copy of algorithm_id in file scope for later use

Bug: 12002
Change-Id: Iff48863c1954f76d6fc34150d315d15295dc1f5c
Reviewed-on: https://code.wireshark.org/review/13406
Petri-Dish: Pascal Quantin <pascal.quantin@gmail.com>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Pascal Quantin <pascal.quantin@gmail.com>",5a8020a1b6bb73fcb8bb7eb7d53177bc8a9fc703,https://github.com/wireshark/wireshark/commit/5a8020a1b6bb73fcb8bb7eb7d53177bc8a9fc703,epan/dissectors/packet-x509af.c,dissect_x509af_T_subjectPublicKey,"static int
dissect_x509af_T_subjectPublicKey(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 91 ""../../asn1/x509af/x509af.cnf""
tvbuff_t *bs_tvb = NULL;
dissect_ber_bitstring(FALSE, actx, NULL, tvb, offset,
NULL, -1, -1, &bs_tvb);
if (bs_tvb && !g_strcmp0(algorithm_id, ""1.2.840.113549.1.1.1"")) { 
offset += dissect_pkcs1_RSAPublicKey(FALSE, bs_tvb, 0, actx, tree, hf_index);
} else {
offset = dissect_ber_bitstring(FALSE, actx, tree, tvb, offset,
NULL, hf_index, -1, NULL);
}
return offset;
}","static int
dissect_x509af_T_subjectPublicKey(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 91 ""../../asn1/x509af/x509af.cnf""
tvbuff_t *VAR_6 = NULL;
dissect_ber_bitstring(FALSE, VAR_3, NULL, VAR_1, VAR_2,
NULL, -1, -1, &VAR_6);
if (VAR_6 && !g_strcmp0(VAR_7, ""1.2.840.113549.1.1.1"")) { 
VAR_2 += dissect_pkcs1_RSAPublicKey(FALSE, VAR_6, 0, VAR_3, VAR_4, VAR_5);
} else {
VAR_2 = dissect_ber_bitstring(FALSE, VAR_3, VAR_4, VAR_1, VAR_2,
NULL, VAR_5, -1, NULL);
}
return VAR_2;
}",,"static int
dissect_x509af_T_subjectPublicKey(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
#line 97 ""../../asn1/x509af/x509af.cnf""
  tvbuff_t *bs_tvb = NULL;

  dissect_ber_bitstring(FALSE, actx, NULL, tvb, offset,
                        NULL, -1, -1, &bs_tvb);

  /* See RFC 3279 for possible subjectPublicKey values given an Algorithm ID.
   * The contents of subjectPublicKey are always explicitly tagged. */
  if (bs_tvb && !g_strcmp0(algorithm_id, ""1.2.840.113549.1.1.1"")) { /* id-rsa */
    offset += dissect_pkcs1_RSAPublicKey(FALSE, bs_tvb, 0, actx, tree, hf_index);

  } else {
    offset = dissect_ber_bitstring(FALSE, actx, tree, tvb, offset,
                                   NULL, hf_index, -1, NULL);
  }



  return offset;
}","static int
dissect_x509af_T_subjectPublicKey(gboolean VAR_0 _U_, tvbuff_t *VAR_1 _U_, int VAR_2 _U_, asn1_ctx_t *VAR_3 _U_, proto_tree *VAR_4 _U_, int VAR_5 _U_) {
#line 97 ""../../asn1/x509af/x509af.cnf""
  tvbuff_t *VAR_6 = NULL;

  dissect_ber_bitstring(FALSE, VAR_3, NULL, VAR_1, VAR_2,
                        NULL, -1, -1, &VAR_6);

  /* COMMENT_0 */
                                                                      
  if (VAR_6 && !g_strcmp0(VAR_7, ""1.2.840.113549.1.1.1"")) { /* COMMENT_2 */
    VAR_2 += dissect_pkcs1_RSAPublicKey(FALSE, VAR_6, 0, VAR_3, VAR_4, VAR_5);

  } else {
    VAR_2 = dissect_ber_bitstring(FALSE, VAR_3, VAR_4, VAR_1, VAR_2,
                                   NULL, VAR_5, -1, NULL);
  }



  return VAR_2;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static int
 dissect_x509af_T_subjectPublicKey(gboolean implicit_tag _U_, tvbuff_t *tvb _U_, int offset _U_, asn1_ctx_t *actx _U_, proto_tree *tree _U_, int hf_index _U_) {
-#line 91 ""../../asn1/x509af/x509af.cnf""
+#line 97 ""../../asn1/x509af/x509af.cnf""
   tvbuff_t *bs_tvb = NULL;
 
   dissect_ber_bitstring(FALSE, actx, NULL, tvb, offset,","{'deleted_lines': ['#line 91 ""../../asn1/x509af/x509af.cnf""'], 'added_lines': ['#line 97 ""../../asn1/x509af/x509af.cnf""']}",True,"epan/dissectors/packet-x509af.c in the X.509AF dissector in Wireshark 2.0.x before 2.0.2 mishandles the algorithm ID, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.",5.9,MEDIUM,1,test,2016-01-18T21:08:38Z,1
CVE-2016-7532,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,Added check for out of bounds read (https://github.com/ImageMagick/ImageMagick/issues/108).,4f2c04ea6673863b87ac7f186cbb0d911f74085c,https://github.com/ImageMagick/ImageMagick/commit/4f2c04ea6673863b87ac7f186cbb0d911f74085c,coders/psd.c,WritePSDImage,"static MagickBooleanType WritePSDImage(const ImageInfo *image_info,Image *image,
ExceptionInfo *exception)
{
const char
*property;
const StringInfo
*icc_profile;
Image
*base_image,
*next_image;
MagickBooleanType
status;
PSDInfo
psd_info;
register ssize_t
i;
size_t
channel_size,
channelLength,
layer_count,
layer_info_size,
length,
num_channels,
packet_size,
rounded_layer_info_size;
StringInfo
*bim_profile;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
assert(image != (Image *) NULL);
assert(image->signature == MagickCoreSignature);
if (image->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
if (status == MagickFalse)
return(status);
packet_size=(size_t) (image->depth > 8 ? 6 : 3);
if (image->alpha_trait != UndefinedPixelTrait)
packet_size+=image->depth > 8 ? 2 : 1;
psd_info.version=1;
if ((LocaleCompare(image_info->magick,""PSB"") == 0) ||
(image->columns > 30000) || (image->rows > 30000))
psd_info.version=2;
(void) WriteBlob(image,4,(const unsigned char *) ""8BPS"");
(void) WriteBlobMSBShort(image,psd_info.version);  
for (i=1; i <= 6; i++)
(void) WriteBlobByte(image, 0);  
if (SetImageGray(image,exception) != MagickFalse)
num_channels=(image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL);
else
if ((image_info->type != TrueColorType) && (image_info->type !=
TrueColorAlphaType) && (image->storage_class == PseudoClass))
num_channels=(image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL);
else
{
if (image->storage_class == PseudoClass)
(void) SetImageStorageClass(image,DirectClass,exception);
if (image->colorspace != CMYKColorspace)
num_channels=(image->alpha_trait != UndefinedPixelTrait ? 4UL : 3UL);
else
num_channels=(image->alpha_trait != UndefinedPixelTrait ? 5UL : 4UL);
}
(void) WriteBlobMSBShort(image,(unsigned short) num_channels);
(void) WriteBlobMSBLong(image,(unsigned int) image->rows);
(void) WriteBlobMSBLong(image,(unsigned int) image->columns);
if (IsImageGray(image) != MagickFalse)
{
MagickBooleanType
monochrome;
monochrome=IsImageMonochrome(image) && (image->depth == 1) ?
MagickTrue : MagickFalse;
(void) WriteBlobMSBShort(image,(unsigned short)
(monochrome != MagickFalse ? 1 : image->depth > 8 ? 16 : 8));
(void) WriteBlobMSBShort(image,(unsigned short)
(monochrome != MagickFalse ? BitmapMode : GrayscaleMode));
}
else
{
(void) WriteBlobMSBShort(image,(unsigned short) (image->storage_class ==
PseudoClass ? 8 : image->depth > 8 ? 16 : 8));
if (((image_info->colorspace != UndefinedColorspace) ||
(image->colorspace != CMYKColorspace)) &&
(image_info->colorspace != CMYKColorspace))
{
(void) TransformImageColorspace(image,sRGBColorspace,exception);
(void) WriteBlobMSBShort(image,(unsigned short)
(image->storage_class == PseudoClass ? IndexedMode : RGBMode));
}
else
{
if (image->colorspace != CMYKColorspace)
(void) TransformImageColorspace(image,CMYKColorspace,exception);
(void) WriteBlobMSBShort(image,CMYKMode);
}
}
if ((IsImageGray(image) != MagickFalse) ||
(image->storage_class == DirectClass) || (image->colors > 256))
(void) WriteBlobMSBLong(image,0);
else
{
(void) WriteBlobMSBLong(image,768);
for (i=0; i < (ssize_t) image->colors; i++)
(void) WriteBlobByte(image,ScaleQuantumToChar(image->colormap[i].red));
for ( ; i < 256; i++)
(void) WriteBlobByte(image,0);
for (i=0; i < (ssize_t) image->colors; i++)
(void) WriteBlobByte(image,ScaleQuantumToChar(
image->colormap[i].green));
for ( ; i < 256; i++)
(void) WriteBlobByte(image,0);
for (i=0; i < (ssize_t) image->colors; i++)
(void) WriteBlobByte(image,ScaleQuantumToChar(image->colormap[i].blue));
for ( ; i < 256; i++)
(void) WriteBlobByte(image,0);
}
length=28; 
bim_profile=(StringInfo *) GetImageProfile(image,""8bim"");
icc_profile=GetImageProfile(image,""icc"");
if (bim_profile != (StringInfo *) NULL)
{
bim_profile=CloneStringInfo(bim_profile);
if (icc_profile != (StringInfo *) NULL)
RemoveICCProfileFromResourceBlock(bim_profile);
RemoveResolutionFromResourceBlock(bim_profile);
length+=PSDQuantum(GetStringInfoLength(bim_profile));
}
if (icc_profile != (const StringInfo *) NULL)
length+=PSDQuantum(GetStringInfoLength(icc_profile))+12;
(void) WriteBlobMSBLong(image,(unsigned int) length);
WriteResolutionResourceBlock(image);
if (bim_profile != (StringInfo *) NULL)
{
(void) WriteBlob(image,GetStringInfoLength(bim_profile),
GetStringInfoDatum(bim_profile));
bim_profile=DestroyStringInfo(bim_profile);
}
if (icc_profile != (StringInfo *) NULL)
{
(void) WriteBlob(image,4,(const unsigned char *) ""8BIM"");
(void) WriteBlobMSBShort(image,0x0000040F);
(void) WriteBlobMSBShort(image,0);
(void) WriteBlobMSBLong(image,(unsigned int) GetStringInfoLength(
icc_profile));
(void) WriteBlob(image,GetStringInfoLength(icc_profile),
GetStringInfoDatum(icc_profile));
if ((MagickOffsetType) GetStringInfoLength(icc_profile) !=
PSDQuantum(GetStringInfoLength(icc_profile)))
(void) WriteBlobByte(image,0);
}
layer_count=0;
layer_info_size=2;
base_image=GetNextImageInList(image);
if ((image->alpha_trait != UndefinedPixelTrait) && (base_image == (Image *) NULL))
base_image=image;
next_image=base_image;
while ( next_image != NULL )
{
packet_size=next_image->depth > 8 ? 2UL : 1UL;
if (IsImageGray(next_image) != MagickFalse)
num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL;
else
if (next_image->storage_class == PseudoClass)
num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL;
else
if (next_image->colorspace != CMYKColorspace)
num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 4UL : 3UL;
else
num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 5UL : 4UL;
channelLength=(size_t) (next_image->columns*next_image->rows*packet_size+2);
layer_info_size+=(size_t) (4*4+2+num_channels*6+(psd_info.version == 1 ? 8 :
16)+4*1+4+num_channels*channelLength);
property=(const char *) GetImageProperty(next_image,""label"",exception);
if (property == (const char *) NULL)
layer_info_size+=16;
else
{
size_t
layer_length;
layer_length=strlen(property);
layer_info_size+=8+layer_length+(4-(layer_length % 4));
}
layer_count++;
next_image=GetNextImageInList(next_image);
}
if (layer_count == 0)
(void) SetPSDSize(&psd_info,image,0);
else
{
CompressionType
compression;
(void) SetPSDSize(&psd_info,image,layer_info_size+
(psd_info.version == 1 ? 8 : 16));
if ((layer_info_size/2) != ((layer_info_size+1)/2))
rounded_layer_info_size=layer_info_size+1;
else
rounded_layer_info_size=layer_info_size;
(void) SetPSDSize(&psd_info,image,rounded_layer_info_size);
if (image->alpha_trait != UndefinedPixelTrait)
(void) WriteBlobMSBShort(image,-(unsigned short) layer_count);
else
(void) WriteBlobMSBShort(image,(unsigned short) layer_count);
layer_count=1;
compression=base_image->compression;
for (next_image=base_image; next_image != NULL; )
{
next_image->compression=NoCompression;
(void) WriteBlobMSBLong(image,(unsigned int) next_image->page.y);
(void) WriteBlobMSBLong(image,(unsigned int) next_image->page.x);
(void) WriteBlobMSBLong(image,(unsigned int) (next_image->page.y+
next_image->rows));
(void) WriteBlobMSBLong(image,(unsigned int) (next_image->page.x+
next_image->columns));
packet_size=next_image->depth > 8 ? 2UL : 1UL;
channel_size=(unsigned int) ((packet_size*next_image->rows*
next_image->columns)+2);
if ((IsImageGray(next_image) != MagickFalse) ||
(next_image->storage_class == PseudoClass))
{
(void) WriteBlobMSBShort(image,(unsigned short)
(next_image->alpha_trait != UndefinedPixelTrait ? 2 : 1));
(void) WriteBlobMSBShort(image,0);
(void) SetPSDSize(&psd_info,image,channel_size);
if (next_image->alpha_trait != UndefinedPixelTrait)
{
(void) WriteBlobMSBShort(image,(unsigned short) -1);
(void) SetPSDSize(&psd_info,image,channel_size);
}
}
else
if (next_image->colorspace != CMYKColorspace)
{
(void) WriteBlobMSBShort(image,(unsigned short)
(next_image->alpha_trait != UndefinedPixelTrait ? 4 : 3));
(void) WriteBlobMSBShort(image,0);
(void) SetPSDSize(&psd_info,image,channel_size);
(void) WriteBlobMSBShort(image,1);
(void) SetPSDSize(&psd_info,image,channel_size);
(void) WriteBlobMSBShort(image,2);
(void) SetPSDSize(&psd_info,image,channel_size);
if (next_image->alpha_trait != UndefinedPixelTrait)
{
(void) WriteBlobMSBShort(image,(unsigned short) -1);
(void) SetPSDSize(&psd_info,image,channel_size);
}
}
else
{
(void) WriteBlobMSBShort(image,(unsigned short)
(next_image->alpha_trait ? 5 : 4));
(void) WriteBlobMSBShort(image,0);
(void) SetPSDSize(&psd_info,image,channel_size);
(void) WriteBlobMSBShort(image,1);
(void) SetPSDSize(&psd_info,image,channel_size);
(void) WriteBlobMSBShort(image,2);
(void) SetPSDSize(&psd_info,image,channel_size);
(void) WriteBlobMSBShort(image,3);
(void) SetPSDSize(&psd_info,image,channel_size);
if (next_image->alpha_trait)
{
(void) WriteBlobMSBShort(image,(unsigned short) -1);
(void) SetPSDSize(&psd_info,image,channel_size);
}
}
(void) WriteBlob(image,4,(const unsigned char *) ""8BIM"");
(void) WriteBlob(image,4,(const unsigned char *)
CompositeOperatorToPSDBlendMode(next_image->compose));
(void) WriteBlobByte(image,255); 
(void) WriteBlobByte(image,0);
(void) WriteBlobByte(image,next_image->compose==NoCompositeOp ?
1 << 0x02 : 1); 
(void) WriteBlobByte(image,0);
property=(const char *) GetImageProperty(next_image,""label"",exception);
if (property == (const char *) NULL)
{
char
layer_name[MagickPathExtent];
(void) WriteBlobMSBLong(image,16);
(void) WriteBlobMSBLong(image,0);
(void) WriteBlobMSBLong(image,0);
(void) FormatLocaleString(layer_name,MagickPathExtent,""L%04ld"",(long)
layer_count++);
WritePascalString(image,layer_name,4);
}
else
{
size_t
label_length;
label_length=strlen(property);
(void) WriteBlobMSBLong(image,(unsigned int) (label_length+(4-
(label_length % 4))+8));
(void) WriteBlobMSBLong(image,0);
(void) WriteBlobMSBLong(image,0);
WritePascalString(image,property,4);
}
next_image=GetNextImageInList(next_image);
}
next_image=base_image;
while (next_image != NULL)
{
status=WriteImageChannels(&psd_info,image_info,image,next_image,
MagickTrue,exception);
next_image=GetNextImageInList(next_image);
}
(void) WriteBlobMSBLong(image,0);  
base_image->compression=compression;
}
if (status != MagickFalse)
status=WriteImageChannels(&psd_info,image_info,image,image,MagickFalse,
exception);
(void) CloseBlob(image);
return(status);
}","static MagickBooleanType WritePSDImage(const ImageInfo *VAR_0,Image *VAR_1,
ExceptionInfo *VAR_2)
{
const char
*VAR_3;
const StringInfo
*VAR_4;
Image
*VAR_5,
*VAR_6;
MagickBooleanType
VAR_7;
PSDInfo
VAR_8;
register ssize_t
VAR_9;
size_t
VAR_10,
VAR_11,
VAR_12,
VAR_13,
VAR_14,
VAR_15,
VAR_16,
VAR_17;
StringInfo
*VAR_18;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_19);
assert(VAR_1 != (Image *) NULL);
assert(VAR_1->signature == VAR_19);
if (VAR_1->debug != VAR_20)
(void) LogMagickEvent(VAR_21,GetMagickModule(),""%s"",VAR_1->filename);
assert(VAR_2 != (ExceptionInfo *) NULL);
assert(VAR_2->signature == VAR_19);
VAR_7=OpenBlob(VAR_0,VAR_1,VAR_22,VAR_2);
if (VAR_7 == VAR_20)
return(VAR_7);
VAR_16=(size_t) (VAR_1->depth > 8 ? 6 : 3);
if (VAR_1->alpha_trait != VAR_23)
VAR_16+=VAR_1->depth > 8 ? 2 : 1;
VAR_8.version=1;
if ((LocaleCompare(VAR_0->magick,""PSB"") == 0) ||
(VAR_1->columns > 30000) || (VAR_1->rows > 30000))
VAR_8.version=2;
(void) WriteBlob(VAR_1,4,(const unsigned char *) ""8BPS"");
(void) WriteBlobMSBShort(VAR_1,VAR_8.version);  
for (VAR_9=1; VAR_9 <= 6; VAR_9++)
(void) WriteBlobByte(VAR_1, 0);  
if (SetImageGray(VAR_1,VAR_2) != VAR_20)
VAR_15=(VAR_1->alpha_trait != VAR_23 ? 2UL : 1UL);
else
if ((VAR_0->type != VAR_24) && (VAR_0->type !=
VAR_25) && (VAR_1->storage_class == VAR_26))
VAR_15=(VAR_1->alpha_trait != VAR_23 ? 2UL : 1UL);
else
{
if (VAR_1->storage_class == VAR_26)
(void) SetImageStorageClass(VAR_1,VAR_27,VAR_2);
if (VAR_1->colorspace != VAR_28)
VAR_15=(VAR_1->alpha_trait != VAR_23 ? 4UL : 3UL);
else
VAR_15=(VAR_1->alpha_trait != VAR_23 ? 5UL : 4UL);
}
(void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_15);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_1->rows);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_1->columns);
if (IsImageGray(VAR_1) != VAR_20)
{
MagickBooleanType
VAR_29;
VAR_29=IsImageMonochrome(VAR_1) && (VAR_1->depth == 1) ?
VAR_30 : VAR_20;
(void) WriteBlobMSBShort(VAR_1,(unsigned short)
(VAR_29 != VAR_20 ? 1 : VAR_1->depth > 8 ? 16 : 8));
(void) WriteBlobMSBShort(VAR_1,(unsigned short)
(VAR_29 != VAR_20 ? VAR_31 : VAR_32));
}
else
{
(void) WriteBlobMSBShort(VAR_1,(unsigned short) (VAR_1->storage_class ==
VAR_26 ? 8 : VAR_1->depth > 8 ? 16 : 8));
if (((VAR_0->colorspace != VAR_33) ||
(VAR_1->colorspace != VAR_28)) &&
(VAR_0->colorspace != VAR_28))
{
(void) TransformImageColorspace(VAR_1,VAR_34,VAR_2);
(void) WriteBlobMSBShort(VAR_1,(unsigned short)
(VAR_1->storage_class == VAR_26 ? VAR_35 : VAR_36));
}
else
{
if (VAR_1->colorspace != VAR_28)
(void) TransformImageColorspace(VAR_1,VAR_28,VAR_2);
(void) WriteBlobMSBShort(VAR_1,VAR_37);
}
}
if ((IsImageGray(VAR_1) != VAR_20) ||
(VAR_1->storage_class == VAR_27) || (VAR_1->colors > 256))
(void) WriteBlobMSBLong(VAR_1,0);
else
{
(void) WriteBlobMSBLong(VAR_1,768);
for (VAR_9=0; VAR_9 < (ssize_t) VAR_1->colors; VAR_9++)
(void) WriteBlobByte(VAR_1,ScaleQuantumToChar(VAR_1->colormap[VAR_9].red));
for ( ; VAR_9 < 256; VAR_9++)
(void) WriteBlobByte(VAR_1,0);
for (VAR_9=0; VAR_9 < (ssize_t) VAR_1->colors; VAR_9++)
(void) WriteBlobByte(VAR_1,ScaleQuantumToChar(
VAR_1->colormap[VAR_9].green));
for ( ; VAR_9 < 256; VAR_9++)
(void) WriteBlobByte(VAR_1,0);
for (VAR_9=0; VAR_9 < (ssize_t) VAR_1->colors; VAR_9++)
(void) WriteBlobByte(VAR_1,ScaleQuantumToChar(VAR_1->colormap[VAR_9].blue));
for ( ; VAR_9 < 256; VAR_9++)
(void) WriteBlobByte(VAR_1,0);
}
VAR_14=28; 
VAR_18=(StringInfo *) GetImageProfile(VAR_1,""8bim"");
VAR_4=GetImageProfile(VAR_1,""icc"");
if (VAR_18 != (StringInfo *) NULL)
{
VAR_18=CloneStringInfo(VAR_18);
if (VAR_4 != (StringInfo *) NULL)
RemoveICCProfileFromResourceBlock(VAR_18);
RemoveResolutionFromResourceBlock(VAR_18);
VAR_14+=PSDQuantum(GetStringInfoLength(VAR_18));
}
if (VAR_4 != (const StringInfo *) NULL)
VAR_14+=PSDQuantum(GetStringInfoLength(VAR_4))+12;
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_14);
WriteResolutionResourceBlock(VAR_1);
if (VAR_18 != (StringInfo *) NULL)
{
(void) WriteBlob(VAR_1,GetStringInfoLength(VAR_18),
GetStringInfoDatum(VAR_18));
VAR_18=DestroyStringInfo(VAR_18);
}
if (VAR_4 != (StringInfo *) NULL)
{
(void) WriteBlob(VAR_1,4,(const unsigned char *) ""8BIM"");
(void) WriteBlobMSBShort(VAR_1,0x0000040F);
(void) WriteBlobMSBShort(VAR_1,0);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) GetStringInfoLength(
VAR_4));
(void) WriteBlob(VAR_1,GetStringInfoLength(VAR_4),
GetStringInfoDatum(VAR_4));
if ((MagickOffsetType) GetStringInfoLength(VAR_4) !=
PSDQuantum(GetStringInfoLength(VAR_4)))
(void) WriteBlobByte(VAR_1,0);
}
VAR_12=0;
VAR_13=2;
VAR_5=GetNextImageInList(VAR_1);
if ((VAR_1->alpha_trait != VAR_23) && (VAR_5 == (Image *) NULL))
VAR_5=VAR_1;
VAR_6=VAR_5;
while ( VAR_6 != NULL )
{
VAR_16=VAR_6->depth > 8 ? 2UL : 1UL;
if (IsImageGray(VAR_6) != VAR_20)
VAR_15=VAR_6->alpha_trait != VAR_23 ? 2UL : 1UL;
else
if (VAR_6->storage_class == VAR_26)
VAR_15=VAR_6->alpha_trait != VAR_23 ? 2UL : 1UL;
else
if (VAR_6->colorspace != VAR_28)
VAR_15=VAR_6->alpha_trait != VAR_23 ? 4UL : 3UL;
else
VAR_15=VAR_6->alpha_trait != VAR_23 ? 5UL : 4UL;
VAR_11=(size_t) (VAR_6->columns*VAR_6->rows*VAR_16+2);
VAR_13+=(size_t) (4*4+2+VAR_15*6+(VAR_8.version == 1 ? 8 :
16)+4*1+4+VAR_15*VAR_11);
VAR_3=(const char *) GetImageProperty(VAR_6,""label"",VAR_2);
if (VAR_3 == (const char *) NULL)
VAR_13+=16;
else
{
size_t
VAR_38;
VAR_38=strlen(VAR_3);
VAR_13+=8+VAR_38+(4-(VAR_38 % 4));
}
VAR_12++;
VAR_6=GetNextImageInList(VAR_6);
}
if (VAR_12 == 0)
(void) SetPSDSize(&VAR_8,VAR_1,0);
else
{
CompressionType
VAR_39;
(void) SetPSDSize(&VAR_8,VAR_1,VAR_13+
(VAR_8.version == 1 ? 8 : 16));
if ((VAR_13/2) != ((VAR_13+1)/2))
VAR_17=VAR_13+1;
else
VAR_17=VAR_13;
(void) SetPSDSize(&VAR_8,VAR_1,VAR_17);
if (VAR_1->alpha_trait != VAR_23)
(void) WriteBlobMSBShort(VAR_1,-(unsigned short) VAR_12);
else
(void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_12);
VAR_12=1;
VAR_39=VAR_5->compression;
for (VAR_6=VAR_5; VAR_6 != NULL; )
{
VAR_6->compression=VAR_40;
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_6->page.y);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_6->page.x);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) (VAR_6->page.y+
VAR_6->rows));
(void) WriteBlobMSBLong(VAR_1,(unsigned int) (VAR_6->page.x+
VAR_6->columns));
VAR_16=VAR_6->depth > 8 ? 2UL : 1UL;
VAR_10=(unsigned int) ((VAR_16*VAR_6->rows*
VAR_6->columns)+2);
if ((IsImageGray(VAR_6) != VAR_20) ||
(VAR_6->storage_class == VAR_26))
{
(void) WriteBlobMSBShort(VAR_1,(unsigned short)
(VAR_6->alpha_trait != VAR_23 ? 2 : 1));
(void) WriteBlobMSBShort(VAR_1,0);
(void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
if (VAR_6->alpha_trait != VAR_23)
{
(void) WriteBlobMSBShort(VAR_1,(unsigned short) -1);
(void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
}
}
else
if (VAR_6->colorspace != VAR_28)
{
(void) WriteBlobMSBShort(VAR_1,(unsigned short)
(VAR_6->alpha_trait != VAR_23 ? 4 : 3));
(void) WriteBlobMSBShort(VAR_1,0);
(void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
(void) WriteBlobMSBShort(VAR_1,1);
(void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
(void) WriteBlobMSBShort(VAR_1,2);
(void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
if (VAR_6->alpha_trait != VAR_23)
{
(void) WriteBlobMSBShort(VAR_1,(unsigned short) -1);
(void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
}
}
else
{
(void) WriteBlobMSBShort(VAR_1,(unsigned short)
(VAR_6->alpha_trait ? 5 : 4));
(void) WriteBlobMSBShort(VAR_1,0);
(void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
(void) WriteBlobMSBShort(VAR_1,1);
(void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
(void) WriteBlobMSBShort(VAR_1,2);
(void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
(void) WriteBlobMSBShort(VAR_1,3);
(void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
if (VAR_6->alpha_trait)
{
(void) WriteBlobMSBShort(VAR_1,(unsigned short) -1);
(void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
}
}
(void) WriteBlob(VAR_1,4,(const unsigned char *) ""8BIM"");
(void) WriteBlob(VAR_1,4,(const unsigned char *)
CompositeOperatorToPSDBlendMode(VAR_6->compose));
(void) WriteBlobByte(VAR_1,255); 
(void) WriteBlobByte(VAR_1,0);
(void) WriteBlobByte(VAR_1,VAR_6->compose==VAR_41 ?
1 << 0x02 : 1); 
(void) WriteBlobByte(VAR_1,0);
VAR_3=(const char *) GetImageProperty(VAR_6,""label"",VAR_2);
if (VAR_3 == (const char *) NULL)
{
char
VAR_42[VAR_43];
(void) WriteBlobMSBLong(VAR_1,16);
(void) WriteBlobMSBLong(VAR_1,0);
(void) WriteBlobMSBLong(VAR_1,0);
(void) FormatLocaleString(VAR_42,VAR_43,""L%04ld"",(long)
VAR_12++);
WritePascalString(VAR_1,VAR_42,4);
}
else
{
size_t
VAR_44;
VAR_44=strlen(VAR_3);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) (VAR_44+(4-
(VAR_44 % 4))+8));
(void) WriteBlobMSBLong(VAR_1,0);
(void) WriteBlobMSBLong(VAR_1,0);
WritePascalString(VAR_1,VAR_3,4);
}
VAR_6=GetNextImageInList(VAR_6);
}
VAR_6=VAR_5;
while (VAR_6 != NULL)
{
VAR_7=WriteImageChannels(&VAR_8,VAR_0,VAR_1,VAR_6,
VAR_30,VAR_2);
VAR_6=GetNextImageInList(VAR_6);
}
(void) WriteBlobMSBLong(VAR_1,0);  
VAR_5->compression=VAR_39;
}
if (VAR_7 != VAR_20)
VAR_7=WriteImageChannels(&VAR_8,VAR_0,VAR_1,VAR_1,VAR_20,
VAR_2);
(void) CloseBlob(VAR_1);
return(VAR_7);
}",ImageMagick/4f2c04ea6673863b87ac7f186cbb0d911f74085c/psd.c/vul/before/0.json,"static MagickBooleanType WritePSDImage(const ImageInfo *image_info,
  Image *image,ExceptionInfo *exception)
{
  const char
    *property;

  const StringInfo
    *icc_profile;

  Image
    *base_image,
    *next_image;

  MagickBooleanType
    status;

  PSDInfo
    psd_info;

  register ssize_t
    i;

  size_t
    channel_size,
    channelLength,
    layer_count,
    layer_info_size,
    length,
    num_channels,
    packet_size,
    rounded_layer_info_size;

  StringInfo
    *bim_profile;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(status);
  packet_size=(size_t) (image->depth > 8 ? 6 : 3);
  if (image->alpha_trait != UndefinedPixelTrait)
    packet_size+=image->depth > 8 ? 2 : 1;
  psd_info.version=1;
  if ((LocaleCompare(image_info->magick,""PSB"") == 0) ||
      (image->columns > 30000) || (image->rows > 30000))
    psd_info.version=2;
  (void) WriteBlob(image,4,(const unsigned char *) ""8BPS"");
  (void) WriteBlobMSBShort(image,psd_info.version);  /* version */
  for (i=1; i <= 6; i++)
    (void) WriteBlobByte(image, 0);  /* 6 bytes of reserved */
  if (SetImageGray(image,exception) != MagickFalse)
    num_channels=(image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL);
  else
    if ((image_info->type != TrueColorType) && (image_info->type !=
         TrueColorAlphaType) && (image->storage_class == PseudoClass))
      num_channels=(image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL);
    else
      {
        if (image->storage_class == PseudoClass)
          (void) SetImageStorageClass(image,DirectClass,exception);
        if (image->colorspace != CMYKColorspace)
          num_channels=(image->alpha_trait != UndefinedPixelTrait ? 4UL : 3UL);
        else
          num_channels=(image->alpha_trait != UndefinedPixelTrait ? 5UL : 4UL);
      }
  (void) WriteBlobMSBShort(image,(unsigned short) num_channels);
  (void) WriteBlobMSBLong(image,(unsigned int) image->rows);
  (void) WriteBlobMSBLong(image,(unsigned int) image->columns);
  if (IsImageGray(image) != MagickFalse)
    {
      MagickBooleanType
        monochrome;

      /*
        Write depth & mode.
      */
      monochrome=IsImageMonochrome(image) && (image->depth == 1) ?
        MagickTrue : MagickFalse;
      (void) WriteBlobMSBShort(image,(unsigned short)
        (monochrome != MagickFalse ? 1 : image->depth > 8 ? 16 : 8));
      (void) WriteBlobMSBShort(image,(unsigned short)
        (monochrome != MagickFalse ? BitmapMode : GrayscaleMode));
    }
  else
    {
      (void) WriteBlobMSBShort(image,(unsigned short) (image->storage_class ==
        PseudoClass ? 8 : image->depth > 8 ? 16 : 8));

      if (((image_info->colorspace != UndefinedColorspace) ||
           (image->colorspace != CMYKColorspace)) &&
          (image_info->colorspace != CMYKColorspace))
        {
          (void) TransformImageColorspace(image,sRGBColorspace,exception);
          (void) WriteBlobMSBShort(image,(unsigned short)
            (image->storage_class == PseudoClass ? IndexedMode : RGBMode));
        }
      else
        {
          if (image->colorspace != CMYKColorspace)
            (void) TransformImageColorspace(image,CMYKColorspace,exception);
          (void) WriteBlobMSBShort(image,CMYKMode);
        }
    }
  if ((IsImageGray(image) != MagickFalse) ||
      (image->storage_class == DirectClass) || (image->colors > 256))
    (void) WriteBlobMSBLong(image,0);
  else
    {
      /*
        Write PSD raster colormap.
      */
      (void) WriteBlobMSBLong(image,768);
      for (i=0; i < (ssize_t) image->colors; i++)
        (void) WriteBlobByte(image,ScaleQuantumToChar(image->colormap[i].red));
      for ( ; i < 256; i++)
        (void) WriteBlobByte(image,0);
      for (i=0; i < (ssize_t) image->colors; i++)
        (void) WriteBlobByte(image,ScaleQuantumToChar(
          image->colormap[i].green));
      for ( ; i < 256; i++)
        (void) WriteBlobByte(image,0);
      for (i=0; i < (ssize_t) image->colors; i++)
        (void) WriteBlobByte(image,ScaleQuantumToChar(image->colormap[i].blue));
      for ( ; i < 256; i++)
        (void) WriteBlobByte(image,0);
    }
  /*
    Image resource block.
  */
  length=28; /* 0x03EB */
  bim_profile=(StringInfo *) GetImageProfile(image,""8bim"");
  icc_profile=GetImageProfile(image,""icc"");
  if (bim_profile != (StringInfo *) NULL)
    {
      bim_profile=CloneStringInfo(bim_profile);
      if (icc_profile != (StringInfo *) NULL)
        RemoveICCProfileFromResourceBlock(bim_profile);
      RemoveResolutionFromResourceBlock(bim_profile);
      length+=PSDQuantum(GetStringInfoLength(bim_profile));
    }
  if (icc_profile != (const StringInfo *) NULL)
    length+=PSDQuantum(GetStringInfoLength(icc_profile))+12;
  (void) WriteBlobMSBLong(image,(unsigned int) length);
  WriteResolutionResourceBlock(image);
  if (bim_profile != (StringInfo *) NULL)
    {
      (void) WriteBlob(image,GetStringInfoLength(bim_profile),
        GetStringInfoDatum(bim_profile));
      bim_profile=DestroyStringInfo(bim_profile);
    }
  if (icc_profile != (StringInfo *) NULL)
    {
      (void) WriteBlob(image,4,(const unsigned char *) ""8BIM"");
      (void) WriteBlobMSBShort(image,0x0000040F);
      (void) WriteBlobMSBShort(image,0);
      (void) WriteBlobMSBLong(image,(unsigned int) GetStringInfoLength(
        icc_profile));
      (void) WriteBlob(image,GetStringInfoLength(icc_profile),
        GetStringInfoDatum(icc_profile));
      if ((MagickOffsetType) GetStringInfoLength(icc_profile) !=
          PSDQuantum(GetStringInfoLength(icc_profile)))
        (void) WriteBlobByte(image,0);
    }
  layer_count=0;
  layer_info_size=2;
  base_image=GetNextImageInList(image);
  if ((image->alpha_trait != UndefinedPixelTrait) && (base_image == (Image *) NULL))
    base_image=image;
  next_image=base_image;
  while ( next_image != NULL )
  {
    packet_size=next_image->depth > 8 ? 2UL : 1UL;
    if (IsImageGray(next_image) != MagickFalse)
      num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL;
    else
      if (next_image->storage_class == PseudoClass)
        num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 2UL : 1UL;
      else
        if (next_image->colorspace != CMYKColorspace)
          num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 4UL : 3UL;
        else
          num_channels=next_image->alpha_trait != UndefinedPixelTrait ? 5UL : 4UL;
    channelLength=(size_t) (next_image->columns*next_image->rows*packet_size+2);
    layer_info_size+=(size_t) (4*4+2+num_channels*6+(psd_info.version == 1 ? 8 :
      16)+4*1+4+num_channels*channelLength);
    property=(const char *) GetImageProperty(next_image,""label"",exception);
    if (property == (const char *) NULL)
      layer_info_size+=16;
    else
      {
        size_t
          layer_length;

        layer_length=strlen(property);
        layer_info_size+=8+layer_length+(4-(layer_length % 4));
      }
    layer_count++;
    next_image=GetNextImageInList(next_image);
  }
  if (layer_count == 0)
    (void) SetPSDSize(&psd_info,image,0);
  else
    {
      CompressionType
        compression;

      (void) SetPSDSize(&psd_info,image,layer_info_size+
        (psd_info.version == 1 ? 8 : 16));
      if ((layer_info_size/2) != ((layer_info_size+1)/2))
        rounded_layer_info_size=layer_info_size+1;
      else
        rounded_layer_info_size=layer_info_size;
      (void) SetPSDSize(&psd_info,image,rounded_layer_info_size);
      if (image->alpha_trait != UndefinedPixelTrait)
        (void) WriteBlobMSBShort(image,-(unsigned short) layer_count);
      else
        (void) WriteBlobMSBShort(image,(unsigned short) layer_count);
      layer_count=1;
      compression=base_image->compression;
      for (next_image=base_image; next_image != NULL; )
      {
        next_image->compression=NoCompression;
        (void) WriteBlobMSBLong(image,(unsigned int) next_image->page.y);
        (void) WriteBlobMSBLong(image,(unsigned int) next_image->page.x);
        (void) WriteBlobMSBLong(image,(unsigned int) (next_image->page.y+
          next_image->rows));
        (void) WriteBlobMSBLong(image,(unsigned int) (next_image->page.x+
          next_image->columns));
        packet_size=next_image->depth > 8 ? 2UL : 1UL;
        channel_size=(unsigned int) ((packet_size*next_image->rows*
          next_image->columns)+2);
        if ((IsImageGray(next_image) != MagickFalse) ||
            (next_image->storage_class == PseudoClass))
          {
             (void) WriteBlobMSBShort(image,(unsigned short)
               (next_image->alpha_trait != UndefinedPixelTrait ? 2 : 1));
             (void) WriteBlobMSBShort(image,0);
             (void) SetPSDSize(&psd_info,image,channel_size);
             if (next_image->alpha_trait != UndefinedPixelTrait)
               {
                 (void) WriteBlobMSBShort(image,(unsigned short) -1);
                 (void) SetPSDSize(&psd_info,image,channel_size);
               }
           }
          else
            if (next_image->colorspace != CMYKColorspace)
              {
                (void) WriteBlobMSBShort(image,(unsigned short)
                  (next_image->alpha_trait != UndefinedPixelTrait ? 4 : 3));
               (void) WriteBlobMSBShort(image,0);
               (void) SetPSDSize(&psd_info,image,channel_size);
               (void) WriteBlobMSBShort(image,1);
               (void) SetPSDSize(&psd_info,image,channel_size);
               (void) WriteBlobMSBShort(image,2);
               (void) SetPSDSize(&psd_info,image,channel_size);
               if (next_image->alpha_trait != UndefinedPixelTrait)
                 {
                   (void) WriteBlobMSBShort(image,(unsigned short) -1);
                   (void) SetPSDSize(&psd_info,image,channel_size);
                 }
             }
           else
             {
               (void) WriteBlobMSBShort(image,(unsigned short)
                 (next_image->alpha_trait ? 5 : 4));
               (void) WriteBlobMSBShort(image,0);
               (void) SetPSDSize(&psd_info,image,channel_size);
               (void) WriteBlobMSBShort(image,1);
               (void) SetPSDSize(&psd_info,image,channel_size);
               (void) WriteBlobMSBShort(image,2);
               (void) SetPSDSize(&psd_info,image,channel_size);
               (void) WriteBlobMSBShort(image,3);
               (void) SetPSDSize(&psd_info,image,channel_size);
               if (next_image->alpha_trait)
                 {
                   (void) WriteBlobMSBShort(image,(unsigned short) -1);
                   (void) SetPSDSize(&psd_info,image,channel_size);
                 }
             }
        (void) WriteBlob(image,4,(const unsigned char *) ""8BIM"");
        (void) WriteBlob(image,4,(const unsigned char *)
          CompositeOperatorToPSDBlendMode(next_image->compose));
        (void) WriteBlobByte(image,255); /* layer opacity */
        (void) WriteBlobByte(image,0);
        (void) WriteBlobByte(image,next_image->compose==NoCompositeOp ?
          1 << 0x02 : 1); /* layer properties - visible, etc. */
        (void) WriteBlobByte(image,0);
        property=(const char *) GetImageProperty(next_image,""label"",exception);
        if (property == (const char *) NULL)
          {
            char
              layer_name[MagickPathExtent];

            (void) WriteBlobMSBLong(image,16);
            (void) WriteBlobMSBLong(image,0);
            (void) WriteBlobMSBLong(image,0);
            (void) FormatLocaleString(layer_name,MagickPathExtent,""L%04ld"",(long)
              layer_count++);
            WritePascalString(image,layer_name,4);
          }
        else
          {
            size_t
              label_length;

            label_length=strlen(property);
            (void) WriteBlobMSBLong(image,(unsigned int) (label_length+(4-
              (label_length % 4))+8));
            (void) WriteBlobMSBLong(image,0);
            (void) WriteBlobMSBLong(image,0);
            WritePascalString(image,property,4);
          }
        next_image=GetNextImageInList(next_image);
      }
      /*
        Now the image data!
      */
      next_image=base_image;
      while (next_image != NULL)
      {
        status=WriteImageChannels(&psd_info,image_info,image,next_image,
          MagickTrue,exception);
        next_image=GetNextImageInList(next_image);
      }
      (void) WriteBlobMSBLong(image,0);  /* user mask data */
      base_image->compression=compression;
    }
  /*
    Write composite image.
  */
  if (status != MagickFalse)
    status=WriteImageChannels(&psd_info,image_info,image,image,MagickFalse,
      exception);
  (void) CloseBlob(image);
  return(status);
}","static MagickBooleanType WritePSDImage(const ImageInfo *VAR_0,
  Image *VAR_1,ExceptionInfo *VAR_2)
{
  const char
    *VAR_3;

  const StringInfo
    *VAR_4;

  Image
    *VAR_5,
    *VAR_6;

  MagickBooleanType
    VAR_7;

  PSDInfo
    VAR_8;

  register ssize_t
    VAR_9;

  size_t
    VAR_10,
    VAR_11,
    VAR_12,
    VAR_13,
    VAR_14,
    VAR_15,
    VAR_16,
    VAR_17;

  StringInfo
    *VAR_18;

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_19);
  assert(VAR_1 != (Image *) NULL);
  assert(VAR_1->signature == VAR_19);
  if (VAR_1->debug != VAR_20)
    (void) LogMagickEvent(VAR_21,GetMagickModule(),""%s"",VAR_1->filename);
  assert(VAR_2 != (ExceptionInfo *) NULL);
  assert(VAR_2->signature == VAR_19);
  VAR_7=OpenBlob(VAR_0,VAR_1,VAR_22,VAR_2);
  if (VAR_7 == VAR_20)
    return(VAR_7);
  VAR_16=(size_t) (VAR_1->depth > 8 ? 6 : 3);
  if (VAR_1->alpha_trait != VAR_23)
    VAR_16+=VAR_1->depth > 8 ? 2 : 1;
  VAR_8.version=1;
  if ((LocaleCompare(VAR_0->magick,""PSB"") == 0) ||
      (VAR_1->columns > 30000) || (VAR_1->rows > 30000))
    VAR_8.version=2;
  (void) WriteBlob(VAR_1,4,(const unsigned char *) ""8BPS"");
  (void) WriteBlobMSBShort(VAR_1,VAR_8.version);  /* COMMENT_3 */
  for (VAR_9=1; VAR_9 <= 6; VAR_9++)
    (void) WriteBlobByte(VAR_1, 0);  /* COMMENT_4 */
  if (SetImageGray(VAR_1,VAR_2) != VAR_20)
    VAR_15=(VAR_1->alpha_trait != VAR_23 ? 2UL : 1UL);
  else
    if ((VAR_0->type != VAR_24) && (VAR_0->type !=
         VAR_25) && (VAR_1->storage_class == VAR_26))
      VAR_15=(VAR_1->alpha_trait != VAR_23 ? 2UL : 1UL);
    else
      {
        if (VAR_1->storage_class == VAR_26)
          (void) SetImageStorageClass(VAR_1,VAR_27,VAR_2);
        if (VAR_1->colorspace != VAR_28)
          VAR_15=(VAR_1->alpha_trait != VAR_23 ? 4UL : 3UL);
        else
          VAR_15=(VAR_1->alpha_trait != VAR_23 ? 5UL : 4UL);
      }
  (void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_15);
  (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_1->rows);
  (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_1->columns);
  if (IsImageGray(VAR_1) != VAR_20)
    {
      MagickBooleanType
        VAR_29;

      /* COMMENT_5 */
                           
        
      VAR_29=IsImageMonochrome(VAR_1) && (VAR_1->depth == 1) ?
        VAR_30 : VAR_20;
      (void) WriteBlobMSBShort(VAR_1,(unsigned short)
        (VAR_29 != VAR_20 ? 1 : VAR_1->depth > 8 ? 16 : 8));
      (void) WriteBlobMSBShort(VAR_1,(unsigned short)
        (VAR_29 != VAR_20 ? VAR_31 : VAR_32));
    }
  else
    {
      (void) WriteBlobMSBShort(VAR_1,(unsigned short) (VAR_1->storage_class ==
        VAR_26 ? 8 : VAR_1->depth > 8 ? 16 : 8));

      if (((VAR_0->colorspace != VAR_33) ||
           (VAR_1->colorspace != VAR_28)) &&
          (VAR_0->colorspace != VAR_28))
        {
          (void) TransformImageColorspace(VAR_1,VAR_34,VAR_2);
          (void) WriteBlobMSBShort(VAR_1,(unsigned short)
            (VAR_1->storage_class == VAR_26 ? VAR_35 : VAR_36));
        }
      else
        {
          if (VAR_1->colorspace != VAR_28)
            (void) TransformImageColorspace(VAR_1,VAR_28,VAR_2);
          (void) WriteBlobMSBShort(VAR_1,VAR_37);
        }
    }
  if ((IsImageGray(VAR_1) != VAR_20) ||
      (VAR_1->storage_class == VAR_27) || (VAR_1->colors > 256))
    (void) WriteBlobMSBLong(VAR_1,0);
  else
    {
      /* COMMENT_8 */
                                  
        
      (void) WriteBlobMSBLong(VAR_1,768);
      for (VAR_9=0; VAR_9 < (ssize_t) VAR_1->colors; VAR_9++)
        (void) WriteBlobByte(VAR_1,ScaleQuantumToChar(VAR_1->colormap[VAR_9].red));
      for ( ; VAR_9 < 256; VAR_9++)
        (void) WriteBlobByte(VAR_1,0);
      for (VAR_9=0; VAR_9 < (ssize_t) VAR_1->colors; VAR_9++)
        (void) WriteBlobByte(VAR_1,ScaleQuantumToChar(
          VAR_1->colormap[VAR_9].green));
      for ( ; VAR_9 < 256; VAR_9++)
        (void) WriteBlobByte(VAR_1,0);
      for (VAR_9=0; VAR_9 < (ssize_t) VAR_1->colors; VAR_9++)
        (void) WriteBlobByte(VAR_1,ScaleQuantumToChar(VAR_1->colormap[VAR_9].blue));
      for ( ; VAR_9 < 256; VAR_9++)
        (void) WriteBlobByte(VAR_1,0);
    }
  /* COMMENT_11 */
                         
    
  VAR_14=28; /* COMMENT_14 */
  VAR_18=(StringInfo *) GetImageProfile(VAR_1,""8bim"");
  VAR_4=GetImageProfile(VAR_1,""icc"");
  if (VAR_18 != (StringInfo *) NULL)
    {
      VAR_18=CloneStringInfo(VAR_18);
      if (VAR_4 != (StringInfo *) NULL)
        RemoveICCProfileFromResourceBlock(VAR_18);
      RemoveResolutionFromResourceBlock(VAR_18);
      VAR_14+=PSDQuantum(GetStringInfoLength(VAR_18));
    }
  if (VAR_4 != (const StringInfo *) NULL)
    VAR_14+=PSDQuantum(GetStringInfoLength(VAR_4))+12;
  (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_14);
  WriteResolutionResourceBlock(VAR_1);
  if (VAR_18 != (StringInfo *) NULL)
    {
      (void) WriteBlob(VAR_1,GetStringInfoLength(VAR_18),
        GetStringInfoDatum(VAR_18));
      VAR_18=DestroyStringInfo(VAR_18);
    }
  if (VAR_4 != (StringInfo *) NULL)
    {
      (void) WriteBlob(VAR_1,4,(const unsigned char *) ""8BIM"");
      (void) WriteBlobMSBShort(VAR_1,0x0000040F);
      (void) WriteBlobMSBShort(VAR_1,0);
      (void) WriteBlobMSBLong(VAR_1,(unsigned int) GetStringInfoLength(
        VAR_4));
      (void) WriteBlob(VAR_1,GetStringInfoLength(VAR_4),
        GetStringInfoDatum(VAR_4));
      if ((MagickOffsetType) GetStringInfoLength(VAR_4) !=
          PSDQuantum(GetStringInfoLength(VAR_4)))
        (void) WriteBlobByte(VAR_1,0);
    }
  VAR_12=0;
  VAR_13=2;
  VAR_5=GetNextImageInList(VAR_1);
  if ((VAR_1->alpha_trait != VAR_23) && (VAR_5 == (Image *) NULL))
    VAR_5=VAR_1;
  VAR_6=VAR_5;
  while ( VAR_6 != NULL )
  {
    VAR_16=VAR_6->depth > 8 ? 2UL : 1UL;
    if (IsImageGray(VAR_6) != VAR_20)
      VAR_15=VAR_6->alpha_trait != VAR_23 ? 2UL : 1UL;
    else
      if (VAR_6->storage_class == VAR_26)
        VAR_15=VAR_6->alpha_trait != VAR_23 ? 2UL : 1UL;
      else
        if (VAR_6->colorspace != VAR_28)
          VAR_15=VAR_6->alpha_trait != VAR_23 ? 4UL : 3UL;
        else
          VAR_15=VAR_6->alpha_trait != VAR_23 ? 5UL : 4UL;
    VAR_11=(size_t) (VAR_6->columns*VAR_6->rows*VAR_16+2);
    VAR_13+=(size_t) (4*4+2+VAR_15*6+(VAR_8.version == 1 ? 8 :
      16)+4*1+4+VAR_15*VAR_11);
    VAR_3=(const char *) GetImageProperty(VAR_6,""label"",VAR_2);
    if (VAR_3 == (const char *) NULL)
      VAR_13+=16;
    else
      {
        size_t
          VAR_38;

        VAR_38=strlen(VAR_3);
        VAR_13+=8+VAR_38+(4-(VAR_38 % 4));
      }
    VAR_12++;
    VAR_6=GetNextImageInList(VAR_6);
  }
  if (VAR_12 == 0)
    (void) SetPSDSize(&VAR_8,VAR_1,0);
  else
    {
      CompressionType
        VAR_39;

      (void) SetPSDSize(&VAR_8,VAR_1,VAR_13+
        (VAR_8.version == 1 ? 8 : 16));
      if ((VAR_13/2) != ((VAR_13+1)/2))
        VAR_17=VAR_13+1;
      else
        VAR_17=VAR_13;
      (void) SetPSDSize(&VAR_8,VAR_1,VAR_17);
      if (VAR_1->alpha_trait != VAR_23)
        (void) WriteBlobMSBShort(VAR_1,-(unsigned short) VAR_12);
      else
        (void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_12);
      VAR_12=1;
      VAR_39=VAR_5->compression;
      for (VAR_6=VAR_5; VAR_6 != NULL; )
      {
        VAR_6->compression=VAR_40;
        (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_6->page.y);
        (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_6->page.x);
        (void) WriteBlobMSBLong(VAR_1,(unsigned int) (VAR_6->page.y+
          VAR_6->rows));
        (void) WriteBlobMSBLong(VAR_1,(unsigned int) (VAR_6->page.x+
          VAR_6->columns));
        VAR_16=VAR_6->depth > 8 ? 2UL : 1UL;
        VAR_10=(unsigned int) ((VAR_16*VAR_6->rows*
          VAR_6->columns)+2);
        if ((IsImageGray(VAR_6) != VAR_20) ||
            (VAR_6->storage_class == VAR_26))
          {
             (void) WriteBlobMSBShort(VAR_1,(unsigned short)
               (VAR_6->alpha_trait != VAR_23 ? 2 : 1));
             (void) WriteBlobMSBShort(VAR_1,0);
             (void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
             if (VAR_6->alpha_trait != VAR_23)
               {
                 (void) WriteBlobMSBShort(VAR_1,(unsigned short) -1);
                 (void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
               }
           }
          else
            if (VAR_6->colorspace != VAR_28)
              {
                (void) WriteBlobMSBShort(VAR_1,(unsigned short)
                  (VAR_6->alpha_trait != VAR_23 ? 4 : 3));
               (void) WriteBlobMSBShort(VAR_1,0);
               (void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
               (void) WriteBlobMSBShort(VAR_1,1);
               (void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
               (void) WriteBlobMSBShort(VAR_1,2);
               (void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
               if (VAR_6->alpha_trait != VAR_23)
                 {
                   (void) WriteBlobMSBShort(VAR_1,(unsigned short) -1);
                   (void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
                 }
             }
           else
             {
               (void) WriteBlobMSBShort(VAR_1,(unsigned short)
                 (VAR_6->alpha_trait ? 5 : 4));
               (void) WriteBlobMSBShort(VAR_1,0);
               (void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
               (void) WriteBlobMSBShort(VAR_1,1);
               (void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
               (void) WriteBlobMSBShort(VAR_1,2);
               (void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
               (void) WriteBlobMSBShort(VAR_1,3);
               (void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
               if (VAR_6->alpha_trait)
                 {
                   (void) WriteBlobMSBShort(VAR_1,(unsigned short) -1);
                   (void) SetPSDSize(&VAR_8,VAR_1,VAR_10);
                 }
             }
        (void) WriteBlob(VAR_1,4,(const unsigned char *) ""8BIM"");
        (void) WriteBlob(VAR_1,4,(const unsigned char *)
          CompositeOperatorToPSDBlendMode(VAR_6->compose));
        (void) WriteBlobByte(VAR_1,255); /* COMMENT_15 */
        (void) WriteBlobByte(VAR_1,0);
        (void) WriteBlobByte(VAR_1,VAR_6->compose==VAR_41 ?
          1 << 0x02 : 1); /* COMMENT_16 */
        (void) WriteBlobByte(VAR_1,0);
        VAR_3=(const char *) GetImageProperty(VAR_6,""label"",VAR_2);
        if (VAR_3 == (const char *) NULL)
          {
            char
              VAR_42[VAR_43];

            (void) WriteBlobMSBLong(VAR_1,16);
            (void) WriteBlobMSBLong(VAR_1,0);
            (void) WriteBlobMSBLong(VAR_1,0);
            (void) FormatLocaleString(VAR_42,VAR_43,""L%04ld"",(long)
              VAR_12++);
            WritePascalString(VAR_1,VAR_42,4);
          }
        else
          {
            size_t
              VAR_44;

            VAR_44=strlen(VAR_3);
            (void) WriteBlobMSBLong(VAR_1,(unsigned int) (VAR_44+(4-
              (VAR_44 % 4))+8));
            (void) WriteBlobMSBLong(VAR_1,0);
            (void) WriteBlobMSBLong(VAR_1,0);
            WritePascalString(VAR_1,VAR_3,4);
          }
        VAR_6=GetNextImageInList(VAR_6);
      }
      /* COMMENT_17 */
                           
        
      VAR_6=VAR_5;
      while (VAR_6 != NULL)
      {
        VAR_7=WriteImageChannels(&VAR_8,VAR_0,VAR_1,VAR_6,
          VAR_30,VAR_2);
        VAR_6=GetNextImageInList(VAR_6);
      }
      (void) WriteBlobMSBLong(VAR_1,0);  /* COMMENT_20 */
      VAR_5->compression=VAR_39;
    }
  /* COMMENT_21 */
                          
    
  if (VAR_7 != VAR_20)
    VAR_7=WriteImageChannels(&VAR_8,VAR_0,VAR_1,VAR_1,VAR_20,
      VAR_2);
  (void) CloseBlob(VAR_1);
  return(VAR_7);
}",ImageMagick/4f2c04ea6673863b87ac7f186cbb0d911f74085c/psd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
-static MagickBooleanType WritePSDImage(const ImageInfo *image_info,Image *image,
-  ExceptionInfo *exception)
+static MagickBooleanType WritePSDImage(const ImageInfo *image_info,
+  Image *image,ExceptionInfo *exception)
 {
   const char
     *property;","{'deleted_lines': ['static MagickBooleanType WritePSDImage(const ImageInfo *image_info,Image *image,', '  ExceptionInfo *exception)'], 'added_lines': ['static MagickBooleanType WritePSDImage(const ImageInfo *image_info,', '  Image *image,ExceptionInfo *exception)']}",True,coders/psd.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted PSD file.,6.5,MEDIUM,1,test,2016-02-02T20:35:45Z,1
CVE-2016-7532,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,Added check for out of bounds read (https://github.com/ImageMagick/ImageMagick/issues/108).,4f2c04ea6673863b87ac7f186cbb0d911f74085c,https://github.com/ImageMagick/ImageMagick/commit/4f2c04ea6673863b87ac7f186cbb0d911f74085c,coders/psd.c,RemoveResolutionFromResourceBlock,"static void RemoveResolutionFromResourceBlock(StringInfo *bim_profile)
{
register const unsigned char
*p;
size_t
length;
unsigned char
*datum;
unsigned int
count,
long_sans;
unsigned short
id,
short_sans;
length=GetStringInfoLength(bim_profile);
if (length < 16)
return;
datum=GetStringInfoDatum(bim_profile);
for (p=datum; (p >= datum) && (p < (datum+length-16)); )
{
register unsigned char
*q;
q=(unsigned char *) p;
if (LocaleNCompare((const char *) p,""8BIM"",4) != 0)
break;
p=PushLongPixel(MSBEndian,p,&long_sans);
p=PushShortPixel(MSBEndian,p,&id);
p=PushShortPixel(MSBEndian,p,&short_sans);
p=PushLongPixel(MSBEndian,p,&count);
if ((id == 0x000003ed) && (PSDQuantum(count) < (ssize_t) (length-12)))
{
(void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-
(PSDQuantum(count)+12)-(q-datum));
SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));
break;
}
p+=count;
if ((count & 0x01) != 0)
p++;
}
}","static void RemoveResolutionFromResourceBlock(StringInfo *VAR_0)
{
register const unsigned char
*VAR_1;
size_t
VAR_2;
unsigned char
*VAR_3;
unsigned int
VAR_4,
VAR_5;
unsigned short
VAR_6,
VAR_7;
VAR_2=GetStringInfoLength(VAR_0);
if (VAR_2 < 16)
return;
VAR_3=GetStringInfoDatum(VAR_0);
for (VAR_1=VAR_3; (VAR_1 >= VAR_3) && (VAR_1 < (VAR_3+VAR_2-16)); )
{
register unsigned char
*VAR_8;
VAR_8=(unsigned char *) VAR_1;
if (LocaleNCompare((const char *) VAR_1,""8BIM"",4) != 0)
break;
VAR_1=PushLongPixel(VAR_9,VAR_1,&VAR_5);
VAR_1=PushShortPixel(VAR_9,VAR_1,&VAR_6);
VAR_1=PushShortPixel(VAR_9,VAR_1,&VAR_7);
VAR_1=PushLongPixel(VAR_9,VAR_1,&VAR_4);
if ((VAR_6 == 0x000003ed) && (PSDQuantum(VAR_4) < (ssize_t) (VAR_2-12)))
{
(void) CopyMagickMemory(VAR_8,VAR_8+PSDQuantum(VAR_4)+12,VAR_2-
(PSDQuantum(VAR_4)+12)-(VAR_8-VAR_3));
SetStringInfoLength(VAR_0,VAR_2-(PSDQuantum(VAR_4)+12));
break;
}
VAR_1+=VAR_4;
if ((VAR_4 & 0x01) != 0)
VAR_1++;
}
}",ImageMagick/4f2c04ea6673863b87ac7f186cbb0d911f74085c/psd.c/vul/before/1.json,"static void RemoveResolutionFromResourceBlock(StringInfo *bim_profile)
{
  register const unsigned char
    *p;

  size_t
    length;

  unsigned char
    *datum;

  unsigned int
    count,
    long_sans;

  unsigned short
    id,
    short_sans;

  length=GetStringInfoLength(bim_profile);
  if (length < 16)
    return;
  datum=GetStringInfoDatum(bim_profile);
  for (p=datum; (p >= datum) && (p < (datum+length-16)); )
  {
    register unsigned char
      *q;

    ssize_t
      cnt;

    q=(unsigned char *) p;
    if (LocaleNCompare((const char *) p,""8BIM"",4) != 0)
      return;
    p=PushLongPixel(MSBEndian,p,&long_sans);
    p=PushShortPixel(MSBEndian,p,&id);
    p=PushShortPixel(MSBEndian,p,&short_sans);
    p=PushLongPixel(MSBEndian,p,&count);
    cnt=PSDQuantum(count);
    if (cnt < 0)
      return;
    if ((id == 0x000003ed) && (cnt < (ssize_t) (length-12)))
      {
        (void) CopyMagickMemory(q,q+cnt+12,length-(cnt+12)-(q-datum));
        SetStringInfoLength(bim_profile,length-(cnt+12));
        break;
      }
    p+=count;
    if ((count & 0x01) != 0)
      p++;
  }
}","static void RemoveResolutionFromResourceBlock(StringInfo *VAR_0)
{
  register const unsigned char
    *VAR_1;

  size_t
    VAR_2;

  unsigned char
    *VAR_3;

  unsigned int
    VAR_4,
    VAR_5;

  unsigned short
    VAR_6,
    VAR_7;

  VAR_2=GetStringInfoLength(VAR_0);
  if (VAR_2 < 16)
    return;
  VAR_3=GetStringInfoDatum(VAR_0);
  for (VAR_1=VAR_3; (VAR_1 >= VAR_3) && (VAR_1 < (VAR_3+VAR_2-16)); )
  {
    register unsigned char
      *VAR_8;

    ssize_t
      VAR_9;

    VAR_8=(unsigned char *) VAR_1;
    if (LocaleNCompare((const char *) VAR_1,""8BIM"",4) != 0)
      return;
    VAR_1=PushLongPixel(VAR_10,VAR_1,&VAR_5);
    VAR_1=PushShortPixel(VAR_10,VAR_1,&VAR_6);
    VAR_1=PushShortPixel(VAR_10,VAR_1,&VAR_7);
    VAR_1=PushLongPixel(VAR_10,VAR_1,&VAR_4);
    VAR_9=PSDQuantum(VAR_4);
    if (VAR_9 < 0)
      return;
    if ((VAR_6 == 0x000003ed) && (VAR_9 < (ssize_t) (VAR_2-12)))
      {
        (void) CopyMagickMemory(VAR_8,VAR_8+VAR_9+12,VAR_2-(VAR_9+12)-(VAR_8-VAR_3));
        SetStringInfoLength(VAR_0,VAR_2-(VAR_9+12));
        break;
      }
    VAR_1+=VAR_4;
    if ((VAR_4 & 0x01) != 0)
      VAR_1++;
  }
}",ImageMagick/4f2c04ea6673863b87ac7f186cbb0d911f74085c/psd.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -26,18 +26,23 @@
     register unsigned char
       *q;
 
+    ssize_t
+      cnt;
+
     q=(unsigned char *) p;
     if (LocaleNCompare((const char *) p,""8BIM"",4) != 0)
-      break;
+      return;
     p=PushLongPixel(MSBEndian,p,&long_sans);
     p=PushShortPixel(MSBEndian,p,&id);
     p=PushShortPixel(MSBEndian,p,&short_sans);
     p=PushLongPixel(MSBEndian,p,&count);
-    if ((id == 0x000003ed) && (PSDQuantum(count) < (ssize_t) (length-12)))
+    cnt=PSDQuantum(count);
+    if (cnt < 0)
+      return;
+    if ((id == 0x000003ed) && (cnt < (ssize_t) (length-12)))
       {
-        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-
-          (PSDQuantum(count)+12)-(q-datum));
-        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));
+        (void) CopyMagickMemory(q,q+cnt+12,length-(cnt+12)-(q-datum));
+        SetStringInfoLength(bim_profile,length-(cnt+12));
         break;
       }
     p+=count;","{'deleted_lines': ['      break;', '    if ((id == 0x000003ed) && (PSDQuantum(count) < (ssize_t) (length-12)))', '        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-', '          (PSDQuantum(count)+12)-(q-datum));', '        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));'], 'added_lines': ['    ssize_t', '      cnt;', '', '      return;', '    cnt=PSDQuantum(count);', '    if (cnt < 0)', '      return;', '    if ((id == 0x000003ed) && (cnt < (ssize_t) (length-12)))', '        (void) CopyMagickMemory(q,q+cnt+12,length-(cnt+12)-(q-datum));', '        SetStringInfoLength(bim_profile,length-(cnt+12));']}",True,coders/psd.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted PSD file.,6.5,MEDIUM,1,test,2016-02-02T20:35:45Z,1
CVE-2016-3178,['CWE-125'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,miniupnp,minissdpd: Fix broken overflow test (p+l > buf+n) thanks to Salva Piero,b238cade9a173c6f751a34acf8ccff838a62aa47,https://github.com/miniupnp/miniupnp/commit/b238cade9a173c6f751a34acf8ccff838a62aa47,minissdpd/minissdpd.c,processRequest,"void processRequest(struct reqelem * req)
{
ssize_t n;
unsigned int l, m;
unsigned char buf[2048];
const unsigned char * p;
enum request_type type;
struct device * d = devlist;
unsigned char rbuf[RESPONSE_BUFFER_SIZE];
unsigned char * rp;
unsigned char nrep = 0;
time_t t;
struct service * newserv = NULL;
struct service * serv;
n = read(req->socket, buf, sizeof(buf));
if(n<0) {
if(errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK)
return;
syslog(LOG_ERR, ""(s=%d) processRequest(): read(): %m"", req->socket);
goto error;
}
if(n==0) {
syslog(LOG_INFO, ""(s=%d) request connection closed"", req->socket);
goto error;
}
t = time(NULL);
type = buf[0];
p = buf + 1;
DECODELENGTH_CHECKLIMIT(l, p, buf + n);
if(p+l > buf+n) {
syslog(LOG_WARNING, ""bad request (length encoding l=%u n=%u)"",
l, (unsigned)n);
goto error;
}
if(l == 0 && type != MINISSDPD_SEARCH_ALL
&& type != MINISSDPD_GET_VERSION && type != MINISSDPD_NOTIF) {
syslog(LOG_WARNING, ""bad request (length=0, type=%d)"", type);
goto error;
}
syslog(LOG_INFO, ""(s=%d) request type=%d str='%.*s'"",
req->socket, type, l, p);
switch(type) {
case MINISSDPD_GET_VERSION:
rp = rbuf;
CODELENGTH((sizeof(MINISSDPD_VERSION) - 1), rp);
memcpy(rp, MINISSDPD_VERSION, sizeof(MINISSDPD_VERSION) - 1);
rp += (sizeof(MINISSDPD_VERSION) - 1);
if(write_or_buffer(req, rbuf, rp - rbuf) < 0) {
syslog(LOG_ERR, ""(s=%d) write: %m"", req->socket);
goto error;
}
break;
case MINISSDPD_SEARCH_TYPE:
case MINISSDPD_SEARCH_USN:
case MINISSDPD_SEARCH_ALL:
rp = rbuf+1;
while(d && (nrep < 255)) {
if(d->t < t) {
syslog(LOG_INFO, ""outdated device"");
} else {
if(d->headers[HEADER_LOCATION].l + d->headers[HEADER_NT].l
+ d->headers[HEADER_USN].l + 6
+ (rp - rbuf) >= (int)sizeof(rbuf))
break;
if( (type==MINISSDPD_SEARCH_TYPE && 0==memcmp(d->headers[HEADER_NT].p, p, l))
||(type==MINISSDPD_SEARCH_USN && 0==memcmp(d->headers[HEADER_USN].p, p, l))
||(type==MINISSDPD_SEARCH_ALL) ) {
m = d->headers[HEADER_LOCATION].l;
CODELENGTH(m, rp);
memcpy(rp, d->headers[HEADER_LOCATION].p, d->headers[HEADER_LOCATION].l);
rp += d->headers[HEADER_LOCATION].l;
m = d->headers[HEADER_NT].l;
CODELENGTH(m, rp);
memcpy(rp, d->headers[HEADER_NT].p, d->headers[HEADER_NT].l);
rp += d->headers[HEADER_NT].l;
m = d->headers[HEADER_USN].l;
CODELENGTH(m, rp);
memcpy(rp, d->headers[HEADER_USN].p, d->headers[HEADER_USN].l);
rp += d->headers[HEADER_USN].l;
nrep++;
}
}
d = d->next;
}
for(serv = servicelisthead.lh_first;
serv && (nrep < 255);
serv = serv->entries.le_next) {
if(strlen(serv->location) + strlen(serv->st)
+ strlen(serv->usn) + 6 + (rp - rbuf) >= sizeof(rbuf))
break;
if( (type==MINISSDPD_SEARCH_TYPE && 0==strncmp(serv->st, (const char *)p, l))
||(type==MINISSDPD_SEARCH_USN && 0==strncmp(serv->usn, (const char *)p, l))
||(type==MINISSDPD_SEARCH_ALL) ) {
m = strlen(serv->location);
CODELENGTH(m, rp);
memcpy(rp, serv->location, m);
rp += m;
m = strlen(serv->st);
CODELENGTH(m, rp);
memcpy(rp, serv->st, m);
rp += m;
m = strlen(serv->usn);
CODELENGTH(m, rp);
memcpy(rp, serv->usn, m);
rp += m;
nrep++;
}
}
rbuf[0] = nrep;
syslog(LOG_DEBUG, ""(s=%d) response : %d device%s"",
req->socket, nrep, (nrep > 1) ? ""s"" : """");
if(write_or_buffer(req, rbuf, rp - rbuf) < 0) {
syslog(LOG_ERR, ""(s=%d) write: %m"", req->socket);
goto error;
}
break;
case MINISSDPD_SUBMIT:
newserv = malloc(sizeof(struct service));
if(!newserv) {
syslog(LOG_ERR, ""cannot allocate memory"");
goto error;
}
memset(newserv, 0, sizeof(struct service));
if(containsForbiddenChars(p, l)) {
syslog(LOG_ERR, ""bad request (st contains forbidden chars)"");
goto error;
}
newserv->st = malloc(l + 1);
if(!newserv->st) {
syslog(LOG_ERR, ""cannot allocate memory"");
goto error;
}
memcpy(newserv->st, p, l);
newserv->st[l] = '\0';
p += l;
if(p >= buf + n) {
syslog(LOG_WARNING, ""bad request (missing usn)"");
goto error;
}
DECODELENGTH_CHECKLIMIT(l, p, buf + n);
if(p+l > buf+n) {
syslog(LOG_WARNING, ""bad request (length encoding)"");
goto error;
}
if(containsForbiddenChars(p, l)) {
syslog(LOG_ERR, ""bad request (usn contains forbidden chars)"");
goto error;
}
syslog(LOG_INFO, ""usn='%.*s'"", l, p);
newserv->usn = malloc(l + 1);
if(!newserv->usn) {
syslog(LOG_ERR, ""cannot allocate memory"");
goto error;
}
memcpy(newserv->usn, p, l);
newserv->usn[l] = '\0';
p += l;
DECODELENGTH_CHECKLIMIT(l, p, buf + n);
if(p+l > buf+n) {
syslog(LOG_WARNING, ""bad request (length encoding)"");
goto error;
}
if(containsForbiddenChars(p, l)) {
syslog(LOG_ERR, ""bad request (server contains forbidden chars)"");
goto error;
}
syslog(LOG_INFO, ""server='%.*s'"", l, p);
newserv->server = malloc(l + 1);
if(!newserv->server) {
syslog(LOG_ERR, ""cannot allocate memory"");
goto error;
}
memcpy(newserv->server, p, l);
newserv->server[l] = '\0';
p += l;
DECODELENGTH_CHECKLIMIT(l, p, buf + n);
if(p+l > buf+n) {
syslog(LOG_WARNING, ""bad request (length encoding)"");
goto error;
}
if(containsForbiddenChars(p, l)) {
syslog(LOG_ERR, ""bad request (location contains forbidden chars)"");
goto error;
}
syslog(LOG_INFO, ""location='%.*s'"", l, p);
newserv->location = malloc(l + 1);
if(!newserv->location) {
syslog(LOG_ERR, ""cannot allocate memory"");
goto error;
}
memcpy(newserv->location, p, l);
newserv->location[l] = '\0';
for(serv = servicelisthead.lh_first;
serv;
serv = serv->entries.le_next) {
if(0 == strcmp(newserv->usn, serv->usn)
&& 0 == strcmp(newserv->st, serv->st)) {
syslog(LOG_INFO, ""Service already in the list. Updating..."");
free(newserv->st);
free(newserv->usn);
free(serv->server);
serv->server = newserv->server;
free(serv->location);
serv->location = newserv->location;
free(newserv);
newserv = NULL;
return;
}
}
LIST_INSERT_HEAD(&servicelisthead, newserv, entries);
sendNotifications(NOTIF_NEW, NULL, newserv);
newserv = NULL;
break;
case MINISSDPD_NOTIF:
rbuf[0] = '\0';
if(write_or_buffer(req, rbuf, 1) < 0) {
syslog(LOG_ERR, ""(s=%d) write: %m"", req->socket);
goto error;
}
req->is_notify = 1;
break;
default:
syslog(LOG_WARNING, ""Unknown request type %d"", type);
rbuf[0] = '\0';
if(write_or_buffer(req, rbuf, 1) < 0) {
syslog(LOG_ERR, ""(s=%d) write: %m"", req->socket);
goto error;
}
}
return;
error:
if(newserv) {
free(newserv->st);
free(newserv->usn);
free(newserv->server);
free(newserv->location);
free(newserv);
newserv = NULL;
}
close(req->socket);
req->socket = -1;
return;
}","void processRequest(struct reqelem * VAR_0)
{
ssize_t VAR_1;
unsigned int VAR_2, VAR_3;
unsigned char VAR_4[2048];
const unsigned char * VAR_5;
enum request_type VAR_6;
struct device * VAR_7 = VAR_8;
unsigned char VAR_9[VAR_10];
unsigned char * VAR_11;
unsigned char VAR_12 = 0;
time_t VAR_13;
struct service * VAR_14 = NULL;
struct service * VAR_15;
VAR_1 = read(VAR_0->socket, VAR_4, sizeof(VAR_4));
if(VAR_1<0) {
if(VAR_16 == VAR_17 || VAR_16 == VAR_18 || VAR_16 == VAR_19)
return;
syslog(VAR_20, ""(s=%d) processRequest(): read(): %m"", VAR_0->socket);
goto error;
}
if(VAR_1==0) {
syslog(VAR_21, ""(s=%d) request connection closed"", VAR_0->socket);
goto error;
}
VAR_13 = time(NULL);
VAR_6 = VAR_4[0];
VAR_5 = VAR_4 + 1;
DECODELENGTH_CHECKLIMIT(VAR_2, VAR_5, VAR_4 + VAR_1);
if(VAR_5+VAR_2 > VAR_4+VAR_1) {
syslog(VAR_22, ""bad request (length encoding l=%u n=%u)"",
VAR_2, (unsigned)VAR_1);
goto error;
}
if(VAR_2 == 0 && VAR_6 != VAR_23
&& VAR_6 != VAR_24 && VAR_6 != VAR_25) {
syslog(VAR_22, ""bad request (length=0, type=%d)"", VAR_6);
goto error;
}
syslog(VAR_21, ""(s=%d) request type=%d str='%.*s'"",
VAR_0->socket, VAR_6, VAR_2, VAR_5);
switch(VAR_6) {
case VAR_24:
VAR_11 = VAR_9;
CODELENGTH((sizeof(VAR_26) - 1), VAR_11);
memcpy(VAR_11, VAR_26, sizeof(VAR_26) - 1);
VAR_11 += (sizeof(VAR_26) - 1);
if(write_or_buffer(VAR_0, VAR_9, VAR_11 - VAR_9) < 0) {
syslog(VAR_20, ""(s=%d) write: %m"", VAR_0->socket);
goto error;
}
break;
case VAR_27:
case VAR_28:
case VAR_23:
VAR_11 = VAR_9+1;
while(VAR_7 && (VAR_12 < 255)) {
if(VAR_7->t < VAR_13) {
syslog(VAR_21, ""outdated device"");
} else {
if(VAR_7->headers[VAR_29].l + VAR_7->headers[VAR_30].l
+ VAR_7->headers[VAR_31].l + 6
+ (VAR_11 - VAR_9) >= (int)sizeof(VAR_9))
break;
if( (VAR_6==VAR_27 && 0==memcmp(VAR_7->headers[VAR_30].p, VAR_5, VAR_2))
||(VAR_6==VAR_28 && 0==memcmp(VAR_7->headers[VAR_31].p, VAR_5, VAR_2))
||(VAR_6==VAR_23) ) {
VAR_3 = VAR_7->headers[VAR_29].l;
CODELENGTH(VAR_3, VAR_11);
memcpy(VAR_11, VAR_7->headers[VAR_29].p, VAR_7->headers[VAR_29].l);
VAR_11 += VAR_7->headers[VAR_29].l;
VAR_3 = VAR_7->headers[VAR_30].l;
CODELENGTH(VAR_3, VAR_11);
memcpy(VAR_11, VAR_7->headers[VAR_30].p, VAR_7->headers[VAR_30].l);
VAR_11 += VAR_7->headers[VAR_30].l;
VAR_3 = VAR_7->headers[VAR_31].l;
CODELENGTH(VAR_3, VAR_11);
memcpy(VAR_11, VAR_7->headers[VAR_31].p, VAR_7->headers[VAR_31].l);
VAR_11 += VAR_7->headers[VAR_31].l;
VAR_12++;
}
}
VAR_7 = VAR_7->next;
}
for(VAR_15 = VAR_32.lh_first;
VAR_15 && (VAR_12 < 255);
VAR_15 = VAR_15->entries.le_next) {
if(strlen(VAR_15->location) + strlen(VAR_15->st)
+ strlen(VAR_15->usn) + 6 + (VAR_11 - VAR_9) >= sizeof(VAR_9))
break;
if( (VAR_6==VAR_27 && 0==strncmp(VAR_15->st, (const char *)VAR_5, VAR_2))
||(VAR_6==VAR_28 && 0==strncmp(VAR_15->usn, (const char *)VAR_5, VAR_2))
||(VAR_6==VAR_23) ) {
VAR_3 = strlen(VAR_15->location);
CODELENGTH(VAR_3, VAR_11);
memcpy(VAR_11, VAR_15->location, VAR_3);
VAR_11 += VAR_3;
VAR_3 = strlen(VAR_15->st);
CODELENGTH(VAR_3, VAR_11);
memcpy(VAR_11, VAR_15->st, VAR_3);
VAR_11 += VAR_3;
VAR_3 = strlen(VAR_15->usn);
CODELENGTH(VAR_3, VAR_11);
memcpy(VAR_11, VAR_15->usn, VAR_3);
VAR_11 += VAR_3;
VAR_12++;
}
}
VAR_9[0] = VAR_12;
syslog(VAR_33, ""(s=%d) response : %d device%s"",
VAR_0->socket, VAR_12, (VAR_12 > 1) ? ""s"" : """");
if(write_or_buffer(VAR_0, VAR_9, VAR_11 - VAR_9) < 0) {
syslog(VAR_20, ""(s=%d) write: %m"", VAR_0->socket);
goto error;
}
break;
case VAR_34:
VAR_14 = malloc(sizeof(struct service));
if(!VAR_14) {
syslog(VAR_20, ""cannot allocate memory"");
goto error;
}
memset(VAR_14, 0, sizeof(struct service));
if(containsForbiddenChars(VAR_5, VAR_2)) {
syslog(VAR_20, ""bad request (st contains forbidden chars)"");
goto error;
}
VAR_14->st = malloc(VAR_2 + 1);
if(!VAR_14->st) {
syslog(VAR_20, ""cannot allocate memory"");
goto error;
}
memcpy(VAR_14->st, VAR_5, VAR_2);
VAR_14->st[VAR_2] = '\0';
VAR_5 += VAR_2;
if(VAR_5 >= VAR_4 + VAR_1) {
syslog(VAR_22, ""bad request (missing usn)"");
goto error;
}
DECODELENGTH_CHECKLIMIT(VAR_2, VAR_5, VAR_4 + VAR_1);
if(VAR_5+VAR_2 > VAR_4+VAR_1) {
syslog(VAR_22, ""bad request (length encoding)"");
goto error;
}
if(containsForbiddenChars(VAR_5, VAR_2)) {
syslog(VAR_20, ""bad request (usn contains forbidden chars)"");
goto error;
}
syslog(VAR_21, ""usn='%.*s'"", VAR_2, VAR_5);
VAR_14->usn = malloc(VAR_2 + 1);
if(!VAR_14->usn) {
syslog(VAR_20, ""cannot allocate memory"");
goto error;
}
memcpy(VAR_14->usn, VAR_5, VAR_2);
VAR_14->usn[VAR_2] = '\0';
VAR_5 += VAR_2;
DECODELENGTH_CHECKLIMIT(VAR_2, VAR_5, VAR_4 + VAR_1);
if(VAR_5+VAR_2 > VAR_4+VAR_1) {
syslog(VAR_22, ""bad request (length encoding)"");
goto error;
}
if(containsForbiddenChars(VAR_5, VAR_2)) {
syslog(VAR_20, ""bad request (server contains forbidden chars)"");
goto error;
}
syslog(VAR_21, ""server='%.*s'"", VAR_2, VAR_5);
VAR_14->server = malloc(VAR_2 + 1);
if(!VAR_14->server) {
syslog(VAR_20, ""cannot allocate memory"");
goto error;
}
memcpy(VAR_14->server, VAR_5, VAR_2);
VAR_14->server[VAR_2] = '\0';
VAR_5 += VAR_2;
DECODELENGTH_CHECKLIMIT(VAR_2, VAR_5, VAR_4 + VAR_1);
if(VAR_5+VAR_2 > VAR_4+VAR_1) {
syslog(VAR_22, ""bad request (length encoding)"");
goto error;
}
if(containsForbiddenChars(VAR_5, VAR_2)) {
syslog(VAR_20, ""bad request (location contains forbidden chars)"");
goto error;
}
syslog(VAR_21, ""location='%.*s'"", VAR_2, VAR_5);
VAR_14->location = malloc(VAR_2 + 1);
if(!VAR_14->location) {
syslog(VAR_20, ""cannot allocate memory"");
goto error;
}
memcpy(VAR_14->location, VAR_5, VAR_2);
VAR_14->location[VAR_2] = '\0';
for(VAR_15 = VAR_32.lh_first;
VAR_15;
VAR_15 = VAR_15->entries.le_next) {
if(0 == strcmp(VAR_14->usn, VAR_15->usn)
&& 0 == strcmp(VAR_14->st, VAR_15->st)) {
syslog(VAR_21, ""Service already in the list. Updating..."");
free(VAR_14->st);
free(VAR_14->usn);
free(VAR_15->server);
VAR_15->server = VAR_14->server;
free(VAR_15->location);
VAR_15->location = VAR_14->location;
free(VAR_14);
VAR_14 = NULL;
return;
}
}
LIST_INSERT_HEAD(&VAR_32, VAR_14, VAR_35);
sendNotifications(VAR_36, NULL, VAR_14);
VAR_14 = NULL;
break;
case VAR_25:
VAR_9[0] = '\0';
if(write_or_buffer(VAR_0, VAR_9, 1) < 0) {
syslog(VAR_20, ""(s=%d) write: %m"", VAR_0->socket);
goto error;
}
VAR_0->is_notify = 1;
break;
default:
syslog(VAR_22, ""Unknown request type %d"", VAR_6);
VAR_9[0] = '\0';
if(write_or_buffer(VAR_0, VAR_9, 1) < 0) {
syslog(VAR_20, ""(s=%d) write: %m"", VAR_0->socket);
goto error;
}
}
return;
error:
if(VAR_14) {
free(VAR_14->st);
free(VAR_14->usn);
free(VAR_14->server);
free(VAR_14->location);
free(VAR_14);
VAR_14 = NULL;
}
close(VAR_0->socket);
VAR_0->socket = -1;
return;
}",miniupnp/b238cade9a173c6f751a34acf8ccff838a62aa47/minissdpd.c/vul/before/0.json,"void processRequest(struct reqelem * req)
{
	ssize_t n;
	unsigned int l, m;
	unsigned char buf[2048];
	const unsigned char * p;
	enum request_type type;
	struct device * d = devlist;
	unsigned char rbuf[RESPONSE_BUFFER_SIZE];
	unsigned char * rp;
	unsigned char nrep = 0;
	time_t t;
	struct service * newserv = NULL;
	struct service * serv;

	n = read(req->socket, buf, sizeof(buf));
	if(n<0) {
		if(errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK)
			return;	/* try again later */
		syslog(LOG_ERR, ""(s=%d) processRequest(): read(): %m"", req->socket);
		goto error;
	}
	if(n==0) {
		syslog(LOG_INFO, ""(s=%d) request connection closed"", req->socket);
		goto error;
	}
	t = time(NULL);
	type = buf[0];
	p = buf + 1;
	DECODELENGTH_CHECKLIMIT(l, p, buf + n);
	if(l > (unsigned)(buf+n-p)) {
		syslog(LOG_WARNING, ""bad request (length encoding l=%u n=%u)"",
		       l, (unsigned)n);
		goto error;
	}
	if(l == 0 && type != MINISSDPD_SEARCH_ALL
	   && type != MINISSDPD_GET_VERSION && type != MINISSDPD_NOTIF) {
		syslog(LOG_WARNING, ""bad request (length=0, type=%d)"", type);
		goto error;
	}
	syslog(LOG_INFO, ""(s=%d) request type=%d str='%.*s'"",
	       req->socket, type, l, p);
	switch(type) {
	case MINISSDPD_GET_VERSION:
		rp = rbuf;
		CODELENGTH((sizeof(MINISSDPD_VERSION) - 1), rp);
		memcpy(rp, MINISSDPD_VERSION, sizeof(MINISSDPD_VERSION) - 1);
		rp += (sizeof(MINISSDPD_VERSION) - 1);
		if(write_or_buffer(req, rbuf, rp - rbuf) < 0) {
			syslog(LOG_ERR, ""(s=%d) write: %m"", req->socket);
			goto error;
		}
		break;
	case MINISSDPD_SEARCH_TYPE:	/* request by type */
	case MINISSDPD_SEARCH_USN:	/* request by USN (unique id) */
	case MINISSDPD_SEARCH_ALL:	/* everything */
		rp = rbuf+1;
		while(d && (nrep < 255)) {
			if(d->t < t) {
				syslog(LOG_INFO, ""outdated device"");
			} else {
				/* test if we can put more responses in the buffer */
				if(d->headers[HEADER_LOCATION].l + d->headers[HEADER_NT].l
				  + d->headers[HEADER_USN].l + 6
				  + (rp - rbuf) >= (int)sizeof(rbuf))
					break;
				if( (type==MINISSDPD_SEARCH_TYPE && 0==memcmp(d->headers[HEADER_NT].p, p, l))
				  ||(type==MINISSDPD_SEARCH_USN && 0==memcmp(d->headers[HEADER_USN].p, p, l))
				  ||(type==MINISSDPD_SEARCH_ALL) ) {
					/* response :
					 * 1 - Location
					 * 2 - NT (device/service type)
					 * 3 - usn */
					m = d->headers[HEADER_LOCATION].l;
					CODELENGTH(m, rp);
					memcpy(rp, d->headers[HEADER_LOCATION].p, d->headers[HEADER_LOCATION].l);
					rp += d->headers[HEADER_LOCATION].l;
					m = d->headers[HEADER_NT].l;
					CODELENGTH(m, rp);
					memcpy(rp, d->headers[HEADER_NT].p, d->headers[HEADER_NT].l);
					rp += d->headers[HEADER_NT].l;
					m = d->headers[HEADER_USN].l;
					CODELENGTH(m, rp);
					memcpy(rp, d->headers[HEADER_USN].p, d->headers[HEADER_USN].l);
					rp += d->headers[HEADER_USN].l;
					nrep++;
				}
			}
			d = d->next;
		}
		/* Also look in service list */
		for(serv = servicelisthead.lh_first;
		    serv && (nrep < 255);
		    serv = serv->entries.le_next) {
			/* test if we can put more responses in the buffer */
			if(strlen(serv->location) + strlen(serv->st)
			  + strlen(serv->usn) + 6 + (rp - rbuf) >= sizeof(rbuf))
			  	break;
			if( (type==MINISSDPD_SEARCH_TYPE && 0==strncmp(serv->st, (const char *)p, l))
			  ||(type==MINISSDPD_SEARCH_USN && 0==strncmp(serv->usn, (const char *)p, l))
			  ||(type==MINISSDPD_SEARCH_ALL) ) {
				/* response :
				 * 1 - Location
				 * 2 - NT (device/service type)
				 * 3 - usn */
				m = strlen(serv->location);
				CODELENGTH(m, rp);
				memcpy(rp, serv->location, m);
				rp += m;
				m = strlen(serv->st);
				CODELENGTH(m, rp);
				memcpy(rp, serv->st, m);
				rp += m;
				m = strlen(serv->usn);
				CODELENGTH(m, rp);
				memcpy(rp, serv->usn, m);
				rp += m;
				nrep++;
			}
		}
		rbuf[0] = nrep;
		syslog(LOG_DEBUG, ""(s=%d) response : %d device%s"",
		       req->socket, nrep, (nrep > 1) ? ""s"" : """");
		if(write_or_buffer(req, rbuf, rp - rbuf) < 0) {
			syslog(LOG_ERR, ""(s=%d) write: %m"", req->socket);
			goto error;
		}
		break;
	case MINISSDPD_SUBMIT:	/* submit service */
		newserv = malloc(sizeof(struct service));
		if(!newserv) {
			syslog(LOG_ERR, ""cannot allocate memory"");
			goto error;
		}
		memset(newserv, 0, sizeof(struct service));	/* set pointers to NULL */
		if(containsForbiddenChars(p, l)) {
			syslog(LOG_ERR, ""bad request (st contains forbidden chars)"");
			goto error;
		}
		newserv->st = malloc(l + 1);
		if(!newserv->st) {
			syslog(LOG_ERR, ""cannot allocate memory"");
			goto error;
		}
		memcpy(newserv->st, p, l);
		newserv->st[l] = '\0';
		p += l;
		if(p >= buf + n) {
			syslog(LOG_WARNING, ""bad request (missing usn)"");
			goto error;
		}
		DECODELENGTH_CHECKLIMIT(l, p, buf + n);
		if(l > (unsigned)(buf+n-p)) {
			syslog(LOG_WARNING, ""bad request (length encoding)"");
			goto error;
		}
		if(containsForbiddenChars(p, l)) {
			syslog(LOG_ERR, ""bad request (usn contains forbidden chars)"");
			goto error;
		}
		syslog(LOG_INFO, ""usn='%.*s'"", l, p);
		newserv->usn = malloc(l + 1);
		if(!newserv->usn) {
			syslog(LOG_ERR, ""cannot allocate memory"");
			goto error;
		}
		memcpy(newserv->usn, p, l);
		newserv->usn[l] = '\0';
		p += l;
		DECODELENGTH_CHECKLIMIT(l, p, buf + n);
		if(l > (unsigned)(buf+n-p)) {
			syslog(LOG_WARNING, ""bad request (length encoding)"");
			goto error;
		}
		if(containsForbiddenChars(p, l)) {
			syslog(LOG_ERR, ""bad request (server contains forbidden chars)"");
			goto error;
		}
		syslog(LOG_INFO, ""server='%.*s'"", l, p);
		newserv->server = malloc(l + 1);
		if(!newserv->server) {
			syslog(LOG_ERR, ""cannot allocate memory"");
			goto error;
		}
		memcpy(newserv->server, p, l);
		newserv->server[l] = '\0';
		p += l;
		DECODELENGTH_CHECKLIMIT(l, p, buf + n);
		if(l > (unsigned)(buf+n-p)) {
			syslog(LOG_WARNING, ""bad request (length encoding)"");
			goto error;
		}
		if(containsForbiddenChars(p, l)) {
			syslog(LOG_ERR, ""bad request (location contains forbidden chars)"");
			goto error;
		}
		syslog(LOG_INFO, ""location='%.*s'"", l, p);
		newserv->location = malloc(l + 1);
		if(!newserv->location) {
			syslog(LOG_ERR, ""cannot allocate memory"");
			goto error;
		}
		memcpy(newserv->location, p, l);
		newserv->location[l] = '\0';
		/* look in service list for duplicate */
		for(serv = servicelisthead.lh_first;
		    serv;
		    serv = serv->entries.le_next) {
			if(0 == strcmp(newserv->usn, serv->usn)
			  && 0 == strcmp(newserv->st, serv->st)) {
				syslog(LOG_INFO, ""Service already in the list. Updating..."");
				free(newserv->st);
				free(newserv->usn);
				free(serv->server);
				serv->server = newserv->server;
				free(serv->location);
				serv->location = newserv->location;
				free(newserv);
				newserv = NULL;
				return;
			}
		}
		/* Inserting new service */
		LIST_INSERT_HEAD(&servicelisthead, newserv, entries);
		sendNotifications(NOTIF_NEW, NULL, newserv);
		newserv = NULL;
		break;
	case MINISSDPD_NOTIF:	/* switch socket to notify */
		rbuf[0] = '\0';
		if(write_or_buffer(req, rbuf, 1) < 0) {
			syslog(LOG_ERR, ""(s=%d) write: %m"", req->socket);
			goto error;
		}
		req->is_notify = 1;
		break;
	default:
		syslog(LOG_WARNING, ""Unknown request type %d"", type);
		rbuf[0] = '\0';
		if(write_or_buffer(req, rbuf, 1) < 0) {
			syslog(LOG_ERR, ""(s=%d) write: %m"", req->socket);
			goto error;
		}
	}
	return;
error:
	if(newserv) {
		free(newserv->st);
		free(newserv->usn);
		free(newserv->server);
		free(newserv->location);
		free(newserv);
		newserv = NULL;
	}
	close(req->socket);
	req->socket = -1;
	return;
}","void processRequest(struct reqelem * VAR_0)
{
	ssize_t VAR_1;
	unsigned int VAR_2, VAR_3;
	unsigned char VAR_4[2048];
	const unsigned char * VAR_5;
	enum request_type VAR_6;
	struct device * VAR_7 = VAR_8;
	unsigned char VAR_9[VAR_10];
	unsigned char * VAR_11;
	unsigned char VAR_12 = 0;
	time_t VAR_13;
	struct service * VAR_14 = NULL;
	struct service * VAR_15;

	VAR_1 = read(VAR_0->socket, VAR_4, sizeof(VAR_4));
	if(VAR_1<0) {
		if(VAR_16 == VAR_17 || VAR_16 == VAR_18 || VAR_16 == VAR_19)
			return;	/* COMMENT_0 */
		syslog(VAR_20, ""(s=%d) processRequest(): read(): %m"", VAR_0->socket);
		goto error;
	}
	if(VAR_1==0) {
		syslog(VAR_21, ""(s=%d) request connection closed"", VAR_0->socket);
		goto error;
	}
	VAR_13 = time(NULL);
	VAR_6 = VAR_4[0];
	VAR_5 = VAR_4 + 1;
	DECODELENGTH_CHECKLIMIT(VAR_2, VAR_5, VAR_4 + VAR_1);
	if(VAR_2 > (unsigned)(VAR_4+VAR_1-VAR_5)) {
		syslog(VAR_22, ""bad request (length encoding l=%u n=%u)"",
		       VAR_2, (unsigned)VAR_1);
		goto error;
	}
	if(VAR_2 == 0 && VAR_6 != VAR_23
	   && VAR_6 != VAR_24 && VAR_6 != VAR_25) {
		syslog(VAR_22, ""bad request (length=0, type=%d)"", VAR_6);
		goto error;
	}
	syslog(VAR_21, ""(s=%d) request type=%d str='%.*s'"",
	       VAR_0->socket, VAR_6, VAR_2, VAR_5);
	switch(VAR_6) {
	case VAR_24:
		VAR_11 = VAR_9;
		CODELENGTH((sizeof(VAR_26) - 1), VAR_11);
		memcpy(VAR_11, VAR_26, sizeof(VAR_26) - 1);
		VAR_11 += (sizeof(VAR_26) - 1);
		if(write_or_buffer(VAR_0, VAR_9, VAR_11 - VAR_9) < 0) {
			syslog(VAR_20, ""(s=%d) write: %m"", VAR_0->socket);
			goto error;
		}
		break;
	case VAR_27:	/* COMMENT_1 */
	case VAR_28:	/* COMMENT_2 */
	case VAR_23:	/* COMMENT_3 */
		VAR_11 = VAR_9+1;
		while(VAR_7 && (VAR_12 < 255)) {
			if(VAR_7->t < VAR_13) {
				syslog(VAR_21, ""outdated device"");
			} else {
				/* COMMENT_4 */
				if(VAR_7->headers[VAR_29].l + VAR_7->headers[VAR_30].l
				  + VAR_7->headers[VAR_31].l + 6
				  + (VAR_11 - VAR_9) >= (int)sizeof(VAR_9))
					break;
				if( (VAR_6==VAR_27 && 0==memcmp(VAR_7->headers[VAR_30].p, VAR_5, VAR_2))
				  ||(VAR_6==VAR_28 && 0==memcmp(VAR_7->headers[VAR_31].p, VAR_5, VAR_2))
				  ||(VAR_6==VAR_23) ) {
					/* COMMENT_5 */
                    
                                    
                  
					VAR_3 = VAR_7->headers[VAR_29].l;
					CODELENGTH(VAR_3, VAR_11);
					memcpy(VAR_11, VAR_7->headers[VAR_29].p, VAR_7->headers[VAR_29].l);
					VAR_11 += VAR_7->headers[VAR_29].l;
					VAR_3 = VAR_7->headers[VAR_30].l;
					CODELENGTH(VAR_3, VAR_11);
					memcpy(VAR_11, VAR_7->headers[VAR_30].p, VAR_7->headers[VAR_30].l);
					VAR_11 += VAR_7->headers[VAR_30].l;
					VAR_3 = VAR_7->headers[VAR_31].l;
					CODELENGTH(VAR_3, VAR_11);
					memcpy(VAR_11, VAR_7->headers[VAR_31].p, VAR_7->headers[VAR_31].l);
					VAR_11 += VAR_7->headers[VAR_31].l;
					VAR_12++;
				}
			}
			VAR_7 = VAR_7->next;
		}
		/* COMMENT_9 */
		for(VAR_15 = VAR_32.lh_first;
		    VAR_15 && (VAR_12 < 255);
		    VAR_15 = VAR_15->entries.le_next) {
			/* COMMENT_4 */
			if(strlen(VAR_15->location) + strlen(VAR_15->st)
			  + strlen(VAR_15->usn) + 6 + (VAR_11 - VAR_9) >= sizeof(VAR_9))
			  	break;
			if( (VAR_6==VAR_27 && 0==strncmp(VAR_15->st, (const char *)VAR_5, VAR_2))
			  ||(VAR_6==VAR_28 && 0==strncmp(VAR_15->usn, (const char *)VAR_5, VAR_2))
			  ||(VAR_6==VAR_23) ) {
				/* COMMENT_10 */
                   
                                   
                 
				VAR_3 = strlen(VAR_15->location);
				CODELENGTH(VAR_3, VAR_11);
				memcpy(VAR_11, VAR_15->location, VAR_3);
				VAR_11 += VAR_3;
				VAR_3 = strlen(VAR_15->st);
				CODELENGTH(VAR_3, VAR_11);
				memcpy(VAR_11, VAR_15->st, VAR_3);
				VAR_11 += VAR_3;
				VAR_3 = strlen(VAR_15->usn);
				CODELENGTH(VAR_3, VAR_11);
				memcpy(VAR_11, VAR_15->usn, VAR_3);
				VAR_11 += VAR_3;
				VAR_12++;
			}
		}
		VAR_9[0] = VAR_12;
		syslog(VAR_33, ""(s=%d) response : %d device%s"",
		       VAR_0->socket, VAR_12, (VAR_12 > 1) ? ""s"" : """");
		if(write_or_buffer(VAR_0, VAR_9, VAR_11 - VAR_9) < 0) {
			syslog(VAR_20, ""(s=%d) write: %m"", VAR_0->socket);
			goto error;
		}
		break;
	case VAR_34:	/* COMMENT_14 */
		VAR_14 = malloc(sizeof(struct service));
		if(!VAR_14) {
			syslog(VAR_20, ""cannot allocate memory"");
			goto error;
		}
		memset(VAR_14, 0, sizeof(struct service));	/* COMMENT_15 */
		if(containsForbiddenChars(VAR_5, VAR_2)) {
			syslog(VAR_20, ""bad request (st contains forbidden chars)"");
			goto error;
		}
		VAR_14->st = malloc(VAR_2 + 1);
		if(!VAR_14->st) {
			syslog(VAR_20, ""cannot allocate memory"");
			goto error;
		}
		memcpy(VAR_14->st, VAR_5, VAR_2);
		VAR_14->st[VAR_2] = '\0';
		VAR_5 += VAR_2;
		if(VAR_5 >= VAR_4 + VAR_1) {
			syslog(VAR_22, ""bad request (missing usn)"");
			goto error;
		}
		DECODELENGTH_CHECKLIMIT(VAR_2, VAR_5, VAR_4 + VAR_1);
		if(VAR_2 > (unsigned)(VAR_4+VAR_1-VAR_5)) {
			syslog(VAR_22, ""bad request (length encoding)"");
			goto error;
		}
		if(containsForbiddenChars(VAR_5, VAR_2)) {
			syslog(VAR_20, ""bad request (usn contains forbidden chars)"");
			goto error;
		}
		syslog(VAR_21, ""usn='%.*s'"", VAR_2, VAR_5);
		VAR_14->usn = malloc(VAR_2 + 1);
		if(!VAR_14->usn) {
			syslog(VAR_20, ""cannot allocate memory"");
			goto error;
		}
		memcpy(VAR_14->usn, VAR_5, VAR_2);
		VAR_14->usn[VAR_2] = '\0';
		VAR_5 += VAR_2;
		DECODELENGTH_CHECKLIMIT(VAR_2, VAR_5, VAR_4 + VAR_1);
		if(VAR_2 > (unsigned)(VAR_4+VAR_1-VAR_5)) {
			syslog(VAR_22, ""bad request (length encoding)"");
			goto error;
		}
		if(containsForbiddenChars(VAR_5, VAR_2)) {
			syslog(VAR_20, ""bad request (server contains forbidden chars)"");
			goto error;
		}
		syslog(VAR_21, ""server='%.*s'"", VAR_2, VAR_5);
		VAR_14->server = malloc(VAR_2 + 1);
		if(!VAR_14->server) {
			syslog(VAR_20, ""cannot allocate memory"");
			goto error;
		}
		memcpy(VAR_14->server, VAR_5, VAR_2);
		VAR_14->server[VAR_2] = '\0';
		VAR_5 += VAR_2;
		DECODELENGTH_CHECKLIMIT(VAR_2, VAR_5, VAR_4 + VAR_1);
		if(VAR_2 > (unsigned)(VAR_4+VAR_1-VAR_5)) {
			syslog(VAR_22, ""bad request (length encoding)"");
			goto error;
		}
		if(containsForbiddenChars(VAR_5, VAR_2)) {
			syslog(VAR_20, ""bad request (location contains forbidden chars)"");
			goto error;
		}
		syslog(VAR_21, ""location='%.*s'"", VAR_2, VAR_5);
		VAR_14->location = malloc(VAR_2 + 1);
		if(!VAR_14->location) {
			syslog(VAR_20, ""cannot allocate memory"");
			goto error;
		}
		memcpy(VAR_14->location, VAR_5, VAR_2);
		VAR_14->location[VAR_2] = '\0';
		/* COMMENT_16 */
		for(VAR_15 = VAR_32.lh_first;
		    VAR_15;
		    VAR_15 = VAR_15->entries.le_next) {
			if(0 == strcmp(VAR_14->usn, VAR_15->usn)
			  && 0 == strcmp(VAR_14->st, VAR_15->st)) {
				syslog(VAR_21, ""Service already in the list. Updating..."");
				free(VAR_14->st);
				free(VAR_14->usn);
				free(VAR_15->server);
				VAR_15->server = VAR_14->server;
				free(VAR_15->location);
				VAR_15->location = VAR_14->location;
				free(VAR_14);
				VAR_14 = NULL;
				return;
			}
		}
		/* COMMENT_17 */
		LIST_INSERT_HEAD(&VAR_32, VAR_14, VAR_35);
		sendNotifications(VAR_36, NULL, VAR_14);
		VAR_14 = NULL;
		break;
	case VAR_25:	/* COMMENT_18 */
		VAR_9[0] = '\0';
		if(write_or_buffer(VAR_0, VAR_9, 1) < 0) {
			syslog(VAR_20, ""(s=%d) write: %m"", VAR_0->socket);
			goto error;
		}
		VAR_0->is_notify = 1;
		break;
	default:
		syslog(VAR_22, ""Unknown request type %d"", VAR_6);
		VAR_9[0] = '\0';
		if(write_or_buffer(VAR_0, VAR_9, 1) < 0) {
			syslog(VAR_20, ""(s=%d) write: %m"", VAR_0->socket);
			goto error;
		}
	}
	return;
error:
	if(VAR_14) {
		free(VAR_14->st);
		free(VAR_14->usn);
		free(VAR_14->server);
		free(VAR_14->location);
		free(VAR_14);
		VAR_14 = NULL;
	}
	close(VAR_0->socket);
	VAR_0->socket = -1;
	return;
}",miniupnp/b238cade9a173c6f751a34acf8ccff838a62aa47/minissdpd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -28,7 +28,7 @@
 	type = buf[0];
 	p = buf + 1;
 	DECODELENGTH_CHECKLIMIT(l, p, buf + n);
-	if(p+l > buf+n) {
+	if(l > (unsigned)(buf+n-p)) {
 		syslog(LOG_WARNING, ""bad request (length encoding l=%u n=%u)"",
 		       l, (unsigned)n);
 		goto error;
@@ -150,7 +150,7 @@
 			goto error;
 		}
 		DECODELENGTH_CHECKLIMIT(l, p, buf + n);
-		if(p+l > buf+n) {
+		if(l > (unsigned)(buf+n-p)) {
 			syslog(LOG_WARNING, ""bad request (length encoding)"");
 			goto error;
 		}
@@ -168,7 +168,7 @@
 		newserv->usn[l] = '\0';
 		p += l;
 		DECODELENGTH_CHECKLIMIT(l, p, buf + n);
-		if(p+l > buf+n) {
+		if(l > (unsigned)(buf+n-p)) {
 			syslog(LOG_WARNING, ""bad request (length encoding)"");
 			goto error;
 		}
@@ -186,7 +186,7 @@
 		newserv->server[l] = '\0';
 		p += l;
 		DECODELENGTH_CHECKLIMIT(l, p, buf + n);
-		if(p+l > buf+n) {
+		if(l > (unsigned)(buf+n-p)) {
 			syslog(LOG_WARNING, ""bad request (length encoding)"");
 			goto error;
 		}","{'deleted_lines': ['\tif(p+l > buf+n) {', '\t\tif(p+l > buf+n) {', '\t\tif(p+l > buf+n) {', '\t\tif(p+l > buf+n) {'], 'added_lines': ['\tif(l > (unsigned)(buf+n-p)) {', '\t\tif(l > (unsigned)(buf+n-p)) {', '\t\tif(l > (unsigned)(buf+n-p)) {', '\t\tif(l > (unsigned)(buf+n-p)) {']}",True,The processRequest function in minissdpd.c in MiniSSDPd 1.2.20130907-3 allows local users to cause a denial of service (out-of-bounds memory access and daemon crash) via vectors involving a negative length value.,5.5,MEDIUM,1,test,2016-03-01T18:14:15Z,1
CVE-2016-3951,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"usbnet: cleanup after bind() in probe()

In case bind() works, but a later error forces bailing
in probe() in error cases work and a timer may be scheduled.
They must be killed. This fixes an error case related to
the double free reported in
http://www.spinics.net/lists/netdev/msg367669.html
and needs to go on top of Linus' fix to cdc-ncm.

Signed-off-by: Oliver Neukum <ONeukum@suse.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",1666984c8625b3db19a9abc298931d35ab7bc64b,https://github.com/torvalds/linux/commit/1666984c8625b3db19a9abc298931d35ab7bc64b,drivers/net/usb/usbnet.c,usbnet_probe,"int
usbnet_probe (struct usb_interface *udev, const struct usb_device_id *prod)
{
struct usbnet*dev;
struct net_device*net;
struct usb_host_interface*interface;
struct driver_info*info;
struct usb_device*xdev;
intstatus;
const char*name;
struct usb_driver *driver = to_usb_driver(udev->dev.driver);
if (!driver->supports_autosuspend) {
driver->supports_autosuspend = 1;
pm_runtime_enable(&udev->dev);
}
name = udev->dev.driver->name;
info = (struct driver_info *) prod->driver_info;
if (!info) {
dev_dbg (&udev->dev, ""blacklisted by %s\n"", name);
return -ENODEV;
}
xdev = interface_to_usbdev (udev);
interface = udev->cur_altsetting;
status = -ENOMEM;
net = alloc_etherdev(sizeof(*dev));
if (!net)
goto out;
SET_NETDEV_DEV(net, &udev->dev);
dev = netdev_priv(net);
dev->udev = xdev;
dev->intf = udev;
dev->driver_info = info;
dev->driver_name = name;
dev->msg_enable = netif_msg_init (msg_level, NETIF_MSG_DRV
| NETIF_MSG_PROBE | NETIF_MSG_LINK);
init_waitqueue_head(&dev->wait);
skb_queue_head_init (&dev->rxq);
skb_queue_head_init (&dev->txq);
skb_queue_head_init (&dev->done);
skb_queue_head_init(&dev->rxq_pause);
dev->bh.func = usbnet_bh;
dev->bh.data = (unsigned long) dev;
INIT_WORK (&dev->kevent, usbnet_deferred_kevent);
init_usb_anchor(&dev->deferred);
dev->delay.function = usbnet_bh;
dev->delay.data = (unsigned long) dev;
init_timer (&dev->delay);
mutex_init (&dev->phy_mutex);
mutex_init(&dev->interrupt_mutex);
dev->interrupt_count = 0;
dev->net = net;
strcpy (net->name, ""usb%d"");
memcpy (net->dev_addr, node_id, sizeof node_id);
dev->hard_mtu = net->mtu + net->hard_header_len;
net->netdev_ops = &usbnet_netdev_ops;
net->watchdog_timeo = TX_TIMEOUT_JIFFIES;
net->ethtool_ops = &usbnet_ethtool_ops;
if (info->bind) {
status = info->bind (dev, udev);
if (status < 0)
goto out1;
if ((dev->driver_info->flags & FLAG_ETHER) != 0 &&
((dev->driver_info->flags & FLAG_POINTTOPOINT) == 0 ||
(net->dev_addr [0] & 0x02) == 0))
strcpy (net->name, ""eth%d"");
if ((dev->driver_info->flags & FLAG_WLAN) != 0)
strcpy(net->name, ""wlan%d"");
if ((dev->driver_info->flags & FLAG_WWAN) != 0)
strcpy(net->name, ""wwan%d"");
if ((dev->driver_info->flags & FLAG_NOARP) != 0)
net->flags |= IFF_NOARP;
if (net->mtu > (dev->hard_mtu - net->hard_header_len))
net->mtu = dev->hard_mtu - net->hard_header_len;
} else if (!info->in || !info->out)
status = usbnet_get_endpoints (dev, udev);
else {
dev->in = usb_rcvbulkpipe (xdev, info->in);
dev->out = usb_sndbulkpipe (xdev, info->out);
if (!(info->flags & FLAG_NO_SETINT))
status = usb_set_interface (xdev,
interface->desc.bInterfaceNumber,
interface->desc.bAlternateSetting);
else
status = 0;
}
if (status >= 0 && dev->status)
status = init_status (dev, udev);
if (status < 0)
goto out3;
if (!dev->rx_urb_size)
dev->rx_urb_size = dev->hard_mtu;
dev->maxpacket = usb_maxpacket (dev->udev, dev->out, 1);
if (ether_addr_equal(net->dev_addr, node_id))
net->addr_assign_type = NET_ADDR_RANDOM;
if ((dev->driver_info->flags & FLAG_WLAN) != 0)
SET_NETDEV_DEVTYPE(net, &wlan_type);
if ((dev->driver_info->flags & FLAG_WWAN) != 0)
SET_NETDEV_DEVTYPE(net, &wwan_type);
usbnet_update_max_qlen(dev);
if (dev->can_dma_sg && !(info->flags & FLAG_SEND_ZLP) &&
!(info->flags & FLAG_MULTI_PACKET)) {
dev->padding_pkt = kzalloc(1, GFP_KERNEL);
if (!dev->padding_pkt) {
status = -ENOMEM;
goto out4;
}
}
status = register_netdev (net);
if (status)
goto out5;
netif_info(dev, probe, dev->net,
""register '%s' at usb-%s-%s, %s, %pM\n"",
udev->dev.driver->name,
xdev->bus->bus_name, xdev->devpath,
dev->driver_info->description,
net->dev_addr);
usb_set_intfdata (udev, dev);
netif_device_attach (net);
if (dev->driver_info->flags & FLAG_LINK_INTR)
usbnet_link_change(dev, 0, 0);
return 0;
out5:
kfree(dev->padding_pkt);
out4:
usb_free_urb(dev->interrupt);
out3:
if (info->unbind)
info->unbind (dev, udev);
out1:
free_netdev(net);
out:
return status;
}","int
usbnet_probe (struct usb_interface *VAR_0, const struct usb_device_id *VAR_1)
{
struct usbnet*VAR_2;
struct net_device*VAR_3;
struct usb_host_interface*VAR_4;
struct driver_info*VAR_5;
struct usb_device*VAR_6;
intVAR_7;
const char*VAR_8;
struct usb_driver *VAR_9 = to_usb_driver(VAR_0->dev.driver);
if (!VAR_9->supports_autosuspend) {
VAR_9->supports_autosuspend = 1;
pm_runtime_enable(&VAR_0->dev);
}
VAR_8 = VAR_0->dev.driver->name;
VAR_5 = (struct driver_info *) VAR_1->driver_info;
if (!VAR_5) {
dev_dbg (&VAR_0->dev, ""blacklisted by %s\n"", VAR_8);
return -VAR_10;
}
VAR_6 = interface_to_usbdev (VAR_0);
VAR_4 = VAR_0->cur_altsetting;
VAR_7 = -VAR_11;
VAR_3 = alloc_etherdev(sizeof(*VAR_2));
if (!VAR_3)
goto out;
SET_NETDEV_DEV(VAR_3, &VAR_0->dev);
VAR_2 = netdev_priv(VAR_3);
VAR_2->udev = VAR_6;
VAR_2->intf = VAR_0;
VAR_2->driver_info = VAR_5;
VAR_2->driver_name = VAR_8;
VAR_2->msg_enable = netif_msg_init (VAR_12, VAR_13
| VAR_14 | VAR_15);
init_waitqueue_head(&VAR_2->wait);
skb_queue_head_init (&VAR_2->rxq);
skb_queue_head_init (&VAR_2->txq);
skb_queue_head_init (&VAR_2->done);
skb_queue_head_init(&VAR_2->rxq_pause);
VAR_2->bh.func = VAR_16;
VAR_2->bh.data = (unsigned long) VAR_2;
INIT_WORK (&VAR_2->kevent, VAR_17);
init_usb_anchor(&VAR_2->deferred);
VAR_2->delay.function = VAR_16;
VAR_2->delay.data = (unsigned long) VAR_2;
init_timer (&VAR_2->delay);
mutex_init (&VAR_2->phy_mutex);
mutex_init(&VAR_2->interrupt_mutex);
VAR_2->interrupt_count = 0;
VAR_2->net = VAR_3;
strcpy (VAR_3->name, ""usb%d"");
memcpy (VAR_3->dev_addr, VAR_18, sizeof VAR_18);
VAR_2->hard_mtu = VAR_3->mtu + VAR_3->hard_header_len;
VAR_3->netdev_ops = &VAR_19;
VAR_3->watchdog_timeo = VAR_20;
VAR_3->ethtool_ops = &VAR_21;
if (VAR_5->bind) {
VAR_7 = VAR_5->bind (VAR_2, VAR_0);
if (VAR_7 < 0)
goto out1;
if ((VAR_2->driver_info->flags & VAR_22) != 0 &&
((VAR_2->driver_info->flags & VAR_23) == 0 ||
(VAR_3->dev_addr [0] & 0x02) == 0))
strcpy (VAR_3->name, ""eth%d"");
if ((VAR_2->driver_info->flags & VAR_24) != 0)
strcpy(VAR_3->name, ""wlan%d"");
if ((VAR_2->driver_info->flags & VAR_25) != 0)
strcpy(VAR_3->name, ""wwan%d"");
if ((VAR_2->driver_info->flags & VAR_26) != 0)
VAR_3->flags |= VAR_27;
if (VAR_3->mtu > (VAR_2->hard_mtu - VAR_3->hard_header_len))
VAR_3->mtu = VAR_2->hard_mtu - VAR_3->hard_header_len;
} else if (!VAR_5->in || !VAR_5->out)
VAR_7 = usbnet_get_endpoints (VAR_2, VAR_0);
else {
VAR_2->in = usb_rcvbulkpipe (VAR_6, VAR_5->in);
VAR_2->out = usb_sndbulkpipe (VAR_6, VAR_5->out);
if (!(VAR_5->flags & VAR_28))
VAR_7 = usb_set_interface (VAR_6,
VAR_4->desc.bInterfaceNumber,
VAR_4->desc.bAlternateSetting);
else
VAR_7 = 0;
}
if (VAR_7 >= 0 && VAR_2->status)
VAR_7 = init_status (VAR_2, VAR_0);
if (VAR_7 < 0)
goto out3;
if (!VAR_2->rx_urb_size)
VAR_2->rx_urb_size = VAR_2->hard_mtu;
VAR_2->maxpacket = usb_maxpacket (VAR_2->udev, VAR_2->out, 1);
if (ether_addr_equal(VAR_3->dev_addr, VAR_18))
VAR_3->addr_assign_type = VAR_29;
if ((VAR_2->driver_info->flags & VAR_24) != 0)
SET_NETDEV_DEVTYPE(VAR_3, &VAR_30);
if ((VAR_2->driver_info->flags & VAR_25) != 0)
SET_NETDEV_DEVTYPE(VAR_3, &VAR_31);
usbnet_update_max_qlen(VAR_2);
if (VAR_2->can_dma_sg && !(VAR_5->flags & VAR_32) &&
!(VAR_5->flags & VAR_33)) {
VAR_2->padding_pkt = kzalloc(1, VAR_34);
if (!VAR_2->padding_pkt) {
VAR_7 = -VAR_11;
goto out4;
}
}
VAR_7 = register_netdev (VAR_3);
if (VAR_7)
goto out5;
netif_info(VAR_2, VAR_35, VAR_2->net,
""register '%s' at usb-%s-%s, %s, %pM\n"",
VAR_0->dev.driver->name,
VAR_6->bus->bus_name, VAR_6->devpath,
VAR_2->driver_info->description,
VAR_3->dev_addr);
usb_set_intfdata (VAR_0, VAR_2);
netif_device_attach (VAR_3);
if (VAR_2->driver_info->flags & VAR_36)
usbnet_link_change(VAR_2, 0, 0);
return 0;
out5:
kfree(VAR_2->padding_pkt);
out4:
usb_free_urb(VAR_2->interrupt);
out3:
if (VAR_5->unbind)
VAR_5->unbind (VAR_2, VAR_0);
out1:
free_netdev(VAR_3);
out:
return VAR_7;
}",torvalds/linux/1666984c8625b3db19a9abc298931d35ab7bc64b/usbnet.c/vul/before/0.json,"int
usbnet_probe (struct usb_interface *udev, const struct usb_device_id *prod)
{
	struct usbnet			*dev;
	struct net_device		*net;
	struct usb_host_interface	*interface;
	struct driver_info		*info;
	struct usb_device		*xdev;
	int				status;
	const char			*name;
	struct usb_driver 	*driver = to_usb_driver(udev->dev.driver);

	/* usbnet already took usb runtime pm, so have to enable the feature
	 * for usb interface, otherwise usb_autopm_get_interface may return
	 * failure if RUNTIME_PM is enabled.
	 */
	if (!driver->supports_autosuspend) {
		driver->supports_autosuspend = 1;
		pm_runtime_enable(&udev->dev);
	}

	name = udev->dev.driver->name;
	info = (struct driver_info *) prod->driver_info;
	if (!info) {
		dev_dbg (&udev->dev, ""blacklisted by %s\n"", name);
		return -ENODEV;
	}
	xdev = interface_to_usbdev (udev);
	interface = udev->cur_altsetting;

	status = -ENOMEM;

	// set up our own records
	net = alloc_etherdev(sizeof(*dev));
	if (!net)
		goto out;

	/* netdev_printk() needs this so do it as early as possible */
	SET_NETDEV_DEV(net, &udev->dev);

	dev = netdev_priv(net);
	dev->udev = xdev;
	dev->intf = udev;
	dev->driver_info = info;
	dev->driver_name = name;
	dev->msg_enable = netif_msg_init (msg_level, NETIF_MSG_DRV
				| NETIF_MSG_PROBE | NETIF_MSG_LINK);
	init_waitqueue_head(&dev->wait);
	skb_queue_head_init (&dev->rxq);
	skb_queue_head_init (&dev->txq);
	skb_queue_head_init (&dev->done);
	skb_queue_head_init(&dev->rxq_pause);
	dev->bh.func = usbnet_bh;
	dev->bh.data = (unsigned long) dev;
	INIT_WORK (&dev->kevent, usbnet_deferred_kevent);
	init_usb_anchor(&dev->deferred);
	dev->delay.function = usbnet_bh;
	dev->delay.data = (unsigned long) dev;
	init_timer (&dev->delay);
	mutex_init (&dev->phy_mutex);
	mutex_init(&dev->interrupt_mutex);
	dev->interrupt_count = 0;

	dev->net = net;
	strcpy (net->name, ""usb%d"");
	memcpy (net->dev_addr, node_id, sizeof node_id);

	/* rx and tx sides can use different message sizes;
	 * bind() should set rx_urb_size in that case.
	 */
	dev->hard_mtu = net->mtu + net->hard_header_len;

	net->netdev_ops = &usbnet_netdev_ops;
	net->watchdog_timeo = TX_TIMEOUT_JIFFIES;
	net->ethtool_ops = &usbnet_ethtool_ops;

	// allow device-specific bind/init procedures
	// NOTE net->name still not usable ...
	if (info->bind) {
		status = info->bind (dev, udev);
		if (status < 0)
			goto out1;

		// heuristic:  ""usb%d"" for links we know are two-host,
		// else ""eth%d"" when there's reasonable doubt.  userspace
		// can rename the link if it knows better.
		if ((dev->driver_info->flags & FLAG_ETHER) != 0 &&
		    ((dev->driver_info->flags & FLAG_POINTTOPOINT) == 0 ||
		     (net->dev_addr [0] & 0x02) == 0))
			strcpy (net->name, ""eth%d"");
		/* WLAN devices should always be named ""wlan%d"" */
		if ((dev->driver_info->flags & FLAG_WLAN) != 0)
			strcpy(net->name, ""wlan%d"");
		/* WWAN devices should always be named ""wwan%d"" */
		if ((dev->driver_info->flags & FLAG_WWAN) != 0)
			strcpy(net->name, ""wwan%d"");

		/* devices that cannot do ARP */
		if ((dev->driver_info->flags & FLAG_NOARP) != 0)
			net->flags |= IFF_NOARP;

		/* maybe the remote can't receive an Ethernet MTU */
		if (net->mtu > (dev->hard_mtu - net->hard_header_len))
			net->mtu = dev->hard_mtu - net->hard_header_len;
	} else if (!info->in || !info->out)
		status = usbnet_get_endpoints (dev, udev);
	else {
		dev->in = usb_rcvbulkpipe (xdev, info->in);
		dev->out = usb_sndbulkpipe (xdev, info->out);
		if (!(info->flags & FLAG_NO_SETINT))
			status = usb_set_interface (xdev,
				interface->desc.bInterfaceNumber,
				interface->desc.bAlternateSetting);
		else
			status = 0;

	}
	if (status >= 0 && dev->status)
		status = init_status (dev, udev);
	if (status < 0)
		goto out3;

	if (!dev->rx_urb_size)
		dev->rx_urb_size = dev->hard_mtu;
	dev->maxpacket = usb_maxpacket (dev->udev, dev->out, 1);

	/* let userspace know we have a random address */
	if (ether_addr_equal(net->dev_addr, node_id))
		net->addr_assign_type = NET_ADDR_RANDOM;

	if ((dev->driver_info->flags & FLAG_WLAN) != 0)
		SET_NETDEV_DEVTYPE(net, &wlan_type);
	if ((dev->driver_info->flags & FLAG_WWAN) != 0)
		SET_NETDEV_DEVTYPE(net, &wwan_type);

	/* initialize max rx_qlen and tx_qlen */
	usbnet_update_max_qlen(dev);

	if (dev->can_dma_sg && !(info->flags & FLAG_SEND_ZLP) &&
		!(info->flags & FLAG_MULTI_PACKET)) {
		dev->padding_pkt = kzalloc(1, GFP_KERNEL);
		if (!dev->padding_pkt) {
			status = -ENOMEM;
			goto out4;
		}
	}

	status = register_netdev (net);
	if (status)
		goto out5;
	netif_info(dev, probe, dev->net,
		   ""register '%s' at usb-%s-%s, %s, %pM\n"",
		   udev->dev.driver->name,
		   xdev->bus->bus_name, xdev->devpath,
		   dev->driver_info->description,
		   net->dev_addr);

	// ok, it's ready to go.
	usb_set_intfdata (udev, dev);

	netif_device_attach (net);

	if (dev->driver_info->flags & FLAG_LINK_INTR)
		usbnet_link_change(dev, 0, 0);

	return 0;

out5:
	kfree(dev->padding_pkt);
out4:
	usb_free_urb(dev->interrupt);
out3:
	if (info->unbind)
		info->unbind (dev, udev);
out1:
	/* subdrivers must undo all they did in bind() if they
	 * fail it, but we may fail later and a deferred kevent
	 * may trigger an error resubmitting itself and, worse,
	 * schedule a timer. So we kill it all just in case.
	 */
	cancel_work_sync(&dev->kevent);
	del_timer_sync(&dev->delay);
	free_netdev(net);
out:
	return status;
}","int
usbnet_probe (struct usb_interface *VAR_0, const struct usb_device_id *VAR_1)
{
	struct usbnet			*VAR_2;
	struct net_device		*VAR_3;
	struct usb_host_interface	*VAR_4;
	struct driver_info		*VAR_5;
	struct usb_device		*VAR_6;
	int				VAR_7;
	const char			*VAR_8;
	struct usb_driver 	*VAR_9 = to_usb_driver(VAR_0->dev.driver);

	/* COMMENT_0 */
                                                                    
                                     
    
	if (!VAR_9->supports_autosuspend) {
		VAR_9->supports_autosuspend = 1;
		pm_runtime_enable(&VAR_0->dev);
	}

	VAR_8 = VAR_0->dev.driver->name;
	VAR_5 = (struct driver_info *) VAR_1->driver_info;
	if (!VAR_5) {
		dev_dbg (&VAR_0->dev, ""blacklisted by %s\n"", VAR_8);
		return -VAR_10;
	}
	VAR_6 = interface_to_usbdev (VAR_0);
	VAR_4 = VAR_0->cur_altsetting;

	VAR_7 = -VAR_11;

	/* COMMENT_4 */
	VAR_3 = alloc_etherdev(sizeof(*VAR_2));
	if (!VAR_3)
		goto out;

	/* COMMENT_5 */
	SET_NETDEV_DEV(VAR_3, &VAR_0->dev);

	VAR_2 = netdev_priv(VAR_3);
	VAR_2->udev = VAR_6;
	VAR_2->intf = VAR_0;
	VAR_2->driver_info = VAR_5;
	VAR_2->driver_name = VAR_8;
	VAR_2->msg_enable = netif_msg_init (VAR_12, VAR_13
				| VAR_14 | VAR_15);
	init_waitqueue_head(&VAR_2->wait);
	skb_queue_head_init (&VAR_2->rxq);
	skb_queue_head_init (&VAR_2->txq);
	skb_queue_head_init (&VAR_2->done);
	skb_queue_head_init(&VAR_2->rxq_pause);
	VAR_2->bh.func = VAR_16;
	VAR_2->bh.data = (unsigned long) VAR_2;
	INIT_WORK (&VAR_2->kevent, VAR_17);
	init_usb_anchor(&VAR_2->deferred);
	VAR_2->delay.function = VAR_16;
	VAR_2->delay.data = (unsigned long) VAR_2;
	init_timer (&VAR_2->delay);
	mutex_init (&VAR_2->phy_mutex);
	mutex_init(&VAR_2->interrupt_mutex);
	VAR_2->interrupt_count = 0;

	VAR_2->net = VAR_3;
	strcpy (VAR_3->name, ""usb%d"");
	memcpy (VAR_3->dev_addr, VAR_18, sizeof VAR_18);

	/* COMMENT_6 */
                                               
    
	VAR_2->hard_mtu = VAR_3->mtu + VAR_3->hard_header_len;

	VAR_3->netdev_ops = &VAR_19;
	VAR_3->watchdog_timeo = VAR_20;
	VAR_3->ethtool_ops = &VAR_21;

	/* COMMENT_9 */
	/* COMMENT_10 */
	if (VAR_5->bind) {
		VAR_7 = VAR_5->bind (VAR_2, VAR_0);
		if (VAR_7 < 0)
			goto out1;

		/* COMMENT_11 */
		/* COMMENT_12 */
		/* COMMENT_13 */
		if ((VAR_2->driver_info->flags & VAR_22) != 0 &&
		    ((VAR_2->driver_info->flags & VAR_23) == 0 ||
		     (VAR_3->dev_addr [0] & 0x02) == 0))
			strcpy (VAR_3->name, ""eth%d"");
		/* COMMENT_14 */
		if ((VAR_2->driver_info->flags & VAR_24) != 0)
			strcpy(VAR_3->name, ""wlan%d"");
		/* COMMENT_15 */
		if ((VAR_2->driver_info->flags & VAR_25) != 0)
			strcpy(VAR_3->name, ""wwan%d"");

		/* COMMENT_16 */
		if ((VAR_2->driver_info->flags & VAR_26) != 0)
			VAR_3->flags |= VAR_27;

		/* COMMENT_17 */
		if (VAR_3->mtu > (VAR_2->hard_mtu - VAR_3->hard_header_len))
			VAR_3->mtu = VAR_2->hard_mtu - VAR_3->hard_header_len;
	} else if (!VAR_5->in || !VAR_5->out)
		VAR_7 = usbnet_get_endpoints (VAR_2, VAR_0);
	else {
		VAR_2->in = usb_rcvbulkpipe (VAR_6, VAR_5->in);
		VAR_2->out = usb_sndbulkpipe (VAR_6, VAR_5->out);
		if (!(VAR_5->flags & VAR_28))
			VAR_7 = usb_set_interface (VAR_6,
				VAR_4->desc.bInterfaceNumber,
				VAR_4->desc.bAlternateSetting);
		else
			VAR_7 = 0;

	}
	if (VAR_7 >= 0 && VAR_2->status)
		VAR_7 = init_status (VAR_2, VAR_0);
	if (VAR_7 < 0)
		goto out3;

	if (!VAR_2->rx_urb_size)
		VAR_2->rx_urb_size = VAR_2->hard_mtu;
	VAR_2->maxpacket = usb_maxpacket (VAR_2->udev, VAR_2->out, 1);

	/* COMMENT_18 */
	if (ether_addr_equal(VAR_3->dev_addr, VAR_18))
		VAR_3->addr_assign_type = VAR_29;

	if ((VAR_2->driver_info->flags & VAR_24) != 0)
		SET_NETDEV_DEVTYPE(VAR_3, &VAR_30);
	if ((VAR_2->driver_info->flags & VAR_25) != 0)
		SET_NETDEV_DEVTYPE(VAR_3, &VAR_31);

	/* COMMENT_19 */
	usbnet_update_max_qlen(VAR_2);

	if (VAR_2->can_dma_sg && !(VAR_5->flags & VAR_32) &&
		!(VAR_5->flags & VAR_33)) {
		VAR_2->padding_pkt = kzalloc(1, VAR_34);
		if (!VAR_2->padding_pkt) {
			VAR_7 = -VAR_11;
			goto out4;
		}
	}

	VAR_7 = register_netdev (VAR_3);
	if (VAR_7)
		goto out5;
	netif_info(VAR_2, VAR_35, VAR_2->net,
		   ""register '%s' at usb-%s-%s, %s, %pM\n"",
		   VAR_0->dev.driver->name,
		   VAR_6->bus->bus_name, VAR_6->devpath,
		   VAR_2->driver_info->description,
		   VAR_3->dev_addr);

	/* COMMENT_20 */
	usb_set_intfdata (VAR_0, VAR_2);

	netif_device_attach (VAR_3);

	if (VAR_2->driver_info->flags & VAR_36)
		usbnet_link_change(VAR_2, 0, 0);

	return 0;

out5:
	kfree(VAR_2->padding_pkt);
out4:
	usb_free_urb(VAR_2->interrupt);
out3:
	if (VAR_5->unbind)
		VAR_5->unbind (VAR_2, VAR_0);
out1:
	/* COMMENT_21 */
                                                        
                                                        
                                                     
    
	cancel_work_sync(&VAR_2->kevent);
	del_timer_sync(&VAR_2->delay);
	free_netdev(VAR_3);
out:
	return VAR_7;
}",torvalds/linux/1666984c8625b3db19a9abc298931d35ab7bc64b/usbnet.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -173,6 +173,13 @@
 	if (info->unbind)
 		info->unbind (dev, udev);
 out1:
+	/* subdrivers must undo all they did in bind() if they
+	 * fail it, but we may fail later and a deferred kevent
+	 * may trigger an error resubmitting itself and, worse,
+	 * schedule a timer. So we kill it all just in case.
+	 */
+	cancel_work_sync(&dev->kevent);
+	del_timer_sync(&dev->delay);
 	free_netdev(net);
 out:
 	return status;","{'deleted_lines': [], 'added_lines': ['\t/* subdrivers must undo all they did in bind() if they', '\t * fail it, but we may fail later and a deferred kevent', '\t * may trigger an error resubmitting itself and, worse,', '\t * schedule a timer. So we kill it all just in case.', '\t */', '\tcancel_work_sync(&dev->kevent);', '\tdel_timer_sync(&dev->delay);']}",True,Double free vulnerability in drivers/net/usb/cdc_ncm.c in the Linux kernel before 4.5 allows physically proximate attackers to cause a denial of service (system crash) or possibly have unspecified other impact by inserting a USB device with an invalid USB descriptor.,4.6,MEDIUM,1,test,2016-03-07T10:31:10Z,1
CVE-2016-7537,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/143,6d202a0514fb6a406456b8b728cde776becb25f8,https://github.com/ImageMagick/ImageMagick/commit/6d202a0514fb6a406456b8b728cde776becb25f8,coders/pdb.c,WritePDBImage,"static MagickBooleanType WritePDBImage(const ImageInfo *image_info,Image *image,
ExceptionInfo *exception)
{
const char
*comment;
int
bits;
MagickBooleanType
status;
PDBImage
pdb_image;
PDBInfo
pdb_info;
QuantumInfo
*quantum_info;
register const Quantum
*p;
register ssize_t
x;
register unsigned char
*q;
size_t
bits_per_pixel,
literal,
packets,
packet_size,
repeat;
ssize_t
y;
unsigned char
*buffer,
*runlength,
*scanline;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
assert(image != (Image *) NULL);
assert(image->signature == MagickCoreSignature);
if (image->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
if (status == MagickFalse)
return(status);
(void) TransformImageColorspace(image,sRGBColorspace,exception);
if (SetImageMonochrome(image,exception) != MagickFalse) {
bits_per_pixel=1;
} else if (image->colors <= 4) {
bits_per_pixel=2;
} else if (image->colors <= 8) {
bits_per_pixel=3;
} else {
bits_per_pixel=4;
}
(void) ResetMagickMemory(&pdb_info,0,sizeof(pdb_info));
(void) CopyMagickString(pdb_info.name,image_info->filename,
sizeof(pdb_info.name));
pdb_info.attributes=0;
pdb_info.version=0;
pdb_info.create_time=time(NULL);
pdb_info.modify_time=pdb_info.create_time;
pdb_info.archive_time=0;
pdb_info.modify_number=0;
pdb_info.application_info=0;
pdb_info.sort_info=0;
(void) CopyMagickMemory(pdb_info.type,""vIMG"",4);
(void) CopyMagickMemory(pdb_info.id,""View"",4);
pdb_info.seed=0;
pdb_info.next_record=0;
comment=GetImageProperty(image,""comment"",exception);
pdb_info.number_records=(comment == (const char *) NULL ? 1 : 2);
(void) WriteBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);
(void) WriteBlobMSBShort(image,(unsigned short) pdb_info.attributes);
(void) WriteBlobMSBShort(image,(unsigned short) pdb_info.version);
(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.create_time);
(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_time);
(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.archive_time);
(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_number);
(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.application_info);
(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.sort_info);
(void) WriteBlob(image,4,(unsigned char *) pdb_info.type);
(void) WriteBlob(image,4,(unsigned char *) pdb_info.id);
(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.seed);
(void) WriteBlobMSBLong(image,(unsigned int) pdb_info.next_record);
(void) WriteBlobMSBShort(image,(unsigned short) pdb_info.number_records);
(void) CopyMagickString(pdb_image.name,pdb_info.name,sizeof(pdb_image.name));
pdb_image.version=1;  
switch (bits_per_pixel)
{
case 1: pdb_image.type=(unsigned char) 0xff; break;  
case 2: pdb_image.type=(unsigned char) 0x00; break;  
default: pdb_image.type=(unsigned char) 0x02;  
}
pdb_image.reserved_1=0;
pdb_image.note=0;
pdb_image.x_last=0;
pdb_image.y_last=0;
pdb_image.reserved_2=0;
pdb_image.x_anchor=(unsigned short) 0xffff;
pdb_image.y_anchor=(unsigned short) 0xffff;
pdb_image.width=(short) image->columns;
if (image->columns % 16)
pdb_image.width=(short) (16*(image->columns/16+1));
pdb_image.height=(short) image->rows;
packets=((bits_per_pixel*image->columns+7)/8);
runlength=(unsigned char *) AcquireQuantumMemory(9UL*packets,
image->rows*sizeof(*runlength));
if (runlength == (unsigned char *) NULL)
ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
buffer=(unsigned char *) AcquireQuantumMemory(256,sizeof(*buffer));
if (buffer == (unsigned char *) NULL)
ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
packet_size=(size_t) (image->depth > 8 ? 2: 1);
scanline=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*
sizeof(*scanline));
if (scanline == (unsigned char *) NULL)
ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
(void) TransformImageColorspace(image,sRGBColorspace,exception);
quantum_info=AcquireQuantumInfo(image_info,image);
if (quantum_info == (QuantumInfo *) NULL)
ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
bits=8/(int) bits_per_pixel-1;  
literal=0;
repeat=0;
q=runlength;
buffer[0]=0x00;
for (y=0; y < (ssize_t) image->rows; y++)
{
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
(void) ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
GrayQuantum,scanline,exception);
for (x=0; x < (ssize_t) pdb_image.width; x++)
{
if (x < (ssize_t) image->columns)
buffer[literal+repeat]|=(0xff-scanline[x*packet_size]) >>
(8-bits_per_pixel) << bits*bits_per_pixel;
bits--;
if (bits < 0)
{
if (((literal+repeat) > 0) &&
(buffer[literal+repeat] == buffer[literal+repeat-1]))
{
if (repeat == 0)
{
literal--;
repeat++;
}
repeat++;
if (0x7f < repeat)
{
q=EncodeRLE(q,buffer,literal,repeat);
literal=0;
repeat=0;
}
}
else
{
if (repeat >= 2)
literal+=repeat;
else
{
q=EncodeRLE(q,buffer,literal,repeat);
buffer[0]=buffer[literal+repeat];
literal=0;
}
literal++;
repeat=0;
if (0x7f < literal)
{
q=EncodeRLE(q,buffer,(literal < 0x80 ? literal : 0x80),0);
(void) CopyMagickMemory(buffer,buffer+literal+repeat,0x80);
literal-=0x80;
}
}
bits=8/(int) bits_per_pixel-1;
buffer[literal+repeat]=0x00;
}
}
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
q=EncodeRLE(q,buffer,literal,repeat);
scanline=(unsigned char *) RelinquishMagickMemory(scanline);
buffer=(unsigned char *) RelinquishMagickMemory(buffer);
quantum_info=DestroyQuantumInfo(quantum_info);
(void) WriteBlobMSBLong(image,(unsigned int)
(TellBlob(image)+8*pdb_info.number_records));
(void) WriteBlobByte(image,0x40);
(void) WriteBlobByte(image,0x6f);
(void) WriteBlobByte(image,0x80);
(void) WriteBlobByte(image,0);
if (pdb_info.number_records > 1)
{
(void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8+58+q-
runlength));
(void) WriteBlobByte(image,0x40);
(void) WriteBlobByte(image,0x6f);
(void) WriteBlobByte(image,0x80);
(void) WriteBlobByte(image,1);
}
(void) WriteBlob(image,sizeof(pdb_image.name),(unsigned char *)
pdb_image.name);
(void) WriteBlobByte(image,(unsigned char) pdb_image.version);
(void) WriteBlobByte(image,pdb_image.type);
(void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_1);
(void) WriteBlobMSBLong(image,(unsigned int) pdb_image.note);
(void) WriteBlobMSBShort(image,(unsigned short) pdb_image.x_last);
(void) WriteBlobMSBShort(image,(unsigned short) pdb_image.y_last);
(void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_2);
(void) WriteBlobMSBShort(image,pdb_image.x_anchor);
(void) WriteBlobMSBShort(image,pdb_image.y_anchor);
(void) WriteBlobMSBShort(image,(unsigned short) pdb_image.width);
(void) WriteBlobMSBShort(image,(unsigned short) pdb_image.height);
(void) WriteBlob(image,(size_t) (q-runlength),runlength);
runlength=(unsigned char *) RelinquishMagickMemory(runlength);
if (pdb_info.number_records > 1)
(void) WriteBlobString(image,comment);
(void) CloseBlob(image);
return(MagickTrue);
}","static MagickBooleanType WritePDBImage(const ImageInfo *VAR_0,Image *VAR_1,
ExceptionInfo *VAR_2)
{
const char
*VAR_3;
int
VAR_4;
MagickBooleanType
VAR_5;
PDBImage
VAR_6;
PDBInfo
VAR_7;
QuantumInfo
*VAR_8;
register const Quantum
*VAR_9;
register ssize_t
VAR_10;
register unsigned char
*VAR_11;
size_t
VAR_12,
VAR_13,
VAR_14,
VAR_15,
VAR_16;
ssize_t
VAR_17;
unsigned char
*VAR_18,
*VAR_19,
*VAR_20;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_21);
assert(VAR_1 != (Image *) NULL);
assert(VAR_1->signature == VAR_21);
if (VAR_1->debug != VAR_22)
(void) LogMagickEvent(VAR_23,GetMagickModule(),""%s"",VAR_1->filename);
assert(VAR_2 != (ExceptionInfo *) NULL);
assert(VAR_2->signature == VAR_21);
VAR_5=OpenBlob(VAR_0,VAR_1,VAR_24,VAR_2);
if (VAR_5 == VAR_22)
return(VAR_5);
(void) TransformImageColorspace(VAR_1,VAR_25,VAR_2);
if (SetImageMonochrome(VAR_1,VAR_2) != VAR_22) {
VAR_12=1;
} else if (VAR_1->colors <= 4) {
VAR_12=2;
} else if (VAR_1->colors <= 8) {
VAR_12=3;
} else {
VAR_12=4;
}
(void) ResetMagickMemory(&VAR_7,0,sizeof(VAR_7));
(void) CopyMagickString(VAR_7.name,VAR_0->filename,
sizeof(VAR_7.name));
VAR_7.attributes=0;
VAR_7.version=0;
VAR_7.create_time=time(NULL);
VAR_7.modify_time=VAR_7.create_time;
VAR_7.archive_time=0;
VAR_7.modify_number=0;
VAR_7.application_info=0;
VAR_7.sort_info=0;
(void) CopyMagickMemory(VAR_7.type,""vIMG"",4);
(void) CopyMagickMemory(VAR_7.id,""View"",4);
VAR_7.seed=0;
VAR_7.next_record=0;
VAR_3=GetImageProperty(VAR_1,""comment"",VAR_2);
VAR_7.number_records=(VAR_3 == (const char *) NULL ? 1 : 2);
(void) WriteBlob(VAR_1,sizeof(VAR_7.name),(unsigned char *) VAR_7.name);
(void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_7.attributes);
(void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_7.version);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_7.create_time);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_7.modify_time);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_7.archive_time);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_7.modify_number);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_7.application_info);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_7.sort_info);
(void) WriteBlob(VAR_1,4,(unsigned char *) VAR_7.type);
(void) WriteBlob(VAR_1,4,(unsigned char *) VAR_7.id);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_7.seed);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_7.next_record);
(void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_7.number_records);
(void) CopyMagickString(VAR_6.name,VAR_7.name,sizeof(VAR_6.name));
VAR_6.version=1;  
switch (VAR_12)
{
case 1: VAR_6.type=(unsigned char) 0xff; break;  
case 2: VAR_6.type=(unsigned char) 0x00; break;  
default: VAR_6.type=(unsigned char) 0x02;  
}
VAR_6.reserved_1=0;
VAR_6.note=0;
VAR_6.x_last=0;
VAR_6.y_last=0;
VAR_6.reserved_2=0;
VAR_6.x_anchor=(unsigned short) 0xffff;
VAR_6.y_anchor=(unsigned short) 0xffff;
VAR_6.width=(short) VAR_1->columns;
if (VAR_1->columns % 16)
VAR_6.width=(short) (16*(VAR_1->columns/16+1));
VAR_6.height=(short) VAR_1->rows;
VAR_14=((VAR_12*VAR_1->columns+7)/8);
VAR_19=(unsigned char *) AcquireQuantumMemory(9UL*VAR_14,
VAR_1->rows*sizeof(*VAR_19));
if (VAR_19 == (unsigned char *) NULL)
ThrowWriterException(VAR_26,""MemoryAllocationFailed"");
VAR_18=(unsigned char *) AcquireQuantumMemory(256,sizeof(*VAR_18));
if (VAR_18 == (unsigned char *) NULL)
ThrowWriterException(VAR_26,""MemoryAllocationFailed"");
VAR_15=(size_t) (VAR_1->depth > 8 ? 2: 1);
VAR_20=(unsigned char *) AcquireQuantumMemory(VAR_1->columns,VAR_15*
sizeof(*VAR_20));
if (VAR_20 == (unsigned char *) NULL)
ThrowWriterException(VAR_26,""MemoryAllocationFailed"");
if (IssRGBCompatibleColorspace(VAR_1->colorspace) == VAR_22)
(void) TransformImageColorspace(VAR_1,VAR_25,VAR_2);
VAR_8=AcquireQuantumInfo(VAR_0,VAR_1);
if (VAR_8 == (QuantumInfo *) NULL)
ThrowWriterException(VAR_26,""MemoryAllocationFailed"");
VAR_4=8/(int) VAR_12-1;  
VAR_13=0;
VAR_16=0;
VAR_11=VAR_19;
VAR_18[0]=0x00;
for (VAR_17=0; VAR_17 < (ssize_t) VAR_1->rows; VAR_17++)
{
VAR_9=GetVirtualPixels(VAR_1,0,VAR_17,VAR_1->columns,1,VAR_2);
if (VAR_9 == (const Quantum *) NULL)
break;
(void) ExportQuantumPixels(VAR_1,(CacheView *) NULL,VAR_8,
VAR_27,VAR_20,VAR_2);
for (VAR_10=0; VAR_10 < (ssize_t) VAR_6.width; VAR_10++)
{
if (VAR_10 < (ssize_t) VAR_1->columns)
VAR_18[VAR_13+VAR_16]|=(0xff-VAR_20[VAR_10*VAR_15]) >>
(8-VAR_12) << VAR_4*VAR_12;
VAR_4--;
if (VAR_4 < 0)
{
if (((VAR_13+VAR_16) > 0) &&
(VAR_18[VAR_13+VAR_16] == VAR_18[VAR_13+VAR_16-1]))
{
if (VAR_16 == 0)
{
VAR_13--;
VAR_16++;
}
VAR_16++;
if (0x7f < VAR_16)
{
VAR_11=EncodeRLE(VAR_11,VAR_18,VAR_13,VAR_16);
VAR_13=0;
VAR_16=0;
}
}
else
{
if (VAR_16 >= 2)
VAR_13+=VAR_16;
else
{
VAR_11=EncodeRLE(VAR_11,VAR_18,VAR_13,VAR_16);
VAR_18[0]=VAR_18[VAR_13+VAR_16];
VAR_13=0;
}
VAR_13++;
VAR_16=0;
if (0x7f < VAR_13)
{
VAR_11=EncodeRLE(VAR_11,VAR_18,(VAR_13 < 0x80 ? VAR_13 : 0x80),0);
(void) CopyMagickMemory(VAR_18,VAR_18+VAR_13+VAR_16,0x80);
VAR_13-=0x80;
}
}
VAR_4=8/(int) VAR_12-1;
VAR_18[VAR_13+VAR_16]=0x00;
}
}
VAR_5=SetImageProgress(VAR_1,VAR_28,(MagickOffsetType) VAR_17,
VAR_1->rows);
if (VAR_5 == VAR_22)
break;
}
VAR_11=EncodeRLE(VAR_11,VAR_18,VAR_13,VAR_16);
VAR_20=(unsigned char *) RelinquishMagickMemory(VAR_20);
VAR_18=(unsigned char *) RelinquishMagickMemory(VAR_18);
VAR_8=DestroyQuantumInfo(VAR_8);
(void) WriteBlobMSBLong(VAR_1,(unsigned int)
(TellBlob(VAR_1)+8*VAR_7.number_records));
(void) WriteBlobByte(VAR_1,0x40);
(void) WriteBlobByte(VAR_1,0x6f);
(void) WriteBlobByte(VAR_1,0x80);
(void) WriteBlobByte(VAR_1,0);
if (VAR_7.number_records > 1)
{
(void) WriteBlobMSBLong(VAR_1,(unsigned int) (TellBlob(VAR_1)+8+58+VAR_11-
VAR_19));
(void) WriteBlobByte(VAR_1,0x40);
(void) WriteBlobByte(VAR_1,0x6f);
(void) WriteBlobByte(VAR_1,0x80);
(void) WriteBlobByte(VAR_1,1);
}
(void) WriteBlob(VAR_1,sizeof(VAR_6.name),(unsigned char *)
VAR_6.name);
(void) WriteBlobByte(VAR_1,(unsigned char) VAR_6.version);
(void) WriteBlobByte(VAR_1,VAR_6.type);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_6.reserved_1);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_6.note);
(void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_6.x_last);
(void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_6.y_last);
(void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_6.reserved_2);
(void) WriteBlobMSBShort(VAR_1,VAR_6.x_anchor);
(void) WriteBlobMSBShort(VAR_1,VAR_6.y_anchor);
(void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_6.width);
(void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_6.height);
(void) WriteBlob(VAR_1,(size_t) (VAR_11-VAR_19),VAR_19);
VAR_19=(unsigned char *) RelinquishMagickMemory(VAR_19);
if (VAR_7.number_records > 1)
(void) WriteBlobString(VAR_1,VAR_3);
(void) CloseBlob(VAR_1);
return(VAR_29);
}",ImageMagick/6d202a0514fb6a406456b8b728cde776becb25f8/pdb.c/vul/before/0.json,"static MagickBooleanType WritePDBImage(const ImageInfo *image_info,Image *image,
  ExceptionInfo *exception)
{
  const char
    *comment;

  int
    bits;

  MagickBooleanType
    status;

  PDBImage
    pdb_image;

  PDBInfo
    pdb_info;

  QuantumInfo
    *quantum_info;

  register const Quantum
    *p;

  register ssize_t
    x;

  register unsigned char
    *q;

  size_t
    bits_per_pixel,
    literal,
    packets,
    packet_size,
    repeat;

  ssize_t
    y;

  unsigned char
    *buffer,
    *runlength,
    *scanline;

  /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(status);
  (void) TransformImageColorspace(image,sRGBColorspace,exception);
  if (SetImageMonochrome(image,exception) != MagickFalse) {
    bits_per_pixel=1;
  } else if (image->colors <= 4) {
    bits_per_pixel=2;
  } else if (image->colors <= 8) {
    bits_per_pixel=3;
  } else {
    bits_per_pixel=4;
  }
  (void) ResetMagickMemory(&pdb_info,0,sizeof(pdb_info));
  (void) CopyMagickString(pdb_info.name,image_info->filename,
    sizeof(pdb_info.name));
  pdb_info.attributes=0;
  pdb_info.version=0;
  pdb_info.create_time=time(NULL);
  pdb_info.modify_time=pdb_info.create_time;
  pdb_info.archive_time=0;
  pdb_info.modify_number=0;
  pdb_info.application_info=0;
  pdb_info.sort_info=0;
  (void) CopyMagickMemory(pdb_info.type,""vIMG"",4);
  (void) CopyMagickMemory(pdb_info.id,""View"",4);
  pdb_info.seed=0;
  pdb_info.next_record=0;
  comment=GetImageProperty(image,""comment"",exception);
  pdb_info.number_records=(comment == (const char *) NULL ? 1 : 2);
  (void) WriteBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);
  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.attributes);
  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.version);
  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.create_time);
  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_time);
  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.archive_time);
  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_number);
  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.application_info);
  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.sort_info);
  (void) WriteBlob(image,4,(unsigned char *) pdb_info.type);
  (void) WriteBlob(image,4,(unsigned char *) pdb_info.id);
  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.seed);
  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.next_record);
  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.number_records);
  (void) CopyMagickString(pdb_image.name,pdb_info.name,sizeof(pdb_image.name));
  pdb_image.version=1;  /* RLE Compressed */
  switch (bits_per_pixel)
  {
    case 1: pdb_image.type=(unsigned char) 0xff; break;  /* monochrome */
    case 2: pdb_image.type=(unsigned char) 0x00; break;  /* 2 bit gray */
    default: pdb_image.type=(unsigned char) 0x02;  /* 4 bit gray */
  }
  pdb_image.reserved_1=0;
  pdb_image.note=0;
  pdb_image.x_last=0;
  pdb_image.y_last=0;
  pdb_image.reserved_2=0;
  pdb_image.x_anchor=(unsigned short) 0xffff;
  pdb_image.y_anchor=(unsigned short) 0xffff;
  pdb_image.width=(short) image->columns;
  if (image->columns % 16)
    pdb_image.width=(short) (16*(image->columns/16+1));
  pdb_image.height=(short) image->rows;
  packets=((bits_per_pixel*image->columns+7)/8);
  runlength=(unsigned char *) AcquireQuantumMemory(9UL*packets,
    image->rows*sizeof(*runlength));
  if (runlength == (unsigned char *) NULL)
    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
  buffer=(unsigned char *) AcquireQuantumMemory(257,sizeof(*buffer));
  if (buffer == (unsigned char *) NULL)
    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
  packet_size=(size_t) (image->depth > 8 ? 2: 1);
  scanline=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*
    sizeof(*scanline));
  if (scanline == (unsigned char *) NULL)
    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
    (void) TransformImageColorspace(image,sRGBColorspace,exception);
  /*
    Convert to GRAY raster scanline.
  */
  quantum_info=AcquireQuantumInfo(image_info,image);
  if (quantum_info == (QuantumInfo *) NULL)
    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
  bits=8/(int) bits_per_pixel-1;  /* start at most significant bits */
  literal=0;
  repeat=0;
  q=runlength;
  buffer[0]=0x00;
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    p=GetVirtualPixels(image,0,y,image->columns,1,exception);
    if (p == (const Quantum *) NULL)
      break;
    (void) ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,
      GrayQuantum,scanline,exception);
    for (x=0; x < (ssize_t) pdb_image.width; x++)
    {
      if (x < (ssize_t) image->columns)
        buffer[literal+repeat]|=(0xff-scanline[x*packet_size]) >>
          (8-bits_per_pixel) << bits*bits_per_pixel;
      bits--;
      if (bits < 0)
        {
          if (((literal+repeat) > 0) &&
              (buffer[literal+repeat] == buffer[literal+repeat-1]))
            {
              if (repeat == 0)
                {
                  literal--;
                  repeat++;
                }
              repeat++;
              if (0x7f < repeat)
                {
                  q=EncodeRLE(q,buffer,literal,repeat);
                  literal=0;
                  repeat=0;
                }
            }
          else
            {
              if (repeat >= 2)
                literal+=repeat;
              else
                {
                  q=EncodeRLE(q,buffer,literal,repeat);
                  buffer[0]=buffer[literal+repeat];
                  literal=0;
                }
              literal++;
              repeat=0;
              if (0x7f < literal)
                {
                  q=EncodeRLE(q,buffer,(literal < 0x80 ? literal : 0x80),0);
                  (void) CopyMagickMemory(buffer,buffer+literal+repeat,0x80);
                  literal-=0x80;
                }
            }
        bits=8/(int) bits_per_pixel-1;
        buffer[literal+repeat]=0x00;
      }
    }
    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
      image->rows);
    if (status == MagickFalse)
      break;
  }
  q=EncodeRLE(q,buffer,literal,repeat);
  scanline=(unsigned char *) RelinquishMagickMemory(scanline);
  buffer=(unsigned char *) RelinquishMagickMemory(buffer);
  quantum_info=DestroyQuantumInfo(quantum_info);
  /*
    Write the Image record header.
  */
  (void) WriteBlobMSBLong(image,(unsigned int)
    (TellBlob(image)+8*pdb_info.number_records));
  (void) WriteBlobByte(image,0x40);
  (void) WriteBlobByte(image,0x6f);
  (void) WriteBlobByte(image,0x80);
  (void) WriteBlobByte(image,0);
  if (pdb_info.number_records > 1)
    {
      /*
        Write the comment record header.
      */
      (void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8+58+q-
        runlength));
      (void) WriteBlobByte(image,0x40);
      (void) WriteBlobByte(image,0x6f);
      (void) WriteBlobByte(image,0x80);
      (void) WriteBlobByte(image,1);
    }
  /*
    Write the Image data.
  */
  (void) WriteBlob(image,sizeof(pdb_image.name),(unsigned char *)
    pdb_image.name);
  (void) WriteBlobByte(image,(unsigned char) pdb_image.version);
  (void) WriteBlobByte(image,pdb_image.type);
  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_1);
  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.note);
  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.x_last);
  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.y_last);
  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_2);
  (void) WriteBlobMSBShort(image,pdb_image.x_anchor);
  (void) WriteBlobMSBShort(image,pdb_image.y_anchor);
  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.width);
  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.height);
  (void) WriteBlob(image,(size_t) (q-runlength),runlength);
  runlength=(unsigned char *) RelinquishMagickMemory(runlength);
  if (pdb_info.number_records > 1)
    (void) WriteBlobString(image,comment);
  (void) CloseBlob(image);
  return(MagickTrue);
}","static MagickBooleanType WritePDBImage(const ImageInfo *VAR_0,Image *VAR_1,
  ExceptionInfo *VAR_2)
{
  const char
    *VAR_3;

  int
    VAR_4;

  MagickBooleanType
    VAR_5;

  PDBImage
    VAR_6;

  PDBInfo
    VAR_7;

  QuantumInfo
    *VAR_8;

  register const Quantum
    *VAR_9;

  register ssize_t
    VAR_10;

  register unsigned char
    *VAR_11;

  size_t
    VAR_12,
    VAR_13,
    VAR_14,
    VAR_15,
    VAR_16;

  ssize_t
    VAR_17;

  unsigned char
    *VAR_18,
    *VAR_19,
    *VAR_20;

  /* COMMENT_0 */
                           
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_21);
  assert(VAR_1 != (Image *) NULL);
  assert(VAR_1->signature == VAR_21);
  if (VAR_1->debug != VAR_22)
    (void) LogMagickEvent(VAR_23,GetMagickModule(),""%s"",VAR_1->filename);
  assert(VAR_2 != (ExceptionInfo *) NULL);
  assert(VAR_2->signature == VAR_21);
  VAR_5=OpenBlob(VAR_0,VAR_1,VAR_24,VAR_2);
  if (VAR_5 == VAR_22)
    return(VAR_5);
  (void) TransformImageColorspace(VAR_1,VAR_25,VAR_2);
  if (SetImageMonochrome(VAR_1,VAR_2) != VAR_22) {
    VAR_12=1;
  } else if (VAR_1->colors <= 4) {
    VAR_12=2;
  } else if (VAR_1->colors <= 8) {
    VAR_12=3;
  } else {
    VAR_12=4;
  }
  (void) ResetMagickMemory(&VAR_7,0,sizeof(VAR_7));
  (void) CopyMagickString(VAR_7.name,VAR_0->filename,
    sizeof(VAR_7.name));
  VAR_7.attributes=0;
  VAR_7.version=0;
  VAR_7.create_time=time(NULL);
  VAR_7.modify_time=VAR_7.create_time;
  VAR_7.archive_time=0;
  VAR_7.modify_number=0;
  VAR_7.application_info=0;
  VAR_7.sort_info=0;
  (void) CopyMagickMemory(VAR_7.type,""vIMG"",4);
  (void) CopyMagickMemory(VAR_7.id,""View"",4);
  VAR_7.seed=0;
  VAR_7.next_record=0;
  VAR_3=GetImageProperty(VAR_1,""comment"",VAR_2);
  VAR_7.number_records=(VAR_3 == (const char *) NULL ? 1 : 2);
  (void) WriteBlob(VAR_1,sizeof(VAR_7.name),(unsigned char *) VAR_7.name);
  (void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_7.attributes);
  (void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_7.version);
  (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_7.create_time);
  (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_7.modify_time);
  (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_7.archive_time);
  (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_7.modify_number);
  (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_7.application_info);
  (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_7.sort_info);
  (void) WriteBlob(VAR_1,4,(unsigned char *) VAR_7.type);
  (void) WriteBlob(VAR_1,4,(unsigned char *) VAR_7.id);
  (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_7.seed);
  (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_7.next_record);
  (void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_7.number_records);
  (void) CopyMagickString(VAR_6.name,VAR_7.name,sizeof(VAR_6.name));
  VAR_6.version=1;  /* COMMENT_3 */
  switch (VAR_12)
  {
    case 1: VAR_6.type=(unsigned char) 0xff; break;  /* COMMENT_4 */
    case 2: VAR_6.type=(unsigned char) 0x00; break;  /* COMMENT_5 */
    default: VAR_6.type=(unsigned char) 0x02;  /* COMMENT_6 */
  }
  VAR_6.reserved_1=0;
  VAR_6.note=0;
  VAR_6.x_last=0;
  VAR_6.y_last=0;
  VAR_6.reserved_2=0;
  VAR_6.x_anchor=(unsigned short) 0xffff;
  VAR_6.y_anchor=(unsigned short) 0xffff;
  VAR_6.width=(short) VAR_1->columns;
  if (VAR_1->columns % 16)
    VAR_6.width=(short) (16*(VAR_1->columns/16+1));
  VAR_6.height=(short) VAR_1->rows;
  VAR_14=((VAR_12*VAR_1->columns+7)/8);
  VAR_19=(unsigned char *) AcquireQuantumMemory(9UL*VAR_14,
    VAR_1->rows*sizeof(*VAR_19));
  if (VAR_19 == (unsigned char *) NULL)
    ThrowWriterException(VAR_26,""MemoryAllocationFailed"");
  VAR_18=(unsigned char *) AcquireQuantumMemory(257,sizeof(*VAR_18));
  if (VAR_18 == (unsigned char *) NULL)
    ThrowWriterException(VAR_26,""MemoryAllocationFailed"");
  VAR_15=(size_t) (VAR_1->depth > 8 ? 2: 1);
  VAR_20=(unsigned char *) AcquireQuantumMemory(VAR_1->columns,VAR_15*
    sizeof(*VAR_20));
  if (VAR_20 == (unsigned char *) NULL)
    ThrowWriterException(VAR_26,""MemoryAllocationFailed"");
  if (IssRGBCompatibleColorspace(VAR_1->colorspace) == VAR_22)
    (void) TransformImageColorspace(VAR_1,VAR_25,VAR_2);
  /* COMMENT_7 */
                                    
    
  VAR_8=AcquireQuantumInfo(VAR_0,VAR_1);
  if (VAR_8 == (QuantumInfo *) NULL)
    ThrowWriterException(VAR_26,""MemoryAllocationFailed"");
  VAR_4=8/(int) VAR_12-1;  /* COMMENT_10 */
  VAR_13=0;
  VAR_16=0;
  VAR_11=VAR_19;
  VAR_18[0]=0x00;
  for (VAR_17=0; VAR_17 < (ssize_t) VAR_1->rows; VAR_17++)
  {
    VAR_9=GetVirtualPixels(VAR_1,0,VAR_17,VAR_1->columns,1,VAR_2);
    if (VAR_9 == (const Quantum *) NULL)
      break;
    (void) ExportQuantumPixels(VAR_1,(CacheView *) NULL,VAR_8,
      VAR_27,VAR_20,VAR_2);
    for (VAR_10=0; VAR_10 < (ssize_t) VAR_6.width; VAR_10++)
    {
      if (VAR_10 < (ssize_t) VAR_1->columns)
        VAR_18[VAR_13+VAR_16]|=(0xff-VAR_20[VAR_10*VAR_15]) >>
          (8-VAR_12) << VAR_4*VAR_12;
      VAR_4--;
      if (VAR_4 < 0)
        {
          if (((VAR_13+VAR_16) > 0) &&
              (VAR_18[VAR_13+VAR_16] == VAR_18[VAR_13+VAR_16-1]))
            {
              if (VAR_16 == 0)
                {
                  VAR_13--;
                  VAR_16++;
                }
              VAR_16++;
              if (0x7f < VAR_16)
                {
                  VAR_11=EncodeRLE(VAR_11,VAR_18,VAR_13,VAR_16);
                  VAR_13=0;
                  VAR_16=0;
                }
            }
          else
            {
              if (VAR_16 >= 2)
                VAR_13+=VAR_16;
              else
                {
                  VAR_11=EncodeRLE(VAR_11,VAR_18,VAR_13,VAR_16);
                  VAR_18[0]=VAR_18[VAR_13+VAR_16];
                  VAR_13=0;
                }
              VAR_13++;
              VAR_16=0;
              if (0x7f < VAR_13)
                {
                  VAR_11=EncodeRLE(VAR_11,VAR_18,(VAR_13 < 0x80 ? VAR_13 : 0x80),0);
                  (void) CopyMagickMemory(VAR_18,VAR_18+VAR_13+VAR_16,0x80);
                  VAR_13-=0x80;
                }
            }
        VAR_4=8/(int) VAR_12-1;
        VAR_18[VAR_13+VAR_16]=0x00;
      }
    }
    VAR_5=SetImageProgress(VAR_1,VAR_28,(MagickOffsetType) VAR_17,
      VAR_1->rows);
    if (VAR_5 == VAR_22)
      break;
  }
  VAR_11=EncodeRLE(VAR_11,VAR_18,VAR_13,VAR_16);
  VAR_20=(unsigned char *) RelinquishMagickMemory(VAR_20);
  VAR_18=(unsigned char *) RelinquishMagickMemory(VAR_18);
  VAR_8=DestroyQuantumInfo(VAR_8);
  /* COMMENT_11 */
                                  
    
  (void) WriteBlobMSBLong(VAR_1,(unsigned int)
    (TellBlob(VAR_1)+8*VAR_7.number_records));
  (void) WriteBlobByte(VAR_1,0x40);
  (void) WriteBlobByte(VAR_1,0x6f);
  (void) WriteBlobByte(VAR_1,0x80);
  (void) WriteBlobByte(VAR_1,0);
  if (VAR_7.number_records > 1)
    {
      /* COMMENT_14 */
                                        
        
      (void) WriteBlobMSBLong(VAR_1,(unsigned int) (TellBlob(VAR_1)+8+58+VAR_11-
        VAR_19));
      (void) WriteBlobByte(VAR_1,0x40);
      (void) WriteBlobByte(VAR_1,0x6f);
      (void) WriteBlobByte(VAR_1,0x80);
      (void) WriteBlobByte(VAR_1,1);
    }
  /* COMMENT_17 */
                         
    
  (void) WriteBlob(VAR_1,sizeof(VAR_6.name),(unsigned char *)
    VAR_6.name);
  (void) WriteBlobByte(VAR_1,(unsigned char) VAR_6.version);
  (void) WriteBlobByte(VAR_1,VAR_6.type);
  (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_6.reserved_1);
  (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_6.note);
  (void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_6.x_last);
  (void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_6.y_last);
  (void) WriteBlobMSBLong(VAR_1,(unsigned int) VAR_6.reserved_2);
  (void) WriteBlobMSBShort(VAR_1,VAR_6.x_anchor);
  (void) WriteBlobMSBShort(VAR_1,VAR_6.y_anchor);
  (void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_6.width);
  (void) WriteBlobMSBShort(VAR_1,(unsigned short) VAR_6.height);
  (void) WriteBlob(VAR_1,(size_t) (VAR_11-VAR_19),VAR_19);
  VAR_19=(unsigned char *) RelinquishMagickMemory(VAR_19);
  if (VAR_7.number_records > 1)
    (void) WriteBlobString(VAR_1,VAR_3);
  (void) CloseBlob(VAR_1);
  return(VAR_29);
}",ImageMagick/6d202a0514fb6a406456b8b728cde776becb25f8/pdb.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -122,7 +122,7 @@
     image->rows*sizeof(*runlength));
   if (runlength == (unsigned char *) NULL)
     ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
-  buffer=(unsigned char *) AcquireQuantumMemory(256,sizeof(*buffer));
+  buffer=(unsigned char *) AcquireQuantumMemory(257,sizeof(*buffer));
   if (buffer == (unsigned char *) NULL)
     ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
   packet_size=(size_t) (image->depth > 8 ? 2: 1);","{'deleted_lines': ['  buffer=(unsigned char *) AcquireQuantumMemory(256,sizeof(*buffer));'], 'added_lines': ['  buffer=(unsigned char *) AcquireQuantumMemory(257,sizeof(*buffer));']}",True,MagickCore/memory.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds access) via a crafted PDB file.,6.5,MEDIUM,1,test,2016-03-07T12:13:10Z,1
CVE-2016-7537,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/143,6d202a0514fb6a406456b8b728cde776becb25f8,https://github.com/ImageMagick/ImageMagick/commit/6d202a0514fb6a406456b8b728cde776becb25f8,coders/pdb.c,ReadPDBImage,"static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
unsigned char
attributes,
tag[3];
Image
*image;
MagickBooleanType
status;
PDBImage
pdb_image;
PDBInfo
pdb_info;
Quantum
index;
register ssize_t
x;
register Quantum
*q;
register unsigned char
*p;
size_t
bits_per_pixel,
num_pad_bytes,
one,
packets;
ssize_t
count,
img_offset,
comment_offset = 0,
y;
unsigned char
*pixels;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
image=AcquireImage(image_info,exception);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
count=ReadBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);
if (count != sizeof(pdb_info.name))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
pdb_info.attributes=(short) ReadBlobMSBShort(image);
pdb_info.version=(short) ReadBlobMSBShort(image);
pdb_info.create_time=ReadBlobMSBLong(image);
pdb_info.modify_time=ReadBlobMSBLong(image);
pdb_info.archive_time=ReadBlobMSBLong(image);
pdb_info.modify_number=ReadBlobMSBLong(image);
pdb_info.application_info=ReadBlobMSBLong(image);
pdb_info.sort_info=ReadBlobMSBLong(image);
(void) ReadBlob(image,4,(unsigned char *) pdb_info.type);
(void) ReadBlob(image,4,(unsigned char *) pdb_info.id);
pdb_info.seed=ReadBlobMSBLong(image);
pdb_info.next_record=ReadBlobMSBLong(image);
pdb_info.number_records=(short) ReadBlobMSBShort(image);
if ((memcmp(pdb_info.type,""vIMG"",4) != 0) ||
(memcmp(pdb_info.id,""View"",4) != 0))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
if (pdb_info.next_record != 0)
ThrowReaderException(CoderError,""MultipleRecordListNotSupported"");
img_offset=(ssize_t) ((int) ReadBlobMSBLong(image));
attributes=(unsigned char) ReadBlobByte(image);
(void) attributes;
count=ReadBlob(image,3,(unsigned char *) tag);
if (count != 3  ||  memcmp(tag,""\x6f\x80\x00"",3) != 0)
ThrowReaderException(CorruptImageError,""CorruptImage"");
if (pdb_info.number_records > 1)
{
comment_offset=(ssize_t) ((int) ReadBlobMSBLong(image));
attributes=(unsigned char) ReadBlobByte(image);
count=ReadBlob(image,3,(unsigned char *) tag);
if (count != 3  ||  memcmp(tag,""\x6f\x80\x01"",3) != 0)
ThrowReaderException(CorruptImageError,""CorruptImage"");
}
num_pad_bytes = (size_t) (img_offset - TellBlob( image ));
while (num_pad_bytes-- != 0)
{
int
c;
c=ReadBlobByte(image);
if (c == EOF)
break;
}
count=ReadBlob(image,sizeof(pdb_image.name),(unsigned char *) pdb_image.name);
if (count != sizeof(pdb_image.name))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
pdb_image.version=ReadBlobByte(image);
pdb_image.type=(unsigned char) ((int) ReadBlobByte(image));
pdb_image.reserved_1=ReadBlobMSBLong(image);
pdb_image.note=ReadBlobMSBLong(image);
pdb_image.x_last=(short) ReadBlobMSBShort(image);
pdb_image.y_last=(short) ReadBlobMSBShort(image);
pdb_image.reserved_2=ReadBlobMSBLong(image);
pdb_image.x_anchor=ReadBlobMSBShort(image);
pdb_image.y_anchor=ReadBlobMSBShort(image);
pdb_image.width=(short) ReadBlobMSBShort(image);
pdb_image.height=(short) ReadBlobMSBShort(image);
image->columns=(size_t) pdb_image.width;
image->rows=(size_t) pdb_image.height;
image->depth=8;
status=SetImageExtent(image,image->columns,image->rows,exception);
if (status == MagickFalse)
return(DestroyImageList(image));
image->storage_class=PseudoClass;
bits_per_pixel=pdb_image.type == 0 ? 2UL : pdb_image.type == 2 ? 4UL : 1UL;
one=1;
if (AcquireImageColormap(image,one << bits_per_pixel,exception) == MagickFalse)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
if (image_info->ping != MagickFalse)
{
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}
packets=(bits_per_pixel*image->columns+7)/8;
pixels=(unsigned char *) AcquireQuantumMemory(packets+256UL,image->rows*
sizeof(*pixels));
if (pixels == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
switch (pdb_image.version & 0x07) 
{
case 0:
{
image->compression=NoCompression;
count=(ssize_t) ReadBlob(image, packets * image -> rows, pixels);
break;
}
case 1:
{
image->compression=RLECompression;
if (!DecodeImage(image, pixels, packets * image -> rows))
ThrowReaderException( CorruptImageError, ""RLEDecoderError"" );
break;
}
default:
ThrowReaderException(CorruptImageError,
""UnrecognizedImageCompressionType"" );
}
p=pixels;
switch (bits_per_pixel)
{
case 1:
{
int
bit;
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < ((ssize_t) image->columns-7); x+=8)
{
for (bit=0; bit < 8; bit++)
{
index=(Quantum) (*p & (0x80 >> bit) ? 0x00 : 0x01);
SetPixelIndex(image,index,q);
q+=GetPixelChannels(image);
}
p++;
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
(void) SyncImage(image,exception);
break;
}
case 2:
{
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns-3; x+=4)
{
index=ConstrainColormapIndex(image,3UL-((*p >> 6) & 0x03),exception);
SetPixelIndex(image,index,q);
q+=GetPixelChannels(image);
index=ConstrainColormapIndex(image,3UL-((*p >> 4) & 0x03),exception);
SetPixelIndex(image,index,q);
q+=GetPixelChannels(image);
index=ConstrainColormapIndex(image,3UL-((*p >> 2) & 0x03),exception);
SetPixelIndex(image,index,q);
q+=GetPixelChannels(image);
index=ConstrainColormapIndex(image,3UL-((*p) & 0x03),exception);
SetPixelIndex(image,index,q);
p++;
q+=GetPixelChannels(image);
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
(void) SyncImage(image,exception);
break;
}
case 4:
{
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns-1; x+=2)
{
index=ConstrainColormapIndex(image,15UL-((*p >> 4) & 0x0f),exception);
SetPixelIndex(image,index,q);
q+=GetPixelChannels(image);
index=ConstrainColormapIndex(image,15UL-((*p) & 0x0f),exception);
SetPixelIndex(image,index,q);
p++;
q+=GetPixelChannels(image);
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
(void) SyncImage(image,exception);
break;
}
default:
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
}
pixels=(unsigned char *) RelinquishMagickMemory(pixels);
if (EOFBlob(image) != MagickFalse)
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
if (pdb_info.number_records > 1)
{
char
*comment;
int
c;
register char
*p;
size_t
length;
num_pad_bytes = (size_t) (comment_offset - TellBlob( image ));
while (num_pad_bytes--) ReadBlobByte( image );
c=ReadBlobByte(image);
length=MagickPathExtent;
comment=AcquireString((char *) NULL);
for (p=comment; c != EOF; p++)
{
if ((size_t) (p-comment+MagickPathExtent) >= length)
{
*p='\0';
length<<=1;
length+=MagickPathExtent;
comment=(char *) ResizeQuantumMemory(comment,length+MagickPathExtent,
sizeof(*comment));
if (comment == (char *) NULL)
break;
p=comment+strlen(comment);
}
*p=c;
c=ReadBlobByte(image);
}
*p='\0';
if (comment == (char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
(void) SetImageProperty(image,""comment"",comment,exception);
comment=DestroyString(comment);
}
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}","static Image *ReadPDBImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
unsigned char
VAR_2,
VAR_3[3];
Image
*VAR_4;
MagickBooleanType
VAR_5;
PDBImage
VAR_6;
PDBInfo
VAR_7;
Quantum
VAR_8;
register ssize_t
VAR_9;
register Quantum
*VAR_10;
register unsigned char
*VAR_11;
size_t
VAR_12,
VAR_13,
VAR_14,
VAR_15;
ssize_t
VAR_16,
VAR_17,
VAR_18 = 0,
VAR_19;
unsigned char
*VAR_20;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_21);
if (VAR_0->debug != VAR_22)
(void) LogMagickEvent(VAR_23,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_21);
VAR_4=AcquireImage(VAR_0,VAR_1);
VAR_5=OpenBlob(VAR_0,VAR_4,VAR_24,VAR_1);
if (VAR_5 == VAR_22)
{
VAR_4=DestroyImageList(VAR_4);
return((Image *) NULL);
}
VAR_16=ReadBlob(VAR_4,sizeof(VAR_7.name),(unsigned char *) VAR_7.name);
if (VAR_16 != sizeof(VAR_7.name))
ThrowReaderException(VAR_25,""ImproperImageHeader"");
VAR_7.attributes=(short) ReadBlobMSBShort(VAR_4);
VAR_7.version=(short) ReadBlobMSBShort(VAR_4);
VAR_7.create_time=ReadBlobMSBLong(VAR_4);
VAR_7.modify_time=ReadBlobMSBLong(VAR_4);
VAR_7.archive_time=ReadBlobMSBLong(VAR_4);
VAR_7.modify_number=ReadBlobMSBLong(VAR_4);
VAR_7.application_info=ReadBlobMSBLong(VAR_4);
VAR_7.sort_info=ReadBlobMSBLong(VAR_4);
(void) ReadBlob(VAR_4,4,(unsigned char *) VAR_7.type);
(void) ReadBlob(VAR_4,4,(unsigned char *) VAR_7.id);
VAR_7.seed=ReadBlobMSBLong(VAR_4);
VAR_7.next_record=ReadBlobMSBLong(VAR_4);
VAR_7.number_records=(short) ReadBlobMSBShort(VAR_4);
if ((memcmp(VAR_7.type,""vIMG"",4) != 0) ||
(memcmp(VAR_7.id,""View"",4) != 0))
ThrowReaderException(VAR_25,""ImproperImageHeader"");
if (VAR_7.next_record != 0)
ThrowReaderException(VAR_26,""MultipleRecordListNotSupported"");
VAR_17=(ssize_t) ((int) ReadBlobMSBLong(VAR_4));
VAR_2=(unsigned char) ReadBlobByte(VAR_4);
(void) VAR_2;
VAR_16=ReadBlob(VAR_4,3,(unsigned char *) VAR_3);
if (VAR_16 != 3  ||  memcmp(VAR_3,""\x6f\x80\x00"",3) != 0)
ThrowReaderException(VAR_25,""CorruptImage"");
if (VAR_7.number_records > 1)
{
VAR_18=(ssize_t) ((int) ReadBlobMSBLong(VAR_4));
VAR_2=(unsigned char) ReadBlobByte(VAR_4);
VAR_16=ReadBlob(VAR_4,3,(unsigned char *) VAR_3);
if (VAR_16 != 3  ||  memcmp(VAR_3,""\x6f\x80\x01"",3) != 0)
ThrowReaderException(VAR_25,""CorruptImage"");
}
VAR_13 = (size_t) (VAR_17 - TellBlob( VAR_4 ));
while (VAR_13-- != 0)
{
int
VAR_27;
VAR_27=ReadBlobByte(VAR_4);
if (VAR_27 == VAR_28)
break;
}
VAR_16=ReadBlob(VAR_4,sizeof(VAR_6.name),(unsigned char *) VAR_6.name);
if (VAR_16 != sizeof(VAR_6.name))
ThrowReaderException(VAR_25,""ImproperImageHeader"");
VAR_6.version=ReadBlobByte(VAR_4);
VAR_6.type=(unsigned char) ((int) ReadBlobByte(VAR_4));
VAR_6.reserved_1=ReadBlobMSBLong(VAR_4);
VAR_6.note=ReadBlobMSBLong(VAR_4);
VAR_6.x_last=(short) ReadBlobMSBShort(VAR_4);
VAR_6.y_last=(short) ReadBlobMSBShort(VAR_4);
VAR_6.reserved_2=ReadBlobMSBLong(VAR_4);
VAR_6.x_anchor=ReadBlobMSBShort(VAR_4);
VAR_6.y_anchor=ReadBlobMSBShort(VAR_4);
VAR_6.width=(short) ReadBlobMSBShort(VAR_4);
VAR_6.height=(short) ReadBlobMSBShort(VAR_4);
VAR_4->columns=(size_t) VAR_6.width;
VAR_4->rows=(size_t) VAR_6.height;
VAR_4->depth=8;
VAR_5=SetImageExtent(VAR_4,VAR_4->columns,VAR_4->rows,VAR_1);
if (VAR_5 == VAR_22)
return(DestroyImageList(VAR_4));
VAR_4->storage_class=VAR_29;
VAR_12=VAR_6.type == 0 ? 2UL : VAR_6.type == 2 ? 4UL : 1UL;
VAR_14=1;
if (AcquireImageColormap(VAR_4,VAR_14 << VAR_12,VAR_1) == VAR_22)
ThrowReaderException(VAR_30,""MemoryAllocationFailed"");
if (VAR_0->ping != VAR_22)
{
(void) CloseBlob(VAR_4);
return(GetFirstImageInList(VAR_4));
}
VAR_15=(VAR_12*VAR_4->columns+7)/8;
VAR_20=(unsigned char *) AcquireQuantumMemory(VAR_15+256UL,VAR_4->rows*
sizeof(*VAR_20));
if (VAR_20 == (unsigned char *) NULL)
ThrowReaderException(VAR_30,""MemoryAllocationFailed"");
switch (VAR_6.version & 0x07) 
{
case 0:
{
VAR_4->compression=VAR_31;
VAR_16=(ssize_t) ReadBlob(VAR_4, VAR_15 * VAR_4 -> rows, VAR_20);
break;
}
case 1:
{
VAR_4->compression=VAR_32;
if (!DecodeImage(VAR_4, VAR_20, VAR_15 * VAR_4 -> rows))
ThrowReaderException( VAR_25, ""RLEDecoderError"" );
break;
}
default:
ThrowReaderException(VAR_25,
""UnrecognizedImageCompressionType"" );
}
VAR_11=VAR_20;
switch (VAR_12)
{
case 1:
{
int
VAR_33;
for (VAR_19=0; VAR_19 < (ssize_t) VAR_4->rows; VAR_19++)
{
VAR_10=QueueAuthenticPixels(VAR_4,0,VAR_19,VAR_4->columns,1,VAR_1);
if (VAR_10 == (Quantum *) NULL)
break;
for (VAR_9=0; VAR_9 < ((ssize_t) VAR_4->columns-7); VAR_9+=8)
{
for (VAR_33=0; VAR_33 < 8; VAR_33++)
{
VAR_8=(Quantum) (*VAR_11 & (0x80 >> VAR_33) ? 0x00 : 0x01);
SetPixelIndex(VAR_4,VAR_8,VAR_10);
VAR_10+=GetPixelChannels(VAR_4);
}
VAR_11++;
}
if (SyncAuthenticPixels(VAR_4,VAR_1) == VAR_22)
break;
VAR_5=SetImageProgress(VAR_4,VAR_34,(MagickOffsetType) VAR_19,
VAR_4->rows);
if (VAR_5 == VAR_22)
break;
}
(void) SyncImage(VAR_4,VAR_1);
break;
}
case 2:
{
for (VAR_19=0; VAR_19 < (ssize_t) VAR_4->rows; VAR_19++)
{
VAR_10=QueueAuthenticPixels(VAR_4,0,VAR_19,VAR_4->columns,1,VAR_1);
if (VAR_10 == (Quantum *) NULL)
break;
for (VAR_9=0; VAR_9 < (ssize_t) VAR_4->columns-3; VAR_9+=4)
{
VAR_8=ConstrainColormapIndex(VAR_4,3UL-((*VAR_11 >> 6) & 0x03),VAR_1);
SetPixelIndex(VAR_4,VAR_8,VAR_10);
VAR_10+=GetPixelChannels(VAR_4);
VAR_8=ConstrainColormapIndex(VAR_4,3UL-((*VAR_11 >> 4) & 0x03),VAR_1);
SetPixelIndex(VAR_4,VAR_8,VAR_10);
VAR_10+=GetPixelChannels(VAR_4);
VAR_8=ConstrainColormapIndex(VAR_4,3UL-((*VAR_11 >> 2) & 0x03),VAR_1);
SetPixelIndex(VAR_4,VAR_8,VAR_10);
VAR_10+=GetPixelChannels(VAR_4);
VAR_8=ConstrainColormapIndex(VAR_4,3UL-((*VAR_11) & 0x03),VAR_1);
SetPixelIndex(VAR_4,VAR_8,VAR_10);
VAR_11++;
VAR_10+=GetPixelChannels(VAR_4);
}
if (SyncAuthenticPixels(VAR_4,VAR_1) == VAR_22)
break;
VAR_5=SetImageProgress(VAR_4,VAR_34,(MagickOffsetType) VAR_19,
VAR_4->rows);
if (VAR_5 == VAR_22)
break;
}
(void) SyncImage(VAR_4,VAR_1);
break;
}
case 4:
{
for (VAR_19=0; VAR_19 < (ssize_t) VAR_4->rows; VAR_19++)
{
VAR_10=QueueAuthenticPixels(VAR_4,0,VAR_19,VAR_4->columns,1,VAR_1);
if (VAR_10 == (Quantum *) NULL)
break;
for (VAR_9=0; VAR_9 < (ssize_t) VAR_4->columns-1; VAR_9+=2)
{
VAR_8=ConstrainColormapIndex(VAR_4,15UL-((*VAR_11 >> 4) & 0x0f),VAR_1);
SetPixelIndex(VAR_4,VAR_8,VAR_10);
VAR_10+=GetPixelChannels(VAR_4);
VAR_8=ConstrainColormapIndex(VAR_4,15UL-((*VAR_11) & 0x0f),VAR_1);
SetPixelIndex(VAR_4,VAR_8,VAR_10);
VAR_11++;
VAR_10+=GetPixelChannels(VAR_4);
}
if (SyncAuthenticPixels(VAR_4,VAR_1) == VAR_22)
break;
VAR_5=SetImageProgress(VAR_4,VAR_34,(MagickOffsetType) VAR_19,
VAR_4->rows);
if (VAR_5 == VAR_22)
break;
}
(void) SyncImage(VAR_4,VAR_1);
break;
}
default:
ThrowReaderException(VAR_25,""ImproperImageHeader"");
}
VAR_20=(unsigned char *) RelinquishMagickMemory(VAR_20);
if (EOFBlob(VAR_4) != VAR_22)
ThrowFileException(VAR_1,VAR_25,""UnexpectedEndOfFile"",
VAR_4->filename);
if (VAR_7.number_records > 1)
{
char
*VAR_35;
int
VAR_27;
register char
*VAR_11;
size_t
VAR_36;
VAR_13 = (size_t) (VAR_18 - TellBlob( VAR_4 ));
while (VAR_13--) ReadBlobByte( VAR_4 );
VAR_27=ReadBlobByte(VAR_4);
VAR_36=VAR_37;
VAR_35=AcquireString((char *) NULL);
for (VAR_11=VAR_35; VAR_27 != VAR_28; VAR_11++)
{
if ((size_t) (VAR_11-VAR_35+VAR_37) >= VAR_36)
{
*VAR_11='\0';
VAR_36<<=1;
VAR_36+=VAR_37;
VAR_35=(char *) ResizeQuantumMemory(VAR_35,VAR_36+VAR_37,
sizeof(*VAR_35));
if (VAR_35 == (char *) NULL)
break;
VAR_11=VAR_35+strlen(VAR_35);
}
*VAR_11=VAR_27;
VAR_27=ReadBlobByte(VAR_4);
}
*VAR_11='\0';
if (VAR_35 == (char *) NULL)
ThrowReaderException(VAR_30,""MemoryAllocationFailed"");
(void) SetImageProperty(VAR_4,""comment"",VAR_35,VAR_1);
VAR_35=DestroyString(VAR_35);
}
(void) CloseBlob(VAR_4);
return(GetFirstImageInList(VAR_4));
}",ImageMagick/6d202a0514fb6a406456b8b728cde776becb25f8/pdb.c/vul/before/1.json,"static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  unsigned char
    attributes,
    tag[3];

  Image
    *image;

  MagickBooleanType
    status;

  PDBImage
    pdb_image;

  PDBInfo
    pdb_info;

  Quantum
    index;

  register ssize_t
    x;

  register Quantum
    *q;

  register unsigned char
    *p;

  size_t
    bits_per_pixel,
    num_pad_bytes,
    one,
    packets;

  ssize_t
    count,
    img_offset,
    comment_offset = 0,
    y;

  unsigned char
    *pixels;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Determine if this a PDB image file.
  */
  count=ReadBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);
  if (count != sizeof(pdb_info.name))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  pdb_info.attributes=(short) ReadBlobMSBShort(image);
  pdb_info.version=(short) ReadBlobMSBShort(image);
  pdb_info.create_time=ReadBlobMSBLong(image);
  pdb_info.modify_time=ReadBlobMSBLong(image);
  pdb_info.archive_time=ReadBlobMSBLong(image);
  pdb_info.modify_number=ReadBlobMSBLong(image);
  pdb_info.application_info=ReadBlobMSBLong(image);
  pdb_info.sort_info=ReadBlobMSBLong(image);
  (void) ReadBlob(image,4,(unsigned char *) pdb_info.type);
  (void) ReadBlob(image,4,(unsigned char *) pdb_info.id);
  pdb_info.seed=ReadBlobMSBLong(image);
  pdb_info.next_record=ReadBlobMSBLong(image);
  pdb_info.number_records=(short) ReadBlobMSBShort(image);
  if ((memcmp(pdb_info.type,""vIMG"",4) != 0) ||
      (memcmp(pdb_info.id,""View"",4) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (pdb_info.next_record != 0)
    ThrowReaderException(CoderError,""MultipleRecordListNotSupported"");
  /*
    Read record header.
  */
  img_offset=(ssize_t) ((int) ReadBlobMSBLong(image));
  attributes=(unsigned char) ReadBlobByte(image);
  (void) attributes;
  count=ReadBlob(image,3,(unsigned char *) tag);
  if (count != 3  ||  memcmp(tag,""\x6f\x80\x00"",3) != 0)
    ThrowReaderException(CorruptImageError,""CorruptImage"");
  if (pdb_info.number_records > 1)
    {
      comment_offset=(ssize_t) ((int) ReadBlobMSBLong(image));
      attributes=(unsigned char) ReadBlobByte(image);
      count=ReadBlob(image,3,(unsigned char *) tag);
      if (count != 3  ||  memcmp(tag,""\x6f\x80\x01"",3) != 0)
        ThrowReaderException(CorruptImageError,""CorruptImage"");
    }
  num_pad_bytes = (size_t) (img_offset - TellBlob( image ));
  while (num_pad_bytes-- != 0)
  {
    int
      c;

    c=ReadBlobByte(image);
    if (c == EOF)
      break;
  }
  /*
    Read image header.
  */
  count=ReadBlob(image,sizeof(pdb_image.name),(unsigned char *) pdb_image.name);
  if (count != sizeof(pdb_image.name))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  pdb_image.version=ReadBlobByte(image);
  pdb_image.type=(unsigned char) ((int) ReadBlobByte(image));
  pdb_image.reserved_1=ReadBlobMSBLong(image);
  pdb_image.note=ReadBlobMSBLong(image);
  pdb_image.x_last=(short) ReadBlobMSBShort(image);
  pdb_image.y_last=(short) ReadBlobMSBShort(image);
  pdb_image.reserved_2=ReadBlobMSBLong(image);
  pdb_image.x_anchor=ReadBlobMSBShort(image);
  pdb_image.y_anchor=ReadBlobMSBShort(image);
  pdb_image.width=(short) ReadBlobMSBShort(image);
  pdb_image.height=(short) ReadBlobMSBShort(image);
  /*
    Initialize image structure.
  */
  image->columns=(size_t) pdb_image.width;
  image->rows=(size_t) pdb_image.height;
  image->depth=8;
  status=SetImageExtent(image,image->columns,image->rows,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  image->storage_class=PseudoClass;
  bits_per_pixel=pdb_image.type == 0 ? 2UL : pdb_image.type == 2 ? 4UL : 1UL;
  one=1;
  if (AcquireImageColormap(image,one << bits_per_pixel,exception) == MagickFalse)
    ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  if (image_info->ping != MagickFalse)
    {
      (void) CloseBlob(image);
      return(GetFirstImageInList(image));
    }
  packets=(bits_per_pixel*image->columns+7)/8;
  pixels=(unsigned char *) AcquireQuantumMemory(packets+257UL,image->rows*
    sizeof(*pixels));
  if (pixels == (unsigned char *) NULL)
    ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  switch (pdb_image.version & 0x07) 
  {
    case 0:
    {
      image->compression=NoCompression;
      count=(ssize_t) ReadBlob(image, packets * image -> rows, pixels);
      break;
    }
    case 1:
    {
      image->compression=RLECompression;
      if (!DecodeImage(image, pixels, packets * image -> rows))
        ThrowReaderException( CorruptImageError, ""RLEDecoderError"" );
      break;
    }
    default:
      ThrowReaderException(CorruptImageError,
         ""UnrecognizedImageCompressionType"" );
  }
  p=pixels;
  switch (bits_per_pixel)
  {
    case 1:
    {
      int
        bit;

      /*
        Read 1-bit PDB image.
      */
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
        for (x=0; x < ((ssize_t) image->columns-7); x+=8)
        {
          for (bit=0; bit < 8; bit++)
          {
            index=(Quantum) (*p & (0x80 >> bit) ? 0x00 : 0x01);
            SetPixelIndex(image,index,q);
            q+=GetPixelChannels(image);
          }
          p++;
        }
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
      (void) SyncImage(image,exception);
      break;
    }
    case 2:
    {
      /*
        Read 2-bit PDB image.
      */
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
        for (x=0; x < (ssize_t) image->columns-3; x+=4)
        {
          index=ConstrainColormapIndex(image,3UL-((*p >> 6) & 0x03),exception);
          SetPixelIndex(image,index,q);
          q+=GetPixelChannels(image);
          index=ConstrainColormapIndex(image,3UL-((*p >> 4) & 0x03),exception);
          SetPixelIndex(image,index,q);
          q+=GetPixelChannels(image);
          index=ConstrainColormapIndex(image,3UL-((*p >> 2) & 0x03),exception);
          SetPixelIndex(image,index,q);
          q+=GetPixelChannels(image);
          index=ConstrainColormapIndex(image,3UL-((*p) & 0x03),exception);
          SetPixelIndex(image,index,q);
          p++;
          q+=GetPixelChannels(image);
        }
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
      (void) SyncImage(image,exception);
      break;
    }
    case 4:
    {
      /*
        Read 4-bit PDB image.
      */
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (Quantum *) NULL)
          break;
        for (x=0; x < (ssize_t) image->columns-1; x+=2)
        {
          index=ConstrainColormapIndex(image,15UL-((*p >> 4) & 0x0f),exception);
          SetPixelIndex(image,index,q);
          q+=GetPixelChannels(image);
          index=ConstrainColormapIndex(image,15UL-((*p) & 0x0f),exception);
          SetPixelIndex(image,index,q);
          p++;
          q+=GetPixelChannels(image);
        }
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
      (void) SyncImage(image,exception);
      break;
    }
    default:
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  }
  pixels=(unsigned char *) RelinquishMagickMemory(pixels);
  if (EOFBlob(image) != MagickFalse)
    ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
      image->filename);
  if (pdb_info.number_records > 1)
    {
      char
        *comment;

      int
        c;

      register char
        *p;

      size_t
        length;

      num_pad_bytes = (size_t) (comment_offset - TellBlob( image ));
      while (num_pad_bytes--) ReadBlobByte( image );

      /*
        Read comment.
      */
      c=ReadBlobByte(image);
      length=MagickPathExtent;
      comment=AcquireString((char *) NULL);
      for (p=comment; c != EOF; p++)
      {
        if ((size_t) (p-comment+MagickPathExtent) >= length)
          {
            *p='\0';
            length<<=1;
            length+=MagickPathExtent;
            comment=(char *) ResizeQuantumMemory(comment,length+MagickPathExtent,
              sizeof(*comment));
            if (comment == (char *) NULL)
              break;
            p=comment+strlen(comment);
          }
        *p=c;
        c=ReadBlobByte(image);
      }
      *p='\0';
      if (comment == (char *) NULL)
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      (void) SetImageProperty(image,""comment"",comment,exception);
      comment=DestroyString(comment);
    }
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}","static Image *ReadPDBImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
  unsigned char
    VAR_2,
    VAR_3[3];

  Image
    *VAR_4;

  MagickBooleanType
    VAR_5;

  PDBImage
    VAR_6;

  PDBInfo
    VAR_7;

  Quantum
    VAR_8;

  register ssize_t
    VAR_9;

  register Quantum
    *VAR_10;

  register unsigned char
    *VAR_11;

  size_t
    VAR_12,
    VAR_13,
    VAR_14,
    VAR_15;

  ssize_t
    VAR_16,
    VAR_17,
    VAR_18 = 0,
    VAR_19;

  unsigned char
    *VAR_20;

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_21);
  if (VAR_0->debug != VAR_22)
    (void) LogMagickEvent(VAR_23,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_21);
  VAR_4=AcquireImage(VAR_0,VAR_1);
  VAR_5=OpenBlob(VAR_0,VAR_4,VAR_24,VAR_1);
  if (VAR_5 == VAR_22)
    {
      VAR_4=DestroyImageList(VAR_4);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                                       
    
  VAR_16=ReadBlob(VAR_4,sizeof(VAR_7.name),(unsigned char *) VAR_7.name);
  if (VAR_16 != sizeof(VAR_7.name))
    ThrowReaderException(VAR_25,""ImproperImageHeader"");
  VAR_7.attributes=(short) ReadBlobMSBShort(VAR_4);
  VAR_7.version=(short) ReadBlobMSBShort(VAR_4);
  VAR_7.create_time=ReadBlobMSBLong(VAR_4);
  VAR_7.modify_time=ReadBlobMSBLong(VAR_4);
  VAR_7.archive_time=ReadBlobMSBLong(VAR_4);
  VAR_7.modify_number=ReadBlobMSBLong(VAR_4);
  VAR_7.application_info=ReadBlobMSBLong(VAR_4);
  VAR_7.sort_info=ReadBlobMSBLong(VAR_4);
  (void) ReadBlob(VAR_4,4,(unsigned char *) VAR_7.type);
  (void) ReadBlob(VAR_4,4,(unsigned char *) VAR_7.id);
  VAR_7.seed=ReadBlobMSBLong(VAR_4);
  VAR_7.next_record=ReadBlobMSBLong(VAR_4);
  VAR_7.number_records=(short) ReadBlobMSBShort(VAR_4);
  if ((memcmp(VAR_7.type,""vIMG"",4) != 0) ||
      (memcmp(VAR_7.id,""View"",4) != 0))
    ThrowReaderException(VAR_25,""ImproperImageHeader"");
  if (VAR_7.next_record != 0)
    ThrowReaderException(VAR_26,""MultipleRecordListNotSupported"");
  /* COMMENT_6 */
                       
    
  VAR_17=(ssize_t) ((int) ReadBlobMSBLong(VAR_4));
  VAR_2=(unsigned char) ReadBlobByte(VAR_4);
  (void) VAR_2;
  VAR_16=ReadBlob(VAR_4,3,(unsigned char *) VAR_3);
  if (VAR_16 != 3  ||  memcmp(VAR_3,""\x6f\x80\x00"",3) != 0)
    ThrowReaderException(VAR_25,""CorruptImage"");
  if (VAR_7.number_records > 1)
    {
      VAR_18=(ssize_t) ((int) ReadBlobMSBLong(VAR_4));
      VAR_2=(unsigned char) ReadBlobByte(VAR_4);
      VAR_16=ReadBlob(VAR_4,3,(unsigned char *) VAR_3);
      if (VAR_16 != 3  ||  memcmp(VAR_3,""\x6f\x80\x01"",3) != 0)
        ThrowReaderException(VAR_25,""CorruptImage"");
    }
  VAR_13 = (size_t) (VAR_17 - TellBlob( VAR_4 ));
  while (VAR_13-- != 0)
  {
    int
      VAR_27;

    VAR_27=ReadBlobByte(VAR_4);
    if (VAR_27 == VAR_28)
      break;
  }
  /* COMMENT_9 */
                      
    
  VAR_16=ReadBlob(VAR_4,sizeof(VAR_6.name),(unsigned char *) VAR_6.name);
  if (VAR_16 != sizeof(VAR_6.name))
    ThrowReaderException(VAR_25,""ImproperImageHeader"");
  VAR_6.version=ReadBlobByte(VAR_4);
  VAR_6.type=(unsigned char) ((int) ReadBlobByte(VAR_4));
  VAR_6.reserved_1=ReadBlobMSBLong(VAR_4);
  VAR_6.note=ReadBlobMSBLong(VAR_4);
  VAR_6.x_last=(short) ReadBlobMSBShort(VAR_4);
  VAR_6.y_last=(short) ReadBlobMSBShort(VAR_4);
  VAR_6.reserved_2=ReadBlobMSBLong(VAR_4);
  VAR_6.x_anchor=ReadBlobMSBShort(VAR_4);
  VAR_6.y_anchor=ReadBlobMSBShort(VAR_4);
  VAR_6.width=(short) ReadBlobMSBShort(VAR_4);
  VAR_6.height=(short) ReadBlobMSBShort(VAR_4);
  /* COMMENT_12 */
                               
    
  VAR_4->columns=(size_t) VAR_6.width;
  VAR_4->rows=(size_t) VAR_6.height;
  VAR_4->depth=8;
  VAR_5=SetImageExtent(VAR_4,VAR_4->columns,VAR_4->rows,VAR_1);
  if (VAR_5 == VAR_22)
    return(DestroyImageList(VAR_4));
  VAR_4->storage_class=VAR_29;
  VAR_12=VAR_6.type == 0 ? 2UL : VAR_6.type == 2 ? 4UL : 1UL;
  VAR_14=1;
  if (AcquireImageColormap(VAR_4,VAR_14 << VAR_12,VAR_1) == VAR_22)
    ThrowReaderException(VAR_30,""MemoryAllocationFailed"");
  if (VAR_0->ping != VAR_22)
    {
      (void) CloseBlob(VAR_4);
      return(GetFirstImageInList(VAR_4));
    }
  VAR_15=(VAR_12*VAR_4->columns+7)/8;
  VAR_20=(unsigned char *) AcquireQuantumMemory(VAR_15+257UL,VAR_4->rows*
    sizeof(*VAR_20));
  if (VAR_20 == (unsigned char *) NULL)
    ThrowReaderException(VAR_30,""MemoryAllocationFailed"");
  switch (VAR_6.version & 0x07) 
  {
    case 0:
    {
      VAR_4->compression=VAR_31;
      VAR_16=(ssize_t) ReadBlob(VAR_4, VAR_15 * VAR_4 -> rows, VAR_20);
      break;
    }
    case 1:
    {
      VAR_4->compression=VAR_32;
      if (!DecodeImage(VAR_4, VAR_20, VAR_15 * VAR_4 -> rows))
        ThrowReaderException( VAR_25, ""RLEDecoderError"" );
      break;
    }
    default:
      ThrowReaderException(VAR_25,
         ""UnrecognizedImageCompressionType"" );
  }
  VAR_11=VAR_20;
  switch (VAR_12)
  {
    case 1:
    {
      int
        VAR_33;

      /* COMMENT_15 */
                             
        
      for (VAR_19=0; VAR_19 < (ssize_t) VAR_4->rows; VAR_19++)
      {
        VAR_10=QueueAuthenticPixels(VAR_4,0,VAR_19,VAR_4->columns,1,VAR_1);
        if (VAR_10 == (Quantum *) NULL)
          break;
        for (VAR_9=0; VAR_9 < ((ssize_t) VAR_4->columns-7); VAR_9+=8)
        {
          for (VAR_33=0; VAR_33 < 8; VAR_33++)
          {
            VAR_8=(Quantum) (*VAR_11 & (0x80 >> VAR_33) ? 0x00 : 0x01);
            SetPixelIndex(VAR_4,VAR_8,VAR_10);
            VAR_10+=GetPixelChannels(VAR_4);
          }
          VAR_11++;
        }
        if (SyncAuthenticPixels(VAR_4,VAR_1) == VAR_22)
          break;
        VAR_5=SetImageProgress(VAR_4,VAR_34,(MagickOffsetType) VAR_19,
          VAR_4->rows);
        if (VAR_5 == VAR_22)
          break;
      }
      (void) SyncImage(VAR_4,VAR_1);
      break;
    }
    case 2:
    {
      /* COMMENT_18 */
                             
        
      for (VAR_19=0; VAR_19 < (ssize_t) VAR_4->rows; VAR_19++)
      {
        VAR_10=QueueAuthenticPixels(VAR_4,0,VAR_19,VAR_4->columns,1,VAR_1);
        if (VAR_10 == (Quantum *) NULL)
          break;
        for (VAR_9=0; VAR_9 < (ssize_t) VAR_4->columns-3; VAR_9+=4)
        {
          VAR_8=ConstrainColormapIndex(VAR_4,3UL-((*VAR_11 >> 6) & 0x03),VAR_1);
          SetPixelIndex(VAR_4,VAR_8,VAR_10);
          VAR_10+=GetPixelChannels(VAR_4);
          VAR_8=ConstrainColormapIndex(VAR_4,3UL-((*VAR_11 >> 4) & 0x03),VAR_1);
          SetPixelIndex(VAR_4,VAR_8,VAR_10);
          VAR_10+=GetPixelChannels(VAR_4);
          VAR_8=ConstrainColormapIndex(VAR_4,3UL-((*VAR_11 >> 2) & 0x03),VAR_1);
          SetPixelIndex(VAR_4,VAR_8,VAR_10);
          VAR_10+=GetPixelChannels(VAR_4);
          VAR_8=ConstrainColormapIndex(VAR_4,3UL-((*VAR_11) & 0x03),VAR_1);
          SetPixelIndex(VAR_4,VAR_8,VAR_10);
          VAR_11++;
          VAR_10+=GetPixelChannels(VAR_4);
        }
        if (SyncAuthenticPixels(VAR_4,VAR_1) == VAR_22)
          break;
        VAR_5=SetImageProgress(VAR_4,VAR_34,(MagickOffsetType) VAR_19,
          VAR_4->rows);
        if (VAR_5 == VAR_22)
          break;
      }
      (void) SyncImage(VAR_4,VAR_1);
      break;
    }
    case 4:
    {
      /* COMMENT_21 */
                             
        
      for (VAR_19=0; VAR_19 < (ssize_t) VAR_4->rows; VAR_19++)
      {
        VAR_10=QueueAuthenticPixels(VAR_4,0,VAR_19,VAR_4->columns,1,VAR_1);
        if (VAR_10 == (Quantum *) NULL)
          break;
        for (VAR_9=0; VAR_9 < (ssize_t) VAR_4->columns-1; VAR_9+=2)
        {
          VAR_8=ConstrainColormapIndex(VAR_4,15UL-((*VAR_11 >> 4) & 0x0f),VAR_1);
          SetPixelIndex(VAR_4,VAR_8,VAR_10);
          VAR_10+=GetPixelChannels(VAR_4);
          VAR_8=ConstrainColormapIndex(VAR_4,15UL-((*VAR_11) & 0x0f),VAR_1);
          SetPixelIndex(VAR_4,VAR_8,VAR_10);
          VAR_11++;
          VAR_10+=GetPixelChannels(VAR_4);
        }
        if (SyncAuthenticPixels(VAR_4,VAR_1) == VAR_22)
          break;
        VAR_5=SetImageProgress(VAR_4,VAR_34,(MagickOffsetType) VAR_19,
          VAR_4->rows);
        if (VAR_5 == VAR_22)
          break;
      }
      (void) SyncImage(VAR_4,VAR_1);
      break;
    }
    default:
      ThrowReaderException(VAR_25,""ImproperImageHeader"");
  }
  VAR_20=(unsigned char *) RelinquishMagickMemory(VAR_20);
  if (EOFBlob(VAR_4) != VAR_22)
    ThrowFileException(VAR_1,VAR_25,""UnexpectedEndOfFile"",
      VAR_4->filename);
  if (VAR_7.number_records > 1)
    {
      char
        *VAR_35;

      int
        VAR_27;

      register char
        *VAR_11;

      size_t
        VAR_36;

      VAR_13 = (size_t) (VAR_18 - TellBlob( VAR_4 ));
      while (VAR_13--) ReadBlobByte( VAR_4 );

      /* COMMENT_24 */
                     
        
      VAR_27=ReadBlobByte(VAR_4);
      VAR_36=VAR_37;
      VAR_35=AcquireString((char *) NULL);
      for (VAR_11=VAR_35; VAR_27 != VAR_28; VAR_11++)
      {
        if ((size_t) (VAR_11-VAR_35+VAR_37) >= VAR_36)
          {
            *VAR_11='\0';
            VAR_36<<=1;
            VAR_36+=VAR_37;
            VAR_35=(char *) ResizeQuantumMemory(VAR_35,VAR_36+VAR_37,
              sizeof(*VAR_35));
            if (VAR_35 == (char *) NULL)
              break;
            VAR_11=VAR_35+strlen(VAR_35);
          }
        *VAR_11=VAR_27;
        VAR_27=ReadBlobByte(VAR_4);
      }
      *VAR_11='\0';
      if (VAR_35 == (char *) NULL)
        ThrowReaderException(VAR_30,""MemoryAllocationFailed"");
      (void) SetImageProperty(VAR_4,""comment"",VAR_35,VAR_1);
      VAR_35=DestroyString(VAR_35);
    }
  (void) CloseBlob(VAR_4);
  return(GetFirstImageInList(VAR_4));
}",ImageMagick/6d202a0514fb6a406456b8b728cde776becb25f8/pdb.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -148,7 +148,7 @@
       return(GetFirstImageInList(image));
     }
   packets=(bits_per_pixel*image->columns+7)/8;
-  pixels=(unsigned char *) AcquireQuantumMemory(packets+256UL,image->rows*
+  pixels=(unsigned char *) AcquireQuantumMemory(packets+257UL,image->rows*
     sizeof(*pixels));
   if (pixels == (unsigned char *) NULL)
     ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");","{'deleted_lines': ['  pixels=(unsigned char *) AcquireQuantumMemory(packets+256UL,image->rows*'], 'added_lines': ['  pixels=(unsigned char *) AcquireQuantumMemory(packets+257UL,image->rows*']}",True,MagickCore/memory.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds access) via a crafted PDB file.,6.5,MEDIUM,1,test,2016-03-07T12:13:10Z,1
CVE-2016-1840,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,GNOME/libxml2,"Bug 757711: heap-buffer-overflow in xmlFAParsePosCharGroup <https://bugzilla.gnome.org/show_bug.cgi?id=757711>

* xmlregexp.c:
(xmlFAParseCharRange): Only advance to the next character if
there is no error.  Advancing to the next character in case of
an error while parsing regexp leads to an out of bounds access.",cbb271655cadeb8dbb258a64701d9a3a0c4835b4,https://github.com/GNOME/libxml2/commit/cbb271655cadeb8dbb258a64701d9a3a0c4835b4,xmlregexp.c,xmlFAParseCharRange,"static void
xmlFAParseCharRange(xmlRegParserCtxtPtr ctxt) {
int cur, len;
int start = -1;
int end = -1;
if (CUR == '\0') {
ERROR(""Expecting ']'"");
return;
}
cur = CUR;
if (cur == '\\') {
NEXT;
cur = CUR;
switch (cur) {
case 'n': start = 0xA; break;
case 'r': start = 0xD; break;
case 't': start = 0x9; break;
case '\\': case '|': case '.': case '-': case '^': case '?':
case '*': case '+': case '{': case '}': case '(': case ')':
case '[': case ']':
start = cur; break;
default:
ERROR(""Invalid escape value"");
return;
}
end = start;
len = 1;
} else if ((cur != 0x5B) && (cur != 0x5D)) {
end = start = CUR_SCHAR(ctxt->cur, len);
} else {
ERROR(""Expecting a char range"");
return;
}
if ((start == '-') && (NXT(1) != ']') && (PREV != '[') && (PREV != '^')) {
NEXTL(len);
return;
}
NEXTL(len);
cur = CUR;
if ((cur != '-') || (NXT(1) == ']')) {
xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
XML_REGEXP_CHARVAL, start, end, NULL);
return;
}
NEXT;
cur = CUR;
if (cur == '\\') {
NEXT;
cur = CUR;
switch (cur) {
case 'n': end = 0xA; break;
case 'r': end = 0xD; break;
case 't': end = 0x9; break;
case '\\': case '|': case '.': case '-': case '^': case '?':
case '*': case '+': case '{': case '}': case '(': case ')':
case '[': case ']':
end = cur; break;
default:
ERROR(""Invalid escape value"");
return;
}
len = 1;
} else if ((cur != 0x5B) && (cur != 0x5D)) {
end = CUR_SCHAR(ctxt->cur, len);
} else {
ERROR(""Expecting the end of a char range"");
return;
}
NEXTL(len);
if (end < start) {
ERROR(""End of range is before start of range"");
} else {
xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
XML_REGEXP_CHARVAL, start, end, NULL);
}
return;
}","static void
xmlFAParseCharRange(xmlRegParserCtxtPtr VAR_0) {
int VAR_1, VAR_2;
int VAR_3 = -1;
int VAR_4 = -1;
if (VAR_5 == '\0') {
ERROR(""Expecting ']'"");
return;
}
VAR_1 = VAR_5;
if (VAR_1 == '\\') {
VAR_6;
VAR_1 = VAR_5;
switch (VAR_1) {
case 'n': VAR_3 = 0xA; break;
case 'r': VAR_3 = 0xD; break;
case 't': VAR_3 = 0x9; break;
case '\\': case '|': case '.': case '-': case '^': case '?':
case '*': case '+': case '{': case '}': case '(': case ')':
case '[': case ']':
VAR_3 = VAR_1; break;
default:
ERROR(""Invalid escape value"");
return;
}
VAR_4 = VAR_3;
VAR_2 = 1;
} else if ((VAR_1 != 0x5B) && (VAR_1 != 0x5D)) {
VAR_4 = VAR_3 = CUR_SCHAR(VAR_0->cur, VAR_2);
} else {
ERROR(""Expecting a char range"");
return;
}
if ((VAR_3 == '-') && (NXT(1) != ']') && (VAR_7 != '[') && (VAR_7 != '^')) {
NEXTL(VAR_2);
return;
}
NEXTL(VAR_2);
VAR_1 = VAR_5;
if ((VAR_1 != '-') || (NXT(1) == ']')) {
xmlRegAtomAddRange(VAR_0, VAR_0->atom, VAR_0->neg,
VAR_8, VAR_3, VAR_4, NULL);
return;
}
VAR_6;
VAR_1 = VAR_5;
if (VAR_1 == '\\') {
VAR_6;
VAR_1 = VAR_5;
switch (VAR_1) {
case 'n': VAR_4 = 0xA; break;
case 'r': VAR_4 = 0xD; break;
case 't': VAR_4 = 0x9; break;
case '\\': case '|': case '.': case '-': case '^': case '?':
case '*': case '+': case '{': case '}': case '(': case ')':
case '[': case ']':
VAR_4 = VAR_1; break;
default:
ERROR(""Invalid escape value"");
return;
}
VAR_2 = 1;
} else if ((VAR_1 != 0x5B) && (VAR_1 != 0x5D)) {
VAR_4 = CUR_SCHAR(VAR_0->cur, VAR_2);
} else {
ERROR(""Expecting the end of a char range"");
return;
}
NEXTL(VAR_2);
if (VAR_4 < VAR_3) {
ERROR(""End of range is before start of range"");
} else {
xmlRegAtomAddRange(VAR_0, VAR_0->atom, VAR_0->neg,
VAR_8, VAR_3, VAR_4, NULL);
}
return;
}",GNOME/libxml2/cbb271655cadeb8dbb258a64701d9a3a0c4835b4/xmlregexp.c/vul/before/0.json,"static void
xmlFAParseCharRange(xmlRegParserCtxtPtr ctxt) {
    int cur, len;
    int start = -1;
    int end = -1;

    if (CUR == '\0') {
        ERROR(""Expecting ']'"");
	return;
    }

    cur = CUR;
    if (cur == '\\') {
	NEXT;
	cur = CUR;
	switch (cur) {
	    case 'n': start = 0xA; break;
	    case 'r': start = 0xD; break;
	    case 't': start = 0x9; break;
	    case '\\': case '|': case '.': case '-': case '^': case '?':
	    case '*': case '+': case '{': case '}': case '(': case ')':
	    case '[': case ']':
		start = cur; break;
	    default:
		ERROR(""Invalid escape value"");
		return;
	}
	end = start;
        len = 1;
    } else if ((cur != 0x5B) && (cur != 0x5D)) {
        end = start = CUR_SCHAR(ctxt->cur, len);
    } else {
	ERROR(""Expecting a char range"");
	return;
    }
    /*
     * Since we are ""inside"" a range, we can assume ctxt->cur is past
     * the start of ctxt->string, and PREV should be safe
     */
    if ((start == '-') && (NXT(1) != ']') && (PREV != '[') && (PREV != '^')) {
	NEXTL(len);
	return;
    }
    NEXTL(len);
    cur = CUR;
    if ((cur != '-') || (NXT(1) == ']')) {
        xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
		              XML_REGEXP_CHARVAL, start, end, NULL);
	return;
    }
    NEXT;
    cur = CUR;
    if (cur == '\\') {
	NEXT;
	cur = CUR;
	switch (cur) {
	    case 'n': end = 0xA; break;
	    case 'r': end = 0xD; break;
	    case 't': end = 0x9; break;
	    case '\\': case '|': case '.': case '-': case '^': case '?':
	    case '*': case '+': case '{': case '}': case '(': case ')':
	    case '[': case ']':
		end = cur; break;
	    default:
		ERROR(""Invalid escape value"");
		return;
	}
        len = 1;
    } else if ((cur != 0x5B) && (cur != 0x5D)) {
        end = CUR_SCHAR(ctxt->cur, len);
    } else {
	ERROR(""Expecting the end of a char range"");
	return;
    }

    /* TODO check that the values are acceptable character ranges for XML */
    if (end < start) {
	ERROR(""End of range is before start of range"");
    } else {
        NEXTL(len);
        xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
		           XML_REGEXP_CHARVAL, start, end, NULL);
    }
    return;
}","static void
xmlFAParseCharRange(xmlRegParserCtxtPtr VAR_0) {
    int VAR_1, VAR_2;
    int VAR_3 = -1;
    int VAR_4 = -1;

    if (VAR_5 == '\0') {
        ERROR(""Expecting ']'"");
	return;
    }

    VAR_1 = VAR_5;
    if (VAR_1 == '\\') {
	VAR_6;
	VAR_1 = VAR_5;
	switch (VAR_1) {
	    case 'n': VAR_3 = 0xA; break;
	    case 'r': VAR_3 = 0xD; break;
	    case 't': VAR_3 = 0x9; break;
	    case '\\': case '|': case '.': case '-': case '^': case '?':
	    case '*': case '+': case '{': case '}': case '(': case ')':
	    case '[': case ']':
		VAR_3 = VAR_1; break;
	    default:
		ERROR(""Invalid escape value"");
		return;
	}
	VAR_4 = VAR_3;
        VAR_2 = 1;
    } else if ((VAR_1 != 0x5B) && (VAR_1 != 0x5D)) {
        VAR_4 = VAR_3 = CUR_SCHAR(VAR_0->cur, VAR_2);
    } else {
	ERROR(""Expecting a char range"");
	return;
    }
    /* COMMENT_0 */
                                                                     
                                                         
       
    if ((VAR_3 == '-') && (NXT(1) != ']') && (VAR_7 != '[') && (VAR_7 != '^')) {
	NEXTL(VAR_2);
	return;
    }
    NEXTL(VAR_2);
    VAR_1 = VAR_5;
    if ((VAR_1 != '-') || (NXT(1) == ']')) {
        xmlRegAtomAddRange(VAR_0, VAR_0->atom, VAR_0->neg,
		              VAR_8, VAR_3, VAR_4, NULL);
	return;
    }
    VAR_6;
    VAR_1 = VAR_5;
    if (VAR_1 == '\\') {
	VAR_6;
	VAR_1 = VAR_5;
	switch (VAR_1) {
	    case 'n': VAR_4 = 0xA; break;
	    case 'r': VAR_4 = 0xD; break;
	    case 't': VAR_4 = 0x9; break;
	    case '\\': case '|': case '.': case '-': case '^': case '?':
	    case '*': case '+': case '{': case '}': case '(': case ')':
	    case '[': case ']':
		VAR_4 = VAR_1; break;
	    default:
		ERROR(""Invalid escape value"");
		return;
	}
        VAR_2 = 1;
    } else if ((VAR_1 != 0x5B) && (VAR_1 != 0x5D)) {
        VAR_4 = CUR_SCHAR(VAR_0->cur, VAR_2);
    } else {
	ERROR(""Expecting the end of a char range"");
	return;
    }

    /* COMMENT_4 */
    if (VAR_4 < VAR_3) {
	ERROR(""End of range is before start of range"");
    } else {
        NEXTL(VAR_2);
        xmlRegAtomAddRange(VAR_0, VAR_0->atom, VAR_0->neg,
		           VAR_8, VAR_3, VAR_4, NULL);
    }
    return;
}",GNOME/libxml2/cbb271655cadeb8dbb258a64701d9a3a0c4835b4/xmlregexp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -72,11 +72,12 @@
 	ERROR(""Expecting the end of a char range"");
 	return;
     }
-    NEXTL(len);
+
     /* TODO check that the values are acceptable character ranges for XML */
     if (end < start) {
 	ERROR(""End of range is before start of range"");
     } else {
+        NEXTL(len);
         xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 		           XML_REGEXP_CHARVAL, start, end, NULL);
     }","{'deleted_lines': ['    NEXTL(len);'], 'added_lines': ['', '        NEXTL(len);']}",True,"Heap-based buffer overflow in the xmlFAParsePosCharGroup function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted XML document.",7.8,HIGH,2,test,2016-03-07T14:34:26Z,1
CVE-2016-3951,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"cdc_ncm: do not call usbnet_link_change from cdc_ncm_bind

usbnet_link_change will call schedule_work and should be
avoided if bind is failing. Otherwise we will end up with
scheduled work referring to a netdev which has gone away.

Instead of making the call conditional, we can just defer
it to usbnet_probe, using the driver_info flag made for
this purpose.

Fixes: 8a34b0ae8778 (""usbnet: cdc_ncm: apply usbnet_link_change"")
Reported-by: Andrey Konovalov <andreyknvl@gmail.com>
Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Bjrn Mork <bjorn@mork.no>
Signed-off-by: David S. Miller <davem@davemloft.net>",4d06dd537f95683aba3651098ae288b7cbff8274,https://github.com/torvalds/linux/commit/4d06dd537f95683aba3651098ae288b7cbff8274,drivers/net/usb/cdc_ncm.c,cdc_ncm_bind,"static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)
{
int ret;
if (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)
return -ENODEV;
ret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);
usbnet_link_change(dev, 0, 0);
return ret;
}","static int cdc_ncm_bind(struct usbnet *VAR_0, struct usb_interface *VAR_1)
{
int VAR_2;
if (cdc_ncm_select_altsetting(VAR_1) != VAR_3)
return -VAR_4;
VAR_2 = cdc_ncm_bind_common(VAR_0, VAR_1, VAR_5, 0);
usbnet_link_change(VAR_0, 0, 0);
return VAR_2;
}",torvalds/linux/4d06dd537f95683aba3651098ae288b7cbff8274/cdc_ncm.c/vul/before/0.json,"static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)
{
	/* MBIM backwards compatible function? */
	if (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)
		return -ENODEV;

	/* The NCM data altsetting is fixed, so we hard-coded it.
	 * Additionally, generic NCM devices are assumed to accept arbitrarily
	 * placed NDP.
	 */
	return cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);
}","static int cdc_ncm_bind(struct usbnet *VAR_0, struct usb_interface *VAR_1)
{
	/* COMMENT_0 */
	if (cdc_ncm_select_altsetting(VAR_1) != VAR_2)
		return -VAR_3;

	/* COMMENT_1 */
                                                                       
               
    
	return cdc_ncm_bind_common(VAR_0, VAR_1, VAR_4, 0);
}",torvalds/linux/4d06dd537f95683aba3651098ae288b7cbff8274/cdc_ncm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,5 @@
 static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)
 {
-	int ret;
-
 	/* MBIM backwards compatible function? */
 	if (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)
 		return -ENODEV;
@@ -10,14 +8,5 @@
 	 * Additionally, generic NCM devices are assumed to accept arbitrarily
 	 * placed NDP.
 	 */
-	ret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);
-
-	/*
-	 * We should get an event when network connection is ""connected"" or
-	 * ""disconnected"". Set network connection in ""disconnected"" state
-	 * (carrier is OFF) during attach, so the IP network stack does not
-	 * start IPv6 negotiation and more.
-	 */
-	usbnet_link_change(dev, 0, 0);
-	return ret;
+	return cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);
 }","{'deleted_lines': ['\tint ret;', '', '\tret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);', '', '\t/*', '\t * We should get an event when network connection is ""connected"" or', '\t * ""disconnected"". Set network connection in ""disconnected"" state', '\t * (carrier is OFF) during attach, so the IP network stack does not', '\t * start IPv6 negotiation and more.', '\t */', '\tusbnet_link_change(dev, 0, 0);', '\treturn ret;'], 'added_lines': ['\treturn cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);']}",True,Double free vulnerability in drivers/net/usb/cdc_ncm.c in the Linux kernel before 4.5 allows physically proximate attackers to cause a denial of service (system crash) or possibly have unspecified other impact by inserting a USB device with an invalid USB descriptor.,4.6,MEDIUM,1,test,2016-03-07T20:15:36Z,1
CVE-2016-7117,['CWE-19'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"net: Fix use after free in the recvmmsg exit path

The syzkaller fuzzer hit the following use-after-free:

  Call Trace:
   [<ffffffff8175ea0e>] __asan_report_load8_noabort+0x3e/0x40 mm/kasan/report.c:295
   [<ffffffff851cc31a>] __sys_recvmmsg+0x6fa/0x7f0 net/socket.c:2261
   [<     inline     >] SYSC_recvmmsg net/socket.c:2281
   [<ffffffff851cc57f>] SyS_recvmmsg+0x16f/0x180 net/socket.c:2270
   [<ffffffff86332bb6>] entry_SYSCALL_64_fastpath+0x16/0x7a
  arch/x86/entry/entry_64.S:185

And, as Dmitry rightly assessed, that is because we can drop the
reference and then touch it when the underlying recvmsg calls return
some packets and then hit an error, which will make recvmmsg to set
sock->sk->sk_err, oops, fix it.

Reported-and-Tested-by: Dmitry Vyukov <dvyukov@google.com>
Cc: Alexander Potapenko <glider@google.com>
Cc: Eric Dumazet <edumazet@google.com>
Cc: Kostya Serebryany <kcc@google.com>
Cc: Sasha Levin <sasha.levin@oracle.com>
Fixes: a2e2725541fa (""net: Introduce recvmmsg socket syscall"")
http://lkml.kernel.org/r/20160122211644.GC2470@redhat.com
Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",34b88a68f26a75e4fded796f1a49c40f82234b7d,https://github.com/torvalds/linux/commit/34b88a68f26a75e4fded796f1a49c40f82234b7d,net/socket.c,__sys_recvmmsg,"int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,
unsigned int flags, struct timespec *timeout)
{
int fput_needed, err, datagrams;
struct socket *sock;
struct mmsghdr __user *entry;
struct compat_mmsghdr __user *compat_entry;
struct msghdr msg_sys;
struct timespec end_time;
if (timeout &&
poll_select_set_timeout(&end_time, timeout->tv_sec,
timeout->tv_nsec))
return -EINVAL;
datagrams = 0;
sock = sockfd_lookup_light(fd, &err, &fput_needed);
if (!sock)
return err;
err = sock_error(sock->sk);
if (err)
goto out_put;
entry = mmsg;
compat_entry = (struct compat_mmsghdr __user *)mmsg;
while (datagrams < vlen) {
if (MSG_CMSG_COMPAT & flags) {
err = ___sys_recvmsg(sock, (struct user_msghdr __user *)compat_entry,
&msg_sys, flags & ~MSG_WAITFORONE,
datagrams);
if (err < 0)
break;
err = __put_user(err, &compat_entry->msg_len);
++compat_entry;
} else {
err = ___sys_recvmsg(sock,
(struct user_msghdr __user *)entry,
&msg_sys, flags & ~MSG_WAITFORONE,
datagrams);
if (err < 0)
break;
err = put_user(err, &entry->msg_len);
++entry;
}
if (err)
break;
++datagrams;
if (flags & MSG_WAITFORONE)
flags |= MSG_DONTWAIT;
if (timeout) {
ktime_get_ts(timeout);
*timeout = timespec_sub(end_time, *timeout);
if (timeout->tv_sec < 0) {
timeout->tv_sec = timeout->tv_nsec = 0;
break;
}
if (timeout->tv_nsec == 0 && timeout->tv_sec == 0)
break;
}
if (msg_sys.msg_flags & MSG_OOB)
break;
cond_resched();
}
out_put:
fput_light(sock->file, fput_needed);
if (err == 0)
return datagrams;
if (datagrams != 0) {
if (err != -EAGAIN) {
sock->sk->sk_err = -err;
}
return datagrams;
}
return err;
}","int __sys_recvmmsg(int VAR_0, struct mmsghdr __user *VAR_1, unsigned int VAR_2,
unsigned int VAR_3, struct timespec *VAR_4)
{
int VAR_5, VAR_6, VAR_7;
struct socket *VAR_8;
struct mmsghdr __user *VAR_9;
struct compat_mmsghdr __user *VAR_10;
struct msghdr VAR_11;
struct timespec VAR_12;
if (VAR_4 &&
poll_select_set_timeout(&VAR_12, VAR_4->tv_sec,
VAR_4->tv_nsec))
return -VAR_13;
VAR_7 = 0;
VAR_8 = sockfd_lookup_light(VAR_0, &VAR_6, &VAR_5);
if (!VAR_8)
return VAR_6;
VAR_6 = sock_error(VAR_8->sk);
if (VAR_6)
goto out_put;
VAR_9 = VAR_1;
VAR_10 = (struct compat_mmsghdr __user *)VAR_1;
while (VAR_7 < VAR_2) {
if (VAR_14 & VAR_3) {
VAR_6 = ___sys_recvmsg(VAR_8, (struct user_msghdr __user *)VAR_10,
&VAR_11, VAR_3 & ~VAR_15,
VAR_7);
if (VAR_6 < 0)
break;
VAR_6 = __put_user(VAR_6, &VAR_10->msg_len);
++VAR_10;
} else {
VAR_6 = ___sys_recvmsg(VAR_8,
(struct user_msghdr __user *)VAR_9,
&VAR_11, VAR_3 & ~VAR_15,
VAR_7);
if (VAR_6 < 0)
break;
VAR_6 = put_user(VAR_6, &VAR_9->msg_len);
++VAR_9;
}
if (VAR_6)
break;
++VAR_7;
if (VAR_3 & VAR_15)
VAR_3 |= VAR_16;
if (VAR_4) {
ktime_get_ts(VAR_4);
*VAR_4 = timespec_sub(VAR_12, *VAR_4);
if (VAR_4->tv_sec < 0) {
VAR_4->tv_sec = VAR_4->tv_nsec = 0;
break;
}
if (VAR_4->tv_nsec == 0 && VAR_4->tv_sec == 0)
break;
}
if (VAR_11.msg_flags & VAR_17)
break;
cond_resched();
}
out_put:
fput_light(VAR_8->file, VAR_5);
if (VAR_6 == 0)
return VAR_7;
if (VAR_7 != 0) {
if (VAR_6 != -VAR_18) {
VAR_8->sk->sk_err = -VAR_6;
}
return VAR_7;
}
return VAR_6;
}",,"int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,
		   unsigned int flags, struct timespec *timeout)
{
	int fput_needed, err, datagrams;
	struct socket *sock;
	struct mmsghdr __user *entry;
	struct compat_mmsghdr __user *compat_entry;
	struct msghdr msg_sys;
	struct timespec end_time;

	if (timeout &&
	    poll_select_set_timeout(&end_time, timeout->tv_sec,
				    timeout->tv_nsec))
		return -EINVAL;

	datagrams = 0;

	sock = sockfd_lookup_light(fd, &err, &fput_needed);
	if (!sock)
		return err;

	err = sock_error(sock->sk);
	if (err)
		goto out_put;

	entry = mmsg;
	compat_entry = (struct compat_mmsghdr __user *)mmsg;

	while (datagrams < vlen) {
		/*
		 * No need to ask LSM for more than the first datagram.
		 */
		if (MSG_CMSG_COMPAT & flags) {
			err = ___sys_recvmsg(sock, (struct user_msghdr __user *)compat_entry,
					     &msg_sys, flags & ~MSG_WAITFORONE,
					     datagrams);
			if (err < 0)
				break;
			err = __put_user(err, &compat_entry->msg_len);
			++compat_entry;
		} else {
			err = ___sys_recvmsg(sock,
					     (struct user_msghdr __user *)entry,
					     &msg_sys, flags & ~MSG_WAITFORONE,
					     datagrams);
			if (err < 0)
				break;
			err = put_user(err, &entry->msg_len);
			++entry;
		}

		if (err)
			break;
		++datagrams;

		/* MSG_WAITFORONE turns on MSG_DONTWAIT after one packet */
		if (flags & MSG_WAITFORONE)
			flags |= MSG_DONTWAIT;

		if (timeout) {
			ktime_get_ts(timeout);
			*timeout = timespec_sub(end_time, *timeout);
			if (timeout->tv_sec < 0) {
				timeout->tv_sec = timeout->tv_nsec = 0;
				break;
			}

			/* Timeout, return less than vlen datagrams */
			if (timeout->tv_nsec == 0 && timeout->tv_sec == 0)
				break;
		}

		/* Out of band data, return right away */
		if (msg_sys.msg_flags & MSG_OOB)
			break;
		cond_resched();
	}

	if (err == 0)
		goto out_put;

	if (datagrams == 0) {
		datagrams = err;
		goto out_put;
	}

	/*
	 * We may return less entries than requested (vlen) if the
	 * sock is non block and there aren't enough datagrams...
	 */
	if (err != -EAGAIN) {
		/*
		 * ... or  if recvmsg returns an error after we
		 * received some datagrams, where we record the
		 * error to return on the next call or if the
		 * app asks about it using getsockopt(SO_ERROR).
		 */
		sock->sk->sk_err = -err;
	}
out_put:
	fput_light(sock->file, fput_needed);

	return datagrams;
}","int __sys_recvmmsg(int VAR_0, struct mmsghdr __user *VAR_1, unsigned int VAR_2,
		   unsigned int VAR_3, struct timespec *VAR_4)
{
	int VAR_5, VAR_6, VAR_7;
	struct socket *VAR_8;
	struct mmsghdr __user *VAR_9;
	struct compat_mmsghdr __user *VAR_10;
	struct msghdr VAR_11;
	struct timespec VAR_12;

	if (VAR_4 &&
	    poll_select_set_timeout(&VAR_12, VAR_4->tv_sec,
				    VAR_4->tv_nsec))
		return -VAR_13;

	VAR_7 = 0;

	VAR_8 = sockfd_lookup_light(VAR_0, &VAR_6, &VAR_5);
	if (!VAR_8)
		return VAR_6;

	VAR_6 = sock_error(VAR_8->sk);
	if (VAR_6)
		goto out_put;

	VAR_9 = VAR_1;
	VAR_10 = (struct compat_mmsghdr __user *)VAR_1;

	while (VAR_7 < VAR_2) {
		/* COMMENT_0 */
                                                         
     
		if (VAR_14 & VAR_3) {
			VAR_6 = ___sys_recvmsg(VAR_8, (struct user_msghdr __user *)VAR_10,
					     &VAR_11, VAR_3 & ~VAR_15,
					     VAR_7);
			if (VAR_6 < 0)
				break;
			VAR_6 = __put_user(VAR_6, &VAR_10->msg_len);
			++VAR_10;
		} else {
			VAR_6 = ___sys_recvmsg(VAR_8,
					     (struct user_msghdr __user *)VAR_9,
					     &VAR_11, VAR_3 & ~VAR_15,
					     VAR_7);
			if (VAR_6 < 0)
				break;
			VAR_6 = put_user(VAR_6, &VAR_9->msg_len);
			++VAR_9;
		}

		if (VAR_6)
			break;
		++VAR_7;

		/* COMMENT_3 */
		if (VAR_3 & VAR_15)
			VAR_3 |= VAR_16;

		if (VAR_4) {
			ktime_get_ts(VAR_4);
			*VAR_4 = timespec_sub(VAR_12, *VAR_4);
			if (VAR_4->tv_sec < 0) {
				VAR_4->tv_sec = VAR_4->tv_nsec = 0;
				break;
			}

			/* COMMENT_4 */
			if (VAR_4->tv_nsec == 0 && VAR_4->tv_sec == 0)
				break;
		}

		/* COMMENT_5 */
		if (VAR_11.msg_flags & VAR_17)
			break;
		cond_resched();
	}

	if (VAR_6 == 0)
		goto out_put;

	if (VAR_7 == 0) {
		VAR_7 = VAR_6;
		goto out_put;
	}

	/* COMMENT_6 */
                                                           
                                                          
    
	if (VAR_6 != -VAR_18) {
		/* COMMENT_10 */
                                                 
                                                 
                                               
                                                  
     
		VAR_8->sk->sk_err = -VAR_6;
	}
out_put:
	fput_light(VAR_8->file, VAR_5);

	return VAR_7;
}",,"--- func_before
+++ func_after
@@ -76,29 +76,29 @@
 		cond_resched();
 	}
 
+	if (err == 0)
+		goto out_put;
+
+	if (datagrams == 0) {
+		datagrams = err;
+		goto out_put;
+	}
+
+	/*
+	 * We may return less entries than requested (vlen) if the
+	 * sock is non block and there aren't enough datagrams...
+	 */
+	if (err != -EAGAIN) {
+		/*
+		 * ... or  if recvmsg returns an error after we
+		 * received some datagrams, where we record the
+		 * error to return on the next call or if the
+		 * app asks about it using getsockopt(SO_ERROR).
+		 */
+		sock->sk->sk_err = -err;
+	}
 out_put:
 	fput_light(sock->file, fput_needed);
 
-	if (err == 0)
-		return datagrams;
-
-	if (datagrams != 0) {
-		/*
-		 * We may return less entries than requested (vlen) if the
-		 * sock is non block and there aren't enough datagrams...
-		 */
-		if (err != -EAGAIN) {
-			/*
-			 * ... or  if recvmsg returns an error after we
-			 * received some datagrams, where we record the
-			 * error to return on the next call or if the
-			 * app asks about it using getsockopt(SO_ERROR).
-			 */
-			sock->sk->sk_err = -err;
-		}
-
-		return datagrams;
-	}
-
-	return err;
+	return datagrams;
 }","{'deleted_lines': ['\tif (err == 0)', '\t\treturn datagrams;', '', '\tif (datagrams != 0) {', '\t\t/*', '\t\t * We may return less entries than requested (vlen) if the', ""\t\t * sock is non block and there aren't enough datagrams..."", '\t\t */', '\t\tif (err != -EAGAIN) {', '\t\t\t/*', '\t\t\t * ... or  if recvmsg returns an error after we', '\t\t\t * received some datagrams, where we record the', '\t\t\t * error to return on the next call or if the', '\t\t\t * app asks about it using getsockopt(SO_ERROR).', '\t\t\t */', '\t\t\tsock->sk->sk_err = -err;', '\t\t}', '', '\t\treturn datagrams;', '\t}', '', '\treturn err;'], 'added_lines': ['\tif (err == 0)', '\t\tgoto out_put;', '', '\tif (datagrams == 0) {', '\t\tdatagrams = err;', '\t\tgoto out_put;', '\t}', '', '\t/*', '\t * We may return less entries than requested (vlen) if the', ""\t * sock is non block and there aren't enough datagrams..."", '\t */', '\tif (err != -EAGAIN) {', '\t\t/*', '\t\t * ... or  if recvmsg returns an error after we', '\t\t * received some datagrams, where we record the', '\t\t * error to return on the next call or if the', '\t\t * app asks about it using getsockopt(SO_ERROR).', '\t\t */', '\t\tsock->sk->sk_err = -err;', '\t}', '\treturn datagrams;']}",True,Use-after-free vulnerability in the __sys_recvmmsg function in net/socket.c in the Linux kernel before 4.5.2 allows remote attackers to execute arbitrary code via vectors involving a recvmmsg system call that is mishandled during error processing.,9.8,CRITICAL,3,test,2016-03-14T12:56:35Z,1
CVE-2016-4998,['CWE-119'],AV:L/AC:L/Au:N/C:P/I:N/A:C,0,torvalds/linux,"netfilter: x_tables: make sure e->next_offset covers remaining blob size

Otherwise this function may read data beyond the ruleset blob.

Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91,https://github.com/torvalds/linux/commit/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91,net/ipv4/netfilter/arp_tables.c,check_compat_entry_size_and_hooks,"static inline int
check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,
struct xt_table_info *newinfo,
unsigned int *size,
const unsigned char *base,
const unsigned char *limit,
const unsigned int *hook_entries,
const unsigned int *underflows,
const char *name)
{
struct xt_entry_target *t;
struct xt_target *target;
unsigned int entry_offset;
int ret, off, h;
duprintf(""check_compat_entry_size_and_hooks %p\n"", e);
if ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||
(unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit) {
duprintf(""Bad offset %p, limit = %p\n"", e, limit);
return -EINVAL;
}
if (e->next_offset < sizeof(struct compat_arpt_entry) +
sizeof(struct compat_xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
e, e->next_offset);
return -EINVAL;
}
ret = check_entry((struct arpt_entry *)e);
if (ret)
return ret;
off = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);
entry_offset = (void *)e - (void *)base;
t = compat_arpt_get_target(e);
target = xt_request_find_target(NFPROTO_ARP, t->u.user.name,
t->u.user.revision);
if (IS_ERR(target)) {
duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
t->u.user.name);
ret = PTR_ERR(target);
goto out;
}
t->u.kernel.target = target;
off += xt_compat_target_offset(target);
*size += off;
ret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);
if (ret)
goto release_target;
for (h = 0; h < NF_ARP_NUMHOOKS; h++) {
if ((unsigned char *)e - base == hook_entries[h])
newinfo->hook_entry[h] = hook_entries[h];
if ((unsigned char *)e - base == underflows[h])
newinfo->underflow[h] = underflows[h];
}
memset(&e->counters, 0, sizeof(e->counters));
e->comefrom = 0;
return 0;
release_target:
module_put(t->u.kernel.target->me);
out:
return ret;
}","static inline int
check_compat_entry_size_and_hooks(struct compat_arpt_entry *VAR_0,
struct xt_table_info *VAR_1,
unsigned int *VAR_2,
const unsigned char *VAR_3,
const unsigned char *VAR_4,
const unsigned int *VAR_5,
const unsigned int *VAR_6,
const char *VAR_7)
{
struct xt_entry_target *VAR_8;
struct xt_target *VAR_9;
unsigned int VAR_10;
int VAR_11, VAR_12, VAR_13;
duprintf(""check_compat_entry_size_and_hooks %p\n"", VAR_0);
if ((unsigned long)VAR_0 % __alignof__(struct compat_arpt_entry) != 0 ||
(unsigned char *)VAR_0 + sizeof(struct compat_arpt_entry) >= VAR_4) {
duprintf(""Bad offset %p, limit = %p\n"", VAR_0, VAR_4);
return -VAR_14;
}
if (VAR_0->next_offset < sizeof(struct compat_arpt_entry) +
sizeof(struct compat_xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
VAR_0, VAR_0->next_offset);
return -VAR_14;
}
VAR_11 = check_entry((struct arpt_entry *)VAR_0);
if (VAR_11)
return VAR_11;
VAR_12 = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);
VAR_10 = (void *)VAR_0 - (void *)VAR_3;
VAR_8 = compat_arpt_get_target(VAR_0);
VAR_9 = xt_request_find_target(VAR_15, VAR_8->u.user.name,
VAR_8->u.user.revision);
if (IS_ERR(VAR_9)) {
duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
VAR_8->u.user.name);
VAR_11 = PTR_ERR(VAR_9);
goto out;
}
VAR_8->u.kernel.target = VAR_9;
VAR_12 += xt_compat_target_offset(VAR_9);
*VAR_2 += VAR_12;
VAR_11 = xt_compat_add_offset(VAR_15, VAR_10, VAR_12);
if (VAR_11)
goto release_target;
for (VAR_13 = 0; VAR_13 < VAR_16; VAR_13++) {
if ((unsigned char *)VAR_0 - VAR_3 == VAR_5[VAR_13])
VAR_1->hook_entry[VAR_13] = VAR_5[VAR_13];
if ((unsigned char *)VAR_0 - VAR_3 == VAR_6[VAR_13])
VAR_1->underflow[VAR_13] = VAR_6[VAR_13];
}
memset(&VAR_0->counters, 0, sizeof(VAR_0->counters));
VAR_0->comefrom = 0;
return 0;
release_target:
module_put(VAR_8->u.kernel.target->me);
out:
return VAR_11;
}",torvalds/linux/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91/arp_tables.c/vul/before/1.json,"static inline int
check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,
				  struct xt_table_info *newinfo,
				  unsigned int *size,
				  const unsigned char *base,
				  const unsigned char *limit,
				  const unsigned int *hook_entries,
				  const unsigned int *underflows,
				  const char *name)
{
	struct xt_entry_target *t;
	struct xt_target *target;
	unsigned int entry_offset;
	int ret, off, h;

	duprintf(""check_compat_entry_size_and_hooks %p\n"", e);
	if ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||
	    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit ||
	    (unsigned char *)e + e->next_offset > limit) {
		duprintf(""Bad offset %p, limit = %p\n"", e, limit);
		return -EINVAL;
	}

	if (e->next_offset < sizeof(struct compat_arpt_entry) +
			     sizeof(struct compat_xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 e, e->next_offset);
		return -EINVAL;
	}

	/* For purposes of check_entry casting the compat entry is fine */
	ret = check_entry((struct arpt_entry *)e);
	if (ret)
		return ret;

	off = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);
	entry_offset = (void *)e - (void *)base;

	t = compat_arpt_get_target(e);
	target = xt_request_find_target(NFPROTO_ARP, t->u.user.name,
					t->u.user.revision);
	if (IS_ERR(target)) {
		duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
			 t->u.user.name);
		ret = PTR_ERR(target);
		goto out;
	}
	t->u.kernel.target = target;

	off += xt_compat_target_offset(target);
	*size += off;
	ret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);
	if (ret)
		goto release_target;

	/* Check hooks & underflows */
	for (h = 0; h < NF_ARP_NUMHOOKS; h++) {
		if ((unsigned char *)e - base == hook_entries[h])
			newinfo->hook_entry[h] = hook_entries[h];
		if ((unsigned char *)e - base == underflows[h])
			newinfo->underflow[h] = underflows[h];
	}

	/* Clear counters and comefrom */
	memset(&e->counters, 0, sizeof(e->counters));
	e->comefrom = 0;
	return 0;

release_target:
	module_put(t->u.kernel.target->me);
out:
	return ret;
}","static inline int
check_compat_entry_size_and_hooks(struct compat_arpt_entry *VAR_0,
				  struct xt_table_info *VAR_1,
				  unsigned int *VAR_2,
				  const unsigned char *VAR_3,
				  const unsigned char *VAR_4,
				  const unsigned int *VAR_5,
				  const unsigned int *VAR_6,
				  const char *VAR_7)
{
	struct xt_entry_target *VAR_8;
	struct xt_target *VAR_9;
	unsigned int VAR_10;
	int VAR_11, VAR_12, VAR_13;

	duprintf(""check_compat_entry_size_and_hooks %p\n"", VAR_0);
	if ((unsigned long)VAR_0 % __alignof__(struct compat_arpt_entry) != 0 ||
	    (unsigned char *)VAR_0 + sizeof(struct compat_arpt_entry) >= VAR_4 ||
	    (unsigned char *)VAR_0 + VAR_0->next_offset > VAR_4) {
		duprintf(""Bad offset %p, limit = %p\n"", VAR_0, VAR_4);
		return -VAR_14;
	}

	if (VAR_0->next_offset < sizeof(struct compat_arpt_entry) +
			     sizeof(struct compat_xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 VAR_0, VAR_0->next_offset);
		return -VAR_14;
	}

	/* COMMENT_0 */
	VAR_11 = check_entry((struct arpt_entry *)VAR_0);
	if (VAR_11)
		return VAR_11;

	VAR_12 = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);
	VAR_10 = (void *)VAR_0 - (void *)VAR_3;

	VAR_8 = compat_arpt_get_target(VAR_0);
	VAR_9 = xt_request_find_target(VAR_15, VAR_8->u.user.name,
					VAR_8->u.user.revision);
	if (IS_ERR(VAR_9)) {
		duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
			 VAR_8->u.user.name);
		VAR_11 = PTR_ERR(VAR_9);
		goto out;
	}
	VAR_8->u.kernel.target = VAR_9;

	VAR_12 += xt_compat_target_offset(VAR_9);
	*VAR_2 += VAR_12;
	VAR_11 = xt_compat_add_offset(VAR_15, VAR_10, VAR_12);
	if (VAR_11)
		goto release_target;

	/* COMMENT_1 */
	for (VAR_13 = 0; VAR_13 < VAR_16; VAR_13++) {
		if ((unsigned char *)VAR_0 - VAR_3 == VAR_5[VAR_13])
			VAR_1->hook_entry[VAR_13] = VAR_5[VAR_13];
		if ((unsigned char *)VAR_0 - VAR_3 == VAR_6[VAR_13])
			VAR_1->underflow[VAR_13] = VAR_6[VAR_13];
	}

	/* COMMENT_2 */
	memset(&VAR_0->counters, 0, sizeof(VAR_0->counters));
	VAR_0->comefrom = 0;
	return 0;

release_target:
	module_put(VAR_8->u.kernel.target->me);
out:
	return VAR_11;
}",torvalds/linux/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91/arp_tables.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -15,7 +15,8 @@
 
 	duprintf(""check_compat_entry_size_and_hooks %p\n"", e);
 	if ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||
-	    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit) {
+	    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit ||
+	    (unsigned char *)e + e->next_offset > limit) {
 		duprintf(""Bad offset %p, limit = %p\n"", e, limit);
 		return -EINVAL;
 	}","{'deleted_lines': ['\t    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit) {'], 'added_lines': ['\t    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit ||', '\t    (unsigned char *)e + e->next_offset > limit) {']}",True,The IPT_SO_SET_REPLACE setsockopt implementation in the netfilter subsystem in the Linux kernel before 4.6 allows local users to cause a denial of service (out-of-bounds read) or possibly obtain sensitive information from kernel heap memory by leveraging in-container root access to provide a crafted offset value that leads to crossing a ruleset blob boundary.,7.1,HIGH,2,test,2016-03-22T17:02:50Z,1
CVE-2016-4998,['CWE-119'],AV:L/AC:L/Au:N/C:P/I:N/A:C,0,torvalds/linux,"netfilter: x_tables: make sure e->next_offset covers remaining blob size

Otherwise this function may read data beyond the ruleset blob.

Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91,https://github.com/torvalds/linux/commit/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91,net/ipv4/netfilter/ip_tables.c,check_entry_size_and_hooks,"static int
check_entry_size_and_hooks(struct ipt_entry *e,
struct xt_table_info *newinfo,
const unsigned char *base,
const unsigned char *limit,
const unsigned int *hook_entries,
const unsigned int *underflows,
unsigned int valid_hooks)
{
unsigned int h;
int err;
if ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||
(unsigned char *)e + sizeof(struct ipt_entry) >= limit) {
duprintf(""Bad offset %p\n"", e);
return -EINVAL;
}
if (e->next_offset
< sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
e, e->next_offset);
return -EINVAL;
}
err = check_entry(e);
if (err)
return err;
for (h = 0; h < NF_INET_NUMHOOKS; h++) {
if (!(valid_hooks & (1 << h)))
continue;
if ((unsigned char *)e - base == hook_entries[h])
newinfo->hook_entry[h] = hook_entries[h];
if ((unsigned char *)e - base == underflows[h]) {
if (!check_underflow(e)) {
pr_err(""Underflows must be unconditional and ""
""use the STANDARD target with ""
""ACCEPT/DROP\n"");
return -EINVAL;
}
newinfo->underflow[h] = underflows[h];
}
}
e->counters = ((struct xt_counters) { 0, 0 });
e->comefrom = 0;
return 0;
}","static int
check_entry_size_and_hooks(struct ipt_entry *VAR_0,
struct xt_table_info *VAR_1,
const unsigned char *VAR_2,
const unsigned char *VAR_3,
const unsigned int *VAR_4,
const unsigned int *VAR_5,
unsigned int VAR_6)
{
unsigned int VAR_7;
int VAR_8;
if ((unsigned long)VAR_0 % __alignof__(struct ipt_entry) != 0 ||
(unsigned char *)VAR_0 + sizeof(struct ipt_entry) >= VAR_3) {
duprintf(""Bad offset %p\n"", VAR_0);
return -VAR_9;
}
if (VAR_0->next_offset
< sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
VAR_0, VAR_0->next_offset);
return -VAR_9;
}
VAR_8 = check_entry(VAR_0);
if (VAR_8)
return VAR_8;
for (VAR_7 = 0; VAR_7 < VAR_10; VAR_7++) {
if (!(VAR_6 & (1 << VAR_7)))
continue;
if ((unsigned char *)VAR_0 - VAR_2 == VAR_4[VAR_7])
VAR_1->hook_entry[VAR_7] = VAR_4[VAR_7];
if ((unsigned char *)VAR_0 - VAR_2 == VAR_5[VAR_7]) {
if (!check_underflow(VAR_0)) {
pr_err(""Underflows must be unconditional and ""
""use the STANDARD target with ""
""ACCEPT/DROP\n"");
return -VAR_9;
}
VAR_1->underflow[VAR_7] = VAR_5[VAR_7];
}
}
VAR_0->counters = ((struct xt_counters) { 0, 0 });
VAR_0->comefrom = 0;
return 0;
}",torvalds/linux/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91/ip_tables.c/vul/before/0.json,"static int
check_entry_size_and_hooks(struct ipt_entry *e,
			   struct xt_table_info *newinfo,
			   const unsigned char *base,
			   const unsigned char *limit,
			   const unsigned int *hook_entries,
			   const unsigned int *underflows,
			   unsigned int valid_hooks)
{
	unsigned int h;
	int err;

	if ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||
	    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||
	    (unsigned char *)e + e->next_offset > limit) {
		duprintf(""Bad offset %p\n"", e);
		return -EINVAL;
	}

	if (e->next_offset
	    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 e, e->next_offset);
		return -EINVAL;
	}

	err = check_entry(e);
	if (err)
		return err;

	/* Check hooks & underflows */
	for (h = 0; h < NF_INET_NUMHOOKS; h++) {
		if (!(valid_hooks & (1 << h)))
			continue;
		if ((unsigned char *)e - base == hook_entries[h])
			newinfo->hook_entry[h] = hook_entries[h];
		if ((unsigned char *)e - base == underflows[h]) {
			if (!check_underflow(e)) {
				pr_err(""Underflows must be unconditional and ""
				       ""use the STANDARD target with ""
				       ""ACCEPT/DROP\n"");
				return -EINVAL;
			}
			newinfo->underflow[h] = underflows[h];
		}
	}

	/* Clear counters and comefrom */
	e->counters = ((struct xt_counters) { 0, 0 });
	e->comefrom = 0;
	return 0;
}","static int
check_entry_size_and_hooks(struct ipt_entry *VAR_0,
			   struct xt_table_info *VAR_1,
			   const unsigned char *VAR_2,
			   const unsigned char *VAR_3,
			   const unsigned int *VAR_4,
			   const unsigned int *VAR_5,
			   unsigned int VAR_6)
{
	unsigned int VAR_7;
	int VAR_8;

	if ((unsigned long)VAR_0 % __alignof__(struct ipt_entry) != 0 ||
	    (unsigned char *)VAR_0 + sizeof(struct ipt_entry) >= VAR_3 ||
	    (unsigned char *)VAR_0 + VAR_0->next_offset > VAR_3) {
		duprintf(""Bad offset %p\n"", VAR_0);
		return -VAR_9;
	}

	if (VAR_0->next_offset
	    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 VAR_0, VAR_0->next_offset);
		return -VAR_9;
	}

	VAR_8 = check_entry(VAR_0);
	if (VAR_8)
		return VAR_8;

	/* COMMENT_0 */
	for (VAR_7 = 0; VAR_7 < VAR_10; VAR_7++) {
		if (!(VAR_6 & (1 << VAR_7)))
			continue;
		if ((unsigned char *)VAR_0 - VAR_2 == VAR_4[VAR_7])
			VAR_1->hook_entry[VAR_7] = VAR_4[VAR_7];
		if ((unsigned char *)VAR_0 - VAR_2 == VAR_5[VAR_7]) {
			if (!check_underflow(VAR_0)) {
				pr_err(""Underflows must be unconditional and ""
				       ""use the STANDARD target with ""
				       ""ACCEPT/DROP\n"");
				return -VAR_9;
			}
			VAR_1->underflow[VAR_7] = VAR_5[VAR_7];
		}
	}

	/* COMMENT_1 */
	VAR_0->counters = ((struct xt_counters) { 0, 0 });
	VAR_0->comefrom = 0;
	return 0;
}",torvalds/linux/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91/ip_tables.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,7 +11,8 @@
 	int err;
 
 	if ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||
-	    (unsigned char *)e + sizeof(struct ipt_entry) >= limit) {
+	    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||
+	    (unsigned char *)e + e->next_offset > limit) {
 		duprintf(""Bad offset %p\n"", e);
 		return -EINVAL;
 	}","{'deleted_lines': ['\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit) {'], 'added_lines': ['\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||', '\t    (unsigned char *)e + e->next_offset > limit) {']}",True,The IPT_SO_SET_REPLACE setsockopt implementation in the netfilter subsystem in the Linux kernel before 4.6 allows local users to cause a denial of service (out-of-bounds read) or possibly obtain sensitive information from kernel heap memory by leveraging in-container root access to provide a crafted offset value that leads to crossing a ruleset blob boundary.,7.1,HIGH,2,test,2016-03-22T17:02:50Z,1
CVE-2016-4998,['CWE-119'],AV:L/AC:L/Au:N/C:P/I:N/A:C,0,torvalds/linux,"netfilter: x_tables: make sure e->next_offset covers remaining blob size

Otherwise this function may read data beyond the ruleset blob.

Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91,https://github.com/torvalds/linux/commit/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91,net/ipv4/netfilter/arp_tables.c,check_entry_size_and_hooks,"static inline int check_entry_size_and_hooks(struct arpt_entry *e,
struct xt_table_info *newinfo,
const unsigned char *base,
const unsigned char *limit,
const unsigned int *hook_entries,
const unsigned int *underflows,
unsigned int valid_hooks)
{
unsigned int h;
int err;
if ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||
(unsigned char *)e + sizeof(struct arpt_entry) >= limit) {
duprintf(""Bad offset %p\n"", e);
return -EINVAL;
}
if (e->next_offset
< sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
e, e->next_offset);
return -EINVAL;
}
err = check_entry(e);
if (err)
return err;
for (h = 0; h < NF_ARP_NUMHOOKS; h++) {
if (!(valid_hooks & (1 << h)))
continue;
if ((unsigned char *)e - base == hook_entries[h])
newinfo->hook_entry[h] = hook_entries[h];
if ((unsigned char *)e - base == underflows[h]) {
if (!check_underflow(e)) {
pr_err(""Underflows must be unconditional and ""
""use the STANDARD target with ""
""ACCEPT/DROP\n"");
return -EINVAL;
}
newinfo->underflow[h] = underflows[h];
}
}
e->counters = ((struct xt_counters) { 0, 0 });
e->comefrom = 0;
return 0;
}","static inline int check_entry_size_and_hooks(struct arpt_entry *VAR_0,
struct xt_table_info *VAR_1,
const unsigned char *VAR_2,
const unsigned char *VAR_3,
const unsigned int *VAR_4,
const unsigned int *VAR_5,
unsigned int VAR_6)
{
unsigned int VAR_7;
int VAR_8;
if ((unsigned long)VAR_0 % __alignof__(struct arpt_entry) != 0 ||
(unsigned char *)VAR_0 + sizeof(struct arpt_entry) >= VAR_3) {
duprintf(""Bad offset %p\n"", VAR_0);
return -VAR_9;
}
if (VAR_0->next_offset
< sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
VAR_0, VAR_0->next_offset);
return -VAR_9;
}
VAR_8 = check_entry(VAR_0);
if (VAR_8)
return VAR_8;
for (VAR_7 = 0; VAR_7 < VAR_10; VAR_7++) {
if (!(VAR_6 & (1 << VAR_7)))
continue;
if ((unsigned char *)VAR_0 - VAR_2 == VAR_4[VAR_7])
VAR_1->hook_entry[VAR_7] = VAR_4[VAR_7];
if ((unsigned char *)VAR_0 - VAR_2 == VAR_5[VAR_7]) {
if (!check_underflow(VAR_0)) {
pr_err(""Underflows must be unconditional and ""
""use the STANDARD target with ""
""ACCEPT/DROP\n"");
return -VAR_9;
}
VAR_1->underflow[VAR_7] = VAR_5[VAR_7];
}
}
VAR_0->counters = ((struct xt_counters) { 0, 0 });
VAR_0->comefrom = 0;
return 0;
}",torvalds/linux/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91/arp_tables.c/vul/before/0.json,"static inline int check_entry_size_and_hooks(struct arpt_entry *e,
					     struct xt_table_info *newinfo,
					     const unsigned char *base,
					     const unsigned char *limit,
					     const unsigned int *hook_entries,
					     const unsigned int *underflows,
					     unsigned int valid_hooks)
{
	unsigned int h;
	int err;

	if ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||
	    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||
	    (unsigned char *)e + e->next_offset > limit) {
		duprintf(""Bad offset %p\n"", e);
		return -EINVAL;
	}

	if (e->next_offset
	    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 e, e->next_offset);
		return -EINVAL;
	}

	err = check_entry(e);
	if (err)
		return err;

	/* Check hooks & underflows */
	for (h = 0; h < NF_ARP_NUMHOOKS; h++) {
		if (!(valid_hooks & (1 << h)))
			continue;
		if ((unsigned char *)e - base == hook_entries[h])
			newinfo->hook_entry[h] = hook_entries[h];
		if ((unsigned char *)e - base == underflows[h]) {
			if (!check_underflow(e)) {
				pr_err(""Underflows must be unconditional and ""
				       ""use the STANDARD target with ""
				       ""ACCEPT/DROP\n"");
				return -EINVAL;
			}
			newinfo->underflow[h] = underflows[h];
		}
	}

	/* Clear counters and comefrom */
	e->counters = ((struct xt_counters) { 0, 0 });
	e->comefrom = 0;
	return 0;
}","static inline int check_entry_size_and_hooks(struct arpt_entry *VAR_0,
					     struct xt_table_info *VAR_1,
					     const unsigned char *VAR_2,
					     const unsigned char *VAR_3,
					     const unsigned int *VAR_4,
					     const unsigned int *VAR_5,
					     unsigned int VAR_6)
{
	unsigned int VAR_7;
	int VAR_8;

	if ((unsigned long)VAR_0 % __alignof__(struct arpt_entry) != 0 ||
	    (unsigned char *)VAR_0 + sizeof(struct arpt_entry) >= VAR_3 ||
	    (unsigned char *)VAR_0 + VAR_0->next_offset > VAR_3) {
		duprintf(""Bad offset %p\n"", VAR_0);
		return -VAR_9;
	}

	if (VAR_0->next_offset
	    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 VAR_0, VAR_0->next_offset);
		return -VAR_9;
	}

	VAR_8 = check_entry(VAR_0);
	if (VAR_8)
		return VAR_8;

	/* COMMENT_0 */
	for (VAR_7 = 0; VAR_7 < VAR_10; VAR_7++) {
		if (!(VAR_6 & (1 << VAR_7)))
			continue;
		if ((unsigned char *)VAR_0 - VAR_2 == VAR_4[VAR_7])
			VAR_1->hook_entry[VAR_7] = VAR_4[VAR_7];
		if ((unsigned char *)VAR_0 - VAR_2 == VAR_5[VAR_7]) {
			if (!check_underflow(VAR_0)) {
				pr_err(""Underflows must be unconditional and ""
				       ""use the STANDARD target with ""
				       ""ACCEPT/DROP\n"");
				return -VAR_9;
			}
			VAR_1->underflow[VAR_7] = VAR_5[VAR_7];
		}
	}

	/* COMMENT_1 */
	VAR_0->counters = ((struct xt_counters) { 0, 0 });
	VAR_0->comefrom = 0;
	return 0;
}",torvalds/linux/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91/arp_tables.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,7 +10,8 @@
 	int err;
 
 	if ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||
-	    (unsigned char *)e + sizeof(struct arpt_entry) >= limit) {
+	    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||
+	    (unsigned char *)e + e->next_offset > limit) {
 		duprintf(""Bad offset %p\n"", e);
 		return -EINVAL;
 	}","{'deleted_lines': ['\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit) {'], 'added_lines': ['\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||', '\t    (unsigned char *)e + e->next_offset > limit) {']}",True,The IPT_SO_SET_REPLACE setsockopt implementation in the netfilter subsystem in the Linux kernel before 4.6 allows local users to cause a denial of service (out-of-bounds read) or possibly obtain sensitive information from kernel heap memory by leveraging in-container root access to provide a crafted offset value that leads to crossing a ruleset blob boundary.,7.1,HIGH,2,test,2016-03-22T17:02:50Z,1
CVE-2016-4998,['CWE-119'],AV:L/AC:L/Au:N/C:P/I:N/A:C,0,torvalds/linux,"netfilter: x_tables: make sure e->next_offset covers remaining blob size

Otherwise this function may read data beyond the ruleset blob.

Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91,https://github.com/torvalds/linux/commit/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91,net/ipv6/netfilter/ip6_tables.c,check_compat_entry_size_and_hooks,"static int
check_compat_entry_size_and_hooks(struct compat_ip6t_entry *e,
struct xt_table_info *newinfo,
unsigned int *size,
const unsigned char *base,
const unsigned char *limit,
const unsigned int *hook_entries,
const unsigned int *underflows,
const char *name)
{
struct xt_entry_match *ematch;
struct xt_entry_target *t;
struct xt_target *target;
unsigned int entry_offset;
unsigned int j;
int ret, off, h;
duprintf(""check_compat_entry_size_and_hooks %p\n"", e);
if ((unsigned long)e % __alignof__(struct compat_ip6t_entry) != 0 ||
(unsigned char *)e + sizeof(struct compat_ip6t_entry) >= limit) {
duprintf(""Bad offset %p, limit = %p\n"", e, limit);
return -EINVAL;
}
if (e->next_offset < sizeof(struct compat_ip6t_entry) +
sizeof(struct compat_xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
e, e->next_offset);
return -EINVAL;
}
ret = check_entry((struct ip6t_entry *)e);
if (ret)
return ret;
off = sizeof(struct ip6t_entry) - sizeof(struct compat_ip6t_entry);
entry_offset = (void *)e - (void *)base;
j = 0;
xt_ematch_foreach(ematch, e) {
ret = compat_find_calc_match(ematch, name, &e->ipv6, &off);
if (ret != 0)
goto release_matches;
++j;
}
t = compat_ip6t_get_target(e);
target = xt_request_find_target(NFPROTO_IPV6, t->u.user.name,
t->u.user.revision);
if (IS_ERR(target)) {
duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
t->u.user.name);
ret = PTR_ERR(target);
goto release_matches;
}
t->u.kernel.target = target;
off += xt_compat_target_offset(target);
*size += off;
ret = xt_compat_add_offset(AF_INET6, entry_offset, off);
if (ret)
goto out;
for (h = 0; h < NF_INET_NUMHOOKS; h++) {
if ((unsigned char *)e - base == hook_entries[h])
newinfo->hook_entry[h] = hook_entries[h];
if ((unsigned char *)e - base == underflows[h])
newinfo->underflow[h] = underflows[h];
}
memset(&e->counters, 0, sizeof(e->counters));
e->comefrom = 0;
return 0;
out:
module_put(t->u.kernel.target->me);
release_matches:
xt_ematch_foreach(ematch, e) {
if (j-- == 0)
break;
module_put(ematch->u.kernel.match->me);
}
return ret;
}","static int
check_compat_entry_size_and_hooks(struct compat_ip6t_entry *VAR_0,
struct xt_table_info *VAR_1,
unsigned int *VAR_2,
const unsigned char *VAR_3,
const unsigned char *VAR_4,
const unsigned int *VAR_5,
const unsigned int *VAR_6,
const char *VAR_7)
{
struct xt_entry_match *VAR_8;
struct xt_entry_target *VAR_9;
struct xt_target *VAR_10;
unsigned int VAR_11;
unsigned int VAR_12;
int VAR_13, VAR_14, VAR_15;
duprintf(""check_compat_entry_size_and_hooks %p\n"", VAR_0);
if ((unsigned long)VAR_0 % __alignof__(struct compat_ip6t_entry) != 0 ||
(unsigned char *)VAR_0 + sizeof(struct compat_ip6t_entry) >= VAR_4) {
duprintf(""Bad offset %p, limit = %p\n"", VAR_0, VAR_4);
return -VAR_16;
}
if (VAR_0->next_offset < sizeof(struct compat_ip6t_entry) +
sizeof(struct compat_xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
VAR_0, VAR_0->next_offset);
return -VAR_16;
}
VAR_13 = check_entry((struct ip6t_entry *)VAR_0);
if (VAR_13)
return VAR_13;
VAR_14 = sizeof(struct ip6t_entry) - sizeof(struct compat_ip6t_entry);
VAR_11 = (void *)VAR_0 - (void *)VAR_3;
VAR_12 = 0;
xt_ematch_foreach(VAR_8, VAR_0) {
VAR_13 = compat_find_calc_match(VAR_8, VAR_7, &VAR_0->ipv6, &VAR_14);
if (VAR_13 != 0)
goto release_matches;
++VAR_12;
}
VAR_9 = compat_ip6t_get_target(VAR_0);
VAR_10 = xt_request_find_target(VAR_17, VAR_9->u.user.name,
VAR_9->u.user.revision);
if (IS_ERR(VAR_10)) {
duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
VAR_9->u.user.name);
VAR_13 = PTR_ERR(VAR_10);
goto release_matches;
}
VAR_9->u.kernel.target = VAR_10;
VAR_14 += xt_compat_target_offset(VAR_10);
*VAR_2 += VAR_14;
VAR_13 = xt_compat_add_offset(VAR_18, VAR_11, VAR_14);
if (VAR_13)
goto out;
for (VAR_15 = 0; VAR_15 < VAR_19; VAR_15++) {
if ((unsigned char *)VAR_0 - VAR_3 == VAR_5[VAR_15])
VAR_1->hook_entry[VAR_15] = VAR_5[VAR_15];
if ((unsigned char *)VAR_0 - VAR_3 == VAR_6[VAR_15])
VAR_1->underflow[VAR_15] = VAR_6[VAR_15];
}
memset(&VAR_0->counters, 0, sizeof(VAR_0->counters));
VAR_0->comefrom = 0;
return 0;
out:
module_put(VAR_9->u.kernel.target->me);
release_matches:
xt_ematch_foreach(VAR_8, VAR_0) {
if (VAR_12-- == 0)
break;
module_put(VAR_8->u.kernel.match->me);
}
return VAR_13;
}",torvalds/linux/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91/ip6_tables.c/vul/before/1.json,"static int
check_compat_entry_size_and_hooks(struct compat_ip6t_entry *e,
				  struct xt_table_info *newinfo,
				  unsigned int *size,
				  const unsigned char *base,
				  const unsigned char *limit,
				  const unsigned int *hook_entries,
				  const unsigned int *underflows,
				  const char *name)
{
	struct xt_entry_match *ematch;
	struct xt_entry_target *t;
	struct xt_target *target;
	unsigned int entry_offset;
	unsigned int j;
	int ret, off, h;

	duprintf(""check_compat_entry_size_and_hooks %p\n"", e);
	if ((unsigned long)e % __alignof__(struct compat_ip6t_entry) != 0 ||
	    (unsigned char *)e + sizeof(struct compat_ip6t_entry) >= limit ||
	    (unsigned char *)e + e->next_offset > limit) {
		duprintf(""Bad offset %p, limit = %p\n"", e, limit);
		return -EINVAL;
	}

	if (e->next_offset < sizeof(struct compat_ip6t_entry) +
			     sizeof(struct compat_xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 e, e->next_offset);
		return -EINVAL;
	}

	/* For purposes of check_entry casting the compat entry is fine */
	ret = check_entry((struct ip6t_entry *)e);
	if (ret)
		return ret;

	off = sizeof(struct ip6t_entry) - sizeof(struct compat_ip6t_entry);
	entry_offset = (void *)e - (void *)base;
	j = 0;
	xt_ematch_foreach(ematch, e) {
		ret = compat_find_calc_match(ematch, name, &e->ipv6, &off);
		if (ret != 0)
			goto release_matches;
		++j;
	}

	t = compat_ip6t_get_target(e);
	target = xt_request_find_target(NFPROTO_IPV6, t->u.user.name,
					t->u.user.revision);
	if (IS_ERR(target)) {
		duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
			 t->u.user.name);
		ret = PTR_ERR(target);
		goto release_matches;
	}
	t->u.kernel.target = target;

	off += xt_compat_target_offset(target);
	*size += off;
	ret = xt_compat_add_offset(AF_INET6, entry_offset, off);
	if (ret)
		goto out;

	/* Check hooks & underflows */
	for (h = 0; h < NF_INET_NUMHOOKS; h++) {
		if ((unsigned char *)e - base == hook_entries[h])
			newinfo->hook_entry[h] = hook_entries[h];
		if ((unsigned char *)e - base == underflows[h])
			newinfo->underflow[h] = underflows[h];
	}

	/* Clear counters and comefrom */
	memset(&e->counters, 0, sizeof(e->counters));
	e->comefrom = 0;
	return 0;

out:
	module_put(t->u.kernel.target->me);
release_matches:
	xt_ematch_foreach(ematch, e) {
		if (j-- == 0)
			break;
		module_put(ematch->u.kernel.match->me);
	}
	return ret;
}","static int
check_compat_entry_size_and_hooks(struct compat_ip6t_entry *VAR_0,
				  struct xt_table_info *VAR_1,
				  unsigned int *VAR_2,
				  const unsigned char *VAR_3,
				  const unsigned char *VAR_4,
				  const unsigned int *VAR_5,
				  const unsigned int *VAR_6,
				  const char *VAR_7)
{
	struct xt_entry_match *VAR_8;
	struct xt_entry_target *VAR_9;
	struct xt_target *VAR_10;
	unsigned int VAR_11;
	unsigned int VAR_12;
	int VAR_13, VAR_14, VAR_15;

	duprintf(""check_compat_entry_size_and_hooks %p\n"", VAR_0);
	if ((unsigned long)VAR_0 % __alignof__(struct compat_ip6t_entry) != 0 ||
	    (unsigned char *)VAR_0 + sizeof(struct compat_ip6t_entry) >= VAR_4 ||
	    (unsigned char *)VAR_0 + VAR_0->next_offset > VAR_4) {
		duprintf(""Bad offset %p, limit = %p\n"", VAR_0, VAR_4);
		return -VAR_16;
	}

	if (VAR_0->next_offset < sizeof(struct compat_ip6t_entry) +
			     sizeof(struct compat_xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 VAR_0, VAR_0->next_offset);
		return -VAR_16;
	}

	/* COMMENT_0 */
	VAR_13 = check_entry((struct ip6t_entry *)VAR_0);
	if (VAR_13)
		return VAR_13;

	VAR_14 = sizeof(struct ip6t_entry) - sizeof(struct compat_ip6t_entry);
	VAR_11 = (void *)VAR_0 - (void *)VAR_3;
	VAR_12 = 0;
	xt_ematch_foreach(VAR_8, VAR_0) {
		VAR_13 = compat_find_calc_match(VAR_8, VAR_7, &VAR_0->ipv6, &VAR_14);
		if (VAR_13 != 0)
			goto release_matches;
		++VAR_12;
	}

	VAR_9 = compat_ip6t_get_target(VAR_0);
	VAR_10 = xt_request_find_target(VAR_17, VAR_9->u.user.name,
					VAR_9->u.user.revision);
	if (IS_ERR(VAR_10)) {
		duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
			 VAR_9->u.user.name);
		VAR_13 = PTR_ERR(VAR_10);
		goto release_matches;
	}
	VAR_9->u.kernel.target = VAR_10;

	VAR_14 += xt_compat_target_offset(VAR_10);
	*VAR_2 += VAR_14;
	VAR_13 = xt_compat_add_offset(VAR_18, VAR_11, VAR_14);
	if (VAR_13)
		goto out;

	/* COMMENT_1 */
	for (VAR_15 = 0; VAR_15 < VAR_19; VAR_15++) {
		if ((unsigned char *)VAR_0 - VAR_3 == VAR_5[VAR_15])
			VAR_1->hook_entry[VAR_15] = VAR_5[VAR_15];
		if ((unsigned char *)VAR_0 - VAR_3 == VAR_6[VAR_15])
			VAR_1->underflow[VAR_15] = VAR_6[VAR_15];
	}

	/* COMMENT_2 */
	memset(&VAR_0->counters, 0, sizeof(VAR_0->counters));
	VAR_0->comefrom = 0;
	return 0;

out:
	module_put(VAR_9->u.kernel.target->me);
release_matches:
	xt_ematch_foreach(VAR_8, VAR_0) {
		if (VAR_12-- == 0)
			break;
		module_put(VAR_8->u.kernel.match->me);
	}
	return VAR_13;
}",torvalds/linux/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91/ip6_tables.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -17,7 +17,8 @@
 
 	duprintf(""check_compat_entry_size_and_hooks %p\n"", e);
 	if ((unsigned long)e % __alignof__(struct compat_ip6t_entry) != 0 ||
-	    (unsigned char *)e + sizeof(struct compat_ip6t_entry) >= limit) {
+	    (unsigned char *)e + sizeof(struct compat_ip6t_entry) >= limit ||
+	    (unsigned char *)e + e->next_offset > limit) {
 		duprintf(""Bad offset %p, limit = %p\n"", e, limit);
 		return -EINVAL;
 	}","{'deleted_lines': ['\t    (unsigned char *)e + sizeof(struct compat_ip6t_entry) >= limit) {'], 'added_lines': ['\t    (unsigned char *)e + sizeof(struct compat_ip6t_entry) >= limit ||', '\t    (unsigned char *)e + e->next_offset > limit) {']}",True,The IPT_SO_SET_REPLACE setsockopt implementation in the netfilter subsystem in the Linux kernel before 4.6 allows local users to cause a denial of service (out-of-bounds read) or possibly obtain sensitive information from kernel heap memory by leveraging in-container root access to provide a crafted offset value that leads to crossing a ruleset blob boundary.,7.1,HIGH,2,test,2016-03-22T17:02:50Z,1
CVE-2016-4998,['CWE-119'],AV:L/AC:L/Au:N/C:P/I:N/A:C,0,torvalds/linux,"netfilter: x_tables: make sure e->next_offset covers remaining blob size

Otherwise this function may read data beyond the ruleset blob.

Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91,https://github.com/torvalds/linux/commit/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91,net/ipv4/netfilter/ip_tables.c,check_compat_entry_size_and_hooks,"static int
check_compat_entry_size_and_hooks(struct compat_ipt_entry *e,
struct xt_table_info *newinfo,
unsigned int *size,
const unsigned char *base,
const unsigned char *limit,
const unsigned int *hook_entries,
const unsigned int *underflows,
const char *name)
{
struct xt_entry_match *ematch;
struct xt_entry_target *t;
struct xt_target *target;
unsigned int entry_offset;
unsigned int j;
int ret, off, h;
duprintf(""check_compat_entry_size_and_hooks %p\n"", e);
if ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||
(unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit) {
duprintf(""Bad offset %p, limit = %p\n"", e, limit);
return -EINVAL;
}
if (e->next_offset < sizeof(struct compat_ipt_entry) +
sizeof(struct compat_xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
e, e->next_offset);
return -EINVAL;
}
ret = check_entry((struct ipt_entry *)e);
if (ret)
return ret;
off = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);
entry_offset = (void *)e - (void *)base;
j = 0;
xt_ematch_foreach(ematch, e) {
ret = compat_find_calc_match(ematch, name, &e->ip, &off);
if (ret != 0)
goto release_matches;
++j;
}
t = compat_ipt_get_target(e);
target = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,
t->u.user.revision);
if (IS_ERR(target)) {
duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
t->u.user.name);
ret = PTR_ERR(target);
goto release_matches;
}
t->u.kernel.target = target;
off += xt_compat_target_offset(target);
*size += off;
ret = xt_compat_add_offset(AF_INET, entry_offset, off);
if (ret)
goto out;
for (h = 0; h < NF_INET_NUMHOOKS; h++) {
if ((unsigned char *)e - base == hook_entries[h])
newinfo->hook_entry[h] = hook_entries[h];
if ((unsigned char *)e - base == underflows[h])
newinfo->underflow[h] = underflows[h];
}
memset(&e->counters, 0, sizeof(e->counters));
e->comefrom = 0;
return 0;
out:
module_put(t->u.kernel.target->me);
release_matches:
xt_ematch_foreach(ematch, e) {
if (j-- == 0)
break;
module_put(ematch->u.kernel.match->me);
}
return ret;
}","static int
check_compat_entry_size_and_hooks(struct compat_ipt_entry *VAR_0,
struct xt_table_info *VAR_1,
unsigned int *VAR_2,
const unsigned char *VAR_3,
const unsigned char *VAR_4,
const unsigned int *VAR_5,
const unsigned int *VAR_6,
const char *VAR_7)
{
struct xt_entry_match *VAR_8;
struct xt_entry_target *VAR_9;
struct xt_target *VAR_10;
unsigned int VAR_11;
unsigned int VAR_12;
int VAR_13, VAR_14, VAR_15;
duprintf(""check_compat_entry_size_and_hooks %p\n"", VAR_0);
if ((unsigned long)VAR_0 % __alignof__(struct compat_ipt_entry) != 0 ||
(unsigned char *)VAR_0 + sizeof(struct compat_ipt_entry) >= VAR_4) {
duprintf(""Bad offset %p, limit = %p\n"", VAR_0, VAR_4);
return -VAR_16;
}
if (VAR_0->next_offset < sizeof(struct compat_ipt_entry) +
sizeof(struct compat_xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
VAR_0, VAR_0->next_offset);
return -VAR_16;
}
VAR_13 = check_entry((struct ipt_entry *)VAR_0);
if (VAR_13)
return VAR_13;
VAR_14 = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);
VAR_11 = (void *)VAR_0 - (void *)VAR_3;
VAR_12 = 0;
xt_ematch_foreach(VAR_8, VAR_0) {
VAR_13 = compat_find_calc_match(VAR_8, VAR_7, &VAR_0->ip, &VAR_14);
if (VAR_13 != 0)
goto release_matches;
++VAR_12;
}
VAR_9 = compat_ipt_get_target(VAR_0);
VAR_10 = xt_request_find_target(VAR_17, VAR_9->u.user.name,
VAR_9->u.user.revision);
if (IS_ERR(VAR_10)) {
duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
VAR_9->u.user.name);
VAR_13 = PTR_ERR(VAR_10);
goto release_matches;
}
VAR_9->u.kernel.target = VAR_10;
VAR_14 += xt_compat_target_offset(VAR_10);
*VAR_2 += VAR_14;
VAR_13 = xt_compat_add_offset(VAR_18, VAR_11, VAR_14);
if (VAR_13)
goto out;
for (VAR_15 = 0; VAR_15 < VAR_19; VAR_15++) {
if ((unsigned char *)VAR_0 - VAR_3 == VAR_5[VAR_15])
VAR_1->hook_entry[VAR_15] = VAR_5[VAR_15];
if ((unsigned char *)VAR_0 - VAR_3 == VAR_6[VAR_15])
VAR_1->underflow[VAR_15] = VAR_6[VAR_15];
}
memset(&VAR_0->counters, 0, sizeof(VAR_0->counters));
VAR_0->comefrom = 0;
return 0;
out:
module_put(VAR_9->u.kernel.target->me);
release_matches:
xt_ematch_foreach(VAR_8, VAR_0) {
if (VAR_12-- == 0)
break;
module_put(VAR_8->u.kernel.match->me);
}
return VAR_13;
}",torvalds/linux/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91/ip_tables.c/vul/before/1.json,"static int
check_compat_entry_size_and_hooks(struct compat_ipt_entry *e,
				  struct xt_table_info *newinfo,
				  unsigned int *size,
				  const unsigned char *base,
				  const unsigned char *limit,
				  const unsigned int *hook_entries,
				  const unsigned int *underflows,
				  const char *name)
{
	struct xt_entry_match *ematch;
	struct xt_entry_target *t;
	struct xt_target *target;
	unsigned int entry_offset;
	unsigned int j;
	int ret, off, h;

	duprintf(""check_compat_entry_size_and_hooks %p\n"", e);
	if ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||
	    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit ||
	    (unsigned char *)e + e->next_offset > limit) {
		duprintf(""Bad offset %p, limit = %p\n"", e, limit);
		return -EINVAL;
	}

	if (e->next_offset < sizeof(struct compat_ipt_entry) +
			     sizeof(struct compat_xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 e, e->next_offset);
		return -EINVAL;
	}

	/* For purposes of check_entry casting the compat entry is fine */
	ret = check_entry((struct ipt_entry *)e);
	if (ret)
		return ret;

	off = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);
	entry_offset = (void *)e - (void *)base;
	j = 0;
	xt_ematch_foreach(ematch, e) {
		ret = compat_find_calc_match(ematch, name, &e->ip, &off);
		if (ret != 0)
			goto release_matches;
		++j;
	}

	t = compat_ipt_get_target(e);
	target = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,
					t->u.user.revision);
	if (IS_ERR(target)) {
		duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
			 t->u.user.name);
		ret = PTR_ERR(target);
		goto release_matches;
	}
	t->u.kernel.target = target;

	off += xt_compat_target_offset(target);
	*size += off;
	ret = xt_compat_add_offset(AF_INET, entry_offset, off);
	if (ret)
		goto out;

	/* Check hooks & underflows */
	for (h = 0; h < NF_INET_NUMHOOKS; h++) {
		if ((unsigned char *)e - base == hook_entries[h])
			newinfo->hook_entry[h] = hook_entries[h];
		if ((unsigned char *)e - base == underflows[h])
			newinfo->underflow[h] = underflows[h];
	}

	/* Clear counters and comefrom */
	memset(&e->counters, 0, sizeof(e->counters));
	e->comefrom = 0;
	return 0;

out:
	module_put(t->u.kernel.target->me);
release_matches:
	xt_ematch_foreach(ematch, e) {
		if (j-- == 0)
			break;
		module_put(ematch->u.kernel.match->me);
	}
	return ret;
}","static int
check_compat_entry_size_and_hooks(struct compat_ipt_entry *VAR_0,
				  struct xt_table_info *VAR_1,
				  unsigned int *VAR_2,
				  const unsigned char *VAR_3,
				  const unsigned char *VAR_4,
				  const unsigned int *VAR_5,
				  const unsigned int *VAR_6,
				  const char *VAR_7)
{
	struct xt_entry_match *VAR_8;
	struct xt_entry_target *VAR_9;
	struct xt_target *VAR_10;
	unsigned int VAR_11;
	unsigned int VAR_12;
	int VAR_13, VAR_14, VAR_15;

	duprintf(""check_compat_entry_size_and_hooks %p\n"", VAR_0);
	if ((unsigned long)VAR_0 % __alignof__(struct compat_ipt_entry) != 0 ||
	    (unsigned char *)VAR_0 + sizeof(struct compat_ipt_entry) >= VAR_4 ||
	    (unsigned char *)VAR_0 + VAR_0->next_offset > VAR_4) {
		duprintf(""Bad offset %p, limit = %p\n"", VAR_0, VAR_4);
		return -VAR_16;
	}

	if (VAR_0->next_offset < sizeof(struct compat_ipt_entry) +
			     sizeof(struct compat_xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 VAR_0, VAR_0->next_offset);
		return -VAR_16;
	}

	/* COMMENT_0 */
	VAR_13 = check_entry((struct ipt_entry *)VAR_0);
	if (VAR_13)
		return VAR_13;

	VAR_14 = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);
	VAR_11 = (void *)VAR_0 - (void *)VAR_3;
	VAR_12 = 0;
	xt_ematch_foreach(VAR_8, VAR_0) {
		VAR_13 = compat_find_calc_match(VAR_8, VAR_7, &VAR_0->ip, &VAR_14);
		if (VAR_13 != 0)
			goto release_matches;
		++VAR_12;
	}

	VAR_9 = compat_ipt_get_target(VAR_0);
	VAR_10 = xt_request_find_target(VAR_17, VAR_9->u.user.name,
					VAR_9->u.user.revision);
	if (IS_ERR(VAR_10)) {
		duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
			 VAR_9->u.user.name);
		VAR_13 = PTR_ERR(VAR_10);
		goto release_matches;
	}
	VAR_9->u.kernel.target = VAR_10;

	VAR_14 += xt_compat_target_offset(VAR_10);
	*VAR_2 += VAR_14;
	VAR_13 = xt_compat_add_offset(VAR_18, VAR_11, VAR_14);
	if (VAR_13)
		goto out;

	/* COMMENT_1 */
	for (VAR_15 = 0; VAR_15 < VAR_19; VAR_15++) {
		if ((unsigned char *)VAR_0 - VAR_3 == VAR_5[VAR_15])
			VAR_1->hook_entry[VAR_15] = VAR_5[VAR_15];
		if ((unsigned char *)VAR_0 - VAR_3 == VAR_6[VAR_15])
			VAR_1->underflow[VAR_15] = VAR_6[VAR_15];
	}

	/* COMMENT_2 */
	memset(&VAR_0->counters, 0, sizeof(VAR_0->counters));
	VAR_0->comefrom = 0;
	return 0;

out:
	module_put(VAR_9->u.kernel.target->me);
release_matches:
	xt_ematch_foreach(VAR_8, VAR_0) {
		if (VAR_12-- == 0)
			break;
		module_put(VAR_8->u.kernel.match->me);
	}
	return VAR_13;
}",torvalds/linux/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91/ip_tables.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -17,7 +17,8 @@
 
 	duprintf(""check_compat_entry_size_and_hooks %p\n"", e);
 	if ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||
-	    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit) {
+	    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit ||
+	    (unsigned char *)e + e->next_offset > limit) {
 		duprintf(""Bad offset %p, limit = %p\n"", e, limit);
 		return -EINVAL;
 	}","{'deleted_lines': ['\t    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit) {'], 'added_lines': ['\t    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit ||', '\t    (unsigned char *)e + e->next_offset > limit) {']}",True,The IPT_SO_SET_REPLACE setsockopt implementation in the netfilter subsystem in the Linux kernel before 4.6 allows local users to cause a denial of service (out-of-bounds read) or possibly obtain sensitive information from kernel heap memory by leveraging in-container root access to provide a crafted offset value that leads to crossing a ruleset blob boundary.,7.1,HIGH,2,test,2016-03-22T17:02:50Z,1
CVE-2016-4998,['CWE-119'],AV:L/AC:L/Au:N/C:P/I:N/A:C,0,torvalds/linux,"netfilter: x_tables: make sure e->next_offset covers remaining blob size

Otherwise this function may read data beyond the ruleset blob.

Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91,https://github.com/torvalds/linux/commit/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91,net/ipv6/netfilter/ip6_tables.c,check_entry_size_and_hooks,"static int
check_entry_size_and_hooks(struct ip6t_entry *e,
struct xt_table_info *newinfo,
const unsigned char *base,
const unsigned char *limit,
const unsigned int *hook_entries,
const unsigned int *underflows,
unsigned int valid_hooks)
{
unsigned int h;
int err;
if ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||
(unsigned char *)e + sizeof(struct ip6t_entry) >= limit) {
duprintf(""Bad offset %p\n"", e);
return -EINVAL;
}
if (e->next_offset
< sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
e, e->next_offset);
return -EINVAL;
}
err = check_entry(e);
if (err)
return err;
for (h = 0; h < NF_INET_NUMHOOKS; h++) {
if (!(valid_hooks & (1 << h)))
continue;
if ((unsigned char *)e - base == hook_entries[h])
newinfo->hook_entry[h] = hook_entries[h];
if ((unsigned char *)e - base == underflows[h]) {
if (!check_underflow(e)) {
pr_err(""Underflows must be unconditional and ""
""use the STANDARD target with ""
""ACCEPT/DROP\n"");
return -EINVAL;
}
newinfo->underflow[h] = underflows[h];
}
}
e->counters = ((struct xt_counters) { 0, 0 });
e->comefrom = 0;
return 0;
}","static int
check_entry_size_and_hooks(struct ip6t_entry *VAR_0,
struct xt_table_info *VAR_1,
const unsigned char *VAR_2,
const unsigned char *VAR_3,
const unsigned int *VAR_4,
const unsigned int *VAR_5,
unsigned int VAR_6)
{
unsigned int VAR_7;
int VAR_8;
if ((unsigned long)VAR_0 % __alignof__(struct ip6t_entry) != 0 ||
(unsigned char *)VAR_0 + sizeof(struct ip6t_entry) >= VAR_3) {
duprintf(""Bad offset %p\n"", VAR_0);
return -VAR_9;
}
if (VAR_0->next_offset
< sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
VAR_0, VAR_0->next_offset);
return -VAR_9;
}
VAR_8 = check_entry(VAR_0);
if (VAR_8)
return VAR_8;
for (VAR_7 = 0; VAR_7 < VAR_10; VAR_7++) {
if (!(VAR_6 & (1 << VAR_7)))
continue;
if ((unsigned char *)VAR_0 - VAR_2 == VAR_4[VAR_7])
VAR_1->hook_entry[VAR_7] = VAR_4[VAR_7];
if ((unsigned char *)VAR_0 - VAR_2 == VAR_5[VAR_7]) {
if (!check_underflow(VAR_0)) {
pr_err(""Underflows must be unconditional and ""
""use the STANDARD target with ""
""ACCEPT/DROP\n"");
return -VAR_9;
}
VAR_1->underflow[VAR_7] = VAR_5[VAR_7];
}
}
VAR_0->counters = ((struct xt_counters) { 0, 0 });
VAR_0->comefrom = 0;
return 0;
}",torvalds/linux/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91/ip6_tables.c/vul/before/0.json,"static int
check_entry_size_and_hooks(struct ip6t_entry *e,
			   struct xt_table_info *newinfo,
			   const unsigned char *base,
			   const unsigned char *limit,
			   const unsigned int *hook_entries,
			   const unsigned int *underflows,
			   unsigned int valid_hooks)
{
	unsigned int h;
	int err;

	if ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||
	    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||
	    (unsigned char *)e + e->next_offset > limit) {
		duprintf(""Bad offset %p\n"", e);
		return -EINVAL;
	}

	if (e->next_offset
	    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 e, e->next_offset);
		return -EINVAL;
	}

	err = check_entry(e);
	if (err)
		return err;

	/* Check hooks & underflows */
	for (h = 0; h < NF_INET_NUMHOOKS; h++) {
		if (!(valid_hooks & (1 << h)))
			continue;
		if ((unsigned char *)e - base == hook_entries[h])
			newinfo->hook_entry[h] = hook_entries[h];
		if ((unsigned char *)e - base == underflows[h]) {
			if (!check_underflow(e)) {
				pr_err(""Underflows must be unconditional and ""
				       ""use the STANDARD target with ""
				       ""ACCEPT/DROP\n"");
				return -EINVAL;
			}
			newinfo->underflow[h] = underflows[h];
		}
	}

	/* Clear counters and comefrom */
	e->counters = ((struct xt_counters) { 0, 0 });
	e->comefrom = 0;
	return 0;
}","static int
check_entry_size_and_hooks(struct ip6t_entry *VAR_0,
			   struct xt_table_info *VAR_1,
			   const unsigned char *VAR_2,
			   const unsigned char *VAR_3,
			   const unsigned int *VAR_4,
			   const unsigned int *VAR_5,
			   unsigned int VAR_6)
{
	unsigned int VAR_7;
	int VAR_8;

	if ((unsigned long)VAR_0 % __alignof__(struct ip6t_entry) != 0 ||
	    (unsigned char *)VAR_0 + sizeof(struct ip6t_entry) >= VAR_3 ||
	    (unsigned char *)VAR_0 + VAR_0->next_offset > VAR_3) {
		duprintf(""Bad offset %p\n"", VAR_0);
		return -VAR_9;
	}

	if (VAR_0->next_offset
	    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 VAR_0, VAR_0->next_offset);
		return -VAR_9;
	}

	VAR_8 = check_entry(VAR_0);
	if (VAR_8)
		return VAR_8;

	/* COMMENT_0 */
	for (VAR_7 = 0; VAR_7 < VAR_10; VAR_7++) {
		if (!(VAR_6 & (1 << VAR_7)))
			continue;
		if ((unsigned char *)VAR_0 - VAR_2 == VAR_4[VAR_7])
			VAR_1->hook_entry[VAR_7] = VAR_4[VAR_7];
		if ((unsigned char *)VAR_0 - VAR_2 == VAR_5[VAR_7]) {
			if (!check_underflow(VAR_0)) {
				pr_err(""Underflows must be unconditional and ""
				       ""use the STANDARD target with ""
				       ""ACCEPT/DROP\n"");
				return -VAR_9;
			}
			VAR_1->underflow[VAR_7] = VAR_5[VAR_7];
		}
	}

	/* COMMENT_1 */
	VAR_0->counters = ((struct xt_counters) { 0, 0 });
	VAR_0->comefrom = 0;
	return 0;
}",torvalds/linux/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91/ip6_tables.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,7 +11,8 @@
 	int err;
 
 	if ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||
-	    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit) {
+	    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||
+	    (unsigned char *)e + e->next_offset > limit) {
 		duprintf(""Bad offset %p\n"", e);
 		return -EINVAL;
 	}","{'deleted_lines': ['\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit) {'], 'added_lines': ['\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||', '\t    (unsigned char *)e + e->next_offset > limit) {']}",True,The IPT_SO_SET_REPLACE setsockopt implementation in the netfilter subsystem in the Linux kernel before 4.6 allows local users to cause a denial of service (out-of-bounds read) or possibly obtain sensitive information from kernel heap memory by leveraging in-container root access to provide a crafted offset value that leads to crossing a ruleset blob boundary.,7.1,HIGH,2,test,2016-03-22T17:02:50Z,1
CVE-2016-1683,['CWE-119'],AV:N/AC:H/Au:N/C:P/I:P/A:P,0,GNOME/libxslt,"Fix xsltNumberFormatGetMultipleLevel

Namespace nodes are actually an xmlNs, not an xmlNode. They must be
special-cased in xsltNumberFormatGetMultipleLevel to avoid an
out-of-bounds heap access.

Move the test whether a node matches the ""count"" pattern to a separate
function to make the code more readable. As a side effect, we also
compare expanded names when walking up the ancestor axis, fixing an
insignificant bug.",d182d8f6ba3071503d96ce17395c9d55871f0242,https://github.com/GNOME/libxslt/commit/d182d8f6ba3071503d96ce17395c9d55871f0242,libxslt/numbers.c,xsltNumberFormatGetMultipleLevel,"static int
xsltNumberFormatGetMultipleLevel(xsltTransformContextPtr context,
xmlNodePtr node,
xsltCompMatchPtr countPat,
xsltCompMatchPtr fromPat,
double *array,
int max)
{
int amount = 0;
int cnt;
xmlNodePtr ancestor;
xmlNodePtr preceding;
xmlXPathParserContextPtr parser;
context->xpathCtxt->node = node;
parser = xmlXPathNewParserContext(NULL, context->xpathCtxt);
if (parser) {
for (ancestor = node;
(ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE);
ancestor = xmlXPathNextAncestor(parser, ancestor)) {
if ((fromPat != NULL) &&
xsltTestCompMatchList(context, ancestor, fromPat))
break; 
if ((countPat == NULL && node->type == ancestor->type &&
xmlStrEqual(node->name, ancestor->name)) ||
xsltTestCompMatchList(context, ancestor, countPat)) {
cnt = 0;
for (preceding = ancestor;
preceding != NULL;
preceding =
xmlXPathNextPrecedingSibling(parser, preceding)) {
if (countPat == NULL) {
if ((preceding->type == ancestor->type) &&
xmlStrEqual(preceding->name, ancestor->name)){
if ((preceding->ns == ancestor->ns) ||
((preceding->ns != NULL) &&
(ancestor->ns != NULL) &&
(xmlStrEqual(preceding->ns->href,
ancestor->ns->href) )))
cnt++;
}
} else {
if (xsltTestCompMatchList(context, preceding,
countPat))
cnt++;
}
}
array[amount++] = (double)cnt;
if (amount >= max)
break; 
}
}
xmlXPathFreeParserContext(parser);
}
return amount;
}","static int
xsltNumberFormatGetMultipleLevel(xsltTransformContextPtr VAR_0,
xmlNodePtr VAR_1,
xsltCompMatchPtr VAR_2,
xsltCompMatchPtr VAR_3,
double *VAR_4,
int VAR_5)
{
int VAR_6 = 0;
int VAR_7;
xmlNodePtr VAR_8;
xmlNodePtr VAR_9;
xmlXPathParserContextPtr VAR_10;
VAR_0->xpathCtxt->node = VAR_1;
VAR_10 = xmlXPathNewParserContext(NULL, VAR_0->xpathCtxt);
if (VAR_10) {
for (VAR_8 = VAR_1;
(VAR_8 != NULL) && (VAR_8->type != VAR_11);
VAR_8 = xmlXPathNextAncestor(VAR_10, VAR_8)) {
if ((VAR_3 != NULL) &&
xsltTestCompMatchList(VAR_0, VAR_8, VAR_3))
break; 
if ((VAR_2 == NULL && VAR_1->type == VAR_8->type &&
xmlStrEqual(VAR_1->name, VAR_8->name)) ||
xsltTestCompMatchList(VAR_0, VAR_8, VAR_2)) {
VAR_7 = 0;
for (VAR_9 = VAR_8;
VAR_9 != NULL;
VAR_9 =
xmlXPathNextPrecedingSibling(VAR_10, VAR_9)) {
if (VAR_2 == NULL) {
if ((VAR_9->type == VAR_8->type) &&
xmlStrEqual(VAR_9->name, VAR_8->name)){
if ((VAR_9->ns == VAR_8->ns) ||
((VAR_9->ns != NULL) &&
(VAR_8->ns != NULL) &&
(xmlStrEqual(VAR_9->ns->href,
VAR_8->ns->href) )))
VAR_7++;
}
} else {
if (xsltTestCompMatchList(VAR_0, VAR_9,
VAR_2))
VAR_7++;
}
}
VAR_4[VAR_6++] = (double)VAR_7;
if (VAR_6 >= VAR_5)
break; 
}
}
xmlXPathFreeParserContext(VAR_10);
}
return VAR_6;
}",GNOME/libxslt/d182d8f6ba3071503d96ce17395c9d55871f0242/numbers.c/vul/before/1.json,"static int
xsltNumberFormatGetMultipleLevel(xsltTransformContextPtr context,
				 xmlNodePtr node,
				 xsltCompMatchPtr countPat,
				 xsltCompMatchPtr fromPat,
				 double *array,
				 int max)
{
    int amount = 0;
    int cnt;
    xmlNodePtr ancestor;
    xmlNodePtr preceding;
    xmlXPathParserContextPtr parser;

    context->xpathCtxt->node = node;
    parser = xmlXPathNewParserContext(NULL, context->xpathCtxt);
    if (parser) {
	/* ancestor-or-self::*[count] */
	for (ancestor = node;
	     (ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE);
	     ancestor = xmlXPathNextAncestor(parser, ancestor)) {

	    if ((fromPat != NULL) &&
		xsltTestCompMatchList(context, ancestor, fromPat))
		break; /* for */

	    if (xsltTestCompMatchCount(context, ancestor, countPat, node)) {
		/* count(preceding-sibling::*) */
		cnt = 1;
		for (preceding =
                        xmlXPathNextPrecedingSibling(parser, ancestor);
		     preceding != NULL;
		     preceding =
		        xmlXPathNextPrecedingSibling(parser, preceding)) {

	            if (xsltTestCompMatchCount(context, preceding, countPat,
                                               node))
			cnt++;
		}
		array[amount++] = (double)cnt;
		if (amount >= max)
		    break; /* for */
	    }
	}
	xmlXPathFreeParserContext(parser);
    }
    return amount;
}","static int
xsltNumberFormatGetMultipleLevel(xsltTransformContextPtr VAR_0,
				 xmlNodePtr VAR_1,
				 xsltCompMatchPtr VAR_2,
				 xsltCompMatchPtr VAR_3,
				 double *VAR_4,
				 int VAR_5)
{
    int VAR_6 = 0;
    int VAR_7;
    xmlNodePtr VAR_8;
    xmlNodePtr VAR_9;
    xmlXPathParserContextPtr VAR_10;

    VAR_0->xpathCtxt->node = VAR_1;
    VAR_10 = xmlXPathNewParserContext(NULL, VAR_0->xpathCtxt);
    if (VAR_10) {
	/* COMMENT_0 */
	for (VAR_8 = VAR_1;
	     (VAR_8 != NULL) && (VAR_8->type != VAR_11);
	     VAR_8 = xmlXPathNextAncestor(VAR_10, VAR_8)) {

	    if ((VAR_3 != NULL) &&
		xsltTestCompMatchList(VAR_0, VAR_8, VAR_3))
		break; /* COMMENT_1 */

	    if (xsltTestCompMatchCount(VAR_0, VAR_8, VAR_2, VAR_1)) {
		/* COMMENT_2 */
		VAR_7 = 1;
		for (VAR_9 =
                        xmlXPathNextPrecedingSibling(VAR_10, VAR_8);
		     VAR_9 != NULL;
		     VAR_9 =
		        xmlXPathNextPrecedingSibling(VAR_10, VAR_9)) {

	            if (xsltTestCompMatchCount(VAR_0, VAR_9, VAR_2,
                                               VAR_1))
			VAR_7++;
		}
		VAR_4[VAR_6++] = (double)VAR_7;
		if (VAR_6 >= VAR_5)
		    break; /* COMMENT_1 */
	    }
	}
	xmlXPathFreeParserContext(VAR_10);
    }
    return VAR_6;
}",GNOME/libxslt/d182d8f6ba3071503d96ce17395c9d55871f0242/numbers.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -24,30 +24,18 @@
 		xsltTestCompMatchList(context, ancestor, fromPat))
 		break; /* for */
 
-	    if ((countPat == NULL && node->type == ancestor->type &&
-		xmlStrEqual(node->name, ancestor->name)) ||
-		xsltTestCompMatchList(context, ancestor, countPat)) {
+	    if (xsltTestCompMatchCount(context, ancestor, countPat, node)) {
 		/* count(preceding-sibling::*) */
-		cnt = 0;
-		for (preceding = ancestor;
+		cnt = 1;
+		for (preceding =
+                        xmlXPathNextPrecedingSibling(parser, ancestor);
 		     preceding != NULL;
 		     preceding =
 		        xmlXPathNextPrecedingSibling(parser, preceding)) {
-		    if (countPat == NULL) {
-			if ((preceding->type == ancestor->type) &&
-			    xmlStrEqual(preceding->name, ancestor->name)){
-			    if ((preceding->ns == ancestor->ns) ||
-			        ((preceding->ns != NULL) &&
-				 (ancestor->ns != NULL) &&
-			         (xmlStrEqual(preceding->ns->href,
-			             ancestor->ns->href) )))
-			        cnt++;
-			}
-		    } else {
-			if (xsltTestCompMatchList(context, preceding,
-				                  countPat))
-			    cnt++;
-		    }
+
+	            if (xsltTestCompMatchCount(context, preceding, countPat,
+                                               node))
+			cnt++;
 		}
 		array[amount++] = (double)cnt;
 		if (amount >= max)","{'deleted_lines': ['\t    if ((countPat == NULL && node->type == ancestor->type &&', '\t\txmlStrEqual(node->name, ancestor->name)) ||', '\t\txsltTestCompMatchList(context, ancestor, countPat)) {', '\t\tcnt = 0;', '\t\tfor (preceding = ancestor;', '\t\t    if (countPat == NULL) {', '\t\t\tif ((preceding->type == ancestor->type) &&', '\t\t\t    xmlStrEqual(preceding->name, ancestor->name)){', '\t\t\t    if ((preceding->ns == ancestor->ns) ||', '\t\t\t        ((preceding->ns != NULL) &&', '\t\t\t\t (ancestor->ns != NULL) &&', '\t\t\t         (xmlStrEqual(preceding->ns->href,', '\t\t\t             ancestor->ns->href) )))', '\t\t\t        cnt++;', '\t\t\t}', '\t\t    } else {', '\t\t\tif (xsltTestCompMatchList(context, preceding,', '\t\t\t\t                  countPat))', '\t\t\t    cnt++;', '\t\t    }'], 'added_lines': ['\t    if (xsltTestCompMatchCount(context, ancestor, countPat, node)) {', '\t\tcnt = 1;', '\t\tfor (preceding =', '                        xmlXPathNextPrecedingSibling(parser, ancestor);', '', '\t            if (xsltTestCompMatchCount(context, preceding, countPat,', '                                               node))', '\t\t\tcnt++;']}",True,"numbers.c in libxslt before 1.1.29, as used in Google Chrome before 51.0.2704.63, mishandles namespace nodes, which allows remote attackers to cause a denial of service (out-of-bounds heap memory access) or possibly have unspecified other impact via a crafted document.",7.5,HIGH,2,test,2016-03-22T17:20:01Z,1
CVE-2016-1683,['CWE-119'],AV:N/AC:H/Au:N/C:P/I:P/A:P,0,GNOME/libxslt,"Fix xsltNumberFormatGetMultipleLevel

Namespace nodes are actually an xmlNs, not an xmlNode. They must be
special-cased in xsltNumberFormatGetMultipleLevel to avoid an
out-of-bounds heap access.

Move the test whether a node matches the ""count"" pattern to a separate
function to make the code more readable. As a side effect, we also
compare expanded names when walking up the ancestor axis, fixing an
insignificant bug.",d182d8f6ba3071503d96ce17395c9d55871f0242,https://github.com/GNOME/libxslt/commit/d182d8f6ba3071503d96ce17395c9d55871f0242,libxslt/numbers.c,xsltNumberFormatGetAnyLevel,"static int
xsltNumberFormatGetAnyLevel(xsltTransformContextPtr context,
xmlNodePtr node,
xsltCompMatchPtr countPat,
xsltCompMatchPtr fromPat,
double *array)
{
int amount = 0;
int cnt = 0;
xmlNodePtr cur;
switch (node->type) {
case XML_ELEMENT_NODE:
cur = node;
break;
case XML_ATTRIBUTE_NODE:
cur = ((xmlAttrPtr) node)->parent;
break;
case XML_TEXT_NODE:
case XML_PI_NODE:
case XML_COMMENT_NODE:
cur = node->parent;
break;
default:
cur = NULL;
break;
}
while (cur != NULL) {
if (countPat == NULL) {
if ((node->type == cur->type) &&
xmlStrEqual(node->name, cur->name)) {
if ((node->ns == cur->ns) ||
((node->ns != NULL) &&
(cur->ns != NULL) &&
(xmlStrEqual(node->ns->href,
cur->ns->href) )))
cnt++;
}
} else {
if (xsltTestCompMatchList(context, cur, countPat))
cnt++;
}
if ((fromPat != NULL) &&
xsltTestCompMatchList(context, cur, fromPat)) {
break; 
}
if ((cur->type == XML_DOCUMENT_NODE) ||
#ifdef LIBXML_DOCB_ENABLED
(cur->type == XML_DOCB_DOCUMENT_NODE) ||
#endif
(cur->type == XML_HTML_DOCUMENT_NODE))
break; 
while ((cur->prev != NULL) && ((cur->prev->type == XML_DTD_NODE) ||
(cur->prev->type == XML_XINCLUDE_START) ||
(cur->prev->type == XML_XINCLUDE_END)))
cur = cur->prev;
if (cur->prev != NULL) {
for (cur = cur->prev; cur->last != NULL; cur = cur->last);
} else {
cur = cur->parent;
}
}
array[amount++] = (double) cnt;
return(amount);
}","static int
xsltNumberFormatGetAnyLevel(xsltTransformContextPtr VAR_0,
xmlNodePtr VAR_1,
xsltCompMatchPtr VAR_2,
xsltCompMatchPtr VAR_3,
double *VAR_4)
{
int VAR_5 = 0;
int VAR_6 = 0;
xmlNodePtr VAR_7;
switch (VAR_1->type) {
case VAR_8:
VAR_7 = VAR_1;
break;
case VAR_9:
VAR_7 = ((xmlAttrPtr) VAR_1)->parent;
break;
case VAR_10:
case VAR_11:
case VAR_12:
VAR_7 = VAR_1->parent;
break;
default:
VAR_7 = NULL;
break;
}
while (VAR_7 != NULL) {
if (VAR_2 == NULL) {
if ((VAR_1->type == VAR_7->type) &&
xmlStrEqual(VAR_1->name, VAR_7->name)) {
if ((VAR_1->ns == VAR_7->ns) ||
((VAR_1->ns != NULL) &&
(VAR_7->ns != NULL) &&
(xmlStrEqual(VAR_1->ns->href,
VAR_7->ns->href) )))
VAR_6++;
}
} else {
if (xsltTestCompMatchList(VAR_0, VAR_7, VAR_2))
VAR_6++;
}
if ((VAR_3 != NULL) &&
xsltTestCompMatchList(VAR_0, VAR_7, VAR_3)) {
break; 
}
if ((VAR_7->type == VAR_13) ||
#ifdef LIBXML_DOCB_ENABLED
(VAR_7->type == VAR_14) ||
#endif
(VAR_7->type == VAR_15))
break; 
while ((VAR_7->prev != NULL) && ((VAR_7->prev->type == VAR_16) ||
(VAR_7->prev->type == VAR_17) ||
(VAR_7->prev->type == VAR_18)))
VAR_7 = VAR_7->prev;
if (VAR_7->prev != NULL) {
for (VAR_7 = VAR_7->prev; VAR_7->last != NULL; VAR_7 = VAR_7->last);
} else {
VAR_7 = VAR_7->parent;
}
}
VAR_4[VAR_5++] = (double) VAR_6;
return(VAR_5);
}",GNOME/libxslt/d182d8f6ba3071503d96ce17395c9d55871f0242/numbers.c/vul/before/0.json,"static int
xsltNumberFormatGetAnyLevel(xsltTransformContextPtr context,
			    xmlNodePtr node,
			    xsltCompMatchPtr countPat,
			    xsltCompMatchPtr fromPat,
			    double *array)
{
    int amount = 0;
    int cnt = 0;
    xmlNodePtr cur;

    /* select the starting node */
    switch (node->type) {
	case XML_ELEMENT_NODE:
	    cur = node;
	    break;
	case XML_ATTRIBUTE_NODE:
	    cur = ((xmlAttrPtr) node)->parent;
	    break;
	case XML_TEXT_NODE:
	case XML_PI_NODE:
	case XML_COMMENT_NODE:
	    cur = node->parent;
	    break;
	default:
	    cur = NULL;
	    break;
    }

    while (cur != NULL) {
	/* process current node */
	if (xsltTestCompMatchCount(context, cur, countPat, node))
	    cnt++;
	if ((fromPat != NULL) &&
	    xsltTestCompMatchList(context, cur, fromPat)) {
	    break; /* while */
	}

	/* Skip to next preceding or ancestor */
	if ((cur->type == XML_DOCUMENT_NODE) ||
#ifdef LIBXML_DOCB_ENABLED
            (cur->type == XML_DOCB_DOCUMENT_NODE) ||
#endif
            (cur->type == XML_HTML_DOCUMENT_NODE))
	    break; /* while */

	while ((cur->prev != NULL) && ((cur->prev->type == XML_DTD_NODE) ||
	       (cur->prev->type == XML_XINCLUDE_START) ||
	       (cur->prev->type == XML_XINCLUDE_END)))
	    cur = cur->prev;
	if (cur->prev != NULL) {
	    for (cur = cur->prev; cur->last != NULL; cur = cur->last);
	} else {
	    cur = cur->parent;
	}

    }

    array[amount++] = (double) cnt;

    return(amount);
}","static int
xsltNumberFormatGetAnyLevel(xsltTransformContextPtr VAR_0,
			    xmlNodePtr VAR_1,
			    xsltCompMatchPtr VAR_2,
			    xsltCompMatchPtr VAR_3,
			    double *VAR_4)
{
    int VAR_5 = 0;
    int VAR_6 = 0;
    xmlNodePtr VAR_7;

    /* COMMENT_0 */
    switch (VAR_1->type) {
	case VAR_8:
	    VAR_7 = VAR_1;
	    break;
	case VAR_9:
	    VAR_7 = ((xmlAttrPtr) VAR_1)->parent;
	    break;
	case VAR_10:
	case VAR_11:
	case VAR_12:
	    VAR_7 = VAR_1->parent;
	    break;
	default:
	    VAR_7 = NULL;
	    break;
    }

    while (VAR_7 != NULL) {
	/* COMMENT_1 */
	if (xsltTestCompMatchCount(VAR_0, VAR_7, VAR_2, VAR_1))
	    VAR_6++;
	if ((VAR_3 != NULL) &&
	    xsltTestCompMatchList(VAR_0, VAR_7, VAR_3)) {
	    break; /* COMMENT_2 */
	}

	/* COMMENT_3 */
	if ((VAR_7->type == VAR_13) ||
#ifdef LIBXML_DOCB_ENABLED
            (VAR_7->type == VAR_14) ||
#endif
            (VAR_7->type == VAR_15))
	    break; /* COMMENT_2 */

	while ((VAR_7->prev != NULL) && ((VAR_7->prev->type == VAR_16) ||
	       (VAR_7->prev->type == VAR_17) ||
	       (VAR_7->prev->type == VAR_18)))
	    VAR_7 = VAR_7->prev;
	if (VAR_7->prev != NULL) {
	    for (VAR_7 = VAR_7->prev; VAR_7->last != NULL; VAR_7 = VAR_7->last);
	} else {
	    VAR_7 = VAR_7->parent;
	}

    }

    VAR_4[VAR_5++] = (double) VAR_6;

    return(VAR_5);
}",GNOME/libxslt/d182d8f6ba3071503d96ce17395c9d55871f0242/numbers.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -29,21 +29,8 @@
 
     while (cur != NULL) {
 	/* process current node */
-	if (countPat == NULL) {
-	    if ((node->type == cur->type) &&
-		/* FIXME: must use expanded-name instead of local name */
-		xmlStrEqual(node->name, cur->name)) {
-		    if ((node->ns == cur->ns) ||
-		        ((node->ns != NULL) &&
-			 (cur->ns != NULL) &&
-		         (xmlStrEqual(node->ns->href,
-		             cur->ns->href) )))
-		        cnt++;
-	    }
-	} else {
-	    if (xsltTestCompMatchList(context, cur, countPat))
-		cnt++;
-	}
+	if (xsltTestCompMatchCount(context, cur, countPat, node))
+	    cnt++;
 	if ((fromPat != NULL) &&
 	    xsltTestCompMatchList(context, cur, fromPat)) {
 	    break; /* while */","{'deleted_lines': ['\tif (countPat == NULL) {', '\t    if ((node->type == cur->type) &&', '\t\t/* FIXME: must use expanded-name instead of local name */', '\t\txmlStrEqual(node->name, cur->name)) {', '\t\t    if ((node->ns == cur->ns) ||', '\t\t        ((node->ns != NULL) &&', '\t\t\t (cur->ns != NULL) &&', '\t\t         (xmlStrEqual(node->ns->href,', '\t\t             cur->ns->href) )))', '\t\t        cnt++;', '\t    }', '\t} else {', '\t    if (xsltTestCompMatchList(context, cur, countPat))', '\t\tcnt++;', '\t}'], 'added_lines': ['\tif (xsltTestCompMatchCount(context, cur, countPat, node))', '\t    cnt++;']}",True,"numbers.c in libxslt before 1.1.29, as used in Google Chrome before 51.0.2704.63, mishandles namespace nodes, which allows remote attackers to cause a denial of service (out-of-bounds heap memory access) or possibly have unspecified other impact via a crafted document.",7.5,HIGH,2,test,2016-03-22T17:20:01Z,1
CVE-2015-8865,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,"Fixed bug #71527 Buffer over-write in finfo_open with malformed magic file

The actual fix is applying the upstream patch from
https://github.com/file/file/commit/6713ca45e7757297381f4b4cdb9cf5e624a9ad36",e93c6910fceb62d19fe143e351a86eee8df9b456,https://github.com/php/php-src/commit/e93c6910fceb62d19fe143e351a86eee8df9b456,ext/fileinfo/libmagic/funcs.c,file_check_mem,"protected int
file_check_mem(struct magic_set *ms, unsigned int level)
{
size_t len;
if (level >= ms->c.len) {
len = (ms->c.len += 20) * sizeof(*ms->c.li);
ms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?
emalloc(len) :
erealloc(ms->c.li, len));
if (ms->c.li == NULL) {
file_oomem(ms, len);
return -1;
}
}
ms->c.li[level].got_match = 0;
#ifdef ENABLE_CONDITIONALS
ms->c.li[level].last_match = 0;
ms->c.li[level].last_cond = COND_NONE;
#endif 
return 0;
}","protected VAR_0
file_check_mem(struct magic_set *VAR_1, unsigned int VAR_2)
{
size_t VAR_3;
if (VAR_2 >= VAR_1->c.len) {
VAR_3 = (VAR_1->c.len += 20) * sizeof(*VAR_1->c.li);
VAR_1->c.li = CAST(struct VAR_4 *, (VAR_1->c.li == NULL) ?
emalloc(VAR_3) :
erealloc(VAR_1->c.li, VAR_3));
if (VAR_1->c.li == NULL) {
file_oomem(VAR_1, VAR_3);
return -1;
}
}
VAR_1->c.li[VAR_2].got_match = 0;
#ifdef VAR_5
VAR_1->c.li[VAR_2].last_match = 0;
VAR_1->c.li[VAR_2].last_cond = VAR_6;
#endif 
return 0;
}",,"protected int
file_check_mem(struct magic_set *ms, unsigned int level)
{
	size_t len;

	if (level >= ms->c.len) {
		len = (ms->c.len += 20 + level) * sizeof(*ms->c.li);
		ms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?
		    emalloc(len) :
		    erealloc(ms->c.li, len));
		if (ms->c.li == NULL) {
			file_oomem(ms, len);
			return -1;
		}
	}
	ms->c.li[level].got_match = 0;
#ifdef ENABLE_CONDITIONALS
	ms->c.li[level].last_match = 0;
	ms->c.li[level].last_cond = COND_NONE;
#endif /* ENABLE_CONDITIONALS */
	return 0;
}","protected VAR_0
file_check_mem(struct magic_set *VAR_1, unsigned int VAR_2)
{
	size_t VAR_3;

	if (VAR_2 >= VAR_1->c.len) {
		VAR_3 = (VAR_1->c.len += 20 + VAR_2) * sizeof(*VAR_1->c.li);
		VAR_1->c.li = CAST(struct VAR_4 *, (VAR_1->c.li == NULL) ?
		    emalloc(VAR_3) :
		    erealloc(VAR_1->c.li, VAR_3));
		if (VAR_1->c.li == NULL) {
			file_oomem(VAR_1, VAR_3);
			return -1;
		}
	}
	VAR_1->c.li[VAR_2].got_match = 0;
#ifdef VAR_5
	VAR_1->c.li[VAR_2].last_match = 0;
	VAR_1->c.li[VAR_2].last_cond = VAR_6;
#endif /* COMMENT_0 */
	return 0;
}",,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
 	size_t len;
 
 	if (level >= ms->c.len) {
-		len = (ms->c.len += 20) * sizeof(*ms->c.li);
+		len = (ms->c.len += 20 + level) * sizeof(*ms->c.li);
 		ms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?
 		    emalloc(len) :
 		    erealloc(ms->c.li, len));","{'deleted_lines': ['\t\tlen = (ms->c.len += 20) * sizeof(*ms->c.li);'], 'added_lines': ['\t\tlen = (ms->c.len += 20 + level) * sizeof(*ms->c.li);']}",True,"The file_check_mem function in funcs.c in file before 5.23, as used in the Fileinfo component in PHP before 5.5.34, 5.6.x before 5.6.20, and 7.x before 7.0.5, mishandles continuation-level jumps, which allows context-dependent attackers to cause a denial of service (buffer overflow and application crash) or possibly execute arbitrary code via a crafted magic file.",7.3,HIGH,2,test,2016-03-27T22:45:19Z,1
CVE-2015-8865,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,"Fixed bug #71527 Buffer over-write in finfo_open with malformed magic file

The actual fix is applying the upstream patch from
https://github.com/file/file/commit/6713ca45e7757297381f4b4cdb9cf5e624a9ad36",fe13566c93f118a15a96320a546c7878fd0cfc5e,https://github.com/php/php-src/commit/fe13566c93f118a15a96320a546c7878fd0cfc5e,ext/fileinfo/libmagic/funcs.c,file_check_mem,"protected int
file_check_mem(struct magic_set *ms, unsigned int level)
{
size_t len;
if (level >= ms->c.len) {
len = (ms->c.len += 20) * sizeof(*ms->c.li);
ms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?
emalloc(len) :
erealloc(ms->c.li, len));
if (ms->c.li == NULL) {
file_oomem(ms, len);
return -1;
}
}
ms->c.li[level].got_match = 0;
#ifdef ENABLE_CONDITIONALS
ms->c.li[level].last_match = 0;
ms->c.li[level].last_cond = COND_NONE;
#endif 
return 0;
}","protected VAR_0
file_check_mem(struct magic_set *VAR_1, unsigned int VAR_2)
{
size_t VAR_3;
if (VAR_2 >= VAR_1->c.len) {
VAR_3 = (VAR_1->c.len += 20) * sizeof(*VAR_1->c.li);
VAR_1->c.li = CAST(struct VAR_4 *, (VAR_1->c.li == NULL) ?
emalloc(VAR_3) :
erealloc(VAR_1->c.li, VAR_3));
if (VAR_1->c.li == NULL) {
file_oomem(VAR_1, VAR_3);
return -1;
}
}
VAR_1->c.li[VAR_2].got_match = 0;
#ifdef VAR_5
VAR_1->c.li[VAR_2].last_match = 0;
VAR_1->c.li[VAR_2].last_cond = VAR_6;
#endif 
return 0;
}",,"protected int
file_check_mem(struct magic_set *ms, unsigned int level)
{
	size_t len;

	if (level >= ms->c.len) {
		len = (ms->c.len += 20 + level) * sizeof(*ms->c.li);
		ms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?
		    emalloc(len) :
		    erealloc(ms->c.li, len));
		if (ms->c.li == NULL) {
			file_oomem(ms, len);
			return -1;
		}
	}
	ms->c.li[level].got_match = 0;
#ifdef ENABLE_CONDITIONALS
	ms->c.li[level].last_match = 0;
	ms->c.li[level].last_cond = COND_NONE;
#endif /* ENABLE_CONDITIONALS */
	return 0;
}","protected VAR_0
file_check_mem(struct magic_set *VAR_1, unsigned int VAR_2)
{
	size_t VAR_3;

	if (VAR_2 >= VAR_1->c.len) {
		VAR_3 = (VAR_1->c.len += 20 + VAR_2) * sizeof(*VAR_1->c.li);
		VAR_1->c.li = CAST(struct VAR_4 *, (VAR_1->c.li == NULL) ?
		    emalloc(VAR_3) :
		    erealloc(VAR_1->c.li, VAR_3));
		if (VAR_1->c.li == NULL) {
			file_oomem(VAR_1, VAR_3);
			return -1;
		}
	}
	VAR_1->c.li[VAR_2].got_match = 0;
#ifdef VAR_5
	VAR_1->c.li[VAR_2].last_match = 0;
	VAR_1->c.li[VAR_2].last_cond = VAR_6;
#endif /* COMMENT_0 */
	return 0;
}",,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
 	size_t len;
 
 	if (level >= ms->c.len) {
-		len = (ms->c.len += 20) * sizeof(*ms->c.li);
+		len = (ms->c.len += 20 + level) * sizeof(*ms->c.li);
 		ms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?
 		    emalloc(len) :
 		    erealloc(ms->c.li, len));","{'deleted_lines': ['\t\tlen = (ms->c.len += 20) * sizeof(*ms->c.li);'], 'added_lines': ['\t\tlen = (ms->c.len += 20 + level) * sizeof(*ms->c.li);']}",True,"The file_check_mem function in funcs.c in file before 5.23, as used in the Fileinfo component in PHP before 5.5.34, 5.6.x before 5.6.20, and 7.x before 7.0.5, mishandles continuation-level jumps, which allows context-dependent attackers to cause a denial of service (buffer overflow and application crash) or possibly execute arbitrary code via a crafted magic file.",7.3,HIGH,2,test,2016-03-27T22:45:19Z,1
CVE-2016-2187,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Input: gtco - fix crash on detecting device without endpoints

The gtco driver expects at least one valid endpoint. If given malicious
descriptors that specify 0 for the number of endpoints, it will crash in
the probe function. Ensure there is at least one endpoint on the interface
before using it.

Also let's fix a minor coding style issue.

The full correct report of this issue can be found in the public
Red Hat Bugzilla:

https://bugzilla.redhat.com/show_bug.cgi?id=1283385

Reported-by: Ralf Spenneberg <ralf@spenneberg.net>
Signed-off-by: Vladis Dronov <vdronov@redhat.com>
Cc: stable@vger.kernel.org
Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>",162f98dea487206d9ab79fc12ed64700667a894d,https://github.com/torvalds/linux/commit/162f98dea487206d9ab79fc12ed64700667a894d,drivers/input/tablet/gtco.c,gtco_probe,"static int gtco_probe(struct usb_interface *usbinterface,
const struct usb_device_id *id)
{
struct gtco             *gtco;
struct input_dev        *input_dev;
struct hid_descriptor   *hid_desc;
char                    *report;
int                     result = 0, retry;
interror;
struct usb_endpoint_descriptor *endpoint;
gtco = kzalloc(sizeof(struct gtco), GFP_KERNEL);
input_dev = input_allocate_device();
if (!gtco || !input_dev) {
dev_err(&usbinterface->dev, ""No more memory\n"");
error = -ENOMEM;
goto err_free_devs;
}
gtco->inputdevice = input_dev;
gtco->usbdev = interface_to_usbdev(usbinterface);
gtco->intf = usbinterface;
gtco->buffer = usb_alloc_coherent(gtco->usbdev, REPORT_MAX_SIZE,
GFP_KERNEL, &gtco->buf_dma);
if (!gtco->buffer) {
dev_err(&usbinterface->dev, ""No more memory for us buffers\n"");
error = -ENOMEM;
goto err_free_devs;
}
gtco->urbinfo = usb_alloc_urb(0, GFP_KERNEL);
if (!gtco->urbinfo) {
dev_err(&usbinterface->dev, ""Failed to allocate URB\n"");
error = -ENOMEM;
goto err_free_buf;
}
endpoint = &usbinterface->altsetting[0].endpoint[0].desc;
dev_dbg(&usbinterface->dev, ""gtco # interfaces: %d\n"", usbinterface->num_altsetting);
dev_dbg(&usbinterface->dev, ""num endpoints:     %d\n"", usbinterface->cur_altsetting->desc.bNumEndpoints);
dev_dbg(&usbinterface->dev, ""interface class:   %d\n"", usbinterface->cur_altsetting->desc.bInterfaceClass);
dev_dbg(&usbinterface->dev, ""endpoint: attribute:0x%x type:0x%x\n"", endpoint->bmAttributes, endpoint->bDescriptorType);
if (usb_endpoint_xfer_int(endpoint))
dev_dbg(&usbinterface->dev, ""endpoint: we have interrupt endpoint\n"");
dev_dbg(&usbinterface->dev, ""endpoint extra len:%d\n"", usbinterface->altsetting[0].extralen);
if (usb_get_extra_descriptor(usbinterface->cur_altsetting,
HID_DEVICE_TYPE, &hid_desc) != 0){
dev_err(&usbinterface->dev,
""Can't retrieve exta USB descriptor to get hid report descriptor length\n"");
error = -EIO;
goto err_free_urb;
}
dev_dbg(&usbinterface->dev,
""Extra descriptor success: type:%d  len:%d\n"",
hid_desc->bDescriptorType,  hid_desc->wDescriptorLength);
report = kzalloc(le16_to_cpu(hid_desc->wDescriptorLength), GFP_KERNEL);
if (!report) {
dev_err(&usbinterface->dev, ""No more memory for report\n"");
error = -ENOMEM;
goto err_free_urb;
}
for (retry = 0; retry < 3; retry++) {
result = usb_control_msg(gtco->usbdev,
usb_rcvctrlpipe(gtco->usbdev, 0),
USB_REQ_GET_DESCRIPTOR,
USB_RECIP_INTERFACE | USB_DIR_IN,
REPORT_DEVICE_TYPE << 8,
0, 
report,
le16_to_cpu(hid_desc->wDescriptorLength),
5000); 
dev_dbg(&usbinterface->dev, ""usb_control_msg result: %d\n"", result);
if (result == le16_to_cpu(hid_desc->wDescriptorLength)) {
parse_hid_report_descriptor(gtco, report, result);
break;
}
}
kfree(report);
if (result != le16_to_cpu(hid_desc->wDescriptorLength)) {
dev_err(&usbinterface->dev,
""Failed to get HID Report Descriptor of size: %d\n"",
hid_desc->wDescriptorLength);
error = -EIO;
goto err_free_urb;
}
usb_make_path(gtco->usbdev, gtco->usbpath, sizeof(gtco->usbpath));
strlcat(gtco->usbpath, ""/input0"", sizeof(gtco->usbpath));
input_dev->open = gtco_input_open;
input_dev->close = gtco_input_close;
input_dev->name = ""GTCO_CalComp"";
input_dev->phys = gtco->usbpath;
input_set_drvdata(input_dev, gtco);
gtco_setup_caps(input_dev);
usb_to_input_id(gtco->usbdev, &input_dev->id);
input_dev->dev.parent = &usbinterface->dev;
endpoint = &usbinterface->altsetting[0].endpoint[0].desc;
usb_fill_int_urb(gtco->urbinfo,
gtco->usbdev,
usb_rcvintpipe(gtco->usbdev,
endpoint->bEndpointAddress),
gtco->buffer,
REPORT_MAX_SIZE,
gtco_urb_callback,
gtco,
endpoint->bInterval);
gtco->urbinfo->transfer_dma = gtco->buf_dma;
gtco->urbinfo->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
usb_set_intfdata(usbinterface, gtco);
error = input_register_device(input_dev);
if (error)
goto err_free_urb;
return 0;
err_free_urb:
usb_free_urb(gtco->urbinfo);
err_free_buf:
usb_free_coherent(gtco->usbdev, REPORT_MAX_SIZE,
gtco->buffer, gtco->buf_dma);
err_free_devs:
input_free_device(input_dev);
kfree(gtco);
return error;
}","static int gtco_probe(struct usb_interface *VAR_0,
const struct usb_device_id *VAR_1)
{
struct gtco             *gtco;
struct input_dev        *input_dev;
struct hid_descriptor   *VAR_2;
char                    *VAR_3;
int                     VAR_4 = 0, VAR_5;
intVAR_6;
struct usb_endpoint_descriptor *VAR_7;
gtco = kzalloc(sizeof(struct gtco), VAR_8);
input_dev = input_allocate_device();
if (!gtco || !input_dev) {
dev_err(&VAR_0->dev, ""No more memory\n"");
VAR_6 = -VAR_9;
goto err_free_devs;
}
gtco->inputdevice = input_dev;
gtco->usbdev = interface_to_usbdev(VAR_0);
gtco->intf = VAR_0;
gtco->buffer = usb_alloc_coherent(gtco->usbdev, VAR_10,
VAR_8, &gtco->buf_dma);
if (!gtco->buffer) {
dev_err(&VAR_0->dev, ""No more memory for us buffers\n"");
VAR_6 = -VAR_9;
goto err_free_devs;
}
gtco->urbinfo = usb_alloc_urb(0, VAR_8);
if (!gtco->urbinfo) {
dev_err(&VAR_0->dev, ""Failed to allocate URB\n"");
VAR_6 = -VAR_9;
goto err_free_buf;
}
VAR_7 = &VAR_0->altsetting[0].endpoint[0].desc;
dev_dbg(&VAR_0->dev, ""gtco # interfaces: %d\n"", VAR_0->num_altsetting);
dev_dbg(&VAR_0->dev, ""num endpoints:     %d\n"", VAR_0->cur_altsetting->desc.bNumEndpoints);
dev_dbg(&VAR_0->dev, ""interface class:   %d\n"", VAR_0->cur_altsetting->desc.bInterfaceClass);
dev_dbg(&VAR_0->dev, ""endpoint: attribute:0x%x type:0x%x\n"", VAR_7->bmAttributes, VAR_7->bDescriptorType);
if (usb_endpoint_xfer_int(VAR_7))
dev_dbg(&VAR_0->dev, ""endpoint: we have interrupt endpoint\n"");
dev_dbg(&VAR_0->dev, ""endpoint extra len:%d\n"", VAR_0->altsetting[0].extralen);
if (usb_get_extra_descriptor(VAR_0->cur_altsetting,
VAR_11, &VAR_2) != 0){
dev_err(&VAR_0->dev,
""Can't retrieve exta USB descriptor to get hid report descriptor length\n"");
VAR_6 = -VAR_12;
goto err_free_urb;
}
dev_dbg(&VAR_0->dev,
""Extra descriptor success: type:%d  len:%d\n"",
VAR_2->bDescriptorType,  VAR_2->wDescriptorLength);
VAR_3 = kzalloc(le16_to_cpu(VAR_2->wDescriptorLength), VAR_8);
if (!VAR_3) {
dev_err(&VAR_0->dev, ""No more memory for report\n"");
VAR_6 = -VAR_9;
goto err_free_urb;
}
for (VAR_5 = 0; VAR_5 < 3; VAR_5++) {
VAR_4 = usb_control_msg(gtco->usbdev,
usb_rcvctrlpipe(gtco->usbdev, 0),
VAR_13,
VAR_14 | VAR_15,
VAR_16 << 8,
0, 
VAR_3,
le16_to_cpu(VAR_2->wDescriptorLength),
5000); 
dev_dbg(&VAR_0->dev, ""usb_control_msg result: %d\n"", VAR_4);
if (VAR_4 == le16_to_cpu(VAR_2->wDescriptorLength)) {
parse_hid_report_descriptor(gtco, VAR_3, VAR_4);
break;
}
}
kfree(VAR_3);
if (VAR_4 != le16_to_cpu(VAR_2->wDescriptorLength)) {
dev_err(&VAR_0->dev,
""Failed to get HID Report Descriptor of size: %d\n"",
VAR_2->wDescriptorLength);
VAR_6 = -VAR_12;
goto err_free_urb;
}
usb_make_path(gtco->usbdev, gtco->usbpath, sizeof(gtco->usbpath));
strlcat(gtco->usbpath, ""/input0"", sizeof(gtco->usbpath));
input_dev->open = VAR_17;
input_dev->close = VAR_18;
input_dev->name = ""GTCO_CalComp"";
input_dev->phys = gtco->usbpath;
input_set_drvdata(input_dev, gtco);
gtco_setup_caps(input_dev);
usb_to_input_id(gtco->usbdev, &input_dev->id);
input_dev->dev.parent = &VAR_0->dev;
VAR_7 = &VAR_0->altsetting[0].endpoint[0].desc;
usb_fill_int_urb(gtco->urbinfo,
gtco->usbdev,
usb_rcvintpipe(gtco->usbdev,
VAR_7->bEndpointAddress),
gtco->buffer,
VAR_10,
VAR_19,
gtco,
VAR_7->bInterval);
gtco->urbinfo->transfer_dma = gtco->buf_dma;
gtco->urbinfo->transfer_flags |= VAR_20;
usb_set_intfdata(VAR_0, gtco);
VAR_6 = input_register_device(input_dev);
if (VAR_6)
goto err_free_urb;
return 0;
err_free_urb:
usb_free_urb(gtco->urbinfo);
err_free_buf:
usb_free_coherent(gtco->usbdev, VAR_10,
gtco->buffer, gtco->buf_dma);
err_free_devs:
input_free_device(input_dev);
kfree(gtco);
return VAR_6;
}",torvalds/linux/162f98dea487206d9ab79fc12ed64700667a894d/gtco.c/vul/before/0.json,"static int gtco_probe(struct usb_interface *usbinterface,
		      const struct usb_device_id *id)
{

	struct gtco             *gtco;
	struct input_dev        *input_dev;
	struct hid_descriptor   *hid_desc;
	char                    *report;
	int                     result = 0, retry;
	int			error;
	struct usb_endpoint_descriptor *endpoint;

	/* Allocate memory for device structure */
	gtco = kzalloc(sizeof(struct gtco), GFP_KERNEL);
	input_dev = input_allocate_device();
	if (!gtco || !input_dev) {
		dev_err(&usbinterface->dev, ""No more memory\n"");
		error = -ENOMEM;
		goto err_free_devs;
	}

	/* Set pointer to the input device */
	gtco->inputdevice = input_dev;

	/* Save interface information */
	gtco->usbdev = interface_to_usbdev(usbinterface);
	gtco->intf = usbinterface;

	/* Allocate some data for incoming reports */
	gtco->buffer = usb_alloc_coherent(gtco->usbdev, REPORT_MAX_SIZE,
					  GFP_KERNEL, &gtco->buf_dma);
	if (!gtco->buffer) {
		dev_err(&usbinterface->dev, ""No more memory for us buffers\n"");
		error = -ENOMEM;
		goto err_free_devs;
	}

	/* Allocate URB for reports */
	gtco->urbinfo = usb_alloc_urb(0, GFP_KERNEL);
	if (!gtco->urbinfo) {
		dev_err(&usbinterface->dev, ""Failed to allocate URB\n"");
		error = -ENOMEM;
		goto err_free_buf;
	}

	/* Sanity check that a device has an endpoint */
	if (usbinterface->altsetting[0].desc.bNumEndpoints < 1) {
		dev_err(&usbinterface->dev,
			""Invalid number of endpoints\n"");
		error = -EINVAL;
		goto err_free_urb;
	}

	/*
	 * The endpoint is always altsetting 0, we know this since we know
	 * this device only has one interrupt endpoint
	 */
	endpoint = &usbinterface->altsetting[0].endpoint[0].desc;

	/* Some debug */
	dev_dbg(&usbinterface->dev, ""gtco # interfaces: %d\n"", usbinterface->num_altsetting);
	dev_dbg(&usbinterface->dev, ""num endpoints:     %d\n"", usbinterface->cur_altsetting->desc.bNumEndpoints);
	dev_dbg(&usbinterface->dev, ""interface class:   %d\n"", usbinterface->cur_altsetting->desc.bInterfaceClass);
	dev_dbg(&usbinterface->dev, ""endpoint: attribute:0x%x type:0x%x\n"", endpoint->bmAttributes, endpoint->bDescriptorType);
	if (usb_endpoint_xfer_int(endpoint))
		dev_dbg(&usbinterface->dev, ""endpoint: we have interrupt endpoint\n"");

	dev_dbg(&usbinterface->dev, ""endpoint extra len:%d\n"", usbinterface->altsetting[0].extralen);

	/*
	 * Find the HID descriptor so we can find out the size of the
	 * HID report descriptor
	 */
	if (usb_get_extra_descriptor(usbinterface->cur_altsetting,
				     HID_DEVICE_TYPE, &hid_desc) != 0) {
		dev_err(&usbinterface->dev,
			""Can't retrieve exta USB descriptor to get hid report descriptor length\n"");
		error = -EIO;
		goto err_free_urb;
	}

	dev_dbg(&usbinterface->dev,
		""Extra descriptor success: type:%d  len:%d\n"",
		hid_desc->bDescriptorType,  hid_desc->wDescriptorLength);

	report = kzalloc(le16_to_cpu(hid_desc->wDescriptorLength), GFP_KERNEL);
	if (!report) {
		dev_err(&usbinterface->dev, ""No more memory for report\n"");
		error = -ENOMEM;
		goto err_free_urb;
	}

	/* Couple of tries to get reply */
	for (retry = 0; retry < 3; retry++) {
		result = usb_control_msg(gtco->usbdev,
					 usb_rcvctrlpipe(gtco->usbdev, 0),
					 USB_REQ_GET_DESCRIPTOR,
					 USB_RECIP_INTERFACE | USB_DIR_IN,
					 REPORT_DEVICE_TYPE << 8,
					 0, /* interface */
					 report,
					 le16_to_cpu(hid_desc->wDescriptorLength),
					 5000); /* 5 secs */

		dev_dbg(&usbinterface->dev, ""usb_control_msg result: %d\n"", result);
		if (result == le16_to_cpu(hid_desc->wDescriptorLength)) {
			parse_hid_report_descriptor(gtco, report, result);
			break;
		}
	}

	kfree(report);

	/* If we didn't get the report, fail */
	if (result != le16_to_cpu(hid_desc->wDescriptorLength)) {
		dev_err(&usbinterface->dev,
			""Failed to get HID Report Descriptor of size: %d\n"",
			hid_desc->wDescriptorLength);
		error = -EIO;
		goto err_free_urb;
	}

	/* Create a device file node */
	usb_make_path(gtco->usbdev, gtco->usbpath, sizeof(gtco->usbpath));
	strlcat(gtco->usbpath, ""/input0"", sizeof(gtco->usbpath));

	/* Set Input device functions */
	input_dev->open = gtco_input_open;
	input_dev->close = gtco_input_close;

	/* Set input device information */
	input_dev->name = ""GTCO_CalComp"";
	input_dev->phys = gtco->usbpath;

	input_set_drvdata(input_dev, gtco);

	/* Now set up all the input device capabilities */
	gtco_setup_caps(input_dev);

	/* Set input device required ID information */
	usb_to_input_id(gtco->usbdev, &input_dev->id);
	input_dev->dev.parent = &usbinterface->dev;

	/* Setup the URB, it will be posted later on open of input device */
	endpoint = &usbinterface->altsetting[0].endpoint[0].desc;

	usb_fill_int_urb(gtco->urbinfo,
			 gtco->usbdev,
			 usb_rcvintpipe(gtco->usbdev,
					endpoint->bEndpointAddress),
			 gtco->buffer,
			 REPORT_MAX_SIZE,
			 gtco_urb_callback,
			 gtco,
			 endpoint->bInterval);

	gtco->urbinfo->transfer_dma = gtco->buf_dma;
	gtco->urbinfo->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;

	/* Save gtco pointer in USB interface gtco */
	usb_set_intfdata(usbinterface, gtco);

	/* All done, now register the input device */
	error = input_register_device(input_dev);
	if (error)
		goto err_free_urb;

	return 0;

 err_free_urb:
	usb_free_urb(gtco->urbinfo);
 err_free_buf:
	usb_free_coherent(gtco->usbdev, REPORT_MAX_SIZE,
			  gtco->buffer, gtco->buf_dma);
 err_free_devs:
	input_free_device(input_dev);
	kfree(gtco);
	return error;
}","static int gtco_probe(struct usb_interface *VAR_0,
		      const struct usb_device_id *VAR_1)
{

	struct gtco             *gtco;
	struct input_dev        *input_dev;
	struct hid_descriptor   *VAR_2;
	char                    *VAR_3;
	int                     VAR_4 = 0, VAR_5;
	int			VAR_6;
	struct usb_endpoint_descriptor *VAR_7;

	/* COMMENT_0 */
	gtco = kzalloc(sizeof(struct gtco), VAR_8);
	input_dev = input_allocate_device();
	if (!gtco || !input_dev) {
		dev_err(&VAR_0->dev, ""No more memory\n"");
		VAR_6 = -VAR_9;
		goto err_free_devs;
	}

	/* COMMENT_1 */
	gtco->inputdevice = input_dev;

	/* COMMENT_2 */
	gtco->usbdev = interface_to_usbdev(VAR_0);
	gtco->intf = VAR_0;

	/* COMMENT_3 */
	gtco->buffer = usb_alloc_coherent(gtco->usbdev, VAR_10,
					  VAR_8, &gtco->buf_dma);
	if (!gtco->buffer) {
		dev_err(&VAR_0->dev, ""No more memory for us buffers\n"");
		VAR_6 = -VAR_9;
		goto err_free_devs;
	}

	/* COMMENT_4 */
	gtco->urbinfo = usb_alloc_urb(0, VAR_8);
	if (!gtco->urbinfo) {
		dev_err(&VAR_0->dev, ""Failed to allocate URB\n"");
		VAR_6 = -VAR_9;
		goto err_free_buf;
	}

	/* COMMENT_5 */
	if (VAR_0->altsetting[0].desc.bNumEndpoints < 1) {
		dev_err(&VAR_0->dev,
			""Invalid number of endpoints\n"");
		VAR_6 = -VAR_11;
		goto err_free_urb;
	}

	/* COMMENT_6 */
                                                                   
                                               
    
	VAR_7 = &VAR_0->altsetting[0].endpoint[0].desc;

	/* COMMENT_10 */
	dev_dbg(&VAR_0->dev, ""gtco # interfaces: %d\n"", VAR_0->num_altsetting);
	dev_dbg(&VAR_0->dev, ""num endpoints:     %d\n"", VAR_0->cur_altsetting->desc.bNumEndpoints);
	dev_dbg(&VAR_0->dev, ""interface class:   %d\n"", VAR_0->cur_altsetting->desc.bInterfaceClass);
	dev_dbg(&VAR_0->dev, ""endpoint: attribute:0x%x type:0x%x\n"", VAR_7->bmAttributes, VAR_7->bDescriptorType);
	if (usb_endpoint_xfer_int(VAR_7))
		dev_dbg(&VAR_0->dev, ""endpoint: we have interrupt endpoint\n"");

	dev_dbg(&VAR_0->dev, ""endpoint extra len:%d\n"", VAR_0->altsetting[0].extralen);

	/* COMMENT_11 */
                                                              
                         
    
	if (usb_get_extra_descriptor(VAR_0->cur_altsetting,
				     VAR_12, &VAR_2) != 0) {
		dev_err(&VAR_0->dev,
			""Can't retrieve exta USB descriptor to get hid report descriptor length\n"");
		VAR_6 = -VAR_13;
		goto err_free_urb;
	}

	dev_dbg(&VAR_0->dev,
		""Extra descriptor success: type:%d  len:%d\n"",
		VAR_2->bDescriptorType,  VAR_2->wDescriptorLength);

	VAR_3 = kzalloc(le16_to_cpu(VAR_2->wDescriptorLength), VAR_8);
	if (!VAR_3) {
		dev_err(&VAR_0->dev, ""No more memory for report\n"");
		VAR_6 = -VAR_9;
		goto err_free_urb;
	}

	/* COMMENT_15 */
	for (VAR_5 = 0; VAR_5 < 3; VAR_5++) {
		VAR_4 = usb_control_msg(gtco->usbdev,
					 usb_rcvctrlpipe(gtco->usbdev, 0),
					 VAR_14,
					 VAR_15 | VAR_16,
					 VAR_17 << 8,
					 0, /* COMMENT_16 */
					 VAR_3,
					 le16_to_cpu(VAR_2->wDescriptorLength),
					 5000); /* COMMENT_17 */

		dev_dbg(&VAR_0->dev, ""usb_control_msg result: %d\n"", VAR_4);
		if (VAR_4 == le16_to_cpu(VAR_2->wDescriptorLength)) {
			parse_hid_report_descriptor(gtco, VAR_3, VAR_4);
			break;
		}
	}

	kfree(VAR_3);

	/* COMMENT_18 */
	if (VAR_4 != le16_to_cpu(VAR_2->wDescriptorLength)) {
		dev_err(&VAR_0->dev,
			""Failed to get HID Report Descriptor of size: %d\n"",
			VAR_2->wDescriptorLength);
		VAR_6 = -VAR_13;
		goto err_free_urb;
	}

	/* COMMENT_19 */
	usb_make_path(gtco->usbdev, gtco->usbpath, sizeof(gtco->usbpath));
	strlcat(gtco->usbpath, ""/input0"", sizeof(gtco->usbpath));

	/* COMMENT_20 */
	input_dev->open = VAR_18;
	input_dev->close = VAR_19;

	/* COMMENT_21 */
	input_dev->name = ""GTCO_CalComp"";
	input_dev->phys = gtco->usbpath;

	input_set_drvdata(input_dev, gtco);

	/* COMMENT_22 */
	gtco_setup_caps(input_dev);

	/* COMMENT_23 */
	usb_to_input_id(gtco->usbdev, &input_dev->id);
	input_dev->dev.parent = &VAR_0->dev;

	/* COMMENT_24 */
	VAR_7 = &VAR_0->altsetting[0].endpoint[0].desc;

	usb_fill_int_urb(gtco->urbinfo,
			 gtco->usbdev,
			 usb_rcvintpipe(gtco->usbdev,
					VAR_7->bEndpointAddress),
			 gtco->buffer,
			 VAR_10,
			 VAR_20,
			 gtco,
			 VAR_7->bInterval);

	gtco->urbinfo->transfer_dma = gtco->buf_dma;
	gtco->urbinfo->transfer_flags |= VAR_21;

	/* COMMENT_25 */
	usb_set_intfdata(VAR_0, gtco);

	/* COMMENT_26 */
	VAR_6 = input_register_device(input_dev);
	if (VAR_6)
		goto err_free_urb;

	return 0;

 err_free_urb:
	usb_free_urb(gtco->urbinfo);
 err_free_buf:
	usb_free_coherent(gtco->usbdev, VAR_10,
			  gtco->buffer, gtco->buf_dma);
 err_free_devs:
	input_free_device(input_dev);
	kfree(gtco);
	return VAR_6;
}",torvalds/linux/162f98dea487206d9ab79fc12ed64700667a894d/gtco.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -43,6 +43,14 @@
 		goto err_free_buf;
 	}
 
+	/* Sanity check that a device has an endpoint */
+	if (usbinterface->altsetting[0].desc.bNumEndpoints < 1) {
+		dev_err(&usbinterface->dev,
+			""Invalid number of endpoints\n"");
+		error = -EINVAL;
+		goto err_free_urb;
+	}
+
 	/*
 	 * The endpoint is always altsetting 0, we know this since we know
 	 * this device only has one interrupt endpoint
@@ -64,7 +72,7 @@
 	 * HID report descriptor
 	 */
 	if (usb_get_extra_descriptor(usbinterface->cur_altsetting,
-				     HID_DEVICE_TYPE, &hid_desc) != 0){
+				     HID_DEVICE_TYPE, &hid_desc) != 0) {
 		dev_err(&usbinterface->dev,
 			""Can't retrieve exta USB descriptor to get hid report descriptor length\n"");
 		error = -EIO;","{'deleted_lines': ['\t\t\t\t     HID_DEVICE_TYPE, &hid_desc) != 0){'], 'added_lines': ['\t/* Sanity check that a device has an endpoint */', '\tif (usbinterface->altsetting[0].desc.bNumEndpoints < 1) {', '\t\tdev_err(&usbinterface->dev,', '\t\t\t""Invalid number of endpoints\\n"");', '\t\terror = -EINVAL;', '\t\tgoto err_free_urb;', '\t}', '', '\t\t\t\t     HID_DEVICE_TYPE, &hid_desc) != 0) {']}",True,The gtco_probe function in drivers/input/tablet/gtco.c in the Linux kernel through 4.5.2 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a crafted endpoints value in a USB device descriptor.,4.6,MEDIUM,1,test,2016-03-31T17:53:42Z,1
CVE-2016-4997,['CWE-264'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"netfilter: x_tables: check for bogus target offset

We're currently asserting that targetoff + targetsize <= nextoff.

Extend it to also check that targetoff is >= sizeof(xt_entry).
Since this is generic code, add an argument pointing to the start of the
match/target, we can then derive the base structure size from the delta.

We also need the e->elems pointer in a followup change to validate matches.

Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,https://github.com/torvalds/linux/commit/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,net/ipv4/netfilter/arp_tables.c,check_compat_entry_size_and_hooks,"static inline int
check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,
struct xt_table_info *newinfo,
unsigned int *size,
const unsigned char *base,
const unsigned char *limit,
const unsigned int *hook_entries,
const unsigned int *underflows,
const char *name)
{
struct xt_entry_target *t;
struct xt_target *target;
unsigned int entry_offset;
int ret, off, h;
duprintf(""check_compat_entry_size_and_hooks %p\n"", e);
if ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||
(unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit ||
(unsigned char *)e + e->next_offset > limit) {
duprintf(""Bad offset %p, limit = %p\n"", e, limit);
return -EINVAL;
}
if (e->next_offset < sizeof(struct compat_arpt_entry) +
sizeof(struct compat_xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
e, e->next_offset);
return -EINVAL;
}
if (!arp_checkentry(&e->arp))
return -EINVAL;
ret = xt_compat_check_entry_offsets(e, e->target_offset,
e->next_offset);
if (ret)
return ret;
off = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);
entry_offset = (void *)e - (void *)base;
t = compat_arpt_get_target(e);
target = xt_request_find_target(NFPROTO_ARP, t->u.user.name,
t->u.user.revision);
if (IS_ERR(target)) {
duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
t->u.user.name);
ret = PTR_ERR(target);
goto out;
}
t->u.kernel.target = target;
off += xt_compat_target_offset(target);
*size += off;
ret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);
if (ret)
goto release_target;
for (h = 0; h < NF_ARP_NUMHOOKS; h++) {
if ((unsigned char *)e - base == hook_entries[h])
newinfo->hook_entry[h] = hook_entries[h];
if ((unsigned char *)e - base == underflows[h])
newinfo->underflow[h] = underflows[h];
}
memset(&e->counters, 0, sizeof(e->counters));
e->comefrom = 0;
return 0;
release_target:
module_put(t->u.kernel.target->me);
out:
return ret;
}","static inline int
check_compat_entry_size_and_hooks(struct compat_arpt_entry *VAR_0,
struct xt_table_info *VAR_1,
unsigned int *VAR_2,
const unsigned char *VAR_3,
const unsigned char *VAR_4,
const unsigned int *VAR_5,
const unsigned int *VAR_6,
const char *VAR_7)
{
struct xt_entry_target *VAR_8;
struct xt_target *VAR_9;
unsigned int VAR_10;
int VAR_11, VAR_12, VAR_13;
duprintf(""check_compat_entry_size_and_hooks %p\n"", VAR_0);
if ((unsigned long)VAR_0 % __alignof__(struct compat_arpt_entry) != 0 ||
(unsigned char *)VAR_0 + sizeof(struct compat_arpt_entry) >= VAR_4 ||
(unsigned char *)VAR_0 + VAR_0->next_offset > VAR_4) {
duprintf(""Bad offset %p, limit = %p\n"", VAR_0, VAR_4);
return -VAR_14;
}
if (VAR_0->next_offset < sizeof(struct compat_arpt_entry) +
sizeof(struct compat_xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
VAR_0, VAR_0->next_offset);
return -VAR_14;
}
if (!arp_checkentry(&VAR_0->arp))
return -VAR_14;
VAR_11 = xt_compat_check_entry_offsets(VAR_0, VAR_0->target_offset,
VAR_0->next_offset);
if (VAR_11)
return VAR_11;
VAR_12 = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);
VAR_10 = (void *)VAR_0 - (void *)VAR_3;
VAR_8 = compat_arpt_get_target(VAR_0);
VAR_9 = xt_request_find_target(VAR_15, VAR_8->u.user.name,
VAR_8->u.user.revision);
if (IS_ERR(VAR_9)) {
duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
VAR_8->u.user.name);
VAR_11 = PTR_ERR(VAR_9);
goto out;
}
VAR_8->u.kernel.target = VAR_9;
VAR_12 += xt_compat_target_offset(VAR_9);
*VAR_2 += VAR_12;
VAR_11 = xt_compat_add_offset(VAR_15, VAR_10, VAR_12);
if (VAR_11)
goto release_target;
for (VAR_13 = 0; VAR_13 < VAR_16; VAR_13++) {
if ((unsigned char *)VAR_0 - VAR_3 == VAR_5[VAR_13])
VAR_1->hook_entry[VAR_13] = VAR_5[VAR_13];
if ((unsigned char *)VAR_0 - VAR_3 == VAR_6[VAR_13])
VAR_1->underflow[VAR_13] = VAR_6[VAR_13];
}
memset(&VAR_0->counters, 0, sizeof(VAR_0->counters));
VAR_0->comefrom = 0;
return 0;
release_target:
module_put(VAR_8->u.kernel.target->me);
out:
return VAR_11;
}",torvalds/linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/arp_tables.c/vul/before/1.json,"static inline int
check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,
				  struct xt_table_info *newinfo,
				  unsigned int *size,
				  const unsigned char *base,
				  const unsigned char *limit,
				  const unsigned int *hook_entries,
				  const unsigned int *underflows,
				  const char *name)
{
	struct xt_entry_target *t;
	struct xt_target *target;
	unsigned int entry_offset;
	int ret, off, h;

	duprintf(""check_compat_entry_size_and_hooks %p\n"", e);
	if ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||
	    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit ||
	    (unsigned char *)e + e->next_offset > limit) {
		duprintf(""Bad offset %p, limit = %p\n"", e, limit);
		return -EINVAL;
	}

	if (e->next_offset < sizeof(struct compat_arpt_entry) +
			     sizeof(struct compat_xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 e, e->next_offset);
		return -EINVAL;
	}

	if (!arp_checkentry(&e->arp))
		return -EINVAL;

	ret = xt_compat_check_entry_offsets(e, e->elems, e->target_offset,
					    e->next_offset);
	if (ret)
		return ret;

	off = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);
	entry_offset = (void *)e - (void *)base;

	t = compat_arpt_get_target(e);
	target = xt_request_find_target(NFPROTO_ARP, t->u.user.name,
					t->u.user.revision);
	if (IS_ERR(target)) {
		duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
			 t->u.user.name);
		ret = PTR_ERR(target);
		goto out;
	}
	t->u.kernel.target = target;

	off += xt_compat_target_offset(target);
	*size += off;
	ret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);
	if (ret)
		goto release_target;

	/* Check hooks & underflows */
	for (h = 0; h < NF_ARP_NUMHOOKS; h++) {
		if ((unsigned char *)e - base == hook_entries[h])
			newinfo->hook_entry[h] = hook_entries[h];
		if ((unsigned char *)e - base == underflows[h])
			newinfo->underflow[h] = underflows[h];
	}

	/* Clear counters and comefrom */
	memset(&e->counters, 0, sizeof(e->counters));
	e->comefrom = 0;
	return 0;

release_target:
	module_put(t->u.kernel.target->me);
out:
	return ret;
}","static inline int
check_compat_entry_size_and_hooks(struct compat_arpt_entry *VAR_0,
				  struct xt_table_info *VAR_1,
				  unsigned int *VAR_2,
				  const unsigned char *VAR_3,
				  const unsigned char *VAR_4,
				  const unsigned int *VAR_5,
				  const unsigned int *VAR_6,
				  const char *VAR_7)
{
	struct xt_entry_target *VAR_8;
	struct xt_target *VAR_9;
	unsigned int VAR_10;
	int VAR_11, VAR_12, VAR_13;

	duprintf(""check_compat_entry_size_and_hooks %p\n"", VAR_0);
	if ((unsigned long)VAR_0 % __alignof__(struct compat_arpt_entry) != 0 ||
	    (unsigned char *)VAR_0 + sizeof(struct compat_arpt_entry) >= VAR_4 ||
	    (unsigned char *)VAR_0 + VAR_0->next_offset > VAR_4) {
		duprintf(""Bad offset %p, limit = %p\n"", VAR_0, VAR_4);
		return -VAR_14;
	}

	if (VAR_0->next_offset < sizeof(struct compat_arpt_entry) +
			     sizeof(struct compat_xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 VAR_0, VAR_0->next_offset);
		return -VAR_14;
	}

	if (!arp_checkentry(&VAR_0->arp))
		return -VAR_14;

	VAR_11 = xt_compat_check_entry_offsets(VAR_0, VAR_0->elems, VAR_0->target_offset,
					    VAR_0->next_offset);
	if (VAR_11)
		return VAR_11;

	VAR_12 = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);
	VAR_10 = (void *)VAR_0 - (void *)VAR_3;

	VAR_8 = compat_arpt_get_target(VAR_0);
	VAR_9 = xt_request_find_target(VAR_15, VAR_8->u.user.name,
					VAR_8->u.user.revision);
	if (IS_ERR(VAR_9)) {
		duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
			 VAR_8->u.user.name);
		VAR_11 = PTR_ERR(VAR_9);
		goto out;
	}
	VAR_8->u.kernel.target = VAR_9;

	VAR_12 += xt_compat_target_offset(VAR_9);
	*VAR_2 += VAR_12;
	VAR_11 = xt_compat_add_offset(VAR_15, VAR_10, VAR_12);
	if (VAR_11)
		goto release_target;

	/* COMMENT_0 */
	for (VAR_13 = 0; VAR_13 < VAR_16; VAR_13++) {
		if ((unsigned char *)VAR_0 - VAR_3 == VAR_5[VAR_13])
			VAR_1->hook_entry[VAR_13] = VAR_5[VAR_13];
		if ((unsigned char *)VAR_0 - VAR_3 == VAR_6[VAR_13])
			VAR_1->underflow[VAR_13] = VAR_6[VAR_13];
	}

	/* COMMENT_1 */
	memset(&VAR_0->counters, 0, sizeof(VAR_0->counters));
	VAR_0->comefrom = 0;
	return 0;

release_target:
	module_put(VAR_8->u.kernel.target->me);
out:
	return VAR_11;
}",torvalds/linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/arp_tables.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -31,7 +31,7 @@
 	if (!arp_checkentry(&e->arp))
 		return -EINVAL;
 
-	ret = xt_compat_check_entry_offsets(e, e->target_offset,
+	ret = xt_compat_check_entry_offsets(e, e->elems, e->target_offset,
 					    e->next_offset);
 	if (ret)
 		return ret;","{'deleted_lines': ['\tret = xt_compat_check_entry_offsets(e, e->target_offset,'], 'added_lines': ['\tret = xt_compat_check_entry_offsets(e, e->elems, e->target_offset,']}",True,The compat IPT_SO_SET_REPLACE and IP6T_SO_SET_REPLACE setsockopt implementations in the netfilter subsystem in the Linux kernel before 4.6.3 allow local users to gain privileges or cause a denial of service (memory corruption) by leveraging in-container root access to provide a crafted offset value that triggers an unintended decrement.,7.8,HIGH,2,test,2016-04-01T12:17:28Z,1
CVE-2016-4997,['CWE-264'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"netfilter: x_tables: check for bogus target offset

We're currently asserting that targetoff + targetsize <= nextoff.

Extend it to also check that targetoff is >= sizeof(xt_entry).
Since this is generic code, add an argument pointing to the start of the
match/target, we can then derive the base structure size from the delta.

We also need the e->elems pointer in a followup change to validate matches.

Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,https://github.com/torvalds/linux/commit/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,net/ipv6/netfilter/ip6_tables.c,check_compat_entry_size_and_hooks,"static int
check_compat_entry_size_and_hooks(struct compat_ip6t_entry *e,
struct xt_table_info *newinfo,
unsigned int *size,
const unsigned char *base,
const unsigned char *limit,
const unsigned int *hook_entries,
const unsigned int *underflows,
const char *name)
{
struct xt_entry_match *ematch;
struct xt_entry_target *t;
struct xt_target *target;
unsigned int entry_offset;
unsigned int j;
int ret, off, h;
duprintf(""check_compat_entry_size_and_hooks %p\n"", e);
if ((unsigned long)e % __alignof__(struct compat_ip6t_entry) != 0 ||
(unsigned char *)e + sizeof(struct compat_ip6t_entry) >= limit ||
(unsigned char *)e + e->next_offset > limit) {
duprintf(""Bad offset %p, limit = %p\n"", e, limit);
return -EINVAL;
}
if (e->next_offset < sizeof(struct compat_ip6t_entry) +
sizeof(struct compat_xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
e, e->next_offset);
return -EINVAL;
}
if (!ip6_checkentry(&e->ipv6))
return -EINVAL;
ret = xt_compat_check_entry_offsets(e,
e->target_offset, e->next_offset);
if (ret)
return ret;
off = sizeof(struct ip6t_entry) - sizeof(struct compat_ip6t_entry);
entry_offset = (void *)e - (void *)base;
j = 0;
xt_ematch_foreach(ematch, e) {
ret = compat_find_calc_match(ematch, name, &e->ipv6, &off);
if (ret != 0)
goto release_matches;
++j;
}
t = compat_ip6t_get_target(e);
target = xt_request_find_target(NFPROTO_IPV6, t->u.user.name,
t->u.user.revision);
if (IS_ERR(target)) {
duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
t->u.user.name);
ret = PTR_ERR(target);
goto release_matches;
}
t->u.kernel.target = target;
off += xt_compat_target_offset(target);
*size += off;
ret = xt_compat_add_offset(AF_INET6, entry_offset, off);
if (ret)
goto out;
for (h = 0; h < NF_INET_NUMHOOKS; h++) {
if ((unsigned char *)e - base == hook_entries[h])
newinfo->hook_entry[h] = hook_entries[h];
if ((unsigned char *)e - base == underflows[h])
newinfo->underflow[h] = underflows[h];
}
memset(&e->counters, 0, sizeof(e->counters));
e->comefrom = 0;
return 0;
out:
module_put(t->u.kernel.target->me);
release_matches:
xt_ematch_foreach(ematch, e) {
if (j-- == 0)
break;
module_put(ematch->u.kernel.match->me);
}
return ret;
}","static int
check_compat_entry_size_and_hooks(struct compat_ip6t_entry *VAR_0,
struct xt_table_info *VAR_1,
unsigned int *VAR_2,
const unsigned char *VAR_3,
const unsigned char *VAR_4,
const unsigned int *VAR_5,
const unsigned int *VAR_6,
const char *VAR_7)
{
struct xt_entry_match *VAR_8;
struct xt_entry_target *VAR_9;
struct xt_target *VAR_10;
unsigned int VAR_11;
unsigned int VAR_12;
int VAR_13, VAR_14, VAR_15;
duprintf(""check_compat_entry_size_and_hooks %p\n"", VAR_0);
if ((unsigned long)VAR_0 % __alignof__(struct compat_ip6t_entry) != 0 ||
(unsigned char *)VAR_0 + sizeof(struct compat_ip6t_entry) >= VAR_4 ||
(unsigned char *)VAR_0 + VAR_0->next_offset > VAR_4) {
duprintf(""Bad offset %p, limit = %p\n"", VAR_0, VAR_4);
return -VAR_16;
}
if (VAR_0->next_offset < sizeof(struct compat_ip6t_entry) +
sizeof(struct compat_xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
VAR_0, VAR_0->next_offset);
return -VAR_16;
}
if (!ip6_checkentry(&VAR_0->ipv6))
return -VAR_16;
VAR_13 = xt_compat_check_entry_offsets(VAR_0,
VAR_0->target_offset, VAR_0->next_offset);
if (VAR_13)
return VAR_13;
VAR_14 = sizeof(struct ip6t_entry) - sizeof(struct compat_ip6t_entry);
VAR_11 = (void *)VAR_0 - (void *)VAR_3;
VAR_12 = 0;
xt_ematch_foreach(VAR_8, VAR_0) {
VAR_13 = compat_find_calc_match(VAR_8, VAR_7, &VAR_0->ipv6, &VAR_14);
if (VAR_13 != 0)
goto release_matches;
++VAR_12;
}
VAR_9 = compat_ip6t_get_target(VAR_0);
VAR_10 = xt_request_find_target(VAR_17, VAR_9->u.user.name,
VAR_9->u.user.revision);
if (IS_ERR(VAR_10)) {
duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
VAR_9->u.user.name);
VAR_13 = PTR_ERR(VAR_10);
goto release_matches;
}
VAR_9->u.kernel.target = VAR_10;
VAR_14 += xt_compat_target_offset(VAR_10);
*VAR_2 += VAR_14;
VAR_13 = xt_compat_add_offset(VAR_18, VAR_11, VAR_14);
if (VAR_13)
goto out;
for (VAR_15 = 0; VAR_15 < VAR_19; VAR_15++) {
if ((unsigned char *)VAR_0 - VAR_3 == VAR_5[VAR_15])
VAR_1->hook_entry[VAR_15] = VAR_5[VAR_15];
if ((unsigned char *)VAR_0 - VAR_3 == VAR_6[VAR_15])
VAR_1->underflow[VAR_15] = VAR_6[VAR_15];
}
memset(&VAR_0->counters, 0, sizeof(VAR_0->counters));
VAR_0->comefrom = 0;
return 0;
out:
module_put(VAR_9->u.kernel.target->me);
release_matches:
xt_ematch_foreach(VAR_8, VAR_0) {
if (VAR_12-- == 0)
break;
module_put(VAR_8->u.kernel.match->me);
}
return VAR_13;
}",torvalds/linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/ip6_tables.c/vul/before/1.json,"static int
check_compat_entry_size_and_hooks(struct compat_ip6t_entry *e,
				  struct xt_table_info *newinfo,
				  unsigned int *size,
				  const unsigned char *base,
				  const unsigned char *limit,
				  const unsigned int *hook_entries,
				  const unsigned int *underflows,
				  const char *name)
{
	struct xt_entry_match *ematch;
	struct xt_entry_target *t;
	struct xt_target *target;
	unsigned int entry_offset;
	unsigned int j;
	int ret, off, h;

	duprintf(""check_compat_entry_size_and_hooks %p\n"", e);
	if ((unsigned long)e % __alignof__(struct compat_ip6t_entry) != 0 ||
	    (unsigned char *)e + sizeof(struct compat_ip6t_entry) >= limit ||
	    (unsigned char *)e + e->next_offset > limit) {
		duprintf(""Bad offset %p, limit = %p\n"", e, limit);
		return -EINVAL;
	}

	if (e->next_offset < sizeof(struct compat_ip6t_entry) +
			     sizeof(struct compat_xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 e, e->next_offset);
		return -EINVAL;
	}

	if (!ip6_checkentry(&e->ipv6))
		return -EINVAL;

	ret = xt_compat_check_entry_offsets(e, e->elems,
					    e->target_offset, e->next_offset);
	if (ret)
		return ret;

	off = sizeof(struct ip6t_entry) - sizeof(struct compat_ip6t_entry);
	entry_offset = (void *)e - (void *)base;
	j = 0;
	xt_ematch_foreach(ematch, e) {
		ret = compat_find_calc_match(ematch, name, &e->ipv6, &off);
		if (ret != 0)
			goto release_matches;
		++j;
	}

	t = compat_ip6t_get_target(e);
	target = xt_request_find_target(NFPROTO_IPV6, t->u.user.name,
					t->u.user.revision);
	if (IS_ERR(target)) {
		duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
			 t->u.user.name);
		ret = PTR_ERR(target);
		goto release_matches;
	}
	t->u.kernel.target = target;

	off += xt_compat_target_offset(target);
	*size += off;
	ret = xt_compat_add_offset(AF_INET6, entry_offset, off);
	if (ret)
		goto out;

	/* Check hooks & underflows */
	for (h = 0; h < NF_INET_NUMHOOKS; h++) {
		if ((unsigned char *)e - base == hook_entries[h])
			newinfo->hook_entry[h] = hook_entries[h];
		if ((unsigned char *)e - base == underflows[h])
			newinfo->underflow[h] = underflows[h];
	}

	/* Clear counters and comefrom */
	memset(&e->counters, 0, sizeof(e->counters));
	e->comefrom = 0;
	return 0;

out:
	module_put(t->u.kernel.target->me);
release_matches:
	xt_ematch_foreach(ematch, e) {
		if (j-- == 0)
			break;
		module_put(ematch->u.kernel.match->me);
	}
	return ret;
}","static int
check_compat_entry_size_and_hooks(struct compat_ip6t_entry *VAR_0,
				  struct xt_table_info *VAR_1,
				  unsigned int *VAR_2,
				  const unsigned char *VAR_3,
				  const unsigned char *VAR_4,
				  const unsigned int *VAR_5,
				  const unsigned int *VAR_6,
				  const char *VAR_7)
{
	struct xt_entry_match *VAR_8;
	struct xt_entry_target *VAR_9;
	struct xt_target *VAR_10;
	unsigned int VAR_11;
	unsigned int VAR_12;
	int VAR_13, VAR_14, VAR_15;

	duprintf(""check_compat_entry_size_and_hooks %p\n"", VAR_0);
	if ((unsigned long)VAR_0 % __alignof__(struct compat_ip6t_entry) != 0 ||
	    (unsigned char *)VAR_0 + sizeof(struct compat_ip6t_entry) >= VAR_4 ||
	    (unsigned char *)VAR_0 + VAR_0->next_offset > VAR_4) {
		duprintf(""Bad offset %p, limit = %p\n"", VAR_0, VAR_4);
		return -VAR_16;
	}

	if (VAR_0->next_offset < sizeof(struct compat_ip6t_entry) +
			     sizeof(struct compat_xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 VAR_0, VAR_0->next_offset);
		return -VAR_16;
	}

	if (!ip6_checkentry(&VAR_0->ipv6))
		return -VAR_16;

	VAR_13 = xt_compat_check_entry_offsets(VAR_0, VAR_0->elems,
					    VAR_0->target_offset, VAR_0->next_offset);
	if (VAR_13)
		return VAR_13;

	VAR_14 = sizeof(struct ip6t_entry) - sizeof(struct compat_ip6t_entry);
	VAR_11 = (void *)VAR_0 - (void *)VAR_3;
	VAR_12 = 0;
	xt_ematch_foreach(VAR_8, VAR_0) {
		VAR_13 = compat_find_calc_match(VAR_8, VAR_7, &VAR_0->ipv6, &VAR_14);
		if (VAR_13 != 0)
			goto release_matches;
		++VAR_12;
	}

	VAR_9 = compat_ip6t_get_target(VAR_0);
	VAR_10 = xt_request_find_target(VAR_17, VAR_9->u.user.name,
					VAR_9->u.user.revision);
	if (IS_ERR(VAR_10)) {
		duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
			 VAR_9->u.user.name);
		VAR_13 = PTR_ERR(VAR_10);
		goto release_matches;
	}
	VAR_9->u.kernel.target = VAR_10;

	VAR_14 += xt_compat_target_offset(VAR_10);
	*VAR_2 += VAR_14;
	VAR_13 = xt_compat_add_offset(VAR_18, VAR_11, VAR_14);
	if (VAR_13)
		goto out;

	/* COMMENT_0 */
	for (VAR_15 = 0; VAR_15 < VAR_19; VAR_15++) {
		if ((unsigned char *)VAR_0 - VAR_3 == VAR_5[VAR_15])
			VAR_1->hook_entry[VAR_15] = VAR_5[VAR_15];
		if ((unsigned char *)VAR_0 - VAR_3 == VAR_6[VAR_15])
			VAR_1->underflow[VAR_15] = VAR_6[VAR_15];
	}

	/* COMMENT_1 */
	memset(&VAR_0->counters, 0, sizeof(VAR_0->counters));
	VAR_0->comefrom = 0;
	return 0;

out:
	module_put(VAR_9->u.kernel.target->me);
release_matches:
	xt_ematch_foreach(VAR_8, VAR_0) {
		if (VAR_12-- == 0)
			break;
		module_put(VAR_8->u.kernel.match->me);
	}
	return VAR_13;
}",torvalds/linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/ip6_tables.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -33,7 +33,7 @@
 	if (!ip6_checkentry(&e->ipv6))
 		return -EINVAL;
 
-	ret = xt_compat_check_entry_offsets(e,
+	ret = xt_compat_check_entry_offsets(e, e->elems,
 					    e->target_offset, e->next_offset);
 	if (ret)
 		return ret;","{'deleted_lines': ['\tret = xt_compat_check_entry_offsets(e,'], 'added_lines': ['\tret = xt_compat_check_entry_offsets(e, e->elems,']}",True,The compat IPT_SO_SET_REPLACE and IP6T_SO_SET_REPLACE setsockopt implementations in the netfilter subsystem in the Linux kernel before 4.6.3 allow local users to gain privileges or cause a denial of service (memory corruption) by leveraging in-container root access to provide a crafted offset value that triggers an unintended decrement.,7.8,HIGH,2,test,2016-04-01T12:17:28Z,1
CVE-2016-4997,['CWE-264'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"netfilter: x_tables: check for bogus target offset

We're currently asserting that targetoff + targetsize <= nextoff.

Extend it to also check that targetoff is >= sizeof(xt_entry).
Since this is generic code, add an argument pointing to the start of the
match/target, we can then derive the base structure size from the delta.

We also need the e->elems pointer in a followup change to validate matches.

Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,https://github.com/torvalds/linux/commit/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,net/ipv6/netfilter/ip6_tables.c,check_entry_size_and_hooks,"static int
check_entry_size_and_hooks(struct ip6t_entry *e,
struct xt_table_info *newinfo,
const unsigned char *base,
const unsigned char *limit,
const unsigned int *hook_entries,
const unsigned int *underflows,
unsigned int valid_hooks)
{
unsigned int h;
int err;
if ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||
(unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||
(unsigned char *)e + e->next_offset > limit) {
duprintf(""Bad offset %p\n"", e);
return -EINVAL;
}
if (e->next_offset
< sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
e, e->next_offset);
return -EINVAL;
}
if (!ip6_checkentry(&e->ipv6))
return -EINVAL;
err = xt_check_entry_offsets(e, e->target_offset, e->next_offset);
if (err)
return err;
for (h = 0; h < NF_INET_NUMHOOKS; h++) {
if (!(valid_hooks & (1 << h)))
continue;
if ((unsigned char *)e - base == hook_entries[h])
newinfo->hook_entry[h] = hook_entries[h];
if ((unsigned char *)e - base == underflows[h]) {
if (!check_underflow(e)) {
pr_debug(""Underflows must be unconditional and ""
""use the STANDARD target with ""
""ACCEPT/DROP\n"");
return -EINVAL;
}
newinfo->underflow[h] = underflows[h];
}
}
e->counters = ((struct xt_counters) { 0, 0 });
e->comefrom = 0;
return 0;
}","static int
check_entry_size_and_hooks(struct ip6t_entry *VAR_0,
struct xt_table_info *VAR_1,
const unsigned char *VAR_2,
const unsigned char *VAR_3,
const unsigned int *VAR_4,
const unsigned int *VAR_5,
unsigned int VAR_6)
{
unsigned int VAR_7;
int VAR_8;
if ((unsigned long)VAR_0 % __alignof__(struct ip6t_entry) != 0 ||
(unsigned char *)VAR_0 + sizeof(struct ip6t_entry) >= VAR_3 ||
(unsigned char *)VAR_0 + VAR_0->next_offset > VAR_3) {
duprintf(""Bad offset %p\n"", VAR_0);
return -VAR_9;
}
if (VAR_0->next_offset
< sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
VAR_0, VAR_0->next_offset);
return -VAR_9;
}
if (!ip6_checkentry(&VAR_0->ipv6))
return -VAR_9;
VAR_8 = xt_check_entry_offsets(VAR_0, VAR_0->target_offset, VAR_0->next_offset);
if (VAR_8)
return VAR_8;
for (VAR_7 = 0; VAR_7 < VAR_10; VAR_7++) {
if (!(VAR_6 & (1 << VAR_7)))
continue;
if ((unsigned char *)VAR_0 - VAR_2 == VAR_4[VAR_7])
VAR_1->hook_entry[VAR_7] = VAR_4[VAR_7];
if ((unsigned char *)VAR_0 - VAR_2 == VAR_5[VAR_7]) {
if (!check_underflow(VAR_0)) {
pr_debug(""Underflows must be unconditional and ""
""use the STANDARD target with ""
""ACCEPT/DROP\n"");
return -VAR_9;
}
VAR_1->underflow[VAR_7] = VAR_5[VAR_7];
}
}
VAR_0->counters = ((struct xt_counters) { 0, 0 });
VAR_0->comefrom = 0;
return 0;
}",torvalds/linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/ip6_tables.c/vul/before/0.json,"static int
check_entry_size_and_hooks(struct ip6t_entry *e,
			   struct xt_table_info *newinfo,
			   const unsigned char *base,
			   const unsigned char *limit,
			   const unsigned int *hook_entries,
			   const unsigned int *underflows,
			   unsigned int valid_hooks)
{
	unsigned int h;
	int err;

	if ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||
	    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||
	    (unsigned char *)e + e->next_offset > limit) {
		duprintf(""Bad offset %p\n"", e);
		return -EINVAL;
	}

	if (e->next_offset
	    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 e, e->next_offset);
		return -EINVAL;
	}

	if (!ip6_checkentry(&e->ipv6))
		return -EINVAL;

	err = xt_check_entry_offsets(e, e->elems, e->target_offset,
				     e->next_offset);
	if (err)
		return err;

	/* Check hooks & underflows */
	for (h = 0; h < NF_INET_NUMHOOKS; h++) {
		if (!(valid_hooks & (1 << h)))
			continue;
		if ((unsigned char *)e - base == hook_entries[h])
			newinfo->hook_entry[h] = hook_entries[h];
		if ((unsigned char *)e - base == underflows[h]) {
			if (!check_underflow(e)) {
				pr_debug(""Underflows must be unconditional and ""
					 ""use the STANDARD target with ""
					 ""ACCEPT/DROP\n"");
				return -EINVAL;
			}
			newinfo->underflow[h] = underflows[h];
		}
	}

	/* Clear counters and comefrom */
	e->counters = ((struct xt_counters) { 0, 0 });
	e->comefrom = 0;
	return 0;
}","static int
check_entry_size_and_hooks(struct ip6t_entry *VAR_0,
			   struct xt_table_info *VAR_1,
			   const unsigned char *VAR_2,
			   const unsigned char *VAR_3,
			   const unsigned int *VAR_4,
			   const unsigned int *VAR_5,
			   unsigned int VAR_6)
{
	unsigned int VAR_7;
	int VAR_8;

	if ((unsigned long)VAR_0 % __alignof__(struct ip6t_entry) != 0 ||
	    (unsigned char *)VAR_0 + sizeof(struct ip6t_entry) >= VAR_3 ||
	    (unsigned char *)VAR_0 + VAR_0->next_offset > VAR_3) {
		duprintf(""Bad offset %p\n"", VAR_0);
		return -VAR_9;
	}

	if (VAR_0->next_offset
	    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 VAR_0, VAR_0->next_offset);
		return -VAR_9;
	}

	if (!ip6_checkentry(&VAR_0->ipv6))
		return -VAR_9;

	VAR_8 = xt_check_entry_offsets(VAR_0, VAR_0->elems, VAR_0->target_offset,
				     VAR_0->next_offset);
	if (VAR_8)
		return VAR_8;

	/* COMMENT_0 */
	for (VAR_7 = 0; VAR_7 < VAR_10; VAR_7++) {
		if (!(VAR_6 & (1 << VAR_7)))
			continue;
		if ((unsigned char *)VAR_0 - VAR_2 == VAR_4[VAR_7])
			VAR_1->hook_entry[VAR_7] = VAR_4[VAR_7];
		if ((unsigned char *)VAR_0 - VAR_2 == VAR_5[VAR_7]) {
			if (!check_underflow(VAR_0)) {
				pr_debug(""Underflows must be unconditional and ""
					 ""use the STANDARD target with ""
					 ""ACCEPT/DROP\n"");
				return -VAR_9;
			}
			VAR_1->underflow[VAR_7] = VAR_5[VAR_7];
		}
	}

	/* COMMENT_1 */
	VAR_0->counters = ((struct xt_counters) { 0, 0 });
	VAR_0->comefrom = 0;
	return 0;
}",torvalds/linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/ip6_tables.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -27,7 +27,8 @@
 	if (!ip6_checkentry(&e->ipv6))
 		return -EINVAL;
 
-	err = xt_check_entry_offsets(e, e->target_offset, e->next_offset);
+	err = xt_check_entry_offsets(e, e->elems, e->target_offset,
+				     e->next_offset);
 	if (err)
 		return err;
 ","{'deleted_lines': ['\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);'], 'added_lines': ['\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,', '\t\t\t\t     e->next_offset);']}",True,The compat IPT_SO_SET_REPLACE and IP6T_SO_SET_REPLACE setsockopt implementations in the netfilter subsystem in the Linux kernel before 4.6.3 allow local users to gain privileges or cause a denial of service (memory corruption) by leveraging in-container root access to provide a crafted offset value that triggers an unintended decrement.,7.8,HIGH,2,test,2016-04-01T12:17:28Z,1
CVE-2016-4997,['CWE-264'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"netfilter: x_tables: check for bogus target offset

We're currently asserting that targetoff + targetsize <= nextoff.

Extend it to also check that targetoff is >= sizeof(xt_entry).
Since this is generic code, add an argument pointing to the start of the
match/target, we can then derive the base structure size from the delta.

We also need the e->elems pointer in a followup change to validate matches.

Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,https://github.com/torvalds/linux/commit/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,net/netfilter/x_tables.c,xt_check_entry_offsets,"int xt_check_entry_offsets(const void *base,
unsigned int target_offset,
unsigned int next_offset)
{
const struct xt_entry_target *t;
const char *e = base;
if (target_offset + sizeof(*t) > next_offset)
return -EINVAL;
t = (void *)(e + target_offset);
if (t->u.target_size < sizeof(*t))
return -EINVAL;
if (target_offset + t->u.target_size > next_offset)
return -EINVAL;
if (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&
target_offset + sizeof(struct xt_standard_target) != next_offset)
return -EINVAL;
return 0;
}","int xt_check_entry_offsets(const void *VAR_0,
unsigned int VAR_1,
unsigned int VAR_2)
{
const struct xt_entry_target *VAR_3;
const char *VAR_4 = VAR_0;
if (VAR_1 + sizeof(*VAR_3) > VAR_2)
return -VAR_5;
VAR_3 = (void *)(VAR_4 + VAR_1);
if (VAR_3->u.target_size < sizeof(*VAR_3))
return -VAR_5;
if (VAR_1 + VAR_3->u.target_size > VAR_2)
return -VAR_5;
if (strcmp(VAR_3->u.user.name, VAR_6) == 0 &&
VAR_1 + sizeof(struct xt_standard_target) != VAR_2)
return -VAR_5;
return 0;
}",torvalds/linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/x_tables.c/vul/before/1.json,"int xt_check_entry_offsets(const void *base,
			   const char *elems,
			   unsigned int target_offset,
			   unsigned int next_offset)
{
	long size_of_base_struct = elems - (const char *)base;
	const struct xt_entry_target *t;
	const char *e = base;

	/* target start is within the ip/ip6/arpt_entry struct */
	if (target_offset < size_of_base_struct)
		return -EINVAL;

	if (target_offset + sizeof(*t) > next_offset)
		return -EINVAL;

	t = (void *)(e + target_offset);
	if (t->u.target_size < sizeof(*t))
		return -EINVAL;

	if (target_offset + t->u.target_size > next_offset)
		return -EINVAL;

	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&
	    target_offset + sizeof(struct xt_standard_target) != next_offset)
		return -EINVAL;

	return 0;
}","int xt_check_entry_offsets(const void *VAR_0,
			   const char *VAR_1,
			   unsigned int VAR_2,
			   unsigned int VAR_3)
{
	long VAR_4 = VAR_1 - (const char *)VAR_0;
	const struct xt_entry_target *VAR_5;
	const char *VAR_6 = VAR_0;

	/* COMMENT_0 */
	if (VAR_2 < VAR_4)
		return -VAR_7;

	if (VAR_2 + sizeof(*VAR_5) > VAR_3)
		return -VAR_7;

	VAR_5 = (void *)(VAR_6 + VAR_2);
	if (VAR_5->u.target_size < sizeof(*VAR_5))
		return -VAR_7;

	if (VAR_2 + VAR_5->u.target_size > VAR_3)
		return -VAR_7;

	if (strcmp(VAR_5->u.user.name, VAR_8) == 0 &&
	    VAR_2 + sizeof(struct xt_standard_target) != VAR_3)
		return -VAR_7;

	return 0;
}",torvalds/linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/x_tables.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,9 +1,15 @@
 int xt_check_entry_offsets(const void *base,
+			   const char *elems,
 			   unsigned int target_offset,
 			   unsigned int next_offset)
 {
+	long size_of_base_struct = elems - (const char *)base;
 	const struct xt_entry_target *t;
 	const char *e = base;
+
+	/* target start is within the ip/ip6/arpt_entry struct */
+	if (target_offset < size_of_base_struct)
+		return -EINVAL;
 
 	if (target_offset + sizeof(*t) > next_offset)
 		return -EINVAL;","{'deleted_lines': [], 'added_lines': ['\t\t\t   const char *elems,', '\tlong size_of_base_struct = elems - (const char *)base;', '', '\t/* target start is within the ip/ip6/arpt_entry struct */', '\tif (target_offset < size_of_base_struct)', '\t\treturn -EINVAL;']}",True,The compat IPT_SO_SET_REPLACE and IP6T_SO_SET_REPLACE setsockopt implementations in the netfilter subsystem in the Linux kernel before 4.6.3 allow local users to gain privileges or cause a denial of service (memory corruption) by leveraging in-container root access to provide a crafted offset value that triggers an unintended decrement.,7.8,HIGH,2,test,2016-04-01T12:17:28Z,1
CVE-2016-4997,['CWE-264'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"netfilter: x_tables: check for bogus target offset

We're currently asserting that targetoff + targetsize <= nextoff.

Extend it to also check that targetoff is >= sizeof(xt_entry).
Since this is generic code, add an argument pointing to the start of the
match/target, we can then derive the base structure size from the delta.

We also need the e->elems pointer in a followup change to validate matches.

Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,https://github.com/torvalds/linux/commit/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,net/ipv4/netfilter/ip_tables.c,check_entry_size_and_hooks,"static int
check_entry_size_and_hooks(struct ipt_entry *e,
struct xt_table_info *newinfo,
const unsigned char *base,
const unsigned char *limit,
const unsigned int *hook_entries,
const unsigned int *underflows,
unsigned int valid_hooks)
{
unsigned int h;
int err;
if ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||
(unsigned char *)e + sizeof(struct ipt_entry) >= limit ||
(unsigned char *)e + e->next_offset > limit) {
duprintf(""Bad offset %p\n"", e);
return -EINVAL;
}
if (e->next_offset
< sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
e, e->next_offset);
return -EINVAL;
}
if (!ip_checkentry(&e->ip))
return -EINVAL;
err = xt_check_entry_offsets(e, e->target_offset, e->next_offset);
if (err)
return err;
for (h = 0; h < NF_INET_NUMHOOKS; h++) {
if (!(valid_hooks & (1 << h)))
continue;
if ((unsigned char *)e - base == hook_entries[h])
newinfo->hook_entry[h] = hook_entries[h];
if ((unsigned char *)e - base == underflows[h]) {
if (!check_underflow(e)) {
pr_debug(""Underflows must be unconditional and ""
""use the STANDARD target with ""
""ACCEPT/DROP\n"");
return -EINVAL;
}
newinfo->underflow[h] = underflows[h];
}
}
e->counters = ((struct xt_counters) { 0, 0 });
e->comefrom = 0;
return 0;
}","static int
check_entry_size_and_hooks(struct ipt_entry *VAR_0,
struct xt_table_info *VAR_1,
const unsigned char *VAR_2,
const unsigned char *VAR_3,
const unsigned int *VAR_4,
const unsigned int *VAR_5,
unsigned int VAR_6)
{
unsigned int VAR_7;
int VAR_8;
if ((unsigned long)VAR_0 % __alignof__(struct ipt_entry) != 0 ||
(unsigned char *)VAR_0 + sizeof(struct ipt_entry) >= VAR_3 ||
(unsigned char *)VAR_0 + VAR_0->next_offset > VAR_3) {
duprintf(""Bad offset %p\n"", VAR_0);
return -VAR_9;
}
if (VAR_0->next_offset
< sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
VAR_0, VAR_0->next_offset);
return -VAR_9;
}
if (!ip_checkentry(&VAR_0->ip))
return -VAR_9;
VAR_8 = xt_check_entry_offsets(VAR_0, VAR_0->target_offset, VAR_0->next_offset);
if (VAR_8)
return VAR_8;
for (VAR_7 = 0; VAR_7 < VAR_10; VAR_7++) {
if (!(VAR_6 & (1 << VAR_7)))
continue;
if ((unsigned char *)VAR_0 - VAR_2 == VAR_4[VAR_7])
VAR_1->hook_entry[VAR_7] = VAR_4[VAR_7];
if ((unsigned char *)VAR_0 - VAR_2 == VAR_5[VAR_7]) {
if (!check_underflow(VAR_0)) {
pr_debug(""Underflows must be unconditional and ""
""use the STANDARD target with ""
""ACCEPT/DROP\n"");
return -VAR_9;
}
VAR_1->underflow[VAR_7] = VAR_5[VAR_7];
}
}
VAR_0->counters = ((struct xt_counters) { 0, 0 });
VAR_0->comefrom = 0;
return 0;
}",torvalds/linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/ip_tables.c/vul/before/0.json,"static int
check_entry_size_and_hooks(struct ipt_entry *e,
			   struct xt_table_info *newinfo,
			   const unsigned char *base,
			   const unsigned char *limit,
			   const unsigned int *hook_entries,
			   const unsigned int *underflows,
			   unsigned int valid_hooks)
{
	unsigned int h;
	int err;

	if ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||
	    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||
	    (unsigned char *)e + e->next_offset > limit) {
		duprintf(""Bad offset %p\n"", e);
		return -EINVAL;
	}

	if (e->next_offset
	    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 e, e->next_offset);
		return -EINVAL;
	}

	if (!ip_checkentry(&e->ip))
		return -EINVAL;

	err = xt_check_entry_offsets(e, e->elems, e->target_offset,
				     e->next_offset);
	if (err)
		return err;

	/* Check hooks & underflows */
	for (h = 0; h < NF_INET_NUMHOOKS; h++) {
		if (!(valid_hooks & (1 << h)))
			continue;
		if ((unsigned char *)e - base == hook_entries[h])
			newinfo->hook_entry[h] = hook_entries[h];
		if ((unsigned char *)e - base == underflows[h]) {
			if (!check_underflow(e)) {
				pr_debug(""Underflows must be unconditional and ""
					 ""use the STANDARD target with ""
					 ""ACCEPT/DROP\n"");
				return -EINVAL;
			}
			newinfo->underflow[h] = underflows[h];
		}
	}

	/* Clear counters and comefrom */
	e->counters = ((struct xt_counters) { 0, 0 });
	e->comefrom = 0;
	return 0;
}","static int
check_entry_size_and_hooks(struct ipt_entry *VAR_0,
			   struct xt_table_info *VAR_1,
			   const unsigned char *VAR_2,
			   const unsigned char *VAR_3,
			   const unsigned int *VAR_4,
			   const unsigned int *VAR_5,
			   unsigned int VAR_6)
{
	unsigned int VAR_7;
	int VAR_8;

	if ((unsigned long)VAR_0 % __alignof__(struct ipt_entry) != 0 ||
	    (unsigned char *)VAR_0 + sizeof(struct ipt_entry) >= VAR_3 ||
	    (unsigned char *)VAR_0 + VAR_0->next_offset > VAR_3) {
		duprintf(""Bad offset %p\n"", VAR_0);
		return -VAR_9;
	}

	if (VAR_0->next_offset
	    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 VAR_0, VAR_0->next_offset);
		return -VAR_9;
	}

	if (!ip_checkentry(&VAR_0->ip))
		return -VAR_9;

	VAR_8 = xt_check_entry_offsets(VAR_0, VAR_0->elems, VAR_0->target_offset,
				     VAR_0->next_offset);
	if (VAR_8)
		return VAR_8;

	/* COMMENT_0 */
	for (VAR_7 = 0; VAR_7 < VAR_10; VAR_7++) {
		if (!(VAR_6 & (1 << VAR_7)))
			continue;
		if ((unsigned char *)VAR_0 - VAR_2 == VAR_4[VAR_7])
			VAR_1->hook_entry[VAR_7] = VAR_4[VAR_7];
		if ((unsigned char *)VAR_0 - VAR_2 == VAR_5[VAR_7]) {
			if (!check_underflow(VAR_0)) {
				pr_debug(""Underflows must be unconditional and ""
					 ""use the STANDARD target with ""
					 ""ACCEPT/DROP\n"");
				return -VAR_9;
			}
			VAR_1->underflow[VAR_7] = VAR_5[VAR_7];
		}
	}

	/* COMMENT_1 */
	VAR_0->counters = ((struct xt_counters) { 0, 0 });
	VAR_0->comefrom = 0;
	return 0;
}",torvalds/linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/ip_tables.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -27,7 +27,8 @@
 	if (!ip_checkentry(&e->ip))
 		return -EINVAL;
 
-	err = xt_check_entry_offsets(e, e->target_offset, e->next_offset);
+	err = xt_check_entry_offsets(e, e->elems, e->target_offset,
+				     e->next_offset);
 	if (err)
 		return err;
 ","{'deleted_lines': ['\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);'], 'added_lines': ['\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,', '\t\t\t\t     e->next_offset);']}",True,The compat IPT_SO_SET_REPLACE and IP6T_SO_SET_REPLACE setsockopt implementations in the netfilter subsystem in the Linux kernel before 4.6.3 allow local users to gain privileges or cause a denial of service (memory corruption) by leveraging in-container root access to provide a crafted offset value that triggers an unintended decrement.,7.8,HIGH,2,test,2016-04-01T12:17:28Z,1
CVE-2016-4997,['CWE-264'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"netfilter: x_tables: check for bogus target offset

We're currently asserting that targetoff + targetsize <= nextoff.

Extend it to also check that targetoff is >= sizeof(xt_entry).
Since this is generic code, add an argument pointing to the start of the
match/target, we can then derive the base structure size from the delta.

We also need the e->elems pointer in a followup change to validate matches.

Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,https://github.com/torvalds/linux/commit/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,net/ipv4/netfilter/ip_tables.c,check_compat_entry_size_and_hooks,"static int
check_compat_entry_size_and_hooks(struct compat_ipt_entry *e,
struct xt_table_info *newinfo,
unsigned int *size,
const unsigned char *base,
const unsigned char *limit,
const unsigned int *hook_entries,
const unsigned int *underflows,
const char *name)
{
struct xt_entry_match *ematch;
struct xt_entry_target *t;
struct xt_target *target;
unsigned int entry_offset;
unsigned int j;
int ret, off, h;
duprintf(""check_compat_entry_size_and_hooks %p\n"", e);
if ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||
(unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit ||
(unsigned char *)e + e->next_offset > limit) {
duprintf(""Bad offset %p, limit = %p\n"", e, limit);
return -EINVAL;
}
if (e->next_offset < sizeof(struct compat_ipt_entry) +
sizeof(struct compat_xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
e, e->next_offset);
return -EINVAL;
}
if (!ip_checkentry(&e->ip))
return -EINVAL;
ret = xt_compat_check_entry_offsets(e,
e->target_offset, e->next_offset);
if (ret)
return ret;
off = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);
entry_offset = (void *)e - (void *)base;
j = 0;
xt_ematch_foreach(ematch, e) {
ret = compat_find_calc_match(ematch, name, &e->ip, &off);
if (ret != 0)
goto release_matches;
++j;
}
t = compat_ipt_get_target(e);
target = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,
t->u.user.revision);
if (IS_ERR(target)) {
duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
t->u.user.name);
ret = PTR_ERR(target);
goto release_matches;
}
t->u.kernel.target = target;
off += xt_compat_target_offset(target);
*size += off;
ret = xt_compat_add_offset(AF_INET, entry_offset, off);
if (ret)
goto out;
for (h = 0; h < NF_INET_NUMHOOKS; h++) {
if ((unsigned char *)e - base == hook_entries[h])
newinfo->hook_entry[h] = hook_entries[h];
if ((unsigned char *)e - base == underflows[h])
newinfo->underflow[h] = underflows[h];
}
memset(&e->counters, 0, sizeof(e->counters));
e->comefrom = 0;
return 0;
out:
module_put(t->u.kernel.target->me);
release_matches:
xt_ematch_foreach(ematch, e) {
if (j-- == 0)
break;
module_put(ematch->u.kernel.match->me);
}
return ret;
}","static int
check_compat_entry_size_and_hooks(struct compat_ipt_entry *VAR_0,
struct xt_table_info *VAR_1,
unsigned int *VAR_2,
const unsigned char *VAR_3,
const unsigned char *VAR_4,
const unsigned int *VAR_5,
const unsigned int *VAR_6,
const char *VAR_7)
{
struct xt_entry_match *VAR_8;
struct xt_entry_target *VAR_9;
struct xt_target *VAR_10;
unsigned int VAR_11;
unsigned int VAR_12;
int VAR_13, VAR_14, VAR_15;
duprintf(""check_compat_entry_size_and_hooks %p\n"", VAR_0);
if ((unsigned long)VAR_0 % __alignof__(struct compat_ipt_entry) != 0 ||
(unsigned char *)VAR_0 + sizeof(struct compat_ipt_entry) >= VAR_4 ||
(unsigned char *)VAR_0 + VAR_0->next_offset > VAR_4) {
duprintf(""Bad offset %p, limit = %p\n"", VAR_0, VAR_4);
return -VAR_16;
}
if (VAR_0->next_offset < sizeof(struct compat_ipt_entry) +
sizeof(struct compat_xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
VAR_0, VAR_0->next_offset);
return -VAR_16;
}
if (!ip_checkentry(&VAR_0->ip))
return -VAR_16;
VAR_13 = xt_compat_check_entry_offsets(VAR_0,
VAR_0->target_offset, VAR_0->next_offset);
if (VAR_13)
return VAR_13;
VAR_14 = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);
VAR_11 = (void *)VAR_0 - (void *)VAR_3;
VAR_12 = 0;
xt_ematch_foreach(VAR_8, VAR_0) {
VAR_13 = compat_find_calc_match(VAR_8, VAR_7, &VAR_0->ip, &VAR_14);
if (VAR_13 != 0)
goto release_matches;
++VAR_12;
}
VAR_9 = compat_ipt_get_target(VAR_0);
VAR_10 = xt_request_find_target(VAR_17, VAR_9->u.user.name,
VAR_9->u.user.revision);
if (IS_ERR(VAR_10)) {
duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
VAR_9->u.user.name);
VAR_13 = PTR_ERR(VAR_10);
goto release_matches;
}
VAR_9->u.kernel.target = VAR_10;
VAR_14 += xt_compat_target_offset(VAR_10);
*VAR_2 += VAR_14;
VAR_13 = xt_compat_add_offset(VAR_18, VAR_11, VAR_14);
if (VAR_13)
goto out;
for (VAR_15 = 0; VAR_15 < VAR_19; VAR_15++) {
if ((unsigned char *)VAR_0 - VAR_3 == VAR_5[VAR_15])
VAR_1->hook_entry[VAR_15] = VAR_5[VAR_15];
if ((unsigned char *)VAR_0 - VAR_3 == VAR_6[VAR_15])
VAR_1->underflow[VAR_15] = VAR_6[VAR_15];
}
memset(&VAR_0->counters, 0, sizeof(VAR_0->counters));
VAR_0->comefrom = 0;
return 0;
out:
module_put(VAR_9->u.kernel.target->me);
release_matches:
xt_ematch_foreach(VAR_8, VAR_0) {
if (VAR_12-- == 0)
break;
module_put(VAR_8->u.kernel.match->me);
}
return VAR_13;
}",torvalds/linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/ip_tables.c/vul/before/1.json,"static int
check_compat_entry_size_and_hooks(struct compat_ipt_entry *e,
				  struct xt_table_info *newinfo,
				  unsigned int *size,
				  const unsigned char *base,
				  const unsigned char *limit,
				  const unsigned int *hook_entries,
				  const unsigned int *underflows,
				  const char *name)
{
	struct xt_entry_match *ematch;
	struct xt_entry_target *t;
	struct xt_target *target;
	unsigned int entry_offset;
	unsigned int j;
	int ret, off, h;

	duprintf(""check_compat_entry_size_and_hooks %p\n"", e);
	if ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||
	    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit ||
	    (unsigned char *)e + e->next_offset > limit) {
		duprintf(""Bad offset %p, limit = %p\n"", e, limit);
		return -EINVAL;
	}

	if (e->next_offset < sizeof(struct compat_ipt_entry) +
			     sizeof(struct compat_xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 e, e->next_offset);
		return -EINVAL;
	}

	if (!ip_checkentry(&e->ip))
		return -EINVAL;

	ret = xt_compat_check_entry_offsets(e, e->elems,
					    e->target_offset, e->next_offset);
	if (ret)
		return ret;

	off = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);
	entry_offset = (void *)e - (void *)base;
	j = 0;
	xt_ematch_foreach(ematch, e) {
		ret = compat_find_calc_match(ematch, name, &e->ip, &off);
		if (ret != 0)
			goto release_matches;
		++j;
	}

	t = compat_ipt_get_target(e);
	target = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,
					t->u.user.revision);
	if (IS_ERR(target)) {
		duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
			 t->u.user.name);
		ret = PTR_ERR(target);
		goto release_matches;
	}
	t->u.kernel.target = target;

	off += xt_compat_target_offset(target);
	*size += off;
	ret = xt_compat_add_offset(AF_INET, entry_offset, off);
	if (ret)
		goto out;

	/* Check hooks & underflows */
	for (h = 0; h < NF_INET_NUMHOOKS; h++) {
		if ((unsigned char *)e - base == hook_entries[h])
			newinfo->hook_entry[h] = hook_entries[h];
		if ((unsigned char *)e - base == underflows[h])
			newinfo->underflow[h] = underflows[h];
	}

	/* Clear counters and comefrom */
	memset(&e->counters, 0, sizeof(e->counters));
	e->comefrom = 0;
	return 0;

out:
	module_put(t->u.kernel.target->me);
release_matches:
	xt_ematch_foreach(ematch, e) {
		if (j-- == 0)
			break;
		module_put(ematch->u.kernel.match->me);
	}
	return ret;
}","static int
check_compat_entry_size_and_hooks(struct compat_ipt_entry *VAR_0,
				  struct xt_table_info *VAR_1,
				  unsigned int *VAR_2,
				  const unsigned char *VAR_3,
				  const unsigned char *VAR_4,
				  const unsigned int *VAR_5,
				  const unsigned int *VAR_6,
				  const char *VAR_7)
{
	struct xt_entry_match *VAR_8;
	struct xt_entry_target *VAR_9;
	struct xt_target *VAR_10;
	unsigned int VAR_11;
	unsigned int VAR_12;
	int VAR_13, VAR_14, VAR_15;

	duprintf(""check_compat_entry_size_and_hooks %p\n"", VAR_0);
	if ((unsigned long)VAR_0 % __alignof__(struct compat_ipt_entry) != 0 ||
	    (unsigned char *)VAR_0 + sizeof(struct compat_ipt_entry) >= VAR_4 ||
	    (unsigned char *)VAR_0 + VAR_0->next_offset > VAR_4) {
		duprintf(""Bad offset %p, limit = %p\n"", VAR_0, VAR_4);
		return -VAR_16;
	}

	if (VAR_0->next_offset < sizeof(struct compat_ipt_entry) +
			     sizeof(struct compat_xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 VAR_0, VAR_0->next_offset);
		return -VAR_16;
	}

	if (!ip_checkentry(&VAR_0->ip))
		return -VAR_16;

	VAR_13 = xt_compat_check_entry_offsets(VAR_0, VAR_0->elems,
					    VAR_0->target_offset, VAR_0->next_offset);
	if (VAR_13)
		return VAR_13;

	VAR_14 = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);
	VAR_11 = (void *)VAR_0 - (void *)VAR_3;
	VAR_12 = 0;
	xt_ematch_foreach(VAR_8, VAR_0) {
		VAR_13 = compat_find_calc_match(VAR_8, VAR_7, &VAR_0->ip, &VAR_14);
		if (VAR_13 != 0)
			goto release_matches;
		++VAR_12;
	}

	VAR_9 = compat_ipt_get_target(VAR_0);
	VAR_10 = xt_request_find_target(VAR_17, VAR_9->u.user.name,
					VAR_9->u.user.revision);
	if (IS_ERR(VAR_10)) {
		duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"",
			 VAR_9->u.user.name);
		VAR_13 = PTR_ERR(VAR_10);
		goto release_matches;
	}
	VAR_9->u.kernel.target = VAR_10;

	VAR_14 += xt_compat_target_offset(VAR_10);
	*VAR_2 += VAR_14;
	VAR_13 = xt_compat_add_offset(VAR_18, VAR_11, VAR_14);
	if (VAR_13)
		goto out;

	/* COMMENT_0 */
	for (VAR_15 = 0; VAR_15 < VAR_19; VAR_15++) {
		if ((unsigned char *)VAR_0 - VAR_3 == VAR_5[VAR_15])
			VAR_1->hook_entry[VAR_15] = VAR_5[VAR_15];
		if ((unsigned char *)VAR_0 - VAR_3 == VAR_6[VAR_15])
			VAR_1->underflow[VAR_15] = VAR_6[VAR_15];
	}

	/* COMMENT_1 */
	memset(&VAR_0->counters, 0, sizeof(VAR_0->counters));
	VAR_0->comefrom = 0;
	return 0;

out:
	module_put(VAR_9->u.kernel.target->me);
release_matches:
	xt_ematch_foreach(VAR_8, VAR_0) {
		if (VAR_12-- == 0)
			break;
		module_put(VAR_8->u.kernel.match->me);
	}
	return VAR_13;
}",torvalds/linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/ip_tables.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -33,7 +33,7 @@
 	if (!ip_checkentry(&e->ip))
 		return -EINVAL;
 
-	ret = xt_compat_check_entry_offsets(e,
+	ret = xt_compat_check_entry_offsets(e, e->elems,
 					    e->target_offset, e->next_offset);
 	if (ret)
 		return ret;","{'deleted_lines': ['\tret = xt_compat_check_entry_offsets(e,'], 'added_lines': ['\tret = xt_compat_check_entry_offsets(e, e->elems,']}",True,The compat IPT_SO_SET_REPLACE and IP6T_SO_SET_REPLACE setsockopt implementations in the netfilter subsystem in the Linux kernel before 4.6.3 allow local users to gain privileges or cause a denial of service (memory corruption) by leveraging in-container root access to provide a crafted offset value that triggers an unintended decrement.,7.8,HIGH,2,test,2016-04-01T12:17:28Z,1
CVE-2016-4997,['CWE-264'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"netfilter: x_tables: check for bogus target offset

We're currently asserting that targetoff + targetsize <= nextoff.

Extend it to also check that targetoff is >= sizeof(xt_entry).
Since this is generic code, add an argument pointing to the start of the
match/target, we can then derive the base structure size from the delta.

We also need the e->elems pointer in a followup change to validate matches.

Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,https://github.com/torvalds/linux/commit/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,net/netfilter/x_tables.c,xt_compat_check_entry_offsets,"int xt_compat_check_entry_offsets(const void *base,
unsigned int target_offset,
unsigned int next_offset)
{
const struct compat_xt_entry_target *t;
const char *e = base;
if (target_offset + sizeof(*t) > next_offset)
return -EINVAL;
t = (void *)(e + target_offset);
if (t->u.target_size < sizeof(*t))
return -EINVAL;
if (target_offset + t->u.target_size > next_offset)
return -EINVAL;
if (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&
target_offset + sizeof(struct compat_xt_standard_target) != next_offset)
return -EINVAL;
return 0;
}","int xt_compat_check_entry_offsets(const void *VAR_0,
unsigned int VAR_1,
unsigned int VAR_2)
{
const struct compat_xt_entry_target *VAR_3;
const char *VAR_4 = VAR_0;
if (VAR_1 + sizeof(*VAR_3) > VAR_2)
return -VAR_5;
VAR_3 = (void *)(VAR_4 + VAR_1);
if (VAR_3->u.target_size < sizeof(*VAR_3))
return -VAR_5;
if (VAR_1 + VAR_3->u.target_size > VAR_2)
return -VAR_5;
if (strcmp(VAR_3->u.user.name, VAR_6) == 0 &&
VAR_1 + sizeof(struct compat_xt_standard_target) != VAR_2)
return -VAR_5;
return 0;
}",torvalds/linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/x_tables.c/vul/before/0.json,"int xt_compat_check_entry_offsets(const void *base, const char *elems,
				  unsigned int target_offset,
				  unsigned int next_offset)
{
	long size_of_base_struct = elems - (const char *)base;
	const struct compat_xt_entry_target *t;
	const char *e = base;

	if (target_offset < size_of_base_struct)
		return -EINVAL;

	if (target_offset + sizeof(*t) > next_offset)
		return -EINVAL;

	t = (void *)(e + target_offset);
	if (t->u.target_size < sizeof(*t))
		return -EINVAL;

	if (target_offset + t->u.target_size > next_offset)
		return -EINVAL;

	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&
	    target_offset + sizeof(struct compat_xt_standard_target) != next_offset)
		return -EINVAL;

	return 0;
}","int xt_compat_check_entry_offsets(const void *VAR_0, const char *VAR_1,
				  unsigned int VAR_2,
				  unsigned int VAR_3)
{
	long VAR_4 = VAR_1 - (const char *)VAR_0;
	const struct compat_xt_entry_target *VAR_5;
	const char *VAR_6 = VAR_0;

	if (VAR_2 < VAR_4)
		return -VAR_7;

	if (VAR_2 + sizeof(*VAR_5) > VAR_3)
		return -VAR_7;

	VAR_5 = (void *)(VAR_6 + VAR_2);
	if (VAR_5->u.target_size < sizeof(*VAR_5))
		return -VAR_7;

	if (VAR_2 + VAR_5->u.target_size > VAR_3)
		return -VAR_7;

	if (strcmp(VAR_5->u.user.name, VAR_8) == 0 &&
	    VAR_2 + sizeof(struct compat_xt_standard_target) != VAR_3)
		return -VAR_7;

	return 0;
}",torvalds/linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/x_tables.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,9 +1,13 @@
-int xt_compat_check_entry_offsets(const void *base,
+int xt_compat_check_entry_offsets(const void *base, const char *elems,
 				  unsigned int target_offset,
 				  unsigned int next_offset)
 {
+	long size_of_base_struct = elems - (const char *)base;
 	const struct compat_xt_entry_target *t;
 	const char *e = base;
+
+	if (target_offset < size_of_base_struct)
+		return -EINVAL;
 
 	if (target_offset + sizeof(*t) > next_offset)
 		return -EINVAL;","{'deleted_lines': ['int xt_compat_check_entry_offsets(const void *base,'], 'added_lines': ['int xt_compat_check_entry_offsets(const void *base, const char *elems,', '\tlong size_of_base_struct = elems - (const char *)base;', '', '\tif (target_offset < size_of_base_struct)', '\t\treturn -EINVAL;']}",True,The compat IPT_SO_SET_REPLACE and IP6T_SO_SET_REPLACE setsockopt implementations in the netfilter subsystem in the Linux kernel before 4.6.3 allow local users to gain privileges or cause a denial of service (memory corruption) by leveraging in-container root access to provide a crafted offset value that triggers an unintended decrement.,7.8,HIGH,2,test,2016-04-01T12:17:28Z,1
CVE-2016-4997,['CWE-264'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"netfilter: x_tables: check for bogus target offset

We're currently asserting that targetoff + targetsize <= nextoff.

Extend it to also check that targetoff is >= sizeof(xt_entry).
Since this is generic code, add an argument pointing to the start of the
match/target, we can then derive the base structure size from the delta.

We also need the e->elems pointer in a followup change to validate matches.

Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,https://github.com/torvalds/linux/commit/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,net/ipv4/netfilter/arp_tables.c,check_entry_size_and_hooks,"static inline int check_entry_size_and_hooks(struct arpt_entry *e,
struct xt_table_info *newinfo,
const unsigned char *base,
const unsigned char *limit,
const unsigned int *hook_entries,
const unsigned int *underflows,
unsigned int valid_hooks)
{
unsigned int h;
int err;
if ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||
(unsigned char *)e + sizeof(struct arpt_entry) >= limit ||
(unsigned char *)e + e->next_offset > limit) {
duprintf(""Bad offset %p\n"", e);
return -EINVAL;
}
if (e->next_offset
< sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
e, e->next_offset);
return -EINVAL;
}
if (!arp_checkentry(&e->arp))
return -EINVAL;
err = xt_check_entry_offsets(e, e->target_offset, e->next_offset);
if (err)
return err;
for (h = 0; h < NF_ARP_NUMHOOKS; h++) {
if (!(valid_hooks & (1 << h)))
continue;
if ((unsigned char *)e - base == hook_entries[h])
newinfo->hook_entry[h] = hook_entries[h];
if ((unsigned char *)e - base == underflows[h]) {
if (!check_underflow(e)) {
pr_debug(""Underflows must be unconditional and ""
""use the STANDARD target with ""
""ACCEPT/DROP\n"");
return -EINVAL;
}
newinfo->underflow[h] = underflows[h];
}
}
e->counters = ((struct xt_counters) { 0, 0 });
e->comefrom = 0;
return 0;
}","static inline int check_entry_size_and_hooks(struct arpt_entry *VAR_0,
struct xt_table_info *VAR_1,
const unsigned char *VAR_2,
const unsigned char *VAR_3,
const unsigned int *VAR_4,
const unsigned int *VAR_5,
unsigned int VAR_6)
{
unsigned int VAR_7;
int VAR_8;
if ((unsigned long)VAR_0 % __alignof__(struct arpt_entry) != 0 ||
(unsigned char *)VAR_0 + sizeof(struct arpt_entry) >= VAR_3 ||
(unsigned char *)VAR_0 + VAR_0->next_offset > VAR_3) {
duprintf(""Bad offset %p\n"", VAR_0);
return -VAR_9;
}
if (VAR_0->next_offset
< sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {
duprintf(""checking: element %p size %u\n"",
VAR_0, VAR_0->next_offset);
return -VAR_9;
}
if (!arp_checkentry(&VAR_0->arp))
return -VAR_9;
VAR_8 = xt_check_entry_offsets(VAR_0, VAR_0->target_offset, VAR_0->next_offset);
if (VAR_8)
return VAR_8;
for (VAR_7 = 0; VAR_7 < VAR_10; VAR_7++) {
if (!(VAR_6 & (1 << VAR_7)))
continue;
if ((unsigned char *)VAR_0 - VAR_2 == VAR_4[VAR_7])
VAR_1->hook_entry[VAR_7] = VAR_4[VAR_7];
if ((unsigned char *)VAR_0 - VAR_2 == VAR_5[VAR_7]) {
if (!check_underflow(VAR_0)) {
pr_debug(""Underflows must be unconditional and ""
""use the STANDARD target with ""
""ACCEPT/DROP\n"");
return -VAR_9;
}
VAR_1->underflow[VAR_7] = VAR_5[VAR_7];
}
}
VAR_0->counters = ((struct xt_counters) { 0, 0 });
VAR_0->comefrom = 0;
return 0;
}",torvalds/linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/arp_tables.c/vul/before/0.json,"static inline int check_entry_size_and_hooks(struct arpt_entry *e,
					     struct xt_table_info *newinfo,
					     const unsigned char *base,
					     const unsigned char *limit,
					     const unsigned int *hook_entries,
					     const unsigned int *underflows,
					     unsigned int valid_hooks)
{
	unsigned int h;
	int err;

	if ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||
	    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||
	    (unsigned char *)e + e->next_offset > limit) {
		duprintf(""Bad offset %p\n"", e);
		return -EINVAL;
	}

	if (e->next_offset
	    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 e, e->next_offset);
		return -EINVAL;
	}

	if (!arp_checkentry(&e->arp))
		return -EINVAL;

	err = xt_check_entry_offsets(e, e->elems, e->target_offset,
				     e->next_offset);
	if (err)
		return err;

	/* Check hooks & underflows */
	for (h = 0; h < NF_ARP_NUMHOOKS; h++) {
		if (!(valid_hooks & (1 << h)))
			continue;
		if ((unsigned char *)e - base == hook_entries[h])
			newinfo->hook_entry[h] = hook_entries[h];
		if ((unsigned char *)e - base == underflows[h]) {
			if (!check_underflow(e)) {
				pr_debug(""Underflows must be unconditional and ""
					 ""use the STANDARD target with ""
					 ""ACCEPT/DROP\n"");
				return -EINVAL;
			}
			newinfo->underflow[h] = underflows[h];
		}
	}

	/* Clear counters and comefrom */
	e->counters = ((struct xt_counters) { 0, 0 });
	e->comefrom = 0;
	return 0;
}","static inline int check_entry_size_and_hooks(struct arpt_entry *VAR_0,
					     struct xt_table_info *VAR_1,
					     const unsigned char *VAR_2,
					     const unsigned char *VAR_3,
					     const unsigned int *VAR_4,
					     const unsigned int *VAR_5,
					     unsigned int VAR_6)
{
	unsigned int VAR_7;
	int VAR_8;

	if ((unsigned long)VAR_0 % __alignof__(struct arpt_entry) != 0 ||
	    (unsigned char *)VAR_0 + sizeof(struct arpt_entry) >= VAR_3 ||
	    (unsigned char *)VAR_0 + VAR_0->next_offset > VAR_3) {
		duprintf(""Bad offset %p\n"", VAR_0);
		return -VAR_9;
	}

	if (VAR_0->next_offset
	    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 VAR_0, VAR_0->next_offset);
		return -VAR_9;
	}

	if (!arp_checkentry(&VAR_0->arp))
		return -VAR_9;

	VAR_8 = xt_check_entry_offsets(VAR_0, VAR_0->elems, VAR_0->target_offset,
				     VAR_0->next_offset);
	if (VAR_8)
		return VAR_8;

	/* COMMENT_0 */
	for (VAR_7 = 0; VAR_7 < VAR_10; VAR_7++) {
		if (!(VAR_6 & (1 << VAR_7)))
			continue;
		if ((unsigned char *)VAR_0 - VAR_2 == VAR_4[VAR_7])
			VAR_1->hook_entry[VAR_7] = VAR_4[VAR_7];
		if ((unsigned char *)VAR_0 - VAR_2 == VAR_5[VAR_7]) {
			if (!check_underflow(VAR_0)) {
				pr_debug(""Underflows must be unconditional and ""
					 ""use the STANDARD target with ""
					 ""ACCEPT/DROP\n"");
				return -VAR_9;
			}
			VAR_1->underflow[VAR_7] = VAR_5[VAR_7];
		}
	}

	/* COMMENT_1 */
	VAR_0->counters = ((struct xt_counters) { 0, 0 });
	VAR_0->comefrom = 0;
	return 0;
}",torvalds/linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/arp_tables.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -26,7 +26,8 @@
 	if (!arp_checkentry(&e->arp))
 		return -EINVAL;
 
-	err = xt_check_entry_offsets(e, e->target_offset, e->next_offset);
+	err = xt_check_entry_offsets(e, e->elems, e->target_offset,
+				     e->next_offset);
 	if (err)
 		return err;
 ","{'deleted_lines': ['\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);'], 'added_lines': ['\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,', '\t\t\t\t     e->next_offset);']}",True,The compat IPT_SO_SET_REPLACE and IP6T_SO_SET_REPLACE setsockopt implementations in the netfilter subsystem in the Linux kernel before 4.6.3 allow local users to gain privileges or cause a denial of service (memory corruption) by leveraging in-container root access to provide a crafted offset value that triggers an unintended decrement.,7.8,HIGH,2,test,2016-04-01T12:17:28Z,1
CVE-2016-4804,['CWE-119'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,dosfstools,"read_boot(): Handle excessive FAT size specifications

The variable used for storing the FAT size (in bytes) was an unsigned
int. Since the size in sectors read from the BPB was not sufficiently
checked, this could end up being zero after multiplying it with the
sector size while some offsets still stayed excessive. Ultimately it
would cause segfaults when accessing FAT entries for which no memory
was allocated.

Make it more robust by changing the types used to store FAT size to
off_t and abort if there is no room for data clusters. Additionally
check that FAT size is not specified as zero.

Fixes #25 and fixes #26.

Reported-by: Hanno Bck
Signed-off-by: Andreas Bombe <aeb@debian.org>",e8eff147e9da1185f9afd5b25948153a3b97cf52,https://github.com/dosfstools/dosfstools/commit/e8eff147e9da1185f9afd5b25948153a3b97cf52,src/boot.c,dump_boot,"static void dump_boot(DOS_FS * fs, struct boot_sector *b, unsigned lss)
{
unsigned short sectors;
printf(""Boot sector contents:\n"");
if (!atari_format) {
char id[9];
strncpy(id, (const char *)b->system_id, 8);
id[8] = 0;
printf(""System ID \""%s\""\n"", id);
} else {
printf(""Serial number 0x%x\n"",
b->system_id[5] | (b->system_id[6] << 8) | (b->
system_id[7] << 16));
}
printf(""Media byte 0x%02x (%s)\n"", b->media, get_media_descr(b->media));
printf(""%10d bytes per logical sector\n"", GET_UNALIGNED_W(b->sector_size));
printf(""%10d bytes per cluster\n"", fs->cluster_size);
printf(""%10d reserved sector%s\n"", le16toh(b->reserved),
le16toh(b->reserved) == 1 ? """" : ""s"");
printf(""First FAT starts at byte %llu (sector %llu)\n"",
(unsigned long long)fs->fat_start,
(unsigned long long)fs->fat_start / lss);
printf(""%10d FATs, %d bit entries\n"", b->fats, fs->fat_bits);
printf(""%10d bytes per FAT (= %u sectors)\n"", fs->fat_size,
fs->fat_size / lss);
if (!fs->root_cluster) {
printf(""Root directory starts at byte %llu (sector %llu)\n"",
(unsigned long long)fs->root_start,
(unsigned long long)fs->root_start / lss);
printf(""%10d root directory entries\n"", fs->root_entries);
} else {
printf(""Root directory start at cluster %lu (arbitrary size)\n"",
(unsigned long)fs->root_cluster);
}
printf(""Data area starts at byte %llu (sector %llu)\n"",
(unsigned long long)fs->data_start,
(unsigned long long)fs->data_start / lss);
printf(""%10lu data clusters (%llu bytes)\n"",
(unsigned long)fs->data_clusters,
(unsigned long long)fs->data_clusters * fs->cluster_size);
printf(""%u sectors/track, %u heads\n"", le16toh(b->secs_track),
le16toh(b->heads));
printf(""%10u hidden sectors\n"", atari_format ?
(((unsigned char *)&b->hidden)[0] |
((unsigned char *)&b->hidden)[1] << 8) : le32toh(b->hidden));
sectors = GET_UNALIGNED_W(b->sectors);
printf(""%10u sectors total\n"", sectors ? sectors : le32toh(b->total_sect));
}","static void dump_boot(DOS_FS * VAR_0, struct boot_sector *VAR_1, unsigned VAR_2)
{
unsigned short VAR_3;
printf(""Boot sector contents:\n"");
if (!VAR_4) {
char VAR_5[9];
strncpy(VAR_5, (const char *)VAR_1->system_id, 8);
VAR_5[8] = 0;
printf(""System ID \""%s\""\n"", VAR_5);
} else {
printf(""Serial number 0x%x\n"",
VAR_1->system_id[5] | (VAR_1->system_id[6] << 8) | (VAR_1->
system_id[7] << 16));
}
printf(""Media byte 0x%02x (%s)\n"", VAR_1->media, get_media_descr(VAR_1->media));
printf(""%10d bytes per logical sector\n"", GET_UNALIGNED_W(VAR_1->sector_size));
printf(""%10d bytes per cluster\n"", VAR_0->cluster_size);
printf(""%10d reserved sector%s\n"", le16toh(VAR_1->reserved),
le16toh(VAR_1->reserved) == 1 ? """" : ""s"");
printf(""First FAT starts at byte %llu (sector %llu)\n"",
(unsigned long long)VAR_0->fat_start,
(unsigned long long)VAR_0->fat_start / VAR_2);
printf(""%10d FATs, %d bit entries\n"", VAR_1->fats, VAR_0->fat_bits);
printf(""%10d bytes per FAT (= %u sectors)\n"", VAR_0->fat_size,
VAR_0->fat_size / VAR_2);
if (!VAR_0->root_cluster) {
printf(""Root directory starts at byte %llu (sector %llu)\n"",
(unsigned long long)VAR_0->root_start,
(unsigned long long)VAR_0->root_start / VAR_2);
printf(""%10d root directory entries\n"", VAR_0->root_entries);
} else {
printf(""Root directory start at cluster %lu (arbitrary size)\n"",
(unsigned long)VAR_0->root_cluster);
}
printf(""Data area starts at byte %llu (sector %llu)\n"",
(unsigned long long)VAR_0->data_start,
(unsigned long long)VAR_0->data_start / VAR_2);
printf(""%10lu data clusters (%llu bytes)\n"",
(unsigned long)VAR_0->data_clusters,
(unsigned long long)VAR_0->data_clusters * VAR_0->cluster_size);
printf(""%u sectors/track, %u heads\n"", le16toh(VAR_1->secs_track),
le16toh(VAR_1->heads));
printf(""%10u hidden sectors\n"", VAR_4 ?
(((unsigned char *)&VAR_1->hidden)[0] |
((unsigned char *)&VAR_1->hidden)[1] << 8) : le32toh(VAR_1->hidden));
VAR_3 = GET_UNALIGNED_W(VAR_1->sectors);
printf(""%10u sectors total\n"", VAR_3 ? VAR_3 : le32toh(VAR_1->total_sect));
}",dosfstools/e8eff147e9da1185f9afd5b25948153a3b97cf52/boot.c/vul/before/1.json,"static void dump_boot(DOS_FS * fs, struct boot_sector *b, unsigned lss)
{
    unsigned short sectors;

    printf(""Boot sector contents:\n"");
    if (!atari_format) {
	char id[9];
	strncpy(id, (const char *)b->system_id, 8);
	id[8] = 0;
	printf(""System ID \""%s\""\n"", id);
    } else {
	/* On Atari, a 24 bit serial number is stored at offset 8 of the boot
	 * sector */
	printf(""Serial number 0x%x\n"",
	       b->system_id[5] | (b->system_id[6] << 8) | (b->
							   system_id[7] << 16));
    }
    printf(""Media byte 0x%02x (%s)\n"", b->media, get_media_descr(b->media));
    printf(""%10d bytes per logical sector\n"", GET_UNALIGNED_W(b->sector_size));
    printf(""%10d bytes per cluster\n"", fs->cluster_size);
    printf(""%10d reserved sector%s\n"", le16toh(b->reserved),
	   le16toh(b->reserved) == 1 ? """" : ""s"");
    printf(""First FAT starts at byte %llu (sector %llu)\n"",
	   (unsigned long long)fs->fat_start,
	   (unsigned long long)fs->fat_start / lss);
    printf(""%10d FATs, %d bit entries\n"", b->fats, fs->fat_bits);
    printf(""%10lld bytes per FAT (= %llu sectors)\n"", (long long)fs->fat_size,
	   (long long)fs->fat_size / lss);
    if (!fs->root_cluster) {
	printf(""Root directory starts at byte %llu (sector %llu)\n"",
	       (unsigned long long)fs->root_start,
	       (unsigned long long)fs->root_start / lss);
	printf(""%10d root directory entries\n"", fs->root_entries);
    } else {
	printf(""Root directory start at cluster %lu (arbitrary size)\n"",
	       (unsigned long)fs->root_cluster);
    }
    printf(""Data area starts at byte %llu (sector %llu)\n"",
	   (unsigned long long)fs->data_start,
	   (unsigned long long)fs->data_start / lss);
    printf(""%10lu data clusters (%llu bytes)\n"",
	   (unsigned long)fs->data_clusters,
	   (unsigned long long)fs->data_clusters * fs->cluster_size);
    printf(""%u sectors/track, %u heads\n"", le16toh(b->secs_track),
	   le16toh(b->heads));
    printf(""%10u hidden sectors\n"", atari_format ?
	   /* On Atari, the hidden field is only 16 bit wide and unused */
	   (((unsigned char *)&b->hidden)[0] |
	    ((unsigned char *)&b->hidden)[1] << 8) : le32toh(b->hidden));
    sectors = GET_UNALIGNED_W(b->sectors);
    printf(""%10u sectors total\n"", sectors ? sectors : le32toh(b->total_sect));
}","static void dump_boot(DOS_FS * VAR_0, struct boot_sector *VAR_1, unsigned VAR_2)
{
    unsigned short VAR_3;

    printf(""Boot sector contents:\n"");
    if (!VAR_4) {
	char VAR_5[9];
	strncpy(VAR_5, (const char *)VAR_1->system_id, 8);
	VAR_5[8] = 0;
	printf(""System ID \""%s\""\n"", VAR_5);
    } else {
	/* COMMENT_0 */
             
	printf(""Serial number 0x%x\n"",
	       VAR_1->system_id[5] | (VAR_1->system_id[6] << 8) | (VAR_1->
							   system_id[7] << 16));
    }
    printf(""Media byte 0x%02x (%s)\n"", VAR_1->media, get_media_descr(VAR_1->media));
    printf(""%10d bytes per logical sector\n"", GET_UNALIGNED_W(VAR_1->sector_size));
    printf(""%10d bytes per cluster\n"", VAR_0->cluster_size);
    printf(""%10d reserved sector%s\n"", le16toh(VAR_1->reserved),
	   le16toh(VAR_1->reserved) == 1 ? """" : ""s"");
    printf(""First FAT starts at byte %llu (sector %llu)\n"",
	   (unsigned long long)VAR_0->fat_start,
	   (unsigned long long)VAR_0->fat_start / VAR_2);
    printf(""%10d FATs, %d bit entries\n"", VAR_1->fats, VAR_0->fat_bits);
    printf(""%10lld bytes per FAT (= %llu sectors)\n"", (long long)VAR_0->fat_size,
	   (long long)VAR_0->fat_size / VAR_2);
    if (!VAR_0->root_cluster) {
	printf(""Root directory starts at byte %llu (sector %llu)\n"",
	       (unsigned long long)VAR_0->root_start,
	       (unsigned long long)VAR_0->root_start / VAR_2);
	printf(""%10d root directory entries\n"", VAR_0->root_entries);
    } else {
	printf(""Root directory start at cluster %lu (arbitrary size)\n"",
	       (unsigned long)VAR_0->root_cluster);
    }
    printf(""Data area starts at byte %llu (sector %llu)\n"",
	   (unsigned long long)VAR_0->data_start,
	   (unsigned long long)VAR_0->data_start / VAR_2);
    printf(""%10lu data clusters (%llu bytes)\n"",
	   (unsigned long)VAR_0->data_clusters,
	   (unsigned long long)VAR_0->data_clusters * VAR_0->cluster_size);
    printf(""%u sectors/track, %u heads\n"", le16toh(VAR_1->secs_track),
	   le16toh(VAR_1->heads));
    printf(""%10u hidden sectors\n"", VAR_4 ?
	   /* COMMENT_2 */
	   (((unsigned char *)&VAR_1->hidden)[0] |
	    ((unsigned char *)&VAR_1->hidden)[1] << 8) : le32toh(VAR_1->hidden));
    VAR_3 = GET_UNALIGNED_W(VAR_1->sectors);
    printf(""%10u sectors total\n"", VAR_3 ? VAR_3 : le32toh(VAR_1->total_sect));
}",dosfstools/e8eff147e9da1185f9afd5b25948153a3b97cf52/boot.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -24,8 +24,8 @@
 	   (unsigned long long)fs->fat_start,
 	   (unsigned long long)fs->fat_start / lss);
     printf(""%10d FATs, %d bit entries\n"", b->fats, fs->fat_bits);
-    printf(""%10d bytes per FAT (= %u sectors)\n"", fs->fat_size,
-	   fs->fat_size / lss);
+    printf(""%10lld bytes per FAT (= %llu sectors)\n"", (long long)fs->fat_size,
+	   (long long)fs->fat_size / lss);
     if (!fs->root_cluster) {
 	printf(""Root directory starts at byte %llu (sector %llu)\n"",
 	       (unsigned long long)fs->root_start,","{'deleted_lines': ['    printf(""%10d bytes per FAT (= %u sectors)\\n"", fs->fat_size,', '\t   fs->fat_size / lss);'], 'added_lines': ['    printf(""%10lld bytes per FAT (= %llu sectors)\\n"", (long long)fs->fat_size,', '\t   (long long)fs->fat_size / lss);']}",True,"The read_boot function in boot.c in dosfstools before 4.0 allows attackers to cause a denial of service (crash) via a crafted filesystem, which triggers a heap-based buffer overflow in the (1) read_fat function or an out-of-bounds heap read in (2) get_fat function.",6.2,MEDIUM,1,test,2016-04-27T19:38:37Z,1
CVE-2016-4804,['CWE-119'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,dosfstools,"read_boot(): Handle excessive FAT size specifications

The variable used for storing the FAT size (in bytes) was an unsigned
int. Since the size in sectors read from the BPB was not sufficiently
checked, this could end up being zero after multiplying it with the
sector size while some offsets still stayed excessive. Ultimately it
would cause segfaults when accessing FAT entries for which no memory
was allocated.

Make it more robust by changing the types used to store FAT size to
off_t and abort if there is no room for data clusters. Additionally
check that FAT size is not specified as zero.

Fixes #25 and fixes #26.

Reported-by: Hanno Bck
Signed-off-by: Andreas Bombe <aeb@debian.org>",e8eff147e9da1185f9afd5b25948153a3b97cf52,https://github.com/dosfstools/dosfstools/commit/e8eff147e9da1185f9afd5b25948153a3b97cf52,src/boot.c,read_boot,"void read_boot(DOS_FS * fs)
{
struct boot_sector b;
unsigned total_sectors;
unsigned short logical_sector_size, sectors;
unsigned fat_length;
unsigned total_fat_entries;
off_t data_size;
fs_read(0, sizeof(b), &b);
logical_sector_size = GET_UNALIGNED_W(b.sector_size);
if (!logical_sector_size)
die(""Logical sector size is zero."");
if (logical_sector_size & (SECTOR_SIZE - 1))
die(""Logical sector size (%d bytes) is not a multiple of the physical ""
""sector size."", logical_sector_size);
fs->cluster_size = b.cluster_size * logical_sector_size;
if (!fs->cluster_size)
die(""Cluster size is zero."");
if (b.fats != 2 && b.fats != 1)
die(""Currently, only 1 or 2 FATs are supported, not %d.\n"", b.fats);
fs->nfats = b.fats;
sectors = GET_UNALIGNED_W(b.sectors);
total_sectors = sectors ? sectors : le32toh(b.total_sect);
if (verbose)
printf(""Checking we can access the last sector of the filesystem\n"");
fs_test((off_t)((total_sectors & ~1) - 1) * logical_sector_size,
logical_sector_size);
fat_length = le16toh(b.fat_length) ?
le16toh(b.fat_length) : le32toh(b.fat32_length);
fs->fat_start = (off_t)le16toh(b.reserved) * logical_sector_size;
fs->root_start = ((off_t)le16toh(b.reserved) + b.fats * fat_length) *
logical_sector_size;
fs->root_entries = GET_UNALIGNED_W(b.dir_entries);
fs->data_start = fs->root_start + ROUND_TO_MULTIPLE(fs->root_entries <<
MSDOS_DIR_BITS,
logical_sector_size);
data_size = (off_t)total_sectors * logical_sector_size - fs->data_start;
fs->data_clusters = data_size / fs->cluster_size;
fs->root_cluster = 0;
fs->fsinfo_start = 0;
fs->free_clusters = -1;
if (!b.fat_length && b.fat32_length) {
fs->fat_bits = 32;
fs->root_cluster = le32toh(b.root_cluster);
if (!fs->root_cluster && fs->root_entries)
printf(""Warning: FAT32 root dir not in cluster chain! ""
""Compatibility mode...\n"");
else if (!fs->root_cluster && !fs->root_entries)
die(""No root directory!"");
else if (fs->root_cluster && fs->root_entries)
printf(""Warning: FAT32 root dir is in a cluster chain, but ""
""a separate root dir\n""
""  area is defined. Cannot fix this easily.\n"");
if (fs->data_clusters < FAT16_THRESHOLD)
printf(""Warning: Filesystem is FAT32 according to fat_length ""
""and fat32_length fields,\n""
""  but has only %lu clusters, less than the required ""
""minimum of %d.\n""
""  This may lead to problems on some systems.\n"",
(unsigned long)fs->data_clusters, FAT16_THRESHOLD);
check_fat_state_bit(fs, &b);
fs->backupboot_start = le16toh(b.backup_boot) * logical_sector_size;
check_backup_boot(fs, &b, logical_sector_size);
read_fsinfo(fs, &b, logical_sector_size);
} else if (!atari_format) {
fs->fat_bits = (fs->data_clusters >= FAT12_THRESHOLD) ? 16 : 12;
if (fs->data_clusters >= FAT16_THRESHOLD)
die(""Too many clusters (%lu) for FAT16 filesystem."", fs->data_clusters);
check_fat_state_bit(fs, &b);
} else {
fs->fat_bits = 16;
if (fs->data_clusters + 2 > fat_length * logical_sector_size * 8 / 16 ||
(total_sectors == 720 || total_sectors == 1440 ||
total_sectors == 2880))
fs->fat_bits = 12;
}
fs->eff_fat_bits = (fs->fat_bits == 32) ? 28 : fs->fat_bits;
fs->fat_size = fat_length * logical_sector_size;
fs->label = calloc(12, sizeof(uint8_t));
if (fs->fat_bits == 12 || fs->fat_bits == 16) {
struct boot_sector_16 *b16 = (struct boot_sector_16 *)&b;
if (b16->extended_sig == 0x29)
memmove(fs->label, b16->label, 11);
else
fs->label = NULL;
} else if (fs->fat_bits == 32) {
if (b.extended_sig == 0x29)
memmove(fs->label, &b.label, 11);
else
fs->label = NULL;
}
total_fat_entries = (uint64_t)fs->fat_size * 8 / fs->fat_bits;
if (fs->data_clusters > total_fat_entries - 2)
die(""Filesystem has %u clusters but only space for %u FAT entries."",
fs->data_clusters, total_fat_entries - 2);
if (!fs->root_entries && !fs->root_cluster)
die(""Root directory has zero size."");
if (fs->root_entries & (MSDOS_DPS - 1))
die(""Root directory (%d entries) doesn't span an integral number of ""
""sectors."", fs->root_entries);
if (logical_sector_size & (SECTOR_SIZE - 1))
die(""Logical sector size (%d bytes) is not a multiple of the physical ""
""sector size."", logical_sector_size);
#if 0
if (!atari_format && (!b.secs_track || !b.heads))
die(""Invalid disk format in boot sector."");
#endif
if (verbose)
dump_boot(fs, &b, logical_sector_size);
}","void read_boot(DOS_FS * VAR_0)
{
struct boot_sector VAR_1;
unsigned VAR_2;
unsigned short VAR_3, VAR_4;
unsigned VAR_5;
unsigned VAR_6;
off_t VAR_7;
fs_read(0, sizeof(VAR_1), &VAR_1);
VAR_3 = GET_UNALIGNED_W(VAR_1.sector_size);
if (!VAR_3)
die(""Logical sector size is zero."");
if (VAR_3 & (VAR_8 - 1))
die(""Logical sector size (%d bytes) is not a multiple of the physical ""
""sector size."", VAR_3);
VAR_0->cluster_size = VAR_1.cluster_size * VAR_3;
if (!VAR_0->cluster_size)
die(""Cluster size is zero."");
if (VAR_1.fats != 2 && VAR_1.fats != 1)
die(""Currently, only 1 or 2 FATs are supported, not %d.\n"", VAR_1.fats);
VAR_0->nfats = VAR_1.fats;
VAR_4 = GET_UNALIGNED_W(VAR_1.sectors);
VAR_2 = VAR_4 ? VAR_4 : le32toh(VAR_1.total_sect);
if (VAR_9)
printf(""Checking we can access the last sector of the filesystem\n"");
fs_test((off_t)((VAR_2 & ~1) - 1) * VAR_3,
VAR_3);
VAR_5 = le16toh(VAR_1.fat_length) ?
le16toh(VAR_1.fat_length) : le32toh(VAR_1.fat32_length);
VAR_0->fat_start = (off_t)le16toh(VAR_1.reserved) * VAR_3;
VAR_0->root_start = ((off_t)le16toh(VAR_1.reserved) + VAR_1.fats * VAR_5) *
VAR_3;
VAR_0->root_entries = GET_UNALIGNED_W(VAR_1.dir_entries);
VAR_0->data_start = VAR_0->root_start + ROUND_TO_MULTIPLE(VAR_0->root_entries <<
VAR_10,
VAR_3);
VAR_7 = (off_t)VAR_2 * VAR_3 - VAR_0->data_start;
VAR_0->data_clusters = VAR_7 / VAR_0->cluster_size;
VAR_0->root_cluster = 0;
VAR_0->fsinfo_start = 0;
VAR_0->free_clusters = -1;
if (!VAR_1.fat_length && VAR_1.fat32_length) {
VAR_0->fat_bits = 32;
VAR_0->root_cluster = le32toh(VAR_1.root_cluster);
if (!VAR_0->root_cluster && VAR_0->root_entries)
printf(""Warning: FAT32 root dir not in cluster chain! ""
""Compatibility mode...\n"");
else if (!VAR_0->root_cluster && !VAR_0->root_entries)
die(""No root directory!"");
else if (VAR_0->root_cluster && VAR_0->root_entries)
printf(""Warning: FAT32 root dir is in a cluster chain, but ""
""a separate root dir\n""
""  area is defined. Cannot fix this easily.\n"");
if (VAR_0->data_clusters < VAR_11)
printf(""Warning: Filesystem is FAT32 according to fat_length ""
""and fat32_length fields,\n""
""  but has only %lu clusters, less than the required ""
""minimum of %d.\n""
""  This may lead to problems on some systems.\n"",
(unsigned long)VAR_0->data_clusters, VAR_11);
check_fat_state_bit(VAR_0, &VAR_1);
VAR_0->backupboot_start = le16toh(VAR_1.backup_boot) * VAR_3;
check_backup_boot(VAR_0, &VAR_1, VAR_3);
read_fsinfo(VAR_0, &VAR_1, VAR_3);
} else if (!VAR_12) {
VAR_0->fat_bits = (VAR_0->data_clusters >= VAR_13) ? 16 : 12;
if (VAR_0->data_clusters >= VAR_11)
die(""Too many clusters (%lu) for FAT16 filesystem."", VAR_0->data_clusters);
check_fat_state_bit(VAR_0, &VAR_1);
} else {
VAR_0->fat_bits = 16;
if (VAR_0->data_clusters + 2 > VAR_5 * VAR_3 * 8 / 16 ||
(VAR_2 == 720 || VAR_2 == 1440 ||
VAR_2 == 2880))
VAR_0->fat_bits = 12;
}
VAR_0->eff_fat_bits = (VAR_0->fat_bits == 32) ? 28 : VAR_0->fat_bits;
VAR_0->fat_size = VAR_5 * VAR_3;
VAR_0->label = calloc(12, sizeof(uint8_t));
if (VAR_0->fat_bits == 12 || VAR_0->fat_bits == 16) {
struct boot_sector_16 *VAR_14 = (struct boot_sector_16 *)&VAR_1;
if (VAR_14->extended_sig == 0x29)
memmove(VAR_0->label, VAR_14->label, 11);
else
VAR_0->label = NULL;
} else if (VAR_0->fat_bits == 32) {
if (VAR_1.extended_sig == 0x29)
memmove(VAR_0->label, &VAR_1.label, 11);
else
VAR_0->label = NULL;
}
VAR_6 = (uint64_t)VAR_0->fat_size * 8 / VAR_0->fat_bits;
if (VAR_0->data_clusters > VAR_6 - 2)
die(""Filesystem has %u clusters but only space for %u FAT entries."",
VAR_0->data_clusters, VAR_6 - 2);
if (!VAR_0->root_entries && !VAR_0->root_cluster)
die(""Root directory has zero size."");
if (VAR_0->root_entries & (VAR_15 - 1))
die(""Root directory (%d entries) doesn't span an integral number of ""
""sectors."", VAR_0->root_entries);
if (VAR_3 & (VAR_8 - 1))
die(""Logical sector size (%d bytes) is not a multiple of the physical ""
""sector size."", VAR_3);
#if 0
if (!VAR_12 && (!VAR_1.secs_track || !VAR_1.heads))
die(""Invalid disk format in boot sector."");
#endif
if (VAR_9)
dump_boot(VAR_0, &VAR_1, VAR_3);
}",dosfstools/e8eff147e9da1185f9afd5b25948153a3b97cf52/boot.c/vul/before/0.json,"void read_boot(DOS_FS * fs)
{
    struct boot_sector b;
    unsigned total_sectors;
    unsigned short logical_sector_size, sectors;
    off_t fat_length;
    unsigned total_fat_entries;
    off_t data_size;

    fs_read(0, sizeof(b), &b);
    logical_sector_size = GET_UNALIGNED_W(b.sector_size);
    if (!logical_sector_size)
	die(""Logical sector size is zero."");

    /* This was moved up because it's the first thing that will fail */
    /* if the platform needs special handling of unaligned multibyte accesses */
    /* but such handling isn't being provided. See GET_UNALIGNED_W() above. */
    if (logical_sector_size & (SECTOR_SIZE - 1))
	die(""Logical sector size (%d bytes) is not a multiple of the physical ""
	    ""sector size."", logical_sector_size);

    fs->cluster_size = b.cluster_size * logical_sector_size;
    if (!fs->cluster_size)
	die(""Cluster size is zero."");
    if (b.fats != 2 && b.fats != 1)
	die(""Currently, only 1 or 2 FATs are supported, not %d.\n"", b.fats);
    fs->nfats = b.fats;
    sectors = GET_UNALIGNED_W(b.sectors);
    total_sectors = sectors ? sectors : le32toh(b.total_sect);
    if (verbose)
	printf(""Checking we can access the last sector of the filesystem\n"");
    /* Can't access last odd sector anyway, so round down */
    fs_test((off_t)((total_sectors & ~1) - 1) * logical_sector_size,
	    logical_sector_size);

    fat_length = le16toh(b.fat_length) ?
	le16toh(b.fat_length) : le32toh(b.fat32_length);
    if (!fat_length)
	die(""FAT size is zero."");

    fs->fat_start = (off_t)le16toh(b.reserved) * logical_sector_size;
    fs->root_start = ((off_t)le16toh(b.reserved) + b.fats * fat_length) *
	logical_sector_size;
    fs->root_entries = GET_UNALIGNED_W(b.dir_entries);
    fs->data_start = fs->root_start + ROUND_TO_MULTIPLE(fs->root_entries <<
							MSDOS_DIR_BITS,
							logical_sector_size);

    data_size = (off_t)total_sectors * logical_sector_size - fs->data_start;
    if (data_size < fs->cluster_size)
	die(""Filesystem has no space for any data clusters"");

    fs->data_clusters = data_size / fs->cluster_size;
    fs->root_cluster = 0;	/* indicates standard, pre-FAT32 root dir */
    fs->fsinfo_start = 0;	/* no FSINFO structure */
    fs->free_clusters = -1;	/* unknown */
    if (!b.fat_length && b.fat32_length) {
	fs->fat_bits = 32;
	fs->root_cluster = le32toh(b.root_cluster);
	if (!fs->root_cluster && fs->root_entries)
	    /* M$ hasn't specified this, but it looks reasonable: If
	     * root_cluster is 0 but there is a separate root dir
	     * (root_entries != 0), we handle the root dir the old way. Give a
	     * warning, but convertig to a root dir in a cluster chain seems
	     * to complex for now... */
	    printf(""Warning: FAT32 root dir not in cluster chain! ""
		   ""Compatibility mode...\n"");
	else if (!fs->root_cluster && !fs->root_entries)
	    die(""No root directory!"");
	else if (fs->root_cluster && fs->root_entries)
	    printf(""Warning: FAT32 root dir is in a cluster chain, but ""
		   ""a separate root dir\n""
		   ""  area is defined. Cannot fix this easily.\n"");
	if (fs->data_clusters < FAT16_THRESHOLD)
	    printf(""Warning: Filesystem is FAT32 according to fat_length ""
		   ""and fat32_length fields,\n""
		   ""  but has only %lu clusters, less than the required ""
		   ""minimum of %d.\n""
		   ""  This may lead to problems on some systems.\n"",
		   (unsigned long)fs->data_clusters, FAT16_THRESHOLD);

	check_fat_state_bit(fs, &b);
	fs->backupboot_start = le16toh(b.backup_boot) * logical_sector_size;
	check_backup_boot(fs, &b, logical_sector_size);

	read_fsinfo(fs, &b, logical_sector_size);
    } else if (!atari_format) {
	/* On real MS-DOS, a 16 bit FAT is used whenever there would be too
	 * much clusers otherwise. */
	fs->fat_bits = (fs->data_clusters >= FAT12_THRESHOLD) ? 16 : 12;
	if (fs->data_clusters >= FAT16_THRESHOLD)
	    die(""Too many clusters (%lu) for FAT16 filesystem."", fs->data_clusters);
	check_fat_state_bit(fs, &b);
    } else {
	/* On Atari, things are more difficult: GEMDOS always uses 12bit FATs
	 * on floppies, and always 16 bit on harddisks. */
	fs->fat_bits = 16;	/* assume 16 bit FAT for now */
	/* If more clusters than fat entries in 16-bit fat, we assume
	 * it's a real MSDOS FS with 12-bit fat. */
	if (fs->data_clusters + 2 > fat_length * logical_sector_size * 8 / 16 ||
	    /* if it has one of the usual floppy sizes -> 12bit FAT  */
	    (total_sectors == 720 || total_sectors == 1440 ||
	     total_sectors == 2880))
	    fs->fat_bits = 12;
    }
    /* On FAT32, the high 4 bits of a FAT entry are reserved */
    fs->eff_fat_bits = (fs->fat_bits == 32) ? 28 : fs->fat_bits;
    fs->fat_size = fat_length * logical_sector_size;

    fs->label = calloc(12, sizeof(uint8_t));
    if (fs->fat_bits == 12 || fs->fat_bits == 16) {
	struct boot_sector_16 *b16 = (struct boot_sector_16 *)&b;
	if (b16->extended_sig == 0x29)
	    memmove(fs->label, b16->label, 11);
	else
	    fs->label = NULL;
    } else if (fs->fat_bits == 32) {
	if (b.extended_sig == 0x29)
	    memmove(fs->label, &b.label, 11);
	else
	    fs->label = NULL;
    }

    total_fat_entries = (uint64_t)fs->fat_size * 8 / fs->fat_bits;
    if (fs->data_clusters > total_fat_entries - 2)
	die(""Filesystem has %u clusters but only space for %u FAT entries."",
	    fs->data_clusters, total_fat_entries - 2);
    if (!fs->root_entries && !fs->root_cluster)
	die(""Root directory has zero size."");
    if (fs->root_entries & (MSDOS_DPS - 1))
	die(""Root directory (%d entries) doesn't span an integral number of ""
	    ""sectors."", fs->root_entries);
    if (logical_sector_size & (SECTOR_SIZE - 1))
	die(""Logical sector size (%d bytes) is not a multiple of the physical ""
	    ""sector size."", logical_sector_size);
#if 0				/* linux kernel doesn't check that either */
    /* ++roman: On Atari, these two fields are often left uninitialized */
    if (!atari_format && (!b.secs_track || !b.heads))
	die(""Invalid disk format in boot sector."");
#endif
    if (verbose)
	dump_boot(fs, &b, logical_sector_size);
}","void read_boot(DOS_FS * VAR_0)
{
    struct boot_sector VAR_1;
    unsigned VAR_2;
    unsigned short VAR_3, VAR_4;
    off_t VAR_5;
    unsigned VAR_6;
    off_t VAR_7;

    fs_read(0, sizeof(VAR_1), &VAR_1);
    VAR_3 = GET_UNALIGNED_W(VAR_1.sector_size);
    if (!VAR_3)
	die(""Logical sector size is zero."");

    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    if (VAR_3 & (VAR_8 - 1))
	die(""Logical sector size (%d bytes) is not a multiple of the physical ""
	    ""sector size."", VAR_3);

    VAR_0->cluster_size = VAR_1.cluster_size * VAR_3;
    if (!VAR_0->cluster_size)
	die(""Cluster size is zero."");
    if (VAR_1.fats != 2 && VAR_1.fats != 1)
	die(""Currently, only 1 or 2 FATs are supported, not %d.\n"", VAR_1.fats);
    VAR_0->nfats = VAR_1.fats;
    VAR_4 = GET_UNALIGNED_W(VAR_1.sectors);
    VAR_2 = VAR_4 ? VAR_4 : le32toh(VAR_1.total_sect);
    if (VAR_9)
	printf(""Checking we can access the last sector of the filesystem\n"");
    /* COMMENT_3 */
    fs_test((off_t)((VAR_2 & ~1) - 1) * VAR_3,
	    VAR_3);

    VAR_5 = le16toh(VAR_1.fat_length) ?
	le16toh(VAR_1.fat_length) : le32toh(VAR_1.fat32_length);
    if (!VAR_5)
	die(""FAT size is zero."");

    VAR_0->fat_start = (off_t)le16toh(VAR_1.reserved) * VAR_3;
    VAR_0->root_start = ((off_t)le16toh(VAR_1.reserved) + VAR_1.fats * VAR_5) *
	VAR_3;
    VAR_0->root_entries = GET_UNALIGNED_W(VAR_1.dir_entries);
    VAR_0->data_start = VAR_0->root_start + ROUND_TO_MULTIPLE(VAR_0->root_entries <<
							VAR_10,
							VAR_3);

    VAR_7 = (off_t)VAR_2 * VAR_3 - VAR_0->data_start;
    if (VAR_7 < VAR_0->cluster_size)
	die(""Filesystem has no space for any data clusters"");

    VAR_0->data_clusters = VAR_7 / VAR_0->cluster_size;
    VAR_0->root_cluster = 0;	/* COMMENT_4 */
    VAR_0->fsinfo_start = 0;	/* COMMENT_5 */
    VAR_0->free_clusters = -1;	/* COMMENT_6 */
    if (!VAR_1.fat_length && VAR_1.fat32_length) {
	VAR_0->fat_bits = 32;
	VAR_0->root_cluster = le32toh(VAR_1.root_cluster);
	if (!VAR_0->root_cluster && VAR_0->root_entries)
	    /* COMMENT_7 */
                                                          
                                                                       
                                                                     
                                
	    printf(""Warning: FAT32 root dir not in cluster chain! ""
		   ""Compatibility mode...\n"");
	else if (!VAR_0->root_cluster && !VAR_0->root_entries)
	    die(""No root directory!"");
	else if (VAR_0->root_cluster && VAR_0->root_entries)
	    printf(""Warning: FAT32 root dir is in a cluster chain, but ""
		   ""a separate root dir\n""
		   ""  area is defined. Cannot fix this easily.\n"");
	if (VAR_0->data_clusters < VAR_11)
	    printf(""Warning: Filesystem is FAT32 according to fat_length ""
		   ""and fat32_length fields,\n""
		   ""  but has only %lu clusters, less than the required ""
		   ""minimum of %d.\n""
		   ""  This may lead to problems on some systems.\n"",
		   (unsigned long)VAR_0->data_clusters, VAR_11);

	check_fat_state_bit(VAR_0, &VAR_1);
	VAR_0->backupboot_start = le16toh(VAR_1.backup_boot) * VAR_3;
	check_backup_boot(VAR_0, &VAR_1, VAR_3);

	read_fsinfo(VAR_0, &VAR_1, VAR_3);
    } else if (!VAR_12) {
	/* COMMENT_12 */
                              
	VAR_0->fat_bits = (VAR_0->data_clusters >= VAR_13) ? 16 : 12;
	if (VAR_0->data_clusters >= VAR_11)
	    die(""Too many clusters (%lu) for FAT16 filesystem."", VAR_0->data_clusters);
	check_fat_state_bit(VAR_0, &VAR_1);
    } else {
	/* COMMENT_14 */
                                                   
	VAR_0->fat_bits = 16;	/* COMMENT_16 */
	/* COMMENT_17 */
                                            
	if (VAR_0->data_clusters + 2 > VAR_5 * VAR_3 * 8 / 16 ||
	    /* COMMENT_19 */
	    (VAR_2 == 720 || VAR_2 == 1440 ||
	     VAR_2 == 2880))
	    VAR_0->fat_bits = 12;
    }
    /* COMMENT_20 */
    VAR_0->eff_fat_bits = (VAR_0->fat_bits == 32) ? 28 : VAR_0->fat_bits;
    VAR_0->fat_size = VAR_5 * VAR_3;

    VAR_0->label = calloc(12, sizeof(uint8_t));
    if (VAR_0->fat_bits == 12 || VAR_0->fat_bits == 16) {
	struct boot_sector_16 *VAR_14 = (struct boot_sector_16 *)&VAR_1;
	if (VAR_14->extended_sig == 0x29)
	    memmove(VAR_0->label, VAR_14->label, 11);
	else
	    VAR_0->label = NULL;
    } else if (VAR_0->fat_bits == 32) {
	if (VAR_1.extended_sig == 0x29)
	    memmove(VAR_0->label, &VAR_1.label, 11);
	else
	    VAR_0->label = NULL;
    }

    VAR_6 = (uint64_t)VAR_0->fat_size * 8 / VAR_0->fat_bits;
    if (VAR_0->data_clusters > VAR_6 - 2)
	die(""Filesystem has %u clusters but only space for %u FAT entries."",
	    VAR_0->data_clusters, VAR_6 - 2);
    if (!VAR_0->root_entries && !VAR_0->root_cluster)
	die(""Root directory has zero size."");
    if (VAR_0->root_entries & (VAR_15 - 1))
	die(""Root directory (%d entries) doesn't span an integral number of ""
	    ""sectors."", VAR_0->root_entries);
    if (VAR_3 & (VAR_8 - 1))
	die(""Logical sector size (%d bytes) is not a multiple of the physical ""
	    ""sector size."", VAR_3);
#if 0				/* COMMENT_21 */
    /* COMMENT_22 */
    if (!VAR_12 && (!VAR_1.secs_track || !VAR_1.heads))
	die(""Invalid disk format in boot sector."");
#endif
    if (VAR_9)
	dump_boot(VAR_0, &VAR_1, VAR_3);
}",dosfstools/e8eff147e9da1185f9afd5b25948153a3b97cf52/boot.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
     struct boot_sector b;
     unsigned total_sectors;
     unsigned short logical_sector_size, sectors;
-    unsigned fat_length;
+    off_t fat_length;
     unsigned total_fat_entries;
     off_t data_size;
 
@@ -32,8 +32,12 @@
     /* Can't access last odd sector anyway, so round down */
     fs_test((off_t)((total_sectors & ~1) - 1) * logical_sector_size,
 	    logical_sector_size);
+
     fat_length = le16toh(b.fat_length) ?
 	le16toh(b.fat_length) : le32toh(b.fat32_length);
+    if (!fat_length)
+	die(""FAT size is zero."");
+
     fs->fat_start = (off_t)le16toh(b.reserved) * logical_sector_size;
     fs->root_start = ((off_t)le16toh(b.reserved) + b.fats * fat_length) *
 	logical_sector_size;
@@ -41,7 +45,11 @@
     fs->data_start = fs->root_start + ROUND_TO_MULTIPLE(fs->root_entries <<
 							MSDOS_DIR_BITS,
 							logical_sector_size);
+
     data_size = (off_t)total_sectors * logical_sector_size - fs->data_start;
+    if (data_size < fs->cluster_size)
+	die(""Filesystem has no space for any data clusters"");
+
     fs->data_clusters = data_size / fs->cluster_size;
     fs->root_cluster = 0;	/* indicates standard, pre-FAT32 root dir */
     fs->fsinfo_start = 0;	/* no FSINFO structure */","{'deleted_lines': ['    unsigned fat_length;'], 'added_lines': ['    off_t fat_length;', '', '    if (!fat_length)', '\tdie(""FAT size is zero."");', '', '', '    if (data_size < fs->cluster_size)', '\tdie(""Filesystem has no space for any data clusters"");', '']}",True,"The read_boot function in boot.c in dosfstools before 4.0 allows attackers to cause a denial of service (crash) via a crafted filesystem, which triggers a heap-based buffer overflow in the (1) read_fat function or an out-of-bounds heap read in (2) get_fat function.",6.2,MEDIUM,1,test,2016-04-27T19:38:37Z,1
CVE-2016-4558,['CWE-Other'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"bpf: fix refcnt overflow

On a system with >32Gbyte of phyiscal memory and infinite RLIMIT_MEMLOCK,
the malicious application may overflow 32-bit bpf program refcnt.
It's also possible to overflow map refcnt on 1Tb system.
Impose 32k hard limit which means that the same bpf program or
map cannot be shared by more than 32k processes.

Fixes: 1be7f75d1668 (""bpf: enable non-root eBPF programs"")
Reported-by: Jann Horn <jannh@google.com>
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Acked-by: Daniel Borkmann <daniel@iogearbox.net>
Signed-off-by: David S. Miller <davem@davemloft.net>",92117d8443bc5afacc8d5ba82e541946310f106e,https://github.com/torvalds/linux/commit/92117d8443bc5afacc8d5ba82e541946310f106e,kernel/bpf/syscall.c,bpf_prog_get,"struct bpf_prog *bpf_prog_get(u32 ufd)
{
struct fd f = fdget(ufd);
struct bpf_prog *prog;
prog = __bpf_prog_get(f);
if (IS_ERR(prog))
return prog;
atomic_inc(&prog->aux->refcnt);
fdput(f);
return prog;
}","struct bpf_prog *bpf_prog_get(u32 VAR_0)
{
struct fd VAR_1 = fdget(VAR_0);
struct bpf_prog *VAR_2;
VAR_2 = __bpf_prog_get(VAR_1);
if (IS_ERR(VAR_2))
return VAR_2;
atomic_inc(&VAR_2->aux->refcnt);
fdput(VAR_1);
return VAR_2;
}",torvalds/linux/92117d8443bc5afacc8d5ba82e541946310f106e/syscall.c/vul/before/2.json,"struct bpf_prog *bpf_prog_get(u32 ufd)
{
	struct fd f = fdget(ufd);
	struct bpf_prog *prog;

	prog = __bpf_prog_get(f);
	if (IS_ERR(prog))
		return prog;

	prog = bpf_prog_inc(prog);
	fdput(f);

	return prog;
}","struct bpf_prog *bpf_prog_get(u32 VAR_0)
{
	struct fd VAR_1 = fdget(VAR_0);
	struct bpf_prog *VAR_2;

	VAR_2 = __bpf_prog_get(VAR_1);
	if (IS_ERR(VAR_2))
		return VAR_2;

	VAR_2 = bpf_prog_inc(VAR_2);
	fdput(VAR_1);

	return VAR_2;
}",torvalds/linux/92117d8443bc5afacc8d5ba82e541946310f106e/syscall.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
 	if (IS_ERR(prog))
 		return prog;
 
-	atomic_inc(&prog->aux->refcnt);
+	prog = bpf_prog_inc(prog);
 	fdput(f);
 
 	return prog;","{'deleted_lines': ['\tatomic_inc(&prog->aux->refcnt);'], 'added_lines': ['\tprog = bpf_prog_inc(prog);']}",True,"The BPF subsystem in the Linux kernel before 4.5.5 mishandles reference counts, which allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted application on (1) a system with more than 32 Gb of memory, related to the program reference count or (2) a 1 Tb system, related to the map reference count.",7.0,HIGH,2,test,2016-04-28T01:56:20Z,1
CVE-2016-4558,['CWE-Other'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"bpf: fix refcnt overflow

On a system with >32Gbyte of phyiscal memory and infinite RLIMIT_MEMLOCK,
the malicious application may overflow 32-bit bpf program refcnt.
It's also possible to overflow map refcnt on 1Tb system.
Impose 32k hard limit which means that the same bpf program or
map cannot be shared by more than 32k processes.

Fixes: 1be7f75d1668 (""bpf: enable non-root eBPF programs"")
Reported-by: Jann Horn <jannh@google.com>
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Acked-by: Daniel Borkmann <daniel@iogearbox.net>
Signed-off-by: David S. Miller <davem@davemloft.net>",92117d8443bc5afacc8d5ba82e541946310f106e,https://github.com/torvalds/linux/commit/92117d8443bc5afacc8d5ba82e541946310f106e,kernel/bpf/syscall.c,bpf_map_get_with_uref,"struct bpf_map *bpf_map_get_with_uref(u32 ufd)
{
struct fd f = fdget(ufd);
struct bpf_map *map;
map = __bpf_map_get(f);
if (IS_ERR(map))
return map;
bpf_map_inc(map, true);
fdput(f);
return map;
}","struct bpf_map *bpf_map_get_with_uref(u32 VAR_0)
{
struct fd VAR_1 = fdget(VAR_0);
struct bpf_map *VAR_2;
VAR_2 = __bpf_map_get(VAR_1);
if (IS_ERR(VAR_2))
return VAR_2;
bpf_map_inc(VAR_2, true);
fdput(VAR_1);
return VAR_2;
}",torvalds/linux/92117d8443bc5afacc8d5ba82e541946310f106e/syscall.c/vul/before/1.json,"struct bpf_map *bpf_map_get_with_uref(u32 ufd)
{
	struct fd f = fdget(ufd);
	struct bpf_map *map;

	map = __bpf_map_get(f);
	if (IS_ERR(map))
		return map;

	map = bpf_map_inc(map, true);
	fdput(f);

	return map;
}","struct bpf_map *bpf_map_get_with_uref(u32 VAR_0)
{
	struct fd VAR_1 = fdget(VAR_0);
	struct bpf_map *VAR_2;

	VAR_2 = __bpf_map_get(VAR_1);
	if (IS_ERR(VAR_2))
		return VAR_2;

	VAR_2 = bpf_map_inc(VAR_2, true);
	fdput(VAR_1);

	return VAR_2;
}",torvalds/linux/92117d8443bc5afacc8d5ba82e541946310f106e/syscall.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
 	if (IS_ERR(map))
 		return map;
 
-	bpf_map_inc(map, true);
+	map = bpf_map_inc(map, true);
 	fdput(f);
 
 	return map;","{'deleted_lines': ['\tbpf_map_inc(map, true);'], 'added_lines': ['\tmap = bpf_map_inc(map, true);']}",True,"The BPF subsystem in the Linux kernel before 4.5.5 mishandles reference counts, which allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted application on (1) a system with more than 32 Gb of memory, related to the program reference count or (2) a 1 Tb system, related to the map reference count.",7.0,HIGH,2,test,2016-04-28T01:56:20Z,1
CVE-2016-4558,['CWE-Other'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"bpf: fix refcnt overflow

On a system with >32Gbyte of phyiscal memory and infinite RLIMIT_MEMLOCK,
the malicious application may overflow 32-bit bpf program refcnt.
It's also possible to overflow map refcnt on 1Tb system.
Impose 32k hard limit which means that the same bpf program or
map cannot be shared by more than 32k processes.

Fixes: 1be7f75d1668 (""bpf: enable non-root eBPF programs"")
Reported-by: Jann Horn <jannh@google.com>
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Acked-by: Daniel Borkmann <daniel@iogearbox.net>
Signed-off-by: David S. Miller <davem@davemloft.net>",92117d8443bc5afacc8d5ba82e541946310f106e,https://github.com/torvalds/linux/commit/92117d8443bc5afacc8d5ba82e541946310f106e,kernel/bpf/syscall.c,bpf_map_inc,"void bpf_map_inc(struct bpf_map *map, bool uref)
{
atomic_inc(&map->refcnt);
if (uref)
atomic_inc(&map->usercnt);
}","void bpf_map_inc(struct bpf_map *VAR_0, bool VAR_1)
{
atomic_inc(&VAR_0->refcnt);
if (VAR_1)
atomic_inc(&VAR_0->usercnt);
}",torvalds/linux/92117d8443bc5afacc8d5ba82e541946310f106e/syscall.c/vul/before/0.json,"struct bpf_map *bpf_map_inc(struct bpf_map *map, bool uref)
{
	if (atomic_inc_return(&map->refcnt) > BPF_MAX_REFCNT) {
		atomic_dec(&map->refcnt);
		return ERR_PTR(-EBUSY);
	}
	if (uref)
		atomic_inc(&map->usercnt);
	return map;
}","struct bpf_map *bpf_map_inc(struct bpf_map *VAR_0, bool VAR_1)
{
	if (atomic_inc_return(&VAR_0->refcnt) > VAR_2) {
		atomic_dec(&VAR_0->refcnt);
		return ERR_PTR(-VAR_3);
	}
	if (VAR_1)
		atomic_inc(&VAR_0->usercnt);
	return VAR_0;
}",torvalds/linux/92117d8443bc5afacc8d5ba82e541946310f106e/syscall.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,10 @@
-void bpf_map_inc(struct bpf_map *map, bool uref)
+struct bpf_map *bpf_map_inc(struct bpf_map *map, bool uref)
 {
-	atomic_inc(&map->refcnt);
+	if (atomic_inc_return(&map->refcnt) > BPF_MAX_REFCNT) {
+		atomic_dec(&map->refcnt);
+		return ERR_PTR(-EBUSY);
+	}
 	if (uref)
 		atomic_inc(&map->usercnt);
+	return map;
 }","{'deleted_lines': ['void bpf_map_inc(struct bpf_map *map, bool uref)', '\tatomic_inc(&map->refcnt);'], 'added_lines': ['struct bpf_map *bpf_map_inc(struct bpf_map *map, bool uref)', '\tif (atomic_inc_return(&map->refcnt) > BPF_MAX_REFCNT) {', '\t\tatomic_dec(&map->refcnt);', '\t\treturn ERR_PTR(-EBUSY);', '\t}', '\treturn map;']}",True,"The BPF subsystem in the Linux kernel before 4.5.5 mishandles reference counts, which allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted application on (1) a system with more than 32 Gb of memory, related to the program reference count or (2) a 1 Tb system, related to the map reference count.",7.0,HIGH,2,test,2016-04-28T01:56:20Z,1
CVE-2016-4558,['CWE-Other'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"bpf: fix refcnt overflow

On a system with >32Gbyte of phyiscal memory and infinite RLIMIT_MEMLOCK,
the malicious application may overflow 32-bit bpf program refcnt.
It's also possible to overflow map refcnt on 1Tb system.
Impose 32k hard limit which means that the same bpf program or
map cannot be shared by more than 32k processes.

Fixes: 1be7f75d1668 (""bpf: enable non-root eBPF programs"")
Reported-by: Jann Horn <jannh@google.com>
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Acked-by: Daniel Borkmann <daniel@iogearbox.net>
Signed-off-by: David S. Miller <davem@davemloft.net>",92117d8443bc5afacc8d5ba82e541946310f106e,https://github.com/torvalds/linux/commit/92117d8443bc5afacc8d5ba82e541946310f106e,kernel/bpf/inode.c,bpf_obj_do_get,"static void *bpf_obj_do_get(const struct filename *pathname,
enum bpf_type *type)
{
struct inode *inode;
struct path path;
void *raw;
int ret;
ret = kern_path(pathname->name, LOOKUP_FOLLOW, &path);
if (ret)
return ERR_PTR(ret);
inode = d_backing_inode(path.dentry);
ret = inode_permission(inode, MAY_WRITE);
if (ret)
goto out;
ret = bpf_inode_type(inode, type);
if (ret)
goto out;
raw = bpf_any_get(inode->i_private, *type);
touch_atime(&path);
path_put(&path);
return raw;
out:
path_put(&path);
return ERR_PTR(ret);
}","static void *bpf_obj_do_get(const struct filename *VAR_0,
enum bpf_type *VAR_1)
{
struct inode *inode;
struct path path;
void *VAR_2;
int VAR_3;
VAR_3 = kern_path(VAR_0->name, VAR_4, &path);
if (VAR_3)
return ERR_PTR(VAR_3);
inode = d_backing_inode(path.dentry);
VAR_3 = inode_permission(inode, VAR_5);
if (VAR_3)
goto out;
VAR_3 = bpf_inode_type(inode, VAR_1);
if (VAR_3)
goto out;
VAR_2 = bpf_any_get(inode->i_private, *VAR_1);
touch_atime(&path);
path_put(&path);
return VAR_2;
out:
path_put(&path);
return ERR_PTR(VAR_3);
}",torvalds/linux/92117d8443bc5afacc8d5ba82e541946310f106e/inode.c/vul/before/0.json,"static void *bpf_obj_do_get(const struct filename *pathname,
			    enum bpf_type *type)
{
	struct inode *inode;
	struct path path;
	void *raw;
	int ret;

	ret = kern_path(pathname->name, LOOKUP_FOLLOW, &path);
	if (ret)
		return ERR_PTR(ret);

	inode = d_backing_inode(path.dentry);
	ret = inode_permission(inode, MAY_WRITE);
	if (ret)
		goto out;

	ret = bpf_inode_type(inode, type);
	if (ret)
		goto out;

	raw = bpf_any_get(inode->i_private, *type);
	if (!IS_ERR(raw))
		touch_atime(&path);

	path_put(&path);
	return raw;
out:
	path_put(&path);
	return ERR_PTR(ret);
}","static void *bpf_obj_do_get(const struct filename *VAR_0,
			    enum bpf_type *VAR_1)
{
	struct inode *inode;
	struct path path;
	void *VAR_2;
	int VAR_3;

	VAR_3 = kern_path(VAR_0->name, VAR_4, &path);
	if (VAR_3)
		return ERR_PTR(VAR_3);

	inode = d_backing_inode(path.dentry);
	VAR_3 = inode_permission(inode, VAR_5);
	if (VAR_3)
		goto out;

	VAR_3 = bpf_inode_type(inode, VAR_1);
	if (VAR_3)
		goto out;

	VAR_2 = bpf_any_get(inode->i_private, *VAR_1);
	if (!IS_ERR(VAR_2))
		touch_atime(&path);

	path_put(&path);
	return VAR_2;
out:
	path_put(&path);
	return ERR_PTR(VAR_3);
}",torvalds/linux/92117d8443bc5afacc8d5ba82e541946310f106e/inode.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -20,7 +20,8 @@
 		goto out;
 
 	raw = bpf_any_get(inode->i_private, *type);
-	touch_atime(&path);
+	if (!IS_ERR(raw))
+		touch_atime(&path);
 
 	path_put(&path);
 	return raw;","{'deleted_lines': ['\ttouch_atime(&path);'], 'added_lines': ['\tif (!IS_ERR(raw))', '\t\ttouch_atime(&path);']}",True,"The BPF subsystem in the Linux kernel before 4.5.5 mishandles reference counts, which allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted application on (1) a system with more than 32 Gb of memory, related to the program reference count or (2) a 1 Tb system, related to the map reference count.",7.0,HIGH,2,test,2016-04-28T01:56:20Z,1
CVE-2016-4558,['CWE-Other'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"bpf: fix refcnt overflow

On a system with >32Gbyte of phyiscal memory and infinite RLIMIT_MEMLOCK,
the malicious application may overflow 32-bit bpf program refcnt.
It's also possible to overflow map refcnt on 1Tb system.
Impose 32k hard limit which means that the same bpf program or
map cannot be shared by more than 32k processes.

Fixes: 1be7f75d1668 (""bpf: enable non-root eBPF programs"")
Reported-by: Jann Horn <jannh@google.com>
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Acked-by: Daniel Borkmann <daniel@iogearbox.net>
Signed-off-by: David S. Miller <davem@davemloft.net>",92117d8443bc5afacc8d5ba82e541946310f106e,https://github.com/torvalds/linux/commit/92117d8443bc5afacc8d5ba82e541946310f106e,kernel/bpf/inode.c,bpf_any_get,"static void *bpf_any_get(void *raw, enum bpf_type type)
{
switch (type) {
case BPF_TYPE_PROG:
atomic_inc(&((struct bpf_prog *)raw)->aux->refcnt);
break;
case BPF_TYPE_MAP:
bpf_map_inc(raw, true);
break;
default:
WARN_ON_ONCE(1);
break;
}
return raw;
}","static void *bpf_any_get(void *VAR_0, enum bpf_type VAR_1)
{
switch (VAR_1) {
case VAR_2:
atomic_inc(&((struct bpf_prog *)VAR_0)->aux->refcnt);
break;
case VAR_3:
bpf_map_inc(VAR_0, true);
break;
default:
WARN_ON_ONCE(1);
break;
}
return VAR_0;
}",torvalds/linux/92117d8443bc5afacc8d5ba82e541946310f106e/inode.c/vul/before/1.json,"static void *bpf_any_get(void *raw, enum bpf_type type)
{
	switch (type) {
	case BPF_TYPE_PROG:
		raw = bpf_prog_inc(raw);
		break;
	case BPF_TYPE_MAP:
		raw = bpf_map_inc(raw, true);
		break;
	default:
		WARN_ON_ONCE(1);
		break;
	}

	return raw;
}","static void *bpf_any_get(void *VAR_0, enum bpf_type VAR_1)
{
	switch (VAR_1) {
	case VAR_2:
		VAR_0 = bpf_prog_inc(VAR_0);
		break;
	case VAR_3:
		VAR_0 = bpf_map_inc(VAR_0, true);
		break;
	default:
		WARN_ON_ONCE(1);
		break;
	}

	return VAR_0;
}",torvalds/linux/92117d8443bc5afacc8d5ba82e541946310f106e/inode.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,10 +2,10 @@
 {
 	switch (type) {
 	case BPF_TYPE_PROG:
-		atomic_inc(&((struct bpf_prog *)raw)->aux->refcnt);
+		raw = bpf_prog_inc(raw);
 		break;
 	case BPF_TYPE_MAP:
-		bpf_map_inc(raw, true);
+		raw = bpf_map_inc(raw, true);
 		break;
 	default:
 		WARN_ON_ONCE(1);","{'deleted_lines': ['\t\tatomic_inc(&((struct bpf_prog *)raw)->aux->refcnt);', '\t\tbpf_map_inc(raw, true);'], 'added_lines': ['\t\traw = bpf_prog_inc(raw);', '\t\traw = bpf_map_inc(raw, true);']}",True,"The BPF subsystem in the Linux kernel before 4.5.5 mishandles reference counts, which allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted application on (1) a system with more than 32 Gb of memory, related to the program reference count or (2) a 1 Tb system, related to the map reference count.",7.0,HIGH,2,test,2016-04-28T01:56:20Z,1
CVE-2016-4558,['CWE-Other'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"bpf: fix refcnt overflow

On a system with >32Gbyte of phyiscal memory and infinite RLIMIT_MEMLOCK,
the malicious application may overflow 32-bit bpf program refcnt.
It's also possible to overflow map refcnt on 1Tb system.
Impose 32k hard limit which means that the same bpf program or
map cannot be shared by more than 32k processes.

Fixes: 1be7f75d1668 (""bpf: enable non-root eBPF programs"")
Reported-by: Jann Horn <jannh@google.com>
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Acked-by: Daniel Borkmann <daniel@iogearbox.net>
Signed-off-by: David S. Miller <davem@davemloft.net>",92117d8443bc5afacc8d5ba82e541946310f106e,https://github.com/torvalds/linux/commit/92117d8443bc5afacc8d5ba82e541946310f106e,kernel/bpf/verifier.c,replace_map_fd_with_map_ptr,"static int replace_map_fd_with_map_ptr(struct verifier_env *env)
{
struct bpf_insn *insn = env->prog->insnsi;
int insn_cnt = env->prog->len;
int i, j;
for (i = 0; i < insn_cnt; i++, insn++) {
if (BPF_CLASS(insn->code) == BPF_LDX &&
(BPF_MODE(insn->code) != BPF_MEM || insn->imm != 0)) {
verbose(""BPF_LDX uses reserved fields\n"");
return -EINVAL;
}
if (BPF_CLASS(insn->code) == BPF_STX &&
((BPF_MODE(insn->code) != BPF_MEM &&
BPF_MODE(insn->code) != BPF_XADD) || insn->imm != 0)) {
verbose(""BPF_STX uses reserved fields\n"");
return -EINVAL;
}
if (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW)) {
struct bpf_map *map;
struct fd f;
if (i == insn_cnt - 1 || insn[1].code != 0 ||
insn[1].dst_reg != 0 || insn[1].src_reg != 0 ||
insn[1].off != 0) {
verbose(""invalid bpf_ld_imm64 insn\n"");
return -EINVAL;
}
if (insn->src_reg == 0)
goto next_insn;
if (insn->src_reg != BPF_PSEUDO_MAP_FD) {
verbose(""unrecognized bpf_ld_imm64 insn\n"");
return -EINVAL;
}
f = fdget(insn->imm);
map = __bpf_map_get(f);
if (IS_ERR(map)) {
verbose(""fd %d is not pointing to valid bpf_map\n"",
insn->imm);
return PTR_ERR(map);
}
insn[0].imm = (u32) (unsigned long) map;
insn[1].imm = ((u64) (unsigned long) map) >> 32;
for (j = 0; j < env->used_map_cnt; j++)
if (env->used_maps[j] == map) {
fdput(f);
goto next_insn;
}
if (env->used_map_cnt >= MAX_USED_MAPS) {
fdput(f);
return -E2BIG;
}
env->used_maps[env->used_map_cnt++] = map;
bpf_map_inc(map, false);
fdput(f);
next_insn:
insn++;
i++;
}
}
return 0;
}","static int replace_map_fd_with_map_ptr(struct verifier_env *VAR_0)
{
struct bpf_insn *VAR_1 = VAR_0->prog->insnsi;
int VAR_2 = VAR_0->prog->len;
int VAR_3, VAR_4;
for (VAR_3 = 0; VAR_3 < VAR_2; VAR_3++, VAR_1++) {
if (BPF_CLASS(VAR_1->code) == VAR_5 &&
(BPF_MODE(VAR_1->code) != VAR_6 || VAR_1->imm != 0)) {
verbose(""BPF_LDX uses reserved fields\n"");
return -VAR_7;
}
if (BPF_CLASS(VAR_1->code) == VAR_8 &&
((BPF_MODE(VAR_1->code) != VAR_6 &&
BPF_MODE(VAR_1->code) != VAR_9) || VAR_1->imm != 0)) {
verbose(""BPF_STX uses reserved fields\n"");
return -VAR_7;
}
if (VAR_1[0].code == (VAR_10 | VAR_11 | VAR_12)) {
struct bpf_map *VAR_13;
struct fd VAR_14;
if (VAR_3 == VAR_2 - 1 || VAR_1[1].code != 0 ||
VAR_1[1].dst_reg != 0 || VAR_1[1].src_reg != 0 ||
VAR_1[1].off != 0) {
verbose(""invalid bpf_ld_imm64 insn\n"");
return -VAR_7;
}
if (VAR_1->src_reg == 0)
goto next_insn;
if (VAR_1->src_reg != VAR_15) {
verbose(""unrecognized bpf_ld_imm64 insn\n"");
return -VAR_7;
}
VAR_14 = fdget(VAR_1->imm);
VAR_13 = __bpf_map_get(VAR_14);
if (IS_ERR(VAR_13)) {
verbose(""fd %d is not pointing to valid bpf_map\n"",
VAR_1->imm);
return PTR_ERR(VAR_13);
}
VAR_1[0].imm = (u32) (unsigned long) VAR_13;
VAR_1[1].imm = ((u64) (unsigned long) VAR_13) >> 32;
for (VAR_4 = 0; VAR_4 < VAR_0->used_map_cnt; VAR_4++)
if (VAR_0->used_maps[VAR_4] == VAR_13) {
fdput(VAR_14);
goto next_insn;
}
if (VAR_0->used_map_cnt >= VAR_16) {
fdput(VAR_14);
return -VAR_17;
}
VAR_0->used_maps[VAR_0->used_map_cnt++] = VAR_13;
bpf_map_inc(VAR_13, false);
fdput(VAR_14);
next_insn:
VAR_1++;
VAR_3++;
}
}
return 0;
}",torvalds/linux/92117d8443bc5afacc8d5ba82e541946310f106e/verifier.c/vul/before/0.json,"static int replace_map_fd_with_map_ptr(struct verifier_env *env)
{
	struct bpf_insn *insn = env->prog->insnsi;
	int insn_cnt = env->prog->len;
	int i, j;

	for (i = 0; i < insn_cnt; i++, insn++) {
		if (BPF_CLASS(insn->code) == BPF_LDX &&
		    (BPF_MODE(insn->code) != BPF_MEM || insn->imm != 0)) {
			verbose(""BPF_LDX uses reserved fields\n"");
			return -EINVAL;
		}

		if (BPF_CLASS(insn->code) == BPF_STX &&
		    ((BPF_MODE(insn->code) != BPF_MEM &&
		      BPF_MODE(insn->code) != BPF_XADD) || insn->imm != 0)) {
			verbose(""BPF_STX uses reserved fields\n"");
			return -EINVAL;
		}

		if (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW)) {
			struct bpf_map *map;
			struct fd f;

			if (i == insn_cnt - 1 || insn[1].code != 0 ||
			    insn[1].dst_reg != 0 || insn[1].src_reg != 0 ||
			    insn[1].off != 0) {
				verbose(""invalid bpf_ld_imm64 insn\n"");
				return -EINVAL;
			}

			if (insn->src_reg == 0)
				/* valid generic load 64-bit imm */
				goto next_insn;

			if (insn->src_reg != BPF_PSEUDO_MAP_FD) {
				verbose(""unrecognized bpf_ld_imm64 insn\n"");
				return -EINVAL;
			}

			f = fdget(insn->imm);
			map = __bpf_map_get(f);
			if (IS_ERR(map)) {
				verbose(""fd %d is not pointing to valid bpf_map\n"",
					insn->imm);
				return PTR_ERR(map);
			}

			/* store map pointer inside BPF_LD_IMM64 instruction */
			insn[0].imm = (u32) (unsigned long) map;
			insn[1].imm = ((u64) (unsigned long) map) >> 32;

			/* check whether we recorded this map already */
			for (j = 0; j < env->used_map_cnt; j++)
				if (env->used_maps[j] == map) {
					fdput(f);
					goto next_insn;
				}

			if (env->used_map_cnt >= MAX_USED_MAPS) {
				fdput(f);
				return -E2BIG;
			}

			/* hold the map. If the program is rejected by verifier,
			 * the map will be released by release_maps() or it
			 * will be used by the valid program until it's unloaded
			 * and all maps are released in free_bpf_prog_info()
			 */
			map = bpf_map_inc(map, false);
			if (IS_ERR(map)) {
				fdput(f);
				return PTR_ERR(map);
			}
			env->used_maps[env->used_map_cnt++] = map;

			fdput(f);
next_insn:
			insn++;
			i++;
		}
	}

	/* now all pseudo BPF_LD_IMM64 instructions load valid
	 * 'struct bpf_map *' into a register instead of user map_fd.
	 * These pointers will be used later by verifier to validate map access.
	 */
	return 0;
}","static int replace_map_fd_with_map_ptr(struct verifier_env *VAR_0)
{
	struct bpf_insn *VAR_1 = VAR_0->prog->insnsi;
	int VAR_2 = VAR_0->prog->len;
	int VAR_3, VAR_4;

	for (VAR_3 = 0; VAR_3 < VAR_2; VAR_3++, VAR_1++) {
		if (BPF_CLASS(VAR_1->code) == VAR_5 &&
		    (BPF_MODE(VAR_1->code) != VAR_6 || VAR_1->imm != 0)) {
			verbose(""BPF_LDX uses reserved fields\n"");
			return -VAR_7;
		}

		if (BPF_CLASS(VAR_1->code) == VAR_8 &&
		    ((BPF_MODE(VAR_1->code) != VAR_6 &&
		      BPF_MODE(VAR_1->code) != VAR_9) || VAR_1->imm != 0)) {
			verbose(""BPF_STX uses reserved fields\n"");
			return -VAR_7;
		}

		if (VAR_1[0].code == (VAR_10 | VAR_11 | VAR_12)) {
			struct bpf_map *VAR_13;
			struct fd VAR_14;

			if (VAR_3 == VAR_2 - 1 || VAR_1[1].code != 0 ||
			    VAR_1[1].dst_reg != 0 || VAR_1[1].src_reg != 0 ||
			    VAR_1[1].off != 0) {
				verbose(""invalid bpf_ld_imm64 insn\n"");
				return -VAR_7;
			}

			if (VAR_1->src_reg == 0)
				/* COMMENT_0 */
				goto next_insn;

			if (VAR_1->src_reg != VAR_15) {
				verbose(""unrecognized bpf_ld_imm64 insn\n"");
				return -VAR_7;
			}

			VAR_14 = fdget(VAR_1->imm);
			VAR_13 = __bpf_map_get(VAR_14);
			if (IS_ERR(VAR_13)) {
				verbose(""fd %d is not pointing to valid bpf_map\n"",
					VAR_1->imm);
				return PTR_ERR(VAR_13);
			}

			/* COMMENT_1 */
			VAR_1[0].imm = (u32) (unsigned long) VAR_13;
			VAR_1[1].imm = ((u64) (unsigned long) VAR_13) >> 32;

			/* COMMENT_2 */
			for (VAR_4 = 0; VAR_4 < VAR_0->used_map_cnt; VAR_4++)
				if (VAR_0->used_maps[VAR_4] == VAR_13) {
					fdput(VAR_14);
					goto next_insn;
				}

			if (VAR_0->used_map_cnt >= VAR_16) {
				fdput(VAR_14);
				return -VAR_17;
			}

			/* COMMENT_3 */
                                                      
                                                           
                                                       
      
			VAR_13 = bpf_map_inc(VAR_13, false);
			if (IS_ERR(VAR_13)) {
				fdput(VAR_14);
				return PTR_ERR(VAR_13);
			}
			VAR_0->used_maps[VAR_0->used_map_cnt++] = VAR_13;

			fdput(VAR_14);
next_insn:
			VAR_1++;
			VAR_3++;
		}
	}

	/* COMMENT_8 */
                                                              
                                                                         
    
	return 0;
}",torvalds/linux/92117d8443bc5afacc8d5ba82e541946310f106e/verifier.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -62,15 +62,18 @@
 				return -E2BIG;
 			}
 
-			/* remember this map */
-			env->used_maps[env->used_map_cnt++] = map;
-
 			/* hold the map. If the program is rejected by verifier,
 			 * the map will be released by release_maps() or it
 			 * will be used by the valid program until it's unloaded
 			 * and all maps are released in free_bpf_prog_info()
 			 */
-			bpf_map_inc(map, false);
+			map = bpf_map_inc(map, false);
+			if (IS_ERR(map)) {
+				fdput(f);
+				return PTR_ERR(map);
+			}
+			env->used_maps[env->used_map_cnt++] = map;
+
 			fdput(f);
 next_insn:
 			insn++;","{'deleted_lines': ['\t\t\t/* remember this map */', '\t\t\tenv->used_maps[env->used_map_cnt++] = map;', '', '\t\t\tbpf_map_inc(map, false);'], 'added_lines': ['\t\t\tmap = bpf_map_inc(map, false);', '\t\t\tif (IS_ERR(map)) {', '\t\t\t\tfdput(f);', '\t\t\t\treturn PTR_ERR(map);', '\t\t\t}', '\t\t\tenv->used_maps[env->used_map_cnt++] = map;', '']}",True,"The BPF subsystem in the Linux kernel before 4.5.5 mishandles reference counts, which allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted application on (1) a system with more than 32 Gb of memory, related to the program reference count or (2) a 1 Tb system, related to the map reference count.",7.0,HIGH,2,test,2016-04-28T01:56:20Z,1
CVE-2016-5355,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"Fix packet length handling.

Treat the packet length as unsigned - it shouldn't be negative in the
file.  If it is, that'll probably cause the sscanf to fail, so we'll
report the file as bad.

Check it against WTAP_MAX_PACKET_SIZE to make sure we don't try to
allocate a huge amount of memory, just as we do in other file readers.

Use the now-validated packet size as the length in
ws_buffer_assure_space(), so we are certain to have enough space, and
don't allocate too much space.

Bug: 12394
Change-Id: Ifa023ce70f7a2697bf151009b035a6e6cf8d5d90
Reviewed-on: https://code.wireshark.org/review/15169
Reviewed-by: Guy Harris <guy@alum.mit.edu>",5efb45231671baa2db2011d8f67f9d6e72bc455b,https://github.com/wireshark/wireshark/commit/5efb45231671baa2db2011d8f67f9d6e72bc455b,wiretap/toshiba.c,parse_toshiba_packet,"static gboolean
parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,
int *err, gchar **err_info)
{
union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;
charline[TOSHIBA_LINE_LENGTH];
intnum_items_scanned;
intpkt_len, pktnum, hr, min, sec, csec;
charchannel[10], direction[10];
inti, hex_lines;
guint8*pd;
if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {
*err = file_error(fh, err_info);
if (*err == 0) {
*err = WTAP_ERR_SHORT_READ;
}
return FALSE;
}
num_items_scanned = sscanf(line, ""%9d] %2d:%2d:%2d.%9d %9s %9s"",
&pktnum, &hr, &min, &sec, &csec, channel, direction);
if (num_items_scanned != 7) {
*err = WTAP_ERR_BAD_FILE;
*err_info = g_strdup(""toshiba: record header isn't valid"");
return FALSE;
}
do {
if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {
*err = file_error(fh, err_info);
if (*err == 0) {
*err = WTAP_ERR_SHORT_READ;
}
return FALSE;
}
line[16] = '\0';
} while (strcmp(line, ""OFFSET 0001-0203"") != 0);
num_items_scanned = sscanf(line+64, ""LEN=%9d"", &pkt_len);
if (num_items_scanned != 1) {
*err = WTAP_ERR_BAD_FILE;
*err_info = g_strdup(""toshiba: OFFSET line doesn't have valid LEN item"");
return FALSE;
}
phdr->rec_type = REC_TYPE_PACKET;
phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;
phdr->ts.secs = hr * 3600 + min * 60 + sec;
phdr->ts.nsecs = csec * 10000000;
phdr->caplen = pkt_len;
phdr->len = pkt_len;
switch (channel[0]) {
case 'B':
phdr->pkt_encap = WTAP_ENCAP_ISDN;
pseudo_header->isdn.uton = (direction[0] == 'T');
pseudo_header->isdn.channel = (guint8)
strtol(&channel[1], NULL, 10);
break;
case 'D':
phdr->pkt_encap = WTAP_ENCAP_ISDN;
pseudo_header->isdn.uton = (direction[0] == 'T');
pseudo_header->isdn.channel = 0;
break;
default:
phdr->pkt_encap = WTAP_ENCAP_ETHERNET;
pseudo_header->eth.fcs_len = -1;
break;
}
ws_buffer_assure_space(buf, TOSHIBA_MAX_PACKET_LEN);
pd = ws_buffer_start_ptr(buf);
hex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);
for (i = 0; i < hex_lines; i++) {
if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {
*err = file_error(fh, err_info);
if (*err == 0) {
*err = WTAP_ERR_SHORT_READ;
}
return FALSE;
}
if (!parse_single_hex_dump_line(line, pd, i * 16)) {
*err = WTAP_ERR_BAD_FILE;
*err_info = g_strdup(""toshiba: hex dump not valid"");
return FALSE;
}
}
return TRUE;
}","static gboolean
parse_toshiba_packet(FILE_T VAR_0, struct wtap_pkthdr *VAR_1, Buffer *VAR_2,
int *VAR_3, gchar **VAR_4)
{
union wtap_pseudo_header *VAR_5 = &VAR_1->pseudo_header;
charVAR_6[VAR_7];
intVAR_8;
intVAR_9, VAR_10, VAR_11, VAR_12, VAR_13, VAR_14;
charVAR_15[10], VAR_16[10];
intVAR_17, VAR_18;
guint8*VAR_19;
if (file_gets(VAR_6, VAR_7, VAR_0) == NULL) {
*VAR_3 = file_error(VAR_0, VAR_4);
if (*VAR_3 == 0) {
*VAR_3 = VAR_20;
}
return FALSE;
}
VAR_8 = sscanf(VAR_6, ""%9d] %2d:%2d:%2d.%9d %9s %9s"",
&VAR_10, &VAR_11, &VAR_12, &VAR_13, &VAR_14, VAR_15, VAR_16);
if (VAR_8 != 7) {
*VAR_3 = VAR_21;
*VAR_4 = g_strdup(""toshiba: record header isn't valid"");
return FALSE;
}
do {
if (file_gets(VAR_6, VAR_7, VAR_0) == NULL) {
*VAR_3 = file_error(VAR_0, VAR_4);
if (*VAR_3 == 0) {
*VAR_3 = VAR_20;
}
return FALSE;
}
VAR_6[16] = '\0';
} while (strcmp(VAR_6, ""OFFSET 0001-0203"") != 0);
VAR_8 = sscanf(VAR_6+64, ""LEN=%9d"", &VAR_9);
if (VAR_8 != 1) {
*VAR_3 = VAR_21;
*VAR_4 = g_strdup(""toshiba: OFFSET line doesn't have valid LEN item"");
return FALSE;
}
VAR_1->rec_type = VAR_22;
VAR_1->presence_flags = VAR_23|VAR_24;
VAR_1->ts.secs = VAR_11 * 3600 + VAR_12 * 60 + VAR_13;
VAR_1->ts.nsecs = VAR_14 * 10000000;
VAR_1->caplen = VAR_9;
VAR_1->len = VAR_9;
switch (VAR_15[0]) {
case 'B':
VAR_1->pkt_encap = VAR_25;
VAR_5->isdn.uton = (VAR_16[0] == 'T');
VAR_5->isdn.channel = (guint8)
strtol(&VAR_15[1], NULL, 10);
break;
case 'D':
VAR_1->pkt_encap = VAR_25;
VAR_5->isdn.uton = (VAR_16[0] == 'T');
VAR_5->isdn.channel = 0;
break;
default:
VAR_1->pkt_encap = VAR_26;
VAR_5->eth.fcs_len = -1;
break;
}
ws_buffer_assure_space(VAR_2, VAR_27);
VAR_19 = ws_buffer_start_ptr(VAR_2);
VAR_18 = VAR_9 / 16 + ((VAR_9 % 16) ? 1 : 0);
for (VAR_17 = 0; VAR_17 < VAR_18; VAR_17++) {
if (file_gets(VAR_6, VAR_7, VAR_0) == NULL) {
*VAR_3 = file_error(VAR_0, VAR_4);
if (*VAR_3 == 0) {
*VAR_3 = VAR_20;
}
return FALSE;
}
if (!parse_single_hex_dump_line(VAR_6, VAR_19, VAR_17 * 16)) {
*VAR_3 = VAR_21;
*VAR_4 = g_strdup(""toshiba: hex dump not valid"");
return FALSE;
}
}
return TRUE;
}",wireshark/5efb45231671baa2db2011d8f67f9d6e72bc455b/toshiba.c/vul/before/0.json,"static gboolean
parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,
    int *err, gchar **err_info)
{
	union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;
	char	line[TOSHIBA_LINE_LENGTH];
	int	num_items_scanned;
	guint	pkt_len;
	int	pktnum, hr, min, sec, csec;
	char	channel[10], direction[10];
	int	i, hex_lines;
	guint8	*pd;

	/* Our file pointer should be on the line containing the
	 * summary information for a packet. Read in that line and
	 * extract the useful information
	 */
	if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {
		*err = file_error(fh, err_info);
		if (*err == 0) {
			*err = WTAP_ERR_SHORT_READ;
		}
		return FALSE;
	}

	/* Find text in line after ""[No."". Limit the length of the
	 * two strings since we have fixed buffers for channel[] and
	 * direction[] */
	num_items_scanned = sscanf(line, ""%9d] %2d:%2d:%2d.%9d %9s %9s"",
			&pktnum, &hr, &min, &sec, &csec, channel, direction);

	if (num_items_scanned != 7) {
		*err = WTAP_ERR_BAD_FILE;
		*err_info = g_strdup(""toshiba: record header isn't valid"");
		return FALSE;
	}

	/* Scan lines until we find the OFFSET line. In a ""telnet"" trace,
	 * this will be the next line. But if you save your telnet session
	 * to a file from within a Windows-based telnet client, it may
	 * put in line breaks at 80 columns (or however big your ""telnet"" box
	 * is). CRT (a Windows telnet app from VanDyke) does this.
	 * Here we assume that 80 columns will be the minimum size, and that
	 * the OFFSET line is not broken in the middle. It's the previous
	 * line that is normally long and can thus be broken at column 80.
	 */
	do {
		if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {
			*err = file_error(fh, err_info);
			if (*err == 0) {
				*err = WTAP_ERR_SHORT_READ;
			}
			return FALSE;
		}

		/* Check for ""OFFSET 0001-0203"" at beginning of line */
		line[16] = '\0';

	} while (strcmp(line, ""OFFSET 0001-0203"") != 0);

	num_items_scanned = sscanf(line+64, ""LEN=%9u"", &pkt_len);
	if (num_items_scanned != 1) {
		*err = WTAP_ERR_BAD_FILE;
		*err_info = g_strdup(""toshiba: OFFSET line doesn't have valid LEN item"");
		return FALSE;
	}
	if (pkt_len > WTAP_MAX_PACKET_SIZE) {
		/*
		 * Probably a corrupt capture file; don't blow up trying
		 * to allocate space for an immensely-large packet.
		 */
		*err = WTAP_ERR_BAD_FILE;
		*err_info = g_strdup_printf(""toshiba: File has %u-byte packet, bigger than maximum of %u"",
		    pkt_len, WTAP_MAX_PACKET_SIZE);
		return FALSE;
	}

	phdr->rec_type = REC_TYPE_PACKET;
	phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;
	phdr->ts.secs = hr * 3600 + min * 60 + sec;
	phdr->ts.nsecs = csec * 10000000;
	phdr->caplen = pkt_len;
	phdr->len = pkt_len;

	switch (channel[0]) {
		case 'B':
			phdr->pkt_encap = WTAP_ENCAP_ISDN;
			pseudo_header->isdn.uton = (direction[0] == 'T');
			pseudo_header->isdn.channel = (guint8)
			    strtol(&channel[1], NULL, 10);
			break;

		case 'D':
			phdr->pkt_encap = WTAP_ENCAP_ISDN;
			pseudo_header->isdn.uton = (direction[0] == 'T');
			pseudo_header->isdn.channel = 0;
			break;

		default:
			phdr->pkt_encap = WTAP_ENCAP_ETHERNET;
			/* XXX - is there an FCS in the frame? */
			pseudo_header->eth.fcs_len = -1;
			break;
	}

	/* Make sure we have enough room for the packet */
	ws_buffer_assure_space(buf, pkt_len);
	pd = ws_buffer_start_ptr(buf);

	/* Calculate the number of hex dump lines, each
	 * containing 16 bytes of data */
	hex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);

	for (i = 0; i < hex_lines; i++) {
		if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {
			*err = file_error(fh, err_info);
			if (*err == 0) {
				*err = WTAP_ERR_SHORT_READ;
			}
			return FALSE;
		}
		if (!parse_single_hex_dump_line(line, pd, i * 16)) {
			*err = WTAP_ERR_BAD_FILE;
			*err_info = g_strdup(""toshiba: hex dump not valid"");
			return FALSE;
		}
	}
	return TRUE;
}","static gboolean
parse_toshiba_packet(FILE_T VAR_0, struct wtap_pkthdr *VAR_1, Buffer *VAR_2,
    int *VAR_3, gchar **VAR_4)
{
	union wtap_pseudo_header *VAR_5 = &VAR_1->pseudo_header;
	char	VAR_6[VAR_7];
	int	VAR_8;
	guint	VAR_9;
	int	VAR_10, VAR_11, VAR_12, VAR_13, VAR_14;
	char	VAR_15[10], VAR_16[10];
	int	VAR_17, VAR_18;
	guint8	*VAR_19;

	/* COMMENT_0 */
                                                           
                                  
    
	if (file_gets(VAR_6, VAR_7, VAR_0) == NULL) {
		*VAR_3 = file_error(VAR_0, VAR_4);
		if (*VAR_3 == 0) {
			*VAR_3 = VAR_20;
		}
		return FALSE;
	}

	/* COMMENT_4 */
                                                             
                  
	VAR_8 = sscanf(VAR_6, ""%9d] %2d:%2d:%2d.%9d %9s %9s"",
			&VAR_10, &VAR_11, &VAR_12, &VAR_13, &VAR_14, VAR_15, VAR_16);

	if (VAR_8 != 7) {
		*VAR_3 = VAR_21;
		*VAR_4 = g_strdup(""toshiba: record header isn't valid"");
		return FALSE;
	}

	/* COMMENT_7 */
                                                                   
                                                               
                                                                      
                                                           
                                                                     
                                                                  
                                                                   
    
	do {
		if (file_gets(VAR_6, VAR_7, VAR_0) == NULL) {
			*VAR_3 = file_error(VAR_0, VAR_4);
			if (*VAR_3 == 0) {
				*VAR_3 = VAR_20;
			}
			return FALSE;
		}

		/* COMMENT_16 */
		VAR_6[16] = '\0';

	} while (strcmp(VAR_6, ""OFFSET 0001-0203"") != 0);

	VAR_8 = sscanf(VAR_6+64, ""LEN=%9u"", &VAR_9);
	if (VAR_8 != 1) {
		*VAR_3 = VAR_21;
		*VAR_4 = g_strdup(""toshiba: OFFSET line doesn't have valid LEN item"");
		return FALSE;
	}
	if (VAR_9 > VAR_22) {
		/* COMMENT_17 */
                                                          
                                                     
     
		*VAR_3 = VAR_21;
		*VAR_4 = g_strdup_printf(""toshiba: File has %u-byte packet, bigger than maximum of %u"",
		    VAR_9, VAR_22);
		return FALSE;
	}

	VAR_1->rec_type = VAR_23;
	VAR_1->presence_flags = VAR_24|VAR_25;
	VAR_1->ts.secs = VAR_11 * 3600 + VAR_12 * 60 + VAR_13;
	VAR_1->ts.nsecs = VAR_14 * 10000000;
	VAR_1->caplen = VAR_9;
	VAR_1->len = VAR_9;

	switch (VAR_15[0]) {
		case 'B':
			VAR_1->pkt_encap = VAR_26;
			VAR_5->isdn.uton = (VAR_16[0] == 'T');
			VAR_5->isdn.channel = (guint8)
			    strtol(&VAR_15[1], NULL, 10);
			break;

		case 'D':
			VAR_1->pkt_encap = VAR_26;
			VAR_5->isdn.uton = (VAR_16[0] == 'T');
			VAR_5->isdn.channel = 0;
			break;

		default:
			VAR_1->pkt_encap = VAR_27;
			/* COMMENT_21 */
			VAR_5->eth.fcs_len = -1;
			break;
	}

	/* COMMENT_22 */
	ws_buffer_assure_space(VAR_2, VAR_9);
	VAR_19 = ws_buffer_start_ptr(VAR_2);

	/* COMMENT_23 */
                                  
	VAR_18 = VAR_9 / 16 + ((VAR_9 % 16) ? 1 : 0);

	for (VAR_17 = 0; VAR_17 < VAR_18; VAR_17++) {
		if (file_gets(VAR_6, VAR_7, VAR_0) == NULL) {
			*VAR_3 = file_error(VAR_0, VAR_4);
			if (*VAR_3 == 0) {
				*VAR_3 = VAR_20;
			}
			return FALSE;
		}
		if (!parse_single_hex_dump_line(VAR_6, VAR_19, VAR_17 * 16)) {
			*VAR_3 = VAR_21;
			*VAR_4 = g_strdup(""toshiba: hex dump not valid"");
			return FALSE;
		}
	}
	return TRUE;
}",wireshark/5efb45231671baa2db2011d8f67f9d6e72bc455b/toshiba.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,7 +5,8 @@
 	union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;
 	char	line[TOSHIBA_LINE_LENGTH];
 	int	num_items_scanned;
-	int	pkt_len, pktnum, hr, min, sec, csec;
+	guint	pkt_len;
+	int	pktnum, hr, min, sec, csec;
 	char	channel[10], direction[10];
 	int	i, hex_lines;
 	guint8	*pd;
@@ -57,10 +58,20 @@
 
 	} while (strcmp(line, ""OFFSET 0001-0203"") != 0);
 
-	num_items_scanned = sscanf(line+64, ""LEN=%9d"", &pkt_len);
+	num_items_scanned = sscanf(line+64, ""LEN=%9u"", &pkt_len);
 	if (num_items_scanned != 1) {
 		*err = WTAP_ERR_BAD_FILE;
 		*err_info = g_strdup(""toshiba: OFFSET line doesn't have valid LEN item"");
+		return FALSE;
+	}
+	if (pkt_len > WTAP_MAX_PACKET_SIZE) {
+		/*
+		 * Probably a corrupt capture file; don't blow up trying
+		 * to allocate space for an immensely-large packet.
+		 */
+		*err = WTAP_ERR_BAD_FILE;
+		*err_info = g_strdup_printf(""toshiba: File has %u-byte packet, bigger than maximum of %u"",
+		    pkt_len, WTAP_MAX_PACKET_SIZE);
 		return FALSE;
 	}
 
@@ -93,7 +104,7 @@
 	}
 
 	/* Make sure we have enough room for the packet */
-	ws_buffer_assure_space(buf, TOSHIBA_MAX_PACKET_LEN);
+	ws_buffer_assure_space(buf, pkt_len);
 	pd = ws_buffer_start_ptr(buf);
 
 	/* Calculate the number of hex dump lines, each","{'deleted_lines': ['\tint\tpkt_len, pktnum, hr, min, sec, csec;', '\tnum_items_scanned = sscanf(line+64, ""LEN=%9d"", &pkt_len);', '\tws_buffer_assure_space(buf, TOSHIBA_MAX_PACKET_LEN);'], 'added_lines': ['\tguint\tpkt_len;', '\tint\tpktnum, hr, min, sec, csec;', '\tnum_items_scanned = sscanf(line+64, ""LEN=%9u"", &pkt_len);', '\t\treturn FALSE;', '\t}', '\tif (pkt_len > WTAP_MAX_PACKET_SIZE) {', '\t\t/*', ""\t\t * Probably a corrupt capture file; don't blow up trying"", '\t\t * to allocate space for an immensely-large packet.', '\t\t */', '\t\t*err = WTAP_ERR_BAD_FILE;', '\t\t*err_info = g_strdup_printf(""toshiba: File has %u-byte packet, bigger than maximum of %u"",', '\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);', '\tws_buffer_assure_space(buf, pkt_len);']}",True,"wiretap/toshiba.c in the Toshiba file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file.",5.9,MEDIUM,1,test,2016-04-29T22:19:49Z,1
CVE-2016-5355,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"Don't treat the packet length as unsigned.

The scanf family of functions are as annoyingly bad at handling unsigned
numbers as strtoul() is - both of them are perfectly willing to accept a
value beginning with a negative sign as an unsigned value.  When using
strtoul(), you can compensate for this by explicitly checking for a '-'
as the first character of the string, but you can't do that with
sscanf().

So revert to having pkt_len be signed, and scanning it with %d, but
check for a negative value and fail if we see a negative value.

Bug: 12394
Change-Id: I4b19b95f2e1ffc96dac5c91bff6698c246f52007
Reviewed-on: https://code.wireshark.org/review/15230
Reviewed-by: Guy Harris <guy@alum.mit.edu>",3270dfac43da861c714df76513456b46765ff47f,https://github.com/wireshark/wireshark/commit/3270dfac43da861c714df76513456b46765ff47f,wiretap/toshiba.c,parse_toshiba_packet,"static gboolean
parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,
int *err, gchar **err_info)
{
union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;
charline[TOSHIBA_LINE_LENGTH];
intnum_items_scanned;
guintpkt_len;
intpktnum, hr, min, sec, csec;
charchannel[10], direction[10];
inti, hex_lines;
guint8*pd;
if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {
*err = file_error(fh, err_info);
if (*err == 0) {
*err = WTAP_ERR_SHORT_READ;
}
return FALSE;
}
num_items_scanned = sscanf(line, ""%9d] %2d:%2d:%2d.%9d %9s %9s"",
&pktnum, &hr, &min, &sec, &csec, channel, direction);
if (num_items_scanned != 7) {
*err = WTAP_ERR_BAD_FILE;
*err_info = g_strdup(""toshiba: record header isn't valid"");
return FALSE;
}
do {
if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {
*err = file_error(fh, err_info);
if (*err == 0) {
*err = WTAP_ERR_SHORT_READ;
}
return FALSE;
}
line[16] = '\0';
} while (strcmp(line, ""OFFSET 0001-0203"") != 0);
num_items_scanned = sscanf(line+64, ""LEN=%9u"", &pkt_len);
if (num_items_scanned != 1) {
*err = WTAP_ERR_BAD_FILE;
*err_info = g_strdup(""toshiba: OFFSET line doesn't have valid LEN item"");
return FALSE;
}
if (pkt_len > WTAP_MAX_PACKET_SIZE) {
*err = WTAP_ERR_BAD_FILE;
*err_info = g_strdup_printf(""toshiba: File has %u-byte packet, bigger than maximum of %u"",
pkt_len, WTAP_MAX_PACKET_SIZE);
return FALSE;
}
phdr->rec_type = REC_TYPE_PACKET;
phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;
phdr->ts.secs = hr * 3600 + min * 60 + sec;
phdr->ts.nsecs = csec * 10000000;
phdr->caplen = pkt_len;
phdr->len = pkt_len;
switch (channel[0]) {
case 'B':
phdr->pkt_encap = WTAP_ENCAP_ISDN;
pseudo_header->isdn.uton = (direction[0] == 'T');
pseudo_header->isdn.channel = (guint8)
strtol(&channel[1], NULL, 10);
break;
case 'D':
phdr->pkt_encap = WTAP_ENCAP_ISDN;
pseudo_header->isdn.uton = (direction[0] == 'T');
pseudo_header->isdn.channel = 0;
break;
default:
phdr->pkt_encap = WTAP_ENCAP_ETHERNET;
pseudo_header->eth.fcs_len = -1;
break;
}
ws_buffer_assure_space(buf, pkt_len);
pd = ws_buffer_start_ptr(buf);
hex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);
for (i = 0; i < hex_lines; i++) {
if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {
*err = file_error(fh, err_info);
if (*err == 0) {
*err = WTAP_ERR_SHORT_READ;
}
return FALSE;
}
if (!parse_single_hex_dump_line(line, pd, i * 16)) {
*err = WTAP_ERR_BAD_FILE;
*err_info = g_strdup(""toshiba: hex dump not valid"");
return FALSE;
}
}
return TRUE;
}","static gboolean
parse_toshiba_packet(FILE_T VAR_0, struct wtap_pkthdr *VAR_1, Buffer *VAR_2,
int *VAR_3, gchar **VAR_4)
{
union wtap_pseudo_header *VAR_5 = &VAR_1->pseudo_header;
charVAR_6[VAR_7];
intVAR_8;
guintVAR_9;
intVAR_10, VAR_11, VAR_12, VAR_13, VAR_14;
charVAR_15[10], VAR_16[10];
intVAR_17, VAR_18;
guint8*VAR_19;
if (file_gets(VAR_6, VAR_7, VAR_0) == NULL) {
*VAR_3 = file_error(VAR_0, VAR_4);
if (*VAR_3 == 0) {
*VAR_3 = VAR_20;
}
return FALSE;
}
VAR_8 = sscanf(VAR_6, ""%9d] %2d:%2d:%2d.%9d %9s %9s"",
&VAR_10, &VAR_11, &VAR_12, &VAR_13, &VAR_14, VAR_15, VAR_16);
if (VAR_8 != 7) {
*VAR_3 = VAR_21;
*VAR_4 = g_strdup(""toshiba: record header isn't valid"");
return FALSE;
}
do {
if (file_gets(VAR_6, VAR_7, VAR_0) == NULL) {
*VAR_3 = file_error(VAR_0, VAR_4);
if (*VAR_3 == 0) {
*VAR_3 = VAR_20;
}
return FALSE;
}
VAR_6[16] = '\0';
} while (strcmp(VAR_6, ""OFFSET 0001-0203"") != 0);
VAR_8 = sscanf(VAR_6+64, ""LEN=%9u"", &VAR_9);
if (VAR_8 != 1) {
*VAR_3 = VAR_21;
*VAR_4 = g_strdup(""toshiba: OFFSET line doesn't have valid LEN item"");
return FALSE;
}
if (VAR_9 > VAR_22) {
*VAR_3 = VAR_21;
*VAR_4 = g_strdup_printf(""toshiba: File has %u-byte packet, bigger than maximum of %u"",
VAR_9, VAR_22);
return FALSE;
}
VAR_1->rec_type = VAR_23;
VAR_1->presence_flags = VAR_24|VAR_25;
VAR_1->ts.secs = VAR_11 * 3600 + VAR_12 * 60 + VAR_13;
VAR_1->ts.nsecs = VAR_14 * 10000000;
VAR_1->caplen = VAR_9;
VAR_1->len = VAR_9;
switch (VAR_15[0]) {
case 'B':
VAR_1->pkt_encap = VAR_26;
VAR_5->isdn.uton = (VAR_16[0] == 'T');
VAR_5->isdn.channel = (guint8)
strtol(&VAR_15[1], NULL, 10);
break;
case 'D':
VAR_1->pkt_encap = VAR_26;
VAR_5->isdn.uton = (VAR_16[0] == 'T');
VAR_5->isdn.channel = 0;
break;
default:
VAR_1->pkt_encap = VAR_27;
VAR_5->eth.fcs_len = -1;
break;
}
ws_buffer_assure_space(VAR_2, VAR_9);
VAR_19 = ws_buffer_start_ptr(VAR_2);
VAR_18 = VAR_9 / 16 + ((VAR_9 % 16) ? 1 : 0);
for (VAR_17 = 0; VAR_17 < VAR_18; VAR_17++) {
if (file_gets(VAR_6, VAR_7, VAR_0) == NULL) {
*VAR_3 = file_error(VAR_0, VAR_4);
if (*VAR_3 == 0) {
*VAR_3 = VAR_20;
}
return FALSE;
}
if (!parse_single_hex_dump_line(VAR_6, VAR_19, VAR_17 * 16)) {
*VAR_3 = VAR_21;
*VAR_4 = g_strdup(""toshiba: hex dump not valid"");
return FALSE;
}
}
return TRUE;
}",wireshark/3270dfac43da861c714df76513456b46765ff47f/toshiba.c/vul/before/0.json,"static gboolean
parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,
    int *err, gchar **err_info)
{
	union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;
	char	line[TOSHIBA_LINE_LENGTH];
	int	num_items_scanned;
	int	pkt_len, pktnum, hr, min, sec, csec;
	char	channel[10], direction[10];
	int	i, hex_lines;
	guint8	*pd;

	/* Our file pointer should be on the line containing the
	 * summary information for a packet. Read in that line and
	 * extract the useful information
	 */
	if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {
		*err = file_error(fh, err_info);
		if (*err == 0) {
			*err = WTAP_ERR_SHORT_READ;
		}
		return FALSE;
	}

	/* Find text in line after ""[No."". Limit the length of the
	 * two strings since we have fixed buffers for channel[] and
	 * direction[] */
	num_items_scanned = sscanf(line, ""%9d] %2d:%2d:%2d.%9d %9s %9s"",
			&pktnum, &hr, &min, &sec, &csec, channel, direction);

	if (num_items_scanned != 7) {
		*err = WTAP_ERR_BAD_FILE;
		*err_info = g_strdup(""toshiba: record header isn't valid"");
		return FALSE;
	}

	/* Scan lines until we find the OFFSET line. In a ""telnet"" trace,
	 * this will be the next line. But if you save your telnet session
	 * to a file from within a Windows-based telnet client, it may
	 * put in line breaks at 80 columns (or however big your ""telnet"" box
	 * is). CRT (a Windows telnet app from VanDyke) does this.
	 * Here we assume that 80 columns will be the minimum size, and that
	 * the OFFSET line is not broken in the middle. It's the previous
	 * line that is normally long and can thus be broken at column 80.
	 */
	do {
		if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {
			*err = file_error(fh, err_info);
			if (*err == 0) {
				*err = WTAP_ERR_SHORT_READ;
			}
			return FALSE;
		}

		/* Check for ""OFFSET 0001-0203"" at beginning of line */
		line[16] = '\0';

	} while (strcmp(line, ""OFFSET 0001-0203"") != 0);

	num_items_scanned = sscanf(line+64, ""LEN=%9d"", &pkt_len);
	if (num_items_scanned != 1) {
		*err = WTAP_ERR_BAD_FILE;
		*err_info = g_strdup(""toshiba: OFFSET line doesn't have valid LEN item"");
		return FALSE;
	}
	if (pkt_len < 0) {
		*err = WTAP_ERR_BAD_FILE;
		*err_info = g_strdup(""toshiba: packet header has a negative packet length"");
		return FALSE;
	}
	if (pkt_len > WTAP_MAX_PACKET_SIZE) {
		/*
		 * Probably a corrupt capture file; don't blow up trying
		 * to allocate space for an immensely-large packet.
		 */
		*err = WTAP_ERR_BAD_FILE;
		*err_info = g_strdup_printf(""toshiba: File has %u-byte packet, bigger than maximum of %u"",
		    pkt_len, WTAP_MAX_PACKET_SIZE);
		return FALSE;
	}

	phdr->rec_type = REC_TYPE_PACKET;
	phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;
	phdr->ts.secs = hr * 3600 + min * 60 + sec;
	phdr->ts.nsecs = csec * 10000000;
	phdr->caplen = pkt_len;
	phdr->len = pkt_len;

	switch (channel[0]) {
		case 'B':
			phdr->pkt_encap = WTAP_ENCAP_ISDN;
			pseudo_header->isdn.uton = (direction[0] == 'T');
			pseudo_header->isdn.channel = (guint8)
			    strtol(&channel[1], NULL, 10);
			break;

		case 'D':
			phdr->pkt_encap = WTAP_ENCAP_ISDN;
			pseudo_header->isdn.uton = (direction[0] == 'T');
			pseudo_header->isdn.channel = 0;
			break;

		default:
			phdr->pkt_encap = WTAP_ENCAP_ETHERNET;
			/* XXX - is there an FCS in the frame? */
			pseudo_header->eth.fcs_len = -1;
			break;
	}

	/* Make sure we have enough room for the packet */
	ws_buffer_assure_space(buf, pkt_len);
	pd = ws_buffer_start_ptr(buf);

	/* Calculate the number of hex dump lines, each
	 * containing 16 bytes of data */
	hex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);

	for (i = 0; i < hex_lines; i++) {
		if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {
			*err = file_error(fh, err_info);
			if (*err == 0) {
				*err = WTAP_ERR_SHORT_READ;
			}
			return FALSE;
		}
		if (!parse_single_hex_dump_line(line, pd, i * 16)) {
			*err = WTAP_ERR_BAD_FILE;
			*err_info = g_strdup(""toshiba: hex dump not valid"");
			return FALSE;
		}
	}
	return TRUE;
}","static gboolean
parse_toshiba_packet(FILE_T VAR_0, struct wtap_pkthdr *VAR_1, Buffer *VAR_2,
    int *VAR_3, gchar **VAR_4)
{
	union wtap_pseudo_header *VAR_5 = &VAR_1->pseudo_header;
	char	VAR_6[VAR_7];
	int	VAR_8;
	int	VAR_9, VAR_10, VAR_11, VAR_12, VAR_13, VAR_14;
	char	VAR_15[10], VAR_16[10];
	int	VAR_17, VAR_18;
	guint8	*VAR_19;

	/* COMMENT_0 */
                                                           
                                  
    
	if (file_gets(VAR_6, VAR_7, VAR_0) == NULL) {
		*VAR_3 = file_error(VAR_0, VAR_4);
		if (*VAR_3 == 0) {
			*VAR_3 = VAR_20;
		}
		return FALSE;
	}

	/* COMMENT_4 */
                                                             
                  
	VAR_8 = sscanf(VAR_6, ""%9d] %2d:%2d:%2d.%9d %9s %9s"",
			&VAR_10, &VAR_11, &VAR_12, &VAR_13, &VAR_14, VAR_15, VAR_16);

	if (VAR_8 != 7) {
		*VAR_3 = VAR_21;
		*VAR_4 = g_strdup(""toshiba: record header isn't valid"");
		return FALSE;
	}

	/* COMMENT_7 */
                                                                   
                                                               
                                                                      
                                                           
                                                                     
                                                                  
                                                                   
    
	do {
		if (file_gets(VAR_6, VAR_7, VAR_0) == NULL) {
			*VAR_3 = file_error(VAR_0, VAR_4);
			if (*VAR_3 == 0) {
				*VAR_3 = VAR_20;
			}
			return FALSE;
		}

		/* COMMENT_16 */
		VAR_6[16] = '\0';

	} while (strcmp(VAR_6, ""OFFSET 0001-0203"") != 0);

	VAR_8 = sscanf(VAR_6+64, ""LEN=%9d"", &VAR_9);
	if (VAR_8 != 1) {
		*VAR_3 = VAR_21;
		*VAR_4 = g_strdup(""toshiba: OFFSET line doesn't have valid LEN item"");
		return FALSE;
	}
	if (VAR_9 < 0) {
		*VAR_3 = VAR_21;
		*VAR_4 = g_strdup(""toshiba: packet header has a negative packet length"");
		return FALSE;
	}
	if (VAR_9 > VAR_22) {
		/* COMMENT_17 */
                                                          
                                                     
     
		*VAR_3 = VAR_21;
		*VAR_4 = g_strdup_printf(""toshiba: File has %u-byte packet, bigger than maximum of %u"",
		    VAR_9, VAR_22);
		return FALSE;
	}

	VAR_1->rec_type = VAR_23;
	VAR_1->presence_flags = VAR_24|VAR_25;
	VAR_1->ts.secs = VAR_11 * 3600 + VAR_12 * 60 + VAR_13;
	VAR_1->ts.nsecs = VAR_14 * 10000000;
	VAR_1->caplen = VAR_9;
	VAR_1->len = VAR_9;

	switch (VAR_15[0]) {
		case 'B':
			VAR_1->pkt_encap = VAR_26;
			VAR_5->isdn.uton = (VAR_16[0] == 'T');
			VAR_5->isdn.channel = (guint8)
			    strtol(&VAR_15[1], NULL, 10);
			break;

		case 'D':
			VAR_1->pkt_encap = VAR_26;
			VAR_5->isdn.uton = (VAR_16[0] == 'T');
			VAR_5->isdn.channel = 0;
			break;

		default:
			VAR_1->pkt_encap = VAR_27;
			/* COMMENT_21 */
			VAR_5->eth.fcs_len = -1;
			break;
	}

	/* COMMENT_22 */
	ws_buffer_assure_space(VAR_2, VAR_9);
	VAR_19 = ws_buffer_start_ptr(VAR_2);

	/* COMMENT_23 */
                                  
	VAR_18 = VAR_9 / 16 + ((VAR_9 % 16) ? 1 : 0);

	for (VAR_17 = 0; VAR_17 < VAR_18; VAR_17++) {
		if (file_gets(VAR_6, VAR_7, VAR_0) == NULL) {
			*VAR_3 = file_error(VAR_0, VAR_4);
			if (*VAR_3 == 0) {
				*VAR_3 = VAR_20;
			}
			return FALSE;
		}
		if (!parse_single_hex_dump_line(VAR_6, VAR_19, VAR_17 * 16)) {
			*VAR_3 = VAR_21;
			*VAR_4 = g_strdup(""toshiba: hex dump not valid"");
			return FALSE;
		}
	}
	return TRUE;
}",wireshark/3270dfac43da861c714df76513456b46765ff47f/toshiba.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,8 +5,7 @@
 	union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;
 	char	line[TOSHIBA_LINE_LENGTH];
 	int	num_items_scanned;
-	guint	pkt_len;
-	int	pktnum, hr, min, sec, csec;
+	int	pkt_len, pktnum, hr, min, sec, csec;
 	char	channel[10], direction[10];
 	int	i, hex_lines;
 	guint8	*pd;
@@ -58,10 +57,15 @@
 
 	} while (strcmp(line, ""OFFSET 0001-0203"") != 0);
 
-	num_items_scanned = sscanf(line+64, ""LEN=%9u"", &pkt_len);
+	num_items_scanned = sscanf(line+64, ""LEN=%9d"", &pkt_len);
 	if (num_items_scanned != 1) {
 		*err = WTAP_ERR_BAD_FILE;
 		*err_info = g_strdup(""toshiba: OFFSET line doesn't have valid LEN item"");
+		return FALSE;
+	}
+	if (pkt_len < 0) {
+		*err = WTAP_ERR_BAD_FILE;
+		*err_info = g_strdup(""toshiba: packet header has a negative packet length"");
 		return FALSE;
 	}
 	if (pkt_len > WTAP_MAX_PACKET_SIZE) {","{'deleted_lines': ['\tguint\tpkt_len;', '\tint\tpktnum, hr, min, sec, csec;', '\tnum_items_scanned = sscanf(line+64, ""LEN=%9u"", &pkt_len);'], 'added_lines': ['\tint\tpkt_len, pktnum, hr, min, sec, csec;', '\tnum_items_scanned = sscanf(line+64, ""LEN=%9d"", &pkt_len);', '\t\treturn FALSE;', '\t}', '\tif (pkt_len < 0) {', '\t\t*err = WTAP_ERR_BAD_FILE;', '\t\t*err_info = g_strdup(""toshiba: packet header has a negative packet length"");']}",True,"wiretap/toshiba.c in the Toshiba file parser in Wireshark 1.12.x before 1.12.12 and 2.x before 2.0.4 mishandles sscanf unsigned-integer processing, which allows remote attackers to cause a denial of service (application crash) via a crafted file.",5.9,MEDIUM,1,test,2016-05-01T23:29:41Z,1
CVE-2016-4913,['CWE-200'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"get_rock_ridge_filename(): handle malformed NM entries

Payloads of NM entries are not supposed to contain NUL.  When we run
into such, only the part prior to the first NUL goes into the
concatenation (i.e. the directory entry name being encoded by a bunch
of NM entries).  We do stop when the amount collected so far + the
claimed amount in the current NM entry exceed 254.  So far, so good,
but what we return as the total length is the sum of *claimed*
sizes, not the actual amount collected.  And that can grow pretty
large - not unlimited, since you'd need to put CE entries in
between to be able to get more than the maximum that could be
contained in one isofs directory entry / continuation chunk and
we are stop once we'd encountered 32 CEs, but you can get about 8Kb
easily.  And that's what will be passed to readdir callback as the
name length.  8Kb __copy_to_user() from a buffer allocated by
__get_free_page()

Cc: stable@vger.kernel.org # 0.98pl6+ (yes, really)
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>",99d825822eade8d827a1817357cbf3f889a552d6,https://github.com/torvalds/linux/commit/99d825822eade8d827a1817357cbf3f889a552d6,fs/isofs/rock.c,get_rock_ridge_filename,"int get_rock_ridge_filename(struct iso_directory_record *de,
char *retname, struct inode *inode)
{
struct rock_state rs;
struct rock_ridge *rr;
int sig;
int retnamlen = 0;
int truncate = 0;
int ret = 0;
if (!ISOFS_SB(inode->i_sb)->s_rock)
return 0;
*retname = 0;
init_rock_state(&rs, inode);
setup_rock_ridge(de, inode, &rs);
repeat:
while (rs.len > 2) { 
rr = (struct rock_ridge *)rs.chr;
if (rr->len < 3)
goto out;
sig = isonum_721(rs.chr);
if (rock_check_overflow(&rs, sig))
goto eio;
rs.chr += rr->len;
rs.len -= rr->len;
if (rs.len < 0)
goto out;
switch (sig) {
case SIG('R', 'R'):
if ((rr->u.RR.flags[0] & RR_NM) == 0)
goto out;
break;
case SIG('S', 'P'):
if (check_sp(rr, inode))
goto out;
break;
case SIG('C', 'E'):
rs.cont_extent = isonum_733(rr->u.CE.extent);
rs.cont_offset = isonum_733(rr->u.CE.offset);
rs.cont_size = isonum_733(rr->u.CE.size);
break;
case SIG('N', 'M'):
if (truncate)
break;
if (rr->len < 5)
break;
if (rr->u.NM.flags & 6)
break;
if (rr->u.NM.flags & ~1) {
printk(""Unsupported NM flag settings (%d)\n"",
rr->u.NM.flags);
break;
}
if ((strlen(retname) + rr->len - 5) >= 254) {
truncate = 1;
break;
}
strncat(retname, rr->u.NM.name, rr->len - 5);
retnamlen += rr->len - 5;
break;
case SIG('R', 'E'):
kfree(rs.buffer);
return -1;
default:
break;
}
}
ret = rock_continue(&rs);
if (ret == 0)
goto repeat;
if (ret == 1)
return retnamlen; 
out:
kfree(rs.buffer);
return ret;
eio:
ret = -EIO;
goto out;
}","int get_rock_ridge_filename(struct iso_directory_record *VAR_0,
char *VAR_1, struct inode *inode)
{
struct rock_state VAR_2;
struct rock_ridge *VAR_3;
int VAR_4;
int VAR_5 = 0;
int VAR_6 = 0;
int VAR_7 = 0;
if (!ISOFS_SB(inode->i_sb)->s_rock)
return 0;
*VAR_1 = 0;
init_rock_state(&VAR_2, inode);
setup_rock_ridge(VAR_0, inode, &VAR_2);
repeat:
while (VAR_2.len > 2) { 
VAR_3 = (struct rock_ridge *)VAR_2.chr;
if (VAR_3->len < 3)
goto out;
VAR_4 = isonum_721(VAR_2.chr);
if (rock_check_overflow(&VAR_2, VAR_4))
goto eio;
VAR_2.chr += VAR_3->len;
VAR_2.len -= VAR_3->len;
if (VAR_2.len < 0)
goto out;
switch (VAR_4) {
case SIG('R', 'R'):
if ((VAR_3->u.RR.flags[0] & VAR_8) == 0)
goto out;
break;
case SIG('S', 'P'):
if (check_sp(VAR_3, inode))
goto out;
break;
case SIG('C', 'E'):
VAR_2.cont_extent = isonum_733(VAR_3->u.CE.extent);
VAR_2.cont_offset = isonum_733(VAR_3->u.CE.offset);
VAR_2.cont_size = isonum_733(VAR_3->u.CE.size);
break;
case SIG('N', 'M'):
if (VAR_6)
break;
if (VAR_3->len < 5)
break;
if (VAR_3->u.NM.flags & 6)
break;
if (VAR_3->u.NM.flags & ~1) {
printk(""Unsupported NM flag settings (%d)\n"",
VAR_3->u.NM.flags);
break;
}
if ((strlen(VAR_1) + VAR_3->len - 5) >= 254) {
VAR_6 = 1;
break;
}
strncat(VAR_1, VAR_3->u.NM.name, VAR_3->len - 5);
VAR_5 += VAR_3->len - 5;
break;
case SIG('R', 'E'):
kfree(VAR_2.buffer);
return -1;
default:
break;
}
}
VAR_7 = rock_continue(&VAR_2);
if (VAR_7 == 0)
goto repeat;
if (VAR_7 == 1)
return VAR_5; 
out:
kfree(VAR_2.buffer);
return VAR_7;
eio:
VAR_7 = -VAR_9;
goto out;
}",torvalds/linux/99d825822eade8d827a1817357cbf3f889a552d6/rock.c/vul/before/0.json,"int get_rock_ridge_filename(struct iso_directory_record *de,
			    char *retname, struct inode *inode)
{
	struct rock_state rs;
	struct rock_ridge *rr;
	int sig;
	int retnamlen = 0;
	int truncate = 0;
	int ret = 0;
	char *p;
	int len;

	if (!ISOFS_SB(inode->i_sb)->s_rock)
		return 0;
	*retname = 0;

	init_rock_state(&rs, inode);
	setup_rock_ridge(de, inode, &rs);
repeat:

	while (rs.len > 2) { /* There may be one byte for padding somewhere */
		rr = (struct rock_ridge *)rs.chr;
		/*
		 * Ignore rock ridge info if rr->len is out of range, but
		 * don't return -EIO because that would make the file
		 * invisible.
		 */
		if (rr->len < 3)
			goto out;	/* Something got screwed up here */
		sig = isonum_721(rs.chr);
		if (rock_check_overflow(&rs, sig))
			goto eio;
		rs.chr += rr->len;
		rs.len -= rr->len;
		/*
		 * As above, just ignore the rock ridge info if rr->len
		 * is bogus.
		 */
		if (rs.len < 0)
			goto out;	/* Something got screwed up here */

		switch (sig) {
		case SIG('R', 'R'):
			if ((rr->u.RR.flags[0] & RR_NM) == 0)
				goto out;
			break;
		case SIG('S', 'P'):
			if (check_sp(rr, inode))
				goto out;
			break;
		case SIG('C', 'E'):
			rs.cont_extent = isonum_733(rr->u.CE.extent);
			rs.cont_offset = isonum_733(rr->u.CE.offset);
			rs.cont_size = isonum_733(rr->u.CE.size);
			break;
		case SIG('N', 'M'):
			if (truncate)
				break;
			if (rr->len < 5)
				break;
			/*
			 * If the flags are 2 or 4, this indicates '.' or '..'.
			 * We don't want to do anything with this, because it
			 * screws up the code that calls us.  We don't really
			 * care anyways, since we can just use the non-RR
			 * name.
			 */
			if (rr->u.NM.flags & 6)
				break;

			if (rr->u.NM.flags & ~1) {
				printk(""Unsupported NM flag settings (%d)\n"",
					rr->u.NM.flags);
				break;
			}
			len = rr->len - 5;
			if (retnamlen + len >= 254) {
				truncate = 1;
				break;
			}
			p = memchr(rr->u.NM.name, '\0', len);
			if (unlikely(p))
				len = p - rr->u.NM.name;
			memcpy(retname + retnamlen, rr->u.NM.name, len);
			retnamlen += len;
			retname[retnamlen] = '\0';
			break;
		case SIG('R', 'E'):
			kfree(rs.buffer);
			return -1;
		default:
			break;
		}
	}
	ret = rock_continue(&rs);
	if (ret == 0)
		goto repeat;
	if (ret == 1)
		return retnamlen; /* If 0, this file did not have a NM field */
out:
	kfree(rs.buffer);
	return ret;
eio:
	ret = -EIO;
	goto out;
}","int get_rock_ridge_filename(struct iso_directory_record *VAR_0,
			    char *VAR_1, struct inode *inode)
{
	struct rock_state VAR_2;
	struct rock_ridge *VAR_3;
	int VAR_4;
	int VAR_5 = 0;
	int VAR_6 = 0;
	int VAR_7 = 0;
	char *VAR_8;
	int VAR_9;

	if (!ISOFS_SB(inode->i_sb)->s_rock)
		return 0;
	*VAR_1 = 0;

	init_rock_state(&VAR_2, inode);
	setup_rock_ridge(VAR_0, inode, &VAR_2);
repeat:

	while (VAR_2.len > 2) { /* COMMENT_0 */
		VAR_3 = (struct rock_ridge *)VAR_2.chr;
		/* COMMENT_1 */
                                                           
                                                       
               
     
		if (VAR_3->len < 3)
			goto out;	/* COMMENT_6 */
		VAR_4 = isonum_721(VAR_2.chr);
		if (rock_check_overflow(&VAR_2, VAR_4))
			goto eio;
		VAR_2.chr += VAR_3->len;
		VAR_2.len -= VAR_3->len;
		/* COMMENT_7 */
                                                         
              
     
		if (VAR_2.len < 0)
			goto out;	/* COMMENT_6 */

		switch (VAR_4) {
		case SIG('R', 'R'):
			if ((VAR_3->u.RR.flags[0] & VAR_10) == 0)
				goto out;
			break;
		case SIG('S', 'P'):
			if (check_sp(VAR_3, inode))
				goto out;
			break;
		case SIG('C', 'E'):
			VAR_2.cont_extent = isonum_733(VAR_3->u.CE.extent);
			VAR_2.cont_offset = isonum_733(VAR_3->u.CE.offset);
			VAR_2.cont_size = isonum_733(VAR_3->u.CE.size);
			break;
		case SIG('N', 'M'):
			if (VAR_6)
				break;
			if (VAR_3->len < 5)
				break;
			/* COMMENT_11 */
                                                          
                                                        
                                                        
                                                    
           
      
			if (VAR_3->u.NM.flags & 6)
				break;

			if (VAR_3->u.NM.flags & ~1) {
				printk(""Unsupported NM flag settings (%d)\n"",
					VAR_3->u.NM.flags);
				break;
			}
			VAR_9 = VAR_3->len - 5;
			if (VAR_5 + VAR_9 >= 254) {
				VAR_6 = 1;
				break;
			}
			VAR_8 = memchr(VAR_3->u.NM.name, '\0', VAR_9);
			if (unlikely(VAR_8))
				VAR_9 = VAR_8 - VAR_3->u.NM.name;
			memcpy(VAR_1 + VAR_5, VAR_3->u.NM.name, VAR_9);
			VAR_5 += VAR_9;
			VAR_1[VAR_5] = '\0';
			break;
		case SIG('R', 'E'):
			kfree(VAR_2.buffer);
			return -1;
		default:
			break;
		}
	}
	VAR_7 = rock_continue(&VAR_2);
	if (VAR_7 == 0)
		goto repeat;
	if (VAR_7 == 1)
		return VAR_5; /* COMMENT_18 */
out:
	kfree(VAR_2.buffer);
	return VAR_7;
eio:
	VAR_7 = -VAR_11;
	goto out;
}",torvalds/linux/99d825822eade8d827a1817357cbf3f889a552d6/rock.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,6 +7,8 @@
 	int retnamlen = 0;
 	int truncate = 0;
 	int ret = 0;
+	char *p;
+	int len;
 
 	if (!ISOFS_SB(inode->i_sb)->s_rock)
 		return 0;
@@ -71,12 +73,17 @@
 					rr->u.NM.flags);
 				break;
 			}
-			if ((strlen(retname) + rr->len - 5) >= 254) {
+			len = rr->len - 5;
+			if (retnamlen + len >= 254) {
 				truncate = 1;
 				break;
 			}
-			strncat(retname, rr->u.NM.name, rr->len - 5);
-			retnamlen += rr->len - 5;
+			p = memchr(rr->u.NM.name, '\0', len);
+			if (unlikely(p))
+				len = p - rr->u.NM.name;
+			memcpy(retname + retnamlen, rr->u.NM.name, len);
+			retnamlen += len;
+			retname[retnamlen] = '\0';
 			break;
 		case SIG('R', 'E'):
 			kfree(rs.buffer);","{'deleted_lines': ['\t\t\tif ((strlen(retname) + rr->len - 5) >= 254) {', '\t\t\tstrncat(retname, rr->u.NM.name, rr->len - 5);', '\t\t\tretnamlen += rr->len - 5;'], 'added_lines': ['\tchar *p;', '\tint len;', '\t\t\tlen = rr->len - 5;', '\t\t\tif (retnamlen + len >= 254) {', ""\t\t\tp = memchr(rr->u.NM.name, '\\0', len);"", '\t\t\tif (unlikely(p))', '\t\t\t\tlen = p - rr->u.NM.name;', '\t\t\tmemcpy(retname + retnamlen, rr->u.NM.name, len);', '\t\t\tretnamlen += len;', ""\t\t\tretname[retnamlen] = '\\0';""]}",True,"The get_rock_ridge_filename function in fs/isofs/rock.c in the Linux kernel before 4.5.5 mishandles NM (aka alternate name) entries containing \0 characters, which allows local users to obtain sensitive information from kernel memory or possibly have unspecified other impact via a crafted isofs filesystem.",7.8,HIGH,2,test,2016-05-05T20:25:35Z,1
CVE-2016-3698,['CWE-284'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,jpirko/libndp,"libndp: validate the IPv6 hop limit

None of the NDP messages should ever come from a non-local network; as
stated in RFC4861's 6.1.1 (RS), 6.1.2 (RA), 7.1.1 (NS), 7.1.2 (NA),
and 8.1. (redirect):

  - The IP Hop Limit field has a value of 255, i.e., the packet
    could not possibly have been forwarded by a router.

This fixes CVE-2016-3698.

Reported by: Julien BERNARD <julien.bernard@viagenie.ca>
Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
Signed-off-by: Jiri Pirko <jiri@mellanox.com>",a4892df306e0532487f1634ba6d4c6d4bb381c7f,https://github.com/jpirko/libndp/commit/a4892df306e0532487f1634ba6d4c6d4bb381c7f,libndp/libndp.c,myrecvfrom6,"static int myrecvfrom6(int sockfd, void *buf, size_t *buflen, int flags,
struct in6_addr *addr, uint32_t *ifindex)
{
struct sockaddr_in6 sin6;
unsigned char cbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];
struct iovec iovec;
struct msghdr msghdr;
struct cmsghdr *cmsghdr;
ssize_t len;
iovec.iov_len = *buflen;
iovec.iov_base = buf;
memset(&msghdr, 0, sizeof(msghdr));
msghdr.msg_name = &sin6;
msghdr.msg_namelen = sizeof(sin6);
msghdr.msg_iov = &iovec;
msghdr.msg_iovlen = 1;
msghdr.msg_control = cbuf;
msghdr.msg_controllen = sizeof(cbuf);
len = recvmsg(sockfd, &msghdr, flags);
if (len == -1)
return -errno;
*buflen = len;
*ifindex = sin6.sin6_scope_id;
for (cmsghdr = CMSG_FIRSTHDR(&msghdr); cmsghdr;
cmsghdr = CMSG_NXTHDR(&msghdr, cmsghdr)) {
if (cmsghdr->cmsg_level == IPPROTO_IPV6 &&
cmsghdr->cmsg_type == IPV6_PKTINFO &&
cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {
struct in6_pktinfo *pktinfo;
pktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);
*ifindex = pktinfo->ipi6_ifindex;
}
}
*addr = sin6.sin6_addr;
return 0;
}","static int myrecvfrom6(int VAR_0, void *VAR_1, size_t *VAR_2, int VAR_3,
struct in6_addr *VAR_4, uint32_t *VAR_5)
{
struct sockaddr_in6 VAR_6;
unsigned char VAR_7[CMSG_SPACE(sizeof(struct in6_pktinfo))];
struct iovec iovec;
struct msghdr msghdr;
struct cmsghdr *cmsghdr;
ssize_t VAR_8;
iovec.iov_len = *VAR_2;
iovec.iov_base = VAR_1;
memset(&msghdr, 0, sizeof(msghdr));
msghdr.msg_name = &VAR_6;
msghdr.msg_namelen = sizeof(VAR_6);
msghdr.msg_iov = &iovec;
msghdr.msg_iovlen = 1;
msghdr.msg_control = VAR_7;
msghdr.msg_controllen = sizeof(VAR_7);
VAR_8 = recvmsg(VAR_0, &msghdr, VAR_3);
if (VAR_8 == -1)
return -VAR_9;
*VAR_2 = VAR_8;
*VAR_5 = VAR_6.sin6_scope_id;
for (cmsghdr = CMSG_FIRSTHDR(&msghdr); cmsghdr;
cmsghdr = CMSG_NXTHDR(&msghdr, cmsghdr)) {
if (cmsghdr->cmsg_level == VAR_10 &&
cmsghdr->cmsg_type == VAR_11 &&
cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {
struct in6_pktinfo *VAR_12;
VAR_12 = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);
*VAR_5 = VAR_12->ipi6_ifindex;
}
}
*VAR_4 = VAR_6.sin6_addr;
return 0;
}",jpirko/libndp/a4892df306e0532487f1634ba6d4c6d4bb381c7f/libndp.c/vul/before/0.json,"static int myrecvfrom6(int sockfd, void *buf, size_t *buflen, int flags,
		       struct in6_addr *addr, uint32_t *ifindex, int *hoplimit)
{
	struct sockaddr_in6 sin6;
	unsigned char cbuf[2 * CMSG_SPACE(sizeof(struct in6_pktinfo))];
	struct iovec iovec;
	struct msghdr msghdr;
	struct cmsghdr *cmsghdr;
	ssize_t len;

	iovec.iov_len = *buflen;
	iovec.iov_base = buf;
	memset(&msghdr, 0, sizeof(msghdr));
	msghdr.msg_name = &sin6;
	msghdr.msg_namelen = sizeof(sin6);
	msghdr.msg_iov = &iovec;
	msghdr.msg_iovlen = 1;
	msghdr.msg_control = cbuf;
	msghdr.msg_controllen = sizeof(cbuf);

	len = recvmsg(sockfd, &msghdr, flags);
	if (len == -1)
		return -errno;
	*buflen = len;

	/* Set ifindex to scope_id now. But since scope_id gets not
	 * set by kernel for linklocal addresses, use pktinfo to obtain that
	 * value right after.
	 */
	*ifindex = sin6.sin6_scope_id;
        for (cmsghdr = CMSG_FIRSTHDR(&msghdr); cmsghdr;
	     cmsghdr = CMSG_NXTHDR(&msghdr, cmsghdr)) {
		if (cmsghdr->cmsg_level != IPPROTO_IPV6)
			continue;

		switch(cmsghdr->cmsg_type) {
		case IPV6_PKTINFO:
			if (cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {
				struct in6_pktinfo *pktinfo;

				pktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);
				*ifindex = pktinfo->ipi6_ifindex;
			}
			break;
		case IPV6_HOPLIMIT:
			if (cmsghdr->cmsg_len == CMSG_LEN(sizeof(int))) {
				int *val;

				val = (int *) CMSG_DATA(cmsghdr);
				*hoplimit = *val;
			}
			break;
		}
	}
	*addr = sin6.sin6_addr;

	return 0;
}","static int myrecvfrom6(int VAR_0, void *VAR_1, size_t *VAR_2, int VAR_3,
		       struct in6_addr *VAR_4, uint32_t *VAR_5, int *VAR_6)
{
	struct sockaddr_in6 VAR_7;
	unsigned char VAR_8[2 * CMSG_SPACE(sizeof(struct in6_pktinfo))];
	struct iovec iovec;
	struct msghdr msghdr;
	struct cmsghdr *cmsghdr;
	ssize_t VAR_9;

	iovec.iov_len = *VAR_2;
	iovec.iov_base = VAR_1;
	memset(&msghdr, 0, sizeof(msghdr));
	msghdr.msg_name = &VAR_7;
	msghdr.msg_namelen = sizeof(VAR_7);
	msghdr.msg_iov = &iovec;
	msghdr.msg_iovlen = 1;
	msghdr.msg_control = VAR_8;
	msghdr.msg_controllen = sizeof(VAR_8);

	VAR_9 = recvmsg(VAR_0, &msghdr, VAR_3);
	if (VAR_9 == -1)
		return -VAR_10;
	*VAR_2 = VAR_9;

	/* COMMENT_0 */
                                                                     
                      
    
	*VAR_5 = VAR_7.sin6_scope_id;
        for (cmsghdr = CMSG_FIRSTHDR(&msghdr); cmsghdr;
	     cmsghdr = CMSG_NXTHDR(&msghdr, cmsghdr)) {
		if (cmsghdr->cmsg_level != VAR_11)
			continue;

		switch(cmsghdr->cmsg_type) {
		case VAR_12:
			if (cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {
				struct in6_pktinfo *VAR_13;

				VAR_13 = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);
				*VAR_5 = VAR_13->ipi6_ifindex;
			}
			break;
		case VAR_14:
			if (cmsghdr->cmsg_len == CMSG_LEN(sizeof(int))) {
				int *VAR_15;

				VAR_15 = (int *) CMSG_DATA(cmsghdr);
				*VAR_6 = *VAR_15;
			}
			break;
		}
	}
	*VAR_4 = VAR_7.sin6_addr;

	return 0;
}",jpirko/libndp/a4892df306e0532487f1634ba6d4c6d4bb381c7f/libndp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,8 +1,8 @@
 static int myrecvfrom6(int sockfd, void *buf, size_t *buflen, int flags,
-		       struct in6_addr *addr, uint32_t *ifindex)
+		       struct in6_addr *addr, uint32_t *ifindex, int *hoplimit)
 {
 	struct sockaddr_in6 sin6;
-	unsigned char cbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];
+	unsigned char cbuf[2 * CMSG_SPACE(sizeof(struct in6_pktinfo))];
 	struct iovec iovec;
 	struct msghdr msghdr;
 	struct cmsghdr *cmsghdr;
@@ -30,13 +30,26 @@
 	*ifindex = sin6.sin6_scope_id;
         for (cmsghdr = CMSG_FIRSTHDR(&msghdr); cmsghdr;
 	     cmsghdr = CMSG_NXTHDR(&msghdr, cmsghdr)) {
-		if (cmsghdr->cmsg_level == IPPROTO_IPV6 &&
-		    cmsghdr->cmsg_type == IPV6_PKTINFO &&
-		    cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {
-			struct in6_pktinfo *pktinfo;
+		if (cmsghdr->cmsg_level != IPPROTO_IPV6)
+			continue;
 
-			pktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);
-			*ifindex = pktinfo->ipi6_ifindex;
+		switch(cmsghdr->cmsg_type) {
+		case IPV6_PKTINFO:
+			if (cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {
+				struct in6_pktinfo *pktinfo;
+
+				pktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);
+				*ifindex = pktinfo->ipi6_ifindex;
+			}
+			break;
+		case IPV6_HOPLIMIT:
+			if (cmsghdr->cmsg_len == CMSG_LEN(sizeof(int))) {
+				int *val;
+
+				val = (int *) CMSG_DATA(cmsghdr);
+				*hoplimit = *val;
+			}
+			break;
 		}
 	}
 	*addr = sin6.sin6_addr;","{'deleted_lines': ['\t\t       struct in6_addr *addr, uint32_t *ifindex)', '\tunsigned char cbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];', '\t\tif (cmsghdr->cmsg_level == IPPROTO_IPV6 &&', '\t\t    cmsghdr->cmsg_type == IPV6_PKTINFO &&', '\t\t    cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {', '\t\t\tstruct in6_pktinfo *pktinfo;', '\t\t\tpktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);', '\t\t\t*ifindex = pktinfo->ipi6_ifindex;'], 'added_lines': ['\t\t       struct in6_addr *addr, uint32_t *ifindex, int *hoplimit)', '\tunsigned char cbuf[2 * CMSG_SPACE(sizeof(struct in6_pktinfo))];', '\t\tif (cmsghdr->cmsg_level != IPPROTO_IPV6)', '\t\t\tcontinue;', '\t\tswitch(cmsghdr->cmsg_type) {', '\t\tcase IPV6_PKTINFO:', '\t\t\tif (cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {', '\t\t\t\tstruct in6_pktinfo *pktinfo;', '', '\t\t\t\tpktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);', '\t\t\t\t*ifindex = pktinfo->ipi6_ifindex;', '\t\t\t}', '\t\t\tbreak;', '\t\tcase IPV6_HOPLIMIT:', '\t\t\tif (cmsghdr->cmsg_len == CMSG_LEN(sizeof(int))) {', '\t\t\t\tint *val;', '', '\t\t\t\tval = (int *) CMSG_DATA(cmsghdr);', '\t\t\t\t*hoplimit = *val;', '\t\t\t}', '\t\t\tbreak;']}",True,"libndp before 1.6, as used in NetworkManager, does not properly validate the origin of Neighbor Discovery Protocol (NDP) messages, which allows remote attackers to conduct man-in-the-middle attacks or cause a denial of service (network connectivity disruption) by advertising a node as a router from a non-local network.",8.1,HIGH,2,test,2016-05-17T10:17:53Z,1
CVE-2016-3698,['CWE-284'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,jpirko/libndp,"libndp: validate the IPv6 hop limit

None of the NDP messages should ever come from a non-local network; as
stated in RFC4861's 6.1.1 (RS), 6.1.2 (RA), 7.1.1 (NS), 7.1.2 (NA),
and 8.1. (redirect):

  - The IP Hop Limit field has a value of 255, i.e., the packet
    could not possibly have been forwarded by a router.

This fixes CVE-2016-3698.

Reported by: Julien BERNARD <julien.bernard@viagenie.ca>
Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
Signed-off-by: Jiri Pirko <jiri@mellanox.com>",a4892df306e0532487f1634ba6d4c6d4bb381c7f,https://github.com/jpirko/libndp/commit/a4892df306e0532487f1634ba6d4c6d4bb381c7f,libndp/libndp.c,ndp_sock_open,"static int ndp_sock_open(struct ndp *ndp)
{
int sock;
int ret;
int err;
int val;
sock = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);
if (sock == -1) {
err(ndp, ""Failed to create ICMP6 socket."");
return -errno;
}
val = 1;
ret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVPKTINFO,
&val, sizeof(val));
if (ret == -1) {
err(ndp, ""Failed to setsockopt IPV6_RECVPKTINFO."");
err = -errno;
goto close_sock;
}
val = 255;
ret = setsockopt(sock, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
&val, sizeof(val));
if (ret == -1) {
err(ndp, ""Failed to setsockopt IPV6_MULTICAST_HOPS."");
err = -errno;
goto close_sock;
}
ndp->sock = sock;
return 0;
close_sock:
close(sock);
return err;
}","static int ndp_sock_open(struct ndp *ndp)
{
int VAR_0;
int VAR_1;
int VAR_2;
int VAR_3;
VAR_0 = socket(VAR_4, VAR_5, VAR_6);
if (VAR_0 == -1) {
VAR_2(ndp, ""Failed to create ICMP6 socket."");
return -VAR_7;
}
VAR_3 = 1;
VAR_1 = setsockopt(VAR_0, VAR_8, VAR_9,
&VAR_3, sizeof(VAR_3));
if (VAR_1 == -1) {
VAR_2(ndp, ""Failed to setsockopt IPV6_RECVPKTINFO."");
VAR_2 = -VAR_7;
goto close_sock;
}
VAR_3 = 255;
VAR_1 = setsockopt(VAR_0, VAR_8, VAR_10,
&VAR_3, sizeof(VAR_3));
if (VAR_1 == -1) {
VAR_2(ndp, ""Failed to setsockopt IPV6_MULTICAST_HOPS."");
VAR_2 = -VAR_7;
goto close_sock;
}
ndp->sock = VAR_0;
return 0;
close_sock:
close(VAR_0);
return VAR_2;
}",jpirko/libndp/a4892df306e0532487f1634ba6d4c6d4bb381c7f/libndp.c/vul/before/1.json,"static int ndp_sock_open(struct ndp *ndp)
{
	int sock;
	//struct icmp6_filter flt;
	int ret;
	int err;
	int val;

	sock = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);
	if (sock == -1) {
		err(ndp, ""Failed to create ICMP6 socket."");
		return -errno;
	}

	val = 1;
	ret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVPKTINFO,
			 &val, sizeof(val));
	if (ret == -1) {
		err(ndp, ""Failed to setsockopt IPV6_RECVPKTINFO."");
		err = -errno;
		goto close_sock;
	}

	val = 255;
	ret = setsockopt(sock, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
			 &val, sizeof(val));
	if (ret == -1) {
		err(ndp, ""Failed to setsockopt IPV6_MULTICAST_HOPS."");
		err = -errno;
		goto close_sock;
	}

	val = 1;
	ret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVHOPLIMIT,
			 &val, sizeof(val));
	if (ret == -1) {
		err(ndp, ""Failed to setsockopt IPV6_RECVHOPLIMIT,."");
		err = -errno;
		goto close_sock;
	}

	ndp->sock = sock;
	return 0;
close_sock:
	close(sock);
	return err;
}","static int ndp_sock_open(struct ndp *ndp)
{
	int VAR_0;
	/* COMMENT_0 */
	int VAR_1;
	int VAR_2;
	int VAR_3;

	VAR_0 = socket(VAR_4, VAR_5, VAR_6);
	if (VAR_0 == -1) {
		VAR_2(ndp, ""Failed to create ICMP6 socket."");
		return -VAR_7;
	}

	VAR_3 = 1;
	VAR_1 = setsockopt(VAR_0, VAR_8, VAR_9,
			 &VAR_3, sizeof(VAR_3));
	if (VAR_1 == -1) {
		VAR_2(ndp, ""Failed to setsockopt IPV6_RECVPKTINFO."");
		VAR_2 = -VAR_7;
		goto close_sock;
	}

	VAR_3 = 255;
	VAR_1 = setsockopt(VAR_0, VAR_8, VAR_10,
			 &VAR_3, sizeof(VAR_3));
	if (VAR_1 == -1) {
		VAR_2(ndp, ""Failed to setsockopt IPV6_MULTICAST_HOPS."");
		VAR_2 = -VAR_7;
		goto close_sock;
	}

	VAR_3 = 1;
	VAR_1 = setsockopt(VAR_0, VAR_8, VAR_11,
			 &VAR_3, sizeof(VAR_3));
	if (VAR_1 == -1) {
		VAR_2(ndp, ""Failed to setsockopt IPV6_RECVHOPLIMIT,."");
		VAR_2 = -VAR_7;
		goto close_sock;
	}

	ndp->sock = VAR_0;
	return 0;
close_sock:
	close(VAR_0);
	return VAR_2;
}",jpirko/libndp/a4892df306e0532487f1634ba6d4c6d4bb381c7f/libndp.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -30,6 +30,15 @@
 		goto close_sock;
 	}
 
+	val = 1;
+	ret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVHOPLIMIT,
+			 &val, sizeof(val));
+	if (ret == -1) {
+		err(ndp, ""Failed to setsockopt IPV6_RECVHOPLIMIT,."");
+		err = -errno;
+		goto close_sock;
+	}
+
 	ndp->sock = sock;
 	return 0;
 close_sock:","{'deleted_lines': [], 'added_lines': ['\tval = 1;', '\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVHOPLIMIT,', '\t\t\t &val, sizeof(val));', '\tif (ret == -1) {', '\t\terr(ndp, ""Failed to setsockopt IPV6_RECVHOPLIMIT,."");', '\t\terr = -errno;', '\t\tgoto close_sock;', '\t}', '']}",True,"libndp before 1.6, as used in NetworkManager, does not properly validate the origin of Neighbor Discovery Protocol (NDP) messages, which allows remote attackers to conduct man-in-the-middle attacks or cause a denial of service (network connectivity disruption) by advertising a node as a router from a non-local network.",8.1,HIGH,2,test,2016-05-17T10:17:53Z,1
CVE-2016-3698,['CWE-284'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,jpirko/libndp,"libndp: validate the IPv6 hop limit

None of the NDP messages should ever come from a non-local network; as
stated in RFC4861's 6.1.1 (RS), 6.1.2 (RA), 7.1.1 (NS), 7.1.2 (NA),
and 8.1. (redirect):

  - The IP Hop Limit field has a value of 255, i.e., the packet
    could not possibly have been forwarded by a router.

This fixes CVE-2016-3698.

Reported by: Julien BERNARD <julien.bernard@viagenie.ca>
Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
Signed-off-by: Jiri Pirko <jiri@mellanox.com>",a4892df306e0532487f1634ba6d4c6d4bb381c7f,https://github.com/jpirko/libndp/commit/a4892df306e0532487f1634ba6d4c6d4bb381c7f,libndp/libndp.c,ndp_sock_recv,"static int ndp_sock_recv(struct ndp *ndp)
{
struct ndp_msg *msg;
enum ndp_msg_type msg_type;
size_t len;
int err;
msg = ndp_msg_alloc();
if (!msg)
return -ENOMEM;
len = ndp_msg_payload_maxlen(msg);
err = myrecvfrom6(ndp->sock, msg->buf, &len, 0,
&msg->addrto, &msg->ifindex);
if (err) {
err(ndp, ""Failed to receive message"");
goto free_msg;
}
dbg(ndp, ""rcvd from: %s, ifindex: %u"",
str_in6_addr(&msg->addrto), msg->ifindex);
if (len < sizeof(*msg->icmp6_hdr)) {
warn(ndp, ""rcvd icmp6 packet too short (%luB)"", len);
err = 0;
goto free_msg;
}
err = ndp_msg_type_by_raw_type(&msg_type, msg->icmp6_hdr->icmp6_type);
if (err) {
err = 0;
goto free_msg;
}
ndp_msg_init(msg, msg_type);
ndp_msg_payload_len_set(msg, len);
if (!ndp_msg_check_valid(msg)) {
warn(ndp, ""rcvd invalid ND message"");
err = 0;
goto free_msg;
}
dbg(ndp, ""rcvd %s, len: %zuB"",
ndp_msg_type_info(msg_type)->strabbr, len);
if (!ndp_msg_check_opts(msg)) {
err = 0;
goto free_msg;
}
err = ndp_call_handlers(ndp, msg);;
free_msg:
ndp_msg_destroy(msg);
return err;
}","static int ndp_sock_recv(struct ndp *ndp)
{
struct ndp_msg *VAR_0;
enum ndp_msg_type VAR_1;
size_t VAR_2;
int VAR_3;
VAR_0 = ndp_msg_alloc();
if (!VAR_0)
return -VAR_4;
VAR_2 = ndp_msg_payload_maxlen(VAR_0);
VAR_3 = myrecvfrom6(ndp->sock, VAR_0->buf, &VAR_2, 0,
&VAR_0->addrto, &VAR_0->ifindex);
if (VAR_3) {
VAR_3(ndp, ""Failed to receive message"");
goto free_msg;
}
dbg(ndp, ""rcvd from: %s, ifindex: %u"",
str_in6_addr(&VAR_0->addrto), VAR_0->ifindex);
if (VAR_2 < sizeof(*VAR_0->icmp6_hdr)) {
warn(ndp, ""rcvd icmp6 packet too short (%luB)"", VAR_2);
VAR_3 = 0;
goto free_msg;
}
VAR_3 = ndp_msg_type_by_raw_type(&VAR_1, VAR_0->icmp6_hdr->icmp6_type);
if (VAR_3) {
VAR_3 = 0;
goto free_msg;
}
ndp_msg_init(VAR_0, VAR_1);
ndp_msg_payload_len_set(VAR_0, VAR_2);
if (!ndp_msg_check_valid(VAR_0)) {
warn(ndp, ""rcvd invalid ND message"");
VAR_3 = 0;
goto free_msg;
}
dbg(ndp, ""rcvd %s, len: %zuB"",
ndp_msg_type_info(VAR_1)->strabbr, VAR_2);
if (!ndp_msg_check_opts(VAR_0)) {
VAR_3 = 0;
goto free_msg;
}
VAR_3 = ndp_call_handlers(ndp, VAR_0);;
free_msg:
ndp_msg_destroy(VAR_0);
return VAR_3;
}",jpirko/libndp/a4892df306e0532487f1634ba6d4c6d4bb381c7f/libndp.c/vul/before/2.json,"static int ndp_sock_recv(struct ndp *ndp)
{
	struct ndp_msg *msg;
	enum ndp_msg_type msg_type;
	size_t len;
	int err;

	msg = ndp_msg_alloc();
	if (!msg)
		return -ENOMEM;

	len = ndp_msg_payload_maxlen(msg);
	err = myrecvfrom6(ndp->sock, msg->buf, &len, 0,
			  &msg->addrto, &msg->ifindex, &msg->hoplimit);
	if (err) {
		err(ndp, ""Failed to receive message"");
		goto free_msg;
	}
	dbg(ndp, ""rcvd from: %s, ifindex: %u, hoplimit: %d"",
		 str_in6_addr(&msg->addrto), msg->ifindex, msg->hoplimit);

	if (msg->hoplimit != 255) {
		warn(ndp, ""ignoring packet with bad hop limit (%d)"", msg->hoplimit);
		err = 0;
		goto free_msg;
	}

	if (len < sizeof(*msg->icmp6_hdr)) {
		warn(ndp, ""rcvd icmp6 packet too short (%luB)"", len);
		err = 0;
		goto free_msg;
	}
	err = ndp_msg_type_by_raw_type(&msg_type, msg->icmp6_hdr->icmp6_type);
	if (err) {
		err = 0;
		goto free_msg;
	}
	ndp_msg_init(msg, msg_type);
	ndp_msg_payload_len_set(msg, len);

	if (!ndp_msg_check_valid(msg)) {
		warn(ndp, ""rcvd invalid ND message"");
		err = 0;
		goto free_msg;
	}

	dbg(ndp, ""rcvd %s, len: %zuB"",
		 ndp_msg_type_info(msg_type)->strabbr, len);

	if (!ndp_msg_check_opts(msg)) {
		err = 0;
		goto free_msg;
	}

	err = ndp_call_handlers(ndp, msg);;

free_msg:
	ndp_msg_destroy(msg);
	return err;
}","static int ndp_sock_recv(struct ndp *ndp)
{
	struct ndp_msg *VAR_0;
	enum ndp_msg_type VAR_1;
	size_t VAR_2;
	int VAR_3;

	VAR_0 = ndp_msg_alloc();
	if (!VAR_0)
		return -VAR_4;

	VAR_2 = ndp_msg_payload_maxlen(VAR_0);
	VAR_3 = myrecvfrom6(ndp->sock, VAR_0->buf, &VAR_2, 0,
			  &VAR_0->addrto, &VAR_0->ifindex, &VAR_0->hoplimit);
	if (VAR_3) {
		VAR_3(ndp, ""Failed to receive message"");
		goto free_msg;
	}
	dbg(ndp, ""rcvd from: %s, ifindex: %u, hoplimit: %d"",
		 str_in6_addr(&VAR_0->addrto), VAR_0->ifindex, VAR_0->hoplimit);

	if (VAR_0->hoplimit != 255) {
		warn(ndp, ""ignoring packet with bad hop limit (%d)"", VAR_0->hoplimit);
		VAR_3 = 0;
		goto free_msg;
	}

	if (VAR_2 < sizeof(*VAR_0->icmp6_hdr)) {
		warn(ndp, ""rcvd icmp6 packet too short (%luB)"", VAR_2);
		VAR_3 = 0;
		goto free_msg;
	}
	VAR_3 = ndp_msg_type_by_raw_type(&VAR_1, VAR_0->icmp6_hdr->icmp6_type);
	if (VAR_3) {
		VAR_3 = 0;
		goto free_msg;
	}
	ndp_msg_init(VAR_0, VAR_1);
	ndp_msg_payload_len_set(VAR_0, VAR_2);

	if (!ndp_msg_check_valid(VAR_0)) {
		warn(ndp, ""rcvd invalid ND message"");
		VAR_3 = 0;
		goto free_msg;
	}

	dbg(ndp, ""rcvd %s, len: %zuB"",
		 ndp_msg_type_info(VAR_1)->strabbr, VAR_2);

	if (!ndp_msg_check_opts(VAR_0)) {
		VAR_3 = 0;
		goto free_msg;
	}

	VAR_3 = ndp_call_handlers(ndp, VAR_0);;

free_msg:
	ndp_msg_destroy(VAR_0);
	return VAR_3;
}",jpirko/libndp/a4892df306e0532487f1634ba6d4c6d4bb381c7f/libndp.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -11,13 +11,19 @@
 
 	len = ndp_msg_payload_maxlen(msg);
 	err = myrecvfrom6(ndp->sock, msg->buf, &len, 0,
-			  &msg->addrto, &msg->ifindex);
+			  &msg->addrto, &msg->ifindex, &msg->hoplimit);
 	if (err) {
 		err(ndp, ""Failed to receive message"");
 		goto free_msg;
 	}
-	dbg(ndp, ""rcvd from: %s, ifindex: %u"",
-		 str_in6_addr(&msg->addrto), msg->ifindex);
+	dbg(ndp, ""rcvd from: %s, ifindex: %u, hoplimit: %d"",
+		 str_in6_addr(&msg->addrto), msg->ifindex, msg->hoplimit);
+
+	if (msg->hoplimit != 255) {
+		warn(ndp, ""ignoring packet with bad hop limit (%d)"", msg->hoplimit);
+		err = 0;
+		goto free_msg;
+	}
 
 	if (len < sizeof(*msg->icmp6_hdr)) {
 		warn(ndp, ""rcvd icmp6 packet too short (%luB)"", len);","{'deleted_lines': ['\t\t\t  &msg->addrto, &msg->ifindex);', '\tdbg(ndp, ""rcvd from: %s, ifindex: %u"",', '\t\t str_in6_addr(&msg->addrto), msg->ifindex);'], 'added_lines': ['\t\t\t  &msg->addrto, &msg->ifindex, &msg->hoplimit);', '\tdbg(ndp, ""rcvd from: %s, ifindex: %u, hoplimit: %d"",', '\t\t str_in6_addr(&msg->addrto), msg->ifindex, msg->hoplimit);', '', '\tif (msg->hoplimit != 255) {', '\t\twarn(ndp, ""ignoring packet with bad hop limit (%d)"", msg->hoplimit);', '\t\terr = 0;', '\t\tgoto free_msg;', '\t}']}",True,"libndp before 1.6, as used in NetworkManager, does not properly validate the origin of Neighbor Discovery Protocol (NDP) messages, which allows remote attackers to conduct man-in-the-middle attacks or cause a denial of service (network connectivity disruption) by advertising a node as a router from a non-local network.",8.1,HIGH,2,test,2016-05-17T10:17:53Z,1
CVE-2016-3698,['CWE-284'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,jpirko/libndp,"libndb: reject redirect and router advertisements from non-link-local

RFC4861 suggests that these messages should only originate from
link-local addresses in 6.1.2 (RA) and 8.1. (redirect):

Mitigates CVE-2016-3698.

Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
Signed-off-by: Jiri Pirko <jiri@mellanox.com>",2af9a55b38b55abbf05fd116ec097d4029115839,https://github.com/jpirko/libndp/commit/2af9a55b38b55abbf05fd116ec097d4029115839,libndp/libndp.c,ndp_msg_check_valid,"static bool ndp_msg_check_valid(struct ndp_msg *msg)
{
size_t len = ndp_msg_payload_len(msg);
enum ndp_msg_type msg_type = ndp_msg_type(msg);
if (len < ndp_msg_type_info(msg_type)->raw_struct_size)
return false;
return true;
}","static bool ndp_msg_check_valid(struct ndp_msg *VAR_0)
{
size_t VAR_1 = ndp_msg_payload_len(VAR_0);
enum ndp_msg_type VAR_2 = ndp_msg_type(VAR_0);
if (VAR_1 < ndp_msg_type_info(VAR_2)->raw_struct_size)
return false;
return true;
}",jpirko/libndp/2af9a55b38b55abbf05fd116ec097d4029115839/libndp.c/vul/before/0.json,"static bool ndp_msg_check_valid(struct ndp_msg *msg)
{
	size_t len = ndp_msg_payload_len(msg);
	enum ndp_msg_type msg_type = ndp_msg_type(msg);

	if (len < ndp_msg_type_info(msg_type)->raw_struct_size)
		return false;

	if (ndp_msg_type_info(msg_type)->addrto_validate)
		return ndp_msg_type_info(msg_type)->addrto_validate(&msg->addrto);
	else
		return true;
}","static bool ndp_msg_check_valid(struct ndp_msg *VAR_0)
{
	size_t VAR_1 = ndp_msg_payload_len(VAR_0);
	enum ndp_msg_type VAR_2 = ndp_msg_type(VAR_0);

	if (VAR_1 < ndp_msg_type_info(VAR_2)->raw_struct_size)
		return false;

	if (ndp_msg_type_info(VAR_2)->addrto_validate)
		return ndp_msg_type_info(VAR_2)->addrto_validate(&VAR_0->addrto);
	else
		return true;
}",jpirko/libndp/2af9a55b38b55abbf05fd116ec097d4029115839/libndp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,5 +5,9 @@
 
 	if (len < ndp_msg_type_info(msg_type)->raw_struct_size)
 		return false;
-	return true;
+
+	if (ndp_msg_type_info(msg_type)->addrto_validate)
+		return ndp_msg_type_info(msg_type)->addrto_validate(&msg->addrto);
+	else
+		return true;
 }","{'deleted_lines': ['\treturn true;'], 'added_lines': ['', '\tif (ndp_msg_type_info(msg_type)->addrto_validate)', '\t\treturn ndp_msg_type_info(msg_type)->addrto_validate(&msg->addrto);', '\telse', '\t\treturn true;']}",True,"libndp before 1.6, as used in NetworkManager, does not properly validate the origin of Neighbor Discovery Protocol (NDP) messages, which allows remote attackers to conduct man-in-the-middle attacks or cause a denial of service (network connectivity disruption) by advertising a node as a router from a non-local network.",8.1,HIGH,2,test,2016-05-17T10:17:54Z,1
CVE-2016-3713,['CWE-284'],AV:L/AC:L/Au:N/C:P/I:N/A:C,0,torvalds/linux,"KVM: MTRR: remove MSR 0x2f8

MSR 0x2f8 accessed the 124th Variable Range MTRR ever since MTRR support
was introduced by 9ba075a664df (""KVM: MTRR support"").

0x2f8 became harmful when 910a6aae4e2e (""KVM: MTRR: exactly define the
size of variable MTRRs"") shrinked the array of VR MTRRs from 256 to 8,
which made access to index 124 out of bounds.  The surrounding code only
WARNs in this situation, thus the guest gained a limited read/write
access to struct kvm_arch_vcpu.

0x2f8 is not a valid VR MTRR MSR, because KVM has/advertises only 16 VR
MTRR MSRs, 0x200-0x20f.  Every VR MTRR is set up using two MSRs, 0x2f8
was treated as a PHYSBASE and 0x2f9 would be its PHYSMASK, but 0x2f9 was
not implemented in KVM, therefore 0x2f8 could never do anything useful
and getting rid of it is safe.

This fixes CVE-2016-3713.

Fixes: 910a6aae4e2e (""KVM: MTRR: exactly define the size of variable MTRRs"")
Cc: stable@vger.kernel.org
Reported-by: David Matlack <dmatlack@google.com>
Signed-off-by: Andy Honig <ahonig@google.com>
Signed-off-by: Radim Krm <rkrcmar@redhat.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>",9842df62004f366b9fed2423e24df10542ee0dc5,https://github.com/torvalds/linux/commit/9842df62004f366b9fed2423e24df10542ee0dc5,arch/x86/kvm/mtrr.c,msr_mtrr_valid,"static bool msr_mtrr_valid(unsigned msr)
{
switch (msr) {
case 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:
case MSR_MTRRfix64K_00000:
case MSR_MTRRfix16K_80000:
case MSR_MTRRfix16K_A0000:
case MSR_MTRRfix4K_C0000:
case MSR_MTRRfix4K_C8000:
case MSR_MTRRfix4K_D0000:
case MSR_MTRRfix4K_D8000:
case MSR_MTRRfix4K_E0000:
case MSR_MTRRfix4K_E8000:
case MSR_MTRRfix4K_F0000:
case MSR_MTRRfix4K_F8000:
case MSR_MTRRdefType:
case MSR_IA32_CR_PAT:
return true;
case 0x2f8:
return true;
}
return false;
}","static bool msr_mtrr_valid(unsigned VAR_0)
{
switch (VAR_0) {
case 0x200 ... 0x200 + 2 * VAR_1 - 1:
case VAR_2:
case VAR_3:
case VAR_4:
case VAR_5:
case VAR_6:
case VAR_7:
case VAR_8:
case VAR_9:
case VAR_10:
case VAR_11:
case VAR_12:
case VAR_13:
case VAR_14:
return true;
case 0x2f8:
return true;
}
return false;
}",torvalds/linux/9842df62004f366b9fed2423e24df10542ee0dc5/mtrr.c/vul/before/0.json,"static bool msr_mtrr_valid(unsigned msr)
{
	switch (msr) {
	case 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:
	case MSR_MTRRfix64K_00000:
	case MSR_MTRRfix16K_80000:
	case MSR_MTRRfix16K_A0000:
	case MSR_MTRRfix4K_C0000:
	case MSR_MTRRfix4K_C8000:
	case MSR_MTRRfix4K_D0000:
	case MSR_MTRRfix4K_D8000:
	case MSR_MTRRfix4K_E0000:
	case MSR_MTRRfix4K_E8000:
	case MSR_MTRRfix4K_F0000:
	case MSR_MTRRfix4K_F8000:
	case MSR_MTRRdefType:
	case MSR_IA32_CR_PAT:
		return true;
	}
	return false;
}","static bool msr_mtrr_valid(unsigned VAR_0)
{
	switch (VAR_0) {
	case 0x200 ... 0x200 + 2 * VAR_1 - 1:
	case VAR_2:
	case VAR_3:
	case VAR_4:
	case VAR_5:
	case VAR_6:
	case VAR_7:
	case VAR_8:
	case VAR_9:
	case VAR_10:
	case VAR_11:
	case VAR_12:
	case VAR_13:
	case VAR_14:
		return true;
	}
	return false;
}",torvalds/linux/9842df62004f366b9fed2423e24df10542ee0dc5/mtrr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -16,8 +16,6 @@
 	case MSR_MTRRdefType:
 	case MSR_IA32_CR_PAT:
 		return true;
-	case 0x2f8:
-		return true;
 	}
 	return false;
 }","{'deleted_lines': ['\tcase 0x2f8:', '\t\treturn true;'], 'added_lines': []}",True,"The msr_mtrr_valid function in arch/x86/kvm/mtrr.c in the Linux kernel before 4.6.1 supports MSR 0x2f8, which allows guest OS users to read or write to the kvm_arch_vcpu data structure, and consequently obtain sensitive information or cause a denial of service (system crash), via a crafted ioctl call.",7.1,HIGH,2,test,2016-05-17T15:41:47Z,1
CVE-2016-5093,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #72241: get_icu_value_internal out-of-bounds read,97eff7eb57fc2320c267a949cffd622c38712484,https://github.com/php/php-src/commit/97eff7eb57fc2320c267a949cffd622c38712484,ext/intl/locale/locale_methods.c,add_array_entry,"static int add_array_entry(const char* loc_name, zval* hash_arr, char* key_name TSRMLS_DC)
{
char*   key_value = NULL;
char*   cur_key_name= NULL;
char*   token        = NULL;
char*   last_ptr  = NULL;
intresult= 0;
int cur_result  = 0;
int cnt  = 0;
if( strcmp(key_name , LOC_PRIVATE_TAG)==0 ){
key_value = get_private_subtags( loc_name );
result = 1;
} else {
key_value = get_icu_value_internal( loc_name , key_name , &result,1 );
}
if( (strcmp(key_name , LOC_PRIVATE_TAG)==0) || 
( strcmp(key_name , LOC_VARIANT_TAG)==0) ){
if( result > 0 && key_value){
token = php_strtok_r( key_value , DELIMITER ,&last_ptr);
if( cur_key_name ){
efree( cur_key_name);
}
cur_key_name = (char*)ecalloc( 25,  25);
sprintf( cur_key_name , ""%s%d"", key_name , cnt++);
add_assoc_string( hash_arr, cur_key_name , token ,TRUE );
while( (token = php_strtok_r(NULL , DELIMITER , &last_ptr)) && (strlen(token)>1) ){
sprintf( cur_key_name , ""%s%d"", key_name , cnt++);
add_assoc_string( hash_arr, cur_key_name , token , TRUE );
}
}
} else {
if( result == 1 ){
add_assoc_string( hash_arr, key_name , key_value , TRUE );
cur_result = 1;
}
}
if( cur_key_name ){
efree( cur_key_name);
}
if( key_value){
efree(key_value);
}
return cur_result;
}","static int add_array_entry(const char* VAR_0, zval* VAR_1, char* VAR_2 TSRMLS_DC)
{
char*   VAR_3 = NULL;
char*   VAR_4= NULL;
char*   VAR_5        = NULL;
char*   VAR_6  = NULL;
intVAR_7= 0;
int VAR_8  = 0;
int VAR_9  = 0;
if( strcmp(VAR_2 , VAR_10)==0 ){
VAR_3 = get_private_subtags( VAR_0 );
VAR_7 = 1;
} else {
VAR_3 = get_icu_value_internal( VAR_0 , VAR_2 , &VAR_7,1 );
}
if( (strcmp(VAR_2 , VAR_10)==0) || 
( strcmp(VAR_2 , VAR_11)==0) ){
if( VAR_7 > 0 && VAR_3){
VAR_5 = php_strtok_r( VAR_3 , VAR_12 ,&VAR_6);
if( VAR_4 ){
efree( VAR_4);
}
VAR_4 = (char*)ecalloc( 25,  25);
sprintf( VAR_4 , ""%s%d"", VAR_2 , VAR_9++);
add_assoc_string( VAR_1, VAR_4 , VAR_5 ,TRUE );
while( (VAR_5 = php_strtok_r(NULL , VAR_12 , &VAR_6)) && (strlen(VAR_5)>1) ){
sprintf( VAR_4 , ""%s%d"", VAR_2 , VAR_9++);
add_assoc_string( VAR_1, VAR_4 , VAR_5 , TRUE );
}
}
} else {
if( VAR_7 == 1 ){
add_assoc_string( VAR_1, VAR_2 , VAR_3 , TRUE );
VAR_8 = 1;
}
}
if( VAR_4 ){
efree( VAR_4);
}
if( VAR_3){
efree(VAR_3);
}
return VAR_8;
}",,"static int add_array_entry(const char* loc_name, zval* hash_arr, char* key_name TSRMLS_DC)
{
	char*   key_value 	= NULL;
	char*   cur_key_name	= NULL;
	char*   token        	= NULL;
	char*   last_ptr  	= NULL;

	int	result		= 0;
	int 	cur_result  	= 0;
	int 	cnt  		= 0;


	if( strcmp(key_name , LOC_PRIVATE_TAG)==0 ){
		key_value = get_private_subtags( loc_name );
		result = 1;
	} else {
		key_value = get_icu_value_internal( loc_name , key_name , &result,1 );
	}
	if( (strcmp(key_name , LOC_PRIVATE_TAG)==0) ||
		( strcmp(key_name , LOC_VARIANT_TAG)==0) ){
		if( result > 0 && key_value){
			/* Tokenize on the ""_"" or ""-""  */
			token = php_strtok_r( key_value , DELIMITER ,&last_ptr);
			if( cur_key_name ){
				efree( cur_key_name);
			}
			cur_key_name = (char*)ecalloc( 25,  25);
			sprintf( cur_key_name , ""%s%d"", key_name , cnt++);
			add_assoc_string( hash_arr, cur_key_name , token ,TRUE );
			/* tokenize on the ""_"" or ""-"" and stop  at singleton if any */
			while( (token = php_strtok_r(NULL , DELIMITER , &last_ptr)) && (strlen(token)>1) ){
				sprintf( cur_key_name , ""%s%d"", key_name , cnt++);
				add_assoc_string( hash_arr, cur_key_name , token , TRUE );
			}
/*
			if( strcmp(key_name, LOC_PRIVATE_TAG) == 0 ){
			}
*/
		}
	} else {
		if( result == 1 ){
			add_assoc_string( hash_arr, key_name , key_value , TRUE );
			cur_result = 1;
		}
	}

	if( cur_key_name ){
		efree( cur_key_name);
	}
	/*if( key_name != LOC_PRIVATE_TAG && key_value){*/
	if( key_value){
		efree(key_value);
	}
	return cur_result;
}","static int add_array_entry(const char* VAR_0, zval* VAR_1, char* VAR_2 TSRMLS_DC)
{
	char*   VAR_3 	= NULL;
	char*   VAR_4	= NULL;
	char*   VAR_5        	= NULL;
	char*   VAR_6  	= NULL;

	int	VAR_7		= 0;
	int 	VAR_8  	= 0;
	int 	VAR_9  		= 0;


	if( strcmp(VAR_2 , VAR_10)==0 ){
		VAR_3 = get_private_subtags( VAR_0 );
		VAR_7 = 1;
	} else {
		VAR_3 = get_icu_value_internal( VAR_0 , VAR_2 , &VAR_7,1 );
	}
	if( (strcmp(VAR_2 , VAR_10)==0) ||
		( strcmp(VAR_2 , VAR_11)==0) ){
		if( VAR_7 > 0 && VAR_3){
			/* COMMENT_0 */
			VAR_5 = php_strtok_r( VAR_3 , VAR_12 ,&VAR_6);
			if( VAR_4 ){
				efree( VAR_4);
			}
			VAR_4 = (char*)ecalloc( 25,  25);
			sprintf( VAR_4 , ""%s%d"", VAR_2 , VAR_9++);
			add_assoc_string( VAR_1, VAR_4 , VAR_5 ,TRUE );
			/* COMMENT_1 */
			while( (VAR_5 = php_strtok_r(NULL , VAR_12 , &VAR_6)) && (strlen(VAR_5)>1) ){
				sprintf( VAR_4 , ""%s%d"", VAR_2 , VAR_9++);
				add_assoc_string( VAR_1, VAR_4 , VAR_5 , TRUE );
			}
/* COMMENT_2 */
                                                
    
  
		}
	} else {
		if( VAR_7 == 1 ){
			add_assoc_string( VAR_1, VAR_2 , VAR_3 , TRUE );
			VAR_8 = 1;
		}
	}

	if( VAR_4 ){
		efree( VAR_4);
	}
	/* COMMENT_6 */
	if( VAR_3){
		efree(VAR_3);
	}
	return VAR_8;
}",,"--- func_before
+++ func_after
@@ -16,20 +16,20 @@
 	} else {
 		key_value = get_icu_value_internal( loc_name , key_name , &result,1 );
 	}
-	if( (strcmp(key_name , LOC_PRIVATE_TAG)==0) || 
+	if( (strcmp(key_name , LOC_PRIVATE_TAG)==0) ||
 		( strcmp(key_name , LOC_VARIANT_TAG)==0) ){
 		if( result > 0 && key_value){
 			/* Tokenize on the ""_"" or ""-""  */
-			token = php_strtok_r( key_value , DELIMITER ,&last_ptr);	
+			token = php_strtok_r( key_value , DELIMITER ,&last_ptr);
 			if( cur_key_name ){
 				efree( cur_key_name);
 			}
 			cur_key_name = (char*)ecalloc( 25,  25);
-			sprintf( cur_key_name , ""%s%d"", key_name , cnt++);	
+			sprintf( cur_key_name , ""%s%d"", key_name , cnt++);
 			add_assoc_string( hash_arr, cur_key_name , token ,TRUE );
 			/* tokenize on the ""_"" or ""-"" and stop  at singleton if any */
 			while( (token = php_strtok_r(NULL , DELIMITER , &last_ptr)) && (strlen(token)>1) ){
-				sprintf( cur_key_name , ""%s%d"", key_name , cnt++);	
+				sprintf( cur_key_name , ""%s%d"", key_name , cnt++);
 				add_assoc_string( hash_arr, cur_key_name , token , TRUE );
 			}
 /*
@@ -49,7 +49,7 @@
 	}
 	/*if( key_name != LOC_PRIVATE_TAG && key_value){*/
 	if( key_value){
-		efree(key_value);	
+		efree(key_value);
 	}
 	return cur_result;
 }","{'deleted_lines': ['\tif( (strcmp(key_name , LOC_PRIVATE_TAG)==0) || ', '\t\t\ttoken = php_strtok_r( key_value , DELIMITER ,&last_ptr);\t', '\t\t\tsprintf( cur_key_name , ""%s%d"", key_name , cnt++);\t', '\t\t\t\tsprintf( cur_key_name , ""%s%d"", key_name , cnt++);\t', '\t\tefree(key_value);\t'], 'added_lines': ['\tif( (strcmp(key_name , LOC_PRIVATE_TAG)==0) ||', '\t\t\ttoken = php_strtok_r( key_value , DELIMITER ,&last_ptr);', '\t\t\tsprintf( cur_key_name , ""%s%d"", key_name , cnt++);', '\t\t\t\tsprintf( cur_key_name , ""%s%d"", key_name , cnt++);', '\t\tefree(key_value);']}",True,"The get_icu_value_internal function in ext/intl/locale/locale_methods.c in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7 does not ensure the presence of a '\0' character, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted locale_get_primary_language call.",8.6,HIGH,2,test,2016-05-23T00:49:02Z,1
CVE-2016-5093,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #72241: get_icu_value_internal out-of-bounds read,97eff7eb57fc2320c267a949cffd622c38712484,https://github.com/php/php-src/commit/97eff7eb57fc2320c267a949cffd622c38712484,ext/intl/locale/locale_methods.c,get_icu_value_src_php,"static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) 
{
const char* loc_name        = NULL;
int         loc_name_len    = 0;
char*       tag_value= NULL;
char*       empty_result= """";
int         result    = 0;
char*       msg        = NULL;
UErrorCode  status          = U_ZERO_ERROR;
intl_error_reset( NULL TSRMLS_CC );
if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, ""s"",
&loc_name ,&loc_name_len ) == FAILURE) {
spprintf(&msg , 0, ""locale_get_%s : unable to parse input params"", tag_name );
intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 TSRMLS_CC );
efree(msg);
RETURN_FALSE;
}
if(loc_name_len == 0) {
loc_name = intl_locale_get_default(TSRMLS_C);
}
tag_value = get_icu_value_internal( loc_name , tag_name , &result ,0);
if( result == -1 ) {
if( tag_value){
efree( tag_value);
}
RETURN_STRING( empty_result , TRUE);
}
if( tag_value){
RETURN_STRING( tag_value , FALSE);
}
if( result ==0) {
spprintf(&msg , 0, ""locale_get_%s : unable to get locale %s"", tag_name , tag_name );
intl_error_set( NULL, status, msg , 1 TSRMLS_CC );
efree(msg);
RETURN_NULL();
}
}","static void get_icu_value_src_php( char* VAR_0, INTERNAL_FUNCTION_PARAMETERS) 
{
const char* VAR_1        = NULL;
int         VAR_2    = 0;
char*       VAR_3= NULL;
char*       VAR_4= """";
int         VAR_5    = 0;
char*       VAR_6        = NULL;
UErrorCode  VAR_7          = VAR_8;
VAR_9( NULL TSRMLS_CC );
if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, ""s"",
&VAR_1 ,&VAR_2 ) == VAR_10) {
spprintf(&VAR_6 , 0, ""locale_get_%s : unable to parse input params"", VAR_0 );
intl_error_set( NULL, VAR_11,  VAR_6 , 1 TSRMLS_CC );
efree(VAR_6);
VAR_12;
}
if(VAR_2 == 0) {
VAR_1 = intl_locale_get_default(VAR_13);
}
VAR_3 = get_icu_value_internal( VAR_1 , VAR_0 , &VAR_5 ,0);
if( VAR_5 == -1 ) {
if( VAR_3){
efree( VAR_3);
}
RETURN_STRING( VAR_4 , TRUE);
}
if( VAR_3){
RETURN_STRING( VAR_3 , FALSE);
}
if( VAR_5 ==0) {
spprintf(&VAR_6 , 0, ""locale_get_%s : unable to get locale %s"", VAR_0 , VAR_0 );
intl_error_set( NULL, VAR_7, VAR_6 , 1 TSRMLS_CC );
efree(VAR_6);
RETURN_NULL();
}
}",php/php-src/97eff7eb57fc2320c267a949cffd622c38712484/locale_methods.c/vul/before/10.json,"static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)
{

	const char* loc_name        	= NULL;
	int         loc_name_len    	= 0;

	char*       tag_value		= NULL;
	char*       empty_result	= """";

	int         result    		= 0;
	char*       msg        		= NULL;

	UErrorCode  status          	= U_ZERO_ERROR;

	intl_error_reset( NULL TSRMLS_CC );

	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, ""s"",
	&loc_name ,&loc_name_len ) == FAILURE) {
		spprintf(&msg , 0, ""locale_get_%s : unable to parse input params"", tag_name );
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 TSRMLS_CC );
		efree(msg);

		RETURN_FALSE;
    }

	if(loc_name_len == 0) {
		loc_name = intl_locale_get_default(TSRMLS_C);
	}

	/* Call ICU get */
	tag_value = get_icu_value_internal( loc_name , tag_name , &result ,0);

	/* No value found */
	if( result == -1 ) {
		if( tag_value){
			efree( tag_value);
		}
		RETURN_STRING( empty_result , TRUE);
	}

	/* value found */
	if( tag_value){
		RETURN_STRING( tag_value , FALSE);
	}

	/* Error encountered while fetching the value */
	if( result ==0) {
		spprintf(&msg , 0, ""locale_get_%s : unable to get locale %s"", tag_name , tag_name );
		intl_error_set( NULL, status, msg , 1 TSRMLS_CC );
		efree(msg);
		RETURN_NULL();
	}

}","static void get_icu_value_src_php( char* VAR_0, INTERNAL_FUNCTION_PARAMETERS)
{

	const char* VAR_1        	= NULL;
	int         VAR_2    	= 0;

	char*       VAR_3		= NULL;
	char*       VAR_4	= """";

	int         VAR_5    		= 0;
	char*       VAR_6        		= NULL;

	UErrorCode  VAR_7          	= VAR_8;

	VAR_9( NULL TSRMLS_CC );

	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, ""s"",
	&VAR_1 ,&VAR_2 ) == VAR_10) {
		spprintf(&VAR_6 , 0, ""locale_get_%s : unable to parse input params"", VAR_0 );
		intl_error_set( NULL, VAR_11,  VAR_6 , 1 TSRMLS_CC );
		efree(VAR_6);

		VAR_12;
    }

	if(VAR_2 == 0) {
		VAR_1 = intl_locale_get_default(VAR_13);
	}

	/* COMMENT_0 */
	VAR_3 = get_icu_value_internal( VAR_1 , VAR_0 , &VAR_5 ,0);

	/* COMMENT_1 */
	if( VAR_5 == -1 ) {
		if( VAR_3){
			efree( VAR_3);
		}
		RETURN_STRING( VAR_4 , TRUE);
	}

	/* COMMENT_2 */
	if( VAR_3){
		RETURN_STRING( VAR_3 , FALSE);
	}

	/* COMMENT_3 */
	if( VAR_5 ==0) {
		spprintf(&VAR_6 , 0, ""locale_get_%s : unable to get locale %s"", VAR_0 , VAR_0 );
		intl_error_set( NULL, VAR_7, VAR_6 , 1 TSRMLS_CC );
		efree(VAR_6);
		RETURN_NULL();
	}

}",php/php-src/97eff7eb57fc2320c267a949cffd622c38712484/locale_methods.c/vul/after/10.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) 
+static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)
 {
 
 	const char* loc_name        	= NULL;","{'deleted_lines': ['static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) '], 'added_lines': ['static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)']}",True,"The get_icu_value_internal function in ext/intl/locale/locale_methods.c in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7 does not ensure the presence of a '\0' character, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted locale_get_primary_language call.",8.6,HIGH,2,test,2016-05-23T00:49:02Z,1
CVE-2016-5093,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #72241: get_icu_value_internal out-of-bounds read,97eff7eb57fc2320c267a949cffd622c38712484,https://github.com/php/php-src/commit/97eff7eb57fc2320c267a949cffd622c38712484,ext/intl/locale/locale_methods.c,append_key_value,"static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_name)
{
zval**ele_value= NULL;
if(zend_hash_find(hash_arr , key_name , strlen(key_name) + 1 ,(void **)&ele_value ) == SUCCESS ) {
if(Z_TYPE_PP(ele_value)!= IS_STRING ){
return FAILURE;
}
if(strcmp(key_name, LOC_LANG_TAG) != 0 && 
strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) {
smart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);
}
smart_str_appendl(loc_name, Z_STRVAL_PP(ele_value) , Z_STRLEN_PP(ele_value));
return SUCCESS;
}
return LOC_NOT_FOUND;
}","static int append_key_value(smart_str* VAR_0, HashTable* VAR_1, char* VAR_2)
{
zval**VAR_3= NULL;
if(zend_hash_find(VAR_1 , VAR_2 , strlen(VAR_2) + 1 ,(void **)&VAR_3 ) == VAR_4 ) {
if(Z_TYPE_PP(VAR_3)!= VAR_5 ){
return VAR_6;
}
if(strcmp(VAR_2, VAR_7) != 0 && 
strcmp(VAR_2, VAR_8)!=0 ) {
smart_str_appendl(VAR_0, VAR_9 , sizeof(VAR_9)-1);
}
smart_str_appendl(VAR_0, Z_STRVAL_PP(VAR_3) , Z_STRLEN_PP(VAR_3));
return VAR_4;
}
return VAR_10;
}",php/php-src/97eff7eb57fc2320c267a949cffd622c38712484/locale_methods.c/vul/before/9.json,"static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_name)
{
	zval**	ele_value	= NULL;

	if(zend_hash_find(hash_arr , key_name , strlen(key_name) + 1 ,(void **)&ele_value ) == SUCCESS ) {
		if(Z_TYPE_PP(ele_value)!= IS_STRING ){
			/* element value is not a string */
			return FAILURE;
		}
		if(strcmp(key_name, LOC_LANG_TAG) != 0 &&
		   strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) {
			/* not lang or grandfathered tag */
			smart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);
		}
		smart_str_appendl(loc_name, Z_STRVAL_PP(ele_value) , Z_STRLEN_PP(ele_value));
		return SUCCESS;
	}

	return LOC_NOT_FOUND;
}","static int append_key_value(smart_str* VAR_0, HashTable* VAR_1, char* VAR_2)
{
	zval**	VAR_3	= NULL;

	if(zend_hash_find(VAR_1 , VAR_2 , strlen(VAR_2) + 1 ,(void **)&VAR_3 ) == VAR_4 ) {
		if(Z_TYPE_PP(VAR_3)!= VAR_5 ){
			/* COMMENT_0 */
			return VAR_6;
		}
		if(strcmp(VAR_2, VAR_7) != 0 &&
		   strcmp(VAR_2, VAR_8)!=0 ) {
			/* COMMENT_1 */
			smart_str_appendl(VAR_0, VAR_9 , sizeof(VAR_9)-1);
		}
		smart_str_appendl(VAR_0, Z_STRVAL_PP(VAR_3) , Z_STRLEN_PP(VAR_3));
		return VAR_4;
	}

	return VAR_10;
}",php/php-src/97eff7eb57fc2320c267a949cffd622c38712484/locale_methods.c/vul/after/9.json,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
 			/* element value is not a string */
 			return FAILURE;
 		}
-		if(strcmp(key_name, LOC_LANG_TAG) != 0 && 
+		if(strcmp(key_name, LOC_LANG_TAG) != 0 &&
 		   strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) {
 			/* not lang or grandfathered tag */
 			smart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);","{'deleted_lines': ['\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 && '], 'added_lines': ['\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 &&']}",True,"The get_icu_value_internal function in ext/intl/locale/locale_methods.c in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7 does not ensure the presence of a '\0' character, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted locale_get_primary_language call.",8.6,HIGH,2,test,2016-05-23T00:49:02Z,1
CVE-2016-5093,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #72241: get_icu_value_internal out-of-bounds read,97eff7eb57fc2320c267a949cffd622c38712484,https://github.com/php/php-src/commit/97eff7eb57fc2320c267a949cffd622c38712484,ext/intl/locale/locale_methods.c,getSingletonPos,"static int getSingletonPos(const char* str)
{
int result =-1;
int i=0;
int len = 0;
if( str && ((len=strlen(str))>0) ){
for( i=0; i<len ; i++){
if( isIDSeparator(*(str+i)) ){
if( i==1){
result =0;
break;
} else {
if( isIDSeparator(*(str+i+2)) ){
result = i+1;
break;
}
}
}
}
}
return result;
}","static int getSingletonPos(const char* VAR_0)
{
int VAR_1 =-1;
int VAR_2=0;
int VAR_3 = 0;
if( VAR_0 && ((VAR_3=strlen(VAR_0))>0) ){
for( VAR_2=0; VAR_2<VAR_3 ; VAR_2++){
if( isIDSeparator(*(VAR_0+VAR_2)) ){
if( VAR_2==1){
VAR_1 =0;
break;
} else {
if( isIDSeparator(*(VAR_0+VAR_2+2)) ){
VAR_1 = VAR_2+1;
break;
}
}
}
}
}
return VAR_1;
}",php/php-src/97eff7eb57fc2320c267a949cffd622c38712484/locale_methods.c/vul/before/8.json,"static int getSingletonPos(const char* str)
{
	int result =-1;
	int i=0;
	int len = 0;

	if( str && ((len=strlen(str))>0) ){
		for( i=0; i<len ; i++){
			if( isIDSeparator(*(str+i)) ){
				if( i==1){
					/* string is of the form x-avy or a-prv1 */
					result =0;
					break;
				} else {
					/* delimiter found; check for singleton */
					if( isIDSeparator(*(str+i+2)) ){
						/* a singleton; so send the position of separator before singleton */
						result = i+1;
						break;
					}
				}
			}
		}/* end of for */

	}
	return result;
}","static int getSingletonPos(const char* VAR_0)
{
	int VAR_1 =-1;
	int VAR_2=0;
	int VAR_3 = 0;

	if( VAR_0 && ((VAR_3=strlen(VAR_0))>0) ){
		for( VAR_2=0; VAR_2<VAR_3 ; VAR_2++){
			if( isIDSeparator(*(VAR_0+VAR_2)) ){
				if( VAR_2==1){
					/* COMMENT_0 */
					VAR_1 =0;
					break;
				} else {
					/* COMMENT_1 */
					if( isIDSeparator(*(VAR_0+VAR_2+2)) ){
						/* COMMENT_2 */
						VAR_1 = VAR_2+1;
						break;
					}
				}
			}
		}/* COMMENT_3 */

	}
	return VAR_1;
}",php/php-src/97eff7eb57fc2320c267a949cffd622c38712484/locale_methods.c/vul/after/8.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 	int result =-1;
 	int i=0;
 	int len = 0;
-	
+
 	if( str && ((len=strlen(str))>0) ){
 		for( i=0; i<len ; i++){
 			if( isIDSeparator(*(str+i)) ){
@@ -21,7 +21,7 @@
 				}
 			}
 		}/* end of for */
-		
+
 	}
 	return result;
 }","{'deleted_lines': ['\t', '\t\t'], 'added_lines': ['', '']}",True,"The get_icu_value_internal function in ext/intl/locale/locale_methods.c in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7 does not ensure the presence of a '\0' character, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted locale_get_primary_language call.",8.6,HIGH,2,test,2016-05-23T00:49:02Z,1
CVE-2016-5093,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #72241: get_icu_value_internal out-of-bounds read,97eff7eb57fc2320c267a949cffd622c38712484,https://github.com/php/php-src/commit/97eff7eb57fc2320c267a949cffd622c38712484,ext/intl/locale/locale_methods.c,lookup_loc_range,"static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int canonicalize  TSRMLS_DC)
{
inti = 0;
intcur_arr_len = 0;
int result = 0;
char* lang_tag = NULL;
zval** ele_value = NULL;
char** cur_arr = NULL;
char* cur_loc_range= NULL;
char* can_loc_range= NULL;
intsaved_pos = 0;
char* return_value = NULL;
cur_arr = ecalloc(zend_hash_num_elements(hash_arr)*2, sizeof(char *));
for(zend_hash_internal_pointer_reset(hash_arr);
zend_hash_has_more_elements(hash_arr) == SUCCESS;
zend_hash_move_forward(hash_arr)) {
if (zend_hash_get_current_data(hash_arr, (void**)&ele_value) == FAILURE) {
continue;
}
if(Z_TYPE_PP(ele_value)!= IS_STRING) {
intl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, ""lookup_loc_range: locale array element is not a string"", 0 TSRMLS_CC);
LOOKUP_CLEAN_RETURN(NULL);
} 
cur_arr[cur_arr_len*2] = estrndup(Z_STRVAL_PP(ele_value), Z_STRLEN_PP(ele_value));
result = strToMatch(Z_STRVAL_PP(ele_value), cur_arr[cur_arr_len*2]);
if(result == 0) {
intl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, ""lookup_loc_range: unable to canonicalize lang_tag"", 0 TSRMLS_CC);
LOOKUP_CLEAN_RETURN(NULL);
}
cur_arr[cur_arr_len*2+1] = Z_STRVAL_PP(ele_value);
cur_arr_len++ ; 
} 
if(canonicalize) {
for(i=0; i<cur_arr_len; i++) { 
lang_tag = get_icu_value_internal(cur_arr[i*2], LOC_CANONICALIZE_TAG, &result, 0);
if(result != 1 || lang_tag == NULL || !lang_tag[0]) {
if(lang_tag) {
efree(lang_tag);
}
intl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, ""lookup_loc_range: unable to canonicalize lang_tag"" , 0 TSRMLS_CC);
LOOKUP_CLEAN_RETURN(NULL);
}
cur_arr[i*2] = erealloc(cur_arr[i*2], strlen(lang_tag)+1);
result = strToMatch(lang_tag, cur_arr[i*2]);
efree(lang_tag);
if(result == 0) {
intl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, ""lookup_loc_range: unable to canonicalize lang_tag"" , 0 TSRMLS_CC);
LOOKUP_CLEAN_RETURN(NULL);
}
}
}
if(canonicalize) {
can_loc_range = get_icu_value_internal(loc_range, LOC_CANONICALIZE_TAG, &result , 0);
if( result != 1 || can_loc_range == NULL || !can_loc_range[0]) {
intl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, ""lookup_loc_range: unable to canonicalize loc_range"" , 0 TSRMLS_CC );
if(can_loc_range) {
efree(can_loc_range);
}
LOOKUP_CLEAN_RETURN(NULL);
} else {
loc_range = can_loc_range;
}
} 
cur_loc_range = ecalloc(1, strlen(loc_range)+1);
result = strToMatch(loc_range, cur_loc_range);
if(can_loc_range) {
efree(can_loc_range);
}
if(result == 0) {
intl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, ""lookup_loc_range: unable to canonicalize lang_tag"" , 0 TSRMLS_CC);
LOOKUP_CLEAN_RETURN(NULL);
}
saved_pos = strlen(cur_loc_range);
while(saved_pos > 0) {
for(i=0; i< cur_arr_len; i++){ 
if(cur_arr[i*2] != NULL && strlen(cur_arr[i*2]) == saved_pos && strncmp(cur_loc_range, cur_arr[i*2], saved_pos) == 0) {
return_value = estrdup(canonicalize?cur_arr[i*2]:cur_arr[i*2+1]);
efree(cur_loc_range);
LOOKUP_CLEAN_RETURN(return_value);
}
}
saved_pos = getStrrtokenPos(cur_loc_range, saved_pos);
}
efree(cur_loc_range);
LOOKUP_CLEAN_RETURN(NULL);
}","static char* lookup_loc_range(const char* VAR_0, HashTable* VAR_1, int VAR_2  TSRMLS_DC)
{
intVAR_3 = 0;
intVAR_4 = 0;
int VAR_5 = 0;
char* VAR_6 = NULL;
zval** VAR_7 = NULL;
char** VAR_8 = NULL;
char* VAR_9= NULL;
char* VAR_10= NULL;
intVAR_11 = 0;
char* VAR_12 = NULL;
VAR_8 = ecalloc(zend_hash_num_elements(VAR_1)*2, sizeof(char *));
for(zend_hash_internal_pointer_reset(VAR_1);
zend_hash_has_more_elements(VAR_1) == VAR_13;
zend_hash_move_forward(VAR_1)) {
if (zend_hash_get_current_data(VAR_1, (void**)&VAR_7) == VAR_14) {
continue;
}
if(Z_TYPE_PP(VAR_7)!= VAR_15) {
intl_error_set(NULL, VAR_16, ""lookup_loc_range: locale array element is not a string"", 0 VAR_17);
LOOKUP_CLEAN_RETURN(NULL);
} 
VAR_8[VAR_4*2] = estrndup(Z_STRVAL_PP(VAR_7), Z_STRLEN_PP(VAR_7));
VAR_5 = strToMatch(Z_STRVAL_PP(VAR_7), VAR_8[VAR_4*2]);
if(VAR_5 == 0) {
intl_error_set(NULL, VAR_16, ""lookup_loc_range: unable to canonicalize lang_tag"", 0 VAR_17);
LOOKUP_CLEAN_RETURN(NULL);
}
VAR_8[VAR_4*2+1] = Z_STRVAL_PP(VAR_7);
VAR_4++ ; 
} 
if(VAR_2) {
for(VAR_3=0; VAR_3<VAR_4; VAR_3++) { 
VAR_6 = get_icu_value_internal(VAR_8[VAR_3*2], VAR_18, &VAR_5, 0);
if(VAR_5 != 1 || VAR_6 == NULL || !VAR_6[0]) {
if(VAR_6) {
efree(VAR_6);
}
intl_error_set(NULL, VAR_16, ""lookup_loc_range: unable to canonicalize lang_tag"" , 0 VAR_17);
LOOKUP_CLEAN_RETURN(NULL);
}
VAR_8[VAR_3*2] = erealloc(VAR_8[VAR_3*2], strlen(VAR_6)+1);
VAR_5 = strToMatch(VAR_6, VAR_8[VAR_3*2]);
efree(VAR_6);
if(VAR_5 == 0) {
intl_error_set(NULL, VAR_16, ""lookup_loc_range: unable to canonicalize lang_tag"" , 0 VAR_17);
LOOKUP_CLEAN_RETURN(NULL);
}
}
}
if(VAR_2) {
VAR_10 = get_icu_value_internal(VAR_0, VAR_18, &VAR_5 , 0);
if( VAR_5 != 1 || VAR_10 == NULL || !VAR_10[0]) {
intl_error_set(NULL, VAR_16, ""lookup_loc_range: unable to canonicalize loc_range"" , 0 VAR_17 );
if(VAR_10) {
efree(VAR_10);
}
LOOKUP_CLEAN_RETURN(NULL);
} else {
VAR_0 = VAR_10;
}
} 
VAR_9 = ecalloc(1, strlen(VAR_0)+1);
VAR_5 = strToMatch(VAR_0, VAR_9);
if(VAR_10) {
efree(VAR_10);
}
if(VAR_5 == 0) {
intl_error_set(NULL, VAR_16, ""lookup_loc_range: unable to canonicalize lang_tag"" , 0 VAR_17);
LOOKUP_CLEAN_RETURN(NULL);
}
VAR_11 = strlen(VAR_9);
while(VAR_11 > 0) {
for(VAR_3=0; VAR_3< VAR_4; VAR_3++){ 
if(VAR_8[VAR_3*2] != NULL && strlen(VAR_8[VAR_3*2]) == VAR_11 && strncmp(VAR_9, VAR_8[VAR_3*2], VAR_11) == 0) {
VAR_12 = estrdup(VAR_2?VAR_8[VAR_3*2]:VAR_8[VAR_3*2+1]);
efree(VAR_9);
LOOKUP_CLEAN_RETURN(VAR_12);
}
}
VAR_11 = getStrrtokenPos(VAR_9, VAR_11);
}
efree(VAR_9);
LOOKUP_CLEAN_RETURN(NULL);
}",,"static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int canonicalize  TSRMLS_DC)
{
	int	i = 0;
	int	cur_arr_len = 0;
	int result = 0;

	char* lang_tag = NULL;
	zval** ele_value = NULL;
	char** cur_arr = NULL;

	char* cur_loc_range	= NULL;
	char* can_loc_range	= NULL;
	int	saved_pos = 0;

	char* return_value = NULL;

	cur_arr = ecalloc(zend_hash_num_elements(hash_arr)*2, sizeof(char *));
	/* convert the array to lowercase , also replace hyphens with the underscore and store it in cur_arr */
	for(zend_hash_internal_pointer_reset(hash_arr);
		zend_hash_has_more_elements(hash_arr) == SUCCESS;
		zend_hash_move_forward(hash_arr)) {

		if (zend_hash_get_current_data(hash_arr, (void**)&ele_value) == FAILURE) {
			/* Should never actually fail since the key is known to exist.*/
			continue;
		}
		if(Z_TYPE_PP(ele_value)!= IS_STRING) {
			/* element value is not a string */
			intl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, ""lookup_loc_range: locale array element is not a string"", 0 TSRMLS_CC);
			LOOKUP_CLEAN_RETURN(NULL);
		}
		cur_arr[cur_arr_len*2] = estrndup(Z_STRVAL_PP(ele_value), Z_STRLEN_PP(ele_value));
		result = strToMatch(Z_STRVAL_PP(ele_value), cur_arr[cur_arr_len*2]);
		if(result == 0) {
			intl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, ""lookup_loc_range: unable to canonicalize lang_tag"", 0 TSRMLS_CC);
			LOOKUP_CLEAN_RETURN(NULL);
		}
		cur_arr[cur_arr_len*2+1] = Z_STRVAL_PP(ele_value);
		cur_arr_len++ ;
	} /* end of for */

	/* Canonicalize array elements */
	if(canonicalize) {
		for(i=0; i<cur_arr_len; i++) {
			lang_tag = get_icu_value_internal(cur_arr[i*2], LOC_CANONICALIZE_TAG, &result, 0);
			if(result != 1 || lang_tag == NULL || !lang_tag[0]) {
				if(lang_tag) {
					efree(lang_tag);
				}
				intl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, ""lookup_loc_range: unable to canonicalize lang_tag"" , 0 TSRMLS_CC);
				LOOKUP_CLEAN_RETURN(NULL);
			}
			cur_arr[i*2] = erealloc(cur_arr[i*2], strlen(lang_tag)+1);
			result = strToMatch(lang_tag, cur_arr[i*2]);
			efree(lang_tag);
			if(result == 0) {
				intl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, ""lookup_loc_range: unable to canonicalize lang_tag"" , 0 TSRMLS_CC);
				LOOKUP_CLEAN_RETURN(NULL);
			}
		}

	}

	if(canonicalize) {
		/* Canonicalize the loc_range */
		can_loc_range = get_icu_value_internal(loc_range, LOC_CANONICALIZE_TAG, &result , 0);
		if( result != 1 || can_loc_range == NULL || !can_loc_range[0]) {
			/* Error */
			intl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, ""lookup_loc_range: unable to canonicalize loc_range"" , 0 TSRMLS_CC );
			if(can_loc_range) {
				efree(can_loc_range);
			}
			LOOKUP_CLEAN_RETURN(NULL);
		} else {
			loc_range = can_loc_range;
		}
	}

	cur_loc_range = ecalloc(1, strlen(loc_range)+1);
	/* convert to lower and replace hyphens */
	result = strToMatch(loc_range, cur_loc_range);
	if(can_loc_range) {
		efree(can_loc_range);
	}
	if(result == 0) {
		intl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, ""lookup_loc_range: unable to canonicalize lang_tag"" , 0 TSRMLS_CC);
		LOOKUP_CLEAN_RETURN(NULL);
	}

	/* Lookup for the lang_tag match */
	saved_pos = strlen(cur_loc_range);
	while(saved_pos > 0) {
		for(i=0; i< cur_arr_len; i++){
			if(cur_arr[i*2] != NULL && strlen(cur_arr[i*2]) == saved_pos && strncmp(cur_loc_range, cur_arr[i*2], saved_pos) == 0) {
				/* Match found */
				return_value = estrdup(canonicalize?cur_arr[i*2]:cur_arr[i*2+1]);
				efree(cur_loc_range);
				LOOKUP_CLEAN_RETURN(return_value);
			}
		}
		saved_pos = getStrrtokenPos(cur_loc_range, saved_pos);
	}

	/* Match not found */
	efree(cur_loc_range);
	LOOKUP_CLEAN_RETURN(NULL);
}","static char* lookup_loc_range(const char* VAR_0, HashTable* VAR_1, int VAR_2  TSRMLS_DC)
{
	int	VAR_3 = 0;
	int	VAR_4 = 0;
	int VAR_5 = 0;

	char* VAR_6 = NULL;
	zval** VAR_7 = NULL;
	char** VAR_8 = NULL;

	char* VAR_9	= NULL;
	char* VAR_10	= NULL;
	int	VAR_11 = 0;

	char* VAR_12 = NULL;

	VAR_8 = ecalloc(zend_hash_num_elements(VAR_1)*2, sizeof(char *));
	/* COMMENT_0 */
	for(zend_hash_internal_pointer_reset(VAR_1);
		zend_hash_has_more_elements(VAR_1) == VAR_13;
		zend_hash_move_forward(VAR_1)) {

		if (zend_hash_get_current_data(VAR_1, (void**)&VAR_7) == VAR_14) {
			/* COMMENT_1 */
			continue;
		}
		if(Z_TYPE_PP(VAR_7)!= VAR_15) {
			/* COMMENT_2 */
			intl_error_set(NULL, VAR_16, ""lookup_loc_range: locale array element is not a string"", 0 VAR_17);
			LOOKUP_CLEAN_RETURN(NULL);
		}
		VAR_8[VAR_4*2] = estrndup(Z_STRVAL_PP(VAR_7), Z_STRLEN_PP(VAR_7));
		VAR_5 = strToMatch(Z_STRVAL_PP(VAR_7), VAR_8[VAR_4*2]);
		if(VAR_5 == 0) {
			intl_error_set(NULL, VAR_16, ""lookup_loc_range: unable to canonicalize lang_tag"", 0 VAR_17);
			LOOKUP_CLEAN_RETURN(NULL);
		}
		VAR_8[VAR_4*2+1] = Z_STRVAL_PP(VAR_7);
		VAR_4++ ;
	} /* COMMENT_3 */

	/* COMMENT_4 */
	if(VAR_2) {
		for(VAR_3=0; VAR_3<VAR_4; VAR_3++) {
			VAR_6 = get_icu_value_internal(VAR_8[VAR_3*2], VAR_18, &VAR_5, 0);
			if(VAR_5 != 1 || VAR_6 == NULL || !VAR_6[0]) {
				if(VAR_6) {
					efree(VAR_6);
				}
				intl_error_set(NULL, VAR_16, ""lookup_loc_range: unable to canonicalize lang_tag"" , 0 VAR_17);
				LOOKUP_CLEAN_RETURN(NULL);
			}
			VAR_8[VAR_3*2] = erealloc(VAR_8[VAR_3*2], strlen(VAR_6)+1);
			VAR_5 = strToMatch(VAR_6, VAR_8[VAR_3*2]);
			efree(VAR_6);
			if(VAR_5 == 0) {
				intl_error_set(NULL, VAR_16, ""lookup_loc_range: unable to canonicalize lang_tag"" , 0 VAR_17);
				LOOKUP_CLEAN_RETURN(NULL);
			}
		}

	}

	if(VAR_2) {
		/* COMMENT_5 */
		VAR_10 = get_icu_value_internal(VAR_0, VAR_18, &VAR_5 , 0);
		if( VAR_5 != 1 || VAR_10 == NULL || !VAR_10[0]) {
			/* COMMENT_6 */
			intl_error_set(NULL, VAR_16, ""lookup_loc_range: unable to canonicalize loc_range"" , 0 VAR_17 );
			if(VAR_10) {
				efree(VAR_10);
			}
			LOOKUP_CLEAN_RETURN(NULL);
		} else {
			VAR_0 = VAR_10;
		}
	}

	VAR_9 = ecalloc(1, strlen(VAR_0)+1);
	/* COMMENT_7 */
	VAR_5 = strToMatch(VAR_0, VAR_9);
	if(VAR_10) {
		efree(VAR_10);
	}
	if(VAR_5 == 0) {
		intl_error_set(NULL, VAR_16, ""lookup_loc_range: unable to canonicalize lang_tag"" , 0 VAR_17);
		LOOKUP_CLEAN_RETURN(NULL);
	}

	/* COMMENT_8 */
	VAR_11 = strlen(VAR_9);
	while(VAR_11 > 0) {
		for(VAR_3=0; VAR_3< VAR_4; VAR_3++){
			if(VAR_8[VAR_3*2] != NULL && strlen(VAR_8[VAR_3*2]) == VAR_11 && strncmp(VAR_9, VAR_8[VAR_3*2], VAR_11) == 0) {
				/* COMMENT_9 */
				VAR_12 = estrdup(VAR_2?VAR_8[VAR_3*2]:VAR_8[VAR_3*2+1]);
				efree(VAR_9);
				LOOKUP_CLEAN_RETURN(VAR_12);
			}
		}
		VAR_11 = getStrrtokenPos(VAR_9, VAR_11);
	}

	/* COMMENT_10 */
	efree(VAR_9);
	LOOKUP_CLEAN_RETURN(NULL);
}",,"--- func_before
+++ func_after
@@ -19,7 +19,7 @@
 	for(zend_hash_internal_pointer_reset(hash_arr);
 		zend_hash_has_more_elements(hash_arr) == SUCCESS;
 		zend_hash_move_forward(hash_arr)) {
-		
+
 		if (zend_hash_get_current_data(hash_arr, (void**)&ele_value) == FAILURE) {
 			/* Should never actually fail since the key is known to exist.*/
 			continue;
@@ -28,7 +28,7 @@
 			/* element value is not a string */
 			intl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, ""lookup_loc_range: locale array element is not a string"", 0 TSRMLS_CC);
 			LOOKUP_CLEAN_RETURN(NULL);
-		} 
+		}
 		cur_arr[cur_arr_len*2] = estrndup(Z_STRVAL_PP(ele_value), Z_STRLEN_PP(ele_value));
 		result = strToMatch(Z_STRVAL_PP(ele_value), cur_arr[cur_arr_len*2]);
 		if(result == 0) {
@@ -36,12 +36,12 @@
 			LOOKUP_CLEAN_RETURN(NULL);
 		}
 		cur_arr[cur_arr_len*2+1] = Z_STRVAL_PP(ele_value);
-		cur_arr_len++ ; 
+		cur_arr_len++ ;
 	} /* end of for */
 
 	/* Canonicalize array elements */
 	if(canonicalize) {
-		for(i=0; i<cur_arr_len; i++) { 
+		for(i=0; i<cur_arr_len; i++) {
 			lang_tag = get_icu_value_internal(cur_arr[i*2], LOC_CANONICALIZE_TAG, &result, 0);
 			if(result != 1 || lang_tag == NULL || !lang_tag[0]) {
 				if(lang_tag) {
@@ -51,7 +51,7 @@
 				LOOKUP_CLEAN_RETURN(NULL);
 			}
 			cur_arr[i*2] = erealloc(cur_arr[i*2], strlen(lang_tag)+1);
-			result = strToMatch(lang_tag, cur_arr[i*2]);	
+			result = strToMatch(lang_tag, cur_arr[i*2]);
 			efree(lang_tag);
 			if(result == 0) {
 				intl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, ""lookup_loc_range: unable to canonicalize lang_tag"" , 0 TSRMLS_CC);
@@ -74,11 +74,11 @@
 		} else {
 			loc_range = can_loc_range;
 		}
-	} 
+	}
 
 	cur_loc_range = ecalloc(1, strlen(loc_range)+1);
 	/* convert to lower and replace hyphens */
-	result = strToMatch(loc_range, cur_loc_range);	
+	result = strToMatch(loc_range, cur_loc_range);
 	if(can_loc_range) {
 		efree(can_loc_range);
 	}
@@ -90,8 +90,8 @@
 	/* Lookup for the lang_tag match */
 	saved_pos = strlen(cur_loc_range);
 	while(saved_pos > 0) {
-		for(i=0; i< cur_arr_len; i++){ 
-			if(cur_arr[i*2] != NULL && strlen(cur_arr[i*2]) == saved_pos && strncmp(cur_loc_range, cur_arr[i*2], saved_pos) == 0) {	
+		for(i=0; i< cur_arr_len; i++){
+			if(cur_arr[i*2] != NULL && strlen(cur_arr[i*2]) == saved_pos && strncmp(cur_loc_range, cur_arr[i*2], saved_pos) == 0) {
 				/* Match found */
 				return_value = estrdup(canonicalize?cur_arr[i*2]:cur_arr[i*2+1]);
 				efree(cur_loc_range);","{'deleted_lines': ['\t\t', '\t\t} ', '\t\tcur_arr_len++ ; ', '\t\tfor(i=0; i<cur_arr_len; i++) { ', '\t\t\tresult = strToMatch(lang_tag, cur_arr[i*2]);\t', '\t} ', '\tresult = strToMatch(loc_range, cur_loc_range);\t', '\t\tfor(i=0; i< cur_arr_len; i++){ ', '\t\t\tif(cur_arr[i*2] != NULL && strlen(cur_arr[i*2]) == saved_pos && strncmp(cur_loc_range, cur_arr[i*2], saved_pos) == 0) {\t'], 'added_lines': ['', '\t\t}', '\t\tcur_arr_len++ ;', '\t\tfor(i=0; i<cur_arr_len; i++) {', '\t\t\tresult = strToMatch(lang_tag, cur_arr[i*2]);', '\t}', '\tresult = strToMatch(loc_range, cur_loc_range);', '\t\tfor(i=0; i< cur_arr_len; i++){', '\t\t\tif(cur_arr[i*2] != NULL && strlen(cur_arr[i*2]) == saved_pos && strncmp(cur_loc_range, cur_arr[i*2], saved_pos) == 0) {']}",True,"The get_icu_value_internal function in ext/intl/locale/locale_methods.c in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7 does not ensure the presence of a '\0' character, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted locale_get_primary_language call.",8.6,HIGH,2,test,2016-05-23T00:49:02Z,1
CVE-2016-5093,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #72241: get_icu_value_internal out-of-bounds read,97eff7eb57fc2320c267a949cffd622c38712484,https://github.com/php/php-src/commit/97eff7eb57fc2320c267a949cffd622c38712484,ext/intl/locale/locale_methods.c,get_private_subtags,"static char* get_private_subtags(const char* loc_name)
{
char* result =NULL;
int singletonPos = 0;
int len =0; 
const char* mod_loc_name =NULL;
if( loc_name && (len = strlen(loc_name)>0 ) ){
mod_loc_name = loc_name ; 
len   = strlen(mod_loc_name);
while( (singletonPos = getSingletonPos(mod_loc_name))!= -1){
if( singletonPos!=-1){ 
if( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){
if( singletonPos + 2 ==  len){
}
else{
result = estrndup(mod_loc_name + singletonPos+2  , (len -( singletonPos +2) ) );
}
break;
}
else{
if( singletonPos + 1 >=  len){
break;
} else {
mod_loc_name = mod_loc_name + singletonPos +1;
len = strlen(mod_loc_name);
}
}
}
} 
}
return result;
}","static char* get_private_subtags(const char* VAR_0)
{
char* VAR_1 =NULL;
int VAR_2 = 0;
int VAR_3 =0; 
const char* VAR_4 =NULL;
if( VAR_0 && (VAR_3 = strlen(VAR_0)>0 ) ){
VAR_4 = VAR_0 ; 
VAR_3   = strlen(VAR_4);
while( (VAR_2 = getSingletonPos(VAR_4))!= -1){
if( VAR_2!=-1){ 
if( (*(VAR_4+VAR_2)=='x') || (*(VAR_4+VAR_2)=='X') ){
if( VAR_2 + 2 ==  VAR_3){
}
else{
VAR_1 = estrndup(VAR_4 + VAR_2+2  , (VAR_3 -( VAR_2 +2) ) );
}
break;
}
else{
if( VAR_2 + 1 >=  VAR_3){
break;
} else {
VAR_4 = VAR_4 + VAR_2 +1;
VAR_3 = strlen(VAR_4);
}
}
}
} 
}
return VAR_1;
}",php/php-src/97eff7eb57fc2320c267a949cffd622c38712484/locale_methods.c/vul/before/6.json,"static char* get_private_subtags(const char* loc_name)
{
	char* 	result =NULL;
	int 	singletonPos = 0;
	int 	len =0;
	const char* 	mod_loc_name =NULL;

	if( loc_name && (len = strlen(loc_name)>0 ) ){
		mod_loc_name = loc_name ;
		len   = strlen(mod_loc_name);
		while( (singletonPos = getSingletonPos(mod_loc_name))!= -1){

			if( singletonPos!=-1){
				if( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){
					/* private subtag start found */
					if( singletonPos + 2 ==  len){
						/* loc_name ends with '-x-' ; return  NULL */
					}
					else{
						/* result = mod_loc_name + singletonPos +2; */
						result = estrndup(mod_loc_name + singletonPos+2  , (len -( singletonPos +2) ) );
					}
					break;
				}
				else{
					if( singletonPos + 1 >=  len){
						/* String end */
						break;
					} else {
						/* singleton found but not a private subtag , hence check further in the string for the private subtag */
						mod_loc_name = mod_loc_name + singletonPos +1;
						len = strlen(mod_loc_name);
					}
				}
			}

		} /* end of while */
	}

	return result;
}","static char* get_private_subtags(const char* VAR_0)
{
	char* 	VAR_1 =NULL;
	int 	VAR_2 = 0;
	int 	VAR_3 =0;
	const char* 	VAR_4 =NULL;

	if( VAR_0 && (VAR_3 = strlen(VAR_0)>0 ) ){
		VAR_4 = VAR_0 ;
		VAR_3   = strlen(VAR_4);
		while( (VAR_2 = getSingletonPos(VAR_4))!= -1){

			if( VAR_2!=-1){
				if( (*(VAR_4+VAR_2)=='x') || (*(VAR_4+VAR_2)=='X') ){
					/* COMMENT_0 */
					if( VAR_2 + 2 ==  VAR_3){
						/* COMMENT_1 */
					}
					else{
						/* COMMENT_2 */
						VAR_1 = estrndup(VAR_4 + VAR_2+2  , (VAR_3 -( VAR_2 +2) ) );
					}
					break;
				}
				else{
					if( VAR_2 + 1 >=  VAR_3){
						/* COMMENT_3 */
						break;
					} else {
						/* COMMENT_4 */
						VAR_4 = VAR_4 + VAR_2 +1;
						VAR_3 = strlen(VAR_4);
					}
				}
			}

		} /* COMMENT_5 */
	}

	return VAR_1;
}",php/php-src/97eff7eb57fc2320c267a949cffd622c38712484/locale_methods.c/vul/after/6.json,"--- func_before
+++ func_after
@@ -2,16 +2,16 @@
 {
 	char* 	result =NULL;
 	int 	singletonPos = 0;
-	int 	len =0; 
+	int 	len =0;
 	const char* 	mod_loc_name =NULL;
 
 	if( loc_name && (len = strlen(loc_name)>0 ) ){
-		mod_loc_name = loc_name ; 
+		mod_loc_name = loc_name ;
 		len   = strlen(mod_loc_name);
 		while( (singletonPos = getSingletonPos(mod_loc_name))!= -1){
 
-			if( singletonPos!=-1){ 
-				if( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){		
+			if( singletonPos!=-1){
+				if( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){
 					/* private subtag start found */
 					if( singletonPos + 2 ==  len){
 						/* loc_name ends with '-x-' ; return  NULL */
@@ -36,6 +36,6 @@
 
 		} /* end of while */
 	}
-	
+
 	return result;
 }","{'deleted_lines': ['\tint \tlen =0; ', '\t\tmod_loc_name = loc_name ; ', '\t\t\tif( singletonPos!=-1){ ', ""\t\t\t\tif( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){\t\t"", '\t'], 'added_lines': ['\tint \tlen =0;', '\t\tmod_loc_name = loc_name ;', '\t\t\tif( singletonPos!=-1){', ""\t\t\t\tif( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){"", '']}",True,"The get_icu_value_internal function in ext/intl/locale/locale_methods.c in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7 does not ensure the presence of a '\0' character, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted locale_get_primary_language call.",8.6,HIGH,2,test,2016-05-23T00:49:02Z,1
CVE-2016-5093,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #72241: get_icu_value_internal out-of-bounds read,97eff7eb57fc2320c267a949cffd622c38712484,https://github.com/php/php-src/commit/97eff7eb57fc2320c267a949cffd622c38712484,ext/intl/locale/locale_methods.c,getPreferredTag,"static char* getPreferredTag(const char* gf_tag)
{ 
char* result = NULL;
int grOffset = 0;
grOffset = findOffset( LOC_GRANDFATHERED ,gf_tag);
if(grOffset < 0) {
return NULL;
}
if( grOffset < LOC_PREFERRED_GRANDFATHERED_LEN ){
result = estrdup( LOC_PREFERRED_GRANDFATHERED[grOffset] );
} else {
result = estrdup( LOC_GRANDFATHERED[grOffset] );
}
return result;
}","static char* getPreferredTag(const char* VAR_0)
{ 
char* VAR_1 = NULL;
int VAR_2 = 0;
VAR_2 = findOffset( VAR_3 ,VAR_0);
if(VAR_2 < 0) {
return NULL;
}
if( VAR_2 < VAR_4 ){
VAR_1 = estrdup( VAR_5[VAR_2] );
} else {
VAR_1 = estrdup( VAR_3[VAR_2] );
}
return VAR_1;
}",php/php-src/97eff7eb57fc2320c267a949cffd622c38712484/locale_methods.c/vul/before/11.json,"static char* getPreferredTag(const char* gf_tag)
{
	char* result = NULL;
	int grOffset = 0;

	grOffset = findOffset( LOC_GRANDFATHERED ,gf_tag);
	if(grOffset < 0) {
		return NULL;
	}
	if( grOffset < LOC_PREFERRED_GRANDFATHERED_LEN ){
		/* return preferred tag */
		result = estrdup( LOC_PREFERRED_GRANDFATHERED[grOffset] );
	} else {
		/* Return correct grandfathered language tag */
		result = estrdup( LOC_GRANDFATHERED[grOffset] );
	}
	return result;
}","static char* getPreferredTag(const char* VAR_0)
{
	char* VAR_1 = NULL;
	int VAR_2 = 0;

	VAR_2 = findOffset( VAR_3 ,VAR_0);
	if(VAR_2 < 0) {
		return NULL;
	}
	if( VAR_2 < VAR_4 ){
		/* COMMENT_0 */
		VAR_1 = estrdup( VAR_5[VAR_2] );
	} else {
		/* COMMENT_1 */
		VAR_1 = estrdup( VAR_3[VAR_2] );
	}
	return VAR_1;
}",php/php-src/97eff7eb57fc2320c267a949cffd622c38712484/locale_methods.c/vul/after/11.json,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
 static char* getPreferredTag(const char* gf_tag)
-{ 
+{
 	char* result = NULL;
 	int grOffset = 0;
 ","{'deleted_lines': ['{ '], 'added_lines': ['{']}",True,"The get_icu_value_internal function in ext/intl/locale/locale_methods.c in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7 does not ensure the presence of a '\0' character, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted locale_get_primary_language call.",8.6,HIGH,2,test,2016-05-23T00:49:02Z,1
CVE-2016-5093,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #72241: get_icu_value_internal out-of-bounds read,97eff7eb57fc2320c267a949cffd622c38712484,https://github.com/php/php-src/commit/97eff7eb57fc2320c267a949cffd622c38712484,ext/intl/locale/locale_methods.c,get_icu_value_internal,"static char* get_icu_value_internal( const char* loc_name , char* tag_name, int* result , int fromParseLocale)
{
char*tag_value= NULL;
int32_t     tag_value_len   = 512;
intsingletonPos   = 0;
char*       mod_loc_name= NULL;
int grOffset= 0;
int32_t     buflen          = 512;
UErrorCode  status          = U_ZERO_ERROR;
if( strcmp(tag_name, LOC_CANONICALIZE_TAG) != 0 ){
grOffset =  findOffset( LOC_GRANDFATHERED , loc_name );
if( grOffset >= 0 ){
if( strcmp(tag_name , LOC_LANG_TAG)==0 ){
return estrdup(loc_name);
} else {
return NULL;
}
}
if( fromParseLocale==1 ){
if( strcmp(tag_name , LOC_LANG_TAG)==0 ){
if( strlen(loc_name)>1 && (isIDPrefix(loc_name) == 1) ){
return estrdup(loc_name);
}
}
singletonPos = getSingletonPos( loc_name );
if( singletonPos == 0){
return NULL;
} else if( singletonPos > 0 ){
mod_loc_name = estrndup ( loc_name , singletonPos-1);
}
} 
} 
if( mod_loc_name == NULL){
mod_loc_name = estrdup(loc_name );
}
do{
tag_value = erealloc( tag_value , buflen  );
tag_value_len = buflen;
if( strcmp(tag_name , LOC_SCRIPT_TAG)==0 ){
buflen = uloc_getScript ( mod_loc_name ,tag_value , tag_value_len , &status);
}
if( strcmp(tag_name , LOC_LANG_TAG )==0 ){
buflen = uloc_getLanguage ( mod_loc_name ,tag_value , tag_value_len , &status);
}
if( strcmp(tag_name , LOC_REGION_TAG)==0 ){
buflen = uloc_getCountry ( mod_loc_name ,tag_value , tag_value_len , &status);
}
if( strcmp(tag_name , LOC_VARIANT_TAG)==0 ){
buflen = uloc_getVariant ( mod_loc_name ,tag_value , tag_value_len , &status);
}
if( strcmp(tag_name , LOC_CANONICALIZE_TAG)==0 ){
buflen = uloc_canonicalize ( mod_loc_name ,tag_value , tag_value_len , &status);
}
if( U_FAILURE( status ) ) {
if( status == U_BUFFER_OVERFLOW_ERROR ) {
status = U_ZERO_ERROR;
continue;
}
*result = 0;
if( tag_value ){
efree( tag_value );
}
if( mod_loc_name ){
efree( mod_loc_name);
}
return NULL;
}
} while( buflen > tag_value_len );
if(  buflen ==0 ){
*result = -1;
if( tag_value ){
efree( tag_value );
}
if( mod_loc_name ){
efree( mod_loc_name);
}
return NULL;
} else {
*result = 1;
}
if( mod_loc_name ){
efree( mod_loc_name);
}
return tag_value;
}","static char* get_icu_value_internal( const char* VAR_0 , char* VAR_1, int* VAR_2 , int VAR_3)
{
char*VAR_4= NULL;
int32_t     VAR_5   = 512;
intVAR_6   = 0;
char*       VAR_7= NULL;
int VAR_8= 0;
int32_t     VAR_9          = 512;
UErrorCode  VAR_10          = VAR_11;
if( strcmp(VAR_1, VAR_12) != 0 ){
VAR_8 =  findOffset( VAR_13 , VAR_0 );
if( VAR_8 >= 0 ){
if( strcmp(VAR_1 , VAR_14)==0 ){
return estrdup(VAR_0);
} else {
return NULL;
}
}
if( VAR_3==1 ){
if( strcmp(VAR_1 , VAR_14)==0 ){
if( strlen(VAR_0)>1 && (isIDPrefix(VAR_0) == 1) ){
return estrdup(VAR_0);
}
}
VAR_6 = getSingletonPos( VAR_0 );
if( VAR_6 == 0){
return NULL;
} else if( VAR_6 > 0 ){
VAR_7 = estrndup ( VAR_0 , VAR_6-1);
}
} 
} 
if( VAR_7 == NULL){
VAR_7 = estrdup(VAR_0 );
}
do{
VAR_4 = erealloc( VAR_4 , VAR_9  );
VAR_5 = VAR_9;
if( strcmp(VAR_1 , VAR_15)==0 ){
VAR_9 = uloc_getScript ( VAR_7 ,VAR_4 , VAR_5 , &VAR_10);
}
if( strcmp(VAR_1 , VAR_14 )==0 ){
VAR_9 = uloc_getLanguage ( VAR_7 ,VAR_4 , VAR_5 , &VAR_10);
}
if( strcmp(VAR_1 , VAR_16)==0 ){
VAR_9 = uloc_getCountry ( VAR_7 ,VAR_4 , VAR_5 , &VAR_10);
}
if( strcmp(VAR_1 , VAR_17)==0 ){
VAR_9 = uloc_getVariant ( VAR_7 ,VAR_4 , VAR_5 , &VAR_10);
}
if( strcmp(VAR_1 , VAR_12)==0 ){
VAR_9 = uloc_canonicalize ( VAR_7 ,VAR_4 , VAR_5 , &VAR_10);
}
if( U_FAILURE( VAR_10 ) ) {
if( VAR_10 == VAR_18 ) {
VAR_10 = VAR_11;
continue;
}
*VAR_2 = 0;
if( VAR_4 ){
efree( VAR_4 );
}
if( VAR_7 ){
efree( VAR_7);
}
return NULL;
}
} while( VAR_9 > VAR_5 );
if(  VAR_9 ==0 ){
*VAR_2 = -1;
if( VAR_4 ){
efree( VAR_4 );
}
if( VAR_7 ){
efree( VAR_7);
}
return NULL;
} else {
*VAR_2 = 1;
}
if( VAR_7 ){
efree( VAR_7);
}
return VAR_4;
}",php/php-src/97eff7eb57fc2320c267a949cffd622c38712484/locale_methods.c/vul/before/5.json,"static char* get_icu_value_internal( const char* loc_name , char* tag_name, int* result , int fromParseLocale)
{
	char*		tag_value	= NULL;
	int32_t     	tag_value_len   = 512;

	int		singletonPos   	= 0;
	char*       	mod_loc_name	= NULL;
	int 		grOffset	= 0;

	int32_t     	buflen          = 512;
	UErrorCode  	status          = U_ZERO_ERROR;


	if( strcmp(tag_name, LOC_CANONICALIZE_TAG) != 0 ){
		/* Handle  grandfathered languages */
		grOffset =  findOffset( LOC_GRANDFATHERED , loc_name );
		if( grOffset >= 0 ){
			if( strcmp(tag_name , LOC_LANG_TAG)==0 ){
				return estrdup(loc_name);
			} else {
				/* Since Grandfathered , no value , do nothing , retutn NULL */
				return NULL;
			}
		}

	if( fromParseLocale==1 ){
		/* Handle singletons */
		if( strcmp(tag_name , LOC_LANG_TAG)==0 ){
			if( strlen(loc_name)>1 && (isIDPrefix(loc_name) == 1) ){
				return estrdup(loc_name);
			}
		}

		singletonPos = getSingletonPos( loc_name );
		if( singletonPos == 0){
			/* singleton at start of script, region , variant etc.
			 * or invalid singleton at start of language */
			return NULL;
		} else if( singletonPos > 0 ){
			/* singleton at some position except at start
			 * strip off the singleton and rest of the loc_name */
			mod_loc_name = estrndup ( loc_name , singletonPos-1);
		}
	} /* end of if fromParse */

	} /* end of if != LOC_CANONICAL_TAG */

	if( mod_loc_name == NULL){
		mod_loc_name = estrdup(loc_name );
	}

	/* Proceed to ICU */
    do{
		tag_value = erealloc( tag_value , buflen  );
		tag_value_len = buflen;

		if( strcmp(tag_name , LOC_SCRIPT_TAG)==0 ){
			buflen = uloc_getScript ( mod_loc_name ,tag_value , tag_value_len , &status);
		}
		if( strcmp(tag_name , LOC_LANG_TAG )==0 ){
			buflen = uloc_getLanguage ( mod_loc_name ,tag_value , tag_value_len , &status);
		}
		if( strcmp(tag_name , LOC_REGION_TAG)==0 ){
			buflen = uloc_getCountry ( mod_loc_name ,tag_value , tag_value_len , &status);
		}
		if( strcmp(tag_name , LOC_VARIANT_TAG)==0 ){
			buflen = uloc_getVariant ( mod_loc_name ,tag_value , tag_value_len , &status);
		}
		if( strcmp(tag_name , LOC_CANONICALIZE_TAG)==0 ){
			buflen = uloc_canonicalize ( mod_loc_name ,tag_value , tag_value_len , &status);
		}

		if( U_FAILURE( status ) ) {
			if( status == U_BUFFER_OVERFLOW_ERROR ) {
				status = U_ZERO_ERROR;
				buflen++; /* add space for \0 */
				continue;
			}

			/* Error in retriving data */
			*result = 0;
			if( tag_value ){
				efree( tag_value );
			}
			if( mod_loc_name ){
				efree( mod_loc_name);
			}
			return NULL;
		}
	} while( buflen > tag_value_len );

	if(  buflen ==0 ){
		/* No value found */
		*result = -1;
		if( tag_value ){
			efree( tag_value );
		}
		if( mod_loc_name ){
			efree( mod_loc_name);
		}
		return NULL;
	} else {
		*result = 1;
	}

	if( mod_loc_name ){
		efree( mod_loc_name);
	}
	return tag_value;
}","static char* get_icu_value_internal( const char* VAR_0 , char* VAR_1, int* VAR_2 , int VAR_3)
{
	char*		VAR_4	= NULL;
	int32_t     	VAR_5   = 512;

	int		VAR_6   	= 0;
	char*       	VAR_7	= NULL;
	int 		VAR_8	= 0;

	int32_t     	VAR_9          = 512;
	UErrorCode  	VAR_10          = VAR_11;


	if( strcmp(VAR_1, VAR_12) != 0 ){
		/* COMMENT_0 */
		VAR_8 =  findOffset( VAR_13 , VAR_0 );
		if( VAR_8 >= 0 ){
			if( strcmp(VAR_1 , VAR_14)==0 ){
				return estrdup(VAR_0);
			} else {
				/* COMMENT_1 */
				return NULL;
			}
		}

	if( VAR_3==1 ){
		/* COMMENT_2 */
		if( strcmp(VAR_1 , VAR_14)==0 ){
			if( strlen(VAR_0)>1 && (isIDPrefix(VAR_0) == 1) ){
				return estrdup(VAR_0);
			}
		}

		VAR_6 = getSingletonPos( VAR_0 );
		if( VAR_6 == 0){
			/* COMMENT_3 */
                                                  
			return NULL;
		} else if( VAR_6 > 0 ){
			/* COMMENT_5 */
                                                         
			VAR_7 = estrndup ( VAR_0 , VAR_6-1);
		}
	} /* COMMENT_7 */

	} /* COMMENT_8 */

	if( VAR_7 == NULL){
		VAR_7 = estrdup(VAR_0 );
	}

	/* COMMENT_9 */
    do{
		VAR_4 = erealloc( VAR_4 , VAR_9  );
		VAR_5 = VAR_9;

		if( strcmp(VAR_1 , VAR_15)==0 ){
			VAR_9 = uloc_getScript ( VAR_7 ,VAR_4 , VAR_5 , &VAR_10);
		}
		if( strcmp(VAR_1 , VAR_14 )==0 ){
			VAR_9 = uloc_getLanguage ( VAR_7 ,VAR_4 , VAR_5 , &VAR_10);
		}
		if( strcmp(VAR_1 , VAR_16)==0 ){
			VAR_9 = uloc_getCountry ( VAR_7 ,VAR_4 , VAR_5 , &VAR_10);
		}
		if( strcmp(VAR_1 , VAR_17)==0 ){
			VAR_9 = uloc_getVariant ( VAR_7 ,VAR_4 , VAR_5 , &VAR_10);
		}
		if( strcmp(VAR_1 , VAR_12)==0 ){
			VAR_9 = uloc_canonicalize ( VAR_7 ,VAR_4 , VAR_5 , &VAR_10);
		}

		if( U_FAILURE( VAR_10 ) ) {
			if( VAR_10 == VAR_18 ) {
				VAR_10 = VAR_11;
				VAR_9++; /* COMMENT_10 */
				continue;
			}

			/* COMMENT_11 */
			*VAR_2 = 0;
			if( VAR_4 ){
				efree( VAR_4 );
			}
			if( VAR_7 ){
				efree( VAR_7);
			}
			return NULL;
		}
	} while( VAR_9 > VAR_5 );

	if(  VAR_9 ==0 ){
		/* COMMENT_12 */
		*VAR_2 = -1;
		if( VAR_4 ){
			efree( VAR_4 );
		}
		if( VAR_7 ){
			efree( VAR_7);
		}
		return NULL;
	} else {
		*VAR_2 = 1;
	}

	if( VAR_7 ){
		efree( VAR_7);
	}
	return VAR_4;
}",php/php-src/97eff7eb57fc2320c267a949cffd622c38712484/locale_methods.c/vul/after/5.json,"--- func_before
+++ func_after
@@ -31,7 +31,7 @@
 			}
 		}
 
-		singletonPos = getSingletonPos( loc_name );	
+		singletonPos = getSingletonPos( loc_name );
 		if( singletonPos == 0){
 			/* singleton at start of script, region , variant etc.
 			 * or invalid singleton at start of language */
@@ -46,7 +46,7 @@
 	} /* end of if != LOC_CANONICAL_TAG */
 
 	if( mod_loc_name == NULL){
-		mod_loc_name = estrdup(loc_name );	
+		mod_loc_name = estrdup(loc_name );
 	}
 
 	/* Proceed to ICU */
@@ -73,6 +73,7 @@
 		if( U_FAILURE( status ) ) {
 			if( status == U_BUFFER_OVERFLOW_ERROR ) {
 				status = U_ZERO_ERROR;
+				buflen++; /* add space for \0 */
 				continue;
 			}
 ","{'deleted_lines': ['\t\tsingletonPos = getSingletonPos( loc_name );\t', '\t\tmod_loc_name = estrdup(loc_name );\t'], 'added_lines': ['\t\tsingletonPos = getSingletonPos( loc_name );', '\t\tmod_loc_name = estrdup(loc_name );', '\t\t\t\tbuflen++; /* add space for \\0 */']}",True,"The get_icu_value_internal function in ext/intl/locale/locale_methods.c in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7 does not ensure the presence of a '\0' character, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted locale_get_primary_language call.",8.6,HIGH,2,test,2016-05-23T00:49:02Z,1
CVE-2016-5093,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #72241: get_icu_value_internal out-of-bounds read,97eff7eb57fc2320c267a949cffd622c38712484,https://github.com/php/php-src/commit/97eff7eb57fc2320c267a949cffd622c38712484,ext/intl/locale/locale_methods.c,get_icu_disp_value_src_php,"static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) 
{
const char* loc_name        = NULL;
int         loc_name_len    = 0;
const char* disp_loc_name       = NULL;
int         disp_loc_name_len   = 0;
int         free_loc_name       = 0;
UChar*      disp_name      = NULL;
int32_t     disp_name_len  = 0;
char*       mod_loc_name        = NULL;
int32_t     buflen          = 512;
UErrorCode  status          = U_ZERO_ERROR;
char*       utf8value= NULL;
int         utf8value_len   = 0;
char*       msg             = NULL;
int         grOffset    = 0;
intl_error_reset( NULL TSRMLS_CC );
if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, ""s|s"",
&loc_name, &loc_name_len , 
&disp_loc_name ,&disp_loc_name_len ) == FAILURE)
{
spprintf(&msg , 0, ""locale_get_display_%s : unable to parse input params"", tag_name );
intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 TSRMLS_CC );
efree(msg);
RETURN_FALSE;
}
if(loc_name_len > ULOC_FULLNAME_CAPACITY) {
spprintf(&msg , 0, ""locale_get_display_%s : name too long"", tag_name );
intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 TSRMLS_CC );
efree(msg);
RETURN_FALSE;
}
if(loc_name_len == 0) {
loc_name = intl_locale_get_default(TSRMLS_C);
}
if( strcmp(tag_name, DISP_NAME) != 0 ){
grOffset = findOffset( LOC_GRANDFATHERED , loc_name );
if( grOffset >= 0 ){
if( strcmp(tag_name , LOC_LANG_TAG)==0 ){
mod_loc_name = getPreferredTag( loc_name );
} else {
RETURN_FALSE;
}
}
} 
if( mod_loc_name==NULL ){
mod_loc_name = estrdup( loc_name );
}
if( !disp_loc_name){
disp_loc_name = estrdup(intl_locale_get_default(TSRMLS_C));
free_loc_name = 1;
}
do{
disp_name = erealloc( disp_name , buflen * sizeof(UChar)  );
disp_name_len = buflen;
if( strcmp(tag_name , LOC_LANG_TAG)==0 ){
buflen = uloc_getDisplayLanguage ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);
} else if( strcmp(tag_name , LOC_SCRIPT_TAG)==0 ){
buflen = uloc_getDisplayScript ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);
} else if( strcmp(tag_name , LOC_REGION_TAG)==0 ){
buflen = uloc_getDisplayCountry ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);
} else if( strcmp(tag_name , LOC_VARIANT_TAG)==0 ){
buflen = uloc_getDisplayVariant ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);
} else if( strcmp(tag_name , DISP_NAME)==0 ){
buflen = uloc_getDisplayName ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);
}
if( U_FAILURE( status ) )
{
if( status == U_BUFFER_OVERFLOW_ERROR )
{
status = U_ZERO_ERROR;
continue;
}
spprintf(&msg, 0, ""locale_get_display_%s : unable to get locale %s"", tag_name , tag_name );
intl_error_set( NULL, status, msg , 1 TSRMLS_CC );
efree(msg);
if( disp_name){
efree( disp_name );
}
if( mod_loc_name){
efree( mod_loc_name );
}
if (free_loc_name) {
efree((void *)disp_loc_name);
disp_loc_name = NULL;
}
RETURN_FALSE;
}
} while( buflen > disp_name_len );
if( mod_loc_name){
efree( mod_loc_name );
}
if (free_loc_name) {
efree((void *)disp_loc_name);
disp_loc_name = NULL;
}
intl_convert_utf16_to_utf8( &utf8value, &utf8value_len, disp_name, buflen, &status );
efree( disp_name );
if( U_FAILURE( status ) )
{
spprintf(&msg, 0, ""locale_get_display_%s :error converting display name for %s to UTF-8"", tag_name , tag_name );
intl_error_set( NULL, status, msg , 1 TSRMLS_CC );
efree(msg);
RETURN_FALSE;
}
RETVAL_STRINGL( utf8value, utf8value_len , FALSE);
}","static void get_icu_disp_value_src_php( char* VAR_0, INTERNAL_FUNCTION_PARAMETERS) 
{
const char* VAR_1        = NULL;
int         VAR_2    = 0;
const char* VAR_3       = NULL;
int         VAR_4   = 0;
int         VAR_5       = 0;
UChar*      VAR_6      = NULL;
int32_t     VAR_7  = 0;
char*       VAR_8        = NULL;
int32_t     VAR_9          = 512;
UErrorCode  VAR_10          = VAR_11;
char*       VAR_12= NULL;
int         VAR_13   = 0;
char*       VAR_14             = NULL;
int         VAR_15    = 0;
VAR_16( NULL TSRMLS_CC );
if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, ""s|s"",
&VAR_1, &VAR_2 , 
&VAR_3 ,&VAR_4 ) == VAR_17)
{
spprintf(&VAR_14 , 0, ""locale_get_display_%s : unable to parse input params"", VAR_0 );
intl_error_set( NULL, VAR_18,  VAR_14 , 1 TSRMLS_CC );
efree(VAR_14);
VAR_19;
}
if(VAR_2 > VAR_20) {
spprintf(&VAR_14 , 0, ""locale_get_display_%s : name too long"", VAR_0 );
intl_error_set( NULL, VAR_18,  VAR_14 , 1 TSRMLS_CC );
efree(VAR_14);
VAR_19;
}
if(VAR_2 == 0) {
VAR_1 = intl_locale_get_default(VAR_21);
}
if( strcmp(VAR_0, VAR_22) != 0 ){
VAR_15 = findOffset( VAR_23 , VAR_1 );
if( VAR_15 >= 0 ){
if( strcmp(VAR_0 , VAR_24)==0 ){
VAR_8 = getPreferredTag( VAR_1 );
} else {
VAR_19;
}
}
} 
if( VAR_8==NULL ){
VAR_8 = estrdup( VAR_1 );
}
if( !VAR_3){
VAR_3 = estrdup(intl_locale_get_default(VAR_21));
VAR_5 = 1;
}
do{
VAR_6 = erealloc( VAR_6 , VAR_9 * sizeof(UChar)  );
VAR_7 = VAR_9;
if( strcmp(VAR_0 , VAR_24)==0 ){
VAR_9 = uloc_getDisplayLanguage ( VAR_8 , VAR_3 , VAR_6 , VAR_7 , &VAR_10);
} else if( strcmp(VAR_0 , VAR_25)==0 ){
VAR_9 = uloc_getDisplayScript ( VAR_8 , VAR_3 , VAR_6 , VAR_7 , &VAR_10);
} else if( strcmp(VAR_0 , VAR_26)==0 ){
VAR_9 = uloc_getDisplayCountry ( VAR_8 , VAR_3 , VAR_6 , VAR_7 , &VAR_10);
} else if( strcmp(VAR_0 , VAR_27)==0 ){
VAR_9 = uloc_getDisplayVariant ( VAR_8 , VAR_3 , VAR_6 , VAR_7 , &VAR_10);
} else if( strcmp(VAR_0 , VAR_22)==0 ){
VAR_9 = uloc_getDisplayName ( VAR_8 , VAR_3 , VAR_6 , VAR_7 , &VAR_10);
}
if( U_FAILURE( VAR_10 ) )
{
if( VAR_10 == VAR_28 )
{
VAR_10 = VAR_11;
continue;
}
spprintf(&VAR_14, 0, ""locale_get_display_%s : unable to get locale %s"", VAR_0 , VAR_0 );
intl_error_set( NULL, VAR_10, VAR_14 , 1 TSRMLS_CC );
efree(VAR_14);
if( VAR_6){
efree( VAR_6 );
}
if( VAR_8){
efree( VAR_8 );
}
if (VAR_5) {
efree((void *)VAR_3);
VAR_3 = NULL;
}
VAR_19;
}
} while( VAR_9 > VAR_7 );
if( VAR_8){
efree( VAR_8 );
}
if (VAR_5) {
efree((void *)VAR_3);
VAR_3 = NULL;
}
intl_convert_utf16_to_utf8( &VAR_12, &VAR_13, VAR_6, VAR_9, &VAR_10 );
efree( VAR_6 );
if( U_FAILURE( VAR_10 ) )
{
spprintf(&VAR_14, 0, ""locale_get_display_%s :error converting display name for %s to UTF-8"", VAR_0 , VAR_0 );
intl_error_set( NULL, VAR_10, VAR_14 , 1 TSRMLS_CC );
efree(VAR_14);
VAR_19;
}
RETVAL_STRINGL( VAR_12, VAR_13 , FALSE);
}",php/php-src/97eff7eb57fc2320c267a949cffd622c38712484/locale_methods.c/vul/before/4.json,"static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)
{
	const char* loc_name        	= NULL;
	int         loc_name_len    	= 0;

	const char* disp_loc_name       = NULL;
	int         disp_loc_name_len   = 0;
	int         free_loc_name       = 0;

	UChar*      disp_name      	= NULL;
	int32_t     disp_name_len  	= 0;

	char*       mod_loc_name        = NULL;

	int32_t     buflen          	= 512;
	UErrorCode  status          	= U_ZERO_ERROR;

	char*       utf8value		= NULL;
	int         utf8value_len   	= 0;

  	char*       msg             	= NULL;
	int         grOffset    	= 0;

	intl_error_reset( NULL TSRMLS_CC );

	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, ""s|s"",
		&loc_name, &loc_name_len ,
		&disp_loc_name ,&disp_loc_name_len ) == FAILURE)
	{
		spprintf(&msg , 0, ""locale_get_display_%s : unable to parse input params"", tag_name );
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 TSRMLS_CC );
		efree(msg);
		RETURN_FALSE;
	}

    if(loc_name_len > ULOC_FULLNAME_CAPACITY) {
        /* See bug 67397: overlong locale names cause trouble in uloc_getDisplayName */
		spprintf(&msg , 0, ""locale_get_display_%s : name too long"", tag_name );
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 TSRMLS_CC );
		efree(msg);
		RETURN_FALSE;
    }

	if(loc_name_len == 0) {
		loc_name = intl_locale_get_default(TSRMLS_C);
	}

	if( strcmp(tag_name, DISP_NAME) != 0 ){
		/* Handle grandfathered languages */
		grOffset = findOffset( LOC_GRANDFATHERED , loc_name );
		if( grOffset >= 0 ){
			if( strcmp(tag_name , LOC_LANG_TAG)==0 ){
				mod_loc_name = getPreferredTag( loc_name );
			} else {
				/* Since Grandfathered, no value, do nothing, retutn NULL */
				RETURN_FALSE;
			}
		}
	} /* end of if != LOC_CANONICAL_TAG */

	if( mod_loc_name==NULL ){
		mod_loc_name = estrdup( loc_name );
	}

	/* Check if disp_loc_name passed , if not use default locale */
	if( !disp_loc_name){
		disp_loc_name = estrdup(intl_locale_get_default(TSRMLS_C));
		free_loc_name = 1;
	}

    /* Get the disp_value for the given locale */
    do{
        disp_name = erealloc( disp_name , buflen * sizeof(UChar)  );
        disp_name_len = buflen;

		if( strcmp(tag_name , LOC_LANG_TAG)==0 ){
			buflen = uloc_getDisplayLanguage ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);
		} else if( strcmp(tag_name , LOC_SCRIPT_TAG)==0 ){
			buflen = uloc_getDisplayScript ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);
		} else if( strcmp(tag_name , LOC_REGION_TAG)==0 ){
			buflen = uloc_getDisplayCountry ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);
		} else if( strcmp(tag_name , LOC_VARIANT_TAG)==0 ){
			buflen = uloc_getDisplayVariant ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);
		} else if( strcmp(tag_name , DISP_NAME)==0 ){
			buflen = uloc_getDisplayName ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);
		}

		/* U_STRING_NOT_TERMINATED_WARNING is admissible here; don't look for it */
		if( U_FAILURE( status ) )
		{
			if( status == U_BUFFER_OVERFLOW_ERROR )
			{
				status = U_ZERO_ERROR;
				continue;
			}

			spprintf(&msg, 0, ""locale_get_display_%s : unable to get locale %s"", tag_name , tag_name );
			intl_error_set( NULL, status, msg , 1 TSRMLS_CC );
			efree(msg);
			if( disp_name){
				efree( disp_name );
			}
			if( mod_loc_name){
				efree( mod_loc_name );
			}
			if (free_loc_name) {
				efree((void *)disp_loc_name);
				disp_loc_name = NULL;
			}
			RETURN_FALSE;
		}
	} while( buflen > disp_name_len );

	if( mod_loc_name){
		efree( mod_loc_name );
	}
	if (free_loc_name) {
		efree((void *)disp_loc_name);
		disp_loc_name = NULL;
	}
	/* Convert display locale name from UTF-16 to UTF-8. */
	intl_convert_utf16_to_utf8( &utf8value, &utf8value_len, disp_name, buflen, &status );
	efree( disp_name );
	if( U_FAILURE( status ) )
	{
		spprintf(&msg, 0, ""locale_get_display_%s :error converting display name for %s to UTF-8"", tag_name , tag_name );
		intl_error_set( NULL, status, msg , 1 TSRMLS_CC );
		efree(msg);
		RETURN_FALSE;
	}

	RETVAL_STRINGL( utf8value, utf8value_len , FALSE);

}","static void get_icu_disp_value_src_php( char* VAR_0, INTERNAL_FUNCTION_PARAMETERS)
{
	const char* VAR_1        	= NULL;
	int         VAR_2    	= 0;

	const char* VAR_3       = NULL;
	int         VAR_4   = 0;
	int         VAR_5       = 0;

	UChar*      VAR_6      	= NULL;
	int32_t     VAR_7  	= 0;

	char*       VAR_8        = NULL;

	int32_t     VAR_9          	= 512;
	UErrorCode  VAR_10          	= VAR_11;

	char*       VAR_12		= NULL;
	int         VAR_13   	= 0;

  	char*       VAR_14             	= NULL;
	int         VAR_15    	= 0;

	VAR_16( NULL TSRMLS_CC );

	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, ""s|s"",
		&VAR_1, &VAR_2 ,
		&VAR_3 ,&VAR_4 ) == VAR_17)
	{
		spprintf(&VAR_14 , 0, ""locale_get_display_%s : unable to parse input params"", VAR_0 );
		intl_error_set( NULL, VAR_18,  VAR_14 , 1 TSRMLS_CC );
		efree(VAR_14);
		VAR_19;
	}

    if(VAR_2 > VAR_20) {
        /* COMMENT_0 */
		spprintf(&VAR_14 , 0, ""locale_get_display_%s : name too long"", VAR_0 );
		intl_error_set( NULL, VAR_18,  VAR_14 , 1 TSRMLS_CC );
		efree(VAR_14);
		VAR_19;
    }

	if(VAR_2 == 0) {
		VAR_1 = intl_locale_get_default(VAR_21);
	}

	if( strcmp(VAR_0, VAR_22) != 0 ){
		/* COMMENT_1 */
		VAR_15 = findOffset( VAR_23 , VAR_1 );
		if( VAR_15 >= 0 ){
			if( strcmp(VAR_0 , VAR_24)==0 ){
				VAR_8 = getPreferredTag( VAR_1 );
			} else {
				/* COMMENT_2 */
				VAR_19;
			}
		}
	} /* COMMENT_3 */

	if( VAR_8==NULL ){
		VAR_8 = estrdup( VAR_1 );
	}

	/* COMMENT_4 */
	if( !VAR_3){
		VAR_3 = estrdup(intl_locale_get_default(VAR_21));
		VAR_5 = 1;
	}

    /* COMMENT_5 */
    do{
        VAR_6 = erealloc( VAR_6 , VAR_9 * sizeof(UChar)  );
        VAR_7 = VAR_9;

		if( strcmp(VAR_0 , VAR_24)==0 ){
			VAR_9 = uloc_getDisplayLanguage ( VAR_8 , VAR_3 , VAR_6 , VAR_7 , &VAR_10);
		} else if( strcmp(VAR_0 , VAR_25)==0 ){
			VAR_9 = uloc_getDisplayScript ( VAR_8 , VAR_3 , VAR_6 , VAR_7 , &VAR_10);
		} else if( strcmp(VAR_0 , VAR_26)==0 ){
			VAR_9 = uloc_getDisplayCountry ( VAR_8 , VAR_3 , VAR_6 , VAR_7 , &VAR_10);
		} else if( strcmp(VAR_0 , VAR_27)==0 ){
			VAR_9 = uloc_getDisplayVariant ( VAR_8 , VAR_3 , VAR_6 , VAR_7 , &VAR_10);
		} else if( strcmp(VAR_0 , VAR_22)==0 ){
			VAR_9 = uloc_getDisplayName ( VAR_8 , VAR_3 , VAR_6 , VAR_7 , &VAR_10);
		}

		/* COMMENT_6 */
		if( U_FAILURE( VAR_10 ) )
		{
			if( VAR_10 == VAR_28 )
			{
				VAR_10 = VAR_11;
				continue;
			}

			spprintf(&VAR_14, 0, ""locale_get_display_%s : unable to get locale %s"", VAR_0 , VAR_0 );
			intl_error_set( NULL, VAR_10, VAR_14 , 1 TSRMLS_CC );
			efree(VAR_14);
			if( VAR_6){
				efree( VAR_6 );
			}
			if( VAR_8){
				efree( VAR_8 );
			}
			if (VAR_5) {
				efree((void *)VAR_3);
				VAR_3 = NULL;
			}
			VAR_19;
		}
	} while( VAR_9 > VAR_7 );

	if( VAR_8){
		efree( VAR_8 );
	}
	if (VAR_5) {
		efree((void *)VAR_3);
		VAR_3 = NULL;
	}
	/* COMMENT_7 */
	intl_convert_utf16_to_utf8( &VAR_12, &VAR_13, VAR_6, VAR_9, &VAR_10 );
	efree( VAR_6 );
	if( U_FAILURE( VAR_10 ) )
	{
		spprintf(&VAR_14, 0, ""locale_get_display_%s :error converting display name for %s to UTF-8"", VAR_0 , VAR_0 );
		intl_error_set( NULL, VAR_10, VAR_14 , 1 TSRMLS_CC );
		efree(VAR_14);
		VAR_19;
	}

	RETVAL_STRINGL( VAR_12, VAR_13 , FALSE);

}",php/php-src/97eff7eb57fc2320c267a949cffd622c38712484/locale_methods.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) 
+static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)
 {
 	const char* loc_name        	= NULL;
 	int         loc_name_len    	= 0;
@@ -24,7 +24,7 @@
 	intl_error_reset( NULL TSRMLS_CC );
 
 	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, ""s|s"",
-		&loc_name, &loc_name_len , 
+		&loc_name, &loc_name_len ,
 		&disp_loc_name ,&disp_loc_name_len ) == FAILURE)
 	{
 		spprintf(&msg , 0, ""locale_get_display_%s : unable to parse input params"", tag_name );
@@ -61,7 +61,7 @@
 	if( mod_loc_name==NULL ){
 		mod_loc_name = estrdup( loc_name );
 	}
-	
+
 	/* Check if disp_loc_name passed , if not use default locale */
 	if( !disp_loc_name){
 		disp_loc_name = estrdup(intl_locale_get_default(TSRMLS_C));","{'deleted_lines': ['static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) ', '\t\t&loc_name, &loc_name_len , ', '\t'], 'added_lines': ['static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)', '\t\t&loc_name, &loc_name_len ,', '']}",True,"The get_icu_value_internal function in ext/intl/locale/locale_methods.c in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7 does not ensure the presence of a '\0' character, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted locale_get_primary_language call.",8.6,HIGH,2,test,2016-05-23T00:49:02Z,1
CVE-2016-5093,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #72241: get_icu_value_internal out-of-bounds read,97eff7eb57fc2320c267a949cffd622c38712484,https://github.com/php/php-src/commit/97eff7eb57fc2320c267a949cffd622c38712484,ext/intl/locale/locale_methods.c,append_multiple_key_values,"static int append_multiple_key_values(smart_str* loc_name, HashTable* hash_arr, char* key_name TSRMLS_DC)
{
zval**ele_value    = NULL;
int i = 0;
int isFirstSubtag = 0;
int max_value = 0;
if( zend_hash_find( hash_arr , key_name , strlen(key_name) + 1 ,(void **)&ele_value ) == SUCCESS ) {
if( Z_TYPE_PP(ele_value) == IS_STRING ){
add_prefix( loc_name , key_name);
smart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);
smart_str_appendl(loc_name, Z_STRVAL_PP(ele_value) , Z_STRLEN_PP(ele_value));
return SUCCESS;
} else if(Z_TYPE_PP(ele_value) == IS_ARRAY ) {
HashPosition pos;
HashTable *arr = HASH_OF(*ele_value);
zval **data = NULL;
zend_hash_internal_pointer_reset_ex(arr, &pos);
while(zend_hash_get_current_data_ex(arr, (void **)&data, &pos) != FAILURE) {
if(Z_TYPE_PP(data) != IS_STRING) {
return FAILURE;
}
if (isFirstSubtag++ == 0){
add_prefix(loc_name , key_name);
}
smart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);
smart_str_appendl(loc_name, Z_STRVAL_PP(data) , Z_STRLEN_PP(data));
zend_hash_move_forward_ex(arr, &pos);
}
return SUCCESS;
} else {
return FAILURE;
}
} else {
char cur_key_name[31];
if( strcmp(key_name , LOC_VARIANT_TAG) ==0 ){
max_value  = MAX_NO_VARIANT;
}
if( strcmp(key_name , LOC_EXTLANG_TAG) ==0 ){
max_value  = MAX_NO_EXTLANG;
}
if( strcmp(key_name , LOC_PRIVATE_TAG) ==0 ){
max_value  = MAX_NO_PRIVATE;
}
isFirstSubtag = 0;
for( i=0 ; i< max_value; i++ ){  
snprintf( cur_key_name , 30, ""%s%d"", key_name , i);
if( zend_hash_find( hash_arr , cur_key_name , strlen(cur_key_name) + 1,(void **)&ele_value ) == SUCCESS ){
if( Z_TYPE_PP(ele_value)!= IS_STRING ){
return FAILURE;
}
if (isFirstSubtag++ == 0){
add_prefix(loc_name , cur_key_name);
}
smart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);
smart_str_appendl(loc_name, Z_STRVAL_PP(ele_value) , Z_STRLEN_PP(ele_value));
}
} 
} 
return SUCCESS;
}","static int append_multiple_key_values(smart_str* VAR_0, HashTable* VAR_1, char* VAR_2 TSRMLS_DC)
{
zval**VAR_3    = NULL;
int VAR_4 = 0;
int VAR_5 = 0;
int VAR_6 = 0;
if( zend_hash_find( VAR_1 , VAR_2 , strlen(VAR_2) + 1 ,(void **)&VAR_3 ) == VAR_7 ) {
if( Z_TYPE_PP(VAR_3) == VAR_8 ){
add_prefix( VAR_0 , VAR_2);
smart_str_appendl(VAR_0, VAR_9 , sizeof(VAR_9)-1);
smart_str_appendl(VAR_0, Z_STRVAL_PP(VAR_3) , Z_STRLEN_PP(VAR_3));
return VAR_7;
} else if(Z_TYPE_PP(VAR_3) == VAR_10 ) {
HashPosition VAR_11;
HashTable *VAR_12 = HASH_OF(*VAR_3);
zval **VAR_13 = NULL;
zend_hash_internal_pointer_reset_ex(VAR_12, &VAR_11);
while(zend_hash_get_current_data_ex(VAR_12, (void **)&VAR_13, &VAR_11) != VAR_14) {
if(Z_TYPE_PP(VAR_13) != VAR_8) {
return VAR_14;
}
if (VAR_5++ == 0){
add_prefix(VAR_0 , VAR_2);
}
smart_str_appendl(VAR_0, VAR_9 , sizeof(VAR_9)-1);
smart_str_appendl(VAR_0, Z_STRVAL_PP(VAR_13) , Z_STRLEN_PP(VAR_13));
zend_hash_move_forward_ex(VAR_12, &VAR_11);
}
return VAR_7;
} else {
return VAR_14;
}
} else {
char VAR_15[31];
if( strcmp(VAR_2 , VAR_16) ==0 ){
VAR_6  = VAR_17;
}
if( strcmp(VAR_2 , VAR_18) ==0 ){
VAR_6  = VAR_19;
}
if( strcmp(VAR_2 , VAR_20) ==0 ){
VAR_6  = VAR_21;
}
VAR_5 = 0;
for( VAR_4=0 ; VAR_4< VAR_6; VAR_4++ ){  
snprintf( VAR_15 , 30, ""%s%d"", VAR_2 , VAR_4);
if( zend_hash_find( VAR_1 , VAR_15 , strlen(VAR_15) + 1,(void **)&VAR_3 ) == VAR_7 ){
if( Z_TYPE_PP(VAR_3)!= VAR_8 ){
return VAR_14;
}
if (VAR_5++ == 0){
add_prefix(VAR_0 , VAR_15);
}
smart_str_appendl(VAR_0, VAR_9 , sizeof(VAR_9)-1);
smart_str_appendl(VAR_0, Z_STRVAL_PP(VAR_3) , Z_STRLEN_PP(VAR_3));
}
} 
} 
return VAR_7;
}",,"static int append_multiple_key_values(smart_str* loc_name, HashTable* hash_arr, char* key_name TSRMLS_DC)
{
	zval**	ele_value    	= NULL;
	int 	i 		= 0;
	int 	isFirstSubtag 	= 0;
	int 	max_value 	= 0;

	/* Variant/ Extlang/Private etc. */
	if( zend_hash_find( hash_arr , key_name , strlen(key_name) + 1 ,(void **)&ele_value ) == SUCCESS ) {
		if( Z_TYPE_PP(ele_value) == IS_STRING ){
			add_prefix( loc_name , key_name);

			smart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);
			smart_str_appendl(loc_name, Z_STRVAL_PP(ele_value) , Z_STRLEN_PP(ele_value));
			return SUCCESS;
		} else if(Z_TYPE_PP(ele_value) == IS_ARRAY ) {
			HashPosition pos;
			HashTable *arr = HASH_OF(*ele_value);
			zval **data = NULL;

			zend_hash_internal_pointer_reset_ex(arr, &pos);
			while(zend_hash_get_current_data_ex(arr, (void **)&data, &pos) != FAILURE) {
				if(Z_TYPE_PP(data) != IS_STRING) {
					return FAILURE;
				}
				if (isFirstSubtag++ == 0){
					add_prefix(loc_name , key_name);
				}
				smart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);
				smart_str_appendl(loc_name, Z_STRVAL_PP(data) , Z_STRLEN_PP(data));
				zend_hash_move_forward_ex(arr, &pos);
			}
			return SUCCESS;
		} else {
			return FAILURE;
		}
	} else {
		char cur_key_name[31];
		/* Decide the max_value: the max. no. of elements allowed */
		if( strcmp(key_name , LOC_VARIANT_TAG) ==0 ){
			max_value  = MAX_NO_VARIANT;
		}
		if( strcmp(key_name , LOC_EXTLANG_TAG) ==0 ){
			max_value  = MAX_NO_EXTLANG;
		}
		if( strcmp(key_name , LOC_PRIVATE_TAG) ==0 ){
			max_value  = MAX_NO_PRIVATE;
		}

		/* Multiple variant values as variant0, variant1 ,variant2 */
		isFirstSubtag = 0;
		for( i=0 ; i< max_value; i++ ){
			snprintf( cur_key_name , 30, ""%s%d"", key_name , i);
			if( zend_hash_find( hash_arr , cur_key_name , strlen(cur_key_name) + 1,(void **)&ele_value ) == SUCCESS ){
				if( Z_TYPE_PP(ele_value)!= IS_STRING ){
					/* variant is not a string */
					return FAILURE;
				}
				/* Add the contents */
				if (isFirstSubtag++ == 0){
					add_prefix(loc_name , cur_key_name);
				}
				smart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);
				smart_str_appendl(loc_name, Z_STRVAL_PP(ele_value) , Z_STRLEN_PP(ele_value));
			}
		} /* end of for */
	} /* end of else */

	return SUCCESS;
}","static int append_multiple_key_values(smart_str* VAR_0, HashTable* VAR_1, char* VAR_2 TSRMLS_DC)
{
	zval**	VAR_3    	= NULL;
	int 	VAR_4 		= 0;
	int 	VAR_5 	= 0;
	int 	VAR_6 	= 0;

	/* COMMENT_0 */
	if( zend_hash_find( VAR_1 , VAR_2 , strlen(VAR_2) + 1 ,(void **)&VAR_3 ) == VAR_7 ) {
		if( Z_TYPE_PP(VAR_3) == VAR_8 ){
			add_prefix( VAR_0 , VAR_2);

			smart_str_appendl(VAR_0, VAR_9 , sizeof(VAR_9)-1);
			smart_str_appendl(VAR_0, Z_STRVAL_PP(VAR_3) , Z_STRLEN_PP(VAR_3));
			return VAR_7;
		} else if(Z_TYPE_PP(VAR_3) == VAR_10 ) {
			HashPosition VAR_11;
			HashTable *VAR_12 = HASH_OF(*VAR_3);
			zval **VAR_13 = NULL;

			zend_hash_internal_pointer_reset_ex(VAR_12, &VAR_11);
			while(zend_hash_get_current_data_ex(VAR_12, (void **)&VAR_13, &VAR_11) != VAR_14) {
				if(Z_TYPE_PP(VAR_13) != VAR_8) {
					return VAR_14;
				}
				if (VAR_5++ == 0){
					add_prefix(VAR_0 , VAR_2);
				}
				smart_str_appendl(VAR_0, VAR_9 , sizeof(VAR_9)-1);
				smart_str_appendl(VAR_0, Z_STRVAL_PP(VAR_13) , Z_STRLEN_PP(VAR_13));
				zend_hash_move_forward_ex(VAR_12, &VAR_11);
			}
			return VAR_7;
		} else {
			return VAR_14;
		}
	} else {
		char VAR_15[31];
		/* COMMENT_1 */
		if( strcmp(VAR_2 , VAR_16) ==0 ){
			VAR_6  = VAR_17;
		}
		if( strcmp(VAR_2 , VAR_18) ==0 ){
			VAR_6  = VAR_19;
		}
		if( strcmp(VAR_2 , VAR_20) ==0 ){
			VAR_6  = VAR_21;
		}

		/* COMMENT_2 */
		VAR_5 = 0;
		for( VAR_4=0 ; VAR_4< VAR_6; VAR_4++ ){
			snprintf( VAR_15 , 30, ""%s%d"", VAR_2 , VAR_4);
			if( zend_hash_find( VAR_1 , VAR_15 , strlen(VAR_15) + 1,(void **)&VAR_3 ) == VAR_7 ){
				if( Z_TYPE_PP(VAR_3)!= VAR_8 ){
					/* COMMENT_3 */
					return VAR_14;
				}
				/* COMMENT_4 */
				if (VAR_5++ == 0){
					add_prefix(VAR_0 , VAR_15);
				}
				smart_str_appendl(VAR_0, VAR_9 , sizeof(VAR_9)-1);
				smart_str_appendl(VAR_0, Z_STRVAL_PP(VAR_3) , Z_STRLEN_PP(VAR_3));
			}
		} /* COMMENT_5 */
	} /* COMMENT_6 */

	return VAR_7;
}",,"--- func_before
+++ func_after
@@ -49,8 +49,8 @@
 
 		/* Multiple variant values as variant0, variant1 ,variant2 */
 		isFirstSubtag = 0;
-		for( i=0 ; i< max_value; i++ ){  
-			snprintf( cur_key_name , 30, ""%s%d"", key_name , i);	
+		for( i=0 ; i< max_value; i++ ){
+			snprintf( cur_key_name , 30, ""%s%d"", key_name , i);
 			if( zend_hash_find( hash_arr , cur_key_name , strlen(cur_key_name) + 1,(void **)&ele_value ) == SUCCESS ){
 				if( Z_TYPE_PP(ele_value)!= IS_STRING ){
 					/* variant is not a string */","{'deleted_lines': ['\t\tfor( i=0 ; i< max_value; i++ ){  ', '\t\t\tsnprintf( cur_key_name , 30, ""%s%d"", key_name , i);\t'], 'added_lines': ['\t\tfor( i=0 ; i< max_value; i++ ){', '\t\t\tsnprintf( cur_key_name , 30, ""%s%d"", key_name , i);']}",True,"The get_icu_value_internal function in ext/intl/locale/locale_methods.c in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7 does not ensure the presence of a '\0' character, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted locale_get_primary_language call.",8.6,HIGH,2,test,2016-05-23T00:49:02Z,1
CVE-2016-5093,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #72241: get_icu_value_internal out-of-bounds read,97eff7eb57fc2320c267a949cffd622c38712484,https://github.com/php/php-src/commit/97eff7eb57fc2320c267a949cffd622c38712484,ext/intl/locale/locale_methods.c,getStrrtokenPos,"static int getStrrtokenPos(char* str, int savedPos)
{
int result =-1;
int i;
for(i=savedPos-1; i>=0; i--) {
if(isIDSeparator(*(str+i)) ){
if(i>=2 && isIDSeparator(*(str+i-2)) ){
result = i-2;
} else {
result = i;
}
break;
}
}
if(result < 1){
result =-1;
}
return result;
}","static int getStrrtokenPos(char* VAR_0, int VAR_1)
{
int VAR_2 =-1;
int VAR_3;
for(VAR_3=VAR_1-1; VAR_3>=0; VAR_3--) {
if(isIDSeparator(*(VAR_0+VAR_3)) ){
if(VAR_3>=2 && isIDSeparator(*(VAR_0+VAR_3-2)) ){
VAR_2 = VAR_3-2;
} else {
VAR_2 = VAR_3;
}
break;
}
}
if(VAR_2 < 1){
VAR_2 =-1;
}
return VAR_2;
}",php/php-src/97eff7eb57fc2320c267a949cffd622c38712484/locale_methods.c/vul/before/2.json,"static int getStrrtokenPos(char* str, int savedPos)
{
	int result =-1;
	int i;

	for(i=savedPos-1; i>=0; i--) {
		if(isIDSeparator(*(str+i)) ){
			/* delimiter found; check for singleton */
			if(i>=2 && isIDSeparator(*(str+i-2)) ){
				/* a singleton; so send the position of token before the singleton */
				result = i-2;
			} else {
				result = i;
			}
			break;
		}
	}
	if(result < 1){
		/* Just in case inavlid locale e.g. '-x-xyz' or '-sl_Latn' */
		result =-1;
	}
	return result;
}","static int getStrrtokenPos(char* VAR_0, int VAR_1)
{
	int VAR_2 =-1;
	int VAR_3;

	for(VAR_3=VAR_1-1; VAR_3>=0; VAR_3--) {
		if(isIDSeparator(*(VAR_0+VAR_3)) ){
			/* COMMENT_0 */
			if(VAR_3>=2 && isIDSeparator(*(VAR_0+VAR_3-2)) ){
				/* COMMENT_1 */
				VAR_2 = VAR_3-2;
			} else {
				VAR_2 = VAR_3;
			}
			break;
		}
	}
	if(VAR_2 < 1){
		/* COMMENT_2 */
		VAR_2 =-1;
	}
	return VAR_2;
}",php/php-src/97eff7eb57fc2320c267a949cffd622c38712484/locale_methods.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 {
 	int result =-1;
 	int i;
-	
+
 	for(i=savedPos-1; i>=0; i--) {
 		if(isIDSeparator(*(str+i)) ){
 			/* delimiter found; check for singleton */","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,"The get_icu_value_internal function in ext/intl/locale/locale_methods.c in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7 does not ensure the presence of a '\0' character, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted locale_get_primary_language call.",8.6,HIGH,2,test,2016-05-23T00:49:02Z,1
CVE-2016-5093,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #72241: get_icu_value_internal out-of-bounds read,97eff7eb57fc2320c267a949cffd622c38712484,https://github.com/php/php-src/commit/97eff7eb57fc2320c267a949cffd622c38712484,ext/intl/locale/locale_methods.c,array_cleanup,"static void array_cleanup( char* arr[] , int arr_size)
{
int i=0;
for( i=0; i< arr_size; i++ ){ 
if( arr[i*2] ){
efree( arr[i*2]);
}
}
efree(arr);
}","static void array_cleanup( char* VAR_0[] , int VAR_1)
{
int VAR_2=0;
for( VAR_2=0; VAR_2< VAR_1; VAR_2++ ){ 
if( VAR_0[VAR_2*2] ){
efree( VAR_0[VAR_2*2]);
}
}
efree(VAR_0);
}",php/php-src/97eff7eb57fc2320c267a949cffd622c38712484/locale_methods.c/vul/before/0.json,"static void array_cleanup( char* arr[] , int arr_size)
{
	int i=0;
	for( i=0; i< arr_size; i++ ){
		if( arr[i*2] ){
			efree( arr[i*2]);
		}
	}
	efree(arr);
}","static void array_cleanup( char* VAR_0[] , int VAR_1)
{
	int VAR_2=0;
	for( VAR_2=0; VAR_2< VAR_1; VAR_2++ ){
		if( VAR_0[VAR_2*2] ){
			efree( VAR_0[VAR_2*2]);
		}
	}
	efree(VAR_0);
}",php/php-src/97eff7eb57fc2320c267a949cffd622c38712484/locale_methods.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 static void array_cleanup( char* arr[] , int arr_size)
 {
 	int i=0;
-	for( i=0; i< arr_size; i++ ){ 
+	for( i=0; i< arr_size; i++ ){
 		if( arr[i*2] ){
 			efree( arr[i*2]);
 		}","{'deleted_lines': ['\tfor( i=0; i< arr_size; i++ ){ '], 'added_lines': ['\tfor( i=0; i< arr_size; i++ ){']}",True,"The get_icu_value_internal function in ext/intl/locale/locale_methods.c in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7 does not ensure the presence of a '\0' character, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted locale_get_primary_language call.",8.6,HIGH,2,test,2016-05-23T00:49:02Z,1
CVE-2013-7456,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,php/php-src,"Fixed bug #72227: imagescale out-of-bounds read

Ported from https://github.com/libgd/libgd/commit/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a",7a1aac3343af85b4af4df5f8844946eaa27394ab,https://github.com/php/php-src/commit/7a1aac3343af85b4af4df5f8844946eaa27394ab,ext/gd/libgd/gd_interpolation.c,_setEdgePixel,"static inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor) 
{
const gdFixed f_127 = gd_itofx(127);
register int c = src->tpixels[y][x];
c = c | (( (int) (gd_fxtof(gd_mulfx(coverage, f_127)) + 50.5f)) << 24);
return _color_blend(bgColor, c);
}","static inline int _setEdgePixel(const gdImagePtr VAR_0, unsigned int VAR_1, unsigned int VAR_2, gdFixed VAR_3, const int VAR_4) 
{
const gdFixed VAR_5 = gd_itofx(127);
register int VAR_6 = VAR_0->tpixels[VAR_2][VAR_1];
VAR_6 = VAR_6 | (( (int) (gd_fxtof(gd_mulfx(VAR_3, VAR_5)) + 50.5f)) << 24);
return _color_blend(VAR_4, VAR_6);
}",php/php-src/7a1aac3343af85b4af4df5f8844946eaa27394ab/gd_interpolation.c/vul/before/0.json,"static inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor)
{
	const gdFixed f_127 = gd_itofx(127);
	register int c = src->tpixels[y][x];
	c = c | (( (int) (gd_fxtof(gd_mulfx(coverage, f_127)) + 50.5f)) << 24);
	return _color_blend(bgColor, c);
}","static inline int _setEdgePixel(const gdImagePtr VAR_0, unsigned int VAR_1, unsigned int VAR_2, gdFixed VAR_3, const int VAR_4)
{
	const gdFixed VAR_5 = gd_itofx(127);
	register int VAR_6 = VAR_0->tpixels[VAR_2][VAR_1];
	VAR_6 = VAR_6 | (( (int) (gd_fxtof(gd_mulfx(VAR_3, VAR_5)) + 50.5f)) << 24);
	return _color_blend(VAR_4, VAR_6);
}",php/php-src/7a1aac3343af85b4af4df5f8844946eaa27394ab/gd_interpolation.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-static inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor) 
+static inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor)
 {
 	const gdFixed f_127 = gd_itofx(127);
 	register int c = src->tpixels[y][x];","{'deleted_lines': ['static inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor) '], 'added_lines': ['static inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor)']}",True,"gd_interpolation.c in the GD Graphics Library (aka libgd) before 2.1.1, as used in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7, allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted image that is mishandled by the imagescale function.",7.6,HIGH,2,test,2016-05-23T07:28:02Z,1
CVE-2013-7456,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,php/php-src,"Fixed bug #72227: imagescale out-of-bounds read

Ported from https://github.com/libgd/libgd/commit/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a",7a1aac3343af85b4af4df5f8844946eaa27394ab,https://github.com/php/php-src/commit/7a1aac3343af85b4af4df5f8844946eaa27394ab,ext/gd/libgd/gd_interpolation.c,gdTransformAffineCopy,"int gdTransformAffineCopy(gdImagePtr dst,
int dst_x, int dst_y,
const gdImagePtr src,
gdRectPtr src_region,
const double affine[6])
{
int c1x,c1y,c2x,c2y;
int backclip = 0;
int backup_clipx1, backup_clipy1, backup_clipx2, backup_clipy2;
register int x, y, src_offset_x, src_offset_y;
double inv[6];
int *dst_p;
gdPointF pt, src_pt;
gdRect bbox;
int end_x, end_y;
gdInterpolationMethod interpolation_id_bak = GD_DEFAULT;
interpolation_method interpolation_bak;
if (src->interpolation_id == GD_BILINEAR_FIXED || src->interpolation_id == GD_BICUBIC_FIXED || src->interpolation_id == GD_NEAREST_NEIGHBOUR) {
interpolation_id_bak = src->interpolation_id;
interpolation_bak = src->interpolation;
gdImageSetInterpolationMethod(src, GD_BICUBIC);
}
gdImageClipRectangle(src, src_region);
if (src_region->x > 0 || src_region->y > 0
|| src_region->width < gdImageSX(src)
|| src_region->height < gdImageSY(src)) {
backclip = 1;
gdImageGetClip(src, &backup_clipx1, &backup_clipy1,
&backup_clipx2, &backup_clipy2);
gdImageSetClip(src, src_region->x, src_region->y,
src_region->x + src_region->width - 1,
src_region->y + src_region->height - 1);
}
if (!gdTransformAffineBoundingBox(src_region, affine, &bbox)) {
if (backclip) {
gdImageSetClip(src, backup_clipx1, backup_clipy1,
backup_clipx2, backup_clipy2);
}
gdImageSetInterpolationMethod(src, interpolation_id_bak);
return GD_FALSE;
}
gdImageGetClip(dst, &c1x, &c1y, &c2x, &c2y);
end_x = bbox.width  + (int) fabs(bbox.x);
end_y = bbox.height + (int) fabs(bbox.y);
gdAffineInvert(inv, affine);
src_offset_x =  src_region->x;
src_offset_y =  src_region->y;
if (dst->alphaBlendingFlag) {
for (y = bbox.y; y <= end_y; y++) {
pt.y = y + 0.5;
for (x = 0; x <= end_x; x++) {
pt.x = x + 0.5;
gdAffineApplyToPointF(&src_pt, &pt, inv);
gdImageSetPixel(dst, dst_x + x, dst_y + y, getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, 0));
}
}
} else {
for (y = 0; y <= end_y; y++) {
pt.y = y + 0.5 + bbox.y;
if ((dst_y + y) < 0 || ((dst_y + y) > gdImageSY(dst) -1)) {
continue;
}
dst_p = dst->tpixels[dst_y + y] + dst_x;
for (x = 0; x <= end_x; x++) {
pt.x = x + 0.5 + bbox.x;
gdAffineApplyToPointF(&src_pt, &pt, inv);
if ((dst_x + x) < 0 || (dst_x + x) > (gdImageSX(dst) - 1)) {
break;
}
*(dst_p++) = getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, -1);
}
}
}
if (backclip) {
gdImageSetClip(src, backup_clipx1, backup_clipy1,
backup_clipx2, backup_clipy2);
}
gdImageSetInterpolationMethod(src, interpolation_id_bak);
return GD_TRUE;
}","int gdTransformAffineCopy(gdImagePtr VAR_0,
int VAR_1, int VAR_2,
const gdImagePtr VAR_3,
gdRectPtr VAR_4,
const double VAR_5[6])
{
int VAR_6,VAR_7,VAR_8,VAR_9;
int VAR_10 = 0;
int VAR_11, VAR_12, VAR_13, VAR_14;
register int VAR_15, VAR_16, VAR_17, VAR_18;
double VAR_19[6];
int *VAR_20;
gdPointF VAR_21, VAR_22;
gdRect VAR_23;
int VAR_24, VAR_25;
gdInterpolationMethod VAR_26 = VAR_27;
interpolation_method VAR_28;
if (VAR_3->interpolation_id == VAR_29 || VAR_3->interpolation_id == VAR_30 || VAR_3->interpolation_id == VAR_31) {
VAR_26 = VAR_3->interpolation_id;
VAR_28 = VAR_3->interpolation;
gdImageSetInterpolationMethod(VAR_3, VAR_32);
}
gdImageClipRectangle(VAR_3, VAR_4);
if (VAR_4->x > 0 || VAR_4->y > 0
|| VAR_4->width < gdImageSX(VAR_3)
|| VAR_4->height < gdImageSY(VAR_3)) {
VAR_10 = 1;
gdImageGetClip(VAR_3, &VAR_11, &VAR_12,
&VAR_13, &VAR_14);
gdImageSetClip(VAR_3, VAR_4->x, VAR_4->y,
VAR_4->x + VAR_4->width - 1,
VAR_4->y + VAR_4->height - 1);
}
if (!gdTransformAffineBoundingBox(VAR_4, VAR_5, &VAR_23)) {
if (VAR_10) {
gdImageSetClip(VAR_3, VAR_11, VAR_12,
VAR_13, VAR_14);
}
gdImageSetInterpolationMethod(VAR_3, VAR_26);
return VAR_33;
}
gdImageGetClip(VAR_0, &VAR_6, &VAR_7, &VAR_8, &VAR_9);
VAR_24 = VAR_23.width  + (int) fabs(VAR_23.x);
VAR_25 = VAR_23.height + (int) fabs(VAR_23.y);
gdAffineInvert(VAR_19, VAR_5);
VAR_17 =  VAR_4->x;
VAR_18 =  VAR_4->y;
if (VAR_0->alphaBlendingFlag) {
for (VAR_16 = VAR_23.y; VAR_16 <= VAR_25; VAR_16++) {
VAR_21.y = VAR_16 + 0.5;
for (VAR_15 = 0; VAR_15 <= VAR_24; VAR_15++) {
VAR_21.x = VAR_15 + 0.5;
gdAffineApplyToPointF(&VAR_22, &VAR_21, VAR_19);
gdImageSetPixel(VAR_0, VAR_1 + VAR_15, VAR_2 + VAR_16, getPixelInterpolated(VAR_3, VAR_17 + VAR_22.x, VAR_18 + VAR_22.y, 0));
}
}
} else {
for (VAR_16 = 0; VAR_16 <= VAR_25; VAR_16++) {
VAR_21.y = VAR_16 + 0.5 + VAR_23.y;
if ((VAR_2 + VAR_16) < 0 || ((VAR_2 + VAR_16) > gdImageSY(VAR_0) -1)) {
continue;
}
VAR_20 = VAR_0->tpixels[VAR_2 + VAR_16] + VAR_1;
for (VAR_15 = 0; VAR_15 <= VAR_24; VAR_15++) {
VAR_21.x = VAR_15 + 0.5 + VAR_23.x;
gdAffineApplyToPointF(&VAR_22, &VAR_21, VAR_19);
if ((VAR_1 + VAR_15) < 0 || (VAR_1 + VAR_15) > (gdImageSX(VAR_0) - 1)) {
break;
}
*(VAR_20++) = getPixelInterpolated(VAR_3, VAR_17 + VAR_22.x, VAR_18 + VAR_22.y, -1);
}
}
}
if (VAR_10) {
gdImageSetClip(VAR_3, VAR_11, VAR_12,
VAR_13, VAR_14);
}
gdImageSetInterpolationMethod(VAR_3, VAR_26);
return VAR_34;
}",php/php-src/7a1aac3343af85b4af4df5f8844946eaa27394ab/gd_interpolation.c/vul/before/3.json,"int gdTransformAffineCopy(gdImagePtr dst,
		  int dst_x, int dst_y,
		  const gdImagePtr src,
		  gdRectPtr src_region,
		  const double affine[6])
{
	int c1x,c1y,c2x,c2y;
	int backclip = 0;
	int backup_clipx1, backup_clipy1, backup_clipx2, backup_clipy2;
	register int x, y, src_offset_x, src_offset_y;
	double inv[6];
	int *dst_p;
	gdPointF pt, src_pt;
	gdRect bbox;
	int end_x, end_y;
	gdInterpolationMethod interpolation_id_bak = GD_DEFAULT;
	interpolation_method interpolation_bak;

	/* These methods use special implementations */
	if (src->interpolation_id == GD_BILINEAR_FIXED || src->interpolation_id == GD_BICUBIC_FIXED || src->interpolation_id == GD_NEAREST_NEIGHBOUR) {
		interpolation_id_bak = src->interpolation_id;
		interpolation_bak = src->interpolation;

		gdImageSetInterpolationMethod(src, GD_BICUBIC);
	}


	gdImageClipRectangle(src, src_region);

	if (src_region->x > 0 || src_region->y > 0
		|| src_region->width < gdImageSX(src)
		|| src_region->height < gdImageSY(src)) {
		backclip = 1;

		gdImageGetClip(src, &backup_clipx1, &backup_clipy1,
		&backup_clipx2, &backup_clipy2);

		gdImageSetClip(src, src_region->x, src_region->y,
			src_region->x + src_region->width - 1,
			src_region->y + src_region->height - 1);
	}

	if (!gdTransformAffineBoundingBox(src_region, affine, &bbox)) {
		if (backclip) {
			gdImageSetClip(src, backup_clipx1, backup_clipy1,
					backup_clipx2, backup_clipy2);
		}
		gdImageSetInterpolationMethod(src, interpolation_id_bak);
		return GD_FALSE;
	}

	gdImageGetClip(dst, &c1x, &c1y, &c2x, &c2y);

	end_x = bbox.width  + (int) fabs(bbox.x);
	end_y = bbox.height + (int) fabs(bbox.y);

	/* Get inverse affine to let us work with destination -> source */
	gdAffineInvert(inv, affine);

	src_offset_x =  src_region->x;
	src_offset_y =  src_region->y;

	if (dst->alphaBlendingFlag) {
		for (y = bbox.y; y <= end_y; y++) {
			pt.y = y + 0.5;
			for (x = 0; x <= end_x; x++) {
				pt.x = x + 0.5;
				gdAffineApplyToPointF(&src_pt, &pt, inv);
				gdImageSetPixel(dst, dst_x + x, dst_y + y, getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, 0));
			}
		}
	} else {
		for (y = 0; y <= end_y; y++) {
			pt.y = y + 0.5 + bbox.y;
			if ((dst_y + y) < 0 || ((dst_y + y) > gdImageSY(dst) -1)) {
				continue;
			}
			dst_p = dst->tpixels[dst_y + y] + dst_x;

			for (x = 0; x <= end_x; x++) {
				pt.x = x + 0.5 + bbox.x;
				gdAffineApplyToPointF(&src_pt, &pt, inv);

				if ((dst_x + x) < 0 || (dst_x + x) > (gdImageSX(dst) - 1)) {
					break;
				}
				*(dst_p++) = getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, -1);
			}
		}
	}

	/* Restore clip if required */
	if (backclip) {
		gdImageSetClip(src, backup_clipx1, backup_clipy1,
				backup_clipx2, backup_clipy2);
	}

	gdImageSetInterpolationMethod(src, interpolation_id_bak);
	return GD_TRUE;
}","int gdTransformAffineCopy(gdImagePtr VAR_0,
		  int VAR_1, int VAR_2,
		  const gdImagePtr VAR_3,
		  gdRectPtr VAR_4,
		  const double VAR_5[6])
{
	int VAR_6,VAR_7,VAR_8,VAR_9;
	int VAR_10 = 0;
	int VAR_11, VAR_12, VAR_13, VAR_14;
	register int VAR_15, VAR_16, VAR_17, VAR_18;
	double VAR_19[6];
	int *VAR_20;
	gdPointF VAR_21, VAR_22;
	gdRect VAR_23;
	int VAR_24, VAR_25;
	gdInterpolationMethod VAR_26 = VAR_27;
	interpolation_method VAR_28;

	/* COMMENT_0 */
	if (VAR_3->interpolation_id == VAR_29 || VAR_3->interpolation_id == VAR_30 || VAR_3->interpolation_id == VAR_31) {
		VAR_26 = VAR_3->interpolation_id;
		VAR_28 = VAR_3->interpolation;

		gdImageSetInterpolationMethod(VAR_3, VAR_32);
	}


	gdImageClipRectangle(VAR_3, VAR_4);

	if (VAR_4->x > 0 || VAR_4->y > 0
		|| VAR_4->width < gdImageSX(VAR_3)
		|| VAR_4->height < gdImageSY(VAR_3)) {
		VAR_10 = 1;

		gdImageGetClip(VAR_3, &VAR_11, &VAR_12,
		&VAR_13, &VAR_14);

		gdImageSetClip(VAR_3, VAR_4->x, VAR_4->y,
			VAR_4->x + VAR_4->width - 1,
			VAR_4->y + VAR_4->height - 1);
	}

	if (!gdTransformAffineBoundingBox(VAR_4, VAR_5, &VAR_23)) {
		if (VAR_10) {
			gdImageSetClip(VAR_3, VAR_11, VAR_12,
					VAR_13, VAR_14);
		}
		gdImageSetInterpolationMethod(VAR_3, VAR_26);
		return VAR_33;
	}

	gdImageGetClip(VAR_0, &VAR_6, &VAR_7, &VAR_8, &VAR_9);

	VAR_24 = VAR_23.width  + (int) fabs(VAR_23.x);
	VAR_25 = VAR_23.height + (int) fabs(VAR_23.y);

	/* COMMENT_1 */
	gdAffineInvert(VAR_19, VAR_5);

	VAR_17 =  VAR_4->x;
	VAR_18 =  VAR_4->y;

	if (VAR_0->alphaBlendingFlag) {
		for (VAR_16 = VAR_23.y; VAR_16 <= VAR_25; VAR_16++) {
			VAR_21.y = VAR_16 + 0.5;
			for (VAR_15 = 0; VAR_15 <= VAR_24; VAR_15++) {
				VAR_21.x = VAR_15 + 0.5;
				gdAffineApplyToPointF(&VAR_22, &VAR_21, VAR_19);
				gdImageSetPixel(VAR_0, VAR_1 + VAR_15, VAR_2 + VAR_16, getPixelInterpolated(VAR_3, VAR_17 + VAR_22.x, VAR_18 + VAR_22.y, 0));
			}
		}
	} else {
		for (VAR_16 = 0; VAR_16 <= VAR_25; VAR_16++) {
			VAR_21.y = VAR_16 + 0.5 + VAR_23.y;
			if ((VAR_2 + VAR_16) < 0 || ((VAR_2 + VAR_16) > gdImageSY(VAR_0) -1)) {
				continue;
			}
			VAR_20 = VAR_0->tpixels[VAR_2 + VAR_16] + VAR_1;

			for (VAR_15 = 0; VAR_15 <= VAR_24; VAR_15++) {
				VAR_21.x = VAR_15 + 0.5 + VAR_23.x;
				gdAffineApplyToPointF(&VAR_22, &VAR_21, VAR_19);

				if ((VAR_1 + VAR_15) < 0 || (VAR_1 + VAR_15) > (gdImageSX(VAR_0) - 1)) {
					break;
				}
				*(VAR_20++) = getPixelInterpolated(VAR_3, VAR_17 + VAR_22.x, VAR_18 + VAR_22.y, -1);
			}
		}
	}

	/* COMMENT_2 */
	if (VAR_10) {
		gdImageSetClip(VAR_3, VAR_11, VAR_12,
				VAR_13, VAR_14);
	}

	gdImageSetInterpolationMethod(VAR_3, VAR_26);
	return VAR_34;
}",php/php-src/7a1aac3343af85b4af4df5f8844946eaa27394ab/gd_interpolation.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -20,7 +20,7 @@
 	if (src->interpolation_id == GD_BILINEAR_FIXED || src->interpolation_id == GD_BICUBIC_FIXED || src->interpolation_id == GD_NEAREST_NEIGHBOUR) {
 		interpolation_id_bak = src->interpolation_id;
 		interpolation_bak = src->interpolation;
-		
+
 		gdImageSetInterpolationMethod(src, GD_BICUBIC);
 	}
 ","{'deleted_lines': ['\t\t'], 'added_lines': ['']}",True,"gd_interpolation.c in the GD Graphics Library (aka libgd) before 2.1.1, as used in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7, allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted image that is mishandled by the imagescale function.",7.6,HIGH,2,test,2016-05-23T07:28:02Z,1
CVE-2013-7456,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,php/php-src,"Fixed bug #72227: imagescale out-of-bounds read

Ported from https://github.com/libgd/libgd/commit/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a",7a1aac3343af85b4af4df5f8844946eaa27394ab,https://github.com/php/php-src/commit/7a1aac3343af85b4af4df5f8844946eaa27394ab,ext/gd/libgd/gd_interpolation.c,_gdContributionsCalc,"static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter)
{
double width_d;
double scale_f_d = 1.0;
const double filter_width_d = DEFAULT_BOX_RADIUS;
int windows_size;
unsigned int u;
LineContribType *res;
if (scale_d < 1.0) {
width_d = filter_width_d / scale_d;
scale_f_d = scale_d;
}  else {
width_d= filter_width_d;
}
windows_size = 2 * (int)ceil(width_d) + 1;
res = _gdContributionsAlloc(line_size, windows_size);
for (u = 0; u < line_size; u++) {
const double dCenter = (double)u / scale_d;
register int iLeft = MAX(0, (int)floor (dCenter - width_d));
int iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);
double dTotalWeight = 0.0;
int iSrc;
res->ContribRow[u].Left = iLeft;
res->ContribRow[u].Right = iRight;
if (iRight - iLeft + 1 > windows_size)  {
if (iLeft < ((int)src_size - 1 / 2))  {
iLeft++;
} else {
iRight--;
}
}
for (iSrc = iLeft; iSrc <= iRight; iSrc++) {
dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));
}
if (dTotalWeight < 0.0) {
_gdContributionsFree(res);
return NULL;
}
if (dTotalWeight > 0.0) {
for (iSrc = iLeft; iSrc <= iRight; iSrc++) {
res->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight;
}
}
}
return res;
}","static inline LineContribType *_gdContributionsCalc(unsigned int VAR_0, unsigned int VAR_1, double VAR_2,  const interpolation_method VAR_3)
{
double VAR_4;
double VAR_5 = 1.0;
const double VAR_6 = VAR_7;
int VAR_8;
unsigned int VAR_9;
LineContribType *VAR_10;
if (VAR_2 < 1.0) {
VAR_4 = VAR_6 / VAR_2;
VAR_5 = VAR_2;
}  else {
VAR_4= VAR_6;
}
VAR_8 = 2 * (int)ceil(VAR_4) + 1;
VAR_10 = _gdContributionsAlloc(VAR_0, VAR_8);
for (VAR_9 = 0; VAR_9 < VAR_0; VAR_9++) {
const double VAR_11 = (double)VAR_9 / VAR_2;
register int VAR_12 = MAX(0, (int)floor (VAR_11 - VAR_4));
int VAR_13 = MIN((int)ceil(VAR_11 + VAR_4), (int)VAR_1 - 1);
double VAR_14 = 0.0;
int VAR_15;
VAR_10->ContribRow[VAR_9].Left = VAR_12;
VAR_10->ContribRow[VAR_9].Right = VAR_13;
if (VAR_13 - VAR_12 + 1 > VAR_8)  {
if (VAR_12 < ((int)VAR_1 - 1 / 2))  {
VAR_12++;
} else {
VAR_13--;
}
}
for (VAR_15 = VAR_12; VAR_15 <= VAR_13; VAR_15++) {
VAR_14 += (VAR_10->ContribRow[VAR_9].Weights[VAR_15-VAR_12] =  VAR_5 * (*VAR_3)(VAR_5 * (VAR_11 - (double)VAR_15)));
}
if (VAR_14 < 0.0) {
_gdContributionsFree(VAR_10);
return NULL;
}
if (VAR_14 > 0.0) {
for (VAR_15 = VAR_12; VAR_15 <= VAR_13; VAR_15++) {
VAR_10->ContribRow[VAR_9].Weights[VAR_15-VAR_12] /= VAR_14;
}
}
}
return VAR_10;
}",php/php-src/7a1aac3343af85b4af4df5f8844946eaa27394ab/gd_interpolation.c/vul/before/2.json,"static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter)
{
    double width_d;
    double scale_f_d = 1.0;
    const double filter_width_d = DEFAULT_BOX_RADIUS;
	int windows_size;
	unsigned int u;
	LineContribType *res;

    if (scale_d < 1.0) {
        width_d = filter_width_d / scale_d;
        scale_f_d = scale_d;
    }  else {
        width_d= filter_width_d;
    }

    windows_size = 2 * (int)ceil(width_d) + 1;
    res = _gdContributionsAlloc(line_size, windows_size);

    for (u = 0; u < line_size; u++) {
        const double dCenter = (double)u / scale_d;
        /* get the significant edge points affecting the pixel */
        register int iLeft = MAX(0, (int)floor (dCenter - width_d));
        int iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);
        double dTotalWeight = 0.0;
		int iSrc;

        /* Cut edge points to fit in filter window in case of spill-off */
        if (iRight - iLeft + 1 > windows_size)  {
            if (iLeft < ((int)src_size - 1 / 2))  {
                iLeft++;
            } else {
                iRight--;
            }
        }

        res->ContribRow[u].Left = iLeft;
        res->ContribRow[u].Right = iRight;

        for (iSrc = iLeft; iSrc <= iRight; iSrc++) {
            dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));
        }

		if (dTotalWeight < 0.0) {
			_gdContributionsFree(res);
			return NULL;
		}

        if (dTotalWeight > 0.0) {
            for (iSrc = iLeft; iSrc <= iRight; iSrc++) {
                res->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight;
            }
        }
   }
   return res;
}","static inline LineContribType *_gdContributionsCalc(unsigned int VAR_0, unsigned int VAR_1, double VAR_2,  const interpolation_method VAR_3)
{
    double VAR_4;
    double VAR_5 = 1.0;
    const double VAR_6 = VAR_7;
	int VAR_8;
	unsigned int VAR_9;
	LineContribType *VAR_10;

    if (VAR_2 < 1.0) {
        VAR_4 = VAR_6 / VAR_2;
        VAR_5 = VAR_2;
    }  else {
        VAR_4= VAR_6;
    }

    VAR_8 = 2 * (int)ceil(VAR_4) + 1;
    VAR_10 = _gdContributionsAlloc(VAR_0, VAR_8);

    for (VAR_9 = 0; VAR_9 < VAR_0; VAR_9++) {
        const double VAR_11 = (double)VAR_9 / VAR_2;
        /* COMMENT_0 */
        register int VAR_12 = MAX(0, (int)floor (VAR_11 - VAR_4));
        int VAR_13 = MIN((int)ceil(VAR_11 + VAR_4), (int)VAR_1 - 1);
        double VAR_14 = 0.0;
		int VAR_15;

        /* COMMENT_1 */
        if (VAR_13 - VAR_12 + 1 > VAR_8)  {
            if (VAR_12 < ((int)VAR_1 - 1 / 2))  {
                VAR_12++;
            } else {
                VAR_13--;
            }
        }

        VAR_10->ContribRow[VAR_9].Left = VAR_12;
        VAR_10->ContribRow[VAR_9].Right = VAR_13;

        for (VAR_15 = VAR_12; VAR_15 <= VAR_13; VAR_15++) {
            VAR_14 += (VAR_10->ContribRow[VAR_9].Weights[VAR_15-VAR_12] =  VAR_5 * (*VAR_3)(VAR_5 * (VAR_11 - (double)VAR_15)));
        }

		if (VAR_14 < 0.0) {
			_gdContributionsFree(VAR_10);
			return NULL;
		}

        if (VAR_14 > 0.0) {
            for (VAR_15 = VAR_12; VAR_15 <= VAR_13; VAR_15++) {
                VAR_10->ContribRow[VAR_9].Weights[VAR_15-VAR_12] /= VAR_14;
            }
        }
   }
   return VAR_10;
}",php/php-src/7a1aac3343af85b4af4df5f8844946eaa27394ab/gd_interpolation.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -25,9 +25,6 @@
         double dTotalWeight = 0.0;
 		int iSrc;
 
-        res->ContribRow[u].Left = iLeft;
-        res->ContribRow[u].Right = iRight;
-
         /* Cut edge points to fit in filter window in case of spill-off */
         if (iRight - iLeft + 1 > windows_size)  {
             if (iLeft < ((int)src_size - 1 / 2))  {
@@ -36,6 +33,9 @@
                 iRight--;
             }
         }
+
+        res->ContribRow[u].Left = iLeft;
+        res->ContribRow[u].Right = iRight;
 
         for (iSrc = iLeft; iSrc <= iRight; iSrc++) {
             dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));","{'deleted_lines': ['        res->ContribRow[u].Left = iLeft;', '        res->ContribRow[u].Right = iRight;', ''], 'added_lines': ['', '        res->ContribRow[u].Left = iLeft;', '        res->ContribRow[u].Right = iRight;']}",True,"gd_interpolation.c in the GD Graphics Library (aka libgd) before 2.1.1, as used in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7, allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted image that is mishandled by the imagescale function.",7.6,HIGH,2,test,2016-05-23T07:28:02Z,1
CVE-2013-7456,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,php/php-src,"Fixed bug #72227: imagescale out-of-bounds read

Ported from https://github.com/libgd/libgd/commit/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a",7a1aac3343af85b4af4df5f8844946eaa27394ab,https://github.com/php/php-src/commit/7a1aac3343af85b4af4df5f8844946eaa27394ab,ext/gd/libgd/gd_interpolation.c,gdTransformAffineGetImage,"int gdTransformAffineGetImage(gdImagePtr *dst,
const gdImagePtr src,
gdRectPtr src_area,
const double affine[6])
{
int res;
double m[6];
gdRect bbox;
gdRect area_full;
if (src_area == NULL) {
area_full.x = 0;
area_full.y = 0;
area_full.width  = gdImageSX(src);
area_full.height = gdImageSY(src);
src_area = &area_full;
}
gdTransformAffineBoundingBox(src_area, affine, &bbox);
*dst = gdImageCreateTrueColor(bbox.width, bbox.height);
if (*dst == NULL) {
return GD_FALSE;
}
(*dst)->saveAlphaFlag = 1;
if (!src->trueColor) {
gdImagePaletteToTrueColor(src);
}
gdAffineTranslate(m, -bbox.x, -bbox.y);
gdAffineConcat(m, affine, m);
gdImageAlphaBlending(*dst, 0);
res = gdTransformAffineCopy(*dst,
0,0,
src,
src_area,
m);
if (res != GD_TRUE) {
gdImageDestroy(*dst);
dst = NULL;
return GD_FALSE;
} else {
return GD_TRUE;
}
}","int gdTransformAffineGetImage(gdImagePtr *VAR_0,
const gdImagePtr VAR_1,
gdRectPtr VAR_2,
const double VAR_3[6])
{
int VAR_4;
double VAR_5[6];
gdRect VAR_6;
gdRect VAR_7;
if (VAR_2 == NULL) {
VAR_7.x = 0;
VAR_7.y = 0;
VAR_7.width  = gdImageSX(VAR_1);
VAR_7.height = gdImageSY(VAR_1);
VAR_2 = &VAR_7;
}
gdTransformAffineBoundingBox(VAR_2, VAR_3, &VAR_6);
*VAR_0 = gdImageCreateTrueColor(VAR_6.width, VAR_6.height);
if (*VAR_0 == NULL) {
return VAR_8;
}
(*VAR_0)->saveAlphaFlag = 1;
if (!VAR_1->trueColor) {
gdImagePaletteToTrueColor(VAR_1);
}
gdAffineTranslate(VAR_5, -VAR_6.x, -VAR_6.y);
gdAffineConcat(VAR_5, VAR_3, VAR_5);
gdImageAlphaBlending(*VAR_0, 0);
VAR_4 = gdTransformAffineCopy(*VAR_0,
0,0,
VAR_1,
VAR_2,
VAR_5);
if (VAR_4 != VAR_9) {
gdImageDestroy(*VAR_0);
VAR_0 = NULL;
return VAR_8;
} else {
return VAR_9;
}
}",php/php-src/7a1aac3343af85b4af4df5f8844946eaa27394ab/gd_interpolation.c/vul/before/1.json,"int gdTransformAffineGetImage(gdImagePtr *dst,
		  const gdImagePtr src,
		  gdRectPtr src_area,
		  const double affine[6])
{
	int res;
	double m[6];
	gdRect bbox;
	gdRect area_full;

	if (src_area == NULL) {
		area_full.x = 0;
		area_full.y = 0;
		area_full.width  = gdImageSX(src);
		area_full.height = gdImageSY(src);
		src_area = &area_full;
	}

	gdTransformAffineBoundingBox(src_area, affine, &bbox);

	*dst = gdImageCreateTrueColor(bbox.width, bbox.height);
	if (*dst == NULL) {
		return GD_FALSE;
	}
	(*dst)->saveAlphaFlag = 1;

	if (!src->trueColor) {
		gdImagePaletteToTrueColor(src);
	}

	/* Translate to dst origin (0,0) */
	gdAffineTranslate(m, -bbox.x, -bbox.y);
	gdAffineConcat(m, affine, m);

	gdImageAlphaBlending(*dst, 0);

	res = gdTransformAffineCopy(*dst,
		  0,0,
		  src,
		  src_area,
		  m);

	if (res != GD_TRUE) {
		gdImageDestroy(*dst);
		dst = NULL;
		return GD_FALSE;
	} else {
		return GD_TRUE;
	}
}","int gdTransformAffineGetImage(gdImagePtr *VAR_0,
		  const gdImagePtr VAR_1,
		  gdRectPtr VAR_2,
		  const double VAR_3[6])
{
	int VAR_4;
	double VAR_5[6];
	gdRect VAR_6;
	gdRect VAR_7;

	if (VAR_2 == NULL) {
		VAR_7.x = 0;
		VAR_7.y = 0;
		VAR_7.width  = gdImageSX(VAR_1);
		VAR_7.height = gdImageSY(VAR_1);
		VAR_2 = &VAR_7;
	}

	gdTransformAffineBoundingBox(VAR_2, VAR_3, &VAR_6);

	*VAR_0 = gdImageCreateTrueColor(VAR_6.width, VAR_6.height);
	if (*VAR_0 == NULL) {
		return VAR_8;
	}
	(*VAR_0)->saveAlphaFlag = 1;

	if (!VAR_1->trueColor) {
		gdImagePaletteToTrueColor(VAR_1);
	}

	/* COMMENT_0 */
	gdAffineTranslate(VAR_5, -VAR_6.x, -VAR_6.y);
	gdAffineConcat(VAR_5, VAR_3, VAR_5);

	gdImageAlphaBlending(*VAR_0, 0);

	VAR_4 = gdTransformAffineCopy(*VAR_0,
		  0,0,
		  VAR_1,
		  VAR_2,
		  VAR_5);

	if (VAR_4 != VAR_9) {
		gdImageDestroy(*VAR_0);
		VAR_0 = NULL;
		return VAR_8;
	} else {
		return VAR_9;
	}
}",php/php-src/7a1aac3343af85b4af4df5f8844946eaa27394ab/gd_interpolation.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -27,7 +27,7 @@
 	if (!src->trueColor) {
 		gdImagePaletteToTrueColor(src);
 	}
-	
+
 	/* Translate to dst origin (0,0) */
 	gdAffineTranslate(m, -bbox.x, -bbox.y);
 	gdAffineConcat(m, affine, m);","{'deleted_lines': ['\t'], 'added_lines': ['']}",True,"gd_interpolation.c in the GD Graphics Library (aka libgd) before 2.1.1, as used in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7, allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted image that is mishandled by the imagescale function.",7.6,HIGH,2,test,2016-05-23T07:28:02Z,1
CVE-2016-4301,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,libarchive,Fix libarchive/archive_read_support_format_mtree.c:1388:11: error: array subscript is above array bounds,a550daeecf6bc689ade371349892ea17b5b97c77,https://github.com/libarchive/libarchive/commit/a550daeecf6bc689ade371349892ea17b5b97c77,libarchive/archive_read_support_format_mtree.c,parse_device,"static int
parse_device(dev_t *pdev, struct archive *a, char *val)
{
#define MAX_PACK_ARGS 3
unsigned long numbers[MAX_PACK_ARGS];
char *p, *dev;
int argc;
pack_t *pack;
dev_t result;
const char *error = NULL;
memset(pdev, 0, sizeof(*pdev));
if ((dev = strchr(val, ',')) != NULL) {
*dev++ = '\0';
if ((pack = pack_find(val)) == NULL) {
archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
""Unknown format `%s'"", val);
return ARCHIVE_WARN;
}
argc = 0;
while ((p = la_strsep(&dev, "","")) != NULL) {
if (*p == '\0') {
archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
""Missing number"");
return ARCHIVE_WARN;
}
numbers[argc++] = (unsigned long)mtree_atol(&p);
if (argc > MAX_PACK_ARGS) {
archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
""Too many arguments"");
return ARCHIVE_WARN;
}
}
if (argc < 2) {
archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
""Not enough arguments"");
return ARCHIVE_WARN;
}
result = (*pack)(argc, numbers, &error);
if (error != NULL) {
archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
""%s"", error);
return ARCHIVE_WARN;
}
} else {
result = (dev_t)mtree_atol(&val);
}
*pdev = result;
return ARCHIVE_OK;
#undef MAX_PACK_ARGS
}","static int
parse_device(dev_t *VAR_0, struct archive *VAR_1, char *VAR_2)
{
#define VAR_3 3
unsigned long VAR_4[VAR_3];
char *VAR_5, *VAR_6;
int VAR_7;
pack_t *VAR_8;
dev_t VAR_9;
const char *VAR_10 = NULL;
memset(VAR_0, 0, sizeof(*VAR_0));
if ((VAR_6 = strchr(VAR_2, ',')) != NULL) {
*VAR_6++ = '\0';
if ((VAR_8 = pack_find(VAR_2)) == NULL) {
archive_set_error(VAR_1, VAR_11,
""Unknown format `%s'"", VAR_2);
return VAR_12;
}
VAR_7 = 0;
while ((VAR_5 = la_strsep(&VAR_6, "","")) != NULL) {
if (*VAR_5 == '\0') {
archive_set_error(VAR_1, VAR_11,
""Missing number"");
return VAR_12;
}
VAR_4[VAR_7++] = (unsigned long)mtree_atol(&VAR_5);
if (VAR_7 > VAR_3) {
archive_set_error(VAR_1, VAR_11,
""Too many arguments"");
return VAR_12;
}
}
if (VAR_7 < 2) {
archive_set_error(VAR_1, VAR_11,
""Not enough arguments"");
return VAR_12;
}
VAR_9 = (*VAR_8)(VAR_7, VAR_4, &VAR_10);
if (VAR_10 != NULL) {
archive_set_error(VAR_1, VAR_11,
""%s"", VAR_10);
return VAR_12;
}
} else {
VAR_9 = (dev_t)mtree_atol(&VAR_2);
}
*VAR_0 = VAR_9;
return VAR_13;
#undef MAX_PACK_ARGS
}",libarchive/a550daeecf6bc689ade371349892ea17b5b97c77/archive_read_support_format_mtree.c/vul/before/0.json,"static int
parse_device(dev_t *pdev, struct archive *a, char *val)
{
#define MAX_PACK_ARGS 3
	unsigned long numbers[MAX_PACK_ARGS];
	char *p, *dev;
	int argc;
	pack_t *pack;
	dev_t result;
	const char *error = NULL;

	memset(pdev, 0, sizeof(*pdev));
	if ((dev = strchr(val, ',')) != NULL) {
		/*
		 * Device's major/minor are given in a specified format.
		 * Decode and pack it accordingly.
		 */
		*dev++ = '\0';
		if ((pack = pack_find(val)) == NULL) {
			archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Unknown format `%s'"", val);
			return ARCHIVE_WARN;
		}
		argc = 0;
		while ((p = la_strsep(&dev, "","")) != NULL) {
			if (*p == '\0') {
				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Missing number"");
				return ARCHIVE_WARN;
			}
			if (argc >= MAX_PACK_ARGS) {
				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Too many arguments"");
				return ARCHIVE_WARN;
			}
			numbers[argc++] = (unsigned long)mtree_atol(&p);
		}
		if (argc < 2) {
			archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Not enough arguments"");
			return ARCHIVE_WARN;
		}
		result = (*pack)(argc, numbers, &error);
		if (error != NULL) {
			archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""%s"", error);
			return ARCHIVE_WARN;
		}
	} else {
		/* file system raw value. */
		result = (dev_t)mtree_atol(&val);
	}
	*pdev = result;
	return ARCHIVE_OK;
#undef MAX_PACK_ARGS
}","static int
parse_device(dev_t *VAR_0, struct archive *VAR_1, char *VAR_2)
{
#define VAR_3 3
	unsigned long VAR_4[VAR_3];
	char *VAR_5, *VAR_6;
	int VAR_7;
	pack_t *VAR_8;
	dev_t VAR_9;
	const char *VAR_10 = NULL;

	memset(VAR_0, 0, sizeof(*VAR_0));
	if ((VAR_6 = strchr(VAR_2, ',')) != NULL) {
		/* COMMENT_0 */
                                                          
                                    
     
		*VAR_6++ = '\0';
		if ((VAR_8 = pack_find(VAR_2)) == NULL) {
			archive_set_error(VAR_1, VAR_11,
			    ""Unknown format `%s'"", VAR_2);
			return VAR_12;
		}
		VAR_7 = 0;
		while ((VAR_5 = la_strsep(&VAR_6, "","")) != NULL) {
			if (*VAR_5 == '\0') {
				archive_set_error(VAR_1, VAR_11,
				    ""Missing number"");
				return VAR_12;
			}
			if (VAR_7 >= VAR_3) {
				archive_set_error(VAR_1, VAR_11,
				    ""Too many arguments"");
				return VAR_12;
			}
			VAR_4[VAR_7++] = (unsigned long)mtree_atol(&VAR_5);
		}
		if (VAR_7 < 2) {
			archive_set_error(VAR_1, VAR_11,
			    ""Not enough arguments"");
			return VAR_12;
		}
		VAR_9 = (*VAR_8)(VAR_7, VAR_4, &VAR_10);
		if (VAR_10 != NULL) {
			archive_set_error(VAR_1, VAR_11,
			    ""%s"", VAR_10);
			return VAR_12;
		}
	} else {
		/* COMMENT_4 */
		VAR_9 = (dev_t)mtree_atol(&VAR_2);
	}
	*VAR_0 = VAR_9;
	return VAR_13;
#undef MAX_PACK_ARGS
}",libarchive/a550daeecf6bc689ade371349892ea17b5b97c77/archive_read_support_format_mtree.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -28,12 +28,12 @@
 				    ""Missing number"");
 				return ARCHIVE_WARN;
 			}
-			numbers[argc++] = (unsigned long)mtree_atol(&p);
-			if (argc > MAX_PACK_ARGS) {
+			if (argc >= MAX_PACK_ARGS) {
 				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
 				    ""Too many arguments"");
 				return ARCHIVE_WARN;
 			}
+			numbers[argc++] = (unsigned long)mtree_atol(&p);
 		}
 		if (argc < 2) {
 			archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,","{'deleted_lines': ['\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);', '\t\t\tif (argc > MAX_PACK_ARGS) {'], 'added_lines': ['\t\t\tif (argc >= MAX_PACK_ARGS) {', '\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);']}",True,Stack-based buffer overflow in the parse_device function in archive_read_support_format_mtree.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a crafted mtree file.,7.8,HIGH,2,test,2016-06-10T14:54:43Z,1
CVE-2016-5772,['CWE-415'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,php/php-src,Fix bug #72340: Double Free Courruption in wddx_deserialize,a44c89e8af7c2410f4bfc5e097be2a5d0639a60c,https://github.com/php/php-src/commit/a44c89e8af7c2410f4bfc5e097be2a5d0639a60c,ext/wddx/wddx.c,php_wddx_process_data,"static void php_wddx_process_data(void *user_data, const XML_Char *s, int len)
{
st_entry *ent;
wddx_stack *stack = (wddx_stack *)user_data;
TSRMLS_FETCH();
if (!wddx_stack_is_empty(stack) && !stack->done) {
wddx_stack_top(stack, (void**)&ent);
switch (ent->type) {
case ST_STRING:
if (Z_STRLEN_P(ent->data) == 0) {
STR_FREE(Z_STRVAL_P(ent->data));
Z_STRVAL_P(ent->data) = estrndup(s, len);
Z_STRLEN_P(ent->data) = len;
} else {
Z_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);
memcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);
Z_STRLEN_P(ent->data) += len;
Z_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\0';
}
break;
case ST_BINARY:
if (Z_STRLEN_P(ent->data) == 0) {
STR_FREE(Z_STRVAL_P(ent->data));
Z_STRVAL_P(ent->data) = estrndup(s, len + 1);
} else {
Z_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);
memcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);
}
Z_STRLEN_P(ent->data) += len;
Z_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\0';
break;
case ST_NUMBER:
Z_TYPE_P(ent->data) = IS_STRING;
Z_STRLEN_P(ent->data) = len;
Z_STRVAL_P(ent->data) = estrndup(s, len);
convert_scalar_to_number(ent->data TSRMLS_CC);
break;
case ST_BOOLEAN:
if (!strcmp(s, ""true"")) {
Z_LVAL_P(ent->data) = 1;
} else if (!strcmp(s, ""false"")) {
Z_LVAL_P(ent->data) = 0;
} else {
zval_ptr_dtor(&ent->data);
if (ent->varname) {
efree(ent->varname);
}
ent->data = NULL;
}
break;
case ST_DATETIME: {
char *tmp;
tmp = emalloc(len + 1);
memcpy(tmp, s, len);
tmp[len] = '\0';
Z_LVAL_P(ent->data) = php_parse_date(tmp, NULL);
if (Z_LVAL_P(ent->data) == -1) {
Z_TYPE_P(ent->data) = IS_STRING;
Z_STRLEN_P(ent->data) = len;
Z_STRVAL_P(ent->data) = estrndup(s, len);
}
efree(tmp);
}
break;
default:
break;
}
}
}","static void php_wddx_process_data(void *VAR_0, const XML_Char *VAR_1, int VAR_2)
{
st_entry *VAR_3;
wddx_stack *VAR_4 = (wddx_stack *)VAR_0;
TSRMLS_FETCH();
if (!wddx_stack_is_empty(VAR_4) && !VAR_4->done) {
wddx_stack_top(VAR_4, (void**)&VAR_3);
switch (VAR_3->type) {
case VAR_5:
if (Z_STRLEN_P(VAR_3->data) == 0) {
STR_FREE(Z_STRVAL_P(VAR_3->data));
Z_STRVAL_P(VAR_3->data) = estrndup(VAR_1, VAR_2);
Z_STRLEN_P(VAR_3->data) = VAR_2;
} else {
Z_STRVAL_P(VAR_3->data) = erealloc(Z_STRVAL_P(VAR_3->data), Z_STRLEN_P(VAR_3->data) + VAR_2 + 1);
memcpy(Z_STRVAL_P(VAR_3->data) + Z_STRLEN_P(VAR_3->data), VAR_1, VAR_2);
Z_STRLEN_P(VAR_3->data) += VAR_2;
Z_STRVAL_P(VAR_3->data)[Z_STRLEN_P(VAR_3->data)] = '\0';
}
break;
case VAR_6:
if (Z_STRLEN_P(VAR_3->data) == 0) {
STR_FREE(Z_STRVAL_P(VAR_3->data));
Z_STRVAL_P(VAR_3->data) = estrndup(VAR_1, VAR_2 + 1);
} else {
Z_STRVAL_P(VAR_3->data) = erealloc(Z_STRVAL_P(VAR_3->data), Z_STRLEN_P(VAR_3->data) + VAR_2 + 1);
memcpy(Z_STRVAL_P(VAR_3->data) + Z_STRLEN_P(VAR_3->data), VAR_1, VAR_2);
}
Z_STRLEN_P(VAR_3->data) += VAR_2;
Z_STRVAL_P(VAR_3->data)[Z_STRLEN_P(VAR_3->data)] = '\0';
break;
case VAR_7:
Z_TYPE_P(VAR_3->data) = VAR_8;
Z_STRLEN_P(VAR_3->data) = VAR_2;
Z_STRVAL_P(VAR_3->data) = estrndup(VAR_1, VAR_2);
convert_scalar_to_number(VAR_3->data VAR_9);
break;
case VAR_10:
if (!strcmp(VAR_1, ""true"")) {
Z_LVAL_P(VAR_3->data) = 1;
} else if (!strcmp(VAR_1, ""false"")) {
Z_LVAL_P(VAR_3->data) = 0;
} else {
zval_ptr_dtor(&VAR_3->data);
if (VAR_3->varname) {
efree(VAR_3->varname);
}
VAR_3->data = NULL;
}
break;
case VAR_11: {
char *VAR_12;
VAR_12 = emalloc(VAR_2 + 1);
memcpy(VAR_12, VAR_1, VAR_2);
VAR_12[VAR_2] = '\0';
Z_LVAL_P(VAR_3->data) = php_parse_date(VAR_12, NULL);
if (Z_LVAL_P(VAR_3->data) == -1) {
Z_TYPE_P(VAR_3->data) = VAR_8;
Z_STRLEN_P(VAR_3->data) = VAR_2;
Z_STRVAL_P(VAR_3->data) = estrndup(VAR_1, VAR_2);
}
efree(VAR_12);
}
break;
default:
break;
}
}
}",php/php-src/a44c89e8af7c2410f4bfc5e097be2a5d0639a60c/wddx.c/vul/before/0.json,"static void php_wddx_process_data(void *user_data, const XML_Char *s, int len)
{
	st_entry *ent;
	wddx_stack *stack = (wddx_stack *)user_data;
	TSRMLS_FETCH();

	if (!wddx_stack_is_empty(stack) && !stack->done) {
		wddx_stack_top(stack, (void**)&ent);
		switch (ent->type) {
			case ST_STRING:
				if (Z_STRLEN_P(ent->data) == 0) {
					STR_FREE(Z_STRVAL_P(ent->data));
					Z_STRVAL_P(ent->data) = estrndup(s, len);
					Z_STRLEN_P(ent->data) = len;
				} else {
					Z_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);
					memcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);
					Z_STRLEN_P(ent->data) += len;
					Z_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\0';
				}
				break;

			case ST_BINARY:
				if (Z_STRLEN_P(ent->data) == 0) {
					STR_FREE(Z_STRVAL_P(ent->data));
					Z_STRVAL_P(ent->data) = estrndup(s, len + 1);
				} else {
					Z_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);
					memcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);
				}
				Z_STRLEN_P(ent->data) += len;
				Z_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\0';
				break;

			case ST_NUMBER:
				Z_TYPE_P(ent->data) = IS_STRING;
				Z_STRLEN_P(ent->data) = len;
				Z_STRVAL_P(ent->data) = estrndup(s, len);
				convert_scalar_to_number(ent->data TSRMLS_CC);
				break;

			case ST_BOOLEAN:
				if(!ent->data) {
					break;
				}
				if (!strcmp(s, ""true"")) {
					Z_LVAL_P(ent->data) = 1;
				} else if (!strcmp(s, ""false"")) {
					Z_LVAL_P(ent->data) = 0;
				} else {
					zval_ptr_dtor(&ent->data);
					if (ent->varname) {
						efree(ent->varname);
						ent->varname = NULL;
					}
					ent->data = NULL;
				}
				break;

			case ST_DATETIME: {
				char *tmp;

				tmp = emalloc(len + 1);
				memcpy(tmp, s, len);
				tmp[len] = '\0';

				Z_LVAL_P(ent->data) = php_parse_date(tmp, NULL);
				/* date out of range < 1969 or > 2038 */
				if (Z_LVAL_P(ent->data) == -1) {
					Z_TYPE_P(ent->data) = IS_STRING;
					Z_STRLEN_P(ent->data) = len;
					Z_STRVAL_P(ent->data) = estrndup(s, len);
				}
				efree(tmp);
			}
				break;

			default:
				break;
		}
	}
}","static void php_wddx_process_data(void *VAR_0, const XML_Char *VAR_1, int VAR_2)
{
	st_entry *VAR_3;
	wddx_stack *VAR_4 = (wddx_stack *)VAR_0;
	TSRMLS_FETCH();

	if (!wddx_stack_is_empty(VAR_4) && !VAR_4->done) {
		wddx_stack_top(VAR_4, (void**)&VAR_3);
		switch (VAR_3->type) {
			case VAR_5:
				if (Z_STRLEN_P(VAR_3->data) == 0) {
					STR_FREE(Z_STRVAL_P(VAR_3->data));
					Z_STRVAL_P(VAR_3->data) = estrndup(VAR_1, VAR_2);
					Z_STRLEN_P(VAR_3->data) = VAR_2;
				} else {
					Z_STRVAL_P(VAR_3->data) = erealloc(Z_STRVAL_P(VAR_3->data), Z_STRLEN_P(VAR_3->data) + VAR_2 + 1);
					memcpy(Z_STRVAL_P(VAR_3->data) + Z_STRLEN_P(VAR_3->data), VAR_1, VAR_2);
					Z_STRLEN_P(VAR_3->data) += VAR_2;
					Z_STRVAL_P(VAR_3->data)[Z_STRLEN_P(VAR_3->data)] = '\0';
				}
				break;

			case VAR_6:
				if (Z_STRLEN_P(VAR_3->data) == 0) {
					STR_FREE(Z_STRVAL_P(VAR_3->data));
					Z_STRVAL_P(VAR_3->data) = estrndup(VAR_1, VAR_2 + 1);
				} else {
					Z_STRVAL_P(VAR_3->data) = erealloc(Z_STRVAL_P(VAR_3->data), Z_STRLEN_P(VAR_3->data) + VAR_2 + 1);
					memcpy(Z_STRVAL_P(VAR_3->data) + Z_STRLEN_P(VAR_3->data), VAR_1, VAR_2);
				}
				Z_STRLEN_P(VAR_3->data) += VAR_2;
				Z_STRVAL_P(VAR_3->data)[Z_STRLEN_P(VAR_3->data)] = '\0';
				break;

			case VAR_7:
				Z_TYPE_P(VAR_3->data) = VAR_8;
				Z_STRLEN_P(VAR_3->data) = VAR_2;
				Z_STRVAL_P(VAR_3->data) = estrndup(VAR_1, VAR_2);
				convert_scalar_to_number(VAR_3->data VAR_9);
				break;

			case VAR_10:
				if(!VAR_3->data) {
					break;
				}
				if (!strcmp(VAR_1, ""true"")) {
					Z_LVAL_P(VAR_3->data) = 1;
				} else if (!strcmp(VAR_1, ""false"")) {
					Z_LVAL_P(VAR_3->data) = 0;
				} else {
					zval_ptr_dtor(&VAR_3->data);
					if (VAR_3->varname) {
						efree(VAR_3->varname);
						VAR_3->varname = NULL;
					}
					VAR_3->data = NULL;
				}
				break;

			case VAR_11: {
				char *VAR_12;

				VAR_12 = emalloc(VAR_2 + 1);
				memcpy(VAR_12, VAR_1, VAR_2);
				VAR_12[VAR_2] = '\0';

				Z_LVAL_P(VAR_3->data) = php_parse_date(VAR_12, NULL);
				/* COMMENT_0 */
				if (Z_LVAL_P(VAR_3->data) == -1) {
					Z_TYPE_P(VAR_3->data) = VAR_8;
					Z_STRLEN_P(VAR_3->data) = VAR_2;
					Z_STRVAL_P(VAR_3->data) = estrndup(VAR_1, VAR_2);
				}
				efree(VAR_12);
			}
				break;

			default:
				break;
		}
	}
}",php/php-src/a44c89e8af7c2410f4bfc5e097be2a5d0639a60c/wddx.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -40,6 +40,9 @@
 				break;
 
 			case ST_BOOLEAN:
+				if(!ent->data) {
+					break;
+				}
 				if (!strcmp(s, ""true"")) {
 					Z_LVAL_P(ent->data) = 1;
 				} else if (!strcmp(s, ""false"")) {
@@ -48,6 +51,7 @@
 					zval_ptr_dtor(&ent->data);
 					if (ent->varname) {
 						efree(ent->varname);
+						ent->varname = NULL;
 					}
 					ent->data = NULL;
 				}","{'deleted_lines': [], 'added_lines': ['\t\t\t\tif(!ent->data) {', '\t\t\t\t\tbreak;', '\t\t\t\t}', '\t\t\t\t\t\tent->varname = NULL;']}",True,"Double free vulnerability in the php_wddx_process_data function in wddx.c in the WDDX extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via crafted XML data that is mishandled in a wddx_deserialize call.",9.8,CRITICAL,3,test,2016-06-13T06:18:23Z,1
CVE-2016-4302,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,libarchive,"Issue 719:  Fix for TALOS-CAN-154

A RAR file with an invalid zero dictionary size was not being
rejected, leading to a zero-sized allocation for the dictionary
storage which was then overwritten during the dictionary initialization.

Thanks to the Open Source and Threat Intelligence project at Cisco for
reporting this.",05caadc7eedbef471ac9610809ba683f0c698700,https://github.com/libarchive/libarchive/commit/05caadc7eedbef471ac9610809ba683f0c698700,libarchive/archive_read_support_format_rar.c,parse_codes,"static int
parse_codes(struct archive_read *a)
{
int i, j, val, n, r;
unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;
unsigned int maxorder;
struct huffman_code precode;
struct rar *rar = (struct rar *)(a->format->data);
struct rar_br *br = &(rar->br);
free_codes(a);
rar_br_consume_unalined_bits(br);
if (!rar_br_read_ahead(a, br, 1))
goto truncated_data;
if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0)
{
rar_br_consume(br, 1);
if (!rar_br_read_ahead(a, br, 7))
goto truncated_data;
ppmd_flags = rar_br_bits(br, 7);
rar_br_consume(br, 7);
if (ppmd_flags & 0x20)
{
if (!rar_br_read_ahead(a, br, 8))
goto truncated_data;
rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20;
rar_br_consume(br, 8);
}
if (ppmd_flags & 0x40)
{
if (!rar_br_read_ahead(a, br, 8))
goto truncated_data;
rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8);
rar_br_consume(br, 8);
}
else
rar->ppmd_escape = 2;
if (ppmd_flags & 0x20)
{
maxorder = (ppmd_flags & 0x1F) + 1;
if(maxorder > 16)
maxorder = 16 + (maxorder - 16) * 3;
if (maxorder == 1)
{
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Truncated RAR file data"");
return (ARCHIVE_FATAL);
}
__archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context, &g_szalloc);
rar->bytein.a = a;
rar->bytein.Read = &ppmd_read;
__archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);
rar->range_dec.Stream = &rar->bytein;
__archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);
if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,
rar->dictionary_size, &g_szalloc))
{
archive_set_error(&a->archive, ENOMEM,
""Out of memory"");
return (ARCHIVE_FATAL);
}
if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))
{
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Unable to initialize PPMd range decoder"");
return (ARCHIVE_FATAL);
}
__archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder);
rar->ppmd_valid = 1;
}
else
{
if (!rar->ppmd_valid) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Invalid PPMd sequence"");
return (ARCHIVE_FATAL);
}
if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))
{
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Unable to initialize PPMd range decoder"");
return (ARCHIVE_FATAL);
}
}
}
else
{
rar_br_consume(br, 1);
if (!rar_br_read_ahead(a, br, 1))
goto truncated_data;
if (!rar_br_bits(br, 1))
memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
rar_br_consume(br, 1);
memset(&bitlengths, 0, sizeof(bitlengths));
for (i = 0; i < MAX_SYMBOLS;)
{
if (!rar_br_read_ahead(a, br, 4))
goto truncated_data;
bitlengths[i++] = rar_br_bits(br, 4);
rar_br_consume(br, 4);
if (bitlengths[i-1] == 0xF)
{
if (!rar_br_read_ahead(a, br, 4))
goto truncated_data;
zerocount = rar_br_bits(br, 4);
rar_br_consume(br, 4);
if (zerocount)
{
i--;
for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++)
bitlengths[i++] = 0;
}
}
}
memset(&precode, 0, sizeof(precode));
r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH);
if (r != ARCHIVE_OK) {
free(precode.tree);
free(precode.table);
return (r);
}
for (i = 0; i < HUFFMAN_TABLE_SIZE;)
{
if ((val = read_next_symbol(a, &precode)) < 0) {
free(precode.tree);
free(precode.table);
return (ARCHIVE_FATAL);
}
if (val < 16)
{
rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF;
i++;
}
else if (val < 18)
{
if (i == 0)
{
free(precode.tree);
free(precode.table);
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Internal error extracting RAR file."");
return (ARCHIVE_FATAL);
}
if(val == 16) {
if (!rar_br_read_ahead(a, br, 3)) {
free(precode.tree);
free(precode.table);
goto truncated_data;
}
n = rar_br_bits(br, 3) + 3;
rar_br_consume(br, 3);
} else {
if (!rar_br_read_ahead(a, br, 7)) {
free(precode.tree);
free(precode.table);
goto truncated_data;
}
n = rar_br_bits(br, 7) + 11;
rar_br_consume(br, 7);
}
for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)
{
rar->lengthtable[i] = rar->lengthtable[i-1];
i++;
}
}
else
{
if(val == 18) {
if (!rar_br_read_ahead(a, br, 3)) {
free(precode.tree);
free(precode.table);
goto truncated_data;
}
n = rar_br_bits(br, 3) + 3;
rar_br_consume(br, 3);
} else {
if (!rar_br_read_ahead(a, br, 7)) {
free(precode.tree);
free(precode.table);
goto truncated_data;
}
n = rar_br_bits(br, 7) + 11;
rar_br_consume(br, 7);
}
for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)
rar->lengthtable[i++] = 0;
}
}
free(precode.tree);
free(precode.table);
r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE,
MAX_SYMBOL_LENGTH);
if (r != ARCHIVE_OK)
return (r);
r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE],
OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);
if (r != ARCHIVE_OK)
return (r);
r = create_code(a, &rar->lowoffsetcode,
&rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE],
LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);
if (r != ARCHIVE_OK)
return (r);
r = create_code(a, &rar->lengthcode,
&rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE +
LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH);
if (r != ARCHIVE_OK)
return (r);
}
if (!rar->dictionary_size || !rar->lzss.window)
{
void *new_window;
unsigned int new_size;
if (rar->unp_size >= DICTIONARY_MAX_SIZE)
new_size = DICTIONARY_MAX_SIZE;
else
new_size = rar_fls((unsigned int)rar->unp_size) << 1;
new_window = realloc(rar->lzss.window, new_size);
if (new_window == NULL) {
archive_set_error(&a->archive, ENOMEM,
""Unable to allocate memory for uncompressed data."");
return (ARCHIVE_FATAL);
}
rar->lzss.window = (unsigned char *)new_window;
rar->dictionary_size = new_size;
memset(rar->lzss.window, 0, rar->dictionary_size);
rar->lzss.mask = rar->dictionary_size - 1;
}
rar->start_new_table = 0;
return (ARCHIVE_OK);
truncated_data:
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Truncated RAR file data"");
rar->valid = 0;
return (ARCHIVE_FATAL);
}","static int
parse_codes(struct archive_read *VAR_0)
{
int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5;
unsigned char VAR_6[VAR_7], VAR_8, VAR_9;
unsigned int VAR_10;
struct huffman_code VAR_11;
struct rar *rar = (struct rar *)(VAR_0->format->data);
struct rar_br *VAR_12 = &(rar->br);
free_codes(VAR_0);
rar_br_consume_unalined_bits(VAR_12);
if (!rar_br_read_ahead(VAR_0, VAR_12, 1))
goto truncated_data;
if ((rar->is_ppmd_block = rar_br_bits(VAR_12, 1)) != 0)
{
rar_br_consume(VAR_12, 1);
if (!rar_br_read_ahead(VAR_0, VAR_12, 7))
goto truncated_data;
VAR_9 = rar_br_bits(VAR_12, 7);
rar_br_consume(VAR_12, 7);
if (VAR_9 & 0x20)
{
if (!rar_br_read_ahead(VAR_0, VAR_12, 8))
goto truncated_data;
rar->dictionary_size = (rar_br_bits(VAR_12, 8) + 1) << 20;
rar_br_consume(VAR_12, 8);
}
if (VAR_9 & 0x40)
{
if (!rar_br_read_ahead(VAR_0, VAR_12, 8))
goto truncated_data;
rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(VAR_12, 8);
rar_br_consume(VAR_12, 8);
}
else
rar->ppmd_escape = 2;
if (VAR_9 & 0x20)
{
VAR_10 = (VAR_9 & 0x1F) + 1;
if(VAR_10 > 16)
VAR_10 = 16 + (VAR_10 - 16) * 3;
if (VAR_10 == 1)
{
archive_set_error(&VAR_0->archive, VAR_13,
""Truncated RAR file data"");
return (VAR_14);
}
VAR_15.Ppmd7_Free(&rar->ppmd7_context, &VAR_16);
rar->bytein.a = VAR_0;
rar->bytein.Read = &VAR_17;
VAR_15.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);
rar->range_dec.Stream = &rar->bytein;
VAR_15.Ppmd7_Construct(&rar->ppmd7_context);
if (!VAR_15.Ppmd7_Alloc(&rar->ppmd7_context,
rar->dictionary_size, &VAR_16))
{
archive_set_error(&VAR_0->archive, VAR_18,
""Out of memory"");
return (VAR_14);
}
if (!VAR_15.PpmdRAR_RangeDec_Init(&rar->range_dec))
{
archive_set_error(&VAR_0->archive, VAR_13,
""Unable to initialize PPMd range decoder"");
return (VAR_14);
}
VAR_15.Ppmd7_Init(&rar->ppmd7_context, VAR_10);
rar->ppmd_valid = 1;
}
else
{
if (!rar->ppmd_valid) {
archive_set_error(&VAR_0->archive, VAR_13,
""Invalid PPMd sequence"");
return (VAR_14);
}
if (!VAR_15.PpmdRAR_RangeDec_Init(&rar->range_dec))
{
archive_set_error(&VAR_0->archive, VAR_13,
""Unable to initialize PPMd range decoder"");
return (VAR_14);
}
}
}
else
{
rar_br_consume(VAR_12, 1);
if (!rar_br_read_ahead(VAR_0, VAR_12, 1))
goto truncated_data;
if (!rar_br_bits(VAR_12, 1))
memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
rar_br_consume(VAR_12, 1);
memset(&VAR_6, 0, sizeof(VAR_6));
for (VAR_1 = 0; VAR_1 < VAR_7;)
{
if (!rar_br_read_ahead(VAR_0, VAR_12, 4))
goto truncated_data;
VAR_6[VAR_1++] = rar_br_bits(VAR_12, 4);
rar_br_consume(VAR_12, 4);
if (VAR_6[VAR_1-1] == 0xF)
{
if (!rar_br_read_ahead(VAR_0, VAR_12, 4))
goto truncated_data;
VAR_8 = rar_br_bits(VAR_12, 4);
rar_br_consume(VAR_12, 4);
if (VAR_8)
{
VAR_1--;
for (VAR_2 = 0; VAR_2 < VAR_8 + 2 && VAR_1 < VAR_7; VAR_2++)
VAR_6[VAR_1++] = 0;
}
}
}
memset(&VAR_11, 0, sizeof(VAR_11));
VAR_5 = create_code(VAR_0, &VAR_11, VAR_6, VAR_7, VAR_19);
if (VAR_5 != VAR_20) {
free(VAR_11.tree);
free(VAR_11.table);
return (VAR_5);
}
for (VAR_1 = 0; VAR_1 < VAR_21;)
{
if ((VAR_3 = read_next_symbol(VAR_0, &VAR_11)) < 0) {
free(VAR_11.tree);
free(VAR_11.table);
return (VAR_14);
}
if (VAR_3 < 16)
{
rar->lengthtable[VAR_1] = (rar->lengthtable[VAR_1] + VAR_3) & 0xF;
VAR_1++;
}
else if (VAR_3 < 18)
{
if (VAR_1 == 0)
{
free(VAR_11.tree);
free(VAR_11.table);
archive_set_error(&VAR_0->archive, VAR_13,
""Internal error extracting RAR file."");
return (VAR_14);
}
if(VAR_3 == 16) {
if (!rar_br_read_ahead(VAR_0, VAR_12, 3)) {
free(VAR_11.tree);
free(VAR_11.table);
goto truncated_data;
}
VAR_4 = rar_br_bits(VAR_12, 3) + 3;
rar_br_consume(VAR_12, 3);
} else {
if (!rar_br_read_ahead(VAR_0, VAR_12, 7)) {
free(VAR_11.tree);
free(VAR_11.table);
goto truncated_data;
}
VAR_4 = rar_br_bits(VAR_12, 7) + 11;
rar_br_consume(VAR_12, 7);
}
for (VAR_2 = 0; VAR_2 < VAR_4 && VAR_1 < VAR_21; VAR_2++)
{
rar->lengthtable[VAR_1] = rar->lengthtable[VAR_1-1];
VAR_1++;
}
}
else
{
if(VAR_3 == 18) {
if (!rar_br_read_ahead(VAR_0, VAR_12, 3)) {
free(VAR_11.tree);
free(VAR_11.table);
goto truncated_data;
}
VAR_4 = rar_br_bits(VAR_12, 3) + 3;
rar_br_consume(VAR_12, 3);
} else {
if (!rar_br_read_ahead(VAR_0, VAR_12, 7)) {
free(VAR_11.tree);
free(VAR_11.table);
goto truncated_data;
}
VAR_4 = rar_br_bits(VAR_12, 7) + 11;
rar_br_consume(VAR_12, 7);
}
for(VAR_2 = 0; VAR_2 < VAR_4 && VAR_1 < VAR_21; VAR_2++)
rar->lengthtable[VAR_1++] = 0;
}
}
free(VAR_11.tree);
free(VAR_11.table);
VAR_5 = create_code(VAR_0, &rar->maincode, &rar->lengthtable[0], VAR_22,
VAR_19);
if (VAR_5 != VAR_20)
return (VAR_5);
VAR_5 = create_code(VAR_0, &rar->offsetcode, &rar->lengthtable[VAR_22],
VAR_23, VAR_19);
if (VAR_5 != VAR_20)
return (VAR_5);
VAR_5 = create_code(VAR_0, &rar->lowoffsetcode,
&rar->lengthtable[VAR_22 + VAR_23],
VAR_24, VAR_19);
if (VAR_5 != VAR_20)
return (VAR_5);
VAR_5 = create_code(VAR_0, &rar->lengthcode,
&rar->lengthtable[VAR_22 + VAR_23 +
VAR_24], VAR_25, VAR_19);
if (VAR_5 != VAR_20)
return (VAR_5);
}
if (!rar->dictionary_size || !rar->lzss.window)
{
void *VAR_26;
unsigned int VAR_27;
if (rar->unp_size >= VAR_28)
VAR_27 = VAR_28;
else
VAR_27 = rar_fls((unsigned int)rar->unp_size) << 1;
VAR_26 = realloc(rar->lzss.window, VAR_27);
if (VAR_26 == NULL) {
archive_set_error(&VAR_0->archive, VAR_18,
""Unable to allocate memory for uncompressed data."");
return (VAR_14);
}
rar->lzss.window = (unsigned char *)VAR_26;
rar->dictionary_size = VAR_27;
memset(rar->lzss.window, 0, rar->dictionary_size);
rar->lzss.mask = rar->dictionary_size - 1;
}
rar->start_new_table = 0;
return (VAR_20);
truncated_data:
archive_set_error(&VAR_0->archive, VAR_13,
""Truncated RAR file data"");
rar->valid = 0;
return (VAR_14);
}",libarchive/05caadc7eedbef471ac9610809ba683f0c698700/archive_read_support_format_rar.c/vul/before/0.json,"static int
parse_codes(struct archive_read *a)
{
  int i, j, val, n, r;
  unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;
  unsigned int maxorder;
  struct huffman_code precode;
  struct rar *rar = (struct rar *)(a->format->data);
  struct rar_br *br = &(rar->br);

  free_codes(a);

  /* Skip to the next byte */
  rar_br_consume_unalined_bits(br);

  /* PPMd block flag */
  if (!rar_br_read_ahead(a, br, 1))
    goto truncated_data;
  if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0)
  {
    rar_br_consume(br, 1);
    if (!rar_br_read_ahead(a, br, 7))
      goto truncated_data;
    ppmd_flags = rar_br_bits(br, 7);
    rar_br_consume(br, 7);

    /* Memory is allocated in MB */
    if (ppmd_flags & 0x20)
    {
      if (!rar_br_read_ahead(a, br, 8))
        goto truncated_data;
      rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20;
      rar_br_consume(br, 8);
    }

    if (ppmd_flags & 0x40)
    {
      if (!rar_br_read_ahead(a, br, 8))
        goto truncated_data;
      rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8);
      rar_br_consume(br, 8);
    }
    else
      rar->ppmd_escape = 2;

    if (ppmd_flags & 0x20)
    {
      maxorder = (ppmd_flags & 0x1F) + 1;
      if(maxorder > 16)
        maxorder = 16 + (maxorder - 16) * 3;

      if (maxorder == 1)
      {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Truncated RAR file data"");
        return (ARCHIVE_FATAL);
      }

      /* Make sure ppmd7_contest is freed before Ppmd7_Construct
       * because reading a broken file cause this abnormal sequence. */
      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context, &g_szalloc);

      rar->bytein.a = a;
      rar->bytein.Read = &ppmd_read;
      __archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);
      rar->range_dec.Stream = &rar->bytein;
      __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);

      if (rar->dictionary_size == 0) {
	      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Invalid zero dictionary size"");
	      return (ARCHIVE_FATAL);
      }

      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,
        rar->dictionary_size, &g_szalloc))
      {
        archive_set_error(&a->archive, ENOMEM,
                          ""Out of memory"");
        return (ARCHIVE_FATAL);
      }
      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))
      {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Unable to initialize PPMd range decoder"");
        return (ARCHIVE_FATAL);
      }
      __archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder);
      rar->ppmd_valid = 1;
    }
    else
    {
      if (!rar->ppmd_valid) {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Invalid PPMd sequence"");
        return (ARCHIVE_FATAL);
      }
      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))
      {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""Unable to initialize PPMd range decoder"");
        return (ARCHIVE_FATAL);
      }
    }
  }
  else
  {
    rar_br_consume(br, 1);

    /* Keep existing table flag */
    if (!rar_br_read_ahead(a, br, 1))
      goto truncated_data;
    if (!rar_br_bits(br, 1))
      memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
    rar_br_consume(br, 1);

    memset(&bitlengths, 0, sizeof(bitlengths));
    for (i = 0; i < MAX_SYMBOLS;)
    {
      if (!rar_br_read_ahead(a, br, 4))
        goto truncated_data;
      bitlengths[i++] = rar_br_bits(br, 4);
      rar_br_consume(br, 4);
      if (bitlengths[i-1] == 0xF)
      {
        if (!rar_br_read_ahead(a, br, 4))
          goto truncated_data;
        zerocount = rar_br_bits(br, 4);
        rar_br_consume(br, 4);
        if (zerocount)
        {
          i--;
          for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++)
            bitlengths[i++] = 0;
        }
      }
    }

    memset(&precode, 0, sizeof(precode));
    r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK) {
      free(precode.tree);
      free(precode.table);
      return (r);
    }

    for (i = 0; i < HUFFMAN_TABLE_SIZE;)
    {
      if ((val = read_next_symbol(a, &precode)) < 0) {
        free(precode.tree);
        free(precode.table);
        return (ARCHIVE_FATAL);
      }
      if (val < 16)
      {
        rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF;
        i++;
      }
      else if (val < 18)
      {
        if (i == 0)
        {
          free(precode.tree);
          free(precode.table);
          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                            ""Internal error extracting RAR file."");
          return (ARCHIVE_FATAL);
        }

        if(val == 16) {
          if (!rar_br_read_ahead(a, br, 3)) {
            free(precode.tree);
            free(precode.table);
            goto truncated_data;
          }
          n = rar_br_bits(br, 3) + 3;
          rar_br_consume(br, 3);
        } else {
          if (!rar_br_read_ahead(a, br, 7)) {
            free(precode.tree);
            free(precode.table);
            goto truncated_data;
          }
          n = rar_br_bits(br, 7) + 11;
          rar_br_consume(br, 7);
        }

        for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)
        {
          rar->lengthtable[i] = rar->lengthtable[i-1];
          i++;
        }
      }
      else
      {
        if(val == 18) {
          if (!rar_br_read_ahead(a, br, 3)) {
            free(precode.tree);
            free(precode.table);
            goto truncated_data;
          }
          n = rar_br_bits(br, 3) + 3;
          rar_br_consume(br, 3);
        } else {
          if (!rar_br_read_ahead(a, br, 7)) {
            free(precode.tree);
            free(precode.table);
            goto truncated_data;
          }
          n = rar_br_bits(br, 7) + 11;
          rar_br_consume(br, 7);
        }

        for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)
          rar->lengthtable[i++] = 0;
      }
    }
    free(precode.tree);
    free(precode.table);

    r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE,
                MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK)
      return (r);
    r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE],
                OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK)
      return (r);
    r = create_code(a, &rar->lowoffsetcode,
                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE],
                LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK)
      return (r);
    r = create_code(a, &rar->lengthcode,
                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE +
                LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH);
    if (r != ARCHIVE_OK)
      return (r);
  }

  if (!rar->dictionary_size || !rar->lzss.window)
  {
    /* Seems as though dictionary sizes are not used. Even so, minimize
     * memory usage as much as possible.
     */
    void *new_window;
    unsigned int new_size;

    if (rar->unp_size >= DICTIONARY_MAX_SIZE)
      new_size = DICTIONARY_MAX_SIZE;
    else
      new_size = rar_fls((unsigned int)rar->unp_size) << 1;
    new_window = realloc(rar->lzss.window, new_size);
    if (new_window == NULL) {
      archive_set_error(&a->archive, ENOMEM,
                        ""Unable to allocate memory for uncompressed data."");
      return (ARCHIVE_FATAL);
    }
    rar->lzss.window = (unsigned char *)new_window;
    rar->dictionary_size = new_size;
    memset(rar->lzss.window, 0, rar->dictionary_size);
    rar->lzss.mask = rar->dictionary_size - 1;
  }

  rar->start_new_table = 0;
  return (ARCHIVE_OK);
truncated_data:
  archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                    ""Truncated RAR file data"");
  rar->valid = 0;
  return (ARCHIVE_FATAL);
}","static int
parse_codes(struct archive_read *VAR_0)
{
  int VAR_1, VAR_2, VAR_3, VAR_4, VAR_5;
  unsigned char VAR_6[VAR_7], VAR_8, VAR_9;
  unsigned int VAR_10;
  struct huffman_code VAR_11;
  struct rar *rar = (struct rar *)(VAR_0->format->data);
  struct rar_br *VAR_12 = &(rar->br);

  free_codes(VAR_0);

  /* COMMENT_0 */
  rar_br_consume_unalined_bits(VAR_12);

  /* COMMENT_1 */
  if (!rar_br_read_ahead(VAR_0, VAR_12, 1))
    goto truncated_data;
  if ((rar->is_ppmd_block = rar_br_bits(VAR_12, 1)) != 0)
  {
    rar_br_consume(VAR_12, 1);
    if (!rar_br_read_ahead(VAR_0, VAR_12, 7))
      goto truncated_data;
    VAR_9 = rar_br_bits(VAR_12, 7);
    rar_br_consume(VAR_12, 7);

    /* COMMENT_2 */
    if (VAR_9 & 0x20)
    {
      if (!rar_br_read_ahead(VAR_0, VAR_12, 8))
        goto truncated_data;
      rar->dictionary_size = (rar_br_bits(VAR_12, 8) + 1) << 20;
      rar_br_consume(VAR_12, 8);
    }

    if (VAR_9 & 0x40)
    {
      if (!rar_br_read_ahead(VAR_0, VAR_12, 8))
        goto truncated_data;
      rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(VAR_12, 8);
      rar_br_consume(VAR_12, 8);
    }
    else
      rar->ppmd_escape = 2;

    if (VAR_9 & 0x20)
    {
      VAR_10 = (VAR_9 & 0x1F) + 1;
      if(VAR_10 > 16)
        VAR_10 = 16 + (VAR_10 - 16) * 3;

      if (VAR_10 == 1)
      {
        archive_set_error(&VAR_0->archive, VAR_13,
                          ""Truncated RAR file data"");
        return (VAR_14);
      }

      /* COMMENT_3 */
                                                                       
      VAR_15.Ppmd7_Free(&rar->ppmd7_context, &VAR_16);

      rar->bytein.a = VAR_0;
      rar->bytein.Read = &VAR_17;
      VAR_15.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);
      rar->range_dec.Stream = &rar->bytein;
      VAR_15.Ppmd7_Construct(&rar->ppmd7_context);

      if (rar->dictionary_size == 0) {
	      archive_set_error(&VAR_0->archive, VAR_13,
                          ""Invalid zero dictionary size"");
	      return (VAR_14);
      }

      if (!VAR_15.Ppmd7_Alloc(&rar->ppmd7_context,
        rar->dictionary_size, &VAR_16))
      {
        archive_set_error(&VAR_0->archive, VAR_18,
                          ""Out of memory"");
        return (VAR_14);
      }
      if (!VAR_15.PpmdRAR_RangeDec_Init(&rar->range_dec))
      {
        archive_set_error(&VAR_0->archive, VAR_13,
                          ""Unable to initialize PPMd range decoder"");
        return (VAR_14);
      }
      VAR_15.Ppmd7_Init(&rar->ppmd7_context, VAR_10);
      rar->ppmd_valid = 1;
    }
    else
    {
      if (!rar->ppmd_valid) {
        archive_set_error(&VAR_0->archive, VAR_13,
                          ""Invalid PPMd sequence"");
        return (VAR_14);
      }
      if (!VAR_15.PpmdRAR_RangeDec_Init(&rar->range_dec))
      {
        archive_set_error(&VAR_0->archive, VAR_13,
                          ""Unable to initialize PPMd range decoder"");
        return (VAR_14);
      }
    }
  }
  else
  {
    rar_br_consume(VAR_12, 1);

    /* COMMENT_5 */
    if (!rar_br_read_ahead(VAR_0, VAR_12, 1))
      goto truncated_data;
    if (!rar_br_bits(VAR_12, 1))
      memset(rar->lengthtable, 0, sizeof(rar->lengthtable));
    rar_br_consume(VAR_12, 1);

    memset(&VAR_6, 0, sizeof(VAR_6));
    for (VAR_1 = 0; VAR_1 < VAR_7;)
    {
      if (!rar_br_read_ahead(VAR_0, VAR_12, 4))
        goto truncated_data;
      VAR_6[VAR_1++] = rar_br_bits(VAR_12, 4);
      rar_br_consume(VAR_12, 4);
      if (VAR_6[VAR_1-1] == 0xF)
      {
        if (!rar_br_read_ahead(VAR_0, VAR_12, 4))
          goto truncated_data;
        VAR_8 = rar_br_bits(VAR_12, 4);
        rar_br_consume(VAR_12, 4);
        if (VAR_8)
        {
          VAR_1--;
          for (VAR_2 = 0; VAR_2 < VAR_8 + 2 && VAR_1 < VAR_7; VAR_2++)
            VAR_6[VAR_1++] = 0;
        }
      }
    }

    memset(&VAR_11, 0, sizeof(VAR_11));
    VAR_5 = create_code(VAR_0, &VAR_11, VAR_6, VAR_7, VAR_19);
    if (VAR_5 != VAR_20) {
      free(VAR_11.tree);
      free(VAR_11.table);
      return (VAR_5);
    }

    for (VAR_1 = 0; VAR_1 < VAR_21;)
    {
      if ((VAR_3 = read_next_symbol(VAR_0, &VAR_11)) < 0) {
        free(VAR_11.tree);
        free(VAR_11.table);
        return (VAR_14);
      }
      if (VAR_3 < 16)
      {
        rar->lengthtable[VAR_1] = (rar->lengthtable[VAR_1] + VAR_3) & 0xF;
        VAR_1++;
      }
      else if (VAR_3 < 18)
      {
        if (VAR_1 == 0)
        {
          free(VAR_11.tree);
          free(VAR_11.table);
          archive_set_error(&VAR_0->archive, VAR_13,
                            ""Internal error extracting RAR file."");
          return (VAR_14);
        }

        if(VAR_3 == 16) {
          if (!rar_br_read_ahead(VAR_0, VAR_12, 3)) {
            free(VAR_11.tree);
            free(VAR_11.table);
            goto truncated_data;
          }
          VAR_4 = rar_br_bits(VAR_12, 3) + 3;
          rar_br_consume(VAR_12, 3);
        } else {
          if (!rar_br_read_ahead(VAR_0, VAR_12, 7)) {
            free(VAR_11.tree);
            free(VAR_11.table);
            goto truncated_data;
          }
          VAR_4 = rar_br_bits(VAR_12, 7) + 11;
          rar_br_consume(VAR_12, 7);
        }

        for (VAR_2 = 0; VAR_2 < VAR_4 && VAR_1 < VAR_21; VAR_2++)
        {
          rar->lengthtable[VAR_1] = rar->lengthtable[VAR_1-1];
          VAR_1++;
        }
      }
      else
      {
        if(VAR_3 == 18) {
          if (!rar_br_read_ahead(VAR_0, VAR_12, 3)) {
            free(VAR_11.tree);
            free(VAR_11.table);
            goto truncated_data;
          }
          VAR_4 = rar_br_bits(VAR_12, 3) + 3;
          rar_br_consume(VAR_12, 3);
        } else {
          if (!rar_br_read_ahead(VAR_0, VAR_12, 7)) {
            free(VAR_11.tree);
            free(VAR_11.table);
            goto truncated_data;
          }
          VAR_4 = rar_br_bits(VAR_12, 7) + 11;
          rar_br_consume(VAR_12, 7);
        }

        for(VAR_2 = 0; VAR_2 < VAR_4 && VAR_1 < VAR_21; VAR_2++)
          rar->lengthtable[VAR_1++] = 0;
      }
    }
    free(VAR_11.tree);
    free(VAR_11.table);

    VAR_5 = create_code(VAR_0, &rar->maincode, &rar->lengthtable[0], VAR_22,
                VAR_19);
    if (VAR_5 != VAR_20)
      return (VAR_5);
    VAR_5 = create_code(VAR_0, &rar->offsetcode, &rar->lengthtable[VAR_22],
                VAR_23, VAR_19);
    if (VAR_5 != VAR_20)
      return (VAR_5);
    VAR_5 = create_code(VAR_0, &rar->lowoffsetcode,
                &rar->lengthtable[VAR_22 + VAR_23],
                VAR_24, VAR_19);
    if (VAR_5 != VAR_20)
      return (VAR_5);
    VAR_5 = create_code(VAR_0, &rar->lengthcode,
                &rar->lengthtable[VAR_22 + VAR_23 +
                VAR_24], VAR_25, VAR_19);
    if (VAR_5 != VAR_20)
      return (VAR_5);
  }

  if (!rar->dictionary_size || !rar->lzss.window)
  {
    /* COMMENT_6 */
                                        
       
    void *VAR_26;
    unsigned int VAR_27;

    if (rar->unp_size >= VAR_28)
      VAR_27 = VAR_28;
    else
      VAR_27 = rar_fls((unsigned int)rar->unp_size) << 1;
    VAR_26 = realloc(rar->lzss.window, VAR_27);
    if (VAR_26 == NULL) {
      archive_set_error(&VAR_0->archive, VAR_18,
                        ""Unable to allocate memory for uncompressed data."");
      return (VAR_14);
    }
    rar->lzss.window = (unsigned char *)VAR_26;
    rar->dictionary_size = VAR_27;
    memset(rar->lzss.window, 0, rar->dictionary_size);
    rar->lzss.mask = rar->dictionary_size - 1;
  }

  rar->start_new_table = 0;
  return (VAR_20);
truncated_data:
  archive_set_error(&VAR_0->archive, VAR_13,
                    ""Truncated RAR file data"");
  rar->valid = 0;
  return (VAR_14);
}",libarchive/05caadc7eedbef471ac9610809ba683f0c698700/archive_read_support_format_rar.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -66,6 +66,12 @@
       rar->range_dec.Stream = &rar->bytein;
       __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);
 
+      if (rar->dictionary_size == 0) {
+	      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                          ""Invalid zero dictionary size"");
+	      return (ARCHIVE_FATAL);
+      }
+
       if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,
         rar->dictionary_size, &g_szalloc))
       {","{'deleted_lines': [], 'added_lines': ['      if (rar->dictionary_size == 0) {', '\t      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,', '                          ""Invalid zero dictionary size"");', '\t      return (ARCHIVE_FATAL);', '      }', '']}",True,Heap-based buffer overflow in the parse_codes function in archive_read_support_format_rar.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a RAR file with a zero-sized dictionary.,7.8,HIGH,2,test,2016-06-19T21:21:42Z,1
CVE-2016-6128,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,libgd,"fix php 72494, invalid color index not handled, can lead to crash",1ccfe21e14c4d18336f9da8515cd17db88c3de61,https://github.com/libgd/libgd/commit/1ccfe21e14c4d18336f9da8515cd17db88c3de61,src/gd_crop.c,gdImageCropThreshold,"BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)
{
const int width = gdImageSX(im);
const int height = gdImageSY(im);
int x,y;
int match;
gdRect crop;
crop.x = 0;
crop.y = 0;
crop.width = 0;
crop.height = 0;
if (threshold > 100.0) {
return NULL;
}
match = 1;
for (y = 0; match && y < height; y++) {
for (x = 0; match && x < width; x++) {
match = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;
}
}
if (y == height - 1) {
return NULL;
}
crop.y = y -1;
match = 1;
for (y = height - 1; match && y >= 0; y--) {
for (x = 0; match && x < width; x++) {
match = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;
}
}
if (y == 0) {
crop.height = height - crop.y + 1;
} else {
crop.height = y - crop.y + 2;
}
match = 1;
for (x = 0; match && x < width; x++) {
for (y = 0; match && y < crop.y + crop.height - 1; y++) {
match = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;
}
}
crop.x = x - 1;
match = 1;
for (x = width - 1; match && x >= 0; x--) {
for (y = 0; match &&  y < crop.y + crop.height - 1; y++) {
match = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;
}
}
crop.width = x - crop.x + 2;
return gdImageCrop(im, &crop);
}","VAR_0(gdImagePtr) gdImageCropThreshold(gdImagePtr VAR_1, const unsigned int VAR_2, const float VAR_3)
{
const int VAR_4 = gdImageSX(VAR_1);
const int VAR_5 = gdImageSY(VAR_1);
int VAR_6,VAR_7;
int VAR_8;
gdRect VAR_9;
VAR_9.x = 0;
VAR_9.y = 0;
VAR_9.width = 0;
VAR_9.height = 0;
if (VAR_3 > 100.0) {
return NULL;
}
VAR_8 = 1;
for (VAR_7 = 0; VAR_8 && VAR_7 < VAR_5; VAR_7++) {
for (VAR_6 = 0; VAR_8 && VAR_6 < VAR_4; VAR_6++) {
VAR_8 = (gdColorMatch(VAR_1, VAR_2, gdImageGetPixel(VAR_1, VAR_6,VAR_7), VAR_3)) > 0;
}
}
if (VAR_7 == VAR_5 - 1) {
return NULL;
}
VAR_9.y = VAR_7 -1;
VAR_8 = 1;
for (VAR_7 = VAR_5 - 1; VAR_8 && VAR_7 >= 0; VAR_7--) {
for (VAR_6 = 0; VAR_8 && VAR_6 < VAR_4; VAR_6++) {
VAR_8 = (gdColorMatch(VAR_1, VAR_2, gdImageGetPixel(VAR_1, VAR_6, VAR_7), VAR_3)) > 0;
}
}
if (VAR_7 == 0) {
VAR_9.height = VAR_5 - VAR_9.y + 1;
} else {
VAR_9.height = VAR_7 - VAR_9.y + 2;
}
VAR_8 = 1;
for (VAR_6 = 0; VAR_8 && VAR_6 < VAR_4; VAR_6++) {
for (VAR_7 = 0; VAR_8 && VAR_7 < VAR_9.y + VAR_9.height - 1; VAR_7++) {
VAR_8 = (gdColorMatch(VAR_1, VAR_2, gdImageGetPixel(VAR_1, VAR_6,VAR_7), VAR_3)) > 0;
}
}
VAR_9.x = VAR_6 - 1;
VAR_8 = 1;
for (VAR_6 = VAR_4 - 1; VAR_8 && VAR_6 >= 0; VAR_6--) {
for (VAR_7 = 0; VAR_8 &&  VAR_7 < VAR_9.y + VAR_9.height - 1; VAR_7++) {
VAR_8 = (gdColorMatch(VAR_1, VAR_2, gdImageGetPixel(VAR_1, VAR_6,VAR_7), VAR_3)) > 0;
}
}
VAR_9.width = VAR_6 - VAR_9.x + 2;
return gdImageCrop(VAR_1, &VAR_9);
}",,"BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)
{
	const int width = gdImageSX(im);
	const int height = gdImageSY(im);

	int x,y;
	int match;
	gdRect crop;

	crop.x = 0;
	crop.y = 0;
	crop.width = 0;
	crop.height = 0;

	/* Pierre: crop everything sounds bad */
	if (threshold > 100.0) {
		return NULL;
	}

	if (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {
		return NULL;
	}

	/* TODO: Add gdImageGetRowPtr and works with ptr at the row level
	 * for the true color and palette images
	 * new formats will simply work with ptr
	 */
	match = 1;
	for (y = 0; match && y < height; y++) {
		for (x = 0; match && x < width; x++) {
			match = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;
		}
	}

	/* Pierre
	 * Nothing to do > bye
	 * Duplicate the image?
	 */
	if (y == height - 1) {
		return NULL;
	}

	crop.y = y -1;
	match = 1;
	for (y = height - 1; match && y >= 0; y--) {
		for (x = 0; match && x < width; x++) {
			match = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;
		}
	}

	if (y == 0) {
		crop.height = height - crop.y + 1;
	} else {
		crop.height = y - crop.y + 2;
	}

	match = 1;
	for (x = 0; match && x < width; x++) {
		for (y = 0; match && y < crop.y + crop.height - 1; y++) {
			match = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;
		}
	}
	crop.x = x - 1;

	match = 1;
	for (x = width - 1; match && x >= 0; x--) {
		for (y = 0; match &&  y < crop.y + crop.height - 1; y++) {
			match = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;
		}
	}
	crop.width = x - crop.x + 2;

	return gdImageCrop(im, &crop);
}","VAR_0(gdImagePtr) gdImageCropThreshold(gdImagePtr VAR_1, const unsigned int VAR_2, const float VAR_3)
{
	const int VAR_4 = gdImageSX(VAR_1);
	const int VAR_5 = gdImageSY(VAR_1);

	int VAR_6,VAR_7;
	int VAR_8;
	gdRect VAR_9;

	VAR_9.x = 0;
	VAR_9.y = 0;
	VAR_9.width = 0;
	VAR_9.height = 0;

	/* COMMENT_0 */
	if (VAR_3 > 100.0) {
		return NULL;
	}

	if (VAR_2 < 0 || (!gdImageTrueColor(VAR_1) && VAR_2 >= gdImageColorsTotal(VAR_1))) {
		return NULL;
	}

	/* COMMENT_1 */
                                         
                                         
    
	VAR_8 = 1;
	for (VAR_7 = 0; VAR_8 && VAR_7 < VAR_5; VAR_7++) {
		for (VAR_6 = 0; VAR_8 && VAR_6 < VAR_4; VAR_6++) {
			VAR_8 = (gdColorMatch(VAR_1, VAR_2, gdImageGetPixel(VAR_1, VAR_6,VAR_7), VAR_3)) > 0;
		}
	}

	/* COMMENT_5 */
                       
                        
    
	if (VAR_7 == VAR_5 - 1) {
		return NULL;
	}

	VAR_9.y = VAR_7 -1;
	VAR_8 = 1;
	for (VAR_7 = VAR_5 - 1; VAR_8 && VAR_7 >= 0; VAR_7--) {
		for (VAR_6 = 0; VAR_8 && VAR_6 < VAR_4; VAR_6++) {
			VAR_8 = (gdColorMatch(VAR_1, VAR_2, gdImageGetPixel(VAR_1, VAR_6, VAR_7), VAR_3)) > 0;
		}
	}

	if (VAR_7 == 0) {
		VAR_9.height = VAR_5 - VAR_9.y + 1;
	} else {
		VAR_9.height = VAR_7 - VAR_9.y + 2;
	}

	VAR_8 = 1;
	for (VAR_6 = 0; VAR_8 && VAR_6 < VAR_4; VAR_6++) {
		for (VAR_7 = 0; VAR_8 && VAR_7 < VAR_9.y + VAR_9.height - 1; VAR_7++) {
			VAR_8 = (gdColorMatch(VAR_1, VAR_2, gdImageGetPixel(VAR_1, VAR_6,VAR_7), VAR_3)) > 0;
		}
	}
	VAR_9.x = VAR_6 - 1;

	VAR_8 = 1;
	for (VAR_6 = VAR_4 - 1; VAR_8 && VAR_6 >= 0; VAR_6--) {
		for (VAR_7 = 0; VAR_8 &&  VAR_7 < VAR_9.y + VAR_9.height - 1; VAR_7++) {
			VAR_8 = (gdColorMatch(VAR_1, VAR_2, gdImageGetPixel(VAR_1, VAR_6,VAR_7), VAR_3)) > 0;
		}
	}
	VAR_9.width = VAR_6 - VAR_9.x + 2;

	return gdImageCrop(VAR_1, &VAR_9);
}",,"--- func_before
+++ func_after
@@ -14,6 +14,10 @@
 
 	/* Pierre: crop everything sounds bad */
 	if (threshold > 100.0) {
+		return NULL;
+	}
+
+	if (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {
 		return NULL;
 	}
 ","{'deleted_lines': [], 'added_lines': ['\t\treturn NULL;', '\t}', '', '\tif (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {']}",True,"The gdImageCropThreshold function in gd_crop.c in the GD Graphics Library (aka libgd) before 2.2.3, as used in PHP before 7.0.9, allows remote attackers to cause a denial of service (application crash) via an invalid color index.",7.5,HIGH,2,test,2016-06-27T04:17:39Z,1
CVE-2023-3106,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"xfrm: fix crash in XFRM_MSG_GETSA netlink handler

If we hit any of the error conditions inside xfrm_dump_sa(), then
xfrm_state_walk_init() never gets called. However, we still call
xfrm_state_walk_done() from xfrm_dump_sa_done(), which will crash
because the state walk was never initialized properly.

We can fix this by setting cb->args[0] only after we've processed the
first element and checking this before calling xfrm_state_walk_done().

Fixes: d3623099d3 (""ipsec: add support of limited SA dump"")
Cc: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Cc: Steffen Klassert <steffen.klassert@secunet.com>
Signed-off-by: Vegard Nossum <vegard.nossum@oracle.com>
Acked-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>",1ba5bf993c6a3142e18e68ea6452b347f9cb5635,https://github.com/torvalds/linux/commit/1ba5bf993c6a3142e18e68ea6452b347f9cb5635,net/xfrm/xfrm_user.c,xfrm_dump_sa,"static int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)
{
struct net *net = sock_net(skb->sk);
struct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];
struct xfrm_dump_info info;
BUILD_BUG_ON(sizeof(struct xfrm_state_walk) >
sizeof(cb->args) - sizeof(cb->args[0]));
info.in_skb = cb->skb;
info.out_skb = skb;
info.nlmsg_seq = cb->nlh->nlmsg_seq;
info.nlmsg_flags = NLM_F_MULTI;
if (!cb->args[0]) {
struct nlattr *attrs[XFRMA_MAX+1];
struct xfrm_address_filter *filter = NULL;
u8 proto = 0;
int err;
cb->args[0] = 1;
err = nlmsg_parse(cb->nlh, 0, attrs, XFRMA_MAX,
xfrma_policy);
if (err < 0)
return err;
if (attrs[XFRMA_ADDRESS_FILTER]) {
filter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),
sizeof(*filter), GFP_KERNEL);
if (filter == NULL)
return -ENOMEM;
}
if (attrs[XFRMA_PROTO])
proto = nla_get_u8(attrs[XFRMA_PROTO]);
xfrm_state_walk_init(walk, proto, filter);
}
(void) xfrm_state_walk(net, walk, dump_one_state, &info);
return skb->len;
}","static int xfrm_dump_sa(struct sk_buff *VAR_0, struct netlink_callback *VAR_1)
{
struct net *net = sock_net(VAR_0->sk);
struct xfrm_state_walk *VAR_2 = (struct xfrm_state_walk *) &VAR_1->args[1];
struct xfrm_dump_info VAR_3;
BUILD_BUG_ON(sizeof(struct xfrm_state_walk) >
sizeof(VAR_1->args) - sizeof(VAR_1->args[0]));
VAR_3.in_skb = VAR_1->skb;
VAR_3.out_skb = VAR_0;
VAR_3.nlmsg_seq = VAR_1->nlh->nlmsg_seq;
VAR_3.nlmsg_flags = VAR_4;
if (!VAR_1->args[0]) {
struct nlattr *VAR_5[VAR_6+1];
struct xfrm_address_filter *VAR_7 = NULL;
u8 VAR_8 = 0;
int VAR_9;
VAR_1->args[0] = 1;
VAR_9 = nlmsg_parse(VAR_1->nlh, 0, VAR_5, VAR_6,
VAR_10);
if (VAR_9 < 0)
return VAR_9;
if (VAR_5[VAR_11]) {
VAR_7 = kmemdup(nla_data(VAR_5[VAR_11]),
sizeof(*VAR_7), VAR_12);
if (VAR_7 == NULL)
return -VAR_13;
}
if (VAR_5[VAR_14])
VAR_8 = nla_get_u8(VAR_5[VAR_14]);
xfrm_state_walk_init(VAR_2, VAR_8, VAR_7);
}
(void) xfrm_state_walk(net, VAR_2, VAR_15, &VAR_3);
return VAR_0->len;
}",torvalds/linux/1ba5bf993c6a3142e18e68ea6452b347f9cb5635/xfrm_user.c/vul/before/1.json,"static int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)
{
	struct net *net = sock_net(skb->sk);
	struct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];
	struct xfrm_dump_info info;

	BUILD_BUG_ON(sizeof(struct xfrm_state_walk) >
		     sizeof(cb->args) - sizeof(cb->args[0]));

	info.in_skb = cb->skb;
	info.out_skb = skb;
	info.nlmsg_seq = cb->nlh->nlmsg_seq;
	info.nlmsg_flags = NLM_F_MULTI;

	if (!cb->args[0]) {
		struct nlattr *attrs[XFRMA_MAX+1];
		struct xfrm_address_filter *filter = NULL;
		u8 proto = 0;
		int err;

		err = nlmsg_parse(cb->nlh, 0, attrs, XFRMA_MAX,
				  xfrma_policy);
		if (err < 0)
			return err;

		if (attrs[XFRMA_ADDRESS_FILTER]) {
			filter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),
					 sizeof(*filter), GFP_KERNEL);
			if (filter == NULL)
				return -ENOMEM;
		}

		if (attrs[XFRMA_PROTO])
			proto = nla_get_u8(attrs[XFRMA_PROTO]);

		xfrm_state_walk_init(walk, proto, filter);
		cb->args[0] = 1;
	}

	(void) xfrm_state_walk(net, walk, dump_one_state, &info);

	return skb->len;
}","static int xfrm_dump_sa(struct sk_buff *VAR_0, struct netlink_callback *VAR_1)
{
	struct net *net = sock_net(VAR_0->sk);
	struct xfrm_state_walk *VAR_2 = (struct xfrm_state_walk *) &VAR_1->args[1];
	struct xfrm_dump_info VAR_3;

	BUILD_BUG_ON(sizeof(struct xfrm_state_walk) >
		     sizeof(VAR_1->args) - sizeof(VAR_1->args[0]));

	VAR_3.in_skb = VAR_1->skb;
	VAR_3.out_skb = VAR_0;
	VAR_3.nlmsg_seq = VAR_1->nlh->nlmsg_seq;
	VAR_3.nlmsg_flags = VAR_4;

	if (!VAR_1->args[0]) {
		struct nlattr *VAR_5[VAR_6+1];
		struct xfrm_address_filter *VAR_7 = NULL;
		u8 VAR_8 = 0;
		int VAR_9;

		VAR_9 = nlmsg_parse(VAR_1->nlh, 0, VAR_5, VAR_6,
				  VAR_10);
		if (VAR_9 < 0)
			return VAR_9;

		if (VAR_5[VAR_11]) {
			VAR_7 = kmemdup(nla_data(VAR_5[VAR_11]),
					 sizeof(*VAR_7), VAR_12);
			if (VAR_7 == NULL)
				return -VAR_13;
		}

		if (VAR_5[VAR_14])
			VAR_8 = nla_get_u8(VAR_5[VAR_14]);

		xfrm_state_walk_init(VAR_2, VAR_8, VAR_7);
		VAR_1->args[0] = 1;
	}

	(void) xfrm_state_walk(net, VAR_2, VAR_15, &VAR_3);

	return VAR_0->len;
}",torvalds/linux/1ba5bf993c6a3142e18e68ea6452b347f9cb5635/xfrm_user.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -18,8 +18,6 @@
 		u8 proto = 0;
 		int err;
 
-		cb->args[0] = 1;
-
 		err = nlmsg_parse(cb->nlh, 0, attrs, XFRMA_MAX,
 				  xfrma_policy);
 		if (err < 0)
@@ -36,6 +34,7 @@
 			proto = nla_get_u8(attrs[XFRMA_PROTO]);
 
 		xfrm_state_walk_init(walk, proto, filter);
+		cb->args[0] = 1;
 	}
 
 	(void) xfrm_state_walk(net, walk, dump_one_state, &info);","{'deleted_lines': ['\t\tcb->args[0] = 1;', ''], 'added_lines': ['\t\tcb->args[0] = 1;']}",True,"A NULL pointer dereference vulnerability was found in netlink_dump. This issue can occur when the Netlink socket receives the message(sendmsg) for the XFRM_MSG_GETSA, XFRM_MSG_GETPOLICY type message, and the DUMP flag is set and can cause a denial of service or possibly another unspecified impact. Due to the nature of the flaw, privilege escalation cannot be fully ruled out, although it is unlikely.",6.6,MEDIUM,1,test,2016-07-05T08:18:08Z,1
CVE-2023-3106,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"xfrm: fix crash in XFRM_MSG_GETSA netlink handler

If we hit any of the error conditions inside xfrm_dump_sa(), then
xfrm_state_walk_init() never gets called. However, we still call
xfrm_state_walk_done() from xfrm_dump_sa_done(), which will crash
because the state walk was never initialized properly.

We can fix this by setting cb->args[0] only after we've processed the
first element and checking this before calling xfrm_state_walk_done().

Fixes: d3623099d3 (""ipsec: add support of limited SA dump"")
Cc: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Cc: Steffen Klassert <steffen.klassert@secunet.com>
Signed-off-by: Vegard Nossum <vegard.nossum@oracle.com>
Acked-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>",1ba5bf993c6a3142e18e68ea6452b347f9cb5635,https://github.com/torvalds/linux/commit/1ba5bf993c6a3142e18e68ea6452b347f9cb5635,net/xfrm/xfrm_user.c,xfrm_dump_sa_done,"static int xfrm_dump_sa_done(struct netlink_callback *cb)
{
struct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];
struct sock *sk = cb->skb->sk;
struct net *net = sock_net(sk);
xfrm_state_walk_done(walk, net);
return 0;
}","static int xfrm_dump_sa_done(struct netlink_callback *VAR_0)
{
struct xfrm_state_walk *VAR_1 = (struct xfrm_state_walk *) &VAR_0->args[1];
struct sock *VAR_2 = VAR_0->skb->sk;
struct net *net = sock_net(VAR_2);
xfrm_state_walk_done(VAR_1, net);
return 0;
}",torvalds/linux/1ba5bf993c6a3142e18e68ea6452b347f9cb5635/xfrm_user.c/vul/before/0.json,"static int xfrm_dump_sa_done(struct netlink_callback *cb)
{
	struct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];
	struct sock *sk = cb->skb->sk;
	struct net *net = sock_net(sk);

	if (cb->args[0])
		xfrm_state_walk_done(walk, net);
	return 0;
}","static int xfrm_dump_sa_done(struct netlink_callback *VAR_0)
{
	struct xfrm_state_walk *VAR_1 = (struct xfrm_state_walk *) &VAR_0->args[1];
	struct sock *VAR_2 = VAR_0->skb->sk;
	struct net *net = sock_net(VAR_2);

	if (VAR_0->args[0])
		xfrm_state_walk_done(VAR_1, net);
	return 0;
}",torvalds/linux/1ba5bf993c6a3142e18e68ea6452b347f9cb5635/xfrm_user.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,6 +4,7 @@
 	struct sock *sk = cb->skb->sk;
 	struct net *net = sock_net(sk);
 
-	xfrm_state_walk_done(walk, net);
+	if (cb->args[0])
+		xfrm_state_walk_done(walk, net);
 	return 0;
 }","{'deleted_lines': ['\txfrm_state_walk_done(walk, net);'], 'added_lines': ['\tif (cb->args[0])', '\t\txfrm_state_walk_done(walk, net);']}",True,"A NULL pointer dereference vulnerability was found in netlink_dump. This issue can occur when the Netlink socket receives the message(sendmsg) for the XFRM_MSG_GETSA, XFRM_MSG_GETPOLICY type message, and the DUMP flag is set and can cause a denial of service or possibly another unspecified impact. Due to the nature of the flaw, privilege escalation cannot be fully ruled out, although it is unlikely.",6.6,MEDIUM,1,test,2016-07-05T08:18:08Z,1
CVE-2016-6265,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ArtifexSoftware/mupdf,"Bug 696941: Fix use after free.

The file is HORRIBLY corrupt, and triggers Sophos to think it's
PDF malware (which it isn't). It does however trigger a use
after free, worked around here.",fa1936405b6a84e5c9bb440912c23d532772f958,https://github.com/ArtifexSoftware/mupdf/commit/fa1936405b6a84e5c9bb440912c23d532772f958,source/pdf/pdf-xref.c,pdf_load_xref,"static void
pdf_load_xref(fz_context *ctx, pdf_document *doc, pdf_lexbuf *buf)
{
int i;
int xref_len;
pdf_xref_entry *entry;
pdf_read_start_xref(ctx, doc);
pdf_read_xref_sections(ctx, doc, doc->startxref, buf, 1);
if (pdf_xref_len(ctx, doc) == 0)
fz_throw(ctx, FZ_ERROR_GENERIC, ""found xref was empty"");
pdf_prime_xref_index(ctx, doc);
entry = pdf_get_xref_entry(ctx, doc, 0);
if (!entry->type)
{
entry->type = 'f';
entry->gen = 65535;
entry->num = 0;
}
else if (entry->type != 'f')
fz_warn(ctx, ""first object in xref is not free"");
xref_len = pdf_xref_len(ctx, doc);
for (i = 0; i < xref_len; i++)
{
pdf_xref_entry *entry = pdf_get_xref_entry(ctx, doc, i);
if (entry->type == 'n')
{
if (entry->ofs == 0)
entry->type = 'f';
else if (entry->ofs <= 0 || entry->ofs >= doc->file_size)
fz_throw(ctx, FZ_ERROR_GENERIC, ""object offset out of range: %d (%d 0 R)"", (int)entry->ofs, i);
}
if (entry->type == 'o')
if (entry->ofs <= 0 || entry->ofs >= xref_len || pdf_get_xref_entry(ctx, doc, entry->ofs)->type != 'n')
fz_throw(ctx, FZ_ERROR_GENERIC, ""invalid reference to an objstm that does not exist: %d (%d 0 R)"", (int)entry->ofs, i);
}
}","static void
pdf_load_xref(fz_context *VAR_0, pdf_document *VAR_1, pdf_lexbuf *VAR_2)
{
int VAR_3;
int VAR_4;
pdf_xref_entry *VAR_5;
pdf_read_start_xref(VAR_0, VAR_1);
pdf_read_xref_sections(VAR_0, VAR_1, VAR_1->startxref, VAR_2, 1);
if (pdf_xref_len(VAR_0, VAR_1) == 0)
fz_throw(VAR_0, VAR_6, ""found xref was empty"");
pdf_prime_xref_index(VAR_0, VAR_1);
VAR_5 = pdf_get_xref_entry(VAR_0, VAR_1, 0);
if (!VAR_5->type)
{
VAR_5->type = 'f';
VAR_5->gen = 65535;
VAR_5->num = 0;
}
else if (VAR_5->type != 'f')
fz_warn(VAR_0, ""first object in xref is not free"");
VAR_4 = pdf_xref_len(VAR_0, VAR_1);
for (VAR_3 = 0; VAR_3 < VAR_4; VAR_3++)
{
pdf_xref_entry *VAR_5 = pdf_get_xref_entry(VAR_0, VAR_1, VAR_3);
if (VAR_5->type == 'n')
{
if (VAR_5->ofs == 0)
VAR_5->type = 'f';
else if (VAR_5->ofs <= 0 || VAR_5->ofs >= VAR_1->file_size)
fz_throw(VAR_0, VAR_6, ""object offset out of range: %d (%d 0 R)"", (int)VAR_5->ofs, VAR_3);
}
if (VAR_5->type == 'o')
if (VAR_5->ofs <= 0 || VAR_5->ofs >= VAR_4 || pdf_get_xref_entry(VAR_0, VAR_1, VAR_5->ofs)->type != 'n')
fz_throw(VAR_0, VAR_6, ""invalid reference to an objstm that does not exist: %d (%d 0 R)"", (int)VAR_5->ofs, VAR_3);
}
}",ArtifexSoftware/mupdf/fa1936405b6a84e5c9bb440912c23d532772f958/pdf-xref.c/vul/before/0.json,"static void
pdf_load_xref(fz_context *ctx, pdf_document *doc, pdf_lexbuf *buf)
{
	int i;
	int xref_len;
	pdf_xref_entry *entry;

	pdf_read_start_xref(ctx, doc);

	pdf_read_xref_sections(ctx, doc, doc->startxref, buf, 1);

	if (pdf_xref_len(ctx, doc) == 0)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""found xref was empty"");

	pdf_prime_xref_index(ctx, doc);

	entry = pdf_get_xref_entry(ctx, doc, 0);
	/* broken pdfs where first object is missing */
	if (!entry->type)
	{
		entry->type = 'f';
		entry->gen = 65535;
		entry->num = 0;
	}
	/* broken pdfs where first object is not free */
	else if (entry->type != 'f')
		fz_warn(ctx, ""first object in xref is not free"");

	/* broken pdfs where object offsets are out of range */
	xref_len = pdf_xref_len(ctx, doc);
	for (i = 0; i < xref_len; i++)
	{
		pdf_xref_entry *entry = pdf_get_xref_entry(ctx, doc, i);
		if (entry->type == 'n')
		{
			/* Special case code: ""0000000000 * n"" means free,
			 * according to some producers (inc Quartz) */
			if (entry->ofs == 0)
				entry->type = 'f';
			else if (entry->ofs <= 0 || entry->ofs >= doc->file_size)
				fz_throw(ctx, FZ_ERROR_GENERIC, ""object offset out of range: %d (%d 0 R)"", (int)entry->ofs, i);
		}
		if (entry->type == 'o')
		{
			/* Read this into a local variable here, because pdf_get_xref_entry
			 * may solidify the xref, hence invalidating ""entry"", meaning we
			 * need a stashed value for the throw. */
			fz_off_t ofs = entry->ofs;
			if (ofs <= 0 || ofs >= xref_len || pdf_get_xref_entry(ctx, doc, ofs)->type != 'n')
				fz_throw(ctx, FZ_ERROR_GENERIC, ""invalid reference to an objstm that does not exist: %d (%d 0 R)"", (int)ofs, i);
		}
	}
}","static void
pdf_load_xref(fz_context *VAR_0, pdf_document *VAR_1, pdf_lexbuf *VAR_2)
{
	int VAR_3;
	int VAR_4;
	pdf_xref_entry *VAR_5;

	pdf_read_start_xref(VAR_0, VAR_1);

	pdf_read_xref_sections(VAR_0, VAR_1, VAR_1->startxref, VAR_2, 1);

	if (pdf_xref_len(VAR_0, VAR_1) == 0)
		fz_throw(VAR_0, VAR_6, ""found xref was empty"");

	pdf_prime_xref_index(VAR_0, VAR_1);

	VAR_5 = pdf_get_xref_entry(VAR_0, VAR_1, 0);
	/* COMMENT_0 */
	if (!VAR_5->type)
	{
		VAR_5->type = 'f';
		VAR_5->gen = 65535;
		VAR_5->num = 0;
	}
	/* COMMENT_1 */
	else if (VAR_5->type != 'f')
		fz_warn(VAR_0, ""first object in xref is not free"");

	/* COMMENT_2 */
	VAR_4 = pdf_xref_len(VAR_0, VAR_1);
	for (VAR_3 = 0; VAR_3 < VAR_4; VAR_3++)
	{
		pdf_xref_entry *VAR_5 = pdf_get_xref_entry(VAR_0, VAR_1, VAR_3);
		if (VAR_5->type == 'n')
		{
			/* COMMENT_3 */
                                                 
			if (VAR_5->ofs == 0)
				VAR_5->type = 'f';
			else if (VAR_5->ofs <= 0 || VAR_5->ofs >= VAR_1->file_size)
				fz_throw(VAR_0, VAR_6, ""object offset out of range: %d (%d 0 R)"", (int)VAR_5->ofs, VAR_3);
		}
		if (VAR_5->type == 'o')
		{
			/* COMMENT_5 */
                                                                   
                                            
			fz_off_t VAR_7 = VAR_5->ofs;
			if (VAR_7 <= 0 || VAR_7 >= VAR_4 || pdf_get_xref_entry(VAR_0, VAR_1, VAR_7)->type != 'n')
				fz_throw(VAR_0, VAR_6, ""invalid reference to an objstm that does not exist: %d (%d 0 R)"", (int)VAR_7, VAR_3);
		}
	}
}",ArtifexSoftware/mupdf/fa1936405b6a84e5c9bb440912c23d532772f958/pdf-xref.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -41,7 +41,13 @@
 				fz_throw(ctx, FZ_ERROR_GENERIC, ""object offset out of range: %d (%d 0 R)"", (int)entry->ofs, i);
 		}
 		if (entry->type == 'o')
-			if (entry->ofs <= 0 || entry->ofs >= xref_len || pdf_get_xref_entry(ctx, doc, entry->ofs)->type != 'n')
-				fz_throw(ctx, FZ_ERROR_GENERIC, ""invalid reference to an objstm that does not exist: %d (%d 0 R)"", (int)entry->ofs, i);
+		{
+			/* Read this into a local variable here, because pdf_get_xref_entry
+			 * may solidify the xref, hence invalidating ""entry"", meaning we
+			 * need a stashed value for the throw. */
+			fz_off_t ofs = entry->ofs;
+			if (ofs <= 0 || ofs >= xref_len || pdf_get_xref_entry(ctx, doc, ofs)->type != 'n')
+				fz_throw(ctx, FZ_ERROR_GENERIC, ""invalid reference to an objstm that does not exist: %d (%d 0 R)"", (int)ofs, i);
+		}
 	}
 }","{'deleted_lines': [""\t\t\tif (entry->ofs <= 0 || entry->ofs >= xref_len || pdf_get_xref_entry(ctx, doc, entry->ofs)->type != 'n')"", '\t\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, ""invalid reference to an objstm that does not exist: %d (%d 0 R)"", (int)entry->ofs, i);'], 'added_lines': ['\t\t{', '\t\t\t/* Read this into a local variable here, because pdf_get_xref_entry', '\t\t\t * may solidify the xref, hence invalidating ""entry"", meaning we', '\t\t\t * need a stashed value for the throw. */', '\t\t\tfz_off_t ofs = entry->ofs;', ""\t\t\tif (ofs <= 0 || ofs >= xref_len || pdf_get_xref_entry(ctx, doc, ofs)->type != 'n')"", '\t\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, ""invalid reference to an objstm that does not exist: %d (%d 0 R)"", (int)ofs, i);', '\t\t}']}",True,Use-after-free vulnerability in the pdf_load_xref function in pdf/pdf-xref.c in MuPDF allows remote attackers to cause a denial of service (crash) via a crafted PDF file.,5.5,MEDIUM,1,test,2016-07-21T14:39:11Z,1
CVE-2016-6510,['CWE-189'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"RLC: fix a stack overflow in rlc_decode_li function

The test to check whether the array was full or not was off by 1

Bug: 12664
Change-Id: If2057b71d92c7f03e05b0f4676abc62d5a03ae73
Reviewed-on: https://code.wireshark.org/review/16640
Reviewed-by: Pascal Quantin <pascal.quantin@gmail.com>",47a5fa850b388fcf4ea762073806f01b459820fe,https://github.com/wireshark/wireshark/commit/47a5fa850b388fcf4ea762073806f01b459820fe,epan/dissectors/packet-rlc.c,rlc_decode_li,"static gint16
rlc_decode_li(enum rlc_mode mode, tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
struct rlc_li *li, guint8 max_li, gboolean li_on_2_bytes)
{
guint8      ext, hdr_len, offs  = 0, num_li = 0, li_offs;
guint16     next_bytes, prev_li = 0;
proto_item *malformed;
guint16     total_len;
switch (mode) {
case RLC_AM:
offs = 1;
break;
case RLC_UM:
offs = 0;
break;
case RLC_TM:
case RLC_UNKNOWN_MODE:
default:
return -1;
}
hdr_len = offs;
ext = tvb_get_guint8(tvb, hdr_len++) & 0x01;
while (ext) {
next_bytes = li_on_2_bytes ? tvb_get_ntohs(tvb, hdr_len) : tvb_get_guint8(tvb, hdr_len);
ext = next_bytes & 0x01;
hdr_len += li_on_2_bytes ? 2 : 1;
}
total_len = tvb_captured_length_remaining(tvb, hdr_len);
ext = tvb_get_guint8(tvb, offs++) & 0x01;
li_offs = offs;
while (ext) {
if (li_on_2_bytes) {
next_bytes = tvb_get_ntohs(tvb, offs);
offs += 2;
} else {
next_bytes = tvb_get_guint8(tvb, offs++);
}
ext = next_bytes & 0x01;
li[num_li].ext = ext;
li[num_li].li = next_bytes >> 1;
if (li_on_2_bytes) {
switch (li[num_li].li) {
case 0x0000: 
case 0x7ffb: 
case 0x7ffe: 
case 0x7fff: 
li[num_li].len = 0;
break;
case 0x7ffa: 
case 0x7ffc: 
case 0x7ffd: 
if (mode == RLC_UM) {
li[num_li].len = 0;
break;
}
malformed = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);
expert_add_info(pinfo, malformed, &ei_rlc_li_reserved);
return -1; 
default:
if (((li[num_li].li > total_len) && !global_rlc_headers_expected)
|| (li[num_li].li < prev_li)) {
malformed = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);
expert_add_info(pinfo, malformed, &ei_rlc_li_incorrect_warn);
return -1; 
}
li[num_li].len = li[num_li].li - prev_li;
prev_li = li[num_li].li;
}
} else {
switch (li[num_li].li) {
case 0x00: 
case 0x7e: 
case 0x7f: 
li[num_li].len = 0;
break;
case 0x7c: 
case 0x7d: 
if (mode == RLC_UM) {
li[num_li].len = 0;
break;
}
malformed = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);
expert_add_info(pinfo, malformed, &ei_rlc_li_reserved);
return -1; 
default:
li[num_li].len = li[num_li].li - prev_li;
if (((li[num_li].li > total_len) && !global_rlc_headers_expected)
|| (li[num_li].li < prev_li)) {
malformed = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);
expert_add_info_format(pinfo, malformed, &ei_rlc_li_incorrect_mal, ""Incorrect LI value 0x%x"", li[num_li].li);
return -1; 
}
prev_li = li[num_li].li;
}
}
li[num_li].tree = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);
num_li++;
if (num_li > max_li) {
expert_add_info(pinfo, li[num_li-1].tree, &ei_rlc_li_too_many);
return -1;
}
}
return num_li;
}","static gint16
rlc_decode_li(enum rlc_mode VAR_0, tvbuff_t *VAR_1, packet_info *VAR_2, proto_tree *VAR_3,
struct rlc_li *VAR_4, guint8 VAR_5, gboolean VAR_6)
{
guint8      VAR_7, VAR_8, VAR_9  = 0, VAR_10 = 0, VAR_11;
guint16     VAR_12, VAR_13 = 0;
proto_item *VAR_14;
guint16     VAR_15;
switch (VAR_0) {
case VAR_16:
VAR_9 = 1;
break;
case VAR_17:
VAR_9 = 0;
break;
case VAR_18:
case VAR_19:
default:
return -1;
}
VAR_8 = VAR_9;
VAR_7 = tvb_get_guint8(VAR_1, VAR_8++) & 0x01;
while (VAR_7) {
VAR_12 = VAR_6 ? tvb_get_ntohs(VAR_1, VAR_8) : tvb_get_guint8(VAR_1, VAR_8);
VAR_7 = VAR_12 & 0x01;
VAR_8 += VAR_6 ? 2 : 1;
}
VAR_15 = tvb_captured_length_remaining(VAR_1, VAR_8);
VAR_7 = tvb_get_guint8(VAR_1, VAR_9++) & 0x01;
VAR_11 = VAR_9;
while (VAR_7) {
if (VAR_6) {
VAR_12 = tvb_get_ntohs(VAR_1, VAR_9);
VAR_9 += 2;
} else {
VAR_12 = tvb_get_guint8(VAR_1, VAR_9++);
}
VAR_7 = VAR_12 & 0x01;
VAR_4[VAR_10].ext = VAR_7;
VAR_4[VAR_10].li = VAR_12 >> 1;
if (VAR_6) {
switch (VAR_4[VAR_10].li) {
case 0x0000: 
case 0x7ffb: 
case 0x7ffe: 
case 0x7fff: 
VAR_4[VAR_10].len = 0;
break;
case 0x7ffa: 
case 0x7ffc: 
case 0x7ffd: 
if (VAR_0 == VAR_17) {
VAR_4[VAR_10].len = 0;
break;
}
VAR_14 = tree_add_li(VAR_0, &VAR_4[VAR_10], VAR_10, VAR_11, VAR_6, VAR_1, VAR_3);
expert_add_info(VAR_2, VAR_14, &VAR_20);
return -1; 
default:
if (((VAR_4[VAR_10].li > VAR_15) && !VAR_21)
|| (VAR_4[VAR_10].li < VAR_13)) {
VAR_14 = tree_add_li(VAR_0, &VAR_4[VAR_10], VAR_10, VAR_11, VAR_6, VAR_1, VAR_3);
expert_add_info(VAR_2, VAR_14, &VAR_22);
return -1; 
}
VAR_4[VAR_10].len = VAR_4[VAR_10].li - VAR_13;
VAR_13 = VAR_4[VAR_10].li;
}
} else {
switch (VAR_4[VAR_10].li) {
case 0x00: 
case 0x7e: 
case 0x7f: 
VAR_4[VAR_10].len = 0;
break;
case 0x7c: 
case 0x7d: 
if (VAR_0 == VAR_17) {
VAR_4[VAR_10].len = 0;
break;
}
VAR_14 = tree_add_li(VAR_0, &VAR_4[VAR_10], VAR_10, VAR_11, VAR_6, VAR_1, VAR_3);
expert_add_info(VAR_2, VAR_14, &VAR_20);
return -1; 
default:
VAR_4[VAR_10].len = VAR_4[VAR_10].li - VAR_13;
if (((VAR_4[VAR_10].li > VAR_15) && !VAR_21)
|| (VAR_4[VAR_10].li < VAR_13)) {
VAR_14 = tree_add_li(VAR_0, &VAR_4[VAR_10], VAR_10, VAR_11, VAR_6, VAR_1, VAR_3);
expert_add_info_format(VAR_2, VAR_14, &VAR_23, ""Incorrect LI value 0x%x"", VAR_4[VAR_10].li);
return -1; 
}
VAR_13 = VAR_4[VAR_10].li;
}
}
VAR_4[VAR_10].tree = tree_add_li(VAR_0, &VAR_4[VAR_10], VAR_10, VAR_11, VAR_6, VAR_1, VAR_3);
VAR_10++;
if (VAR_10 > VAR_5) {
expert_add_info(VAR_2, VAR_4[VAR_10-1].tree, &VAR_24);
return -1;
}
}
return VAR_10;
}",wireshark/47a5fa850b388fcf4ea762073806f01b459820fe/packet-rlc.c/vul/before/0.json,"static gint16
rlc_decode_li(enum rlc_mode mode, tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
          struct rlc_li *li, guint8 max_li, gboolean li_on_2_bytes)
{
    guint8      ext, hdr_len, offs  = 0, num_li = 0, li_offs;
    guint16     next_bytes, prev_li = 0;
    proto_item *malformed;
    guint16     total_len;

    switch (mode) {
        case RLC_AM:
            offs = 1;
            break;
        case RLC_UM:
            offs = 0;
            break;
        case RLC_TM:
            /* fall through */
        case RLC_UNKNOWN_MODE:
        default:
            return -1;
    }
    hdr_len = offs;
    /* calculate header length */
    ext = tvb_get_guint8(tvb, hdr_len++) & 0x01;
    while (ext) {
        next_bytes = li_on_2_bytes ? tvb_get_ntohs(tvb, hdr_len) : tvb_get_guint8(tvb, hdr_len);
        ext = next_bytes & 0x01;
        hdr_len += li_on_2_bytes ? 2 : 1;
    }
    total_len = tvb_captured_length_remaining(tvb, hdr_len);

    /* do actual evaluation of LIs */
    ext = tvb_get_guint8(tvb, offs++) & 0x01;
    li_offs = offs;
    while (ext) {
        if (li_on_2_bytes) {
            next_bytes = tvb_get_ntohs(tvb, offs);
            offs += 2;
        } else {
            next_bytes = tvb_get_guint8(tvb, offs++);
        }
        ext = next_bytes & 0x01;
        li[num_li].ext = ext;
        li[num_li].li = next_bytes >> 1;

        if (li_on_2_bytes) {
            switch (li[num_li].li) {
                case 0x0000: /* previous segment was the last one */
                case 0x7ffb: /* previous PDU contains last segment of SDU (minus last byte) */
                case 0x7ffe: /* contains piggybacked STATUS in AM or segment in UM */
                case 0x7fff: /* padding */
                    li[num_li].len = 0;
                    break;
                case 0x7ffa: /* contains exactly one SDU (minus last byte), UM only */
                case 0x7ffc: /* start of a new SDU, UM only */
                case 0x7ffd: /* contains exactly one SDU, UM only */
                    if (mode == RLC_UM) {
                        /* valid for UM */
                        li[num_li].len = 0;
                        break;
                    }
                    /*invalid for AM */
                    /* add malformed LI for investigation */
                    malformed = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);
                    expert_add_info(pinfo, malformed, &ei_rlc_li_reserved);
                    return -1; /* just give up on this */
                default:
                    /* since the LI is an offset (from the end of the header), it
                    * may not be larger than the total remaining length and no
                    * LI may be smaller than its preceding one
                    */
                    if (((li[num_li].li > total_len) && !global_rlc_headers_expected)
                        || (li[num_li].li < prev_li)) {
                        /* add malformed LI for investigation */
                        malformed = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);
                        expert_add_info(pinfo, malformed, &ei_rlc_li_incorrect_warn);
                        return -1; /* just give up on this */
                    }
                    li[num_li].len = li[num_li].li - prev_li;
                    prev_li = li[num_li].li;
            }
        } else {
            switch (li[num_li].li) {
                case 0x00: /* previous segment was the last one */
                case 0x7e: /* contains piggybacked STATUS in AM or segment in UM */
                case 0x7f: /* padding */
                    li[num_li].len = 0;
                    break;
                case 0x7c: /* start of a new SDU, UM only */
                case 0x7d: /* contains exactly one SDU, UM only */
                    if (mode == RLC_UM) {
                        /* valid for UM */
                        li[num_li].len = 0;
                        break;
                    }
                    /*invalid for AM */
                    /* add malformed LI for investigation */
                    malformed = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);
                    expert_add_info(pinfo, malformed, &ei_rlc_li_reserved);
                    return -1; /* just give up on this */
                default:
                    /* since the LI is an offset (from the end of the header), it
                    * may not be larger than the total remaining length and no
                    * LI may be smaller than its preceding one
                    */
                    li[num_li].len = li[num_li].li - prev_li;
                    if (((li[num_li].li > total_len) && !global_rlc_headers_expected)
                        || (li[num_li].li < prev_li)) {
                        /* add malformed LI for investigation */
                        malformed = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);
                        expert_add_info_format(pinfo, malformed, &ei_rlc_li_incorrect_mal, ""Incorrect LI value 0x%x"", li[num_li].li);
                        return -1; /* just give up on this */
                    }
                    prev_li = li[num_li].li;
            }
        }
        li[num_li].tree = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);
        num_li++;

        if (num_li >= max_li) {
            /* OK, so this is not really a malformed packet, but for now,
            * we will treat it as such, so that it is marked in some way */
            expert_add_info(pinfo, li[num_li-1].tree, &ei_rlc_li_too_many);
            return -1;
        }
    }
    return num_li;
}","static gint16
rlc_decode_li(enum rlc_mode VAR_0, tvbuff_t *VAR_1, packet_info *VAR_2, proto_tree *VAR_3,
          struct rlc_li *VAR_4, guint8 VAR_5, gboolean VAR_6)
{
    guint8      VAR_7, VAR_8, VAR_9  = 0, VAR_10 = 0, VAR_11;
    guint16     VAR_12, VAR_13 = 0;
    proto_item *VAR_14;
    guint16     VAR_15;

    switch (VAR_0) {
        case VAR_16:
            VAR_9 = 1;
            break;
        case VAR_17:
            VAR_9 = 0;
            break;
        case VAR_18:
            /* COMMENT_0 */
        case VAR_19:
        default:
            return -1;
    }
    VAR_8 = VAR_9;
    /* COMMENT_1 */
    VAR_7 = tvb_get_guint8(VAR_1, VAR_8++) & 0x01;
    while (VAR_7) {
        VAR_12 = VAR_6 ? tvb_get_ntohs(VAR_1, VAR_8) : tvb_get_guint8(VAR_1, VAR_8);
        VAR_7 = VAR_12 & 0x01;
        VAR_8 += VAR_6 ? 2 : 1;
    }
    VAR_15 = tvb_captured_length_remaining(VAR_1, VAR_8);

    /* COMMENT_2 */
    VAR_7 = tvb_get_guint8(VAR_1, VAR_9++) & 0x01;
    VAR_11 = VAR_9;
    while (VAR_7) {
        if (VAR_6) {
            VAR_12 = tvb_get_ntohs(VAR_1, VAR_9);
            VAR_9 += 2;
        } else {
            VAR_12 = tvb_get_guint8(VAR_1, VAR_9++);
        }
        VAR_7 = VAR_12 & 0x01;
        VAR_4[VAR_10].ext = VAR_7;
        VAR_4[VAR_10].li = VAR_12 >> 1;

        if (VAR_6) {
            switch (VAR_4[VAR_10].li) {
                case 0x0000: /* COMMENT_3 */
                case 0x7ffb: /* COMMENT_4 */
                case 0x7ffe: /* COMMENT_5 */
                case 0x7fff: /* COMMENT_6 */
                    VAR_4[VAR_10].len = 0;
                    break;
                case 0x7ffa: /* COMMENT_7 */
                case 0x7ffc: /* COMMENT_8 */
                case 0x7ffd: /* COMMENT_9 */
                    if (VAR_0 == VAR_17) {
                        /* COMMENT_10 */
                        VAR_4[VAR_10].len = 0;
                        break;
                    }
                    /* COMMENT_11 */
                    /* COMMENT_12 */
                    VAR_14 = tree_add_li(VAR_0, &VAR_4[VAR_10], VAR_10, VAR_11, VAR_6, VAR_1, VAR_3);
                    expert_add_info(VAR_2, VAR_14, &VAR_20);
                    return -1; /* COMMENT_13 */
                default:
                    /* COMMENT_14 */
                                                                              
                                                              
                      
                    if (((VAR_4[VAR_10].li > VAR_15) && !VAR_21)
                        || (VAR_4[VAR_10].li < VAR_13)) {
                        /* COMMENT_12 */
                        VAR_14 = tree_add_li(VAR_0, &VAR_4[VAR_10], VAR_10, VAR_11, VAR_6, VAR_1, VAR_3);
                        expert_add_info(VAR_2, VAR_14, &VAR_22);
                        return -1; /* COMMENT_13 */
                    }
                    VAR_4[VAR_10].len = VAR_4[VAR_10].li - VAR_13;
                    VAR_13 = VAR_4[VAR_10].li;
            }
        } else {
            switch (VAR_4[VAR_10].li) {
                case 0x00: /* COMMENT_3 */
                case 0x7e: /* COMMENT_5 */
                case 0x7f: /* COMMENT_6 */
                    VAR_4[VAR_10].len = 0;
                    break;
                case 0x7c: /* COMMENT_8 */
                case 0x7d: /* COMMENT_9 */
                    if (VAR_0 == VAR_17) {
                        /* COMMENT_10 */
                        VAR_4[VAR_10].len = 0;
                        break;
                    }
                    /* COMMENT_11 */
                    /* COMMENT_12 */
                    VAR_14 = tree_add_li(VAR_0, &VAR_4[VAR_10], VAR_10, VAR_11, VAR_6, VAR_1, VAR_3);
                    expert_add_info(VAR_2, VAR_14, &VAR_20);
                    return -1; /* COMMENT_13 */
                default:
                    /* COMMENT_18 */
                                                                              
                                                              
                      
                    VAR_4[VAR_10].len = VAR_4[VAR_10].li - VAR_13;
                    if (((VAR_4[VAR_10].li > VAR_15) && !VAR_21)
                        || (VAR_4[VAR_10].li < VAR_13)) {
                        /* COMMENT_12 */
                        VAR_14 = tree_add_li(VAR_0, &VAR_4[VAR_10], VAR_10, VAR_11, VAR_6, VAR_1, VAR_3);
                        expert_add_info_format(VAR_2, VAR_14, &VAR_23, ""Incorrect LI value 0x%x"", VAR_4[VAR_10].li);
                        return -1; /* COMMENT_13 */
                    }
                    VAR_13 = VAR_4[VAR_10].li;
            }
        }
        VAR_4[VAR_10].tree = tree_add_li(VAR_0, &VAR_4[VAR_10], VAR_10, VAR_11, VAR_6, VAR_1, VAR_3);
        VAR_10++;

        if (VAR_10 >= VAR_5) {
            /* COMMENT_22 */
                                                                           
            expert_add_info(VAR_2, VAR_4[VAR_10-1].tree, &VAR_24);
            return -1;
        }
    }
    return VAR_10;
}",wireshark/47a5fa850b388fcf4ea762073806f01b459820fe/packet-rlc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -118,7 +118,7 @@
         li[num_li].tree = tree_add_li(mode, &li[num_li], num_li, li_offs, li_on_2_bytes, tvb, tree);
         num_li++;
 
-        if (num_li > max_li) {
+        if (num_li >= max_li) {
             /* OK, so this is not really a malformed packet, but for now,
             * we will treat it as such, so that it is marked in some way */
             expert_add_info(pinfo, li[num_li-1].tree, &ei_rlc_li_too_many);","{'deleted_lines': ['        if (num_li > max_li) {'], 'added_lines': ['        if (num_li >= max_li) {']}",True,Off-by-one error in epan/dissectors/packet-rlc.c in the RLC dissector in Wireshark 1.12.x before 1.12.13 and 2.x before 2.0.5 allows remote attackers to cause a denial of service (stack-based buffer overflow and application crash) via a crafted packet.,5.9,MEDIUM,1,test,2016-07-25T07:54:06Z,1
CVE-2016-6509,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,wireshark,"LDSS: check if a conversation already exists before recreating it

Bug: 12662
Change-Id: I81d91d54544e5865336dc08ffda9fe109fc643ed
Reviewed-on: https://code.wireshark.org/review/16660
Reviewed-by: Pascal Quantin <pascal.quantin@gmail.com>
Petri-Dish: Pascal Quantin <pascal.quantin@gmail.com>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Anders Broman <a.broman58@gmail.com>",5a469ddc893f7c1912d0e15cc73bd3011e6cc2fb,https://github.com/wireshark/wireshark/commit/5a469ddc893f7c1912d0e15cc73bd3011e6cc2fb,epan/dissectors/packet-ldss.c,prepare_ldss_transfer_conv,"static void
prepare_ldss_transfer_conv(ldss_broadcast_t *broadcast)
{
conversation_t *transfer_conv;
ldss_transfer_info_t *transfer_info;
transfer_info = wmem_new0(wmem_file_scope(), ldss_transfer_info_t);
transfer_info->broadcast = broadcast;
transfer_conv = conversation_new (broadcast->num, &broadcast->broadcaster->addr, &broadcast->broadcaster->addr,
PT_TCP, broadcast->broadcaster->port, broadcast->broadcaster->port, NO_ADDR2|NO_PORT2);
conversation_add_proto_data(transfer_conv, proto_ldss, transfer_info);
conversation_set_dissector(transfer_conv, ldss_tcp_handle);
}","static void
prepare_ldss_transfer_conv(ldss_broadcast_t *VAR_0)
{
conversation_t *VAR_1;
ldss_transfer_info_t *VAR_2;
VAR_2 = wmem_new0(wmem_file_scope(), ldss_transfer_info_t);
VAR_2->broadcast = VAR_0;
VAR_1 = conversation_new (VAR_0->num, &VAR_0->broadcaster->addr, &VAR_0->broadcaster->addr,
VAR_3, VAR_0->broadcaster->port, VAR_0->broadcaster->port, VAR_4|VAR_5);
conversation_add_proto_data(VAR_1, VAR_6, VAR_2);
conversation_set_dissector(VAR_1, VAR_7);
}",wireshark/5a469ddc893f7c1912d0e15cc73bd3011e6cc2fb/packet-ldss.c/vul/before/0.json,"static void
prepare_ldss_transfer_conv(ldss_broadcast_t *broadcast)
{
	if (!find_conversation(broadcast->num, &broadcast->broadcaster->addr, &broadcast->broadcaster->addr,
	                       PT_TCP, broadcast->broadcaster->port, broadcast->broadcaster->port, NO_ADDR2|NO_PORT2)) {
		conversation_t *transfer_conv;
		ldss_transfer_info_t *transfer_info;

		transfer_info = wmem_new0(wmem_file_scope(), ldss_transfer_info_t);
		transfer_info->broadcast = broadcast;

		/* Preparation for later push/pull dissection */
		transfer_conv = conversation_new (broadcast->num, &broadcast->broadcaster->addr, &broadcast->broadcaster->addr,
						PT_TCP, broadcast->broadcaster->port, broadcast->broadcaster->port, NO_ADDR2|NO_PORT2);
		conversation_add_proto_data(transfer_conv, proto_ldss, transfer_info);
		conversation_set_dissector(transfer_conv, ldss_tcp_handle);
	}
}","static void
prepare_ldss_transfer_conv(ldss_broadcast_t *VAR_0)
{
	if (!find_conversation(VAR_0->num, &VAR_0->broadcaster->addr, &VAR_0->broadcaster->addr,
	                       VAR_1, VAR_0->broadcaster->port, VAR_0->broadcaster->port, VAR_2|VAR_3)) {
		conversation_t *VAR_4;
		ldss_transfer_info_t *VAR_5;

		VAR_5 = wmem_new0(wmem_file_scope(), ldss_transfer_info_t);
		VAR_5->broadcast = VAR_0;

		/* COMMENT_0 */
		VAR_4 = conversation_new (VAR_0->num, &VAR_0->broadcaster->addr, &VAR_0->broadcaster->addr,
						VAR_1, VAR_0->broadcaster->port, VAR_0->broadcaster->port, VAR_2|VAR_3);
		conversation_add_proto_data(VAR_4, VAR_6, VAR_5);
		conversation_set_dissector(VAR_4, VAR_7);
	}
}",wireshark/5a469ddc893f7c1912d0e15cc73bd3011e6cc2fb/packet-ldss.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,15 +1,18 @@
 static void
 prepare_ldss_transfer_conv(ldss_broadcast_t *broadcast)
 {
-	conversation_t *transfer_conv;
-	ldss_transfer_info_t *transfer_info;
+	if (!find_conversation(broadcast->num, &broadcast->broadcaster->addr, &broadcast->broadcaster->addr,
+	                       PT_TCP, broadcast->broadcaster->port, broadcast->broadcaster->port, NO_ADDR2|NO_PORT2)) {
+		conversation_t *transfer_conv;
+		ldss_transfer_info_t *transfer_info;
 
-	transfer_info = wmem_new0(wmem_file_scope(), ldss_transfer_info_t);
-	transfer_info->broadcast = broadcast;
+		transfer_info = wmem_new0(wmem_file_scope(), ldss_transfer_info_t);
+		transfer_info->broadcast = broadcast;
 
-	/* Preparation for later push/pull dissection */
-	transfer_conv = conversation_new (broadcast->num, &broadcast->broadcaster->addr, &broadcast->broadcaster->addr,
-					  PT_TCP, broadcast->broadcaster->port, broadcast->broadcaster->port, NO_ADDR2|NO_PORT2);
-	conversation_add_proto_data(transfer_conv, proto_ldss, transfer_info);
-	conversation_set_dissector(transfer_conv, ldss_tcp_handle);
+		/* Preparation for later push/pull dissection */
+		transfer_conv = conversation_new (broadcast->num, &broadcast->broadcaster->addr, &broadcast->broadcaster->addr,
+						PT_TCP, broadcast->broadcaster->port, broadcast->broadcaster->port, NO_ADDR2|NO_PORT2);
+		conversation_add_proto_data(transfer_conv, proto_ldss, transfer_info);
+		conversation_set_dissector(transfer_conv, ldss_tcp_handle);
+	}
 }","{'deleted_lines': ['\tconversation_t *transfer_conv;', '\tldss_transfer_info_t *transfer_info;', '\ttransfer_info = wmem_new0(wmem_file_scope(), ldss_transfer_info_t);', '\ttransfer_info->broadcast = broadcast;', '\t/* Preparation for later push/pull dissection */', '\ttransfer_conv = conversation_new (broadcast->num, &broadcast->broadcaster->addr, &broadcast->broadcaster->addr,', '\t\t\t\t\t  PT_TCP, broadcast->broadcaster->port, broadcast->broadcaster->port, NO_ADDR2|NO_PORT2);', '\tconversation_add_proto_data(transfer_conv, proto_ldss, transfer_info);', '\tconversation_set_dissector(transfer_conv, ldss_tcp_handle);'], 'added_lines': ['\tif (!find_conversation(broadcast->num, &broadcast->broadcaster->addr, &broadcast->broadcaster->addr,', '\t                       PT_TCP, broadcast->broadcaster->port, broadcast->broadcaster->port, NO_ADDR2|NO_PORT2)) {', '\t\tconversation_t *transfer_conv;', '\t\tldss_transfer_info_t *transfer_info;', '\t\ttransfer_info = wmem_new0(wmem_file_scope(), ldss_transfer_info_t);', '\t\ttransfer_info->broadcast = broadcast;', '\t\t/* Preparation for later push/pull dissection */', '\t\ttransfer_conv = conversation_new (broadcast->num, &broadcast->broadcaster->addr, &broadcast->broadcaster->addr,', '\t\t\t\t\t\tPT_TCP, broadcast->broadcaster->port, broadcast->broadcaster->port, NO_ADDR2|NO_PORT2);', '\t\tconversation_add_proto_data(transfer_conv, proto_ldss, transfer_info);', '\t\tconversation_set_dissector(transfer_conv, ldss_tcp_handle);', '\t}']}",True,"epan/dissectors/packet-ldss.c in the LDSS dissector in Wireshark 1.12.x before 1.12.13 and 2.x before 2.0.5 mishandles conversations, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.",5.9,MEDIUM,1,test,2016-07-25T11:32:45Z,1
CVE-2016-6823,['CWE-190'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,ImageMagick,Prevent buffer overflow in BMP coder (bug report from pwchen of tencent).,4cc6ec8a4197d4c008577127736bf7985d632323,https://github.com/ImageMagick/ImageMagick/commit/4cc6ec8a4197d4c008577127736bf7985d632323,coders/bmp.c,WriteBMPImage,"static MagickBooleanType WriteBMPImage(const ImageInfo *image_info,Image *image,
ExceptionInfo *exception)
{
BMPInfo
bmp_info;
const char
*option;
const StringInfo
*profile;
MagickBooleanType
have_color_info,
status;
MagickOffsetType
scene;
MemoryInfo
*pixel_info;
register const Quantum
*p;
register ssize_t
i,
x;
register unsigned char
*q;
size_t
bytes_per_line,
type;
ssize_t
y;
unsigned char
*bmp_data,
*pixels;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
assert(image != (Image *) NULL);
assert(image->signature == MagickCoreSignature);
if (image->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
if (status == MagickFalse)
return(status);
type=4;
if (LocaleCompare(image_info->magick,""BMP2"") == 0)
type=2;
else
if (LocaleCompare(image_info->magick,""BMP3"") == 0)
type=3;
option=GetImageOption(image_info,""bmp:format"");
if (option != (char *) NULL)
{
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  Format=%s"",option);
if (LocaleCompare(option,""bmp2"") == 0)
type=2;
if (LocaleCompare(option,""bmp3"") == 0)
type=3;
if (LocaleCompare(option,""bmp4"") == 0)
type=4;
}
scene=0;
do
{
(void) TransformImageColorspace(image,sRGBColorspace,exception);
(void) ResetMagickMemory(&bmp_info,0,sizeof(bmp_info));
bmp_info.file_size=14+12;
if (type > 2)
bmp_info.file_size+=28;
bmp_info.offset_bits=bmp_info.file_size;
bmp_info.compression=BI_RGB;
if ((image->storage_class == PseudoClass) && (image->colors > 256))
(void) SetImageStorageClass(image,DirectClass,exception);
if (image->storage_class != DirectClass)
{
bmp_info.bits_per_pixel=8;
if (image->colors <= 2)
bmp_info.bits_per_pixel=1;
else
if (image->colors <= 16)
bmp_info.bits_per_pixel=4;
else
if (image->colors <= 256)
bmp_info.bits_per_pixel=8;
if (image_info->compression == RLECompression)
bmp_info.bits_per_pixel=8;
bmp_info.number_colors=1U << bmp_info.bits_per_pixel;
if (image->alpha_trait != UndefinedPixelTrait)
(void) SetImageStorageClass(image,DirectClass,exception);
else
if ((size_t) bmp_info.number_colors < image->colors)
(void) SetImageStorageClass(image,DirectClass,exception);
else
{
bmp_info.file_size+=3*(1UL << bmp_info.bits_per_pixel);
bmp_info.offset_bits+=3*(1UL << bmp_info.bits_per_pixel);
if (type > 2)
{
bmp_info.file_size+=(1UL << bmp_info.bits_per_pixel);
bmp_info.offset_bits+=(1UL << bmp_info.bits_per_pixel);
}
}
}
if (image->storage_class == DirectClass)
{
bmp_info.number_colors=0;
bmp_info.bits_per_pixel=(unsigned short)
((type > 3) && (image->alpha_trait != UndefinedPixelTrait) ? 32 : 24);
bmp_info.compression=(unsigned int) ((type > 3) &&
(image->alpha_trait != UndefinedPixelTrait) ?  BI_BITFIELDS : BI_RGB);
if ((type == 3) && (image->alpha_trait != UndefinedPixelTrait))
{
option=GetImageOption(image_info,""bmp3:alpha"");
if (IsStringTrue(option))
bmp_info.bits_per_pixel=32;
}
}
bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);
bmp_info.ba_offset=0;
profile=GetImageProfile(image,""icc"");
have_color_info=(image->rendering_intent != UndefinedIntent) ||
(profile != (StringInfo *) NULL) || (image->gamma != 0.0) ?  MagickTrue :
MagickFalse;
if (type == 2)
bmp_info.size=12;
else
if ((type == 3) || ((image->alpha_trait == UndefinedPixelTrait) &&
(have_color_info == MagickFalse)))
{
type=3;
bmp_info.size=40;
}
else
{
int
extra_size;
bmp_info.size=108;
extra_size=68;
if ((image->rendering_intent != UndefinedIntent) ||
(profile != (StringInfo *) NULL))
{
bmp_info.size=124;
extra_size+=16;
}
bmp_info.file_size+=extra_size;
bmp_info.offset_bits+=extra_size;
}
bmp_info.width=(ssize_t) image->columns;
bmp_info.height=(ssize_t) image->rows;
bmp_info.planes=1;
bmp_info.image_size=(unsigned int) (bytes_per_line*image->rows);
bmp_info.file_size+=bmp_info.image_size;
bmp_info.x_pixels=75*39;
bmp_info.y_pixels=75*39;
switch (image->units)
{
case UndefinedResolution:
case PixelsPerInchResolution:
{
bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x/2.54);
bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y/2.54);
break;
}
case PixelsPerCentimeterResolution:
{
bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x);
bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y);
break;
}
}
bmp_info.colors_important=bmp_info.number_colors;
pixel_info=AcquireVirtualMemory((size_t) bmp_info.image_size,
sizeof(*pixels));
if (pixel_info == (MemoryInfo *) NULL)
ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
(void) ResetMagickMemory(pixels,0,(size_t) bmp_info.image_size);
switch (bmp_info.bits_per_pixel)
{
case 1:
{
size_t
bit,
byte;
for (y=0; y < (ssize_t) image->rows; y++)
{
ssize_t
offset;
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
q=pixels+(image->rows-y-1)*bytes_per_line;
bit=0;
byte=0;
for (x=0; x < (ssize_t) image->columns; x++)
{
byte<<=1;
byte|=GetPixelIndex(image,p) != 0 ? 0x01 : 0x00;
bit++;
if (bit == 8)
{
*q++=(unsigned char) byte;
bit=0;
byte=0;
}
p+=GetPixelChannels(image);
}
if (bit != 0)
{
*q++=(unsigned char) (byte << (8-bit));
x++;
}
offset=(ssize_t) (image->columns+7)/8;
for (x=offset; x < (ssize_t) bytes_per_line; x++)
*q++=0x00;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
break;
}
case 4:
{
size_t
byte,
nibble;
ssize_t
offset;
for (y=0; y < (ssize_t) image->rows; y++)
{
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
q=pixels+(image->rows-y-1)*bytes_per_line;
nibble=0;
byte=0;
for (x=0; x < (ssize_t) image->columns; x++)
{
byte<<=4;
byte|=((size_t) GetPixelIndex(image,p) & 0x0f);
nibble++;
if (nibble == 2)
{
*q++=(unsigned char) byte;
nibble=0;
byte=0;
}
p+=GetPixelChannels(image);
}
if (nibble != 0)
{
*q++=(unsigned char) (byte << 4);
x++;
}
offset=(ssize_t) (image->columns+1)/2;
for (x=offset; x < (ssize_t) bytes_per_line; x++)
*q++=0x00;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
break;
}
case 8:
{
for (y=0; y < (ssize_t) image->rows; y++)
{
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
q=pixels+(image->rows-y-1)*bytes_per_line;
for (x=0; x < (ssize_t) image->columns; x++)
{
*q++=(unsigned char) GetPixelIndex(image,p);
p+=GetPixelChannels(image);
}
for ( ; x < (ssize_t) bytes_per_line; x++)
*q++=0x00;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
break;
}
case 24:
{
for (y=0; y < (ssize_t) image->rows; y++)
{
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
q=pixels+(image->rows-y-1)*bytes_per_line;
for (x=0; x < (ssize_t) image->columns; x++)
{
*q++=ScaleQuantumToChar(GetPixelBlue(image,p));
*q++=ScaleQuantumToChar(GetPixelGreen(image,p));
*q++=ScaleQuantumToChar(GetPixelRed(image,p));
p+=GetPixelChannels(image);
}
for (x=3L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)
*q++=0x00;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
break;
}
case 32:
{
for (y=0; y < (ssize_t) image->rows; y++)
{
p=GetVirtualPixels(image,0,y,image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
q=pixels+(image->rows-y-1)*bytes_per_line;
for (x=0; x < (ssize_t) image->columns; x++)
{
*q++=ScaleQuantumToChar(GetPixelBlue(image,p));
*q++=ScaleQuantumToChar(GetPixelGreen(image,p));
*q++=ScaleQuantumToChar(GetPixelRed(image,p));
*q++=ScaleQuantumToChar(GetPixelAlpha(image,p));
p+=GetPixelChannels(image);
}
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
break;
}
}
if ((type > 2) && (bmp_info.bits_per_pixel == 8))
if (image_info->compression != NoCompression)
{
MemoryInfo
*rle_info;
rle_info=AcquireVirtualMemory((size_t) (2*(bytes_per_line+2)+2),
(image->rows+2)*sizeof(*pixels));
if (rle_info == (MemoryInfo *) NULL)
{
pixel_info=RelinquishVirtualMemory(pixel_info);
ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
}
bmp_data=(unsigned char *) GetVirtualMemoryBlob(rle_info);
bmp_info.file_size-=bmp_info.image_size;
bmp_info.image_size=(unsigned int) EncodeImage(image,bytes_per_line,
pixels,bmp_data);
bmp_info.file_size+=bmp_info.image_size;
pixel_info=RelinquishVirtualMemory(pixel_info);
pixel_info=rle_info;
pixels=bmp_data;
bmp_info.compression=BI_RLE8;
}
if (image->debug != MagickFalse)
{
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Writing BMP version %.20g datastream"",(double) type);
if (image->storage_class == DirectClass)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Storage class=DirectClass"");
else
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Storage class=PseudoClass"");
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Image depth=%.20g"",(double) image->depth);
if (image->alpha_trait != UndefinedPixelTrait)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Matte=True"");
else
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Matte=MagickFalse"");
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   BMP bits_per_pixel=%.20g"",(double) bmp_info.bits_per_pixel);
switch ((int) bmp_info.compression)
{
case BI_RGB:
{
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Compression=BI_RGB"");
break;
}
case BI_RLE8:
{
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Compression=BI_RLE8"");
break;
}
case BI_BITFIELDS:
{
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Compression=BI_BITFIELDS"");
break;
}
default:
{
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Compression=UNKNOWN (%lu)"",bmp_info.compression);
break;
}
}
if (bmp_info.number_colors == 0)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Number_colors=unspecified"");
else
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   Number_colors=%lu"",bmp_info.number_colors);
}
(void) WriteBlob(image,2,(unsigned char *) ""BM"");
(void) WriteBlobLSBLong(image,bmp_info.file_size);
(void) WriteBlobLSBLong(image,bmp_info.ba_offset);  
(void) WriteBlobLSBLong(image,bmp_info.offset_bits);
if (type == 2)
{
(void) WriteBlobLSBLong(image,bmp_info.size);
(void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.width);
(void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.height);
(void) WriteBlobLSBShort(image,bmp_info.planes);
(void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);
}
else
{
(void) WriteBlobLSBLong(image,bmp_info.size);
(void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.width);
(void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.height);
(void) WriteBlobLSBShort(image,bmp_info.planes);
(void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);
(void) WriteBlobLSBLong(image,bmp_info.compression);
(void) WriteBlobLSBLong(image,bmp_info.image_size);
(void) WriteBlobLSBLong(image,bmp_info.x_pixels);
(void) WriteBlobLSBLong(image,bmp_info.y_pixels);
(void) WriteBlobLSBLong(image,bmp_info.number_colors);
(void) WriteBlobLSBLong(image,bmp_info.colors_important);
}
if ((type > 3) && ((image->alpha_trait != UndefinedPixelTrait) ||
(have_color_info != MagickFalse)))
{
(void) WriteBlobLSBLong(image,0x00ff0000U);  
(void) WriteBlobLSBLong(image,0x0000ff00U);  
(void) WriteBlobLSBLong(image,0x000000ffU);  
(void) WriteBlobLSBLong(image,0xff000000U);  
(void) WriteBlobLSBLong(image,0x73524742U);  
(void) WriteBlobLSBLong(image,(unsigned int)
(image->chromaticity.red_primary.x*0x40000000));
(void) WriteBlobLSBLong(image,(unsigned int)
(image->chromaticity.red_primary.y*0x40000000));
(void) WriteBlobLSBLong(image,(unsigned int)
((1.000f-(image->chromaticity.red_primary.x+
image->chromaticity.red_primary.y))*0x40000000));
(void) WriteBlobLSBLong(image,(unsigned int)
(image->chromaticity.green_primary.x*0x40000000));
(void) WriteBlobLSBLong(image,(unsigned int)
(image->chromaticity.green_primary.y*0x40000000));
(void) WriteBlobLSBLong(image,(unsigned int)
((1.000f-(image->chromaticity.green_primary.x+
image->chromaticity.green_primary.y))*0x40000000));
(void) WriteBlobLSBLong(image,(unsigned int)
(image->chromaticity.blue_primary.x*0x40000000));
(void) WriteBlobLSBLong(image,(unsigned int)
(image->chromaticity.blue_primary.y*0x40000000));
(void) WriteBlobLSBLong(image,(unsigned int)
((1.000f-(image->chromaticity.blue_primary.x+
image->chromaticity.blue_primary.y))*0x40000000));
(void) WriteBlobLSBLong(image,(unsigned int)
(bmp_info.gamma_scale.x*0x10000));
(void) WriteBlobLSBLong(image,(unsigned int)
(bmp_info.gamma_scale.y*0x10000));
(void) WriteBlobLSBLong(image,(unsigned int)
(bmp_info.gamma_scale.z*0x10000));
if ((image->rendering_intent != UndefinedIntent) ||
(profile != (StringInfo *) NULL))
{
ssize_t
intent;
switch ((int) image->rendering_intent)
{
case SaturationIntent:
{
intent=LCS_GM_BUSINESS;
break;
}
case RelativeIntent:
{
intent=LCS_GM_GRAPHICS;
break;
}
case PerceptualIntent:
{
intent=LCS_GM_IMAGES;
break;
}
case AbsoluteIntent:
{
intent=LCS_GM_ABS_COLORIMETRIC;
break;
}
default:
{
intent=0;
break;
}
}
(void) WriteBlobLSBLong(image,(unsigned int) intent);
(void) WriteBlobLSBLong(image,0x00);  
(void) WriteBlobLSBLong(image,0x00);  
(void) WriteBlobLSBLong(image,0x00);  
}
}
if (image->storage_class == PseudoClass)
{
unsigned char
*bmp_colormap;
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  Colormap: %.20g entries"",(double) image->colors);
bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<
bmp_info.bits_per_pixel),4*sizeof(*bmp_colormap));
if (bmp_colormap == (unsigned char *) NULL)
ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
q=bmp_colormap;
for (i=0; i < (ssize_t) MagickMin((ssize_t) image->colors,(ssize_t) bmp_info.number_colors); i++)
{
*q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));
*q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));
*q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));
if (type > 2)
*q++=(unsigned char) 0x0;
}
for ( ; i < (ssize_t) (1UL << bmp_info.bits_per_pixel); i++)
{
*q++=(unsigned char) 0x00;
*q++=(unsigned char) 0x00;
*q++=(unsigned char) 0x00;
if (type > 2)
*q++=(unsigned char) 0x00;
}
if (type <= 2)
(void) WriteBlob(image,(size_t) (3*(1L << bmp_info.bits_per_pixel)),
bmp_colormap);
else
(void) WriteBlob(image,(size_t) (4*(1L << bmp_info.bits_per_pixel)),
bmp_colormap);
bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);
}
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  Pixels:  %lu bytes"",bmp_info.image_size);
(void) WriteBlob(image,(size_t) bmp_info.image_size,pixels);
pixel_info=RelinquishVirtualMemory(pixel_info);
if (GetNextImageInList(image) == (Image *) NULL)
break;
image=SyncNextImageInList(image);
status=SetImageProgress(image,SaveImagesTag,scene++,
GetImageListLength(image));
if (status == MagickFalse)
break;
} while (image_info->adjoin != MagickFalse);
(void) CloseBlob(image);
return(MagickTrue);
}","static MagickBooleanType WriteBMPImage(const ImageInfo *VAR_0,Image *VAR_1,
ExceptionInfo *VAR_2)
{
BMPInfo
VAR_3;
const char
*VAR_4;
const StringInfo
*VAR_5;
MagickBooleanType
VAR_6,
VAR_7;
MagickOffsetType
VAR_8;
MemoryInfo
*VAR_9;
register const Quantum
*VAR_10;
register ssize_t
VAR_11,
VAR_12;
register unsigned char
*VAR_13;
size_t
VAR_14,
VAR_15;
ssize_t
VAR_16;
unsigned char
*VAR_17,
*VAR_18;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_19);
assert(VAR_1 != (Image *) NULL);
assert(VAR_1->signature == VAR_19);
if (VAR_1->debug != VAR_20)
(void) LogMagickEvent(VAR_21,GetMagickModule(),""%s"",VAR_1->filename);
assert(VAR_2 != (ExceptionInfo *) NULL);
assert(VAR_2->signature == VAR_19);
VAR_7=OpenBlob(VAR_0,VAR_1,VAR_22,VAR_2);
if (VAR_7 == VAR_20)
return(VAR_7);
VAR_15=4;
if (LocaleCompare(VAR_0->magick,""BMP2"") == 0)
VAR_15=2;
else
if (LocaleCompare(VAR_0->magick,""BMP3"") == 0)
VAR_15=3;
VAR_4=GetImageOption(VAR_0,""bmp:format"");
if (VAR_4 != (char *) NULL)
{
(void) LogMagickEvent(VAR_23,GetMagickModule(),
""  Format=%s"",VAR_4);
if (LocaleCompare(VAR_4,""bmp2"") == 0)
VAR_15=2;
if (LocaleCompare(VAR_4,""bmp3"") == 0)
VAR_15=3;
if (LocaleCompare(VAR_4,""bmp4"") == 0)
VAR_15=4;
}
VAR_8=0;
do
{
(void) TransformImageColorspace(VAR_1,VAR_24,VAR_2);
(void) ResetMagickMemory(&VAR_3,0,sizeof(VAR_3));
VAR_3.file_size=14+12;
if (VAR_15 > 2)
VAR_3.file_size+=28;
VAR_3.offset_bits=VAR_3.file_size;
VAR_3.compression=VAR_25;
if ((VAR_1->storage_class == VAR_26) && (VAR_1->colors > 256))
(void) SetImageStorageClass(VAR_1,VAR_27,VAR_2);
if (VAR_1->storage_class != VAR_27)
{
VAR_3.bits_per_pixel=8;
if (VAR_1->colors <= 2)
VAR_3.bits_per_pixel=1;
else
if (VAR_1->colors <= 16)
VAR_3.bits_per_pixel=4;
else
if (VAR_1->colors <= 256)
VAR_3.bits_per_pixel=8;
if (VAR_0->compression == VAR_28)
VAR_3.bits_per_pixel=8;
VAR_3.number_colors=1U << VAR_3.bits_per_pixel;
if (VAR_1->alpha_trait != VAR_29)
(void) SetImageStorageClass(VAR_1,VAR_27,VAR_2);
else
if ((size_t) VAR_3.number_colors < VAR_1->colors)
(void) SetImageStorageClass(VAR_1,VAR_27,VAR_2);
else
{
VAR_3.file_size+=3*(1UL << VAR_3.bits_per_pixel);
VAR_3.offset_bits+=3*(1UL << VAR_3.bits_per_pixel);
if (VAR_15 > 2)
{
VAR_3.file_size+=(1UL << VAR_3.bits_per_pixel);
VAR_3.offset_bits+=(1UL << VAR_3.bits_per_pixel);
}
}
}
if (VAR_1->storage_class == VAR_27)
{
VAR_3.number_colors=0;
VAR_3.bits_per_pixel=(unsigned short)
((VAR_15 > 3) && (VAR_1->alpha_trait != VAR_29) ? 32 : 24);
VAR_3.compression=(unsigned int) ((VAR_15 > 3) &&
(VAR_1->alpha_trait != VAR_29) ?  VAR_30 : VAR_25);
if ((VAR_15 == 3) && (VAR_1->alpha_trait != VAR_29))
{
VAR_4=GetImageOption(VAR_0,""bmp3:alpha"");
if (IsStringTrue(VAR_4))
VAR_3.bits_per_pixel=32;
}
}
VAR_14=4*((VAR_1->columns*VAR_3.bits_per_pixel+31)/32);
VAR_3.ba_offset=0;
VAR_5=GetImageProfile(VAR_1,""icc"");
VAR_6=(VAR_1->rendering_intent != VAR_31) ||
(VAR_5 != (StringInfo *) NULL) || (VAR_1->gamma != 0.0) ?  VAR_32 :
VAR_20;
if (VAR_15 == 2)
VAR_3.size=12;
else
if ((VAR_15 == 3) || ((VAR_1->alpha_trait == VAR_29) &&
(VAR_6 == VAR_20)))
{
VAR_15=3;
VAR_3.size=40;
}
else
{
int
VAR_33;
VAR_3.size=108;
VAR_33=68;
if ((VAR_1->rendering_intent != VAR_31) ||
(VAR_5 != (StringInfo *) NULL))
{
VAR_3.size=124;
VAR_33+=16;
}
VAR_3.file_size+=VAR_33;
VAR_3.offset_bits+=VAR_33;
}
VAR_3.width=(ssize_t) VAR_1->columns;
VAR_3.height=(ssize_t) VAR_1->rows;
VAR_3.planes=1;
VAR_3.image_size=(unsigned int) (VAR_14*VAR_1->rows);
VAR_3.file_size+=VAR_3.image_size;
VAR_3.x_pixels=75*39;
VAR_3.y_pixels=75*39;
switch (VAR_1->units)
{
case VAR_34:
case VAR_35:
{
VAR_3.x_pixels=(unsigned int) (100.0*VAR_1->resolution.x/2.54);
VAR_3.y_pixels=(unsigned int) (100.0*VAR_1->resolution.y/2.54);
break;
}
case VAR_36:
{
VAR_3.x_pixels=(unsigned int) (100.0*VAR_1->resolution.x);
VAR_3.y_pixels=(unsigned int) (100.0*VAR_1->resolution.y);
break;
}
}
VAR_3.colors_important=VAR_3.number_colors;
VAR_9=AcquireVirtualMemory((size_t) VAR_3.image_size,
sizeof(*VAR_18));
if (VAR_9 == (MemoryInfo *) NULL)
ThrowWriterException(VAR_37,""MemoryAllocationFailed"");
VAR_18=(unsigned char *) GetVirtualMemoryBlob(VAR_9);
(void) ResetMagickMemory(VAR_18,0,(size_t) VAR_3.image_size);
switch (VAR_3.bits_per_pixel)
{
case 1:
{
size_t
VAR_38,
VAR_39;
for (VAR_16=0; VAR_16 < (ssize_t) VAR_1->rows; VAR_16++)
{
ssize_t
VAR_40;
VAR_10=GetVirtualPixels(VAR_1,0,VAR_16,VAR_1->columns,1,VAR_2);
if (VAR_10 == (const Quantum *) NULL)
break;
VAR_13=VAR_18+(VAR_1->rows-VAR_16-1)*VAR_14;
VAR_38=0;
VAR_39=0;
for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)
{
VAR_39<<=1;
VAR_39|=GetPixelIndex(VAR_1,VAR_10) != 0 ? 0x01 : 0x00;
VAR_38++;
if (VAR_38 == 8)
{
*VAR_13++=(unsigned char) VAR_39;
VAR_38=0;
VAR_39=0;
}
VAR_10+=GetPixelChannels(VAR_1);
}
if (VAR_38 != 0)
{
*VAR_13++=(unsigned char) (VAR_39 << (8-VAR_38));
VAR_12++;
}
VAR_40=(ssize_t) (VAR_1->columns+7)/8;
for (VAR_12=VAR_40; VAR_12 < (ssize_t) VAR_14; VAR_12++)
*VAR_13++=0x00;
if (VAR_1->previous == (Image *) NULL)
{
VAR_7=SetImageProgress(VAR_1,VAR_41,(MagickOffsetType) VAR_16,
VAR_1->rows);
if (VAR_7 == VAR_20)
break;
}
}
break;
}
case 4:
{
size_t
VAR_39,
VAR_42;
ssize_t
VAR_40;
for (VAR_16=0; VAR_16 < (ssize_t) VAR_1->rows; VAR_16++)
{
VAR_10=GetVirtualPixels(VAR_1,0,VAR_16,VAR_1->columns,1,VAR_2);
if (VAR_10 == (const Quantum *) NULL)
break;
VAR_13=VAR_18+(VAR_1->rows-VAR_16-1)*VAR_14;
VAR_42=0;
VAR_39=0;
for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)
{
VAR_39<<=4;
VAR_39|=((size_t) GetPixelIndex(VAR_1,VAR_10) & 0x0f);
VAR_42++;
if (VAR_42 == 2)
{
*VAR_13++=(unsigned char) VAR_39;
VAR_42=0;
VAR_39=0;
}
VAR_10+=GetPixelChannels(VAR_1);
}
if (VAR_42 != 0)
{
*VAR_13++=(unsigned char) (VAR_39 << 4);
VAR_12++;
}
VAR_40=(ssize_t) (VAR_1->columns+1)/2;
for (VAR_12=VAR_40; VAR_12 < (ssize_t) VAR_14; VAR_12++)
*VAR_13++=0x00;
if (VAR_1->previous == (Image *) NULL)
{
VAR_7=SetImageProgress(VAR_1,VAR_41,(MagickOffsetType) VAR_16,
VAR_1->rows);
if (VAR_7 == VAR_20)
break;
}
}
break;
}
case 8:
{
for (VAR_16=0; VAR_16 < (ssize_t) VAR_1->rows; VAR_16++)
{
VAR_10=GetVirtualPixels(VAR_1,0,VAR_16,VAR_1->columns,1,VAR_2);
if (VAR_10 == (const Quantum *) NULL)
break;
VAR_13=VAR_18+(VAR_1->rows-VAR_16-1)*VAR_14;
for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)
{
*VAR_13++=(unsigned char) GetPixelIndex(VAR_1,VAR_10);
VAR_10+=GetPixelChannels(VAR_1);
}
for ( ; VAR_12 < (ssize_t) VAR_14; VAR_12++)
*VAR_13++=0x00;
if (VAR_1->previous == (Image *) NULL)
{
VAR_7=SetImageProgress(VAR_1,VAR_41,(MagickOffsetType) VAR_16,
VAR_1->rows);
if (VAR_7 == VAR_20)
break;
}
}
break;
}
case 24:
{
for (VAR_16=0; VAR_16 < (ssize_t) VAR_1->rows; VAR_16++)
{
VAR_10=GetVirtualPixels(VAR_1,0,VAR_16,VAR_1->columns,1,VAR_2);
if (VAR_10 == (const Quantum *) NULL)
break;
VAR_13=VAR_18+(VAR_1->rows-VAR_16-1)*VAR_14;
for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)
{
*VAR_13++=ScaleQuantumToChar(GetPixelBlue(VAR_1,VAR_10));
*VAR_13++=ScaleQuantumToChar(GetPixelGreen(VAR_1,VAR_10));
*VAR_13++=ScaleQuantumToChar(GetPixelRed(VAR_1,VAR_10));
VAR_10+=GetPixelChannels(VAR_1);
}
for (VAR_12=3L*(ssize_t) VAR_1->columns; VAR_12 < (ssize_t) VAR_14; VAR_12++)
*VAR_13++=0x00;
if (VAR_1->previous == (Image *) NULL)
{
VAR_7=SetImageProgress(VAR_1,VAR_41,(MagickOffsetType) VAR_16,
VAR_1->rows);
if (VAR_7 == VAR_20)
break;
}
}
break;
}
case 32:
{
for (VAR_16=0; VAR_16 < (ssize_t) VAR_1->rows; VAR_16++)
{
VAR_10=GetVirtualPixels(VAR_1,0,VAR_16,VAR_1->columns,1,VAR_2);
if (VAR_10 == (const Quantum *) NULL)
break;
VAR_13=VAR_18+(VAR_1->rows-VAR_16-1)*VAR_14;
for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)
{
*VAR_13++=ScaleQuantumToChar(GetPixelBlue(VAR_1,VAR_10));
*VAR_13++=ScaleQuantumToChar(GetPixelGreen(VAR_1,VAR_10));
*VAR_13++=ScaleQuantumToChar(GetPixelRed(VAR_1,VAR_10));
*VAR_13++=ScaleQuantumToChar(GetPixelAlpha(VAR_1,VAR_10));
VAR_10+=GetPixelChannels(VAR_1);
}
if (VAR_1->previous == (Image *) NULL)
{
VAR_7=SetImageProgress(VAR_1,VAR_41,(MagickOffsetType) VAR_16,
VAR_1->rows);
if (VAR_7 == VAR_20)
break;
}
}
break;
}
}
if ((VAR_15 > 2) && (VAR_3.bits_per_pixel == 8))
if (VAR_0->compression != VAR_43)
{
MemoryInfo
*VAR_44;
VAR_44=AcquireVirtualMemory((size_t) (2*(VAR_14+2)+2),
(VAR_1->rows+2)*sizeof(*VAR_18));
if (VAR_44 == (MemoryInfo *) NULL)
{
VAR_9=RelinquishVirtualMemory(VAR_9);
ThrowWriterException(VAR_37,""MemoryAllocationFailed"");
}
VAR_17=(unsigned char *) GetVirtualMemoryBlob(VAR_44);
VAR_3.file_size-=VAR_3.image_size;
VAR_3.image_size=(unsigned int) EncodeImage(VAR_1,VAR_14,
VAR_18,VAR_17);
VAR_3.file_size+=VAR_3.image_size;
VAR_9=RelinquishVirtualMemory(VAR_9);
VAR_9=VAR_44;
VAR_18=VAR_17;
VAR_3.compression=VAR_45;
}
if (VAR_1->debug != VAR_20)
{
(void) LogMagickEvent(VAR_23,GetMagickModule(),
""   Writing BMP version %.20g datastream"",(double) VAR_15);
if (VAR_1->storage_class == VAR_27)
(void) LogMagickEvent(VAR_23,GetMagickModule(),
""   Storage class=DirectClass"");
else
(void) LogMagickEvent(VAR_23,GetMagickModule(),
""   Storage class=PseudoClass"");
(void) LogMagickEvent(VAR_23,GetMagickModule(),
""   Image depth=%.20g"",(double) VAR_1->depth);
if (VAR_1->alpha_trait != VAR_29)
(void) LogMagickEvent(VAR_23,GetMagickModule(),
""   Matte=True"");
else
(void) LogMagickEvent(VAR_23,GetMagickModule(),
""   Matte=MagickFalse"");
(void) LogMagickEvent(VAR_23,GetMagickModule(),
""   BMP bits_per_pixel=%.20g"",(double) VAR_3.bits_per_pixel);
switch ((int) VAR_3.compression)
{
case VAR_25:
{
(void) LogMagickEvent(VAR_23,GetMagickModule(),
""   Compression=BI_RGB"");
break;
}
case VAR_45:
{
(void) LogMagickEvent(VAR_23,GetMagickModule(),
""   Compression=BI_RLE8"");
break;
}
case VAR_30:
{
(void) LogMagickEvent(VAR_23,GetMagickModule(),
""   Compression=BI_BITFIELDS"");
break;
}
default:
{
(void) LogMagickEvent(VAR_23,GetMagickModule(),
""   Compression=UNKNOWN (%lu)"",VAR_3.compression);
break;
}
}
if (VAR_3.number_colors == 0)
(void) LogMagickEvent(VAR_23,GetMagickModule(),
""   Number_colors=unspecified"");
else
(void) LogMagickEvent(VAR_23,GetMagickModule(),
""   Number_colors=%lu"",VAR_3.number_colors);
}
(void) WriteBlob(VAR_1,2,(unsigned char *) ""BM"");
(void) WriteBlobLSBLong(VAR_1,VAR_3.file_size);
(void) WriteBlobLSBLong(VAR_1,VAR_3.ba_offset);  
(void) WriteBlobLSBLong(VAR_1,VAR_3.offset_bits);
if (VAR_15 == 2)
{
(void) WriteBlobLSBLong(VAR_1,VAR_3.size);
(void) WriteBlobLSBSignedShort(VAR_1,(signed short) VAR_3.width);
(void) WriteBlobLSBSignedShort(VAR_1,(signed short) VAR_3.height);
(void) WriteBlobLSBShort(VAR_1,VAR_3.planes);
(void) WriteBlobLSBShort(VAR_1,VAR_3.bits_per_pixel);
}
else
{
(void) WriteBlobLSBLong(VAR_1,VAR_3.size);
(void) WriteBlobLSBSignedLong(VAR_1,(signed int) VAR_3.width);
(void) WriteBlobLSBSignedLong(VAR_1,(signed int) VAR_3.height);
(void) WriteBlobLSBShort(VAR_1,VAR_3.planes);
(void) WriteBlobLSBShort(VAR_1,VAR_3.bits_per_pixel);
(void) WriteBlobLSBLong(VAR_1,VAR_3.compression);
(void) WriteBlobLSBLong(VAR_1,VAR_3.image_size);
(void) WriteBlobLSBLong(VAR_1,VAR_3.x_pixels);
(void) WriteBlobLSBLong(VAR_1,VAR_3.y_pixels);
(void) WriteBlobLSBLong(VAR_1,VAR_3.number_colors);
(void) WriteBlobLSBLong(VAR_1,VAR_3.colors_important);
}
if ((VAR_15 > 3) && ((VAR_1->alpha_trait != VAR_29) ||
(VAR_6 != VAR_20)))
{
(void) WriteBlobLSBLong(VAR_1,0x00ff0000U);  
(void) WriteBlobLSBLong(VAR_1,0x0000ff00U);  
(void) WriteBlobLSBLong(VAR_1,0x000000ffU);  
(void) WriteBlobLSBLong(VAR_1,0xff000000U);  
(void) WriteBlobLSBLong(VAR_1,0x73524742U);  
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
(VAR_1->chromaticity.red_primary.x*0x40000000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
(VAR_1->chromaticity.red_primary.y*0x40000000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
((1.000f-(VAR_1->chromaticity.red_primary.x+
VAR_1->chromaticity.red_primary.y))*0x40000000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
(VAR_1->chromaticity.green_primary.x*0x40000000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
(VAR_1->chromaticity.green_primary.y*0x40000000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
((1.000f-(VAR_1->chromaticity.green_primary.x+
VAR_1->chromaticity.green_primary.y))*0x40000000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
(VAR_1->chromaticity.blue_primary.x*0x40000000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
(VAR_1->chromaticity.blue_primary.y*0x40000000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
((1.000f-(VAR_1->chromaticity.blue_primary.x+
VAR_1->chromaticity.blue_primary.y))*0x40000000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
(VAR_3.gamma_scale.x*0x10000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
(VAR_3.gamma_scale.y*0x10000));
(void) WriteBlobLSBLong(VAR_1,(unsigned int)
(VAR_3.gamma_scale.z*0x10000));
if ((VAR_1->rendering_intent != VAR_31) ||
(VAR_5 != (StringInfo *) NULL))
{
ssize_t
VAR_46;
switch ((int) VAR_1->rendering_intent)
{
case VAR_47:
{
VAR_46=VAR_48;
break;
}
case VAR_49:
{
VAR_46=VAR_50;
break;
}
case VAR_51:
{
VAR_46=VAR_52;
break;
}
case VAR_53:
{
VAR_46=VAR_54;
break;
}
default:
{
VAR_46=0;
break;
}
}
(void) WriteBlobLSBLong(VAR_1,(unsigned int) VAR_46);
(void) WriteBlobLSBLong(VAR_1,0x00);  
(void) WriteBlobLSBLong(VAR_1,0x00);  
(void) WriteBlobLSBLong(VAR_1,0x00);  
}
}
if (VAR_1->storage_class == VAR_26)
{
unsigned char
*VAR_55;
if (VAR_1->debug != VAR_20)
(void) LogMagickEvent(VAR_23,GetMagickModule(),
""  Colormap: %.20g entries"",(double) VAR_1->colors);
VAR_55=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<
VAR_3.bits_per_pixel),4*sizeof(*VAR_55));
if (VAR_55 == (unsigned char *) NULL)
ThrowWriterException(VAR_37,""MemoryAllocationFailed"");
VAR_13=VAR_55;
for (VAR_11=0; VAR_11 < (ssize_t) MagickMin((ssize_t) VAR_1->colors,(ssize_t) VAR_3.number_colors); VAR_11++)
{
*VAR_13++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_11].blue));
*VAR_13++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_11].green));
*VAR_13++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_11].red));
if (VAR_15 > 2)
*VAR_13++=(unsigned char) 0x0;
}
for ( ; VAR_11 < (ssize_t) (1UL << VAR_3.bits_per_pixel); VAR_11++)
{
*VAR_13++=(unsigned char) 0x00;
*VAR_13++=(unsigned char) 0x00;
*VAR_13++=(unsigned char) 0x00;
if (VAR_15 > 2)
*VAR_13++=(unsigned char) 0x00;
}
if (VAR_15 <= 2)
(void) WriteBlob(VAR_1,(size_t) (3*(1L << VAR_3.bits_per_pixel)),
VAR_55);
else
(void) WriteBlob(VAR_1,(size_t) (4*(1L << VAR_3.bits_per_pixel)),
VAR_55);
VAR_55=(unsigned char *) RelinquishMagickMemory(VAR_55);
}
if (VAR_1->debug != VAR_20)
(void) LogMagickEvent(VAR_23,GetMagickModule(),
""  Pixels:  %lu bytes"",VAR_3.image_size);
(void) WriteBlob(VAR_1,(size_t) VAR_3.image_size,VAR_18);
VAR_9=RelinquishVirtualMemory(VAR_9);
if (GetNextImageInList(VAR_1) == (Image *) NULL)
break;
VAR_1=SyncNextImageInList(VAR_1);
VAR_7=SetImageProgress(VAR_1,VAR_56,VAR_8++,
GetImageListLength(VAR_1));
if (VAR_7 == VAR_20)
break;
} while (VAR_0->adjoin != VAR_20);
(void) CloseBlob(VAR_1);
return(VAR_32);
}",ImageMagick/4cc6ec8a4197d4c008577127736bf7985d632323/bmp.c/vul/before/0.json,"static MagickBooleanType WriteBMPImage(const ImageInfo *image_info,Image *image,
  ExceptionInfo *exception)
{
  BMPInfo
    bmp_info;

  const char
    *option;

  const StringInfo
    *profile;

  MagickBooleanType
    have_color_info,
    status;

  MagickOffsetType
    scene;

  MemoryInfo
    *pixel_info;

  register const Quantum
    *p;

  register ssize_t
    i,
    x;

  register unsigned char
    *q;

  size_t
    bytes_per_line,
    type;

  ssize_t
    y;

  unsigned char
    *bmp_data,
    *pixels;

  /*
    Open output image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(status);
  type=4;
  if (LocaleCompare(image_info->magick,""BMP2"") == 0)
    type=2;
  else
    if (LocaleCompare(image_info->magick,""BMP3"") == 0)
      type=3;

  option=GetImageOption(image_info,""bmp:format"");
  if (option != (char *) NULL)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  Format=%s"",option);

      if (LocaleCompare(option,""bmp2"") == 0)
        type=2;
      if (LocaleCompare(option,""bmp3"") == 0)
        type=3;
      if (LocaleCompare(option,""bmp4"") == 0)
        type=4;
    }

  scene=0;
  do
  {
    /*
      Initialize BMP raster file header.
    */
    (void) TransformImageColorspace(image,sRGBColorspace,exception);
    (void) ResetMagickMemory(&bmp_info,0,sizeof(bmp_info));
    bmp_info.file_size=14+12;
    if (type > 2)
      bmp_info.file_size+=28;
    bmp_info.offset_bits=bmp_info.file_size;
    bmp_info.compression=BI_RGB;
    if ((image->storage_class == PseudoClass) && (image->colors > 256))
      (void) SetImageStorageClass(image,DirectClass,exception);
    if (image->storage_class != DirectClass)
      {
        /*
          Colormapped BMP raster.
        */
        bmp_info.bits_per_pixel=8;
        if (image->colors <= 2)
          bmp_info.bits_per_pixel=1;
        else
          if (image->colors <= 16)
            bmp_info.bits_per_pixel=4;
          else
            if (image->colors <= 256)
              bmp_info.bits_per_pixel=8;
        if (image_info->compression == RLECompression)
          bmp_info.bits_per_pixel=8;
        bmp_info.number_colors=1U << bmp_info.bits_per_pixel;
        if (image->alpha_trait != UndefinedPixelTrait)
          (void) SetImageStorageClass(image,DirectClass,exception);
        else
          if ((size_t) bmp_info.number_colors < image->colors)
            (void) SetImageStorageClass(image,DirectClass,exception);
          else
            {
              bmp_info.file_size+=3*(1UL << bmp_info.bits_per_pixel);
              bmp_info.offset_bits+=3*(1UL << bmp_info.bits_per_pixel);
              if (type > 2)
                {
                  bmp_info.file_size+=(1UL << bmp_info.bits_per_pixel);
                  bmp_info.offset_bits+=(1UL << bmp_info.bits_per_pixel);
                }
            }
      }
    if (image->storage_class == DirectClass)
      {
        /*
          Full color BMP raster.
        */
        bmp_info.number_colors=0;
        bmp_info.bits_per_pixel=(unsigned short)
          ((type > 3) && (image->alpha_trait != UndefinedPixelTrait) ? 32 : 24);
        bmp_info.compression=(unsigned int) ((type > 3) &&
          (image->alpha_trait != UndefinedPixelTrait) ?  BI_BITFIELDS : BI_RGB);
        if ((type == 3) && (image->alpha_trait != UndefinedPixelTrait))
          {
            option=GetImageOption(image_info,""bmp3:alpha"");
            if (IsStringTrue(option))
              bmp_info.bits_per_pixel=32;
          }
      }
    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);
    bmp_info.ba_offset=0;
    profile=GetImageProfile(image,""icc"");
    have_color_info=(image->rendering_intent != UndefinedIntent) ||
      (profile != (StringInfo *) NULL) || (image->gamma != 0.0) ?  MagickTrue :
      MagickFalse;
    if (type == 2)
      bmp_info.size=12;
    else
      if ((type == 3) || ((image->alpha_trait == UndefinedPixelTrait) &&
          (have_color_info == MagickFalse)))
        {
          type=3;
          bmp_info.size=40;
        }
      else
        {
          int
            extra_size;

          bmp_info.size=108;
          extra_size=68;
          if ((image->rendering_intent != UndefinedIntent) ||
              (profile != (StringInfo *) NULL))
            {
              bmp_info.size=124;
              extra_size+=16;
            }
          bmp_info.file_size+=extra_size;
          bmp_info.offset_bits+=extra_size;
        }
    if ((image->columns != (signed int) image->columns) ||
        (image->rows != (signed int) image->rows))
      ThrowWriterException(ImageError,""WidthOrHeightExceedsLimit"");
    bmp_info.width=(ssize_t) image->columns;
    bmp_info.height=(ssize_t) image->rows;
    bmp_info.planes=1;
    bmp_info.image_size=(unsigned long) (bytes_per_line*image->rows);
    bmp_info.file_size+=bmp_info.image_size;
    bmp_info.x_pixels=75*39;
    bmp_info.y_pixels=75*39;
    switch (image->units)
    {
      case UndefinedResolution:
      case PixelsPerInchResolution:
      {
        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x/2.54);
        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y/2.54);
        break;
      }
      case PixelsPerCentimeterResolution:
      {
        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x);
        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y);
        break;
      }
    }
    bmp_info.colors_important=bmp_info.number_colors;
    /*
      Convert MIFF to BMP raster pixels.
    */
    pixel_info=AcquireVirtualMemory((size_t) bmp_info.image_size,
      sizeof(*pixels));
    if (pixel_info == (MemoryInfo *) NULL)
      ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
    (void) ResetMagickMemory(pixels,0,(size_t) bmp_info.image_size);
    switch (bmp_info.bits_per_pixel)
    {
      case 1:
      {
        size_t
          bit,
          byte;

        /*
          Convert PseudoClass image to a BMP monochrome image.
        */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          ssize_t
            offset;

          p=GetVirtualPixels(image,0,y,image->columns,1,exception);
          if (p == (const Quantum *) NULL)
            break;
          q=pixels+(image->rows-y-1)*bytes_per_line;
          bit=0;
          byte=0;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            byte<<=1;
            byte|=GetPixelIndex(image,p) != 0 ? 0x01 : 0x00;
            bit++;
            if (bit == 8)
              {
                *q++=(unsigned char) byte;
                bit=0;
                byte=0;
              }
             p+=GetPixelChannels(image);
           }
           if (bit != 0)
             {
               *q++=(unsigned char) (byte << (8-bit));
               x++;
             }
          offset=(ssize_t) (image->columns+7)/8;
          for (x=offset; x < (ssize_t) bytes_per_line; x++)
            *q++=0x00;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case 4:
      {
        size_t
          byte,
          nibble;

        ssize_t
          offset;

        /*
          Convert PseudoClass image to a BMP monochrome image.
        */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          p=GetVirtualPixels(image,0,y,image->columns,1,exception);
          if (p == (const Quantum *) NULL)
            break;
          q=pixels+(image->rows-y-1)*bytes_per_line;
          nibble=0;
          byte=0;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            byte<<=4;
            byte|=((size_t) GetPixelIndex(image,p) & 0x0f);
            nibble++;
            if (nibble == 2)
              {
                *q++=(unsigned char) byte;
                nibble=0;
                byte=0;
              }
            p+=GetPixelChannels(image);
          }
          if (nibble != 0)
            {
              *q++=(unsigned char) (byte << 4);
              x++;
            }
          offset=(ssize_t) (image->columns+1)/2;
          for (x=offset; x < (ssize_t) bytes_per_line; x++)
            *q++=0x00;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case 8:
      {
        /*
          Convert PseudoClass packet to BMP pixel.
        */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          p=GetVirtualPixels(image,0,y,image->columns,1,exception);
          if (p == (const Quantum *) NULL)
            break;
          q=pixels+(image->rows-y-1)*bytes_per_line;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            *q++=(unsigned char) GetPixelIndex(image,p);
            p+=GetPixelChannels(image);
          }
          for ( ; x < (ssize_t) bytes_per_line; x++)
            *q++=0x00;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case 24:
      {
        /*
          Convert DirectClass packet to BMP BGR888.
        */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          p=GetVirtualPixels(image,0,y,image->columns,1,exception);
          if (p == (const Quantum *) NULL)
            break;
          q=pixels+(image->rows-y-1)*bytes_per_line;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));
            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));
            *q++=ScaleQuantumToChar(GetPixelRed(image,p));
            p+=GetPixelChannels(image);
          }
          for (x=3L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)
            *q++=0x00;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case 32:
      {
        /*
          Convert DirectClass packet to ARGB8888 pixel.
        */
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          p=GetVirtualPixels(image,0,y,image->columns,1,exception);
          if (p == (const Quantum *) NULL)
            break;
          q=pixels+(image->rows-y-1)*bytes_per_line;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));
            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));
            *q++=ScaleQuantumToChar(GetPixelRed(image,p));
            *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));
            p+=GetPixelChannels(image);
          }
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
    }
    if ((type > 2) && (bmp_info.bits_per_pixel == 8))
      if (image_info->compression != NoCompression)
        {
          MemoryInfo
            *rle_info;

          /*
            Convert run-length encoded raster pixels.
          */
          rle_info=AcquireVirtualMemory((size_t) (2*(bytes_per_line+2)+2),
            (image->rows+2)*sizeof(*pixels));
          if (rle_info == (MemoryInfo *) NULL)
            {
              pixel_info=RelinquishVirtualMemory(pixel_info);
              ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
            }
          bmp_data=(unsigned char *) GetVirtualMemoryBlob(rle_info);
          bmp_info.file_size-=bmp_info.image_size;
          bmp_info.image_size=(unsigned int) EncodeImage(image,bytes_per_line,
            pixels,bmp_data);
          bmp_info.file_size+=bmp_info.image_size;
          pixel_info=RelinquishVirtualMemory(pixel_info);
          pixel_info=rle_info;
          pixels=bmp_data;
          bmp_info.compression=BI_RLE8;
        }
    /*
      Write BMP for Windows, all versions, 14-byte header.
    */
    if (image->debug != MagickFalse)
      {
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""   Writing BMP version %.20g datastream"",(double) type);
        if (image->storage_class == DirectClass)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""   Storage class=DirectClass"");
        else
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""   Storage class=PseudoClass"");
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""   Image depth=%.20g"",(double) image->depth);
        if (image->alpha_trait != UndefinedPixelTrait)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""   Matte=True"");
        else
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""   Matte=MagickFalse"");
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""   BMP bits_per_pixel=%.20g"",(double) bmp_info.bits_per_pixel);
        switch ((int) bmp_info.compression)
        {
           case BI_RGB:
           {
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""   Compression=BI_RGB"");
             break;
           }
           case BI_RLE8:
           {
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""   Compression=BI_RLE8"");
             break;
           }
           case BI_BITFIELDS:
           {
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""   Compression=BI_BITFIELDS"");
             break;
           }
           default:
           {
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""   Compression=UNKNOWN (%lu)"",bmp_info.compression);
             break;
           }
        }
        if (bmp_info.number_colors == 0)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""   Number_colors=unspecified"");
        else
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""   Number_colors=%lu"",bmp_info.number_colors);
      }
    (void) WriteBlob(image,2,(unsigned char *) ""BM"");
    (void) WriteBlobLSBLong(image,bmp_info.file_size);
    (void) WriteBlobLSBLong(image,bmp_info.ba_offset);  /* always 0 */
    (void) WriteBlobLSBLong(image,bmp_info.offset_bits);
    if (type == 2)
      {
        /*
          Write 12-byte version 2 bitmap header.
        */
        (void) WriteBlobLSBLong(image,bmp_info.size);
        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.width);
        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.height);
        (void) WriteBlobLSBShort(image,bmp_info.planes);
        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);
      }
    else
      {
        /*
          Write 40-byte version 3+ bitmap header.
        */
        (void) WriteBlobLSBLong(image,bmp_info.size);
        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.width);
        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.height);
        (void) WriteBlobLSBShort(image,bmp_info.planes);
        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);
        (void) WriteBlobLSBLong(image,bmp_info.compression);
        (void) WriteBlobLSBLong(image,bmp_info.image_size);
        (void) WriteBlobLSBLong(image,bmp_info.x_pixels);
        (void) WriteBlobLSBLong(image,bmp_info.y_pixels);
        (void) WriteBlobLSBLong(image,bmp_info.number_colors);
        (void) WriteBlobLSBLong(image,bmp_info.colors_important);
      }
    if ((type > 3) && ((image->alpha_trait != UndefinedPixelTrait) ||
        (have_color_info != MagickFalse)))
      {
        /*
          Write the rest of the 108-byte BMP Version 4 header.
        */
        (void) WriteBlobLSBLong(image,0x00ff0000U);  /* Red mask */
        (void) WriteBlobLSBLong(image,0x0000ff00U);  /* Green mask */
        (void) WriteBlobLSBLong(image,0x000000ffU);  /* Blue mask */
        (void) WriteBlobLSBLong(image,0xff000000U);  /* Alpha mask */
        (void) WriteBlobLSBLong(image,0x73524742U);  /* sRGB */
        (void) WriteBlobLSBLong(image,(unsigned int)
          (image->chromaticity.red_primary.x*0x40000000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          (image->chromaticity.red_primary.y*0x40000000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          ((1.000f-(image->chromaticity.red_primary.x+
          image->chromaticity.red_primary.y))*0x40000000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          (image->chromaticity.green_primary.x*0x40000000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          (image->chromaticity.green_primary.y*0x40000000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          ((1.000f-(image->chromaticity.green_primary.x+
          image->chromaticity.green_primary.y))*0x40000000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          (image->chromaticity.blue_primary.x*0x40000000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          (image->chromaticity.blue_primary.y*0x40000000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          ((1.000f-(image->chromaticity.blue_primary.x+
          image->chromaticity.blue_primary.y))*0x40000000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          (bmp_info.gamma_scale.x*0x10000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          (bmp_info.gamma_scale.y*0x10000));
        (void) WriteBlobLSBLong(image,(unsigned int)
          (bmp_info.gamma_scale.z*0x10000));
        if ((image->rendering_intent != UndefinedIntent) ||
            (profile != (StringInfo *) NULL))
          {
            ssize_t
              intent;

            switch ((int) image->rendering_intent)
            {
              case SaturationIntent:
              {
                intent=LCS_GM_BUSINESS;
                break;
              }
              case RelativeIntent:
              {
                intent=LCS_GM_GRAPHICS;
                break;
              }
              case PerceptualIntent:
              {
                intent=LCS_GM_IMAGES;
                break;
              }
              case AbsoluteIntent:
              {
                intent=LCS_GM_ABS_COLORIMETRIC;
                break;
              }
              default:
              {
                intent=0;
                break;
              }
            }
            (void) WriteBlobLSBLong(image,(unsigned int) intent);
            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile data */
            (void) WriteBlobLSBLong(image,0x00);  /* dummy profile length */
            (void) WriteBlobLSBLong(image,0x00);  /* reserved */
          }
      }
    if (image->storage_class == PseudoClass)
      {
        unsigned char
          *bmp_colormap;

        /*
          Dump colormap to file.
        */
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  Colormap: %.20g entries"",(double) image->colors);
        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<
          bmp_info.bits_per_pixel),4*sizeof(*bmp_colormap));
        if (bmp_colormap == (unsigned char *) NULL)
          ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
        q=bmp_colormap;
        for (i=0; i < (ssize_t) MagickMin((ssize_t) image->colors,(ssize_t) bmp_info.number_colors); i++)
        {
          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));
          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));
          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));
          if (type > 2)
            *q++=(unsigned char) 0x0;
        }
        for ( ; i < (ssize_t) (1UL << bmp_info.bits_per_pixel); i++)
        {
          *q++=(unsigned char) 0x00;
          *q++=(unsigned char) 0x00;
          *q++=(unsigned char) 0x00;
          if (type > 2)
            *q++=(unsigned char) 0x00;
        }
        if (type <= 2)
          (void) WriteBlob(image,(size_t) (3*(1L << bmp_info.bits_per_pixel)),
            bmp_colormap);
        else
          (void) WriteBlob(image,(size_t) (4*(1L << bmp_info.bits_per_pixel)),
            bmp_colormap);
        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);
      }
    if (image->debug != MagickFalse)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""  Pixels:  %lu bytes"",bmp_info.image_size);
    (void) WriteBlob(image,(size_t) bmp_info.image_size,pixels);
    pixel_info=RelinquishVirtualMemory(pixel_info);
    if (GetNextImageInList(image) == (Image *) NULL)
      break;
    image=SyncNextImageInList(image);
    status=SetImageProgress(image,SaveImagesTag,scene++,
      GetImageListLength(image));
    if (status == MagickFalse)
      break;
  } while (image_info->adjoin != MagickFalse);
  (void) CloseBlob(image);
  return(MagickTrue);
}","static MagickBooleanType WriteBMPImage(const ImageInfo *VAR_0,Image *VAR_1,
  ExceptionInfo *VAR_2)
{
  BMPInfo
    VAR_3;

  const char
    *VAR_4;

  const StringInfo
    *VAR_5;

  MagickBooleanType
    VAR_6,
    VAR_7;

  MagickOffsetType
    VAR_8;

  MemoryInfo
    *VAR_9;

  register const Quantum
    *VAR_10;

  register ssize_t
    VAR_11,
    VAR_12;

  register unsigned char
    *VAR_13;

  size_t
    VAR_14,
    VAR_15;

  ssize_t
    VAR_16;

  unsigned char
    *VAR_17,
    *VAR_18;

  /* COMMENT_0 */
                           
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_19);
  assert(VAR_1 != (Image *) NULL);
  assert(VAR_1->signature == VAR_19);
  if (VAR_1->debug != VAR_20)
    (void) LogMagickEvent(VAR_21,GetMagickModule(),""%s"",VAR_1->filename);
  assert(VAR_2 != (ExceptionInfo *) NULL);
  assert(VAR_2->signature == VAR_19);
  VAR_7=OpenBlob(VAR_0,VAR_1,VAR_22,VAR_2);
  if (VAR_7 == VAR_20)
    return(VAR_7);
  VAR_15=4;
  if (LocaleCompare(VAR_0->magick,""BMP2"") == 0)
    VAR_15=2;
  else
    if (LocaleCompare(VAR_0->magick,""BMP3"") == 0)
      VAR_15=3;

  VAR_4=GetImageOption(VAR_0,""bmp:format"");
  if (VAR_4 != (char *) NULL)
    {
      (void) LogMagickEvent(VAR_23,GetMagickModule(),
          ""  Format=%s"",VAR_4);

      if (LocaleCompare(VAR_4,""bmp2"") == 0)
        VAR_15=2;
      if (LocaleCompare(VAR_4,""bmp3"") == 0)
        VAR_15=3;
      if (LocaleCompare(VAR_4,""bmp4"") == 0)
        VAR_15=4;
    }

  VAR_8=0;
  do
  {
    /* COMMENT_3 */
                                        
      
    (void) TransformImageColorspace(VAR_1,VAR_24,VAR_2);
    (void) ResetMagickMemory(&VAR_3,0,sizeof(VAR_3));
    VAR_3.file_size=14+12;
    if (VAR_15 > 2)
      VAR_3.file_size+=28;
    VAR_3.offset_bits=VAR_3.file_size;
    VAR_3.compression=VAR_25;
    if ((VAR_1->storage_class == VAR_26) && (VAR_1->colors > 256))
      (void) SetImageStorageClass(VAR_1,VAR_27,VAR_2);
    if (VAR_1->storage_class != VAR_27)
      {
        /* COMMENT_6 */
                                 
          
        VAR_3.bits_per_pixel=8;
        if (VAR_1->colors <= 2)
          VAR_3.bits_per_pixel=1;
        else
          if (VAR_1->colors <= 16)
            VAR_3.bits_per_pixel=4;
          else
            if (VAR_1->colors <= 256)
              VAR_3.bits_per_pixel=8;
        if (VAR_0->compression == VAR_28)
          VAR_3.bits_per_pixel=8;
        VAR_3.number_colors=1U << VAR_3.bits_per_pixel;
        if (VAR_1->alpha_trait != VAR_29)
          (void) SetImageStorageClass(VAR_1,VAR_27,VAR_2);
        else
          if ((size_t) VAR_3.number_colors < VAR_1->colors)
            (void) SetImageStorageClass(VAR_1,VAR_27,VAR_2);
          else
            {
              VAR_3.file_size+=3*(1UL << VAR_3.bits_per_pixel);
              VAR_3.offset_bits+=3*(1UL << VAR_3.bits_per_pixel);
              if (VAR_15 > 2)
                {
                  VAR_3.file_size+=(1UL << VAR_3.bits_per_pixel);
                  VAR_3.offset_bits+=(1UL << VAR_3.bits_per_pixel);
                }
            }
      }
    if (VAR_1->storage_class == VAR_27)
      {
        /* COMMENT_9 */
                                
          
        VAR_3.number_colors=0;
        VAR_3.bits_per_pixel=(unsigned short)
          ((VAR_15 > 3) && (VAR_1->alpha_trait != VAR_29) ? 32 : 24);
        VAR_3.compression=(unsigned int) ((VAR_15 > 3) &&
          (VAR_1->alpha_trait != VAR_29) ?  VAR_30 : VAR_25);
        if ((VAR_15 == 3) && (VAR_1->alpha_trait != VAR_29))
          {
            VAR_4=GetImageOption(VAR_0,""bmp3:alpha"");
            if (IsStringTrue(VAR_4))
              VAR_3.bits_per_pixel=32;
          }
      }
    VAR_14=4*((VAR_1->columns*VAR_3.bits_per_pixel+31)/32);
    VAR_3.ba_offset=0;
    VAR_5=GetImageProfile(VAR_1,""icc"");
    VAR_6=(VAR_1->rendering_intent != VAR_31) ||
      (VAR_5 != (StringInfo *) NULL) || (VAR_1->gamma != 0.0) ?  VAR_32 :
      VAR_20;
    if (VAR_15 == 2)
      VAR_3.size=12;
    else
      if ((VAR_15 == 3) || ((VAR_1->alpha_trait == VAR_29) &&
          (VAR_6 == VAR_20)))
        {
          VAR_15=3;
          VAR_3.size=40;
        }
      else
        {
          int
            VAR_33;

          VAR_3.size=108;
          VAR_33=68;
          if ((VAR_1->rendering_intent != VAR_31) ||
              (VAR_5 != (StringInfo *) NULL))
            {
              VAR_3.size=124;
              VAR_33+=16;
            }
          VAR_3.file_size+=VAR_33;
          VAR_3.offset_bits+=VAR_33;
        }
    if ((VAR_1->columns != (signed int) VAR_1->columns) ||
        (VAR_1->rows != (signed int) VAR_1->rows))
      ThrowWriterException(VAR_34,""WidthOrHeightExceedsLimit"");
    VAR_3.width=(ssize_t) VAR_1->columns;
    VAR_3.height=(ssize_t) VAR_1->rows;
    VAR_3.planes=1;
    VAR_3.image_size=(unsigned long) (VAR_14*VAR_1->rows);
    VAR_3.file_size+=VAR_3.image_size;
    VAR_3.x_pixels=75*39;
    VAR_3.y_pixels=75*39;
    switch (VAR_1->units)
    {
      case VAR_35:
      case VAR_36:
      {
        VAR_3.x_pixels=(unsigned int) (100.0*VAR_1->resolution.x/2.54);
        VAR_3.y_pixels=(unsigned int) (100.0*VAR_1->resolution.y/2.54);
        break;
      }
      case VAR_37:
      {
        VAR_3.x_pixels=(unsigned int) (100.0*VAR_1->resolution.x);
        VAR_3.y_pixels=(unsigned int) (100.0*VAR_1->resolution.y);
        break;
      }
    }
    VAR_3.colors_important=VAR_3.number_colors;
    /* COMMENT_12 */
                                        
      
    VAR_9=AcquireVirtualMemory((size_t) VAR_3.image_size,
      sizeof(*VAR_18));
    if (VAR_9 == (MemoryInfo *) NULL)
      ThrowWriterException(VAR_38,""MemoryAllocationFailed"");
    VAR_18=(unsigned char *) GetVirtualMemoryBlob(VAR_9);
    (void) ResetMagickMemory(VAR_18,0,(size_t) VAR_3.image_size);
    switch (VAR_3.bits_per_pixel)
    {
      case 1:
      {
        size_t
          VAR_39,
          VAR_40;

        /* COMMENT_15 */
                                                              
          
        for (VAR_16=0; VAR_16 < (ssize_t) VAR_1->rows; VAR_16++)
        {
          ssize_t
            VAR_41;

          VAR_10=GetVirtualPixels(VAR_1,0,VAR_16,VAR_1->columns,1,VAR_2);
          if (VAR_10 == (const Quantum *) NULL)
            break;
          VAR_13=VAR_18+(VAR_1->rows-VAR_16-1)*VAR_14;
          VAR_39=0;
          VAR_40=0;
          for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)
          {
            VAR_40<<=1;
            VAR_40|=GetPixelIndex(VAR_1,VAR_10) != 0 ? 0x01 : 0x00;
            VAR_39++;
            if (VAR_39 == 8)
              {
                *VAR_13++=(unsigned char) VAR_40;
                VAR_39=0;
                VAR_40=0;
              }
             VAR_10+=GetPixelChannels(VAR_1);
           }
           if (VAR_39 != 0)
             {
               *VAR_13++=(unsigned char) (VAR_40 << (8-VAR_39));
               VAR_12++;
             }
          VAR_41=(ssize_t) (VAR_1->columns+7)/8;
          for (VAR_12=VAR_41; VAR_12 < (ssize_t) VAR_14; VAR_12++)
            *VAR_13++=0x00;
          if (VAR_1->previous == (Image *) NULL)
            {
              VAR_7=SetImageProgress(VAR_1,VAR_42,(MagickOffsetType) VAR_16,
                VAR_1->rows);
              if (VAR_7 == VAR_20)
                break;
            }
        }
        break;
      }
      case 4:
      {
        size_t
          VAR_40,
          VAR_43;

        ssize_t
          VAR_41;

        /* COMMENT_18 */
                                                              
          
        for (VAR_16=0; VAR_16 < (ssize_t) VAR_1->rows; VAR_16++)
        {
          VAR_10=GetVirtualPixels(VAR_1,0,VAR_16,VAR_1->columns,1,VAR_2);
          if (VAR_10 == (const Quantum *) NULL)
            break;
          VAR_13=VAR_18+(VAR_1->rows-VAR_16-1)*VAR_14;
          VAR_43=0;
          VAR_40=0;
          for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)
          {
            VAR_40<<=4;
            VAR_40|=((size_t) GetPixelIndex(VAR_1,VAR_10) & 0x0f);
            VAR_43++;
            if (VAR_43 == 2)
              {
                *VAR_13++=(unsigned char) VAR_40;
                VAR_43=0;
                VAR_40=0;
              }
            VAR_10+=GetPixelChannels(VAR_1);
          }
          if (VAR_43 != 0)
            {
              *VAR_13++=(unsigned char) (VAR_40 << 4);
              VAR_12++;
            }
          VAR_41=(ssize_t) (VAR_1->columns+1)/2;
          for (VAR_12=VAR_41; VAR_12 < (ssize_t) VAR_14; VAR_12++)
            *VAR_13++=0x00;
          if (VAR_1->previous == (Image *) NULL)
            {
              VAR_7=SetImageProgress(VAR_1,VAR_42,(MagickOffsetType) VAR_16,
                VAR_1->rows);
              if (VAR_7 == VAR_20)
                break;
            }
        }
        break;
      }
      case 8:
      {
        /* COMMENT_21 */
                                                  
          
        for (VAR_16=0; VAR_16 < (ssize_t) VAR_1->rows; VAR_16++)
        {
          VAR_10=GetVirtualPixels(VAR_1,0,VAR_16,VAR_1->columns,1,VAR_2);
          if (VAR_10 == (const Quantum *) NULL)
            break;
          VAR_13=VAR_18+(VAR_1->rows-VAR_16-1)*VAR_14;
          for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)
          {
            *VAR_13++=(unsigned char) GetPixelIndex(VAR_1,VAR_10);
            VAR_10+=GetPixelChannels(VAR_1);
          }
          for ( ; VAR_12 < (ssize_t) VAR_14; VAR_12++)
            *VAR_13++=0x00;
          if (VAR_1->previous == (Image *) NULL)
            {
              VAR_7=SetImageProgress(VAR_1,VAR_42,(MagickOffsetType) VAR_16,
                VAR_1->rows);
              if (VAR_7 == VAR_20)
                break;
            }
        }
        break;
      }
      case 24:
      {
        /* COMMENT_24 */
                                                   
          
        for (VAR_16=0; VAR_16 < (ssize_t) VAR_1->rows; VAR_16++)
        {
          VAR_10=GetVirtualPixels(VAR_1,0,VAR_16,VAR_1->columns,1,VAR_2);
          if (VAR_10 == (const Quantum *) NULL)
            break;
          VAR_13=VAR_18+(VAR_1->rows-VAR_16-1)*VAR_14;
          for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)
          {
            *VAR_13++=ScaleQuantumToChar(GetPixelBlue(VAR_1,VAR_10));
            *VAR_13++=ScaleQuantumToChar(GetPixelGreen(VAR_1,VAR_10));
            *VAR_13++=ScaleQuantumToChar(GetPixelRed(VAR_1,VAR_10));
            VAR_10+=GetPixelChannels(VAR_1);
          }
          for (VAR_12=3L*(ssize_t) VAR_1->columns; VAR_12 < (ssize_t) VAR_14; VAR_12++)
            *VAR_13++=0x00;
          if (VAR_1->previous == (Image *) NULL)
            {
              VAR_7=SetImageProgress(VAR_1,VAR_42,(MagickOffsetType) VAR_16,
                VAR_1->rows);
              if (VAR_7 == VAR_20)
                break;
            }
        }
        break;
      }
      case 32:
      {
        /* COMMENT_27 */
                                                       
          
        for (VAR_16=0; VAR_16 < (ssize_t) VAR_1->rows; VAR_16++)
        {
          VAR_10=GetVirtualPixels(VAR_1,0,VAR_16,VAR_1->columns,1,VAR_2);
          if (VAR_10 == (const Quantum *) NULL)
            break;
          VAR_13=VAR_18+(VAR_1->rows-VAR_16-1)*VAR_14;
          for (VAR_12=0; VAR_12 < (ssize_t) VAR_1->columns; VAR_12++)
          {
            *VAR_13++=ScaleQuantumToChar(GetPixelBlue(VAR_1,VAR_10));
            *VAR_13++=ScaleQuantumToChar(GetPixelGreen(VAR_1,VAR_10));
            *VAR_13++=ScaleQuantumToChar(GetPixelRed(VAR_1,VAR_10));
            *VAR_13++=ScaleQuantumToChar(GetPixelAlpha(VAR_1,VAR_10));
            VAR_10+=GetPixelChannels(VAR_1);
          }
          if (VAR_1->previous == (Image *) NULL)
            {
              VAR_7=SetImageProgress(VAR_1,VAR_42,(MagickOffsetType) VAR_16,
                VAR_1->rows);
              if (VAR_7 == VAR_20)
                break;
            }
        }
        break;
      }
    }
    if ((VAR_15 > 2) && (VAR_3.bits_per_pixel == 8))
      if (VAR_0->compression != VAR_44)
        {
          MemoryInfo
            *VAR_45;

          /* COMMENT_30 */
                                                     
            
          VAR_45=AcquireVirtualMemory((size_t) (2*(VAR_14+2)+2),
            (VAR_1->rows+2)*sizeof(*VAR_18));
          if (VAR_45 == (MemoryInfo *) NULL)
            {
              VAR_9=RelinquishVirtualMemory(VAR_9);
              ThrowWriterException(VAR_38,""MemoryAllocationFailed"");
            }
          VAR_17=(unsigned char *) GetVirtualMemoryBlob(VAR_45);
          VAR_3.file_size-=VAR_3.image_size;
          VAR_3.image_size=(unsigned int) EncodeImage(VAR_1,VAR_14,
            VAR_18,VAR_17);
          VAR_3.file_size+=VAR_3.image_size;
          VAR_9=RelinquishVirtualMemory(VAR_9);
          VAR_9=VAR_45;
          VAR_18=VAR_17;
          VAR_3.compression=VAR_46;
        }
    /* COMMENT_33 */
                                                          
      
    if (VAR_1->debug != VAR_20)
      {
        (void) LogMagickEvent(VAR_23,GetMagickModule(),
          ""   Writing BMP version %.20g datastream"",(double) VAR_15);
        if (VAR_1->storage_class == VAR_27)
          (void) LogMagickEvent(VAR_23,GetMagickModule(),
            ""   Storage class=DirectClass"");
        else
          (void) LogMagickEvent(VAR_23,GetMagickModule(),
            ""   Storage class=PseudoClass"");
        (void) LogMagickEvent(VAR_23,GetMagickModule(),
          ""   Image depth=%.20g"",(double) VAR_1->depth);
        if (VAR_1->alpha_trait != VAR_29)
          (void) LogMagickEvent(VAR_23,GetMagickModule(),
            ""   Matte=True"");
        else
          (void) LogMagickEvent(VAR_23,GetMagickModule(),
            ""   Matte=MagickFalse"");
        (void) LogMagickEvent(VAR_23,GetMagickModule(),
          ""   BMP bits_per_pixel=%.20g"",(double) VAR_3.bits_per_pixel);
        switch ((int) VAR_3.compression)
        {
           case VAR_25:
           {
             (void) LogMagickEvent(VAR_23,GetMagickModule(),
               ""   Compression=BI_RGB"");
             break;
           }
           case VAR_46:
           {
             (void) LogMagickEvent(VAR_23,GetMagickModule(),
               ""   Compression=BI_RLE8"");
             break;
           }
           case VAR_30:
           {
             (void) LogMagickEvent(VAR_23,GetMagickModule(),
               ""   Compression=BI_BITFIELDS"");
             break;
           }
           default:
           {
             (void) LogMagickEvent(VAR_23,GetMagickModule(),
               ""   Compression=UNKNOWN (%lu)"",VAR_3.compression);
             break;
           }
        }
        if (VAR_3.number_colors == 0)
          (void) LogMagickEvent(VAR_23,GetMagickModule(),
            ""   Number_colors=unspecified"");
        else
          (void) LogMagickEvent(VAR_23,GetMagickModule(),
            ""   Number_colors=%lu"",VAR_3.number_colors);
      }
    (void) WriteBlob(VAR_1,2,(unsigned char *) ""BM"");
    (void) WriteBlobLSBLong(VAR_1,VAR_3.file_size);
    (void) WriteBlobLSBLong(VAR_1,VAR_3.ba_offset);  /* COMMENT_36 */
    (void) WriteBlobLSBLong(VAR_1,VAR_3.offset_bits);
    if (VAR_15 == 2)
      {
        /* COMMENT_37 */
                                                
          
        (void) WriteBlobLSBLong(VAR_1,VAR_3.size);
        (void) WriteBlobLSBSignedShort(VAR_1,(signed short) VAR_3.width);
        (void) WriteBlobLSBSignedShort(VAR_1,(signed short) VAR_3.height);
        (void) WriteBlobLSBShort(VAR_1,VAR_3.planes);
        (void) WriteBlobLSBShort(VAR_1,VAR_3.bits_per_pixel);
      }
    else
      {
        /* COMMENT_40 */
                                                 
          
        (void) WriteBlobLSBLong(VAR_1,VAR_3.size);
        (void) WriteBlobLSBSignedLong(VAR_1,(signed int) VAR_3.width);
        (void) WriteBlobLSBSignedLong(VAR_1,(signed int) VAR_3.height);
        (void) WriteBlobLSBShort(VAR_1,VAR_3.planes);
        (void) WriteBlobLSBShort(VAR_1,VAR_3.bits_per_pixel);
        (void) WriteBlobLSBLong(VAR_1,VAR_3.compression);
        (void) WriteBlobLSBLong(VAR_1,VAR_3.image_size);
        (void) WriteBlobLSBLong(VAR_1,VAR_3.x_pixels);
        (void) WriteBlobLSBLong(VAR_1,VAR_3.y_pixels);
        (void) WriteBlobLSBLong(VAR_1,VAR_3.number_colors);
        (void) WriteBlobLSBLong(VAR_1,VAR_3.colors_important);
      }
    if ((VAR_15 > 3) && ((VAR_1->alpha_trait != VAR_29) ||
        (VAR_6 != VAR_20)))
      {
        /* COMMENT_43 */
                                                              
          
        (void) WriteBlobLSBLong(VAR_1,0x00ff0000U);  /* COMMENT_46 */
        (void) WriteBlobLSBLong(VAR_1,0x0000ff00U);  /* COMMENT_47 */
        (void) WriteBlobLSBLong(VAR_1,0x000000ffU);  /* COMMENT_48 */
        (void) WriteBlobLSBLong(VAR_1,0xff000000U);  /* COMMENT_49 */
        (void) WriteBlobLSBLong(VAR_1,0x73524742U);  /* COMMENT_50 */
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          (VAR_1->chromaticity.red_primary.x*0x40000000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          (VAR_1->chromaticity.red_primary.y*0x40000000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          ((1.000f-(VAR_1->chromaticity.red_primary.x+
          VAR_1->chromaticity.red_primary.y))*0x40000000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          (VAR_1->chromaticity.green_primary.x*0x40000000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          (VAR_1->chromaticity.green_primary.y*0x40000000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          ((1.000f-(VAR_1->chromaticity.green_primary.x+
          VAR_1->chromaticity.green_primary.y))*0x40000000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          (VAR_1->chromaticity.blue_primary.x*0x40000000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          (VAR_1->chromaticity.blue_primary.y*0x40000000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          ((1.000f-(VAR_1->chromaticity.blue_primary.x+
          VAR_1->chromaticity.blue_primary.y))*0x40000000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          (VAR_3.gamma_scale.x*0x10000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          (VAR_3.gamma_scale.y*0x10000));
        (void) WriteBlobLSBLong(VAR_1,(unsigned int)
          (VAR_3.gamma_scale.z*0x10000));
        if ((VAR_1->rendering_intent != VAR_31) ||
            (VAR_5 != (StringInfo *) NULL))
          {
            ssize_t
              VAR_47;

            switch ((int) VAR_1->rendering_intent)
            {
              case VAR_48:
              {
                VAR_47=VAR_49;
                break;
              }
              case VAR_50:
              {
                VAR_47=VAR_51;
                break;
              }
              case VAR_52:
              {
                VAR_47=VAR_53;
                break;
              }
              case VAR_54:
              {
                VAR_47=VAR_55;
                break;
              }
              default:
              {
                VAR_47=0;
                break;
              }
            }
            (void) WriteBlobLSBLong(VAR_1,(unsigned int) VAR_47);
            (void) WriteBlobLSBLong(VAR_1,0x00);  /* COMMENT_51 */
            (void) WriteBlobLSBLong(VAR_1,0x00);  /* COMMENT_52 */
            (void) WriteBlobLSBLong(VAR_1,0x00);  /* COMMENT_53 */
          }
      }
    if (VAR_1->storage_class == VAR_26)
      {
        unsigned char
          *VAR_56;

        /* COMMENT_54 */
                                
          
        if (VAR_1->debug != VAR_20)
          (void) LogMagickEvent(VAR_23,GetMagickModule(),
            ""  Colormap: %.20g entries"",(double) VAR_1->colors);
        VAR_56=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<
          VAR_3.bits_per_pixel),4*sizeof(*VAR_56));
        if (VAR_56 == (unsigned char *) NULL)
          ThrowWriterException(VAR_38,""MemoryAllocationFailed"");
        VAR_13=VAR_56;
        for (VAR_11=0; VAR_11 < (ssize_t) MagickMin((ssize_t) VAR_1->colors,(ssize_t) VAR_3.number_colors); VAR_11++)
        {
          *VAR_13++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_11].blue));
          *VAR_13++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_11].green));
          *VAR_13++=ScaleQuantumToChar(ClampToQuantum(VAR_1->colormap[VAR_11].red));
          if (VAR_15 > 2)
            *VAR_13++=(unsigned char) 0x0;
        }
        for ( ; VAR_11 < (ssize_t) (1UL << VAR_3.bits_per_pixel); VAR_11++)
        {
          *VAR_13++=(unsigned char) 0x00;
          *VAR_13++=(unsigned char) 0x00;
          *VAR_13++=(unsigned char) 0x00;
          if (VAR_15 > 2)
            *VAR_13++=(unsigned char) 0x00;
        }
        if (VAR_15 <= 2)
          (void) WriteBlob(VAR_1,(size_t) (3*(1L << VAR_3.bits_per_pixel)),
            VAR_56);
        else
          (void) WriteBlob(VAR_1,(size_t) (4*(1L << VAR_3.bits_per_pixel)),
            VAR_56);
        VAR_56=(unsigned char *) RelinquishMagickMemory(VAR_56);
      }
    if (VAR_1->debug != VAR_20)
      (void) LogMagickEvent(VAR_23,GetMagickModule(),
        ""  Pixels:  %lu bytes"",VAR_3.image_size);
    (void) WriteBlob(VAR_1,(size_t) VAR_3.image_size,VAR_18);
    VAR_9=RelinquishVirtualMemory(VAR_9);
    if (GetNextImageInList(VAR_1) == (Image *) NULL)
      break;
    VAR_1=SyncNextImageInList(VAR_1);
    VAR_7=SetImageProgress(VAR_1,VAR_57,VAR_8++,
      GetImageListLength(VAR_1));
    if (VAR_7 == VAR_20)
      break;
  } while (VAR_0->adjoin != VAR_20);
  (void) CloseBlob(VAR_1);
  return(VAR_32);
}",ImageMagick/4cc6ec8a4197d4c008577127736bf7985d632323/bmp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -172,10 +172,13 @@
           bmp_info.file_size+=extra_size;
           bmp_info.offset_bits+=extra_size;
         }
+    if ((image->columns != (signed int) image->columns) ||
+        (image->rows != (signed int) image->rows))
+      ThrowWriterException(ImageError,""WidthOrHeightExceedsLimit"");
     bmp_info.width=(ssize_t) image->columns;
     bmp_info.height=(ssize_t) image->rows;
     bmp_info.planes=1;
-    bmp_info.image_size=(unsigned int) (bytes_per_line*image->rows);
+    bmp_info.image_size=(unsigned long) (bytes_per_line*image->rows);
     bmp_info.file_size+=bmp_info.image_size;
     bmp_info.x_pixels=75*39;
     bmp_info.y_pixels=75*39;","{'deleted_lines': ['    bmp_info.image_size=(unsigned int) (bytes_per_line*image->rows);'], 'added_lines': ['    if ((image->columns != (signed int) image->columns) ||', '        (image->rows != (signed int) image->rows))', '      ThrowWriterException(ImageError,""WidthOrHeightExceedsLimit"");', '    bmp_info.image_size=(unsigned long) (bytes_per_line*image->rows);']}",True,"Integer overflow in the BMP coder in ImageMagick before 7.0.2-10 allows remote attackers to cause a denial of service (crash) via crafted height and width values, which triggers an out-of-bounds write.",7.5,HIGH,2,test,2016-08-15T19:54:42Z,1
CVE-2016-10167,['CWE-20'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,libgd,"Fix DOS vulnerability in gdImageCreateFromGd2Ctx()

We must not pretend that there are image data if there are none. Instead
we fail reading the image file gracefully.",fe9ed49dafa993e3af96b6a5a589efeea9bfb36f,https://github.com/libgd/libgd/commit/fe9ed49dafa993e3af96b6a5a589efeea9bfb36f,src/gd_gd2.c,gdImageCreateFromGd2Ctx,"BGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ctx (gdIOCtxPtr in)
{
int sx, sy;
int i;
int ncx, ncy, nc, cs, cx, cy;
int x, y, ylo, yhi, xlo, xhi;
int vers, fmt;
t_chunk_info *chunkIdx = NULL;
unsigned char *chunkBuf = NULL;
int chunkNum = 0;
int chunkMax = 0;
uLongf chunkLen;
int chunkPos = 0;
int compMax = 0;
int bytesPerPixel;
char *compBuf = NULL;
gdImagePtr im;
im =
_gd2CreateFromFile (in, &sx, &sy, &cs, &vers, &fmt, &ncx, &ncy,
&chunkIdx);
if (im == NULL) {
return 0;
}
bytesPerPixel = im->trueColor ? 4 : 1;
nc = ncx * ncy;
if (gd2_compressed (fmt)) {
compMax = 0;
for (i = 0; (i < nc); i++) {
if (chunkIdx[i].size > compMax) {
compMax = chunkIdx[i].size;
};
};
compMax++;
chunkMax = cs * bytesPerPixel * cs;
chunkBuf = gdCalloc (chunkMax, 1);
if (!chunkBuf) {
goto fail;
}
compBuf = gdCalloc (compMax, 1);
if (!compBuf) {
goto fail;
}
GD2_DBG (printf (""Largest compressed chunk is %d bytes\n"", compMax));
};
for (cy = 0; (cy < ncy); cy++) {
for (cx = 0; (cx < ncx); cx++) {
ylo = cy * cs;
yhi = ylo + cs;
if (yhi > im->sy) {
yhi = im->sy;
};
GD2_DBG (printf
(""Processing Chunk %d (%d, %d), y from %d to %d\n"",
chunkNum, cx, cy, ylo, yhi));
if (gd2_compressed (fmt)) {
chunkLen = chunkMax;
if (!_gd2ReadChunk (chunkIdx[chunkNum].offset,
compBuf,
chunkIdx[chunkNum].size,
(char *) chunkBuf, &chunkLen, in)) {
GD2_DBG (printf (""Error reading comproessed chunk\n""));
goto fail;
};
chunkPos = 0;
};
for (y = ylo; (y < yhi); y++) {
xlo = cx * cs;
xhi = xlo + cs;
if (xhi > im->sx) {
xhi = im->sx;
};
if (!gd2_compressed (fmt)) {
for (x = xlo; x < xhi; x++) {
if (im->trueColor) {
if (!gdGetInt (&im->tpixels[y][x], in)) {
im->tpixels[y][x] = 0;
}
} else {
int ch;
if (!gdGetByte (&ch, in)) {
ch = 0;
}
im->pixels[y][x] = ch;
}
}
} else {
for (x = xlo; x < xhi; x++) {
if (im->trueColor) {
int a = chunkBuf[chunkPos++] << 24;
int r = chunkBuf[chunkPos++] << 16;
int g = chunkBuf[chunkPos++] << 8;
int b = chunkBuf[chunkPos++];
im->tpixels[y][x] = a + r + g + b;
} else {
im->pixels[y][x] = chunkBuf[chunkPos++];
}
};
};
};
chunkNum++;
};
};
GD2_DBG (printf (""Freeing memory\n""));
gdFree (chunkBuf);
gdFree (compBuf);
gdFree (chunkIdx);
GD2_DBG (printf (""Done\n""));
return im;
fail:
gdImageDestroy (im);
if (chunkBuf) {
gdFree (chunkBuf);
}
if (compBuf) {
gdFree (compBuf);
}
if (chunkIdx) {
gdFree (chunkIdx);
}
return 0;
}","VAR_0(gdImagePtr) gdImageCreateFromGd2Ctx (gdIOCtxPtr VAR_1)
{
int VAR_2, VAR_3;
int VAR_4;
int VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10;
int VAR_11, VAR_12, VAR_13, VAR_14, VAR_15, VAR_16;
int VAR_17, VAR_18;
t_chunk_info *VAR_19 = NULL;
unsigned char *VAR_20 = NULL;
int VAR_21 = 0;
int VAR_22 = 0;
uLongf VAR_23;
int VAR_24 = 0;
int VAR_25 = 0;
int VAR_26;
char *VAR_27 = NULL;
gdImagePtr VAR_28;
VAR_28 =
_gd2CreateFromFile (VAR_1, &VAR_2, &VAR_3, &VAR_8, &VAR_17, &VAR_18, &VAR_5, &VAR_6,
&VAR_19);
if (VAR_28 == NULL) {
return 0;
}
VAR_26 = VAR_28->trueColor ? 4 : 1;
VAR_7 = VAR_5 * VAR_6;
if (gd2_compressed (VAR_18)) {
VAR_25 = 0;
for (VAR_4 = 0; (VAR_4 < VAR_7); VAR_4++) {
if (VAR_19[VAR_4].size > VAR_25) {
VAR_25 = VAR_19[VAR_4].size;
};
};
VAR_25++;
VAR_22 = VAR_8 * VAR_26 * VAR_8;
VAR_20 = gdCalloc (VAR_22, 1);
if (!VAR_20) {
goto fail;
}
VAR_27 = gdCalloc (VAR_25, 1);
if (!VAR_27) {
goto fail;
}
GD2_DBG (printf (""Largest compressed chunk is %d bytes\n"", VAR_25));
};
for (VAR_10 = 0; (VAR_10 < VAR_6); VAR_10++) {
for (VAR_9 = 0; (VAR_9 < VAR_5); VAR_9++) {
VAR_13 = VAR_10 * VAR_8;
VAR_14 = VAR_13 + VAR_8;
if (VAR_14 > VAR_28->sy) {
VAR_14 = VAR_28->sy;
};
GD2_DBG (printf
(""Processing Chunk %d (%d, %d), y from %d to %d\n"",
VAR_21, VAR_9, VAR_10, VAR_13, VAR_14));
if (gd2_compressed (VAR_18)) {
VAR_23 = VAR_22;
if (!_gd2ReadChunk (VAR_19[VAR_21].offset,
VAR_27,
VAR_19[VAR_21].size,
(char *) VAR_20, &VAR_23, VAR_1)) {
GD2_DBG (printf (""Error reading comproessed chunk\n""));
goto fail;
};
VAR_24 = 0;
};
for (VAR_12 = VAR_13; (VAR_12 < VAR_14); VAR_12++) {
VAR_15 = VAR_9 * VAR_8;
VAR_16 = VAR_15 + VAR_8;
if (VAR_16 > VAR_28->sx) {
VAR_16 = VAR_28->sx;
};
if (!gd2_compressed (VAR_18)) {
for (VAR_11 = VAR_15; VAR_11 < VAR_16; VAR_11++) {
if (VAR_28->trueColor) {
if (!gdGetInt (&VAR_28->tpixels[VAR_12][VAR_11], VAR_1)) {
VAR_28->tpixels[VAR_12][VAR_11] = 0;
}
} else {
int VAR_29;
if (!gdGetByte (&VAR_29, VAR_1)) {
VAR_29 = 0;
}
VAR_28->pixels[VAR_12][VAR_11] = VAR_29;
}
}
} else {
for (VAR_11 = VAR_15; VAR_11 < VAR_16; VAR_11++) {
if (VAR_28->trueColor) {
int VAR_30 = VAR_20[VAR_24++] << 24;
int VAR_31 = VAR_20[VAR_24++] << 16;
int VAR_32 = VAR_20[VAR_24++] << 8;
int VAR_33 = VAR_20[VAR_24++];
VAR_28->tpixels[VAR_12][VAR_11] = VAR_30 + VAR_31 + VAR_32 + VAR_33;
} else {
VAR_28->pixels[VAR_12][VAR_11] = VAR_20[VAR_24++];
}
};
};
};
VAR_21++;
};
};
GD2_DBG (printf (""Freeing memory\n""));
gdFree (VAR_20);
gdFree (VAR_27);
gdFree (VAR_19);
GD2_DBG (printf (""Done\n""));
return VAR_28;
fail:
gdImageDestroy (VAR_28);
if (VAR_20) {
gdFree (VAR_20);
}
if (VAR_27) {
gdFree (VAR_27);
}
if (VAR_19) {
gdFree (VAR_19);
}
return 0;
}",,"BGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ctx (gdIOCtxPtr in)
{
	int sx, sy;
	int i;
	int ncx, ncy, nc, cs, cx, cy;
	int x, y, ylo, yhi, xlo, xhi;
	int vers, fmt;
	t_chunk_info *chunkIdx = NULL;	/* So we can gdFree it with impunity. */
	unsigned char *chunkBuf = NULL;	/* So we can gdFree it with impunity. */
	int chunkNum = 0;
	int chunkMax = 0;
	uLongf chunkLen;
	int chunkPos = 0;
	int compMax = 0;
	int bytesPerPixel;
	char *compBuf = NULL;		/* So we can gdFree it with impunity. */

	gdImagePtr im;

	/* Get the header */
	im =
	    _gd2CreateFromFile (in, &sx, &sy, &cs, &vers, &fmt, &ncx, &ncy,
	                        &chunkIdx);
	if (im == NULL) {
		/* No need to free chunkIdx as _gd2CreateFromFile does it for us. */
		return 0;
	}

	bytesPerPixel = im->trueColor ? 4 : 1;
	nc = ncx * ncy;

	if (gd2_compressed (fmt)) {
		/* Find the maximum compressed chunk size. */
		compMax = 0;
		for (i = 0; (i < nc); i++) {
			if (chunkIdx[i].size > compMax) {
				compMax = chunkIdx[i].size;
			};
		};
		compMax++;

		/* Allocate buffers */
		chunkMax = cs * bytesPerPixel * cs;
		chunkBuf = gdCalloc (chunkMax, 1);
		if (!chunkBuf) {
			goto fail;
		}
		compBuf = gdCalloc (compMax, 1);
		if (!compBuf) {
			goto fail;
		}

		GD2_DBG (printf (""Largest compressed chunk is %d bytes\n"", compMax));
	};

	/*      if ( (ncx != sx / cs) || (ncy != sy / cs)) { */
	/*              goto fail2; */
	/*      }; */

	/* Read the data... */
	for (cy = 0; (cy < ncy); cy++) {
		for (cx = 0; (cx < ncx); cx++) {

			ylo = cy * cs;
			yhi = ylo + cs;
			if (yhi > im->sy) {
				yhi = im->sy;
			};

			GD2_DBG (printf
			         (""Processing Chunk %d (%d, %d), y from %d to %d\n"",
			          chunkNum, cx, cy, ylo, yhi));

			if (gd2_compressed (fmt)) {

				chunkLen = chunkMax;

				if (!_gd2ReadChunk (chunkIdx[chunkNum].offset,
				                    compBuf,
				                    chunkIdx[chunkNum].size,
				                    (char *) chunkBuf, &chunkLen, in)) {
					GD2_DBG (printf (""Error reading comproessed chunk\n""));
					goto fail;
				};

				chunkPos = 0;
			};

			for (y = ylo; (y < yhi); y++) {

				xlo = cx * cs;
				xhi = xlo + cs;
				if (xhi > im->sx) {
					xhi = im->sx;
				};
				/*GD2_DBG(printf(""y=%d: "",y)); */
				if (!gd2_compressed (fmt)) {
					for (x = xlo; x < xhi; x++) {

						if (im->trueColor) {
							if (!gdGetInt (&im->tpixels[y][x], in)) {
								gd_error(""gd2: EOF while reading\n"");
								gdImageDestroy(im);
								return NULL;
							}
						} else {
							int ch;
							if (!gdGetByte (&ch, in)) {
								gd_error(""gd2: EOF while reading\n"");
								gdImageDestroy(im);
								return NULL;
							}
							im->pixels[y][x] = ch;
						}
					}
				} else {
					for (x = xlo; x < xhi; x++) {
						if (im->trueColor) {
							/* 2.0.1: work around a gcc bug by being verbose.
							   TBB */
							int a = chunkBuf[chunkPos++] << 24;
							int r = chunkBuf[chunkPos++] << 16;
							int g = chunkBuf[chunkPos++] << 8;
							int b = chunkBuf[chunkPos++];
							/* 2.0.11: tpixels */
							im->tpixels[y][x] = a + r + g + b;
						} else {
							im->pixels[y][x] = chunkBuf[chunkPos++];
						}
					};
				};
				/*GD2_DBG(printf(""\n"")); */
			};
			chunkNum++;
		};
	};

	GD2_DBG (printf (""Freeing memory\n""));

	gdFree (chunkBuf);
	gdFree (compBuf);
	gdFree (chunkIdx);

	GD2_DBG (printf (""Done\n""));

	return im;

fail:
	gdImageDestroy (im);
	if (chunkBuf) {
		gdFree (chunkBuf);
	}
	if (compBuf) {
		gdFree (compBuf);
	}
	if (chunkIdx) {
		gdFree (chunkIdx);
	}
	return 0;
}","VAR_0(gdImagePtr) gdImageCreateFromGd2Ctx (gdIOCtxPtr VAR_1)
{
	int VAR_2, VAR_3;
	int VAR_4;
	int VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10;
	int VAR_11, VAR_12, VAR_13, VAR_14, VAR_15, VAR_16;
	int VAR_17, VAR_18;
	t_chunk_info *VAR_19 = NULL;	/* COMMENT_0 */
	unsigned char *VAR_20 = NULL;	/* COMMENT_0 */
	int VAR_21 = 0;
	int VAR_22 = 0;
	uLongf VAR_23;
	int VAR_24 = 0;
	int VAR_25 = 0;
	int VAR_26;
	char *VAR_27 = NULL;		/* COMMENT_0 */

	gdImagePtr VAR_28;

	/* COMMENT_1 */
	VAR_28 =
	    _gd2CreateFromFile (VAR_1, &VAR_2, &VAR_3, &VAR_8, &VAR_17, &VAR_18, &VAR_5, &VAR_6,
	                        &VAR_19);
	if (VAR_28 == NULL) {
		/* COMMENT_2 */
		return 0;
	}

	VAR_26 = VAR_28->trueColor ? 4 : 1;
	VAR_7 = VAR_5 * VAR_6;

	if (gd2_compressed (VAR_18)) {
		/* COMMENT_3 */
		VAR_25 = 0;
		for (VAR_4 = 0; (VAR_4 < VAR_7); VAR_4++) {
			if (VAR_19[VAR_4].size > VAR_25) {
				VAR_25 = VAR_19[VAR_4].size;
			};
		};
		VAR_25++;

		/* COMMENT_4 */
		VAR_22 = VAR_8 * VAR_26 * VAR_8;
		VAR_20 = gdCalloc (VAR_22, 1);
		if (!VAR_20) {
			goto fail;
		}
		VAR_27 = gdCalloc (VAR_25, 1);
		if (!VAR_27) {
			goto fail;
		}

		GD2_DBG (printf (""Largest compressed chunk is %d bytes\n"", VAR_25));
	};

	/* COMMENT_5 */
	/* COMMENT_6 */
	/* COMMENT_7 */

	/* COMMENT_8 */
	for (VAR_10 = 0; (VAR_10 < VAR_6); VAR_10++) {
		for (VAR_9 = 0; (VAR_9 < VAR_5); VAR_9++) {

			VAR_13 = VAR_10 * VAR_8;
			VAR_14 = VAR_13 + VAR_8;
			if (VAR_14 > VAR_28->sy) {
				VAR_14 = VAR_28->sy;
			};

			GD2_DBG (printf
			         (""Processing Chunk %d (%d, %d), y from %d to %d\n"",
			          VAR_21, VAR_9, VAR_10, VAR_13, VAR_14));

			if (gd2_compressed (VAR_18)) {

				VAR_23 = VAR_22;

				if (!_gd2ReadChunk (VAR_19[VAR_21].offset,
				                    VAR_27,
				                    VAR_19[VAR_21].size,
				                    (char *) VAR_20, &VAR_23, VAR_1)) {
					GD2_DBG (printf (""Error reading comproessed chunk\n""));
					goto fail;
				};

				VAR_24 = 0;
			};

			for (VAR_12 = VAR_13; (VAR_12 < VAR_14); VAR_12++) {

				VAR_15 = VAR_9 * VAR_8;
				VAR_16 = VAR_15 + VAR_8;
				if (VAR_16 > VAR_28->sx) {
					VAR_16 = VAR_28->sx;
				};
				/* COMMENT_9 */
				if (!gd2_compressed (VAR_18)) {
					for (VAR_11 = VAR_15; VAR_11 < VAR_16; VAR_11++) {

						if (VAR_28->trueColor) {
							if (!gdGetInt (&VAR_28->tpixels[VAR_12][VAR_11], VAR_1)) {
								gd_error(""gd2: EOF while reading\n"");
								gdImageDestroy(VAR_28);
								return NULL;
							}
						} else {
							int VAR_29;
							if (!gdGetByte (&VAR_29, VAR_1)) {
								gd_error(""gd2: EOF while reading\n"");
								gdImageDestroy(VAR_28);
								return NULL;
							}
							VAR_28->pixels[VAR_12][VAR_11] = VAR_29;
						}
					}
				} else {
					for (VAR_11 = VAR_15; VAR_11 < VAR_16; VAR_11++) {
						if (VAR_28->trueColor) {
							/* COMMENT_10 */
                
							int VAR_30 = VAR_20[VAR_24++] << 24;
							int VAR_31 = VAR_20[VAR_24++] << 16;
							int VAR_32 = VAR_20[VAR_24++] << 8;
							int VAR_33 = VAR_20[VAR_24++];
							/* COMMENT_12 */
							VAR_28->tpixels[VAR_12][VAR_11] = VAR_30 + VAR_31 + VAR_32 + VAR_33;
						} else {
							VAR_28->pixels[VAR_12][VAR_11] = VAR_20[VAR_24++];
						}
					};
				};
				/* COMMENT_13 */
			};
			VAR_21++;
		};
	};

	GD2_DBG (printf (""Freeing memory\n""));

	gdFree (VAR_20);
	gdFree (VAR_27);
	gdFree (VAR_19);

	GD2_DBG (printf (""Done\n""));

	return VAR_28;

fail:
	gdImageDestroy (VAR_28);
	if (VAR_20) {
		gdFree (VAR_20);
	}
	if (VAR_27) {
		gdFree (VAR_27);
	}
	if (VAR_19) {
		gdFree (VAR_19);
	}
	return 0;
}",,"--- func_before
+++ func_after
@@ -99,18 +99,16 @@
 
 						if (im->trueColor) {
 							if (!gdGetInt (&im->tpixels[y][x], in)) {
-								/*printf(""EOF while reading\n""); */
-								/*gdImageDestroy(im); */
-								/*return 0; */
-								im->tpixels[y][x] = 0;
+								gd_error(""gd2: EOF while reading\n"");
+								gdImageDestroy(im);
+								return NULL;
 							}
 						} else {
 							int ch;
 							if (!gdGetByte (&ch, in)) {
-								/*printf(""EOF while reading\n""); */
-								/*gdImageDestroy(im); */
-								/*return 0; */
-								ch = 0;
+								gd_error(""gd2: EOF while reading\n"");
+								gdImageDestroy(im);
+								return NULL;
 							}
 							im->pixels[y][x] = ch;
 						}","{'deleted_lines': ['\t\t\t\t\t\t\t\t/*printf(""EOF while reading\\n""); */', '\t\t\t\t\t\t\t\t/*gdImageDestroy(im); */', '\t\t\t\t\t\t\t\t/*return 0; */', '\t\t\t\t\t\t\t\tim->tpixels[y][x] = 0;', '\t\t\t\t\t\t\t\t/*printf(""EOF while reading\\n""); */', '\t\t\t\t\t\t\t\t/*gdImageDestroy(im); */', '\t\t\t\t\t\t\t\t/*return 0; */', '\t\t\t\t\t\t\t\tch = 0;'], 'added_lines': ['\t\t\t\t\t\t\t\tgd_error(""gd2: EOF while reading\\n"");', '\t\t\t\t\t\t\t\tgdImageDestroy(im);', '\t\t\t\t\t\t\t\treturn NULL;', '\t\t\t\t\t\t\t\tgd_error(""gd2: EOF while reading\\n"");', '\t\t\t\t\t\t\t\tgdImageDestroy(im);', '\t\t\t\t\t\t\t\treturn NULL;']}",True,The gdImageCreateFromGd2Ctx function in gd_gd2.c in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to cause a denial of service (application crash) via a crafted image file.,5.5,MEDIUM,1,test,2016-08-16T16:23:36Z,1
CVE-2016-6828,['CWE-416'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"tcp: fix use after free in tcp_xmit_retransmit_queue()

When tcp_sendmsg() allocates a fresh and empty skb, it puts it at the
tail of the write queue using tcp_add_write_queue_tail()

Then it attempts to copy user data into this fresh skb.

If the copy fails, we undo the work and remove the fresh skb.

Unfortunately, this undo lacks the change done to tp->highest_sack and
we can leave a dangling pointer (to a freed skb)

Later, tcp_xmit_retransmit_queue() can dereference this pointer and
access freed memory. For regular kernels where memory is not unmapped,
this might cause SACK bugs because tcp_highest_sack_seq() is buggy,
returning garbage instead of tp->snd_nxt, but with various debug
features like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.

This bug was found by Marco Grassi thanks to syzkaller.

Fixes: 6859d49475d4 (""[TCP]: Abstract tp->highest_sack accessing & point to next skb"")
Reported-by: Marco Grassi <marco.gra@gmail.com>
Signed-off-by: Eric Dumazet <edumazet@google.com>
Cc: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
Cc: Yuchung Cheng <ycheng@google.com>
Cc: Neal Cardwell <ncardwell@google.com>
Acked-by: Neal Cardwell <ncardwell@google.com>
Reviewed-by: Cong Wang <xiyou.wangcong@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",bb1fceca22492109be12640d49f5ea5a544c6bb4,https://github.com/torvalds/linux/commit/bb1fceca22492109be12640d49f5ea5a544c6bb4,include/net/tcp.h,tcp_check_send_head,"static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked)
{
if (sk->sk_send_head == skb_unlinked)
sk->sk_send_head = NULL;
}","static inline void tcp_check_send_head(struct sock *VAR_0, struct sk_buff *VAR_1)
{
if (VAR_0->sk_send_head == VAR_1)
VAR_0->sk_send_head = NULL;
}",torvalds/linux/bb1fceca22492109be12640d49f5ea5a544c6bb4/tcp.h/vul/before/0.json,"static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked)
{
	if (sk->sk_send_head == skb_unlinked)
		sk->sk_send_head = NULL;
	if (tcp_sk(sk)->highest_sack == skb_unlinked)
		tcp_sk(sk)->highest_sack = NULL;
}","static inline void tcp_check_send_head(struct sock *VAR_0, struct sk_buff *VAR_1)
{
	if (VAR_0->sk_send_head == VAR_1)
		VAR_0->sk_send_head = NULL;
	if (tcp_sk(VAR_0)->highest_sack == VAR_1)
		tcp_sk(VAR_0)->highest_sack = NULL;
}",torvalds/linux/bb1fceca22492109be12640d49f5ea5a544c6bb4/tcp.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,4 +2,6 @@
 {
 	if (sk->sk_send_head == skb_unlinked)
 		sk->sk_send_head = NULL;
+	if (tcp_sk(sk)->highest_sack == skb_unlinked)
+		tcp_sk(sk)->highest_sack = NULL;
 }","{'deleted_lines': [], 'added_lines': ['\tif (tcp_sk(sk)->highest_sack == skb_unlinked)', '\t\ttcp_sk(sk)->highest_sack = NULL;']}",True,"The tcp_check_send_head function in include/net/tcp.h in the Linux kernel before 4.7.5 does not properly maintain certain SACK state after a failed data copy, which allows local users to cause a denial of service (tcp_xmit_retransmit_queue use-after-free and system crash) via a crafted SACK option.",5.5,MEDIUM,1,test,2016-08-17T12:56:26Z,1
CVE-2016-7162,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,GNOME/file-roller,"do not follow symlinks when deleting a folder recursively

[bug #698554]",f70be1f41688859ec8dbe266df35a1839ceb96c5,https://github.com/GNOME/file-roller/commit/f70be1f41688859ec8dbe266df35a1839ceb96c5,src/file-utils.c,_g_file_remove_directory,"gboolean
_g_file_remove_directory (GFile         *directory,
GCancellable  *cancellable,
GError       **error)
{
GFileEnumerator *enumerator;
GFileInfo       *info;
gboolean         error_occurred = FALSE;
if (directory == NULL)
return TRUE;
enumerator = g_file_enumerate_children (directory,
G_FILE_ATTRIBUTE_STANDARD_NAME "",""
G_FILE_ATTRIBUTE_STANDARD_TYPE,
0,
cancellable,
error);
while (! error_occurred && (info = g_file_enumerator_next_file (enumerator, cancellable, error)) != NULL) {
GFile *child;
child = g_file_get_child (directory, g_file_info_get_name (info));
switch (g_file_info_get_file_type (info)) {
case G_FILE_TYPE_DIRECTORY:
if (! _g_file_remove_directory (child, cancellable, error))
error_occurred = TRUE;
break;
default:
if (! g_file_delete (child, cancellable, error))
error_occurred = TRUE;
break;
}
g_object_unref (child);
g_object_unref (info);
}
if (! error_occurred && ! g_file_delete (directory, cancellable, error))
error_occurred = TRUE;
g_object_unref (enumerator);
return ! error_occurred;
}","gboolean
_g_file_remove_directory (GFile         *VAR_0,
GCancellable  *VAR_1,
GError       **VAR_2)
{
GFileEnumerator *VAR_3;
GFileInfo       *VAR_4;
gboolean         VAR_5 = FALSE;
if (VAR_0 == NULL)
return TRUE;
VAR_3 = g_file_enumerate_children (VAR_0,
VAR_6 "",""
VAR_7,
0,
VAR_1,
VAR_2);
while (! VAR_5 && (VAR_4 = g_file_enumerator_next_file (VAR_3, VAR_1, VAR_2)) != NULL) {
GFile *VAR_8;
VAR_8 = g_file_get_child (VAR_0, g_file_info_get_name (VAR_4));
switch (g_file_info_get_file_type (VAR_4)) {
case VAR_9:
if (! _g_file_remove_directory (VAR_8, VAR_1, VAR_2))
VAR_5 = TRUE;
break;
default:
if (! g_file_delete (VAR_8, VAR_1, VAR_2))
VAR_5 = TRUE;
break;
}
g_object_unref (VAR_8);
g_object_unref (VAR_4);
}
if (! VAR_5 && ! g_file_delete (VAR_0, VAR_1, VAR_2))
VAR_5 = TRUE;
g_object_unref (VAR_3);
return ! VAR_5;
}",GNOME/file-roller/f70be1f41688859ec8dbe266df35a1839ceb96c5/file-utils.c/vul/before/0.json,"gboolean
_g_file_remove_directory (GFile         *directory,
			  GCancellable  *cancellable,
			  GError       **error)
{
	GFileEnumerator *enumerator;
	GFileInfo       *info;
	gboolean         error_occurred = FALSE;

	if (directory == NULL)
		return TRUE;

	enumerator = g_file_enumerate_children (directory,
					        G_FILE_ATTRIBUTE_STANDARD_NAME "","" G_FILE_ATTRIBUTE_STANDARD_TYPE,
						G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
					        cancellable,
					        error);

	while (! error_occurred && (info = g_file_enumerator_next_file (enumerator, cancellable, error)) != NULL) {
		GFile *child;

		child = g_file_get_child (directory, g_file_info_get_name (info));
		switch (g_file_info_get_file_type (info)) {
		case G_FILE_TYPE_DIRECTORY:
			if (! _g_file_remove_directory (child, cancellable, error))
				error_occurred = TRUE;
			break;
		default:
			if (! g_file_delete (child, cancellable, error))
				error_occurred = TRUE;
			break;
		}

		g_object_unref (child);
		g_object_unref (info);
	}

	if (! error_occurred && ! g_file_delete (directory, cancellable, error))
 		error_occurred = TRUE;

	g_object_unref (enumerator);

	return ! error_occurred;
}","gboolean
_g_file_remove_directory (GFile         *VAR_0,
			  GCancellable  *VAR_1,
			  GError       **VAR_2)
{
	GFileEnumerator *VAR_3;
	GFileInfo       *VAR_4;
	gboolean         VAR_5 = FALSE;

	if (VAR_0 == NULL)
		return TRUE;

	VAR_3 = g_file_enumerate_children (VAR_0,
					        VAR_6 "","" G_FILE_ATTRIBUTE_STANDARD_TYPE,
						VAR_7,
					        VAR_1,
					        VAR_2);

	while (! VAR_5 && (VAR_4 = g_file_enumerator_next_file (VAR_3, VAR_1, VAR_2)) != NULL) {
		GFile *VAR_8;

		VAR_8 = g_file_get_child (VAR_0, g_file_info_get_name (VAR_4));
		switch (g_file_info_get_file_type (VAR_4)) {
		case VAR_9:
			if (! _g_file_remove_directory (VAR_8, VAR_1, VAR_2))
				VAR_5 = TRUE;
			break;
		default:
			if (! g_file_delete (VAR_8, VAR_1, VAR_2))
				VAR_5 = TRUE;
			break;
		}

		g_object_unref (VAR_8);
		g_object_unref (VAR_4);
	}

	if (! VAR_5 && ! g_file_delete (VAR_0, VAR_1, VAR_2))
 		VAR_5 = TRUE;

	g_object_unref (VAR_3);

	return ! VAR_5;
}",GNOME/file-roller/f70be1f41688859ec8dbe266df35a1839ceb96c5/file-utils.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,9 +11,8 @@
 		return TRUE;
 
 	enumerator = g_file_enumerate_children (directory,
-					        G_FILE_ATTRIBUTE_STANDARD_NAME "",""
-					        G_FILE_ATTRIBUTE_STANDARD_TYPE,
-					        0,
+					        G_FILE_ATTRIBUTE_STANDARD_NAME "","" G_FILE_ATTRIBUTE_STANDARD_TYPE,
+						G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
 					        cancellable,
 					        error);
 ","{'deleted_lines': ['\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_NAME "",""', '\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_TYPE,', '\t\t\t\t\t        0,'], 'added_lines': ['\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_NAME "","" G_FILE_ATTRIBUTE_STANDARD_TYPE,', '\t\t\t\t\t\tG_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,']}",True,The _g_file_remove_directory function in file-utils.c in File Roller 3.5.4 through 3.20.2 allows remote attackers to delete arbitrary files via a symlink attack on a folder in an archive.,7.5,HIGH,2,test,2016-08-17T13:41:35Z,1
CVE-2016-7157,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,qemu,"scsi: mptconfig: fix misuse of MPTSAS_CONFIG_PACK

These issues cause respectively a QEMU crash and a leak of 2 bytes of
stack.  They were discovered by VictorV of 360 Marvel Team.

Reported-by: Tom Victor <i-tangtianwen@360.cm>
Cc: qemu-stable@nongnu.org
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>",65a8e1f6413a0f6f79894da710b5d6d43361d27d,https://github.com/qemu/qemu/commit/65a8e1f6413a0f6f79894da710b5d6d43361d27d,hw/scsi/mptconfig.c,mptsas_config_manufacturing_1,"static
size_t mptsas_config_manufacturing_1(MPTSASState *s, uint8_t **data, int address)
{
return MPTSAS_CONFIG_PACK(1, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,
""s256"");
}","static
size_t mptsas_config_manufacturing_1(MPTSASState *VAR_0, uint8_t **VAR_1, int VAR_2)
{
return MPTSAS_CONFIG_PACK(1, VAR_3, 0x00,
""s256"");
}",qemu/65a8e1f6413a0f6f79894da710b5d6d43361d27d/mptconfig.c/vul/before/0.json,"static
size_t mptsas_config_manufacturing_1(MPTSASState *s, uint8_t **data, int address)
{
    /* VPD - all zeros */
    return MPTSAS_CONFIG_PACK(1, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,
                              ""*s256"");
}","static
size_t mptsas_config_manufacturing_1(MPTSASState *VAR_0, uint8_t **VAR_1, int VAR_2)
{
    /* COMMENT_0 */
    return MPTSAS_CONFIG_PACK(1, VAR_3, 0x00,
                              ""*s256"");
}",qemu/65a8e1f6413a0f6f79894da710b5d6d43361d27d/mptconfig.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,5 +3,5 @@
 {
     /* VPD - all zeros */
     return MPTSAS_CONFIG_PACK(1, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,
-                              ""s256"");
+                              ""*s256"");
 }","{'deleted_lines': ['                              ""s256"");'], 'added_lines': ['                              ""*s256"");']}",True,The (1) mptsas_config_manufacturing_1 and (2) mptsas_config_ioc_0 functions in hw/scsi/mptconfig.c in QEMU (aka Quick Emulator) allow local guest OS administrators to cause a denial of service (QEMU process crash) via vectors involving MPTSAS_CONFIG_PACK.,4.4,MEDIUM,1,test,2016-08-29T09:35:37Z,1
CVE-2016-7157,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,qemu,"scsi: mptconfig: fix misuse of MPTSAS_CONFIG_PACK

These issues cause respectively a QEMU crash and a leak of 2 bytes of
stack.  They were discovered by VictorV of 360 Marvel Team.

Reported-by: Tom Victor <i-tangtianwen@360.cm>
Cc: qemu-stable@nongnu.org
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>",65a8e1f6413a0f6f79894da710b5d6d43361d27d,https://github.com/qemu/qemu/commit/65a8e1f6413a0f6f79894da710b5d6d43361d27d,hw/scsi/mptconfig.c,mptsas_config_ioc_0,"static
size_t mptsas_config_ioc_0(MPTSASState *s, uint8_t **data, int address)
{
PCIDeviceClass *pcic = PCI_DEVICE_GET_CLASS(s);
return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_IOC, 0x01,
""*l*lwwb*b*b*blww"",
pcic->vendor_id, pcic->device_id, pcic->revision,
pcic->subsystem_vendor_id,
pcic->subsystem_id);
}","static
size_t mptsas_config_ioc_0(MPTSASState *VAR_0, uint8_t **VAR_1, int VAR_2)
{
PCIDeviceClass *VAR_3 = PCI_DEVICE_GET_CLASS(VAR_0);
return MPTSAS_CONFIG_PACK(0, VAR_4, 0x01,
""*l*lwwb*b*b*blww"",
VAR_3->vendor_id, VAR_3->device_id, VAR_3->revision,
VAR_3->subsystem_vendor_id,
VAR_3->subsystem_id);
}",qemu/65a8e1f6413a0f6f79894da710b5d6d43361d27d/mptconfig.c/vul/before/1.json,"static
size_t mptsas_config_ioc_0(MPTSASState *s, uint8_t **data, int address)
{
    PCIDeviceClass *pcic = PCI_DEVICE_GET_CLASS(s);

    return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_IOC, 0x01,
                              ""*l*lwwb*b*b*blww"",
                              pcic->vendor_id, pcic->device_id, pcic->revision,
                              pcic->class_id, pcic->subsystem_vendor_id,
                              pcic->subsystem_id);
}","static
size_t mptsas_config_ioc_0(MPTSASState *VAR_0, uint8_t **VAR_1, int VAR_2)
{
    PCIDeviceClass *VAR_3 = PCI_DEVICE_GET_CLASS(VAR_0);

    return MPTSAS_CONFIG_PACK(0, VAR_4, 0x01,
                              ""*l*lwwb*b*b*blww"",
                              VAR_3->vendor_id, VAR_3->device_id, VAR_3->revision,
                              VAR_3->class_id, VAR_3->subsystem_vendor_id,
                              VAR_3->subsystem_id);
}",qemu/65a8e1f6413a0f6f79894da710b5d6d43361d27d/mptconfig.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -6,6 +6,6 @@
     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_IOC, 0x01,
                               ""*l*lwwb*b*b*blww"",
                               pcic->vendor_id, pcic->device_id, pcic->revision,
-                              pcic->subsystem_vendor_id,
+                              pcic->class_id, pcic->subsystem_vendor_id,
                               pcic->subsystem_id);
 }","{'deleted_lines': ['                              pcic->subsystem_vendor_id,'], 'added_lines': ['                              pcic->class_id, pcic->subsystem_vendor_id,']}",True,The (1) mptsas_config_manufacturing_1 and (2) mptsas_config_ioc_0 functions in hw/scsi/mptconfig.c in QEMU (aka Quick Emulator) allow local guest OS administrators to cause a denial of service (QEMU process crash) via vectors involving MPTSAS_CONFIG_PACK.,4.4,MEDIUM,1,test,2016-08-29T09:35:37Z,1
CVE-2016-7156,['CWE-704'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,qemu,"scsi: pvscsi: limit loop to fetch SG list

In PVSCSI paravirtual SCSI bus, pvscsi_convert_sglist can take a very
long time or go into an infinite loop due to two different bugs:

1) the request descriptor data length is defined to be 64 bit. While
building SG list from a request descriptor, it gets truncated to 32bit
in routine 'pvscsi_convert_sglist'. This could lead to an infinite loop
situation large 'dataLen' values when data_length is cast to uint32_t and
chunk_size becomes always zero.  Fix this by removing the incorrect cast.

2) pvscsi_get_next_sg_elem can be called arbitrarily many times if the
element has a zero length.  Get out of the loop early when this happens,
by introducing an upper limit on the number of SG list elements.

Reported-by: Li Qiang <liqiang6-s@360.cn>
Signed-off-by: Prasad J Pandit <pjp@fedoraproject.org>
Message-Id: <1473108643-12983-1-git-send-email-ppandit@redhat.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>",49adc5d3f8c6bb75e55ebfeab109c5c37dea65e8,https://github.com/qemu/qemu/commit/49adc5d3f8c6bb75e55ebfeab109c5c37dea65e8,hw/scsi/vmw_pvscsi.c,pvscsi_convert_sglist,"static void
pvscsi_convert_sglist(PVSCSIRequest *r)
{
int chunk_size;
uint64_t data_length = r->req.dataLen;
PVSCSISGState sg = r->sg;
while (data_length) {
while (!sg.resid) {
pvscsi_get_next_sg_elem(&sg);
trace_pvscsi_convert_sglist(r->req.context, r->sg.dataAddr,
r->sg.resid);
}
assert(data_length > 0);
chunk_size = MIN((unsigned) data_length, sg.resid);
if (chunk_size) {
qemu_sglist_add(&r->sgl, sg.dataAddr, chunk_size);
}
sg.dataAddr += chunk_size;
data_length -= chunk_size;
sg.resid -= chunk_size;
}
}","static void
pvscsi_convert_sglist(PVSCSIRequest *VAR_0)
{
int VAR_1;
uint64_t VAR_2 = VAR_0->req.dataLen;
PVSCSISGState VAR_3 = VAR_0->sg;
while (VAR_2) {
while (!VAR_3.resid) {
pvscsi_get_next_sg_elem(&VAR_3);
trace_pvscsi_convert_sglist(VAR_0->req.context, VAR_0->sg.dataAddr,
VAR_0->sg.resid);
}
assert(VAR_2 > 0);
VAR_1 = MIN((unsigned) VAR_2, VAR_3.resid);
if (VAR_1) {
qemu_sglist_add(&VAR_0->sgl, VAR_3.dataAddr, VAR_1);
}
VAR_3.dataAddr += VAR_1;
VAR_2 -= VAR_1;
VAR_3.resid -= VAR_1;
}
}",qemu/49adc5d3f8c6bb75e55ebfeab109c5c37dea65e8/vmw_pvscsi.c/vul/before/0.json,"static void
pvscsi_convert_sglist(PVSCSIRequest *r)
{
    uint32_t chunk_size, elmcnt = 0;
    uint64_t data_length = r->req.dataLen;
    PVSCSISGState sg = r->sg;
    while (data_length && elmcnt < PVSCSI_MAX_SG_ELEM) {
        while (!sg.resid && elmcnt++ < PVSCSI_MAX_SG_ELEM) {
            pvscsi_get_next_sg_elem(&sg);
            trace_pvscsi_convert_sglist(r->req.context, r->sg.dataAddr,
                                        r->sg.resid);
        }
        chunk_size = MIN(data_length, sg.resid);
        if (chunk_size) {
            qemu_sglist_add(&r->sgl, sg.dataAddr, chunk_size);
        }

        sg.dataAddr += chunk_size;
        data_length -= chunk_size;
        sg.resid -= chunk_size;
    }
}","static void
pvscsi_convert_sglist(PVSCSIRequest *VAR_0)
{
    uint32_t VAR_1, VAR_2 = 0;
    uint64_t VAR_3 = VAR_0->req.dataLen;
    PVSCSISGState VAR_4 = VAR_0->sg;
    while (VAR_3 && VAR_2 < VAR_5) {
        while (!VAR_4.resid && VAR_2++ < VAR_5) {
            pvscsi_get_next_sg_elem(&VAR_4);
            trace_pvscsi_convert_sglist(VAR_0->req.context, VAR_0->sg.dataAddr,
                                        VAR_0->sg.resid);
        }
        VAR_1 = MIN(VAR_3, VAR_4.resid);
        if (VAR_1) {
            qemu_sglist_add(&VAR_0->sgl, VAR_4.dataAddr, VAR_1);
        }

        VAR_4.dataAddr += VAR_1;
        VAR_3 -= VAR_1;
        VAR_4.resid -= VAR_1;
    }
}",qemu/49adc5d3f8c6bb75e55ebfeab109c5c37dea65e8/vmw_pvscsi.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,17 +1,16 @@
 static void
 pvscsi_convert_sglist(PVSCSIRequest *r)
 {
-    int chunk_size;
+    uint32_t chunk_size, elmcnt = 0;
     uint64_t data_length = r->req.dataLen;
     PVSCSISGState sg = r->sg;
-    while (data_length) {
-        while (!sg.resid) {
+    while (data_length && elmcnt < PVSCSI_MAX_SG_ELEM) {
+        while (!sg.resid && elmcnt++ < PVSCSI_MAX_SG_ELEM) {
             pvscsi_get_next_sg_elem(&sg);
             trace_pvscsi_convert_sglist(r->req.context, r->sg.dataAddr,
                                         r->sg.resid);
         }
-        assert(data_length > 0);
-        chunk_size = MIN((unsigned) data_length, sg.resid);
+        chunk_size = MIN(data_length, sg.resid);
         if (chunk_size) {
             qemu_sglist_add(&r->sgl, sg.dataAddr, chunk_size);
         }","{'deleted_lines': ['    int chunk_size;', '    while (data_length) {', '        while (!sg.resid) {', '        assert(data_length > 0);', '        chunk_size = MIN((unsigned) data_length, sg.resid);'], 'added_lines': ['    uint32_t chunk_size, elmcnt = 0;', '    while (data_length && elmcnt < PVSCSI_MAX_SG_ELEM) {', '        while (!sg.resid && elmcnt++ < PVSCSI_MAX_SG_ELEM) {', '        chunk_size = MIN(data_length, sg.resid);']}",True,The pvscsi_convert_sglist function in hw/scsi/vmw_pvscsi.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (infinite loop and QEMU process crash) by leveraging an incorrect cast.,4.4,MEDIUM,1,test,2016-09-05T20:50:43Z,1
CVE-2016-7466,['CWE-772'],AV:L/AC:M/Au:N/C:N/I:N/A:P,0,qemu,"usb:xhci:fix memory leak in usb_xhci_exit

If the xhci uses msix, it doesn't free the corresponding
memory, thus leading a memory leak. This patch avoid this.

Signed-off-by: Li Qiang <liqiang6-s@360.cn>
Message-id: 57d7d2e0.d4301c0a.d13e9.9a55@mx.google.com
Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>",b53dd4495ced2432a0b652ea895e651d07336f7e,https://github.com/qemu/qemu/commit/b53dd4495ced2432a0b652ea895e651d07336f7e,hw/usb/hcd-xhci.c,usb_xhci_exit,"static void usb_xhci_exit(PCIDevice *dev)
{
int i;
XHCIState *xhci = XHCI(dev);
trace_usb_xhci_exit();
for (i = 0; i < xhci->numslots; i++) {
xhci_disable_slot(xhci, i + 1);
}
if (xhci->mfwrap_timer) {
timer_del(xhci->mfwrap_timer);
timer_free(xhci->mfwrap_timer);
xhci->mfwrap_timer = NULL;
}
memory_region_del_subregion(&xhci->mem, &xhci->mem_cap);
memory_region_del_subregion(&xhci->mem, &xhci->mem_oper);
memory_region_del_subregion(&xhci->mem, &xhci->mem_runtime);
memory_region_del_subregion(&xhci->mem, &xhci->mem_doorbell);
for (i = 0; i < xhci->numports; i++) {
XHCIPort *port = &xhci->ports[i];
memory_region_del_subregion(&xhci->mem, &port->mem);
}
if (dev->msix_table && dev->msix_pba
&& dev->msix_entry_used) {
memory_region_del_subregion(&xhci->mem, &dev->msix_table_mmio);
memory_region_del_subregion(&xhci->mem, &dev->msix_pba_mmio);
}
usb_bus_release(&xhci->bus);
}","static void usb_xhci_exit(PCIDevice *VAR_0)
{
int VAR_1;
XHCIState *VAR_2 = XHCI(VAR_0);
trace_usb_xhci_exit();
for (VAR_1 = 0; VAR_1 < VAR_2->numslots; VAR_1++) {
xhci_disable_slot(VAR_2, VAR_1 + 1);
}
if (VAR_2->mfwrap_timer) {
timer_del(VAR_2->mfwrap_timer);
timer_free(VAR_2->mfwrap_timer);
VAR_2->mfwrap_timer = NULL;
}
memory_region_del_subregion(&VAR_2->mem, &VAR_2->mem_cap);
memory_region_del_subregion(&VAR_2->mem, &VAR_2->mem_oper);
memory_region_del_subregion(&VAR_2->mem, &VAR_2->mem_runtime);
memory_region_del_subregion(&VAR_2->mem, &VAR_2->mem_doorbell);
for (VAR_1 = 0; VAR_1 < VAR_2->numports; VAR_1++) {
XHCIPort *VAR_3 = &VAR_2->ports[VAR_1];
memory_region_del_subregion(&VAR_2->mem, &VAR_3->mem);
}
if (VAR_0->msix_table && VAR_0->msix_pba
&& VAR_0->msix_entry_used) {
memory_region_del_subregion(&VAR_2->mem, &VAR_0->msix_table_mmio);
memory_region_del_subregion(&VAR_2->mem, &VAR_0->msix_pba_mmio);
}
usb_bus_release(&VAR_2->bus);
}",qemu/b53dd4495ced2432a0b652ea895e651d07336f7e/hcd-xhci.c/vul/before/0.json,"static void usb_xhci_exit(PCIDevice *dev)
{
    int i;
    XHCIState *xhci = XHCI(dev);

    trace_usb_xhci_exit();

    for (i = 0; i < xhci->numslots; i++) {
        xhci_disable_slot(xhci, i + 1);
    }

    if (xhci->mfwrap_timer) {
        timer_del(xhci->mfwrap_timer);
        timer_free(xhci->mfwrap_timer);
        xhci->mfwrap_timer = NULL;
    }

    memory_region_del_subregion(&xhci->mem, &xhci->mem_cap);
    memory_region_del_subregion(&xhci->mem, &xhci->mem_oper);
    memory_region_del_subregion(&xhci->mem, &xhci->mem_runtime);
    memory_region_del_subregion(&xhci->mem, &xhci->mem_doorbell);

    for (i = 0; i < xhci->numports; i++) {
        XHCIPort *port = &xhci->ports[i];
        memory_region_del_subregion(&xhci->mem, &port->mem);
    }

    /* destroy msix memory region */
    if (dev->msix_table && dev->msix_pba
        && dev->msix_entry_used) {
        msix_uninit(dev, &xhci->mem, &xhci->mem);
    }

    usb_bus_release(&xhci->bus);
}","static void usb_xhci_exit(PCIDevice *VAR_0)
{
    int VAR_1;
    XHCIState *VAR_2 = XHCI(VAR_0);

    trace_usb_xhci_exit();

    for (VAR_1 = 0; VAR_1 < VAR_2->numslots; VAR_1++) {
        xhci_disable_slot(VAR_2, VAR_1 + 1);
    }

    if (VAR_2->mfwrap_timer) {
        timer_del(VAR_2->mfwrap_timer);
        timer_free(VAR_2->mfwrap_timer);
        VAR_2->mfwrap_timer = NULL;
    }

    memory_region_del_subregion(&VAR_2->mem, &VAR_2->mem_cap);
    memory_region_del_subregion(&VAR_2->mem, &VAR_2->mem_oper);
    memory_region_del_subregion(&VAR_2->mem, &VAR_2->mem_runtime);
    memory_region_del_subregion(&VAR_2->mem, &VAR_2->mem_doorbell);

    for (VAR_1 = 0; VAR_1 < VAR_2->numports; VAR_1++) {
        XHCIPort *VAR_3 = &VAR_2->ports[VAR_1];
        memory_region_del_subregion(&VAR_2->mem, &VAR_3->mem);
    }

    /* COMMENT_0 */
    if (VAR_0->msix_table && VAR_0->msix_pba
        && VAR_0->msix_entry_used) {
        msix_uninit(VAR_0, &VAR_2->mem, &VAR_2->mem);
    }

    usb_bus_release(&VAR_2->bus);
}",qemu/b53dd4495ced2432a0b652ea895e651d07336f7e/hcd-xhci.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -28,8 +28,7 @@
     /* destroy msix memory region */
     if (dev->msix_table && dev->msix_pba
         && dev->msix_entry_used) {
-        memory_region_del_subregion(&xhci->mem, &dev->msix_table_mmio);
-        memory_region_del_subregion(&xhci->mem, &dev->msix_pba_mmio);
+        msix_uninit(dev, &xhci->mem, &xhci->mem);
     }
 
     usb_bus_release(&xhci->bus);","{'deleted_lines': ['        memory_region_del_subregion(&xhci->mem, &dev->msix_table_mmio);', '        memory_region_del_subregion(&xhci->mem, &dev->msix_pba_mmio);'], 'added_lines': ['        msix_uninit(dev, &xhci->mem, &xhci->mem);']}",True,"Memory leak in the usb_xhci_exit function in hw/usb/hcd-xhci.c in QEMU (aka Quick Emulator), when the xhci uses msix, allows local guest OS administrators to cause a denial of service (memory consumption and possibly QEMU process crash) by repeatedly unplugging a USB device.",6.0,MEDIUM,1,test,2016-09-13T10:20:03Z,1
CVE-2016-7995,['CWE-772'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,qemu,"usb: ehci: fix memory leak in ehci_process_itd

While processing isochronous transfer descriptors(iTD), if the page
select(PG) field value is out of bands it will return. In this
situation the ehci's sg list is not freed thus leading to a memory
leak issue. This patch avoid this.

Signed-off-by: Li Qiang <liqiang6-s@360.cn>
Reviewed-by: Thomas Huth <thuth@redhat.com>
Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>",b16c129daf0fed91febbb88de23dae8271c8898a,https://github.com/qemu/qemu/commit/b16c129daf0fed91febbb88de23dae8271c8898a,hw/usb/hcd-ehci.c,ehci_process_itd,"static int ehci_process_itd(EHCIState *ehci,
EHCIitd *itd,
uint32_t addr)
{
USBDevice *dev;
USBEndpoint *ep;
uint32_t i, len, pid, dir, devaddr, endp;
uint32_t pg, off, ptr1, ptr2, max, mult;
ehci->periodic_sched_active = PERIODIC_ACTIVE;
dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);
devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);
endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);
max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);
mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);
for(i = 0; i < 8; i++) {
if (itd->transact[i] & ITD_XACT_ACTIVE) {
pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);
off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;
len  = get_field(itd->transact[i], ITD_XACT_LENGTH);
if (len > max * mult) {
len = max * mult;
}
if (len > BUFF_SIZE || pg > 6) {
return -1;
}
ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);
qemu_sglist_init(&ehci->isgl, ehci->device, 2, ehci->as);
if (off + len > 4096) {
if (pg == 6) {
return -1;  
}
ptr2 = (itd->bufptr[pg + 1] & ITD_BUFPTR_MASK);
uint32_t len2 = off + len - 4096;
uint32_t len1 = len - len2;
qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);
qemu_sglist_add(&ehci->isgl, ptr2, len2);
} else {
qemu_sglist_add(&ehci->isgl, ptr1 + off, len);
}
pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;
dev = ehci_find_device(ehci, devaddr);
ep = usb_ep_get(dev, pid, endp);
if (ep && ep->type == USB_ENDPOINT_XFER_ISOC) {
usb_packet_setup(&ehci->ipacket, pid, ep, 0, addr, false,
(itd->transact[i] & ITD_XACT_IOC) != 0);
usb_packet_map(&ehci->ipacket, &ehci->isgl);
usb_handle_packet(dev, &ehci->ipacket);
usb_packet_unmap(&ehci->ipacket, &ehci->isgl);
} else {
DPRINTF(""ISOCH: attempt to addess non-iso endpoint\n"");
ehci->ipacket.status = USB_RET_NAK;
ehci->ipacket.actual_length = 0;
}
qemu_sglist_destroy(&ehci->isgl);
switch (ehci->ipacket.status) {
case USB_RET_SUCCESS:
break;
default:
fprintf(stderr, ""Unexpected iso usb result: %d\n"",
ehci->ipacket.status);
case USB_RET_IOERROR:
case USB_RET_NODEV:
if (dir) {
itd->transact[i] |= ITD_XACT_XACTERR;
ehci_raise_irq(ehci, USBSTS_ERRINT);
}
break;
case USB_RET_BABBLE:
itd->transact[i] |= ITD_XACT_BABBLE;
ehci_raise_irq(ehci, USBSTS_ERRINT);
break;
case USB_RET_NAK:
ehci->ipacket.actual_length = 0;
break;
}
if (!dir) {
set_field(&itd->transact[i], len - ehci->ipacket.actual_length,
ITD_XACT_LENGTH); 
} else {
set_field(&itd->transact[i], ehci->ipacket.actual_length,
ITD_XACT_LENGTH); 
}
if (itd->transact[i] & ITD_XACT_IOC) {
ehci_raise_irq(ehci, USBSTS_INT);
}
itd->transact[i] &= ~ITD_XACT_ACTIVE;
}
}
return 0;
}","static int ehci_process_itd(EHCIState *VAR_0,
EHCIitd *VAR_1,
uint32_t VAR_2)
{
USBDevice *VAR_3;
USBEndpoint *VAR_4;
uint32_t VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10;
uint32_t VAR_11, VAR_12, VAR_13, VAR_14, VAR_15, VAR_16;
VAR_0->periodic_sched_active = VAR_17;
VAR_8 =(VAR_1->bufptr[1] & VAR_18);
VAR_9 = get_field(VAR_1->bufptr[0], VAR_19);
VAR_10 = get_field(VAR_1->bufptr[0], VAR_20);
VAR_15 = get_field(VAR_1->bufptr[1], VAR_21);
VAR_16 = get_field(VAR_1->bufptr[2], VAR_22);
for(VAR_5 = 0; VAR_5 < 8; VAR_5++) {
if (VAR_1->transact[VAR_5] & VAR_23) {
VAR_11   = get_field(VAR_1->transact[VAR_5], VAR_24);
VAR_12  = VAR_1->transact[VAR_5] & VAR_25;
VAR_6  = get_field(VAR_1->transact[VAR_5], VAR_26);
if (VAR_6 > VAR_15 * VAR_16) {
VAR_6 = VAR_15 * VAR_16;
}
if (VAR_6 > VAR_27 || VAR_11 > 6) {
return -1;
}
VAR_13 = (VAR_1->bufptr[VAR_11] & VAR_28);
qemu_sglist_init(&VAR_0->isgl, VAR_0->device, 2, VAR_0->as);
if (VAR_12 + VAR_6 > 4096) {
if (VAR_11 == 6) {
return -1;  
}
VAR_14 = (VAR_1->bufptr[VAR_11 + 1] & VAR_28);
uint32_t VAR_29 = VAR_12 + VAR_6 - 4096;
uint32_t VAR_30 = VAR_6 - VAR_29;
qemu_sglist_add(&VAR_0->isgl, VAR_13 + VAR_12, VAR_30);
qemu_sglist_add(&VAR_0->isgl, VAR_14, VAR_29);
} else {
qemu_sglist_add(&VAR_0->isgl, VAR_13 + VAR_12, VAR_6);
}
VAR_7 = VAR_8 ? VAR_31 : VAR_32;
VAR_3 = ehci_find_device(VAR_0, VAR_9);
VAR_4 = usb_ep_get(VAR_3, VAR_7, VAR_10);
if (VAR_4 && VAR_4->type == VAR_33) {
usb_packet_setup(&VAR_0->ipacket, VAR_7, VAR_4, 0, VAR_2, false,
(VAR_1->transact[VAR_5] & VAR_34) != 0);
usb_packet_map(&VAR_0->ipacket, &VAR_0->isgl);
usb_handle_packet(VAR_3, &VAR_0->ipacket);
usb_packet_unmap(&VAR_0->ipacket, &VAR_0->isgl);
} else {
DPRINTF(""ISOCH: attempt to addess non-iso endpoint\n"");
VAR_0->ipacket.status = VAR_35;
VAR_0->ipacket.actual_length = 0;
}
qemu_sglist_destroy(&VAR_0->isgl);
switch (VAR_0->ipacket.status) {
case VAR_36:
break;
default:
fprintf(VAR_37, ""Unexpected iso usb result: %d\n"",
VAR_0->ipacket.status);
case VAR_38:
case VAR_39:
if (VAR_8) {
VAR_1->transact[VAR_5] |= VAR_40;
ehci_raise_irq(VAR_0, VAR_41);
}
break;
case VAR_42:
VAR_1->transact[VAR_5] |= VAR_43;
ehci_raise_irq(VAR_0, VAR_41);
break;
case VAR_35:
VAR_0->ipacket.actual_length = 0;
break;
}
if (!VAR_8) {
set_field(&VAR_1->transact[VAR_5], VAR_6 - VAR_0->ipacket.actual_length,
VAR_26); 
} else {
set_field(&VAR_1->transact[VAR_5], VAR_0->ipacket.actual_length,
VAR_26); 
}
if (VAR_1->transact[VAR_5] & VAR_34) {
ehci_raise_irq(VAR_0, VAR_44);
}
VAR_1->transact[VAR_5] &= ~VAR_23;
}
}
return 0;
}",qemu/b16c129daf0fed91febbb88de23dae8271c8898a/hcd-ehci.c/vul/before/0.json,"static int ehci_process_itd(EHCIState *ehci,
                            EHCIitd *itd,
                            uint32_t addr)
{
    USBDevice *dev;
    USBEndpoint *ep;
    uint32_t i, len, pid, dir, devaddr, endp;
    uint32_t pg, off, ptr1, ptr2, max, mult;

    ehci->periodic_sched_active = PERIODIC_ACTIVE;

    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);
    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);
    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);
    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);
    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);

    for(i = 0; i < 8; i++) {
        if (itd->transact[i] & ITD_XACT_ACTIVE) {
            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);
            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;
            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);

            if (len > max * mult) {
                len = max * mult;
            }
            if (len > BUFF_SIZE || pg > 6) {
                return -1;
            }

            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);
            qemu_sglist_init(&ehci->isgl, ehci->device, 2, ehci->as);
            if (off + len > 4096) {
                /* transfer crosses page border */
                if (pg == 6) {
                    qemu_sglist_destroy(&ehci->isgl);
                    return -1;  /* avoid page pg + 1 */
                }
                ptr2 = (itd->bufptr[pg + 1] & ITD_BUFPTR_MASK);
                uint32_t len2 = off + len - 4096;
                uint32_t len1 = len - len2;
                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);
                qemu_sglist_add(&ehci->isgl, ptr2, len2);
            } else {
                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);
            }

            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;

            dev = ehci_find_device(ehci, devaddr);
            ep = usb_ep_get(dev, pid, endp);
            if (ep && ep->type == USB_ENDPOINT_XFER_ISOC) {
                usb_packet_setup(&ehci->ipacket, pid, ep, 0, addr, false,
                                 (itd->transact[i] & ITD_XACT_IOC) != 0);
                usb_packet_map(&ehci->ipacket, &ehci->isgl);
                usb_handle_packet(dev, &ehci->ipacket);
                usb_packet_unmap(&ehci->ipacket, &ehci->isgl);
            } else {
                DPRINTF(""ISOCH: attempt to addess non-iso endpoint\n"");
                ehci->ipacket.status = USB_RET_NAK;
                ehci->ipacket.actual_length = 0;
            }
            qemu_sglist_destroy(&ehci->isgl);

            switch (ehci->ipacket.status) {
            case USB_RET_SUCCESS:
                break;
            default:
                fprintf(stderr, ""Unexpected iso usb result: %d\n"",
                        ehci->ipacket.status);
                /* Fall through */
            case USB_RET_IOERROR:
            case USB_RET_NODEV:
                /* 3.3.2: XACTERR is only allowed on IN transactions */
                if (dir) {
                    itd->transact[i] |= ITD_XACT_XACTERR;
                    ehci_raise_irq(ehci, USBSTS_ERRINT);
                }
                break;
            case USB_RET_BABBLE:
                itd->transact[i] |= ITD_XACT_BABBLE;
                ehci_raise_irq(ehci, USBSTS_ERRINT);
                break;
            case USB_RET_NAK:
                /* no data for us, so do a zero-length transfer */
                ehci->ipacket.actual_length = 0;
                break;
            }
            if (!dir) {
                set_field(&itd->transact[i], len - ehci->ipacket.actual_length,
                          ITD_XACT_LENGTH); /* OUT */
            } else {
                set_field(&itd->transact[i], ehci->ipacket.actual_length,
                          ITD_XACT_LENGTH); /* IN */
            }
            if (itd->transact[i] & ITD_XACT_IOC) {
                ehci_raise_irq(ehci, USBSTS_INT);
            }
            itd->transact[i] &= ~ITD_XACT_ACTIVE;
        }
    }
    return 0;
}","static int ehci_process_itd(EHCIState *VAR_0,
                            EHCIitd *VAR_1,
                            uint32_t VAR_2)
{
    USBDevice *VAR_3;
    USBEndpoint *VAR_4;
    uint32_t VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10;
    uint32_t VAR_11, VAR_12, VAR_13, VAR_14, VAR_15, VAR_16;

    VAR_0->periodic_sched_active = VAR_17;

    VAR_8 =(VAR_1->bufptr[1] & VAR_18);
    VAR_9 = get_field(VAR_1->bufptr[0], VAR_19);
    VAR_10 = get_field(VAR_1->bufptr[0], VAR_20);
    VAR_15 = get_field(VAR_1->bufptr[1], VAR_21);
    VAR_16 = get_field(VAR_1->bufptr[2], VAR_22);

    for(VAR_5 = 0; VAR_5 < 8; VAR_5++) {
        if (VAR_1->transact[VAR_5] & VAR_23) {
            VAR_11   = get_field(VAR_1->transact[VAR_5], VAR_24);
            VAR_12  = VAR_1->transact[VAR_5] & VAR_25;
            VAR_6  = get_field(VAR_1->transact[VAR_5], VAR_26);

            if (VAR_6 > VAR_15 * VAR_16) {
                VAR_6 = VAR_15 * VAR_16;
            }
            if (VAR_6 > VAR_27 || VAR_11 > 6) {
                return -1;
            }

            VAR_13 = (VAR_1->bufptr[VAR_11] & VAR_28);
            qemu_sglist_init(&VAR_0->isgl, VAR_0->device, 2, VAR_0->as);
            if (VAR_12 + VAR_6 > 4096) {
                /* COMMENT_0 */
                if (VAR_11 == 6) {
                    qemu_sglist_destroy(&VAR_0->isgl);
                    return -1;  /* COMMENT_1 */
                }
                VAR_14 = (VAR_1->bufptr[VAR_11 + 1] & VAR_28);
                uint32_t VAR_29 = VAR_12 + VAR_6 - 4096;
                uint32_t VAR_30 = VAR_6 - VAR_29;
                qemu_sglist_add(&VAR_0->isgl, VAR_13 + VAR_12, VAR_30);
                qemu_sglist_add(&VAR_0->isgl, VAR_14, VAR_29);
            } else {
                qemu_sglist_add(&VAR_0->isgl, VAR_13 + VAR_12, VAR_6);
            }

            VAR_7 = VAR_8 ? VAR_31 : VAR_32;

            VAR_3 = ehci_find_device(VAR_0, VAR_9);
            VAR_4 = usb_ep_get(VAR_3, VAR_7, VAR_10);
            if (VAR_4 && VAR_4->type == VAR_33) {
                usb_packet_setup(&VAR_0->ipacket, VAR_7, VAR_4, 0, VAR_2, false,
                                 (VAR_1->transact[VAR_5] & VAR_34) != 0);
                usb_packet_map(&VAR_0->ipacket, &VAR_0->isgl);
                usb_handle_packet(VAR_3, &VAR_0->ipacket);
                usb_packet_unmap(&VAR_0->ipacket, &VAR_0->isgl);
            } else {
                DPRINTF(""ISOCH: attempt to addess non-iso endpoint\n"");
                VAR_0->ipacket.status = VAR_35;
                VAR_0->ipacket.actual_length = 0;
            }
            qemu_sglist_destroy(&VAR_0->isgl);

            switch (VAR_0->ipacket.status) {
            case VAR_36:
                break;
            default:
                fprintf(VAR_37, ""Unexpected iso usb result: %d\n"",
                        VAR_0->ipacket.status);
                /* COMMENT_2 */
            case VAR_38:
            case VAR_39:
                /* COMMENT_3 */
                if (VAR_8) {
                    VAR_1->transact[VAR_5] |= VAR_40;
                    ehci_raise_irq(VAR_0, VAR_41);
                }
                break;
            case VAR_42:
                VAR_1->transact[VAR_5] |= VAR_43;
                ehci_raise_irq(VAR_0, VAR_41);
                break;
            case VAR_35:
                /* COMMENT_4 */
                VAR_0->ipacket.actual_length = 0;
                break;
            }
            if (!VAR_8) {
                set_field(&VAR_1->transact[VAR_5], VAR_6 - VAR_0->ipacket.actual_length,
                          VAR_26); /* COMMENT_5 */
            } else {
                set_field(&VAR_1->transact[VAR_5], VAR_0->ipacket.actual_length,
                          VAR_26); /* COMMENT_6 */
            }
            if (VAR_1->transact[VAR_5] & VAR_34) {
                ehci_raise_irq(VAR_0, VAR_44);
            }
            VAR_1->transact[VAR_5] &= ~VAR_23;
        }
    }
    return 0;
}",qemu/b16c129daf0fed91febbb88de23dae8271c8898a/hcd-ehci.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -33,6 +33,7 @@
             if (off + len > 4096) {
                 /* transfer crosses page border */
                 if (pg == 6) {
+                    qemu_sglist_destroy(&ehci->isgl);
                     return -1;  /* avoid page pg + 1 */
                 }
                 ptr2 = (itd->bufptr[pg + 1] & ITD_BUFPTR_MASK);","{'deleted_lines': [], 'added_lines': ['                    qemu_sglist_destroy(&ehci->isgl);']}",True,Memory leak in the ehci_process_itd function in hw/usb/hcd-ehci.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (memory consumption) via a large number of crafted buffer page select (PG) indexes.,6.0,MEDIUM,1,test,2016-09-19T02:48:35Z,1
CVE-2016-7906,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/281,90406972f108c4da71f998601b06abdc2ac6f06e,https://github.com/ImageMagick/ImageMagick/commit/90406972f108c4da71f998601b06abdc2ac6f06e,MagickCore/attribute.c,SetImageType,"MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type,
ExceptionInfo *exception)
{
const char
*artifact;
ImageInfo
*image_info;
MagickBooleanType
status;
QuantizeInfo
*quantize_info;
assert(image != (Image *) NULL);
if (image->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
assert(image->signature == MagickCoreSignature);
status=MagickTrue;
image_info=AcquireImageInfo();
image_info->dither=image->dither;
artifact=GetImageArtifact(image,""dither"");
if (artifact != (const char *) NULL)
(void) SetImageOption(image_info,""dither"",artifact);
switch (type)
{
case BilevelType:
{
if (SetImageMonochrome(image,exception) == MagickFalse)
{
status=TransformImageColorspace(image,GRAYColorspace,exception);
(void) NormalizeImage(image,exception);
quantize_info=AcquireQuantizeInfo(image_info);
quantize_info->number_colors=2;
quantize_info->colorspace=GRAYColorspace;
status=QuantizeImage(quantize_info,image,exception);
quantize_info=DestroyQuantizeInfo(quantize_info);
}
image->colors=2;
image->alpha_trait=UndefinedPixelTrait;
break;
}
case GrayscaleType:
{
if (SetImageGray(image,exception) == MagickFalse)
status=TransformImageColorspace(image,GRAYColorspace,exception);
image->alpha_trait=UndefinedPixelTrait;
break;
}
case GrayscaleAlphaType:
{
if (SetImageGray(image,exception) == MagickFalse)
status=TransformImageColorspace(image,GRAYColorspace,exception);
if (image->alpha_trait == UndefinedPixelTrait)
(void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
break;
}
case PaletteType:
{
if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
status=TransformImageColorspace(image,sRGBColorspace,exception);
if ((image->storage_class == DirectClass) || (image->colors > 256))
{
quantize_info=AcquireQuantizeInfo(image_info);
quantize_info->number_colors=256;
status=QuantizeImage(quantize_info,image,exception);
quantize_info=DestroyQuantizeInfo(quantize_info);
}
image->alpha_trait=UndefinedPixelTrait;
break;
}
case PaletteBilevelAlphaType:
{
ChannelType
channel_mask;
if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
status=TransformImageColorspace(image,sRGBColorspace,exception);
if (image->alpha_trait == UndefinedPixelTrait)
(void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
channel_mask=SetImageChannelMask(image,AlphaChannel);
(void) BilevelImage(image,(double) QuantumRange/2.0,exception);
(void) SetImageChannelMask(image,channel_mask);
quantize_info=AcquireQuantizeInfo(image_info);
status=QuantizeImage(quantize_info,image,exception);
quantize_info=DestroyQuantizeInfo(quantize_info);
break;
}
case PaletteAlphaType:
{
if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
status=TransformImageColorspace(image,sRGBColorspace,exception);
if (image->alpha_trait == UndefinedPixelTrait)
(void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
quantize_info=AcquireQuantizeInfo(image_info);
quantize_info->colorspace=TransparentColorspace;
status=QuantizeImage(quantize_info,image,exception);
quantize_info=DestroyQuantizeInfo(quantize_info);
break;
}
case TrueColorType:
{
if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
status=TransformImageColorspace(image,sRGBColorspace,exception);
if (image->storage_class != DirectClass)
status=SetImageStorageClass(image,DirectClass,exception);
image->alpha_trait=UndefinedPixelTrait;
break;
}
case TrueColorAlphaType:
{
if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
status=TransformImageColorspace(image,sRGBColorspace,exception);
if (image->storage_class != DirectClass)
status=SetImageStorageClass(image,DirectClass,exception);
if (image->alpha_trait == UndefinedPixelTrait)
(void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
break;
}
case ColorSeparationType:
{
if (image->colorspace != CMYKColorspace)
{
if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
status=TransformImageColorspace(image,sRGBColorspace,exception);
status=TransformImageColorspace(image,CMYKColorspace,exception);
}
if (image->storage_class != DirectClass)
status=SetImageStorageClass(image,DirectClass,exception);
image->alpha_trait=UndefinedPixelTrait;
break;
}
case ColorSeparationAlphaType:
{
if (image->colorspace != CMYKColorspace)
{
if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
status=TransformImageColorspace(image,sRGBColorspace,exception);
status=TransformImageColorspace(image,CMYKColorspace,exception);
}
if (image->storage_class != DirectClass)
status=SetImageStorageClass(image,DirectClass,exception);
if (image->alpha_trait == UndefinedPixelTrait)
status=SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
break;
}
case OptimizeType:
case UndefinedType:
break;
}
image_info=DestroyImageInfo(image_info);
if (status == MagickFalse)
return(status);
image->type=type;
return(MagickTrue);
}","MagickExport VAR_0 SetImageType(Image *VAR_1,const ImageType VAR_2,
ExceptionInfo *VAR_3)
{
const char
*VAR_4;
ImageInfo
*VAR_5;
MagickBooleanType
VAR_6;
QuantizeInfo
*VAR_7;
assert(VAR_1 != (Image *) NULL);
if (VAR_1->debug != VAR_8)
(void) LogMagickEvent(VAR_9,GetMagickModule(),""..."");
assert(VAR_1->signature == VAR_10);
VAR_6=VAR_11;
VAR_5=AcquireImageInfo();
VAR_5->dither=VAR_1->dither;
VAR_4=GetImageArtifact(VAR_1,""dither"");
if (VAR_4 != (const char *) NULL)
(void) SetImageOption(VAR_5,""dither"",VAR_4);
switch (VAR_2)
{
case VAR_12:
{
if (SetImageMonochrome(VAR_1,VAR_3) == VAR_8)
{
VAR_6=TransformImageColorspace(VAR_1,VAR_13,VAR_3);
(void) NormalizeImage(VAR_1,VAR_3);
VAR_7=AcquireQuantizeInfo(VAR_5);
VAR_7->number_colors=2;
VAR_7->colorspace=VAR_13;
VAR_6=QuantizeImage(VAR_7,VAR_1,VAR_3);
VAR_7=DestroyQuantizeInfo(VAR_7);
}
VAR_1->colors=2;
VAR_1->alpha_trait=VAR_14;
break;
}
case VAR_15:
{
if (SetImageGray(VAR_1,VAR_3) == VAR_8)
VAR_6=TransformImageColorspace(VAR_1,VAR_13,VAR_3);
VAR_1->alpha_trait=VAR_14;
break;
}
case VAR_16:
{
if (SetImageGray(VAR_1,VAR_3) == VAR_8)
VAR_6=TransformImageColorspace(VAR_1,VAR_13,VAR_3);
if (VAR_1->alpha_trait == VAR_14)
(void) SetImageAlphaChannel(VAR_1,VAR_17,VAR_3);
break;
}
case VAR_18:
{
if (IssRGBCompatibleColorspace(VAR_1->colorspace) == VAR_8)
VAR_6=TransformImageColorspace(VAR_1,VAR_19,VAR_3);
if ((VAR_1->storage_class == VAR_20) || (VAR_1->colors > 256))
{
VAR_7=AcquireQuantizeInfo(VAR_5);
VAR_7->number_colors=256;
VAR_6=QuantizeImage(VAR_7,VAR_1,VAR_3);
VAR_7=DestroyQuantizeInfo(VAR_7);
}
VAR_1->alpha_trait=VAR_14;
break;
}
case VAR_21:
{
ChannelType
VAR_22;
if (IssRGBCompatibleColorspace(VAR_1->colorspace) == VAR_8)
VAR_6=TransformImageColorspace(VAR_1,VAR_19,VAR_3);
if (VAR_1->alpha_trait == VAR_14)
(void) SetImageAlphaChannel(VAR_1,VAR_17,VAR_3);
VAR_22=SetImageChannelMask(VAR_1,VAR_23);
(void) BilevelImage(VAR_1,(double) VAR_24/2.0,VAR_3);
(void) SetImageChannelMask(VAR_1,VAR_22);
VAR_7=AcquireQuantizeInfo(VAR_5);
VAR_6=QuantizeImage(VAR_7,VAR_1,VAR_3);
VAR_7=DestroyQuantizeInfo(VAR_7);
break;
}
case VAR_25:
{
if (IssRGBCompatibleColorspace(VAR_1->colorspace) == VAR_8)
VAR_6=TransformImageColorspace(VAR_1,VAR_19,VAR_3);
if (VAR_1->alpha_trait == VAR_14)
(void) SetImageAlphaChannel(VAR_1,VAR_17,VAR_3);
VAR_7=AcquireQuantizeInfo(VAR_5);
VAR_7->colorspace=VAR_26;
VAR_6=QuantizeImage(VAR_7,VAR_1,VAR_3);
VAR_7=DestroyQuantizeInfo(VAR_7);
break;
}
case VAR_27:
{
if (IssRGBCompatibleColorspace(VAR_1->colorspace) == VAR_8)
VAR_6=TransformImageColorspace(VAR_1,VAR_19,VAR_3);
if (VAR_1->storage_class != VAR_20)
VAR_6=SetImageStorageClass(VAR_1,VAR_20,VAR_3);
VAR_1->alpha_trait=VAR_14;
break;
}
case VAR_28:
{
if (IssRGBCompatibleColorspace(VAR_1->colorspace) == VAR_8)
VAR_6=TransformImageColorspace(VAR_1,VAR_19,VAR_3);
if (VAR_1->storage_class != VAR_20)
VAR_6=SetImageStorageClass(VAR_1,VAR_20,VAR_3);
if (VAR_1->alpha_trait == VAR_14)
(void) SetImageAlphaChannel(VAR_1,VAR_17,VAR_3);
break;
}
case VAR_29:
{
if (VAR_1->colorspace != VAR_30)
{
if (IssRGBCompatibleColorspace(VAR_1->colorspace) == VAR_8)
VAR_6=TransformImageColorspace(VAR_1,VAR_19,VAR_3);
VAR_6=TransformImageColorspace(VAR_1,VAR_30,VAR_3);
}
if (VAR_1->storage_class != VAR_20)
VAR_6=SetImageStorageClass(VAR_1,VAR_20,VAR_3);
VAR_1->alpha_trait=VAR_14;
break;
}
case VAR_31:
{
if (VAR_1->colorspace != VAR_30)
{
if (IssRGBCompatibleColorspace(VAR_1->colorspace) == VAR_8)
VAR_6=TransformImageColorspace(VAR_1,VAR_19,VAR_3);
VAR_6=TransformImageColorspace(VAR_1,VAR_30,VAR_3);
}
if (VAR_1->storage_class != VAR_20)
VAR_6=SetImageStorageClass(VAR_1,VAR_20,VAR_3);
if (VAR_1->alpha_trait == VAR_14)
VAR_6=SetImageAlphaChannel(VAR_1,VAR_17,VAR_3);
break;
}
case VAR_32:
case VAR_33:
break;
}
VAR_5=DestroyImageInfo(VAR_5);
if (VAR_6 == VAR_8)
return(VAR_6);
VAR_1->type=VAR_2;
return(VAR_11);
}",,"MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type,
  ExceptionInfo *exception)
{
  const char
    *artifact;

  ImageInfo
    *image_info;

  MagickBooleanType
    status;

  QuantizeInfo
    *quantize_info;

  assert(image != (Image *) NULL);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->signature == MagickCoreSignature);
  status=MagickTrue;
  image_info=AcquireImageInfo();
  image_info->dither=image->dither;
  artifact=GetImageArtifact(image,""dither"");
  if (artifact != (const char *) NULL)
    (void) SetImageOption(image_info,""dither"",artifact);
  switch (type)
  {
    case BilevelType:
    {
      if (SetImageMonochrome(image,exception) == MagickFalse)
        {
          status=TransformImageColorspace(image,GRAYColorspace,exception);
          (void) NormalizeImage(image,exception);
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=2;
          quantize_info->colorspace=GRAYColorspace;
          status=QuantizeImage(quantize_info,image,exception);
          quantize_info=DestroyQuantizeInfo(quantize_info);
        }
      status=AcquireImageColormap(image,2,exception);
      image->alpha_trait=UndefinedPixelTrait;
      break;
    }
    case GrayscaleType:
    {
      if (SetImageGray(image,exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace,exception);
      image->alpha_trait=UndefinedPixelTrait;
      break;
    }
    case GrayscaleAlphaType:
    {
      if (SetImageGray(image,exception) == MagickFalse)
        status=TransformImageColorspace(image,GRAYColorspace,exception);
      if (image->alpha_trait == UndefinedPixelTrait)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
      break;
    }
    case PaletteType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace,exception);
      if ((image->storage_class == DirectClass) || (image->colors > 256))
        {
          quantize_info=AcquireQuantizeInfo(image_info);
          quantize_info->number_colors=256;
          status=QuantizeImage(quantize_info,image,exception);
          quantize_info=DestroyQuantizeInfo(quantize_info);
        }
      image->alpha_trait=UndefinedPixelTrait;
      break;
    }
    case PaletteBilevelAlphaType:
    {
      ChannelType
        channel_mask;

      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace,exception);
      if (image->alpha_trait == UndefinedPixelTrait)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
      channel_mask=SetImageChannelMask(image,AlphaChannel);
      (void) BilevelImage(image,(double) QuantumRange/2.0,exception);
      (void) SetImageChannelMask(image,channel_mask);
      quantize_info=AcquireQuantizeInfo(image_info);
      status=QuantizeImage(quantize_info,image,exception);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case PaletteAlphaType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace,exception);
      if (image->alpha_trait == UndefinedPixelTrait)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
      quantize_info=AcquireQuantizeInfo(image_info);
      quantize_info->colorspace=TransparentColorspace;
      status=QuantizeImage(quantize_info,image,exception);
      quantize_info=DestroyQuantizeInfo(quantize_info);
      break;
    }
    case TrueColorType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace,exception);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass,exception);
      image->alpha_trait=UndefinedPixelTrait;
      break;
    }
    case TrueColorAlphaType:
    {
      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
        status=TransformImageColorspace(image,sRGBColorspace,exception);
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass,exception);
      if (image->alpha_trait == UndefinedPixelTrait)
        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
      break;
    }
    case ColorSeparationType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            status=TransformImageColorspace(image,sRGBColorspace,exception);
          status=TransformImageColorspace(image,CMYKColorspace,exception);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass,exception);
      image->alpha_trait=UndefinedPixelTrait;
      break;
    }
    case ColorSeparationAlphaType:
    {
      if (image->colorspace != CMYKColorspace)
        {
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
            status=TransformImageColorspace(image,sRGBColorspace,exception);
          status=TransformImageColorspace(image,CMYKColorspace,exception);
        }
      if (image->storage_class != DirectClass)
        status=SetImageStorageClass(image,DirectClass,exception);
      if (image->alpha_trait == UndefinedPixelTrait)
        status=SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
      break;
    }
    case OptimizeType:
    case UndefinedType:
      break;
  }
  image_info=DestroyImageInfo(image_info);
  if (status == MagickFalse)
    return(status);
  image->type=type;
  return(MagickTrue);
}","MagickExport VAR_0 SetImageType(Image *VAR_1,const ImageType VAR_2,
  ExceptionInfo *VAR_3)
{
  const char
    *VAR_4;

  ImageInfo
    *VAR_5;

  MagickBooleanType
    VAR_6;

  QuantizeInfo
    *VAR_7;

  assert(VAR_1 != (Image *) NULL);
  if (VAR_1->debug != VAR_8)
    (void) LogMagickEvent(VAR_9,GetMagickModule(),""..."");
  assert(VAR_1->signature == VAR_10);
  VAR_6=VAR_11;
  VAR_5=AcquireImageInfo();
  VAR_5->dither=VAR_1->dither;
  VAR_4=GetImageArtifact(VAR_1,""dither"");
  if (VAR_4 != (const char *) NULL)
    (void) SetImageOption(VAR_5,""dither"",VAR_4);
  switch (VAR_2)
  {
    case VAR_12:
    {
      if (SetImageMonochrome(VAR_1,VAR_3) == VAR_8)
        {
          VAR_6=TransformImageColorspace(VAR_1,VAR_13,VAR_3);
          (void) NormalizeImage(VAR_1,VAR_3);
          VAR_7=AcquireQuantizeInfo(VAR_5);
          VAR_7->number_colors=2;
          VAR_7->colorspace=VAR_13;
          VAR_6=QuantizeImage(VAR_7,VAR_1,VAR_3);
          VAR_7=DestroyQuantizeInfo(VAR_7);
        }
      VAR_6=AcquireImageColormap(VAR_1,2,VAR_3);
      VAR_1->alpha_trait=VAR_14;
      break;
    }
    case VAR_15:
    {
      if (SetImageGray(VAR_1,VAR_3) == VAR_8)
        VAR_6=TransformImageColorspace(VAR_1,VAR_13,VAR_3);
      VAR_1->alpha_trait=VAR_14;
      break;
    }
    case VAR_16:
    {
      if (SetImageGray(VAR_1,VAR_3) == VAR_8)
        VAR_6=TransformImageColorspace(VAR_1,VAR_13,VAR_3);
      if (VAR_1->alpha_trait == VAR_14)
        (void) SetImageAlphaChannel(VAR_1,VAR_17,VAR_3);
      break;
    }
    case VAR_18:
    {
      if (IssRGBCompatibleColorspace(VAR_1->colorspace) == VAR_8)
        VAR_6=TransformImageColorspace(VAR_1,VAR_19,VAR_3);
      if ((VAR_1->storage_class == VAR_20) || (VAR_1->colors > 256))
        {
          VAR_7=AcquireQuantizeInfo(VAR_5);
          VAR_7->number_colors=256;
          VAR_6=QuantizeImage(VAR_7,VAR_1,VAR_3);
          VAR_7=DestroyQuantizeInfo(VAR_7);
        }
      VAR_1->alpha_trait=VAR_14;
      break;
    }
    case VAR_21:
    {
      ChannelType
        VAR_22;

      if (IssRGBCompatibleColorspace(VAR_1->colorspace) == VAR_8)
        VAR_6=TransformImageColorspace(VAR_1,VAR_19,VAR_3);
      if (VAR_1->alpha_trait == VAR_14)
        (void) SetImageAlphaChannel(VAR_1,VAR_17,VAR_3);
      VAR_22=SetImageChannelMask(VAR_1,VAR_23);
      (void) BilevelImage(VAR_1,(double) VAR_24/2.0,VAR_3);
      (void) SetImageChannelMask(VAR_1,VAR_22);
      VAR_7=AcquireQuantizeInfo(VAR_5);
      VAR_6=QuantizeImage(VAR_7,VAR_1,VAR_3);
      VAR_7=DestroyQuantizeInfo(VAR_7);
      break;
    }
    case VAR_25:
    {
      if (IssRGBCompatibleColorspace(VAR_1->colorspace) == VAR_8)
        VAR_6=TransformImageColorspace(VAR_1,VAR_19,VAR_3);
      if (VAR_1->alpha_trait == VAR_14)
        (void) SetImageAlphaChannel(VAR_1,VAR_17,VAR_3);
      VAR_7=AcquireQuantizeInfo(VAR_5);
      VAR_7->colorspace=VAR_26;
      VAR_6=QuantizeImage(VAR_7,VAR_1,VAR_3);
      VAR_7=DestroyQuantizeInfo(VAR_7);
      break;
    }
    case VAR_27:
    {
      if (IssRGBCompatibleColorspace(VAR_1->colorspace) == VAR_8)
        VAR_6=TransformImageColorspace(VAR_1,VAR_19,VAR_3);
      if (VAR_1->storage_class != VAR_20)
        VAR_6=SetImageStorageClass(VAR_1,VAR_20,VAR_3);
      VAR_1->alpha_trait=VAR_14;
      break;
    }
    case VAR_28:
    {
      if (IssRGBCompatibleColorspace(VAR_1->colorspace) == VAR_8)
        VAR_6=TransformImageColorspace(VAR_1,VAR_19,VAR_3);
      if (VAR_1->storage_class != VAR_20)
        VAR_6=SetImageStorageClass(VAR_1,VAR_20,VAR_3);
      if (VAR_1->alpha_trait == VAR_14)
        (void) SetImageAlphaChannel(VAR_1,VAR_17,VAR_3);
      break;
    }
    case VAR_29:
    {
      if (VAR_1->colorspace != VAR_30)
        {
          if (IssRGBCompatibleColorspace(VAR_1->colorspace) == VAR_8)
            VAR_6=TransformImageColorspace(VAR_1,VAR_19,VAR_3);
          VAR_6=TransformImageColorspace(VAR_1,VAR_30,VAR_3);
        }
      if (VAR_1->storage_class != VAR_20)
        VAR_6=SetImageStorageClass(VAR_1,VAR_20,VAR_3);
      VAR_1->alpha_trait=VAR_14;
      break;
    }
    case VAR_31:
    {
      if (VAR_1->colorspace != VAR_30)
        {
          if (IssRGBCompatibleColorspace(VAR_1->colorspace) == VAR_8)
            VAR_6=TransformImageColorspace(VAR_1,VAR_19,VAR_3);
          VAR_6=TransformImageColorspace(VAR_1,VAR_30,VAR_3);
        }
      if (VAR_1->storage_class != VAR_20)
        VAR_6=SetImageStorageClass(VAR_1,VAR_20,VAR_3);
      if (VAR_1->alpha_trait == VAR_14)
        VAR_6=SetImageAlphaChannel(VAR_1,VAR_17,VAR_3);
      break;
    }
    case VAR_32:
    case VAR_33:
      break;
  }
  VAR_5=DestroyImageInfo(VAR_5);
  if (VAR_6 == VAR_8)
    return(VAR_6);
  VAR_1->type=VAR_2;
  return(VAR_11);
}",,"--- func_before
+++ func_after
@@ -37,7 +37,7 @@
           status=QuantizeImage(quantize_info,image,exception);
           quantize_info=DestroyQuantizeInfo(quantize_info);
         }
-      image->colors=2;
+      status=AcquireImageColormap(image,2,exception);
       image->alpha_trait=UndefinedPixelTrait;
       break;
     }","{'deleted_lines': ['      image->colors=2;'], 'added_lines': ['      status=AcquireImageColormap(image,2,exception);']}",True,magick/attribute.c in ImageMagick 7.0.3-2 allows remote attackers to cause a denial of service (use-after-free) via a crafted file.,5.5,MEDIUM,1,test,2016-10-01T15:18:08Z,1
CVE-2016-9443,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,tats/w3m,"Fix null pointer dereference in formUpdateBuffer

Bug-Debian: https://github.com/tats/w3m/issues/28 [CVE-2016-9443]
Origin: https://anonscm.debian.org/cgit/collab-maint/w3m.git/commit/?id=ec9eb22e008a69ea9dc21fdca4b9b836679965ee
Origin: https://anonscm.debian.org/cgit/collab-maint/w3m.git/commit/?id=22d29c3d11bdfec80164789a99c36cc674340914",77c2c85da5ca7865d840f563291bb5e67c4a29c2,https://github.com/tats/w3m/commit/77c2c85da5ca7865d840f563291bb5e67c4a29c2,form.c,formUpdateBuffer,"void
formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)
{
Buffer save;
char *p;
int spos, epos, rows, c_rows, pos, col = 0;
Line *l;
copyBuffer(&save, buf);
gotoLine(buf, a->start.line);
switch (form->type) {
case FORM_TEXTAREA:
case FORM_INPUT_TEXT:
case FORM_INPUT_FILE:
case FORM_INPUT_PASSWORD:
case FORM_INPUT_CHECKBOX:
case FORM_INPUT_RADIO:
#ifdef MENU_SELECT
case FORM_SELECT:
#endif
spos = a->start.pos;
epos = a->end.pos;
break;
default:
spos = a->start.pos + 1;
epos = a->end.pos - 1;
}
switch (form->type) {
case FORM_INPUT_CHECKBOX:
case FORM_INPUT_RADIO:
if (form->checked)
buf->currentLine->lineBuf[spos] = '*';
else
buf->currentLine->lineBuf[spos] = ' ';
break;
case FORM_INPUT_TEXT:
case FORM_INPUT_FILE:
case FORM_INPUT_PASSWORD:
case FORM_TEXTAREA:
#ifdef MENU_SELECT
case FORM_SELECT:
if (form->type == FORM_SELECT) {
p = form->label->ptr;
updateSelectOption(form, form->select_option);
}
else
#endif
p = form->value->ptr;
l = buf->currentLine;
if (!l)
break;
if (form->type == FORM_TEXTAREA) {
int n = a->y - buf->currentLine->linenumber;
if (n > 0)
for (; l && n; l = l->prev, n--) ;
else if (n < 0)
for (; l && n; l = l->prev, n++) ;
if (!l)
break;
}
rows = form->rows ? form->rows : 1;
col = COLPOS(l, a->start.pos);
for (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {
if (rows > 1) {
pos = columnPos(l, col);
a = retrieveAnchor(buf->formitem, l->linenumber, pos);
if (a == NULL)
break;
spos = a->start.pos;
epos = a->end.pos;
}
if (a->start.line != a->end.line || spos > epos || epos >= l->len)
break;
pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,
rows > 1,
form->type == FORM_INPUT_PASSWORD);
if (pos != epos) {
shiftAnchorPosition(buf->href, buf->hmarklist,
a->start.line, spos, pos - epos);
shiftAnchorPosition(buf->name, buf->hmarklist,
a->start.line, spos, pos - epos);
shiftAnchorPosition(buf->img, buf->hmarklist,
a->start.line, spos, pos - epos);
shiftAnchorPosition(buf->formitem, buf->hmarklist,
a->start.line, spos, pos - epos);
}
}
break;
}
copyBuffer(buf, &save);
arrangeLine(buf);
}","void
formUpdateBuffer(Anchor *VAR_0, Buffer *VAR_1, FormItemList *VAR_2)
{
Buffer VAR_3;
char *VAR_4;
int VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10 = 0;
Line *VAR_11;
copyBuffer(&VAR_3, VAR_1);
gotoLine(VAR_1, VAR_0->start.line);
switch (VAR_2->type) {
case VAR_12:
case VAR_13:
case VAR_14:
case VAR_15:
case VAR_16:
case VAR_17:
#ifdef VAR_18
case VAR_19:
#endif
VAR_5 = VAR_0->start.pos;
VAR_6 = VAR_0->end.pos;
break;
default:
VAR_5 = VAR_0->start.pos + 1;
VAR_6 = VAR_0->end.pos - 1;
}
switch (VAR_2->type) {
case VAR_16:
case VAR_17:
if (VAR_2->checked)
VAR_1->currentLine->lineBuf[VAR_5] = '*';
else
VAR_1->currentLine->lineBuf[VAR_5] = ' ';
break;
case VAR_13:
case VAR_14:
case VAR_15:
case VAR_12:
#ifdef VAR_18
case VAR_19:
if (VAR_2->type == VAR_19) {
VAR_4 = VAR_2->label->ptr;
updateSelectOption(VAR_2, VAR_2->select_option);
}
else
#endif
VAR_4 = VAR_2->value->ptr;
VAR_11 = VAR_1->currentLine;
if (!VAR_11)
break;
if (VAR_2->type == VAR_12) {
int VAR_20 = VAR_0->y - VAR_1->currentLine->linenumber;
if (VAR_20 > 0)
for (; VAR_11 && VAR_20; VAR_11 = VAR_11->prev, VAR_20--) ;
else if (VAR_20 < 0)
for (; VAR_11 && VAR_20; VAR_11 = VAR_11->prev, VAR_20++) ;
if (!VAR_11)
break;
}
VAR_7 = VAR_2->rows ? VAR_2->rows : 1;
VAR_10 = COLPOS(VAR_11, VAR_0->start.pos);
for (VAR_8 = 0; VAR_8 < VAR_7; VAR_8++, VAR_11 = VAR_11->next) {
if (VAR_7 > 1) {
VAR_9 = columnPos(VAR_11, VAR_10);
VAR_0 = retrieveAnchor(VAR_1->formitem, VAR_11->linenumber, VAR_9);
if (VAR_0 == NULL)
break;
VAR_5 = VAR_0->start.pos;
VAR_6 = VAR_0->end.pos;
}
if (VAR_0->start.line != VAR_0->end.line || VAR_5 > VAR_6 || VAR_6 >= VAR_11->len)
break;
VAR_9 = form_update_line(VAR_11, &VAR_4, VAR_5, VAR_6, COLPOS(VAR_11, VAR_6) - VAR_10,
VAR_7 > 1,
VAR_2->type == VAR_15);
if (VAR_9 != VAR_6) {
shiftAnchorPosition(VAR_1->href, VAR_1->hmarklist,
VAR_0->start.line, VAR_5, VAR_9 - VAR_6);
shiftAnchorPosition(VAR_1->name, VAR_1->hmarklist,
VAR_0->start.line, VAR_5, VAR_9 - VAR_6);
shiftAnchorPosition(VAR_1->img, VAR_1->hmarklist,
VAR_0->start.line, VAR_5, VAR_9 - VAR_6);
shiftAnchorPosition(VAR_1->formitem, VAR_1->hmarklist,
VAR_0->start.line, VAR_5, VAR_9 - VAR_6);
}
}
break;
}
copyBuffer(VAR_1, &VAR_3);
arrangeLine(VAR_1);
}",tats/w3m/77c2c85da5ca7865d840f563291bb5e67c4a29c2/form.c/vul/before/0.json,"void
formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)
{
    Buffer save;
    char *p;
    int spos, epos, rows, c_rows, pos, col = 0;
    Line *l;

    copyBuffer(&save, buf);
    gotoLine(buf, a->start.line);
    switch (form->type) {
    case FORM_TEXTAREA:
    case FORM_INPUT_TEXT:
    case FORM_INPUT_FILE:
    case FORM_INPUT_PASSWORD:
    case FORM_INPUT_CHECKBOX:
    case FORM_INPUT_RADIO:
#ifdef MENU_SELECT
    case FORM_SELECT:
#endif				/* MENU_SELECT */
	spos = a->start.pos;
	epos = a->end.pos;
	break;
    default:
	spos = a->start.pos + 1;
	epos = a->end.pos - 1;
    }
    switch (form->type) {
    case FORM_INPUT_CHECKBOX:
    case FORM_INPUT_RADIO:
	if (form->checked)
	    buf->currentLine->lineBuf[spos] = '*';
	else
	    buf->currentLine->lineBuf[spos] = ' ';
	break;
    case FORM_INPUT_TEXT:
    case FORM_INPUT_FILE:
    case FORM_INPUT_PASSWORD:
    case FORM_TEXTAREA:
#ifdef MENU_SELECT
    case FORM_SELECT:
	if (form->type == FORM_SELECT) {
	    p = form->label->ptr;
	    updateSelectOption(form, form->select_option);
	}
	else
#endif				/* MENU_SELECT */
	{
	    if (!form->value)
		break;
	    p = form->value->ptr;
	}
	l = buf->currentLine;
	if (!l)
	    break;
	if (form->type == FORM_TEXTAREA) {
	    int n = a->y - buf->currentLine->linenumber;
	    if (n > 0)
		for (; l && n; l = l->prev, n--) ;
	    else if (n < 0)
		for (; l && n; l = l->prev, n++) ;
	    if (!l)
		break;
	}
	rows = form->rows ? form->rows : 1;
	col = COLPOS(l, a->start.pos);
	for (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {
	    if (rows > 1) {
		pos = columnPos(l, col);
		a = retrieveAnchor(buf->formitem, l->linenumber, pos);
		if (a == NULL)
		    break;
		spos = a->start.pos;
		epos = a->end.pos;
	    }
	    if (a->start.line != a->end.line || spos > epos || epos >= l->len)
		break;
	    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,
				   rows > 1,
				   form->type == FORM_INPUT_PASSWORD);
	    if (pos != epos) {
		shiftAnchorPosition(buf->href, buf->hmarklist,
				    a->start.line, spos, pos - epos);
		shiftAnchorPosition(buf->name, buf->hmarklist,
				    a->start.line, spos, pos - epos);
		shiftAnchorPosition(buf->img, buf->hmarklist,
				    a->start.line, spos, pos - epos);
		shiftAnchorPosition(buf->formitem, buf->hmarklist,
				    a->start.line, spos, pos - epos);
	    }
	}
	break;
    }
    copyBuffer(buf, &save);
    arrangeLine(buf);
}","void
formUpdateBuffer(Anchor *VAR_0, Buffer *VAR_1, FormItemList *VAR_2)
{
    Buffer VAR_3;
    char *VAR_4;
    int VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10 = 0;
    Line *VAR_11;

    copyBuffer(&VAR_3, VAR_1);
    gotoLine(VAR_1, VAR_0->start.line);
    switch (VAR_2->type) {
    case VAR_12:
    case VAR_13:
    case VAR_14:
    case VAR_15:
    case VAR_16:
    case VAR_17:
#ifdef VAR_18
    case VAR_19:
#endif				/* COMMENT_0 */
	VAR_5 = VAR_0->start.pos;
	VAR_6 = VAR_0->end.pos;
	break;
    default:
	VAR_5 = VAR_0->start.pos + 1;
	VAR_6 = VAR_0->end.pos - 1;
    }
    switch (VAR_2->type) {
    case VAR_16:
    case VAR_17:
	if (VAR_2->checked)
	    VAR_1->currentLine->lineBuf[VAR_5] = '*';
	else
	    VAR_1->currentLine->lineBuf[VAR_5] = ' ';
	break;
    case VAR_13:
    case VAR_14:
    case VAR_15:
    case VAR_12:
#ifdef VAR_18
    case VAR_19:
	if (VAR_2->type == VAR_19) {
	    VAR_4 = VAR_2->label->ptr;
	    updateSelectOption(VAR_2, VAR_2->select_option);
	}
	else
#endif				/* COMMENT_0 */
	{
	    if (!VAR_2->value)
		break;
	    VAR_4 = VAR_2->value->ptr;
	}
	VAR_11 = VAR_1->currentLine;
	if (!VAR_11)
	    break;
	if (VAR_2->type == VAR_12) {
	    int VAR_20 = VAR_0->y - VAR_1->currentLine->linenumber;
	    if (VAR_20 > 0)
		for (; VAR_11 && VAR_20; VAR_11 = VAR_11->prev, VAR_20--) ;
	    else if (VAR_20 < 0)
		for (; VAR_11 && VAR_20; VAR_11 = VAR_11->prev, VAR_20++) ;
	    if (!VAR_11)
		break;
	}
	VAR_7 = VAR_2->rows ? VAR_2->rows : 1;
	VAR_10 = COLPOS(VAR_11, VAR_0->start.pos);
	for (VAR_8 = 0; VAR_8 < VAR_7; VAR_8++, VAR_11 = VAR_11->next) {
	    if (VAR_7 > 1) {
		VAR_9 = columnPos(VAR_11, VAR_10);
		VAR_0 = retrieveAnchor(VAR_1->formitem, VAR_11->linenumber, VAR_9);
		if (VAR_0 == NULL)
		    break;
		VAR_5 = VAR_0->start.pos;
		VAR_6 = VAR_0->end.pos;
	    }
	    if (VAR_0->start.line != VAR_0->end.line || VAR_5 > VAR_6 || VAR_6 >= VAR_11->len)
		break;
	    VAR_9 = form_update_line(VAR_11, &VAR_4, VAR_5, VAR_6, COLPOS(VAR_11, VAR_6) - VAR_10,
				   VAR_7 > 1,
				   VAR_2->type == VAR_15);
	    if (VAR_9 != VAR_6) {
		shiftAnchorPosition(VAR_1->href, VAR_1->hmarklist,
				    VAR_0->start.line, VAR_5, VAR_9 - VAR_6);
		shiftAnchorPosition(VAR_1->name, VAR_1->hmarklist,
				    VAR_0->start.line, VAR_5, VAR_9 - VAR_6);
		shiftAnchorPosition(VAR_1->img, VAR_1->hmarklist,
				    VAR_0->start.line, VAR_5, VAR_9 - VAR_6);
		shiftAnchorPosition(VAR_1->formitem, VAR_1->hmarklist,
				    VAR_0->start.line, VAR_5, VAR_9 - VAR_6);
	    }
	}
	break;
    }
    copyBuffer(VAR_1, &VAR_3);
    arrangeLine(VAR_1);
}",tats/w3m/77c2c85da5ca7865d840f563291bb5e67c4a29c2/form.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -45,7 +45,11 @@
 	}
 	else
 #endif				/* MENU_SELECT */
+	{
+	    if (!form->value)
+		break;
 	    p = form->value->ptr;
+	}
 	l = buf->currentLine;
 	if (!l)
 	    break;","{'deleted_lines': [], 'added_lines': ['\t{', '\t    if (!form->value)', '\t\tbreak;', '\t}']}",True,An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-31. w3m allows remote attackers to cause a denial of service (segmentation fault and crash) via a crafted HTML page.,6.5,MEDIUM,1,test,2016-10-07T21:39:47Z,1
CVE-2016-9443,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,tats/w3m,"Fix null pointer dereference in formUpdateBuffer

Bug-Debian: https://github.com/tats/w3m/issues/28",ec9eb22e008a69ea9dc21fdca4b9b836679965ee,https://github.com/tats/w3m/commit/ec9eb22e008a69ea9dc21fdca4b9b836679965ee,form.c,formUpdateBuffer,"void
formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)
{
Buffer save;
char *p;
int spos, epos, rows, c_rows, pos, col = 0;
Line *l;
copyBuffer(&save, buf);
gotoLine(buf, a->start.line);
switch (form->type) {
case FORM_TEXTAREA:
case FORM_INPUT_TEXT:
case FORM_INPUT_FILE:
case FORM_INPUT_PASSWORD:
case FORM_INPUT_CHECKBOX:
case FORM_INPUT_RADIO:
#ifdef MENU_SELECT
case FORM_SELECT:
#endif
spos = a->start.pos;
epos = a->end.pos;
break;
default:
spos = a->start.pos + 1;
epos = a->end.pos - 1;
}
switch (form->type) {
case FORM_INPUT_CHECKBOX:
case FORM_INPUT_RADIO:
if (form->checked)
buf->currentLine->lineBuf[spos] = '*';
else
buf->currentLine->lineBuf[spos] = ' ';
break;
case FORM_INPUT_TEXT:
case FORM_INPUT_FILE:
case FORM_INPUT_PASSWORD:
case FORM_TEXTAREA:
#ifdef MENU_SELECT
case FORM_SELECT:
if (form->type == FORM_SELECT) {
p = form->label->ptr;
updateSelectOption(form, form->select_option);
}
else
#endif
p = form->value->ptr;
l = buf->currentLine;
if (!l)
break;
if (form->type == FORM_TEXTAREA) {
int n = a->y - buf->currentLine->linenumber;
if (n > 0)
for (; l && n; l = l->prev, n--) ;
else if (n < 0)
for (; l && n; l = l->prev, n++) ;
if (!l)
break;
}
rows = form->rows ? form->rows : 1;
col = COLPOS(l, a->start.pos);
for (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {
if (rows > 1) {
pos = columnPos(l, col);
a = retrieveAnchor(buf->formitem, l->linenumber, pos);
if (a == NULL)
break;
spos = a->start.pos;
epos = a->end.pos;
}
if (a->start.line != a->end.line || spos > epos || epos >= l->len)
break;
pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,
rows > 1,
form->type == FORM_INPUT_PASSWORD);
if (pos != epos) {
shiftAnchorPosition(buf->href, buf->hmarklist,
a->start.line, spos, pos - epos);
shiftAnchorPosition(buf->name, buf->hmarklist,
a->start.line, spos, pos - epos);
shiftAnchorPosition(buf->img, buf->hmarklist,
a->start.line, spos, pos - epos);
shiftAnchorPosition(buf->formitem, buf->hmarklist,
a->start.line, spos, pos - epos);
}
}
break;
}
copyBuffer(buf, &save);
arrangeLine(buf);
}","void
formUpdateBuffer(Anchor *VAR_0, Buffer *VAR_1, FormItemList *VAR_2)
{
Buffer VAR_3;
char *VAR_4;
int VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10 = 0;
Line *VAR_11;
copyBuffer(&VAR_3, VAR_1);
gotoLine(VAR_1, VAR_0->start.line);
switch (VAR_2->type) {
case VAR_12:
case VAR_13:
case VAR_14:
case VAR_15:
case VAR_16:
case VAR_17:
#ifdef VAR_18
case VAR_19:
#endif
VAR_5 = VAR_0->start.pos;
VAR_6 = VAR_0->end.pos;
break;
default:
VAR_5 = VAR_0->start.pos + 1;
VAR_6 = VAR_0->end.pos - 1;
}
switch (VAR_2->type) {
case VAR_16:
case VAR_17:
if (VAR_2->checked)
VAR_1->currentLine->lineBuf[VAR_5] = '*';
else
VAR_1->currentLine->lineBuf[VAR_5] = ' ';
break;
case VAR_13:
case VAR_14:
case VAR_15:
case VAR_12:
#ifdef VAR_18
case VAR_19:
if (VAR_2->type == VAR_19) {
VAR_4 = VAR_2->label->ptr;
updateSelectOption(VAR_2, VAR_2->select_option);
}
else
#endif
VAR_4 = VAR_2->value->ptr;
VAR_11 = VAR_1->currentLine;
if (!VAR_11)
break;
if (VAR_2->type == VAR_12) {
int VAR_20 = VAR_0->y - VAR_1->currentLine->linenumber;
if (VAR_20 > 0)
for (; VAR_11 && VAR_20; VAR_11 = VAR_11->prev, VAR_20--) ;
else if (VAR_20 < 0)
for (; VAR_11 && VAR_20; VAR_11 = VAR_11->prev, VAR_20++) ;
if (!VAR_11)
break;
}
VAR_7 = VAR_2->rows ? VAR_2->rows : 1;
VAR_10 = COLPOS(VAR_11, VAR_0->start.pos);
for (VAR_8 = 0; VAR_8 < VAR_7; VAR_8++, VAR_11 = VAR_11->next) {
if (VAR_7 > 1) {
VAR_9 = columnPos(VAR_11, VAR_10);
VAR_0 = retrieveAnchor(VAR_1->formitem, VAR_11->linenumber, VAR_9);
if (VAR_0 == NULL)
break;
VAR_5 = VAR_0->start.pos;
VAR_6 = VAR_0->end.pos;
}
if (VAR_0->start.line != VAR_0->end.line || VAR_5 > VAR_6 || VAR_6 >= VAR_11->len)
break;
VAR_9 = form_update_line(VAR_11, &VAR_4, VAR_5, VAR_6, COLPOS(VAR_11, VAR_6) - VAR_10,
VAR_7 > 1,
VAR_2->type == VAR_15);
if (VAR_9 != VAR_6) {
shiftAnchorPosition(VAR_1->href, VAR_1->hmarklist,
VAR_0->start.line, VAR_5, VAR_9 - VAR_6);
shiftAnchorPosition(VAR_1->name, VAR_1->hmarklist,
VAR_0->start.line, VAR_5, VAR_9 - VAR_6);
shiftAnchorPosition(VAR_1->img, VAR_1->hmarklist,
VAR_0->start.line, VAR_5, VAR_9 - VAR_6);
shiftAnchorPosition(VAR_1->formitem, VAR_1->hmarklist,
VAR_0->start.line, VAR_5, VAR_9 - VAR_6);
}
}
break;
}
copyBuffer(VAR_1, &VAR_3);
arrangeLine(VAR_1);
}",tats/w3m/ec9eb22e008a69ea9dc21fdca4b9b836679965ee/form.c/vul/before/0.json,"void
formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)
{
    Buffer save;
    char *p;
    int spos, epos, rows, c_rows, pos, col = 0;
    Line *l;

    copyBuffer(&save, buf);
    gotoLine(buf, a->start.line);
    switch (form->type) {
    case FORM_TEXTAREA:
    case FORM_INPUT_TEXT:
    case FORM_INPUT_FILE:
    case FORM_INPUT_PASSWORD:
    case FORM_INPUT_CHECKBOX:
    case FORM_INPUT_RADIO:
#ifdef MENU_SELECT
    case FORM_SELECT:
#endif				/* MENU_SELECT */
	spos = a->start.pos;
	epos = a->end.pos;
	break;
    default:
	spos = a->start.pos + 1;
	epos = a->end.pos - 1;
    }
    switch (form->type) {
    case FORM_INPUT_CHECKBOX:
    case FORM_INPUT_RADIO:
	if (form->checked)
	    buf->currentLine->lineBuf[spos] = '*';
	else
	    buf->currentLine->lineBuf[spos] = ' ';
	break;
    case FORM_INPUT_TEXT:
    case FORM_INPUT_FILE:
    case FORM_INPUT_PASSWORD:
    case FORM_TEXTAREA:
#ifdef MENU_SELECT
    case FORM_SELECT:
	if (form->type == FORM_SELECT) {
	    p = form->label->ptr;
	    updateSelectOption(form, form->select_option);
	}
	else
#endif				/* MENU_SELECT */
	    if (!form->value)
		break;
	    p = form->value->ptr;
	l = buf->currentLine;
	if (!l)
	    break;
	if (form->type == FORM_TEXTAREA) {
	    int n = a->y - buf->currentLine->linenumber;
	    if (n > 0)
		for (; l && n; l = l->prev, n--) ;
	    else if (n < 0)
		for (; l && n; l = l->prev, n++) ;
	    if (!l)
		break;
	}
	rows = form->rows ? form->rows : 1;
	col = COLPOS(l, a->start.pos);
	for (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {
	    if (rows > 1) {
		pos = columnPos(l, col);
		a = retrieveAnchor(buf->formitem, l->linenumber, pos);
		if (a == NULL)
		    break;
		spos = a->start.pos;
		epos = a->end.pos;
	    }
	    if (a->start.line != a->end.line || spos > epos || epos >= l->len)
		break;
	    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,
				   rows > 1,
				   form->type == FORM_INPUT_PASSWORD);
	    if (pos != epos) {
		shiftAnchorPosition(buf->href, buf->hmarklist,
				    a->start.line, spos, pos - epos);
		shiftAnchorPosition(buf->name, buf->hmarklist,
				    a->start.line, spos, pos - epos);
		shiftAnchorPosition(buf->img, buf->hmarklist,
				    a->start.line, spos, pos - epos);
		shiftAnchorPosition(buf->formitem, buf->hmarklist,
				    a->start.line, spos, pos - epos);
	    }
	}
	break;
    }
    copyBuffer(buf, &save);
    arrangeLine(buf);
}","void
formUpdateBuffer(Anchor *VAR_0, Buffer *VAR_1, FormItemList *VAR_2)
{
    Buffer VAR_3;
    char *VAR_4;
    int VAR_5, VAR_6, VAR_7, VAR_8, VAR_9, VAR_10 = 0;
    Line *VAR_11;

    copyBuffer(&VAR_3, VAR_1);
    gotoLine(VAR_1, VAR_0->start.line);
    switch (VAR_2->type) {
    case VAR_12:
    case VAR_13:
    case VAR_14:
    case VAR_15:
    case VAR_16:
    case VAR_17:
#ifdef VAR_18
    case VAR_19:
#endif				/* COMMENT_0 */
	VAR_5 = VAR_0->start.pos;
	VAR_6 = VAR_0->end.pos;
	break;
    default:
	VAR_5 = VAR_0->start.pos + 1;
	VAR_6 = VAR_0->end.pos - 1;
    }
    switch (VAR_2->type) {
    case VAR_16:
    case VAR_17:
	if (VAR_2->checked)
	    VAR_1->currentLine->lineBuf[VAR_5] = '*';
	else
	    VAR_1->currentLine->lineBuf[VAR_5] = ' ';
	break;
    case VAR_13:
    case VAR_14:
    case VAR_15:
    case VAR_12:
#ifdef VAR_18
    case VAR_19:
	if (VAR_2->type == VAR_19) {
	    VAR_4 = VAR_2->label->ptr;
	    updateSelectOption(VAR_2, VAR_2->select_option);
	}
	else
#endif				/* COMMENT_0 */
	    if (!VAR_2->value)
		break;
	    VAR_4 = VAR_2->value->ptr;
	VAR_11 = VAR_1->currentLine;
	if (!VAR_11)
	    break;
	if (VAR_2->type == VAR_12) {
	    int VAR_20 = VAR_0->y - VAR_1->currentLine->linenumber;
	    if (VAR_20 > 0)
		for (; VAR_11 && VAR_20; VAR_11 = VAR_11->prev, VAR_20--) ;
	    else if (VAR_20 < 0)
		for (; VAR_11 && VAR_20; VAR_11 = VAR_11->prev, VAR_20++) ;
	    if (!VAR_11)
		break;
	}
	VAR_7 = VAR_2->rows ? VAR_2->rows : 1;
	VAR_10 = COLPOS(VAR_11, VAR_0->start.pos);
	for (VAR_8 = 0; VAR_8 < VAR_7; VAR_8++, VAR_11 = VAR_11->next) {
	    if (VAR_7 > 1) {
		VAR_9 = columnPos(VAR_11, VAR_10);
		VAR_0 = retrieveAnchor(VAR_1->formitem, VAR_11->linenumber, VAR_9);
		if (VAR_0 == NULL)
		    break;
		VAR_5 = VAR_0->start.pos;
		VAR_6 = VAR_0->end.pos;
	    }
	    if (VAR_0->start.line != VAR_0->end.line || VAR_5 > VAR_6 || VAR_6 >= VAR_11->len)
		break;
	    VAR_9 = form_update_line(VAR_11, &VAR_4, VAR_5, VAR_6, COLPOS(VAR_11, VAR_6) - VAR_10,
				   VAR_7 > 1,
				   VAR_2->type == VAR_15);
	    if (VAR_9 != VAR_6) {
		shiftAnchorPosition(VAR_1->href, VAR_1->hmarklist,
				    VAR_0->start.line, VAR_5, VAR_9 - VAR_6);
		shiftAnchorPosition(VAR_1->name, VAR_1->hmarklist,
				    VAR_0->start.line, VAR_5, VAR_9 - VAR_6);
		shiftAnchorPosition(VAR_1->img, VAR_1->hmarklist,
				    VAR_0->start.line, VAR_5, VAR_9 - VAR_6);
		shiftAnchorPosition(VAR_1->formitem, VAR_1->hmarklist,
				    VAR_0->start.line, VAR_5, VAR_9 - VAR_6);
	    }
	}
	break;
    }
    copyBuffer(VAR_1, &VAR_3);
    arrangeLine(VAR_1);
}",tats/w3m/ec9eb22e008a69ea9dc21fdca4b9b836679965ee/form.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -45,6 +45,8 @@
 	}
 	else
 #endif				/* MENU_SELECT */
+	    if (!form->value)
+		break;
 	    p = form->value->ptr;
 	l = buf->currentLine;
 	if (!l)","{'deleted_lines': [], 'added_lines': ['\t    if (!form->value)', '\t\tbreak;']}",True,An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-31. w3m allows remote attackers to cause a denial of service (segmentation fault and crash) via a crafted HTML page.,6.5,MEDIUM,1,test,2016-10-07T21:39:47Z,1
CVE-2016-9538,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,vadz/libtiff,"* tools/tiffcp.c: fix read of undefined variable in case of missing
required tags. Found on test case of MSVR 35100.
* tools/tiffcrop.c: fix read of undefined buffer in
readContigStripsIntoBuffer() due to uint16 overflow. Probably not a
security issue but I can be wrong. Reported as MSVR 35100 by Axel
Souchet from the MSRC Vulnerabilities & Mitigations team.",43c0b81a818640429317c80fea1e66771e85024b,https://github.com/vadz/libtiff/commit/43c0b81a818640429317c80fea1e66771e85024b,tools/tiffcrop.c,readSeparateStripsIntoBuffer,"static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length, 
uint32 width, uint16 spp,
struct dump_opts *dump)
{
int i, j, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;
int32  bytes_read = 0;
uint16 bps, nstrips, planar, strips_per_sample;
uint32 src_rowsize, dst_rowsize, rows_processed, rps;
uint32 rows_this_strip = 0;
tsample_t s;
tstrip_t  strip;
tsize_t scanlinesize = TIFFScanlineSize(in);
tsize_t stripsize    = TIFFStripSize(in);
unsigned char *srcbuffs[MAX_SAMPLES];
unsigned char *buff = NULL;
unsigned char *dst = NULL;
if (obuf == NULL)
{
TIFFError(""readSeparateStripsIntoBuffer"",""Invalid buffer argument"");
return (0);
}
memset (srcbuffs, '\0', sizeof(srcbuffs));
TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);
TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);
TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
if (rps > length)
rps = length;
bytes_per_sample = (bps + 7) / 8; 
bytes_per_pixel  = ((bps * spp) + 7) / 8;
if (bytes_per_pixel < (bytes_per_sample + 1))
shift_width = bytes_per_pixel;
else
shift_width = bytes_per_sample + 1;
src_rowsize = ((bps * width) + 7) / 8;
dst_rowsize = ((bps * width * spp) + 7) / 8;
dst = obuf;
if ((dump->infile != NULL) && (dump->level == 3))
{
dump_info  (dump->infile, dump->format, """", 
""Image width %d, length %d, Scanline size, %4d bytes"",
width, length,  scanlinesize);
dump_info  (dump->infile, dump->format, """", 
""Bits per sample %d, Samples per pixel %d, Shift width %d"",
bps, spp, shift_width);
}
nstrips = TIFFNumberOfStrips(in);
strips_per_sample = nstrips /spp;
for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)
{
srcbuffs[s] = NULL;
buff = _TIFFmalloc(stripsize);
if (!buff)
{
TIFFError (""readSeparateStripsIntoBuffer"", 
""Unable to allocate strip read buffer for sample %d"", s);
for (i = 0; i < s; i++)
_TIFFfree (srcbuffs[i]);
return 0;
}
srcbuffs[s] = buff;
}
rows_processed = 0;
for (j = 0; (j < strips_per_sample) && (result == 1); j++)
{
for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)
{
buff = srcbuffs[s];
strip = (s * strips_per_sample) + j; 
bytes_read = TIFFReadEncodedStrip (in, strip, buff, stripsize);
rows_this_strip = bytes_read / src_rowsize;
if (bytes_read < 0 && !ignore)
{
TIFFError(TIFFFileName(in),
""Error, can't read strip %lu for sample %d"",
(unsigned long) strip, s + 1);
result = 0;
break;
}
#ifdef DEVELMODE
TIFFError("""", ""Strip %2d, read %5d bytes for %4d scanlines, shift width %d"", 
strip, bytes_read, rows_this_strip, shift_width);
#endif
}
if (rps > rows_this_strip)
rps = rows_this_strip;
dst = obuf + (dst_rowsize * rows_processed);
if ((bps % 8) == 0)
{
if (combineSeparateSamplesBytes (srcbuffs, dst, width, rps,
spp, bps, dump->infile, 
dump->format, dump->level))
{
result = 0;
break;
}
}
else
{
switch (shift_width)
{
case 1: if (combineSeparateSamples8bits (srcbuffs, dst, width, rps,
spp, bps, dump->infile,
dump->format, dump->level))
{
result = 0;
break;
}
break;
case 2: if (combineSeparateSamples16bits (srcbuffs, dst, width, rps,
spp, bps, dump->infile,
dump->format, dump->level))
{
result = 0;
break;
}
break;
case 3: if (combineSeparateSamples24bits (srcbuffs, dst, width, rps,
spp, bps, dump->infile,
dump->format, dump->level))
{
result = 0;
break;
}
break;
case 4: 
case 5:
case 6:
case 7:
case 8: if (combineSeparateSamples32bits (srcbuffs, dst, width, rps,
spp, bps, dump->infile,
dump->format, dump->level))
{
result = 0;
break;
}
break;
default: TIFFError (""readSeparateStripsIntoBuffer"", ""Unsupported bit depth: %d"", bps);
result = 0;
break;
}
}
if ((rows_processed + rps) > length)
{
rows_processed = length;
rps = length - rows_processed;
}
else
rows_processed += rps;
}
for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)
{
buff = srcbuffs[s];
if (buff != NULL)
_TIFFfree(buff);
}
return (result);
}","static int readSeparateStripsIntoBuffer (TIFF *VAR_0, uint8 *VAR_1, uint32 VAR_2, 
uint32 VAR_3, uint16 VAR_4,
struct dump_opts *VAR_5)
{
int VAR_6, VAR_7, VAR_8, VAR_9, VAR_10, VAR_11 = 1;
int32  VAR_12 = 0;
uint16 VAR_13, VAR_14, VAR_15, VAR_16;
uint32 VAR_17, VAR_18, VAR_19, VAR_20;
uint32 VAR_21 = 0;
tsample_t VAR_22;
tstrip_t  VAR_23;
tsize_t VAR_24 = TIFFScanlineSize(VAR_0);
tsize_t VAR_25    = TIFFStripSize(VAR_0);
unsigned char *VAR_26[VAR_27];
unsigned char *VAR_28 = NULL;
unsigned char *VAR_29 = NULL;
if (VAR_1 == NULL)
{
TIFFError(""readSeparateStripsIntoBuffer"",""Invalid buffer argument"");
return (0);
}
memset (VAR_26, '\0', sizeof(VAR_26));
TIFFGetField(VAR_0, VAR_30, &VAR_13);
TIFFGetFieldDefaulted(VAR_0, VAR_31, &VAR_15);
TIFFGetFieldDefaulted(VAR_0, VAR_32, &VAR_20);
if (VAR_20 > VAR_2)
VAR_20 = VAR_2;
VAR_8 = (VAR_13 + 7) / 8; 
VAR_9  = ((VAR_13 * VAR_4) + 7) / 8;
if (VAR_9 < (VAR_8 + 1))
VAR_10 = VAR_9;
else
VAR_10 = VAR_8 + 1;
VAR_17 = ((VAR_13 * VAR_3) + 7) / 8;
VAR_18 = ((VAR_13 * VAR_3 * VAR_4) + 7) / 8;
VAR_29 = VAR_1;
if ((VAR_5->infile != NULL) && (VAR_5->level == 3))
{
dump_info  (VAR_5->infile, VAR_5->format, """", 
""Image width %d, length %d, Scanline size, %4d bytes"",
VAR_3, VAR_2,  VAR_24);
dump_info  (VAR_5->infile, VAR_5->format, """", 
""Bits per sample %d, Samples per pixel %d, Shift width %d"",
VAR_13, VAR_4, VAR_10);
}
VAR_14 = TIFFNumberOfStrips(VAR_0);
VAR_16 = VAR_14 /VAR_4;
for (VAR_22 = 0; (VAR_22 < VAR_4) && (VAR_22 < VAR_27); VAR_22++)
{
VAR_26[VAR_22] = NULL;
VAR_28 = _TIFFmalloc(VAR_25);
if (!VAR_28)
{
TIFFError (""readSeparateStripsIntoBuffer"", 
""Unable to allocate strip read buffer for sample %d"", VAR_22);
for (VAR_6 = 0; VAR_6 < VAR_22; VAR_6++)
_TIFFfree (VAR_26[VAR_6]);
return 0;
}
VAR_26[VAR_22] = VAR_28;
}
VAR_19 = 0;
for (VAR_7 = 0; (VAR_7 < VAR_16) && (VAR_11 == 1); VAR_7++)
{
for (VAR_22 = 0; (VAR_22 < VAR_4) && (VAR_22 < VAR_27); VAR_22++)
{
VAR_28 = VAR_26[VAR_22];
VAR_23 = (VAR_22 * VAR_16) + VAR_7; 
VAR_12 = TIFFReadEncodedStrip (VAR_0, VAR_23, VAR_28, VAR_25);
VAR_21 = VAR_12 / VAR_17;
if (VAR_12 < 0 && !VAR_33)
{
TIFFError(TIFFFileName(VAR_0),
""Error, can't read strip %lu for sample %d"",
(unsigned long) VAR_23, VAR_22 + 1);
VAR_11 = 0;
break;
}
#ifdef VAR_34
TIFFError("""", ""Strip %2d, read %5d bytes for %4d scanlines, shift width %d"", 
VAR_23, VAR_12, VAR_21, VAR_10);
#endif
}
if (VAR_20 > VAR_21)
VAR_20 = VAR_21;
VAR_29 = VAR_1 + (VAR_18 * VAR_19);
if ((VAR_13 % 8) == 0)
{
if (combineSeparateSamplesBytes (VAR_26, VAR_29, VAR_3, VAR_20,
VAR_4, VAR_13, VAR_5->infile, 
VAR_5->format, VAR_5->level))
{
VAR_11 = 0;
break;
}
}
else
{
switch (VAR_10)
{
case 1: if (combineSeparateSamples8bits (VAR_26, VAR_29, VAR_3, VAR_20,
VAR_4, VAR_13, VAR_5->infile,
VAR_5->format, VAR_5->level))
{
VAR_11 = 0;
break;
}
break;
case 2: if (combineSeparateSamples16bits (VAR_26, VAR_29, VAR_3, VAR_20,
VAR_4, VAR_13, VAR_5->infile,
VAR_5->format, VAR_5->level))
{
VAR_11 = 0;
break;
}
break;
case 3: if (combineSeparateSamples24bits (VAR_26, VAR_29, VAR_3, VAR_20,
VAR_4, VAR_13, VAR_5->infile,
VAR_5->format, VAR_5->level))
{
VAR_11 = 0;
break;
}
break;
case 4: 
case 5:
case 6:
case 7:
case 8: if (combineSeparateSamples32bits (VAR_26, VAR_29, VAR_3, VAR_20,
VAR_4, VAR_13, VAR_5->infile,
VAR_5->format, VAR_5->level))
{
VAR_11 = 0;
break;
}
break;
default: TIFFError (""readSeparateStripsIntoBuffer"", ""Unsupported bit depth: %d"", VAR_13);
VAR_11 = 0;
break;
}
}
if ((VAR_19 + VAR_20) > VAR_2)
{
VAR_19 = VAR_2;
VAR_20 = VAR_2 - VAR_19;
}
else
VAR_19 += VAR_20;
}
for (VAR_22 = 0; (VAR_22 < VAR_4) && (VAR_22 < VAR_27); VAR_22++)
{
VAR_28 = VAR_26[VAR_22];
if (VAR_28 != NULL)
_TIFFfree(VAR_28);
}
return (VAR_11);
}",vadz/libtiff/43c0b81a818640429317c80fea1e66771e85024b/tiffcrop.c/vul/before/0.json,"static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length, 
                                         uint32 width, uint16 spp,
                                         struct dump_opts *dump)
  {
  int i, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;
  uint32 j;
  int32  bytes_read = 0;
  uint16 bps, planar;
  uint32 nstrips;
  uint32 strips_per_sample;
  uint32 src_rowsize, dst_rowsize, rows_processed, rps;
  uint32 rows_this_strip = 0;
  tsample_t s;
  tstrip_t  strip;
  tsize_t scanlinesize = TIFFScanlineSize(in);
  tsize_t stripsize    = TIFFStripSize(in);
  unsigned char *srcbuffs[MAX_SAMPLES];
  unsigned char *buff = NULL;
  unsigned char *dst = NULL;

  if (obuf == NULL)
    {
    TIFFError(""readSeparateStripsIntoBuffer"",""Invalid buffer argument"");
    return (0);
    }

  memset (srcbuffs, '\0', sizeof(srcbuffs));
  TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);
  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);
  TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
  if (rps > length)
    rps = length;

  bytes_per_sample = (bps + 7) / 8; 
  bytes_per_pixel  = ((bps * spp) + 7) / 8;
  if (bytes_per_pixel < (bytes_per_sample + 1))
    shift_width = bytes_per_pixel;
  else
    shift_width = bytes_per_sample + 1;

  src_rowsize = ((bps * width) + 7) / 8;
  dst_rowsize = ((bps * width * spp) + 7) / 8;
  dst = obuf;

  if ((dump->infile != NULL) && (dump->level == 3))
    {
    dump_info  (dump->infile, dump->format, """", 
                ""Image width %d, length %d, Scanline size, %4d bytes"",
                width, length,  scanlinesize);
    dump_info  (dump->infile, dump->format, """", 
                ""Bits per sample %d, Samples per pixel %d, Shift width %d"",
		bps, spp, shift_width);
    }

  /* Libtiff seems to assume/require that data for separate planes are 
   * written one complete plane after another and not interleaved in any way.
   * Multiple scanlines and possibly strips of the same plane must be 
   * written before data for any other plane.
   */
  nstrips = TIFFNumberOfStrips(in);
  strips_per_sample = nstrips /spp;

  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)
    {
    srcbuffs[s] = NULL;
    buff = _TIFFmalloc(stripsize);
    if (!buff)
      {
      TIFFError (""readSeparateStripsIntoBuffer"", 
                 ""Unable to allocate strip read buffer for sample %d"", s);
      for (i = 0; i < s; i++)
        _TIFFfree (srcbuffs[i]);
      return 0;
      }
    srcbuffs[s] = buff;
    }

  rows_processed = 0;
  for (j = 0; (j < strips_per_sample) && (result == 1); j++)
    {
    for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)
      {
      buff = srcbuffs[s];
      strip = (s * strips_per_sample) + j; 
      bytes_read = TIFFReadEncodedStrip (in, strip, buff, stripsize);
      rows_this_strip = bytes_read / src_rowsize;
      if (bytes_read < 0 && !ignore)
        {
        TIFFError(TIFFFileName(in),
	          ""Error, can't read strip %lu for sample %d"",
         	   (unsigned long) strip, s + 1);
        result = 0;
        break;
        }
#ifdef DEVELMODE
      TIFFError("""", ""Strip %2d, read %5d bytes for %4d scanlines, shift width %d"", 
		strip, bytes_read, rows_this_strip, shift_width);
#endif
      }

    if (rps > rows_this_strip)
      rps = rows_this_strip;
    dst = obuf + (dst_rowsize * rows_processed);
    if ((bps % 8) == 0)
      {
      if (combineSeparateSamplesBytes (srcbuffs, dst, width, rps,
                                       spp, bps, dump->infile, 
                                       dump->format, dump->level))
        {
        result = 0;
        break;
	}
      }
    else
      {
      switch (shift_width)
        {
        case 1: if (combineSeparateSamples8bits (srcbuffs, dst, width, rps,
                                                 spp, bps, dump->infile,
                                                 dump->format, dump->level))
	          {
                  result = 0;
                  break;
      	          }
	        break;
        case 2: if (combineSeparateSamples16bits (srcbuffs, dst, width, rps,
                                                  spp, bps, dump->infile,
                                                  dump->format, dump->level))
	          {
                  result = 0;
                  break;
		  }
	        break;
        case 3: if (combineSeparateSamples24bits (srcbuffs, dst, width, rps,
                                                  spp, bps, dump->infile,
                                                  dump->format, dump->level))
	          {
                  result = 0;
                  break;
       	          }
                break;
        case 4: 
        case 5:
        case 6:
        case 7:
        case 8: if (combineSeparateSamples32bits (srcbuffs, dst, width, rps,
                                                  spp, bps, dump->infile,
                                                  dump->format, dump->level))
	          {
                  result = 0;
                  break;
		  }
	        break;
        default: TIFFError (""readSeparateStripsIntoBuffer"", ""Unsupported bit depth: %d"", bps);
                  result = 0;
                  break;
        }
      }
 
    if ((rows_processed + rps) > length)
      {
      rows_processed = length;
      rps = length - rows_processed;
      }
    else
      rows_processed += rps;
    }

  /* free any buffers allocated for each plane or scanline and 
   * any temporary buffers 
   */
  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)
    {
    buff = srcbuffs[s];
    if (buff != NULL)
      _TIFFfree(buff);
    }

  return (result);
  }","static int readSeparateStripsIntoBuffer (TIFF *VAR_0, uint8 *VAR_1, uint32 VAR_2, 
                                         uint32 VAR_3, uint16 VAR_4,
                                         struct dump_opts *VAR_5)
  {
  int VAR_6, VAR_7, VAR_8, VAR_9, VAR_10 = 1;
  uint32 VAR_11;
  int32  VAR_12 = 0;
  uint16 VAR_13, VAR_14;
  uint32 VAR_15;
  uint32 VAR_16;
  uint32 VAR_17, VAR_18, VAR_19, VAR_20;
  uint32 VAR_21 = 0;
  tsample_t VAR_22;
  tstrip_t  VAR_23;
  tsize_t VAR_24 = TIFFScanlineSize(VAR_0);
  tsize_t VAR_25    = TIFFStripSize(VAR_0);
  unsigned char *VAR_26[VAR_27];
  unsigned char *VAR_28 = NULL;
  unsigned char *VAR_29 = NULL;

  if (VAR_1 == NULL)
    {
    TIFFError(""readSeparateStripsIntoBuffer"",""Invalid buffer argument"");
    return (0);
    }

  memset (VAR_26, '\0', sizeof(VAR_26));
  TIFFGetField(VAR_0, VAR_30, &VAR_13);
  TIFFGetFieldDefaulted(VAR_0, VAR_31, &VAR_14);
  TIFFGetFieldDefaulted(VAR_0, VAR_32, &VAR_20);
  if (VAR_20 > VAR_2)
    VAR_20 = VAR_2;

  VAR_7 = (VAR_13 + 7) / 8; 
  VAR_8  = ((VAR_13 * VAR_4) + 7) / 8;
  if (VAR_8 < (VAR_7 + 1))
    VAR_9 = VAR_8;
  else
    VAR_9 = VAR_7 + 1;

  VAR_17 = ((VAR_13 * VAR_3) + 7) / 8;
  VAR_18 = ((VAR_13 * VAR_3 * VAR_4) + 7) / 8;
  VAR_29 = VAR_1;

  if ((VAR_5->infile != NULL) && (VAR_5->level == 3))
    {
    dump_info  (VAR_5->infile, VAR_5->format, """", 
                ""Image width %d, length %d, Scanline size, %4d bytes"",
                VAR_3, VAR_2,  VAR_24);
    dump_info  (VAR_5->infile, VAR_5->format, """", 
                ""Bits per sample %d, Samples per pixel %d, Shift width %d"",
		VAR_13, VAR_4, VAR_9);
    }

  /* COMMENT_0 */
                                                                             
                                                                      
                                             
     
  VAR_15 = TIFFNumberOfStrips(VAR_0);
  VAR_16 = VAR_15 /VAR_4;

  for (VAR_22 = 0; (VAR_22 < VAR_4) && (VAR_22 < VAR_27); VAR_22++)
    {
    VAR_26[VAR_22] = NULL;
    VAR_28 = _TIFFmalloc(VAR_25);
    if (!VAR_28)
      {
      TIFFError (""readSeparateStripsIntoBuffer"", 
                 ""Unable to allocate strip read buffer for sample %d"", VAR_22);
      for (VAR_6 = 0; VAR_6 < VAR_22; VAR_6++)
        _TIFFfree (VAR_26[VAR_6]);
      return 0;
      }
    VAR_26[VAR_22] = VAR_28;
    }

  VAR_19 = 0;
  for (VAR_11 = 0; (VAR_11 < VAR_16) && (VAR_10 == 1); VAR_11++)
    {
    for (VAR_22 = 0; (VAR_22 < VAR_4) && (VAR_22 < VAR_27); VAR_22++)
      {
      VAR_28 = VAR_26[VAR_22];
      VAR_23 = (VAR_22 * VAR_16) + VAR_11; 
      VAR_12 = TIFFReadEncodedStrip (VAR_0, VAR_23, VAR_28, VAR_25);
      VAR_21 = VAR_12 / VAR_17;
      if (VAR_12 < 0 && !VAR_33)
        {
        TIFFError(TIFFFileName(VAR_0),
	          ""Error, can't read strip %lu for sample %d"",
         	   (unsigned long) VAR_23, VAR_22 + 1);
        VAR_10 = 0;
        break;
        }
#ifdef VAR_34
      TIFFError("""", ""Strip %2d, read %5d bytes for %4d scanlines, shift width %d"", 
		VAR_23, VAR_12, VAR_21, VAR_9);
#endif
      }

    if (VAR_20 > VAR_21)
      VAR_20 = VAR_21;
    VAR_29 = VAR_1 + (VAR_18 * VAR_19);
    if ((VAR_13 % 8) == 0)
      {
      if (combineSeparateSamplesBytes (VAR_26, VAR_29, VAR_3, VAR_20,
                                       VAR_4, VAR_13, VAR_5->infile, 
                                       VAR_5->format, VAR_5->level))
        {
        VAR_10 = 0;
        break;
	}
      }
    else
      {
      switch (VAR_9)
        {
        case 1: if (combineSeparateSamples8bits (VAR_26, VAR_29, VAR_3, VAR_20,
                                                 VAR_4, VAR_13, VAR_5->infile,
                                                 VAR_5->format, VAR_5->level))
	          {
                  VAR_10 = 0;
                  break;
      	          }
	        break;
        case 2: if (combineSeparateSamples16bits (VAR_26, VAR_29, VAR_3, VAR_20,
                                                  VAR_4, VAR_13, VAR_5->infile,
                                                  VAR_5->format, VAR_5->level))
	          {
                  VAR_10 = 0;
                  break;
		  }
	        break;
        case 3: if (combineSeparateSamples24bits (VAR_26, VAR_29, VAR_3, VAR_20,
                                                  VAR_4, VAR_13, VAR_5->infile,
                                                  VAR_5->format, VAR_5->level))
	          {
                  VAR_10 = 0;
                  break;
       	          }
                break;
        case 4: 
        case 5:
        case 6:
        case 7:
        case 8: if (combineSeparateSamples32bits (VAR_26, VAR_29, VAR_3, VAR_20,
                                                  VAR_4, VAR_13, VAR_5->infile,
                                                  VAR_5->format, VAR_5->level))
	          {
                  VAR_10 = 0;
                  break;
		  }
	        break;
        default: TIFFError (""readSeparateStripsIntoBuffer"", ""Unsupported bit depth: %d"", VAR_13);
                  VAR_10 = 0;
                  break;
        }
      }
 
    if ((VAR_19 + VAR_20) > VAR_2)
      {
      VAR_19 = VAR_2;
      VAR_20 = VAR_2 - VAR_19;
      }
    else
      VAR_19 += VAR_20;
    }

  /* COMMENT_5 */
                           
     
  for (VAR_22 = 0; (VAR_22 < VAR_4) && (VAR_22 < VAR_27); VAR_22++)
    {
    VAR_28 = VAR_26[VAR_22];
    if (VAR_28 != NULL)
      _TIFFfree(VAR_28);
    }

  return (VAR_10);
  }",vadz/libtiff/43c0b81a818640429317c80fea1e66771e85024b/tiffcrop.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,9 +2,12 @@
                                          uint32 width, uint16 spp,
                                          struct dump_opts *dump)
   {
-  int i, j, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;
+  int i, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;
+  uint32 j;
   int32  bytes_read = 0;
-  uint16 bps, nstrips, planar, strips_per_sample;
+  uint16 bps, planar;
+  uint32 nstrips;
+  uint32 strips_per_sample;
   uint32 src_rowsize, dst_rowsize, rows_processed, rps;
   uint32 rows_this_strip = 0;
   tsample_t s;","{'deleted_lines': ['  int i, j, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;', '  uint16 bps, nstrips, planar, strips_per_sample;'], 'added_lines': ['  int i, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;', '  uint32 j;', '  uint16 bps, planar;', '  uint32 nstrips;', '  uint32 strips_per_sample;']}",True,tools/tiffcrop.c in libtiff 4.0.6 reads an undefined buffer in readContigStripsIntoBuffer() because of a uint16 integer overflow. Reported as MSVR 35100.,9.8,CRITICAL,3,test,2016-10-08T15:04:31Z,1
CVE-2016-9538,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,vadz/libtiff,"* tools/tiffcp.c: fix read of undefined variable in case of missing
required tags. Found on test case of MSVR 35100.
* tools/tiffcrop.c: fix read of undefined buffer in
readContigStripsIntoBuffer() due to uint16 overflow. Probably not a
security issue but I can be wrong. Reported as MSVR 35100 by Axel
Souchet from the MSRC Vulnerabilities & Mitigations team.",43c0b81a818640429317c80fea1e66771e85024b,https://github.com/vadz/libtiff/commit/43c0b81a818640429317c80fea1e66771e85024b,tools/tiffcrop.c,readContigStripsIntoBuffer,"static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
{
uint8* bufp = buf;
int32  bytes_read = 0;
uint16 strip, nstrips   = TIFFNumberOfStrips(in);
uint32 stripsize = TIFFStripSize(in);
uint32 rows = 0;
uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
tsize_t scanline_size = TIFFScanlineSize(in);
if (scanline_size == 0) {
TIFFError("""", ""TIFF scanline size is zero!"");    
return 0;
}
for (strip = 0; strip < nstrips; strip++) {
bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
rows = bytes_read / scanline_size;
if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
TIFFError("""", ""Strip %d: read %lu bytes, strip size %lu"",
(int)strip + 1, (unsigned long) bytes_read,
(unsigned long)stripsize);
if (bytes_read < 0 && !ignore) {
TIFFError("""", ""Error reading strip %lu after %lu rows"",
(unsigned long) strip, (unsigned long)rows);
return 0;
}
bufp += bytes_read;
}
return 1;
}","static int readContigStripsIntoBuffer (TIFF* VAR_0, uint8* VAR_1)
{
uint8* VAR_2 = VAR_1;
int32  VAR_3 = 0;
uint16 VAR_4, VAR_5   = TIFFNumberOfStrips(VAR_0);
uint32 VAR_6 = TIFFStripSize(VAR_0);
uint32 VAR_7 = 0;
uint32 VAR_8 = TIFFGetFieldDefaulted(VAR_0, VAR_9, &VAR_8);
tsize_t VAR_10 = TIFFScanlineSize(VAR_0);
if (VAR_10 == 0) {
TIFFError("""", ""TIFF scanline size is zero!"");    
return 0;
}
for (VAR_4 = 0; VAR_4 < VAR_5; VAR_4++) {
VAR_3 = TIFFReadEncodedStrip (VAR_0, VAR_4, VAR_2, -1);
VAR_7 = VAR_3 / VAR_10;
if ((VAR_4 < (VAR_5 - 1)) && (VAR_3 != (int32)VAR_6))
TIFFError("""", ""Strip %d: read %lu bytes, strip size %lu"",
(int)VAR_4 + 1, (unsigned long) VAR_3,
(unsigned long)VAR_6);
if (VAR_3 < 0 && !VAR_11) {
TIFFError("""", ""Error reading strip %lu after %lu rows"",
(unsigned long) VAR_4, (unsigned long)VAR_7);
return 0;
}
VAR_2 += VAR_3;
}
return 1;
}",vadz/libtiff/43c0b81a818640429317c80fea1e66771e85024b/tiffcrop.c/vul/before/1.json,"static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
{
        uint8* bufp = buf;
        int32  bytes_read = 0;
        uint32 strip, nstrips   = TIFFNumberOfStrips(in);
        uint32 stripsize = TIFFStripSize(in);
        uint32 rows = 0;
        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
        tsize_t scanline_size = TIFFScanlineSize(in);

        if (scanline_size == 0) {
                TIFFError("""", ""TIFF scanline size is zero!"");    
                return 0;
        }

        for (strip = 0; strip < nstrips; strip++) {
                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
                rows = bytes_read / scanline_size;
                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
                        TIFFError("""", ""Strip %d: read %lu bytes, strip size %lu"",
                                  (int)strip + 1, (unsigned long) bytes_read,
                                  (unsigned long)stripsize);

                if (bytes_read < 0 && !ignore) {
                        TIFFError("""", ""Error reading strip %lu after %lu rows"",
                                  (unsigned long) strip, (unsigned long)rows);
                        return 0;
                }
                bufp += bytes_read;
        }

        return 1;
}","static int readContigStripsIntoBuffer (TIFF* VAR_0, uint8* VAR_1)
{
        uint8* VAR_2 = VAR_1;
        int32  VAR_3 = 0;
        uint32 VAR_4, VAR_5   = TIFFNumberOfStrips(VAR_0);
        uint32 VAR_6 = TIFFStripSize(VAR_0);
        uint32 VAR_7 = 0;
        uint32 VAR_8 = TIFFGetFieldDefaulted(VAR_0, VAR_9, &VAR_8);
        tsize_t VAR_10 = TIFFScanlineSize(VAR_0);

        if (VAR_10 == 0) {
                TIFFError("""", ""TIFF scanline size is zero!"");    
                return 0;
        }

        for (VAR_4 = 0; VAR_4 < VAR_5; VAR_4++) {
                VAR_3 = TIFFReadEncodedStrip (VAR_0, VAR_4, VAR_2, -1);
                VAR_7 = VAR_3 / VAR_10;
                if ((VAR_4 < (VAR_5 - 1)) && (VAR_3 != (int32)VAR_6))
                        TIFFError("""", ""Strip %d: read %lu bytes, strip size %lu"",
                                  (int)VAR_4 + 1, (unsigned long) VAR_3,
                                  (unsigned long)VAR_6);

                if (VAR_3 < 0 && !VAR_11) {
                        TIFFError("""", ""Error reading strip %lu after %lu rows"",
                                  (unsigned long) VAR_4, (unsigned long)VAR_7);
                        return 0;
                }
                VAR_2 += VAR_3;
        }

        return 1;
}",vadz/libtiff/43c0b81a818640429317c80fea1e66771e85024b/tiffcrop.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 {
         uint8* bufp = buf;
         int32  bytes_read = 0;
-        uint16 strip, nstrips   = TIFFNumberOfStrips(in);
+        uint32 strip, nstrips   = TIFFNumberOfStrips(in);
         uint32 stripsize = TIFFStripSize(in);
         uint32 rows = 0;
         uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);","{'deleted_lines': ['        uint16 strip, nstrips   = TIFFNumberOfStrips(in);'], 'added_lines': ['        uint32 strip, nstrips   = TIFFNumberOfStrips(in);']}",True,tools/tiffcrop.c in libtiff 4.0.6 reads an undefined buffer in readContigStripsIntoBuffer() because of a uint16 integer overflow. Reported as MSVR 35100.,9.8,CRITICAL,3,test,2016-10-08T15:04:31Z,1
CVE-2016-9538,['CWE-190'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,vadz/libtiff,"* tools/tiffcp.c: fix read of undefined variable in case of missing
required tags. Found on test case of MSVR 35100.
* tools/tiffcrop.c: fix read of undefined buffer in
readContigStripsIntoBuffer() due to uint16 overflow. Probably not a
security issue but I can be wrong. Reported as MSVR 35100 by Axel
Souchet from the MSRC Vulnerabilities & Mitigations team.",43c0b81a818640429317c80fea1e66771e85024b,https://github.com/vadz/libtiff/commit/43c0b81a818640429317c80fea1e66771e85024b,tools/tiffcp.c,tiffcp,"static int
tiffcp(TIFF* in, TIFF* out)
{
uint16 bitspersample, samplesperpixel;
uint16 input_compression, input_photometric;
copyFunc cf;
uint32 width, length;
struct cpTag* p;
CopyField(TIFFTAG_IMAGEWIDTH, width);
CopyField(TIFFTAG_IMAGELENGTH, length);
CopyField(TIFFTAG_BITSPERSAMPLE, bitspersample);
CopyField(TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);
if (compression != (uint16)-1)
TIFFSetField(out, TIFFTAG_COMPRESSION, compression);
else
CopyField(TIFFTAG_COMPRESSION, compression);
TIFFGetFieldDefaulted(in, TIFFTAG_COMPRESSION, &input_compression);
TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric);
if (input_compression == COMPRESSION_JPEG) {
TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
} else if (input_photometric == PHOTOMETRIC_YCBCR) {
uint16 subsamplinghor,subsamplingver;
TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,
&subsamplinghor, &subsamplingver);
if (subsamplinghor!=1 || subsamplingver!=1) {
fprintf(stderr, ""tiffcp: %s: Can't copy/convert subsampled image.\n"",
TIFFFileName(in));
return FALSE;
}
}
if (compression == COMPRESSION_JPEG) {
if (input_photometric == PHOTOMETRIC_RGB &&
jpegcolormode == JPEGCOLORMODE_RGB)
TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
else
TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);
}
else if (compression == COMPRESSION_SGILOG
|| compression == COMPRESSION_SGILOG24)
TIFFSetField(out, TIFFTAG_PHOTOMETRIC,
samplesperpixel == 1 ?
PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);
else if (input_compression == COMPRESSION_JPEG &&
samplesperpixel == 3 ) {
TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
}
else
CopyTag(TIFFTAG_PHOTOMETRIC, 1, TIFF_SHORT);
if (fillorder != 0)
TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);
else
CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);
TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);
switch (orientation) {
case ORIENTATION_BOTRIGHT:
case ORIENTATION_RIGHTBOT:
TIFFWarning(TIFFFileName(in), ""using bottom-left orientation"");
orientation = ORIENTATION_BOTLEFT;
case ORIENTATION_LEFTBOT:
case ORIENTATION_BOTLEFT:
break;
case ORIENTATION_TOPRIGHT:
case ORIENTATION_RIGHTTOP:
default:
TIFFWarning(TIFFFileName(in), ""using top-left orientation"");
orientation = ORIENTATION_TOPLEFT;
case ORIENTATION_LEFTTOP:
case ORIENTATION_TOPLEFT:
break;
}
TIFFSetField(out, TIFFTAG_ORIENTATION, orientation);
if (outtiled == -1)
outtiled = TIFFIsTiled(in);
if (outtiled) {
if (tilewidth == (uint32) -1)
TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);
if (tilelength == (uint32) -1)
TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);
TIFFDefaultTileSize(out, &tilewidth, &tilelength);
TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);
TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);
} else {
if (rowsperstrip == (uint32) 0) {
if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP,
&rowsperstrip)) {
rowsperstrip =
TIFFDefaultStripSize(out, rowsperstrip);
}
if (rowsperstrip > length && rowsperstrip != (uint32)-1)
rowsperstrip = length;
}
else if (rowsperstrip == (uint32) -1)
rowsperstrip = length;
TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);
}
if (config != (uint16) -1)
TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);
else
CopyField(TIFFTAG_PLANARCONFIG, config);
if (samplesperpixel <= 4)
CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);
CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);
switch (compression) {
case COMPRESSION_JPEG:
TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);
TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);
break;
case COMPRESSION_JBIG:
CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);
CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);
CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);
CopyTag(TIFFTAG_FAXDCS, 1, TIFF_ASCII);
break;
case COMPRESSION_LZW:
case COMPRESSION_ADOBE_DEFLATE:
case COMPRESSION_DEFLATE:
case COMPRESSION_LZMA:
if (predictor != (uint16)-1)
TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);
else
CopyField(TIFFTAG_PREDICTOR, predictor);
if (preset != -1) {
if (compression == COMPRESSION_ADOBE_DEFLATE
|| compression == COMPRESSION_DEFLATE)
TIFFSetField(out, TIFFTAG_ZIPQUALITY, preset);
else if (compression == COMPRESSION_LZMA)
TIFFSetField(out, TIFFTAG_LZMAPRESET, preset);
}
break;
case COMPRESSION_CCITTFAX3:
case COMPRESSION_CCITTFAX4:
if (compression == COMPRESSION_CCITTFAX3) {
if (g3opts != (uint32) -1)
TIFFSetField(out, TIFFTAG_GROUP3OPTIONS,
g3opts);
else
CopyField(TIFFTAG_GROUP3OPTIONS, g3opts);
} else
CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);
CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);
CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);
CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);
CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);
CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);
CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);
break;
}
{
uint32 len32;
void** data;
if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))
TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);
}
{
uint16 ninks;
const char* inknames;
if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {
TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);
if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {
int inknameslen = strlen(inknames) + 1;
const char* cp = inknames;
while (ninks > 1) {
cp = strchr(cp, '\0');
cp++;
inknameslen += (strlen(cp) + 1);
ninks--;
}
TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);
}
}
}
{
unsigned short pg0, pg1;
if (pageInSeq == 1) {
if (pageNum < 0)  {
if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1))
TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);
} else
TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);
} else {
if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {
if (pageNum < 0) 
TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);
else
TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);
}
}
}
for (p = tags; p < &tags[NTAGS]; p++)
CopyTag(p->tag, p->count, p->type);
cf = pickCopyFunc(in, out, bitspersample, samplesperpixel);
return (cf ? (*cf)(in, out, length, width, samplesperpixel) : FALSE);
}","static int
tiffcp(TIFF* VAR_0, TIFF* VAR_1)
{
uint16 VAR_2, VAR_3;
uint16 VAR_4, VAR_5;
copyFunc VAR_6;
uint32 VAR_7, VAR_8;
struct cpTag* VAR_9;
CopyField(VAR_10, VAR_7);
CopyField(VAR_11, VAR_8);
CopyField(VAR_12, VAR_2);
CopyField(VAR_13, VAR_3);
if (VAR_14 != (uint16)-1)
TIFFSetField(VAR_1, VAR_15, VAR_14);
else
CopyField(VAR_15, VAR_14);
TIFFGetFieldDefaulted(VAR_0, VAR_15, &VAR_4);
TIFFGetFieldDefaulted(VAR_0, VAR_16, &VAR_5);
if (VAR_4 == VAR_17) {
TIFFSetField(VAR_0, VAR_18, VAR_19);
} else if (VAR_5 == VAR_20) {
uint16 VAR_21,VAR_22;
TIFFGetFieldDefaulted(VAR_0, VAR_23,
&VAR_21, &VAR_22);
if (VAR_21!=1 || VAR_22!=1) {
fprintf(VAR_24, ""tiffcp: %s: Can't copy/convert subsampled image.\n"",
TIFFFileName(VAR_0));
return FALSE;
}
}
if (VAR_14 == VAR_17) {
if (VAR_5 == VAR_25 &&
VAR_26 == VAR_19)
TIFFSetField(VAR_1, VAR_16, VAR_20);
else
TIFFSetField(VAR_1, VAR_16, VAR_5);
}
else if (VAR_14 == VAR_27
|| VAR_14 == VAR_28)
TIFFSetField(VAR_1, VAR_16,
VAR_3 == 1 ?
VAR_29 : VAR_30);
else if (VAR_4 == VAR_17 &&
VAR_3 == 3 ) {
TIFFSetField(VAR_1, VAR_16, VAR_25);
}
else
CopyTag(VAR_16, 1, VAR_31);
if (VAR_32 != 0)
TIFFSetField(VAR_1, VAR_33, VAR_32);
else
CopyTag(VAR_33, 1, VAR_31);
TIFFGetFieldDefaulted(VAR_0, VAR_34, &VAR_35);
switch (VAR_35) {
case VAR_36:
case VAR_37:
TIFFWarning(TIFFFileName(VAR_0), ""using bottom-left orientation"");
VAR_35 = VAR_38;
case VAR_39:
case VAR_38:
break;
case VAR_40:
case VAR_41:
default:
TIFFWarning(TIFFFileName(VAR_0), ""using top-left orientation"");
VAR_35 = VAR_42;
case VAR_43:
case VAR_42:
break;
}
TIFFSetField(VAR_1, VAR_34, VAR_35);
if (VAR_44 == -1)
VAR_44 = TIFFIsTiled(VAR_0);
if (VAR_44) {
if (VAR_45 == (uint32) -1)
TIFFGetField(VAR_0, VAR_46, &VAR_45);
if (VAR_47 == (uint32) -1)
TIFFGetField(VAR_0, VAR_48, &VAR_47);
TIFFDefaultTileSize(VAR_1, &VAR_45, &VAR_47);
TIFFSetField(VAR_1, VAR_46, VAR_45);
TIFFSetField(VAR_1, VAR_48, VAR_47);
} else {
if (VAR_49 == (uint32) 0) {
if (!TIFFGetField(VAR_0, VAR_50,
&VAR_49)) {
VAR_49 =
TIFFDefaultStripSize(VAR_1, VAR_49);
}
if (VAR_49 > VAR_8 && VAR_49 != (uint32)-1)
VAR_49 = VAR_8;
}
else if (VAR_49 == (uint32) -1)
VAR_49 = VAR_8;
TIFFSetField(VAR_1, VAR_50, VAR_49);
}
if (VAR_51 != (uint16) -1)
TIFFSetField(VAR_1, VAR_52, VAR_51);
else
CopyField(VAR_52, VAR_51);
if (VAR_3 <= 4)
CopyTag(VAR_53, 4, VAR_31);
CopyTag(VAR_54, 4, VAR_31);
switch (VAR_14) {
case VAR_17:
TIFFSetField(VAR_1, VAR_55, VAR_56);
TIFFSetField(VAR_1, VAR_18, VAR_26);
break;
case VAR_57:
CopyTag(VAR_58, 1, VAR_59);
CopyTag(VAR_60, 1, VAR_59);
CopyTag(VAR_61, 1, VAR_62);
CopyTag(VAR_63, 1, VAR_62);
break;
case VAR_64:
case VAR_65:
case VAR_66:
case VAR_67:
if (VAR_68 != (uint16)-1)
TIFFSetField(VAR_1, VAR_69, VAR_68);
else
CopyField(VAR_69, VAR_68);
if (VAR_70 != -1) {
if (VAR_14 == VAR_65
|| VAR_14 == VAR_66)
TIFFSetField(VAR_1, VAR_71, VAR_70);
else if (VAR_14 == VAR_67)
TIFFSetField(VAR_1, VAR_72, VAR_70);
}
break;
case VAR_73:
case VAR_74:
if (VAR_14 == VAR_73) {
if (VAR_75 != (uint32) -1)
TIFFSetField(VAR_1, VAR_76,
VAR_75);
else
CopyField(VAR_76, VAR_75);
} else
CopyTag(VAR_77, 1, VAR_59);
CopyTag(VAR_78, 1, VAR_59);
CopyTag(VAR_79, 1, VAR_59);
CopyTag(VAR_80, 1, VAR_59);
CopyTag(VAR_58, 1, VAR_59);
CopyTag(VAR_60, 1, VAR_59);
CopyTag(VAR_61, 1, VAR_62);
break;
}
{
uint32 VAR_81;
void** VAR_82;
if (TIFFGetField(VAR_0, VAR_83, &VAR_81, &VAR_82))
TIFFSetField(VAR_1, VAR_83, VAR_81, VAR_82);
}
{
uint16 VAR_84;
const char* VAR_85;
if (TIFFGetField(VAR_0, VAR_86, &VAR_84)) {
TIFFSetField(VAR_1, VAR_86, VAR_84);
if (TIFFGetField(VAR_0, VAR_87, &VAR_85)) {
int VAR_88 = strlen(VAR_85) + 1;
const char* VAR_89 = VAR_85;
while (VAR_84 > 1) {
VAR_89 = strchr(VAR_89, '\0');
VAR_89++;
VAR_88 += (strlen(VAR_89) + 1);
VAR_84--;
}
TIFFSetField(VAR_1, VAR_87, VAR_88, VAR_85);
}
}
}
{
unsigned short VAR_90, VAR_91;
if (VAR_92 == 1) {
if (VAR_93 < 0)  {
if (TIFFGetField(VAR_0, VAR_94, &VAR_90, &VAR_91))
TIFFSetField(VAR_1, VAR_94, VAR_90, VAR_91);
} else
TIFFSetField(VAR_1, VAR_94, VAR_93++, 0);
} else {
if (TIFFGetField(VAR_0, VAR_94, &VAR_90, &VAR_91)) {
if (VAR_93 < 0) 
TIFFSetField(VAR_1, VAR_94, VAR_90, VAR_91);
else
TIFFSetField(VAR_1, VAR_94, VAR_93++, 0);
}
}
}
for (VAR_9 = VAR_95; VAR_9 < &VAR_95[VAR_96]; VAR_9++)
CopyTag(VAR_9->tag, VAR_9->count, VAR_9->type);
VAR_6 = pickCopyFunc(VAR_0, VAR_1, VAR_2, VAR_3);
return (VAR_6 ? (*VAR_6)(VAR_0, VAR_1, VAR_8, VAR_7, VAR_3) : FALSE);
}",vadz/libtiff/43c0b81a818640429317c80fea1e66771e85024b/tiffcp.c/vul/before/0.json,"static int
tiffcp(TIFF* in, TIFF* out)
{
	uint16 bitspersample, samplesperpixel = 1;
	uint16 input_compression, input_photometric = PHOTOMETRIC_MINISBLACK;
	copyFunc cf;
	uint32 width, length;
	struct cpTag* p;

	CopyField(TIFFTAG_IMAGEWIDTH, width);
	CopyField(TIFFTAG_IMAGELENGTH, length);
	CopyField(TIFFTAG_BITSPERSAMPLE, bitspersample);
	CopyField(TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);
	if (compression != (uint16)-1)
		TIFFSetField(out, TIFFTAG_COMPRESSION, compression);
	else
		CopyField(TIFFTAG_COMPRESSION, compression);
	TIFFGetFieldDefaulted(in, TIFFTAG_COMPRESSION, &input_compression);
	TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric);
	if (input_compression == COMPRESSION_JPEG) {
		/* Force conversion to RGB */
		TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
	} else if (input_photometric == PHOTOMETRIC_YCBCR) {
		/* Otherwise, can't handle subsampled input */
		uint16 subsamplinghor,subsamplingver;

		TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,
				      &subsamplinghor, &subsamplingver);
		if (subsamplinghor!=1 || subsamplingver!=1) {
			fprintf(stderr, ""tiffcp: %s: Can't copy/convert subsampled image.\n"",
				TIFFFileName(in));
			return FALSE;
		}
	}
	if (compression == COMPRESSION_JPEG) {
		if (input_photometric == PHOTOMETRIC_RGB &&
		    jpegcolormode == JPEGCOLORMODE_RGB)
		  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
		else
		  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);
	}
	else if (compression == COMPRESSION_SGILOG
	    || compression == COMPRESSION_SGILOG24)
		TIFFSetField(out, TIFFTAG_PHOTOMETRIC,
		    samplesperpixel == 1 ?
		    PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);
	else if (input_compression == COMPRESSION_JPEG &&
			 samplesperpixel == 3 ) {
		/* RGB conversion was forced above
		hence the output will be of the same type */
		TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
	}
	else
		CopyTag(TIFFTAG_PHOTOMETRIC, 1, TIFF_SHORT);
	if (fillorder != 0)
		TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);
	else
		CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);
	/*
	 * Will copy `Orientation' tag from input image
	 */
	TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);
	switch (orientation) {
		case ORIENTATION_BOTRIGHT:
		case ORIENTATION_RIGHTBOT:	/* XXX */
			TIFFWarning(TIFFFileName(in), ""using bottom-left orientation"");
			orientation = ORIENTATION_BOTLEFT;
		/* fall thru... */
		case ORIENTATION_LEFTBOT:	/* XXX */
		case ORIENTATION_BOTLEFT:
			break;
		case ORIENTATION_TOPRIGHT:
		case ORIENTATION_RIGHTTOP:	/* XXX */
		default:
			TIFFWarning(TIFFFileName(in), ""using top-left orientation"");
			orientation = ORIENTATION_TOPLEFT;
		/* fall thru... */
		case ORIENTATION_LEFTTOP:	/* XXX */
		case ORIENTATION_TOPLEFT:
			break;
	}
	TIFFSetField(out, TIFFTAG_ORIENTATION, orientation);
	/*
	 * Choose tiles/strip for the output image according to
	 * the command line arguments (-tiles, -strips) and the
	 * structure of the input image.
	 */
	if (outtiled == -1)
		outtiled = TIFFIsTiled(in);
	if (outtiled) {
		/*
		 * Setup output file's tile width&height.  If either
		 * is not specified, use either the value from the
		 * input image or, if nothing is defined, use the
		 * library default.
		 */
		if (tilewidth == (uint32) -1)
			TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);
		if (tilelength == (uint32) -1)
			TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);
		TIFFDefaultTileSize(out, &tilewidth, &tilelength);
		TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);
		TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);
	} else {
		/*
		 * RowsPerStrip is left unspecified: use either the
		 * value from the input image or, if nothing is defined,
		 * use the library default.
		 */
		if (rowsperstrip == (uint32) 0) {
			if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP,
			    &rowsperstrip)) {
				rowsperstrip =
				    TIFFDefaultStripSize(out, rowsperstrip);
			}
			if (rowsperstrip > length && rowsperstrip != (uint32)-1)
				rowsperstrip = length;
		}
		else if (rowsperstrip == (uint32) -1)
			rowsperstrip = length;
		TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);
	}
	if (config != (uint16) -1)
		TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);
	else
		CopyField(TIFFTAG_PLANARCONFIG, config);
	if (samplesperpixel <= 4)
		CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);
	CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);
/* SMinSampleValue & SMaxSampleValue */
	switch (compression) {
		case COMPRESSION_JPEG:
			TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);
			TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);
			break;
		case COMPRESSION_JBIG:
			CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);
			CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);
			CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);
			CopyTag(TIFFTAG_FAXDCS, 1, TIFF_ASCII);
			break;
		case COMPRESSION_LZW:
		case COMPRESSION_ADOBE_DEFLATE:
		case COMPRESSION_DEFLATE:
                case COMPRESSION_LZMA:
			if (predictor != (uint16)-1)
				TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);
			else
				CopyField(TIFFTAG_PREDICTOR, predictor);
			if (preset != -1) {
                                if (compression == COMPRESSION_ADOBE_DEFLATE
                                         || compression == COMPRESSION_DEFLATE)
                                        TIFFSetField(out, TIFFTAG_ZIPQUALITY, preset);
				else if (compression == COMPRESSION_LZMA)
					TIFFSetField(out, TIFFTAG_LZMAPRESET, preset);
                        }
			break;
		case COMPRESSION_CCITTFAX3:
		case COMPRESSION_CCITTFAX4:
			if (compression == COMPRESSION_CCITTFAX3) {
				if (g3opts != (uint32) -1)
					TIFFSetField(out, TIFFTAG_GROUP3OPTIONS,
					    g3opts);
				else
					CopyField(TIFFTAG_GROUP3OPTIONS, g3opts);
			} else
				CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);
			CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);
			CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);
			CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);
			CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);
			CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);
			CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);
			break;
	}
	{
		uint32 len32;
		void** data;
		if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))
			TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);
	}
	{
		uint16 ninks;
		const char* inknames;
		if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {
			TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);
			if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {
				int inknameslen = strlen(inknames) + 1;
				const char* cp = inknames;
				while (ninks > 1) {
					cp = strchr(cp, '\0');
                                        cp++;
                                        inknameslen += (strlen(cp) + 1);
					ninks--;
				}
				TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);
			}
		}
	}
	{
		unsigned short pg0, pg1;

		if (pageInSeq == 1) {
			if (pageNum < 0) /* only one input file */ {
				if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1))
					TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);
			} else
				TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);

		} else {
			if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {
				if (pageNum < 0) /* only one input file */
					TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);
				else
					TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);
			}
		}
	}

	for (p = tags; p < &tags[NTAGS]; p++)
		CopyTag(p->tag, p->count, p->type);

	cf = pickCopyFunc(in, out, bitspersample, samplesperpixel);
	return (cf ? (*cf)(in, out, length, width, samplesperpixel) : FALSE);
}","static int
tiffcp(TIFF* VAR_0, TIFF* VAR_1)
{
	uint16 VAR_2, VAR_3 = 1;
	uint16 VAR_4, VAR_5 = VAR_6;
	copyFunc VAR_7;
	uint32 VAR_8, VAR_9;
	struct cpTag* VAR_10;

	CopyField(VAR_11, VAR_8);
	CopyField(VAR_12, VAR_9);
	CopyField(VAR_13, VAR_2);
	CopyField(VAR_14, VAR_3);
	if (VAR_15 != (uint16)-1)
		TIFFSetField(VAR_1, VAR_16, VAR_15);
	else
		CopyField(VAR_16, VAR_15);
	TIFFGetFieldDefaulted(VAR_0, VAR_16, &VAR_4);
	TIFFGetFieldDefaulted(VAR_0, VAR_17, &VAR_5);
	if (VAR_4 == VAR_18) {
		/* COMMENT_0 */
		TIFFSetField(VAR_0, VAR_19, VAR_20);
	} else if (VAR_5 == VAR_21) {
		/* COMMENT_1 */
		uint16 VAR_22,VAR_23;

		TIFFGetFieldDefaulted(VAR_0, VAR_24,
				      &VAR_22, &VAR_23);
		if (VAR_22!=1 || VAR_23!=1) {
			fprintf(VAR_25, ""tiffcp: %s: Can't copy/convert subsampled image.\n"",
				TIFFFileName(VAR_0));
			return FALSE;
		}
	}
	if (VAR_15 == VAR_18) {
		if (VAR_5 == VAR_26 &&
		    VAR_27 == VAR_20)
		  TIFFSetField(VAR_1, VAR_17, VAR_21);
		else
		  TIFFSetField(VAR_1, VAR_17, VAR_5);
	}
	else if (VAR_15 == VAR_28
	    || VAR_15 == VAR_29)
		TIFFSetField(VAR_1, VAR_17,
		    VAR_3 == 1 ?
		    VAR_30 : VAR_31);
	else if (VAR_4 == VAR_18 &&
			 VAR_3 == 3 ) {
		/* COMMENT_2 */
                                              
		TIFFSetField(VAR_1, VAR_17, VAR_26);
	}
	else
		CopyTag(VAR_17, 1, VAR_32);
	if (VAR_33 != 0)
		TIFFSetField(VAR_1, VAR_34, VAR_33);
	else
		CopyTag(VAR_34, 1, VAR_32);
	/* COMMENT_4 */
                                                
    
	TIFFGetFieldDefaulted(VAR_0, VAR_35, &VAR_36);
	switch (VAR_36) {
		case VAR_37:
		case VAR_38:	/* COMMENT_7 */
			TIFFWarning(TIFFFileName(VAR_0), ""using bottom-left orientation"");
			VAR_36 = VAR_39;
		/* COMMENT_8 */
		case VAR_40:	/* COMMENT_7 */
		case VAR_39:
			break;
		case VAR_41:
		case VAR_42:	/* COMMENT_7 */
		default:
			TIFFWarning(TIFFFileName(VAR_0), ""using top-left orientation"");
			VAR_36 = VAR_43;
		/* COMMENT_8 */
		case VAR_44:	/* COMMENT_7 */
		case VAR_43:
			break;
	}
	TIFFSetField(VAR_1, VAR_35, VAR_36);
	/* COMMENT_9 */
                                                        
                                                        
                                 
    
	if (VAR_45 == -1)
		VAR_45 = TIFFIsTiled(VAR_0);
	if (VAR_45) {
		/* COMMENT_14 */
                                                      
                                                    
                                                   
                     
     
		if (VAR_46 == (uint32) -1)
			TIFFGetField(VAR_0, VAR_47, &VAR_46);
		if (VAR_48 == (uint32) -1)
			TIFFGetField(VAR_0, VAR_49, &VAR_48);
		TIFFDefaultTileSize(VAR_1, &VAR_46, &VAR_48);
		TIFFSetField(VAR_1, VAR_47, VAR_46);
		TIFFSetField(VAR_1, VAR_49, VAR_48);
	} else {
		/* COMMENT_20 */
                                                     
                                                          
                             
     
		if (VAR_50 == (uint32) 0) {
			if (!TIFFGetField(VAR_0, VAR_51,
			    &VAR_50)) {
				VAR_50 =
				    TIFFDefaultStripSize(VAR_1, VAR_50);
			}
			if (VAR_50 > VAR_9 && VAR_50 != (uint32)-1)
				VAR_50 = VAR_9;
		}
		else if (VAR_50 == (uint32) -1)
			VAR_50 = VAR_9;
		TIFFSetField(VAR_1, VAR_51, VAR_50);
	}
	if (VAR_52 != (uint16) -1)
		TIFFSetField(VAR_1, VAR_53, VAR_52);
	else
		CopyField(VAR_53, VAR_52);
	if (VAR_3 <= 4)
		CopyTag(VAR_54, 4, VAR_32);
	CopyTag(VAR_55, 4, VAR_32);
/* COMMENT_25 */
	switch (VAR_15) {
		case VAR_18:
			TIFFSetField(VAR_1, VAR_56, VAR_57);
			TIFFSetField(VAR_1, VAR_19, VAR_27);
			break;
		case VAR_58:
			CopyTag(VAR_59, 1, VAR_60);
			CopyTag(VAR_61, 1, VAR_60);
			CopyTag(VAR_62, 1, VAR_63);
			CopyTag(VAR_64, 1, VAR_63);
			break;
		case VAR_65:
		case VAR_66:
		case VAR_67:
                case VAR_68:
			if (VAR_69 != (uint16)-1)
				TIFFSetField(VAR_1, VAR_70, VAR_69);
			else
				CopyField(VAR_70, VAR_69);
			if (VAR_71 != -1) {
                                if (VAR_15 == VAR_66
                                         || VAR_15 == VAR_67)
                                        TIFFSetField(VAR_1, VAR_72, VAR_71);
				else if (VAR_15 == VAR_68)
					TIFFSetField(VAR_1, VAR_73, VAR_71);
                        }
			break;
		case VAR_74:
		case VAR_75:
			if (VAR_15 == VAR_74) {
				if (VAR_76 != (uint32) -1)
					TIFFSetField(VAR_1, VAR_77,
					    VAR_76);
				else
					CopyField(VAR_77, VAR_76);
			} else
				CopyTag(VAR_78, 1, VAR_60);
			CopyTag(VAR_79, 1, VAR_60);
			CopyTag(VAR_80, 1, VAR_60);
			CopyTag(VAR_81, 1, VAR_60);
			CopyTag(VAR_59, 1, VAR_60);
			CopyTag(VAR_61, 1, VAR_60);
			CopyTag(VAR_62, 1, VAR_63);
			break;
	}
	{
		uint32 VAR_82;
		void** VAR_83;
		if (TIFFGetField(VAR_0, VAR_84, &VAR_82, &VAR_83))
			TIFFSetField(VAR_1, VAR_84, VAR_82, VAR_83);
	}
	{
		uint16 VAR_85;
		const char* VAR_86;
		if (TIFFGetField(VAR_0, VAR_87, &VAR_85)) {
			TIFFSetField(VAR_1, VAR_87, VAR_85);
			if (TIFFGetField(VAR_0, VAR_88, &VAR_86)) {
				int VAR_89 = strlen(VAR_86) + 1;
				const char* VAR_90 = VAR_86;
				while (VAR_85 > 1) {
					VAR_90 = strchr(VAR_90, '\0');
                                        VAR_90++;
                                        VAR_89 += (strlen(VAR_90) + 1);
					VAR_85--;
				}
				TIFFSetField(VAR_1, VAR_88, VAR_89, VAR_86);
			}
		}
	}
	{
		unsigned short VAR_91, VAR_92;

		if (VAR_93 == 1) {
			if (VAR_94 < 0) /* COMMENT_26 */ {
				if (TIFFGetField(VAR_0, VAR_95, &VAR_91, &VAR_92))
					TIFFSetField(VAR_1, VAR_95, VAR_91, VAR_92);
			} else
				TIFFSetField(VAR_1, VAR_95, VAR_94++, 0);

		} else {
			if (TIFFGetField(VAR_0, VAR_95, &VAR_91, &VAR_92)) {
				if (VAR_94 < 0) /* COMMENT_26 */
					TIFFSetField(VAR_1, VAR_95, VAR_91, VAR_92);
				else
					TIFFSetField(VAR_1, VAR_95, VAR_94++, 0);
			}
		}
	}

	for (VAR_10 = VAR_96; VAR_10 < &VAR_96[VAR_97]; VAR_10++)
		CopyTag(VAR_10->tag, VAR_10->count, VAR_10->type);

	VAR_7 = pickCopyFunc(VAR_0, VAR_1, VAR_2, VAR_3);
	return (VAR_7 ? (*VAR_7)(VAR_0, VAR_1, VAR_9, VAR_8, VAR_3) : FALSE);
}",vadz/libtiff/43c0b81a818640429317c80fea1e66771e85024b/tiffcp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,8 +1,8 @@
 static int
 tiffcp(TIFF* in, TIFF* out)
 {
-	uint16 bitspersample, samplesperpixel;
-	uint16 input_compression, input_photometric;
+	uint16 bitspersample, samplesperpixel = 1;
+	uint16 input_compression, input_photometric = PHOTOMETRIC_MINISBLACK;
 	copyFunc cf;
 	uint32 width, length;
 	struct cpTag* p;","{'deleted_lines': ['\tuint16 bitspersample, samplesperpixel;', '\tuint16 input_compression, input_photometric;'], 'added_lines': ['\tuint16 bitspersample, samplesperpixel = 1;', '\tuint16 input_compression, input_photometric = PHOTOMETRIC_MINISBLACK;']}",True,tools/tiffcrop.c in libtiff 4.0.6 reads an undefined buffer in readContigStripsIntoBuffer() because of a uint16 integer overflow. Reported as MSVR 35100.,9.8,CRITICAL,3,test,2016-10-08T15:04:31Z,1
CVE-2016-9083,"['CWE-119', 'CWE-190']",AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"vfio/pci: Fix integer overflows, bitmask check

The VFIO_DEVICE_SET_IRQS ioctl did not sufficiently sanitize
user-supplied integers, potentially allowing memory corruption. This
patch adds appropriate integer overflow checks, checks the range bounds
for VFIO_IRQ_SET_DATA_NONE, and also verifies that only single element
in the VFIO_IRQ_SET_DATA_TYPE_MASK bitmask is set.
VFIO_IRQ_SET_ACTION_TYPE_MASK is already correctly checked later in
vfio_pci_set_irqs_ioctl().

Furthermore, a kzalloc is changed to a kcalloc because the use of a
kzalloc with an integer multiplication allowed an integer overflow
condition to be reached without this patch. kcalloc checks for overflow
and should prevent a similar occurrence.

Signed-off-by: Vlad Tsyrklevich <vlad@tsyrklevich.net>
Signed-off-by: Alex Williamson <alex.williamson@redhat.com>",05692d7005a364add85c6e25a6c4447ce08f913a,https://github.com/torvalds/linux/commit/05692d7005a364add85c6e25a6c4447ce08f913a,drivers/vfio/pci/vfio_pci.c,vfio_pci_ioctl,"static long vfio_pci_ioctl(void *device_data,
unsigned int cmd, unsigned long arg)
{
struct vfio_pci_device *vdev = device_data;
unsigned long minsz;
if (cmd == VFIO_DEVICE_GET_INFO) {
struct vfio_device_info info;
minsz = offsetofend(struct vfio_device_info, num_irqs);
if (copy_from_user(&info, (void __user *)arg, minsz))
return -EFAULT;
if (info.argsz < minsz)
return -EINVAL;
info.flags = VFIO_DEVICE_FLAGS_PCI;
if (vdev->reset_works)
info.flags |= VFIO_DEVICE_FLAGS_RESET;
info.num_regions = VFIO_PCI_NUM_REGIONS + vdev->num_regions;
info.num_irqs = VFIO_PCI_NUM_IRQS;
return copy_to_user((void __user *)arg, &info, minsz) ?
-EFAULT : 0;
} else if (cmd == VFIO_DEVICE_GET_REGION_INFO) {
struct pci_dev *pdev = vdev->pdev;
struct vfio_region_info info;
struct vfio_info_cap caps = { .buf = NULL, .size = 0 };
int i, ret;
minsz = offsetofend(struct vfio_region_info, offset);
if (copy_from_user(&info, (void __user *)arg, minsz))
return -EFAULT;
if (info.argsz < minsz)
return -EINVAL;
switch (info.index) {
case VFIO_PCI_CONFIG_REGION_INDEX:
info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);
info.size = pdev->cfg_size;
info.flags = VFIO_REGION_INFO_FLAG_READ |
VFIO_REGION_INFO_FLAG_WRITE;
break;
case VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:
info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);
info.size = pci_resource_len(pdev, info.index);
if (!info.size) {
info.flags = 0;
break;
}
info.flags = VFIO_REGION_INFO_FLAG_READ |
VFIO_REGION_INFO_FLAG_WRITE;
if (vdev->bar_mmap_supported[info.index]) {
info.flags |= VFIO_REGION_INFO_FLAG_MMAP;
if (info.index == vdev->msix_bar) {
ret = msix_sparse_mmap_cap(vdev, &caps);
if (ret)
return ret;
}
}
break;
case VFIO_PCI_ROM_REGION_INDEX:
{
void __iomem *io;
size_t size;
info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);
info.flags = 0;
info.size = pci_resource_len(pdev, info.index);
if (!info.size) {
if (pdev->resource[PCI_ROM_RESOURCE].flags &
IORESOURCE_ROM_SHADOW)
info.size = 0x20000;
else
break;
}
io = pci_map_rom(pdev, &size);
if (!io || !size) {
info.size = 0;
break;
}
pci_unmap_rom(pdev, io);
info.flags = VFIO_REGION_INFO_FLAG_READ;
break;
}
case VFIO_PCI_VGA_REGION_INDEX:
if (!vdev->has_vga)
return -EINVAL;
info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);
info.size = 0xc0000;
info.flags = VFIO_REGION_INFO_FLAG_READ |
VFIO_REGION_INFO_FLAG_WRITE;
break;
default:
if (info.index >=
VFIO_PCI_NUM_REGIONS + vdev->num_regions)
return -EINVAL;
i = info.index - VFIO_PCI_NUM_REGIONS;
info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);
info.size = vdev->region[i].size;
info.flags = vdev->region[i].flags;
ret = region_type_cap(vdev, &caps,
vdev->region[i].type,
vdev->region[i].subtype);
if (ret)
return ret;
}
if (caps.size) {
info.flags |= VFIO_REGION_INFO_FLAG_CAPS;
if (info.argsz < sizeof(info) + caps.size) {
info.argsz = sizeof(info) + caps.size;
info.cap_offset = 0;
} else {
vfio_info_cap_shift(&caps, sizeof(info));
if (copy_to_user((void __user *)arg +
sizeof(info), caps.buf,
caps.size)) {
kfree(caps.buf);
return -EFAULT;
}
info.cap_offset = sizeof(info);
}
kfree(caps.buf);
}
return copy_to_user((void __user *)arg, &info, minsz) ?
-EFAULT : 0;
} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {
struct vfio_irq_info info;
minsz = offsetofend(struct vfio_irq_info, count);
if (copy_from_user(&info, (void __user *)arg, minsz))
return -EFAULT;
if (info.argsz < minsz || info.index >= VFIO_PCI_NUM_IRQS)
return -EINVAL;
switch (info.index) {
case VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX:
case VFIO_PCI_REQ_IRQ_INDEX:
break;
case VFIO_PCI_ERR_IRQ_INDEX:
if (pci_is_pcie(vdev->pdev))
break;
default:
return -EINVAL;
}
info.flags = VFIO_IRQ_INFO_EVENTFD;
info.count = vfio_pci_get_irq_count(vdev, info.index);
if (info.index == VFIO_PCI_INTX_IRQ_INDEX)
info.flags |= (VFIO_IRQ_INFO_MASKABLE |
VFIO_IRQ_INFO_AUTOMASKED);
else
info.flags |= VFIO_IRQ_INFO_NORESIZE;
return copy_to_user((void __user *)arg, &info, minsz) ?
-EFAULT : 0;
} else if (cmd == VFIO_DEVICE_SET_IRQS) {
struct vfio_irq_set hdr;
u8 *data = NULL;
int ret = 0;
minsz = offsetofend(struct vfio_irq_set, count);
if (copy_from_user(&hdr, (void __user *)arg, minsz))
return -EFAULT;
if (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||
hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |
VFIO_IRQ_SET_ACTION_TYPE_MASK))
return -EINVAL;
if (!(hdr.flags & VFIO_IRQ_SET_DATA_NONE)) {
size_t size;
int max = vfio_pci_get_irq_count(vdev, hdr.index);
if (hdr.flags & VFIO_IRQ_SET_DATA_BOOL)
size = sizeof(uint8_t);
else if (hdr.flags & VFIO_IRQ_SET_DATA_EVENTFD)
size = sizeof(int32_t);
else
return -EINVAL;
if (hdr.argsz - minsz < hdr.count * size ||
hdr.start >= max || hdr.start + hdr.count > max)
return -EINVAL;
data = memdup_user((void __user *)(arg + minsz),
hdr.count * size);
if (IS_ERR(data))
return PTR_ERR(data);
}
mutex_lock(&vdev->igate);
ret = vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index,
hdr.start, hdr.count, data);
mutex_unlock(&vdev->igate);
kfree(data);
return ret;
} else if (cmd == VFIO_DEVICE_RESET) {
return vdev->reset_works ?
pci_try_reset_function(vdev->pdev) : -EINVAL;
} else if (cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO) {
struct vfio_pci_hot_reset_info hdr;
struct vfio_pci_fill_info fill = { 0 };
struct vfio_pci_dependent_device *devices = NULL;
bool slot = false;
int ret = 0;
minsz = offsetofend(struct vfio_pci_hot_reset_info, count);
if (copy_from_user(&hdr, (void __user *)arg, minsz))
return -EFAULT;
if (hdr.argsz < minsz)
return -EINVAL;
hdr.flags = 0;
if (!pci_probe_reset_slot(vdev->pdev->slot))
slot = true;
else if (pci_probe_reset_bus(vdev->pdev->bus))
return -ENODEV;
ret = vfio_pci_for_each_slot_or_bus(vdev->pdev,
vfio_pci_count_devs,
&fill.max, slot);
if (ret)
return ret;
WARN_ON(!fill.max); 
if (hdr.argsz < sizeof(hdr) + (fill.max * sizeof(*devices))) {
ret = -ENOSPC;
hdr.count = fill.max;
goto reset_info_exit;
}
devices = kcalloc(fill.max, sizeof(*devices), GFP_KERNEL);
if (!devices)
return -ENOMEM;
fill.devices = devices;
ret = vfio_pci_for_each_slot_or_bus(vdev->pdev,
vfio_pci_fill_devs,
&fill, slot);
if (!ret)
hdr.count = fill.cur;
reset_info_exit:
if (copy_to_user((void __user *)arg, &hdr, minsz))
ret = -EFAULT;
if (!ret) {
if (copy_to_user((void __user *)(arg + minsz), devices,
hdr.count * sizeof(*devices)))
ret = -EFAULT;
}
kfree(devices);
return ret;
} else if (cmd == VFIO_DEVICE_PCI_HOT_RESET) {
struct vfio_pci_hot_reset hdr;
int32_t *group_fds;
struct vfio_pci_group_entry *groups;
struct vfio_pci_group_info info;
bool slot = false;
int i, count = 0, ret = 0;
minsz = offsetofend(struct vfio_pci_hot_reset, count);
if (copy_from_user(&hdr, (void __user *)arg, minsz))
return -EFAULT;
if (hdr.argsz < minsz || hdr.flags)
return -EINVAL;
if (!pci_probe_reset_slot(vdev->pdev->slot))
slot = true;
else if (pci_probe_reset_bus(vdev->pdev->bus))
return -ENODEV;
ret = vfio_pci_for_each_slot_or_bus(vdev->pdev,
vfio_pci_count_devs,
&count, slot);
if (ret)
return ret;
if (!hdr.count || hdr.count > count)
return -EINVAL;
group_fds = kcalloc(hdr.count, sizeof(*group_fds), GFP_KERNEL);
groups = kcalloc(hdr.count, sizeof(*groups), GFP_KERNEL);
if (!group_fds || !groups) {
kfree(group_fds);
kfree(groups);
return -ENOMEM;
}
if (copy_from_user(group_fds, (void __user *)(arg + minsz),
hdr.count * sizeof(*group_fds))) {
kfree(group_fds);
kfree(groups);
return -EFAULT;
}
for (i = 0; i < hdr.count; i++) {
struct vfio_group *group;
struct fd f = fdget(group_fds[i]);
if (!f.file) {
ret = -EBADF;
break;
}
group = vfio_group_get_external_user(f.file);
fdput(f);
if (IS_ERR(group)) {
ret = PTR_ERR(group);
break;
}
groups[i].group = group;
groups[i].id = vfio_external_user_iommu_id(group);
}
kfree(group_fds);
if (ret)
goto hot_reset_release;
info.count = hdr.count;
info.groups = groups;
ret = vfio_pci_for_each_slot_or_bus(vdev->pdev,
vfio_pci_validate_devs,
&info, slot);
if (!ret)
ret = slot ? pci_try_reset_slot(vdev->pdev->slot) :
pci_try_reset_bus(vdev->pdev->bus);
hot_reset_release:
for (i--; i >= 0; i--)
vfio_group_put_external_user(groups[i].group);
kfree(groups);
return ret;
}
return -ENOTTY;
}","static long vfio_pci_ioctl(void *VAR_0,
unsigned int VAR_1, unsigned long VAR_2)
{
struct vfio_pci_device *VAR_3 = VAR_0;
unsigned long VAR_4;
if (VAR_1 == VAR_5) {
struct vfio_device_info VAR_6;
VAR_4 = offsetofend(struct vfio_device_info, VAR_7);
if (copy_from_user(&VAR_6, (void __user *)VAR_2, VAR_4))
return -VAR_8;
if (VAR_6.argsz < VAR_4)
return -VAR_9;
VAR_6.flags = VAR_10;
if (VAR_3->reset_works)
VAR_6.flags |= VAR_11;
VAR_6.num_regions = VAR_12 + VAR_3->num_regions;
VAR_6.num_irqs = VAR_13;
return copy_to_user((void __user *)VAR_2, &VAR_6, VAR_4) ?
-VAR_8 : 0;
} else if (VAR_1 == VAR_14) {
struct pci_dev *VAR_15 = VAR_3->pdev;
struct vfio_region_info VAR_6;
struct vfio_info_cap VAR_16 = { .buf = NULL, .size = 0 };
int VAR_17, VAR_18;
VAR_4 = offsetofend(struct vfio_region_info, VAR_19);
if (copy_from_user(&VAR_6, (void __user *)VAR_2, VAR_4))
return -VAR_8;
if (VAR_6.argsz < VAR_4)
return -VAR_9;
switch (VAR_6.index) {
case VAR_20:
VAR_6.offset = VFIO_PCI_INDEX_TO_OFFSET(VAR_6.index);
VAR_6.size = VAR_15->cfg_size;
VAR_6.flags = VAR_21 |
VAR_22;
break;
case VAR_23 ... VFIO_PCI_BAR5_REGION_INDEX:
VAR_6.offset = VFIO_PCI_INDEX_TO_OFFSET(VAR_6.index);
VAR_6.size = pci_resource_len(VAR_15, VAR_6.index);
if (!VAR_6.size) {
VAR_6.flags = 0;
break;
}
VAR_6.flags = VAR_21 |
VAR_22;
if (VAR_3->bar_mmap_supported[VAR_6.index]) {
VAR_6.flags |= VAR_24;
if (VAR_6.index == VAR_3->msix_bar) {
VAR_18 = msix_sparse_mmap_cap(VAR_3, &VAR_16);
if (VAR_18)
return VAR_18;
}
}
break;
case VAR_25:
{
void VAR_26 *VAR_27;
size_t VAR_28;
VAR_6.offset = VFIO_PCI_INDEX_TO_OFFSET(VAR_6.index);
VAR_6.flags = 0;
VAR_6.size = pci_resource_len(VAR_15, VAR_6.index);
if (!VAR_6.size) {
if (VAR_15->resource[VAR_29].flags &
VAR_30)
VAR_6.size = 0x20000;
else
break;
}
VAR_27 = pci_map_rom(VAR_15, &VAR_28);
if (!VAR_27 || !VAR_28) {
VAR_6.size = 0;
break;
}
pci_unmap_rom(VAR_15, VAR_27);
VAR_6.flags = VAR_21;
break;
}
case VAR_31:
if (!VAR_3->has_vga)
return -VAR_9;
VAR_6.offset = VFIO_PCI_INDEX_TO_OFFSET(VAR_6.index);
VAR_6.size = 0xc0000;
VAR_6.flags = VAR_21 |
VAR_22;
break;
default:
if (VAR_6.index >=
VAR_12 + VAR_3->num_regions)
return -VAR_9;
VAR_17 = VAR_6.index - VAR_12;
VAR_6.offset = VFIO_PCI_INDEX_TO_OFFSET(VAR_6.index);
VAR_6.size = VAR_3->region[VAR_17].size;
VAR_6.flags = VAR_3->region[VAR_17].flags;
VAR_18 = region_type_cap(VAR_3, &VAR_16,
VAR_3->region[VAR_17].type,
VAR_3->region[VAR_17].subtype);
if (VAR_18)
return VAR_18;
}
if (VAR_16.size) {
VAR_6.flags |= VAR_32;
if (VAR_6.argsz < sizeof(VAR_6) + VAR_16.size) {
VAR_6.argsz = sizeof(VAR_6) + VAR_16.size;
VAR_6.cap_offset = 0;
} else {
vfio_info_cap_shift(&VAR_16, sizeof(VAR_6));
if (copy_to_user((void __user *)VAR_2 +
sizeof(VAR_6), VAR_16.buf,
VAR_16.size)) {
kfree(VAR_16.buf);
return -VAR_8;
}
VAR_6.cap_offset = sizeof(VAR_6);
}
kfree(VAR_16.buf);
}
return copy_to_user((void __user *)VAR_2, &VAR_6, VAR_4) ?
-VAR_8 : 0;
} else if (VAR_1 == VAR_33) {
struct vfio_irq_info VAR_6;
VAR_4 = offsetofend(struct vfio_irq_info, VAR_34);
if (copy_from_user(&VAR_6, (void __user *)VAR_2, VAR_4))
return -VAR_8;
if (VAR_6.argsz < VAR_4 || VAR_6.index >= VAR_13)
return -VAR_9;
switch (VAR_6.index) {
case VAR_35 ... VFIO_PCI_MSIX_IRQ_INDEX:
case VAR_36:
break;
case VAR_37:
if (pci_is_pcie(VAR_3->pdev))
break;
default:
return -VAR_9;
}
VAR_6.flags = VAR_38;
VAR_6.count = vfio_pci_get_irq_count(VAR_3, VAR_6.index);
if (VAR_6.index == VAR_35)
VAR_6.flags |= (VAR_39 |
VAR_40);
else
VAR_6.flags |= VAR_41;
return copy_to_user((void __user *)VAR_2, &VAR_6, VAR_4) ?
-VAR_8 : 0;
} else if (VAR_1 == VAR_42) {
struct vfio_irq_set VAR_43;
u8 *VAR_44 = NULL;
int VAR_18 = 0;
VAR_4 = offsetofend(struct vfio_irq_set, VAR_34);
if (copy_from_user(&VAR_43, (void __user *)VAR_2, VAR_4))
return -VAR_8;
if (VAR_43.argsz < VAR_4 || VAR_43.index >= VAR_13 ||
VAR_43.flags & ~(VAR_45 |
VAR_46))
return -VAR_9;
if (!(VAR_43.flags & VAR_47)) {
size_t VAR_28;
int VAR_48 = vfio_pci_get_irq_count(VAR_3, VAR_43.index);
if (VAR_43.flags & VAR_49)
VAR_28 = sizeof(uint8_t);
else if (VAR_43.flags & VAR_50)
VAR_28 = sizeof(int32_t);
else
return -VAR_9;
if (VAR_43.argsz - VAR_4 < VAR_43.count * VAR_28 ||
VAR_43.start >= VAR_48 || VAR_43.start + VAR_43.count > VAR_48)
return -VAR_9;
VAR_44 = memdup_user((void __user *)(VAR_2 + VAR_4),
VAR_43.count * VAR_28);
if (IS_ERR(VAR_44))
return PTR_ERR(VAR_44);
}
mutex_lock(&VAR_3->igate);
VAR_18 = vfio_pci_set_irqs_ioctl(VAR_3, VAR_43.flags, VAR_43.index,
VAR_43.start, VAR_43.count, VAR_44);
mutex_unlock(&VAR_3->igate);
kfree(VAR_44);
return VAR_18;
} else if (VAR_1 == VAR_51) {
return VAR_3->reset_works ?
pci_try_reset_function(VAR_3->pdev) : -VAR_9;
} else if (VAR_1 == VAR_52) {
struct vfio_pci_hot_reset_info VAR_43;
struct vfio_pci_fill_info VAR_53 = { 0 };
struct vfio_pci_dependent_device *VAR_54 = NULL;
bool VAR_55 = false;
int VAR_18 = 0;
VAR_4 = offsetofend(struct vfio_pci_hot_reset_info, VAR_34);
if (copy_from_user(&VAR_43, (void __user *)VAR_2, VAR_4))
return -VAR_8;
if (VAR_43.argsz < VAR_4)
return -VAR_9;
VAR_43.flags = 0;
if (!pci_probe_reset_slot(VAR_3->pdev->slot))
VAR_55 = true;
else if (pci_probe_reset_bus(VAR_3->pdev->bus))
return -VAR_56;
VAR_18 = vfio_pci_for_each_slot_or_bus(VAR_3->pdev,
VAR_57,
&VAR_53.max, VAR_55);
if (VAR_18)
return VAR_18;
WARN_ON(!VAR_53.max); 
if (VAR_43.argsz < sizeof(VAR_43) + (VAR_53.max * sizeof(*VAR_54))) {
VAR_18 = -VAR_58;
VAR_43.count = VAR_53.max;
goto reset_info_exit;
}
VAR_54 = kcalloc(VAR_53.max, sizeof(*VAR_54), VAR_59);
if (!VAR_54)
return -VAR_60;
VAR_53.devices = VAR_54;
VAR_18 = vfio_pci_for_each_slot_or_bus(VAR_3->pdev,
VAR_61,
&VAR_53, VAR_55);
if (!VAR_18)
VAR_43.count = VAR_53.cur;
reset_info_exit:
if (copy_to_user((void __user *)VAR_2, &VAR_43, VAR_4))
VAR_18 = -VAR_8;
if (!VAR_18) {
if (copy_to_user((void __user *)(VAR_2 + VAR_4), VAR_54,
VAR_43.count * sizeof(*VAR_54)))
VAR_18 = -VAR_8;
}
kfree(VAR_54);
return VAR_18;
} else if (VAR_1 == VAR_62) {
struct vfio_pci_hot_reset VAR_43;
int32_t *VAR_63;
struct vfio_pci_group_entry *VAR_64;
struct vfio_pci_group_info VAR_6;
bool VAR_55 = false;
int VAR_17, VAR_34 = 0, VAR_18 = 0;
VAR_4 = offsetofend(struct vfio_pci_hot_reset, VAR_34);
if (copy_from_user(&VAR_43, (void __user *)VAR_2, VAR_4))
return -VAR_8;
if (VAR_43.argsz < VAR_4 || VAR_43.flags)
return -VAR_9;
if (!pci_probe_reset_slot(VAR_3->pdev->slot))
VAR_55 = true;
else if (pci_probe_reset_bus(VAR_3->pdev->bus))
return -VAR_56;
VAR_18 = vfio_pci_for_each_slot_or_bus(VAR_3->pdev,
VAR_57,
&VAR_34, VAR_55);
if (VAR_18)
return VAR_18;
if (!VAR_43.count || VAR_43.count > VAR_34)
return -VAR_9;
VAR_63 = kcalloc(VAR_43.count, sizeof(*VAR_63), VAR_59);
VAR_64 = kcalloc(VAR_43.count, sizeof(*VAR_64), VAR_59);
if (!VAR_63 || !VAR_64) {
kfree(VAR_63);
kfree(VAR_64);
return -VAR_60;
}
if (copy_from_user(VAR_63, (void __user *)(VAR_2 + VAR_4),
VAR_43.count * sizeof(*VAR_63))) {
kfree(VAR_63);
kfree(VAR_64);
return -VAR_8;
}
for (VAR_17 = 0; VAR_17 < VAR_43.count; VAR_17++) {
struct vfio_group *VAR_65;
struct fd VAR_66 = fdget(VAR_63[VAR_17]);
if (!VAR_66.file) {
VAR_18 = -VAR_67;
break;
}
VAR_65 = vfio_group_get_external_user(VAR_66.file);
fdput(VAR_66);
if (IS_ERR(VAR_65)) {
VAR_18 = PTR_ERR(VAR_65);
break;
}
VAR_64[VAR_17].group = VAR_65;
VAR_64[VAR_17].id = vfio_external_user_iommu_id(VAR_65);
}
kfree(VAR_63);
if (VAR_18)
goto hot_reset_release;
VAR_6.count = VAR_43.count;
VAR_6.groups = VAR_64;
VAR_18 = vfio_pci_for_each_slot_or_bus(VAR_3->pdev,
VAR_68,
&VAR_6, VAR_55);
if (!VAR_18)
VAR_18 = VAR_55 ? pci_try_reset_slot(VAR_3->pdev->slot) :
pci_try_reset_bus(VAR_3->pdev->bus);
hot_reset_release:
for (VAR_17--; VAR_17 >= 0; VAR_17--)
vfio_group_put_external_user(VAR_64[VAR_17].group);
kfree(VAR_64);
return VAR_18;
}
return -VAR_69;
}",torvalds/linux/05692d7005a364add85c6e25a6c4447ce08f913a/vfio_pci.c/vul/before/0.json,"static long vfio_pci_ioctl(void *device_data,
			   unsigned int cmd, unsigned long arg)
{
	struct vfio_pci_device *vdev = device_data;
	unsigned long minsz;

	if (cmd == VFIO_DEVICE_GET_INFO) {
		struct vfio_device_info info;

		minsz = offsetofend(struct vfio_device_info, num_irqs);

		if (copy_from_user(&info, (void __user *)arg, minsz))
			return -EFAULT;

		if (info.argsz < minsz)
			return -EINVAL;

		info.flags = VFIO_DEVICE_FLAGS_PCI;

		if (vdev->reset_works)
			info.flags |= VFIO_DEVICE_FLAGS_RESET;

		info.num_regions = VFIO_PCI_NUM_REGIONS + vdev->num_regions;
		info.num_irqs = VFIO_PCI_NUM_IRQS;

		return copy_to_user((void __user *)arg, &info, minsz) ?
			-EFAULT : 0;

	} else if (cmd == VFIO_DEVICE_GET_REGION_INFO) {
		struct pci_dev *pdev = vdev->pdev;
		struct vfio_region_info info;
		struct vfio_info_cap caps = { .buf = NULL, .size = 0 };
		int i, ret;

		minsz = offsetofend(struct vfio_region_info, offset);

		if (copy_from_user(&info, (void __user *)arg, minsz))
			return -EFAULT;

		if (info.argsz < minsz)
			return -EINVAL;

		switch (info.index) {
		case VFIO_PCI_CONFIG_REGION_INDEX:
			info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);
			info.size = pdev->cfg_size;
			info.flags = VFIO_REGION_INFO_FLAG_READ |
				     VFIO_REGION_INFO_FLAG_WRITE;
			break;
		case VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:
			info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);
			info.size = pci_resource_len(pdev, info.index);
			if (!info.size) {
				info.flags = 0;
				break;
			}

			info.flags = VFIO_REGION_INFO_FLAG_READ |
				     VFIO_REGION_INFO_FLAG_WRITE;
			if (vdev->bar_mmap_supported[info.index]) {
				info.flags |= VFIO_REGION_INFO_FLAG_MMAP;
				if (info.index == vdev->msix_bar) {
					ret = msix_sparse_mmap_cap(vdev, &caps);
					if (ret)
						return ret;
				}
			}

			break;
		case VFIO_PCI_ROM_REGION_INDEX:
		{
			void __iomem *io;
			size_t size;

			info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);
			info.flags = 0;

			/* Report the BAR size, not the ROM size */
			info.size = pci_resource_len(pdev, info.index);
			if (!info.size) {
				/* Shadow ROMs appear as PCI option ROMs */
				if (pdev->resource[PCI_ROM_RESOURCE].flags &
							IORESOURCE_ROM_SHADOW)
					info.size = 0x20000;
				else
					break;
			}

			/* Is it really there? */
			io = pci_map_rom(pdev, &size);
			if (!io || !size) {
				info.size = 0;
				break;
			}
			pci_unmap_rom(pdev, io);

			info.flags = VFIO_REGION_INFO_FLAG_READ;
			break;
		}
		case VFIO_PCI_VGA_REGION_INDEX:
			if (!vdev->has_vga)
				return -EINVAL;

			info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);
			info.size = 0xc0000;
			info.flags = VFIO_REGION_INFO_FLAG_READ |
				     VFIO_REGION_INFO_FLAG_WRITE;

			break;
		default:
			if (info.index >=
			    VFIO_PCI_NUM_REGIONS + vdev->num_regions)
				return -EINVAL;

			i = info.index - VFIO_PCI_NUM_REGIONS;

			info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);
			info.size = vdev->region[i].size;
			info.flags = vdev->region[i].flags;

			ret = region_type_cap(vdev, &caps,
					      vdev->region[i].type,
					      vdev->region[i].subtype);
			if (ret)
				return ret;
		}

		if (caps.size) {
			info.flags |= VFIO_REGION_INFO_FLAG_CAPS;
			if (info.argsz < sizeof(info) + caps.size) {
				info.argsz = sizeof(info) + caps.size;
				info.cap_offset = 0;
			} else {
				vfio_info_cap_shift(&caps, sizeof(info));
				if (copy_to_user((void __user *)arg +
						  sizeof(info), caps.buf,
						  caps.size)) {
					kfree(caps.buf);
					return -EFAULT;
				}
				info.cap_offset = sizeof(info);
			}

			kfree(caps.buf);
		}

		return copy_to_user((void __user *)arg, &info, minsz) ?
			-EFAULT : 0;

	} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {
		struct vfio_irq_info info;

		minsz = offsetofend(struct vfio_irq_info, count);

		if (copy_from_user(&info, (void __user *)arg, minsz))
			return -EFAULT;

		if (info.argsz < minsz || info.index >= VFIO_PCI_NUM_IRQS)
			return -EINVAL;

		switch (info.index) {
		case VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX:
		case VFIO_PCI_REQ_IRQ_INDEX:
			break;
		case VFIO_PCI_ERR_IRQ_INDEX:
			if (pci_is_pcie(vdev->pdev))
				break;
		/* pass thru to return error */
		default:
			return -EINVAL;
		}

		info.flags = VFIO_IRQ_INFO_EVENTFD;

		info.count = vfio_pci_get_irq_count(vdev, info.index);

		if (info.index == VFIO_PCI_INTX_IRQ_INDEX)
			info.flags |= (VFIO_IRQ_INFO_MASKABLE |
				       VFIO_IRQ_INFO_AUTOMASKED);
		else
			info.flags |= VFIO_IRQ_INFO_NORESIZE;

		return copy_to_user((void __user *)arg, &info, minsz) ?
			-EFAULT : 0;

	} else if (cmd == VFIO_DEVICE_SET_IRQS) {
		struct vfio_irq_set hdr;
		size_t size;
		u8 *data = NULL;
		int max, ret = 0;

		minsz = offsetofend(struct vfio_irq_set, count);

		if (copy_from_user(&hdr, (void __user *)arg, minsz))
			return -EFAULT;

		if (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||
		    hdr.count >= (U32_MAX - hdr.start) ||
		    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |
				  VFIO_IRQ_SET_ACTION_TYPE_MASK))
			return -EINVAL;

		max = vfio_pci_get_irq_count(vdev, hdr.index);
		if (hdr.start >= max || hdr.start + hdr.count > max)
			return -EINVAL;

		switch (hdr.flags & VFIO_IRQ_SET_DATA_TYPE_MASK) {
		case VFIO_IRQ_SET_DATA_NONE:
			size = 0;
			break;
		case VFIO_IRQ_SET_DATA_BOOL:
			size = sizeof(uint8_t);
			break;
		case VFIO_IRQ_SET_DATA_EVENTFD:
			size = sizeof(int32_t);
			break;
		default:
			return -EINVAL;
		}

		if (size) {
			if (hdr.argsz - minsz < hdr.count * size)
				return -EINVAL;

			data = memdup_user((void __user *)(arg + minsz),
					   hdr.count * size);
			if (IS_ERR(data))
				return PTR_ERR(data);
		}

		mutex_lock(&vdev->igate);

		ret = vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index,
					      hdr.start, hdr.count, data);

		mutex_unlock(&vdev->igate);
		kfree(data);

		return ret;

	} else if (cmd == VFIO_DEVICE_RESET) {
		return vdev->reset_works ?
			pci_try_reset_function(vdev->pdev) : -EINVAL;

	} else if (cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO) {
		struct vfio_pci_hot_reset_info hdr;
		struct vfio_pci_fill_info fill = { 0 };
		struct vfio_pci_dependent_device *devices = NULL;
		bool slot = false;
		int ret = 0;

		minsz = offsetofend(struct vfio_pci_hot_reset_info, count);

		if (copy_from_user(&hdr, (void __user *)arg, minsz))
			return -EFAULT;

		if (hdr.argsz < minsz)
			return -EINVAL;

		hdr.flags = 0;

		/* Can we do a slot or bus reset or neither? */
		if (!pci_probe_reset_slot(vdev->pdev->slot))
			slot = true;
		else if (pci_probe_reset_bus(vdev->pdev->bus))
			return -ENODEV;

		/* How many devices are affected? */
		ret = vfio_pci_for_each_slot_or_bus(vdev->pdev,
						    vfio_pci_count_devs,
						    &fill.max, slot);
		if (ret)
			return ret;

		WARN_ON(!fill.max); /* Should always be at least one */

		/*
		 * If there's enough space, fill it now, otherwise return
		 * -ENOSPC and the number of devices affected.
		 */
		if (hdr.argsz < sizeof(hdr) + (fill.max * sizeof(*devices))) {
			ret = -ENOSPC;
			hdr.count = fill.max;
			goto reset_info_exit;
		}

		devices = kcalloc(fill.max, sizeof(*devices), GFP_KERNEL);
		if (!devices)
			return -ENOMEM;

		fill.devices = devices;

		ret = vfio_pci_for_each_slot_or_bus(vdev->pdev,
						    vfio_pci_fill_devs,
						    &fill, slot);

		/*
		 * If a device was removed between counting and filling,
		 * we may come up short of fill.max.  If a device was
		 * added, we'll have a return of -EAGAIN above.
		 */
		if (!ret)
			hdr.count = fill.cur;

reset_info_exit:
		if (copy_to_user((void __user *)arg, &hdr, minsz))
			ret = -EFAULT;

		if (!ret) {
			if (copy_to_user((void __user *)(arg + minsz), devices,
					 hdr.count * sizeof(*devices)))
				ret = -EFAULT;
		}

		kfree(devices);
		return ret;

	} else if (cmd == VFIO_DEVICE_PCI_HOT_RESET) {
		struct vfio_pci_hot_reset hdr;
		int32_t *group_fds;
		struct vfio_pci_group_entry *groups;
		struct vfio_pci_group_info info;
		bool slot = false;
		int i, count = 0, ret = 0;

		minsz = offsetofend(struct vfio_pci_hot_reset, count);

		if (copy_from_user(&hdr, (void __user *)arg, minsz))
			return -EFAULT;

		if (hdr.argsz < minsz || hdr.flags)
			return -EINVAL;

		/* Can we do a slot or bus reset or neither? */
		if (!pci_probe_reset_slot(vdev->pdev->slot))
			slot = true;
		else if (pci_probe_reset_bus(vdev->pdev->bus))
			return -ENODEV;

		/*
		 * We can't let userspace give us an arbitrarily large
		 * buffer to copy, so verify how many we think there
		 * could be.  Note groups can have multiple devices so
		 * one group per device is the max.
		 */
		ret = vfio_pci_for_each_slot_or_bus(vdev->pdev,
						    vfio_pci_count_devs,
						    &count, slot);
		if (ret)
			return ret;

		/* Somewhere between 1 and count is OK */
		if (!hdr.count || hdr.count > count)
			return -EINVAL;

		group_fds = kcalloc(hdr.count, sizeof(*group_fds), GFP_KERNEL);
		groups = kcalloc(hdr.count, sizeof(*groups), GFP_KERNEL);
		if (!group_fds || !groups) {
			kfree(group_fds);
			kfree(groups);
			return -ENOMEM;
		}

		if (copy_from_user(group_fds, (void __user *)(arg + minsz),
				   hdr.count * sizeof(*group_fds))) {
			kfree(group_fds);
			kfree(groups);
			return -EFAULT;
		}

		/*
		 * For each group_fd, get the group through the vfio external
		 * user interface and store the group and iommu ID.  This
		 * ensures the group is held across the reset.
		 */
		for (i = 0; i < hdr.count; i++) {
			struct vfio_group *group;
			struct fd f = fdget(group_fds[i]);
			if (!f.file) {
				ret = -EBADF;
				break;
			}

			group = vfio_group_get_external_user(f.file);
			fdput(f);
			if (IS_ERR(group)) {
				ret = PTR_ERR(group);
				break;
			}

			groups[i].group = group;
			groups[i].id = vfio_external_user_iommu_id(group);
		}

		kfree(group_fds);

		/* release reference to groups on error */
		if (ret)
			goto hot_reset_release;

		info.count = hdr.count;
		info.groups = groups;

		/*
		 * Test whether all the affected devices are contained
		 * by the set of groups provided by the user.
		 */
		ret = vfio_pci_for_each_slot_or_bus(vdev->pdev,
						    vfio_pci_validate_devs,
						    &info, slot);
		if (!ret)
			/* User has access, do the reset */
			ret = slot ? pci_try_reset_slot(vdev->pdev->slot) :
				     pci_try_reset_bus(vdev->pdev->bus);

hot_reset_release:
		for (i--; i >= 0; i--)
			vfio_group_put_external_user(groups[i].group);

		kfree(groups);
		return ret;
	}

	return -ENOTTY;
}","static long vfio_pci_ioctl(void *VAR_0,
			   unsigned int VAR_1, unsigned long VAR_2)
{
	struct vfio_pci_device *VAR_3 = VAR_0;
	unsigned long VAR_4;

	if (VAR_1 == VAR_5) {
		struct vfio_device_info VAR_6;

		VAR_4 = offsetofend(struct vfio_device_info, VAR_7);

		if (copy_from_user(&VAR_6, (void __user *)VAR_2, VAR_4))
			return -VAR_8;

		if (VAR_6.argsz < VAR_4)
			return -VAR_9;

		VAR_6.flags = VAR_10;

		if (VAR_3->reset_works)
			VAR_6.flags |= VAR_11;

		VAR_6.num_regions = VAR_12 + VAR_3->num_regions;
		VAR_6.num_irqs = VAR_13;

		return copy_to_user((void __user *)VAR_2, &VAR_6, VAR_4) ?
			-VAR_8 : 0;

	} else if (VAR_1 == VAR_14) {
		struct pci_dev *VAR_15 = VAR_3->pdev;
		struct vfio_region_info VAR_6;
		struct vfio_info_cap VAR_16 = { .buf = NULL, .size = 0 };
		int VAR_17, VAR_18;

		VAR_4 = offsetofend(struct vfio_region_info, VAR_19);

		if (copy_from_user(&VAR_6, (void __user *)VAR_2, VAR_4))
			return -VAR_8;

		if (VAR_6.argsz < VAR_4)
			return -VAR_9;

		switch (VAR_6.index) {
		case VAR_20:
			VAR_6.offset = VFIO_PCI_INDEX_TO_OFFSET(VAR_6.index);
			VAR_6.size = VAR_15->cfg_size;
			VAR_6.flags = VAR_21 |
				     VAR_22;
			break;
		case VAR_23 ... VFIO_PCI_BAR5_REGION_INDEX:
			VAR_6.offset = VFIO_PCI_INDEX_TO_OFFSET(VAR_6.index);
			VAR_6.size = pci_resource_len(VAR_15, VAR_6.index);
			if (!VAR_6.size) {
				VAR_6.flags = 0;
				break;
			}

			VAR_6.flags = VAR_21 |
				     VAR_22;
			if (VAR_3->bar_mmap_supported[VAR_6.index]) {
				VAR_6.flags |= VAR_24;
				if (VAR_6.index == VAR_3->msix_bar) {
					VAR_18 = msix_sparse_mmap_cap(VAR_3, &VAR_16);
					if (VAR_18)
						return VAR_18;
				}
			}

			break;
		case VAR_25:
		{
			void VAR_26 *VAR_27;
			size_t VAR_28;

			VAR_6.offset = VFIO_PCI_INDEX_TO_OFFSET(VAR_6.index);
			VAR_6.flags = 0;

			/* COMMENT_0 */
			VAR_6.size = pci_resource_len(VAR_15, VAR_6.index);
			if (!VAR_6.size) {
				/* COMMENT_1 */
				if (VAR_15->resource[VAR_29].flags &
							VAR_30)
					VAR_6.size = 0x20000;
				else
					break;
			}

			/* COMMENT_2 */
			VAR_27 = pci_map_rom(VAR_15, &VAR_28);
			if (!VAR_27 || !VAR_28) {
				VAR_6.size = 0;
				break;
			}
			pci_unmap_rom(VAR_15, VAR_27);

			VAR_6.flags = VAR_21;
			break;
		}
		case VAR_31:
			if (!VAR_3->has_vga)
				return -VAR_9;

			VAR_6.offset = VFIO_PCI_INDEX_TO_OFFSET(VAR_6.index);
			VAR_6.size = 0xc0000;
			VAR_6.flags = VAR_21 |
				     VAR_22;

			break;
		default:
			if (VAR_6.index >=
			    VAR_12 + VAR_3->num_regions)
				return -VAR_9;

			VAR_17 = VAR_6.index - VAR_12;

			VAR_6.offset = VFIO_PCI_INDEX_TO_OFFSET(VAR_6.index);
			VAR_6.size = VAR_3->region[VAR_17].size;
			VAR_6.flags = VAR_3->region[VAR_17].flags;

			VAR_18 = region_type_cap(VAR_3, &VAR_16,
					      VAR_3->region[VAR_17].type,
					      VAR_3->region[VAR_17].subtype);
			if (VAR_18)
				return VAR_18;
		}

		if (VAR_16.size) {
			VAR_6.flags |= VAR_32;
			if (VAR_6.argsz < sizeof(VAR_6) + VAR_16.size) {
				VAR_6.argsz = sizeof(VAR_6) + VAR_16.size;
				VAR_6.cap_offset = 0;
			} else {
				vfio_info_cap_shift(&VAR_16, sizeof(VAR_6));
				if (copy_to_user((void __user *)VAR_2 +
						  sizeof(VAR_6), VAR_16.buf,
						  VAR_16.size)) {
					kfree(VAR_16.buf);
					return -VAR_8;
				}
				VAR_6.cap_offset = sizeof(VAR_6);
			}

			kfree(VAR_16.buf);
		}

		return copy_to_user((void __user *)VAR_2, &VAR_6, VAR_4) ?
			-VAR_8 : 0;

	} else if (VAR_1 == VAR_33) {
		struct vfio_irq_info VAR_6;

		VAR_4 = offsetofend(struct vfio_irq_info, VAR_34);

		if (copy_from_user(&VAR_6, (void __user *)VAR_2, VAR_4))
			return -VAR_8;

		if (VAR_6.argsz < VAR_4 || VAR_6.index >= VAR_13)
			return -VAR_9;

		switch (VAR_6.index) {
		case VAR_35 ... VFIO_PCI_MSIX_IRQ_INDEX:
		case VAR_36:
			break;
		case VAR_37:
			if (pci_is_pcie(VAR_3->pdev))
				break;
		/* COMMENT_3 */
		default:
			return -VAR_9;
		}

		VAR_6.flags = VAR_38;

		VAR_6.count = vfio_pci_get_irq_count(VAR_3, VAR_6.index);

		if (VAR_6.index == VAR_35)
			VAR_6.flags |= (VAR_39 |
				       VAR_40);
		else
			VAR_6.flags |= VAR_41;

		return copy_to_user((void __user *)VAR_2, &VAR_6, VAR_4) ?
			-VAR_8 : 0;

	} else if (VAR_1 == VAR_42) {
		struct vfio_irq_set VAR_43;
		size_t VAR_28;
		u8 *VAR_44 = NULL;
		int VAR_45, VAR_18 = 0;

		VAR_4 = offsetofend(struct vfio_irq_set, VAR_34);

		if (copy_from_user(&VAR_43, (void __user *)VAR_2, VAR_4))
			return -VAR_8;

		if (VAR_43.argsz < VAR_4 || VAR_43.index >= VAR_13 ||
		    VAR_43.count >= (VAR_46 - VAR_43.start) ||
		    VAR_43.flags & ~(VAR_47 |
				  VAR_48))
			return -VAR_9;

		VAR_45 = vfio_pci_get_irq_count(VAR_3, VAR_43.index);
		if (VAR_43.start >= VAR_45 || VAR_43.start + VAR_43.count > VAR_45)
			return -VAR_9;

		switch (VAR_43.flags & VAR_47) {
		case VAR_49:
			VAR_28 = 0;
			break;
		case VAR_50:
			VAR_28 = sizeof(uint8_t);
			break;
		case VAR_51:
			VAR_28 = sizeof(int32_t);
			break;
		default:
			return -VAR_9;
		}

		if (VAR_28) {
			if (VAR_43.argsz - VAR_4 < VAR_43.count * VAR_28)
				return -VAR_9;

			VAR_44 = memdup_user((void __user *)(VAR_2 + VAR_4),
					   VAR_43.count * VAR_28);
			if (IS_ERR(VAR_44))
				return PTR_ERR(VAR_44);
		}

		mutex_lock(&VAR_3->igate);

		VAR_18 = vfio_pci_set_irqs_ioctl(VAR_3, VAR_43.flags, VAR_43.index,
					      VAR_43.start, VAR_43.count, VAR_44);

		mutex_unlock(&VAR_3->igate);
		kfree(VAR_44);

		return VAR_18;

	} else if (VAR_1 == VAR_52) {
		return VAR_3->reset_works ?
			pci_try_reset_function(VAR_3->pdev) : -VAR_9;

	} else if (VAR_1 == VAR_53) {
		struct vfio_pci_hot_reset_info VAR_43;
		struct vfio_pci_fill_info VAR_54 = { 0 };
		struct vfio_pci_dependent_device *VAR_55 = NULL;
		bool VAR_56 = false;
		int VAR_18 = 0;

		VAR_4 = offsetofend(struct vfio_pci_hot_reset_info, VAR_34);

		if (copy_from_user(&VAR_43, (void __user *)VAR_2, VAR_4))
			return -VAR_8;

		if (VAR_43.argsz < VAR_4)
			return -VAR_9;

		VAR_43.flags = 0;

		/* COMMENT_4 */
		if (!pci_probe_reset_slot(VAR_3->pdev->slot))
			VAR_56 = true;
		else if (pci_probe_reset_bus(VAR_3->pdev->bus))
			return -VAR_57;

		/* COMMENT_5 */
		VAR_18 = vfio_pci_for_each_slot_or_bus(VAR_3->pdev,
						    VAR_58,
						    &VAR_54.max, VAR_56);
		if (VAR_18)
			return VAR_18;

		WARN_ON(!VAR_54.max); /* COMMENT_6 */

		/* COMMENT_7 */
                                                           
                                                
     
		if (VAR_43.argsz < sizeof(VAR_43) + (VAR_54.max * sizeof(*VAR_55))) {
			VAR_18 = -VAR_59;
			VAR_43.count = VAR_54.max;
			goto reset_info_exit;
		}

		VAR_55 = kcalloc(VAR_54.max, sizeof(*VAR_55), VAR_60);
		if (!VAR_55)
			return -VAR_61;

		VAR_54.devices = VAR_55;

		VAR_18 = vfio_pci_for_each_slot_or_bus(VAR_3->pdev,
						    VAR_62,
						    &VAR_54, VAR_56);

		/* COMMENT_11 */
                                                          
                                                       
                                                 
     
		if (!VAR_18)
			VAR_43.count = VAR_54.cur;

reset_info_exit:
		if (copy_to_user((void __user *)VAR_2, &VAR_43, VAR_4))
			VAR_18 = -VAR_8;

		if (!VAR_18) {
			if (copy_to_user((void __user *)(VAR_2 + VAR_4), VAR_55,
					 VAR_43.count * sizeof(*VAR_55)))
				VAR_18 = -VAR_8;
		}

		kfree(VAR_55);
		return VAR_18;

	} else if (VAR_1 == VAR_63) {
		struct vfio_pci_hot_reset VAR_43;
		int32_t *VAR_64;
		struct vfio_pci_group_entry *VAR_65;
		struct vfio_pci_group_info VAR_6;
		bool VAR_56 = false;
		int VAR_17, VAR_34 = 0, VAR_18 = 0;

		VAR_4 = offsetofend(struct vfio_pci_hot_reset, VAR_34);

		if (copy_from_user(&VAR_43, (void __user *)VAR_2, VAR_4))
			return -VAR_8;

		if (VAR_43.argsz < VAR_4 || VAR_43.flags)
			return -VAR_9;

		/* COMMENT_4 */
		if (!pci_probe_reset_slot(VAR_3->pdev->slot))
			VAR_56 = true;
		else if (pci_probe_reset_bus(VAR_3->pdev->bus))
			return -VAR_57;

		/* COMMENT_16 */
                                                        
                                                      
                                                        
                                     
     
		VAR_18 = vfio_pci_for_each_slot_or_bus(VAR_3->pdev,
						    VAR_58,
						    &VAR_34, VAR_56);
		if (VAR_18)
			return VAR_18;

		/* COMMENT_22 */
		if (!VAR_43.count || VAR_43.count > VAR_34)
			return -VAR_9;

		VAR_64 = kcalloc(VAR_43.count, sizeof(*VAR_64), VAR_60);
		VAR_65 = kcalloc(VAR_43.count, sizeof(*VAR_65), VAR_60);
		if (!VAR_64 || !VAR_65) {
			kfree(VAR_64);
			kfree(VAR_65);
			return -VAR_61;
		}

		if (copy_from_user(VAR_64, (void __user *)(VAR_2 + VAR_4),
				   VAR_43.count * sizeof(*VAR_64))) {
			kfree(VAR_64);
			kfree(VAR_65);
			return -VAR_8;
		}

		/* COMMENT_23 */
                                                               
                                                           
                                                
     
		for (VAR_17 = 0; VAR_17 < VAR_43.count; VAR_17++) {
			struct vfio_group *VAR_66;
			struct fd VAR_67 = fdget(VAR_64[VAR_17]);
			if (!VAR_67.file) {
				VAR_18 = -VAR_68;
				break;
			}

			VAR_66 = vfio_group_get_external_user(VAR_67.file);
			fdput(VAR_67);
			if (IS_ERR(VAR_66)) {
				VAR_18 = PTR_ERR(VAR_66);
				break;
			}

			VAR_65[VAR_17].group = VAR_66;
			VAR_65[VAR_17].id = vfio_external_user_iommu_id(VAR_66);
		}

		kfree(VAR_64);

		/* COMMENT_28 */
		if (VAR_18)
			goto hot_reset_release;

		VAR_6.count = VAR_43.count;
		VAR_6.groups = VAR_65;

		/* COMMENT_29 */
                                                        
                                               
     
		VAR_18 = vfio_pci_for_each_slot_or_bus(VAR_3->pdev,
						    VAR_69,
						    &VAR_6, VAR_56);
		if (!VAR_18)
			/* COMMENT_33 */
			VAR_18 = VAR_56 ? pci_try_reset_slot(VAR_3->pdev->slot) :
				     pci_try_reset_bus(VAR_3->pdev->bus);

hot_reset_release:
		for (VAR_17--; VAR_17 >= 0; VAR_17--)
			vfio_group_put_external_user(VAR_65[VAR_17].group);

		kfree(VAR_65);
		return VAR_18;
	}

	return -VAR_70;
}",torvalds/linux/05692d7005a364add85c6e25a6c4447ce08f913a/vfio_pci.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -185,8 +185,9 @@
 
 	} else if (cmd == VFIO_DEVICE_SET_IRQS) {
 		struct vfio_irq_set hdr;
+		size_t size;
 		u8 *data = NULL;
-		int ret = 0;
+		int max, ret = 0;
 
 		minsz = offsetofend(struct vfio_irq_set, count);
 
@@ -194,23 +195,31 @@
 			return -EFAULT;
 
 		if (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||
+		    hdr.count >= (U32_MAX - hdr.start) ||
 		    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |
 				  VFIO_IRQ_SET_ACTION_TYPE_MASK))
 			return -EINVAL;
 
-		if (!(hdr.flags & VFIO_IRQ_SET_DATA_NONE)) {
-			size_t size;
-			int max = vfio_pci_get_irq_count(vdev, hdr.index);
-
-			if (hdr.flags & VFIO_IRQ_SET_DATA_BOOL)
-				size = sizeof(uint8_t);
-			else if (hdr.flags & VFIO_IRQ_SET_DATA_EVENTFD)
-				size = sizeof(int32_t);
-			else
-				return -EINVAL;
-
-			if (hdr.argsz - minsz < hdr.count * size ||
-			    hdr.start >= max || hdr.start + hdr.count > max)
+		max = vfio_pci_get_irq_count(vdev, hdr.index);
+		if (hdr.start >= max || hdr.start + hdr.count > max)
+			return -EINVAL;
+
+		switch (hdr.flags & VFIO_IRQ_SET_DATA_TYPE_MASK) {
+		case VFIO_IRQ_SET_DATA_NONE:
+			size = 0;
+			break;
+		case VFIO_IRQ_SET_DATA_BOOL:
+			size = sizeof(uint8_t);
+			break;
+		case VFIO_IRQ_SET_DATA_EVENTFD:
+			size = sizeof(int32_t);
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		if (size) {
+			if (hdr.argsz - minsz < hdr.count * size)
 				return -EINVAL;
 
 			data = memdup_user((void __user *)(arg + minsz),","{'deleted_lines': ['\t\tint ret = 0;', '\t\tif (!(hdr.flags & VFIO_IRQ_SET_DATA_NONE)) {', '\t\t\tsize_t size;', '\t\t\tint max = vfio_pci_get_irq_count(vdev, hdr.index);', '', '\t\t\tif (hdr.flags & VFIO_IRQ_SET_DATA_BOOL)', '\t\t\t\tsize = sizeof(uint8_t);', '\t\t\telse if (hdr.flags & VFIO_IRQ_SET_DATA_EVENTFD)', '\t\t\t\tsize = sizeof(int32_t);', '\t\t\telse', '\t\t\t\treturn -EINVAL;', '', '\t\t\tif (hdr.argsz - minsz < hdr.count * size ||', '\t\t\t    hdr.start >= max || hdr.start + hdr.count > max)'], 'added_lines': ['\t\tsize_t size;', '\t\tint max, ret = 0;', '\t\t    hdr.count >= (U32_MAX - hdr.start) ||', '\t\tmax = vfio_pci_get_irq_count(vdev, hdr.index);', '\t\tif (hdr.start >= max || hdr.start + hdr.count > max)', '\t\t\treturn -EINVAL;', '', '\t\tswitch (hdr.flags & VFIO_IRQ_SET_DATA_TYPE_MASK) {', '\t\tcase VFIO_IRQ_SET_DATA_NONE:', '\t\t\tsize = 0;', '\t\t\tbreak;', '\t\tcase VFIO_IRQ_SET_DATA_BOOL:', '\t\t\tsize = sizeof(uint8_t);', '\t\t\tbreak;', '\t\tcase VFIO_IRQ_SET_DATA_EVENTFD:', '\t\t\tsize = sizeof(int32_t);', '\t\t\tbreak;', '\t\tdefault:', '\t\t\treturn -EINVAL;', '\t\t}', '', '\t\tif (size) {', '\t\t\tif (hdr.argsz - minsz < hdr.count * size)']}",True,"drivers/vfio/pci/vfio_pci.c in the Linux kernel through 4.8.11 allows local users to bypass integer overflow checks, and cause a denial of service (memory corruption) or have unspecified other impact, by leveraging access to a vfio PCI device file for a VFIO_DEVICE_SET_IRQS ioctl call, aka a ""state machine confusion bug.""",7.8,HIGH,2,test,2016-10-12T16:51:24Z,1
CVE-2016-9083,"['CWE-119', 'CWE-190']",AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"vfio/pci: Fix integer overflows, bitmask check

The VFIO_DEVICE_SET_IRQS ioctl did not sufficiently sanitize
user-supplied integers, potentially allowing memory corruption. This
patch adds appropriate integer overflow checks, checks the range bounds
for VFIO_IRQ_SET_DATA_NONE, and also verifies that only single element
in the VFIO_IRQ_SET_DATA_TYPE_MASK bitmask is set.
VFIO_IRQ_SET_ACTION_TYPE_MASK is already correctly checked later in
vfio_pci_set_irqs_ioctl().

Furthermore, a kzalloc is changed to a kcalloc because the use of a
kzalloc with an integer multiplication allowed an integer overflow
condition to be reached without this patch. kcalloc checks for overflow
and should prevent a similar occurrence.

Signed-off-by: Vlad Tsyrklevich <vlad@tsyrklevich.net>
Signed-off-by: Alex Williamson <alex.williamson@redhat.com>",05692d7005a364add85c6e25a6c4447ce08f913a,https://github.com/torvalds/linux/commit/05692d7005a364add85c6e25a6c4447ce08f913a,drivers/vfio/pci/vfio_pci_intrs.c,vfio_msi_enable,"static int vfio_msi_enable(struct vfio_pci_device *vdev, int nvec, bool msix)
{
struct pci_dev *pdev = vdev->pdev;
unsigned int flag = msix ? PCI_IRQ_MSIX : PCI_IRQ_MSI;
int ret;
if (!is_irq_none(vdev))
return -EINVAL;
vdev->ctx = kzalloc(nvec * sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);
if (!vdev->ctx)
return -ENOMEM;
ret = pci_alloc_irq_vectors(pdev, 1, nvec, flag);
if (ret < nvec) {
if (ret > 0)
pci_free_irq_vectors(pdev);
kfree(vdev->ctx);
return ret;
}
vdev->num_ctx = nvec;
vdev->irq_type = msix ? VFIO_PCI_MSIX_IRQ_INDEX :
VFIO_PCI_MSI_IRQ_INDEX;
if (!msix) {
vdev->msi_qmax = fls(nvec * 2 - 1) - 1;
}
return 0;
}","static int vfio_msi_enable(struct vfio_pci_device *VAR_0, int VAR_1, bool VAR_2)
{
struct pci_dev *VAR_3 = VAR_0->pdev;
unsigned int VAR_4 = VAR_2 ? VAR_5 : VAR_6;
int VAR_7;
if (!is_irq_none(VAR_0))
return -VAR_8;
VAR_0->ctx = kzalloc(VAR_1 * sizeof(struct vfio_pci_irq_ctx), VAR_9);
if (!VAR_0->ctx)
return -VAR_10;
VAR_7 = pci_alloc_irq_vectors(VAR_3, 1, VAR_1, VAR_4);
if (VAR_7 < VAR_1) {
if (VAR_7 > 0)
pci_free_irq_vectors(VAR_3);
kfree(VAR_0->ctx);
return VAR_7;
}
VAR_0->num_ctx = VAR_1;
VAR_0->irq_type = VAR_2 ? VAR_11 :
VAR_12;
if (!VAR_2) {
VAR_0->msi_qmax = fls(VAR_1 * 2 - 1) - 1;
}
return 0;
}",torvalds/linux/05692d7005a364add85c6e25a6c4447ce08f913a/vfio_pci_intrs.c/vul/before/0.json,"static int vfio_msi_enable(struct vfio_pci_device *vdev, int nvec, bool msix)
{
	struct pci_dev *pdev = vdev->pdev;
	unsigned int flag = msix ? PCI_IRQ_MSIX : PCI_IRQ_MSI;
	int ret;

	if (!is_irq_none(vdev))
		return -EINVAL;

	vdev->ctx = kcalloc(nvec, sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);
	if (!vdev->ctx)
		return -ENOMEM;

	/* return the number of supported vectors if we can't get all: */
	ret = pci_alloc_irq_vectors(pdev, 1, nvec, flag);
	if (ret < nvec) {
		if (ret > 0)
			pci_free_irq_vectors(pdev);
		kfree(vdev->ctx);
		return ret;
	}

	vdev->num_ctx = nvec;
	vdev->irq_type = msix ? VFIO_PCI_MSIX_IRQ_INDEX :
				VFIO_PCI_MSI_IRQ_INDEX;

	if (!msix) {
		/*
		 * Compute the virtual hardware field for max msi vectors -
		 * it is the log base 2 of the number of vectors.
		 */
		vdev->msi_qmax = fls(nvec * 2 - 1) - 1;
	}

	return 0;
}","static int vfio_msi_enable(struct vfio_pci_device *VAR_0, int VAR_1, bool VAR_2)
{
	struct pci_dev *VAR_3 = VAR_0->pdev;
	unsigned int VAR_4 = VAR_2 ? VAR_5 : VAR_6;
	int VAR_7;

	if (!is_irq_none(VAR_0))
		return -VAR_8;

	VAR_0->ctx = kcalloc(VAR_1, sizeof(struct vfio_pci_irq_ctx), VAR_9);
	if (!VAR_0->ctx)
		return -VAR_10;

	/* COMMENT_0 */
	VAR_7 = pci_alloc_irq_vectors(VAR_3, 1, VAR_1, VAR_4);
	if (VAR_7 < VAR_1) {
		if (VAR_7 > 0)
			pci_free_irq_vectors(VAR_3);
		kfree(VAR_0->ctx);
		return VAR_7;
	}

	VAR_0->num_ctx = VAR_1;
	VAR_0->irq_type = VAR_2 ? VAR_11 :
				VAR_12;

	if (!VAR_2) {
		/* COMMENT_1 */
                                                             
                                                   
     
		VAR_0->msi_qmax = fls(VAR_1 * 2 - 1) - 1;
	}

	return 0;
}",torvalds/linux/05692d7005a364add85c6e25a6c4447ce08f913a/vfio_pci_intrs.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
 	if (!is_irq_none(vdev))
 		return -EINVAL;
 
-	vdev->ctx = kzalloc(nvec * sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);
+	vdev->ctx = kcalloc(nvec, sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);
 	if (!vdev->ctx)
 		return -ENOMEM;
 ","{'deleted_lines': ['\tvdev->ctx = kzalloc(nvec * sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);'], 'added_lines': ['\tvdev->ctx = kcalloc(nvec, sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);']}",True,"drivers/vfio/pci/vfio_pci.c in the Linux kernel through 4.8.11 allows local users to bypass integer overflow checks, and cause a denial of service (memory corruption) or have unspecified other impact, by leveraging access to a vfio PCI device file for a VFIO_DEVICE_SET_IRQS ioctl call, aka a ""state machine confusion bug.""",7.8,HIGH,2,test,2016-10-12T16:51:24Z,1
CVE-2016-10764,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"mtd: spi-nor: Off by one in cqspi_setup_flash()

There are CQSPI_MAX_CHIPSELECT elements in the ->f_pdata array so the >
should be >=.

Fixes: 140623410536 ('mtd: spi-nor: Add driver for Cadence Quad SPI Flash Controller')
Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
Reviewed-by: Marek Vasut <marex@denx.de>
Signed-off-by: Cyrille Pitchen <cyrille.pitchen@atmel.com>",193e87143c290ec16838f5368adc0e0bc94eb931,https://github.com/torvalds/linux/commit/193e87143c290ec16838f5368adc0e0bc94eb931,drivers/mtd/spi-nor/cadence-quadspi.c,cqspi_setup_flash,"static int cqspi_setup_flash(struct cqspi_st *cqspi, struct device_node *np)
{
struct platform_device *pdev = cqspi->pdev;
struct device *dev = &pdev->dev;
struct cqspi_flash_pdata *f_pdata;
struct spi_nor *nor;
struct mtd_info *mtd;
unsigned int cs;
int i, ret;
for_each_available_child_of_node(dev->of_node, np) {
if (of_property_read_u32(np, ""reg"", &cs)) {
dev_err(dev, ""Couldn't determine chip select.\n"");
goto err;
}
if (cs > CQSPI_MAX_CHIPSELECT) {
dev_err(dev, ""Chip select %d out of range.\n"", cs);
goto err;
}
f_pdata = &cqspi->f_pdata[cs];
f_pdata->cqspi = cqspi;
f_pdata->cs = cs;
ret = cqspi_of_get_flash_pdata(pdev, f_pdata, np);
if (ret)
goto err;
nor = &f_pdata->nor;
mtd = &nor->mtd;
mtd->priv = nor;
nor->dev = dev;
spi_nor_set_flash_node(nor, np);
nor->priv = f_pdata;
nor->read_reg = cqspi_read_reg;
nor->write_reg = cqspi_write_reg;
nor->read = cqspi_read;
nor->write = cqspi_write;
nor->erase = cqspi_erase;
nor->prepare = cqspi_prep;
nor->unprepare = cqspi_unprep;
mtd->name = devm_kasprintf(dev, GFP_KERNEL, ""%s.%d"",
dev_name(dev), cs);
if (!mtd->name) {
ret = -ENOMEM;
goto err;
}
ret = spi_nor_scan(nor, NULL, SPI_NOR_QUAD);
if (ret)
goto err;
ret = mtd_device_register(mtd, NULL, 0);
if (ret)
goto err;
f_pdata->registered = true;
}
return 0;
err:
for (i = 0; i < CQSPI_MAX_CHIPSELECT; i++)
if (cqspi->f_pdata[i].registered)
mtd_device_unregister(&cqspi->f_pdata[i].nor.mtd);
return ret;
}","static int cqspi_setup_flash(struct cqspi_st *VAR_0, struct device_node *VAR_1)
{
struct platform_device *VAR_2 = VAR_0->pdev;
struct device *VAR_3 = &VAR_2->dev;
struct cqspi_flash_pdata *VAR_4;
struct spi_nor *VAR_5;
struct mtd_info *VAR_6;
unsigned int VAR_7;
int VAR_8, VAR_9;
for_each_available_child_of_node(VAR_3->of_node, VAR_1) {
if (of_property_read_u32(VAR_1, ""reg"", &VAR_7)) {
dev_err(VAR_3, ""Couldn't determine chip select.\n"");
goto err;
}
if (VAR_7 > VAR_10) {
dev_err(VAR_3, ""Chip select %d out of range.\n"", VAR_7);
goto err;
}
VAR_4 = &VAR_0->f_pdata[VAR_7];
VAR_4->cqspi = VAR_0;
VAR_4->cs = VAR_7;
VAR_9 = cqspi_of_get_flash_pdata(VAR_2, VAR_4, VAR_1);
if (VAR_9)
goto err;
VAR_5 = &VAR_4->nor;
VAR_6 = &VAR_5->mtd;
VAR_6->priv = VAR_5;
VAR_5->dev = VAR_3;
spi_nor_set_flash_node(VAR_5, VAR_1);
VAR_5->priv = VAR_4;
VAR_5->read_reg = VAR_11;
VAR_5->write_reg = VAR_12;
VAR_5->read = VAR_13;
VAR_5->write = VAR_14;
VAR_5->erase = VAR_15;
VAR_5->prepare = VAR_16;
VAR_5->unprepare = VAR_17;
VAR_6->name = devm_kasprintf(VAR_3, VAR_18, ""%s.%d"",
dev_name(VAR_3), VAR_7);
if (!VAR_6->name) {
VAR_9 = -VAR_19;
goto err;
}
VAR_9 = spi_nor_scan(VAR_5, NULL, VAR_20);
if (VAR_9)
goto err;
VAR_9 = mtd_device_register(VAR_6, NULL, 0);
if (VAR_9)
goto err;
VAR_4->registered = true;
}
return 0;
err:
for (VAR_8 = 0; VAR_8 < VAR_10; VAR_8++)
if (VAR_0->f_pdata[VAR_8].registered)
mtd_device_unregister(&VAR_0->f_pdata[VAR_8].nor.mtd);
return VAR_9;
}",torvalds/linux/193e87143c290ec16838f5368adc0e0bc94eb931/cadence-quadspi.c/vul/before/0.json,"static int cqspi_setup_flash(struct cqspi_st *cqspi, struct device_node *np)
{
	struct platform_device *pdev = cqspi->pdev;
	struct device *dev = &pdev->dev;
	struct cqspi_flash_pdata *f_pdata;
	struct spi_nor *nor;
	struct mtd_info *mtd;
	unsigned int cs;
	int i, ret;

	/* Get flash device data */
	for_each_available_child_of_node(dev->of_node, np) {
		if (of_property_read_u32(np, ""reg"", &cs)) {
			dev_err(dev, ""Couldn't determine chip select.\n"");
			goto err;
		}

		if (cs >= CQSPI_MAX_CHIPSELECT) {
			dev_err(dev, ""Chip select %d out of range.\n"", cs);
			goto err;
		}

		f_pdata = &cqspi->f_pdata[cs];
		f_pdata->cqspi = cqspi;
		f_pdata->cs = cs;

		ret = cqspi_of_get_flash_pdata(pdev, f_pdata, np);
		if (ret)
			goto err;

		nor = &f_pdata->nor;
		mtd = &nor->mtd;

		mtd->priv = nor;

		nor->dev = dev;
		spi_nor_set_flash_node(nor, np);
		nor->priv = f_pdata;

		nor->read_reg = cqspi_read_reg;
		nor->write_reg = cqspi_write_reg;
		nor->read = cqspi_read;
		nor->write = cqspi_write;
		nor->erase = cqspi_erase;
		nor->prepare = cqspi_prep;
		nor->unprepare = cqspi_unprep;

		mtd->name = devm_kasprintf(dev, GFP_KERNEL, ""%s.%d"",
					   dev_name(dev), cs);
		if (!mtd->name) {
			ret = -ENOMEM;
			goto err;
		}

		ret = spi_nor_scan(nor, NULL, SPI_NOR_QUAD);
		if (ret)
			goto err;

		ret = mtd_device_register(mtd, NULL, 0);
		if (ret)
			goto err;

		f_pdata->registered = true;
	}

	return 0;

err:
	for (i = 0; i < CQSPI_MAX_CHIPSELECT; i++)
		if (cqspi->f_pdata[i].registered)
			mtd_device_unregister(&cqspi->f_pdata[i].nor.mtd);
	return ret;
}","static int cqspi_setup_flash(struct cqspi_st *VAR_0, struct device_node *VAR_1)
{
	struct platform_device *VAR_2 = VAR_0->pdev;
	struct device *VAR_3 = &VAR_2->dev;
	struct cqspi_flash_pdata *VAR_4;
	struct spi_nor *VAR_5;
	struct mtd_info *VAR_6;
	unsigned int VAR_7;
	int VAR_8, VAR_9;

	/* COMMENT_0 */
	for_each_available_child_of_node(VAR_3->of_node, VAR_1) {
		if (of_property_read_u32(VAR_1, ""reg"", &VAR_7)) {
			dev_err(VAR_3, ""Couldn't determine chip select.\n"");
			goto err;
		}

		if (VAR_7 >= VAR_10) {
			dev_err(VAR_3, ""Chip select %d out of range.\n"", VAR_7);
			goto err;
		}

		VAR_4 = &VAR_0->f_pdata[VAR_7];
		VAR_4->cqspi = VAR_0;
		VAR_4->cs = VAR_7;

		VAR_9 = cqspi_of_get_flash_pdata(VAR_2, VAR_4, VAR_1);
		if (VAR_9)
			goto err;

		VAR_5 = &VAR_4->nor;
		VAR_6 = &VAR_5->mtd;

		VAR_6->priv = VAR_5;

		VAR_5->dev = VAR_3;
		spi_nor_set_flash_node(VAR_5, VAR_1);
		VAR_5->priv = VAR_4;

		VAR_5->read_reg = VAR_11;
		VAR_5->write_reg = VAR_12;
		VAR_5->read = VAR_13;
		VAR_5->write = VAR_14;
		VAR_5->erase = VAR_15;
		VAR_5->prepare = VAR_16;
		VAR_5->unprepare = VAR_17;

		VAR_6->name = devm_kasprintf(VAR_3, VAR_18, ""%s.%d"",
					   dev_name(VAR_3), VAR_7);
		if (!VAR_6->name) {
			VAR_9 = -VAR_19;
			goto err;
		}

		VAR_9 = spi_nor_scan(VAR_5, NULL, VAR_20);
		if (VAR_9)
			goto err;

		VAR_9 = mtd_device_register(VAR_6, NULL, 0);
		if (VAR_9)
			goto err;

		VAR_4->registered = true;
	}

	return 0;

err:
	for (VAR_8 = 0; VAR_8 < VAR_10; VAR_8++)
		if (VAR_0->f_pdata[VAR_8].registered)
			mtd_device_unregister(&VAR_0->f_pdata[VAR_8].nor.mtd);
	return VAR_9;
}",torvalds/linux/193e87143c290ec16838f5368adc0e0bc94eb931/cadence-quadspi.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -15,7 +15,7 @@
 			goto err;
 		}
 
-		if (cs > CQSPI_MAX_CHIPSELECT) {
+		if (cs >= CQSPI_MAX_CHIPSELECT) {
 			dev_err(dev, ""Chip select %d out of range.\n"", cs);
 			goto err;
 		}","{'deleted_lines': ['\t\tif (cs > CQSPI_MAX_CHIPSELECT) {'], 'added_lines': ['\t\tif (cs >= CQSPI_MAX_CHIPSELECT) {']}",True,"In the Linux kernel before 4.9.6, there is an off by one in the drivers/mtd/spi-nor/cadence-quadspi.c cqspi_setup_flash() function. There are CQSPI_MAX_CHIPSELECT elements in the ->f_pdata array so the "">"" should be "">="" instead.",9.8,CRITICAL,3,test,2016-10-13T08:06:47Z,1
CVE-2016-9539,"['CWE-119', 'CWE-125']",AV:N/AC:L/Au:N/C:P/I:P/A:P,0,vadz/libtiff,"* tools/tiffcrop.c: fix out-of-bound read of up to 3 bytes in
readContigTilesIntoBuffer(). Reported as MSVR 35092 by Axel Souchet
& Vishal Chauhan from the MSRC Vulnerabilities & Mitigations team.",ae9365db1b271b62b35ce018eac8799b1d5e8a53,https://github.com/vadz/libtiff/commit/ae9365db1b271b62b35ce018eac8799b1d5e8a53,tools/tiffcrop.c,readContigTilesIntoBuffer,"static int readContigTilesIntoBuffer (TIFF* in, uint8* buf, 
uint32 imagelength, 
uint32 imagewidth, 
uint32 tw, uint32 tl,
tsample_t spp, uint16 bps)
{
int status = 1;
tsample_t sample = 0;
tsample_t count = spp; 
uint32 row, col, trow;
uint32 nrow, ncol;
uint32 dst_rowsize, shift_width;
uint32 bytes_per_sample, bytes_per_pixel;
uint32 trailing_bits, prev_trailing_bits;
uint32 tile_rowsize  = TIFFTileRowSize(in);
uint32 src_offset, dst_offset;
uint32 row_offset, col_offset;
uint8 *bufp = (uint8*) buf;
unsigned char *src = NULL;
unsigned char *dst = NULL;
tsize_t tbytes = 0, tile_buffsize = 0;
tsize_t tilesize = TIFFTileSize(in);
unsigned char *tilebuf = NULL;
bytes_per_sample = (bps + 7) / 8; 
bytes_per_pixel  = ((bps * spp) + 7) / 8;
if ((bps % 8) == 0)
shift_width = 0;
else
{
if (bytes_per_pixel < (bytes_per_sample + 1))
shift_width = bytes_per_pixel;
else
shift_width = bytes_per_sample + 1;
}
tile_buffsize = tilesize;
if (tilesize == 0 || tile_rowsize == 0)
{
TIFFError(""readContigTilesIntoBuffer"", ""Tile size or tile rowsize is zero"");
exit(-1);
}
if (tilesize < (tsize_t)(tl * tile_rowsize))
{
#ifdef DEBUG2
TIFFError(""readContigTilesIntoBuffer"",
""Tilesize %lu is too small, using alternate calculation %u"",
tilesize, tl * tile_rowsize);
#endif
tile_buffsize = tl * tile_rowsize;
if (tl != (tile_buffsize / tile_rowsize))
{
TIFFError(""readContigTilesIntoBuffer"", ""Integer overflow when calculating buffer size."");
exit(-1);
}
}
tilebuf = _TIFFmalloc(tile_buffsize);
if (tilebuf == 0)
return 0;
dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;  
for (row = 0; row < imagelength; row += tl)
{
nrow = (row + tl > imagelength) ? imagelength - row : tl;
for (col = 0; col < imagewidth; col += tw)
{
tbytes = TIFFReadTile(in, tilebuf, col, row, 0, 0);
if (tbytes < tilesize  && !ignore)
{
TIFFError(TIFFFileName(in),
""Error, can't read tile at row %lu col %lu, Read %lu bytes of %lu"",
(unsigned long) col, (unsigned long) row, (unsigned long)tbytes,
(unsigned long)tilesize);
status = 0;
_TIFFfree(tilebuf);
return status;
}
row_offset = row * dst_rowsize;
col_offset = ((col * bps * spp) + 7)/ 8;
bufp = buf + row_offset + col_offset;
if (col + tw > imagewidth)
ncol = imagewidth - col;
else
ncol = tw;
if (((bps % 8) == 0) && (count == spp))
{
for (trow = 0; trow < nrow; trow++)
{
src_offset = trow * tile_rowsize;
_TIFFmemcpy (bufp, tilebuf + src_offset, (ncol * spp * bps) / 8);
bufp += (imagewidth * bps * spp) / 8;
}
}
else
{
prev_trailing_bits = trailing_bits = 0;
trailing_bits = (ncol * bps * spp) % 8;
for (trow = 0; trow < nrow; trow++)
{
src_offset = trow * tile_rowsize;
src = tilebuf + src_offset;
dst_offset = (row + trow) * dst_rowsize;
dst = buf + dst_offset + col_offset;
switch (shift_width)
{
case 0: if (extractContigSamplesBytes (src, dst, ncol, sample,
spp, bps, count, 0, ncol))
{
TIFFError(""readContigTilesIntoBuffer"",
""Unable to extract row %d from tile %lu"", 
row, (unsigned long)TIFFCurrentTile(in));
return 1;
}
break;
case 1: if (bps == 1)
{ 
if (extractContigSamplesShifted8bits (src, dst, ncol,
sample, spp,
bps, count,
0, ncol,
prev_trailing_bits))
{
TIFFError(""readContigTilesIntoBuffer"",
""Unable to extract row %d from tile %lu"", 
row, (unsigned long)TIFFCurrentTile(in));
return 1;
}
break;
}
else
if (extractContigSamplesShifted16bits (src, dst, ncol,
sample, spp,
bps, count,
0, ncol,
prev_trailing_bits))
{
TIFFError(""readContigTilesIntoBuffer"",
""Unable to extract row %d from tile %lu"", 
row, (unsigned long)TIFFCurrentTile(in));
return 1;
}
break;
case 2: if (extractContigSamplesShifted24bits (src, dst, ncol,
sample, spp,
bps, count,
0, ncol,
prev_trailing_bits))
{
TIFFError(""readContigTilesIntoBuffer"",
""Unable to extract row %d from tile %lu"", 
row, (unsigned long)TIFFCurrentTile(in));
return 1;
}
break;
case 3:
case 4:
case 5: if (extractContigSamplesShifted32bits (src, dst, ncol,
sample, spp,
bps, count,
0, ncol,
prev_trailing_bits))
{
TIFFError(""readContigTilesIntoBuffer"",
""Unable to extract row %d from tile %lu"", 
row, (unsigned long)TIFFCurrentTile(in));
return 1;
}
break;
default: TIFFError(""readContigTilesIntoBuffer"", ""Unsupported bit depth %d"", bps);
return 1;
}
}
prev_trailing_bits += trailing_bits;
}
}
}
_TIFFfree(tilebuf);
return status;
}","static int readContigTilesIntoBuffer (TIFF* VAR_0, uint8* VAR_1, 
uint32 VAR_2, 
uint32 VAR_3, 
uint32 VAR_4, uint32 VAR_5,
tsample_t VAR_6, uint16 VAR_7)
{
int VAR_8 = 1;
tsample_t VAR_9 = 0;
tsample_t VAR_10 = VAR_6; 
uint32 VAR_11, VAR_12, VAR_13;
uint32 VAR_14, VAR_15;
uint32 VAR_16, VAR_17;
uint32 VAR_18, VAR_19;
uint32 VAR_20, VAR_21;
uint32 VAR_22  = TIFFTileRowSize(VAR_0);
uint32 VAR_23, VAR_24;
uint32 VAR_25, VAR_26;
uint8 *VAR_27 = (uint8*) VAR_1;
unsigned char *VAR_28 = NULL;
unsigned char *VAR_29 = NULL;
tsize_t VAR_30 = 0, VAR_31 = 0;
tsize_t VAR_32 = TIFFTileSize(VAR_0);
unsigned char *VAR_33 = NULL;
VAR_18 = (VAR_7 + 7) / 8; 
VAR_19  = ((VAR_7 * VAR_6) + 7) / 8;
if ((VAR_7 % 8) == 0)
VAR_17 = 0;
else
{
if (VAR_19 < (VAR_18 + 1))
VAR_17 = VAR_19;
else
VAR_17 = VAR_18 + 1;
}
VAR_31 = VAR_32;
if (VAR_32 == 0 || VAR_22 == 0)
{
TIFFError(""readContigTilesIntoBuffer"", ""Tile size or tile rowsize is zero"");
exit(-1);
}
if (VAR_32 < (tsize_t)(VAR_5 * VAR_22))
{
#ifdef VAR_34
TIFFError(""readContigTilesIntoBuffer"",
""Tilesize %lu is too small, using alternate calculation %u"",
VAR_32, VAR_5 * VAR_22);
#endif
VAR_31 = VAR_5 * VAR_22;
if (VAR_5 != (VAR_31 / VAR_22))
{
TIFFError(""readContigTilesIntoBuffer"", ""Integer overflow when calculating buffer size."");
exit(-1);
}
}
VAR_33 = _TIFFmalloc(VAR_31);
if (VAR_33 == 0)
return 0;
VAR_16 = ((VAR_3 * VAR_7 * VAR_6) + 7) / 8;  
for (VAR_11 = 0; VAR_11 < VAR_2; VAR_11 += VAR_5)
{
VAR_14 = (VAR_11 + VAR_5 > VAR_2) ? VAR_2 - VAR_11 : VAR_5;
for (VAR_12 = 0; VAR_12 < VAR_3; VAR_12 += VAR_4)
{
VAR_30 = TIFFReadTile(VAR_0, VAR_33, VAR_12, VAR_11, 0, 0);
if (VAR_30 < VAR_32  && !VAR_35)
{
TIFFError(TIFFFileName(VAR_0),
""Error, can't read tile at row %lu col %lu, Read %lu bytes of %lu"",
(unsigned long) VAR_12, (unsigned long) VAR_11, (unsigned long)VAR_30,
(unsigned long)VAR_32);
VAR_8 = 0;
_TIFFfree(VAR_33);
return VAR_8;
}
VAR_25 = VAR_11 * VAR_16;
VAR_26 = ((VAR_12 * VAR_7 * VAR_6) + 7)/ 8;
VAR_27 = VAR_1 + VAR_25 + VAR_26;
if (VAR_12 + VAR_4 > VAR_3)
VAR_15 = VAR_3 - VAR_12;
else
VAR_15 = VAR_4;
if (((VAR_7 % 8) == 0) && (VAR_10 == VAR_6))
{
for (VAR_13 = 0; VAR_13 < VAR_14; VAR_13++)
{
VAR_23 = VAR_13 * VAR_22;
_TIFFmemcpy (VAR_27, VAR_33 + VAR_23, (VAR_15 * VAR_6 * VAR_7) / 8);
VAR_27 += (VAR_3 * VAR_7 * VAR_6) / 8;
}
}
else
{
VAR_21 = VAR_20 = 0;
VAR_20 = (VAR_15 * VAR_7 * VAR_6) % 8;
for (VAR_13 = 0; VAR_13 < VAR_14; VAR_13++)
{
VAR_23 = VAR_13 * VAR_22;
VAR_28 = VAR_33 + VAR_23;
VAR_24 = (VAR_11 + VAR_13) * VAR_16;
VAR_29 = VAR_1 + VAR_24 + VAR_26;
switch (VAR_17)
{
case 0: if (extractContigSamplesBytes (VAR_28, VAR_29, VAR_15, VAR_9,
VAR_6, VAR_7, VAR_10, 0, VAR_15))
{
TIFFError(""readContigTilesIntoBuffer"",
""Unable to extract row %d from tile %lu"", 
VAR_11, (unsigned long)TIFFCurrentTile(VAR_0));
return 1;
}
break;
case 1: if (VAR_7 == 1)
{ 
if (extractContigSamplesShifted8bits (VAR_28, VAR_29, VAR_15,
VAR_9, VAR_6,
VAR_7, VAR_10,
0, VAR_15,
VAR_21))
{
TIFFError(""readContigTilesIntoBuffer"",
""Unable to extract row %d from tile %lu"", 
VAR_11, (unsigned long)TIFFCurrentTile(VAR_0));
return 1;
}
break;
}
else
if (extractContigSamplesShifted16bits (VAR_28, VAR_29, VAR_15,
VAR_9, VAR_6,
VAR_7, VAR_10,
0, VAR_15,
VAR_21))
{
TIFFError(""readContigTilesIntoBuffer"",
""Unable to extract row %d from tile %lu"", 
VAR_11, (unsigned long)TIFFCurrentTile(VAR_0));
return 1;
}
break;
case 2: if (extractContigSamplesShifted24bits (VAR_28, VAR_29, VAR_15,
VAR_9, VAR_6,
VAR_7, VAR_10,
0, VAR_15,
VAR_21))
{
TIFFError(""readContigTilesIntoBuffer"",
""Unable to extract row %d from tile %lu"", 
VAR_11, (unsigned long)TIFFCurrentTile(VAR_0));
return 1;
}
break;
case 3:
case 4:
case 5: if (extractContigSamplesShifted32bits (VAR_28, VAR_29, VAR_15,
VAR_9, VAR_6,
VAR_7, VAR_10,
0, VAR_15,
VAR_21))
{
TIFFError(""readContigTilesIntoBuffer"",
""Unable to extract row %d from tile %lu"", 
VAR_11, (unsigned long)TIFFCurrentTile(VAR_0));
return 1;
}
break;
default: TIFFError(""readContigTilesIntoBuffer"", ""Unsupported bit depth %d"", VAR_7);
return 1;
}
}
VAR_21 += VAR_20;
}
}
}
_TIFFfree(VAR_33);
return VAR_8;
}",vadz/libtiff/ae9365db1b271b62b35ce018eac8799b1d5e8a53/tiffcrop.c/vul/before/0.json,"static int readContigTilesIntoBuffer (TIFF* in, uint8* buf, 
                                      uint32 imagelength, 
                                      uint32 imagewidth, 
                                      uint32 tw, uint32 tl,
                                      tsample_t spp, uint16 bps)
  {
  int status = 1;
  tsample_t sample = 0;
  tsample_t count = spp; 
  uint32 row, col, trow;
  uint32 nrow, ncol;
  uint32 dst_rowsize, shift_width;
  uint32 bytes_per_sample, bytes_per_pixel;
  uint32 trailing_bits, prev_trailing_bits;
  uint32 tile_rowsize  = TIFFTileRowSize(in);
  uint32 src_offset, dst_offset;
  uint32 row_offset, col_offset;
  uint8 *bufp = (uint8*) buf;
  unsigned char *src = NULL;
  unsigned char *dst = NULL;
  tsize_t tbytes = 0, tile_buffsize = 0;
  tsize_t tilesize = TIFFTileSize(in);
  unsigned char *tilebuf = NULL;

  bytes_per_sample = (bps + 7) / 8; 
  bytes_per_pixel  = ((bps * spp) + 7) / 8;

  if ((bps % 8) == 0)
    shift_width = 0;
  else
    {
    if (bytes_per_pixel < (bytes_per_sample + 1))
      shift_width = bytes_per_pixel;
    else
      shift_width = bytes_per_sample + 1;
    }

  tile_buffsize = tilesize;
  if (tilesize == 0 || tile_rowsize == 0)
  {
     TIFFError(""readContigTilesIntoBuffer"", ""Tile size or tile rowsize is zero"");
     exit(-1);
  }

  if (tilesize < (tsize_t)(tl * tile_rowsize))
    {
#ifdef DEBUG2
    TIFFError(""readContigTilesIntoBuffer"",
	      ""Tilesize %lu is too small, using alternate calculation %u"",
              tilesize, tl * tile_rowsize);
#endif
    tile_buffsize = tl * tile_rowsize;
    if (tl != (tile_buffsize / tile_rowsize))
    {
    	TIFFError(""readContigTilesIntoBuffer"", ""Integer overflow when calculating buffer size."");
        exit(-1);
    }
    }

  /* Add 3 padding bytes for extractContigSamplesShifted32bits */
  if( tile_buffsize > 0xFFFFFFFFU - 3 )
  {
      TIFFError(""readContigTilesIntoBuffer"", ""Integer overflow when calculating buffer size."");
      exit(-1);
  }
  tilebuf = _TIFFmalloc(tile_buffsize + 3);
  if (tilebuf == 0)
    return 0;
  tilebuf[tile_buffsize] = 0;
  tilebuf[tile_buffsize+1] = 0;
  tilebuf[tile_buffsize+2] = 0;

  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;  
  for (row = 0; row < imagelength; row += tl)
    {
    nrow = (row + tl > imagelength) ? imagelength - row : tl;
    for (col = 0; col < imagewidth; col += tw)
      {
      tbytes = TIFFReadTile(in, tilebuf, col, row, 0, 0);
      if (tbytes < tilesize  && !ignore)
        {
	TIFFError(TIFFFileName(in),
		  ""Error, can't read tile at row %lu col %lu, Read %lu bytes of %lu"",
		  (unsigned long) col, (unsigned long) row, (unsigned long)tbytes,
                  (unsigned long)tilesize);
		  status = 0;
                  _TIFFfree(tilebuf);
		  return status;
	}
      
      row_offset = row * dst_rowsize;
      col_offset = ((col * bps * spp) + 7)/ 8;
      bufp = buf + row_offset + col_offset;

      if (col + tw > imagewidth)
	ncol = imagewidth - col;
      else
        ncol = tw;

      /* Each tile scanline will start on a byte boundary but it
       * has to be merged into the scanline for the entire
       * image buffer and the previous segment may not have
       * ended on a byte boundary
       */
      /* Optimization for common bit depths, all samples */
      if (((bps % 8) == 0) && (count == spp))
        {
	for (trow = 0; trow < nrow; trow++)
          {
	  src_offset = trow * tile_rowsize;
	  _TIFFmemcpy (bufp, tilebuf + src_offset, (ncol * spp * bps) / 8);
          bufp += (imagewidth * bps * spp) / 8;
	  }
        }
      else
        {
	/* Bit depths not a multiple of 8 and/or extract fewer than spp samples */
        prev_trailing_bits = trailing_bits = 0;
        trailing_bits = (ncol * bps * spp) % 8;

	/*	for (trow = 0; tl < nrow; trow++) */
	for (trow = 0; trow < nrow; trow++)
          {
	  src_offset = trow * tile_rowsize;
          src = tilebuf + src_offset;
	  dst_offset = (row + trow) * dst_rowsize;
          dst = buf + dst_offset + col_offset;
          switch (shift_width)
            {
            case 0: if (extractContigSamplesBytes (src, dst, ncol, sample,
                                                   spp, bps, count, 0, ncol))
                      {
		      TIFFError(""readContigTilesIntoBuffer"",
                                ""Unable to extract row %d from tile %lu"", 
				row, (unsigned long)TIFFCurrentTile(in));
		      return 1;
		      }
		    break;
            case 1: if (bps == 1)
                      { 
                      if (extractContigSamplesShifted8bits (src, dst, ncol,
                                                            sample, spp,
                                                            bps, count,
                                                            0, ncol,
                                                            prev_trailing_bits))
                        {
		        TIFFError(""readContigTilesIntoBuffer"",
                                  ""Unable to extract row %d from tile %lu"", 
				  row, (unsigned long)TIFFCurrentTile(in));
		        return 1;
		        }
		      break;
		      }
                    else
                      if (extractContigSamplesShifted16bits (src, dst, ncol,
                                                             sample, spp,
                                                             bps, count,
                                                             0, ncol,
                                                             prev_trailing_bits))
                        {
		        TIFFError(""readContigTilesIntoBuffer"",
                                  ""Unable to extract row %d from tile %lu"", 
			  	  row, (unsigned long)TIFFCurrentTile(in));
		        return 1;
		        }
	            break;
            case 2: if (extractContigSamplesShifted24bits (src, dst, ncol,
                                                           sample, spp,
                                                           bps, count,
                                                           0, ncol,
                                                           prev_trailing_bits))
                      {
		      TIFFError(""readContigTilesIntoBuffer"",
                                ""Unable to extract row %d from tile %lu"", 
		  	        row, (unsigned long)TIFFCurrentTile(in));
		      return 1;
		      }
		    break;
            case 3:
            case 4:
            case 5: if (extractContigSamplesShifted32bits (src, dst, ncol,
                                                           sample, spp,
                                                           bps, count,
                                                           0, ncol,
                                                           prev_trailing_bits))
                      {
		      TIFFError(""readContigTilesIntoBuffer"",
                                ""Unable to extract row %d from tile %lu"", 
			        row, (unsigned long)TIFFCurrentTile(in));
		      return 1;
		      }
		    break;
            default: TIFFError(""readContigTilesIntoBuffer"", ""Unsupported bit depth %d"", bps);
		     return 1;
	    }
          }
        prev_trailing_bits += trailing_bits;
        /* if (prev_trailing_bits > 7) */
	/*   prev_trailing_bits-= 8; */
	}
      }
    }

  _TIFFfree(tilebuf);
  return status;
  }","static int readContigTilesIntoBuffer (TIFF* VAR_0, uint8* VAR_1, 
                                      uint32 VAR_2, 
                                      uint32 VAR_3, 
                                      uint32 VAR_4, uint32 VAR_5,
                                      tsample_t VAR_6, uint16 VAR_7)
  {
  int VAR_8 = 1;
  tsample_t VAR_9 = 0;
  tsample_t VAR_10 = VAR_6; 
  uint32 VAR_11, VAR_12, VAR_13;
  uint32 VAR_14, VAR_15;
  uint32 VAR_16, VAR_17;
  uint32 VAR_18, VAR_19;
  uint32 VAR_20, VAR_21;
  uint32 VAR_22  = TIFFTileRowSize(VAR_0);
  uint32 VAR_23, VAR_24;
  uint32 VAR_25, VAR_26;
  uint8 *VAR_27 = (uint8*) VAR_1;
  unsigned char *VAR_28 = NULL;
  unsigned char *VAR_29 = NULL;
  tsize_t VAR_30 = 0, VAR_31 = 0;
  tsize_t VAR_32 = TIFFTileSize(VAR_0);
  unsigned char *VAR_33 = NULL;

  VAR_18 = (VAR_7 + 7) / 8; 
  VAR_19  = ((VAR_7 * VAR_6) + 7) / 8;

  if ((VAR_7 % 8) == 0)
    VAR_17 = 0;
  else
    {
    if (VAR_19 < (VAR_18 + 1))
      VAR_17 = VAR_19;
    else
      VAR_17 = VAR_18 + 1;
    }

  VAR_31 = VAR_32;
  if (VAR_32 == 0 || VAR_22 == 0)
  {
     TIFFError(""readContigTilesIntoBuffer"", ""Tile size or tile rowsize is zero"");
     exit(-1);
  }

  if (VAR_32 < (tsize_t)(VAR_5 * VAR_22))
    {
#ifdef VAR_34
    TIFFError(""readContigTilesIntoBuffer"",
	      ""Tilesize %lu is too small, using alternate calculation %u"",
              VAR_32, VAR_5 * VAR_22);
#endif
    VAR_31 = VAR_5 * VAR_22;
    if (VAR_5 != (VAR_31 / VAR_22))
    {
    	TIFFError(""readContigTilesIntoBuffer"", ""Integer overflow when calculating buffer size."");
        exit(-1);
    }
    }

  /* COMMENT_0 */
  if( VAR_31 > 0xFFFFFFFFU - 3 )
  {
      TIFFError(""readContigTilesIntoBuffer"", ""Integer overflow when calculating buffer size."");
      exit(-1);
  }
  VAR_33 = _TIFFmalloc(VAR_31 + 3);
  if (VAR_33 == 0)
    return 0;
  VAR_33[VAR_31] = 0;
  VAR_33[VAR_31+1] = 0;
  VAR_33[VAR_31+2] = 0;

  VAR_16 = ((VAR_3 * VAR_7 * VAR_6) + 7) / 8;  
  for (VAR_11 = 0; VAR_11 < VAR_2; VAR_11 += VAR_5)
    {
    VAR_14 = (VAR_11 + VAR_5 > VAR_2) ? VAR_2 - VAR_11 : VAR_5;
    for (VAR_12 = 0; VAR_12 < VAR_3; VAR_12 += VAR_4)
      {
      VAR_30 = TIFFReadTile(VAR_0, VAR_33, VAR_12, VAR_11, 0, 0);
      if (VAR_30 < VAR_32  && !VAR_35)
        {
	TIFFError(TIFFFileName(VAR_0),
		  ""Error, can't read tile at row %lu col %lu, Read %lu bytes of %lu"",
		  (unsigned long) VAR_12, (unsigned long) VAR_11, (unsigned long)VAR_30,
                  (unsigned long)VAR_32);
		  VAR_8 = 0;
                  _TIFFfree(VAR_33);
		  return VAR_8;
	}
      
      VAR_25 = VAR_11 * VAR_16;
      VAR_26 = ((VAR_12 * VAR_7 * VAR_6) + 7)/ 8;
      VAR_27 = VAR_1 + VAR_25 + VAR_26;

      if (VAR_12 + VAR_4 > VAR_3)
	VAR_15 = VAR_3 - VAR_12;
      else
        VAR_15 = VAR_4;

      /* COMMENT_1 */
                                                          
                                                           
                                 
         
      /* COMMENT_6 */
      if (((VAR_7 % 8) == 0) && (VAR_10 == VAR_6))
        {
	for (VAR_13 = 0; VAR_13 < VAR_14; VAR_13++)
          {
	  VAR_23 = VAR_13 * VAR_22;
	  _TIFFmemcpy (VAR_27, VAR_33 + VAR_23, (VAR_15 * VAR_6 * VAR_7) / 8);
          VAR_27 += (VAR_3 * VAR_7 * VAR_6) / 8;
	  }
        }
      else
        {
	/* COMMENT_7 */
        VAR_21 = VAR_20 = 0;
        VAR_20 = (VAR_15 * VAR_7 * VAR_6) % 8;

	/* COMMENT_8 */
	for (VAR_13 = 0; VAR_13 < VAR_14; VAR_13++)
          {
	  VAR_23 = VAR_13 * VAR_22;
          VAR_28 = VAR_33 + VAR_23;
	  VAR_24 = (VAR_11 + VAR_13) * VAR_16;
          VAR_29 = VAR_1 + VAR_24 + VAR_26;
          switch (VAR_17)
            {
            case 0: if (extractContigSamplesBytes (VAR_28, VAR_29, VAR_15, VAR_9,
                                                   VAR_6, VAR_7, VAR_10, 0, VAR_15))
                      {
		      TIFFError(""readContigTilesIntoBuffer"",
                                ""Unable to extract row %d from tile %lu"", 
				VAR_11, (unsigned long)TIFFCurrentTile(VAR_0));
		      return 1;
		      }
		    break;
            case 1: if (VAR_7 == 1)
                      { 
                      if (extractContigSamplesShifted8bits (VAR_28, VAR_29, VAR_15,
                                                            VAR_9, VAR_6,
                                                            VAR_7, VAR_10,
                                                            0, VAR_15,
                                                            VAR_21))
                        {
		        TIFFError(""readContigTilesIntoBuffer"",
                                  ""Unable to extract row %d from tile %lu"", 
				  VAR_11, (unsigned long)TIFFCurrentTile(VAR_0));
		        return 1;
		        }
		      break;
		      }
                    else
                      if (extractContigSamplesShifted16bits (VAR_28, VAR_29, VAR_15,
                                                             VAR_9, VAR_6,
                                                             VAR_7, VAR_10,
                                                             0, VAR_15,
                                                             VAR_21))
                        {
		        TIFFError(""readContigTilesIntoBuffer"",
                                  ""Unable to extract row %d from tile %lu"", 
			  	  VAR_11, (unsigned long)TIFFCurrentTile(VAR_0));
		        return 1;
		        }
	            break;
            case 2: if (extractContigSamplesShifted24bits (VAR_28, VAR_29, VAR_15,
                                                           VAR_9, VAR_6,
                                                           VAR_7, VAR_10,
                                                           0, VAR_15,
                                                           VAR_21))
                      {
		      TIFFError(""readContigTilesIntoBuffer"",
                                ""Unable to extract row %d from tile %lu"", 
		  	        VAR_11, (unsigned long)TIFFCurrentTile(VAR_0));
		      return 1;
		      }
		    break;
            case 3:
            case 4:
            case 5: if (extractContigSamplesShifted32bits (VAR_28, VAR_29, VAR_15,
                                                           VAR_9, VAR_6,
                                                           VAR_7, VAR_10,
                                                           0, VAR_15,
                                                           VAR_21))
                      {
		      TIFFError(""readContigTilesIntoBuffer"",
                                ""Unable to extract row %d from tile %lu"", 
			        VAR_11, (unsigned long)TIFFCurrentTile(VAR_0));
		      return 1;
		      }
		    break;
            default: TIFFError(""readContigTilesIntoBuffer"", ""Unsupported bit depth %d"", VAR_7);
		     return 1;
	    }
          }
        VAR_21 += VAR_20;
        /* COMMENT_9 */
	/* COMMENT_10 */
	}
      }
    }

  _TIFFfree(VAR_33);
  return VAR_8;
  }",vadz/libtiff/ae9365db1b271b62b35ce018eac8799b1d5e8a53/tiffcrop.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -57,9 +57,18 @@
     }
     }
 
-  tilebuf = _TIFFmalloc(tile_buffsize);
+  /* Add 3 padding bytes for extractContigSamplesShifted32bits */
+  if( tile_buffsize > 0xFFFFFFFFU - 3 )
+  {
+      TIFFError(""readContigTilesIntoBuffer"", ""Integer overflow when calculating buffer size."");
+      exit(-1);
+  }
+  tilebuf = _TIFFmalloc(tile_buffsize + 3);
   if (tilebuf == 0)
     return 0;
+  tilebuf[tile_buffsize] = 0;
+  tilebuf[tile_buffsize+1] = 0;
+  tilebuf[tile_buffsize+2] = 0;
 
   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;  
   for (row = 0; row < imagelength; row += tl)","{'deleted_lines': ['  tilebuf = _TIFFmalloc(tile_buffsize);'], 'added_lines': ['  /* Add 3 padding bytes for extractContigSamplesShifted32bits */', '  if( tile_buffsize > 0xFFFFFFFFU - 3 )', '  {', '      TIFFError(""readContigTilesIntoBuffer"", ""Integer overflow when calculating buffer size."");', '      exit(-1);', '  }', '  tilebuf = _TIFFmalloc(tile_buffsize + 3);', '  tilebuf[tile_buffsize] = 0;', '  tilebuf[tile_buffsize+1] = 0;', '  tilebuf[tile_buffsize+2] = 0;']}",True,tools/tiffcrop.c in libtiff 4.0.6 has an out-of-bounds read in readContigTilesIntoBuffer(). Reported as MSVR 35092.,9.8,CRITICAL,3,test,2016-10-14T19:13:20Z,1
CVE-2016-10058,['CWE-400'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,ImageMagick,Fixed memory leak.,4ec444f4eab88cf4bec664fafcf9cab50bc5ff6a,https://github.com/ImageMagick/ImageMagick/commit/4ec444f4eab88cf4bec664fafcf9cab50bc5ff6a,coders/psd.c,ReadPSDLayers,"ModuleExport MagickBooleanType ReadPSDLayers(Image *image,
const ImageInfo *image_info,const PSDInfo *psd_info,
const MagickBooleanType skip_layers,ExceptionInfo *exception)
{
char
type[4];
LayerInfo
*layer_info;
MagickSizeType
size;
MagickBooleanType
status;
register ssize_t
i;
ssize_t
count,
j,
number_layers;
size=GetPSDSize(psd_info,image);
if (size == 0)
{
(void) ReadBlobLong(image);
count=ReadBlob(image,4,(unsigned char *) type);
ReversePSDString(image,type,4);
status=MagickFalse;
if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
return(MagickTrue);
else
{
count=ReadBlob(image,4,(unsigned char *) type);
ReversePSDString(image,type,4);
if ((count != 0) && (LocaleNCompare(type,""Lr16"",4) == 0))
size=GetPSDSize(psd_info,image);
else
return(MagickTrue);
}
}
status=MagickTrue;
if (size != 0)
{
layer_info=(LayerInfo *) NULL;
number_layers=(short) ReadBlobShort(image);
if (number_layers < 0)
{
number_layers=MagickAbsoluteValue(number_layers);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  negative layer count corrected for"");
image->matte=MagickTrue;
}
if (skip_layers != MagickFalse)
return(MagickTrue);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  image contains %.20g layers"",(double) number_layers);
if (number_layers == 0)
ThrowBinaryException(CorruptImageError,""InvalidNumberOfLayers"",
image->filename);
layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,
sizeof(*layer_info));
if (layer_info == (LayerInfo *) NULL)
{
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  allocation of LayerInfo failed"");
ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
image->filename);
}
(void) ResetMagickMemory(layer_info,0,(size_t) number_layers*
sizeof(*layer_info));
for (i=0; i < number_layers; i++)
{
ssize_t
x,
y;
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  reading layer #%.20g"",(double) i+1);
layer_info[i].page.y=ReadBlobSignedLong(image);
layer_info[i].page.x=ReadBlobSignedLong(image);
y=ReadBlobSignedLong(image);
x=ReadBlobSignedLong(image);
layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);
layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);
layer_info[i].channels=ReadBlobShort(image);
if (layer_info[i].channels > MaxPSDChannels)
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,""MaximumChannelsExceeded"",
image->filename);
}
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
(double) layer_info[i].page.x,(double) layer_info[i].page.y,
(double) layer_info[i].page.height,(double)
layer_info[i].page.width,(double) layer_info[i].channels);
for (j=0; j < (ssize_t) layer_info[i].channels; j++)
{
layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);
layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,
image);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""    channel[%.20g]: type=%.20g, size=%.20g"",(double) j,
(double) layer_info[i].channel_info[j].type,
(double) layer_info[i].channel_info[j].size);
}
count=ReadBlob(image,4,(unsigned char *) type);
ReversePSDString(image,type,4);
if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
{
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  layer type was %.4s instead of 8BIM"", type);
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,""ImproperImageHeader"",
image->filename);
}
(void) ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);
ReversePSDString(image,layer_info[i].blendkey,4);
layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)
ReadBlobByte(image));
layer_info[i].clipping=(unsigned char) ReadBlobByte(image);
layer_info[i].flags=(unsigned char) ReadBlobByte(image);
layer_info[i].visible=!(layer_info[i].flags & 0x02);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s"",
layer_info[i].blendkey,(double) layer_info[i].opacity,
layer_info[i].clipping ? ""true"" : ""false"",layer_info[i].flags,
layer_info[i].visible ? ""true"" : ""false"");
(void) ReadBlobByte(image);  
size=ReadBlobLong(image);
if (size != 0)
{
MagickSizeType
combined_length,
length;
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""    layer contains additional info"");
length=ReadBlobLong(image);
combined_length=length+4;
if (length != 0)
{
layer_info[i].mask.page.y=ReadBlobSignedLong(image);
layer_info[i].mask.page.x=ReadBlobSignedLong(image);
layer_info[i].mask.page.height=(size_t) (ReadBlobLong(image)-
layer_info[i].mask.page.y);
layer_info[i].mask.page.width=(size_t) (ReadBlobLong(image)-
layer_info[i].mask.page.x);
layer_info[i].mask.background=(unsigned char) ReadBlobByte(
image);
layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);
if (!(layer_info[i].mask.flags & 0x01))
{
layer_info[i].mask.page.y=layer_info[i].mask.page.y-
layer_info[i].page.y;
layer_info[i].mask.page.x=layer_info[i].mask.page.x-
layer_info[i].page.x;
}
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g"",
(double) layer_info[i].mask.page.x,(double)
layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,
(double) layer_info[i].mask.page.height,(double)
((MagickOffsetType) length)-18);
if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
}
}
length=ReadBlobLong(image);
combined_length+=length+4;
if (length != 0)
{
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""      layer blending ranges: length=%.20g"",(double)
((MagickOffsetType) length));
for (j=0; j < (ssize_t) length; j+=8)
{
size_t blend_source=ReadBlobLong(image);
size_t blend_dest=ReadBlobLong(image);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""        source(%x), dest(%x)"",(unsigned int)
blend_source,(unsigned int) blend_dest);
}
}
length=(MagickSizeType) ReadBlobByte(image);
combined_length+=length+1;
if (length > 0)
(void) ReadBlob(image,(size_t) length++,layer_info[i].name);
layer_info[i].name[length]='\0';
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""      layer name: %s"",layer_info[i].name);
if ((length % 4) != 0)
{
length=4-(length % 4);
combined_length+=length;
if (DiscardBlobBytes(image,length) == MagickFalse)
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,
""UnexpectedEndOfFile"",image->filename);
}
}
length=(MagickSizeType) size-combined_length;
if (length > 0)
{
unsigned char
*info;
layer_info[i].info=AcquireStringInfo((const size_t) length);
info=GetStringInfoDatum(layer_info[i].info);
(void) ReadBlob(image,(const size_t) length,info);
}
}
}
for (i=0; i < number_layers; i++)
{
if ((layer_info[i].page.width == 0) ||
(layer_info[i].page.height == 0))
{
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""      layer data is empty"");
continue;
}
layer_info[i].image=CloneImage(image,layer_info[i].page.width,
layer_info[i].page.height,MagickFalse,exception);
if (layer_info[i].image == (Image *) NULL)
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  allocation of image for layer %.20g failed"",(double) i);
ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
image->filename);
}
if (layer_info[i].info != (StringInfo *) NULL)
{
(void) SetImageProfile(layer_info[i].image,""psd:additional-info"",
layer_info[i].info);
layer_info[i].info=DestroyStringInfo(layer_info[i].info);
}
}
if (image_info->ping == MagickFalse)
{
for (i=0; i < number_layers; i++)
{
if (layer_info[i].image == (Image *) NULL)
{
for (j=0; j < layer_info[i].channels; j++)
{
if (DiscardBlobBytes(image,(MagickSizeType)
layer_info[i].channel_info[j].size) == MagickFalse)
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,
""UnexpectedEndOfFile"",image->filename);
}
}
continue;
}
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  reading data for layer %.20g"",(double) i);
status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],
exception);
if (status == MagickFalse)
break;
status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)
number_layers);
if (status == MagickFalse)
break;
}
}
if (status != MagickFalse)
{
for (i=0; i < number_layers; i++)
{
if (layer_info[i].image == (Image *) NULL)
{
for (j=i; j < number_layers - 1; j++)
layer_info[j] = layer_info[j+1];
number_layers--;
i--;
}
}
if (number_layers > 0)
{
for (i=0; i < number_layers; i++)
{
if (i > 0)
layer_info[i].image->previous=layer_info[i-1].image;
if (i < (number_layers-1))
layer_info[i].image->next=layer_info[i+1].image;
layer_info[i].image->page=layer_info[i].page;
}
image->next=layer_info[0].image;
layer_info[0].image->previous=image;
}
layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);
}
else
layer_info=DestroyLayerInfo(layer_info,number_layers);
}
return(status);
}","ModuleExport VAR_0 ReadPSDLayers(Image *VAR_1,
const ImageInfo *VAR_2,const PSDInfo *VAR_3,
const MagickBooleanType VAR_4,ExceptionInfo *VAR_5)
{
char
VAR_6[4];
LayerInfo
*VAR_7;
MagickSizeType
VAR_8;
MagickBooleanType
VAR_9;
register ssize_t
VAR_10;
ssize_t
VAR_11,
VAR_12,
VAR_13;
VAR_8=GetPSDSize(VAR_3,VAR_1);
if (VAR_8 == 0)
{
(void) ReadBlobLong(VAR_1);
VAR_11=ReadBlob(VAR_1,4,(unsigned char *) VAR_6);
ReversePSDString(VAR_1,VAR_6,4);
VAR_9=VAR_14;
if ((VAR_11 == 0) || (LocaleNCompare(VAR_6,""8BIM"",4) != 0))
return(VAR_15);
else
{
VAR_11=ReadBlob(VAR_1,4,(unsigned char *) VAR_6);
ReversePSDString(VAR_1,VAR_6,4);
if ((VAR_11 != 0) && (LocaleNCompare(VAR_6,""Lr16"",4) == 0))
VAR_8=GetPSDSize(VAR_3,VAR_1);
else
return(VAR_15);
}
}
VAR_9=VAR_15;
if (VAR_8 != 0)
{
VAR_7=(LayerInfo *) NULL;
VAR_13=(short) ReadBlobShort(VAR_1);
if (VAR_13 < 0)
{
VAR_13=MagickAbsoluteValue(VAR_13);
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""  negative layer count corrected for"");
VAR_1->matte=VAR_15;
}
if (VAR_4 != VAR_14)
return(VAR_15);
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""  image contains %.20g layers"",(double) VAR_13);
if (VAR_13 == 0)
ThrowBinaryException(VAR_17,""InvalidNumberOfLayers"",
VAR_1->filename);
VAR_7=(LayerInfo *) AcquireQuantumMemory((size_t) VAR_13,
sizeof(*VAR_7));
if (VAR_7 == (LayerInfo *) NULL)
{
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""  allocation of LayerInfo failed"");
ThrowBinaryException(VAR_18,""MemoryAllocationFailed"",
VAR_1->filename);
}
(void) ResetMagickMemory(VAR_7,0,(size_t) VAR_13*
sizeof(*VAR_7));
for (VAR_10=0; VAR_10 < VAR_13; VAR_10++)
{
ssize_t
VAR_19,
VAR_20;
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""  reading layer #%.20g"",(double) VAR_10+1);
VAR_7[VAR_10].page.y=ReadBlobSignedLong(VAR_1);
VAR_7[VAR_10].page.x=ReadBlobSignedLong(VAR_1);
VAR_20=ReadBlobSignedLong(VAR_1);
VAR_19=ReadBlobSignedLong(VAR_1);
VAR_7[VAR_10].page.width=(size_t) (VAR_19-VAR_7[VAR_10].page.x);
VAR_7[VAR_10].page.height=(size_t) (VAR_20-VAR_7[VAR_10].page.y);
VAR_7[VAR_10].channels=ReadBlobShort(VAR_1);
if (VAR_7[VAR_10].channels > VAR_21)
{
VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
ThrowBinaryException(VAR_17,""MaximumChannelsExceeded"",
VAR_1->filename);
}
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
(double) VAR_7[VAR_10].page.x,(double) VAR_7[VAR_10].page.y,
(double) VAR_7[VAR_10].page.height,(double)
VAR_7[VAR_10].page.width,(double) VAR_7[VAR_10].channels);
for (VAR_12=0; VAR_12 < (ssize_t) VAR_7[VAR_10].channels; VAR_12++)
{
VAR_7[VAR_10].channel_info[VAR_12].type=(short) ReadBlobShort(VAR_1);
VAR_7[VAR_10].channel_info[VAR_12].size=(size_t) GetPSDSize(VAR_3,
VAR_1);
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""    channel[%.20g]: type=%.20g, size=%.20g"",(double) VAR_12,
(double) VAR_7[VAR_10].channel_info[VAR_12].type,
(double) VAR_7[VAR_10].channel_info[VAR_12].size);
}
VAR_11=ReadBlob(VAR_1,4,(unsigned char *) VAR_6);
ReversePSDString(VAR_1,VAR_6,4);
if ((VAR_11 == 0) || (LocaleNCompare(VAR_6,""8BIM"",4) != 0))
{
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""  layer type was %.4s instead of 8BIM"", VAR_6);
VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
ThrowBinaryException(VAR_17,""ImproperImageHeader"",
VAR_1->filename);
}
(void) ReadBlob(VAR_1,4,(unsigned char *) VAR_7[VAR_10].blendkey);
ReversePSDString(VAR_1,VAR_7[VAR_10].blendkey,4);
VAR_7[VAR_10].opacity=(Quantum) ScaleCharToQuantum((unsigned char)
ReadBlobByte(VAR_1));
VAR_7[VAR_10].clipping=(unsigned char) ReadBlobByte(VAR_1);
VAR_7[VAR_10].flags=(unsigned char) ReadBlobByte(VAR_1);
VAR_7[VAR_10].visible=!(VAR_7[VAR_10].flags & 0x02);
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s"",
VAR_7[VAR_10].blendkey,(double) VAR_7[VAR_10].opacity,
VAR_7[VAR_10].clipping ? ""true"" : ""false"",VAR_7[VAR_10].flags,
VAR_7[VAR_10].visible ? ""true"" : ""false"");
(void) ReadBlobByte(VAR_1);  
VAR_8=ReadBlobLong(VAR_1);
if (VAR_8 != 0)
{
MagickSizeType
VAR_22,
VAR_23;
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""    layer contains additional info"");
VAR_23=ReadBlobLong(VAR_1);
VAR_22=VAR_23+4;
if (VAR_23 != 0)
{
VAR_7[VAR_10].mask.page.y=ReadBlobSignedLong(VAR_1);
VAR_7[VAR_10].mask.page.x=ReadBlobSignedLong(VAR_1);
VAR_7[VAR_10].mask.page.height=(size_t) (ReadBlobLong(VAR_1)-
VAR_7[VAR_10].mask.page.y);
VAR_7[VAR_10].mask.page.width=(size_t) (ReadBlobLong(VAR_1)-
VAR_7[VAR_10].mask.page.x);
VAR_7[VAR_10].mask.background=(unsigned char) ReadBlobByte(
VAR_1);
VAR_7[VAR_10].mask.flags=(unsigned char) ReadBlobByte(VAR_1);
if (!(VAR_7[VAR_10].mask.flags & 0x01))
{
VAR_7[VAR_10].mask.page.y=VAR_7[VAR_10].mask.page.y-
VAR_7[VAR_10].page.y;
VAR_7[VAR_10].mask.page.x=VAR_7[VAR_10].mask.page.x-
VAR_7[VAR_10].page.x;
}
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g"",
(double) VAR_7[VAR_10].mask.page.x,(double)
VAR_7[VAR_10].mask.page.y,(double) VAR_7[VAR_10].mask.page.width,
(double) VAR_7[VAR_10].mask.page.height,(double)
((MagickOffsetType) VAR_23)-18);
if (DiscardBlobBytes(VAR_1,(MagickSizeType) (VAR_23-18)) == VAR_14)
{
VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
ThrowBinaryException(VAR_17,""UnexpectedEndOfFile"",
VAR_1->filename);
}
}
VAR_23=ReadBlobLong(VAR_1);
VAR_22+=VAR_23+4;
if (VAR_23 != 0)
{
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""      layer blending ranges: length=%.20g"",(double)
((MagickOffsetType) VAR_23));
for (VAR_12=0; VAR_12 < (ssize_t) VAR_23; VAR_12+=8)
{
size_t VAR_24=ReadBlobLong(VAR_1);
size_t VAR_25=ReadBlobLong(VAR_1);
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""        source(%x), dest(%x)"",(unsigned int)
VAR_24,(unsigned int) VAR_25);
}
}
VAR_23=(MagickSizeType) ReadBlobByte(VAR_1);
VAR_22+=VAR_23+1;
if (VAR_23 > 0)
(void) ReadBlob(VAR_1,(size_t) VAR_23++,VAR_7[VAR_10].name);
VAR_7[VAR_10].name[VAR_23]='\0';
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""      layer name: %s"",VAR_7[VAR_10].name);
if ((VAR_23 % 4) != 0)
{
VAR_23=4-(VAR_23 % 4);
VAR_22+=VAR_23;
if (DiscardBlobBytes(VAR_1,VAR_23) == VAR_14)
{
VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
ThrowBinaryException(VAR_17,
""UnexpectedEndOfFile"",VAR_1->filename);
}
}
VAR_23=(MagickSizeType) VAR_8-VAR_22;
if (VAR_23 > 0)
{
unsigned char
*VAR_26;
VAR_7[VAR_10].info=AcquireStringInfo((const size_t) VAR_23);
VAR_26=GetStringInfoDatum(VAR_7[VAR_10].info);
(void) ReadBlob(VAR_1,(const size_t) VAR_23,VAR_26);
}
}
}
for (VAR_10=0; VAR_10 < VAR_13; VAR_10++)
{
if ((VAR_7[VAR_10].page.width == 0) ||
(VAR_7[VAR_10].page.height == 0))
{
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""      layer data is empty"");
continue;
}
VAR_7[VAR_10].image=CloneImage(VAR_1,VAR_7[VAR_10].page.width,
VAR_7[VAR_10].page.height,VAR_14,VAR_5);
if (VAR_7[VAR_10].image == (Image *) NULL)
{
VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""  allocation of image for layer %.20g failed"",(double) VAR_10);
ThrowBinaryException(VAR_18,""MemoryAllocationFailed"",
VAR_1->filename);
}
if (VAR_7[VAR_10].info != (StringInfo *) NULL)
{
(void) SetImageProfile(VAR_7[VAR_10].image,""psd:additional-info"",
VAR_7[VAR_10].info);
VAR_7[VAR_10].info=DestroyStringInfo(VAR_7[VAR_10].info);
}
}
if (VAR_2->ping == VAR_14)
{
for (VAR_10=0; VAR_10 < VAR_13; VAR_10++)
{
if (VAR_7[VAR_10].image == (Image *) NULL)
{
for (VAR_12=0; VAR_12 < VAR_7[VAR_10].channels; VAR_12++)
{
if (DiscardBlobBytes(VAR_1,(MagickSizeType)
VAR_7[VAR_10].channel_info[VAR_12].size) == VAR_14)
{
VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
ThrowBinaryException(VAR_17,
""UnexpectedEndOfFile"",VAR_1->filename);
}
}
continue;
}
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""  reading data for layer %.20g"",(double) VAR_10);
VAR_9=ReadPSDLayer(VAR_1,VAR_2,VAR_3,&VAR_7[VAR_10],
VAR_5);
if (VAR_9 == VAR_14)
break;
VAR_9=SetImageProgress(VAR_1,VAR_27,VAR_10,(MagickSizeType)
VAR_13);
if (VAR_9 == VAR_14)
break;
}
}
if (VAR_9 != VAR_14)
{
for (VAR_10=0; VAR_10 < VAR_13; VAR_10++)
{
if (VAR_7[VAR_10].image == (Image *) NULL)
{
for (VAR_12=VAR_10; VAR_12 < VAR_13 - 1; VAR_12++)
VAR_7[VAR_12] = VAR_7[VAR_12+1];
VAR_13--;
VAR_10--;
}
}
if (VAR_13 > 0)
{
for (VAR_10=0; VAR_10 < VAR_13; VAR_10++)
{
if (VAR_10 > 0)
VAR_7[VAR_10].image->previous=VAR_7[VAR_10-1].image;
if (VAR_10 < (VAR_13-1))
VAR_7[VAR_10].image->next=VAR_7[VAR_10+1].image;
VAR_7[VAR_10].image->page=VAR_7[VAR_10].page;
}
VAR_1->next=VAR_7[0].image;
VAR_7[0].image->previous=VAR_1;
}
VAR_7=(LayerInfo *) RelinquishMagickMemory(VAR_7);
}
else
VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
}
return(VAR_9);
}",,"ModuleExport MagickBooleanType ReadPSDLayers(Image *image,
  const ImageInfo *image_info,const PSDInfo *psd_info,
  const MagickBooleanType skip_layers,ExceptionInfo *exception)
{
  char
    type[4];

  LayerInfo
    *layer_info;

  MagickSizeType
    size;

  MagickBooleanType
    status;

  register ssize_t
    i;

  ssize_t
    count,
    j,
    number_layers;

  size=GetPSDSize(psd_info,image);
  if (size == 0)
    {
      /*
        Skip layers & masks.
      */
      (void) ReadBlobLong(image);
      count=ReadBlob(image,4,(unsigned char *) type);
      ReversePSDString(image,type,4);
      status=MagickFalse;
      if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
        return(MagickTrue);
      else
        {
          count=ReadBlob(image,4,(unsigned char *) type);
          ReversePSDString(image,type,4);
          if ((count != 0) && (LocaleNCompare(type,""Lr16"",4) == 0))
            size=GetPSDSize(psd_info,image);
          else
            return(MagickTrue);
        }
    }
  status=MagickTrue;
  if (size != 0)
    {
      layer_info=(LayerInfo *) NULL;
      number_layers=(short) ReadBlobShort(image);

      if (number_layers < 0)
        {
          /*
            The first alpha channel in the merged result contains the
            transparency data for the merged result.
          */
          number_layers=MagickAbsoluteValue(number_layers);
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  negative layer count corrected for"");
          image->matte=MagickTrue;
        }

      /*
        We only need to know if the image has an alpha channel
      */
      if (skip_layers != MagickFalse)
        return(MagickTrue);

      if (image->debug != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  image contains %.20g layers"",(double) number_layers);

      if (number_layers == 0)
        ThrowBinaryException(CorruptImageError,""InvalidNumberOfLayers"",
          image->filename);

      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,
        sizeof(*layer_info));
      if (layer_info == (LayerInfo *) NULL)
        {
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  allocation of LayerInfo failed"");
          ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
            image->filename);
        }
      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*
        sizeof(*layer_info));

      for (i=0; i < number_layers; i++)
      {
        ssize_t
          x,
          y;

        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  reading layer #%.20g"",(double) i+1);
        layer_info[i].page.y=ReadBlobSignedLong(image);
        layer_info[i].page.x=ReadBlobSignedLong(image);
        y=ReadBlobSignedLong(image);
        x=ReadBlobSignedLong(image);
        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);
        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);
        layer_info[i].channels=ReadBlobShort(image);
        if (layer_info[i].channels > MaxPSDChannels)
          {
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            ThrowBinaryException(CorruptImageError,""MaximumChannelsExceeded"",
              image->filename);
          }
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
            (double) layer_info[i].page.x,(double) layer_info[i].page.y,
            (double) layer_info[i].page.height,(double)
            layer_info[i].page.width,(double) layer_info[i].channels);
        for (j=0; j < (ssize_t) layer_info[i].channels; j++)
        {
          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);
          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,
            image);
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    channel[%.20g]: type=%.20g, size=%.20g"",(double) j,
              (double) layer_info[i].channel_info[j].type,
              (double) layer_info[i].channel_info[j].size);
        }
        count=ReadBlob(image,4,(unsigned char *) type);
        ReversePSDString(image,type,4);
        if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
          {
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  layer type was %.4s instead of 8BIM"", type);
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            ThrowBinaryException(CorruptImageError,""ImproperImageHeader"",
              image->filename);
          }
        (void) ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);
        ReversePSDString(image,layer_info[i].blendkey,4);
        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)
          ReadBlobByte(image));
        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);
        layer_info[i].flags=(unsigned char) ReadBlobByte(image);
        layer_info[i].visible=!(layer_info[i].flags & 0x02);
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s"",
            layer_info[i].blendkey,(double) layer_info[i].opacity,
            layer_info[i].clipping ? ""true"" : ""false"",layer_info[i].flags,
            layer_info[i].visible ? ""true"" : ""false"");
        (void) ReadBlobByte(image);  /* filler */

        size=ReadBlobLong(image);
        if (size != 0)
          {
            MagickSizeType
              combined_length,
              length;

            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""    layer contains additional info"");
            length=ReadBlobLong(image);
            combined_length=length+4;
            if (length != 0)
              {
                /*
                  Layer mask info.
                */
                layer_info[i].mask.page.y=ReadBlobSignedLong(image);
                layer_info[i].mask.page.x=ReadBlobSignedLong(image);
                layer_info[i].mask.page.height=(size_t) (ReadBlobLong(image)-
                  layer_info[i].mask.page.y);
                layer_info[i].mask.page.width=(size_t) (ReadBlobLong(image)-
                  layer_info[i].mask.page.x);
                layer_info[i].mask.background=(unsigned char) ReadBlobByte(
                  image);
                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);
                if (!(layer_info[i].mask.flags & 0x01))
                  {
                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-
                      layer_info[i].page.y;
                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-
                      layer_info[i].page.x;
                  }
                if (image->debug != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g"",
                    (double) layer_info[i].mask.page.x,(double)
                    layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,
                    (double) layer_info[i].mask.page.height,(double)
                    ((MagickOffsetType) length)-18);
                /*
                  Skip over the rest of the layer mask information.
                */
                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)
                  {
                    layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,""UnexpectedEndOfFile"",
                      image->filename);
                  }
              }
            length=ReadBlobLong(image);
            combined_length+=length+4;
            if (length != 0)
              {
                /*
                  Layer blending ranges info.
                */
                if (image->debug != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      layer blending ranges: length=%.20g"",(double)
                    ((MagickOffsetType) length));
                /*
                  We read it, but don't use it...
                */
                for (j=0; j < (ssize_t) length; j+=8)
                {
                  size_t blend_source=ReadBlobLong(image);
                  size_t blend_dest=ReadBlobLong(image);
                  if (image->debug != MagickFalse)
                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                      ""        source(%x), dest(%x)"",(unsigned int)
                      blend_source,(unsigned int) blend_dest);
                }
              }
            /*
              Layer name.
            */
            length=(MagickSizeType) ReadBlobByte(image);
            combined_length+=length+1;
            if (length > 0)
              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);
            layer_info[i].name[length]='\0';
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""      layer name: %s"",layer_info[i].name);
            if ((length % 4) != 0)
              {
                length=4-(length % 4);
                combined_length+=length;
                /* Skip over the padding of the layer name */
                if (DiscardBlobBytes(image,length) == MagickFalse)
                  {
                    layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,
                      ""UnexpectedEndOfFile"",image->filename);
                  }
              }
            length=(MagickSizeType) size-combined_length;
            if (length > 0)
              {
                unsigned char
                  *info;

                layer_info[i].info=AcquireStringInfo((const size_t) length);
                info=GetStringInfoDatum(layer_info[i].info);
                (void) ReadBlob(image,(const size_t) length,info);
              }
          }
      }

      for (i=0; i < number_layers; i++)
      {
        if ((layer_info[i].page.width == 0) ||
              (layer_info[i].page.height == 0))
          {
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""      layer data is empty"");
            if (layer_info[i].info != (StringInfo *) NULL)
              layer_info[i].info=DestroyStringInfo(layer_info[i].info);
            continue;
          }

        /*
          Allocate layered image.
        */
        layer_info[i].image=CloneImage(image,layer_info[i].page.width,
          layer_info[i].page.height,MagickFalse,exception);
        if (layer_info[i].image == (Image *) NULL)
          {
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  allocation of image for layer %.20g failed"",(double) i);
            ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
              image->filename);
          }

        if (layer_info[i].info != (StringInfo *) NULL)
          {
            (void) SetImageProfile(layer_info[i].image,""psd:additional-info"",
              layer_info[i].info);
            layer_info[i].info=DestroyStringInfo(layer_info[i].info);
          }
      }

      if (image_info->ping == MagickFalse)
        {
          for (i=0; i < number_layers; i++)
          {
            if (layer_info[i].image == (Image *) NULL)
              {
                for (j=0; j < layer_info[i].channels; j++)
                {
                  if (DiscardBlobBytes(image,(MagickSizeType)
                      layer_info[i].channel_info[j].size) == MagickFalse)
                    {
                      layer_info=DestroyLayerInfo(layer_info,number_layers);
                      ThrowBinaryException(CorruptImageError,
                        ""UnexpectedEndOfFile"",image->filename);
                    }
                }
                continue;
              }

            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  reading data for layer %.20g"",(double) i);
            status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],
              exception);
            if (status == MagickFalse)
              break;

            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)
              number_layers);
            if (status == MagickFalse)
              break;
          }
        }

      if (status != MagickFalse)
        {
          for (i=0; i < number_layers; i++)
          {
            if (layer_info[i].image == (Image *) NULL)
              {
                for (j=i; j < number_layers - 1; j++)
                  layer_info[j] = layer_info[j+1];
                number_layers--;
                i--;
              }
          }

          if (number_layers > 0)
            {
              for (i=0; i < number_layers; i++)
              {
                if (i > 0)
                  layer_info[i].image->previous=layer_info[i-1].image;
                if (i < (number_layers-1))
                  layer_info[i].image->next=layer_info[i+1].image;
                layer_info[i].image->page=layer_info[i].page;
              }
              image->next=layer_info[0].image;
              layer_info[0].image->previous=image;
            }
          layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);
        }
      else
        layer_info=DestroyLayerInfo(layer_info,number_layers);
    }

  return(status);
}","ModuleExport VAR_0 ReadPSDLayers(Image *VAR_1,
  const ImageInfo *VAR_2,const PSDInfo *VAR_3,
  const MagickBooleanType VAR_4,ExceptionInfo *VAR_5)
{
  char
    VAR_6[4];

  LayerInfo
    *VAR_7;

  MagickSizeType
    VAR_8;

  MagickBooleanType
    VAR_9;

  register ssize_t
    VAR_10;

  ssize_t
    VAR_11,
    VAR_12,
    VAR_13;

  VAR_8=GetPSDSize(VAR_3,VAR_1);
  if (VAR_8 == 0)
    {
      /* COMMENT_0 */
                            
        
      (void) ReadBlobLong(VAR_1);
      VAR_11=ReadBlob(VAR_1,4,(unsigned char *) VAR_6);
      ReversePSDString(VAR_1,VAR_6,4);
      VAR_9=VAR_14;
      if ((VAR_11 == 0) || (LocaleNCompare(VAR_6,""8BIM"",4) != 0))
        return(VAR_15);
      else
        {
          VAR_11=ReadBlob(VAR_1,4,(unsigned char *) VAR_6);
          ReversePSDString(VAR_1,VAR_6,4);
          if ((VAR_11 != 0) && (LocaleNCompare(VAR_6,""Lr16"",4) == 0))
            VAR_8=GetPSDSize(VAR_3,VAR_1);
          else
            return(VAR_15);
        }
    }
  VAR_9=VAR_15;
  if (VAR_8 != 0)
    {
      VAR_7=(LayerInfo *) NULL;
      VAR_13=(short) ReadBlobShort(VAR_1);

      if (VAR_13 < 0)
        {
          /* COMMENT_3 */
                                                                     
                                                    
            
          VAR_13=MagickAbsoluteValue(VAR_13);
          if (VAR_1->debug != VAR_14)
            (void) LogMagickEvent(VAR_16,GetMagickModule(),
              ""  negative layer count corrected for"");
          VAR_1->matte=VAR_15;
        }

      /* COMMENT_7 */
                                                              
        
      if (VAR_4 != VAR_14)
        return(VAR_15);

      if (VAR_1->debug != VAR_14)
        (void) LogMagickEvent(VAR_16,GetMagickModule(),
          ""  image contains %.20g layers"",(double) VAR_13);

      if (VAR_13 == 0)
        ThrowBinaryException(VAR_17,""InvalidNumberOfLayers"",
          VAR_1->filename);

      VAR_7=(LayerInfo *) AcquireQuantumMemory((size_t) VAR_13,
        sizeof(*VAR_7));
      if (VAR_7 == (LayerInfo *) NULL)
        {
          if (VAR_1->debug != VAR_14)
            (void) LogMagickEvent(VAR_16,GetMagickModule(),
              ""  allocation of LayerInfo failed"");
          ThrowBinaryException(VAR_18,""MemoryAllocationFailed"",
            VAR_1->filename);
        }
      (void) ResetMagickMemory(VAR_7,0,(size_t) VAR_13*
        sizeof(*VAR_7));

      for (VAR_10=0; VAR_10 < VAR_13; VAR_10++)
      {
        ssize_t
          VAR_19,
          VAR_20;

        if (VAR_1->debug != VAR_14)
          (void) LogMagickEvent(VAR_16,GetMagickModule(),
            ""  reading layer #%.20g"",(double) VAR_10+1);
        VAR_7[VAR_10].page.y=ReadBlobSignedLong(VAR_1);
        VAR_7[VAR_10].page.x=ReadBlobSignedLong(VAR_1);
        VAR_20=ReadBlobSignedLong(VAR_1);
        VAR_19=ReadBlobSignedLong(VAR_1);
        VAR_7[VAR_10].page.width=(size_t) (VAR_19-VAR_7[VAR_10].page.x);
        VAR_7[VAR_10].page.height=(size_t) (VAR_20-VAR_7[VAR_10].page.y);
        VAR_7[VAR_10].channels=ReadBlobShort(VAR_1);
        if (VAR_7[VAR_10].channels > VAR_21)
          {
            VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
            ThrowBinaryException(VAR_17,""MaximumChannelsExceeded"",
              VAR_1->filename);
          }
        if (VAR_1->debug != VAR_14)
          (void) LogMagickEvent(VAR_16,GetMagickModule(),
            ""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
            (double) VAR_7[VAR_10].page.x,(double) VAR_7[VAR_10].page.y,
            (double) VAR_7[VAR_10].page.height,(double)
            VAR_7[VAR_10].page.width,(double) VAR_7[VAR_10].channels);
        for (VAR_12=0; VAR_12 < (ssize_t) VAR_7[VAR_10].channels; VAR_12++)
        {
          VAR_7[VAR_10].channel_info[VAR_12].type=(short) ReadBlobShort(VAR_1);
          VAR_7[VAR_10].channel_info[VAR_12].size=(size_t) GetPSDSize(VAR_3,
            VAR_1);
          if (VAR_1->debug != VAR_14)
            (void) LogMagickEvent(VAR_16,GetMagickModule(),
              ""    channel[%.20g]: type=%.20g, size=%.20g"",(double) VAR_12,
              (double) VAR_7[VAR_10].channel_info[VAR_12].type,
              (double) VAR_7[VAR_10].channel_info[VAR_12].size);
        }
        VAR_11=ReadBlob(VAR_1,4,(unsigned char *) VAR_6);
        ReversePSDString(VAR_1,VAR_6,4);
        if ((VAR_11 == 0) || (LocaleNCompare(VAR_6,""8BIM"",4) != 0))
          {
            if (VAR_1->debug != VAR_14)
              (void) LogMagickEvent(VAR_16,GetMagickModule(),
                ""  layer type was %.4s instead of 8BIM"", VAR_6);
            VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
            ThrowBinaryException(VAR_17,""ImproperImageHeader"",
              VAR_1->filename);
          }
        (void) ReadBlob(VAR_1,4,(unsigned char *) VAR_7[VAR_10].blendkey);
        ReversePSDString(VAR_1,VAR_7[VAR_10].blendkey,4);
        VAR_7[VAR_10].opacity=(Quantum) ScaleCharToQuantum((unsigned char)
          ReadBlobByte(VAR_1));
        VAR_7[VAR_10].clipping=(unsigned char) ReadBlobByte(VAR_1);
        VAR_7[VAR_10].flags=(unsigned char) ReadBlobByte(VAR_1);
        VAR_7[VAR_10].visible=!(VAR_7[VAR_10].flags & 0x02);
        if (VAR_1->debug != VAR_14)
          (void) LogMagickEvent(VAR_16,GetMagickModule(),
            ""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s"",
            VAR_7[VAR_10].blendkey,(double) VAR_7[VAR_10].opacity,
            VAR_7[VAR_10].clipping ? ""true"" : ""false"",VAR_7[VAR_10].flags,
            VAR_7[VAR_10].visible ? ""true"" : ""false"");
        (void) ReadBlobByte(VAR_1);  /* COMMENT_10 */

        VAR_8=ReadBlobLong(VAR_1);
        if (VAR_8 != 0)
          {
            MagickSizeType
              VAR_22,
              VAR_23;

            if (VAR_1->debug != VAR_14)
              (void) LogMagickEvent(VAR_16,GetMagickModule(),
                ""    layer contains additional info"");
            VAR_23=ReadBlobLong(VAR_1);
            VAR_22=VAR_23+4;
            if (VAR_23 != 0)
              {
                /* COMMENT_11 */
                                  
                  
                VAR_7[VAR_10].mask.page.y=ReadBlobSignedLong(VAR_1);
                VAR_7[VAR_10].mask.page.x=ReadBlobSignedLong(VAR_1);
                VAR_7[VAR_10].mask.page.height=(size_t) (ReadBlobLong(VAR_1)-
                  VAR_7[VAR_10].mask.page.y);
                VAR_7[VAR_10].mask.page.width=(size_t) (ReadBlobLong(VAR_1)-
                  VAR_7[VAR_10].mask.page.x);
                VAR_7[VAR_10].mask.background=(unsigned char) ReadBlobByte(
                  VAR_1);
                VAR_7[VAR_10].mask.flags=(unsigned char) ReadBlobByte(VAR_1);
                if (!(VAR_7[VAR_10].mask.flags & 0x01))
                  {
                    VAR_7[VAR_10].mask.page.y=VAR_7[VAR_10].mask.page.y-
                      VAR_7[VAR_10].page.y;
                    VAR_7[VAR_10].mask.page.x=VAR_7[VAR_10].mask.page.x-
                      VAR_7[VAR_10].page.x;
                  }
                if (VAR_1->debug != VAR_14)
                  (void) LogMagickEvent(VAR_16,GetMagickModule(),
                    ""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g"",
                    (double) VAR_7[VAR_10].mask.page.x,(double)
                    VAR_7[VAR_10].mask.page.y,(double) VAR_7[VAR_10].mask.page.width,
                    (double) VAR_7[VAR_10].mask.page.height,(double)
                    ((MagickOffsetType) VAR_23)-18);
                /* COMMENT_14 */
                                                                   
                  
                if (DiscardBlobBytes(VAR_1,(MagickSizeType) (VAR_23-18)) == VAR_14)
                  {
                    VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
                    ThrowBinaryException(VAR_17,""UnexpectedEndOfFile"",
                      VAR_1->filename);
                  }
              }
            VAR_23=ReadBlobLong(VAR_1);
            VAR_22+=VAR_23+4;
            if (VAR_23 != 0)
              {
                /* COMMENT_17 */
                                             
                  
                if (VAR_1->debug != VAR_14)
                  (void) LogMagickEvent(VAR_16,GetMagickModule(),
                    ""      layer blending ranges: length=%.20g"",(double)
                    ((MagickOffsetType) VAR_23));
                /* COMMENT_20 */
                                                 
                  
                for (VAR_12=0; VAR_12 < (ssize_t) VAR_23; VAR_12+=8)
                {
                  size_t VAR_24=ReadBlobLong(VAR_1);
                  size_t VAR_25=ReadBlobLong(VAR_1);
                  if (VAR_1->debug != VAR_14)
                    (void) LogMagickEvent(VAR_16,GetMagickModule(),
                      ""        source(%x), dest(%x)"",(unsigned int)
                      VAR_24,(unsigned int) VAR_25);
                }
              }
            /* COMMENT_23 */
                         
              
            VAR_23=(MagickSizeType) ReadBlobByte(VAR_1);
            VAR_22+=VAR_23+1;
            if (VAR_23 > 0)
              (void) ReadBlob(VAR_1,(size_t) VAR_23++,VAR_7[VAR_10].name);
            VAR_7[VAR_10].name[VAR_23]='\0';
            if (VAR_1->debug != VAR_14)
              (void) LogMagickEvent(VAR_16,GetMagickModule(),
                ""      layer name: %s"",VAR_7[VAR_10].name);
            if ((VAR_23 % 4) != 0)
              {
                VAR_23=4-(VAR_23 % 4);
                VAR_22+=VAR_23;
                /* COMMENT_26 */
                if (DiscardBlobBytes(VAR_1,VAR_23) == VAR_14)
                  {
                    VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
                    ThrowBinaryException(VAR_17,
                      ""UnexpectedEndOfFile"",VAR_1->filename);
                  }
              }
            VAR_23=(MagickSizeType) VAR_8-VAR_22;
            if (VAR_23 > 0)
              {
                unsigned char
                  *VAR_26;

                VAR_7[VAR_10].info=AcquireStringInfo((const size_t) VAR_23);
                VAR_26=GetStringInfoDatum(VAR_7[VAR_10].info);
                (void) ReadBlob(VAR_1,(const size_t) VAR_23,VAR_26);
              }
          }
      }

      for (VAR_10=0; VAR_10 < VAR_13; VAR_10++)
      {
        if ((VAR_7[VAR_10].page.width == 0) ||
              (VAR_7[VAR_10].page.height == 0))
          {
            if (VAR_1->debug != VAR_14)
              (void) LogMagickEvent(VAR_16,GetMagickModule(),
                ""      layer data is empty"");
            if (VAR_7[VAR_10].info != (StringInfo *) NULL)
              VAR_7[VAR_10].info=DestroyStringInfo(VAR_7[VAR_10].info);
            continue;
          }

        /* COMMENT_27 */
                                 
          
        VAR_7[VAR_10].image=CloneImage(VAR_1,VAR_7[VAR_10].page.width,
          VAR_7[VAR_10].page.height,VAR_14,VAR_5);
        if (VAR_7[VAR_10].image == (Image *) NULL)
          {
            VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
            if (VAR_1->debug != VAR_14)
              (void) LogMagickEvent(VAR_16,GetMagickModule(),
                ""  allocation of image for layer %.20g failed"",(double) VAR_10);
            ThrowBinaryException(VAR_18,""MemoryAllocationFailed"",
              VAR_1->filename);
          }

        if (VAR_7[VAR_10].info != (StringInfo *) NULL)
          {
            (void) SetImageProfile(VAR_7[VAR_10].image,""psd:additional-info"",
              VAR_7[VAR_10].info);
            VAR_7[VAR_10].info=DestroyStringInfo(VAR_7[VAR_10].info);
          }
      }

      if (VAR_2->ping == VAR_14)
        {
          for (VAR_10=0; VAR_10 < VAR_13; VAR_10++)
          {
            if (VAR_7[VAR_10].image == (Image *) NULL)
              {
                for (VAR_12=0; VAR_12 < VAR_7[VAR_10].channels; VAR_12++)
                {
                  if (DiscardBlobBytes(VAR_1,(MagickSizeType)
                      VAR_7[VAR_10].channel_info[VAR_12].size) == VAR_14)
                    {
                      VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
                      ThrowBinaryException(VAR_17,
                        ""UnexpectedEndOfFile"",VAR_1->filename);
                    }
                }
                continue;
              }

            if (VAR_1->debug != VAR_14)
              (void) LogMagickEvent(VAR_16,GetMagickModule(),
                ""  reading data for layer %.20g"",(double) VAR_10);
            VAR_9=ReadPSDLayer(VAR_1,VAR_2,VAR_3,&VAR_7[VAR_10],
              VAR_5);
            if (VAR_9 == VAR_14)
              break;

            VAR_9=SetImageProgress(VAR_1,VAR_27,VAR_10,(MagickSizeType)
              VAR_13);
            if (VAR_9 == VAR_14)
              break;
          }
        }

      if (VAR_9 != VAR_14)
        {
          for (VAR_10=0; VAR_10 < VAR_13; VAR_10++)
          {
            if (VAR_7[VAR_10].image == (Image *) NULL)
              {
                for (VAR_12=VAR_10; VAR_12 < VAR_13 - 1; VAR_12++)
                  VAR_7[VAR_12] = VAR_7[VAR_12+1];
                VAR_13--;
                VAR_10--;
              }
          }

          if (VAR_13 > 0)
            {
              for (VAR_10=0; VAR_10 < VAR_13; VAR_10++)
              {
                if (VAR_10 > 0)
                  VAR_7[VAR_10].image->previous=VAR_7[VAR_10-1].image;
                if (VAR_10 < (VAR_13-1))
                  VAR_7[VAR_10].image->next=VAR_7[VAR_10+1].image;
                VAR_7[VAR_10].image->page=VAR_7[VAR_10].page;
              }
              VAR_1->next=VAR_7[0].image;
              VAR_7[0].image->previous=VAR_1;
            }
          VAR_7=(LayerInfo *) RelinquishMagickMemory(VAR_7);
        }
      else
        VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
    }

  return(VAR_9);
}",,"--- func_before
+++ func_after
@@ -273,6 +273,8 @@
             if (image->debug != MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""      layer data is empty"");
+            if (layer_info[i].info != (StringInfo *) NULL)
+              layer_info[i].info=DestroyStringInfo(layer_info[i].info);
             continue;
           }
 ","{'deleted_lines': [], 'added_lines': ['            if (layer_info[i].info != (StringInfo *) NULL)', '              layer_info[i].info=DestroyStringInfo(layer_info[i].info);']}",True,Memory leak in the ReadPSDLayers function in coders/psd.c in ImageMagick before 6.9.6-3 allows remote attackers to cause a denial of service (memory consumption) via a crafted image file.,5.5,MEDIUM,1,test,2016-10-19T05:29:36Z,1
CVE-2016-8887,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,jasper-software/jasper,"Fixed a bug that resulted in the destruction of JP2 box data that had never
been constructed in the first place.",e24bdc716c3327b067c551bc6cfb97fd2370358d,https://github.com/jasper-software/jasper/commit/e24bdc716c3327b067c551bc6cfb97fd2370358d,src/libjasper/jp2/jp2_cod.c,jp2_box_get,"jp2_box_t *jp2_box_get(jas_stream_t *in)
{
jp2_box_t *box;
jp2_boxinfo_t *boxinfo;
jas_stream_t *tmpstream;
uint_fast32_t len;
uint_fast64_t extlen;
bool dataflag;
box = 0;
tmpstream = 0;
if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
goto error;
}
box->ops = &jp2_boxinfo_unk.ops;
if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
goto error;
}
boxinfo = jp2_boxinfolookup(box->type);
box->info = boxinfo;
box->ops = &boxinfo->ops;
box->len = len;
if (box->len == 1) {
if (jp2_getuint64(in, &extlen)) {
goto error;
}
if (extlen > 0xffffffffUL) {
jas_eprintf(""warning: cannot handle large 64-bit box length\n"");
extlen = 0xffffffffUL;
}
box->len = extlen;
box->datalen = extlen - JP2_BOX_HDRLEN(true);
} else {
box->datalen = box->len - JP2_BOX_HDRLEN(false);
}
if (box->len != 0 && box->len < 8) {
goto error;
}
dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));
if (dataflag) {
if (!(tmpstream = jas_stream_memopen(0, 0))) {
goto error;
}
if (jas_stream_copy(tmpstream, in, box->datalen)) {
jas_eprintf(""cannot copy box data\n"");
goto error;
}
jas_stream_rewind(tmpstream);
if (box->ops->getdata) {
if ((*box->ops->getdata)(box, tmpstream)) {
jas_eprintf(""cannot parse box data\n"");
goto error;
}
}
jas_stream_close(tmpstream);
}
if (jas_getdbglevel() >= 1) {
jp2_box_dump(box, stderr);
}
return box;
error:
if (box) {
jp2_box_destroy(box);
}
if (tmpstream) {
jas_stream_close(tmpstream);
}
return 0;
}","jp2_box_t *jp2_box_get(jas_stream_t *VAR_0)
{
jp2_box_t *VAR_1;
jp2_boxinfo_t *VAR_2;
jas_stream_t *VAR_3;
uint_fast32_t VAR_4;
uint_fast64_t VAR_5;
bool VAR_6;
VAR_1 = 0;
VAR_3 = 0;
if (!(VAR_1 = jas_malloc(sizeof(jp2_box_t)))) {
goto error;
}
VAR_1->ops = &VAR_7.ops;
if (jp2_getuint32(VAR_0, &VAR_4) || jp2_getuint32(VAR_0, &VAR_1->type)) {
goto error;
}
VAR_2 = jp2_boxinfolookup(VAR_1->type);
VAR_1->info = VAR_2;
VAR_1->ops = &VAR_2->ops;
VAR_1->len = VAR_4;
if (VAR_1->len == 1) {
if (jp2_getuint64(VAR_0, &VAR_5)) {
goto error;
}
if (VAR_5 > 0xffffffffUL) {
jas_eprintf(""warning: cannot handle large 64-bit box length\n"");
VAR_5 = 0xffffffffUL;
}
VAR_1->len = VAR_5;
VAR_1->datalen = VAR_5 - JP2_BOX_HDRLEN(true);
} else {
VAR_1->datalen = VAR_1->len - JP2_BOX_HDRLEN(false);
}
if (VAR_1->len != 0 && VAR_1->len < 8) {
goto error;
}
VAR_6 = !(VAR_1->info->flags & (VAR_8 | VAR_9));
if (VAR_6) {
if (!(VAR_3 = jas_stream_memopen(0, 0))) {
goto error;
}
if (jas_stream_copy(VAR_3, VAR_0, VAR_1->datalen)) {
jas_eprintf(""cannot copy box data\n"");
goto error;
}
jas_stream_rewind(VAR_3);
if (VAR_1->ops->getdata) {
if ((*VAR_1->ops->getdata)(VAR_1, VAR_3)) {
jas_eprintf(""cannot parse box data\n"");
goto error;
}
}
jas_stream_close(VAR_3);
}
if (jas_getdbglevel() >= 1) {
jp2_box_dump(VAR_1, VAR_10);
}
return VAR_1;
error:
if (VAR_1) {
jp2_box_destroy(VAR_1);
}
if (VAR_3) {
jas_stream_close(VAR_3);
}
return 0;
}",jasper-software/jasper/e24bdc716c3327b067c551bc6cfb97fd2370358d/jp2_cod.c/vul/before/0.json,"jp2_box_t *jp2_box_get(jas_stream_t *in)
{
	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;
	jas_stream_t *tmpstream;
	uint_fast32_t len;
	uint_fast64_t extlen;
	bool dataflag;

	box = 0;
	tmpstream = 0;

	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
		goto error;
	}
	box->ops = &jp2_boxinfo_unk.ops;
	if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
		goto error;
	}
	boxinfo = jp2_boxinfolookup(box->type);
	box->info = boxinfo;
	box->ops = &boxinfo->ops;
	box->len = len;
	JAS_DBGLOG(10, (
	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
	  '""', boxinfo->name, '""', box->type, box->len
	  ));
	if (box->len == 1) {
		if (jp2_getuint64(in, &extlen)) {
			goto error;
		}
		if (extlen > 0xffffffffUL) {
			jas_eprintf(""warning: cannot handle large 64-bit box length\n"");
			extlen = 0xffffffffUL;
		}
		box->len = extlen;
		box->datalen = extlen - JP2_BOX_HDRLEN(true);
	} else {
		box->datalen = box->len - JP2_BOX_HDRLEN(false);
	}
	if (box->len != 0 && box->len < 8) {
		goto error;
	}

	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));

	if (dataflag) {
		if (!(tmpstream = jas_stream_memopen(0, 0))) {
			goto error;
		}
		if (jas_stream_copy(tmpstream, in, box->datalen)) {
			// Mark the box data as never having been constructed
			// so that we will not errantly attempt to destroy it later.
			box->ops = &jp2_boxinfo_unk.ops;
			jas_eprintf(""cannot copy box data\n"");
			goto error;
		}
		jas_stream_rewind(tmpstream);

		if (box->ops->getdata) {
			if ((*box->ops->getdata)(box, tmpstream)) {
				jas_eprintf(""cannot parse box data\n"");
				goto error;
			}
		}
		jas_stream_close(tmpstream);
	}

	if (jas_getdbglevel() >= 1) {
		jp2_box_dump(box, stderr);
	}

	return box;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (tmpstream) {
		jas_stream_close(tmpstream);
	}
	return 0;
}","jp2_box_t *jp2_box_get(jas_stream_t *VAR_0)
{
	jp2_box_t *VAR_1;
	jp2_boxinfo_t *VAR_2;
	jas_stream_t *VAR_3;
	uint_fast32_t VAR_4;
	uint_fast64_t VAR_5;
	bool VAR_6;

	VAR_1 = 0;
	VAR_3 = 0;

	if (!(VAR_1 = jas_malloc(sizeof(jp2_box_t)))) {
		goto error;
	}
	VAR_1->ops = &VAR_7.ops;
	if (jp2_getuint32(VAR_0, &VAR_4) || jp2_getuint32(VAR_0, &VAR_1->type)) {
		goto error;
	}
	VAR_2 = jp2_boxinfolookup(VAR_1->type);
	VAR_1->info = VAR_2;
	VAR_1->ops = &VAR_2->ops;
	VAR_1->len = VAR_4;
	JAS_DBGLOG(10, (
	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
	  '""', VAR_2->name, '""', VAR_1->type, VAR_1->len
	  ));
	if (VAR_1->len == 1) {
		if (jp2_getuint64(VAR_0, &VAR_5)) {
			goto error;
		}
		if (VAR_5 > 0xffffffffUL) {
			jas_eprintf(""warning: cannot handle large 64-bit box length\n"");
			VAR_5 = 0xffffffffUL;
		}
		VAR_1->len = VAR_5;
		VAR_1->datalen = VAR_5 - JP2_BOX_HDRLEN(true);
	} else {
		VAR_1->datalen = VAR_1->len - JP2_BOX_HDRLEN(false);
	}
	if (VAR_1->len != 0 && VAR_1->len < 8) {
		goto error;
	}

	VAR_6 = !(VAR_1->info->flags & (VAR_8 | VAR_9));

	if (VAR_6) {
		if (!(VAR_3 = jas_stream_memopen(0, 0))) {
			goto error;
		}
		if (jas_stream_copy(VAR_3, VAR_0, VAR_1->datalen)) {
			/* COMMENT_0 */
			/* COMMENT_1 */
			VAR_1->ops = &VAR_7.ops;
			jas_eprintf(""cannot copy box data\n"");
			goto error;
		}
		jas_stream_rewind(VAR_3);

		if (VAR_1->ops->getdata) {
			if ((*VAR_1->ops->getdata)(VAR_1, VAR_3)) {
				jas_eprintf(""cannot parse box data\n"");
				goto error;
			}
		}
		jas_stream_close(VAR_3);
	}

	if (jas_getdbglevel() >= 1) {
		jp2_box_dump(VAR_1, VAR_10);
	}

	return VAR_1;

error:
	if (VAR_1) {
		jp2_box_destroy(VAR_1);
	}
	if (VAR_3) {
		jas_stream_close(VAR_3);
	}
	return 0;
}",jasper-software/jasper/e24bdc716c3327b067c551bc6cfb97fd2370358d/jp2_cod.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,6 +21,10 @@
 	box->info = boxinfo;
 	box->ops = &boxinfo->ops;
 	box->len = len;
+	JAS_DBGLOG(10, (
+	  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
+	  '""', boxinfo->name, '""', box->type, box->len
+	  ));
 	if (box->len == 1) {
 		if (jp2_getuint64(in, &extlen)) {
 			goto error;
@@ -45,6 +49,9 @@
 			goto error;
 		}
 		if (jas_stream_copy(tmpstream, in, box->datalen)) {
+			// Mark the box data as never having been constructed
+			// so that we will not errantly attempt to destroy it later.
+			box->ops = &jp2_boxinfo_unk.ops;
 			jas_eprintf(""cannot copy box data\n"");
 			goto error;
 		}","{'deleted_lines': [], 'added_lines': ['\tJAS_DBGLOG(10, (', '\t  ""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n"",', '\t  \'""\', boxinfo->name, \'""\', box->type, box->len', '\t  ));', '\t\t\t// Mark the box data as never having been constructed', '\t\t\t// so that we will not errantly attempt to destroy it later.', '\t\t\tbox->ops = &jp2_boxinfo_unk.ops;']}",True,The jp2_colr_destroy function in libjasper/jp2/jp2_cod.c in JasPer before 1.900.10 allows remote attackers to cause a denial of service (NULL pointer dereference).,5.5,MEDIUM,1,test,2016-10-21T07:00:27Z,1
CVE-2016-8887,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,jasper-software/jasper,"Fixed a bug that resulted in the destruction of JP2 box data that had never
been constructed in the first place.",e24bdc716c3327b067c551bc6cfb97fd2370358d,https://github.com/jasper-software/jasper/commit/e24bdc716c3327b067c551bc6cfb97fd2370358d,src/libjasper/jp2/jp2_dec.c,jp2_decode,"jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)
{
jp2_box_t *box;
int found;
jas_image_t *image;
jp2_dec_t *dec;
bool samedtype;
int dtype;
unsigned int i;
jp2_cmap_t *cmapd;
jp2_pclr_t *pclrd;
jp2_cdef_t *cdefd;
unsigned int channo;
int newcmptno;
int_fast32_t *lutents;
#if 0
jp2_cdefchan_t *cdefent;
int cmptno;
#endif
jp2_cmapent_t *cmapent;
jas_icchdr_t icchdr;
jas_iccprof_t *iccprof;
dec = 0;
box = 0;
image = 0;
if (!(dec = jp2_dec_create())) {
goto error;
}
if (!(box = jp2_box_get(in))) {
jas_eprintf(""error: cannot get box\n"");
goto error;
}
if (box->type != JP2_BOX_JP) {
jas_eprintf(""error: expecting signature box\n"");
goto error;
}
if (box->data.jp.magic != JP2_JP_MAGIC) {
jas_eprintf(""incorrect magic number\n"");
goto error;
}
jp2_box_destroy(box);
box = 0;
if (!(box = jp2_box_get(in))) {
goto error;
}
if (box->type != JP2_BOX_FTYP) {
jas_eprintf(""expecting file type box\n"");
goto error;
}
jp2_box_destroy(box);
box = 0;
found = 0;
while ((box = jp2_box_get(in))) {
if (jas_getdbglevel() >= 1) {
jas_eprintf(""box type %s\n"", box->info->name);
}
switch (box->type) {
case JP2_BOX_JP2C:
found = 1;
break;
case JP2_BOX_IHDR:
if (!dec->ihdr) {
dec->ihdr = box;
box = 0;
}
break;
case JP2_BOX_BPCC:
if (!dec->bpcc) {
dec->bpcc = box;
box = 0;
}
break;
case JP2_BOX_CDEF:
if (!dec->cdef) {
dec->cdef = box;
box = 0;
}
break;
case JP2_BOX_PCLR:
if (!dec->pclr) {
dec->pclr = box;
box = 0;
}
break;
case JP2_BOX_CMAP:
if (!dec->cmap) {
dec->cmap = box;
box = 0;
}
break;
case JP2_BOX_COLR:
if (!dec->colr) {
dec->colr = box;
box = 0;
}
break;
}
if (box) {
jp2_box_destroy(box);
box = 0;
}
if (found) {
break;
}
}
if (!found) {
jas_eprintf(""error: no code stream found\n"");
goto error;
}
if (!(dec->image = jpc_decode(in, optstr))) {
jas_eprintf(""error: cannot decode code stream\n"");
goto error;
}
if (!dec->ihdr) {
jas_eprintf(""error: missing IHDR box\n"");
goto error;
}
if (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(uint,
jas_image_numcmpts(dec->image))) {
jas_eprintf(""warning: number of components mismatch\n"");
}
if (!jas_image_numcmpts(dec->image)) {
jas_eprintf(""error: no components\n"");
goto error;
}
samedtype = true;
dtype = jas_image_cmptdtype(dec->image, 0);
for (i = 1; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {
if (jas_image_cmptdtype(dec->image, i) != dtype) {
samedtype = false;
break;
}
}
if ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||
(!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {
jas_eprintf(""warning: component data type mismatch\n"");
}
if (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {
jas_eprintf(""error: unsupported compression type\n"");
goto error;
}
if (dec->bpcc) {
if (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(uint, jas_image_numcmpts(
dec->image))) {
jas_eprintf(""warning: number of components mismatch\n"");
}
if (!samedtype) {
for (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image));
++i) {
if (jas_image_cmptdtype(dec->image, i) !=
JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {
jas_eprintf(""warning: component data type mismatch\n"");
}
}
} else {
jas_eprintf(""warning: superfluous BPCC box\n"");
}
}
if (!dec->colr) {
jas_eprintf(""error: no COLR box\n"");
goto error;
}
switch (dec->colr->data.colr.method) {
case JP2_COLR_ENUM:
jas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));
break;
case JP2_COLR_ICC:
iccprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,
dec->colr->data.colr.iccplen);
if (!iccprof) {
jas_eprintf(""error: failed to parse ICC profile\n"");
goto error;
}
jas_iccprof_gethdr(iccprof, &icchdr);
jas_eprintf(""ICC Profile CS %08x\n"", icchdr.colorspc);
jas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));
dec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);
assert(dec->image->cmprof_);
jas_iccprof_destroy(iccprof);
break;
}
if (dec->cmap && !dec->pclr) {
jas_eprintf(""warning: missing PCLR box or superfluous CMAP box\n"");
jp2_box_destroy(dec->cmap);
dec->cmap = 0;
}
if (!dec->cmap && dec->pclr) {
jas_eprintf(""warning: missing CMAP box or superfluous PCLR box\n"");
jp2_box_destroy(dec->pclr);
dec->pclr = 0;
}
dec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :
JAS_CAST(uint, jas_image_numcmpts(dec->image));
if (dec->cmap) {
for (i = 0; i < dec->numchans; ++i) {
if (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(uint,
jas_image_numcmpts(dec->image))) {
jas_eprintf(""error: invalid component number in CMAP box\n"");
goto error;
}
if (dec->cmap->data.cmap.ents[i].pcol >=
dec->pclr->data.pclr.numchans) {
jas_eprintf(""error: invalid CMAP LUT index\n"");
goto error;
}
}
}
if (!(dec->chantocmptlut = jas_alloc2(dec->numchans,
sizeof(uint_fast16_t)))) {
jas_eprintf(""error: no memory\n"");
goto error;
}
if (!dec->cmap) {
for (i = 0; i < dec->numchans; ++i) {
dec->chantocmptlut[i] = i;
}
} else {
cmapd = &dec->cmap->data.cmap;
pclrd = &dec->pclr->data.pclr;
cdefd = &dec->cdef->data.cdef;
for (channo = 0; channo < cmapd->numchans; ++channo) {
cmapent = &cmapd->ents[channo];
if (cmapent->map == JP2_CMAP_DIRECT) {
dec->chantocmptlut[channo] = channo;
} else if (cmapent->map == JP2_CMAP_PALETTE) {
lutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));
for (i = 0; i < pclrd->numlutents; ++i) {
lutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];
}
newcmptno = jas_image_numcmpts(dec->image);
jas_image_depalettize(dec->image, cmapent->cmptno,
pclrd->numlutents, lutents,
JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);
dec->chantocmptlut[channo] = newcmptno;
jas_free(lutents);
#if 0
if (dec->cdef) {
cdefent = jp2_cdef_lookup(cdefd, channo);
if (!cdefent) {
abort();
}
jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));
} else {
jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));
}
#endif
}
}
}
for (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {
jas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);
}
if (dec->cdef) {
for (i = 0; i < dec->numchans; ++i) {
if (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {
jas_eprintf(""error: invalid channel number in CDEF box\n"");
goto error;
}
jas_image_setcmpttype(dec->image,
dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],
jp2_getct(jas_image_clrspc(dec->image),
dec->cdef->data.cdef.ents[i].type,
dec->cdef->data.cdef.ents[i].assoc));
}
} else {
for (i = 0; i < dec->numchans; ++i) {
jas_image_setcmpttype(dec->image, dec->chantocmptlut[i],
jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));
}
}
for (i = jas_image_numcmpts(dec->image); i > 0; --i) {
if (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {
jas_image_delcmpt(dec->image, i - 1);
}
}
if (!jas_image_numcmpts(dec->image)) {
jas_eprintf(""error: no components\n"");
goto error;
}
#if 0
jas_eprintf(""no of components is %d\n"", jas_image_numcmpts(dec->image));
#endif
image = dec->image;
dec->image = 0;
jp2_dec_destroy(dec);
return image;
error:
if (box) {
jp2_box_destroy(box);
}
if (dec) {
jp2_dec_destroy(dec);
}
return 0;
}","jas_image_t *jp2_decode(jas_stream_t *VAR_0, char *VAR_1)
{
jp2_box_t *VAR_2;
int VAR_3;
jas_image_t *VAR_4;
jp2_dec_t *VAR_5;
bool VAR_6;
int VAR_7;
unsigned int VAR_8;
jp2_cmap_t *VAR_9;
jp2_pclr_t *VAR_10;
jp2_cdef_t *VAR_11;
unsigned int VAR_12;
int VAR_13;
int_fast32_t *VAR_14;
#if 0
jp2_cdefchan_t *VAR_15;
int VAR_16;
#endif
jp2_cmapent_t *VAR_17;
jas_icchdr_t VAR_18;
jas_iccprof_t *VAR_19;
VAR_5 = 0;
VAR_2 = 0;
VAR_4 = 0;
if (!(VAR_5 = jp2_dec_create())) {
goto error;
}
if (!(VAR_2 = jp2_box_get(VAR_0))) {
jas_eprintf(""error: cannot get box\n"");
goto error;
}
if (VAR_2->type != VAR_20) {
jas_eprintf(""error: expecting signature box\n"");
goto error;
}
if (VAR_2->data.jp.magic != VAR_21) {
jas_eprintf(""incorrect magic number\n"");
goto error;
}
jp2_box_destroy(VAR_2);
VAR_2 = 0;
if (!(VAR_2 = jp2_box_get(VAR_0))) {
goto error;
}
if (VAR_2->type != VAR_22) {
jas_eprintf(""expecting file type box\n"");
goto error;
}
jp2_box_destroy(VAR_2);
VAR_2 = 0;
VAR_3 = 0;
while ((VAR_2 = jp2_box_get(VAR_0))) {
if (jas_getdbglevel() >= 1) {
jas_eprintf(""box type %s\n"", VAR_2->info->name);
}
switch (VAR_2->type) {
case VAR_23:
VAR_3 = 1;
break;
case VAR_24:
if (!VAR_5->ihdr) {
VAR_5->ihdr = VAR_2;
VAR_2 = 0;
}
break;
case VAR_25:
if (!VAR_5->bpcc) {
VAR_5->bpcc = VAR_2;
VAR_2 = 0;
}
break;
case VAR_26:
if (!VAR_5->cdef) {
VAR_5->cdef = VAR_2;
VAR_2 = 0;
}
break;
case VAR_27:
if (!VAR_5->pclr) {
VAR_5->pclr = VAR_2;
VAR_2 = 0;
}
break;
case VAR_28:
if (!VAR_5->cmap) {
VAR_5->cmap = VAR_2;
VAR_2 = 0;
}
break;
case VAR_29:
if (!VAR_5->colr) {
VAR_5->colr = VAR_2;
VAR_2 = 0;
}
break;
}
if (VAR_2) {
jp2_box_destroy(VAR_2);
VAR_2 = 0;
}
if (VAR_3) {
break;
}
}
if (!VAR_3) {
jas_eprintf(""error: no code stream found\n"");
goto error;
}
if (!(VAR_5->image = jpc_decode(VAR_0, VAR_1))) {
jas_eprintf(""error: cannot decode code stream\n"");
goto error;
}
if (!VAR_5->ihdr) {
jas_eprintf(""error: missing IHDR box\n"");
goto error;
}
if (VAR_5->ihdr->data.ihdr.numcmpts != JAS_CAST(VAR_30,
jas_image_numcmpts(VAR_5->image))) {
jas_eprintf(""warning: number of components mismatch\n"");
}
if (!jas_image_numcmpts(VAR_5->image)) {
jas_eprintf(""error: no components\n"");
goto error;
}
VAR_6 = true;
VAR_7 = jas_image_cmptdtype(VAR_5->image, 0);
for (VAR_8 = 1; VAR_8 < JAS_CAST(VAR_30, jas_image_numcmpts(VAR_5->image)); ++VAR_8) {
if (jas_image_cmptdtype(VAR_5->image, VAR_8) != VAR_7) {
VAR_6 = false;
break;
}
}
if ((VAR_6 && VAR_5->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(VAR_7)) ||
(!VAR_6 && VAR_5->ihdr->data.ihdr.bpc != VAR_31)) {
jas_eprintf(""warning: component data type mismatch\n"");
}
if (VAR_5->ihdr->data.ihdr.comptype != VAR_32) {
jas_eprintf(""error: unsupported compression type\n"");
goto error;
}
if (VAR_5->bpcc) {
if (VAR_5->bpcc->data.bpcc.numcmpts != JAS_CAST(VAR_30, jas_image_numcmpts(
VAR_5->image))) {
jas_eprintf(""warning: number of components mismatch\n"");
}
if (!VAR_6) {
for (VAR_8 = 0; VAR_8 < JAS_CAST(VAR_30, jas_image_numcmpts(VAR_5->image));
++VAR_8) {
if (jas_image_cmptdtype(VAR_5->image, VAR_8) !=
JP2_BPCTODTYPE(VAR_5->bpcc->data.bpcc.bpcs[VAR_8])) {
jas_eprintf(""warning: component data type mismatch\n"");
}
}
} else {
jas_eprintf(""warning: superfluous BPCC box\n"");
}
}
if (!VAR_5->colr) {
jas_eprintf(""error: no COLR box\n"");
goto error;
}
switch (VAR_5->colr->data.colr.method) {
case VAR_33:
jas_image_setclrspc(VAR_5->image, jp2_getcs(&VAR_5->colr->data.colr));
break;
case VAR_34:
VAR_19 = jas_iccprof_createfrombuf(VAR_5->colr->data.colr.iccp,
VAR_5->colr->data.colr.iccplen);
if (!VAR_19) {
jas_eprintf(""error: failed to parse ICC profile\n"");
goto error;
}
jas_iccprof_gethdr(VAR_19, &VAR_18);
jas_eprintf(""ICC Profile CS %08x\n"", VAR_18.colorspc);
jas_image_setclrspc(VAR_5->image, fromiccpcs(VAR_18.colorspc));
VAR_5->image->cmprof_ = jas_cmprof_createfromiccprof(VAR_19);
assert(VAR_5->image->cmprof_);
jas_iccprof_destroy(VAR_19);
break;
}
if (VAR_5->cmap && !VAR_5->pclr) {
jas_eprintf(""warning: missing PCLR box or superfluous CMAP box\n"");
jp2_box_destroy(VAR_5->cmap);
VAR_5->cmap = 0;
}
if (!VAR_5->cmap && VAR_5->pclr) {
jas_eprintf(""warning: missing CMAP box or superfluous PCLR box\n"");
jp2_box_destroy(VAR_5->pclr);
VAR_5->pclr = 0;
}
VAR_5->numchans = VAR_5->cmap ? VAR_5->cmap->data.cmap.numchans :
JAS_CAST(VAR_30, jas_image_numcmpts(VAR_5->image));
if (VAR_5->cmap) {
for (VAR_8 = 0; VAR_8 < VAR_5->numchans; ++VAR_8) {
if (VAR_5->cmap->data.cmap.ents[VAR_8].cmptno >= JAS_CAST(VAR_30,
jas_image_numcmpts(VAR_5->image))) {
jas_eprintf(""error: invalid component number in CMAP box\n"");
goto error;
}
if (VAR_5->cmap->data.cmap.ents[VAR_8].pcol >=
VAR_5->pclr->data.pclr.numchans) {
jas_eprintf(""error: invalid CMAP LUT index\n"");
goto error;
}
}
}
if (!(VAR_5->chantocmptlut = jas_alloc2(VAR_5->numchans,
sizeof(VAR_35)))) {
jas_eprintf(""error: no memory\n"");
goto error;
}
if (!VAR_5->cmap) {
for (VAR_8 = 0; VAR_8 < VAR_5->numchans; ++VAR_8) {
VAR_5->chantocmptlut[VAR_8] = VAR_8;
}
} else {
VAR_9 = &VAR_5->cmap->data.cmap;
VAR_10 = &VAR_5->pclr->data.pclr;
VAR_11 = &VAR_5->cdef->data.cdef;
for (VAR_12 = 0; VAR_12 < VAR_9->numchans; ++VAR_12) {
VAR_17 = &VAR_9->ents[VAR_12];
if (VAR_17->map == VAR_36) {
VAR_5->chantocmptlut[VAR_12] = VAR_12;
} else if (VAR_17->map == VAR_37) {
VAR_14 = jas_alloc2(VAR_10->numlutents, sizeof(int_fast32_t));
for (VAR_8 = 0; VAR_8 < VAR_10->numlutents; ++VAR_8) {
VAR_14[VAR_8] = VAR_10->lutdata[VAR_17->pcol + VAR_8 * VAR_10->numchans];
}
VAR_13 = jas_image_numcmpts(VAR_5->image);
jas_image_depalettize(VAR_5->image, VAR_17->cmptno,
VAR_10->numlutents, VAR_14,
JP2_BPCTODTYPE(VAR_10->bpc[VAR_17->pcol]), VAR_13);
VAR_5->chantocmptlut[VAR_12] = VAR_13;
jas_free(VAR_14);
#if 0
if (VAR_5->cdef) {
VAR_15 = jp2_cdef_lookup(VAR_11, VAR_12);
if (!VAR_15) {
abort();
}
jas_image_setcmpttype(VAR_5->image, VAR_13, jp2_getct(jas_image_clrspc(VAR_5->image), VAR_15->type, VAR_15->assoc));
} else {
jas_image_setcmpttype(VAR_5->image, VAR_13, jp2_getct(jas_image_clrspc(VAR_5->image), 0, VAR_12 + 1));
}
#endif
}
}
}
for (VAR_8 = 0; VAR_8 < JAS_CAST(VAR_30, jas_image_numcmpts(VAR_5->image)); ++VAR_8) {
jas_image_setcmpttype(VAR_5->image, VAR_8, VAR_38);
}
if (VAR_5->cdef) {
for (VAR_8 = 0; VAR_8 < VAR_5->numchans; ++VAR_8) {
if (VAR_5->cdef->data.cdef.ents[VAR_8].channo >= VAR_5->numchans) {
jas_eprintf(""error: invalid channel number in CDEF box\n"");
goto error;
}
jas_image_setcmpttype(VAR_5->image,
VAR_5->chantocmptlut[VAR_5->cdef->data.cdef.ents[VAR_8].channo],
jp2_getct(jas_image_clrspc(VAR_5->image),
VAR_5->cdef->data.cdef.ents[VAR_8].type,
VAR_5->cdef->data.cdef.ents[VAR_8].assoc));
}
} else {
for (VAR_8 = 0; VAR_8 < VAR_5->numchans; ++VAR_8) {
jas_image_setcmpttype(VAR_5->image, VAR_5->chantocmptlut[VAR_8],
jp2_getct(jas_image_clrspc(VAR_5->image), 0, VAR_8 + 1));
}
}
for (VAR_8 = jas_image_numcmpts(VAR_5->image); VAR_8 > 0; --VAR_8) {
if (jas_image_cmpttype(VAR_5->image, VAR_8 - 1) == VAR_38) {
jas_image_delcmpt(VAR_5->image, VAR_8 - 1);
}
}
if (!jas_image_numcmpts(VAR_5->image)) {
jas_eprintf(""error: no components\n"");
goto error;
}
#if 0
jas_eprintf(""no of components is %d\n"", jas_image_numcmpts(VAR_5->image));
#endif
VAR_4 = VAR_5->image;
VAR_5->image = 0;
jp2_dec_destroy(VAR_5);
return VAR_4;
error:
if (VAR_2) {
jp2_box_destroy(VAR_2);
}
if (VAR_5) {
jp2_dec_destroy(VAR_5);
}
return 0;
}",jasper-software/jasper/e24bdc716c3327b067c551bc6cfb97fd2370358d/jp2_dec.c/vul/before/0.json,"jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)
{
	jp2_box_t *box;
	int found;
	jas_image_t *image;
	jp2_dec_t *dec;
	bool samedtype;
	int dtype;
	unsigned int i;
	jp2_cmap_t *cmapd;
	jp2_pclr_t *pclrd;
	jp2_cdef_t *cdefd;
	unsigned int channo;
	int newcmptno;
	int_fast32_t *lutents;
#if 0
	jp2_cdefchan_t *cdefent;
	int cmptno;
#endif
	jp2_cmapent_t *cmapent;
	jas_icchdr_t icchdr;
	jas_iccprof_t *iccprof;

	dec = 0;
	box = 0;
	image = 0;

	if (!(dec = jp2_dec_create())) {
		goto error;
	}

	/* Get the first box.  This should be a JP box. */
	if (!(box = jp2_box_get(in))) {
		jas_eprintf(""error: cannot get box\n"");
		goto error;
	}
	if (box->type != JP2_BOX_JP) {
		jas_eprintf(""error: expecting signature box\n"");
		goto error;
	}
	if (box->data.jp.magic != JP2_JP_MAGIC) {
		jas_eprintf(""incorrect magic number\n"");
		goto error;
	}
	jp2_box_destroy(box);
	box = 0;

	/* Get the second box.  This should be a FTYP box. */
	if (!(box = jp2_box_get(in))) {
		goto error;
	}
	if (box->type != JP2_BOX_FTYP) {
		jas_eprintf(""expecting file type box\n"");
		goto error;
	}
	jp2_box_destroy(box);
	box = 0;

	/* Get more boxes... */
	found = 0;
	while ((box = jp2_box_get(in))) {
		if (jas_getdbglevel() >= 1) {
			jas_eprintf(""got box type %s\n"", box->info->name);
		}
		switch (box->type) {
		case JP2_BOX_JP2C:
			found = 1;
			break;
		case JP2_BOX_IHDR:
			if (!dec->ihdr) {
				dec->ihdr = box;
				box = 0;
			}
			break;
		case JP2_BOX_BPCC:
			if (!dec->bpcc) {
				dec->bpcc = box;
				box = 0;
			}
			break;
		case JP2_BOX_CDEF:
			if (!dec->cdef) {
				dec->cdef = box;
				box = 0;
			}
			break;
		case JP2_BOX_PCLR:
			if (!dec->pclr) {
				dec->pclr = box;
				box = 0;
			}
			break;
		case JP2_BOX_CMAP:
			if (!dec->cmap) {
				dec->cmap = box;
				box = 0;
			}
			break;
		case JP2_BOX_COLR:
			if (!dec->colr) {
				dec->colr = box;
				box = 0;
			}
			break;
		}
		if (box) {
			jp2_box_destroy(box);
			box = 0;
		}
		if (found) {
			break;
		}
	}

	if (!found) {
		jas_eprintf(""error: no code stream found\n"");
		goto error;
	}

	if (!(dec->image = jpc_decode(in, optstr))) {
		jas_eprintf(""error: cannot decode code stream\n"");
		goto error;
	}

	/* An IHDR box must be present. */
	if (!dec->ihdr) {
		jas_eprintf(""error: missing IHDR box\n"");
		goto error;
	}

	/* Does the number of components indicated in the IHDR box match
	  the value specified in the code stream? */
	if (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(uint,
	  jas_image_numcmpts(dec->image))) {
		jas_eprintf(""warning: number of components mismatch\n"");
	}

	/* At least one component must be present. */
	if (!jas_image_numcmpts(dec->image)) {
		jas_eprintf(""error: no components\n"");
		goto error;
	}

	/* Determine if all components have the same data type. */
	samedtype = true;
	dtype = jas_image_cmptdtype(dec->image, 0);
	for (i = 1; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {
		if (jas_image_cmptdtype(dec->image, i) != dtype) {
			samedtype = false;
			break;
		}
	}

	/* Is the component data type indicated in the IHDR box consistent
	  with the data in the code stream? */
	if ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||
	  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {
		jas_eprintf(""warning: component data type mismatch\n"");
	}

	/* Is the compression type supported? */
	if (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {
		jas_eprintf(""error: unsupported compression type\n"");
		goto error;
	}

	if (dec->bpcc) {
		/* Is the number of components indicated in the BPCC box
		  consistent with the code stream data? */
		if (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(uint, jas_image_numcmpts(
		  dec->image))) {
			jas_eprintf(""warning: number of components mismatch\n"");
		}
		/* Is the component data type information indicated in the BPCC
		  box consistent with the code stream data? */
		if (!samedtype) {
			for (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image));
			  ++i) {
				if (jas_image_cmptdtype(dec->image, i) !=
				  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {
					jas_eprintf(""warning: component data type mismatch\n"");
				}
			}
		} else {
			jas_eprintf(""warning: superfluous BPCC box\n"");
		}
	}

	/* A COLR box must be present. */
	if (!dec->colr) {
		jas_eprintf(""error: no COLR box\n"");
		goto error;
	}

	switch (dec->colr->data.colr.method) {
	case JP2_COLR_ENUM:
		jas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));
		break;
	case JP2_COLR_ICC:
		iccprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,
		  dec->colr->data.colr.iccplen);
		if (!iccprof) {
			jas_eprintf(""error: failed to parse ICC profile\n"");
			goto error;
		}
		jas_iccprof_gethdr(iccprof, &icchdr);
		jas_eprintf(""ICC Profile CS %08x\n"", icchdr.colorspc);
		jas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));
		dec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);
		assert(dec->image->cmprof_);
		jas_iccprof_destroy(iccprof);
		break;
	}

	/* If a CMAP box is present, a PCLR box must also be present. */
	if (dec->cmap && !dec->pclr) {
		jas_eprintf(""warning: missing PCLR box or superfluous CMAP box\n"");
		jp2_box_destroy(dec->cmap);
		dec->cmap = 0;
	}

	/* If a CMAP box is not present, a PCLR box must not be present. */
	if (!dec->cmap && dec->pclr) {
		jas_eprintf(""warning: missing CMAP box or superfluous PCLR box\n"");
		jp2_box_destroy(dec->pclr);
		dec->pclr = 0;
	}

	/* Determine the number of channels (which is essentially the number
	  of components after any palette mappings have been applied). */
	dec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :
	  JAS_CAST(uint, jas_image_numcmpts(dec->image));

	/* Perform a basic sanity check on the CMAP box if present. */
	if (dec->cmap) {
		for (i = 0; i < dec->numchans; ++i) {
			/* Is the component number reasonable? */
			if (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(uint,
			  jas_image_numcmpts(dec->image))) {
				jas_eprintf(""error: invalid component number in CMAP box\n"");
				goto error;
			}
			/* Is the LUT index reasonable? */
			if (dec->cmap->data.cmap.ents[i].pcol >=
			  dec->pclr->data.pclr.numchans) {
				jas_eprintf(""error: invalid CMAP LUT index\n"");
				goto error;
			}
		}
	}

	/* Allocate space for the channel-number to component-number LUT. */
	if (!(dec->chantocmptlut = jas_alloc2(dec->numchans,
	  sizeof(uint_fast16_t)))) {
		jas_eprintf(""error: no memory\n"");
		goto error;
	}

	if (!dec->cmap) {
		for (i = 0; i < dec->numchans; ++i) {
			dec->chantocmptlut[i] = i;
		}
	} else {
		cmapd = &dec->cmap->data.cmap;
		pclrd = &dec->pclr->data.pclr;
		cdefd = &dec->cdef->data.cdef;
		for (channo = 0; channo < cmapd->numchans; ++channo) {
			cmapent = &cmapd->ents[channo];
			if (cmapent->map == JP2_CMAP_DIRECT) {
				dec->chantocmptlut[channo] = channo;
			} else if (cmapent->map == JP2_CMAP_PALETTE) {
				lutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));
				for (i = 0; i < pclrd->numlutents; ++i) {
					lutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];
				}
				newcmptno = jas_image_numcmpts(dec->image);
				jas_image_depalettize(dec->image, cmapent->cmptno,
				  pclrd->numlutents, lutents,
				  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);
				dec->chantocmptlut[channo] = newcmptno;
				jas_free(lutents);
#if 0
				if (dec->cdef) {
					cdefent = jp2_cdef_lookup(cdefd, channo);
					if (!cdefent) {
						abort();
					}
				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));
				} else {
				jas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));
				}
#endif
			}
		}
	}

	/* Mark all components as being of unknown type. */

	for (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {
		jas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);
	}

	/* Determine the type of each component. */
	if (dec->cdef) {
		for (i = 0; i < dec->numchans; ++i) {
			/* Is the channel number reasonable? */
			if (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {
				jas_eprintf(""error: invalid channel number in CDEF box\n"");
				goto error;
			}
			jas_image_setcmpttype(dec->image,
			  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],
			  jp2_getct(jas_image_clrspc(dec->image),
			  dec->cdef->data.cdef.ents[i].type,
			  dec->cdef->data.cdef.ents[i].assoc));
		}
	} else {
		for (i = 0; i < dec->numchans; ++i) {
			jas_image_setcmpttype(dec->image, dec->chantocmptlut[i],
			  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));
		}
	}

	/* Delete any components that are not of interest. */
	for (i = jas_image_numcmpts(dec->image); i > 0; --i) {
		if (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {
			jas_image_delcmpt(dec->image, i - 1);
		}
	}

	/* Ensure that some components survived. */
	if (!jas_image_numcmpts(dec->image)) {
		jas_eprintf(""error: no components\n"");
		goto error;
	}
#if 0
jas_eprintf(""no of components is %d\n"", jas_image_numcmpts(dec->image));
#endif

	/* Prevent the image from being destroyed later. */
	image = dec->image;
	dec->image = 0;

	jp2_dec_destroy(dec);

	return image;

error:
	if (box) {
		jp2_box_destroy(box);
	}
	if (dec) {
		jp2_dec_destroy(dec);
	}
	return 0;
}","jas_image_t *jp2_decode(jas_stream_t *VAR_0, char *VAR_1)
{
	jp2_box_t *VAR_2;
	int VAR_3;
	jas_image_t *VAR_4;
	jp2_dec_t *VAR_5;
	bool VAR_6;
	int VAR_7;
	unsigned int VAR_8;
	jp2_cmap_t *VAR_9;
	jp2_pclr_t *VAR_10;
	jp2_cdef_t *VAR_11;
	unsigned int VAR_12;
	int VAR_13;
	int_fast32_t *VAR_14;
#if 0
	jp2_cdefchan_t *VAR_15;
	int VAR_16;
#endif
	jp2_cmapent_t *VAR_17;
	jas_icchdr_t VAR_18;
	jas_iccprof_t *VAR_19;

	VAR_5 = 0;
	VAR_2 = 0;
	VAR_4 = 0;

	if (!(VAR_5 = jp2_dec_create())) {
		goto error;
	}

	/* COMMENT_0 */
	if (!(VAR_2 = jp2_box_get(VAR_0))) {
		jas_eprintf(""error: cannot get box\n"");
		goto error;
	}
	if (VAR_2->type != VAR_20) {
		jas_eprintf(""error: expecting signature box\n"");
		goto error;
	}
	if (VAR_2->data.jp.magic != VAR_21) {
		jas_eprintf(""incorrect magic number\n"");
		goto error;
	}
	jp2_box_destroy(VAR_2);
	VAR_2 = 0;

	/* COMMENT_1 */
	if (!(VAR_2 = jp2_box_get(VAR_0))) {
		goto error;
	}
	if (VAR_2->type != VAR_22) {
		jas_eprintf(""expecting file type box\n"");
		goto error;
	}
	jp2_box_destroy(VAR_2);
	VAR_2 = 0;

	/* COMMENT_2 */
	VAR_3 = 0;
	while ((VAR_2 = jp2_box_get(VAR_0))) {
		if (jas_getdbglevel() >= 1) {
			jas_eprintf(""got box type %s\n"", VAR_2->info->name);
		}
		switch (VAR_2->type) {
		case VAR_23:
			VAR_3 = 1;
			break;
		case VAR_24:
			if (!VAR_5->ihdr) {
				VAR_5->ihdr = VAR_2;
				VAR_2 = 0;
			}
			break;
		case VAR_25:
			if (!VAR_5->bpcc) {
				VAR_5->bpcc = VAR_2;
				VAR_2 = 0;
			}
			break;
		case VAR_26:
			if (!VAR_5->cdef) {
				VAR_5->cdef = VAR_2;
				VAR_2 = 0;
			}
			break;
		case VAR_27:
			if (!VAR_5->pclr) {
				VAR_5->pclr = VAR_2;
				VAR_2 = 0;
			}
			break;
		case VAR_28:
			if (!VAR_5->cmap) {
				VAR_5->cmap = VAR_2;
				VAR_2 = 0;
			}
			break;
		case VAR_29:
			if (!VAR_5->colr) {
				VAR_5->colr = VAR_2;
				VAR_2 = 0;
			}
			break;
		}
		if (VAR_2) {
			jp2_box_destroy(VAR_2);
			VAR_2 = 0;
		}
		if (VAR_3) {
			break;
		}
	}

	if (!VAR_3) {
		jas_eprintf(""error: no code stream found\n"");
		goto error;
	}

	if (!(VAR_5->image = jpc_decode(VAR_0, VAR_1))) {
		jas_eprintf(""error: cannot decode code stream\n"");
		goto error;
	}

	/* COMMENT_3 */
	if (!VAR_5->ihdr) {
		jas_eprintf(""error: missing IHDR box\n"");
		goto error;
	}

	/* COMMENT_4 */
                                             
	if (VAR_5->ihdr->data.ihdr.numcmpts != JAS_CAST(VAR_30,
	  jas_image_numcmpts(VAR_5->image))) {
		jas_eprintf(""warning: number of components mismatch\n"");
	}

	/* COMMENT_6 */
	if (!jas_image_numcmpts(VAR_5->image)) {
		jas_eprintf(""error: no components\n"");
		goto error;
	}

	/* COMMENT_7 */
	VAR_6 = true;
	VAR_7 = jas_image_cmptdtype(VAR_5->image, 0);
	for (VAR_8 = 1; VAR_8 < JAS_CAST(VAR_30, jas_image_numcmpts(VAR_5->image)); ++VAR_8) {
		if (jas_image_cmptdtype(VAR_5->image, VAR_8) != VAR_7) {
			VAR_6 = false;
			break;
		}
	}

	/* COMMENT_8 */
                                       
	if ((VAR_6 && VAR_5->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(VAR_7)) ||
	  (!VAR_6 && VAR_5->ihdr->data.ihdr.bpc != VAR_31)) {
		jas_eprintf(""warning: component data type mismatch\n"");
	}

	/* COMMENT_10 */
	if (VAR_5->ihdr->data.ihdr.comptype != VAR_32) {
		jas_eprintf(""error: unsupported compression type\n"");
		goto error;
	}

	if (VAR_5->bpcc) {
		/* COMMENT_11 */
                                            
		if (VAR_5->bpcc->data.bpcc.numcmpts != JAS_CAST(VAR_30, jas_image_numcmpts(
		  VAR_5->image))) {
			jas_eprintf(""warning: number of components mismatch\n"");
		}
		/* COMMENT_13 */
                                                
		if (!VAR_6) {
			for (VAR_8 = 0; VAR_8 < JAS_CAST(VAR_30, jas_image_numcmpts(VAR_5->image));
			  ++VAR_8) {
				if (jas_image_cmptdtype(VAR_5->image, VAR_8) !=
				  JP2_BPCTODTYPE(VAR_5->bpcc->data.bpcc.bpcs[VAR_8])) {
					jas_eprintf(""warning: component data type mismatch\n"");
				}
			}
		} else {
			jas_eprintf(""warning: superfluous BPCC box\n"");
		}
	}

	/* COMMENT_15 */
	if (!VAR_5->colr) {
		jas_eprintf(""error: no COLR box\n"");
		goto error;
	}

	switch (VAR_5->colr->data.colr.method) {
	case VAR_33:
		jas_image_setclrspc(VAR_5->image, jp2_getcs(&VAR_5->colr->data.colr));
		break;
	case VAR_34:
		VAR_19 = jas_iccprof_createfrombuf(VAR_5->colr->data.colr.iccp,
		  VAR_5->colr->data.colr.iccplen);
		if (!VAR_19) {
			jas_eprintf(""error: failed to parse ICC profile\n"");
			goto error;
		}
		jas_iccprof_gethdr(VAR_19, &VAR_18);
		jas_eprintf(""ICC Profile CS %08x\n"", VAR_18.colorspc);
		jas_image_setclrspc(VAR_5->image, fromiccpcs(VAR_18.colorspc));
		VAR_5->image->cmprof_ = jas_cmprof_createfromiccprof(VAR_19);
		assert(VAR_5->image->cmprof_);
		jas_iccprof_destroy(VAR_19);
		break;
	}

	/* COMMENT_16 */
	if (VAR_5->cmap && !VAR_5->pclr) {
		jas_eprintf(""warning: missing PCLR box or superfluous CMAP box\n"");
		jp2_box_destroy(VAR_5->cmap);
		VAR_5->cmap = 0;
	}

	/* COMMENT_17 */
	if (!VAR_5->cmap && VAR_5->pclr) {
		jas_eprintf(""warning: missing CMAP box or superfluous PCLR box\n"");
		jp2_box_destroy(VAR_5->pclr);
		VAR_5->pclr = 0;
	}

	/* COMMENT_18 */
                                                                  
	VAR_5->numchans = VAR_5->cmap ? VAR_5->cmap->data.cmap.numchans :
	  JAS_CAST(VAR_30, jas_image_numcmpts(VAR_5->image));

	/* COMMENT_20 */
	if (VAR_5->cmap) {
		for (VAR_8 = 0; VAR_8 < VAR_5->numchans; ++VAR_8) {
			/* COMMENT_21 */
			if (VAR_5->cmap->data.cmap.ents[VAR_8].cmptno >= JAS_CAST(VAR_30,
			  jas_image_numcmpts(VAR_5->image))) {
				jas_eprintf(""error: invalid component number in CMAP box\n"");
				goto error;
			}
			/* COMMENT_22 */
			if (VAR_5->cmap->data.cmap.ents[VAR_8].pcol >=
			  VAR_5->pclr->data.pclr.numchans) {
				jas_eprintf(""error: invalid CMAP LUT index\n"");
				goto error;
			}
		}
	}

	/* COMMENT_23 */
	if (!(VAR_5->chantocmptlut = jas_alloc2(VAR_5->numchans,
	  sizeof(VAR_35)))) {
		jas_eprintf(""error: no memory\n"");
		goto error;
	}

	if (!VAR_5->cmap) {
		for (VAR_8 = 0; VAR_8 < VAR_5->numchans; ++VAR_8) {
			VAR_5->chantocmptlut[VAR_8] = VAR_8;
		}
	} else {
		VAR_9 = &VAR_5->cmap->data.cmap;
		VAR_10 = &VAR_5->pclr->data.pclr;
		VAR_11 = &VAR_5->cdef->data.cdef;
		for (VAR_12 = 0; VAR_12 < VAR_9->numchans; ++VAR_12) {
			VAR_17 = &VAR_9->ents[VAR_12];
			if (VAR_17->map == VAR_36) {
				VAR_5->chantocmptlut[VAR_12] = VAR_12;
			} else if (VAR_17->map == VAR_37) {
				VAR_14 = jas_alloc2(VAR_10->numlutents, sizeof(int_fast32_t));
				for (VAR_8 = 0; VAR_8 < VAR_10->numlutents; ++VAR_8) {
					VAR_14[VAR_8] = VAR_10->lutdata[VAR_17->pcol + VAR_8 * VAR_10->numchans];
				}
				VAR_13 = jas_image_numcmpts(VAR_5->image);
				jas_image_depalettize(VAR_5->image, VAR_17->cmptno,
				  VAR_10->numlutents, VAR_14,
				  JP2_BPCTODTYPE(VAR_10->bpc[VAR_17->pcol]), VAR_13);
				VAR_5->chantocmptlut[VAR_12] = VAR_13;
				jas_free(VAR_14);
#if 0
				if (VAR_5->cdef) {
					VAR_15 = jp2_cdef_lookup(VAR_11, VAR_12);
					if (!VAR_15) {
						abort();
					}
				jas_image_setcmpttype(VAR_5->image, VAR_13, jp2_getct(jas_image_clrspc(VAR_5->image), VAR_15->type, VAR_15->assoc));
				} else {
				jas_image_setcmpttype(VAR_5->image, VAR_13, jp2_getct(jas_image_clrspc(VAR_5->image), 0, VAR_12 + 1));
				}
#endif
			}
		}
	}

	/* COMMENT_24 */

	for (VAR_8 = 0; VAR_8 < JAS_CAST(VAR_30, jas_image_numcmpts(VAR_5->image)); ++VAR_8) {
		jas_image_setcmpttype(VAR_5->image, VAR_8, VAR_38);
	}

	/* COMMENT_25 */
	if (VAR_5->cdef) {
		for (VAR_8 = 0; VAR_8 < VAR_5->numchans; ++VAR_8) {
			/* COMMENT_26 */
			if (VAR_5->cdef->data.cdef.ents[VAR_8].channo >= VAR_5->numchans) {
				jas_eprintf(""error: invalid channel number in CDEF box\n"");
				goto error;
			}
			jas_image_setcmpttype(VAR_5->image,
			  VAR_5->chantocmptlut[VAR_5->cdef->data.cdef.ents[VAR_8].channo],
			  jp2_getct(jas_image_clrspc(VAR_5->image),
			  VAR_5->cdef->data.cdef.ents[VAR_8].type,
			  VAR_5->cdef->data.cdef.ents[VAR_8].assoc));
		}
	} else {
		for (VAR_8 = 0; VAR_8 < VAR_5->numchans; ++VAR_8) {
			jas_image_setcmpttype(VAR_5->image, VAR_5->chantocmptlut[VAR_8],
			  jp2_getct(jas_image_clrspc(VAR_5->image), 0, VAR_8 + 1));
		}
	}

	/* COMMENT_27 */
	for (VAR_8 = jas_image_numcmpts(VAR_5->image); VAR_8 > 0; --VAR_8) {
		if (jas_image_cmpttype(VAR_5->image, VAR_8 - 1) == VAR_38) {
			jas_image_delcmpt(VAR_5->image, VAR_8 - 1);
		}
	}

	/* COMMENT_28 */
	if (!jas_image_numcmpts(VAR_5->image)) {
		jas_eprintf(""error: no components\n"");
		goto error;
	}
#if 0
jas_eprintf(""no of components is %d\n"", jas_image_numcmpts(VAR_5->image));
#endif

	/* COMMENT_29 */
	VAR_4 = VAR_5->image;
	VAR_5->image = 0;

	jp2_dec_destroy(VAR_5);

	return VAR_4;

error:
	if (VAR_2) {
		jp2_box_destroy(VAR_2);
	}
	if (VAR_5) {
		jp2_dec_destroy(VAR_5);
	}
	return 0;
}",jasper-software/jasper/e24bdc716c3327b067c551bc6cfb97fd2370358d/jp2_dec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -60,7 +60,7 @@
 	found = 0;
 	while ((box = jp2_box_get(in))) {
 		if (jas_getdbglevel() >= 1) {
-			jas_eprintf(""box type %s\n"", box->info->name);
+			jas_eprintf(""got box type %s\n"", box->info->name);
 		}
 		switch (box->type) {
 		case JP2_BOX_JP2C:","{'deleted_lines': ['\t\t\tjas_eprintf(""box type %s\\n"", box->info->name);'], 'added_lines': ['\t\t\tjas_eprintf(""got box type %s\\n"", box->info->name);']}",True,The jp2_colr_destroy function in libjasper/jp2/jp2_cod.c in JasPer before 1.900.10 allows remote attackers to cause a denial of service (NULL pointer dereference).,5.5,MEDIUM,1,test,2016-10-21T07:00:27Z,1
CVE-2016-9631,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,tats/w3m,"Prevent deref null pointer in HTMLlineproc0()

Bug-Debian: https://github.com/tats/w3m/issues/42
Origin: https://anonscm.debian.org/cgit/collab-maint/w3m.git/commit/?id=ecfdcbe1131591502c5e7f9ff4f34b24c5a2db97",a8cba1bd912a65ed40acded2bd5013d1f01253e1,https://github.com/tats/w3m/commit/a8cba1bd912a65ed40acded2bd5013d1f01253e1,file.c,HTMLlineproc0,"void
HTMLlineproc0(char *line, struct html_feed_environ *h_env, int internal)
{
Lineprop mode;
int cmd;
struct readbuffer *obuf = h_env->obuf;
int indent, delta;
struct parsed_tag *tag;
Str tokbuf;
struct table *tbl = NULL;
struct table_mode *tbl_mode = NULL;
int tbl_width = 0;
#ifdef USE_M17N
int is_hangul, prev_is_hangul = 0;
#endif
#ifdef DEBUG
if (w3m_debug) {
FILE *f = fopen(""zzzproc1"", ""a"");
fprintf(f, ""%c%c%c%c"",
(obuf->flag & RB_PREMODE) ? 'P' : ' ',
(obuf->table_level >= 0) ? 'T' : ' ',
(obuf->flag & RB_INTXTA) ? 'X' : ' ',
(obuf->flag & (RB_SCRIPT | RB_STYLE)) ? 'S' : ' ');
fprintf(f, ""HTMLlineproc1(\""%s\"",%d,%lx)\n"", line, h_env->limit,
(unsigned long)h_env);
fclose(f);
}
#endif
tokbuf = Strnew();
table_start:
if (obuf->table_level >= 0) {
int level = min(obuf->table_level, MAX_TABLE - 1);
tbl = tables[level];
tbl_mode = &table_mode[level];
tbl_width = table_width(h_env, level);
}
while (*line != '\0') {
char *str, *p;
int is_tag = FALSE;
int pre_mode = (obuf->table_level >= 0) ? tbl_mode->pre_mode :
obuf->flag;
int end_tag = (obuf->table_level >= 0) ? tbl_mode->end_tag :
obuf->end_tag;
if (*line == '<' || obuf->status != R_ST_NORMAL) {
if (obuf->status == R_ST_EOL)
obuf->status = R_ST_NORMAL;
else {
read_token(h_env->tagbuf, &line, &obuf->status,
pre_mode & RB_PREMODE, obuf->status != R_ST_NORMAL);
if (obuf->status != R_ST_NORMAL)
return;
}
if (h_env->tagbuf->length == 0)
continue;
str = h_env->tagbuf->ptr;
if (*str == '<') {
if (str[1] && REALLY_THE_BEGINNING_OF_A_TAG(str))
is_tag = TRUE;
else if (!(pre_mode & (RB_PLAIN | RB_INTXTA | RB_INSELECT |
RB_SCRIPT | RB_STYLE | RB_TITLE))) {
line = Strnew_m_charp(str + 1, line, NULL)->ptr;
str = ""&lt;"";
}
}
}
else {
read_token(tokbuf, &line, &obuf->status, pre_mode & RB_PREMODE, 0);
if (obuf->status != R_ST_NORMAL)
obuf->status = R_ST_NORMAL;
str = tokbuf->ptr;
}
if (pre_mode & (RB_PLAIN | RB_INTXTA | RB_INSELECT | RB_SCRIPT |
RB_STYLE | RB_TITLE)) {
if (is_tag) {
p = str;
if ((tag = parse_tag(&p, internal))) {
if (tag->tagid == end_tag ||
(pre_mode & RB_INSELECT && tag->tagid == HTML_N_FORM)
|| (pre_mode & RB_TITLE
&& (tag->tagid == HTML_N_HEAD
|| tag->tagid == HTML_BODY)))
goto proc_normal;
}
}
if (pre_mode & RB_TITLE) {
feed_title(str);
continue;
}
if (pre_mode & RB_INSELECT) {
if (obuf->table_level >= 0)
goto proc_normal;
feed_select(str);
continue;
}
if (is_tag) {
if (strncmp(str, ""<!--"", 4) && (p = strchr(str + 1, '<'))) {
str = Strnew_charp_n(str, p - str)->ptr;
line = Strnew_m_charp(p, line, NULL)->ptr;
}
is_tag = FALSE;
}
if (obuf->table_level >= 0)
goto proc_normal;
if (pre_mode & RB_INTXTA) {
feed_textarea(str);
continue;
}
if (pre_mode & RB_SCRIPT)
continue;
if (pre_mode & RB_STYLE)
continue;
}
proc_normal:
if (obuf->table_level >= 0) {
switch (feed_table(tbl, str, tbl_mode, tbl_width, internal)) {
case 0:
obuf->table_level--;
if (obuf->table_level >= MAX_TABLE - 1)
continue;
end_table(tbl);
if (obuf->table_level >= 0) {
struct table *tbl0 = tables[obuf->table_level];
str = Sprintf(""<table_alt tid=%d>"", tbl0->ntable)->ptr;
pushTable(tbl0, tbl);
tbl = tbl0;
tbl_mode = &table_mode[obuf->table_level];
tbl_width = table_width(h_env, obuf->table_level);
feed_table(tbl, str, tbl_mode, tbl_width, TRUE);
continue;
}
if (obuf->flag & RB_DEL)
continue;
if (tbl->vspace > 0 && !(obuf->flag & RB_IGNORE_P)) {
int indent = h_env->envs[h_env->envc].indent;
flushline(h_env, obuf, indent, 0, h_env->limit);
do_blankline(h_env, obuf, indent, 0, h_env->limit);
}
save_fonteffect(h_env, obuf);
initRenderTable();
renderTable(tbl, tbl_width, h_env);
restore_fonteffect(h_env, obuf);
obuf->flag &= ~RB_IGNORE_P;
if (tbl->vspace > 0) {
int indent = h_env->envs[h_env->envc].indent;
do_blankline(h_env, obuf, indent, 0, h_env->limit);
obuf->flag |= RB_IGNORE_P;
}
set_space_to_prevchar(obuf->prevchar);
continue;
case 1:
break;
default:
continue;
}
}
if (is_tag) {
if ((tag = parse_tag(&str, internal)))
cmd = tag->tagid;
else
continue;
if (HTMLtagproc1(tag, h_env) == 0) {
if (parsedtag_need_reconstruct(tag))
h_env->tagbuf = parsedtag2str(tag);
push_tag(obuf, h_env->tagbuf->ptr, cmd);
}
#ifdef ID_EXT
else {
process_idattr(obuf, cmd, tag);
}
#endif
obuf->bp.init_flag = 1;
clear_ignore_p_flag(cmd, obuf);
if (cmd == HTML_TABLE)
goto table_start;
else
continue;
}
if (obuf->flag & (RB_DEL | RB_S))
continue;
while (*str) {
mode = get_mctype(str);
delta = get_mcwidth(str);
if (obuf->flag & (RB_SPECIAL & ~RB_NOBR)) {
char ch = *str;
if (!(obuf->flag & RB_PLAIN) && (*str == '&')) {
char *p = str;
int ech = getescapechar(&p);
if (ech == '\n' || ech == '\r') {
ch = '\n';
str = p - 1;
}
else if (ech == '\t') {
ch = '\t';
str = p - 1;
}
}
if (ch != '\n')
obuf->flag &= ~RB_IGNORE_P;
if (ch == '\n') {
str++;
if (obuf->flag & RB_IGNORE_P) {
obuf->flag &= ~RB_IGNORE_P;
continue;
}
if (obuf->flag & RB_PRE_INT)
PUSH(' ');
else
flushline(h_env, obuf, h_env->envs[h_env->envc].indent,
1, h_env->limit);
}
else if (ch == '\t') {
do {
PUSH(' ');
} while ((h_env->envs[h_env->envc].indent + obuf->pos)
% Tabstop != 0);
str++;
}
else if (obuf->flag & RB_PLAIN) {
char *p = html_quote_char(*str);
if (p) {
push_charp(obuf, 1, p, PC_ASCII);
str++;
}
else {
proc_mchar(obuf, 1, delta, &str, mode);
}
}
else {
if (*str == '&')
proc_escape(obuf, &str);
else
proc_mchar(obuf, 1, delta, &str, mode);
}
if (obuf->flag & (RB_SPECIAL & ~RB_PRE_INT))
continue;
}
else {
if (!IS_SPACE(*str))
obuf->flag &= ~RB_IGNORE_P;
if ((mode == PC_ASCII || mode == PC_CTRL) && IS_SPACE(*str)) {
if (*obuf->prevchar->ptr != ' ') {
PUSH(' ');
}
str++;
}
else {
#ifdef USE_M17N
if (mode == PC_KANJI1)
is_hangul = wtf_is_hangul((wc_uchar *) str);
else
is_hangul = 0;
if (!SimplePreserveSpace && mode == PC_KANJI1 &&
!is_hangul && !prev_is_hangul &&
obuf->pos > h_env->envs[h_env->envc].indent &&
Strlastchar(obuf->line) == ' ') {
while (obuf->line->length >= 2 &&
!strncmp(obuf->line->ptr + obuf->line->length -
2, ""  "", 2)
&& obuf->pos >= h_env->envs[h_env->envc].indent) {
Strshrink(obuf->line, 1);
obuf->pos--;
}
if (obuf->line->length >= 3 &&
obuf->prev_ctype == PC_KANJI1 &&
Strlastchar(obuf->line) == ' ' &&
obuf->pos >= h_env->envs[h_env->envc].indent) {
Strshrink(obuf->line, 1);
obuf->pos--;
}
}
prev_is_hangul = is_hangul;
#endif
if (*str == '&')
proc_escape(obuf, &str);
else
proc_mchar(obuf, obuf->flag & RB_SPECIAL, delta, &str,
mode);
}
}
if (need_flushline(h_env, obuf, mode)) {
char *bp = obuf->line->ptr + obuf->bp.len;
char *tp = bp - obuf->bp.tlen;
int i = 0;
if (tp > obuf->line->ptr && tp[-1] == ' ')
i = 1;
indent = h_env->envs[h_env->envc].indent;
if (obuf->bp.pos - i > indent) {
Str line;
append_tags(obuf);
line = Strnew_charp(bp);
Strshrink(obuf->line, obuf->line->length - obuf->bp.len);
#ifdef FORMAT_NICE
if (obuf->pos - i > h_env->limit)
obuf->flag |= RB_FILL;
#endif
back_to_breakpoint(obuf);
flushline(h_env, obuf, indent, 0, h_env->limit);
#ifdef FORMAT_NICE
obuf->flag &= ~RB_FILL;
#endif
HTMLlineproc1(line->ptr, h_env);
}
}
}
}
if (!(obuf->flag & (RB_SPECIAL | RB_INTXTA | RB_INSELECT))) {
char *tp;
int i = 0;
if (obuf->bp.pos == obuf->pos) {
tp = &obuf->line->ptr[obuf->bp.len - obuf->bp.tlen];
}
else {
tp = &obuf->line->ptr[obuf->line->length];
}
if (tp > obuf->line->ptr && tp[-1] == ' ')
i = 1;
indent = h_env->envs[h_env->envc].indent;
if (obuf->pos - i > h_env->limit) {
#ifdef FORMAT_NICE
obuf->flag |= RB_FILL;
#endif
flushline(h_env, obuf, indent, 0, h_env->limit);
#ifdef FORMAT_NICE
obuf->flag &= ~RB_FILL;
#endif
}
}
}","void
HTMLlineproc0(char *VAR_0, struct html_feed_environ *VAR_1, int VAR_2)
{
Lineprop VAR_3;
int VAR_4;
struct readbuffer *VAR_5 = VAR_1->obuf;
int VAR_6, VAR_7;
struct parsed_tag *VAR_8;
Str VAR_9;
struct table *VAR_10 = NULL;
struct table_mode *VAR_11 = NULL;
int VAR_12 = 0;
#ifdef VAR_13
int VAR_14, VAR_15 = 0;
#endif
#ifdef VAR_16
if (VAR_17) {
FILE *VAR_18 = fopen(""zzzproc1"", ""a"");
fprintf(VAR_18, ""%c%c%c%c"",
(VAR_5->flag & VAR_19) ? 'P' : ' ',
(VAR_5->table_level >= 0) ? 'T' : ' ',
(VAR_5->flag & VAR_20) ? 'X' : ' ',
(VAR_5->flag & (VAR_21 | VAR_22)) ? 'S' : ' ');
fprintf(VAR_18, ""HTMLlineproc1(\""%s\"",%d,%lx)\n"", VAR_0, VAR_1->limit,
(unsigned long)VAR_1);
fclose(VAR_18);
}
#endif
VAR_9 = Strnew();
table_start:
if (VAR_5->table_level >= 0) {
int VAR_23 = min(VAR_5->table_level, VAR_24 - 1);
VAR_10 = VAR_25[VAR_23];
VAR_11 = &table_mode[VAR_23];
VAR_12 = table_width(VAR_1, VAR_23);
}
while (*VAR_0 != '\0') {
char *VAR_26, *VAR_27;
int VAR_28 = FALSE;
int VAR_29 = (VAR_5->table_level >= 0) ? VAR_11->pre_mode :
VAR_5->flag;
int VAR_30 = (VAR_5->table_level >= 0) ? VAR_11->end_tag :
VAR_5->end_tag;
if (*VAR_0 == '<' || VAR_5->status != VAR_31) {
if (VAR_5->status == VAR_32)
VAR_5->status = VAR_31;
else {
read_token(VAR_1->tagbuf, &VAR_0, &VAR_5->status,
VAR_29 & VAR_19, VAR_5->status != VAR_31);
if (VAR_5->status != VAR_31)
return;
}
if (VAR_1->tagbuf->length == 0)
continue;
VAR_26 = VAR_1->tagbuf->ptr;
if (*VAR_26 == '<') {
if (VAR_26[1] && REALLY_THE_BEGINNING_OF_A_TAG(VAR_26))
VAR_28 = TRUE;
else if (!(VAR_29 & (VAR_33 | VAR_20 | VAR_34 |
VAR_21 | VAR_22 | VAR_35))) {
VAR_0 = Strnew_m_charp(VAR_26 + 1, VAR_0, NULL)->ptr;
VAR_26 = ""&lt;"";
}
}
}
else {
read_token(VAR_9, &VAR_0, &VAR_5->status, VAR_29 & VAR_19, 0);
if (VAR_5->status != VAR_31)
VAR_5->status = VAR_31;
VAR_26 = VAR_9->ptr;
}
if (VAR_29 & (VAR_33 | VAR_20 | VAR_34 | VAR_21 |
VAR_22 | VAR_35)) {
if (VAR_28) {
VAR_27 = VAR_26;
if ((VAR_8 = parse_tag(&VAR_27, VAR_2))) {
if (VAR_8->tagid == VAR_30 ||
(VAR_29 & VAR_34 && VAR_8->tagid == VAR_36)
|| (VAR_29 & VAR_35
&& (VAR_8->tagid == VAR_37
|| VAR_8->tagid == VAR_38)))
goto proc_normal;
}
}
if (VAR_29 & VAR_35) {
feed_title(VAR_26);
continue;
}
if (VAR_29 & VAR_34) {
if (VAR_5->table_level >= 0)
goto proc_normal;
feed_select(VAR_26);
continue;
}
if (VAR_28) {
if (strncmp(VAR_26, ""<!--"", 4) && (VAR_27 = strchr(VAR_26 + 1, '<'))) {
VAR_26 = Strnew_charp_n(VAR_26, VAR_27 - VAR_26)->ptr;
VAR_0 = Strnew_m_charp(VAR_27, VAR_0, NULL)->ptr;
}
VAR_28 = FALSE;
}
if (VAR_5->table_level >= 0)
goto proc_normal;
if (VAR_29 & VAR_20) {
feed_textarea(VAR_26);
continue;
}
if (VAR_29 & VAR_21)
continue;
if (VAR_29 & VAR_22)
continue;
}
proc_normal:
if (VAR_5->table_level >= 0) {
switch (feed_table(VAR_10, VAR_26, VAR_11, VAR_12, VAR_2)) {
case 0:
VAR_5->table_level--;
if (VAR_5->table_level >= VAR_24 - 1)
continue;
end_table(VAR_10);
if (VAR_5->table_level >= 0) {
struct table *VAR_39 = VAR_25[VAR_5->table_level];
VAR_26 = Sprintf(""<table_alt tid=%d>"", VAR_39->ntable)->ptr;
pushTable(VAR_39, VAR_10);
VAR_10 = VAR_39;
VAR_11 = &table_mode[VAR_5->table_level];
VAR_12 = table_width(VAR_1, VAR_5->table_level);
feed_table(VAR_10, VAR_26, VAR_11, VAR_12, TRUE);
continue;
}
if (VAR_5->flag & VAR_40)
continue;
if (VAR_10->vspace > 0 && !(VAR_5->flag & VAR_41)) {
int VAR_6 = VAR_1->envs[VAR_1->envc].indent;
flushline(VAR_1, VAR_5, VAR_6, 0, VAR_1->limit);
do_blankline(VAR_1, VAR_5, VAR_6, 0, VAR_1->limit);
}
save_fonteffect(VAR_1, VAR_5);
initRenderTable();
renderTable(VAR_10, VAR_12, VAR_1);
restore_fonteffect(VAR_1, VAR_5);
VAR_5->flag &= ~VAR_41;
if (VAR_10->vspace > 0) {
int VAR_6 = VAR_1->envs[VAR_1->envc].indent;
do_blankline(VAR_1, VAR_5, VAR_6, 0, VAR_1->limit);
VAR_5->flag |= VAR_41;
}
set_space_to_prevchar(VAR_5->prevchar);
continue;
case 1:
break;
default:
continue;
}
}
if (VAR_28) {
if ((VAR_8 = parse_tag(&VAR_26, VAR_2)))
VAR_4 = VAR_8->tagid;
else
continue;
if (HTMLtagproc1(VAR_8, VAR_1) == 0) {
if (parsedtag_need_reconstruct(VAR_8))
VAR_1->tagbuf = parsedtag2str(VAR_8);
push_tag(VAR_5, VAR_1->tagbuf->ptr, VAR_4);
}
#ifdef VAR_42
else {
process_idattr(VAR_5, VAR_4, VAR_8);
}
#endif
VAR_5->bp.init_flag = 1;
clear_ignore_p_flag(VAR_4, VAR_5);
if (VAR_4 == VAR_43)
goto table_start;
else
continue;
}
if (VAR_5->flag & (VAR_40 | VAR_44))
continue;
while (*VAR_26) {
VAR_3 = get_mctype(VAR_26);
VAR_7 = get_mcwidth(VAR_26);
if (VAR_5->flag & (VAR_45 & ~VAR_46)) {
char VAR_47 = *VAR_26;
if (!(VAR_5->flag & VAR_33) && (*VAR_26 == '&')) {
char *VAR_27 = VAR_26;
int VAR_48 = getescapechar(&VAR_27);
if (VAR_48 == '\n' || VAR_48 == '\r') {
VAR_47 = '\n';
VAR_26 = VAR_27 - 1;
}
else if (VAR_48 == '\t') {
VAR_47 = '\t';
VAR_26 = VAR_27 - 1;
}
}
if (VAR_47 != '\n')
VAR_5->flag &= ~VAR_41;
if (VAR_47 == '\n') {
VAR_26++;
if (VAR_5->flag & VAR_41) {
VAR_5->flag &= ~VAR_41;
continue;
}
if (VAR_5->flag & VAR_49)
PUSH(' ');
else
flushline(VAR_1, VAR_5, VAR_1->envs[VAR_1->envc].indent,
1, VAR_1->limit);
}
else if (VAR_47 == '\t') {
do {
PUSH(' ');
} while ((VAR_1->envs[VAR_1->envc].indent + VAR_5->pos)
% VAR_50 != 0);
VAR_26++;
}
else if (VAR_5->flag & VAR_33) {
char *VAR_27 = html_quote_char(*VAR_26);
if (VAR_27) {
push_charp(VAR_5, 1, VAR_27, VAR_51);
VAR_26++;
}
else {
proc_mchar(VAR_5, 1, VAR_7, &VAR_26, VAR_3);
}
}
else {
if (*VAR_26 == '&')
proc_escape(VAR_5, &VAR_26);
else
proc_mchar(VAR_5, 1, VAR_7, &VAR_26, VAR_3);
}
if (VAR_5->flag & (VAR_45 & ~VAR_49))
continue;
}
else {
if (!IS_SPACE(*VAR_26))
VAR_5->flag &= ~VAR_41;
if ((VAR_3 == VAR_51 || VAR_3 == VAR_52) && IS_SPACE(*VAR_26)) {
if (*VAR_5->prevchar->ptr != ' ') {
PUSH(' ');
}
VAR_26++;
}
else {
#ifdef VAR_13
if (VAR_3 == VAR_53)
VAR_14 = wtf_is_hangul((wc_uchar *) VAR_26);
else
VAR_14 = 0;
if (!VAR_54 && VAR_3 == VAR_53 &&
!VAR_14 && !VAR_15 &&
VAR_5->pos > VAR_1->envs[VAR_1->envc].indent &&
Strlastchar(VAR_5->line) == ' ') {
while (VAR_5->line->length >= 2 &&
!strncmp(VAR_5->line->ptr + VAR_5->line->length -
2, ""  "", 2)
&& VAR_5->pos >= VAR_1->envs[VAR_1->envc].indent) {
Strshrink(VAR_5->line, 1);
VAR_5->pos--;
}
if (VAR_5->line->length >= 3 &&
VAR_5->prev_ctype == VAR_53 &&
Strlastchar(VAR_5->line) == ' ' &&
VAR_5->pos >= VAR_1->envs[VAR_1->envc].indent) {
Strshrink(VAR_5->line, 1);
VAR_5->pos--;
}
}
VAR_15 = VAR_14;
#endif
if (*VAR_26 == '&')
proc_escape(VAR_5, &VAR_26);
else
proc_mchar(VAR_5, VAR_5->flag & VAR_45, VAR_7, &VAR_26,
VAR_3);
}
}
if (need_flushline(VAR_1, VAR_5, VAR_3)) {
char *VAR_55 = VAR_5->line->ptr + VAR_5->bp.len;
char *VAR_56 = VAR_55 - VAR_5->bp.tlen;
int VAR_57 = 0;
if (VAR_56 > VAR_5->line->ptr && VAR_56[-1] == ' ')
VAR_57 = 1;
VAR_6 = VAR_1->envs[VAR_1->envc].indent;
if (VAR_5->bp.pos - VAR_57 > VAR_6) {
Str VAR_0;
append_tags(VAR_5);
VAR_0 = Strnew_charp(VAR_55);
Strshrink(VAR_5->line, VAR_5->line->length - VAR_5->bp.len);
#ifdef VAR_58
if (VAR_5->pos - VAR_57 > VAR_1->limit)
VAR_5->flag |= VAR_59;
#endif
back_to_breakpoint(VAR_5);
flushline(VAR_1, VAR_5, VAR_6, 0, VAR_1->limit);
#ifdef VAR_58
VAR_5->flag &= ~VAR_59;
#endif
HTMLlineproc1(VAR_0->ptr, VAR_1);
}
}
}
}
if (!(VAR_5->flag & (VAR_45 | VAR_20 | VAR_34))) {
char *VAR_56;
int VAR_57 = 0;
if (VAR_5->bp.pos == VAR_5->pos) {
VAR_56 = &VAR_5->line->ptr[VAR_5->bp.len - VAR_5->bp.tlen];
}
else {
VAR_56 = &VAR_5->line->ptr[VAR_5->line->length];
}
if (VAR_56 > VAR_5->line->ptr && VAR_56[-1] == ' ')
VAR_57 = 1;
VAR_6 = VAR_1->envs[VAR_1->envc].indent;
if (VAR_5->pos - VAR_57 > VAR_1->limit) {
#ifdef VAR_58
VAR_5->flag |= VAR_59;
#endif
flushline(VAR_1, VAR_5, VAR_6, 0, VAR_1->limit);
#ifdef VAR_58
VAR_5->flag &= ~VAR_59;
#endif
}
}
}",tats/w3m/a8cba1bd912a65ed40acded2bd5013d1f01253e1/file.c/vul/before/0.json,"void
HTMLlineproc0(char *line, struct html_feed_environ *h_env, int internal)
{
    Lineprop mode;
    int cmd;
    struct readbuffer *obuf = h_env->obuf;
    int indent, delta;
    struct parsed_tag *tag;
    Str tokbuf;
    struct table *tbl = NULL;
    struct table_mode *tbl_mode = NULL;
    int tbl_width = 0;
#ifdef USE_M17N
    int is_hangul, prev_is_hangul = 0;
#endif

#ifdef DEBUG
    if (w3m_debug) {
	FILE *f = fopen(""zzzproc1"", ""a"");
	fprintf(f, ""%c%c%c%c"",
		(obuf->flag & RB_PREMODE) ? 'P' : ' ',
		(obuf->table_level >= 0) ? 'T' : ' ',
		(obuf->flag & RB_INTXTA) ? 'X' : ' ',
		(obuf->flag & (RB_SCRIPT | RB_STYLE)) ? 'S' : ' ');
	fprintf(f, ""HTMLlineproc1(\""%s\"",%d,%lx)\n"", line, h_env->limit,
		(unsigned long)h_env);
	fclose(f);
    }
#endif

    tokbuf = Strnew();

  table_start:
    if (obuf->table_level >= 0) {
	int level = min(obuf->table_level, MAX_TABLE - 1);
	tbl = tables[level];
	tbl_mode = &table_mode[level];
	tbl_width = table_width(h_env, level);
    }

    while (*line != '\0') {
	char *str, *p;
	int is_tag = FALSE;
	int pre_mode = (obuf->table_level >= 0 && tbl_mode) ?
	    tbl_mode->pre_mode : obuf->flag;
	int end_tag = (obuf->table_level >= 0 && tbl_mode) ?
	    tbl_mode->end_tag : obuf->end_tag;

	if (*line == '<' || obuf->status != R_ST_NORMAL) {
	    /* 
	     * Tag processing
	     */
	    if (obuf->status == R_ST_EOL)
		obuf->status = R_ST_NORMAL;
	    else {
		read_token(h_env->tagbuf, &line, &obuf->status,
			   pre_mode & RB_PREMODE, obuf->status != R_ST_NORMAL);
		if (obuf->status != R_ST_NORMAL)
		    return;
	    }
	    if (h_env->tagbuf->length == 0)
		continue;
	    str = h_env->tagbuf->ptr;
	    if (*str == '<') {
		if (str[1] && REALLY_THE_BEGINNING_OF_A_TAG(str))
		    is_tag = TRUE;
		else if (!(pre_mode & (RB_PLAIN | RB_INTXTA | RB_INSELECT |
				       RB_SCRIPT | RB_STYLE | RB_TITLE))) {
		    line = Strnew_m_charp(str + 1, line, NULL)->ptr;
		    str = ""&lt;"";
		}
	    }
	}
	else {
	    read_token(tokbuf, &line, &obuf->status, pre_mode & RB_PREMODE, 0);
	    if (obuf->status != R_ST_NORMAL)	/* R_ST_AMP ? */
		obuf->status = R_ST_NORMAL;
	    str = tokbuf->ptr;
	}

	if (pre_mode & (RB_PLAIN | RB_INTXTA | RB_INSELECT | RB_SCRIPT |
			RB_STYLE | RB_TITLE)) {
	    if (is_tag) {
		p = str;
		if ((tag = parse_tag(&p, internal))) {
		    if (tag->tagid == end_tag ||
			(pre_mode & RB_INSELECT && tag->tagid == HTML_N_FORM)
			|| (pre_mode & RB_TITLE
			    && (tag->tagid == HTML_N_HEAD
				|| tag->tagid == HTML_BODY)))
			goto proc_normal;
		}
	    }
	    /* title */
	    if (pre_mode & RB_TITLE) {
		feed_title(str);
		continue;
	    }
	    /* select */
	    if (pre_mode & RB_INSELECT) {
		if (obuf->table_level >= 0)
		    goto proc_normal;
		feed_select(str);
		continue;
	    }
	    if (is_tag) {
		if (strncmp(str, ""<!--"", 4) && (p = strchr(str + 1, '<'))) {
		    str = Strnew_charp_n(str, p - str)->ptr;
		    line = Strnew_m_charp(p, line, NULL)->ptr;
		}
		is_tag = FALSE;
	    }
	    if (obuf->table_level >= 0)
		goto proc_normal;
	    /* textarea */
	    if (pre_mode & RB_INTXTA) {
		feed_textarea(str);
		continue;
	    }
	    /* script */
	    if (pre_mode & RB_SCRIPT)
		continue;
	    /* style */
	    if (pre_mode & RB_STYLE)
		continue;
	}

      proc_normal:
	if (obuf->table_level >= 0 && tbl && tbl_mode) {
	    /* 
	     * within table: in <table>..</table>, all input tokens
	     * are fed to the table renderer, and then the renderer
	     * makes HTML output.
	     */
	    switch (feed_table(tbl, str, tbl_mode, tbl_width, internal)) {
	    case 0:
		/* </table> tag */
		obuf->table_level--;
		if (obuf->table_level >= MAX_TABLE - 1)
		    continue;
		end_table(tbl);
		if (obuf->table_level >= 0) {
		    struct table *tbl0 = tables[obuf->table_level];
		    str = Sprintf(""<table_alt tid=%d>"", tbl0->ntable)->ptr;
		    pushTable(tbl0, tbl);
		    tbl = tbl0;
		    tbl_mode = &table_mode[obuf->table_level];
		    tbl_width = table_width(h_env, obuf->table_level);
		    feed_table(tbl, str, tbl_mode, tbl_width, TRUE);
		    continue;
		    /* continue to the next */
		}
		if (obuf->flag & RB_DEL)
		    continue;
		/* all tables have been read */
		if (tbl->vspace > 0 && !(obuf->flag & RB_IGNORE_P)) {
		    int indent = h_env->envs[h_env->envc].indent;
		    flushline(h_env, obuf, indent, 0, h_env->limit);
		    do_blankline(h_env, obuf, indent, 0, h_env->limit);
		}
		save_fonteffect(h_env, obuf);
		initRenderTable();
		renderTable(tbl, tbl_width, h_env);
		restore_fonteffect(h_env, obuf);
		obuf->flag &= ~RB_IGNORE_P;
		if (tbl->vspace > 0) {
		    int indent = h_env->envs[h_env->envc].indent;
		    do_blankline(h_env, obuf, indent, 0, h_env->limit);
		    obuf->flag |= RB_IGNORE_P;
		}
		set_space_to_prevchar(obuf->prevchar);
		continue;
	    case 1:
		/* <table> tag */
		break;
	    default:
		continue;
	    }
	}

	if (is_tag) {
/*** Beginning of a new tag ***/
	    if ((tag = parse_tag(&str, internal)))
		cmd = tag->tagid;
	    else
		continue;
	    /* process tags */
	    if (HTMLtagproc1(tag, h_env) == 0) {
		/* preserve the tag for second-stage processing */
		if (parsedtag_need_reconstruct(tag))
		    h_env->tagbuf = parsedtag2str(tag);
		push_tag(obuf, h_env->tagbuf->ptr, cmd);
	    }
#ifdef ID_EXT
	    else {
		process_idattr(obuf, cmd, tag);
	    }
#endif				/* ID_EXT */
	    obuf->bp.init_flag = 1;
	    clear_ignore_p_flag(cmd, obuf);
	    if (cmd == HTML_TABLE)
		goto table_start;
	    else
		continue;
	}

	if (obuf->flag & (RB_DEL | RB_S))
	    continue;
	while (*str) {
	    mode = get_mctype(str);
	    delta = get_mcwidth(str);
	    if (obuf->flag & (RB_SPECIAL & ~RB_NOBR)) {
		char ch = *str;
		if (!(obuf->flag & RB_PLAIN) && (*str == '&')) {
		    char *p = str;
		    int ech = getescapechar(&p);
		    if (ech == '\n' || ech == '\r') {
			ch = '\n';
			str = p - 1;
		    }
		    else if (ech == '\t') {
			ch = '\t';
			str = p - 1;
		    }
		}
		if (ch != '\n')
		    obuf->flag &= ~RB_IGNORE_P;
		if (ch == '\n') {
		    str++;
		    if (obuf->flag & RB_IGNORE_P) {
			obuf->flag &= ~RB_IGNORE_P;
			continue;
		    }
		    if (obuf->flag & RB_PRE_INT)
			PUSH(' ');
		    else
			flushline(h_env, obuf, h_env->envs[h_env->envc].indent,
				  1, h_env->limit);
		}
		else if (ch == '\t') {
		    do {
			PUSH(' ');
		    } while ((h_env->envs[h_env->envc].indent + obuf->pos)
			     % Tabstop != 0);
		    str++;
		}
		else if (obuf->flag & RB_PLAIN) {
		    char *p = html_quote_char(*str);
		    if (p) {
			push_charp(obuf, 1, p, PC_ASCII);
			str++;
		    }
		    else {
			proc_mchar(obuf, 1, delta, &str, mode);
		    }
		}
		else {
		    if (*str == '&')
			proc_escape(obuf, &str);
		    else
			proc_mchar(obuf, 1, delta, &str, mode);
		}
		if (obuf->flag & (RB_SPECIAL & ~RB_PRE_INT))
		    continue;
	    }
	    else {
		if (!IS_SPACE(*str))
		    obuf->flag &= ~RB_IGNORE_P;
		if ((mode == PC_ASCII || mode == PC_CTRL) && IS_SPACE(*str)) {
		    if (*obuf->prevchar->ptr != ' ') {
			PUSH(' ');
		    }
		    str++;
		}
		else {
#ifdef USE_M17N
		    if (mode == PC_KANJI1)
			is_hangul = wtf_is_hangul((wc_uchar *) str);
		    else
			is_hangul = 0;
		    if (!SimplePreserveSpace && mode == PC_KANJI1 &&
			!is_hangul && !prev_is_hangul &&
			obuf->pos > h_env->envs[h_env->envc].indent &&
			Strlastchar(obuf->line) == ' ') {
			while (obuf->line->length >= 2 &&
			       !strncmp(obuf->line->ptr + obuf->line->length -
					2, ""  "", 2)
			       && obuf->pos >= h_env->envs[h_env->envc].indent) {
			    Strshrink(obuf->line, 1);
			    obuf->pos--;
			}
			if (obuf->line->length >= 3 &&
			    obuf->prev_ctype == PC_KANJI1 &&
			    Strlastchar(obuf->line) == ' ' &&
			    obuf->pos >= h_env->envs[h_env->envc].indent) {
			    Strshrink(obuf->line, 1);
			    obuf->pos--;
			}
		    }
		    prev_is_hangul = is_hangul;
#endif
		    if (*str == '&')
			proc_escape(obuf, &str);
		    else
			proc_mchar(obuf, obuf->flag & RB_SPECIAL, delta, &str,
				   mode);
		}
	    }
	    if (need_flushline(h_env, obuf, mode)) {
		char *bp = obuf->line->ptr + obuf->bp.len;
		char *tp = bp - obuf->bp.tlen;
		int i = 0;

		if (tp > obuf->line->ptr && tp[-1] == ' ')
		    i = 1;

		indent = h_env->envs[h_env->envc].indent;
		if (obuf->bp.pos - i > indent) {
		    Str line;
		    append_tags(obuf);
		    line = Strnew_charp(bp);
		    Strshrink(obuf->line, obuf->line->length - obuf->bp.len);
#ifdef FORMAT_NICE
		    if (obuf->pos - i > h_env->limit)
			obuf->flag |= RB_FILL;
#endif				/* FORMAT_NICE */
		    back_to_breakpoint(obuf);
		    flushline(h_env, obuf, indent, 0, h_env->limit);
#ifdef FORMAT_NICE
		    obuf->flag &= ~RB_FILL;
#endif				/* FORMAT_NICE */
		    HTMLlineproc1(line->ptr, h_env);
		}
	    }
	}
    }
    if (!(obuf->flag & (RB_SPECIAL | RB_INTXTA | RB_INSELECT))) {
	char *tp;
	int i = 0;

	if (obuf->bp.pos == obuf->pos) {
	    tp = &obuf->line->ptr[obuf->bp.len - obuf->bp.tlen];
	}
	else {
	    tp = &obuf->line->ptr[obuf->line->length];
	}

	if (tp > obuf->line->ptr && tp[-1] == ' ')
	    i = 1;
	indent = h_env->envs[h_env->envc].indent;
	if (obuf->pos - i > h_env->limit) {
#ifdef FORMAT_NICE
	    obuf->flag |= RB_FILL;
#endif				/* FORMAT_NICE */
	    flushline(h_env, obuf, indent, 0, h_env->limit);
#ifdef FORMAT_NICE
	    obuf->flag &= ~RB_FILL;
#endif				/* FORMAT_NICE */
	}
    }
}","void
HTMLlineproc0(char *VAR_0, struct html_feed_environ *VAR_1, int VAR_2)
{
    Lineprop VAR_3;
    int VAR_4;
    struct readbuffer *VAR_5 = VAR_1->obuf;
    int VAR_6, VAR_7;
    struct parsed_tag *VAR_8;
    Str VAR_9;
    struct table *VAR_10 = NULL;
    struct table_mode *VAR_11 = NULL;
    int VAR_12 = 0;
#ifdef VAR_13
    int VAR_14, VAR_15 = 0;
#endif

#ifdef VAR_16
    if (VAR_17) {
	FILE *VAR_18 = fopen(""zzzproc1"", ""a"");
	fprintf(VAR_18, ""%c%c%c%c"",
		(VAR_5->flag & VAR_19) ? 'P' : ' ',
		(VAR_5->table_level >= 0) ? 'T' : ' ',
		(VAR_5->flag & VAR_20) ? 'X' : ' ',
		(VAR_5->flag & (VAR_21 | VAR_22)) ? 'S' : ' ');
	fprintf(VAR_18, ""HTMLlineproc1(\""%s\"",%d,%lx)\n"", VAR_0, VAR_1->limit,
		(unsigned long)VAR_1);
	fclose(VAR_18);
    }
#endif

    VAR_9 = Strnew();

  table_start:
    if (VAR_5->table_level >= 0) {
	int VAR_23 = min(VAR_5->table_level, VAR_24 - 1);
	VAR_10 = VAR_25[VAR_23];
	VAR_11 = &table_mode[VAR_23];
	VAR_12 = table_width(VAR_1, VAR_23);
    }

    while (*VAR_0 != '\0') {
	char *VAR_26, *VAR_27;
	int VAR_28 = FALSE;
	int VAR_29 = (VAR_5->table_level >= 0 && VAR_11) ?
	    VAR_11->pre_mode : VAR_5->flag;
	int VAR_30 = (VAR_5->table_level >= 0 && VAR_11) ?
	    VAR_11->end_tag : VAR_5->end_tag;

	if (*VAR_0 == '<' || VAR_5->status != VAR_31) {
	    /* COMMENT_0 */
                      
        
	    if (VAR_5->status == VAR_32)
		VAR_5->status = VAR_31;
	    else {
		read_token(VAR_1->tagbuf, &VAR_0, &VAR_5->status,
			   VAR_29 & VAR_19, VAR_5->status != VAR_31);
		if (VAR_5->status != VAR_31)
		    return;
	    }
	    if (VAR_1->tagbuf->length == 0)
		continue;
	    VAR_26 = VAR_1->tagbuf->ptr;
	    if (*VAR_26 == '<') {
		if (VAR_26[1] && REALLY_THE_BEGINNING_OF_A_TAG(VAR_26))
		    VAR_28 = TRUE;
		else if (!(VAR_29 & (VAR_33 | VAR_20 | VAR_34 |
				       VAR_21 | VAR_22 | VAR_35))) {
		    VAR_0 = Strnew_m_charp(VAR_26 + 1, VAR_0, NULL)->ptr;
		    VAR_26 = ""&lt;"";
		}
	    }
	}
	else {
	    read_token(VAR_9, &VAR_0, &VAR_5->status, VAR_29 & VAR_19, 0);
	    if (VAR_5->status != VAR_31)	/* COMMENT_3 */
		VAR_5->status = VAR_31;
	    VAR_26 = VAR_9->ptr;
	}

	if (VAR_29 & (VAR_33 | VAR_20 | VAR_34 | VAR_21 |
			VAR_22 | VAR_35)) {
	    if (VAR_28) {
		VAR_27 = VAR_26;
		if ((VAR_8 = parse_tag(&VAR_27, VAR_2))) {
		    if (VAR_8->tagid == VAR_30 ||
			(VAR_29 & VAR_34 && VAR_8->tagid == VAR_36)
			|| (VAR_29 & VAR_35
			    && (VAR_8->tagid == VAR_37
				|| VAR_8->tagid == VAR_38)))
			goto proc_normal;
		}
	    }
	    /* COMMENT_4 */
	    if (VAR_29 & VAR_35) {
		feed_title(VAR_26);
		continue;
	    }
	    /* COMMENT_5 */
	    if (VAR_29 & VAR_34) {
		if (VAR_5->table_level >= 0)
		    goto proc_normal;
		feed_select(VAR_26);
		continue;
	    }
	    if (VAR_28) {
		if (strncmp(VAR_26, ""<!--"", 4) && (VAR_27 = strchr(VAR_26 + 1, '<'))) {
		    VAR_26 = Strnew_charp_n(VAR_26, VAR_27 - VAR_26)->ptr;
		    VAR_0 = Strnew_m_charp(VAR_27, VAR_0, NULL)->ptr;
		}
		VAR_28 = FALSE;
	    }
	    if (VAR_5->table_level >= 0)
		goto proc_normal;
	    /* COMMENT_6 */
	    if (VAR_29 & VAR_20) {
		feed_textarea(VAR_26);
		continue;
	    }
	    /* COMMENT_7 */
	    if (VAR_29 & VAR_21)
		continue;
	    /* COMMENT_8 */
	    if (VAR_29 & VAR_22)
		continue;
	}

      proc_normal:
	if (VAR_5->table_level >= 0 && VAR_10 && VAR_11) {
	    /* COMMENT_9 */
                                                            
                                                            
                          
        
	    switch (feed_table(VAR_10, VAR_26, VAR_11, VAR_12, VAR_2)) {
	    case 0:
		/* COMMENT_14 */
		VAR_5->table_level--;
		if (VAR_5->table_level >= VAR_24 - 1)
		    continue;
		end_table(VAR_10);
		if (VAR_5->table_level >= 0) {
		    struct table *VAR_39 = VAR_25[VAR_5->table_level];
		    VAR_26 = Sprintf(""<table_alt tid=%d>"", VAR_39->ntable)->ptr;
		    pushTable(VAR_39, VAR_10);
		    VAR_10 = VAR_39;
		    VAR_11 = &table_mode[VAR_5->table_level];
		    VAR_12 = table_width(VAR_1, VAR_5->table_level);
		    feed_table(VAR_10, VAR_26, VAR_11, VAR_12, TRUE);
		    continue;
		    /* COMMENT_15 */
		}
		if (VAR_5->flag & VAR_40)
		    continue;
		/* COMMENT_16 */
		if (VAR_10->vspace > 0 && !(VAR_5->flag & VAR_41)) {
		    int VAR_6 = VAR_1->envs[VAR_1->envc].indent;
		    flushline(VAR_1, VAR_5, VAR_6, 0, VAR_1->limit);
		    do_blankline(VAR_1, VAR_5, VAR_6, 0, VAR_1->limit);
		}
		save_fonteffect(VAR_1, VAR_5);
		initRenderTable();
		renderTable(VAR_10, VAR_12, VAR_1);
		restore_fonteffect(VAR_1, VAR_5);
		VAR_5->flag &= ~VAR_41;
		if (VAR_10->vspace > 0) {
		    int VAR_6 = VAR_1->envs[VAR_1->envc].indent;
		    do_blankline(VAR_1, VAR_5, VAR_6, 0, VAR_1->limit);
		    VAR_5->flag |= VAR_41;
		}
		set_space_to_prevchar(VAR_5->prevchar);
		continue;
	    case 1:
		/* COMMENT_17 */
		break;
	    default:
		continue;
	    }
	}

	if (VAR_28) {
/* COMMENT_18 */
	    if ((VAR_8 = parse_tag(&VAR_26, VAR_2)))
		VAR_4 = VAR_8->tagid;
	    else
		continue;
	    /* COMMENT_19 */
	    if (HTMLtagproc1(VAR_8, VAR_1) == 0) {
		/* COMMENT_20 */
		if (parsedtag_need_reconstruct(VAR_8))
		    VAR_1->tagbuf = parsedtag2str(VAR_8);
		push_tag(VAR_5, VAR_1->tagbuf->ptr, VAR_4);
	    }
#ifdef VAR_42
	    else {
		process_idattr(VAR_5, VAR_4, VAR_8);
	    }
#endif				/* COMMENT_21 */
	    VAR_5->bp.init_flag = 1;
	    clear_ignore_p_flag(VAR_4, VAR_5);
	    if (VAR_4 == VAR_43)
		goto table_start;
	    else
		continue;
	}

	if (VAR_5->flag & (VAR_40 | VAR_44))
	    continue;
	while (*VAR_26) {
	    VAR_3 = get_mctype(VAR_26);
	    VAR_7 = get_mcwidth(VAR_26);
	    if (VAR_5->flag & (VAR_45 & ~VAR_46)) {
		char VAR_47 = *VAR_26;
		if (!(VAR_5->flag & VAR_33) && (*VAR_26 == '&')) {
		    char *VAR_27 = VAR_26;
		    int VAR_48 = getescapechar(&VAR_27);
		    if (VAR_48 == '\n' || VAR_48 == '\r') {
			VAR_47 = '\n';
			VAR_26 = VAR_27 - 1;
		    }
		    else if (VAR_48 == '\t') {
			VAR_47 = '\t';
			VAR_26 = VAR_27 - 1;
		    }
		}
		if (VAR_47 != '\n')
		    VAR_5->flag &= ~VAR_41;
		if (VAR_47 == '\n') {
		    VAR_26++;
		    if (VAR_5->flag & VAR_41) {
			VAR_5->flag &= ~VAR_41;
			continue;
		    }
		    if (VAR_5->flag & VAR_49)
			PUSH(' ');
		    else
			flushline(VAR_1, VAR_5, VAR_1->envs[VAR_1->envc].indent,
				  1, VAR_1->limit);
		}
		else if (VAR_47 == '\t') {
		    do {
			PUSH(' ');
		    } while ((VAR_1->envs[VAR_1->envc].indent + VAR_5->pos)
			     % VAR_50 != 0);
		    VAR_26++;
		}
		else if (VAR_5->flag & VAR_33) {
		    char *VAR_27 = html_quote_char(*VAR_26);
		    if (VAR_27) {
			push_charp(VAR_5, 1, VAR_27, VAR_51);
			VAR_26++;
		    }
		    else {
			proc_mchar(VAR_5, 1, VAR_7, &VAR_26, VAR_3);
		    }
		}
		else {
		    if (*VAR_26 == '&')
			proc_escape(VAR_5, &VAR_26);
		    else
			proc_mchar(VAR_5, 1, VAR_7, &VAR_26, VAR_3);
		}
		if (VAR_5->flag & (VAR_45 & ~VAR_49))
		    continue;
	    }
	    else {
		if (!IS_SPACE(*VAR_26))
		    VAR_5->flag &= ~VAR_41;
		if ((VAR_3 == VAR_51 || VAR_3 == VAR_52) && IS_SPACE(*VAR_26)) {
		    if (*VAR_5->prevchar->ptr != ' ') {
			PUSH(' ');
		    }
		    VAR_26++;
		}
		else {
#ifdef VAR_13
		    if (VAR_3 == VAR_53)
			VAR_14 = wtf_is_hangul((wc_uchar *) VAR_26);
		    else
			VAR_14 = 0;
		    if (!VAR_54 && VAR_3 == VAR_53 &&
			!VAR_14 && !VAR_15 &&
			VAR_5->pos > VAR_1->envs[VAR_1->envc].indent &&
			Strlastchar(VAR_5->line) == ' ') {
			while (VAR_5->line->length >= 2 &&
			       !strncmp(VAR_5->line->ptr + VAR_5->line->length -
					2, ""  "", 2)
			       && VAR_5->pos >= VAR_1->envs[VAR_1->envc].indent) {
			    Strshrink(VAR_5->line, 1);
			    VAR_5->pos--;
			}
			if (VAR_5->line->length >= 3 &&
			    VAR_5->prev_ctype == VAR_53 &&
			    Strlastchar(VAR_5->line) == ' ' &&
			    VAR_5->pos >= VAR_1->envs[VAR_1->envc].indent) {
			    Strshrink(VAR_5->line, 1);
			    VAR_5->pos--;
			}
		    }
		    VAR_15 = VAR_14;
#endif
		    if (*VAR_26 == '&')
			proc_escape(VAR_5, &VAR_26);
		    else
			proc_mchar(VAR_5, VAR_5->flag & VAR_45, VAR_7, &VAR_26,
				   VAR_3);
		}
	    }
	    if (need_flushline(VAR_1, VAR_5, VAR_3)) {
		char *VAR_55 = VAR_5->line->ptr + VAR_5->bp.len;
		char *VAR_56 = VAR_55 - VAR_5->bp.tlen;
		int VAR_57 = 0;

		if (VAR_56 > VAR_5->line->ptr && VAR_56[-1] == ' ')
		    VAR_57 = 1;

		VAR_6 = VAR_1->envs[VAR_1->envc].indent;
		if (VAR_5->bp.pos - VAR_57 > VAR_6) {
		    Str VAR_0;
		    append_tags(VAR_5);
		    VAR_0 = Strnew_charp(VAR_55);
		    Strshrink(VAR_5->line, VAR_5->line->length - VAR_5->bp.len);
#ifdef VAR_58
		    if (VAR_5->pos - VAR_57 > VAR_1->limit)
			VAR_5->flag |= VAR_59;
#endif				/* COMMENT_22 */
		    back_to_breakpoint(VAR_5);
		    flushline(VAR_1, VAR_5, VAR_6, 0, VAR_1->limit);
#ifdef VAR_58
		    VAR_5->flag &= ~VAR_59;
#endif				/* COMMENT_22 */
		    HTMLlineproc1(VAR_0->ptr, VAR_1);
		}
	    }
	}
    }
    if (!(VAR_5->flag & (VAR_45 | VAR_20 | VAR_34))) {
	char *VAR_56;
	int VAR_57 = 0;

	if (VAR_5->bp.pos == VAR_5->pos) {
	    VAR_56 = &VAR_5->line->ptr[VAR_5->bp.len - VAR_5->bp.tlen];
	}
	else {
	    VAR_56 = &VAR_5->line->ptr[VAR_5->line->length];
	}

	if (VAR_56 > VAR_5->line->ptr && VAR_56[-1] == ' ')
	    VAR_57 = 1;
	VAR_6 = VAR_1->envs[VAR_1->envc].indent;
	if (VAR_5->pos - VAR_57 > VAR_1->limit) {
#ifdef VAR_58
	    VAR_5->flag |= VAR_59;
#endif				/* COMMENT_22 */
	    flushline(VAR_1, VAR_5, VAR_6, 0, VAR_1->limit);
#ifdef VAR_58
	    VAR_5->flag &= ~VAR_59;
#endif				/* COMMENT_22 */
	}
    }
}",tats/w3m/a8cba1bd912a65ed40acded2bd5013d1f01253e1/file.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -41,10 +41,10 @@
     while (*line != '\0') {
 	char *str, *p;
 	int is_tag = FALSE;
-	int pre_mode = (obuf->table_level >= 0) ? tbl_mode->pre_mode :
-	    obuf->flag;
-	int end_tag = (obuf->table_level >= 0) ? tbl_mode->end_tag :
-	    obuf->end_tag;
+	int pre_mode = (obuf->table_level >= 0 && tbl_mode) ?
+	    tbl_mode->pre_mode : obuf->flag;
+	int end_tag = (obuf->table_level >= 0 && tbl_mode) ?
+	    tbl_mode->end_tag : obuf->end_tag;
 
 	if (*line == '<' || obuf->status != R_ST_NORMAL) {
 	    /* 
@@ -126,7 +126,7 @@
 	}
 
       proc_normal:
-	if (obuf->table_level >= 0) {
+	if (obuf->table_level >= 0 && tbl && tbl_mode) {
 	    /* 
 	     * within table: in <table>..</table>, all input tokens
 	     * are fed to the table renderer, and then the renderer","{'deleted_lines': ['\tint pre_mode = (obuf->table_level >= 0) ? tbl_mode->pre_mode :', '\t    obuf->flag;', '\tint end_tag = (obuf->table_level >= 0) ? tbl_mode->end_tag :', '\t    obuf->end_tag;', '\tif (obuf->table_level >= 0) {'], 'added_lines': ['\tint pre_mode = (obuf->table_level >= 0 && tbl_mode) ?', '\t    tbl_mode->pre_mode : obuf->flag;', '\tint end_tag = (obuf->table_level >= 0 && tbl_mode) ?', '\t    tbl_mode->end_tag : obuf->end_tag;', '\tif (obuf->table_level >= 0 && tbl && tbl_mode) {']}",True,An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-33. w3m allows remote attackers to cause a denial of service (segmentation fault and crash) via a crafted HTML page.,6.5,MEDIUM,1,test,2016-11-17T10:33:09Z,1
CVE-2016-1251,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,perl5-dbi/DBD-mysql,"Fix use-after-free for repeated fetchrow_arrayref calls when mysql_server_prepare=1

Function dbd_st_fetch() via Renew() can reallocate output buffer for
mysql_stmt_fetch() call. But it does not update pointer to that buffer in
imp_sth->stmt structure initialized by mysql_stmt_bind_result() function.
That leads to use-after-free in any mysql function which access
imp_sth->stmt structure (e.g. mysql_stmt_fetch()).

This patch fix this problem and properly updates pointer in imp_sth->stmt
structure after Renew() call.

Test 40server_prepare_crash.t is extended to check for that use-after-free
crash.",3619c170461a3107a258d1fd2d00ed4832adb1b1,https://github.com/perl5-dbi/DBD-mysql/commit/3619c170461a3107a258d1fd2d00ed4832adb1b1,dbdimp.c,dbd_st_fetch,"AV*
dbd_st_fetch(SV *sth, imp_sth_t* imp_sth)
{
dTHX;
int num_fields, ChopBlanks, i, rc;
unsigned long *lengths;
AV *av;
int av_length, av_readonly;
MYSQL_ROW cols;
D_imp_dbh_from_sth;
MYSQL* svsock= imp_dbh->pmysql;
imp_sth_fbh_t *fbh;
D_imp_xxh(sth);
#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION
MYSQL_BIND *buffer;
#endif
MYSQL_FIELD *fields;
if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t-> dbd_st_fetch\n"");
#if MYSQL_ASYNC
if(imp_dbh->async_query_in_flight) {
if(mysql_db_async_result(sth, &imp_sth->result) <= 0) {
return Nullav;
}
}
#endif
#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION
if (imp_sth->use_server_side_prepare)
{
if (!DBIc_ACTIVE(imp_sth) )
{
do_error(sth, JW_ERR_SEQUENCE, ""no statement executing\n"",NULL);
return Nullav;
}
if (imp_sth->fetch_done)
{
do_error(sth, JW_ERR_SEQUENCE, ""fetch() but fetch already done"",NULL);
return Nullav;
}
if (!imp_sth->done_desc)
{
if (!dbd_describe(sth, imp_sth))
{
do_error(sth, JW_ERR_SEQUENCE, ""Error while describe result set."",
NULL);
return Nullav;
}
}
}
#endif
ChopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);
if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
PerlIO_printf(DBIc_LOGPIO(imp_xxh),
""\t\tdbd_st_fetch for %p, chopblanks %d\n"",
sth, ChopBlanks);
if (!imp_sth->result)
{
do_error(sth, JW_ERR_SEQUENCE, ""fetch() without execute()"" ,NULL);
return Nullav;
}
imp_dbh->pmysql->net.last_errno = 0;
#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION
if (imp_sth->use_server_side_prepare)
{
if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t\tdbd_st_fetch calling mysql_fetch\n"");
if ((rc= mysql_stmt_fetch(imp_sth->stmt)))
{
if (rc == 1)
do_error(sth, mysql_stmt_errno(imp_sth->stmt),
mysql_stmt_error(imp_sth->stmt),
mysql_stmt_sqlstate(imp_sth->stmt));
#if MYSQL_VERSION_ID >= MYSQL_VERSION_5_0 
if (rc == MYSQL_DATA_TRUNCATED) {
if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t\tdbd_st_fetch data truncated\n"");
goto process;
}
#endif
if (rc == MYSQL_NO_DATA)
{
imp_sth->row_num= mysql_stmt_affected_rows(imp_sth->stmt);
imp_sth->fetch_done=1;
if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t\tdbd_st_fetch no data\n"");
}
dbd_st_finish(sth, imp_sth);
return Nullav;
}
process:
imp_sth->currow++;
av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);
num_fields=mysql_stmt_field_count(imp_sth->stmt);
if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
PerlIO_printf(DBIc_LOGPIO(imp_xxh),
""\t\tdbd_st_fetch called mysql_fetch, rc %d num_fields %d\n"",
rc, num_fields);
for (
buffer= imp_sth->buffer,
fbh= imp_sth->fbh,
i= 0;
i < num_fields;
i++,
fbh++,
buffer++
)
{
SV *sv= AvARRAY(av)[i]; 
STRLEN len;
if (fbh->is_null)
(void) SvOK_off(sv);  
else
{
if (fbh->length > buffer->buffer_length || fbh->error)
{
if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
PerlIO_printf(DBIc_LOGPIO(imp_xxh),
""\t\tRefetch BLOB/TEXT column: %d, length: %lu, error: %d\n"",
i, fbh->length, fbh->error);
Renew(fbh->data, fbh->length, char);
buffer->buffer_length= fbh->length;
buffer->buffer= (char *) fbh->data;
if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {
int j;
int m = MIN(*buffer->length, buffer->buffer_length);
char *ptr = (char*)buffer->buffer;
PerlIO_printf(DBIc_LOGPIO(imp_xxh),""\t\tbefore buffer->buffer: "");
for (j = 0; j < m; j++) {
PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""%c"", *ptr++);
}
PerlIO_printf(DBIc_LOGPIO(imp_xxh),""\n"");
}
if (mysql_stmt_fetch_column(imp_sth->stmt, buffer , i, 0))
do_error(sth, mysql_stmt_errno(imp_sth->stmt),
mysql_stmt_error(imp_sth->stmt),
mysql_stmt_sqlstate(imp_sth->stmt));
if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {
int j;
int m = MIN(*buffer->length, buffer->buffer_length);
char *ptr = (char*)buffer->buffer;
PerlIO_printf(DBIc_LOGPIO(imp_xxh),""\t\tafter buffer->buffer: "");
for (j = 0; j < m; j++) {
PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""%c"", *ptr++);
}
PerlIO_printf(DBIc_LOGPIO(imp_xxh),""\n"");
}
}
switch (buffer->buffer_type) {
case MYSQL_TYPE_DOUBLE:
if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t\tst_fetch double data %f\n"", fbh->ddata);
sv_setnv(sv, fbh->ddata);
break;
case MYSQL_TYPE_LONG:
case MYSQL_TYPE_LONGLONG:
if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t\tst_fetch int data %""IVdf"", unsigned? %d\n"",
fbh->ldata, buffer->is_unsigned);
if (buffer->is_unsigned)
sv_setuv(sv, fbh->ldata);
else
sv_setiv(sv, fbh->ldata);
break;
case MYSQL_TYPE_BIT:
sv_setpvn(sv, fbh->data, fbh->length);
break;
default:
if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t\tERROR IN st_fetch_string"");
len= fbh->length;
if (ChopBlanks)
{
if (fbh->charsetnr != 63)
while (len && fbh->data[len-1] == ' ') { --len; }
}
sv_setpvn(sv, fbh->data, len);
#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION
#if MYSQL_VERSION_ID >= FIELD_CHARSETNR_VERSION 
if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fbh->charsetnr != 63)
#else
if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && !(fbh->flags & BINARY_FLAG))
#endif
sv_utf8_decode(sv);
#endif
break;
}
}
}
if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t<- dbd_st_fetch, %d cols\n"", num_fields);
return av;
}
else
{
#endif
imp_sth->currow++;
if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
{
PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\tdbd_st_fetch result set details\n"");
PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\timp_sth->result=%p\n"", imp_sth->result);
PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\tmysql_num_fields=%u\n"",
mysql_num_fields(imp_sth->result));
PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\tmysql_num_rows=%llu\n"",
mysql_num_rows(imp_sth->result));
PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\tmysql_affected_rows=%llu\n"",
mysql_affected_rows(imp_dbh->pmysql));
PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\tdbd_st_fetch for %p, currow= %d\n"",
sth,imp_sth->currow);
}
if (!(cols= mysql_fetch_row(imp_sth->result)))
{
if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
{
PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\tdbd_st_fetch, no more rows to fetch"");
}
if (mysql_errno(imp_dbh->pmysql))
do_error(sth, mysql_errno(imp_dbh->pmysql),
mysql_error(imp_dbh->pmysql),
mysql_sqlstate(imp_dbh->pmysql));
#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION
if (!mysql_more_results(svsock))
#endif
dbd_st_finish(sth, imp_sth);
return Nullav;
}
num_fields= mysql_num_fields(imp_sth->result);
fields= mysql_fetch_fields(imp_sth->result);
lengths= mysql_fetch_lengths(imp_sth->result);
if ((av= DBIc_FIELDS_AV(imp_sth)) != Nullav)
{
av_length= av_len(av)+1;
if (av_length != num_fields)              
{
if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t<- dbd_st_fetch, size of results array(%d) != num_fields(%d)\n"",
av_length, num_fields);
if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t<- dbd_st_fetch, result fields(%d)\n"",
DBIc_NUM_FIELDS(imp_sth));
av_readonly = SvREADONLY(av);
if (av_readonly)
SvREADONLY_off( av );              
while (av_length < num_fields)
{
av_store(av, av_length++, newSV(0));
}
while (av_length > num_fields)
{
SvREFCNT_dec(av_pop(av));
av_length--;
}
if (av_readonly)
SvREADONLY_on(av);
}
}
av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);
for (i= 0;  i < num_fields; ++i)
{
char *col= cols[i];
SV *sv= AvARRAY(av)[i]; 
if (col)
{
STRLEN len= lengths[i];
if (ChopBlanks)
{
while (len && col[len-1] == ' ')
{--len; }
}
sv_setpvn(sv, col, len);
switch (mysql_to_perl_type(fields[i].type)) {
case MYSQL_TYPE_DOUBLE:
(void) SvNV(sv);
SvNOK_only(sv);
break;
case MYSQL_TYPE_LONG:
case MYSQL_TYPE_LONGLONG:
if (fields[i].flags & UNSIGNED_FLAG)
{
(void) SvUV(sv);
SvIOK_only_UV(sv);
}
else
{
(void) SvIV(sv);
SvIOK_only(sv);
}
break;
#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION
case MYSQL_TYPE_BIT:
break;
#endif
default:
#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION
break;
}
}
else
(void) SvOK_off(sv);  
}
if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t<- dbd_st_fetch, %d cols\n"", num_fields);
return av;
#if MYSQL_VERSION_ID  >= SERVER_PREPARE_VERSION
}
#endif
}","AV*
dbd_st_fetch(SV *VAR_0, imp_sth_t* VAR_1)
{
VAR_2;
int VAR_3, VAR_4, VAR_5, VAR_6;
unsigned long *VAR_7;
AV *VAR_8;
int VAR_9, VAR_10;
MYSQL_ROW VAR_11;
VAR_12;
MYSQL* VAR_13= VAR_14->pmysql;
imp_sth_fbh_t *VAR_15;
D_imp_xxh(VAR_0);
#if VAR_16 >=VAR_17
MYSQL_BIND *VAR_18;
#endif
MYSQL_FIELD *VAR_19;
if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t-> dbd_st_fetch\n"");
#if VAR_21
if(VAR_14->async_query_in_flight) {
if(mysql_db_async_result(VAR_0, &VAR_1->result) <= 0) {
return VAR_22;
}
}
#endif
#if VAR_16 >=VAR_17
if (VAR_1->use_server_side_prepare)
{
if (!DBIc_ACTIVE(VAR_1) )
{
do_error(VAR_0, VAR_23, ""no statement executing\n"",NULL);
return VAR_22;
}
if (VAR_1->fetch_done)
{
do_error(VAR_0, VAR_23, ""fetch() but fetch already done"",NULL);
return VAR_22;
}
if (!VAR_1->done_desc)
{
if (!dbd_describe(VAR_0, VAR_1))
{
do_error(VAR_0, VAR_23, ""Error while describe result set."",
NULL);
return VAR_22;
}
}
}
#endif
VAR_4 = DBIc_is(VAR_1, VAR_24);
if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
PerlIO_printf(DBIc_LOGPIO(VAR_20),
""\t\tdbd_st_fetch for %p, chopblanks %d\n"",
VAR_0, VAR_4);
if (!VAR_1->result)
{
do_error(VAR_0, VAR_23, ""fetch() without execute()"" ,NULL);
return VAR_22;
}
VAR_14->pmysql->net.last_errno = 0;
#if VAR_16 >=VAR_17
if (VAR_1->use_server_side_prepare)
{
if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t\tdbd_st_fetch calling mysql_fetch\n"");
if ((VAR_6= mysql_stmt_fetch(VAR_1->stmt)))
{
if (VAR_6 == 1)
do_error(VAR_0, mysql_stmt_errno(VAR_1->stmt),
mysql_stmt_error(VAR_1->stmt),
mysql_stmt_sqlstate(VAR_1->stmt));
#if VAR_16 >= VAR_25 
if (VAR_6 == VAR_26) {
if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t\tdbd_st_fetch data truncated\n"");
goto process;
}
#endif
if (VAR_6 == VAR_27)
{
VAR_1->row_num= mysql_stmt_affected_rows(VAR_1->stmt);
VAR_1->fetch_done=1;
if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t\tdbd_st_fetch no data\n"");
}
dbd_st_finish(VAR_0, VAR_1);
return VAR_22;
}
process:
VAR_1->currow++;
VAR_8= DBIc_DBISTATE(VAR_1)->get_fbav(VAR_1);
VAR_3=mysql_stmt_field_count(VAR_1->stmt);
if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
PerlIO_printf(DBIc_LOGPIO(VAR_20),
""\t\tdbd_st_fetch called mysql_fetch, rc %d num_fields %d\n"",
VAR_6, VAR_3);
for (
VAR_18= VAR_1->buffer,
VAR_15= VAR_1->fbh,
VAR_5= 0;
VAR_5 < VAR_3;
VAR_5++,
VAR_15++,
VAR_18++
)
{
SV *VAR_28= AvARRAY(VAR_8)[VAR_5]; 
STRLEN VAR_29;
if (VAR_15->is_null)
(void) SvOK_off(VAR_28);  
else
{
if (VAR_15->length > VAR_18->buffer_length || VAR_15->error)
{
if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
PerlIO_printf(DBIc_LOGPIO(VAR_20),
""\t\tRefetch BLOB/TEXT column: %d, length: %lu, error: %d\n"",
VAR_5, VAR_15->length, VAR_15->error);
Renew(VAR_15->data, VAR_15->length, VAR_30);
VAR_18->buffer_length= VAR_15->length;
VAR_18->buffer= (char *) VAR_15->data;
if (DBIc_TRACE_LEVEL(VAR_20) >= 2) {
int VAR_31;
int VAR_32 = MIN(*VAR_18->length, VAR_18->buffer_length);
char *VAR_33 = (char*)VAR_18->buffer;
PerlIO_printf(DBIc_LOGPIO(VAR_20),""\t\tbefore buffer->buffer: "");
for (VAR_31 = 0; VAR_31 < VAR_32; VAR_31++) {
PerlIO_printf(DBIc_LOGPIO(VAR_20), ""%c"", *VAR_33++);
}
PerlIO_printf(DBIc_LOGPIO(VAR_20),""\n"");
}
if (mysql_stmt_fetch_column(VAR_1->stmt, VAR_18 , VAR_5, 0))
do_error(VAR_0, mysql_stmt_errno(VAR_1->stmt),
mysql_stmt_error(VAR_1->stmt),
mysql_stmt_sqlstate(VAR_1->stmt));
if (DBIc_TRACE_LEVEL(VAR_20) >= 2) {
int VAR_31;
int VAR_32 = MIN(*VAR_18->length, VAR_18->buffer_length);
char *VAR_33 = (char*)VAR_18->buffer;
PerlIO_printf(DBIc_LOGPIO(VAR_20),""\t\tafter buffer->buffer: "");
for (VAR_31 = 0; VAR_31 < VAR_32; VAR_31++) {
PerlIO_printf(DBIc_LOGPIO(VAR_20), ""%c"", *VAR_33++);
}
PerlIO_printf(DBIc_LOGPIO(VAR_20),""\n"");
}
}
switch (VAR_18->buffer_type) {
case VAR_34:
if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t\tst_fetch double data %f\n"", VAR_15->ddata);
sv_setnv(VAR_28, VAR_15->ddata);
break;
case VAR_35:
case VAR_36:
if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t\tst_fetch int data %""VAR_37"", unsigned? %d\n"",
VAR_15->ldata, VAR_18->is_unsigned);
if (VAR_18->is_unsigned)
sv_setuv(VAR_28, VAR_15->ldata);
else
sv_setiv(VAR_28, VAR_15->ldata);
break;
case VAR_38:
sv_setpvn(VAR_28, VAR_15->data, VAR_15->length);
break;
default:
if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t\tERROR IN st_fetch_string"");
VAR_29= VAR_15->length;
if (VAR_4)
{
if (VAR_15->charsetnr != 63)
while (VAR_29 && VAR_15->data[VAR_29-1] == ' ') { --VAR_29; }
}
sv_setpvn(VAR_28, VAR_15->data, VAR_29);
#if defined(VAR_39) && VAR_16 >=VAR_17
#if VAR_16 >= VAR_40 
if ((VAR_14->enable_utf8 || VAR_14->enable_utf8mb4) && VAR_15->charsetnr != 63)
#else
if ((VAR_14->enable_utf8 || VAR_14->enable_utf8mb4) && !(VAR_15->flags & VAR_41))
#endif
VAR_39(VAR_28);
#endif
break;
}
}
}
if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t<- dbd_st_fetch, %d cols\n"", VAR_3);
return VAR_8;
}
else
{
#endif
imp_sth->currow++;
if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
{
PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\tdbd_st_fetch result set details\n"");
PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\timp_sth->result=%p\n"", VAR_1->result);
PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\tmysql_num_fields=%u\n"",
mysql_num_fields(VAR_1->result));
PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\tmysql_num_rows=%llu\n"",
mysql_num_rows(VAR_1->result));
PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\tmysql_affected_rows=%llu\n"",
mysql_affected_rows(VAR_14->pmysql));
PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\tdbd_st_fetch for %p, currow= %d\n"",
VAR_0,VAR_1->currow);
}
if (!(VAR_11= mysql_fetch_row(VAR_1->result)))
{
if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
{
PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\tdbd_st_fetch, no more rows to fetch"");
}
if (mysql_errno(VAR_14->pmysql))
do_error(VAR_0, mysql_errno(VAR_14->pmysql),
mysql_error(VAR_14->pmysql),
mysql_sqlstate(VAR_14->pmysql));
#if VAR_16 >= VAR_42
if (!mysql_more_results(VAR_13))
#endif
dbd_st_finish(VAR_0, VAR_1);
return VAR_22;
}
VAR_3= mysql_num_fields(VAR_1->result);
VAR_19= mysql_fetch_fields(VAR_1->result);
VAR_7= mysql_fetch_lengths(VAR_1->result);
if ((VAR_8= DBIc_FIELDS_AV(VAR_1)) != VAR_22)
{
VAR_9= av_len(VAR_8)+1;
if (VAR_9 != VAR_3)              
{
if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t<- dbd_st_fetch, size of results array(%d) != num_fields(%d)\n"",
VAR_9, VAR_3);
if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t<- dbd_st_fetch, result fields(%d)\n"",
DBIc_NUM_FIELDS(VAR_1));
VAR_10 = SvREADONLY(VAR_8);
if (VAR_10)
SvREADONLY_off( VAR_8 );              
while (VAR_9 < VAR_3)
{
av_store(VAR_8, VAR_9++, newSV(0));
}
while (VAR_9 > VAR_3)
{
SvREFCNT_dec(av_pop(VAR_8));
VAR_9--;
}
if (VAR_10)
SvREADONLY_on(VAR_8);
}
}
VAR_8= DBIc_DBISTATE(VAR_1)->get_fbav(VAR_1);
for (VAR_5= 0;  VAR_5 < VAR_3; ++VAR_5)
{
char *VAR_43= VAR_11[VAR_5];
SV *VAR_28= AvARRAY(VAR_8)[VAR_5]; 
if (VAR_43)
{
STRLEN VAR_29= VAR_7[VAR_5];
if (VAR_4)
{
while (VAR_29 && VAR_43[VAR_29-1] == ' ')
{--VAR_29; }
}
sv_setpvn(VAR_28, VAR_43, VAR_29);
switch (mysql_to_perl_type(VAR_19[VAR_5].type)) {
case VAR_34:
(void) SvNV(VAR_28);
SvNOK_only(VAR_28);
break;
case VAR_35:
case VAR_36:
if (VAR_19[VAR_5].flags & VAR_44)
{
(void) SvUV(VAR_28);
SvIOK_only_UV(VAR_28);
}
else
{
(void) SvIV(VAR_28);
SvIOK_only(VAR_28);
}
break;
#if VAR_16 > VAR_45
case VAR_38:
break;
#endif
default:
#if defined(VAR_39) && VAR_16 >=VAR_17
if ((VAR_14->enable_utf8 || VAR_14->enable_utf8mb4) && VAR_19[VAR_5].charsetnr != 63)
VAR_39(VAR_28);
#endif
break;
}
}
else
(void) SvOK_off(VAR_28);  
}
if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t<- dbd_st_fetch, %d cols\n"", VAR_3);
return VAR_8;
#if VAR_16  >= VAR_17
}
#endif
}",perl5-dbi/DBD-mysql/3619c170461a3107a258d1fd2d00ed4832adb1b1/dbdimp.c/vul/before/0.json,"AV*
dbd_st_fetch(SV *sth, imp_sth_t* imp_sth)
{
  dTHX;
  int num_fields, ChopBlanks, i, rc;
  unsigned long *lengths;
  AV *av;
  int av_length, av_readonly;
  MYSQL_ROW cols;
  D_imp_dbh_from_sth;
  MYSQL* svsock= imp_dbh->pmysql;
  imp_sth_fbh_t *fbh;
  D_imp_xxh(sth);
#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION
  MYSQL_BIND *buffer;
#endif
  MYSQL_FIELD *fields;
  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t-> dbd_st_fetch\n"");

#if MYSQL_ASYNC
  if(imp_dbh->async_query_in_flight) {
      if(mysql_db_async_result(sth, &imp_sth->result) <= 0) {
        return Nullav;
      }
  }
#endif

#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION
  if (imp_sth->use_server_side_prepare)
  {
    if (!DBIc_ACTIVE(imp_sth) )
    {
      do_error(sth, JW_ERR_SEQUENCE, ""no statement executing\n"",NULL);
      return Nullav;
    }

    if (imp_sth->fetch_done)
    {
      do_error(sth, JW_ERR_SEQUENCE, ""fetch() but fetch already done"",NULL);
      return Nullav;
    }

    if (!imp_sth->done_desc)
    {
      if (!dbd_describe(sth, imp_sth))
      {
        do_error(sth, JW_ERR_SEQUENCE, ""Error while describe result set."",
                 NULL);
        return Nullav;
      }
    }
  }
#endif

  ChopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);

  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                  ""\t\tdbd_st_fetch for %p, chopblanks %d\n"",
                  sth, ChopBlanks);

  if (!imp_sth->result)
  {
    do_error(sth, JW_ERR_SEQUENCE, ""fetch() without execute()"" ,NULL);
    return Nullav;
  }

  /* fix from 2.9008 */
  imp_dbh->pmysql->net.last_errno = 0;

#if MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION
  if (imp_sth->use_server_side_prepare)
  {
    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t\tdbd_st_fetch calling mysql_fetch\n"");

    if ((rc= mysql_stmt_fetch(imp_sth->stmt)))
    {
      if (rc == 1)
        do_error(sth, mysql_stmt_errno(imp_sth->stmt),
                 mysql_stmt_error(imp_sth->stmt),
                mysql_stmt_sqlstate(imp_sth->stmt));

#if MYSQL_VERSION_ID >= MYSQL_VERSION_5_0 
      if (rc == MYSQL_DATA_TRUNCATED) {
        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
          PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t\tdbd_st_fetch data truncated\n"");
        goto process;
      }
#endif

      if (rc == MYSQL_NO_DATA)
      {
        /* Update row_num to affected_rows value */
        imp_sth->row_num= mysql_stmt_affected_rows(imp_sth->stmt);
        imp_sth->fetch_done=1;
        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
          PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t\tdbd_st_fetch no data\n"");
      }

      dbd_st_finish(sth, imp_sth);

      return Nullav;
    }

process:
    imp_sth->currow++;

    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);
    num_fields=mysql_stmt_field_count(imp_sth->stmt);
    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
      PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                    ""\t\tdbd_st_fetch called mysql_fetch, rc %d num_fields %d\n"",
                    rc, num_fields);

    for (
         buffer= imp_sth->buffer,
         fbh= imp_sth->fbh,
         i= 0;
         i < num_fields;
         i++,
         fbh++,
         buffer++
        )
    {
      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV	*/
      STRLEN len;

      /* This is wrong, null is not being set correctly
       * This is not the way to determine length (this would break blobs!)
       */
      if (fbh->is_null)
        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */
      else
      {
        /* In case of BLOB/TEXT fields we allocate only 8192 bytes
           in dbd_describe() for data. Here we know real size of field
           so we should increase buffer size and refetch column value
        */
        if (fbh->length > buffer->buffer_length || fbh->error)
        {
          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
            PerlIO_printf(DBIc_LOGPIO(imp_xxh),
              ""\t\tRefetch BLOB/TEXT column: %d, length: %lu, error: %d\n"",
              i, fbh->length, fbh->error);

          Renew(fbh->data, fbh->length, char);
          buffer->buffer_length= fbh->length;
          buffer->buffer= (char *) fbh->data;
          imp_sth->stmt->bind[i].buffer_length = fbh->length;
          imp_sth->stmt->bind[i].buffer = (char *)fbh->data;

          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {
            int j;
            int m = MIN(*buffer->length, buffer->buffer_length);
            char *ptr = (char*)buffer->buffer;
            PerlIO_printf(DBIc_LOGPIO(imp_xxh),""\t\tbefore buffer->buffer: "");
            for (j = 0; j < m; j++) {
              PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""%c"", *ptr++);
            }
            PerlIO_printf(DBIc_LOGPIO(imp_xxh),""\n"");
          }

          /*TODO: Use offset instead of 0 to fetch only remain part of data*/
          if (mysql_stmt_fetch_column(imp_sth->stmt, buffer , i, 0))
            do_error(sth, mysql_stmt_errno(imp_sth->stmt),
                     mysql_stmt_error(imp_sth->stmt),
                     mysql_stmt_sqlstate(imp_sth->stmt));

          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {
            int j;
            int m = MIN(*buffer->length, buffer->buffer_length);
            char *ptr = (char*)buffer->buffer;
            PerlIO_printf(DBIc_LOGPIO(imp_xxh),""\t\tafter buffer->buffer: "");
            for (j = 0; j < m; j++) {
              PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""%c"", *ptr++);
            }
            PerlIO_printf(DBIc_LOGPIO(imp_xxh),""\n"");
          }
        }

        /* This does look a lot like Georg's PHP driver doesn't it?  --Brian */
        /* Credit due to Georg - mysqli_api.c  ;) --PMG */
        switch (buffer->buffer_type) {
        case MYSQL_TYPE_DOUBLE:
          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
            PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t\tst_fetch double data %f\n"", fbh->ddata);
          sv_setnv(sv, fbh->ddata);
          break;

        case MYSQL_TYPE_LONG:
        case MYSQL_TYPE_LONGLONG:
          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
            PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t\tst_fetch int data %""IVdf"", unsigned? %d\n"",
                          fbh->ldata, buffer->is_unsigned);
          if (buffer->is_unsigned)
            sv_setuv(sv, fbh->ldata);
          else
            sv_setiv(sv, fbh->ldata);

          break;

        case MYSQL_TYPE_BIT:
          sv_setpvn(sv, fbh->data, fbh->length);

          break;

        default:
          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
            PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t\tERROR IN st_fetch_string"");
          len= fbh->length;
	  /* ChopBlanks server-side prepared statement */
          if (ChopBlanks)
          {
            /* 
              see bottom of:
              http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html
            */
            if (fbh->charsetnr != 63)
              while (len && fbh->data[len-1] == ' ') { --len; }
          }
	  /* END OF ChopBlanks */

          sv_setpvn(sv, fbh->data, len);

	/* UTF8 */
        /*HELMUT*/
#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION

#if MYSQL_VERSION_ID >= FIELD_CHARSETNR_VERSION 
  /* SHOW COLLATION WHERE Id = 63; -- 63 == charset binary, collation binary */
        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fbh->charsetnr != 63)
#else
	if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && !(fbh->flags & BINARY_FLAG))
#endif
	  sv_utf8_decode(sv);
#endif
	/* END OF UTF8 */
          break;

        }

      }
    }

    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t<- dbd_st_fetch, %d cols\n"", num_fields);

    return av;
  }
  else
  {
#endif

    imp_sth->currow++;

    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    {
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\tdbd_st_fetch result set details\n"");
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\timp_sth->result=%p\n"", imp_sth->result);
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\tmysql_num_fields=%u\n"",
                    mysql_num_fields(imp_sth->result));
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\tmysql_num_rows=%llu\n"",
                    mysql_num_rows(imp_sth->result));
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\tmysql_affected_rows=%llu\n"",
                    mysql_affected_rows(imp_dbh->pmysql));
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\tdbd_st_fetch for %p, currow= %d\n"",
                    sth,imp_sth->currow);
    }

    if (!(cols= mysql_fetch_row(imp_sth->result)))
    {
      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
      {
        PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\tdbd_st_fetch, no more rows to fetch"");
      }
      if (mysql_errno(imp_dbh->pmysql))
        do_error(sth, mysql_errno(imp_dbh->pmysql),
                 mysql_error(imp_dbh->pmysql),
                 mysql_sqlstate(imp_dbh->pmysql));


#if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION
      if (!mysql_more_results(svsock))
#endif
        dbd_st_finish(sth, imp_sth);
      return Nullav;
    }

    num_fields= mysql_num_fields(imp_sth->result);
    fields= mysql_fetch_fields(imp_sth->result);
    lengths= mysql_fetch_lengths(imp_sth->result);

    if ((av= DBIc_FIELDS_AV(imp_sth)) != Nullav)
    {
      av_length= av_len(av)+1;

      if (av_length != num_fields)              /* Resize array if necessary */
      {
        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
          PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t<- dbd_st_fetch, size of results array(%d) != num_fields(%d)\n"",
                                   av_length, num_fields);

        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
          PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t<- dbd_st_fetch, result fields(%d)\n"",
                                   DBIc_NUM_FIELDS(imp_sth));

        av_readonly = SvREADONLY(av);

        if (av_readonly)
          SvREADONLY_off( av );              /* DBI sets this readonly */

        while (av_length < num_fields)
        {
          av_store(av, av_length++, newSV(0));
        }

        while (av_length > num_fields)
        {
          SvREFCNT_dec(av_pop(av));
          av_length--;
        }
        if (av_readonly)
          SvREADONLY_on(av);
      }
    }

    av= DBIc_DBISTATE(imp_sth)->get_fbav(imp_sth);

    for (i= 0;  i < num_fields; ++i)
    {
      char *col= cols[i];
      SV *sv= AvARRAY(av)[i]; /* Note: we (re)use the SV in the AV	*/

      if (col)
      {
        STRLEN len= lengths[i];
        if (ChopBlanks)
        {
          while (len && col[len-1] == ' ')
          {	--len; }
        }

        /* Set string value returned from mysql server */
        sv_setpvn(sv, col, len);

        switch (mysql_to_perl_type(fields[i].type)) {
        case MYSQL_TYPE_DOUBLE:
          /* Coerce to dobule and set scalar as NV */
          (void) SvNV(sv);
          SvNOK_only(sv);
          break;

        case MYSQL_TYPE_LONG:
        case MYSQL_TYPE_LONGLONG:
          /* Coerce to integer and set scalar as UV resp. IV */
          if (fields[i].flags & UNSIGNED_FLAG)
          {
            (void) SvUV(sv);
            SvIOK_only_UV(sv);
          }
          else
          {
            (void) SvIV(sv);
            SvIOK_only(sv);
          }
          break;

#if MYSQL_VERSION_ID > NEW_DATATYPE_VERSION
        case MYSQL_TYPE_BIT:
          /* Let it as binary string */
          break;
#endif

        default:
	/* UTF8 */
        /*HELMUT*/
#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION

  /* see bottom of: http://www.mysql.org/doc/refman/5.0/en/c-api-datatypes.html */
        if ((imp_dbh->enable_utf8 || imp_dbh->enable_utf8mb4) && fields[i].charsetnr != 63)
	  sv_utf8_decode(sv);
#endif
	/* END OF UTF8 */
          break;
        }
      }
      else
        (void) SvOK_off(sv);  /*  Field is NULL, return undef  */
    }

    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
      PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""\t<- dbd_st_fetch, %d cols\n"", num_fields);
    return av;

#if MYSQL_VERSION_ID  >= SERVER_PREPARE_VERSION
  }
#endif

}","AV*
dbd_st_fetch(SV *VAR_0, imp_sth_t* VAR_1)
{
  VAR_2;
  int VAR_3, VAR_4, VAR_5, VAR_6;
  unsigned long *VAR_7;
  AV *VAR_8;
  int VAR_9, VAR_10;
  MYSQL_ROW VAR_11;
  VAR_12;
  MYSQL* VAR_13= VAR_14->pmysql;
  imp_sth_fbh_t *VAR_15;
  D_imp_xxh(VAR_0);
#if VAR_16 >=VAR_17
  MYSQL_BIND *VAR_18;
#endif
  MYSQL_FIELD *VAR_19;
  if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
    PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t-> dbd_st_fetch\n"");

#if VAR_21
  if(VAR_14->async_query_in_flight) {
      if(mysql_db_async_result(VAR_0, &VAR_1->result) <= 0) {
        return VAR_22;
      }
  }
#endif

#if VAR_16 >=VAR_17
  if (VAR_1->use_server_side_prepare)
  {
    if (!DBIc_ACTIVE(VAR_1) )
    {
      do_error(VAR_0, VAR_23, ""no statement executing\n"",NULL);
      return VAR_22;
    }

    if (VAR_1->fetch_done)
    {
      do_error(VAR_0, VAR_23, ""fetch() but fetch already done"",NULL);
      return VAR_22;
    }

    if (!VAR_1->done_desc)
    {
      if (!dbd_describe(VAR_0, VAR_1))
      {
        do_error(VAR_0, VAR_23, ""Error while describe result set."",
                 NULL);
        return VAR_22;
      }
    }
  }
#endif

  VAR_4 = DBIc_is(VAR_1, VAR_24);

  if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
    PerlIO_printf(DBIc_LOGPIO(VAR_20),
                  ""\t\tdbd_st_fetch for %p, chopblanks %d\n"",
                  VAR_0, VAR_4);

  if (!VAR_1->result)
  {
    do_error(VAR_0, VAR_23, ""fetch() without execute()"" ,NULL);
    return VAR_22;
  }

  /* COMMENT_0 */
  VAR_14->pmysql->net.last_errno = 0;

#if VAR_16 >=VAR_17
  if (VAR_1->use_server_side_prepare)
  {
    if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
      PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t\tdbd_st_fetch calling mysql_fetch\n"");

    if ((VAR_6= mysql_stmt_fetch(VAR_1->stmt)))
    {
      if (VAR_6 == 1)
        do_error(VAR_0, mysql_stmt_errno(VAR_1->stmt),
                 mysql_stmt_error(VAR_1->stmt),
                mysql_stmt_sqlstate(VAR_1->stmt));

#if VAR_16 >= VAR_25 
      if (VAR_6 == VAR_26) {
        if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
          PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t\tdbd_st_fetch data truncated\n"");
        goto process;
      }
#endif

      if (VAR_6 == VAR_27)
      {
        /* COMMENT_1 */
        VAR_1->row_num= mysql_stmt_affected_rows(VAR_1->stmt);
        VAR_1->fetch_done=1;
        if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
          PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t\tdbd_st_fetch no data\n"");
      }

      dbd_st_finish(VAR_0, VAR_1);

      return VAR_22;
    }

process:
    VAR_1->currow++;

    VAR_8= DBIc_DBISTATE(VAR_1)->get_fbav(VAR_1);
    VAR_3=mysql_stmt_field_count(VAR_1->stmt);
    if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
      PerlIO_printf(DBIc_LOGPIO(VAR_20),
                    ""\t\tdbd_st_fetch called mysql_fetch, rc %d num_fields %d\n"",
                    VAR_6, VAR_3);

    for (
         VAR_18= VAR_1->buffer,
         VAR_15= VAR_1->fbh,
         VAR_5= 0;
         VAR_5 < VAR_3;
         VAR_5++,
         VAR_15++,
         VAR_18++
        )
    {
      SV *VAR_28= AvARRAY(VAR_8)[VAR_5]; /* COMMENT_2 */
      STRLEN VAR_29;

      /* COMMENT_3 */
                                                                          
         
      if (VAR_15->is_null)
        (void) SvOK_off(VAR_28);  /* COMMENT_6 */
      else
      {
        /* COMMENT_7 */
                                                                      
                                                                     
          
        if (VAR_15->length > VAR_18->buffer_length || VAR_15->error)
        {
          if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
            PerlIO_printf(DBIc_LOGPIO(VAR_20),
              ""\t\tRefetch BLOB/TEXT column: %d, length: %lu, error: %d\n"",
              VAR_5, VAR_15->length, VAR_15->error);

          Renew(VAR_15->data, VAR_15->length, VAR_30);
          VAR_18->buffer_length= VAR_15->length;
          VAR_18->buffer= (char *) VAR_15->data;
          VAR_1->stmt->bind[VAR_5].buffer_length = VAR_15->length;
          VAR_1->stmt->bind[VAR_5].buffer = (char *)VAR_15->data;

          if (DBIc_TRACE_LEVEL(VAR_20) >= 2) {
            int VAR_31;
            int VAR_32 = MIN(*VAR_18->length, VAR_18->buffer_length);
            char *VAR_33 = (char*)VAR_18->buffer;
            PerlIO_printf(DBIc_LOGPIO(VAR_20),""\t\tbefore buffer->buffer: "");
            for (VAR_31 = 0; VAR_31 < VAR_32; VAR_31++) {
              PerlIO_printf(DBIc_LOGPIO(VAR_20), ""%c"", *VAR_33++);
            }
            PerlIO_printf(DBIc_LOGPIO(VAR_20),""\n"");
          }

          /* COMMENT_11 */
          if (mysql_stmt_fetch_column(VAR_1->stmt, VAR_18 , VAR_5, 0))
            do_error(VAR_0, mysql_stmt_errno(VAR_1->stmt),
                     mysql_stmt_error(VAR_1->stmt),
                     mysql_stmt_sqlstate(VAR_1->stmt));

          if (DBIc_TRACE_LEVEL(VAR_20) >= 2) {
            int VAR_31;
            int VAR_32 = MIN(*VAR_18->length, VAR_18->buffer_length);
            char *VAR_33 = (char*)VAR_18->buffer;
            PerlIO_printf(DBIc_LOGPIO(VAR_20),""\t\tafter buffer->buffer: "");
            for (VAR_31 = 0; VAR_31 < VAR_32; VAR_31++) {
              PerlIO_printf(DBIc_LOGPIO(VAR_20), ""%c"", *VAR_33++);
            }
            PerlIO_printf(DBIc_LOGPIO(VAR_20),""\n"");
          }
        }

        /* COMMENT_12 */
        /* COMMENT_13 */
        switch (VAR_18->buffer_type) {
        case VAR_34:
          if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
            PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t\tst_fetch double data %f\n"", VAR_15->ddata);
          sv_setnv(VAR_28, VAR_15->ddata);
          break;

        case VAR_35:
        case VAR_36:
          if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
            PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t\tst_fetch int data %""VAR_37"", unsigned? %d\n"",
                          VAR_15->ldata, VAR_18->is_unsigned);
          if (VAR_18->is_unsigned)
            sv_setuv(VAR_28, VAR_15->ldata);
          else
            sv_setiv(VAR_28, VAR_15->ldata);

          break;

        case VAR_38:
          sv_setpvn(VAR_28, VAR_15->data, VAR_15->length);

          break;

        default:
          if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
            PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t\tERROR IN st_fetch_string"");
          VAR_29= VAR_15->length;
	  /* COMMENT_14 */
          if (VAR_4)
          {
            /* COMMENT_15 */
                            
                                                                         
              
            if (VAR_15->charsetnr != 63)
              while (VAR_29 && VAR_15->data[VAR_29-1] == ' ') { --VAR_29; }
          }
	  /* COMMENT_19 */

          sv_setpvn(VAR_28, VAR_15->data, VAR_29);

	/* COMMENT_20 */
        /* COMMENT_21 */
#if defined(VAR_39) && VAR_16 >=VAR_17

#if VAR_16 >= VAR_40 
  /* COMMENT_22 */
        if ((VAR_14->enable_utf8 || VAR_14->enable_utf8mb4) && VAR_15->charsetnr != 63)
#else
	if ((VAR_14->enable_utf8 || VAR_14->enable_utf8mb4) && !(VAR_15->flags & VAR_41))
#endif
	  VAR_39(VAR_28);
#endif
	/* COMMENT_23 */
          break;

        }

      }
    }

    if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
      PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t<- dbd_st_fetch, %d cols\n"", VAR_3);

    return VAR_8;
  }
  else
  {
#endif

    imp_sth->currow++;

    if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
    {
      PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\tdbd_st_fetch result set details\n"");
      PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\timp_sth->result=%p\n"", VAR_1->result);
      PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\tmysql_num_fields=%u\n"",
                    mysql_num_fields(VAR_1->result));
      PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\tmysql_num_rows=%llu\n"",
                    mysql_num_rows(VAR_1->result));
      PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\tmysql_affected_rows=%llu\n"",
                    mysql_affected_rows(VAR_14->pmysql));
      PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\tdbd_st_fetch for %p, currow= %d\n"",
                    VAR_0,VAR_1->currow);
    }

    if (!(VAR_11= mysql_fetch_row(VAR_1->result)))
    {
      if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
      {
        PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\tdbd_st_fetch, no more rows to fetch"");
      }
      if (mysql_errno(VAR_14->pmysql))
        do_error(VAR_0, mysql_errno(VAR_14->pmysql),
                 mysql_error(VAR_14->pmysql),
                 mysql_sqlstate(VAR_14->pmysql));


#if VAR_16 >= VAR_42
      if (!mysql_more_results(VAR_13))
#endif
        dbd_st_finish(VAR_0, VAR_1);
      return VAR_22;
    }

    VAR_3= mysql_num_fields(VAR_1->result);
    VAR_19= mysql_fetch_fields(VAR_1->result);
    VAR_7= mysql_fetch_lengths(VAR_1->result);

    if ((VAR_8= DBIc_FIELDS_AV(VAR_1)) != VAR_22)
    {
      VAR_9= av_len(VAR_8)+1;

      if (VAR_9 != VAR_3)              /* COMMENT_24 */
      {
        if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
          PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t<- dbd_st_fetch, size of results array(%d) != num_fields(%d)\n"",
                                   VAR_9, VAR_3);

        if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
          PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t<- dbd_st_fetch, result fields(%d)\n"",
                                   DBIc_NUM_FIELDS(VAR_1));

        VAR_10 = SvREADONLY(VAR_8);

        if (VAR_10)
          SvREADONLY_off( VAR_8 );              /* COMMENT_25 */

        while (VAR_9 < VAR_3)
        {
          av_store(VAR_8, VAR_9++, newSV(0));
        }

        while (VAR_9 > VAR_3)
        {
          SvREFCNT_dec(av_pop(VAR_8));
          VAR_9--;
        }
        if (VAR_10)
          SvREADONLY_on(VAR_8);
      }
    }

    VAR_8= DBIc_DBISTATE(VAR_1)->get_fbav(VAR_1);

    for (VAR_5= 0;  VAR_5 < VAR_3; ++VAR_5)
    {
      char *VAR_43= VAR_11[VAR_5];
      SV *VAR_28= AvARRAY(VAR_8)[VAR_5]; /* COMMENT_2 */

      if (VAR_43)
      {
        STRLEN VAR_29= VAR_7[VAR_5];
        if (VAR_4)
        {
          while (VAR_29 && VAR_43[VAR_29-1] == ' ')
          {	--VAR_29; }
        }

        /* COMMENT_26 */
        sv_setpvn(VAR_28, VAR_43, VAR_29);

        switch (mysql_to_perl_type(VAR_19[VAR_5].type)) {
        case VAR_34:
          /* COMMENT_27 */
          (void) SvNV(VAR_28);
          SvNOK_only(VAR_28);
          break;

        case VAR_35:
        case VAR_36:
          /* COMMENT_28 */
          if (VAR_19[VAR_5].flags & VAR_44)
          {
            (void) SvUV(VAR_28);
            SvIOK_only_UV(VAR_28);
          }
          else
          {
            (void) SvIV(VAR_28);
            SvIOK_only(VAR_28);
          }
          break;

#if VAR_16 > VAR_45
        case VAR_38:
          /* COMMENT_29 */
          break;
#endif

        default:
	/* COMMENT_20 */
        /* COMMENT_21 */
#if defined(VAR_39) && VAR_16 >=VAR_17

  /* COMMENT_30 */
        if ((VAR_14->enable_utf8 || VAR_14->enable_utf8mb4) && VAR_19[VAR_5].charsetnr != 63)
	  VAR_39(VAR_28);
#endif
	/* COMMENT_23 */
          break;
        }
      }
      else
        (void) SvOK_off(VAR_28);  /* COMMENT_6 */
    }

    if (DBIc_TRACE_LEVEL(VAR_20) >= 2)
      PerlIO_printf(DBIc_LOGPIO(VAR_20), ""\t<- dbd_st_fetch, %d cols\n"", VAR_3);
    return VAR_8;

#if VAR_16  >= VAR_17
  }
#endif

}",perl5-dbi/DBD-mysql/3619c170461a3107a258d1fd2d00ed4832adb1b1/dbdimp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -148,6 +148,8 @@
           Renew(fbh->data, fbh->length, char);
           buffer->buffer_length= fbh->length;
           buffer->buffer= (char *) fbh->data;
+          imp_sth->stmt->bind[i].buffer_length = fbh->length;
+          imp_sth->stmt->bind[i].buffer = (char *)fbh->data;
 
           if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {
             int j;","{'deleted_lines': [], 'added_lines': ['          imp_sth->stmt->bind[i].buffer_length = fbh->length;', '          imp_sth->stmt->bind[i].buffer = (char *)fbh->data;']}",True,There is a vulnerability of type use-after-free affecting DBD::mysql (aka DBD-mysql or the Database Interface (DBI) MySQL driver for Perl) 3.x and 4.x before 4.041 when used with mysql_server_prepare=1.,8.1,HIGH,2,test,2016-11-18T18:01:48Z,1
CVE-2016-10200,"['CWE-362', 'CWE-264', 'CWE-416']",AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"l2tp: fix racy SOCK_ZAPPED flag check in l2tp_ip{,6}_bind()

Lock socket before checking the SOCK_ZAPPED flag in l2tp_ip6_bind().
Without lock, a concurrent call could modify the socket flags between
the sock_flag(sk, SOCK_ZAPPED) test and the lock_sock() call. This way,
a socket could be inserted twice in l2tp_ip6_bind_table. Releasing it
would then leave a stale pointer there, generating use-after-free
errors when walking through the list or modifying adjacent entries.

BUG: KASAN: use-after-free in l2tp_ip6_close+0x22e/0x290 at addr ffff8800081b0ed8
Write of size 8 by task syz-executor/10987
CPU: 0 PID: 10987 Comm: syz-executor Not tainted 4.8.0+ #39
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.8.2-0-g33fbe13 by qemu-project.org 04/01/2014
 ffff880031d97838 ffffffff829f835b ffff88001b5a1640 ffff8800081b0ec0
 ffff8800081b15a0 ffff8800081b6d20 ffff880031d97860 ffffffff8174d3cc
 ffff880031d978f0 ffff8800081b0e80 ffff88001b5a1640 ffff880031d978e0
Call Trace:
 [<ffffffff829f835b>] dump_stack+0xb3/0x118 lib/dump_stack.c:15
 [<ffffffff8174d3cc>] kasan_object_err+0x1c/0x70 mm/kasan/report.c:156
 [<     inline     >] print_address_description mm/kasan/report.c:194
 [<ffffffff8174d666>] kasan_report_error+0x1f6/0x4d0 mm/kasan/report.c:283
 [<     inline     >] kasan_report mm/kasan/report.c:303
 [<ffffffff8174db7e>] __asan_report_store8_noabort+0x3e/0x40 mm/kasan/report.c:329
 [<     inline     >] __write_once_size ./include/linux/compiler.h:249
 [<     inline     >] __hlist_del ./include/linux/list.h:622
 [<     inline     >] hlist_del_init ./include/linux/list.h:637
 [<ffffffff8579047e>] l2tp_ip6_close+0x22e/0x290 net/l2tp/l2tp_ip6.c:239
 [<ffffffff850b2dfd>] inet_release+0xed/0x1c0 net/ipv4/af_inet.c:415
 [<ffffffff851dc5a0>] inet6_release+0x50/0x70 net/ipv6/af_inet6.c:422
 [<ffffffff84c4581d>] sock_release+0x8d/0x1d0 net/socket.c:570
 [<ffffffff84c45976>] sock_close+0x16/0x20 net/socket.c:1017
 [<ffffffff817a108c>] __fput+0x28c/0x780 fs/file_table.c:208
 [<ffffffff817a1605>] ____fput+0x15/0x20 fs/file_table.c:244
 [<ffffffff813774f9>] task_work_run+0xf9/0x170
 [<ffffffff81324aae>] do_exit+0x85e/0x2a00
 [<ffffffff81326dc8>] do_group_exit+0x108/0x330
 [<ffffffff81348cf7>] get_signal+0x617/0x17a0 kernel/signal.c:2307
 [<ffffffff811b49af>] do_signal+0x7f/0x18f0
 [<ffffffff810039bf>] exit_to_usermode_loop+0xbf/0x150 arch/x86/entry/common.c:156
 [<     inline     >] prepare_exit_to_usermode arch/x86/entry/common.c:190
 [<ffffffff81006060>] syscall_return_slowpath+0x1a0/0x1e0 arch/x86/entry/common.c:259
 [<ffffffff85e4d726>] entry_SYSCALL_64_fastpath+0xc4/0xc6
Object at ffff8800081b0ec0, in cache L2TP/IPv6 size: 1448
Allocated:
PID = 10987
 [ 1116.897025] [<ffffffff811ddcb6>] save_stack_trace+0x16/0x20
 [ 1116.897025] [<ffffffff8174c736>] save_stack+0x46/0xd0
 [ 1116.897025] [<ffffffff8174c9ad>] kasan_kmalloc+0xad/0xe0
 [ 1116.897025] [<ffffffff8174cee2>] kasan_slab_alloc+0x12/0x20
 [ 1116.897025] [<     inline     >] slab_post_alloc_hook mm/slab.h:417
 [ 1116.897025] [<     inline     >] slab_alloc_node mm/slub.c:2708
 [ 1116.897025] [<     inline     >] slab_alloc mm/slub.c:2716
 [ 1116.897025] [<ffffffff817476a8>] kmem_cache_alloc+0xc8/0x2b0 mm/slub.c:2721
 [ 1116.897025] [<ffffffff84c4f6a9>] sk_prot_alloc+0x69/0x2b0 net/core/sock.c:1326
 [ 1116.897025] [<ffffffff84c58ac8>] sk_alloc+0x38/0xae0 net/core/sock.c:1388
 [ 1116.897025] [<ffffffff851ddf67>] inet6_create+0x2d7/0x1000 net/ipv6/af_inet6.c:182
 [ 1116.897025] [<ffffffff84c4af7b>] __sock_create+0x37b/0x640 net/socket.c:1153
 [ 1116.897025] [<     inline     >] sock_create net/socket.c:1193
 [ 1116.897025] [<     inline     >] SYSC_socket net/socket.c:1223
 [ 1116.897025] [<ffffffff84c4b46f>] SyS_socket+0xef/0x1b0 net/socket.c:1203
 [ 1116.897025] [<ffffffff85e4d685>] entry_SYSCALL_64_fastpath+0x23/0xc6
Freed:
PID = 10987
 [ 1116.897025] [<ffffffff811ddcb6>] save_stack_trace+0x16/0x20
 [ 1116.897025] [<ffffffff8174c736>] save_stack+0x46/0xd0
 [ 1116.897025] [<ffffffff8174cf61>] kasan_slab_free+0x71/0xb0
 [ 1116.897025] [<     inline     >] slab_free_hook mm/slub.c:1352
 [ 1116.897025] [<     inline     >] slab_free_freelist_hook mm/slub.c:1374
 [ 1116.897025] [<     inline     >] slab_free mm/slub.c:2951
 [ 1116.897025] [<ffffffff81748b28>] kmem_cache_free+0xc8/0x330 mm/slub.c:2973
 [ 1116.897025] [<     inline     >] sk_prot_free net/core/sock.c:1369
 [ 1116.897025] [<ffffffff84c541eb>] __sk_destruct+0x32b/0x4f0 net/core/sock.c:1444
 [ 1116.897025] [<ffffffff84c5aca4>] sk_destruct+0x44/0x80 net/core/sock.c:1452
 [ 1116.897025] [<ffffffff84c5ad33>] __sk_free+0x53/0x220 net/core/sock.c:1460
 [ 1116.897025] [<ffffffff84c5af23>] sk_free+0x23/0x30 net/core/sock.c:1471
 [ 1116.897025] [<ffffffff84c5cb6c>] sk_common_release+0x28c/0x3e0 ./include/net/sock.h:1589
 [ 1116.897025] [<ffffffff8579044e>] l2tp_ip6_close+0x1fe/0x290 net/l2tp/l2tp_ip6.c:243
 [ 1116.897025] [<ffffffff850b2dfd>] inet_release+0xed/0x1c0 net/ipv4/af_inet.c:415
 [ 1116.897025] [<ffffffff851dc5a0>] inet6_release+0x50/0x70 net/ipv6/af_inet6.c:422
 [ 1116.897025] [<ffffffff84c4581d>] sock_release+0x8d/0x1d0 net/socket.c:570
 [ 1116.897025] [<ffffffff84c45976>] sock_close+0x16/0x20 net/socket.c:1017
 [ 1116.897025] [<ffffffff817a108c>] __fput+0x28c/0x780 fs/file_table.c:208
 [ 1116.897025] [<ffffffff817a1605>] ____fput+0x15/0x20 fs/file_table.c:244
 [ 1116.897025] [<ffffffff813774f9>] task_work_run+0xf9/0x170
 [ 1116.897025] [<ffffffff81324aae>] do_exit+0x85e/0x2a00
 [ 1116.897025] [<ffffffff81326dc8>] do_group_exit+0x108/0x330
 [ 1116.897025] [<ffffffff81348cf7>] get_signal+0x617/0x17a0 kernel/signal.c:2307
 [ 1116.897025] [<ffffffff811b49af>] do_signal+0x7f/0x18f0
 [ 1116.897025] [<ffffffff810039bf>] exit_to_usermode_loop+0xbf/0x150 arch/x86/entry/common.c:156
 [ 1116.897025] [<     inline     >] prepare_exit_to_usermode arch/x86/entry/common.c:190
 [ 1116.897025] [<ffffffff81006060>] syscall_return_slowpath+0x1a0/0x1e0 arch/x86/entry/common.c:259
 [ 1116.897025] [<ffffffff85e4d726>] entry_SYSCALL_64_fastpath+0xc4/0xc6
Memory state around the buggy address:
 ffff8800081b0d80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
 ffff8800081b0e00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
>ffff8800081b0e80: fc fc fc fc fc fc fc fc fb fb fb fb fb fb fb fb
                                                    ^
 ffff8800081b0f00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff8800081b0f80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb

==================================================================

The same issue exists with l2tp_ip_bind() and l2tp_ip_bind_table.

Fixes: c51ce49735c1 (""l2tp: fix oops in L2TP IP sockets for connect() AF_UNSPEC case"")
Reported-by: Baozeng Ding <sploving1@gmail.com>
Reported-by: Andrey Konovalov <andreyknvl@google.com>
Tested-by: Baozeng Ding <sploving1@gmail.com>
Signed-off-by: Guillaume Nault <g.nault@alphalink.fr>
Signed-off-by: David S. Miller <davem@davemloft.net>",32c231164b762dddefa13af5a0101032c70b50ef,https://github.com/torvalds/linux/commit/32c231164b762dddefa13af5a0101032c70b50ef,net/l2tp/l2tp_ip.c,l2tp_ip_bind,"static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
struct inet_sock *inet = inet_sk(sk);
struct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;
struct net *net = sock_net(sk);
int ret;
int chk_addr_ret;
if (!sock_flag(sk, SOCK_ZAPPED))
return -EINVAL;
if (addr_len < sizeof(struct sockaddr_l2tpip))
return -EINVAL;
if (addr->l2tp_family != AF_INET)
return -EINVAL;
ret = -EADDRINUSE;
read_lock_bh(&l2tp_ip_lock);
if (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,
sk->sk_bound_dev_if, addr->l2tp_conn_id))
goto out_in_use;
read_unlock_bh(&l2tp_ip_lock);
lock_sock(sk);
if (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))
goto out;
chk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);
ret = -EADDRNOTAVAIL;
if (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&
chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)
goto out;
if (addr->l2tp_addr.s_addr)
inet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;
if (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)
inet->inet_saddr = 0;  
sk_dst_reset(sk);
l2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;
write_lock_bh(&l2tp_ip_lock);
sk_add_bind_node(sk, &l2tp_ip_bind_table);
sk_del_node_init(sk);
write_unlock_bh(&l2tp_ip_lock);
ret = 0;
sock_reset_flag(sk, SOCK_ZAPPED);
out:
release_sock(sk);
return ret;
out_in_use:
read_unlock_bh(&l2tp_ip_lock);
return ret;
}","static int l2tp_ip_bind(struct sock *VAR_0, struct sockaddr *VAR_1, int VAR_2)
{
struct inet_sock *VAR_3 = inet_sk(VAR_0);
struct sockaddr_l2tpip *VAR_4 = (struct sockaddr_l2tpip *) VAR_1;
struct net *net = sock_net(VAR_0);
int VAR_5;
int VAR_6;
if (!sock_flag(VAR_0, VAR_7))
return -VAR_8;
if (VAR_2 < sizeof(struct sockaddr_l2tpip))
return -VAR_8;
if (VAR_4->l2tp_family != VAR_9)
return -VAR_8;
VAR_5 = -VAR_10;
read_lock_bh(&VAR_11);
if (__l2tp_ip_bind_lookup(net, VAR_4->l2tp_addr.s_addr,
VAR_0->sk_bound_dev_if, VAR_4->l2tp_conn_id))
goto out_in_use;
read_unlock_bh(&VAR_11);
lock_sock(VAR_0);
if (VAR_0->sk_state != VAR_12 || VAR_2 < sizeof(struct sockaddr_l2tpip))
goto out;
VAR_6 = inet_addr_type(net, VAR_4->l2tp_addr.s_addr);
VAR_5 = -VAR_13;
if (VAR_4->l2tp_addr.s_addr && VAR_6 != VAR_14 &&
VAR_6 != VAR_15 && VAR_6 != VAR_16)
goto out;
if (VAR_4->l2tp_addr.s_addr)
VAR_3->inet_rcv_saddr = VAR_3->inet_saddr = VAR_4->l2tp_addr.s_addr;
if (VAR_6 == VAR_15 || VAR_6 == VAR_16)
VAR_3->inet_saddr = 0;  
sk_dst_reset(VAR_0);
l2tp_ip_sk(VAR_0)->conn_id = VAR_4->l2tp_conn_id;
write_lock_bh(&VAR_11);
sk_add_bind_node(VAR_0, &VAR_17);
sk_del_node_init(VAR_0);
write_unlock_bh(&VAR_11);
VAR_5 = 0;
sock_reset_flag(VAR_0, VAR_7);
out:
release_sock(VAR_0);
return VAR_5;
out_in_use:
read_unlock_bh(&VAR_11);
return VAR_5;
}",torvalds/linux/32c231164b762dddefa13af5a0101032c70b50ef/l2tp_ip.c/vul/before/0.json,"static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;
	struct net *net = sock_net(sk);
	int ret;
	int chk_addr_ret;

	if (addr_len < sizeof(struct sockaddr_l2tpip))
		return -EINVAL;
	if (addr->l2tp_family != AF_INET)
		return -EINVAL;

	ret = -EADDRINUSE;
	read_lock_bh(&l2tp_ip_lock);
	if (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,
				  sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;

	read_unlock_bh(&l2tp_ip_lock);

	lock_sock(sk);
	if (!sock_flag(sk, SOCK_ZAPPED))
		goto out;

	if (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))
		goto out;

	chk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);
	ret = -EADDRNOTAVAIL;
	if (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&
	    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)
		goto out;

	if (addr->l2tp_addr.s_addr)
		inet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;
	if (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)
		inet->inet_saddr = 0;  /* Use device */
	sk_dst_reset(sk);

	l2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip_lock);
	sk_add_bind_node(sk, &l2tp_ip_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip_lock);
	ret = 0;
	sock_reset_flag(sk, SOCK_ZAPPED);

out:
	release_sock(sk);

	return ret;

out_in_use:
	read_unlock_bh(&l2tp_ip_lock);

	return ret;
}","static int l2tp_ip_bind(struct sock *VAR_0, struct sockaddr *VAR_1, int VAR_2)
{
	struct inet_sock *VAR_3 = inet_sk(VAR_0);
	struct sockaddr_l2tpip *VAR_4 = (struct sockaddr_l2tpip *) VAR_1;
	struct net *net = sock_net(VAR_0);
	int VAR_5;
	int VAR_6;

	if (VAR_2 < sizeof(struct sockaddr_l2tpip))
		return -VAR_7;
	if (VAR_4->l2tp_family != VAR_8)
		return -VAR_7;

	VAR_5 = -VAR_9;
	read_lock_bh(&VAR_10);
	if (__l2tp_ip_bind_lookup(net, VAR_4->l2tp_addr.s_addr,
				  VAR_0->sk_bound_dev_if, VAR_4->l2tp_conn_id))
		goto out_in_use;

	read_unlock_bh(&VAR_10);

	lock_sock(VAR_0);
	if (!sock_flag(VAR_0, VAR_11))
		goto out;

	if (VAR_0->sk_state != VAR_12 || VAR_2 < sizeof(struct sockaddr_l2tpip))
		goto out;

	VAR_6 = inet_addr_type(net, VAR_4->l2tp_addr.s_addr);
	VAR_5 = -VAR_13;
	if (VAR_4->l2tp_addr.s_addr && VAR_6 != VAR_14 &&
	    VAR_6 != VAR_15 && VAR_6 != VAR_16)
		goto out;

	if (VAR_4->l2tp_addr.s_addr)
		VAR_3->inet_rcv_saddr = VAR_3->inet_saddr = VAR_4->l2tp_addr.s_addr;
	if (VAR_6 == VAR_15 || VAR_6 == VAR_16)
		VAR_3->inet_saddr = 0;  /* COMMENT_0 */
	sk_dst_reset(VAR_0);

	l2tp_ip_sk(VAR_0)->conn_id = VAR_4->l2tp_conn_id;

	write_lock_bh(&VAR_10);
	sk_add_bind_node(VAR_0, &VAR_17);
	sk_del_node_init(VAR_0);
	write_unlock_bh(&VAR_10);
	VAR_5 = 0;
	sock_reset_flag(VAR_0, VAR_11);

out:
	release_sock(VAR_0);

	return VAR_5;

out_in_use:
	read_unlock_bh(&VAR_10);

	return VAR_5;
}",torvalds/linux/32c231164b762dddefa13af5a0101032c70b50ef/l2tp_ip.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,8 +6,6 @@
 	int ret;
 	int chk_addr_ret;
 
-	if (!sock_flag(sk, SOCK_ZAPPED))
-		return -EINVAL;
 	if (addr_len < sizeof(struct sockaddr_l2tpip))
 		return -EINVAL;
 	if (addr->l2tp_family != AF_INET)
@@ -22,6 +20,9 @@
 	read_unlock_bh(&l2tp_ip_lock);
 
 	lock_sock(sk);
+	if (!sock_flag(sk, SOCK_ZAPPED))
+		goto out;
+
 	if (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))
 		goto out;
 ","{'deleted_lines': ['\tif (!sock_flag(sk, SOCK_ZAPPED))', '\t\treturn -EINVAL;'], 'added_lines': ['\tif (!sock_flag(sk, SOCK_ZAPPED))', '\t\tgoto out;', '']}",True,"Race condition in the L2TPv3 IP Encapsulation feature in the Linux kernel before 4.8.14 allows local users to gain privileges or cause a denial of service (use-after-free) by making multiple bind system calls without properly ascertaining whether a socket has the SOCK_ZAPPED status, related to net/l2tp/l2tp_ip.c and net/l2tp/l2tp_ip6.c.",7.0,HIGH,2,test,2016-11-18T21:13:00Z,1
CVE-2016-10200,"['CWE-362', 'CWE-264', 'CWE-416']",AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"l2tp: fix racy SOCK_ZAPPED flag check in l2tp_ip{,6}_bind()

Lock socket before checking the SOCK_ZAPPED flag in l2tp_ip6_bind().
Without lock, a concurrent call could modify the socket flags between
the sock_flag(sk, SOCK_ZAPPED) test and the lock_sock() call. This way,
a socket could be inserted twice in l2tp_ip6_bind_table. Releasing it
would then leave a stale pointer there, generating use-after-free
errors when walking through the list or modifying adjacent entries.

BUG: KASAN: use-after-free in l2tp_ip6_close+0x22e/0x290 at addr ffff8800081b0ed8
Write of size 8 by task syz-executor/10987
CPU: 0 PID: 10987 Comm: syz-executor Not tainted 4.8.0+ #39
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.8.2-0-g33fbe13 by qemu-project.org 04/01/2014
 ffff880031d97838 ffffffff829f835b ffff88001b5a1640 ffff8800081b0ec0
 ffff8800081b15a0 ffff8800081b6d20 ffff880031d97860 ffffffff8174d3cc
 ffff880031d978f0 ffff8800081b0e80 ffff88001b5a1640 ffff880031d978e0
Call Trace:
 [<ffffffff829f835b>] dump_stack+0xb3/0x118 lib/dump_stack.c:15
 [<ffffffff8174d3cc>] kasan_object_err+0x1c/0x70 mm/kasan/report.c:156
 [<     inline     >] print_address_description mm/kasan/report.c:194
 [<ffffffff8174d666>] kasan_report_error+0x1f6/0x4d0 mm/kasan/report.c:283
 [<     inline     >] kasan_report mm/kasan/report.c:303
 [<ffffffff8174db7e>] __asan_report_store8_noabort+0x3e/0x40 mm/kasan/report.c:329
 [<     inline     >] __write_once_size ./include/linux/compiler.h:249
 [<     inline     >] __hlist_del ./include/linux/list.h:622
 [<     inline     >] hlist_del_init ./include/linux/list.h:637
 [<ffffffff8579047e>] l2tp_ip6_close+0x22e/0x290 net/l2tp/l2tp_ip6.c:239
 [<ffffffff850b2dfd>] inet_release+0xed/0x1c0 net/ipv4/af_inet.c:415
 [<ffffffff851dc5a0>] inet6_release+0x50/0x70 net/ipv6/af_inet6.c:422
 [<ffffffff84c4581d>] sock_release+0x8d/0x1d0 net/socket.c:570
 [<ffffffff84c45976>] sock_close+0x16/0x20 net/socket.c:1017
 [<ffffffff817a108c>] __fput+0x28c/0x780 fs/file_table.c:208
 [<ffffffff817a1605>] ____fput+0x15/0x20 fs/file_table.c:244
 [<ffffffff813774f9>] task_work_run+0xf9/0x170
 [<ffffffff81324aae>] do_exit+0x85e/0x2a00
 [<ffffffff81326dc8>] do_group_exit+0x108/0x330
 [<ffffffff81348cf7>] get_signal+0x617/0x17a0 kernel/signal.c:2307
 [<ffffffff811b49af>] do_signal+0x7f/0x18f0
 [<ffffffff810039bf>] exit_to_usermode_loop+0xbf/0x150 arch/x86/entry/common.c:156
 [<     inline     >] prepare_exit_to_usermode arch/x86/entry/common.c:190
 [<ffffffff81006060>] syscall_return_slowpath+0x1a0/0x1e0 arch/x86/entry/common.c:259
 [<ffffffff85e4d726>] entry_SYSCALL_64_fastpath+0xc4/0xc6
Object at ffff8800081b0ec0, in cache L2TP/IPv6 size: 1448
Allocated:
PID = 10987
 [ 1116.897025] [<ffffffff811ddcb6>] save_stack_trace+0x16/0x20
 [ 1116.897025] [<ffffffff8174c736>] save_stack+0x46/0xd0
 [ 1116.897025] [<ffffffff8174c9ad>] kasan_kmalloc+0xad/0xe0
 [ 1116.897025] [<ffffffff8174cee2>] kasan_slab_alloc+0x12/0x20
 [ 1116.897025] [<     inline     >] slab_post_alloc_hook mm/slab.h:417
 [ 1116.897025] [<     inline     >] slab_alloc_node mm/slub.c:2708
 [ 1116.897025] [<     inline     >] slab_alloc mm/slub.c:2716
 [ 1116.897025] [<ffffffff817476a8>] kmem_cache_alloc+0xc8/0x2b0 mm/slub.c:2721
 [ 1116.897025] [<ffffffff84c4f6a9>] sk_prot_alloc+0x69/0x2b0 net/core/sock.c:1326
 [ 1116.897025] [<ffffffff84c58ac8>] sk_alloc+0x38/0xae0 net/core/sock.c:1388
 [ 1116.897025] [<ffffffff851ddf67>] inet6_create+0x2d7/0x1000 net/ipv6/af_inet6.c:182
 [ 1116.897025] [<ffffffff84c4af7b>] __sock_create+0x37b/0x640 net/socket.c:1153
 [ 1116.897025] [<     inline     >] sock_create net/socket.c:1193
 [ 1116.897025] [<     inline     >] SYSC_socket net/socket.c:1223
 [ 1116.897025] [<ffffffff84c4b46f>] SyS_socket+0xef/0x1b0 net/socket.c:1203
 [ 1116.897025] [<ffffffff85e4d685>] entry_SYSCALL_64_fastpath+0x23/0xc6
Freed:
PID = 10987
 [ 1116.897025] [<ffffffff811ddcb6>] save_stack_trace+0x16/0x20
 [ 1116.897025] [<ffffffff8174c736>] save_stack+0x46/0xd0
 [ 1116.897025] [<ffffffff8174cf61>] kasan_slab_free+0x71/0xb0
 [ 1116.897025] [<     inline     >] slab_free_hook mm/slub.c:1352
 [ 1116.897025] [<     inline     >] slab_free_freelist_hook mm/slub.c:1374
 [ 1116.897025] [<     inline     >] slab_free mm/slub.c:2951
 [ 1116.897025] [<ffffffff81748b28>] kmem_cache_free+0xc8/0x330 mm/slub.c:2973
 [ 1116.897025] [<     inline     >] sk_prot_free net/core/sock.c:1369
 [ 1116.897025] [<ffffffff84c541eb>] __sk_destruct+0x32b/0x4f0 net/core/sock.c:1444
 [ 1116.897025] [<ffffffff84c5aca4>] sk_destruct+0x44/0x80 net/core/sock.c:1452
 [ 1116.897025] [<ffffffff84c5ad33>] __sk_free+0x53/0x220 net/core/sock.c:1460
 [ 1116.897025] [<ffffffff84c5af23>] sk_free+0x23/0x30 net/core/sock.c:1471
 [ 1116.897025] [<ffffffff84c5cb6c>] sk_common_release+0x28c/0x3e0 ./include/net/sock.h:1589
 [ 1116.897025] [<ffffffff8579044e>] l2tp_ip6_close+0x1fe/0x290 net/l2tp/l2tp_ip6.c:243
 [ 1116.897025] [<ffffffff850b2dfd>] inet_release+0xed/0x1c0 net/ipv4/af_inet.c:415
 [ 1116.897025] [<ffffffff851dc5a0>] inet6_release+0x50/0x70 net/ipv6/af_inet6.c:422
 [ 1116.897025] [<ffffffff84c4581d>] sock_release+0x8d/0x1d0 net/socket.c:570
 [ 1116.897025] [<ffffffff84c45976>] sock_close+0x16/0x20 net/socket.c:1017
 [ 1116.897025] [<ffffffff817a108c>] __fput+0x28c/0x780 fs/file_table.c:208
 [ 1116.897025] [<ffffffff817a1605>] ____fput+0x15/0x20 fs/file_table.c:244
 [ 1116.897025] [<ffffffff813774f9>] task_work_run+0xf9/0x170
 [ 1116.897025] [<ffffffff81324aae>] do_exit+0x85e/0x2a00
 [ 1116.897025] [<ffffffff81326dc8>] do_group_exit+0x108/0x330
 [ 1116.897025] [<ffffffff81348cf7>] get_signal+0x617/0x17a0 kernel/signal.c:2307
 [ 1116.897025] [<ffffffff811b49af>] do_signal+0x7f/0x18f0
 [ 1116.897025] [<ffffffff810039bf>] exit_to_usermode_loop+0xbf/0x150 arch/x86/entry/common.c:156
 [ 1116.897025] [<     inline     >] prepare_exit_to_usermode arch/x86/entry/common.c:190
 [ 1116.897025] [<ffffffff81006060>] syscall_return_slowpath+0x1a0/0x1e0 arch/x86/entry/common.c:259
 [ 1116.897025] [<ffffffff85e4d726>] entry_SYSCALL_64_fastpath+0xc4/0xc6
Memory state around the buggy address:
 ffff8800081b0d80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
 ffff8800081b0e00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
>ffff8800081b0e80: fc fc fc fc fc fc fc fc fb fb fb fb fb fb fb fb
                                                    ^
 ffff8800081b0f00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff8800081b0f80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb

==================================================================

The same issue exists with l2tp_ip_bind() and l2tp_ip_bind_table.

Fixes: c51ce49735c1 (""l2tp: fix oops in L2TP IP sockets for connect() AF_UNSPEC case"")
Reported-by: Baozeng Ding <sploving1@gmail.com>
Reported-by: Andrey Konovalov <andreyknvl@google.com>
Tested-by: Baozeng Ding <sploving1@gmail.com>
Signed-off-by: Guillaume Nault <g.nault@alphalink.fr>
Signed-off-by: David S. Miller <davem@davemloft.net>",32c231164b762dddefa13af5a0101032c70b50ef,https://github.com/torvalds/linux/commit/32c231164b762dddefa13af5a0101032c70b50ef,net/l2tp/l2tp_ip6.c,l2tp_ip6_bind,"static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
struct inet_sock *inet = inet_sk(sk);
struct ipv6_pinfo *np = inet6_sk(sk);
struct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;
struct net *net = sock_net(sk);
__be32 v4addr = 0;
int addr_type;
int err;
if (!sock_flag(sk, SOCK_ZAPPED))
return -EINVAL;
if (addr->l2tp_family != AF_INET6)
return -EINVAL;
if (addr_len < sizeof(*addr))
return -EINVAL;
addr_type = ipv6_addr_type(&addr->l2tp_addr);
if (addr_type == IPV6_ADDR_MAPPED)
return -EADDRNOTAVAIL;
if (addr_type & IPV6_ADDR_MULTICAST)
return -EADDRNOTAVAIL;
err = -EADDRINUSE;
read_lock_bh(&l2tp_ip6_lock);
if (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,
sk->sk_bound_dev_if, addr->l2tp_conn_id))
goto out_in_use;
read_unlock_bh(&l2tp_ip6_lock);
lock_sock(sk);
err = -EINVAL;
if (sk->sk_state != TCP_CLOSE)
goto out_unlock;
rcu_read_lock();
if (addr_type != IPV6_ADDR_ANY) {
struct net_device *dev = NULL;
if (addr_type & IPV6_ADDR_LINKLOCAL) {
if (addr_len >= sizeof(struct sockaddr_in6) &&
addr->l2tp_scope_id) {
sk->sk_bound_dev_if = addr->l2tp_scope_id;
}
if (!sk->sk_bound_dev_if)
goto out_unlock_rcu;
err = -ENODEV;
dev = dev_get_by_index_rcu(sock_net(sk),
sk->sk_bound_dev_if);
if (!dev)
goto out_unlock_rcu;
}
v4addr = LOOPBACK4_IPV6;
err = -EADDRNOTAVAIL;
if (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))
goto out_unlock_rcu;
}
rcu_read_unlock();
inet->inet_rcv_saddr = inet->inet_saddr = v4addr;
sk->sk_v6_rcv_saddr = addr->l2tp_addr;
np->saddr = addr->l2tp_addr;
l2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;
write_lock_bh(&l2tp_ip6_lock);
sk_add_bind_node(sk, &l2tp_ip6_bind_table);
sk_del_node_init(sk);
write_unlock_bh(&l2tp_ip6_lock);
sock_reset_flag(sk, SOCK_ZAPPED);
release_sock(sk);
return 0;
out_unlock_rcu:
rcu_read_unlock();
out_unlock:
release_sock(sk);
return err;
out_in_use:
read_unlock_bh(&l2tp_ip6_lock);
return err;
}","static int l2tp_ip6_bind(struct sock *VAR_0, struct sockaddr *VAR_1, int VAR_2)
{
struct inet_sock *VAR_3 = inet_sk(VAR_0);
struct ipv6_pinfo *VAR_4 = inet6_sk(VAR_0);
struct sockaddr_l2tpip6 *VAR_5 = (struct sockaddr_l2tpip6 *) VAR_1;
struct net *net = sock_net(VAR_0);
__be32 VAR_6 = 0;
int VAR_7;
int VAR_8;
if (!sock_flag(VAR_0, VAR_9))
return -VAR_10;
if (VAR_5->l2tp_family != VAR_11)
return -VAR_10;
if (VAR_2 < sizeof(*VAR_5))
return -VAR_10;
VAR_7 = ipv6_addr_type(&VAR_5->l2tp_addr);
if (VAR_7 == VAR_12)
return -VAR_13;
if (VAR_7 & VAR_14)
return -VAR_13;
VAR_8 = -VAR_15;
read_lock_bh(&VAR_16);
if (__l2tp_ip6_bind_lookup(net, &VAR_5->l2tp_addr,
VAR_0->sk_bound_dev_if, VAR_5->l2tp_conn_id))
goto out_in_use;
read_unlock_bh(&VAR_16);
lock_sock(VAR_0);
VAR_8 = -VAR_10;
if (VAR_0->sk_state != VAR_17)
goto out_unlock;
rcu_read_lock();
if (VAR_7 != VAR_18) {
struct net_device *VAR_19 = NULL;
if (VAR_7 & VAR_20) {
if (VAR_2 >= sizeof(struct sockaddr_in6) &&
VAR_5->l2tp_scope_id) {
VAR_0->sk_bound_dev_if = VAR_5->l2tp_scope_id;
}
if (!VAR_0->sk_bound_dev_if)
goto out_unlock_rcu;
VAR_8 = -VAR_21;
VAR_19 = dev_get_by_index_rcu(sock_net(VAR_0),
VAR_0->sk_bound_dev_if);
if (!VAR_19)
goto out_unlock_rcu;
}
VAR_6 = VAR_22;
VAR_8 = -VAR_13;
if (!ipv6_chk_addr(sock_net(VAR_0), &VAR_5->l2tp_addr, VAR_19, 0))
goto out_unlock_rcu;
}
rcu_read_unlock();
VAR_3->inet_rcv_saddr = VAR_3->inet_saddr = VAR_6;
VAR_0->sk_v6_rcv_saddr = VAR_5->l2tp_addr;
VAR_4->saddr = VAR_5->l2tp_addr;
l2tp_ip6_sk(VAR_0)->conn_id = VAR_5->l2tp_conn_id;
write_lock_bh(&VAR_16);
sk_add_bind_node(VAR_0, &VAR_23);
sk_del_node_init(VAR_0);
write_unlock_bh(&VAR_16);
sock_reset_flag(VAR_0, VAR_9);
release_sock(VAR_0);
return 0;
out_unlock_rcu:
rcu_read_unlock();
out_unlock:
release_sock(VAR_0);
return VAR_8;
out_in_use:
read_unlock_bh(&VAR_16);
return VAR_8;
}",torvalds/linux/32c231164b762dddefa13af5a0101032c70b50ef/l2tp_ip6.c/vul/before/0.json,"static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;
	struct net *net = sock_net(sk);
	__be32 v4addr = 0;
	int addr_type;
	int err;

	if (addr->l2tp_family != AF_INET6)
		return -EINVAL;
	if (addr_len < sizeof(*addr))
		return -EINVAL;

	addr_type = ipv6_addr_type(&addr->l2tp_addr);

	/* l2tp_ip6 sockets are IPv6 only */
	if (addr_type == IPV6_ADDR_MAPPED)
		return -EADDRNOTAVAIL;

	/* L2TP is point-point, not multicast */
	if (addr_type & IPV6_ADDR_MULTICAST)
		return -EADDRNOTAVAIL;

	err = -EADDRINUSE;
	read_lock_bh(&l2tp_ip6_lock);
	if (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,
				   sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;
	read_unlock_bh(&l2tp_ip6_lock);

	lock_sock(sk);

	err = -EINVAL;
	if (!sock_flag(sk, SOCK_ZAPPED))
		goto out_unlock;

	if (sk->sk_state != TCP_CLOSE)
		goto out_unlock;

	/* Check if the address belongs to the host. */
	rcu_read_lock();
	if (addr_type != IPV6_ADDR_ANY) {
		struct net_device *dev = NULL;

		if (addr_type & IPV6_ADDR_LINKLOCAL) {
			if (addr_len >= sizeof(struct sockaddr_in6) &&
			    addr->l2tp_scope_id) {
				/* Override any existing binding, if another
				 * one is supplied by user.
				 */
				sk->sk_bound_dev_if = addr->l2tp_scope_id;
			}

			/* Binding to link-local address requires an
			   interface */
			if (!sk->sk_bound_dev_if)
				goto out_unlock_rcu;

			err = -ENODEV;
			dev = dev_get_by_index_rcu(sock_net(sk),
						   sk->sk_bound_dev_if);
			if (!dev)
				goto out_unlock_rcu;
		}

		/* ipv4 addr of the socket is invalid.  Only the
		 * unspecified and mapped address have a v4 equivalent.
		 */
		v4addr = LOOPBACK4_IPV6;
		err = -EADDRNOTAVAIL;
		if (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))
			goto out_unlock_rcu;
	}
	rcu_read_unlock();

	inet->inet_rcv_saddr = inet->inet_saddr = v4addr;
	sk->sk_v6_rcv_saddr = addr->l2tp_addr;
	np->saddr = addr->l2tp_addr;

	l2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip6_lock);
	sk_add_bind_node(sk, &l2tp_ip6_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip6_lock);

	sock_reset_flag(sk, SOCK_ZAPPED);
	release_sock(sk);
	return 0;

out_unlock_rcu:
	rcu_read_unlock();
out_unlock:
	release_sock(sk);
	return err;

out_in_use:
	read_unlock_bh(&l2tp_ip6_lock);
	return err;
}","static int l2tp_ip6_bind(struct sock *VAR_0, struct sockaddr *VAR_1, int VAR_2)
{
	struct inet_sock *VAR_3 = inet_sk(VAR_0);
	struct ipv6_pinfo *VAR_4 = inet6_sk(VAR_0);
	struct sockaddr_l2tpip6 *VAR_5 = (struct sockaddr_l2tpip6 *) VAR_1;
	struct net *net = sock_net(VAR_0);
	__be32 VAR_6 = 0;
	int VAR_7;
	int VAR_8;

	if (VAR_5->l2tp_family != VAR_9)
		return -VAR_10;
	if (VAR_2 < sizeof(*VAR_5))
		return -VAR_10;

	VAR_7 = ipv6_addr_type(&VAR_5->l2tp_addr);

	/* COMMENT_0 */
	if (VAR_7 == VAR_11)
		return -VAR_12;

	/* COMMENT_1 */
	if (VAR_7 & VAR_13)
		return -VAR_12;

	VAR_8 = -VAR_14;
	read_lock_bh(&VAR_15);
	if (__l2tp_ip6_bind_lookup(net, &VAR_5->l2tp_addr,
				   VAR_0->sk_bound_dev_if, VAR_5->l2tp_conn_id))
		goto out_in_use;
	read_unlock_bh(&VAR_15);

	lock_sock(VAR_0);

	VAR_8 = -VAR_10;
	if (!sock_flag(VAR_0, VAR_16))
		goto out_unlock;

	if (VAR_0->sk_state != VAR_17)
		goto out_unlock;

	/* COMMENT_2 */
	rcu_read_lock();
	if (VAR_7 != VAR_18) {
		struct net_device *VAR_19 = NULL;

		if (VAR_7 & VAR_20) {
			if (VAR_2 >= sizeof(struct sockaddr_in6) &&
			    VAR_5->l2tp_scope_id) {
				/* COMMENT_3 */
                               
       
				VAR_0->sk_bound_dev_if = VAR_5->l2tp_scope_id;
			}

			/* COMMENT_6 */
                  
			if (!VAR_0->sk_bound_dev_if)
				goto out_unlock_rcu;

			VAR_8 = -VAR_21;
			VAR_19 = dev_get_by_index_rcu(sock_net(VAR_0),
						   VAR_0->sk_bound_dev_if);
			if (!VAR_19)
				goto out_unlock_rcu;
		}

		/* COMMENT_8 */
                                                         
     
		VAR_6 = VAR_22;
		VAR_8 = -VAR_12;
		if (!ipv6_chk_addr(sock_net(VAR_0), &VAR_5->l2tp_addr, VAR_19, 0))
			goto out_unlock_rcu;
	}
	rcu_read_unlock();

	VAR_3->inet_rcv_saddr = VAR_3->inet_saddr = VAR_6;
	VAR_0->sk_v6_rcv_saddr = VAR_5->l2tp_addr;
	VAR_4->saddr = VAR_5->l2tp_addr;

	l2tp_ip6_sk(VAR_0)->conn_id = VAR_5->l2tp_conn_id;

	write_lock_bh(&VAR_15);
	sk_add_bind_node(VAR_0, &VAR_23);
	sk_del_node_init(VAR_0);
	write_unlock_bh(&VAR_15);

	sock_reset_flag(VAR_0, VAR_16);
	release_sock(VAR_0);
	return 0;

out_unlock_rcu:
	rcu_read_unlock();
out_unlock:
	release_sock(VAR_0);
	return VAR_8;

out_in_use:
	read_unlock_bh(&VAR_15);
	return VAR_8;
}",torvalds/linux/32c231164b762dddefa13af5a0101032c70b50ef/l2tp_ip6.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,8 +8,6 @@
 	int addr_type;
 	int err;
 
-	if (!sock_flag(sk, SOCK_ZAPPED))
-		return -EINVAL;
 	if (addr->l2tp_family != AF_INET6)
 		return -EINVAL;
 	if (addr_len < sizeof(*addr))
@@ -35,6 +33,9 @@
 	lock_sock(sk);
 
 	err = -EINVAL;
+	if (!sock_flag(sk, SOCK_ZAPPED))
+		goto out_unlock;
+
 	if (sk->sk_state != TCP_CLOSE)
 		goto out_unlock;
 ","{'deleted_lines': ['\tif (!sock_flag(sk, SOCK_ZAPPED))', '\t\treturn -EINVAL;'], 'added_lines': ['\tif (!sock_flag(sk, SOCK_ZAPPED))', '\t\tgoto out_unlock;', '']}",True,"Race condition in the L2TPv3 IP Encapsulation feature in the Linux kernel before 4.8.14 allows local users to gain privileges or cause a denial of service (use-after-free) by making multiple bind system calls without properly ascertaining whether a socket has the SOCK_ZAPPED status, related to net/l2tp/l2tp_ip.c and net/l2tp/l2tp_ip6.c.",7.0,HIGH,2,test,2016-11-18T21:13:00Z,1
CVE-2016-9382,['CWE-264'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/HVM: don't load LDTR with VM86 mode attrs during task switch

Just like TR, LDTR is purely a protected mode facility and hence needs
to be loaded accordingly. Also move its loading to where it
architecurally belongs.

This is CVE-2016-9382 / XSA-192.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>
Tested-by: Andrew Cooper <andrew.cooper3@citrix.com>",93aa42b85ae0084ba7b749d0e990c94fbf0c17e3,https://github.com/xen-project/xen/commit/93aa42b85ae0084ba7b749d0e990c94fbf0c17e3,xen/arch/x86/hvm/hvm.c,hvm_load_segment_selector,"static int hvm_load_segment_selector(
enum x86_segment seg, uint16_t sel)
{
struct segment_register desctab, cs, segr;
struct desc_struct *pdesc, desc;
u8 dpl, rpl, cpl;
bool_t writable;
int fault_type = TRAP_invalid_tss;
struct cpu_user_regs *regs = guest_cpu_user_regs();
struct vcpu *v = current;
if ( regs->eflags & X86_EFLAGS_VM )
{
segr.sel = sel;
segr.base = (uint32_t)sel << 4;
segr.limit = 0xffffu;
segr.attr.bytes = 0xf3;
hvm_set_segment_register(v, seg, &segr);
return 0;
}
if ( (sel & 0xfffc) == 0 )
{
if ( (seg == x86_seg_cs) || (seg == x86_seg_ss) )
goto fail;
memset(&segr, 0, sizeof(segr));
segr.sel = sel;
hvm_set_segment_register(v, seg, &segr);
return 0;
}
if ( (seg == x86_seg_ldtr) && (sel & 4) )
goto fail;
hvm_get_segment_register(v, x86_seg_cs, &cs);
hvm_get_segment_register(
v, (sel & 4) ? x86_seg_ldtr : x86_seg_gdtr, &desctab);
if ( !desctab.attr.fields.p )
goto fail;
if ( ((sel & 0xfff8) + 7) > desctab.limit )
goto fail;
pdesc = hvm_map_entry(desctab.base + (sel & 0xfff8), &writable);
if ( pdesc == NULL )
goto hvm_map_fail;
do {
desc = *pdesc;
if ( (desc.b & (1u<<12)) == ((seg == x86_seg_ldtr) << 12) )
goto unmap_and_fail;
dpl = (desc.b >> 13) & 3;
rpl = sel & 3;
cpl = cs.sel & 3;
switch ( seg )
{
case x86_seg_cs:
if ( !(desc.b & _SEGMENT_CODE) )
goto unmap_and_fail;
if ( !(desc.b & _SEGMENT_EC) && (dpl != rpl) )
goto unmap_and_fail;
break;
case x86_seg_ss:
if ( (desc.b & (_SEGMENT_CODE|_SEGMENT_WR)) != _SEGMENT_WR )
goto unmap_and_fail;
if ( (dpl != cpl) || (dpl != rpl) )
goto unmap_and_fail;
break;
case x86_seg_ldtr:
if ( (desc.b & _SEGMENT_TYPE) != (2u<<8) )
goto unmap_and_fail;
goto skip_accessed_flag;
default:
if ( (desc.b & (_SEGMENT_CODE|_SEGMENT_WR)) == _SEGMENT_CODE )
goto unmap_and_fail;
if ( ((desc.b & (_SEGMENT_EC|_SEGMENT_CODE)) !=
(_SEGMENT_EC|_SEGMENT_CODE))
&& ((dpl < cpl) || (dpl < rpl)) )
goto unmap_and_fail;
break;
}
if ( !(desc.b & _SEGMENT_P) )
{
fault_type = (seg != x86_seg_ss) ? TRAP_no_segment
: TRAP_stack_error;
goto unmap_and_fail;
}
} while ( !(desc.b & 0x100) && 
writable && 
(cmpxchg(&pdesc->b, desc.b, desc.b | 0x100) != desc.b) );
desc.b |= 0x100;
skip_accessed_flag:
hvm_unmap_entry(pdesc);
segr.base = (((desc.b <<  0) & 0xff000000u) |
((desc.b << 16) & 0x00ff0000u) |
((desc.a >> 16) & 0x0000ffffu));
segr.attr.bytes = (((desc.b >>  8) & 0x00ffu) |
((desc.b >> 12) & 0x0f00u));
segr.limit = (desc.b & 0x000f0000u) | (desc.a & 0x0000ffffu);
if ( segr.attr.fields.g )
segr.limit = (segr.limit << 12) | 0xfffu;
segr.sel = sel;
hvm_set_segment_register(v, seg, &segr);
return 0;
unmap_and_fail:
hvm_unmap_entry(pdesc);
fail:
hvm_inject_hw_exception(fault_type, sel & 0xfffc);
hvm_map_fail:
return 1;
}","static int hvm_load_segment_selector(
enum x86_segment VAR_0, uint16_t VAR_1)
{
struct segment_register VAR_2, VAR_3, VAR_4;
struct desc_struct *VAR_5, VAR_6;
u8 VAR_7, VAR_8, VAR_9;
bool_t VAR_10;
int VAR_11 = VAR_12;
struct cpu_user_regs *VAR_13 = guest_cpu_user_regs();
struct vcpu *VAR_14 = VAR_15;
if ( VAR_13->eflags & VAR_16 )
{
VAR_4.sel = VAR_1;
VAR_4.base = (uint32_t)VAR_1 << 4;
VAR_4.limit = 0xffffu;
VAR_4.attr.bytes = 0xf3;
hvm_set_segment_register(VAR_14, VAR_0, &VAR_4);
return 0;
}
if ( (VAR_1 & 0xfffc) == 0 )
{
if ( (VAR_0 == VAR_17) || (VAR_0 == VAR_18) )
goto fail;
memset(&VAR_4, 0, sizeof(VAR_4));
VAR_4.sel = VAR_1;
hvm_set_segment_register(VAR_14, VAR_0, &VAR_4);
return 0;
}
if ( (VAR_0 == VAR_19) && (VAR_1 & 4) )
goto fail;
hvm_get_segment_register(VAR_14, VAR_17, &VAR_3);
hvm_get_segment_register(
VAR_14, (VAR_1 & 4) ? VAR_19 : VAR_20, &VAR_2);
if ( !VAR_2.attr.fields.p )
goto fail;
if ( ((VAR_1 & 0xfff8) + 7) > VAR_2.limit )
goto fail;
VAR_5 = hvm_map_entry(VAR_2.base + (VAR_1 & 0xfff8), &VAR_10);
if ( VAR_5 == NULL )
goto hvm_map_fail;
do {
VAR_6 = *VAR_5;
if ( (VAR_6.b & (1u<<12)) == ((VAR_0 == VAR_19) << 12) )
goto unmap_and_fail;
VAR_7 = (VAR_6.b >> 13) & 3;
VAR_8 = VAR_1 & 3;
VAR_9 = VAR_3.sel & 3;
switch ( VAR_0 )
{
case VAR_17:
if ( !(VAR_6.b & VAR_21) )
goto unmap_and_fail;
if ( !(VAR_6.b & VAR_22) && (VAR_7 != VAR_8) )
goto unmap_and_fail;
break;
case VAR_18:
if ( (VAR_6.b & (VAR_21|VAR_23)) != VAR_23 )
goto unmap_and_fail;
if ( (VAR_7 != VAR_9) || (VAR_7 != VAR_8) )
goto unmap_and_fail;
break;
case VAR_19:
if ( (VAR_6.b & VAR_24) != (2u<<8) )
goto unmap_and_fail;
goto skip_accessed_flag;
default:
if ( (VAR_6.b & (VAR_21|VAR_23)) == VAR_21 )
goto unmap_and_fail;
if ( ((VAR_6.b & (VAR_22|VAR_21)) !=
(VAR_22|VAR_21))
&& ((VAR_7 < VAR_9) || (VAR_7 < VAR_8)) )
goto unmap_and_fail;
break;
}
if ( !(VAR_6.b & VAR_25) )
{
VAR_11 = (VAR_0 != VAR_18) ? VAR_26
: VAR_27;
goto unmap_and_fail;
}
} while ( !(VAR_6.b & 0x100) && 
VAR_10 && 
(cmpxchg(&VAR_5->b, VAR_6.b, VAR_6.b | 0x100) != VAR_6.b) );
VAR_6.b |= 0x100;
skip_accessed_flag:
hvm_unmap_entry(VAR_5);
VAR_4.base = (((VAR_6.b <<  0) & 0xff000000u) |
((VAR_6.b << 16) & 0x00ff0000u) |
((VAR_6.a >> 16) & 0x0000ffffu));
VAR_4.attr.bytes = (((VAR_6.b >>  8) & 0x00ffu) |
((VAR_6.b >> 12) & 0x0f00u));
VAR_4.limit = (VAR_6.b & 0x000f0000u) | (VAR_6.a & 0x0000ffffu);
if ( VAR_4.attr.fields.g )
VAR_4.limit = (VAR_4.limit << 12) | 0xfffu;
VAR_4.sel = VAR_1;
hvm_set_segment_register(VAR_14, VAR_0, &VAR_4);
return 0;
unmap_and_fail:
hvm_unmap_entry(VAR_5);
fail:
hvm_inject_hw_exception(VAR_11, VAR_1 & 0xfffc);
hvm_map_fail:
return 1;
}",xen-project/xen/93aa42b85ae0084ba7b749d0e990c94fbf0c17e3/hvm.c/vul/before/0.json,"static int hvm_load_segment_selector(
    enum x86_segment seg, uint16_t sel, unsigned int eflags)
{
    struct segment_register desctab, cs, segr;
    struct desc_struct *pdesc, desc;
    u8 dpl, rpl, cpl;
    bool_t writable;
    int fault_type = TRAP_invalid_tss;
    struct vcpu *v = current;

    if ( eflags & X86_EFLAGS_VM )
    {
        segr.sel = sel;
        segr.base = (uint32_t)sel << 4;
        segr.limit = 0xffffu;
        segr.attr.bytes = 0xf3;
        hvm_set_segment_register(v, seg, &segr);
        return 0;
    }

    /* NULL selector? */
    if ( (sel & 0xfffc) == 0 )
    {
        if ( (seg == x86_seg_cs) || (seg == x86_seg_ss) )
            goto fail;
        memset(&segr, 0, sizeof(segr));
        segr.sel = sel;
        hvm_set_segment_register(v, seg, &segr);
        return 0;
    }

    /* LDT descriptor must be in the GDT. */
    if ( (seg == x86_seg_ldtr) && (sel & 4) )
        goto fail;

    hvm_get_segment_register(v, x86_seg_cs, &cs);
    hvm_get_segment_register(
        v, (sel & 4) ? x86_seg_ldtr : x86_seg_gdtr, &desctab);

    /* Segment not valid for use (cooked meaning of .p)? */
    if ( !desctab.attr.fields.p )
        goto fail;

    /* Check against descriptor table limit. */
    if ( ((sel & 0xfff8) + 7) > desctab.limit )
        goto fail;

    pdesc = hvm_map_entry(desctab.base + (sel & 0xfff8), &writable);
    if ( pdesc == NULL )
        goto hvm_map_fail;

    do {
        desc = *pdesc;

        /* LDT descriptor is a system segment. All others are code/data. */
        if ( (desc.b & (1u<<12)) == ((seg == x86_seg_ldtr) << 12) )
            goto unmap_and_fail;

        dpl = (desc.b >> 13) & 3;
        rpl = sel & 3;
        cpl = cs.sel & 3;

        switch ( seg )
        {
        case x86_seg_cs:
            /* Code segment? */
            if ( !(desc.b & _SEGMENT_CODE) )
                goto unmap_and_fail;
            /* Non-conforming segment: check DPL against RPL. */
            if ( !(desc.b & _SEGMENT_EC) && (dpl != rpl) )
                goto unmap_and_fail;
            break;
        case x86_seg_ss:
            /* Writable data segment? */
            if ( (desc.b & (_SEGMENT_CODE|_SEGMENT_WR)) != _SEGMENT_WR )
                goto unmap_and_fail;
            if ( (dpl != cpl) || (dpl != rpl) )
                goto unmap_and_fail;
            break;
        case x86_seg_ldtr:
            /* LDT system segment? */
            if ( (desc.b & _SEGMENT_TYPE) != (2u<<8) )
                goto unmap_and_fail;
            goto skip_accessed_flag;
        default:
            /* Readable code or data segment? */
            if ( (desc.b & (_SEGMENT_CODE|_SEGMENT_WR)) == _SEGMENT_CODE )
                goto unmap_and_fail;
            /*
             * Data or non-conforming code segment:
             * check DPL against RPL and CPL.
             */
            if ( ((desc.b & (_SEGMENT_EC|_SEGMENT_CODE)) !=
                  (_SEGMENT_EC|_SEGMENT_CODE))
                 && ((dpl < cpl) || (dpl < rpl)) )
                goto unmap_and_fail;
            break;
        }

        /* Segment present in memory? */
        if ( !(desc.b & _SEGMENT_P) )
        {
            fault_type = (seg != x86_seg_ss) ? TRAP_no_segment
                                             : TRAP_stack_error;
            goto unmap_and_fail;
        }
    } while ( !(desc.b & 0x100) && /* Ensure Accessed flag is set */
              writable && /* except if we are to discard writes */
              (cmpxchg(&pdesc->b, desc.b, desc.b | 0x100) != desc.b) );

    /* Force the Accessed flag in our local copy. */
    desc.b |= 0x100;

 skip_accessed_flag:
    hvm_unmap_entry(pdesc);

    segr.base = (((desc.b <<  0) & 0xff000000u) |
                 ((desc.b << 16) & 0x00ff0000u) |
                 ((desc.a >> 16) & 0x0000ffffu));
    segr.attr.bytes = (((desc.b >>  8) & 0x00ffu) |
                       ((desc.b >> 12) & 0x0f00u));
    segr.limit = (desc.b & 0x000f0000u) | (desc.a & 0x0000ffffu);
    if ( segr.attr.fields.g )
        segr.limit = (segr.limit << 12) | 0xfffu;
    segr.sel = sel;
    hvm_set_segment_register(v, seg, &segr);

    return 0;

 unmap_and_fail:
    hvm_unmap_entry(pdesc);
 fail:
    hvm_inject_hw_exception(fault_type, sel & 0xfffc);
 hvm_map_fail:
    return 1;
}","static int hvm_load_segment_selector(
    enum x86_segment VAR_0, uint16_t VAR_1, unsigned int VAR_2)
{
    struct segment_register VAR_3, VAR_4, VAR_5;
    struct desc_struct *VAR_6, VAR_7;
    u8 VAR_8, VAR_9, VAR_10;
    bool_t VAR_11;
    int VAR_12 = VAR_13;
    struct vcpu *VAR_14 = VAR_15;

    if ( VAR_2 & VAR_16 )
    {
        VAR_5.sel = VAR_1;
        VAR_5.base = (uint32_t)VAR_1 << 4;
        VAR_5.limit = 0xffffu;
        VAR_5.attr.bytes = 0xf3;
        hvm_set_segment_register(VAR_14, VAR_0, &VAR_5);
        return 0;
    }

    /* COMMENT_0 */
    if ( (VAR_1 & 0xfffc) == 0 )
    {
        if ( (VAR_0 == VAR_17) || (VAR_0 == VAR_18) )
            goto fail;
        memset(&VAR_5, 0, sizeof(VAR_5));
        VAR_5.sel = VAR_1;
        hvm_set_segment_register(VAR_14, VAR_0, &VAR_5);
        return 0;
    }

    /* COMMENT_1 */
    if ( (VAR_0 == VAR_19) && (VAR_1 & 4) )
        goto fail;

    hvm_get_segment_register(VAR_14, VAR_17, &VAR_4);
    hvm_get_segment_register(
        VAR_14, (VAR_1 & 4) ? VAR_19 : VAR_20, &VAR_3);

    /* COMMENT_2 */
    if ( !VAR_3.attr.fields.p )
        goto fail;

    /* COMMENT_3 */
    if ( ((VAR_1 & 0xfff8) + 7) > VAR_3.limit )
        goto fail;

    VAR_6 = hvm_map_entry(VAR_3.base + (VAR_1 & 0xfff8), &VAR_11);
    if ( VAR_6 == NULL )
        goto hvm_map_fail;

    do {
        VAR_7 = *VAR_6;

        /* COMMENT_4 */
        if ( (VAR_7.b & (1u<<12)) == ((VAR_0 == VAR_19) << 12) )
            goto unmap_and_fail;

        VAR_8 = (VAR_7.b >> 13) & 3;
        VAR_9 = VAR_1 & 3;
        VAR_10 = VAR_4.sel & 3;

        switch ( VAR_0 )
        {
        case VAR_17:
            /* COMMENT_5 */
            if ( !(VAR_7.b & VAR_21) )
                goto unmap_and_fail;
            /* COMMENT_6 */
            if ( !(VAR_7.b & VAR_22) && (VAR_8 != VAR_9) )
                goto unmap_and_fail;
            break;
        case VAR_18:
            /* COMMENT_7 */
            if ( (VAR_7.b & (VAR_21|VAR_23)) != VAR_23 )
                goto unmap_and_fail;
            if ( (VAR_8 != VAR_10) || (VAR_8 != VAR_9) )
                goto unmap_and_fail;
            break;
        case VAR_19:
            /* COMMENT_8 */
            if ( (VAR_7.b & VAR_24) != (2u<<8) )
                goto unmap_and_fail;
            goto skip_accessed_flag;
        default:
            /* COMMENT_9 */
            if ( (VAR_7.b & (VAR_21|VAR_23)) == VAR_21 )
                goto unmap_and_fail;
            /* COMMENT_10 */
                                                   
                                             
               
            if ( ((VAR_7.b & (VAR_22|VAR_21)) !=
                  (VAR_22|VAR_21))
                 && ((VAR_8 < VAR_10) || (VAR_8 < VAR_9)) )
                goto unmap_and_fail;
            break;
        }

        /* COMMENT_14 */
        if ( !(VAR_7.b & VAR_25) )
        {
            VAR_12 = (VAR_0 != VAR_18) ? VAR_26
                                             : VAR_27;
            goto unmap_and_fail;
        }
    } while ( !(VAR_7.b & 0x100) && /* COMMENT_15 */
              VAR_11 && /* COMMENT_16 */
              (cmpxchg(&VAR_6->b, VAR_7.b, VAR_7.b | 0x100) != VAR_7.b) );

    /* COMMENT_17 */
    VAR_7.b |= 0x100;

 skip_accessed_flag:
    hvm_unmap_entry(VAR_6);

    VAR_5.base = (((VAR_7.b <<  0) & 0xff000000u) |
                 ((VAR_7.b << 16) & 0x00ff0000u) |
                 ((VAR_7.a >> 16) & 0x0000ffffu));
    VAR_5.attr.bytes = (((VAR_7.b >>  8) & 0x00ffu) |
                       ((VAR_7.b >> 12) & 0x0f00u));
    VAR_5.limit = (VAR_7.b & 0x000f0000u) | (VAR_7.a & 0x0000ffffu);
    if ( VAR_5.attr.fields.g )
        VAR_5.limit = (VAR_5.limit << 12) | 0xfffu;
    VAR_5.sel = VAR_1;
    hvm_set_segment_register(VAR_14, VAR_0, &VAR_5);

    return 0;

 unmap_and_fail:
    hvm_unmap_entry(VAR_6);
 fail:
    hvm_inject_hw_exception(VAR_12, VAR_1 & 0xfffc);
 hvm_map_fail:
    return 1;
}",xen-project/xen/93aa42b85ae0084ba7b749d0e990c94fbf0c17e3/hvm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,15 +1,14 @@
 static int hvm_load_segment_selector(
-    enum x86_segment seg, uint16_t sel)
+    enum x86_segment seg, uint16_t sel, unsigned int eflags)
 {
     struct segment_register desctab, cs, segr;
     struct desc_struct *pdesc, desc;
     u8 dpl, rpl, cpl;
     bool_t writable;
     int fault_type = TRAP_invalid_tss;
-    struct cpu_user_regs *regs = guest_cpu_user_regs();
     struct vcpu *v = current;
 
-    if ( regs->eflags & X86_EFLAGS_VM )
+    if ( eflags & X86_EFLAGS_VM )
     {
         segr.sel = sel;
         segr.base = (uint32_t)sel << 4;","{'deleted_lines': ['    enum x86_segment seg, uint16_t sel)', '    struct cpu_user_regs *regs = guest_cpu_user_regs();', '    if ( regs->eflags & X86_EFLAGS_VM )'], 'added_lines': ['    enum x86_segment seg, uint16_t sel, unsigned int eflags)', '    if ( eflags & X86_EFLAGS_VM )']}",True,"Xen 4.0.x through 4.7.x mishandle x86 task switches to VM86 mode, which allows local 32-bit x86 HVM guest OS users to gain privileges or cause a denial of service (guest OS crash) by leveraging a guest operating system that uses hardware task switching and allows a new task to start in VM86 mode.",7.8,HIGH,2,test,2016-11-22T12:45:44Z,1
CVE-2016-9382,['CWE-264'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,xen-project/xen,"x86/HVM: don't load LDTR with VM86 mode attrs during task switch

Just like TR, LDTR is purely a protected mode facility and hence needs
to be loaded accordingly. Also move its loading to where it
architecurally belongs.

This is CVE-2016-9382 / XSA-192.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>
Tested-by: Andrew Cooper <andrew.cooper3@citrix.com>",93aa42b85ae0084ba7b749d0e990c94fbf0c17e3,https://github.com/xen-project/xen/commit/93aa42b85ae0084ba7b749d0e990c94fbf0c17e3,xen/arch/x86/hvm/hvm.c,hvm_task_switch,"void hvm_task_switch(
uint16_t tss_sel, enum hvm_task_switch_reason taskswitch_reason,
int32_t errcode)
{
struct vcpu *v = current;
struct cpu_user_regs *regs = guest_cpu_user_regs();
struct segment_register gdt, tr, prev_tr, segr;
struct desc_struct *optss_desc = NULL, *nptss_desc = NULL, tss_desc;
bool_t otd_writable, ntd_writable;
unsigned long eflags;
int exn_raised, rc;
struct {
u16 back_link,__blh;
u32 esp0;
u16 ss0, _0;
u32 esp1;
u16 ss1, _1;
u32 esp2;
u16 ss2, _2;
u32 cr3, eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi;
u16 es, _3, cs, _4, ss, _5, ds, _6, fs, _7, gs, _8, ldt, _9;
u16 trace, iomap;
} tss = { 0 };
hvm_get_segment_register(v, x86_seg_gdtr, &gdt);
hvm_get_segment_register(v, x86_seg_tr, &prev_tr);
if ( ((tss_sel & 0xfff8) + 7) > gdt.limit )
{
hvm_inject_hw_exception((taskswitch_reason == TSW_iret) ?
TRAP_invalid_tss : TRAP_gp_fault,
tss_sel & 0xfff8);
goto out;
}
optss_desc = hvm_map_entry(gdt.base + (prev_tr.sel & 0xfff8),
&otd_writable);
if ( optss_desc == NULL )
goto out;
nptss_desc = hvm_map_entry(gdt.base + (tss_sel & 0xfff8), &ntd_writable);
if ( nptss_desc == NULL )
goto out;
tss_desc = *nptss_desc;
tr.sel = tss_sel;
tr.base = (((tss_desc.b <<  0) & 0xff000000u) |
((tss_desc.b << 16) & 0x00ff0000u) |
((tss_desc.a >> 16) & 0x0000ffffu));
tr.attr.bytes = (((tss_desc.b >>  8) & 0x00ffu) |
((tss_desc.b >> 12) & 0x0f00u));
tr.limit = (tss_desc.b & 0x000f0000u) | (tss_desc.a & 0x0000ffffu);
if ( tr.attr.fields.g )
tr.limit = (tr.limit << 12) | 0xfffu;
if ( tr.attr.fields.type != ((taskswitch_reason == TSW_iret) ? 0xb : 0x9) )
{
hvm_inject_hw_exception(
(taskswitch_reason == TSW_iret) ? TRAP_invalid_tss : TRAP_gp_fault,
tss_sel & 0xfff8);
goto out;
}
if ( !tr.attr.fields.p )
{
hvm_inject_hw_exception(TRAP_no_segment, tss_sel & 0xfff8);
goto out;
}
if ( tr.limit < (sizeof(tss)-1) )
{
hvm_inject_hw_exception(TRAP_invalid_tss, tss_sel & 0xfff8);
goto out;
}
rc = hvm_copy_from_guest_virt(
&tss, prev_tr.base, sizeof(tss), PFEC_page_present);
if ( rc != HVMCOPY_okay )
goto out;
eflags = regs->eflags;
if ( taskswitch_reason == TSW_iret )
eflags &= ~X86_EFLAGS_NT;
tss.cr3    = v->arch.hvm_vcpu.guest_cr[3];
tss.eip    = regs->eip;
tss.eflags = eflags;
tss.eax    = regs->eax;
tss.ecx    = regs->ecx;
tss.edx    = regs->edx;
tss.ebx    = regs->ebx;
tss.esp    = regs->esp;
tss.ebp    = regs->ebp;
tss.esi    = regs->esi;
tss.edi    = regs->edi;
hvm_get_segment_register(v, x86_seg_es, &segr);
tss.es = segr.sel;
hvm_get_segment_register(v, x86_seg_cs, &segr);
tss.cs = segr.sel;
hvm_get_segment_register(v, x86_seg_ss, &segr);
tss.ss = segr.sel;
hvm_get_segment_register(v, x86_seg_ds, &segr);
tss.ds = segr.sel;
hvm_get_segment_register(v, x86_seg_fs, &segr);
tss.fs = segr.sel;
hvm_get_segment_register(v, x86_seg_gs, &segr);
tss.gs = segr.sel;
hvm_get_segment_register(v, x86_seg_ldtr, &segr);
tss.ldt = segr.sel;
rc = hvm_copy_to_guest_virt(
prev_tr.base, &tss, sizeof(tss), PFEC_page_present);
if ( rc != HVMCOPY_okay )
goto out;
rc = hvm_copy_from_guest_virt(
&tss, tr.base, sizeof(tss), PFEC_page_present);
if ( rc != HVMCOPY_okay )
goto out;
if ( hvm_set_cr3(tss.cr3, 1) )
goto out;
regs->eip    = tss.eip;
regs->eflags = tss.eflags | 2;
regs->eax    = tss.eax;
regs->ecx    = tss.ecx;
regs->edx    = tss.edx;
regs->ebx    = tss.ebx;
regs->esp    = tss.esp;
regs->ebp    = tss.ebp;
regs->esi    = tss.esi;
regs->edi    = tss.edi;
if ( (taskswitch_reason == TSW_call_or_int) )
{
regs->eflags |= X86_EFLAGS_NT;
tss.back_link = prev_tr.sel;
}
exn_raised = 0;
if ( hvm_load_segment_selector(x86_seg_ldtr, tss.ldt) ||
hvm_load_segment_selector(x86_seg_es, tss.es) ||
hvm_load_segment_selector(x86_seg_cs, tss.cs) ||
hvm_load_segment_selector(x86_seg_ss, tss.ss) ||
hvm_load_segment_selector(x86_seg_ds, tss.ds) ||
hvm_load_segment_selector(x86_seg_fs, tss.fs) ||
hvm_load_segment_selector(x86_seg_gs, tss.gs) )
exn_raised = 1;
rc = hvm_copy_to_guest_virt(
tr.base, &tss, sizeof(tss), PFEC_page_present);
if ( rc == HVMCOPY_bad_gva_to_gfn )
exn_raised = 1;
else if ( rc != HVMCOPY_okay )
goto out;
if ( (tss.trace & 1) && !exn_raised )
hvm_inject_hw_exception(TRAP_debug, HVM_DELIVER_NO_ERROR_CODE);
tr.attr.fields.type = 0xb; 
hvm_set_segment_register(v, x86_seg_tr, &tr);
v->arch.hvm_vcpu.guest_cr[0] |= X86_CR0_TS;
hvm_update_guest_cr(v, 0);
if ( (taskswitch_reason == TSW_iret ||
taskswitch_reason == TSW_jmp) && otd_writable )
clear_bit(41, optss_desc); 
if ( taskswitch_reason != TSW_iret && ntd_writable )
set_bit(41, nptss_desc); 
if ( errcode >= 0 )
{
struct segment_register reg;
unsigned long linear_addr;
regs->esp -= 4;
hvm_get_segment_register(current, x86_seg_ss, &reg);
if ( hvm_virtual_to_linear_addr(x86_seg_ss, &reg, regs->esp,
4, hvm_access_write, 32,
&linear_addr) )
hvm_copy_to_guest_virt_nofault(linear_addr, &errcode, 4, 0);
}
out:
hvm_unmap_entry(optss_desc);
hvm_unmap_entry(nptss_desc);
}","void hvm_task_switch(
uint16_t VAR_0, enum hvm_task_switch_reason VAR_1,
int32_t VAR_2)
{
struct vcpu *VAR_3 = VAR_4;
struct cpu_user_regs *VAR_5 = guest_cpu_user_regs();
struct segment_register VAR_6, VAR_7, VAR_8, VAR_9;
struct desc_struct *VAR_10 = NULL, *VAR_11 = NULL, VAR_12;
bool_t VAR_13, VAR_14;
unsigned long VAR_15;
int VAR_16, VAR_17;
struct {
u16 back_link,__blh;
u32 esp0;
u16 ss0, _0;
u32 esp1;
u16 ss1, _1;
u32 esp2;
u16 ss2, _2;
u32 cr3, eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi;
u16 es, _3, cs, _4, ss, _5, ds, _6, fs, _7, gs, _8, ldt, _9;
u16 trace, iomap;
} VAR_18 = { 0 };
hvm_get_segment_register(VAR_3, VAR_19, &VAR_6);
hvm_get_segment_register(VAR_3, VAR_20, &VAR_8);
if ( ((VAR_0 & 0xfff8) + 7) > VAR_6.limit )
{
hvm_inject_hw_exception((VAR_1 == VAR_21) ?
VAR_22 : VAR_23,
VAR_0 & 0xfff8);
goto out;
}
VAR_10 = hvm_map_entry(VAR_6.base + (VAR_8.sel & 0xfff8),
&VAR_13);
if ( VAR_10 == NULL )
goto out;
VAR_11 = hvm_map_entry(VAR_6.base + (VAR_0 & 0xfff8), &VAR_14);
if ( VAR_11 == NULL )
goto out;
VAR_12 = *VAR_11;
VAR_7.sel = VAR_0;
VAR_7.base = (((VAR_12.b <<  0) & 0xff000000u) |
((VAR_12.b << 16) & 0x00ff0000u) |
((VAR_12.a >> 16) & 0x0000ffffu));
VAR_7.attr.bytes = (((VAR_12.b >>  8) & 0x00ffu) |
((VAR_12.b >> 12) & 0x0f00u));
VAR_7.limit = (VAR_12.b & 0x000f0000u) | (VAR_12.a & 0x0000ffffu);
if ( VAR_7.attr.fields.g )
VAR_7.limit = (VAR_7.limit << 12) | 0xfffu;
if ( VAR_7.attr.fields.type != ((VAR_1 == VAR_21) ? 0xb : 0x9) )
{
hvm_inject_hw_exception(
(VAR_1 == VAR_21) ? VAR_22 : VAR_23,
VAR_0 & 0xfff8);
goto out;
}
if ( !VAR_7.attr.fields.p )
{
hvm_inject_hw_exception(VAR_24, VAR_0 & 0xfff8);
goto out;
}
if ( VAR_7.limit < (sizeof(VAR_18)-1) )
{
hvm_inject_hw_exception(VAR_22, VAR_0 & 0xfff8);
goto out;
}
VAR_17 = hvm_copy_from_guest_virt(
&VAR_18, VAR_8.base, sizeof(VAR_18), VAR_25);
if ( VAR_17 != VAR_26 )
goto out;
VAR_15 = VAR_5->eflags;
if ( VAR_1 == VAR_21 )
VAR_15 &= ~VAR_27;
VAR_18.cr3    = VAR_3->arch.hvm_vcpu.guest_cr[3];
VAR_18.eip    = VAR_5->eip;
VAR_18.eflags = VAR_15;
VAR_18.eax    = VAR_5->eax;
VAR_18.ecx    = VAR_5->ecx;
VAR_18.edx    = VAR_5->edx;
VAR_18.ebx    = VAR_5->ebx;
VAR_18.esp    = VAR_5->esp;
VAR_18.ebp    = VAR_5->ebp;
VAR_18.esi    = VAR_5->esi;
VAR_18.edi    = VAR_5->edi;
hvm_get_segment_register(VAR_3, VAR_28, &VAR_9);
VAR_18.es = VAR_9.sel;
hvm_get_segment_register(VAR_3, VAR_29, &VAR_9);
VAR_18.cs = VAR_9.sel;
hvm_get_segment_register(VAR_3, VAR_30, &VAR_9);
VAR_18.ss = VAR_9.sel;
hvm_get_segment_register(VAR_3, VAR_31, &VAR_9);
VAR_18.ds = VAR_9.sel;
hvm_get_segment_register(VAR_3, VAR_32, &VAR_9);
VAR_18.fs = VAR_9.sel;
hvm_get_segment_register(VAR_3, VAR_33, &VAR_9);
VAR_18.gs = VAR_9.sel;
hvm_get_segment_register(VAR_3, VAR_34, &VAR_9);
VAR_18.ldt = VAR_9.sel;
VAR_17 = hvm_copy_to_guest_virt(
VAR_8.base, &VAR_18, sizeof(VAR_18), VAR_25);
if ( VAR_17 != VAR_26 )
goto out;
VAR_17 = hvm_copy_from_guest_virt(
&VAR_18, VAR_7.base, sizeof(VAR_18), VAR_25);
if ( VAR_17 != VAR_26 )
goto out;
if ( hvm_set_cr3(VAR_18.cr3, 1) )
goto out;
VAR_5->eip    = VAR_18.eip;
VAR_5->eflags = VAR_18.eflags | 2;
VAR_5->eax    = VAR_18.eax;
VAR_5->ecx    = VAR_18.ecx;
VAR_5->edx    = VAR_18.edx;
VAR_5->ebx    = VAR_18.ebx;
VAR_5->esp    = VAR_18.esp;
VAR_5->ebp    = VAR_18.ebp;
VAR_5->esi    = VAR_18.esi;
VAR_5->edi    = VAR_18.edi;
if ( (VAR_1 == VAR_35) )
{
VAR_5->eflags |= VAR_27;
VAR_18.back_link = VAR_8.sel;
}
VAR_16 = 0;
if ( hvm_load_segment_selector(VAR_34, VAR_18.ldt) ||
hvm_load_segment_selector(VAR_28, VAR_18.es) ||
hvm_load_segment_selector(VAR_29, VAR_18.cs) ||
hvm_load_segment_selector(VAR_30, VAR_18.ss) ||
hvm_load_segment_selector(VAR_31, VAR_18.ds) ||
hvm_load_segment_selector(VAR_32, VAR_18.fs) ||
hvm_load_segment_selector(VAR_33, VAR_18.gs) )
VAR_16 = 1;
VAR_17 = hvm_copy_to_guest_virt(
VAR_7.base, &VAR_18, sizeof(VAR_18), VAR_25);
if ( VAR_17 == VAR_36 )
VAR_16 = 1;
else if ( VAR_17 != VAR_26 )
goto out;
if ( (VAR_18.trace & 1) && !VAR_16 )
hvm_inject_hw_exception(VAR_37, VAR_38);
VAR_7.attr.fields.type = 0xb; 
hvm_set_segment_register(VAR_3, VAR_20, &VAR_7);
VAR_3->arch.hvm_vcpu.guest_cr[0] |= VAR_39;
hvm_update_guest_cr(VAR_3, 0);
if ( (VAR_1 == VAR_21 ||
VAR_1 == VAR_40) && VAR_13 )
clear_bit(41, VAR_10); 
if ( VAR_1 != VAR_21 && VAR_14 )
set_bit(41, VAR_11); 
if ( VAR_2 >= 0 )
{
struct segment_register VAR_41;
unsigned long VAR_42;
VAR_5->esp -= 4;
hvm_get_segment_register(VAR_4, VAR_30, &VAR_41);
if ( hvm_virtual_to_linear_addr(VAR_30, &VAR_41, VAR_5->esp,
4, VAR_43, 32,
&VAR_42) )
hvm_copy_to_guest_virt_nofault(VAR_42, &VAR_2, 4, 0);
}
out:
hvm_unmap_entry(VAR_10);
hvm_unmap_entry(VAR_11);
}",xen-project/xen/93aa42b85ae0084ba7b749d0e990c94fbf0c17e3/hvm.c/vul/before/1.json,"void hvm_task_switch(
    uint16_t tss_sel, enum hvm_task_switch_reason taskswitch_reason,
    int32_t errcode)
{
    struct vcpu *v = current;
    struct cpu_user_regs *regs = guest_cpu_user_regs();
    struct segment_register gdt, tr, prev_tr, segr;
    struct desc_struct *optss_desc = NULL, *nptss_desc = NULL, tss_desc;
    bool_t otd_writable, ntd_writable;
    unsigned long eflags;
    int exn_raised, rc;
    struct {
        u16 back_link,__blh;
        u32 esp0;
        u16 ss0, _0;
        u32 esp1;
        u16 ss1, _1;
        u32 esp2;
        u16 ss2, _2;
        u32 cr3, eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi;
        u16 es, _3, cs, _4, ss, _5, ds, _6, fs, _7, gs, _8, ldt, _9;
        u16 trace, iomap;
    } tss = { 0 };

    hvm_get_segment_register(v, x86_seg_gdtr, &gdt);
    hvm_get_segment_register(v, x86_seg_tr, &prev_tr);

    if ( ((tss_sel & 0xfff8) + 7) > gdt.limit )
    {
        hvm_inject_hw_exception((taskswitch_reason == TSW_iret) ?
                             TRAP_invalid_tss : TRAP_gp_fault,
                             tss_sel & 0xfff8);
        goto out;
    }

    optss_desc = hvm_map_entry(gdt.base + (prev_tr.sel & 0xfff8),
                               &otd_writable);
    if ( optss_desc == NULL )
        goto out;

    nptss_desc = hvm_map_entry(gdt.base + (tss_sel & 0xfff8), &ntd_writable);
    if ( nptss_desc == NULL )
        goto out;

    tss_desc = *nptss_desc;
    tr.sel = tss_sel;
    tr.base = (((tss_desc.b <<  0) & 0xff000000u) |
               ((tss_desc.b << 16) & 0x00ff0000u) |
               ((tss_desc.a >> 16) & 0x0000ffffu));
    tr.attr.bytes = (((tss_desc.b >>  8) & 0x00ffu) |
                     ((tss_desc.b >> 12) & 0x0f00u));
    tr.limit = (tss_desc.b & 0x000f0000u) | (tss_desc.a & 0x0000ffffu);
    if ( tr.attr.fields.g )
        tr.limit = (tr.limit << 12) | 0xfffu;

    if ( tr.attr.fields.type != ((taskswitch_reason == TSW_iret) ? 0xb : 0x9) )
    {
        hvm_inject_hw_exception(
            (taskswitch_reason == TSW_iret) ? TRAP_invalid_tss : TRAP_gp_fault,
            tss_sel & 0xfff8);
        goto out;
    }

    if ( !tr.attr.fields.p )
    {
        hvm_inject_hw_exception(TRAP_no_segment, tss_sel & 0xfff8);
        goto out;
    }

    if ( tr.limit < (sizeof(tss)-1) )
    {
        hvm_inject_hw_exception(TRAP_invalid_tss, tss_sel & 0xfff8);
        goto out;
    }

    rc = hvm_copy_from_guest_virt(
        &tss, prev_tr.base, sizeof(tss), PFEC_page_present);
    if ( rc != HVMCOPY_okay )
        goto out;

    eflags = regs->eflags;
    if ( taskswitch_reason == TSW_iret )
        eflags &= ~X86_EFLAGS_NT;

    tss.cr3    = v->arch.hvm_vcpu.guest_cr[3];
    tss.eip    = regs->eip;
    tss.eflags = eflags;
    tss.eax    = regs->eax;
    tss.ecx    = regs->ecx;
    tss.edx    = regs->edx;
    tss.ebx    = regs->ebx;
    tss.esp    = regs->esp;
    tss.ebp    = regs->ebp;
    tss.esi    = regs->esi;
    tss.edi    = regs->edi;

    hvm_get_segment_register(v, x86_seg_es, &segr);
    tss.es = segr.sel;
    hvm_get_segment_register(v, x86_seg_cs, &segr);
    tss.cs = segr.sel;
    hvm_get_segment_register(v, x86_seg_ss, &segr);
    tss.ss = segr.sel;
    hvm_get_segment_register(v, x86_seg_ds, &segr);
    tss.ds = segr.sel;
    hvm_get_segment_register(v, x86_seg_fs, &segr);
    tss.fs = segr.sel;
    hvm_get_segment_register(v, x86_seg_gs, &segr);
    tss.gs = segr.sel;
    hvm_get_segment_register(v, x86_seg_ldtr, &segr);
    tss.ldt = segr.sel;

    rc = hvm_copy_to_guest_virt(
        prev_tr.base, &tss, sizeof(tss), PFEC_page_present);
    if ( rc != HVMCOPY_okay )
        goto out;

    rc = hvm_copy_from_guest_virt(
        &tss, tr.base, sizeof(tss), PFEC_page_present);
    /*
     * Note: The HVMCOPY_gfn_shared case could be optimised, if the callee
     * functions knew we want RO access.
     */
    if ( rc != HVMCOPY_okay )
        goto out;

    if ( hvm_load_segment_selector(x86_seg_ldtr, tss.ldt, 0) )
        goto out;

    if ( hvm_set_cr3(tss.cr3, 1) )
        goto out;

    regs->eip    = tss.eip;
    regs->eflags = tss.eflags | 2;
    regs->eax    = tss.eax;
    regs->ecx    = tss.ecx;
    regs->edx    = tss.edx;
    regs->ebx    = tss.ebx;
    regs->esp    = tss.esp;
    regs->ebp    = tss.ebp;
    regs->esi    = tss.esi;
    regs->edi    = tss.edi;

    if ( (taskswitch_reason == TSW_call_or_int) )
    {
        regs->eflags |= X86_EFLAGS_NT;
        tss.back_link = prev_tr.sel;
    }

    exn_raised = 0;
    if ( hvm_load_segment_selector(x86_seg_es, tss.es, tss.eflags) ||
         hvm_load_segment_selector(x86_seg_cs, tss.cs, tss.eflags) ||
         hvm_load_segment_selector(x86_seg_ss, tss.ss, tss.eflags) ||
         hvm_load_segment_selector(x86_seg_ds, tss.ds, tss.eflags) ||
         hvm_load_segment_selector(x86_seg_fs, tss.fs, tss.eflags) ||
         hvm_load_segment_selector(x86_seg_gs, tss.gs, tss.eflags) )
        exn_raised = 1;

    rc = hvm_copy_to_guest_virt(
        tr.base, &tss, sizeof(tss), PFEC_page_present);
    if ( rc == HVMCOPY_bad_gva_to_gfn )
        exn_raised = 1;
    else if ( rc != HVMCOPY_okay )
        goto out;

    if ( (tss.trace & 1) && !exn_raised )
        hvm_inject_hw_exception(TRAP_debug, HVM_DELIVER_NO_ERROR_CODE);

    tr.attr.fields.type = 0xb; /* busy 32-bit tss */
    hvm_set_segment_register(v, x86_seg_tr, &tr);

    v->arch.hvm_vcpu.guest_cr[0] |= X86_CR0_TS;
    hvm_update_guest_cr(v, 0);

    if ( (taskswitch_reason == TSW_iret ||
          taskswitch_reason == TSW_jmp) && otd_writable )
        clear_bit(41, optss_desc); /* clear B flag of old task */

    if ( taskswitch_reason != TSW_iret && ntd_writable )
        set_bit(41, nptss_desc); /* set B flag of new task */

    if ( errcode >= 0 )
    {
        struct segment_register reg;
        unsigned long linear_addr;
        regs->esp -= 4;
        hvm_get_segment_register(current, x86_seg_ss, &reg);
        /* Todo: do not ignore access faults here. */
        if ( hvm_virtual_to_linear_addr(x86_seg_ss, &reg, regs->esp,
                                        4, hvm_access_write, 32,
                                        &linear_addr) )
            hvm_copy_to_guest_virt_nofault(linear_addr, &errcode, 4, 0);
    }

 out:
    hvm_unmap_entry(optss_desc);
    hvm_unmap_entry(nptss_desc);
}","void hvm_task_switch(
    uint16_t VAR_0, enum hvm_task_switch_reason VAR_1,
    int32_t VAR_2)
{
    struct vcpu *VAR_3 = VAR_4;
    struct cpu_user_regs *VAR_5 = guest_cpu_user_regs();
    struct segment_register VAR_6, VAR_7, VAR_8, VAR_9;
    struct desc_struct *VAR_10 = NULL, *VAR_11 = NULL, VAR_12;
    bool_t VAR_13, VAR_14;
    unsigned long VAR_15;
    int VAR_16, VAR_17;
    struct {
        u16 back_link,__blh;
        u32 esp0;
        u16 ss0, _0;
        u32 esp1;
        u16 ss1, _1;
        u32 esp2;
        u16 ss2, _2;
        u32 cr3, eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi;
        u16 es, _3, cs, _4, ss, _5, ds, _6, fs, _7, gs, _8, ldt, _9;
        u16 trace, iomap;
    } VAR_18 = { 0 };

    hvm_get_segment_register(VAR_3, VAR_19, &VAR_6);
    hvm_get_segment_register(VAR_3, VAR_20, &VAR_8);

    if ( ((VAR_0 & 0xfff8) + 7) > VAR_6.limit )
    {
        hvm_inject_hw_exception((VAR_1 == VAR_21) ?
                             VAR_22 : VAR_23,
                             VAR_0 & 0xfff8);
        goto out;
    }

    VAR_10 = hvm_map_entry(VAR_6.base + (VAR_8.sel & 0xfff8),
                               &VAR_13);
    if ( VAR_10 == NULL )
        goto out;

    VAR_11 = hvm_map_entry(VAR_6.base + (VAR_0 & 0xfff8), &VAR_14);
    if ( VAR_11 == NULL )
        goto out;

    VAR_12 = *VAR_11;
    VAR_7.sel = VAR_0;
    VAR_7.base = (((VAR_12.b <<  0) & 0xff000000u) |
               ((VAR_12.b << 16) & 0x00ff0000u) |
               ((VAR_12.a >> 16) & 0x0000ffffu));
    VAR_7.attr.bytes = (((VAR_12.b >>  8) & 0x00ffu) |
                     ((VAR_12.b >> 12) & 0x0f00u));
    VAR_7.limit = (VAR_12.b & 0x000f0000u) | (VAR_12.a & 0x0000ffffu);
    if ( VAR_7.attr.fields.g )
        VAR_7.limit = (VAR_7.limit << 12) | 0xfffu;

    if ( VAR_7.attr.fields.type != ((VAR_1 == VAR_21) ? 0xb : 0x9) )
    {
        hvm_inject_hw_exception(
            (VAR_1 == VAR_21) ? VAR_22 : VAR_23,
            VAR_0 & 0xfff8);
        goto out;
    }

    if ( !VAR_7.attr.fields.p )
    {
        hvm_inject_hw_exception(VAR_24, VAR_0 & 0xfff8);
        goto out;
    }

    if ( VAR_7.limit < (sizeof(VAR_18)-1) )
    {
        hvm_inject_hw_exception(VAR_22, VAR_0 & 0xfff8);
        goto out;
    }

    VAR_17 = hvm_copy_from_guest_virt(
        &VAR_18, VAR_8.base, sizeof(VAR_18), VAR_25);
    if ( VAR_17 != VAR_26 )
        goto out;

    VAR_15 = VAR_5->eflags;
    if ( VAR_1 == VAR_21 )
        VAR_15 &= ~VAR_27;

    VAR_18.cr3    = VAR_3->arch.hvm_vcpu.guest_cr[3];
    VAR_18.eip    = VAR_5->eip;
    VAR_18.eflags = VAR_15;
    VAR_18.eax    = VAR_5->eax;
    VAR_18.ecx    = VAR_5->ecx;
    VAR_18.edx    = VAR_5->edx;
    VAR_18.ebx    = VAR_5->ebx;
    VAR_18.esp    = VAR_5->esp;
    VAR_18.ebp    = VAR_5->ebp;
    VAR_18.esi    = VAR_5->esi;
    VAR_18.edi    = VAR_5->edi;

    hvm_get_segment_register(VAR_3, VAR_28, &VAR_9);
    VAR_18.es = VAR_9.sel;
    hvm_get_segment_register(VAR_3, VAR_29, &VAR_9);
    VAR_18.cs = VAR_9.sel;
    hvm_get_segment_register(VAR_3, VAR_30, &VAR_9);
    VAR_18.ss = VAR_9.sel;
    hvm_get_segment_register(VAR_3, VAR_31, &VAR_9);
    VAR_18.ds = VAR_9.sel;
    hvm_get_segment_register(VAR_3, VAR_32, &VAR_9);
    VAR_18.fs = VAR_9.sel;
    hvm_get_segment_register(VAR_3, VAR_33, &VAR_9);
    VAR_18.gs = VAR_9.sel;
    hvm_get_segment_register(VAR_3, VAR_34, &VAR_9);
    VAR_18.ldt = VAR_9.sel;

    VAR_17 = hvm_copy_to_guest_virt(
        VAR_8.base, &VAR_18, sizeof(VAR_18), VAR_25);
    if ( VAR_17 != VAR_26 )
        goto out;

    VAR_17 = hvm_copy_from_guest_virt(
        &VAR_18, VAR_7.base, sizeof(VAR_18), VAR_25);
    /* COMMENT_0 */
                                                                          
                                        
       
    if ( VAR_17 != VAR_26 )
        goto out;

    if ( hvm_load_segment_selector(VAR_34, VAR_18.ldt, 0) )
        goto out;

    if ( hvm_set_cr3(VAR_18.cr3, 1) )
        goto out;

    VAR_5->eip    = VAR_18.eip;
    VAR_5->eflags = VAR_18.eflags | 2;
    VAR_5->eax    = VAR_18.eax;
    VAR_5->ecx    = VAR_18.ecx;
    VAR_5->edx    = VAR_18.edx;
    VAR_5->ebx    = VAR_18.ebx;
    VAR_5->esp    = VAR_18.esp;
    VAR_5->ebp    = VAR_18.ebp;
    VAR_5->esi    = VAR_18.esi;
    VAR_5->edi    = VAR_18.edi;

    if ( (VAR_1 == VAR_35) )
    {
        VAR_5->eflags |= VAR_27;
        VAR_18.back_link = VAR_8.sel;
    }

    VAR_16 = 0;
    if ( hvm_load_segment_selector(VAR_28, VAR_18.es, VAR_18.eflags) ||
         hvm_load_segment_selector(VAR_29, VAR_18.cs, VAR_18.eflags) ||
         hvm_load_segment_selector(VAR_30, VAR_18.ss, VAR_18.eflags) ||
         hvm_load_segment_selector(VAR_31, VAR_18.ds, VAR_18.eflags) ||
         hvm_load_segment_selector(VAR_32, VAR_18.fs, VAR_18.eflags) ||
         hvm_load_segment_selector(VAR_33, VAR_18.gs, VAR_18.eflags) )
        VAR_16 = 1;

    VAR_17 = hvm_copy_to_guest_virt(
        VAR_7.base, &VAR_18, sizeof(VAR_18), VAR_25);
    if ( VAR_17 == VAR_36 )
        VAR_16 = 1;
    else if ( VAR_17 != VAR_26 )
        goto out;

    if ( (VAR_18.trace & 1) && !VAR_16 )
        hvm_inject_hw_exception(VAR_37, VAR_38);

    VAR_7.attr.fields.type = 0xb; /* COMMENT_4 */
    hvm_set_segment_register(VAR_3, VAR_20, &VAR_7);

    VAR_3->arch.hvm_vcpu.guest_cr[0] |= VAR_39;
    hvm_update_guest_cr(VAR_3, 0);

    if ( (VAR_1 == VAR_21 ||
          VAR_1 == VAR_40) && VAR_13 )
        clear_bit(41, VAR_10); /* COMMENT_5 */

    if ( VAR_1 != VAR_21 && VAR_14 )
        set_bit(41, VAR_11); /* COMMENT_6 */

    if ( VAR_2 >= 0 )
    {
        struct segment_register VAR_41;
        unsigned long VAR_42;
        VAR_5->esp -= 4;
        hvm_get_segment_register(VAR_4, VAR_30, &VAR_41);
        /* COMMENT_7 */
        if ( hvm_virtual_to_linear_addr(VAR_30, &VAR_41, VAR_5->esp,
                                        4, VAR_43, 32,
                                        &VAR_42) )
            hvm_copy_to_guest_virt_nofault(VAR_42, &VAR_2, 4, 0);
    }

 out:
    hvm_unmap_entry(VAR_10);
    hvm_unmap_entry(VAR_11);
}",xen-project/xen/93aa42b85ae0084ba7b749d0e990c94fbf0c17e3/hvm.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -123,6 +123,8 @@
     if ( rc != HVMCOPY_okay )
         goto out;
 
+    if ( hvm_load_segment_selector(x86_seg_ldtr, tss.ldt, 0) )
+        goto out;
 
     if ( hvm_set_cr3(tss.cr3, 1) )
         goto out;
@@ -145,13 +147,12 @@
     }
 
     exn_raised = 0;
-    if ( hvm_load_segment_selector(x86_seg_ldtr, tss.ldt) ||
-         hvm_load_segment_selector(x86_seg_es, tss.es) ||
-         hvm_load_segment_selector(x86_seg_cs, tss.cs) ||
-         hvm_load_segment_selector(x86_seg_ss, tss.ss) ||
-         hvm_load_segment_selector(x86_seg_ds, tss.ds) ||
-         hvm_load_segment_selector(x86_seg_fs, tss.fs) ||
-         hvm_load_segment_selector(x86_seg_gs, tss.gs) )
+    if ( hvm_load_segment_selector(x86_seg_es, tss.es, tss.eflags) ||
+         hvm_load_segment_selector(x86_seg_cs, tss.cs, tss.eflags) ||
+         hvm_load_segment_selector(x86_seg_ss, tss.ss, tss.eflags) ||
+         hvm_load_segment_selector(x86_seg_ds, tss.ds, tss.eflags) ||
+         hvm_load_segment_selector(x86_seg_fs, tss.fs, tss.eflags) ||
+         hvm_load_segment_selector(x86_seg_gs, tss.gs, tss.eflags) )
         exn_raised = 1;
 
     rc = hvm_copy_to_guest_virt(","{'deleted_lines': ['    if ( hvm_load_segment_selector(x86_seg_ldtr, tss.ldt) ||', '         hvm_load_segment_selector(x86_seg_es, tss.es) ||', '         hvm_load_segment_selector(x86_seg_cs, tss.cs) ||', '         hvm_load_segment_selector(x86_seg_ss, tss.ss) ||', '         hvm_load_segment_selector(x86_seg_ds, tss.ds) ||', '         hvm_load_segment_selector(x86_seg_fs, tss.fs) ||', '         hvm_load_segment_selector(x86_seg_gs, tss.gs) )'], 'added_lines': ['    if ( hvm_load_segment_selector(x86_seg_ldtr, tss.ldt, 0) )', '        goto out;', '    if ( hvm_load_segment_selector(x86_seg_es, tss.es, tss.eflags) ||', '         hvm_load_segment_selector(x86_seg_cs, tss.cs, tss.eflags) ||', '         hvm_load_segment_selector(x86_seg_ss, tss.ss, tss.eflags) ||', '         hvm_load_segment_selector(x86_seg_ds, tss.ds, tss.eflags) ||', '         hvm_load_segment_selector(x86_seg_fs, tss.fs, tss.eflags) ||', '         hvm_load_segment_selector(x86_seg_gs, tss.gs, tss.eflags) )']}",True,"Xen 4.0.x through 4.7.x mishandle x86 task switches to VM86 mode, which allows local 32-bit x86 HVM guest OS users to gain privileges or cause a denial of service (guest OS crash) by leveraging a guest operating system that uses hardware task switching and allows a new task to start in VM86 mode.",7.8,HIGH,2,test,2016-11-22T12:45:44Z,1
CVE-2016-9914,['CWE-401'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,qemu,"9pfs: add cleanup operation in FileOperations

Currently, the backend of VirtFS doesn't have a cleanup
function. This will lead resource leak issues if the backed
driver allocates resources. This patch addresses this issue.

Signed-off-by: Li Qiang <liq3ea@gmail.com>
Reviewed-by: Greg Kurz <groug@kaod.org>
Signed-off-by: Greg Kurz <groug@kaod.org>",702dbcc274e2ca43be20ba64c758c0ca57dab91d,https://github.com/qemu/qemu/commit/702dbcc274e2ca43be20ba64c758c0ca57dab91d,hw/9pfs/9p.c,v9fs_device_unrealize_common,"void v9fs_device_unrealize_common(V9fsState *s, Error **errp)
{
g_free(s->tag);
g_free(s->ctx.fs_root);
}","void v9fs_device_unrealize_common(V9fsState *VAR_0, Error **VAR_1)
{
g_free(VAR_0->tag);
g_free(VAR_0->ctx.fs_root);
}",qemu/702dbcc274e2ca43be20ba64c758c0ca57dab91d/9p.c/vul/before/1.json,"void v9fs_device_unrealize_common(V9fsState *s, Error **errp)
{
    if (s->ops->cleanup) {
        s->ops->cleanup(&s->ctx);
    }
    g_free(s->tag);
    g_free(s->ctx.fs_root);
}","void v9fs_device_unrealize_common(V9fsState *VAR_0, Error **VAR_1)
{
    if (VAR_0->ops->cleanup) {
        VAR_0->ops->cleanup(&VAR_0->ctx);
    }
    g_free(VAR_0->tag);
    g_free(VAR_0->ctx.fs_root);
}",qemu/702dbcc274e2ca43be20ba64c758c0ca57dab91d/9p.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,5 +1,8 @@
 void v9fs_device_unrealize_common(V9fsState *s, Error **errp)
 {
+    if (s->ops->cleanup) {
+        s->ops->cleanup(&s->ctx);
+    }
     g_free(s->tag);
     g_free(s->ctx.fs_root);
 }","{'deleted_lines': [], 'added_lines': ['    if (s->ops->cleanup) {', '        s->ops->cleanup(&s->ctx);', '    }']}",True,Memory leak in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local privileged guest OS users to cause a denial of service (host memory consumption and possibly QEMU process crash) by leveraging a missing cleanup operation in FileOperations.,6.5,MEDIUM,1,test,2016-11-23T12:53:34Z,1
CVE-2016-9914,['CWE-401'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,qemu,"9pfs: add cleanup operation in FileOperations

Currently, the backend of VirtFS doesn't have a cleanup
function. This will lead resource leak issues if the backed
driver allocates resources. This patch addresses this issue.

Signed-off-by: Li Qiang <liq3ea@gmail.com>
Reviewed-by: Greg Kurz <groug@kaod.org>
Signed-off-by: Greg Kurz <groug@kaod.org>",702dbcc274e2ca43be20ba64c758c0ca57dab91d,https://github.com/qemu/qemu/commit/702dbcc274e2ca43be20ba64c758c0ca57dab91d,hw/9pfs/9p.c,v9fs_device_realize_common,"int v9fs_device_realize_common(V9fsState *s, Error **errp)
{
V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);
int i, len;
struct stat stat;
FsDriverEntry *fse;
V9fsPath path;
int rc = 1;
QLIST_INIT(&s->free_list);
QLIST_INIT(&s->active_list);
for (i = 0; i < (MAX_REQ - 1); i++) {
QLIST_INSERT_HEAD(&s->free_list, &v->pdus[i], next);
v->pdus[i].s = s;
v->pdus[i].idx = i;
}
v9fs_path_init(&path);
fse = get_fsdev_fsentry(s->fsconf.fsdev_id);
if (!fse) {
error_setg(errp, ""9pfs device couldn't find fsdev with the ""
""id = %s"",
s->fsconf.fsdev_id ? s->fsconf.fsdev_id : ""NULL"");
goto out;
}
if (!s->fsconf.tag) {
error_setg(errp, ""fsdev with id %s needs mount_tag arguments"",
s->fsconf.fsdev_id);
goto out;
}
s->ctx.export_flags = fse->export_flags;
s->ctx.fs_root = g_strdup(fse->path);
s->ctx.exops.get_st_gen = NULL;
len = strlen(s->fsconf.tag);
if (len > MAX_TAG_LEN - 1) {
error_setg(errp, ""mount tag '%s' (%d bytes) is longer than ""
""maximum (%d bytes)"", s->fsconf.tag, len, MAX_TAG_LEN - 1);
goto out;
}
s->tag = g_strdup(s->fsconf.tag);
s->ctx.uid = -1;
s->ops = fse->ops;
s->fid_list = NULL;
qemu_co_rwlock_init(&s->rename_lock);
if (s->ops->init(&s->ctx) < 0) {
error_setg(errp, ""9pfs Failed to initialize fs-driver with id:%s""
"" and export path:%s"", s->fsconf.fsdev_id, s->ctx.fs_root);
goto out;
}
if (s->ops->name_to_path(&s->ctx, NULL, ""/"", &path) < 0) {
error_setg(errp,
""error in converting name to path %s"", strerror(errno));
goto out;
}
if (s->ops->lstat(&s->ctx, &path, &stat)) {
error_setg(errp, ""share path %s does not exist"", fse->path);
goto out;
} else if (!S_ISDIR(stat.st_mode)) {
error_setg(errp, ""share path %s is not a directory"", fse->path);
goto out;
}
v9fs_path_free(&path);
rc = 0;
out:
if (rc) {
g_free(s->tag);
g_free(s->ctx.fs_root);
v9fs_path_free(&path);
}
return rc;
}","int v9fs_device_realize_common(V9fsState *VAR_0, Error **VAR_1)
{
V9fsVirtioState *VAR_2 = container_of(VAR_0, V9fsVirtioState, VAR_3);
int VAR_4, VAR_5;
struct stat stat;
FsDriverEntry *VAR_6;
V9fsPath VAR_7;
int VAR_8 = 1;
QLIST_INIT(&VAR_0->free_list);
QLIST_INIT(&VAR_0->active_list);
for (VAR_4 = 0; VAR_4 < (VAR_9 - 1); VAR_4++) {
QLIST_INSERT_HEAD(&VAR_0->free_list, &VAR_2->pdus[VAR_4], VAR_10);
VAR_2->pdus[VAR_4].s = VAR_0;
VAR_2->pdus[VAR_4].idx = VAR_4;
}
v9fs_path_init(&VAR_7);
VAR_6 = get_fsdev_fsentry(VAR_0->fsconf.fsdev_id);
if (!VAR_6) {
error_setg(VAR_1, ""9pfs device couldn't find fsdev with the ""
""id = %s"",
VAR_0->fsconf.fsdev_id ? VAR_0->fsconf.fsdev_id : ""NULL"");
goto out;
}
if (!VAR_0->fsconf.tag) {
error_setg(VAR_1, ""fsdev with id %s needs mount_tag arguments"",
VAR_0->fsconf.fsdev_id);
goto out;
}
VAR_0->ctx.export_flags = VAR_6->export_flags;
VAR_0->ctx.fs_root = g_strdup(VAR_6->path);
VAR_0->ctx.exops.get_st_gen = NULL;
VAR_5 = strlen(VAR_0->fsconf.tag);
if (VAR_5 > VAR_11 - 1) {
error_setg(VAR_1, ""mount tag '%s' (%d bytes) is longer than ""
""maximum (%d bytes)"", VAR_0->fsconf.tag, VAR_5, VAR_11 - 1);
goto out;
}
VAR_0->tag = g_strdup(VAR_0->fsconf.tag);
VAR_0->ctx.uid = -1;
VAR_0->ops = VAR_6->ops;
VAR_0->fid_list = NULL;
qemu_co_rwlock_init(&VAR_0->rename_lock);
if (VAR_0->ops->init(&VAR_0->ctx) < 0) {
error_setg(VAR_1, ""9pfs Failed to initialize fs-driver with id:%s""
"" and export path:%s"", VAR_0->fsconf.fsdev_id, VAR_0->ctx.fs_root);
goto out;
}
if (VAR_0->ops->name_to_path(&VAR_0->ctx, NULL, ""/"", &VAR_7) < 0) {
error_setg(VAR_1,
""error in converting name to path %s"", strerror(VAR_12));
goto out;
}
if (VAR_0->ops->lstat(&VAR_0->ctx, &VAR_7, &stat)) {
error_setg(VAR_1, ""share path %s does not exist"", VAR_6->path);
goto out;
} else if (!S_ISDIR(stat.st_mode)) {
error_setg(VAR_1, ""share path %s is not a directory"", VAR_6->path);
goto out;
}
v9fs_path_free(&VAR_7);
VAR_8 = 0;
out:
if (VAR_8) {
g_free(VAR_0->tag);
g_free(VAR_0->ctx.fs_root);
v9fs_path_free(&VAR_7);
}
return VAR_8;
}",qemu/702dbcc274e2ca43be20ba64c758c0ca57dab91d/9p.c/vul/before/0.json,"int v9fs_device_realize_common(V9fsState *s, Error **errp)
{
    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);
    int i, len;
    struct stat stat;
    FsDriverEntry *fse;
    V9fsPath path;
    int rc = 1;

    /* initialize pdu allocator */
    QLIST_INIT(&s->free_list);
    QLIST_INIT(&s->active_list);
    for (i = 0; i < (MAX_REQ - 1); i++) {
        QLIST_INSERT_HEAD(&s->free_list, &v->pdus[i], next);
        v->pdus[i].s = s;
        v->pdus[i].idx = i;
    }

    v9fs_path_init(&path);

    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);

    if (!fse) {
        /* We don't have a fsdev identified by fsdev_id */
        error_setg(errp, ""9pfs device couldn't find fsdev with the ""
                   ""id = %s"",
                   s->fsconf.fsdev_id ? s->fsconf.fsdev_id : ""NULL"");
        goto out;
    }

    if (!s->fsconf.tag) {
        /* we haven't specified a mount_tag */
        error_setg(errp, ""fsdev with id %s needs mount_tag arguments"",
                   s->fsconf.fsdev_id);
        goto out;
    }

    s->ctx.export_flags = fse->export_flags;
    s->ctx.fs_root = g_strdup(fse->path);
    s->ctx.exops.get_st_gen = NULL;
    len = strlen(s->fsconf.tag);
    if (len > MAX_TAG_LEN - 1) {
        error_setg(errp, ""mount tag '%s' (%d bytes) is longer than ""
                   ""maximum (%d bytes)"", s->fsconf.tag, len, MAX_TAG_LEN - 1);
        goto out;
    }

    s->tag = g_strdup(s->fsconf.tag);
    s->ctx.uid = -1;

    s->ops = fse->ops;

    s->fid_list = NULL;
    qemu_co_rwlock_init(&s->rename_lock);

    if (s->ops->init(&s->ctx) < 0) {
        error_setg(errp, ""9pfs Failed to initialize fs-driver with id:%s""
                   "" and export path:%s"", s->fsconf.fsdev_id, s->ctx.fs_root);
        goto out;
    }

    /*
     * Check details of export path, We need to use fs driver
     * call back to do that. Since we are in the init path, we don't
     * use co-routines here.
     */
    if (s->ops->name_to_path(&s->ctx, NULL, ""/"", &path) < 0) {
        error_setg(errp,
                   ""error in converting name to path %s"", strerror(errno));
        goto out;
    }
    if (s->ops->lstat(&s->ctx, &path, &stat)) {
        error_setg(errp, ""share path %s does not exist"", fse->path);
        goto out;
    } else if (!S_ISDIR(stat.st_mode)) {
        error_setg(errp, ""share path %s is not a directory"", fse->path);
        goto out;
    }
    v9fs_path_free(&path);

    rc = 0;
out:
    if (rc) {
        if (s->ops->cleanup && s->ctx.private) {
            s->ops->cleanup(&s->ctx);
        }
        g_free(s->tag);
        g_free(s->ctx.fs_root);
        v9fs_path_free(&path);
    }
    return rc;
}","int v9fs_device_realize_common(V9fsState *VAR_0, Error **VAR_1)
{
    V9fsVirtioState *VAR_2 = container_of(VAR_0, V9fsVirtioState, VAR_3);
    int VAR_4, VAR_5;
    struct stat stat;
    FsDriverEntry *VAR_6;
    V9fsPath VAR_7;
    int VAR_8 = 1;

    /* COMMENT_0 */
    QLIST_INIT(&VAR_0->free_list);
    QLIST_INIT(&VAR_0->active_list);
    for (VAR_4 = 0; VAR_4 < (VAR_9 - 1); VAR_4++) {
        QLIST_INSERT_HEAD(&VAR_0->free_list, &VAR_2->pdus[VAR_4], VAR_10);
        VAR_2->pdus[VAR_4].s = VAR_0;
        VAR_2->pdus[VAR_4].idx = VAR_4;
    }

    v9fs_path_init(&VAR_7);

    VAR_6 = get_fsdev_fsentry(VAR_0->fsconf.fsdev_id);

    if (!VAR_6) {
        /* COMMENT_1 */
        error_setg(VAR_1, ""9pfs device couldn't find fsdev with the ""
                   ""id = %s"",
                   VAR_0->fsconf.fsdev_id ? VAR_0->fsconf.fsdev_id : ""NULL"");
        goto out;
    }

    if (!VAR_0->fsconf.tag) {
        /* COMMENT_2 */
        error_setg(VAR_1, ""fsdev with id %s needs mount_tag arguments"",
                   VAR_0->fsconf.fsdev_id);
        goto out;
    }

    VAR_0->ctx.export_flags = VAR_6->export_flags;
    VAR_0->ctx.fs_root = g_strdup(VAR_6->path);
    VAR_0->ctx.exops.get_st_gen = NULL;
    VAR_5 = strlen(VAR_0->fsconf.tag);
    if (VAR_5 > VAR_11 - 1) {
        error_setg(VAR_1, ""mount tag '%s' (%d bytes) is longer than ""
                   ""maximum (%d bytes)"", VAR_0->fsconf.tag, VAR_5, VAR_11 - 1);
        goto out;
    }

    VAR_0->tag = g_strdup(VAR_0->fsconf.tag);
    VAR_0->ctx.uid = -1;

    VAR_0->ops = VAR_6->ops;

    VAR_0->fid_list = NULL;
    qemu_co_rwlock_init(&VAR_0->rename_lock);

    if (VAR_0->ops->init(&VAR_0->ctx) < 0) {
        error_setg(VAR_1, ""9pfs Failed to initialize fs-driver with id:%s""
                   "" and export path:%s"", VAR_0->fsconf.fsdev_id, VAR_0->ctx.fs_root);
        goto out;
    }

    /* COMMENT_3 */
                                                             
                                                                    
                            
       
    if (VAR_0->ops->name_to_path(&VAR_0->ctx, NULL, ""/"", &VAR_7) < 0) {
        error_setg(VAR_1,
                   ""error in converting name to path %s"", strerror(VAR_12));
        goto out;
    }
    if (VAR_0->ops->lstat(&VAR_0->ctx, &VAR_7, &stat)) {
        error_setg(VAR_1, ""share path %s does not exist"", VAR_6->path);
        goto out;
    } else if (!S_ISDIR(stat.st_mode)) {
        error_setg(VAR_1, ""share path %s is not a directory"", VAR_6->path);
        goto out;
    }
    v9fs_path_free(&VAR_7);

    VAR_8 = 0;
out:
    if (VAR_8) {
        if (VAR_0->ops->cleanup && VAR_0->ctx.private) {
            VAR_0->ops->cleanup(&VAR_0->ctx);
        }
        g_free(VAR_0->tag);
        g_free(VAR_0->ctx.fs_root);
        v9fs_path_free(&VAR_7);
    }
    return VAR_8;
}",qemu/702dbcc274e2ca43be20ba64c758c0ca57dab91d/9p.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -81,6 +81,9 @@
     rc = 0;
 out:
     if (rc) {
+        if (s->ops->cleanup && s->ctx.private) {
+            s->ops->cleanup(&s->ctx);
+        }
         g_free(s->tag);
         g_free(s->ctx.fs_root);
         v9fs_path_free(&path);","{'deleted_lines': [], 'added_lines': ['        if (s->ops->cleanup && s->ctx.private) {', '            s->ops->cleanup(&s->ctx);', '        }']}",True,Memory leak in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local privileged guest OS users to cause a denial of service (host memory consumption and possibly QEMU process crash) by leveraging a missing cleanup operation in FileOperations.,6.5,MEDIUM,1,test,2016-11-23T12:53:34Z,1
CVE-2016-8655,"['CWE-362', 'CWE-416']",AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"packet: fix race condition in packet_set_ring

When packet_set_ring creates a ring buffer it will initialize a
struct timer_list if the packet version is TPACKET_V3. This value
can then be raced by a different thread calling setsockopt to
set the version to TPACKET_V1 before packet_set_ring has finished.

This leads to a use-after-free on a function pointer in the
struct timer_list when the socket is closed as the previously
initialized timer will not be deleted.

The bug is fixed by taking lock_sock(sk) in packet_setsockopt when
changing the packet version while also taking the lock at the start
of packet_set_ring.

Fixes: f6fb8f100b80 (""af-packet: TPACKET_V3 flexible buffer implementation."")
Signed-off-by: Philip Pettersson <philip.pettersson@gmail.com>
Signed-off-by: Eric Dumazet <edumazet@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",84ac7260236a49c79eede91617700174c2c19b0c,https://github.com/torvalds/linux/commit/84ac7260236a49c79eede91617700174c2c19b0c,net/packet/af_packet.c,packet_set_ring,"static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,
int closing, int tx_ring)
{
struct pgv *pg_vec = NULL;
struct packet_sock *po = pkt_sk(sk);
int was_running, order = 0;
struct packet_ring_buffer *rb;
struct sk_buff_head *rb_queue;
__be16 num;
int err = -EINVAL;
struct tpacket_req *req = &req_u->req;
if (!closing && tx_ring && (po->tp_version > TPACKET_V2)) {
net_warn_ratelimited(""Tx-ring is not supported.\n"");
goto out;
}
rb = tx_ring ? &po->tx_ring : &po->rx_ring;
rb_queue = tx_ring ? &sk->sk_write_queue : &sk->sk_receive_queue;
err = -EBUSY;
if (!closing) {
if (atomic_read(&po->mapped))
goto out;
if (packet_read_pending(rb))
goto out;
}
if (req->tp_block_nr) {
err = -EBUSY;
if (unlikely(rb->pg_vec))
goto out;
switch (po->tp_version) {
case TPACKET_V1:
po->tp_hdrlen = TPACKET_HDRLEN;
break;
case TPACKET_V2:
po->tp_hdrlen = TPACKET2_HDRLEN;
break;
case TPACKET_V3:
po->tp_hdrlen = TPACKET3_HDRLEN;
break;
}
err = -EINVAL;
if (unlikely((int)req->tp_block_size <= 0))
goto out;
if (unlikely(!PAGE_ALIGNED(req->tp_block_size)))
goto out;
if (po->tp_version >= TPACKET_V3 &&
(int)(req->tp_block_size -
BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv)) <= 0)
goto out;
if (unlikely(req->tp_frame_size < po->tp_hdrlen +
po->tp_reserve))
goto out;
if (unlikely(req->tp_frame_size & (TPACKET_ALIGNMENT - 1)))
goto out;
rb->frames_per_block = req->tp_block_size / req->tp_frame_size;
if (unlikely(rb->frames_per_block == 0))
goto out;
if (unlikely((rb->frames_per_block * req->tp_block_nr) !=
req->tp_frame_nr))
goto out;
err = -ENOMEM;
order = get_order(req->tp_block_size);
pg_vec = alloc_pg_vec(req, order);
if (unlikely(!pg_vec))
goto out;
switch (po->tp_version) {
case TPACKET_V3:
if (!tx_ring)
init_prb_bdqc(po, rb, pg_vec, req_u);
break;
default:
break;
}
}
else {
err = -EINVAL;
if (unlikely(req->tp_frame_nr))
goto out;
}
lock_sock(sk);
spin_lock(&po->bind_lock);
was_running = po->running;
num = po->num;
if (was_running) {
po->num = 0;
__unregister_prot_hook(sk, false);
}
spin_unlock(&po->bind_lock);
synchronize_net();
err = -EBUSY;
mutex_lock(&po->pg_vec_lock);
if (closing || atomic_read(&po->mapped) == 0) {
err = 0;
spin_lock_bh(&rb_queue->lock);
swap(rb->pg_vec, pg_vec);
rb->frame_max = (req->tp_frame_nr - 1);
rb->head = 0;
rb->frame_size = req->tp_frame_size;
spin_unlock_bh(&rb_queue->lock);
swap(rb->pg_vec_order, order);
swap(rb->pg_vec_len, req->tp_block_nr);
rb->pg_vec_pages = req->tp_block_size/PAGE_SIZE;
po->prot_hook.func = (po->rx_ring.pg_vec) ?
tpacket_rcv : packet_rcv;
skb_queue_purge(rb_queue);
if (atomic_read(&po->mapped))
pr_err(""packet_mmap: vma is busy: %d\n"",
atomic_read(&po->mapped));
}
mutex_unlock(&po->pg_vec_lock);
spin_lock(&po->bind_lock);
if (was_running) {
po->num = num;
register_prot_hook(sk);
}
spin_unlock(&po->bind_lock);
if (closing && (po->tp_version > TPACKET_V2)) {
if (!tx_ring)
prb_shutdown_retire_blk_timer(po, rb_queue);
}
release_sock(sk);
if (pg_vec)
free_pg_vec(pg_vec, order, req->tp_block_nr);
out:
return err;
}","static int packet_set_ring(struct sock *VAR_0, union tpacket_req_u *VAR_1,
int VAR_2, int VAR_3)
{
struct pgv *VAR_4 = NULL;
struct packet_sock *VAR_5 = pkt_sk(VAR_0);
int VAR_6, VAR_7 = 0;
struct packet_ring_buffer *VAR_8;
struct sk_buff_head *VAR_9;
__be16 numVAR_10;
int VAR_11 = -VAR_12;
struct tpacket_req *VAR_13 = &VAR_1->req;
if (!VAR_2 && VAR_3 && (VAR_5->tp_version > VAR_14)) {
net_warn_ratelimited(""Tx-ring is not supported.\n"");
goto out;
}
VAR_8 = VAR_3 ? &VAR_5->tx_ring : &VAR_5->rx_ring;
VAR_9 = VAR_3 ? &VAR_0->sk_write_queue : &VAR_0->sk_receive_queue;
VAR_11 = -VAR_15;
if (!VAR_2) {
if (atomic_read(&VAR_5->mapped))
goto out;
if (packet_read_pending(VAR_8))
goto out;
}
if (VAR_13->tp_block_nr) {
VAR_11 = -VAR_15;
if (unlikely(VAR_8->pg_vec))
goto out;
switch (VAR_5->tp_version) {
case VAR_16:
VAR_5->tp_hdrlen = VAR_17;
break;
case VAR_14:
VAR_5->tp_hdrlen = VAR_18;
break;
case VAR_19:
VAR_5->tp_hdrlen = VAR_20;
break;
}
VAR_11 = -VAR_12;
if (unlikely((int)VAR_13->tp_block_size <= 0))
goto out;
if (unlikely(!PAGE_ALIGNED(VAR_13->tp_block_size)))
goto out;
if (VAR_5->tp_version >= VAR_19 &&
(int)(VAR_13->tp_block_size -
BLK_PLUS_PRIV(VAR_1->req3.tp_sizeof_priv)) <= 0)
goto out;
if (unlikely(VAR_13->tp_frame_size < VAR_5->tp_hdrlen +
VAR_5->tp_reserve))
goto out;
if (unlikely(VAR_13->tp_frame_size & (VAR_21 - 1)))
goto out;
VAR_8->frames_per_block = VAR_13->tp_block_size / VAR_13->tp_frame_size;
if (unlikely(VAR_8->frames_per_block == 0))
goto out;
if (unlikely((VAR_8->frames_per_block * VAR_13->tp_block_nr) !=
VAR_13->tp_frame_nr))
goto out;
VAR_11 = -VAR_22;
VAR_7 = get_order(VAR_13->tp_block_size);
VAR_4 = alloc_pg_vec(VAR_13, VAR_7);
if (unlikely(!VAR_4))
goto out;
switch (VAR_5->tp_version) {
case VAR_19:
if (!VAR_3)
init_prb_bdqc(VAR_5, VAR_8, VAR_4, VAR_1);
break;
default:
break;
}
}
else {
VAR_11 = -VAR_12;
if (unlikely(VAR_13->tp_frame_nr))
goto out;
}
lock_sock(VAR_0);
spin_lock(&VAR_5->bind_lock);
VAR_6 = VAR_5->running;
num = VAR_5->num;
if (VAR_6) {
VAR_5->num = 0;
__unregister_prot_hook(VAR_0, false);
}
spin_unlock(&VAR_5->bind_lock);
synchronize_net();
VAR_11 = -VAR_15;
mutex_lock(&VAR_5->pg_vec_lock);
if (VAR_2 || atomic_read(&VAR_5->mapped) == 0) {
VAR_11 = 0;
spin_lock_bh(&VAR_9->lock);
swap(VAR_8->pg_vec, VAR_4);
VAR_8->frame_max = (VAR_13->tp_frame_nr - 1);
VAR_8->head = 0;
VAR_8->frame_size = VAR_13->tp_frame_size;
spin_unlock_bh(&VAR_9->lock);
swap(VAR_8->pg_vec_order, VAR_7);
swap(VAR_8->pg_vec_len, VAR_13->tp_block_nr);
VAR_8->pg_vec_pages = VAR_13->tp_block_size/VAR_23;
VAR_5->prot_hook.func = (VAR_5->rx_ring.pg_vec) ?
VAR_24 : VAR_25;
skb_queue_purge(VAR_9);
if (atomic_read(&VAR_5->mapped))
pr_err(""packet_mmap: vma is busy: %d\n"",
atomic_read(&VAR_5->mapped));
}
mutex_unlock(&VAR_5->pg_vec_lock);
spin_lock(&VAR_5->bind_lock);
if (VAR_6) {
VAR_5->num = num;
register_prot_hook(VAR_0);
}
spin_unlock(&VAR_5->bind_lock);
if (VAR_2 && (VAR_5->tp_version > VAR_14)) {
if (!VAR_3)
prb_shutdown_retire_blk_timer(VAR_5, VAR_9);
}
release_sock(VAR_0);
if (VAR_4)
free_pg_vec(VAR_4, VAR_7, VAR_13->tp_block_nr);
out:
return VAR_11;
}",torvalds/linux/84ac7260236a49c79eede91617700174c2c19b0c/af_packet.c/vul/before/0.json,"static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,
		int closing, int tx_ring)
{
	struct pgv *pg_vec = NULL;
	struct packet_sock *po = pkt_sk(sk);
	int was_running, order = 0;
	struct packet_ring_buffer *rb;
	struct sk_buff_head *rb_queue;
	__be16 num;
	int err = -EINVAL;
	/* Added to avoid minimal code churn */
	struct tpacket_req *req = &req_u->req;

	lock_sock(sk);
	/* Opening a Tx-ring is NOT supported in TPACKET_V3 */
	if (!closing && tx_ring && (po->tp_version > TPACKET_V2)) {
		net_warn_ratelimited(""Tx-ring is not supported.\n"");
		goto out;
	}

	rb = tx_ring ? &po->tx_ring : &po->rx_ring;
	rb_queue = tx_ring ? &sk->sk_write_queue : &sk->sk_receive_queue;

	err = -EBUSY;
	if (!closing) {
		if (atomic_read(&po->mapped))
			goto out;
		if (packet_read_pending(rb))
			goto out;
	}

	if (req->tp_block_nr) {
		/* Sanity tests and some calculations */
		err = -EBUSY;
		if (unlikely(rb->pg_vec))
			goto out;

		switch (po->tp_version) {
		case TPACKET_V1:
			po->tp_hdrlen = TPACKET_HDRLEN;
			break;
		case TPACKET_V2:
			po->tp_hdrlen = TPACKET2_HDRLEN;
			break;
		case TPACKET_V3:
			po->tp_hdrlen = TPACKET3_HDRLEN;
			break;
		}

		err = -EINVAL;
		if (unlikely((int)req->tp_block_size <= 0))
			goto out;
		if (unlikely(!PAGE_ALIGNED(req->tp_block_size)))
			goto out;
		if (po->tp_version >= TPACKET_V3 &&
		    (int)(req->tp_block_size -
			  BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv)) <= 0)
			goto out;
		if (unlikely(req->tp_frame_size < po->tp_hdrlen +
					po->tp_reserve))
			goto out;
		if (unlikely(req->tp_frame_size & (TPACKET_ALIGNMENT - 1)))
			goto out;

		rb->frames_per_block = req->tp_block_size / req->tp_frame_size;
		if (unlikely(rb->frames_per_block == 0))
			goto out;
		if (unlikely((rb->frames_per_block * req->tp_block_nr) !=
					req->tp_frame_nr))
			goto out;

		err = -ENOMEM;
		order = get_order(req->tp_block_size);
		pg_vec = alloc_pg_vec(req, order);
		if (unlikely(!pg_vec))
			goto out;
		switch (po->tp_version) {
		case TPACKET_V3:
		/* Transmit path is not supported. We checked
		 * it above but just being paranoid
		 */
			if (!tx_ring)
				init_prb_bdqc(po, rb, pg_vec, req_u);
			break;
		default:
			break;
		}
	}
	/* Done */
	else {
		err = -EINVAL;
		if (unlikely(req->tp_frame_nr))
			goto out;
	}


	/* Detach socket from network */
	spin_lock(&po->bind_lock);
	was_running = po->running;
	num = po->num;
	if (was_running) {
		po->num = 0;
		__unregister_prot_hook(sk, false);
	}
	spin_unlock(&po->bind_lock);

	synchronize_net();

	err = -EBUSY;
	mutex_lock(&po->pg_vec_lock);
	if (closing || atomic_read(&po->mapped) == 0) {
		err = 0;
		spin_lock_bh(&rb_queue->lock);
		swap(rb->pg_vec, pg_vec);
		rb->frame_max = (req->tp_frame_nr - 1);
		rb->head = 0;
		rb->frame_size = req->tp_frame_size;
		spin_unlock_bh(&rb_queue->lock);

		swap(rb->pg_vec_order, order);
		swap(rb->pg_vec_len, req->tp_block_nr);

		rb->pg_vec_pages = req->tp_block_size/PAGE_SIZE;
		po->prot_hook.func = (po->rx_ring.pg_vec) ?
						tpacket_rcv : packet_rcv;
		skb_queue_purge(rb_queue);
		if (atomic_read(&po->mapped))
			pr_err(""packet_mmap: vma is busy: %d\n"",
			       atomic_read(&po->mapped));
	}
	mutex_unlock(&po->pg_vec_lock);

	spin_lock(&po->bind_lock);
	if (was_running) {
		po->num = num;
		register_prot_hook(sk);
	}
	spin_unlock(&po->bind_lock);
	if (closing && (po->tp_version > TPACKET_V2)) {
		/* Because we don't support block-based V3 on tx-ring */
		if (!tx_ring)
			prb_shutdown_retire_blk_timer(po, rb_queue);
	}

	if (pg_vec)
		free_pg_vec(pg_vec, order, req->tp_block_nr);
out:
	release_sock(sk);
	return err;
}","static int packet_set_ring(struct sock *VAR_0, union tpacket_req_u *VAR_1,
		int VAR_2, int VAR_3)
{
	struct pgv *VAR_4 = NULL;
	struct packet_sock *VAR_5 = pkt_sk(VAR_0);
	int VAR_6, VAR_7 = 0;
	struct packet_ring_buffer *VAR_8;
	struct sk_buff_head *VAR_9;
	__be16 numVAR_10;
	int VAR_11 = -VAR_12;
	/* COMMENT_0 */
	struct tpacket_req *VAR_13 = &VAR_1->req;

	lock_sock(VAR_0);
	/* COMMENT_1 */
	if (!VAR_2 && VAR_3 && (VAR_5->tp_version > VAR_14)) {
		net_warn_ratelimited(""Tx-ring is not supported.\n"");
		goto out;
	}

	VAR_8 = VAR_3 ? &VAR_5->tx_ring : &VAR_5->rx_ring;
	VAR_9 = VAR_3 ? &VAR_0->sk_write_queue : &VAR_0->sk_receive_queue;

	VAR_11 = -VAR_15;
	if (!VAR_2) {
		if (atomic_read(&VAR_5->mapped))
			goto out;
		if (packet_read_pending(VAR_8))
			goto out;
	}

	if (VAR_13->tp_block_nr) {
		/* COMMENT_2 */
		VAR_11 = -VAR_15;
		if (unlikely(VAR_8->pg_vec))
			goto out;

		switch (VAR_5->tp_version) {
		case VAR_16:
			VAR_5->tp_hdrlen = VAR_17;
			break;
		case VAR_14:
			VAR_5->tp_hdrlen = VAR_18;
			break;
		case VAR_19:
			VAR_5->tp_hdrlen = VAR_20;
			break;
		}

		VAR_11 = -VAR_12;
		if (unlikely((int)VAR_13->tp_block_size <= 0))
			goto out;
		if (unlikely(!PAGE_ALIGNED(VAR_13->tp_block_size)))
			goto out;
		if (VAR_5->tp_version >= VAR_19 &&
		    (int)(VAR_13->tp_block_size -
			  BLK_PLUS_PRIV(VAR_1->req3.tp_sizeof_priv)) <= 0)
			goto out;
		if (unlikely(VAR_13->tp_frame_size < VAR_5->tp_hdrlen +
					VAR_5->tp_reserve))
			goto out;
		if (unlikely(VAR_13->tp_frame_size & (VAR_21 - 1)))
			goto out;

		VAR_8->frames_per_block = VAR_13->tp_block_size / VAR_13->tp_frame_size;
		if (unlikely(VAR_8->frames_per_block == 0))
			goto out;
		if (unlikely((VAR_8->frames_per_block * VAR_13->tp_block_nr) !=
					VAR_13->tp_frame_nr))
			goto out;

		VAR_11 = -VAR_22;
		VAR_7 = get_order(VAR_13->tp_block_size);
		VAR_4 = alloc_pg_vec(VAR_13, VAR_7);
		if (unlikely(!VAR_4))
			goto out;
		switch (VAR_5->tp_version) {
		case VAR_19:
		/* COMMENT_3 */
                                     
     
			if (!VAR_3)
				init_prb_bdqc(VAR_5, VAR_8, VAR_4, VAR_1);
			break;
		default:
			break;
		}
	}
	/* COMMENT_6 */
	else {
		VAR_11 = -VAR_12;
		if (unlikely(VAR_13->tp_frame_nr))
			goto out;
	}


	/* COMMENT_7 */
	spin_lock(&VAR_5->bind_lock);
	VAR_6 = VAR_5->running;
	num = VAR_5->num;
	if (VAR_6) {
		VAR_5->num = 0;
		__unregister_prot_hook(VAR_0, false);
	}
	spin_unlock(&VAR_5->bind_lock);

	synchronize_net();

	VAR_11 = -VAR_15;
	mutex_lock(&VAR_5->pg_vec_lock);
	if (VAR_2 || atomic_read(&VAR_5->mapped) == 0) {
		VAR_11 = 0;
		spin_lock_bh(&VAR_9->lock);
		swap(VAR_8->pg_vec, VAR_4);
		VAR_8->frame_max = (VAR_13->tp_frame_nr - 1);
		VAR_8->head = 0;
		VAR_8->frame_size = VAR_13->tp_frame_size;
		spin_unlock_bh(&VAR_9->lock);

		swap(VAR_8->pg_vec_order, VAR_7);
		swap(VAR_8->pg_vec_len, VAR_13->tp_block_nr);

		VAR_8->pg_vec_pages = VAR_13->tp_block_size/VAR_23;
		VAR_5->prot_hook.func = (VAR_5->rx_ring.pg_vec) ?
						VAR_24 : VAR_25;
		skb_queue_purge(VAR_9);
		if (atomic_read(&VAR_5->mapped))
			pr_err(""packet_mmap: vma is busy: %d\n"",
			       atomic_read(&VAR_5->mapped));
	}
	mutex_unlock(&VAR_5->pg_vec_lock);

	spin_lock(&VAR_5->bind_lock);
	if (VAR_6) {
		VAR_5->num = num;
		register_prot_hook(VAR_0);
	}
	spin_unlock(&VAR_5->bind_lock);
	if (VAR_2 && (VAR_5->tp_version > VAR_14)) {
		/* COMMENT_8 */
		if (!VAR_3)
			prb_shutdown_retire_blk_timer(VAR_5, VAR_9);
	}

	if (VAR_4)
		free_pg_vec(VAR_4, VAR_7, VAR_13->tp_block_nr);
out:
	release_sock(VAR_0);
	return VAR_11;
}",torvalds/linux/84ac7260236a49c79eede91617700174c2c19b0c/af_packet.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,6 +11,7 @@
 	/* Added to avoid minimal code churn */
 	struct tpacket_req *req = &req_u->req;
 
+	lock_sock(sk);
 	/* Opening a Tx-ring is NOT supported in TPACKET_V3 */
 	if (!closing && tx_ring && (po->tp_version > TPACKET_V2)) {
 		net_warn_ratelimited(""Tx-ring is not supported.\n"");
@@ -92,7 +93,6 @@
 			goto out;
 	}
 
-	lock_sock(sk);
 
 	/* Detach socket from network */
 	spin_lock(&po->bind_lock);
@@ -141,10 +141,10 @@
 		if (!tx_ring)
 			prb_shutdown_retire_blk_timer(po, rb_queue);
 	}
-	release_sock(sk);
 
 	if (pg_vec)
 		free_pg_vec(pg_vec, order, req->tp_block_nr);
 out:
+	release_sock(sk);
 	return err;
 }","{'deleted_lines': ['\tlock_sock(sk);', '\trelease_sock(sk);'], 'added_lines': ['\tlock_sock(sk);', '\trelease_sock(sk);']}",True,"Race condition in net/packet/af_packet.c in the Linux kernel through 4.8.12 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging the CAP_NET_RAW capability to change a socket version, related to the packet_set_ring and packet_setsockopt functions.",7.8,HIGH,2,test,2016-11-30T22:55:36Z,1
CVE-2016-8655,"['CWE-362', 'CWE-416']",AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"packet: fix race condition in packet_set_ring

When packet_set_ring creates a ring buffer it will initialize a
struct timer_list if the packet version is TPACKET_V3. This value
can then be raced by a different thread calling setsockopt to
set the version to TPACKET_V1 before packet_set_ring has finished.

This leads to a use-after-free on a function pointer in the
struct timer_list when the socket is closed as the previously
initialized timer will not be deleted.

The bug is fixed by taking lock_sock(sk) in packet_setsockopt when
changing the packet version while also taking the lock at the start
of packet_set_ring.

Fixes: f6fb8f100b80 (""af-packet: TPACKET_V3 flexible buffer implementation."")
Signed-off-by: Philip Pettersson <philip.pettersson@gmail.com>
Signed-off-by: Eric Dumazet <edumazet@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",84ac7260236a49c79eede91617700174c2c19b0c,https://github.com/torvalds/linux/commit/84ac7260236a49c79eede91617700174c2c19b0c,net/packet/af_packet.c,packet_setsockopt,"static int
packet_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)
{
struct sock *sk = sock->sk;
struct packet_sock *po = pkt_sk(sk);
int ret;
if (level != SOL_PACKET)
return -ENOPROTOOPT;
switch (optname) {
case PACKET_ADD_MEMBERSHIP:
case PACKET_DROP_MEMBERSHIP:
{
struct packet_mreq_max mreq;
int len = optlen;
memset(&mreq, 0, sizeof(mreq));
if (len < sizeof(struct packet_mreq))
return -EINVAL;
if (len > sizeof(mreq))
len = sizeof(mreq);
if (copy_from_user(&mreq, optval, len))
return -EFAULT;
if (len < (mreq.mr_alen + offsetof(struct packet_mreq, mr_address)))
return -EINVAL;
if (optname == PACKET_ADD_MEMBERSHIP)
ret = packet_mc_add(sk, &mreq);
else
ret = packet_mc_drop(sk, &mreq);
return ret;
}
case PACKET_RX_RING:
case PACKET_TX_RING:
{
union tpacket_req_u req_u;
int len;
switch (po->tp_version) {
case TPACKET_V1:
case TPACKET_V2:
len = sizeof(req_u.req);
break;
case TPACKET_V3:
default:
len = sizeof(req_u.req3);
break;
}
if (optlen < len)
return -EINVAL;
if (copy_from_user(&req_u.req, optval, len))
return -EFAULT;
return packet_set_ring(sk, &req_u, 0,
optname == PACKET_TX_RING);
}
case PACKET_COPY_THRESH:
{
int val;
if (optlen != sizeof(val))
return -EINVAL;
if (copy_from_user(&val, optval, sizeof(val)))
return -EFAULT;
pkt_sk(sk)->copy_thresh = val;
return 0;
}
case PACKET_VERSION:
{
int val;
if (optlen != sizeof(val))
return -EINVAL;
if (po->rx_ring.pg_vec || po->tx_ring.pg_vec)
return -EBUSY;
if (copy_from_user(&val, optval, sizeof(val)))
return -EFAULT;
switch (val) {
case TPACKET_V1:
case TPACKET_V2:
case TPACKET_V3:
po->tp_version = val;
return 0;
default:
return -EINVAL;
}
}
case PACKET_RESERVE:
{
unsigned int val;
if (optlen != sizeof(val))
return -EINVAL;
if (po->rx_ring.pg_vec || po->tx_ring.pg_vec)
return -EBUSY;
if (copy_from_user(&val, optval, sizeof(val)))
return -EFAULT;
po->tp_reserve = val;
return 0;
}
case PACKET_LOSS:
{
unsigned int val;
if (optlen != sizeof(val))
return -EINVAL;
if (po->rx_ring.pg_vec || po->tx_ring.pg_vec)
return -EBUSY;
if (copy_from_user(&val, optval, sizeof(val)))
return -EFAULT;
po->tp_loss = !!val;
return 0;
}
case PACKET_AUXDATA:
{
int val;
if (optlen < sizeof(val))
return -EINVAL;
if (copy_from_user(&val, optval, sizeof(val)))
return -EFAULT;
po->auxdata = !!val;
return 0;
}
case PACKET_ORIGDEV:
{
int val;
if (optlen < sizeof(val))
return -EINVAL;
if (copy_from_user(&val, optval, sizeof(val)))
return -EFAULT;
po->origdev = !!val;
return 0;
}
case PACKET_VNET_HDR:
{
int val;
if (sock->type != SOCK_RAW)
return -EINVAL;
if (po->rx_ring.pg_vec || po->tx_ring.pg_vec)
return -EBUSY;
if (optlen < sizeof(val))
return -EINVAL;
if (copy_from_user(&val, optval, sizeof(val)))
return -EFAULT;
po->has_vnet_hdr = !!val;
return 0;
}
case PACKET_TIMESTAMP:
{
int val;
if (optlen != sizeof(val))
return -EINVAL;
if (copy_from_user(&val, optval, sizeof(val)))
return -EFAULT;
po->tp_tstamp = val;
return 0;
}
case PACKET_FANOUT:
{
int val;
if (optlen != sizeof(val))
return -EINVAL;
if (copy_from_user(&val, optval, sizeof(val)))
return -EFAULT;
return fanout_add(sk, val & 0xffff, val >> 16);
}
case PACKET_FANOUT_DATA:
{
if (!po->fanout)
return -EINVAL;
return fanout_set_data(po, optval, optlen);
}
case PACKET_TX_HAS_OFF:
{
unsigned int val;
if (optlen != sizeof(val))
return -EINVAL;
if (po->rx_ring.pg_vec || po->tx_ring.pg_vec)
return -EBUSY;
if (copy_from_user(&val, optval, sizeof(val)))
return -EFAULT;
po->tp_tx_has_off = !!val;
return 0;
}
case PACKET_QDISC_BYPASS:
{
int val;
if (optlen != sizeof(val))
return -EINVAL;
if (copy_from_user(&val, optval, sizeof(val)))
return -EFAULT;
po->xmit = val ? packet_direct_xmit : dev_queue_xmit;
return 0;
}
default:
return -ENOPROTOOPT;
}
}","static int
packet_setsockopt(struct socket *VAR_0, int VAR_1, int VAR_2, char __user *VAR_3, unsigned int VAR_4)
{
struct sock *VAR_5 = sock->sk;
struct packet_sock *VAR_6 = pkt_sk(VAR_5);
int VAR_7;
if (VAR_1 != VAR_8)
return -VAR_9;
switch (VAR_2) {
case VAR_10:
case VAR_11:
{
struct packet_mreq_max VAR_12;
int VAR_13 = VAR_4;
memset(&VAR_12, 0, sizeof(VAR_12));
if (VAR_13 < sizeof(struct packet_mreq))
return -VAR_14;
if (VAR_13 > sizeof(VAR_12))
VAR_13 = sizeof(VAR_12);
if (copy_from_user(&VAR_12, VAR_3, VAR_13))
return -VAR_15;
if (VAR_13 < (VAR_12.mr_alen + offsetof(struct packet_mreq, VAR_16)))
return -VAR_14;
if (VAR_2 == VAR_10)
VAR_7 = packet_mc_add(VAR_5, &VAR_12);
else
VAR_7 = packet_mc_drop(VAR_5, &VAR_12);
return VAR_7;
}
case VAR_17:
case VAR_18:
{
union tpacket_req_u VAR_19;
int VAR_13;
switch (VAR_6->tp_version) {
case VAR_20:
case VAR_21:
VAR_13 = sizeof(VAR_19.req);
break;
case VAR_22:
default:
VAR_13 = sizeof(VAR_19.req3);
break;
}
if (VAR_4 < VAR_13)
return -VAR_14;
if (copy_from_user(&VAR_19.req, VAR_3, VAR_13))
return -VAR_15;
return packet_set_ring(VAR_5, &VAR_19, 0,
VAR_2 == VAR_18);
}
case VAR_23:
{
int VAR_24;
if (VAR_4 != sizeof(VAR_24))
return -VAR_14;
if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
return -VAR_15;
pkt_sk(VAR_5)->copy_thresh = VAR_24;
return 0;
}
case VAR_25:
{
int VAR_24;
if (VAR_4 != sizeof(VAR_24))
return -VAR_14;
if (VAR_6->rx_ring.pg_vec || VAR_6->tx_ring.pg_vec)
return -VAR_26;
if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
return -VAR_15;
switch (VAR_24) {
case VAR_20:
case VAR_21:
case VAR_22:
VAR_6->tp_version = VAR_24;
return 0;
default:
return -VAR_14;
}
}
case VAR_27:
{
unsigned int VAR_24;
if (VAR_4 != sizeof(VAR_24))
return -VAR_14;
if (VAR_6->rx_ring.pg_vec || VAR_6->tx_ring.pg_vec)
return -VAR_26;
if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
return -VAR_15;
VAR_6->tp_reserve = VAR_24;
return 0;
}
case VAR_28:
{
unsigned int VAR_24;
if (VAR_4 != sizeof(VAR_24))
return -VAR_14;
if (VAR_6->rx_ring.pg_vec || VAR_6->tx_ring.pg_vec)
return -VAR_26;
if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
return -VAR_15;
VAR_6->tp_loss = !!VAR_24;
return 0;
}
case VAR_29:
{
int VAR_24;
if (VAR_4 < sizeof(VAR_24))
return -VAR_14;
if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
return -VAR_15;
VAR_6->auxdata = !!VAR_24;
return 0;
}
case VAR_30:
{
int VAR_24;
if (VAR_4 < sizeof(VAR_24))
return -VAR_14;
if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
return -VAR_15;
VAR_6->origdev = !!VAR_24;
return 0;
}
case VAR_31:
{
int VAR_24;
if (sock->type != VAR_32)
return -VAR_14;
if (VAR_6->rx_ring.pg_vec || VAR_6->tx_ring.pg_vec)
return -VAR_26;
if (VAR_4 < sizeof(VAR_24))
return -VAR_14;
if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
return -VAR_15;
VAR_6->has_vnet_hdr = !!VAR_24;
return 0;
}
case VAR_33:
{
int VAR_24;
if (VAR_4 != sizeof(VAR_24))
return -VAR_14;
if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
return -VAR_15;
VAR_6->tp_tstamp = VAR_24;
return 0;
}
case VAR_34:
{
int VAR_24;
if (VAR_4 != sizeof(VAR_24))
return -VAR_14;
if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
return -VAR_15;
return fanout_add(VAR_5, VAR_24 & 0xffff, VAR_24 >> 16);
}
case VAR_35:
{
if (!VAR_6->fanout)
return -VAR_14;
return fanout_set_data(VAR_6, VAR_3, VAR_4);
}
case VAR_36:
{
unsigned int VAR_24;
if (VAR_4 != sizeof(VAR_24))
return -VAR_14;
if (VAR_6->rx_ring.pg_vec || VAR_6->tx_ring.pg_vec)
return -VAR_26;
if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
return -VAR_15;
VAR_6->tp_tx_has_off = !!VAR_24;
return 0;
}
case VAR_37:
{
int VAR_24;
if (VAR_4 != sizeof(VAR_24))
return -VAR_14;
if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
return -VAR_15;
VAR_6->xmit = VAR_24 ? VAR_38 : VAR_39;
return 0;
}
default:
return -VAR_9;
}
}",,"static int
packet_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)
{
	struct sock *sk = sock->sk;
	struct packet_sock *po = pkt_sk(sk);
	int ret;

	if (level != SOL_PACKET)
		return -ENOPROTOOPT;

	switch (optname) {
	case PACKET_ADD_MEMBERSHIP:
	case PACKET_DROP_MEMBERSHIP:
	{
		struct packet_mreq_max mreq;
		int len = optlen;
		memset(&mreq, 0, sizeof(mreq));
		if (len < sizeof(struct packet_mreq))
			return -EINVAL;
		if (len > sizeof(mreq))
			len = sizeof(mreq);
		if (copy_from_user(&mreq, optval, len))
			return -EFAULT;
		if (len < (mreq.mr_alen + offsetof(struct packet_mreq, mr_address)))
			return -EINVAL;
		if (optname == PACKET_ADD_MEMBERSHIP)
			ret = packet_mc_add(sk, &mreq);
		else
			ret = packet_mc_drop(sk, &mreq);
		return ret;
	}

	case PACKET_RX_RING:
	case PACKET_TX_RING:
	{
		union tpacket_req_u req_u;
		int len;

		switch (po->tp_version) {
		case TPACKET_V1:
		case TPACKET_V2:
			len = sizeof(req_u.req);
			break;
		case TPACKET_V3:
		default:
			len = sizeof(req_u.req3);
			break;
		}
		if (optlen < len)
			return -EINVAL;
		if (copy_from_user(&req_u.req, optval, len))
			return -EFAULT;
		return packet_set_ring(sk, &req_u, 0,
			optname == PACKET_TX_RING);
	}
	case PACKET_COPY_THRESH:
	{
		int val;

		if (optlen != sizeof(val))
			return -EINVAL;
		if (copy_from_user(&val, optval, sizeof(val)))
			return -EFAULT;

		pkt_sk(sk)->copy_thresh = val;
		return 0;
	}
	case PACKET_VERSION:
	{
		int val;

		if (optlen != sizeof(val))
			return -EINVAL;
		if (copy_from_user(&val, optval, sizeof(val)))
			return -EFAULT;
		switch (val) {
		case TPACKET_V1:
		case TPACKET_V2:
		case TPACKET_V3:
			break;
		default:
			return -EINVAL;
		}
		lock_sock(sk);
		if (po->rx_ring.pg_vec || po->tx_ring.pg_vec) {
			ret = -EBUSY;
		} else {
			po->tp_version = val;
			ret = 0;
		}
		release_sock(sk);
		return ret;
	}
	case PACKET_RESERVE:
	{
		unsigned int val;

		if (optlen != sizeof(val))
			return -EINVAL;
		if (po->rx_ring.pg_vec || po->tx_ring.pg_vec)
			return -EBUSY;
		if (copy_from_user(&val, optval, sizeof(val)))
			return -EFAULT;
		po->tp_reserve = val;
		return 0;
	}
	case PACKET_LOSS:
	{
		unsigned int val;

		if (optlen != sizeof(val))
			return -EINVAL;
		if (po->rx_ring.pg_vec || po->tx_ring.pg_vec)
			return -EBUSY;
		if (copy_from_user(&val, optval, sizeof(val)))
			return -EFAULT;
		po->tp_loss = !!val;
		return 0;
	}
	case PACKET_AUXDATA:
	{
		int val;

		if (optlen < sizeof(val))
			return -EINVAL;
		if (copy_from_user(&val, optval, sizeof(val)))
			return -EFAULT;

		po->auxdata = !!val;
		return 0;
	}
	case PACKET_ORIGDEV:
	{
		int val;

		if (optlen < sizeof(val))
			return -EINVAL;
		if (copy_from_user(&val, optval, sizeof(val)))
			return -EFAULT;

		po->origdev = !!val;
		return 0;
	}
	case PACKET_VNET_HDR:
	{
		int val;

		if (sock->type != SOCK_RAW)
			return -EINVAL;
		if (po->rx_ring.pg_vec || po->tx_ring.pg_vec)
			return -EBUSY;
		if (optlen < sizeof(val))
			return -EINVAL;
		if (copy_from_user(&val, optval, sizeof(val)))
			return -EFAULT;

		po->has_vnet_hdr = !!val;
		return 0;
	}
	case PACKET_TIMESTAMP:
	{
		int val;

		if (optlen != sizeof(val))
			return -EINVAL;
		if (copy_from_user(&val, optval, sizeof(val)))
			return -EFAULT;

		po->tp_tstamp = val;
		return 0;
	}
	case PACKET_FANOUT:
	{
		int val;

		if (optlen != sizeof(val))
			return -EINVAL;
		if (copy_from_user(&val, optval, sizeof(val)))
			return -EFAULT;

		return fanout_add(sk, val & 0xffff, val >> 16);
	}
	case PACKET_FANOUT_DATA:
	{
		if (!po->fanout)
			return -EINVAL;

		return fanout_set_data(po, optval, optlen);
	}
	case PACKET_TX_HAS_OFF:
	{
		unsigned int val;

		if (optlen != sizeof(val))
			return -EINVAL;
		if (po->rx_ring.pg_vec || po->tx_ring.pg_vec)
			return -EBUSY;
		if (copy_from_user(&val, optval, sizeof(val)))
			return -EFAULT;
		po->tp_tx_has_off = !!val;
		return 0;
	}
	case PACKET_QDISC_BYPASS:
	{
		int val;

		if (optlen != sizeof(val))
			return -EINVAL;
		if (copy_from_user(&val, optval, sizeof(val)))
			return -EFAULT;

		po->xmit = val ? packet_direct_xmit : dev_queue_xmit;
		return 0;
	}
	default:
		return -ENOPROTOOPT;
	}
}","static int
packet_setsockopt(struct socket *VAR_0, int VAR_1, int VAR_2, char __user *VAR_3, unsigned int VAR_4)
{
	struct sock *VAR_5 = sock->sk;
	struct packet_sock *VAR_6 = pkt_sk(VAR_5);
	int VAR_7;

	if (VAR_1 != VAR_8)
		return -VAR_9;

	switch (VAR_2) {
	case VAR_10:
	case VAR_11:
	{
		struct packet_mreq_max VAR_12;
		int VAR_13 = VAR_4;
		memset(&VAR_12, 0, sizeof(VAR_12));
		if (VAR_13 < sizeof(struct packet_mreq))
			return -VAR_14;
		if (VAR_13 > sizeof(VAR_12))
			VAR_13 = sizeof(VAR_12);
		if (copy_from_user(&VAR_12, VAR_3, VAR_13))
			return -VAR_15;
		if (VAR_13 < (VAR_12.mr_alen + offsetof(struct packet_mreq, VAR_16)))
			return -VAR_14;
		if (VAR_2 == VAR_10)
			VAR_7 = packet_mc_add(VAR_5, &VAR_12);
		else
			VAR_7 = packet_mc_drop(VAR_5, &VAR_12);
		return VAR_7;
	}

	case VAR_17:
	case VAR_18:
	{
		union tpacket_req_u VAR_19;
		int VAR_13;

		switch (VAR_6->tp_version) {
		case VAR_20:
		case VAR_21:
			VAR_13 = sizeof(VAR_19.req);
			break;
		case VAR_22:
		default:
			VAR_13 = sizeof(VAR_19.req3);
			break;
		}
		if (VAR_4 < VAR_13)
			return -VAR_14;
		if (copy_from_user(&VAR_19.req, VAR_3, VAR_13))
			return -VAR_15;
		return packet_set_ring(VAR_5, &VAR_19, 0,
			VAR_2 == VAR_18);
	}
	case VAR_23:
	{
		int VAR_24;

		if (VAR_4 != sizeof(VAR_24))
			return -VAR_14;
		if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
			return -VAR_15;

		pkt_sk(VAR_5)->copy_thresh = VAR_24;
		return 0;
	}
	case VAR_25:
	{
		int VAR_24;

		if (VAR_4 != sizeof(VAR_24))
			return -VAR_14;
		if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
			return -VAR_15;
		switch (VAR_24) {
		case VAR_20:
		case VAR_21:
		case VAR_22:
			break;
		default:
			return -VAR_14;
		}
		lock_sock(VAR_5);
		if (VAR_6->rx_ring.pg_vec || VAR_6->tx_ring.pg_vec) {
			VAR_7 = -VAR_26;
		} else {
			VAR_6->tp_version = VAR_24;
			VAR_7 = 0;
		}
		release_sock(VAR_5);
		return VAR_7;
	}
	case VAR_27:
	{
		unsigned int VAR_24;

		if (VAR_4 != sizeof(VAR_24))
			return -VAR_14;
		if (VAR_6->rx_ring.pg_vec || VAR_6->tx_ring.pg_vec)
			return -VAR_26;
		if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
			return -VAR_15;
		VAR_6->tp_reserve = VAR_24;
		return 0;
	}
	case VAR_28:
	{
		unsigned int VAR_24;

		if (VAR_4 != sizeof(VAR_24))
			return -VAR_14;
		if (VAR_6->rx_ring.pg_vec || VAR_6->tx_ring.pg_vec)
			return -VAR_26;
		if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
			return -VAR_15;
		VAR_6->tp_loss = !!VAR_24;
		return 0;
	}
	case VAR_29:
	{
		int VAR_24;

		if (VAR_4 < sizeof(VAR_24))
			return -VAR_14;
		if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
			return -VAR_15;

		VAR_6->auxdata = !!VAR_24;
		return 0;
	}
	case VAR_30:
	{
		int VAR_24;

		if (VAR_4 < sizeof(VAR_24))
			return -VAR_14;
		if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
			return -VAR_15;

		VAR_6->origdev = !!VAR_24;
		return 0;
	}
	case VAR_31:
	{
		int VAR_24;

		if (sock->type != VAR_32)
			return -VAR_14;
		if (VAR_6->rx_ring.pg_vec || VAR_6->tx_ring.pg_vec)
			return -VAR_26;
		if (VAR_4 < sizeof(VAR_24))
			return -VAR_14;
		if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
			return -VAR_15;

		VAR_6->has_vnet_hdr = !!VAR_24;
		return 0;
	}
	case VAR_33:
	{
		int VAR_24;

		if (VAR_4 != sizeof(VAR_24))
			return -VAR_14;
		if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
			return -VAR_15;

		VAR_6->tp_tstamp = VAR_24;
		return 0;
	}
	case VAR_34:
	{
		int VAR_24;

		if (VAR_4 != sizeof(VAR_24))
			return -VAR_14;
		if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
			return -VAR_15;

		return fanout_add(VAR_5, VAR_24 & 0xffff, VAR_24 >> 16);
	}
	case VAR_35:
	{
		if (!VAR_6->fanout)
			return -VAR_14;

		return fanout_set_data(VAR_6, VAR_3, VAR_4);
	}
	case VAR_36:
	{
		unsigned int VAR_24;

		if (VAR_4 != sizeof(VAR_24))
			return -VAR_14;
		if (VAR_6->rx_ring.pg_vec || VAR_6->tx_ring.pg_vec)
			return -VAR_26;
		if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
			return -VAR_15;
		VAR_6->tp_tx_has_off = !!VAR_24;
		return 0;
	}
	case VAR_37:
	{
		int VAR_24;

		if (VAR_4 != sizeof(VAR_24))
			return -VAR_14;
		if (copy_from_user(&VAR_24, VAR_3, sizeof(VAR_24)))
			return -VAR_15;

		VAR_6->xmit = VAR_24 ? VAR_38 : VAR_39;
		return 0;
	}
	default:
		return -VAR_9;
	}
}",,"--- func_before
+++ func_after
@@ -71,19 +71,25 @@
 
 		if (optlen != sizeof(val))
 			return -EINVAL;
-		if (po->rx_ring.pg_vec || po->tx_ring.pg_vec)
-			return -EBUSY;
 		if (copy_from_user(&val, optval, sizeof(val)))
 			return -EFAULT;
 		switch (val) {
 		case TPACKET_V1:
 		case TPACKET_V2:
 		case TPACKET_V3:
+			break;
+		default:
+			return -EINVAL;
+		}
+		lock_sock(sk);
+		if (po->rx_ring.pg_vec || po->tx_ring.pg_vec) {
+			ret = -EBUSY;
+		} else {
 			po->tp_version = val;
-			return 0;
-		default:
-			return -EINVAL;
+			ret = 0;
 		}
+		release_sock(sk);
+		return ret;
 	}
 	case PACKET_RESERVE:
 	{","{'deleted_lines': ['\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec)', '\t\t\treturn -EBUSY;', '\t\t\treturn 0;', '\t\tdefault:', '\t\t\treturn -EINVAL;'], 'added_lines': ['\t\t\tbreak;', '\t\tdefault:', '\t\t\treturn -EINVAL;', '\t\t}', '\t\tlock_sock(sk);', '\t\tif (po->rx_ring.pg_vec || po->tx_ring.pg_vec) {', '\t\t\tret = -EBUSY;', '\t\t} else {', '\t\t\tret = 0;', '\t\trelease_sock(sk);', '\t\treturn ret;']}",True,"Race condition in net/packet/af_packet.c in the Linux kernel through 4.8.12 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging the CAP_NET_RAW capability to change a socket version, related to the packet_set_ring and packet_setsockopt functions.",7.8,HIGH,2,test,2016-11-30T22:55:36Z,1
CVE-2016-10270,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,vadz/libtiff,"* libtiff/tif_dirread.c: modify ChopUpSingleUncompressedStrip() to
instanciate compute ntrips as TIFFhowmany_32(td->td_imagelength, rowsperstrip),
instead of a logic based on the total size of data. Which is faulty is
the total size of data is not sufficient to fill the whole image, and thus
results in reading outside of the StripByCounts/StripOffsets arrays when
using TIFFReadScanline().
Reported by Agostino Sarubbo.
Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2608.

* libtiff/tif_strip.c: revert the change in TIFFNumberOfStrips() done
for http://bugzilla.maptools.org/show_bug.cgi?id=2587 / CVE-2016-9273 since
the above change is a better fix that makes it unnecessary.",9a72a69e035ee70ff5c41541c8c61cd97990d018,https://github.com/vadz/libtiff/commit/9a72a69e035ee70ff5c41541c8c61cd97990d018,libtiff/tif_dirread.c,ChopUpSingleUncompressedStrip,"static void
ChopUpSingleUncompressedStrip(TIFF* tif)
{
register TIFFDirectory *td = &tif->tif_dir;
uint64 bytecount;
uint64 offset;
uint32 rowblock;
uint64 rowblockbytes;
uint64 stripbytes;
uint32 strip;
uint64 nstrips64;
uint32 nstrips32;
uint32 rowsperstrip;
uint64* newcounts;
uint64* newoffsets;
bytecount = td->td_stripbytecount[0];
offset = td->td_stripoffset[0];
assert(td->td_planarconfig == PLANARCONFIG_CONTIG);
if ((td->td_photometric == PHOTOMETRIC_YCBCR)&&
(!isUpSampled(tif)))
rowblock = td->td_ycbcrsubsampling[1];
else
rowblock = 1;
rowblockbytes = TIFFVTileSize64(tif, rowblock);
if (rowblockbytes > STRIP_SIZE_DEFAULT) {
stripbytes = rowblockbytes;
rowsperstrip = rowblock;
} else if (rowblockbytes > 0 ) {
uint32 rowblocksperstrip;
rowblocksperstrip = (uint32) (STRIP_SIZE_DEFAULT / rowblockbytes);
rowsperstrip = rowblocksperstrip * rowblock;
stripbytes = rowblocksperstrip * rowblockbytes;
}
else
return;
if (rowsperstrip >= td->td_rowsperstrip)
return;
nstrips64 = TIFFhowmany_64(bytecount, stripbytes);
if ((nstrips64==0)||(nstrips64>0xFFFFFFFF)) 
return;
nstrips32 = (uint32)nstrips64;
newcounts = (uint64*) _TIFFCheckMalloc(tif, nstrips32, sizeof (uint64),
""for chopped \""StripByteCounts\"" array"");
newoffsets = (uint64*) _TIFFCheckMalloc(tif, nstrips32, sizeof (uint64),
""for chopped \""StripOffsets\"" array"");
if (newcounts == NULL || newoffsets == NULL) {
if (newcounts != NULL)
_TIFFfree(newcounts);
if (newoffsets != NULL)
_TIFFfree(newoffsets);
return;
}
for (strip = 0; strip < nstrips32; strip++) {
if (stripbytes > bytecount)
stripbytes = bytecount;
newcounts[strip] = stripbytes;
newoffsets[strip] = offset;
offset += stripbytes;
bytecount -= stripbytes;
}
td->td_stripsperimage = td->td_nstrips = nstrips32;
TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);
_TIFFfree(td->td_stripbytecount);
_TIFFfree(td->td_stripoffset);
td->td_stripbytecount = newcounts;
td->td_stripoffset = newoffsets;
td->td_stripbytecountsorted = 1;
}","static void
ChopUpSingleUncompressedStrip(TIFF* VAR_0)
{
register TIFFDirectory *VAR_1 = &VAR_0->tif_dir;
uint64 VAR_2;
uint64 VAR_3;
uint32 VAR_4;
uint64 VAR_5;
uint64 VAR_6;
uint32 VAR_7;
uint64 VAR_8;
uint32 VAR_9;
uint32 VAR_10;
uint64* VAR_11;
uint64* VAR_12;
VAR_2 = VAR_1->td_stripbytecount[0];
VAR_3 = VAR_1->td_stripoffset[0];
assert(VAR_1->td_planarconfig == VAR_13);
if ((VAR_1->td_photometric == VAR_14)&&
(!isUpSampled(VAR_0)))
VAR_4 = VAR_1->td_ycbcrsubsampling[1];
else
VAR_4 = 1;
VAR_5 = TIFFVTileSize64(VAR_0, VAR_4);
if (VAR_5 > VAR_15) {
VAR_6 = VAR_5;
VAR_10 = VAR_4;
} else if (VAR_5 > 0 ) {
uint32 VAR_16;
VAR_16 = (uint32) (VAR_15 / VAR_5);
VAR_10 = VAR_16 * VAR_4;
VAR_6 = VAR_16 * VAR_5;
}
else
return;
if (VAR_10 >= VAR_1->td_rowsperstrip)
return;
VAR_8 = TIFFhowmany_64(VAR_2, VAR_6);
if ((VAR_8==0)||(VAR_8>0xFFFFFFFF)) 
return;
VAR_9 = (uint32)VAR_8;
VAR_11 = (uint64*) _TIFFCheckMalloc(VAR_0, VAR_9, sizeof (uint64),
""for chopped \""StripByteCounts\"" array"");
VAR_12 = (uint64*) _TIFFCheckMalloc(VAR_0, VAR_9, sizeof (uint64),
""for chopped \""StripOffsets\"" array"");
if (VAR_11 == NULL || VAR_12 == NULL) {
if (VAR_11 != NULL)
_TIFFfree(VAR_11);
if (VAR_12 != NULL)
_TIFFfree(VAR_12);
return;
}
for (VAR_7 = 0; VAR_7 < VAR_9; VAR_7++) {
if (VAR_6 > VAR_2)
VAR_6 = VAR_2;
VAR_11[VAR_7] = VAR_6;
VAR_12[VAR_7] = VAR_3;
VAR_3 += VAR_6;
VAR_2 -= VAR_6;
}
VAR_1->td_stripsperimage = VAR_1->td_nstrips = VAR_9;
TIFFSetField(VAR_0, VAR_17, VAR_10);
_TIFFfree(VAR_1->td_stripbytecount);
_TIFFfree(VAR_1->td_stripoffset);
VAR_1->td_stripbytecount = VAR_11;
VAR_1->td_stripoffset = VAR_12;
VAR_1->td_stripbytecountsorted = 1;
}",vadz/libtiff/9a72a69e035ee70ff5c41541c8c61cd97990d018/tif_dirread.c/vul/before/0.json,"static void
ChopUpSingleUncompressedStrip(TIFF* tif)
{
	register TIFFDirectory *td = &tif->tif_dir;
	uint64 bytecount;
	uint64 offset;
	uint32 rowblock;
	uint64 rowblockbytes;
	uint64 stripbytes;
	uint32 strip;
	uint32 nstrips;
	uint32 rowsperstrip;
	uint64* newcounts;
	uint64* newoffsets;

	bytecount = td->td_stripbytecount[0];
	offset = td->td_stripoffset[0];
	assert(td->td_planarconfig == PLANARCONFIG_CONTIG);
	if ((td->td_photometric == PHOTOMETRIC_YCBCR)&&
	    (!isUpSampled(tif)))
		rowblock = td->td_ycbcrsubsampling[1];
	else
		rowblock = 1;
	rowblockbytes = TIFFVTileSize64(tif, rowblock);
	/*
	 * Make the rows hold at least one scanline, but fill specified amount
	 * of data if possible.
	 */
	if (rowblockbytes > STRIP_SIZE_DEFAULT) {
		stripbytes = rowblockbytes;
		rowsperstrip = rowblock;
	} else if (rowblockbytes > 0 ) {
		uint32 rowblocksperstrip;
		rowblocksperstrip = (uint32) (STRIP_SIZE_DEFAULT / rowblockbytes);
		rowsperstrip = rowblocksperstrip * rowblock;
		stripbytes = rowblocksperstrip * rowblockbytes;
	}
	else
	    return;

	/*
	 * never increase the number of rows per strip
	 */
	if (rowsperstrip >= td->td_rowsperstrip)
		return;
        nstrips = TIFFhowmany_32(td->td_imagelength, rowsperstrip);
        if( nstrips == 0 )
            return;

	newcounts = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),
				""for chopped \""StripByteCounts\"" array"");
	newoffsets = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),
				""for chopped \""StripOffsets\"" array"");
	if (newcounts == NULL || newoffsets == NULL) {
		/*
		 * Unable to allocate new strip information, give up and use
		 * the original one strip information.
		 */
		if (newcounts != NULL)
			_TIFFfree(newcounts);
		if (newoffsets != NULL)
			_TIFFfree(newoffsets);
		return;
	}
	/*
	 * Fill the strip information arrays with new bytecounts and offsets
	 * that reflect the broken-up format.
	 */
	for (strip = 0; strip < nstrips; strip++) {
		if (stripbytes > bytecount)
			stripbytes = bytecount;
		newcounts[strip] = stripbytes;
		newoffsets[strip] = stripbytes ? offset : 0;
		offset += stripbytes;
		bytecount -= stripbytes;
	}
	/*
	 * Replace old single strip info with multi-strip info.
	 */
	td->td_stripsperimage = td->td_nstrips = nstrips;
	TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);

	_TIFFfree(td->td_stripbytecount);
	_TIFFfree(td->td_stripoffset);
	td->td_stripbytecount = newcounts;
	td->td_stripoffset = newoffsets;
	td->td_stripbytecountsorted = 1;
}","static void
ChopUpSingleUncompressedStrip(TIFF* VAR_0)
{
	register TIFFDirectory *VAR_1 = &VAR_0->tif_dir;
	uint64 VAR_2;
	uint64 VAR_3;
	uint32 VAR_4;
	uint64 VAR_5;
	uint64 VAR_6;
	uint32 VAR_7;
	uint32 VAR_8;
	uint32 VAR_9;
	uint64* VAR_10;
	uint64* VAR_11;

	VAR_2 = VAR_1->td_stripbytecount[0];
	VAR_3 = VAR_1->td_stripoffset[0];
	assert(VAR_1->td_planarconfig == VAR_12);
	if ((VAR_1->td_photometric == VAR_13)&&
	    (!isUpSampled(VAR_0)))
		VAR_4 = VAR_1->td_ycbcrsubsampling[1];
	else
		VAR_4 = 1;
	VAR_5 = TIFFVTileSize64(VAR_0, VAR_4);
	/* COMMENT_0 */
                                                                       
                        
    
	if (VAR_5 > VAR_14) {
		VAR_6 = VAR_5;
		VAR_9 = VAR_4;
	} else if (VAR_5 > 0 ) {
		uint32 VAR_15;
		VAR_15 = (uint32) (VAR_14 / VAR_5);
		VAR_9 = VAR_15 * VAR_4;
		VAR_6 = VAR_15 * VAR_5;
	}
	else
	    return;

	/* COMMENT_4 */
                                               
    
	if (VAR_9 >= VAR_1->td_rowsperstrip)
		return;
        VAR_8 = TIFFhowmany_32(VAR_1->td_imagelength, VAR_9);
        if( VAR_8 == 0 )
            return;

	VAR_10 = (uint64*) _TIFFCheckMalloc(VAR_0, VAR_8, sizeof (uint64),
				""for chopped \""StripByteCounts\"" array"");
	VAR_11 = (uint64*) _TIFFCheckMalloc(VAR_0, VAR_8, sizeof (uint64),
				""for chopped \""StripOffsets\"" array"");
	if (VAR_10 == NULL || VAR_11 == NULL) {
		/* COMMENT_7 */
                                                              
                                        
     
		if (VAR_10 != NULL)
			_TIFFfree(VAR_10);
		if (VAR_11 != NULL)
			_TIFFfree(VAR_11);
		return;
	}
	/* COMMENT_11 */
                                                                     
                                      
    
	for (VAR_7 = 0; VAR_7 < VAR_8; VAR_7++) {
		if (VAR_6 > VAR_2)
			VAR_6 = VAR_2;
		VAR_10[VAR_7] = VAR_6;
		VAR_11[VAR_7] = VAR_6 ? VAR_3 : 0;
		VAR_3 += VAR_6;
		VAR_2 -= VAR_6;
	}
	/* COMMENT_15 */
                                                        
    
	VAR_1->td_stripsperimage = VAR_1->td_nstrips = VAR_8;
	TIFFSetField(VAR_0, VAR_16, VAR_9);

	_TIFFfree(VAR_1->td_stripbytecount);
	_TIFFfree(VAR_1->td_stripoffset);
	VAR_1->td_stripbytecount = VAR_10;
	VAR_1->td_stripoffset = VAR_11;
	VAR_1->td_stripbytecountsorted = 1;
}",vadz/libtiff/9a72a69e035ee70ff5c41541c8c61cd97990d018/tif_dirread.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,8 +8,7 @@
 	uint64 rowblockbytes;
 	uint64 stripbytes;
 	uint32 strip;
-	uint64 nstrips64;
-	uint32 nstrips32;
+	uint32 nstrips;
 	uint32 rowsperstrip;
 	uint64* newcounts;
 	uint64* newoffsets;
@@ -40,18 +39,17 @@
 	    return;
 
 	/*
-	 * never increase the number of strips in an image
+	 * never increase the number of rows per strip
 	 */
 	if (rowsperstrip >= td->td_rowsperstrip)
 		return;
-	nstrips64 = TIFFhowmany_64(bytecount, stripbytes);
-	if ((nstrips64==0)||(nstrips64>0xFFFFFFFF)) /* something is wonky, do nothing. */
-	    return;
-	nstrips32 = (uint32)nstrips64;
+        nstrips = TIFFhowmany_32(td->td_imagelength, rowsperstrip);
+        if( nstrips == 0 )
+            return;
 
-	newcounts = (uint64*) _TIFFCheckMalloc(tif, nstrips32, sizeof (uint64),
+	newcounts = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),
 				""for chopped \""StripByteCounts\"" array"");
-	newoffsets = (uint64*) _TIFFCheckMalloc(tif, nstrips32, sizeof (uint64),
+	newoffsets = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),
 				""for chopped \""StripOffsets\"" array"");
 	if (newcounts == NULL || newoffsets == NULL) {
 		/*
@@ -68,18 +66,18 @@
 	 * Fill the strip information arrays with new bytecounts and offsets
 	 * that reflect the broken-up format.
 	 */
-	for (strip = 0; strip < nstrips32; strip++) {
+	for (strip = 0; strip < nstrips; strip++) {
 		if (stripbytes > bytecount)
 			stripbytes = bytecount;
 		newcounts[strip] = stripbytes;
-		newoffsets[strip] = offset;
+		newoffsets[strip] = stripbytes ? offset : 0;
 		offset += stripbytes;
 		bytecount -= stripbytes;
 	}
 	/*
 	 * Replace old single strip info with multi-strip info.
 	 */
-	td->td_stripsperimage = td->td_nstrips = nstrips32;
+	td->td_stripsperimage = td->td_nstrips = nstrips;
 	TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);
 
 	_TIFFfree(td->td_stripbytecount);","{'deleted_lines': ['\tuint64 nstrips64;', '\tuint32 nstrips32;', '\t * never increase the number of strips in an image', '\tnstrips64 = TIFFhowmany_64(bytecount, stripbytes);', '\tif ((nstrips64==0)||(nstrips64>0xFFFFFFFF)) /* something is wonky, do nothing. */', '\t    return;', '\tnstrips32 = (uint32)nstrips64;', '\tnewcounts = (uint64*) _TIFFCheckMalloc(tif, nstrips32, sizeof (uint64),', '\tnewoffsets = (uint64*) _TIFFCheckMalloc(tif, nstrips32, sizeof (uint64),', '\tfor (strip = 0; strip < nstrips32; strip++) {', '\t\tnewoffsets[strip] = offset;', '\ttd->td_stripsperimage = td->td_nstrips = nstrips32;'], 'added_lines': ['\tuint32 nstrips;', '\t * never increase the number of rows per strip', '        nstrips = TIFFhowmany_32(td->td_imagelength, rowsperstrip);', '        if( nstrips == 0 )', '            return;', '\tnewcounts = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),', '\tnewoffsets = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),', '\tfor (strip = 0; strip < nstrips; strip++) {', '\t\tnewoffsets[strip] = stripbytes ? offset : 0;', '\ttd->td_stripsperimage = td->td_nstrips = nstrips;']}",True,"LibTIFF 4.0.7 allows remote attackers to cause a denial of service (heap-based buffer over-read) or possibly have unspecified other impact via a crafted TIFF image, related to ""READ of size 8"" and libtiff/tif_read.c:523:22.",7.8,HIGH,2,test,2016-12-03T11:02:15Z,1
CVE-2016-10270,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,vadz/libtiff,"* libtiff/tif_dirread.c: modify ChopUpSingleUncompressedStrip() to
instanciate compute ntrips as TIFFhowmany_32(td->td_imagelength, rowsperstrip),
instead of a logic based on the total size of data. Which is faulty is
the total size of data is not sufficient to fill the whole image, and thus
results in reading outside of the StripByCounts/StripOffsets arrays when
using TIFFReadScanline().
Reported by Agostino Sarubbo.
Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2608.

* libtiff/tif_strip.c: revert the change in TIFFNumberOfStrips() done
for http://bugzilla.maptools.org/show_bug.cgi?id=2587 / CVE-2016-9273 since
the above change is a better fix that makes it unnecessary.",9a72a69e035ee70ff5c41541c8c61cd97990d018,https://github.com/vadz/libtiff/commit/9a72a69e035ee70ff5c41541c8c61cd97990d018,libtiff/tif_strip.c,TIFFNumberOfStrips,"uint32
TIFFNumberOfStrips(TIFF* tif)
{
TIFFDirectory *td = &tif->tif_dir;
uint32 nstrips;
/* If the value was already computed and store in td_nstrips, then return it,
since ChopUpSingleUncompressedStrip might have altered and resized the
since the td_stripbytecount and td_stripoffset arrays to the new value
after the initial affectation of td_nstrips = TIFFNumberOfStrips() in
tif_dirread.c ~line 3612.
See http:    if( td->td_nstrips )
return td->td_nstrips;
nstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :
TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));
if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
nstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,
""TIFFNumberOfStrips"");
return (nstrips);
}","uint32
TIFFNumberOfStrips(TIFF* VAR_0)
{
TIFFDirectory *VAR_1 = &VAR_0->tif_dir;
uint32 VAR_2;
if( VAR_1->td_nstrips )
return VAR_1->td_nstrips;
VAR_2 = (VAR_1->td_rowsperstrip == (uint32) -1 ? 1 :
TIFFhowmany_32(VAR_1->td_imagelength, VAR_1->td_rowsperstrip));
if (VAR_1->td_planarconfig == VAR_3)
VAR_2 = _TIFFMultiply32(VAR_0, VAR_2, (uint32)VAR_1->td_samplesperpixel,
""TIFFNumberOfStrips"");
return (VAR_2);
}",vadz/libtiff/9a72a69e035ee70ff5c41541c8c61cd97990d018/tif_strip.c/vul/before/0.json,"uint32
TIFFNumberOfStrips(TIFF* tif)
{
	TIFFDirectory *td = &tif->tif_dir;
	uint32 nstrips;

	nstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :
	     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));
	if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
		nstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,
		    ""TIFFNumberOfStrips"");
	return (nstrips);
}","uint32
TIFFNumberOfStrips(TIFF* VAR_0)
{
	TIFFDirectory *VAR_1 = &VAR_0->tif_dir;
	uint32 VAR_2;

	VAR_2 = (VAR_1->td_rowsperstrip == (uint32) -1 ? 1 :
	     TIFFhowmany_32(VAR_1->td_imagelength, VAR_1->td_rowsperstrip));
	if (VAR_1->td_planarconfig == VAR_3)
		VAR_2 = _TIFFMultiply32(VAR_0, VAR_2, (uint32)VAR_1->td_samplesperpixel,
		    ""TIFFNumberOfStrips"");
	return (VAR_2);
}",vadz/libtiff/9a72a69e035ee70ff5c41541c8c61cd97990d018/tif_strip.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,15 +3,6 @@
 {
 	TIFFDirectory *td = &tif->tif_dir;
 	uint32 nstrips;
-
-    /* If the value was already computed and store in td_nstrips, then return it,
-       since ChopUpSingleUncompressedStrip might have altered and resized the
-       since the td_stripbytecount and td_stripoffset arrays to the new value
-       after the initial affectation of td_nstrips = TIFFNumberOfStrips() in
-       tif_dirread.c ~line 3612.
-       See http://bugzilla.maptools.org/show_bug.cgi?id=2587 */
-    if( td->td_nstrips )
-        return td->td_nstrips;
 
 	nstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :
 	     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));","{'deleted_lines': ['', '    /* If the value was already computed and store in td_nstrips, then return it,', '       since ChopUpSingleUncompressedStrip might have altered and resized the', '       since the td_stripbytecount and td_stripoffset arrays to the new value', '       after the initial affectation of td_nstrips = TIFFNumberOfStrips() in', '       tif_dirread.c ~line 3612.', '       See http://bugzilla.maptools.org/show_bug.cgi?id=2587 */', '    if( td->td_nstrips )', '        return td->td_nstrips;'], 'added_lines': []}",True,"LibTIFF 4.0.7 allows remote attackers to cause a denial of service (heap-based buffer over-read) or possibly have unspecified other impact via a crafted TIFF image, related to ""READ of size 8"" and libtiff/tif_read.c:523:22.",7.8,HIGH,2,test,2016-12-03T11:02:15Z,1
CVE-2016-10145,['CWE-189'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ImageMagick,...,d23beebe7b1179fb75db1e85fbca3100e49593d9,https://github.com/ImageMagick/ImageMagick/commit/d23beebe7b1179fb75db1e85fbca3100e49593d9,coders/wpg.c,ExtractPostscript,"static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,
MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)
{
char
postscript_file[MaxTextExtent];
const MagicInfo
*magic_info;
FILE
*ps_file;
ImageInfo
*clone_info;
Image
*image2;
unsigned char
magick[2*MaxTextExtent];
if ((clone_info=CloneImageInfo(image_info)) == NULL)
return(image);
clone_info->blob=(void *) NULL;
clone_info->length=0;
(void) AcquireUniqueFilename(postscript_file);
ps_file=fopen_utf8(postscript_file,""wb"");
if (ps_file == (FILE *) NULL)
goto FINISH;
(void) SeekBlob(image,PS_Offset,SEEK_SET);
(void) ReadBlob(image, 2*MaxTextExtent, magick);
(void) SeekBlob(image,PS_Offset,SEEK_SET);
while(PS_Size-- > 0)
{
(void) fputc(ReadBlobByte(image),ps_file);
}
(void) fclose(ps_file);
magic_info=GetMagicInfo(magick,2*MaxTextExtent,exception);
if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;
if(exception->severity != UndefinedException) goto FINISH_UNL;
if(magic_info->name == (char *) NULL) goto FINISH_UNL;
(void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent);
FormatLocaleString(clone_info->filename,MaxTextExtent,""%s"",postscript_file);
image2=ReadImage(clone_info,exception);
if (!image2)
goto FINISH_UNL;
(void) CopyMagickString(image2->filename,image->filename,MaxTextExtent);
(void) CopyMagickString(image2->magick_filename,image->magick_filename,MaxTextExtent);
(void) CopyMagickString(image2->magick,image->magick,MaxTextExtent);
image2->depth=image->depth;
DestroyBlob(image2);
image2->blob=ReferenceBlob(image->blob);
if ((image->rows == 0) || (image->columns == 0))
DeleteImageFromList(&image);
AppendImageToList(&image,image2);
FINISH_UNL:
(void) RelinquishUniqueFileResource(postscript_file);
FINISH:
DestroyImageInfo(clone_info);
return(image);
}","static Image *ExtractPostscript(Image *VAR_0,const ImageInfo *VAR_1,
MagickOffsetType VAR_2,ssize_t VAR_3,ExceptionInfo *VAR_4)
{
char
VAR_5[VAR_6];
const MagicInfo
*VAR_7;
FILE
*VAR_8;
ImageInfo
*VAR_9;
Image
*VAR_10;
unsigned char
VAR_11[2*VAR_6];
if ((VAR_9=CloneImageInfo(VAR_1)) == NULL)
return(VAR_0);
VAR_9->blob=(void *) NULL;
VAR_9->length=0;
(void) AcquireUniqueFilename(VAR_5);
VAR_8=fopen_utf8(VAR_5,""wb"");
if (VAR_8 == (FILE *) NULL)
goto FINISH;
(void) SeekBlob(VAR_0,VAR_2,VAR_12);
(void) ReadBlob(VAR_0, 2*VAR_6, VAR_11);
(void) SeekBlob(VAR_0,VAR_2,VAR_12);
while(VAR_3-- > 0)
{
(void) fputc(ReadBlobByte(VAR_0),VAR_8);
}
(void) fclose(VAR_8);
VAR_7=GetMagicInfo(VAR_11,2*VAR_6,VAR_4);
if(VAR_7 == (const MagicInfo *) NULL) goto FINISH_UNL;
if(VAR_4->severity != VAR_13) goto FINISH_UNL;
if(VAR_7->name == (char *) NULL) goto FINISH_UNL;
(void) strncpy(VAR_9->magick,VAR_7->name,VAR_6);
FormatLocaleString(VAR_9->filename,VAR_6,""%s"",VAR_5);
VAR_10=ReadImage(VAR_9,VAR_4);
if (!VAR_10)
goto FINISH_UNL;
(void) CopyMagickString(VAR_10->filename,VAR_0->filename,VAR_6);
(void) CopyMagickString(VAR_10->magick_filename,VAR_0->magick_filename,VAR_6);
(void) CopyMagickString(VAR_10->magick,VAR_0->magick,VAR_6);
VAR_10->depth=VAR_0->depth;
DestroyBlob(VAR_10);
VAR_10->blob=ReferenceBlob(VAR_0->blob);
if ((VAR_0->rows == 0) || (VAR_0->columns == 0))
DeleteImageFromList(&VAR_0);
AppendImageToList(&VAR_0,VAR_10);
FINISH_UNL:
(void) RelinquishUniqueFileResource(VAR_5);
FINISH:
DestroyImageInfo(VAR_9);
return(VAR_0);
}",ImageMagick/d23beebe7b1179fb75db1e85fbca3100e49593d9/wpg.c/vul/before/0.json,"static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,
  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)
{
  char
    postscript_file[MaxTextExtent];

  const MagicInfo
    *magic_info;

  FILE
    *ps_file;

  ImageInfo
    *clone_info;

  Image
    *image2;

  unsigned char
    magick[2*MaxTextExtent];


  if ((clone_info=CloneImageInfo(image_info)) == NULL)
    return(image);
  clone_info->blob=(void *) NULL;
  clone_info->length=0;

  /* Obtain temporary file */
  (void) AcquireUniqueFilename(postscript_file);
  ps_file=fopen_utf8(postscript_file,""wb"");
  if (ps_file == (FILE *) NULL)
    goto FINISH;

  /* Copy postscript to temporary file */
  (void) SeekBlob(image,PS_Offset,SEEK_SET);
  (void) ReadBlob(image, 2*MaxTextExtent, magick);

  (void) SeekBlob(image,PS_Offset,SEEK_SET);
  while(PS_Size-- > 0)
    {
      (void) fputc(ReadBlobByte(image),ps_file);
    }
  (void) fclose(ps_file);

    /* Detect file format - Check magic.mgk configuration file. */
  magic_info=GetMagicInfo(magick,2*MaxTextExtent,exception);
  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;
  /*     printf(""Detected:%s  \n"",magic_info->name); */
  if(exception->severity != UndefinedException) goto FINISH_UNL;
  if(magic_info->name == (char *) NULL) goto FINISH_UNL;

  (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent-1);

    /* Read nested image */
  /*FormatString(clone_info->filename,""%s:%s"",magic_info->name,postscript_file);*/
  FormatLocaleString(clone_info->filename,MaxTextExtent,""%s"",postscript_file);
  image2=ReadImage(clone_info,exception);

  if (!image2)
    goto FINISH_UNL;

  /*
    Replace current image with new image while copying base image
    attributes.
  */
  (void) CopyMagickString(image2->filename,image->filename,MaxTextExtent);
  (void) CopyMagickString(image2->magick_filename,image->magick_filename,MaxTextExtent);
  (void) CopyMagickString(image2->magick,image->magick,MaxTextExtent);
  image2->depth=image->depth;
  DestroyBlob(image2);
  image2->blob=ReferenceBlob(image->blob);

  if ((image->rows == 0) || (image->columns == 0))
    DeleteImageFromList(&image);

  AppendImageToList(&image,image2);

 FINISH_UNL:
  (void) RelinquishUniqueFileResource(postscript_file);
 FINISH:
  DestroyImageInfo(clone_info);
  return(image);
}","static Image *ExtractPostscript(Image *VAR_0,const ImageInfo *VAR_1,
  MagickOffsetType VAR_2,ssize_t VAR_3,ExceptionInfo *VAR_4)
{
  char
    VAR_5[VAR_6];

  const MagicInfo
    *VAR_7;

  FILE
    *VAR_8;

  ImageInfo
    *VAR_9;

  Image
    *VAR_10;

  unsigned char
    VAR_11[2*VAR_6];


  if ((VAR_9=CloneImageInfo(VAR_1)) == NULL)
    return(VAR_0);
  VAR_9->blob=(void *) NULL;
  VAR_9->length=0;

  /* COMMENT_0 */
  (void) AcquireUniqueFilename(VAR_5);
  VAR_8=fopen_utf8(VAR_5,""wb"");
  if (VAR_8 == (FILE *) NULL)
    goto FINISH;

  /* COMMENT_1 */
  (void) SeekBlob(VAR_0,VAR_2,VAR_12);
  (void) ReadBlob(VAR_0, 2*VAR_6, VAR_11);

  (void) SeekBlob(VAR_0,VAR_2,VAR_12);
  while(VAR_3-- > 0)
    {
      (void) fputc(ReadBlobByte(VAR_0),VAR_8);
    }
  (void) fclose(VAR_8);

    /* COMMENT_2 */
  VAR_7=GetMagicInfo(VAR_11,2*VAR_6,VAR_4);
  if(VAR_7 == (const MagicInfo *) NULL) goto FINISH_UNL;
  /* COMMENT_3 */
  if(VAR_4->severity != VAR_13) goto FINISH_UNL;
  if(VAR_7->name == (char *) NULL) goto FINISH_UNL;

  (void) strncpy(VAR_9->magick,VAR_7->name,VAR_6-1);

    /* COMMENT_4 */
  /* COMMENT_5 */
  FormatLocaleString(VAR_9->filename,VAR_6,""%s"",VAR_5);
  VAR_10=ReadImage(VAR_9,VAR_4);

  if (!VAR_10)
    goto FINISH_UNL;

  /* COMMENT_6 */
                                                                 
               
    
  (void) CopyMagickString(VAR_10->filename,VAR_0->filename,VAR_6);
  (void) CopyMagickString(VAR_10->magick_filename,VAR_0->magick_filename,VAR_6);
  (void) CopyMagickString(VAR_10->magick,VAR_0->magick,VAR_6);
  VAR_10->depth=VAR_0->depth;
  DestroyBlob(VAR_10);
  VAR_10->blob=ReferenceBlob(VAR_0->blob);

  if ((VAR_0->rows == 0) || (VAR_0->columns == 0))
    DeleteImageFromList(&VAR_0);

  AppendImageToList(&VAR_0,VAR_10);

 FINISH_UNL:
  (void) RelinquishUniqueFileResource(VAR_5);
 FINISH:
  DestroyImageInfo(VAR_9);
  return(VAR_0);
}",ImageMagick/d23beebe7b1179fb75db1e85fbca3100e49593d9/wpg.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -49,7 +49,7 @@
   if(exception->severity != UndefinedException) goto FINISH_UNL;
   if(magic_info->name == (char *) NULL) goto FINISH_UNL;
 
-  (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent);
+  (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent-1);
 
     /* Read nested image */
   /*FormatString(clone_info->filename,""%s:%s"",magic_info->name,postscript_file);*/","{'deleted_lines': ['  (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent);'], 'added_lines': ['  (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent-1);']}",True,Off-by-one error in coders/wpg.c in ImageMagick allows remote attackers to have unspecified impact via vectors related to a string copy.,9.8,CRITICAL,3,test,2016-12-24T16:44:42Z,1
CVE-2017-11147,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:N/A:P,0,php/php-src,Fix bug #73773 - Seg fault when loading hostile phar,e5246580a85f031e1a3b8064edbaa55c1643a451,https://github.com/php/php-src/commit/e5246580a85f031e1a3b8064edbaa55c1643a451,ext/phar/phar.c,phar_parse_pharfile,"static int phar_parse_pharfile(php_stream *fp, char *fname, int fname_len, char *alias, int alias_len, long halt_offset, phar_archive_data** pphar, php_uint32 compression, char **error TSRMLS_DC) 
{
char b32[4], *buffer, *endbuffer, *savebuf;
phar_archive_data *mydata = NULL;
phar_entry_info entry;
php_uint32 manifest_len, manifest_count, manifest_flags, manifest_index, tmp_len, sig_flags;
php_uint16 manifest_ver;
php_uint32 len;
long offset;
int sig_len, register_alias = 0, temp_alias = 0;
char *signature = NULL;
if (pphar) {
*pphar = NULL;
}
if (error) {
*error = NULL;
}
if (-1 == php_stream_seek(fp, halt_offset, SEEK_SET)) {
MAPPHAR_ALLOC_FAIL(""cannot seek to __HALT_COMPILER(); location in phar \""%s\"""")
}
buffer = b32;
if (3 != php_stream_read(fp, buffer, 3)) {
MAPPHAR_ALLOC_FAIL(""internal corruption of phar \""%s\"" (truncated manifest at stub end)"")
}
if ((*buffer == ' ' || *buffer == '\n') && *(buffer + 1) == '?' && *(buffer + 2) == '>') {
int nextchar;
halt_offset += 3;
if (EOF == (nextchar = php_stream_getc(fp))) {
MAPPHAR_ALLOC_FAIL(""internal corruption of phar \""%s\"" (truncated manifest at stub end)"")
}
if ((char) nextchar == '\r') {
if (EOF == (nextchar = php_stream_getc(fp)) || (char)nextchar != '\n') {
MAPPHAR_ALLOC_FAIL(""internal corruption of phar \""%s\"" (truncated manifest at stub end)"")
}
++halt_offset;
}
if ((char) nextchar == '\n') {
++halt_offset;
}
}
if (-1 == php_stream_seek(fp, halt_offset, SEEK_SET)) {
MAPPHAR_ALLOC_FAIL(""cannot seek to __HALT_COMPILER(); location in phar \""%s\"""")
}
buffer = b32;
if (4 != php_stream_read(fp, buffer, 4)) {
MAPPHAR_ALLOC_FAIL(""internal corruption of phar \""%s\"" (truncated manifest at manifest length)"")
}
PHAR_GET_32(buffer, manifest_len);
if (manifest_len > 1048576 * 100) {
MAPPHAR_ALLOC_FAIL(""manifest cannot be larger than 100 MB in phar \""%s\"""")
}
buffer = (char *)emalloc(manifest_len);
savebuf = buffer;
endbuffer = buffer + manifest_len;
if (manifest_len < 10 || manifest_len != php_stream_read(fp, buffer, manifest_len)) {
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest header)"")
}
PHAR_GET_32(buffer, manifest_count);
if (manifest_count == 0) {
MAPPHAR_FAIL(""in phar \""%s\"", manifest claims to have zero entries.  Phars must have at least 1 entry"");
}
manifest_ver = (((unsigned char)buffer[0]) << 8)
+ ((unsigned char)buffer[1]);
buffer += 2;
if ((manifest_ver & PHAR_API_VER_MASK) < PHAR_API_MIN_READ) {
efree(savebuf);
php_stream_close(fp);
if (error) {
spprintf(error, 0, ""phar \""%s\"" is API version %1.u.%1.u.%1.u, and cannot be processed"", fname, manifest_ver >> 12, (manifest_ver >> 8) & 0xF, (manifest_ver >> 4) & 0x0F);
}
return FAILURE;
}
PHAR_GET_32(buffer, manifest_flags);
manifest_flags &= ~PHAR_HDR_COMPRESSION_MASK;
manifest_flags &= ~PHAR_FILE_COMPRESSION_MASK;
manifest_flags |= compression;
if (manifest_flags & PHAR_HDR_SIGNATURE) {
char sig_buf[8], *sig_ptr = sig_buf;
off_t read_len;
size_t end_of_phar;
if (-1 == php_stream_seek(fp, -8, SEEK_END)
|| (read_len = php_stream_tell(fp)) < 20
|| 8 != php_stream_read(fp, sig_buf, 8)
|| memcmp(sig_buf+4, ""GBMB"", 4)) {
efree(savebuf);
php_stream_close(fp);
if (error) {
spprintf(error, 0, ""phar \""%s\"" has a broken signature"", fname);
}
return FAILURE;
}
PHAR_GET_32(sig_ptr, sig_flags);
switch(sig_flags) {
case PHAR_SIG_OPENSSL: {
php_uint32 signature_len;
char *sig;
off_t whence;
if (-1 == php_stream_seek(fp, -12, SEEK_CUR)
|| 4 != php_stream_read(fp, sig_buf, 4)) {
efree(savebuf);
php_stream_close(fp);
if (error) {
spprintf(error, 0, ""phar \""%s\"" openssl signature length could not be read"", fname);
}
return FAILURE;
}
sig_ptr = sig_buf;
PHAR_GET_32(sig_ptr, signature_len);
sig = (char *) emalloc(signature_len);
whence = signature_len + 4;
whence = -whence;
if (-1 == php_stream_seek(fp, whence, SEEK_CUR)
|| !(end_of_phar = php_stream_tell(fp))
|| signature_len != php_stream_read(fp, sig, signature_len)) {
efree(savebuf);
efree(sig);
php_stream_close(fp);
if (error) {
spprintf(error, 0, ""phar \""%s\"" openssl signature could not be read"", fname);
}
return FAILURE;
}
if (FAILURE == phar_verify_signature(fp, end_of_phar, PHAR_SIG_OPENSSL, sig, signature_len, fname, &signature, &sig_len, error TSRMLS_CC)) {
efree(savebuf);
efree(sig);
php_stream_close(fp);
if (error) {
char *save = *error;
spprintf(error, 0, ""phar \""%s\"" openssl signature could not be verified: %s"", fname, *error);
efree(save);
}
return FAILURE;
}
efree(sig);
}
break;
#if PHAR_HASH_OK
case PHAR_SIG_SHA512: {
unsigned char digest[64];
php_stream_seek(fp, -(8 + 64), SEEK_END);
read_len = php_stream_tell(fp);
if (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {
efree(savebuf);
php_stream_close(fp);
if (error) {
spprintf(error, 0, ""phar \""%s\"" has a broken signature"", fname);
}
return FAILURE;
}
if (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA512, (char *)digest, 64, fname, &signature, &sig_len, error TSRMLS_CC)) {
efree(savebuf);
php_stream_close(fp);
if (error) {
char *save = *error;
spprintf(error, 0, ""phar \""%s\"" SHA512 signature could not be verified: %s"", fname, *error);
efree(save);
}
return FAILURE;
}
break;
}
case PHAR_SIG_SHA256: {
unsigned char digest[32];
php_stream_seek(fp, -(8 + 32), SEEK_END);
read_len = php_stream_tell(fp);
if (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {
efree(savebuf);
php_stream_close(fp);
if (error) {
spprintf(error, 0, ""phar \""%s\"" has a broken signature"", fname);
}
return FAILURE;
}
if (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA256, (char *)digest, 32, fname, &signature, &sig_len, error TSRMLS_CC)) {
efree(savebuf);
php_stream_close(fp);
if (error) {
char *save = *error;
spprintf(error, 0, ""phar \""%s\"" SHA256 signature could not be verified: %s"", fname, *error);
efree(save);
}
return FAILURE;
}
break;
}
#else
case PHAR_SIG_SHA512:
case PHAR_SIG_SHA256:
efree(savebuf);
php_stream_close(fp);
if (error) {
spprintf(error, 0, ""phar \""%s\"" has a unsupported signature"", fname);
}
return FAILURE;
#endif
case PHAR_SIG_SHA1: {
unsigned char digest[20];
php_stream_seek(fp, -(8 + 20), SEEK_END);
read_len = php_stream_tell(fp);
if (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {
efree(savebuf);
php_stream_close(fp);
if (error) {
spprintf(error, 0, ""phar \""%s\"" has a broken signature"", fname);
}
return FAILURE;
}
if (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA1, (char *)digest, 20, fname, &signature, &sig_len, error TSRMLS_CC)) {
efree(savebuf);
php_stream_close(fp);
if (error) {
char *save = *error;
spprintf(error, 0, ""phar \""%s\"" SHA1 signature could not be verified: %s"", fname, *error);
efree(save);
}
return FAILURE;
}
break;
}
case PHAR_SIG_MD5: {
unsigned char digest[16];
php_stream_seek(fp, -(8 + 16), SEEK_END);
read_len = php_stream_tell(fp);
if (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {
efree(savebuf);
php_stream_close(fp);
if (error) {
spprintf(error, 0, ""phar \""%s\"" has a broken signature"", fname);
}
return FAILURE;
}
if (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_MD5, (char *)digest, 16, fname, &signature, &sig_len, error TSRMLS_CC)) {
efree(savebuf);
php_stream_close(fp);
if (error) {
char *save = *error;
spprintf(error, 0, ""phar \""%s\"" MD5 signature could not be verified: %s"", fname, *error);
efree(save);
}
return FAILURE;
}
break;
}
default:
efree(savebuf);
php_stream_close(fp);
if (error) {
spprintf(error, 0, ""phar \""%s\"" has a broken or unsupported signature"", fname);
}
return FAILURE;
}
} else if (PHAR_G(require_hash)) {
efree(savebuf);
php_stream_close(fp);
if (error) {
spprintf(error, 0, ""phar \""%s\"" does not have a signature"", fname);
}
return FAILURE;
} else {
sig_flags = 0;
sig_len = 0;
}
PHAR_GET_32(buffer, tmp_len);
if (buffer + tmp_len > endbuffer) {
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (buffer overrun)"");
}
if (manifest_len < 10 + tmp_len) {
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest header)"")
}
if (tmp_len) {
if (alias && alias_len && (alias_len != (int)tmp_len || strncmp(alias, buffer, tmp_len)))
{
php_stream_close(fp);
if (signature) {
efree(signature);
}
if (error) {
spprintf(error, 0, ""cannot load phar \""%s\"" with implicit alias \""%.*s\"" under different alias \""%s\"""", fname, tmp_len, buffer, alias);
}
efree(savebuf);
return FAILURE;
}
alias_len = tmp_len;
alias = buffer;
buffer += tmp_len;
register_alias = 1;
} else if (!alias_len || !alias) {
alias = NULL;
alias_len = 0;
register_alias = 0;
} else if (alias_len) {
register_alias = 1;
temp_alias = 1;
}
if (manifest_count > ((manifest_len - 10 - tmp_len) / (5 * 4 + 1))) {
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (too many manifest entries for size of manifest)"")
}
mydata = pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));
mydata->is_persistent = PHAR_G(persist);
PHAR_GET_32(buffer, len);
if (mydata->is_persistent) {
mydata->metadata_len = len;
if(!len) {
PHAR_GET_32(buffer, len);
}
}
if(len > endbuffer - buffer) {
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (trying to read past buffer end)"");
}
if (phar_parse_metadata(&buffer, &mydata->metadata, len TSRMLS_CC) == FAILURE) {
MAPPHAR_FAIL(""unable to read phar metadata in .phar file \""%s\"""");
}
buffer += len;
zend_hash_init(&mydata->manifest, manifest_count,
zend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)mydata->is_persistent);
zend_hash_init(&mydata->mounted_dirs, 5,
zend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);
zend_hash_init(&mydata->virtual_dirs, manifest_count * 2,
zend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);
mydata->fname = pestrndup(fname, fname_len, mydata->is_persistent);
#ifdef PHP_WIN32
phar_unixify_path_separators(mydata->fname, fname_len);
#endif
mydata->fname_len = fname_len;
offset = halt_offset + manifest_len + 4;
memset(&entry, 0, sizeof(phar_entry_info));
entry.phar = mydata;
entry.fp_type = PHAR_FP;
entry.is_persistent = mydata->is_persistent;
for (manifest_index = 0; manifest_index < manifest_count; ++manifest_index) {
if (buffer + 24 > endbuffer) {
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest entry)"")
}
PHAR_GET_32(buffer, entry.filename_len);
if (entry.filename_len == 0) {
MAPPHAR_FAIL(""zero-length filename encountered in phar \""%s\"""");
}
if (entry.is_persistent) {
entry.manifest_pos = manifest_index;
}
if (entry.filename_len > endbuffer - buffer - 20) {
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest entry)"");
}
if ((manifest_ver & PHAR_API_VER_MASK) >= PHAR_API_MIN_DIR && buffer[entry.filename_len - 1] == '/') {
entry.is_dir = 1;
} else {
entry.is_dir = 0;
}
phar_add_virtual_dirs(mydata, buffer, entry.filename_len TSRMLS_CC);
entry.filename = pestrndup(buffer, entry.filename_len, entry.is_persistent);
buffer += entry.filename_len;
PHAR_GET_32(buffer, entry.uncompressed_filesize);
PHAR_GET_32(buffer, entry.timestamp);
if (offset == halt_offset + (int)manifest_len + 4) {
mydata->min_timestamp = entry.timestamp;
mydata->max_timestamp = entry.timestamp;
} else {
if (mydata->min_timestamp > entry.timestamp) {
mydata->min_timestamp = entry.timestamp;
} else if (mydata->max_timestamp < entry.timestamp) {
mydata->max_timestamp = entry.timestamp;
}
}
PHAR_GET_32(buffer, entry.compressed_filesize);
PHAR_GET_32(buffer, entry.crc32);
PHAR_GET_32(buffer, entry.flags);
if (entry.is_dir) {
entry.filename_len--;
entry.flags |= PHAR_ENT_PERM_DEF_DIR;
}
PHAR_GET_32(buffer, len);
if (entry.is_persistent) {
entry.metadata_len = len;
} else {
entry.metadata_len = 0;
}
if (len > endbuffer - buffer) {
pefree(entry.filename, entry.is_persistent);
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest entry)"");
}
if (phar_parse_metadata(&buffer, &entry.metadata, len TSRMLS_CC) == FAILURE) {
pefree(entry.filename, entry.is_persistent);
MAPPHAR_FAIL(""unable to read file metadata in .phar file \""%s\"""");
}
buffer += len;
entry.offset = entry.offset_abs = offset;
offset += entry.compressed_filesize;
switch (entry.flags & PHAR_ENT_COMPRESSION_MASK) {
case PHAR_ENT_COMPRESSED_GZ:
if (!PHAR_G(has_zlib)) {
if (entry.metadata) {
if (entry.is_persistent) {
free(entry.metadata);
} else {
zval_ptr_dtor(&entry.metadata);
}
}
pefree(entry.filename, entry.is_persistent);
MAPPHAR_FAIL(""zlib extension is required for gz compressed .phar file \""%s\"""");
}
break;
case PHAR_ENT_COMPRESSED_BZ2:
if (!PHAR_G(has_bz2)) {
if (entry.metadata) {
if (entry.is_persistent) {
free(entry.metadata);
} else {
zval_ptr_dtor(&entry.metadata);
}
}
pefree(entry.filename, entry.is_persistent);
MAPPHAR_FAIL(""bz2 extension is required for bzip2 compressed .phar file \""%s\"""");
}
break;
default:
if (entry.uncompressed_filesize != entry.compressed_filesize) {
if (entry.metadata) {
if (entry.is_persistent) {
free(entry.metadata);
} else {
zval_ptr_dtor(&entry.metadata);
}
}
pefree(entry.filename, entry.is_persistent);
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (compressed and uncompressed size does not match for uncompressed entry)"");
}
break;
}
manifest_flags |= (entry.flags & PHAR_ENT_COMPRESSION_MASK);
entry.is_crc_checked = (manifest_flags & PHAR_HDR_SIGNATURE ? 1 : 0);
phar_set_inode(&entry TSRMLS_CC);
zend_hash_add(&mydata->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info), NULL);
}
snprintf(mydata->version, sizeof(mydata->version), ""%u.%u.%u"", manifest_ver >> 12, (manifest_ver >> 8) & 0xF, (manifest_ver >> 4) & 0xF);
mydata->internal_file_start = halt_offset + manifest_len + 4;
mydata->halt_offset = halt_offset;
mydata->flags = manifest_flags;
endbuffer = strrchr(mydata->fname, '/');
if (endbuffer) {
mydata->ext = memchr(endbuffer, '.', (mydata->fname + fname_len) - endbuffer);
if (mydata->ext == endbuffer) {
mydata->ext = memchr(endbuffer + 1, '.', (mydata->fname + fname_len) - endbuffer - 1);
}
if (mydata->ext) {
mydata->ext_len = (mydata->fname + mydata->fname_len) - mydata->ext;
}
}
mydata->alias = alias ?
pestrndup(alias, alias_len, mydata->is_persistent) :
pestrndup(mydata->fname, fname_len, mydata->is_persistent);
mydata->alias_len = alias ? alias_len : fname_len;
mydata->sig_flags = sig_flags;
mydata->fp = fp;
mydata->sig_len = sig_len;
mydata->signature = signature;
phar_request_initialize(TSRMLS_C);
if (register_alias) {
phar_archive_data **fd_ptr;
mydata->is_temporary_alias = temp_alias;
if (!phar_validate_alias(mydata->alias, mydata->alias_len)) {
signature = NULL;
fp = NULL;
MAPPHAR_FAIL(""Cannot open archive \""%s\"", invalid alias"");
}
if (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {
if (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {
signature = NULL;
fp = NULL;
MAPPHAR_FAIL(""Cannot open archive \""%s\"", alias is already in use by existing archive"");
}
}
zend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&mydata, sizeof(phar_archive_data*), NULL);
} else {
mydata->is_temporary_alias = 1;
}
zend_hash_add(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len, (void*)&mydata, sizeof(phar_archive_data*),  NULL);
efree(savebuf);
if (pphar) {
*pphar = mydata;
}
return SUCCESS;
}","static int phar_parse_pharfile(php_stream *VAR_0, char *VAR_1, int VAR_2, char *VAR_3, int VAR_4, long VAR_5, phar_archive_data** VAR_6, php_uint32 VAR_7, char **VAR_8 TSRMLS_DC) 
{
char VAR_9[4], *VAR_10, *VAR_11, *VAR_12;
phar_archive_data *VAR_13 = NULL;
phar_entry_info VAR_14;
php_uint32 VAR_15, VAR_16, VAR_17, VAR_18, VAR_19, VAR_20;
php_uint16 VAR_21;
php_uint32 VAR_22;
long VAR_23;
int VAR_24, VAR_25 = 0, VAR_26 = 0;
char *VAR_27 = NULL;
if (VAR_6) {
*VAR_6 = NULL;
}
if (VAR_8) {
*VAR_8 = NULL;
}
if (-1 == php_stream_seek(VAR_0, VAR_5, VAR_28)) {
MAPPHAR_ALLOC_FAIL(""cannot seek to __HALT_COMPILER(); location in phar \""%s\"""")
}
VAR_10 = VAR_9;
if (3 != php_stream_read(VAR_0, VAR_10, 3)) {
MAPPHAR_ALLOC_FAIL(""internal corruption of phar \""%s\"" (truncated manifest at stub end)"")
}
if ((*VAR_10 == ' ' || *VAR_10 == '\n') && *(VAR_10 + 1) == '?' && *(VAR_10 + 2) == '>') {
int VAR_29;
VAR_5 += 3;
if (VAR_30 == (VAR_29 = php_stream_getc(VAR_0))) {
MAPPHAR_ALLOC_FAIL(""internal corruption of phar \""%s\"" (truncated manifest at stub end)"")
}
if ((char) VAR_29 == '\r') {
if (VAR_30 == (VAR_29 = php_stream_getc(VAR_0)) || (char)VAR_29 != '\n') {
MAPPHAR_ALLOC_FAIL(""internal corruption of phar \""%s\"" (truncated manifest at stub end)"")
}
++VAR_5;
}
if ((char) VAR_29 == '\n') {
++VAR_5;
}
}
if (-1 == php_stream_seek(VAR_0, VAR_5, VAR_28)) {
MAPPHAR_ALLOC_FAIL(""cannot seek to __HALT_COMPILER(); location in phar \""%s\"""")
}
VAR_10 = VAR_9;
if (4 != php_stream_read(VAR_0, VAR_10, 4)) {
MAPPHAR_ALLOC_FAIL(""internal corruption of phar \""%s\"" (truncated manifest at manifest length)"")
}
PHAR_GET_32(VAR_10, VAR_15);
if (VAR_15 > 1048576 * 100) {
MAPPHAR_ALLOC_FAIL(""manifest cannot be larger than 100 MB in phar \""%s\"""")
}
VAR_10 = (char *)emalloc(VAR_15);
VAR_12 = VAR_10;
VAR_11 = VAR_10 + VAR_15;
if (VAR_15 < 10 || VAR_15 != php_stream_read(VAR_0, VAR_10, VAR_15)) {
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest header)"")
}
PHAR_GET_32(VAR_10, VAR_16);
if (VAR_16 == 0) {
MAPPHAR_FAIL(""in phar \""%s\"", manifest claims to have zero entries.  Phars must have at least 1 entry"");
}
VAR_21 = (((unsigned char)VAR_10[0]) << 8)
+ ((unsigned char)VAR_10[1]);
VAR_10 += 2;
if ((VAR_21 & VAR_31) < VAR_32) {
efree(VAR_12);
php_stream_close(VAR_0);
if (VAR_8) {
spprintf(VAR_8, 0, ""phar \""%s\"" is API version %1.u.%1.u.%1.u, and cannot be processed"", VAR_1, VAR_21 >> 12, (VAR_21 >> 8) & 0xF, (VAR_21 >> 4) & 0x0F);
}
return VAR_33;
}
PHAR_GET_32(VAR_10, VAR_17);
VAR_17 &= ~VAR_34;
VAR_17 &= ~VAR_35;
VAR_17 |= VAR_7;
if (VAR_17 & VAR_36) {
char VAR_37[8], *VAR_38 = VAR_37;
off_t VAR_39;
size_t VAR_40;
if (-1 == php_stream_seek(VAR_0, -8, VAR_41)
|| (VAR_39 = php_stream_tell(VAR_0)) < 20
|| 8 != php_stream_read(VAR_0, VAR_37, 8)
|| memcmp(VAR_37+4, ""GBMB"", 4)) {
efree(VAR_12);
php_stream_close(VAR_0);
if (VAR_8) {
spprintf(VAR_8, 0, ""phar \""%s\"" has a broken signature"", VAR_1);
}
return VAR_33;
}
PHAR_GET_32(VAR_38, VAR_20);
switch(VAR_20) {
case VAR_42: {
php_uint32 VAR_43;
char *VAR_44;
off_t VAR_45;
if (-1 == php_stream_seek(VAR_0, -12, VAR_46)
|| 4 != php_stream_read(VAR_0, VAR_37, 4)) {
efree(VAR_12);
php_stream_close(VAR_0);
if (VAR_8) {
spprintf(VAR_8, 0, ""phar \""%s\"" openssl signature length could not be read"", VAR_1);
}
return VAR_33;
}
VAR_38 = VAR_37;
PHAR_GET_32(VAR_38, VAR_43);
VAR_44 = (char *) emalloc(VAR_43);
VAR_45 = VAR_43 + 4;
VAR_45 = -VAR_45;
if (-1 == php_stream_seek(VAR_0, VAR_45, VAR_46)
|| !(VAR_40 = php_stream_tell(VAR_0))
|| VAR_43 != php_stream_read(VAR_0, VAR_44, VAR_43)) {
efree(VAR_12);
efree(VAR_44);
php_stream_close(VAR_0);
if (VAR_8) {
spprintf(VAR_8, 0, ""phar \""%s\"" openssl signature could not be read"", VAR_1);
}
return VAR_33;
}
if (VAR_33 == phar_verify_signature(VAR_0, VAR_40, VAR_42, VAR_44, VAR_43, VAR_1, &VAR_27, &VAR_24, VAR_8 VAR_47)) {
efree(VAR_12);
efree(VAR_44);
php_stream_close(VAR_0);
if (VAR_8) {
char *VAR_48 = *VAR_8;
spprintf(VAR_8, 0, ""phar \""%s\"" openssl signature could not be verified: %s"", VAR_1, *VAR_8);
efree(VAR_48);
}
return VAR_33;
}
efree(VAR_44);
}
break;
#if VAR_49
case VAR_50: {
unsigned char VAR_51[64];
php_stream_seek(VAR_0, -(8 + 64), VAR_41);
VAR_39 = php_stream_tell(VAR_0);
if (php_stream_read(VAR_0, (char*)VAR_51, sizeof(VAR_51)) != sizeof(VAR_51)) {
efree(VAR_12);
php_stream_close(VAR_0);
if (VAR_8) {
spprintf(VAR_8, 0, ""phar \""%s\"" has a broken signature"", VAR_1);
}
return VAR_33;
}
if (VAR_33 == phar_verify_signature(VAR_0, VAR_39, VAR_50, (char *)VAR_51, 64, VAR_1, &VAR_27, &VAR_24, VAR_8 VAR_47)) {
efree(VAR_12);
php_stream_close(VAR_0);
if (VAR_8) {
char *VAR_48 = *VAR_8;
spprintf(VAR_8, 0, ""phar \""%s\"" SHA512 signature could not be verified: %s"", VAR_1, *VAR_8);
efree(VAR_48);
}
return VAR_33;
}
break;
}
case VAR_52: {
unsigned char VAR_51[32];
php_stream_seek(VAR_0, -(8 + 32), VAR_41);
VAR_39 = php_stream_tell(VAR_0);
if (php_stream_read(VAR_0, (char*)VAR_51, sizeof(VAR_51)) != sizeof(VAR_51)) {
efree(VAR_12);
php_stream_close(VAR_0);
if (VAR_8) {
spprintf(VAR_8, 0, ""phar \""%s\"" has a broken signature"", VAR_1);
}
return VAR_33;
}
if (VAR_33 == phar_verify_signature(VAR_0, VAR_39, VAR_52, (char *)VAR_51, 32, VAR_1, &VAR_27, &VAR_24, VAR_8 VAR_47)) {
efree(VAR_12);
php_stream_close(VAR_0);
if (VAR_8) {
char *VAR_48 = *VAR_8;
spprintf(VAR_8, 0, ""phar \""%s\"" SHA256 signature could not be verified: %s"", VAR_1, *VAR_8);
efree(VAR_48);
}
return VAR_33;
}
break;
}
#else
case VAR_50:
case VAR_52:
efree(VAR_12);
php_stream_close(VAR_0);
if (VAR_8) {
spprintf(VAR_8, 0, ""phar \""%s\"" has a unsupported signature"", VAR_1);
}
return VAR_33;
#endif
case VAR_53: {
unsigned char VAR_51[20];
php_stream_seek(VAR_0, -(8 + 20), VAR_41);
VAR_39 = php_stream_tell(VAR_0);
if (php_stream_read(VAR_0, (char*)VAR_51, sizeof(VAR_51)) != sizeof(VAR_51)) {
efree(VAR_12);
php_stream_close(VAR_0);
if (VAR_8) {
spprintf(VAR_8, 0, ""phar \""%s\"" has a broken signature"", VAR_1);
}
return VAR_33;
}
if (VAR_33 == phar_verify_signature(VAR_0, VAR_39, VAR_53, (char *)VAR_51, 20, VAR_1, &VAR_27, &VAR_24, VAR_8 VAR_47)) {
efree(VAR_12);
php_stream_close(VAR_0);
if (VAR_8) {
char *VAR_48 = *VAR_8;
spprintf(VAR_8, 0, ""phar \""%s\"" SHA1 signature could not be verified: %s"", VAR_1, *VAR_8);
efree(VAR_48);
}
return VAR_33;
}
break;
}
case VAR_54: {
unsigned char VAR_51[16];
php_stream_seek(VAR_0, -(8 + 16), VAR_41);
VAR_39 = php_stream_tell(VAR_0);
if (php_stream_read(VAR_0, (char*)VAR_51, sizeof(VAR_51)) != sizeof(VAR_51)) {
efree(VAR_12);
php_stream_close(VAR_0);
if (VAR_8) {
spprintf(VAR_8, 0, ""phar \""%s\"" has a broken signature"", VAR_1);
}
return VAR_33;
}
if (VAR_33 == phar_verify_signature(VAR_0, VAR_39, VAR_54, (char *)VAR_51, 16, VAR_1, &VAR_27, &VAR_24, VAR_8 VAR_47)) {
efree(VAR_12);
php_stream_close(VAR_0);
if (VAR_8) {
char *VAR_48 = *VAR_8;
spprintf(VAR_8, 0, ""phar \""%s\"" MD5 signature could not be verified: %s"", VAR_1, *VAR_8);
efree(VAR_48);
}
return VAR_33;
}
break;
}
default:
efree(VAR_12);
php_stream_close(VAR_0);
if (VAR_8) {
spprintf(VAR_8, 0, ""phar \""%s\"" has a broken or unsupported signature"", VAR_1);
}
return VAR_33;
}
} else if (PHAR_G(VAR_55)) {
efree(VAR_12);
php_stream_close(VAR_0);
if (VAR_8) {
spprintf(VAR_8, 0, ""phar \""%s\"" does not have a signature"", VAR_1);
}
return VAR_33;
} else {
VAR_20 = 0;
VAR_24 = 0;
}
PHAR_GET_32(VAR_10, VAR_19);
if (VAR_10 + VAR_19 > VAR_11) {
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (buffer overrun)"");
}
if (VAR_15 < 10 + VAR_19) {
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest header)"")
}
if (VAR_19) {
if (VAR_3 && VAR_4 && (VAR_4 != (int)VAR_19 || strncmp(VAR_3, VAR_10, VAR_19)))
{
php_stream_close(VAR_0);
if (VAR_27) {
efree(VAR_27);
}
if (VAR_8) {
spprintf(VAR_8, 0, ""cannot load phar \""%s\"" with implicit alias \""%.*s\"" under different alias \""%s\"""", VAR_1, VAR_19, VAR_10, VAR_3);
}
efree(VAR_12);
return VAR_33;
}
VAR_4 = VAR_19;
VAR_3 = VAR_10;
VAR_10 += VAR_19;
VAR_25 = 1;
} else if (!VAR_4 || !VAR_3) {
VAR_3 = NULL;
VAR_4 = 0;
VAR_25 = 0;
} else if (VAR_4) {
VAR_25 = 1;
VAR_26 = 1;
}
if (VAR_16 > ((VAR_15 - 10 - VAR_19) / (5 * 4 + 1))) {
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (too many manifest entries for size of manifest)"")
}
VAR_13 = pecalloc(1, sizeof(phar_archive_data), PHAR_G(VAR_56));
VAR_13->is_persistent = PHAR_G(VAR_56);
PHAR_GET_32(VAR_10, VAR_22);
if (VAR_13->is_persistent) {
VAR_13->metadata_len = VAR_22;
if(!VAR_22) {
PHAR_GET_32(VAR_10, VAR_22);
}
}
if(VAR_22 > VAR_11 - VAR_10) {
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (trying to read past buffer end)"");
}
if (phar_parse_metadata(&VAR_10, &VAR_13->metadata, VAR_22 VAR_47) == VAR_33) {
MAPPHAR_FAIL(""unable to read phar metadata in .phar file \""%s\"""");
}
VAR_10 += VAR_22;
zend_hash_init(&VAR_13->manifest, VAR_16,
VAR_57, VAR_58, (zend_bool)VAR_13->is_persistent);
zend_hash_init(&VAR_13->mounted_dirs, 5,
VAR_57, NULL, (zend_bool)VAR_13->is_persistent);
zend_hash_init(&VAR_13->virtual_dirs, VAR_16 * 2,
VAR_57, NULL, (zend_bool)VAR_13->is_persistent);
VAR_13->fname = pestrndup(VAR_1, VAR_2, VAR_13->is_persistent);
#ifdef VAR_59
phar_unixify_path_separators(VAR_13->fname, VAR_2);
#endif
VAR_13->fname_len = VAR_2;
VAR_23 = VAR_5 + VAR_15 + 4;
memset(&VAR_14, 0, sizeof(phar_entry_info));
VAR_14.phar = VAR_13;
VAR_14.fp_type = VAR_60;
VAR_14.is_persistent = VAR_13->is_persistent;
for (VAR_18 = 0; VAR_18 < VAR_16; ++VAR_18) {
if (VAR_10 + 24 > VAR_11) {
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest entry)"")
}
PHAR_GET_32(VAR_10, VAR_14.filename_len);
if (VAR_14.filename_len == 0) {
MAPPHAR_FAIL(""zero-length filename encountered in phar \""%s\"""");
}
if (VAR_14.is_persistent) {
VAR_14.manifest_pos = VAR_18;
}
if (VAR_14.filename_len > VAR_11 - VAR_10 - 20) {
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest entry)"");
}
if ((VAR_21 & VAR_31) >= VAR_61 && VAR_10[VAR_14.filename_len - 1] == '/') {
VAR_14.is_dir = 1;
} else {
VAR_14.is_dir = 0;
}
phar_add_virtual_dirs(VAR_13, VAR_10, VAR_14.filename_len VAR_47);
VAR_14.filename = pestrndup(VAR_10, VAR_14.filename_len, VAR_14.is_persistent);
VAR_10 += VAR_14.filename_len;
PHAR_GET_32(VAR_10, VAR_14.uncompressed_filesize);
PHAR_GET_32(VAR_10, VAR_14.timestamp);
if (VAR_23 == VAR_5 + (int)VAR_15 + 4) {
VAR_13->min_timestamp = VAR_14.timestamp;
VAR_13->max_timestamp = VAR_14.timestamp;
} else {
if (VAR_13->min_timestamp > VAR_14.timestamp) {
VAR_13->min_timestamp = VAR_14.timestamp;
} else if (VAR_13->max_timestamp < VAR_14.timestamp) {
VAR_13->max_timestamp = VAR_14.timestamp;
}
}
PHAR_GET_32(VAR_10, VAR_14.compressed_filesize);
PHAR_GET_32(VAR_10, VAR_14.crc32);
PHAR_GET_32(VAR_10, VAR_14.flags);
if (VAR_14.is_dir) {
VAR_14.filename_len--;
VAR_14.flags |= VAR_62;
}
PHAR_GET_32(VAR_10, VAR_22);
if (VAR_14.is_persistent) {
VAR_14.metadata_len = VAR_22;
} else {
VAR_14.metadata_len = 0;
}
if (VAR_22 > VAR_11 - VAR_10) {
pefree(VAR_14.filename, VAR_14.is_persistent);
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest entry)"");
}
if (phar_parse_metadata(&VAR_10, &VAR_14.metadata, VAR_22 VAR_47) == VAR_33) {
pefree(VAR_14.filename, VAR_14.is_persistent);
MAPPHAR_FAIL(""unable to read file metadata in .phar file \""%s\"""");
}
VAR_10 += VAR_22;
VAR_14.offset = VAR_14.offset_abs = VAR_23;
VAR_23 += VAR_14.compressed_filesize;
switch (VAR_14.flags & VAR_63) {
case VAR_64:
if (!PHAR_G(VAR_65)) {
if (VAR_14.metadata) {
if (VAR_14.is_persistent) {
free(VAR_14.metadata);
} else {
zval_ptr_dtor(&VAR_14.metadata);
}
}
pefree(VAR_14.filename, VAR_14.is_persistent);
MAPPHAR_FAIL(""zlib extension is required for gz compressed .phar file \""%s\"""");
}
break;
case VAR_66:
if (!PHAR_G(VAR_67)) {
if (VAR_14.metadata) {
if (VAR_14.is_persistent) {
free(VAR_14.metadata);
} else {
zval_ptr_dtor(&VAR_14.metadata);
}
}
pefree(VAR_14.filename, VAR_14.is_persistent);
MAPPHAR_FAIL(""bz2 extension is required for bzip2 compressed .phar file \""%s\"""");
}
break;
default:
if (VAR_14.uncompressed_filesize != VAR_14.compressed_filesize) {
if (VAR_14.metadata) {
if (VAR_14.is_persistent) {
free(VAR_14.metadata);
} else {
zval_ptr_dtor(&VAR_14.metadata);
}
}
pefree(VAR_14.filename, VAR_14.is_persistent);
MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (compressed and uncompressed size does not match for uncompressed entry)"");
}
break;
}
VAR_17 |= (VAR_14.flags & VAR_63);
VAR_14.is_crc_checked = (VAR_17 & VAR_36 ? 1 : 0);
phar_set_inode(&VAR_14 VAR_47);
zend_hash_add(&VAR_13->manifest, VAR_14.filename, VAR_14.filename_len, (void*)&VAR_14, sizeof(phar_entry_info), NULL);
}
snprintf(VAR_13->version, sizeof(VAR_13->version), ""%u.%u.%u"", VAR_21 >> 12, (VAR_21 >> 8) & 0xF, (VAR_21 >> 4) & 0xF);
VAR_13->internal_file_start = VAR_5 + VAR_15 + 4;
VAR_13->halt_offset = VAR_5;
VAR_13->flags = VAR_17;
VAR_11 = strrchr(VAR_13->fname, '/');
if (VAR_11) {
VAR_13->ext = memchr(VAR_11, '.', (VAR_13->fname + VAR_2) - VAR_11);
if (VAR_13->ext == VAR_11) {
VAR_13->ext = memchr(VAR_11 + 1, '.', (VAR_13->fname + VAR_2) - VAR_11 - 1);
}
if (VAR_13->ext) {
VAR_13->ext_len = (VAR_13->fname + VAR_13->fname_len) - VAR_13->ext;
}
}
VAR_13->alias = VAR_3 ?
pestrndup(VAR_3, VAR_4, VAR_13->is_persistent) :
pestrndup(VAR_13->fname, VAR_2, VAR_13->is_persistent);
VAR_13->alias_len = VAR_3 ? VAR_4 : VAR_2;
VAR_13->sig_flags = VAR_20;
VAR_13->fp = VAR_0;
VAR_13->sig_len = VAR_24;
VAR_13->signature = VAR_27;
phar_request_initialize(VAR_68);
if (VAR_25) {
phar_archive_data **VAR_69;
VAR_13->is_temporary_alias = VAR_26;
if (!phar_validate_alias(VAR_13->alias, VAR_13->alias_len)) {
VAR_27 = NULL;
VAR_0 = NULL;
MAPPHAR_FAIL(""Cannot open archive \""%s\"", invalid alias"");
}
if (VAR_70 == zend_hash_find(&(VAR_71->phar_alias_map), VAR_3, VAR_4, (void **)&VAR_69)) {
if (VAR_70 != phar_free_alias(*VAR_69, VAR_3, VAR_4 VAR_47)) {
VAR_27 = NULL;
VAR_0 = NULL;
MAPPHAR_FAIL(""Cannot open archive \""%s\"", alias is already in use by existing archive"");
}
}
zend_hash_add(&(VAR_71->phar_alias_map), VAR_3, VAR_4, (void*)&VAR_13, sizeof(phar_archive_data*), NULL);
} else {
VAR_13->is_temporary_alias = 1;
}
zend_hash_add(&(VAR_71->phar_fname_map), VAR_13->fname, VAR_2, (void*)&VAR_13, sizeof(phar_archive_data*),  NULL);
efree(VAR_12);
if (VAR_6) {
*VAR_6 = VAR_13;
}
return VAR_70;
}",,"static int phar_parse_pharfile(php_stream *fp, char *fname, int fname_len, char *alias, int alias_len, long halt_offset, phar_archive_data** pphar, php_uint32 compression, char **error TSRMLS_DC) /* {{{ */
{
	char b32[4], *buffer, *endbuffer, *savebuf;
	phar_archive_data *mydata = NULL;
	phar_entry_info entry;
	php_uint32 manifest_len, manifest_count, manifest_flags, manifest_index, tmp_len, sig_flags;
	php_uint16 manifest_ver;
	php_uint32 len;
	long offset;
	int sig_len, register_alias = 0, temp_alias = 0;
	char *signature = NULL;

	if (pphar) {
		*pphar = NULL;
	}

	if (error) {
		*error = NULL;
	}

	/* check for ?>\n and increment accordingly */
	if (-1 == php_stream_seek(fp, halt_offset, SEEK_SET)) {
		MAPPHAR_ALLOC_FAIL(""cannot seek to __HALT_COMPILER(); location in phar \""%s\"""")
	}

	buffer = b32;

	if (3 != php_stream_read(fp, buffer, 3)) {
		MAPPHAR_ALLOC_FAIL(""internal corruption of phar \""%s\"" (truncated manifest at stub end)"")
	}

	if ((*buffer == ' ' || *buffer == '\n') && *(buffer + 1) == '?' && *(buffer + 2) == '>') {
		int nextchar;
		halt_offset += 3;
		if (EOF == (nextchar = php_stream_getc(fp))) {
			MAPPHAR_ALLOC_FAIL(""internal corruption of phar \""%s\"" (truncated manifest at stub end)"")
		}

		if ((char) nextchar == '\r') {
			/* if we have an \r we require an \n as well */
			if (EOF == (nextchar = php_stream_getc(fp)) || (char)nextchar != '\n') {
				MAPPHAR_ALLOC_FAIL(""internal corruption of phar \""%s\"" (truncated manifest at stub end)"")
			}
			++halt_offset;
		}

		if ((char) nextchar == '\n') {
			++halt_offset;
		}
	}

	/* make sure we are at the right location to read the manifest */
	if (-1 == php_stream_seek(fp, halt_offset, SEEK_SET)) {
		MAPPHAR_ALLOC_FAIL(""cannot seek to __HALT_COMPILER(); location in phar \""%s\"""")
	}

	/* read in manifest */
	buffer = b32;

	if (4 != php_stream_read(fp, buffer, 4)) {
		MAPPHAR_ALLOC_FAIL(""internal corruption of phar \""%s\"" (truncated manifest at manifest length)"")
	}

	PHAR_GET_32(buffer, manifest_len);

	if (manifest_len > 1048576 * 100) {
		/* prevent serious memory issues by limiting manifest to at most 100 MB in length */
		MAPPHAR_ALLOC_FAIL(""manifest cannot be larger than 100 MB in phar \""%s\"""")
	}

	buffer = (char *)emalloc(manifest_len);
	savebuf = buffer;
	endbuffer = buffer + manifest_len;

	if (manifest_len < 10 || manifest_len != php_stream_read(fp, buffer, manifest_len)) {
		MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest header)"")
	}

	/* extract the number of entries */
	PHAR_GET_32(buffer, manifest_count);

	if (manifest_count == 0) {
		MAPPHAR_FAIL(""in phar \""%s\"", manifest claims to have zero entries.  Phars must have at least 1 entry"");
	}

	/* extract API version, lowest nibble currently unused */
	manifest_ver = (((unsigned char)buffer[0]) << 8)
				 + ((unsigned char)buffer[1]);
	buffer += 2;

	if ((manifest_ver & PHAR_API_VER_MASK) < PHAR_API_MIN_READ) {
		efree(savebuf);
		php_stream_close(fp);
		if (error) {
			spprintf(error, 0, ""phar \""%s\"" is API version %1.u.%1.u.%1.u, and cannot be processed"", fname, manifest_ver >> 12, (manifest_ver >> 8) & 0xF, (manifest_ver >> 4) & 0x0F);
		}
		return FAILURE;
	}

	PHAR_GET_32(buffer, manifest_flags);

	manifest_flags &= ~PHAR_HDR_COMPRESSION_MASK;
	manifest_flags &= ~PHAR_FILE_COMPRESSION_MASK;
	/* remember whether this entire phar was compressed with gz/bzip2 */
	manifest_flags |= compression;

	/* The lowest nibble contains the phar wide flags. The compression flags can */
	/* be ignored on reading because it is being generated anyways. */
	if (manifest_flags & PHAR_HDR_SIGNATURE) {
		char sig_buf[8], *sig_ptr = sig_buf;
		off_t read_len;
		size_t end_of_phar;

		if (-1 == php_stream_seek(fp, -8, SEEK_END)
		|| (read_len = php_stream_tell(fp)) < 20
		|| 8 != php_stream_read(fp, sig_buf, 8)
		|| memcmp(sig_buf+4, ""GBMB"", 4)) {
			efree(savebuf);
			php_stream_close(fp);
			if (error) {
				spprintf(error, 0, ""phar \""%s\"" has a broken signature"", fname);
			}
			return FAILURE;
		}

		PHAR_GET_32(sig_ptr, sig_flags);

		switch(sig_flags) {
			case PHAR_SIG_OPENSSL: {
				php_uint32 signature_len;
				char *sig;
				off_t whence;

				/* we store the signature followed by the signature length */
				if (-1 == php_stream_seek(fp, -12, SEEK_CUR)
				|| 4 != php_stream_read(fp, sig_buf, 4)) {
					efree(savebuf);
					php_stream_close(fp);
					if (error) {
						spprintf(error, 0, ""phar \""%s\"" openssl signature length could not be read"", fname);
					}
					return FAILURE;
				}

				sig_ptr = sig_buf;
				PHAR_GET_32(sig_ptr, signature_len);
				sig = (char *) emalloc(signature_len);
				whence = signature_len + 4;
				whence = -whence;

				if (-1 == php_stream_seek(fp, whence, SEEK_CUR)
				|| !(end_of_phar = php_stream_tell(fp))
				|| signature_len != php_stream_read(fp, sig, signature_len)) {
					efree(savebuf);
					efree(sig);
					php_stream_close(fp);
					if (error) {
						spprintf(error, 0, ""phar \""%s\"" openssl signature could not be read"", fname);
					}
					return FAILURE;
				}

				if (FAILURE == phar_verify_signature(fp, end_of_phar, PHAR_SIG_OPENSSL, sig, signature_len, fname, &signature, &sig_len, error TSRMLS_CC)) {
					efree(savebuf);
					efree(sig);
					php_stream_close(fp);
					if (error) {
						char *save = *error;
						spprintf(error, 0, ""phar \""%s\"" openssl signature could not be verified: %s"", fname, *error);
						efree(save);
					}
					return FAILURE;
				}
				efree(sig);
			}
			break;
#if PHAR_HASH_OK
			case PHAR_SIG_SHA512: {
				unsigned char digest[64];

				php_stream_seek(fp, -(8 + 64), SEEK_END);
				read_len = php_stream_tell(fp);

				if (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {
					efree(savebuf);
					php_stream_close(fp);
					if (error) {
						spprintf(error, 0, ""phar \""%s\"" has a broken signature"", fname);
					}
					return FAILURE;
				}

				if (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA512, (char *)digest, 64, fname, &signature, &sig_len, error TSRMLS_CC)) {
					efree(savebuf);
					php_stream_close(fp);
					if (error) {
						char *save = *error;
						spprintf(error, 0, ""phar \""%s\"" SHA512 signature could not be verified: %s"", fname, *error);
						efree(save);
					}
					return FAILURE;
				}
				break;
			}
			case PHAR_SIG_SHA256: {
				unsigned char digest[32];

				php_stream_seek(fp, -(8 + 32), SEEK_END);
				read_len = php_stream_tell(fp);

				if (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {
					efree(savebuf);
					php_stream_close(fp);
					if (error) {
						spprintf(error, 0, ""phar \""%s\"" has a broken signature"", fname);
					}
					return FAILURE;
				}

				if (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA256, (char *)digest, 32, fname, &signature, &sig_len, error TSRMLS_CC)) {
					efree(savebuf);
					php_stream_close(fp);
					if (error) {
						char *save = *error;
						spprintf(error, 0, ""phar \""%s\"" SHA256 signature could not be verified: %s"", fname, *error);
						efree(save);
					}
					return FAILURE;
				}
				break;
			}
#else
			case PHAR_SIG_SHA512:
			case PHAR_SIG_SHA256:
				efree(savebuf);
				php_stream_close(fp);

				if (error) {
					spprintf(error, 0, ""phar \""%s\"" has a unsupported signature"", fname);
				}
				return FAILURE;
#endif
			case PHAR_SIG_SHA1: {
				unsigned char digest[20];

				php_stream_seek(fp, -(8 + 20), SEEK_END);
				read_len = php_stream_tell(fp);

				if (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {
					efree(savebuf);
					php_stream_close(fp);
					if (error) {
						spprintf(error, 0, ""phar \""%s\"" has a broken signature"", fname);
					}
					return FAILURE;
				}

				if (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA1, (char *)digest, 20, fname, &signature, &sig_len, error TSRMLS_CC)) {
					efree(savebuf);
					php_stream_close(fp);
					if (error) {
						char *save = *error;
						spprintf(error, 0, ""phar \""%s\"" SHA1 signature could not be verified: %s"", fname, *error);
						efree(save);
					}
					return FAILURE;
				}
				break;
			}
			case PHAR_SIG_MD5: {
				unsigned char digest[16];

				php_stream_seek(fp, -(8 + 16), SEEK_END);
				read_len = php_stream_tell(fp);

				if (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {
					efree(savebuf);
					php_stream_close(fp);
					if (error) {
						spprintf(error, 0, ""phar \""%s\"" has a broken signature"", fname);
					}
					return FAILURE;
				}

				if (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_MD5, (char *)digest, 16, fname, &signature, &sig_len, error TSRMLS_CC)) {
					efree(savebuf);
					php_stream_close(fp);
					if (error) {
						char *save = *error;
						spprintf(error, 0, ""phar \""%s\"" MD5 signature could not be verified: %s"", fname, *error);
						efree(save);
					}
					return FAILURE;
				}
				break;
			}
			default:
				efree(savebuf);
				php_stream_close(fp);

				if (error) {
					spprintf(error, 0, ""phar \""%s\"" has a broken or unsupported signature"", fname);
				}
				return FAILURE;
		}
	} else if (PHAR_G(require_hash)) {
		efree(savebuf);
		php_stream_close(fp);

		if (error) {
			spprintf(error, 0, ""phar \""%s\"" does not have a signature"", fname);
		}
		return FAILURE;
	} else {
		sig_flags = 0;
		sig_len = 0;
	}

	/* extract alias */
	PHAR_GET_32(buffer, tmp_len);

	if (buffer + tmp_len > endbuffer) {
		MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (buffer overrun)"");
	}

	if (manifest_len < 10 + tmp_len) {
		MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest header)"")
	}

	/* tmp_len = 0 says alias length is 0, which means the alias is not stored in the phar */
	if (tmp_len) {
		/* if the alias is stored we enforce it (implicit overrides explicit) */
		if (alias && alias_len && (alias_len != (int)tmp_len || strncmp(alias, buffer, tmp_len)))
		{
			php_stream_close(fp);

			if (signature) {
				efree(signature);
			}

			if (error) {
				spprintf(error, 0, ""cannot load phar \""%s\"" with implicit alias \""%.*s\"" under different alias \""%s\"""", fname, tmp_len, buffer, alias);
			}

			efree(savebuf);
			return FAILURE;
		}

		alias_len = tmp_len;
		alias = buffer;
		buffer += tmp_len;
		register_alias = 1;
	} else if (!alias_len || !alias) {
		/* if we neither have an explicit nor an implicit alias, we use the filename */
		alias = NULL;
		alias_len = 0;
		register_alias = 0;
	} else if (alias_len) {
		register_alias = 1;
		temp_alias = 1;
	}

	/* we have 5 32-bit items plus 1 byte at least */
	if (manifest_count > ((manifest_len - 10 - tmp_len) / (5 * 4 + 1))) {
		/* prevent serious memory issues */
		MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (too many manifest entries for size of manifest)"")
	}

	mydata = pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));
	mydata->is_persistent = PHAR_G(persist);

	/* check whether we have meta data, zero check works regardless of byte order */
	PHAR_GET_32(buffer, len);
	if (mydata->is_persistent) {
		mydata->metadata_len = len;
		if(!len) {
			/* FIXME: not sure why this is needed but removing it breaks tests */
			PHAR_GET_32(buffer, len);
		}
	}
	if(len > endbuffer - buffer) {
		MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (trying to read past buffer end)"");
	}
	if (phar_parse_metadata(&buffer, &mydata->metadata, len TSRMLS_CC) == FAILURE) {
		MAPPHAR_FAIL(""unable to read phar metadata in .phar file \""%s\"""");
	}
	buffer += len;

	/* set up our manifest */
	zend_hash_init(&mydata->manifest, manifest_count,
		zend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)mydata->is_persistent);
	zend_hash_init(&mydata->mounted_dirs, 5,
		zend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);
	zend_hash_init(&mydata->virtual_dirs, manifest_count * 2,
		zend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);
	mydata->fname = pestrndup(fname, fname_len, mydata->is_persistent);
#ifdef PHP_WIN32
	phar_unixify_path_separators(mydata->fname, fname_len);
#endif
	mydata->fname_len = fname_len;
	offset = halt_offset + manifest_len + 4;
	memset(&entry, 0, sizeof(phar_entry_info));
	entry.phar = mydata;
	entry.fp_type = PHAR_FP;
	entry.is_persistent = mydata->is_persistent;

	for (manifest_index = 0; manifest_index < manifest_count; ++manifest_index) {
		if (buffer + 28 > endbuffer) {
			MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest entry)"")
		}

		PHAR_GET_32(buffer, entry.filename_len);

		if (entry.filename_len == 0) {
			MAPPHAR_FAIL(""zero-length filename encountered in phar \""%s\"""");
		}

		if (entry.is_persistent) {
			entry.manifest_pos = manifest_index;
		}

		if (entry.filename_len > endbuffer - buffer - 24) {
			MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest entry)"");
		}

		if ((manifest_ver & PHAR_API_VER_MASK) >= PHAR_API_MIN_DIR && buffer[entry.filename_len - 1] == '/') {
			entry.is_dir = 1;
		} else {
			entry.is_dir = 0;
		}

		phar_add_virtual_dirs(mydata, buffer, entry.filename_len TSRMLS_CC);
		entry.filename = pestrndup(buffer, entry.filename_len, entry.is_persistent);
		buffer += entry.filename_len;
		PHAR_GET_32(buffer, entry.uncompressed_filesize);
		PHAR_GET_32(buffer, entry.timestamp);

		if (offset == halt_offset + (int)manifest_len + 4) {
			mydata->min_timestamp = entry.timestamp;
			mydata->max_timestamp = entry.timestamp;
		} else {
			if (mydata->min_timestamp > entry.timestamp) {
				mydata->min_timestamp = entry.timestamp;
			} else if (mydata->max_timestamp < entry.timestamp) {
				mydata->max_timestamp = entry.timestamp;
			}
		}

		PHAR_GET_32(buffer, entry.compressed_filesize);
		PHAR_GET_32(buffer, entry.crc32);
		PHAR_GET_32(buffer, entry.flags);

		if (entry.is_dir) {
			entry.filename_len--;
			entry.flags |= PHAR_ENT_PERM_DEF_DIR;
		}

		PHAR_GET_32(buffer, len);
		if (entry.is_persistent) {
			entry.metadata_len = len;
		} else {
			entry.metadata_len = 0;
		}
		if (len > endbuffer - buffer) {
			pefree(entry.filename, entry.is_persistent);
			MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest entry)"");
		}
		if (phar_parse_metadata(&buffer, &entry.metadata, len TSRMLS_CC) == FAILURE) {
			pefree(entry.filename, entry.is_persistent);
			MAPPHAR_FAIL(""unable to read file metadata in .phar file \""%s\"""");
		}
		buffer += len;

		entry.offset = entry.offset_abs = offset;
		offset += entry.compressed_filesize;

		switch (entry.flags & PHAR_ENT_COMPRESSION_MASK) {
			case PHAR_ENT_COMPRESSED_GZ:
				if (!PHAR_G(has_zlib)) {
					if (entry.metadata) {
						if (entry.is_persistent) {
							free(entry.metadata);
						} else {
							zval_ptr_dtor(&entry.metadata);
						}
					}
					pefree(entry.filename, entry.is_persistent);
					MAPPHAR_FAIL(""zlib extension is required for gz compressed .phar file \""%s\"""");
				}
				break;
			case PHAR_ENT_COMPRESSED_BZ2:
				if (!PHAR_G(has_bz2)) {
					if (entry.metadata) {
						if (entry.is_persistent) {
							free(entry.metadata);
						} else {
							zval_ptr_dtor(&entry.metadata);
						}
					}
					pefree(entry.filename, entry.is_persistent);
					MAPPHAR_FAIL(""bz2 extension is required for bzip2 compressed .phar file \""%s\"""");
				}
				break;
			default:
				if (entry.uncompressed_filesize != entry.compressed_filesize) {
					if (entry.metadata) {
						if (entry.is_persistent) {
							free(entry.metadata);
						} else {
							zval_ptr_dtor(&entry.metadata);
						}
					}
					pefree(entry.filename, entry.is_persistent);
					MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (compressed and uncompressed size does not match for uncompressed entry)"");
				}
				break;
		}

		manifest_flags |= (entry.flags & PHAR_ENT_COMPRESSION_MASK);
		/* if signature matched, no need to check CRC32 for each file */
		entry.is_crc_checked = (manifest_flags & PHAR_HDR_SIGNATURE ? 1 : 0);
		phar_set_inode(&entry TSRMLS_CC);
		zend_hash_add(&mydata->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info), NULL);
	}

	snprintf(mydata->version, sizeof(mydata->version), ""%u.%u.%u"", manifest_ver >> 12, (manifest_ver >> 8) & 0xF, (manifest_ver >> 4) & 0xF);
	mydata->internal_file_start = halt_offset + manifest_len + 4;
	mydata->halt_offset = halt_offset;
	mydata->flags = manifest_flags;
	endbuffer = strrchr(mydata->fname, '/');

	if (endbuffer) {
		mydata->ext = memchr(endbuffer, '.', (mydata->fname + fname_len) - endbuffer);
		if (mydata->ext == endbuffer) {
			mydata->ext = memchr(endbuffer + 1, '.', (mydata->fname + fname_len) - endbuffer - 1);
		}
		if (mydata->ext) {
			mydata->ext_len = (mydata->fname + mydata->fname_len) - mydata->ext;
		}
	}

	mydata->alias = alias ?
		pestrndup(alias, alias_len, mydata->is_persistent) :
		pestrndup(mydata->fname, fname_len, mydata->is_persistent);
	mydata->alias_len = alias ? alias_len : fname_len;
	mydata->sig_flags = sig_flags;
	mydata->fp = fp;
	mydata->sig_len = sig_len;
	mydata->signature = signature;
	phar_request_initialize(TSRMLS_C);

	if (register_alias) {
		phar_archive_data **fd_ptr;

		mydata->is_temporary_alias = temp_alias;

		if (!phar_validate_alias(mydata->alias, mydata->alias_len)) {
			signature = NULL;
			fp = NULL;
			MAPPHAR_FAIL(""Cannot open archive \""%s\"", invalid alias"");
		}

		if (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {
			if (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {
				signature = NULL;
				fp = NULL;
				MAPPHAR_FAIL(""Cannot open archive \""%s\"", alias is already in use by existing archive"");
			}
		}

		zend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&mydata, sizeof(phar_archive_data*), NULL);
	} else {
		mydata->is_temporary_alias = 1;
	}

	zend_hash_add(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len, (void*)&mydata, sizeof(phar_archive_data*),  NULL);
	efree(savebuf);

	if (pphar) {
		*pphar = mydata;
	}

	return SUCCESS;
}","static int phar_parse_pharfile(php_stream *VAR_0, char *VAR_1, int VAR_2, char *VAR_3, int VAR_4, long VAR_5, phar_archive_data** VAR_6, php_uint32 VAR_7, char **VAR_8 TSRMLS_DC) /* COMMENT_0 */
{
	char VAR_9[4], *VAR_10, *VAR_11, *VAR_12;
	phar_archive_data *VAR_13 = NULL;
	phar_entry_info VAR_14;
	php_uint32 VAR_15, VAR_16, VAR_17, VAR_18, VAR_19, VAR_20;
	php_uint16 VAR_21;
	php_uint32 VAR_22;
	long VAR_23;
	int VAR_24, VAR_25 = 0, VAR_26 = 0;
	char *VAR_27 = NULL;

	if (VAR_6) {
		*VAR_6 = NULL;
	}

	if (VAR_8) {
		*VAR_8 = NULL;
	}

	/* COMMENT_1 */
	if (-1 == php_stream_seek(VAR_0, VAR_5, VAR_28)) {
		MAPPHAR_ALLOC_FAIL(""cannot seek to __HALT_COMPILER(); location in phar \""%s\"""")
	}

	VAR_10 = VAR_9;

	if (3 != php_stream_read(VAR_0, VAR_10, 3)) {
		MAPPHAR_ALLOC_FAIL(""internal corruption of phar \""%s\"" (truncated manifest at stub end)"")
	}

	if ((*VAR_10 == ' ' || *VAR_10 == '\n') && *(VAR_10 + 1) == '?' && *(VAR_10 + 2) == '>') {
		int VAR_29;
		VAR_5 += 3;
		if (VAR_30 == (VAR_29 = php_stream_getc(VAR_0))) {
			MAPPHAR_ALLOC_FAIL(""internal corruption of phar \""%s\"" (truncated manifest at stub end)"")
		}

		if ((char) VAR_29 == '\r') {
			/* COMMENT_2 */
			if (VAR_30 == (VAR_29 = php_stream_getc(VAR_0)) || (char)VAR_29 != '\n') {
				MAPPHAR_ALLOC_FAIL(""internal corruption of phar \""%s\"" (truncated manifest at stub end)"")
			}
			++VAR_5;
		}

		if ((char) VAR_29 == '\n') {
			++VAR_5;
		}
	}

	/* COMMENT_3 */
	if (-1 == php_stream_seek(VAR_0, VAR_5, VAR_28)) {
		MAPPHAR_ALLOC_FAIL(""cannot seek to __HALT_COMPILER(); location in phar \""%s\"""")
	}

	/* COMMENT_4 */
	VAR_10 = VAR_9;

	if (4 != php_stream_read(VAR_0, VAR_10, 4)) {
		MAPPHAR_ALLOC_FAIL(""internal corruption of phar \""%s\"" (truncated manifest at manifest length)"")
	}

	PHAR_GET_32(VAR_10, VAR_15);

	if (VAR_15 > 1048576 * 100) {
		/* COMMENT_5 */
		MAPPHAR_ALLOC_FAIL(""manifest cannot be larger than 100 MB in phar \""%s\"""")
	}

	VAR_10 = (char *)emalloc(VAR_15);
	VAR_12 = VAR_10;
	VAR_11 = VAR_10 + VAR_15;

	if (VAR_15 < 10 || VAR_15 != php_stream_read(VAR_0, VAR_10, VAR_15)) {
		MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest header)"")
	}

	/* COMMENT_6 */
	PHAR_GET_32(VAR_10, VAR_16);

	if (VAR_16 == 0) {
		MAPPHAR_FAIL(""in phar \""%s\"", manifest claims to have zero entries.  Phars must have at least 1 entry"");
	}

	/* COMMENT_7 */
	VAR_21 = (((unsigned char)VAR_10[0]) << 8)
				 + ((unsigned char)VAR_10[1]);
	VAR_10 += 2;

	if ((VAR_21 & VAR_31) < VAR_32) {
		efree(VAR_12);
		php_stream_close(VAR_0);
		if (VAR_8) {
			spprintf(VAR_8, 0, ""phar \""%s\"" is API version %1.u.%1.u.%1.u, and cannot be processed"", VAR_1, VAR_21 >> 12, (VAR_21 >> 8) & 0xF, (VAR_21 >> 4) & 0x0F);
		}
		return VAR_33;
	}

	PHAR_GET_32(VAR_10, VAR_17);

	VAR_17 &= ~VAR_34;
	VAR_17 &= ~VAR_35;
	/* COMMENT_8 */
	VAR_17 |= VAR_7;

	/* COMMENT_9 */
	/* COMMENT_10 */
	if (VAR_17 & VAR_36) {
		char VAR_37[8], *VAR_38 = VAR_37;
		off_t VAR_39;
		size_t VAR_40;

		if (-1 == php_stream_seek(VAR_0, -8, VAR_41)
		|| (VAR_39 = php_stream_tell(VAR_0)) < 20
		|| 8 != php_stream_read(VAR_0, VAR_37, 8)
		|| memcmp(VAR_37+4, ""GBMB"", 4)) {
			efree(VAR_12);
			php_stream_close(VAR_0);
			if (VAR_8) {
				spprintf(VAR_8, 0, ""phar \""%s\"" has a broken signature"", VAR_1);
			}
			return VAR_33;
		}

		PHAR_GET_32(VAR_38, VAR_20);

		switch(VAR_20) {
			case VAR_42: {
				php_uint32 VAR_43;
				char *VAR_44;
				off_t VAR_45;

				/* COMMENT_11 */
				if (-1 == php_stream_seek(VAR_0, -12, VAR_46)
				|| 4 != php_stream_read(VAR_0, VAR_37, 4)) {
					efree(VAR_12);
					php_stream_close(VAR_0);
					if (VAR_8) {
						spprintf(VAR_8, 0, ""phar \""%s\"" openssl signature length could not be read"", VAR_1);
					}
					return VAR_33;
				}

				VAR_38 = VAR_37;
				PHAR_GET_32(VAR_38, VAR_43);
				VAR_44 = (char *) emalloc(VAR_43);
				VAR_45 = VAR_43 + 4;
				VAR_45 = -VAR_45;

				if (-1 == php_stream_seek(VAR_0, VAR_45, VAR_46)
				|| !(VAR_40 = php_stream_tell(VAR_0))
				|| VAR_43 != php_stream_read(VAR_0, VAR_44, VAR_43)) {
					efree(VAR_12);
					efree(VAR_44);
					php_stream_close(VAR_0);
					if (VAR_8) {
						spprintf(VAR_8, 0, ""phar \""%s\"" openssl signature could not be read"", VAR_1);
					}
					return VAR_33;
				}

				if (VAR_33 == phar_verify_signature(VAR_0, VAR_40, VAR_42, VAR_44, VAR_43, VAR_1, &VAR_27, &VAR_24, VAR_8 VAR_47)) {
					efree(VAR_12);
					efree(VAR_44);
					php_stream_close(VAR_0);
					if (VAR_8) {
						char *VAR_48 = *VAR_8;
						spprintf(VAR_8, 0, ""phar \""%s\"" openssl signature could not be verified: %s"", VAR_1, *VAR_8);
						efree(VAR_48);
					}
					return VAR_33;
				}
				efree(VAR_44);
			}
			break;
#if VAR_49
			case VAR_50: {
				unsigned char VAR_51[64];

				php_stream_seek(VAR_0, -(8 + 64), VAR_41);
				VAR_39 = php_stream_tell(VAR_0);

				if (php_stream_read(VAR_0, (char*)VAR_51, sizeof(VAR_51)) != sizeof(VAR_51)) {
					efree(VAR_12);
					php_stream_close(VAR_0);
					if (VAR_8) {
						spprintf(VAR_8, 0, ""phar \""%s\"" has a broken signature"", VAR_1);
					}
					return VAR_33;
				}

				if (VAR_33 == phar_verify_signature(VAR_0, VAR_39, VAR_50, (char *)VAR_51, 64, VAR_1, &VAR_27, &VAR_24, VAR_8 VAR_47)) {
					efree(VAR_12);
					php_stream_close(VAR_0);
					if (VAR_8) {
						char *VAR_48 = *VAR_8;
						spprintf(VAR_8, 0, ""phar \""%s\"" SHA512 signature could not be verified: %s"", VAR_1, *VAR_8);
						efree(VAR_48);
					}
					return VAR_33;
				}
				break;
			}
			case VAR_52: {
				unsigned char VAR_51[32];

				php_stream_seek(VAR_0, -(8 + 32), VAR_41);
				VAR_39 = php_stream_tell(VAR_0);

				if (php_stream_read(VAR_0, (char*)VAR_51, sizeof(VAR_51)) != sizeof(VAR_51)) {
					efree(VAR_12);
					php_stream_close(VAR_0);
					if (VAR_8) {
						spprintf(VAR_8, 0, ""phar \""%s\"" has a broken signature"", VAR_1);
					}
					return VAR_33;
				}

				if (VAR_33 == phar_verify_signature(VAR_0, VAR_39, VAR_52, (char *)VAR_51, 32, VAR_1, &VAR_27, &VAR_24, VAR_8 VAR_47)) {
					efree(VAR_12);
					php_stream_close(VAR_0);
					if (VAR_8) {
						char *VAR_48 = *VAR_8;
						spprintf(VAR_8, 0, ""phar \""%s\"" SHA256 signature could not be verified: %s"", VAR_1, *VAR_8);
						efree(VAR_48);
					}
					return VAR_33;
				}
				break;
			}
#else
			case VAR_50:
			case VAR_52:
				efree(VAR_12);
				php_stream_close(VAR_0);

				if (VAR_8) {
					spprintf(VAR_8, 0, ""phar \""%s\"" has a unsupported signature"", VAR_1);
				}
				return VAR_33;
#endif
			case VAR_53: {
				unsigned char VAR_51[20];

				php_stream_seek(VAR_0, -(8 + 20), VAR_41);
				VAR_39 = php_stream_tell(VAR_0);

				if (php_stream_read(VAR_0, (char*)VAR_51, sizeof(VAR_51)) != sizeof(VAR_51)) {
					efree(VAR_12);
					php_stream_close(VAR_0);
					if (VAR_8) {
						spprintf(VAR_8, 0, ""phar \""%s\"" has a broken signature"", VAR_1);
					}
					return VAR_33;
				}

				if (VAR_33 == phar_verify_signature(VAR_0, VAR_39, VAR_53, (char *)VAR_51, 20, VAR_1, &VAR_27, &VAR_24, VAR_8 VAR_47)) {
					efree(VAR_12);
					php_stream_close(VAR_0);
					if (VAR_8) {
						char *VAR_48 = *VAR_8;
						spprintf(VAR_8, 0, ""phar \""%s\"" SHA1 signature could not be verified: %s"", VAR_1, *VAR_8);
						efree(VAR_48);
					}
					return VAR_33;
				}
				break;
			}
			case VAR_54: {
				unsigned char VAR_51[16];

				php_stream_seek(VAR_0, -(8 + 16), VAR_41);
				VAR_39 = php_stream_tell(VAR_0);

				if (php_stream_read(VAR_0, (char*)VAR_51, sizeof(VAR_51)) != sizeof(VAR_51)) {
					efree(VAR_12);
					php_stream_close(VAR_0);
					if (VAR_8) {
						spprintf(VAR_8, 0, ""phar \""%s\"" has a broken signature"", VAR_1);
					}
					return VAR_33;
				}

				if (VAR_33 == phar_verify_signature(VAR_0, VAR_39, VAR_54, (char *)VAR_51, 16, VAR_1, &VAR_27, &VAR_24, VAR_8 VAR_47)) {
					efree(VAR_12);
					php_stream_close(VAR_0);
					if (VAR_8) {
						char *VAR_48 = *VAR_8;
						spprintf(VAR_8, 0, ""phar \""%s\"" MD5 signature could not be verified: %s"", VAR_1, *VAR_8);
						efree(VAR_48);
					}
					return VAR_33;
				}
				break;
			}
			default:
				efree(VAR_12);
				php_stream_close(VAR_0);

				if (VAR_8) {
					spprintf(VAR_8, 0, ""phar \""%s\"" has a broken or unsupported signature"", VAR_1);
				}
				return VAR_33;
		}
	} else if (PHAR_G(VAR_55)) {
		efree(VAR_12);
		php_stream_close(VAR_0);

		if (VAR_8) {
			spprintf(VAR_8, 0, ""phar \""%s\"" does not have a signature"", VAR_1);
		}
		return VAR_33;
	} else {
		VAR_20 = 0;
		VAR_24 = 0;
	}

	/* COMMENT_12 */
	PHAR_GET_32(VAR_10, VAR_19);

	if (VAR_10 + VAR_19 > VAR_11) {
		MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (buffer overrun)"");
	}

	if (VAR_15 < 10 + VAR_19) {
		MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest header)"")
	}

	/* COMMENT_13 */
	if (VAR_19) {
		/* COMMENT_14 */
		if (VAR_3 && VAR_4 && (VAR_4 != (int)VAR_19 || strncmp(VAR_3, VAR_10, VAR_19)))
		{
			php_stream_close(VAR_0);

			if (VAR_27) {
				efree(VAR_27);
			}

			if (VAR_8) {
				spprintf(VAR_8, 0, ""cannot load phar \""%s\"" with implicit alias \""%.*s\"" under different alias \""%s\"""", VAR_1, VAR_19, VAR_10, VAR_3);
			}

			efree(VAR_12);
			return VAR_33;
		}

		VAR_4 = VAR_19;
		VAR_3 = VAR_10;
		VAR_10 += VAR_19;
		VAR_25 = 1;
	} else if (!VAR_4 || !VAR_3) {
		/* COMMENT_15 */
		VAR_3 = NULL;
		VAR_4 = 0;
		VAR_25 = 0;
	} else if (VAR_4) {
		VAR_25 = 1;
		VAR_26 = 1;
	}

	/* COMMENT_16 */
	if (VAR_16 > ((VAR_15 - 10 - VAR_19) / (5 * 4 + 1))) {
		/* COMMENT_17 */
		MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (too many manifest entries for size of manifest)"")
	}

	VAR_13 = pecalloc(1, sizeof(phar_archive_data), PHAR_G(VAR_56));
	VAR_13->is_persistent = PHAR_G(VAR_56);

	/* COMMENT_18 */
	PHAR_GET_32(VAR_10, VAR_22);
	if (VAR_13->is_persistent) {
		VAR_13->metadata_len = VAR_22;
		if(!VAR_22) {
			/* COMMENT_19 */
			PHAR_GET_32(VAR_10, VAR_22);
		}
	}
	if(VAR_22 > VAR_11 - VAR_10) {
		MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (trying to read past buffer end)"");
	}
	if (phar_parse_metadata(&VAR_10, &VAR_13->metadata, VAR_22 VAR_47) == VAR_33) {
		MAPPHAR_FAIL(""unable to read phar metadata in .phar file \""%s\"""");
	}
	VAR_10 += VAR_22;

	/* COMMENT_20 */
	zend_hash_init(&VAR_13->manifest, VAR_16,
		VAR_57, VAR_58, (zend_bool)VAR_13->is_persistent);
	zend_hash_init(&VAR_13->mounted_dirs, 5,
		VAR_57, NULL, (zend_bool)VAR_13->is_persistent);
	zend_hash_init(&VAR_13->virtual_dirs, VAR_16 * 2,
		VAR_57, NULL, (zend_bool)VAR_13->is_persistent);
	VAR_13->fname = pestrndup(VAR_1, VAR_2, VAR_13->is_persistent);
#ifdef VAR_59
	phar_unixify_path_separators(VAR_13->fname, VAR_2);
#endif
	VAR_13->fname_len = VAR_2;
	VAR_23 = VAR_5 + VAR_15 + 4;
	memset(&VAR_14, 0, sizeof(phar_entry_info));
	VAR_14.phar = VAR_13;
	VAR_14.fp_type = VAR_60;
	VAR_14.is_persistent = VAR_13->is_persistent;

	for (VAR_18 = 0; VAR_18 < VAR_16; ++VAR_18) {
		if (VAR_10 + 28 > VAR_11) {
			MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest entry)"")
		}

		PHAR_GET_32(VAR_10, VAR_14.filename_len);

		if (VAR_14.filename_len == 0) {
			MAPPHAR_FAIL(""zero-length filename encountered in phar \""%s\"""");
		}

		if (VAR_14.is_persistent) {
			VAR_14.manifest_pos = VAR_18;
		}

		if (VAR_14.filename_len > VAR_11 - VAR_10 - 24) {
			MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest entry)"");
		}

		if ((VAR_21 & VAR_31) >= VAR_61 && VAR_10[VAR_14.filename_len - 1] == '/') {
			VAR_14.is_dir = 1;
		} else {
			VAR_14.is_dir = 0;
		}

		phar_add_virtual_dirs(VAR_13, VAR_10, VAR_14.filename_len VAR_47);
		VAR_14.filename = pestrndup(VAR_10, VAR_14.filename_len, VAR_14.is_persistent);
		VAR_10 += VAR_14.filename_len;
		PHAR_GET_32(VAR_10, VAR_14.uncompressed_filesize);
		PHAR_GET_32(VAR_10, VAR_14.timestamp);

		if (VAR_23 == VAR_5 + (int)VAR_15 + 4) {
			VAR_13->min_timestamp = VAR_14.timestamp;
			VAR_13->max_timestamp = VAR_14.timestamp;
		} else {
			if (VAR_13->min_timestamp > VAR_14.timestamp) {
				VAR_13->min_timestamp = VAR_14.timestamp;
			} else if (VAR_13->max_timestamp < VAR_14.timestamp) {
				VAR_13->max_timestamp = VAR_14.timestamp;
			}
		}

		PHAR_GET_32(VAR_10, VAR_14.compressed_filesize);
		PHAR_GET_32(VAR_10, VAR_14.crc32);
		PHAR_GET_32(VAR_10, VAR_14.flags);

		if (VAR_14.is_dir) {
			VAR_14.filename_len--;
			VAR_14.flags |= VAR_62;
		}

		PHAR_GET_32(VAR_10, VAR_22);
		if (VAR_14.is_persistent) {
			VAR_14.metadata_len = VAR_22;
		} else {
			VAR_14.metadata_len = 0;
		}
		if (VAR_22 > VAR_11 - VAR_10) {
			pefree(VAR_14.filename, VAR_14.is_persistent);
			MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest entry)"");
		}
		if (phar_parse_metadata(&VAR_10, &VAR_14.metadata, VAR_22 VAR_47) == VAR_33) {
			pefree(VAR_14.filename, VAR_14.is_persistent);
			MAPPHAR_FAIL(""unable to read file metadata in .phar file \""%s\"""");
		}
		VAR_10 += VAR_22;

		VAR_14.offset = VAR_14.offset_abs = VAR_23;
		VAR_23 += VAR_14.compressed_filesize;

		switch (VAR_14.flags & VAR_63) {
			case VAR_64:
				if (!PHAR_G(VAR_65)) {
					if (VAR_14.metadata) {
						if (VAR_14.is_persistent) {
							free(VAR_14.metadata);
						} else {
							zval_ptr_dtor(&VAR_14.metadata);
						}
					}
					pefree(VAR_14.filename, VAR_14.is_persistent);
					MAPPHAR_FAIL(""zlib extension is required for gz compressed .phar file \""%s\"""");
				}
				break;
			case VAR_66:
				if (!PHAR_G(VAR_67)) {
					if (VAR_14.metadata) {
						if (VAR_14.is_persistent) {
							free(VAR_14.metadata);
						} else {
							zval_ptr_dtor(&VAR_14.metadata);
						}
					}
					pefree(VAR_14.filename, VAR_14.is_persistent);
					MAPPHAR_FAIL(""bz2 extension is required for bzip2 compressed .phar file \""%s\"""");
				}
				break;
			default:
				if (VAR_14.uncompressed_filesize != VAR_14.compressed_filesize) {
					if (VAR_14.metadata) {
						if (VAR_14.is_persistent) {
							free(VAR_14.metadata);
						} else {
							zval_ptr_dtor(&VAR_14.metadata);
						}
					}
					pefree(VAR_14.filename, VAR_14.is_persistent);
					MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (compressed and uncompressed size does not match for uncompressed entry)"");
				}
				break;
		}

		VAR_17 |= (VAR_14.flags & VAR_63);
		/* COMMENT_21 */
		VAR_14.is_crc_checked = (VAR_17 & VAR_36 ? 1 : 0);
		phar_set_inode(&VAR_14 VAR_47);
		zend_hash_add(&VAR_13->manifest, VAR_14.filename, VAR_14.filename_len, (void*)&VAR_14, sizeof(phar_entry_info), NULL);
	}

	snprintf(VAR_13->version, sizeof(VAR_13->version), ""%u.%u.%u"", VAR_21 >> 12, (VAR_21 >> 8) & 0xF, (VAR_21 >> 4) & 0xF);
	VAR_13->internal_file_start = VAR_5 + VAR_15 + 4;
	VAR_13->halt_offset = VAR_5;
	VAR_13->flags = VAR_17;
	VAR_11 = strrchr(VAR_13->fname, '/');

	if (VAR_11) {
		VAR_13->ext = memchr(VAR_11, '.', (VAR_13->fname + VAR_2) - VAR_11);
		if (VAR_13->ext == VAR_11) {
			VAR_13->ext = memchr(VAR_11 + 1, '.', (VAR_13->fname + VAR_2) - VAR_11 - 1);
		}
		if (VAR_13->ext) {
			VAR_13->ext_len = (VAR_13->fname + VAR_13->fname_len) - VAR_13->ext;
		}
	}

	VAR_13->alias = VAR_3 ?
		pestrndup(VAR_3, VAR_4, VAR_13->is_persistent) :
		pestrndup(VAR_13->fname, VAR_2, VAR_13->is_persistent);
	VAR_13->alias_len = VAR_3 ? VAR_4 : VAR_2;
	VAR_13->sig_flags = VAR_20;
	VAR_13->fp = VAR_0;
	VAR_13->sig_len = VAR_24;
	VAR_13->signature = VAR_27;
	phar_request_initialize(VAR_68);

	if (VAR_25) {
		phar_archive_data **VAR_69;

		VAR_13->is_temporary_alias = VAR_26;

		if (!phar_validate_alias(VAR_13->alias, VAR_13->alias_len)) {
			VAR_27 = NULL;
			VAR_0 = NULL;
			MAPPHAR_FAIL(""Cannot open archive \""%s\"", invalid alias"");
		}

		if (VAR_70 == zend_hash_find(&(VAR_71->phar_alias_map), VAR_3, VAR_4, (void **)&VAR_69)) {
			if (VAR_70 != phar_free_alias(*VAR_69, VAR_3, VAR_4 VAR_47)) {
				VAR_27 = NULL;
				VAR_0 = NULL;
				MAPPHAR_FAIL(""Cannot open archive \""%s\"", alias is already in use by existing archive"");
			}
		}

		zend_hash_add(&(VAR_71->phar_alias_map), VAR_3, VAR_4, (void*)&VAR_13, sizeof(phar_archive_data*), NULL);
	} else {
		VAR_13->is_temporary_alias = 1;
	}

	zend_hash_add(&(VAR_71->phar_fname_map), VAR_13->fname, VAR_2, (void*)&VAR_13, sizeof(phar_archive_data*),  NULL);
	efree(VAR_12);

	if (VAR_6) {
		*VAR_6 = VAR_13;
	}

	return VAR_70;
}",,"--- func_before
+++ func_after
@@ -405,7 +405,7 @@
 	entry.is_persistent = mydata->is_persistent;
 
 	for (manifest_index = 0; manifest_index < manifest_count; ++manifest_index) {
-		if (buffer + 24 > endbuffer) {
+		if (buffer + 28 > endbuffer) {
 			MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest entry)"")
 		}
 
@@ -419,7 +419,7 @@
 			entry.manifest_pos = manifest_index;
 		}
 
-		if (entry.filename_len > endbuffer - buffer - 20) {
+		if (entry.filename_len > endbuffer - buffer - 24) {
 			MAPPHAR_FAIL(""internal corruption of phar \""%s\"" (truncated manifest entry)"");
 		}
 ","{'deleted_lines': ['\t\tif (buffer + 24 > endbuffer) {', '\t\tif (entry.filename_len > endbuffer - buffer - 20) {'], 'added_lines': ['\t\tif (buffer + 28 > endbuffer) {', '\t\tif (entry.filename_len > endbuffer - buffer - 24) {']}",True,"In PHP before 5.6.30 and 7.x before 7.0.15, the PHAR archive handler could be used by attackers supplying malicious archive files to crash the PHP interpreter or potentially disclose information due to a buffer over-read in the phar_parse_pharfile function in ext/phar/phar.c.",9.1,CRITICAL,3,test,2017-01-01T02:47:50Z,1
CVE-2017-5511,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ImageMagick,Fix improper cast that could cause an overflow as demonstrated in #347.,7d65a814ac76bd04760072c33e452371692ee790,https://github.com/ImageMagick/ImageMagick/commit/7d65a814ac76bd04760072c33e452371692ee790,coders/psd.c,ReadPSDLayers,"ModuleExport MagickBooleanType ReadPSDLayers(Image *image,
const ImageInfo *image_info,const PSDInfo *psd_info,
const MagickBooleanType skip_layers,ExceptionInfo *exception)
{
char
type[4];
LayerInfo
*layer_info;
MagickSizeType
size;
MagickBooleanType
status;
register ssize_t
i;
ssize_t
count,
j,
number_layers;
size=GetPSDSize(psd_info,image);
if (size == 0)
{
(void) ReadBlobLong(image);
count=ReadBlob(image,4,(unsigned char *) type);
ReversePSDString(image,type,4);
status=MagickFalse;
if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
return(MagickTrue);
else
{
count=ReadBlob(image,4,(unsigned char *) type);
ReversePSDString(image,type,4);
if ((count != 0) && (LocaleNCompare(type,""Lr16"",4) == 0))
size=GetPSDSize(psd_info,image);
else
return(MagickTrue);
}
}
status=MagickTrue;
if (size != 0)
{
layer_info=(LayerInfo *) NULL;
number_layers=(short) ReadBlobShort(image);
if (number_layers < 0)
{
number_layers=MagickAbsoluteValue(number_layers);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  negative layer count corrected for"");
image->matte=MagickTrue;
}
if (skip_layers != MagickFalse)
return(MagickTrue);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  image contains %.20g layers"",(double) number_layers);
if (number_layers == 0)
ThrowBinaryException(CorruptImageError,""InvalidNumberOfLayers"",
image->filename);
layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,
sizeof(*layer_info));
if (layer_info == (LayerInfo *) NULL)
{
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  allocation of LayerInfo failed"");
ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
image->filename);
}
(void) ResetMagickMemory(layer_info,0,(size_t) number_layers*
sizeof(*layer_info));
for (i=0; i < number_layers; i++)
{
ssize_t
x,
y;
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  reading layer #%.20g"",(double) i+1);
layer_info[i].page.y=ReadBlobSignedLong(image);
layer_info[i].page.x=ReadBlobSignedLong(image);
y=ReadBlobSignedLong(image);
x=ReadBlobSignedLong(image);
layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);
layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);
layer_info[i].channels=ReadBlobShort(image);
if (layer_info[i].channels > MaxPSDChannels)
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,""MaximumChannelsExceeded"",
image->filename);
}
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
(double) layer_info[i].page.x,(double) layer_info[i].page.y,
(double) layer_info[i].page.height,(double)
layer_info[i].page.width,(double) layer_info[i].channels);
for (j=0; j < (ssize_t) layer_info[i].channels; j++)
{
layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);
layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,
image);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""    channel[%.20g]: type=%.20g, size=%.20g"",(double) j,
(double) layer_info[i].channel_info[j].type,
(double) layer_info[i].channel_info[j].size);
}
count=ReadBlob(image,4,(unsigned char *) type);
ReversePSDString(image,type,4);
if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
{
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  layer type was %.4s instead of 8BIM"", type);
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,""ImproperImageHeader"",
image->filename);
}
(void) ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);
ReversePSDString(image,layer_info[i].blendkey,4);
layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)
ReadBlobByte(image));
layer_info[i].clipping=(unsigned char) ReadBlobByte(image);
layer_info[i].flags=(unsigned char) ReadBlobByte(image);
layer_info[i].visible=!(layer_info[i].flags & 0x02);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s"",
layer_info[i].blendkey,(double) layer_info[i].opacity,
layer_info[i].clipping ? ""true"" : ""false"",layer_info[i].flags,
layer_info[i].visible ? ""true"" : ""false"");
(void) ReadBlobByte(image);  
size=ReadBlobLong(image);
if (size != 0)
{
MagickSizeType
combined_length,
length;
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""    layer contains additional info"");
length=ReadBlobLong(image);
combined_length=length+4;
if (length != 0)
{
layer_info[i].mask.page.y=ReadBlobSignedLong(image);
layer_info[i].mask.page.x=ReadBlobSignedLong(image);
layer_info[i].mask.page.height=(size_t) (ReadBlobLong(image)-
layer_info[i].mask.page.y);
layer_info[i].mask.page.width=(size_t) (ReadBlobLong(image)-
layer_info[i].mask.page.x);
layer_info[i].mask.background=(unsigned char) ReadBlobByte(
image);
layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);
if (!(layer_info[i].mask.flags & 0x01))
{
layer_info[i].mask.page.y=layer_info[i].mask.page.y-
layer_info[i].page.y;
layer_info[i].mask.page.x=layer_info[i].mask.page.x-
layer_info[i].page.x;
}
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g"",
(double) layer_info[i].mask.page.x,(double)
layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,
(double) layer_info[i].mask.page.height,(double)
((MagickOffsetType) length)-18);
if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
}
}
length=ReadBlobLong(image);
combined_length+=length+4;
if (length != 0)
{
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""      layer blending ranges: length=%.20g"",(double)
((MagickOffsetType) length));
for (j=0; j < (ssize_t) length; j+=8)
{
size_t blend_source=ReadBlobLong(image);
size_t blend_dest=ReadBlobLong(image);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""        source(%x), dest(%x)"",(unsigned int)
blend_source,(unsigned int) blend_dest);
}
}
length=(MagickSizeType) ReadBlobByte(image);
combined_length+=length+1;
if (length > 0)
(void) ReadBlob(image,(size_t) length++,layer_info[i].name);
layer_info[i].name[length]='\0';
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""      layer name: %s"",layer_info[i].name);
if ((length % 4) != 0)
{
length=4-(length % 4);
combined_length+=length;
if (DiscardBlobBytes(image,length) == MagickFalse)
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,
""UnexpectedEndOfFile"",image->filename);
}
}
length=(MagickSizeType) size-combined_length;
if (length > 0)
{
unsigned char
*info;
layer_info[i].info=AcquireStringInfo((const size_t) length);
info=GetStringInfoDatum(layer_info[i].info);
(void) ReadBlob(image,(const size_t) length,info);
}
}
}
for (i=0; i < number_layers; i++)
{
if ((layer_info[i].page.width == 0) ||
(layer_info[i].page.height == 0))
{
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""      layer data is empty"");
if (layer_info[i].info != (StringInfo *) NULL)
layer_info[i].info=DestroyStringInfo(layer_info[i].info);
continue;
}
layer_info[i].image=CloneImage(image,layer_info[i].page.width,
layer_info[i].page.height,MagickFalse,exception);
if (layer_info[i].image == (Image *) NULL)
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  allocation of image for layer %.20g failed"",(double) i);
ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
image->filename);
}
if (layer_info[i].info != (StringInfo *) NULL)
{
(void) SetImageProfile(layer_info[i].image,""psd:additional-info"",
layer_info[i].info);
layer_info[i].info=DestroyStringInfo(layer_info[i].info);
}
}
if (image_info->ping == MagickFalse)
{
for (i=0; i < number_layers; i++)
{
if (layer_info[i].image == (Image *) NULL)
{
for (j=0; j < layer_info[i].channels; j++)
{
if (DiscardBlobBytes(image,(MagickSizeType)
layer_info[i].channel_info[j].size) == MagickFalse)
{
layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,
""UnexpectedEndOfFile"",image->filename);
}
}
continue;
}
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""  reading data for layer %.20g"",(double) i);
status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],
exception);
if (status == MagickFalse)
break;
status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)
number_layers);
if (status == MagickFalse)
break;
}
}
if (status != MagickFalse)
{
for (i=0; i < number_layers; i++)
{
if (layer_info[i].image == (Image *) NULL)
{
for (j=i; j < number_layers - 1; j++)
layer_info[j] = layer_info[j+1];
number_layers--;
i--;
}
}
if (number_layers > 0)
{
for (i=0; i < number_layers; i++)
{
if (i > 0)
layer_info[i].image->previous=layer_info[i-1].image;
if (i < (number_layers-1))
layer_info[i].image->next=layer_info[i+1].image;
layer_info[i].image->page=layer_info[i].page;
}
image->next=layer_info[0].image;
layer_info[0].image->previous=image;
}
layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);
}
else
layer_info=DestroyLayerInfo(layer_info,number_layers);
}
return(status);
}","ModuleExport VAR_0 ReadPSDLayers(Image *VAR_1,
const ImageInfo *VAR_2,const PSDInfo *VAR_3,
const MagickBooleanType VAR_4,ExceptionInfo *VAR_5)
{
char
VAR_6[4];
LayerInfo
*VAR_7;
MagickSizeType
VAR_8;
MagickBooleanType
VAR_9;
register ssize_t
VAR_10;
ssize_t
VAR_11,
VAR_12,
VAR_13;
VAR_8=GetPSDSize(VAR_3,VAR_1);
if (VAR_8 == 0)
{
(void) ReadBlobLong(VAR_1);
VAR_11=ReadBlob(VAR_1,4,(unsigned char *) VAR_6);
ReversePSDString(VAR_1,VAR_6,4);
VAR_9=VAR_14;
if ((VAR_11 == 0) || (LocaleNCompare(VAR_6,""8BIM"",4) != 0))
return(VAR_15);
else
{
VAR_11=ReadBlob(VAR_1,4,(unsigned char *) VAR_6);
ReversePSDString(VAR_1,VAR_6,4);
if ((VAR_11 != 0) && (LocaleNCompare(VAR_6,""Lr16"",4) == 0))
VAR_8=GetPSDSize(VAR_3,VAR_1);
else
return(VAR_15);
}
}
VAR_9=VAR_15;
if (VAR_8 != 0)
{
VAR_7=(LayerInfo *) NULL;
VAR_13=(short) ReadBlobShort(VAR_1);
if (VAR_13 < 0)
{
VAR_13=MagickAbsoluteValue(VAR_13);
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""  negative layer count corrected for"");
VAR_1->matte=VAR_15;
}
if (VAR_4 != VAR_14)
return(VAR_15);
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""  image contains %.20g layers"",(double) VAR_13);
if (VAR_13 == 0)
ThrowBinaryException(VAR_17,""InvalidNumberOfLayers"",
VAR_1->filename);
VAR_7=(LayerInfo *) AcquireQuantumMemory((size_t) VAR_13,
sizeof(*VAR_7));
if (VAR_7 == (LayerInfo *) NULL)
{
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""  allocation of LayerInfo failed"");
ThrowBinaryException(VAR_18,""MemoryAllocationFailed"",
VAR_1->filename);
}
(void) ResetMagickMemory(VAR_7,0,(size_t) VAR_13*
sizeof(*VAR_7));
for (VAR_10=0; VAR_10 < VAR_13; VAR_10++)
{
ssize_t
VAR_19,
VAR_20;
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""  reading layer #%.20g"",(double) VAR_10+1);
VAR_7[VAR_10].page.y=ReadBlobSignedLong(VAR_1);
VAR_7[VAR_10].page.x=ReadBlobSignedLong(VAR_1);
VAR_20=ReadBlobSignedLong(VAR_1);
VAR_19=ReadBlobSignedLong(VAR_1);
VAR_7[VAR_10].page.width=(size_t) (VAR_19-VAR_7[VAR_10].page.x);
VAR_7[VAR_10].page.height=(size_t) (VAR_20-VAR_7[VAR_10].page.y);
VAR_7[VAR_10].channels=ReadBlobShort(VAR_1);
if (VAR_7[VAR_10].channels > VAR_21)
{
VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
ThrowBinaryException(VAR_17,""MaximumChannelsExceeded"",
VAR_1->filename);
}
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
(double) VAR_7[VAR_10].page.x,(double) VAR_7[VAR_10].page.y,
(double) VAR_7[VAR_10].page.height,(double)
VAR_7[VAR_10].page.width,(double) VAR_7[VAR_10].channels);
for (VAR_12=0; VAR_12 < (ssize_t) VAR_7[VAR_10].channels; VAR_12++)
{
VAR_7[VAR_10].channel_info[VAR_12].type=(short) ReadBlobShort(VAR_1);
VAR_7[VAR_10].channel_info[VAR_12].size=(size_t) GetPSDSize(VAR_3,
VAR_1);
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""    channel[%.20g]: type=%.20g, size=%.20g"",(double) VAR_12,
(double) VAR_7[VAR_10].channel_info[VAR_12].type,
(double) VAR_7[VAR_10].channel_info[VAR_12].size);
}
VAR_11=ReadBlob(VAR_1,4,(unsigned char *) VAR_6);
ReversePSDString(VAR_1,VAR_6,4);
if ((VAR_11 == 0) || (LocaleNCompare(VAR_6,""8BIM"",4) != 0))
{
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""  layer type was %.4s instead of 8BIM"", VAR_6);
VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
ThrowBinaryException(VAR_17,""ImproperImageHeader"",
VAR_1->filename);
}
(void) ReadBlob(VAR_1,4,(unsigned char *) VAR_7[VAR_10].blendkey);
ReversePSDString(VAR_1,VAR_7[VAR_10].blendkey,4);
VAR_7[VAR_10].opacity=(Quantum) ScaleCharToQuantum((unsigned char)
ReadBlobByte(VAR_1));
VAR_7[VAR_10].clipping=(unsigned char) ReadBlobByte(VAR_1);
VAR_7[VAR_10].flags=(unsigned char) ReadBlobByte(VAR_1);
VAR_7[VAR_10].visible=!(VAR_7[VAR_10].flags & 0x02);
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s"",
VAR_7[VAR_10].blendkey,(double) VAR_7[VAR_10].opacity,
VAR_7[VAR_10].clipping ? ""true"" : ""false"",VAR_7[VAR_10].flags,
VAR_7[VAR_10].visible ? ""true"" : ""false"");
(void) ReadBlobByte(VAR_1);  
VAR_8=ReadBlobLong(VAR_1);
if (VAR_8 != 0)
{
MagickSizeType
VAR_22,
VAR_23;
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""    layer contains additional info"");
VAR_23=ReadBlobLong(VAR_1);
VAR_22=VAR_23+4;
if (VAR_23 != 0)
{
VAR_7[VAR_10].mask.page.y=ReadBlobSignedLong(VAR_1);
VAR_7[VAR_10].mask.page.x=ReadBlobSignedLong(VAR_1);
VAR_7[VAR_10].mask.page.height=(size_t) (ReadBlobLong(VAR_1)-
VAR_7[VAR_10].mask.page.y);
VAR_7[VAR_10].mask.page.width=(size_t) (ReadBlobLong(VAR_1)-
VAR_7[VAR_10].mask.page.x);
VAR_7[VAR_10].mask.background=(unsigned char) ReadBlobByte(
VAR_1);
VAR_7[VAR_10].mask.flags=(unsigned char) ReadBlobByte(VAR_1);
if (!(VAR_7[VAR_10].mask.flags & 0x01))
{
VAR_7[VAR_10].mask.page.y=VAR_7[VAR_10].mask.page.y-
VAR_7[VAR_10].page.y;
VAR_7[VAR_10].mask.page.x=VAR_7[VAR_10].mask.page.x-
VAR_7[VAR_10].page.x;
}
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g"",
(double) VAR_7[VAR_10].mask.page.x,(double)
VAR_7[VAR_10].mask.page.y,(double) VAR_7[VAR_10].mask.page.width,
(double) VAR_7[VAR_10].mask.page.height,(double)
((MagickOffsetType) VAR_23)-18);
if (DiscardBlobBytes(VAR_1,(MagickSizeType) (VAR_23-18)) == VAR_14)
{
VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
ThrowBinaryException(VAR_17,""UnexpectedEndOfFile"",
VAR_1->filename);
}
}
VAR_23=ReadBlobLong(VAR_1);
VAR_22+=VAR_23+4;
if (VAR_23 != 0)
{
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""      layer blending ranges: length=%.20g"",(double)
((MagickOffsetType) VAR_23));
for (VAR_12=0; VAR_12 < (ssize_t) VAR_23; VAR_12+=8)
{
size_t VAR_24=ReadBlobLong(VAR_1);
size_t VAR_25=ReadBlobLong(VAR_1);
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""        source(%x), dest(%x)"",(unsigned int)
VAR_24,(unsigned int) VAR_25);
}
}
VAR_23=(MagickSizeType) ReadBlobByte(VAR_1);
VAR_22+=VAR_23+1;
if (VAR_23 > 0)
(void) ReadBlob(VAR_1,(size_t) VAR_23++,VAR_7[VAR_10].name);
VAR_7[VAR_10].name[VAR_23]='\0';
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""      layer name: %s"",VAR_7[VAR_10].name);
if ((VAR_23 % 4) != 0)
{
VAR_23=4-(VAR_23 % 4);
VAR_22+=VAR_23;
if (DiscardBlobBytes(VAR_1,VAR_23) == VAR_14)
{
VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
ThrowBinaryException(VAR_17,
""UnexpectedEndOfFile"",VAR_1->filename);
}
}
VAR_23=(MagickSizeType) VAR_8-VAR_22;
if (VAR_23 > 0)
{
unsigned char
*VAR_26;
VAR_7[VAR_10].info=AcquireStringInfo((const size_t) VAR_23);
VAR_26=GetStringInfoDatum(VAR_7[VAR_10].info);
(void) ReadBlob(VAR_1,(const size_t) VAR_23,VAR_26);
}
}
}
for (VAR_10=0; VAR_10 < VAR_13; VAR_10++)
{
if ((VAR_7[VAR_10].page.width == 0) ||
(VAR_7[VAR_10].page.height == 0))
{
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""      layer data is empty"");
if (VAR_7[VAR_10].info != (StringInfo *) NULL)
VAR_7[VAR_10].info=DestroyStringInfo(VAR_7[VAR_10].info);
continue;
}
VAR_7[VAR_10].image=CloneImage(VAR_1,VAR_7[VAR_10].page.width,
VAR_7[VAR_10].page.height,VAR_14,VAR_5);
if (VAR_7[VAR_10].image == (Image *) NULL)
{
VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""  allocation of image for layer %.20g failed"",(double) VAR_10);
ThrowBinaryException(VAR_18,""MemoryAllocationFailed"",
VAR_1->filename);
}
if (VAR_7[VAR_10].info != (StringInfo *) NULL)
{
(void) SetImageProfile(VAR_7[VAR_10].image,""psd:additional-info"",
VAR_7[VAR_10].info);
VAR_7[VAR_10].info=DestroyStringInfo(VAR_7[VAR_10].info);
}
}
if (VAR_2->ping == VAR_14)
{
for (VAR_10=0; VAR_10 < VAR_13; VAR_10++)
{
if (VAR_7[VAR_10].image == (Image *) NULL)
{
for (VAR_12=0; VAR_12 < VAR_7[VAR_10].channels; VAR_12++)
{
if (DiscardBlobBytes(VAR_1,(MagickSizeType)
VAR_7[VAR_10].channel_info[VAR_12].size) == VAR_14)
{
VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
ThrowBinaryException(VAR_17,
""UnexpectedEndOfFile"",VAR_1->filename);
}
}
continue;
}
if (VAR_1->debug != VAR_14)
(void) LogMagickEvent(VAR_16,GetMagickModule(),
""  reading data for layer %.20g"",(double) VAR_10);
VAR_9=ReadPSDLayer(VAR_1,VAR_2,VAR_3,&VAR_7[VAR_10],
VAR_5);
if (VAR_9 == VAR_14)
break;
VAR_9=SetImageProgress(VAR_1,VAR_27,VAR_10,(MagickSizeType)
VAR_13);
if (VAR_9 == VAR_14)
break;
}
}
if (VAR_9 != VAR_14)
{
for (VAR_10=0; VAR_10 < VAR_13; VAR_10++)
{
if (VAR_7[VAR_10].image == (Image *) NULL)
{
for (VAR_12=VAR_10; VAR_12 < VAR_13 - 1; VAR_12++)
VAR_7[VAR_12] = VAR_7[VAR_12+1];
VAR_13--;
VAR_10--;
}
}
if (VAR_13 > 0)
{
for (VAR_10=0; VAR_10 < VAR_13; VAR_10++)
{
if (VAR_10 > 0)
VAR_7[VAR_10].image->previous=VAR_7[VAR_10-1].image;
if (VAR_10 < (VAR_13-1))
VAR_7[VAR_10].image->next=VAR_7[VAR_10+1].image;
VAR_7[VAR_10].image->page=VAR_7[VAR_10].page;
}
VAR_1->next=VAR_7[0].image;
VAR_7[0].image->previous=VAR_1;
}
VAR_7=(LayerInfo *) RelinquishMagickMemory(VAR_7);
}
else
VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
}
return(VAR_9);
}",,"ModuleExport MagickBooleanType ReadPSDLayers(Image *image,
  const ImageInfo *image_info,const PSDInfo *psd_info,
  const MagickBooleanType skip_layers,ExceptionInfo *exception)
{
  char
    type[4];

  LayerInfo
    *layer_info;

  MagickSizeType
    size;

  MagickBooleanType
    status;

  register ssize_t
    i;

  ssize_t
    count,
    j,
    number_layers;

  size=GetPSDSize(psd_info,image);
  if (size == 0)
    {
      /*
        Skip layers & masks.
      */
      (void) ReadBlobLong(image);
      count=ReadBlob(image,4,(unsigned char *) type);
      ReversePSDString(image,type,4);
      status=MagickFalse;
      if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
        return(MagickTrue);
      else
        {
          count=ReadBlob(image,4,(unsigned char *) type);
          ReversePSDString(image,type,4);
          if ((count != 0) && (LocaleNCompare(type,""Lr16"",4) == 0))
            size=GetPSDSize(psd_info,image);
          else
            return(MagickTrue);
        }
    }
  status=MagickTrue;
  if (size != 0)
    {
      layer_info=(LayerInfo *) NULL;
      number_layers=(short) ReadBlobShort(image);

      if (number_layers < 0)
        {
          /*
            The first alpha channel in the merged result contains the
            transparency data for the merged result.
          */
          number_layers=MagickAbsoluteValue(number_layers);
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  negative layer count corrected for"");
          image->matte=MagickTrue;
        }

      /*
        We only need to know if the image has an alpha channel
      */
      if (skip_layers != MagickFalse)
        return(MagickTrue);

      if (image->debug != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  image contains %.20g layers"",(double) number_layers);

      if (number_layers == 0)
        ThrowBinaryException(CorruptImageError,""InvalidNumberOfLayers"",
          image->filename);

      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,
        sizeof(*layer_info));
      if (layer_info == (LayerInfo *) NULL)
        {
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  allocation of LayerInfo failed"");
          ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
            image->filename);
        }
      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*
        sizeof(*layer_info));

      for (i=0; i < number_layers; i++)
      {
        ssize_t
          x,
          y;

        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  reading layer #%.20g"",(double) i+1);
        layer_info[i].page.y=ReadBlobSignedLong(image);
        layer_info[i].page.x=ReadBlobSignedLong(image);
        y=ReadBlobSignedLong(image);
        x=ReadBlobSignedLong(image);
        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);
        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);
        layer_info[i].channels=ReadBlobShort(image);
        if (layer_info[i].channels > MaxPSDChannels)
          {
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            ThrowBinaryException(CorruptImageError,""MaximumChannelsExceeded"",
              image->filename);
          }
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
            (double) layer_info[i].page.x,(double) layer_info[i].page.y,
            (double) layer_info[i].page.height,(double)
            layer_info[i].page.width,(double) layer_info[i].channels);
        for (j=0; j < (ssize_t) layer_info[i].channels; j++)
        {
          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);
          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,
            image);
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    channel[%.20g]: type=%.20g, size=%.20g"",(double) j,
              (double) layer_info[i].channel_info[j].type,
              (double) layer_info[i].channel_info[j].size);
        }
        count=ReadBlob(image,4,(unsigned char *) type);
        ReversePSDString(image,type,4);
        if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
          {
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  layer type was %.4s instead of 8BIM"", type);
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            ThrowBinaryException(CorruptImageError,""ImproperImageHeader"",
              image->filename);
          }
        (void) ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);
        ReversePSDString(image,layer_info[i].blendkey,4);
        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)
          ReadBlobByte(image));
        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);
        layer_info[i].flags=(unsigned char) ReadBlobByte(image);
        layer_info[i].visible=!(layer_info[i].flags & 0x02);
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s"",
            layer_info[i].blendkey,(double) layer_info[i].opacity,
            layer_info[i].clipping ? ""true"" : ""false"",layer_info[i].flags,
            layer_info[i].visible ? ""true"" : ""false"");
        (void) ReadBlobByte(image);  /* filler */

        size=ReadBlobLong(image);
        if (size != 0)
          {
            MagickSizeType
              combined_length,
              length;

            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""    layer contains additional info"");
            length=ReadBlobLong(image);
            combined_length=length+4;
            if (length != 0)
              {
                /*
                  Layer mask info.
                */
                layer_info[i].mask.page.y=ReadBlobSignedLong(image);
                layer_info[i].mask.page.x=ReadBlobSignedLong(image);
                layer_info[i].mask.page.height=(size_t) (ReadBlobLong(image)-
                  layer_info[i].mask.page.y);
                layer_info[i].mask.page.width=(size_t) (ReadBlobLong(image)-
                  layer_info[i].mask.page.x);
                layer_info[i].mask.background=(unsigned char) ReadBlobByte(
                  image);
                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);
                if (!(layer_info[i].mask.flags & 0x01))
                  {
                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-
                      layer_info[i].page.y;
                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-
                      layer_info[i].page.x;
                  }
                if (image->debug != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g"",
                    (double) layer_info[i].mask.page.x,(double)
                    layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,
                    (double) layer_info[i].mask.page.height,(double)
                    ((MagickOffsetType) length)-18);
                /*
                  Skip over the rest of the layer mask information.
                */
                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)
                  {
                    layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,""UnexpectedEndOfFile"",
                      image->filename);
                  }
              }
            length=ReadBlobLong(image);
            combined_length+=length+4;
            if (length != 0)
              {
                /*
                  Layer blending ranges info.
                */
                if (image->debug != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      layer blending ranges: length=%.20g"",(double)
                    ((MagickOffsetType) length));
                /*
                  We read it, but don't use it...
                */
                for (j=0; j < (ssize_t) length; j+=8)
                {
                  size_t blend_source=ReadBlobLong(image);
                  size_t blend_dest=ReadBlobLong(image);
                  if (image->debug != MagickFalse)
                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                      ""        source(%x), dest(%x)"",(unsigned int)
                      blend_source,(unsigned int) blend_dest);
                }
              }
            /*
              Layer name.
            */
            length=(MagickSizeType) (unsigned char) ReadBlobByte(image);
            combined_length+=length+1;
            if (length > 0)
              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);
            layer_info[i].name[length]='\0';
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""      layer name: %s"",layer_info[i].name);
            if ((length % 4) != 0)
              {
                length=4-(length % 4);
                combined_length+=length;
                /* Skip over the padding of the layer name */
                if (DiscardBlobBytes(image,length) == MagickFalse)
                  {
                    layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,
                      ""UnexpectedEndOfFile"",image->filename);
                  }
              }
            length=(MagickSizeType) size-combined_length;
            if (length > 0)
              {
                unsigned char
                  *info;

                layer_info[i].info=AcquireStringInfo((const size_t) length);
                info=GetStringInfoDatum(layer_info[i].info);
                (void) ReadBlob(image,(const size_t) length,info);
              }
          }
      }

      for (i=0; i < number_layers; i++)
      {
        if ((layer_info[i].page.width == 0) ||
              (layer_info[i].page.height == 0))
          {
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""      layer data is empty"");
            if (layer_info[i].info != (StringInfo *) NULL)
              layer_info[i].info=DestroyStringInfo(layer_info[i].info);
            continue;
          }

        /*
          Allocate layered image.
        */
        layer_info[i].image=CloneImage(image,layer_info[i].page.width,
          layer_info[i].page.height,MagickFalse,exception);
        if (layer_info[i].image == (Image *) NULL)
          {
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  allocation of image for layer %.20g failed"",(double) i);
            ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
              image->filename);
          }

        if (layer_info[i].info != (StringInfo *) NULL)
          {
            (void) SetImageProfile(layer_info[i].image,""psd:additional-info"",
              layer_info[i].info);
            layer_info[i].info=DestroyStringInfo(layer_info[i].info);
          }
      }

      if (image_info->ping == MagickFalse)
        {
          for (i=0; i < number_layers; i++)
          {
            if (layer_info[i].image == (Image *) NULL)
              {
                for (j=0; j < layer_info[i].channels; j++)
                {
                  if (DiscardBlobBytes(image,(MagickSizeType)
                      layer_info[i].channel_info[j].size) == MagickFalse)
                    {
                      layer_info=DestroyLayerInfo(layer_info,number_layers);
                      ThrowBinaryException(CorruptImageError,
                        ""UnexpectedEndOfFile"",image->filename);
                    }
                }
                continue;
              }

            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  reading data for layer %.20g"",(double) i);
            status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],
              exception);
            if (status == MagickFalse)
              break;

            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)
              number_layers);
            if (status == MagickFalse)
              break;
          }
        }

      if (status != MagickFalse)
        {
          for (i=0; i < number_layers; i++)
          {
            if (layer_info[i].image == (Image *) NULL)
              {
                for (j=i; j < number_layers - 1; j++)
                  layer_info[j] = layer_info[j+1];
                number_layers--;
                i--;
              }
          }

          if (number_layers > 0)
            {
              for (i=0; i < number_layers; i++)
              {
                if (i > 0)
                  layer_info[i].image->previous=layer_info[i-1].image;
                if (i < (number_layers-1))
                  layer_info[i].image->next=layer_info[i+1].image;
                layer_info[i].image->page=layer_info[i].page;
              }
              image->next=layer_info[0].image;
              layer_info[0].image->previous=image;
            }
          layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);
        }
      else
        layer_info=DestroyLayerInfo(layer_info,number_layers);
    }

  return(status);
}","ModuleExport VAR_0 ReadPSDLayers(Image *VAR_1,
  const ImageInfo *VAR_2,const PSDInfo *VAR_3,
  const MagickBooleanType VAR_4,ExceptionInfo *VAR_5)
{
  char
    VAR_6[4];

  LayerInfo
    *VAR_7;

  MagickSizeType
    VAR_8;

  MagickBooleanType
    VAR_9;

  register ssize_t
    VAR_10;

  ssize_t
    VAR_11,
    VAR_12,
    VAR_13;

  VAR_8=GetPSDSize(VAR_3,VAR_1);
  if (VAR_8 == 0)
    {
      /* COMMENT_0 */
                            
        
      (void) ReadBlobLong(VAR_1);
      VAR_11=ReadBlob(VAR_1,4,(unsigned char *) VAR_6);
      ReversePSDString(VAR_1,VAR_6,4);
      VAR_9=VAR_14;
      if ((VAR_11 == 0) || (LocaleNCompare(VAR_6,""8BIM"",4) != 0))
        return(VAR_15);
      else
        {
          VAR_11=ReadBlob(VAR_1,4,(unsigned char *) VAR_6);
          ReversePSDString(VAR_1,VAR_6,4);
          if ((VAR_11 != 0) && (LocaleNCompare(VAR_6,""Lr16"",4) == 0))
            VAR_8=GetPSDSize(VAR_3,VAR_1);
          else
            return(VAR_15);
        }
    }
  VAR_9=VAR_15;
  if (VAR_8 != 0)
    {
      VAR_7=(LayerInfo *) NULL;
      VAR_13=(short) ReadBlobShort(VAR_1);

      if (VAR_13 < 0)
        {
          /* COMMENT_3 */
                                                                     
                                                    
            
          VAR_13=MagickAbsoluteValue(VAR_13);
          if (VAR_1->debug != VAR_14)
            (void) LogMagickEvent(VAR_16,GetMagickModule(),
              ""  negative layer count corrected for"");
          VAR_1->matte=VAR_15;
        }

      /* COMMENT_7 */
                                                              
        
      if (VAR_4 != VAR_14)
        return(VAR_15);

      if (VAR_1->debug != VAR_14)
        (void) LogMagickEvent(VAR_16,GetMagickModule(),
          ""  image contains %.20g layers"",(double) VAR_13);

      if (VAR_13 == 0)
        ThrowBinaryException(VAR_17,""InvalidNumberOfLayers"",
          VAR_1->filename);

      VAR_7=(LayerInfo *) AcquireQuantumMemory((size_t) VAR_13,
        sizeof(*VAR_7));
      if (VAR_7 == (LayerInfo *) NULL)
        {
          if (VAR_1->debug != VAR_14)
            (void) LogMagickEvent(VAR_16,GetMagickModule(),
              ""  allocation of LayerInfo failed"");
          ThrowBinaryException(VAR_18,""MemoryAllocationFailed"",
            VAR_1->filename);
        }
      (void) ResetMagickMemory(VAR_7,0,(size_t) VAR_13*
        sizeof(*VAR_7));

      for (VAR_10=0; VAR_10 < VAR_13; VAR_10++)
      {
        ssize_t
          VAR_19,
          VAR_20;

        if (VAR_1->debug != VAR_14)
          (void) LogMagickEvent(VAR_16,GetMagickModule(),
            ""  reading layer #%.20g"",(double) VAR_10+1);
        VAR_7[VAR_10].page.y=ReadBlobSignedLong(VAR_1);
        VAR_7[VAR_10].page.x=ReadBlobSignedLong(VAR_1);
        VAR_20=ReadBlobSignedLong(VAR_1);
        VAR_19=ReadBlobSignedLong(VAR_1);
        VAR_7[VAR_10].page.width=(size_t) (VAR_19-VAR_7[VAR_10].page.x);
        VAR_7[VAR_10].page.height=(size_t) (VAR_20-VAR_7[VAR_10].page.y);
        VAR_7[VAR_10].channels=ReadBlobShort(VAR_1);
        if (VAR_7[VAR_10].channels > VAR_21)
          {
            VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
            ThrowBinaryException(VAR_17,""MaximumChannelsExceeded"",
              VAR_1->filename);
          }
        if (VAR_1->debug != VAR_14)
          (void) LogMagickEvent(VAR_16,GetMagickModule(),
            ""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
            (double) VAR_7[VAR_10].page.x,(double) VAR_7[VAR_10].page.y,
            (double) VAR_7[VAR_10].page.height,(double)
            VAR_7[VAR_10].page.width,(double) VAR_7[VAR_10].channels);
        for (VAR_12=0; VAR_12 < (ssize_t) VAR_7[VAR_10].channels; VAR_12++)
        {
          VAR_7[VAR_10].channel_info[VAR_12].type=(short) ReadBlobShort(VAR_1);
          VAR_7[VAR_10].channel_info[VAR_12].size=(size_t) GetPSDSize(VAR_3,
            VAR_1);
          if (VAR_1->debug != VAR_14)
            (void) LogMagickEvent(VAR_16,GetMagickModule(),
              ""    channel[%.20g]: type=%.20g, size=%.20g"",(double) VAR_12,
              (double) VAR_7[VAR_10].channel_info[VAR_12].type,
              (double) VAR_7[VAR_10].channel_info[VAR_12].size);
        }
        VAR_11=ReadBlob(VAR_1,4,(unsigned char *) VAR_6);
        ReversePSDString(VAR_1,VAR_6,4);
        if ((VAR_11 == 0) || (LocaleNCompare(VAR_6,""8BIM"",4) != 0))
          {
            if (VAR_1->debug != VAR_14)
              (void) LogMagickEvent(VAR_16,GetMagickModule(),
                ""  layer type was %.4s instead of 8BIM"", VAR_6);
            VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
            ThrowBinaryException(VAR_17,""ImproperImageHeader"",
              VAR_1->filename);
          }
        (void) ReadBlob(VAR_1,4,(unsigned char *) VAR_7[VAR_10].blendkey);
        ReversePSDString(VAR_1,VAR_7[VAR_10].blendkey,4);
        VAR_7[VAR_10].opacity=(Quantum) ScaleCharToQuantum((unsigned char)
          ReadBlobByte(VAR_1));
        VAR_7[VAR_10].clipping=(unsigned char) ReadBlobByte(VAR_1);
        VAR_7[VAR_10].flags=(unsigned char) ReadBlobByte(VAR_1);
        VAR_7[VAR_10].visible=!(VAR_7[VAR_10].flags & 0x02);
        if (VAR_1->debug != VAR_14)
          (void) LogMagickEvent(VAR_16,GetMagickModule(),
            ""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s"",
            VAR_7[VAR_10].blendkey,(double) VAR_7[VAR_10].opacity,
            VAR_7[VAR_10].clipping ? ""true"" : ""false"",VAR_7[VAR_10].flags,
            VAR_7[VAR_10].visible ? ""true"" : ""false"");
        (void) ReadBlobByte(VAR_1);  /* COMMENT_10 */

        VAR_8=ReadBlobLong(VAR_1);
        if (VAR_8 != 0)
          {
            MagickSizeType
              VAR_22,
              VAR_23;

            if (VAR_1->debug != VAR_14)
              (void) LogMagickEvent(VAR_16,GetMagickModule(),
                ""    layer contains additional info"");
            VAR_23=ReadBlobLong(VAR_1);
            VAR_22=VAR_23+4;
            if (VAR_23 != 0)
              {
                /* COMMENT_11 */
                                  
                  
                VAR_7[VAR_10].mask.page.y=ReadBlobSignedLong(VAR_1);
                VAR_7[VAR_10].mask.page.x=ReadBlobSignedLong(VAR_1);
                VAR_7[VAR_10].mask.page.height=(size_t) (ReadBlobLong(VAR_1)-
                  VAR_7[VAR_10].mask.page.y);
                VAR_7[VAR_10].mask.page.width=(size_t) (ReadBlobLong(VAR_1)-
                  VAR_7[VAR_10].mask.page.x);
                VAR_7[VAR_10].mask.background=(unsigned char) ReadBlobByte(
                  VAR_1);
                VAR_7[VAR_10].mask.flags=(unsigned char) ReadBlobByte(VAR_1);
                if (!(VAR_7[VAR_10].mask.flags & 0x01))
                  {
                    VAR_7[VAR_10].mask.page.y=VAR_7[VAR_10].mask.page.y-
                      VAR_7[VAR_10].page.y;
                    VAR_7[VAR_10].mask.page.x=VAR_7[VAR_10].mask.page.x-
                      VAR_7[VAR_10].page.x;
                  }
                if (VAR_1->debug != VAR_14)
                  (void) LogMagickEvent(VAR_16,GetMagickModule(),
                    ""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g"",
                    (double) VAR_7[VAR_10].mask.page.x,(double)
                    VAR_7[VAR_10].mask.page.y,(double) VAR_7[VAR_10].mask.page.width,
                    (double) VAR_7[VAR_10].mask.page.height,(double)
                    ((MagickOffsetType) VAR_23)-18);
                /* COMMENT_14 */
                                                                   
                  
                if (DiscardBlobBytes(VAR_1,(MagickSizeType) (VAR_23-18)) == VAR_14)
                  {
                    VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
                    ThrowBinaryException(VAR_17,""UnexpectedEndOfFile"",
                      VAR_1->filename);
                  }
              }
            VAR_23=ReadBlobLong(VAR_1);
            VAR_22+=VAR_23+4;
            if (VAR_23 != 0)
              {
                /* COMMENT_17 */
                                             
                  
                if (VAR_1->debug != VAR_14)
                  (void) LogMagickEvent(VAR_16,GetMagickModule(),
                    ""      layer blending ranges: length=%.20g"",(double)
                    ((MagickOffsetType) VAR_23));
                /* COMMENT_20 */
                                                 
                  
                for (VAR_12=0; VAR_12 < (ssize_t) VAR_23; VAR_12+=8)
                {
                  size_t VAR_24=ReadBlobLong(VAR_1);
                  size_t VAR_25=ReadBlobLong(VAR_1);
                  if (VAR_1->debug != VAR_14)
                    (void) LogMagickEvent(VAR_16,GetMagickModule(),
                      ""        source(%x), dest(%x)"",(unsigned int)
                      VAR_24,(unsigned int) VAR_25);
                }
              }
            /* COMMENT_23 */
                         
              
            VAR_23=(MagickSizeType) (unsigned char) ReadBlobByte(VAR_1);
            VAR_22+=VAR_23+1;
            if (VAR_23 > 0)
              (void) ReadBlob(VAR_1,(size_t) VAR_23++,VAR_7[VAR_10].name);
            VAR_7[VAR_10].name[VAR_23]='\0';
            if (VAR_1->debug != VAR_14)
              (void) LogMagickEvent(VAR_16,GetMagickModule(),
                ""      layer name: %s"",VAR_7[VAR_10].name);
            if ((VAR_23 % 4) != 0)
              {
                VAR_23=4-(VAR_23 % 4);
                VAR_22+=VAR_23;
                /* COMMENT_26 */
                if (DiscardBlobBytes(VAR_1,VAR_23) == VAR_14)
                  {
                    VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
                    ThrowBinaryException(VAR_17,
                      ""UnexpectedEndOfFile"",VAR_1->filename);
                  }
              }
            VAR_23=(MagickSizeType) VAR_8-VAR_22;
            if (VAR_23 > 0)
              {
                unsigned char
                  *VAR_26;

                VAR_7[VAR_10].info=AcquireStringInfo((const size_t) VAR_23);
                VAR_26=GetStringInfoDatum(VAR_7[VAR_10].info);
                (void) ReadBlob(VAR_1,(const size_t) VAR_23,VAR_26);
              }
          }
      }

      for (VAR_10=0; VAR_10 < VAR_13; VAR_10++)
      {
        if ((VAR_7[VAR_10].page.width == 0) ||
              (VAR_7[VAR_10].page.height == 0))
          {
            if (VAR_1->debug != VAR_14)
              (void) LogMagickEvent(VAR_16,GetMagickModule(),
                ""      layer data is empty"");
            if (VAR_7[VAR_10].info != (StringInfo *) NULL)
              VAR_7[VAR_10].info=DestroyStringInfo(VAR_7[VAR_10].info);
            continue;
          }

        /* COMMENT_27 */
                                 
          
        VAR_7[VAR_10].image=CloneImage(VAR_1,VAR_7[VAR_10].page.width,
          VAR_7[VAR_10].page.height,VAR_14,VAR_5);
        if (VAR_7[VAR_10].image == (Image *) NULL)
          {
            VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
            if (VAR_1->debug != VAR_14)
              (void) LogMagickEvent(VAR_16,GetMagickModule(),
                ""  allocation of image for layer %.20g failed"",(double) VAR_10);
            ThrowBinaryException(VAR_18,""MemoryAllocationFailed"",
              VAR_1->filename);
          }

        if (VAR_7[VAR_10].info != (StringInfo *) NULL)
          {
            (void) SetImageProfile(VAR_7[VAR_10].image,""psd:additional-info"",
              VAR_7[VAR_10].info);
            VAR_7[VAR_10].info=DestroyStringInfo(VAR_7[VAR_10].info);
          }
      }

      if (VAR_2->ping == VAR_14)
        {
          for (VAR_10=0; VAR_10 < VAR_13; VAR_10++)
          {
            if (VAR_7[VAR_10].image == (Image *) NULL)
              {
                for (VAR_12=0; VAR_12 < VAR_7[VAR_10].channels; VAR_12++)
                {
                  if (DiscardBlobBytes(VAR_1,(MagickSizeType)
                      VAR_7[VAR_10].channel_info[VAR_12].size) == VAR_14)
                    {
                      VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
                      ThrowBinaryException(VAR_17,
                        ""UnexpectedEndOfFile"",VAR_1->filename);
                    }
                }
                continue;
              }

            if (VAR_1->debug != VAR_14)
              (void) LogMagickEvent(VAR_16,GetMagickModule(),
                ""  reading data for layer %.20g"",(double) VAR_10);
            VAR_9=ReadPSDLayer(VAR_1,VAR_2,VAR_3,&VAR_7[VAR_10],
              VAR_5);
            if (VAR_9 == VAR_14)
              break;

            VAR_9=SetImageProgress(VAR_1,VAR_27,VAR_10,(MagickSizeType)
              VAR_13);
            if (VAR_9 == VAR_14)
              break;
          }
        }

      if (VAR_9 != VAR_14)
        {
          for (VAR_10=0; VAR_10 < VAR_13; VAR_10++)
          {
            if (VAR_7[VAR_10].image == (Image *) NULL)
              {
                for (VAR_12=VAR_10; VAR_12 < VAR_13 - 1; VAR_12++)
                  VAR_7[VAR_12] = VAR_7[VAR_12+1];
                VAR_13--;
                VAR_10--;
              }
          }

          if (VAR_13 > 0)
            {
              for (VAR_10=0; VAR_10 < VAR_13; VAR_10++)
              {
                if (VAR_10 > 0)
                  VAR_7[VAR_10].image->previous=VAR_7[VAR_10-1].image;
                if (VAR_10 < (VAR_13-1))
                  VAR_7[VAR_10].image->next=VAR_7[VAR_10+1].image;
                VAR_7[VAR_10].image->page=VAR_7[VAR_10].page;
              }
              VAR_1->next=VAR_7[0].image;
              VAR_7[0].image->previous=VAR_1;
            }
          VAR_7=(LayerInfo *) RelinquishMagickMemory(VAR_7);
        }
      else
        VAR_7=DestroyLayerInfo(VAR_7,VAR_13);
    }

  return(VAR_9);
}",,"--- func_before
+++ func_after
@@ -232,7 +232,7 @@
             /*
               Layer name.
             */
-            length=(MagickSizeType) ReadBlobByte(image);
+            length=(MagickSizeType) (unsigned char) ReadBlobByte(image);
             combined_length+=length+1;
             if (length > 0)
               (void) ReadBlob(image,(size_t) length++,layer_info[i].name);","{'deleted_lines': ['            length=(MagickSizeType) ReadBlobByte(image);'], 'added_lines': ['            length=(MagickSizeType) (unsigned char) ReadBlobByte(image);']}",True,"coders/psd.c in ImageMagick allows remote attackers to have unspecified impact by leveraging an improper cast, which triggers a heap-based buffer overflow.",9.8,CRITICAL,3,test,2017-01-07T15:56:30Z,1
CVE-2017-5510,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/348,91cc3f36f2ccbd485a0456bab9aebe63b635da88,https://github.com/ImageMagick/ImageMagick/commit/91cc3f36f2ccbd485a0456bab9aebe63b635da88,coders/psd.c,WritePSDChannel,"static size_t WritePSDChannel(const PSDInfo *psd_info,
const ImageInfo *image_info,Image *image,Image *next_image,
const QuantumType quantum_type, unsigned char *compact_pixels,
MagickOffsetType size_offset,const MagickBooleanType separate,
ExceptionInfo *exception)
{
int
y;
MagickBooleanType
monochrome;
QuantumInfo
*quantum_info;
register const Quantum
*p;
register ssize_t
i;
size_t
count,
length;
unsigned char
*pixels;
#ifdef MAGICKCORE_ZLIB_DELEGATE
#define CHUNK 16384
int
flush,
level;
unsigned char
*compressed_pixels;
z_stream
stream;
compressed_pixels=(unsigned char *) NULL;
flush=Z_NO_FLUSH;
#endif
count=0;
if (separate != MagickFalse)
{
size_offset=TellBlob(image)+2;
count+=WriteCompressionStart(psd_info,image,next_image,1);
}
if (next_image->depth > 8)
next_image->depth=16;
monochrome=IsImageMonochrome(image) && (image->depth == 1) ?
MagickTrue : MagickFalse;
quantum_info=AcquireQuantumInfo(image_info,image);
if (quantum_info == (QuantumInfo *) NULL)
return(0);
pixels=(unsigned char *) GetQuantumPixels(quantum_info);
#ifdef MAGICKCORE_ZLIB_DELEGATE
if (next_image->compression == ZipCompression)
{
compressed_pixels=(unsigned char *) AcquireQuantumMemory(CHUNK,
sizeof(*compressed_pixels));
if (compressed_pixels == (unsigned char *) NULL)
{
quantum_info=DestroyQuantumInfo(quantum_info);
return(0);
}
ResetMagickMemory(&stream,0,sizeof(stream));
stream.data_type=Z_BINARY;
level=Z_DEFAULT_COMPRESSION;
if ((image_info->quality > 0 && image_info->quality < 10))
level=(int) image_info->quality;
if (deflateInit(&stream,level) != Z_OK)
{
quantum_info=DestroyQuantumInfo(quantum_info);
return(0);
}
}
#endif
for (y=0; y < (ssize_t) next_image->rows; y++)
{
p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);
if (p == (const Quantum *) NULL)
break;
length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,
quantum_type,pixels,exception);
if (monochrome != MagickFalse)
for (i=0; i < (ssize_t) length; i++)
pixels[i]=(~pixels[i]);
if (next_image->compression == RLECompression)
{
length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,
exception);
count+=WriteBlob(image,length,compact_pixels);
size_offset+=WritePSDOffset(psd_info,image,length,size_offset);
}
#ifdef MAGICKCORE_ZLIB_DELEGATE
else if (next_image->compression == ZipCompression)
{
stream.avail_in=(uInt) length;
stream.next_in=(Bytef *) pixels;
if (y == (ssize_t) next_image->rows-1)
flush=Z_FINISH;
do {
stream.avail_out=(uInt) CHUNK;
stream.next_out=(Bytef *) compressed_pixels;
if (deflate(&stream,flush) == Z_STREAM_ERROR)
break;
length=(size_t) CHUNK-stream.avail_out;
if (length > 0)
count+=WriteBlob(image,length,compressed_pixels);
} while (stream.avail_out == 0);
}
#endif
else
count+=WriteBlob(image,length,pixels);
}
#ifdef MAGICKCORE_ZLIB_DELEGATE
if (next_image->compression == ZipCompression)
{
(void) deflateEnd(&stream);
compressed_pixels=(unsigned char *) RelinquishMagickMemory(
compressed_pixels);
}
#endif
quantum_info=DestroyQuantumInfo(quantum_info);
return(count);
}","static size_t WritePSDChannel(const PSDInfo *VAR_0,
const ImageInfo *VAR_1,Image *VAR_2,Image *VAR_3,
const QuantumType VAR_4, unsigned char *VAR_5,
MagickOffsetType VAR_6,const MagickBooleanType VAR_7,
ExceptionInfo *VAR_8)
{
int
VAR_9;
MagickBooleanType
VAR_10;
QuantumInfo
*VAR_11;
register const Quantum
*VAR_12;
register ssize_t
VAR_13;
size_t
VAR_14,
VAR_15;
unsigned char
*VAR_16;
#ifdef VAR_17
#define VAR_18 16384
int
VAR_19,
VAR_20;
unsigned char
*VAR_21;
z_stream
VAR_22;
VAR_21=(unsigned char *) NULL;
VAR_19=VAR_23;
#endif
VAR_14=0;
if (VAR_7 != VAR_24)
{
VAR_6=TellBlob(VAR_2)+2;
VAR_14+=WriteCompressionStart(VAR_0,VAR_2,VAR_3,1);
}
if (VAR_3->depth > 8)
VAR_3->depth=16;
VAR_10=IsImageMonochrome(VAR_2) && (VAR_2->depth == 1) ?
VAR_25 : VAR_24;
VAR_11=AcquireQuantumInfo(VAR_1,VAR_2);
if (VAR_11 == (QuantumInfo *) NULL)
return(0);
VAR_16=(unsigned char *) GetQuantumPixels(VAR_11);
#ifdef VAR_17
if (VAR_3->compression == VAR_26)
{
VAR_21=(unsigned char *) AcquireQuantumMemory(VAR_18,
sizeof(*VAR_21));
if (VAR_21 == (unsigned char *) NULL)
{
VAR_11=DestroyQuantumInfo(VAR_11);
return(0);
}
ResetMagickMemory(&VAR_22,0,sizeof(VAR_22));
VAR_22.data_type=VAR_27;
VAR_20=VAR_28;
if ((VAR_1->quality > 0 && VAR_1->quality < 10))
VAR_20=(int) VAR_1->quality;
if (deflateInit(&VAR_22,VAR_20) != VAR_29)
{
VAR_11=DestroyQuantumInfo(VAR_11);
return(0);
}
}
#endif
for (VAR_9=0; VAR_9 < (ssize_t) VAR_3->rows; VAR_9++)
{
VAR_12=GetVirtualPixels(VAR_3,0,VAR_9,VAR_3->columns,1,VAR_8);
if (VAR_12 == (const Quantum *) NULL)
break;
VAR_15=ExportQuantumPixels(VAR_3,(CacheView *) NULL,VAR_11,
VAR_4,VAR_16,VAR_8);
if (VAR_10 != VAR_24)
for (VAR_13=0; VAR_13 < (ssize_t) VAR_15; VAR_13++)
VAR_16[VAR_13]=(~VAR_16[VAR_13]);
if (VAR_3->compression == VAR_30)
{
VAR_15=PSDPackbitsEncodeImage(VAR_2,VAR_15,VAR_16,VAR_5,
VAR_8);
VAR_14+=WriteBlob(VAR_2,VAR_15,VAR_5);
VAR_6+=WritePSDOffset(VAR_0,VAR_2,VAR_15,VAR_6);
}
#ifdef VAR_17
else if (next_image->VAR_31 == VAR_26)
{
VAR_22.avail_in=(uInt) VAR_15;
VAR_22.next_in=(Bytef *) VAR_16;
if (VAR_9 == (ssize_t) next_image->rows-1)
VAR_19=VAR_32;
do {
VAR_22.avail_out=(uInt) VAR_18;
VAR_22.next_out=(Bytef *) VAR_21;
if (deflate(&VAR_22,VAR_19) == VAR_33)
break;
VAR_15=(size_t) VAR_18-VAR_22.avail_out;
if (VAR_15 > 0)
VAR_14+=WriteBlob(VAR_2,VAR_15,VAR_21);
} while (VAR_22.avail_out == 0);
}
#endif
else
VAR_14+=WriteBlob(image,length,pixels);
}
#ifdef VAR_17
if (next_image->compression == VAR_26)
{
(void) deflateEnd(&VAR_22);
VAR_21=(unsigned char *) RelinquishMagickMemory(
VAR_21);
}
#endif
VAR_11=DestroyQuantumInfo(VAR_11);
return(VAR_14);
}",ImageMagick/91cc3f36f2ccbd485a0456bab9aebe63b635da88/psd.c/vul/before/0.json,"static size_t WritePSDChannel(const PSDInfo *psd_info,
  const ImageInfo *image_info,Image *image,Image *next_image,
  const QuantumType quantum_type, unsigned char *compact_pixels,
  MagickOffsetType size_offset,const MagickBooleanType separate,
  ExceptionInfo *exception)
{
  int
    y;

  MagickBooleanType
    monochrome;

  QuantumInfo
    *quantum_info;

  register const Quantum
    *p;

  register ssize_t
    i;

  size_t
    count,
    length;

  unsigned char
    *pixels;

#ifdef MAGICKCORE_ZLIB_DELEGATE

#define CHUNK 16384

  int
    flush,
    level;

  unsigned char
    *compressed_pixels;

  z_stream
    stream;

  compressed_pixels=(unsigned char *) NULL;
  flush=Z_NO_FLUSH;
#endif
  count=0;
  if (separate != MagickFalse)
    {
      size_offset=TellBlob(image)+2;
      count+=WriteCompressionStart(psd_info,image,next_image,1);
    }
  if (next_image->depth > 8)
    next_image->depth=16;
  monochrome=IsImageMonochrome(image) && (image->depth == 1) ?
    MagickTrue : MagickFalse;
  quantum_info=AcquireQuantumInfo(image_info,next_image);
  if (quantum_info == (QuantumInfo *) NULL)
    return(0);
  pixels=(unsigned char *) GetQuantumPixels(quantum_info);
#ifdef MAGICKCORE_ZLIB_DELEGATE
  if (next_image->compression == ZipCompression)
    {
      compressed_pixels=(unsigned char *) AcquireQuantumMemory(CHUNK,
        sizeof(*compressed_pixels));
      if (compressed_pixels == (unsigned char *) NULL)
        {
          quantum_info=DestroyQuantumInfo(quantum_info);
          return(0);
        }
      ResetMagickMemory(&stream,0,sizeof(stream));
      stream.data_type=Z_BINARY;
      level=Z_DEFAULT_COMPRESSION;
      if ((image_info->quality > 0 && image_info->quality < 10))
        level=(int) image_info->quality;
      if (deflateInit(&stream,level) != Z_OK)
        {
          quantum_info=DestroyQuantumInfo(quantum_info);
          return(0);
        }
    }
#endif
  for (y=0; y < (ssize_t) next_image->rows; y++)
  {
    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);
    if (p == (const Quantum *) NULL)
      break;
    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,
      quantum_type,pixels,exception);
    if (monochrome != MagickFalse)
      for (i=0; i < (ssize_t) length; i++)
        pixels[i]=(~pixels[i]);
    if (next_image->compression == RLECompression)
      {
        length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,
          exception);
        count+=WriteBlob(image,length,compact_pixels);
        size_offset+=WritePSDOffset(psd_info,image,length,size_offset);
      }
#ifdef MAGICKCORE_ZLIB_DELEGATE
    else if (next_image->compression == ZipCompression)
      {
        stream.avail_in=(uInt) length;
        stream.next_in=(Bytef *) pixels;
        if (y == (ssize_t) next_image->rows-1)
          flush=Z_FINISH;
        do {
            stream.avail_out=(uInt) CHUNK;
            stream.next_out=(Bytef *) compressed_pixels;
            if (deflate(&stream,flush) == Z_STREAM_ERROR)
              break;
            length=(size_t) CHUNK-stream.avail_out;
            if (length > 0)
              count+=WriteBlob(image,length,compressed_pixels);
        } while (stream.avail_out == 0);
      }
#endif
    else
      count+=WriteBlob(image,length,pixels);
  }
#ifdef MAGICKCORE_ZLIB_DELEGATE
  if (next_image->compression == ZipCompression)
    {
      (void) deflateEnd(&stream);
      compressed_pixels=(unsigned char *) RelinquishMagickMemory(
        compressed_pixels);
    }
#endif
  quantum_info=DestroyQuantumInfo(quantum_info);
  return(count);
}","static size_t WritePSDChannel(const PSDInfo *VAR_0,
  const ImageInfo *VAR_1,Image *VAR_2,Image *VAR_3,
  const QuantumType VAR_4, unsigned char *VAR_5,
  MagickOffsetType VAR_6,const MagickBooleanType VAR_7,
  ExceptionInfo *VAR_8)
{
  int
    VAR_9;

  MagickBooleanType
    VAR_10;

  QuantumInfo
    *VAR_11;

  register const Quantum
    *VAR_12;

  register ssize_t
    VAR_13;

  size_t
    VAR_14,
    VAR_15;

  unsigned char
    *VAR_16;

#ifdef VAR_17

#define VAR_18 16384

  int
    VAR_19,
    VAR_20;

  unsigned char
    *VAR_21;

  z_stream
    VAR_22;

  VAR_21=(unsigned char *) NULL;
  VAR_19=VAR_23;
#endif
  VAR_14=0;
  if (VAR_7 != VAR_24)
    {
      VAR_6=TellBlob(VAR_2)+2;
      VAR_14+=WriteCompressionStart(VAR_0,VAR_2,VAR_3,1);
    }
  if (VAR_3->depth > 8)
    VAR_3->depth=16;
  VAR_10=IsImageMonochrome(VAR_2) && (VAR_2->depth == 1) ?
    VAR_25 : VAR_24;
  VAR_11=AcquireQuantumInfo(VAR_1,VAR_3);
  if (VAR_11 == (QuantumInfo *) NULL)
    return(0);
  VAR_16=(unsigned char *) GetQuantumPixels(VAR_11);
#ifdef VAR_17
  if (VAR_3->compression == VAR_26)
    {
      VAR_21=(unsigned char *) AcquireQuantumMemory(VAR_18,
        sizeof(*VAR_21));
      if (VAR_21 == (unsigned char *) NULL)
        {
          VAR_11=DestroyQuantumInfo(VAR_11);
          return(0);
        }
      ResetMagickMemory(&VAR_22,0,sizeof(VAR_22));
      VAR_22.data_type=VAR_27;
      VAR_20=VAR_28;
      if ((VAR_1->quality > 0 && VAR_1->quality < 10))
        VAR_20=(int) VAR_1->quality;
      if (deflateInit(&VAR_22,VAR_20) != VAR_29)
        {
          VAR_11=DestroyQuantumInfo(VAR_11);
          return(0);
        }
    }
#endif
  for (VAR_9=0; VAR_9 < (ssize_t) VAR_3->rows; VAR_9++)
  {
    VAR_12=GetVirtualPixels(VAR_3,0,VAR_9,VAR_3->columns,1,VAR_8);
    if (VAR_12 == (const Quantum *) NULL)
      break;
    VAR_15=ExportQuantumPixels(VAR_3,(CacheView *) NULL,VAR_11,
      VAR_4,VAR_16,VAR_8);
    if (VAR_10 != VAR_24)
      for (VAR_13=0; VAR_13 < (ssize_t) VAR_15; VAR_13++)
        VAR_16[VAR_13]=(~VAR_16[VAR_13]);
    if (VAR_3->compression == VAR_30)
      {
        VAR_15=PSDPackbitsEncodeImage(VAR_2,VAR_15,VAR_16,VAR_5,
          VAR_8);
        VAR_14+=WriteBlob(VAR_2,VAR_15,VAR_5);
        VAR_6+=WritePSDOffset(VAR_0,VAR_2,VAR_15,VAR_6);
      }
#ifdef VAR_17
    else if (next_image->VAR_31 == VAR_26)
      {
        VAR_22.avail_in=(uInt) VAR_15;
        VAR_22.next_in=(Bytef *) VAR_16;
        if (VAR_9 == (ssize_t) next_image->rows-1)
          VAR_19=VAR_32;
        do {
            VAR_22.avail_out=(uInt) VAR_18;
            VAR_22.next_out=(Bytef *) VAR_21;
            if (deflate(&VAR_22,VAR_19) == VAR_33)
              break;
            VAR_15=(size_t) VAR_18-VAR_22.avail_out;
            if (VAR_15 > 0)
              VAR_14+=WriteBlob(VAR_2,VAR_15,VAR_21);
        } while (VAR_22.avail_out == 0);
      }
#endif
    else
      VAR_14+=WriteBlob(image,length,pixels);
  }
#ifdef VAR_17
  if (next_image->compression == VAR_26)
    {
      (void) deflateEnd(&VAR_22);
      VAR_21=(unsigned char *) RelinquishMagickMemory(
        VAR_21);
    }
#endif
  VAR_11=DestroyQuantumInfo(VAR_11);
  return(VAR_14);
}",ImageMagick/91cc3f36f2ccbd485a0456bab9aebe63b635da88/psd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -53,7 +53,7 @@
     next_image->depth=16;
   monochrome=IsImageMonochrome(image) && (image->depth == 1) ?
     MagickTrue : MagickFalse;
-  quantum_info=AcquireQuantumInfo(image_info,image);
+  quantum_info=AcquireQuantumInfo(image_info,next_image);
   if (quantum_info == (QuantumInfo *) NULL)
     return(0);
   pixels=(unsigned char *) GetQuantumPixels(quantum_info);","{'deleted_lines': ['  quantum_info=AcquireQuantumInfo(image_info,image);'], 'added_lines': ['  quantum_info=AcquireQuantumInfo(image_info,next_image);']}",True,"coders/psd.c in ImageMagick allows remote attackers to have unspecified impact via a crafted PSD file, which triggers an out-of-bounds write.",7.8,HIGH,2,test,2017-01-08T13:37:32Z,1
CVE-2017-5546,['CWE-Other'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"mm/slab.c: fix SLAB freelist randomization duplicate entries

This patch fixes a bug in the freelist randomization code.  When a high
random number is used, the freelist will contain duplicate entries.  It
will result in different allocations sharing the same chunk.

It will result in odd behaviours and crashes.  It should be uncommon but
it depends on the machines.  We saw it happening more often on some
machines (every few hours of running tests).

Fixes: c7ce4f60ac19 (""mm: SLAB freelist randomization"")
Link: http://lkml.kernel.org/r/20170103181908.143178-1-thgarnie@google.com
Signed-off-by: John Sperbeck <jsperbeck@google.com>
Signed-off-by: Thomas Garnier <thgarnie@google.com>
Cc: Christoph Lameter <cl@linux.com>
Cc: Pekka Enberg <penberg@kernel.org>
Cc: David Rientjes <rientjes@google.com>
Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",c4e490cf148e85ead0d1b1c2caaba833f1d5b29f,https://github.com/torvalds/linux/commit/c4e490cf148e85ead0d1b1c2caaba833f1d5b29f,mm/slab.c,next_random_slot,"static freelist_idx_t next_random_slot(union freelist_init_state *state)
{
return (state->list[state->pos++] + state->rand) % state->count;
}","static freelist_idx_t next_random_slot(union freelist_init_state *VAR_0)
{
return (VAR_0->list[VAR_0->pos++] + VAR_0->rand) % VAR_0->count;
}",torvalds/linux/c4e490cf148e85ead0d1b1c2caaba833f1d5b29f/slab.c/vul/before/1.json,"static freelist_idx_t next_random_slot(union freelist_init_state *state)
{
	if (state->pos >= state->count)
		state->pos = 0;
	return state->list[state->pos++];
}","static freelist_idx_t next_random_slot(union freelist_init_state *VAR_0)
{
	if (VAR_0->pos >= VAR_0->count)
		VAR_0->pos = 0;
	return VAR_0->list[VAR_0->pos++];
}",torvalds/linux/c4e490cf148e85ead0d1b1c2caaba833f1d5b29f/slab.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,4 +1,6 @@
 static freelist_idx_t next_random_slot(union freelist_init_state *state)
 {
-	return (state->list[state->pos++] + state->rand) % state->count;
+	if (state->pos >= state->count)
+		state->pos = 0;
+	return state->list[state->pos++];
 }","{'deleted_lines': ['\treturn (state->list[state->pos++] + state->rand) % state->count;'], 'added_lines': ['\tif (state->pos >= state->count)', '\t\tstate->pos = 0;', '\treturn state->list[state->pos++];']}",True,The freelist-randomization feature in mm/slab.c in the Linux kernel 4.8.x and 4.9.x before 4.9.5 allows local users to cause a denial of service (duplicate freelist entries and system crash) or possibly have unspecified other impact in opportunistic circumstances by leveraging the selection of a large value for a random number.,7.8,HIGH,2,test,2017-01-11T00:58:24Z,1
CVE-2017-5546,['CWE-Other'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"mm/slab.c: fix SLAB freelist randomization duplicate entries

This patch fixes a bug in the freelist randomization code.  When a high
random number is used, the freelist will contain duplicate entries.  It
will result in different allocations sharing the same chunk.

It will result in odd behaviours and crashes.  It should be uncommon but
it depends on the machines.  We saw it happening more often on some
machines (every few hours of running tests).

Fixes: c7ce4f60ac19 (""mm: SLAB freelist randomization"")
Link: http://lkml.kernel.org/r/20170103181908.143178-1-thgarnie@google.com
Signed-off-by: John Sperbeck <jsperbeck@google.com>
Signed-off-by: Thomas Garnier <thgarnie@google.com>
Cc: Christoph Lameter <cl@linux.com>
Cc: Pekka Enberg <penberg@kernel.org>
Cc: David Rientjes <rientjes@google.com>
Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",c4e490cf148e85ead0d1b1c2caaba833f1d5b29f,https://github.com/torvalds/linux/commit/c4e490cf148e85ead0d1b1c2caaba833f1d5b29f,mm/slab.c,freelist_state_initialize,"static bool freelist_state_initialize(union freelist_init_state *state,
struct kmem_cache *cachep,
unsigned int count)
{
bool ret;
unsigned int rand;
rand = get_random_int();
if (!cachep->random_seq) {
prandom_seed_state(&state->rnd_state, rand);
ret = false;
} else {
state->list = cachep->random_seq;
state->count = count;
state->pos = 0;
state->rand = rand;
ret = true;
}
return ret;
}","static bool freelist_state_initialize(union freelist_init_state *VAR_0,
struct kmem_cache *VAR_1,
unsigned int VAR_2)
{
bool VAR_3;
unsigned int VAR_4;
VAR_4 = get_random_int();
if (!VAR_1->random_seq) {
prandom_seed_state(&VAR_0->rnd_state, VAR_4);
VAR_3 = false;
} else {
VAR_0->list = VAR_1->random_seq;
VAR_0->count = VAR_2;
VAR_0->pos = 0;
VAR_0->rand = VAR_4;
VAR_3 = true;
}
return VAR_3;
}",torvalds/linux/c4e490cf148e85ead0d1b1c2caaba833f1d5b29f/slab.c/vul/before/0.json,"static bool freelist_state_initialize(union freelist_init_state *state,
				struct kmem_cache *cachep,
				unsigned int count)
{
	bool ret;
	unsigned int rand;

	/* Use best entropy available to define a random shift */
	rand = get_random_int();

	/* Use a random state if the pre-computed list is not available */
	if (!cachep->random_seq) {
		prandom_seed_state(&state->rnd_state, rand);
		ret = false;
	} else {
		state->list = cachep->random_seq;
		state->count = count;
		state->pos = rand % count;
		ret = true;
	}
	return ret;
}","static bool freelist_state_initialize(union freelist_init_state *VAR_0,
				struct kmem_cache *VAR_1,
				unsigned int VAR_2)
{
	bool VAR_3;
	unsigned int VAR_4;

	/* COMMENT_0 */
	VAR_4 = get_random_int();

	/* COMMENT_1 */
	if (!VAR_1->random_seq) {
		prandom_seed_state(&VAR_0->rnd_state, VAR_4);
		VAR_3 = false;
	} else {
		VAR_0->list = VAR_1->random_seq;
		VAR_0->count = VAR_2;
		VAR_0->pos = VAR_4 % VAR_2;
		VAR_3 = true;
	}
	return VAR_3;
}",torvalds/linux/c4e490cf148e85ead0d1b1c2caaba833f1d5b29f/slab.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -15,8 +15,7 @@
 	} else {
 		state->list = cachep->random_seq;
 		state->count = count;
-		state->pos = 0;
-		state->rand = rand;
+		state->pos = rand % count;
 		ret = true;
 	}
 	return ret;","{'deleted_lines': ['\t\tstate->pos = 0;', '\t\tstate->rand = rand;'], 'added_lines': ['\t\tstate->pos = rand % count;']}",True,The freelist-randomization feature in mm/slab.c in the Linux kernel 4.8.x and 4.9.x before 4.9.5 allows local users to cause a denial of service (duplicate freelist entries and system crash) or possibly have unspecified other impact in opportunistic circumstances by leveraging the selection of a large value for a random number.,7.8,HIGH,2,test,2017-01-11T00:58:24Z,1
CVE-2016-10133,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ArtifexSoftware/mujs,Fix 697401: Error when dropping extra arguments to lightweight functions.,77ab465f1c394bb77f00966cd950650f3f53cb24,https://github.com/ArtifexSoftware/mujs/commit/77ab465f1c394bb77f00966cd950650f3f53cb24,jsrun.c,jsR_calllwfunction,"static void jsR_calllwfunction(js_State *J, int n, js_Function *F, js_Environment *scope)
{
js_Value v;
int i;
jsR_savescope(J, scope);
if (n > F->numparams) {
js_pop(J, F->numparams - n);
n = F->numparams;
}
for (i = n; i < F->varlen; ++i)
js_pushundefined(J);
jsR_run(J, F);
v = *stackidx(J, -1);
TOP = --BOT; 
js_pushvalue(J, v);
jsR_restorescope(J);
}","static void jsR_calllwfunction(js_State *VAR_0, int VAR_1, js_Function *VAR_2, js_Environment *VAR_3)
{
js_Value VAR_4;
int VAR_5;
jsR_savescope(VAR_0, VAR_3);
if (VAR_1 > VAR_2->numparams) {
js_pop(VAR_0, VAR_2->numparams - VAR_1);
VAR_1 = VAR_2->numparams;
}
for (VAR_5 = VAR_1; VAR_5 < VAR_2->varlen; ++VAR_5)
js_pushundefined(VAR_0);
jsR_run(VAR_0, VAR_2);
VAR_4 = *stackidx(VAR_0, -1);
VAR_6 = --VAR_7; 
js_pushvalue(VAR_0, VAR_4);
jsR_restorescope(VAR_0);
}",ArtifexSoftware/mujs/77ab465f1c394bb77f00966cd950650f3f53cb24/jsrun.c/vul/before/0.json,"static void jsR_calllwfunction(js_State *J, int n, js_Function *F, js_Environment *scope)
{
	js_Value v;
	int i;

	jsR_savescope(J, scope);

	if (n > F->numparams) {
		js_pop(J, n - F->numparams);
		n = F->numparams;
	}
	for (i = n; i < F->varlen; ++i)
		js_pushundefined(J);

	jsR_run(J, F);
	v = *stackidx(J, -1);
	TOP = --BOT; /* clear stack */
	js_pushvalue(J, v);

	jsR_restorescope(J);
}","static void jsR_calllwfunction(js_State *VAR_0, int VAR_1, js_Function *VAR_2, js_Environment *VAR_3)
{
	js_Value VAR_4;
	int VAR_5;

	jsR_savescope(VAR_0, VAR_3);

	if (VAR_1 > VAR_2->numparams) {
		js_pop(VAR_0, VAR_1 - VAR_2->numparams);
		VAR_1 = VAR_2->numparams;
	}
	for (VAR_5 = VAR_1; VAR_5 < VAR_2->varlen; ++VAR_5)
		js_pushundefined(VAR_0);

	jsR_run(VAR_0, VAR_2);
	VAR_4 = *stackidx(VAR_0, -1);
	VAR_6 = --VAR_7; /* COMMENT_0 */
	js_pushvalue(VAR_0, VAR_4);

	jsR_restorescope(VAR_0);
}",ArtifexSoftware/mujs/77ab465f1c394bb77f00966cd950650f3f53cb24/jsrun.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
 	jsR_savescope(J, scope);
 
 	if (n > F->numparams) {
-		js_pop(J, F->numparams - n);
+		js_pop(J, n - F->numparams);
 		n = F->numparams;
 	}
 	for (i = n; i < F->varlen; ++i)","{'deleted_lines': ['\t\tjs_pop(J, F->numparams - n);'], 'added_lines': ['\t\tjs_pop(J, n - F->numparams);']}",True,"Heap-based buffer overflow in the js_stackoverflow function in jsrun.c in Artifex Software, Inc. MuJS allows attackers to have unspecified impact by leveraging an error when dropping extra arguments to lightweight functions.",9.8,CRITICAL,3,test,2017-01-12T13:47:01Z,1
CVE-2017-5029,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,GNOME/libxslt,"Check for integer overflow in xsltAddTextString

Limit buffer size in xsltAddTextString to INT_MAX. The issue can be
exploited to trigger an out of bounds write on 64-bit systems.

Originally reported to Chromium:

https://crbug.com/676623",08ab2774b870de1c7b5a48693df75e8154addae5,https://github.com/GNOME/libxslt/commit/08ab2774b870de1c7b5a48693df75e8154addae5,libxslt/transform.c,xsltAddTextString,"static xmlNodePtr
xsltAddTextString(xsltTransformContextPtr ctxt, xmlNodePtr target,
const xmlChar *string, int len) {
if ((len <= 0) || (string == NULL) || (target == NULL))
return(target);
if (ctxt->lasttext == target->content) {
if (ctxt->lasttuse + len >= ctxt->lasttsize) {
xmlChar *newbuf;
int size;
size = ctxt->lasttsize + len + 100;
size *= 2;
newbuf = (xmlChar *) xmlRealloc(target->content,size);
if (newbuf == NULL) {
xsltTransformError(ctxt, NULL, target,
""xsltCopyText: text allocation failed\n"");
return(NULL);
}
ctxt->lasttsize = size;
ctxt->lasttext = newbuf;
target->content = newbuf;
}
memcpy(&(target->content[ctxt->lasttuse]), string, len);
ctxt->lasttuse += len;
target->content[ctxt->lasttuse] = 0;
} else {
xmlNodeAddContent(target, string);
ctxt->lasttext = target->content;
len = xmlStrlen(target->content);
ctxt->lasttsize = len;
ctxt->lasttuse = len;
}
return(target);
}","static xmlNodePtr
xsltAddTextString(xsltTransformContextPtr VAR_0, xmlNodePtr VAR_1,
const xmlChar *VAR_2, int VAR_3) {
if ((VAR_3 <= 0) || (VAR_2 == NULL) || (VAR_1 == NULL))
return(VAR_1);
if (VAR_0->lasttext == VAR_1->content) {
if (VAR_0->lasttuse + VAR_3 >= VAR_0->lasttsize) {
xmlChar *VAR_4;
int VAR_5;
VAR_5 = VAR_0->lasttsize + VAR_3 + 100;
VAR_5 *= 2;
VAR_4 = (xmlChar *) xmlRealloc(VAR_1->content,VAR_5);
if (VAR_4 == NULL) {
xsltTransformError(VAR_0, NULL, VAR_1,
""xsltCopyText: text allocation failed\n"");
return(NULL);
}
VAR_0->lasttsize = VAR_5;
VAR_0->lasttext = VAR_4;
VAR_1->content = VAR_4;
}
memcpy(&(VAR_1->content[VAR_0->lasttuse]), VAR_2, VAR_3);
VAR_0->lasttuse += VAR_3;
VAR_1->content[VAR_0->lasttuse] = 0;
} else {
xmlNodeAddContent(VAR_1, VAR_2);
VAR_0->lasttext = VAR_1->content;
VAR_3 = xmlStrlen(VAR_1->content);
VAR_0->lasttsize = VAR_3;
VAR_0->lasttuse = VAR_3;
}
return(VAR_1);
}",GNOME/libxslt/08ab2774b870de1c7b5a48693df75e8154addae5/transform.c/vul/before/0.json,"static xmlNodePtr
xsltAddTextString(xsltTransformContextPtr ctxt, xmlNodePtr target,
		  const xmlChar *string, int len) {
    /*
     * optimization
     */
    if ((len <= 0) || (string == NULL) || (target == NULL))
        return(target);

    if (ctxt->lasttext == target->content) {
        int minSize;

        /* Check for integer overflow accounting for NUL terminator. */
        if (len >= INT_MAX - ctxt->lasttuse) {
            xsltTransformError(ctxt, NULL, target,
                ""xsltCopyText: text allocation failed\n"");
            return(NULL);
        }
        minSize = ctxt->lasttuse + len + 1;

        if (ctxt->lasttsize < minSize) {
	    xmlChar *newbuf;
	    int size;
            int extra;

            /* Double buffer size but increase by at least 100 bytes. */
            extra = minSize < 100 ? 100 : minSize;

            /* Check for integer overflow. */
            if (extra > INT_MAX - ctxt->lasttsize) {
                size = INT_MAX;
            }
            else {
                size = ctxt->lasttsize + extra;
            }

	    newbuf = (xmlChar *) xmlRealloc(target->content,size);
	    if (newbuf == NULL) {
		xsltTransformError(ctxt, NULL, target,
		 ""xsltCopyText: text allocation failed\n"");
		return(NULL);
	    }
	    ctxt->lasttsize = size;
	    ctxt->lasttext = newbuf;
	    target->content = newbuf;
	}
	memcpy(&(target->content[ctxt->lasttuse]), string, len);
	ctxt->lasttuse += len;
	target->content[ctxt->lasttuse] = 0;
    } else {
	xmlNodeAddContent(target, string);
	ctxt->lasttext = target->content;
	len = xmlStrlen(target->content);
	ctxt->lasttsize = len;
	ctxt->lasttuse = len;
    }
    return(target);
}","static xmlNodePtr
xsltAddTextString(xsltTransformContextPtr VAR_0, xmlNodePtr VAR_1,
		  const xmlChar *VAR_2, int VAR_3) {
    /* COMMENT_0 */
                   
       
    if ((VAR_3 <= 0) || (VAR_2 == NULL) || (VAR_1 == NULL))
        return(VAR_1);

    if (VAR_0->lasttext == VAR_1->content) {
        int VAR_4;

        /* COMMENT_3 */
        if (VAR_3 >= VAR_5 - VAR_0->lasttuse) {
            xsltTransformError(VAR_0, NULL, VAR_1,
                ""xsltCopyText: text allocation failed\n"");
            return(NULL);
        }
        VAR_4 = VAR_0->lasttuse + VAR_3 + 1;

        if (VAR_0->lasttsize < VAR_4) {
	    xmlChar *VAR_6;
	    int VAR_7;
            int VAR_8;

            /* COMMENT_4 */
            VAR_8 = VAR_4 < 100 ? 100 : VAR_4;

            /* COMMENT_5 */
            if (VAR_8 > VAR_5 - VAR_0->lasttsize) {
                VAR_7 = VAR_5;
            }
            else {
                VAR_7 = VAR_0->lasttsize + VAR_8;
            }

	    VAR_6 = (xmlChar *) xmlRealloc(VAR_1->content,VAR_7);
	    if (VAR_6 == NULL) {
		xsltTransformError(VAR_0, NULL, VAR_1,
		 ""xsltCopyText: text allocation failed\n"");
		return(NULL);
	    }
	    VAR_0->lasttsize = VAR_7;
	    VAR_0->lasttext = VAR_6;
	    VAR_1->content = VAR_6;
	}
	memcpy(&(VAR_1->content[VAR_0->lasttuse]), VAR_2, VAR_3);
	VAR_0->lasttuse += VAR_3;
	VAR_1->content[VAR_0->lasttuse] = 0;
    } else {
	xmlNodeAddContent(VAR_1, VAR_2);
	VAR_0->lasttext = VAR_1->content;
	VAR_3 = xmlStrlen(VAR_1->content);
	VAR_0->lasttsize = VAR_3;
	VAR_0->lasttuse = VAR_3;
    }
    return(VAR_1);
}",GNOME/libxslt/08ab2774b870de1c7b5a48693df75e8154addae5/transform.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,13 +8,32 @@
         return(target);
 
     if (ctxt->lasttext == target->content) {
+        int minSize;
 
-	if (ctxt->lasttuse + len >= ctxt->lasttsize) {
+        /* Check for integer overflow accounting for NUL terminator. */
+        if (len >= INT_MAX - ctxt->lasttuse) {
+            xsltTransformError(ctxt, NULL, target,
+                ""xsltCopyText: text allocation failed\n"");
+            return(NULL);
+        }
+        minSize = ctxt->lasttuse + len + 1;
+
+        if (ctxt->lasttsize < minSize) {
 	    xmlChar *newbuf;
 	    int size;
+            int extra;
 
-	    size = ctxt->lasttsize + len + 100;
-	    size *= 2;
+            /* Double buffer size but increase by at least 100 bytes. */
+            extra = minSize < 100 ? 100 : minSize;
+
+            /* Check for integer overflow. */
+            if (extra > INT_MAX - ctxt->lasttsize) {
+                size = INT_MAX;
+            }
+            else {
+                size = ctxt->lasttsize + extra;
+            }
+
 	    newbuf = (xmlChar *) xmlRealloc(target->content,size);
 	    if (newbuf == NULL) {
 		xsltTransformError(ctxt, NULL, target,","{'deleted_lines': ['\tif (ctxt->lasttuse + len >= ctxt->lasttsize) {', '\t    size = ctxt->lasttsize + len + 100;', '\t    size *= 2;'], 'added_lines': ['        int minSize;', '        /* Check for integer overflow accounting for NUL terminator. */', '        if (len >= INT_MAX - ctxt->lasttuse) {', '            xsltTransformError(ctxt, NULL, target,', '                ""xsltCopyText: text allocation failed\\n"");', '            return(NULL);', '        }', '        minSize = ctxt->lasttuse + len + 1;', '', '        if (ctxt->lasttsize < minSize) {', '            int extra;', '            /* Double buffer size but increase by at least 100 bytes. */', '            extra = minSize < 100 ? 100 : minSize;', '', '            /* Check for integer overflow. */', '            if (extra > INT_MAX - ctxt->lasttsize) {', '                size = INT_MAX;', '            }', '            else {', '                size = ctxt->lasttsize + extra;', '            }', '']}",True,"The xsltAddTextString function in transform.c in libxslt 1.1.29, as used in Blink in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android, lacked a check for integer overflow during a size calculation, which allowed a remote attacker to perform an out of bounds memory write via a crafted HTML page.",8.8,HIGH,2,test,2017-01-12T14:39:52Z,1
CVE-2017-6059,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:P/A:N,0,OpenIDC/mod_auth_openidc,"don't echo query params on invalid requests to redirect URI; closes #212

thanks @LukasReschke; I'm sure there's some OWASP guideline that warns
against this",612e309bfffd6f9b8ad7cdccda3019fc0865f3b4,https://github.com/OpenIDC/mod_auth_openidc/commit/612e309bfffd6f9b8ad7cdccda3019fc0865f3b4,src/mod_auth_openidc.c,oidc_handle_redirect_uri_request,"int oidc_handle_redirect_uri_request(request_rec *r, oidc_cfg *c,
oidc_session_t *session) {
if (oidc_proto_is_redirect_authorization_response(r, c)) {
return oidc_handle_redirect_authorization_response(r, c, session);
} else if (oidc_proto_is_post_authorization_response(r, c)) {
return oidc_handle_post_authorization_response(r, c, session);
} else if (oidc_is_discovery_response(r, c)) {
return oidc_handle_discovery_response(r, c);
} else if (oidc_util_request_has_parameter(r, ""logout"")) {
return oidc_handle_logout(r, c, session);
} else if (oidc_util_request_has_parameter(r, ""jwks"")) {
return oidc_handle_jwks(r, c);
} else if (oidc_util_request_has_parameter(r, ""session"")) {
return oidc_handle_session_management(r, c, session);
} else if (oidc_util_request_has_parameter(r, ""refresh"")) {
return oidc_handle_refresh_token_request(r, c, session);
} else if (oidc_util_request_has_parameter(r, ""request_uri"")) {
return oidc_handle_request_uri(r, c);
} else if (oidc_util_request_has_parameter(r, ""remove_at_cache"")) {
return oidc_handle_remove_at_cache(r, c);
} else if ((r->args == NULL) || (apr_strnatcmp(r->args, """") == 0)) {
return oidc_proto_javascript_implicit(r, c);
}
if (oidc_util_request_has_parameter(r, ""error"")) {
oidc_handle_redirect_authorization_response(r, c, session);
}
return oidc_util_html_send_error(r, c->error_template, ""Invalid Request"",
apr_psprintf(r->pool,
""The OpenID Connect callback URL received an invalid request: %s"",
r->args), HTTP_INTERNAL_SERVER_ERROR);
}","int oidc_handle_redirect_uri_request(request_rec *VAR_0, oidc_cfg *VAR_1,
oidc_session_t *VAR_2) {
if (oidc_proto_is_redirect_authorization_response(VAR_0, VAR_1)) {
return oidc_handle_redirect_authorization_response(VAR_0, VAR_1, VAR_2);
} else if (oidc_proto_is_post_authorization_response(VAR_0, VAR_1)) {
return oidc_handle_post_authorization_response(VAR_0, VAR_1, VAR_2);
} else if (oidc_is_discovery_response(VAR_0, VAR_1)) {
return oidc_handle_discovery_response(VAR_0, VAR_1);
} else if (oidc_util_request_has_parameter(VAR_0, ""logout"")) {
return oidc_handle_logout(VAR_0, VAR_1, VAR_2);
} else if (oidc_util_request_has_parameter(VAR_0, ""jwks"")) {
return oidc_handle_jwks(VAR_0, VAR_1);
} else if (oidc_util_request_has_parameter(VAR_0, ""session"")) {
return oidc_handle_session_management(VAR_0, VAR_1, VAR_2);
} else if (oidc_util_request_has_parameter(VAR_0, ""refresh"")) {
return oidc_handle_refresh_token_request(VAR_0, VAR_1, VAR_2);
} else if (oidc_util_request_has_parameter(VAR_0, ""request_uri"")) {
return oidc_handle_request_uri(VAR_0, VAR_1);
} else if (oidc_util_request_has_parameter(VAR_0, ""remove_at_cache"")) {
return oidc_handle_remove_at_cache(VAR_0, VAR_1);
} else if ((VAR_0->args == NULL) || (apr_strnatcmp(VAR_0->args, """") == 0)) {
return oidc_proto_javascript_implicit(VAR_0, VAR_1);
}
if (oidc_util_request_has_parameter(VAR_0, ""error"")) {
oidc_handle_redirect_authorization_response(VAR_0, VAR_1, VAR_2);
}
return oidc_util_html_send_error(VAR_0, VAR_1->error_template, ""Invalid Request"",
apr_psprintf(VAR_0->pool,
""The OpenID Connect callback URL received an invalid request: %s"",
VAR_0->args), VAR_3);
}",OpenIDC/mod_auth_openidc/612e309bfffd6f9b8ad7cdccda3019fc0865f3b4/mod_auth_openidc.c/vul/before/0.json,"int oidc_handle_redirect_uri_request(request_rec *r, oidc_cfg *c,
		oidc_session_t *session) {

	if (oidc_proto_is_redirect_authorization_response(r, c)) {

		/* this is an authorization response from the OP using the Basic Client profile or a Hybrid flow*/
		return oidc_handle_redirect_authorization_response(r, c, session);

	} else if (oidc_proto_is_post_authorization_response(r, c)) {

		/* this is an authorization response using the fragment(+POST) response_mode with the Implicit Client profile */
		return oidc_handle_post_authorization_response(r, c, session);

	} else if (oidc_is_discovery_response(r, c)) {

		/* this is response from the OP discovery page */
		return oidc_handle_discovery_response(r, c);

	} else if (oidc_util_request_has_parameter(r, ""logout"")) {

		/* handle logout */
		return oidc_handle_logout(r, c, session);

	} else if (oidc_util_request_has_parameter(r, ""jwks"")) {

		/* handle JWKs request */
		return oidc_handle_jwks(r, c);

	} else if (oidc_util_request_has_parameter(r, ""session"")) {

		/* handle session management request */
		return oidc_handle_session_management(r, c, session);

	} else if (oidc_util_request_has_parameter(r, ""refresh"")) {

		/* handle refresh token request */
		return oidc_handle_refresh_token_request(r, c, session);

	} else if (oidc_util_request_has_parameter(r, ""request_uri"")) {

		/* handle request object by reference request */
		return oidc_handle_request_uri(r, c);

	} else if (oidc_util_request_has_parameter(r, ""remove_at_cache"")) {

		/* handle request to invalidate access token cache */
		return oidc_handle_remove_at_cache(r, c);

	} else if ((r->args == NULL) || (apr_strnatcmp(r->args, """") == 0)) {

		/* this is a ""bare"" request to the redirect URI, indicating implicit flow using the fragment response_mode */
		return oidc_proto_javascript_implicit(r, c);
	}

	/* this is not an authorization response or logout request */

	/* check for ""error"" response */
	if (oidc_util_request_has_parameter(r, ""error"")) {

//		char *error = NULL, *descr = NULL;
//		oidc_util_get_request_parameter(r, ""error"", &error);
//		oidc_util_get_request_parameter(r, ""error_description"", &descr);
//
//		/* send user facing error to browser */
//		return oidc_util_html_send_error(r, error, descr, DONE);
		oidc_handle_redirect_authorization_response(r, c, session);
	}

	/* something went wrong */
	return oidc_util_html_send_error(r, c->error_template, ""Invalid Request"",
			apr_psprintf(r->pool,
					""The OpenID Connect callback URL received an invalid request""),
					HTTP_INTERNAL_SERVER_ERROR);
}","int oidc_handle_redirect_uri_request(request_rec *VAR_0, oidc_cfg *VAR_1,
		oidc_session_t *VAR_2) {

	if (oidc_proto_is_redirect_authorization_response(VAR_0, VAR_1)) {

		/* COMMENT_0 */
		return oidc_handle_redirect_authorization_response(VAR_0, VAR_1, VAR_2);

	} else if (oidc_proto_is_post_authorization_response(VAR_0, VAR_1)) {

		/* COMMENT_1 */
		return oidc_handle_post_authorization_response(VAR_0, VAR_1, VAR_2);

	} else if (oidc_is_discovery_response(VAR_0, VAR_1)) {

		/* COMMENT_2 */
		return oidc_handle_discovery_response(VAR_0, VAR_1);

	} else if (oidc_util_request_has_parameter(VAR_0, ""logout"")) {

		/* COMMENT_3 */
		return oidc_handle_logout(VAR_0, VAR_1, VAR_2);

	} else if (oidc_util_request_has_parameter(VAR_0, ""jwks"")) {

		/* COMMENT_4 */
		return oidc_handle_jwks(VAR_0, VAR_1);

	} else if (oidc_util_request_has_parameter(VAR_0, ""session"")) {

		/* COMMENT_5 */
		return oidc_handle_session_management(VAR_0, VAR_1, VAR_2);

	} else if (oidc_util_request_has_parameter(VAR_0, ""refresh"")) {

		/* COMMENT_6 */
		return oidc_handle_refresh_token_request(VAR_0, VAR_1, VAR_2);

	} else if (oidc_util_request_has_parameter(VAR_0, ""request_uri"")) {

		/* COMMENT_7 */
		return oidc_handle_request_uri(VAR_0, VAR_1);

	} else if (oidc_util_request_has_parameter(VAR_0, ""remove_at_cache"")) {

		/* COMMENT_8 */
		return oidc_handle_remove_at_cache(VAR_0, VAR_1);

	} else if ((VAR_0->args == NULL) || (apr_strnatcmp(VAR_0->args, """") == 0)) {

		/* COMMENT_9 */
		return oidc_proto_javascript_implicit(VAR_0, VAR_1);
	}

	/* COMMENT_10 */

	/* COMMENT_11 */
	if (oidc_util_request_has_parameter(VAR_0, ""error"")) {

/* COMMENT_12 */
/* COMMENT_13 */
/* COMMENT_14 */
/* COMMENT_15 */
/* COMMENT_16 */
/* COMMENT_17 */
		oidc_handle_redirect_authorization_response(VAR_0, VAR_1, VAR_2);
	}

	/* COMMENT_18 */
	return oidc_util_html_send_error(VAR_0, VAR_1->error_template, ""Invalid Request"",
			apr_psprintf(VAR_0->pool,
					""The OpenID Connect callback URL received an invalid request""),
					VAR_3);
}",OpenIDC/mod_auth_openidc/612e309bfffd6f9b8ad7cdccda3019fc0865f3b4/mod_auth_openidc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -69,6 +69,6 @@
 	/* something went wrong */
 	return oidc_util_html_send_error(r, c->error_template, ""Invalid Request"",
 			apr_psprintf(r->pool,
-					""The OpenID Connect callback URL received an invalid request: %s"",
-					r->args), HTTP_INTERNAL_SERVER_ERROR);
+					""The OpenID Connect callback URL received an invalid request""),
+					HTTP_INTERNAL_SERVER_ERROR);
 }","{'deleted_lines': ['\t\t\t\t\t""The OpenID Connect callback URL received an invalid request: %s"",', '\t\t\t\t\tr->args), HTTP_INTERNAL_SERVER_ERROR);'], 'added_lines': ['\t\t\t\t\t""The OpenID Connect callback URL received an invalid request""),', '\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);']}",True,"Mod_auth_openidc.c in the Ping Identity OpenID Connect authentication module for Apache (aka mod_auth_openidc) before 2.14 allows remote attackers to spoof page content via a malicious URL provided to the user, which triggers an invalid request.",7.5,HIGH,2,test,2017-01-18T23:03:37Z,1
CVE-2017-9060,['CWE-401'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,qemu,"virtio-gpu: fix memory leak in set scanout

In virtio_gpu_set_scanout function, when creating the 'rect'
its refcount is set to 2, by pixman_image_create_bits and
qemu_create_displaysurface_pixman function. This can lead
a memory leak issues. This patch avoid this issue.

Signed-off-by: Li Qiang <liqiang6-s@360.cn>
Reviewed-by: Marc-Andr Lureau <marcandre.lureau@redhat.com>
Message-id: 5884626f.5b2f6b0a.1bfff.3037@mx.google.com
Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>",dd248ed7e204ee8a1873914e02b8b526e8f1b80d,https://github.com/qemu/qemu/commit/dd248ed7e204ee8a1873914e02b8b526e8f1b80d,hw/display/virtio-gpu.c,virtio_gpu_set_scanout,"static void virtio_gpu_set_scanout(VirtIOGPU *g,
struct virtio_gpu_ctrl_command *cmd)
{
struct virtio_gpu_simple_resource *res;
struct virtio_gpu_scanout *scanout;
pixman_format_code_t format;
uint32_t offset;
int bpp;
struct virtio_gpu_set_scanout ss;
VIRTIO_GPU_FILL_CMD(ss);
trace_virtio_gpu_cmd_set_scanout(ss.scanout_id, ss.resource_id,
ss.r.width, ss.r.height, ss.r.x, ss.r.y);
if (ss.scanout_id >= g->conf.max_outputs) {
qemu_log_mask(LOG_GUEST_ERROR, ""%s: illegal scanout id specified %d"",
__func__, ss.scanout_id);
cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;
return;
}
g->enable = 1;
if (ss.resource_id == 0) {
scanout = &g->scanout[ss.scanout_id];
if (scanout->resource_id) {
res = virtio_gpu_find_resource(g, scanout->resource_id);
if (res) {
res->scanout_bitmask &= ~(1 << ss.scanout_id);
}
}
if (ss.scanout_id == 0) {
qemu_log_mask(LOG_GUEST_ERROR,
""%s: illegal scanout id specified %d"",
__func__, ss.scanout_id);
cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;
return;
}
dpy_gfx_replace_surface(g->scanout[ss.scanout_id].con, NULL);
scanout->ds = NULL;
scanout->width = 0;
scanout->height = 0;
return;
}
res = virtio_gpu_find_resource(g, ss.resource_id);
if (!res) {
qemu_log_mask(LOG_GUEST_ERROR, ""%s: illegal resource specified %d\n"",
__func__, ss.resource_id);
cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;
return;
}
if (ss.r.x > res->width ||
ss.r.y > res->height ||
ss.r.width > res->width ||
ss.r.height > res->height ||
ss.r.x + ss.r.width > res->width ||
ss.r.y + ss.r.height > res->height) {
qemu_log_mask(LOG_GUEST_ERROR, ""%s: illegal scanout %d bounds for""
"" resource %d, (%d,%d)+%d,%d vs %d %d\n"",
__func__, ss.scanout_id, ss.resource_id, ss.r.x, ss.r.y,
ss.r.width, ss.r.height, res->width, res->height);
cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;
return;
}
scanout = &g->scanout[ss.scanout_id];
format = pixman_image_get_format(res->image);
bpp = (PIXMAN_FORMAT_BPP(format) + 7) / 8;
offset = (ss.r.x * bpp) + ss.r.y * pixman_image_get_stride(res->image);
if (!scanout->ds || surface_data(scanout->ds)
!= ((uint8_t *)pixman_image_get_data(res->image) + offset) ||
scanout->width != ss.r.width ||
scanout->height != ss.r.height) {
pixman_image_t *rect;
void *ptr = (uint8_t *)pixman_image_get_data(res->image) + offset;
rect = pixman_image_create_bits(format, ss.r.width, ss.r.height, ptr,
pixman_image_get_stride(res->image));
pixman_image_ref(res->image);
pixman_image_set_destroy_function(rect, virtio_unref_resource,
res->image);
scanout->ds = qemu_create_displaysurface_pixman(rect);
if (!scanout->ds) {
cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;
return;
}
dpy_gfx_replace_surface(g->scanout[ss.scanout_id].con, scanout->ds);
}
res->scanout_bitmask |= (1 << ss.scanout_id);
scanout->resource_id = ss.resource_id;
scanout->x = ss.r.x;
scanout->y = ss.r.y;
scanout->width = ss.r.width;
scanout->height = ss.r.height;
}","static void virtio_gpu_set_scanout(VirtIOGPU *VAR_0,
struct virtio_gpu_ctrl_command *VAR_1)
{
struct virtio_gpu_simple_resource *VAR_2;
struct virtio_gpu_scanout *VAR_3;
pixman_format_code_t VAR_4;
uint32_t VAR_5;
int VAR_6;
struct virtio_gpu_set_scanout VAR_7;
VIRTIO_GPU_FILL_CMD(VAR_7);
trace_virtio_gpu_cmd_set_scanout(VAR_7.scanout_id, VAR_7.resource_id,
VAR_7.r.width, VAR_7.r.height, VAR_7.r.x, VAR_7.r.y);
if (VAR_7.scanout_id >= VAR_0->conf.max_outputs) {
qemu_log_mask(VAR_8, ""%s: illegal scanout id specified %d"",
VAR_9, VAR_7.scanout_id);
VAR_1->error = VAR_10;
return;
}
VAR_0->enable = 1;
if (VAR_7.resource_id == 0) {
VAR_3 = &VAR_0->scanout[VAR_7.scanout_id];
if (VAR_3->resource_id) {
VAR_2 = virtio_gpu_find_resource(VAR_0, VAR_3->resource_id);
if (VAR_2) {
VAR_2->scanout_bitmask &= ~(1 << VAR_7.scanout_id);
}
}
if (VAR_7.scanout_id == 0) {
qemu_log_mask(VAR_8,
""%s: illegal scanout id specified %d"",
VAR_9, VAR_7.scanout_id);
VAR_1->error = VAR_10;
return;
}
dpy_gfx_replace_surface(VAR_0->scanout[VAR_7.scanout_id].con, NULL);
VAR_3->ds = NULL;
VAR_3->width = 0;
VAR_3->height = 0;
return;
}
VAR_2 = virtio_gpu_find_resource(VAR_0, VAR_7.resource_id);
if (!VAR_2) {
qemu_log_mask(VAR_8, ""%s: illegal resource specified %d\n"",
VAR_9, VAR_7.resource_id);
VAR_1->error = VAR_11;
return;
}
if (VAR_7.r.x > VAR_2->width ||
VAR_7.r.y > VAR_2->height ||
VAR_7.r.width > VAR_2->width ||
VAR_7.r.height > VAR_2->height ||
VAR_7.r.x + VAR_7.r.width > VAR_2->width ||
VAR_7.r.y + VAR_7.r.height > VAR_2->height) {
qemu_log_mask(VAR_8, ""%s: illegal scanout %d bounds for""
"" resource %d, (%d,%d)+%d,%d vs %d %d\n"",
VAR_9, VAR_7.scanout_id, VAR_7.resource_id, VAR_7.r.x, VAR_7.r.y,
VAR_7.r.width, VAR_7.r.height, VAR_2->width, VAR_2->height);
VAR_1->error = VAR_12;
return;
}
VAR_3 = &VAR_0->scanout[VAR_7.scanout_id];
VAR_4 = pixman_image_get_format(VAR_2->image);
VAR_6 = (PIXMAN_FORMAT_BPP(VAR_4) + 7) / 8;
VAR_5 = (VAR_7.r.x * VAR_6) + VAR_7.r.y * pixman_image_get_stride(VAR_2->image);
if (!VAR_3->ds || surface_data(VAR_3->ds)
!= ((uint8_t *)pixman_image_get_data(VAR_2->image) + VAR_5) ||
VAR_3->width != VAR_7.r.width ||
VAR_3->height != VAR_7.r.height) {
pixman_image_t *VAR_13;
void *VAR_14 = (uint8_t *)pixman_image_get_data(VAR_2->image) + VAR_5;
VAR_13 = pixman_image_create_bits(VAR_4, VAR_7.r.width, VAR_7.r.height, VAR_14,
pixman_image_get_stride(VAR_2->image));
pixman_image_ref(VAR_2->image);
pixman_image_set_destroy_function(VAR_13, VAR_15,
VAR_2->image);
VAR_3->ds = qemu_create_displaysurface_pixman(VAR_13);
if (!VAR_3->ds) {
VAR_1->error = VAR_16;
return;
}
dpy_gfx_replace_surface(VAR_0->scanout[VAR_7.scanout_id].con, VAR_3->ds);
}
VAR_2->scanout_bitmask |= (1 << VAR_7.scanout_id);
VAR_3->resource_id = VAR_7.resource_id;
VAR_3->x = VAR_7.r.x;
VAR_3->y = VAR_7.r.y;
VAR_3->width = VAR_7.r.width;
VAR_3->height = VAR_7.r.height;
}",qemu/dd248ed7e204ee8a1873914e02b8b526e8f1b80d/virtio-gpu.c/vul/before/0.json,"static void virtio_gpu_set_scanout(VirtIOGPU *g,
                                   struct virtio_gpu_ctrl_command *cmd)
{
    struct virtio_gpu_simple_resource *res;
    struct virtio_gpu_scanout *scanout;
    pixman_format_code_t format;
    uint32_t offset;
    int bpp;
    struct virtio_gpu_set_scanout ss;

    VIRTIO_GPU_FILL_CMD(ss);
    trace_virtio_gpu_cmd_set_scanout(ss.scanout_id, ss.resource_id,
                                     ss.r.width, ss.r.height, ss.r.x, ss.r.y);

    if (ss.scanout_id >= g->conf.max_outputs) {
        qemu_log_mask(LOG_GUEST_ERROR, ""%s: illegal scanout id specified %d"",
                      __func__, ss.scanout_id);
        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;
        return;
    }

    g->enable = 1;
    if (ss.resource_id == 0) {
        scanout = &g->scanout[ss.scanout_id];
        if (scanout->resource_id) {
            res = virtio_gpu_find_resource(g, scanout->resource_id);
            if (res) {
                res->scanout_bitmask &= ~(1 << ss.scanout_id);
            }
        }
        if (ss.scanout_id == 0) {
            qemu_log_mask(LOG_GUEST_ERROR,
                          ""%s: illegal scanout id specified %d"",
                          __func__, ss.scanout_id);
            cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;
            return;
        }
        dpy_gfx_replace_surface(g->scanout[ss.scanout_id].con, NULL);
        scanout->ds = NULL;
        scanout->width = 0;
        scanout->height = 0;
        return;
    }

    /* create a surface for this scanout */
    res = virtio_gpu_find_resource(g, ss.resource_id);
    if (!res) {
        qemu_log_mask(LOG_GUEST_ERROR, ""%s: illegal resource specified %d\n"",
                      __func__, ss.resource_id);
        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;
        return;
    }

    if (ss.r.x > res->width ||
        ss.r.y > res->height ||
        ss.r.width > res->width ||
        ss.r.height > res->height ||
        ss.r.x + ss.r.width > res->width ||
        ss.r.y + ss.r.height > res->height) {
        qemu_log_mask(LOG_GUEST_ERROR, ""%s: illegal scanout %d bounds for""
                      "" resource %d, (%d,%d)+%d,%d vs %d %d\n"",
                      __func__, ss.scanout_id, ss.resource_id, ss.r.x, ss.r.y,
                      ss.r.width, ss.r.height, res->width, res->height);
        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;
        return;
    }

    scanout = &g->scanout[ss.scanout_id];

    format = pixman_image_get_format(res->image);
    bpp = (PIXMAN_FORMAT_BPP(format) + 7) / 8;
    offset = (ss.r.x * bpp) + ss.r.y * pixman_image_get_stride(res->image);
    if (!scanout->ds || surface_data(scanout->ds)
        != ((uint8_t *)pixman_image_get_data(res->image) + offset) ||
        scanout->width != ss.r.width ||
        scanout->height != ss.r.height) {
        pixman_image_t *rect;
        void *ptr = (uint8_t *)pixman_image_get_data(res->image) + offset;
        rect = pixman_image_create_bits(format, ss.r.width, ss.r.height, ptr,
                                        pixman_image_get_stride(res->image));
        pixman_image_ref(res->image);
        pixman_image_set_destroy_function(rect, virtio_unref_resource,
                                          res->image);
        /* realloc the surface ptr */
        scanout->ds = qemu_create_displaysurface_pixman(rect);
        if (!scanout->ds) {
            cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;
            return;
        }
        pixman_image_unref(rect);
        dpy_gfx_replace_surface(g->scanout[ss.scanout_id].con, scanout->ds);
    }

    res->scanout_bitmask |= (1 << ss.scanout_id);
    scanout->resource_id = ss.resource_id;
    scanout->x = ss.r.x;
    scanout->y = ss.r.y;
    scanout->width = ss.r.width;
    scanout->height = ss.r.height;
}","static void virtio_gpu_set_scanout(VirtIOGPU *VAR_0,
                                   struct virtio_gpu_ctrl_command *VAR_1)
{
    struct virtio_gpu_simple_resource *VAR_2;
    struct virtio_gpu_scanout *VAR_3;
    pixman_format_code_t VAR_4;
    uint32_t VAR_5;
    int VAR_6;
    struct virtio_gpu_set_scanout VAR_7;

    VIRTIO_GPU_FILL_CMD(VAR_7);
    trace_virtio_gpu_cmd_set_scanout(VAR_7.scanout_id, VAR_7.resource_id,
                                     VAR_7.r.width, VAR_7.r.height, VAR_7.r.x, VAR_7.r.y);

    if (VAR_7.scanout_id >= VAR_0->conf.max_outputs) {
        qemu_log_mask(VAR_8, ""%s: illegal scanout id specified %d"",
                      VAR_9, VAR_7.scanout_id);
        VAR_1->error = VAR_10;
        return;
    }

    VAR_0->enable = 1;
    if (VAR_7.resource_id == 0) {
        VAR_3 = &VAR_0->scanout[VAR_7.scanout_id];
        if (VAR_3->resource_id) {
            VAR_2 = virtio_gpu_find_resource(VAR_0, VAR_3->resource_id);
            if (VAR_2) {
                VAR_2->scanout_bitmask &= ~(1 << VAR_7.scanout_id);
            }
        }
        if (VAR_7.scanout_id == 0) {
            qemu_log_mask(VAR_8,
                          ""%s: illegal scanout id specified %d"",
                          VAR_9, VAR_7.scanout_id);
            VAR_1->error = VAR_10;
            return;
        }
        dpy_gfx_replace_surface(VAR_0->scanout[VAR_7.scanout_id].con, NULL);
        VAR_3->ds = NULL;
        VAR_3->width = 0;
        VAR_3->height = 0;
        return;
    }

    /* COMMENT_0 */
    VAR_2 = virtio_gpu_find_resource(VAR_0, VAR_7.resource_id);
    if (!VAR_2) {
        qemu_log_mask(VAR_8, ""%s: illegal resource specified %d\n"",
                      VAR_9, VAR_7.resource_id);
        VAR_1->error = VAR_11;
        return;
    }

    if (VAR_7.r.x > VAR_2->width ||
        VAR_7.r.y > VAR_2->height ||
        VAR_7.r.width > VAR_2->width ||
        VAR_7.r.height > VAR_2->height ||
        VAR_7.r.x + VAR_7.r.width > VAR_2->width ||
        VAR_7.r.y + VAR_7.r.height > VAR_2->height) {
        qemu_log_mask(VAR_8, ""%s: illegal scanout %d bounds for""
                      "" resource %d, (%d,%d)+%d,%d vs %d %d\n"",
                      VAR_9, VAR_7.scanout_id, VAR_7.resource_id, VAR_7.r.x, VAR_7.r.y,
                      VAR_7.r.width, VAR_7.r.height, VAR_2->width, VAR_2->height);
        VAR_1->error = VAR_12;
        return;
    }

    VAR_3 = &VAR_0->scanout[VAR_7.scanout_id];

    VAR_4 = pixman_image_get_format(VAR_2->image);
    VAR_6 = (PIXMAN_FORMAT_BPP(VAR_4) + 7) / 8;
    VAR_5 = (VAR_7.r.x * VAR_6) + VAR_7.r.y * pixman_image_get_stride(VAR_2->image);
    if (!VAR_3->ds || surface_data(VAR_3->ds)
        != ((uint8_t *)pixman_image_get_data(VAR_2->image) + VAR_5) ||
        VAR_3->width != VAR_7.r.width ||
        VAR_3->height != VAR_7.r.height) {
        pixman_image_t *VAR_13;
        void *VAR_14 = (uint8_t *)pixman_image_get_data(VAR_2->image) + VAR_5;
        VAR_13 = pixman_image_create_bits(VAR_4, VAR_7.r.width, VAR_7.r.height, VAR_14,
                                        pixman_image_get_stride(VAR_2->image));
        pixman_image_ref(VAR_2->image);
        pixman_image_set_destroy_function(VAR_13, VAR_15,
                                          VAR_2->image);
        /* COMMENT_1 */
        VAR_3->ds = qemu_create_displaysurface_pixman(VAR_13);
        if (!VAR_3->ds) {
            VAR_1->error = VAR_16;
            return;
        }
        pixman_image_unref(VAR_13);
        dpy_gfx_replace_surface(VAR_0->scanout[VAR_7.scanout_id].con, VAR_3->ds);
    }

    VAR_2->scanout_bitmask |= (1 << VAR_7.scanout_id);
    VAR_3->resource_id = VAR_7.resource_id;
    VAR_3->x = VAR_7.r.x;
    VAR_3->y = VAR_7.r.y;
    VAR_3->width = VAR_7.r.width;
    VAR_3->height = VAR_7.r.height;
}",qemu/dd248ed7e204ee8a1873914e02b8b526e8f1b80d/virtio-gpu.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -87,6 +87,7 @@
             cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;
             return;
         }
+        pixman_image_unref(rect);
         dpy_gfx_replace_surface(g->scanout[ss.scanout_id].con, scanout->ds);
     }
 ","{'deleted_lines': [], 'added_lines': ['        pixman_image_unref(rect);']}",True,"Memory leak in the virtio_gpu_set_scanout function in hw/display/virtio-gpu.c in QEMU (aka Quick Emulator) allows local guest OS users to cause a denial of service (memory consumption) via a large number of ""VIRTIO_GPU_CMD_SET_SCANOUT:"" commands.",5.5,MEDIUM,1,test,2017-01-22T07:42:33Z,1
CVE-2017-5627,['CWE-190'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ArtifexSoftware/mujs,"Fix 697497: Ensure array length is positive.

As a side effect when changing to using regular integers (and avoid the
nightmare of mixing signed and unsigned) we accidentally allowed negative
array lengths.",4006739a28367c708dea19aeb19b8a1a9326ce08,https://github.com/ArtifexSoftware/mujs/commit/4006739a28367c708dea19aeb19b8a1a9326ce08,jsrun.c,jsR_setproperty,"static void jsR_setproperty(js_State *J, js_Object *obj, const char *name)
{
js_Value *value = stackidx(J, -1);
js_Property *ref;
int k;
int own;
if (obj->type == JS_CARRAY) {
if (!strcmp(name, ""length"")) {
double rawlen = jsV_tonumber(J, value);
int newlen = jsV_numbertointeger(rawlen);
if (newlen != rawlen)
js_rangeerror(J, ""array length"");
jsV_resizearray(J, obj, newlen);
return;
}
if (js_isarrayindex(J, name, &k))
if (k >= obj->u.a.length)
obj->u.a.length = k + 1;
}
else if (obj->type == JS_CSTRING) {
if (!strcmp(name, ""length""))
goto readonly;
if (js_isarrayindex(J, name, &k))
if (js_runeat(J, obj->u.s.string, k))
goto readonly;
}
else if (obj->type == JS_CREGEXP) {
if (!strcmp(name, ""source"")) goto readonly;
if (!strcmp(name, ""global"")) goto readonly;
if (!strcmp(name, ""ignoreCase"")) goto readonly;
if (!strcmp(name, ""multiline"")) goto readonly;
if (!strcmp(name, ""lastIndex"")) {
obj->u.r.last = jsV_tointeger(J, value);
return;
}
}
else if (obj->type == JS_CUSERDATA) {
if (obj->u.user.put && obj->u.user.put(J, obj->u.user.data, name))
return;
}
ref = jsV_getpropertyx(J, obj, name, &own);
if (ref && ref->setter) {
js_pushobject(J, ref->setter);
js_pushobject(J, obj);
js_pushvalue(J, *value);
js_call(J, 1);
js_pop(J, 1);
return;
}
if (!ref || !own)
ref = jsV_setproperty(J, obj, name);
if (ref) {
if (!(ref->atts & JS_READONLY))
ref->value = *value;
else
goto readonly;
}
return;
readonly:
if (J->strict)
js_typeerror(J, ""'%s' is read-only"", name);
}","static void jsR_setproperty(js_State *VAR_0, js_Object *VAR_1, const char *VAR_2)
{
js_Value *VAR_3 = stackidx(VAR_0, -1);
js_Property *VAR_4;
int VAR_5;
int VAR_6;
if (VAR_1->type == VAR_7) {
if (!strcmp(VAR_2, ""length"")) {
double VAR_8 = jsV_tonumber(VAR_0, VAR_3);
int VAR_9 = jsV_numbertointeger(VAR_8);
if (VAR_9 != VAR_8)
js_rangeerror(VAR_0, ""array length"");
jsV_resizearray(VAR_0, VAR_1, VAR_9);
return;
}
if (js_isarrayindex(VAR_0, VAR_2, &VAR_5))
if (VAR_5 >= VAR_1->u.a.length)
VAR_1->u.a.length = VAR_5 + 1;
}
else if (VAR_1->type == VAR_10) {
if (!strcmp(VAR_2, ""length""))
goto readonly;
if (js_isarrayindex(VAR_0, VAR_2, &VAR_5))
if (js_runeat(VAR_0, VAR_1->u.s.string, VAR_5))
goto readonly;
}
else if (VAR_1->type == VAR_11) {
if (!strcmp(VAR_2, ""source"")) goto readonly;
if (!strcmp(VAR_2, ""global"")) goto readonly;
if (!strcmp(VAR_2, ""ignoreCase"")) goto readonly;
if (!strcmp(VAR_2, ""multiline"")) goto readonly;
if (!strcmp(VAR_2, ""lastIndex"")) {
VAR_1->u.r.last = jsV_tointeger(VAR_0, VAR_3);
return;
}
}
else if (VAR_1->type == VAR_12) {
if (VAR_1->u.user.put && VAR_1->u.user.put(VAR_0, VAR_1->u.user.data, VAR_2))
return;
}
VAR_4 = jsV_getpropertyx(VAR_0, VAR_1, VAR_2, &VAR_6);
if (VAR_4 && VAR_4->setter) {
js_pushobject(VAR_0, VAR_4->setter);
js_pushobject(VAR_0, VAR_1);
js_pushvalue(VAR_0, *VAR_3);
js_call(VAR_0, 1);
js_pop(VAR_0, 1);
return;
}
if (!VAR_4 || !VAR_6)
VAR_4 = jsV_setproperty(VAR_0, VAR_1, VAR_2);
if (VAR_4) {
if (!(VAR_4->atts & VAR_13))
VAR_4->value = *VAR_3;
else
goto readonly;
}
return;
readonly:
if (VAR_0->strict)
js_typeerror(VAR_0, ""'%s' is read-only"", VAR_2);
}",ArtifexSoftware/mujs/4006739a28367c708dea19aeb19b8a1a9326ce08/jsrun.c/vul/before/0.json,"static void jsR_setproperty(js_State *J, js_Object *obj, const char *name)
{
	js_Value *value = stackidx(J, -1);
	js_Property *ref;
	int k;
	int own;

	if (obj->type == JS_CARRAY) {
		if (!strcmp(name, ""length"")) {
			double rawlen = jsV_tonumber(J, value);
			int newlen = jsV_numbertointeger(rawlen);
			if (newlen != rawlen || newlen < 0)
				js_rangeerror(J, ""array length"");
			jsV_resizearray(J, obj, newlen);
			return;
		}
		if (js_isarrayindex(J, name, &k))
			if (k >= obj->u.a.length)
				obj->u.a.length = k + 1;
	}

	else if (obj->type == JS_CSTRING) {
		if (!strcmp(name, ""length""))
			goto readonly;
		if (js_isarrayindex(J, name, &k))
			if (js_runeat(J, obj->u.s.string, k))
				goto readonly;
	}

	else if (obj->type == JS_CREGEXP) {
		if (!strcmp(name, ""source"")) goto readonly;
		if (!strcmp(name, ""global"")) goto readonly;
		if (!strcmp(name, ""ignoreCase"")) goto readonly;
		if (!strcmp(name, ""multiline"")) goto readonly;
		if (!strcmp(name, ""lastIndex"")) {
			obj->u.r.last = jsV_tointeger(J, value);
			return;
		}
	}

	else if (obj->type == JS_CUSERDATA) {
		if (obj->u.user.put && obj->u.user.put(J, obj->u.user.data, name))
			return;
	}

	/* First try to find a setter in prototype chain */
	ref = jsV_getpropertyx(J, obj, name, &own);
	if (ref && ref->setter) {
		js_pushobject(J, ref->setter);
		js_pushobject(J, obj);
		js_pushvalue(J, *value);
		js_call(J, 1);
		js_pop(J, 1);
		return;
	}

	/* Property not found on this object, so create one */
	if (!ref || !own)
		ref = jsV_setproperty(J, obj, name);

	if (ref) {
		if (!(ref->atts & JS_READONLY))
			ref->value = *value;
		else
			goto readonly;
	}

	return;

readonly:
	if (J->strict)
		js_typeerror(J, ""'%s' is read-only"", name);
}","static void jsR_setproperty(js_State *VAR_0, js_Object *VAR_1, const char *VAR_2)
{
	js_Value *VAR_3 = stackidx(VAR_0, -1);
	js_Property *VAR_4;
	int VAR_5;
	int VAR_6;

	if (VAR_1->type == VAR_7) {
		if (!strcmp(VAR_2, ""length"")) {
			double VAR_8 = jsV_tonumber(VAR_0, VAR_3);
			int VAR_9 = jsV_numbertointeger(VAR_8);
			if (VAR_9 != VAR_8 || VAR_9 < 0)
				js_rangeerror(VAR_0, ""array length"");
			jsV_resizearray(VAR_0, VAR_1, VAR_9);
			return;
		}
		if (js_isarrayindex(VAR_0, VAR_2, &VAR_5))
			if (VAR_5 >= VAR_1->u.a.length)
				VAR_1->u.a.length = VAR_5 + 1;
	}

	else if (VAR_1->type == VAR_10) {
		if (!strcmp(VAR_2, ""length""))
			goto readonly;
		if (js_isarrayindex(VAR_0, VAR_2, &VAR_5))
			if (js_runeat(VAR_0, VAR_1->u.s.string, VAR_5))
				goto readonly;
	}

	else if (VAR_1->type == VAR_11) {
		if (!strcmp(VAR_2, ""source"")) goto readonly;
		if (!strcmp(VAR_2, ""global"")) goto readonly;
		if (!strcmp(VAR_2, ""ignoreCase"")) goto readonly;
		if (!strcmp(VAR_2, ""multiline"")) goto readonly;
		if (!strcmp(VAR_2, ""lastIndex"")) {
			VAR_1->u.r.last = jsV_tointeger(VAR_0, VAR_3);
			return;
		}
	}

	else if (VAR_1->type == VAR_12) {
		if (VAR_1->u.user.put && VAR_1->u.user.put(VAR_0, VAR_1->u.user.data, VAR_2))
			return;
	}

	/* COMMENT_0 */
	VAR_4 = jsV_getpropertyx(VAR_0, VAR_1, VAR_2, &VAR_6);
	if (VAR_4 && VAR_4->setter) {
		js_pushobject(VAR_0, VAR_4->setter);
		js_pushobject(VAR_0, VAR_1);
		js_pushvalue(VAR_0, *VAR_3);
		js_call(VAR_0, 1);
		js_pop(VAR_0, 1);
		return;
	}

	/* COMMENT_1 */
	if (!VAR_4 || !VAR_6)
		VAR_4 = jsV_setproperty(VAR_0, VAR_1, VAR_2);

	if (VAR_4) {
		if (!(VAR_4->atts & VAR_13))
			VAR_4->value = *VAR_3;
		else
			goto readonly;
	}

	return;

readonly:
	if (VAR_0->strict)
		js_typeerror(VAR_0, ""'%s' is read-only"", VAR_2);
}",ArtifexSoftware/mujs/4006739a28367c708dea19aeb19b8a1a9326ce08/jsrun.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,7 +9,7 @@
 		if (!strcmp(name, ""length"")) {
 			double rawlen = jsV_tonumber(J, value);
 			int newlen = jsV_numbertointeger(rawlen);
-			if (newlen != rawlen)
+			if (newlen != rawlen || newlen < 0)
 				js_rangeerror(J, ""array length"");
 			jsV_resizearray(J, obj, newlen);
 			return;","{'deleted_lines': ['\t\t\tif (newlen != rawlen)'], 'added_lines': ['\t\t\tif (newlen != rawlen || newlen < 0)']}",True,"An issue was discovered in Artifex Software, Inc. MuJS before 4006739a28367c708dea19aeb19b8a1a9326ce08. The jsR_setproperty function in jsrun.c lacks a check for a negative array length. This leads to an integer overflow in the js_pushstring function in jsrun.c when parsing a specially crafted JS file.",7.8,HIGH,2,test,2017-01-24T13:42:36Z,1
CVE-2017-5668,['CWE-476'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,bitlbee,"purple: Fix crash on ft requests from unknown contacts

Followup to 701ab81 (included in 3.5) which was a partial fix which only
improved things for non-libpurple file transfers (that is, just jabber)",30d598ce7cd3f136ee9d7097f39fa9818a272441,https://github.com/bitlbee/bitlbee/commit/30d598ce7cd3f136ee9d7097f39fa9818a272441,protocols/purple/ft.c,prplcb_xfer_new_send_cb,"static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)
{
PurpleXfer *xfer = data;
struct im_connection *ic = purple_ic_by_pa(xfer->account);
struct prpl_xfer_data *px = xfer->ui_data;
PurpleBuddy *buddy;
const char *who;
buddy = purple_find_buddy(xfer->account, xfer->who);
who = buddy ? purple_buddy_get_name(buddy) : xfer->who;
px->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);
px->ft->data = px;
px->ft->accept = prpl_xfer_accept;
px->ft->canceled = prpl_xfer_canceled;
px->ft->free = prpl_xfer_free;
px->ft->write_request = prpl_xfer_write_request;
return FALSE;
}","static gboolean prplcb_xfer_new_send_cb(gpointer VAR_0, gint VAR_1, b_input_condition VAR_2)
{
PurpleXfer *VAR_3 = VAR_0;
struct im_connection *VAR_4 = purple_ic_by_pa(VAR_3->account);
struct prpl_xfer_data *VAR_5 = VAR_3->ui_data;
PurpleBuddy *VAR_6;
const char *VAR_7;
VAR_6 = purple_find_buddy(VAR_3->account, VAR_3->who);
VAR_7 = VAR_6 ? purple_buddy_get_name(VAR_6) : VAR_3->who;
VAR_5->ft = imcb_file_send_start(VAR_4, (char *) VAR_7, VAR_3->filename, VAR_3->size);
VAR_5->ft->data = VAR_5;
VAR_5->ft->accept = VAR_8;
VAR_5->ft->canceled = VAR_9;
VAR_5->ft->free = VAR_10;
VAR_5->ft->write_request = VAR_11;
return FALSE;
}",bitlbee/30d598ce7cd3f136ee9d7097f39fa9818a272441/ft.c/vul/before/0.json,"static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)
{
	PurpleXfer *xfer = data;
	struct im_connection *ic = purple_ic_by_pa(xfer->account);
	struct prpl_xfer_data *px = xfer->ui_data;
	PurpleBuddy *buddy;
	const char *who;

	buddy = purple_find_buddy(xfer->account, xfer->who);
	who = buddy ? purple_buddy_get_name(buddy) : xfer->who;

	/* TODO(wilmer): After spreading some more const goodness in BitlBee,
	   remove the evil cast below. */
	px->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);

	if (!px->ft) {
		return FALSE;
	}
	px->ft->data = px;

	px->ft->accept = prpl_xfer_accept;
	px->ft->canceled = prpl_xfer_canceled;
	px->ft->free = prpl_xfer_free;
	px->ft->write_request = prpl_xfer_write_request;

	return FALSE;
}","static gboolean prplcb_xfer_new_send_cb(gpointer VAR_0, gint VAR_1, b_input_condition VAR_2)
{
	PurpleXfer *VAR_3 = VAR_0;
	struct im_connection *VAR_4 = purple_ic_by_pa(VAR_3->account);
	struct prpl_xfer_data *VAR_5 = VAR_3->ui_data;
	PurpleBuddy *VAR_6;
	const char *VAR_7;

	VAR_6 = purple_find_buddy(VAR_3->account, VAR_3->who);
	VAR_7 = VAR_6 ? purple_buddy_get_name(VAR_6) : VAR_3->who;

	/* COMMENT_0 */
                                  
	VAR_5->ft = imcb_file_send_start(VAR_4, (char *) VAR_7, VAR_3->filename, VAR_3->size);

	if (!VAR_5->ft) {
		return FALSE;
	}
	VAR_5->ft->data = VAR_5;

	VAR_5->ft->accept = VAR_8;
	VAR_5->ft->canceled = VAR_9;
	VAR_5->ft->free = VAR_10;
	VAR_5->ft->write_request = VAR_11;

	return FALSE;
}",bitlbee/30d598ce7cd3f136ee9d7097f39fa9818a272441/ft.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,6 +12,10 @@
 	/* TODO(wilmer): After spreading some more const goodness in BitlBee,
 	   remove the evil cast below. */
 	px->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);
+
+	if (!px->ft) {
+		return FALSE;
+	}
 	px->ft->data = px;
 
 	px->ft->accept = prpl_xfer_accept;","{'deleted_lines': [], 'added_lines': ['', '\tif (!px->ft) {', '\t\treturn FALSE;', '\t}']}",True,bitlbee-libpurple before 3.5.1 allows remote attackers to cause a denial of service (NULL pointer dereference and crash) and possibly execute arbitrary code via a file transfer request for a contact that is not in the contact list.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-10189.,9.8,CRITICAL,3,test,2017-01-29T22:40:09Z,1
CVE-2017-12898,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-12898/NFS: Fix bounds checking.

Fix the bounds checking for the NFSv3 WRITE procedure to check whether the
length of the opaque data being written is present in the captured data,
not just whether the byte count is present in the captured data.
furthest forward in the packet, not the item before it.  (This also lets
us eliminate the check for the ""stable"" argument being present in the
captured data; rewrite the code to print that to make it a bit clearer.)

Check that the entire ar_stat field is present in the capture.

Note that parse_wcc_attr() is called after we've already checked whether
the wcc_data is present.

Check before fetching the ""access"" part of the NFSv3 ACCESS results.
This fixes a buffer over-read discovered by Kamil Frankowicz.

Include a test for the ""check before fetching the ""access"" part..."" fix,
using the capture supplied by the reporter(s).",19d25dd8781620cd41bf178a5e2e27fc1cf242d0,https://github.com/the-tcpdump-group/tcpdump/commit/19d25dd8781620cd41bf178a5e2e27fc1cf242d0,print-nfs.c,parserep,"static const uint32_t *
parserep(netdissect_options *ndo,
register const struct sunrpc_msg *rp, register u_int length)
{
register const uint32_t *dp;
u_int len;
enum sunrpc_accept_stat astat;
dp = ((const uint32_t *)&rp->rm_reply) + 1;
ND_TCHECK(dp[1]);
len = EXTRACT_32BITS(&dp[1]);
if (len >= length)
return (NULL);
dp += (len + (2*sizeof(uint32_t) + 3)) / sizeof(uint32_t);
ND_TCHECK2(dp[0], 0);
astat = (enum sunrpc_accept_stat) EXTRACT_32BITS(dp);
if (astat != SUNRPC_SUCCESS) {
ND_PRINT((ndo, "" %s"", tok2str(sunrpc_str, ""ar_stat %d"", astat)));
nfserr = 1;
return (NULL);
}
ND_TCHECK2(*dp, sizeof(astat));
return ((const uint32_t *) (sizeof(astat) + ((const char *)dp)));
trunc:
return (0);
}","static const uint32_t *
parserep(netdissect_options *VAR_0,
register const struct sunrpc_msg *VAR_1, register u_int VAR_2)
{
register const uint32_t *VAR_3;
u_int VAR_4;
enum sunrpc_accept_stat VAR_5;
VAR_3 = ((const uint32_t *)&VAR_1->rm_reply) + 1;
ND_TCHECK(VAR_3[1]);
VAR_4 = EXTRACT_32BITS(&VAR_3[1]);
if (VAR_4 >= VAR_2)
return (NULL);
VAR_3 += (VAR_4 + (2*sizeof(uint32_t) + 3)) / sizeof(uint32_t);
ND_TCHECK2(VAR_3[0], 0);
VAR_5 = (enum sunrpc_accept_stat) EXTRACT_32BITS(VAR_3);
if (VAR_5 != VAR_6) {
ND_PRINT((VAR_0, "" %s"", tok2str(VAR_7, ""ar_stat %d"", VAR_5)));
VAR_8 = 1;
return (NULL);
}
ND_TCHECK2(*VAR_3, sizeof(VAR_5));
return ((const uint32_t *) (sizeof(VAR_5) + ((const char *)VAR_3)));
trunc:
return (0);
}",the-tcpdump-group/tcpdump/19d25dd8781620cd41bf178a5e2e27fc1cf242d0/print-nfs.c/vul/before/0.json,"static const uint32_t *
parserep(netdissect_options *ndo,
         register const struct sunrpc_msg *rp, register u_int length)
{
	register const uint32_t *dp;
	u_int len;
	enum sunrpc_accept_stat astat;

	/*
	 * Portability note:
	 * Here we find the address of the ar_verf credentials.
	 * Originally, this calculation was
	 *	dp = (uint32_t *)&rp->rm_reply.rp_acpt.ar_verf
	 * On the wire, the rp_acpt field starts immediately after
	 * the (32 bit) rp_stat field.  However, rp_acpt (which is a
	 * ""struct accepted_reply"") contains a ""struct opaque_auth"",
	 * whose internal representation contains a pointer, so on a
	 * 64-bit machine the compiler inserts 32 bits of padding
	 * before rp->rm_reply.rp_acpt.ar_verf.  So, we cannot use
	 * the internal representation to parse the on-the-wire
	 * representation.  Instead, we skip past the rp_stat field,
	 * which is an ""enum"" and so occupies one 32-bit word.
	 */
	dp = ((const uint32_t *)&rp->rm_reply) + 1;
	ND_TCHECK(dp[1]);
	len = EXTRACT_32BITS(&dp[1]);
	if (len >= length)
		return (NULL);
	/*
	 * skip past the ar_verf credentials.
	 */
	dp += (len + (2*sizeof(uint32_t) + 3)) / sizeof(uint32_t);

	/*
	 * now we can check the ar_stat field
	 */
	ND_TCHECK(dp[0]);
	astat = (enum sunrpc_accept_stat) EXTRACT_32BITS(dp);
	if (astat != SUNRPC_SUCCESS) {
		ND_PRINT((ndo, "" %s"", tok2str(sunrpc_str, ""ar_stat %d"", astat)));
		nfserr = 1;		/* suppress trunc string */
		return (NULL);
	}
	/* successful return */
	ND_TCHECK2(*dp, sizeof(astat));
	return ((const uint32_t *) (sizeof(astat) + ((const char *)dp)));
trunc:
	return (0);
}","static const uint32_t *
parserep(netdissect_options *VAR_0,
         register const struct sunrpc_msg *VAR_1, register u_int VAR_2)
{
	register const uint32_t *VAR_3;
	u_int VAR_4;
	enum sunrpc_accept_stat VAR_5;

	/* COMMENT_0 */
                     
                                                        
                                    
                                                  
                                                           
                                                             
                                                             
                                                             
                                                          
                                                           
                                                        
                                                             
                                                       
    
	VAR_3 = ((const uint32_t *)&VAR_1->rm_reply) + 1;
	ND_TCHECK(VAR_3[1]);
	VAR_4 = EXTRACT_32BITS(&VAR_3[1]);
	if (VAR_4 >= VAR_2)
		return (NULL);
	/* COMMENT_15 */
                                      
    
	VAR_3 += (VAR_4 + (2*sizeof(uint32_t) + 3)) / sizeof(uint32_t);

	/* COMMENT_18 */
                                      
    
	ND_TCHECK(VAR_3[0]);
	VAR_5 = (enum sunrpc_accept_stat) EXTRACT_32BITS(VAR_3);
	if (VAR_5 != VAR_6) {
		ND_PRINT((VAR_0, "" %s"", tok2str(VAR_7, ""ar_stat %d"", VAR_5)));
		VAR_8 = 1;		/* COMMENT_21 */
		return (NULL);
	}
	/* COMMENT_22 */
	ND_TCHECK2(*VAR_3, sizeof(VAR_5));
	return ((const uint32_t *) (sizeof(VAR_5) + ((const char *)VAR_3)));
trunc:
	return (0);
}",the-tcpdump-group/tcpdump/19d25dd8781620cd41bf178a5e2e27fc1cf242d0/print-nfs.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -30,11 +30,11 @@
 	 * skip past the ar_verf credentials.
 	 */
 	dp += (len + (2*sizeof(uint32_t) + 3)) / sizeof(uint32_t);
-	ND_TCHECK2(dp[0], 0);
 
 	/*
 	 * now we can check the ar_stat field
 	 */
+	ND_TCHECK(dp[0]);
 	astat = (enum sunrpc_accept_stat) EXTRACT_32BITS(dp);
 	if (astat != SUNRPC_SUCCESS) {
 		ND_PRINT((ndo, "" %s"", tok2str(sunrpc_str, ""ar_stat %d"", astat)));","{'deleted_lines': ['\tND_TCHECK2(dp[0], 0);'], 'added_lines': ['\tND_TCHECK(dp[0]);']}",True,The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:interp_reply().,9.8,CRITICAL,3,test,2017-02-03T23:14:51Z,1
CVE-2017-12898,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-12898/NFS: Fix bounds checking.

Fix the bounds checking for the NFSv3 WRITE procedure to check whether the
length of the opaque data being written is present in the captured data,
not just whether the byte count is present in the captured data.
furthest forward in the packet, not the item before it.  (This also lets
us eliminate the check for the ""stable"" argument being present in the
captured data; rewrite the code to print that to make it a bit clearer.)

Check that the entire ar_stat field is present in the capture.

Note that parse_wcc_attr() is called after we've already checked whether
the wcc_data is present.

Check before fetching the ""access"" part of the NFSv3 ACCESS results.
This fixes a buffer over-read discovered by Kamil Frankowicz.

Include a test for the ""check before fetching the ""access"" part..."" fix,
using the capture supplied by the reporter(s).",19d25dd8781620cd41bf178a5e2e27fc1cf242d0,https://github.com/the-tcpdump-group/tcpdump/commit/19d25dd8781620cd41bf178a5e2e27fc1cf242d0,print-nfs.c,parse_wcc_attr,"static const uint32_t *
parse_wcc_attr(netdissect_options *ndo,
const uint32_t *dp)
{
ND_PRINT((ndo, "" sz %"" PRIu64, EXTRACT_64BITS(&dp[0])));
ND_PRINT((ndo, "" mtime %u.%06u ctime %u.%06u"",
EXTRACT_32BITS(&dp[2]), EXTRACT_32BITS(&dp[3]),
EXTRACT_32BITS(&dp[4]), EXTRACT_32BITS(&dp[5])));
return (dp + 6);
}","static const uint32_t *
parse_wcc_attr(netdissect_options *VAR_0,
const uint32_t *VAR_1)
{
ND_PRINT((VAR_0, "" sz %"" VAR_2, EXTRACT_64BITS(&VAR_1[0])));
ND_PRINT((VAR_0, "" mtime %u.%06u ctime %u.%06u"",
EXTRACT_32BITS(&VAR_1[2]), EXTRACT_32BITS(&VAR_1[3]),
EXTRACT_32BITS(&VAR_1[4]), EXTRACT_32BITS(&VAR_1[5])));
return (VAR_1 + 6);
}",the-tcpdump-group/tcpdump/19d25dd8781620cd41bf178a5e2e27fc1cf242d0/print-nfs.c/vul/before/1.json,"static const uint32_t *
parse_wcc_attr(netdissect_options *ndo,
               const uint32_t *dp)
{
	/* Our caller has already checked this */
	ND_PRINT((ndo, "" sz %"" PRIu64, EXTRACT_64BITS(&dp[0])));
	ND_PRINT((ndo, "" mtime %u.%06u ctime %u.%06u"",
	       EXTRACT_32BITS(&dp[2]), EXTRACT_32BITS(&dp[3]),
	       EXTRACT_32BITS(&dp[4]), EXTRACT_32BITS(&dp[5])));
	return (dp + 6);
}","static const uint32_t *
parse_wcc_attr(netdissect_options *VAR_0,
               const uint32_t *VAR_1)
{
	/* COMMENT_0 */
	ND_PRINT((VAR_0, "" sz %"" VAR_2, EXTRACT_64BITS(&VAR_1[0])));
	ND_PRINT((VAR_0, "" mtime %u.%06u ctime %u.%06u"",
	       EXTRACT_32BITS(&VAR_1[2]), EXTRACT_32BITS(&VAR_1[3]),
	       EXTRACT_32BITS(&VAR_1[4]), EXTRACT_32BITS(&VAR_1[5])));
	return (VAR_1 + 6);
}",the-tcpdump-group/tcpdump/19d25dd8781620cd41bf178a5e2e27fc1cf242d0/print-nfs.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,6 +2,7 @@
 parse_wcc_attr(netdissect_options *ndo,
                const uint32_t *dp)
 {
+	/* Our caller has already checked this */
 	ND_PRINT((ndo, "" sz %"" PRIu64, EXTRACT_64BITS(&dp[0])));
 	ND_PRINT((ndo, "" mtime %u.%06u ctime %u.%06u"",
 	       EXTRACT_32BITS(&dp[2]), EXTRACT_32BITS(&dp[3]),","{'deleted_lines': [], 'added_lines': ['\t/* Our caller has already checked this */']}",True,The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:interp_reply().,9.8,CRITICAL,3,test,2017-02-03T23:14:51Z,1
CVE-2017-12898,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-12898/NFS: Fix bounds checking.

Fix the bounds checking for the NFSv3 WRITE procedure to check whether the
length of the opaque data being written is present in the captured data,
not just whether the byte count is present in the captured data.
furthest forward in the packet, not the item before it.  (This also lets
us eliminate the check for the ""stable"" argument being present in the
captured data; rewrite the code to print that to make it a bit clearer.)

Check that the entire ar_stat field is present in the capture.

Note that parse_wcc_attr() is called after we've already checked whether
the wcc_data is present.

Check before fetching the ""access"" part of the NFSv3 ACCESS results.
This fixes a buffer over-read discovered by Kamil Frankowicz.

Include a test for the ""check before fetching the ""access"" part..."" fix,
using the capture supplied by the reporter(s).",19d25dd8781620cd41bf178a5e2e27fc1cf242d0,https://github.com/the-tcpdump-group/tcpdump/commit/19d25dd8781620cd41bf178a5e2e27fc1cf242d0,print-nfs.c,interp_reply,"static void
interp_reply(netdissect_options *ndo,
const struct sunrpc_msg *rp, uint32_t proc, uint32_t vers, int length)
{
register const uint32_t *dp;
register int v3;
int er;
v3 = (vers == NFS_VER3);
if (!v3 && proc < NFS_NPROCS)
proc = nfsv3_procid[proc];
ND_PRINT((ndo, "" %s"", tok2str(nfsproc_str, ""proc-%u"", proc)));
switch (proc) {
case NFSPROC_GETATTR:
dp = parserep(ndo, rp, length);
if (dp != NULL && parseattrstat(ndo, dp, !ndo->ndo_qflag, v3) != 0)
return;
break;
case NFSPROC_SETATTR:
if (!(dp = parserep(ndo, rp, length)))
return;
if (v3) {
if (parsewccres(ndo, dp, ndo->ndo_vflag))
return;
} else {
if (parseattrstat(ndo, dp, !ndo->ndo_qflag, 0) != 0)
return;
}
break;
case NFSPROC_LOOKUP:
if (!(dp = parserep(ndo, rp, length)))
break;
if (v3) {
if (!(dp = parsestatus(ndo, dp, &er)))
break;
if (er) {
if (ndo->ndo_vflag > 1) {
ND_PRINT((ndo, "" post dattr:""));
dp = parse_post_op_attr(ndo, dp, ndo->ndo_vflag);
}
} else {
if (!(dp = parsefh(ndo, dp, v3)))
break;
if ((dp = parse_post_op_attr(ndo, dp, ndo->ndo_vflag)) &&
ndo->ndo_vflag > 1) {
ND_PRINT((ndo, "" post dattr:""));
dp = parse_post_op_attr(ndo, dp, ndo->ndo_vflag);
}
}
if (dp)
return;
} else {
if (parsediropres(ndo, dp) != 0)
return;
}
break;
case NFSPROC_ACCESS:
if (!(dp = parserep(ndo, rp, length)))
break;
if (!(dp = parsestatus(ndo, dp, &er)))
break;
if (ndo->ndo_vflag)
ND_PRINT((ndo, "" attr:""));
if (!(dp = parse_post_op_attr(ndo, dp, ndo->ndo_vflag)))
break;
if (!er)
ND_PRINT((ndo, "" c %04x"", EXTRACT_32BITS(&dp[0])));
return;
case NFSPROC_READLINK:
dp = parserep(ndo, rp, length);
if (dp != NULL && parselinkres(ndo, dp, v3) != 0)
return;
break;
case NFSPROC_READ:
if (!(dp = parserep(ndo, rp, length)))
break;
if (v3) {
if (!(dp = parsestatus(ndo, dp, &er)))
break;
if (!(dp = parse_post_op_attr(ndo, dp, ndo->ndo_vflag)))
break;
if (er)
return;
if (ndo->ndo_vflag) {
ND_TCHECK(dp[1]);
ND_PRINT((ndo, "" %u bytes"", EXTRACT_32BITS(&dp[0])));
if (EXTRACT_32BITS(&dp[1]))
ND_PRINT((ndo, "" EOF""));
}
return;
} else {
if (parseattrstat(ndo, dp, ndo->ndo_vflag, 0) != 0)
return;
}
break;
case NFSPROC_WRITE:
if (!(dp = parserep(ndo, rp, length)))
break;
if (v3) {
if (!(dp = parsestatus(ndo, dp, &er)))
break;
if (!(dp = parse_wcc_data(ndo, dp, ndo->ndo_vflag)))
break;
if (er)
return;
if (ndo->ndo_vflag) {
ND_TCHECK(dp[0]);
ND_PRINT((ndo, "" %u bytes"", EXTRACT_32BITS(&dp[0])));
if (ndo->ndo_vflag > 1) {
ND_TCHECK(dp[1]);
ND_PRINT((ndo, "" <%s>"",
tok2str(nfsv3_writemodes,
NULL, EXTRACT_32BITS(&dp[1]))));
}
return;
}
} else {
if (parseattrstat(ndo, dp, ndo->ndo_vflag, v3) != 0)
return;
}
break;
case NFSPROC_CREATE:
case NFSPROC_MKDIR:
if (!(dp = parserep(ndo, rp, length)))
break;
if (v3) {
if (parsecreateopres(ndo, dp, ndo->ndo_vflag) != NULL)
return;
} else {
if (parsediropres(ndo, dp) != 0)
return;
}
break;
case NFSPROC_SYMLINK:
if (!(dp = parserep(ndo, rp, length)))
break;
if (v3) {
if (parsecreateopres(ndo, dp, ndo->ndo_vflag) != NULL)
return;
} else {
if (parsestatus(ndo, dp, &er) != NULL)
return;
}
break;
case NFSPROC_MKNOD:
if (!(dp = parserep(ndo, rp, length)))
break;
if (parsecreateopres(ndo, dp, ndo->ndo_vflag) != NULL)
return;
break;
case NFSPROC_REMOVE:
case NFSPROC_RMDIR:
if (!(dp = parserep(ndo, rp, length)))
break;
if (v3) {
if (parsewccres(ndo, dp, ndo->ndo_vflag))
return;
} else {
if (parsestatus(ndo, dp, &er) != NULL)
return;
}
break;
case NFSPROC_RENAME:
if (!(dp = parserep(ndo, rp, length)))
break;
if (v3) {
if (!(dp = parsestatus(ndo, dp, &er)))
break;
if (ndo->ndo_vflag) {
ND_PRINT((ndo, "" from:""));
if (!(dp = parse_wcc_data(ndo, dp, ndo->ndo_vflag)))
break;
ND_PRINT((ndo, "" to:""));
if (!(dp = parse_wcc_data(ndo, dp, ndo->ndo_vflag)))
break;
}
return;
} else {
if (parsestatus(ndo, dp, &er) != NULL)
return;
}
break;
case NFSPROC_LINK:
if (!(dp = parserep(ndo, rp, length)))
break;
if (v3) {
if (!(dp = parsestatus(ndo, dp, &er)))
break;
if (ndo->ndo_vflag) {
ND_PRINT((ndo, "" file POST:""));
if (!(dp = parse_post_op_attr(ndo, dp, ndo->ndo_vflag)))
break;
ND_PRINT((ndo, "" dir:""));
if (!(dp = parse_wcc_data(ndo, dp, ndo->ndo_vflag)))
break;
return;
}
} else {
if (parsestatus(ndo, dp, &er) != NULL)
return;
}
break;
case NFSPROC_READDIR:
if (!(dp = parserep(ndo, rp, length)))
break;
if (v3) {
if (parsev3rddirres(ndo, dp, ndo->ndo_vflag))
return;
} else {
if (parserddires(ndo, dp) != 0)
return;
}
break;
case NFSPROC_READDIRPLUS:
if (!(dp = parserep(ndo, rp, length)))
break;
if (parsev3rddirres(ndo, dp, ndo->ndo_vflag))
return;
break;
case NFSPROC_FSSTAT:
dp = parserep(ndo, rp, length);
if (dp != NULL && parsestatfs(ndo, dp, v3) != 0)
return;
break;
case NFSPROC_FSINFO:
dp = parserep(ndo, rp, length);
if (dp != NULL && parsefsinfo(ndo, dp) != 0)
return;
break;
case NFSPROC_PATHCONF:
dp = parserep(ndo, rp, length);
if (dp != NULL && parsepathconf(ndo, dp) != 0)
return;
break;
case NFSPROC_COMMIT:
dp = parserep(ndo, rp, length);
if (dp != NULL && parsewccres(ndo, dp, ndo->ndo_vflag) != 0)
return;
break;
default:
return;
}
trunc:
if (!nfserr)
ND_PRINT((ndo, ""%s"", tstr));
}","static void
interp_reply(netdissect_options *VAR_0,
const struct sunrpc_msg *VAR_1, uint32_t VAR_2, uint32_t VAR_3, int VAR_4)
{
register const uint32_t *VAR_5;
register int VAR_6;
int VAR_7;
VAR_6 = (VAR_3 == VAR_8);
if (!VAR_6 && VAR_2 < VAR_9)
VAR_2 = VAR_10[VAR_2];
ND_PRINT((VAR_0, "" %s"", tok2str(VAR_11, ""proc-%u"", VAR_2)));
switch (VAR_2) {
case VAR_12:
VAR_5 = parserep(VAR_0, VAR_1, VAR_4);
if (VAR_5 != NULL && parseattrstat(VAR_0, VAR_5, !VAR_0->ndo_qflag, VAR_6) != 0)
return;
break;
case VAR_13:
if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
return;
if (VAR_6) {
if (parsewccres(VAR_0, VAR_5, VAR_0->ndo_vflag))
return;
} else {
if (parseattrstat(VAR_0, VAR_5, !VAR_0->ndo_qflag, 0) != 0)
return;
}
break;
case VAR_14:
if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
break;
if (VAR_6) {
if (!(VAR_5 = parsestatus(VAR_0, VAR_5, &VAR_7)))
break;
if (VAR_7) {
if (VAR_0->ndo_vflag > 1) {
ND_PRINT((VAR_0, "" post dattr:""));
VAR_5 = parse_post_op_attr(VAR_0, VAR_5, VAR_0->ndo_vflag);
}
} else {
if (!(VAR_5 = parsefh(VAR_0, VAR_5, VAR_6)))
break;
if ((VAR_5 = parse_post_op_attr(VAR_0, VAR_5, VAR_0->ndo_vflag)) &&
VAR_0->ndo_vflag > 1) {
ND_PRINT((VAR_0, "" post dattr:""));
VAR_5 = parse_post_op_attr(VAR_0, VAR_5, VAR_0->ndo_vflag);
}
}
if (VAR_5)
return;
} else {
if (parsediropres(VAR_0, VAR_5) != 0)
return;
}
break;
case VAR_15:
if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
break;
if (!(VAR_5 = parsestatus(VAR_0, VAR_5, &VAR_7)))
break;
if (VAR_0->ndo_vflag)
ND_PRINT((VAR_0, "" attr:""));
if (!(VAR_5 = parse_post_op_attr(VAR_0, VAR_5, VAR_0->ndo_vflag)))
break;
if (!VAR_7)
ND_PRINT((VAR_0, "" c %04x"", EXTRACT_32BITS(&VAR_5[0])));
return;
case VAR_16:
VAR_5 = parserep(VAR_0, VAR_1, VAR_4);
if (VAR_5 != NULL && parselinkres(VAR_0, VAR_5, VAR_6) != 0)
return;
break;
case VAR_17:
if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
break;
if (VAR_6) {
if (!(VAR_5 = parsestatus(VAR_0, VAR_5, &VAR_7)))
break;
if (!(VAR_5 = parse_post_op_attr(VAR_0, VAR_5, VAR_0->ndo_vflag)))
break;
if (VAR_7)
return;
if (VAR_0->ndo_vflag) {
ND_TCHECK(VAR_5[1]);
ND_PRINT((VAR_0, "" %u bytes"", EXTRACT_32BITS(&VAR_5[0])));
if (EXTRACT_32BITS(&VAR_5[1]))
ND_PRINT((VAR_0, "" EOF""));
}
return;
} else {
if (parseattrstat(VAR_0, VAR_5, VAR_0->ndo_vflag, 0) != 0)
return;
}
break;
case VAR_18:
if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
break;
if (VAR_6) {
if (!(VAR_5 = parsestatus(VAR_0, VAR_5, &VAR_7)))
break;
if (!(VAR_5 = parse_wcc_data(VAR_0, VAR_5, VAR_0->ndo_vflag)))
break;
if (VAR_7)
return;
if (VAR_0->ndo_vflag) {
ND_TCHECK(VAR_5[0]);
ND_PRINT((VAR_0, "" %u bytes"", EXTRACT_32BITS(&VAR_5[0])));
if (VAR_0->ndo_vflag > 1) {
ND_TCHECK(VAR_5[1]);
ND_PRINT((VAR_0, "" <%s>"",
tok2str(VAR_19,
NULL, EXTRACT_32BITS(&VAR_5[1]))));
}
return;
}
} else {
if (parseattrstat(VAR_0, VAR_5, VAR_0->ndo_vflag, VAR_6) != 0)
return;
}
break;
case VAR_20:
case VAR_21:
if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
break;
if (VAR_6) {
if (parsecreateopres(VAR_0, VAR_5, VAR_0->ndo_vflag) != NULL)
return;
} else {
if (parsediropres(VAR_0, VAR_5) != 0)
return;
}
break;
case VAR_22:
if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
break;
if (VAR_6) {
if (parsecreateopres(VAR_0, VAR_5, VAR_0->ndo_vflag) != NULL)
return;
} else {
if (parsestatus(VAR_0, VAR_5, &VAR_7) != NULL)
return;
}
break;
case VAR_23:
if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
break;
if (parsecreateopres(VAR_0, VAR_5, VAR_0->ndo_vflag) != NULL)
return;
break;
case VAR_24:
case VAR_25:
if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
break;
if (VAR_6) {
if (parsewccres(VAR_0, VAR_5, VAR_0->ndo_vflag))
return;
} else {
if (parsestatus(VAR_0, VAR_5, &VAR_7) != NULL)
return;
}
break;
case VAR_26:
if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
break;
if (VAR_6) {
if (!(VAR_5 = parsestatus(VAR_0, VAR_5, &VAR_7)))
break;
if (VAR_0->ndo_vflag) {
ND_PRINT((VAR_0, "" from:""));
if (!(VAR_5 = parse_wcc_data(VAR_0, VAR_5, VAR_0->ndo_vflag)))
break;
ND_PRINT((VAR_0, "" to:""));
if (!(VAR_5 = parse_wcc_data(VAR_0, VAR_5, VAR_0->ndo_vflag)))
break;
}
return;
} else {
if (parsestatus(VAR_0, VAR_5, &VAR_7) != NULL)
return;
}
break;
case VAR_27:
if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
break;
if (VAR_6) {
if (!(VAR_5 = parsestatus(VAR_0, VAR_5, &VAR_7)))
break;
if (VAR_0->ndo_vflag) {
ND_PRINT((VAR_0, "" file POST:""));
if (!(VAR_5 = parse_post_op_attr(VAR_0, VAR_5, VAR_0->ndo_vflag)))
break;
ND_PRINT((VAR_0, "" dir:""));
if (!(VAR_5 = parse_wcc_data(VAR_0, VAR_5, VAR_0->ndo_vflag)))
break;
return;
}
} else {
if (parsestatus(VAR_0, VAR_5, &VAR_7) != NULL)
return;
}
break;
case VAR_28:
if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
break;
if (VAR_6) {
if (parsev3rddirres(VAR_0, VAR_5, VAR_0->ndo_vflag))
return;
} else {
if (parserddires(VAR_0, VAR_5) != 0)
return;
}
break;
case VAR_29:
if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
break;
if (parsev3rddirres(VAR_0, VAR_5, VAR_0->ndo_vflag))
return;
break;
case VAR_30:
VAR_5 = parserep(VAR_0, VAR_1, VAR_4);
if (VAR_5 != NULL && parsestatfs(VAR_0, VAR_5, VAR_6) != 0)
return;
break;
case VAR_31:
VAR_5 = parserep(VAR_0, VAR_1, VAR_4);
if (VAR_5 != NULL && parsefsinfo(VAR_0, VAR_5) != 0)
return;
break;
case VAR_32:
VAR_5 = parserep(VAR_0, VAR_1, VAR_4);
if (VAR_5 != NULL && parsepathconf(VAR_0, VAR_5) != 0)
return;
break;
case VAR_33:
VAR_5 = parserep(VAR_0, VAR_1, VAR_4);
if (VAR_5 != NULL && parsewccres(VAR_0, VAR_5, VAR_0->ndo_vflag) != 0)
return;
break;
default:
return;
}
trunc:
if (!VAR_34)
ND_PRINT((VAR_0, ""%s"", VAR_35));
}",the-tcpdump-group/tcpdump/19d25dd8781620cd41bf178a5e2e27fc1cf242d0/print-nfs.c/vul/before/3.json,"static void
interp_reply(netdissect_options *ndo,
             const struct sunrpc_msg *rp, uint32_t proc, uint32_t vers, int length)
{
	register const uint32_t *dp;
	register int v3;
	int er;

	v3 = (vers == NFS_VER3);

	if (!v3 && proc < NFS_NPROCS)
		proc = nfsv3_procid[proc];

	ND_PRINT((ndo, "" %s"", tok2str(nfsproc_str, ""proc-%u"", proc)));
	switch (proc) {

	case NFSPROC_GETATTR:
		dp = parserep(ndo, rp, length);
		if (dp != NULL && parseattrstat(ndo, dp, !ndo->ndo_qflag, v3) != 0)
			return;
		break;

	case NFSPROC_SETATTR:
		if (!(dp = parserep(ndo, rp, length)))
			return;
		if (v3) {
			if (parsewccres(ndo, dp, ndo->ndo_vflag))
				return;
		} else {
			if (parseattrstat(ndo, dp, !ndo->ndo_qflag, 0) != 0)
				return;
		}
		break;

	case NFSPROC_LOOKUP:
		if (!(dp = parserep(ndo, rp, length)))
			break;
		if (v3) {
			if (!(dp = parsestatus(ndo, dp, &er)))
				break;
			if (er) {
				if (ndo->ndo_vflag > 1) {
					ND_PRINT((ndo, "" post dattr:""));
					dp = parse_post_op_attr(ndo, dp, ndo->ndo_vflag);
				}
			} else {
				if (!(dp = parsefh(ndo, dp, v3)))
					break;
				if ((dp = parse_post_op_attr(ndo, dp, ndo->ndo_vflag)) &&
				    ndo->ndo_vflag > 1) {
					ND_PRINT((ndo, "" post dattr:""));
					dp = parse_post_op_attr(ndo, dp, ndo->ndo_vflag);
				}
			}
			if (dp)
				return;
		} else {
			if (parsediropres(ndo, dp) != 0)
				return;
		}
		break;

	case NFSPROC_ACCESS:
		if (!(dp = parserep(ndo, rp, length)))
			break;
		if (!(dp = parsestatus(ndo, dp, &er)))
			break;
		if (ndo->ndo_vflag)
			ND_PRINT((ndo, "" attr:""));
		if (!(dp = parse_post_op_attr(ndo, dp, ndo->ndo_vflag)))
			break;
		if (!er) {
			ND_TCHECK(dp[0]);
			ND_PRINT((ndo, "" c %04x"", EXTRACT_32BITS(&dp[0])));
		}
		return;

	case NFSPROC_READLINK:
		dp = parserep(ndo, rp, length);
		if (dp != NULL && parselinkres(ndo, dp, v3) != 0)
			return;
		break;

	case NFSPROC_READ:
		if (!(dp = parserep(ndo, rp, length)))
			break;
		if (v3) {
			if (!(dp = parsestatus(ndo, dp, &er)))
				break;
			if (!(dp = parse_post_op_attr(ndo, dp, ndo->ndo_vflag)))
				break;
			if (er)
				return;
			if (ndo->ndo_vflag) {
				ND_TCHECK(dp[1]);
				ND_PRINT((ndo, "" %u bytes"", EXTRACT_32BITS(&dp[0])));
				if (EXTRACT_32BITS(&dp[1]))
					ND_PRINT((ndo, "" EOF""));
			}
			return;
		} else {
			if (parseattrstat(ndo, dp, ndo->ndo_vflag, 0) != 0)
				return;
		}
		break;

	case NFSPROC_WRITE:
		if (!(dp = parserep(ndo, rp, length)))
			break;
		if (v3) {
			if (!(dp = parsestatus(ndo, dp, &er)))
				break;
			if (!(dp = parse_wcc_data(ndo, dp, ndo->ndo_vflag)))
				break;
			if (er)
				return;
			if (ndo->ndo_vflag) {
				ND_TCHECK(dp[0]);
				ND_PRINT((ndo, "" %u bytes"", EXTRACT_32BITS(&dp[0])));
				if (ndo->ndo_vflag > 1) {
					ND_TCHECK(dp[1]);
					ND_PRINT((ndo, "" <%s>"",
						tok2str(nfsv3_writemodes,
							NULL, EXTRACT_32BITS(&dp[1]))));
				}
				return;
			}
		} else {
			if (parseattrstat(ndo, dp, ndo->ndo_vflag, v3) != 0)
				return;
		}
		break;

	case NFSPROC_CREATE:
	case NFSPROC_MKDIR:
		if (!(dp = parserep(ndo, rp, length)))
			break;
		if (v3) {
			if (parsecreateopres(ndo, dp, ndo->ndo_vflag) != NULL)
				return;
		} else {
			if (parsediropres(ndo, dp) != 0)
				return;
		}
		break;

	case NFSPROC_SYMLINK:
		if (!(dp = parserep(ndo, rp, length)))
			break;
		if (v3) {
			if (parsecreateopres(ndo, dp, ndo->ndo_vflag) != NULL)
				return;
		} else {
			if (parsestatus(ndo, dp, &er) != NULL)
				return;
		}
		break;

	case NFSPROC_MKNOD:
		if (!(dp = parserep(ndo, rp, length)))
			break;
		if (parsecreateopres(ndo, dp, ndo->ndo_vflag) != NULL)
			return;
		break;

	case NFSPROC_REMOVE:
	case NFSPROC_RMDIR:
		if (!(dp = parserep(ndo, rp, length)))
			break;
		if (v3) {
			if (parsewccres(ndo, dp, ndo->ndo_vflag))
				return;
		} else {
			if (parsestatus(ndo, dp, &er) != NULL)
				return;
		}
		break;

	case NFSPROC_RENAME:
		if (!(dp = parserep(ndo, rp, length)))
			break;
		if (v3) {
			if (!(dp = parsestatus(ndo, dp, &er)))
				break;
			if (ndo->ndo_vflag) {
				ND_PRINT((ndo, "" from:""));
				if (!(dp = parse_wcc_data(ndo, dp, ndo->ndo_vflag)))
					break;
				ND_PRINT((ndo, "" to:""));
				if (!(dp = parse_wcc_data(ndo, dp, ndo->ndo_vflag)))
					break;
			}
			return;
		} else {
			if (parsestatus(ndo, dp, &er) != NULL)
				return;
		}
		break;

	case NFSPROC_LINK:
		if (!(dp = parserep(ndo, rp, length)))
			break;
		if (v3) {
			if (!(dp = parsestatus(ndo, dp, &er)))
				break;
			if (ndo->ndo_vflag) {
				ND_PRINT((ndo, "" file POST:""));
				if (!(dp = parse_post_op_attr(ndo, dp, ndo->ndo_vflag)))
					break;
				ND_PRINT((ndo, "" dir:""));
				if (!(dp = parse_wcc_data(ndo, dp, ndo->ndo_vflag)))
					break;
				return;
			}
		} else {
			if (parsestatus(ndo, dp, &er) != NULL)
				return;
		}
		break;

	case NFSPROC_READDIR:
		if (!(dp = parserep(ndo, rp, length)))
			break;
		if (v3) {
			if (parsev3rddirres(ndo, dp, ndo->ndo_vflag))
				return;
		} else {
			if (parserddires(ndo, dp) != 0)
				return;
		}
		break;

	case NFSPROC_READDIRPLUS:
		if (!(dp = parserep(ndo, rp, length)))
			break;
		if (parsev3rddirres(ndo, dp, ndo->ndo_vflag))
			return;
		break;

	case NFSPROC_FSSTAT:
		dp = parserep(ndo, rp, length);
		if (dp != NULL && parsestatfs(ndo, dp, v3) != 0)
			return;
		break;

	case NFSPROC_FSINFO:
		dp = parserep(ndo, rp, length);
		if (dp != NULL && parsefsinfo(ndo, dp) != 0)
			return;
		break;

	case NFSPROC_PATHCONF:
		dp = parserep(ndo, rp, length);
		if (dp != NULL && parsepathconf(ndo, dp) != 0)
			return;
		break;

	case NFSPROC_COMMIT:
		dp = parserep(ndo, rp, length);
		if (dp != NULL && parsewccres(ndo, dp, ndo->ndo_vflag) != 0)
			return;
		break;

	default:
		return;
	}
trunc:
	if (!nfserr)
		ND_PRINT((ndo, ""%s"", tstr));
}","static void
interp_reply(netdissect_options *VAR_0,
             const struct sunrpc_msg *VAR_1, uint32_t VAR_2, uint32_t VAR_3, int VAR_4)
{
	register const uint32_t *VAR_5;
	register int VAR_6;
	int VAR_7;

	VAR_6 = (VAR_3 == VAR_8);

	if (!VAR_6 && VAR_2 < VAR_9)
		VAR_2 = VAR_10[VAR_2];

	ND_PRINT((VAR_0, "" %s"", tok2str(VAR_11, ""proc-%u"", VAR_2)));
	switch (VAR_2) {

	case VAR_12:
		VAR_5 = parserep(VAR_0, VAR_1, VAR_4);
		if (VAR_5 != NULL && parseattrstat(VAR_0, VAR_5, !VAR_0->ndo_qflag, VAR_6) != 0)
			return;
		break;

	case VAR_13:
		if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
			return;
		if (VAR_6) {
			if (parsewccres(VAR_0, VAR_5, VAR_0->ndo_vflag))
				return;
		} else {
			if (parseattrstat(VAR_0, VAR_5, !VAR_0->ndo_qflag, 0) != 0)
				return;
		}
		break;

	case VAR_14:
		if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
			break;
		if (VAR_6) {
			if (!(VAR_5 = parsestatus(VAR_0, VAR_5, &VAR_7)))
				break;
			if (VAR_7) {
				if (VAR_0->ndo_vflag > 1) {
					ND_PRINT((VAR_0, "" post dattr:""));
					VAR_5 = parse_post_op_attr(VAR_0, VAR_5, VAR_0->ndo_vflag);
				}
			} else {
				if (!(VAR_5 = parsefh(VAR_0, VAR_5, VAR_6)))
					break;
				if ((VAR_5 = parse_post_op_attr(VAR_0, VAR_5, VAR_0->ndo_vflag)) &&
				    VAR_0->ndo_vflag > 1) {
					ND_PRINT((VAR_0, "" post dattr:""));
					VAR_5 = parse_post_op_attr(VAR_0, VAR_5, VAR_0->ndo_vflag);
				}
			}
			if (VAR_5)
				return;
		} else {
			if (parsediropres(VAR_0, VAR_5) != 0)
				return;
		}
		break;

	case VAR_15:
		if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
			break;
		if (!(VAR_5 = parsestatus(VAR_0, VAR_5, &VAR_7)))
			break;
		if (VAR_0->ndo_vflag)
			ND_PRINT((VAR_0, "" attr:""));
		if (!(VAR_5 = parse_post_op_attr(VAR_0, VAR_5, VAR_0->ndo_vflag)))
			break;
		if (!VAR_7) {
			ND_TCHECK(VAR_5[0]);
			ND_PRINT((VAR_0, "" c %04x"", EXTRACT_32BITS(&VAR_5[0])));
		}
		return;

	case VAR_16:
		VAR_5 = parserep(VAR_0, VAR_1, VAR_4);
		if (VAR_5 != NULL && parselinkres(VAR_0, VAR_5, VAR_6) != 0)
			return;
		break;

	case VAR_17:
		if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
			break;
		if (VAR_6) {
			if (!(VAR_5 = parsestatus(VAR_0, VAR_5, &VAR_7)))
				break;
			if (!(VAR_5 = parse_post_op_attr(VAR_0, VAR_5, VAR_0->ndo_vflag)))
				break;
			if (VAR_7)
				return;
			if (VAR_0->ndo_vflag) {
				ND_TCHECK(VAR_5[1]);
				ND_PRINT((VAR_0, "" %u bytes"", EXTRACT_32BITS(&VAR_5[0])));
				if (EXTRACT_32BITS(&VAR_5[1]))
					ND_PRINT((VAR_0, "" EOF""));
			}
			return;
		} else {
			if (parseattrstat(VAR_0, VAR_5, VAR_0->ndo_vflag, 0) != 0)
				return;
		}
		break;

	case VAR_18:
		if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
			break;
		if (VAR_6) {
			if (!(VAR_5 = parsestatus(VAR_0, VAR_5, &VAR_7)))
				break;
			if (!(VAR_5 = parse_wcc_data(VAR_0, VAR_5, VAR_0->ndo_vflag)))
				break;
			if (VAR_7)
				return;
			if (VAR_0->ndo_vflag) {
				ND_TCHECK(VAR_5[0]);
				ND_PRINT((VAR_0, "" %u bytes"", EXTRACT_32BITS(&VAR_5[0])));
				if (VAR_0->ndo_vflag > 1) {
					ND_TCHECK(VAR_5[1]);
					ND_PRINT((VAR_0, "" <%s>"",
						tok2str(VAR_19,
							NULL, EXTRACT_32BITS(&VAR_5[1]))));
				}
				return;
			}
		} else {
			if (parseattrstat(VAR_0, VAR_5, VAR_0->ndo_vflag, VAR_6) != 0)
				return;
		}
		break;

	case VAR_20:
	case VAR_21:
		if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
			break;
		if (VAR_6) {
			if (parsecreateopres(VAR_0, VAR_5, VAR_0->ndo_vflag) != NULL)
				return;
		} else {
			if (parsediropres(VAR_0, VAR_5) != 0)
				return;
		}
		break;

	case VAR_22:
		if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
			break;
		if (VAR_6) {
			if (parsecreateopres(VAR_0, VAR_5, VAR_0->ndo_vflag) != NULL)
				return;
		} else {
			if (parsestatus(VAR_0, VAR_5, &VAR_7) != NULL)
				return;
		}
		break;

	case VAR_23:
		if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
			break;
		if (parsecreateopres(VAR_0, VAR_5, VAR_0->ndo_vflag) != NULL)
			return;
		break;

	case VAR_24:
	case VAR_25:
		if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
			break;
		if (VAR_6) {
			if (parsewccres(VAR_0, VAR_5, VAR_0->ndo_vflag))
				return;
		} else {
			if (parsestatus(VAR_0, VAR_5, &VAR_7) != NULL)
				return;
		}
		break;

	case VAR_26:
		if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
			break;
		if (VAR_6) {
			if (!(VAR_5 = parsestatus(VAR_0, VAR_5, &VAR_7)))
				break;
			if (VAR_0->ndo_vflag) {
				ND_PRINT((VAR_0, "" from:""));
				if (!(VAR_5 = parse_wcc_data(VAR_0, VAR_5, VAR_0->ndo_vflag)))
					break;
				ND_PRINT((VAR_0, "" to:""));
				if (!(VAR_5 = parse_wcc_data(VAR_0, VAR_5, VAR_0->ndo_vflag)))
					break;
			}
			return;
		} else {
			if (parsestatus(VAR_0, VAR_5, &VAR_7) != NULL)
				return;
		}
		break;

	case VAR_27:
		if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
			break;
		if (VAR_6) {
			if (!(VAR_5 = parsestatus(VAR_0, VAR_5, &VAR_7)))
				break;
			if (VAR_0->ndo_vflag) {
				ND_PRINT((VAR_0, "" file POST:""));
				if (!(VAR_5 = parse_post_op_attr(VAR_0, VAR_5, VAR_0->ndo_vflag)))
					break;
				ND_PRINT((VAR_0, "" dir:""));
				if (!(VAR_5 = parse_wcc_data(VAR_0, VAR_5, VAR_0->ndo_vflag)))
					break;
				return;
			}
		} else {
			if (parsestatus(VAR_0, VAR_5, &VAR_7) != NULL)
				return;
		}
		break;

	case VAR_28:
		if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
			break;
		if (VAR_6) {
			if (parsev3rddirres(VAR_0, VAR_5, VAR_0->ndo_vflag))
				return;
		} else {
			if (parserddires(VAR_0, VAR_5) != 0)
				return;
		}
		break;

	case VAR_29:
		if (!(VAR_5 = parserep(VAR_0, VAR_1, VAR_4)))
			break;
		if (parsev3rddirres(VAR_0, VAR_5, VAR_0->ndo_vflag))
			return;
		break;

	case VAR_30:
		VAR_5 = parserep(VAR_0, VAR_1, VAR_4);
		if (VAR_5 != NULL && parsestatfs(VAR_0, VAR_5, VAR_6) != 0)
			return;
		break;

	case VAR_31:
		VAR_5 = parserep(VAR_0, VAR_1, VAR_4);
		if (VAR_5 != NULL && parsefsinfo(VAR_0, VAR_5) != 0)
			return;
		break;

	case VAR_32:
		VAR_5 = parserep(VAR_0, VAR_1, VAR_4);
		if (VAR_5 != NULL && parsepathconf(VAR_0, VAR_5) != 0)
			return;
		break;

	case VAR_33:
		VAR_5 = parserep(VAR_0, VAR_1, VAR_4);
		if (VAR_5 != NULL && parsewccres(VAR_0, VAR_5, VAR_0->ndo_vflag) != 0)
			return;
		break;

	default:
		return;
	}
trunc:
	if (!VAR_34)
		ND_PRINT((VAR_0, ""%s"", VAR_35));
}",the-tcpdump-group/tcpdump/19d25dd8781620cd41bf178a5e2e27fc1cf242d0/print-nfs.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -69,8 +69,10 @@
 			ND_PRINT((ndo, "" attr:""));
 		if (!(dp = parse_post_op_attr(ndo, dp, ndo->ndo_vflag)))
 			break;
-		if (!er)
+		if (!er) {
+			ND_TCHECK(dp[0]);
 			ND_PRINT((ndo, "" c %04x"", EXTRACT_32BITS(&dp[0])));
+		}
 		return;
 
 	case NFSPROC_READLINK:","{'deleted_lines': ['\t\tif (!er)'], 'added_lines': ['\t\tif (!er) {', '\t\t\tND_TCHECK(dp[0]);', '\t\t}']}",True,The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:interp_reply().,9.8,CRITICAL,3,test,2017-02-03T23:14:51Z,1
CVE-2017-12898,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-12898/NFS: Fix bounds checking.

Fix the bounds checking for the NFSv3 WRITE procedure to check whether the
length of the opaque data being written is present in the captured data,
not just whether the byte count is present in the captured data.
furthest forward in the packet, not the item before it.  (This also lets
us eliminate the check for the ""stable"" argument being present in the
captured data; rewrite the code to print that to make it a bit clearer.)

Check that the entire ar_stat field is present in the capture.

Note that parse_wcc_attr() is called after we've already checked whether
the wcc_data is present.

Check before fetching the ""access"" part of the NFSv3 ACCESS results.
This fixes a buffer over-read discovered by Kamil Frankowicz.

Include a test for the ""check before fetching the ""access"" part..."" fix,
using the capture supplied by the reporter(s).",19d25dd8781620cd41bf178a5e2e27fc1cf242d0,https://github.com/the-tcpdump-group/tcpdump/commit/19d25dd8781620cd41bf178a5e2e27fc1cf242d0,print-nfs.c,nfsreq_print_noaddr,"void
nfsreq_print_noaddr(netdissect_options *ndo,
register const u_char *bp, u_int length,
register const u_char *bp2)
{
register const struct sunrpc_msg *rp;
register const uint32_t *dp;
nfs_type type;
int v3;
uint32_t proc;
uint32_t access_flags;
struct nfsv3_sattr sa3;
ND_PRINT((ndo, ""%d"", length));
nfserr = 0;
rp = (const struct sunrpc_msg *)bp;
if (!xid_map_enter(ndo, rp, bp2))
goto trunc;
v3 = (EXTRACT_32BITS(&rp->rm_call.cb_vers) == NFS_VER3);
proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);
if (!v3 && proc < NFS_NPROCS)
proc =  nfsv3_procid[proc];
ND_PRINT((ndo, "" %s"", tok2str(nfsproc_str, ""proc-%u"", proc)));
switch (proc) {
case NFSPROC_GETATTR:
case NFSPROC_SETATTR:
case NFSPROC_READLINK:
case NFSPROC_FSSTAT:
case NFSPROC_FSINFO:
case NFSPROC_PATHCONF:
if ((dp = parsereq(ndo, rp, length)) != NULL &&
parsefh(ndo, dp, v3) != NULL)
return;
break;
case NFSPROC_LOOKUP:
case NFSPROC_CREATE:
case NFSPROC_MKDIR:
case NFSPROC_REMOVE:
case NFSPROC_RMDIR:
if ((dp = parsereq(ndo, rp, length)) != NULL &&
parsefhn(ndo, dp, v3) != NULL)
return;
break;
case NFSPROC_ACCESS:
if ((dp = parsereq(ndo, rp, length)) != NULL &&
(dp = parsefh(ndo, dp, v3)) != NULL) {
ND_TCHECK(dp[0]);
access_flags = EXTRACT_32BITS(&dp[0]);
if (access_flags & ~NFSV3ACCESS_FULL) {
ND_PRINT((ndo, "" %04x"", access_flags));
} else if ((access_flags & NFSV3ACCESS_FULL) == NFSV3ACCESS_FULL) {
ND_PRINT((ndo, "" NFS_ACCESS_FULL""));
} else {
char separator = ' ';
if (access_flags & NFSV3ACCESS_READ) {
ND_PRINT((ndo, "" NFS_ACCESS_READ""));
separator = '|';
}
if (access_flags & NFSV3ACCESS_LOOKUP) {
ND_PRINT((ndo, ""%cNFS_ACCESS_LOOKUP"", separator));
separator = '|';
}
if (access_flags & NFSV3ACCESS_MODIFY) {
ND_PRINT((ndo, ""%cNFS_ACCESS_MODIFY"", separator));
separator = '|';
}
if (access_flags & NFSV3ACCESS_EXTEND) {
ND_PRINT((ndo, ""%cNFS_ACCESS_EXTEND"", separator));
separator = '|';
}
if (access_flags & NFSV3ACCESS_DELETE) {
ND_PRINT((ndo, ""%cNFS_ACCESS_DELETE"", separator));
separator = '|';
}
if (access_flags & NFSV3ACCESS_EXECUTE)
ND_PRINT((ndo, ""%cNFS_ACCESS_EXECUTE"", separator));
}
return;
}
break;
case NFSPROC_READ:
if ((dp = parsereq(ndo, rp, length)) != NULL &&
(dp = parsefh(ndo, dp, v3)) != NULL) {
if (v3) {
ND_TCHECK(dp[2]);
ND_PRINT((ndo, "" %u bytes @ %"" PRIu64,
EXTRACT_32BITS(&dp[2]),
EXTRACT_64BITS(&dp[0])));
} else {
ND_TCHECK(dp[1]);
ND_PRINT((ndo, "" %u bytes @ %u"",
EXTRACT_32BITS(&dp[1]),
EXTRACT_32BITS(&dp[0])));
}
return;
}
break;
case NFSPROC_WRITE:
if ((dp = parsereq(ndo, rp, length)) != NULL &&
(dp = parsefh(ndo, dp, v3)) != NULL) {
if (v3) {
ND_TCHECK(dp[2]);
ND_PRINT((ndo, "" %u (%u) bytes @ %"" PRIu64,
EXTRACT_32BITS(&dp[4]),
EXTRACT_32BITS(&dp[2]),
EXTRACT_64BITS(&dp[0])));
if (ndo->ndo_vflag) {
dp += 3;
ND_TCHECK(dp[0]);
ND_PRINT((ndo, "" <%s>"",
tok2str(nfsv3_writemodes,
NULL, EXTRACT_32BITS(dp))));
}
} else {
ND_TCHECK(dp[3]);
ND_PRINT((ndo, "" %u (%u) bytes @ %u (%u)"",
EXTRACT_32BITS(&dp[3]),
EXTRACT_32BITS(&dp[2]),
EXTRACT_32BITS(&dp[1]),
EXTRACT_32BITS(&dp[0])));
}
return;
}
break;
case NFSPROC_SYMLINK:
if ((dp = parsereq(ndo, rp, length)) != NULL &&
(dp = parsefhn(ndo, dp, v3)) != NULL) {
ND_PRINT((ndo, "" ->""));
if (v3 && (dp = parse_sattr3(ndo, dp, &sa3)) == NULL)
break;
if (parsefn(ndo, dp) == NULL)
break;
if (v3 && ndo->ndo_vflag)
print_sattr3(ndo, &sa3, ndo->ndo_vflag);
return;
}
break;
case NFSPROC_MKNOD:
if ((dp = parsereq(ndo, rp, length)) != NULL &&
(dp = parsefhn(ndo, dp, v3)) != NULL) {
ND_TCHECK(*dp);
type = (nfs_type)EXTRACT_32BITS(dp);
dp++;
if ((dp = parse_sattr3(ndo, dp, &sa3)) == NULL)
break;
ND_PRINT((ndo, "" %s"", tok2str(type2str, ""unk-ft %d"", type)));
if (ndo->ndo_vflag && (type == NFCHR || type == NFBLK)) {
ND_TCHECK(dp[1]);
ND_PRINT((ndo, "" %u/%u"",
EXTRACT_32BITS(&dp[0]),
EXTRACT_32BITS(&dp[1])));
dp += 2;
}
if (ndo->ndo_vflag)
print_sattr3(ndo, &sa3, ndo->ndo_vflag);
return;
}
break;
case NFSPROC_RENAME:
if ((dp = parsereq(ndo, rp, length)) != NULL &&
(dp = parsefhn(ndo, dp, v3)) != NULL) {
ND_PRINT((ndo, "" ->""));
if (parsefhn(ndo, dp, v3) != NULL)
return;
}
break;
case NFSPROC_LINK:
if ((dp = parsereq(ndo, rp, length)) != NULL &&
(dp = parsefh(ndo, dp, v3)) != NULL) {
ND_PRINT((ndo, "" ->""));
if (parsefhn(ndo, dp, v3) != NULL)
return;
}
break;
case NFSPROC_READDIR:
if ((dp = parsereq(ndo, rp, length)) != NULL &&
(dp = parsefh(ndo, dp, v3)) != NULL) {
if (v3) {
ND_TCHECK(dp[4]);
ND_PRINT((ndo, "" %u bytes @ %"" PRId64,
EXTRACT_32BITS(&dp[4]),
EXTRACT_64BITS(&dp[0])));
if (ndo->ndo_vflag)
ND_PRINT((ndo, "" verf %08x%08x"", dp[2], dp[3]));
} else {
ND_TCHECK(dp[1]);
ND_PRINT((ndo, "" %u bytes @ %d"",
EXTRACT_32BITS(&dp[1]),
EXTRACT_32BITS(&dp[0])));
}
return;
}
break;
case NFSPROC_READDIRPLUS:
if ((dp = parsereq(ndo, rp, length)) != NULL &&
(dp = parsefh(ndo, dp, v3)) != NULL) {
ND_TCHECK(dp[4]);
ND_PRINT((ndo, "" %u bytes @ %"" PRId64,
EXTRACT_32BITS(&dp[4]),
EXTRACT_64BITS(&dp[0])));
if (ndo->ndo_vflag) {
ND_TCHECK(dp[5]);
ND_PRINT((ndo, "" max %u verf %08x%08x"",
EXTRACT_32BITS(&dp[5]), dp[2], dp[3]));
}
return;
}
break;
case NFSPROC_COMMIT:
if ((dp = parsereq(ndo, rp, length)) != NULL &&
(dp = parsefh(ndo, dp, v3)) != NULL) {
ND_TCHECK(dp[2]);
ND_PRINT((ndo, "" %u bytes @ %"" PRIu64,
EXTRACT_32BITS(&dp[2]),
EXTRACT_64BITS(&dp[0])));
return;
}
break;
default:
return;
}
trunc:
if (!nfserr)
ND_PRINT((ndo, ""%s"", tstr));
}","void
nfsreq_print_noaddr(netdissect_options *VAR_0,
register const u_char *VAR_1, u_int VAR_2,
register const u_char *VAR_3)
{
register const struct sunrpc_msg *VAR_4;
register const uint32_t *VAR_5;
nfs_type VAR_6;
int VAR_7;
uint32_t VAR_8;
uint32_t VAR_9;
struct nfsv3_sattr VAR_10;
ND_PRINT((VAR_0, ""%d"", VAR_2));
VAR_11 = 0;
VAR_4 = (const struct sunrpc_msg *)VAR_1;
if (!xid_map_enter(VAR_0, VAR_4, VAR_3))
goto trunc;
VAR_7 = (EXTRACT_32BITS(&VAR_4->rm_call.cb_vers) == VAR_12);
VAR_8 = EXTRACT_32BITS(&VAR_4->rm_call.cb_proc);
if (!VAR_7 && VAR_8 < VAR_13)
VAR_8 =  VAR_14[VAR_8];
ND_PRINT((VAR_0, "" %s"", tok2str(VAR_15, ""proc-%u"", VAR_8)));
switch (VAR_8) {
case VAR_16:
case VAR_17:
case VAR_18:
case VAR_19:
case VAR_20:
case VAR_21:
if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
parsefh(VAR_0, VAR_5, VAR_7) != NULL)
return;
break;
case VAR_22:
case VAR_23:
case VAR_24:
case VAR_25:
case VAR_26:
if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
parsefhn(VAR_0, VAR_5, VAR_7) != NULL)
return;
break;
case VAR_27:
if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
(VAR_5 = parsefh(VAR_0, VAR_5, VAR_7)) != NULL) {
ND_TCHECK(VAR_5[0]);
VAR_9 = EXTRACT_32BITS(&VAR_5[0]);
if (VAR_9 & ~VAR_28) {
ND_PRINT((VAR_0, "" %04x"", VAR_9));
} else if ((VAR_9 & VAR_28) == VAR_28) {
ND_PRINT((VAR_0, "" NFS_ACCESS_FULL""));
} else {
char VAR_29 = ' ';
if (VAR_9 & VAR_30) {
ND_PRINT((VAR_0, "" NFS_ACCESS_READ""));
VAR_29 = '|';
}
if (VAR_9 & VAR_31) {
ND_PRINT((VAR_0, ""%cNFS_ACCESS_LOOKUP"", VAR_29));
VAR_29 = '|';
}
if (VAR_9 & VAR_32) {
ND_PRINT((VAR_0, ""%cNFS_ACCESS_MODIFY"", VAR_29));
VAR_29 = '|';
}
if (VAR_9 & VAR_33) {
ND_PRINT((VAR_0, ""%cNFS_ACCESS_EXTEND"", VAR_29));
VAR_29 = '|';
}
if (VAR_9 & VAR_34) {
ND_PRINT((VAR_0, ""%cNFS_ACCESS_DELETE"", VAR_29));
VAR_29 = '|';
}
if (VAR_9 & VAR_35)
ND_PRINT((VAR_0, ""%cNFS_ACCESS_EXECUTE"", VAR_29));
}
return;
}
break;
case VAR_36:
if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
(VAR_5 = parsefh(VAR_0, VAR_5, VAR_7)) != NULL) {
if (VAR_7) {
ND_TCHECK(VAR_5[2]);
ND_PRINT((VAR_0, "" %u bytes @ %"" VAR_37,
EXTRACT_32BITS(&VAR_5[2]),
EXTRACT_64BITS(&VAR_5[0])));
} else {
ND_TCHECK(VAR_5[1]);
ND_PRINT((VAR_0, "" %u bytes @ %u"",
EXTRACT_32BITS(&VAR_5[1]),
EXTRACT_32BITS(&VAR_5[0])));
}
return;
}
break;
case VAR_38:
if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
(VAR_5 = parsefh(VAR_0, VAR_5, VAR_7)) != NULL) {
if (VAR_7) {
ND_TCHECK(VAR_5[2]);
ND_PRINT((VAR_0, "" %u (%u) bytes @ %"" VAR_37,
EXTRACT_32BITS(&VAR_5[4]),
EXTRACT_32BITS(&VAR_5[2]),
EXTRACT_64BITS(&VAR_5[0])));
if (VAR_0->ndo_vflag) {
VAR_5 += 3;
ND_TCHECK(VAR_5[0]);
ND_PRINT((VAR_0, "" <%s>"",
tok2str(VAR_39,
NULL, EXTRACT_32BITS(VAR_5))));
}
} else {
ND_TCHECK(VAR_5[3]);
ND_PRINT((VAR_0, "" %u (%u) bytes @ %u (%u)"",
EXTRACT_32BITS(&VAR_5[3]),
EXTRACT_32BITS(&VAR_5[2]),
EXTRACT_32BITS(&VAR_5[1]),
EXTRACT_32BITS(&VAR_5[0])));
}
return;
}
break;
case VAR_40:
if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
(VAR_5 = parsefhn(VAR_0, VAR_5, VAR_7)) != NULL) {
ND_PRINT((VAR_0, "" ->""));
if (VAR_7 && (VAR_5 = parse_sattr3(VAR_0, VAR_5, &VAR_10)) == NULL)
break;
if (parsefn(VAR_0, VAR_5) == NULL)
break;
if (VAR_7 && VAR_0->ndo_vflag)
print_sattr3(VAR_0, &VAR_10, VAR_0->ndo_vflag);
return;
}
break;
case VAR_41:
if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
(VAR_5 = parsefhn(VAR_0, VAR_5, VAR_7)) != NULL) {
ND_TCHECK(*VAR_5);
VAR_6 = (nfs_type)EXTRACT_32BITS(VAR_5);
VAR_5++;
if ((VAR_5 = parse_sattr3(VAR_0, VAR_5, &VAR_10)) == NULL)
break;
ND_PRINT((VAR_0, "" %s"", tok2str(VAR_42, ""unk-ft %d"", VAR_6)));
if (VAR_0->ndo_vflag && (VAR_6 == VAR_43 || VAR_6 == VAR_44)) {
ND_TCHECK(VAR_5[1]);
ND_PRINT((VAR_0, "" %u/%u"",
EXTRACT_32BITS(&VAR_5[0]),
EXTRACT_32BITS(&VAR_5[1])));
VAR_5 += 2;
}
if (VAR_0->ndo_vflag)
print_sattr3(VAR_0, &VAR_10, VAR_0->ndo_vflag);
return;
}
break;
case VAR_45:
if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
(VAR_5 = parsefhn(VAR_0, VAR_5, VAR_7)) != NULL) {
ND_PRINT((VAR_0, "" ->""));
if (parsefhn(VAR_0, VAR_5, VAR_7) != NULL)
return;
}
break;
case VAR_46:
if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
(VAR_5 = parsefh(VAR_0, VAR_5, VAR_7)) != NULL) {
ND_PRINT((VAR_0, "" ->""));
if (parsefhn(VAR_0, VAR_5, VAR_7) != NULL)
return;
}
break;
case VAR_47:
if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
(VAR_5 = parsefh(VAR_0, VAR_5, VAR_7)) != NULL) {
if (VAR_7) {
ND_TCHECK(VAR_5[4]);
ND_PRINT((VAR_0, "" %u bytes @ %"" VAR_48,
EXTRACT_32BITS(&VAR_5[4]),
EXTRACT_64BITS(&VAR_5[0])));
if (VAR_0->ndo_vflag)
ND_PRINT((VAR_0, "" verf %08x%08x"", VAR_5[2], VAR_5[3]));
} else {
ND_TCHECK(VAR_5[1]);
ND_PRINT((VAR_0, "" %u bytes @ %d"",
EXTRACT_32BITS(&VAR_5[1]),
EXTRACT_32BITS(&VAR_5[0])));
}
return;
}
break;
case VAR_49:
if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
(VAR_5 = parsefh(VAR_0, VAR_5, VAR_7)) != NULL) {
ND_TCHECK(VAR_5[4]);
ND_PRINT((VAR_0, "" %u bytes @ %"" VAR_48,
EXTRACT_32BITS(&VAR_5[4]),
EXTRACT_64BITS(&VAR_5[0])));
if (VAR_0->ndo_vflag) {
ND_TCHECK(VAR_5[5]);
ND_PRINT((VAR_0, "" max %u verf %08x%08x"",
EXTRACT_32BITS(&VAR_5[5]), VAR_5[2], VAR_5[3]));
}
return;
}
break;
case VAR_50:
if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
(VAR_5 = parsefh(VAR_0, VAR_5, VAR_7)) != NULL) {
ND_TCHECK(VAR_5[2]);
ND_PRINT((VAR_0, "" %u bytes @ %"" VAR_37,
EXTRACT_32BITS(&VAR_5[2]),
EXTRACT_64BITS(&VAR_5[0])));
return;
}
break;
default:
return;
}
trunc:
if (!VAR_11)
ND_PRINT((VAR_0, ""%s"", VAR_51));
}",the-tcpdump-group/tcpdump/19d25dd8781620cd41bf178a5e2e27fc1cf242d0/print-nfs.c/vul/before/2.json,"void
nfsreq_print_noaddr(netdissect_options *ndo,
                    register const u_char *bp, u_int length,
                    register const u_char *bp2)
{
	register const struct sunrpc_msg *rp;
	register const uint32_t *dp;
	nfs_type type;
	int v3;
	uint32_t proc;
	uint32_t access_flags;
	struct nfsv3_sattr sa3;

	ND_PRINT((ndo, ""%d"", length));
	nfserr = 0;		/* assume no error */
	rp = (const struct sunrpc_msg *)bp;

	if (!xid_map_enter(ndo, rp, bp2))	/* record proc number for later on */
		goto trunc;

	v3 = (EXTRACT_32BITS(&rp->rm_call.cb_vers) == NFS_VER3);
	proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);

	if (!v3 && proc < NFS_NPROCS)
		proc =  nfsv3_procid[proc];

	ND_PRINT((ndo, "" %s"", tok2str(nfsproc_str, ""proc-%u"", proc)));
	switch (proc) {

	case NFSPROC_GETATTR:
	case NFSPROC_SETATTR:
	case NFSPROC_READLINK:
	case NFSPROC_FSSTAT:
	case NFSPROC_FSINFO:
	case NFSPROC_PATHCONF:
		if ((dp = parsereq(ndo, rp, length)) != NULL &&
		    parsefh(ndo, dp, v3) != NULL)
			return;
		break;

	case NFSPROC_LOOKUP:
	case NFSPROC_CREATE:
	case NFSPROC_MKDIR:
	case NFSPROC_REMOVE:
	case NFSPROC_RMDIR:
		if ((dp = parsereq(ndo, rp, length)) != NULL &&
		    parsefhn(ndo, dp, v3) != NULL)
			return;
		break;

	case NFSPROC_ACCESS:
		if ((dp = parsereq(ndo, rp, length)) != NULL &&
		    (dp = parsefh(ndo, dp, v3)) != NULL) {
			ND_TCHECK(dp[0]);
			access_flags = EXTRACT_32BITS(&dp[0]);
			if (access_flags & ~NFSV3ACCESS_FULL) {
				/* NFSV3ACCESS definitions aren't up to date */
				ND_PRINT((ndo, "" %04x"", access_flags));
			} else if ((access_flags & NFSV3ACCESS_FULL) == NFSV3ACCESS_FULL) {
				ND_PRINT((ndo, "" NFS_ACCESS_FULL""));
			} else {
				char separator = ' ';
				if (access_flags & NFSV3ACCESS_READ) {
					ND_PRINT((ndo, "" NFS_ACCESS_READ""));
					separator = '|';
				}
				if (access_flags & NFSV3ACCESS_LOOKUP) {
					ND_PRINT((ndo, ""%cNFS_ACCESS_LOOKUP"", separator));
					separator = '|';
				}
				if (access_flags & NFSV3ACCESS_MODIFY) {
					ND_PRINT((ndo, ""%cNFS_ACCESS_MODIFY"", separator));
					separator = '|';
				}
				if (access_flags & NFSV3ACCESS_EXTEND) {
					ND_PRINT((ndo, ""%cNFS_ACCESS_EXTEND"", separator));
					separator = '|';
				}
				if (access_flags & NFSV3ACCESS_DELETE) {
					ND_PRINT((ndo, ""%cNFS_ACCESS_DELETE"", separator));
					separator = '|';
				}
				if (access_flags & NFSV3ACCESS_EXECUTE)
					ND_PRINT((ndo, ""%cNFS_ACCESS_EXECUTE"", separator));
			}
			return;
		}
		break;

	case NFSPROC_READ:
		if ((dp = parsereq(ndo, rp, length)) != NULL &&
		    (dp = parsefh(ndo, dp, v3)) != NULL) {
			if (v3) {
				ND_TCHECK(dp[2]);
				ND_PRINT((ndo, "" %u bytes @ %"" PRIu64,
				       EXTRACT_32BITS(&dp[2]),
				       EXTRACT_64BITS(&dp[0])));
			} else {
				ND_TCHECK(dp[1]);
				ND_PRINT((ndo, "" %u bytes @ %u"",
				    EXTRACT_32BITS(&dp[1]),
				    EXTRACT_32BITS(&dp[0])));
			}
			return;
		}
		break;

	case NFSPROC_WRITE:
		if ((dp = parsereq(ndo, rp, length)) != NULL &&
		    (dp = parsefh(ndo, dp, v3)) != NULL) {
			if (v3) {
				ND_TCHECK(dp[4]);
				ND_PRINT((ndo, "" %u (%u) bytes @ %"" PRIu64,
						EXTRACT_32BITS(&dp[4]),
						EXTRACT_32BITS(&dp[2]),
						EXTRACT_64BITS(&dp[0])));
				if (ndo->ndo_vflag) {
					ND_PRINT((ndo, "" <%s>"",
						tok2str(nfsv3_writemodes,
							NULL, EXTRACT_32BITS(&dp[3]))));
				}
			} else {
				ND_TCHECK(dp[3]);
				ND_PRINT((ndo, "" %u (%u) bytes @ %u (%u)"",
						EXTRACT_32BITS(&dp[3]),
						EXTRACT_32BITS(&dp[2]),
						EXTRACT_32BITS(&dp[1]),
						EXTRACT_32BITS(&dp[0])));
			}
			return;
		}
		break;

	case NFSPROC_SYMLINK:
		if ((dp = parsereq(ndo, rp, length)) != NULL &&
		    (dp = parsefhn(ndo, dp, v3)) != NULL) {
			ND_PRINT((ndo, "" ->""));
			if (v3 && (dp = parse_sattr3(ndo, dp, &sa3)) == NULL)
				break;
			if (parsefn(ndo, dp) == NULL)
				break;
			if (v3 && ndo->ndo_vflag)
				print_sattr3(ndo, &sa3, ndo->ndo_vflag);
			return;
		}
		break;

	case NFSPROC_MKNOD:
		if ((dp = parsereq(ndo, rp, length)) != NULL &&
		    (dp = parsefhn(ndo, dp, v3)) != NULL) {
			ND_TCHECK(*dp);
			type = (nfs_type)EXTRACT_32BITS(dp);
			dp++;
			if ((dp = parse_sattr3(ndo, dp, &sa3)) == NULL)
				break;
			ND_PRINT((ndo, "" %s"", tok2str(type2str, ""unk-ft %d"", type)));
			if (ndo->ndo_vflag && (type == NFCHR || type == NFBLK)) {
				ND_TCHECK(dp[1]);
				ND_PRINT((ndo, "" %u/%u"",
				       EXTRACT_32BITS(&dp[0]),
				       EXTRACT_32BITS(&dp[1])));
				dp += 2;
			}
			if (ndo->ndo_vflag)
				print_sattr3(ndo, &sa3, ndo->ndo_vflag);
			return;
		}
		break;

	case NFSPROC_RENAME:
		if ((dp = parsereq(ndo, rp, length)) != NULL &&
		    (dp = parsefhn(ndo, dp, v3)) != NULL) {
			ND_PRINT((ndo, "" ->""));
			if (parsefhn(ndo, dp, v3) != NULL)
				return;
		}
		break;

	case NFSPROC_LINK:
		if ((dp = parsereq(ndo, rp, length)) != NULL &&
		    (dp = parsefh(ndo, dp, v3)) != NULL) {
			ND_PRINT((ndo, "" ->""));
			if (parsefhn(ndo, dp, v3) != NULL)
				return;
		}
		break;

	case NFSPROC_READDIR:
		if ((dp = parsereq(ndo, rp, length)) != NULL &&
		    (dp = parsefh(ndo, dp, v3)) != NULL) {
			if (v3) {
				ND_TCHECK(dp[4]);
				/*
				 * We shouldn't really try to interpret the
				 * offset cookie here.
				 */
				ND_PRINT((ndo, "" %u bytes @ %"" PRId64,
				    EXTRACT_32BITS(&dp[4]),
				    EXTRACT_64BITS(&dp[0])));
				if (ndo->ndo_vflag)
					ND_PRINT((ndo, "" verf %08x%08x"", dp[2], dp[3]));
			} else {
				ND_TCHECK(dp[1]);
				/*
				 * Print the offset as signed, since -1 is
				 * common, but offsets > 2^31 aren't.
				 */
				ND_PRINT((ndo, "" %u bytes @ %d"",
				    EXTRACT_32BITS(&dp[1]),
				    EXTRACT_32BITS(&dp[0])));
			}
			return;
		}
		break;

	case NFSPROC_READDIRPLUS:
		if ((dp = parsereq(ndo, rp, length)) != NULL &&
		    (dp = parsefh(ndo, dp, v3)) != NULL) {
			ND_TCHECK(dp[4]);
			/*
			 * We don't try to interpret the offset
			 * cookie here.
			 */
			ND_PRINT((ndo, "" %u bytes @ %"" PRId64,
				EXTRACT_32BITS(&dp[4]),
				EXTRACT_64BITS(&dp[0])));
			if (ndo->ndo_vflag) {
				ND_TCHECK(dp[5]);
				ND_PRINT((ndo, "" max %u verf %08x%08x"",
				       EXTRACT_32BITS(&dp[5]), dp[2], dp[3]));
			}
			return;
		}
		break;

	case NFSPROC_COMMIT:
		if ((dp = parsereq(ndo, rp, length)) != NULL &&
		    (dp = parsefh(ndo, dp, v3)) != NULL) {
			ND_TCHECK(dp[2]);
			ND_PRINT((ndo, "" %u bytes @ %"" PRIu64,
				EXTRACT_32BITS(&dp[2]),
				EXTRACT_64BITS(&dp[0])));
			return;
		}
		break;

	default:
		return;
	}

trunc:
	if (!nfserr)
		ND_PRINT((ndo, ""%s"", tstr));
}","void
nfsreq_print_noaddr(netdissect_options *VAR_0,
                    register const u_char *VAR_1, u_int VAR_2,
                    register const u_char *VAR_3)
{
	register const struct sunrpc_msg *VAR_4;
	register const uint32_t *VAR_5;
	nfs_type VAR_6;
	int VAR_7;
	uint32_t VAR_8;
	uint32_t VAR_9;
	struct nfsv3_sattr VAR_10;

	ND_PRINT((VAR_0, ""%d"", VAR_2));
	VAR_11 = 0;		/* COMMENT_0 */
	VAR_4 = (const struct sunrpc_msg *)VAR_1;

	if (!xid_map_enter(VAR_0, VAR_4, VAR_3))	/* COMMENT_1 */
		goto trunc;

	VAR_7 = (EXTRACT_32BITS(&VAR_4->rm_call.cb_vers) == VAR_12);
	VAR_8 = EXTRACT_32BITS(&VAR_4->rm_call.cb_proc);

	if (!VAR_7 && VAR_8 < VAR_13)
		VAR_8 =  VAR_14[VAR_8];

	ND_PRINT((VAR_0, "" %s"", tok2str(VAR_15, ""proc-%u"", VAR_8)));
	switch (VAR_8) {

	case VAR_16:
	case VAR_17:
	case VAR_18:
	case VAR_19:
	case VAR_20:
	case VAR_21:
		if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
		    parsefh(VAR_0, VAR_5, VAR_7) != NULL)
			return;
		break;

	case VAR_22:
	case VAR_23:
	case VAR_24:
	case VAR_25:
	case VAR_26:
		if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
		    parsefhn(VAR_0, VAR_5, VAR_7) != NULL)
			return;
		break;

	case VAR_27:
		if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
		    (VAR_5 = parsefh(VAR_0, VAR_5, VAR_7)) != NULL) {
			ND_TCHECK(VAR_5[0]);
			VAR_9 = EXTRACT_32BITS(&VAR_5[0]);
			if (VAR_9 & ~VAR_28) {
				/* COMMENT_2 */
				ND_PRINT((VAR_0, "" %04x"", VAR_9));
			} else if ((VAR_9 & VAR_28) == VAR_28) {
				ND_PRINT((VAR_0, "" NFS_ACCESS_FULL""));
			} else {
				char VAR_29 = ' ';
				if (VAR_9 & VAR_30) {
					ND_PRINT((VAR_0, "" NFS_ACCESS_READ""));
					VAR_29 = '|';
				}
				if (VAR_9 & VAR_31) {
					ND_PRINT((VAR_0, ""%cNFS_ACCESS_LOOKUP"", VAR_29));
					VAR_29 = '|';
				}
				if (VAR_9 & VAR_32) {
					ND_PRINT((VAR_0, ""%cNFS_ACCESS_MODIFY"", VAR_29));
					VAR_29 = '|';
				}
				if (VAR_9 & VAR_33) {
					ND_PRINT((VAR_0, ""%cNFS_ACCESS_EXTEND"", VAR_29));
					VAR_29 = '|';
				}
				if (VAR_9 & VAR_34) {
					ND_PRINT((VAR_0, ""%cNFS_ACCESS_DELETE"", VAR_29));
					VAR_29 = '|';
				}
				if (VAR_9 & VAR_35)
					ND_PRINT((VAR_0, ""%cNFS_ACCESS_EXECUTE"", VAR_29));
			}
			return;
		}
		break;

	case VAR_36:
		if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
		    (VAR_5 = parsefh(VAR_0, VAR_5, VAR_7)) != NULL) {
			if (VAR_7) {
				ND_TCHECK(VAR_5[2]);
				ND_PRINT((VAR_0, "" %u bytes @ %"" VAR_37,
				       EXTRACT_32BITS(&VAR_5[2]),
				       EXTRACT_64BITS(&VAR_5[0])));
			} else {
				ND_TCHECK(VAR_5[1]);
				ND_PRINT((VAR_0, "" %u bytes @ %u"",
				    EXTRACT_32BITS(&VAR_5[1]),
				    EXTRACT_32BITS(&VAR_5[0])));
			}
			return;
		}
		break;

	case VAR_38:
		if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
		    (VAR_5 = parsefh(VAR_0, VAR_5, VAR_7)) != NULL) {
			if (VAR_7) {
				ND_TCHECK(VAR_5[4]);
				ND_PRINT((VAR_0, "" %u (%u) bytes @ %"" VAR_37,
						EXTRACT_32BITS(&VAR_5[4]),
						EXTRACT_32BITS(&VAR_5[2]),
						EXTRACT_64BITS(&VAR_5[0])));
				if (VAR_0->ndo_vflag) {
					ND_PRINT((VAR_0, "" <%s>"",
						tok2str(VAR_39,
							NULL, EXTRACT_32BITS(&VAR_5[3]))));
				}
			} else {
				ND_TCHECK(VAR_5[3]);
				ND_PRINT((VAR_0, "" %u (%u) bytes @ %u (%u)"",
						EXTRACT_32BITS(&VAR_5[3]),
						EXTRACT_32BITS(&VAR_5[2]),
						EXTRACT_32BITS(&VAR_5[1]),
						EXTRACT_32BITS(&VAR_5[0])));
			}
			return;
		}
		break;

	case VAR_40:
		if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
		    (VAR_5 = parsefhn(VAR_0, VAR_5, VAR_7)) != NULL) {
			ND_PRINT((VAR_0, "" ->""));
			if (VAR_7 && (VAR_5 = parse_sattr3(VAR_0, VAR_5, &VAR_10)) == NULL)
				break;
			if (parsefn(VAR_0, VAR_5) == NULL)
				break;
			if (VAR_7 && VAR_0->ndo_vflag)
				print_sattr3(VAR_0, &VAR_10, VAR_0->ndo_vflag);
			return;
		}
		break;

	case VAR_41:
		if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
		    (VAR_5 = parsefhn(VAR_0, VAR_5, VAR_7)) != NULL) {
			ND_TCHECK(*VAR_5);
			VAR_6 = (nfs_type)EXTRACT_32BITS(VAR_5);
			VAR_5++;
			if ((VAR_5 = parse_sattr3(VAR_0, VAR_5, &VAR_10)) == NULL)
				break;
			ND_PRINT((VAR_0, "" %s"", tok2str(VAR_42, ""unk-ft %d"", VAR_6)));
			if (VAR_0->ndo_vflag && (VAR_6 == VAR_43 || VAR_6 == VAR_44)) {
				ND_TCHECK(VAR_5[1]);
				ND_PRINT((VAR_0, "" %u/%u"",
				       EXTRACT_32BITS(&VAR_5[0]),
				       EXTRACT_32BITS(&VAR_5[1])));
				VAR_5 += 2;
			}
			if (VAR_0->ndo_vflag)
				print_sattr3(VAR_0, &VAR_10, VAR_0->ndo_vflag);
			return;
		}
		break;

	case VAR_45:
		if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
		    (VAR_5 = parsefhn(VAR_0, VAR_5, VAR_7)) != NULL) {
			ND_PRINT((VAR_0, "" ->""));
			if (parsefhn(VAR_0, VAR_5, VAR_7) != NULL)
				return;
		}
		break;

	case VAR_46:
		if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
		    (VAR_5 = parsefh(VAR_0, VAR_5, VAR_7)) != NULL) {
			ND_PRINT((VAR_0, "" ->""));
			if (parsefhn(VAR_0, VAR_5, VAR_7) != NULL)
				return;
		}
		break;

	case VAR_47:
		if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
		    (VAR_5 = parsefh(VAR_0, VAR_5, VAR_7)) != NULL) {
			if (VAR_7) {
				ND_TCHECK(VAR_5[4]);
				/* COMMENT_3 */
                                               
                          
       
				ND_PRINT((VAR_0, "" %u bytes @ %"" VAR_48,
				    EXTRACT_32BITS(&VAR_5[4]),
				    EXTRACT_64BITS(&VAR_5[0])));
				if (VAR_0->ndo_vflag)
					ND_PRINT((VAR_0, "" verf %08x%08x"", VAR_5[2], VAR_5[3]));
			} else {
				ND_TCHECK(VAR_5[1]);
				/* COMMENT_7 */
                                              
                                         
       
				ND_PRINT((VAR_0, "" %u bytes @ %d"",
				    EXTRACT_32BITS(&VAR_5[1]),
				    EXTRACT_32BITS(&VAR_5[0])));
			}
			return;
		}
		break;

	case VAR_49:
		if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
		    (VAR_5 = parsefh(VAR_0, VAR_5, VAR_7)) != NULL) {
			ND_TCHECK(VAR_5[4]);
			/* COMMENT_11 */
                                          
                  
      
			ND_PRINT((VAR_0, "" %u bytes @ %"" VAR_48,
				EXTRACT_32BITS(&VAR_5[4]),
				EXTRACT_64BITS(&VAR_5[0])));
			if (VAR_0->ndo_vflag) {
				ND_TCHECK(VAR_5[5]);
				ND_PRINT((VAR_0, "" max %u verf %08x%08x"",
				       EXTRACT_32BITS(&VAR_5[5]), VAR_5[2], VAR_5[3]));
			}
			return;
		}
		break;

	case VAR_50:
		if ((VAR_5 = parsereq(VAR_0, VAR_4, VAR_2)) != NULL &&
		    (VAR_5 = parsefh(VAR_0, VAR_5, VAR_7)) != NULL) {
			ND_TCHECK(VAR_5[2]);
			ND_PRINT((VAR_0, "" %u bytes @ %"" VAR_37,
				EXTRACT_32BITS(&VAR_5[2]),
				EXTRACT_64BITS(&VAR_5[0])));
			return;
		}
		break;

	default:
		return;
	}

trunc:
	if (!VAR_11)
		ND_PRINT((VAR_0, ""%s"", VAR_51));
}",the-tcpdump-group/tcpdump/19d25dd8781620cd41bf178a5e2e27fc1cf242d0/print-nfs.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -109,17 +109,15 @@
 		if ((dp = parsereq(ndo, rp, length)) != NULL &&
 		    (dp = parsefh(ndo, dp, v3)) != NULL) {
 			if (v3) {
-				ND_TCHECK(dp[2]);
+				ND_TCHECK(dp[4]);
 				ND_PRINT((ndo, "" %u (%u) bytes @ %"" PRIu64,
 						EXTRACT_32BITS(&dp[4]),
 						EXTRACT_32BITS(&dp[2]),
 						EXTRACT_64BITS(&dp[0])));
 				if (ndo->ndo_vflag) {
-					dp += 3;
-					ND_TCHECK(dp[0]);
 					ND_PRINT((ndo, "" <%s>"",
 						tok2str(nfsv3_writemodes,
-							NULL, EXTRACT_32BITS(dp))));
+							NULL, EXTRACT_32BITS(&dp[3]))));
 				}
 			} else {
 				ND_TCHECK(dp[3]);","{'deleted_lines': ['\t\t\t\tND_TCHECK(dp[2]);', '\t\t\t\t\tdp += 3;', '\t\t\t\t\tND_TCHECK(dp[0]);', '\t\t\t\t\t\t\tNULL, EXTRACT_32BITS(dp))));'], 'added_lines': ['\t\t\t\tND_TCHECK(dp[4]);', '\t\t\t\t\t\t\tNULL, EXTRACT_32BITS(&dp[3]))));']}",True,The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:interp_reply().,9.8,CRITICAL,3,test,2017-02-03T23:14:51Z,1
CVE-2017-6384,['CWE-772'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,atheme,saslserv/main: free sasl_sourceinfo_t after use,a80355d2971f6453ef9c6c9507e8f0d16e55dd0f,https://github.com/atheme/atheme/commit/a80355d2971f6453ef9c6c9507e8f0d16e55dd0f,modules/saslserv/main.c,login_user,"static myuser_t *login_user(sasl_session_t *p)
{
myuser_t *source_mu, *target_mu;
hook_user_login_check_t req;
source_mu = myuser_find_by_nick(p->username);
if(source_mu == NULL)
return NULL;
req.si = sasl_sourceinfo_create(p);
req.mu = source_mu;
req.allowed = true;
hook_call_user_can_login(&req);
if (!req.allowed)
{
sasl_logcommand(p, source_mu, CMDLOG_LOGIN, ""failed LOGIN to \2%s\2 (denied by hook)"", entity(source_mu)->name);
return NULL;
}
if(p->authzid && *p->authzid)
{
target_mu = myuser_find_by_nick(p->authzid);
if(target_mu == NULL)
return NULL;
}
else
{
target_mu = source_mu;
if(p->authzid != NULL)
free(p->authzid);
p->authzid = sstrdup(p->username);
}
if(metadata_find(source_mu, ""private:freeze:freezer""))
{
sasl_logcommand(p, source_mu, CMDLOG_LOGIN, ""failed LOGIN to \2%s\2 (frozen)"", entity(source_mu)->name);
return NULL;
}
if(target_mu != source_mu)
{
if(!may_impersonate(source_mu, target_mu))
{
sasl_logcommand(p, source_mu, CMDLOG_LOGIN, ""denied IMPERSONATE by \2%s\2 to \2%s\2"", entity(source_mu)->name, entity(target_mu)->name);
return NULL;
}
sasl_logcommand(p, source_mu, CMDLOG_LOGIN, ""allowed IMPERSONATE by \2%s\2 to \2%s\2"", entity(source_mu)->name, entity(target_mu)->name);
req.mu = target_mu;
req.allowed = true;
hook_call_user_can_login(&req);
if (!req.allowed)
{
sasl_logcommand(p, source_mu, CMDLOG_LOGIN, ""failed LOGIN to \2%s\2 (denied by hook)"", entity(target_mu)->name);
return NULL;
}
if(metadata_find(target_mu, ""private:freeze:freezer""))
{
sasl_logcommand(p, target_mu, CMDLOG_LOGIN, ""failed LOGIN to \2%s\2 (frozen)"", entity(target_mu)->name);
return NULL;
}
}
if(MOWGLI_LIST_LENGTH(&target_mu->logins) >= me.maxlogins)
{
sasl_logcommand(p, target_mu, CMDLOG_LOGIN, ""failed LOGIN to \2%s\2 (too many logins)"", entity(target_mu)->name);
return NULL;
}
p->flags |= ASASL_NEED_LOG;
if(ircd->flags & IRCD_SASL_USE_PUID)
{
target_mu->flags &= ~MU_NOBURSTLOGIN;
target_mu->flags |= MU_PENDINGLOGIN;
}
return target_mu;
}","static myuser_t *login_user(sasl_session_t *VAR_0)
{
myuser_t *VAR_1, *VAR_2;
hook_user_login_check_t VAR_3;
VAR_1 = myuser_find_by_nick(VAR_0->username);
if(VAR_1 == NULL)
return NULL;
VAR_3.si = sasl_sourceinfo_create(VAR_0);
VAR_3.mu = VAR_1;
VAR_3.allowed = true;
hook_call_user_can_login(&VAR_3);
if (!VAR_3.allowed)
{
sasl_logcommand(VAR_0, VAR_1, VAR_4, ""failed LOGIN to \2%s\2 (denied by hook)"", entity(VAR_1)->name);
return NULL;
}
if(VAR_0->authzid && *VAR_0->authzid)
{
VAR_2 = myuser_find_by_nick(VAR_0->authzid);
if(VAR_2 == NULL)
return NULL;
}
else
{
VAR_2 = VAR_1;
if(VAR_0->authzid != NULL)
free(VAR_0->authzid);
VAR_0->authzid = sstrdup(VAR_0->username);
}
if(metadata_find(VAR_1, ""private:freeze:freezer""))
{
sasl_logcommand(VAR_0, VAR_1, VAR_4, ""failed LOGIN to \2%s\2 (frozen)"", entity(VAR_1)->name);
return NULL;
}
if(VAR_2 != VAR_1)
{
if(!may_impersonate(VAR_1, VAR_2))
{
sasl_logcommand(VAR_0, VAR_1, VAR_4, ""denied IMPERSONATE by \2%s\2 to \2%s\2"", entity(VAR_1)->name, entity(VAR_2)->name);
return NULL;
}
sasl_logcommand(VAR_0, VAR_1, VAR_4, ""allowed IMPERSONATE by \2%s\2 to \2%s\2"", entity(VAR_1)->name, entity(VAR_2)->name);
VAR_3.mu = VAR_2;
VAR_3.allowed = true;
hook_call_user_can_login(&VAR_3);
if (!VAR_3.allowed)
{
sasl_logcommand(VAR_0, VAR_1, VAR_4, ""failed LOGIN to \2%s\2 (denied by hook)"", entity(VAR_2)->name);
return NULL;
}
if(metadata_find(VAR_2, ""private:freeze:freezer""))
{
sasl_logcommand(VAR_0, VAR_2, VAR_4, ""failed LOGIN to \2%s\2 (frozen)"", entity(VAR_2)->name);
return NULL;
}
}
if(MOWGLI_LIST_LENGTH(&VAR_2->logins) >= VAR_5.maxlogins)
{
sasl_logcommand(VAR_0, VAR_2, VAR_4, ""failed LOGIN to \2%s\2 (too many logins)"", entity(VAR_2)->name);
return NULL;
}
VAR_0->flags |= VAR_6;
if(VAR_7->flags & VAR_8)
{
VAR_2->flags &= ~VAR_9;
VAR_2->flags |= VAR_10;
}
return VAR_2;
}",atheme/a80355d2971f6453ef9c6c9507e8f0d16e55dd0f/main.c/vul/before/0.json,"static myuser_t *login_user(sasl_session_t *p)
{
	myuser_t *source_mu, *target_mu;
	hook_user_login_check_t req;

	/* source_mu is the user whose credentials we verified (""authentication id"") */
	/* target_mu is the user who will be ultimately logged in (""authorization id"") */

	source_mu = myuser_find_by_nick(p->username);
	if(source_mu == NULL)
		return NULL;

	req.si = sasl_sourceinfo_create(p);
	req.mu = source_mu;
	req.allowed = true;
	hook_call_user_can_login(&req);
	object_unref(req.si);
	if (!req.allowed)
	{
		sasl_logcommand(p, source_mu, CMDLOG_LOGIN, ""failed LOGIN to \2%s\2 (denied by hook)"", entity(source_mu)->name);
		return NULL;
	}

	if(p->authzid && *p->authzid)
	{
		target_mu = myuser_find_by_nick(p->authzid);
		if(target_mu == NULL)
			return NULL;
	}
	else
	{
		target_mu = source_mu;
		if(p->authzid != NULL)
			free(p->authzid);
		p->authzid = sstrdup(p->username);
	}

	if(metadata_find(source_mu, ""private:freeze:freezer""))
	{
		sasl_logcommand(p, source_mu, CMDLOG_LOGIN, ""failed LOGIN to \2%s\2 (frozen)"", entity(source_mu)->name);
		return NULL;
	}

	if(target_mu != source_mu)
	{
		if(!may_impersonate(source_mu, target_mu))
		{
			sasl_logcommand(p, source_mu, CMDLOG_LOGIN, ""denied IMPERSONATE by \2%s\2 to \2%s\2"", entity(source_mu)->name, entity(target_mu)->name);
			return NULL;
		}

		sasl_logcommand(p, source_mu, CMDLOG_LOGIN, ""allowed IMPERSONATE by \2%s\2 to \2%s\2"", entity(source_mu)->name, entity(target_mu)->name);

		req.mu = target_mu;
		req.allowed = true;
		hook_call_user_can_login(&req);
		if (!req.allowed)
		{
			sasl_logcommand(p, source_mu, CMDLOG_LOGIN, ""failed LOGIN to \2%s\2 (denied by hook)"", entity(target_mu)->name);
			return NULL;
		}

		if(metadata_find(target_mu, ""private:freeze:freezer""))
		{
			sasl_logcommand(p, target_mu, CMDLOG_LOGIN, ""failed LOGIN to \2%s\2 (frozen)"", entity(target_mu)->name);
			return NULL;
		}
	}

	if(MOWGLI_LIST_LENGTH(&target_mu->logins) >= me.maxlogins)
	{
		sasl_logcommand(p, target_mu, CMDLOG_LOGIN, ""failed LOGIN to \2%s\2 (too many logins)"", entity(target_mu)->name);
		return NULL;
	}

	/* Log it with the full n!u@h later */
	p->flags |= ASASL_NEED_LOG;

	/* We just did SASL authentication for a user.  With IRCds which do not
	 * have unique UIDs for users, we will likely be expecting the login
	 * data to be bursted.  As a result, we should give the core a heads'
	 * up that this is going to happen so that hooks will be properly
	 * fired...
	 */
	if(ircd->flags & IRCD_SASL_USE_PUID)
	{
		target_mu->flags &= ~MU_NOBURSTLOGIN;
		target_mu->flags |= MU_PENDINGLOGIN;
	}

	return target_mu;
}","static myuser_t *login_user(sasl_session_t *VAR_0)
{
	myuser_t *VAR_1, *VAR_2;
	hook_user_login_check_t VAR_3;

	/* COMMENT_0 */
	/* COMMENT_1 */

	VAR_1 = myuser_find_by_nick(VAR_0->username);
	if(VAR_1 == NULL)
		return NULL;

	VAR_3.si = sasl_sourceinfo_create(VAR_0);
	VAR_3.mu = VAR_1;
	VAR_3.allowed = true;
	hook_call_user_can_login(&VAR_3);
	object_unref(VAR_3.si);
	if (!VAR_3.allowed)
	{
		sasl_logcommand(VAR_0, VAR_1, VAR_4, ""failed LOGIN to \2%s\2 (denied by hook)"", entity(VAR_1)->name);
		return NULL;
	}

	if(VAR_0->authzid && *VAR_0->authzid)
	{
		VAR_2 = myuser_find_by_nick(VAR_0->authzid);
		if(VAR_2 == NULL)
			return NULL;
	}
	else
	{
		VAR_2 = VAR_1;
		if(VAR_0->authzid != NULL)
			free(VAR_0->authzid);
		VAR_0->authzid = sstrdup(VAR_0->username);
	}

	if(metadata_find(VAR_1, ""private:freeze:freezer""))
	{
		sasl_logcommand(VAR_0, VAR_1, VAR_4, ""failed LOGIN to \2%s\2 (frozen)"", entity(VAR_1)->name);
		return NULL;
	}

	if(VAR_2 != VAR_1)
	{
		if(!may_impersonate(VAR_1, VAR_2))
		{
			sasl_logcommand(VAR_0, VAR_1, VAR_4, ""denied IMPERSONATE by \2%s\2 to \2%s\2"", entity(VAR_1)->name, entity(VAR_2)->name);
			return NULL;
		}

		sasl_logcommand(VAR_0, VAR_1, VAR_4, ""allowed IMPERSONATE by \2%s\2 to \2%s\2"", entity(VAR_1)->name, entity(VAR_2)->name);

		VAR_3.mu = VAR_2;
		VAR_3.allowed = true;
		hook_call_user_can_login(&VAR_3);
		if (!VAR_3.allowed)
		{
			sasl_logcommand(VAR_0, VAR_1, VAR_4, ""failed LOGIN to \2%s\2 (denied by hook)"", entity(VAR_2)->name);
			return NULL;
		}

		if(metadata_find(VAR_2, ""private:freeze:freezer""))
		{
			sasl_logcommand(VAR_0, VAR_2, VAR_4, ""failed LOGIN to \2%s\2 (frozen)"", entity(VAR_2)->name);
			return NULL;
		}
	}

	if(MOWGLI_LIST_LENGTH(&VAR_2->logins) >= VAR_5.maxlogins)
	{
		sasl_logcommand(VAR_0, VAR_2, VAR_4, ""failed LOGIN to \2%s\2 (too many logins)"", entity(VAR_2)->name);
		return NULL;
	}

	/* COMMENT_2 */
	VAR_0->flags |= VAR_6;

	/* COMMENT_3 */
                                                                     
                                                                      
                                                                  
            
    
	if(VAR_7->flags & VAR_8)
	{
		VAR_2->flags &= ~VAR_9;
		VAR_2->flags |= VAR_10;
	}

	return VAR_2;
}",atheme/a80355d2971f6453ef9c6c9507e8f0d16e55dd0f/main.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,6 +14,7 @@
 	req.mu = source_mu;
 	req.allowed = true;
 	hook_call_user_can_login(&req);
+	object_unref(req.si);
 	if (!req.allowed)
 	{
 		sasl_logcommand(p, source_mu, CMDLOG_LOGIN, ""failed LOGIN to \2%s\2 (denied by hook)"", entity(source_mu)->name);","{'deleted_lines': [], 'added_lines': ['\tobject_unref(req.si);']}",True,Memory leak in the login_user function in saslserv/main.c in saslserv/main.so in Atheme 7.2.7 allows a remote unauthenticated attacker to consume memory and cause a denial of service. This is fixed in 7.2.8.,7.5,HIGH,2,test,2017-02-03T23:50:53Z,1
CVE-2017-14604,['CWE-20'],AV:N/AC:L/Au:S/C:N/I:P/A:N,0,GNOME/nautilus,"mime-actions: use file metadata for trusting desktop files

Currently we only trust desktop files that have the executable bit
set, and don't replace the displayed icon or the displayed name until
it's trusted, which prevents for running random programs by a malicious
desktop file.

However, the executable permission is preserved if the desktop file
comes from a compressed file.

To prevent this, add a metadata::trusted metadata to the file once the
user acknowledges the file as trusted. This adds metadata to the file,
which cannot be added unless it has access to the computer.

Also remove the SHEBANG ""trusted"" content we were putting inside the
desktop file, since that doesn't add more security since it can come
with the file itself.

https://bugzilla.gnome.org/show_bug.cgi?id=777991",1630f53481f445ada0a455e9979236d31a8d3bb0,https://github.com/GNOME/nautilus/commit/1630f53481f445ada0a455e9979236d31a8d3bb0,src/nautilus-mime-actions.c,untrusted_launcher_response_callback,"static void
untrusted_launcher_response_callback (GtkDialog                 *dialog,
int                        response_id,
ActivateParametersDesktop *parameters)
{
GdkScreen *screen;
char *uri;
GFile *file;
switch (response_id)
{
case RESPONSE_RUN:
{
screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));
uri = nautilus_file_get_uri (parameters->file);
DEBUG (""Launching untrusted launcher %s"", uri);
nautilus_launch_desktop_file (screen, uri, NULL,
parameters->parent_window);
g_free (uri);
}
break;
case RESPONSE_MARK_TRUSTED:
{
file = nautilus_file_get_location (parameters->file);
nautilus_file_mark_desktop_file_trusted (file,
parameters->parent_window,
TRUE,
NULL, NULL);
g_object_unref (file);
}
break;
default:
{
}
break;
}
gtk_widget_destroy (GTK_WIDGET (dialog));
activate_parameters_desktop_free (parameters);
}","static void
untrusted_launcher_response_callback (GtkDialog                 *VAR_0,
int                        VAR_1,
ActivateParametersDesktop *VAR_2)
{
GdkScreen *VAR_3;
char *VAR_4;
GFile *VAR_5;
switch (VAR_1)
{
case VAR_6:
{
VAR_3 = gtk_widget_get_screen (GTK_WIDGET (VAR_2->parent_window));
VAR_4 = nautilus_file_get_uri (VAR_2->file);
DEBUG (""Launching untrusted launcher %s"", VAR_4);
nautilus_launch_desktop_file (VAR_3, VAR_4, NULL,
VAR_2->parent_window);
g_free (VAR_4);
}
break;
case VAR_7:
{
VAR_5 = nautilus_file_get_location (VAR_2->file);
nautilus_file_mark_desktop_file_trusted (VAR_5,
VAR_2->parent_window,
TRUE,
NULL, NULL);
g_object_unref (VAR_5);
}
break;
default:
{
}
break;
}
gtk_widget_destroy (GTK_WIDGET (VAR_0));
activate_parameters_desktop_free (VAR_2);
}",GNOME/nautilus/1630f53481f445ada0a455e9979236d31a8d3bb0/nautilus-mime-actions.c/vul/before/1.json,"static void
untrusted_launcher_response_callback (GtkDialog                 *dialog,
                                      int                        response_id,
                                      ActivateParametersDesktop *parameters)
{
    GdkScreen *screen;
    char *uri;
    GFile *file;

    switch (response_id)
    {
        case GTK_RESPONSE_OK:
        {
            file = nautilus_file_get_location (parameters->file);

            /* We need to do this in order to prevent malicious desktop files
             * with the executable bit already set.
             * See https://bugzilla.gnome.org/show_bug.cgi?id=777991
             */
            nautilus_file_set_metadata (parameters->file, NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,
                                        NULL,
                                        ""yes"");

            nautilus_file_mark_desktop_file_executable (file,
                                                        parameters->parent_window,
                                                        TRUE,
                                                        NULL, NULL);

            /* Need to force a reload of the attributes so is_trusted is marked
             * correctly. Not sure why the general monitor doesn't fire in this
             * case when setting the metadata
             */
            nautilus_file_invalidate_all_attributes (parameters->file);

            screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));
            uri = nautilus_file_get_uri (parameters->file);
            DEBUG (""Launching untrusted launcher %s"", uri);
            nautilus_launch_desktop_file (screen, uri, NULL,
                                          parameters->parent_window);
            g_free (uri);
            g_object_unref (file);
        }
        break;

        default:
        {
            /* Just destroy dialog */
        }
        break;
    }

    gtk_widget_destroy (GTK_WIDGET (dialog));
    activate_parameters_desktop_free (parameters);
}","static void
untrusted_launcher_response_callback (GtkDialog                 *VAR_0,
                                      int                        VAR_1,
                                      ActivateParametersDesktop *VAR_2)
{
    GdkScreen *VAR_3;
    char *VAR_4;
    GFile *VAR_5;

    switch (VAR_1)
    {
        case VAR_6:
        {
            VAR_5 = nautilus_file_get_location (VAR_2->file);

            /* COMMENT_0 */
                                                   
                                                                    
               
            nautilus_file_set_metadata (VAR_2->file, VAR_7,
                                        NULL,
                                        ""yes"");

            nautilus_file_mark_desktop_file_executable (VAR_5,
                                                        VAR_2->parent_window,
                                                        TRUE,
                                                        NULL, NULL);

            /* COMMENT_4 */
                                                                               
                                             
               
            nautilus_file_invalidate_all_attributes (VAR_2->file);

            VAR_3 = gtk_widget_get_screen (GTK_WIDGET (VAR_2->parent_window));
            VAR_4 = nautilus_file_get_uri (VAR_2->file);
            DEBUG (""Launching untrusted launcher %s"", VAR_4);
            nautilus_launch_desktop_file (VAR_3, VAR_4, NULL,
                                          VAR_2->parent_window);
            g_free (VAR_4);
            g_object_unref (VAR_5);
        }
        break;

        default:
        {
            /* COMMENT_8 */
        }
        break;
    }

    gtk_widget_destroy (GTK_WIDGET (VAR_0));
    activate_parameters_desktop_free (VAR_2);
}",GNOME/nautilus/1630f53481f445ada0a455e9979236d31a8d3bb0/nautilus-mime-actions.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -9,24 +9,35 @@
 
     switch (response_id)
     {
-        case RESPONSE_RUN:
+        case GTK_RESPONSE_OK:
         {
+            file = nautilus_file_get_location (parameters->file);
+
+            /* We need to do this in order to prevent malicious desktop files
+             * with the executable bit already set.
+             * See https://bugzilla.gnome.org/show_bug.cgi?id=777991
+             */
+            nautilus_file_set_metadata (parameters->file, NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,
+                                        NULL,
+                                        ""yes"");
+
+            nautilus_file_mark_desktop_file_executable (file,
+                                                        parameters->parent_window,
+                                                        TRUE,
+                                                        NULL, NULL);
+
+            /* Need to force a reload of the attributes so is_trusted is marked
+             * correctly. Not sure why the general monitor doesn't fire in this
+             * case when setting the metadata
+             */
+            nautilus_file_invalidate_all_attributes (parameters->file);
+
             screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));
             uri = nautilus_file_get_uri (parameters->file);
             DEBUG (""Launching untrusted launcher %s"", uri);
             nautilus_launch_desktop_file (screen, uri, NULL,
                                           parameters->parent_window);
             g_free (uri);
-        }
-        break;
-
-        case RESPONSE_MARK_TRUSTED:
-        {
-            file = nautilus_file_get_location (parameters->file);
-            nautilus_file_mark_desktop_file_trusted (file,
-                                                     parameters->parent_window,
-                                                     TRUE,
-                                                     NULL, NULL);
             g_object_unref (file);
         }
         break;","{'deleted_lines': ['        case RESPONSE_RUN:', '        }', '        break;', '', '        case RESPONSE_MARK_TRUSTED:', '        {', '            file = nautilus_file_get_location (parameters->file);', '            nautilus_file_mark_desktop_file_trusted (file,', '                                                     parameters->parent_window,', '                                                     TRUE,', '                                                     NULL, NULL);'], 'added_lines': ['        case GTK_RESPONSE_OK:', '            file = nautilus_file_get_location (parameters->file);', '', '            /* We need to do this in order to prevent malicious desktop files', '             * with the executable bit already set.', '             * See https://bugzilla.gnome.org/show_bug.cgi?id=777991', '             */', '            nautilus_file_set_metadata (parameters->file, NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,', '                                        NULL,', '                                        ""yes"");', '', '            nautilus_file_mark_desktop_file_executable (file,', '                                                        parameters->parent_window,', '                                                        TRUE,', '                                                        NULL, NULL);', '', '            /* Need to force a reload of the attributes so is_trusted is marked', ""             * correctly. Not sure why the general monitor doesn't fire in this"", '             * case when setting the metadata', '             */', '            nautilus_file_invalidate_all_attributes (parameters->file);', '']}",True,"GNOME Nautilus before 3.23.90 allows attackers to spoof a file type by using the .desktop file extension, as demonstrated by an attack in which a .desktop file's Name field ends in .pdf but this file's Exec field launches a malicious ""sh -c"" command. In other words, Nautilus provides no UI indication that a file actually has the potentially unsafe .desktop extension; instead, the UI only shows the .pdf extension. One (slightly) mitigating factor is that an attack requires the .desktop file to have execute permission. The solution is to ask the user to confirm that the file is supposed to be treated as a .desktop file, and then remember the user's answer in the metadata::trusted field.",6.5,MEDIUM,1,test,2017-02-06T17:47:54Z,1
CVE-2017-14604,['CWE-20'],AV:N/AC:L/Au:S/C:N/I:P/A:N,0,GNOME/nautilus,"mime-actions: use file metadata for trusting desktop files

Currently we only trust desktop files that have the executable bit
set, and don't replace the displayed icon or the displayed name until
it's trusted, which prevents for running random programs by a malicious
desktop file.

However, the executable permission is preserved if the desktop file
comes from a compressed file.

To prevent this, add a metadata::trusted metadata to the file once the
user acknowledges the file as trusted. This adds metadata to the file,
which cannot be added unless it has access to the computer.

Also remove the SHEBANG ""trusted"" content we were putting inside the
desktop file, since that doesn't add more security since it can come
with the file itself.

https://bugzilla.gnome.org/show_bug.cgi?id=777991",1630f53481f445ada0a455e9979236d31a8d3bb0,https://github.com/GNOME/nautilus/commit/1630f53481f445ada0a455e9979236d31a8d3bb0,src/nautilus-file-operations.c,copy_move_file,"static void
copy_move_file (CopyMoveJob   *copy_job,
GFile         *src,
GFile         *dest_dir,
gboolean       same_fs,
gboolean       unique_names,
char         **dest_fs_type,
SourceInfo    *source_info,
TransferInfo  *transfer_info,
GHashTable    *debuting_files,
GdkPoint      *position,
gboolean       overwrite,
gboolean      *skipped_file,
gboolean       readonly_source_fs)
{
GFile *dest, *new_dest;
g_autofree gchar *dest_uri = NULL;
GError *error;
GFileCopyFlags flags;
char *primary, *secondary, *details;
int response;
ProgressData pdata;
gboolean would_recurse, is_merge;
CommonJob *job;
gboolean res;
int unique_name_nr;
gboolean handled_invalid_filename;
job = (CommonJob *) copy_job;
if (should_skip_file (job, src))
{
*skipped_file = TRUE;
return;
}
unique_name_nr = 1;
handled_invalid_filename = *dest_fs_type != NULL;
if (unique_names)
{
dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr++);
}
else if (copy_job->target_name != NULL)
{
dest = get_target_file_with_custom_name (src, dest_dir, *dest_fs_type, same_fs,
copy_job->target_name);
}
else
{
dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);
}
if (test_dir_is_parent (dest_dir, src))
{
if (job->skip_all_error)
{
goto out;
}
primary = copy_job->is_move ? g_strdup (_(""You cannot move a folder into itself.""))
: g_strdup (_(""You cannot copy a folder into itself.""));
secondary = g_strdup (_(""The destination folder is inside the source folder.""));
response = run_cancel_or_skip_warning (job,
primary,
secondary,
NULL,
source_info->num_files,
source_info->num_files - transfer_info->num_files);
if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
{
abort_job (job);
}
else if (response == 1)             
{
job->skip_all_error = TRUE;
}
else if (response == 2)             
{               
}
else
{
g_assert_not_reached ();
}
goto out;
}
if (test_dir_is_parent (src, dest))
{
if (job->skip_all_error)
{
goto out;
}
primary = copy_job->is_move ? g_strdup (_(""You cannot move a file over itself.""))
: g_strdup (_(""You cannot copy a file over itself.""));
secondary = g_strdup (_(""The source file would be overwritten by the destination.""));
response = run_cancel_or_skip_warning (job,
primary,
secondary,
NULL,
source_info->num_files,
source_info->num_files - transfer_info->num_files);
if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
{
abort_job (job);
}
else if (response == 1)             
{
job->skip_all_error = TRUE;
}
else if (response == 2)             
{               
}
else
{
g_assert_not_reached ();
}
goto out;
}
retry:
error = NULL;
flags = G_FILE_COPY_NOFOLLOW_SYMLINKS;
if (overwrite)
{
flags |= G_FILE_COPY_OVERWRITE;
}
if (readonly_source_fs)
{
flags |= G_FILE_COPY_TARGET_DEFAULT_PERMS;
}
pdata.job = copy_job;
pdata.last_size = 0;
pdata.source_info = source_info;
pdata.transfer_info = transfer_info;
if (copy_job->is_move)
{
res = g_file_move (src, dest,
flags,
job->cancellable,
copy_file_progress_callback,
&pdata,
&error);
}
else
{
res = g_file_copy (src, dest,
flags,
job->cancellable,
copy_file_progress_callback,
&pdata,
&error);
}
if (res)
{
GFile *real;
real = map_possibly_volatile_file_to_real (dest, job->cancellable, &error);
if (real == NULL)
{
res = FALSE;
}
else
{
g_object_unref (dest);
dest = real;
}
}
if (res)
{
transfer_info->num_files++;
report_copy_progress (copy_job, source_info, transfer_info);
if (debuting_files)
{
dest_uri = g_file_get_uri (dest);
if (position)
{
nautilus_file_changes_queue_schedule_position_set (dest, *position, job->screen_num);
}
else if (eel_uri_is_desktop (dest_uri))
{
nautilus_file_changes_queue_schedule_position_remove (dest);
}
g_hash_table_replace (debuting_files, g_object_ref (dest), GINT_TO_POINTER (TRUE));
}
if (copy_job->is_move)
{
nautilus_file_changes_queue_file_moved (src, dest);
}
else
{
nautilus_file_changes_queue_file_added (dest);
}
if (copy_job->desktop_location != NULL &&
g_file_equal (copy_job->desktop_location, dest_dir) &&
is_trusted_desktop_file (src, job->cancellable))
{
mark_desktop_file_trusted (job,
job->cancellable,
dest,
FALSE);
}
if (job->undo_info != NULL)
{
nautilus_file_undo_info_ext_add_origin_target_pair (NAUTILUS_FILE_UNDO_INFO_EXT (job->undo_info),
src, dest);
}
g_object_unref (dest);
return;
}
if (!handled_invalid_filename &&
IS_IO_ERROR (error, INVALID_FILENAME))
{
handled_invalid_filename = TRUE;
g_assert (*dest_fs_type == NULL);
*dest_fs_type = query_fs_type (dest_dir, job->cancellable);
if (unique_names)
{
new_dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr);
}
else
{
new_dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);
}
if (!g_file_equal (dest, new_dest))
{
g_object_unref (dest);
dest = new_dest;
g_error_free (error);
goto retry;
}
else
{
g_object_unref (new_dest);
}
}
if (!overwrite &&
IS_IO_ERROR (error, EXISTS))
{
gboolean is_merge;
FileConflictResponse *response;
g_error_free (error);
if (unique_names)
{
g_object_unref (dest);
dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr++);
goto retry;
}
is_merge = FALSE;
if (is_dir (dest) && is_dir (src))
{
is_merge = TRUE;
}
if ((is_merge && job->merge_all) ||
(!is_merge && job->replace_all))
{
overwrite = TRUE;
goto retry;
}
if (job->skip_all_conflict)
{
goto out;
}
response = handle_copy_move_conflict (job, src, dest, dest_dir);
if (response->id == GTK_RESPONSE_CANCEL ||
response->id == GTK_RESPONSE_DELETE_EVENT)
{
file_conflict_response_free (response);
abort_job (job);
}
else if (response->id == CONFLICT_RESPONSE_SKIP)
{
if (response->apply_to_all)
{
job->skip_all_conflict = TRUE;
}
file_conflict_response_free (response);
}
else if (response->id == CONFLICT_RESPONSE_REPLACE)             
{
if (response->apply_to_all)
{
if (is_merge)
{
job->merge_all = TRUE;
}
else
{
job->replace_all = TRUE;
}
}
overwrite = TRUE;
file_conflict_response_free (response);
goto retry;
}
else if (response->id == CONFLICT_RESPONSE_RENAME)
{
g_object_unref (dest);
dest = get_target_file_for_display_name (dest_dir,
response->new_name);
file_conflict_response_free (response);
goto retry;
}
else
{
g_assert_not_reached ();
}
}
else if (overwrite &&
IS_IO_ERROR (error, IS_DIRECTORY))
{
gboolean existing_file_deleted;
DeleteExistingFileData data;
g_error_free (error);
data.job = job;
data.source = src;
existing_file_deleted =
delete_file_recursively (dest,
job->cancellable,
existing_file_removed_callback,
&data);
if (existing_file_deleted)
{
goto retry;
}
}
else if (IS_IO_ERROR (error, WOULD_RECURSE) ||
IS_IO_ERROR (error, WOULD_MERGE))
{
is_merge = error->code == G_IO_ERROR_WOULD_MERGE;
would_recurse = error->code == G_IO_ERROR_WOULD_RECURSE;
g_error_free (error);
if (overwrite && would_recurse)
{
error = NULL;
if (!g_file_delete (dest, job->cancellable, &error) &&
!IS_IO_ERROR (error, NOT_FOUND))
{
if (job->skip_all_error)
{
g_error_free (error);
goto out;
}
if (copy_job->is_move)
{
primary = f (_(""Error while moving %B.""), src);
}
else
{
primary = f (_(""Error while copying %B.""), src);
}
secondary = f (_(""Could not remove the already existing file with the same name in %F.""), dest_dir);
details = error->message;
response = run_warning (job,
primary,
secondary,
details,
TRUE,
CANCEL, SKIP_ALL, SKIP,
NULL);
g_error_free (error);
if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
{
abort_job (job);
}
else if (response == 1)                     
{
job->skip_all_error = TRUE;
}
else if (response == 2)                     
{                       
}
else
{
g_assert_not_reached ();
}
goto out;
}
if (error)
{
g_error_free (error);
error = NULL;
}
nautilus_file_changes_queue_file_removed (dest);
}
if (is_merge)
{
same_fs = FALSE;
}
if (!copy_move_directory (copy_job, src, &dest, same_fs,
would_recurse, dest_fs_type,
source_info, transfer_info,
debuting_files, skipped_file,
readonly_source_fs))
{
g_assert (*dest_fs_type != NULL);
handled_invalid_filename = TRUE;
goto retry;
}
g_object_unref (dest);
return;
}
else if (IS_IO_ERROR (error, CANCELLED))
{
g_error_free (error);
}
else
{
if (job->skip_all_error)
{
g_error_free (error);
goto out;
}
primary = f (_(""Error while copying %B.""), src);
secondary = f (_(""There was an error copying the file into %F.""), dest_dir);
details = error->message;
response = run_cancel_or_skip_warning (job,
primary,
secondary,
details,
source_info->num_files,
source_info->num_files - transfer_info->num_files);
g_error_free (error);
if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
{
abort_job (job);
}
else if (response == 1)             
{
job->skip_all_error = TRUE;
}
else if (response == 2)             
{               
}
else
{
g_assert_not_reached ();
}
}
out:
*skipped_file = TRUE;     
g_object_unref (dest);
}","static void
copy_move_file (CopyMoveJob   *VAR_0,
GFile         *VAR_1,
GFile         *VAR_2,
gboolean       VAR_3,
gboolean       VAR_4,
char         **VAR_5,
SourceInfo    *VAR_6,
TransferInfo  *VAR_7,
GHashTable    *VAR_8,
GdkPoint      *VAR_9,
gboolean       VAR_10,
gboolean      *VAR_11,
gboolean       VAR_12)
{
GFile *VAR_13, *VAR_14;
g_autofree VAR_15 *VAR_16 = NULL;
GError *VAR_17;
GFileCopyFlags VAR_18;
char *VAR_19, *VAR_20, *VAR_21;
int VAR_22;
ProgressData VAR_23;
gboolean VAR_24, VAR_25;
CommonJob *VAR_26;
gboolean VAR_27;
int VAR_28;
gboolean VAR_29;
VAR_26 = (CommonJob *) VAR_0;
if (should_skip_file (VAR_26, VAR_1))
{
*VAR_11 = TRUE;
return;
}
VAR_28 = 1;
VAR_29 = *VAR_5 != NULL;
if (VAR_4)
{
VAR_13 = get_unique_target_file (VAR_1, VAR_2, VAR_3, *VAR_5, VAR_28++);
}
else if (VAR_0->target_name != NULL)
{
VAR_13 = get_target_file_with_custom_name (VAR_1, VAR_2, *VAR_5, VAR_3,
VAR_0->target_name);
}
else
{
VAR_13 = get_target_file (VAR_1, VAR_2, *VAR_5, VAR_3);
}
if (test_dir_is_parent (VAR_2, VAR_1))
{
if (VAR_26->skip_all_error)
{
goto out;
}
VAR_19 = VAR_0->is_move ? g_strdup (_(""You cannot move a folder into itself.""))
: g_strdup (_(""You cannot copy a folder into itself.""));
VAR_20 = g_strdup (_(""The destination folder is inside the source folder.""));
VAR_22 = run_cancel_or_skip_warning (VAR_26,
VAR_19,
VAR_20,
NULL,
VAR_6->num_files,
VAR_6->num_files - VAR_7->num_files);
if (VAR_22 == 0 || VAR_22 == VAR_30)
{
abort_job (VAR_26);
}
else if (VAR_22 == 1)             
{
VAR_26->skip_all_error = TRUE;
}
else if (VAR_22 == 2)             
{               
}
else
{
g_assert_not_reached ();
}
goto out;
}
if (test_dir_is_parent (VAR_1, VAR_13))
{
if (VAR_26->skip_all_error)
{
goto out;
}
VAR_19 = VAR_0->is_move ? g_strdup (_(""You cannot move a file over itself.""))
: g_strdup (_(""You cannot copy a file over itself.""));
VAR_20 = g_strdup (_(""The source file would be overwritten by the destination.""));
VAR_22 = run_cancel_or_skip_warning (VAR_26,
VAR_19,
VAR_20,
NULL,
VAR_6->num_files,
VAR_6->num_files - VAR_7->num_files);
if (VAR_22 == 0 || VAR_22 == VAR_30)
{
abort_job (VAR_26);
}
else if (VAR_22 == 1)             
{
VAR_26->skip_all_error = TRUE;
}
else if (VAR_22 == 2)             
{               
}
else
{
g_assert_not_reached ();
}
goto out;
}
retry:
VAR_17 = NULL;
VAR_18 = VAR_31;
if (VAR_10)
{
VAR_18 |= VAR_32;
}
if (VAR_12)
{
VAR_18 |= VAR_33;
}
VAR_23.job = VAR_0;
VAR_23.last_size = 0;
VAR_23.source_info = VAR_6;
VAR_23.transfer_info = VAR_7;
if (VAR_0->is_move)
{
VAR_27 = g_file_move (VAR_1, VAR_13,
VAR_18,
VAR_26->cancellable,
VAR_34,
&VAR_23,
&VAR_17);
}
else
{
VAR_27 = g_file_copy (VAR_1, VAR_13,
VAR_18,
VAR_26->cancellable,
VAR_34,
&VAR_23,
&VAR_17);
}
if (VAR_27)
{
GFile *VAR_35;
VAR_35 = map_possibly_volatile_file_to_real (VAR_13, VAR_26->cancellable, &VAR_17);
if (VAR_35 == NULL)
{
VAR_27 = FALSE;
}
else
{
g_object_unref (VAR_13);
VAR_13 = VAR_35;
}
}
if (VAR_27)
{
VAR_7->num_files++;
report_copy_progress (VAR_0, VAR_6, VAR_7);
if (VAR_8)
{
VAR_16 = g_file_get_uri (VAR_13);
if (VAR_9)
{
nautilus_file_changes_queue_schedule_position_set (VAR_13, *VAR_9, VAR_26->screen_num);
}
else if (eel_uri_is_desktop (VAR_16))
{
nautilus_file_changes_queue_schedule_position_remove (VAR_13);
}
g_hash_table_replace (VAR_8, g_object_ref (VAR_13), GINT_TO_POINTER (TRUE));
}
if (VAR_0->is_move)
{
nautilus_file_changes_queue_file_moved (VAR_1, VAR_13);
}
else
{
nautilus_file_changes_queue_file_added (VAR_13);
}
if (VAR_0->desktop_location != NULL &&
g_file_equal (VAR_0->desktop_location, VAR_2) &&
is_trusted_desktop_file (VAR_1, VAR_26->cancellable))
{
mark_desktop_file_trusted (VAR_26,
VAR_26->cancellable,
VAR_13,
FALSE);
}
if (VAR_26->undo_info != NULL)
{
nautilus_file_undo_info_ext_add_origin_target_pair (NAUTILUS_FILE_UNDO_INFO_EXT (VAR_26->undo_info),
VAR_1, VAR_13);
}
g_object_unref (VAR_13);
return;
}
if (!VAR_29 &&
IS_IO_ERROR (VAR_17, VAR_36))
{
VAR_29 = TRUE;
g_assert (*VAR_5 == NULL);
*VAR_5 = query_fs_type (VAR_2, VAR_26->cancellable);
if (VAR_4)
{
VAR_14 = get_unique_target_file (VAR_1, VAR_2, VAR_3, *VAR_5, VAR_28);
}
else
{
VAR_14 = get_target_file (VAR_1, VAR_2, *VAR_5, VAR_3);
}
if (!g_file_equal (VAR_13, VAR_14))
{
g_object_unref (VAR_13);
VAR_13 = VAR_14;
g_error_free (VAR_17);
goto retry;
}
else
{
g_object_unref (VAR_14);
}
}
if (!VAR_10 &&
IS_IO_ERROR (VAR_17, VAR_37))
{
gboolean VAR_25;
FileConflictResponse *VAR_22;
g_error_free (VAR_17);
if (VAR_4)
{
g_object_unref (VAR_13);
VAR_13 = get_unique_target_file (VAR_1, VAR_2, VAR_3, *VAR_5, VAR_28++);
goto retry;
}
VAR_25 = FALSE;
if (is_dir (VAR_13) && is_dir (VAR_1))
{
VAR_25 = TRUE;
}
if ((VAR_25 && VAR_26->merge_all) ||
(!VAR_25 && VAR_26->replace_all))
{
VAR_10 = TRUE;
goto retry;
}
if (VAR_26->skip_all_conflict)
{
goto out;
}
VAR_22 = handle_copy_move_conflict (VAR_26, VAR_1, VAR_13, VAR_2);
if (VAR_22->id == VAR_38 ||
VAR_22->id == VAR_30)
{
file_conflict_response_free (VAR_22);
abort_job (VAR_26);
}
else if (VAR_22->id == VAR_39)
{
if (VAR_22->apply_to_all)
{
VAR_26->skip_all_conflict = TRUE;
}
file_conflict_response_free (VAR_22);
}
else if (VAR_22->id == VAR_40)             
{
if (VAR_22->apply_to_all)
{
if (VAR_25)
{
VAR_26->merge_all = TRUE;
}
else
{
VAR_26->replace_all = TRUE;
}
}
VAR_10 = TRUE;
file_conflict_response_free (VAR_22);
goto retry;
}
else if (VAR_22->id == VAR_41)
{
g_object_unref (VAR_13);
VAR_13 = get_target_file_for_display_name (VAR_2,
VAR_22->new_name);
file_conflict_response_free (VAR_22);
goto retry;
}
else
{
g_assert_not_reached ();
}
}
else if (VAR_10 &&
IS_IO_ERROR (VAR_17, VAR_42))
{
gboolean VAR_43;
DeleteExistingFileData VAR_44;
g_error_free (VAR_17);
VAR_44.job = VAR_26;
VAR_44.source = VAR_1;
VAR_43 =
delete_file_recursively (VAR_13,
VAR_26->cancellable,
VAR_45,
&VAR_44);
if (VAR_43)
{
goto retry;
}
}
else if (IS_IO_ERROR (VAR_17, VAR_46) ||
IS_IO_ERROR (VAR_17, VAR_47))
{
VAR_25 = VAR_17->code == VAR_48;
VAR_24 = VAR_17->code == VAR_49;
g_error_free (VAR_17);
if (VAR_10 && VAR_24)
{
VAR_17 = NULL;
if (!g_file_delete (VAR_13, VAR_26->cancellable, &VAR_17) &&
!IS_IO_ERROR (VAR_17, VAR_50))
{
if (VAR_26->skip_all_error)
{
g_error_free (VAR_17);
goto out;
}
if (VAR_0->is_move)
{
VAR_19 = f (_(""Error while moving %B.""), src)$$$$;
$$$$                }
else
{
VAR_19 = f (_(""Error while copying %B.""), src)$$$$;
$$$$                }
VAR_20 = f (_(""Could not remove the already existing file with the same name in %F.""), VAR_2);
VAR_21 = VAR_17->message;
VAR_22 = run_warning (VAR_26,
VAR_19,
VAR_20,
VAR_21,
TRUE,
VAR_51, VAR_52, VAR_53,
NULL);
g_error_free (VAR_17);
if (VAR_22 == 0 || VAR_22 == VAR_30)
{
abort_job (VAR_26);
}
else if (VAR_22 == 1)                     
{
VAR_26->skip_all_error = TRUE;
}
else if (VAR_22 == 2)                     
{                       
}
else
{
g_assert_not_reached ();
}
goto out;
}
if (VAR_17)
{
g_error_free (VAR_17);
VAR_17 = NULL;
}
nautilus_file_changes_queue_file_removed (VAR_13);
}
if (VAR_25)
{
VAR_3 = FALSE;
}
if (!copy_move_directory (VAR_0, VAR_1, &VAR_13, VAR_3,
VAR_24, VAR_5,
VAR_6, VAR_7,
VAR_8, VAR_11,
VAR_12))
{
g_assert (*VAR_5 != NULL);
VAR_29 = TRUE;
goto retry;
}
g_object_unref (VAR_13);
return;
}
else if (IS_IO_ERROR (VAR_17, VAR_54))
{
g_error_free (VAR_17);
}
else
{
if (VAR_26->skip_all_error)
{
g_error_free (VAR_17);
goto out;
}
VAR_19 = f (_(""Error while copying %B.""), src)$$$$;
$$$$        VAR_20 = f (_(""There was an error copying the file into %F.""), VAR_2);
VAR_21 = VAR_17->message;
VAR_22 = run_cancel_or_skip_warning (VAR_26,
VAR_19,
VAR_20,
VAR_21,
VAR_6->num_files,
VAR_6->num_files - VAR_7->num_files);
g_error_free (VAR_17);
if (VAR_22 == 0 || VAR_22 == VAR_30)
{
abort_job (VAR_26);
}
else if (VAR_22 == 1)             
{
VAR_26->skip_all_error = TRUE;
}
else if (VAR_22 == 2)             
{               
}
else
{
g_assert_not_reached ();
}
}
out:
*VAR_11 = TRUE;     
g_object_unref (VAR_13);
}",GNOME/nautilus/1630f53481f445ada0a455e9979236d31a8d3bb0/nautilus-file-operations.c/vul/before/0.json,"static void
copy_move_file (CopyMoveJob   *copy_job,
                GFile         *src,
                GFile         *dest_dir,
                gboolean       same_fs,
                gboolean       unique_names,
                char         **dest_fs_type,
                SourceInfo    *source_info,
                TransferInfo  *transfer_info,
                GHashTable    *debuting_files,
                GdkPoint      *position,
                gboolean       overwrite,
                gboolean      *skipped_file,
                gboolean       readonly_source_fs)
{
    GFile *dest, *new_dest;
    g_autofree gchar *dest_uri = NULL;
    GError *error;
    GFileCopyFlags flags;
    char *primary, *secondary, *details;
    int response;
    ProgressData pdata;
    gboolean would_recurse, is_merge;
    CommonJob *job;
    gboolean res;
    int unique_name_nr;
    gboolean handled_invalid_filename;

    job = (CommonJob *) copy_job;

    if (should_skip_file (job, src))
    {
        *skipped_file = TRUE;
        return;
    }

    unique_name_nr = 1;

    /* another file in the same directory might have handled the invalid
     * filename condition for us
     */
    handled_invalid_filename = *dest_fs_type != NULL;

    if (unique_names)
    {
        dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr++);
    }
    else if (copy_job->target_name != NULL)
    {
        dest = get_target_file_with_custom_name (src, dest_dir, *dest_fs_type, same_fs,
                                                 copy_job->target_name);
    }
    else
    {
        dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);
    }

    /* Don't allow recursive move/copy into itself.
     * (We would get a file system error if we proceeded but it is nicer to
     * detect and report it at this level) */
    if (test_dir_is_parent (dest_dir, src))
    {
        if (job->skip_all_error)
        {
            goto out;
        }

        /*  the run_warning() frees all strings passed in automatically  */
        primary = copy_job->is_move ? g_strdup (_(""You cannot move a folder into itself.""))
                  : g_strdup (_(""You cannot copy a folder into itself.""));
        secondary = g_strdup (_(""The destination folder is inside the source folder.""));

        response = run_cancel_or_skip_warning (job,
                                               primary,
                                               secondary,
                                               NULL,
                                               source_info->num_files,
                                               source_info->num_files - transfer_info->num_files);

        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
        {
            abort_job (job);
        }
        else if (response == 1)             /* skip all */
        {
            job->skip_all_error = TRUE;
        }
        else if (response == 2)             /* skip */
        {               /* do nothing */
        }
        else
        {
            g_assert_not_reached ();
        }

        goto out;
    }

    /* Don't allow copying over the source or one of the parents of the source.
     */
    if (test_dir_is_parent (src, dest))
    {
        if (job->skip_all_error)
        {
            goto out;
        }

        /*  the run_warning() frees all strings passed in automatically  */
        primary = copy_job->is_move ? g_strdup (_(""You cannot move a file over itself.""))
                  : g_strdup (_(""You cannot copy a file over itself.""));
        secondary = g_strdup (_(""The source file would be overwritten by the destination.""));

        response = run_cancel_or_skip_warning (job,
                                               primary,
                                               secondary,
                                               NULL,
                                               source_info->num_files,
                                               source_info->num_files - transfer_info->num_files);

        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
        {
            abort_job (job);
        }
        else if (response == 1)             /* skip all */
        {
            job->skip_all_error = TRUE;
        }
        else if (response == 2)             /* skip */
        {               /* do nothing */
        }
        else
        {
            g_assert_not_reached ();
        }

        goto out;
    }


retry:

    error = NULL;
    flags = G_FILE_COPY_NOFOLLOW_SYMLINKS;
    if (overwrite)
    {
        flags |= G_FILE_COPY_OVERWRITE;
    }
    if (readonly_source_fs)
    {
        flags |= G_FILE_COPY_TARGET_DEFAULT_PERMS;
    }

    pdata.job = copy_job;
    pdata.last_size = 0;
    pdata.source_info = source_info;
    pdata.transfer_info = transfer_info;

    if (copy_job->is_move)
    {
        res = g_file_move (src, dest,
                           flags,
                           job->cancellable,
                           copy_file_progress_callback,
                           &pdata,
                           &error);
    }
    else
    {
        res = g_file_copy (src, dest,
                           flags,
                           job->cancellable,
                           copy_file_progress_callback,
                           &pdata,
                           &error);
    }

    if (res)
    {
        GFile *real;

        real = map_possibly_volatile_file_to_real (dest, job->cancellable, &error);
        if (real == NULL)
        {
            res = FALSE;
        }
        else
        {
            g_object_unref (dest);
            dest = real;
        }
    }

    if (res)
    {
        transfer_info->num_files++;
        report_copy_progress (copy_job, source_info, transfer_info);

        if (debuting_files)
        {
            dest_uri = g_file_get_uri (dest);
            if (position)
            {
                nautilus_file_changes_queue_schedule_position_set (dest, *position, job->screen_num);
            }
            else if (eel_uri_is_desktop (dest_uri))
            {
                nautilus_file_changes_queue_schedule_position_remove (dest);
            }

            g_hash_table_replace (debuting_files, g_object_ref (dest), GINT_TO_POINTER (TRUE));
        }
        if (copy_job->is_move)
        {
            nautilus_file_changes_queue_file_moved (src, dest);
        }
        else
        {
            nautilus_file_changes_queue_file_added (dest);
        }

        /* If copying a trusted desktop file to the desktop,
         *  mark it as trusted. */
        if (copy_job->desktop_location != NULL &&
            g_file_equal (copy_job->desktop_location, dest_dir) &&
            is_trusted_desktop_file (src, job->cancellable))
        {
            mark_desktop_file_executable (job,
                                          job->cancellable,
                                          dest,
                                          FALSE);
        }

        if (job->undo_info != NULL)
        {
            nautilus_file_undo_info_ext_add_origin_target_pair (NAUTILUS_FILE_UNDO_INFO_EXT (job->undo_info),
                                                                src, dest);
        }

        g_object_unref (dest);
        return;
    }

    if (!handled_invalid_filename &&
        IS_IO_ERROR (error, INVALID_FILENAME))
    {
        handled_invalid_filename = TRUE;

        g_assert (*dest_fs_type == NULL);
        *dest_fs_type = query_fs_type (dest_dir, job->cancellable);

        if (unique_names)
        {
            new_dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr);
        }
        else
        {
            new_dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);
        }

        if (!g_file_equal (dest, new_dest))
        {
            g_object_unref (dest);
            dest = new_dest;

            g_error_free (error);
            goto retry;
        }
        else
        {
            g_object_unref (new_dest);
        }
    }

    /* Conflict */
    if (!overwrite &&
        IS_IO_ERROR (error, EXISTS))
    {
        gboolean is_merge;
        FileConflictResponse *response;

        g_error_free (error);

        if (unique_names)
        {
            g_object_unref (dest);
            dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr++);
            goto retry;
        }

        is_merge = FALSE;

        if (is_dir (dest) && is_dir (src))
        {
            is_merge = TRUE;
        }

        if ((is_merge && job->merge_all) ||
            (!is_merge && job->replace_all))
        {
            overwrite = TRUE;
            goto retry;
        }

        if (job->skip_all_conflict)
        {
            goto out;
        }

        response = handle_copy_move_conflict (job, src, dest, dest_dir);

        if (response->id == GTK_RESPONSE_CANCEL ||
            response->id == GTK_RESPONSE_DELETE_EVENT)
        {
            file_conflict_response_free (response);
            abort_job (job);
        }
        else if (response->id == CONFLICT_RESPONSE_SKIP)
        {
            if (response->apply_to_all)
            {
                job->skip_all_conflict = TRUE;
            }
            file_conflict_response_free (response);
        }
        else if (response->id == CONFLICT_RESPONSE_REPLACE)             /* merge/replace */
        {
            if (response->apply_to_all)
            {
                if (is_merge)
                {
                    job->merge_all = TRUE;
                }
                else
                {
                    job->replace_all = TRUE;
                }
            }
            overwrite = TRUE;
            file_conflict_response_free (response);
            goto retry;
        }
        else if (response->id == CONFLICT_RESPONSE_RENAME)
        {
            g_object_unref (dest);
            dest = get_target_file_for_display_name (dest_dir,
                                                     response->new_name);
            file_conflict_response_free (response);
            goto retry;
        }
        else
        {
            g_assert_not_reached ();
        }
    }
    else if (overwrite &&
             IS_IO_ERROR (error, IS_DIRECTORY))
    {
        gboolean existing_file_deleted;
        DeleteExistingFileData data;

        g_error_free (error);

        data.job = job;
        data.source = src;

        existing_file_deleted =
            delete_file_recursively (dest,
                                     job->cancellable,
                                     existing_file_removed_callback,
                                     &data);

        if (existing_file_deleted)
        {
            goto retry;
        }
    }
    /* Needs to recurse */
    else if (IS_IO_ERROR (error, WOULD_RECURSE) ||
             IS_IO_ERROR (error, WOULD_MERGE))
    {
        is_merge = error->code == G_IO_ERROR_WOULD_MERGE;
        would_recurse = error->code == G_IO_ERROR_WOULD_RECURSE;
        g_error_free (error);

        if (overwrite && would_recurse)
        {
            error = NULL;

            /* Copying a dir onto file, first remove the file */
            if (!g_file_delete (dest, job->cancellable, &error) &&
                !IS_IO_ERROR (error, NOT_FOUND))
            {
                if (job->skip_all_error)
                {
                    g_error_free (error);
                    goto out;
                }
                if (copy_job->is_move)
                {
                    primary = f (_(""Error while moving %B.""), src);
                }
                else
                {
                    primary = f (_(""Error while copying %B.""), src);
                }
                secondary = f (_(""Could not remove the already existing file with the same name in %F.""), dest_dir);
                details = error->message;

                /* setting TRUE on show_all here, as we could have
                 * another error on the same file later.
                 */
                response = run_warning (job,
                                        primary,
                                        secondary,
                                        details,
                                        TRUE,
                                        CANCEL, SKIP_ALL, SKIP,
                                        NULL);

                g_error_free (error);

                if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
                {
                    abort_job (job);
                }
                else if (response == 1)                     /* skip all */
                {
                    job->skip_all_error = TRUE;
                }
                else if (response == 2)                     /* skip */
                {                       /* do nothing */
                }
                else
                {
                    g_assert_not_reached ();
                }
                goto out;
            }
            if (error)
            {
                g_error_free (error);
                error = NULL;
            }
            nautilus_file_changes_queue_file_removed (dest);
        }

        if (is_merge)
        {
            /* On merge we now write in the target directory, which may not
             *   be in the same directory as the source, even if the parent is
             *   (if the merged directory is a mountpoint). This could cause
             *   problems as we then don't transcode filenames.
             *   We just set same_fs to FALSE which is safe but a bit slower. */
            same_fs = FALSE;
        }

        if (!copy_move_directory (copy_job, src, &dest, same_fs,
                                  would_recurse, dest_fs_type,
                                  source_info, transfer_info,
                                  debuting_files, skipped_file,
                                  readonly_source_fs))
        {
            /* destination changed, since it was an invalid file name */
            g_assert (*dest_fs_type != NULL);
            handled_invalid_filename = TRUE;
            goto retry;
        }

        g_object_unref (dest);
        return;
    }
    else if (IS_IO_ERROR (error, CANCELLED))
    {
        g_error_free (error);
    }
    /* Other error */
    else
    {
        if (job->skip_all_error)
        {
            g_error_free (error);
            goto out;
        }
        primary = f (_(""Error while copying %B.""), src);
        secondary = f (_(""There was an error copying the file into %F.""), dest_dir);
        details = error->message;

        response = run_cancel_or_skip_warning (job,
                                               primary,
                                               secondary,
                                               details,
                                               source_info->num_files,
                                               source_info->num_files - transfer_info->num_files);

        g_error_free (error);

        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
        {
            abort_job (job);
        }
        else if (response == 1)             /* skip all */
        {
            job->skip_all_error = TRUE;
        }
        else if (response == 2)             /* skip */
        {               /* do nothing */
        }
        else
        {
            g_assert_not_reached ();
        }
    }
out:
    *skipped_file = TRUE;     /* Or aborted, but same-same */
    g_object_unref (dest);
}","static void
copy_move_file (CopyMoveJob   *VAR_0,
                GFile         *VAR_1,
                GFile         *VAR_2,
                gboolean       VAR_3,
                gboolean       VAR_4,
                char         **VAR_5,
                SourceInfo    *VAR_6,
                TransferInfo  *VAR_7,
                GHashTable    *VAR_8,
                GdkPoint      *VAR_9,
                gboolean       VAR_10,
                gboolean      *VAR_11,
                gboolean       VAR_12)
{
    GFile *VAR_13, *VAR_14;
    g_autofree VAR_15 *VAR_16 = NULL;
    GError *VAR_17;
    GFileCopyFlags VAR_18;
    char *VAR_19, *VAR_20, *VAR_21;
    int VAR_22;
    ProgressData VAR_23;
    gboolean VAR_24, VAR_25;
    CommonJob *VAR_26;
    gboolean VAR_27;
    int VAR_28;
    gboolean VAR_29;

    VAR_26 = (CommonJob *) VAR_0;

    if (should_skip_file (VAR_26, VAR_1))
    {
        *VAR_11 = TRUE;
        return;
    }

    VAR_28 = 1;

    /* COMMENT_0 */
                                
       
    VAR_29 = *VAR_5 != NULL;

    if (VAR_4)
    {
        VAR_13 = get_unique_target_file (VAR_1, VAR_2, VAR_3, *VAR_5, VAR_28++);
    }
    else if (VAR_0->target_name != NULL)
    {
        VAR_13 = get_target_file_with_custom_name (VAR_1, VAR_2, *VAR_5, VAR_3,
                                                 VAR_0->target_name);
    }
    else
    {
        VAR_13 = get_target_file (VAR_1, VAR_2, *VAR_5, VAR_3);
    }

    /* COMMENT_3 */
                                                                           
                                             
    if (test_dir_is_parent (VAR_2, VAR_1))
    {
        if (VAR_26->skip_all_error)
        {
            goto out;
        }

        /* COMMENT_6 */
        VAR_19 = VAR_0->is_move ? g_strdup (_(""You cannot move a folder into itself.""))
                  : g_strdup (_(""You cannot copy a folder into itself.""));
        VAR_20 = g_strdup (_(""The destination folder is inside the source folder.""));

        VAR_22 = run_cancel_or_skip_warning (VAR_26,
                                               VAR_19,
                                               VAR_20,
                                               NULL,
                                               VAR_6->num_files,
                                               VAR_6->num_files - VAR_7->num_files);

        if (VAR_22 == 0 || VAR_22 == VAR_30)
        {
            abort_job (VAR_26);
        }
        else if (VAR_22 == 1)             /* COMMENT_7 */
        {
            VAR_26->skip_all_error = TRUE;
        }
        else if (VAR_22 == 2)             /* COMMENT_8 */
        {               /* COMMENT_9 */
        }
        else
        {
            g_assert_not_reached ();
        }

        goto out;
    }

    /* COMMENT_10 */
       
    if (test_dir_is_parent (VAR_1, VAR_13))
    {
        if (VAR_26->skip_all_error)
        {
            goto out;
        }

        /* COMMENT_6 */
        VAR_19 = VAR_0->is_move ? g_strdup (_(""You cannot move a file over itself.""))
                  : g_strdup (_(""You cannot copy a file over itself.""));
        VAR_20 = g_strdup (_(""The source file would be overwritten by the destination.""));

        VAR_22 = run_cancel_or_skip_warning (VAR_26,
                                               VAR_19,
                                               VAR_20,
                                               NULL,
                                               VAR_6->num_files,
                                               VAR_6->num_files - VAR_7->num_files);

        if (VAR_22 == 0 || VAR_22 == VAR_30)
        {
            abort_job (VAR_26);
        }
        else if (VAR_22 == 1)             /* COMMENT_7 */
        {
            VAR_26->skip_all_error = TRUE;
        }
        else if (VAR_22 == 2)             /* COMMENT_8 */
        {               /* COMMENT_9 */
        }
        else
        {
            g_assert_not_reached ();
        }

        goto out;
    }


retry:

    VAR_17 = NULL;
    VAR_18 = VAR_31;
    if (VAR_10)
    {
        VAR_18 |= VAR_32;
    }
    if (VAR_12)
    {
        VAR_18 |= VAR_33;
    }

    VAR_23.job = VAR_0;
    VAR_23.last_size = 0;
    VAR_23.source_info = VAR_6;
    VAR_23.transfer_info = VAR_7;

    if (VAR_0->is_move)
    {
        VAR_27 = g_file_move (VAR_1, VAR_13,
                           VAR_18,
                           VAR_26->cancellable,
                           VAR_34,
                           &VAR_23,
                           &VAR_17);
    }
    else
    {
        VAR_27 = g_file_copy (VAR_1, VAR_13,
                           VAR_18,
                           VAR_26->cancellable,
                           VAR_34,
                           &VAR_23,
                           &VAR_17);
    }

    if (VAR_27)
    {
        GFile *VAR_35;

        VAR_35 = map_possibly_volatile_file_to_real (VAR_13, VAR_26->cancellable, &VAR_17);
        if (VAR_35 == NULL)
        {
            VAR_27 = FALSE;
        }
        else
        {
            g_object_unref (VAR_13);
            VAR_13 = VAR_35;
        }
    }

    if (VAR_27)
    {
        VAR_7->num_files++;
        report_copy_progress (VAR_0, VAR_6, VAR_7);

        if (VAR_8)
        {
            VAR_16 = g_file_get_uri (VAR_13);
            if (VAR_9)
            {
                nautilus_file_changes_queue_schedule_position_set (VAR_13, *VAR_9, VAR_26->screen_num);
            }
            else if (eel_uri_is_desktop (VAR_16))
            {
                nautilus_file_changes_queue_schedule_position_remove (VAR_13);
            }

            g_hash_table_replace (VAR_8, g_object_ref (VAR_13), GINT_TO_POINTER (TRUE));
        }
        if (VAR_0->is_move)
        {
            nautilus_file_changes_queue_file_moved (VAR_1, VAR_13);
        }
        else
        {
            nautilus_file_changes_queue_file_added (VAR_13);
        }

        /* COMMENT_12 */
                                  
        if (VAR_0->desktop_location != NULL &&
            g_file_equal (VAR_0->desktop_location, VAR_2) &&
            is_trusted_desktop_file (VAR_1, VAR_26->cancellable))
        {
            mark_desktop_file_executable (VAR_26,
                                          VAR_26->cancellable,
                                          VAR_13,
                                          FALSE);
        }

        if (VAR_26->undo_info != NULL)
        {
            nautilus_file_undo_info_ext_add_origin_target_pair (NAUTILUS_FILE_UNDO_INFO_EXT (VAR_26->undo_info),
                                                                VAR_1, VAR_13);
        }

        g_object_unref (VAR_13);
        return;
    }

    if (!VAR_29 &&
        IS_IO_ERROR (VAR_17, VAR_36))
    {
        VAR_29 = TRUE;

        g_assert (*VAR_5 == NULL);
        *VAR_5 = query_fs_type (VAR_2, VAR_26->cancellable);

        if (VAR_4)
        {
            VAR_14 = get_unique_target_file (VAR_1, VAR_2, VAR_3, *VAR_5, VAR_28);
        }
        else
        {
            VAR_14 = get_target_file (VAR_1, VAR_2, *VAR_5, VAR_3);
        }

        if (!g_file_equal (VAR_13, VAR_14))
        {
            g_object_unref (VAR_13);
            VAR_13 = VAR_14;

            g_error_free (VAR_17);
            goto retry;
        }
        else
        {
            g_object_unref (VAR_14);
        }
    }

    /* COMMENT_14 */
    if (!VAR_10 &&
        IS_IO_ERROR (VAR_17, VAR_37))
    {
        gboolean VAR_25;
        FileConflictResponse *VAR_22;

        g_error_free (VAR_17);

        if (VAR_4)
        {
            g_object_unref (VAR_13);
            VAR_13 = get_unique_target_file (VAR_1, VAR_2, VAR_3, *VAR_5, VAR_28++);
            goto retry;
        }

        VAR_25 = FALSE;

        if (is_dir (VAR_13) && is_dir (VAR_1))
        {
            VAR_25 = TRUE;
        }

        if ((VAR_25 && VAR_26->merge_all) ||
            (!VAR_25 && VAR_26->replace_all))
        {
            VAR_10 = TRUE;
            goto retry;
        }

        if (VAR_26->skip_all_conflict)
        {
            goto out;
        }

        VAR_22 = handle_copy_move_conflict (VAR_26, VAR_1, VAR_13, VAR_2);

        if (VAR_22->id == VAR_38 ||
            VAR_22->id == VAR_30)
        {
            file_conflict_response_free (VAR_22);
            abort_job (VAR_26);
        }
        else if (VAR_22->id == VAR_39)
        {
            if (VAR_22->apply_to_all)
            {
                VAR_26->skip_all_conflict = TRUE;
            }
            file_conflict_response_free (VAR_22);
        }
        else if (VAR_22->id == VAR_40)             /* COMMENT_15 */
        {
            if (VAR_22->apply_to_all)
            {
                if (VAR_25)
                {
                    VAR_26->merge_all = TRUE;
                }
                else
                {
                    VAR_26->replace_all = TRUE;
                }
            }
            VAR_10 = TRUE;
            file_conflict_response_free (VAR_22);
            goto retry;
        }
        else if (VAR_22->id == VAR_41)
        {
            g_object_unref (VAR_13);
            VAR_13 = get_target_file_for_display_name (VAR_2,
                                                     VAR_22->new_name);
            file_conflict_response_free (VAR_22);
            goto retry;
        }
        else
        {
            g_assert_not_reached ();
        }
    }
    else if (VAR_10 &&
             IS_IO_ERROR (VAR_17, VAR_42))
    {
        gboolean VAR_43;
        DeleteExistingFileData VAR_44;

        g_error_free (VAR_17);

        VAR_44.job = VAR_26;
        VAR_44.source = VAR_1;

        VAR_43 =
            delete_file_recursively (VAR_13,
                                     VAR_26->cancellable,
                                     VAR_45,
                                     &VAR_44);

        if (VAR_43)
        {
            goto retry;
        }
    }
    /* COMMENT_16 */
    else if (IS_IO_ERROR (VAR_17, VAR_46) ||
             IS_IO_ERROR (VAR_17, VAR_47))
    {
        VAR_25 = VAR_17->code == VAR_48;
        VAR_24 = VAR_17->code == VAR_49;
        g_error_free (VAR_17);

        if (VAR_10 && VAR_24)
        {
            VAR_17 = NULL;

            /* COMMENT_17 */
            if (!g_file_delete (VAR_13, VAR_26->cancellable, &VAR_17) &&
                !IS_IO_ERROR (VAR_17, VAR_50))
            {
                if (VAR_26->skip_all_error)
                {
                    g_error_free (VAR_17);
                    goto out;
                }
                if (VAR_0->is_move)
                {
                    VAR_19 = f (_(""Error while moving %B.""), src)$$$$;
$$$$                }
                else
                {
                    VAR_19 = f (_(""Error while copying %B.""), src)$$$$;
$$$$                }
                VAR_20 = f (_(""Could not remove the already existing file with the same name in %F.""), VAR_2);
                VAR_21 = VAR_17->message;

                /* COMMENT_18 */
                                                        
                   
                VAR_22 = run_warning (VAR_26,
                                        VAR_19,
                                        VAR_20,
                                        VAR_21,
                                        TRUE,
                                        VAR_51, VAR_52, VAR_53,
                                        NULL);

                g_error_free (VAR_17);

                if (VAR_22 == 0 || VAR_22 == VAR_30)
                {
                    abort_job (VAR_26);
                }
                else if (VAR_22 == 1)                     /* COMMENT_7 */
                {
                    VAR_26->skip_all_error = TRUE;
                }
                else if (VAR_22 == 2)                     /* COMMENT_8 */
                {                       /* COMMENT_9 */
                }
                else
                {
                    g_assert_not_reached ();
                }
                goto out;
            }
            if (VAR_17)
            {
                g_error_free (VAR_17);
                VAR_17 = NULL;
            }
            nautilus_file_changes_queue_file_removed (VAR_13);
        }

        if (VAR_25)
        {
            /* COMMENT_21 */
                                                                              
                                                                            
                                                               
                                                                                
            VAR_3 = FALSE;
        }

        if (!copy_move_directory (VAR_0, VAR_1, &VAR_13, VAR_3,
                                  VAR_24, VAR_5,
                                  VAR_6, VAR_7,
                                  VAR_8, VAR_11,
                                  VAR_12))
        {
            /* COMMENT_26 */
            g_assert (*VAR_5 != NULL);
            VAR_29 = TRUE;
            goto retry;
        }

        g_object_unref (VAR_13);
        return;
    }
    else if (IS_IO_ERROR (VAR_17, VAR_54))
    {
        g_error_free (VAR_17);
    }
    /* COMMENT_27 */
    else
    {
        if (VAR_26->skip_all_error)
        {
            g_error_free (VAR_17);
            goto out;
        }
        VAR_19 = f (_(""Error while copying %B.""), src)$$$$;
$$$$        VAR_20 = f (_(""There was an error copying the file into %F.""), VAR_2);
        VAR_21 = VAR_17->message;

        VAR_22 = run_cancel_or_skip_warning (VAR_26,
                                               VAR_19,
                                               VAR_20,
                                               VAR_21,
                                               VAR_6->num_files,
                                               VAR_6->num_files - VAR_7->num_files);

        g_error_free (VAR_17);

        if (VAR_22 == 0 || VAR_22 == VAR_30)
        {
            abort_job (VAR_26);
        }
        else if (VAR_22 == 1)             /* COMMENT_7 */
        {
            VAR_26->skip_all_error = TRUE;
        }
        else if (VAR_22 == 2)             /* COMMENT_8 */
        {               /* COMMENT_9 */
        }
        else
        {
            g_assert_not_reached ();
        }
    }
out:
    *VAR_11 = TRUE;     /* COMMENT_28 */
    g_object_unref (VAR_13);
}",GNOME/nautilus/1630f53481f445ada0a455e9979236d31a8d3bb0/nautilus-file-operations.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -224,10 +224,10 @@
             g_file_equal (copy_job->desktop_location, dest_dir) &&
             is_trusted_desktop_file (src, job->cancellable))
         {
-            mark_desktop_file_trusted (job,
-                                       job->cancellable,
-                                       dest,
-                                       FALSE);
+            mark_desktop_file_executable (job,
+                                          job->cancellable,
+                                          dest,
+                                          FALSE);
         }
 
         if (job->undo_info != NULL)","{'deleted_lines': ['            mark_desktop_file_trusted (job,', '                                       job->cancellable,', '                                       dest,', '                                       FALSE);'], 'added_lines': ['            mark_desktop_file_executable (job,', '                                          job->cancellable,', '                                          dest,', '                                          FALSE);']}",True,"GNOME Nautilus before 3.23.90 allows attackers to spoof a file type by using the .desktop file extension, as demonstrated by an attack in which a .desktop file's Name field ends in .pdf but this file's Exec field launches a malicious ""sh -c"" command. In other words, Nautilus provides no UI indication that a file actually has the potentially unsafe .desktop extension; instead, the UI only shows the .pdf extension. One (slightly) mitigating factor is that an attack requires the .desktop file to have execute permission. The solution is to ask the user to confirm that the file is supposed to be treated as a .desktop file, and then remember the user's answer in the metadata::trusted field.",6.5,MEDIUM,1,test,2017-02-06T17:47:54Z,1
CVE-2017-14604,['CWE-20'],AV:N/AC:L/Au:S/C:N/I:P/A:N,0,GNOME/nautilus,"mime-actions: use file metadata for trusting desktop files

Currently we only trust desktop files that have the executable bit
set, and don't replace the displayed icon or the displayed name until
it's trusted, which prevents for running random programs by a malicious
desktop file.

However, the executable permission is preserved if the desktop file
comes from a compressed file.

To prevent this, add a metadata::trusted metadata to the file once the
user acknowledges the file as trusted. This adds metadata to the file,
which cannot be added unless it has access to the computer.

Also remove the SHEBANG ""trusted"" content we were putting inside the
desktop file, since that doesn't add more security since it can come
with the file itself.

https://bugzilla.gnome.org/show_bug.cgi?id=777991",1630f53481f445ada0a455e9979236d31a8d3bb0,https://github.com/GNOME/nautilus/commit/1630f53481f445ada0a455e9979236d31a8d3bb0,src/nautilus-mime-actions.c,activate_desktop_file,"static void
activate_desktop_file (ActivateParameters *parameters,
NautilusFile       *file)
{
ActivateParametersDesktop *parameters_desktop;
char *primary, *secondary, *display_name;
GtkWidget *dialog;
GdkScreen *screen;
char *uri;
screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));
if (!nautilus_file_is_trusted_link (file))
{
parameters_desktop = g_new0 (ActivateParametersDesktop, 1);
if (parameters->parent_window)
{
parameters_desktop->parent_window = parameters->parent_window;
g_object_add_weak_pointer (G_OBJECT (parameters_desktop->parent_window), (gpointer *) &parameters_desktop->parent_window);
}
parameters_desktop->file = nautilus_file_ref (file);
primary = _(""Untrusted application launcher"");
display_name = nautilus_file_get_display_name (file);
secondary =
g_strdup_printf (_(""The application launcher %s has not been marked as trusted. ""
""If you do not know the source of this file, launching it may be unsafe.""
),
display_name);
dialog = gtk_message_dialog_new (parameters->parent_window,
0,
GTK_MESSAGE_WARNING,
GTK_BUTTONS_NONE,
NULL);
g_object_set (dialog,
""text"", primary,
""secondary-text"", secondary,
NULL);
gtk_dialog_add_button (GTK_DIALOG (dialog),
_(""_Launch Anyway""), RESPONSE_RUN);
if (nautilus_file_can_set_permissions (file))
{
gtk_dialog_add_button (GTK_DIALOG (dialog),
_(""Mark as _Trusted""), RESPONSE_MARK_TRUSTED);
}
gtk_dialog_add_button (GTK_DIALOG (dialog),
_(""_Cancel""), GTK_RESPONSE_CANCEL);
gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);
g_signal_connect (dialog, ""response"",
G_CALLBACK (untrusted_launcher_response_callback),
parameters_desktop);
gtk_widget_show (dialog);
g_free (display_name);
g_free (secondary);
return;
}
uri = nautilus_file_get_uri (file);
DEBUG (""Launching trusted launcher %s"", uri);
nautilus_launch_desktop_file (screen, uri, NULL,
parameters->parent_window);
g_free (uri);
}","static void
activate_desktop_file (ActivateParameters *VAR_0,
NautilusFile       *VAR_1)
{
ActivateParametersDesktop *VAR_2;
char *VAR_3, *VAR_4, *VAR_5;
GtkWidget *VAR_6;
GdkScreen *VAR_7;
char *VAR_8;
VAR_7 = gtk_widget_get_screen (GTK_WIDGET (VAR_0->parent_window));
if (!nautilus_file_is_trusted_link (VAR_1))
{
VAR_2 = g_new0 (ActivateParametersDesktop, 1);
if (VAR_0->parent_window)
{
VAR_2->parent_window = VAR_0->parent_window;
g_object_add_weak_pointer (G_OBJECT (VAR_2->parent_window), (gpointer *) &VAR_2->parent_window);
}
VAR_2->file = nautilus_file_ref (VAR_1);
VAR_3 = _(""Untrusted application launcher"");
VAR_5 = nautilus_file_get_display_name (VAR_1);
VAR_4 =
g_strdup_printf (_(""The application launcher %s has not been marked as trusted. ""
""If you do not know the source of this file, launching it may be unsafe.""
),
VAR_5);
VAR_6 = gtk_message_dialog_new (VAR_0->parent_window,
0,
VAR_9,
VAR_10,
NULL);
g_object_set (VAR_6,
""text"", VAR_3,
""secondary-text"", VAR_4,
NULL);
gtk_dialog_add_button (GTK_DIALOG (VAR_6),
_(""_Launch Anyway""), VAR_11);
if (nautilus_file_can_set_permissions (VAR_1))
{
gtk_dialog_add_button (GTK_DIALOG (VAR_6),
_(""Mark as _Trusted""), VAR_12);
}
gtk_dialog_add_button (GTK_DIALOG (VAR_6),
_(""_Cancel""), VAR_13);
gtk_dialog_set_default_response (GTK_DIALOG (VAR_6), VAR_13);
g_signal_connect (VAR_6, ""response"",
G_CALLBACK (VAR_14),
VAR_2);
gtk_widget_show (VAR_6);
g_free (VAR_5);
g_free (VAR_4);
return;
}
VAR_8 = nautilus_file_get_uri (VAR_1);
DEBUG (""Launching trusted launcher %s"", VAR_8);
nautilus_launch_desktop_file (VAR_7, VAR_8, NULL,
VAR_0->parent_window);
g_free (VAR_8);
}",GNOME/nautilus/1630f53481f445ada0a455e9979236d31a8d3bb0/nautilus-mime-actions.c/vul/before/0.json,"static void
activate_desktop_file (ActivateParameters *parameters,
                       NautilusFile       *file)
{
    ActivateParametersDesktop *parameters_desktop;
    char *primary, *secondary, *display_name;
    GtkWidget *dialog;
    GdkScreen *screen;
    char *uri;

    screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));

    if (!nautilus_file_is_trusted_link (file))
    {
        /* copy the parts of parameters we are interested in as the orignal will be freed */
        parameters_desktop = g_new0 (ActivateParametersDesktop, 1);
        if (parameters->parent_window)
        {
            parameters_desktop->parent_window = parameters->parent_window;
            g_object_add_weak_pointer (G_OBJECT (parameters_desktop->parent_window), (gpointer *) &parameters_desktop->parent_window);
        }
        parameters_desktop->file = nautilus_file_ref (file);

        primary = _(""Untrusted application launcher"");
        display_name = nautilus_file_get_display_name (file);
        secondary =
            g_strdup_printf (_(""The application launcher %s has not been marked as trusted. ""
                               ""If you do not know the source of this file, launching it may be unsafe.""
                               ),
                             display_name);

        dialog = gtk_message_dialog_new (parameters->parent_window,
                                         0,
                                         GTK_MESSAGE_WARNING,
                                         GTK_BUTTONS_NONE,
                                         NULL);
        g_object_set (dialog,
                      ""text"", primary,
                      ""secondary-text"", secondary,
                      NULL);

        gtk_dialog_add_button (GTK_DIALOG (dialog),
                               _(""_Cancel""), GTK_RESPONSE_CANCEL);

        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);
        if (nautilus_file_can_set_permissions (file))
        {
            gtk_dialog_add_button (GTK_DIALOG (dialog),
                                   _(""Trust and _Launch""), GTK_RESPONSE_OK);
        }
        g_signal_connect (dialog, ""response"",
                          G_CALLBACK (untrusted_launcher_response_callback),
                          parameters_desktop);
        gtk_widget_show (dialog);

        g_free (display_name);
        g_free (secondary);
        return;
    }

    uri = nautilus_file_get_uri (file);
    DEBUG (""Launching trusted launcher %s"", uri);
    nautilus_launch_desktop_file (screen, uri, NULL,
                                  parameters->parent_window);
    g_free (uri);
}","static void
activate_desktop_file (ActivateParameters *VAR_0,
                       NautilusFile       *VAR_1)
{
    ActivateParametersDesktop *VAR_2;
    char *VAR_3, *VAR_4, *VAR_5;
    GtkWidget *VAR_6;
    GdkScreen *VAR_7;
    char *VAR_8;

    VAR_7 = gtk_widget_get_screen (GTK_WIDGET (VAR_0->parent_window));

    if (!nautilus_file_is_trusted_link (VAR_1))
    {
        /* COMMENT_0 */
        VAR_2 = g_new0 (ActivateParametersDesktop, 1);
        if (VAR_0->parent_window)
        {
            VAR_2->parent_window = VAR_0->parent_window;
            g_object_add_weak_pointer (G_OBJECT (VAR_2->parent_window), (gpointer *) &VAR_2->parent_window);
        }
        VAR_2->file = nautilus_file_ref (VAR_1);

        VAR_3 = _(""Untrusted application launcher"");
        VAR_5 = nautilus_file_get_display_name (VAR_1);
        VAR_4 =
            g_strdup_printf (_(""The application launcher %s has not been marked as trusted. ""
                               ""If you do not know the source of this file, launching it may be unsafe.""
                               ),
                             VAR_5);

        VAR_6 = gtk_message_dialog_new (VAR_0->parent_window,
                                         0,
                                         VAR_9,
                                         VAR_10,
                                         NULL);
        g_object_set (VAR_6,
                      ""text"", VAR_3,
                      ""secondary-text"", VAR_4,
                      NULL);

        gtk_dialog_add_button (GTK_DIALOG (VAR_6),
                               _(""_Cancel""), VAR_11);

        gtk_dialog_set_default_response (GTK_DIALOG (VAR_6), VAR_11);
        if (nautilus_file_can_set_permissions (VAR_1))
        {
            gtk_dialog_add_button (GTK_DIALOG (VAR_6),
                                   _(""Trust and _Launch""), VAR_12);
        }
        g_signal_connect (VAR_6, ""response"",
                          G_CALLBACK (VAR_13),
                          VAR_2);
        gtk_widget_show (VAR_6);

        g_free (VAR_5);
        g_free (VAR_4);
        return;
    }

    VAR_8 = nautilus_file_get_uri (VAR_1);
    DEBUG (""Launching trusted launcher %s"", VAR_8);
    nautilus_launch_desktop_file (VAR_7, VAR_8, NULL,
                                  VAR_0->parent_window);
    g_free (VAR_8);
}",GNOME/nautilus/1630f53481f445ada0a455e9979236d31a8d3bb0/nautilus-mime-actions.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -38,17 +38,16 @@
                       ""text"", primary,
                       ""secondary-text"", secondary,
                       NULL);
+
         gtk_dialog_add_button (GTK_DIALOG (dialog),
-                               _(""_Launch Anyway""), RESPONSE_RUN);
+                               _(""_Cancel""), GTK_RESPONSE_CANCEL);
+
+        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);
         if (nautilus_file_can_set_permissions (file))
         {
             gtk_dialog_add_button (GTK_DIALOG (dialog),
-                                   _(""Mark as _Trusted""), RESPONSE_MARK_TRUSTED);
+                                   _(""Trust and _Launch""), GTK_RESPONSE_OK);
         }
-        gtk_dialog_add_button (GTK_DIALOG (dialog),
-                               _(""_Cancel""), GTK_RESPONSE_CANCEL);
-        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);
-
         g_signal_connect (dialog, ""response"",
                           G_CALLBACK (untrusted_launcher_response_callback),
                           parameters_desktop);","{'deleted_lines': ['                               _(""_Launch Anyway""), RESPONSE_RUN);', '                                   _(""Mark as _Trusted""), RESPONSE_MARK_TRUSTED);', '        gtk_dialog_add_button (GTK_DIALOG (dialog),', '                               _(""_Cancel""), GTK_RESPONSE_CANCEL);', '        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);', ''], 'added_lines': ['', '                               _(""_Cancel""), GTK_RESPONSE_CANCEL);', '', '        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);', '                                   _(""Trust and _Launch""), GTK_RESPONSE_OK);']}",True,"GNOME Nautilus before 3.23.90 allows attackers to spoof a file type by using the .desktop file extension, as demonstrated by an attack in which a .desktop file's Name field ends in .pdf but this file's Exec field launches a malicious ""sh -c"" command. In other words, Nautilus provides no UI indication that a file actually has the potentially unsafe .desktop extension; instead, the UI only shows the .pdf extension. One (slightly) mitigating factor is that an attack requires the .desktop file to have execute permission. The solution is to ask the user to confirm that the file is supposed to be treated as a .desktop file, and then remember the user's answer in the metadata::trusted field.",6.5,MEDIUM,1,test,2017-02-06T17:47:54Z,1
CVE-2017-14604,['CWE-20'],AV:N/AC:L/Au:S/C:N/I:P/A:N,0,GNOME/nautilus,"mime-actions: use file metadata for trusting desktop files

Currently we only trust desktop files that have the executable bit
set, and don't replace the displayed icon or the displayed name until
it's trusted, which prevents for running random programs by a malicious
desktop file.

However, the executable permission is preserved if the desktop file
comes from a compressed file.

To prevent this, add a metadata::trusted metadata to the file once the
user acknowledges the file as trusted. This adds metadata to the file,
which cannot be added unless it has access to the computer.

Also remove the SHEBANG ""trusted"" content we were putting inside the
desktop file, since that doesn't add more security since it can come
with the file itself.

https://bugzilla.gnome.org/show_bug.cgi?id=777991",1630f53481f445ada0a455e9979236d31a8d3bb0,https://github.com/GNOME/nautilus/commit/1630f53481f445ada0a455e9979236d31a8d3bb0,src/nautilus-directory-async.c,is_link_trusted,"static gboolean
is_link_trusted (NautilusFile *file,
gboolean      is_launcher)
{
GFile *location;
gboolean res;
if (!is_launcher)
{
return TRUE;
}
if (nautilus_file_can_execute (file))
{
return TRUE;
}
res = FALSE;
if (nautilus_file_is_local (file))
{
location = nautilus_file_get_location (file);
res = nautilus_is_in_system_dir (location);
g_object_unref (location);
}
return res;
}","static gboolean
is_link_trusted (NautilusFile *VAR_0,
gboolean      VAR_1)
{
GFile *VAR_2;
gboolean VAR_3;
if (!VAR_1)
{
return TRUE;
}
if (nautilus_file_can_execute (VAR_0))
{
return TRUE;
}
VAR_3 = FALSE;
if (nautilus_file_is_local (VAR_0))
{
VAR_2 = nautilus_file_get_location (VAR_0);
VAR_3 = nautilus_is_in_system_dir (VAR_2);
g_object_unref (VAR_2);
}
return VAR_3;
}",GNOME/nautilus/1630f53481f445ada0a455e9979236d31a8d3bb0/nautilus-directory-async.c/vul/before/0.json,"static gboolean
is_link_trusted (NautilusFile *file,
                 gboolean      is_launcher)
{
    GFile *location;
    gboolean res;
    g_autofree gchar* trusted = NULL;

    if (!is_launcher)
    {
        return TRUE;
    }

    trusted = nautilus_file_get_metadata (file,
                                          NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,
                                          NULL);
    if (nautilus_file_can_execute (file) && trusted != NULL)
    {
        return TRUE;
    }

    res = FALSE;

    if (nautilus_file_is_local (file))
    {
        location = nautilus_file_get_location (file);
        res = nautilus_is_in_system_dir (location);
        g_object_unref (location);
    }

    return res;
}","static gboolean
is_link_trusted (NautilusFile *VAR_0,
                 gboolean      VAR_1)
{
    GFile *VAR_2;
    gboolean VAR_3;
    g_autofree VAR_4* VAR_5 = NULL;

    if (!VAR_1)
    {
        return TRUE;
    }

    VAR_5 = nautilus_file_get_metadata (VAR_0,
                                          VAR_6,
                                          NULL);
    if (nautilus_file_can_execute (VAR_0) && VAR_5 != NULL)
    {
        return TRUE;
    }

    VAR_3 = FALSE;

    if (nautilus_file_is_local (VAR_0))
    {
        VAR_2 = nautilus_file_get_location (VAR_0);
        VAR_3 = nautilus_is_in_system_dir (VAR_2);
        g_object_unref (VAR_2);
    }

    return VAR_3;
}",GNOME/nautilus/1630f53481f445ada0a455e9979236d31a8d3bb0/nautilus-directory-async.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,13 +4,17 @@
 {
     GFile *location;
     gboolean res;
+    g_autofree gchar* trusted = NULL;
 
     if (!is_launcher)
     {
         return TRUE;
     }
 
-    if (nautilus_file_can_execute (file))
+    trusted = nautilus_file_get_metadata (file,
+                                          NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,
+                                          NULL);
+    if (nautilus_file_can_execute (file) && trusted != NULL)
     {
         return TRUE;
     }","{'deleted_lines': ['    if (nautilus_file_can_execute (file))'], 'added_lines': ['    g_autofree gchar* trusted = NULL;', '    trusted = nautilus_file_get_metadata (file,', '                                          NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,', '                                          NULL);', '    if (nautilus_file_can_execute (file) && trusted != NULL)']}",True,"GNOME Nautilus before 3.23.90 allows attackers to spoof a file type by using the .desktop file extension, as demonstrated by an attack in which a .desktop file's Name field ends in .pdf but this file's Exec field launches a malicious ""sh -c"" command. In other words, Nautilus provides no UI indication that a file actually has the potentially unsafe .desktop extension; instead, the UI only shows the .pdf extension. One (slightly) mitigating factor is that an attack requires the .desktop file to have execute permission. The solution is to ask the user to confirm that the file is supposed to be treated as a .desktop file, and then remember the user's answer in the metadata::trusted field.",6.5,MEDIUM,1,test,2017-02-06T17:47:54Z,1
CVE-2017-6435,['CWE-119'],AV:L/AC:M/Au:N/C:N/I:N/A:P,0,libimobiledevice/libplist,"bplist: Make sure to bail out if malloc() fails in parse_string_node()

Credit to Wang Junjie <zhunkibatu@gmail.com> (#93)",fbd8494d5e4e46bf2e90cb6116903e404374fb56,https://github.com/libimobiledevice/libplist/commit/fbd8494d5e4e46bf2e90cb6116903e404374fb56,src/bplist.c,parse_string_node,"static plist_t parse_string_node(const char **bnode, uint64_t size)
{
plist_data_t data = plist_new_plist_data();
data->type = PLIST_STRING;
data->strval = (char *) malloc(sizeof(char) * (size + 1));
memcpy(data->strval, *bnode, size);
data->strval[size] = '\0';
data->length = strlen(data->strval);
return node_create(NULL, data);
}","static plist_t parse_string_node(const char **VAR_0, uint64_t VAR_1)
{
plist_data_t VAR_2 = plist_new_plist_data();
VAR_2->type = VAR_3;
VAR_2->strval = (char *) malloc(sizeof(char) * (VAR_1 + 1));
memcpy(VAR_2->strval, *VAR_0, VAR_1);
VAR_2->strval[VAR_1] = '\0';
VAR_2->length = strlen(VAR_2->strval);
return node_create(NULL, VAR_2);
}",libimobiledevice/libplist/fbd8494d5e4e46bf2e90cb6116903e404374fb56/bplist.c/vul/before/0.json,"static plist_t parse_string_node(const char **bnode, uint64_t size)
{
    plist_data_t data = plist_new_plist_data();

    data->type = PLIST_STRING;
    data->strval = (char *) malloc(sizeof(char) * (size + 1));
    if (!data->strval) {
        plist_free_data(data);
        PLIST_BIN_ERR(""%s: Could not allocate %"" PRIu64 "" bytes\n"", __func__, sizeof(char) * (size + 1));
        return NULL;
    }
    memcpy(data->strval, *bnode, size);
    data->strval[size] = '\0';
    data->length = strlen(data->strval);

    return node_create(NULL, data);
}","static plist_t parse_string_node(const char **VAR_0, uint64_t VAR_1)
{
    plist_data_t VAR_2 = plist_new_plist_data();

    VAR_2->type = VAR_3;
    VAR_2->strval = (char *) malloc(sizeof(char) * (VAR_1 + 1));
    if (!VAR_2->strval) {
        plist_free_data(VAR_2);
        PLIST_BIN_ERR(""%s: Could not allocate %"" VAR_4 "" bytes\n"", VAR_5, sizeof(char) * (VAR_1 + 1));
        return NULL;
    }
    memcpy(VAR_2->strval, *VAR_0, VAR_1);
    VAR_2->strval[VAR_1] = '\0';
    VAR_2->length = strlen(VAR_2->strval);

    return node_create(NULL, VAR_2);
}",libimobiledevice/libplist/fbd8494d5e4e46bf2e90cb6116903e404374fb56/bplist.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,6 +4,11 @@
 
     data->type = PLIST_STRING;
     data->strval = (char *) malloc(sizeof(char) * (size + 1));
+    if (!data->strval) {
+        plist_free_data(data);
+        PLIST_BIN_ERR(""%s: Could not allocate %"" PRIu64 "" bytes\n"", __func__, sizeof(char) * (size + 1));
+        return NULL;
+    }
     memcpy(data->strval, *bnode, size);
     data->strval[size] = '\0';
     data->length = strlen(data->strval);","{'deleted_lines': [], 'added_lines': ['    if (!data->strval) {', '        plist_free_data(data);', '        PLIST_BIN_ERR(""%s: Could not allocate %"" PRIu64 "" bytes\\n"", __func__, sizeof(char) * (size + 1));', '        return NULL;', '    }']}",True,The parse_string_node function in bplist.c in libimobiledevice libplist 1.12 allows local users to cause a denial of service (memory corruption) via a crafted plist file.,5.0,MEDIUM,1,test,2017-02-07T11:43:27Z,1
CVE-2017-7862,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ffmpeg,"avcodec/pictordec: Fix logic error

Fixes: 559/clusterfuzz-testcase-6424225917173760

Found-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/targets/ffmpeg
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>",8c2ea3030af7b40a3c4275696fb5c76cdb80950a,https://github.com/FFmpeg/FFmpeg/commit/8c2ea3030af7b40a3c4275696fb5c76cdb80950a,libavcodec/pictordec.c,decode_frame,"static int decode_frame(AVCodecContext *avctx,
void *data, int *got_frame,
AVPacket *avpkt)
{
PicContext *s = avctx->priv_data;
AVFrame *frame = data;
uint32_t *palette;
int bits_per_plane, bpp, etype, esize, npal, pos_after_pal;
int i, x, y, plane, tmp, ret, val;
bytestream2_init(&s->g, avpkt->data, avpkt->size);
if (bytestream2_get_bytes_left(&s->g) < 11)
return AVERROR_INVALIDDATA;
if (bytestream2_get_le16u(&s->g) != 0x1234)
return AVERROR_INVALIDDATA;
s->width       = bytestream2_get_le16u(&s->g);
s->height      = bytestream2_get_le16u(&s->g);
bytestream2_skip(&s->g, 4);
tmp            = bytestream2_get_byteu(&s->g);
bits_per_plane = tmp & 0xF;
s->nb_planes   = (tmp >> 4) + 1;
bpp            = bits_per_plane * s->nb_planes;
if (bits_per_plane > 8 || bpp < 1 || bpp > 32) {
avpriv_request_sample(avctx, ""Unsupported bit depth"");
return AVERROR_PATCHWELCOME;
}
if (bytestream2_peek_byte(&s->g) == 0xFF || bpp == 1 || bpp == 4 || bpp == 8) {
bytestream2_skip(&s->g, 2);
etype = bytestream2_get_le16(&s->g);
esize = bytestream2_get_le16(&s->g);
if (bytestream2_get_bytes_left(&s->g) < esize)
return AVERROR_INVALIDDATA;
} else {
etype = -1;
esize = 0;
}
avctx->pix_fmt = AV_PIX_FMT_PAL8;
if (av_image_check_size(s->width, s->height, 0, avctx) < 0)
return -1;
if (s->width != avctx->width && s->height != avctx->height) {
ret = ff_set_dimensions(avctx, s->width, s->height);
if (ret < 0)
return ret;
}
if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
return ret;
memset(frame->data[0], 0, s->height * frame->linesize[0]);
frame->pict_type           = AV_PICTURE_TYPE_I;
frame->palette_has_changed = 1;
pos_after_pal = bytestream2_tell(&s->g) + esize;
palette = (uint32_t*)frame->data[1];
if (etype == 1 && esize > 1 && bytestream2_peek_byte(&s->g) < 6) {
int idx = bytestream2_get_byte(&s->g);
npal = 4;
for (i = 0; i < npal; i++)
palette[i] = ff_cga_palette[ cga_mode45_index[idx][i] ];
} else if (etype == 2) {
npal = FFMIN(esize, 16);
for (i = 0; i < npal; i++) {
int pal_idx = bytestream2_get_byte(&s->g);
palette[i]  = ff_cga_palette[FFMIN(pal_idx, 15)];
}
} else if (etype == 3) {
npal = FFMIN(esize, 16);
for (i = 0; i < npal; i++) {
int pal_idx = bytestream2_get_byte(&s->g);
palette[i]  = ff_ega_palette[FFMIN(pal_idx, 63)];
}
} else if (etype == 4 || etype == 5) {
npal = FFMIN(esize / 3, 256);
for (i = 0; i < npal; i++) {
palette[i] = bytestream2_get_be24(&s->g) << 2;
palette[i] |= 0xFFU << 24 | palette[i] >> 6 & 0x30303;
}
} else {
if (bpp == 1) {
npal = 2;
palette[0] = 0xFF000000;
palette[1] = 0xFFFFFFFF;
} else if (bpp == 2) {
npal = 4;
for (i = 0; i < npal; i++)
palette[i] = ff_cga_palette[ cga_mode45_index[0][i] ];
} else {
npal = 16;
memcpy(palette, ff_cga_palette, npal * 4);
}
}
memset(palette + npal, 0, AVPALETTE_SIZE - npal * 4);
bytestream2_seek(&s->g, pos_after_pal, SEEK_SET);
val = 0;
y = s->height - 1;
if (bytestream2_get_le16(&s->g)) {
x = 0;
plane = 0;
while (bytestream2_get_bytes_left(&s->g) >= 6) {
int stop_size, marker, t1, t2;
t1        = bytestream2_get_bytes_left(&s->g);
t2        = bytestream2_get_le16(&s->g);
stop_size = t1 - FFMIN(t1, t2);
bytestream2_skip(&s->g, 2);
marker    = bytestream2_get_byte(&s->g);
while (plane < s->nb_planes &&
bytestream2_get_bytes_left(&s->g) > stop_size) {
int run = 1;
val = bytestream2_get_byte(&s->g);
if (val == marker) {
run = bytestream2_get_byte(&s->g);
if (run == 0)
run = bytestream2_get_le16(&s->g);
val = bytestream2_get_byte(&s->g);
}
if (!bytestream2_get_bytes_left(&s->g))
break;
if (bits_per_plane == 8) {
picmemset_8bpp(s, frame, val, run, &x, &y);
if (y < 0)
goto finish;
} else {
picmemset(s, frame, val, run, &x, &y, &plane, bits_per_plane);
}
}
}
if (x < avctx->width) {
int run = (y + 1) * avctx->width - x;
if (bits_per_plane == 8)
picmemset_8bpp(s, frame, val, run, &x, &y);
else
picmemset(s, frame, val, run / (8 / bits_per_plane), &x, &y, &plane, bits_per_plane);
}
} else {
while (y >= 0 && bytestream2_get_bytes_left(&s->g) > 0) {
memcpy(frame->data[0] + y * frame->linesize[0], s->g.buffer, FFMIN(avctx->width, bytestream2_get_bytes_left(&s->g)));
bytestream2_skip(&s->g, avctx->width);
y--;
}
}
finish:
*got_frame      = 1;
return avpkt->size;
}","static int decode_frame(AVCodecContext *VAR_0,
void *VAR_1, int *VAR_2,
AVPacket *VAR_3)
{
PicContext *VAR_4 = VAR_0->priv_data;
AVFrame *VAR_5 = VAR_1;
uint32_t *VAR_6;
int VAR_7, VAR_8, VAR_9, VAR_10, VAR_11, VAR_12;
int VAR_13, VAR_14, VAR_15, VAR_16, VAR_17, VAR_18, VAR_19;
bytestream2_init(&VAR_4->g, VAR_3->data, VAR_3->size);
if (bytestream2_get_bytes_left(&VAR_4->g) < 11)
return VAR_20;
if (bytestream2_get_le16u(&VAR_4->g) != 0x1234)
return VAR_20;
VAR_4->width       = bytestream2_get_le16u(&VAR_4->g);
VAR_4->height      = bytestream2_get_le16u(&VAR_4->g);
bytestream2_skip(&VAR_4->g, 4);
VAR_17            = bytestream2_get_byteu(&VAR_4->g);
VAR_7 = VAR_17 & 0xF;
VAR_4->nb_planes   = (VAR_17 >> 4) + 1;
VAR_8            = VAR_7 * VAR_4->nb_planes;
if (VAR_7 > 8 || VAR_8 < 1 || VAR_8 > 32) {
avpriv_request_sample(VAR_0, ""Unsupported bit depth"");
return VAR_21;
}
if (bytestream2_peek_byte(&VAR_4->g) == 0xFF || VAR_8 == 1 || VAR_8 == 4 || VAR_8 == 8) {
bytestream2_skip(&VAR_4->g, 2);
VAR_9 = bytestream2_get_le16(&VAR_4->g);
VAR_10 = bytestream2_get_le16(&VAR_4->g);
if (bytestream2_get_bytes_left(&VAR_4->g) < VAR_10)
return VAR_20;
} else {
VAR_9 = -1;
VAR_10 = 0;
}
VAR_0->pix_fmt = VAR_22;
if (av_image_check_size(VAR_4->width, VAR_4->height, 0, VAR_0) < 0)
return -1;
if (VAR_4->width != VAR_0->width && VAR_4->height != VAR_0->height) {
VAR_18 = ff_set_dimensions(VAR_0, VAR_4->width, VAR_4->height);
if (VAR_18 < 0)
return VAR_18;
}
if ((VAR_18 = ff_get_buffer(VAR_0, VAR_5, 0)) < 0)
return VAR_18;
memset(VAR_5->data[0], 0, VAR_4->height * VAR_5->linesize[0]);
VAR_5->pict_type           = VAR_23;
VAR_5->palette_has_changed = 1;
VAR_12 = bytestream2_tell(&VAR_4->g) + VAR_10;
VAR_6 = (uint32_t*)VAR_5->data[1];
if (VAR_9 == 1 && VAR_10 > 1 && bytestream2_peek_byte(&VAR_4->g) < 6) {
int VAR_24 = bytestream2_get_byte(&VAR_4->g);
VAR_11 = 4;
for (VAR_13 = 0; VAR_13 < VAR_11; VAR_13++)
VAR_6[VAR_13] = VAR_25[ VAR_26[VAR_24][VAR_13] ];
} else if (VAR_9 == 2) {
VAR_11 = FFMIN(VAR_10, 16);
for (VAR_13 = 0; VAR_13 < VAR_11; VAR_13++) {
int VAR_27 = bytestream2_get_byte(&VAR_4->g);
VAR_6[VAR_13]  = VAR_25[FFMIN(VAR_27, 15)];
}
} else if (VAR_9 == 3) {
VAR_11 = FFMIN(VAR_10, 16);
for (VAR_13 = 0; VAR_13 < VAR_11; VAR_13++) {
int VAR_27 = bytestream2_get_byte(&VAR_4->g);
VAR_6[VAR_13]  = VAR_28[FFMIN(VAR_27, 63)];
}
} else if (VAR_9 == 4 || VAR_9 == 5) {
VAR_11 = FFMIN(VAR_10 / 3, 256);
for (VAR_13 = 0; VAR_13 < VAR_11; VAR_13++) {
VAR_6[VAR_13] = bytestream2_get_be24(&VAR_4->g) << 2;
VAR_6[VAR_13] |= 0xFFU << 24 | VAR_6[VAR_13] >> 6 & 0x30303;
}
} else {
if (VAR_8 == 1) {
VAR_11 = 2;
VAR_6[0] = 0xFF000000;
VAR_6[1] = 0xFFFFFFFF;
} else if (VAR_8 == 2) {
VAR_11 = 4;
for (VAR_13 = 0; VAR_13 < VAR_11; VAR_13++)
VAR_6[VAR_13] = VAR_25[ VAR_26[0][VAR_13] ];
} else {
VAR_11 = 16;
memcpy(VAR_6, VAR_25, VAR_11 * 4);
}
}
memset(VAR_6 + VAR_11, 0, VAR_29 - VAR_11 * 4);
bytestream2_seek(&VAR_4->g, VAR_12, VAR_30);
VAR_19 = 0;
VAR_15 = VAR_4->height - 1;
if (bytestream2_get_le16(&VAR_4->g)) {
VAR_14 = 0;
VAR_16 = 0;
while (bytestream2_get_bytes_left(&VAR_4->g) >= 6) {
int VAR_31, VAR_32, VAR_33, VAR_34;
VAR_33        = bytestream2_get_bytes_left(&VAR_4->g);
VAR_34        = bytestream2_get_le16(&VAR_4->g);
VAR_31 = VAR_33 - FFMIN(VAR_33, VAR_34);
bytestream2_skip(&VAR_4->g, 2);
VAR_32    = bytestream2_get_byte(&VAR_4->g);
while (VAR_16 < VAR_4->nb_planes &&
bytestream2_get_bytes_left(&VAR_4->g) > VAR_31) {
int VAR_35 = 1;
VAR_19 = bytestream2_get_byte(&VAR_4->g);
if (VAR_19 == VAR_32) {
VAR_35 = bytestream2_get_byte(&VAR_4->g);
if (VAR_35 == 0)
VAR_35 = bytestream2_get_le16(&VAR_4->g);
VAR_19 = bytestream2_get_byte(&VAR_4->g);
}
if (!bytestream2_get_bytes_left(&VAR_4->g))
break;
if (VAR_7 == 8) {
picmemset_8bpp(VAR_4, VAR_5, VAR_19, VAR_35, &VAR_14, &VAR_15);
if (VAR_15 < 0)
goto finish;
} else {
picmemset(VAR_4, VAR_5, VAR_19, VAR_35, &VAR_14, &VAR_15, &VAR_16, VAR_7);
}
}
}
if (VAR_14 < VAR_0->width) {
int VAR_35 = (VAR_15 + 1) * VAR_0->width - VAR_14;
if (VAR_7 == 8)
picmemset_8bpp(VAR_4, VAR_5, VAR_19, VAR_35, &VAR_14, &VAR_15);
else
picmemset(VAR_4, VAR_5, VAR_19, VAR_35 / (8 / VAR_7), &VAR_14, &VAR_15, &VAR_16, VAR_7);
}
} else {
while (VAR_15 >= 0 && bytestream2_get_bytes_left(&VAR_4->g) > 0) {
memcpy(VAR_5->data[0] + VAR_15 * VAR_5->linesize[0], VAR_4->g.buffer, FFMIN(VAR_0->width, bytestream2_get_bytes_left(&VAR_4->g)));
bytestream2_skip(&VAR_4->g, VAR_0->width);
VAR_15--;
}
}
finish:
*VAR_2      = 1;
return VAR_3->size;
}",ffmpeg/8c2ea3030af7b40a3c4275696fb5c76cdb80950a/pictordec.c/vul/before/0.json,"static int decode_frame(AVCodecContext *avctx,
                        void *data, int *got_frame,
                        AVPacket *avpkt)
{
    PicContext *s = avctx->priv_data;
    AVFrame *frame = data;
    uint32_t *palette;
    int bits_per_plane, bpp, etype, esize, npal, pos_after_pal;
    int i, x, y, plane, tmp, ret, val;

    bytestream2_init(&s->g, avpkt->data, avpkt->size);

    if (bytestream2_get_bytes_left(&s->g) < 11)
        return AVERROR_INVALIDDATA;

    if (bytestream2_get_le16u(&s->g) != 0x1234)
        return AVERROR_INVALIDDATA;

    s->width       = bytestream2_get_le16u(&s->g);
    s->height      = bytestream2_get_le16u(&s->g);
    bytestream2_skip(&s->g, 4);
    tmp            = bytestream2_get_byteu(&s->g);
    bits_per_plane = tmp & 0xF;
    s->nb_planes   = (tmp >> 4) + 1;
    bpp            = bits_per_plane * s->nb_planes;
    if (bits_per_plane > 8 || bpp < 1 || bpp > 32) {
        avpriv_request_sample(avctx, ""Unsupported bit depth"");
        return AVERROR_PATCHWELCOME;
    }

    if (bytestream2_peek_byte(&s->g) == 0xFF || bpp == 1 || bpp == 4 || bpp == 8) {
        bytestream2_skip(&s->g, 2);
        etype = bytestream2_get_le16(&s->g);
        esize = bytestream2_get_le16(&s->g);
        if (bytestream2_get_bytes_left(&s->g) < esize)
            return AVERROR_INVALIDDATA;
    } else {
        etype = -1;
        esize = 0;
    }

    avctx->pix_fmt = AV_PIX_FMT_PAL8;

    if (av_image_check_size(s->width, s->height, 0, avctx) < 0)
        return -1;
    if (s->width != avctx->width || s->height != avctx->height) {
        ret = ff_set_dimensions(avctx, s->width, s->height);
        if (ret < 0)
            return ret;
    }

    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
        return ret;
    memset(frame->data[0], 0, s->height * frame->linesize[0]);
    frame->pict_type           = AV_PICTURE_TYPE_I;
    frame->palette_has_changed = 1;

    pos_after_pal = bytestream2_tell(&s->g) + esize;
    palette = (uint32_t*)frame->data[1];
    if (etype == 1 && esize > 1 && bytestream2_peek_byte(&s->g) < 6) {
        int idx = bytestream2_get_byte(&s->g);
        npal = 4;
        for (i = 0; i < npal; i++)
            palette[i] = ff_cga_palette[ cga_mode45_index[idx][i] ];
    } else if (etype == 2) {
        npal = FFMIN(esize, 16);
        for (i = 0; i < npal; i++) {
            int pal_idx = bytestream2_get_byte(&s->g);
            palette[i]  = ff_cga_palette[FFMIN(pal_idx, 15)];
        }
    } else if (etype == 3) {
        npal = FFMIN(esize, 16);
        for (i = 0; i < npal; i++) {
            int pal_idx = bytestream2_get_byte(&s->g);
            palette[i]  = ff_ega_palette[FFMIN(pal_idx, 63)];
        }
    } else if (etype == 4 || etype == 5) {
        npal = FFMIN(esize / 3, 256);
        for (i = 0; i < npal; i++) {
            palette[i] = bytestream2_get_be24(&s->g) << 2;
            palette[i] |= 0xFFU << 24 | palette[i] >> 6 & 0x30303;
        }
    } else {
        if (bpp == 1) {
            npal = 2;
            palette[0] = 0xFF000000;
            palette[1] = 0xFFFFFFFF;
        } else if (bpp == 2) {
            npal = 4;
            for (i = 0; i < npal; i++)
                palette[i] = ff_cga_palette[ cga_mode45_index[0][i] ];
        } else {
            npal = 16;
            memcpy(palette, ff_cga_palette, npal * 4);
        }
    }
    // fill remaining palette entries
    memset(palette + npal, 0, AVPALETTE_SIZE - npal * 4);
    // skip remaining palette bytes
    bytestream2_seek(&s->g, pos_after_pal, SEEK_SET);

    val = 0;
    y = s->height - 1;
    if (bytestream2_get_le16(&s->g)) {
        x = 0;
        plane = 0;
        while (bytestream2_get_bytes_left(&s->g) >= 6) {
            int stop_size, marker, t1, t2;

            t1        = bytestream2_get_bytes_left(&s->g);
            t2        = bytestream2_get_le16(&s->g);
            stop_size = t1 - FFMIN(t1, t2);
            // ignore uncompressed block size
            bytestream2_skip(&s->g, 2);
            marker    = bytestream2_get_byte(&s->g);

            while (plane < s->nb_planes &&
                   bytestream2_get_bytes_left(&s->g) > stop_size) {
                int run = 1;
                val = bytestream2_get_byte(&s->g);
                if (val == marker) {
                    run = bytestream2_get_byte(&s->g);
                    if (run == 0)
                        run = bytestream2_get_le16(&s->g);
                    val = bytestream2_get_byte(&s->g);
                }
                if (!bytestream2_get_bytes_left(&s->g))
                    break;

                if (bits_per_plane == 8) {
                    picmemset_8bpp(s, frame, val, run, &x, &y);
                    if (y < 0)
                        goto finish;
                } else {
                    picmemset(s, frame, val, run, &x, &y, &plane, bits_per_plane);
                }
            }
        }

        if (x < avctx->width) {
            int run = (y + 1) * avctx->width - x;
            if (bits_per_plane == 8)
                picmemset_8bpp(s, frame, val, run, &x, &y);
            else
                picmemset(s, frame, val, run / (8 / bits_per_plane), &x, &y, &plane, bits_per_plane);
        }
    } else {
        while (y >= 0 && bytestream2_get_bytes_left(&s->g) > 0) {
            memcpy(frame->data[0] + y * frame->linesize[0], s->g.buffer, FFMIN(avctx->width, bytestream2_get_bytes_left(&s->g)));
            bytestream2_skip(&s->g, avctx->width);
            y--;
        }
    }
finish:

    *got_frame      = 1;
    return avpkt->size;
}","static int decode_frame(AVCodecContext *VAR_0,
                        void *VAR_1, int *VAR_2,
                        AVPacket *VAR_3)
{
    PicContext *VAR_4 = VAR_0->priv_data;
    AVFrame *VAR_5 = VAR_1;
    uint32_t *VAR_6;
    int VAR_7, VAR_8, VAR_9, VAR_10, VAR_11, VAR_12;
    int VAR_13, VAR_14, VAR_15, VAR_16, VAR_17, VAR_18, VAR_19;

    bytestream2_init(&VAR_4->g, VAR_3->data, VAR_3->size);

    if (bytestream2_get_bytes_left(&VAR_4->g) < 11)
        return VAR_20;

    if (bytestream2_get_le16u(&VAR_4->g) != 0x1234)
        return VAR_20;

    VAR_4->width       = bytestream2_get_le16u(&VAR_4->g);
    VAR_4->height      = bytestream2_get_le16u(&VAR_4->g);
    bytestream2_skip(&VAR_4->g, 4);
    VAR_17            = bytestream2_get_byteu(&VAR_4->g);
    VAR_7 = VAR_17 & 0xF;
    VAR_4->nb_planes   = (VAR_17 >> 4) + 1;
    VAR_8            = VAR_7 * VAR_4->nb_planes;
    if (VAR_7 > 8 || VAR_8 < 1 || VAR_8 > 32) {
        avpriv_request_sample(VAR_0, ""Unsupported bit depth"");
        return VAR_21;
    }

    if (bytestream2_peek_byte(&VAR_4->g) == 0xFF || VAR_8 == 1 || VAR_8 == 4 || VAR_8 == 8) {
        bytestream2_skip(&VAR_4->g, 2);
        VAR_9 = bytestream2_get_le16(&VAR_4->g);
        VAR_10 = bytestream2_get_le16(&VAR_4->g);
        if (bytestream2_get_bytes_left(&VAR_4->g) < VAR_10)
            return VAR_20;
    } else {
        VAR_9 = -1;
        VAR_10 = 0;
    }

    VAR_0->pix_fmt = VAR_22;

    if (av_image_check_size(VAR_4->width, VAR_4->height, 0, VAR_0) < 0)
        return -1;
    if (VAR_4->width != VAR_0->width || VAR_4->height != VAR_0->height) {
        VAR_18 = ff_set_dimensions(VAR_0, VAR_4->width, VAR_4->height);
        if (VAR_18 < 0)
            return VAR_18;
    }

    if ((VAR_18 = ff_get_buffer(VAR_0, VAR_5, 0)) < 0)
        return VAR_18;
    memset(VAR_5->data[0], 0, VAR_4->height * VAR_5->linesize[0]);
    VAR_5->pict_type           = VAR_23;
    VAR_5->palette_has_changed = 1;

    VAR_12 = bytestream2_tell(&VAR_4->g) + VAR_10;
    VAR_6 = (uint32_t*)VAR_5->data[1];
    if (VAR_9 == 1 && VAR_10 > 1 && bytestream2_peek_byte(&VAR_4->g) < 6) {
        int VAR_24 = bytestream2_get_byte(&VAR_4->g);
        VAR_11 = 4;
        for (VAR_13 = 0; VAR_13 < VAR_11; VAR_13++)
            VAR_6[VAR_13] = VAR_25[ VAR_26[VAR_24][VAR_13] ];
    } else if (VAR_9 == 2) {
        VAR_11 = FFMIN(VAR_10, 16);
        for (VAR_13 = 0; VAR_13 < VAR_11; VAR_13++) {
            int VAR_27 = bytestream2_get_byte(&VAR_4->g);
            VAR_6[VAR_13]  = VAR_25[FFMIN(VAR_27, 15)];
        }
    } else if (VAR_9 == 3) {
        VAR_11 = FFMIN(VAR_10, 16);
        for (VAR_13 = 0; VAR_13 < VAR_11; VAR_13++) {
            int VAR_27 = bytestream2_get_byte(&VAR_4->g);
            VAR_6[VAR_13]  = VAR_28[FFMIN(VAR_27, 63)];
        }
    } else if (VAR_9 == 4 || VAR_9 == 5) {
        VAR_11 = FFMIN(VAR_10 / 3, 256);
        for (VAR_13 = 0; VAR_13 < VAR_11; VAR_13++) {
            VAR_6[VAR_13] = bytestream2_get_be24(&VAR_4->g) << 2;
            VAR_6[VAR_13] |= 0xFFU << 24 | VAR_6[VAR_13] >> 6 & 0x30303;
        }
    } else {
        if (VAR_8 == 1) {
            VAR_11 = 2;
            VAR_6[0] = 0xFF000000;
            VAR_6[1] = 0xFFFFFFFF;
        } else if (VAR_8 == 2) {
            VAR_11 = 4;
            for (VAR_13 = 0; VAR_13 < VAR_11; VAR_13++)
                VAR_6[VAR_13] = VAR_25[ VAR_26[0][VAR_13] ];
        } else {
            VAR_11 = 16;
            memcpy(VAR_6, VAR_25, VAR_11 * 4);
        }
    }
    /* COMMENT_0 */
    memset(VAR_6 + VAR_11, 0, VAR_29 - VAR_11 * 4);
    /* COMMENT_1 */
    bytestream2_seek(&VAR_4->g, VAR_12, VAR_30);

    VAR_19 = 0;
    VAR_15 = VAR_4->height - 1;
    if (bytestream2_get_le16(&VAR_4->g)) {
        VAR_14 = 0;
        VAR_16 = 0;
        while (bytestream2_get_bytes_left(&VAR_4->g) >= 6) {
            int VAR_31, VAR_32, VAR_33, VAR_34;

            VAR_33        = bytestream2_get_bytes_left(&VAR_4->g);
            VAR_34        = bytestream2_get_le16(&VAR_4->g);
            VAR_31 = VAR_33 - FFMIN(VAR_33, VAR_34);
            /* COMMENT_2 */
            bytestream2_skip(&VAR_4->g, 2);
            VAR_32    = bytestream2_get_byte(&VAR_4->g);

            while (VAR_16 < VAR_4->nb_planes &&
                   bytestream2_get_bytes_left(&VAR_4->g) > VAR_31) {
                int VAR_35 = 1;
                VAR_19 = bytestream2_get_byte(&VAR_4->g);
                if (VAR_19 == VAR_32) {
                    VAR_35 = bytestream2_get_byte(&VAR_4->g);
                    if (VAR_35 == 0)
                        VAR_35 = bytestream2_get_le16(&VAR_4->g);
                    VAR_19 = bytestream2_get_byte(&VAR_4->g);
                }
                if (!bytestream2_get_bytes_left(&VAR_4->g))
                    break;

                if (VAR_7 == 8) {
                    picmemset_8bpp(VAR_4, VAR_5, VAR_19, VAR_35, &VAR_14, &VAR_15);
                    if (VAR_15 < 0)
                        goto finish;
                } else {
                    picmemset(VAR_4, VAR_5, VAR_19, VAR_35, &VAR_14, &VAR_15, &VAR_16, VAR_7);
                }
            }
        }

        if (VAR_14 < VAR_0->width) {
            int VAR_35 = (VAR_15 + 1) * VAR_0->width - VAR_14;
            if (VAR_7 == 8)
                picmemset_8bpp(VAR_4, VAR_5, VAR_19, VAR_35, &VAR_14, &VAR_15);
            else
                picmemset(VAR_4, VAR_5, VAR_19, VAR_35 / (8 / VAR_7), &VAR_14, &VAR_15, &VAR_16, VAR_7);
        }
    } else {
        while (VAR_15 >= 0 && bytestream2_get_bytes_left(&VAR_4->g) > 0) {
            memcpy(VAR_5->data[0] + VAR_15 * VAR_5->linesize[0], VAR_4->g.buffer, FFMIN(VAR_0->width, bytestream2_get_bytes_left(&VAR_4->g)));
            bytestream2_skip(&VAR_4->g, VAR_0->width);
            VAR_15--;
        }
    }
finish:

    *VAR_2      = 1;
    return VAR_3->size;
}",ffmpeg/8c2ea3030af7b40a3c4275696fb5c76cdb80950a/pictordec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -43,7 +43,7 @@
 
     if (av_image_check_size(s->width, s->height, 0, avctx) < 0)
         return -1;
-    if (s->width != avctx->width && s->height != avctx->height) {
+    if (s->width != avctx->width || s->height != avctx->height) {
         ret = ff_set_dimensions(avctx, s->width, s->height);
         if (ret < 0)
             return ret;","{'deleted_lines': ['    if (s->width != avctx->width && s->height != avctx->height) {'], 'added_lines': ['    if (s->width != avctx->width || s->height != avctx->height) {']}",True,FFmpeg before 2017-02-07 has an out-of-bounds write caused by a heap-based buffer overflow related to the decode_frame function in libavcodec/pictordec.c.,9.8,CRITICAL,3,test,2017-02-07T14:49:09Z,1
CVE-2017-6196,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ArtifexSoftware/ghostpdl,"Resolve image enumerator ownership on error

Bug #697596 ""Use-After-Free in i_free_object()""

There is confusion over ownership of 'penum' between gx_begin_image1(),
gx_begin_image4() and gx_image_enum_begin() which is called from these
two functions (and only from these two functions).

The enumerator is allocated in gx_begin_image?() and freed there if
gx_image_enum_begin() returns an error. However, gx_image_enum_begin()
also frees the enumerator on an error; except that it doesn't always do
so. Its a large function and there are at least 9 ways to exit it, only
4 of which free the enumerator.

This commit removes the 'free' instances from gx_image_enum_begin()
leaving the cleanup as the responsibility of the calling code, which
performed the allocation.",ecceafe3abba2714ef9b432035fe0739d9b1a283,https://github.com/ArtifexSoftware/ghostpdl/commit/ecceafe3abba2714ef9b432035fe0739d9b1a283,base/gxipixel.c,gx_image_enum_begin,"int
gx_image_enum_begin(gx_device * dev, const gs_gstate * pgs,
const gs_matrix *pmat, const gs_image_common_t * pic,
const gx_drawing_color * pdcolor, const gx_clip_path * pcpath,
gs_memory_t * mem, gx_image_enum *penum)
{
const gs_pixel_image_t *pim = (const gs_pixel_image_t *)pic;
gs_image_format_t format = pim->format;
const int width = pim->Width;
const int height = pim->Height;
const int bps = pim->BitsPerComponent;
bool masked = penum->masked;
const float *decode = pim->Decode;
gs_matrix_double mat;
int index_bps;
const gs_color_space *pcs = pim->ColorSpace;
gs_logical_operation_t lop = (pgs ? pgs->log_op : lop_default);
int code;
int log2_xbytes = (bps <= 8 ? 0 : arch_log2_sizeof_frac);
int spp, nplanes, spread;
uint bsize;
byte *buffer;
fixed mtx, mty;
gs_fixed_point row_extent, col_extent, x_extent, y_extent;
bool device_color = true;
gs_fixed_rect obox, cbox;
bool gridfitimages = 0;
bool in_pattern_accumulator = 0;
int orthogonal;
int force_interpolation = 0;
penum->clues = NULL;
penum->icc_setup.has_transfer = false;
penum->icc_setup.is_lab = false;
penum->icc_setup.must_halftone = false;
penum->icc_setup.need_decode = false;
penum->Width = width;
penum->Height = height;
if ((code = gx_image_compute_mat(pgs, pmat, &(pim->ImageMatrix), &mat)) < 0) {
gs_free_object(mem, penum, ""gx_default_begin_image"");
return code;
}
in_pattern_accumulator = (dev_proc(dev, dev_spec_op)(dev, gxdso_in_pattern_accumulator, NULL, 0));
if (in_pattern_accumulator < 0)
in_pattern_accumulator = 0;
if (mat.xy == 0 && mat.yx == 0)
orthogonal = 1;
else if (mat.xx == 0 && mat.yy == 0)
orthogonal = 2;
else
orthogonal = 0;
gridfitimages = in_pattern_accumulator && orthogonal;
if (pgs != NULL && pgs->show_gstate != NULL) {
} else if (!gridfitimages &&
(!penum->masked || penum->image_parent_type != 0)) {
} else if (gridfitimages && (penum->masked && penum->image_parent_type == 0)) {
} else if (pgs != NULL && pgs->fill_adjust.x == 0 && pgs->fill_adjust.y == 0) {
} else if (orthogonal == 1) {
if (width == 1 || gridfitimages) {
if (mat.xx > 0) {
fixed ix0 = int2fixed(fixed2int(float2fixed(mat.tx)));
double x1 = mat.tx + mat.xx * width;
fixed ix1 = int2fixed(fixed2int_ceiling(float2fixed(x1)));
mat.tx = (double)fixed2float(ix0);
mat.xx = (double)(fixed2float(ix1 - ix0)/width);
} else if (mat.xx < 0) {
fixed ix0 = int2fixed(fixed2int_ceiling(float2fixed(mat.tx)));
double x1 = mat.tx + mat.xx * width;
fixed ix1 = int2fixed(fixed2int(float2fixed(x1)));
mat.tx = (double)fixed2float(ix0);
mat.xx = (double)(fixed2float(ix1 - ix0)/width);
}
}
if (height == 1 || gridfitimages) {
if (mat.yy > 0) {
fixed iy0 = int2fixed(fixed2int(float2fixed(mat.ty)));
double y1 = mat.ty + mat.yy * height;
fixed iy1 = int2fixed(fixed2int_ceiling(float2fixed(y1)));
mat.ty = (double)fixed2float(iy0);
mat.yy = (double)(fixed2float(iy1 - iy0)/height);
} else if (mat.yy < 0) {
fixed iy0 = int2fixed(fixed2int_ceiling(float2fixed(mat.ty)));
double y1 = mat.ty + mat.yy * height;
fixed iy1 = int2fixed(fixed2int(float2fixed(y1)));
mat.ty = (double)fixed2float(iy0);
mat.yy = ((double)fixed2float(iy1 - iy0)/height);
}
}
} else if (orthogonal == 2) {
if (height == 1 || gridfitimages) {
if (mat.yx > 0) {
fixed ix0 = int2fixed(fixed2int(float2fixed(mat.tx)));
double x1 = mat.tx + mat.yx * height;
fixed ix1 = int2fixed(fixed2int_ceiling(float2fixed(x1)));
mat.tx = (double)fixed2float(ix0);
mat.yx = (double)(fixed2float(ix1 - ix0)/height);
} else if (mat.yx < 0) {
fixed ix0 = int2fixed(fixed2int_ceiling(float2fixed(mat.tx)));
double x1 = mat.tx + mat.yx * height;
fixed ix1 = int2fixed(fixed2int(float2fixed(x1)));
mat.tx = (double)fixed2float(ix0);
mat.yx = (double)(fixed2float(ix1 - ix0)/height);
}
}
if (width == 1 || gridfitimages) {
if (mat.xy > 0) {
fixed iy0 = int2fixed(fixed2int(float2fixed(mat.ty)));
double y1 = mat.ty + mat.xy * width;
fixed iy1 = int2fixed(fixed2int_ceiling(float2fixed(y1)));
mat.ty = (double)fixed2float(iy0);
mat.xy = (double)(fixed2float(iy1 - iy0)/width);
} else if (mat.xy < 0) {
fixed iy0 = int2fixed(fixed2int_ceiling(float2fixed(mat.ty)));
double y1 = mat.ty + mat.xy * width;
fixed iy1 = int2fixed(fixed2int(float2fixed(y1)));
mat.ty = (double)fixed2float(iy0);
mat.xy = ((double)fixed2float(iy1 - iy0)/width);
}
}
}
if (in_pattern_accumulator) {
double ome = ((double)(fixed_1 - fixed_epsilon)) / (double)fixed_1; 
if (orthogonal == 1) {
if ((mat.xx > -ome && mat.xx < ome) || (mat.yy > -ome && mat.yy < ome)) {
force_interpolation = true;
}
} else if (orthogonal == 2) {
if ((mat.xy > -ome && mat.xy < ome) || (mat.yx > -ome && mat.yx < ome)) {
force_interpolation = true;
}
}
}
while (pcpath) 
{
gs_rect rect, rect_out;
gs_matrix mi;
gs_fixed_rect obox;
gs_int_rect irect;
if ((code = gs_matrix_invert(&ctm_only(pgs), &mi)) < 0 ||
(code = gs_matrix_multiply(&mi, &pic->ImageMatrix, &mi)) < 0) {
break;
}
gx_cpath_outer_box(pcpath, &obox);
rect.p.x = fixed2float(obox.p.x);
rect.p.y = fixed2float(obox.p.y);
rect.q.x = fixed2float(obox.q.x);
rect.q.y = fixed2float(obox.q.y);
code = gs_bbox_transform(&rect, &mi, &rect_out);
if (code < 0) {
break;
}
irect.p.x = (int)(rect_out.p.x-1.0);
irect.p.y = (int)(rect_out.p.y-1.0);
irect.q.x = (int)(rect_out.q.x+1.0);
irect.q.y = (int)(rect_out.q.y+1.0);
{
float support = any_abs(mi.xx);
int isupport;
if (any_abs(mi.yy) > support)
support = any_abs(mi.yy);
if (any_abs(mi.xy) > support)
support = any_abs(mi.xy);
if (any_abs(mi.yx) > support)
support = any_abs(mi.yx);
isupport = (int)(MAX_ISCALE_SUPPORT * (support+1)) + 1;
irect.p.x -= isupport;
irect.p.y -= isupport;
irect.q.x += isupport;
irect.q.y += isupport;
}
if (penum->rrect.x < irect.p.x) {
penum->rrect.w -= irect.p.x - penum->rrect.x;
if (penum->rrect.w < 0)
penum->rrect.w = 0;
penum->rrect.x = irect.p.x;
}
if (penum->rrect.x + penum->rrect.w > irect.q.x) {
penum->rrect.w = irect.q.x - penum->rrect.x;
if (penum->rrect.w < 0)
penum->rrect.w = 0;
}
if (penum->rrect.y < irect.p.y) {
penum->rrect.h -= irect.p.y - penum->rrect.y;
if (penum->rrect.h < 0)
penum->rrect.h = 0;
penum->rrect.y = irect.p.y;
}
if (penum->rrect.y + penum->rrect.h > irect.q.y) {
penum->rrect.h = irect.q.y - penum->rrect.y;
if (penum->rrect.h < 0)
penum->rrect.h = 0;
}
break; 
}
if (penum->rrect.x + penum->rrect.w <= penum->rect.x  ||
penum->rect.x  + penum->rect.w  <= penum->rrect.x ||
penum->rrect.y + penum->rrect.h <= penum->rect.y  ||
penum->rect.y  + penum->rect.h  <= penum->rrect.y)
{
penum->rrect.x = penum->rect.x;
penum->rrect.y = penum->rect.y;
penum->rrect.w = 0;
penum->rrect.h = 0;
}
penum->matrix.xx = mat.xx;
penum->matrix.xy = mat.xy;
penum->matrix.yx = mat.yx;
penum->matrix.yy = mat.yy;
penum->matrix.tx = mat.tx;
penum->matrix.ty = mat.ty;
if_debug6m('b', mem, "" [%g %g %g %g %g %g]\n"",
mat.xx, mat.xy, mat.yx, mat.yy, mat.tx, mat.ty);
index_bps = (bps < 8 ? bps >> 1 : (bps >> 2) + 1);
if (mat.tx > 0)
mtx = float2fixed(mat.tx);
else { 
int f = (int)-mat.tx + 1;
mtx = float2fixed(mat.tx + f) - int2fixed(f);
}
if (mat.ty > 0)
mty = float2fixed(mat.ty);
else {  
int f = (int)-mat.ty + 1;
mty = float2fixed(mat.ty + f) - int2fixed(f);
}
row_extent.x = float2fixed_rounded_boxed(width * mat.xx);
row_extent.y =
(is_fzero(mat.xy) ? fixed_0 :
float2fixed_rounded_boxed(width * mat.xy));
col_extent.x =
(is_fzero(mat.yx) ? fixed_0 :
float2fixed_rounded_boxed(height * mat.yx));
col_extent.y = float2fixed_rounded_boxed(height * mat.yy);
gx_image_enum_common_init((gx_image_enum_common_t *)penum,
(const gs_data_image_t *)pim,
&image1_enum_procs, dev,
(masked ? 1 : (penum->alpha ? cs_num_components(pcs)+1 : cs_num_components(pcs))),
format);
if (penum->rect.w == width && penum->rect.h == height) {
x_extent = row_extent;
y_extent = col_extent;
} else {
int rw = penum->rect.w, rh = penum->rect.h;
x_extent.x = float2fixed_rounded_boxed(rw * mat.xx);
x_extent.y =
(is_fzero(mat.xy) ? fixed_0 :
float2fixed_rounded_boxed(rw * mat.xy));
y_extent.x =
(is_fzero(mat.yx) ? fixed_0 :
float2fixed_rounded_boxed(rh * mat.yx));
y_extent.y = float2fixed_rounded_boxed(rh * mat.yy);
}
if (masked || cs_num_components(pcs) == 1) {
penum->clues = (gx_image_clue*) gs_alloc_bytes(mem, sizeof(gx_image_clue)*256,
""gx_image_enum_begin"");
if (penum->clues == NULL)
return_error(gs_error_VMerror);
penum->icolor0 = &(penum->clues[0].dev_color);
penum->icolor1 = &(penum->clues[255].dev_color);
} else {
penum->icolor0 = &(penum->icolor0_val);
penum->icolor1 = &(penum->icolor1_val);
}
if (masked) {       
if (bps != 1 || pcs != NULL || penum->alpha || decode[0] == decode[1]) {
gs_free_object(mem, penum, ""gx_default_begin_image"");
return_error(gs_error_rangecheck);
}
set_nonclient_dev_color(penum->icolor0, gx_no_color_index);
set_nonclient_dev_color(penum->icolor1, gx_no_color_index);
*(penum->icolor1) = *pdcolor;
memcpy(&penum->map[0].table.lookup4x1to32[0],
(decode[0] < decode[1] ? lookup4x1to32_inverted :
lookup4x1to32_identity),
16 * 4);
penum->map[0].decoding = sd_none;
spp = 1;
lop = rop3_know_S_0(lop);
} else {                    
const gs_color_space_type *pcst = pcs->type;
int b_w_color;
spp = cs_num_components(pcs);
if (spp < 0) {          
gs_free_object(mem, penum, ""gx_default_begin_image"");
return_error(gs_error_rangecheck);
}
if (penum->alpha)
++spp;
switch (format) {
case gs_image_format_bit_planar:
if (bps > 1)
break;
format = gs_image_format_component_planar;
case gs_image_format_component_planar:
if (spp == 1)
format = gs_image_format_chunky;
default:                
break;
}
if (pcs->cmm_icc_profile_data != NULL) {
device_color = false;
} else {
device_color = (*pcst->concrete_space) (pcs, pgs) == pcs;
}
code = image_init_colors(penum, bps, spp, format, decode, pgs, dev,
pcs, &device_color);
if (code < 0) 
return gs_throw(code, ""Image colors initialization failed"");
if (gs_color_space_is_PSCIE(pcs) && pcs->icc_equivalent == NULL) {
gs_colorspace_set_icc_equivalent((gs_color_space *)pcs, &(penum->icc_setup.is_lab),
pgs->memory);
if (penum->icc_setup.is_lab) {
gs_color_space *curr_pcs = (gs_color_space *)pcs;
rc_decrement(curr_pcs->icc_equivalent,""gx_image_enum_begin"");
rc_decrement(curr_pcs->cmm_icc_profile_data,""gx_image_enum_begin"");
curr_pcs->cmm_icc_profile_data = pgs->icc_manager->lab_profile;
rc_increment(curr_pcs->cmm_icc_profile_data);
}
}
if (!pim->CombineWithColor)
lop = rop3_know_T_0(lop) & ~lop_T_transparent;
else if ((rop3_uses_T(lop) && color_draws_b_w(dev, pdcolor) == 0))
lop = rop3_know_T_0(lop);
if (lop != rop3_S &&    
!rop3_uses_T(lop) && bps == 1 && spp == 1 &&
(b_w_color =
color_draws_b_w(dev, penum->icolor0)) >= 0 &&
color_draws_b_w(dev, penum->icolor1) == (b_w_color ^ 1)
) {
if (b_w_color) {    
gx_device_color dcolor;
dcolor = *(penum->icolor0);
*(penum->icolor0) = *(penum->icolor1);
*(penum->icolor1) = dcolor;
lop = rop3_invert_S(lop);
}
switch (lop) {
case rop3_D & rop3_S:
*(penum->icolor1) = *(penum->icolor0);
case rop3_D | rop3_not(rop3_S):
memcpy(&penum->map[0].table.lookup4x1to32[0],
lookup4x1to32_inverted, 16 * 4);
rmask:        
penum->masked = masked = true;
set_nonclient_dev_color(penum->icolor0, gx_no_color_index);
penum->map[0].decoding = sd_none;
lop = rop3_T;
break;
case rop3_D & rop3_not(rop3_S):
*(penum->icolor1) = *(penum->icolor0);
case rop3_D | rop3_S:
memcpy(&penum->map[0].table.lookup4x1to32[0],
lookup4x1to32_identity, 16 * 4);
goto rmask;
default:
;
}
}
}
penum->device_color = device_color;
bsize = ((bps > 8 ? width * 2 : width) + 15) * spp;
buffer = gs_alloc_bytes(mem, bsize, ""image buffer"");
if (buffer == 0) {
gs_free_object(mem, penum, ""gx_default_begin_image"");
return_error(gs_error_VMerror);
}
penum->bps = bps;
penum->unpack_bps = bps;
penum->log2_xbytes = log2_xbytes;
penum->spp = spp;
switch (format) {
case gs_image_format_chunky:
nplanes = 1;
spread = 1 << log2_xbytes;
break;
case gs_image_format_component_planar:
nplanes = spp;
spread = spp << log2_xbytes;
break;
case gs_image_format_bit_planar:
nplanes = spp * bps;
spread = spp << log2_xbytes;
break;
default:
return_error(gs_error_Fatal);
}
penum->num_planes = nplanes;
penum->spread = spread;
penum->interpolate = force_interpolation ? interp_force : pim->Interpolate ? interp_on : interp_off;
penum->x_extent = x_extent;
penum->y_extent = y_extent;
penum->posture =
((x_extent.y | y_extent.x) == 0 ? image_portrait :
(x_extent.x | y_extent.y) == 0 ? image_landscape :
image_skewed);
penum->pgs = pgs;
penum->pcs = pcs;
penum->memory = mem;
penum->buffer = buffer;
penum->buffer_size = bsize;
penum->line = 0;
penum->icc_link = NULL;
penum->color_cache = NULL;
penum->ht_buffer = NULL;
penum->thresh_buffer = NULL;
penum->use_cie_range = false;
penum->line_size = 0;
penum->use_rop = lop != (masked ? rop3_T : rop3_S);
#ifdef DEBUG
if (gs_debug_c('*')) {
if (penum->use_rop)
dmprintf1(mem, ""[%03x]"", lop);
dmprintf5(mem, ""%c%d%c%dx%d "",
(masked ? (color_is_pure(pdcolor) ? 'm' : 'h') : 'i'),
bps,
(penum->posture == image_portrait ? ' ' :
penum->posture == image_landscape ? 'L' : 'T'),
width, height);
}
#endif
penum->slow_loop = 0;
if (pcpath == 0) {
(*dev_proc(dev, get_clipping_box)) (dev, &obox);
cbox = obox;
penum->clip_image = 0;
} else
penum->clip_image =
(gx_cpath_outer_box(pcpath, &obox) |        
gx_cpath_inner_box(pcpath, &cbox) ?
0 : image_clip_region);
penum->clip_outer = obox;
penum->clip_inner = cbox;
penum->log_op = rop3_T;     
penum->clip_dev = 0;        
penum->rop_dev = 0;         
penum->scaler = 0;          
{
fixed
epx = min(row_extent.x, 0) + min(col_extent.x, 0),
eqx = max(row_extent.x, 0) + max(col_extent.x, 0),
epy = min(row_extent.y, 0) + min(col_extent.y, 0),
eqy = max(row_extent.y, 0) + max(col_extent.y, 0);
{
int hwx, hwy;
switch (penum->posture) {
case image_portrait:
hwx = width, hwy = height;
break;
case image_landscape:
hwx = height, hwy = width;
break;
default:
hwx = hwy = 0;
}
if (hwx == 1 && eqx - epx < fixed_1) {
fixed diff =
arith_rshift_1(row_extent.x + col_extent.x);
mtx = (((mtx + diff) | fixed_half) & -fixed_half) - diff;
}
if (hwy == 1 && eqy - epy < fixed_1) {
fixed diff =
arith_rshift_1(row_extent.y + col_extent.y);
mty = (((mty + diff) | fixed_half) & -fixed_half) - diff;
}
}
if_debug5m('b', mem, ""[b]Image: %sspp=%d, bps=%d, mt=(%g,%g)\n"",
(masked? ""masked, "" : """"), spp, bps,
fixed2float(mtx), fixed2float(mty));
if_debug9m('b', mem,
""[b]   cbox=(%g,%g),(%g,%g), obox=(%g,%g),(%g,%g), clip_image=0x%x\n"",
fixed2float(cbox.p.x), fixed2float(cbox.p.y),
fixed2float(cbox.q.x), fixed2float(cbox.q.y),
fixed2float(obox.p.x), fixed2float(obox.p.y),
fixed2float(obox.q.x), fixed2float(obox.q.y),
penum->clip_image);
dda_init(penum->dda.row.x, mtx, col_extent.x, height);
dda_init(penum->dda.row.y, mty, col_extent.y, height);
if (penum->posture == image_portrait) {
penum->dst_width = row_extent.x;
penum->dst_height = col_extent.y;
} else {
penum->dst_width = col_extent.x;
penum->dst_height = row_extent.y;
}
penum->yi0 = fixed2int_pixround_perfect(dda_current(penum->dda.row.y)); 
if (penum->rect.y) {
int y = penum->rect.y;
while (y--) {
dda_next(penum->dda.row.x);
dda_next(penum->dda.row.y);
}
}
penum->cur.x = penum->prev.x = dda_current(penum->dda.row.x);
penum->cur.y = penum->prev.y = dda_current(penum->dda.row.y);
dda_init(penum->dda.strip.x, penum->cur.x, row_extent.x, width);
dda_init(penum->dda.strip.y, penum->cur.y, row_extent.y, width);
if (penum->rect.x) {
dda_advance(penum->dda.strip.x, penum->rect.x);
dda_advance(penum->dda.strip.y, penum->rect.x);
}
{
fixed ox = dda_current(penum->dda.strip.x);
fixed oy = dda_current(penum->dda.strip.y);
if (!penum->clip_image)     
penum->clip_image =
(fixed_pixround(ox + epx) < fixed_pixround(cbox.p.x) ?
image_clip_xmin : 0) +
(fixed_pixround(ox + eqx) >= fixed_pixround(cbox.q.x) ?
image_clip_xmax : 0) +
(fixed_pixround(oy + epy) < fixed_pixround(cbox.p.y) ?
image_clip_ymin : 0) +
(fixed_pixround(oy + eqy) >= fixed_pixround(cbox.q.y) ?
image_clip_ymax : 0);
}
}
penum->y = 0;
penum->used.x = 0;
penum->used.y = 0;
{
static sample_unpack_proc_t procs[2][6] = {
{   sample_unpack_1, sample_unpack_2,
sample_unpack_4, sample_unpack_8,
sample_unpack_12, sample_unpack_16
},
{   sample_unpack_1_interleaved, sample_unpack_2_interleaved,
sample_unpack_4_interleaved, sample_unpack_8_interleaved,
sample_unpack_12, sample_unpack_16
}};
int num_planes = penum->num_planes;
bool interleaved = (num_planes == 1 && penum->plane_depths[0] != penum->bps);
int i;
if (interleaved) {
int num_components = penum->plane_depths[0] / penum->bps;
for (i = 1; i < num_components; i++) {
if (decode[0] != decode[i * 2 + 0] ||
decode[1] != decode[i * 2 + 1])
break;
}
if (i == num_components)
interleaved = false; 
}
penum->unpack = procs[interleaved][index_bps];
if_debug1m('b', mem, ""[b]unpack=%d\n"", bps);
penum->dda.pixel0 = penum->dda.strip;
for (i = 0; i < gx_image_class_table_count; ++i)
if ((penum->render = gx_image_class_table[i](penum)) != 0)
break;
if (i == gx_image_class_table_count) {
gx_default_end_image(dev, (gx_image_enum_common_t *) penum,
false);
return_error(gs_error_rangecheck);
}
}
if (penum->clip_image && pcpath) {  
gx_device_clip *cdev =
gs_alloc_struct(mem, gx_device_clip,
&st_device_clip, ""image clipper"");
if (cdev == 0) {
gx_default_end_image(dev,
(gx_image_enum_common_t *) penum,
false);
return_error(gs_error_VMerror);
}
gx_make_clip_device_in_heap(cdev, pcpath, dev, mem);
penum->clip_dev = cdev;
}
if (penum->use_rop) {       
gx_device_rop_texture *rtdev;
code = gx_alloc_rop_texture_device(&rtdev, mem,
""image RasterOp"");
if (code < 0) {
gx_default_end_image(dev, (gx_image_enum_common_t *) penum,
false);
return code;
}
if (!penum->clip_dev && !dev)
return_error(gs_error_undefined);
gx_make_rop_texture_device(rtdev,
(penum->clip_dev != 0 ?
(gx_device *) penum->clip_dev :
dev), lop, pdcolor);
gx_device_retain((gx_device *)rtdev, true);
penum->rop_dev = rtdev;
}
return 0;
}","int
gx_image_enum_begin(gx_device * VAR_0, const gs_gstate * VAR_1,
const gs_matrix *VAR_2, const gs_image_common_t * VAR_3,
const gx_drawing_color * VAR_4, const gx_clip_path * VAR_5,
gs_memory_t * VAR_6, gx_image_enum *VAR_7)
{
const gs_pixel_image_t *VAR_8 = (const gs_pixel_image_t *)VAR_3;
gs_image_format_t VAR_9 = VAR_8->format;
const int VAR_10 = VAR_8->Width;
const int VAR_11 = VAR_8->Height;
const int VAR_12 = VAR_8->BitsPerComponent;
bool VAR_13 = VAR_7->masked;
const float *VAR_14 = VAR_8->Decode;
gs_matrix_double VAR_15;
int VAR_16;
const gs_color_space *VAR_17 = VAR_8->ColorSpace;
gs_logical_operation_t VAR_18 = (VAR_1 ? VAR_1->log_op : VAR_19);
int VAR_20;
int VAR_21 = (VAR_12 <= 8 ? 0 : VAR_22);
int VAR_23, VAR_24, VAR_25;
uint VAR_26;
byte *VAR_27;
fixed VAR_28, VAR_29;
gs_fixed_point VAR_30, VAR_31, VAR_32, VAR_33;
bool VAR_34 = true;
gs_fixed_rect VAR_35, VAR_36;
bool VAR_37 = 0;
bool VAR_38 = 0;
int VAR_39;
int VAR_40 = 0;
VAR_7->clues = NULL;
VAR_7->icc_setup.has_transfer = false;
VAR_7->icc_setup.is_lab = false;
VAR_7->icc_setup.must_halftone = false;
VAR_7->icc_setup.need_decode = false;
VAR_7->Width = VAR_10;
VAR_7->Height = VAR_11;
if ((VAR_20 = gx_image_compute_mat(VAR_1, VAR_2, &(VAR_8->ImageMatrix), &VAR_15)) < 0) {
gs_free_object(VAR_6, VAR_7, ""gx_default_begin_image"");
return VAR_20;
}
VAR_38 = (dev_proc(VAR_0, VAR_41)(VAR_0, VAR_42, NULL, 0));
if (VAR_38 < 0)
VAR_38 = 0;
if (VAR_15.xy == 0 && VAR_15.yx == 0)
VAR_39 = 1;
else if (VAR_15.xx == 0 && VAR_15.yy == 0)
VAR_39 = 2;
else
VAR_39 = 0;
VAR_37 = VAR_38 && VAR_39;
if (VAR_1 != NULL && VAR_1->show_gstate != NULL) {
} else if (!VAR_37 &&
(!VAR_7->masked || VAR_7->image_parent_type != 0)) {
} else if (VAR_37 && (VAR_7->masked && VAR_7->image_parent_type == 0)) {
} else if (VAR_1 != NULL && VAR_1->fill_adjust.x == 0 && VAR_1->fill_adjust.y == 0) {
} else if (VAR_39 == 1) {
if (VAR_10 == 1 || VAR_37) {
if (VAR_15.xx > 0) {
fixed VAR_43 = int2fixed(fixed2int(float2fixed(VAR_15.tx)));
double VAR_44 = VAR_15.tx + VAR_15.xx * VAR_10;
fixed VAR_45 = int2fixed(fixed2int_ceiling(float2fixed(VAR_44)));
VAR_15.tx = (double)fixed2float(VAR_43);
VAR_15.xx = (double)(fixed2float(VAR_45 - VAR_43)/VAR_10);
} else if (VAR_15.xx < 0) {
fixed VAR_43 = int2fixed(fixed2int_ceiling(float2fixed(VAR_15.tx)));
double VAR_44 = VAR_15.tx + VAR_15.xx * VAR_10;
fixed VAR_45 = int2fixed(fixed2int(float2fixed(VAR_44)));
VAR_15.tx = (double)fixed2float(VAR_43);
VAR_15.xx = (double)(fixed2float(VAR_45 - VAR_43)/VAR_10);
}
}
if (VAR_11 == 1 || VAR_37) {
if (VAR_15.yy > 0) {
fixed VAR_46 = int2fixed(fixed2int(float2fixed(VAR_15.ty)));
double VAR_47 = VAR_15.ty + VAR_15.yy * VAR_11;
fixed VAR_48 = int2fixed(fixed2int_ceiling(float2fixed(VAR_47)));
VAR_15.ty = (double)fixed2float(VAR_46);
VAR_15.yy = (double)(fixed2float(VAR_48 - VAR_46)/VAR_11);
} else if (VAR_15.yy < 0) {
fixed VAR_46 = int2fixed(fixed2int_ceiling(float2fixed(VAR_15.ty)));
double VAR_47 = VAR_15.ty + VAR_15.yy * VAR_11;
fixed VAR_48 = int2fixed(fixed2int(float2fixed(VAR_47)));
VAR_15.ty = (double)fixed2float(VAR_46);
VAR_15.yy = ((double)fixed2float(VAR_48 - VAR_46)/VAR_11);
}
}
} else if (VAR_39 == 2) {
if (VAR_11 == 1 || VAR_37) {
if (VAR_15.yx > 0) {
fixed VAR_43 = int2fixed(fixed2int(float2fixed(VAR_15.tx)));
double VAR_44 = VAR_15.tx + VAR_15.yx * VAR_11;
fixed VAR_45 = int2fixed(fixed2int_ceiling(float2fixed(VAR_44)));
VAR_15.tx = (double)fixed2float(VAR_43);
VAR_15.yx = (double)(fixed2float(VAR_45 - VAR_43)/VAR_11);
} else if (VAR_15.yx < 0) {
fixed VAR_43 = int2fixed(fixed2int_ceiling(float2fixed(VAR_15.tx)));
double VAR_44 = VAR_15.tx + VAR_15.yx * VAR_11;
fixed VAR_45 = int2fixed(fixed2int(float2fixed(VAR_44)));
VAR_15.tx = (double)fixed2float(VAR_43);
VAR_15.yx = (double)(fixed2float(VAR_45 - VAR_43)/VAR_11);
}
}
if (VAR_10 == 1 || VAR_37) {
if (VAR_15.xy > 0) {
fixed VAR_46 = int2fixed(fixed2int(float2fixed(VAR_15.ty)));
double VAR_47 = VAR_15.ty + VAR_15.xy * VAR_10;
fixed VAR_48 = int2fixed(fixed2int_ceiling(float2fixed(VAR_47)));
VAR_15.ty = (double)fixed2float(VAR_46);
VAR_15.xy = (double)(fixed2float(VAR_48 - VAR_46)/VAR_10);
} else if (VAR_15.xy < 0) {
fixed VAR_46 = int2fixed(fixed2int_ceiling(float2fixed(VAR_15.ty)));
double VAR_47 = VAR_15.ty + VAR_15.xy * VAR_10;
fixed VAR_48 = int2fixed(fixed2int(float2fixed(VAR_47)));
VAR_15.ty = (double)fixed2float(VAR_46);
VAR_15.xy = ((double)fixed2float(VAR_48 - VAR_46)/VAR_10);
}
}
}
if (VAR_38) {
double VAR_49 = ((double)(VAR_50 - VAR_51)) / (double)VAR_50; 
if (VAR_39 == 1) {
if ((VAR_15.xx > -VAR_49 && VAR_15.xx < VAR_49) || (VAR_15.yy > -VAR_49 && VAR_15.yy < VAR_49)) {
VAR_40 = true;
}
} else if (VAR_39 == 2) {
if ((VAR_15.xy > -VAR_49 && VAR_15.xy < VAR_49) || (VAR_15.yx > -VAR_49 && VAR_15.yx < VAR_49)) {
VAR_40 = true;
}
}
}
while (VAR_5) 
{
gs_rect VAR_52, VAR_53;
gs_matrix VAR_54;
gs_fixed_rect VAR_35;
gs_int_rect VAR_55;
if ((VAR_20 = gs_matrix_invert(&ctm_only(VAR_1), &VAR_54)) < 0 ||
(VAR_20 = gs_matrix_multiply(&VAR_54, &VAR_3->ImageMatrix, &VAR_54)) < 0) {
break;
}
gx_cpath_outer_box(VAR_5, &VAR_35);
VAR_52.p.x = fixed2float(VAR_35.p.x);
VAR_52.p.y = fixed2float(VAR_35.p.y);
VAR_52.q.x = fixed2float(VAR_35.q.x);
VAR_52.q.y = fixed2float(VAR_35.q.y);
VAR_20 = gs_bbox_transform(&VAR_52, &VAR_54, &VAR_53);
if (VAR_20 < 0) {
break;
}
VAR_55.p.x = (int)(VAR_53.p.x-1.0);
VAR_55.p.y = (int)(VAR_53.p.y-1.0);
VAR_55.q.x = (int)(VAR_53.q.x+1.0);
VAR_55.q.y = (int)(VAR_53.q.y+1.0);
{
float VAR_56 = any_abs(VAR_54.xx);
int VAR_57;
if (any_abs(VAR_54.yy) > VAR_56)
VAR_56 = any_abs(VAR_54.yy);
if (any_abs(VAR_54.xy) > VAR_56)
VAR_56 = any_abs(VAR_54.xy);
if (any_abs(VAR_54.yx) > VAR_56)
VAR_56 = any_abs(VAR_54.yx);
VAR_57 = (int)(VAR_58 * (VAR_56+1)) + 1;
VAR_55.p.x -= VAR_57;
VAR_55.p.y -= VAR_57;
VAR_55.q.x += VAR_57;
VAR_55.q.y += VAR_57;
}
if (VAR_7->rrect.x < VAR_55.p.x) {
VAR_7->rrect.w -= VAR_55.p.x - VAR_7->rrect.x;
if (VAR_7->rrect.w < 0)
VAR_7->rrect.w = 0;
VAR_7->rrect.x = VAR_55.p.x;
}
if (VAR_7->rrect.x + VAR_7->rrect.w > VAR_55.q.x) {
VAR_7->rrect.w = VAR_55.q.x - VAR_7->rrect.x;
if (VAR_7->rrect.w < 0)
VAR_7->rrect.w = 0;
}
if (VAR_7->rrect.y < VAR_55.p.y) {
VAR_7->rrect.h -= VAR_55.p.y - VAR_7->rrect.y;
if (VAR_7->rrect.h < 0)
VAR_7->rrect.h = 0;
VAR_7->rrect.y = VAR_55.p.y;
}
if (VAR_7->rrect.y + VAR_7->rrect.h > VAR_55.q.y) {
VAR_7->rrect.h = VAR_55.q.y - VAR_7->rrect.y;
if (VAR_7->rrect.h < 0)
VAR_7->rrect.h = 0;
}
break; 
}
if (VAR_7->rrect.x + VAR_7->rrect.w <= VAR_7->rect.x  ||
VAR_7->rect.x  + VAR_7->rect.w  <= VAR_7->rrect.x ||
VAR_7->rrect.y + VAR_7->rrect.h <= VAR_7->rect.y  ||
VAR_7->rect.y  + VAR_7->rect.h  <= VAR_7->rrect.y)
{
VAR_7->rrect.x = VAR_7->rect.x;
VAR_7->rrect.y = VAR_7->rect.y;
VAR_7->rrect.w = 0;
VAR_7->rrect.h = 0;
}
VAR_7->matrix.xx = VAR_15.xx;
VAR_7->matrix.xy = VAR_15.xy;
VAR_7->matrix.yx = VAR_15.yx;
VAR_7->matrix.yy = VAR_15.yy;
VAR_7->matrix.tx = VAR_15.tx;
VAR_7->matrix.ty = VAR_15.ty;
if_debug6m('b', VAR_6, "" [%g %g %g %g %g %g]\n"",
VAR_15.xx, VAR_15.xy, VAR_15.yx, VAR_15.yy, VAR_15.tx, VAR_15.ty);
VAR_16 = (VAR_12 < 8 ? VAR_12 >> 1 : (VAR_12 >> 2) + 1);
if (VAR_15.tx > 0)
VAR_28 = float2fixed(VAR_15.tx);
else { 
int VAR_59 = (int)-VAR_15.tx + 1;
VAR_28 = float2fixed(VAR_15.tx + VAR_59) - int2fixed(VAR_59);
}
if (VAR_15.ty > 0)
VAR_29 = float2fixed(VAR_15.ty);
else {  
int VAR_59 = (int)-VAR_15.ty + 1;
VAR_29 = float2fixed(VAR_15.ty + VAR_59) - int2fixed(VAR_59);
}
VAR_30.x = float2fixed_rounded_boxed(VAR_10 * VAR_15.xx);
VAR_30.y =
(is_fzero(VAR_15.xy) ? VAR_60 :
float2fixed_rounded_boxed(VAR_10 * VAR_15.xy));
VAR_31.x =
(is_fzero(VAR_15.yx) ? VAR_60 :
float2fixed_rounded_boxed(VAR_11 * VAR_15.yx));
VAR_31.y = float2fixed_rounded_boxed(VAR_11 * VAR_15.yy);
gx_image_enum_common_init((gx_image_enum_common_t *)VAR_7,
(const gs_data_image_t *)VAR_8,
&VAR_61, VAR_0,
(VAR_13 ? 1 : (VAR_7->alpha ? cs_num_components(VAR_17)+1 : cs_num_components(VAR_17))),
VAR_9);
if (VAR_7->rect.w == VAR_10 && VAR_7->rect.h == VAR_11) {
VAR_32 = VAR_30;
VAR_33 = VAR_31;
} else {
int VAR_62 = VAR_7->rect.w, VAR_63 = VAR_7->rect.h;
VAR_32.x = float2fixed_rounded_boxed(VAR_62 * VAR_15.xx);
VAR_32.y =
(is_fzero(VAR_15.xy) ? VAR_60 :
float2fixed_rounded_boxed(VAR_62 * VAR_15.xy));
VAR_33.x =
(is_fzero(VAR_15.yx) ? VAR_60 :
float2fixed_rounded_boxed(VAR_63 * VAR_15.yx));
VAR_33.y = float2fixed_rounded_boxed(VAR_63 * VAR_15.yy);
}
if (VAR_13 || cs_num_components(VAR_17) == 1) {
VAR_7->clues = (gx_image_clue*) gs_alloc_bytes(VAR_6, sizeof(gx_image_clue)*256,
""gx_image_enum_begin"");
if (VAR_7->clues == NULL)
return_error(VAR_64);
VAR_7->icolor0 = &(VAR_7->clues[0].dev_color);
VAR_7->icolor1 = &(VAR_7->clues[255].dev_color);
} else {
VAR_7->icolor0 = &(VAR_7->icolor0_val);
VAR_7->icolor1 = &(VAR_7->icolor1_val);
}
if (VAR_13) {       
if (VAR_12 != 1 || VAR_17 != NULL || VAR_7->alpha || VAR_14[0] == VAR_14[1]) {
gs_free_object(VAR_6, VAR_7, ""gx_default_begin_image"");
return_error(VAR_65);
}
set_nonclient_dev_color(VAR_7->icolor0, VAR_66);
set_nonclient_dev_color(VAR_7->icolor1, VAR_66);
*(VAR_7->icolor1) = *VAR_4;
memcpy(&VAR_7->map[0].table.lookup4x1to32[0],
(VAR_14[0] < VAR_14[1] ? VAR_67 :
VAR_68),
16 * 4);
VAR_7->map[0].decoding = VAR_69;
VAR_23 = 1;
VAR_18 = rop3_know_S_0(VAR_18);
} else {                    
const gs_color_space_type *VAR_70 = VAR_17->type;
int VAR_71;
VAR_23 = cs_num_components(VAR_17);
if (VAR_23 < 0) {          
gs_free_object(VAR_6, VAR_7, ""gx_default_begin_image"");
return_error(VAR_65);
}
if (VAR_7->alpha)
++VAR_23;
switch (VAR_9) {
case VAR_72:
if (VAR_12 > 1)
break;
VAR_9 = VAR_73;
case VAR_73:
if (VAR_23 == 1)
VAR_9 = VAR_74;
default:                
break;
}
if (VAR_17->cmm_icc_profile_data != NULL) {
VAR_34 = false;
} else {
VAR_34 = (*VAR_70->concrete_space) (VAR_17, VAR_1) == VAR_17;
}
VAR_20 = image_init_colors(VAR_7, VAR_12, VAR_23, VAR_9, VAR_14, VAR_1, VAR_0,
VAR_17, &VAR_34);
if (VAR_20 < 0) 
return gs_throw(VAR_20, ""Image colors initialization failed"");
if (gs_color_space_is_PSCIE(VAR_17) && VAR_17->icc_equivalent == NULL) {
gs_colorspace_set_icc_equivalent((gs_color_space *)VAR_17, &(VAR_7->icc_setup.is_lab),
VAR_1->memory);
if (VAR_7->icc_setup.is_lab) {
gs_color_space *VAR_75 = (gs_color_space *)VAR_17;
rc_decrement(VAR_75->icc_equivalent,""gx_image_enum_begin"");
rc_decrement(VAR_75->cmm_icc_profile_data,""gx_image_enum_begin"");
VAR_75->cmm_icc_profile_data = VAR_1->icc_manager->lab_profile;
rc_increment(VAR_75->cmm_icc_profile_data);
}
}
if (!VAR_8->CombineWithColor)
VAR_18 = rop3_know_T_0(VAR_18) & ~VAR_76;
else if ((rop3_uses_T(VAR_18) && color_draws_b_w(VAR_0, VAR_4) == 0))
VAR_18 = rop3_know_T_0(VAR_18);
if (VAR_18 != VAR_77 &&    
!rop3_uses_T(VAR_18) && VAR_12 == 1 && VAR_23 == 1 &&
(VAR_71 =
color_draws_b_w(VAR_0, VAR_7->icolor0)) >= 0 &&
color_draws_b_w(VAR_0, VAR_7->icolor1) == (VAR_71 ^ 1)
) {
if (VAR_71) {    
gx_device_color VAR_78;
VAR_78 = *(VAR_7->icolor0);
*(VAR_7->icolor0) = *(VAR_7->icolor1);
*(VAR_7->icolor1) = VAR_78;
VAR_18 = rop3_invert_S(VAR_18);
}
switch (VAR_18) {
case VAR_79 & VAR_77:
*(VAR_7->icolor1) = *(VAR_7->icolor0);
case VAR_79 | rop3_not(VAR_77):
memcpy(&VAR_7->map[0].table.lookup4x1to32[0],
VAR_67, 16 * 4);
rmask:        
VAR_7->masked = VAR_13 = true;
set_nonclient_dev_color(VAR_7->icolor0, VAR_66);
VAR_7->map[0].decoding = VAR_69;
VAR_18 = VAR_80;
break;
case VAR_79 & rop3_not(VAR_77):
*(VAR_7->icolor1) = *(VAR_7->icolor0);
case VAR_79 | VAR_77:
memcpy(&VAR_7->map[0].table.lookup4x1to32[0],
VAR_68, 16 * 4);
goto rmask;
default:
;
}
}
}
VAR_7->device_color = VAR_34;
VAR_26 = ((VAR_12 > 8 ? VAR_10 * 2 : VAR_10) + 15) * VAR_23;
VAR_27 = gs_alloc_bytes(VAR_6, VAR_26, ""image buffer"");
if (VAR_27 == 0) {
gs_free_object(VAR_6, VAR_7, ""gx_default_begin_image"");
return_error(VAR_64);
}
VAR_7->bps = VAR_12;
VAR_7->unpack_bps = VAR_12;
VAR_7->log2_xbytes = VAR_21;
VAR_7->spp = VAR_23;
switch (VAR_9) {
case VAR_74:
VAR_24 = 1;
VAR_25 = 1 << VAR_21;
break;
case VAR_73:
VAR_24 = VAR_23;
VAR_25 = VAR_23 << VAR_21;
break;
case VAR_72:
VAR_24 = VAR_23 * VAR_12;
VAR_25 = VAR_23 << VAR_21;
break;
default:
return_error(VAR_81);
}
VAR_7->num_planes = VAR_24;
VAR_7->spread = VAR_25;
VAR_7->interpolate = VAR_40 ? VAR_82 : VAR_8->Interpolate ? VAR_83 : VAR_84;
VAR_7->x_extent = VAR_32;
VAR_7->y_extent = VAR_33;
VAR_7->posture =
((VAR_32.y | VAR_33.x) == 0 ? VAR_85 :
(VAR_32.x | VAR_33.y) == 0 ? VAR_86 :
VAR_87);
VAR_7->pgs = VAR_1;
VAR_7->pcs = VAR_17;
VAR_7->memory = VAR_6;
VAR_7->buffer = VAR_27;
VAR_7->buffer_size = VAR_26;
VAR_7->line = 0;
VAR_7->icc_link = NULL;
VAR_7->color_cache = NULL;
VAR_7->ht_buffer = NULL;
VAR_7->thresh_buffer = NULL;
VAR_7->use_cie_range = false;
VAR_7->line_size = 0;
VAR_7->use_rop = VAR_18 != (VAR_13 ? VAR_80 : VAR_77);
#ifdef VAR_88
if (gs_debug_c('*')) {
if (VAR_7->use_rop)
dmprintf1(VAR_6, ""[%03x]"", VAR_18);
dmprintf5(VAR_6, ""%c%d%c%dx%d "",
(VAR_13 ? (color_is_pure(VAR_4) ? 'm' : 'h') : 'i'),
VAR_12,
(VAR_7->posture == VAR_85 ? ' ' :
VAR_7->posture == VAR_86 ? 'L' : 'T'),
VAR_10, VAR_11);
}
#endif
VAR_7->slow_loop = 0;
if (VAR_5 == 0) {
(*dev_proc(VAR_0, VAR_89)) (VAR_0, &VAR_35);
VAR_36 = VAR_35;
VAR_7->clip_image = 0;
} else
VAR_7->clip_image =
(gx_cpath_outer_box(VAR_5, &VAR_35) |        
gx_cpath_inner_box(VAR_5, &VAR_36) ?
0 : VAR_90);
VAR_7->clip_outer = VAR_35;
VAR_7->clip_inner = VAR_36;
VAR_7->log_op = VAR_80;     
VAR_7->clip_dev = 0;        
VAR_7->rop_dev = 0;         
VAR_7->scaler = 0;          
{
fixed
VAR_91 = min(VAR_30.x, 0) + min(VAR_31.x, 0),
VAR_92 = max(VAR_30.x, 0) + max(VAR_31.x, 0),
VAR_93 = min(VAR_30.y, 0) + min(VAR_31.y, 0),
VAR_94 = max(VAR_30.y, 0) + max(VAR_31.y, 0);
{
int VAR_95, VAR_96;
switch (VAR_7->posture) {
case VAR_85:
VAR_95 = VAR_10, VAR_96 = VAR_11;
break;
case VAR_86:
VAR_95 = VAR_11, VAR_96 = VAR_10;
break;
default:
VAR_95 = VAR_96 = 0;
}
if (VAR_95 == 1 && VAR_92 - VAR_91 < VAR_50) {
fixed VAR_97 =
arith_rshift_1(VAR_30.x + VAR_31.x);
VAR_28 = (((VAR_28 + VAR_97) | VAR_98) & -VAR_98) - VAR_97;
}
if (VAR_96 == 1 && VAR_94 - VAR_93 < VAR_50) {
fixed VAR_97 =
arith_rshift_1(VAR_30.y + VAR_31.y);
VAR_29 = (((VAR_29 + VAR_97) | VAR_98) & -VAR_98) - VAR_97;
}
}
if_debug5m('b', VAR_6, ""[b]Image: %sspp=%d, bps=%d, mt=(%g,%g)\n"",
(VAR_13? ""masked, "" : """"), VAR_23, VAR_12,
fixed2float(VAR_28), fixed2float(VAR_29));
if_debug9m('b', VAR_6,
""[b]   cbox=(%g,%g),(%g,%g), obox=(%g,%g),(%g,%g), clip_image=0x%x\n"",
fixed2float(VAR_36.p.x), fixed2float(VAR_36.p.y),
fixed2float(VAR_36.q.x), fixed2float(VAR_36.q.y),
fixed2float(VAR_35.p.x), fixed2float(VAR_35.p.y),
fixed2float(VAR_35.q.x), fixed2float(VAR_35.q.y),
VAR_7->clip_image);
dda_init(VAR_7->dda.row.x, VAR_28, VAR_31.x, VAR_11);
dda_init(VAR_7->dda.row.y, VAR_29, VAR_31.y, VAR_11);
if (VAR_7->posture == VAR_85) {
VAR_7->dst_width = VAR_30.x;
VAR_7->dst_height = VAR_31.y;
} else {
VAR_7->dst_width = VAR_31.x;
VAR_7->dst_height = VAR_30.y;
}
VAR_7->yi0 = fixed2int_pixround_perfect(dda_current(VAR_7->dda.row.y)); 
if (VAR_7->rect.y) {
int VAR_99 = VAR_7->rect.y;
while (VAR_99--) {
dda_next(VAR_7->dda.row.x);
dda_next(VAR_7->dda.row.y);
}
}
VAR_7->cur.x = VAR_7->prev.x = dda_current(VAR_7->dda.row.x);
VAR_7->cur.y = VAR_7->prev.y = dda_current(VAR_7->dda.row.y);
dda_init(VAR_7->dda.strip.x, VAR_7->cur.x, VAR_30.x, VAR_10);
dda_init(VAR_7->dda.strip.y, VAR_7->cur.y, VAR_30.y, VAR_10);
if (VAR_7->rect.x) {
dda_advance(VAR_7->dda.strip.x, VAR_7->rect.x);
dda_advance(VAR_7->dda.strip.y, VAR_7->rect.x);
}
{
fixed VAR_100 = dda_current(VAR_7->dda.strip.x);
fixed VAR_101 = dda_current(VAR_7->dda.strip.y);
if (!VAR_7->clip_image)     
VAR_7->clip_image =
(fixed_pixround(VAR_100 + VAR_91) < fixed_pixround(VAR_36.p.x) ?
VAR_102 : 0) +
(fixed_pixround(VAR_100 + VAR_92) >= fixed_pixround(VAR_36.q.x) ?
VAR_103 : 0) +
(fixed_pixround(VAR_101 + VAR_93) < fixed_pixround(VAR_36.p.y) ?
VAR_104 : 0) +
(fixed_pixround(VAR_101 + VAR_94) >= fixed_pixround(VAR_36.q.y) ?
VAR_105 : 0);
}
}
VAR_7->y = 0;
VAR_7->used.x = 0;
VAR_7->used.y = 0;
{
static sample_unpack_proc_t VAR_106[2][6] = {
{   VAR_107, VAR_108,
VAR_109, VAR_110,
VAR_111, VAR_112
},
{   VAR_113, VAR_114,
VAR_115, VAR_116,
VAR_111, VAR_112
}};
int VAR_117 = VAR_7->num_planes;
bool VAR_118 = (VAR_117 == 1 && VAR_7->plane_depths[0] != VAR_7->bps);
int VAR_119;
if (VAR_118) {
int VAR_120 = VAR_7->plane_depths[0] / VAR_7->bps;
for (VAR_119 = 1; VAR_119 < VAR_120; VAR_119++) {
if (VAR_14[0] != VAR_14[VAR_119 * 2 + 0] ||
VAR_14[1] != VAR_14[VAR_119 * 2 + 1])
break;
}
if (VAR_119 == VAR_120)
VAR_118 = false; 
}
VAR_7->unpack = VAR_106[VAR_118][VAR_16];
if_debug1m('b', VAR_6, ""[b]unpack=%d\n"", VAR_12);
VAR_7->dda.pixel0 = VAR_7->dda.strip;
for (VAR_119 = 0; VAR_119 < VAR_121; ++VAR_119)
if ((VAR_7->render = VAR_122[VAR_119](VAR_7)) != 0)
break;
if (VAR_119 == VAR_121) {
gx_default_end_image(VAR_0, (gx_image_enum_common_t *) VAR_7,
false);
return_error(VAR_65);
}
}
if (VAR_7->clip_image && VAR_5) {  
gx_device_clip *VAR_123 =
gs_alloc_struct(VAR_6, gx_device_clip,
&VAR_124, ""image clipper"");
if (VAR_123 == 0) {
gx_default_end_image(VAR_0,
(gx_image_enum_common_t *) VAR_7,
false);
return_error(VAR_64);
}
gx_make_clip_device_in_heap(VAR_123, VAR_5, VAR_0, VAR_6);
VAR_7->clip_dev = VAR_123;
}
if (VAR_7->use_rop) {       
gx_device_rop_texture *VAR_125;
VAR_20 = gx_alloc_rop_texture_device(&VAR_125, VAR_6,
""image RasterOp"");
if (VAR_20 < 0) {
gx_default_end_image(VAR_0, (gx_image_enum_common_t *) VAR_7,
false);
return VAR_20;
}
if (!VAR_7->clip_dev && !VAR_0)
return_error(VAR_126);
gx_make_rop_texture_device(VAR_125,
(VAR_7->clip_dev != 0 ?
(gx_device *) VAR_7->clip_dev :
VAR_0), VAR_18, VAR_4);
gx_device_retain((gx_device *)VAR_125, true);
VAR_7->rop_dev = VAR_125;
}
return 0;
}",ArtifexSoftware/ghostpdl/ecceafe3abba2714ef9b432035fe0739d9b1a283/gxipixel.c/vul/before/0.json,"int
gx_image_enum_begin(gx_device * dev, const gs_gstate * pgs,
                    const gs_matrix *pmat, const gs_image_common_t * pic,
                const gx_drawing_color * pdcolor, const gx_clip_path * pcpath,
                gs_memory_t * mem, gx_image_enum *penum)
{
    const gs_pixel_image_t *pim = (const gs_pixel_image_t *)pic;
    gs_image_format_t format = pim->format;
    const int width = pim->Width;
    const int height = pim->Height;
    const int bps = pim->BitsPerComponent;
    bool masked = penum->masked;
    const float *decode = pim->Decode;
    gs_matrix_double mat;
    int index_bps;
    const gs_color_space *pcs = pim->ColorSpace;
    gs_logical_operation_t lop = (pgs ? pgs->log_op : lop_default);
    int code;
    int log2_xbytes = (bps <= 8 ? 0 : arch_log2_sizeof_frac);
    int spp, nplanes, spread;
    uint bsize;
    byte *buffer;
    fixed mtx, mty;
    gs_fixed_point row_extent, col_extent, x_extent, y_extent;
    bool device_color = true;
    gs_fixed_rect obox, cbox;
    bool gridfitimages = 0;
    bool in_pattern_accumulator = 0;
    int orthogonal;
    int force_interpolation = 0;

    penum->clues = NULL;
    penum->icc_setup.has_transfer = false;
    penum->icc_setup.is_lab = false;
    penum->icc_setup.must_halftone = false;
    penum->icc_setup.need_decode = false;
    penum->Width = width;
    penum->Height = height;

    if ((code = gx_image_compute_mat(pgs, pmat, &(pim->ImageMatrix), &mat)) < 0) {
        return code;
    }
    /* Grid fit: A common construction in postscript/PDF files is for images
     * to be constructed as a series of 'stacked' 1 pixel high images.
     * Furthermore, many of these are implemented as an imagemask plotted on
     * top of thin rectangles. The different fill rules for images and line
     * art produces problems; line art fills a pixel if any part of it is
     * touched - images only fill a pixel if the centre of the pixel is
     * covered. Bug 692666 is such a problem.
     *
     * As a workaround for this problem, the code below was introduced. The
     * concept is that orthogonal images can be 'grid fitted' (or 'stretch')
     * to entirely cover pixels that they touch. Initially I had this working
     * for all images regardless of type, but as testing has proceeded, this
     * showed more and more regressions, so I've cut the cases back in which
     * this code is used until it now only triggers on imagemasks that are
     * either 1 pixel high, or wide, and then not if we are rendering a
     * glyph (such as from a type3 font).
     */

    /* Ask the device if we are in a pattern accumulator */
    in_pattern_accumulator = (dev_proc(dev, dev_spec_op)(dev, gxdso_in_pattern_accumulator, NULL, 0));
    if (in_pattern_accumulator < 0)
        in_pattern_accumulator = 0;

    /* Figure out if we are orthogonal */
    if (mat.xy == 0 && mat.yx == 0)
        orthogonal = 1;
    else if (mat.xx == 0 && mat.yy == 0)
        orthogonal = 2;
    else
        orthogonal = 0;

    /* If we are in a pattern accumulator, we choose to always grid fit
     * orthogonal images. We do this by asking the device whether we
     * should grid fit. This allows us to avoid nasty blank lines around
     * the edges of cells.
     */
    gridfitimages = in_pattern_accumulator && orthogonal;

    if (pgs != NULL && pgs->show_gstate != NULL) {
        /* If we're a graphics state, and we're in a text object, then we
         * must be in a type3 font. Don't fiddle with it. */
    } else if (!gridfitimages &&
               (!penum->masked || penum->image_parent_type != 0)) {
        /* Other than for images we are specifically looking to grid fit (such as
         * ones in a pattern device), we only grid fit imagemasks */
    } else if (gridfitimages && (penum->masked && penum->image_parent_type == 0)) {
        /* We don't gridfit imagemasks in a pattern accumulator */
    } else if (pgs != NULL && pgs->fill_adjust.x == 0 && pgs->fill_adjust.y == 0) {
        /* If fill adjust is disabled, so is grid fitting */
    } else if (orthogonal == 1) {
        if (width == 1 || gridfitimages) {
            if (mat.xx > 0) {
                fixed ix0 = int2fixed(fixed2int(float2fixed(mat.tx)));
                double x1 = mat.tx + mat.xx * width;
                fixed ix1 = int2fixed(fixed2int_ceiling(float2fixed(x1)));
                mat.tx = (double)fixed2float(ix0);
                mat.xx = (double)(fixed2float(ix1 - ix0)/width);
            } else if (mat.xx < 0) {
                fixed ix0 = int2fixed(fixed2int_ceiling(float2fixed(mat.tx)));
                double x1 = mat.tx + mat.xx * width;
                fixed ix1 = int2fixed(fixed2int(float2fixed(x1)));
                mat.tx = (double)fixed2float(ix0);
                mat.xx = (double)(fixed2float(ix1 - ix0)/width);
            }
        }
        if (height == 1 || gridfitimages) {
            if (mat.yy > 0) {
                fixed iy0 = int2fixed(fixed2int(float2fixed(mat.ty)));
                double y1 = mat.ty + mat.yy * height;
                fixed iy1 = int2fixed(fixed2int_ceiling(float2fixed(y1)));
                mat.ty = (double)fixed2float(iy0);
                mat.yy = (double)(fixed2float(iy1 - iy0)/height);
            } else if (mat.yy < 0) {
                fixed iy0 = int2fixed(fixed2int_ceiling(float2fixed(mat.ty)));
                double y1 = mat.ty + mat.yy * height;
                fixed iy1 = int2fixed(fixed2int(float2fixed(y1)));
                mat.ty = (double)fixed2float(iy0);
                mat.yy = ((double)fixed2float(iy1 - iy0)/height);
            }
        }
    } else if (orthogonal == 2) {
        if (height == 1 || gridfitimages) {
            if (mat.yx > 0) {
                fixed ix0 = int2fixed(fixed2int(float2fixed(mat.tx)));
                double x1 = mat.tx + mat.yx * height;
                fixed ix1 = int2fixed(fixed2int_ceiling(float2fixed(x1)));
                mat.tx = (double)fixed2float(ix0);
                mat.yx = (double)(fixed2float(ix1 - ix0)/height);
            } else if (mat.yx < 0) {
                fixed ix0 = int2fixed(fixed2int_ceiling(float2fixed(mat.tx)));
                double x1 = mat.tx + mat.yx * height;
                fixed ix1 = int2fixed(fixed2int(float2fixed(x1)));
                mat.tx = (double)fixed2float(ix0);
                mat.yx = (double)(fixed2float(ix1 - ix0)/height);
            }
        }
        if (width == 1 || gridfitimages) {
            if (mat.xy > 0) {
                fixed iy0 = int2fixed(fixed2int(float2fixed(mat.ty)));
                double y1 = mat.ty + mat.xy * width;
                fixed iy1 = int2fixed(fixed2int_ceiling(float2fixed(y1)));
                mat.ty = (double)fixed2float(iy0);
                mat.xy = (double)(fixed2float(iy1 - iy0)/width);
            } else if (mat.xy < 0) {
                fixed iy0 = int2fixed(fixed2int_ceiling(float2fixed(mat.ty)));
                double y1 = mat.ty + mat.xy * width;
                fixed iy1 = int2fixed(fixed2int(float2fixed(y1)));
                mat.ty = (double)fixed2float(iy0);
                mat.xy = ((double)fixed2float(iy1 - iy0)/width);
            }
        }
    }

    /* When rendering to a pattern accumulator, if we are downscaling
     * then enable interpolation, as otherwise dropouts can cause
     * serious problems. */
    if (in_pattern_accumulator) {
        double ome = ((double)(fixed_1 - fixed_epsilon)) / (double)fixed_1; /* One Minus Epsilon */

        if (orthogonal == 1) {
            if ((mat.xx > -ome && mat.xx < ome) || (mat.yy > -ome && mat.yy < ome)) {
                force_interpolation = true;
            }
        } else if (orthogonal == 2) {
            if ((mat.xy > -ome && mat.xy < ome) || (mat.yx > -ome && mat.yx < ome)) {
                force_interpolation = true;
            }
        }
    }

    /* Can we restrict the amount of image we need? */
    while (pcpath) /* So we can break out of it */
    {
        gs_rect rect, rect_out;
        gs_matrix mi;
        gs_fixed_rect obox;
        gs_int_rect irect;
        if ((code = gs_matrix_invert(&ctm_only(pgs), &mi)) < 0 ||
            (code = gs_matrix_multiply(&mi, &pic->ImageMatrix, &mi)) < 0) {
            /* Give up trying to shrink the render box, but continue processing */
            break;
        }
        gx_cpath_outer_box(pcpath, &obox);
        rect.p.x = fixed2float(obox.p.x);
        rect.p.y = fixed2float(obox.p.y);
        rect.q.x = fixed2float(obox.q.x);
        rect.q.y = fixed2float(obox.q.y);
        code = gs_bbox_transform(&rect, &mi, &rect_out);
        if (code < 0) {
            /* Give up trying to shrink the render box, but continue processing */
            break;
        }
        irect.p.x = (int)(rect_out.p.x-1.0);
        irect.p.y = (int)(rect_out.p.y-1.0);
        irect.q.x = (int)(rect_out.q.x+1.0);
        irect.q.y = (int)(rect_out.q.y+1.0);
        /* Need to expand the region to allow for the fact that the mitchell
         * scaler reads multiple pixels in. This calculation can probably be
         * improved. */
        /* If mi.{xx,yy} > 1 then we are downscaling. During downscaling,
         * the support increases to ensure that we don't lose pixels contributions
         * entirely. */
        /* I do not understand the need for the +/- 1 fudge factors,
         * but they seem to be required. Increasing the render rectangle can
         * never be bad at least... RJW */
        {
            float support = any_abs(mi.xx);
            int isupport;
            if (any_abs(mi.yy) > support)
                support = any_abs(mi.yy);
            if (any_abs(mi.xy) > support)
                support = any_abs(mi.xy);
            if (any_abs(mi.yx) > support)
                support = any_abs(mi.yx);
            isupport = (int)(MAX_ISCALE_SUPPORT * (support+1)) + 1;
            irect.p.x -= isupport;
            irect.p.y -= isupport;
            irect.q.x += isupport;
            irect.q.y += isupport;
        }
        if (penum->rrect.x < irect.p.x) {
            penum->rrect.w -= irect.p.x - penum->rrect.x;
            if (penum->rrect.w < 0)
               penum->rrect.w = 0;
            penum->rrect.x = irect.p.x;
        }
        if (penum->rrect.x + penum->rrect.w > irect.q.x) {
            penum->rrect.w = irect.q.x - penum->rrect.x;
            if (penum->rrect.w < 0)
                penum->rrect.w = 0;
        }
        if (penum->rrect.y < irect.p.y) {
            penum->rrect.h -= irect.p.y - penum->rrect.y;
            if (penum->rrect.h < 0)
                penum->rrect.h = 0;
            penum->rrect.y = irect.p.y;
        }
        if (penum->rrect.y + penum->rrect.h > irect.q.y) {
            penum->rrect.h = irect.q.y - penum->rrect.y;
            if (penum->rrect.h < 0)
                penum->rrect.h = 0;
        }
        break; /* Out of the while */
    }
    /* Check for the intersection being null */
    if (penum->rrect.x + penum->rrect.w <= penum->rect.x  ||
        penum->rect.x  + penum->rect.w  <= penum->rrect.x ||
        penum->rrect.y + penum->rrect.h <= penum->rect.y  ||
        penum->rect.y  + penum->rect.h  <= penum->rrect.y)
    {
          /* Something may have gone wrong with the floating point above.
           * set the region to something sane. */
        penum->rrect.x = penum->rect.x;
        penum->rrect.y = penum->rect.y;
        penum->rrect.w = 0;
        penum->rrect.h = 0;
    }

    /*penum->matrix = mat;*/
    penum->matrix.xx = mat.xx;
    penum->matrix.xy = mat.xy;
    penum->matrix.yx = mat.yx;
    penum->matrix.yy = mat.yy;
    penum->matrix.tx = mat.tx;
    penum->matrix.ty = mat.ty;
    if_debug6m('b', mem, "" [%g %g %g %g %g %g]\n"",
              mat.xx, mat.xy, mat.yx, mat.yy, mat.tx, mat.ty);
    /* following works for 1, 2, 4, 8, 12, 16 */
    index_bps = (bps < 8 ? bps >> 1 : (bps >> 2) + 1);
    /*
     * Compute extents with distance transformation.
     */
    if (mat.tx > 0)
        mtx = float2fixed(mat.tx);
    else { /* Use positive values to ensure round down. */
        int f = (int)-mat.tx + 1;

        mtx = float2fixed(mat.tx + f) - int2fixed(f);
    }
    if (mat.ty > 0)
        mty = float2fixed(mat.ty);
    else {  /* Use positive values to ensure round down. */
        int f = (int)-mat.ty + 1;

        mty = float2fixed(mat.ty + f) - int2fixed(f);
    }

    row_extent.x = float2fixed_rounded_boxed(width * mat.xx);
    row_extent.y =
        (is_fzero(mat.xy) ? fixed_0 :
         float2fixed_rounded_boxed(width * mat.xy));
    col_extent.x =
        (is_fzero(mat.yx) ? fixed_0 :
         float2fixed_rounded_boxed(height * mat.yx));
    col_extent.y = float2fixed_rounded_boxed(height * mat.yy);
    gx_image_enum_common_init((gx_image_enum_common_t *)penum,
                              (const gs_data_image_t *)pim,
                              &image1_enum_procs, dev,
                              (masked ? 1 : (penum->alpha ? cs_num_components(pcs)+1 : cs_num_components(pcs))),
                              format);
    if (penum->rect.w == width && penum->rect.h == height) {
        x_extent = row_extent;
        y_extent = col_extent;
    } else {
        int rw = penum->rect.w, rh = penum->rect.h;

        x_extent.x = float2fixed_rounded_boxed(rw * mat.xx);
        x_extent.y =
            (is_fzero(mat.xy) ? fixed_0 :
             float2fixed_rounded_boxed(rw * mat.xy));
        y_extent.x =
            (is_fzero(mat.yx) ? fixed_0 :
             float2fixed_rounded_boxed(rh * mat.yx));
        y_extent.y = float2fixed_rounded_boxed(rh * mat.yy);
    }
    /* Set icolor0 and icolor1 to point to image clues locations if we have
       1spp or an imagemask, otherwise image clues is not used and
       we have these values point to other member variables */
    if (masked || cs_num_components(pcs) == 1) {
        /* Go ahead and allocate now if not already done.  For a mask
           we really should only do 2 values. For now, the goal is to
           eliminate the 256 bytes for the >8bpp image enumerator */
        penum->clues = (gx_image_clue*) gs_alloc_bytes(mem, sizeof(gx_image_clue)*256,
                             ""gx_image_enum_begin"");
        if (penum->clues == NULL)
            return_error(gs_error_VMerror);
        penum->icolor0 = &(penum->clues[0].dev_color);
        penum->icolor1 = &(penum->clues[255].dev_color);
    } else {
        penum->icolor0 = &(penum->icolor0_val);
        penum->icolor1 = &(penum->icolor1_val);
    }
    if (masked) {       /* This is imagemask. */
        if (bps != 1 || pcs != NULL || penum->alpha || decode[0] == decode[1]) {
            return_error(gs_error_rangecheck);
        }
        /* Initialize color entries 0 and 255. */
        set_nonclient_dev_color(penum->icolor0, gx_no_color_index);
        set_nonclient_dev_color(penum->icolor1, gx_no_color_index);
        *(penum->icolor1) = *pdcolor;
        memcpy(&penum->map[0].table.lookup4x1to32[0],
               (decode[0] < decode[1] ? lookup4x1to32_inverted :
                lookup4x1to32_identity),
               16 * 4);
        penum->map[0].decoding = sd_none;
        spp = 1;
        lop = rop3_know_S_0(lop);
    } else {                    /* This is image, not imagemask. */
        const gs_color_space_type *pcst = pcs->type;
        int b_w_color;

        spp = cs_num_components(pcs);
        if (spp < 0) {          /* Pattern not allowed */
            return_error(gs_error_rangecheck);
        }
        if (penum->alpha)
            ++spp;
        /* Use a less expensive format if possible. */
        switch (format) {
        case gs_image_format_bit_planar:
            if (bps > 1)
                break;
            format = gs_image_format_component_planar;
        case gs_image_format_component_planar:
            if (spp == 1)
                format = gs_image_format_chunky;
        default:                /* chunky */
            break;
        }

        if (pcs->cmm_icc_profile_data != NULL) {
            device_color = false;
        } else {
            device_color = (*pcst->concrete_space) (pcs, pgs) == pcs;
        }

        code = image_init_colors(penum, bps, spp, format, decode, pgs, dev,
                          pcs, &device_color);
        if (code < 0) 
            return gs_throw(code, ""Image colors initialization failed"");
        /* If we have a CIE based color space and the icc equivalent profile
           is not yet set, go ahead and handle that now.  It may already
           be done due to the above init_colors which may go through remap. */
        if (gs_color_space_is_PSCIE(pcs) && pcs->icc_equivalent == NULL) {
            gs_colorspace_set_icc_equivalent((gs_color_space *)pcs, &(penum->icc_setup.is_lab),
                                                pgs->memory);
            if (penum->icc_setup.is_lab) {
                /* Free what ever profile was created and use the icc manager's
                   cielab profile */
                gs_color_space *curr_pcs = (gs_color_space *)pcs;
                rc_decrement(curr_pcs->icc_equivalent,""gx_image_enum_begin"");
                rc_decrement(curr_pcs->cmm_icc_profile_data,""gx_image_enum_begin"");
                curr_pcs->cmm_icc_profile_data = pgs->icc_manager->lab_profile;
                rc_increment(curr_pcs->cmm_icc_profile_data);
            }
        }
        /* Try to transform non-default RasterOps to something */
        /* that we implement less expensively. */
        if (!pim->CombineWithColor)
            lop = rop3_know_T_0(lop) & ~lop_T_transparent;
        else if ((rop3_uses_T(lop) && color_draws_b_w(dev, pdcolor) == 0))
            lop = rop3_know_T_0(lop);

        if (lop != rop3_S &&    /* if best case, no more work needed */
            !rop3_uses_T(lop) && bps == 1 && spp == 1 &&
            (b_w_color =
             color_draws_b_w(dev, penum->icolor0)) >= 0 &&
            color_draws_b_w(dev, penum->icolor1) == (b_w_color ^ 1)
            ) {
            if (b_w_color) {    /* Swap the colors and invert the RasterOp source. */
                gx_device_color dcolor;

                dcolor = *(penum->icolor0);
                *(penum->icolor0) = *(penum->icolor1);
                *(penum->icolor1) = dcolor;
                lop = rop3_invert_S(lop);
            }
            /*
             * At this point, we know that the source pixels
             * correspond directly to the S input for the raster op,
             * i.e., icolor0 is black and icolor1 is white.
             */
            switch (lop) {
                case rop3_D & rop3_S:
                    /* Implement this as an inverted mask writing 0s. */
                    *(penum->icolor1) = *(penum->icolor0);
                    /* (falls through) */
                case rop3_D | rop3_not(rop3_S):
                    /* Implement this as an inverted mask writing 1s. */
                    memcpy(&penum->map[0].table.lookup4x1to32[0],
                           lookup4x1to32_inverted, 16 * 4);
                  rmask:        /* Fill in the remaining parameters for a mask. */
                    penum->masked = masked = true;
                    set_nonclient_dev_color(penum->icolor0, gx_no_color_index);
                    penum->map[0].decoding = sd_none;
                    lop = rop3_T;
                    break;
                case rop3_D & rop3_not(rop3_S):
                    /* Implement this as a mask writing 0s. */
                    *(penum->icolor1) = *(penum->icolor0);
                    /* (falls through) */
                case rop3_D | rop3_S:
                    /* Implement this as a mask writing 1s. */
                    memcpy(&penum->map[0].table.lookup4x1to32[0],
                           lookup4x1to32_identity, 16 * 4);
                    goto rmask;
                default:
                    ;
            }
        }
    }
    penum->device_color = device_color;
    /*
     * Adjust width upward for unpacking up to 7 trailing bits in
     * the row, plus 1 byte for end-of-run, plus up to 7 leading
     * bits for data_x offset within a packed byte.
     */
    bsize = ((bps > 8 ? width * 2 : width) + 15) * spp;
    buffer = gs_alloc_bytes(mem, bsize, ""image buffer"");
    if (buffer == 0) {
        return_error(gs_error_VMerror);
    }
    penum->bps = bps;
    penum->unpack_bps = bps;
    penum->log2_xbytes = log2_xbytes;
    penum->spp = spp;
    switch (format) {
    case gs_image_format_chunky:
        nplanes = 1;
        spread = 1 << log2_xbytes;
        break;
    case gs_image_format_component_planar:
        nplanes = spp;
        spread = spp << log2_xbytes;
        break;
    case gs_image_format_bit_planar:
        nplanes = spp * bps;
        spread = spp << log2_xbytes;
        break;
    default:
        /* No other cases are possible (checked by gx_image_enum_alloc). */
        return_error(gs_error_Fatal);
    }
    penum->num_planes = nplanes;
    penum->spread = spread;
    /*
     * If we're asked to interpolate in a partial image, we have to
     * assume that the client either really only is interested in
     * the given sub-image, or else is constructing output out of
     * overlapping pieces.
     */
    penum->interpolate = force_interpolation ? interp_force : pim->Interpolate ? interp_on : interp_off;
    penum->x_extent = x_extent;
    penum->y_extent = y_extent;
    penum->posture =
        ((x_extent.y | y_extent.x) == 0 ? image_portrait :
         (x_extent.x | y_extent.y) == 0 ? image_landscape :
         image_skewed);
    penum->pgs = pgs;
    penum->pcs = pcs;
    penum->memory = mem;
    penum->buffer = buffer;
    penum->buffer_size = bsize;
    penum->line = 0;
    penum->icc_link = NULL;
    penum->color_cache = NULL;
    penum->ht_buffer = NULL;
    penum->thresh_buffer = NULL;
    penum->use_cie_range = false;
    penum->line_size = 0;
    penum->use_rop = lop != (masked ? rop3_T : rop3_S);
#ifdef DEBUG
    if (gs_debug_c('*')) {
        if (penum->use_rop)
            dmprintf1(mem, ""[%03x]"", lop);
        dmprintf5(mem, ""%c%d%c%dx%d "",
                 (masked ? (color_is_pure(pdcolor) ? 'm' : 'h') : 'i'),
                 bps,
                 (penum->posture == image_portrait ? ' ' :
                  penum->posture == image_landscape ? 'L' : 'T'),
                 width, height);
    }
#endif
    penum->slow_loop = 0;
    if (pcpath == 0) {
        (*dev_proc(dev, get_clipping_box)) (dev, &obox);
        cbox = obox;
        penum->clip_image = 0;
    } else
        penum->clip_image =
            (gx_cpath_outer_box(pcpath, &obox) |        /* not || */
             gx_cpath_inner_box(pcpath, &cbox) ?
             0 : image_clip_region);
    penum->clip_outer = obox;
    penum->clip_inner = cbox;
    penum->log_op = rop3_T;     /* rop device takes care of this */
    penum->clip_dev = 0;        /* in case we bail out */
    penum->rop_dev = 0;         /* ditto */
    penum->scaler = 0;          /* ditto */
    /*
     * If all four extrema of the image fall within the clipping
     * rectangle, clipping is never required.  When making this check,
     * we must carefully take into account the fact that we only care
     * about pixel centers.
     */
    {
        fixed
            epx = min(row_extent.x, 0) + min(col_extent.x, 0),
            eqx = max(row_extent.x, 0) + max(col_extent.x, 0),
            epy = min(row_extent.y, 0) + min(col_extent.y, 0),
            eqy = max(row_extent.y, 0) + max(col_extent.y, 0);

        {
            int hwx, hwy;

            switch (penum->posture) {
                case image_portrait:
                    hwx = width, hwy = height;
                    break;
                case image_landscape:
                    hwx = height, hwy = width;
                    break;
                default:
                    hwx = hwy = 0;
            }
            /*
             * If the image is only 1 sample wide or high,
             * and is less than 1 device pixel wide or high,
             * move it slightly so that it covers pixel centers.
             * This is a hack to work around a bug in some old
             * versions of TeX/dvips, which use 1-bit-high images
             * to draw horizontal and vertical lines without
             * positioning them properly.
             */
            if (hwx == 1 && eqx - epx < fixed_1) {
                fixed diff =
                arith_rshift_1(row_extent.x + col_extent.x);

                mtx = (((mtx + diff) | fixed_half) & -fixed_half) - diff;
            }
            if (hwy == 1 && eqy - epy < fixed_1) {
                fixed diff =
                arith_rshift_1(row_extent.y + col_extent.y);

                mty = (((mty + diff) | fixed_half) & -fixed_half) - diff;
            }
        }
        if_debug5m('b', mem, ""[b]Image: %sspp=%d, bps=%d, mt=(%g,%g)\n"",
                   (masked? ""masked, "" : """"), spp, bps,
                   fixed2float(mtx), fixed2float(mty));
        if_debug9m('b', mem,
                   ""[b]   cbox=(%g,%g),(%g,%g), obox=(%g,%g),(%g,%g), clip_image=0x%x\n"",
                   fixed2float(cbox.p.x), fixed2float(cbox.p.y),
                   fixed2float(cbox.q.x), fixed2float(cbox.q.y),
                   fixed2float(obox.p.x), fixed2float(obox.p.y),
                   fixed2float(obox.q.x), fixed2float(obox.q.y),
                   penum->clip_image);
        /* These DDAs enumerate the starting position of each source pixel
         * row in device space. */
        dda_init(penum->dda.row.x, mtx, col_extent.x, height);
        dda_init(penum->dda.row.y, mty, col_extent.y, height);
        if (penum->posture == image_portrait) {
            penum->dst_width = row_extent.x;
            penum->dst_height = col_extent.y;
        } else {
            penum->dst_width = col_extent.x;
            penum->dst_height = row_extent.y;
        }
        /* For gs_image_class_0_interpolate. */
        penum->yi0 = fixed2int_pixround_perfect(dda_current(penum->dda.row.y)); /* For gs_image_class_0_interpolate. */
        if (penum->rect.y) {
            int y = penum->rect.y;

            while (y--) {
                dda_next(penum->dda.row.x);
                dda_next(penum->dda.row.y);
            }
        }
        penum->cur.x = penum->prev.x = dda_current(penum->dda.row.x);
        penum->cur.y = penum->prev.y = dda_current(penum->dda.row.y);
        /* These DDAs enumerate the starting positions of each row of our
         * source pixel data, in the subrectangle ('strip') that we are
         * actually rendering. */
        dda_init(penum->dda.strip.x, penum->cur.x, row_extent.x, width);
        dda_init(penum->dda.strip.y, penum->cur.y, row_extent.y, width);
        if (penum->rect.x) {
            dda_advance(penum->dda.strip.x, penum->rect.x);
            dda_advance(penum->dda.strip.y, penum->rect.x);
        }
        {
            fixed ox = dda_current(penum->dda.strip.x);
            fixed oy = dda_current(penum->dda.strip.y);

            if (!penum->clip_image)     /* i.e., not clip region */
                penum->clip_image =
                    (fixed_pixround(ox + epx) < fixed_pixround(cbox.p.x) ?
                     image_clip_xmin : 0) +
                    (fixed_pixround(ox + eqx) >= fixed_pixround(cbox.q.x) ?
                     image_clip_xmax : 0) +
                    (fixed_pixround(oy + epy) < fixed_pixround(cbox.p.y) ?
                     image_clip_ymin : 0) +
                    (fixed_pixround(oy + eqy) >= fixed_pixround(cbox.q.y) ?
                     image_clip_ymax : 0);
        }
    }
    penum->y = 0;
    penum->used.x = 0;
    penum->used.y = 0;
    {
        static sample_unpack_proc_t procs[2][6] = {
        {   sample_unpack_1, sample_unpack_2,
            sample_unpack_4, sample_unpack_8,
            sample_unpack_12, sample_unpack_16
        },
        {   sample_unpack_1_interleaved, sample_unpack_2_interleaved,
            sample_unpack_4_interleaved, sample_unpack_8_interleaved,
            sample_unpack_12, sample_unpack_16
        }};
        int num_planes = penum->num_planes;
        bool interleaved = (num_planes == 1 && penum->plane_depths[0] != penum->bps);
        int i;

        if (interleaved) {
            int num_components = penum->plane_depths[0] / penum->bps;

            for (i = 1; i < num_components; i++) {
                if (decode[0] != decode[i * 2 + 0] ||
                    decode[1] != decode[i * 2 + 1])
                    break;
            }
            if (i == num_components)
                interleaved = false; /* Use single table. */
        }
        penum->unpack = procs[interleaved][index_bps];

        if_debug1m('b', mem, ""[b]unpack=%d\n"", bps);
        /* Set up pixel0 for image class procedures. */
        penum->dda.pixel0 = penum->dda.strip;
        for (i = 0; i < gx_image_class_table_count; ++i)
            if ((penum->render = gx_image_class_table[i](penum)) != 0)
                break;
        if (i == gx_image_class_table_count) {
            /* No available class can handle this image. */
            gx_default_end_image(dev, (gx_image_enum_common_t *) penum,
                                 false);
            return_error(gs_error_rangecheck);
        }
    }
    if (penum->clip_image && pcpath) {  /* Set up the clipping device. */
        gx_device_clip *cdev =
            gs_alloc_struct(mem, gx_device_clip,
                            &st_device_clip, ""image clipper"");

        if (cdev == 0) {
            gx_default_end_image(dev,
                                 (gx_image_enum_common_t *) penum,
                                 false);
            return_error(gs_error_VMerror);
        }
        gx_make_clip_device_in_heap(cdev, pcpath, dev, mem);
        penum->clip_dev = cdev;
    }
    if (penum->use_rop) {       /* Set up the RasterOp source device. */
        gx_device_rop_texture *rtdev;

        code = gx_alloc_rop_texture_device(&rtdev, mem,
                                           ""image RasterOp"");
        if (code < 0) {
            gx_default_end_image(dev, (gx_image_enum_common_t *) penum,
                                 false);
            return code;
        }
        /* The 'target' must not be NULL for gx_make_rop_texture_device */
        if (!penum->clip_dev && !dev)
            return_error(gs_error_undefined);

        gx_make_rop_texture_device(rtdev,
                                   (penum->clip_dev != 0 ?
                                    (gx_device *) penum->clip_dev :
                                    dev), lop, pdcolor);
        gx_device_retain((gx_device *)rtdev, true);
        penum->rop_dev = rtdev;
    }
    return 0;
}","int
gx_image_enum_begin(gx_device * VAR_0, const gs_gstate * VAR_1,
                    const gs_matrix *VAR_2, const gs_image_common_t * VAR_3,
                const gx_drawing_color * VAR_4, const gx_clip_path * VAR_5,
                gs_memory_t * VAR_6, gx_image_enum *VAR_7)
{
    const gs_pixel_image_t *VAR_8 = (const gs_pixel_image_t *)VAR_3;
    gs_image_format_t VAR_9 = VAR_8->format;
    const int VAR_10 = VAR_8->Width;
    const int VAR_11 = VAR_8->Height;
    const int VAR_12 = VAR_8->BitsPerComponent;
    bool VAR_13 = VAR_7->masked;
    const float *VAR_14 = VAR_8->Decode;
    gs_matrix_double VAR_15;
    int VAR_16;
    const gs_color_space *VAR_17 = VAR_8->ColorSpace;
    gs_logical_operation_t VAR_18 = (VAR_1 ? VAR_1->log_op : VAR_19);
    int VAR_20;
    int VAR_21 = (VAR_12 <= 8 ? 0 : VAR_22);
    int VAR_23, VAR_24, VAR_25;
    uint VAR_26;
    byte *VAR_27;
    fixed VAR_28, VAR_29;
    gs_fixed_point VAR_30, VAR_31, VAR_32, VAR_33;
    bool VAR_34 = true;
    gs_fixed_rect VAR_35, VAR_36;
    bool VAR_37 = 0;
    bool VAR_38 = 0;
    int VAR_39;
    int VAR_40 = 0;

    VAR_7->clues = NULL;
    VAR_7->icc_setup.has_transfer = false;
    VAR_7->icc_setup.is_lab = false;
    VAR_7->icc_setup.must_halftone = false;
    VAR_7->icc_setup.need_decode = false;
    VAR_7->Width = VAR_10;
    VAR_7->Height = VAR_11;

    if ((VAR_20 = gx_image_compute_mat(VAR_1, VAR_2, &(VAR_8->ImageMatrix), &VAR_15)) < 0) {
        return VAR_20;
    }
    /* COMMENT_0 */
                                                                      
                                                                            
                                                                           
                                                                         
                                                                       
                                             
      
                                                                           
                                                                            
                                                                             
                                                                            
                                                                            
                                                                          
                                                                       
                                         
       

    /* COMMENT_17 */
    VAR_38 = (dev_proc(VAR_0, VAR_41)(VAR_0, VAR_42, NULL, 0));
    if (VAR_38 < 0)
        VAR_38 = 0;

    /* COMMENT_18 */
    if (VAR_15.xy == 0 && VAR_15.yx == 0)
        VAR_39 = 1;
    else if (VAR_15.xx == 0 && VAR_15.yy == 0)
        VAR_39 = 2;
    else
        VAR_39 = 0;

    /* COMMENT_19 */
                                                                    
                                                                        
                          
       
    VAR_37 = VAR_38 && VAR_39;

    if (VAR_1 != NULL && VAR_1->show_gstate != NULL) {
        /* COMMENT_24 */
                                                            
    } else if (!VAR_37 &&
               (!VAR_7->masked || VAR_7->image_parent_type != 0)) {
        /* COMMENT_26 */
                                                                    
    } else if (VAR_37 && (VAR_7->masked && VAR_7->image_parent_type == 0)) {
        /* COMMENT_28 */
    } else if (VAR_1 != NULL && VAR_1->fill_adjust.x == 0 && VAR_1->fill_adjust.y == 0) {
        /* COMMENT_29 */
    } else if (VAR_39 == 1) {
        if (VAR_10 == 1 || VAR_37) {
            if (VAR_15.xx > 0) {
                fixed VAR_43 = int2fixed(fixed2int(float2fixed(VAR_15.tx)));
                double VAR_44 = VAR_15.tx + VAR_15.xx * VAR_10;
                fixed VAR_45 = int2fixed(fixed2int_ceiling(float2fixed(VAR_44)));
                VAR_15.tx = (double)fixed2float(VAR_43);
                VAR_15.xx = (double)(fixed2float(VAR_45 - VAR_43)/VAR_10);
            } else if (VAR_15.xx < 0) {
                fixed VAR_43 = int2fixed(fixed2int_ceiling(float2fixed(VAR_15.tx)));
                double VAR_44 = VAR_15.tx + VAR_15.xx * VAR_10;
                fixed VAR_45 = int2fixed(fixed2int(float2fixed(VAR_44)));
                VAR_15.tx = (double)fixed2float(VAR_43);
                VAR_15.xx = (double)(fixed2float(VAR_45 - VAR_43)/VAR_10);
            }
        }
        if (VAR_11 == 1 || VAR_37) {
            if (VAR_15.yy > 0) {
                fixed VAR_46 = int2fixed(fixed2int(float2fixed(VAR_15.ty)));
                double VAR_47 = VAR_15.ty + VAR_15.yy * VAR_11;
                fixed VAR_48 = int2fixed(fixed2int_ceiling(float2fixed(VAR_47)));
                VAR_15.ty = (double)fixed2float(VAR_46);
                VAR_15.yy = (double)(fixed2float(VAR_48 - VAR_46)/VAR_11);
            } else if (VAR_15.yy < 0) {
                fixed VAR_46 = int2fixed(fixed2int_ceiling(float2fixed(VAR_15.ty)));
                double VAR_47 = VAR_15.ty + VAR_15.yy * VAR_11;
                fixed VAR_48 = int2fixed(fixed2int(float2fixed(VAR_47)));
                VAR_15.ty = (double)fixed2float(VAR_46);
                VAR_15.yy = ((double)fixed2float(VAR_48 - VAR_46)/VAR_11);
            }
        }
    } else if (VAR_39 == 2) {
        if (VAR_11 == 1 || VAR_37) {
            if (VAR_15.yx > 0) {
                fixed VAR_43 = int2fixed(fixed2int(float2fixed(VAR_15.tx)));
                double VAR_44 = VAR_15.tx + VAR_15.yx * VAR_11;
                fixed VAR_45 = int2fixed(fixed2int_ceiling(float2fixed(VAR_44)));
                VAR_15.tx = (double)fixed2float(VAR_43);
                VAR_15.yx = (double)(fixed2float(VAR_45 - VAR_43)/VAR_11);
            } else if (VAR_15.yx < 0) {
                fixed VAR_43 = int2fixed(fixed2int_ceiling(float2fixed(VAR_15.tx)));
                double VAR_44 = VAR_15.tx + VAR_15.yx * VAR_11;
                fixed VAR_45 = int2fixed(fixed2int(float2fixed(VAR_44)));
                VAR_15.tx = (double)fixed2float(VAR_43);
                VAR_15.yx = (double)(fixed2float(VAR_45 - VAR_43)/VAR_11);
            }
        }
        if (VAR_10 == 1 || VAR_37) {
            if (VAR_15.xy > 0) {
                fixed VAR_46 = int2fixed(fixed2int(float2fixed(VAR_15.ty)));
                double VAR_47 = VAR_15.ty + VAR_15.xy * VAR_10;
                fixed VAR_48 = int2fixed(fixed2int_ceiling(float2fixed(VAR_47)));
                VAR_15.ty = (double)fixed2float(VAR_46);
                VAR_15.xy = (double)(fixed2float(VAR_48 - VAR_46)/VAR_10);
            } else if (VAR_15.xy < 0) {
                fixed VAR_46 = int2fixed(fixed2int_ceiling(float2fixed(VAR_15.ty)));
                double VAR_47 = VAR_15.ty + VAR_15.xy * VAR_10;
                fixed VAR_48 = int2fixed(fixed2int(float2fixed(VAR_47)));
                VAR_15.ty = (double)fixed2float(VAR_46);
                VAR_15.xy = ((double)fixed2float(VAR_48 - VAR_46)/VAR_10);
            }
        }
    }

    /* COMMENT_30 */
                                                                 
                           
    if (VAR_38) {
        double VAR_49 = ((double)(VAR_50 - VAR_51)) / (double)VAR_50; /* COMMENT_33 */

        if (VAR_39 == 1) {
            if ((VAR_15.xx > -VAR_49 && VAR_15.xx < VAR_49) || (VAR_15.yy > -VAR_49 && VAR_15.yy < VAR_49)) {
                VAR_40 = true;
            }
        } else if (VAR_39 == 2) {
            if ((VAR_15.xy > -VAR_49 && VAR_15.xy < VAR_49) || (VAR_15.yx > -VAR_49 && VAR_15.yx < VAR_49)) {
                VAR_40 = true;
            }
        }
    }

    /* COMMENT_34 */
    while (VAR_5) /* COMMENT_35 */
    {
        gs_rect VAR_52, VAR_53;
        gs_matrix VAR_54;
        gs_fixed_rect VAR_35;
        gs_int_rect VAR_55;
        if ((VAR_20 = gs_matrix_invert(&ctm_only(VAR_1), &VAR_54)) < 0 ||
            (VAR_20 = gs_matrix_multiply(&VAR_54, &VAR_3->ImageMatrix, &VAR_54)) < 0) {
            /* COMMENT_36 */
            break;
        }
        gx_cpath_outer_box(VAR_5, &VAR_35);
        VAR_52.p.x = fixed2float(VAR_35.p.x);
        VAR_52.p.y = fixed2float(VAR_35.p.y);
        VAR_52.q.x = fixed2float(VAR_35.q.x);
        VAR_52.q.y = fixed2float(VAR_35.q.y);
        VAR_20 = gs_bbox_transform(&VAR_52, &VAR_54, &VAR_53);
        if (VAR_20 < 0) {
            /* COMMENT_36 */
            break;
        }
        VAR_55.p.x = (int)(VAR_53.p.x-1.0);
        VAR_55.p.y = (int)(VAR_53.p.y-1.0);
        VAR_55.q.x = (int)(VAR_53.q.x+1.0);
        VAR_55.q.y = (int)(VAR_53.q.y+1.0);
        /* COMMENT_37 */
                                                                            
                       
        /* COMMENT_40 */
                                                                                  
                       
        /* COMMENT_43 */
                                                                            
                                          
        {
            float VAR_56 = any_abs(VAR_54.xx);
            int VAR_57;
            if (any_abs(VAR_54.yy) > VAR_56)
                VAR_56 = any_abs(VAR_54.yy);
            if (any_abs(VAR_54.xy) > VAR_56)
                VAR_56 = any_abs(VAR_54.xy);
            if (any_abs(VAR_54.yx) > VAR_56)
                VAR_56 = any_abs(VAR_54.yx);
            VAR_57 = (int)(VAR_58 * (VAR_56+1)) + 1;
            VAR_55.p.x -= VAR_57;
            VAR_55.p.y -= VAR_57;
            VAR_55.q.x += VAR_57;
            VAR_55.q.y += VAR_57;
        }
        if (VAR_7->rrect.x < VAR_55.p.x) {
            VAR_7->rrect.w -= VAR_55.p.x - VAR_7->rrect.x;
            if (VAR_7->rrect.w < 0)
               VAR_7->rrect.w = 0;
            VAR_7->rrect.x = VAR_55.p.x;
        }
        if (VAR_7->rrect.x + VAR_7->rrect.w > VAR_55.q.x) {
            VAR_7->rrect.w = VAR_55.q.x - VAR_7->rrect.x;
            if (VAR_7->rrect.w < 0)
                VAR_7->rrect.w = 0;
        }
        if (VAR_7->rrect.y < VAR_55.p.y) {
            VAR_7->rrect.h -= VAR_55.p.y - VAR_7->rrect.y;
            if (VAR_7->rrect.h < 0)
                VAR_7->rrect.h = 0;
            VAR_7->rrect.y = VAR_55.p.y;
        }
        if (VAR_7->rrect.y + VAR_7->rrect.h > VAR_55.q.y) {
            VAR_7->rrect.h = VAR_55.q.y - VAR_7->rrect.y;
            if (VAR_7->rrect.h < 0)
                VAR_7->rrect.h = 0;
        }
        break; /* COMMENT_46 */
    }
    /* COMMENT_47 */
    if (VAR_7->rrect.x + VAR_7->rrect.w <= VAR_7->rect.x  ||
        VAR_7->rect.x  + VAR_7->rect.w  <= VAR_7->rrect.x ||
        VAR_7->rrect.y + VAR_7->rrect.h <= VAR_7->rect.y  ||
        VAR_7->rect.y  + VAR_7->rect.h  <= VAR_7->rrect.y)
    {
          /* COMMENT_48 */
                                                 
        VAR_7->rrect.x = VAR_7->rect.x;
        VAR_7->rrect.y = VAR_7->rect.y;
        VAR_7->rrect.w = 0;
        VAR_7->rrect.h = 0;
    }

    /* COMMENT_50 */
    VAR_7->matrix.xx = VAR_15.xx;
    VAR_7->matrix.xy = VAR_15.xy;
    VAR_7->matrix.yx = VAR_15.yx;
    VAR_7->matrix.yy = VAR_15.yy;
    VAR_7->matrix.tx = VAR_15.tx;
    VAR_7->matrix.ty = VAR_15.ty;
    if_debug6m('b', VAR_6, "" [%g %g %g %g %g %g]\n"",
              VAR_15.xx, VAR_15.xy, VAR_15.yx, VAR_15.yy, VAR_15.tx, VAR_15.ty);
    /* COMMENT_51 */
    VAR_16 = (VAR_12 < 8 ? VAR_12 >> 1 : (VAR_12 >> 2) + 1);
    /* COMMENT_52 */
                                                    
       
    if (VAR_15.tx > 0)
        VAR_28 = float2fixed(VAR_15.tx);
    else { /* COMMENT_55 */
        int VAR_59 = (int)-VAR_15.tx + 1;

        VAR_28 = float2fixed(VAR_15.tx + VAR_59) - int2fixed(VAR_59);
    }
    if (VAR_15.ty > 0)
        VAR_29 = float2fixed(VAR_15.ty);
    else {  /* COMMENT_55 */
        int VAR_59 = (int)-VAR_15.ty + 1;

        VAR_29 = float2fixed(VAR_15.ty + VAR_59) - int2fixed(VAR_59);
    }

    VAR_30.x = float2fixed_rounded_boxed(VAR_10 * VAR_15.xx);
    VAR_30.y =
        (is_fzero(VAR_15.xy) ? VAR_60 :
         float2fixed_rounded_boxed(VAR_10 * VAR_15.xy));
    VAR_31.x =
        (is_fzero(VAR_15.yx) ? VAR_60 :
         float2fixed_rounded_boxed(VAR_11 * VAR_15.yx));
    VAR_31.y = float2fixed_rounded_boxed(VAR_11 * VAR_15.yy);
    gx_image_enum_common_init((gx_image_enum_common_t *)VAR_7,
                              (const gs_data_image_t *)VAR_8,
                              &VAR_61, VAR_0,
                              (VAR_13 ? 1 : (VAR_7->alpha ? cs_num_components(VAR_17)+1 : cs_num_components(VAR_17))),
                              VAR_9);
    if (VAR_7->rect.w == VAR_10 && VAR_7->rect.h == VAR_11) {
        VAR_32 = VAR_30;
        VAR_33 = VAR_31;
    } else {
        int VAR_62 = VAR_7->rect.w, VAR_63 = VAR_7->rect.h;

        VAR_32.x = float2fixed_rounded_boxed(VAR_62 * VAR_15.xx);
        VAR_32.y =
            (is_fzero(VAR_15.xy) ? VAR_60 :
             float2fixed_rounded_boxed(VAR_62 * VAR_15.xy));
        VAR_33.x =
            (is_fzero(VAR_15.yx) ? VAR_60 :
             float2fixed_rounded_boxed(VAR_63 * VAR_15.yx));
        VAR_33.y = float2fixed_rounded_boxed(VAR_63 * VAR_15.yy);
    }
    /* COMMENT_56 */
                                                                  
                                                              
    if (VAR_13 || cs_num_components(VAR_17) == 1) {
        /* COMMENT_59 */
                                                                     
                                                                    
        VAR_7->clues = (gx_image_clue*) gs_alloc_bytes(VAR_6, sizeof(gx_image_clue)*256,
                             ""gx_image_enum_begin"");
        if (VAR_7->clues == NULL)
            return_error(VAR_64);
        VAR_7->icolor0 = &(VAR_7->clues[0].dev_color);
        VAR_7->icolor1 = &(VAR_7->clues[255].dev_color);
    } else {
        VAR_7->icolor0 = &(VAR_7->icolor0_val);
        VAR_7->icolor1 = &(VAR_7->icolor1_val);
    }
    if (VAR_13) {       /* COMMENT_62 */
        if (VAR_12 != 1 || VAR_17 != NULL || VAR_7->alpha || VAR_14[0] == VAR_14[1]) {
            return_error(VAR_65);
        }
        /* COMMENT_63 */
        set_nonclient_dev_color(VAR_7->icolor0, VAR_66);
        set_nonclient_dev_color(VAR_7->icolor1, VAR_66);
        *(VAR_7->icolor1) = *VAR_4;
        memcpy(&VAR_7->map[0].table.lookup4x1to32[0],
               (VAR_14[0] < VAR_14[1] ? VAR_67 :
                VAR_68),
               16 * 4);
        VAR_7->map[0].decoding = VAR_69;
        VAR_23 = 1;
        VAR_18 = rop3_know_S_0(VAR_18);
    } else {                    /* COMMENT_64 */
        const gs_color_space_type *VAR_70 = VAR_17->type;
        int VAR_71;

        VAR_23 = cs_num_components(VAR_17);
        if (VAR_23 < 0) {          /* COMMENT_65 */
            return_error(VAR_65);
        }
        if (VAR_7->alpha)
            ++VAR_23;
        /* COMMENT_66 */
        switch (VAR_9) {
        case VAR_72:
            if (VAR_12 > 1)
                break;
            VAR_9 = VAR_73;
        case VAR_73:
            if (VAR_23 == 1)
                VAR_9 = VAR_74;
        default:                /* COMMENT_67 */
            break;
        }

        if (VAR_17->cmm_icc_profile_data != NULL) {
            VAR_34 = false;
        } else {
            VAR_34 = (*VAR_70->concrete_space) (VAR_17, VAR_1) == VAR_17;
        }

        VAR_20 = image_init_colors(VAR_7, VAR_12, VAR_23, VAR_9, VAR_14, VAR_1, VAR_0,
                          VAR_17, &VAR_34);
        if (VAR_20 < 0) 
            return gs_throw(VAR_20, ""Image colors initialization failed"");
        /* COMMENT_68 */
                                                                        
                                                                              
        if (gs_color_space_is_PSCIE(VAR_17) && VAR_17->icc_equivalent == NULL) {
            gs_colorspace_set_icc_equivalent((gs_color_space *)VAR_17, &(VAR_7->icc_setup.is_lab),
                                                VAR_1->memory);
            if (VAR_7->icc_setup.is_lab) {
                /* COMMENT_71 */
                                    
                gs_color_space *VAR_75 = (gs_color_space *)VAR_17;
                rc_decrement(VAR_75->icc_equivalent,""gx_image_enum_begin"");
                rc_decrement(VAR_75->cmm_icc_profile_data,""gx_image_enum_begin"");
                VAR_75->cmm_icc_profile_data = VAR_1->icc_manager->lab_profile;
                rc_increment(VAR_75->cmm_icc_profile_data);
            }
        }
        /* COMMENT_73 */
        /* COMMENT_74 */
        if (!VAR_8->CombineWithColor)
            VAR_18 = rop3_know_T_0(VAR_18) & ~VAR_76;
        else if ((rop3_uses_T(VAR_18) && color_draws_b_w(VAR_0, VAR_4) == 0))
            VAR_18 = rop3_know_T_0(VAR_18);

        if (VAR_18 != VAR_77 &&    /* COMMENT_75 */
            !rop3_uses_T(VAR_18) && VAR_12 == 1 && VAR_23 == 1 &&
            (VAR_71 =
             color_draws_b_w(VAR_0, VAR_7->icolor0)) >= 0 &&
            color_draws_b_w(VAR_0, VAR_7->icolor1) == (VAR_71 ^ 1)
            ) {
            if (VAR_71) {    /* COMMENT_76 */
                gx_device_color VAR_78;

                VAR_78 = *(VAR_7->icolor0);
                *(VAR_7->icolor0) = *(VAR_7->icolor1);
                *(VAR_7->icolor1) = VAR_78;
                VAR_18 = rop3_invert_S(VAR_18);
            }
            /* COMMENT_77 */
                                                            
                                                                    
                                                           
               
            switch (VAR_18) {
                case VAR_79 & VAR_77:
                    /* COMMENT_82 */
                    *(VAR_7->icolor1) = *(VAR_7->icolor0);
                    /* COMMENT_83 */
                case VAR_79 | rop3_not(VAR_77):
                    /* COMMENT_84 */
                    memcpy(&VAR_7->map[0].table.lookup4x1to32[0],
                           VAR_67, 16 * 4);
                  rmask:        /* COMMENT_85 */
                    VAR_7->masked = VAR_13 = true;
                    set_nonclient_dev_color(VAR_7->icolor0, VAR_66);
                    VAR_7->map[0].decoding = VAR_69;
                    VAR_18 = VAR_80;
                    break;
                case VAR_79 & rop3_not(VAR_77):
                    /* COMMENT_86 */
                    *(VAR_7->icolor1) = *(VAR_7->icolor0);
                    /* COMMENT_83 */
                case VAR_79 | VAR_77:
                    /* COMMENT_87 */
                    memcpy(&VAR_7->map[0].table.lookup4x1to32[0],
                           VAR_68, 16 * 4);
                    goto rmask;
                default:
                    ;
            }
        }
    }
    VAR_7->device_color = VAR_34;
    /* COMMENT_88 */
                                                                 
                                                                
                                                   
       
    VAR_26 = ((VAR_12 > 8 ? VAR_10 * 2 : VAR_10) + 15) * VAR_23;
    VAR_27 = gs_alloc_bytes(VAR_6, VAR_26, ""image buffer"");
    if (VAR_27 == 0) {
        return_error(VAR_64);
    }
    VAR_7->bps = VAR_12;
    VAR_7->unpack_bps = VAR_12;
    VAR_7->log2_xbytes = VAR_21;
    VAR_7->spp = VAR_23;
    switch (VAR_9) {
    case VAR_74:
        VAR_24 = 1;
        VAR_25 = 1 << VAR_21;
        break;
    case VAR_73:
        VAR_24 = VAR_23;
        VAR_25 = VAR_23 << VAR_21;
        break;
    case VAR_72:
        VAR_24 = VAR_23 * VAR_12;
        VAR_25 = VAR_23 << VAR_21;
        break;
    default:
        /* COMMENT_93 */
        return_error(VAR_81);
    }
    VAR_7->num_planes = VAR_24;
    VAR_7->spread = VAR_25;
    /* COMMENT_94 */
                                                                   
                                                                 
                                                                 
                          
       
    VAR_7->interpolate = VAR_40 ? VAR_82 : VAR_8->Interpolate ? VAR_83 : VAR_84;
    VAR_7->x_extent = VAR_32;
    VAR_7->y_extent = VAR_33;
    VAR_7->posture =
        ((VAR_32.y | VAR_33.x) == 0 ? VAR_85 :
         (VAR_32.x | VAR_33.y) == 0 ? VAR_86 :
         VAR_87);
    VAR_7->pgs = VAR_1;
    VAR_7->pcs = VAR_17;
    VAR_7->memory = VAR_6;
    VAR_7->buffer = VAR_27;
    VAR_7->buffer_size = VAR_26;
    VAR_7->line = 0;
    VAR_7->icc_link = NULL;
    VAR_7->color_cache = NULL;
    VAR_7->ht_buffer = NULL;
    VAR_7->thresh_buffer = NULL;
    VAR_7->use_cie_range = false;
    VAR_7->line_size = 0;
    VAR_7->use_rop = VAR_18 != (VAR_13 ? VAR_80 : VAR_77);
#ifdef VAR_88
    if (gs_debug_c('*')) {
        if (VAR_7->use_rop)
            dmprintf1(VAR_6, ""[%03x]"", VAR_18);
        dmprintf5(VAR_6, ""%c%d%c%dx%d "",
                 (VAR_13 ? (color_is_pure(VAR_4) ? 'm' : 'h') : 'i'),
                 VAR_12,
                 (VAR_7->posture == VAR_85 ? ' ' :
                  VAR_7->posture == VAR_86 ? 'L' : 'T'),
                 VAR_10, VAR_11);
    }
#endif
    VAR_7->slow_loop = 0;
    if (VAR_5 == 0) {
        (*dev_proc(VAR_0, VAR_89)) (VAR_0, &VAR_35);
        VAR_36 = VAR_35;
        VAR_7->clip_image = 0;
    } else
        VAR_7->clip_image =
            (gx_cpath_outer_box(VAR_5, &VAR_35) |        /* COMMENT_100 */
             gx_cpath_inner_box(VAR_5, &VAR_36) ?
             0 : VAR_90);
    VAR_7->clip_outer = VAR_35;
    VAR_7->clip_inner = VAR_36;
    VAR_7->log_op = VAR_80;     /* COMMENT_101 */
    VAR_7->clip_dev = 0;        /* COMMENT_102 */
    VAR_7->rop_dev = 0;         /* COMMENT_103 */
    VAR_7->scaler = 0;          /* COMMENT_103 */
    /* COMMENT_104 */
                                                                
                                                                      
                                                                     
                           
       
    {
        fixed
            VAR_91 = min(VAR_30.x, 0) + min(VAR_31.x, 0),
            VAR_92 = max(VAR_30.x, 0) + max(VAR_31.x, 0),
            VAR_93 = min(VAR_30.y, 0) + min(VAR_31.y, 0),
            VAR_94 = max(VAR_30.y, 0) + max(VAR_31.y, 0);

        {
            int VAR_95, VAR_96;

            switch (VAR_7->posture) {
                case VAR_85:
                    VAR_95 = VAR_10, VAR_96 = VAR_11;
                    break;
                case VAR_86:
                    VAR_95 = VAR_11, VAR_96 = VAR_10;
                    break;
                default:
                    VAR_95 = VAR_96 = 0;
            }
            /* COMMENT_110 */
                                                          
                                                            
                                                                
                                                              
                                                                 
                                                            
                                         
               
            if (VAR_95 == 1 && VAR_92 - VAR_91 < VAR_50) {
                fixed VAR_97 =
                arith_rshift_1(VAR_30.x + VAR_31.x);

                VAR_28 = (((VAR_28 + VAR_97) | VAR_98) & -VAR_98) - VAR_97;
            }
            if (VAR_96 == 1 && VAR_94 - VAR_93 < VAR_50) {
                fixed VAR_97 =
                arith_rshift_1(VAR_30.y + VAR_31.y);

                VAR_29 = (((VAR_29 + VAR_97) | VAR_98) & -VAR_98) - VAR_97;
            }
        }
        if_debug5m('b', VAR_6, ""[b]Image: %sspp=%d, bps=%d, mt=(%g,%g)\n"",
                   (VAR_13? ""masked, "" : """"), VAR_23, VAR_12,
                   fixed2float(VAR_28), fixed2float(VAR_29));
        if_debug9m('b', VAR_6,
                   ""[b]   cbox=(%g,%g),(%g,%g), obox=(%g,%g),(%g,%g), clip_image=0x%x\n"",
                   fixed2float(VAR_36.p.x), fixed2float(VAR_36.p.y),
                   fixed2float(VAR_36.q.x), fixed2float(VAR_36.q.y),
                   fixed2float(VAR_35.p.x), fixed2float(VAR_35.p.y),
                   fixed2float(VAR_35.q.x), fixed2float(VAR_35.q.y),
                   VAR_7->clip_image);
        /* COMMENT_119 */
                                  
        dda_init(VAR_7->dda.row.x, VAR_28, VAR_31.x, VAR_11);
        dda_init(VAR_7->dda.row.y, VAR_29, VAR_31.y, VAR_11);
        if (VAR_7->posture == VAR_85) {
            VAR_7->dst_width = VAR_30.x;
            VAR_7->dst_height = VAR_31.y;
        } else {
            VAR_7->dst_width = VAR_31.x;
            VAR_7->dst_height = VAR_30.y;
        }
        /* COMMENT_121 */
        VAR_7->yi0 = fixed2int_pixround_perfect(dda_current(VAR_7->dda.row.y)); /* COMMENT_121 */
        if (VAR_7->rect.y) {
            int VAR_99 = VAR_7->rect.y;

            while (VAR_99--) {
                dda_next(VAR_7->dda.row.x);
                dda_next(VAR_7->dda.row.y);
            }
        }
        VAR_7->cur.x = VAR_7->prev.x = dda_current(VAR_7->dda.row.x);
        VAR_7->cur.y = VAR_7->prev.y = dda_current(VAR_7->dda.row.y);
        /* COMMENT_122 */
                                                                       
                                 
        dda_init(VAR_7->dda.strip.x, VAR_7->cur.x, VAR_30.x, VAR_10);
        dda_init(VAR_7->dda.strip.y, VAR_7->cur.y, VAR_30.y, VAR_10);
        if (VAR_7->rect.x) {
            dda_advance(VAR_7->dda.strip.x, VAR_7->rect.x);
            dda_advance(VAR_7->dda.strip.y, VAR_7->rect.x);
        }
        {
            fixed VAR_100 = dda_current(VAR_7->dda.strip.x);
            fixed VAR_101 = dda_current(VAR_7->dda.strip.y);

            if (!VAR_7->clip_image)     /* COMMENT_125 */
                VAR_7->clip_image =
                    (fixed_pixround(VAR_100 + VAR_91) < fixed_pixround(VAR_36.p.x) ?
                     VAR_102 : 0) +
                    (fixed_pixround(VAR_100 + VAR_92) >= fixed_pixround(VAR_36.q.x) ?
                     VAR_103 : 0) +
                    (fixed_pixround(VAR_101 + VAR_93) < fixed_pixround(VAR_36.p.y) ?
                     VAR_104 : 0) +
                    (fixed_pixround(VAR_101 + VAR_94) >= fixed_pixround(VAR_36.q.y) ?
                     VAR_105 : 0);
        }
    }
    VAR_7->y = 0;
    VAR_7->used.x = 0;
    VAR_7->used.y = 0;
    {
        static sample_unpack_proc_t VAR_106[2][6] = {
        {   VAR_107, VAR_108,
            VAR_109, VAR_110,
            VAR_111, VAR_112
        },
        {   VAR_113, VAR_114,
            VAR_115, VAR_116,
            VAR_111, VAR_112
        }};
        int VAR_117 = VAR_7->num_planes;
        bool VAR_118 = (VAR_117 == 1 && VAR_7->plane_depths[0] != VAR_7->bps);
        int VAR_119;

        if (VAR_118) {
            int VAR_120 = VAR_7->plane_depths[0] / VAR_7->bps;

            for (VAR_119 = 1; VAR_119 < VAR_120; VAR_119++) {
                if (VAR_14[0] != VAR_14[VAR_119 * 2 + 0] ||
                    VAR_14[1] != VAR_14[VAR_119 * 2 + 1])
                    break;
            }
            if (VAR_119 == VAR_120)
                VAR_118 = false; /* COMMENT_126 */
        }
        VAR_7->unpack = VAR_106[VAR_118][VAR_16];

        if_debug1m('b', VAR_6, ""[b]unpack=%d\n"", VAR_12);
        /* COMMENT_127 */
        VAR_7->dda.pixel0 = VAR_7->dda.strip;
        for (VAR_119 = 0; VAR_119 < VAR_121; ++VAR_119)
            if ((VAR_7->render = VAR_122[VAR_119](VAR_7)) != 0)
                break;
        if (VAR_119 == VAR_121) {
            /* COMMENT_128 */
            gx_default_end_image(VAR_0, (gx_image_enum_common_t *) VAR_7,
                                 false);
            return_error(VAR_65);
        }
    }
    if (VAR_7->clip_image && VAR_5) {  /* COMMENT_129 */
        gx_device_clip *VAR_123 =
            gs_alloc_struct(VAR_6, gx_device_clip,
                            &VAR_124, ""image clipper"");

        if (VAR_123 == 0) {
            gx_default_end_image(VAR_0,
                                 (gx_image_enum_common_t *) VAR_7,
                                 false);
            return_error(VAR_64);
        }
        gx_make_clip_device_in_heap(VAR_123, VAR_5, VAR_0, VAR_6);
        VAR_7->clip_dev = VAR_123;
    }
    if (VAR_7->use_rop) {       /* COMMENT_130 */
        gx_device_rop_texture *VAR_125;

        VAR_20 = gx_alloc_rop_texture_device(&VAR_125, VAR_6,
                                           ""image RasterOp"");
        if (VAR_20 < 0) {
            gx_default_end_image(VAR_0, (gx_image_enum_common_t *) VAR_7,
                                 false);
            return VAR_20;
        }
        /* COMMENT_131 */
        if (!VAR_7->clip_dev && !VAR_0)
            return_error(VAR_126);

        gx_make_rop_texture_device(VAR_125,
                                   (VAR_7->clip_dev != 0 ?
                                    (gx_device *) VAR_7->clip_dev :
                                    VAR_0), VAR_18, VAR_4);
        gx_device_retain((gx_device *)VAR_125, true);
        VAR_7->rop_dev = VAR_125;
    }
    return 0;
}",ArtifexSoftware/ghostpdl/ecceafe3abba2714ef9b432035fe0739d9b1a283/gxipixel.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -38,7 +38,6 @@
     penum->Height = height;
 
     if ((code = gx_image_compute_mat(pgs, pmat, &(pim->ImageMatrix), &mat)) < 0) {
-        gs_free_object(mem, penum, ""gx_default_begin_image"");
         return code;
     }
     /* Grid fit: A common construction in postscript/PDF files is for images
@@ -335,7 +334,6 @@
     }
     if (masked) {       /* This is imagemask. */
         if (bps != 1 || pcs != NULL || penum->alpha || decode[0] == decode[1]) {
-            gs_free_object(mem, penum, ""gx_default_begin_image"");
             return_error(gs_error_rangecheck);
         }
         /* Initialize color entries 0 and 255. */
@@ -355,7 +353,6 @@
 
         spp = cs_num_components(pcs);
         if (spp < 0) {          /* Pattern not allowed */
-            gs_free_object(mem, penum, ""gx_default_begin_image"");
             return_error(gs_error_rangecheck);
         }
         if (penum->alpha)
@@ -463,7 +460,6 @@
     bsize = ((bps > 8 ? width * 2 : width) + 15) * spp;
     buffer = gs_alloc_bytes(mem, bsize, ""image buffer"");
     if (buffer == 0) {
-        gs_free_object(mem, penum, ""gx_default_begin_image"");
         return_error(gs_error_VMerror);
     }
     penum->bps = bps;","{'deleted_lines': ['        gs_free_object(mem, penum, ""gx_default_begin_image"");', '            gs_free_object(mem, penum, ""gx_default_begin_image"");', '            gs_free_object(mem, penum, ""gx_default_begin_image"");', '        gs_free_object(mem, penum, ""gx_default_begin_image"");'], 'added_lines': []}",True,Multiple use-after-free vulnerabilities in the gx_image_enum_begin function in base/gxipixel.c in Ghostscript before ecceafe3abba2714ef9b432035fe0739d9b1a283 allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted PostScript document.,7.8,HIGH,2,test,2017-02-20T09:45:18Z,1
CVE-2017-6429,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,appneta/tcpreplay,"#278 fail if capture has a packet that is too large (#286)

* #278 fail if capture has a packet that is too large

* Update CHANGELOG",d689d14dbcd768c028eab2fb378d849e543dcfe9,https://github.com/appneta/tcpreplay/commit/d689d14dbcd768c028eab2fb378d849e543dcfe9,src/tcpcapinfo.c,main,"int
main(int argc, char *argv[])
{
int i, fd, swapped, pkthdrlen, ret, optct, backwards, caplentoobig;
struct pcap_file_header pcap_fh;
struct pcap_pkthdr pcap_ph;
struct pcap_sf_patched_pkthdr pcap_patched_ph; 
char buf[10000];
struct stat statinfo;
uint64_t pktcnt;
uint32_t readword;
int32_t last_sec, last_usec, caplen;
optct = optionProcess(&tcpcapinfoOptions, argc, argv);
argc -= optct;
argv += optct;
#ifdef DEBUG
if (HAVE_OPT(DBUG))
debug = OPT_VALUE_DBUG;
#endif
for (i = 0; i < argc; i++) {
dbgx(1, ""processing:  %s\n"", argv[i]);
if ((fd = open(argv[i], O_RDONLY)) < 0)
errx(-1, ""Error opening file %s: %s"", argv[i], strerror(errno));
if (fstat(fd, &statinfo) < 0)
errx(-1, ""Error getting file stat info %s: %s"", argv[i], strerror(errno));
printf(""file size   = %""PRIu64"" bytes\n"", (uint64_t)statinfo.st_size);
if ((ret = read(fd, &buf, sizeof(pcap_fh))) != sizeof(pcap_fh))
errx(-1, ""File too small.  Unable to read pcap_file_header from %s"", argv[i]);
dbgx(3, ""Read %d bytes for file header"", ret);
swapped = 0;
memcpy(&pcap_fh, &buf, sizeof(pcap_fh));
pkthdrlen = 16; 
switch (pcap_fh.magic) {
case TCPDUMP_MAGIC:
printf(""magic       = 0x%08""PRIx32"" (tcpdump) (%s)\n"", pcap_fh.magic, is_not_swapped);
break;
case SWAPLONG(TCPDUMP_MAGIC):
printf(""magic       = 0x%08""PRIx32"" (tcpdump/swapped) (%s)\n"", pcap_fh.magic, is_swapped);
swapped = 1;
break;
case KUZNETZOV_TCPDUMP_MAGIC:
pkthdrlen = sizeof(pcap_patched_ph);
printf(""magic       = 0x%08""PRIx32"" (Kuznetzov) (%s)\n"", pcap_fh.magic, is_not_swapped);
break;
case SWAPLONG(KUZNETZOV_TCPDUMP_MAGIC):
pkthdrlen = sizeof(pcap_patched_ph);
printf(""magic       = 0x%08""PRIx32"" (Kuznetzov/swapped) (%s)\n"", pcap_fh.magic, is_swapped);
swapped = 1;
break;
case FMESQUITA_TCPDUMP_MAGIC:
printf(""magic       = 0x%08""PRIx32"" (Fmesquita) (%s)\n"", pcap_fh.magic, is_not_swapped);
break;
case SWAPLONG(FMESQUITA_TCPDUMP_MAGIC):
printf(""magic       = 0x%08""PRIx32"" (Fmesquita) (%s)\n"", pcap_fh.magic, is_swapped);
swapped = 1;
break;
case NAVTEL_TCPDUMP_MAGIC:
printf(""magic       = 0x%08""PRIx32"" (Navtel) (%s)\n"", pcap_fh.magic, is_not_swapped);
break;
case SWAPLONG(NAVTEL_TCPDUMP_MAGIC):
printf(""magic       = 0x%08""PRIx32"" (Navtel/swapped) (%s)\n"", pcap_fh.magic, is_swapped);
swapped = 1;
break;
case NSEC_TCPDUMP_MAGIC:
printf(""magic       = 0x%08""PRIx32"" (Nsec) (%s)\n"", pcap_fh.magic, is_not_swapped);
break;
case SWAPLONG(NSEC_TCPDUMP_MAGIC):
printf(""magic       = 0x%08""PRIx32"" (Nsec/swapped) (%s)\n"", pcap_fh.magic, is_swapped);
swapped = 1;
break;
default:
printf(""magic       = 0x%08""PRIx32"" (unknown)\n"", pcap_fh.magic);
}
if (swapped == 1) {
pcap_fh.version_major = SWAPSHORT(pcap_fh.version_major);
pcap_fh.version_minor = SWAPSHORT(pcap_fh.version_minor);
pcap_fh.thiszone = SWAPLONG(pcap_fh.thiszone);
pcap_fh.sigfigs = SWAPLONG(pcap_fh.sigfigs);
pcap_fh.snaplen = SWAPLONG(pcap_fh.snaplen);
pcap_fh.linktype = SWAPLONG(pcap_fh.linktype);
}
printf(""version     = %hu.%hu\n"", pcap_fh.version_major, pcap_fh.version_minor);
printf(""thiszone    = 0x%08""PRIx32""\n"", pcap_fh.thiszone);
printf(""sigfigs     = 0x%08""PRIx32""\n"", pcap_fh.sigfigs);
printf(""snaplen     = %""PRIu32""\n"", pcap_fh.snaplen);
printf(""linktype    = 0x%08""PRIx32""\n"", pcap_fh.linktype);
if (pcap_fh.version_major != 2 && pcap_fh.version_minor != 4) {
printf(""Sorry, we only support file format version 2.4\n"");
close(fd);
continue;
}
dbgx(5, ""Packet header len: %d"", pkthdrlen);
if (pkthdrlen == 24) {
printf(""Packet\tOrigLen\t\tCaplen\t\tTimestamp\t\tIndex\tProto\tPktType\tPktCsum\tNote\n"");
} else {
printf(""Packet\tOrigLen\t\tCaplen\t\tTimestamp\tCsum\tNote\n"");
}
pktcnt = 0;
last_sec = 0;
last_usec = 0;
while ((ret = read(fd, &buf, pkthdrlen)) == pkthdrlen) {
pktcnt ++;
backwards = 0;
caplentoobig = 0;
dbgx(3, ""Read %d bytes for packet %""PRIu64"" header"", ret, pktcnt);
memset(&pcap_ph, 0, sizeof(pcap_ph));
if (pkthdrlen == sizeof(pcap_patched_ph)) {
memcpy(&pcap_patched_ph, &buf, sizeof(pcap_patched_ph));
if (swapped == 1) {
dbg(3, ""Swapping packet header bytes..."");
pcap_patched_ph.caplen = SWAPLONG(pcap_patched_ph.caplen);
pcap_patched_ph.len = SWAPLONG(pcap_patched_ph.len);
pcap_patched_ph.ts.tv_sec = SWAPLONG(pcap_patched_ph.ts.tv_sec);
pcap_patched_ph.ts.tv_usec = SWAPLONG(pcap_patched_ph.ts.tv_usec);
pcap_patched_ph.index = SWAPLONG(pcap_patched_ph.index);
pcap_patched_ph.protocol = SWAPSHORT(pcap_patched_ph.protocol);
}
printf(""%""PRIu64""\t%4""PRIu32""\t\t%4""PRIu32""\t\t%""
PRIx32"".%""PRIx32""\t\t%4""PRIu32""\t%4hu\t%4hhu"", 
pktcnt, pcap_patched_ph.len, pcap_patched_ph.caplen, 
pcap_patched_ph.ts.tv_sec, pcap_patched_ph.ts.tv_usec,
pcap_patched_ph.index, pcap_patched_ph.protocol, pcap_patched_ph.pkt_type);
if (pcap_fh.snaplen < pcap_patched_ph.caplen) {
caplentoobig = 1;
}
caplen = pcap_patched_ph.caplen;
} else {
memcpy(&readword, buf, 4);
pcap_ph.ts.tv_sec = readword;
memcpy(&readword, &buf[4], 4);
pcap_ph.ts.tv_usec = readword;
memcpy(&pcap_ph.caplen, &buf[8], 4);
memcpy(&pcap_ph.len, &buf[12], 4);
if (swapped == 1) {
dbg(3, ""Swapping packet header bytes..."");
pcap_ph.caplen = SWAPLONG(pcap_ph.caplen);
pcap_ph.len = SWAPLONG(pcap_ph.len);
pcap_ph.ts.tv_sec = SWAPLONG(pcap_ph.ts.tv_sec);
pcap_ph.ts.tv_usec = SWAPLONG(pcap_ph.ts.tv_usec);
}
printf(""%""PRIu64""\t%4""PRIu32""\t\t%4""PRIu32""\t\t%""
PRIx32"".%""PRIx32,
pktcnt, pcap_ph.len, pcap_ph.caplen, 
(unsigned int)pcap_ph.ts.tv_sec, (unsigned int)pcap_ph.ts.tv_usec);
if (pcap_fh.snaplen < pcap_ph.caplen) {
caplentoobig = 1;
}
caplen = pcap_ph.caplen;
}
if (last_sec > 0 && last_usec > 0) {
if ((pcap_ph.ts.tv_sec == last_sec) ? 
(pcap_ph.ts.tv_usec < last_usec) : 
(pcap_ph.ts.tv_sec < last_sec)) {
backwards = 1;
}
}
if (pkthdrlen == sizeof(pcap_patched_ph)) {
last_sec = pcap_patched_ph.ts.tv_sec;
last_usec = pcap_patched_ph.ts.tv_usec;
} else {
last_sec = pcap_ph.ts.tv_sec;
last_usec = pcap_ph.ts.tv_usec;
}
if ((ret = read(fd, &buf, caplen)) != caplen) {
if (ret < 0) {
printf(""Error reading file: %s: %s\n"", argv[i], strerror(errno));
} else {
printf(""File truncated!  Unable to jump to next packet.\n"");
}
close(fd);
continue;
}
printf(""\t%x\t"", do_checksum_math((u_int16_t *)buf, caplen));
if (! backwards && ! caplentoobig) {
printf(""OK\n"");
} else if (backwards && ! caplentoobig) {
printf(""BAD_TS\n"");
} else if (caplentoobig && ! backwards) {
printf(""TOOBIG\n"");
} else if (backwards && caplentoobig) {
printf(""BAD_TS|TOOBIG"");
} 
}
}
exit(0);
}","int
main(int VAR_0, char *VAR_1[])
{
int VAR_2, VAR_3, VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9;
struct pcap_file_header VAR_10;
struct pcap_pkthdr VAR_11;
struct pcap_sf_patched_pkthdr VAR_12; 
char VAR_13[10000];
struct stat VAR_14;
uint64_t VAR_15;
uint32_t VAR_16;
int32_t VAR_17, VAR_18, VAR_19;
VAR_7 = optionProcess(&VAR_20, VAR_0, VAR_1);
VAR_0 -= VAR_7;
VAR_1 += VAR_7;
#ifdef VAR_21
if (HAVE_OPT(VAR_22))
VAR_23 = VAR_24;
#endif
for (VAR_2 = 0; VAR_2 < VAR_0; VAR_2++) {
dbgx(1, ""processing:  %s\n"", VAR_1[VAR_2]);
if ((VAR_3 = open(VAR_1[VAR_2], VAR_25)) < 0)
errx(-1, ""Error opening file %s: %s"", VAR_1[VAR_2], strerror(VAR_26));
if (fstat(VAR_3, &VAR_14) < 0)
errx(-1, ""Error getting file stat info %s: %s"", VAR_1[VAR_2], strerror(VAR_26));
printf(""file size   = %""VAR_27"" bytes\n"", (uint64_t)VAR_14.st_size);
if ((VAR_6 = read(VAR_3, &VAR_13, sizeof(VAR_10))) != sizeof(VAR_10))
errx(-1, ""File too small.  Unable to read pcap_file_header from %s"", VAR_1[VAR_2]);
dbgx(3, ""Read %d bytes for file header"", VAR_6);
VAR_4 = 0;
memcpy(&VAR_10, &VAR_13, sizeof(VAR_10));
VAR_5 = 16; 
switch (VAR_10.magic) {
case VAR_28:
printf(""magic       = 0x%08""VAR_29"" (tcpdump) (%s)\n"", VAR_10.magic, VAR_30);
break;
case SWAPLONG(VAR_28):
printf(""magic       = 0x%08""VAR_29"" (tcpdump/swapped) (%s)\n"", VAR_10.magic, VAR_31);
VAR_4 = 1;
break;
case VAR_32:
VAR_5 = sizeof(VAR_12);
printf(""magic       = 0x%08""VAR_29"" (Kuznetzov) (%s)\n"", VAR_10.magic, VAR_30);
break;
case SWAPLONG(VAR_32):
VAR_5 = sizeof(VAR_12);
printf(""magic       = 0x%08""VAR_29"" (Kuznetzov/swapped) (%s)\n"", VAR_10.magic, VAR_31);
VAR_4 = 1;
break;
case VAR_33:
printf(""magic       = 0x%08""VAR_29"" (Fmesquita) (%s)\n"", VAR_10.magic, VAR_30);
break;
case SWAPLONG(VAR_33):
printf(""magic       = 0x%08""VAR_29"" (Fmesquita) (%s)\n"", VAR_10.magic, VAR_31);
VAR_4 = 1;
break;
case VAR_34:
printf(""magic       = 0x%08""VAR_29"" (Navtel) (%s)\n"", VAR_10.magic, VAR_30);
break;
case SWAPLONG(VAR_34):
printf(""magic       = 0x%08""VAR_29"" (Navtel/swapped) (%s)\n"", VAR_10.magic, VAR_31);
VAR_4 = 1;
break;
case VAR_35:
printf(""magic       = 0x%08""VAR_29"" (Nsec) (%s)\n"", VAR_10.magic, VAR_30);
break;
case SWAPLONG(VAR_35):
printf(""magic       = 0x%08""VAR_29"" (Nsec/swapped) (%s)\n"", VAR_10.magic, VAR_31);
VAR_4 = 1;
break;
default:
printf(""magic       = 0x%08""VAR_29"" (unknown)\n"", VAR_10.magic);
}
if (VAR_4 == 1) {
VAR_10.version_major = SWAPSHORT(VAR_10.version_major);
VAR_10.version_minor = SWAPSHORT(VAR_10.version_minor);
VAR_10.thiszone = SWAPLONG(VAR_10.thiszone);
VAR_10.sigfigs = SWAPLONG(VAR_10.sigfigs);
VAR_10.snaplen = SWAPLONG(VAR_10.snaplen);
VAR_10.linktype = SWAPLONG(VAR_10.linktype);
}
printf(""version     = %hu.%hu\n"", VAR_10.version_major, VAR_10.version_minor);
printf(""thiszone    = 0x%08""VAR_29""\n"", VAR_10.thiszone);
printf(""sigfigs     = 0x%08""VAR_29""\n"", VAR_10.sigfigs);
printf(""snaplen     = %""VAR_36""\n"", VAR_10.snaplen);
printf(""linktype    = 0x%08""VAR_29""\n"", VAR_10.linktype);
if (VAR_10.version_major != 2 && VAR_10.version_minor != 4) {
printf(""Sorry, we only support file format version 2.4\n"");
close(VAR_3);
continue;
}
dbgx(5, ""Packet header len: %d"", VAR_5);
if (VAR_5 == 24) {
printf(""Packet\tOrigLen\t\tCaplen\t\tTimestamp\t\tIndex\tProto\tPktType\tPktCsum\tNote\n"");
} else {
printf(""Packet\tOrigLen\t\tCaplen\t\tTimestamp\tCsum\tNote\n"");
}
VAR_15 = 0;
VAR_17 = 0;
VAR_18 = 0;
while ((VAR_6 = read(VAR_3, &VAR_13, VAR_5)) == VAR_5) {
VAR_15 ++;
VAR_8 = 0;
VAR_9 = 0;
dbgx(3, ""Read %d bytes for packet %""VAR_27"" header"", VAR_6, VAR_15);
memset(&VAR_11, 0, sizeof(VAR_11));
if (VAR_5 == sizeof(VAR_12)) {
memcpy(&VAR_12, &VAR_13, sizeof(VAR_12));
if (VAR_4 == 1) {
dbg(3, ""Swapping packet header bytes..."");
VAR_12.caplen = SWAPLONG(VAR_12.caplen);
VAR_12.len = SWAPLONG(VAR_12.len);
VAR_12.ts.tv_sec = SWAPLONG(VAR_12.ts.tv_sec);
VAR_12.ts.tv_usec = SWAPLONG(VAR_12.ts.tv_usec);
VAR_12.index = SWAPLONG(VAR_12.index);
VAR_12.protocol = SWAPSHORT(VAR_12.protocol);
}
printf(""%""VAR_27""\t%4""VAR_36""\t\t%4""VAR_36""\t\t%""
VAR_29"".%""VAR_29""\t\t%4""VAR_36""\t%4hu\t%4hhu"", 
VAR_15, VAR_12.len, VAR_12.caplen, 
VAR_12.ts.tv_sec, VAR_12.ts.tv_usec,
VAR_12.index, VAR_12.protocol, VAR_12.pkt_type);
if (VAR_10.snaplen < VAR_12.caplen) {
VAR_9 = 1;
}
VAR_19 = VAR_12.caplen;
} else {
memcpy(&VAR_16, VAR_13, 4);
VAR_11.ts.tv_sec = VAR_16;
memcpy(&VAR_16, &VAR_13[4], 4);
VAR_11.ts.tv_usec = VAR_16;
memcpy(&VAR_11.caplen, &VAR_13[8], 4);
memcpy(&VAR_11.len, &VAR_13[12], 4);
if (VAR_4 == 1) {
dbg(3, ""Swapping packet header bytes..."");
VAR_11.caplen = SWAPLONG(VAR_11.caplen);
VAR_11.len = SWAPLONG(VAR_11.len);
VAR_11.ts.tv_sec = SWAPLONG(VAR_11.ts.tv_sec);
VAR_11.ts.tv_usec = SWAPLONG(VAR_11.ts.tv_usec);
}
printf(""%""VAR_27""\t%4""VAR_36""\t\t%4""VAR_36""\t\t%""
VAR_29"".%""VAR_29,
VAR_15, VAR_11.len, VAR_11.caplen, 
(unsigned int)VAR_11.ts.tv_sec, (unsigned int)VAR_11.ts.tv_usec);
if (VAR_10.snaplen < VAR_11.caplen) {
VAR_9 = 1;
}
VAR_19 = VAR_11.caplen;
}
if (VAR_17 > 0 && VAR_18 > 0) {
if ((VAR_11.ts.tv_sec == VAR_17) ? 
(VAR_11.ts.tv_usec < VAR_18) : 
(VAR_11.ts.tv_sec < VAR_17)) {
VAR_8 = 1;
}
}
if (VAR_5 == sizeof(VAR_12)) {
VAR_17 = VAR_12.ts.tv_sec;
VAR_18 = VAR_12.ts.tv_usec;
} else {
VAR_17 = VAR_11.ts.tv_sec;
VAR_18 = VAR_11.ts.tv_usec;
}
if ((VAR_6 = read(VAR_3, &VAR_13, VAR_19)) != VAR_19) {
if (VAR_6 < 0) {
printf(""Error reading file: %s: %s\n"", VAR_1[VAR_2], strerror(VAR_26));
} else {
printf(""File truncated!  Unable to jump to next packet.\n"");
}
close(VAR_3);
continue;
}
printf(""\t%x\t"", do_checksum_math((u_int16_t *)VAR_13, VAR_19));
if (! VAR_8 && ! VAR_9) {
printf(""OK\n"");
} else if (VAR_8 && ! VAR_9) {
printf(""BAD_TS\n"");
} else if (VAR_9 && ! VAR_8) {
printf(""TOOBIG\n"");
} else if (VAR_8 && VAR_9) {
printf(""BAD_TS|TOOBIG"");
} 
}
}
exit(0);
}",appneta/tcpreplay/d689d14dbcd768c028eab2fb378d849e543dcfe9/tcpcapinfo.c/vul/before/0.json,"int
main(int argc, char *argv[])
{
    int i, fd, swapped, pkthdrlen, ret, optct, backwards, caplentoobig;
    struct pcap_file_header pcap_fh;
    struct pcap_pkthdr pcap_ph;
    struct pcap_sf_patched_pkthdr pcap_patched_ph; /* Kuznetzov */
    char buf[10000];
    struct stat statinfo;
    uint64_t pktcnt;
    uint32_t readword;
    int32_t last_sec, last_usec, caplen;

    optct = optionProcess(&tcpcapinfoOptions, argc, argv);
    argc -= optct;
    argv += optct;

#ifdef DEBUG
    if (HAVE_OPT(DBUG))
        debug = OPT_VALUE_DBUG;
#endif

    for (i = 0; i < argc; i++) {
        dbgx(1, ""processing:  %s\n"", argv[i]);
        if ((fd = open(argv[i], O_RDONLY)) < 0)
            errx(-1, ""Error opening file %s: %s"", argv[i], strerror(errno));

        if (fstat(fd, &statinfo) < 0)
            errx(-1, ""Error getting file stat info %s: %s"", argv[i], strerror(errno));

        printf(""file size   = %""PRIu64"" bytes\n"", (uint64_t)statinfo.st_size);

        if ((ret = read(fd, &buf, sizeof(pcap_fh))) != sizeof(pcap_fh))
            errx(-1, ""File too small.  Unable to read pcap_file_header from %s"", argv[i]);

        dbgx(3, ""Read %d bytes for file header"", ret);

        swapped = 0;

        memcpy(&pcap_fh, &buf, sizeof(pcap_fh));

        pkthdrlen = 16; /* pcap_pkthdr isn't the actual on-disk format for 64bit systems! */

        switch (pcap_fh.magic) {
            case TCPDUMP_MAGIC:
            printf(""magic       = 0x%08""PRIx32"" (tcpdump) (%s)\n"", pcap_fh.magic, is_not_swapped);
            break;

            case SWAPLONG(TCPDUMP_MAGIC):
            printf(""magic       = 0x%08""PRIx32"" (tcpdump/swapped) (%s)\n"", pcap_fh.magic, is_swapped);
            swapped = 1;
            break;

            case KUZNETZOV_TCPDUMP_MAGIC:
            pkthdrlen = sizeof(pcap_patched_ph);
            printf(""magic       = 0x%08""PRIx32"" (Kuznetzov) (%s)\n"", pcap_fh.magic, is_not_swapped);
            break;

            case SWAPLONG(KUZNETZOV_TCPDUMP_MAGIC):
            pkthdrlen = sizeof(pcap_patched_ph);
            printf(""magic       = 0x%08""PRIx32"" (Kuznetzov/swapped) (%s)\n"", pcap_fh.magic, is_swapped);
            swapped = 1;
            break;

            case FMESQUITA_TCPDUMP_MAGIC:
            printf(""magic       = 0x%08""PRIx32"" (Fmesquita) (%s)\n"", pcap_fh.magic, is_not_swapped);
            break;

            case SWAPLONG(FMESQUITA_TCPDUMP_MAGIC):
            printf(""magic       = 0x%08""PRIx32"" (Fmesquita) (%s)\n"", pcap_fh.magic, is_swapped);
            swapped = 1;
            break;

            case NAVTEL_TCPDUMP_MAGIC:
            printf(""magic       = 0x%08""PRIx32"" (Navtel) (%s)\n"", pcap_fh.magic, is_not_swapped);
            break;

            case SWAPLONG(NAVTEL_TCPDUMP_MAGIC):
            printf(""magic       = 0x%08""PRIx32"" (Navtel/swapped) (%s)\n"", pcap_fh.magic, is_swapped);
            swapped = 1;
            break;

            case NSEC_TCPDUMP_MAGIC:
            printf(""magic       = 0x%08""PRIx32"" (Nsec) (%s)\n"", pcap_fh.magic, is_not_swapped);
            break;

            case SWAPLONG(NSEC_TCPDUMP_MAGIC):
            printf(""magic       = 0x%08""PRIx32"" (Nsec/swapped) (%s)\n"", pcap_fh.magic, is_swapped);
            swapped = 1;
            break;

            default:
            printf(""magic       = 0x%08""PRIx32"" (unknown)\n"", pcap_fh.magic);
        }

        if (swapped == 1) {
            pcap_fh.version_major = SWAPSHORT(pcap_fh.version_major);
            pcap_fh.version_minor = SWAPSHORT(pcap_fh.version_minor);
            pcap_fh.thiszone = SWAPLONG(pcap_fh.thiszone);
            pcap_fh.sigfigs = SWAPLONG(pcap_fh.sigfigs);
            pcap_fh.snaplen = SWAPLONG(pcap_fh.snaplen);
            pcap_fh.linktype = SWAPLONG(pcap_fh.linktype);
        }

        printf(""version     = %hu.%hu\n"", pcap_fh.version_major, pcap_fh.version_minor);
        printf(""thiszone    = 0x%08""PRIx32""\n"", pcap_fh.thiszone);
        printf(""sigfigs     = 0x%08""PRIx32""\n"", pcap_fh.sigfigs);
        printf(""snaplen     = %""PRIu32""\n"", pcap_fh.snaplen);
        printf(""linktype    = 0x%08""PRIx32""\n"", pcap_fh.linktype);

        if (pcap_fh.version_major != 2 && pcap_fh.version_minor != 4) {
            printf(""Sorry, we only support file format version 2.4\n"");
            close(fd);
            continue;
        }

        dbgx(5, ""Packet header len: %d"", pkthdrlen);

        if (pkthdrlen == 24) {
            printf(""Packet\tOrigLen\t\tCaplen\t\tTimestamp\t\tIndex\tProto\tPktType\tPktCsum\tNote\n"");
        } else {
            printf(""Packet\tOrigLen\t\tCaplen\t\tTimestamp\tCsum\tNote\n"");
        }

        pktcnt = 0;
        last_sec = 0;
        last_usec = 0;
        while ((ret = read(fd, &buf, pkthdrlen)) == pkthdrlen) {
            pktcnt ++;
            backwards = 0;
            caplentoobig = 0;
            dbgx(3, ""Read %d bytes for packet %""PRIu64"" header"", ret, pktcnt);

            memset(&pcap_ph, 0, sizeof(pcap_ph));

            /* see what packet header we're using */
            if (pkthdrlen == sizeof(pcap_patched_ph)) {
                memcpy(&pcap_patched_ph, &buf, sizeof(pcap_patched_ph));

                if (swapped == 1) {
                    dbg(3, ""Swapping packet header bytes..."");
                    pcap_patched_ph.caplen = SWAPLONG(pcap_patched_ph.caplen);
                    pcap_patched_ph.len = SWAPLONG(pcap_patched_ph.len);
                    pcap_patched_ph.ts.tv_sec = SWAPLONG(pcap_patched_ph.ts.tv_sec);
                    pcap_patched_ph.ts.tv_usec = SWAPLONG(pcap_patched_ph.ts.tv_usec);
                    pcap_patched_ph.index = SWAPLONG(pcap_patched_ph.index);
                    pcap_patched_ph.protocol = SWAPSHORT(pcap_patched_ph.protocol);
                }
                printf(""%""PRIu64""\t%4""PRIu32""\t\t%4""PRIu32""\t\t%""
                        PRIx32"".%""PRIx32""\t\t%4""PRIu32""\t%4hu\t%4hhu"", 
                        pktcnt, pcap_patched_ph.len, pcap_patched_ph.caplen, 
                        pcap_patched_ph.ts.tv_sec, pcap_patched_ph.ts.tv_usec,
                        pcap_patched_ph.index, pcap_patched_ph.protocol, pcap_patched_ph.pkt_type);

                if (pcap_fh.snaplen < pcap_patched_ph.caplen) {
                    caplentoobig = 1;
                }

                caplen = pcap_patched_ph.caplen;

            } else {
                /* manually map on-disk bytes to our memory structure */
                memcpy(&readword, buf, 4);
                pcap_ph.ts.tv_sec = readword;
                memcpy(&readword, &buf[4], 4);
                pcap_ph.ts.tv_usec = readword;
                memcpy(&pcap_ph.caplen, &buf[8], 4);
                memcpy(&pcap_ph.len, &buf[12], 4);

                if (swapped == 1) {
                    dbg(3, ""Swapping packet header bytes..."");
                    pcap_ph.caplen = SWAPLONG(pcap_ph.caplen);
                    pcap_ph.len = SWAPLONG(pcap_ph.len);
                    pcap_ph.ts.tv_sec = SWAPLONG(pcap_ph.ts.tv_sec);
                    pcap_ph.ts.tv_usec = SWAPLONG(pcap_ph.ts.tv_usec);
                }
                printf(""%""PRIu64""\t%4""PRIu32""\t\t%4""PRIu32""\t\t%""
                        PRIx32"".%""PRIx32,
                        pktcnt, pcap_ph.len, pcap_ph.caplen, 
                        (unsigned int)pcap_ph.ts.tv_sec, (unsigned int)pcap_ph.ts.tv_usec);
                if (pcap_fh.snaplen < pcap_ph.caplen) {
                    caplentoobig = 1;
                }
                caplen = pcap_ph.caplen;
            }

            if (caplentoobig) {
                printf(""\n\nCapture file appears to be damaged or corrupt.\n""
                        ""Contains packet of size %u, bigger than snap length %u\n"",
                        caplen, pcap_fh.snaplen);

                close(fd);
                break;
            }

            /* check to make sure timestamps don't go backwards */
            if (last_sec > 0 && last_usec > 0) {
                if ((pcap_ph.ts.tv_sec == last_sec) ? 
                        (pcap_ph.ts.tv_usec < last_usec) : 
                        (pcap_ph.ts.tv_sec < last_sec)) {
                    backwards = 1;
                }
            }
            if (pkthdrlen == sizeof(pcap_patched_ph)) {
                last_sec = pcap_patched_ph.ts.tv_sec;
                last_usec = pcap_patched_ph.ts.tv_usec;
            } else {
                last_sec = pcap_ph.ts.tv_sec;
                last_usec = pcap_ph.ts.tv_usec;
            }

            /* read the frame */
            if ((ret = read(fd, &buf, caplen)) != caplen) {
                if (ret < 0) {
                    printf(""Error reading file: %s: %s\n"", argv[i], strerror(errno));
                } else {
                    printf(""File truncated!  Unable to jump to next packet.\n"");
                }

                close(fd);
                break;
            }

            /* print the frame checksum */
            printf(""\t%x\t"", do_checksum_math((u_int16_t *)buf, caplen));

            /* print the Note */
            if (! backwards && ! caplentoobig) {
                printf(""OK\n"");
            } else if (backwards && ! caplentoobig) {
                printf(""BAD_TS\n"");
            } else if (caplentoobig && ! backwards) {
                printf(""TOOBIG\n"");
            } else if (backwards && caplentoobig) {
                printf(""BAD_TS|TOOBIG"");
            } 

        }

    }

    exit(0);

}","int
main(int VAR_0, char *VAR_1[])
{
    int VAR_2, VAR_3, VAR_4, VAR_5, VAR_6, VAR_7, VAR_8, VAR_9;
    struct pcap_file_header VAR_10;
    struct pcap_pkthdr VAR_11;
    struct pcap_sf_patched_pkthdr VAR_12; /* COMMENT_0 */
    char VAR_13[10000];
    struct stat VAR_14;
    uint64_t VAR_15;
    uint32_t VAR_16;
    int32_t VAR_17, VAR_18, VAR_19;

    VAR_7 = optionProcess(&VAR_20, VAR_0, VAR_1);
    VAR_0 -= VAR_7;
    VAR_1 += VAR_7;

#ifdef VAR_21
    if (HAVE_OPT(VAR_22))
        VAR_23 = VAR_24;
#endif

    for (VAR_2 = 0; VAR_2 < VAR_0; VAR_2++) {
        dbgx(1, ""processing:  %s\n"", VAR_1[VAR_2]);
        if ((VAR_3 = open(VAR_1[VAR_2], VAR_25)) < 0)
            errx(-1, ""Error opening file %s: %s"", VAR_1[VAR_2], strerror(VAR_26));

        if (fstat(VAR_3, &VAR_14) < 0)
            errx(-1, ""Error getting file stat info %s: %s"", VAR_1[VAR_2], strerror(VAR_26));

        printf(""file size   = %""VAR_27"" bytes\n"", (uint64_t)VAR_14.st_size);

        if ((VAR_6 = read(VAR_3, &VAR_13, sizeof(VAR_10))) != sizeof(VAR_10))
            errx(-1, ""File too small.  Unable to read pcap_file_header from %s"", VAR_1[VAR_2]);

        dbgx(3, ""Read %d bytes for file header"", VAR_6);

        VAR_4 = 0;

        memcpy(&VAR_10, &VAR_13, sizeof(VAR_10));

        VAR_5 = 16; /* COMMENT_1 */

        switch (VAR_10.magic) {
            case VAR_28:
            printf(""magic       = 0x%08""VAR_29"" (tcpdump) (%s)\n"", VAR_10.magic, VAR_30);
            break;

            case SWAPLONG(VAR_28):
            printf(""magic       = 0x%08""VAR_29"" (tcpdump/swapped) (%s)\n"", VAR_10.magic, VAR_31);
            VAR_4 = 1;
            break;

            case VAR_32:
            VAR_5 = sizeof(VAR_12);
            printf(""magic       = 0x%08""VAR_29"" (Kuznetzov) (%s)\n"", VAR_10.magic, VAR_30);
            break;

            case SWAPLONG(VAR_32):
            VAR_5 = sizeof(VAR_12);
            printf(""magic       = 0x%08""VAR_29"" (Kuznetzov/swapped) (%s)\n"", VAR_10.magic, VAR_31);
            VAR_4 = 1;
            break;

            case VAR_33:
            printf(""magic       = 0x%08""VAR_29"" (Fmesquita) (%s)\n"", VAR_10.magic, VAR_30);
            break;

            case SWAPLONG(VAR_33):
            printf(""magic       = 0x%08""VAR_29"" (Fmesquita) (%s)\n"", VAR_10.magic, VAR_31);
            VAR_4 = 1;
            break;

            case VAR_34:
            printf(""magic       = 0x%08""VAR_29"" (Navtel) (%s)\n"", VAR_10.magic, VAR_30);
            break;

            case SWAPLONG(VAR_34):
            printf(""magic       = 0x%08""VAR_29"" (Navtel/swapped) (%s)\n"", VAR_10.magic, VAR_31);
            VAR_4 = 1;
            break;

            case VAR_35:
            printf(""magic       = 0x%08""VAR_29"" (Nsec) (%s)\n"", VAR_10.magic, VAR_30);
            break;

            case SWAPLONG(VAR_35):
            printf(""magic       = 0x%08""VAR_29"" (Nsec/swapped) (%s)\n"", VAR_10.magic, VAR_31);
            VAR_4 = 1;
            break;

            default:
            printf(""magic       = 0x%08""VAR_29"" (unknown)\n"", VAR_10.magic);
        }

        if (VAR_4 == 1) {
            VAR_10.version_major = SWAPSHORT(VAR_10.version_major);
            VAR_10.version_minor = SWAPSHORT(VAR_10.version_minor);
            VAR_10.thiszone = SWAPLONG(VAR_10.thiszone);
            VAR_10.sigfigs = SWAPLONG(VAR_10.sigfigs);
            VAR_10.snaplen = SWAPLONG(VAR_10.snaplen);
            VAR_10.linktype = SWAPLONG(VAR_10.linktype);
        }

        printf(""version     = %hu.%hu\n"", VAR_10.version_major, VAR_10.version_minor);
        printf(""thiszone    = 0x%08""VAR_29""\n"", VAR_10.thiszone);
        printf(""sigfigs     = 0x%08""VAR_29""\n"", VAR_10.sigfigs);
        printf(""snaplen     = %""VAR_36""\n"", VAR_10.snaplen);
        printf(""linktype    = 0x%08""VAR_29""\n"", VAR_10.linktype);

        if (VAR_10.version_major != 2 && VAR_10.version_minor != 4) {
            printf(""Sorry, we only support file format version 2.4\n"");
            close(VAR_3);
            continue;
        }

        dbgx(5, ""Packet header len: %d"", VAR_5);

        if (VAR_5 == 24) {
            printf(""Packet\tOrigLen\t\tCaplen\t\tTimestamp\t\tIndex\tProto\tPktType\tPktCsum\tNote\n"");
        } else {
            printf(""Packet\tOrigLen\t\tCaplen\t\tTimestamp\tCsum\tNote\n"");
        }

        VAR_15 = 0;
        VAR_17 = 0;
        VAR_18 = 0;
        while ((VAR_6 = read(VAR_3, &VAR_13, VAR_5)) == VAR_5) {
            VAR_15 ++;
            VAR_8 = 0;
            VAR_9 = 0;
            dbgx(3, ""Read %d bytes for packet %""VAR_27"" header"", VAR_6, VAR_15);

            memset(&VAR_11, 0, sizeof(VAR_11));

            /* COMMENT_2 */
            if (VAR_5 == sizeof(VAR_12)) {
                memcpy(&VAR_12, &VAR_13, sizeof(VAR_12));

                if (VAR_4 == 1) {
                    dbg(3, ""Swapping packet header bytes..."");
                    VAR_12.caplen = SWAPLONG(VAR_12.caplen);
                    VAR_12.len = SWAPLONG(VAR_12.len);
                    VAR_12.ts.tv_sec = SWAPLONG(VAR_12.ts.tv_sec);
                    VAR_12.ts.tv_usec = SWAPLONG(VAR_12.ts.tv_usec);
                    VAR_12.index = SWAPLONG(VAR_12.index);
                    VAR_12.protocol = SWAPSHORT(VAR_12.protocol);
                }
                printf(""%""VAR_27""\t%4""VAR_36""\t\t%4""VAR_36""\t\t%""
                        VAR_29"".%""VAR_29""\t\t%4""VAR_36""\t%4hu\t%4hhu"", 
                        VAR_15, VAR_12.len, VAR_12.caplen, 
                        VAR_12.ts.tv_sec, VAR_12.ts.tv_usec,
                        VAR_12.index, VAR_12.protocol, VAR_12.pkt_type);

                if (VAR_10.snaplen < VAR_12.caplen) {
                    VAR_9 = 1;
                }

                VAR_19 = VAR_12.caplen;

            } else {
                /* COMMENT_3 */
                memcpy(&VAR_16, VAR_13, 4);
                VAR_11.ts.tv_sec = VAR_16;
                memcpy(&VAR_16, &VAR_13[4], 4);
                VAR_11.ts.tv_usec = VAR_16;
                memcpy(&VAR_11.caplen, &VAR_13[8], 4);
                memcpy(&VAR_11.len, &VAR_13[12], 4);

                if (VAR_4 == 1) {
                    dbg(3, ""Swapping packet header bytes..."");
                    VAR_11.caplen = SWAPLONG(VAR_11.caplen);
                    VAR_11.len = SWAPLONG(VAR_11.len);
                    VAR_11.ts.tv_sec = SWAPLONG(VAR_11.ts.tv_sec);
                    VAR_11.ts.tv_usec = SWAPLONG(VAR_11.ts.tv_usec);
                }
                printf(""%""VAR_27""\t%4""VAR_36""\t\t%4""VAR_36""\t\t%""
                        VAR_29"".%""VAR_29,
                        VAR_15, VAR_11.len, VAR_11.caplen, 
                        (unsigned int)VAR_11.ts.tv_sec, (unsigned int)VAR_11.ts.tv_usec);
                if (VAR_10.snaplen < VAR_11.caplen) {
                    VAR_9 = 1;
                }
                VAR_19 = VAR_11.caplen;
            }

            if (VAR_9) {
                printf(""\n\nCapture file appears to be damaged or corrupt.\n""
                        ""Contains packet of size %u, bigger than snap length %u\n"",
                        VAR_19, VAR_10.snaplen);

                close(VAR_3);
                break;
            }

            /* COMMENT_4 */
            if (VAR_17 > 0 && VAR_18 > 0) {
                if ((VAR_11.ts.tv_sec == VAR_17) ? 
                        (VAR_11.ts.tv_usec < VAR_18) : 
                        (VAR_11.ts.tv_sec < VAR_17)) {
                    VAR_8 = 1;
                }
            }
            if (VAR_5 == sizeof(VAR_12)) {
                VAR_17 = VAR_12.ts.tv_sec;
                VAR_18 = VAR_12.ts.tv_usec;
            } else {
                VAR_17 = VAR_11.ts.tv_sec;
                VAR_18 = VAR_11.ts.tv_usec;
            }

            /* COMMENT_5 */
            if ((VAR_6 = read(VAR_3, &VAR_13, VAR_19)) != VAR_19) {
                if (VAR_6 < 0) {
                    printf(""Error reading file: %s: %s\n"", VAR_1[VAR_2], strerror(VAR_26));
                } else {
                    printf(""File truncated!  Unable to jump to next packet.\n"");
                }

                close(VAR_3);
                break;
            }

            /* COMMENT_6 */
            printf(""\t%x\t"", do_checksum_math((u_int16_t *)VAR_13, VAR_19));

            /* COMMENT_7 */
            if (! VAR_8 && ! VAR_9) {
                printf(""OK\n"");
            } else if (VAR_8 && ! VAR_9) {
                printf(""BAD_TS\n"");
            } else if (VAR_9 && ! VAR_8) {
                printf(""TOOBIG\n"");
            } else if (VAR_8 && VAR_9) {
                printf(""BAD_TS|TOOBIG"");
            } 

        }

    }

    exit(0);

}",appneta/tcpreplay/d689d14dbcd768c028eab2fb378d849e543dcfe9/tcpcapinfo.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -184,6 +184,15 @@
                 caplen = pcap_ph.caplen;
             }
 
+            if (caplentoobig) {
+                printf(""\n\nCapture file appears to be damaged or corrupt.\n""
+                        ""Contains packet of size %u, bigger than snap length %u\n"",
+                        caplen, pcap_fh.snaplen);
+
+                close(fd);
+                break;
+            }
+
             /* check to make sure timestamps don't go backwards */
             if (last_sec > 0 && last_usec > 0) {
                 if ((pcap_ph.ts.tv_sec == last_sec) ? 
@@ -209,7 +218,7 @@
                 }
 
                 close(fd);
-                continue;
+                break;
             }
 
             /* print the frame checksum */","{'deleted_lines': ['                continue;'], 'added_lines': ['            if (caplentoobig) {', '                printf(""\\n\\nCapture file appears to be damaged or corrupt.\\n""', '                        ""Contains packet of size %u, bigger than snap length %u\\n"",', '                        caplen, pcap_fh.snaplen);', '', '                close(fd);', '                break;', '            }', '', '                break;']}",True,Buffer overflow in the tcpcapinfo utility in Tcpreplay before 4.2.0 Beta 1 allows remote attackers to have unspecified impact via a pcap file with an over-size packet.,7.8,HIGH,2,test,2017-02-27T04:45:59Z,1
CVE-2017-7272,"['CWE-20', 'CWE-918']",AV:N/AC:M/Au:N/C:P/I:P/A:N,0,php/php-src,"Detect invalid port in xp_socket parse ip address

For historical reasons, fsockopen() accepts the port and hostname
separately: fsockopen('127.0.0.1', 80)

However, with the introdcution of stream transports in PHP 4.3,
it became possible to include the port in the hostname specifier:

fsockopen('127.0.0.1:80')
Or more formally: fsockopen('tcp://127.0.0.1:80')

Confusing results when these two forms are combined, however.
fsockopen('127.0.0.1:80', 443) results in fsockopen() attempting
to connect to '127.0.0.1:80:443' which any reasonable stack would
consider invalid.

Unfortunately, PHP parses the address looking for the first colon
(with special handling for IPv6, don't worry) and calls atoi()
from there.  atoi() in turn, simply stops parsing at the first
non-numeric character and returns the value so far.

The end result is that the explicitly supplied port is treated
as ignored garbage, rather than producing an error.

This diff replaces atoi() with strtol() and inspects the
stop character.  If additional ""garbage"" of any kind is found,
it fails and returns an error.",bab0b99f376dac9170ac81382a5ed526938d595a,https://github.com/php/php-src/commit/bab0b99f376dac9170ac81382a5ed526938d595a,main/streams/xp_socket.c,parse_ip_address_ex,"static inline char *parse_ip_address_ex(const char *str, size_t str_len, int *portno, int get_err, zend_string **err)
{
char *colon;
char *host = NULL;
#ifdef HAVE_IPV6
char *p;
if (*(str) == '[' && str_len > 1) {
p = memchr(str + 1, ']', str_len - 2);
if (!p || *(p + 1) != ':') {
if (get_err) {
*err = strpprintf(0, ""Failed to parse IPv6 address \""%s\"""", str);
}
return NULL;
}
*portno = atoi(p + 2);
return estrndup(str + 1, p - str - 1);
}
#endif
if (str_len) {
colon = memchr(str, ':', str_len - 1);
} else {
colon = NULL;
}
if (colon) {
*portno = atoi(colon + 1);
host = estrndup(str, colon - str);
} else {
if (get_err) {
*err = strpprintf(0, ""Failed to parse address \""%s\"""", str);
}
return NULL;
}
return host;
}","static inline char *parse_ip_address_ex(const char *VAR_0, size_t VAR_1, int *VAR_2, int VAR_3, zend_string **VAR_4)
{
char *VAR_5;
char *VAR_6 = NULL;
#ifdef VAR_7
char *VAR_8;
if (*(VAR_0) == '[' && VAR_1 > 1) {
VAR_8 = memchr(VAR_0 + 1, ']', VAR_1 - 2);
if (!VAR_8 || *(VAR_8 + 1) != ':') {
if (VAR_3) {
*VAR_4 = strpprintf(0, ""Failed to parse IPv6 address \""%s\"""", VAR_0);
}
return NULL;
}
*VAR_2 = atoi(VAR_8 + 2);
return estrndup(VAR_0 + 1, VAR_8 - VAR_0 - 1);
}
#endif
if (VAR_1) {
VAR_5 = memchr(VAR_0, ':', VAR_1 - 1);
} else {
VAR_5 = NULL;
}
if (VAR_5) {
*VAR_2 = atoi(VAR_5 + 1);
VAR_6 = estrndup(VAR_0, VAR_5 - VAR_0);
} else {
if (VAR_3) {
*VAR_4 = strpprintf(0, ""Failed to parse address \""%s\"""", VAR_0);
}
return NULL;
}
return VAR_6;
}",php/php-src/bab0b99f376dac9170ac81382a5ed526938d595a/xp_socket.c/vul/before/0.json,"static inline char *parse_ip_address_ex(const char *str, size_t str_len, int *portno, int get_err, zend_string **err)
{
	char *colon;
	char *host = NULL;

#ifdef HAVE_IPV6
	if (*(str) == '[' && str_len > 1) {
		/* IPV6 notation to specify raw address with port (i.e. [fe80::1]:80) */
		char *p = memchr(str + 1, ']', str_len - 2), *e = NULL;
		if (!p || *(p + 1) != ':') {
			if (get_err) {
				*err = strpprintf(0, ""Failed to parse IPv6 address \""%s\"""", str);
			}
			return NULL;
		}
		*portno = strtol(p + 2, &e, 10);
		if (e && *e) {
			if (get_err) {
				*err = strpprintf(0, ""Failed to parse address \""%s\"""", str);
			}
			return NULL;
		}
		return estrndup(str + 1, p - str - 1);
	}
#endif

	if (str_len) {
		colon = memchr(str, ':', str_len - 1);
	} else {
		colon = NULL;
	}

	if (colon) {
		char *e = NULL;
		*portno = strtol(colon + 1, &e, 10);
		if (!e || !*e) {
			return estrndup(str, colon - str);
		}
	}

	if (get_err) {
		*err = strpprintf(0, ""Failed to parse address \""%s\"""", str);
	}
	return NULL;
}","static inline char *parse_ip_address_ex(const char *VAR_0, size_t VAR_1, int *VAR_2, int VAR_3, zend_string **VAR_4)
{
	char *VAR_5;
	char *VAR_6 = NULL;

#ifdef VAR_7
	if (*(VAR_0) == '[' && VAR_1 > 1) {
		/* COMMENT_0 */
		char *VAR_8 = memchr(VAR_0 + 1, ']', VAR_1 - 2), *VAR_9 = NULL;
		if (!VAR_8 || *(VAR_8 + 1) != ':') {
			if (VAR_3) {
				*VAR_4 = strpprintf(0, ""Failed to parse IPv6 address \""%s\"""", VAR_0);
			}
			return NULL;
		}
		*VAR_2 = strtol(VAR_8 + 2, &VAR_9, 10);
		if (VAR_9 && *VAR_9) {
			if (VAR_3) {
				*VAR_4 = strpprintf(0, ""Failed to parse address \""%s\"""", VAR_0);
			}
			return NULL;
		}
		return estrndup(VAR_0 + 1, VAR_8 - VAR_0 - 1);
	}
#endif

	if (VAR_1) {
		VAR_5 = memchr(VAR_0, ':', VAR_1 - 1);
	} else {
		VAR_5 = NULL;
	}

	if (VAR_5) {
		char *VAR_9 = NULL;
		*VAR_2 = strtol(VAR_5 + 1, &VAR_9, 10);
		if (!VAR_9 || !*VAR_9) {
			return estrndup(VAR_0, VAR_5 - VAR_0);
		}
	}

	if (VAR_3) {
		*VAR_4 = strpprintf(0, ""Failed to parse address \""%s\"""", VAR_0);
	}
	return NULL;
}",php/php-src/bab0b99f376dac9170ac81382a5ed526938d595a/xp_socket.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,35 +4,42 @@
 	char *host = NULL;
 
 #ifdef HAVE_IPV6
-	char *p;
-
 	if (*(str) == '[' && str_len > 1) {
 		/* IPV6 notation to specify raw address with port (i.e. [fe80::1]:80) */
-		p = memchr(str + 1, ']', str_len - 2);
+		char *p = memchr(str + 1, ']', str_len - 2), *e = NULL;
 		if (!p || *(p + 1) != ':') {
 			if (get_err) {
 				*err = strpprintf(0, ""Failed to parse IPv6 address \""%s\"""", str);
 			}
 			return NULL;
 		}
-		*portno = atoi(p + 2);
+		*portno = strtol(p + 2, &e, 10);
+		if (e && *e) {
+			if (get_err) {
+				*err = strpprintf(0, ""Failed to parse address \""%s\"""", str);
+			}
+			return NULL;
+		}
 		return estrndup(str + 1, p - str - 1);
 	}
 #endif
+
 	if (str_len) {
 		colon = memchr(str, ':', str_len - 1);
 	} else {
 		colon = NULL;
 	}
+
 	if (colon) {
-		*portno = atoi(colon + 1);
-		host = estrndup(str, colon - str);
-	} else {
-		if (get_err) {
-			*err = strpprintf(0, ""Failed to parse address \""%s\"""", str);
+		char *e = NULL;
+		*portno = strtol(colon + 1, &e, 10);
+		if (!e || !*e) {
+			return estrndup(str, colon - str);
 		}
-		return NULL;
 	}
 
-	return host;
+	if (get_err) {
+		*err = strpprintf(0, ""Failed to parse address \""%s\"""", str);
+	}
+	return NULL;
 }","{'deleted_lines': ['\tchar *p;', '', ""\t\tp = memchr(str + 1, ']', str_len - 2);"", '\t\t*portno = atoi(p + 2);', '\t\t*portno = atoi(colon + 1);', '\t\thost = estrndup(str, colon - str);', '\t} else {', '\t\tif (get_err) {', '\t\t\t*err = strpprintf(0, ""Failed to parse address \\""%s\\"""", str);', '\t\treturn NULL;', '\treturn host;'], 'added_lines': [""\t\tchar *p = memchr(str + 1, ']', str_len - 2), *e = NULL;"", '\t\t*portno = strtol(p + 2, &e, 10);', '\t\tif (e && *e) {', '\t\t\tif (get_err) {', '\t\t\t\t*err = strpprintf(0, ""Failed to parse address \\""%s\\"""", str);', '\t\t\t}', '\t\t\treturn NULL;', '\t\t}', '', '', '\t\tchar *e = NULL;', '\t\t*portno = strtol(colon + 1, &e, 10);', '\t\tif (!e || !*e) {', '\t\t\treturn estrndup(str, colon - str);', '\tif (get_err) {', '\t\t*err = strpprintf(0, ""Failed to parse address \\""%s\\"""", str);', '\t}', '\treturn NULL;']}",True,"PHP through 7.1.11 enables potential SSRF in applications that accept an fsockopen or pfsockopen hostname argument with an expectation that the port number is constrained. Because a :port syntax is recognized, fsockopen will use the port number that is specified in the hostname argument, instead of the port number in the second argument of the function.",7.4,HIGH,2,test,2017-03-07T19:27:46Z,1
CVE-2017-0152,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,chakra-core/ChakraCore,"[CVE-2017-0152] MSFT: 10592731 : Issue with Function name capturing in param scope

In a function expression with name, where the name is captured in one
of the param scope functions, if there is a function or var declaration
with the same name as the function expression name we were marking the
function expression name as shadowed. In non-eval case this causes
issue because the name symbol won't get added to the body. This change is to
fix it in such a way if the name is captured in the param scope then we
split the param and body scope such that the name symbol is added to the
param scope not body scope.",9da019424601325a6e95e6be0fa03d7d21d0b517,https://github.com/chakra-core/ChakraCore/commit/9da019424601325a6e95e6be0fa03d7d21d0b517,lib/Parser/Parse.cpp,Parser::ParseFncDeclHelper,"bool Parser::ParseFncDeclHelper(ParseNodePtr pnodeFnc, LPCOLESTR pNameHint, ushort flags, bool *pHasName, bool fUnaryOrParen, bool noStmtContext, bool *pNeedScanRCurly, bool skipFormals)
{
ParseNodePtr pnodeFncParent = GetCurrentFunctionNode();
ParseNodePtr pnodeFncSave = buildAST ? m_currentNodeFunc : m_currentNodeDeferredFunc;
ParseNodePtr pnodeFncSaveNonLambda = buildAST ? m_currentNodeNonLambdaFunc : m_currentNodeNonLambdaDeferredFunc;
int32* pAstSizeSave = m_pCurrentAstSize;
bool fDeclaration = (flags & fFncDeclaration) != 0;
bool fLambda = (flags & fFncLambda) != 0;
bool fAsync = (flags & fFncAsync) != 0;
bool fModule = (flags & fFncModule) != 0;
bool fDeferred = false;
StmtNest *pstmtSave;
ParseNodePtr *lastNodeRef = nullptr;
bool fFunctionInBlock = false;
if (buildAST)
{
fFunctionInBlock = GetCurrentBlockInfo() != GetCurrentFunctionBlockInfo() &&
(GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope == nullptr ||
GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope->GetScopeType() != ScopeType_GlobalEvalBlock);
}
RestorePoint beginNameHint;
m_pscan->Capture(&beginNameHint);
ParseNodePtr pnodeFncExprScope = nullptr;    
Scope *fncExprScope = nullptr;
if (!fDeclaration)
{
pnodeFncExprScope = StartParseBlock<buildAST>(PnodeBlockType::Function, ScopeType_FuncExpr);
fncExprScope = pnodeFncExprScope->sxBlock.scope;
this->UpdateCurrentNodeFunc<buildAST>(pnodeFnc, fLambda);
}
*pHasName = !fLambda && !fModule && this->ParseFncNames<buildAST>(pnodeFnc, pnodeFncSave, flags, &lastNodeRef);
if (fDeclaration)
{
this->UpdateCurrentNodeFunc<buildAST>(pnodeFnc, fLambda);
}
if (noStmtContext && pnodeFnc->sxFnc.IsGenerator())
{
Error(ERRsyntax, pnodeFnc);
}
bool fPreviousYieldIsKeyword = m_pscan->SetYieldIsKeyword(pnodeFnc && pnodeFnc->sxFnc.IsGenerator());
bool fPreviousAwaitIsKeyword = m_pscan->SetAwaitIsKeyword(fAsync);
if (pnodeFnc && pnodeFnc->sxFnc.IsGenerator())
{
CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Generator, m_scriptContext);
}
if (fncExprScope && !*pHasName)
{
FinishParseBlock(pnodeFncExprScope);
m_nextBlockId--;
Adelete(&m_nodeAllocator, fncExprScope);
fncExprScope = nullptr;
pnodeFncExprScope = nullptr;
}
if (pnodeFnc)
{
pnodeFnc->sxFnc.scope = fncExprScope;
}
bool topLevelStmt =
buildAST &&
!fFunctionInBlock &&
(this->m_pstmtCur == nullptr || this->m_pstmtCur->pnodeStmt->nop == knopBlock);
pstmtSave = m_pstmtCur;
SetCurrentStatement(nullptr);
bool isEnclosedInParamScope = this->m_currentScope->GetScopeType() == ScopeType_Parameter;
if (this->m_currentScope->GetScopeType() == ScopeType_FuncExpr || this->m_currentScope->GetScopeType() == ScopeType_Block)
{
isEnclosedInParamScope = this->m_currentScope->GetEnclosingScope() && this->m_currentScope->GetEnclosingScope()->GetScopeType() == ScopeType_Parameter;
}
Assert(!isEnclosedInParamScope || pnodeFncSave->sxFnc.HasNonSimpleParameterList());
RestorePoint beginFormals;
m_pscan->Capture(&beginFormals);
BOOL fWasAlreadyStrictMode = IsStrictMode();
BOOL oldStrictMode = this->m_fUseStrictMode;
if (fLambda)
{
CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Lambda, m_scriptContext);
}
uint uDeferSave = m_grfscr & fscrDeferFncParse;
if ((!fDeclaration && m_ppnodeExprScope) ||
isEnclosedInParamScope ||
(flags & (fFncNoName | fFncLambda)))
{
m_grfscr &= ~fscrDeferFncParse;
}
bool saveInFIB = this->m_inFIB;
this->m_inFIB = fFunctionInBlock || this->m_inFIB;
bool isTopLevelDeferredFunc = false;
struct AutoFastScanFlag {
bool savedDoingFastScan;
AutoFastScanFlag(Parser *parser) : m_parser(parser) { savedDoingFastScan = m_parser->m_doingFastScan; }
~AutoFastScanFlag() { m_parser->m_doingFastScan = savedDoingFastScan; }
Parser *m_parser;
} flag(this);
bool doParallel = false;
bool parallelJobStarted = false;
if (buildAST)
{
bool isLikelyIIFE = !fDeclaration && pnodeFnc && fUnaryOrParen;
BOOL isDeferredFnc = IsDeferredFnc();
AnalysisAssert(isDeferredFnc || pnodeFnc);
isTopLevelDeferredFunc =
(!fLambda
&& pnodeFnc
&& DeferredParse(pnodeFnc->sxFnc.functionId)
&& (!pnodeFnc->sxFnc.IsNested() || CONFIG_FLAG(DeferNested))
&& !m_InAsmMode
&& !fModule
);
if (pnodeFnc)
{
pnodeFnc->sxFnc.SetCanBeDeferred(isTopLevelDeferredFunc && PnFnc::CanBeRedeferred(pnodeFnc->sxFnc.fncFlags));
pnodeFnc->sxFnc.SetFIBPreventsDeferral(false);
}
if (this->m_inFIB)
{
if (isTopLevelDeferredFunc)
{
pnodeFnc->sxFnc.SetFIBPreventsDeferral(true);
}
isTopLevelDeferredFunc = false;
}        
isTopLevelDeferredFunc = isTopLevelDeferredFunc && !isDeferredFnc && 
(!isLikelyIIFE || !topLevelStmt || PHASE_FORCE_RAW(Js::DeferParsePhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId));
;
if (!fLambda &&
!isDeferredFnc &&
!isLikelyIIFE &&
!this->IsBackgroundParser() &&
!this->m_doingFastScan &&
!(pnodeFncSave && m_currDeferredStub) &&
!(this->m_parseType == ParseType_Deferred && this->m_functionBody && this->m_functionBody->GetScopeInfo() && !isTopLevelDeferredFunc))
{
doParallel = DoParallelParse(pnodeFnc);
#if ENABLE_BACKGROUND_PARSING
if (doParallel)
{
BackgroundParser *bgp = m_scriptContext->GetBackgroundParser();
Assert(bgp);
if (bgp->HasFailedBackgroundParseItem())
{
Error(ERRsyntax);
}
doParallel = bgp->ParseBackgroundItem(this, pnodeFnc, isTopLevelDeferredFunc);
if (doParallel)
{
parallelJobStarted = true;
this->m_hasParallelJob = true;
this->m_doingFastScan = true;
doParallel = FastScanFormalsAndBody();
if (doParallel)
{
pnodeFnc->ichLim = m_pscan->IchLimTok();
pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();
}
}
}
#endif
}
}
if (!doParallel)
{
ParseNodePtr pnodeRealFnc = pnodeFnc;
if (parallelJobStarted)
{
pnodeFnc = CreateDummyFuncNode(fDeclaration);
}
AnalysisAssert(pnodeFnc);
ParseNodePtr pnodeBlock = StartParseBlock<buildAST>(PnodeBlockType::Parameter, ScopeType_Parameter);
AnalysisAssert(pnodeBlock != nullptr);
pnodeFnc->sxFnc.pnodeScopes = pnodeBlock;
m_ppnodeVar = &pnodeFnc->sxFnc.pnodeParams;
ParseNodePtr *ppnodeScopeSave = nullptr;
ParseNodePtr *ppnodeExprScopeSave = nullptr;
ppnodeScopeSave = m_ppnodeScope;
if (pnodeBlock)
{
m_ppnodeScope = &pnodeBlock->sxBlock.pnodeScopes;
pnodeBlock->sxBlock.pnodeStmt = pnodeFnc;
}
ppnodeExprScopeSave = m_ppnodeExprScope;
m_ppnodeExprScope = nullptr;
if (!skipFormals)
{
bool fLambdaParamsSave = m_reparsingLambdaParams;
if (fLambda)
{
m_reparsingLambdaParams = true;
}
this->ParseFncFormals<buildAST>(pnodeFnc, pnodeFncParent, flags);
m_reparsingLambdaParams = fLambdaParamsSave;
}
ParseNodePtr pnodeInnerBlock = StartParseBlock<buildAST>(PnodeBlockType::Function, ScopeType_FunctionBody);
*m_ppnodeScope = pnodeInnerBlock;
pnodeFnc->sxFnc.pnodeBodyScope = pnodeInnerBlock;
m_ppnodeScope = &pnodeInnerBlock->sxBlock.pnodeScopes;
pnodeInnerBlock->sxBlock.pnodeStmt = pnodeFnc;
bool strictModeTurnedOn = false;
if (isTopLevelDeferredFunc &&
!(this->m_grfscr & fscrEvalCode) &&
pnodeFnc->sxFnc.IsNested() &&
#ifndef DISABLE_DYNAMIC_PROFILE_DEFER_PARSE
m_sourceContextInfo->sourceDynamicProfileManager == nullptr &&
#endif
PHASE_ON_RAW(Js::ScanAheadPhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId) &&
(
!PHASE_FORCE_RAW(Js::DeferParsePhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId) ||
PHASE_FORCE_RAW(Js::ScanAheadPhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId)
))
{
if (this->ScanAheadToFunctionEnd(CONFIG_FLAG(MinDeferredFuncTokenCount)))
{
isTopLevelDeferredFunc = false;
}
}
Scope* paramScope = pnodeFnc->sxFnc.pnodeScopes ? pnodeFnc->sxFnc.pnodeScopes->sxBlock.scope : nullptr;
if (paramScope != nullptr)
{
if (CONFIG_FLAG(ForceSplitScope))
{
paramScope->SetCannotMergeWithBodyScope();
}
else if (pnodeFnc->sxFnc.HasNonSimpleParameterList())
{
if (paramScope->GetCanMergeWithBodyScope())
{
paramScope->ForEachSymbolUntil([this, paramScope, pnodeFnc](Symbol* sym) {
if (sym->GetPid()->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)
{
paramScope->SetCannotMergeWithBodyScope();
return true;
}
return false;
});
if (wellKnownPropertyPids.arguments->GetTopRef() && wellKnownPropertyPids.arguments->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)
{
Assert(pnodeFnc->sxFnc.UsesArguments());
paramScope->SetCannotMergeWithBodyScope();
}
}
}
}
if (!fLambda && paramScope != nullptr && !paramScope->GetCanMergeWithBodyScope()
&& (pnodeFnc->sxFnc.UsesArguments() || pnodeFnc->grfpn & fpnArguments_overriddenByDecl))
{
Error(ERRNonSimpleParamListArgumentsUse);
}
if (paramScope != nullptr && paramScope->GetCanMergeWithBodyScope())
{
paramScope->ForEachSymbol([this](Symbol* paramSym)
{
PidRefStack* ref = PushPidRef(paramSym->GetPid());
ref->SetSym(paramSym);
});
}
if (isTopLevelDeferredFunc || (m_InAsmMode && m_deferAsmJs))
{
AssertMsg(!fLambda, ""Deferring function parsing of a function does not handle lambda syntax"");
fDeferred = true;
this->ParseTopLevelDeferredFunc(pnodeFnc, pnodeFncSave, pNameHint);
}
else
{
if (m_token.tk == tkRParen)             {
m_pscan->Scan();
}
if (fLambda)
{
BOOL hadNewLine = m_pscan->FHadNewLine();
ChkCurTok(tkDArrow, ERRnoDArrow);
if (hadNewLine)
{
Error(ERRsyntax);
}
}
AnalysisAssert(pnodeFnc);
Assert(*m_ppnodeVar == nullptr);
pnodeFnc->sxFnc.pnodeVars = nullptr;
m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;
if (paramScope != nullptr && !paramScope->GetCanMergeWithBodyScope())
{
OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(""The param and body scope of the function %s cannot be merged\n""), pnodeFnc->sxFnc.pnodeName ? pnodeFnc->sxFnc.pnodeName->sxVar.pid->Psz() : _u(""Anonymous function""));
paramScope->ForEachSymbol([this, pnodeFnc](Symbol* param) {
OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(""Creating a duplicate symbol for the parameter %s in the body scope\n""), param->GetPid()->Psz());
ParseNodePtr paramNode = nullptr;
if (this->m_ppnodeVar != &pnodeFnc->sxFnc.pnodeVars)
{
ParseNodePtr *const ppnodeVarSave = m_ppnodeVar;
m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;
paramNode = this->CreateVarDeclNode(param->GetPid(), STVariable, false, nullptr, false);
m_ppnodeVar = ppnodeVarSave;
}
else
{
paramNode = this->CreateVarDeclNode(param->GetPid(), STVariable, false, nullptr, false);
}
Assert(paramNode && paramNode->sxVar.sym->GetScope()->GetScopeType() == ScopeType_FunctionBody);
paramNode->sxVar.sym->SetHasInit(true);
});
if (!fLambda)
{
ParseNodePtr argumentsNode = this->CreateVarDeclNode(wellKnownPropertyPids.arguments, STVariable, true, nullptr, false);
Assert(argumentsNode && argumentsNode->sxVar.sym->GetScope()->GetScopeType() == ScopeType_FunctionBody);
}
}
m_ppnodeExprScope = nullptr;
if (buildAST)
{
DeferredFunctionStub *saveCurrentStub = m_currDeferredStub;
if (isEnclosedInParamScope)
{
m_currDeferredStub = nullptr;
}
else if (pnodeFncSave && m_currDeferredStub)
{
if (pnodeFncSave->sxFnc.nestedCount == 1)
{
m_prevSiblingDeferredStub = nullptr;
}
if (m_prevSiblingDeferredStub == nullptr)
{
m_prevSiblingDeferredStub = (m_currDeferredStub + (pnodeFncSave->sxFnc.nestedCount - 1));
}
if (m_prevSiblingDeferredStub->ichMin == pnodeFnc->ichMin)
{
m_currDeferredStub = m_prevSiblingDeferredStub->deferredStubs;
m_prevSiblingDeferredStub = nullptr;
}
else
{
m_currDeferredStub = nullptr;
}
}
if (m_token.tk != tkLCurly && fLambda)
{
ParseExpressionLambdaBody<true>(pnodeFnc);
*pNeedScanRCurly = false;
}
else
{
this->FinishFncDecl(pnodeFnc, pNameHint, lastNodeRef, skipFormals);
}
m_currDeferredStub = saveCurrentStub;
}
else
{
this->ParseNestedDeferredFunc(pnodeFnc, fLambda, pNeedScanRCurly, &strictModeTurnedOn);
}
}
if (pnodeInnerBlock)
{
FinishParseBlock(pnodeInnerBlock, *pNeedScanRCurly);
}
if (!fModule && (m_token.tk == tkLCurly || !fLambda))
{
this->AddArgumentsNodeToVars(pnodeFnc);
}
Assert(m_ppnodeExprScope == nullptr || *m_ppnodeExprScope == nullptr);
m_ppnodeExprScope = ppnodeExprScopeSave;
AssertMem(m_ppnodeScope);
Assert(nullptr == *m_ppnodeScope);
m_ppnodeScope = ppnodeScopeSave;
if (pnodeBlock)
{
FinishParseBlock(pnodeBlock, *pNeedScanRCurly);
}
if (IsStrictMode() || strictModeTurnedOn)
{
this->m_fUseStrictMode = TRUE; 
if (!fWasAlreadyStrictMode)
{
RestorePoint afterFnc;
m_pscan->Capture(&afterFnc);
if (*pHasName)
{
m_pscan->SeekTo(beginNameHint);
m_pscan->Scan();
if (pnodeFnc->sxFnc.IsGenerator())
{
Assert(m_token.tk == tkStar);
Assert(m_scriptContext->GetConfig()->IsES6GeneratorsEnabled());
Assert(!(flags & fFncClassMember));
m_pscan->Scan();
}
if (m_token.IsReservedWord())
{
IdentifierExpectedError(m_token);
}
CheckStrictModeEvalArgumentsUsage(m_token.GetIdentifier(m_phtbl));
}
m_pscan->SeekToForcingPid(beginFormals);
CheckStrictFormalParameters();
m_pscan->SeekTo(afterFnc);
}
if (buildAST)
{
if (pnodeFnc->sxFnc.pnodeName != nullptr && knopVarDecl == pnodeFnc->sxFnc.pnodeName->nop)
{
CheckStrictModeEvalArgumentsUsage(pnodeFnc->sxFnc.pnodeName->sxVar.pid, pnodeFnc->sxFnc.pnodeName);
}
}
this->m_fUseStrictMode = oldStrictMode;
CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(StrictModeFunction, m_scriptContext);
}
if (fDeferred)
{
AnalysisAssert(pnodeFnc);
pnodeFnc->sxFnc.pnodeVars = nullptr;
}
if (parallelJobStarted)
{
pnodeFnc = pnodeRealFnc;
m_currentNodeFunc = pnodeRealFnc;
pnodeFnc->ichLim = m_pscan->IchLimTok();
pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();
}
}
AnalysisAssert(pnodeFnc);
if (pnodeFnc->sxFnc.GetAsmjsMode())
{
m_InAsmMode = false;
}
Assert(nullptr == m_pstmtCur);
SetCurrentStatement(pstmtSave);
if (pnodeFncExprScope)
{
FinishParseFncExprScope(pnodeFnc, pnodeFncExprScope);
}
if (!m_stoppedDeferredParse)
{
m_grfscr |= uDeferSave;
}
m_inFIB = saveInFIB;
m_pscan->SetYieldIsKeyword(fPreviousYieldIsKeyword);
m_pscan->SetAwaitIsKeyword(fPreviousAwaitIsKeyword);
if (buildAST)
{
Assert(pnodeFnc == m_currentNodeFunc);
m_currentNodeFunc = pnodeFncSave;
m_pCurrentAstSize = pAstSizeSave;
if (!fLambda)
{
Assert(pnodeFnc == m_currentNodeNonLambdaFunc);
m_currentNodeNonLambdaFunc = pnodeFncSaveNonLambda;
}
}
else
{
Assert(pnodeFnc == m_currentNodeDeferredFunc);
if (!fLambda)
{
Assert(pnodeFnc == m_currentNodeNonLambdaDeferredFunc);
m_currentNodeNonLambdaDeferredFunc = pnodeFncSaveNonLambda;
}
m_currentNodeDeferredFunc = pnodeFncSave;
}
if (m_currentNodeFunc && pnodeFnc->sxFnc.HasWithStmt())
{
GetCurrentFunctionNode()->sxFnc.SetHasWithStmt(true);
}
return true;
}","bool Parser::ParseFncDeclHelper(ParseNodePtr VAR_0, LPCOLESTR VAR_1, ushort VAR_2, bool *VAR_3, bool VAR_4, bool VAR_5, bool *VAR_6, bool VAR_7)
{
ParseNodePtr VAR_8 = GetCurrentFunctionNode();
ParseNodePtr VAR_9 = VAR_10 ? VAR_11 : VAR_12;
ParseNodePtr VAR_13 = VAR_10 ? VAR_14 : VAR_15;
int32* VAR_16 = VAR_17;
bool VAR_18 = (VAR_2 & VAR_19) != 0;
bool VAR_20 = (VAR_2 & VAR_21) != 0;
bool VAR_22 = (VAR_2 & VAR_23) != 0;
bool VAR_24 = (VAR_2 & VAR_25) != 0;
bool VAR_26 = false;
StmtNest *VAR_27;
ParseNodePtr *VAR_28 = nullptr;
bool VAR_29 = false;
if (VAR_10)
{
VAR_29 = GetCurrentBlockInfo() != GetCurrentFunctionBlockInfo() &&
(GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope == nullptr ||
GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope->GetScopeType() != VAR_30);
}
RestorePoint VAR_31;
VAR_32->Capture(&VAR_31);
ParseNodePtr VAR_33 = nullptr;    
Scope *VAR_34 = nullptr;
if (!VAR_18)
{
VAR_33 = VAR_35<buildAST>(PnodeBlockType::Function, VAR_36);
VAR_34 = VAR_33->sxBlock.scope;
this->UpdateCurrentNodeFunc<buildAST>(VAR_0, VAR_20);
}
*VAR_3 = !VAR_20 && !VAR_24 && this->ParseFncNames<buildAST>(VAR_0, VAR_9, VAR_2, &VAR_28);
if (VAR_18)
{
this->UpdateCurrentNodeFunc<buildAST>(VAR_0, VAR_20);
}
if (VAR_5 && VAR_0->sxFnc.IsGenerator())
{
Error(VAR_37, VAR_0);
}
bool VAR_38 = VAR_32->SetYieldIsKeyword(VAR_0 && VAR_0->sxFnc.IsGenerator());
bool VAR_39 = VAR_32->SetAwaitIsKeyword(VAR_22);
if (VAR_0 && VAR_0->sxFnc.IsGenerator())
{
CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(VAR_40, VAR_41);
}
if (VAR_34 && !*VAR_3)
{
FinishParseBlock(VAR_33);
VAR_42--;
Adelete(&VAR_43, VAR_34);
VAR_34 = nullptr;
VAR_33 = nullptr;
}
if (VAR_0)
{
VAR_0->sxFnc.scope = VAR_34;
}
bool VAR_44 =
buildAST &&
!VAR_29 &&
(this->m_pstmtCur == nullptr || this->m_pstmtCur->pnodeStmt->nop == VAR_45);
VAR_27 = VAR_46;
SetCurrentStatement(nullptr);
bool VAR_47 = this->m_currentScope->GetScopeType() == VAR_48;
if (this->m_currentScope->GetScopeType() == VAR_36 || this->m_currentScope->GetScopeType() == VAR_49)
{
VAR_47 = this->m_currentScope->GetEnclosingScope() && this->m_currentScope->GetEnclosingScope()->GetScopeType() == VAR_48;
}
Assert(!VAR_47 || VAR_9->sxFnc.HasNonSimpleParameterList());
RestorePoint VAR_50;
VAR_32->Capture(&VAR_50);
BOOL VAR_51 = IsStrictMode();
BOOL VAR_52 = this->m_fUseStrictMode;
if (VAR_20)
{
CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(VAR_53, VAR_41);
}
uint VAR_54 = VAR_55 & VAR_56;
if ((!VAR_18 && VAR_57) ||
VAR_47 ||
(VAR_2 & (VAR_58 | VAR_21)))
{
VAR_55 &= ~VAR_56;
}
bool VAR_59 = this->m_inFIB;
this->m_inFIB = VAR_29 || this->m_inFIB;
bool VAR_60 = false;
struct AutoFastScanFlag {
bool savedDoingFastScan;
AutoFastScanFlag(Parser *VAR_61) : m_parser(VAR_61) { VAR_62 = VAR_63->m_doingFastScan; }
~AutoFastScanFlag() { VAR_63->m_doingFastScan = VAR_62; }
Parser *m_parser;
} VAR_64(this);
bool VAR_65 = false;
bool VAR_66 = false;
if (buildAST)
{
bool VAR_67 = !VAR_18 && VAR_0 && VAR_4;
BOOL VAR_68 = IsDeferredFnc();
AnalysisAssert(VAR_68 || VAR_0);
VAR_60 =
(!VAR_20
&& VAR_0
&& DeferredParse(VAR_0->sxFnc.functionId)
&& (!VAR_0->sxFnc.IsNested() || CONFIG_FLAG(VAR_69))
&& !VAR_70
&& !VAR_24
);
if (VAR_0)
{
VAR_0->sxFnc.SetCanBeDeferred(VAR_60 && PnFnc::CanBeRedeferred(VAR_0->sxFnc.fncFlags));
VAR_0->sxFnc.SetFIBPreventsDeferral(false);
}
if (this->m_inFIB)
{
if (VAR_60)
{
VAR_0->sxFnc.SetFIBPreventsDeferral(true);
}
VAR_60 = false;
}        
VAR_60 = VAR_60 && !VAR_68 && 
(!VAR_67 || !VAR_44 || PHASE_FORCE_RAW(Js::DeferParsePhase, VAR_71->sourceContextId, VAR_0->sxFnc.functionId));
;
if (!VAR_20 &&
!VAR_68 &&
!VAR_67 &&
!this->IsBackgroundParser() &&
!this->m_doingFastScan &&
!(VAR_9 && VAR_72) &&
!(this->m_parseType == VAR_73 && this->m_functionBody && this->m_functionBody->GetScopeInfo() && !VAR_60))
{
VAR_65 = DoParallelParse(VAR_0);
#if VAR_74
if (VAR_65)
{
BackgroundParser *VAR_75 = VAR_41->GetBackgroundParser();
Assert(VAR_75);
if (VAR_75->HasFailedBackgroundParseItem())
{
Error(VAR_37);
}
VAR_65 = VAR_75->ParseBackgroundItem(this, VAR_0, VAR_60);
if (VAR_65)
{
VAR_66 = true;
this->m_hasParallelJob = true;
this->m_doingFastScan = true;
VAR_65 = FastScanFormalsAndBody();
if (VAR_65)
{
VAR_0->ichLim = VAR_32->IchLimTok();
VAR_0->sxFnc.cbLim = VAR_32->IecpLimTok();
}
}
}
#endif
}
}
if (!VAR_65)
{
ParseNodePtr VAR_76 = VAR_0;
if (VAR_66)
{
VAR_0 = CreateDummyFuncNode(VAR_18);
}
AnalysisAssert(VAR_0);
ParseNodePtr VAR_77 = VAR_35<buildAST>(PnodeBlockType::Parameter, VAR_48);
AnalysisAssert(VAR_77 != nullptr);
VAR_0->sxFnc.pnodeScopes = VAR_77;
VAR_78 = &VAR_0->sxFnc.pnodeParams;
ParseNodePtr *VAR_79 = nullptr;
ParseNodePtr *VAR_80 = nullptr;
VAR_79 = VAR_81;
if (VAR_77)
{
VAR_81 = &VAR_77->sxBlock.pnodeScopes;
VAR_77->sxBlock.pnodeStmt = VAR_0;
}
VAR_80 = VAR_57;
VAR_57 = nullptr;
if (!VAR_7)
{
bool VAR_82 = VAR_83;
if (VAR_20)
{
VAR_83 = true;
}
this->ParseFncFormals<buildAST>(VAR_0, VAR_8, VAR_2);
VAR_83 = VAR_82;
}
ParseNodePtr VAR_84 = VAR_35<buildAST>(PnodeBlockType::Function, VAR_85);
*VAR_81 = VAR_84;
VAR_0->sxFnc.pnodeBodyScope = VAR_84;
VAR_81 = &VAR_84->sxBlock.pnodeScopes;
VAR_84->sxBlock.pnodeStmt = VAR_0;
bool VAR_86 = false;
if (VAR_60 &&
!(this->m_grfscr & VAR_87) &&
VAR_0->sxFnc.IsNested() &&
#ifndef VAR_88
VAR_71->sourceDynamicProfileManager == nullptr &&
#endif
PHASE_ON_RAW(Js::ScanAheadPhase, VAR_71->sourceContextId, VAR_0->sxFnc.functionId) &&
(
!PHASE_FORCE_RAW(Js::DeferParsePhase, VAR_71->sourceContextId, VAR_0->sxFnc.functionId) ||
PHASE_FORCE_RAW(Js::ScanAheadPhase, VAR_71->sourceContextId, VAR_0->sxFnc.functionId)
))
{
if (this->ScanAheadToFunctionEnd(CONFIG_FLAG(VAR_89)))
{
VAR_60 = false;
}
}
Scope* VAR_90 = VAR_0->sxFnc.pnodeScopes ? VAR_0->sxFnc.pnodeScopes->sxBlock.scope : nullptr;
if (VAR_90 != nullptr)
{
if (CONFIG_FLAG(VAR_91))
{
VAR_90->SetCannotMergeWithBodyScope();
}
else if (VAR_0->sxFnc.HasNonSimpleParameterList())
{
if (VAR_90->GetCanMergeWithBodyScope())
{
VAR_90->ForEachSymbolUntil([this, VAR_90, VAR_0](Symbol* VAR_92) {
if (VAR_92->GetPid()->GetTopRef()->GetFuncScopeId() > VAR_0->sxFnc.functionId)
{
VAR_90->SetCannotMergeWithBodyScope();
return true;
}
return false;
});
if (VAR_93.arguments->GetTopRef() && VAR_93.arguments->GetTopRef()->GetFuncScopeId() > VAR_0->sxFnc.functionId)
{
Assert(VAR_0->sxFnc.UsesArguments());
VAR_90->SetCannotMergeWithBodyScope();
}
}
}
}
if (!VAR_20 && VAR_90 != nullptr && !VAR_90->GetCanMergeWithBodyScope()
&& (VAR_0->sxFnc.UsesArguments() || VAR_0->grfpn & VAR_94))
{
Error(VAR_95);
}
if (VAR_90 != nullptr && VAR_90->GetCanMergeWithBodyScope())
{
VAR_90->ForEachSymbol([this](Symbol* VAR_96)
{
PidRefStack* VAR_97 = PushPidRef(VAR_96->GetPid());
VAR_97->SetSym(VAR_96);
});
}
if (VAR_60 || (VAR_70 && VAR_98))
{
AssertMsg(!VAR_20, ""Deferring function parsing of a function does not handle lambda syntax"");
VAR_26 = true;
this->ParseTopLevelDeferredFunc(VAR_0, VAR_9, VAR_1);
}
else
{
if (VAR_99.tk == VAR_100) 
{
VAR_32->Scan();
}
if (VAR_20)
{
BOOL VAR_101 = VAR_32->FHadNewLine();
ChkCurTok(VAR_102, VAR_103);
if (VAR_101)
{
Error(VAR_37);
}
}
AnalysisAssert(VAR_0);
Assert(*VAR_78 == nullptr);
VAR_0->sxFnc.pnodeVars = nullptr;
VAR_78 = &VAR_0->sxFnc.pnodeVars;
if (VAR_90 != nullptr && !VAR_90->GetCanMergeWithBodyScope())
{
OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(""The param and body scope of the function %s cannot be merged\n""), VAR_0->sxFnc.pnodeName ? VAR_0->sxFnc.pnodeName->sxVar.pid->Psz() : _u(""Anonymous function""));
VAR_90->ForEachSymbol([this, VAR_0](Symbol* VAR_104) {
OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(""Creating a duplicate symbol for the parameter %s in the body scope\n""), VAR_104->GetPid()->Psz());
ParseNodePtr VAR_105 = nullptr;
if (this->m_ppnodeVar != &VAR_0->sxFnc.pnodeVars)
{
ParseNodePtr *const VAR_106 = VAR_78;
VAR_78 = &VAR_0->sxFnc.pnodeVars;
VAR_105 = this->CreateVarDeclNode(VAR_104->GetPid(), VAR_107, false, nullptr, false);
VAR_78 = VAR_106;
}
else
{
VAR_105 = this->CreateVarDeclNode(VAR_104->GetPid(), VAR_107, false, nullptr, false);
}
Assert(VAR_105 && VAR_105->sxVar.sym->GetScope()->GetScopeType() == VAR_85);
VAR_105->sxVar.sym->SetHasInit(true);
});
if (!VAR_20)
{
ParseNodePtr VAR_108 = this->CreateVarDeclNode(VAR_93.arguments, VAR_107, true, nullptr, false);
Assert(VAR_108 && VAR_108->sxVar.sym->GetScope()->GetScopeType() == VAR_85);
}
}
VAR_57 = nullptr;
if (buildAST)
{
DeferredFunctionStub *VAR_109 = VAR_72;
if (VAR_47)
{
VAR_72 = nullptr;
}
else if (VAR_9 && VAR_72)
{
if (VAR_9->sxFnc.nestedCount == 1)
{
VAR_110 = nullptr;
}
if (VAR_110 == nullptr)
{
VAR_110 = (VAR_72 + (VAR_9->sxFnc.nestedCount - 1));
}
if (VAR_110->ichMin == VAR_0->ichMin)
{
VAR_72 = VAR_110->deferredStubs;
VAR_110 = nullptr;
}
else
{
VAR_72 = nullptr;
}
}
if (VAR_99.tk != VAR_111 && VAR_20)
{
VAR_112<true>(VAR_0);
*VAR_6 = false;
}
else
{
this->FinishFncDecl(VAR_0, VAR_1, VAR_28, VAR_7);
}
VAR_72 = VAR_109;
}
else
{
this->ParseNestedDeferredFunc(VAR_0, VAR_20, VAR_6, &VAR_86);
}
}
if (VAR_84)
{
FinishParseBlock(VAR_84, *VAR_6);
}
if (!VAR_24 && (VAR_99.tk == VAR_111 || !VAR_20))
{
this->AddArgumentsNodeToVars(VAR_0);
}
Assert(VAR_57 == nullptr || *VAR_57 == nullptr);
VAR_57 = VAR_80;
AssertMem(VAR_81);
Assert(nullptr == *VAR_81);
VAR_81 = VAR_79;
if (VAR_77)
{
FinishParseBlock(VAR_77, *VAR_6);
}
if (IsStrictMode() || VAR_86)
{
this->m_fUseStrictMode = TRUE; 
if (!VAR_51)
{
RestorePoint VAR_113;
VAR_32->Capture(&VAR_113);
if (*VAR_3)
{
VAR_32->SeekTo(VAR_31);
VAR_32->Scan();
if (VAR_0->sxFnc.IsGenerator())
{
Assert(VAR_99.tk == VAR_114);
Assert(VAR_41->GetConfig()->IsES6GeneratorsEnabled());
Assert(!(VAR_2 & VAR_115));
VAR_32->Scan();
}
if (VAR_99.IsReservedWord())
{
IdentifierExpectedError(VAR_99);
}
CheckStrictModeEvalArgumentsUsage(VAR_99.GetIdentifier(VAR_116));
}
VAR_32->SeekToForcingPid(VAR_50);
CheckStrictFormalParameters();
VAR_32->SeekTo(VAR_113);
}
if (buildAST)
{
if (VAR_0->sxFnc.pnodeName != nullptr && VAR_117 == VAR_0->sxFnc.pnodeName->nop)
{
CheckStrictModeEvalArgumentsUsage(VAR_0->sxFnc.pnodeName->sxVar.pid, VAR_0->sxFnc.pnodeName);
}
}
this->m_fUseStrictMode = VAR_52;
CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(VAR_118, VAR_41);
}
if (VAR_26)
{
AnalysisAssert(VAR_0);
VAR_0->sxFnc.pnodeVars = nullptr;
}
if (VAR_66)
{
VAR_0 = VAR_76;
VAR_11 = VAR_76;
VAR_0->ichLim = VAR_32->IchLimTok();
VAR_0->sxFnc.cbLim = VAR_32->IecpLimTok();
}
}
AnalysisAssert(VAR_0);
if (VAR_0->sxFnc.GetAsmjsMode())
{
VAR_70 = false;
}
Assert(nullptr == VAR_46);
SetCurrentStatement(VAR_27);
if (VAR_33)
{
FinishParseFncExprScope(VAR_0, VAR_33);
}
if (!VAR_119)
{
VAR_55 |= VAR_54;
}
VAR_120 = VAR_59;
VAR_32->SetYieldIsKeyword(VAR_38);
VAR_32->SetAwaitIsKeyword(VAR_39);
if (buildAST)
{
Assert(VAR_0 == VAR_11);
VAR_11 = VAR_9;
VAR_17 = VAR_16;
if (!VAR_20)
{
Assert(VAR_0 == VAR_14);
VAR_14 = VAR_13;
}
}
else
{
Assert(VAR_0 == VAR_12);
if (!VAR_20)
{
Assert(VAR_0 == VAR_15);
VAR_15 = VAR_13;
}
VAR_12 = VAR_9;
}
if (VAR_11 && VAR_0->sxFnc.HasWithStmt())
{
GetCurrentFunctionNode()->sxFnc.SetHasWithStmt(true);
}
return true;
}",chakra-core/ChakraCore/9da019424601325a6e95e6be0fa03d7d21d0b517/Parse.cpp/vul/before/0.json,"bool Parser::ParseFncDeclHelper(ParseNodePtr pnodeFnc, LPCOLESTR pNameHint, ushort flags, bool *pHasName, bool fUnaryOrParen, bool noStmtContext, bool *pNeedScanRCurly, bool skipFormals)
{
    ParseNodePtr pnodeFncParent = GetCurrentFunctionNode();
    // is the following correct? When buildAST is false, m_currentNodeDeferredFunc can be nullptr on transition to deferred parse from non-deferred
    ParseNodePtr pnodeFncSave = buildAST ? m_currentNodeFunc : m_currentNodeDeferredFunc;
    ParseNodePtr pnodeFncSaveNonLambda = buildAST ? m_currentNodeNonLambdaFunc : m_currentNodeNonLambdaDeferredFunc;
    int32* pAstSizeSave = m_pCurrentAstSize;

    bool fDeclaration = (flags & fFncDeclaration) != 0;
    bool fLambda = (flags & fFncLambda) != 0;
    bool fAsync = (flags & fFncAsync) != 0;
    bool fModule = (flags & fFncModule) != 0;
    bool fDeferred = false;
    StmtNest *pstmtSave;
    ParseNodePtr *lastNodeRef = nullptr;
    bool fFunctionInBlock = false;
    if (buildAST)
    {
        fFunctionInBlock = GetCurrentBlockInfo() != GetCurrentFunctionBlockInfo() &&
            (GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope == nullptr ||
             GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope->GetScopeType() != ScopeType_GlobalEvalBlock);
    }

    // Save the position of the scanner in case we need to inspect the name hint later
    RestorePoint beginNameHint;
    m_pscan->Capture(&beginNameHint);

    ParseNodePtr pnodeFncExprScope = nullptr;    
    Scope *fncExprScope = nullptr;
    if (!fDeclaration)
    {
        pnodeFncExprScope = StartParseBlock<buildAST>(PnodeBlockType::Function, ScopeType_FuncExpr);
        fncExprScope = pnodeFncExprScope->sxBlock.scope;

        // Function expression: push the new function onto the stack now so that the name (if any) will be
        // local to the new function.

        this->UpdateCurrentNodeFunc<buildAST>(pnodeFnc, fLambda);
    }

    *pHasName = !fLambda && !fModule && this->ParseFncNames<buildAST>(pnodeFnc, pnodeFncSave, flags, &lastNodeRef);

    if (fDeclaration)
    {
        // Declaration statement: push the new function now, after parsing the name, so the name is local to the
        // enclosing function.

        this->UpdateCurrentNodeFunc<buildAST>(pnodeFnc, fLambda);
    }

    if (noStmtContext && pnodeFnc->sxFnc.IsGenerator())
    {
        // Generator decl not allowed outside stmt context. (We have to wait until we've parsed the '*' to
        // detect generator.)
        Error(ERRsyntax, pnodeFnc);
    }

    // switch scanner to treat 'yield' as keyword in generator functions
    // or as an identifier in non-generator functions
    bool fPreviousYieldIsKeyword = m_pscan->SetYieldIsKeyword(pnodeFnc && pnodeFnc->sxFnc.IsGenerator());

    bool fPreviousAwaitIsKeyword = m_pscan->SetAwaitIsKeyword(fAsync);

    if (pnodeFnc && pnodeFnc->sxFnc.IsGenerator())
    {
        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Generator, m_scriptContext);
    }

    if (fncExprScope && !*pHasName)
    {
        FinishParseBlock(pnodeFncExprScope);
        m_nextBlockId--;
        Adelete(&m_nodeAllocator, fncExprScope);
        fncExprScope = nullptr;
        pnodeFncExprScope = nullptr;
    }
    if (pnodeFnc)
    {
        pnodeFnc->sxFnc.scope = fncExprScope;
    }

    // Start a new statement stack.
    bool topLevelStmt =
        buildAST &&
        !fFunctionInBlock &&
        (this->m_pstmtCur == nullptr || this->m_pstmtCur->pnodeStmt->nop == knopBlock);

    pstmtSave = m_pstmtCur;
    SetCurrentStatement(nullptr);

    // Function definition is inside the parent function's parameter scope
    bool isEnclosedInParamScope = this->m_currentScope->GetScopeType() == ScopeType_Parameter;

    if (this->m_currentScope->GetScopeType() == ScopeType_FuncExpr || this->m_currentScope->GetScopeType() == ScopeType_Block)
    {
        // Or this is a function expression or class enclosed in a parameter scope
        isEnclosedInParamScope = this->m_currentScope->GetEnclosingScope() && this->m_currentScope->GetEnclosingScope()->GetScopeType() == ScopeType_Parameter;
    }

    Assert(!isEnclosedInParamScope || pnodeFncSave->sxFnc.HasNonSimpleParameterList());

    RestorePoint beginFormals;
    m_pscan->Capture(&beginFormals);
    BOOL fWasAlreadyStrictMode = IsStrictMode();
    BOOL oldStrictMode = this->m_fUseStrictMode;

    if (fLambda)
    {
        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(Lambda, m_scriptContext);
    }

    uint uDeferSave = m_grfscr & fscrDeferFncParse;
    if ((!fDeclaration && m_ppnodeExprScope) ||
        isEnclosedInParamScope ||
        (flags & (fFncNoName | fFncLambda)))
    {
        // NOTE: Don't defer if this is a function expression inside a construct that induces
        // a scope nested within the current function (like a with, or a catch in ES5 mode, or
        // any function declared inside a nested lexical block or param scope in ES6 mode).
        // We won't be able to reconstruct the scope chain properly when we come back and
        // try to compile just the function expression.
        // Also shut off deferring on getter/setter or other construct with unusual text bounds
        // (fFncNoName|fFncLambda) as these are usually trivial, and re-parsing is problematic.
        m_grfscr &= ~fscrDeferFncParse;
    }

    bool saveInFIB = this->m_inFIB;
    this->m_inFIB = fFunctionInBlock || this->m_inFIB;

    bool isTopLevelDeferredFunc = false;

    struct AutoFastScanFlag {
        bool savedDoingFastScan;
        AutoFastScanFlag(Parser *parser) : m_parser(parser) { savedDoingFastScan = m_parser->m_doingFastScan; }
        ~AutoFastScanFlag() { m_parser->m_doingFastScan = savedDoingFastScan; }
        Parser *m_parser;
    } flag(this);

    bool doParallel = false;
    bool parallelJobStarted = false;
    if (buildAST)
    {
        bool isLikelyIIFE = !fDeclaration && pnodeFnc && fUnaryOrParen;

        BOOL isDeferredFnc = IsDeferredFnc();
        AnalysisAssert(isDeferredFnc || pnodeFnc);
        // These are the conditions that prohibit upfront deferral *and* redeferral.
        isTopLevelDeferredFunc =
            (!fLambda
             && pnodeFnc
             && DeferredParse(pnodeFnc->sxFnc.functionId)
             && (!pnodeFnc->sxFnc.IsNested() || CONFIG_FLAG(DeferNested))
             && !m_InAsmMode
            // Don't defer a module function wrapper because we need to do export resolution at parse time
             && !fModule
            );

        if (pnodeFnc)
        {
            pnodeFnc->sxFnc.SetCanBeDeferred(isTopLevelDeferredFunc && PnFnc::CanBeRedeferred(pnodeFnc->sxFnc.fncFlags));
            pnodeFnc->sxFnc.SetFIBPreventsDeferral(false);
        }

        if (this->m_inFIB)
        {
            if (isTopLevelDeferredFunc)
            {
                // Block-scoping is the only non-heuristic reason for not deferring this function up front.
                // So on creating the full FunctionBody at byte code gen time, verify that there is no
                // block-scoped content visible to this function so it can remain a redeferral candidate.
                pnodeFnc->sxFnc.SetFIBPreventsDeferral(true);
            }
            isTopLevelDeferredFunc = false;
        }        

        // These are heuristic conditions that prohibit upfront deferral but not redeferral.
        isTopLevelDeferredFunc = isTopLevelDeferredFunc && !isDeferredFnc && 
            (!isLikelyIIFE || !topLevelStmt || PHASE_FORCE_RAW(Js::DeferParsePhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId));
;
        if (!fLambda &&
            !isDeferredFnc &&
            !isLikelyIIFE &&
            !this->IsBackgroundParser() &&
            !this->m_doingFastScan &&
            !(pnodeFncSave && m_currDeferredStub) &&
            !(this->m_parseType == ParseType_Deferred && this->m_functionBody && this->m_functionBody->GetScopeInfo() && !isTopLevelDeferredFunc))
        {
            doParallel = DoParallelParse(pnodeFnc);
#if ENABLE_BACKGROUND_PARSING
            if (doParallel)
            {
                BackgroundParser *bgp = m_scriptContext->GetBackgroundParser();
                Assert(bgp);
                if (bgp->HasFailedBackgroundParseItem())
                {
                    Error(ERRsyntax);
                }
                doParallel = bgp->ParseBackgroundItem(this, pnodeFnc, isTopLevelDeferredFunc);
                if (doParallel)
                {
                    parallelJobStarted = true;
                    this->m_hasParallelJob = true;
                    this->m_doingFastScan = true;
                    doParallel = FastScanFormalsAndBody();
                    if (doParallel)
                    {
                        // Let the foreground thread take care of marking the limit on the function node,
                        // because in some cases this function's caller will want to change that limit,
                        // so we don't want the background thread to try and touch it.
                        pnodeFnc->ichLim = m_pscan->IchLimTok();
                        pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();
                    }
                }
            }
#endif
        }
    }

    if (!doParallel)
    {
        // We don't want to, or couldn't, let the main thread scan past this function body, so parse
        // it for real.
        ParseNodePtr pnodeRealFnc = pnodeFnc;
        if (parallelJobStarted)
        {
            // We have to deal with a failure to fast-scan the function (due to syntax error? ""/""?) when
            // a background thread may already have begun to work on the job. Both threads can't be allowed to
            // operate on the same node.
            pnodeFnc = CreateDummyFuncNode(fDeclaration);
        }

        AnalysisAssert(pnodeFnc);
        ParseNodePtr pnodeBlock = StartParseBlock<buildAST>(PnodeBlockType::Parameter, ScopeType_Parameter);
        AnalysisAssert(pnodeBlock != nullptr);
        pnodeFnc->sxFnc.pnodeScopes = pnodeBlock;
        m_ppnodeVar = &pnodeFnc->sxFnc.pnodeParams;

        ParseNodePtr *ppnodeScopeSave = nullptr;
        ParseNodePtr *ppnodeExprScopeSave = nullptr;

        ppnodeScopeSave = m_ppnodeScope;
        if (pnodeBlock)
        {
            // This synthetic block scope will contain all the nested scopes.
            m_ppnodeScope = &pnodeBlock->sxBlock.pnodeScopes;
            pnodeBlock->sxBlock.pnodeStmt = pnodeFnc;
        }

        // Keep nested function declarations and expressions in the same list at function scope.
        // (Indicate this by nulling out the current function expressions list.)
        ppnodeExprScopeSave = m_ppnodeExprScope;
        m_ppnodeExprScope = nullptr;

        if (!skipFormals)
        {
            bool fLambdaParamsSave = m_reparsingLambdaParams;
            if (fLambda)
            {
                m_reparsingLambdaParams = true;
            }
            this->ParseFncFormals<buildAST>(pnodeFnc, pnodeFncParent, flags);
            m_reparsingLambdaParams = fLambdaParamsSave;
        }

        // Create function body scope
        ParseNodePtr pnodeInnerBlock = StartParseBlock<buildAST>(PnodeBlockType::Function, ScopeType_FunctionBody);
        // Set the parameter block's child to the function body block.
        // The pnodeFnc->sxFnc.pnodeScopes list is constructed in such a way that it includes all the scopes in this list.
        // For example if the param scope has one function and body scope has one function then the list will look like below,
        // param scope block -> function decl from param scope -> body socpe block -> function decl from body scope.
        *m_ppnodeScope = pnodeInnerBlock;
        pnodeFnc->sxFnc.pnodeBodyScope = pnodeInnerBlock;

        // This synthetic block scope will contain all the nested scopes.
        m_ppnodeScope = &pnodeInnerBlock->sxBlock.pnodeScopes;
        pnodeInnerBlock->sxBlock.pnodeStmt = pnodeFnc;

        // DEFER: Begin deferral here (after names are parsed and name nodes created).
        // Create no more AST nodes until we're done.

        // Try to defer this func if all these are true:
        //  0. We are not already in deferred parsing (i.e. buildAST is true)
        //  1. We are not re-parsing a deferred func which is being invoked.
        //  2. Dynamic profile suggests this func can be deferred (and deferred parse is on).
        //  3. This func is top level or defer nested func is on.
        //  4. Optionally, the function is non-nested and not in eval, or the deferral decision was based on cached profile info,
        //     or the function is sufficiently long. (I.e., don't defer little nested functions unless we're
        //     confident they'll never be executed, because un-deferring nested functions is more expensive.)
        //     NOTE: I'm disabling #4 by default, because we've found other ways to reduce the cost of un-deferral,
        //           and we don't want to create function bodies aggressively for little functions.

        // We will also temporarily defer all asm.js functions, except for the asm.js
        // module itself, which we will never defer
        bool strictModeTurnedOn = false;

        if (isTopLevelDeferredFunc &&
            !(this->m_grfscr & fscrEvalCode) &&
            pnodeFnc->sxFnc.IsNested() &&
#ifndef DISABLE_DYNAMIC_PROFILE_DEFER_PARSE
            m_sourceContextInfo->sourceDynamicProfileManager == nullptr &&
#endif
            PHASE_ON_RAW(Js::ScanAheadPhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId) &&
            (
                !PHASE_FORCE_RAW(Js::DeferParsePhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId) ||
                PHASE_FORCE_RAW(Js::ScanAheadPhase, m_sourceContextInfo->sourceContextId, pnodeFnc->sxFnc.functionId)
            ))
        {
            // Try to scan ahead to the end of the function. If we get there before we've scanned a minimum
            // number of tokens, don't bother deferring, because it's too small.
            if (this->ScanAheadToFunctionEnd(CONFIG_FLAG(MinDeferredFuncTokenCount)))
            {
                isTopLevelDeferredFunc = false;
            }
        }

        Scope* paramScope = pnodeFnc->sxFnc.pnodeScopes ? pnodeFnc->sxFnc.pnodeScopes->sxBlock.scope : nullptr;
        if (paramScope != nullptr)
        {
            if (CONFIG_FLAG(ForceSplitScope))
            {
                paramScope->SetCannotMergeWithBodyScope();
            }
            else if (pnodeFnc->sxFnc.HasNonSimpleParameterList())
            {
                if (paramScope->GetCanMergeWithBodyScope())
                {
                    paramScope->ForEachSymbolUntil([this, paramScope, pnodeFnc](Symbol* sym) {
                        if (sym->GetPid()->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)
                        {
                            // One of the symbol has non local reference. Mark the param scope as we can't merge it with body scope.
                            paramScope->SetCannotMergeWithBodyScope();
                            return true;
                        }
                        return false;
                    });

                    if (wellKnownPropertyPids.arguments->GetTopRef() && wellKnownPropertyPids.arguments->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)
                    {
                        Assert(pnodeFnc->sxFnc.UsesArguments());
                        // Arguments symbol is captured in the param scope
                        paramScope->SetCannotMergeWithBodyScope();
                    }
                }
                if (paramScope->GetCanMergeWithBodyScope() && !fDeclaration && pnodeFnc->sxFnc.pnodeName != nullptr)
                {
                    Symbol* funcSym = pnodeFnc->sxFnc.pnodeName->sxVar.sym;
                    if (funcSym->GetPid()->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)
                    {
                        // This is a function expression with name captured in the param scope. In non-eval, non-split cases the function
                        // name symbol is added to the body scope to make it accessible in the body. But if there is a function or var
                        // declaration with the same name in the body then adding to the body will fail. So in this case we have to add
                        // the name symbol to the param scope by splitting it.
                        paramScope->SetCannotMergeWithBodyScope();
                    }
                }

            }
        }

        if (!fLambda && paramScope != nullptr && !paramScope->GetCanMergeWithBodyScope()
            && (pnodeFnc->sxFnc.UsesArguments() || pnodeFnc->grfpn & fpnArguments_overriddenByDecl))
        {
            Error(ERRNonSimpleParamListArgumentsUse);
        }

        // If the param scope is merged with the body scope we want to use the param scope symbols in the body scope.
        // So add a pid ref for the body using the param scope symbol. Note that in this case the same symbol will occur twice
        // in the same pid ref stack.
        if (paramScope != nullptr && paramScope->GetCanMergeWithBodyScope())
        {
            paramScope->ForEachSymbol([this](Symbol* paramSym)
            {
                PidRefStack* ref = PushPidRef(paramSym->GetPid());
                ref->SetSym(paramSym);
            });
        }

        if (isTopLevelDeferredFunc || (m_InAsmMode && m_deferAsmJs))
        {
            AssertMsg(!fLambda, ""Deferring function parsing of a function does not handle lambda syntax"");
            fDeferred = true;

            this->ParseTopLevelDeferredFunc(pnodeFnc, pnodeFncSave, pNameHint);
        }
        else
        {
            if (m_token.tk == tkRParen) // This might be false due to error recovery or lambda.
            {
                m_pscan->Scan();
            }

            if (fLambda)
            {
                BOOL hadNewLine = m_pscan->FHadNewLine();

                // it can be the case we do not have a fat arrow here if there is a valid expression on the left hand side
                // of the fat arrow, but that expression does not parse as a parameter list.  E.g.
                //    a.x => { }
                // Therefore check for it and error if not found.
                // LS Mode : since this is a lambda we supposed to get the fat arrow, if not we will skip till we get that fat arrow.
                ChkCurTok(tkDArrow, ERRnoDArrow);

                // Newline character between arrow parameters and fat arrow is a syntax error but we want to check for
                // this after verifying there was a => token. Otherwise we would throw the wrong error.
                if (hadNewLine)
                {
                    Error(ERRsyntax);
                }
            }

            AnalysisAssert(pnodeFnc);

            // Shouldn't be any temps in the arg list.
            Assert(*m_ppnodeVar == nullptr);

            // Start the var list.
            pnodeFnc->sxFnc.pnodeVars = nullptr;
            m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;

            if (paramScope != nullptr && !paramScope->GetCanMergeWithBodyScope())
            {
                OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(""The param and body scope of the function %s cannot be merged\n""), pnodeFnc->sxFnc.pnodeName ? pnodeFnc->sxFnc.pnodeName->sxVar.pid->Psz() : _u(""Anonymous function""));
                // Add a new symbol reference for each formal in the param scope to the body scope.
                // While inserting symbols into the symbol list we always insert at the front, so while traversing the list we will be visiting the last added
                // formals first. Normal insertion of those into the body will reverse the order of symbols, which will eventually result in different order
                // for scope slots allocation for the corresponding symbol in both param and body scope. Inserting them in the opposite order will help us
                // have the same sequence for scope slots allocation in both scopes. This makes it easy to read the bytecode and may help in some optimization
                // later.
                paramScope->ForEachSymbol([this, pnodeFnc](Symbol* param) {
                    OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(""Creating a duplicate symbol for the parameter %s in the body scope\n""), param->GetPid()->Psz());

                    ParseNodePtr paramNode = nullptr;
                    if (this->m_ppnodeVar != &pnodeFnc->sxFnc.pnodeVars)
                    {
                        ParseNodePtr *const ppnodeVarSave = m_ppnodeVar;
                        m_ppnodeVar = &pnodeFnc->sxFnc.pnodeVars;
                        paramNode = this->CreateVarDeclNode(param->GetPid(), STVariable, false, nullptr, false);
                        m_ppnodeVar = ppnodeVarSave;
                    }
                    else
                    {
                        paramNode = this->CreateVarDeclNode(param->GetPid(), STVariable, false, nullptr, false);
                    }

                    Assert(paramNode && paramNode->sxVar.sym->GetScope()->GetScopeType() == ScopeType_FunctionBody);
                    paramNode->sxVar.sym->SetHasInit(true);
                });

                if (!fLambda)
                {
                    // In split scope case ideally the arguments object should be in the param scope.
                    // Right now referring to arguments in the param scope is a SyntaxError, so we have to
                    // add a duplicate symbol in the body scope and copy over the value in BeginBodySope.
                    ParseNodePtr argumentsNode = this->CreateVarDeclNode(wellKnownPropertyPids.arguments, STVariable, true, nullptr, false);
                    Assert(argumentsNode && argumentsNode->sxVar.sym->GetScope()->GetScopeType() == ScopeType_FunctionBody);
                }
            }

            // Keep nested function declarations and expressions in the same list at function scope.
            // (Indicate this by nulling out the current function expressions list.)
            m_ppnodeExprScope = nullptr;

            if (buildAST)
            {
                DeferredFunctionStub *saveCurrentStub = m_currDeferredStub;
                if (isEnclosedInParamScope)
                {
                    // if the enclosed scope is the param scope we would not have created the deferred stub.
                    m_currDeferredStub = nullptr;
                }
                else if (pnodeFncSave && m_currDeferredStub)
                {
                    // the Deferred stub will not match for the function which are defined on lambda formals.
                    // Since this is not determined upfront that the current function is a part of outer function or part of lambda formal until we have seen the Arrow token.
                    // Due to that the current function may be fetching stubs from the outer function (outer of the lambda) - rather then the lambda function. The way to fix is to match
                    // the function start with the stub. Because they should match. We need to have previous sibling concept as the lambda formals can have more than one
                    // functions and we want to avoid getting wrong stub.

                    if (pnodeFncSave->sxFnc.nestedCount == 1)
                    {
                        m_prevSiblingDeferredStub = nullptr;
                    }

                    if (m_prevSiblingDeferredStub == nullptr)
                    {
                        m_prevSiblingDeferredStub = (m_currDeferredStub + (pnodeFncSave->sxFnc.nestedCount - 1));
                    }

                    if (m_prevSiblingDeferredStub->ichMin == pnodeFnc->ichMin)
                    {
                        m_currDeferredStub = m_prevSiblingDeferredStub->deferredStubs;
                        m_prevSiblingDeferredStub = nullptr;
                    }
                    else
                    {
                        m_currDeferredStub = nullptr;
                    }
                }

                if (m_token.tk != tkLCurly && fLambda)
                {
                    ParseExpressionLambdaBody<true>(pnodeFnc);
                    *pNeedScanRCurly = false;
                }
                else
                {
                    this->FinishFncDecl(pnodeFnc, pNameHint, lastNodeRef, skipFormals);
                }
                m_currDeferredStub = saveCurrentStub;
            }
            else
            {
                this->ParseNestedDeferredFunc(pnodeFnc, fLambda, pNeedScanRCurly, &strictModeTurnedOn);
            }
        }

        if (pnodeInnerBlock)
        {
            FinishParseBlock(pnodeInnerBlock, *pNeedScanRCurly);
        }

        if (!fModule && (m_token.tk == tkLCurly || !fLambda))
        {
            this->AddArgumentsNodeToVars(pnodeFnc);
        }

        // Restore the lists of scopes that contain function expressions.

        Assert(m_ppnodeExprScope == nullptr || *m_ppnodeExprScope == nullptr);
        m_ppnodeExprScope = ppnodeExprScopeSave;

        AssertMem(m_ppnodeScope);
        Assert(nullptr == *m_ppnodeScope);
        m_ppnodeScope = ppnodeScopeSave;

        if (pnodeBlock)
        {
            FinishParseBlock(pnodeBlock, *pNeedScanRCurly);
        }

        if (IsStrictMode() || strictModeTurnedOn)
        {
            this->m_fUseStrictMode = TRUE; // Now we know this function is in strict mode

            if (!fWasAlreadyStrictMode)
            {
                // If this function turned on strict mode then we didn't check the formal
                // parameters or function name hint for future reserved word usage. So do that now.
                RestorePoint afterFnc;
                m_pscan->Capture(&afterFnc);

                if (*pHasName)
                {
                    // Rewind to the function name hint and check if the token is a reserved word.
                    m_pscan->SeekTo(beginNameHint);
                    m_pscan->Scan();
                    if (pnodeFnc->sxFnc.IsGenerator())
                    {
                        Assert(m_token.tk == tkStar);
                        Assert(m_scriptContext->GetConfig()->IsES6GeneratorsEnabled());
                        Assert(!(flags & fFncClassMember));
                        m_pscan->Scan();
                    }
                    if (m_token.IsReservedWord())
                    {
                        IdentifierExpectedError(m_token);
                    }
                    CheckStrictModeEvalArgumentsUsage(m_token.GetIdentifier(m_phtbl));
                }

                // Fast forward to formal parameter list, check for future reserved words,
                // then restore scanner as it was.
                m_pscan->SeekToForcingPid(beginFormals);
                CheckStrictFormalParameters();
                m_pscan->SeekTo(afterFnc);
            }

            if (buildAST)
            {
                if (pnodeFnc->sxFnc.pnodeName != nullptr && knopVarDecl == pnodeFnc->sxFnc.pnodeName->nop)
                {
                    CheckStrictModeEvalArgumentsUsage(pnodeFnc->sxFnc.pnodeName->sxVar.pid, pnodeFnc->sxFnc.pnodeName);
                }
            }

            this->m_fUseStrictMode = oldStrictMode;
            CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(StrictModeFunction, m_scriptContext);
        }

        if (fDeferred)
        {
            AnalysisAssert(pnodeFnc);
            pnodeFnc->sxFnc.pnodeVars = nullptr;
        }

        if (parallelJobStarted)
        {
            pnodeFnc = pnodeRealFnc;
            m_currentNodeFunc = pnodeRealFnc;

            // Let the foreground thread take care of marking the limit on the function node,
            // because in some cases this function's caller will want to change that limit,
            // so we don't want the background thread to try and touch it.
            pnodeFnc->ichLim = m_pscan->IchLimTok();
            pnodeFnc->sxFnc.cbLim = m_pscan->IecpLimTok();
        }
    }

    // after parsing asm.js module, we want to reset asm.js state before continuing
    AnalysisAssert(pnodeFnc);
    if (pnodeFnc->sxFnc.GetAsmjsMode())
    {
        m_InAsmMode = false;
    }

    // Restore the statement stack.
    Assert(nullptr == m_pstmtCur);
    SetCurrentStatement(pstmtSave);

    if (pnodeFncExprScope)
    {
        FinishParseFncExprScope(pnodeFnc, pnodeFncExprScope);
    }
    if (!m_stoppedDeferredParse)
    {
        m_grfscr |= uDeferSave;
    }
    m_inFIB = saveInFIB;

    m_pscan->SetYieldIsKeyword(fPreviousYieldIsKeyword);
    m_pscan->SetAwaitIsKeyword(fPreviousAwaitIsKeyword);

    // Restore the current function.
    if (buildAST)
    {
        Assert(pnodeFnc == m_currentNodeFunc);

        m_currentNodeFunc = pnodeFncSave;
        m_pCurrentAstSize = pAstSizeSave;

        if (!fLambda)
        {
            Assert(pnodeFnc == m_currentNodeNonLambdaFunc);
            m_currentNodeNonLambdaFunc = pnodeFncSaveNonLambda;
        }
    }
    else
    {
        Assert(pnodeFnc == m_currentNodeDeferredFunc);
        if (!fLambda)
        {
            Assert(pnodeFnc == m_currentNodeNonLambdaDeferredFunc);
            m_currentNodeNonLambdaDeferredFunc = pnodeFncSaveNonLambda;
        }
        m_currentNodeDeferredFunc = pnodeFncSave;
    }

    if (m_currentNodeFunc && pnodeFnc->sxFnc.HasWithStmt())
    {
        GetCurrentFunctionNode()->sxFnc.SetHasWithStmt(true);
    }

    return true;
}","bool Parser::ParseFncDeclHelper(ParseNodePtr VAR_0, LPCOLESTR VAR_1, ushort VAR_2, bool *VAR_3, bool VAR_4, bool VAR_5, bool *VAR_6, bool VAR_7)
{
    ParseNodePtr VAR_8 = GetCurrentFunctionNode();
    /* COMMENT_0 */
    ParseNodePtr VAR_9 = VAR_10 ? VAR_11 : VAR_12;
    ParseNodePtr VAR_13 = VAR_10 ? VAR_14 : VAR_15;
    int32* VAR_16 = VAR_17;

    bool VAR_18 = (VAR_2 & VAR_19) != 0;
    bool VAR_20 = (VAR_2 & VAR_21) != 0;
    bool VAR_22 = (VAR_2 & VAR_23) != 0;
    bool VAR_24 = (VAR_2 & VAR_25) != 0;
    bool VAR_26 = false;
    StmtNest *VAR_27;
    ParseNodePtr *VAR_28 = nullptr;
    bool VAR_29 = false;
    if (VAR_10)
    {
        VAR_29 = GetCurrentBlockInfo() != GetCurrentFunctionBlockInfo() &&
            (GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope == nullptr ||
             GetCurrentBlockInfo()->pnodeBlock->sxBlock.scope->GetScopeType() != VAR_30);
    }

    /* COMMENT_1 */
    RestorePoint VAR_31;
    VAR_32->Capture(&VAR_31);

    ParseNodePtr VAR_33 = nullptr;    
    Scope *VAR_34 = nullptr;
    if (!VAR_18)
    {
        VAR_33 = VAR_35<buildAST>(PnodeBlockType::Function, VAR_36);
        VAR_34 = VAR_33->sxBlock.scope;

        /* COMMENT_2 */
        /* COMMENT_3 */

        this->UpdateCurrentNodeFunc<buildAST>(VAR_0, VAR_20);
    }

    *VAR_3 = !VAR_20 && !VAR_24 && this->ParseFncNames<buildAST>(VAR_0, VAR_9, VAR_2, &VAR_28);

    if (VAR_18)
    {
        /* COMMENT_4 */
        /* COMMENT_5 */

        this->UpdateCurrentNodeFunc<buildAST>(VAR_0, VAR_20);
    }

    if (VAR_5 && VAR_0->sxFnc.IsGenerator())
    {
        /* COMMENT_6 */
        /* COMMENT_7 */
        Error(VAR_37, VAR_0);
    }

    /* COMMENT_8 */
    /* COMMENT_9 */
    bool VAR_38 = VAR_32->SetYieldIsKeyword(VAR_0 && VAR_0->sxFnc.IsGenerator());

    bool VAR_39 = VAR_32->SetAwaitIsKeyword(VAR_22);

    if (VAR_0 && VAR_0->sxFnc.IsGenerator())
    {
        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(VAR_40, VAR_41);
    }

    if (VAR_34 && !*VAR_3)
    {
        FinishParseBlock(VAR_33);
        VAR_42--;
        Adelete(&VAR_43, VAR_34);
        VAR_34 = nullptr;
        VAR_33 = nullptr;
    }
    if (VAR_0)
    {
        VAR_0->sxFnc.scope = VAR_34;
    }

    /* COMMENT_10 */
    bool VAR_44 =
        buildAST &&
        !VAR_29 &&
        (this->m_pstmtCur == nullptr || this->m_pstmtCur->pnodeStmt->nop == VAR_45);

    VAR_27 = VAR_46;
    SetCurrentStatement(nullptr);

    /* COMMENT_11 */
    bool VAR_47 = this->m_currentScope->GetScopeType() == VAR_48;

    if (this->m_currentScope->GetScopeType() == VAR_36 || this->m_currentScope->GetScopeType() == VAR_49)
    {
        /* COMMENT_12 */
        VAR_47 = this->m_currentScope->GetEnclosingScope() && this->m_currentScope->GetEnclosingScope()->GetScopeType() == VAR_48;
    }

    Assert(!VAR_47 || VAR_9->sxFnc.HasNonSimpleParameterList());

    RestorePoint VAR_50;
    VAR_32->Capture(&VAR_50);
    BOOL VAR_51 = IsStrictMode();
    BOOL VAR_52 = this->m_fUseStrictMode;

    if (VAR_20)
    {
        CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(VAR_53, VAR_41);
    }

    uint VAR_54 = VAR_55 & VAR_56;
    if ((!VAR_18 && VAR_57) ||
        VAR_47 ||
        (VAR_2 & (VAR_58 | VAR_21)))
    {
        /* COMMENT_13 */
        /* COMMENT_14 */
        /* COMMENT_15 */
        /* COMMENT_16 */
        /* COMMENT_17 */
        /* COMMENT_18 */
        /* COMMENT_19 */
        VAR_55 &= ~VAR_56;
    }

    bool VAR_59 = this->m_inFIB;
    this->m_inFIB = VAR_29 || this->m_inFIB;

    bool VAR_60 = false;

    struct AutoFastScanFlag {
        bool savedDoingFastScan;
        AutoFastScanFlag(Parser *VAR_61) : m_parser(VAR_61) { VAR_62 = VAR_63->m_doingFastScan; }
        ~AutoFastScanFlag() { VAR_63->m_doingFastScan = VAR_62; }
        Parser *m_parser;
    } VAR_64(this);

    bool VAR_65 = false;
    bool VAR_66 = false;
    if (buildAST)
    {
        bool VAR_67 = !VAR_18 && VAR_0 && VAR_4;

        BOOL VAR_68 = IsDeferredFnc();
        AnalysisAssert(VAR_68 || VAR_0);
        /* COMMENT_20 */
        VAR_60 =
            (!VAR_20
             && VAR_0
             && DeferredParse(VAR_0->sxFnc.functionId)
             && (!VAR_0->sxFnc.IsNested() || CONFIG_FLAG(VAR_69))
             && !VAR_70
            /* COMMENT_21 */
             && !VAR_24
            );

        if (VAR_0)
        {
            VAR_0->sxFnc.SetCanBeDeferred(VAR_60 && PnFnc::CanBeRedeferred(VAR_0->sxFnc.fncFlags));
            VAR_0->sxFnc.SetFIBPreventsDeferral(false);
        }

        if (this->m_inFIB)
        {
            if (VAR_60)
            {
                /* COMMENT_22 */
                /* COMMENT_23 */
                /* COMMENT_24 */
                VAR_0->sxFnc.SetFIBPreventsDeferral(true);
            }
            VAR_60 = false;
        }        

        /* COMMENT_25 */
        VAR_60 = VAR_60 && !VAR_68 && 
            (!VAR_67 || !VAR_44 || PHASE_FORCE_RAW(Js::DeferParsePhase, VAR_71->sourceContextId, VAR_0->sxFnc.functionId));
;
        if (!VAR_20 &&
            !VAR_68 &&
            !VAR_67 &&
            !this->IsBackgroundParser() &&
            !this->m_doingFastScan &&
            !(VAR_9 && VAR_72) &&
            !(this->m_parseType == VAR_73 && this->m_functionBody && this->m_functionBody->GetScopeInfo() && !VAR_60))
        {
            VAR_65 = DoParallelParse(VAR_0);
#if VAR_74
            if (VAR_65)
            {
                BackgroundParser *VAR_75 = VAR_41->GetBackgroundParser();
                Assert(VAR_75);
                if (VAR_75->HasFailedBackgroundParseItem())
                {
                    Error(VAR_37);
                }
                VAR_65 = VAR_75->ParseBackgroundItem(this, VAR_0, VAR_60);
                if (VAR_65)
                {
                    VAR_66 = true;
                    this->m_hasParallelJob = true;
                    this->m_doingFastScan = true;
                    VAR_65 = FastScanFormalsAndBody();
                    if (VAR_65)
                    {
                        /* COMMENT_26 */
                        /* COMMENT_27 */
                        /* COMMENT_28 */
                        VAR_0->ichLim = VAR_32->IchLimTok();
                        VAR_0->sxFnc.cbLim = VAR_32->IecpLimTok();
                    }
                }
            }
#endif
        }
    }

    if (!VAR_65)
    {
        /* COMMENT_29 */
        /* COMMENT_30 */
        ParseNodePtr VAR_76 = VAR_0;
        if (VAR_66)
        {
            /* COMMENT_31 */
            /* COMMENT_32 */
            /* COMMENT_33 */
            VAR_0 = CreateDummyFuncNode(VAR_18);
        }

        AnalysisAssert(VAR_0);
        ParseNodePtr VAR_77 = VAR_35<buildAST>(PnodeBlockType::Parameter, VAR_48);
        AnalysisAssert(VAR_77 != nullptr);
        VAR_0->sxFnc.pnodeScopes = VAR_77;
        VAR_78 = &VAR_0->sxFnc.pnodeParams;

        ParseNodePtr *VAR_79 = nullptr;
        ParseNodePtr *VAR_80 = nullptr;

        VAR_79 = VAR_81;
        if (VAR_77)
        {
            /* COMMENT_34 */
            VAR_81 = &VAR_77->sxBlock.pnodeScopes;
            VAR_77->sxBlock.pnodeStmt = VAR_0;
        }

        /* COMMENT_35 */
        /* COMMENT_36 */
        VAR_80 = VAR_57;
        VAR_57 = nullptr;

        if (!VAR_7)
        {
            bool VAR_82 = VAR_83;
            if (VAR_20)
            {
                VAR_83 = true;
            }
            this->ParseFncFormals<buildAST>(VAR_0, VAR_8, VAR_2);
            VAR_83 = VAR_82;
        }

        /* COMMENT_37 */
        ParseNodePtr VAR_84 = VAR_35<buildAST>(PnodeBlockType::Function, VAR_85);
        /* COMMENT_38 */
        /* COMMENT_39 */
        /* COMMENT_40 */
        /* COMMENT_41 */
        *VAR_81 = VAR_84;
        VAR_0->sxFnc.pnodeBodyScope = VAR_84;

        /* COMMENT_34 */
        VAR_81 = &VAR_84->sxBlock.pnodeScopes;
        VAR_84->sxBlock.pnodeStmt = VAR_0;

        /* COMMENT_42 */
        /* COMMENT_43 */

        /* COMMENT_44 */
        /* COMMENT_45 */
        /* COMMENT_46 */
        /* COMMENT_47 */
        /* COMMENT_48 */
        /* COMMENT_49 */
        /* COMMENT_50 */
        /* COMMENT_51 */
        /* COMMENT_52 */
        /* COMMENT_53 */

        /* COMMENT_54 */
        /* COMMENT_55 */
        bool VAR_86 = false;

        if (VAR_60 &&
            !(this->m_grfscr & VAR_87) &&
            VAR_0->sxFnc.IsNested() &&
#ifndef VAR_88
            VAR_71->sourceDynamicProfileManager == nullptr &&
#endif
            PHASE_ON_RAW(Js::ScanAheadPhase, VAR_71->sourceContextId, VAR_0->sxFnc.functionId) &&
            (
                !PHASE_FORCE_RAW(Js::DeferParsePhase, VAR_71->sourceContextId, VAR_0->sxFnc.functionId) ||
                PHASE_FORCE_RAW(Js::ScanAheadPhase, VAR_71->sourceContextId, VAR_0->sxFnc.functionId)
            ))
        {
            /* COMMENT_56 */
            /* COMMENT_57 */
            if (this->ScanAheadToFunctionEnd(CONFIG_FLAG(VAR_89)))
            {
                VAR_60 = false;
            }
        }

        Scope* VAR_90 = VAR_0->sxFnc.pnodeScopes ? VAR_0->sxFnc.pnodeScopes->sxBlock.scope : nullptr;
        if (VAR_90 != nullptr)
        {
            if (CONFIG_FLAG(VAR_91))
            {
                VAR_90->SetCannotMergeWithBodyScope();
            }
            else if (VAR_0->sxFnc.HasNonSimpleParameterList())
            {
                if (VAR_90->GetCanMergeWithBodyScope())
                {
                    VAR_90->ForEachSymbolUntil([this, VAR_90, VAR_0](Symbol* VAR_92) {
                        if (VAR_92->GetPid()->GetTopRef()->GetFuncScopeId() > VAR_0->sxFnc.functionId)
                        {
                            /* COMMENT_58 */
                            VAR_90->SetCannotMergeWithBodyScope();
                            return true;
                        }
                        return false;
                    });

                    if (VAR_93.arguments->GetTopRef() && VAR_93.arguments->GetTopRef()->GetFuncScopeId() > VAR_0->sxFnc.functionId)
                    {
                        Assert(VAR_0->sxFnc.UsesArguments());
                        /* COMMENT_59 */
                        VAR_90->SetCannotMergeWithBodyScope();
                    }
                }
                if (VAR_90->GetCanMergeWithBodyScope() && !VAR_18 && VAR_0->sxFnc.pnodeName != nullptr)
                {
                    Symbol* VAR_94 = VAR_0->sxFnc.pnodeName->sxVar.sym;
                    if (VAR_94->GetPid()->GetTopRef()->GetFuncScopeId() > VAR_0->sxFnc.functionId)
                    {
                        /* COMMENT_60 */
                        /* COMMENT_61 */
                        /* COMMENT_62 */
                        /* COMMENT_63 */
                        VAR_90->SetCannotMergeWithBodyScope();
                    }
                }

            }
        }

        if (!VAR_20 && VAR_90 != nullptr && !VAR_90->GetCanMergeWithBodyScope()
            && (VAR_0->sxFnc.UsesArguments() || VAR_0->grfpn & VAR_95))
        {
            Error(VAR_96);
        }

        /* COMMENT_64 */
        /* COMMENT_65 */
        /* COMMENT_66 */
        if (VAR_90 != nullptr && VAR_90->GetCanMergeWithBodyScope())
        {
            VAR_90->ForEachSymbol([this](Symbol* VAR_97)
            {
                PidRefStack* VAR_98 = PushPidRef(VAR_97->GetPid());
                VAR_98->SetSym(VAR_97);
            });
        }

        if (VAR_60 || (VAR_70 && VAR_99))
        {
            AssertMsg(!VAR_20, ""Deferring function parsing of a function does not handle lambda syntax"");
            VAR_26 = true;

            this->ParseTopLevelDeferredFunc(VAR_0, VAR_9, VAR_1);
        }
        else
        {
            if (VAR_100.tk == VAR_101) /* COMMENT_67 */
            {
                VAR_32->Scan();
            }

            if (VAR_20)
            {
                BOOL VAR_102 = VAR_32->FHadNewLine();

                /* COMMENT_68 */
                /* COMMENT_69 */
                /* COMMENT_70 */
                /* COMMENT_71 */
                /* COMMENT_72 */
                ChkCurTok(VAR_103, VAR_104);

                /* COMMENT_73 */
                /* COMMENT_74 */
                if (VAR_102)
                {
                    Error(VAR_37);
                }
            }

            AnalysisAssert(VAR_0);

            /* COMMENT_75 */
            Assert(*VAR_78 == nullptr);

            /* COMMENT_76 */
            VAR_0->sxFnc.pnodeVars = nullptr;
            VAR_78 = &VAR_0->sxFnc.pnodeVars;

            if (VAR_90 != nullptr && !VAR_90->GetCanMergeWithBodyScope())
            {
                OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(""The param and body scope of the function %s cannot be merged\n""), VAR_0->sxFnc.pnodeName ? VAR_0->sxFnc.pnodeName->sxVar.pid->Psz() : _u(""Anonymous function""));
                /* COMMENT_77 */
                /* COMMENT_78 */
                /* COMMENT_79 */
                /* COMMENT_80 */
                /* COMMENT_81 */
                /* COMMENT_82 */
                VAR_90->ForEachSymbol([this, VAR_0](Symbol* VAR_105) {
                    OUTPUT_TRACE_DEBUGONLY(Js::ParsePhase, _u(""Creating a duplicate symbol for the parameter %s in the body scope\n""), VAR_105->GetPid()->Psz());

                    ParseNodePtr VAR_106 = nullptr;
                    if (this->m_ppnodeVar != &VAR_0->sxFnc.pnodeVars)
                    {
                        ParseNodePtr *const VAR_107 = VAR_78;
                        VAR_78 = &VAR_0->sxFnc.pnodeVars;
                        VAR_106 = this->CreateVarDeclNode(VAR_105->GetPid(), VAR_108, false, nullptr, false);
                        VAR_78 = VAR_107;
                    }
                    else
                    {
                        VAR_106 = this->CreateVarDeclNode(VAR_105->GetPid(), VAR_108, false, nullptr, false);
                    }

                    Assert(VAR_106 && VAR_106->sxVar.sym->GetScope()->GetScopeType() == VAR_85);
                    VAR_106->sxVar.sym->SetHasInit(true);
                });

                if (!VAR_20)
                {
                    /* COMMENT_83 */
                    /* COMMENT_84 */
                    /* COMMENT_85 */
                    ParseNodePtr VAR_109 = this->CreateVarDeclNode(VAR_93.arguments, VAR_108, true, nullptr, false);
                    Assert(VAR_109 && VAR_109->sxVar.sym->GetScope()->GetScopeType() == VAR_85);
                }
            }

            /* COMMENT_35 */
            /* COMMENT_36 */
            VAR_57 = nullptr;

            if (buildAST)
            {
                DeferredFunctionStub *VAR_110 = VAR_72;
                if (VAR_47)
                {
                    /* COMMENT_86 */
                    VAR_72 = nullptr;
                }
                else if (VAR_9 && VAR_72)
                {
                    /* COMMENT_87 */
                    /* COMMENT_88 */
                    /* COMMENT_89 */
                    /* COMMENT_90 */
                    /* COMMENT_91 */

                    if (VAR_9->sxFnc.nestedCount == 1)
                    {
                        VAR_111 = nullptr;
                    }

                    if (VAR_111 == nullptr)
                    {
                        VAR_111 = (VAR_72 + (VAR_9->sxFnc.nestedCount - 1));
                    }

                    if (VAR_111->ichMin == VAR_0->ichMin)
                    {
                        VAR_72 = VAR_111->deferredStubs;
                        VAR_111 = nullptr;
                    }
                    else
                    {
                        VAR_72 = nullptr;
                    }
                }

                if (VAR_100.tk != VAR_112 && VAR_20)
                {
                    VAR_113<true>(VAR_0);
                    *VAR_6 = false;
                }
                else
                {
                    this->FinishFncDecl(VAR_0, VAR_1, VAR_28, VAR_7);
                }
                VAR_72 = VAR_110;
            }
            else
            {
                this->ParseNestedDeferredFunc(VAR_0, VAR_20, VAR_6, &VAR_86);
            }
        }

        if (VAR_84)
        {
            FinishParseBlock(VAR_84, *VAR_6);
        }

        if (!VAR_24 && (VAR_100.tk == VAR_112 || !VAR_20))
        {
            this->AddArgumentsNodeToVars(VAR_0);
        }

        /* COMMENT_92 */

        Assert(VAR_57 == nullptr || *VAR_57 == nullptr);
        VAR_57 = VAR_80;

        AssertMem(VAR_81);
        Assert(nullptr == *VAR_81);
        VAR_81 = VAR_79;

        if (VAR_77)
        {
            FinishParseBlock(VAR_77, *VAR_6);
        }

        if (IsStrictMode() || VAR_86)
        {
            this->m_fUseStrictMode = TRUE; /* COMMENT_93 */

            if (!VAR_51)
            {
                /* COMMENT_94 */
                /* COMMENT_95 */
                RestorePoint VAR_114;
                VAR_32->Capture(&VAR_114);

                if (*VAR_3)
                {
                    /* COMMENT_96 */
                    VAR_32->SeekTo(VAR_31);
                    VAR_32->Scan();
                    if (VAR_0->sxFnc.IsGenerator())
                    {
                        Assert(VAR_100.tk == VAR_115);
                        Assert(VAR_41->GetConfig()->IsES6GeneratorsEnabled());
                        Assert(!(VAR_2 & VAR_116));
                        VAR_32->Scan();
                    }
                    if (VAR_100.IsReservedWord())
                    {
                        IdentifierExpectedError(VAR_100);
                    }
                    CheckStrictModeEvalArgumentsUsage(VAR_100.GetIdentifier(VAR_117));
                }

                /* COMMENT_97 */
                /* COMMENT_98 */
                VAR_32->SeekToForcingPid(VAR_50);
                CheckStrictFormalParameters();
                VAR_32->SeekTo(VAR_114);
            }

            if (buildAST)
            {
                if (VAR_0->sxFnc.pnodeName != nullptr && VAR_118 == VAR_0->sxFnc.pnodeName->nop)
                {
                    CheckStrictModeEvalArgumentsUsage(VAR_0->sxFnc.pnodeName->sxVar.pid, VAR_0->sxFnc.pnodeName);
                }
            }

            this->m_fUseStrictMode = VAR_52;
            CHAKRATEL_LANGSTATS_INC_LANGFEATURECOUNT(VAR_119, VAR_41);
        }

        if (VAR_26)
        {
            AnalysisAssert(VAR_0);
            VAR_0->sxFnc.pnodeVars = nullptr;
        }

        if (VAR_66)
        {
            VAR_0 = VAR_76;
            VAR_11 = VAR_76;

            /* COMMENT_26 */
            /* COMMENT_27 */
            /* COMMENT_28 */
            VAR_0->ichLim = VAR_32->IchLimTok();
            VAR_0->sxFnc.cbLim = VAR_32->IecpLimTok();
        }
    }

    /* COMMENT_99 */
    AnalysisAssert(VAR_0);
    if (VAR_0->sxFnc.GetAsmjsMode())
    {
        VAR_70 = false;
    }

    /* COMMENT_100 */
    Assert(nullptr == VAR_46);
    SetCurrentStatement(VAR_27);

    if (VAR_33)
    {
        FinishParseFncExprScope(VAR_0, VAR_33);
    }
    if (!VAR_120)
    {
        VAR_55 |= VAR_54;
    }
    VAR_121 = VAR_59;

    VAR_32->SetYieldIsKeyword(VAR_38);
    VAR_32->SetAwaitIsKeyword(VAR_39);

    /* COMMENT_101 */
    if (buildAST)
    {
        Assert(VAR_0 == VAR_11);

        VAR_11 = VAR_9;
        VAR_17 = VAR_16;

        if (!VAR_20)
        {
            Assert(VAR_0 == VAR_14);
            VAR_14 = VAR_13;
        }
    }
    else
    {
        Assert(VAR_0 == VAR_12);
        if (!VAR_20)
        {
            Assert(VAR_0 == VAR_15);
            VAR_15 = VAR_13;
        }
        VAR_12 = VAR_9;
    }

    if (VAR_11 && VAR_0->sxFnc.HasWithStmt())
    {
        GetCurrentFunctionNode()->sxFnc.SetHasWithStmt(true);
    }

    return true;
}",chakra-core/ChakraCore/9da019424601325a6e95e6be0fa03d7d21d0b517/Parse.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -341,6 +341,19 @@
                         paramScope->SetCannotMergeWithBodyScope();
                     }
                 }
+                if (paramScope->GetCanMergeWithBodyScope() && !fDeclaration && pnodeFnc->sxFnc.pnodeName != nullptr)
+                {
+                    Symbol* funcSym = pnodeFnc->sxFnc.pnodeName->sxVar.sym;
+                    if (funcSym->GetPid()->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)
+                    {
+                        // This is a function expression with name captured in the param scope. In non-eval, non-split cases the function
+                        // name symbol is added to the body scope to make it accessible in the body. But if there is a function or var
+                        // declaration with the same name in the body then adding to the body will fail. So in this case we have to add
+                        // the name symbol to the param scope by splitting it.
+                        paramScope->SetCannotMergeWithBodyScope();
+                    }
+                }
+
             }
         }
 ","{'deleted_lines': [], 'added_lines': ['                if (paramScope->GetCanMergeWithBodyScope() && !fDeclaration && pnodeFnc->sxFnc.pnodeName != nullptr)', '                {', '                    Symbol* funcSym = pnodeFnc->sxFnc.pnodeName->sxVar.sym;', '                    if (funcSym->GetPid()->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)', '                    {', '                        // This is a function expression with name captured in the param scope. In non-eval, non-split cases the function', '                        // name symbol is added to the body scope to make it accessible in the body. But if there is a function or var', '                        // declaration with the same name in the body then adding to the body will fail. So in this case we have to add', '                        // the name symbol to the param scope by splitting it.', '                        paramScope->SetCannotMergeWithBodyScope();', '                    }', '                }', '']}",True,"A remote code execution vulnerability exists in the way affected Microsoft scripting engine render when handling objects in memory in Microsoft browsers. The vulnerability could corrupt memory in such a way that an attacker could execute arbitrary code in the context of the current user. An attacker who successfully exploited the vulnerability could gain the same user rights as the current user, aka ""Scripting Engine Memory Corruption Vulnerability.""",8.1,HIGH,2,test,2017-03-09T00:58:06Z,1
CVE-2017-0152,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,chakra-core/ChakraCore,"[CVE-2017-0152] MSFT: 10592731 : Issue with Function name capturing in param scope

In a function expression with name, where the name is captured in one
of the param scope functions, if there is a function or var declaration
with the same name as the function expression name we were marking the
function expression name as shadowed. In non-eval case this causes
issue because the name symbol won't get added to the body. This change is to
fix it in such a way if the name is captured in the param scope then we
split the param and body scope such that the name symbol is added to the
param scope not body scope.",9da019424601325a6e95e6be0fa03d7d21d0b517,https://github.com/chakra-core/ChakraCore/commit/9da019424601325a6e95e6be0fa03d7d21d0b517,lib/Runtime/ByteCode/ByteCodeEmitter.cpp,ByteCodeGenerator::EmitOneFunction,"void ByteCodeGenerator::EmitOneFunction(ParseNode *pnode)
{
Assert(pnode && (pnode->nop == knopProg || pnode->nop == knopFncDecl));
FuncInfo *funcInfo = pnode->sxFnc.funcInfo;
Assert(funcInfo != nullptr);
if (funcInfo->IsFakeGlobalFunction(this->flags))
{
return;
}
Js::ParseableFunctionInfo* deferParseFunction = funcInfo->byteCodeFunction;
deferParseFunction->SetGrfscr(deferParseFunction->GetGrfscr() | (this->flags & ~fscrDeferredFncExpression));
deferParseFunction->SetSourceInfo(this->GetCurrentSourceIndex(),
funcInfo->root,
!!(this->flags & fscrEvalCode),
((this->flags & fscrDynamicCode) && !(this->flags & fscrEvalCode)));
deferParseFunction->SetInParamsCount(funcInfo->inArgsCount);
if (pnode->sxFnc.HasDefaultArguments())
{
deferParseFunction->SetReportedInParamsCount(pnode->sxFnc.firstDefaultArg + 1);
}
else
{
deferParseFunction->SetReportedInParamsCount(funcInfo->inArgsCount);
}
if (funcInfo->root->sxFnc.pnodeBody == nullptr)
{
if (!PHASE_OFF1(Js::SkipNestedDeferredPhase))
{
deferParseFunction->BuildDeferredStubs(funcInfo->root);
}
Assert(!deferParseFunction->IsFunctionBody() || deferParseFunction->GetFunctionBody()->GetByteCode() != nullptr);
return;
}
Js::FunctionBody* byteCodeFunction = funcInfo->GetParsedFunctionBody();
byteCodeFunction->SetDeferredStubs(nullptr);
try
{
if (!funcInfo->IsGlobalFunction())
{
if (CanStackNestedFunc(funcInfo, true) && byteCodeFunction->GetCompileCount() == 0)
{
#if DBG
byteCodeFunction->SetCanDoStackNestedFunc();
#endif
if (funcInfo->root->sxFnc.astSize <= PnFnc::MaxStackClosureAST)
{
byteCodeFunction->SetStackNestedFunc(true);
}
}
}
if (byteCodeFunction->DoStackNestedFunc())
{
uint nestedCount = byteCodeFunction->GetNestedCount();
for (uint i = 0; i < nestedCount; i++)
{
Js::FunctionProxy * nested = byteCodeFunction->GetNestedFunctionProxy(i);
if (nested->IsFunctionBody())
{
nested->GetFunctionBody()->SetStackNestedFuncParent(byteCodeFunction->GetFunctionInfo());
}
}
}
if (byteCodeFunction->GetByteCode() != nullptr)
{
return;
}
if (funcInfo->root->sxFnc.HasOnlyThisStmts() && !IsInDebugMode())
{
byteCodeFunction->SetHasOnlyThisStmts(true);
}
if (byteCodeFunction->IsInlineApplyDisabled() || this->scriptContext->GetConfig()->IsNoNative())
{
if ((pnode->nop == knopFncDecl) && (funcInfo->GetHasHeapArguments()) && (!funcInfo->GetCallsEval()) && ApplyEnclosesArgs(pnode, this))
{
bool applyEnclosesArgs = true;
for (ParseNode* pnodeVar = funcInfo->root->sxFnc.pnodeVars; pnodeVar; pnodeVar = pnodeVar->sxVar.pnodeNext)
{
Symbol* sym = pnodeVar->sxVar.sym;
if (sym->GetSymbolType() == STVariable && !sym->GetIsArguments())
{
applyEnclosesArgs = false;
break;
}
}
auto constAndLetCheck = [](ParseNode *pnodeBlock, bool *applyEnclosesArgs)
{
if (*applyEnclosesArgs)
{
for (auto lexvar = pnodeBlock->sxBlock.pnodeLexVars; lexvar; lexvar = lexvar->sxVar.pnodeNext)
{
Symbol* sym = lexvar->sxVar.sym;
if (sym->GetSymbolType() == STVariable && !sym->GetIsArguments())
{
*applyEnclosesArgs = false;
break;
}
}
}
};
constAndLetCheck(funcInfo->root->sxFnc.pnodeScopes, &applyEnclosesArgs);
constAndLetCheck(funcInfo->root->sxFnc.pnodeBodyScope, &applyEnclosesArgs);
funcInfo->SetApplyEnclosesArgs(applyEnclosesArgs);
}
}
InitScopeSlotArray(funcInfo);
FinalizeRegisters(funcInfo, byteCodeFunction);
DebugOnly(Js::RegSlot firstTmpReg = funcInfo->varRegsCount);
uint innerScopeCount = funcInfo->InnerScopeCount();
if (!this->IsInDebugMode())
{
byteCodeFunction->SetInnerScopeCount(innerScopeCount);
if (innerScopeCount)
{
funcInfo->SetFirstInnerScopeReg(funcInfo->AcquireTmpRegister());
for (uint i = 1; i < innerScopeCount; i++)
{
funcInfo->AcquireTmpRegister();
}
}
}
funcInfo->inlineCacheMap = Anew(alloc, FuncInfo::InlineCacheMap,
alloc,
funcInfo->RegCount()             );
funcInfo->rootObjectLoadInlineCacheMap = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,
alloc,
10);
funcInfo->rootObjectLoadMethodInlineCacheMap = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,
alloc,
10);
funcInfo->rootObjectStoreInlineCacheMap = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,
alloc,
10);
funcInfo->referencedPropertyIdToMapIndex = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,
alloc,
10);
byteCodeFunction->AllocateLiteralRegexArray();
m_callSiteId = 0;
m_writer.Begin(byteCodeFunction, alloc, this->DoJitLoopBodies(funcInfo), funcInfo->hasLoop, this->IsInDebugMode());
this->PushFuncInfo(_u(""EmitOneFunction""), funcInfo);
this->inPrologue = true;
if (funcInfo->IsClassConstructor())
{
m_writer.Empty(Js::OpCode::ChkNewCallFlag);
}
Scope* currentScope = funcInfo->GetCurrentChildScope();
Scope* paramScope = funcInfo->GetParamScope();
Scope* bodyScope = funcInfo->GetBodyScope();
LoadAllConstants(funcInfo);
HomeArguments(funcInfo);
if (!currentScope->GetCanMergeWithBodyScope())
{
byteCodeFunction->SetParamAndBodyScopeNotMerged();
PopScope();
Assert(this->GetCurrentScope() == paramScope);
}
if (funcInfo->root->sxFnc.pnodeRest != nullptr)
{
byteCodeFunction->SetHasRestParameter();
}
if (funcInfo->thisScopeSlot != Js::Constants::NoRegister && !(funcInfo->IsLambda() || (funcInfo->IsGlobalFunction() && this->flags & fscrEval)))
{
EmitInitCapturedThis(funcInfo, funcInfo->bodyScope);
}
if ((funcInfo->HasSuperReference() || (funcInfo->GetCallsEval() && (funcInfo->root->sxFnc.IsMethod() || funcInfo->root->sxFnc.IsConstructor())))
&& !((GetFlags() & fscrEval) && funcInfo->IsGlobalFunction()))
{
if (funcInfo->IsLambda())
{
Scope *scope;
Js::PropertyId envIndex = -1;
GetEnclosingNonLambdaScope(funcInfo, scope, envIndex);
FuncInfo* parent = scope->GetFunc();
if (!parent->IsGlobalFunction())
{
EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, parent->superScopeSlot, funcInfo->superRegister);
if (funcInfo->superCtorRegister != Js::Constants::NoRegister)
{
EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, parent->superCtorScopeSlot, funcInfo->superCtorRegister);
}
}
else if (!(GetFlags() & fscrEval))
{
m_writer.Reg1(Js::OpCode::LdUndef, funcInfo->superRegister);
}
}
else
{
m_writer.Reg1(Js::OpCode::LdHomeObj, funcInfo->superRegister);
if (funcInfo->superCtorRegister != Js::Constants::NoRegister)                 {
m_writer.Reg1(Js::OpCode::LdFuncObj, funcInfo->superCtorRegister);
}
if (!funcInfo->IsGlobalFunction())
{
if (bodyScope->GetIsObject() && bodyScope->GetLocation() != Js::Constants::NoRegister)
{
uint cacheId = funcInfo->FindOrAddInlineCacheId(bodyScope->GetLocation(), Js::PropertyIds::_superReferenceSymbol, false, true);
m_writer.ElementP(Js::OpCode::InitLocalFld, funcInfo->superRegister, cacheId);
if (funcInfo->superCtorRegister != Js::Constants::NoRegister)
{
cacheId = funcInfo->FindOrAddInlineCacheId(bodyScope->GetLocation(), Js::PropertyIds::_superCtorReferenceSymbol, false, true);
m_writer.ElementP(Js::OpCode::InitLocalFld, funcInfo->superCtorRegister, cacheId);
}
}
else if (funcInfo->superScopeSlot == Js::Constants::NoProperty || funcInfo->superCtorScopeSlot == Js::Constants::NoProperty)
{
byteCodeFunction->InsertSymbolToRegSlotList(funcInfo->superRegister, Js::PropertyIds::_superReferenceSymbol, funcInfo->varRegsCount);
if (funcInfo->superCtorRegister != Js::Constants::NoRegister)
{
byteCodeFunction->InsertSymbolToRegSlotList(funcInfo->superCtorRegister, Js::PropertyIds::_superCtorReferenceSymbol, funcInfo->varRegsCount);
}
}
}
}
}
if (funcInfo->newTargetScopeSlot != Js::Constants::NoRegister && !funcInfo->IsGlobalFunction())
{
EmitInitCapturedNewTarget(funcInfo, bodyScope);
}
if (!(GetFlags() & fscrEval) && !bodyScope->GetIsObject())
{
if (funcInfo->superScopeSlot != Js::Constants::NoRegister)
{
this->EmitInternalScopedSlotStore(funcInfo, funcInfo->superScopeSlot, funcInfo->superRegister);
}
if (funcInfo->superCtorScopeSlot != Js::Constants::NoRegister)
{
this->EmitInternalScopedSlotStore(funcInfo, funcInfo->superCtorScopeSlot, funcInfo->superCtorRegister);
}
}
if (funcInfo->IsGlobalFunction())
{
EnsureNoRedeclarations(pnode->sxFnc.pnodeScopes, funcInfo);
}
::BeginEmitBlock(pnode->sxFnc.pnodeScopes, this, funcInfo);
DefineLabels(funcInfo);
if (pnode->sxFnc.HasNonSimpleParameterList())
{
this->InitBlockScopedNonTemps(funcInfo->root->sxFnc.pnodeScopes, funcInfo);
EmitDefaultArgs(funcInfo, pnode);
if (!currentScope->GetCanMergeWithBodyScope())
{
Assert(this->GetCurrentScope() == paramScope);
PushScope(bodyScope);
funcInfo->SetCurrentChildScope(bodyScope);
this->Writer()->Empty(Js::OpCode::BeginBodyScope);
}
}
InitSpecialScopeSlots(funcInfo);
if (!(funcInfo->IsGlobalFunction() && this->IsEvalWithNoParentScopeInfo()))
{
DefineFunctions(funcInfo);
}
DefineUserVars(funcInfo);
if (pnode->sxFnc.HasNonSimpleParameterList())
{
this->InitBlockScopedNonTemps(funcInfo->root->sxFnc.pnodeBodyScope, funcInfo);
}
else
{
this->InitBlockScopedNonTemps(funcInfo->root->sxFnc.pnodeScopes, funcInfo);
}
if (!pnode->sxFnc.HasNonSimpleParameterList() && funcInfo->GetHasArguments() && !NeedScopeObjectForArguments(funcInfo, pnode))
{
MapFormalsWithoutRest(pnode, [&](ParseNode *pnodeArg) { EmitPropStore(pnodeArg->sxVar.sym->GetLocation(), pnodeArg->sxVar.sym, pnodeArg->sxVar.pid, funcInfo); });
}
if (pnode->sxFnc.pnodeRest != nullptr)
{
pnode->sxFnc.pnodeRest->sxVar.sym->SetNeedDeclaration(false);
}
if (paramScope && !paramScope->GetCanMergeWithBodyScope())
{
paramScope->ForEachSymbol([&](Symbol* param) {
Symbol* varSym = funcInfo->GetBodyScope()->FindLocalSymbol(param->GetName());
Assert(varSym || pnode->sxFnc.pnodeName->sxVar.sym == param);
Assert(param->GetIsArguments() || param->IsInSlot(funcInfo));
if (param->GetIsArguments() && !funcInfo->GetHasArguments())
{
}
else if (varSym && varSym->GetSymbolType() == STVariable && (varSym->IsInSlot(funcInfo) || varSym->GetLocation() != Js::Constants::NoRegister))
{
Js::RegSlot tempReg = funcInfo->AcquireTmpRegister();
Js::PropertyId slot = param->EnsureScopeSlot(funcInfo);
Js::ProfileId profileId = funcInfo->FindOrAddSlotProfileId(paramScope, slot);
Js::OpCode op = paramScope->GetIsObject() ? Js::OpCode::LdParamObjSlot : Js::OpCode::LdParamSlot;
slot = slot + (paramScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);
this->m_writer.SlotI1(op, tempReg, slot, profileId);
if (ShouldTrackDebuggerMetadata() && !varSym->GetIsArguments() && !varSym->IsInSlot(funcInfo))
{
byteCodeFunction->InsertSymbolToRegSlotList(varSym->GetName(), varSym->GetLocation(), funcInfo->varRegsCount);
}
this->EmitPropStore(tempReg, varSym, varSym->GetPid(), funcInfo);
funcInfo->ReleaseTmpRegister(tempReg);
}
});
auto copySpecialSymbolsToBody = [this, funcInfo, paramScope] (Js::PropertyId src, Js::PropertyId dest)
{
if (dest != Js::Constants::NoProperty)
{
Js::RegSlot tempReg = funcInfo->AcquireTmpRegister();
Js::PropertyId slot = src;
Js::ProfileId profileId = funcInfo->FindOrAddSlotProfileId(paramScope, slot);
Js::OpCode op = paramScope->GetIsObject() ? Js::OpCode::LdParamObjSlot : Js::OpCode::LdParamSlot;
slot = slot + (paramScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);
this->m_writer.SlotI1(op, tempReg, slot, profileId);
op = funcInfo->bodyScope->GetIsObject() ? Js::OpCode::StLocalObjSlot : Js::OpCode::StLocalSlot;
slot = dest + (funcInfo->bodyScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);
this->m_writer.SlotI1(op, tempReg, slot);
funcInfo->ReleaseTmpRegister(tempReg);
}
};
copySpecialSymbolsToBody(funcInfo->innerThisScopeSlot, funcInfo->thisScopeSlot);
copySpecialSymbolsToBody(funcInfo->innerSuperScopeSlot, funcInfo->superScopeSlot);
copySpecialSymbolsToBody(funcInfo->innerSuperCtorScopeSlot, funcInfo->superCtorScopeSlot);
copySpecialSymbolsToBody(funcInfo->innerNewTargetScopeSlot, funcInfo->newTargetScopeSlot);
}
if (pnode->sxFnc.pnodeBodyScope != nullptr)
{
::BeginEmitBlock(pnode->sxFnc.pnodeBodyScope, this, funcInfo);
}
this->inPrologue = false;
if (funcInfo->IsGlobalFunction())
{
EmitGlobalBody(funcInfo);
}
else
{
EmitFunctionBody(funcInfo);
}
if (pnode->sxFnc.pnodeBodyScope != nullptr)
{
::EndEmitBlock(pnode->sxFnc.pnodeBodyScope, this, funcInfo);
}
::EndEmitBlock(pnode->sxFnc.pnodeScopes, this, funcInfo);
if (!this->IsInDebugMode())
{
if (innerScopeCount)
{
Js::RegSlot tmpReg = funcInfo->FirstInnerScopeReg() + innerScopeCount - 1;
for (uint i = 0; i < innerScopeCount; i++)
{
funcInfo->ReleaseTmpRegister(tmpReg);
tmpReg--;
}
}
}
Assert(funcInfo->firstTmpReg == firstTmpReg);
Assert(funcInfo->curTmpReg == firstTmpReg);
Assert(byteCodeFunction->GetFirstTmpReg() == firstTmpReg + byteCodeFunction->GetConstantCount());
byteCodeFunction->CheckAndSetVarCount(funcInfo->varRegsCount);
byteCodeFunction->CheckAndSetOutParamMaxDepth(funcInfo->outArgsMaxDepth);
byteCodeFunction->SetForInLoopDepth(funcInfo->GetMaxForInLoopLevel());
UInt32Math::Add(funcInfo->varRegsCount, funcInfo->constRegsCount);
#if DBG_DUMP
if (PHASE_STATS1(Js::ByteCodePhase))
{
Output::Print(_u("" BCode: %-10d, Aux: %-10d, AuxC: %-10d Total: %-10d,  %s\n""),
m_writer.ByteCodeDataSize(),
m_writer.AuxiliaryDataSize(),
m_writer.AuxiliaryContextDataSize(),
m_writer.ByteCodeDataSize() + m_writer.AuxiliaryDataSize() + m_writer.AuxiliaryContextDataSize(),
funcInfo->name);
this->scriptContext->byteCodeDataSize += m_writer.ByteCodeDataSize();
this->scriptContext->byteCodeAuxiliaryDataSize += m_writer.AuxiliaryDataSize();
this->scriptContext->byteCodeAuxiliaryContextDataSize += m_writer.AuxiliaryContextDataSize();
}
#endif
this->MapCacheIdsToPropertyIds(funcInfo);
this->MapReferencedPropertyIds(funcInfo);
Assert(this->TopFuncInfo() == funcInfo);
PopFuncInfo(_u(""EmitOneFunction""));
m_writer.SetCallSiteCount(m_callSiteId);
#ifdef LOG_BYTECODE_AST_RATIO
m_writer.End(funcInfo->root->sxFnc.astSize, this->maxAstSize);
#else
m_writer.End();
#endif
}
catch (...)
{
byteCodeFunction->ResetByteCodeGenState();
m_writer.Reset();
throw;
}
#ifdef PERF_HINT
if (PHASE_TRACE1(Js::PerfHintPhase) && !byteCodeFunction->GetIsGlobalFunc())
{
if (byteCodeFunction->GetHasTry())
{
WritePerfHint(PerfHints::HasTryBlock_Verbose, byteCodeFunction);
}
if (funcInfo->GetCallsEval())
{
WritePerfHint(PerfHints::CallsEval_Verbose, byteCodeFunction);
}
else if (funcInfo->GetChildCallsEval())
{
WritePerfHint(PerfHints::ChildCallsEval, byteCodeFunction);
}
}
#endif
byteCodeFunction->SetInitialDefaultEntryPoint();
byteCodeFunction->SetCompileCount(UInt32Math::Add(byteCodeFunction->GetCompileCount(), 1));
#ifdef ENABLE_DEBUG_CONFIG_OPTIONS
if (byteCodeFunction->IsInDebugMode() != scriptContext->IsScriptContextInDebugMode())     {
if (m_utf8SourceInfo->GetIsLibraryCode())
{
Assert(!byteCodeFunction->IsInDebugMode());         }
else
{
Js::Throw::FatalInternalError();
}
}
#endif
#if DBG_DUMP
if (PHASE_DUMP(Js::ByteCodePhase, funcInfo->byteCodeFunction) && Js::Configuration::Global.flags.Verbose)
{
pnode->Dump();
}
if (this->Trace() || PHASE_DUMP(Js::ByteCodePhase, funcInfo->byteCodeFunction))
{
Js::ByteCodeDumper::Dump(byteCodeFunction);
}
if (PHASE_DUMP(Js::DebuggerScopePhase, funcInfo->byteCodeFunction))
{
byteCodeFunction->DumpScopes();
}
#endif
#if ENABLE_NATIVE_CODEGEN
if ((!PHASE_OFF(Js::BackEndPhase, funcInfo->byteCodeFunction))
&& !this->forceNoNative
&& !this->scriptContext->GetConfig()->IsNoNative())
{
GenerateFunction(this->scriptContext->GetNativeCodeGenerator(), byteCodeFunction);
}
#endif
}","void ByteCodeGenerator::EmitOneFunction(ParseNode *VAR_0)
{
Assert(VAR_0 && (VAR_0->nop == VAR_1 || VAR_0->nop == VAR_2));
FuncInfo *VAR_3 = VAR_0->sxFnc.funcInfo;
Assert(VAR_3 != nullptr);
if (VAR_3->IsFakeGlobalFunction(this->flags))
{
return;
}
Js::ParseableFunctionInfo* VAR_4 = VAR_3->byteCodeFunction;
VAR_4->SetGrfscr(VAR_4->GetGrfscr() | (this->flags & ~VAR_5));
VAR_4->SetSourceInfo(this->GetCurrentSourceIndex(),
VAR_3->root,
!!(this->flags & VAR_6),
((this->flags & VAR_7) && !(this->flags & VAR_6)));
VAR_4->SetInParamsCount(VAR_3->inArgsCount);
if (VAR_0->sxFnc.HasDefaultArguments())
{
VAR_4->SetReportedInParamsCount(VAR_0->sxFnc.firstDefaultArg + 1);
}
else
{
VAR_4->SetReportedInParamsCount(VAR_3->inArgsCount);
}
if (VAR_3->root->sxFnc.pnodeBody == nullptr)
{
if (!PHASE_OFF1(Js::SkipNestedDeferredPhase))
{
VAR_4->BuildDeferredStubs(VAR_3->root);
}
Assert(!VAR_4->IsFunctionBody() || VAR_4->GetFunctionBody()->GetByteCode() != nullptr);
return;
}
Js::FunctionBody* VAR_8 = VAR_3->GetParsedFunctionBody();
VAR_8->SetDeferredStubs(nullptr);
try
{
if (!VAR_3->IsGlobalFunction())
{
if (CanStackNestedFunc(VAR_3, true) && VAR_8->GetCompileCount() == 0)
{
#if VAR_9
VAR_8->SetCanDoStackNestedFunc();
#endif
if (VAR_3->root->sxFnc.astSize <= PnFnc::MaxStackClosureAST)
{
VAR_8->SetStackNestedFunc(true);
}
}
}
if (VAR_8->DoStackNestedFunc())
{
uint VAR_10 = VAR_8->GetNestedCount();
for (uint VAR_11 = 0; VAR_11 < VAR_10; VAR_11++)
{
Js::FunctionProxy * VAR_12 = VAR_8->GetNestedFunctionProxy(VAR_11);
if (VAR_12->IsFunctionBody())
{
VAR_12->GetFunctionBody()->SetStackNestedFuncParent(VAR_8->GetFunctionInfo());
}
}
}
if (VAR_8->GetByteCode() != nullptr)
{
return;
}
if (VAR_3->root->sxFnc.HasOnlyThisStmts() && !IsInDebugMode())
{
VAR_8->SetHasOnlyThisStmts(true);
}
if (VAR_8->IsInlineApplyDisabled() || this->scriptContext->GetConfig()->IsNoNative())
{
if ((VAR_0->nop == VAR_2) && (VAR_3->GetHasHeapArguments()) && (!VAR_3->GetCallsEval()) && ApplyEnclosesArgs(VAR_0, this))
{
bool VAR_13 = true;
for (ParseNode* VAR_14 = VAR_3->root->sxFnc.pnodeVars; VAR_14; VAR_14 = VAR_14->sxVar.pnodeNext)
{
Symbol* VAR_15 = VAR_14->sxVar.sym;
if (VAR_15->GetSymbolType() == VAR_16 && !VAR_15->GetIsArguments())
{
VAR_13 = false;
break;
}
}
auto VAR_17 = [](ParseNode *VAR_18, bool *VAR_13)
{
if (*VAR_13)
{
for (auto VAR_19 = VAR_18->sxBlock.pnodeLexVars; VAR_19; VAR_19 = VAR_19->sxVar.pnodeNext)
{
Symbol* VAR_15 = VAR_19->sxVar.sym;
if (VAR_15->GetSymbolType() == VAR_16 && !VAR_15->GetIsArguments())
{
*VAR_13 = false;
break;
}
}
}
};
VAR_17(VAR_3->root->sxFnc.pnodeScopes, &VAR_13);
VAR_17(VAR_3->root->sxFnc.pnodeBodyScope, &VAR_13);
VAR_3->SetApplyEnclosesArgs(VAR_13);
}
}
InitScopeSlotArray(VAR_3);
FinalizeRegisters(VAR_3, VAR_8);
DebugOnly(Js::RegSlot VAR_20 = VAR_3->varRegsCount);
uint VAR_21 = VAR_3->InnerScopeCount();
if (!this->IsInDebugMode())
{
VAR_8->SetInnerScopeCount(VAR_21);
if (VAR_21)
{
VAR_3->SetFirstInnerScopeReg(VAR_3->AcquireTmpRegister());
for (uint VAR_11 = 1; VAR_11 < VAR_21; VAR_11++)
{
VAR_3->AcquireTmpRegister();
}
}
}
VAR_3->inlineCacheMap = Anew(VAR_22, FuncInfo::InlineCacheMap,
VAR_22,
VAR_3->RegCount() 
);
VAR_3->rootObjectLoadInlineCacheMap = Anew(VAR_22, FuncInfo::RootObjectInlineCacheIdMap,
VAR_22,
10);
VAR_3->rootObjectLoadMethodInlineCacheMap = Anew(VAR_22, FuncInfo::RootObjectInlineCacheIdMap,
VAR_22,
10);
VAR_3->rootObjectStoreInlineCacheMap = Anew(VAR_22, FuncInfo::RootObjectInlineCacheIdMap,
VAR_22,
10);
VAR_3->referencedPropertyIdToMapIndex = Anew(VAR_22, FuncInfo::RootObjectInlineCacheIdMap,
VAR_22,
10);
VAR_8->AllocateLiteralRegexArray();
VAR_23 = 0;
VAR_24.Begin(VAR_8, VAR_22, this->DoJitLoopBodies(VAR_3), VAR_3->hasLoop, this->IsInDebugMode());
this->PushFuncInfo(_u(""EmitOneFunction""), VAR_3);
this->inPrologue = true;
if (VAR_3->IsClassConstructor())
{
VAR_24.Empty(Js::OpCode::ChkNewCallFlag);
}
Scope* VAR_25 = VAR_3->GetCurrentChildScope();
Scope* VAR_26 = VAR_3->GetParamScope();
Scope* VAR_27 = VAR_3->GetBodyScope();
LoadAllConstants(VAR_3);
HomeArguments(VAR_3);
if (!VAR_25->GetCanMergeWithBodyScope())
{
VAR_8->SetParamAndBodyScopeNotMerged();
PopScope();
Assert(this->GetCurrentScope() == VAR_26);
}
if (VAR_3->root->sxFnc.pnodeRest != nullptr)
{
VAR_8->SetHasRestParameter();
}
if (VAR_3->thisScopeSlot != Js::Constants::NoRegister && !(VAR_3->IsLambda() || (VAR_3->IsGlobalFunction() && this->flags & VAR_28)))
{
EmitInitCapturedThis(VAR_3, VAR_3->bodyScope);
}
if ((VAR_3->HasSuperReference() || (VAR_3->GetCallsEval() && (VAR_3->root->sxFnc.IsMethod() || VAR_3->root->sxFnc.IsConstructor())))
&& !((GetFlags() & VAR_28) && VAR_3->IsGlobalFunction()))
{
if (VAR_3->IsLambda())
{
Scope *VAR_29;
Js::PropertyId VAR_30 = -1;
GetEnclosingNonLambdaScope(VAR_3, VAR_29, VAR_30);
FuncInfo* VAR_31 = VAR_29->GetFunc();
if (!VAR_31->IsGlobalFunction())
{
EmitInternalScopedSlotLoad(VAR_3, VAR_29, VAR_30, VAR_31->superScopeSlot, VAR_3->superRegister);
if (VAR_3->superCtorRegister != Js::Constants::NoRegister)
{
EmitInternalScopedSlotLoad(VAR_3, VAR_29, VAR_30, VAR_31->superCtorScopeSlot, VAR_3->superCtorRegister);
}
}
else if (!(GetFlags() & VAR_28))
{
VAR_24.Reg1(Js::OpCode::LdUndef, VAR_3->superRegister);
}
}
else
{
VAR_24.Reg1(Js::OpCode::LdHomeObj, VAR_3->superRegister);
if (VAR_3->superCtorRegister != Js::Constants::NoRegister) 
{
VAR_24.Reg1(Js::OpCode::LdFuncObj, VAR_3->superCtorRegister);
}
if (!VAR_3->IsGlobalFunction())
{
if (VAR_27->GetIsObject() && VAR_27->GetLocation() != Js::Constants::NoRegister)
{
uint VAR_32 = VAR_3->FindOrAddInlineCacheId(VAR_27->GetLocation(), Js::PropertyIds::_superReferenceSymbol, false, true);
VAR_24.ElementP(Js::OpCode::InitLocalFld, VAR_3->superRegister, VAR_32);
if (VAR_3->superCtorRegister != Js::Constants::NoRegister)
{
VAR_32 = VAR_3->FindOrAddInlineCacheId(VAR_27->GetLocation(), Js::PropertyIds::_superCtorReferenceSymbol, false, true);
VAR_24.ElementP(Js::OpCode::InitLocalFld, VAR_3->superCtorRegister, VAR_32);
}
}
else if (VAR_3->superScopeSlot == Js::Constants::NoProperty || VAR_3->superCtorScopeSlot == Js::Constants::NoProperty)
{
VAR_8->InsertSymbolToRegSlotList(VAR_3->superRegister, Js::PropertyIds::_superReferenceSymbol, VAR_3->varRegsCount);
if (VAR_3->superCtorRegister != Js::Constants::NoRegister)
{
VAR_8->InsertSymbolToRegSlotList(VAR_3->superCtorRegister, Js::PropertyIds::_superCtorReferenceSymbol, VAR_3->varRegsCount);
}
}
}
}
}
if (VAR_3->newTargetScopeSlot != Js::Constants::NoRegister && !VAR_3->IsGlobalFunction())
{
EmitInitCapturedNewTarget(VAR_3, VAR_27);
}
if (!(GetFlags() & VAR_28) && !VAR_27->GetIsObject())
{
if (VAR_3->superScopeSlot != Js::Constants::NoRegister)
{
this->EmitInternalScopedSlotStore(VAR_3, VAR_3->superScopeSlot, VAR_3->superRegister);
}
if (VAR_3->superCtorScopeSlot != Js::Constants::NoRegister)
{
this->EmitInternalScopedSlotStore(VAR_3, VAR_3->superCtorScopeSlot, VAR_3->superCtorRegister);
}
}
if (VAR_3->IsGlobalFunction())
{
EnsureNoRedeclarations(VAR_0->sxFnc.pnodeScopes, VAR_3);
}
::BeginEmitBlock(VAR_0->sxFnc.pnodeScopes, this, VAR_3);
DefineLabels(VAR_3);
if (VAR_0->sxFnc.HasNonSimpleParameterList())
{
this->InitBlockScopedNonTemps(VAR_3->root->sxFnc.pnodeScopes, VAR_3);
EmitDefaultArgs(VAR_3, VAR_0);
if (!VAR_25->GetCanMergeWithBodyScope())
{
Assert(this->GetCurrentScope() == VAR_26);
PushScope(VAR_27);
VAR_3->SetCurrentChildScope(VAR_27);
this->Writer()->Empty(Js::OpCode::BeginBodyScope);
}
}
InitSpecialScopeSlots(VAR_3);
if (!(VAR_3->IsGlobalFunction() && this->IsEvalWithNoParentScopeInfo()))
{
DefineFunctions(VAR_3);
}
DefineUserVars(VAR_3);
if (VAR_0->sxFnc.HasNonSimpleParameterList())
{
this->InitBlockScopedNonTemps(VAR_3->root->sxFnc.pnodeBodyScope, VAR_3);
}
else
{
this->InitBlockScopedNonTemps(VAR_3->root->sxFnc.pnodeScopes, VAR_3);
}
if (!VAR_0->sxFnc.HasNonSimpleParameterList() && VAR_3->GetHasArguments() && !NeedScopeObjectForArguments(VAR_3, VAR_0))
{
MapFormalsWithoutRest(VAR_0, [&](ParseNode *VAR_33) { EmitPropStore(VAR_33->sxVar.sym->GetLocation(), VAR_33->sxVar.sym, VAR_33->sxVar.pid, VAR_3); });
}
if (VAR_0->sxFnc.pnodeRest != nullptr)
{
VAR_0->sxFnc.pnodeRest->sxVar.sym->SetNeedDeclaration(false);
}
if (VAR_26 && !VAR_26->GetCanMergeWithBodyScope())
{
VAR_26->ForEachSymbol([&](Symbol* VAR_34) {
Symbol* VAR_35 = VAR_3->GetBodyScope()->FindLocalSymbol(VAR_34->GetName());
Assert(VAR_35 || VAR_0->sxFnc.pnodeName->sxVar.sym == VAR_34);
Assert(VAR_34->GetIsArguments() || VAR_34->IsInSlot(VAR_3));
if (VAR_34->GetIsArguments() && !VAR_3->GetHasArguments())
{
}
else if (VAR_35 && VAR_35->GetSymbolType() == VAR_16 && (VAR_35->IsInSlot(VAR_3) || VAR_35->GetLocation() != Js::Constants::NoRegister))
{
Js::RegSlot VAR_36 = VAR_3->AcquireTmpRegister();
Js::PropertyId VAR_37 = VAR_34->EnsureScopeSlot(VAR_3);
Js::ProfileId VAR_38 = VAR_3->FindOrAddSlotProfileId(VAR_26, VAR_37);
Js::OpCode VAR_39 = VAR_26->GetIsObject() ? Js::OpCode::LdParamObjSlot : Js::OpCode::LdParamSlot;
VAR_37 = VAR_37 + (VAR_26->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);
this->m_writer.SlotI1(VAR_39, VAR_36, VAR_37, VAR_38);
if (ShouldTrackDebuggerMetadata() && !VAR_35->GetIsArguments() && !VAR_35->IsInSlot(VAR_3))
{
VAR_8->InsertSymbolToRegSlotList(VAR_35->GetName(), VAR_35->GetLocation(), VAR_3->varRegsCount);
}
this->EmitPropStore(VAR_36, VAR_35, VAR_35->GetPid(), VAR_3);
VAR_3->ReleaseTmpRegister(VAR_36);
}
});
auto VAR_40 = [this, VAR_3, VAR_26] (Js::PropertyId VAR_41, Js::PropertyId VAR_42)
{
if (VAR_42 != Js::Constants::NoProperty)
{
Js::RegSlot VAR_36 = VAR_3->AcquireTmpRegister();
Js::PropertyId VAR_37 = VAR_41;
Js::ProfileId VAR_38 = VAR_3->FindOrAddSlotProfileId(VAR_26, VAR_37);
Js::OpCode VAR_39 = VAR_26->GetIsObject() ? Js::OpCode::LdParamObjSlot : Js::OpCode::LdParamSlot;
VAR_37 = VAR_37 + (VAR_26->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);
this->m_writer.SlotI1(VAR_39, VAR_36, VAR_37, VAR_38);
VAR_39 = VAR_3->bodyScope->GetIsObject() ? Js::OpCode::StLocalObjSlot : Js::OpCode::StLocalSlot;
VAR_37 = VAR_42 + (VAR_3->bodyScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);
this->m_writer.SlotI1(VAR_39, VAR_36, VAR_37);
VAR_3->ReleaseTmpRegister(VAR_36);
}
};
VAR_40(VAR_3->innerThisScopeSlot, VAR_3->thisScopeSlot);
VAR_40(VAR_3->innerSuperScopeSlot, VAR_3->superScopeSlot);
VAR_40(VAR_3->innerSuperCtorScopeSlot, VAR_3->superCtorScopeSlot);
VAR_40(VAR_3->innerNewTargetScopeSlot, VAR_3->newTargetScopeSlot);
}
if (VAR_0->sxFnc.pnodeBodyScope != nullptr)
{
::BeginEmitBlock(VAR_0->sxFnc.pnodeBodyScope, this, VAR_3);
}
this->inPrologue = false;
if (VAR_3->IsGlobalFunction())
{
EmitGlobalBody(VAR_3);
}
else
{
EmitFunctionBody(VAR_3);
}
if (VAR_0->sxFnc.pnodeBodyScope != nullptr)
{
::EndEmitBlock(VAR_0->sxFnc.pnodeBodyScope, this, VAR_3);
}
::EndEmitBlock(VAR_0->sxFnc.pnodeScopes, this, VAR_3);
if (!this->IsInDebugMode())
{
if (VAR_21)
{
Js::RegSlot VAR_43 = VAR_3->FirstInnerScopeReg() + VAR_21 - 1;
for (uint VAR_11 = 0; VAR_11 < VAR_21; VAR_11++)
{
VAR_3->ReleaseTmpRegister(VAR_43);
VAR_43--;
}
}
}
Assert(VAR_3->firstTmpReg == VAR_20);
Assert(VAR_3->curTmpReg == VAR_20);
Assert(VAR_8->GetFirstTmpReg() == VAR_20 + VAR_8->GetConstantCount());
VAR_8->CheckAndSetVarCount(VAR_3->varRegsCount);
VAR_8->CheckAndSetOutParamMaxDepth(VAR_3->outArgsMaxDepth);
VAR_8->SetForInLoopDepth(VAR_3->GetMaxForInLoopLevel());
UInt32Math::Add(VAR_3->varRegsCount, VAR_3->constRegsCount);
#if VAR_44
if (PHASE_STATS1(Js::ByteCodePhase))
{
Output::Print(_u("" BCode: %-10d, Aux: %-10d, AuxC: %-10d Total: %-10d,  %s\n""),
VAR_24.ByteCodeDataSize(),
VAR_24.AuxiliaryDataSize(),
VAR_24.AuxiliaryContextDataSize(),
VAR_24.ByteCodeDataSize() + VAR_24.AuxiliaryDataSize() + VAR_24.AuxiliaryContextDataSize(),
VAR_3->name);
this->scriptContext->byteCodeDataSize += VAR_24.ByteCodeDataSize();
this->scriptContext->byteCodeAuxiliaryDataSize += VAR_24.AuxiliaryDataSize();
this->scriptContext->byteCodeAuxiliaryContextDataSize += VAR_24.AuxiliaryContextDataSize();
}
#endif
this->MapCacheIdsToPropertyIds(VAR_3);
this->MapReferencedPropertyIds(VAR_3);
Assert(this->TopFuncInfo() == VAR_3);
PopFuncInfo(_u(""EmitOneFunction""));
VAR_24.SetCallSiteCount(VAR_23);
#ifdef VAR_45
VAR_24.End(VAR_3->root->sxFnc.astSize, this->maxAstSize);
#else
VAR_24.End();
#endif
}
catch (...)
{
VAR_8->ResetByteCodeGenState();
VAR_24.Reset();
throw;
}
#ifdef VAR_46
if (PHASE_TRACE1(Js::PerfHintPhase) && !VAR_8->GetIsGlobalFunc())
{
if (VAR_8->GetHasTry())
{
WritePerfHint(PerfHints::HasTryBlock_Verbose, VAR_8);
}
if (VAR_3->GetCallsEval())
{
WritePerfHint(PerfHints::CallsEval_Verbose, VAR_8);
}
else if (VAR_3->GetChildCallsEval())
{
WritePerfHint(PerfHints::ChildCallsEval, VAR_8);
}
}
#endif
VAR_8->SetInitialDefaultEntryPoint();
VAR_8->SetCompileCount(UInt32Math::Add(VAR_8->GetCompileCount(), 1));
#ifdef VAR_47
if (VAR_8->IsInDebugMode() != VAR_48->IsScriptContextInDebugMode()) 
{
if (VAR_49->GetIsLibraryCode())
{
Assert(!VAR_8->IsInDebugMode()); 
}
else
{
Js::Throw::FatalInternalError();
}
}
#endif
#if VAR_44
if (PHASE_DUMP(Js::ByteCodePhase, VAR_3->byteCodeFunction) && Js::Configuration::Global.flags.Verbose)
{
VAR_0->Dump();
}
if (this->Trace() || PHASE_DUMP(Js::ByteCodePhase, VAR_3->byteCodeFunction))
{
Js::ByteCodeDumper::Dump(VAR_8);
}
if (PHASE_DUMP(Js::DebuggerScopePhase, VAR_3->byteCodeFunction))
{
VAR_8->DumpScopes();
}
#endif
#if VAR_50
if ((!PHASE_OFF(Js::BackEndPhase, VAR_3->byteCodeFunction))
&& !this->forceNoNative
&& !this->scriptContext->GetConfig()->IsNoNative())
{
GenerateFunction(this->scriptContext->GetNativeCodeGenerator(), VAR_8);
}
#endif
}",,"void ByteCodeGenerator::EmitOneFunction(ParseNode *pnode)
{
    Assert(pnode && (pnode->nop == knopProg || pnode->nop == knopFncDecl));
    FuncInfo *funcInfo = pnode->sxFnc.funcInfo;
    Assert(funcInfo != nullptr);

    if (funcInfo->IsFakeGlobalFunction(this->flags))
    {
        return;
    }

    Js::ParseableFunctionInfo* deferParseFunction = funcInfo->byteCodeFunction;
    deferParseFunction->SetGrfscr(deferParseFunction->GetGrfscr() | (this->flags & ~fscrDeferredFncExpression));
    deferParseFunction->SetSourceInfo(this->GetCurrentSourceIndex(),
        funcInfo->root,
        !!(this->flags & fscrEvalCode),
        ((this->flags & fscrDynamicCode) && !(this->flags & fscrEvalCode)));

    deferParseFunction->SetInParamsCount(funcInfo->inArgsCount);
    if (pnode->sxFnc.HasDefaultArguments())
    {
        deferParseFunction->SetReportedInParamsCount(pnode->sxFnc.firstDefaultArg + 1);
    }
    else
    {
        deferParseFunction->SetReportedInParamsCount(funcInfo->inArgsCount);
    }

    if (funcInfo->root->sxFnc.pnodeBody == nullptr)
    {
        if (!PHASE_OFF1(Js::SkipNestedDeferredPhase))
        {
            deferParseFunction->BuildDeferredStubs(funcInfo->root);
        }
        Assert(!deferParseFunction->IsFunctionBody() || deferParseFunction->GetFunctionBody()->GetByteCode() != nullptr);
        return;
    }

    Js::FunctionBody* byteCodeFunction = funcInfo->GetParsedFunctionBody();
    // We've now done a full parse of this function, so we no longer need to remember the extents
    // and attributes of the top-level nested functions. (The above code has run for all of those,
    // so they have pointers to the stub sub-trees they need.)
    byteCodeFunction->SetDeferredStubs(nullptr);

    try
    {
        if (!funcInfo->IsGlobalFunction())
        {
            // Note: Do not set the stack nested func flag if the function has been redeferred and recompiled.
            // In that case the flag already has the value we want.
            if (CanStackNestedFunc(funcInfo, true) && byteCodeFunction->GetCompileCount() == 0)
            {
#if DBG
                byteCodeFunction->SetCanDoStackNestedFunc();
#endif
                if (funcInfo->root->sxFnc.astSize <= PnFnc::MaxStackClosureAST)
                {
                    byteCodeFunction->SetStackNestedFunc(true);
                }
            }
        }

        if (byteCodeFunction->DoStackNestedFunc())
        {
            uint nestedCount = byteCodeFunction->GetNestedCount();
            for (uint i = 0; i < nestedCount; i++)
            {
                Js::FunctionProxy * nested = byteCodeFunction->GetNestedFunctionProxy(i);
                if (nested->IsFunctionBody())
                {
                    nested->GetFunctionBody()->SetStackNestedFuncParent(byteCodeFunction->GetFunctionInfo());
                }
            }
        }

        if (byteCodeFunction->GetByteCode() != nullptr)
        {
            // Previously compiled function nested within a re-deferred and re-compiled function.
            return;
        }

        // Bug : 301517
        // In the debug mode the hasOnlyThis optimization needs to be disabled, since user can break in this function
        // and do operation on 'this' and its property, which may not be defined yet.
        if (funcInfo->root->sxFnc.HasOnlyThisStmts() && !IsInDebugMode())
        {
            byteCodeFunction->SetHasOnlyThisStmts(true);
        }

        if (byteCodeFunction->IsInlineApplyDisabled() || this->scriptContext->GetConfig()->IsNoNative())
        {
            if ((pnode->nop == knopFncDecl) && (funcInfo->GetHasHeapArguments()) && (!funcInfo->GetCallsEval()) && ApplyEnclosesArgs(pnode, this))
            {
                bool applyEnclosesArgs = true;
                for (ParseNode* pnodeVar = funcInfo->root->sxFnc.pnodeVars; pnodeVar; pnodeVar = pnodeVar->sxVar.pnodeNext)
                {
                    Symbol* sym = pnodeVar->sxVar.sym;
                    if (sym->GetSymbolType() == STVariable && !sym->GetIsArguments())
                    {
                        applyEnclosesArgs = false;
                        break;
                    }
                }
                auto constAndLetCheck = [](ParseNode *pnodeBlock, bool *applyEnclosesArgs)
                {
                    if (*applyEnclosesArgs)
                    {
                        for (auto lexvar = pnodeBlock->sxBlock.pnodeLexVars; lexvar; lexvar = lexvar->sxVar.pnodeNext)
                        {
                            Symbol* sym = lexvar->sxVar.sym;
                            if (sym->GetSymbolType() == STVariable && !sym->GetIsArguments())
                            {
                                *applyEnclosesArgs = false;
                                break;
                            }
                        }
                    }
                };
                constAndLetCheck(funcInfo->root->sxFnc.pnodeScopes, &applyEnclosesArgs);
                constAndLetCheck(funcInfo->root->sxFnc.pnodeBodyScope, &applyEnclosesArgs);
                funcInfo->SetApplyEnclosesArgs(applyEnclosesArgs);
            }
        }

        InitScopeSlotArray(funcInfo);
        FinalizeRegisters(funcInfo, byteCodeFunction);
        DebugOnly(Js::RegSlot firstTmpReg = funcInfo->varRegsCount);

        // Reserve temp registers for the inner scopes. We prefer temps because the JIT will then renumber them
        // and see different lifetimes. (Note that debug mode requires permanent registers. See FinalizeRegisters.)
        uint innerScopeCount = funcInfo->InnerScopeCount();
        if (!this->IsInDebugMode())
        {
            byteCodeFunction->SetInnerScopeCount(innerScopeCount);
            if (innerScopeCount)
            {
                funcInfo->SetFirstInnerScopeReg(funcInfo->AcquireTmpRegister());
                for (uint i = 1; i < innerScopeCount; i++)
                {
                    funcInfo->AcquireTmpRegister();
                }
            }
        }

        funcInfo->inlineCacheMap = Anew(alloc, FuncInfo::InlineCacheMap,
            alloc,
            funcInfo->RegCount() // Pass the actual register count. // TODO: Check if we can reduce this count
            );
        funcInfo->rootObjectLoadInlineCacheMap = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,
            alloc,
            10);
        funcInfo->rootObjectLoadMethodInlineCacheMap = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,
            alloc,
            10);
        funcInfo->rootObjectStoreInlineCacheMap = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,
            alloc,
            10);
        funcInfo->referencedPropertyIdToMapIndex = Anew(alloc, FuncInfo::RootObjectInlineCacheIdMap,
            alloc,
            10);

        byteCodeFunction->AllocateLiteralRegexArray();
        m_callSiteId = 0;
        m_writer.Begin(byteCodeFunction, alloc, this->DoJitLoopBodies(funcInfo), funcInfo->hasLoop, this->IsInDebugMode());
        this->PushFuncInfo(_u(""EmitOneFunction""), funcInfo);

        this->inPrologue = true;

        // Class constructors do not have a [[call]] slot but we don't implement a generic way to express this.
        // What we do is emit a check for the new flag here. If we don't have CallFlags_New set, the opcode will throw.
        // We need to do this before emitting 'this' since the base class constructor will try to construct a new object.
        if (funcInfo->IsClassConstructor())
        {
            m_writer.Empty(Js::OpCode::ChkNewCallFlag);
        }

        Scope* currentScope = funcInfo->GetCurrentChildScope();
        Scope* paramScope = funcInfo->GetParamScope();
        Scope* bodyScope = funcInfo->GetBodyScope();

        // For now, emit all constant loads at top of function (should instead put in closest dominator of uses).
        LoadAllConstants(funcInfo);
        HomeArguments(funcInfo);

        if (!currentScope->GetCanMergeWithBodyScope())
        {
            byteCodeFunction->SetParamAndBodyScopeNotMerged();

            // Pop the body scope before emitting the default args
            PopScope();
            Assert(this->GetCurrentScope() == paramScope);
        }

        if (funcInfo->root->sxFnc.pnodeRest != nullptr)
        {
            byteCodeFunction->SetHasRestParameter();
        }

        if (funcInfo->thisScopeSlot != Js::Constants::NoRegister && !(funcInfo->IsLambda() || (funcInfo->IsGlobalFunction() && this->flags & fscrEval)))
        {
            EmitInitCapturedThis(funcInfo, funcInfo->bodyScope);
        }

        // Any function with a super reference or an eval call inside a method or a constructor needs to load super,
        if ((funcInfo->HasSuperReference() || (funcInfo->GetCallsEval() && (funcInfo->root->sxFnc.IsMethod() || funcInfo->root->sxFnc.IsConstructor())))
            // unless we are already inside the 'global' scope inside an eval (in which case 'ScopedLdHomeObj' is emitted at every 'super' reference).
            && !((GetFlags() & fscrEval) && funcInfo->IsGlobalFunction()))
        {
            if (funcInfo->IsLambda())
            {
                Scope *scope;
                Js::PropertyId envIndex = -1;
                GetEnclosingNonLambdaScope(funcInfo, scope, envIndex);

                FuncInfo* parent = scope->GetFunc();

                if (!parent->IsGlobalFunction())
                {
                    // lambda in non-global scope (eval and non-eval)
                    EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, parent->superScopeSlot, funcInfo->superRegister);
                    if (funcInfo->superCtorRegister != Js::Constants::NoRegister)
                    {
                        EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, parent->superCtorScopeSlot, funcInfo->superCtorRegister);
                    }
                }
                else if (!(GetFlags() & fscrEval))
                {
                    // lambda in non-eval global scope
                    m_writer.Reg1(Js::OpCode::LdUndef, funcInfo->superRegister);
                }
                // lambda in eval global scope: ScopedLdHomeObj will handle error throwing
            }
            else
            {
                m_writer.Reg1(Js::OpCode::LdHomeObj, funcInfo->superRegister);

                if (funcInfo->superCtorRegister != Js::Constants::NoRegister) // super() is allowed only in derived class constructors
                {
                    m_writer.Reg1(Js::OpCode::LdFuncObj, funcInfo->superCtorRegister);
                }

                if (!funcInfo->IsGlobalFunction())
                {
                    if (bodyScope->GetIsObject() && bodyScope->GetLocation() != Js::Constants::NoRegister)
                    {
                        // Stash the super reference in case something inside the eval or lambda references it.
                        uint cacheId = funcInfo->FindOrAddInlineCacheId(bodyScope->GetLocation(), Js::PropertyIds::_superReferenceSymbol, false, true);
                        m_writer.ElementP(Js::OpCode::InitLocalFld, funcInfo->superRegister, cacheId);
                        if (funcInfo->superCtorRegister != Js::Constants::NoRegister)
                        {
                            cacheId = funcInfo->FindOrAddInlineCacheId(bodyScope->GetLocation(), Js::PropertyIds::_superCtorReferenceSymbol, false, true);
                            m_writer.ElementP(Js::OpCode::InitLocalFld, funcInfo->superCtorRegister, cacheId);
                        }
                    }
                    else if (funcInfo->superScopeSlot == Js::Constants::NoProperty || funcInfo->superCtorScopeSlot == Js::Constants::NoProperty)
                    {
                        // While the diag locals walker will pick up super from scoped slots or an activation object,
                        // it will not pick it up when it is only in a register.
                        byteCodeFunction->InsertSymbolToRegSlotList(funcInfo->superRegister, Js::PropertyIds::_superReferenceSymbol, funcInfo->varRegsCount);
                        if (funcInfo->superCtorRegister != Js::Constants::NoRegister)
                        {
                            byteCodeFunction->InsertSymbolToRegSlotList(funcInfo->superCtorRegister, Js::PropertyIds::_superCtorReferenceSymbol, funcInfo->varRegsCount);
                        }
                    }
                }
            }
        }

        if (funcInfo->newTargetScopeSlot != Js::Constants::NoRegister && !funcInfo->IsGlobalFunction())
        {
            EmitInitCapturedNewTarget(funcInfo, bodyScope);
        }

        // We don't want to load super if we are already in an eval. ScopedLdHomeObj will take care of loading super in that case.
        if (!(GetFlags() & fscrEval) && !bodyScope->GetIsObject())
        {
            if (funcInfo->superScopeSlot != Js::Constants::NoRegister)
            {
                this->EmitInternalScopedSlotStore(funcInfo, funcInfo->superScopeSlot, funcInfo->superRegister);
            }

            if (funcInfo->superCtorScopeSlot != Js::Constants::NoRegister)
            {
                this->EmitInternalScopedSlotStore(funcInfo, funcInfo->superCtorScopeSlot, funcInfo->superCtorRegister);
            }
        }

        if (funcInfo->IsGlobalFunction())
        {
            EnsureNoRedeclarations(pnode->sxFnc.pnodeScopes, funcInfo);
        }

        ::BeginEmitBlock(pnode->sxFnc.pnodeScopes, this, funcInfo);

        DefineLabels(funcInfo);

        if (pnode->sxFnc.HasNonSimpleParameterList())
        {
            this->InitBlockScopedNonTemps(funcInfo->root->sxFnc.pnodeScopes, funcInfo);

            EmitDefaultArgs(funcInfo, pnode);

            if (!currentScope->GetCanMergeWithBodyScope())
            {
                Assert(this->GetCurrentScope() == paramScope);
                // Push the body scope
                PushScope(bodyScope);

                funcInfo->SetCurrentChildScope(bodyScope);

                // Mark the beginning of the body scope so that new scope slots can be created.
                this->Writer()->Empty(Js::OpCode::BeginBodyScope);
            }
        }

        InitSpecialScopeSlots(funcInfo);

        // Emit all scope-wide function definitions before emitting function bodies
        // so that calls may reference functions they precede lexically.
        // Note, global eval scope is a fake local scope and is handled as if it were
        // a lexical block instead of a true global scope, so do not define the functions
        // here. They will be defined during BeginEmitBlock.
        if (!(funcInfo->IsGlobalFunction() && this->IsEvalWithNoParentScopeInfo()))
        {
            // This only handles function declarations, which param scope cannot have any.
            DefineFunctions(funcInfo);
        }

        DefineUserVars(funcInfo);

        if (pnode->sxFnc.HasNonSimpleParameterList())
        {
            this->InitBlockScopedNonTemps(funcInfo->root->sxFnc.pnodeBodyScope, funcInfo);
        }
        else
        {
            this->InitBlockScopedNonTemps(funcInfo->root->sxFnc.pnodeScopes, funcInfo);
        }

        if (!pnode->sxFnc.HasNonSimpleParameterList() && funcInfo->GetHasArguments() && !NeedScopeObjectForArguments(funcInfo, pnode))
        {
            // If we didn't create a scope object and didn't have default args, we still need to transfer the formals to their slots.
            MapFormalsWithoutRest(pnode, [&](ParseNode *pnodeArg) { EmitPropStore(pnodeArg->sxVar.sym->GetLocation(), pnodeArg->sxVar.sym, pnodeArg->sxVar.pid, funcInfo); });
        }

        // Rest needs to trigger use before declaration until all default args have been processed.
        if (pnode->sxFnc.pnodeRest != nullptr)
        {
            pnode->sxFnc.pnodeRest->sxVar.sym->SetNeedDeclaration(false);
        }

        if (paramScope && !paramScope->GetCanMergeWithBodyScope())
        {
            // Emit bytecode to copy the initial values from param names to their corresponding body bindings.
            // We have to do this after the rest param is marked as false for need declaration.
            Symbol* funcSym = funcInfo->root->sxFnc.GetFuncSymbol();
            paramScope->ForEachSymbol([&](Symbol* param) {
                Symbol* varSym = funcInfo->GetBodyScope()->FindLocalSymbol(param->GetName());
                Assert(varSym || pnode->sxFnc.pnodeName->sxVar.sym == param);
                Assert(param->GetIsArguments() || param->IsInSlot(funcInfo));
                if (param->GetIsArguments() && !funcInfo->GetHasArguments())
                {
                    // Do not copy the arguments to the body if it is not used
                }
                else if ((funcSym == nullptr || funcSym != param)    // Do not copy the symbol over to body as the function expression symbol
                                                                     // is expected to stay inside the function expression scope
                    && (varSym && varSym->GetSymbolType() == STVariable && (varSym->IsInSlot(funcInfo) || varSym->GetLocation() != Js::Constants::NoRegister)))
                {
                    // Simulating EmitPropLoad here. We can't directly call the method as we have to use the param scope specifically.
                    // Walking the scope chain is not possible at this time.
                    Js::RegSlot tempReg = funcInfo->AcquireTmpRegister();
                    Js::PropertyId slot = param->EnsureScopeSlot(funcInfo);
                    Js::ProfileId profileId = funcInfo->FindOrAddSlotProfileId(paramScope, slot);
                    Js::OpCode op = paramScope->GetIsObject() ? Js::OpCode::LdParamObjSlot : Js::OpCode::LdParamSlot;
                    slot = slot + (paramScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);

                    this->m_writer.SlotI1(op, tempReg, slot, profileId);

                    if (ShouldTrackDebuggerMetadata() && !varSym->GetIsArguments() && !varSym->IsInSlot(funcInfo))
                    {
                        byteCodeFunction->InsertSymbolToRegSlotList(varSym->GetName(), varSym->GetLocation(), funcInfo->varRegsCount);
                    }

                    this->EmitPropStore(tempReg, varSym, varSym->GetPid(), funcInfo);
                    funcInfo->ReleaseTmpRegister(tempReg);
                }
            });

            // In split scope as the body has a separate closure we have to copy the value of this and other special slots
            // from param scope to the body scope
            auto copySpecialSymbolsToBody = [this, funcInfo, paramScope] (Js::PropertyId src, Js::PropertyId dest)
            {
                if (dest != Js::Constants::NoProperty)
                {
                    Js::RegSlot tempReg = funcInfo->AcquireTmpRegister();
                    Js::PropertyId slot = src;
                    Js::ProfileId profileId = funcInfo->FindOrAddSlotProfileId(paramScope, slot);
                    Js::OpCode op = paramScope->GetIsObject() ? Js::OpCode::LdParamObjSlot : Js::OpCode::LdParamSlot;
                    slot = slot + (paramScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);

                    this->m_writer.SlotI1(op, tempReg, slot, profileId);

                    op = funcInfo->bodyScope->GetIsObject() ? Js::OpCode::StLocalObjSlot : Js::OpCode::StLocalSlot;
                    slot = dest + (funcInfo->bodyScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);
                    this->m_writer.SlotI1(op, tempReg, slot);
                    funcInfo->ReleaseTmpRegister(tempReg);
                }
            };
            copySpecialSymbolsToBody(funcInfo->innerThisScopeSlot, funcInfo->thisScopeSlot);
            copySpecialSymbolsToBody(funcInfo->innerSuperScopeSlot, funcInfo->superScopeSlot);
            copySpecialSymbolsToBody(funcInfo->innerSuperCtorScopeSlot, funcInfo->superCtorScopeSlot);
            copySpecialSymbolsToBody(funcInfo->innerNewTargetScopeSlot, funcInfo->newTargetScopeSlot);
        }

        if (pnode->sxFnc.pnodeBodyScope != nullptr)
        {
            ::BeginEmitBlock(pnode->sxFnc.pnodeBodyScope, this, funcInfo);
        }

        this->inPrologue = false;

        if (funcInfo->IsGlobalFunction())
        {
            EmitGlobalBody(funcInfo);
        }
        else
        {
            EmitFunctionBody(funcInfo);
        }

        if (pnode->sxFnc.pnodeBodyScope != nullptr)
        {
            ::EndEmitBlock(pnode->sxFnc.pnodeBodyScope, this, funcInfo);
        }
        ::EndEmitBlock(pnode->sxFnc.pnodeScopes, this, funcInfo);

        if (!this->IsInDebugMode())
        {
            // Release the temp registers that we reserved for inner scopes above.
            if (innerScopeCount)
            {
                Js::RegSlot tmpReg = funcInfo->FirstInnerScopeReg() + innerScopeCount - 1;
                for (uint i = 0; i < innerScopeCount; i++)
                {
                    funcInfo->ReleaseTmpRegister(tmpReg);
                    tmpReg--;
                }
            }
        }

        Assert(funcInfo->firstTmpReg == firstTmpReg);
        Assert(funcInfo->curTmpReg == firstTmpReg);
        Assert(byteCodeFunction->GetFirstTmpReg() == firstTmpReg + byteCodeFunction->GetConstantCount());

        byteCodeFunction->CheckAndSetVarCount(funcInfo->varRegsCount);
        byteCodeFunction->CheckAndSetOutParamMaxDepth(funcInfo->outArgsMaxDepth);
        byteCodeFunction->SetForInLoopDepth(funcInfo->GetMaxForInLoopLevel());

        // Do a uint32 add just to verify that we haven't overflowed the reg slot type.
        UInt32Math::Add(funcInfo->varRegsCount, funcInfo->constRegsCount);

#if DBG_DUMP
        if (PHASE_STATS1(Js::ByteCodePhase))
        {
            Output::Print(_u("" BCode: %-10d, Aux: %-10d, AuxC: %-10d Total: %-10d,  %s\n""),
                m_writer.ByteCodeDataSize(),
                m_writer.AuxiliaryDataSize(),
                m_writer.AuxiliaryContextDataSize(),
                m_writer.ByteCodeDataSize() + m_writer.AuxiliaryDataSize() + m_writer.AuxiliaryContextDataSize(),
                funcInfo->name);

            this->scriptContext->byteCodeDataSize += m_writer.ByteCodeDataSize();
            this->scriptContext->byteCodeAuxiliaryDataSize += m_writer.AuxiliaryDataSize();
            this->scriptContext->byteCodeAuxiliaryContextDataSize += m_writer.AuxiliaryContextDataSize();
        }
#endif

        this->MapCacheIdsToPropertyIds(funcInfo);
        this->MapReferencedPropertyIds(funcInfo);

        Assert(this->TopFuncInfo() == funcInfo);
        PopFuncInfo(_u(""EmitOneFunction""));
        m_writer.SetCallSiteCount(m_callSiteId);
#ifdef LOG_BYTECODE_AST_RATIO
        m_writer.End(funcInfo->root->sxFnc.astSize, this->maxAstSize);
#else
        m_writer.End();
#endif
    }
    catch (...)
    {
        // Failed to generate byte-code for this function body (likely OOM or stack overflow). Notify the function body so that
        // it can revert intermediate state changes that may have taken place during byte code generation before the failure.
        byteCodeFunction->ResetByteCodeGenState();
        m_writer.Reset();
        throw;
    }

#ifdef PERF_HINT
    if (PHASE_TRACE1(Js::PerfHintPhase) && !byteCodeFunction->GetIsGlobalFunc())
    {
        if (byteCodeFunction->GetHasTry())
        {
            WritePerfHint(PerfHints::HasTryBlock_Verbose, byteCodeFunction);
        }

        if (funcInfo->GetCallsEval())
        {
            WritePerfHint(PerfHints::CallsEval_Verbose, byteCodeFunction);
        }
        else if (funcInfo->GetChildCallsEval())
        {
            WritePerfHint(PerfHints::ChildCallsEval, byteCodeFunction);
        }
    }
#endif


    byteCodeFunction->SetInitialDefaultEntryPoint();
    byteCodeFunction->SetCompileCount(UInt32Math::Add(byteCodeFunction->GetCompileCount(), 1));

#ifdef ENABLE_DEBUG_CONFIG_OPTIONS
    if (byteCodeFunction->IsInDebugMode() != scriptContext->IsScriptContextInDebugMode()) // debug mode mismatch
    {
        if (m_utf8SourceInfo->GetIsLibraryCode())
        {
            Assert(!byteCodeFunction->IsInDebugMode()); // Library script byteCode is never in debug mode
        }
        else
        {
            Js::Throw::FatalInternalError();
        }
    }
#endif

#if DBG_DUMP
    if (PHASE_DUMP(Js::ByteCodePhase, funcInfo->byteCodeFunction) && Js::Configuration::Global.flags.Verbose)
    {
        pnode->Dump();
    }
    if (this->Trace() || PHASE_DUMP(Js::ByteCodePhase, funcInfo->byteCodeFunction))
    {
        Js::ByteCodeDumper::Dump(byteCodeFunction);
    }
    if (PHASE_DUMP(Js::DebuggerScopePhase, funcInfo->byteCodeFunction))
    {
        byteCodeFunction->DumpScopes();
    }
#endif
#if ENABLE_NATIVE_CODEGEN
    if ((!PHASE_OFF(Js::BackEndPhase, funcInfo->byteCodeFunction))
        && !this->forceNoNative
        && !this->scriptContext->GetConfig()->IsNoNative())
    {
        GenerateFunction(this->scriptContext->GetNativeCodeGenerator(), byteCodeFunction);
    }
#endif
}","void ByteCodeGenerator::EmitOneFunction(ParseNode *VAR_0)
{
    Assert(VAR_0 && (VAR_0->nop == VAR_1 || VAR_0->nop == VAR_2));
    FuncInfo *VAR_3 = VAR_0->sxFnc.funcInfo;
    Assert(VAR_3 != nullptr);

    if (VAR_3->IsFakeGlobalFunction(this->flags))
    {
        return;
    }

    Js::ParseableFunctionInfo* VAR_4 = VAR_3->byteCodeFunction;
    VAR_4->SetGrfscr(VAR_4->GetGrfscr() | (this->flags & ~VAR_5));
    VAR_4->SetSourceInfo(this->GetCurrentSourceIndex(),
        VAR_3->root,
        !!(this->flags & VAR_6),
        ((this->flags & VAR_7) && !(this->flags & VAR_6)));

    VAR_4->SetInParamsCount(VAR_3->inArgsCount);
    if (VAR_0->sxFnc.HasDefaultArguments())
    {
        VAR_4->SetReportedInParamsCount(VAR_0->sxFnc.firstDefaultArg + 1);
    }
    else
    {
        VAR_4->SetReportedInParamsCount(VAR_3->inArgsCount);
    }

    if (VAR_3->root->sxFnc.pnodeBody == nullptr)
    {
        if (!PHASE_OFF1(Js::SkipNestedDeferredPhase))
        {
            VAR_4->BuildDeferredStubs(VAR_3->root);
        }
        Assert(!VAR_4->IsFunctionBody() || VAR_4->GetFunctionBody()->GetByteCode() != nullptr);
        return;
    }

    Js::FunctionBody* VAR_8 = VAR_3->GetParsedFunctionBody();
    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    VAR_8->SetDeferredStubs(nullptr);

    try
    {
        if (!VAR_3->IsGlobalFunction())
        {
            /* COMMENT_3 */
            /* COMMENT_4 */
            if (CanStackNestedFunc(VAR_3, true) && VAR_8->GetCompileCount() == 0)
            {
#if VAR_9
                VAR_8->SetCanDoStackNestedFunc();
#endif
                if (VAR_3->root->sxFnc.astSize <= PnFnc::MaxStackClosureAST)
                {
                    VAR_8->SetStackNestedFunc(true);
                }
            }
        }

        if (VAR_8->DoStackNestedFunc())
        {
            uint VAR_10 = VAR_8->GetNestedCount();
            for (uint VAR_11 = 0; VAR_11 < VAR_10; VAR_11++)
            {
                Js::FunctionProxy * VAR_12 = VAR_8->GetNestedFunctionProxy(VAR_11);
                if (VAR_12->IsFunctionBody())
                {
                    VAR_12->GetFunctionBody()->SetStackNestedFuncParent(VAR_8->GetFunctionInfo());
                }
            }
        }

        if (VAR_8->GetByteCode() != nullptr)
        {
            /* COMMENT_5 */
            return;
        }

        /* COMMENT_6 */
        /* COMMENT_7 */
        /* COMMENT_8 */
        if (VAR_3->root->sxFnc.HasOnlyThisStmts() && !IsInDebugMode())
        {
            VAR_8->SetHasOnlyThisStmts(true);
        }

        if (VAR_8->IsInlineApplyDisabled() || this->scriptContext->GetConfig()->IsNoNative())
        {
            if ((VAR_0->nop == VAR_2) && (VAR_3->GetHasHeapArguments()) && (!VAR_3->GetCallsEval()) && ApplyEnclosesArgs(VAR_0, this))
            {
                bool VAR_13 = true;
                for (ParseNode* VAR_14 = VAR_3->root->sxFnc.pnodeVars; VAR_14; VAR_14 = VAR_14->sxVar.pnodeNext)
                {
                    Symbol* VAR_15 = VAR_14->sxVar.sym;
                    if (VAR_15->GetSymbolType() == VAR_16 && !VAR_15->GetIsArguments())
                    {
                        VAR_13 = false;
                        break;
                    }
                }
                auto VAR_17 = [](ParseNode *VAR_18, bool *VAR_13)
                {
                    if (*VAR_13)
                    {
                        for (auto VAR_19 = VAR_18->sxBlock.pnodeLexVars; VAR_19; VAR_19 = VAR_19->sxVar.pnodeNext)
                        {
                            Symbol* VAR_15 = VAR_19->sxVar.sym;
                            if (VAR_15->GetSymbolType() == VAR_16 && !VAR_15->GetIsArguments())
                            {
                                *VAR_13 = false;
                                break;
                            }
                        }
                    }
                };
                VAR_17(VAR_3->root->sxFnc.pnodeScopes, &VAR_13);
                VAR_17(VAR_3->root->sxFnc.pnodeBodyScope, &VAR_13);
                VAR_3->SetApplyEnclosesArgs(VAR_13);
            }
        }

        InitScopeSlotArray(VAR_3);
        FinalizeRegisters(VAR_3, VAR_8);
        DebugOnly(Js::RegSlot VAR_20 = VAR_3->varRegsCount);

        /* COMMENT_9 */
        /* COMMENT_10 */
        uint VAR_21 = VAR_3->InnerScopeCount();
        if (!this->IsInDebugMode())
        {
            VAR_8->SetInnerScopeCount(VAR_21);
            if (VAR_21)
            {
                VAR_3->SetFirstInnerScopeReg(VAR_3->AcquireTmpRegister());
                for (uint VAR_11 = 1; VAR_11 < VAR_21; VAR_11++)
                {
                    VAR_3->AcquireTmpRegister();
                }
            }
        }

        VAR_3->inlineCacheMap = Anew(VAR_22, FuncInfo::InlineCacheMap,
            VAR_22,
            VAR_3->RegCount() /* COMMENT_11 */
            );
        VAR_3->rootObjectLoadInlineCacheMap = Anew(VAR_22, FuncInfo::RootObjectInlineCacheIdMap,
            VAR_22,
            10);
        VAR_3->rootObjectLoadMethodInlineCacheMap = Anew(VAR_22, FuncInfo::RootObjectInlineCacheIdMap,
            VAR_22,
            10);
        VAR_3->rootObjectStoreInlineCacheMap = Anew(VAR_22, FuncInfo::RootObjectInlineCacheIdMap,
            VAR_22,
            10);
        VAR_3->referencedPropertyIdToMapIndex = Anew(VAR_22, FuncInfo::RootObjectInlineCacheIdMap,
            VAR_22,
            10);

        VAR_8->AllocateLiteralRegexArray();
        VAR_23 = 0;
        VAR_24.Begin(VAR_8, VAR_22, this->DoJitLoopBodies(VAR_3), VAR_3->hasLoop, this->IsInDebugMode());
        this->PushFuncInfo(_u(""EmitOneFunction""), VAR_3);

        this->inPrologue = true;

        /* COMMENT_12 */
        /* COMMENT_13 */
        /* COMMENT_14 */
        if (VAR_3->IsClassConstructor())
        {
            VAR_24.Empty(Js::OpCode::ChkNewCallFlag);
        }

        Scope* VAR_25 = VAR_3->GetCurrentChildScope();
        Scope* VAR_26 = VAR_3->GetParamScope();
        Scope* VAR_27 = VAR_3->GetBodyScope();

        /* COMMENT_15 */
        LoadAllConstants(VAR_3);
        HomeArguments(VAR_3);

        if (!VAR_25->GetCanMergeWithBodyScope())
        {
            VAR_8->SetParamAndBodyScopeNotMerged();

            /* COMMENT_16 */
            PopScope();
            Assert(this->GetCurrentScope() == VAR_26);
        }

        if (VAR_3->root->sxFnc.pnodeRest != nullptr)
        {
            VAR_8->SetHasRestParameter();
        }

        if (VAR_3->thisScopeSlot != Js::Constants::NoRegister && !(VAR_3->IsLambda() || (VAR_3->IsGlobalFunction() && this->flags & VAR_28)))
        {
            EmitInitCapturedThis(VAR_3, VAR_3->bodyScope);
        }

        /* COMMENT_17 */
        if ((VAR_3->HasSuperReference() || (VAR_3->GetCallsEval() && (VAR_3->root->sxFnc.IsMethod() || VAR_3->root->sxFnc.IsConstructor())))
            /* COMMENT_18 */
            && !((GetFlags() & VAR_28) && VAR_3->IsGlobalFunction()))
        {
            if (VAR_3->IsLambda())
            {
                Scope *VAR_29;
                Js::PropertyId VAR_30 = -1;
                GetEnclosingNonLambdaScope(VAR_3, VAR_29, VAR_30);

                FuncInfo* VAR_31 = VAR_29->GetFunc();

                if (!VAR_31->IsGlobalFunction())
                {
                    /* COMMENT_19 */
                    EmitInternalScopedSlotLoad(VAR_3, VAR_29, VAR_30, VAR_31->superScopeSlot, VAR_3->superRegister);
                    if (VAR_3->superCtorRegister != Js::Constants::NoRegister)
                    {
                        EmitInternalScopedSlotLoad(VAR_3, VAR_29, VAR_30, VAR_31->superCtorScopeSlot, VAR_3->superCtorRegister);
                    }
                }
                else if (!(GetFlags() & VAR_28))
                {
                    /* COMMENT_20 */
                    VAR_24.Reg1(Js::OpCode::LdUndef, VAR_3->superRegister);
                }
                /* COMMENT_21 */
            }
            else
            {
                VAR_24.Reg1(Js::OpCode::LdHomeObj, VAR_3->superRegister);

                if (VAR_3->superCtorRegister != Js::Constants::NoRegister) /* COMMENT_22 */
                {
                    VAR_24.Reg1(Js::OpCode::LdFuncObj, VAR_3->superCtorRegister);
                }

                if (!VAR_3->IsGlobalFunction())
                {
                    if (VAR_27->GetIsObject() && VAR_27->GetLocation() != Js::Constants::NoRegister)
                    {
                        /* COMMENT_23 */
                        uint VAR_32 = VAR_3->FindOrAddInlineCacheId(VAR_27->GetLocation(), Js::PropertyIds::_superReferenceSymbol, false, true);
                        VAR_24.ElementP(Js::OpCode::InitLocalFld, VAR_3->superRegister, VAR_32);
                        if (VAR_3->superCtorRegister != Js::Constants::NoRegister)
                        {
                            VAR_32 = VAR_3->FindOrAddInlineCacheId(VAR_27->GetLocation(), Js::PropertyIds::_superCtorReferenceSymbol, false, true);
                            VAR_24.ElementP(Js::OpCode::InitLocalFld, VAR_3->superCtorRegister, VAR_32);
                        }
                    }
                    else if (VAR_3->superScopeSlot == Js::Constants::NoProperty || VAR_3->superCtorScopeSlot == Js::Constants::NoProperty)
                    {
                        /* COMMENT_24 */
                        /* COMMENT_25 */
                        VAR_8->InsertSymbolToRegSlotList(VAR_3->superRegister, Js::PropertyIds::_superReferenceSymbol, VAR_3->varRegsCount);
                        if (VAR_3->superCtorRegister != Js::Constants::NoRegister)
                        {
                            VAR_8->InsertSymbolToRegSlotList(VAR_3->superCtorRegister, Js::PropertyIds::_superCtorReferenceSymbol, VAR_3->varRegsCount);
                        }
                    }
                }
            }
        }

        if (VAR_3->newTargetScopeSlot != Js::Constants::NoRegister && !VAR_3->IsGlobalFunction())
        {
            EmitInitCapturedNewTarget(VAR_3, VAR_27);
        }

        /* COMMENT_26 */
        if (!(GetFlags() & VAR_28) && !VAR_27->GetIsObject())
        {
            if (VAR_3->superScopeSlot != Js::Constants::NoRegister)
            {
                this->EmitInternalScopedSlotStore(VAR_3, VAR_3->superScopeSlot, VAR_3->superRegister);
            }

            if (VAR_3->superCtorScopeSlot != Js::Constants::NoRegister)
            {
                this->EmitInternalScopedSlotStore(VAR_3, VAR_3->superCtorScopeSlot, VAR_3->superCtorRegister);
            }
        }

        if (VAR_3->IsGlobalFunction())
        {
            EnsureNoRedeclarations(VAR_0->sxFnc.pnodeScopes, VAR_3);
        }

        ::BeginEmitBlock(VAR_0->sxFnc.pnodeScopes, this, VAR_3);

        DefineLabels(VAR_3);

        if (VAR_0->sxFnc.HasNonSimpleParameterList())
        {
            this->InitBlockScopedNonTemps(VAR_3->root->sxFnc.pnodeScopes, VAR_3);

            EmitDefaultArgs(VAR_3, VAR_0);

            if (!VAR_25->GetCanMergeWithBodyScope())
            {
                Assert(this->GetCurrentScope() == VAR_26);
                /* COMMENT_27 */
                PushScope(VAR_27);

                VAR_3->SetCurrentChildScope(VAR_27);

                /* COMMENT_28 */
                this->Writer()->Empty(Js::OpCode::BeginBodyScope);
            }
        }

        InitSpecialScopeSlots(VAR_3);

        /* COMMENT_29 */
        /* COMMENT_30 */
        /* COMMENT_31 */
        /* COMMENT_32 */
        /* COMMENT_33 */
        if (!(VAR_3->IsGlobalFunction() && this->IsEvalWithNoParentScopeInfo()))
        {
            /* COMMENT_34 */
            DefineFunctions(VAR_3);
        }

        DefineUserVars(VAR_3);

        if (VAR_0->sxFnc.HasNonSimpleParameterList())
        {
            this->InitBlockScopedNonTemps(VAR_3->root->sxFnc.pnodeBodyScope, VAR_3);
        }
        else
        {
            this->InitBlockScopedNonTemps(VAR_3->root->sxFnc.pnodeScopes, VAR_3);
        }

        if (!VAR_0->sxFnc.HasNonSimpleParameterList() && VAR_3->GetHasArguments() && !NeedScopeObjectForArguments(VAR_3, VAR_0))
        {
            /* COMMENT_35 */
            MapFormalsWithoutRest(VAR_0, [&](ParseNode *VAR_33) { EmitPropStore(VAR_33->sxVar.sym->GetLocation(), VAR_33->sxVar.sym, VAR_33->sxVar.pid, VAR_3); });
        }

        /* COMMENT_36 */
        if (VAR_0->sxFnc.pnodeRest != nullptr)
        {
            VAR_0->sxFnc.pnodeRest->sxVar.sym->SetNeedDeclaration(false);
        }

        if (VAR_26 && !VAR_26->GetCanMergeWithBodyScope())
        {
            /* COMMENT_37 */
            /* COMMENT_38 */
            Symbol* VAR_34 = VAR_3->root->sxFnc.GetFuncSymbol();
            VAR_26->ForEachSymbol([&](Symbol* VAR_35) {
                Symbol* VAR_36 = VAR_3->GetBodyScope()->FindLocalSymbol(VAR_35->GetName());
                Assert(VAR_36 || VAR_0->sxFnc.pnodeName->sxVar.sym == VAR_35);
                Assert(VAR_35->GetIsArguments() || VAR_35->IsInSlot(VAR_3));
                if (VAR_35->GetIsArguments() && !VAR_3->GetHasArguments())
                {
                    /* COMMENT_39 */
                }
                else if ((VAR_34 == nullptr || VAR_34 != VAR_35)    /* COMMENT_40 */
                                                                     /* COMMENT_41 */
                    && (VAR_36 && VAR_36->GetSymbolType() == VAR_16 && (VAR_36->IsInSlot(VAR_3) || VAR_36->GetLocation() != Js::Constants::NoRegister)))
                {
                    /* COMMENT_42 */
                    /* COMMENT_43 */
                    Js::RegSlot VAR_37 = VAR_3->AcquireTmpRegister();
                    Js::PropertyId VAR_38 = VAR_35->EnsureScopeSlot(VAR_3);
                    Js::ProfileId VAR_39 = VAR_3->FindOrAddSlotProfileId(VAR_26, VAR_38);
                    Js::OpCode VAR_40 = VAR_26->GetIsObject() ? Js::OpCode::LdParamObjSlot : Js::OpCode::LdParamSlot;
                    VAR_38 = VAR_38 + (VAR_26->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);

                    this->m_writer.SlotI1(VAR_40, VAR_37, VAR_38, VAR_39);

                    if (ShouldTrackDebuggerMetadata() && !VAR_36->GetIsArguments() && !VAR_36->IsInSlot(VAR_3))
                    {
                        VAR_8->InsertSymbolToRegSlotList(VAR_36->GetName(), VAR_36->GetLocation(), VAR_3->varRegsCount);
                    }

                    this->EmitPropStore(VAR_37, VAR_36, VAR_36->GetPid(), VAR_3);
                    VAR_3->ReleaseTmpRegister(VAR_37);
                }
            });

            /* COMMENT_44 */
            /* COMMENT_45 */
            auto VAR_41 = [this, VAR_3, VAR_26] (Js::PropertyId VAR_42, Js::PropertyId VAR_43)
            {
                if (VAR_43 != Js::Constants::NoProperty)
                {
                    Js::RegSlot VAR_37 = VAR_3->AcquireTmpRegister();
                    Js::PropertyId VAR_38 = VAR_42;
                    Js::ProfileId VAR_39 = VAR_3->FindOrAddSlotProfileId(VAR_26, VAR_38);
                    Js::OpCode VAR_40 = VAR_26->GetIsObject() ? Js::OpCode::LdParamObjSlot : Js::OpCode::LdParamSlot;
                    VAR_38 = VAR_38 + (VAR_26->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);

                    this->m_writer.SlotI1(VAR_40, VAR_37, VAR_38, VAR_39);

                    VAR_40 = VAR_3->bodyScope->GetIsObject() ? Js::OpCode::StLocalObjSlot : Js::OpCode::StLocalSlot;
                    VAR_38 = VAR_43 + (VAR_3->bodyScope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);
                    this->m_writer.SlotI1(VAR_40, VAR_37, VAR_38);
                    VAR_3->ReleaseTmpRegister(VAR_37);
                }
            };
            VAR_41(VAR_3->innerThisScopeSlot, VAR_3->thisScopeSlot);
            VAR_41(VAR_3->innerSuperScopeSlot, VAR_3->superScopeSlot);
            VAR_41(VAR_3->innerSuperCtorScopeSlot, VAR_3->superCtorScopeSlot);
            VAR_41(VAR_3->innerNewTargetScopeSlot, VAR_3->newTargetScopeSlot);
        }

        if (VAR_0->sxFnc.pnodeBodyScope != nullptr)
        {
            ::BeginEmitBlock(VAR_0->sxFnc.pnodeBodyScope, this, VAR_3);
        }

        this->inPrologue = false;

        if (VAR_3->IsGlobalFunction())
        {
            EmitGlobalBody(VAR_3);
        }
        else
        {
            EmitFunctionBody(VAR_3);
        }

        if (VAR_0->sxFnc.pnodeBodyScope != nullptr)
        {
            ::EndEmitBlock(VAR_0->sxFnc.pnodeBodyScope, this, VAR_3);
        }
        ::EndEmitBlock(VAR_0->sxFnc.pnodeScopes, this, VAR_3);

        if (!this->IsInDebugMode())
        {
            /* COMMENT_46 */
            if (VAR_21)
            {
                Js::RegSlot VAR_44 = VAR_3->FirstInnerScopeReg() + VAR_21 - 1;
                for (uint VAR_11 = 0; VAR_11 < VAR_21; VAR_11++)
                {
                    VAR_3->ReleaseTmpRegister(VAR_44);
                    VAR_44--;
                }
            }
        }

        Assert(VAR_3->firstTmpReg == VAR_20);
        Assert(VAR_3->curTmpReg == VAR_20);
        Assert(VAR_8->GetFirstTmpReg() == VAR_20 + VAR_8->GetConstantCount());

        VAR_8->CheckAndSetVarCount(VAR_3->varRegsCount);
        VAR_8->CheckAndSetOutParamMaxDepth(VAR_3->outArgsMaxDepth);
        VAR_8->SetForInLoopDepth(VAR_3->GetMaxForInLoopLevel());

        /* COMMENT_47 */
        UInt32Math::Add(VAR_3->varRegsCount, VAR_3->constRegsCount);

#if VAR_45
        if (PHASE_STATS1(Js::ByteCodePhase))
        {
            Output::Print(_u("" BCode: %-10d, Aux: %-10d, AuxC: %-10d Total: %-10d,  %s\n""),
                VAR_24.ByteCodeDataSize(),
                VAR_24.AuxiliaryDataSize(),
                VAR_24.AuxiliaryContextDataSize(),
                VAR_24.ByteCodeDataSize() + VAR_24.AuxiliaryDataSize() + VAR_24.AuxiliaryContextDataSize(),
                VAR_3->name);

            this->scriptContext->byteCodeDataSize += VAR_24.ByteCodeDataSize();
            this->scriptContext->byteCodeAuxiliaryDataSize += VAR_24.AuxiliaryDataSize();
            this->scriptContext->byteCodeAuxiliaryContextDataSize += VAR_24.AuxiliaryContextDataSize();
        }
#endif

        this->MapCacheIdsToPropertyIds(VAR_3);
        this->MapReferencedPropertyIds(VAR_3);

        Assert(this->TopFuncInfo() == VAR_3);
        PopFuncInfo(_u(""EmitOneFunction""));
        VAR_24.SetCallSiteCount(VAR_23);
#ifdef VAR_46
        VAR_24.End(VAR_3->root->sxFnc.astSize, this->maxAstSize);
#else
        VAR_24.End();
#endif
    }
    catch (...)
    {
        /* COMMENT_48 */
        /* COMMENT_49 */
        VAR_8->ResetByteCodeGenState();
        VAR_24.Reset();
        throw;
    }

#ifdef VAR_47
    if (PHASE_TRACE1(Js::PerfHintPhase) && !VAR_8->GetIsGlobalFunc())
    {
        if (VAR_8->GetHasTry())
        {
            WritePerfHint(PerfHints::HasTryBlock_Verbose, VAR_8);
        }

        if (VAR_3->GetCallsEval())
        {
            WritePerfHint(PerfHints::CallsEval_Verbose, VAR_8);
        }
        else if (VAR_3->GetChildCallsEval())
        {
            WritePerfHint(PerfHints::ChildCallsEval, VAR_8);
        }
    }
#endif


    VAR_8->SetInitialDefaultEntryPoint();
    VAR_8->SetCompileCount(UInt32Math::Add(VAR_8->GetCompileCount(), 1));

#ifdef VAR_48
    if (VAR_8->IsInDebugMode() != VAR_49->IsScriptContextInDebugMode()) /* COMMENT_50 */
    {
        if (VAR_50->GetIsLibraryCode())
        {
            Assert(!VAR_8->IsInDebugMode()); /* COMMENT_51 */
        }
        else
        {
            Js::Throw::FatalInternalError();
        }
    }
#endif

#if VAR_45
    if (PHASE_DUMP(Js::ByteCodePhase, VAR_3->byteCodeFunction) && Js::Configuration::Global.flags.Verbose)
    {
        VAR_0->Dump();
    }
    if (this->Trace() || PHASE_DUMP(Js::ByteCodePhase, VAR_3->byteCodeFunction))
    {
        Js::ByteCodeDumper::Dump(VAR_8);
    }
    if (PHASE_DUMP(Js::DebuggerScopePhase, VAR_3->byteCodeFunction))
    {
        VAR_8->DumpScopes();
    }
#endif
#if VAR_51
    if ((!PHASE_OFF(Js::BackEndPhase, VAR_3->byteCodeFunction))
        && !this->forceNoNative
        && !this->scriptContext->GetConfig()->IsNoNative())
    {
        GenerateFunction(this->scriptContext->GetNativeCodeGenerator(), VAR_8);
    }
#endif
}",,"--- func_before
+++ func_after
@@ -353,6 +353,7 @@
         {
             // Emit bytecode to copy the initial values from param names to their corresponding body bindings.
             // We have to do this after the rest param is marked as false for need declaration.
+            Symbol* funcSym = funcInfo->root->sxFnc.GetFuncSymbol();
             paramScope->ForEachSymbol([&](Symbol* param) {
                 Symbol* varSym = funcInfo->GetBodyScope()->FindLocalSymbol(param->GetName());
                 Assert(varSym || pnode->sxFnc.pnodeName->sxVar.sym == param);
@@ -361,7 +362,9 @@
                 {
                     // Do not copy the arguments to the body if it is not used
                 }
-                else if (varSym && varSym->GetSymbolType() == STVariable && (varSym->IsInSlot(funcInfo) || varSym->GetLocation() != Js::Constants::NoRegister))
+                else if ((funcSym == nullptr || funcSym != param)    // Do not copy the symbol over to body as the function expression symbol
+                                                                     // is expected to stay inside the function expression scope
+                    && (varSym && varSym->GetSymbolType() == STVariable && (varSym->IsInSlot(funcInfo) || varSym->GetLocation() != Js::Constants::NoRegister)))
                 {
                     // Simulating EmitPropLoad here. We can't directly call the method as we have to use the param scope specifically.
                     // Walking the scope chain is not possible at this time.","{'deleted_lines': ['                else if (varSym && varSym->GetSymbolType() == STVariable && (varSym->IsInSlot(funcInfo) || varSym->GetLocation() != Js::Constants::NoRegister))'], 'added_lines': ['            Symbol* funcSym = funcInfo->root->sxFnc.GetFuncSymbol();', '                else if ((funcSym == nullptr || funcSym != param)    // Do not copy the symbol over to body as the function expression symbol', '                                                                     // is expected to stay inside the function expression scope', '                    && (varSym && varSym->GetSymbolType() == STVariable && (varSym->IsInSlot(funcInfo) || varSym->GetLocation() != Js::Constants::NoRegister)))']}",True,"A remote code execution vulnerability exists in the way affected Microsoft scripting engine render when handling objects in memory in Microsoft browsers. The vulnerability could corrupt memory in such a way that an attacker could execute arbitrary code in the context of the current user. An attacker who successfully exploited the vulnerability could gain the same user rights as the current user, aka ""Scripting Engine Memory Corruption Vulnerability.""",8.1,HIGH,2,test,2017-03-09T00:58:06Z,1
CVE-2017-13011,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-13011/Properly check for buffer overflow in bittok2str_internal().

Also, make the buffer bigger.

This fixes a buffer overflow discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't be rejected as an invalid capture.",9f0730bee3eb65d07b49fd468bc2f269173352fe,https://github.com/the-tcpdump-group/tcpdump/commit/9f0730bee3eb65d07b49fd468bc2f269173352fe,util-print.c,bittok2str_internal,"static char *
bittok2str_internal(register const struct tok *lp, register const char *fmt,
register u_int v, const char *sep)
{
static char buf[256]; 
int buflen=0;
register u_int rotbit; 
register u_int tokval;
const char * sepstr = """";
while (lp != NULL && lp->s != NULL) {
tokval=lp->v;   
rotbit=1;
while (rotbit != 0) {
if (tokval == (v&rotbit)) {
buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, ""%s%s"",
sepstr, lp->s);
sepstr = sep;
break;
}
rotbit=rotbit<<1; 
}
lp++;
}
if (buflen == 0)
(void)snprintf(buf, sizeof(buf), fmt == NULL ? ""#%08x"" : fmt, v);
return (buf);
}","static char *
bittok2str_internal(register const struct tok *VAR_0, register const char *VAR_1,
register u_int VAR_2, const char *VAR_3)
{
static char VAR_4[256]; 
int VAR_5=0;
register u_int VAR_6; 
register u_int VAR_7;
const char * VAR_8 = """";
while (VAR_0 != NULL && VAR_0->s != NULL) {
VAR_7=VAR_0->v;   
VAR_6=1;
while (VAR_6 != 0) {
if (VAR_7 == (VAR_2&VAR_6)) {
VAR_5+=snprintf(VAR_4+VAR_5, sizeof(VAR_4)-VAR_5, ""%s%s"",
VAR_8, VAR_0->s);
VAR_8 = VAR_3;
break;
}
VAR_6=VAR_6<<1; 
}
VAR_0++;
}
if (VAR_5 == 0)
(void)snprintf(VAR_4, sizeof(VAR_4), VAR_1 == NULL ? ""#%08x"" : VAR_1, VAR_2);
return (VAR_4);
}",the-tcpdump-group/tcpdump/9f0730bee3eb65d07b49fd468bc2f269173352fe/util-print.c/vul/before/0.json,"static char *
bittok2str_internal(register const struct tok *lp, register const char *fmt,
	   register u_int v, const char *sep)
{
        static char buf[1024+1]; /* our string buffer */
        char *bufp = buf;
        size_t space_left = sizeof(buf), string_size;
        register u_int rotbit; /* this is the bit we rotate through all bitpositions */
        register u_int tokval;
        const char * sepstr = """";

	while (lp != NULL && lp->s != NULL) {
            tokval=lp->v;   /* load our first value */
            rotbit=1;
            while (rotbit != 0) {
                /*
                 * lets AND the rotating bit with our token value
                 * and see if we have got a match
                 */
		if (tokval == (v&rotbit)) {
                    /* ok we have found something */
                    if (space_left <= 1)
                        return (buf); /* only enough room left for NUL, if that */
                    string_size = strlcpy(bufp, sepstr, space_left);
                    if (string_size >= space_left)
                        return (buf);    /* we ran out of room */
                    bufp += string_size;
                    space_left -= string_size;
                    if (space_left <= 1)
                        return (buf); /* only enough room left for NUL, if that */
                    string_size = strlcpy(bufp, lp->s, space_left);
                    if (string_size >= space_left)
                        return (buf);    /* we ran out of room */
                    bufp += string_size;
                    space_left -= string_size;
                    sepstr = sep;
                    break;
                }
                rotbit=rotbit<<1; /* no match - lets shift and try again */
            }
            lp++;
	}

        if (bufp == buf)
            /* bummer - lets print the ""unknown"" message as advised in the fmt string if we got one */
            (void)snprintf(buf, sizeof(buf), fmt == NULL ? ""#%08x"" : fmt, v);
        return (buf);
}","static char *
bittok2str_internal(register const struct tok *VAR_0, register const char *VAR_1,
	   register u_int VAR_2, const char *VAR_3)
{
        static char VAR_4[1024+1]; /* COMMENT_0 */
        char *VAR_5 = VAR_4;
        size_t VAR_6 = sizeof(VAR_4), VAR_7;
        register u_int VAR_8; /* COMMENT_1 */
        register u_int VAR_9;
        const char * VAR_10 = """";

	while (VAR_0 != NULL && VAR_0->s != NULL) {
            VAR_9=VAR_0->v;   /* COMMENT_2 */
            VAR_8=1;
            while (VAR_8 != 0) {
                /* COMMENT_3 */
                                                                 
                                                 
                   
		if (VAR_9 == (VAR_2&VAR_8)) {
                    /* COMMENT_7 */
                    if (VAR_6 <= 1)
                        return (VAR_4); /* COMMENT_8 */
                    VAR_7 = strlcpy(VAR_5, VAR_10, VAR_6);
                    if (VAR_7 >= VAR_6)
                        return (VAR_4);    /* COMMENT_9 */
                    VAR_5 += VAR_7;
                    VAR_6 -= VAR_7;
                    if (VAR_6 <= 1)
                        return (VAR_4); /* COMMENT_8 */
                    VAR_7 = strlcpy(VAR_5, VAR_0->s, VAR_6);
                    if (VAR_7 >= VAR_6)
                        return (VAR_4);    /* COMMENT_9 */
                    VAR_5 += VAR_7;
                    VAR_6 -= VAR_7;
                    VAR_10 = VAR_3;
                    break;
                }
                VAR_8=VAR_8<<1; /* COMMENT_10 */
            }
            VAR_0++;
	}

        if (VAR_5 == VAR_4)
            /* COMMENT_11 */
            (void)snprintf(VAR_4, sizeof(VAR_4), VAR_1 == NULL ? ""#%08x"" : VAR_1, VAR_2);
        return (VAR_4);
}",the-tcpdump-group/tcpdump/9f0730bee3eb65d07b49fd468bc2f269173352fe/util-print.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,8 +2,9 @@
 bittok2str_internal(register const struct tok *lp, register const char *fmt,
 	   register u_int v, const char *sep)
 {
-        static char buf[256]; /* our stringbuffer */
-        int buflen=0;
+        static char buf[1024+1]; /* our string buffer */
+        char *bufp = buf;
+        size_t space_left = sizeof(buf), string_size;
         register u_int rotbit; /* this is the bit we rotate through all bitpositions */
         register u_int tokval;
         const char * sepstr = """";
@@ -18,8 +19,20 @@
                  */
 		if (tokval == (v&rotbit)) {
                     /* ok we have found something */
-                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, ""%s%s"",
-                                     sepstr, lp->s);
+                    if (space_left <= 1)
+                        return (buf); /* only enough room left for NUL, if that */
+                    string_size = strlcpy(bufp, sepstr, space_left);
+                    if (string_size >= space_left)
+                        return (buf);    /* we ran out of room */
+                    bufp += string_size;
+                    space_left -= string_size;
+                    if (space_left <= 1)
+                        return (buf); /* only enough room left for NUL, if that */
+                    string_size = strlcpy(bufp, lp->s, space_left);
+                    if (string_size >= space_left)
+                        return (buf);    /* we ran out of room */
+                    bufp += string_size;
+                    space_left -= string_size;
                     sepstr = sep;
                     break;
                 }
@@ -28,7 +41,7 @@
             lp++;
 	}
 
-        if (buflen == 0)
+        if (bufp == buf)
             /* bummer - lets print the ""unknown"" message as advised in the fmt string if we got one */
             (void)snprintf(buf, sizeof(buf), fmt == NULL ? ""#%08x"" : fmt, v);
         return (buf);","{'deleted_lines': ['        static char buf[256]; /* our stringbuffer */', '        int buflen=0;', '                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, ""%s%s"",', '                                     sepstr, lp->s);', '        if (buflen == 0)'], 'added_lines': ['        static char buf[1024+1]; /* our string buffer */', '        char *bufp = buf;', '        size_t space_left = sizeof(buf), string_size;', '                    if (space_left <= 1)', '                        return (buf); /* only enough room left for NUL, if that */', '                    string_size = strlcpy(bufp, sepstr, space_left);', '                    if (string_size >= space_left)', '                        return (buf);    /* we ran out of room */', '                    bufp += string_size;', '                    space_left -= string_size;', '                    if (space_left <= 1)', '                        return (buf); /* only enough room left for NUL, if that */', '                    string_size = strlcpy(bufp, lp->s, space_left);', '                    if (string_size >= space_left)', '                        return (buf);    /* we ran out of room */', '                    bufp += string_size;', '                    space_left -= string_size;', '        if (bufp == buf)']}",True,Several protocol parsers in tcpdump before 4.9.2 could cause a buffer overflow in util-print.c:bittok2str_internal().,9.8,CRITICAL,3,test,2017-03-15T19:12:21Z,1
CVE-2017-13015,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-13015/EAP: Add more bounds checks.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't be rejected as an invalid capture.",985122081165753c7442bd7824c473eb9ff56308,https://github.com/the-tcpdump-group/tcpdump/commit/985122081165753c7442bd7824c473eb9ff56308,print-eap.c,eap_print,"void
eap_print(netdissect_options *ndo,
register const u_char *cp,
u_int length)
{
const struct eap_frame_t *eap;
const u_char *tptr;
u_int tlen, type, subtype;
int count=0, len;
tptr = cp;
tlen = length;
eap = (const struct eap_frame_t *)cp;
ND_TCHECK(*eap);
if (ndo->ndo_vflag < 1) {
ND_PRINT((ndo, ""%s (%u) v%u, len %u"",
tok2str(eap_frame_type_values, ""unknown"", eap->type),
eap->type,
eap->version,
EXTRACT_16BITS(eap->length)));
return;
}
ND_PRINT((ndo, ""%s (%u) v%u, len %u"",
tok2str(eap_frame_type_values, ""unknown"", eap->type),
eap->type,
eap->version,
EXTRACT_16BITS(eap->length)));
tptr += sizeof(const struct eap_frame_t);
tlen -= sizeof(const struct eap_frame_t);
switch (eap->type) {
case EAP_FRAME_TYPE_PACKET:
type = *(tptr);
len = EXTRACT_16BITS(tptr+2);
ND_PRINT((ndo, "", %s (%u), id %u, len %u"",
tok2str(eap_code_values, ""unknown"", type),
type,
*(tptr+1),
len));
ND_TCHECK2(*tptr, len);
if (type <= 2) { 
subtype = *(tptr+4);
ND_PRINT((ndo, ""\n\t\t Type %s (%u)"",
tok2str(eap_type_values, ""unknown"", *(tptr+4)),
*(tptr + 4)));
switch (subtype) {
case EAP_TYPE_IDENTITY:
if (len - 5 > 0) {
ND_PRINT((ndo, "", Identity: ""));
safeputs(ndo, tptr + 5, len - 5);
}
break;
case EAP_TYPE_NOTIFICATION:
if (len - 5 > 0) {
ND_PRINT((ndo, "", Notification: ""));
safeputs(ndo, tptr + 5, len - 5);
}
break;
case EAP_TYPE_NAK:
count = 5;
while (count < len) {
ND_PRINT((ndo, "" %s (%u),"",
tok2str(eap_type_values, ""unknown"", *(tptr+count)),
*(tptr + count)));
count++;
}
break;
case EAP_TYPE_TTLS:
ND_PRINT((ndo, "" TTLSv%u"",
EAP_TTLS_VERSION(*(tptr + 5)))); 
case EAP_TYPE_TLS:
ND_PRINT((ndo, "" flags [%s] 0x%02x,"",
bittok2str(eap_tls_flags_values, ""none"", *(tptr+5)),
*(tptr + 5)));
if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {
ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));
}
break;
case EAP_TYPE_FAST:
ND_PRINT((ndo, "" FASTv%u"",
EAP_TTLS_VERSION(*(tptr + 5))));
ND_PRINT((ndo, "" flags [%s] 0x%02x,"",
bittok2str(eap_tls_flags_values, ""none"", *(tptr+5)),
*(tptr + 5)));
if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {
ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));
}
break;
case EAP_TYPE_AKA:
case EAP_TYPE_SIM:
ND_PRINT((ndo, "" subtype [%s] 0x%02x,"",
tok2str(eap_aka_subtype_values, ""unknown"", *(tptr+5)),
*(tptr + 5)));
break;
case EAP_TYPE_MD5_CHALLENGE:
case EAP_TYPE_OTP:
case EAP_TYPE_GTC:
case EAP_TYPE_EXPANDED_TYPES:
case EAP_TYPE_EXPERIMENTAL:
default:
break;
}
}
break;
case EAP_FRAME_TYPE_LOGOFF:
case EAP_FRAME_TYPE_ENCAP_ASF_ALERT:
default:
break;
}
return;
trunc:
ND_PRINT((ndo, ""\n\t[|EAP]""));
}","void
eap_print(netdissect_options *VAR_0,
register const u_char *VAR_1,
u_int VAR_2)
{
const struct eap_frame_t *VAR_3;
const u_char *VAR_4;
u_int VAR_5, VAR_6, VAR_7;
int VAR_8=0, VAR_9;
VAR_4 = VAR_1;
VAR_5 = VAR_2;
VAR_3 = (const struct eap_frame_t *)VAR_1;
ND_TCHECK(*VAR_3);
if (VAR_0->ndo_vflag < 1) {
ND_PRINT((VAR_0, ""%s (%u) v%u, len %u"",
tok2str(VAR_10, ""unknown"", VAR_3->type),
VAR_3->type,
VAR_3->version,
EXTRACT_16BITS(VAR_3->length)));
return;
}
ND_PRINT((VAR_0, ""%s (%u) v%u, len %u"",
tok2str(VAR_10, ""unknown"", VAR_3->type),
VAR_3->type,
VAR_3->version,
EXTRACT_16BITS(VAR_3->length)));
VAR_4 += sizeof(const struct eap_frame_t);
VAR_5 -= sizeof(const struct eap_frame_t);
switch (VAR_3->type) {
case VAR_11:
VAR_6 = *(VAR_4);
VAR_9 = EXTRACT_16BITS(VAR_4+2);
ND_PRINT((VAR_0, "", %s (%u), id %u, len %u"",
tok2str(VAR_12, ""unknown"", VAR_6),
VAR_6,
*(VAR_4+1),
VAR_9));
ND_TCHECK2(*VAR_4, VAR_9);
if (VAR_6 <= 2) { 
VAR_7 = *(VAR_4+4);
ND_PRINT((VAR_0, ""\n\t\t Type %s (%u)"",
tok2str(VAR_13, ""unknown"", *(VAR_4+4)),
*(VAR_4 + 4)));
switch (VAR_7) {
case VAR_14:
if (VAR_9 - 5 > 0) {
ND_PRINT((VAR_0, "", Identity: ""));
safeputs(VAR_0, VAR_4 + 5, VAR_9 - 5);
}
break;
case VAR_15:
if (VAR_9 - 5 > 0) {
ND_PRINT((VAR_0, "", Notification: ""));
safeputs(VAR_0, VAR_4 + 5, VAR_9 - 5);
}
break;
case VAR_16:
VAR_8 = 5;
while (VAR_8 < VAR_9) {
ND_PRINT((VAR_0, "" %s (%u),"",
tok2str(VAR_13, ""unknown"", *(VAR_4+VAR_8)),
*(VAR_4 + VAR_8)));
VAR_8++;
}
break;
case VAR_17:
ND_PRINT((VAR_0, "" TTLSv%u"",
EAP_TTLS_VERSION(*(VAR_4 + 5)))); 
case VAR_18:
ND_PRINT((VAR_0, "" flags [%s] 0x%02x,"",
bittok2str(VAR_19, ""none"", *(VAR_4+5)),
*(VAR_4 + 5)));
if (EAP_TLS_EXTRACT_BIT_L(*(VAR_4+5))) {
ND_PRINT((VAR_0, "" len %u"", EXTRACT_32BITS(VAR_4 + 6)));
}
break;
case VAR_20:
ND_PRINT((VAR_0, "" FASTv%u"",
EAP_TTLS_VERSION(*(VAR_4 + 5))));
ND_PRINT((VAR_0, "" flags [%s] 0x%02x,"",
bittok2str(VAR_19, ""none"", *(VAR_4+5)),
*(VAR_4 + 5)));
if (EAP_TLS_EXTRACT_BIT_L(*(VAR_4+5))) {
ND_PRINT((VAR_0, "" len %u"", EXTRACT_32BITS(VAR_4 + 6)));
}
break;
case VAR_21:
case VAR_22:
ND_PRINT((VAR_0, "" subtype [%s] 0x%02x,"",
tok2str(VAR_23, ""unknown"", *(VAR_4+5)),
*(VAR_4 + 5)));
break;
case VAR_24:
case VAR_25:
case VAR_26:
case VAR_27:
case VAR_28:
default:
break;
}
}
break;
case VAR_29:
case VAR_30:
default:
break;
}
return;
trunc:
ND_PRINT((VAR_0, ""\n\t[|EAP]""));
}",the-tcpdump-group/tcpdump/985122081165753c7442bd7824c473eb9ff56308/print-eap.c/vul/before/0.json,"void
eap_print(netdissect_options *ndo,
          register const u_char *cp,
          u_int length)
{
    const struct eap_frame_t *eap;
    const u_char *tptr;
    u_int tlen, type, subtype;
    int count=0, len;

    tptr = cp;
    tlen = length;
    eap = (const struct eap_frame_t *)cp;
    ND_TCHECK(*eap);

    /* in non-verbose mode just lets print the basic info */
    if (ndo->ndo_vflag < 1) {
	ND_PRINT((ndo, ""%s (%u) v%u, len %u"",
               tok2str(eap_frame_type_values, ""unknown"", eap->type),
               eap->type,
               eap->version,
               EXTRACT_16BITS(eap->length)));
	return;
    }

    ND_PRINT((ndo, ""%s (%u) v%u, len %u"",
           tok2str(eap_frame_type_values, ""unknown"", eap->type),
           eap->type,
           eap->version,
           EXTRACT_16BITS(eap->length)));

    tptr += sizeof(const struct eap_frame_t);
    tlen -= sizeof(const struct eap_frame_t);

    switch (eap->type) {
    case EAP_FRAME_TYPE_PACKET:
        ND_TCHECK_8BITS(tptr);
        type = *(tptr);
        ND_TCHECK_16BITS(tptr+2);
        len = EXTRACT_16BITS(tptr+2);
        ND_PRINT((ndo, "", %s (%u), id %u, len %u"",
               tok2str(eap_code_values, ""unknown"", type),
               type,
               *(tptr+1),
               len));

        ND_TCHECK2(*tptr, len);

        if (type <= 2) { /* For EAP_REQUEST and EAP_RESPONSE only */
            ND_TCHECK_8BITS(tptr+4);
            subtype = *(tptr+4);
            ND_PRINT((ndo, ""\n\t\t Type %s (%u)"",
                   tok2str(eap_type_values, ""unknown"", subtype),
                   subtype));

            switch (subtype) {
            case EAP_TYPE_IDENTITY:
                if (len - 5 > 0) {
                    ND_PRINT((ndo, "", Identity: ""));
                    safeputs(ndo, tptr + 5, len - 5);
                }
                break;

            case EAP_TYPE_NOTIFICATION:
                if (len - 5 > 0) {
                    ND_PRINT((ndo, "", Notification: ""));
                    safeputs(ndo, tptr + 5, len - 5);
                }
                break;

            case EAP_TYPE_NAK:
                count = 5;

                /*
                 * one or more octets indicating
                 * the desired authentication
                 * type one octet per type
                 */
                while (count < len) {
                    ND_TCHECK_8BITS(tptr+count);
                    ND_PRINT((ndo, "" %s (%u),"",
                           tok2str(eap_type_values, ""unknown"", *(tptr+count)),
                           *(tptr + count)));
                    count++;
                }
                break;

            case EAP_TYPE_TTLS:
            case EAP_TYPE_TLS:
                ND_TCHECK_8BITS(tptr + 5);
                if (subtype == EAP_TYPE_TTLS)
                    ND_PRINT((ndo, "" TTLSv%u"",
                           EAP_TTLS_VERSION(*(tptr + 5))));
                ND_PRINT((ndo, "" flags [%s] 0x%02x,"",
                       bittok2str(eap_tls_flags_values, ""none"", *(tptr+5)),
                       *(tptr + 5)));

                if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {
                    ND_TCHECK_32BITS(tptr + 6);
		    ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));
                }
                break;

            case EAP_TYPE_FAST:
                ND_TCHECK_8BITS(tptr + 5);
                ND_PRINT((ndo, "" FASTv%u"",
                       EAP_TTLS_VERSION(*(tptr + 5))));
                ND_PRINT((ndo, "" flags [%s] 0x%02x,"",
                       bittok2str(eap_tls_flags_values, ""none"", *(tptr+5)),
                       *(tptr + 5)));

                if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {
                    ND_TCHECK_32BITS(tptr + 6);
                    ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));
                }

                /* FIXME - TLV attributes follow */
                break;

            case EAP_TYPE_AKA:
            case EAP_TYPE_SIM:
                ND_TCHECK_8BITS(tptr + 5);
                ND_PRINT((ndo, "" subtype [%s] 0x%02x,"",
                       tok2str(eap_aka_subtype_values, ""unknown"", *(tptr+5)),
                       *(tptr + 5)));

                /* FIXME - TLV attributes follow */
                break;

            case EAP_TYPE_MD5_CHALLENGE:
            case EAP_TYPE_OTP:
            case EAP_TYPE_GTC:
            case EAP_TYPE_EXPANDED_TYPES:
            case EAP_TYPE_EXPERIMENTAL:
            default:
                break;
            }
        }
        break;

    case EAP_FRAME_TYPE_LOGOFF:
    case EAP_FRAME_TYPE_ENCAP_ASF_ALERT:
    default:
        break;
    }
    return;

 trunc:
    ND_PRINT((ndo, ""\n\t[|EAP]""));
}","void
eap_print(netdissect_options *VAR_0,
          register const u_char *VAR_1,
          u_int VAR_2)
{
    const struct eap_frame_t *VAR_3;
    const u_char *VAR_4;
    u_int VAR_5, VAR_6, VAR_7;
    int VAR_8=0, VAR_9;

    VAR_4 = VAR_1;
    VAR_5 = VAR_2;
    VAR_3 = (const struct eap_frame_t *)VAR_1;
    ND_TCHECK(*VAR_3);

    /* COMMENT_0 */
    if (VAR_0->ndo_vflag < 1) {
	ND_PRINT((VAR_0, ""%s (%u) v%u, len %u"",
               tok2str(VAR_10, ""unknown"", VAR_3->type),
               VAR_3->type,
               VAR_3->version,
               EXTRACT_16BITS(VAR_3->length)));
	return;
    }

    ND_PRINT((VAR_0, ""%s (%u) v%u, len %u"",
           tok2str(VAR_10, ""unknown"", VAR_3->type),
           VAR_3->type,
           VAR_3->version,
           EXTRACT_16BITS(VAR_3->length)));

    VAR_4 += sizeof(const struct eap_frame_t);
    VAR_5 -= sizeof(const struct eap_frame_t);

    switch (VAR_3->type) {
    case VAR_11:
        ND_TCHECK_8BITS(VAR_4);
        VAR_6 = *(VAR_4);
        ND_TCHECK_16BITS(VAR_4+2);
        VAR_9 = EXTRACT_16BITS(VAR_4+2);
        ND_PRINT((VAR_0, "", %s (%u), id %u, len %u"",
               tok2str(VAR_12, ""unknown"", VAR_6),
               VAR_6,
               *(VAR_4+1),
               VAR_9));

        ND_TCHECK2(*VAR_4, VAR_9);

        if (VAR_6 <= 2) { /* COMMENT_1 */
            ND_TCHECK_8BITS(VAR_4+4);
            VAR_7 = *(VAR_4+4);
            ND_PRINT((VAR_0, ""\n\t\t Type %s (%u)"",
                   tok2str(VAR_13, ""unknown"", VAR_7),
                   VAR_7));

            switch (VAR_7) {
            case VAR_14:
                if (VAR_9 - 5 > 0) {
                    ND_PRINT((VAR_0, "", Identity: ""));
                    safeputs(VAR_0, VAR_4 + 5, VAR_9 - 5);
                }
                break;

            case VAR_15:
                if (VAR_9 - 5 > 0) {
                    ND_PRINT((VAR_0, "", Notification: ""));
                    safeputs(VAR_0, VAR_4 + 5, VAR_9 - 5);
                }
                break;

            case VAR_16:
                VAR_8 = 5;

                /* COMMENT_2 */
                                                
                                             
                                          
                   
                while (VAR_8 < VAR_9) {
                    ND_TCHECK_8BITS(VAR_4+VAR_8);
                    ND_PRINT((VAR_0, "" %s (%u),"",
                           tok2str(VAR_13, ""unknown"", *(VAR_4+VAR_8)),
                           *(VAR_4 + VAR_8)));
                    VAR_8++;
                }
                break;

            case VAR_17:
            case VAR_18:
                ND_TCHECK_8BITS(VAR_4 + 5);
                if (VAR_7 == VAR_17)
                    ND_PRINT((VAR_0, "" TTLSv%u"",
                           EAP_TTLS_VERSION(*(VAR_4 + 5))));
                ND_PRINT((VAR_0, "" flags [%s] 0x%02x,"",
                       bittok2str(VAR_19, ""none"", *(VAR_4+5)),
                       *(VAR_4 + 5)));

                if (EAP_TLS_EXTRACT_BIT_L(*(VAR_4+5))) {
                    ND_TCHECK_32BITS(VAR_4 + 6);
		    ND_PRINT((VAR_0, "" len %u"", EXTRACT_32BITS(VAR_4 + 6)));
                }
                break;

            case VAR_20:
                ND_TCHECK_8BITS(VAR_4 + 5);
                ND_PRINT((VAR_0, "" FASTv%u"",
                       EAP_TTLS_VERSION(*(VAR_4 + 5))));
                ND_PRINT((VAR_0, "" flags [%s] 0x%02x,"",
                       bittok2str(VAR_19, ""none"", *(VAR_4+5)),
                       *(VAR_4 + 5)));

                if (EAP_TLS_EXTRACT_BIT_L(*(VAR_4+5))) {
                    ND_TCHECK_32BITS(VAR_4 + 6);
                    ND_PRINT((VAR_0, "" len %u"", EXTRACT_32BITS(VAR_4 + 6)));
                }

                /* COMMENT_7 */
                break;

            case VAR_21:
            case VAR_22:
                ND_TCHECK_8BITS(VAR_4 + 5);
                ND_PRINT((VAR_0, "" subtype [%s] 0x%02x,"",
                       tok2str(VAR_23, ""unknown"", *(VAR_4+5)),
                       *(VAR_4 + 5)));

                /* COMMENT_7 */
                break;

            case VAR_24:
            case VAR_25:
            case VAR_26:
            case VAR_27:
            case VAR_28:
            default:
                break;
            }
        }
        break;

    case VAR_29:
    case VAR_30:
    default:
        break;
    }
    return;

 trunc:
    ND_PRINT((VAR_0, ""\n\t[|EAP]""));
}",the-tcpdump-group/tcpdump/985122081165753c7442bd7824c473eb9ff56308/print-eap.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -34,7 +34,9 @@
 
     switch (eap->type) {
     case EAP_FRAME_TYPE_PACKET:
+        ND_TCHECK_8BITS(tptr);
         type = *(tptr);
+        ND_TCHECK_16BITS(tptr+2);
         len = EXTRACT_16BITS(tptr+2);
         ND_PRINT((ndo, "", %s (%u), id %u, len %u"",
                tok2str(eap_code_values, ""unknown"", type),
@@ -45,10 +47,11 @@
         ND_TCHECK2(*tptr, len);
 
         if (type <= 2) { /* For EAP_REQUEST and EAP_RESPONSE only */
+            ND_TCHECK_8BITS(tptr+4);
             subtype = *(tptr+4);
             ND_PRINT((ndo, ""\n\t\t Type %s (%u)"",
-                   tok2str(eap_type_values, ""unknown"", *(tptr+4)),
-                   *(tptr + 4)));
+                   tok2str(eap_type_values, ""unknown"", subtype),
+                   subtype));
 
             switch (subtype) {
             case EAP_TYPE_IDENTITY:
@@ -74,6 +77,7 @@
                  * type one octet per type
                  */
                 while (count < len) {
+                    ND_TCHECK_8BITS(tptr+count);
                     ND_PRINT((ndo, "" %s (%u),"",
                            tok2str(eap_type_values, ""unknown"", *(tptr+count)),
                            *(tptr + count)));
@@ -82,19 +86,23 @@
                 break;
 
             case EAP_TYPE_TTLS:
-                ND_PRINT((ndo, "" TTLSv%u"",
-                       EAP_TTLS_VERSION(*(tptr + 5)))); /* fall through */
             case EAP_TYPE_TLS:
+                ND_TCHECK_8BITS(tptr + 5);
+                if (subtype == EAP_TYPE_TTLS)
+                    ND_PRINT((ndo, "" TTLSv%u"",
+                           EAP_TTLS_VERSION(*(tptr + 5))));
                 ND_PRINT((ndo, "" flags [%s] 0x%02x,"",
                        bittok2str(eap_tls_flags_values, ""none"", *(tptr+5)),
                        *(tptr + 5)));
 
                 if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {
+                    ND_TCHECK_32BITS(tptr + 6);
 		    ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));
                 }
                 break;
 
             case EAP_TYPE_FAST:
+                ND_TCHECK_8BITS(tptr + 5);
                 ND_PRINT((ndo, "" FASTv%u"",
                        EAP_TTLS_VERSION(*(tptr + 5))));
                 ND_PRINT((ndo, "" flags [%s] 0x%02x,"",
@@ -102,6 +110,7 @@
                        *(tptr + 5)));
 
                 if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {
+                    ND_TCHECK_32BITS(tptr + 6);
                     ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));
                 }
 
@@ -110,6 +119,7 @@
 
             case EAP_TYPE_AKA:
             case EAP_TYPE_SIM:
+                ND_TCHECK_8BITS(tptr + 5);
                 ND_PRINT((ndo, "" subtype [%s] 0x%02x,"",
                        tok2str(eap_aka_subtype_values, ""unknown"", *(tptr+5)),
                        *(tptr + 5)));","{'deleted_lines': ['                   tok2str(eap_type_values, ""unknown"", *(tptr+4)),', '                   *(tptr + 4)));', '                ND_PRINT((ndo, "" TTLSv%u"",', '                       EAP_TTLS_VERSION(*(tptr + 5)))); /* fall through */'], 'added_lines': ['        ND_TCHECK_8BITS(tptr);', '        ND_TCHECK_16BITS(tptr+2);', '            ND_TCHECK_8BITS(tptr+4);', '                   tok2str(eap_type_values, ""unknown"", subtype),', '                   subtype));', '                    ND_TCHECK_8BITS(tptr+count);', '                ND_TCHECK_8BITS(tptr + 5);', '                if (subtype == EAP_TYPE_TTLS)', '                    ND_PRINT((ndo, "" TTLSv%u"",', '                           EAP_TTLS_VERSION(*(tptr + 5))));', '                    ND_TCHECK_32BITS(tptr + 6);', '                ND_TCHECK_8BITS(tptr + 5);', '                    ND_TCHECK_32BITS(tptr + 6);', '                ND_TCHECK_8BITS(tptr + 5);']}",True,The EAP parser in tcpdump before 4.9.2 has a buffer over-read in print-eap.c:eap_print().,9.8,CRITICAL,3,test,2017-03-16T19:02:20Z,1
CVE-2017-13017,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-13017/DHCPv6: Add a missing option length check.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't be rejected as an invalid capture.",11b426ee05eb62ed103218526f1fa616851c43ce,https://github.com/the-tcpdump-group/tcpdump/commit/11b426ee05eb62ed103218526f1fa616851c43ce,print-dhcp6.c,dhcp6opt_print,"static void
dhcp6opt_print(netdissect_options *ndo,
const u_char *cp, const u_char *ep)
{
const struct dhcp6opt *dh6o;
const u_char *tp;
size_t i;
uint16_t opttype;
size_t optlen;
uint8_t auth_proto;
u_int authinfolen, authrealmlen;
int remain_len;  
int label_len;   
uint16_t subopt_code;
uint16_t subopt_len;
if (cp == ep)
return;
while (cp < ep) {
if (ep < cp + sizeof(*dh6o))
goto trunc;
dh6o = (const struct dhcp6opt *)cp;
ND_TCHECK(*dh6o);
optlen = EXTRACT_16BITS(&dh6o->dh6opt_len);
if (ep < cp + sizeof(*dh6o) + optlen)
goto trunc;
opttype = EXTRACT_16BITS(&dh6o->dh6opt_type);
ND_PRINT((ndo, "" (%s"", tok2str(dh6opt_str, ""opt_%u"", opttype)));
ND_TCHECK2(*(cp + sizeof(*dh6o)), optlen);
switch (opttype) {
case DH6OPT_CLIENTID:
case DH6OPT_SERVERID:
if (optlen < 2) {
ND_PRINT((ndo, "" ?)""));
break;
}
tp = (const u_char *)(dh6o + 1);
switch (EXTRACT_16BITS(tp)) {
case 1:
if (optlen >= 2 + 6) {
ND_PRINT((ndo, "" hwaddr/time type %u time %u "",
EXTRACT_16BITS(&tp[2]),
EXTRACT_32BITS(&tp[4])));
for (i = 8; i < optlen; i++)
ND_PRINT((ndo, ""%02x"", tp[i]));
ND_PRINT((ndo, "")""));
} else {
ND_PRINT((ndo, "" ?)""));
}
break;
case 2:
if (optlen >= 2 + 8) {
ND_PRINT((ndo, "" vid ""));
for (i = 2; i < 2 + 8; i++)
ND_PRINT((ndo, ""%02x"", tp[i]));
ND_PRINT((ndo, "")""));
} else {
ND_PRINT((ndo, "" ?)""));
}
break;
case 3:
if (optlen >= 2 + 2) {
ND_PRINT((ndo, "" hwaddr type %u "",
EXTRACT_16BITS(&tp[2])));
for (i = 4; i < optlen; i++)
ND_PRINT((ndo, ""%02x"", tp[i]));
ND_PRINT((ndo, "")""));
} else {
ND_PRINT((ndo, "" ?)""));
}
break;
default:
ND_PRINT((ndo, "" type %d)"", EXTRACT_16BITS(tp)));
break;
}
break;
case DH6OPT_IA_ADDR:
if (optlen < 24) {
ND_PRINT((ndo, "" ?)""));
break;
}
tp = (const u_char *)(dh6o + 1);
ND_PRINT((ndo, "" %s"", ip6addr_string(ndo, &tp[0])));
ND_PRINT((ndo, "" pltime:%u vltime:%u"",
EXTRACT_32BITS(&tp[16]),
EXTRACT_32BITS(&tp[20])));
if (optlen > 24) {
dhcp6opt_print(ndo, tp + 24, tp + optlen);
}
ND_PRINT((ndo, "")""));
break;
case DH6OPT_ORO:
case DH6OPT_ERO:
if (optlen % 2) {
ND_PRINT((ndo, "" ?)""));
break;
}
tp = (const u_char *)(dh6o + 1);
for (i = 0; i < optlen; i += 2) {
ND_PRINT((ndo, "" %s"",
tok2str(dh6opt_str, ""opt_%u"", EXTRACT_16BITS(&tp[i]))));
}
ND_PRINT((ndo, "")""));
break;
case DH6OPT_PREFERENCE:
if (optlen != 1) {
ND_PRINT((ndo, "" ?)""));
break;
}
tp = (const u_char *)(dh6o + 1);
ND_PRINT((ndo, "" %d)"", *tp));
break;
case DH6OPT_ELAPSED_TIME:
if (optlen != 2) {
ND_PRINT((ndo, "" ?)""));
break;
}
tp = (const u_char *)(dh6o + 1);
ND_PRINT((ndo, "" %d)"", EXTRACT_16BITS(tp)));
break;
case DH6OPT_RELAY_MSG:
ND_PRINT((ndo, "" (""));
tp = (const u_char *)(dh6o + 1);
dhcp6_print(ndo, tp, optlen);
ND_PRINT((ndo, "")""));
break;
case DH6OPT_AUTH:
if (optlen < 11) {
ND_PRINT((ndo, "" ?)""));
break;
}
tp = (const u_char *)(dh6o + 1);
auth_proto = *tp;
switch (auth_proto) {
case DH6OPT_AUTHPROTO_DELAYED:
ND_PRINT((ndo, "" proto: delayed""));
break;
case DH6OPT_AUTHPROTO_RECONFIG:
ND_PRINT((ndo, "" proto: reconfigure""));
break;
default:
ND_PRINT((ndo, "" proto: %d"", auth_proto));
break;
}
tp++;
switch (*tp) {
case DH6OPT_AUTHALG_HMACMD5:
ND_PRINT((ndo, "", alg: HMAC-MD5""));
break;
default:
ND_PRINT((ndo, "", alg: %d"", *tp));
break;
}
tp++;
switch (*tp) {
case DH6OPT_AUTHRDM_MONOCOUNTER:
ND_PRINT((ndo, "", RDM: mono""));
break;
default:
ND_PRINT((ndo, "", RDM: %d"", *tp));
break;
}
tp++;
ND_PRINT((ndo, "", RD:""));
for (i = 0; i < 4; i++, tp += 2)
ND_PRINT((ndo, "" %04x"", EXTRACT_16BITS(tp)));
authinfolen = optlen - 11;
switch (auth_proto) {
case DH6OPT_AUTHPROTO_DELAYED:
if (authinfolen == 0)
break;
if (authinfolen < 20) {
ND_PRINT((ndo, "" ??""));
break;
}
authrealmlen = authinfolen - 20;
if (authrealmlen > 0) {
ND_PRINT((ndo, "", realm: ""));
}
for (i = 0; i < authrealmlen; i++, tp++)
ND_PRINT((ndo, ""%02x"", *tp));
ND_PRINT((ndo, "", key ID: %08x"", EXTRACT_32BITS(tp)));
tp += 4;
ND_PRINT((ndo, "", HMAC-MD5:""));
for (i = 0; i < 4; i++, tp+= 4)
ND_PRINT((ndo, "" %08x"", EXTRACT_32BITS(tp)));
break;
case DH6OPT_AUTHPROTO_RECONFIG:
if (authinfolen != 17) {
ND_PRINT((ndo, "" ??""));
break;
}
switch (*tp++) {
case DH6OPT_AUTHRECONFIG_KEY:
ND_PRINT((ndo, "" reconfig-key""));
break;
case DH6OPT_AUTHRECONFIG_HMACMD5:
ND_PRINT((ndo, "" type: HMAC-MD5""));
break;
default:
ND_PRINT((ndo, "" type: ??""));
break;
}
ND_PRINT((ndo, "" value:""));
for (i = 0; i < 4; i++, tp+= 4)
ND_PRINT((ndo, "" %08x"", EXTRACT_32BITS(tp)));
break;
default:
ND_PRINT((ndo, "" ??""));
break;
}
ND_PRINT((ndo, "")""));
break;
case DH6OPT_RAPID_COMMIT: 
ND_PRINT((ndo, "")""));
break;
case DH6OPT_INTERFACE_ID:
case DH6OPT_SUBSCRIBER_ID:
tp = (const u_char *)(dh6o + 1);
ND_PRINT((ndo, "" ""));
for (i = 0; i < optlen && i < 10; i++)
ND_PRINT((ndo, ""%02x"", tp[i]));
ND_PRINT((ndo, ""...)""));
break;
case DH6OPT_RECONF_MSG:
tp = (const u_char *)(dh6o + 1);
switch (*tp) {
case DH6_RENEW:
ND_PRINT((ndo, "" for renew)""));
break;
case DH6_INFORM_REQ:
ND_PRINT((ndo, "" for inf-req)""));
break;
default:
ND_PRINT((ndo, "" for ?\?\?(%02x))"", *tp));
break;
}
break;
case DH6OPT_RECONF_ACCEPT: 
ND_PRINT((ndo, "")""));
break;
case DH6OPT_SIP_SERVER_A:
case DH6OPT_DNS_SERVERS:
case DH6OPT_SNTP_SERVERS:
case DH6OPT_NIS_SERVERS:
case DH6OPT_NISP_SERVERS:
case DH6OPT_BCMCS_SERVER_A:
case DH6OPT_PANA_AGENT:
case DH6OPT_LQ_CLIENT_LINK:
if (optlen % 16) {
ND_PRINT((ndo, "" ?)""));
break;
}
tp = (const u_char *)(dh6o + 1);
for (i = 0; i < optlen; i += 16)
ND_PRINT((ndo, "" %s"", ip6addr_string(ndo, &tp[i])));
ND_PRINT((ndo, "")""));
break;
case DH6OPT_SIP_SERVER_D:
case DH6OPT_DOMAIN_LIST:
tp = (const u_char *)(dh6o + 1);
while (tp < cp + sizeof(*dh6o) + optlen) {
ND_PRINT((ndo, "" ""));
if ((tp = ns_nprint(ndo, tp, cp + sizeof(*dh6o) + optlen)) == NULL)
goto trunc;
}
ND_PRINT((ndo, "")""));
break;
case DH6OPT_STATUS_CODE:
if (optlen < 2) {
ND_PRINT((ndo, "" ?)""));
break;
}
tp = (const u_char *)(dh6o + 1);
ND_PRINT((ndo, "" %s)"", dhcp6stcode(EXTRACT_16BITS(&tp[0]))));
break;
case DH6OPT_IA_NA:
case DH6OPT_IA_PD:
if (optlen < 12) {
ND_PRINT((ndo, "" ?)""));
break;
}
tp = (const u_char *)(dh6o + 1);
ND_PRINT((ndo, "" IAID:%u T1:%u T2:%u"",
EXTRACT_32BITS(&tp[0]),
EXTRACT_32BITS(&tp[4]),
EXTRACT_32BITS(&tp[8])));
if (optlen > 12) {
dhcp6opt_print(ndo, tp + 12, tp + optlen);
}
ND_PRINT((ndo, "")""));
break;
case DH6OPT_IA_TA:
if (optlen < 4) {
ND_PRINT((ndo, "" ?)""));
break;
}
tp = (const u_char *)(dh6o + 1);
ND_PRINT((ndo, "" IAID:%u"", EXTRACT_32BITS(tp)));
if (optlen > 4) {
dhcp6opt_print(ndo, tp + 4, tp + optlen);
}
ND_PRINT((ndo, "")""));
break;
case DH6OPT_IA_PD_PREFIX:
if (optlen < 25) {
ND_PRINT((ndo, "" ?)""));
break;
}
tp = (const u_char *)(dh6o + 1);
ND_PRINT((ndo, "" %s/%d"", ip6addr_string(ndo, &tp[9]), tp[8]));
ND_PRINT((ndo, "" pltime:%u vltime:%u"",
EXTRACT_32BITS(&tp[0]),
EXTRACT_32BITS(&tp[4])));
if (optlen > 25) {
dhcp6opt_print(ndo, tp + 25, tp + optlen);
}
ND_PRINT((ndo, "")""));
break;
case DH6OPT_LIFETIME:
case DH6OPT_CLT_TIME:
if (optlen != 4) {
ND_PRINT((ndo, "" ?)""));
break;
}
tp = (const u_char *)(dh6o + 1);
ND_PRINT((ndo, "" %d)"", EXTRACT_32BITS(tp)));
break;
case DH6OPT_REMOTE_ID:
if (optlen < 4) {
ND_PRINT((ndo, "" ?)""));
break;
}
tp = (const u_char *)(dh6o + 1);
ND_PRINT((ndo, "" %d "", EXTRACT_32BITS(tp)));
for (i = 4; i < optlen && i < 14; i++)
ND_PRINT((ndo, ""%02x"", tp[i]));
ND_PRINT((ndo, ""...)""));
break;
case DH6OPT_LQ_QUERY:
if (optlen < 17) {
ND_PRINT((ndo, "" ?)""));
break;
}
tp = (const u_char *)(dh6o + 1);
switch (*tp) {
case 1:
ND_PRINT((ndo, "" by-address""));
break;
case 2:
ND_PRINT((ndo, "" by-clientID""));
break;
default:
ND_PRINT((ndo, "" type_%d"", (int)*tp));
break;
}
ND_PRINT((ndo, "" %s"", ip6addr_string(ndo, &tp[1])));
if (optlen > 17) {
dhcp6opt_print(ndo, tp + 17, tp + optlen);
}
ND_PRINT((ndo, "")""));
break;
case DH6OPT_CLIENT_DATA:
tp = (const u_char *)(dh6o + 1);
if (optlen > 0) {
dhcp6opt_print(ndo, tp, tp + optlen);
}
ND_PRINT((ndo, "")""));
break;
case DH6OPT_LQ_RELAY_DATA:
if (optlen < 16) {
ND_PRINT((ndo, "" ?)""));
break;
}
tp = (const u_char *)(dh6o + 1);
ND_PRINT((ndo, "" %s "", ip6addr_string(ndo, &tp[0])));
for (i = 16; i < optlen && i < 26; i++)
ND_PRINT((ndo, ""%02x"", tp[i]));
ND_PRINT((ndo, ""...)""));
break;
case DH6OPT_NTP_SERVER:
if (optlen < 4) {
ND_PRINT((ndo, "" ?)""));
break;
}
tp = (const u_char *)(dh6o + 1);
while (tp < cp + sizeof(*dh6o) + optlen - 4) {
subopt_code = EXTRACT_16BITS(tp);
tp += 2;
subopt_len = EXTRACT_16BITS(tp);
tp += 2;
if (tp + subopt_len > cp + sizeof(*dh6o) + optlen)
goto trunc;
ND_PRINT((ndo, "" subopt:%d"", subopt_code));
switch (subopt_code) {
case DH6OPT_NTP_SUBOPTION_SRV_ADDR:
case DH6OPT_NTP_SUBOPTION_MC_ADDR:
if (subopt_len != 16) {
ND_PRINT((ndo, "" ?""));
break;
}
ND_PRINT((ndo, "" %s"", ip6addr_string(ndo, &tp[0])));
break;
case DH6OPT_NTP_SUBOPTION_SRV_FQDN:
ND_PRINT((ndo, "" ""));
if (ns_nprint(ndo, tp, tp + subopt_len) == NULL)
goto trunc;
break;
default:
ND_PRINT((ndo, "" ?""));
break;
}
tp += subopt_len;
}
ND_PRINT((ndo, "")""));
break;
case DH6OPT_AFTR_NAME:
if (optlen < 3) {
ND_PRINT((ndo, "" ?)""));
break;
}
tp = (const u_char *)(dh6o + 1);
remain_len = optlen;
ND_PRINT((ndo, "" ""));
while (remain_len && *tp) {
label_len =  *tp++;
if (label_len < remain_len - 1) {
(void)fn_printn(ndo, tp, label_len, NULL);
tp += label_len;
remain_len -= (label_len + 1);
if(*tp) ND_PRINT((ndo, "".""));
} else {
ND_PRINT((ndo, "" ?""));
break;
}
}
ND_PRINT((ndo, "")""));
break;
case DH6OPT_NEW_POSIX_TIMEZONE: 
case DH6OPT_NEW_TZDB_TIMEZONE:
case DH6OPT_MUDURL:
if (optlen < 5) {
ND_PRINT((ndo, "" ?)""));
break;
}
tp = (const u_char *)(dh6o + 1);
ND_PRINT((ndo, ""=""));
(void)fn_printn(ndo, tp, (u_int)optlen, NULL);
ND_PRINT((ndo, "")""));
break;
default:
ND_PRINT((ndo, "")""));
break;
}
cp += sizeof(*dh6o) + optlen;
}
return;
trunc:
ND_PRINT((ndo, ""[|dhcp6ext]""));
}","static void
dhcp6opt_print(netdissect_options *VAR_0,
const u_char *VAR_1, const u_char *VAR_2)
{
const struct dhcp6opt *VAR_3;
const u_char *VAR_4;
size_t VAR_5;
uint16_t VAR_6;
size_t VAR_7;
uint8_t VAR_8;
u_int VAR_9, VAR_10;
int VAR_11;  
int VAR_12;   
uint16_t VAR_13;
uint16_t VAR_14;
if (VAR_1 == VAR_2)
return;
while (VAR_1 < VAR_2) {
if (VAR_2 < VAR_1 + sizeof(*VAR_3))
goto trunc;
VAR_3 = (const struct dhcp6opt *)VAR_1;
ND_TCHECK(*VAR_3);
VAR_7 = EXTRACT_16BITS(&VAR_3->dh6opt_len);
if (VAR_2 < VAR_1 + sizeof(*VAR_3) + VAR_7)
goto trunc;
VAR_6 = EXTRACT_16BITS(&VAR_3->dh6opt_type);
ND_PRINT((VAR_0, "" (%s"", tok2str(VAR_15, ""opt_%u"", VAR_6)));
ND_TCHECK2(*(VAR_1 + sizeof(*VAR_3)), VAR_7);
switch (VAR_6) {
case VAR_16:
case VAR_17:
if (VAR_7 < 2) {
ND_PRINT((VAR_0, "" ?)""));
break;
}
VAR_4 = (const u_char *)(VAR_3 + 1);
switch (EXTRACT_16BITS(VAR_4)) {
case 1:
if (VAR_7 >= 2 + 6) {
ND_PRINT((VAR_0, "" hwaddr/time type %u time %u "",
EXTRACT_16BITS(&VAR_4[2]),
EXTRACT_32BITS(&VAR_4[4])));
for (VAR_5 = 8; VAR_5 < VAR_7; VAR_5++)
ND_PRINT((VAR_0, ""%02x"", VAR_4[VAR_5]));
ND_PRINT((VAR_0, "")""));
} else {
ND_PRINT((VAR_0, "" ?)""));
}
break;
case 2:
if (VAR_7 >= 2 + 8) {
ND_PRINT((VAR_0, "" vid ""));
for (VAR_5 = 2; VAR_5 < 2 + 8; VAR_5++)
ND_PRINT((VAR_0, ""%02x"", VAR_4[VAR_5]));
ND_PRINT((VAR_0, "")""));
} else {
ND_PRINT((VAR_0, "" ?)""));
}
break;
case 3:
if (VAR_7 >= 2 + 2) {
ND_PRINT((VAR_0, "" hwaddr type %u "",
EXTRACT_16BITS(&VAR_4[2])));
for (VAR_5 = 4; VAR_5 < VAR_7; VAR_5++)
ND_PRINT((VAR_0, ""%02x"", VAR_4[VAR_5]));
ND_PRINT((VAR_0, "")""));
} else {
ND_PRINT((VAR_0, "" ?)""));
}
break;
default:
ND_PRINT((VAR_0, "" type %d)"", EXTRACT_16BITS(VAR_4)));
break;
}
break;
case VAR_18:
if (VAR_7 < 24) {
ND_PRINT((VAR_0, "" ?)""));
break;
}
VAR_4 = (const u_char *)(VAR_3 + 1);
ND_PRINT((VAR_0, "" %s"", ip6addr_string(VAR_0, &VAR_4[0])));
ND_PRINT((VAR_0, "" pltime:%u vltime:%u"",
EXTRACT_32BITS(&VAR_4[16]),
EXTRACT_32BITS(&VAR_4[20])));
if (VAR_7 > 24) {
dhcp6opt_print(VAR_0, VAR_4 + 24, VAR_4 + VAR_7);
}
ND_PRINT((VAR_0, "")""));
break;
case VAR_19:
case VAR_20:
if (VAR_7 % 2) {
ND_PRINT((VAR_0, "" ?)""));
break;
}
VAR_4 = (const u_char *)(VAR_3 + 1);
for (VAR_5 = 0; VAR_5 < VAR_7; VAR_5 += 2) {
ND_PRINT((VAR_0, "" %s"",
tok2str(VAR_15, ""opt_%u"", EXTRACT_16BITS(&VAR_4[VAR_5]))));
}
ND_PRINT((VAR_0, "")""));
break;
case VAR_21:
if (VAR_7 != 1) {
ND_PRINT((VAR_0, "" ?)""));
break;
}
VAR_4 = (const u_char *)(VAR_3 + 1);
ND_PRINT((VAR_0, "" %d)"", *VAR_4));
break;
case VAR_22:
if (VAR_7 != 2) {
ND_PRINT((VAR_0, "" ?)""));
break;
}
VAR_4 = (const u_char *)(VAR_3 + 1);
ND_PRINT((VAR_0, "" %d)"", EXTRACT_16BITS(VAR_4)));
break;
case VAR_23:
ND_PRINT((VAR_0, "" (""));
VAR_4 = (const u_char *)(VAR_3 + 1);
dhcp6_print(VAR_0, VAR_4, VAR_7);
ND_PRINT((VAR_0, "")""));
break;
case VAR_24:
if (VAR_7 < 11) {
ND_PRINT((VAR_0, "" ?)""));
break;
}
VAR_4 = (const u_char *)(VAR_3 + 1);
VAR_8 = *VAR_4;
switch (VAR_8) {
case VAR_25:
ND_PRINT((VAR_0, "" proto: delayed""));
break;
case VAR_26:
ND_PRINT((VAR_0, "" proto: reconfigure""));
break;
default:
ND_PRINT((VAR_0, "" proto: %d"", VAR_8));
break;
}
VAR_4++;
switch (*VAR_4) {
case VAR_27:
ND_PRINT((VAR_0, "", alg: HMAC-MD5""));
break;
default:
ND_PRINT((VAR_0, "", alg: %d"", *VAR_4));
break;
}
VAR_4++;
switch (*VAR_4) {
case VAR_28:
ND_PRINT((VAR_0, "", RDM: mono""));
break;
default:
ND_PRINT((VAR_0, "", RDM: %d"", *VAR_4));
break;
}
VAR_4++;
ND_PRINT((VAR_0, "", RD:""));
for (VAR_5 = 0; VAR_5 < 4; VAR_5++, VAR_4 += 2)
ND_PRINT((VAR_0, "" %04x"", EXTRACT_16BITS(VAR_4)));
VAR_9 = VAR_7 - 11;
switch (VAR_8) {
case VAR_25:
if (VAR_9 == 0)
break;
if (VAR_9 < 20) {
ND_PRINT((VAR_0, "" ??""));
break;
}
VAR_10 = VAR_9 - 20;
if (VAR_10 > 0) {
ND_PRINT((VAR_0, "", realm: ""));
}
for (VAR_5 = 0; VAR_5 < VAR_10; VAR_5++, VAR_4++)
ND_PRINT((VAR_0, ""%02x"", *VAR_4));
ND_PRINT((VAR_0, "", key ID: %08x"", EXTRACT_32BITS(VAR_4)));
VAR_4 += 4;
ND_PRINT((VAR_0, "", HMAC-MD5:""));
for (VAR_5 = 0; VAR_5 < 4; VAR_5++, VAR_4+= 4)
ND_PRINT((VAR_0, "" %08x"", EXTRACT_32BITS(VAR_4)));
break;
case VAR_26:
if (VAR_9 != 17) {
ND_PRINT((VAR_0, "" ??""));
break;
}
switch (*VAR_4++) {
case VAR_29:
ND_PRINT((VAR_0, "" reconfig-key""));
break;
case VAR_30:
ND_PRINT((VAR_0, "" type: HMAC-MD5""));
break;
default:
ND_PRINT((VAR_0, "" type: ??""));
break;
}
ND_PRINT((VAR_0, "" value:""));
for (VAR_5 = 0; VAR_5 < 4; VAR_5++, VAR_4+= 4)
ND_PRINT((VAR_0, "" %08x"", EXTRACT_32BITS(VAR_4)));
break;
default:
ND_PRINT((VAR_0, "" ??""));
break;
}
ND_PRINT((VAR_0, "")""));
break;
case VAR_31: 
ND_PRINT((VAR_0, "")""));
break;
case VAR_32:
case VAR_33:
VAR_4 = (const u_char *)(VAR_3 + 1);
ND_PRINT((VAR_0, "" ""));
for (VAR_5 = 0; VAR_5 < VAR_7 && VAR_5 < 10; VAR_5++)
ND_PRINT((VAR_0, ""%02x"", VAR_4[VAR_5]));
ND_PRINT((VAR_0, ""...)""));
break;
case VAR_34:
VAR_4 = (const u_char *)(VAR_3 + 1);
switch (*VAR_4) {
case VAR_35:
ND_PRINT((VAR_0, "" for renew)""));
break;
case VAR_36:
ND_PRINT((VAR_0, "" for inf-req)""));
break;
default:
ND_PRINT((VAR_0, "" for ?\?\?(%02x))"", *VAR_4));
break;
}
break;
case VAR_37: 
ND_PRINT((VAR_0, "")""));
break;
case VAR_38:
case VAR_39:
case VAR_40:
case VAR_41:
case VAR_42:
case VAR_43:
case VAR_44:
case VAR_45:
if (VAR_7 % 16) {
ND_PRINT((VAR_0, "" ?)""));
break;
}
VAR_4 = (const u_char *)(VAR_3 + 1);
for (VAR_5 = 0; VAR_5 < VAR_7; VAR_5 += 16)
ND_PRINT((VAR_0, "" %s"", ip6addr_string(VAR_0, &VAR_4[VAR_5])));
ND_PRINT((VAR_0, "")""));
break;
case VAR_46:
case VAR_47:
VAR_4 = (const u_char *)(VAR_3 + 1);
while (VAR_4 < VAR_1 + sizeof(*VAR_3) + VAR_7) {
ND_PRINT((VAR_0, "" ""));
if ((VAR_4 = ns_nprint(VAR_0, VAR_4, VAR_1 + sizeof(*VAR_3) + VAR_7)) == NULL)
goto trunc;
}
ND_PRINT((VAR_0, "")""));
break;
case VAR_48:
if (VAR_7 < 2) {
ND_PRINT((VAR_0, "" ?)""));
break;
}
VAR_4 = (const u_char *)(VAR_3 + 1);
ND_PRINT((VAR_0, "" %s)"", dhcp6stcode(EXTRACT_16BITS(&VAR_4[0]))));
break;
case VAR_49:
case VAR_50:
if (VAR_7 < 12) {
ND_PRINT((VAR_0, "" ?)""));
break;
}
VAR_4 = (const u_char *)(VAR_3 + 1);
ND_PRINT((VAR_0, "" IAID:%u T1:%u T2:%u"",
EXTRACT_32BITS(&VAR_4[0]),
EXTRACT_32BITS(&VAR_4[4]),
EXTRACT_32BITS(&VAR_4[8])));
if (VAR_7 > 12) {
dhcp6opt_print(VAR_0, VAR_4 + 12, VAR_4 + VAR_7);
}
ND_PRINT((VAR_0, "")""));
break;
case VAR_51:
if (VAR_7 < 4) {
ND_PRINT((VAR_0, "" ?)""));
break;
}
VAR_4 = (const u_char *)(VAR_3 + 1);
ND_PRINT((VAR_0, "" IAID:%u"", EXTRACT_32BITS(VAR_4)));
if (VAR_7 > 4) {
dhcp6opt_print(VAR_0, VAR_4 + 4, VAR_4 + VAR_7);
}
ND_PRINT((VAR_0, "")""));
break;
case VAR_52:
if (VAR_7 < 25) {
ND_PRINT((VAR_0, "" ?)""));
break;
}
VAR_4 = (const u_char *)(VAR_3 + 1);
ND_PRINT((VAR_0, "" %s/%d"", ip6addr_string(VAR_0, &VAR_4[9]), VAR_4[8]));
ND_PRINT((VAR_0, "" pltime:%u vltime:%u"",
EXTRACT_32BITS(&VAR_4[0]),
EXTRACT_32BITS(&VAR_4[4])));
if (VAR_7 > 25) {
dhcp6opt_print(VAR_0, VAR_4 + 25, VAR_4 + VAR_7);
}
ND_PRINT((VAR_0, "")""));
break;
case VAR_53:
case VAR_54:
if (VAR_7 != 4) {
ND_PRINT((VAR_0, "" ?)""));
break;
}
VAR_4 = (const u_char *)(VAR_3 + 1);
ND_PRINT((VAR_0, "" %d)"", EXTRACT_32BITS(VAR_4)));
break;
case VAR_55:
if (VAR_7 < 4) {
ND_PRINT((VAR_0, "" ?)""));
break;
}
VAR_4 = (const u_char *)(VAR_3 + 1);
ND_PRINT((VAR_0, "" %d "", EXTRACT_32BITS(VAR_4)));
for (VAR_5 = 4; VAR_5 < VAR_7 && VAR_5 < 14; VAR_5++)
ND_PRINT((VAR_0, ""%02x"", VAR_4[VAR_5]));
ND_PRINT((VAR_0, ""...)""));
break;
case VAR_56:
if (VAR_7 < 17) {
ND_PRINT((VAR_0, "" ?)""));
break;
}
VAR_4 = (const u_char *)(VAR_3 + 1);
switch (*VAR_4) {
case 1:
ND_PRINT((VAR_0, "" by-address""));
break;
case 2:
ND_PRINT((VAR_0, "" by-clientID""));
break;
default:
ND_PRINT((VAR_0, "" type_%d"", (int)*VAR_4));
break;
}
ND_PRINT((VAR_0, "" %s"", ip6addr_string(VAR_0, &VAR_4[1])));
if (VAR_7 > 17) {
dhcp6opt_print(VAR_0, VAR_4 + 17, VAR_4 + VAR_7);
}
ND_PRINT((VAR_0, "")""));
break;
case VAR_57:
VAR_4 = (const u_char *)(VAR_3 + 1);
if (VAR_7 > 0) {
dhcp6opt_print(VAR_0, VAR_4, VAR_4 + VAR_7);
}
ND_PRINT((VAR_0, "")""));
break;
case VAR_58:
if (VAR_7 < 16) {
ND_PRINT((VAR_0, "" ?)""));
break;
}
VAR_4 = (const u_char *)(VAR_3 + 1);
ND_PRINT((VAR_0, "" %s "", ip6addr_string(VAR_0, &VAR_4[0])));
for (VAR_5 = 16; VAR_5 < VAR_7 && VAR_5 < 26; VAR_5++)
ND_PRINT((VAR_0, ""%02x"", VAR_4[VAR_5]));
ND_PRINT((VAR_0, ""...)""));
break;
case VAR_59:
if (VAR_7 < 4) {
ND_PRINT((VAR_0, "" ?)""));
break;
}
VAR_4 = (const u_char *)(VAR_3 + 1);
while (VAR_4 < VAR_1 + sizeof(*VAR_3) + VAR_7 - 4) {
VAR_13 = EXTRACT_16BITS(VAR_4);
VAR_4 += 2;
VAR_14 = EXTRACT_16BITS(VAR_4);
VAR_4 += 2;
if (VAR_4 + VAR_14 > VAR_1 + sizeof(*VAR_3) + VAR_7)
goto trunc;
ND_PRINT((VAR_0, "" subopt:%d"", VAR_13));
switch (VAR_13) {
case VAR_60:
case VAR_61:
if (VAR_14 != 16) {
ND_PRINT((VAR_0, "" ?""));
break;
}
ND_PRINT((VAR_0, "" %s"", ip6addr_string(VAR_0, &VAR_4[0])));
break;
case VAR_62:
ND_PRINT((VAR_0, "" ""));
if (ns_nprint(VAR_0, VAR_4, VAR_4 + VAR_14) == NULL)
goto trunc;
break;
default:
ND_PRINT((VAR_0, "" ?""));
break;
}
VAR_4 += VAR_14;
}
ND_PRINT((VAR_0, "")""));
break;
case VAR_63:
if (VAR_7 < 3) {
ND_PRINT((VAR_0, "" ?)""));
break;
}
VAR_4 = (const u_char *)(VAR_3 + 1);
VAR_11 = VAR_7;
ND_PRINT((VAR_0, "" ""));
while (VAR_11 && *VAR_4) {
VAR_12 =  *VAR_4++;
if (VAR_12 < VAR_11 - 1) {
(void)fn_printn(VAR_0, VAR_4, VAR_12, NULL);
VAR_4 += VAR_12;
VAR_11 -= (VAR_12 + 1);
if(*VAR_4) ND_PRINT((VAR_0, "".""));
} else {
ND_PRINT((VAR_0, "" ?""));
break;
}
}
ND_PRINT((VAR_0, "")""));
break;
case VAR_64: 
case VAR_65:
case VAR_66:
if (VAR_7 < 5) {
ND_PRINT((VAR_0, "" ?)""));
break;
}
VAR_4 = (const u_char *)(VAR_3 + 1);
ND_PRINT((VAR_0, ""=""));
(void)fn_printn(VAR_0, VAR_4, (u_int)VAR_7, NULL);
ND_PRINT((VAR_0, "")""));
break;
default:
ND_PRINT((VAR_0, "")""));
break;
}
VAR_1 += sizeof(*VAR_3) + VAR_7;
}
return;
trunc:
ND_PRINT((VAR_0, ""[|dhcp6ext]""));
}",the-tcpdump-group/tcpdump/11b426ee05eb62ed103218526f1fa616851c43ce/print-dhcp6.c/vul/before/0.json,"static void
dhcp6opt_print(netdissect_options *ndo,
               const u_char *cp, const u_char *ep)
{
	const struct dhcp6opt *dh6o;
	const u_char *tp;
	size_t i;
	uint16_t opttype;
	size_t optlen;
	uint8_t auth_proto;
	u_int authinfolen, authrealmlen;
	int remain_len;  /* Length of remaining options */
	int label_len;   /* Label length */
	uint16_t subopt_code;
	uint16_t subopt_len;

	if (cp == ep)
		return;
	while (cp < ep) {
		if (ep < cp + sizeof(*dh6o))
			goto trunc;
		dh6o = (const struct dhcp6opt *)cp;
		ND_TCHECK(*dh6o);
		optlen = EXTRACT_16BITS(&dh6o->dh6opt_len);
		if (ep < cp + sizeof(*dh6o) + optlen)
			goto trunc;
		opttype = EXTRACT_16BITS(&dh6o->dh6opt_type);
		ND_PRINT((ndo, "" (%s"", tok2str(dh6opt_str, ""opt_%u"", opttype)));
		ND_TCHECK2(*(cp + sizeof(*dh6o)), optlen);
		switch (opttype) {
		case DH6OPT_CLIENTID:
		case DH6OPT_SERVERID:
			if (optlen < 2) {
				/*(*/
				ND_PRINT((ndo, "" ?)""));
				break;
			}
			tp = (const u_char *)(dh6o + 1);
			switch (EXTRACT_16BITS(tp)) {
			case 1:
				if (optlen >= 2 + 6) {
					ND_PRINT((ndo, "" hwaddr/time type %u time %u "",
					    EXTRACT_16BITS(&tp[2]),
					    EXTRACT_32BITS(&tp[4])));
					for (i = 8; i < optlen; i++)
						ND_PRINT((ndo, ""%02x"", tp[i]));
					/*(*/
					ND_PRINT((ndo, "")""));
				} else {
					/*(*/
					ND_PRINT((ndo, "" ?)""));
				}
				break;
			case 2:
				if (optlen >= 2 + 8) {
					ND_PRINT((ndo, "" vid ""));
					for (i = 2; i < 2 + 8; i++)
						ND_PRINT((ndo, ""%02x"", tp[i]));
					/*(*/
					ND_PRINT((ndo, "")""));
				} else {
					/*(*/
					ND_PRINT((ndo, "" ?)""));
				}
				break;
			case 3:
				if (optlen >= 2 + 2) {
					ND_PRINT((ndo, "" hwaddr type %u "",
					    EXTRACT_16BITS(&tp[2])));
					for (i = 4; i < optlen; i++)
						ND_PRINT((ndo, ""%02x"", tp[i]));
					/*(*/
					ND_PRINT((ndo, "")""));
				} else {
					/*(*/
					ND_PRINT((ndo, "" ?)""));
				}
				break;
			default:
				ND_PRINT((ndo, "" type %d)"", EXTRACT_16BITS(tp)));
				break;
			}
			break;
		case DH6OPT_IA_ADDR:
			if (optlen < 24) {
				/*(*/
				ND_PRINT((ndo, "" ?)""));
				break;
			}
			tp = (const u_char *)(dh6o + 1);
			ND_PRINT((ndo, "" %s"", ip6addr_string(ndo, &tp[0])));
			ND_PRINT((ndo, "" pltime:%u vltime:%u"",
			    EXTRACT_32BITS(&tp[16]),
			    EXTRACT_32BITS(&tp[20])));
			if (optlen > 24) {
				/* there are sub-options */
				dhcp6opt_print(ndo, tp + 24, tp + optlen);
			}
			ND_PRINT((ndo, "")""));
			break;
		case DH6OPT_ORO:
		case DH6OPT_ERO:
			if (optlen % 2) {
				ND_PRINT((ndo, "" ?)""));
				break;
			}
			tp = (const u_char *)(dh6o + 1);
			for (i = 0; i < optlen; i += 2) {
				ND_PRINT((ndo, "" %s"",
				    tok2str(dh6opt_str, ""opt_%u"", EXTRACT_16BITS(&tp[i]))));
			}
			ND_PRINT((ndo, "")""));
			break;
		case DH6OPT_PREFERENCE:
			if (optlen != 1) {
				ND_PRINT((ndo, "" ?)""));
				break;
			}
			tp = (const u_char *)(dh6o + 1);
			ND_PRINT((ndo, "" %d)"", *tp));
			break;
		case DH6OPT_ELAPSED_TIME:
			if (optlen != 2) {
				ND_PRINT((ndo, "" ?)""));
				break;
			}
			tp = (const u_char *)(dh6o + 1);
			ND_PRINT((ndo, "" %d)"", EXTRACT_16BITS(tp)));
			break;
		case DH6OPT_RELAY_MSG:
			ND_PRINT((ndo, "" (""));
			tp = (const u_char *)(dh6o + 1);
			dhcp6_print(ndo, tp, optlen);
			ND_PRINT((ndo, "")""));
			break;
		case DH6OPT_AUTH:
			if (optlen < 11) {
				ND_PRINT((ndo, "" ?)""));
				break;
			}
			tp = (const u_char *)(dh6o + 1);
			auth_proto = *tp;
			switch (auth_proto) {
			case DH6OPT_AUTHPROTO_DELAYED:
				ND_PRINT((ndo, "" proto: delayed""));
				break;
			case DH6OPT_AUTHPROTO_RECONFIG:
				ND_PRINT((ndo, "" proto: reconfigure""));
				break;
			default:
				ND_PRINT((ndo, "" proto: %d"", auth_proto));
				break;
			}
			tp++;
			switch (*tp) {
			case DH6OPT_AUTHALG_HMACMD5:
				/* XXX: may depend on the protocol */
				ND_PRINT((ndo, "", alg: HMAC-MD5""));
				break;
			default:
				ND_PRINT((ndo, "", alg: %d"", *tp));
				break;
			}
			tp++;
			switch (*tp) {
			case DH6OPT_AUTHRDM_MONOCOUNTER:
				ND_PRINT((ndo, "", RDM: mono""));
				break;
			default:
				ND_PRINT((ndo, "", RDM: %d"", *tp));
				break;
			}
			tp++;
			ND_PRINT((ndo, "", RD:""));
			for (i = 0; i < 4; i++, tp += 2)
				ND_PRINT((ndo, "" %04x"", EXTRACT_16BITS(tp)));

			/* protocol dependent part */
			authinfolen = optlen - 11;
			switch (auth_proto) {
			case DH6OPT_AUTHPROTO_DELAYED:
				if (authinfolen == 0)
					break;
				if (authinfolen < 20) {
					ND_PRINT((ndo, "" ??""));
					break;
				}
				authrealmlen = authinfolen - 20;
				if (authrealmlen > 0) {
					ND_PRINT((ndo, "", realm: ""));
				}
				for (i = 0; i < authrealmlen; i++, tp++)
					ND_PRINT((ndo, ""%02x"", *tp));
				ND_PRINT((ndo, "", key ID: %08x"", EXTRACT_32BITS(tp)));
				tp += 4;
				ND_PRINT((ndo, "", HMAC-MD5:""));
				for (i = 0; i < 4; i++, tp+= 4)
					ND_PRINT((ndo, "" %08x"", EXTRACT_32BITS(tp)));
				break;
			case DH6OPT_AUTHPROTO_RECONFIG:
				if (authinfolen != 17) {
					ND_PRINT((ndo, "" ??""));
					break;
				}
				switch (*tp++) {
				case DH6OPT_AUTHRECONFIG_KEY:
					ND_PRINT((ndo, "" reconfig-key""));
					break;
				case DH6OPT_AUTHRECONFIG_HMACMD5:
					ND_PRINT((ndo, "" type: HMAC-MD5""));
					break;
				default:
					ND_PRINT((ndo, "" type: ??""));
					break;
				}
				ND_PRINT((ndo, "" value:""));
				for (i = 0; i < 4; i++, tp+= 4)
					ND_PRINT((ndo, "" %08x"", EXTRACT_32BITS(tp)));
				break;
			default:
				ND_PRINT((ndo, "" ??""));
				break;
			}

			ND_PRINT((ndo, "")""));
			break;
		case DH6OPT_RAPID_COMMIT: /* nothing todo */
			ND_PRINT((ndo, "")""));
			break;
		case DH6OPT_INTERFACE_ID:
		case DH6OPT_SUBSCRIBER_ID:
			/*
			 * Since we cannot predict the encoding, print hex dump
			 * at most 10 characters.
			 */
			tp = (const u_char *)(dh6o + 1);
			ND_PRINT((ndo, "" ""));
			for (i = 0; i < optlen && i < 10; i++)
				ND_PRINT((ndo, ""%02x"", tp[i]));
			ND_PRINT((ndo, ""...)""));
			break;
		case DH6OPT_RECONF_MSG:
			if (optlen != 1) {
				ND_PRINT((ndo, "" ?)""));
				break;
			}
			tp = (const u_char *)(dh6o + 1);
			switch (*tp) {
			case DH6_RENEW:
				ND_PRINT((ndo, "" for renew)""));
				break;
			case DH6_INFORM_REQ:
				ND_PRINT((ndo, "" for inf-req)""));
				break;
			default:
				ND_PRINT((ndo, "" for ?\?\?(%02x))"", *tp));
				break;
			}
			break;
		case DH6OPT_RECONF_ACCEPT: /* nothing todo */
			ND_PRINT((ndo, "")""));
			break;
		case DH6OPT_SIP_SERVER_A:
		case DH6OPT_DNS_SERVERS:
		case DH6OPT_SNTP_SERVERS:
		case DH6OPT_NIS_SERVERS:
		case DH6OPT_NISP_SERVERS:
		case DH6OPT_BCMCS_SERVER_A:
		case DH6OPT_PANA_AGENT:
		case DH6OPT_LQ_CLIENT_LINK:
			if (optlen % 16) {
				ND_PRINT((ndo, "" ?)""));
				break;
			}
			tp = (const u_char *)(dh6o + 1);
			for (i = 0; i < optlen; i += 16)
				ND_PRINT((ndo, "" %s"", ip6addr_string(ndo, &tp[i])));
			ND_PRINT((ndo, "")""));
			break;
		case DH6OPT_SIP_SERVER_D:
		case DH6OPT_DOMAIN_LIST:
			tp = (const u_char *)(dh6o + 1);
			while (tp < cp + sizeof(*dh6o) + optlen) {
				ND_PRINT((ndo, "" ""));
				if ((tp = ns_nprint(ndo, tp, cp + sizeof(*dh6o) + optlen)) == NULL)
					goto trunc;
			}
			ND_PRINT((ndo, "")""));
			break;
		case DH6OPT_STATUS_CODE:
			if (optlen < 2) {
				ND_PRINT((ndo, "" ?)""));
				break;
			}
			tp = (const u_char *)(dh6o + 1);
			ND_PRINT((ndo, "" %s)"", dhcp6stcode(EXTRACT_16BITS(&tp[0]))));
			break;
		case DH6OPT_IA_NA:
		case DH6OPT_IA_PD:
			if (optlen < 12) {
				ND_PRINT((ndo, "" ?)""));
				break;
			}
			tp = (const u_char *)(dh6o + 1);
			ND_PRINT((ndo, "" IAID:%u T1:%u T2:%u"",
			    EXTRACT_32BITS(&tp[0]),
			    EXTRACT_32BITS(&tp[4]),
			    EXTRACT_32BITS(&tp[8])));
			if (optlen > 12) {
				/* there are sub-options */
				dhcp6opt_print(ndo, tp + 12, tp + optlen);
			}
			ND_PRINT((ndo, "")""));
			break;
		case DH6OPT_IA_TA:
			if (optlen < 4) {
				ND_PRINT((ndo, "" ?)""));
				break;
			}
			tp = (const u_char *)(dh6o + 1);
			ND_PRINT((ndo, "" IAID:%u"", EXTRACT_32BITS(tp)));
			if (optlen > 4) {
				/* there are sub-options */
				dhcp6opt_print(ndo, tp + 4, tp + optlen);
			}
			ND_PRINT((ndo, "")""));
			break;
		case DH6OPT_IA_PD_PREFIX:
			if (optlen < 25) {
				ND_PRINT((ndo, "" ?)""));
				break;
			}
			tp = (const u_char *)(dh6o + 1);
			ND_PRINT((ndo, "" %s/%d"", ip6addr_string(ndo, &tp[9]), tp[8]));
			ND_PRINT((ndo, "" pltime:%u vltime:%u"",
			    EXTRACT_32BITS(&tp[0]),
			    EXTRACT_32BITS(&tp[4])));
			if (optlen > 25) {
				/* there are sub-options */
				dhcp6opt_print(ndo, tp + 25, tp + optlen);
			}
			ND_PRINT((ndo, "")""));
			break;
		case DH6OPT_LIFETIME:
		case DH6OPT_CLT_TIME:
			if (optlen != 4) {
				ND_PRINT((ndo, "" ?)""));
				break;
			}
			tp = (const u_char *)(dh6o + 1);
			ND_PRINT((ndo, "" %d)"", EXTRACT_32BITS(tp)));
			break;
		case DH6OPT_REMOTE_ID:
			if (optlen < 4) {
				ND_PRINT((ndo, "" ?)""));
				break;
			}
			tp = (const u_char *)(dh6o + 1);
			ND_PRINT((ndo, "" %d "", EXTRACT_32BITS(tp)));
			/*
			 * Print hex dump first 10 characters.
			 */
			for (i = 4; i < optlen && i < 14; i++)
				ND_PRINT((ndo, ""%02x"", tp[i]));
			ND_PRINT((ndo, ""...)""));
			break;
		case DH6OPT_LQ_QUERY:
			if (optlen < 17) {
				ND_PRINT((ndo, "" ?)""));
				break;
			}
			tp = (const u_char *)(dh6o + 1);
			switch (*tp) {
			case 1:
				ND_PRINT((ndo, "" by-address""));
				break;
			case 2:
				ND_PRINT((ndo, "" by-clientID""));
				break;
			default:
				ND_PRINT((ndo, "" type_%d"", (int)*tp));
				break;
			}
			ND_PRINT((ndo, "" %s"", ip6addr_string(ndo, &tp[1])));
			if (optlen > 17) {
				/* there are query-options */
				dhcp6opt_print(ndo, tp + 17, tp + optlen);
			}
			ND_PRINT((ndo, "")""));
			break;
		case DH6OPT_CLIENT_DATA:
			tp = (const u_char *)(dh6o + 1);
			if (optlen > 0) {
				/* there are encapsulated options */
				dhcp6opt_print(ndo, tp, tp + optlen);
			}
			ND_PRINT((ndo, "")""));
			break;
		case DH6OPT_LQ_RELAY_DATA:
			if (optlen < 16) {
				ND_PRINT((ndo, "" ?)""));
				break;
			}
			tp = (const u_char *)(dh6o + 1);
			ND_PRINT((ndo, "" %s "", ip6addr_string(ndo, &tp[0])));
			/*
			 * Print hex dump first 10 characters.
			 */
			for (i = 16; i < optlen && i < 26; i++)
				ND_PRINT((ndo, ""%02x"", tp[i]));
			ND_PRINT((ndo, ""...)""));
			break;
		case DH6OPT_NTP_SERVER:
			if (optlen < 4) {
				ND_PRINT((ndo, "" ?)""));
				break;
			}
			tp = (const u_char *)(dh6o + 1);
			while (tp < cp + sizeof(*dh6o) + optlen - 4) {
				subopt_code = EXTRACT_16BITS(tp);
				tp += 2;
				subopt_len = EXTRACT_16BITS(tp);
				tp += 2;
				if (tp + subopt_len > cp + sizeof(*dh6o) + optlen)
					goto trunc;
				ND_PRINT((ndo, "" subopt:%d"", subopt_code));
				switch (subopt_code) {
				case DH6OPT_NTP_SUBOPTION_SRV_ADDR:
				case DH6OPT_NTP_SUBOPTION_MC_ADDR:
					if (subopt_len != 16) {
						ND_PRINT((ndo, "" ?""));
						break;
					}
					ND_PRINT((ndo, "" %s"", ip6addr_string(ndo, &tp[0])));
					break;
				case DH6OPT_NTP_SUBOPTION_SRV_FQDN:
					ND_PRINT((ndo, "" ""));
					if (ns_nprint(ndo, tp, tp + subopt_len) == NULL)
						goto trunc;
					break;
				default:
					ND_PRINT((ndo, "" ?""));
					break;
				}
				tp += subopt_len;
			}
			ND_PRINT((ndo, "")""));
			break;
		case DH6OPT_AFTR_NAME:
			if (optlen < 3) {
				ND_PRINT((ndo, "" ?)""));
				break;
			}
			tp = (const u_char *)(dh6o + 1);
			remain_len = optlen;
			ND_PRINT((ndo, "" ""));
			/* Encoding is described in section 3.1 of RFC 1035 */
			while (remain_len && *tp) {
				label_len =  *tp++;
				if (label_len < remain_len - 1) {
					(void)fn_printn(ndo, tp, label_len, NULL);
					tp += label_len;
					remain_len -= (label_len + 1);
					if(*tp) ND_PRINT((ndo, "".""));
				} else {
					ND_PRINT((ndo, "" ?""));
					break;
				}
			}
			ND_PRINT((ndo, "")""));
			break;
		case DH6OPT_NEW_POSIX_TIMEZONE: /* all three of these options */
		case DH6OPT_NEW_TZDB_TIMEZONE:	/* are encoded similarly */
		case DH6OPT_MUDURL:		/* although GMT might not work */
		        if (optlen < 5) {
				ND_PRINT((ndo, "" ?)""));
				break;
			}
			tp = (const u_char *)(dh6o + 1);
			ND_PRINT((ndo, ""=""));
			(void)fn_printn(ndo, tp, (u_int)optlen, NULL);
			ND_PRINT((ndo, "")""));
			break;

		default:
			ND_PRINT((ndo, "")""));
			break;
		}

		cp += sizeof(*dh6o) + optlen;
	}
	return;

trunc:
	ND_PRINT((ndo, ""[|dhcp6ext]""));
}","static void
dhcp6opt_print(netdissect_options *VAR_0,
               const u_char *VAR_1, const u_char *VAR_2)
{
	const struct dhcp6opt *VAR_3;
	const u_char *VAR_4;
	size_t VAR_5;
	uint16_t VAR_6;
	size_t VAR_7;
	uint8_t VAR_8;
	u_int VAR_9, VAR_10;
	int VAR_11;  /* COMMENT_0 */
	int VAR_12;   /* COMMENT_1 */
	uint16_t VAR_13;
	uint16_t VAR_14;

	if (VAR_1 == VAR_2)
		return;
	while (VAR_1 < VAR_2) {
		if (VAR_2 < VAR_1 + sizeof(*VAR_3))
			goto trunc;
		VAR_3 = (const struct dhcp6opt *)VAR_1;
		ND_TCHECK(*VAR_3);
		VAR_7 = EXTRACT_16BITS(&VAR_3->dh6opt_len);
		if (VAR_2 < VAR_1 + sizeof(*VAR_3) + VAR_7)
			goto trunc;
		VAR_6 = EXTRACT_16BITS(&VAR_3->dh6opt_type);
		ND_PRINT((VAR_0, "" (%s"", tok2str(VAR_15, ""opt_%u"", VAR_6)));
		ND_TCHECK2(*(VAR_1 + sizeof(*VAR_3)), VAR_7);
		switch (VAR_6) {
		case VAR_16:
		case VAR_17:
			if (VAR_7 < 2) {
				/* COMMENT_2 */
				ND_PRINT((VAR_0, "" ?)""));
				break;
			}
			VAR_4 = (const u_char *)(VAR_3 + 1);
			switch (EXTRACT_16BITS(VAR_4)) {
			case 1:
				if (VAR_7 >= 2 + 6) {
					ND_PRINT((VAR_0, "" hwaddr/time type %u time %u "",
					    EXTRACT_16BITS(&VAR_4[2]),
					    EXTRACT_32BITS(&VAR_4[4])));
					for (VAR_5 = 8; VAR_5 < VAR_7; VAR_5++)
						ND_PRINT((VAR_0, ""%02x"", VAR_4[VAR_5]));
					/* COMMENT_2 */
					ND_PRINT((VAR_0, "")""));
				} else {
					/* COMMENT_2 */
					ND_PRINT((VAR_0, "" ?)""));
				}
				break;
			case 2:
				if (VAR_7 >= 2 + 8) {
					ND_PRINT((VAR_0, "" vid ""));
					for (VAR_5 = 2; VAR_5 < 2 + 8; VAR_5++)
						ND_PRINT((VAR_0, ""%02x"", VAR_4[VAR_5]));
					/* COMMENT_2 */
					ND_PRINT((VAR_0, "")""));
				} else {
					/* COMMENT_2 */
					ND_PRINT((VAR_0, "" ?)""));
				}
				break;
			case 3:
				if (VAR_7 >= 2 + 2) {
					ND_PRINT((VAR_0, "" hwaddr type %u "",
					    EXTRACT_16BITS(&VAR_4[2])));
					for (VAR_5 = 4; VAR_5 < VAR_7; VAR_5++)
						ND_PRINT((VAR_0, ""%02x"", VAR_4[VAR_5]));
					/* COMMENT_2 */
					ND_PRINT((VAR_0, "")""));
				} else {
					/* COMMENT_2 */
					ND_PRINT((VAR_0, "" ?)""));
				}
				break;
			default:
				ND_PRINT((VAR_0, "" type %d)"", EXTRACT_16BITS(VAR_4)));
				break;
			}
			break;
		case VAR_18:
			if (VAR_7 < 24) {
				/* COMMENT_2 */
				ND_PRINT((VAR_0, "" ?)""));
				break;
			}
			VAR_4 = (const u_char *)(VAR_3 + 1);
			ND_PRINT((VAR_0, "" %s"", ip6addr_string(VAR_0, &VAR_4[0])));
			ND_PRINT((VAR_0, "" pltime:%u vltime:%u"",
			    EXTRACT_32BITS(&VAR_4[16]),
			    EXTRACT_32BITS(&VAR_4[20])));
			if (VAR_7 > 24) {
				/* COMMENT_3 */
				dhcp6opt_print(VAR_0, VAR_4 + 24, VAR_4 + VAR_7);
			}
			ND_PRINT((VAR_0, "")""));
			break;
		case VAR_19:
		case VAR_20:
			if (VAR_7 % 2) {
				ND_PRINT((VAR_0, "" ?)""));
				break;
			}
			VAR_4 = (const u_char *)(VAR_3 + 1);
			for (VAR_5 = 0; VAR_5 < VAR_7; VAR_5 += 2) {
				ND_PRINT((VAR_0, "" %s"",
				    tok2str(VAR_15, ""opt_%u"", EXTRACT_16BITS(&VAR_4[VAR_5]))));
			}
			ND_PRINT((VAR_0, "")""));
			break;
		case VAR_21:
			if (VAR_7 != 1) {
				ND_PRINT((VAR_0, "" ?)""));
				break;
			}
			VAR_4 = (const u_char *)(VAR_3 + 1);
			ND_PRINT((VAR_0, "" %d)"", *VAR_4));
			break;
		case VAR_22:
			if (VAR_7 != 2) {
				ND_PRINT((VAR_0, "" ?)""));
				break;
			}
			VAR_4 = (const u_char *)(VAR_3 + 1);
			ND_PRINT((VAR_0, "" %d)"", EXTRACT_16BITS(VAR_4)));
			break;
		case VAR_23:
			ND_PRINT((VAR_0, "" (""));
			VAR_4 = (const u_char *)(VAR_3 + 1);
			dhcp6_print(VAR_0, VAR_4, VAR_7);
			ND_PRINT((VAR_0, "")""));
			break;
		case VAR_24:
			if (VAR_7 < 11) {
				ND_PRINT((VAR_0, "" ?)""));
				break;
			}
			VAR_4 = (const u_char *)(VAR_3 + 1);
			VAR_8 = *VAR_4;
			switch (VAR_8) {
			case VAR_25:
				ND_PRINT((VAR_0, "" proto: delayed""));
				break;
			case VAR_26:
				ND_PRINT((VAR_0, "" proto: reconfigure""));
				break;
			default:
				ND_PRINT((VAR_0, "" proto: %d"", VAR_8));
				break;
			}
			VAR_4++;
			switch (*VAR_4) {
			case VAR_27:
				/* COMMENT_4 */
				ND_PRINT((VAR_0, "", alg: HMAC-MD5""));
				break;
			default:
				ND_PRINT((VAR_0, "", alg: %d"", *VAR_4));
				break;
			}
			VAR_4++;
			switch (*VAR_4) {
			case VAR_28:
				ND_PRINT((VAR_0, "", RDM: mono""));
				break;
			default:
				ND_PRINT((VAR_0, "", RDM: %d"", *VAR_4));
				break;
			}
			VAR_4++;
			ND_PRINT((VAR_0, "", RD:""));
			for (VAR_5 = 0; VAR_5 < 4; VAR_5++, VAR_4 += 2)
				ND_PRINT((VAR_0, "" %04x"", EXTRACT_16BITS(VAR_4)));

			/* COMMENT_5 */
			VAR_9 = VAR_7 - 11;
			switch (VAR_8) {
			case VAR_25:
				if (VAR_9 == 0)
					break;
				if (VAR_9 < 20) {
					ND_PRINT((VAR_0, "" ??""));
					break;
				}
				VAR_10 = VAR_9 - 20;
				if (VAR_10 > 0) {
					ND_PRINT((VAR_0, "", realm: ""));
				}
				for (VAR_5 = 0; VAR_5 < VAR_10; VAR_5++, VAR_4++)
					ND_PRINT((VAR_0, ""%02x"", *VAR_4));
				ND_PRINT((VAR_0, "", key ID: %08x"", EXTRACT_32BITS(VAR_4)));
				VAR_4 += 4;
				ND_PRINT((VAR_0, "", HMAC-MD5:""));
				for (VAR_5 = 0; VAR_5 < 4; VAR_5++, VAR_4+= 4)
					ND_PRINT((VAR_0, "" %08x"", EXTRACT_32BITS(VAR_4)));
				break;
			case VAR_26:
				if (VAR_9 != 17) {
					ND_PRINT((VAR_0, "" ??""));
					break;
				}
				switch (*VAR_4++) {
				case VAR_29:
					ND_PRINT((VAR_0, "" reconfig-key""));
					break;
				case VAR_30:
					ND_PRINT((VAR_0, "" type: HMAC-MD5""));
					break;
				default:
					ND_PRINT((VAR_0, "" type: ??""));
					break;
				}
				ND_PRINT((VAR_0, "" value:""));
				for (VAR_5 = 0; VAR_5 < 4; VAR_5++, VAR_4+= 4)
					ND_PRINT((VAR_0, "" %08x"", EXTRACT_32BITS(VAR_4)));
				break;
			default:
				ND_PRINT((VAR_0, "" ??""));
				break;
			}

			ND_PRINT((VAR_0, "")""));
			break;
		case VAR_31: /* COMMENT_6 */
			ND_PRINT((VAR_0, "")""));
			break;
		case VAR_32:
		case VAR_33:
			/* COMMENT_7 */
                                                          
                            
      
			VAR_4 = (const u_char *)(VAR_3 + 1);
			ND_PRINT((VAR_0, "" ""));
			for (VAR_5 = 0; VAR_5 < VAR_7 && VAR_5 < 10; VAR_5++)
				ND_PRINT((VAR_0, ""%02x"", VAR_4[VAR_5]));
			ND_PRINT((VAR_0, ""...)""));
			break;
		case VAR_34:
			if (VAR_7 != 1) {
				ND_PRINT((VAR_0, "" ?)""));
				break;
			}
			VAR_4 = (const u_char *)(VAR_3 + 1);
			switch (*VAR_4) {
			case VAR_35:
				ND_PRINT((VAR_0, "" for renew)""));
				break;
			case VAR_36:
				ND_PRINT((VAR_0, "" for inf-req)""));
				break;
			default:
				ND_PRINT((VAR_0, "" for ?\?\?(%02x))"", *VAR_4));
				break;
			}
			break;
		case VAR_37: /* COMMENT_6 */
			ND_PRINT((VAR_0, "")""));
			break;
		case VAR_38:
		case VAR_39:
		case VAR_40:
		case VAR_41:
		case VAR_42:
		case VAR_43:
		case VAR_44:
		case VAR_45:
			if (VAR_7 % 16) {
				ND_PRINT((VAR_0, "" ?)""));
				break;
			}
			VAR_4 = (const u_char *)(VAR_3 + 1);
			for (VAR_5 = 0; VAR_5 < VAR_7; VAR_5 += 16)
				ND_PRINT((VAR_0, "" %s"", ip6addr_string(VAR_0, &VAR_4[VAR_5])));
			ND_PRINT((VAR_0, "")""));
			break;
		case VAR_46:
		case VAR_47:
			VAR_4 = (const u_char *)(VAR_3 + 1);
			while (VAR_4 < VAR_1 + sizeof(*VAR_3) + VAR_7) {
				ND_PRINT((VAR_0, "" ""));
				if ((VAR_4 = ns_nprint(VAR_0, VAR_4, VAR_1 + sizeof(*VAR_3) + VAR_7)) == NULL)
					goto trunc;
			}
			ND_PRINT((VAR_0, "")""));
			break;
		case VAR_48:
			if (VAR_7 < 2) {
				ND_PRINT((VAR_0, "" ?)""));
				break;
			}
			VAR_4 = (const u_char *)(VAR_3 + 1);
			ND_PRINT((VAR_0, "" %s)"", dhcp6stcode(EXTRACT_16BITS(&VAR_4[0]))));
			break;
		case VAR_49:
		case VAR_50:
			if (VAR_7 < 12) {
				ND_PRINT((VAR_0, "" ?)""));
				break;
			}
			VAR_4 = (const u_char *)(VAR_3 + 1);
			ND_PRINT((VAR_0, "" IAID:%u T1:%u T2:%u"",
			    EXTRACT_32BITS(&VAR_4[0]),
			    EXTRACT_32BITS(&VAR_4[4]),
			    EXTRACT_32BITS(&VAR_4[8])));
			if (VAR_7 > 12) {
				/* COMMENT_3 */
				dhcp6opt_print(VAR_0, VAR_4 + 12, VAR_4 + VAR_7);
			}
			ND_PRINT((VAR_0, "")""));
			break;
		case VAR_51:
			if (VAR_7 < 4) {
				ND_PRINT((VAR_0, "" ?)""));
				break;
			}
			VAR_4 = (const u_char *)(VAR_3 + 1);
			ND_PRINT((VAR_0, "" IAID:%u"", EXTRACT_32BITS(VAR_4)));
			if (VAR_7 > 4) {
				/* COMMENT_3 */
				dhcp6opt_print(VAR_0, VAR_4 + 4, VAR_4 + VAR_7);
			}
			ND_PRINT((VAR_0, "")""));
			break;
		case VAR_52:
			if (VAR_7 < 25) {
				ND_PRINT((VAR_0, "" ?)""));
				break;
			}
			VAR_4 = (const u_char *)(VAR_3 + 1);
			ND_PRINT((VAR_0, "" %s/%d"", ip6addr_string(VAR_0, &VAR_4[9]), VAR_4[8]));
			ND_PRINT((VAR_0, "" pltime:%u vltime:%u"",
			    EXTRACT_32BITS(&VAR_4[0]),
			    EXTRACT_32BITS(&VAR_4[4])));
			if (VAR_7 > 25) {
				/* COMMENT_3 */
				dhcp6opt_print(VAR_0, VAR_4 + 25, VAR_4 + VAR_7);
			}
			ND_PRINT((VAR_0, "")""));
			break;
		case VAR_53:
		case VAR_54:
			if (VAR_7 != 4) {
				ND_PRINT((VAR_0, "" ?)""));
				break;
			}
			VAR_4 = (const u_char *)(VAR_3 + 1);
			ND_PRINT((VAR_0, "" %d)"", EXTRACT_32BITS(VAR_4)));
			break;
		case VAR_55:
			if (VAR_7 < 4) {
				ND_PRINT((VAR_0, "" ?)""));
				break;
			}
			VAR_4 = (const u_char *)(VAR_3 + 1);
			ND_PRINT((VAR_0, "" %d "", EXTRACT_32BITS(VAR_4)));
			/* COMMENT_11 */
                                         
      
			for (VAR_5 = 4; VAR_5 < VAR_7 && VAR_5 < 14; VAR_5++)
				ND_PRINT((VAR_0, ""%02x"", VAR_4[VAR_5]));
			ND_PRINT((VAR_0, ""...)""));
			break;
		case VAR_56:
			if (VAR_7 < 17) {
				ND_PRINT((VAR_0, "" ?)""));
				break;
			}
			VAR_4 = (const u_char *)(VAR_3 + 1);
			switch (*VAR_4) {
			case 1:
				ND_PRINT((VAR_0, "" by-address""));
				break;
			case 2:
				ND_PRINT((VAR_0, "" by-clientID""));
				break;
			default:
				ND_PRINT((VAR_0, "" type_%d"", (int)*VAR_4));
				break;
			}
			ND_PRINT((VAR_0, "" %s"", ip6addr_string(VAR_0, &VAR_4[1])));
			if (VAR_7 > 17) {
				/* COMMENT_14 */
				dhcp6opt_print(VAR_0, VAR_4 + 17, VAR_4 + VAR_7);
			}
			ND_PRINT((VAR_0, "")""));
			break;
		case VAR_57:
			VAR_4 = (const u_char *)(VAR_3 + 1);
			if (VAR_7 > 0) {
				/* COMMENT_15 */
				dhcp6opt_print(VAR_0, VAR_4, VAR_4 + VAR_7);
			}
			ND_PRINT((VAR_0, "")""));
			break;
		case VAR_58:
			if (VAR_7 < 16) {
				ND_PRINT((VAR_0, "" ?)""));
				break;
			}
			VAR_4 = (const u_char *)(VAR_3 + 1);
			ND_PRINT((VAR_0, "" %s "", ip6addr_string(VAR_0, &VAR_4[0])));
			/* COMMENT_16 */
                                         
      
			for (VAR_5 = 16; VAR_5 < VAR_7 && VAR_5 < 26; VAR_5++)
				ND_PRINT((VAR_0, ""%02x"", VAR_4[VAR_5]));
			ND_PRINT((VAR_0, ""...)""));
			break;
		case VAR_59:
			if (VAR_7 < 4) {
				ND_PRINT((VAR_0, "" ?)""));
				break;
			}
			VAR_4 = (const u_char *)(VAR_3 + 1);
			while (VAR_4 < VAR_1 + sizeof(*VAR_3) + VAR_7 - 4) {
				VAR_13 = EXTRACT_16BITS(VAR_4);
				VAR_4 += 2;
				VAR_14 = EXTRACT_16BITS(VAR_4);
				VAR_4 += 2;
				if (VAR_4 + VAR_14 > VAR_1 + sizeof(*VAR_3) + VAR_7)
					goto trunc;
				ND_PRINT((VAR_0, "" subopt:%d"", VAR_13));
				switch (VAR_13) {
				case VAR_60:
				case VAR_61:
					if (VAR_14 != 16) {
						ND_PRINT((VAR_0, "" ?""));
						break;
					}
					ND_PRINT((VAR_0, "" %s"", ip6addr_string(VAR_0, &VAR_4[0])));
					break;
				case VAR_62:
					ND_PRINT((VAR_0, "" ""));
					if (ns_nprint(VAR_0, VAR_4, VAR_4 + VAR_14) == NULL)
						goto trunc;
					break;
				default:
					ND_PRINT((VAR_0, "" ?""));
					break;
				}
				VAR_4 += VAR_14;
			}
			ND_PRINT((VAR_0, "")""));
			break;
		case VAR_63:
			if (VAR_7 < 3) {
				ND_PRINT((VAR_0, "" ?)""));
				break;
			}
			VAR_4 = (const u_char *)(VAR_3 + 1);
			VAR_11 = VAR_7;
			ND_PRINT((VAR_0, "" ""));
			/* COMMENT_19 */
			while (VAR_11 && *VAR_4) {
				VAR_12 =  *VAR_4++;
				if (VAR_12 < VAR_11 - 1) {
					(void)fn_printn(VAR_0, VAR_4, VAR_12, NULL);
					VAR_4 += VAR_12;
					VAR_11 -= (VAR_12 + 1);
					if(*VAR_4) ND_PRINT((VAR_0, "".""));
				} else {
					ND_PRINT((VAR_0, "" ?""));
					break;
				}
			}
			ND_PRINT((VAR_0, "")""));
			break;
		case VAR_64: /* COMMENT_20 */
		case VAR_65:	/* COMMENT_21 */
		case VAR_66:		/* COMMENT_22 */
		        if (VAR_7 < 5) {
				ND_PRINT((VAR_0, "" ?)""));
				break;
			}
			VAR_4 = (const u_char *)(VAR_3 + 1);
			ND_PRINT((VAR_0, ""=""));
			(void)fn_printn(VAR_0, VAR_4, (u_int)VAR_7, NULL);
			ND_PRINT((VAR_0, "")""));
			break;

		default:
			ND_PRINT((VAR_0, "")""));
			break;
		}

		VAR_1 += sizeof(*VAR_3) + VAR_7;
	}
	return;

trunc:
	ND_PRINT((VAR_0, ""[|dhcp6ext]""));
}",the-tcpdump-group/tcpdump/11b426ee05eb62ed103218526f1fa616851c43ce/print-dhcp6.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -240,6 +240,10 @@
 			ND_PRINT((ndo, ""...)""));
 			break;
 		case DH6OPT_RECONF_MSG:
+			if (optlen != 1) {
+				ND_PRINT((ndo, "" ?)""));
+				break;
+			}
 			tp = (const u_char *)(dh6o + 1);
 			switch (*tp) {
 			case DH6_RENEW:","{'deleted_lines': [], 'added_lines': ['\t\t\tif (optlen != 1) {', '\t\t\t\tND_PRINT((ndo, "" ?)""));', '\t\t\t\tbreak;', '\t\t\t}']}",True,The DHCPv6 parser in tcpdump before 4.9.2 has a buffer over-read in print-dhcp6.c:dhcp6opt_print().,9.8,CRITICAL,3,test,2017-03-22T02:40:51Z,1
CVE-2017-13031,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-13031/Check for the presence of the entire IPv6 fragment header.

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't be rejected as an invalid capture.

Clean up some whitespace in tests/TESTLIST while we're at it.",2d669862df7cd17f539129049f6fb70d17174125,https://github.com/the-tcpdump-group/tcpdump/commit/2d669862df7cd17f539129049f6fb70d17174125,print-frag6.c,frag6_print,"int
frag6_print(netdissect_options *ndo, register const u_char *bp, register const u_char *bp2)
{
register const struct ip6_frag *dp;
register const struct ip6_hdr *ip6;
dp = (const struct ip6_frag *)bp;
ip6 = (const struct ip6_hdr *)bp2;
ND_TCHECK(dp->ip6f_offlg);
if (ndo->ndo_vflag) {
ND_PRINT((ndo, ""frag (0x%08x:%d|%ld)"",
EXTRACT_32BITS(&dp->ip6f_ident),
EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,
sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -
(long)(bp - bp2) - sizeof(struct ip6_frag)));
} else {
ND_PRINT((ndo, ""frag (%d|%ld)"",
EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,
sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -
(long)(bp - bp2) - sizeof(struct ip6_frag)));
}
if ((EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK) != 0)
return -1;
else
{
ND_PRINT((ndo, "" ""));
return sizeof(struct ip6_frag);
}
trunc:
ND_PRINT((ndo, ""[|frag]""));
return -1;
}","int
frag6_print(netdissect_options *VAR_0, register const u_char *VAR_1, register const u_char *VAR_2)
{
register const struct ip6_frag *VAR_3;
register const struct ip6_hdr *VAR_4;
VAR_3 = (const struct ip6_frag *)VAR_1;
VAR_4 = (const struct ip6_hdr *)VAR_2;
ND_TCHECK(VAR_3->ip6f_offlg);
if (VAR_0->ndo_vflag) {
ND_PRINT((VAR_0, ""frag (0x%08x:%d|%ld)"",
EXTRACT_32BITS(&VAR_3->ip6f_ident),
EXTRACT_16BITS(&VAR_3->ip6f_offlg) & VAR_5,
sizeof(struct ip6_hdr) + EXTRACT_16BITS(&VAR_4->ip6_plen) -
(long)(VAR_1 - VAR_2) - sizeof(struct ip6_frag)));
} else {
ND_PRINT((VAR_0, ""frag (%d|%ld)"",
EXTRACT_16BITS(&VAR_3->ip6f_offlg) & VAR_5,
sizeof(struct ip6_hdr) + EXTRACT_16BITS(&VAR_4->ip6_plen) -
(long)(VAR_1 - VAR_2) - sizeof(struct ip6_frag)));
}
if ((EXTRACT_16BITS(&VAR_3->ip6f_offlg) & VAR_5) != 0)
return -1;
else
{
ND_PRINT((VAR_0, "" ""));
return sizeof(struct ip6_frag);
}
trunc:
ND_PRINT((VAR_0, ""[|frag]""));
return -1;
}",the-tcpdump-group/tcpdump/2d669862df7cd17f539129049f6fb70d17174125/print-frag6.c/vul/before/0.json,"int
frag6_print(netdissect_options *ndo, register const u_char *bp, register const u_char *bp2)
{
	register const struct ip6_frag *dp;
	register const struct ip6_hdr *ip6;

	dp = (const struct ip6_frag *)bp;
	ip6 = (const struct ip6_hdr *)bp2;

	ND_TCHECK(*dp);

	if (ndo->ndo_vflag) {
		ND_PRINT((ndo, ""frag (0x%08x:%d|%ld)"",
		       EXTRACT_32BITS(&dp->ip6f_ident),
		       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,
		       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -
			       (long)(bp - bp2) - sizeof(struct ip6_frag)));
	} else {
		ND_PRINT((ndo, ""frag (%d|%ld)"",
		       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,
		       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -
			       (long)(bp - bp2) - sizeof(struct ip6_frag)));
	}

	/* it is meaningless to decode non-first fragment */
	if ((EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK) != 0)
		return -1;
	else
	{
		ND_PRINT((ndo, "" ""));
		return sizeof(struct ip6_frag);
	}
trunc:
	ND_PRINT((ndo, ""[|frag]""));
	return -1;
}","int
frag6_print(netdissect_options *VAR_0, register const u_char *VAR_1, register const u_char *VAR_2)
{
	register const struct ip6_frag *VAR_3;
	register const struct ip6_hdr *VAR_4;

	VAR_3 = (const struct ip6_frag *)VAR_1;
	VAR_4 = (const struct ip6_hdr *)VAR_2;

	ND_TCHECK(*VAR_3);

	if (VAR_0->ndo_vflag) {
		ND_PRINT((VAR_0, ""frag (0x%08x:%d|%ld)"",
		       EXTRACT_32BITS(&VAR_3->ip6f_ident),
		       EXTRACT_16BITS(&VAR_3->ip6f_offlg) & VAR_5,
		       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&VAR_4->ip6_plen) -
			       (long)(VAR_1 - VAR_2) - sizeof(struct ip6_frag)));
	} else {
		ND_PRINT((VAR_0, ""frag (%d|%ld)"",
		       EXTRACT_16BITS(&VAR_3->ip6f_offlg) & VAR_5,
		       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&VAR_4->ip6_plen) -
			       (long)(VAR_1 - VAR_2) - sizeof(struct ip6_frag)));
	}

	/* COMMENT_0 */
	if ((EXTRACT_16BITS(&VAR_3->ip6f_offlg) & VAR_5) != 0)
		return -1;
	else
	{
		ND_PRINT((VAR_0, "" ""));
		return sizeof(struct ip6_frag);
	}
trunc:
	ND_PRINT((VAR_0, ""[|frag]""));
	return -1;
}",the-tcpdump-group/tcpdump/2d669862df7cd17f539129049f6fb70d17174125/print-frag6.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
 	dp = (const struct ip6_frag *)bp;
 	ip6 = (const struct ip6_hdr *)bp2;
 
-	ND_TCHECK(dp->ip6f_offlg);
+	ND_TCHECK(*dp);
 
 	if (ndo->ndo_vflag) {
 		ND_PRINT((ndo, ""frag (0x%08x:%d|%ld)"",","{'deleted_lines': ['\tND_TCHECK(dp->ip6f_offlg);'], 'added_lines': ['\tND_TCHECK(*dp);']}",True,The IPv6 fragmentation header parser in tcpdump before 4.9.2 has a buffer over-read in print-frag6.c:frag6_print().,9.8,CRITICAL,3,test,2017-03-22T21:55:12Z,1
CVE-2017-13036,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,the-tcpdump-group/tcpdump,"CVE-2017-13036/OSPFv3: Add a bounds check before fetching data

This fixes a buffer over-read discovered by Bhargava Shastry,
SecT/TU Berlin.

Add a test using the capture file supplied by the reporter(s), modified
so the capture file won't be rejected as an invalid capture.",88b2dac837e81cf56dce05e6e7b5989332c0092d,https://github.com/the-tcpdump-group/tcpdump/commit/88b2dac837e81cf56dce05e6e7b5989332c0092d,print-ospf6.c,ospf6_decode_v3,"static int
ospf6_decode_v3(netdissect_options *ndo,
register const struct ospf6hdr *op,
register const u_char *dataend)
{
register const rtrid_t *ap;
register const struct lsr6 *lsrp;
register const struct lsa6_hdr *lshp;
register const struct lsa6 *lsap;
register int i;
switch (op->ospf6_type) {
case OSPF_TYPE_HELLO: {
register const struct hello6 *hellop = (const struct hello6 *)((const uint8_t *)op + OSPF6HDR_LEN);
ND_PRINT((ndo, ""\n\tOptions [%s]"",
bittok2str(ospf6_option_values, ""none"",
EXTRACT_32BITS(&hellop->hello_options))));
ND_TCHECK(hellop->hello_deadint);
ND_PRINT((ndo, ""\n\t  Hello Timer %us, Dead Timer %us, Interface-ID %s, Priority %u"",
EXTRACT_16BITS(&hellop->hello_helloint),
EXTRACT_16BITS(&hellop->hello_deadint),
ipaddr_string(ndo, &hellop->hello_ifid),
hellop->hello_priority));
ND_TCHECK(hellop->hello_dr);
if (EXTRACT_32BITS(&hellop->hello_dr) != 0)
ND_PRINT((ndo, ""\n\t  Designated Router %s"",
ipaddr_string(ndo, &hellop->hello_dr)));
ND_TCHECK(hellop->hello_bdr);
if (EXTRACT_32BITS(&hellop->hello_bdr) != 0)
ND_PRINT((ndo, "", Backup Designated Router %s"",
ipaddr_string(ndo, &hellop->hello_bdr)));
if (ndo->ndo_vflag > 1) {
ND_PRINT((ndo, ""\n\t  Neighbor List:""));
ap = hellop->hello_neighbor;
while ((const u_char *)ap < dataend) {
ND_TCHECK(*ap);
ND_PRINT((ndo, ""\n\t    %s"", ipaddr_string(ndo, ap)));
++ap;
}
}
break;
}
case OSPF_TYPE_DD: {
register const struct dd6 *ddp = (const struct dd6 *)((const uint8_t *)op + OSPF6HDR_LEN);
ND_TCHECK(ddp->db_options);
ND_PRINT((ndo, ""\n\tOptions [%s]"",
bittok2str(ospf6_option_values, ""none"",
EXTRACT_32BITS(&ddp->db_options))));
ND_TCHECK(ddp->db_flags);
ND_PRINT((ndo, "", DD Flags [%s]"",
bittok2str(ospf6_dd_flag_values,""none"",ddp->db_flags)));
ND_TCHECK(ddp->db_seq);
ND_PRINT((ndo, "", MTU %u, DD-Sequence 0x%08x"",
EXTRACT_16BITS(&ddp->db_mtu),
EXTRACT_32BITS(&ddp->db_seq)));
if (ndo->ndo_vflag > 1) {
lshp = ddp->db_lshdr;
while ((const u_char *)lshp < dataend) {
if (ospf6_print_lshdr(ndo, lshp++, dataend))
goto trunc;
}
}
break;
}
case OSPF_TYPE_LS_REQ:
if (ndo->ndo_vflag > 1) {
lsrp = (const struct lsr6 *)((const uint8_t *)op + OSPF6HDR_LEN);
while ((const u_char *)lsrp < dataend) {
ND_TCHECK(*lsrp);
ND_PRINT((ndo, ""\n\t  Advertising Router %s"",
ipaddr_string(ndo, &lsrp->ls_router)));
ospf6_print_ls_type(ndo, EXTRACT_16BITS(&lsrp->ls_type),
&lsrp->ls_stateid);
++lsrp;
}
}
break;
case OSPF_TYPE_LS_UPDATE:
if (ndo->ndo_vflag > 1) {
register const struct lsu6 *lsup = (const struct lsu6 *)((const uint8_t *)op + OSPF6HDR_LEN);
ND_TCHECK(lsup->lsu_count);
i = EXTRACT_32BITS(&lsup->lsu_count);
lsap = lsup->lsu_lsa;
while ((const u_char *)lsap < dataend && i--) {
if (ospf6_print_lsa(ndo, lsap, dataend))
goto trunc;
lsap = (const struct lsa6 *)((const u_char *)lsap +
EXTRACT_16BITS(&lsap->ls_hdr.ls_length));
}
}
break;
case OSPF_TYPE_LS_ACK:
if (ndo->ndo_vflag > 1) {
lshp = (const struct lsa6_hdr *)((const uint8_t *)op + OSPF6HDR_LEN);
while ((const u_char *)lshp < dataend) {
if (ospf6_print_lshdr(ndo, lshp++, dataend))
goto trunc;
}
}
break;
default:
break;
}
return (0);
trunc:
return (1);
}","static int
ospf6_decode_v3(netdissect_options *VAR_0,
register const struct ospf6hdr *VAR_1,
register const u_char *VAR_2)
{
register const rtrid_t *VAR_3;
register const struct lsr6 *VAR_4;
register const struct lsa6_hdr *VAR_5;
register const struct lsa6 *VAR_6;
register int VAR_7;
switch (VAR_1->ospf6_type) {
case VAR_8: {
register const struct hello6 *VAR_9 = (const struct hello6 *)((const uint8_t *)VAR_1 + VAR_10);
ND_PRINT((VAR_0, ""\n\tOptions [%s]"",
bittok2str(VAR_11, ""none"",
EXTRACT_32BITS(&VAR_9->hello_options))));
ND_TCHECK(VAR_9->hello_deadint);
ND_PRINT((VAR_0, ""\n\t  Hello Timer %us, Dead Timer %us, Interface-ID %s, Priority %u"",
EXTRACT_16BITS(&VAR_9->hello_helloint),
EXTRACT_16BITS(&VAR_9->hello_deadint),
ipaddr_string(VAR_0, &VAR_9->hello_ifid),
VAR_9->hello_priority));
ND_TCHECK(VAR_9->hello_dr);
if (EXTRACT_32BITS(&VAR_9->hello_dr) != 0)
ND_PRINT((VAR_0, ""\n\t  Designated Router %s"",
ipaddr_string(VAR_0, &VAR_9->hello_dr)));
ND_TCHECK(VAR_9->hello_bdr);
if (EXTRACT_32BITS(&VAR_9->hello_bdr) != 0)
ND_PRINT((VAR_0, "", Backup Designated Router %s"",
ipaddr_string(VAR_0, &VAR_9->hello_bdr)));
if (VAR_0->ndo_vflag > 1) {
ND_PRINT((VAR_0, ""\n\t  Neighbor List:""));
VAR_3 = VAR_9->hello_neighbor;
while ((const u_char *)VAR_3 < VAR_2) {
ND_TCHECK(*VAR_3);
ND_PRINT((VAR_0, ""\n\t    %s"", ipaddr_string(VAR_0, VAR_3)));
++VAR_3;
}
}
break;
}
case VAR_12: {
register const struct dd6 *VAR_13 = (const struct dd6 *)((const uint8_t *)VAR_1 + VAR_10);
ND_TCHECK(VAR_13->db_options);
ND_PRINT((VAR_0, ""\n\tOptions [%s]"",
bittok2str(VAR_11, ""none"",
EXTRACT_32BITS(&VAR_13->db_options))));
ND_TCHECK(VAR_13->db_flags);
ND_PRINT((VAR_0, "", DD Flags [%s]"",
bittok2str(VAR_14,""none"",VAR_13->db_flags)));
ND_TCHECK(VAR_13->db_seq);
ND_PRINT((VAR_0, "", MTU %u, DD-Sequence 0x%08x"",
EXTRACT_16BITS(&VAR_13->db_mtu),
EXTRACT_32BITS(&VAR_13->db_seq)));
if (VAR_0->ndo_vflag > 1) {
VAR_5 = VAR_13->db_lshdr;
while ((const u_char *)VAR_5 < VAR_2) {
if (ospf6_print_lshdr(VAR_0, VAR_5++, VAR_2))
goto trunc;
}
}
break;
}
case VAR_15:
if (VAR_0->ndo_vflag > 1) {
VAR_4 = (const struct lsr6 *)((const uint8_t *)VAR_1 + VAR_10);
while ((const u_char *)VAR_4 < VAR_2) {
ND_TCHECK(*VAR_4);
ND_PRINT((VAR_0, ""\n\t  Advertising Router %s"",
ipaddr_string(VAR_0, &VAR_4->ls_router)));
ospf6_print_ls_type(VAR_0, EXTRACT_16BITS(&VAR_4->ls_type),
&VAR_4->ls_stateid);
++VAR_4;
}
}
break;
case VAR_16:
if (VAR_0->ndo_vflag > 1) {
register const struct lsu6 *VAR_17 = (const struct lsu6 *)((const uint8_t *)VAR_1 + VAR_10);
ND_TCHECK(VAR_17->lsu_count);
VAR_7 = EXTRACT_32BITS(&VAR_17->lsu_count);
VAR_6 = VAR_17->lsu_lsa;
while ((const u_char *)VAR_6 < VAR_2 && VAR_7--) {
if (ospf6_print_lsa(VAR_0, VAR_6, VAR_2))
goto trunc;
VAR_6 = (const struct lsa6 *)((const u_char *)VAR_6 +
EXTRACT_16BITS(&VAR_6->ls_hdr.ls_length));
}
}
break;
case VAR_18:
if (VAR_0->ndo_vflag > 1) {
VAR_5 = (const struct lsa6_hdr *)((const uint8_t *)VAR_1 + VAR_10);
while ((const u_char *)VAR_5 < VAR_2) {
if (ospf6_print_lshdr(VAR_0, VAR_5++, VAR_2))
goto trunc;
}
}
break;
default:
break;
}
return (0);
trunc:
return (1);
}",the-tcpdump-group/tcpdump/88b2dac837e81cf56dce05e6e7b5989332c0092d/print-ospf6.c/vul/before/0.json,"static int
ospf6_decode_v3(netdissect_options *ndo,
                register const struct ospf6hdr *op,
                register const u_char *dataend)
{
	register const rtrid_t *ap;
	register const struct lsr6 *lsrp;
	register const struct lsa6_hdr *lshp;
	register const struct lsa6 *lsap;
	register int i;

	switch (op->ospf6_type) {

	case OSPF_TYPE_HELLO: {
		register const struct hello6 *hellop = (const struct hello6 *)((const uint8_t *)op + OSPF6HDR_LEN);

		ND_TCHECK_32BITS(&hellop->hello_options);
		ND_PRINT((ndo, ""\n\tOptions [%s]"",
		          bittok2str(ospf6_option_values, ""none"",
		          EXTRACT_32BITS(&hellop->hello_options))));

		ND_TCHECK(hellop->hello_deadint);
		ND_PRINT((ndo, ""\n\t  Hello Timer %us, Dead Timer %us, Interface-ID %s, Priority %u"",
		          EXTRACT_16BITS(&hellop->hello_helloint),
		          EXTRACT_16BITS(&hellop->hello_deadint),
		          ipaddr_string(ndo, &hellop->hello_ifid),
		          hellop->hello_priority));

		ND_TCHECK(hellop->hello_dr);
		if (EXTRACT_32BITS(&hellop->hello_dr) != 0)
			ND_PRINT((ndo, ""\n\t  Designated Router %s"",
			    ipaddr_string(ndo, &hellop->hello_dr)));
		ND_TCHECK(hellop->hello_bdr);
		if (EXTRACT_32BITS(&hellop->hello_bdr) != 0)
			ND_PRINT((ndo, "", Backup Designated Router %s"",
			    ipaddr_string(ndo, &hellop->hello_bdr)));
		if (ndo->ndo_vflag > 1) {
			ND_PRINT((ndo, ""\n\t  Neighbor List:""));
			ap = hellop->hello_neighbor;
			while ((const u_char *)ap < dataend) {
				ND_TCHECK(*ap);
				ND_PRINT((ndo, ""\n\t    %s"", ipaddr_string(ndo, ap)));
				++ap;
			}
		}
		break;	/* HELLO */
	}

	case OSPF_TYPE_DD: {
		register const struct dd6 *ddp = (const struct dd6 *)((const uint8_t *)op + OSPF6HDR_LEN);

		ND_TCHECK(ddp->db_options);
		ND_PRINT((ndo, ""\n\tOptions [%s]"",
		          bittok2str(ospf6_option_values, ""none"",
		          EXTRACT_32BITS(&ddp->db_options))));
		ND_TCHECK(ddp->db_flags);
		ND_PRINT((ndo, "", DD Flags [%s]"",
		          bittok2str(ospf6_dd_flag_values,""none"",ddp->db_flags)));

		ND_TCHECK(ddp->db_seq);
		ND_PRINT((ndo, "", MTU %u, DD-Sequence 0x%08x"",
                       EXTRACT_16BITS(&ddp->db_mtu),
                       EXTRACT_32BITS(&ddp->db_seq)));
		if (ndo->ndo_vflag > 1) {
			/* Print all the LS adv's */
			lshp = ddp->db_lshdr;
			while ((const u_char *)lshp < dataend) {
				if (ospf6_print_lshdr(ndo, lshp++, dataend))
					goto trunc;
			}
		}
		break;
	}

	case OSPF_TYPE_LS_REQ:
		if (ndo->ndo_vflag > 1) {
			lsrp = (const struct lsr6 *)((const uint8_t *)op + OSPF6HDR_LEN);
			while ((const u_char *)lsrp < dataend) {
				ND_TCHECK(*lsrp);
				ND_PRINT((ndo, ""\n\t  Advertising Router %s"",
				          ipaddr_string(ndo, &lsrp->ls_router)));
				ospf6_print_ls_type(ndo, EXTRACT_16BITS(&lsrp->ls_type),
                                                    &lsrp->ls_stateid);
				++lsrp;
			}
		}
		break;

	case OSPF_TYPE_LS_UPDATE:
		if (ndo->ndo_vflag > 1) {
			register const struct lsu6 *lsup = (const struct lsu6 *)((const uint8_t *)op + OSPF6HDR_LEN);

			ND_TCHECK(lsup->lsu_count);
			i = EXTRACT_32BITS(&lsup->lsu_count);
			lsap = lsup->lsu_lsa;
			while ((const u_char *)lsap < dataend && i--) {
				if (ospf6_print_lsa(ndo, lsap, dataend))
					goto trunc;
				lsap = (const struct lsa6 *)((const u_char *)lsap +
				    EXTRACT_16BITS(&lsap->ls_hdr.ls_length));
			}
		}
		break;

	case OSPF_TYPE_LS_ACK:
		if (ndo->ndo_vflag > 1) {
			lshp = (const struct lsa6_hdr *)((const uint8_t *)op + OSPF6HDR_LEN);
			while ((const u_char *)lshp < dataend) {
				if (ospf6_print_lshdr(ndo, lshp++, dataend))
					goto trunc;
			}
		}
		break;

	default:
		break;
	}
	return (0);
trunc:
	return (1);
}","static int
ospf6_decode_v3(netdissect_options *VAR_0,
                register const struct ospf6hdr *VAR_1,
                register const u_char *VAR_2)
{
	register const rtrid_t *VAR_3;
	register const struct lsr6 *VAR_4;
	register const struct lsa6_hdr *VAR_5;
	register const struct lsa6 *VAR_6;
	register int VAR_7;

	switch (VAR_1->ospf6_type) {

	case VAR_8: {
		register const struct hello6 *VAR_9 = (const struct hello6 *)((const uint8_t *)VAR_1 + VAR_10);

		ND_TCHECK_32BITS(&VAR_9->hello_options);
		ND_PRINT((VAR_0, ""\n\tOptions [%s]"",
		          bittok2str(VAR_11, ""none"",
		          EXTRACT_32BITS(&VAR_9->hello_options))));

		ND_TCHECK(VAR_9->hello_deadint);
		ND_PRINT((VAR_0, ""\n\t  Hello Timer %us, Dead Timer %us, Interface-ID %s, Priority %u"",
		          EXTRACT_16BITS(&VAR_9->hello_helloint),
		          EXTRACT_16BITS(&VAR_9->hello_deadint),
		          ipaddr_string(VAR_0, &VAR_9->hello_ifid),
		          VAR_9->hello_priority));

		ND_TCHECK(VAR_9->hello_dr);
		if (EXTRACT_32BITS(&VAR_9->hello_dr) != 0)
			ND_PRINT((VAR_0, ""\n\t  Designated Router %s"",
			    ipaddr_string(VAR_0, &VAR_9->hello_dr)));
		ND_TCHECK(VAR_9->hello_bdr);
		if (EXTRACT_32BITS(&VAR_9->hello_bdr) != 0)
			ND_PRINT((VAR_0, "", Backup Designated Router %s"",
			    ipaddr_string(VAR_0, &VAR_9->hello_bdr)));
		if (VAR_0->ndo_vflag > 1) {
			ND_PRINT((VAR_0, ""\n\t  Neighbor List:""));
			VAR_3 = VAR_9->hello_neighbor;
			while ((const u_char *)VAR_3 < VAR_2) {
				ND_TCHECK(*VAR_3);
				ND_PRINT((VAR_0, ""\n\t    %s"", ipaddr_string(VAR_0, VAR_3)));
				++VAR_3;
			}
		}
		break;	/* COMMENT_0 */
	}

	case VAR_12: {
		register const struct dd6 *VAR_13 = (const struct dd6 *)((const uint8_t *)VAR_1 + VAR_10);

		ND_TCHECK(VAR_13->db_options);
		ND_PRINT((VAR_0, ""\n\tOptions [%s]"",
		          bittok2str(VAR_11, ""none"",
		          EXTRACT_32BITS(&VAR_13->db_options))));
		ND_TCHECK(VAR_13->db_flags);
		ND_PRINT((VAR_0, "", DD Flags [%s]"",
		          bittok2str(VAR_14,""none"",VAR_13->db_flags)));

		ND_TCHECK(VAR_13->db_seq);
		ND_PRINT((VAR_0, "", MTU %u, DD-Sequence 0x%08x"",
                       EXTRACT_16BITS(&VAR_13->db_mtu),
                       EXTRACT_32BITS(&VAR_13->db_seq)));
		if (VAR_0->ndo_vflag > 1) {
			/* COMMENT_1 */
			VAR_5 = VAR_13->db_lshdr;
			while ((const u_char *)VAR_5 < VAR_2) {
				if (ospf6_print_lshdr(VAR_0, VAR_5++, VAR_2))
					goto trunc;
			}
		}
		break;
	}

	case VAR_15:
		if (VAR_0->ndo_vflag > 1) {
			VAR_4 = (const struct lsr6 *)((const uint8_t *)VAR_1 + VAR_10);
			while ((const u_char *)VAR_4 < VAR_2) {
				ND_TCHECK(*VAR_4);
				ND_PRINT((VAR_0, ""\n\t  Advertising Router %s"",
				          ipaddr_string(VAR_0, &VAR_4->ls_router)));
				ospf6_print_ls_type(VAR_0, EXTRACT_16BITS(&VAR_4->ls_type),
                                                    &VAR_4->ls_stateid);
				++VAR_4;
			}
		}
		break;

	case VAR_16:
		if (VAR_0->ndo_vflag > 1) {
			register const struct lsu6 *VAR_17 = (const struct lsu6 *)((const uint8_t *)VAR_1 + VAR_10);

			ND_TCHECK(VAR_17->lsu_count);
			VAR_7 = EXTRACT_32BITS(&VAR_17->lsu_count);
			VAR_6 = VAR_17->lsu_lsa;
			while ((const u_char *)VAR_6 < VAR_2 && VAR_7--) {
				if (ospf6_print_lsa(VAR_0, VAR_6, VAR_2))
					goto trunc;
				VAR_6 = (const struct lsa6 *)((const u_char *)VAR_6 +
				    EXTRACT_16BITS(&VAR_6->ls_hdr.ls_length));
			}
		}
		break;

	case VAR_18:
		if (VAR_0->ndo_vflag > 1) {
			VAR_5 = (const struct lsa6_hdr *)((const uint8_t *)VAR_1 + VAR_10);
			while ((const u_char *)VAR_5 < VAR_2) {
				if (ospf6_print_lshdr(VAR_0, VAR_5++, VAR_2))
					goto trunc;
			}
		}
		break;

	default:
		break;
	}
	return (0);
trunc:
	return (1);
}",the-tcpdump-group/tcpdump/88b2dac837e81cf56dce05e6e7b5989332c0092d/print-ospf6.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,6 +14,7 @@
 	case OSPF_TYPE_HELLO: {
 		register const struct hello6 *hellop = (const struct hello6 *)((const uint8_t *)op + OSPF6HDR_LEN);
 
+		ND_TCHECK_32BITS(&hellop->hello_options);
 		ND_PRINT((ndo, ""\n\tOptions [%s]"",
 		          bittok2str(ospf6_option_values, ""none"",
 		          EXTRACT_32BITS(&hellop->hello_options))));","{'deleted_lines': [], 'added_lines': ['\t\tND_TCHECK_32BITS(&hellop->hello_options);']}",True,The OSPFv3 parser in tcpdump before 4.9.2 has a buffer over-read in print-ospf6.c:ospf6_decode_v3().,9.8,CRITICAL,3,test,2017-03-23T23:55:18Z,1
CVE-2017-7274,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,radareorg/radare2,Fix #7152 - Null deref in cms,7ab66cca5bbdf6cb2d69339ef4f513d95e532dbf,https://github.com/radareorg/radare2/commit/7ab66cca5bbdf6cb2d69339ef4f513d95e532dbf,libr/util/r_pkcs7.c,r_pkcs7_parse_cms,"RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {
RASN1Object *object;
RCMS *container;
if (!buffer || !length) {
return NULL;
}
container = R_NEW0 (RCMS);
if (!container) {
return NULL;
}
object = r_asn1_create_object (buffer, length);
if (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {
r_asn1_free_object (object);
free (container);
return NULL;
}
container->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);
r_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);
r_asn1_free_object (object);
return container;
}","RCMS *r_pkcs7_parse_cms (const ut8 *VAR_0, ut32 VAR_1) {
RASN1Object *VAR_2;
RCMS *VAR_3;
if (!VAR_0 || !VAR_1) {
return NULL;
}
VAR_3 = R_NEW0 (RCMS);
if (!VAR_3) {
return NULL;
}
VAR_2 = r_asn1_create_object (VAR_0, VAR_1);
if (!VAR_2 || VAR_2->list.length != 2 || !VAR_2->list.objects[0] || VAR_2->list.objects[1]->list.length != 1) {
r_asn1_free_object (VAR_2);
free (VAR_3);
return NULL;
}
VAR_3->contentType = r_asn1_stringify_oid (VAR_2->list.objects[0]->sector, VAR_2->list.objects[0]->length);
r_pkcs7_parse_signeddata (&VAR_3->signedData, VAR_2->list.objects[1]->list.objects[0]);
r_asn1_free_object (VAR_2);
return VAR_3;
}",radareorg/radare2/7ab66cca5bbdf6cb2d69339ef4f513d95e532dbf/r_pkcs7.c/vul/before/0.json,"RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {
	RASN1Object *object;
	RCMS *container;
	if (!buffer || !length) {
		return NULL;
	}
	container = R_NEW0 (RCMS);
	if (!container) {
		return NULL;
	}
	object = r_asn1_create_object (buffer, length);
	if (!object || object->list.length != 2 || !object->list.objects ||
		!object->list.objects[0] || !object->list.objects[1] ||
		object->list.objects[1]->list.length != 1) {
		r_asn1_free_object (object);
		free (container);
		return NULL;
	}
	container->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);
	r_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);
	r_asn1_free_object (object);
	return container;
}","RCMS *r_pkcs7_parse_cms (const ut8 *VAR_0, ut32 VAR_1) {
	RASN1Object *VAR_2;
	RCMS *VAR_3;
	if (!VAR_0 || !VAR_1) {
		return NULL;
	}
	VAR_3 = R_NEW0 (RCMS);
	if (!VAR_3) {
		return NULL;
	}
	VAR_2 = r_asn1_create_object (VAR_0, VAR_1);
	if (!VAR_2 || VAR_2->list.length != 2 || !VAR_2->list.objects ||
		!VAR_2->list.objects[0] || !VAR_2->list.objects[1] ||
		VAR_2->list.objects[1]->list.length != 1) {
		r_asn1_free_object (VAR_2);
		free (VAR_3);
		return NULL;
	}
	VAR_3->contentType = r_asn1_stringify_oid (VAR_2->list.objects[0]->sector, VAR_2->list.objects[0]->length);
	r_pkcs7_parse_signeddata (&VAR_3->signedData, VAR_2->list.objects[1]->list.objects[0]);
	r_asn1_free_object (VAR_2);
	return VAR_3;
}",radareorg/radare2/7ab66cca5bbdf6cb2d69339ef4f513d95e532dbf/r_pkcs7.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,7 +9,9 @@
 		return NULL;
 	}
 	object = r_asn1_create_object (buffer, length);
-	if (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {
+	if (!object || object->list.length != 2 || !object->list.objects ||
+		!object->list.objects[0] || !object->list.objects[1] ||
+		object->list.objects[1]->list.length != 1) {
 		r_asn1_free_object (object);
 		free (container);
 		return NULL;","{'deleted_lines': ['\tif (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {'], 'added_lines': ['\tif (!object || object->list.length != 2 || !object->list.objects ||', '\t\t!object->list.objects[0] || !object->list.objects[1] ||', '\t\tobject->list.objects[1]->list.length != 1) {']}",True,The r_pkcs7_parse_cms function in libr/util/r_pkcs7.c in radare2 1.3.0 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted PE file.,5.5,MEDIUM,1,test,2017-03-27T10:55:16Z,1
CVE-2017-7393,['CWE-415'],AV:N/AC:L/Au:S/C:P/I:P/A:P,0,TigerVNC/tigervnc,"Prevent double free by crafted fences.

If client sent fence with some data, followed by fence with no data (length 0), the original fence data were freed, but the pointer kept pointing at them. Sending one more fence would attempt to free them again.",f3afa24da144409a3c3a0e35913112583d987671,https://github.com/TigerVNC/tigervnc/commit/f3afa24da144409a3c3a0e35913112583d987671,common/rfb/VNCSConnectionST.cxx,VNCSConnectionST::fence,"void VNCSConnectionST::fence(rdr::U32 flags, unsigned len, const char data[])
{
if (flags & fenceFlagRequest) {
if (flags & fenceFlagSyncNext) {
pendingSyncFence = true;
fenceFlags = flags & (fenceFlagBlockBefore | fenceFlagBlockAfter | fenceFlagSyncNext);
fenceDataLen = len;
delete [] fenceData;
if (len > 0) {
fenceData = new char[len];
memcpy(fenceData, data, len);
}
return;
}
flags = flags & (fenceFlagBlockBefore | fenceFlagBlockAfter);
writer()->writeFence(flags, len, data);
return;
}
struct RTTInfo rttInfo;
switch (len) {
case 0:
break;
case sizeof(struct RTTInfo):
memcpy(&rttInfo, data, sizeof(struct RTTInfo));
handleRTTPong(rttInfo);
break;
default:
vlog.error(""Fence response of unexpected size received"");
}
}","void VNCSConnectionST::fence(rdr::U32 VAR_0, unsigned VAR_1, const char VAR_2[])
{
if (VAR_0 & VAR_3) {
if (VAR_0 & VAR_4) {
VAR_5 = true;
VAR_6 = VAR_0 & (VAR_7 | VAR_8 | VAR_4);
VAR_9 = VAR_1;
delete [] VAR_10;
if (VAR_1 > 0) {
VAR_10 = new char[VAR_1];
memcpy(VAR_10, VAR_2, VAR_1);
}
return;
}
VAR_0 = VAR_0 & (VAR_7 | VAR_8);
writer()->writeFence(VAR_0, VAR_1, VAR_2);
return;
}
struct RTTInfo VAR_11;
switch (VAR_1) {
case 0:
break;
case sizeof(struct RTTInfo):
memcpy(&VAR_11, VAR_2, sizeof(struct RTTInfo));
handleRTTPong(VAR_11);
break;
default:
VAR_12.error(""Fence response of unexpected size received"");
}
}",TigerVNC/tigervnc/f3afa24da144409a3c3a0e35913112583d987671/VNCSConnectionST.cxx/vul/before/0.json,"void VNCSConnectionST::fence(rdr::U32 flags, unsigned len, const char data[])
{
  if (flags & fenceFlagRequest) {
    if (flags & fenceFlagSyncNext) {
      pendingSyncFence = true;

      fenceFlags = flags & (fenceFlagBlockBefore | fenceFlagBlockAfter | fenceFlagSyncNext);
      fenceDataLen = len;
      delete [] fenceData;
      fenceData = NULL;
      if (len > 0) {
        fenceData = new char[len];
        memcpy(fenceData, data, len);
      }

      return;
    }

    // We handle everything synchronously so we trivially honor these modes
    flags = flags & (fenceFlagBlockBefore | fenceFlagBlockAfter);

    writer()->writeFence(flags, len, data);
    return;
  }

  struct RTTInfo rttInfo;

  switch (len) {
  case 0:
    // Initial dummy fence;
    break;
  case sizeof(struct RTTInfo):
    memcpy(&rttInfo, data, sizeof(struct RTTInfo));
    handleRTTPong(rttInfo);
    break;
  default:
    vlog.error(""Fence response of unexpected size received"");
  }
}","void VNCSConnectionST::fence(rdr::U32 VAR_0, unsigned VAR_1, const char VAR_2[])
{
  if (VAR_0 & VAR_3) {
    if (VAR_0 & VAR_4) {
      VAR_5 = true;

      VAR_6 = VAR_0 & (VAR_7 | VAR_8 | VAR_4);
      VAR_9 = VAR_1;
      delete [] VAR_10;
      VAR_10 = NULL;
      if (VAR_1 > 0) {
        VAR_10 = new char[VAR_1];
        memcpy(VAR_10, VAR_2, VAR_1);
      }

      return;
    }

    /* COMMENT_0 */
    VAR_0 = VAR_0 & (VAR_7 | VAR_8);

    writer()->writeFence(VAR_0, VAR_1, VAR_2);
    return;
  }

  struct RTTInfo VAR_11;

  switch (VAR_1) {
  case 0:
    /* COMMENT_1 */
    break;
  case sizeof(struct RTTInfo):
    memcpy(&VAR_11, VAR_2, sizeof(struct RTTInfo));
    handleRTTPong(VAR_11);
    break;
  default:
    VAR_12.error(""Fence response of unexpected size received"");
  }
}",TigerVNC/tigervnc/f3afa24da144409a3c3a0e35913112583d987671/VNCSConnectionST.cxx/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,6 +7,7 @@
       fenceFlags = flags & (fenceFlagBlockBefore | fenceFlagBlockAfter | fenceFlagSyncNext);
       fenceDataLen = len;
       delete [] fenceData;
+      fenceData = NULL;
       if (len > 0) {
         fenceData = new char[len];
         memcpy(fenceData, data, len);","{'deleted_lines': [], 'added_lines': ['      fenceData = NULL;']}",True,"In TigerVNC 1.7.1 (VNCSConnectionST.cxx VNCSConnectionST::fence), an authenticated client can cause a double free, leading to denial of service or potentially code execution.",8.8,HIGH,2,test,2017-03-27T16:02:15Z,1
CVE-2017-7393,['CWE-415'],AV:N/AC:L/Au:S/C:P/I:P/A:P,0,TigerVNC/tigervnc,"Prevent double free by crafted fences.

If client sent fence with some data, followed by fence with no data (length 0), the original fence data were freed, but the pointer kept pointing at them. Sending one more fence would attempt to free them again.",f3afa24da144409a3c3a0e35913112583d987671,https://github.com/TigerVNC/tigervnc/commit/f3afa24da144409a3c3a0e35913112583d987671,common/rfb/SMsgWriter.cxx,SMsgWriter::writeFence,"void SMsgWriter::writeFence(rdr::U32 flags, unsigned len, const char data[])
{
if (!cp->supportsFence)
throw Exception(""Client does not support fences"");
if (len > 64)
throw Exception(""Too large fence payload"");
if ((flags & ~fenceFlagsSupported) != 0)
throw Exception(""Unknown fence flags"");
startMsg(msgTypeServerFence);
os->pad(3);
os->writeU32(flags);
os->writeU8(len);
os->writeBytes(data, len);
endMsg();
}","void SMsgWriter::writeFence(rdr::U32 VAR_0, unsigned VAR_1, const char VAR_2[])
{
if (!VAR_3->supportsFence)
throw Exception(""Client does not support fences"");
if (VAR_1 > 64)
throw Exception(""Too large fence payload"");
if ((VAR_0 & ~VAR_4) != 0)
throw Exception(""Unknown fence flags"");
startMsg(VAR_5);
VAR_6->pad(3);
VAR_6->writeU32(VAR_0);
VAR_6->writeU8(VAR_1);
VAR_6->writeBytes(VAR_2, VAR_1);
endMsg();
}",TigerVNC/tigervnc/f3afa24da144409a3c3a0e35913112583d987671/SMsgWriter.cxx/vul/before/0.json,"void SMsgWriter::writeFence(rdr::U32 flags, unsigned len, const char data[])
{
  if (!cp->supportsFence)
    throw Exception(""Client does not support fences"");
  if (len > 64)
    throw Exception(""Too large fence payload"");
  if ((flags & ~fenceFlagsSupported) != 0)
    throw Exception(""Unknown fence flags"");

  startMsg(msgTypeServerFence);
  os->pad(3);

  os->writeU32(flags);

  os->writeU8(len);

  if (len > 0)
    os->writeBytes(data, len);

  endMsg();
}","void SMsgWriter::writeFence(rdr::U32 VAR_0, unsigned VAR_1, const char VAR_2[])
{
  if (!VAR_3->supportsFence)
    throw Exception(""Client does not support fences"");
  if (VAR_1 > 64)
    throw Exception(""Too large fence payload"");
  if ((VAR_0 & ~VAR_4) != 0)
    throw Exception(""Unknown fence flags"");

  startMsg(VAR_5);
  VAR_6->pad(3);

  VAR_6->writeU32(VAR_0);

  VAR_6->writeU8(VAR_1);

  if (VAR_1 > 0)
    VAR_6->writeBytes(VAR_2, VAR_1);

  endMsg();
}",TigerVNC/tigervnc/f3afa24da144409a3c3a0e35913112583d987671/SMsgWriter.cxx/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,7 +13,9 @@
   os->writeU32(flags);
 
   os->writeU8(len);
-  os->writeBytes(data, len);
+
+  if (len > 0)
+    os->writeBytes(data, len);
 
   endMsg();
 }","{'deleted_lines': ['  os->writeBytes(data, len);'], 'added_lines': ['', '  if (len > 0)', '    os->writeBytes(data, len);']}",True,"In TigerVNC 1.7.1 (VNCSConnectionST.cxx VNCSConnectionST::fence), an authenticated client can cause a double free, leading to denial of service or potentially code execution.",8.8,HIGH,2,test,2017-03-27T16:02:15Z,1
CVE-2017-8349,['CWE-772'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/443,5b1b7895bb5c75596942e5c642ea44b0dd13ddec,https://github.com/ImageMagick/ImageMagick/commit/5b1b7895bb5c75596942e5c642ea44b0dd13ddec,coders/sfw.c,ReadSFWImage,"static Image *ReadSFWImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
static unsigned char
HuffmanTable[] =
{
0xFF, 0xC4, 0x01, 0xA2, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04,
0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x10, 0x00, 0x02, 0x01,
0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00,
0x01, 0x7D, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21,
0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32,
0x81, 0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1,
0xF0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A, 0x16, 0x17, 0x18,
0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x34, 0x35, 0x36,
0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64,
0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77,
0x78, 0x79, 0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A,
0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3,
0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5,
0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9,
0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA,
0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0x11,
0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04,
0x04, 0x00, 0x01, 0x02, 0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04,
0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13,
0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09,
0x23, 0x33, 0x52, 0xF0, 0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16, 0x24,
0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26, 0x27, 0x28,
0x29, 0x2A, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45,
0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73,
0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x82, 0x83, 0x84, 0x85,
0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9,
0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2,
0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4,
0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,
0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8,
0xF9, 0xFA
};
FILE
*file;
Image
*flipped_image,
*jpeg_image,
*image;
ImageInfo
*read_info;
int
unique_file;
MagickBooleanType
status;
register unsigned char
*header,
*data;
size_t
extent;
ssize_t
count;
unsigned char
*buffer,
*offset;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
image=AcquireImage(image_info,exception);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
if (GetBlobSize(image) != (size_t) GetBlobSize(image))
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
buffer=(unsigned char *) AcquireQuantumMemory((size_t) GetBlobSize(image),
sizeof(*buffer));
if (buffer == (unsigned char *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
count=ReadBlob(image,(size_t) GetBlobSize(image),buffer);
if ((count != (ssize_t) GetBlobSize(image)) ||
(LocaleNCompare((char *) buffer,""SFW"",3) != 0))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
(void) CloseBlob(image);
header=SFWScan(buffer,buffer+count-1,(const unsigned char *)
""\377\310\377\320"",4);
if (header == (unsigned char *) NULL)
{
buffer=(unsigned char *) RelinquishMagickMemory(buffer);
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
}
TranslateSFWMarker(header);  
TranslateSFWMarker(header+2);
(void) CopyMagickMemory(header+6,""JFIF\0\001\0"",7);  
offset=header+2;
offset+=(((unsigned int) offset[2]) << 8)+offset[3]+2;
for ( ; ; )
{
if ((offset+4) > (buffer+count-1))
{
buffer=(unsigned char *) RelinquishMagickMemory(buffer);
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
}
TranslateSFWMarker(offset);
if (offset[1] == 0xda)
break;
offset+=(((unsigned int) offset[2]) << 8)+offset[3]+2;
}
offset--;
data=SFWScan(offset,buffer+count-1,(const unsigned char *) ""\377\311"",2);
if (data == (unsigned char *) NULL)
{
buffer=(unsigned char *) RelinquishMagickMemory(buffer);
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
}
TranslateSFWMarker(data++);  
read_info=CloneImageInfo(image_info);
SetImageInfoBlob(read_info,(void *) NULL,0);
file=(FILE *) NULL;
unique_file=AcquireUniqueFileResource(read_info->filename);
if (unique_file != -1)
file=fopen_utf8(read_info->filename,""wb"");
if ((unique_file == -1) || (file == (FILE *) NULL))
{
buffer=(unsigned char *) RelinquishMagickMemory(buffer);
read_info=DestroyImageInfo(read_info);
(void) CopyMagickString(image->filename,read_info->filename,
MagickPathExtent);
ThrowFileException(exception,FileOpenError,""UnableToCreateTemporaryFile"",
image->filename);
image=DestroyImageList(image);
return((Image *) NULL);
}
extent=fwrite(header,(size_t) (offset-header+1),1,file);
(void) extent;
extent=fwrite(HuffmanTable,1,sizeof(HuffmanTable)/sizeof(*HuffmanTable),file);
extent=fwrite(offset+1,(size_t) (data-offset),1,file);
status=ferror(file) != 0 ? MagickFalse : MagickTrue;
(void) fclose(file);
(void) close(unique_file);
buffer=(unsigned char *) RelinquishMagickMemory(buffer);
if (status == MagickFalse)
{
char
*message;
(void) remove_utf8(read_info->filename);
read_info=DestroyImageInfo(read_info);
message=GetExceptionMessage(errno);
(void) ThrowMagickException(exception,GetMagickModule(),FileOpenError,
""UnableToWriteFile"",""`%s': %s"",image->filename,message);
message=DestroyString(message);
image=DestroyImageList(image);
return((Image *) NULL);
}
jpeg_image=ReadImage(read_info,exception);
(void) RelinquishUniqueFileResource(read_info->filename);
read_info=DestroyImageInfo(read_info);
if (jpeg_image == (Image *) NULL)
{
image=DestroyImageList(image);
return(jpeg_image);
}
(void) CopyMagickString(jpeg_image->filename,image->filename,MagickPathExtent);
(void) CopyMagickString(jpeg_image->magick,image->magick,MagickPathExtent);
image=DestroyImageList(image);
image=jpeg_image;
flipped_image=FlipImage(image,exception);
if (flipped_image != (Image *) NULL)
{
DuplicateBlob(flipped_image,image);
image=DestroyImage(image);
image=flipped_image;
}
return(GetFirstImageInList(image));
}","static Image *ReadSFWImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
static unsigned char
VAR_2[] =
{
0xFF, 0xC4, 0x01, 0xA2, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01,
0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04,
0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x10, 0x00, 0x02, 0x01,
0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00,
0x01, 0x7D, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21,
0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32,
0x81, 0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1,
0xF0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A, 0x16, 0x17, 0x18,
0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x34, 0x35, 0x36,
0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64,
0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77,
0x78, 0x79, 0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A,
0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3,
0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5,
0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9,
0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA,
0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0x11,
0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04,
0x04, 0x00, 0x01, 0x02, 0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04,
0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13,
0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09,
0x23, 0x33, 0x52, 0xF0, 0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16, 0x24,
0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26, 0x27, 0x28,
0x29, 0x2A, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45,
0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73,
0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x82, 0x83, 0x84, 0x85,
0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9,
0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2,
0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4,
0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,
0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8,
0xF9, 0xFA
};
FILE
*VAR_3;
Image
*VAR_4,
*VAR_5,
*VAR_6;
ImageInfo
*VAR_7;
int
VAR_8;
MagickBooleanType
VAR_9;
register unsigned char
*VAR_10,
*VAR_11;
size_t
VAR_12;
ssize_t
VAR_13;
unsigned char
*VAR_14,
*VAR_15;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_16);
if (VAR_0->debug != VAR_17)
(void) LogMagickEvent(VAR_18,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_16);
VAR_6=AcquireImage(VAR_0,VAR_1);
VAR_9=OpenBlob(VAR_0,VAR_6,VAR_19,VAR_1);
if (VAR_9 == VAR_17)
{
VAR_6=DestroyImageList(VAR_6);
return((Image *) NULL);
}
if (GetBlobSize(VAR_6) != (size_t) GetBlobSize(VAR_6))
ThrowReaderException(VAR_20,""MemoryAllocationFailed"");
VAR_14=(unsigned char *) AcquireQuantumMemory((size_t) GetBlobSize(VAR_6),
sizeof(*VAR_14));
if (VAR_14 == (unsigned char *) NULL)
ThrowReaderException(VAR_20,""MemoryAllocationFailed"");
VAR_13=ReadBlob(VAR_6,(size_t) GetBlobSize(VAR_6),VAR_14);
if ((VAR_13 != (ssize_t) GetBlobSize(VAR_6)) ||
(LocaleNCompare((char *) VAR_14,""SFW"",3) != 0))
ThrowReaderException(VAR_21,""ImproperImageHeader"");
(void) CloseBlob(VAR_6);
VAR_10=SFWScan(VAR_14,VAR_14+VAR_13-1,(const unsigned char *)
""\377\310\377\320"",4);
if (VAR_10 == (unsigned char *) NULL)
{
VAR_14=(unsigned char *) RelinquishMagickMemory(VAR_14);
ThrowReaderException(VAR_21,""ImproperImageHeader"");
}
TranslateSFWMarker(VAR_10);  
TranslateSFWMarker(VAR_10+2);
(void) CopyMagickMemory(VAR_10+6,""JFIF\0\001\0"",7);  
VAR_15=VAR_10+2;
VAR_15+=(((unsigned int) VAR_15[2]) << 8)+VAR_15[3]+2;
for ( ; ; )
{
if ((VAR_15+4) > (VAR_14+VAR_13-1))
{
VAR_14=(unsigned char *) RelinquishMagickMemory(VAR_14);
ThrowReaderException(VAR_20,""MemoryAllocationFailed"");
}
TranslateSFWMarker(VAR_15);
if (VAR_15[1] == 0xda)
break;
VAR_15+=(((unsigned int) VAR_15[2]) << 8)+VAR_15[3]+2;
}
VAR_15--;
VAR_11=SFWScan(VAR_15,VAR_14+VAR_13-1,(const unsigned char *) ""\377\311"",2);
if (VAR_11 == (unsigned char *) NULL)
{
VAR_14=(unsigned char *) RelinquishMagickMemory(VAR_14);
ThrowReaderException(VAR_21,""ImproperImageHeader"");
}
TranslateSFWMarker(VAR_11++);  
VAR_7=CloneImageInfo(VAR_0);
SetImageInfoBlob(VAR_7,(void *) NULL,0);
VAR_3=(FILE *) NULL;
VAR_8=AcquireUniqueFileResource(VAR_7->filename);
if (VAR_8 != -1)
VAR_3=fopen_utf8(VAR_7->filename,""wb"");
if ((VAR_8 == -1) || (VAR_3 == (FILE *) NULL))
{
VAR_14=(unsigned char *) RelinquishMagickMemory(VAR_14);
VAR_7=DestroyImageInfo(VAR_7);
(void) CopyMagickString(VAR_6->filename,VAR_7->filename,
VAR_22);
ThrowFileException(VAR_1,VAR_23,""UnableToCreateTemporaryFile"",
VAR_6->filename);
VAR_6=DestroyImageList(VAR_6);
return((Image *) NULL);
}
VAR_12=fwrite(VAR_10,(size_t) (VAR_15-VAR_10+1),1,VAR_3);
(void) VAR_12;
VAR_12=fwrite(VAR_2,1,sizeof(HuffmanTable)/sizeof(*HuffmanTable),VAR_3);
VAR_12=fwrite(VAR_15+1,(size_t) (VAR_11-VAR_15),1,VAR_3);
VAR_9=ferror(VAR_3) != 0 ? VAR_17 : VAR_24;
(void) fclose(VAR_3);
(void) close(VAR_8);
VAR_14=(unsigned char *) RelinquishMagickMemory(VAR_14);
if (VAR_9 == VAR_17)
{
char
*VAR_25;
(void) remove_utf8(VAR_7->filename);
VAR_7=DestroyImageInfo(VAR_7);
VAR_25=GetExceptionMessage(VAR_26);
(void) ThrowMagickException(VAR_1,GetMagickModule(),VAR_23,
""UnableToWriteFile"",""`%s': %s"",VAR_6->filename,VAR_25);
VAR_25=DestroyString(VAR_25);
VAR_6=DestroyImageList(VAR_6);
return((Image *) NULL);
}
VAR_5=ReadImage(VAR_7,VAR_1);
(void) RelinquishUniqueFileResource(VAR_7->filename);
VAR_7=DestroyImageInfo(VAR_7);
if (VAR_5 == (Image *) NULL)
{
VAR_6=DestroyImageList(VAR_6);
return(VAR_5);
}
(void) CopyMagickString(VAR_5->filename,VAR_6->filename,VAR_22);
(void) CopyMagickString(VAR_5->magick,VAR_6->magick,VAR_22);
VAR_6=DestroyImageList(VAR_6);
VAR_6=VAR_5;
VAR_4=FlipImage(VAR_6,VAR_1);
if (VAR_4 != (Image *) NULL)
{
DuplicateBlob(VAR_4,VAR_6);
VAR_6=DestroyImage(VAR_6);
VAR_6=VAR_4;
}
return(GetFirstImageInList(VAR_6));
}",ImageMagick/5b1b7895bb5c75596942e5c642ea44b0dd13ddec/sfw.c/vul/before/0.json,"static Image *ReadSFWImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  static unsigned char
    HuffmanTable[] =
    {
      0xFF, 0xC4, 0x01, 0xA2, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01,
      0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
      0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
      0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04,
      0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x10, 0x00, 0x02, 0x01,
      0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00,
      0x01, 0x7D, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21,
      0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32,
      0x81, 0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1,
      0xF0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A, 0x16, 0x17, 0x18,
      0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x34, 0x35, 0x36,
      0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
      0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64,
      0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77,
      0x78, 0x79, 0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A,
      0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3,
      0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5,
      0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
      0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9,
      0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA,
      0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0x11,
      0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04,
      0x04, 0x00, 0x01, 0x02, 0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04,
      0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13,
      0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09,
      0x23, 0x33, 0x52, 0xF0, 0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16, 0x24,
      0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26, 0x27, 0x28,
      0x29, 0x2A, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45,
      0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
      0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73,
      0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x82, 0x83, 0x84, 0x85,
      0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
      0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9,
      0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2,
      0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4,
      0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,
      0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8,
      0xF9, 0xFA
    };

  FILE
    *file;

  Image
    *flipped_image,
    *jpeg_image,
    *image;

  ImageInfo
    *read_info;

  int
    unique_file;

  MagickBooleanType
    status;

  register unsigned char
    *header,
    *data;

  size_t
    extent;

  ssize_t
    count;

  unsigned char
    *buffer,
    *offset;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read image into a buffer.
  */
  if (GetBlobSize(image) != (size_t) GetBlobSize(image))
    ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  buffer=(unsigned char *) AcquireQuantumMemory((size_t) GetBlobSize(image),
    sizeof(*buffer));
  if (buffer == (unsigned char *) NULL)
    ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  count=ReadBlob(image,(size_t) GetBlobSize(image),buffer);
  if ((count != (ssize_t) GetBlobSize(image)) ||
      (LocaleNCompare((char *) buffer,""SFW"",3) != 0))
    {
      buffer=(unsigned char *) RelinquishMagickMemory(buffer);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }
  (void) CloseBlob(image);
  /*
    Find the start of the JFIF data
  */
  header=SFWScan(buffer,buffer+count-1,(const unsigned char *)
    ""\377\310\377\320"",4);
  if (header == (unsigned char *) NULL)
    {
      buffer=(unsigned char *) RelinquishMagickMemory(buffer);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }
  TranslateSFWMarker(header);  /* translate soi and app tags */
  TranslateSFWMarker(header+2);
  (void) CopyMagickMemory(header+6,""JFIF\0\001\0"",7);  /* JFIF magic */
  /*
    Translate remaining markers.
  */
  offset=header+2;
  offset+=(((unsigned int) offset[2]) << 8)+offset[3]+2;
  for ( ; ; )
  {
    if ((offset+4) > (buffer+count-1))
      {
        buffer=(unsigned char *) RelinquishMagickMemory(buffer);
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      }
    TranslateSFWMarker(offset);
    if (offset[1] == 0xda)
      break;
    offset+=(((unsigned int) offset[2]) << 8)+offset[3]+2;
  }
  offset--;
  data=SFWScan(offset,buffer+count-1,(const unsigned char *) ""\377\311"",2);
  if (data == (unsigned char *) NULL)
    {
      buffer=(unsigned char *) RelinquishMagickMemory(buffer);
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }
  TranslateSFWMarker(data++);  /* translate eoi marker */
  /*
    Write JFIF file.
  */
  read_info=CloneImageInfo(image_info);
  SetImageInfoBlob(read_info,(void *) NULL,0);
  file=(FILE *) NULL;
  unique_file=AcquireUniqueFileResource(read_info->filename);
  if (unique_file != -1)
    file=fopen_utf8(read_info->filename,""wb"");
  if ((unique_file == -1) || (file == (FILE *) NULL))
    {
      buffer=(unsigned char *) RelinquishMagickMemory(buffer);
      read_info=DestroyImageInfo(read_info);
      (void) CopyMagickString(image->filename,read_info->filename,
        MagickPathExtent);
      ThrowFileException(exception,FileOpenError,""UnableToCreateTemporaryFile"",
        image->filename);
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  extent=fwrite(header,(size_t) (offset-header+1),1,file);
  (void) extent;
  extent=fwrite(HuffmanTable,1,sizeof(HuffmanTable)/sizeof(*HuffmanTable),file);
  extent=fwrite(offset+1,(size_t) (data-offset),1,file);
  status=ferror(file) != 0 ? MagickFalse : MagickTrue;
  (void) fclose(file);
  (void) close(unique_file);
  buffer=(unsigned char *) RelinquishMagickMemory(buffer);
  if (status == MagickFalse)
    {
      char
        *message;

      (void) remove_utf8(read_info->filename);
      read_info=DestroyImageInfo(read_info);
      message=GetExceptionMessage(errno);
      (void) ThrowMagickException(exception,GetMagickModule(),FileOpenError,
        ""UnableToWriteFile"",""`%s': %s"",image->filename,message);
      message=DestroyString(message);
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Read JPEG image.
  */
  jpeg_image=ReadImage(read_info,exception);
  (void) RelinquishUniqueFileResource(read_info->filename);
  read_info=DestroyImageInfo(read_info);
  if (jpeg_image == (Image *) NULL)
    {
      image=DestroyImageList(image);
      return(jpeg_image);
    }
  (void) CopyMagickString(jpeg_image->filename,image->filename,MagickPathExtent);
  (void) CopyMagickString(jpeg_image->magick,image->magick,MagickPathExtent);
  image=DestroyImageList(image);
  image=jpeg_image;
  /*
    Correct image orientation.
  */
  flipped_image=FlipImage(image,exception);
  if (flipped_image != (Image *) NULL)
    {
      DuplicateBlob(flipped_image,image);
      image=DestroyImage(image);
      image=flipped_image;
    }
  return(GetFirstImageInList(image));
}","static Image *ReadSFWImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
  static unsigned char
    VAR_2[] =
    {
      0xFF, 0xC4, 0x01, 0xA2, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01,
      0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
      0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
      0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04,
      0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x10, 0x00, 0x02, 0x01,
      0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00,
      0x01, 0x7D, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21,
      0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32,
      0x81, 0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1,
      0xF0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A, 0x16, 0x17, 0x18,
      0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x34, 0x35, 0x36,
      0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
      0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64,
      0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77,
      0x78, 0x79, 0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A,
      0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3,
      0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5,
      0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
      0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9,
      0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA,
      0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0x11,
      0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04,
      0x04, 0x00, 0x01, 0x02, 0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04,
      0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13,
      0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09,
      0x23, 0x33, 0x52, 0xF0, 0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16, 0x24,
      0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26, 0x27, 0x28,
      0x29, 0x2A, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45,
      0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
      0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73,
      0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x82, 0x83, 0x84, 0x85,
      0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
      0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9,
      0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2,
      0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4,
      0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,
      0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8,
      0xF9, 0xFA
    };

  FILE
    *VAR_3;

  Image
    *VAR_4,
    *VAR_5,
    *VAR_6;

  ImageInfo
    *VAR_7;

  int
    VAR_8;

  MagickBooleanType
    VAR_9;

  register unsigned char
    *VAR_10,
    *VAR_11;

  size_t
    VAR_12;

  ssize_t
    VAR_13;

  unsigned char
    *VAR_14,
    *VAR_15;

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_16);
  if (VAR_0->debug != VAR_17)
    (void) LogMagickEvent(VAR_18,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_16);
  VAR_6=AcquireImage(VAR_0,VAR_1);
  VAR_9=OpenBlob(VAR_0,VAR_6,VAR_19,VAR_1);
  if (VAR_9 == VAR_17)
    {
      VAR_6=DestroyImageList(VAR_6);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                             
    
  if (GetBlobSize(VAR_6) != (size_t) GetBlobSize(VAR_6))
    ThrowReaderException(VAR_20,""MemoryAllocationFailed"");
  VAR_14=(unsigned char *) AcquireQuantumMemory((size_t) GetBlobSize(VAR_6),
    sizeof(*VAR_14));
  if (VAR_14 == (unsigned char *) NULL)
    ThrowReaderException(VAR_20,""MemoryAllocationFailed"");
  VAR_13=ReadBlob(VAR_6,(size_t) GetBlobSize(VAR_6),VAR_14);
  if ((VAR_13 != (ssize_t) GetBlobSize(VAR_6)) ||
      (LocaleNCompare((char *) VAR_14,""SFW"",3) != 0))
    {
      VAR_14=(unsigned char *) RelinquishMagickMemory(VAR_14);
      ThrowReaderException(VAR_21,""ImproperImageHeader"");
    }
  (void) CloseBlob(VAR_6);
  /* COMMENT_6 */
                                   
    
  VAR_10=SFWScan(VAR_14,VAR_14+VAR_13-1,(const unsigned char *)
    ""\377\310\377\320"",4);
  if (VAR_10 == (unsigned char *) NULL)
    {
      VAR_14=(unsigned char *) RelinquishMagickMemory(VAR_14);
      ThrowReaderException(VAR_21,""ImproperImageHeader"");
    }
  TranslateSFWMarker(VAR_10);  /* COMMENT_9 */
  TranslateSFWMarker(VAR_10+2);
  (void) CopyMagickMemory(VAR_10+6,""JFIF\0\001\0"",7);  /* COMMENT_10 */
  /* COMMENT_11 */
                                
    
  VAR_15=VAR_10+2;
  VAR_15+=(((unsigned int) VAR_15[2]) << 8)+VAR_15[3]+2;
  for ( ; ; )
  {
    if ((VAR_15+4) > (VAR_14+VAR_13-1))
      {
        VAR_14=(unsigned char *) RelinquishMagickMemory(VAR_14);
        ThrowReaderException(VAR_20,""MemoryAllocationFailed"");
      }
    TranslateSFWMarker(VAR_15);
    if (VAR_15[1] == 0xda)
      break;
    VAR_15+=(((unsigned int) VAR_15[2]) << 8)+VAR_15[3]+2;
  }
  VAR_15--;
  VAR_11=SFWScan(VAR_15,VAR_14+VAR_13-1,(const unsigned char *) ""\377\311"",2);
  if (VAR_11 == (unsigned char *) NULL)
    {
      VAR_14=(unsigned char *) RelinquishMagickMemory(VAR_14);
      ThrowReaderException(VAR_21,""ImproperImageHeader"");
    }
  TranslateSFWMarker(VAR_11++);  /* COMMENT_14 */
  /* COMMENT_15 */
                    
    
  VAR_7=CloneImageInfo(VAR_0);
  SetImageInfoBlob(VAR_7,(void *) NULL,0);
  VAR_3=(FILE *) NULL;
  VAR_8=AcquireUniqueFileResource(VAR_7->filename);
  if (VAR_8 != -1)
    VAR_3=fopen_utf8(VAR_7->filename,""wb"");
  if ((VAR_8 == -1) || (VAR_3 == (FILE *) NULL))
    {
      VAR_14=(unsigned char *) RelinquishMagickMemory(VAR_14);
      VAR_7=DestroyImageInfo(VAR_7);
      (void) CopyMagickString(VAR_6->filename,VAR_7->filename,
        VAR_22);
      ThrowFileException(VAR_1,VAR_23,""UnableToCreateTemporaryFile"",
        VAR_6->filename);
      VAR_6=DestroyImageList(VAR_6);
      return((Image *) NULL);
    }
  VAR_12=fwrite(VAR_10,(size_t) (VAR_15-VAR_10+1),1,VAR_3);
  (void) VAR_12;
  VAR_12=fwrite(VAR_2,1,sizeof(HuffmanTable)/sizeof(*HuffmanTable),VAR_3);
  VAR_12=fwrite(VAR_15+1,(size_t) (VAR_11-VAR_15),1,VAR_3);
  VAR_9=ferror(VAR_3) != 0 ? VAR_17 : VAR_24;
  (void) fclose(VAR_3);
  (void) close(VAR_8);
  VAR_14=(unsigned char *) RelinquishMagickMemory(VAR_14);
  if (VAR_9 == VAR_17)
    {
      char
        *VAR_25;

      (void) remove_utf8(VAR_7->filename);
      VAR_7=DestroyImageInfo(VAR_7);
      VAR_25=GetExceptionMessage(VAR_26);
      (void) ThrowMagickException(VAR_1,GetMagickModule(),VAR_23,
        ""UnableToWriteFile"",""`%s': %s"",VAR_6->filename,VAR_25);
      VAR_25=DestroyString(VAR_25);
      VAR_6=DestroyImageList(VAR_6);
      return((Image *) NULL);
    }
  /* COMMENT_18 */
                    
    
  VAR_5=ReadImage(VAR_7,VAR_1);
  (void) RelinquishUniqueFileResource(VAR_7->filename);
  VAR_7=DestroyImageInfo(VAR_7);
  if (VAR_5 == (Image *) NULL)
    {
      VAR_6=DestroyImageList(VAR_6);
      return(VAR_5);
    }
  (void) CopyMagickString(VAR_5->filename,VAR_6->filename,VAR_22);
  (void) CopyMagickString(VAR_5->magick,VAR_6->magick,VAR_22);
  VAR_6=DestroyImageList(VAR_6);
  VAR_6=VAR_5;
  /* COMMENT_21 */
                              
    
  VAR_4=FlipImage(VAR_6,VAR_1);
  if (VAR_4 != (Image *) NULL)
    {
      DuplicateBlob(VAR_4,VAR_6);
      VAR_6=DestroyImage(VAR_6);
      VAR_6=VAR_4;
    }
  return(GetFirstImageInList(VAR_6));
}",ImageMagick/5b1b7895bb5c75596942e5c642ea44b0dd13ddec/sfw.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -104,7 +104,10 @@
   count=ReadBlob(image,(size_t) GetBlobSize(image),buffer);
   if ((count != (ssize_t) GetBlobSize(image)) ||
       (LocaleNCompare((char *) buffer,""SFW"",3) != 0))
-    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
+    {
+      buffer=(unsigned char *) RelinquishMagickMemory(buffer);
+      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
+    }
   (void) CloseBlob(image);
   /*
     Find the start of the JFIF data","{'deleted_lines': ['    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");'], 'added_lines': ['    {', '      buffer=(unsigned char *) RelinquishMagickMemory(buffer);', '      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");', '    }']}",True,"In ImageMagick 7.0.5-5, the ReadSFWImage function in sfw.c allows attackers to cause a denial of service (memory leak) via a crafted file.",6.5,MEDIUM,1,test,2017-04-26T19:26:21Z,1
CVE-2017-8294,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"Fix issue #646 (#648)

* Fix issue #646 and some edge cases with wide regexps using \b and \B

* Rename function IS_WORD_CHAR to _yr_re_is_word_char",83d799804648c2a0895d40a19835d9b757c6fa4e,https://github.com/VirusTotal/yara/commit/83d799804648c2a0895d40a19835d9b757c6fa4e,libyara/re.c,yr_re_exec,"int yr_re_exec(
uint8_t* re_code,
uint8_t* input_data,
size_t input_size,
int flags,
RE_MATCH_CALLBACK_FUNC callback,
void* callback_args)
{
uint8_t* ip;
uint8_t* input;
uint8_t mask;
uint8_t value;
RE_FIBER_LIST fibers;
RE_THREAD_STORAGE* storage;
RE_FIBER* fiber;
RE_FIBER* next_fiber;
int error;
int bytes_matched;
int max_bytes_matched;
int match;
int character_size;
int input_incr;
int kill;
int action;
int result = -1;
#define ACTION_NONE       0
#define ACTION_CONTINUE   1
#define ACTION_KILL       2
#define ACTION_KILL_TAIL  3
#define prolog if (bytes_matched >= max_bytes_matched) \
{ \
action = ACTION_KILL; \
break; \
}
#define fail_if_error(e) switch (e) { \
case ERROR_INSUFFICIENT_MEMORY: \
return -2; \
case ERROR_TOO_MANY_RE_FIBERS: \
return -4; \
}
if (_yr_re_alloc_storage(&storage) != ERROR_SUCCESS)
return -2;
if (flags & RE_FLAGS_WIDE)
character_size = 2;
else
character_size = 1;
input = input_data;
input_incr = character_size;
if (flags & RE_FLAGS_BACKWARDS)
{
input -= character_size;
input_incr = -input_incr;
}
max_bytes_matched = (int) yr_min(input_size, RE_SCAN_LIMIT);
max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size;
bytes_matched = 0;
error = _yr_re_fiber_create(&storage->fiber_pool, &fiber);
fail_if_error(error);
fiber->ip = re_code;
fibers.head = fiber;
fibers.tail = fiber;
error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);
fail_if_error(error);
while (fibers.head != NULL)
{
fiber = fibers.head;
while(fiber != NULL)
{
ip = fiber->ip;
action = ACTION_NONE;
switch(*ip)
{
case RE_OPCODE_ANY:
prolog;
match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);
action = match ? ACTION_NONE : ACTION_KILL;
fiber->ip += 1;
break;
case RE_OPCODE_REPEAT_ANY_GREEDY:
case RE_OPCODE_REPEAT_ANY_UNGREEDY:
prolog;
match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);
action = match ? ACTION_NONE : ACTION_KILL;
break;
case RE_OPCODE_LITERAL:
prolog;
if (flags & RE_FLAGS_NO_CASE)
match = yr_lowercase[*input] == yr_lowercase[*(ip + 1)];
else
match = (*input == *(ip + 1));
action = match ? ACTION_NONE : ACTION_KILL;
fiber->ip += 2;
break;
case RE_OPCODE_MASKED_LITERAL:
prolog;
value = *(int16_t*)(ip + 1) & 0xFF;
mask = *(int16_t*)(ip + 1) >> 8;
match = ((*input & mask) == value);
action = match ? ACTION_NONE : ACTION_KILL;
fiber->ip += 3;
break;
case RE_OPCODE_CLASS:
prolog;
match = CHAR_IN_CLASS(*input, ip + 1);
if (!match && (flags & RE_FLAGS_NO_CASE))
match = CHAR_IN_CLASS(yr_altercase[*input], ip + 1);
action = match ? ACTION_NONE : ACTION_KILL;
fiber->ip += 33;
break;
case RE_OPCODE_WORD_CHAR:
prolog;
match = IS_WORD_CHAR(*input);
action = match ? ACTION_NONE : ACTION_KILL;
fiber->ip += 1;
break;
case RE_OPCODE_NON_WORD_CHAR:
prolog;
match = !IS_WORD_CHAR(*input);
action = match ? ACTION_NONE : ACTION_KILL;
fiber->ip += 1;
break;
case RE_OPCODE_SPACE:
case RE_OPCODE_NON_SPACE:
prolog;
switch(*input)
{
case ' ':
case '\t':
case '\r':
case '\n':
case '\v':
case '\f':
match = TRUE;
break;
default:
match = FALSE;
}
if (*ip == RE_OPCODE_NON_SPACE)
match = !match;
action = match ? ACTION_NONE : ACTION_KILL;
fiber->ip += 1;
break;
case RE_OPCODE_DIGIT:
prolog;
match = isdigit(*input);
action = match ? ACTION_NONE : ACTION_KILL;
fiber->ip += 1;
break;
case RE_OPCODE_NON_DIGIT:
prolog;
match = !isdigit(*input);
action = match ? ACTION_NONE : ACTION_KILL;
fiber->ip += 1;
break;
case RE_OPCODE_WORD_BOUNDARY:
case RE_OPCODE_NON_WORD_BOUNDARY:
if (bytes_matched == 0 &&
!(flags & RE_FLAGS_NOT_AT_START) &&
!(flags & RE_FLAGS_BACKWARDS))
match = TRUE;
else if (bytes_matched >= max_bytes_matched)
match = TRUE;
else if (IS_WORD_CHAR(*(input - input_incr)) != IS_WORD_CHAR(*input))
match = TRUE;
else
match = FALSE;
if (*ip == RE_OPCODE_NON_WORD_BOUNDARY)
match = !match;
action = match ? ACTION_CONTINUE : ACTION_KILL;
fiber->ip += 1;
break;
case RE_OPCODE_MATCH_AT_START:
if (flags & RE_FLAGS_BACKWARDS)
kill = input_size > (size_t) bytes_matched;
else
kill = (flags & RE_FLAGS_NOT_AT_START) || (bytes_matched != 0);
action = kill ? ACTION_KILL : ACTION_CONTINUE;
fiber->ip += 1;
break;
case RE_OPCODE_MATCH_AT_END:
kill = flags & RE_FLAGS_BACKWARDS ||
input_size > (size_t) bytes_matched;
action = kill ? ACTION_KILL : ACTION_CONTINUE;
fiber->ip += 1;
break;
case RE_OPCODE_MATCH:
result = bytes_matched;
if (flags & RE_FLAGS_EXHAUSTIVE)
{
if (callback != NULL)
{
int cb_result;
if (flags & RE_FLAGS_BACKWARDS)
cb_result = callback(
input + character_size,
bytes_matched,
flags,
callback_args);
else
cb_result = callback(
input_data,
bytes_matched,
flags,
callback_args);
switch(cb_result)
{
case ERROR_INSUFFICIENT_MEMORY:
return -2;
case ERROR_TOO_MANY_MATCHES:
return -3;
default:
if (cb_result != ERROR_SUCCESS)
return -4;
}
}
action = ACTION_KILL;
}
else
{
action = ACTION_KILL_TAIL;
}
break;
default:
assert(FALSE);
}
switch(action)
{
case ACTION_KILL:
fiber = _yr_re_fiber_kill(&fibers, &storage->fiber_pool, fiber);
break;
case ACTION_KILL_TAIL:
_yr_re_fiber_kill_tail(&fibers, &storage->fiber_pool, fiber);
fiber = NULL;
break;
case ACTION_CONTINUE:
error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);
fail_if_error(error);
break;
default:
next_fiber = fiber->next;
error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);
fail_if_error(error);
fiber = next_fiber;
}
}
if (flags & RE_FLAGS_WIDE &&
bytes_matched < max_bytes_matched &&
*(input + 1) != 0)
{
_yr_re_fiber_kill_all(&fibers, &storage->fiber_pool);
}
input += input_incr;
bytes_matched += character_size;
if (flags & RE_FLAGS_SCAN && bytes_matched < max_bytes_matched)
{
error = _yr_re_fiber_create(&storage->fiber_pool, &fiber);
fail_if_error(error);
fiber->ip = re_code;
_yr_re_fiber_append(&fibers, fiber);
error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);
fail_if_error(error);
}
}
return result;
}","int yr_re_exec(
uint8_t* VAR_0,
uint8_t* VAR_1,
size_t VAR_2,
int VAR_3,
RE_MATCH_CALLBACK_FUNC VAR_4,
void* VAR_5)
{
uint8_t* VAR_6;
uint8_t* VAR_7;
uint8_t VAR_8;
uint8_t VAR_9;
RE_FIBER_LIST VAR_10;
RE_THREAD_STORAGE* VAR_11;
RE_FIBER* VAR_12;
RE_FIBER* VAR_13;
int VAR_14;
int VAR_15;
int VAR_16;
int VAR_17;
int VAR_18;
int VAR_19;
int VAR_20;
int VAR_21;
int VAR_22 = -1;
#define VAR_23       0
#define VAR_24   1
#define VAR_25       2
#define VAR_26  3
#define VAR_27 if (bytes_matched >= max_bytes_matched) \
{ \
action = ACTION_KILL; \
break; \
}
#define fail_if_error(VAR_28) switch (e) { \
case ERROR_INSUFFICIENT_MEMORY: \
return -2; \
case ERROR_TOO_MANY_RE_FIBERS: \
return -4; \
}
if (_yr_re_alloc_storage(&VAR_11) != VAR_29)
return -2;
if (VAR_3 & VAR_30)
VAR_18 = 2;
else
VAR_18 = 1;
VAR_7 = VAR_1;
VAR_19 = VAR_18;
if (VAR_3 & VAR_31)
{
VAR_7 -= VAR_18;
VAR_19 = -VAR_19;
}
VAR_16 = (int) yr_min(VAR_2, VAR_32);
VAR_16 = VAR_16 - VAR_16 % VAR_18;
VAR_15 = 0;
VAR_14 = _yr_re_fiber_create(&VAR_11->fiber_pool, &VAR_12);
fail_if_error(VAR_14);
VAR_12->ip = VAR_0;
VAR_10.head = VAR_12;
VAR_10.tail = VAR_12;
VAR_14 = _yr_re_fiber_sync(&VAR_10, &VAR_11->fiber_pool, VAR_12);
fail_if_error(VAR_14);
while (VAR_10.head != NULL)
{
VAR_12 = VAR_10.head;
while(VAR_12 != NULL)
{
VAR_6 = VAR_12->ip;
VAR_21 = VAR_23;
switch(*VAR_6)
{
case VAR_33:
VAR_27;
VAR_17 = (VAR_3 & VAR_34) || (*VAR_7 != 0x0A);
VAR_21 = VAR_17 ? VAR_23 : VAR_25;
VAR_12->ip += 1;
break;
case VAR_35:
case VAR_36:
VAR_27;
VAR_17 = (VAR_3 & VAR_34) || (*VAR_7 != 0x0A);
VAR_21 = VAR_17 ? VAR_23 : VAR_25;
break;
case VAR_37:
VAR_27;
if (VAR_3 & VAR_38)
VAR_17 = VAR_39[*VAR_7] == VAR_39[*(VAR_6 + 1)];
else
VAR_17 = (*VAR_7 == *(VAR_6 + 1));
VAR_21 = VAR_17 ? VAR_23 : VAR_25;
VAR_12->ip += 2;
break;
case VAR_40:
VAR_27;
VAR_9 = *(int16_t*)(VAR_6 + 1) & 0xFF;
VAR_8 = *(int16_t*)(VAR_6 + 1) >> 8;
VAR_17 = ((*VAR_7 & VAR_8) == VAR_9);
VAR_21 = VAR_17 ? VAR_23 : VAR_25;
VAR_12->ip += 3;
break;
case VAR_41:
VAR_27;
VAR_17 = CHAR_IN_CLASS(*VAR_7, VAR_6 + 1);
if (!VAR_17 && (VAR_3 & VAR_38))
VAR_17 = CHAR_IN_CLASS(VAR_42[*VAR_7], VAR_6 + 1);
VAR_21 = VAR_17 ? VAR_23 : VAR_25;
VAR_12->ip += 33;
break;
case VAR_43:
VAR_27;
VAR_17 = IS_WORD_CHAR(*VAR_7);
VAR_21 = VAR_17 ? VAR_23 : VAR_25;
VAR_12->ip += 1;
break;
case VAR_44:
VAR_27;
VAR_17 = !IS_WORD_CHAR(*VAR_7);
VAR_21 = VAR_17 ? VAR_23 : VAR_25;
VAR_12->ip += 1;
break;
case VAR_45:
case VAR_46:
VAR_27;
switch(*VAR_7)
{
case ' ':
case '\t':
case '\r':
case '\n':
case '\v':
case '\f':
VAR_17 = TRUE;
break;
default:
VAR_17 = FALSE;
}
if (*VAR_6 == VAR_46)
VAR_17 = !VAR_17;
VAR_21 = VAR_17 ? VAR_23 : VAR_25;
VAR_12->ip += 1;
break;
case VAR_47:
VAR_27;
VAR_17 = isdigit(*VAR_7);
VAR_21 = VAR_17 ? VAR_23 : VAR_25;
VAR_12->ip += 1;
break;
case VAR_48:
VAR_27;
VAR_17 = !isdigit(*VAR_7);
VAR_21 = VAR_17 ? VAR_23 : VAR_25;
VAR_12->ip += 1;
break;
case VAR_49:
case VAR_50:
if (VAR_15 == 0 &&
!(VAR_3 & VAR_51) &&
!(VAR_3 & VAR_31))
VAR_17 = TRUE;
else if (VAR_15 >= VAR_16)
VAR_17 = TRUE;
else if (IS_WORD_CHAR(*(VAR_7 - VAR_19)) != IS_WORD_CHAR(*VAR_7))
VAR_17 = TRUE;
else
VAR_17 = FALSE;
if (*VAR_6 == VAR_50)
VAR_17 = !VAR_17;
VAR_21 = VAR_17 ? VAR_24 : VAR_25;
VAR_12->ip += 1;
break;
case VAR_52:
if (VAR_3 & VAR_31)
VAR_20 = VAR_2 > (size_t) VAR_15;
else
VAR_20 = (VAR_3 & VAR_51) || (VAR_15 != 0);
VAR_21 = VAR_20 ? VAR_25 : VAR_24;
VAR_12->ip += 1;
break;
case VAR_53:
VAR_20 = VAR_3 & VAR_31 ||
VAR_2 > (size_t) VAR_15;
VAR_21 = VAR_20 ? VAR_25 : VAR_24;
VAR_12->ip += 1;
break;
case VAR_54:
VAR_22 = VAR_15;
if (VAR_3 & VAR_55)
{
if (VAR_4 != NULL)
{
int VAR_56;
if (VAR_3 & VAR_31)
VAR_56 = VAR_4(
VAR_7 + VAR_18,
VAR_15,
VAR_3,
VAR_5);
else
VAR_56 = VAR_4(
VAR_1,
VAR_15,
VAR_3,
VAR_5);
switch(VAR_56)
{
case VAR_57:
return -2;
case VAR_58:
return -3;
default:
if (VAR_56 != VAR_29)
return -4;
}
}
VAR_21 = VAR_25;
}
else
{
VAR_21 = VAR_26;
}
break;
default:
assert(FALSE);
}
switch(VAR_21)
{
case VAR_25:
VAR_12 = _yr_re_fiber_kill(&VAR_10, &VAR_11->fiber_pool, VAR_12);
break;
case VAR_26:
_yr_re_fiber_kill_tail(&VAR_10, &VAR_11->fiber_pool, VAR_12);
VAR_12 = NULL;
break;
case VAR_24:
VAR_14 = _yr_re_fiber_sync(&VAR_10, &VAR_11->fiber_pool, VAR_12);
fail_if_error(VAR_14);
break;
default:
VAR_13 = VAR_12->next;
VAR_14 = _yr_re_fiber_sync(&VAR_10, &VAR_11->fiber_pool, VAR_12);
fail_if_error(VAR_14);
VAR_12 = VAR_13;
}
}
if (VAR_3 & VAR_30 &&
VAR_15 < VAR_16 &&
*(VAR_7 + 1) != 0)
{
_yr_re_fiber_kill_all(&VAR_10, &VAR_11->fiber_pool);
}
VAR_7 += VAR_19;
VAR_15 += VAR_18;
if (VAR_3 & VAR_59 && VAR_15 < VAR_16)
{
VAR_14 = _yr_re_fiber_create(&VAR_11->fiber_pool, &VAR_12);
fail_if_error(VAR_14);
VAR_12->ip = VAR_0;
_yr_re_fiber_append(&VAR_10, VAR_12);
VAR_14 = _yr_re_fiber_sync(&VAR_10, &VAR_11->fiber_pool, VAR_12);
fail_if_error(VAR_14);
}
}
return VAR_22;
}",VirusTotal/yara/83d799804648c2a0895d40a19835d9b757c6fa4e/re.c/vul/before/2.json,"int yr_re_exec(
    uint8_t* re_code,
    uint8_t* input_data,
    size_t input_forwards_size,
    size_t input_backwards_size,
    int flags,
    RE_MATCH_CALLBACK_FUNC callback,
    void* callback_args)
{
  uint8_t* ip;
  uint8_t* input;
  uint8_t mask;
  uint8_t value;

  RE_FIBER_LIST fibers;
  RE_THREAD_STORAGE* storage;
  RE_FIBER* fiber;
  RE_FIBER* next_fiber;

  int error;
  int bytes_matched;
  int max_bytes_matched;
  int match;
  int character_size;
  int input_incr;
  int kill;
  int action;
  int result = -1;

  #define ACTION_NONE       0
  #define ACTION_CONTINUE   1
  #define ACTION_KILL       2
  #define ACTION_KILL_TAIL  3

  #define prolog { \
      if ((bytes_matched >= max_bytes_matched) || \
          (character_size == 2 && *(input + 1) != 0)) \
      { \
        action = ACTION_KILL; \
        break; \
      } \
    }

  #define fail_if_error(e) { \
      switch (e) { \
        case ERROR_INSUFFICIENT_MEMORY: \
          return -2; \
        case ERROR_TOO_MANY_RE_FIBERS: \
          return -4; \
      } \
    }

  if (_yr_re_alloc_storage(&storage) != ERROR_SUCCESS)
    return -2;

  if (flags & RE_FLAGS_WIDE)
    character_size = 2;
  else
    character_size = 1;

  input = input_data;
  input_incr = character_size;

  if (flags & RE_FLAGS_BACKWARDS)
  {
    max_bytes_matched = (int) yr_min(input_backwards_size, RE_SCAN_LIMIT);
    input -= character_size;
    input_incr = -input_incr;
  }
  else
  {
    max_bytes_matched = (int) yr_min(input_forwards_size, RE_SCAN_LIMIT);
  }

  // Round down max_bytes_matched to a multiple of character_size, this way if
  // character_size is 2 and max_bytes_matched is odd we are ignoring the
  // extra byte which can't match anyways.

  max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size;
  bytes_matched = 0;

  error = _yr_re_fiber_create(&storage->fiber_pool, &fiber);
  fail_if_error(error);

  fiber->ip = re_code;
  fibers.head = fiber;
  fibers.tail = fiber;

  error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);
  fail_if_error(error);

  while (fibers.head != NULL)
  {
    fiber = fibers.head;

    while(fiber != NULL)
    {
      ip = fiber->ip;
      action = ACTION_NONE;

      switch(*ip)
      {
        case RE_OPCODE_ANY:
          prolog;
          match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);
          action = match ? ACTION_NONE : ACTION_KILL;
          fiber->ip += 1;
          break;

        case RE_OPCODE_REPEAT_ANY_GREEDY:
        case RE_OPCODE_REPEAT_ANY_UNGREEDY:
          prolog;
          match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);
          action = match ? ACTION_NONE : ACTION_KILL;

          // The instruction pointer is not incremented here. The current fiber
          // spins in this instruction until reaching the required number of
          // repetitions. The code controlling the number of repetitions is in
          // _yr_re_fiber_sync.

          break;

        case RE_OPCODE_LITERAL:
          prolog;
          if (flags & RE_FLAGS_NO_CASE)
            match = yr_lowercase[*input] == yr_lowercase[*(ip + 1)];
          else
            match = (*input == *(ip + 1));
          action = match ? ACTION_NONE : ACTION_KILL;
          fiber->ip += 2;
          break;

        case RE_OPCODE_MASKED_LITERAL:
          prolog;
          value = *(int16_t*)(ip + 1) & 0xFF;
          mask = *(int16_t*)(ip + 1) >> 8;

          // We don't need to take into account the case-insensitive
          // case because this opcode is only used with hex strings,
          // which can't be case-insensitive.

          match = ((*input & mask) == value);
          action = match ? ACTION_NONE : ACTION_KILL;
          fiber->ip += 3;
          break;

        case RE_OPCODE_CLASS:
          prolog;
          match = CHAR_IN_CLASS(*input, ip + 1);
          if (!match && (flags & RE_FLAGS_NO_CASE))
            match = CHAR_IN_CLASS(yr_altercase[*input], ip + 1);
          action = match ? ACTION_NONE : ACTION_KILL;
          fiber->ip += 33;
          break;

        case RE_OPCODE_WORD_CHAR:
          prolog;
          match = _yr_re_is_word_char(input, character_size);
          action = match ? ACTION_NONE : ACTION_KILL;
          fiber->ip += 1;
          break;

        case RE_OPCODE_NON_WORD_CHAR:
          prolog;
          match = !_yr_re_is_word_char(input, character_size);
          action = match ? ACTION_NONE : ACTION_KILL;
          fiber->ip += 1;
          break;

        case RE_OPCODE_SPACE:
        case RE_OPCODE_NON_SPACE:

          prolog;

          switch(*input)
          {
            case ' ':
            case '\t':
            case '\r':
            case '\n':
            case '\v':
            case '\f':
              match = TRUE;
              break;
            default:
              match = FALSE;
          }

          if (*ip == RE_OPCODE_NON_SPACE)
            match = !match;

          action = match ? ACTION_NONE : ACTION_KILL;
          fiber->ip += 1;
          break;

        case RE_OPCODE_DIGIT:
          prolog;
          match = isdigit(*input);
          action = match ? ACTION_NONE : ACTION_KILL;
          fiber->ip += 1;
          break;

        case RE_OPCODE_NON_DIGIT:
          prolog;
          match = !isdigit(*input);
          action = match ? ACTION_NONE : ACTION_KILL;
          fiber->ip += 1;
          break;

        case RE_OPCODE_WORD_BOUNDARY:
        case RE_OPCODE_NON_WORD_BOUNDARY:

          if (bytes_matched == 0 && input_backwards_size < character_size)
          {
            match = TRUE;
          }
          else if (bytes_matched >= max_bytes_matched)
          {
            match = TRUE;
          }
          else
          {
            assert(input <  input_data + input_forwards_size);
            assert(input >= input_data - input_backwards_size);

            assert(input - input_incr <  input_data + input_forwards_size);
            assert(input - input_incr >= input_data - input_backwards_size);

            match = _yr_re_is_word_char(input, character_size) != \
                    _yr_re_is_word_char(input - input_incr, character_size);
          }

          if (*ip == RE_OPCODE_NON_WORD_BOUNDARY)
            match = !match;

          action = match ? ACTION_CONTINUE : ACTION_KILL;
          fiber->ip += 1;
          break;

        case RE_OPCODE_MATCH_AT_START:
          if (flags & RE_FLAGS_BACKWARDS)
            kill = input_backwards_size > (size_t) bytes_matched;
          else
            kill = input_backwards_size > 0 || (bytes_matched != 0);
          action = kill ? ACTION_KILL : ACTION_CONTINUE;
          fiber->ip += 1;
          break;

        case RE_OPCODE_MATCH_AT_END:
          kill = flags & RE_FLAGS_BACKWARDS ||
                 input_forwards_size > (size_t) bytes_matched;
          action = kill ? ACTION_KILL : ACTION_CONTINUE;
          fiber->ip += 1;
          break;

        case RE_OPCODE_MATCH:

          result = bytes_matched;

          if (flags & RE_FLAGS_EXHAUSTIVE)
          {
            if (callback != NULL)
            {
              int cb_result;

              if (flags & RE_FLAGS_BACKWARDS)
                cb_result = callback(
                    input + character_size,
                    bytes_matched,
                    flags,
                    callback_args);
              else
                cb_result = callback(
                    input_data,
                    bytes_matched,
                    flags,
                    callback_args);

              switch(cb_result)
              {
                case ERROR_INSUFFICIENT_MEMORY:
                  return -2;
                case ERROR_TOO_MANY_MATCHES:
                  return -3;
                default:
                  if (cb_result != ERROR_SUCCESS)
                    return -4;
              }
            }

            action = ACTION_KILL;
          }
          else
          {
            action = ACTION_KILL_TAIL;
          }

          break;

        default:
          assert(FALSE);
      }

      switch(action)
      {
        case ACTION_KILL:
          fiber = _yr_re_fiber_kill(&fibers, &storage->fiber_pool, fiber);
          break;

        case ACTION_KILL_TAIL:
          _yr_re_fiber_kill_tail(&fibers, &storage->fiber_pool, fiber);
          fiber = NULL;
          break;

        case ACTION_CONTINUE:
          error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);
          fail_if_error(error);
          break;

        default:
          next_fiber = fiber->next;
          error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);
          fail_if_error(error);
          fiber = next_fiber;
      }
    }

    input += input_incr;
    bytes_matched += character_size;

    if (flags & RE_FLAGS_SCAN && bytes_matched < max_bytes_matched)
    {
      error = _yr_re_fiber_create(&storage->fiber_pool, &fiber);
      fail_if_error(error);

      fiber->ip = re_code;
      _yr_re_fiber_append(&fibers, fiber);

      error = _yr_re_fiber_sync(&fibers, &storage->fiber_pool, fiber);
      fail_if_error(error);
    }
  }

  return result;
}","int yr_re_exec(
    uint8_t* VAR_0,
    uint8_t* VAR_1,
    size_t VAR_2,
    size_t VAR_3,
    int VAR_4,
    RE_MATCH_CALLBACK_FUNC VAR_5,
    void* VAR_6)
{
  uint8_t* VAR_7;
  uint8_t* VAR_8;
  uint8_t VAR_9;
  uint8_t VAR_10;

  RE_FIBER_LIST VAR_11;
  RE_THREAD_STORAGE* VAR_12;
  RE_FIBER* VAR_13;
  RE_FIBER* VAR_14;

  int VAR_15;
  int VAR_16;
  int VAR_17;
  int VAR_18;
  int VAR_19;
  int VAR_20;
  int VAR_21;
  int VAR_22;
  int VAR_23 = -1;

  #define VAR_24       0
  #define VAR_25   1
  #define VAR_26       2
  #define VAR_27  3

  #define VAR_28 { \
      if ((bytes_matched >= max_bytes_matched) || \
          (character_size == 2 && *(input + 1) != 0)) \
      { \
        action = ACTION_KILL; \
        break; \
      } \
    }

  #define fail_if_error(VAR_29) { \
      switch (e) { \
        case ERROR_INSUFFICIENT_MEMORY: \
          return -2; \
        case ERROR_TOO_MANY_RE_FIBERS: \
          return -4; \
      } \
    }

  if (_yr_re_alloc_storage(&VAR_12) != VAR_30)
    return -2;

  if (VAR_4 & VAR_31)
    VAR_19 = 2;
  else
    VAR_19 = 1;

  VAR_8 = VAR_1;
  VAR_20 = VAR_19;

  if (VAR_4 & VAR_32)
  {
    VAR_17 = (int) yr_min(VAR_3, VAR_33);
    VAR_8 -= VAR_19;
    VAR_20 = -VAR_20;
  }
  else
  {
    VAR_17 = (int) yr_min(VAR_2, VAR_33);
  }

  /* COMMENT_0 */
  /* COMMENT_1 */
  /* COMMENT_2 */

  VAR_17 = VAR_17 - VAR_17 % VAR_19;
  VAR_16 = 0;

  VAR_15 = _yr_re_fiber_create(&VAR_12->fiber_pool, &VAR_13);
  fail_if_error(VAR_15);

  VAR_13->ip = VAR_0;
  VAR_11.head = VAR_13;
  VAR_11.tail = VAR_13;

  VAR_15 = _yr_re_fiber_sync(&VAR_11, &VAR_12->fiber_pool, VAR_13);
  fail_if_error(VAR_15);

  while (VAR_11.head != NULL)
  {
    VAR_13 = VAR_11.head;

    while(VAR_13 != NULL)
    {
      VAR_7 = VAR_13->ip;
      VAR_22 = VAR_24;

      switch(*VAR_7)
      {
        case VAR_34:
          VAR_28;
          VAR_18 = (VAR_4 & VAR_35) || (*VAR_8 != 0x0A);
          VAR_22 = VAR_18 ? VAR_24 : VAR_26;
          VAR_13->ip += 1;
          break;

        case VAR_36:
        case VAR_37:
          VAR_28;
          VAR_18 = (VAR_4 & VAR_35) || (*VAR_8 != 0x0A);
          VAR_22 = VAR_18 ? VAR_24 : VAR_26;

          /* COMMENT_3 */
          /* COMMENT_4 */
          /* COMMENT_5 */
          /* COMMENT_6 */

          break;

        case VAR_38:
          VAR_28;
          if (VAR_4 & VAR_39)
            VAR_18 = VAR_40[*VAR_8] == VAR_40[*(VAR_7 + 1)];
          else
            VAR_18 = (*VAR_8 == *(VAR_7 + 1));
          VAR_22 = VAR_18 ? VAR_24 : VAR_26;
          VAR_13->ip += 2;
          break;

        case VAR_41:
          VAR_28;
          VAR_10 = *(int16_t*)(VAR_7 + 1) & 0xFF;
          VAR_9 = *(int16_t*)(VAR_7 + 1) >> 8;

          /* COMMENT_7 */
          /* COMMENT_8 */
          /* COMMENT_9 */

          VAR_18 = ((*VAR_8 & VAR_9) == VAR_10);
          VAR_22 = VAR_18 ? VAR_24 : VAR_26;
          VAR_13->ip += 3;
          break;

        case VAR_42:
          VAR_28;
          VAR_18 = CHAR_IN_CLASS(*VAR_8, VAR_7 + 1);
          if (!VAR_18 && (VAR_4 & VAR_39))
            VAR_18 = CHAR_IN_CLASS(VAR_43[*VAR_8], VAR_7 + 1);
          VAR_22 = VAR_18 ? VAR_24 : VAR_26;
          VAR_13->ip += 33;
          break;

        case VAR_44:
          VAR_28;
          VAR_18 = _yr_re_is_word_char(VAR_8, VAR_19);
          VAR_22 = VAR_18 ? VAR_24 : VAR_26;
          VAR_13->ip += 1;
          break;

        case VAR_45:
          VAR_28;
          VAR_18 = !_yr_re_is_word_char(VAR_8, VAR_19);
          VAR_22 = VAR_18 ? VAR_24 : VAR_26;
          VAR_13->ip += 1;
          break;

        case VAR_46:
        case VAR_47:

          VAR_28;

          switch(*VAR_8)
          {
            case ' ':
            case '\t':
            case '\r':
            case '\n':
            case '\v':
            case '\f':
              VAR_18 = TRUE;
              break;
            default:
              VAR_18 = FALSE;
          }

          if (*VAR_7 == VAR_47)
            VAR_18 = !VAR_18;

          VAR_22 = VAR_18 ? VAR_24 : VAR_26;
          VAR_13->ip += 1;
          break;

        case VAR_48:
          VAR_28;
          VAR_18 = isdigit(*VAR_8);
          VAR_22 = VAR_18 ? VAR_24 : VAR_26;
          VAR_13->ip += 1;
          break;

        case VAR_49:
          VAR_28;
          VAR_18 = !isdigit(*VAR_8);
          VAR_22 = VAR_18 ? VAR_24 : VAR_26;
          VAR_13->ip += 1;
          break;

        case VAR_50:
        case VAR_51:

          if (VAR_16 == 0 && VAR_3 < VAR_19)
          {
            VAR_18 = TRUE;
          }
          else if (VAR_16 >= VAR_17)
          {
            VAR_18 = TRUE;
          }
          else
          {
            assert(VAR_8 <  VAR_1 + VAR_2);
            assert(VAR_8 >= VAR_1 - VAR_3);

            assert(VAR_8 - VAR_20 <  VAR_1 + VAR_2);
            assert(VAR_8 - VAR_20 >= VAR_1 - VAR_3);

            VAR_18 = _yr_re_is_word_char(VAR_8, VAR_19) != \
                    _yr_re_is_word_char(VAR_8 - VAR_20, VAR_19);
          }

          if (*VAR_7 == VAR_51)
            VAR_18 = !VAR_18;

          VAR_22 = VAR_18 ? VAR_25 : VAR_26;
          VAR_13->ip += 1;
          break;

        case VAR_52:
          if (VAR_4 & VAR_32)
            VAR_21 = VAR_3 > (size_t) VAR_16;
          else
            VAR_21 = VAR_3 > 0 || (VAR_16 != 0);
          VAR_22 = VAR_21 ? VAR_26 : VAR_25;
          VAR_13->ip += 1;
          break;

        case VAR_53:
          VAR_21 = VAR_4 & VAR_32 ||
                 VAR_2 > (size_t) VAR_16;
          VAR_22 = VAR_21 ? VAR_26 : VAR_25;
          VAR_13->ip += 1;
          break;

        case VAR_54:

          VAR_23 = VAR_16;

          if (VAR_4 & VAR_55)
          {
            if (VAR_5 != NULL)
            {
              int VAR_56;

              if (VAR_4 & VAR_32)
                VAR_56 = VAR_5(
                    VAR_8 + VAR_19,
                    VAR_16,
                    VAR_4,
                    VAR_6);
              else
                VAR_56 = VAR_5(
                    VAR_1,
                    VAR_16,
                    VAR_4,
                    VAR_6);

              switch(VAR_56)
              {
                case VAR_57:
                  return -2;
                case VAR_58:
                  return -3;
                default:
                  if (VAR_56 != VAR_30)
                    return -4;
              }
            }

            VAR_22 = VAR_26;
          }
          else
          {
            VAR_22 = VAR_27;
          }

          break;

        default:
          assert(FALSE);
      }

      switch(VAR_22)
      {
        case VAR_26:
          VAR_13 = _yr_re_fiber_kill(&VAR_11, &VAR_12->fiber_pool, VAR_13);
          break;

        case VAR_27:
          _yr_re_fiber_kill_tail(&VAR_11, &VAR_12->fiber_pool, VAR_13);
          VAR_13 = NULL;
          break;

        case VAR_25:
          VAR_15 = _yr_re_fiber_sync(&VAR_11, &VAR_12->fiber_pool, VAR_13);
          fail_if_error(VAR_15);
          break;

        default:
          VAR_14 = VAR_13->next;
          VAR_15 = _yr_re_fiber_sync(&VAR_11, &VAR_12->fiber_pool, VAR_13);
          fail_if_error(VAR_15);
          VAR_13 = VAR_14;
      }
    }

    VAR_8 += VAR_20;
    VAR_16 += VAR_19;

    if (VAR_4 & VAR_59 && VAR_16 < VAR_17)
    {
      VAR_15 = _yr_re_fiber_create(&VAR_12->fiber_pool, &VAR_13);
      fail_if_error(VAR_15);

      VAR_13->ip = VAR_0;
      _yr_re_fiber_append(&VAR_11, VAR_13);

      VAR_15 = _yr_re_fiber_sync(&VAR_11, &VAR_12->fiber_pool, VAR_13);
      fail_if_error(VAR_15);
    }
  }

  return VAR_23;
}",VirusTotal/yara/83d799804648c2a0895d40a19835d9b757c6fa4e/re.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,7 +1,8 @@
 int yr_re_exec(
     uint8_t* re_code,
     uint8_t* input_data,
-    size_t input_size,
+    size_t input_forwards_size,
+    size_t input_backwards_size,
     int flags,
     RE_MATCH_CALLBACK_FUNC callback,
     void* callback_args)
@@ -31,18 +32,23 @@
   #define ACTION_KILL       2
   #define ACTION_KILL_TAIL  3
 
-  #define prolog if (bytes_matched >= max_bytes_matched) \
+  #define prolog { \
+      if ((bytes_matched >= max_bytes_matched) || \
+          (character_size == 2 && *(input + 1) != 0)) \
       { \
         action = ACTION_KILL; \
         break; \
-      }
-
-  #define fail_if_error(e) switch (e) { \
+      } \
+    }
+
+  #define fail_if_error(e) { \
+      switch (e) { \
         case ERROR_INSUFFICIENT_MEMORY: \
           return -2; \
         case ERROR_TOO_MANY_RE_FIBERS: \
           return -4; \
-      }
+      } \
+    }
 
   if (_yr_re_alloc_storage(&storage) != ERROR_SUCCESS)
     return -2;
@@ -57,14 +63,17 @@
 
   if (flags & RE_FLAGS_BACKWARDS)
   {
+    max_bytes_matched = (int) yr_min(input_backwards_size, RE_SCAN_LIMIT);
     input -= character_size;
     input_incr = -input_incr;
   }
-
-  max_bytes_matched = (int) yr_min(input_size, RE_SCAN_LIMIT);
+  else
+  {
+    max_bytes_matched = (int) yr_min(input_forwards_size, RE_SCAN_LIMIT);
+  }
 
   // Round down max_bytes_matched to a multiple of character_size, this way if
-  // character_size is 2 and input_size is odd we are ignoring the
+  // character_size is 2 and max_bytes_matched is odd we are ignoring the
   // extra byte which can't match anyways.
 
   max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size;
@@ -146,14 +155,14 @@
 
         case RE_OPCODE_WORD_CHAR:
           prolog;
-          match = IS_WORD_CHAR(*input);
+          match = _yr_re_is_word_char(input, character_size);
           action = match ? ACTION_NONE : ACTION_KILL;
           fiber->ip += 1;
           break;
 
         case RE_OPCODE_NON_WORD_CHAR:
           prolog;
-          match = !IS_WORD_CHAR(*input);
+          match = !_yr_re_is_word_char(input, character_size);
           action = match ? ACTION_NONE : ACTION_KILL;
           fiber->ip += 1;
           break;
@@ -201,16 +210,25 @@
         case RE_OPCODE_WORD_BOUNDARY:
         case RE_OPCODE_NON_WORD_BOUNDARY:
 
-          if (bytes_matched == 0 &&
-              !(flags & RE_FLAGS_NOT_AT_START) &&
-              !(flags & RE_FLAGS_BACKWARDS))
+          if (bytes_matched == 0 && input_backwards_size < character_size)
+          {
             match = TRUE;
+          }
           else if (bytes_matched >= max_bytes_matched)
+          {
             match = TRUE;
-          else if (IS_WORD_CHAR(*(input - input_incr)) != IS_WORD_CHAR(*input))
-            match = TRUE;
+          }
           else
-            match = FALSE;
+          {
+            assert(input <  input_data + input_forwards_size);
+            assert(input >= input_data - input_backwards_size);
+
+            assert(input - input_incr <  input_data + input_forwards_size);
+            assert(input - input_incr >= input_data - input_backwards_size);
+
+            match = _yr_re_is_word_char(input, character_size) != \
+                    _yr_re_is_word_char(input - input_incr, character_size);
+          }
 
           if (*ip == RE_OPCODE_NON_WORD_BOUNDARY)
             match = !match;
@@ -221,16 +239,16 @@
 
         case RE_OPCODE_MATCH_AT_START:
           if (flags & RE_FLAGS_BACKWARDS)
-            kill = input_size > (size_t) bytes_matched;
+            kill = input_backwards_size > (size_t) bytes_matched;
           else
-            kill = (flags & RE_FLAGS_NOT_AT_START) || (bytes_matched != 0);
+            kill = input_backwards_size > 0 || (bytes_matched != 0);
           action = kill ? ACTION_KILL : ACTION_CONTINUE;
           fiber->ip += 1;
           break;
 
         case RE_OPCODE_MATCH_AT_END:
           kill = flags & RE_FLAGS_BACKWARDS ||
-                 input_size > (size_t) bytes_matched;
+                 input_forwards_size > (size_t) bytes_matched;
           action = kill ? ACTION_KILL : ACTION_CONTINUE;
           fiber->ip += 1;
           break;
@@ -307,13 +325,6 @@
       }
     }
 
-    if (flags & RE_FLAGS_WIDE &&
-        bytes_matched < max_bytes_matched &&
-        *(input + 1) != 0)
-    {
-      _yr_re_fiber_kill_all(&fibers, &storage->fiber_pool);
-    }
-
     input += input_incr;
     bytes_matched += character_size;
 ","{'deleted_lines': ['    size_t input_size,', '  #define prolog if (bytes_matched >= max_bytes_matched) \\', '      }', '', '  #define fail_if_error(e) switch (e) { \\', '      }', '', '  max_bytes_matched = (int) yr_min(input_size, RE_SCAN_LIMIT);', '  // character_size is 2 and input_size is odd we are ignoring the', '          match = IS_WORD_CHAR(*input);', '          match = !IS_WORD_CHAR(*input);', '          if (bytes_matched == 0 &&', '              !(flags & RE_FLAGS_NOT_AT_START) &&', '              !(flags & RE_FLAGS_BACKWARDS))', '          else if (IS_WORD_CHAR(*(input - input_incr)) != IS_WORD_CHAR(*input))', '            match = TRUE;', '            match = FALSE;', '            kill = input_size > (size_t) bytes_matched;', '            kill = (flags & RE_FLAGS_NOT_AT_START) || (bytes_matched != 0);', '                 input_size > (size_t) bytes_matched;', '    if (flags & RE_FLAGS_WIDE &&', '        bytes_matched < max_bytes_matched &&', '        *(input + 1) != 0)', '    {', '      _yr_re_fiber_kill_all(&fibers, &storage->fiber_pool);', '    }', ''], 'added_lines': ['    size_t input_forwards_size,', '    size_t input_backwards_size,', '  #define prolog { \\', '      if ((bytes_matched >= max_bytes_matched) || \\', '          (character_size == 2 && *(input + 1) != 0)) \\', '      } \\', '    }', '', '  #define fail_if_error(e) { \\', '      switch (e) { \\', '      } \\', '    }', '    max_bytes_matched = (int) yr_min(input_backwards_size, RE_SCAN_LIMIT);', '  else', '  {', '    max_bytes_matched = (int) yr_min(input_forwards_size, RE_SCAN_LIMIT);', '  }', '  // character_size is 2 and max_bytes_matched is odd we are ignoring the', '          match = _yr_re_is_word_char(input, character_size);', '          match = !_yr_re_is_word_char(input, character_size);', '          if (bytes_matched == 0 && input_backwards_size < character_size)', '          {', '          }', '          {', '          }', '          {', '            assert(input <  input_data + input_forwards_size);', '            assert(input >= input_data - input_backwards_size);', '', '            assert(input - input_incr <  input_data + input_forwards_size);', '            assert(input - input_incr >= input_data - input_backwards_size);', '', '            match = _yr_re_is_word_char(input, character_size) != \\', '                    _yr_re_is_word_char(input - input_incr, character_size);', '          }', '            kill = input_backwards_size > (size_t) bytes_matched;', '            kill = input_backwards_size > 0 || (bytes_matched != 0);', '                 input_forwards_size > (size_t) bytes_matched;']}",True,libyara/re.c in the regex component in YARA 3.5.0 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted rule that is mishandled in the yr_re_exec function.,7.5,HIGH,2,test,2017-04-27T09:39:04Z,1
CVE-2017-8294,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"Fix issue #646 (#648)

* Fix issue #646 and some edge cases with wide regexps using \b and \B

* Rename function IS_WORD_CHAR to _yr_re_is_word_char",83d799804648c2a0895d40a19835d9b757c6fa4e,https://github.com/VirusTotal/yara/commit/83d799804648c2a0895d40a19835d9b757c6fa4e,libyara/scan.c,_yr_scan_verify_re_match,"int _yr_scan_verify_re_match(
YR_SCAN_CONTEXT* context,
YR_AC_MATCH* ac_match,
uint8_t* data,
size_t data_size,
size_t data_base,
size_t offset)
{
CALLBACK_ARGS callback_args;
RE_EXEC_FUNC exec;
int forward_matches = -1;
int backward_matches = -1;
int flags = 0;
if (STRING_IS_GREEDY_REGEXP(ac_match->string))
flags |= RE_FLAGS_GREEDY;
if (STRING_IS_NO_CASE(ac_match->string))
flags |= RE_FLAGS_NO_CASE;
if (STRING_IS_DOT_ALL(ac_match->string))
flags |= RE_FLAGS_DOT_ALL;
if (STRING_IS_FAST_REGEXP(ac_match->string))
exec = yr_re_fast_exec;
else
exec = yr_re_exec;
if (STRING_IS_ASCII(ac_match->string))
{
forward_matches = exec(
ac_match->forward_code,
data + offset,
data_size - offset,
offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,
NULL,
NULL);
}
if (STRING_IS_WIDE(ac_match->string) && forward_matches == -1)
{
flags |= RE_FLAGS_WIDE;
forward_matches = exec(
ac_match->forward_code,
data + offset,
data_size - offset,
offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,
NULL,
NULL);
}
switch(forward_matches)
{
case -1:
return ERROR_SUCCESS;
case -2:
return ERROR_INSUFFICIENT_MEMORY;
case -3:
return ERROR_TOO_MANY_MATCHES;
case -4:
return ERROR_TOO_MANY_RE_FIBERS;
case -5:
return ERROR_INTERNAL_FATAL_ERROR;
}
if (forward_matches == 0 && ac_match->backward_code == NULL)
return ERROR_SUCCESS;
callback_args.string = ac_match->string;
callback_args.context = context;
callback_args.data = data;
callback_args.data_size = data_size;
callback_args.data_base = data_base;
callback_args.forward_matches = forward_matches;
callback_args.full_word = STRING_IS_FULL_WORD(ac_match->string);
if (ac_match->backward_code != NULL)
{
backward_matches = exec(
ac_match->backward_code,
data + offset,
offset,
flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE,
_yr_scan_match_callback,
(void*) &callback_args);
switch(backward_matches)
{
case -2:
return ERROR_INSUFFICIENT_MEMORY;
case -3:
return ERROR_TOO_MANY_MATCHES;
case -4:
return ERROR_TOO_MANY_RE_FIBERS;
case -5:
return ERROR_INTERNAL_FATAL_ERROR;
}
}
else
{
FAIL_ON_ERROR(_yr_scan_match_callback(
data + offset, 0, flags, &callback_args));
}
return ERROR_SUCCESS;
}","int _yr_scan_verify_re_match(
YR_SCAN_CONTEXT* VAR_0,
YR_AC_MATCH* VAR_1,
uint8_t* VAR_2,
size_t VAR_3,
size_t VAR_4,
size_t VAR_5)
{
CALLBACK_ARGS VAR_6;
RE_EXEC_FUNC VAR_7;
int VAR_8 = -1;
int VAR_9 = -1;
int VAR_10 = 0;
if (STRING_IS_GREEDY_REGEXP(VAR_1->string))
VAR_10 |= VAR_11;
if (STRING_IS_NO_CASE(VAR_1->string))
VAR_10 |= VAR_12;
if (STRING_IS_DOT_ALL(VAR_1->string))
VAR_10 |= VAR_13;
if (STRING_IS_FAST_REGEXP(VAR_1->string))
VAR_7 = VAR_14;
else
VAR_7 = VAR_15;
if (STRING_IS_ASCII(VAR_1->string))
{
VAR_8 = VAR_7(
VAR_1->forward_code,
VAR_2 + VAR_5,
VAR_3 - VAR_5,
VAR_5 > 0 ? VAR_10 | VAR_16 : VAR_10,
NULL,
NULL);
}
if (STRING_IS_WIDE(VAR_1->string) && VAR_8 == -1)
{
VAR_10 |= VAR_17;
VAR_8 = VAR_7(
VAR_1->forward_code,
VAR_2 + VAR_5,
VAR_3 - VAR_5,
VAR_5 > 0 ? VAR_10 | VAR_16 : VAR_10,
NULL,
NULL);
}
switch(VAR_8)
{
case -1:
return VAR_18;
case -2:
return VAR_19;
case -3:
return VAR_20;
case -4:
return VAR_21;
case -5:
return VAR_22;
}
if (VAR_8 == 0 && VAR_1->backward_code == NULL)
return VAR_18;
VAR_6.string = VAR_1->string;
VAR_6.context = VAR_0;
VAR_6.data = VAR_2;
VAR_6.data_size = VAR_3;
VAR_6.data_base = VAR_4;
VAR_6.forward_matches = VAR_8;
VAR_6.full_word = STRING_IS_FULL_WORD(VAR_1->string);
if (VAR_1->backward_code != NULL)
{
VAR_9 = VAR_7(
VAR_1->backward_code,
VAR_2 + VAR_5,
VAR_5,
VAR_10 | VAR_23 | VAR_24,
VAR_25,
(void*) &VAR_6);
switch(VAR_9)
{
case -2:
return VAR_19;
case -3:
return VAR_20;
case -4:
return VAR_21;
case -5:
return VAR_22;
}
}
else
{
FAIL_ON_ERROR(VAR_25(
VAR_2 + VAR_5, 0, VAR_10, &VAR_6));
}
return VAR_18;
}",VirusTotal/yara/83d799804648c2a0895d40a19835d9b757c6fa4e/scan.c/vul/before/0.json,"int _yr_scan_verify_re_match(
    YR_SCAN_CONTEXT* context,
    YR_AC_MATCH* ac_match,
    uint8_t* data,
    size_t data_size,
    size_t data_base,
    size_t offset)
{
  CALLBACK_ARGS callback_args;
  RE_EXEC_FUNC exec;

  int forward_matches = -1;
  int backward_matches = -1;
  int flags = 0;

  if (STRING_IS_GREEDY_REGEXP(ac_match->string))
    flags |= RE_FLAGS_GREEDY;

  if (STRING_IS_NO_CASE(ac_match->string))
    flags |= RE_FLAGS_NO_CASE;

  if (STRING_IS_DOT_ALL(ac_match->string))
    flags |= RE_FLAGS_DOT_ALL;

  if (STRING_IS_FAST_REGEXP(ac_match->string))
    exec = yr_re_fast_exec;
  else
    exec = yr_re_exec;

  if (STRING_IS_ASCII(ac_match->string))
  {
    forward_matches = exec(
        ac_match->forward_code,
        data + offset,
        data_size - offset,
        offset,
        flags,
        NULL,
        NULL);
  }

  if (STRING_IS_WIDE(ac_match->string) && forward_matches == -1)
  {
    flags |= RE_FLAGS_WIDE;
    forward_matches = exec(
        ac_match->forward_code,
        data + offset,
        data_size - offset,
        offset,
        flags,
        NULL,
        NULL);
  }

  switch(forward_matches)
  {
    case -1:
      return ERROR_SUCCESS;
    case -2:
      return ERROR_INSUFFICIENT_MEMORY;
    case -3:
      return ERROR_TOO_MANY_MATCHES;
    case -4:
      return ERROR_TOO_MANY_RE_FIBERS;
    case -5:
      return ERROR_INTERNAL_FATAL_ERROR;
  }

  if (forward_matches == 0 && ac_match->backward_code == NULL)
    return ERROR_SUCCESS;

  callback_args.string = ac_match->string;
  callback_args.context = context;
  callback_args.data = data;
  callback_args.data_size = data_size;
  callback_args.data_base = data_base;
  callback_args.forward_matches = forward_matches;
  callback_args.full_word = STRING_IS_FULL_WORD(ac_match->string);

  if (ac_match->backward_code != NULL)
  {
    backward_matches = exec(
        ac_match->backward_code,
        data + offset,
        data_size - offset,
        offset,
        flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE,
        _yr_scan_match_callback,
        (void*) &callback_args);

    switch(backward_matches)
    {
      case -2:
        return ERROR_INSUFFICIENT_MEMORY;
      case -3:
        return ERROR_TOO_MANY_MATCHES;
      case -4:
        return ERROR_TOO_MANY_RE_FIBERS;
      case -5:
        return ERROR_INTERNAL_FATAL_ERROR;
    }
  }
  else
  {
    FAIL_ON_ERROR(_yr_scan_match_callback(
        data + offset, 0, flags, &callback_args));
  }

  return ERROR_SUCCESS;
}","int _yr_scan_verify_re_match(
    YR_SCAN_CONTEXT* VAR_0,
    YR_AC_MATCH* VAR_1,
    uint8_t* VAR_2,
    size_t VAR_3,
    size_t VAR_4,
    size_t VAR_5)
{
  CALLBACK_ARGS VAR_6;
  RE_EXEC_FUNC VAR_7;

  int VAR_8 = -1;
  int VAR_9 = -1;
  int VAR_10 = 0;

  if (STRING_IS_GREEDY_REGEXP(VAR_1->string))
    VAR_10 |= VAR_11;

  if (STRING_IS_NO_CASE(VAR_1->string))
    VAR_10 |= VAR_12;

  if (STRING_IS_DOT_ALL(VAR_1->string))
    VAR_10 |= VAR_13;

  if (STRING_IS_FAST_REGEXP(VAR_1->string))
    VAR_7 = VAR_14;
  else
    VAR_7 = VAR_15;

  if (STRING_IS_ASCII(VAR_1->string))
  {
    VAR_8 = VAR_7(
        VAR_1->forward_code,
        VAR_2 + VAR_5,
        VAR_3 - VAR_5,
        VAR_5,
        VAR_10,
        NULL,
        NULL);
  }

  if (STRING_IS_WIDE(VAR_1->string) && VAR_8 == -1)
  {
    VAR_10 |= VAR_16;
    VAR_8 = VAR_7(
        VAR_1->forward_code,
        VAR_2 + VAR_5,
        VAR_3 - VAR_5,
        VAR_5,
        VAR_10,
        NULL,
        NULL);
  }

  switch(VAR_8)
  {
    case -1:
      return VAR_17;
    case -2:
      return VAR_18;
    case -3:
      return VAR_19;
    case -4:
      return VAR_20;
    case -5:
      return VAR_21;
  }

  if (VAR_8 == 0 && VAR_1->backward_code == NULL)
    return VAR_17;

  VAR_6.string = VAR_1->string;
  VAR_6.context = VAR_0;
  VAR_6.data = VAR_2;
  VAR_6.data_size = VAR_3;
  VAR_6.data_base = VAR_4;
  VAR_6.forward_matches = VAR_8;
  VAR_6.full_word = STRING_IS_FULL_WORD(VAR_1->string);

  if (VAR_1->backward_code != NULL)
  {
    VAR_9 = VAR_7(
        VAR_1->backward_code,
        VAR_2 + VAR_5,
        VAR_3 - VAR_5,
        VAR_5,
        VAR_10 | VAR_22 | VAR_23,
        VAR_24,
        (void*) &VAR_6);

    switch(VAR_9)
    {
      case -2:
        return VAR_18;
      case -3:
        return VAR_19;
      case -4:
        return VAR_20;
      case -5:
        return VAR_21;
    }
  }
  else
  {
    FAIL_ON_ERROR(VAR_24(
        VAR_2 + VAR_5, 0, VAR_10, &VAR_6));
  }

  return VAR_17;
}",VirusTotal/yara/83d799804648c2a0895d40a19835d9b757c6fa4e/scan.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -33,7 +33,8 @@
         ac_match->forward_code,
         data + offset,
         data_size - offset,
-        offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,
+        offset,
+        flags,
         NULL,
         NULL);
   }
@@ -45,7 +46,8 @@
         ac_match->forward_code,
         data + offset,
         data_size - offset,
-        offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,
+        offset,
+        flags,
         NULL,
         NULL);
   }
@@ -80,6 +82,7 @@
     backward_matches = exec(
         ac_match->backward_code,
         data + offset,
+        data_size - offset,
         offset,
         flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE,
         _yr_scan_match_callback,","{'deleted_lines': ['        offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,', '        offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,'], 'added_lines': ['        offset,', '        flags,', '        offset,', '        flags,', '        data_size - offset,']}",True,libyara/re.c in the regex component in YARA 3.5.0 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted rule that is mishandled in the yr_re_exec function.,7.5,HIGH,2,test,2017-04-27T09:39:04Z,1
CVE-2017-8294,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"Fix issue #646 (#648)

* Fix issue #646 and some edge cases with wide regexps using \b and \B

* Rename function IS_WORD_CHAR to _yr_re_is_word_char",83d799804648c2a0895d40a19835d9b757c6fa4e,https://github.com/VirusTotal/yara/commit/83d799804648c2a0895d40a19835d9b757c6fa4e,libyara/re.c,yr_re_fast_exec,"int yr_re_fast_exec(
uint8_t* code,
uint8_t* input_data,
size_t input_size,
int flags,
RE_MATCH_CALLBACK_FUNC callback,
void* callback_args)
{
RE_REPEAT_ANY_ARGS* repeat_any_args;
uint8_t* code_stack[MAX_FAST_RE_STACK];
uint8_t* input_stack[MAX_FAST_RE_STACK];
int matches_stack[MAX_FAST_RE_STACK];
uint8_t* ip = code;
uint8_t* input = input_data;
uint8_t* next_input;
uint8_t* next_opcode;
uint8_t mask;
uint8_t value;
int i;
int stop;
int input_incr;
int sp = 0;
int bytes_matched;
int max_bytes_matched = input_size;
input_incr = flags & RE_FLAGS_BACKWARDS ? -1 : 1;
if (flags & RE_FLAGS_BACKWARDS)
input--;
code_stack[sp] = code;
input_stack[sp] = input;
matches_stack[sp] = 0;
sp++;
while (sp > 0)
{
sp--;
ip = code_stack[sp];
input = input_stack[sp];
bytes_matched = matches_stack[sp];
stop = FALSE;
while(!stop)
{
if (*ip == RE_OPCODE_MATCH)
{
if (flags & RE_FLAGS_EXHAUSTIVE)
{
int cb_result = callback(
flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data,
bytes_matched,
flags,
callback_args);
switch(cb_result)
{
case ERROR_INSUFFICIENT_MEMORY:
return -2;
case ERROR_TOO_MANY_MATCHES:
return -3;
default:
if (cb_result != ERROR_SUCCESS)
return -4;
}
break;
}
else
{
return bytes_matched;
}
}
if (bytes_matched >= max_bytes_matched)
break;
switch(*ip)
{
case RE_OPCODE_LITERAL:
if (*input == *(ip + 1))
{
bytes_matched++;
input += input_incr;
ip += 2;
}
else
{
stop = TRUE;
}
break;
case RE_OPCODE_MASKED_LITERAL:
value = *(int16_t*)(ip + 1) & 0xFF;
mask = *(int16_t*)(ip + 1) >> 8;
if ((*input & mask) == value)
{
bytes_matched++;
input += input_incr;
ip += 3;
}
else
{
stop = TRUE;
}
break;
case RE_OPCODE_ANY:
bytes_matched++;
input += input_incr;
ip += 1;
break;
case RE_OPCODE_REPEAT_ANY_UNGREEDY:
repeat_any_args = (RE_REPEAT_ANY_ARGS*)(ip + 1);
next_opcode = ip + 1 + sizeof(RE_REPEAT_ANY_ARGS);
for (i = repeat_any_args->min + 1; i <= repeat_any_args->max; i++)
{
next_input = input + i * input_incr;
if (bytes_matched + i >= max_bytes_matched)
break;
if ( *(next_opcode) != RE_OPCODE_LITERAL ||
(*(next_opcode) == RE_OPCODE_LITERAL &&
*(next_opcode + 1) == *next_input))
{
if (sp >= MAX_FAST_RE_STACK)
return -4;
code_stack[sp] = next_opcode;
input_stack[sp] = next_input;
matches_stack[sp] = bytes_matched + i;
sp++;
}
}
input += input_incr * repeat_any_args->min;
bytes_matched += repeat_any_args->min;
ip = next_opcode;
break;
default:
assert(FALSE);
}
}
}
return -1;
}","int yr_re_fast_exec(
uint8_t* VAR_0,
uint8_t* VAR_1,
size_t VAR_2,
int VAR_3,
RE_MATCH_CALLBACK_FUNC VAR_4,
void* VAR_5)
{
RE_REPEAT_ANY_ARGS* VAR_6;
uint8_t* VAR_7[VAR_8];
uint8_t* VAR_9[VAR_8];
int VAR_10[VAR_8];
uint8_t* VAR_11 = VAR_0;
uint8_t* VAR_12 = VAR_1;
uint8_t* VAR_13;
uint8_t* VAR_14;
uint8_t VAR_15;
uint8_t VAR_16;
int VAR_17;
int VAR_18;
int VAR_19;
int VAR_20 = 0;
int VAR_21;
int VAR_22 = VAR_2;
VAR_19 = VAR_3 & VAR_23 ? -1 : 1;
if (VAR_3 & VAR_23)
VAR_12--;
VAR_7[VAR_20] = VAR_0;
VAR_9[VAR_20] = VAR_12;
VAR_10[VAR_20] = 0;
VAR_20++;
while (VAR_20 > 0)
{
VAR_20--;
VAR_11 = VAR_7[VAR_20];
VAR_12 = VAR_9[VAR_20];
VAR_21 = VAR_10[VAR_20];
VAR_18 = FALSE;
while(!VAR_18)
{
if (*VAR_11 == VAR_24)
{
if (VAR_3 & VAR_25)
{
int VAR_26 = VAR_4(
VAR_3 & VAR_23 ? VAR_12 + 1 : VAR_1,
VAR_21,
VAR_3,
VAR_5);
switch(VAR_26)
{
case VAR_27:
return -2;
case VAR_28:
return -3;
default:
if (VAR_26 != VAR_29)
return -4;
}
break;
}
else
{
return VAR_21;
}
}
if (VAR_21 >= VAR_22)
break;
switch(*VAR_11)
{
case VAR_30:
if (*VAR_12 == *(VAR_11 + 1))
{
VAR_21++;
VAR_12 += VAR_19;
VAR_11 += 2;
}
else
{
VAR_18 = TRUE;
}
break;
case VAR_31:
VAR_16 = *(int16_t*)(VAR_11 + 1) & 0xFF;
VAR_15 = *(int16_t*)(VAR_11 + 1) >> 8;
if ((*VAR_12 & VAR_15) == VAR_16)
{
VAR_21++;
VAR_12 += VAR_19;
VAR_11 += 3;
}
else
{
VAR_18 = TRUE;
}
break;
case VAR_32:
VAR_21++;
VAR_12 += VAR_19;
VAR_11 += 1;
break;
case VAR_33:
VAR_6 = (RE_REPEAT_ANY_ARGS*)(VAR_11 + 1);
VAR_14 = VAR_11 + 1 + sizeof(RE_REPEAT_ANY_ARGS);
for (VAR_17 = VAR_6->min + 1; VAR_17 <= VAR_6->max; VAR_17++)
{
VAR_13 = VAR_12 + VAR_17 * VAR_19;
if (VAR_21 + VAR_17 >= VAR_22)
break;
if ( *(VAR_14) != VAR_30 ||
(*(VAR_14) == VAR_30 &&
*(VAR_14 + 1) == *VAR_13))
{
if (VAR_20 >= VAR_8)
return -4;
VAR_7[VAR_20] = VAR_14;
VAR_9[VAR_20] = VAR_13;
VAR_10[VAR_20] = VAR_21 + VAR_17;
VAR_20++;
}
}
VAR_12 += VAR_19 * VAR_6->min;
VAR_21 += VAR_6->min;
VAR_11 = VAR_14;
break;
default:
assert(FALSE);
}
}
}
return -1;
}",VirusTotal/yara/83d799804648c2a0895d40a19835d9b757c6fa4e/re.c/vul/before/1.json,"int yr_re_fast_exec(
    uint8_t* code,
    uint8_t* input_data,
    size_t input_forwards_size,
    size_t input_backwards_size,
    int flags,
    RE_MATCH_CALLBACK_FUNC callback,
    void* callback_args)
{
  RE_REPEAT_ANY_ARGS* repeat_any_args;

  uint8_t* code_stack[MAX_FAST_RE_STACK];
  uint8_t* input_stack[MAX_FAST_RE_STACK];
  int matches_stack[MAX_FAST_RE_STACK];

  uint8_t* ip = code;
  uint8_t* input = input_data;
  uint8_t* next_input;
  uint8_t* next_opcode;
  uint8_t mask;
  uint8_t value;

  int i;
  int stop;
  int input_incr;
  int sp = 0;
  int bytes_matched;
  int max_bytes_matched;

  max_bytes_matched = flags & RE_FLAGS_BACKWARDS ?
      input_backwards_size :
      input_forwards_size;

  input_incr = flags & RE_FLAGS_BACKWARDS ? -1 : 1;

  if (flags & RE_FLAGS_BACKWARDS)
    input--;

  code_stack[sp] = code;
  input_stack[sp] = input;
  matches_stack[sp] = 0;
  sp++;

  while (sp > 0)
  {
    sp--;
    ip = code_stack[sp];
    input = input_stack[sp];
    bytes_matched = matches_stack[sp];
    stop = FALSE;

    while(!stop)
    {
      if (*ip == RE_OPCODE_MATCH)
      {
        if (flags & RE_FLAGS_EXHAUSTIVE)
        {
          int cb_result = callback(
             flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data,
             bytes_matched,
             flags,
             callback_args);

          switch(cb_result)
          {
            case ERROR_INSUFFICIENT_MEMORY:
              return -2;
            case ERROR_TOO_MANY_MATCHES:
              return -3;
            default:
              if (cb_result != ERROR_SUCCESS)
                return -4;
          }

          break;
        }
        else
        {
          return bytes_matched;
        }
      }

      if (bytes_matched >= max_bytes_matched)
        break;

      switch(*ip)
      {
        case RE_OPCODE_LITERAL:

          if (*input == *(ip + 1))
          {
            bytes_matched++;
            input += input_incr;
            ip += 2;
          }
          else
          {
            stop = TRUE;
          }

          break;

        case RE_OPCODE_MASKED_LITERAL:

          value = *(int16_t*)(ip + 1) & 0xFF;
          mask = *(int16_t*)(ip + 1) >> 8;

          if ((*input & mask) == value)
          {
            bytes_matched++;
            input += input_incr;
            ip += 3;
          }
          else
          {
            stop = TRUE;
          }

          break;

        case RE_OPCODE_ANY:

          bytes_matched++;
          input += input_incr;
          ip += 1;

          break;

        case RE_OPCODE_REPEAT_ANY_UNGREEDY:

          repeat_any_args = (RE_REPEAT_ANY_ARGS*)(ip + 1);
          next_opcode = ip + 1 + sizeof(RE_REPEAT_ANY_ARGS);

          for (i = repeat_any_args->min + 1; i <= repeat_any_args->max; i++)
          {
            next_input = input + i * input_incr;

            if (bytes_matched + i >= max_bytes_matched)
              break;

            if ( *(next_opcode) != RE_OPCODE_LITERAL ||
                (*(next_opcode) == RE_OPCODE_LITERAL &&
                 *(next_opcode + 1) == *next_input))
            {
              if (sp >= MAX_FAST_RE_STACK)
                return -4;

              code_stack[sp] = next_opcode;
              input_stack[sp] = next_input;
              matches_stack[sp] = bytes_matched + i;
              sp++;
            }
          }

          input += input_incr * repeat_any_args->min;
          bytes_matched += repeat_any_args->min;
          ip = next_opcode;

          break;

        default:
          assert(FALSE);
      }
    }
  }

  return -1;
}","int yr_re_fast_exec(
    uint8_t* VAR_0,
    uint8_t* VAR_1,
    size_t VAR_2,
    size_t VAR_3,
    int VAR_4,
    RE_MATCH_CALLBACK_FUNC VAR_5,
    void* VAR_6)
{
  RE_REPEAT_ANY_ARGS* VAR_7;

  uint8_t* VAR_8[VAR_9];
  uint8_t* VAR_10[VAR_9];
  int VAR_11[VAR_9];

  uint8_t* VAR_12 = VAR_0;
  uint8_t* VAR_13 = VAR_1;
  uint8_t* VAR_14;
  uint8_t* VAR_15;
  uint8_t VAR_16;
  uint8_t VAR_17;

  int VAR_18;
  int VAR_19;
  int VAR_20;
  int VAR_21 = 0;
  int VAR_22;
  int VAR_23;

  VAR_23 = VAR_4 & VAR_24 ?
      VAR_3 :
      VAR_2;

  VAR_20 = VAR_4 & VAR_24 ? -1 : 1;

  if (VAR_4 & VAR_24)
    VAR_13--;

  VAR_8[VAR_21] = VAR_0;
  VAR_10[VAR_21] = VAR_13;
  VAR_11[VAR_21] = 0;
  VAR_21++;

  while (VAR_21 > 0)
  {
    VAR_21--;
    VAR_12 = VAR_8[VAR_21];
    VAR_13 = VAR_10[VAR_21];
    VAR_22 = VAR_11[VAR_21];
    VAR_19 = FALSE;

    while(!VAR_19)
    {
      if (*VAR_12 == VAR_25)
      {
        if (VAR_4 & VAR_26)
        {
          int VAR_27 = VAR_5(
             VAR_4 & VAR_24 ? VAR_13 + 1 : VAR_1,
             VAR_22,
             VAR_4,
             VAR_6);

          switch(VAR_27)
          {
            case VAR_28:
              return -2;
            case VAR_29:
              return -3;
            default:
              if (VAR_27 != VAR_30)
                return -4;
          }

          break;
        }
        else
        {
          return VAR_22;
        }
      }

      if (VAR_22 >= VAR_23)
        break;

      switch(*VAR_12)
      {
        case VAR_31:

          if (*VAR_13 == *(VAR_12 + 1))
          {
            VAR_22++;
            VAR_13 += VAR_20;
            VAR_12 += 2;
          }
          else
          {
            VAR_19 = TRUE;
          }

          break;

        case VAR_32:

          VAR_17 = *(int16_t*)(VAR_12 + 1) & 0xFF;
          VAR_16 = *(int16_t*)(VAR_12 + 1) >> 8;

          if ((*VAR_13 & VAR_16) == VAR_17)
          {
            VAR_22++;
            VAR_13 += VAR_20;
            VAR_12 += 3;
          }
          else
          {
            VAR_19 = TRUE;
          }

          break;

        case VAR_33:

          VAR_22++;
          VAR_13 += VAR_20;
          VAR_12 += 1;

          break;

        case VAR_34:

          VAR_7 = (RE_REPEAT_ANY_ARGS*)(VAR_12 + 1);
          VAR_15 = VAR_12 + 1 + sizeof(RE_REPEAT_ANY_ARGS);

          for (VAR_18 = VAR_7->min + 1; VAR_18 <= VAR_7->max; VAR_18++)
          {
            VAR_14 = VAR_13 + VAR_18 * VAR_20;

            if (VAR_22 + VAR_18 >= VAR_23)
              break;

            if ( *(VAR_15) != VAR_31 ||
                (*(VAR_15) == VAR_31 &&
                 *(VAR_15 + 1) == *VAR_14))
            {
              if (VAR_21 >= VAR_9)
                return -4;

              VAR_8[VAR_21] = VAR_15;
              VAR_10[VAR_21] = VAR_14;
              VAR_11[VAR_21] = VAR_22 + VAR_18;
              VAR_21++;
            }
          }

          VAR_13 += VAR_20 * VAR_7->min;
          VAR_22 += VAR_7->min;
          VAR_12 = VAR_15;

          break;

        default:
          assert(FALSE);
      }
    }
  }

  return -1;
}",VirusTotal/yara/83d799804648c2a0895d40a19835d9b757c6fa4e/re.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,7 +1,8 @@
 int yr_re_fast_exec(
     uint8_t* code,
     uint8_t* input_data,
-    size_t input_size,
+    size_t input_forwards_size,
+    size_t input_backwards_size,
     int flags,
     RE_MATCH_CALLBACK_FUNC callback,
     void* callback_args)
@@ -24,7 +25,11 @@
   int input_incr;
   int sp = 0;
   int bytes_matched;
-  int max_bytes_matched = input_size;
+  int max_bytes_matched;
+
+  max_bytes_matched = flags & RE_FLAGS_BACKWARDS ?
+      input_backwards_size :
+      input_forwards_size;
 
   input_incr = flags & RE_FLAGS_BACKWARDS ? -1 : 1;
 ","{'deleted_lines': ['    size_t input_size,', '  int max_bytes_matched = input_size;'], 'added_lines': ['    size_t input_forwards_size,', '    size_t input_backwards_size,', '  int max_bytes_matched;', '', '  max_bytes_matched = flags & RE_FLAGS_BACKWARDS ?', '      input_backwards_size :', '      input_forwards_size;']}",True,libyara/re.c in the regex component in YARA 3.5.0 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted rule that is mishandled in the yr_re_exec function.,7.5,HIGH,2,test,2017-04-27T09:39:04Z,1
CVE-2017-8294,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,VirusTotal/yara,"Fix issue #646 (#648)

* Fix issue #646 and some edge cases with wide regexps using \b and \B

* Rename function IS_WORD_CHAR to _yr_re_is_word_char",83d799804648c2a0895d40a19835d9b757c6fa4e,https://github.com/VirusTotal/yara/commit/83d799804648c2a0895d40a19835d9b757c6fa4e,libyara/re.c,yr_re_match,"int yr_re_match(
RE* re,
const char* target)
{
return yr_re_exec(
re->code,
(uint8_t*) target,
strlen(target),
re->flags | RE_FLAGS_SCAN,
NULL,
NULL);
}","int yr_re_match(
RE* VAR_0,
const char* VAR_1)
{
return yr_re_exec(
VAR_0->code,
(uint8_t*) VAR_1,
strlen(VAR_1),
VAR_0->flags | VAR_2,
NULL,
NULL);
}",VirusTotal/yara/83d799804648c2a0895d40a19835d9b757c6fa4e/re.c/vul/before/0.json,"int yr_re_match(
    RE* re,
    const char* target)
{
  return yr_re_exec(
      re->code,
      (uint8_t*) target,
      strlen(target),
      0,
      re->flags | RE_FLAGS_SCAN,
      NULL,
      NULL);
}","int yr_re_match(
    RE* VAR_0,
    const char* VAR_1)
{
  return yr_re_exec(
      VAR_0->code,
      (uint8_t*) VAR_1,
      strlen(VAR_1),
      0,
      VAR_0->flags | VAR_2,
      NULL,
      NULL);
}",VirusTotal/yara/83d799804648c2a0895d40a19835d9b757c6fa4e/re.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,7 @@
       re->code,
       (uint8_t*) target,
       strlen(target),
+      0,
       re->flags | RE_FLAGS_SCAN,
       NULL,
       NULL);","{'deleted_lines': [], 'added_lines': ['      0,']}",True,libyara/re.c in the regex component in YARA 3.5.0 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted rule that is mishandled in the yr_re_exec function.,7.5,HIGH,2,test,2017-04-27T09:39:04Z,1
CVE-2017-9350,"['CWE-20', 'CWE-770']",AV:N/AC:L/Au:N/C:N/I:N/A:C,0,wireshark,"[OpenSafety] Bugfix invalid length calculation.

Length calculation leads to -1, which will result in a large malloc

https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=1212
Bug: 13649
Change-Id: Iccb78b8c8ec9ca8e8f97bc12d0d8f41526d1f791
Reviewed-on: https://code.wireshark.org/review/21367
Reviewed-by: Roland Knall <rknall@gmail.com>
Petri-Dish: Roland Knall <rknall@gmail.com>
Reviewed-by: Michael Mann <mmann78@netscape.net>
(cherry picked from commit f6431695049116176361ce4691dfd3c77ab19858)
Reviewed-on: https://code.wireshark.org/review/21376
Petri-Dish: Michael Mann <mmann78@netscape.net>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>",dbc7cb0bbdd501fa96e0cb98668f6d6bf17ac4e6,https://github.com/wireshark/wireshark/commit/dbc7cb0bbdd501fa96e0cb98668f6d6bf17ac4e6,epan/dissectors/packet-opensafety.c,dissect_opensafety_ssdo_message,"static void
dissect_opensafety_ssdo_message(tvbuff_t *message_tvb, packet_info *pinfo, proto_tree *opensafety_tree,
opensafety_packet_info * packet, proto_item * opensafety_item )
{
proto_item    *item;
proto_tree    *ssdo_tree, *ssdo_payload;
guint16        taddr                = 0, sdn = 0, server = 0, client = 0, n = 0, ct = 0;
guint32        abortcode, ssdoIndex = 0, ssdoSubIndex = 0, payloadSize, fragmentId = 0, entry = 0;
guint8         db0Offset, db0, payloadOffset, preload;
guint          dataLength;
gint           calcDataLength;
gboolean       isResponse, saveFragmented;
tvbuff_t      *new_tvb              = NULL;
fragment_head *frag_msg             = NULL;
static const int * ssdo_sacmd_flags[] = {
&hf_oss_ssdo_sacmd_end_segment,
&hf_oss_ssdo_sacmd_initiate,
&hf_oss_ssdo_sacmd_toggle,
&hf_oss_ssdo_sacmd_segmentation,
&hf_oss_ssdo_sacmd_abort_transfer,
&hf_oss_ssdo_sacmd_preload,
&hf_oss_ssdo_sacmd_access_type,
NULL
};
dataLength = tvb_get_guint8(message_tvb, OSS_FRAME_POS_LEN + packet->frame.subframe1);
db0Offset = packet->frame.subframe1 + OSS_FRAME_POS_DATA;
db0 = tvb_get_guint8(message_tvb, db0Offset);
ssdoIndex = 0;
ssdoSubIndex = 0;
isResponse = ( ( OSS_FRAME_ID_T(message_tvb, packet->frame.subframe1) & 0x04 ) == 0x04 );
if ( packet->scm_udid_valid )
{
taddr = OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2 + 3, packet->scm_udid[3], packet->scm_udid[4]);
sdn =  ( OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1) ^
( OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2, packet->scm_udid[0], packet->scm_udid[1]) ) );
opensafety_packet_sendreceiv ( message_tvb, pinfo, opensafety_tree, opensafety_item, packet, taddr,
packet->frame.subframe2 + 3, OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1),
packet->frame.subframe1, packet->frame.subframe2, sdn );
}
else if ( ! isResponse )
{
opensafety_packet_sender ( message_tvb, pinfo, opensafety_tree, opensafety_item, packet,
OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1), packet->frame.subframe1,
packet->frame.subframe2, -1 * ( ( OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1) ) ^
( OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2, packet->scm_udid[0], packet->scm_udid[1]) ) ) );
}
else if ( isResponse )
{
opensafety_packet_receiver ( message_tvb, pinfo, opensafety_tree, opensafety_item, packet,
OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1), packet->frame.subframe1,
packet->frame.subframe2, -1 * ( ( OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1) ) ^
( OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2, packet->scm_udid[0], packet->scm_udid[1]) ) ) );
}
ssdo_tree = opensafety_packet_payloadtree ( message_tvb, opensafety_tree, packet, ett_opensafety_ssdo );
opensafety_packet_response ( message_tvb, ssdo_tree, packet, isResponse );
packet->payload.ssdo->sacmd.toggle = ( db0 & OPENSAFETY_SSDO_SACMD_TGL ) == OPENSAFETY_SSDO_SACMD_TGL;
packet->payload.ssdo->sacmd.abort_transfer = ( db0 & OPENSAFETY_SSDO_SACMD_ABRT ) == OPENSAFETY_SSDO_SACMD_ABRT;
packet->payload.ssdo->sacmd.preload = ( db0 & OPENSAFETY_SSDO_SACMD_PRLD ) == OPENSAFETY_SSDO_SACMD_PRLD;
packet->payload.ssdo->sacmd.read_access = ( db0 & OPENSAFETY_SSDO_DOWNLOAD ) == OPENSAFETY_SSDO_DOWNLOAD;
packet->payload.ssdo->sacmd.initiate = ( db0 & OPENSAFETY_SSDO_SACMD_INI ) == OPENSAFETY_SSDO_SACMD_INI;
packet->payload.ssdo->sacmd.segmented = ( db0 & OPENSAFETY_SSDO_SACMD_SEG ) == OPENSAFETY_SSDO_SACMD_SEG;
packet->payload.ssdo->sacmd.end_segment = ( db0 & OPENSAFETY_SSDO_SACMD_ENSG ) == OPENSAFETY_SSDO_SACMD_ENSG;
if ( isResponse )
{
opensafety_packet_node ( message_tvb, pinfo, ssdo_tree, hf_oss_ssdo_client,
OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1),
packet->frame.subframe1, packet->frame.subframe2, sdn );
client = OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1);
if ( packet->scm_udid_valid )
{
proto_tree_add_uint(ssdo_tree, hf_oss_ssdo_server, message_tvb, packet->frame.subframe2 + 3, 2, taddr);
server = taddr;
}
}
else if ( ! isResponse )
{
proto_tree_add_uint(ssdo_tree, hf_oss_ssdo_server, message_tvb, packet->frame.subframe1, 2, OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1));
server = OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1);
if ( packet->scm_udid_valid )
{
opensafety_packet_node ( message_tvb, pinfo, ssdo_tree, hf_oss_ssdo_client,
taddr, packet->frame.subframe2 + 3, packet->frame.subframe2, sdn );
client = taddr;
}
}
if ( packet->payload.ssdo->sacmd.toggle )
db0 &= (~OPENSAFETY_SSDO_SACMD_TGL);
proto_tree_add_bitmask(ssdo_tree, message_tvb, db0Offset, hf_oss_ssdo_sacmd,
ett_opensafety_ssdo_sacmd, ssdo_sacmd_flags, ENC_NA);
col_append_fstr(pinfo->cinfo, COL_INFO, "", SACMD: %s"", val_to_str_const(db0, opensafety_ssdo_sacmd_values, "" ""));
payloadOffset = db0Offset + 1;
ct = tvb_get_guint8(message_tvb, packet->frame.subframe1 + 3);
if ( packet->scm_udid_valid )
{
ct = (guint16)((tvb_get_guint8(message_tvb, packet->frame.subframe2 + 2) ^ packet->scm_udid[2]) << 8);
ct += (tvb_get_guint8(message_tvb, packet->frame.subframe1 + 3));
}
proto_tree_add_uint(ssdo_tree, hf_oss_ssdo_sano, message_tvb, packet->frame.subframe1 + 3, 1, ct );
if ( packet->scm_udid_valid && packet->payload.ssdo->sacmd.preload && isResponse )
{
preload = ( (tvb_get_guint8(message_tvb, packet->frame.subframe2 + 4) ^ packet->scm_udid[4]) & 0xFC ) >> 2;
if ( packet->payload.ssdo->sacmd.initiate )
{
proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_preload_queue, message_tvb, packet->frame.subframe2 + 4, 1,
preload & 0x0F, ""%d"", preload & 0x0F );
}
else
{
item = proto_tree_add_item(ssdo_tree, hf_oss_ssdo_preload_error, message_tvb, packet->frame.subframe2 + 4, 1, ENC_NA );
if ( (preload & 0x30) == 0x30 )
proto_item_append_text(item, "" (SOD Access Request Number is last successful)"" );
}
}
if ( packet->payload.ssdo->sacmd.initiate && !packet->payload.ssdo->sacmd.abort_transfer )
{
ssdoIndex = tvb_get_letohs(message_tvb, db0Offset + 1);
ssdoSubIndex = tvb_get_guint8(message_tvb, db0Offset + 3);
proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_sod_index, message_tvb, db0Offset + 1, 2,
ssdoIndex, ""0x%04X (%s)"", ssdoIndex,
val_to_str_ext_const(((guint32) (ssdoIndex << 16)), &opensafety_sod_idx_names_ext, ""Unknown"") );
col_append_fstr(pinfo->cinfo, COL_INFO, "" [%s"", val_to_str_ext_const(((guint32) (ssdoIndex << 16)), &opensafety_sod_idx_names_ext, ""Unknown""));
if ( ssdoSubIndex != 0x0 )
{
proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_sod_subindex, message_tvb, db0Offset + 3, 1,
ssdoSubIndex, ""0x%02X (%s)"", ssdoSubIndex,
val_to_str_ext_const(((guint32) (ssdoIndex << 16) + ssdoSubIndex), &opensafety_sod_idx_names_ext, ""Unknown"") );
col_append_fstr(pinfo->cinfo, COL_INFO, "" - %s"",
val_to_str_ext_const(((guint32) (ssdoIndex << 16) + ssdoSubIndex), &opensafety_sod_idx_names_ext, ""Unknown""));
}
col_append_fstr(pinfo->cinfo, COL_INFO, ""%s"", ""]"" );
payloadOffset += 3;
}
if ( packet->payload.ssdo->sacmd.abort_transfer )
{
abortcode = tvb_get_letohl(message_tvb, packet->frame.subframe1 + OSS_FRAME_POS_DATA + 4);
proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_abort_code, message_tvb, packet->frame.subframe1 + OSS_FRAME_POS_DATA + 4, 4, abortcode,
""0x%04X %04X - %s"", (guint16)(abortcode >> 16), (guint16)(abortcode),
val_to_str_ext_const(abortcode, &opensafety_abort_codes_ext, ""Unknown""));
col_append_fstr(pinfo->cinfo, COL_INFO, "" - %s"", val_to_str_ext_const(abortcode, &opensafety_abort_codes_ext, ""Unknown""));
} else {
if ( ( packet->payload.ssdo->sacmd.initiate || packet->payload.ssdo->sacmd.segmented || packet->payload.ssdo->sacmd.end_segment ) &&
( ( isResponse && !packet->payload.ssdo->sacmd.read_access ) ||
( !isResponse && packet->payload.ssdo->sacmd.read_access ) ) )
{
saveFragmented = pinfo->fragmented;
if ( server != 0 && client != 0 )
fragmentId = (guint32)((((guint32)client) << 16 ) + server );
if ( packet->payload.ssdo->sacmd.segmented && packet->payload.ssdo->sacmd.initiate )
{
payloadOffset += 4;
payloadSize = tvb_get_letohl(message_tvb, payloadOffset - 4);
calcDataLength = dataLength - (payloadOffset - db0Offset);
item = proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_payload_size, message_tvb, payloadOffset - 4, 4,
payloadSize, ""%d octets total (%d octets in this frame)"", payloadSize, calcDataLength);
if ( fragmentId != 0 && packet->payload.ssdo->sacmd.segmented )
{
pinfo->fragmented = TRUE;
frag_msg = fragment_add_seq_check(&os_reassembly_table, message_tvb, payloadOffset, pinfo,
fragmentId, NULL, 0, calcDataLength, TRUE );
fragment_add_seq_offset ( &os_reassembly_table, pinfo, fragmentId, NULL, ct );
if ( frag_msg != NULL )
{
item = proto_tree_add_bytes_format_value(ssdo_tree, hf_oss_ssdo_payload, message_tvb, 0, 0, NULL, ""Reassembled"" );
PROTO_ITEM_SET_GENERATED(item);
ssdo_payload = proto_item_add_subtree(item, ett_opensafety_ssdo_payload);
process_reassembled_data(message_tvb, 0, pinfo, ""Reassembled Message"", frag_msg, &oss_frag_items, NULL, ssdo_payload );
}
}
if ( (gint) calcDataLength >= (gint) 0 )
{
proto_tree_add_item(ssdo_tree, hf_oss_ssdo_payload, message_tvb, payloadOffset, calcDataLength, ENC_NA );
} else {
expert_add_info_format(pinfo, item, &ei_payload_length_not_positive,
""Calculation for payload length yielded non-positive result [%d]"", (guint) calcDataLength );
}
}
else
{
payloadSize = dataLength - (payloadOffset - db0Offset);
if ( fragmentId != 0 && packet->payload.ssdo->sacmd.segmented )
{
pinfo->fragmented = TRUE;
frag_msg = fragment_add_seq_check(&os_reassembly_table, message_tvb, payloadOffset, pinfo,
fragmentId, NULL, ct, payloadSize,
packet->payload.ssdo->sacmd.end_segment ? FALSE : TRUE );
}
if ( frag_msg )
{
item = proto_tree_add_bytes_format_value(ssdo_tree, hf_oss_ssdo_payload, message_tvb,
0, 0, NULL, ""Reassembled"" );
PROTO_ITEM_SET_GENERATED(item);
ssdo_payload = proto_item_add_subtree(item, ett_opensafety_ssdo_payload);
new_tvb = process_reassembled_data(message_tvb, 0, pinfo, ""Reassembled Message"", frag_msg,
&oss_frag_items, NULL, ssdo_payload );
if ( packet->payload.ssdo->sacmd.end_segment && new_tvb )
{
item = proto_tree_add_uint_format_value(ssdo_payload, hf_oss_ssdo_payload_size, message_tvb, 0, 0,
payloadSize, ""%d octets (over all fragments)"", frag_msg->len);
PROTO_ITEM_SET_GENERATED(item);
col_append_str(pinfo->cinfo, COL_INFO, "" (Message Reassembled)"" );
dissect_opensafety_ssdo_payload ( pinfo, new_tvb, ssdo_payload, db0 );
}
}
else
{
item = proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_payload_size, message_tvb, 0, 0, payloadSize,
""%d octets"", payloadSize);
PROTO_ITEM_SET_GENERATED(item);
if ( ssdoIndex == OPENSAFETY_SOD_DVI && ssdoSubIndex == 0x06 )
{
entry = tvb_get_letohl ( message_tvb, payloadOffset );
proto_tree_add_uint_format_value ( ssdo_tree, hf_oss_sod_par_timestamp, message_tvb, payloadOffset,
4, entry, ""0x%08X"", entry );
for ( n = 4; n < payloadSize; n+=4 )
{
entry = tvb_get_letohl ( message_tvb, payloadOffset + n );
proto_tree_add_uint_format_value ( ssdo_tree, hf_oss_sod_par_checksum, message_tvb, (payloadOffset + n ),
4, entry, ""[#%d] 0x%08X"", ( n / 4 ), entry );
}
} else if ( ssdoIndex == OPENSAFETY_SOD_DVI && ssdoSubIndex == 0x07 ) {
entry = tvb_get_letohl ( message_tvb, payloadOffset );
proto_tree_add_uint_format_value ( ssdo_tree, hf_oss_sod_par_timestamp, message_tvb, payloadOffset,
4, entry, ""0x%08X"", entry );
} else
proto_tree_add_item(ssdo_tree, hf_oss_ssdo_payload, message_tvb, payloadOffset, payloadSize, ENC_NA );
}
}
pinfo->fragmented = saveFragmented;
}
}
}","static void
dissect_opensafety_ssdo_message(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2,
opensafety_packet_info * VAR_3, proto_item * VAR_4 )
{
proto_item    *VAR_5;
proto_tree    *VAR_6, *VAR_7;
guint16        VAR_8                = 0, VAR_9 = 0, VAR_10 = 0, VAR_11 = 0, VAR_12 = 0, VAR_13 = 0;
guint32        VAR_14, VAR_15 = 0, VAR_16 = 0, VAR_17, VAR_18 = 0, VAR_19 = 0;
guint8         VAR_20, VAR_21, VAR_22, VAR_23;
guint          VAR_24;
gint           VAR_25;
gboolean       VAR_26, VAR_27;
tvbuff_t      *VAR_28              = NULL;
fragment_head *VAR_29             = NULL;
static const int * VAR_30[] = {
&VAR_31,
&VAR_32,
&VAR_33,
&VAR_34,
&VAR_35,
&VAR_36,
&VAR_37,
NULL
};
VAR_24 = tvb_get_guint8(VAR_0, VAR_38 + VAR_3->frame.subframe1);
VAR_20 = VAR_3->frame.subframe1 + VAR_39;
VAR_21 = tvb_get_guint8(VAR_0, VAR_20);
VAR_15 = 0;
VAR_16 = 0;
VAR_26 = ( ( OSS_FRAME_ID_T(VAR_0, VAR_3->frame.subframe1) & 0x04 ) == 0x04 );
if ( VAR_3->scm_udid_valid )
{
VAR_8 = OSS_FRAME_ADDR_T2(VAR_0, VAR_3->frame.subframe2 + 3, VAR_3->scm_udid[3], VAR_3->scm_udid[4]);
VAR_9 =  ( OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1) ^
( OSS_FRAME_ADDR_T2(VAR_0, VAR_3->frame.subframe2, VAR_3->scm_udid[0], VAR_3->scm_udid[1]) ) );
opensafety_packet_sendreceiv ( VAR_0, VAR_1, VAR_2, VAR_4, VAR_3, VAR_8,
VAR_3->frame.subframe2 + 3, OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1),
VAR_3->frame.subframe1, VAR_3->frame.subframe2, VAR_9 );
}
else if ( ! VAR_26 )
{
opensafety_packet_sender ( VAR_0, VAR_1, VAR_2, VAR_4, VAR_3,
OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1), VAR_3->frame.subframe1,
VAR_3->frame.subframe2, -1 * ( ( OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1) ) ^
( OSS_FRAME_ADDR_T2(VAR_0, VAR_3->frame.subframe2, VAR_3->scm_udid[0], VAR_3->scm_udid[1]) ) ) );
}
else if ( VAR_26 )
{
opensafety_packet_receiver ( VAR_0, VAR_1, VAR_2, VAR_4, VAR_3,
OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1), VAR_3->frame.subframe1,
VAR_3->frame.subframe2, -1 * ( ( OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1) ) ^
( OSS_FRAME_ADDR_T2(VAR_0, VAR_3->frame.subframe2, VAR_3->scm_udid[0], VAR_3->scm_udid[1]) ) ) );
}
VAR_6 = opensafety_packet_payloadtree ( VAR_0, VAR_2, VAR_3, VAR_40 );
opensafety_packet_response ( VAR_0, VAR_6, VAR_3, VAR_26 );
VAR_3->payload.ssdo->sacmd.toggle = ( VAR_21 & VAR_41 ) == VAR_41;
VAR_3->payload.ssdo->sacmd.abort_transfer = ( VAR_21 & VAR_42 ) == VAR_42;
VAR_3->payload.ssdo->sacmd.preload = ( VAR_21 & VAR_43 ) == VAR_43;
VAR_3->payload.ssdo->sacmd.read_access = ( VAR_21 & VAR_44 ) == VAR_44;
VAR_3->payload.ssdo->sacmd.initiate = ( VAR_21 & VAR_45 ) == VAR_45;
VAR_3->payload.ssdo->sacmd.segmented = ( VAR_21 & VAR_46 ) == VAR_46;
VAR_3->payload.ssdo->sacmd.end_segment = ( VAR_21 & VAR_47 ) == VAR_47;
if ( VAR_26 )
{
opensafety_packet_node ( VAR_0, VAR_1, VAR_6, VAR_48,
OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1),
VAR_3->frame.subframe1, VAR_3->frame.subframe2, VAR_9 );
VAR_11 = OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1);
if ( VAR_3->scm_udid_valid )
{
proto_tree_add_uint(VAR_6, VAR_49, VAR_0, VAR_3->frame.subframe2 + 3, 2, VAR_8);
VAR_10 = VAR_8;
}
}
else if ( ! VAR_26 )
{
proto_tree_add_uint(VAR_6, VAR_49, VAR_0, VAR_3->frame.subframe1, 2, OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1));
VAR_10 = OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1);
if ( VAR_3->scm_udid_valid )
{
opensafety_packet_node ( VAR_0, VAR_1, VAR_6, VAR_48,
VAR_8, VAR_3->frame.subframe2 + 3, VAR_3->frame.subframe2, VAR_9 );
VAR_11 = VAR_8;
}
}
if ( VAR_3->payload.ssdo->sacmd.toggle )
VAR_21 &= (~VAR_41);
proto_tree_add_bitmask(VAR_6, VAR_0, VAR_20, VAR_50,
VAR_51, VAR_30, VAR_52);
col_append_fstr(VAR_1->cinfo, VAR_53, "", SACMD: %s"", val_to_str_const(VAR_21, VAR_54, "" ""));
VAR_22 = VAR_20 + 1;
VAR_13 = tvb_get_guint8(VAR_0, VAR_3->frame.subframe1 + 3);
if ( VAR_3->scm_udid_valid )
{
VAR_13 = (guint16)((tvb_get_guint8(VAR_0, VAR_3->frame.subframe2 + 2) ^ VAR_3->scm_udid[2]) << 8);
VAR_13 += (tvb_get_guint8(VAR_0, VAR_3->frame.subframe1 + 3));
}
proto_tree_add_uint(VAR_6, VAR_55, VAR_0, VAR_3->frame.subframe1 + 3, 1, VAR_13 );
if ( VAR_3->scm_udid_valid && VAR_3->payload.ssdo->sacmd.preload && VAR_26 )
{
VAR_23 = ( (tvb_get_guint8(VAR_0, VAR_3->frame.subframe2 + 4) ^ VAR_3->scm_udid[4]) & 0xFC ) >> 2;
if ( VAR_3->payload.ssdo->sacmd.initiate )
{
proto_tree_add_uint_format_value(VAR_6, VAR_56, VAR_0, VAR_3->frame.subframe2 + 4, 1,
VAR_23 & 0x0F, ""%d"", VAR_23 & 0x0F );
}
else
{
VAR_5 = proto_tree_add_item(VAR_6, VAR_57, VAR_0, VAR_3->frame.subframe2 + 4, 1, VAR_52 );
if ( (VAR_23 & 0x30) == 0x30 )
proto_item_append_text(VAR_5, "" (SOD Access Request Number is last successful)"" );
}
}
if ( VAR_3->payload.ssdo->sacmd.initiate && !VAR_3->payload.ssdo->sacmd.abort_transfer )
{
VAR_15 = tvb_get_letohs(VAR_0, VAR_20 + 1);
VAR_16 = tvb_get_guint8(VAR_0, VAR_20 + 3);
proto_tree_add_uint_format_value(VAR_6, VAR_58, VAR_0, VAR_20 + 1, 2,
VAR_15, ""0x%04X (%s)"", VAR_15,
val_to_str_ext_const(((guint32) (VAR_15 << 16)), &VAR_59, ""Unknown"") );
col_append_fstr(VAR_1->cinfo, VAR_53, "" [%s"", val_to_str_ext_const(((guint32) (VAR_15 << 16)), &VAR_59, ""Unknown""));
if ( VAR_16 != 0x0 )
{
proto_tree_add_uint_format_value(VAR_6, VAR_60, VAR_0, VAR_20 + 3, 1,
VAR_16, ""0x%02X (%s)"", VAR_16,
val_to_str_ext_const(((guint32) (VAR_15 << 16) + VAR_16), &VAR_59, ""Unknown"") );
col_append_fstr(VAR_1->cinfo, VAR_53, "" - %s"",
val_to_str_ext_const(((guint32) (VAR_15 << 16) + VAR_16), &VAR_59, ""Unknown""));
}
col_append_fstr(VAR_1->cinfo, VAR_53, ""%s"", ""]"" );
VAR_22 += 3;
}
if ( VAR_3->payload.ssdo->sacmd.abort_transfer )
{
VAR_14 = tvb_get_letohl(VAR_0, VAR_3->frame.subframe1 + VAR_39 + 4);
proto_tree_add_uint_format_value(VAR_6, VAR_61, VAR_0, VAR_3->frame.subframe1 + VAR_39 + 4, 4, VAR_14,
""0x%04X %04X - %s"", (guint16)(VAR_14 >> 16), (guint16)(VAR_14),
val_to_str_ext_const(VAR_14, &VAR_62, ""Unknown""));
col_append_fstr(VAR_1->cinfo, VAR_53, "" - %s"", val_to_str_ext_const(VAR_14, &VAR_62, ""Unknown""));
} else {
if ( ( VAR_3->payload.ssdo->sacmd.initiate || VAR_3->payload.ssdo->sacmd.segmented || VAR_3->payload.ssdo->sacmd.end_segment ) &&
( ( VAR_26 && !VAR_3->payload.ssdo->sacmd.read_access ) ||
( !VAR_26 && VAR_3->payload.ssdo->sacmd.read_access ) ) )
{
VAR_27 = VAR_1->fragmented;
if ( VAR_10 != 0 && VAR_11 != 0 )
VAR_18 = (guint32)((((guint32)VAR_11) << 16 ) + VAR_10 );
if ( VAR_3->payload.ssdo->sacmd.segmented && VAR_3->payload.ssdo->sacmd.initiate )
{
VAR_22 += 4;
VAR_17 = tvb_get_letohl(VAR_0, VAR_22 - 4);
VAR_25 = VAR_24 - (VAR_22 - VAR_20);
VAR_5 = proto_tree_add_uint_format_value(VAR_6, VAR_63, VAR_0, VAR_22 - 4, 4,
VAR_17, ""%d octets total (%d octets in this frame)"", VAR_17, VAR_25);
if ( VAR_18 != 0 && VAR_3->payload.ssdo->sacmd.segmented )
{
VAR_1->fragmented = TRUE;
VAR_29 = fragment_add_seq_check(&VAR_64, VAR_0, VAR_22, VAR_1,
VAR_18, NULL, 0, VAR_25, TRUE );
fragment_add_seq_offset ( &VAR_64, VAR_1, VAR_18, NULL, VAR_13 );
if ( VAR_29 != NULL )
{
VAR_5 = proto_tree_add_bytes_format_value(VAR_6, VAR_65, VAR_0, 0, 0, NULL, ""Reassembled"" );
PROTO_ITEM_SET_GENERATED(VAR_5);
VAR_7 = proto_item_add_subtree(VAR_5, VAR_66);
process_reassembled_data(VAR_0, 0, VAR_1, ""Reassembled Message"", VAR_29, &VAR_67, NULL, VAR_7 );
}
}
if ( (gint) VAR_25 >= (gint) 0 )
{
proto_tree_add_item(VAR_6, VAR_65, VAR_0, VAR_22, VAR_25, VAR_52 );
} else {
expert_add_info_format(VAR_1, VAR_5, &VAR_68,
""Calculation for payload length yielded non-positive result [%d]"", (guint) VAR_25 );
}
}
else
{
VAR_17 = VAR_24 - (VAR_22 - VAR_20);
if ( VAR_18 != 0 && VAR_3->payload.ssdo->sacmd.segmented )
{
VAR_1->fragmented = TRUE;
VAR_29 = fragment_add_seq_check(&VAR_64, VAR_0, VAR_22, VAR_1,
VAR_18, NULL, VAR_13, VAR_17,
VAR_3->payload.ssdo->sacmd.end_segment ? FALSE : TRUE );
}
if ( VAR_29 )
{
VAR_5 = proto_tree_add_bytes_format_value(VAR_6, VAR_65, VAR_0,
0, 0, NULL, ""Reassembled"" );
PROTO_ITEM_SET_GENERATED(VAR_5);
VAR_7 = proto_item_add_subtree(VAR_5, VAR_66);
VAR_28 = process_reassembled_data(VAR_0, 0, VAR_1, ""Reassembled Message"", VAR_29,
&VAR_67, NULL, VAR_7 );
if ( VAR_3->payload.ssdo->sacmd.end_segment && VAR_28 )
{
VAR_5 = proto_tree_add_uint_format_value(VAR_7, VAR_63, VAR_0, 0, 0,
VAR_17, ""%d octets (over all fragments)"", VAR_29->len);
PROTO_ITEM_SET_GENERATED(VAR_5);
col_append_str(VAR_1->cinfo, VAR_53, "" (Message Reassembled)"" );
dissect_opensafety_ssdo_payload ( VAR_1, VAR_28, VAR_7, VAR_21 );
}
}
else
{
VAR_5 = proto_tree_add_uint_format_value(VAR_6, VAR_63, VAR_0, 0, 0, VAR_17,
""%d octets"", VAR_17);
PROTO_ITEM_SET_GENERATED(VAR_5);
if ( VAR_15 == VAR_69 && VAR_16 == 0x06 )
{
VAR_19 = tvb_get_letohl ( VAR_0, VAR_22 );
proto_tree_add_uint_format_value ( VAR_6, VAR_70, VAR_0, VAR_22,
4, VAR_19, ""0x%08X"", VAR_19 );
for ( VAR_12 = 4; VAR_12 < VAR_17; VAR_12+=4 )
{
VAR_19 = tvb_get_letohl ( VAR_0, VAR_22 + VAR_12 );
proto_tree_add_uint_format_value ( VAR_6, VAR_71, VAR_0, (VAR_22 + VAR_12 ),
4, VAR_19, ""[#%d] 0x%08X"", ( VAR_12 / 4 ), VAR_19 );
}
} else if ( VAR_15 == VAR_69 && VAR_16 == 0x07 ) {
VAR_19 = tvb_get_letohl ( VAR_0, VAR_22 );
proto_tree_add_uint_format_value ( VAR_6, VAR_70, VAR_0, VAR_22,
4, VAR_19, ""0x%08X"", VAR_19 );
} else
proto_tree_add_item(VAR_6, VAR_65, VAR_0, VAR_22, VAR_17, VAR_52 );
}
}
VAR_1->fragmented = VAR_27;
}
}
}",wireshark/dbc7cb0bbdd501fa96e0cb98668f6d6bf17ac4e6/packet-opensafety.c/vul/before/0.json,"static void
dissect_opensafety_ssdo_message(tvbuff_t *message_tvb, packet_info *pinfo, proto_tree *opensafety_tree,
        opensafety_packet_info * packet, proto_item * opensafety_item )
{
    proto_item    *item;
    proto_tree    *ssdo_tree, *ssdo_payload;
    guint16        taddr                = 0, sdn = 0, server = 0, client = 0, n = 0, ct = 0;
    guint32        abortcode, ssdoIndex = 0, ssdoSubIndex = 0, payloadSize, fragmentId = 0, entry = 0;
    guint8         db0Offset, db0, payloadOffset, preload;
    guint          dataLength;
    gint           calcDataLength;
    gboolean       isResponse, saveFragmented;
    tvbuff_t      *new_tvb              = NULL;
    fragment_head *frag_msg             = NULL;

    static const int * ssdo_sacmd_flags[] = {
            &hf_oss_ssdo_sacmd_end_segment,
            &hf_oss_ssdo_sacmd_initiate,
            &hf_oss_ssdo_sacmd_toggle,
            &hf_oss_ssdo_sacmd_segmentation,
            &hf_oss_ssdo_sacmd_abort_transfer,
            &hf_oss_ssdo_sacmd_preload,
            &hf_oss_ssdo_sacmd_access_type,
            NULL
    };

    dataLength = tvb_get_guint8(message_tvb, OSS_FRAME_POS_LEN + packet->frame.subframe1);

    db0Offset = packet->frame.subframe1 + OSS_FRAME_POS_DATA;
    db0 = tvb_get_guint8(message_tvb, db0Offset);
    ssdoIndex = 0;
    ssdoSubIndex = 0;

    /* Response is determined by the openSAFETY message field */
    isResponse = ( ( OSS_FRAME_ID_T(message_tvb, packet->frame.subframe1) & 0x04 ) == 0x04 );

    if ( packet->scm_udid_valid )
    {
        /* taddr is the 4th octet in the second frame */
        taddr = OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2 + 3, packet->scm_udid[3], packet->scm_udid[4]);
        sdn =  ( OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1) ^
                        ( OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2, packet->scm_udid[0], packet->scm_udid[1]) ) );

        opensafety_packet_sendreceiv ( message_tvb, pinfo, opensafety_tree, opensafety_item, packet, taddr,
                packet->frame.subframe2 + 3, OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1),
                packet->frame.subframe1, packet->frame.subframe2, sdn );
    }
    else if ( ! isResponse )
    {
        opensafety_packet_sender ( message_tvb, pinfo, opensafety_tree, opensafety_item, packet,
                OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1), packet->frame.subframe1,
                packet->frame.subframe2, -1 * ( ( OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1) ) ^
                        ( OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2, packet->scm_udid[0], packet->scm_udid[1]) ) ) );
    }
    else if ( isResponse )
    {
        opensafety_packet_receiver ( message_tvb, pinfo, opensafety_tree, opensafety_item, packet,
                OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1), packet->frame.subframe1,
                packet->frame.subframe2, -1 * ( ( OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1) ) ^
                        ( OSS_FRAME_ADDR_T2(message_tvb, packet->frame.subframe2, packet->scm_udid[0], packet->scm_udid[1]) ) ) );
    }

    ssdo_tree = opensafety_packet_payloadtree ( message_tvb, opensafety_tree, packet, ett_opensafety_ssdo );

    opensafety_packet_response ( message_tvb, ssdo_tree, packet, isResponse );

    packet->payload.ssdo->sacmd.toggle = ( db0 & OPENSAFETY_SSDO_SACMD_TGL ) == OPENSAFETY_SSDO_SACMD_TGL;
    packet->payload.ssdo->sacmd.abort_transfer = ( db0 & OPENSAFETY_SSDO_SACMD_ABRT ) == OPENSAFETY_SSDO_SACMD_ABRT;
    packet->payload.ssdo->sacmd.preload = ( db0 & OPENSAFETY_SSDO_SACMD_PRLD ) == OPENSAFETY_SSDO_SACMD_PRLD;
    packet->payload.ssdo->sacmd.read_access = ( db0 & OPENSAFETY_SSDO_DOWNLOAD ) == OPENSAFETY_SSDO_DOWNLOAD;
    packet->payload.ssdo->sacmd.initiate = ( db0 & OPENSAFETY_SSDO_SACMD_INI ) == OPENSAFETY_SSDO_SACMD_INI;
    packet->payload.ssdo->sacmd.segmented = ( db0 & OPENSAFETY_SSDO_SACMD_SEG ) == OPENSAFETY_SSDO_SACMD_SEG;
    packet->payload.ssdo->sacmd.end_segment = ( db0 & OPENSAFETY_SSDO_SACMD_ENSG ) == OPENSAFETY_SSDO_SACMD_ENSG;

    if ( isResponse )
    {
        opensafety_packet_node ( message_tvb, pinfo, ssdo_tree, hf_oss_ssdo_client,
                OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1),
                packet->frame.subframe1, packet->frame.subframe2, sdn );
        client = OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1);

        if ( packet->scm_udid_valid )
        {
            proto_tree_add_uint(ssdo_tree, hf_oss_ssdo_server, message_tvb, packet->frame.subframe2 + 3, 2, taddr);
            server = taddr;
        }
    }
    else if ( ! isResponse )
    {
        proto_tree_add_uint(ssdo_tree, hf_oss_ssdo_server, message_tvb, packet->frame.subframe1, 2, OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1));
        server = OSS_FRAME_ADDR_T(message_tvb, packet->frame.subframe1);
        if ( packet->scm_udid_valid )
        {
            opensafety_packet_node ( message_tvb, pinfo, ssdo_tree, hf_oss_ssdo_client,
                    taddr, packet->frame.subframe2 + 3, packet->frame.subframe2, sdn );
            client = taddr;
        }
    }

    /* Toggle bit must be removed, otherwise the values cannot be displayed correctly */
    if ( packet->payload.ssdo->sacmd.toggle )
        db0 &= (~OPENSAFETY_SSDO_SACMD_TGL);
    proto_tree_add_bitmask(ssdo_tree, message_tvb, db0Offset, hf_oss_ssdo_sacmd,
            ett_opensafety_ssdo_sacmd, ssdo_sacmd_flags, ENC_NA);

    col_append_fstr(pinfo->cinfo, COL_INFO, "", SACMD: %s"", val_to_str_const(db0, opensafety_ssdo_sacmd_values, "" ""));

    payloadOffset = db0Offset + 1;

    ct = tvb_get_guint8(message_tvb, packet->frame.subframe1 + 3);
    if ( packet->scm_udid_valid )
    {
        ct = (guint16)((tvb_get_guint8(message_tvb, packet->frame.subframe2 + 2) ^ packet->scm_udid[2]) << 8);
        ct += (tvb_get_guint8(message_tvb, packet->frame.subframe1 + 3));
    }

    proto_tree_add_uint(ssdo_tree, hf_oss_ssdo_sano, message_tvb, packet->frame.subframe1 + 3, 1, ct );

    /* Evaluate preload field [field TR] */
    if ( packet->scm_udid_valid && packet->payload.ssdo->sacmd.preload && isResponse )
    {
        /* Preload info are the higher 6 bit of the TR field */
        preload = ( (tvb_get_guint8(message_tvb, packet->frame.subframe2 + 4) ^ packet->scm_udid[4]) & 0xFC ) >> 2;

        if ( packet->payload.ssdo->sacmd.initiate )
        {
            /* Use the lower 4 bits from the preload as size */
            proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_preload_queue, message_tvb, packet->frame.subframe2 + 4, 1,
                    preload & 0x0F, ""%d"", preload & 0x0F );
        }
        else
        {
            /* The highest 2 bits of information contain an error flag */
            item = proto_tree_add_item(ssdo_tree, hf_oss_ssdo_preload_error, message_tvb, packet->frame.subframe2 + 4, 1, ENC_NA );
            if ( (preload & 0x30) == 0x30 )
                proto_item_append_text(item, "" (SOD Access Request Number is last successful)"" );
        }
    }

    /* When the following clause is met, DB1,2 contain the SOD index, and DB3 the SOD subindex */
    if ( packet->payload.ssdo->sacmd.initiate && !packet->payload.ssdo->sacmd.abort_transfer )
    {
        ssdoIndex = tvb_get_letohs(message_tvb, db0Offset + 1);
        ssdoSubIndex = tvb_get_guint8(message_tvb, db0Offset + 3);

        proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_sod_index, message_tvb, db0Offset + 1, 2,
                ssdoIndex, ""0x%04X (%s)"", ssdoIndex,
                val_to_str_ext_const(((guint32) (ssdoIndex << 16)), &opensafety_sod_idx_names_ext, ""Unknown"") );
        col_append_fstr(pinfo->cinfo, COL_INFO, "" [%s"", val_to_str_ext_const(((guint32) (ssdoIndex << 16)), &opensafety_sod_idx_names_ext, ""Unknown""));

        /* Some SOD downloads (0x101A for instance) don't have sub-indeces */
        if ( ssdoSubIndex != 0x0 )
        {
            proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_sod_subindex, message_tvb, db0Offset + 3, 1,
                ssdoSubIndex, ""0x%02X (%s)"", ssdoSubIndex,
                val_to_str_ext_const(((guint32) (ssdoIndex << 16) + ssdoSubIndex), &opensafety_sod_idx_names_ext, ""Unknown"") );
            col_append_fstr(pinfo->cinfo, COL_INFO, "" - %s"",
                    val_to_str_ext_const(((guint32) (ssdoIndex << 16) + ssdoSubIndex), &opensafety_sod_idx_names_ext, ""Unknown""));
        }
        col_append_fstr(pinfo->cinfo, COL_INFO, ""%s"", ""]"" );
        payloadOffset += 3;
    }

    if ( packet->payload.ssdo->sacmd.abort_transfer )
    {
        abortcode = tvb_get_letohl(message_tvb, packet->frame.subframe1 + OSS_FRAME_POS_DATA + 4);

        proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_abort_code, message_tvb, packet->frame.subframe1 + OSS_FRAME_POS_DATA + 4, 4, abortcode,
                ""0x%04X %04X - %s"", (guint16)(abortcode >> 16), (guint16)(abortcode),
                val_to_str_ext_const(abortcode, &opensafety_abort_codes_ext, ""Unknown""));
        col_append_fstr(pinfo->cinfo, COL_INFO, "" - %s"", val_to_str_ext_const(abortcode, &opensafety_abort_codes_ext, ""Unknown""));


    } else {
        /* Either the SSDO msg is a response, then data is sent by the server and only in uploads,
         * or the message is a request, then data is coming from the client and payload data is
         * sent in downloads. Data is only sent in initiate, segmented or end-segment messages */
        if ( ( packet->payload.ssdo->sacmd.initiate || packet->payload.ssdo->sacmd.segmented || packet->payload.ssdo->sacmd.end_segment ) &&
             ( ( isResponse && !packet->payload.ssdo->sacmd.read_access ) ||
                     ( !isResponse && packet->payload.ssdo->sacmd.read_access ) ) )
        {
            saveFragmented = pinfo->fragmented;
            if ( server != 0 && client != 0 )
                fragmentId = (guint32)((((guint32)client) << 16 ) + server );

            /* If payload data has to be calculated, either a total size is given, or not */
            if ( packet->payload.ssdo->sacmd.segmented && packet->payload.ssdo->sacmd.initiate )
            {

                payloadOffset += 4;

                /* reading real size */
                payloadSize = tvb_get_letohl(message_tvb, payloadOffset - 4);

                calcDataLength = dataLength - (payloadOffset - db0Offset);

                item = proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_payload_size, message_tvb, payloadOffset - 4, 4,
                        payloadSize, ""%d octets total (%d octets in this frame)"", payloadSize, calcDataLength);

                if ( fragmentId != 0 && packet->payload.ssdo->sacmd.segmented )
                {
                    pinfo->fragmented = TRUE;
                    frag_msg = fragment_add_seq_check(&os_reassembly_table, message_tvb, payloadOffset, pinfo,
                                                      fragmentId, NULL, 0, calcDataLength, TRUE );
                    fragment_add_seq_offset ( &os_reassembly_table, pinfo, fragmentId, NULL, ct );

                    if ( frag_msg != NULL )
                    {
                        item = proto_tree_add_bytes_format_value(ssdo_tree, hf_oss_ssdo_payload, message_tvb, 0, 0, NULL, ""Reassembled"" );
                        PROTO_ITEM_SET_GENERATED(item);

                        ssdo_payload = proto_item_add_subtree(item, ett_opensafety_ssdo_payload);
                        process_reassembled_data(message_tvb, 0, pinfo, ""Reassembled Message"", frag_msg, &oss_frag_items, NULL, ssdo_payload );
                    }
                }

                if ( (gint) calcDataLength >= (gint) 0 )
                {
                    proto_tree_add_item(ssdo_tree, hf_oss_ssdo_payload, message_tvb, payloadOffset, calcDataLength, ENC_NA );
                } else {
                    expert_add_info_format(pinfo, item, &ei_payload_length_not_positive,
                                                ""Calculation for payload length yielded non-positive result [%d]"", (guint) calcDataLength );
                }
            }
            else
            {
                payloadSize = dataLength - (payloadOffset - db0Offset);
                if ((gint)dataLength < (payloadOffset - db0Offset))
                {
                    expert_add_info_format(pinfo, opensafety_item, &ei_payload_length_not_positive,
                                                    ""Calculation for payload length yielded non-positive result [%d]"", (gint)payloadSize );
                    return;
                }

                if ( fragmentId != 0 && packet->payload.ssdo->sacmd.segmented )
                {
                    pinfo->fragmented = TRUE;

                    frag_msg = fragment_add_seq_check(&os_reassembly_table, message_tvb, payloadOffset, pinfo,
                                                      fragmentId, NULL, ct, payloadSize,
                                                      packet->payload.ssdo->sacmd.end_segment ? FALSE : TRUE );
                }

                if ( frag_msg )
                {
                    item = proto_tree_add_bytes_format_value(ssdo_tree, hf_oss_ssdo_payload, message_tvb,
                                                             0, 0, NULL, ""Reassembled"" );
                    PROTO_ITEM_SET_GENERATED(item);
                    ssdo_payload = proto_item_add_subtree(item, ett_opensafety_ssdo_payload);

                    new_tvb = process_reassembled_data(message_tvb, 0, pinfo, ""Reassembled Message"", frag_msg,
                                                       &oss_frag_items, NULL, ssdo_payload );
                    if ( packet->payload.ssdo->sacmd.end_segment && new_tvb )
                    {
                        item = proto_tree_add_uint_format_value(ssdo_payload, hf_oss_ssdo_payload_size, message_tvb, 0, 0,
                                                                payloadSize, ""%d octets (over all fragments)"", frag_msg->len);
                        PROTO_ITEM_SET_GENERATED(item);

                        col_append_str(pinfo->cinfo, COL_INFO, "" (Message Reassembled)"" );
                        dissect_opensafety_ssdo_payload ( pinfo, new_tvb, ssdo_payload, db0 );
                    }
                }
                else
                {
                    item = proto_tree_add_uint_format_value(ssdo_tree, hf_oss_ssdo_payload_size, message_tvb, 0, 0, payloadSize,
                            ""%d octets"", payloadSize);
                    PROTO_ITEM_SET_GENERATED(item);

                    if ( ssdoIndex == OPENSAFETY_SOD_DVI && ssdoSubIndex == 0x06 )
                    {
                        entry = tvb_get_letohl ( message_tvb, payloadOffset );
                        proto_tree_add_uint_format_value ( ssdo_tree, hf_oss_sod_par_timestamp, message_tvb, payloadOffset,
                                    4, entry, ""0x%08X"", entry );
                        for ( n = 4; n < payloadSize; n+=4 )
                        {
                            entry = tvb_get_letohl ( message_tvb, payloadOffset + n );
                            proto_tree_add_uint_format_value ( ssdo_tree, hf_oss_sod_par_checksum, message_tvb, (payloadOffset + n ),
                                    4, entry, ""[#%d] 0x%08X"", ( n / 4 ), entry );
                        }
                    } else if ( ssdoIndex == OPENSAFETY_SOD_DVI && ssdoSubIndex == 0x07 ) {
                        entry = tvb_get_letohl ( message_tvb, payloadOffset );
                        proto_tree_add_uint_format_value ( ssdo_tree, hf_oss_sod_par_timestamp, message_tvb, payloadOffset,
                                    4, entry, ""0x%08X"", entry );
                    } else
                        proto_tree_add_item(ssdo_tree, hf_oss_ssdo_payload, message_tvb, payloadOffset, payloadSize, ENC_NA );
                }
            }

            pinfo->fragmented = saveFragmented;
        }
    }
}","static void
dissect_opensafety_ssdo_message(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2,
        opensafety_packet_info * VAR_3, proto_item * VAR_4 )
{
    proto_item    *VAR_5;
    proto_tree    *VAR_6, *VAR_7;
    guint16        VAR_8                = 0, VAR_9 = 0, VAR_10 = 0, VAR_11 = 0, VAR_12 = 0, VAR_13 = 0;
    guint32        VAR_14, VAR_15 = 0, VAR_16 = 0, VAR_17, VAR_18 = 0, VAR_19 = 0;
    guint8         VAR_20, VAR_21, VAR_22, VAR_23;
    guint          VAR_24;
    gint           VAR_25;
    gboolean       VAR_26, VAR_27;
    tvbuff_t      *VAR_28              = NULL;
    fragment_head *VAR_29             = NULL;

    static const int * VAR_30[] = {
            &VAR_31,
            &VAR_32,
            &VAR_33,
            &VAR_34,
            &VAR_35,
            &VAR_36,
            &VAR_37,
            NULL
    };

    VAR_24 = tvb_get_guint8(VAR_0, VAR_38 + VAR_3->frame.subframe1);

    VAR_20 = VAR_3->frame.subframe1 + VAR_39;
    VAR_21 = tvb_get_guint8(VAR_0, VAR_20);
    VAR_15 = 0;
    VAR_16 = 0;

    /* COMMENT_0 */
    VAR_26 = ( ( OSS_FRAME_ID_T(VAR_0, VAR_3->frame.subframe1) & 0x04 ) == 0x04 );

    if ( VAR_3->scm_udid_valid )
    {
        /* COMMENT_1 */
        VAR_8 = OSS_FRAME_ADDR_T2(VAR_0, VAR_3->frame.subframe2 + 3, VAR_3->scm_udid[3], VAR_3->scm_udid[4]);
        VAR_9 =  ( OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1) ^
                        ( OSS_FRAME_ADDR_T2(VAR_0, VAR_3->frame.subframe2, VAR_3->scm_udid[0], VAR_3->scm_udid[1]) ) );

        opensafety_packet_sendreceiv ( VAR_0, VAR_1, VAR_2, VAR_4, VAR_3, VAR_8,
                VAR_3->frame.subframe2 + 3, OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1),
                VAR_3->frame.subframe1, VAR_3->frame.subframe2, VAR_9 );
    }
    else if ( ! VAR_26 )
    {
        opensafety_packet_sender ( VAR_0, VAR_1, VAR_2, VAR_4, VAR_3,
                OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1), VAR_3->frame.subframe1,
                VAR_3->frame.subframe2, -1 * ( ( OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1) ) ^
                        ( OSS_FRAME_ADDR_T2(VAR_0, VAR_3->frame.subframe2, VAR_3->scm_udid[0], VAR_3->scm_udid[1]) ) ) );
    }
    else if ( VAR_26 )
    {
        opensafety_packet_receiver ( VAR_0, VAR_1, VAR_2, VAR_4, VAR_3,
                OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1), VAR_3->frame.subframe1,
                VAR_3->frame.subframe2, -1 * ( ( OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1) ) ^
                        ( OSS_FRAME_ADDR_T2(VAR_0, VAR_3->frame.subframe2, VAR_3->scm_udid[0], VAR_3->scm_udid[1]) ) ) );
    }

    VAR_6 = opensafety_packet_payloadtree ( VAR_0, VAR_2, VAR_3, VAR_40 );

    opensafety_packet_response ( VAR_0, VAR_6, VAR_3, VAR_26 );

    VAR_3->payload.ssdo->sacmd.toggle = ( VAR_21 & VAR_41 ) == VAR_41;
    VAR_3->payload.ssdo->sacmd.abort_transfer = ( VAR_21 & VAR_42 ) == VAR_42;
    VAR_3->payload.ssdo->sacmd.preload = ( VAR_21 & VAR_43 ) == VAR_43;
    VAR_3->payload.ssdo->sacmd.read_access = ( VAR_21 & VAR_44 ) == VAR_44;
    VAR_3->payload.ssdo->sacmd.initiate = ( VAR_21 & VAR_45 ) == VAR_45;
    VAR_3->payload.ssdo->sacmd.segmented = ( VAR_21 & VAR_46 ) == VAR_46;
    VAR_3->payload.ssdo->sacmd.end_segment = ( VAR_21 & VAR_47 ) == VAR_47;

    if ( VAR_26 )
    {
        opensafety_packet_node ( VAR_0, VAR_1, VAR_6, VAR_48,
                OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1),
                VAR_3->frame.subframe1, VAR_3->frame.subframe2, VAR_9 );
        VAR_11 = OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1);

        if ( VAR_3->scm_udid_valid )
        {
            proto_tree_add_uint(VAR_6, VAR_49, VAR_0, VAR_3->frame.subframe2 + 3, 2, VAR_8);
            VAR_10 = VAR_8;
        }
    }
    else if ( ! VAR_26 )
    {
        proto_tree_add_uint(VAR_6, VAR_49, VAR_0, VAR_3->frame.subframe1, 2, OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1));
        VAR_10 = OSS_FRAME_ADDR_T(VAR_0, VAR_3->frame.subframe1);
        if ( VAR_3->scm_udid_valid )
        {
            opensafety_packet_node ( VAR_0, VAR_1, VAR_6, VAR_48,
                    VAR_8, VAR_3->frame.subframe2 + 3, VAR_3->frame.subframe2, VAR_9 );
            VAR_11 = VAR_8;
        }
    }

    /* COMMENT_2 */
    if ( VAR_3->payload.ssdo->sacmd.toggle )
        VAR_21 &= (~VAR_41);
    proto_tree_add_bitmask(VAR_6, VAR_0, VAR_20, VAR_50,
            VAR_51, VAR_30, VAR_52);

    col_append_fstr(VAR_1->cinfo, VAR_53, "", SACMD: %s"", val_to_str_const(VAR_21, VAR_54, "" ""));

    VAR_22 = VAR_20 + 1;

    VAR_13 = tvb_get_guint8(VAR_0, VAR_3->frame.subframe1 + 3);
    if ( VAR_3->scm_udid_valid )
    {
        VAR_13 = (guint16)((tvb_get_guint8(VAR_0, VAR_3->frame.subframe2 + 2) ^ VAR_3->scm_udid[2]) << 8);
        VAR_13 += (tvb_get_guint8(VAR_0, VAR_3->frame.subframe1 + 3));
    }

    proto_tree_add_uint(VAR_6, VAR_55, VAR_0, VAR_3->frame.subframe1 + 3, 1, VAR_13 );

    /* COMMENT_3 */
    if ( VAR_3->scm_udid_valid && VAR_3->payload.ssdo->sacmd.preload && VAR_26 )
    {
        /* COMMENT_4 */
        VAR_23 = ( (tvb_get_guint8(VAR_0, VAR_3->frame.subframe2 + 4) ^ VAR_3->scm_udid[4]) & 0xFC ) >> 2;

        if ( VAR_3->payload.ssdo->sacmd.initiate )
        {
            /* COMMENT_5 */
            proto_tree_add_uint_format_value(VAR_6, VAR_56, VAR_0, VAR_3->frame.subframe2 + 4, 1,
                    VAR_23 & 0x0F, ""%d"", VAR_23 & 0x0F );
        }
        else
        {
            /* COMMENT_6 */
            VAR_5 = proto_tree_add_item(VAR_6, VAR_57, VAR_0, VAR_3->frame.subframe2 + 4, 1, VAR_52 );
            if ( (VAR_23 & 0x30) == 0x30 )
                proto_item_append_text(VAR_5, "" (SOD Access Request Number is last successful)"" );
        }
    }

    /* COMMENT_7 */
    if ( VAR_3->payload.ssdo->sacmd.initiate && !VAR_3->payload.ssdo->sacmd.abort_transfer )
    {
        VAR_15 = tvb_get_letohs(VAR_0, VAR_20 + 1);
        VAR_16 = tvb_get_guint8(VAR_0, VAR_20 + 3);

        proto_tree_add_uint_format_value(VAR_6, VAR_58, VAR_0, VAR_20 + 1, 2,
                VAR_15, ""0x%04X (%s)"", VAR_15,
                val_to_str_ext_const(((guint32) (VAR_15 << 16)), &VAR_59, ""Unknown"") );
        col_append_fstr(VAR_1->cinfo, VAR_53, "" [%s"", val_to_str_ext_const(((guint32) (VAR_15 << 16)), &VAR_59, ""Unknown""));

        /* COMMENT_8 */
        if ( VAR_16 != 0x0 )
        {
            proto_tree_add_uint_format_value(VAR_6, VAR_60, VAR_0, VAR_20 + 3, 1,
                VAR_16, ""0x%02X (%s)"", VAR_16,
                val_to_str_ext_const(((guint32) (VAR_15 << 16) + VAR_16), &VAR_59, ""Unknown"") );
            col_append_fstr(VAR_1->cinfo, VAR_53, "" - %s"",
                    val_to_str_ext_const(((guint32) (VAR_15 << 16) + VAR_16), &VAR_59, ""Unknown""));
        }
        col_append_fstr(VAR_1->cinfo, VAR_53, ""%s"", ""]"" );
        VAR_22 += 3;
    }

    if ( VAR_3->payload.ssdo->sacmd.abort_transfer )
    {
        VAR_14 = tvb_get_letohl(VAR_0, VAR_3->frame.subframe1 + VAR_39 + 4);

        proto_tree_add_uint_format_value(VAR_6, VAR_61, VAR_0, VAR_3->frame.subframe1 + VAR_39 + 4, 4, VAR_14,
                ""0x%04X %04X - %s"", (guint16)(VAR_14 >> 16), (guint16)(VAR_14),
                val_to_str_ext_const(VAR_14, &VAR_62, ""Unknown""));
        col_append_fstr(VAR_1->cinfo, VAR_53, "" - %s"", val_to_str_ext_const(VAR_14, &VAR_62, ""Unknown""));


    } else {
        /* COMMENT_9 */
                                                                                               
                                                                                                 
        if ( ( VAR_3->payload.ssdo->sacmd.initiate || VAR_3->payload.ssdo->sacmd.segmented || VAR_3->payload.ssdo->sacmd.end_segment ) &&
             ( ( VAR_26 && !VAR_3->payload.ssdo->sacmd.read_access ) ||
                     ( !VAR_26 && VAR_3->payload.ssdo->sacmd.read_access ) ) )
        {
            VAR_27 = VAR_1->fragmented;
            if ( VAR_10 != 0 && VAR_11 != 0 )
                VAR_18 = (guint32)((((guint32)VAR_11) << 16 ) + VAR_10 );

            /* COMMENT_12 */
            if ( VAR_3->payload.ssdo->sacmd.segmented && VAR_3->payload.ssdo->sacmd.initiate )
            {

                VAR_22 += 4;

                /* COMMENT_13 */
                VAR_17 = tvb_get_letohl(VAR_0, VAR_22 - 4);

                VAR_25 = VAR_24 - (VAR_22 - VAR_20);

                VAR_5 = proto_tree_add_uint_format_value(VAR_6, VAR_63, VAR_0, VAR_22 - 4, 4,
                        VAR_17, ""%d octets total (%d octets in this frame)"", VAR_17, VAR_25);

                if ( VAR_18 != 0 && VAR_3->payload.ssdo->sacmd.segmented )
                {
                    VAR_1->fragmented = TRUE;
                    VAR_29 = fragment_add_seq_check(&VAR_64, VAR_0, VAR_22, VAR_1,
                                                      VAR_18, NULL, 0, VAR_25, TRUE );
                    fragment_add_seq_offset ( &VAR_64, VAR_1, VAR_18, NULL, VAR_13 );

                    if ( VAR_29 != NULL )
                    {
                        VAR_5 = proto_tree_add_bytes_format_value(VAR_6, VAR_65, VAR_0, 0, 0, NULL, ""Reassembled"" );
                        PROTO_ITEM_SET_GENERATED(VAR_5);

                        VAR_7 = proto_item_add_subtree(VAR_5, VAR_66);
                        process_reassembled_data(VAR_0, 0, VAR_1, ""Reassembled Message"", VAR_29, &VAR_67, NULL, VAR_7 );
                    }
                }

                if ( (gint) VAR_25 >= (gint) 0 )
                {
                    proto_tree_add_item(VAR_6, VAR_65, VAR_0, VAR_22, VAR_25, VAR_52 );
                } else {
                    expert_add_info_format(VAR_1, VAR_5, &VAR_68,
                                                ""Calculation for payload length yielded non-positive result [%d]"", (guint) VAR_25 );
                }
            }
            else
            {
                VAR_17 = VAR_24 - (VAR_22 - VAR_20);
                if ((gint)VAR_24 < (VAR_22 - VAR_20))
                {
                    expert_add_info_format(VAR_1, VAR_4, &VAR_68,
                                                    ""Calculation for payload length yielded non-positive result [%d]"", (gint)VAR_17 );
                    return;
                }

                if ( VAR_18 != 0 && VAR_3->payload.ssdo->sacmd.segmented )
                {
                    VAR_1->fragmented = TRUE;

                    VAR_29 = fragment_add_seq_check(&VAR_64, VAR_0, VAR_22, VAR_1,
                                                      VAR_18, NULL, VAR_13, VAR_17,
                                                      VAR_3->payload.ssdo->sacmd.end_segment ? FALSE : TRUE );
                }

                if ( VAR_29 )
                {
                    VAR_5 = proto_tree_add_bytes_format_value(VAR_6, VAR_65, VAR_0,
                                                             0, 0, NULL, ""Reassembled"" );
                    PROTO_ITEM_SET_GENERATED(VAR_5);
                    VAR_7 = proto_item_add_subtree(VAR_5, VAR_66);

                    VAR_28 = process_reassembled_data(VAR_0, 0, VAR_1, ""Reassembled Message"", VAR_29,
                                                       &VAR_67, NULL, VAR_7 );
                    if ( VAR_3->payload.ssdo->sacmd.end_segment && VAR_28 )
                    {
                        VAR_5 = proto_tree_add_uint_format_value(VAR_7, VAR_63, VAR_0, 0, 0,
                                                                VAR_17, ""%d octets (over all fragments)"", VAR_29->len);
                        PROTO_ITEM_SET_GENERATED(VAR_5);

                        col_append_str(VAR_1->cinfo, VAR_53, "" (Message Reassembled)"" );
                        dissect_opensafety_ssdo_payload ( VAR_1, VAR_28, VAR_7, VAR_21 );
                    }
                }
                else
                {
                    VAR_5 = proto_tree_add_uint_format_value(VAR_6, VAR_63, VAR_0, 0, 0, VAR_17,
                            ""%d octets"", VAR_17);
                    PROTO_ITEM_SET_GENERATED(VAR_5);

                    if ( VAR_15 == VAR_69 && VAR_16 == 0x06 )
                    {
                        VAR_19 = tvb_get_letohl ( VAR_0, VAR_22 );
                        proto_tree_add_uint_format_value ( VAR_6, VAR_70, VAR_0, VAR_22,
                                    4, VAR_19, ""0x%08X"", VAR_19 );
                        for ( VAR_12 = 4; VAR_12 < VAR_17; VAR_12+=4 )
                        {
                            VAR_19 = tvb_get_letohl ( VAR_0, VAR_22 + VAR_12 );
                            proto_tree_add_uint_format_value ( VAR_6, VAR_71, VAR_0, (VAR_22 + VAR_12 ),
                                    4, VAR_19, ""[#%d] 0x%08X"", ( VAR_12 / 4 ), VAR_19 );
                        }
                    } else if ( VAR_15 == VAR_69 && VAR_16 == 0x07 ) {
                        VAR_19 = tvb_get_letohl ( VAR_0, VAR_22 );
                        proto_tree_add_uint_format_value ( VAR_6, VAR_70, VAR_0, VAR_22,
                                    4, VAR_19, ""0x%08X"", VAR_19 );
                    } else
                        proto_tree_add_item(VAR_6, VAR_65, VAR_0, VAR_22, VAR_17, VAR_52 );
                }
            }

            VAR_1->fragmented = VAR_27;
        }
    }
}",wireshark/dbc7cb0bbdd501fa96e0cb98668f6d6bf17ac4e6/packet-opensafety.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -225,6 +225,12 @@
             else
             {
                 payloadSize = dataLength - (payloadOffset - db0Offset);
+                if ((gint)dataLength < (payloadOffset - db0Offset))
+                {
+                    expert_add_info_format(pinfo, opensafety_item, &ei_payload_length_not_positive,
+                                                    ""Calculation for payload length yielded non-positive result [%d]"", (gint)payloadSize );
+                    return;
+                }
 
                 if ( fragmentId != 0 && packet->payload.ssdo->sacmd.segmented )
                 {","{'deleted_lines': [], 'added_lines': ['                if ((gint)dataLength < (payloadOffset - db0Offset))', '                {', '                    expert_add_info_format(pinfo, opensafety_item, &ei_payload_length_not_positive,', '                                                    ""Calculation for payload length yielded non-positive result [%d]"", (gint)payloadSize );', '                    return;', '                }']}",True,"In Wireshark 2.2.0 to 2.2.6 and 2.0.0 to 2.0.12, the openSAFETY dissector could crash or exhaust system memory. This was addressed in epan/dissectors/packet-opensafety.c by checking for a negative length.",7.5,HIGH,2,test,2017-04-27T13:15:01Z,1
CVE-2017-8904,['CWE-Other'],AV:L/AC:L/Au:S/C:C/I:C/A:C,0,xen-project/xen,"x86: discard type information when stealing pages

While a page having just a single general reference left necessarily
has a zero type reference count too, its type may still be valid (and
in validated state; at present this is only possible and relevant for
PGT_seg_desc_page, as page tables have their type forcibly zapped when
their type reference count drops to zero, and
PGT_{writable,shared}_page pages don't require any validation). In
such a case when the page is being re-used with the same type again,
validation is being skipped. As validation criteria differ between
32- and 64-bit guests, pages to be transferred between guests need to
have their validation indicator zapped (and with it we zap all other
type information at once).

This is XSA-214.

Reported-by: Jann Horn <jannh@google.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>",eaf537342c909875c10f49b06e17493655410681,https://github.com/xen-project/xen/commit/eaf537342c909875c10f49b06e17493655410681,xen/arch/x86/mm.c,steal_page,"int steal_page(
struct domain *d, struct page_info *page, unsigned int memflags)
{
unsigned long x, y;
bool_t drop_dom_ref = 0;
const struct domain *owner = dom_xen;
spin_lock(&d->page_alloc_lock);
if ( is_xen_heap_page(page) || ((owner = page_get_owner(page)) != d) )
goto fail;
y = page->count_info;
do {
x = y;
if ( (x & (PGC_count_mask|PGC_allocated)) != (1 | PGC_allocated) )
goto fail;
y = cmpxchg(&page->count_info, x, x & ~PGC_count_mask);
} while ( y != x );
page_set_owner(page, NULL);
y = page->count_info;
do {
x = y;
BUG_ON((x & (PGC_count_mask|PGC_allocated)) != PGC_allocated);
} while ( (y = cmpxchg(&page->count_info, x, x | 1)) != x );
if ( !(memflags & MEMF_no_refcount) && !domain_adjust_tot_pages(d, -1) )
drop_dom_ref = 1;
page_list_del(page, &d->page_list);
spin_unlock(&d->page_alloc_lock);
if ( unlikely(drop_dom_ref) )
put_domain(d);
return 0;
fail:
spin_unlock(&d->page_alloc_lock);
gdprintk(XENLOG_WARNING, ""Bad steal mfn %"" PRI_mfn
"" from d%d (owner d%d) caf=%08lx taf=%"" PRtype_info ""\n"",
page_to_mfn(page), d->domain_id,
owner ? owner->domain_id : DOMID_INVALID,
page->count_info, page->u.inuse.type_info);
return -1;
}","int steal_page(
struct domain *VAR_0, struct page_info *VAR_1, unsigned int VAR_2)
{
unsigned long VAR_3, VAR_4;
bool_t VAR_5 = 0;
const struct domain *VAR_6 = VAR_7;
spin_lock(&VAR_0->page_alloc_lock);
if ( is_xen_heap_page(VAR_1) || ((VAR_6 = page_get_owner(VAR_1)) != VAR_0) )
goto fail;
VAR_4 = VAR_1->count_info;
do {
VAR_3 = VAR_4;
if ( (VAR_3 & (VAR_8|VAR_9)) != (1 | VAR_9) )
goto fail;
VAR_4 = cmpxchg(&VAR_1->count_info, VAR_3, VAR_3 & ~VAR_8);
} while ( VAR_4 != VAR_3 );
page_set_owner(VAR_1, NULL);
VAR_4 = VAR_1->count_info;
do {
VAR_3 = VAR_4;
BUG_ON((VAR_3 & (VAR_8|VAR_9)) != VAR_9);
} while ( (VAR_4 = cmpxchg(&VAR_1->count_info, VAR_3, VAR_3 | 1)) != VAR_3 );
if ( !(VAR_2 & VAR_10) && !domain_adjust_tot_pages(VAR_0, -1) )
VAR_5 = 1;
page_list_del(VAR_1, &VAR_0->page_list);
spin_unlock(&VAR_0->page_alloc_lock);
if ( unlikely(VAR_5) )
put_domain(VAR_0);
return 0;
fail:
spin_unlock(&VAR_0->page_alloc_lock);
gdprintk(VAR_11, ""Bad steal mfn %"" VAR_12
"" from d%d (owner d%d) caf=%08lx taf=%"" VAR_13 ""\n"",
page_to_mfn(VAR_1), VAR_0->domain_id,
VAR_6 ? VAR_6->domain_id : VAR_14,
VAR_1->count_info, VAR_1->u.inuse.type_info);
return -1;
}",xen-project/xen/eaf537342c909875c10f49b06e17493655410681/mm.c/vul/before/0.json,"int steal_page(
    struct domain *d, struct page_info *page, unsigned int memflags)
{
    unsigned long x, y;
    bool_t drop_dom_ref = 0;
    const struct domain *owner = dom_xen;

    spin_lock(&d->page_alloc_lock);

    if ( is_xen_heap_page(page) || ((owner = page_get_owner(page)) != d) )
        goto fail;

    /*
     * We require there is just one reference (PGC_allocated). We temporarily
     * drop this reference now so that we can safely swizzle the owner.
     */
    y = page->count_info;
    do {
        x = y;
        if ( (x & (PGC_count_mask|PGC_allocated)) != (1 | PGC_allocated) )
            goto fail;
        y = cmpxchg(&page->count_info, x, x & ~PGC_count_mask);
    } while ( y != x );

    /*
     * With the sole reference dropped temporarily, no-one can update type
     * information. Type count also needs to be zero in this case, but e.g.
     * PGT_seg_desc_page may still have PGT_validated set, which we need to
     * clear before transferring ownership (as validation criteria vary
     * depending on domain type).
     */
    BUG_ON(page->u.inuse.type_info & (PGT_count_mask | PGT_locked |
                                      PGT_pinned));
    page->u.inuse.type_info = 0;

    /* Swizzle the owner then reinstate the PGC_allocated reference. */
    page_set_owner(page, NULL);
    y = page->count_info;
    do {
        x = y;
        BUG_ON((x & (PGC_count_mask|PGC_allocated)) != PGC_allocated);
    } while ( (y = cmpxchg(&page->count_info, x, x | 1)) != x );

    /* Unlink from original owner. */
    if ( !(memflags & MEMF_no_refcount) && !domain_adjust_tot_pages(d, -1) )
        drop_dom_ref = 1;
    page_list_del(page, &d->page_list);

    spin_unlock(&d->page_alloc_lock);
    if ( unlikely(drop_dom_ref) )
        put_domain(d);
    return 0;

 fail:
    spin_unlock(&d->page_alloc_lock);
    gdprintk(XENLOG_WARNING, ""Bad steal mfn %"" PRI_mfn
             "" from d%d (owner d%d) caf=%08lx taf=%"" PRtype_info ""\n"",
             page_to_mfn(page), d->domain_id,
             owner ? owner->domain_id : DOMID_INVALID,
             page->count_info, page->u.inuse.type_info);
    return -1;
}","int steal_page(
    struct domain *VAR_0, struct page_info *VAR_1, unsigned int VAR_2)
{
    unsigned long VAR_3, VAR_4;
    bool_t VAR_5 = 0;
    const struct domain *VAR_6 = VAR_7;

    spin_lock(&VAR_0->page_alloc_lock);

    if ( is_xen_heap_page(VAR_1) || ((VAR_6 = page_get_owner(VAR_1)) != VAR_0) )
        goto fail;

    /* COMMENT_0 */
                                                                             
                                                                       
       
    VAR_4 = VAR_1->count_info;
    do {
        VAR_3 = VAR_4;
        if ( (VAR_3 & (VAR_8|VAR_9)) != (1 | VAR_9) )
            goto fail;
        VAR_4 = cmpxchg(&VAR_1->count_info, VAR_3, VAR_3 & ~VAR_8);
    } while ( VAR_4 != VAR_3 );

    /* COMMENT_4 */
                                                                          
                                                                           
                                                                           
                                                                       
                                 
       
    BUG_ON(VAR_1->u.inuse.type_info & (VAR_10 | VAR_11 |
                                      VAR_12));
    VAR_1->u.inuse.type_info = 0;

    /* COMMENT_11 */
    page_set_owner(VAR_1, NULL);
    VAR_4 = VAR_1->count_info;
    do {
        VAR_3 = VAR_4;
        BUG_ON((VAR_3 & (VAR_8|VAR_9)) != VAR_9);
    } while ( (VAR_4 = cmpxchg(&VAR_1->count_info, VAR_3, VAR_3 | 1)) != VAR_3 );

    /* COMMENT_12 */
    if ( !(VAR_2 & VAR_13) && !domain_adjust_tot_pages(VAR_0, -1) )
        VAR_5 = 1;
    page_list_del(VAR_1, &VAR_0->page_list);

    spin_unlock(&VAR_0->page_alloc_lock);
    if ( unlikely(VAR_5) )
        put_domain(VAR_0);
    return 0;

 fail:
    spin_unlock(&VAR_0->page_alloc_lock);
    gdprintk(VAR_14, ""Bad steal mfn %"" VAR_15
             "" from d%d (owner d%d) caf=%08lx taf=%"" VAR_16 ""\n"",
             page_to_mfn(VAR_1), VAR_0->domain_id,
             VAR_6 ? VAR_6->domain_id : VAR_17,
             VAR_1->count_info, VAR_1->u.inuse.type_info);
    return -1;
}",xen-project/xen/eaf537342c909875c10f49b06e17493655410681/mm.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -21,6 +21,17 @@
             goto fail;
         y = cmpxchg(&page->count_info, x, x & ~PGC_count_mask);
     } while ( y != x );
+
+    /*
+     * With the sole reference dropped temporarily, no-one can update type
+     * information. Type count also needs to be zero in this case, but e.g.
+     * PGT_seg_desc_page may still have PGT_validated set, which we need to
+     * clear before transferring ownership (as validation criteria vary
+     * depending on domain type).
+     */
+    BUG_ON(page->u.inuse.type_info & (PGT_count_mask | PGT_locked |
+                                      PGT_pinned));
+    page->u.inuse.type_info = 0;
 
     /* Swizzle the owner then reinstate the PGC_allocated reference. */
     page_set_owner(page, NULL);","{'deleted_lines': [], 'added_lines': ['', '    /*', '     * With the sole reference dropped temporarily, no-one can update type', '     * information. Type count also needs to be zero in this case, but e.g.', '     * PGT_seg_desc_page may still have PGT_validated set, which we need to', '     * clear before transferring ownership (as validation criteria vary', '     * depending on domain type).', '     */', '    BUG_ON(page->u.inuse.type_info & (PGT_count_mask | PGT_locked |', '                                      PGT_pinned));', '    page->u.inuse.type_info = 0;']}",True,"Xen through 4.8.x mishandles the ""contains segment descriptors"" property during GNTTABOP_transfer (aka guest transfer) operations, which might allow PV guest OS users to execute arbitrary code on the host OS, aka XSA-214.",8.8,HIGH,2,test,2017-05-02T12:46:58Z,1
CVE-2017-9345,['CWE-835'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,wireshark,"dns: improve loop detection in label decompression

Previously the number of allowed pointers within a message is equal to
the data in a tvb (16575 in one example). This is still expensive, so
implement an alternative detection mechanism that looks for a direct
self-loop and limits the total pointers to about 256.

Bug: 13633
Change-Id: I803873e24ab170c7ef0b881d3bdc9dfd4014de97
Link: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=1206
Reviewed-on: https://code.wireshark.org/review/21507
Petri-Dish: Peter Wu <peter@lekensteyn.nl>
Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
Reviewed-by: Martin Kaiser <wireshark@kaiser.cx>
Reviewed-by: Peter Wu <peter@lekensteyn.nl>
(cherry picked from commit 129bdb5a164a6386c35ff387e9d8f0d3d6a12dbf)
Reviewed-on: https://code.wireshark.org/review/21597",e280c9b637327a65d132bfe72d917b87e6844eb5,https://github.com/wireshark/wireshark/commit/e280c9b637327a65d132bfe72d917b87e6844eb5,epan/dissectors/packet-dns.c,expand_dns_name,"int
expand_dns_name(tvbuff_t *tvb, int offset, int max_len, int dns_data_offset,
const guchar **name)
{
int     start_offset    = offset;
guchar *np;
int     len             = -1;
int     chars_processed = 0;
int     data_size       = tvb_reported_length_remaining(tvb, dns_data_offset);
int     component_len;
int     indir_offset;
int     maxname;
const int min_len = 1;        
maxname=MAXDNAME;
np=(guchar *)wmem_alloc(wmem_packet_scope(), maxname);
*name=np;
maxname--;   
for (;;) {
if (max_len && offset - start_offset > max_len - 1) {
break;
}
component_len = tvb_get_guint8(tvb, offset);
offset++;
if (component_len == 0) {
break;
}
chars_processed++;
switch (component_len & 0xc0) {
case 0x00:
if (np != *name) {
if (maxname > 0) {
*np++ = '.';
maxname--;
}
}
while (component_len > 0) {
if (max_len && offset - start_offset > max_len - 1) {
THROW(ReportedBoundsError);
}
if (maxname > 0) {
*np++ = tvb_get_guint8(tvb, offset);
maxname--;
}
component_len--;
offset++;
chars_processed++;
}
break;
case 0x40:
switch (component_len & 0x3f) {
case 0x01:
{
int bit_count;
int label_len;
int print_len;
bit_count = tvb_get_guint8(tvb, offset);
offset++;
label_len = (bit_count - 1) / 8 + 1;
if (maxname > 0) {
print_len = g_snprintf(np, maxname + 1, ""\\[x"");
if (print_len <= maxname) {
np      += print_len;
maxname -= print_len;
} else {
maxname = 0;
}
}
while (label_len--) {
if (maxname > 0) {
print_len = g_snprintf(np, maxname + 1, ""%02x"",
tvb_get_guint8(tvb, offset));
if (print_len <= maxname) {
np      += print_len;
maxname -= print_len;
} else {
maxname = 0;
}
}
offset++;
}
if (maxname > 0) {
print_len = g_snprintf(np, maxname + 1, ""/%d]"", bit_count);
if (print_len <= maxname) {
np      += print_len;
maxname -= print_len;
} else {
maxname = 0;
}
}
}
break;
default:
*name=""<Unknown extended label>"";
len = offset - start_offset;
if (len < min_len) {
THROW(ReportedBoundsError);
}
return len;
}
break;
case 0x80:
THROW(ReportedBoundsError);
break;
case 0xc0:
indir_offset = dns_data_offset +
(((component_len & ~0xc0) << 8) | tvb_get_guint8(tvb, offset));
offset++;
chars_processed++;
if (len < 0) {
len = offset - start_offset;
}
if (chars_processed >= data_size) {
*name=""<Name contains a pointer that loops>"";
if (len < min_len) {
THROW(ReportedBoundsError);
}
return len;
}
offset = indir_offset;
break;   
}
}
*np = '\0';
if (len < 0) {
len = offset - start_offset;
}
if (len < min_len) {
THROW(ReportedBoundsError);
}
return len;
}","int
expand_dns_name(tvbuff_t *VAR_0, int VAR_1, int VAR_2, int VAR_3,
const guchar **VAR_4)
{
int     VAR_5    = VAR_1;
guchar *VAR_6;
int     VAR_7             = -1;
int     VAR_8 = 0;
int     VAR_9       = tvb_reported_length_remaining(VAR_0, VAR_3);
int     VAR_10;
int     VAR_11;
int     VAR_12;
const int VAR_13 = 1;        
VAR_12=VAR_14;
VAR_6=(guchar *)wmem_alloc(wmem_packet_scope(), VAR_12);
*VAR_4=VAR_6;
VAR_12--;   
for (;;) {
if (VAR_2 && VAR_1 - VAR_5 > VAR_2 - 1) {
break;
}
VAR_10 = tvb_get_guint8(VAR_0, VAR_1);
VAR_1++;
if (VAR_10 == 0) {
break;
}
VAR_8++;
switch (VAR_10 & 0xc0) {
case 0x00:
if (VAR_6 != *VAR_4) {
if (VAR_12 > 0) {
*VAR_6++ = '.';
VAR_12--;
}
}
while (VAR_10 > 0) {
if (VAR_2 && VAR_1 - VAR_5 > VAR_2 - 1) {
THROW(VAR_15);
}
if (VAR_12 > 0) {
*VAR_6++ = tvb_get_guint8(VAR_0, VAR_1);
VAR_12--;
}
VAR_10--;
VAR_1++;
VAR_8++;
}
break;
case 0x40:
switch (VAR_10 & 0x3f) {
case 0x01:
{
int VAR_16;
int VAR_17;
int VAR_18;
VAR_16 = tvb_get_guint8(VAR_0, VAR_1);
VAR_1++;
VAR_17 = (VAR_16 - 1) / 8 + 1;
if (VAR_12 > 0) {
VAR_18 = g_snprintf(VAR_6, VAR_12 + 1, ""\\[x"");
if (VAR_18 <= VAR_12) {
VAR_6      += VAR_18;
VAR_12 -= VAR_18;
} else {
VAR_12 = 0;
}
}
while (VAR_17--) {
if (VAR_12 > 0) {
VAR_18 = g_snprintf(VAR_6, VAR_12 + 1, ""%02x"",
tvb_get_guint8(VAR_0, VAR_1));
if (VAR_18 <= VAR_12) {
VAR_6      += VAR_18;
VAR_12 -= VAR_18;
} else {
VAR_12 = 0;
}
}
VAR_1++;
}
if (VAR_12 > 0) {
VAR_18 = g_snprintf(VAR_6, VAR_12 + 1, ""/%d]"", VAR_16);
if (VAR_18 <= VAR_12) {
VAR_6      += VAR_18;
VAR_12 -= VAR_18;
} else {
VAR_12 = 0;
}
}
}
break;
default:
*VAR_4=""<Unknown extended label>"";
VAR_7 = VAR_1 - VAR_5;
if (VAR_7 < VAR_13) {
THROW(VAR_15);
}
return VAR_7;
}
break;
case 0x80:
THROW(VAR_15);
break;
case 0xc0:
VAR_11 = VAR_3 +
(((VAR_10 & ~0xc0) << 8) | tvb_get_guint8(VAR_0, VAR_1));
VAR_1++;
VAR_8++;
if (VAR_7 < 0) {
VAR_7 = VAR_1 - VAR_5;
}
if (VAR_8 >= VAR_9) {
*VAR_4=""<Name contains a pointer that loops>"";
if (VAR_7 < VAR_13) {
THROW(VAR_15);
}
return VAR_7;
}
VAR_1 = VAR_11;
break;   
}
}
*VAR_6 = '\0';
if (VAR_7 < 0) {
VAR_7 = VAR_1 - VAR_5;
}
if (VAR_7 < VAR_13) {
THROW(VAR_15);
}
return VAR_7;
}",wireshark/e280c9b637327a65d132bfe72d917b87e6844eb5/packet-dns.c/vul/before/0.json,"int
expand_dns_name(tvbuff_t *tvb, int offset, int max_len, int dns_data_offset,
    const guchar **name)
{
  int     start_offset    = offset;
  guchar *np;
  int     len             = -1;
  int     pointers_count  = 0;
  int     component_len;
  int     indir_offset;
  int     maxname;

  const int min_len = 1;        /* Minimum length of encoded name (for root) */
        /* If we're about to return a value (probably negative) which is less
         * than the minimum length, we're looking at bad data and we're liable
         * to put the dissector into a loop.  Instead we throw an exception */

  maxname=MAXDNAME;
  np=(guchar *)wmem_alloc(wmem_packet_scope(), maxname);
  *name=np;

  maxname--;   /* reserve space for the trailing '\0' */
  for (;;) {
    if (max_len && offset - start_offset > max_len - 1) {
      break;
    }
    component_len = tvb_get_guint8(tvb, offset);
    offset++;
    if (component_len == 0) {
      break;
    }
    switch (component_len & 0xc0) {

      case 0x00:
        /* Label */
        if (np != *name) {
          /* Not the first component - put in a '.'. */
          if (maxname > 0) {
            *np++ = '.';
            maxname--;
          }
        }
        while (component_len > 0) {
          if (max_len && offset - start_offset > max_len - 1) {
            THROW(ReportedBoundsError);
          }
          if (maxname > 0) {
            *np++ = tvb_get_guint8(tvb, offset);
            maxname--;
          }
          component_len--;
          offset++;
        }
        break;

      case 0x40:
        /* Extended label (RFC 2673) */
        switch (component_len & 0x3f) {

          case 0x01:
            /* Bitstring label */
          {
            int bit_count;
            int label_len;
            int print_len;

            bit_count = tvb_get_guint8(tvb, offset);
            offset++;
            label_len = (bit_count - 1) / 8 + 1;

            if (maxname > 0) {
              print_len = g_snprintf(np, maxname + 1, ""\\[x"");
              if (print_len <= maxname) {
                np      += print_len;
                maxname -= print_len;
              } else {
                /* Nothing printed, as there's no room.
                   Suppress all subsequent printing. */
                maxname = 0;
              }
            }
            while (label_len--) {
              if (maxname > 0) {
                print_len = g_snprintf(np, maxname + 1, ""%02x"",
                                       tvb_get_guint8(tvb, offset));
                if (print_len <= maxname) {
                  np      += print_len;
                  maxname -= print_len;
                } else {
                  /* Nothing printed, as there's no room.
                     Suppress all subsequent printing. */
                  maxname = 0;
                }
              }
              offset++;
            }
            if (maxname > 0) {
              print_len = g_snprintf(np, maxname + 1, ""/%d]"", bit_count);
              if (print_len <= maxname) {
                np      += print_len;
                maxname -= print_len;
              } else {
                /* Nothing printed, as there's no room.
                   Suppress all subsequent printing. */
                maxname = 0;
              }
            }
          }
          break;

          default:
            *name=""<Unknown extended label>"";
            /* Parsing will probably fail from here on, since the */
            /* label length is unknown... */
            len = offset - start_offset;
            if (len < min_len) {
              THROW(ReportedBoundsError);
            }
            return len;
        }
        break;

      case 0x80:
        THROW(ReportedBoundsError);
        break;

      case 0xc0:
        /* Pointer. */
        indir_offset = dns_data_offset +
          (((component_len & ~0xc0) << 8) | tvb_get_guint8(tvb, offset));
        offset++;
        pointers_count++;

        /* If ""len"" is negative, we are still working on the original name,
           not something pointed to by a pointer, and so we should set ""len""
           to the length of the original name. */
        if (len < 0) {
          len = offset - start_offset;
        }
        /*
         * If we find a pointer to itself, it is a trivial loop. Otherwise if we
         * processed a large number of pointers, assume an indirect loop.
         */
        if (indir_offset == offset + 2 || pointers_count > MAXDNAME/4) {
          *name=""<Name contains a pointer that loops>"";
          if (len < min_len) {
            THROW(ReportedBoundsError);
          }
          return len;
        }

        offset = indir_offset;
        break;   /* now continue processing from there */
    }
  }

  *np = '\0';
  /* If ""len"" is negative, we haven't seen a pointer, and thus haven't
     set the length, so set it. */
  if (len < 0) {
    len = offset - start_offset;
  }
  if (len < min_len) {
    THROW(ReportedBoundsError);
  }
  return len;
}","int
expand_dns_name(tvbuff_t *VAR_0, int VAR_1, int VAR_2, int VAR_3,
    const guchar **VAR_4)
{
  int     VAR_5    = VAR_1;
  guchar *VAR_6;
  int     VAR_7             = -1;
  int     VAR_8  = 0;
  int     VAR_9;
  int     VAR_10;
  int     VAR_11;

  const int VAR_12 = 1;        /* COMMENT_0 */
        /* COMMENT_1 */
                                                                              
                                                                              

  VAR_11=VAR_13;
  VAR_6=(guchar *)wmem_alloc(wmem_packet_scope(), VAR_11);
  *VAR_4=VAR_6;

  VAR_11--;   /* COMMENT_4 */
  for (;;) {
    if (VAR_2 && VAR_1 - VAR_5 > VAR_2 - 1) {
      break;
    }
    VAR_9 = tvb_get_guint8(VAR_0, VAR_1);
    VAR_1++;
    if (VAR_9 == 0) {
      break;
    }
    switch (VAR_9 & 0xc0) {

      case 0x00:
        /* COMMENT_5 */
        if (VAR_6 != *VAR_4) {
          /* COMMENT_6 */
          if (VAR_11 > 0) {
            *VAR_6++ = '.';
            VAR_11--;
          }
        }
        while (VAR_9 > 0) {
          if (VAR_2 && VAR_1 - VAR_5 > VAR_2 - 1) {
            THROW(VAR_14);
          }
          if (VAR_11 > 0) {
            *VAR_6++ = tvb_get_guint8(VAR_0, VAR_1);
            VAR_11--;
          }
          VAR_9--;
          VAR_1++;
        }
        break;

      case 0x40:
        /* COMMENT_7 */
        switch (VAR_9 & 0x3f) {

          case 0x01:
            /* COMMENT_8 */
          {
            int VAR_15;
            int VAR_16;
            int VAR_17;

            VAR_15 = tvb_get_guint8(VAR_0, VAR_1);
            VAR_1++;
            VAR_16 = (VAR_15 - 1) / 8 + 1;

            if (VAR_11 > 0) {
              VAR_17 = g_snprintf(VAR_6, VAR_11 + 1, ""\\[x"");
              if (VAR_17 <= VAR_11) {
                VAR_6      += VAR_17;
                VAR_11 -= VAR_17;
              } else {
                /* COMMENT_9 */
                                                       
                VAR_11 = 0;
              }
            }
            while (VAR_16--) {
              if (VAR_11 > 0) {
                VAR_17 = g_snprintf(VAR_6, VAR_11 + 1, ""%02x"",
                                       tvb_get_guint8(VAR_0, VAR_1));
                if (VAR_17 <= VAR_11) {
                  VAR_6      += VAR_17;
                  VAR_11 -= VAR_17;
                } else {
                  /* COMMENT_11 */
                                                         
                  VAR_11 = 0;
                }
              }
              VAR_1++;
            }
            if (VAR_11 > 0) {
              VAR_17 = g_snprintf(VAR_6, VAR_11 + 1, ""/%d]"", VAR_15);
              if (VAR_17 <= VAR_11) {
                VAR_6      += VAR_17;
                VAR_11 -= VAR_17;
              } else {
                /* COMMENT_13 */
                                                       
                VAR_11 = 0;
              }
            }
          }
          break;

          default:
            *VAR_4=""<Unknown extended label>"";
            /* COMMENT_15 */
            /* COMMENT_16 */
            VAR_7 = VAR_1 - VAR_5;
            if (VAR_7 < VAR_12) {
              THROW(VAR_14);
            }
            return VAR_7;
        }
        break;

      case 0x80:
        THROW(VAR_14);
        break;

      case 0xc0:
        /* COMMENT_17 */
        VAR_10 = VAR_3 +
          (((VAR_9 & ~0xc0) << 8) | tvb_get_guint8(VAR_0, VAR_1));
        VAR_1++;
        VAR_8++;

        /* COMMENT_18 */
                                                                            
                                                 
        if (VAR_7 < 0) {
          VAR_7 = VAR_1 - VAR_5;
        }
        /* COMMENT_21 */
                                                                                
                                                                         
           
        if (VAR_10 == VAR_1 + 2 || VAR_8 > VAR_13/4) {
          *VAR_4=""<Name contains a pointer that loops>"";
          if (VAR_7 < VAR_12) {
            THROW(VAR_14);
          }
          return VAR_7;
        }

        VAR_1 = VAR_10;
        break;   /* COMMENT_25 */
    }
  }

  *VAR_6 = '\0';
  /* COMMENT_26 */
                                  
  if (VAR_7 < 0) {
    VAR_7 = VAR_1 - VAR_5;
  }
  if (VAR_7 < VAR_12) {
    THROW(VAR_14);
  }
  return VAR_7;
}",wireshark/e280c9b637327a65d132bfe72d917b87e6844eb5/packet-dns.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,8 +5,7 @@
   int     start_offset    = offset;
   guchar *np;
   int     len             = -1;
-  int     chars_processed = 0;
-  int     data_size       = tvb_reported_length_remaining(tvb, dns_data_offset);
+  int     pointers_count  = 0;
   int     component_len;
   int     indir_offset;
   int     maxname;
@@ -30,7 +29,6 @@
     if (component_len == 0) {
       break;
     }
-    chars_processed++;
     switch (component_len & 0xc0) {
 
       case 0x00:
@@ -52,7 +50,6 @@
           }
           component_len--;
           offset++;
-          chars_processed++;
         }
         break;
 
@@ -132,7 +129,7 @@
         indir_offset = dns_data_offset +
           (((component_len & ~0xc0) << 8) | tvb_get_guint8(tvb, offset));
         offset++;
-        chars_processed++;
+        pointers_count++;
 
         /* If ""len"" is negative, we are still working on the original name,
            not something pointed to by a pointer, and so we should set ""len""
@@ -140,10 +137,11 @@
         if (len < 0) {
           len = offset - start_offset;
         }
-        /* If we've looked at every character in the message, this pointer
-           will make us look at some character again, which means we're
-           looping. */
-        if (chars_processed >= data_size) {
+        /*
+         * If we find a pointer to itself, it is a trivial loop. Otherwise if we
+         * processed a large number of pointers, assume an indirect loop.
+         */
+        if (indir_offset == offset + 2 || pointers_count > MAXDNAME/4) {
           *name=""<Name contains a pointer that loops>"";
           if (len < min_len) {
             THROW(ReportedBoundsError);","{'deleted_lines': ['  int     chars_processed = 0;', '  int     data_size       = tvb_reported_length_remaining(tvb, dns_data_offset);', '    chars_processed++;', '          chars_processed++;', '        chars_processed++;', ""        /* If we've looked at every character in the message, this pointer"", ""           will make us look at some character again, which means we're"", '           looping. */', '        if (chars_processed >= data_size) {'], 'added_lines': ['  int     pointers_count  = 0;', '        pointers_count++;', '        /*', '         * If we find a pointer to itself, it is a trivial loop. Otherwise if we', '         * processed a large number of pointers, assume an indirect loop.', '         */', '        if (indir_offset == offset + 2 || pointers_count > MAXDNAME/4) {']}",True,"In Wireshark 2.2.0 to 2.2.6 and 2.0.0 to 2.0.12, the DNS dissector could go into an infinite loop. This was addressed in epan/dissectors/packet-dns.c by trying to detect self-referencing pointers.",7.5,HIGH,2,test,2017-05-05T09:46:07Z,1
CVE-2017-10663,['CWE-129'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"f2fs: sanity check checkpoint segno and blkoff

Make sure segno and blkoff read from raw image are valid.

Cc: stable@vger.kernel.org
Signed-off-by: Jin Qian <jinqian@google.com>
[Jaegeuk Kim: adjust minor coding style]
Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",15d3042a937c13f5d9244241c7a9c8416ff6e82a,https://github.com/torvalds/linux/commit/15d3042a937c13f5d9244241c7a9c8416ff6e82a,fs/f2fs/super.c,sanity_check_ckpt,"int sanity_check_ckpt(struct f2fs_sb_info *sbi)
{
unsigned int total, fsmeta;
struct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);
struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
unsigned int ovp_segments, reserved_segments;
total = le32_to_cpu(raw_super->segment_count);
fsmeta = le32_to_cpu(raw_super->segment_count_ckpt);
fsmeta += le32_to_cpu(raw_super->segment_count_sit);
fsmeta += le32_to_cpu(raw_super->segment_count_nat);
fsmeta += le32_to_cpu(ckpt->rsvd_segment_count);
fsmeta += le32_to_cpu(raw_super->segment_count_ssa);
if (unlikely(fsmeta >= total))
return 1;
ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);
reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);
if (unlikely(fsmeta < F2FS_MIN_SEGMENTS ||
ovp_segments == 0 || reserved_segments == 0)) {
f2fs_msg(sbi->sb, KERN_ERR,
""Wrong layout: check mkfs.f2fs version"");
return 1;
}
if (unlikely(f2fs_cp_error(sbi))) {
f2fs_msg(sbi->sb, KERN_ERR, ""A bug case: need to run fsck"");
return 1;
}
return 0;
}","int sanity_check_ckpt(struct f2fs_sb_info *VAR_0)
{
unsigned int VAR_1, VAR_2;
struct f2fs_super_block *VAR_3 = F2FS_RAW_SUPER(VAR_0);
struct f2fs_checkpoint *VAR_4 = F2FS_CKPT(VAR_0);
unsigned int VAR_5, VAR_6;
VAR_1 = le32_to_cpu(VAR_3->segment_count);
VAR_2 = le32_to_cpu(VAR_3->segment_count_ckpt);
VAR_2 += le32_to_cpu(VAR_3->segment_count_sit);
VAR_2 += le32_to_cpu(VAR_3->segment_count_nat);
VAR_2 += le32_to_cpu(VAR_4->rsvd_segment_count);
VAR_2 += le32_to_cpu(VAR_3->segment_count_ssa);
if (unlikely(VAR_2 >= VAR_1))
return 1;
VAR_5 = le32_to_cpu(VAR_4->overprov_segment_count);
VAR_6 = le32_to_cpu(VAR_4->rsvd_segment_count);
if (unlikely(VAR_2 < VAR_7 ||
VAR_5 == 0 || VAR_6 == 0)) {
f2fs_msg(VAR_0->sb, VAR_8,
""Wrong layout: check mkfs.f2fs version"");
return 1;
}
if (unlikely(f2fs_cp_error(VAR_0))) {
f2fs_msg(VAR_0->sb, VAR_8, ""A bug case: need to run fsck"");
return 1;
}
return 0;
}",torvalds/linux/15d3042a937c13f5d9244241c7a9c8416ff6e82a/super.c/vul/before/0.json,"int sanity_check_ckpt(struct f2fs_sb_info *sbi)
{
	unsigned int total, fsmeta;
	struct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);
	struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
	unsigned int ovp_segments, reserved_segments;
	unsigned int main_segs, blocks_per_seg;
	int i;

	total = le32_to_cpu(raw_super->segment_count);
	fsmeta = le32_to_cpu(raw_super->segment_count_ckpt);
	fsmeta += le32_to_cpu(raw_super->segment_count_sit);
	fsmeta += le32_to_cpu(raw_super->segment_count_nat);
	fsmeta += le32_to_cpu(ckpt->rsvd_segment_count);
	fsmeta += le32_to_cpu(raw_super->segment_count_ssa);

	if (unlikely(fsmeta >= total))
		return 1;

	ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);
	reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);

	if (unlikely(fsmeta < F2FS_MIN_SEGMENTS ||
			ovp_segments == 0 || reserved_segments == 0)) {
		f2fs_msg(sbi->sb, KERN_ERR,
			""Wrong layout: check mkfs.f2fs version"");
		return 1;
	}

	main_segs = le32_to_cpu(raw_super->segment_count_main);
	blocks_per_seg = sbi->blocks_per_seg;

	for (i = 0; i < NR_CURSEG_NODE_TYPE; i++) {
		if (le32_to_cpu(ckpt->cur_node_segno[i]) >= main_segs ||
			le16_to_cpu(ckpt->cur_node_blkoff[i]) >= blocks_per_seg)
			return 1;
	}
	for (i = 0; i < NR_CURSEG_DATA_TYPE; i++) {
		if (le32_to_cpu(ckpt->cur_data_segno[i]) >= main_segs ||
			le16_to_cpu(ckpt->cur_data_blkoff[i]) >= blocks_per_seg)
			return 1;
	}

	if (unlikely(f2fs_cp_error(sbi))) {
		f2fs_msg(sbi->sb, KERN_ERR, ""A bug case: need to run fsck"");
		return 1;
	}
	return 0;
}","int sanity_check_ckpt(struct f2fs_sb_info *VAR_0)
{
	unsigned int VAR_1, VAR_2;
	struct f2fs_super_block *VAR_3 = F2FS_RAW_SUPER(VAR_0);
	struct f2fs_checkpoint *VAR_4 = F2FS_CKPT(VAR_0);
	unsigned int VAR_5, VAR_6;
	unsigned int VAR_7, VAR_8;
	int VAR_9;

	VAR_1 = le32_to_cpu(VAR_3->segment_count);
	VAR_2 = le32_to_cpu(VAR_3->segment_count_ckpt);
	VAR_2 += le32_to_cpu(VAR_3->segment_count_sit);
	VAR_2 += le32_to_cpu(VAR_3->segment_count_nat);
	VAR_2 += le32_to_cpu(VAR_4->rsvd_segment_count);
	VAR_2 += le32_to_cpu(VAR_3->segment_count_ssa);

	if (unlikely(VAR_2 >= VAR_1))
		return 1;

	VAR_5 = le32_to_cpu(VAR_4->overprov_segment_count);
	VAR_6 = le32_to_cpu(VAR_4->rsvd_segment_count);

	if (unlikely(VAR_2 < VAR_10 ||
			VAR_5 == 0 || VAR_6 == 0)) {
		f2fs_msg(VAR_0->sb, VAR_11,
			""Wrong layout: check mkfs.f2fs version"");
		return 1;
	}

	VAR_7 = le32_to_cpu(VAR_3->segment_count_main);
	VAR_8 = VAR_0->blocks_per_seg;

	for (VAR_9 = 0; VAR_9 < VAR_12; VAR_9++) {
		if (le32_to_cpu(VAR_4->cur_node_segno[VAR_9]) >= VAR_7 ||
			le16_to_cpu(VAR_4->cur_node_blkoff[VAR_9]) >= VAR_8)
			return 1;
	}
	for (VAR_9 = 0; VAR_9 < VAR_13; VAR_9++) {
		if (le32_to_cpu(VAR_4->cur_data_segno[VAR_9]) >= VAR_7 ||
			le16_to_cpu(VAR_4->cur_data_blkoff[VAR_9]) >= VAR_8)
			return 1;
	}

	if (unlikely(f2fs_cp_error(VAR_0))) {
		f2fs_msg(VAR_0->sb, VAR_11, ""A bug case: need to run fsck"");
		return 1;
	}
	return 0;
}",torvalds/linux/15d3042a937c13f5d9244241c7a9c8416ff6e82a/super.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,6 +4,8 @@
 	struct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);
 	struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
 	unsigned int ovp_segments, reserved_segments;
+	unsigned int main_segs, blocks_per_seg;
+	int i;
 
 	total = le32_to_cpu(raw_super->segment_count);
 	fsmeta = le32_to_cpu(raw_super->segment_count_ckpt);
@@ -25,6 +27,20 @@
 		return 1;
 	}
 
+	main_segs = le32_to_cpu(raw_super->segment_count_main);
+	blocks_per_seg = sbi->blocks_per_seg;
+
+	for (i = 0; i < NR_CURSEG_NODE_TYPE; i++) {
+		if (le32_to_cpu(ckpt->cur_node_segno[i]) >= main_segs ||
+			le16_to_cpu(ckpt->cur_node_blkoff[i]) >= blocks_per_seg)
+			return 1;
+	}
+	for (i = 0; i < NR_CURSEG_DATA_TYPE; i++) {
+		if (le32_to_cpu(ckpt->cur_data_segno[i]) >= main_segs ||
+			le16_to_cpu(ckpt->cur_data_blkoff[i]) >= blocks_per_seg)
+			return 1;
+	}
+
 	if (unlikely(f2fs_cp_error(sbi))) {
 		f2fs_msg(sbi->sb, KERN_ERR, ""A bug case: need to run fsck"");
 		return 1;","{'deleted_lines': [], 'added_lines': ['\tunsigned int main_segs, blocks_per_seg;', '\tint i;', '\tmain_segs = le32_to_cpu(raw_super->segment_count_main);', '\tblocks_per_seg = sbi->blocks_per_seg;', '', '\tfor (i = 0; i < NR_CURSEG_NODE_TYPE; i++) {', '\t\tif (le32_to_cpu(ckpt->cur_node_segno[i]) >= main_segs ||', '\t\t\tle16_to_cpu(ckpt->cur_node_blkoff[i]) >= blocks_per_seg)', '\t\t\treturn 1;', '\t}', '\tfor (i = 0; i < NR_CURSEG_DATA_TYPE; i++) {', '\t\tif (le32_to_cpu(ckpt->cur_data_segno[i]) >= main_segs ||', '\t\t\tle16_to_cpu(ckpt->cur_data_blkoff[i]) >= blocks_per_seg)', '\t\t\treturn 1;', '\t}', '']}",True,"The sanity_check_ckpt function in fs/f2fs/super.c in the Linux kernel before 4.12.4 does not validate the blkoff and segno arrays, which allows local users to gain privileges via unspecified vectors.",7.8,HIGH,2,test,2017-05-15T17:45:08Z,1
CVE-2017-9074,['CWE-125'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"ipv6: Prevent overrun when parsing v6 header options

The KASAN warning repoted below was discovered with a syzkaller
program.  The reproducer is basically:
  int s = socket(AF_INET6, SOCK_RAW, NEXTHDR_HOP);
  send(s, &one_byte_of_data, 1, MSG_MORE);
  send(s, &more_than_mtu_bytes_data, 2000, 0);

The socket() call sets the nexthdr field of the v6 header to
NEXTHDR_HOP, the first send call primes the payload with a non zero
byte of data, and the second send call triggers the fragmentation path.

The fragmentation code tries to parse the header options in order
to figure out where to insert the fragment option.  Since nexthdr points
to an invalid option, the calculation of the size of the network header
can made to be much larger than the linear section of the skb and data
is read outside of it.

This fix makes ip6_find_1stfrag return an error if it detects
running out-of-bounds.

[   42.361487] ==================================================================
[   42.364412] BUG: KASAN: slab-out-of-bounds in ip6_fragment+0x11c8/0x3730
[   42.365471] Read of size 840 at addr ffff88000969e798 by task ip6_fragment-oo/3789
[   42.366469]
[   42.366696] CPU: 1 PID: 3789 Comm: ip6_fragment-oo Not tainted 4.11.0+ #41
[   42.367628] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.1-1ubuntu1 04/01/2014
[   42.368824] Call Trace:
[   42.369183]  dump_stack+0xb3/0x10b
[   42.369664]  print_address_description+0x73/0x290
[   42.370325]  kasan_report+0x252/0x370
[   42.370839]  ? ip6_fragment+0x11c8/0x3730
[   42.371396]  check_memory_region+0x13c/0x1a0
[   42.371978]  memcpy+0x23/0x50
[   42.372395]  ip6_fragment+0x11c8/0x3730
[   42.372920]  ? nf_ct_expect_unregister_notifier+0x110/0x110
[   42.373681]  ? ip6_copy_metadata+0x7f0/0x7f0
[   42.374263]  ? ip6_forward+0x2e30/0x2e30
[   42.374803]  ip6_finish_output+0x584/0x990
[   42.375350]  ip6_output+0x1b7/0x690
[   42.375836]  ? ip6_finish_output+0x990/0x990
[   42.376411]  ? ip6_fragment+0x3730/0x3730
[   42.376968]  ip6_local_out+0x95/0x160
[   42.377471]  ip6_send_skb+0xa1/0x330
[   42.377969]  ip6_push_pending_frames+0xb3/0xe0
[   42.378589]  rawv6_sendmsg+0x2051/0x2db0
[   42.379129]  ? rawv6_bind+0x8b0/0x8b0
[   42.379633]  ? _copy_from_user+0x84/0xe0
[   42.380193]  ? debug_check_no_locks_freed+0x290/0x290
[   42.380878]  ? ___sys_sendmsg+0x162/0x930
[   42.381427]  ? rcu_read_lock_sched_held+0xa3/0x120
[   42.382074]  ? sock_has_perm+0x1f6/0x290
[   42.382614]  ? ___sys_sendmsg+0x167/0x930
[   42.383173]  ? lock_downgrade+0x660/0x660
[   42.383727]  inet_sendmsg+0x123/0x500
[   42.384226]  ? inet_sendmsg+0x123/0x500
[   42.384748]  ? inet_recvmsg+0x540/0x540
[   42.385263]  sock_sendmsg+0xca/0x110
[   42.385758]  SYSC_sendto+0x217/0x380
[   42.386249]  ? SYSC_connect+0x310/0x310
[   42.386783]  ? __might_fault+0x110/0x1d0
[   42.387324]  ? lock_downgrade+0x660/0x660
[   42.387880]  ? __fget_light+0xa1/0x1f0
[   42.388403]  ? __fdget+0x18/0x20
[   42.388851]  ? sock_common_setsockopt+0x95/0xd0
[   42.389472]  ? SyS_setsockopt+0x17f/0x260
[   42.390021]  ? entry_SYSCALL_64_fastpath+0x5/0xbe
[   42.390650]  SyS_sendto+0x40/0x50
[   42.391103]  entry_SYSCALL_64_fastpath+0x1f/0xbe
[   42.391731] RIP: 0033:0x7fbbb711e383
[   42.392217] RSP: 002b:00007ffff4d34f28 EFLAGS: 00000246 ORIG_RAX: 000000000000002c
[   42.393235] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fbbb711e383
[   42.394195] RDX: 0000000000001000 RSI: 00007ffff4d34f60 RDI: 0000000000000003
[   42.395145] RBP: 0000000000000046 R08: 00007ffff4d34f40 R09: 0000000000000018
[   42.396056] R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000400aad
[   42.396598] R13: 0000000000000066 R14: 00007ffff4d34ee0 R15: 00007fbbb717af00
[   42.397257]
[   42.397411] Allocated by task 3789:
[   42.397702]  save_stack_trace+0x16/0x20
[   42.398005]  save_stack+0x46/0xd0
[   42.398267]  kasan_kmalloc+0xad/0xe0
[   42.398548]  kasan_slab_alloc+0x12/0x20
[   42.398848]  __kmalloc_node_track_caller+0xcb/0x380
[   42.399224]  __kmalloc_reserve.isra.32+0x41/0xe0
[   42.399654]  __alloc_skb+0xf8/0x580
[   42.400003]  sock_wmalloc+0xab/0xf0
[   42.400346]  __ip6_append_data.isra.41+0x2472/0x33d0
[   42.400813]  ip6_append_data+0x1a8/0x2f0
[   42.401122]  rawv6_sendmsg+0x11ee/0x2db0
[   42.401505]  inet_sendmsg+0x123/0x500
[   42.401860]  sock_sendmsg+0xca/0x110
[   42.402209]  ___sys_sendmsg+0x7cb/0x930
[   42.402582]  __sys_sendmsg+0xd9/0x190
[   42.402941]  SyS_sendmsg+0x2d/0x50
[   42.403273]  entry_SYSCALL_64_fastpath+0x1f/0xbe
[   42.403718]
[   42.403871] Freed by task 1794:
[   42.404146]  save_stack_trace+0x16/0x20
[   42.404515]  save_stack+0x46/0xd0
[   42.404827]  kasan_slab_free+0x72/0xc0
[   42.405167]  kfree+0xe8/0x2b0
[   42.405462]  skb_free_head+0x74/0xb0
[   42.405806]  skb_release_data+0x30e/0x3a0
[   42.406198]  skb_release_all+0x4a/0x60
[   42.406563]  consume_skb+0x113/0x2e0
[   42.406910]  skb_free_datagram+0x1a/0xe0
[   42.407288]  netlink_recvmsg+0x60d/0xe40
[   42.407667]  sock_recvmsg+0xd7/0x110
[   42.408022]  ___sys_recvmsg+0x25c/0x580
[   42.408395]  __sys_recvmsg+0xd6/0x190
[   42.408753]  SyS_recvmsg+0x2d/0x50
[   42.409086]  entry_SYSCALL_64_fastpath+0x1f/0xbe
[   42.409513]
[   42.409665] The buggy address belongs to the object at ffff88000969e780
[   42.409665]  which belongs to the cache kmalloc-512 of size 512
[   42.410846] The buggy address is located 24 bytes inside of
[   42.410846]  512-byte region [ffff88000969e780, ffff88000969e980)
[   42.411941] The buggy address belongs to the page:
[   42.412405] page:ffffea000025a780 count:1 mapcount:0 mapping:          (null) index:0x0 compound_mapcount: 0
[   42.413298] flags: 0x100000000008100(slab|head)
[   42.413729] raw: 0100000000008100 0000000000000000 0000000000000000 00000001800c000c
[   42.414387] raw: ffffea00002a9500 0000000900000007 ffff88000c401280 0000000000000000
[   42.415074] page dumped because: kasan: bad access detected
[   42.415604]
[   42.415757] Memory state around the buggy address:
[   42.416222]  ffff88000969e880: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[   42.416904]  ffff88000969e900: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[   42.417591] >ffff88000969e980: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
[   42.418273]                    ^
[   42.418588]  ffff88000969ea00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
[   42.419273]  ffff88000969ea80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
[   42.419882] ==================================================================

Reported-by: Andrey Konovalov <andreyknvl@google.com>
Signed-off-by: Craig Gallek <kraig@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",2423496af35d94a87156b063ea5cedffc10a70a1,https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1,net/ipv6/ip6_output.c,ip6_fragment,"int ip6_fragment(struct net *net, struct sock *sk, struct sk_buff *skb,
int (*output)(struct net *, struct sock *, struct sk_buff *))
{
struct sk_buff *frag;
struct rt6_info *rt = (struct rt6_info *)skb_dst(skb);
struct ipv6_pinfo *np = skb->sk && !dev_recursion_level() ?
inet6_sk(skb->sk) : NULL;
struct ipv6hdr *tmp_hdr;
struct frag_hdr *fh;
unsigned int mtu, hlen, left, len;
int hroom, troom;
__be32 frag_id;
int ptr, offset = 0, err = 0;
u8 *prevhdr, nexthdr = 0;
hlen = ip6_find_1stfragopt(skb, &prevhdr);
nexthdr = *prevhdr;
mtu = ip6_skb_dst_mtu(skb);
if (unlikely(!skb->ignore_df && skb->len > mtu))
goto fail_toobig;
if (IP6CB(skb)->frag_max_size) {
if (IP6CB(skb)->frag_max_size > mtu)
goto fail_toobig;
mtu = IP6CB(skb)->frag_max_size;
if (mtu < IPV6_MIN_MTU)
mtu = IPV6_MIN_MTU;
}
if (np && np->frag_size < mtu) {
if (np->frag_size)
mtu = np->frag_size;
}
if (mtu < hlen + sizeof(struct frag_hdr) + 8)
goto fail_toobig;
mtu -= hlen + sizeof(struct frag_hdr);
frag_id = ipv6_select_ident(net, &ipv6_hdr(skb)->daddr,
&ipv6_hdr(skb)->saddr);
if (skb->ip_summed == CHECKSUM_PARTIAL &&
(err = skb_checksum_help(skb)))
goto fail;
hroom = LL_RESERVED_SPACE(rt->dst.dev);
if (skb_has_frag_list(skb)) {
unsigned int first_len = skb_pagelen(skb);
struct sk_buff *frag2;
if (first_len - hlen > mtu ||
((first_len - hlen) & 7) ||
skb_cloned(skb) ||
skb_headroom(skb) < (hroom + sizeof(struct frag_hdr)))
goto slow_path;
skb_walk_frags(skb, frag) {
if (frag->len > mtu ||
((frag->len & 7) && frag->next) ||
skb_headroom(frag) < (hlen + hroom + sizeof(struct frag_hdr)))
goto slow_path_clean;
if (skb_shared(frag))
goto slow_path_clean;
BUG_ON(frag->sk);
if (skb->sk) {
frag->sk = skb->sk;
frag->destructor = sock_wfree;
}
skb->truesize -= frag->truesize;
}
err = 0;
offset = 0;
*prevhdr = NEXTHDR_FRAGMENT;
tmp_hdr = kmemdup(skb_network_header(skb), hlen, GFP_ATOMIC);
if (!tmp_hdr) {
IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),
IPSTATS_MIB_FRAGFAILS);
err = -ENOMEM;
goto fail;
}
frag = skb_shinfo(skb)->frag_list;
skb_frag_list_init(skb);
__skb_pull(skb, hlen);
fh = (struct frag_hdr *)__skb_push(skb, sizeof(struct frag_hdr));
__skb_push(skb, hlen);
skb_reset_network_header(skb);
memcpy(skb_network_header(skb), tmp_hdr, hlen);
fh->nexthdr = nexthdr;
fh->reserved = 0;
fh->frag_off = htons(IP6_MF);
fh->identification = frag_id;
first_len = skb_pagelen(skb);
skb->data_len = first_len - skb_headlen(skb);
skb->len = first_len;
ipv6_hdr(skb)->payload_len = htons(first_len -
sizeof(struct ipv6hdr));
dst_hold(&rt->dst);
for (;;) {
if (frag) {
frag->ip_summed = CHECKSUM_NONE;
skb_reset_transport_header(frag);
fh = (struct frag_hdr *)__skb_push(frag, sizeof(struct frag_hdr));
__skb_push(frag, hlen);
skb_reset_network_header(frag);
memcpy(skb_network_header(frag), tmp_hdr,
hlen);
offset += skb->len - hlen - sizeof(struct frag_hdr);
fh->nexthdr = nexthdr;
fh->reserved = 0;
fh->frag_off = htons(offset);
if (frag->next)
fh->frag_off |= htons(IP6_MF);
fh->identification = frag_id;
ipv6_hdr(frag)->payload_len =
htons(frag->len -
sizeof(struct ipv6hdr));
ip6_copy_metadata(frag, skb);
}
err = output(net, sk, skb);
if (!err)
IP6_INC_STATS(net, ip6_dst_idev(&rt->dst),
IPSTATS_MIB_FRAGCREATES);
if (err || !frag)
break;
skb = frag;
frag = skb->next;
skb->next = NULL;
}
kfree(tmp_hdr);
if (err == 0) {
IP6_INC_STATS(net, ip6_dst_idev(&rt->dst),
IPSTATS_MIB_FRAGOKS);
ip6_rt_put(rt);
return 0;
}
kfree_skb_list(frag);
IP6_INC_STATS(net, ip6_dst_idev(&rt->dst),
IPSTATS_MIB_FRAGFAILS);
ip6_rt_put(rt);
return err;
slow_path_clean:
skb_walk_frags(skb, frag2) {
if (frag2 == frag)
break;
frag2->sk = NULL;
frag2->destructor = NULL;
skb->truesize += frag2->truesize;
}
}
slow_path:
left = skb->len - hlen;
ptr = hlen;
troom = rt->dst.dev->needed_tailroom;
while (left > 0){
u8 *fragnexthdr_offset;
len = left;
if (len > mtu)
len = mtu;
if (len < left){
len &= ~7;
}
frag = alloc_skb(len + hlen + sizeof(struct frag_hdr) +
hroom + troom, GFP_ATOMIC);
if (!frag) {
IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),
IPSTATS_MIB_FRAGFAILS);
err = -ENOMEM;
goto fail;
}
ip6_copy_metadata(frag, skb);
skb_reserve(frag, hroom);
skb_put(frag, len + hlen + sizeof(struct frag_hdr));
skb_reset_network_header(frag);
fh = (struct frag_hdr *)(skb_network_header(frag) + hlen);
frag->transport_header = (frag->network_header + hlen +
sizeof(struct frag_hdr));
if (skb->sk)
skb_set_owner_w(frag, skb->sk);
skb_copy_from_linear_data(skb, skb_network_header(frag), hlen);
fragnexthdr_offset = skb_network_header(frag);
fragnexthdr_offset += prevhdr - skb_network_header(skb);
*fragnexthdr_offset = NEXTHDR_FRAGMENT;
fh->nexthdr = nexthdr;
fh->reserved = 0;
fh->identification = frag_id;
BUG_ON(skb_copy_bits(skb, ptr, skb_transport_header(frag),
len));
left -= len;
fh->frag_off = htons(offset);
if (left > 0)
fh->frag_off |= htons(IP6_MF);
ipv6_hdr(frag)->payload_len = htons(frag->len -
sizeof(struct ipv6hdr));
ptr += len;
offset += len;
err = output(net, sk, frag);
if (err)
goto fail;
IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),
IPSTATS_MIB_FRAGCREATES);
}
IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),
IPSTATS_MIB_FRAGOKS);
consume_skb(skb);
return err;
fail_toobig:
if (skb->sk && dst_allfrag(skb_dst(skb)))
sk_nocaps_add(skb->sk, NETIF_F_GSO_MASK);
skb->dev = skb_dst(skb)->dev;
icmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);
err = -EMSGSIZE;
fail:
IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),
IPSTATS_MIB_FRAGFAILS);
kfree_skb(skb);
return err;
}","int ip6_fragment(struct net *net, struct sock *VAR_0, struct sk_buff *VAR_1,
int (*VAR_2)(struct net *, struct sock *, struct sk_buff *))
{
struct sk_buff *VAR_3;
struct rt6_info *VAR_4 = (struct rt6_info *)skb_dst(VAR_1);
struct ipv6_pinfo *VAR_5 = VAR_1->sk && !dev_recursion_level() ?
inet6_sk(VAR_1->sk) : NULL;
struct ipv6hdr *VAR_6;
struct frag_hdr *VAR_7;
unsigned int VAR_8, VAR_9, VAR_10, VAR_11;
int VAR_12, VAR_13;
__be32 VAR_14;
int VAR_15, VAR_16 = 0, VAR_17 = 0;
u8 *VAR_18, VAR_19 = 0;
VAR_9 = ip6_find_1stfragopt(VAR_1, &VAR_18);
VAR_19 = *VAR_18;
VAR_8 = ip6_skb_dst_mtu(VAR_1);
if (unlikely(!VAR_1->ignore_df && VAR_1->len > VAR_8))
goto fail_toobig;
if (IP6CB(VAR_1)->frag_max_size) {
if (IP6CB(VAR_1)->frag_max_size > VAR_8)
goto fail_toobig;
VAR_8 = IP6CB(VAR_1)->frag_max_size;
if (VAR_8 < VAR_20)
VAR_8 = VAR_20;
}
if (VAR_5 && VAR_5->frag_size < VAR_8) {
if (VAR_5->frag_size)
VAR_8 = VAR_5->frag_size;
}
if (VAR_8 < VAR_9 + sizeof(struct frag_hdr) + 8)
goto fail_toobig;
VAR_8 -= VAR_9 + sizeof(struct frag_hdr);
VAR_14 = ipv6_select_ident(net, &ipv6_hdr(VAR_1)->daddr,
&ipv6_hdr(VAR_1)->saddr);
if (VAR_1->ip_summed == VAR_21 &&
(VAR_17 = skb_checksum_help(VAR_1)))
goto fail;
VAR_12 = LL_RESERVED_SPACE(VAR_4->dst.dev);
if (skb_has_frag_list(VAR_1)) {
unsigned int VAR_22 = skb_pagelen(VAR_1);
struct sk_buff *VAR_23;
if (VAR_22 - VAR_9 > VAR_8 ||
((VAR_22 - VAR_9) & 7) ||
skb_cloned(VAR_1) ||
skb_headroom(VAR_1) < (VAR_12 + sizeof(struct frag_hdr)))
goto slow_path;
skb_walk_frags(VAR_1, VAR_3) {
if (VAR_3->len > VAR_8 ||
((VAR_3->len & 7) && VAR_3->next) ||
skb_headroom(VAR_3) < (VAR_9 + VAR_12 + sizeof(struct frag_hdr)))
goto slow_path_clean;
if (skb_shared(VAR_3))
goto slow_path_clean;
BUG_ON(VAR_3->sk);
if (VAR_1->sk) {
VAR_3->sk = VAR_1->sk;
VAR_3->destructor = VAR_24;
}
VAR_1->truesize -= VAR_3->truesize;
}
VAR_17 = 0;
VAR_16 = 0;
*VAR_18 = VAR_25;
VAR_6 = kmemdup(skb_network_header(VAR_1), VAR_9, VAR_26);
if (!VAR_6) {
IP6_INC_STATS(net, ip6_dst_idev(skb_dst(VAR_1)),
VAR_27);
VAR_17 = -VAR_28;
goto fail;
}
VAR_3 = skb_shinfo(VAR_1)->frag_list;
skb_frag_list_init(VAR_1);
__skb_pull(VAR_1, VAR_9);
VAR_7 = (struct frag_hdr *)__skb_push(VAR_1, sizeof(struct frag_hdr));
__skb_push(VAR_1, VAR_9);
skb_reset_network_header(VAR_1);
memcpy(skb_network_header(VAR_1), VAR_6, VAR_9);
VAR_7->nexthdr = VAR_19;
VAR_7->reserved = 0;
VAR_7->frag_off = htons(VAR_29);
VAR_7->identification = VAR_14;
VAR_22 = skb_pagelen(VAR_1);
VAR_1->data_len = VAR_22 - skb_headlen(VAR_1);
VAR_1->len = VAR_22;
ipv6_hdr(VAR_1)->payload_len = htons(VAR_22 -
sizeof(struct ipv6hdr));
dst_hold(&VAR_4->dst);
for (;;) {
if (VAR_3) {
VAR_3->ip_summed = VAR_30;
skb_reset_transport_header(VAR_3);
VAR_7 = (struct frag_hdr *)__skb_push(VAR_3, sizeof(struct frag_hdr));
__skb_push(VAR_3, VAR_9);
skb_reset_network_header(VAR_3);
memcpy(skb_network_header(VAR_3), VAR_6,
VAR_9);
VAR_16 += VAR_1->len - VAR_9 - sizeof(struct frag_hdr);
VAR_7->nexthdr = VAR_19;
VAR_7->reserved = 0;
VAR_7->frag_off = htons(VAR_16);
if (VAR_3->next)
VAR_7->frag_off |= htons(VAR_29);
VAR_7->identification = VAR_14;
ipv6_hdr(VAR_3)->payload_len =
htons(VAR_3->len -
sizeof(struct ipv6hdr));
ip6_copy_metadata(VAR_3, VAR_1);
}
VAR_17 = VAR_2(net, VAR_0, VAR_1);
if (!VAR_17)
IP6_INC_STATS(net, ip6_dst_idev(&VAR_4->dst),
VAR_31);
if (VAR_17 || !VAR_3)
break;
VAR_1 = VAR_3;
VAR_3 = VAR_1->next;
VAR_1->next = NULL;
}
kfree(VAR_6);
if (VAR_17 == 0) {
IP6_INC_STATS(net, ip6_dst_idev(&VAR_4->dst),
VAR_32);
ip6_rt_put(VAR_4);
return 0;
}
kfree_skb_list(VAR_3);
IP6_INC_STATS(net, ip6_dst_idev(&VAR_4->dst),
VAR_27);
ip6_rt_put(VAR_4);
return VAR_17;
slow_path_clean:
skb_walk_frags(VAR_1, VAR_23) {
if (VAR_23 == VAR_3)
break;
VAR_23->sk = NULL;
VAR_23->destructor = NULL;
VAR_1->truesize += VAR_23->truesize;
}
}
slow_path:
VAR_10 = VAR_1->len - VAR_9;
VAR_15 = VAR_9;
VAR_13 = VAR_4->dst.dev->needed_tailroom;
while (VAR_10 > 0){
u8 *VAR_33;
VAR_11 = VAR_10;
if (VAR_11 > VAR_8)
VAR_11 = VAR_8;
if (VAR_11 < VAR_10){
VAR_11 &= ~7;
}
VAR_3 = alloc_skb(VAR_11 + VAR_9 + sizeof(struct frag_hdr) +
VAR_12 + VAR_13, VAR_26);
if (!VAR_3) {
IP6_INC_STATS(net, ip6_dst_idev(skb_dst(VAR_1)),
VAR_27);
VAR_17 = -VAR_28;
goto fail;
}
ip6_copy_metadata(VAR_3, VAR_1);
skb_reserve(VAR_3, VAR_12);
skb_put(VAR_3, VAR_11 + VAR_9 + sizeof(struct frag_hdr));
skb_reset_network_header(VAR_3);
VAR_7 = (struct frag_hdr *)(skb_network_header(VAR_3) + VAR_9);
VAR_3->transport_header = (VAR_3->network_header + VAR_9 +
sizeof(struct frag_hdr));
if (VAR_1->sk)
skb_set_owner_w(VAR_3, VAR_1->sk);
skb_copy_from_linear_data(VAR_1, skb_network_header(VAR_3), VAR_9);
VAR_33 = skb_network_header(VAR_3);
VAR_33 += VAR_18 - skb_network_header(VAR_1);
*VAR_33 = VAR_25;
VAR_7->nexthdr = VAR_19;
VAR_7->reserved = 0;
VAR_7->identification = VAR_14;
BUG_ON(skb_copy_bits(VAR_1, VAR_15, skb_transport_header(VAR_3),
VAR_11));
VAR_10 -= VAR_11;
VAR_7->frag_off = htons(VAR_16);
if (VAR_10 > 0)
VAR_7->frag_off |= htons(VAR_29);
ipv6_hdr(VAR_3)->payload_len = htons(VAR_3->len -
sizeof(struct ipv6hdr));
VAR_15 += VAR_11;
VAR_16 += VAR_11;
VAR_17 = VAR_2(net, VAR_0, VAR_3);
if (VAR_17)
goto fail;
IP6_INC_STATS(net, ip6_dst_idev(skb_dst(VAR_1)),
VAR_31);
}
IP6_INC_STATS(net, ip6_dst_idev(skb_dst(VAR_1)),
VAR_32);
consume_skb(VAR_1);
return VAR_17;
fail_toobig:
if (VAR_1->sk && dst_allfrag(skb_dst(VAR_1)))
sk_nocaps_add(VAR_1->sk, VAR_34);
VAR_1->dev = skb_dst(VAR_1)->dev;
icmpv6_send(VAR_1, VAR_35, 0, VAR_8);
VAR_17 = -VAR_36;
fail:
IP6_INC_STATS(net, ip6_dst_idev(skb_dst(VAR_1)),
VAR_27);
kfree_skb(VAR_1);
return VAR_17;
}",torvalds/linux/2423496af35d94a87156b063ea5cedffc10a70a1/ip6_output.c/vul/before/0.json,"int ip6_fragment(struct net *net, struct sock *sk, struct sk_buff *skb,
		 int (*output)(struct net *, struct sock *, struct sk_buff *))
{
	struct sk_buff *frag;
	struct rt6_info *rt = (struct rt6_info *)skb_dst(skb);
	struct ipv6_pinfo *np = skb->sk && !dev_recursion_level() ?
				inet6_sk(skb->sk) : NULL;
	struct ipv6hdr *tmp_hdr;
	struct frag_hdr *fh;
	unsigned int mtu, hlen, left, len;
	int hroom, troom;
	__be32 frag_id;
	int ptr, offset = 0, err = 0;
	u8 *prevhdr, nexthdr = 0;

	hlen = ip6_find_1stfragopt(skb, &prevhdr);
	if (hlen < 0) {
		err = hlen;
		goto fail;
	}
	nexthdr = *prevhdr;

	mtu = ip6_skb_dst_mtu(skb);

	/* We must not fragment if the socket is set to force MTU discovery
	 * or if the skb it not generated by a local socket.
	 */
	if (unlikely(!skb->ignore_df && skb->len > mtu))
		goto fail_toobig;

	if (IP6CB(skb)->frag_max_size) {
		if (IP6CB(skb)->frag_max_size > mtu)
			goto fail_toobig;

		/* don't send fragments larger than what we received */
		mtu = IP6CB(skb)->frag_max_size;
		if (mtu < IPV6_MIN_MTU)
			mtu = IPV6_MIN_MTU;
	}

	if (np && np->frag_size < mtu) {
		if (np->frag_size)
			mtu = np->frag_size;
	}
	if (mtu < hlen + sizeof(struct frag_hdr) + 8)
		goto fail_toobig;
	mtu -= hlen + sizeof(struct frag_hdr);

	frag_id = ipv6_select_ident(net, &ipv6_hdr(skb)->daddr,
				    &ipv6_hdr(skb)->saddr);

	if (skb->ip_summed == CHECKSUM_PARTIAL &&
	    (err = skb_checksum_help(skb)))
		goto fail;

	hroom = LL_RESERVED_SPACE(rt->dst.dev);
	if (skb_has_frag_list(skb)) {
		unsigned int first_len = skb_pagelen(skb);
		struct sk_buff *frag2;

		if (first_len - hlen > mtu ||
		    ((first_len - hlen) & 7) ||
		    skb_cloned(skb) ||
		    skb_headroom(skb) < (hroom + sizeof(struct frag_hdr)))
			goto slow_path;

		skb_walk_frags(skb, frag) {
			/* Correct geometry. */
			if (frag->len > mtu ||
			    ((frag->len & 7) && frag->next) ||
			    skb_headroom(frag) < (hlen + hroom + sizeof(struct frag_hdr)))
				goto slow_path_clean;

			/* Partially cloned skb? */
			if (skb_shared(frag))
				goto slow_path_clean;

			BUG_ON(frag->sk);
			if (skb->sk) {
				frag->sk = skb->sk;
				frag->destructor = sock_wfree;
			}
			skb->truesize -= frag->truesize;
		}

		err = 0;
		offset = 0;
		/* BUILD HEADER */

		*prevhdr = NEXTHDR_FRAGMENT;
		tmp_hdr = kmemdup(skb_network_header(skb), hlen, GFP_ATOMIC);
		if (!tmp_hdr) {
			IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),
				      IPSTATS_MIB_FRAGFAILS);
			err = -ENOMEM;
			goto fail;
		}
		frag = skb_shinfo(skb)->frag_list;
		skb_frag_list_init(skb);

		__skb_pull(skb, hlen);
		fh = (struct frag_hdr *)__skb_push(skb, sizeof(struct frag_hdr));
		__skb_push(skb, hlen);
		skb_reset_network_header(skb);
		memcpy(skb_network_header(skb), tmp_hdr, hlen);

		fh->nexthdr = nexthdr;
		fh->reserved = 0;
		fh->frag_off = htons(IP6_MF);
		fh->identification = frag_id;

		first_len = skb_pagelen(skb);
		skb->data_len = first_len - skb_headlen(skb);
		skb->len = first_len;
		ipv6_hdr(skb)->payload_len = htons(first_len -
						   sizeof(struct ipv6hdr));

		dst_hold(&rt->dst);

		for (;;) {
			/* Prepare header of the next frame,
			 * before previous one went down. */
			if (frag) {
				frag->ip_summed = CHECKSUM_NONE;
				skb_reset_transport_header(frag);
				fh = (struct frag_hdr *)__skb_push(frag, sizeof(struct frag_hdr));
				__skb_push(frag, hlen);
				skb_reset_network_header(frag);
				memcpy(skb_network_header(frag), tmp_hdr,
				       hlen);
				offset += skb->len - hlen - sizeof(struct frag_hdr);
				fh->nexthdr = nexthdr;
				fh->reserved = 0;
				fh->frag_off = htons(offset);
				if (frag->next)
					fh->frag_off |= htons(IP6_MF);
				fh->identification = frag_id;
				ipv6_hdr(frag)->payload_len =
						htons(frag->len -
						      sizeof(struct ipv6hdr));
				ip6_copy_metadata(frag, skb);
			}

			err = output(net, sk, skb);
			if (!err)
				IP6_INC_STATS(net, ip6_dst_idev(&rt->dst),
					      IPSTATS_MIB_FRAGCREATES);

			if (err || !frag)
				break;

			skb = frag;
			frag = skb->next;
			skb->next = NULL;
		}

		kfree(tmp_hdr);

		if (err == 0) {
			IP6_INC_STATS(net, ip6_dst_idev(&rt->dst),
				      IPSTATS_MIB_FRAGOKS);
			ip6_rt_put(rt);
			return 0;
		}

		kfree_skb_list(frag);

		IP6_INC_STATS(net, ip6_dst_idev(&rt->dst),
			      IPSTATS_MIB_FRAGFAILS);
		ip6_rt_put(rt);
		return err;

slow_path_clean:
		skb_walk_frags(skb, frag2) {
			if (frag2 == frag)
				break;
			frag2->sk = NULL;
			frag2->destructor = NULL;
			skb->truesize += frag2->truesize;
		}
	}

slow_path:
	left = skb->len - hlen;		/* Space per frame */
	ptr = hlen;			/* Where to start from */

	/*
	 *	Fragment the datagram.
	 */

	troom = rt->dst.dev->needed_tailroom;

	/*
	 *	Keep copying data until we run out.
	 */
	while (left > 0)	{
		u8 *fragnexthdr_offset;

		len = left;
		/* IF: it doesn't fit, use 'mtu' - the data space left */
		if (len > mtu)
			len = mtu;
		/* IF: we are not sending up to and including the packet end
		   then align the next start on an eight byte boundary */
		if (len < left)	{
			len &= ~7;
		}

		/* Allocate buffer */
		frag = alloc_skb(len + hlen + sizeof(struct frag_hdr) +
				 hroom + troom, GFP_ATOMIC);
		if (!frag) {
			IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),
				      IPSTATS_MIB_FRAGFAILS);
			err = -ENOMEM;
			goto fail;
		}

		/*
		 *	Set up data on packet
		 */

		ip6_copy_metadata(frag, skb);
		skb_reserve(frag, hroom);
		skb_put(frag, len + hlen + sizeof(struct frag_hdr));
		skb_reset_network_header(frag);
		fh = (struct frag_hdr *)(skb_network_header(frag) + hlen);
		frag->transport_header = (frag->network_header + hlen +
					  sizeof(struct frag_hdr));

		/*
		 *	Charge the memory for the fragment to any owner
		 *	it might possess
		 */
		if (skb->sk)
			skb_set_owner_w(frag, skb->sk);

		/*
		 *	Copy the packet header into the new buffer.
		 */
		skb_copy_from_linear_data(skb, skb_network_header(frag), hlen);

		fragnexthdr_offset = skb_network_header(frag);
		fragnexthdr_offset += prevhdr - skb_network_header(skb);
		*fragnexthdr_offset = NEXTHDR_FRAGMENT;

		/*
		 *	Build fragment header.
		 */
		fh->nexthdr = nexthdr;
		fh->reserved = 0;
		fh->identification = frag_id;

		/*
		 *	Copy a block of the IP datagram.
		 */
		BUG_ON(skb_copy_bits(skb, ptr, skb_transport_header(frag),
				     len));
		left -= len;

		fh->frag_off = htons(offset);
		if (left > 0)
			fh->frag_off |= htons(IP6_MF);
		ipv6_hdr(frag)->payload_len = htons(frag->len -
						    sizeof(struct ipv6hdr));

		ptr += len;
		offset += len;

		/*
		 *	Put this fragment into the sending queue.
		 */
		err = output(net, sk, frag);
		if (err)
			goto fail;

		IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),
			      IPSTATS_MIB_FRAGCREATES);
	}
	IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),
		      IPSTATS_MIB_FRAGOKS);
	consume_skb(skb);
	return err;

fail_toobig:
	if (skb->sk && dst_allfrag(skb_dst(skb)))
		sk_nocaps_add(skb->sk, NETIF_F_GSO_MASK);

	skb->dev = skb_dst(skb)->dev;
	icmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);
	err = -EMSGSIZE;

fail:
	IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),
		      IPSTATS_MIB_FRAGFAILS);
	kfree_skb(skb);
	return err;
}","int ip6_fragment(struct net *net, struct sock *VAR_0, struct sk_buff *VAR_1,
		 int (*VAR_2)(struct net *, struct sock *, struct sk_buff *))
{
	struct sk_buff *VAR_3;
	struct rt6_info *VAR_4 = (struct rt6_info *)skb_dst(VAR_1);
	struct ipv6_pinfo *VAR_5 = VAR_1->sk && !dev_recursion_level() ?
				inet6_sk(VAR_1->sk) : NULL;
	struct ipv6hdr *VAR_6;
	struct frag_hdr *VAR_7;
	unsigned int VAR_8, VAR_9, VAR_10, VAR_11;
	int VAR_12, VAR_13;
	__be32 VAR_14;
	int VAR_15, VAR_16 = 0, VAR_17 = 0;
	u8 *VAR_18, VAR_19 = 0;

	VAR_9 = ip6_find_1stfragopt(VAR_1, &VAR_18);
	if (VAR_9 < 0) {
		VAR_17 = VAR_9;
		goto fail;
	}
	VAR_19 = *VAR_18;

	VAR_8 = ip6_skb_dst_mtu(VAR_1);

	/* COMMENT_0 */
                                                     
    
	if (unlikely(!VAR_1->ignore_df && VAR_1->len > VAR_8))
		goto fail_toobig;

	if (IP6CB(VAR_1)->frag_max_size) {
		if (IP6CB(VAR_1)->frag_max_size > VAR_8)
			goto fail_toobig;

		/* COMMENT_3 */
		VAR_8 = IP6CB(VAR_1)->frag_max_size;
		if (VAR_8 < VAR_20)
			VAR_8 = VAR_20;
	}

	if (VAR_5 && VAR_5->frag_size < VAR_8) {
		if (VAR_5->frag_size)
			VAR_8 = VAR_5->frag_size;
	}
	if (VAR_8 < VAR_9 + sizeof(struct frag_hdr) + 8)
		goto fail_toobig;
	VAR_8 -= VAR_9 + sizeof(struct frag_hdr);

	VAR_14 = ipv6_select_ident(net, &ipv6_hdr(VAR_1)->daddr,
				    &ipv6_hdr(VAR_1)->saddr);

	if (VAR_1->ip_summed == VAR_21 &&
	    (VAR_17 = skb_checksum_help(VAR_1)))
		goto fail;

	VAR_12 = LL_RESERVED_SPACE(VAR_4->dst.dev);
	if (skb_has_frag_list(VAR_1)) {
		unsigned int VAR_22 = skb_pagelen(VAR_1);
		struct sk_buff *VAR_23;

		if (VAR_22 - VAR_9 > VAR_8 ||
		    ((VAR_22 - VAR_9) & 7) ||
		    skb_cloned(VAR_1) ||
		    skb_headroom(VAR_1) < (VAR_12 + sizeof(struct frag_hdr)))
			goto slow_path;

		skb_walk_frags(VAR_1, VAR_3) {
			/* COMMENT_4 */
			if (VAR_3->len > VAR_8 ||
			    ((VAR_3->len & 7) && VAR_3->next) ||
			    skb_headroom(VAR_3) < (VAR_9 + VAR_12 + sizeof(struct frag_hdr)))
				goto slow_path_clean;

			/* COMMENT_5 */
			if (skb_shared(VAR_3))
				goto slow_path_clean;

			BUG_ON(VAR_3->sk);
			if (VAR_1->sk) {
				VAR_3->sk = VAR_1->sk;
				VAR_3->destructor = VAR_24;
			}
			VAR_1->truesize -= VAR_3->truesize;
		}

		VAR_17 = 0;
		VAR_16 = 0;
		/* COMMENT_6 */

		*VAR_18 = VAR_25;
		VAR_6 = kmemdup(skb_network_header(VAR_1), VAR_9, VAR_26);
		if (!VAR_6) {
			IP6_INC_STATS(net, ip6_dst_idev(skb_dst(VAR_1)),
				      VAR_27);
			VAR_17 = -VAR_28;
			goto fail;
		}
		VAR_3 = skb_shinfo(VAR_1)->frag_list;
		skb_frag_list_init(VAR_1);

		__skb_pull(VAR_1, VAR_9);
		VAR_7 = (struct frag_hdr *)__skb_push(VAR_1, sizeof(struct frag_hdr));
		__skb_push(VAR_1, VAR_9);
		skb_reset_network_header(VAR_1);
		memcpy(skb_network_header(VAR_1), VAR_6, VAR_9);

		VAR_7->nexthdr = VAR_19;
		VAR_7->reserved = 0;
		VAR_7->frag_off = htons(VAR_29);
		VAR_7->identification = VAR_14;

		VAR_22 = skb_pagelen(VAR_1);
		VAR_1->data_len = VAR_22 - skb_headlen(VAR_1);
		VAR_1->len = VAR_22;
		ipv6_hdr(VAR_1)->payload_len = htons(VAR_22 -
						   sizeof(struct ipv6hdr));

		dst_hold(&VAR_4->dst);

		for (;;) {
			/* COMMENT_7 */
                                       
			if (VAR_3) {
				VAR_3->ip_summed = VAR_30;
				skb_reset_transport_header(VAR_3);
				VAR_7 = (struct frag_hdr *)__skb_push(VAR_3, sizeof(struct frag_hdr));
				__skb_push(VAR_3, VAR_9);
				skb_reset_network_header(VAR_3);
				memcpy(skb_network_header(VAR_3), VAR_6,
				       VAR_9);
				VAR_16 += VAR_1->len - VAR_9 - sizeof(struct frag_hdr);
				VAR_7->nexthdr = VAR_19;
				VAR_7->reserved = 0;
				VAR_7->frag_off = htons(VAR_16);
				if (VAR_3->next)
					VAR_7->frag_off |= htons(VAR_29);
				VAR_7->identification = VAR_14;
				ipv6_hdr(VAR_3)->payload_len =
						htons(VAR_3->len -
						      sizeof(struct ipv6hdr));
				ip6_copy_metadata(VAR_3, VAR_1);
			}

			VAR_17 = VAR_2(net, VAR_0, VAR_1);
			if (!VAR_17)
				IP6_INC_STATS(net, ip6_dst_idev(&VAR_4->dst),
					      VAR_31);

			if (VAR_17 || !VAR_3)
				break;

			VAR_1 = VAR_3;
			VAR_3 = VAR_1->next;
			VAR_1->next = NULL;
		}

		kfree(VAR_6);

		if (VAR_17 == 0) {
			IP6_INC_STATS(net, ip6_dst_idev(&VAR_4->dst),
				      VAR_32);
			ip6_rt_put(VAR_4);
			return 0;
		}

		kfree_skb_list(VAR_3);

		IP6_INC_STATS(net, ip6_dst_idev(&VAR_4->dst),
			      VAR_27);
		ip6_rt_put(VAR_4);
		return VAR_17;

slow_path_clean:
		skb_walk_frags(VAR_1, VAR_23) {
			if (VAR_23 == VAR_3)
				break;
			VAR_23->sk = NULL;
			VAR_23->destructor = NULL;
			VAR_1->truesize += VAR_23->truesize;
		}
	}

slow_path:
	VAR_10 = VAR_1->len - VAR_9;		/* COMMENT_9 */
	VAR_15 = VAR_9;			/* COMMENT_10 */

	/* COMMENT_11 */
                          
    

	VAR_13 = VAR_4->dst.dev->needed_tailroom;

	/* COMMENT_14 */
                                       
    
	while (VAR_10 > 0)	{
		u8 *VAR_33;

		VAR_11 = VAR_10;
		/* COMMENT_17 */
		if (VAR_11 > VAR_8)
			VAR_11 = VAR_8;
		/* COMMENT_18 */
                                                           
		if (VAR_11 < VAR_10)	{
			VAR_11 &= ~7;
		}

		/* COMMENT_20 */
		VAR_3 = alloc_skb(VAR_11 + VAR_9 + sizeof(struct frag_hdr) +
				 VAR_12 + VAR_13, VAR_26);
		if (!VAR_3) {
			IP6_INC_STATS(net, ip6_dst_idev(skb_dst(VAR_1)),
				      VAR_27);
			VAR_17 = -VAR_28;
			goto fail;
		}

		/* COMMENT_21 */
                          
     

		ip6_copy_metadata(VAR_3, VAR_1);
		skb_reserve(VAR_3, VAR_12);
		skb_put(VAR_3, VAR_11 + VAR_9 + sizeof(struct frag_hdr));
		skb_reset_network_header(VAR_3);
		VAR_7 = (struct frag_hdr *)(skb_network_header(VAR_3) + VAR_9);
		VAR_3->transport_header = (VAR_3->network_header + VAR_9 +
					  sizeof(struct frag_hdr));

		/* COMMENT_24 */
                                                    
                     
     
		if (VAR_1->sk)
			skb_set_owner_w(VAR_3, VAR_1->sk);

		/* COMMENT_28 */
                                                
     
		skb_copy_from_linear_data(VAR_1, skb_network_header(VAR_3), VAR_9);

		VAR_33 = skb_network_header(VAR_3);
		VAR_33 += VAR_18 - skb_network_header(VAR_1);
		*VAR_33 = VAR_25;

		/* COMMENT_31 */
                           
     
		VAR_7->nexthdr = VAR_19;
		VAR_7->reserved = 0;
		VAR_7->identification = VAR_14;

		/* COMMENT_34 */
                                     
     
		BUG_ON(skb_copy_bits(VAR_1, VAR_15, skb_transport_header(VAR_3),
				     VAR_11));
		VAR_10 -= VAR_11;

		VAR_7->frag_off = htons(VAR_16);
		if (VAR_10 > 0)
			VAR_7->frag_off |= htons(VAR_29);
		ipv6_hdr(VAR_3)->payload_len = htons(VAR_3->len -
						    sizeof(struct ipv6hdr));

		VAR_15 += VAR_11;
		VAR_16 += VAR_11;

		/* COMMENT_37 */
                                              
     
		VAR_17 = VAR_2(net, VAR_0, VAR_3);
		if (VAR_17)
			goto fail;

		IP6_INC_STATS(net, ip6_dst_idev(skb_dst(VAR_1)),
			      VAR_31);
	}
	IP6_INC_STATS(net, ip6_dst_idev(skb_dst(VAR_1)),
		      VAR_32);
	consume_skb(VAR_1);
	return VAR_17;

fail_toobig:
	if (VAR_1->sk && dst_allfrag(skb_dst(VAR_1)))
		sk_nocaps_add(VAR_1->sk, VAR_34);

	VAR_1->dev = skb_dst(VAR_1)->dev;
	icmpv6_send(VAR_1, VAR_35, 0, VAR_8);
	VAR_17 = -VAR_36;

fail:
	IP6_INC_STATS(net, ip6_dst_idev(skb_dst(VAR_1)),
		      VAR_27);
	kfree_skb(VAR_1);
	return VAR_17;
}",torvalds/linux/2423496af35d94a87156b063ea5cedffc10a70a1/ip6_output.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,6 +14,10 @@
 	u8 *prevhdr, nexthdr = 0;
 
 	hlen = ip6_find_1stfragopt(skb, &prevhdr);
+	if (hlen < 0) {
+		err = hlen;
+		goto fail;
+	}
 	nexthdr = *prevhdr;
 
 	mtu = ip6_skb_dst_mtu(skb);","{'deleted_lines': [], 'added_lines': ['\tif (hlen < 0) {', '\t\terr = hlen;', '\t\tgoto fail;', '\t}']}",True,"The IPv6 fragmentation implementation in the Linux kernel through 4.11.1 does not consider that the nexthdr field may be associated with an invalid option, which allows local users to cause a denial of service (out-of-bounds read and BUG) or possibly have unspecified other impact via crafted socket and send system calls.",7.8,HIGH,2,test,2017-05-16T18:36:23Z,1
CVE-2017-9074,['CWE-125'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"ipv6: Prevent overrun when parsing v6 header options

The KASAN warning repoted below was discovered with a syzkaller
program.  The reproducer is basically:
  int s = socket(AF_INET6, SOCK_RAW, NEXTHDR_HOP);
  send(s, &one_byte_of_data, 1, MSG_MORE);
  send(s, &more_than_mtu_bytes_data, 2000, 0);

The socket() call sets the nexthdr field of the v6 header to
NEXTHDR_HOP, the first send call primes the payload with a non zero
byte of data, and the second send call triggers the fragmentation path.

The fragmentation code tries to parse the header options in order
to figure out where to insert the fragment option.  Since nexthdr points
to an invalid option, the calculation of the size of the network header
can made to be much larger than the linear section of the skb and data
is read outside of it.

This fix makes ip6_find_1stfrag return an error if it detects
running out-of-bounds.

[   42.361487] ==================================================================
[   42.364412] BUG: KASAN: slab-out-of-bounds in ip6_fragment+0x11c8/0x3730
[   42.365471] Read of size 840 at addr ffff88000969e798 by task ip6_fragment-oo/3789
[   42.366469]
[   42.366696] CPU: 1 PID: 3789 Comm: ip6_fragment-oo Not tainted 4.11.0+ #41
[   42.367628] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.1-1ubuntu1 04/01/2014
[   42.368824] Call Trace:
[   42.369183]  dump_stack+0xb3/0x10b
[   42.369664]  print_address_description+0x73/0x290
[   42.370325]  kasan_report+0x252/0x370
[   42.370839]  ? ip6_fragment+0x11c8/0x3730
[   42.371396]  check_memory_region+0x13c/0x1a0
[   42.371978]  memcpy+0x23/0x50
[   42.372395]  ip6_fragment+0x11c8/0x3730
[   42.372920]  ? nf_ct_expect_unregister_notifier+0x110/0x110
[   42.373681]  ? ip6_copy_metadata+0x7f0/0x7f0
[   42.374263]  ? ip6_forward+0x2e30/0x2e30
[   42.374803]  ip6_finish_output+0x584/0x990
[   42.375350]  ip6_output+0x1b7/0x690
[   42.375836]  ? ip6_finish_output+0x990/0x990
[   42.376411]  ? ip6_fragment+0x3730/0x3730
[   42.376968]  ip6_local_out+0x95/0x160
[   42.377471]  ip6_send_skb+0xa1/0x330
[   42.377969]  ip6_push_pending_frames+0xb3/0xe0
[   42.378589]  rawv6_sendmsg+0x2051/0x2db0
[   42.379129]  ? rawv6_bind+0x8b0/0x8b0
[   42.379633]  ? _copy_from_user+0x84/0xe0
[   42.380193]  ? debug_check_no_locks_freed+0x290/0x290
[   42.380878]  ? ___sys_sendmsg+0x162/0x930
[   42.381427]  ? rcu_read_lock_sched_held+0xa3/0x120
[   42.382074]  ? sock_has_perm+0x1f6/0x290
[   42.382614]  ? ___sys_sendmsg+0x167/0x930
[   42.383173]  ? lock_downgrade+0x660/0x660
[   42.383727]  inet_sendmsg+0x123/0x500
[   42.384226]  ? inet_sendmsg+0x123/0x500
[   42.384748]  ? inet_recvmsg+0x540/0x540
[   42.385263]  sock_sendmsg+0xca/0x110
[   42.385758]  SYSC_sendto+0x217/0x380
[   42.386249]  ? SYSC_connect+0x310/0x310
[   42.386783]  ? __might_fault+0x110/0x1d0
[   42.387324]  ? lock_downgrade+0x660/0x660
[   42.387880]  ? __fget_light+0xa1/0x1f0
[   42.388403]  ? __fdget+0x18/0x20
[   42.388851]  ? sock_common_setsockopt+0x95/0xd0
[   42.389472]  ? SyS_setsockopt+0x17f/0x260
[   42.390021]  ? entry_SYSCALL_64_fastpath+0x5/0xbe
[   42.390650]  SyS_sendto+0x40/0x50
[   42.391103]  entry_SYSCALL_64_fastpath+0x1f/0xbe
[   42.391731] RIP: 0033:0x7fbbb711e383
[   42.392217] RSP: 002b:00007ffff4d34f28 EFLAGS: 00000246 ORIG_RAX: 000000000000002c
[   42.393235] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fbbb711e383
[   42.394195] RDX: 0000000000001000 RSI: 00007ffff4d34f60 RDI: 0000000000000003
[   42.395145] RBP: 0000000000000046 R08: 00007ffff4d34f40 R09: 0000000000000018
[   42.396056] R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000400aad
[   42.396598] R13: 0000000000000066 R14: 00007ffff4d34ee0 R15: 00007fbbb717af00
[   42.397257]
[   42.397411] Allocated by task 3789:
[   42.397702]  save_stack_trace+0x16/0x20
[   42.398005]  save_stack+0x46/0xd0
[   42.398267]  kasan_kmalloc+0xad/0xe0
[   42.398548]  kasan_slab_alloc+0x12/0x20
[   42.398848]  __kmalloc_node_track_caller+0xcb/0x380
[   42.399224]  __kmalloc_reserve.isra.32+0x41/0xe0
[   42.399654]  __alloc_skb+0xf8/0x580
[   42.400003]  sock_wmalloc+0xab/0xf0
[   42.400346]  __ip6_append_data.isra.41+0x2472/0x33d0
[   42.400813]  ip6_append_data+0x1a8/0x2f0
[   42.401122]  rawv6_sendmsg+0x11ee/0x2db0
[   42.401505]  inet_sendmsg+0x123/0x500
[   42.401860]  sock_sendmsg+0xca/0x110
[   42.402209]  ___sys_sendmsg+0x7cb/0x930
[   42.402582]  __sys_sendmsg+0xd9/0x190
[   42.402941]  SyS_sendmsg+0x2d/0x50
[   42.403273]  entry_SYSCALL_64_fastpath+0x1f/0xbe
[   42.403718]
[   42.403871] Freed by task 1794:
[   42.404146]  save_stack_trace+0x16/0x20
[   42.404515]  save_stack+0x46/0xd0
[   42.404827]  kasan_slab_free+0x72/0xc0
[   42.405167]  kfree+0xe8/0x2b0
[   42.405462]  skb_free_head+0x74/0xb0
[   42.405806]  skb_release_data+0x30e/0x3a0
[   42.406198]  skb_release_all+0x4a/0x60
[   42.406563]  consume_skb+0x113/0x2e0
[   42.406910]  skb_free_datagram+0x1a/0xe0
[   42.407288]  netlink_recvmsg+0x60d/0xe40
[   42.407667]  sock_recvmsg+0xd7/0x110
[   42.408022]  ___sys_recvmsg+0x25c/0x580
[   42.408395]  __sys_recvmsg+0xd6/0x190
[   42.408753]  SyS_recvmsg+0x2d/0x50
[   42.409086]  entry_SYSCALL_64_fastpath+0x1f/0xbe
[   42.409513]
[   42.409665] The buggy address belongs to the object at ffff88000969e780
[   42.409665]  which belongs to the cache kmalloc-512 of size 512
[   42.410846] The buggy address is located 24 bytes inside of
[   42.410846]  512-byte region [ffff88000969e780, ffff88000969e980)
[   42.411941] The buggy address belongs to the page:
[   42.412405] page:ffffea000025a780 count:1 mapcount:0 mapping:          (null) index:0x0 compound_mapcount: 0
[   42.413298] flags: 0x100000000008100(slab|head)
[   42.413729] raw: 0100000000008100 0000000000000000 0000000000000000 00000001800c000c
[   42.414387] raw: ffffea00002a9500 0000000900000007 ffff88000c401280 0000000000000000
[   42.415074] page dumped because: kasan: bad access detected
[   42.415604]
[   42.415757] Memory state around the buggy address:
[   42.416222]  ffff88000969e880: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[   42.416904]  ffff88000969e900: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[   42.417591] >ffff88000969e980: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
[   42.418273]                    ^
[   42.418588]  ffff88000969ea00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
[   42.419273]  ffff88000969ea80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
[   42.419882] ==================================================================

Reported-by: Andrey Konovalov <andreyknvl@google.com>
Signed-off-by: Craig Gallek <kraig@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",2423496af35d94a87156b063ea5cedffc10a70a1,https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1,net/ipv6/output_core.c,ip6_find_1stfragopt,"int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)
{
u16 offset = sizeof(struct ipv6hdr);
struct ipv6_opt_hdr *exthdr =
(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);
unsigned int packet_len = skb_tail_pointer(skb) -
skb_network_header(skb);
int found_rhdr = 0;
*nexthdr = &ipv6_hdr(skb)->nexthdr;
while (offset + 1 <= packet_len) {
switch (**nexthdr) {
case NEXTHDR_HOP:
break;
case NEXTHDR_ROUTING:
found_rhdr = 1;
break;
case NEXTHDR_DEST:
#if IS_ENABLED(CONFIG_IPV6_MIP6)
if (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)
break;
#endif
if (found_rhdr)
return offset;
break;
default:
return offset;
}
offset += ipv6_optlen(exthdr);
*nexthdr = &exthdr->nexthdr;
exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +
offset);
}
return offset;
}","int ip6_find_1stfragopt(struct sk_buff *VAR_0, u8 **VAR_1)
{
u16 VAR_2 = sizeof(struct ipv6hdr);
struct ipv6_opt_hdr *VAR_3 =
(struct ipv6_opt_hdr *)(ipv6_hdr(VAR_0) + 1);
unsigned int VAR_4 = skb_tail_pointer(VAR_0) -
skb_network_header(VAR_0);
int VAR_5 = 0;
*VAR_1 = &ipv6_hdr(VAR_0)->nexthdr;
while (VAR_2 + 1 <= VAR_4) {
switch (**VAR_1) {
case VAR_6:
break;
case VAR_7:
VAR_5 = 1;
break;
case VAR_8:
#if IS_ENABLED(VAR_9)
if (ipv6_find_tlv(VAR_0, VAR_2, VAR_10) >= 0)
break;
#endif
if (VAR_5)
return VAR_2;
break;
default:
return VAR_2;
}
VAR_2 += ipv6_optlen(VAR_3);
*VAR_1 = &VAR_3->nexthdr;
VAR_3 = (struct ipv6_opt_hdr *)(skb_network_header(VAR_0) +
VAR_2);
}
return VAR_2;
}",torvalds/linux/2423496af35d94a87156b063ea5cedffc10a70a1/output_core.c/vul/before/0.json,"int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)
{
	u16 offset = sizeof(struct ipv6hdr);
	unsigned int packet_len = skb_tail_pointer(skb) -
		skb_network_header(skb);
	int found_rhdr = 0;
	*nexthdr = &ipv6_hdr(skb)->nexthdr;

	while (offset <= packet_len) {
		struct ipv6_opt_hdr *exthdr;

		switch (**nexthdr) {

		case NEXTHDR_HOP:
			break;
		case NEXTHDR_ROUTING:
			found_rhdr = 1;
			break;
		case NEXTHDR_DEST:
#if IS_ENABLED(CONFIG_IPV6_MIP6)
			if (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)
				break;
#endif
			if (found_rhdr)
				return offset;
			break;
		default:
			return offset;
		}

		if (offset + sizeof(struct ipv6_opt_hdr) > packet_len)
			return -EINVAL;

		exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +
						 offset);
		offset += ipv6_optlen(exthdr);
		*nexthdr = &exthdr->nexthdr;
	}

	return -EINVAL;
}","int ip6_find_1stfragopt(struct sk_buff *VAR_0, u8 **VAR_1)
{
	u16 VAR_2 = sizeof(struct ipv6hdr);
	unsigned int VAR_3 = skb_tail_pointer(VAR_0) -
		skb_network_header(VAR_0);
	int VAR_4 = 0;
	*VAR_1 = &ipv6_hdr(VAR_0)->nexthdr;

	while (VAR_2 <= VAR_3) {
		struct ipv6_opt_hdr *VAR_5;

		switch (**VAR_1) {

		case VAR_6:
			break;
		case VAR_7:
			VAR_4 = 1;
			break;
		case VAR_8:
#if IS_ENABLED(VAR_9)
			if (ipv6_find_tlv(VAR_0, VAR_2, VAR_10) >= 0)
				break;
#endif
			if (VAR_4)
				return VAR_2;
			break;
		default:
			return VAR_2;
		}

		if (VAR_2 + sizeof(struct ipv6_opt_hdr) > VAR_3)
			return -VAR_11;

		VAR_5 = (struct ipv6_opt_hdr *)(skb_network_header(VAR_0) +
						 VAR_2);
		VAR_2 += ipv6_optlen(VAR_5);
		*VAR_1 = &VAR_5->nexthdr;
	}

	return -VAR_11;
}",torvalds/linux/2423496af35d94a87156b063ea5cedffc10a70a1/output_core.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,14 +1,13 @@
 int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)
 {
 	u16 offset = sizeof(struct ipv6hdr);
-	struct ipv6_opt_hdr *exthdr =
-				(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);
 	unsigned int packet_len = skb_tail_pointer(skb) -
 		skb_network_header(skb);
 	int found_rhdr = 0;
 	*nexthdr = &ipv6_hdr(skb)->nexthdr;
 
-	while (offset + 1 <= packet_len) {
+	while (offset <= packet_len) {
+		struct ipv6_opt_hdr *exthdr;
 
 		switch (**nexthdr) {
 
@@ -29,11 +28,14 @@
 			return offset;
 		}
 
+		if (offset + sizeof(struct ipv6_opt_hdr) > packet_len)
+			return -EINVAL;
+
+		exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +
+						 offset);
 		offset += ipv6_optlen(exthdr);
 		*nexthdr = &exthdr->nexthdr;
-		exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +
-						 offset);
 	}
 
-	return offset;
+	return -EINVAL;
 }","{'deleted_lines': ['\tstruct ipv6_opt_hdr *exthdr =', '\t\t\t\t(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);', '\twhile (offset + 1 <= packet_len) {', '\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +', '\t\t\t\t\t\t offset);', '\treturn offset;'], 'added_lines': ['\twhile (offset <= packet_len) {', '\t\tstruct ipv6_opt_hdr *exthdr;', '\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)', '\t\t\treturn -EINVAL;', '', '\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +', '\t\t\t\t\t\t offset);', '\treturn -EINVAL;']}",True,"The IPv6 fragmentation implementation in the Linux kernel through 4.11.1 does not consider that the nexthdr field may be associated with an invalid option, which allows local users to cause a denial of service (out-of-bounds read and BUG) or possibly have unspecified other impact via crafted socket and send system calls.",7.8,HIGH,2,test,2017-05-16T18:36:23Z,1
CVE-2017-9074,['CWE-125'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"ipv6: Prevent overrun when parsing v6 header options

The KASAN warning repoted below was discovered with a syzkaller
program.  The reproducer is basically:
  int s = socket(AF_INET6, SOCK_RAW, NEXTHDR_HOP);
  send(s, &one_byte_of_data, 1, MSG_MORE);
  send(s, &more_than_mtu_bytes_data, 2000, 0);

The socket() call sets the nexthdr field of the v6 header to
NEXTHDR_HOP, the first send call primes the payload with a non zero
byte of data, and the second send call triggers the fragmentation path.

The fragmentation code tries to parse the header options in order
to figure out where to insert the fragment option.  Since nexthdr points
to an invalid option, the calculation of the size of the network header
can made to be much larger than the linear section of the skb and data
is read outside of it.

This fix makes ip6_find_1stfrag return an error if it detects
running out-of-bounds.

[   42.361487] ==================================================================
[   42.364412] BUG: KASAN: slab-out-of-bounds in ip6_fragment+0x11c8/0x3730
[   42.365471] Read of size 840 at addr ffff88000969e798 by task ip6_fragment-oo/3789
[   42.366469]
[   42.366696] CPU: 1 PID: 3789 Comm: ip6_fragment-oo Not tainted 4.11.0+ #41
[   42.367628] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.1-1ubuntu1 04/01/2014
[   42.368824] Call Trace:
[   42.369183]  dump_stack+0xb3/0x10b
[   42.369664]  print_address_description+0x73/0x290
[   42.370325]  kasan_report+0x252/0x370
[   42.370839]  ? ip6_fragment+0x11c8/0x3730
[   42.371396]  check_memory_region+0x13c/0x1a0
[   42.371978]  memcpy+0x23/0x50
[   42.372395]  ip6_fragment+0x11c8/0x3730
[   42.372920]  ? nf_ct_expect_unregister_notifier+0x110/0x110
[   42.373681]  ? ip6_copy_metadata+0x7f0/0x7f0
[   42.374263]  ? ip6_forward+0x2e30/0x2e30
[   42.374803]  ip6_finish_output+0x584/0x990
[   42.375350]  ip6_output+0x1b7/0x690
[   42.375836]  ? ip6_finish_output+0x990/0x990
[   42.376411]  ? ip6_fragment+0x3730/0x3730
[   42.376968]  ip6_local_out+0x95/0x160
[   42.377471]  ip6_send_skb+0xa1/0x330
[   42.377969]  ip6_push_pending_frames+0xb3/0xe0
[   42.378589]  rawv6_sendmsg+0x2051/0x2db0
[   42.379129]  ? rawv6_bind+0x8b0/0x8b0
[   42.379633]  ? _copy_from_user+0x84/0xe0
[   42.380193]  ? debug_check_no_locks_freed+0x290/0x290
[   42.380878]  ? ___sys_sendmsg+0x162/0x930
[   42.381427]  ? rcu_read_lock_sched_held+0xa3/0x120
[   42.382074]  ? sock_has_perm+0x1f6/0x290
[   42.382614]  ? ___sys_sendmsg+0x167/0x930
[   42.383173]  ? lock_downgrade+0x660/0x660
[   42.383727]  inet_sendmsg+0x123/0x500
[   42.384226]  ? inet_sendmsg+0x123/0x500
[   42.384748]  ? inet_recvmsg+0x540/0x540
[   42.385263]  sock_sendmsg+0xca/0x110
[   42.385758]  SYSC_sendto+0x217/0x380
[   42.386249]  ? SYSC_connect+0x310/0x310
[   42.386783]  ? __might_fault+0x110/0x1d0
[   42.387324]  ? lock_downgrade+0x660/0x660
[   42.387880]  ? __fget_light+0xa1/0x1f0
[   42.388403]  ? __fdget+0x18/0x20
[   42.388851]  ? sock_common_setsockopt+0x95/0xd0
[   42.389472]  ? SyS_setsockopt+0x17f/0x260
[   42.390021]  ? entry_SYSCALL_64_fastpath+0x5/0xbe
[   42.390650]  SyS_sendto+0x40/0x50
[   42.391103]  entry_SYSCALL_64_fastpath+0x1f/0xbe
[   42.391731] RIP: 0033:0x7fbbb711e383
[   42.392217] RSP: 002b:00007ffff4d34f28 EFLAGS: 00000246 ORIG_RAX: 000000000000002c
[   42.393235] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fbbb711e383
[   42.394195] RDX: 0000000000001000 RSI: 00007ffff4d34f60 RDI: 0000000000000003
[   42.395145] RBP: 0000000000000046 R08: 00007ffff4d34f40 R09: 0000000000000018
[   42.396056] R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000400aad
[   42.396598] R13: 0000000000000066 R14: 00007ffff4d34ee0 R15: 00007fbbb717af00
[   42.397257]
[   42.397411] Allocated by task 3789:
[   42.397702]  save_stack_trace+0x16/0x20
[   42.398005]  save_stack+0x46/0xd0
[   42.398267]  kasan_kmalloc+0xad/0xe0
[   42.398548]  kasan_slab_alloc+0x12/0x20
[   42.398848]  __kmalloc_node_track_caller+0xcb/0x380
[   42.399224]  __kmalloc_reserve.isra.32+0x41/0xe0
[   42.399654]  __alloc_skb+0xf8/0x580
[   42.400003]  sock_wmalloc+0xab/0xf0
[   42.400346]  __ip6_append_data.isra.41+0x2472/0x33d0
[   42.400813]  ip6_append_data+0x1a8/0x2f0
[   42.401122]  rawv6_sendmsg+0x11ee/0x2db0
[   42.401505]  inet_sendmsg+0x123/0x500
[   42.401860]  sock_sendmsg+0xca/0x110
[   42.402209]  ___sys_sendmsg+0x7cb/0x930
[   42.402582]  __sys_sendmsg+0xd9/0x190
[   42.402941]  SyS_sendmsg+0x2d/0x50
[   42.403273]  entry_SYSCALL_64_fastpath+0x1f/0xbe
[   42.403718]
[   42.403871] Freed by task 1794:
[   42.404146]  save_stack_trace+0x16/0x20
[   42.404515]  save_stack+0x46/0xd0
[   42.404827]  kasan_slab_free+0x72/0xc0
[   42.405167]  kfree+0xe8/0x2b0
[   42.405462]  skb_free_head+0x74/0xb0
[   42.405806]  skb_release_data+0x30e/0x3a0
[   42.406198]  skb_release_all+0x4a/0x60
[   42.406563]  consume_skb+0x113/0x2e0
[   42.406910]  skb_free_datagram+0x1a/0xe0
[   42.407288]  netlink_recvmsg+0x60d/0xe40
[   42.407667]  sock_recvmsg+0xd7/0x110
[   42.408022]  ___sys_recvmsg+0x25c/0x580
[   42.408395]  __sys_recvmsg+0xd6/0x190
[   42.408753]  SyS_recvmsg+0x2d/0x50
[   42.409086]  entry_SYSCALL_64_fastpath+0x1f/0xbe
[   42.409513]
[   42.409665] The buggy address belongs to the object at ffff88000969e780
[   42.409665]  which belongs to the cache kmalloc-512 of size 512
[   42.410846] The buggy address is located 24 bytes inside of
[   42.410846]  512-byte region [ffff88000969e780, ffff88000969e980)
[   42.411941] The buggy address belongs to the page:
[   42.412405] page:ffffea000025a780 count:1 mapcount:0 mapping:          (null) index:0x0 compound_mapcount: 0
[   42.413298] flags: 0x100000000008100(slab|head)
[   42.413729] raw: 0100000000008100 0000000000000000 0000000000000000 00000001800c000c
[   42.414387] raw: ffffea00002a9500 0000000900000007 ffff88000c401280 0000000000000000
[   42.415074] page dumped because: kasan: bad access detected
[   42.415604]
[   42.415757] Memory state around the buggy address:
[   42.416222]  ffff88000969e880: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[   42.416904]  ffff88000969e900: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[   42.417591] >ffff88000969e980: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
[   42.418273]                    ^
[   42.418588]  ffff88000969ea00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
[   42.419273]  ffff88000969ea80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
[   42.419882] ==================================================================

Reported-by: Andrey Konovalov <andreyknvl@google.com>
Signed-off-by: Craig Gallek <kraig@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",2423496af35d94a87156b063ea5cedffc10a70a1,https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1,net/ipv6/udp_offload.c,udp6_ufo_fragment,"static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,
netdev_features_t features)
{
struct sk_buff *segs = ERR_PTR(-EINVAL);
unsigned int mss;
unsigned int unfrag_ip6hlen, unfrag_len;
struct frag_hdr *fptr;
u8 *packet_start, *prevhdr;
u8 nexthdr;
u8 frag_hdr_sz = sizeof(struct frag_hdr);
__wsum csum;
int tnl_hlen;
mss = skb_shinfo(skb)->gso_size;
if (unlikely(skb->len <= mss))
goto out;
if (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {
skb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);
if (!skb_shinfo(skb)->ip6_frag_id)
ipv6_proxy_select_ident(dev_net(skb->dev), skb);
segs = NULL;
goto out;
}
if (skb->encapsulation && skb_shinfo(skb)->gso_type &
(SKB_GSO_UDP_TUNNEL|SKB_GSO_UDP_TUNNEL_CSUM))
segs = skb_udp_tunnel_segment(skb, features, true);
else {
const struct ipv6hdr *ipv6h;
struct udphdr *uh;
if (!pskb_may_pull(skb, sizeof(struct udphdr)))
goto out;
uh = udp_hdr(skb);
ipv6h = ipv6_hdr(skb);
uh->check = 0;
csum = skb_checksum(skb, 0, skb->len, 0);
uh->check = udp_v6_check(skb->len, &ipv6h->saddr,
&ipv6h->daddr, csum);
if (uh->check == 0)
uh->check = CSUM_MANGLED_0;
skb->ip_summed = CHECKSUM_NONE;
if (!skb->encap_hdr_csum)
features |= NETIF_F_HW_CSUM;
tnl_hlen = skb_tnl_header_len(skb);
if (skb->mac_header < (tnl_hlen + frag_hdr_sz)) {
if (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz))
goto out;
}
unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);
nexthdr = *prevhdr;
*prevhdr = NEXTHDR_FRAGMENT;
unfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +
unfrag_ip6hlen + tnl_hlen;
packet_start = (u8 *) skb->head + SKB_GSO_CB(skb)->mac_offset;
memmove(packet_start-frag_hdr_sz, packet_start, unfrag_len);
SKB_GSO_CB(skb)->mac_offset -= frag_hdr_sz;
skb->mac_header -= frag_hdr_sz;
skb->network_header -= frag_hdr_sz;
fptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);
fptr->nexthdr = nexthdr;
fptr->reserved = 0;
if (!skb_shinfo(skb)->ip6_frag_id)
ipv6_proxy_select_ident(dev_net(skb->dev), skb);
fptr->identification = skb_shinfo(skb)->ip6_frag_id;
segs = skb_segment(skb, features);
}
out:
return segs;
}","static struct sk_buff *udp6_ufo_fragment(struct sk_buff *VAR_0,
netdev_features_t VAR_1)
{
struct sk_buff *VAR_2 = ERR_PTR(-VAR_3);
unsigned int VAR_4;
unsigned int VAR_5, VAR_6;
struct frag_hdr *VAR_7;
u8 *VAR_8, *VAR_9;
u8 VAR_10;
u8 VAR_11 = sizeof(struct frag_hdr);
__wsum VAR_12;
int VAR_13;
VAR_4 = skb_shinfo(VAR_0)->gso_size;
if (unlikely(VAR_0->len <= VAR_4))
goto out;
if (skb_gso_ok(VAR_0, VAR_1 | VAR_14)) {
skb_shinfo(VAR_0)->gso_segs = DIV_ROUND_UP(VAR_0->len, VAR_4);
if (!skb_shinfo(VAR_0)->ip6_frag_id)
ipv6_proxy_select_ident(dev_net(VAR_0->dev), VAR_0);
VAR_2 = NULL;
goto out;
}
if (VAR_0->encapsulation && skb_shinfo(VAR_0)->gso_type &
(VAR_15|VAR_16))
VAR_2 = skb_udp_tunnel_segment(VAR_0, VAR_1, true);
else {
const struct ipv6hdr *VAR_17;
struct udphdr *VAR_18;
if (!pskb_may_pull(VAR_0, sizeof(struct udphdr)))
goto out;
VAR_18 = udp_hdr(VAR_0);
VAR_17 = ipv6_hdr(VAR_0);
VAR_18->check = 0;
VAR_12 = skb_checksum(VAR_0, 0, VAR_0->len, 0);
VAR_18->check = udp_v6_check(VAR_0->len, &VAR_17->saddr,
&VAR_17->daddr, VAR_12);
if (VAR_18->check == 0)
VAR_18->check = VAR_19;
VAR_0->ip_summed = VAR_20;
if (!VAR_0->encap_hdr_csum)
VAR_1 |= VAR_21;
VAR_13 = skb_tnl_header_len(VAR_0);
if (VAR_0->mac_header < (VAR_13 + VAR_11)) {
if (gso_pskb_expand_head(VAR_0, VAR_13 + VAR_11))
goto out;
}
VAR_5 = ip6_find_1stfragopt(VAR_0, &VAR_9);
VAR_10 = *VAR_9;
*VAR_9 = VAR_22;
VAR_6 = (skb_network_header(VAR_0) - skb_mac_header(VAR_0)) +
VAR_5 + VAR_13;
VAR_8 = (u8 *) VAR_0->head + SKB_GSO_CB(VAR_0)->mac_offset;
memmove(VAR_8-VAR_11, VAR_8, VAR_6);
SKB_GSO_CB(VAR_0)->mac_offset -= VAR_11;
VAR_0->mac_header -= VAR_11;
VAR_0->network_header -= VAR_11;
VAR_7 = (struct frag_hdr *)(skb_network_header(VAR_0) + VAR_5);
VAR_7->nexthdr = VAR_10;
VAR_7->reserved = 0;
if (!skb_shinfo(VAR_0)->ip6_frag_id)
ipv6_proxy_select_ident(dev_net(VAR_0->dev), VAR_0);
VAR_7->identification = skb_shinfo(VAR_0)->ip6_frag_id;
VAR_2 = skb_segment(VAR_0, VAR_1);
}
out:
return VAR_2;
}",torvalds/linux/2423496af35d94a87156b063ea5cedffc10a70a1/udp_offload.c/vul/before/0.json,"static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,
					 netdev_features_t features)
{
	struct sk_buff *segs = ERR_PTR(-EINVAL);
	unsigned int mss;
	unsigned int unfrag_ip6hlen, unfrag_len;
	struct frag_hdr *fptr;
	u8 *packet_start, *prevhdr;
	u8 nexthdr;
	u8 frag_hdr_sz = sizeof(struct frag_hdr);
	__wsum csum;
	int tnl_hlen;

	mss = skb_shinfo(skb)->gso_size;
	if (unlikely(skb->len <= mss))
		goto out;

	if (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {
		/* Packet is from an untrusted source, reset gso_segs. */

		skb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);

		/* Set the IPv6 fragment id if not set yet */
		if (!skb_shinfo(skb)->ip6_frag_id)
			ipv6_proxy_select_ident(dev_net(skb->dev), skb);

		segs = NULL;
		goto out;
	}

	if (skb->encapsulation && skb_shinfo(skb)->gso_type &
	    (SKB_GSO_UDP_TUNNEL|SKB_GSO_UDP_TUNNEL_CSUM))
		segs = skb_udp_tunnel_segment(skb, features, true);
	else {
		const struct ipv6hdr *ipv6h;
		struct udphdr *uh;

		if (!pskb_may_pull(skb, sizeof(struct udphdr)))
			goto out;

		/* Do software UFO. Complete and fill in the UDP checksum as HW cannot
		 * do checksum of UDP packets sent as multiple IP fragments.
		 */

		uh = udp_hdr(skb);
		ipv6h = ipv6_hdr(skb);

		uh->check = 0;
		csum = skb_checksum(skb, 0, skb->len, 0);
		uh->check = udp_v6_check(skb->len, &ipv6h->saddr,
					  &ipv6h->daddr, csum);
		if (uh->check == 0)
			uh->check = CSUM_MANGLED_0;

		skb->ip_summed = CHECKSUM_NONE;

		/* If there is no outer header we can fake a checksum offload
		 * due to the fact that we have already done the checksum in
		 * software prior to segmenting the frame.
		 */
		if (!skb->encap_hdr_csum)
			features |= NETIF_F_HW_CSUM;

		/* Check if there is enough headroom to insert fragment header. */
		tnl_hlen = skb_tnl_header_len(skb);
		if (skb->mac_header < (tnl_hlen + frag_hdr_sz)) {
			if (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz))
				goto out;
		}

		/* Find the unfragmentable header and shift it left by frag_hdr_sz
		 * bytes to insert fragment header.
		 */
		unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);
		if (unfrag_ip6hlen < 0)
			return ERR_PTR(unfrag_ip6hlen);
		nexthdr = *prevhdr;
		*prevhdr = NEXTHDR_FRAGMENT;
		unfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +
			     unfrag_ip6hlen + tnl_hlen;
		packet_start = (u8 *) skb->head + SKB_GSO_CB(skb)->mac_offset;
		memmove(packet_start-frag_hdr_sz, packet_start, unfrag_len);

		SKB_GSO_CB(skb)->mac_offset -= frag_hdr_sz;
		skb->mac_header -= frag_hdr_sz;
		skb->network_header -= frag_hdr_sz;

		fptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);
		fptr->nexthdr = nexthdr;
		fptr->reserved = 0;
		if (!skb_shinfo(skb)->ip6_frag_id)
			ipv6_proxy_select_ident(dev_net(skb->dev), skb);
		fptr->identification = skb_shinfo(skb)->ip6_frag_id;

		/* Fragment the skb. ipv6 header and the remaining fields of the
		 * fragment header are updated in ipv6_gso_segment()
		 */
		segs = skb_segment(skb, features);
	}

out:
	return segs;
}","static struct sk_buff *udp6_ufo_fragment(struct sk_buff *VAR_0,
					 netdev_features_t VAR_1)
{
	struct sk_buff *VAR_2 = ERR_PTR(-VAR_3);
	unsigned int VAR_4;
	unsigned int VAR_5, VAR_6;
	struct frag_hdr *VAR_7;
	u8 *VAR_8, *VAR_9;
	u8 VAR_10;
	u8 VAR_11 = sizeof(struct frag_hdr);
	__wsum VAR_12;
	int VAR_13;

	VAR_4 = skb_shinfo(VAR_0)->gso_size;
	if (unlikely(VAR_0->len <= VAR_4))
		goto out;

	if (skb_gso_ok(VAR_0, VAR_1 | VAR_14)) {
		/* COMMENT_0 */

		skb_shinfo(VAR_0)->gso_segs = DIV_ROUND_UP(VAR_0->len, VAR_4);

		/* COMMENT_1 */
		if (!skb_shinfo(VAR_0)->ip6_frag_id)
			ipv6_proxy_select_ident(dev_net(VAR_0->dev), VAR_0);

		VAR_2 = NULL;
		goto out;
	}

	if (VAR_0->encapsulation && skb_shinfo(VAR_0)->gso_type &
	    (VAR_15|VAR_16))
		VAR_2 = skb_udp_tunnel_segment(VAR_0, VAR_1, true);
	else {
		const struct ipv6hdr *VAR_17;
		struct udphdr *VAR_18;

		if (!pskb_may_pull(VAR_0, sizeof(struct udphdr)))
			goto out;

		/* COMMENT_2 */
                                                              
     

		VAR_18 = udp_hdr(VAR_0);
		VAR_17 = ipv6_hdr(VAR_0);

		VAR_18->check = 0;
		VAR_12 = skb_checksum(VAR_0, 0, VAR_0->len, 0);
		VAR_18->check = udp_v6_check(VAR_0->len, &VAR_17->saddr,
					  &VAR_17->daddr, VAR_12);
		if (VAR_18->check == 0)
			VAR_18->check = VAR_19;

		VAR_0->ip_summed = VAR_20;

		/* COMMENT_5 */
                                                              
                                            
     
		if (!VAR_0->encap_hdr_csum)
			VAR_1 |= VAR_21;

		/* COMMENT_9 */
		VAR_13 = skb_tnl_header_len(VAR_0);
		if (VAR_0->mac_header < (VAR_13 + VAR_11)) {
			if (gso_pskb_expand_head(VAR_0, VAR_13 + VAR_11))
				goto out;
		}

		/* COMMENT_10 */
                                     
     
		VAR_5 = ip6_find_1stfragopt(VAR_0, &VAR_9);
		if (VAR_5 < 0)
			return ERR_PTR(VAR_5);
		VAR_10 = *VAR_9;
		*VAR_9 = VAR_22;
		VAR_6 = (skb_network_header(VAR_0) - skb_mac_header(VAR_0)) +
			     VAR_5 + VAR_13;
		VAR_8 = (u8 *) VAR_0->head + SKB_GSO_CB(VAR_0)->mac_offset;
		memmove(VAR_8-VAR_11, VAR_8, VAR_6);

		SKB_GSO_CB(VAR_0)->mac_offset -= VAR_11;
		VAR_0->mac_header -= VAR_11;
		VAR_0->network_header -= VAR_11;

		VAR_7 = (struct frag_hdr *)(skb_network_header(VAR_0) + VAR_5);
		VAR_7->nexthdr = VAR_10;
		VAR_7->reserved = 0;
		if (!skb_shinfo(VAR_0)->ip6_frag_id)
			ipv6_proxy_select_ident(dev_net(VAR_0->dev), VAR_0);
		VAR_7->identification = skb_shinfo(VAR_0)->ip6_frag_id;

		/* COMMENT_13 */
                                                      
     
		VAR_2 = skb_segment(VAR_0, VAR_1);
	}

out:
	return VAR_2;
}",torvalds/linux/2423496af35d94a87156b063ea5cedffc10a70a1/udp_offload.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -72,6 +72,8 @@
 		 * bytes to insert fragment header.
 		 */
 		unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);
+		if (unfrag_ip6hlen < 0)
+			return ERR_PTR(unfrag_ip6hlen);
 		nexthdr = *prevhdr;
 		*prevhdr = NEXTHDR_FRAGMENT;
 		unfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +","{'deleted_lines': [], 'added_lines': ['\t\tif (unfrag_ip6hlen < 0)', '\t\t\treturn ERR_PTR(unfrag_ip6hlen);']}",True,"The IPv6 fragmentation implementation in the Linux kernel through 4.11.1 does not consider that the nexthdr field may be associated with an invalid option, which allows local users to cause a denial of service (out-of-bounds read and BUG) or possibly have unspecified other impact via crafted socket and send system calls.",7.8,HIGH,2,test,2017-05-16T18:36:23Z,1
CVE-2017-9074,['CWE-125'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"ipv6: Prevent overrun when parsing v6 header options

The KASAN warning repoted below was discovered with a syzkaller
program.  The reproducer is basically:
  int s = socket(AF_INET6, SOCK_RAW, NEXTHDR_HOP);
  send(s, &one_byte_of_data, 1, MSG_MORE);
  send(s, &more_than_mtu_bytes_data, 2000, 0);

The socket() call sets the nexthdr field of the v6 header to
NEXTHDR_HOP, the first send call primes the payload with a non zero
byte of data, and the second send call triggers the fragmentation path.

The fragmentation code tries to parse the header options in order
to figure out where to insert the fragment option.  Since nexthdr points
to an invalid option, the calculation of the size of the network header
can made to be much larger than the linear section of the skb and data
is read outside of it.

This fix makes ip6_find_1stfrag return an error if it detects
running out-of-bounds.

[   42.361487] ==================================================================
[   42.364412] BUG: KASAN: slab-out-of-bounds in ip6_fragment+0x11c8/0x3730
[   42.365471] Read of size 840 at addr ffff88000969e798 by task ip6_fragment-oo/3789
[   42.366469]
[   42.366696] CPU: 1 PID: 3789 Comm: ip6_fragment-oo Not tainted 4.11.0+ #41
[   42.367628] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.1-1ubuntu1 04/01/2014
[   42.368824] Call Trace:
[   42.369183]  dump_stack+0xb3/0x10b
[   42.369664]  print_address_description+0x73/0x290
[   42.370325]  kasan_report+0x252/0x370
[   42.370839]  ? ip6_fragment+0x11c8/0x3730
[   42.371396]  check_memory_region+0x13c/0x1a0
[   42.371978]  memcpy+0x23/0x50
[   42.372395]  ip6_fragment+0x11c8/0x3730
[   42.372920]  ? nf_ct_expect_unregister_notifier+0x110/0x110
[   42.373681]  ? ip6_copy_metadata+0x7f0/0x7f0
[   42.374263]  ? ip6_forward+0x2e30/0x2e30
[   42.374803]  ip6_finish_output+0x584/0x990
[   42.375350]  ip6_output+0x1b7/0x690
[   42.375836]  ? ip6_finish_output+0x990/0x990
[   42.376411]  ? ip6_fragment+0x3730/0x3730
[   42.376968]  ip6_local_out+0x95/0x160
[   42.377471]  ip6_send_skb+0xa1/0x330
[   42.377969]  ip6_push_pending_frames+0xb3/0xe0
[   42.378589]  rawv6_sendmsg+0x2051/0x2db0
[   42.379129]  ? rawv6_bind+0x8b0/0x8b0
[   42.379633]  ? _copy_from_user+0x84/0xe0
[   42.380193]  ? debug_check_no_locks_freed+0x290/0x290
[   42.380878]  ? ___sys_sendmsg+0x162/0x930
[   42.381427]  ? rcu_read_lock_sched_held+0xa3/0x120
[   42.382074]  ? sock_has_perm+0x1f6/0x290
[   42.382614]  ? ___sys_sendmsg+0x167/0x930
[   42.383173]  ? lock_downgrade+0x660/0x660
[   42.383727]  inet_sendmsg+0x123/0x500
[   42.384226]  ? inet_sendmsg+0x123/0x500
[   42.384748]  ? inet_recvmsg+0x540/0x540
[   42.385263]  sock_sendmsg+0xca/0x110
[   42.385758]  SYSC_sendto+0x217/0x380
[   42.386249]  ? SYSC_connect+0x310/0x310
[   42.386783]  ? __might_fault+0x110/0x1d0
[   42.387324]  ? lock_downgrade+0x660/0x660
[   42.387880]  ? __fget_light+0xa1/0x1f0
[   42.388403]  ? __fdget+0x18/0x20
[   42.388851]  ? sock_common_setsockopt+0x95/0xd0
[   42.389472]  ? SyS_setsockopt+0x17f/0x260
[   42.390021]  ? entry_SYSCALL_64_fastpath+0x5/0xbe
[   42.390650]  SyS_sendto+0x40/0x50
[   42.391103]  entry_SYSCALL_64_fastpath+0x1f/0xbe
[   42.391731] RIP: 0033:0x7fbbb711e383
[   42.392217] RSP: 002b:00007ffff4d34f28 EFLAGS: 00000246 ORIG_RAX: 000000000000002c
[   42.393235] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fbbb711e383
[   42.394195] RDX: 0000000000001000 RSI: 00007ffff4d34f60 RDI: 0000000000000003
[   42.395145] RBP: 0000000000000046 R08: 00007ffff4d34f40 R09: 0000000000000018
[   42.396056] R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000400aad
[   42.396598] R13: 0000000000000066 R14: 00007ffff4d34ee0 R15: 00007fbbb717af00
[   42.397257]
[   42.397411] Allocated by task 3789:
[   42.397702]  save_stack_trace+0x16/0x20
[   42.398005]  save_stack+0x46/0xd0
[   42.398267]  kasan_kmalloc+0xad/0xe0
[   42.398548]  kasan_slab_alloc+0x12/0x20
[   42.398848]  __kmalloc_node_track_caller+0xcb/0x380
[   42.399224]  __kmalloc_reserve.isra.32+0x41/0xe0
[   42.399654]  __alloc_skb+0xf8/0x580
[   42.400003]  sock_wmalloc+0xab/0xf0
[   42.400346]  __ip6_append_data.isra.41+0x2472/0x33d0
[   42.400813]  ip6_append_data+0x1a8/0x2f0
[   42.401122]  rawv6_sendmsg+0x11ee/0x2db0
[   42.401505]  inet_sendmsg+0x123/0x500
[   42.401860]  sock_sendmsg+0xca/0x110
[   42.402209]  ___sys_sendmsg+0x7cb/0x930
[   42.402582]  __sys_sendmsg+0xd9/0x190
[   42.402941]  SyS_sendmsg+0x2d/0x50
[   42.403273]  entry_SYSCALL_64_fastpath+0x1f/0xbe
[   42.403718]
[   42.403871] Freed by task 1794:
[   42.404146]  save_stack_trace+0x16/0x20
[   42.404515]  save_stack+0x46/0xd0
[   42.404827]  kasan_slab_free+0x72/0xc0
[   42.405167]  kfree+0xe8/0x2b0
[   42.405462]  skb_free_head+0x74/0xb0
[   42.405806]  skb_release_data+0x30e/0x3a0
[   42.406198]  skb_release_all+0x4a/0x60
[   42.406563]  consume_skb+0x113/0x2e0
[   42.406910]  skb_free_datagram+0x1a/0xe0
[   42.407288]  netlink_recvmsg+0x60d/0xe40
[   42.407667]  sock_recvmsg+0xd7/0x110
[   42.408022]  ___sys_recvmsg+0x25c/0x580
[   42.408395]  __sys_recvmsg+0xd6/0x190
[   42.408753]  SyS_recvmsg+0x2d/0x50
[   42.409086]  entry_SYSCALL_64_fastpath+0x1f/0xbe
[   42.409513]
[   42.409665] The buggy address belongs to the object at ffff88000969e780
[   42.409665]  which belongs to the cache kmalloc-512 of size 512
[   42.410846] The buggy address is located 24 bytes inside of
[   42.410846]  512-byte region [ffff88000969e780, ffff88000969e980)
[   42.411941] The buggy address belongs to the page:
[   42.412405] page:ffffea000025a780 count:1 mapcount:0 mapping:          (null) index:0x0 compound_mapcount: 0
[   42.413298] flags: 0x100000000008100(slab|head)
[   42.413729] raw: 0100000000008100 0000000000000000 0000000000000000 00000001800c000c
[   42.414387] raw: ffffea00002a9500 0000000900000007 ffff88000c401280 0000000000000000
[   42.415074] page dumped because: kasan: bad access detected
[   42.415604]
[   42.415757] Memory state around the buggy address:
[   42.416222]  ffff88000969e880: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[   42.416904]  ffff88000969e900: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[   42.417591] >ffff88000969e980: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
[   42.418273]                    ^
[   42.418588]  ffff88000969ea00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
[   42.419273]  ffff88000969ea80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
[   42.419882] ==================================================================

Reported-by: Andrey Konovalov <andreyknvl@google.com>
Signed-off-by: Craig Gallek <kraig@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",2423496af35d94a87156b063ea5cedffc10a70a1,https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1,net/ipv6/ip6_offload.c,ipv6_gso_segment,"static struct sk_buff *ipv6_gso_segment(struct sk_buff *skb,
netdev_features_t features)
{
struct sk_buff *segs = ERR_PTR(-EINVAL);
struct ipv6hdr *ipv6h;
const struct net_offload *ops;
int proto;
struct frag_hdr *fptr;
unsigned int unfrag_ip6hlen;
unsigned int payload_len;
u8 *prevhdr;
int offset = 0;
bool encap, udpfrag;
int nhoff;
bool gso_partial;
skb_reset_network_header(skb);
nhoff = skb_network_header(skb) - skb_mac_header(skb);
if (unlikely(!pskb_may_pull(skb, sizeof(*ipv6h))))
goto out;
encap = SKB_GSO_CB(skb)->encap_level > 0;
if (encap)
features &= skb->dev->hw_enc_features;
SKB_GSO_CB(skb)->encap_level += sizeof(*ipv6h);
ipv6h = ipv6_hdr(skb);
__skb_pull(skb, sizeof(*ipv6h));
segs = ERR_PTR(-EPROTONOSUPPORT);
proto = ipv6_gso_pull_exthdrs(skb, ipv6h->nexthdr);
if (skb->encapsulation &&
skb_shinfo(skb)->gso_type & (SKB_GSO_IPXIP4 | SKB_GSO_IPXIP6))
udpfrag = proto == IPPROTO_UDP && encap;
else
udpfrag = proto == IPPROTO_UDP && !skb->encapsulation;
ops = rcu_dereference(inet6_offloads[proto]);
if (likely(ops && ops->callbacks.gso_segment)) {
skb_reset_transport_header(skb);
segs = ops->callbacks.gso_segment(skb, features);
}
if (IS_ERR_OR_NULL(segs))
goto out;
gso_partial = !!(skb_shinfo(segs)->gso_type & SKB_GSO_PARTIAL);
for (skb = segs; skb; skb = skb->next) {
ipv6h = (struct ipv6hdr *)(skb_mac_header(skb) + nhoff);
if (gso_partial)
payload_len = skb_shinfo(skb)->gso_size +
SKB_GSO_CB(skb)->data_offset +
skb->head - (unsigned char *)(ipv6h + 1);
else
payload_len = skb->len - nhoff - sizeof(*ipv6h);
ipv6h->payload_len = htons(payload_len);
skb->network_header = (u8 *)ipv6h - skb->head;
if (udpfrag) {
unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);
fptr = (struct frag_hdr *)((u8 *)ipv6h + unfrag_ip6hlen);
fptr->frag_off = htons(offset);
if (skb->next)
fptr->frag_off |= htons(IP6_MF);
offset += (ntohs(ipv6h->payload_len) -
sizeof(struct frag_hdr));
}
if (encap)
skb_reset_inner_headers(skb);
}
out:
return segs;
}","static struct sk_buff *ipv6_gso_segment(struct sk_buff *VAR_0,
netdev_features_t VAR_1)
{
struct sk_buff *VAR_2 = ERR_PTR(-VAR_3);
struct ipv6hdr *VAR_4;
const struct net_offload *VAR_5;
int VAR_6;
struct frag_hdr *VAR_7;
unsigned int VAR_8;
unsigned int VAR_9;
u8 *VAR_10;
int VAR_11 = 0;
bool VAR_12, VAR_13;
int VAR_14;
bool VAR_15;
skb_reset_network_header(VAR_0);
VAR_14 = skb_network_header(VAR_0) - skb_mac_header(VAR_0);
if (unlikely(!pskb_may_pull(VAR_0, sizeof(*VAR_4))))
goto out;
VAR_12 = SKB_GSO_CB(VAR_0)->encap_level > 0;
if (VAR_12)
VAR_1 &= VAR_0->dev->hw_enc_features;
SKB_GSO_CB(VAR_0)->encap_level += sizeof(*VAR_4);
VAR_4 = ipv6_hdr(VAR_0);
__skb_pull(VAR_0, sizeof(*VAR_4));
VAR_2 = ERR_PTR(-VAR_16);
VAR_6 = ipv6_gso_pull_exthdrs(VAR_0, VAR_4->nexthdr);
if (VAR_0->encapsulation &&
skb_shinfo(VAR_0)->gso_type & (VAR_17 | VAR_18))
VAR_13 = VAR_6 == VAR_19 && VAR_12;
else
VAR_13 = VAR_6 == VAR_19 && !VAR_0->encapsulation;
VAR_5 = rcu_dereference(VAR_20[VAR_6]);
if (likely(VAR_5 && VAR_5->callbacks.gso_segment)) {
skb_reset_transport_header(VAR_0);
VAR_2 = VAR_5->callbacks.gso_segment(VAR_0, VAR_1);
}
if (IS_ERR_OR_NULL(VAR_2))
goto out;
VAR_15 = !!(skb_shinfo(VAR_2)->gso_type & VAR_21);
for (VAR_0 = VAR_2; VAR_0; VAR_0 = VAR_0->next) {
VAR_4 = (struct ipv6hdr *)(skb_mac_header(VAR_0) + VAR_14);
if (VAR_15)
VAR_9 = skb_shinfo(VAR_0)->gso_size +
SKB_GSO_CB(VAR_0)->data_offset +
VAR_0->head - (unsigned char *)(VAR_4 + 1);
else
VAR_9 = VAR_0->len - VAR_14 - sizeof(*VAR_4);
VAR_4->payload_len = htons(VAR_9);
VAR_0->network_header = (u8 *)VAR_4 - VAR_0->head;
if (VAR_13) {
VAR_8 = ip6_find_1stfragopt(VAR_0, &VAR_10);
VAR_7 = (struct frag_hdr *)((u8 *)VAR_4 + VAR_8);
VAR_7->frag_off = htons(VAR_11);
if (VAR_0->next)
VAR_7->frag_off |= htons(VAR_22);
VAR_11 += (ntohs(VAR_4->payload_len) -
sizeof(struct frag_hdr));
}
if (VAR_12)
skb_reset_inner_headers(VAR_0);
}
out:
return VAR_2;
}",torvalds/linux/2423496af35d94a87156b063ea5cedffc10a70a1/ip6_offload.c/vul/before/0.json,"static struct sk_buff *ipv6_gso_segment(struct sk_buff *skb,
	netdev_features_t features)
{
	struct sk_buff *segs = ERR_PTR(-EINVAL);
	struct ipv6hdr *ipv6h;
	const struct net_offload *ops;
	int proto;
	struct frag_hdr *fptr;
	unsigned int unfrag_ip6hlen;
	unsigned int payload_len;
	u8 *prevhdr;
	int offset = 0;
	bool encap, udpfrag;
	int nhoff;
	bool gso_partial;

	skb_reset_network_header(skb);
	nhoff = skb_network_header(skb) - skb_mac_header(skb);
	if (unlikely(!pskb_may_pull(skb, sizeof(*ipv6h))))
		goto out;

	encap = SKB_GSO_CB(skb)->encap_level > 0;
	if (encap)
		features &= skb->dev->hw_enc_features;
	SKB_GSO_CB(skb)->encap_level += sizeof(*ipv6h);

	ipv6h = ipv6_hdr(skb);
	__skb_pull(skb, sizeof(*ipv6h));
	segs = ERR_PTR(-EPROTONOSUPPORT);

	proto = ipv6_gso_pull_exthdrs(skb, ipv6h->nexthdr);

	if (skb->encapsulation &&
	    skb_shinfo(skb)->gso_type & (SKB_GSO_IPXIP4 | SKB_GSO_IPXIP6))
		udpfrag = proto == IPPROTO_UDP && encap;
	else
		udpfrag = proto == IPPROTO_UDP && !skb->encapsulation;

	ops = rcu_dereference(inet6_offloads[proto]);
	if (likely(ops && ops->callbacks.gso_segment)) {
		skb_reset_transport_header(skb);
		segs = ops->callbacks.gso_segment(skb, features);
	}

	if (IS_ERR_OR_NULL(segs))
		goto out;

	gso_partial = !!(skb_shinfo(segs)->gso_type & SKB_GSO_PARTIAL);

	for (skb = segs; skb; skb = skb->next) {
		ipv6h = (struct ipv6hdr *)(skb_mac_header(skb) + nhoff);
		if (gso_partial)
			payload_len = skb_shinfo(skb)->gso_size +
				      SKB_GSO_CB(skb)->data_offset +
				      skb->head - (unsigned char *)(ipv6h + 1);
		else
			payload_len = skb->len - nhoff - sizeof(*ipv6h);
		ipv6h->payload_len = htons(payload_len);
		skb->network_header = (u8 *)ipv6h - skb->head;

		if (udpfrag) {
			unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);
			if (unfrag_ip6hlen < 0)
				return ERR_PTR(unfrag_ip6hlen);
			fptr = (struct frag_hdr *)((u8 *)ipv6h + unfrag_ip6hlen);
			fptr->frag_off = htons(offset);
			if (skb->next)
				fptr->frag_off |= htons(IP6_MF);
			offset += (ntohs(ipv6h->payload_len) -
				   sizeof(struct frag_hdr));
		}
		if (encap)
			skb_reset_inner_headers(skb);
	}

out:
	return segs;
}","static struct sk_buff *ipv6_gso_segment(struct sk_buff *VAR_0,
	netdev_features_t VAR_1)
{
	struct sk_buff *VAR_2 = ERR_PTR(-VAR_3);
	struct ipv6hdr *VAR_4;
	const struct net_offload *VAR_5;
	int VAR_6;
	struct frag_hdr *VAR_7;
	unsigned int VAR_8;
	unsigned int VAR_9;
	u8 *VAR_10;
	int VAR_11 = 0;
	bool VAR_12, VAR_13;
	int VAR_14;
	bool VAR_15;

	skb_reset_network_header(VAR_0);
	VAR_14 = skb_network_header(VAR_0) - skb_mac_header(VAR_0);
	if (unlikely(!pskb_may_pull(VAR_0, sizeof(*VAR_4))))
		goto out;

	VAR_12 = SKB_GSO_CB(VAR_0)->encap_level > 0;
	if (VAR_12)
		VAR_1 &= VAR_0->dev->hw_enc_features;
	SKB_GSO_CB(VAR_0)->encap_level += sizeof(*VAR_4);

	VAR_4 = ipv6_hdr(VAR_0);
	__skb_pull(VAR_0, sizeof(*VAR_4));
	VAR_2 = ERR_PTR(-VAR_16);

	VAR_6 = ipv6_gso_pull_exthdrs(VAR_0, VAR_4->nexthdr);

	if (VAR_0->encapsulation &&
	    skb_shinfo(VAR_0)->gso_type & (VAR_17 | VAR_18))
		VAR_13 = VAR_6 == VAR_19 && VAR_12;
	else
		VAR_13 = VAR_6 == VAR_19 && !VAR_0->encapsulation;

	VAR_5 = rcu_dereference(VAR_20[VAR_6]);
	if (likely(VAR_5 && VAR_5->callbacks.gso_segment)) {
		skb_reset_transport_header(VAR_0);
		VAR_2 = VAR_5->callbacks.gso_segment(VAR_0, VAR_1);
	}

	if (IS_ERR_OR_NULL(VAR_2))
		goto out;

	VAR_15 = !!(skb_shinfo(VAR_2)->gso_type & VAR_21);

	for (VAR_0 = VAR_2; VAR_0; VAR_0 = VAR_0->next) {
		VAR_4 = (struct ipv6hdr *)(skb_mac_header(VAR_0) + VAR_14);
		if (VAR_15)
			VAR_9 = skb_shinfo(VAR_0)->gso_size +
				      SKB_GSO_CB(VAR_0)->data_offset +
				      VAR_0->head - (unsigned char *)(VAR_4 + 1);
		else
			VAR_9 = VAR_0->len - VAR_14 - sizeof(*VAR_4);
		VAR_4->payload_len = htons(VAR_9);
		VAR_0->network_header = (u8 *)VAR_4 - VAR_0->head;

		if (VAR_13) {
			VAR_8 = ip6_find_1stfragopt(VAR_0, &VAR_10);
			if (VAR_8 < 0)
				return ERR_PTR(VAR_8);
			VAR_7 = (struct frag_hdr *)((u8 *)VAR_4 + VAR_8);
			VAR_7->frag_off = htons(VAR_11);
			if (VAR_0->next)
				VAR_7->frag_off |= htons(VAR_22);
			VAR_11 += (ntohs(VAR_4->payload_len) -
				   sizeof(struct frag_hdr));
		}
		if (VAR_12)
			skb_reset_inner_headers(VAR_0);
	}

out:
	return VAR_2;
}",torvalds/linux/2423496af35d94a87156b063ea5cedffc10a70a1/ip6_offload.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -60,6 +60,8 @@
 
 		if (udpfrag) {
 			unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);
+			if (unfrag_ip6hlen < 0)
+				return ERR_PTR(unfrag_ip6hlen);
 			fptr = (struct frag_hdr *)((u8 *)ipv6h + unfrag_ip6hlen);
 			fptr->frag_off = htons(offset);
 			if (skb->next)","{'deleted_lines': [], 'added_lines': ['\t\t\tif (unfrag_ip6hlen < 0)', '\t\t\t\treturn ERR_PTR(unfrag_ip6hlen);']}",True,"The IPv6 fragmentation implementation in the Linux kernel through 4.11.1 does not consider that the nexthdr field may be associated with an invalid option, which allows local users to cause a denial of service (out-of-bounds read and BUG) or possibly have unspecified other impact via crafted socket and send system calls.",7.8,HIGH,2,test,2017-05-16T18:36:23Z,1
CVE-2017-9228,['CWE-787'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,kkos/oniguruma,fix #60 : invalid state(CCS_VALUE) in parse_char_class(),3b63d12038c8d8fc278e81c942fa9bec7c704c8b,https://github.com/kkos/oniguruma/commit/3b63d12038c8d8fc278e81c942fa9bec7c704c8b,src/regparse.c,next_state_class,"static int
next_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,
enum CCSTATE* state, ScanEnv* env)
{
int r;
if (*state == CCS_RANGE)
return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;
if (*state == CCS_VALUE && *type != CCV_CLASS) {
if (*type == CCV_SB)
BITSET_SET_BIT(cc->bs, (int )(*vs));
else if (*type == CCV_CODE_POINT) {
r = add_code_range(&(cc->mbuf), env, *vs, *vs);
if (r < 0) return r;
}
}
*state = CCS_VALUE;
*type  = CCV_CLASS;
return 0;
}","static int
next_state_class(CClassNode* VAR_0, OnigCodePoint* VAR_1, enum CCVALTYPE* VAR_2,
enum CCSTATE* VAR_3, ScanEnv* VAR_4)
{
int VAR_5;
if (*VAR_3 == VAR_6)
return VAR_7;
if (*VAR_3 == VAR_8 && *VAR_2 != VAR_9) {
if (*VAR_2 == VAR_10)
BITSET_SET_BIT(VAR_0->bs, (int )(*VAR_1));
else if (*VAR_2 == VAR_11) {
VAR_5 = add_code_range(&(VAR_0->mbuf), VAR_4, *VAR_1, *VAR_1);
if (VAR_5 < 0) return VAR_5;
}
}
*VAR_3 = VAR_8;
*VAR_2  = VAR_9;
return 0;
}",kkos/oniguruma/3b63d12038c8d8fc278e81c942fa9bec7c704c8b/regparse.c/vul/before/0.json,"static int
next_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,
		 enum CCSTATE* state, ScanEnv* env)
{
  int r;

  if (*state == CCS_RANGE)
    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;

  if (*state == CCS_VALUE && *type != CCV_CLASS) {
    if (*type == CCV_SB)
      BITSET_SET_BIT(cc->bs, (int )(*vs));
    else if (*type == CCV_CODE_POINT) {
      r = add_code_range(&(cc->mbuf), env, *vs, *vs);
      if (r < 0) return r;
    }
  }

  if (*state != CCS_START)
    *state = CCS_VALUE;

  *type  = CCV_CLASS;
  return 0;
}","static int
next_state_class(CClassNode* VAR_0, OnigCodePoint* VAR_1, enum CCVALTYPE* VAR_2,
		 enum CCSTATE* VAR_3, ScanEnv* VAR_4)
{
  int VAR_5;

  if (*VAR_3 == VAR_6)
    return VAR_7;

  if (*VAR_3 == VAR_8 && *VAR_2 != VAR_9) {
    if (*VAR_2 == VAR_10)
      BITSET_SET_BIT(VAR_0->bs, (int )(*VAR_1));
    else if (*VAR_2 == VAR_11) {
      VAR_5 = add_code_range(&(VAR_0->mbuf), VAR_4, *VAR_1, *VAR_1);
      if (VAR_5 < 0) return VAR_5;
    }
  }

  if (*VAR_3 != VAR_12)
    *VAR_3 = VAR_8;

  *VAR_2  = VAR_9;
  return 0;
}",kkos/oniguruma/3b63d12038c8d8fc278e81c942fa9bec7c704c8b/regparse.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -16,7 +16,9 @@
     }
   }
 
-  *state = CCS_VALUE;
+  if (*state != CCS_START)
+    *state = CCS_VALUE;
+
   *type  = CCV_CLASS;
   return 0;
 }","{'deleted_lines': ['  *state = CCS_VALUE;'], 'added_lines': ['  if (*state != CCS_START)', '    *state = CCS_VALUE;', '']}",True,"An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A heap out-of-bounds write occurs in bitset_set_range() during regular expression compilation due to an uninitialized variable from an incorrect state transition. An incorrect state transition in parse_char_class() could create an execution path that leaves a critical local variable uninitialized until it's used as an index, resulting in an out-of-bounds write memory corruption.",9.8,CRITICAL,3,test,2017-05-24T04:43:25Z,1
CVE-2017-8831,['CWE-125'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,stoth68000/media-tree,"[PATCH] saa7164: Bug - Double fetch PCIe access condition

Avoid a double fetch by reusing the values from the prior transfer.

Originally reported via https://bugzilla.kernel.org/show_bug.cgi?id=195559

Thanks to Pengfei Wang <wpengfeinudt@gmail.com> for reporting.

Signed-off-by: Steven Toth <stoth@kernellabs.com>",354dd3924a2e43806774953de536257548b5002c,https://github.com/stoth68000/media-tree/commit/354dd3924a2e43806774953de536257548b5002c,drivers/media/pci/saa7164/saa7164-bus.c,saa7164_bus_get,"int saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,
void *buf, int peekonly)
{
struct tmComResBusInfo *bus = &dev->bus;
u32 bytes_to_read, write_distance, curr_grp, curr_gwp,
new_grp, buf_size, space_rem;
struct tmComResInfo msg_tmp;
int ret = SAA_ERR_BAD_PARAMETER;
saa7164_bus_verify(dev);
if (msg == NULL)
return ret;
if (msg->size > dev->bus.m_wMaxReqSize) {
printk(KERN_ERR ""%s() Exceeded dev->bus.m_wMaxReqSize\n"",
__func__);
return ret;
}
if ((peekonly == 0) && (msg->size > 0) && (buf == NULL)) {
printk(KERN_ERR
""%s() Missing msg buf, size should be %d bytes\n"",
__func__, msg->size);
return ret;
}
mutex_lock(&bus->lock);
curr_gwp = saa7164_readl(bus->m_dwGetWritePos);
curr_grp = saa7164_readl(bus->m_dwGetReadPos);
if (curr_gwp == curr_grp) {
ret = SAA_ERR_EMPTY;
goto out;
}
bytes_to_read = sizeof(*msg);
write_distance = 0;
if (curr_gwp >= curr_grp)
write_distance = curr_gwp - curr_grp;
else
write_distance = curr_gwp + bus->m_dwSizeGetRing - curr_grp;
if (bytes_to_read > write_distance) {
printk(KERN_ERR ""%s() No message/response found\n"", __func__);
ret = SAA_ERR_INVALID_COMMAND;
goto out;
}
new_grp = curr_grp + bytes_to_read;
if (new_grp > bus->m_dwSizeGetRing) {
new_grp -= bus->m_dwSizeGetRing;
space_rem = bus->m_dwSizeGetRing - curr_grp;
memcpy_fromio(&msg_tmp, bus->m_pdwGetRing + curr_grp, space_rem);
memcpy_fromio((u8 *)&msg_tmp + space_rem, bus->m_pdwGetRing,
bytes_to_read - space_rem);
} else {
memcpy_fromio(&msg_tmp, bus->m_pdwGetRing + curr_grp, bytes_to_read);
}
msg_tmp.size = le16_to_cpu((__force __le16)msg_tmp.size);
msg_tmp.command = le32_to_cpu((__force __le32)msg_tmp.command);
msg_tmp.controlselector = le16_to_cpu((__force __le16)msg_tmp.controlselector);
if (peekonly) {
memcpy(msg, &msg_tmp, sizeof(*msg));
goto peekout;
}
if ((msg_tmp.id != msg->id) || (msg_tmp.command != msg->command) ||
(msg_tmp.controlselector != msg->controlselector) ||
(msg_tmp.seqno != msg->seqno) || (msg_tmp.size != msg->size)) {
printk(KERN_ERR ""%s() Unexpected msg miss-match\n"", __func__);
saa7164_bus_dumpmsg(dev, msg, buf);
saa7164_bus_dumpmsg(dev, &msg_tmp, NULL);
ret = SAA_ERR_INVALID_COMMAND;
goto out;
}
buf_size = msg->size;
bytes_to_read = sizeof(*msg) + msg->size;
write_distance = 0;
if (curr_gwp >= curr_grp)
write_distance = curr_gwp - curr_grp;
else
write_distance = curr_gwp + bus->m_dwSizeGetRing - curr_grp;
if (bytes_to_read > write_distance) {
printk(KERN_ERR ""%s() Invalid bus state, missing msg or mangled ring, faulty H/W / bad code?\n"",
__func__);
ret = SAA_ERR_INVALID_COMMAND;
goto out;
}
new_grp = curr_grp + bytes_to_read;
if (new_grp > bus->m_dwSizeGetRing) {
new_grp -= bus->m_dwSizeGetRing;
space_rem = bus->m_dwSizeGetRing - curr_grp;
if (space_rem < sizeof(*msg)) {
memcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, space_rem);
memcpy_fromio((u8 *)msg + space_rem, bus->m_pdwGetRing,
sizeof(*msg) - space_rem);
if (buf)
memcpy_fromio(buf, bus->m_pdwGetRing + sizeof(*msg) -
space_rem, buf_size);
} else if (space_rem == sizeof(*msg)) {
memcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));
if (buf)
memcpy_fromio(buf, bus->m_pdwGetRing, buf_size);
} else {
memcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));
if (buf) {
memcpy_fromio(buf, bus->m_pdwGetRing + curr_grp +
sizeof(*msg), space_rem - sizeof(*msg));
memcpy_fromio(buf + space_rem - sizeof(*msg),
bus->m_pdwGetRing, bytes_to_read -
space_rem);
}
}
} else {
memcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));
if (buf)
memcpy_fromio(buf, bus->m_pdwGetRing + curr_grp + sizeof(*msg),
buf_size);
}
msg->size = le16_to_cpu((__force __le16)msg->size);
msg->command = le32_to_cpu((__force __le32)msg->command);
msg->controlselector = le16_to_cpu((__force __le16)msg->controlselector);
saa7164_writel(bus->m_dwGetReadPos, new_grp);
peekout:
ret = SAA_OK;
out:
mutex_unlock(&bus->lock);
saa7164_bus_verify(dev);
return ret;
}","int saa7164_bus_get(struct saa7164_dev *VAR_0, struct tmComResInfo* VAR_1,
void *VAR_2, int VAR_3)
{
struct tmComResBusInfo *VAR_4 = &VAR_0->bus;
u32 VAR_5, VAR_6, VAR_7, VAR_8,
VAR_9, VAR_10, VAR_11;
struct tmComResInfo VAR_12;
int VAR_13 = VAR_14;
saa7164_bus_verify(VAR_0);
if (VAR_1 == NULL)
return VAR_13;
if (VAR_1->size > VAR_0->bus.m_wMaxReqSize) {
printk(KERN_ERR ""%s() Exceeded dev->bus.m_wMaxReqSize\n"",
VAR_15);
return VAR_13;
}
if ((VAR_3 == 0) && (VAR_1->size > 0) && (VAR_2 == NULL)) {
printk(KERN_ERR
""%s() Missing msg buf, size should be %d bytes\n"",
VAR_15, VAR_1->size);
return VAR_13;
}
mutex_lock(&VAR_4->lock);
VAR_8 = saa7164_readl(VAR_4->m_dwGetWritePos);
VAR_7 = saa7164_readl(VAR_4->m_dwGetReadPos);
if (VAR_8 == VAR_7) {
VAR_13 = VAR_16;
goto out;
}
VAR_5 = sizeof(*VAR_1);
VAR_6 = 0;
if (VAR_8 >= VAR_7)
VAR_6 = VAR_8 - VAR_7;
else
VAR_6 = VAR_8 + VAR_4->m_dwSizeGetRing - VAR_7;
if (VAR_5 > VAR_6) {
printk(KERN_ERR ""%s() No message/response found\n"", VAR_15);
VAR_13 = VAR_17;
goto out;
}
VAR_9 = VAR_7 + VAR_5;
if (VAR_9 > VAR_4->m_dwSizeGetRing) {
VAR_9 -= VAR_4->m_dwSizeGetRing;
VAR_11 = VAR_4->m_dwSizeGetRing - VAR_7;
memcpy_fromio(&VAR_12, VAR_4->m_pdwGetRing + VAR_7, VAR_11);
memcpy_fromio((u8 *)&VAR_12 + VAR_11, VAR_4->m_pdwGetRing,
VAR_5 - VAR_11);
} else {
memcpy_fromio(&VAR_12, VAR_4->m_pdwGetRing + VAR_7, VAR_5);
}
VAR_12.size = le16_to_cpu((__force VAR_18)VAR_12.size);
VAR_12.command = le32_to_cpu((__force VAR_19)VAR_12.command);
VAR_12.controlselector = le16_to_cpu((__force VAR_18)VAR_12.controlselector);
if (VAR_3) {
memcpy(VAR_1, &VAR_12, sizeof(*VAR_1));
goto peekout;
}
if ((VAR_12.id != VAR_1->id) || (VAR_12.command != VAR_1->command) ||
(VAR_12.controlselector != VAR_1->controlselector) ||
(VAR_12.seqno != VAR_1->seqno) || (VAR_12.size != VAR_1->size)) {
printk(KERN_ERR ""%s() Unexpected msg miss-match\n"", VAR_15);
saa7164_bus_dumpmsg(VAR_0, VAR_1, VAR_2);
saa7164_bus_dumpmsg(VAR_0, &VAR_12, NULL);
VAR_13 = VAR_17;
goto out;
}
VAR_10 = VAR_1->size;
VAR_5 = sizeof(*VAR_1) + VAR_1->size;
VAR_6 = 0;
if (VAR_8 >= VAR_7)
VAR_6 = VAR_8 - VAR_7;
else
VAR_6 = VAR_8 + VAR_4->m_dwSizeGetRing - VAR_7;
if (VAR_5 > VAR_6) {
printk(KERN_ERR ""%s() Invalid bus state, missing msg or mangled ring, faulty H/W / bad code?\n"",
VAR_15);
VAR_13 = VAR_17;
goto out;
}
VAR_9 = VAR_7 + VAR_5;
if (VAR_9 > VAR_4->m_dwSizeGetRing) {
VAR_9 -= VAR_4->m_dwSizeGetRing;
VAR_11 = VAR_4->m_dwSizeGetRing - VAR_7;
if (VAR_11 < sizeof(*VAR_1)) {
memcpy_fromio(VAR_1, VAR_4->m_pdwGetRing + VAR_7, VAR_11);
memcpy_fromio((u8 *)VAR_1 + VAR_11, VAR_4->m_pdwGetRing,
sizeof(*VAR_1) - VAR_11);
if (VAR_2)
memcpy_fromio(VAR_2, VAR_4->m_pdwGetRing + sizeof(*VAR_1) -
VAR_11, VAR_10);
} else if (VAR_11 == sizeof(*VAR_1)) {
memcpy_fromio(VAR_1, VAR_4->m_pdwGetRing + VAR_7, sizeof(*VAR_1));
if (VAR_2)
memcpy_fromio(VAR_2, VAR_4->m_pdwGetRing, VAR_10);
} else {
memcpy_fromio(VAR_1, VAR_4->m_pdwGetRing + VAR_7, sizeof(*VAR_1));
if (VAR_2) {
memcpy_fromio(VAR_2, VAR_4->m_pdwGetRing + VAR_7 +
sizeof(*VAR_1), VAR_11 - sizeof(*VAR_1));
memcpy_fromio(VAR_2 + VAR_11 - sizeof(*VAR_1),
VAR_4->m_pdwGetRing, VAR_5 -
VAR_11);
}
}
} else {
memcpy_fromio(VAR_1, VAR_4->m_pdwGetRing + VAR_7, sizeof(*VAR_1));
if (VAR_2)
memcpy_fromio(VAR_2, VAR_4->m_pdwGetRing + VAR_7 + sizeof(*VAR_1),
VAR_10);
}
VAR_1->size = le16_to_cpu((__force VAR_18)VAR_1->size);
VAR_1->command = le32_to_cpu((__force VAR_19)VAR_1->command);
VAR_1->controlselector = le16_to_cpu((__force VAR_18)VAR_1->controlselector);
saa7164_writel(VAR_4->m_dwGetReadPos, VAR_9);
peekout:
VAR_13 = VAR_20;
out:
mutex_unlock(&VAR_4->lock);
saa7164_bus_verify(VAR_0);
return VAR_13;
}",stoth68000/media-tree/354dd3924a2e43806774953de536257548b5002c/saa7164-bus.c/vul/before/0.json,"int saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,
	void *buf, int peekonly)
{
	struct tmComResBusInfo *bus = &dev->bus;
	u32 bytes_to_read, write_distance, curr_grp, curr_gwp,
		new_grp, buf_size, space_rem;
	struct tmComResInfo msg_tmp;
	int ret = SAA_ERR_BAD_PARAMETER;

	saa7164_bus_verify(dev);

	if (msg == NULL)
		return ret;

	if (msg->size > dev->bus.m_wMaxReqSize) {
		printk(KERN_ERR ""%s() Exceeded dev->bus.m_wMaxReqSize\n"",
			__func__);
		return ret;
	}

	if ((peekonly == 0) && (msg->size > 0) && (buf == NULL)) {
		printk(KERN_ERR
			""%s() Missing msg buf, size should be %d bytes\n"",
			__func__, msg->size);
		return ret;
	}

	mutex_lock(&bus->lock);

	/* Peek the bus to see if a msg exists, if it's not what we're expecting
	 * then return cleanly else read the message from the bus.
	 */
	curr_gwp = saa7164_readl(bus->m_dwGetWritePos);
	curr_grp = saa7164_readl(bus->m_dwGetReadPos);

	if (curr_gwp == curr_grp) {
		ret = SAA_ERR_EMPTY;
		goto out;
	}

	bytes_to_read = sizeof(*msg);

	/* Calculate write distance to current read position */
	write_distance = 0;
	if (curr_gwp >= curr_grp)
		/* Write doesn't wrap around the ring */
		write_distance = curr_gwp - curr_grp;
	else
		/* Write wraps around the ring */
		write_distance = curr_gwp + bus->m_dwSizeGetRing - curr_grp;

	if (bytes_to_read > write_distance) {
		printk(KERN_ERR ""%s() No message/response found\n"", __func__);
		ret = SAA_ERR_INVALID_COMMAND;
		goto out;
	}

	/* Calculate the new read position */
	new_grp = curr_grp + bytes_to_read;
	if (new_grp > bus->m_dwSizeGetRing) {

		/* Ring wraps */
		new_grp -= bus->m_dwSizeGetRing;
		space_rem = bus->m_dwSizeGetRing - curr_grp;

		memcpy_fromio(&msg_tmp, bus->m_pdwGetRing + curr_grp, space_rem);
		memcpy_fromio((u8 *)&msg_tmp + space_rem, bus->m_pdwGetRing,
			bytes_to_read - space_rem);

	} else {
		/* No wrapping */
		memcpy_fromio(&msg_tmp, bus->m_pdwGetRing + curr_grp, bytes_to_read);
	}
	/* Convert from little endian to CPU */
	msg_tmp.size = le16_to_cpu((__force __le16)msg_tmp.size);
	msg_tmp.command = le32_to_cpu((__force __le32)msg_tmp.command);
	msg_tmp.controlselector = le16_to_cpu((__force __le16)msg_tmp.controlselector);
	memcpy(msg, &msg_tmp, sizeof(*msg));

	/* No need to update the read positions, because this was a peek */
	/* If the caller specifically want to peek, return */
	if (peekonly) {
		goto peekout;
	}

	/* Check if the command/response matches what is expected */
	if ((msg_tmp.id != msg->id) || (msg_tmp.command != msg->command) ||
		(msg_tmp.controlselector != msg->controlselector) ||
		(msg_tmp.seqno != msg->seqno) || (msg_tmp.size != msg->size)) {

		printk(KERN_ERR ""%s() Unexpected msg miss-match\n"", __func__);
		saa7164_bus_dumpmsg(dev, msg, buf);
		saa7164_bus_dumpmsg(dev, &msg_tmp, NULL);
		ret = SAA_ERR_INVALID_COMMAND;
		goto out;
	}

	/* Get the actual command and response from the bus */
	buf_size = msg->size;

	bytes_to_read = sizeof(*msg) + msg->size;
	/* Calculate write distance to current read position */
	write_distance = 0;
	if (curr_gwp >= curr_grp)
		/* Write doesn't wrap around the ring */
		write_distance = curr_gwp - curr_grp;
	else
		/* Write wraps around the ring */
		write_distance = curr_gwp + bus->m_dwSizeGetRing - curr_grp;

	if (bytes_to_read > write_distance) {
		printk(KERN_ERR ""%s() Invalid bus state, missing msg or mangled ring, faulty H/W / bad code?\n"",
		       __func__);
		ret = SAA_ERR_INVALID_COMMAND;
		goto out;
	}

	/* Calculate the new read position */
	new_grp = curr_grp + bytes_to_read;
	if (new_grp > bus->m_dwSizeGetRing) {

		/* Ring wraps */
		new_grp -= bus->m_dwSizeGetRing;
		space_rem = bus->m_dwSizeGetRing - curr_grp;

		if (space_rem < sizeof(*msg)) {
			if (buf)
				memcpy_fromio(buf, bus->m_pdwGetRing + sizeof(*msg) -
					space_rem, buf_size);

		} else if (space_rem == sizeof(*msg)) {
			if (buf)
				memcpy_fromio(buf, bus->m_pdwGetRing, buf_size);
		} else {
			/* Additional data wraps around the ring */
			if (buf) {
				memcpy_fromio(buf, bus->m_pdwGetRing + curr_grp +
					sizeof(*msg), space_rem - sizeof(*msg));
				memcpy_fromio(buf + space_rem - sizeof(*msg),
					bus->m_pdwGetRing, bytes_to_read -
					space_rem);
			}

		}

	} else {
		/* No wrapping */
		if (buf)
			memcpy_fromio(buf, bus->m_pdwGetRing + curr_grp + sizeof(*msg),
				buf_size);
	}

	/* Update the read positions, adjusting the ring */
	saa7164_writel(bus->m_dwGetReadPos, new_grp);

peekout:
	ret = SAA_OK;
out:
	mutex_unlock(&bus->lock);
	saa7164_bus_verify(dev);
	return ret;
}","int saa7164_bus_get(struct saa7164_dev *VAR_0, struct tmComResInfo* VAR_1,
	void *VAR_2, int VAR_3)
{
	struct tmComResBusInfo *VAR_4 = &VAR_0->bus;
	u32 VAR_5, VAR_6, VAR_7, VAR_8,
		VAR_9, VAR_10, VAR_11;
	struct tmComResInfo VAR_12;
	int VAR_13 = VAR_14;

	saa7164_bus_verify(VAR_0);

	if (VAR_1 == NULL)
		return VAR_13;

	if (VAR_1->size > VAR_0->bus.m_wMaxReqSize) {
		printk(KERN_ERR ""%s() Exceeded dev->bus.m_wMaxReqSize\n"",
			VAR_15);
		return VAR_13;
	}

	if ((VAR_3 == 0) && (VAR_1->size > 0) && (VAR_2 == NULL)) {
		printk(KERN_ERR
			""%s() Missing msg buf, size should be %d bytes\n"",
			VAR_15, VAR_1->size);
		return VAR_13;
	}

	mutex_lock(&VAR_4->lock);

	/* COMMENT_0 */
                                                           
    
	VAR_8 = saa7164_readl(VAR_4->m_dwGetWritePos);
	VAR_7 = saa7164_readl(VAR_4->m_dwGetReadPos);

	if (VAR_8 == VAR_7) {
		VAR_13 = VAR_16;
		goto out;
	}

	VAR_5 = sizeof(*VAR_1);

	/* COMMENT_3 */
	VAR_6 = 0;
	if (VAR_8 >= VAR_7)
		/* COMMENT_4 */
		VAR_6 = VAR_8 - VAR_7;
	else
		/* COMMENT_5 */
		VAR_6 = VAR_8 + VAR_4->m_dwSizeGetRing - VAR_7;

	if (VAR_5 > VAR_6) {
		printk(KERN_ERR ""%s() No message/response found\n"", VAR_15);
		VAR_13 = VAR_17;
		goto out;
	}

	/* COMMENT_6 */
	VAR_9 = VAR_7 + VAR_5;
	if (VAR_9 > VAR_4->m_dwSizeGetRing) {

		/* COMMENT_7 */
		VAR_9 -= VAR_4->m_dwSizeGetRing;
		VAR_11 = VAR_4->m_dwSizeGetRing - VAR_7;

		memcpy_fromio(&VAR_12, VAR_4->m_pdwGetRing + VAR_7, VAR_11);
		memcpy_fromio((u8 *)&VAR_12 + VAR_11, VAR_4->m_pdwGetRing,
			VAR_5 - VAR_11);

	} else {
		/* COMMENT_8 */
		memcpy_fromio(&VAR_12, VAR_4->m_pdwGetRing + VAR_7, VAR_5);
	}
	/* COMMENT_9 */
	VAR_12.size = le16_to_cpu((__force VAR_18)VAR_12.size);
	VAR_12.command = le32_to_cpu((__force VAR_19)VAR_12.command);
	VAR_12.controlselector = le16_to_cpu((__force VAR_18)VAR_12.controlselector);
	memcpy(VAR_1, &VAR_12, sizeof(*VAR_1));

	/* COMMENT_10 */
	/* COMMENT_11 */
	if (VAR_3) {
		goto peekout;
	}

	/* COMMENT_12 */
	if ((VAR_12.id != VAR_1->id) || (VAR_12.command != VAR_1->command) ||
		(VAR_12.controlselector != VAR_1->controlselector) ||
		(VAR_12.seqno != VAR_1->seqno) || (VAR_12.size != VAR_1->size)) {

		printk(KERN_ERR ""%s() Unexpected msg miss-match\n"", VAR_15);
		saa7164_bus_dumpmsg(VAR_0, VAR_1, VAR_2);
		saa7164_bus_dumpmsg(VAR_0, &VAR_12, NULL);
		VAR_13 = VAR_17;
		goto out;
	}

	/* COMMENT_13 */
	VAR_10 = VAR_1->size;

	VAR_5 = sizeof(*VAR_1) + VAR_1->size;
	/* COMMENT_3 */
	VAR_6 = 0;
	if (VAR_8 >= VAR_7)
		/* COMMENT_4 */
		VAR_6 = VAR_8 - VAR_7;
	else
		/* COMMENT_5 */
		VAR_6 = VAR_8 + VAR_4->m_dwSizeGetRing - VAR_7;

	if (VAR_5 > VAR_6) {
		printk(KERN_ERR ""%s() Invalid bus state, missing msg or mangled ring, faulty H/W / bad code?\n"",
		       VAR_15);
		VAR_13 = VAR_17;
		goto out;
	}

	/* COMMENT_6 */
	VAR_9 = VAR_7 + VAR_5;
	if (VAR_9 > VAR_4->m_dwSizeGetRing) {

		/* COMMENT_7 */
		VAR_9 -= VAR_4->m_dwSizeGetRing;
		VAR_11 = VAR_4->m_dwSizeGetRing - VAR_7;

		if (VAR_11 < sizeof(*VAR_1)) {
			if (VAR_2)
				memcpy_fromio(VAR_2, VAR_4->m_pdwGetRing + sizeof(*VAR_1) -
					VAR_11, VAR_10);

		} else if (VAR_11 == sizeof(*VAR_1)) {
			if (VAR_2)
				memcpy_fromio(VAR_2, VAR_4->m_pdwGetRing, VAR_10);
		} else {
			/* COMMENT_14 */
			if (VAR_2) {
				memcpy_fromio(VAR_2, VAR_4->m_pdwGetRing + VAR_7 +
					sizeof(*VAR_1), VAR_11 - sizeof(*VAR_1));
				memcpy_fromio(VAR_2 + VAR_11 - sizeof(*VAR_1),
					VAR_4->m_pdwGetRing, VAR_5 -
					VAR_11);
			}

		}

	} else {
		/* COMMENT_8 */
		if (VAR_2)
			memcpy_fromio(VAR_2, VAR_4->m_pdwGetRing + VAR_7 + sizeof(*VAR_1),
				VAR_10);
	}

	/* COMMENT_15 */
	saa7164_writel(VAR_4->m_dwGetReadPos, VAR_9);

peekout:
	VAR_13 = VAR_20;
out:
	mutex_unlock(&VAR_4->lock);
	saa7164_bus_verify(VAR_0);
	return VAR_13;
}",stoth68000/media-tree/354dd3924a2e43806774953de536257548b5002c/saa7164-bus.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -75,11 +75,11 @@
 	msg_tmp.size = le16_to_cpu((__force __le16)msg_tmp.size);
 	msg_tmp.command = le32_to_cpu((__force __le32)msg_tmp.command);
 	msg_tmp.controlselector = le16_to_cpu((__force __le16)msg_tmp.controlselector);
+	memcpy(msg, &msg_tmp, sizeof(*msg));
 
 	/* No need to update the read positions, because this was a peek */
 	/* If the caller specifically want to peek, return */
 	if (peekonly) {
-		memcpy(msg, &msg_tmp, sizeof(*msg));
 		goto peekout;
 	}
 
@@ -124,21 +124,15 @@
 		space_rem = bus->m_dwSizeGetRing - curr_grp;
 
 		if (space_rem < sizeof(*msg)) {
-			/* msg wraps around the ring */
-			memcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, space_rem);
-			memcpy_fromio((u8 *)msg + space_rem, bus->m_pdwGetRing,
-				sizeof(*msg) - space_rem);
 			if (buf)
 				memcpy_fromio(buf, bus->m_pdwGetRing + sizeof(*msg) -
 					space_rem, buf_size);
 
 		} else if (space_rem == sizeof(*msg)) {
-			memcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));
 			if (buf)
 				memcpy_fromio(buf, bus->m_pdwGetRing, buf_size);
 		} else {
 			/* Additional data wraps around the ring */
-			memcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));
 			if (buf) {
 				memcpy_fromio(buf, bus->m_pdwGetRing + curr_grp +
 					sizeof(*msg), space_rem - sizeof(*msg));
@@ -151,15 +145,10 @@
 
 	} else {
 		/* No wrapping */
-		memcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));
 		if (buf)
 			memcpy_fromio(buf, bus->m_pdwGetRing + curr_grp + sizeof(*msg),
 				buf_size);
 	}
-	/* Convert from little endian to CPU */
-	msg->size = le16_to_cpu((__force __le16)msg->size);
-	msg->command = le32_to_cpu((__force __le32)msg->command);
-	msg->controlselector = le16_to_cpu((__force __le16)msg->controlselector);
 
 	/* Update the read positions, adjusting the ring */
 	saa7164_writel(bus->m_dwGetReadPos, new_grp);","{'deleted_lines': ['\t\tmemcpy(msg, &msg_tmp, sizeof(*msg));', '\t\t\t/* msg wraps around the ring */', '\t\t\tmemcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, space_rem);', '\t\t\tmemcpy_fromio((u8 *)msg + space_rem, bus->m_pdwGetRing,', '\t\t\t\tsizeof(*msg) - space_rem);', '\t\t\tmemcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));', '\t\t\tmemcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));', '\t\tmemcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));', '\t/* Convert from little endian to CPU */', '\tmsg->size = le16_to_cpu((__force __le16)msg->size);', '\tmsg->command = le32_to_cpu((__force __le32)msg->command);', '\tmsg->controlselector = le16_to_cpu((__force __le16)msg->controlselector);'], 'added_lines': ['\tmemcpy(msg, &msg_tmp, sizeof(*msg));']}",True,"The saa7164_bus_get function in drivers/media/pci/saa7164/saa7164-bus.c in the Linux kernel through 4.11.5 allows local users to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact by changing a certain sequence-number value, aka a ""double fetch"" vulnerability.",6.4,MEDIUM,1,test,2017-06-06T12:30:27Z,1
CVE-2017-10671,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,blueness/sthttpd,Fix heap buffer overflow in de_dotdot,c0dc63a49d8605649f1d8e4a96c9b468b0bff660,https://github.com/blueness/sthttpd/commit/c0dc63a49d8605649f1d8e4a96c9b468b0bff660,src/libhttpd.c,de_dotdot,"static void
de_dotdot( char* file )
{
char* cp;
char* cp2;
int l;
while ( ( cp = strstr( file, ""{
for ( cp2 = cp + 2; *cp2 == '/'; ++cp2 )
continue;
(void) strcpy( cp + 1, cp2 );
}
while ( strncmp( file, ""./"", 2 ) == 0 )
(void) memmove( file, file + 2, strlen( file ) - 1 );
while ( ( cp = strstr( file, ""/./"") ) != (char*) 0 )
(void) memmove( cp, cp + 2, strlen( file ) - 1 );
for (;;)
{
while ( strncmp( file, ""../"", 3 ) == 0 )
(void) memmove( file, file + 3, strlen( file ) - 2 );
cp = strstr( file, ""/../"" );
if ( cp == (char*) 0 )
break;
for ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )
continue;
(void) strcpy( cp2 + 1, cp + 4 );
}
while ( ( l = strlen( file ) ) > 3 &&
strcmp( ( cp = file + l - 3 ), ""/.."" ) == 0 )
{
for ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )
continue;
if ( cp2 < file )
break;
*cp2 = '\0';
}
}","static void
de_dotdot( char* VAR_0 )
{
char* VAR_1;
char* VAR_2;
int VAR_3;
while ( ( VAR_1 = strstr( VAR_0, ""//"") ) != (char*) 0 )
{
for ( VAR_2 = VAR_1 + 2; *VAR_2 == '/'; ++VAR_2 )
continue;
(void) strcpy( VAR_1 + 1, VAR_2 );
}
while ( strncmp( VAR_0, ""./"", 2 ) == 0 )
(void) memmove( VAR_0, VAR_0 + 2, strlen( VAR_0 ) - 1 );
while ( ( VAR_1 = strstr( VAR_0, ""/./"") ) != (char*) 0 )
(void) memmove( VAR_1, VAR_1 + 2, strlen( VAR_0 ) - 1 );
for (;;)
{
while ( strncmp( VAR_0, ""../"", 3 ) == 0 )
(void) memmove( VAR_0, VAR_0 + 3, strlen( VAR_0 ) - 2 );
VAR_1 = strstr( VAR_0, ""/../"" );
if ( VAR_1 == (char*) 0 )
break;
for ( VAR_2 = VAR_1 - 1; VAR_2 >= VAR_0 && *VAR_2 != '/'; --VAR_2 )
continue;
(void) strcpy( VAR_2 + 1, VAR_1 + 4 );
}
while ( ( VAR_3 = strlen( VAR_0 ) ) > 3 &&
strcmp( ( VAR_1 = VAR_0 + VAR_3 - 3 ), ""/.."" ) == 0 )
{
for ( VAR_2 = VAR_1 - 1; VAR_2 >= VAR_0 && *VAR_2 != '/'; --VAR_2 )
continue;
if ( VAR_2 < VAR_0 )
break;
*VAR_2 = '\0';
}
}",blueness/sthttpd/c0dc63a49d8605649f1d8e4a96c9b468b0bff660/libhttpd.c/vul/before/0.json,"static void
de_dotdot( char* file )
    {
    char* cp;
    char* cp2;
    int l;

    /* Collapse any multiple / sequences. */
    while ( ( cp = strstr( file, ""//"") ) != (char*) 0 )
	{
	for ( cp2 = cp + 2; *cp2 == '/'; ++cp2 )
	    continue;
	(void) strcpy( cp + 1, cp2 );
	}

    /* Remove leading ./ and any /./ sequences. */
    while ( strncmp( file, ""./"", 2 ) == 0 )
	(void) memmove( file, file + 2, strlen( file ) - 1 );
    while ( ( cp = strstr( file, ""/./"") ) != (char*) 0 )
	(void) memmove( cp, cp + 2, strlen( cp ) - 1 );

    /* Alternate between removing leading ../ and removing xxx/../ */
    for (;;)
	{
	while ( strncmp( file, ""../"", 3 ) == 0 )
	    (void) memmove( file, file + 3, strlen( file ) - 2 );
	cp = strstr( file, ""/../"" );
	if ( cp == (char*) 0 )
	    break;
	for ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )
	    continue;
	(void) strcpy( cp2 + 1, cp + 4 );
	}

    /* Also elide any xxx/.. at the end. */
    while ( ( l = strlen( file ) ) > 3 &&
	    strcmp( ( cp = file + l - 3 ), ""/.."" ) == 0 )
	{
	for ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )
	    continue;
	if ( cp2 < file )
	    break;
	*cp2 = '\0';
	}
    }","static void
de_dotdot( char* VAR_0 )
    {
    char* VAR_1;
    char* VAR_2;
    int VAR_3;

    /* COMMENT_0 */
    while ( ( VAR_1 = strstr( VAR_0, ""//"") ) != (char*) 0 )
	{
	for ( VAR_2 = VAR_1 + 2; *VAR_2 == '/'; ++VAR_2 )
	    continue;
	(void) strcpy( VAR_1 + 1, VAR_2 );
	}

    /* COMMENT_1 */
    while ( strncmp( VAR_0, ""./"", 2 ) == 0 )
	(void) memmove( VAR_0, VAR_0 + 2, strlen( VAR_0 ) - 1 );
    while ( ( VAR_1 = strstr( VAR_0, ""/./"") ) != (char*) 0 )
	(void) memmove( VAR_1, VAR_1 + 2, strlen( VAR_1 ) - 1 );

    /* COMMENT_2 */
    for (;;)
	{
	while ( strncmp( VAR_0, ""../"", 3 ) == 0 )
	    (void) memmove( VAR_0, VAR_0 + 3, strlen( VAR_0 ) - 2 );
	VAR_1 = strstr( VAR_0, ""/../"" );
	if ( VAR_1 == (char*) 0 )
	    break;
	for ( VAR_2 = VAR_1 - 1; VAR_2 >= VAR_0 && *VAR_2 != '/'; --VAR_2 )
	    continue;
	(void) strcpy( VAR_2 + 1, VAR_1 + 4 );
	}

    /* COMMENT_3 */
    while ( ( VAR_3 = strlen( VAR_0 ) ) > 3 &&
	    strcmp( ( VAR_1 = VAR_0 + VAR_3 - 3 ), ""/.."" ) == 0 )
	{
	for ( VAR_2 = VAR_1 - 1; VAR_2 >= VAR_0 && *VAR_2 != '/'; --VAR_2 )
	    continue;
	if ( VAR_2 < VAR_0 )
	    break;
	*VAR_2 = '\0';
	}
    }",blueness/sthttpd/c0dc63a49d8605649f1d8e4a96c9b468b0bff660/libhttpd.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,7 +17,7 @@
     while ( strncmp( file, ""./"", 2 ) == 0 )
 	(void) memmove( file, file + 2, strlen( file ) - 1 );
     while ( ( cp = strstr( file, ""/./"") ) != (char*) 0 )
-	(void) memmove( cp, cp + 2, strlen( file ) - 1 );
+	(void) memmove( cp, cp + 2, strlen( cp ) - 1 );
 
     /* Alternate between removing leading ../ and removing xxx/../ */
     for (;;)","{'deleted_lines': ['\t(void) memmove( cp, cp + 2, strlen( file ) - 1 );'], 'added_lines': ['\t(void) memmove( cp, cp + 2, strlen( cp ) - 1 );']}",True,Heap-based Buffer Overflow in the de_dotdot function in libhttpd.c in sthttpd before 2.27.1 allows remote attackers to cause a denial of service (daemon crash) or possibly have unspecified other impact via a crafted filename.,7.8,HIGH,2,test,2017-06-06T18:19:43Z,1
CVE-2017-9619,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ArtifexSoftware/ghostpdl,"Bug 698042: xps: fix glyph index and index bounds check.

If a gs_glyph has the GS_MIN_GLYPH_INDEX offset, we need to remove the offset
before we try to use it.

Secondly, using a unsigned variable for a value from which we subtract 1, and
which can be zero doesn't work well. Switch to a signed value.",c53183d4e7103e87368b7cfa15367a47d559e323,https://github.com/ArtifexSoftware/ghostpdl/commit/c53183d4e7103e87368b7cfa15367a47d559e323,xps/xpsttf.c,xps_true_callback_glyph_name,"static int
xps_true_callback_glyph_name(gs_font *pfont, gs_glyph glyph, gs_const_string *pstr)
{
int table_length;
int table_offset;
ulong format;
uint numGlyphs;
uint glyph_name_index;
const byte *postp; 
if ( pfont->FontType != ft_TrueType )
{
glyph -= 29;
if (glyph < 258 )
{
pstr->data = (byte*) pl_mac_names[glyph];
pstr->size = strlen((char*)pstr->data);
return 0;
}
else
{
return gs_throw1(-1, ""glyph index %lu out of range"", (ulong)glyph);
}
}
table_offset = xps_find_sfnt_table((xps_font_t*)pfont->client_data, ""post"", &table_length);
if (table_offset < 0)
return gs_throw(-1, ""no post table"");
if ( table_length == 0 )
return gs_throw(-1, ""zero-size post table"");
((gs_font_type42 *)pfont)->data.string_proc((gs_font_type42 *)pfont,
table_offset, table_length, &postp);
format = u32(postp);
if ( format != 0x20000 )
{
char buf[32];
gs_sprintf(buf, ""glyph%d"", (int)glyph);
pstr->data = (byte*)buf;
pstr->size = strlen((char*)pstr->data);
return 0;
}
numGlyphs = u16(postp + 32);
if (glyph > numGlyphs - 1)
{
return gs_throw1(-1, ""glyph index %lu out of range"", (ulong)glyph);
}
glyph_name_index = u16(postp + 34 + (glyph * 2));
if ( glyph_name_index > 0x7fff )
return gs_throw(-1, ""post table format error"");
if ( glyph_name_index < 258 )
{
pstr->data = (byte*) pl_mac_names[glyph_name_index];
pstr->size = strlen((char*)pstr->data);
return 0;
}
else
{
byte *mydata;
const byte *pascal_stringp = postp + 34 + (numGlyphs * 2);
glyph_name_index -= 258;
while (glyph_name_index > 0)
{
pascal_stringp += ((int)(*pascal_stringp)+1);
glyph_name_index--;
}
pstr->size = (int)(*pascal_stringp);
pstr->data = pascal_stringp + 1;
if ( pstr->data + pstr->size > postp + table_length || pstr->data - 1 < postp)
return gs_throw(-1, ""data out of range"");
mydata = gs_alloc_bytes(pfont->memory, pstr->size + 1, ""glyph to name"");
if ( mydata == 0 )
return -1;
memcpy(mydata, pascal_stringp + 1, pstr->size);
pstr->data = mydata;
mydata[pstr->size] = 0;
return 0;
}
}","static int
xps_true_callback_glyph_name(gs_font *VAR_0, gs_glyph VAR_1, gs_const_string *VAR_2)
{
int VAR_3;
int VAR_4;
ulong VAR_5;
uint VAR_6;
uint VAR_7;
const byte *VAR_8; 
if ( VAR_0->FontType != VAR_9 )
{
VAR_1 -= 29;
if (VAR_1 < 258 )
{
VAR_2->data = (byte*) VAR_10[VAR_1];
VAR_2->size = strlen((char*)VAR_2->data);
return 0;
}
else
{
return gs_throw1(-1, ""glyph index %lu out of range"", (ulong)VAR_1);
}
}
VAR_4 = xps_find_sfnt_table((xps_font_t*)VAR_0->client_data, ""post"", &VAR_3);
if (VAR_4 < 0)
return gs_throw(-1, ""no post table"");
if ( VAR_3 == 0 )
return gs_throw(-1, ""zero-size post table"");
((gs_font_type42 *)VAR_0)->data.string_proc((gs_font_type42 *)VAR_0,
VAR_4, VAR_3, &VAR_8);
VAR_5 = u32(VAR_8);
if ( VAR_5 != 0x20000 )
{
char VAR_11[32];
gs_sprintf(VAR_11, ""glyph%d"", (int)VAR_1);
VAR_2->data = (byte*)VAR_11;
VAR_2->size = strlen((char*)VAR_2->data);
return 0;
}
VAR_6 = u16(VAR_8 + 32);
if (VAR_1 > VAR_6 - 1)
{
return gs_throw1(-1, ""glyph index %lu out of range"", (ulong)VAR_1);
}
VAR_7 = u16(VAR_8 + 34 + (VAR_1 * 2));
if ( VAR_7 > 0x7fff )
return gs_throw(-1, ""post table format error"");
if ( VAR_7 < 258 )
{
VAR_2->data = (byte*) VAR_10[VAR_7];
VAR_2->size = strlen((char*)VAR_2->data);
return 0;
}
else
{
byte *VAR_12;
const byte *VAR_13 = VAR_8 + 34 + (VAR_6 * 2);
VAR_7 -= 258;
while (VAR_7 > 0)
{
VAR_13 += ((int)(*VAR_13)+1);
VAR_7--;
}
VAR_2->size = (int)(*VAR_13);
VAR_2->data = VAR_13 + 1;
if ( VAR_2->data + VAR_2->size > VAR_8 + VAR_3 || VAR_2->data - 1 < VAR_8)
return gs_throw(-1, ""data out of range"");
VAR_12 = gs_alloc_bytes(VAR_0->memory, VAR_2->size + 1, ""glyph to name"");
if ( VAR_12 == 0 )
return -1;
memcpy(VAR_12, VAR_13 + 1, VAR_2->size);
VAR_2->data = VAR_12;
VAR_12[VAR_2->size] = 0;
return 0;
}
}",ArtifexSoftware/ghostpdl/c53183d4e7103e87368b7cfa15367a47d559e323/xpsttf.c/vul/before/0.json,"static int
xps_true_callback_glyph_name(gs_font *pfont, gs_glyph glyph, gs_const_string *pstr)
{
    /* This function is copied verbatim from plfont.c */

    int table_length;
    int table_offset;

    ulong format;
    int numGlyphs;
    uint glyph_name_index;
    const byte *postp; /* post table pointer */

    if (glyph >= GS_MIN_GLYPH_INDEX) {
        glyph -= GS_MIN_GLYPH_INDEX;
    }

    /* guess if the font type is not truetype */
    if ( pfont->FontType != ft_TrueType )
    {
        glyph -= 29;
        if (glyph < 258 )
        {
            pstr->data = (byte*) pl_mac_names[glyph];
            pstr->size = strlen((char*)pstr->data);
            return 0;
        }
        else
        {
            return gs_throw1(-1, ""glyph index %lu out of range"", (ulong)glyph);
        }
    }

    table_offset = xps_find_sfnt_table((xps_font_t*)pfont->client_data, ""post"", &table_length);

    /* no post table */
    if (table_offset < 0)
        return gs_throw(-1, ""no post table"");

    /* this shoudn't happen but... */
    if ( table_length == 0 )
        return gs_throw(-1, ""zero-size post table"");

    ((gs_font_type42 *)pfont)->data.string_proc((gs_font_type42 *)pfont,
                                                table_offset, table_length, &postp);
    format = u32(postp);

    /* Format 1.0 (mac encoding) is a simple table see the TT spec.
     * We don't implement this because we don't see it in practice.
     * Format 2.5 is deprecated.
     * Format 3.0 means that there is no post data in the font file.
     * We see this a lot but can't do much about it.
     * The only format we support is 2.0.
     */
    if ( format != 0x20000 )
    {
        /* Invent a name if we don't know the table format. */
        char buf[32];
        gs_sprintf(buf, ""glyph%d"", (int)glyph);
        pstr->data = (byte*)buf;
        pstr->size = strlen((char*)pstr->data);
        return 0;
    }

    /* skip over the post header */
    numGlyphs = (int)u16(postp + 32);
    if ((int)glyph > numGlyphs - 1)
    {
        return gs_throw1(-1, ""glyph index %lu out of range"", (ulong)glyph);
    }

    /* glyph name index starts at post + 34 each entry is 2 bytes */
    glyph_name_index = u16(postp + 34 + (glyph * 2));

    /* this shouldn't happen */
    if ( glyph_name_index > 0x7fff )
        return gs_throw(-1, ""post table format error"");

    /* mac easy */
    if ( glyph_name_index < 258 )
    {
        // dmprintf2(pfont->memory, ""glyph name (mac) %d = %s\n"", glyph, pl_mac_names[glyph_name_index]);
        pstr->data = (byte*) pl_mac_names[glyph_name_index];
        pstr->size = strlen((char*)pstr->data);
        return 0;
    }

    /* not mac */
    else
    {
        byte *mydata;

        /* and here's the tricky part */
        const byte *pascal_stringp = postp + 34 + (numGlyphs * 2);

        /* 0 - 257 lives in the mac table above */
        glyph_name_index -= 258;

        /* The string we want is the index'th pascal string,
         * so we ""hop"" to each length byte ""index"" times. */
        while (glyph_name_index > 0)
        {
            pascal_stringp += ((int)(*pascal_stringp)+1);
            glyph_name_index--;
        }

        /* length byte */
        pstr->size = (int)(*pascal_stringp);

        /* + 1 is for the length byte */
        pstr->data = pascal_stringp + 1;

        /* sanity check */
        if ( pstr->data + pstr->size > postp + table_length || pstr->data - 1 < postp)
            return gs_throw(-1, ""data out of range"");

        /* sigh - we have to allocate a copy of the data - by the
         * time a high level device makes use of it the font data
         * may be freed. This is a necessary leak. */
        mydata = gs_alloc_bytes(pfont->memory, pstr->size + 1, ""glyph to name"");
        if ( mydata == 0 )
            return -1;
        memcpy(mydata, pascal_stringp + 1, pstr->size);
        pstr->data = mydata;

        mydata[pstr->size] = 0;

        return 0;
    }
}","static int
xps_true_callback_glyph_name(gs_font *VAR_0, gs_glyph VAR_1, gs_const_string *VAR_2)
{
    /* COMMENT_0 */

    int VAR_3;
    int VAR_4;

    ulong VAR_5;
    int VAR_6;
    uint VAR_7;
    const byte *VAR_8; /* COMMENT_1 */

    if (VAR_1 >= VAR_9) {
        VAR_1 -= VAR_9;
    }

    /* COMMENT_2 */
    if ( VAR_0->FontType != VAR_10 )
    {
        VAR_1 -= 29;
        if (VAR_1 < 258 )
        {
            VAR_2->data = (byte*) VAR_11[VAR_1];
            VAR_2->size = strlen((char*)VAR_2->data);
            return 0;
        }
        else
        {
            return gs_throw1(-1, ""glyph index %lu out of range"", (ulong)VAR_1);
        }
    }

    VAR_4 = xps_find_sfnt_table((xps_font_t*)VAR_0->client_data, ""post"", &VAR_3);

    /* COMMENT_3 */
    if (VAR_4 < 0)
        return gs_throw(-1, ""no post table"");

    /* COMMENT_4 */
    if ( VAR_3 == 0 )
        return gs_throw(-1, ""zero-size post table"");

    ((gs_font_type42 *)VAR_0)->data.string_proc((gs_font_type42 *)VAR_0,
                                                VAR_4, VAR_3, &VAR_8);
    VAR_5 = u32(VAR_8);

    /* COMMENT_5 */
                                                                   
                                
                                                                    
                                                    
                                         
       
    if ( VAR_5 != 0x20000 )
    {
        /* COMMENT_12 */
        char VAR_12[32];
        gs_sprintf(VAR_12, ""glyph%d"", (int)VAR_1);
        VAR_2->data = (byte*)VAR_12;
        VAR_2->size = strlen((char*)VAR_2->data);
        return 0;
    }

    /* COMMENT_13 */
    VAR_6 = (int)u16(VAR_8 + 32);
    if ((int)VAR_1 > VAR_6 - 1)
    {
        return gs_throw1(-1, ""glyph index %lu out of range"", (ulong)VAR_1);
    }

    /* COMMENT_14 */
    VAR_7 = u16(VAR_8 + 34 + (VAR_1 * 2));

    /* COMMENT_15 */
    if ( VAR_7 > 0x7fff )
        return gs_throw(-1, ""post table format error"");

    /* COMMENT_16 */
    if ( VAR_7 < 258 )
    {
        /* COMMENT_17 */
        VAR_2->data = (byte*) VAR_11[VAR_7];
        VAR_2->size = strlen((char*)VAR_2->data);
        return 0;
    }

    /* COMMENT_18 */
    else
    {
        byte *VAR_13;

        /* COMMENT_19 */
        const byte *VAR_14 = VAR_8 + 34 + (VAR_6 * 2);

        /* COMMENT_20 */
        VAR_7 -= 258;

        /* COMMENT_21 */
                                                            
        while (VAR_7 > 0)
        {
            VAR_14 += ((int)(*VAR_14)+1);
            VAR_7--;
        }

        /* COMMENT_23 */
        VAR_2->size = (int)(*VAR_14);

        /* COMMENT_24 */
        VAR_2->data = VAR_14 + 1;

        /* COMMENT_25 */
        if ( VAR_2->data + VAR_2->size > VAR_8 + VAR_3 || VAR_2->data - 1 < VAR_8)
            return gs_throw(-1, ""data out of range"");

        /* COMMENT_26 */
                                                                 
                                                     
        VAR_13 = gs_alloc_bytes(VAR_0->memory, VAR_2->size + 1, ""glyph to name"");
        if ( VAR_13 == 0 )
            return -1;
        memcpy(VAR_13, VAR_14 + 1, VAR_2->size);
        VAR_2->data = VAR_13;

        VAR_13[VAR_2->size] = 0;

        return 0;
    }
}",ArtifexSoftware/ghostpdl/c53183d4e7103e87368b7cfa15367a47d559e323/xpsttf.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,9 +7,13 @@
     int table_offset;
 
     ulong format;
-    uint numGlyphs;
+    int numGlyphs;
     uint glyph_name_index;
     const byte *postp; /* post table pointer */
+
+    if (glyph >= GS_MIN_GLYPH_INDEX) {
+        glyph -= GS_MIN_GLYPH_INDEX;
+    }
 
     /* guess if the font type is not truetype */
     if ( pfont->FontType != ft_TrueType )
@@ -59,8 +63,8 @@
     }
 
     /* skip over the post header */
-    numGlyphs = u16(postp + 32);
-    if (glyph > numGlyphs - 1)
+    numGlyphs = (int)u16(postp + 32);
+    if ((int)glyph > numGlyphs - 1)
     {
         return gs_throw1(-1, ""glyph index %lu out of range"", (ulong)glyph);
     }","{'deleted_lines': ['    uint numGlyphs;', '    numGlyphs = u16(postp + 32);', '    if (glyph > numGlyphs - 1)'], 'added_lines': ['    int numGlyphs;', '', '    if (glyph >= GS_MIN_GLYPH_INDEX) {', '        glyph -= GS_MIN_GLYPH_INDEX;', '    }', '    numGlyphs = (int)u16(postp + 32);', '    if ((int)glyph > numGlyphs - 1)']}",True,The xps_true_callback_glyph_name function in xps/xpsttf.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (Segmentation Violation and application crash) via a crafted file.,7.8,HIGH,2,test,2017-06-14T08:16:02Z,1
CVE-2017-9620,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ArtifexSoftware/ghostpdl,Bug 698050: xps: bounds check offset for requested cmap table,3ee55637480d5e319a5de0481b01c3346855cbc9,https://github.com/ArtifexSoftware/ghostpdl/commit/3ee55637480d5e319a5de0481b01c3346855cbc9,xps/xpsglyphs.c,xps_select_best_font_encoding,"static void
xps_select_best_font_encoding(xps_font_t *font)
{
static struct { int pid, eid; } xps_cmap_list[] =
{
{ 3, 10 },      
{ 3, 1 },       
{ 3, 5 },       
{ 3, 4 },       
{ 3, 3 },       
{ 3, 2 },       
{ 3, 0 },       
{ 1, 0 },
{ -1, -1 },
};
int i, k, n, pid, eid;
n = xps_count_font_encodings(font);
for (k = 0; xps_cmap_list[k].pid != -1; k++)
{
for (i = 0; i < n; i++)
{
xps_identify_font_encoding(font, i, &pid, &eid);
if (pid == xps_cmap_list[k].pid && eid == xps_cmap_list[k].eid)
{
xps_select_font_encoding(font, i);
return;
}
}
}
gs_warn(""could not find a suitable cmap"");
}","static void
xps_select_best_font_encoding(xps_font_t *VAR_0)
{
static struct { int pid, eid; } VAR_1[] =
{
{ 3, 10 },      
{ 3, 1 },       
{ 3, 5 },       
{ 3, 4 },       
{ 3, 3 },       
{ 3, 2 },       
{ 3, 0 },       
{ 1, 0 },
{ -1, -1 },
};
int VAR_2, VAR_3, VAR_4, VAR_5, VAR_6;
VAR_4 = xps_count_font_encodings(VAR_0);
for (VAR_3 = 0; VAR_1[VAR_3].pid != -1; VAR_3++)
{
for (VAR_2 = 0; VAR_2 < VAR_4; VAR_2++)
{
xps_identify_font_encoding(VAR_0, VAR_2, &VAR_5, &VAR_6);
if (VAR_5 == VAR_1[VAR_3].pid && VAR_6 == VAR_1[VAR_3].eid)
{
xps_select_font_encoding(VAR_0, VAR_2);
return;
}
}
}
gs_warn(""could not find a suitable cmap"");
}",ArtifexSoftware/ghostpdl/3ee55637480d5e319a5de0481b01c3346855cbc9/xpsglyphs.c/vul/before/0.json,"static void
xps_select_best_font_encoding(xps_font_t *font)
{
    static struct { int pid, eid; } xps_cmap_list[] =
    {
        { 3, 10 },      /* Unicode with surrogates */
        { 3, 1 },       /* Unicode without surrogates */
        { 3, 5 },       /* Wansung */
        { 3, 4 },       /* Big5 */
        { 3, 3 },       /* Prc */
        { 3, 2 },       /* ShiftJis */
        { 3, 0 },       /* Symbol */
        { 1, 0 },
        { -1, -1 },
    };

    int i, k, n, pid, eid;

    n = xps_count_font_encodings(font);
    for (k = 0; xps_cmap_list[k].pid != -1; k++)
    {
        for (i = 0; i < n; i++)
        {
            xps_identify_font_encoding(font, i, &pid, &eid);
            if (pid == xps_cmap_list[k].pid && eid == xps_cmap_list[k].eid)
            {
                if (xps_select_font_encoding(font, i))
                    return;
            }
        }
    }

    gs_warn(""could not find a suitable cmap"");
}","static void
xps_select_best_font_encoding(xps_font_t *VAR_0)
{
    static struct { int pid, eid; } VAR_1[] =
    {
        { 3, 10 },      /* COMMENT_0 */
        { 3, 1 },       /* COMMENT_1 */
        { 3, 5 },       /* COMMENT_2 */
        { 3, 4 },       /* COMMENT_3 */
        { 3, 3 },       /* COMMENT_4 */
        { 3, 2 },       /* COMMENT_5 */
        { 3, 0 },       /* COMMENT_6 */
        { 1, 0 },
        { -1, -1 },
    };

    int VAR_2, VAR_3, VAR_4, VAR_5, VAR_6;

    VAR_4 = xps_count_font_encodings(VAR_0);
    for (VAR_3 = 0; VAR_1[VAR_3].pid != -1; VAR_3++)
    {
        for (VAR_2 = 0; VAR_2 < VAR_4; VAR_2++)
        {
            xps_identify_font_encoding(VAR_0, VAR_2, &VAR_5, &VAR_6);
            if (VAR_5 == VAR_1[VAR_3].pid && VAR_6 == VAR_1[VAR_3].eid)
            {
                if (xps_select_font_encoding(VAR_0, VAR_2))
                    return;
            }
        }
    }

    gs_warn(""could not find a suitable cmap"");
}",ArtifexSoftware/ghostpdl/3ee55637480d5e319a5de0481b01c3346855cbc9/xpsglyphs.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -24,8 +24,8 @@
             xps_identify_font_encoding(font, i, &pid, &eid);
             if (pid == xps_cmap_list[k].pid && eid == xps_cmap_list[k].eid)
             {
-                xps_select_font_encoding(font, i);
-                return;
+                if (xps_select_font_encoding(font, i))
+                    return;
             }
         }
     }","{'deleted_lines': ['                xps_select_font_encoding(font, i);', '                return;'], 'added_lines': ['                if (xps_select_font_encoding(font, i))', '                    return;']}",True,"The xps_select_font_encoding function in xps/xpsfont.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) or possibly have unspecified other impact via a crafted document, related to the xps_encode_font_char_imp function.",7.8,HIGH,2,test,2017-06-14T09:14:51Z,1
CVE-2017-9620,['CWE-125'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ArtifexSoftware/ghostpdl,Bug 698050: xps: bounds check offset for requested cmap table,3ee55637480d5e319a5de0481b01c3346855cbc9,https://github.com/ArtifexSoftware/ghostpdl/commit/3ee55637480d5e319a5de0481b01c3346855cbc9,xps/xpsfont.c,xps_select_font_encoding,"void
xps_select_font_encoding(xps_font_t *font, int idx)
{
byte *cmapdata, *entry;
int pid, eid;
if (idx < 0 || idx >= font->cmapsubcount)
return;
cmapdata = font->data + font->cmaptable;
entry = cmapdata + 4 + idx * 8;
pid = u16(entry + 0);
eid = u16(entry + 2);
font->cmapsubtable = font->cmaptable + u32(entry + 4);
font->usepua = (pid == 3 && eid == 0);
}","void
xps_select_font_encoding(xps_font_t *VAR_0, int VAR_1)
{
byte *VAR_2, *VAR_3;
int VAR_4, VAR_5;
if (VAR_1 < 0 || VAR_1 >= VAR_0->cmapsubcount)
return;
VAR_2 = VAR_0->data + VAR_0->cmaptable;
VAR_3 = VAR_2 + 4 + VAR_1 * 8;
VAR_4 = u16(VAR_3 + 0);
VAR_5 = u16(VAR_3 + 2);
VAR_0->cmapsubtable = VAR_0->cmaptable + u32(VAR_3 + 4);
VAR_0->usepua = (VAR_4 == 3 && VAR_5 == 0);
}",ArtifexSoftware/ghostpdl/3ee55637480d5e319a5de0481b01c3346855cbc9/xpsfont.c/vul/before/0.json,"int
xps_select_font_encoding(xps_font_t *font, int idx)
{
    byte *cmapdata, *entry;
    int pid, eid;
    if (idx < 0 || idx >= font->cmapsubcount)
        return 0;
    cmapdata = font->data + font->cmaptable;
    entry = cmapdata + 4 + idx * 8;
    pid = u16(entry + 0);
    eid = u16(entry + 2);
    font->cmapsubtable = font->cmaptable + u32(entry + 4);
    if (font->cmapsubtable >= font->length) {
        font->cmapsubtable = 0;
        return 0;
    }
    font->usepua = (pid == 3 && eid == 0);
    return 1;
}","int
xps_select_font_encoding(xps_font_t *VAR_0, int VAR_1)
{
    byte *VAR_2, *VAR_3;
    int VAR_4, VAR_5;
    if (VAR_1 < 0 || VAR_1 >= VAR_0->cmapsubcount)
        return 0;
    VAR_2 = VAR_0->data + VAR_0->cmaptable;
    VAR_3 = VAR_2 + 4 + VAR_1 * 8;
    VAR_4 = u16(VAR_3 + 0);
    VAR_5 = u16(VAR_3 + 2);
    VAR_0->cmapsubtable = VAR_0->cmaptable + u32(VAR_3 + 4);
    if (VAR_0->cmapsubtable >= VAR_0->length) {
        VAR_0->cmapsubtable = 0;
        return 0;
    }
    VAR_0->usepua = (VAR_4 == 3 && VAR_5 == 0);
    return 1;
}",ArtifexSoftware/ghostpdl/3ee55637480d5e319a5de0481b01c3346855cbc9/xpsfont.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,14 +1,19 @@
-void
+int
 xps_select_font_encoding(xps_font_t *font, int idx)
 {
     byte *cmapdata, *entry;
     int pid, eid;
     if (idx < 0 || idx >= font->cmapsubcount)
-        return;
+        return 0;
     cmapdata = font->data + font->cmaptable;
     entry = cmapdata + 4 + idx * 8;
     pid = u16(entry + 0);
     eid = u16(entry + 2);
     font->cmapsubtable = font->cmaptable + u32(entry + 4);
+    if (font->cmapsubtable >= font->length) {
+        font->cmapsubtable = 0;
+        return 0;
+    }
     font->usepua = (pid == 3 && eid == 0);
+    return 1;
 }","{'deleted_lines': ['void', '        return;'], 'added_lines': ['int', '        return 0;', '    if (font->cmapsubtable >= font->length) {', '        font->cmapsubtable = 0;', '        return 0;', '    }', '    return 1;']}",True,"The xps_select_font_encoding function in xps/xpsfont.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) or possibly have unspecified other impact via a crafted document, related to the xps_encode_font_char_imp function.",7.8,HIGH,2,test,2017-06-14T09:14:51Z,1
CVE-2017-14032,['CWE-287'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,Mbed-TLS/mbedtls,"Improve behaviour on fatal errors

If we didn't walk the whole chain, then there may be any kind of errors in the
part of the chain we didn't check, so setting all flags looks like the safe
thing to do.",d15795acd5074e0b44e71f7ede8bdfe1b48591fc,https://github.com/Mbed-TLS/mbedtls/commit/d15795acd5074e0b44e71f7ede8bdfe1b48591fc,library/x509_crt.c,mbedtls_x509_crt_verify_with_profile,"int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,
mbedtls_x509_crt *trust_ca,
mbedtls_x509_crl *ca_crl,
const mbedtls_x509_crt_profile *profile,
const char *cn, uint32_t *flags,
int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
void *p_vrfy )
{
size_t cn_len;
int ret;
int pathlen = 0, selfsigned = 0;
mbedtls_x509_crt *parent;
mbedtls_x509_name *name;
mbedtls_x509_sequence *cur = NULL;
mbedtls_pk_type_t pk_type;
if( profile == NULL )
return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
*flags = 0;
if( cn != NULL )
{
name = &crt->subject;
cn_len = strlen( cn );
if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )
{
cur = &crt->subject_alt_names;
while( cur != NULL )
{
if( cur->buf.len == cn_len &&
x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )
break;
if( cur->buf.len > 2 &&
memcmp( cur->buf.p, ""*."", 2 ) == 0 &&
x509_check_wildcard( cn, &cur->buf ) == 0 )
{
break;
}
cur = cur->next;
}
if( cur == NULL )
*flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
}
else
{
while( name != NULL )
{
if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )
{
if( name->val.len == cn_len &&
x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )
break;
if( name->val.len > 2 &&
memcmp( name->val.p, ""*."", 2 ) == 0 &&
x509_check_wildcard( cn, &name->val ) == 0 )
break;
}
name = name->next;
}
if( name == NULL )
*flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
}
}
pk_type = mbedtls_pk_get_type( &crt->pk );
if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )
*flags |= MBEDTLS_X509_BADCERT_BAD_PK;
if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )
*flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
for( parent = trust_ca; parent != NULL; parent = parent->next )
{
if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
break;
}
if( parent != NULL )
{
ret = x509_crt_verify_top( crt, parent, ca_crl, profile,
pathlen, selfsigned, flags, f_vrfy, p_vrfy );
if( ret != 0 )
return( ret );
}
else
{
for( parent = crt->next; parent != NULL; parent = parent->next )
if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
break;
if( parent != NULL )
{
ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,
pathlen, selfsigned, flags, f_vrfy, p_vrfy );
if( ret != 0 )
return( ret );
}
else
{
ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,
pathlen, selfsigned, flags, f_vrfy, p_vrfy );
if( ret != 0 )
return( ret );
}
}
if( *flags != 0 )
return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );
return( 0 );
}","int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *VAR_0,
mbedtls_x509_crt *VAR_1,
mbedtls_x509_crl *VAR_2,
const mbedtls_x509_crt_profile *VAR_3,
const char *VAR_4, uint32_t *VAR_5,
int (*VAR_6)(void *, mbedtls_x509_crt *, int, uint32_t *),
void *VAR_7 )
{
size_t VAR_8;
int VAR_9;
int VAR_10 = 0, VAR_11 = 0;
mbedtls_x509_crt *VAR_12;
mbedtls_x509_name *VAR_13;
mbedtls_x509_sequence *VAR_14 = NULL;
mbedtls_pk_type_t VAR_15;
if( VAR_3 == NULL )
return( VAR_16 );
*VAR_5 = 0;
if( VAR_4 != NULL )
{
VAR_13 = &VAR_0->subject;
VAR_8 = strlen( VAR_4 );
if( VAR_0->ext_types & VAR_17 )
{
VAR_14 = &VAR_0->subject_alt_names;
while( VAR_14 != NULL )
{
if( VAR_14->buf.len == VAR_8 &&
x509_memcasecmp( VAR_4, VAR_14->buf.p, VAR_8 ) == 0 )
break;
if( VAR_14->buf.len > 2 &&
memcmp( VAR_14->buf.p, ""*."", 2 ) == 0 &&
x509_check_wildcard( VAR_4, &VAR_14->buf ) == 0 )
{
break;
}
VAR_14 = VAR_14->next;
}
if( VAR_14 == NULL )
*VAR_5 |= VAR_18;
}
else
{
while( VAR_13 != NULL )
{
if( MBEDTLS_OID_CMP( VAR_19, &VAR_13->oid ) == 0 )
{
if( VAR_13->val.len == VAR_8 &&
x509_memcasecmp( VAR_13->val.p, VAR_4, VAR_8 ) == 0 )
break;
if( VAR_13->val.len > 2 &&
memcmp( VAR_13->val.p, ""*."", 2 ) == 0 &&
x509_check_wildcard( VAR_4, &VAR_13->val ) == 0 )
break;
}
VAR_13 = VAR_13->next;
}
if( VAR_13 == NULL )
*VAR_5 |= VAR_18;
}
}
VAR_15 = mbedtls_pk_get_type( &VAR_0->pk );
if( x509_profile_check_pk_alg( VAR_3, VAR_15 ) != 0 )
*VAR_5 |= VAR_20;
if( x509_profile_check_key( VAR_3, VAR_15, &VAR_0->pk ) != 0 )
*VAR_5 |= VAR_21;
for( VAR_12 = VAR_1; VAR_12 != NULL; VAR_12 = VAR_12->next )
{
if( x509_crt_check_parent( VAR_0, VAR_12, 0, VAR_10 == 0 ) == 0 )
break;
}
if( VAR_12 != NULL )
{
VAR_9 = x509_crt_verify_top( VAR_0, VAR_12, VAR_2, VAR_3,
VAR_10, VAR_11, VAR_5, VAR_6, VAR_7 );
if( VAR_9 != 0 )
return( VAR_9 );
}
else
{
for( VAR_12 = VAR_0->next; VAR_12 != NULL; VAR_12 = VAR_12->next )
if( x509_crt_check_parent( VAR_0, VAR_12, 0, VAR_10 == 0 ) == 0 )
break;
if( VAR_12 != NULL )
{
VAR_9 = x509_crt_verify_child( VAR_0, VAR_12, VAR_1, VAR_2, VAR_3,
VAR_10, VAR_11, VAR_5, VAR_6, VAR_7 );
if( VAR_9 != 0 )
return( VAR_9 );
}
else
{
VAR_9 = x509_crt_verify_top( VAR_0, VAR_1, VAR_2, VAR_3,
VAR_10, VAR_11, VAR_5, VAR_6, VAR_7 );
if( VAR_9 != 0 )
return( VAR_9 );
}
}
if( *VAR_5 != 0 )
return( VAR_22 );
return( 0 );
}",Mbed-TLS/mbedtls/d15795acd5074e0b44e71f7ede8bdfe1b48591fc/x509_crt.c/vul/before/0.json,"int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,
                     mbedtls_x509_crt *trust_ca,
                     mbedtls_x509_crl *ca_crl,
                     const mbedtls_x509_crt_profile *profile,
                     const char *cn, uint32_t *flags,
                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
                     void *p_vrfy )
{
    size_t cn_len;
    int ret;
    int pathlen = 0, selfsigned = 0;
    mbedtls_x509_crt *parent;
    mbedtls_x509_name *name;
    mbedtls_x509_sequence *cur = NULL;
    mbedtls_pk_type_t pk_type;

    *flags = 0;

    if( profile == NULL )
    {
        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;
        goto exit;
    }

    if( cn != NULL )
    {
        name = &crt->subject;
        cn_len = strlen( cn );

        if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )
        {
            cur = &crt->subject_alt_names;

            while( cur != NULL )
            {
                if( cur->buf.len == cn_len &&
                    x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )
                    break;

                if( cur->buf.len > 2 &&
                    memcmp( cur->buf.p, ""*."", 2 ) == 0 &&
                    x509_check_wildcard( cn, &cur->buf ) == 0 )
                {
                    break;
                }

                cur = cur->next;
            }

            if( cur == NULL )
                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
        }
        else
        {
            while( name != NULL )
            {
                if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )
                {
                    if( name->val.len == cn_len &&
                        x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )
                        break;

                    if( name->val.len > 2 &&
                        memcmp( name->val.p, ""*."", 2 ) == 0 &&
                        x509_check_wildcard( cn, &name->val ) == 0 )
                        break;
                }

                name = name->next;
            }

            if( name == NULL )
                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
        }
    }

    /* Check the type and size of the key */
    pk_type = mbedtls_pk_get_type( &crt->pk );

    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;

    if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;

    /* Look for a parent in trusted CAs */
    for( parent = trust_ca; parent != NULL; parent = parent->next )
    {
        if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
            break;
    }

    if( parent != NULL )
    {
        ret = x509_crt_verify_top( crt, parent, ca_crl, profile,
                                   pathlen, selfsigned, flags, f_vrfy, p_vrfy );
        if( ret != 0 )
            goto exit;
    }
    else
    {
        /* Look for a parent upwards the chain */
        for( parent = crt->next; parent != NULL; parent = parent->next )
            if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
                break;

        /* Are we part of the chain or at the top? */
        if( parent != NULL )
        {
            ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,
                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );
            if( ret != 0 )
                goto exit;
        }
        else
        {
            ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,
                                       pathlen, selfsigned, flags, f_vrfy, p_vrfy );
            if( ret != 0 )
                goto exit;
        }
    }

exit:
    if( ret != 0 )
    {
        *flags = (uint32_t) -1;
        return( ret );
    }

    if( *flags != 0 )
        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );

    return( 0 );
}","int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *VAR_0,
                     mbedtls_x509_crt *VAR_1,
                     mbedtls_x509_crl *VAR_2,
                     const mbedtls_x509_crt_profile *VAR_3,
                     const char *VAR_4, uint32_t *VAR_5,
                     int (*VAR_6)(void *, mbedtls_x509_crt *, int, uint32_t *),
                     void *VAR_7 )
{
    size_t VAR_8;
    int VAR_9;
    int VAR_10 = 0, VAR_11 = 0;
    mbedtls_x509_crt *VAR_12;
    mbedtls_x509_name *VAR_13;
    mbedtls_x509_sequence *VAR_14 = NULL;
    mbedtls_pk_type_t VAR_15;

    *VAR_5 = 0;

    if( VAR_3 == NULL )
    {
        VAR_9 = VAR_16;
        goto exit;
    }

    if( VAR_4 != NULL )
    {
        VAR_13 = &VAR_0->subject;
        VAR_8 = strlen( VAR_4 );

        if( VAR_0->ext_types & VAR_17 )
        {
            VAR_14 = &VAR_0->subject_alt_names;

            while( VAR_14 != NULL )
            {
                if( VAR_14->buf.len == VAR_8 &&
                    x509_memcasecmp( VAR_4, VAR_14->buf.p, VAR_8 ) == 0 )
                    break;

                if( VAR_14->buf.len > 2 &&
                    memcmp( VAR_14->buf.p, ""*."", 2 ) == 0 &&
                    x509_check_wildcard( VAR_4, &VAR_14->buf ) == 0 )
                {
                    break;
                }

                VAR_14 = VAR_14->next;
            }

            if( VAR_14 == NULL )
                *VAR_5 |= VAR_18;
        }
        else
        {
            while( VAR_13 != NULL )
            {
                if( MBEDTLS_OID_CMP( VAR_19, &VAR_13->oid ) == 0 )
                {
                    if( VAR_13->val.len == VAR_8 &&
                        x509_memcasecmp( VAR_13->val.p, VAR_4, VAR_8 ) == 0 )
                        break;

                    if( VAR_13->val.len > 2 &&
                        memcmp( VAR_13->val.p, ""*."", 2 ) == 0 &&
                        x509_check_wildcard( VAR_4, &VAR_13->val ) == 0 )
                        break;
                }

                VAR_13 = VAR_13->next;
            }

            if( VAR_13 == NULL )
                *VAR_5 |= VAR_18;
        }
    }

    /* COMMENT_0 */
    VAR_15 = mbedtls_pk_get_type( &VAR_0->pk );

    if( x509_profile_check_pk_alg( VAR_3, VAR_15 ) != 0 )
        *VAR_5 |= VAR_20;

    if( x509_profile_check_key( VAR_3, VAR_15, &VAR_0->pk ) != 0 )
        *VAR_5 |= VAR_21;

    /* COMMENT_1 */
    for( VAR_12 = VAR_1; VAR_12 != NULL; VAR_12 = VAR_12->next )
    {
        if( x509_crt_check_parent( VAR_0, VAR_12, 0, VAR_10 == 0 ) == 0 )
            break;
    }

    if( VAR_12 != NULL )
    {
        VAR_9 = x509_crt_verify_top( VAR_0, VAR_12, VAR_2, VAR_3,
                                   VAR_10, VAR_11, VAR_5, VAR_6, VAR_7 );
        if( VAR_9 != 0 )
            goto exit;
    }
    else
    {
        /* COMMENT_2 */
        for( VAR_12 = VAR_0->next; VAR_12 != NULL; VAR_12 = VAR_12->next )
            if( x509_crt_check_parent( VAR_0, VAR_12, 0, VAR_10 == 0 ) == 0 )
                break;

        /* COMMENT_3 */
        if( VAR_12 != NULL )
        {
            VAR_9 = x509_crt_verify_child( VAR_0, VAR_12, VAR_1, VAR_2, VAR_3,
                                         VAR_10, VAR_11, VAR_5, VAR_6, VAR_7 );
            if( VAR_9 != 0 )
                goto exit;
        }
        else
        {
            VAR_9 = x509_crt_verify_top( VAR_0, VAR_1, VAR_2, VAR_3,
                                       VAR_10, VAR_11, VAR_5, VAR_6, VAR_7 );
            if( VAR_9 != 0 )
                goto exit;
        }
    }

exit:
    if( VAR_9 != 0 )
    {
        *VAR_5 = (uint32_t) -1;
        return( VAR_9 );
    }

    if( *VAR_5 != 0 )
        return( VAR_22 );

    return( 0 );
}",Mbed-TLS/mbedtls/d15795acd5074e0b44e71f7ede8bdfe1b48591fc/x509_crt.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,10 +14,13 @@
     mbedtls_x509_sequence *cur = NULL;
     mbedtls_pk_type_t pk_type;
 
+    *flags = 0;
+
     if( profile == NULL )
-        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
-
-    *flags = 0;
+    {
+        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;
+        goto exit;
+    }
 
     if( cn != NULL )
     {
@@ -92,7 +95,7 @@
         ret = x509_crt_verify_top( crt, parent, ca_crl, profile,
                                    pathlen, selfsigned, flags, f_vrfy, p_vrfy );
         if( ret != 0 )
-            return( ret );
+            goto exit;
     }
     else
     {
@@ -107,15 +110,22 @@
             ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,
                                          pathlen, selfsigned, flags, f_vrfy, p_vrfy );
             if( ret != 0 )
-                return( ret );
+                goto exit;
         }
         else
         {
             ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,
                                        pathlen, selfsigned, flags, f_vrfy, p_vrfy );
             if( ret != 0 )
-                return( ret );
+                goto exit;
         }
+    }
+
+exit:
+    if( ret != 0 )
+    {
+        *flags = (uint32_t) -1;
+        return( ret );
     }
 
     if( *flags != 0 )","{'deleted_lines': ['        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );', '', '    *flags = 0;', '            return( ret );', '                return( ret );', '                return( ret );'], 'added_lines': ['    *flags = 0;', '', '    {', '        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;', '        goto exit;', '    }', '            goto exit;', '                goto exit;', '                goto exit;', '    }', '', 'exit:', '    if( ret != 0 )', '    {', '        *flags = (uint32_t) -1;', '        return( ret );']}",True,"ARM mbed TLS before 1.3.21 and 2.x before 2.1.9, if optional authentication is configured, allows remote attackers to bypass peer authentication via an X.509 certificate chain with many intermediates. NOTE: although mbed TLS was formerly known as PolarSSL, the releases shipped with the PolarSSL name are not affected.",8.1,HIGH,2,test,2017-06-22T10:19:27Z,1
CVE-2017-11525,['CWE-770'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/519,fa3cf0b45980a4c2ea2345032fe43444dfb05bdb,https://github.com/ImageMagick/ImageMagick/commit/fa3cf0b45980a4c2ea2345032fe43444dfb05bdb,coders/cin.c,ReadCINImage,"static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define MonoColorType  1
#define RGBColorType  3
char
property[MagickPathExtent];
CINInfo
cin;
const unsigned char
*pixels;
Image
*image;
MagickBooleanType
status;
MagickOffsetType
offset;
QuantumInfo
*quantum_info;
QuantumType
quantum_type;
register ssize_t
i;
register Quantum
*q;
size_t
length;
ssize_t
count,
y;
unsigned char
magick[4];
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
image=AcquireImage(image_info,exception);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
offset=0;
count=ReadBlob(image,4,magick);
offset+=count;
if ((count != 4) ||
((LocaleNCompare((char *) magick,""\200\052\137\327"",4) != 0)))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&
(magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;
cin.file.image_offset=ReadBlobLong(image);
offset+=4;
cin.file.generic_length=ReadBlobLong(image);
offset+=4;
cin.file.industry_length=ReadBlobLong(image);
offset+=4;
cin.file.user_length=ReadBlobLong(image);
offset+=4;
cin.file.file_size=ReadBlobLong(image);
offset+=4;
offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)
cin.file.version);
(void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));
(void) SetImageProperty(image,""dpx:file.version"",property,exception);
offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)
cin.file.filename);
(void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));
(void) SetImageProperty(image,""dpx:file.filename"",property,exception);
offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)
cin.file.create_date);
(void) CopyMagickString(property,cin.file.create_date,
sizeof(cin.file.create_date));
(void) SetImageProperty(image,""dpx:file.create_date"",property,exception);
offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)
cin.file.create_time);
(void) CopyMagickString(property,cin.file.create_time,
sizeof(cin.file.create_time));
(void) SetImageProperty(image,""dpx:file.create_time"",property,exception);
offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)
cin.file.reserve);
cin.image.orientation=(unsigned char) ReadBlobByte(image);
offset++;
if (cin.image.orientation != (unsigned char) (~0))
(void) FormatImageProperty(image,""dpx:image.orientation"",""%d"",
cin.image.orientation);
switch (cin.image.orientation)
{
default:
case 0: image->orientation=TopLeftOrientation; break;
case 1: image->orientation=TopRightOrientation; break;
case 2: image->orientation=BottomLeftOrientation; break;
case 3: image->orientation=BottomRightOrientation; break;
case 4: image->orientation=LeftTopOrientation; break;
case 5: image->orientation=RightTopOrientation; break;
case 6: image->orientation=LeftBottomOrientation; break;
case 7: image->orientation=RightBottomOrientation; break;
}
cin.image.number_channels=(unsigned char) ReadBlobByte(image);
offset++;
offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)
cin.image.reserve1);
for (i=0; i < 8; i++)
{
cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);
offset++;
cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);
offset++;
cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);
offset++;
cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);
offset++;
cin.image.channel[i].pixels_per_line=ReadBlobLong(image);
offset+=4;
cin.image.channel[i].lines_per_image=ReadBlobLong(image);
offset+=4;
cin.image.channel[i].min_data=ReadBlobFloat(image);
offset+=4;
cin.image.channel[i].min_quantity=ReadBlobFloat(image);
offset+=4;
cin.image.channel[i].max_data=ReadBlobFloat(image);
offset+=4;
cin.image.channel[i].max_quantity=ReadBlobFloat(image);
offset+=4;
}
cin.image.white_point[0]=ReadBlobFloat(image);
offset+=4;
if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)
image->chromaticity.white_point.x=cin.image.white_point[0];
cin.image.white_point[1]=ReadBlobFloat(image);
offset+=4;
if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)
image->chromaticity.white_point.y=cin.image.white_point[1];
cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);
offset+=4;
if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)
image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];
cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);
offset+=4;
if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)
image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];
cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);
offset+=4;
if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)
image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];
cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);
offset+=4;
if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)
image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];
cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);
offset+=4;
if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)
image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];
cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);
offset+=4;
if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)
image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];
offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)
cin.image.label);
(void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));
(void) SetImageProperty(image,""dpx:image.label"",property,exception);
offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)
cin.image.reserve);
cin.data_format.interleave=(unsigned char) ReadBlobByte(image);
offset++;
cin.data_format.packing=(unsigned char) ReadBlobByte(image);
offset++;
cin.data_format.sign=(unsigned char) ReadBlobByte(image);
offset++;
cin.data_format.sense=(unsigned char) ReadBlobByte(image);
offset++;
cin.data_format.line_pad=ReadBlobLong(image);
offset+=4;
cin.data_format.channel_pad=ReadBlobLong(image);
offset+=4;
offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)
cin.data_format.reserve);
cin.origination.x_offset=ReadBlobSignedLong(image);
offset+=4;
if ((size_t) cin.origination.x_offset != ~0UL)
(void) FormatImageProperty(image,""dpx:origination.x_offset"",""%.20g"",
(double) cin.origination.x_offset);
cin.origination.y_offset=(ssize_t) ReadBlobLong(image);
offset+=4;
if ((size_t) cin.origination.y_offset != ~0UL)
(void) FormatImageProperty(image,""dpx:origination.y_offset"",""%.20g"",
(double) cin.origination.y_offset);
offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)
cin.origination.filename);
(void) CopyMagickString(property,cin.origination.filename,
sizeof(cin.origination.filename));
(void) SetImageProperty(image,""dpx:origination.filename"",property,exception);
offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)
cin.origination.create_date);
(void) CopyMagickString(property,cin.origination.create_date,
sizeof(cin.origination.create_date));
(void) SetImageProperty(image,""dpx:origination.create_date"",property,
exception);
offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)
cin.origination.create_time);
(void) CopyMagickString(property,cin.origination.create_time,
sizeof(cin.origination.create_time));
(void) SetImageProperty(image,""dpx:origination.create_time"",property,
exception);
offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)
cin.origination.device);
(void) CopyMagickString(property,cin.origination.device,
sizeof(cin.origination.device));
(void) SetImageProperty(image,""dpx:origination.device"",property,exception);
offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)
cin.origination.model);
(void) CopyMagickString(property,cin.origination.model,
sizeof(cin.origination.model));
(void) SetImageProperty(image,""dpx:origination.model"",property,exception);
(void) ResetMagickMemory(cin.origination.serial,0, 
sizeof(cin.origination.serial));
offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)
cin.origination.serial);
(void) CopyMagickString(property,cin.origination.serial,
sizeof(cin.origination.serial));
(void) SetImageProperty(image,""dpx:origination.serial"",property,exception);
cin.origination.x_pitch=ReadBlobFloat(image);
offset+=4;
cin.origination.y_pitch=ReadBlobFloat(image);
offset+=4;
cin.origination.gamma=ReadBlobFloat(image);
offset+=4;
if (IsFloatDefined(cin.origination.gamma) != MagickFalse)
image->gamma=cin.origination.gamma;
offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)
cin.origination.reserve);
if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))
{
int
c;
cin.film.id=ReadBlobByte(image);
offset++;
c=cin.film.id;
if (c != ~0)
(void) FormatImageProperty(image,""dpx:film.id"",""%d"",cin.film.id);
cin.film.type=ReadBlobByte(image);
offset++;
c=cin.film.type;
if (c != ~0)
(void) FormatImageProperty(image,""dpx:film.type"",""%d"",cin.film.type);
cin.film.offset=ReadBlobByte(image);
offset++;
c=cin.film.offset;
if (c != ~0)
(void) FormatImageProperty(image,""dpx:film.offset"",""%d"",
cin.film.offset);
cin.film.reserve1=ReadBlobByte(image);
offset++;
cin.film.prefix=ReadBlobLong(image);
offset+=4;
if (cin.film.prefix != ~0UL)
(void) FormatImageProperty(image,""dpx:film.prefix"",""%.20g"",(double)
cin.film.prefix);
cin.film.count=ReadBlobLong(image);
offset+=4;
offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)
cin.film.format);
(void) CopyMagickString(property,cin.film.format,sizeof(cin.film.format));
(void) SetImageProperty(image,""dpx:film.format"",property,exception);
cin.film.frame_position=ReadBlobLong(image);
offset+=4;
if (cin.film.frame_position != ~0UL)
(void) FormatImageProperty(image,""dpx:film.frame_position"",""%.20g"",
(double) cin.film.frame_position);
cin.film.frame_rate=ReadBlobFloat(image);
offset+=4;
if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)
(void) FormatImageProperty(image,""dpx:film.frame_rate"",""%g"",
cin.film.frame_rate);
offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)
cin.film.frame_id);
(void) CopyMagickString(property,cin.film.frame_id,
sizeof(cin.film.frame_id));
(void) SetImageProperty(image,""dpx:film.frame_id"",property,exception);
offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)
cin.film.slate_info);
(void) CopyMagickString(property,cin.film.slate_info,
sizeof(cin.film.slate_info));
(void) SetImageProperty(image,""dpx:film.slate_info"",property,exception);
offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)
cin.film.reserve);
}
if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))
{
StringInfo
*profile;
profile=BlobToStringInfo((const unsigned char *) NULL,cin.file.user_length);
if (profile == (StringInfo *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
offset+=ReadBlob(image,GetStringInfoLength(profile),
GetStringInfoDatum(profile));
(void) SetImageProfile(image,""dpx:user.data"",profile,exception);
profile=DestroyStringInfo(profile);
}
image->depth=cin.image.channel[0].bits_per_pixel;
image->columns=cin.image.channel[0].pixels_per_line;
image->rows=cin.image.channel[0].lines_per_image;
if (image_info->ping != MagickFalse)
{
(void) CloseBlob(image);
return(image);
}
for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)
{
int
c;
c=ReadBlobByte(image);
if (c == EOF)
break;
}
if (offset < (MagickOffsetType) cin.file.image_offset)
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
status=SetImageExtent(image,image->columns,image->rows,exception);
if (status == MagickFalse)
return(DestroyImageList(image));
quantum_info=AcquireQuantumInfo(image_info,image);
if (quantum_info == (QuantumInfo *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
quantum_info->quantum=32;
quantum_info->pack=MagickFalse;
quantum_type=RGBQuantum;
length=GetQuantumExtent(image,quantum_info,quantum_type);
length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);
if (cin.image.number_channels == 1)
{
quantum_type=GrayQuantum;
length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);
}
for (y=0; y < (ssize_t) image->rows; y++)
{
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (Quantum *) NULL)
break;
pixels=(const unsigned char *) ReadBlobStream(image,length,
GetQuantumPixels(quantum_info),&count);
if ((size_t) count != length)
break;
(void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
quantum_type,pixels,exception);
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
SetQuantumImageType(image,quantum_type);
quantum_info=DestroyQuantumInfo(quantum_info);
if (EOFBlob(image) != MagickFalse)
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
SetImageColorspace(image,LogColorspace,exception);
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}","static Image *ReadCINImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define VAR_2  1
#define VAR_3  3
char
VAR_4[VAR_5];
CINInfo
VAR_6;
const unsigned char
*VAR_7;
Image
*VAR_8;
MagickBooleanType
VAR_9;
MagickOffsetType
VAR_10;
QuantumInfo
*VAR_11;
QuantumType
VAR_12;
register ssize_t
VAR_13;
register Quantum
*VAR_14;
size_t
VAR_15;
ssize_t
VAR_16,
VAR_17;
unsigned char
VAR_18[4];
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_19);
if (VAR_0->debug != VAR_20)
(void) LogMagickEvent(VAR_21,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_19);
VAR_8=AcquireImage(VAR_0,VAR_1);
VAR_9=OpenBlob(VAR_0,VAR_8,VAR_22,VAR_1);
if (VAR_9 == VAR_20)
{
VAR_8=DestroyImageList(VAR_8);
return((Image *) NULL);
}
VAR_10=0;
VAR_16=ReadBlob(VAR_8,4,VAR_18);
VAR_10+=VAR_16;
if ((VAR_16 != 4) ||
((LocaleNCompare((char *) VAR_18,""\200\052\137\327"",4) != 0)))
ThrowReaderException(VAR_23,""ImproperImageHeader"");
VAR_8->endian=(VAR_18[0] == 0x80) && (VAR_18[1] == 0x2a) &&
(VAR_18[2] == 0x5f) && (VAR_18[3] == 0xd7) ? VAR_24 : VAR_25;
VAR_6.file.image_offset=ReadBlobLong(VAR_8);
VAR_10+=4;
VAR_6.file.generic_length=ReadBlobLong(VAR_8);
VAR_10+=4;
VAR_6.file.industry_length=ReadBlobLong(VAR_8);
VAR_10+=4;
VAR_6.file.user_length=ReadBlobLong(VAR_8);
VAR_10+=4;
VAR_6.file.file_size=ReadBlobLong(VAR_8);
VAR_10+=4;
VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.file.version),(unsigned char *)
VAR_6.file.version);
(void) CopyMagickString(VAR_4,VAR_6.file.version,sizeof(VAR_6.file.version));
(void) SetImageProperty(VAR_8,""dpx:file.version"",VAR_4,VAR_1);
VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.file.filename),(unsigned char *)
VAR_6.file.filename);
(void) CopyMagickString(VAR_4,VAR_6.file.filename,sizeof(VAR_6.file.filename));
(void) SetImageProperty(VAR_8,""dpx:file.filename"",VAR_4,VAR_1);
VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.file.create_date),(unsigned char *)
VAR_6.file.create_date);
(void) CopyMagickString(VAR_4,VAR_6.file.create_date,
sizeof(VAR_6.file.create_date));
(void) SetImageProperty(VAR_8,""dpx:file.create_date"",VAR_4,VAR_1);
VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.file.create_time),(unsigned char *)
VAR_6.file.create_time);
(void) CopyMagickString(VAR_4,VAR_6.file.create_time,
sizeof(VAR_6.file.create_time));
(void) SetImageProperty(VAR_8,""dpx:file.create_time"",VAR_4,VAR_1);
VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.file.reserve),(unsigned char *)
VAR_6.file.reserve);
VAR_6.image.orientation=(unsigned char) ReadBlobByte(VAR_8);
VAR_10++;
if (VAR_6.image.orientation != (unsigned char) (~0))
(void) FormatImageProperty(VAR_8,""dpx:image.orientation"",""%d"",
VAR_6.image.orientation);
switch (VAR_6.image.orientation)
{
default:
case 0: VAR_8->orientation=VAR_26; break;
case 1: VAR_8->orientation=VAR_27; break;
case 2: VAR_8->orientation=VAR_28; break;
case 3: VAR_8->orientation=VAR_29; break;
case 4: VAR_8->orientation=VAR_30; break;
case 5: VAR_8->orientation=VAR_31; break;
case 6: VAR_8->orientation=VAR_32; break;
case 7: VAR_8->orientation=VAR_33; break;
}
VAR_6.image.number_channels=(unsigned char) ReadBlobByte(VAR_8);
VAR_10++;
VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.image.reserve1),(unsigned char *)
VAR_6.image.reserve1);
for (VAR_13=0; VAR_13 < 8; VAR_13++)
{
VAR_6.image.channel[VAR_13].designator[0]=(unsigned char) ReadBlobByte(VAR_8);
VAR_10++;
VAR_6.image.channel[VAR_13].designator[1]=(unsigned char) ReadBlobByte(VAR_8);
VAR_10++;
VAR_6.image.channel[VAR_13].bits_per_pixel=(unsigned char) ReadBlobByte(VAR_8);
VAR_10++;
VAR_6.image.channel[VAR_13].reserve=(unsigned char) ReadBlobByte(VAR_8);
VAR_10++;
VAR_6.image.channel[VAR_13].pixels_per_line=ReadBlobLong(VAR_8);
VAR_10+=4;
VAR_6.image.channel[VAR_13].lines_per_image=ReadBlobLong(VAR_8);
VAR_10+=4;
VAR_6.image.channel[VAR_13].min_data=ReadBlobFloat(VAR_8);
VAR_10+=4;
VAR_6.image.channel[VAR_13].min_quantity=ReadBlobFloat(VAR_8);
VAR_10+=4;
VAR_6.image.channel[VAR_13].max_data=ReadBlobFloat(VAR_8);
VAR_10+=4;
VAR_6.image.channel[VAR_13].max_quantity=ReadBlobFloat(VAR_8);
VAR_10+=4;
}
VAR_6.image.white_point[0]=ReadBlobFloat(VAR_8);
VAR_10+=4;
if (IsFloatDefined(VAR_6.image.white_point[0]) != VAR_20)
VAR_8->chromaticity.white_point.x=VAR_6.image.white_point[0];
VAR_6.image.white_point[1]=ReadBlobFloat(VAR_8);
VAR_10+=4;
if (IsFloatDefined(VAR_6.image.white_point[1]) != VAR_20)
VAR_8->chromaticity.white_point.y=VAR_6.image.white_point[1];
VAR_6.image.red_primary_chromaticity[0]=ReadBlobFloat(VAR_8);
VAR_10+=4;
if (IsFloatDefined(VAR_6.image.red_primary_chromaticity[0]) != VAR_20)
VAR_8->chromaticity.red_primary.x=VAR_6.image.red_primary_chromaticity[0];
VAR_6.image.red_primary_chromaticity[1]=ReadBlobFloat(VAR_8);
VAR_10+=4;
if (IsFloatDefined(VAR_6.image.red_primary_chromaticity[1]) != VAR_20)
VAR_8->chromaticity.red_primary.y=VAR_6.image.red_primary_chromaticity[1];
VAR_6.image.green_primary_chromaticity[0]=ReadBlobFloat(VAR_8);
VAR_10+=4;
if (IsFloatDefined(VAR_6.image.green_primary_chromaticity[0]) != VAR_20)
VAR_8->chromaticity.red_primary.x=VAR_6.image.green_primary_chromaticity[0];
VAR_6.image.green_primary_chromaticity[1]=ReadBlobFloat(VAR_8);
VAR_10+=4;
if (IsFloatDefined(VAR_6.image.green_primary_chromaticity[1]) != VAR_20)
VAR_8->chromaticity.green_primary.y=VAR_6.image.green_primary_chromaticity[1];
VAR_6.image.blue_primary_chromaticity[0]=ReadBlobFloat(VAR_8);
VAR_10+=4;
if (IsFloatDefined(VAR_6.image.blue_primary_chromaticity[0]) != VAR_20)
VAR_8->chromaticity.blue_primary.x=VAR_6.image.blue_primary_chromaticity[0];
VAR_6.image.blue_primary_chromaticity[1]=ReadBlobFloat(VAR_8);
VAR_10+=4;
if (IsFloatDefined(VAR_6.image.blue_primary_chromaticity[1]) != VAR_20)
VAR_8->chromaticity.blue_primary.y=VAR_6.image.blue_primary_chromaticity[1];
VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.image.label),(unsigned char *)
VAR_6.image.label);
(void) CopyMagickString(VAR_4,VAR_6.image.label,sizeof(VAR_6.image.label));
(void) SetImageProperty(VAR_8,""dpx:image.label"",VAR_4,VAR_1);
VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.image.reserve),(unsigned char *)
VAR_6.image.reserve);
VAR_6.data_format.interleave=(unsigned char) ReadBlobByte(VAR_8);
VAR_10++;
VAR_6.data_format.packing=(unsigned char) ReadBlobByte(VAR_8);
VAR_10++;
VAR_6.data_format.sign=(unsigned char) ReadBlobByte(VAR_8);
VAR_10++;
VAR_6.data_format.sense=(unsigned char) ReadBlobByte(VAR_8);
VAR_10++;
VAR_6.data_format.line_pad=ReadBlobLong(VAR_8);
VAR_10+=4;
VAR_6.data_format.channel_pad=ReadBlobLong(VAR_8);
VAR_10+=4;
VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.data_format.reserve),(unsigned char *)
VAR_6.data_format.reserve);
VAR_6.origination.x_offset=ReadBlobSignedLong(VAR_8);
VAR_10+=4;
if ((size_t) VAR_6.origination.x_offset != ~0UL)
(void) FormatImageProperty(VAR_8,""dpx:origination.x_offset"",""%.20g"",
(double) VAR_6.origination.x_offset);
VAR_6.origination.y_offset=(ssize_t) ReadBlobLong(VAR_8);
VAR_10+=4;
if ((size_t) VAR_6.origination.y_offset != ~0UL)
(void) FormatImageProperty(VAR_8,""dpx:origination.y_offset"",""%.20g"",
(double) VAR_6.origination.y_offset);
VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.origination.filename),(unsigned char *)
VAR_6.origination.filename);
(void) CopyMagickString(VAR_4,VAR_6.origination.filename,
sizeof(VAR_6.origination.filename));
(void) SetImageProperty(VAR_8,""dpx:origination.filename"",VAR_4,VAR_1);
VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.origination.create_date),(unsigned char *)
VAR_6.origination.create_date);
(void) CopyMagickString(VAR_4,VAR_6.origination.create_date,
sizeof(VAR_6.origination.create_date));
(void) SetImageProperty(VAR_8,""dpx:origination.create_date"",VAR_4,
VAR_1);
VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.origination.create_time),(unsigned char *)
VAR_6.origination.create_time);
(void) CopyMagickString(VAR_4,VAR_6.origination.create_time,
sizeof(VAR_6.origination.create_time));
(void) SetImageProperty(VAR_8,""dpx:origination.create_time"",VAR_4,
VAR_1);
VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.origination.device),(unsigned char *)
VAR_6.origination.device);
(void) CopyMagickString(VAR_4,VAR_6.origination.device,
sizeof(VAR_6.origination.device));
(void) SetImageProperty(VAR_8,""dpx:origination.device"",VAR_4,VAR_1);
VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.origination.model),(unsigned char *)
VAR_6.origination.model);
(void) CopyMagickString(VAR_4,VAR_6.origination.model,
sizeof(VAR_6.origination.model));
(void) SetImageProperty(VAR_8,""dpx:origination.model"",VAR_4,VAR_1);
(void) ResetMagickMemory(VAR_6.origination.serial,0, 
sizeof(VAR_6.origination.serial));
VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.origination.serial),(unsigned char *)
VAR_6.origination.serial);
(void) CopyMagickString(VAR_4,VAR_6.origination.serial,
sizeof(VAR_6.origination.serial));
(void) SetImageProperty(VAR_8,""dpx:origination.serial"",VAR_4,VAR_1);
VAR_6.origination.x_pitch=ReadBlobFloat(VAR_8);
VAR_10+=4;
VAR_6.origination.y_pitch=ReadBlobFloat(VAR_8);
VAR_10+=4;
VAR_6.origination.gamma=ReadBlobFloat(VAR_8);
VAR_10+=4;
if (IsFloatDefined(VAR_6.origination.gamma) != VAR_20)
VAR_8->gamma=VAR_6.origination.gamma;
VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.origination.reserve),(unsigned char *)
VAR_6.origination.reserve);
if ((VAR_6.file.image_offset > 2048) && (VAR_6.file.user_length != 0))
{
int
VAR_34;
VAR_6.film.id=ReadBlobByte(VAR_8);
VAR_10++;
VAR_34=VAR_6.film.id;
if (VAR_34 != ~0)
(void) FormatImageProperty(VAR_8,""dpx:film.id"",""%d"",VAR_6.film.id);
VAR_6.film.type=ReadBlobByte(VAR_8);
VAR_10++;
VAR_34=VAR_6.film.type;
if (VAR_34 != ~0)
(void) FormatImageProperty(VAR_8,""dpx:film.type"",""%d"",VAR_6.film.type);
VAR_6.film.offset=ReadBlobByte(VAR_8);
VAR_10++;
VAR_34=VAR_6.film.offset;
if (VAR_34 != ~0)
(void) FormatImageProperty(VAR_8,""dpx:film.offset"",""%d"",
VAR_6.film.offset);
VAR_6.film.reserve1=ReadBlobByte(VAR_8);
VAR_10++;
VAR_6.film.prefix=ReadBlobLong(VAR_8);
VAR_10+=4;
if (VAR_6.film.prefix != ~0UL)
(void) FormatImageProperty(VAR_8,""dpx:film.prefix"",""%.20g"",(double)
VAR_6.film.prefix);
VAR_6.film.count=ReadBlobLong(VAR_8);
VAR_10+=4;
VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.film.format),(unsigned char *)
VAR_6.film.format);
(void) CopyMagickString(VAR_4,VAR_6.film.format,sizeof(VAR_6.film.format));
(void) SetImageProperty(VAR_8,""dpx:film.format"",VAR_4,VAR_1);
VAR_6.film.frame_position=ReadBlobLong(VAR_8);
VAR_10+=4;
if (VAR_6.film.frame_position != ~0UL)
(void) FormatImageProperty(VAR_8,""dpx:film.frame_position"",""%.20g"",
(double) VAR_6.film.frame_position);
VAR_6.film.frame_rate=ReadBlobFloat(VAR_8);
VAR_10+=4;
if (IsFloatDefined(VAR_6.film.frame_rate) != VAR_20)
(void) FormatImageProperty(VAR_8,""dpx:film.frame_rate"",""%g"",
VAR_6.film.frame_rate);
VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.film.frame_id),(unsigned char *)
VAR_6.film.frame_id);
(void) CopyMagickString(VAR_4,VAR_6.film.frame_id,
sizeof(VAR_6.film.frame_id));
(void) SetImageProperty(VAR_8,""dpx:film.frame_id"",VAR_4,VAR_1);
VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.film.slate_info),(unsigned char *)
VAR_6.film.slate_info);
(void) CopyMagickString(VAR_4,VAR_6.film.slate_info,
sizeof(VAR_6.film.slate_info));
(void) SetImageProperty(VAR_8,""dpx:film.slate_info"",VAR_4,VAR_1);
VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.film.reserve),(unsigned char *)
VAR_6.film.reserve);
}
if ((VAR_6.file.image_offset > 2048) && (VAR_6.file.user_length != 0))
{
StringInfo
*VAR_35;
VAR_35=BlobToStringInfo((const unsigned char *) NULL,VAR_6.file.user_length);
if (VAR_35 == (StringInfo *) NULL)
ThrowReaderException(VAR_36,""MemoryAllocationFailed"");
VAR_10+=ReadBlob(VAR_8,GetStringInfoLength(VAR_35),
GetStringInfoDatum(VAR_35));
(void) SetImageProfile(VAR_8,""dpx:user.data"",VAR_35,VAR_1);
VAR_35=DestroyStringInfo(VAR_35);
}
VAR_8->depth=VAR_6.image.channel[0].bits_per_pixel;
VAR_8->columns=VAR_6.image.channel[0].pixels_per_line;
VAR_8->rows=VAR_6.image.channel[0].lines_per_image;
if (VAR_0->ping != VAR_20)
{
(void) CloseBlob(VAR_8);
return(VAR_8);
}
for ( ; VAR_10 < (MagickOffsetType) VAR_6.file.image_offset; VAR_10++)
{
int
VAR_34;
VAR_34=ReadBlobByte(VAR_8);
if (VAR_34 == VAR_37)
break;
}
if (VAR_10 < (MagickOffsetType) VAR_6.file.image_offset)
ThrowReaderException(VAR_23,""ImproperImageHeader"");
VAR_9=SetImageExtent(VAR_8,VAR_8->columns,VAR_8->rows,VAR_1);
if (VAR_9 == VAR_20)
return(DestroyImageList(VAR_8));
VAR_11=AcquireQuantumInfo(VAR_0,VAR_8);
if (VAR_11 == (QuantumInfo *) NULL)
ThrowReaderException(VAR_36,""MemoryAllocationFailed"");
VAR_11->quantum=32;
VAR_11->pack=VAR_20;
VAR_12=VAR_38;
VAR_15=GetQuantumExtent(VAR_8,VAR_11,VAR_12);
VAR_15=GetBytesPerRow(VAR_8->columns,3,VAR_8->depth,VAR_39);
if (VAR_6.image.number_channels == 1)
{
VAR_12=VAR_40;
VAR_15=GetBytesPerRow(VAR_8->columns,1,VAR_8->depth,VAR_39);
}
for (VAR_17=0; VAR_17 < (ssize_t) VAR_8->rows; VAR_17++)
{
VAR_14=QueueAuthenticPixels(VAR_8,0,VAR_17,VAR_8->columns,1,VAR_1);
if (VAR_14 == (Quantum *) NULL)
break;
VAR_7=(const unsigned char *) ReadBlobStream(VAR_8,VAR_15,
GetQuantumPixels(VAR_11),&VAR_16);
if ((size_t) VAR_16 != VAR_15)
break;
(void) ImportQuantumPixels(VAR_8,(CacheView *) NULL,VAR_11,
VAR_12,VAR_7,VAR_1);
if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_20)
break;
if (VAR_8->previous == (Image *) NULL)
{
VAR_9=SetImageProgress(VAR_8,VAR_41,(MagickOffsetType) VAR_17,
VAR_8->rows);
if (VAR_9 == VAR_20)
break;
}
}
SetQuantumImageType(VAR_8,VAR_12);
VAR_11=DestroyQuantumInfo(VAR_11);
if (EOFBlob(VAR_8) != VAR_20)
ThrowFileException(VAR_1,VAR_23,""UnexpectedEndOfFile"",
VAR_8->filename);
SetImageColorspace(VAR_8,VAR_42,VAR_1);
(void) CloseBlob(VAR_8);
return(GetFirstImageInList(VAR_8));
}",ImageMagick/fa3cf0b45980a4c2ea2345032fe43444dfb05bdb/cin.c/vul/before/1.json,"static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define MonoColorType  1
#define RGBColorType  3

  char
    property[MagickPathExtent];

  CINInfo
    cin;

  const unsigned char
    *pixels;

  Image
    *image;

  MagickBooleanType
    status;

  MagickOffsetType
    offset;

  QuantumInfo
    *quantum_info;

  QuantumType
    quantum_type;

  register ssize_t
    i;

  register Quantum
    *q;

  size_t
    length;

  ssize_t
    count,
    y;

  unsigned char
    magick[4];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    File information.
  */
  offset=0;
  count=ReadBlob(image,4,magick);
  offset+=count;
  if ((count != 4) ||
      ((LocaleNCompare((char *) magick,""\200\052\137\327"",4) != 0)))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&
    (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;
  cin.file.image_offset=ReadBlobLong(image);
  offset+=4;
  cin.file.generic_length=ReadBlobLong(image);
  offset+=4;
  cin.file.industry_length=ReadBlobLong(image);
  offset+=4;
  cin.file.user_length=ReadBlobLong(image);
  offset+=4;
  cin.file.file_size=ReadBlobLong(image);
  offset+=4;
  offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)
    cin.file.version);
  (void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));
  (void) SetImageProperty(image,""dpx:file.version"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)
    cin.file.filename);
  (void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));
  (void) SetImageProperty(image,""dpx:file.filename"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)
    cin.file.create_date);
  (void) CopyMagickString(property,cin.file.create_date,
    sizeof(cin.file.create_date));
  (void) SetImageProperty(image,""dpx:file.create_date"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)
    cin.file.create_time);
  (void) CopyMagickString(property,cin.file.create_time,
    sizeof(cin.file.create_time));
  (void) SetImageProperty(image,""dpx:file.create_time"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)
    cin.file.reserve);
  /*
    Image information.
  */
  cin.image.orientation=(unsigned char) ReadBlobByte(image);
  offset++;
  if (cin.image.orientation != (unsigned char) (~0))
    (void) FormatImageProperty(image,""dpx:image.orientation"",""%d"",
      cin.image.orientation);
  switch (cin.image.orientation)
  {
    default:
    case 0: image->orientation=TopLeftOrientation; break;
    case 1: image->orientation=TopRightOrientation; break;
    case 2: image->orientation=BottomLeftOrientation; break;
    case 3: image->orientation=BottomRightOrientation; break;
    case 4: image->orientation=LeftTopOrientation; break;
    case 5: image->orientation=RightTopOrientation; break;
    case 6: image->orientation=LeftBottomOrientation; break;
    case 7: image->orientation=RightBottomOrientation; break;
  }
  cin.image.number_channels=(unsigned char) ReadBlobByte(image);
  offset++;
  offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)
    cin.image.reserve1);
  for (i=0; i < 8; i++)
  {
    cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);
    offset++;
    cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);
    offset++;
    cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);
    offset++;
    cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);
    offset++;
    cin.image.channel[i].pixels_per_line=ReadBlobLong(image);
    offset+=4;
    cin.image.channel[i].lines_per_image=ReadBlobLong(image);
    offset+=4;
    cin.image.channel[i].min_data=ReadBlobFloat(image);
    offset+=4;
    cin.image.channel[i].min_quantity=ReadBlobFloat(image);
    offset+=4;
    cin.image.channel[i].max_data=ReadBlobFloat(image);
    offset+=4;
    cin.image.channel[i].max_quantity=ReadBlobFloat(image);
    offset+=4;
  }
  cin.image.white_point[0]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)
    image->chromaticity.white_point.x=cin.image.white_point[0];
  cin.image.white_point[1]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)
    image->chromaticity.white_point.y=cin.image.white_point[1];
  cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)
    image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];
  cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)
    image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];
  cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)
    image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];
  cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)
    image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];
  cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)
    image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];
  cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)
    image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];
  offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)
    cin.image.label);
  (void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));
  (void) SetImageProperty(image,""dpx:image.label"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)
    cin.image.reserve);
  /*
    Image data format information.
  */
  cin.data_format.interleave=(unsigned char) ReadBlobByte(image);
  offset++;
  cin.data_format.packing=(unsigned char) ReadBlobByte(image);
  offset++;
  cin.data_format.sign=(unsigned char) ReadBlobByte(image);
  offset++;
  cin.data_format.sense=(unsigned char) ReadBlobByte(image);
  offset++;
  cin.data_format.line_pad=ReadBlobLong(image);
  offset+=4;
  cin.data_format.channel_pad=ReadBlobLong(image);
  offset+=4;
  offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)
    cin.data_format.reserve);
  /*
    Image origination information.
  */
  cin.origination.x_offset=ReadBlobSignedLong(image);
  offset+=4;
  if ((size_t) cin.origination.x_offset != ~0UL)
    (void) FormatImageProperty(image,""dpx:origination.x_offset"",""%.20g"",
      (double) cin.origination.x_offset);
  cin.origination.y_offset=(ssize_t) ReadBlobLong(image);
  offset+=4;
  if ((size_t) cin.origination.y_offset != ~0UL)
    (void) FormatImageProperty(image,""dpx:origination.y_offset"",""%.20g"",
      (double) cin.origination.y_offset);
  offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)
    cin.origination.filename);
  (void) CopyMagickString(property,cin.origination.filename,
    sizeof(cin.origination.filename));
  (void) SetImageProperty(image,""dpx:origination.filename"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)
    cin.origination.create_date);
  (void) CopyMagickString(property,cin.origination.create_date,
    sizeof(cin.origination.create_date));
  (void) SetImageProperty(image,""dpx:origination.create_date"",property,
    exception);
  offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)
    cin.origination.create_time);
  (void) CopyMagickString(property,cin.origination.create_time,
    sizeof(cin.origination.create_time));
  (void) SetImageProperty(image,""dpx:origination.create_time"",property,
    exception);
  offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)
    cin.origination.device);
  (void) CopyMagickString(property,cin.origination.device,
    sizeof(cin.origination.device));
  (void) SetImageProperty(image,""dpx:origination.device"",property,exception);
  offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)
    cin.origination.model);
  (void) CopyMagickString(property,cin.origination.model,
    sizeof(cin.origination.model));
  (void) SetImageProperty(image,""dpx:origination.model"",property,exception);
  (void) ResetMagickMemory(cin.origination.serial,0, 
    sizeof(cin.origination.serial));
  offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)
    cin.origination.serial);
  (void) CopyMagickString(property,cin.origination.serial,
    sizeof(cin.origination.serial));
  (void) SetImageProperty(image,""dpx:origination.serial"",property,exception);
  cin.origination.x_pitch=ReadBlobFloat(image);
  offset+=4;
  cin.origination.y_pitch=ReadBlobFloat(image);
  offset+=4;
  cin.origination.gamma=ReadBlobFloat(image);
  offset+=4;
  if (IsFloatDefined(cin.origination.gamma) != MagickFalse)
    image->gamma=cin.origination.gamma;
  offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)
    cin.origination.reserve);
  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))
    {
      int
        c;

      /*
        Image film information.
      */
      cin.film.id=ReadBlobByte(image);
      offset++;
      c=cin.film.id;
      if (c != ~0)
        (void) FormatImageProperty(image,""dpx:film.id"",""%d"",cin.film.id);
      cin.film.type=ReadBlobByte(image);
      offset++;
      c=cin.film.type;
      if (c != ~0)
        (void) FormatImageProperty(image,""dpx:film.type"",""%d"",cin.film.type);
      cin.film.offset=ReadBlobByte(image);
      offset++;
      c=cin.film.offset;
      if (c != ~0)
        (void) FormatImageProperty(image,""dpx:film.offset"",""%d"",
          cin.film.offset);
      cin.film.reserve1=ReadBlobByte(image);
      offset++;
      cin.film.prefix=ReadBlobLong(image);
      offset+=4;
      if (cin.film.prefix != ~0UL)
        (void) FormatImageProperty(image,""dpx:film.prefix"",""%.20g"",(double)
          cin.film.prefix);
      cin.film.count=ReadBlobLong(image);
      offset+=4;
      offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)
        cin.film.format);
      (void) CopyMagickString(property,cin.film.format,sizeof(cin.film.format));
      (void) SetImageProperty(image,""dpx:film.format"",property,exception);
      cin.film.frame_position=ReadBlobLong(image);
      offset+=4;
      if (cin.film.frame_position != ~0UL)
        (void) FormatImageProperty(image,""dpx:film.frame_position"",""%.20g"",
          (double) cin.film.frame_position);
      cin.film.frame_rate=ReadBlobFloat(image);
      offset+=4;
      if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)
        (void) FormatImageProperty(image,""dpx:film.frame_rate"",""%g"",
          cin.film.frame_rate);
      offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)
        cin.film.frame_id);
      (void) CopyMagickString(property,cin.film.frame_id,
        sizeof(cin.film.frame_id));
      (void) SetImageProperty(image,""dpx:film.frame_id"",property,exception);
      offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)
        cin.film.slate_info);
      (void) CopyMagickString(property,cin.film.slate_info,
        sizeof(cin.film.slate_info));
      (void) SetImageProperty(image,""dpx:film.slate_info"",property,exception);
      offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)
        cin.film.reserve);
    }
  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))
    {
      StringInfo
        *profile;

      /*
        User defined data.
      */
      if (cin.file.user_length > GetBlobSize(image))
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      profile=BlobToStringInfo((const unsigned char *) NULL,
        cin.file.user_length);
      if (profile == (StringInfo *) NULL)
        ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
      offset+=ReadBlob(image,GetStringInfoLength(profile),
        GetStringInfoDatum(profile));
      (void) SetImageProfile(image,""dpx:user.data"",profile,exception);
      profile=DestroyStringInfo(profile);
    }
  image->depth=cin.image.channel[0].bits_per_pixel;
  image->columns=cin.image.channel[0].pixels_per_line;
  image->rows=cin.image.channel[0].lines_per_image;
  if (image_info->ping != MagickFalse)
    {
      (void) CloseBlob(image);
      return(image);
    }
  for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)
  {
    int
      c;

    c=ReadBlobByte(image);
    if (c == EOF)
      break;
  }
  if (offset < (MagickOffsetType) cin.file.image_offset)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  status=SetImageExtent(image,image->columns,image->rows,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  /*
    Convert CIN raster image to pixel packets.
  */
  quantum_info=AcquireQuantumInfo(image_info,image);
  if (quantum_info == (QuantumInfo *) NULL)
    ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  quantum_info->quantum=32;
  quantum_info->pack=MagickFalse;
  quantum_type=RGBQuantum;
  length=GetQuantumExtent(image,quantum_info,quantum_type);
  length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);
  if (cin.image.number_channels == 1)
    {
      quantum_type=GrayQuantum;
      length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);
    }
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      break;
    pixels=(const unsigned char *) ReadBlobStream(image,length,
      GetQuantumPixels(quantum_info),&count);
    if ((size_t) count != length)
      break;
    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
      quantum_type,pixels,exception);
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
          image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  SetQuantumImageType(image,quantum_type);
  quantum_info=DestroyQuantumInfo(quantum_info);
  if (EOFBlob(image) != MagickFalse)
    ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
      image->filename);
  SetImageColorspace(image,LogColorspace,exception);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}","static Image *ReadCINImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
#define VAR_2  1
#define VAR_3  3

  char
    VAR_4[VAR_5];

  CINInfo
    VAR_6;

  const unsigned char
    *VAR_7;

  Image
    *VAR_8;

  MagickBooleanType
    VAR_9;

  MagickOffsetType
    VAR_10;

  QuantumInfo
    *VAR_11;

  QuantumType
    VAR_12;

  register ssize_t
    VAR_13;

  register Quantum
    *VAR_14;

  size_t
    VAR_15;

  ssize_t
    VAR_16,
    VAR_17;

  unsigned char
    VAR_18[4];

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_19);
  if (VAR_0->debug != VAR_20)
    (void) LogMagickEvent(VAR_21,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_19);
  VAR_8=AcquireImage(VAR_0,VAR_1);
  VAR_9=OpenBlob(VAR_0,VAR_8,VAR_22,VAR_1);
  if (VAR_9 == VAR_20)
    {
      VAR_8=DestroyImageList(VAR_8);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                     
    
  VAR_10=0;
  VAR_16=ReadBlob(VAR_8,4,VAR_18);
  VAR_10+=VAR_16;
  if ((VAR_16 != 4) ||
      ((LocaleNCompare((char *) VAR_18,""\200\052\137\327"",4) != 0)))
    ThrowReaderException(VAR_23,""ImproperImageHeader"");
  VAR_8->endian=(VAR_18[0] == 0x80) && (VAR_18[1] == 0x2a) &&
    (VAR_18[2] == 0x5f) && (VAR_18[3] == 0xd7) ? VAR_24 : VAR_25;
  VAR_6.file.image_offset=ReadBlobLong(VAR_8);
  VAR_10+=4;
  VAR_6.file.generic_length=ReadBlobLong(VAR_8);
  VAR_10+=4;
  VAR_6.file.industry_length=ReadBlobLong(VAR_8);
  VAR_10+=4;
  VAR_6.file.user_length=ReadBlobLong(VAR_8);
  VAR_10+=4;
  VAR_6.file.file_size=ReadBlobLong(VAR_8);
  VAR_10+=4;
  VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.file.version),(unsigned char *)
    VAR_6.file.version);
  (void) CopyMagickString(VAR_4,VAR_6.file.version,sizeof(VAR_6.file.version));
  (void) SetImageProperty(VAR_8,""dpx:file.version"",VAR_4,VAR_1);
  VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.file.filename),(unsigned char *)
    VAR_6.file.filename);
  (void) CopyMagickString(VAR_4,VAR_6.file.filename,sizeof(VAR_6.file.filename));
  (void) SetImageProperty(VAR_8,""dpx:file.filename"",VAR_4,VAR_1);
  VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.file.create_date),(unsigned char *)
    VAR_6.file.create_date);
  (void) CopyMagickString(VAR_4,VAR_6.file.create_date,
    sizeof(VAR_6.file.create_date));
  (void) SetImageProperty(VAR_8,""dpx:file.create_date"",VAR_4,VAR_1);
  VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.file.create_time),(unsigned char *)
    VAR_6.file.create_time);
  (void) CopyMagickString(VAR_4,VAR_6.file.create_time,
    sizeof(VAR_6.file.create_time));
  (void) SetImageProperty(VAR_8,""dpx:file.create_time"",VAR_4,VAR_1);
  VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.file.reserve),(unsigned char *)
    VAR_6.file.reserve);
  /* COMMENT_6 */
                      
    
  VAR_6.image.orientation=(unsigned char) ReadBlobByte(VAR_8);
  VAR_10++;
  if (VAR_6.image.orientation != (unsigned char) (~0))
    (void) FormatImageProperty(VAR_8,""dpx:image.orientation"",""%d"",
      VAR_6.image.orientation);
  switch (VAR_6.image.orientation)
  {
    default:
    case 0: VAR_8->orientation=VAR_26; break;
    case 1: VAR_8->orientation=VAR_27; break;
    case 2: VAR_8->orientation=VAR_28; break;
    case 3: VAR_8->orientation=VAR_29; break;
    case 4: VAR_8->orientation=VAR_30; break;
    case 5: VAR_8->orientation=VAR_31; break;
    case 6: VAR_8->orientation=VAR_32; break;
    case 7: VAR_8->orientation=VAR_33; break;
  }
  VAR_6.image.number_channels=(unsigned char) ReadBlobByte(VAR_8);
  VAR_10++;
  VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.image.reserve1),(unsigned char *)
    VAR_6.image.reserve1);
  for (VAR_13=0; VAR_13 < 8; VAR_13++)
  {
    VAR_6.image.channel[VAR_13].designator[0]=(unsigned char) ReadBlobByte(VAR_8);
    VAR_10++;
    VAR_6.image.channel[VAR_13].designator[1]=(unsigned char) ReadBlobByte(VAR_8);
    VAR_10++;
    VAR_6.image.channel[VAR_13].bits_per_pixel=(unsigned char) ReadBlobByte(VAR_8);
    VAR_10++;
    VAR_6.image.channel[VAR_13].reserve=(unsigned char) ReadBlobByte(VAR_8);
    VAR_10++;
    VAR_6.image.channel[VAR_13].pixels_per_line=ReadBlobLong(VAR_8);
    VAR_10+=4;
    VAR_6.image.channel[VAR_13].lines_per_image=ReadBlobLong(VAR_8);
    VAR_10+=4;
    VAR_6.image.channel[VAR_13].min_data=ReadBlobFloat(VAR_8);
    VAR_10+=4;
    VAR_6.image.channel[VAR_13].min_quantity=ReadBlobFloat(VAR_8);
    VAR_10+=4;
    VAR_6.image.channel[VAR_13].max_data=ReadBlobFloat(VAR_8);
    VAR_10+=4;
    VAR_6.image.channel[VAR_13].max_quantity=ReadBlobFloat(VAR_8);
    VAR_10+=4;
  }
  VAR_6.image.white_point[0]=ReadBlobFloat(VAR_8);
  VAR_10+=4;
  if (IsFloatDefined(VAR_6.image.white_point[0]) != VAR_20)
    VAR_8->chromaticity.white_point.x=VAR_6.image.white_point[0];
  VAR_6.image.white_point[1]=ReadBlobFloat(VAR_8);
  VAR_10+=4;
  if (IsFloatDefined(VAR_6.image.white_point[1]) != VAR_20)
    VAR_8->chromaticity.white_point.y=VAR_6.image.white_point[1];
  VAR_6.image.red_primary_chromaticity[0]=ReadBlobFloat(VAR_8);
  VAR_10+=4;
  if (IsFloatDefined(VAR_6.image.red_primary_chromaticity[0]) != VAR_20)
    VAR_8->chromaticity.red_primary.x=VAR_6.image.red_primary_chromaticity[0];
  VAR_6.image.red_primary_chromaticity[1]=ReadBlobFloat(VAR_8);
  VAR_10+=4;
  if (IsFloatDefined(VAR_6.image.red_primary_chromaticity[1]) != VAR_20)
    VAR_8->chromaticity.red_primary.y=VAR_6.image.red_primary_chromaticity[1];
  VAR_6.image.green_primary_chromaticity[0]=ReadBlobFloat(VAR_8);
  VAR_10+=4;
  if (IsFloatDefined(VAR_6.image.green_primary_chromaticity[0]) != VAR_20)
    VAR_8->chromaticity.red_primary.x=VAR_6.image.green_primary_chromaticity[0];
  VAR_6.image.green_primary_chromaticity[1]=ReadBlobFloat(VAR_8);
  VAR_10+=4;
  if (IsFloatDefined(VAR_6.image.green_primary_chromaticity[1]) != VAR_20)
    VAR_8->chromaticity.green_primary.y=VAR_6.image.green_primary_chromaticity[1];
  VAR_6.image.blue_primary_chromaticity[0]=ReadBlobFloat(VAR_8);
  VAR_10+=4;
  if (IsFloatDefined(VAR_6.image.blue_primary_chromaticity[0]) != VAR_20)
    VAR_8->chromaticity.blue_primary.x=VAR_6.image.blue_primary_chromaticity[0];
  VAR_6.image.blue_primary_chromaticity[1]=ReadBlobFloat(VAR_8);
  VAR_10+=4;
  if (IsFloatDefined(VAR_6.image.blue_primary_chromaticity[1]) != VAR_20)
    VAR_8->chromaticity.blue_primary.y=VAR_6.image.blue_primary_chromaticity[1];
  VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.image.label),(unsigned char *)
    VAR_6.image.label);
  (void) CopyMagickString(VAR_4,VAR_6.image.label,sizeof(VAR_6.image.label));
  (void) SetImageProperty(VAR_8,""dpx:image.label"",VAR_4,VAR_1);
  VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.image.reserve),(unsigned char *)
    VAR_6.image.reserve);
  /* COMMENT_9 */
                                  
    
  VAR_6.data_format.interleave=(unsigned char) ReadBlobByte(VAR_8);
  VAR_10++;
  VAR_6.data_format.packing=(unsigned char) ReadBlobByte(VAR_8);
  VAR_10++;
  VAR_6.data_format.sign=(unsigned char) ReadBlobByte(VAR_8);
  VAR_10++;
  VAR_6.data_format.sense=(unsigned char) ReadBlobByte(VAR_8);
  VAR_10++;
  VAR_6.data_format.line_pad=ReadBlobLong(VAR_8);
  VAR_10+=4;
  VAR_6.data_format.channel_pad=ReadBlobLong(VAR_8);
  VAR_10+=4;
  VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.data_format.reserve),(unsigned char *)
    VAR_6.data_format.reserve);
  /* COMMENT_12 */
                                  
    
  VAR_6.origination.x_offset=ReadBlobSignedLong(VAR_8);
  VAR_10+=4;
  if ((size_t) VAR_6.origination.x_offset != ~0UL)
    (void) FormatImageProperty(VAR_8,""dpx:origination.x_offset"",""%.20g"",
      (double) VAR_6.origination.x_offset);
  VAR_6.origination.y_offset=(ssize_t) ReadBlobLong(VAR_8);
  VAR_10+=4;
  if ((size_t) VAR_6.origination.y_offset != ~0UL)
    (void) FormatImageProperty(VAR_8,""dpx:origination.y_offset"",""%.20g"",
      (double) VAR_6.origination.y_offset);
  VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.origination.filename),(unsigned char *)
    VAR_6.origination.filename);
  (void) CopyMagickString(VAR_4,VAR_6.origination.filename,
    sizeof(VAR_6.origination.filename));
  (void) SetImageProperty(VAR_8,""dpx:origination.filename"",VAR_4,VAR_1);
  VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.origination.create_date),(unsigned char *)
    VAR_6.origination.create_date);
  (void) CopyMagickString(VAR_4,VAR_6.origination.create_date,
    sizeof(VAR_6.origination.create_date));
  (void) SetImageProperty(VAR_8,""dpx:origination.create_date"",VAR_4,
    VAR_1);
  VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.origination.create_time),(unsigned char *)
    VAR_6.origination.create_time);
  (void) CopyMagickString(VAR_4,VAR_6.origination.create_time,
    sizeof(VAR_6.origination.create_time));
  (void) SetImageProperty(VAR_8,""dpx:origination.create_time"",VAR_4,
    VAR_1);
  VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.origination.device),(unsigned char *)
    VAR_6.origination.device);
  (void) CopyMagickString(VAR_4,VAR_6.origination.device,
    sizeof(VAR_6.origination.device));
  (void) SetImageProperty(VAR_8,""dpx:origination.device"",VAR_4,VAR_1);
  VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.origination.model),(unsigned char *)
    VAR_6.origination.model);
  (void) CopyMagickString(VAR_4,VAR_6.origination.model,
    sizeof(VAR_6.origination.model));
  (void) SetImageProperty(VAR_8,""dpx:origination.model"",VAR_4,VAR_1);
  (void) ResetMagickMemory(VAR_6.origination.serial,0, 
    sizeof(VAR_6.origination.serial));
  VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.origination.serial),(unsigned char *)
    VAR_6.origination.serial);
  (void) CopyMagickString(VAR_4,VAR_6.origination.serial,
    sizeof(VAR_6.origination.serial));
  (void) SetImageProperty(VAR_8,""dpx:origination.serial"",VAR_4,VAR_1);
  VAR_6.origination.x_pitch=ReadBlobFloat(VAR_8);
  VAR_10+=4;
  VAR_6.origination.y_pitch=ReadBlobFloat(VAR_8);
  VAR_10+=4;
  VAR_6.origination.gamma=ReadBlobFloat(VAR_8);
  VAR_10+=4;
  if (IsFloatDefined(VAR_6.origination.gamma) != VAR_20)
    VAR_8->gamma=VAR_6.origination.gamma;
  VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.origination.reserve),(unsigned char *)
    VAR_6.origination.reserve);
  if ((VAR_6.file.image_offset > 2048) && (VAR_6.file.user_length != 0))
    {
      int
        VAR_34;

      /* COMMENT_15 */
                               
        
      VAR_6.film.id=ReadBlobByte(VAR_8);
      VAR_10++;
      VAR_34=VAR_6.film.id;
      if (VAR_34 != ~0)
        (void) FormatImageProperty(VAR_8,""dpx:film.id"",""%d"",VAR_6.film.id);
      VAR_6.film.type=ReadBlobByte(VAR_8);
      VAR_10++;
      VAR_34=VAR_6.film.type;
      if (VAR_34 != ~0)
        (void) FormatImageProperty(VAR_8,""dpx:film.type"",""%d"",VAR_6.film.type);
      VAR_6.film.offset=ReadBlobByte(VAR_8);
      VAR_10++;
      VAR_34=VAR_6.film.offset;
      if (VAR_34 != ~0)
        (void) FormatImageProperty(VAR_8,""dpx:film.offset"",""%d"",
          VAR_6.film.offset);
      VAR_6.film.reserve1=ReadBlobByte(VAR_8);
      VAR_10++;
      VAR_6.film.prefix=ReadBlobLong(VAR_8);
      VAR_10+=4;
      if (VAR_6.film.prefix != ~0UL)
        (void) FormatImageProperty(VAR_8,""dpx:film.prefix"",""%.20g"",(double)
          VAR_6.film.prefix);
      VAR_6.film.count=ReadBlobLong(VAR_8);
      VAR_10+=4;
      VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.film.format),(unsigned char *)
        VAR_6.film.format);
      (void) CopyMagickString(VAR_4,VAR_6.film.format,sizeof(VAR_6.film.format));
      (void) SetImageProperty(VAR_8,""dpx:film.format"",VAR_4,VAR_1);
      VAR_6.film.frame_position=ReadBlobLong(VAR_8);
      VAR_10+=4;
      if (VAR_6.film.frame_position != ~0UL)
        (void) FormatImageProperty(VAR_8,""dpx:film.frame_position"",""%.20g"",
          (double) VAR_6.film.frame_position);
      VAR_6.film.frame_rate=ReadBlobFloat(VAR_8);
      VAR_10+=4;
      if (IsFloatDefined(VAR_6.film.frame_rate) != VAR_20)
        (void) FormatImageProperty(VAR_8,""dpx:film.frame_rate"",""%g"",
          VAR_6.film.frame_rate);
      VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.film.frame_id),(unsigned char *)
        VAR_6.film.frame_id);
      (void) CopyMagickString(VAR_4,VAR_6.film.frame_id,
        sizeof(VAR_6.film.frame_id));
      (void) SetImageProperty(VAR_8,""dpx:film.frame_id"",VAR_4,VAR_1);
      VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.film.slate_info),(unsigned char *)
        VAR_6.film.slate_info);
      (void) CopyMagickString(VAR_4,VAR_6.film.slate_info,
        sizeof(VAR_6.film.slate_info));
      (void) SetImageProperty(VAR_8,""dpx:film.slate_info"",VAR_4,VAR_1);
      VAR_10+=ReadBlob(VAR_8,sizeof(VAR_6.film.reserve),(unsigned char *)
        VAR_6.film.reserve);
    }
  if ((VAR_6.file.image_offset > 2048) && (VAR_6.file.user_length != 0))
    {
      StringInfo
        *VAR_35;

      /* COMMENT_18 */
                          
        
      if (VAR_6.file.user_length > GetBlobSize(VAR_8))
        ThrowReaderException(VAR_23,""ImproperImageHeader"");
      VAR_35=BlobToStringInfo((const unsigned char *) NULL,
        VAR_6.file.user_length);
      if (VAR_35 == (StringInfo *) NULL)
        ThrowReaderException(VAR_36,""MemoryAllocationFailed"");
      VAR_10+=ReadBlob(VAR_8,GetStringInfoLength(VAR_35),
        GetStringInfoDatum(VAR_35));
      (void) SetImageProfile(VAR_8,""dpx:user.data"",VAR_35,VAR_1);
      VAR_35=DestroyStringInfo(VAR_35);
    }
  VAR_8->depth=VAR_6.image.channel[0].bits_per_pixel;
  VAR_8->columns=VAR_6.image.channel[0].pixels_per_line;
  VAR_8->rows=VAR_6.image.channel[0].lines_per_image;
  if (VAR_0->ping != VAR_20)
    {
      (void) CloseBlob(VAR_8);
      return(VAR_8);
    }
  for ( ; VAR_10 < (MagickOffsetType) VAR_6.file.image_offset; VAR_10++)
  {
    int
      VAR_34;

    VAR_34=ReadBlobByte(VAR_8);
    if (VAR_34 == VAR_37)
      break;
  }
  if (VAR_10 < (MagickOffsetType) VAR_6.file.image_offset)
    ThrowReaderException(VAR_23,""ImproperImageHeader"");
  VAR_9=SetImageExtent(VAR_8,VAR_8->columns,VAR_8->rows,VAR_1);
  if (VAR_9 == VAR_20)
    return(DestroyImageList(VAR_8));
  /* COMMENT_21 */
                                              
    
  VAR_11=AcquireQuantumInfo(VAR_0,VAR_8);
  if (VAR_11 == (QuantumInfo *) NULL)
    ThrowReaderException(VAR_36,""MemoryAllocationFailed"");
  VAR_11->quantum=32;
  VAR_11->pack=VAR_20;
  VAR_12=VAR_38;
  VAR_15=GetQuantumExtent(VAR_8,VAR_11,VAR_12);
  VAR_15=GetBytesPerRow(VAR_8->columns,3,VAR_8->depth,VAR_39);
  if (VAR_6.image.number_channels == 1)
    {
      VAR_12=VAR_40;
      VAR_15=GetBytesPerRow(VAR_8->columns,1,VAR_8->depth,VAR_39);
    }
  for (VAR_17=0; VAR_17 < (ssize_t) VAR_8->rows; VAR_17++)
  {
    VAR_14=QueueAuthenticPixels(VAR_8,0,VAR_17,VAR_8->columns,1,VAR_1);
    if (VAR_14 == (Quantum *) NULL)
      break;
    VAR_7=(const unsigned char *) ReadBlobStream(VAR_8,VAR_15,
      GetQuantumPixels(VAR_11),&VAR_16);
    if ((size_t) VAR_16 != VAR_15)
      break;
    (void) ImportQuantumPixels(VAR_8,(CacheView *) NULL,VAR_11,
      VAR_12,VAR_7,VAR_1);
    if (SyncAuthenticPixels(VAR_8,VAR_1) == VAR_20)
      break;
    if (VAR_8->previous == (Image *) NULL)
      {
        VAR_9=SetImageProgress(VAR_8,VAR_41,(MagickOffsetType) VAR_17,
          VAR_8->rows);
        if (VAR_9 == VAR_20)
          break;
      }
  }
  SetQuantumImageType(VAR_8,VAR_12);
  VAR_11=DestroyQuantumInfo(VAR_11);
  if (EOFBlob(VAR_8) != VAR_20)
    ThrowFileException(VAR_1,VAR_23,""UnexpectedEndOfFile"",
      VAR_8->filename);
  SetImageColorspace(VAR_8,VAR_42,VAR_1);
  (void) CloseBlob(VAR_8);
  return(GetFirstImageInList(VAR_8));
}",ImageMagick/fa3cf0b45980a4c2ea2345032fe43444dfb05bdb/cin.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -328,7 +328,10 @@
       /*
         User defined data.
       */
-      profile=BlobToStringInfo((const unsigned char *) NULL,cin.file.user_length);
+      if (cin.file.user_length > GetBlobSize(image))
+        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
+      profile=BlobToStringInfo((const unsigned char *) NULL,
+        cin.file.user_length);
       if (profile == (StringInfo *) NULL)
         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
       offset+=ReadBlob(image,GetStringInfoLength(profile),","{'deleted_lines': ['      profile=BlobToStringInfo((const unsigned char *) NULL,cin.file.user_length);'], 'added_lines': ['      if (cin.file.user_length > GetBlobSize(image))', '        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");', '      profile=BlobToStringInfo((const unsigned char *) NULL,', '        cin.file.user_length);']}",True,The ReadCINImage function in coders/cin.c in ImageMagick before 6.9.9-0 and 7.x before 7.0.6-1 allows remote attackers to cause a denial of service (memory consumption) via a crafted file.,6.5,MEDIUM,1,test,2017-06-23T13:29:58Z,1
CVE-2017-11525,['CWE-770'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/519,fa3cf0b45980a4c2ea2345032fe43444dfb05bdb,https://github.com/ImageMagick/ImageMagick/commit/fa3cf0b45980a4c2ea2345032fe43444dfb05bdb,coders/rle.c,RegisterRLEImage,"ModuleExport size_t RegisterRLEImage(void)
{
MagickInfo
*entry;
entry=AcquireMagickInfo(""RLE"",""RLE"",""Utah Run length encoded image"");
entry->decoder=(DecodeImageHandler *) ReadRLEImage;
entry->magick=(IsImageFormatHandler *) IsRLE;
entry->flags^=CoderBlobSupportFlag;
entry->flags^=CoderAdjoinFlag;
(void) RegisterMagickInfo(entry);
return(MagickImageCoderSignature);
}","ModuleExport VAR_0 RegisterRLEImage(void)
{
MagickInfo
*VAR_1;
VAR_1=AcquireMagickInfo(""RLE"",""RLE"",""Utah Run length encoded image"");
VAR_1->decoder=(DecodeImageHandler *) VAR_2;
VAR_1->magick=(IsImageFormatHandler *) VAR_3;
VAR_1->flags^=VAR_4;
VAR_1->flags^=VAR_5;
(void) RegisterMagickInfo(VAR_1);
return(VAR_6);
}",,"ModuleExport size_t RegisterRLEImage(void)
{
  MagickInfo
    *entry;

  entry=AcquireMagickInfo(""RLE"",""RLE"",""Utah Run length encoded image"");
  entry->decoder=(DecodeImageHandler *) ReadRLEImage;
  entry->magick=(IsImageFormatHandler *) IsRLE;
  entry->flags|=CoderDecoderSeekableStreamFlag;
  entry->flags^=CoderAdjoinFlag;
  (void) RegisterMagickInfo(entry);
  return(MagickImageCoderSignature);
}","ModuleExport VAR_0 RegisterRLEImage(void)
{
  MagickInfo
    *VAR_1;

  VAR_1=AcquireMagickInfo(""RLE"",""RLE"",""Utah Run length encoded image"");
  VAR_1->decoder=(DecodeImageHandler *) VAR_2;
  VAR_1->magick=(IsImageFormatHandler *) VAR_3;
  VAR_1->flags|=VAR_4;
  VAR_1->flags^=VAR_5;
  (void) RegisterMagickInfo(VAR_1);
  return(VAR_6);
}",,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
   entry=AcquireMagickInfo(""RLE"",""RLE"",""Utah Run length encoded image"");
   entry->decoder=(DecodeImageHandler *) ReadRLEImage;
   entry->magick=(IsImageFormatHandler *) IsRLE;
-  entry->flags^=CoderBlobSupportFlag;
+  entry->flags|=CoderDecoderSeekableStreamFlag;
   entry->flags^=CoderAdjoinFlag;
   (void) RegisterMagickInfo(entry);
   return(MagickImageCoderSignature);","{'deleted_lines': ['  entry->flags^=CoderBlobSupportFlag;'], 'added_lines': ['  entry->flags|=CoderDecoderSeekableStreamFlag;']}",True,The ReadCINImage function in coders/cin.c in ImageMagick before 6.9.9-0 and 7.x before 7.0.6-1 allows remote attackers to cause a denial of service (memory consumption) via a crafted file.,6.5,MEDIUM,1,test,2017-06-23T13:29:58Z,1
CVE-2017-11525,['CWE-770'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/519,fa3cf0b45980a4c2ea2345032fe43444dfb05bdb,https://github.com/ImageMagick/ImageMagick/commit/fa3cf0b45980a4c2ea2345032fe43444dfb05bdb,coders/cin.c,RegisterCINImage,"ModuleExport size_t RegisterCINImage(void)
{
MagickInfo
*entry;
entry=AcquireMagickInfo(""CIN"",""CIN"",""Cineon Image File"");
entry->decoder=(DecodeImageHandler *) ReadCINImage;
entry->encoder=(EncodeImageHandler *) WriteCINImage;
entry->magick=(IsImageFormatHandler *) IsCIN;
entry->flags^=CoderAdjoinFlag;
(void) RegisterMagickInfo(entry);
return(MagickImageCoderSignature);
}","ModuleExport VAR_0 RegisterCINImage(void)
{
MagickInfo
*VAR_1;
VAR_1=AcquireMagickInfo(""CIN"",""CIN"",""Cineon Image File"");
VAR_1->decoder=(DecodeImageHandler *) VAR_2;
VAR_1->encoder=(EncodeImageHandler *) VAR_3;
VAR_1->magick=(IsImageFormatHandler *) VAR_4;
VAR_1->flags^=VAR_5;
(void) RegisterMagickInfo(VAR_1);
return(VAR_6);
}",,"ModuleExport size_t RegisterCINImage(void)
{
  MagickInfo
    *entry;

  entry=AcquireMagickInfo(""CIN"",""CIN"",""Cineon Image File"");
  entry->decoder=(DecodeImageHandler *) ReadCINImage;
  entry->encoder=(EncodeImageHandler *) WriteCINImage;
  entry->magick=(IsImageFormatHandler *) IsCIN;
  entry->flags|=CoderDecoderSeekableStreamFlag
  entry->flags^=CoderAdjoinFlag;
  (void) RegisterMagickInfo(entry);
  return(MagickImageCoderSignature);
}","ModuleExport VAR_0 RegisterCINImage(void)
{
  MagickInfo
    *VAR_1;

  VAR_1=AcquireMagickInfo(""CIN"",""CIN"",""Cineon Image File"");
  VAR_1->decoder=(DecodeImageHandler *) VAR_2;
  VAR_1->encoder=(EncodeImageHandler *) VAR_3;
  VAR_1->magick=(IsImageFormatHandler *) VAR_4;
  VAR_1->flags|=VAR_5
  VAR_1->flags^=VAR_6;
  (void) RegisterMagickInfo(VAR_1);
  return(VAR_7);
}",,"--- func_before
+++ func_after
@@ -7,6 +7,7 @@
   entry->decoder=(DecodeImageHandler *) ReadCINImage;
   entry->encoder=(EncodeImageHandler *) WriteCINImage;
   entry->magick=(IsImageFormatHandler *) IsCIN;
+  entry->flags|=CoderDecoderSeekableStreamFlag
   entry->flags^=CoderAdjoinFlag;
   (void) RegisterMagickInfo(entry);
   return(MagickImageCoderSignature);","{'deleted_lines': [], 'added_lines': ['  entry->flags|=CoderDecoderSeekableStreamFlag']}",True,The ReadCINImage function in coders/cin.c in ImageMagick before 6.9.9-0 and 7.x before 7.0.6-1 allows remote attackers to cause a denial of service (memory consumption) via a crafted file.,6.5,MEDIUM,1,test,2017-06-23T13:29:58Z,1
CVE-2017-14032,['CWE-287'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,Mbed-TLS/mbedtls,"Only return VERIFY_FAILED from a single point

Everything else is a fatal error. Also improve documentation about that for
the vrfy callback.",31458a18788b0cf0b722acda9bb2f2fe13a3fb32,https://github.com/Mbed-TLS/mbedtls/commit/31458a18788b0cf0b722acda9bb2f2fe13a3fb32,library/x509_crt.c,mbedtls_x509_crt_verify_with_profile,"int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,
mbedtls_x509_crt *trust_ca,
mbedtls_x509_crl *ca_crl,
const mbedtls_x509_crt_profile *profile,
const char *cn, uint32_t *flags,
int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
void *p_vrfy )
{
size_t cn_len;
int ret;
int pathlen = 0, selfsigned = 0;
mbedtls_x509_crt *parent;
mbedtls_x509_name *name;
mbedtls_x509_sequence *cur = NULL;
mbedtls_pk_type_t pk_type;
*flags = 0;
if( profile == NULL )
{
ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;
goto exit;
}
if( cn != NULL )
{
name = &crt->subject;
cn_len = strlen( cn );
if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )
{
cur = &crt->subject_alt_names;
while( cur != NULL )
{
if( cur->buf.len == cn_len &&
x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )
break;
if( cur->buf.len > 2 &&
memcmp( cur->buf.p, ""*."", 2 ) == 0 &&
x509_check_wildcard( cn, &cur->buf ) == 0 )
{
break;
}
cur = cur->next;
}
if( cur == NULL )
*flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
}
else
{
while( name != NULL )
{
if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )
{
if( name->val.len == cn_len &&
x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )
break;
if( name->val.len > 2 &&
memcmp( name->val.p, ""*."", 2 ) == 0 &&
x509_check_wildcard( cn, &name->val ) == 0 )
break;
}
name = name->next;
}
if( name == NULL )
*flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
}
}
pk_type = mbedtls_pk_get_type( &crt->pk );
if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )
*flags |= MBEDTLS_X509_BADCERT_BAD_PK;
if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )
*flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
for( parent = trust_ca; parent != NULL; parent = parent->next )
{
if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
break;
}
if( parent != NULL )
{
ret = x509_crt_verify_top( crt, parent, ca_crl, profile,
pathlen, selfsigned, flags, f_vrfy, p_vrfy );
if( ret != 0 )
goto exit;
}
else
{
for( parent = crt->next; parent != NULL; parent = parent->next )
if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
break;
if( parent != NULL )
{
ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,
pathlen, selfsigned, flags, f_vrfy, p_vrfy );
if( ret != 0 )
goto exit;
}
else
{
ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,
pathlen, selfsigned, flags, f_vrfy, p_vrfy );
if( ret != 0 )
goto exit;
}
}
exit:
if( ret != 0 )
{
*flags = (uint32_t) -1;
return( ret );
}
if( *flags != 0 )
return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );
return( 0 );
}","int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *VAR_0,
mbedtls_x509_crt *VAR_1,
mbedtls_x509_crl *VAR_2,
const mbedtls_x509_crt_profile *VAR_3,
const char *VAR_4, uint32_t *VAR_5,
int (*VAR_6)(void *, mbedtls_x509_crt *, int, uint32_t *),
void *VAR_7 )
{
size_t VAR_8;
int VAR_9;
int VAR_10 = 0, VAR_11 = 0;
mbedtls_x509_crt *VAR_12;
mbedtls_x509_name *VAR_13;
mbedtls_x509_sequence *VAR_14 = NULL;
mbedtls_pk_type_t VAR_15;
*VAR_5 = 0;
if( VAR_3 == NULL )
{
VAR_9 = VAR_16;
goto exit;
}
if( VAR_4 != NULL )
{
VAR_13 = &VAR_0->subject;
VAR_8 = strlen( VAR_4 );
if( VAR_0->ext_types & VAR_17 )
{
VAR_14 = &VAR_0->subject_alt_names;
while( VAR_14 != NULL )
{
if( VAR_14->buf.len == VAR_8 &&
x509_memcasecmp( VAR_4, VAR_14->buf.p, VAR_8 ) == 0 )
break;
if( VAR_14->buf.len > 2 &&
memcmp( VAR_14->buf.p, ""*."", 2 ) == 0 &&
x509_check_wildcard( VAR_4, &VAR_14->buf ) == 0 )
{
break;
}
VAR_14 = VAR_14->next;
}
if( VAR_14 == NULL )
*VAR_5 |= VAR_18;
}
else
{
while( VAR_13 != NULL )
{
if( MBEDTLS_OID_CMP( VAR_19, &VAR_13->oid ) == 0 )
{
if( VAR_13->val.len == VAR_8 &&
x509_memcasecmp( VAR_13->val.p, VAR_4, VAR_8 ) == 0 )
break;
if( VAR_13->val.len > 2 &&
memcmp( VAR_13->val.p, ""*."", 2 ) == 0 &&
x509_check_wildcard( VAR_4, &VAR_13->val ) == 0 )
break;
}
VAR_13 = VAR_13->next;
}
if( VAR_13 == NULL )
*VAR_5 |= VAR_18;
}
}
VAR_15 = mbedtls_pk_get_type( &VAR_0->pk );
if( x509_profile_check_pk_alg( VAR_3, VAR_15 ) != 0 )
*VAR_5 |= VAR_20;
if( x509_profile_check_key( VAR_3, VAR_15, &VAR_0->pk ) != 0 )
*VAR_5 |= VAR_21;
for( VAR_12 = VAR_1; VAR_12 != NULL; VAR_12 = VAR_12->next )
{
if( x509_crt_check_parent( VAR_0, VAR_12, 0, VAR_10 == 0 ) == 0 )
break;
}
if( VAR_12 != NULL )
{
VAR_9 = x509_crt_verify_top( VAR_0, VAR_12, VAR_2, VAR_3,
VAR_10, VAR_11, VAR_5, VAR_6, VAR_7 );
if( VAR_9 != 0 )
goto exit;
}
else
{
for( VAR_12 = VAR_0->next; VAR_12 != NULL; VAR_12 = VAR_12->next )
if( x509_crt_check_parent( VAR_0, VAR_12, 0, VAR_10 == 0 ) == 0 )
break;
if( VAR_12 != NULL )
{
VAR_9 = x509_crt_verify_child( VAR_0, VAR_12, VAR_1, VAR_2, VAR_3,
VAR_10, VAR_11, VAR_5, VAR_6, VAR_7 );
if( VAR_9 != 0 )
goto exit;
}
else
{
VAR_9 = x509_crt_verify_top( VAR_0, VAR_1, VAR_2, VAR_3,
VAR_10, VAR_11, VAR_5, VAR_6, VAR_7 );
if( VAR_9 != 0 )
goto exit;
}
}
exit:
if( VAR_9 != 0 )
{
*VAR_5 = (uint32_t) -1;
return( VAR_9 );
}
if( *VAR_5 != 0 )
return( VAR_22 );
return( 0 );
}",Mbed-TLS/mbedtls/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/x509_crt.c/vul/before/1.json,"int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,
                     mbedtls_x509_crt *trust_ca,
                     mbedtls_x509_crl *ca_crl,
                     const mbedtls_x509_crt_profile *profile,
                     const char *cn, uint32_t *flags,
                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
                     void *p_vrfy )
{
    size_t cn_len;
    int ret;
    int pathlen = 0, selfsigned = 0;
    mbedtls_x509_crt *parent;
    mbedtls_x509_name *name;
    mbedtls_x509_sequence *cur = NULL;
    mbedtls_pk_type_t pk_type;

    *flags = 0;

    if( profile == NULL )
    {
        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;
        goto exit;
    }

    if( cn != NULL )
    {
        name = &crt->subject;
        cn_len = strlen( cn );

        if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )
        {
            cur = &crt->subject_alt_names;

            while( cur != NULL )
            {
                if( cur->buf.len == cn_len &&
                    x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )
                    break;

                if( cur->buf.len > 2 &&
                    memcmp( cur->buf.p, ""*."", 2 ) == 0 &&
                    x509_check_wildcard( cn, &cur->buf ) == 0 )
                {
                    break;
                }

                cur = cur->next;
            }

            if( cur == NULL )
                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
        }
        else
        {
            while( name != NULL )
            {
                if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )
                {
                    if( name->val.len == cn_len &&
                        x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )
                        break;

                    if( name->val.len > 2 &&
                        memcmp( name->val.p, ""*."", 2 ) == 0 &&
                        x509_check_wildcard( cn, &name->val ) == 0 )
                        break;
                }

                name = name->next;
            }

            if( name == NULL )
                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
        }
    }

    /* Check the type and size of the key */
    pk_type = mbedtls_pk_get_type( &crt->pk );

    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;

    if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;

    /* Look for a parent in trusted CAs */
    for( parent = trust_ca; parent != NULL; parent = parent->next )
    {
        if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
            break;
    }

    if( parent != NULL )
    {
        ret = x509_crt_verify_top( crt, parent, ca_crl, profile,
                                   pathlen, selfsigned, flags, f_vrfy, p_vrfy );
        if( ret != 0 )
            goto exit;
    }
    else
    {
        /* Look for a parent upwards the chain */
        for( parent = crt->next; parent != NULL; parent = parent->next )
            if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
                break;

        /* Are we part of the chain or at the top? */
        if( parent != NULL )
        {
            ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,
                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );
            if( ret != 0 )
                goto exit;
        }
        else
        {
            ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,
                                       pathlen, selfsigned, flags, f_vrfy, p_vrfy );
            if( ret != 0 )
                goto exit;
        }
    }

exit:
    /* prevent misuse of the vrfy callback */
    if( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED )
        ret = MBEDTLS_ERR_X509_FATAL_ERROR;

    if( ret != 0 )
    {
        *flags = (uint32_t) -1;
        return( ret );
    }

    if( *flags != 0 )
        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );

    return( 0 );
}","int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *VAR_0,
                     mbedtls_x509_crt *VAR_1,
                     mbedtls_x509_crl *VAR_2,
                     const mbedtls_x509_crt_profile *VAR_3,
                     const char *VAR_4, uint32_t *VAR_5,
                     int (*VAR_6)(void *, mbedtls_x509_crt *, int, uint32_t *),
                     void *VAR_7 )
{
    size_t VAR_8;
    int VAR_9;
    int VAR_10 = 0, VAR_11 = 0;
    mbedtls_x509_crt *VAR_12;
    mbedtls_x509_name *VAR_13;
    mbedtls_x509_sequence *VAR_14 = NULL;
    mbedtls_pk_type_t VAR_15;

    *VAR_5 = 0;

    if( VAR_3 == NULL )
    {
        VAR_9 = VAR_16;
        goto exit;
    }

    if( VAR_4 != NULL )
    {
        VAR_13 = &VAR_0->subject;
        VAR_8 = strlen( VAR_4 );

        if( VAR_0->ext_types & VAR_17 )
        {
            VAR_14 = &VAR_0->subject_alt_names;

            while( VAR_14 != NULL )
            {
                if( VAR_14->buf.len == VAR_8 &&
                    x509_memcasecmp( VAR_4, VAR_14->buf.p, VAR_8 ) == 0 )
                    break;

                if( VAR_14->buf.len > 2 &&
                    memcmp( VAR_14->buf.p, ""*."", 2 ) == 0 &&
                    x509_check_wildcard( VAR_4, &VAR_14->buf ) == 0 )
                {
                    break;
                }

                VAR_14 = VAR_14->next;
            }

            if( VAR_14 == NULL )
                *VAR_5 |= VAR_18;
        }
        else
        {
            while( VAR_13 != NULL )
            {
                if( MBEDTLS_OID_CMP( VAR_19, &VAR_13->oid ) == 0 )
                {
                    if( VAR_13->val.len == VAR_8 &&
                        x509_memcasecmp( VAR_13->val.p, VAR_4, VAR_8 ) == 0 )
                        break;

                    if( VAR_13->val.len > 2 &&
                        memcmp( VAR_13->val.p, ""*."", 2 ) == 0 &&
                        x509_check_wildcard( VAR_4, &VAR_13->val ) == 0 )
                        break;
                }

                VAR_13 = VAR_13->next;
            }

            if( VAR_13 == NULL )
                *VAR_5 |= VAR_18;
        }
    }

    /* COMMENT_0 */
    VAR_15 = mbedtls_pk_get_type( &VAR_0->pk );

    if( x509_profile_check_pk_alg( VAR_3, VAR_15 ) != 0 )
        *VAR_5 |= VAR_20;

    if( x509_profile_check_key( VAR_3, VAR_15, &VAR_0->pk ) != 0 )
        *VAR_5 |= VAR_21;

    /* COMMENT_1 */
    for( VAR_12 = VAR_1; VAR_12 != NULL; VAR_12 = VAR_12->next )
    {
        if( x509_crt_check_parent( VAR_0, VAR_12, 0, VAR_10 == 0 ) == 0 )
            break;
    }

    if( VAR_12 != NULL )
    {
        VAR_9 = x509_crt_verify_top( VAR_0, VAR_12, VAR_2, VAR_3,
                                   VAR_10, VAR_11, VAR_5, VAR_6, VAR_7 );
        if( VAR_9 != 0 )
            goto exit;
    }
    else
    {
        /* COMMENT_2 */
        for( VAR_12 = VAR_0->next; VAR_12 != NULL; VAR_12 = VAR_12->next )
            if( x509_crt_check_parent( VAR_0, VAR_12, 0, VAR_10 == 0 ) == 0 )
                break;

        /* COMMENT_3 */
        if( VAR_12 != NULL )
        {
            VAR_9 = x509_crt_verify_child( VAR_0, VAR_12, VAR_1, VAR_2, VAR_3,
                                         VAR_10, VAR_11, VAR_5, VAR_6, VAR_7 );
            if( VAR_9 != 0 )
                goto exit;
        }
        else
        {
            VAR_9 = x509_crt_verify_top( VAR_0, VAR_1, VAR_2, VAR_3,
                                       VAR_10, VAR_11, VAR_5, VAR_6, VAR_7 );
            if( VAR_9 != 0 )
                goto exit;
        }
    }

exit:
    /* COMMENT_4 */
    if( VAR_9 == VAR_22 )
        VAR_9 = VAR_23;

    if( VAR_9 != 0 )
    {
        *VAR_5 = (uint32_t) -1;
        return( VAR_9 );
    }

    if( *VAR_5 != 0 )
        return( VAR_22 );

    return( 0 );
}",Mbed-TLS/mbedtls/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/x509_crt.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -122,6 +122,10 @@
     }
 
 exit:
+    /* prevent misuse of the vrfy callback */
+    if( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED )
+        ret = MBEDTLS_ERR_X509_FATAL_ERROR;
+
     if( ret != 0 )
     {
         *flags = (uint32_t) -1;","{'deleted_lines': [], 'added_lines': ['    /* prevent misuse of the vrfy callback */', '    if( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED )', '        ret = MBEDTLS_ERR_X509_FATAL_ERROR;', '']}",True,"ARM mbed TLS before 1.3.21 and 2.x before 2.1.9, if optional authentication is configured, allows remote attackers to bypass peer authentication via an X.509 certificate chain with many intermediates. NOTE: although mbed TLS was formerly known as PolarSSL, the releases shipped with the PolarSSL name are not affected.",8.1,HIGH,2,test,2017-06-26T08:11:49Z,1
CVE-2017-14032,['CWE-287'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,Mbed-TLS/mbedtls,"Only return VERIFY_FAILED from a single point

Everything else is a fatal error. Also improve documentation about that for
the vrfy callback.",31458a18788b0cf0b722acda9bb2f2fe13a3fb32,https://github.com/Mbed-TLS/mbedtls/commit/31458a18788b0cf0b722acda9bb2f2fe13a3fb32,library/x509_crt.c,x509_crt_verify_child,"static int x509_crt_verify_child(
mbedtls_x509_crt *child, mbedtls_x509_crt *parent,
mbedtls_x509_crt *trust_ca, mbedtls_x509_crl *ca_crl,
const mbedtls_x509_crt_profile *profile,
int path_cnt, int self_cnt, uint32_t *flags,
int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
void *p_vrfy )
{
int ret;
uint32_t parent_flags = 0;
unsigned char hash[MBEDTLS_MD_MAX_SIZE];
mbedtls_x509_crt *grandparent;
const mbedtls_md_info_t *md_info;
if( ( path_cnt != 0 ) && x509_name_cmp( &child->issuer, &child->subject ) == 0 )
self_cnt++;
if( 1 + path_cnt > MBEDTLS_X509_MAX_INTERMEDIATE_CA )
{
*flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );
}
if( mbedtls_x509_time_is_past( &child->valid_to ) )
*flags |= MBEDTLS_X509_BADCERT_EXPIRED;
if( mbedtls_x509_time_is_future( &child->valid_from ) )
*flags |= MBEDTLS_X509_BADCERT_FUTURE;
if( x509_profile_check_md_alg( profile, child->sig_md ) != 0 )
*flags |= MBEDTLS_X509_BADCERT_BAD_MD;
if( x509_profile_check_pk_alg( profile, child->sig_pk ) != 0 )
*flags |= MBEDTLS_X509_BADCERT_BAD_PK;
md_info = mbedtls_md_info_from_type( child->sig_md );
if( md_info == NULL )
{
*flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
}
else
{
mbedtls_md( md_info, child->tbs.p, child->tbs.len, hash );
if( x509_profile_check_key( profile, child->sig_pk, &parent->pk ) != 0 )
*flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
if( mbedtls_pk_verify_ext( child->sig_pk, child->sig_opts, &parent->pk,
child->sig_md, hash, mbedtls_md_get_size( md_info ),
child->sig.p, child->sig.len ) != 0 )
{
*flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
}
}
#if defined(MBEDTLS_X509_CRL_PARSE_C)
*flags |= x509_crt_verifycrl(child, parent, ca_crl, profile );
#endif
for( grandparent = trust_ca;
grandparent != NULL;
grandparent = grandparent->next )
{
if( x509_crt_check_parent( parent, grandparent,
0, path_cnt == 0 ) == 0 )
break;
}
if( grandparent != NULL )
{
ret = x509_crt_verify_top( parent, grandparent, ca_crl, profile,
path_cnt + 1, self_cnt, &parent_flags, f_vrfy, p_vrfy );
if( ret != 0 )
return( ret );
}
else
{
for( grandparent = parent->next;
grandparent != NULL;
grandparent = grandparent->next )
{
if( grandparent->max_pathlen > 0 &&
grandparent->max_pathlen < 2 + path_cnt - self_cnt )
{
continue;
}
if( x509_crt_check_parent( parent, grandparent,
0, path_cnt == 0 ) == 0 )
break;
}
if( grandparent != NULL )
{
ret = x509_crt_verify_child( parent, grandparent, trust_ca, ca_crl,
profile, path_cnt + 1, self_cnt, &parent_flags,
f_vrfy, p_vrfy );
if( ret != 0 )
return( ret );
}
else
{
ret = x509_crt_verify_top( parent, trust_ca, ca_crl, profile,
path_cnt + 1, self_cnt, &parent_flags,
f_vrfy, p_vrfy );
if( ret != 0 )
return( ret );
}
}
if( NULL != f_vrfy )
if( ( ret = f_vrfy( p_vrfy, child, path_cnt, flags ) ) != 0 )
return( ret );
*flags |= parent_flags;
return( 0 );
}","static int x509_crt_verify_child(
mbedtls_x509_crt *VAR_0, mbedtls_x509_crt *VAR_1,
mbedtls_x509_crt *VAR_2, mbedtls_x509_crl *VAR_3,
const mbedtls_x509_crt_profile *VAR_4,
int VAR_5, int VAR_6, uint32_t *VAR_7,
int (*VAR_8)(void *, mbedtls_x509_crt *, int, uint32_t *),
void *VAR_9 )
{
int VAR_10;
uint32_t VAR_11 = 0;
unsigned char VAR_12[VAR_13];
mbedtls_x509_crt *VAR_14;
const mbedtls_md_info_t *VAR_15;
if( ( VAR_5 != 0 ) && x509_name_cmp( &VAR_0->issuer, &VAR_0->subject ) == 0 )
VAR_6++;
if( 1 + VAR_5 > VAR_16 )
{
*VAR_7 |= VAR_17;
return( VAR_18 );
}
if( mbedtls_x509_time_is_past( &VAR_0->valid_to ) )
*VAR_7 |= VAR_19;
if( mbedtls_x509_time_is_future( &VAR_0->valid_from ) )
*VAR_7 |= VAR_20;
if( x509_profile_check_md_alg( VAR_4, VAR_0->sig_md ) != 0 )
*VAR_7 |= VAR_21;
if( x509_profile_check_pk_alg( VAR_4, VAR_0->sig_pk ) != 0 )
*VAR_7 |= VAR_22;
VAR_15 = mbedtls_md_info_from_type( VAR_0->sig_md );
if( VAR_15 == NULL )
{
*VAR_7 |= VAR_17;
}
else
{
mbedtls_md( VAR_15, VAR_0->tbs.p, VAR_0->tbs.len, VAR_12 );
if( x509_profile_check_key( VAR_4, VAR_0->sig_pk, &VAR_1->pk ) != 0 )
*VAR_7 |= VAR_23;
if( mbedtls_pk_verify_ext( VAR_0->sig_pk, VAR_0->sig_opts, &VAR_1->pk,
VAR_0->sig_md, VAR_12, mbedtls_md_get_size( VAR_15 ),
VAR_0->sig.p, VAR_0->sig.len ) != 0 )
{
*VAR_7 |= VAR_17;
}
}
#if defined(VAR_24)
*VAR_7 |= x509_crt_verifycrl(VAR_0, VAR_1, VAR_3, VAR_4 );
#endif
for( VAR_14 = VAR_2;
VAR_14 != NULL;
VAR_14 = VAR_14->next )
{
if( x509_crt_check_parent( VAR_1, VAR_14,
0, VAR_5 == 0 ) == 0 )
break;
}
if( VAR_14 != NULL )
{
VAR_10 = x509_crt_verify_top( VAR_1, VAR_14, VAR_3, VAR_4,
VAR_5 + 1, VAR_6, &VAR_11, VAR_8, VAR_9 );
if( VAR_10 != 0 )
return( VAR_10 );
}
else
{
for( VAR_14 = VAR_1->next;
VAR_14 != NULL;
VAR_14 = VAR_14->next )
{
if( VAR_14->max_pathlen > 0 &&
VAR_14->max_pathlen < 2 + VAR_5 - VAR_6 )
{
continue;
}
if( x509_crt_check_parent( VAR_1, VAR_14,
0, VAR_5 == 0 ) == 0 )
break;
}
if( VAR_14 != NULL )
{
VAR_10 = x509_crt_verify_child( VAR_1, VAR_14, VAR_2, VAR_3,
VAR_4, VAR_5 + 1, VAR_6, &VAR_11,
VAR_8, VAR_9 );
if( VAR_10 != 0 )
return( VAR_10 );
}
else
{
VAR_10 = x509_crt_verify_top( VAR_1, VAR_2, VAR_3, VAR_4,
VAR_5 + 1, VAR_6, &VAR_11,
VAR_8, VAR_9 );
if( VAR_10 != 0 )
return( VAR_10 );
}
}
if( NULL != VAR_8 )
if( ( VAR_10 = VAR_8( VAR_9, VAR_0, VAR_5, VAR_7 ) ) != 0 )
return( VAR_10 );
*VAR_7 |= VAR_11;
return( 0 );
}",Mbed-TLS/mbedtls/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/x509_crt.c/vul/before/0.json,"static int x509_crt_verify_child(
                mbedtls_x509_crt *child, mbedtls_x509_crt *parent,
                mbedtls_x509_crt *trust_ca, mbedtls_x509_crl *ca_crl,
                const mbedtls_x509_crt_profile *profile,
                int path_cnt, int self_cnt, uint32_t *flags,
                int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
                void *p_vrfy )
{
    int ret;
    uint32_t parent_flags = 0;
    unsigned char hash[MBEDTLS_MD_MAX_SIZE];
    mbedtls_x509_crt *grandparent;
    const mbedtls_md_info_t *md_info;

    /* Counting intermediate self signed certificates */
    if( ( path_cnt != 0 ) && x509_name_cmp( &child->issuer, &child->subject ) == 0 )
        self_cnt++;

    /* path_cnt is 0 for the first intermediate CA */
    if( 1 + path_cnt > MBEDTLS_X509_MAX_INTERMEDIATE_CA )
    {
        /* return immediately as the goal is to avoid unbounded recursion */
        return( MBEDTLS_ERR_X509_FATAL_ERROR );
    }

    if( mbedtls_x509_time_is_past( &child->valid_to ) )
        *flags |= MBEDTLS_X509_BADCERT_EXPIRED;

    if( mbedtls_x509_time_is_future( &child->valid_from ) )
        *flags |= MBEDTLS_X509_BADCERT_FUTURE;

    if( x509_profile_check_md_alg( profile, child->sig_md ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_MD;

    if( x509_profile_check_pk_alg( profile, child->sig_pk ) != 0 )
        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;

    md_info = mbedtls_md_info_from_type( child->sig_md );
    if( md_info == NULL )
    {
        /*
         * Cannot check 'unknown' hash
         */
        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
    }
    else
    {
        mbedtls_md( md_info, child->tbs.p, child->tbs.len, hash );

        if( x509_profile_check_key( profile, child->sig_pk, &parent->pk ) != 0 )
            *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;

        if( mbedtls_pk_verify_ext( child->sig_pk, child->sig_opts, &parent->pk,
                           child->sig_md, hash, mbedtls_md_get_size( md_info ),
                           child->sig.p, child->sig.len ) != 0 )
        {
            *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
        }
    }

#if defined(MBEDTLS_X509_CRL_PARSE_C)
    /* Check trusted CA's CRL for the given crt */
    *flags |= x509_crt_verifycrl(child, parent, ca_crl, profile );
#endif

    /* Look for a grandparent in trusted CAs */
    for( grandparent = trust_ca;
         grandparent != NULL;
         grandparent = grandparent->next )
    {
        if( x509_crt_check_parent( parent, grandparent,
                                   0, path_cnt == 0 ) == 0 )
            break;
    }

    if( grandparent != NULL )
    {
        ret = x509_crt_verify_top( parent, grandparent, ca_crl, profile,
                                path_cnt + 1, self_cnt, &parent_flags, f_vrfy, p_vrfy );
        if( ret != 0 )
            return( ret );
    }
    else
    {
        /* Look for a grandparent upwards the chain */
        for( grandparent = parent->next;
             grandparent != NULL;
             grandparent = grandparent->next )
        {
            /* +2 because the current step is not yet accounted for
             * and because max_pathlen is one higher than it should be.
             * Also self signed certificates do not count to the limit. */
            if( grandparent->max_pathlen > 0 &&
                grandparent->max_pathlen < 2 + path_cnt - self_cnt )
            {
                continue;
            }

            if( x509_crt_check_parent( parent, grandparent,
                                       0, path_cnt == 0 ) == 0 )
                break;
        }

        /* Is our parent part of the chain or at the top? */
        if( grandparent != NULL )
        {
            ret = x509_crt_verify_child( parent, grandparent, trust_ca, ca_crl,
                                         profile, path_cnt + 1, self_cnt, &parent_flags,
                                         f_vrfy, p_vrfy );
            if( ret != 0 )
                return( ret );
        }
        else
        {
            ret = x509_crt_verify_top( parent, trust_ca, ca_crl, profile,
                                       path_cnt + 1, self_cnt, &parent_flags,
                                       f_vrfy, p_vrfy );
            if( ret != 0 )
                return( ret );
        }
    }

    /* child is verified to be a child of the parent, call verify callback */
    if( NULL != f_vrfy )
        if( ( ret = f_vrfy( p_vrfy, child, path_cnt, flags ) ) != 0 )
            return( ret );

    *flags |= parent_flags;

    return( 0 );
}","static int x509_crt_verify_child(
                mbedtls_x509_crt *VAR_0, mbedtls_x509_crt *VAR_1,
                mbedtls_x509_crt *VAR_2, mbedtls_x509_crl *VAR_3,
                const mbedtls_x509_crt_profile *VAR_4,
                int VAR_5, int VAR_6, uint32_t *VAR_7,
                int (*VAR_8)(void *, mbedtls_x509_crt *, int, uint32_t *),
                void *VAR_9 )
{
    int VAR_10;
    uint32_t VAR_11 = 0;
    unsigned char VAR_12[VAR_13];
    mbedtls_x509_crt *VAR_14;
    const mbedtls_md_info_t *VAR_15;

    /* COMMENT_0 */
    if( ( VAR_5 != 0 ) && x509_name_cmp( &VAR_0->issuer, &VAR_0->subject ) == 0 )
        VAR_6++;

    /* COMMENT_1 */
    if( 1 + VAR_5 > VAR_16 )
    {
        /* COMMENT_2 */
        return( VAR_17 );
    }

    if( mbedtls_x509_time_is_past( &VAR_0->valid_to ) )
        *VAR_7 |= VAR_18;

    if( mbedtls_x509_time_is_future( &VAR_0->valid_from ) )
        *VAR_7 |= VAR_19;

    if( x509_profile_check_md_alg( VAR_4, VAR_0->sig_md ) != 0 )
        *VAR_7 |= VAR_20;

    if( x509_profile_check_pk_alg( VAR_4, VAR_0->sig_pk ) != 0 )
        *VAR_7 |= VAR_21;

    VAR_15 = mbedtls_md_info_from_type( VAR_0->sig_md );
    if( VAR_15 == NULL )
    {
        /* COMMENT_3 */
                                      
           
        *VAR_7 |= VAR_22;
    }
    else
    {
        mbedtls_md( VAR_15, VAR_0->tbs.p, VAR_0->tbs.len, VAR_12 );

        if( x509_profile_check_key( VAR_4, VAR_0->sig_pk, &VAR_1->pk ) != 0 )
            *VAR_7 |= VAR_23;

        if( mbedtls_pk_verify_ext( VAR_0->sig_pk, VAR_0->sig_opts, &VAR_1->pk,
                           VAR_0->sig_md, VAR_12, mbedtls_md_get_size( VAR_15 ),
                           VAR_0->sig.p, VAR_0->sig.len ) != 0 )
        {
            *VAR_7 |= VAR_22;
        }
    }

#if defined(VAR_24)
    /* COMMENT_6 */
    *VAR_7 |= x509_crt_verifycrl(VAR_0, VAR_1, VAR_3, VAR_4 );
#endif

    /* COMMENT_7 */
    for( VAR_14 = VAR_2;
         VAR_14 != NULL;
         VAR_14 = VAR_14->next )
    {
        if( x509_crt_check_parent( VAR_1, VAR_14,
                                   0, VAR_5 == 0 ) == 0 )
            break;
    }

    if( VAR_14 != NULL )
    {
        VAR_10 = x509_crt_verify_top( VAR_1, VAR_14, VAR_3, VAR_4,
                                VAR_5 + 1, VAR_6, &VAR_11, VAR_8, VAR_9 );
        if( VAR_10 != 0 )
            return( VAR_10 );
    }
    else
    {
        /* COMMENT_8 */
        for( VAR_14 = VAR_1->next;
             VAR_14 != NULL;
             VAR_14 = VAR_14->next )
        {
            /* COMMENT_9 */
                                                                       
                                                                          
            if( VAR_14->max_pathlen > 0 &&
                VAR_14->max_pathlen < 2 + VAR_5 - VAR_6 )
            {
                continue;
            }

            if( x509_crt_check_parent( VAR_1, VAR_14,
                                       0, VAR_5 == 0 ) == 0 )
                break;
        }

        /* COMMENT_12 */
        if( VAR_14 != NULL )
        {
            VAR_10 = x509_crt_verify_child( VAR_1, VAR_14, VAR_2, VAR_3,
                                         VAR_4, VAR_5 + 1, VAR_6, &VAR_11,
                                         VAR_8, VAR_9 );
            if( VAR_10 != 0 )
                return( VAR_10 );
        }
        else
        {
            VAR_10 = x509_crt_verify_top( VAR_1, VAR_2, VAR_3, VAR_4,
                                       VAR_5 + 1, VAR_6, &VAR_11,
                                       VAR_8, VAR_9 );
            if( VAR_10 != 0 )
                return( VAR_10 );
        }
    }

    /* COMMENT_13 */
    if( NULL != VAR_8 )
        if( ( VAR_10 = VAR_8( VAR_9, VAR_0, VAR_5, VAR_7 ) ) != 0 )
            return( VAR_10 );

    *VAR_7 |= VAR_11;

    return( 0 );
}",Mbed-TLS/mbedtls/31458a18788b0cf0b722acda9bb2f2fe13a3fb32/x509_crt.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -19,8 +19,8 @@
     /* path_cnt is 0 for the first intermediate CA */
     if( 1 + path_cnt > MBEDTLS_X509_MAX_INTERMEDIATE_CA )
     {
-        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
-        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );
+        /* return immediately as the goal is to avoid unbounded recursion */
+        return( MBEDTLS_ERR_X509_FATAL_ERROR );
     }
 
     if( mbedtls_x509_time_is_past( &child->valid_to ) )","{'deleted_lines': ['        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;', '        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );'], 'added_lines': ['        /* return immediately as the goal is to avoid unbounded recursion */', '        return( MBEDTLS_ERR_X509_FATAL_ERROR );']}",True,"ARM mbed TLS before 1.3.21 and 2.x before 2.1.9, if optional authentication is configured, allows remote attackers to bypass peer authentication via an X.509 certificate chain with many intermediates. NOTE: although mbed TLS was formerly known as PolarSSL, the releases shipped with the PolarSSL name are not affected.",8.1,HIGH,2,test,2017-06-26T08:11:49Z,1
CVE-2017-11464,['CWE-369'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,GNOME/librsvg,"bgo#783835 - Don't divide by zero in box_blur_line() for gaussian blurs

We were making the decision to use box blurs, instead of a true
Gaussian kernel, based on the size of *both* x and y dimensions.  Do
them individually instead.",ecf9267a24b2c3c0cd211dbdfa9ef2232511972a,https://github.com/GNOME/librsvg/commit/ecf9267a24b2c3c0cd211dbdfa9ef2232511972a,rsvg-filter.c,gaussian_blur_surface,"static void
gaussian_blur_surface (cairo_surface_t *in,
cairo_surface_t *out,
gdouble sx,
gdouble sy)
{
gboolean use_box_blur;
gint width, height;
cairo_format_t in_format, out_format;
gint in_stride;
gint out_stride;
guchar *in_data, *out_data;
gint bpp;
gboolean out_has_data;
cairo_surface_flush (in);
width = cairo_image_surface_get_width (in);
height = cairo_image_surface_get_height (in);
g_assert (width == cairo_image_surface_get_width (out)
&& height == cairo_image_surface_get_height (out));
in_format = cairo_image_surface_get_format (in);
out_format = cairo_image_surface_get_format (out);
g_assert (in_format == out_format);
g_assert (in_format == CAIRO_FORMAT_ARGB32
|| in_format == CAIRO_FORMAT_A8);
if (in_format == CAIRO_FORMAT_ARGB32)
bpp = 4;
else if (in_format == CAIRO_FORMAT_A8)
bpp = 1;
else {
g_assert_not_reached ();
return;
}
in_stride = cairo_image_surface_get_stride (in);
out_stride = cairo_image_surface_get_stride (out);
in_data = cairo_image_surface_get_data (in);
out_data = cairo_image_surface_get_data (out);
if (sx < 0.0)
sx = 0.0;
if (sy < 0.0)
sy = 0.0;
if (sx < 10.0 && sy < 10.0)
use_box_blur = FALSE;
else
use_box_blur = TRUE;
if ((sx == 0.0 && sy == 0.0)
|| sx > 1000 || sy > 1000) {
cairo_t *cr;
cr = cairo_create (out);
cairo_set_source_surface (cr, in, 0, 0);
cairo_paint (cr);
cairo_destroy (cr);
return;
}
if (sx != 0.0) {
gint box_width;
gdouble *gaussian_matrix;
gint gaussian_matrix_len;
int y;
guchar *row_buffer = NULL;
guchar *row1, *row2;
if (use_box_blur) {
box_width = compute_box_blur_width (sx);
row_buffer = g_new0 (guchar, width * bpp * 2);
row1 = row_buffer;
row2 = row_buffer + width * bpp;
} else
make_gaussian_convolution_matrix (sx, &gaussian_matrix, &gaussian_matrix_len);
for (y = 0; y < height; y++) {
guchar *in_row, *out_row;
in_row = in_data + in_stride * y;
out_row = out_data + out_stride * y;
if (use_box_blur) {
if (box_width % 2 != 0) {
box_blur_line (box_width, 0, in_row, row1,    width, bpp);
box_blur_line (box_width, 0, row1,   row2,    width, bpp);
box_blur_line (box_width, 0, row2,   out_row, width, bpp);
} else {
box_blur_line (box_width,     -1, in_row, row1,    width, bpp);
box_blur_line (box_width,      1, row1,   row2,    width, bpp);
box_blur_line (box_width + 1,  0, row2,   out_row, width, bpp);
}
} else
gaussian_blur_line (gaussian_matrix, gaussian_matrix_len, in_row, out_row, width, bpp);
}
if (!use_box_blur)
g_free (gaussian_matrix);
g_free (row_buffer);
out_has_data = TRUE;
} else
out_has_data = FALSE;
if (sy != 0.0) {
gint box_height;
gdouble *gaussian_matrix = NULL;
gint gaussian_matrix_len;
guchar *col_buffer;
guchar *col1, *col2;
int x;
col_buffer = g_new0 (guchar, height * bpp * 2);
col1 = col_buffer;
col2 = col_buffer + height * bpp;
if (use_box_blur) {
box_height = compute_box_blur_width (sy);
} else
make_gaussian_convolution_matrix (sy, &gaussian_matrix, &gaussian_matrix_len);
for (x = 0; x < width; x++) {
if (out_has_data)
get_column (col1, out_data, out_stride, bpp, height, x);
else
get_column (col1, in_data, in_stride, bpp, height, x);
if (use_box_blur) {
if (box_height % 2 != 0) {
box_blur_line (box_height, 0, col1, col2, height, bpp);
box_blur_line (box_height, 0, col2, col1, height, bpp);
box_blur_line (box_height, 0, col1, col2, height, bpp);
} else {
box_blur_line (box_height,     -1, col1, col2, height, bpp);
box_blur_line (box_height,      1, col2, col1, height, bpp);
box_blur_line (box_height + 1,  0, col1, col2, height, bpp);
}
} else
gaussian_blur_line (gaussian_matrix, gaussian_matrix_len, col1, col2, height, bpp);
put_column (col2, out_data, out_stride, bpp, height, x);
}
g_free (gaussian_matrix);
g_free (col_buffer);
}
cairo_surface_mark_dirty (out);
}","static void
gaussian_blur_surface (cairo_surface_t *VAR_0,
cairo_surface_t *VAR_1,
gdouble VAR_2,
gdouble VAR_3)
{
gboolean VAR_4;
gint VAR_5, VAR_6;
cairo_format_t VAR_7, VAR_8;
gint VAR_9;
gint VAR_10;
guchar *VAR_11, *VAR_12;
gint VAR_13;
gboolean VAR_14;
cairo_surface_flush (VAR_0);
VAR_5 = cairo_image_surface_get_width (VAR_0);
VAR_6 = cairo_image_surface_get_height (VAR_0);
g_assert (VAR_5 == cairo_image_surface_get_width (VAR_1)
&& VAR_6 == cairo_image_surface_get_height (VAR_1));
VAR_7 = cairo_image_surface_get_format (VAR_0);
VAR_8 = cairo_image_surface_get_format (VAR_1);
g_assert (VAR_7 == VAR_8);
g_assert (VAR_7 == VAR_15
|| VAR_7 == VAR_16);
if (VAR_7 == VAR_15)
VAR_13 = 4;
else if (VAR_7 == VAR_16)
VAR_13 = 1;
else {
g_assert_not_reached ();
return;
}
VAR_9 = cairo_image_surface_get_stride (VAR_0);
VAR_10 = cairo_image_surface_get_stride (VAR_1);
VAR_11 = cairo_image_surface_get_data (VAR_0);
VAR_12 = cairo_image_surface_get_data (VAR_1);
if (VAR_2 < 0.0)
VAR_2 = 0.0;
if (VAR_3 < 0.0)
VAR_3 = 0.0;
if (VAR_2 < 10.0 && VAR_3 < 10.0)
VAR_4 = FALSE;
else
VAR_4 = TRUE;
if ((VAR_2 == 0.0 && VAR_3 == 0.0)
|| VAR_2 > 1000 || VAR_3 > 1000) {
cairo_t *VAR_17;
VAR_17 = cairo_create (VAR_1);
cairo_set_source_surface (VAR_17, VAR_0, 0, 0);
cairo_paint (VAR_17);
cairo_destroy (VAR_17);
return;
}
if (VAR_2 != 0.0) {
gint VAR_18;
gdouble *VAR_19;
gint VAR_20;
int VAR_21;
guchar *VAR_22 = NULL;
guchar *VAR_23, *VAR_24;
if (VAR_4) {
VAR_18 = compute_box_blur_width (VAR_2);
VAR_22 = g_new0 (guchar, VAR_5 * VAR_13 * 2);
VAR_23 = VAR_22;
VAR_24 = VAR_22 + VAR_5 * VAR_13;
} else
make_gaussian_convolution_matrix (VAR_2, &VAR_19, &VAR_20);
for (VAR_21 = 0; VAR_21 < VAR_6; VAR_21++) {
guchar *VAR_25, *VAR_26;
VAR_25 = VAR_11 + VAR_9 * VAR_21;
VAR_26 = VAR_12 + VAR_10 * VAR_21;
if (VAR_4) {
if (VAR_18 % 2 != 0) {
box_blur_line (VAR_18, 0, VAR_25, VAR_23,    VAR_5, VAR_13);
box_blur_line (VAR_18, 0, VAR_23,   VAR_24,    VAR_5, VAR_13);
box_blur_line (VAR_18, 0, VAR_24,   VAR_26, VAR_5, VAR_13);
} else {
box_blur_line (VAR_18,     -1, VAR_25, VAR_23,    VAR_5, VAR_13);
box_blur_line (VAR_18,      1, VAR_23,   VAR_24,    VAR_5, VAR_13);
box_blur_line (VAR_18 + 1,  0, VAR_24,   VAR_26, VAR_5, VAR_13);
}
} else
gaussian_blur_line (VAR_19, VAR_20, VAR_25, VAR_26, VAR_5, VAR_13);
}
if (!VAR_4)
g_free (VAR_19);
g_free (VAR_22);
VAR_14 = TRUE;
} else
VAR_14 = FALSE;
if (VAR_3 != 0.0) {
gint VAR_27;
gdouble *VAR_19 = NULL;
gint VAR_20;
guchar *VAR_28;
guchar *VAR_29, *VAR_30;
int VAR_31;
VAR_28 = g_new0 (guchar, VAR_6 * VAR_13 * 2);
VAR_29 = VAR_28;
VAR_30 = VAR_28 + VAR_6 * VAR_13;
if (VAR_4) {
VAR_27 = compute_box_blur_width (VAR_3);
} else
make_gaussian_convolution_matrix (VAR_3, &VAR_19, &VAR_20);
for (VAR_31 = 0; VAR_31 < VAR_5; VAR_31++) {
if (VAR_14)
get_column (VAR_29, VAR_12, VAR_10, VAR_13, VAR_6, VAR_31);
else
get_column (VAR_29, VAR_11, VAR_9, VAR_13, VAR_6, VAR_31);
if (VAR_4) {
if (VAR_27 % 2 != 0) {
box_blur_line (VAR_27, 0, VAR_29, VAR_30, VAR_6, VAR_13);
box_blur_line (VAR_27, 0, VAR_30, VAR_29, VAR_6, VAR_13);
box_blur_line (VAR_27, 0, VAR_29, VAR_30, VAR_6, VAR_13);
} else {
box_blur_line (VAR_27,     -1, VAR_29, VAR_30, VAR_6, VAR_13);
box_blur_line (VAR_27,      1, VAR_30, VAR_29, VAR_6, VAR_13);
box_blur_line (VAR_27 + 1,  0, VAR_29, VAR_30, VAR_6, VAR_13);
}
} else
gaussian_blur_line (VAR_19, VAR_20, VAR_29, VAR_30, VAR_6, VAR_13);
put_column (VAR_30, VAR_12, VAR_10, VAR_13, VAR_6, VAR_31);
}
g_free (VAR_19);
g_free (VAR_28);
}
cairo_surface_mark_dirty (VAR_1);
}",GNOME/librsvg/ecf9267a24b2c3c0cd211dbdfa9ef2232511972a/rsvg-filter.c/vul/before/1.json,"static void
gaussian_blur_surface (cairo_surface_t *in,
                       cairo_surface_t *out,
                       gdouble sx,
                       gdouble sy)
{
    gint width, height;
    cairo_format_t in_format, out_format;
    gint in_stride;
    gint out_stride;
    guchar *in_data, *out_data;
    gint bpp;
    gboolean out_has_data;

    cairo_surface_flush (in);

    width = cairo_image_surface_get_width (in);
    height = cairo_image_surface_get_height (in);

    g_assert (width == cairo_image_surface_get_width (out)
              && height == cairo_image_surface_get_height (out));

    in_format = cairo_image_surface_get_format (in);
    out_format = cairo_image_surface_get_format (out);
    g_assert (in_format == out_format);
    g_assert (in_format == CAIRO_FORMAT_ARGB32
              || in_format == CAIRO_FORMAT_A8);

    if (in_format == CAIRO_FORMAT_ARGB32)
        bpp = 4;
    else if (in_format == CAIRO_FORMAT_A8)
        bpp = 1;
    else {
        g_assert_not_reached ();
        return;
    }

    in_stride = cairo_image_surface_get_stride (in);
    out_stride = cairo_image_surface_get_stride (out);

    in_data = cairo_image_surface_get_data (in);
    out_data = cairo_image_surface_get_data (out);

    if (sx < 0.0)
        sx = 0.0;

    if (sy < 0.0)
        sy = 0.0;

    /* Bail out by just copying? */
    if ((sx == 0.0 && sy == 0.0)
        || sx > 1000 || sy > 1000) {
        cairo_t *cr;

        cr = cairo_create (out);
        cairo_set_source_surface (cr, in, 0, 0);
        cairo_paint (cr);
        cairo_destroy (cr);
        return;
    }

    if (sx != 0.0) {
        gint box_width;
        gdouble *gaussian_matrix;
        gint gaussian_matrix_len;
        int y;
        guchar *row_buffer = NULL;
        guchar *row1, *row2;
        gboolean use_box_blur;

        /* For small radiuses, use a true gaussian kernel; otherwise use three box blurs with
         * clever offsets.
         */
        if (sx < 10.0)
            use_box_blur = FALSE;
        else
            use_box_blur = TRUE;

        if (use_box_blur) {
            box_width = compute_box_blur_width (sx);

            /* twice the size so we can have ""two"" scratch rows */
            row_buffer = g_new0 (guchar, width * bpp * 2);
            row1 = row_buffer;
            row2 = row_buffer + width * bpp;
        } else
            make_gaussian_convolution_matrix (sx, &gaussian_matrix, &gaussian_matrix_len);

        for (y = 0; y < height; y++) {
            guchar *in_row, *out_row;

            in_row = in_data + in_stride * y;
            out_row = out_data + out_stride * y;

            if (use_box_blur) {
                if (box_width % 2 != 0) {
                    /* Odd-width box blur: repeat 3 times, centered on output pixel */

                    box_blur_line (box_width, 0, in_row, row1,    width, bpp);
                    box_blur_line (box_width, 0, row1,   row2,    width, bpp);
                    box_blur_line (box_width, 0, row2,   out_row, width, bpp);
                } else {
                    /* Even-width box blur:
                     * This method is suggested by the specification for SVG.
                     * One pass with width n, centered between output and right pixel
                     * One pass with width n, centered between output and left pixel
                     * One pass with width n+1, centered on output pixel
                     */
                    box_blur_line (box_width,     -1, in_row, row1,    width, bpp);
                    box_blur_line (box_width,      1, row1,   row2,    width, bpp);
                    box_blur_line (box_width + 1,  0, row2,   out_row, width, bpp);
                }
            } else
                gaussian_blur_line (gaussian_matrix, gaussian_matrix_len, in_row, out_row, width, bpp);
        }

        if (!use_box_blur)
            g_free (gaussian_matrix);

        g_free (row_buffer);

        out_has_data = TRUE;
    } else
        out_has_data = FALSE;

    if (sy != 0.0) {
        gint box_height;
        gdouble *gaussian_matrix = NULL;
        gint gaussian_matrix_len;
        guchar *col_buffer;
        guchar *col1, *col2;
        int x;
        gboolean use_box_blur;

        /* For small radiuses, use a true gaussian kernel; otherwise use three box blurs with
         * clever offsets.
         */
        if (sy < 10.0)
            use_box_blur = FALSE;
        else
            use_box_blur = TRUE;

        /* twice the size so we can have the source pixels and the blurred pixels */
        col_buffer = g_new0 (guchar, height * bpp * 2);
        col1 = col_buffer;
        col2 = col_buffer + height * bpp;

        if (use_box_blur) {
            box_height = compute_box_blur_width (sy);
        } else
            make_gaussian_convolution_matrix (sy, &gaussian_matrix, &gaussian_matrix_len);

        for (x = 0; x < width; x++) {
            if (out_has_data)
                get_column (col1, out_data, out_stride, bpp, height, x);
            else
                get_column (col1, in_data, in_stride, bpp, height, x);

            if (use_box_blur) {
                if (box_height % 2 != 0) {
                    /* Odd-width box blur */
                    box_blur_line (box_height, 0, col1, col2, height, bpp);
                    box_blur_line (box_height, 0, col2, col1, height, bpp);
                    box_blur_line (box_height, 0, col1, col2, height, bpp);
                } else {
                    /* Even-width box blur */
                    box_blur_line (box_height,     -1, col1, col2, height, bpp);
                    box_blur_line (box_height,      1, col2, col1, height, bpp);
                    box_blur_line (box_height + 1,  0, col1, col2, height, bpp);
                }
            } else
                gaussian_blur_line (gaussian_matrix, gaussian_matrix_len, col1, col2, height, bpp);

            put_column (col2, out_data, out_stride, bpp, height, x);
        }

        g_free (gaussian_matrix);
        g_free (col_buffer);
    }

    cairo_surface_mark_dirty (out);
}","static void
gaussian_blur_surface (cairo_surface_t *VAR_0,
                       cairo_surface_t *VAR_1,
                       gdouble VAR_2,
                       gdouble VAR_3)
{
    gint VAR_4, VAR_5;
    cairo_format_t VAR_6, VAR_7;
    gint VAR_8;
    gint VAR_9;
    guchar *VAR_10, *VAR_11;
    gint VAR_12;
    gboolean VAR_13;

    cairo_surface_flush (VAR_0);

    VAR_4 = cairo_image_surface_get_width (VAR_0);
    VAR_5 = cairo_image_surface_get_height (VAR_0);

    g_assert (VAR_4 == cairo_image_surface_get_width (VAR_1)
              && VAR_5 == cairo_image_surface_get_height (VAR_1));

    VAR_6 = cairo_image_surface_get_format (VAR_0);
    VAR_7 = cairo_image_surface_get_format (VAR_1);
    g_assert (VAR_6 == VAR_7);
    g_assert (VAR_6 == VAR_14
              || VAR_6 == VAR_15);

    if (VAR_6 == VAR_14)
        VAR_12 = 4;
    else if (VAR_6 == VAR_15)
        VAR_12 = 1;
    else {
        g_assert_not_reached ();
        return;
    }

    VAR_8 = cairo_image_surface_get_stride (VAR_0);
    VAR_9 = cairo_image_surface_get_stride (VAR_1);

    VAR_10 = cairo_image_surface_get_data (VAR_0);
    VAR_11 = cairo_image_surface_get_data (VAR_1);

    if (VAR_2 < 0.0)
        VAR_2 = 0.0;

    if (VAR_3 < 0.0)
        VAR_3 = 0.0;

    /* COMMENT_0 */
    if ((VAR_2 == 0.0 && VAR_3 == 0.0)
        || VAR_2 > 1000 || VAR_3 > 1000) {
        cairo_t *VAR_16;

        VAR_16 = cairo_create (VAR_1);
        cairo_set_source_surface (VAR_16, VAR_0, 0, 0);
        cairo_paint (VAR_16);
        cairo_destroy (VAR_16);
        return;
    }

    if (VAR_2 != 0.0) {
        gint VAR_17;
        gdouble *VAR_18;
        gint VAR_19;
        int VAR_20;
        guchar *VAR_21 = NULL;
        guchar *VAR_22, *VAR_23;
        gboolean VAR_24;

        /* COMMENT_1 */
                          
           
        if (VAR_2 < 10.0)
            VAR_24 = FALSE;
        else
            VAR_24 = TRUE;

        if (VAR_24) {
            VAR_17 = compute_box_blur_width (VAR_2);

            /* COMMENT_4 */
            VAR_21 = g_new0 (guchar, VAR_4 * VAR_12 * 2);
            VAR_22 = VAR_21;
            VAR_23 = VAR_21 + VAR_4 * VAR_12;
        } else
            make_gaussian_convolution_matrix (VAR_2, &VAR_18, &VAR_19);

        for (VAR_20 = 0; VAR_20 < VAR_5; VAR_20++) {
            guchar *VAR_25, *VAR_26;

            VAR_25 = VAR_10 + VAR_8 * VAR_20;
            VAR_26 = VAR_11 + VAR_9 * VAR_20;

            if (VAR_24) {
                if (VAR_17 % 2 != 0) {
                    /* COMMENT_5 */

                    box_blur_line (VAR_17, 0, VAR_25, VAR_22,    VAR_4, VAR_12);
                    box_blur_line (VAR_17, 0, VAR_22,   VAR_23,    VAR_4, VAR_12);
                    box_blur_line (VAR_17, 0, VAR_23,   VAR_26, VAR_4, VAR_12);
                } else {
                    /* COMMENT_6 */
                                                                             
                                                                                     
                                                                                    
                                                                        
                       
                    box_blur_line (VAR_17,     -1, VAR_25, VAR_22,    VAR_4, VAR_12);
                    box_blur_line (VAR_17,      1, VAR_22,   VAR_23,    VAR_4, VAR_12);
                    box_blur_line (VAR_17 + 1,  0, VAR_23,   VAR_26, VAR_4, VAR_12);
                }
            } else
                gaussian_blur_line (VAR_18, VAR_19, VAR_25, VAR_26, VAR_4, VAR_12);
        }

        if (!VAR_24)
            g_free (VAR_18);

        g_free (VAR_21);

        VAR_13 = TRUE;
    } else
        VAR_13 = FALSE;

    if (VAR_3 != 0.0) {
        gint VAR_27;
        gdouble *VAR_18 = NULL;
        gint VAR_19;
        guchar *VAR_28;
        guchar *VAR_29, *VAR_30;
        int VAR_31;
        gboolean VAR_24;

        /* COMMENT_12 */
                          
           
        if (VAR_3 < 10.0)
            VAR_24 = FALSE;
        else
            VAR_24 = TRUE;

        /* COMMENT_15 */
        VAR_28 = g_new0 (guchar, VAR_5 * VAR_12 * 2);
        VAR_29 = VAR_28;
        VAR_30 = VAR_28 + VAR_5 * VAR_12;

        if (VAR_24) {
            VAR_27 = compute_box_blur_width (VAR_3);
        } else
            make_gaussian_convolution_matrix (VAR_3, &VAR_18, &VAR_19);

        for (VAR_31 = 0; VAR_31 < VAR_4; VAR_31++) {
            if (VAR_13)
                get_column (VAR_29, VAR_11, VAR_9, VAR_12, VAR_5, VAR_31);
            else
                get_column (VAR_29, VAR_10, VAR_8, VAR_12, VAR_5, VAR_31);

            if (VAR_24) {
                if (VAR_27 % 2 != 0) {
                    /* COMMENT_16 */
                    box_blur_line (VAR_27, 0, VAR_29, VAR_30, VAR_5, VAR_12);
                    box_blur_line (VAR_27, 0, VAR_30, VAR_29, VAR_5, VAR_12);
                    box_blur_line (VAR_27, 0, VAR_29, VAR_30, VAR_5, VAR_12);
                } else {
                    /* COMMENT_17 */
                    box_blur_line (VAR_27,     -1, VAR_29, VAR_30, VAR_5, VAR_12);
                    box_blur_line (VAR_27,      1, VAR_30, VAR_29, VAR_5, VAR_12);
                    box_blur_line (VAR_27 + 1,  0, VAR_29, VAR_30, VAR_5, VAR_12);
                }
            } else
                gaussian_blur_line (VAR_18, VAR_19, VAR_29, VAR_30, VAR_5, VAR_12);

            put_column (VAR_30, VAR_11, VAR_9, VAR_12, VAR_5, VAR_31);
        }

        g_free (VAR_18);
        g_free (VAR_28);
    }

    cairo_surface_mark_dirty (VAR_1);
}",GNOME/librsvg/ecf9267a24b2c3c0cd211dbdfa9ef2232511972a/rsvg-filter.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -4,7 +4,6 @@
                        gdouble sx,
                        gdouble sy)
 {
-    gboolean use_box_blur;
     gint width, height;
     cairo_format_t in_format, out_format;
     gint in_stride;
@@ -48,14 +47,6 @@
     if (sy < 0.0)
         sy = 0.0;
 
-    /* For small radiuses, use a true gaussian kernel; otherwise use three box blurs with
-     * clever offsets.
-     */
-    if (sx < 10.0 && sy < 10.0)
-        use_box_blur = FALSE;
-    else
-        use_box_blur = TRUE;
-
     /* Bail out by just copying? */
     if ((sx == 0.0 && sy == 0.0)
         || sx > 1000 || sy > 1000) {
@@ -75,6 +66,15 @@
         int y;
         guchar *row_buffer = NULL;
         guchar *row1, *row2;
+        gboolean use_box_blur;
+
+        /* For small radiuses, use a true gaussian kernel; otherwise use three box blurs with
+         * clever offsets.
+         */
+        if (sx < 10.0)
+            use_box_blur = FALSE;
+        else
+            use_box_blur = TRUE;
 
         if (use_box_blur) {
             box_width = compute_box_blur_width (sx);
@@ -130,6 +130,15 @@
         guchar *col_buffer;
         guchar *col1, *col2;
         int x;
+        gboolean use_box_blur;
+
+        /* For small radiuses, use a true gaussian kernel; otherwise use three box blurs with
+         * clever offsets.
+         */
+        if (sy < 10.0)
+            use_box_blur = FALSE;
+        else
+            use_box_blur = TRUE;
 
         /* twice the size so we can have the source pixels and the blurred pixels */
         col_buffer = g_new0 (guchar, height * bpp * 2);","{'deleted_lines': ['    gboolean use_box_blur;', '    /* For small radiuses, use a true gaussian kernel; otherwise use three box blurs with', '     * clever offsets.', '     */', '    if (sx < 10.0 && sy < 10.0)', '        use_box_blur = FALSE;', '    else', '        use_box_blur = TRUE;', ''], 'added_lines': ['        gboolean use_box_blur;', '', '        /* For small radiuses, use a true gaussian kernel; otherwise use three box blurs with', '         * clever offsets.', '         */', '        if (sx < 10.0)', '            use_box_blur = FALSE;', '        else', '            use_box_blur = TRUE;', '        gboolean use_box_blur;', '', '        /* For small radiuses, use a true gaussian kernel; otherwise use three box blurs with', '         * clever offsets.', '         */', '        if (sy < 10.0)', '            use_box_blur = FALSE;', '        else', '            use_box_blur = TRUE;']}",True,"A SIGFPE is raised in the function box_blur_line of rsvg-filter.c in GNOME librsvg 2.40.17 during an attempted parse of a crafted SVG file, because of incorrect protection against division by zero.",7.8,HIGH,2,test,2017-06-27T22:12:51Z,1
CVE-2017-11464,['CWE-369'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,GNOME/librsvg,"bgo#783835 - Don't divide by zero in box_blur_line() for gaussian blurs

We were making the decision to use box blurs, instead of a true
Gaussian kernel, based on the size of *both* x and y dimensions.  Do
them individually instead.",ecf9267a24b2c3c0cd211dbdfa9ef2232511972a,https://github.com/GNOME/librsvg/commit/ecf9267a24b2c3c0cd211dbdfa9ef2232511972a,rsvg-filter.c,box_blur_line,"static void
box_blur_line (gint box_width, gint even_offset,
guchar *src, guchar *dest,
gint len, gint bpp)
{
gint  i;
gint  lead;    
gint  output;  
gint  trail;   
gint  *ac;     
ac = g_new0 (gint, bpp);
lead = 0;
if (box_width % 2 != 0) {
output = lead - (box_width - 1) / 2;
trail  = lead - box_width;
} else {
if (even_offset == 1) {
output = lead + 1 - box_width / 2;
trail  = lead - box_width;
} else if (even_offset == -1) {
output = lead - box_width / 2;
trail  = lead - box_width;
} else {
g_assert_not_reached ();
}
}
for (i = 0; i < bpp; i++)
ac[i] = 0;
while (output < len) {
guint coverage = (lead < len ? lead : len - 1) - (trail >= 0 ? trail : -1);
#ifdef READABLE_BOXBLUR_CODE
for (i = 0; i < bpp; i++) {
if (lead < len)
ac[i] += src[bpp * lead + i];
if (trail >= 0)
ac[i] -= src[bpp * trail + i];
if (output >= 0)
dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;
}
#endif
if (lead < len) {
if (trail >= 0) {
for (i = 0; i < bpp; i++) {
ac[i] += src[bpp * lead + i];
ac[i] -= src[bpp * trail + i];
dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;
}
} else if (output >= 0) {
for (i = 0; i < bpp; i++) {
ac[i] += src[bpp * lead + i];
dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;
}
} else {
for (i = 0; i < bpp; i++)
ac[i] += src[bpp * lead + i];
}
} else if (trail >= 0) {
for (i = 0; i < bpp; i++) {
ac[i] -= src[bpp * trail + i];
dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;
}
} else if (output >= 0) {
for (i = 0; i < bpp; i++)
dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;
}
lead++;
output++;
trail++;
}
g_free (ac);
}","static void
box_blur_line (gint VAR_0, gint VAR_1,
guchar *VAR_2, guchar *VAR_3,
gint VAR_4, gint VAR_5)
{
gint  VAR_6;
gint  VAR_7;    
gint  VAR_8;  
gint  VAR_9;   
gint  *VAR_10;     
VAR_10 = g_new0 (gint, VAR_5);
VAR_7 = 0;
if (VAR_0 % 2 != 0) {
VAR_8 = VAR_7 - (VAR_0 - 1) / 2;
VAR_9  = VAR_7 - VAR_0;
} else {
if (VAR_1 == 1) {
VAR_8 = VAR_7 + 1 - VAR_0 / 2;
VAR_9  = VAR_7 - VAR_0;
} else if (VAR_1 == -1) {
VAR_8 = VAR_7 - VAR_0 / 2;
VAR_9  = VAR_7 - VAR_0;
} else {
g_assert_not_reached ();
}
}
for (VAR_6 = 0; VAR_6 < VAR_5; VAR_6++)
VAR_10[VAR_6] = 0;
while (VAR_8 < VAR_4) {
guint VAR_11 = (VAR_7 < VAR_4 ? VAR_7 : VAR_4 - 1) - (VAR_9 >= 0 ? VAR_9 : -1);
#ifdef VAR_12
for (VAR_6 = 0; VAR_6 < VAR_5; VAR_6++) {
if (VAR_7 < VAR_4)
VAR_10[VAR_6] += VAR_2[VAR_5 * VAR_7 + VAR_6];
if (VAR_9 >= 0)
VAR_10[VAR_6] -= VAR_2[VAR_5 * VAR_9 + VAR_6];
if (VAR_8 >= 0)
VAR_3[VAR_5 * VAR_8 + VAR_6] = (VAR_10[VAR_6] + (VAR_11 >> 1)) / VAR_11;
}
#endif
if (VAR_7 < VAR_4) {
if (VAR_9 >= 0) {
for (VAR_6 = 0; VAR_6 < VAR_5; VAR_6++) {
VAR_10[VAR_6] += VAR_2[VAR_5 * VAR_7 + VAR_6];
VAR_10[VAR_6] -= VAR_2[VAR_5 * VAR_9 + VAR_6];
VAR_3[VAR_5 * VAR_8 + VAR_6] = (VAR_10[VAR_6] + (VAR_11 >> 1)) / VAR_11;
}
} else if (VAR_8 >= 0) {
for (VAR_6 = 0; VAR_6 < VAR_5; VAR_6++) {
VAR_10[VAR_6] += VAR_2[VAR_5 * VAR_7 + VAR_6];
VAR_3[VAR_5 * VAR_8 + VAR_6] = (VAR_10[VAR_6] + (VAR_11 >> 1)) / VAR_11;
}
} else {
for (VAR_6 = 0; VAR_6 < VAR_5; VAR_6++)
VAR_10[VAR_6] += VAR_2[VAR_5 * VAR_7 + VAR_6];
}
} else if (VAR_9 >= 0) {
for (VAR_6 = 0; VAR_6 < VAR_5; VAR_6++) {
VAR_10[VAR_6] -= VAR_2[VAR_5 * VAR_9 + VAR_6];
VAR_3[VAR_5 * VAR_8 + VAR_6] = (VAR_10[VAR_6] + (VAR_11 >> 1)) / VAR_11;
}
} else if (VAR_8 >= 0) {
for (VAR_6 = 0; VAR_6 < VAR_5; VAR_6++)
VAR_3[VAR_5 * VAR_8 + VAR_6] = (VAR_10[VAR_6] + (VAR_11 >> 1)) / VAR_11;
}
VAR_7++;
VAR_8++;
VAR_9++;
}
g_free (VAR_10);
}",GNOME/librsvg/ecf9267a24b2c3c0cd211dbdfa9ef2232511972a/rsvg-filter.c/vul/before/0.json,"static void
box_blur_line (gint box_width, gint even_offset,
               guchar *src, guchar *dest,
               gint len, gint bpp)
{
    gint  i;
    gint  lead;    /* This marks the leading edge of the kernel              */
    gint  output;  /* This marks the center of the kernel                    */
    gint  trail;   /* This marks the pixel BEHIND the last 1 in the
                      kernel; it's the pixel to remove from the accumulator. */
    gint  *ac;     /* Accumulator for each channel                           */

    g_assert (box_width > 0);

    ac = g_new0 (gint, bpp);

    /* The algorithm differs for even and odd-sized kernels.
     * With the output at the center,
     * If odd, the kernel might look like this: 0011100
     * If even, the kernel will either be centered on the boundary between
     * the output and its left neighbor, or on the boundary between the
     * output and its right neighbor, depending on even_lr.
     * So it might be 0111100 or 0011110, where output is on the center
     * of these arrays.
     */
    lead = 0;

    if (box_width % 2 != 0) {
        /* Odd-width kernel */
        output = lead - (box_width - 1) / 2;
        trail  = lead - box_width;
    } else {
        /* Even-width kernel. */
        if (even_offset == 1) {
            /* Right offset */
            output = lead + 1 - box_width / 2;
            trail  = lead - box_width;
        } else if (even_offset == -1) {
            /* Left offset */
            output = lead - box_width / 2;
            trail  = lead - box_width;
        } else {
            /* If even_offset isn't 1 or -1, there's some error. */
            g_assert_not_reached ();
        }
    }

    /* Initialize accumulator */
    for (i = 0; i < bpp; i++)
        ac[i] = 0;

    /* As the kernel moves across the image, it has a leading edge and a
     * trailing edge, and the output is in the middle. */
    while (output < len) {
        /* The number of pixels that are both in the image and
         * currently covered by the kernel. This is necessary to
         * handle edge cases. */
        guint coverage = (lead < len ? lead : len - 1) - (trail >= 0 ? trail : -1);

#ifdef READABLE_BOXBLUR_CODE
/* The code here does the same as the code below, but the code below
 * has been optimized by moving the if statements out of the tight for
 * loop, and is harder to understand.
 * Don't use both this code and the code below. */
        for (i = 0; i < bpp; i++) {
            /* If the leading edge of the kernel is still on the image,
             * add the value there to the accumulator. */
            if (lead < len)
                ac[i] += src[bpp * lead + i];

            /* If the trailing edge of the kernel is on the image,
             * subtract the value there from the accumulator. */
            if (trail >= 0)
                ac[i] -= src[bpp * trail + i];

            /* Take the averaged value in the accumulator and store
             * that value in the output. The number of pixels currently
             * stored in the accumulator can be less than the nominal
             * width of the kernel because the kernel can go ""over the edge""
             * of the image. */
            if (output >= 0)
                dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;
        }
#endif

        /* If the leading edge of the kernel is still on the image... */
        if (lead < len) {
            if (trail >= 0) {
                /* If the trailing edge of the kernel is on the image. (Since
                 * the output is in between the lead and trail, it must be on
                 * the image. */
                for (i = 0; i < bpp; i++) {
                    ac[i] += src[bpp * lead + i];
                    ac[i] -= src[bpp * trail + i];
                    dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;
                }
            } else if (output >= 0) {
                /* If the output is on the image, but the trailing edge isn't yet
                 * on the image. */

                for (i = 0; i < bpp; i++) {
                    ac[i] += src[bpp * lead + i];
                    dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;
                }
            } else {
                /* If leading edge is on the image, but the output and trailing
                 * edge aren't yet on the image. */
                for (i = 0; i < bpp; i++)
                    ac[i] += src[bpp * lead + i];
            }
        } else if (trail >= 0) {
            /* If the leading edge has gone off the image, but the output and
             * trailing edge are on the image. (The big loop exits when the
             * output goes off the image. */
            for (i = 0; i < bpp; i++) {
                ac[i] -= src[bpp * trail + i];
                dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;
            }
        } else if (output >= 0) {
            /* Leading has gone off the image and trailing isn't yet in it
             * (small image) */
            for (i = 0; i < bpp; i++)
                dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;
        }

        lead++;
        output++;
        trail++;
    }

    g_free (ac);
}","static void
box_blur_line (gint VAR_0, gint VAR_1,
               guchar *VAR_2, guchar *VAR_3,
               gint VAR_4, gint VAR_5)
{
    gint  VAR_6;
    gint  VAR_7;    /* COMMENT_0 */
    gint  VAR_8;  /* COMMENT_1 */
    gint  VAR_9;   /* COMMENT_2 */
                                                                               
    gint  *VAR_10;     /* COMMENT_4 */

    g_assert (VAR_0 > 0);

    VAR_10 = g_new0 (gint, VAR_5);

    /* COMMENT_5 */
                                     
                                                       
                                                                          
                                                                       
                                                           
                                                                       
                       
       
    VAR_7 = 0;

    if (VAR_0 % 2 != 0) {
        /* COMMENT_14 */
        VAR_8 = VAR_7 - (VAR_0 - 1) / 2;
        VAR_9  = VAR_7 - VAR_0;
    } else {
        /* COMMENT_15 */
        if (VAR_1 == 1) {
            /* COMMENT_16 */
            VAR_8 = VAR_7 + 1 - VAR_0 / 2;
            VAR_9  = VAR_7 - VAR_0;
        } else if (VAR_1 == -1) {
            /* COMMENT_17 */
            VAR_8 = VAR_7 - VAR_0 / 2;
            VAR_9  = VAR_7 - VAR_0;
        } else {
            /* COMMENT_18 */
            g_assert_not_reached ();
        }
    }

    /* COMMENT_19 */
    for (VAR_6 = 0; VAR_6 < VAR_5; VAR_6++)
        VAR_10[VAR_6] = 0;

    /* COMMENT_20 */
                                                         
    while (VAR_8 < VAR_4) {
        /* COMMENT_22 */
                                                                
                                
        guint VAR_11 = (VAR_7 < VAR_4 ? VAR_7 : VAR_4 - 1) - (VAR_9 >= 0 ? VAR_9 : -1);

#ifdef VAR_12
/* COMMENT_25 */
                                                                      
                                     
                                                  
        for (VAR_6 = 0; VAR_6 < VAR_5; VAR_6++) {
            /* COMMENT_29 */
                                                         
            if (VAR_7 < VAR_4)
                VAR_10[VAR_6] += VAR_2[VAR_5 * VAR_7 + VAR_6];

            /* COMMENT_31 */
                                                                
            if (VAR_9 >= 0)
                VAR_10[VAR_6] -= VAR_2[VAR_5 * VAR_9 + VAR_6];

            /* COMMENT_33 */
                                                                       
                                                                     
                                                                            
                               
            if (VAR_8 >= 0)
                VAR_3[VAR_5 * VAR_8 + VAR_6] = (VAR_10[VAR_6] + (VAR_11 >> 1)) / VAR_11;
        }
#endif

        /* COMMENT_38 */
        if (VAR_7 < VAR_4) {
            if (VAR_9 >= 0) {
                /* COMMENT_39 */
                                                                             
                                
                for (VAR_6 = 0; VAR_6 < VAR_5; VAR_6++) {
                    VAR_10[VAR_6] += VAR_2[VAR_5 * VAR_7 + VAR_6];
                    VAR_10[VAR_6] -= VAR_2[VAR_5 * VAR_9 + VAR_6];
                    VAR_3[VAR_5 * VAR_8 + VAR_6] = (VAR_10[VAR_6] + (VAR_11 >> 1)) / VAR_11;
                }
            } else if (VAR_8 >= 0) {
                /* COMMENT_42 */
                                   

                for (VAR_6 = 0; VAR_6 < VAR_5; VAR_6++) {
                    VAR_10[VAR_6] += VAR_2[VAR_5 * VAR_7 + VAR_6];
                    VAR_3[VAR_5 * VAR_8 + VAR_6] = (VAR_10[VAR_6] + (VAR_11 >> 1)) / VAR_11;
                }
            } else {
                /* COMMENT_44 */
                                                   
                for (VAR_6 = 0; VAR_6 < VAR_5; VAR_6++)
                    VAR_10[VAR_6] += VAR_2[VAR_5 * VAR_7 + VAR_6];
            }
        } else if (VAR_9 >= 0) {
            /* COMMENT_46 */
                                                                           
                                            
            for (VAR_6 = 0; VAR_6 < VAR_5; VAR_6++) {
                VAR_10[VAR_6] -= VAR_2[VAR_5 * VAR_9 + VAR_6];
                VAR_3[VAR_5 * VAR_8 + VAR_6] = (VAR_10[VAR_6] + (VAR_11 >> 1)) / VAR_11;
            }
        } else if (VAR_8 >= 0) {
            /* COMMENT_49 */
                               
            for (VAR_6 = 0; VAR_6 < VAR_5; VAR_6++)
                VAR_3[VAR_5 * VAR_8 + VAR_6] = (VAR_10[VAR_6] + (VAR_11 >> 1)) / VAR_11;
        }

        VAR_7++;
        VAR_8++;
        VAR_9++;
    }

    g_free (VAR_10);
}",GNOME/librsvg/ecf9267a24b2c3c0cd211dbdfa9ef2232511972a/rsvg-filter.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,6 +9,8 @@
     gint  trail;   /* This marks the pixel BEHIND the last 1 in the
                       kernel; it's the pixel to remove from the accumulator. */
     gint  *ac;     /* Accumulator for each channel                           */
+
+    g_assert (box_width > 0);
 
     ac = g_new0 (gint, bpp);
 ","{'deleted_lines': [], 'added_lines': ['', '    g_assert (box_width > 0);']}",True,"A SIGFPE is raised in the function box_blur_line of rsvg-filter.c in GNOME librsvg 2.40.17 during an attempted parse of a crafted SVG file, because of incorrect protection against division by zero.",7.8,HIGH,2,test,2017-06-27T22:12:51Z,1
CVE-2017-11450,['CWE-Other'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ImageMagick,...,948356eec65aea91995d4b7cc487d197d2c5f602,https://github.com/ImageMagick/ImageMagick/commit/948356eec65aea91995d4b7cc487d197d2c5f602,coders/jpeg.c,ReadJPEGImage,"static Image *ReadJPEGImage(const ImageInfo *image_info,
ExceptionInfo *exception)
{
char
value[MaxTextExtent];
const char
*option;
ErrorManager
error_manager;
Image
*image;
IndexPacket
index;
JSAMPLE
*volatile jpeg_pixels;
JSAMPROW
scanline[1];
MagickBooleanType
debug,
status;
MagickSizeType
number_pixels;
MemoryInfo
*memory_info;
register ssize_t
i;
struct jpeg_decompress_struct
jpeg_info;
struct jpeg_error_mgr
jpeg_error;
register JSAMPLE
*p;
size_t
units;
ssize_t
y;
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickSignature);
debug=IsEventLogging();
(void) debug;
image=AcquireImage(image_info);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
(void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));
(void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));
(void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));
jpeg_info.err=jpeg_std_error(&jpeg_error);
jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;
jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;
memory_info=(MemoryInfo *) NULL;
error_manager.image=image;
if (setjmp(error_manager.error_recovery) != 0)
{
jpeg_destroy_decompress(&jpeg_info);
if (error_manager.profile != (StringInfo *) NULL)
error_manager.profile=DestroyStringInfo(error_manager.profile);
(void) CloseBlob(image);
number_pixels=(MagickSizeType) image->columns*image->rows;
if (number_pixels != 0)
return(GetFirstImageInList(image));
InheritException(exception,&image->exception);
return(DestroyImage(image));
}
jpeg_info.client_data=(void *) &error_manager;
jpeg_create_decompress(&jpeg_info);
JPEGSourceManager(&jpeg_info,image);
jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);
option=GetImageOption(image_info,""profile:skip"");
if (IsOptionMember(""ICC"",option) == MagickFalse)
jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);
if (IsOptionMember(""IPTC"",option) == MagickFalse)
jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);
for (i=1; i < 16; i++)
if ((i != 2) && (i != 13) && (i != 14))
if (IsOptionMember(""APP"",option) == MagickFalse)
jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);
i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);
if ((image_info->colorspace == YCbCrColorspace) ||
(image_info->colorspace == Rec601YCbCrColorspace) ||
(image_info->colorspace == Rec709YCbCrColorspace))
jpeg_info.out_color_space=JCS_YCbCr;
units=0;
if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&
(jpeg_info.Y_density != 1))
{
image->x_resolution=(double) jpeg_info.X_density;
image->y_resolution=(double) jpeg_info.Y_density;
units=(size_t) jpeg_info.density_unit;
}
if (units == 1)
image->units=PixelsPerInchResolution;
if (units == 2)
image->units=PixelsPerCentimeterResolution;
number_pixels=(MagickSizeType) image->columns*image->rows;
option=GetImageOption(image_info,""jpeg:size"");
if ((option != (const char *) NULL) &&
(jpeg_info.out_color_space != JCS_YCbCr))
{
double
scale_factor;
GeometryInfo
geometry_info;
MagickStatusType
flags;
flags=ParseGeometry(option,&geometry_info);
if ((flags & SigmaValue) == 0)
geometry_info.sigma=geometry_info.rho;
jpeg_calc_output_dimensions(&jpeg_info);
image->magick_columns=jpeg_info.output_width;
image->magick_rows=jpeg_info.output_height;
scale_factor=1.0;
if (geometry_info.rho != 0.0)
scale_factor=jpeg_info.output_width/geometry_info.rho;
if ((geometry_info.sigma != 0.0) &&
(scale_factor > (jpeg_info.output_height/geometry_info.sigma)))
scale_factor=jpeg_info.output_height/geometry_info.sigma;
jpeg_info.scale_num=1U;
jpeg_info.scale_denom=(unsigned int) scale_factor;
jpeg_calc_output_dimensions(&jpeg_info);
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""Scale factor: %.20g"",(double) scale_factor);
}
#if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)
#if defined(D_LOSSLESS_SUPPORTED)
image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?
JPEGInterlace : NoInterlace;
image->compression=jpeg_info.process == JPROC_LOSSLESS ?
LosslessJPEGCompression : JPEGCompression;
if (jpeg_info.data_precision > 8)
(void) ThrowMagickException(exception,GetMagickModule(),OptionError,
""12-bit JPEG not supported. Reducing pixel data to 8 bits"",""`%s'"",
image->filename);
if (jpeg_info.data_precision == 16)
jpeg_info.data_precision=12;
#else
image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :
NoInterlace;
image->compression=JPEGCompression;
#endif
#else
image->compression=JPEGCompression;
image->interlace=JPEGInterlace;
#endif
option=GetImageOption(image_info,""jpeg:colors"");
if (option != (const char *) NULL)
{
jpeg_info.quantize_colors=TRUE;
jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);
}
option=GetImageOption(image_info,""jpeg:block-smoothing"");
if (option != (const char *) NULL)
jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :
FALSE;
jpeg_info.dct_method=JDCT_FLOAT;
option=GetImageOption(image_info,""jpeg:dct-method"");
if (option != (const char *) NULL)
switch (*option)
{
case 'D':
case 'd':
{
if (LocaleCompare(option,""default"") == 0)
jpeg_info.dct_method=JDCT_DEFAULT;
break;
}
case 'F':
case 'f':
{
if (LocaleCompare(option,""fastest"") == 0)
jpeg_info.dct_method=JDCT_FASTEST;
if (LocaleCompare(option,""float"") == 0)
jpeg_info.dct_method=JDCT_FLOAT;
break;
}
case 'I':
case 'i':
{
if (LocaleCompare(option,""ifast"") == 0)
jpeg_info.dct_method=JDCT_IFAST;
if (LocaleCompare(option,""islow"") == 0)
jpeg_info.dct_method=JDCT_ISLOW;
break;
}
}
option=GetImageOption(image_info,""jpeg:fancy-upsampling"");
if (option != (const char *) NULL)
jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :
FALSE;
(void) jpeg_start_decompress(&jpeg_info);
image->columns=jpeg_info.output_width;
image->rows=jpeg_info.output_height;
image->depth=(size_t) jpeg_info.data_precision;
switch (jpeg_info.out_color_space)
{
case JCS_RGB:
default:
{
(void) SetImageColorspace(image,sRGBColorspace);
break;
}
case JCS_GRAYSCALE:
{
(void) SetImageColorspace(image,GRAYColorspace);
break;
}
case JCS_YCbCr:
{
(void) SetImageColorspace(image,YCbCrColorspace);
break;
}
case JCS_CMYK:
{
(void) SetImageColorspace(image,CMYKColorspace);
break;
}
}
if (IsITUFaxImage(image) != MagickFalse)
{
(void) SetImageColorspace(image,LabColorspace);
jpeg_info.out_color_space=JCS_YCbCr;
}
option=GetImageOption(image_info,""jpeg:colors"");
if (option != (const char *) NULL)
if (AcquireImageColormap(image,StringToUnsignedLong(option)) == MagickFalse)
{
InheritException(exception,&image->exception);
return(DestroyImageList(image));
}
if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))
{
size_t
colors;
colors=(size_t) GetQuantumRange(image->depth)+1;
if (AcquireImageColormap(image,colors) == MagickFalse)
{
InheritException(exception,&image->exception);
return(DestroyImageList(image));
}
}
if (image->debug != MagickFalse)
{
if (image->interlace != NoInterlace)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""Interlace: progressive"");
else
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""Interlace: nonprogressive"");
(void) LogMagickEvent(CoderEvent,GetMagickModule(),""Data precision: %d"",
(int) jpeg_info.data_precision);
(void) LogMagickEvent(CoderEvent,GetMagickModule(),""Geometry: %dx%d"",
(int) jpeg_info.output_width,(int) jpeg_info.output_height);
}
JPEGSetImageQuality(&jpeg_info,image);
JPEGSetImageSamplingFactor(&jpeg_info,image);
(void) FormatLocaleString(value,MaxTextExtent,""%.20g"",(double)
jpeg_info.out_color_space);
(void) SetImageProperty(image,""jpeg:colorspace"",value);
if (image_info->ping != MagickFalse)
{
jpeg_destroy_decompress(&jpeg_info);
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}
status=SetImageExtent(image,image->columns,image->rows);
if (status == MagickFalse)
{
jpeg_destroy_decompress(&jpeg_info);
InheritException(exception,&image->exception);
return(DestroyImageList(image));
}
if ((jpeg_info.output_components != 1) &&
(jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))
{
jpeg_destroy_decompress(&jpeg_info);
ThrowReaderException(CorruptImageError,""ImageTypeNotSupported"");
}
memory_info=AcquireVirtualMemory((size_t) image->columns,
jpeg_info.output_components*sizeof(*jpeg_pixels));
if (memory_info == (MemoryInfo *) NULL)
{
jpeg_destroy_decompress(&jpeg_info);
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
}
jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);
if (setjmp(error_manager.error_recovery) != 0)
{
if (memory_info != (MemoryInfo *) NULL)
memory_info=RelinquishVirtualMemory(memory_info);
jpeg_destroy_decompress(&jpeg_info);
(void) CloseBlob(image);
number_pixels=(MagickSizeType) image->columns*image->rows;
if (number_pixels != 0)
return(GetFirstImageInList(image));
return(DestroyImage(image));
}
if (jpeg_info.quantize_colors != 0)
{
image->colors=(size_t) jpeg_info.actual_number_of_colors;
if (jpeg_info.out_color_space == JCS_GRAYSCALE)
for (i=0; i < (ssize_t) image->colors; i++)
{
image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);
image->colormap[i].green=image->colormap[i].red;
image->colormap[i].blue=image->colormap[i].red;
image->colormap[i].opacity=OpaqueOpacity;
}
else
for (i=0; i < (ssize_t) image->colors; i++)
{
image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);
image->colormap[i].green=ScaleCharToQuantum(jpeg_info.colormap[1][i]);
image->colormap[i].blue=ScaleCharToQuantum(jpeg_info.colormap[2][i]);
image->colormap[i].opacity=OpaqueOpacity;
}
}
scanline[0]=(JSAMPROW) jpeg_pixels;
for (y=0; y < (ssize_t) image->rows; y++)
{
register IndexPacket
*magick_restrict indexes;
register ssize_t
x;
register PixelPacket
*magick_restrict q;
if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)
{
(void) ThrowMagickException(exception,GetMagickModule(),
CorruptImageWarning,""SkipToSyncByte"",""`%s'"",image->filename);
continue;
}
p=jpeg_pixels;
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (PixelPacket *) NULL)
break;
indexes=GetAuthenticIndexQueue(image);
if (jpeg_info.data_precision > 8)
{
unsigned short
scale;
scale=65535/(unsigned short) GetQuantumRange((size_t)
jpeg_info.data_precision);
if (jpeg_info.output_components == 1)
for (x=0; x < (ssize_t) image->columns; x++)
{
size_t
pixel;
pixel=(size_t) (scale*GETJSAMPLE(*p));
index=ConstrainColormapIndex(image,pixel);
SetPixelIndex(indexes+x,index);
SetPixelRGBO(q,image->colormap+(ssize_t) index);
p++;
q++;
}
else
if (image->colorspace != CMYKColorspace)
for (x=0; x < (ssize_t) image->columns; x++)
{
SetPixelRed(q,ScaleShortToQuantum((unsigned short)
(scale*GETJSAMPLE(*p++))));
SetPixelGreen(q,ScaleShortToQuantum((unsigned short)
(scale*GETJSAMPLE(*p++))));
SetPixelBlue(q,ScaleShortToQuantum((unsigned short)
(scale*GETJSAMPLE(*p++))));
SetPixelOpacity(q,OpaqueOpacity);
q++;
}
else
for (x=0; x < (ssize_t) image->columns; x++)
{
SetPixelCyan(q,QuantumRange-ScaleShortToQuantum(
(unsigned short) (scale*GETJSAMPLE(*p++))));
SetPixelMagenta(q,QuantumRange-ScaleShortToQuantum(
(unsigned short) (scale*GETJSAMPLE(*p++))));
SetPixelYellow(q,QuantumRange-ScaleShortToQuantum(
(unsigned short) (scale*GETJSAMPLE(*p++))));
SetPixelBlack(indexes+x,QuantumRange-ScaleShortToQuantum(
(unsigned short) (scale*GETJSAMPLE(*p++))));
SetPixelOpacity(q,OpaqueOpacity);
q++;
}
}
else
if (jpeg_info.output_components == 1)
for (x=0; x < (ssize_t) image->columns; x++)
{
index=ConstrainColormapIndex(image,(size_t) GETJSAMPLE(*p));
SetPixelIndex(indexes+x,index);
SetPixelRGBO(q,image->colormap+(ssize_t) index);
p++;
q++;
}
else
if (image->colorspace != CMYKColorspace)
for (x=0; x < (ssize_t) image->columns; x++)
{
SetPixelRed(q,ScaleCharToQuantum((unsigned char)
GETJSAMPLE(*p++)));
SetPixelGreen(q,ScaleCharToQuantum((unsigned char)
GETJSAMPLE(*p++)));
SetPixelBlue(q,ScaleCharToQuantum((unsigned char)
GETJSAMPLE(*p++)));
SetPixelOpacity(q,OpaqueOpacity);
q++;
}
else
for (x=0; x < (ssize_t) image->columns; x++)
{
SetPixelCyan(q,QuantumRange-ScaleCharToQuantum((unsigned char)
GETJSAMPLE(*p++)));
SetPixelMagenta(q,QuantumRange-ScaleCharToQuantum((unsigned char)
GETJSAMPLE(*p++)));
SetPixelYellow(q,QuantumRange-ScaleCharToQuantum((unsigned char)
GETJSAMPLE(*p++)));
SetPixelBlack(indexes+x,QuantumRange-ScaleCharToQuantum(
(unsigned char) GETJSAMPLE(*p++)));
SetPixelOpacity(q,OpaqueOpacity);
q++;
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
{
jpeg_abort_decompress(&jpeg_info);
break;
}
}
if (status != MagickFalse)
{
error_manager.finished=MagickTrue;
if (setjmp(error_manager.error_recovery) == 0)
(void) jpeg_finish_decompress(&jpeg_info);
}
jpeg_destroy_decompress(&jpeg_info);
memory_info=RelinquishVirtualMemory(memory_info);
(void) CloseBlob(image);
return(GetFirstImageInList(image));
}","static Image *ReadJPEGImage(const ImageInfo *VAR_0,
ExceptionInfo *VAR_1)
{
char
VAR_2[VAR_3];
const char
*VAR_4;
ErrorManager
VAR_5;
Image
*VAR_6;
IndexPacket
VAR_7;
JSAMPLE
*volatile VAR_8;
JSAMPROW
VAR_9[1];
MagickBooleanType
VAR_10,
VAR_11;
MagickSizeType
VAR_12;
MemoryInfo
*VAR_13;
register ssize_t
VAR_14;
struct jpeg_decompress_struct
VAR_15;
struct jpeg_error_mgr
VAR_16;
register JSAMPLE
*VAR_17;
size_t
VAR_18;
ssize_t
VAR_19;
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_20);
if (VAR_0->debug != VAR_21)
(void) LogMagickEvent(VAR_22,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_20);
VAR_10=IsEventLogging();
(void) VAR_10;
VAR_6=AcquireImage(VAR_0);
VAR_11=OpenBlob(VAR_0,VAR_6,VAR_23,VAR_1);
if (VAR_11 == VAR_21)
{
VAR_6=DestroyImageList(VAR_6);
return((Image *) NULL);
}
(void) ResetMagickMemory(&VAR_5,0,sizeof(VAR_5));
(void) ResetMagickMemory(&VAR_15,0,sizeof(VAR_15));
(void) ResetMagickMemory(&VAR_16,0,sizeof(VAR_16));
VAR_15.err=jpeg_std_error(&VAR_16);
VAR_15.err->emit_message=(void (*)(j_common_ptr,int)) VAR_24;
VAR_15.err->error_exit=(void (*)(j_common_ptr)) VAR_25;
VAR_13=(MemoryInfo *) NULL;
VAR_5.image=VAR_6;
if (setjmp(VAR_5.error_recovery) != 0)
{
jpeg_destroy_decompress(&VAR_15);
if (VAR_5.profile != (StringInfo *) NULL)
VAR_5.profile=DestroyStringInfo(VAR_5.profile);
(void) CloseBlob(VAR_6);
VAR_12=(MagickSizeType) VAR_6->columns*VAR_6->rows;
if (VAR_12 != 0)
return(GetFirstImageInList(VAR_6));
InheritException(VAR_1,&VAR_6->exception);
return(DestroyImage(VAR_6));
}
VAR_15.client_data=(void *) &VAR_5;
jpeg_create_decompress(&VAR_15);
JPEGSourceManager(&VAR_15,VAR_6);
jpeg_set_marker_processor(&VAR_15,VAR_26,VAR_27);
VAR_4=GetImageOption(VAR_0,""profile:skip"");
if (IsOptionMember(""ICC"",VAR_4) == VAR_21)
jpeg_set_marker_processor(&VAR_15,VAR_28,VAR_29);
if (IsOptionMember(""IPTC"",VAR_4) == VAR_21)
jpeg_set_marker_processor(&VAR_15,VAR_30,VAR_31);
for (VAR_14=1; VAR_14 < 16; VAR_14++)
if ((VAR_14 != 2) && (VAR_14 != 13) && (VAR_14 != 14))
if (IsOptionMember(""APP"",VAR_4) == VAR_21)
jpeg_set_marker_processor(&VAR_15,(int) (VAR_32+VAR_14),VAR_33);
VAR_14=(ssize_t) jpeg_read_header(&VAR_15,TRUE);
if ((VAR_0->colorspace == VAR_34) ||
(VAR_0->colorspace == VAR_35) ||
(VAR_0->colorspace == VAR_36))
VAR_15.out_color_space=VAR_37;
VAR_18=0;
if ((VAR_15.saw_JFIF_marker != 0) && (VAR_15.X_density != 1) &&
(VAR_15.Y_density != 1))
{
VAR_6->x_resolution=(double) VAR_15.X_density;
VAR_6->y_resolution=(double) VAR_15.Y_density;
VAR_18=(size_t) VAR_15.density_unit;
}
if (VAR_18 == 1)
VAR_6->units=VAR_38;
if (VAR_18 == 2)
VAR_6->units=VAR_39;
VAR_12=(MagickSizeType) VAR_6->columns*VAR_6->rows;
VAR_4=GetImageOption(VAR_0,""jpeg:size"");
if ((VAR_4 != (const char *) NULL) &&
(VAR_15.out_color_space != VAR_37))
{
double
VAR_40;
GeometryInfo
VAR_41;
MagickStatusType
VAR_42;
VAR_42=ParseGeometry(VAR_4,&VAR_41);
if ((VAR_42 & VAR_43) == 0)
VAR_41.sigma=VAR_41.rho;
jpeg_calc_output_dimensions(&VAR_15);
VAR_6->magick_columns=VAR_15.output_width;
VAR_6->magick_rows=VAR_15.output_height;
VAR_40=1.0;
if (VAR_41.rho != 0.0)
VAR_40=VAR_15.output_width/VAR_41.rho;
if ((VAR_41.sigma != 0.0) &&
(VAR_40 > (VAR_15.output_height/VAR_41.sigma)))
VAR_40=VAR_15.output_height/VAR_41.sigma;
VAR_15.scale_num=1U;
VAR_15.scale_denom=(unsigned int) VAR_40;
jpeg_calc_output_dimensions(&VAR_15);
if (VAR_6->debug != VAR_21)
(void) LogMagickEvent(VAR_44,GetMagickModule(),
""Scale factor: %.20g"",(double) VAR_40);
}
#if (VAR_45 >= 61) && defined(VAR_46)
#if defined(VAR_47)
VAR_6->interlace=VAR_15.process == VAR_48 ?
VAR_49 : VAR_50;
VAR_6->compression=VAR_15.process == VAR_51 ?
VAR_52 : VAR_53;
if (VAR_15.data_precision > 8)
(void) ThrowMagickException(VAR_1,GetMagickModule(),VAR_54,
""12-bit JPEG not supported. Reducing pixel data to 8 bits"",""`%s'"",
VAR_6->filename);
if (VAR_15.data_precision == 16)
VAR_15.data_precision=12;
#else
VAR_6->interlace=VAR_15.progressive_mode != 0 ? VAR_49 :
VAR_50;
VAR_6->compression=VAR_53;
#endif
#else
VAR_6->compression=VAR_53;
VAR_6->interlace=VAR_49;
#endif
VAR_4=GetImageOption(VAR_0,""jpeg:colors"");
if (VAR_4 != (const char *) NULL)
{
VAR_15.quantize_colors=TRUE;
VAR_15.desired_number_of_colors=(int) StringToUnsignedLong(VAR_4);
}
VAR_4=GetImageOption(VAR_0,""jpeg:block-smoothing"");
if (VAR_4 != (const char *) NULL)
VAR_15.do_block_smoothing=IsStringTrue(VAR_4) != VAR_21 ? TRUE :
FALSE;
VAR_15.dct_method=VAR_55;
VAR_4=GetImageOption(VAR_0,""jpeg:dct-method"");
if (VAR_4 != (const char *) NULL)
switch (*VAR_4)
{
case 'D':
case 'd':
{
if (LocaleCompare(VAR_4,""default"") == 0)
VAR_15.dct_method=VAR_56;
break;
}
case 'F':
case 'f':
{
if (LocaleCompare(VAR_4,""fastest"") == 0)
VAR_15.dct_method=VAR_57;
if (LocaleCompare(VAR_4,""float"") == 0)
VAR_15.dct_method=VAR_55;
break;
}
case 'I':
case 'i':
{
if (LocaleCompare(VAR_4,""ifast"") == 0)
VAR_15.dct_method=VAR_58;
if (LocaleCompare(VAR_4,""islow"") == 0)
VAR_15.dct_method=VAR_59;
break;
}
}
VAR_4=GetImageOption(VAR_0,""jpeg:fancy-upsampling"");
if (VAR_4 != (const char *) NULL)
VAR_15.do_fancy_upsampling=IsStringTrue(VAR_4) != VAR_21 ? TRUE :
FALSE;
(void) jpeg_start_decompress(&VAR_15);
VAR_6->columns=VAR_15.output_width;
VAR_6->rows=VAR_15.output_height;
VAR_6->depth=(size_t) VAR_15.data_precision;
switch (VAR_15.out_color_space)
{
case VAR_60:
default:
{
(void) SetImageColorspace(VAR_6,VAR_61);
break;
}
case VAR_62:
{
(void) SetImageColorspace(VAR_6,VAR_63);
break;
}
case VAR_37:
{
(void) SetImageColorspace(VAR_6,VAR_34);
break;
}
case VAR_64:
{
(void) SetImageColorspace(VAR_6,VAR_65);
break;
}
}
if (IsITUFaxImage(VAR_6) != VAR_21)
{
(void) SetImageColorspace(VAR_6,VAR_66);
VAR_15.out_color_space=VAR_37;
}
VAR_4=GetImageOption(VAR_0,""jpeg:colors"");
if (VAR_4 != (const char *) NULL)
if (AcquireImageColormap(VAR_6,StringToUnsignedLong(VAR_4)) == VAR_21)
{
InheritException(VAR_1,&VAR_6->exception);
return(DestroyImageList(VAR_6));
}
if ((VAR_15.output_components == 1) && (VAR_15.quantize_colors == 0))
{
size_t
VAR_67;
VAR_67=(size_t) GetQuantumRange(VAR_6->depth)+1;
if (AcquireImageColormap(VAR_6,VAR_67) == VAR_21)
{
InheritException(VAR_1,&VAR_6->exception);
return(DestroyImageList(VAR_6));
}
}
if (VAR_6->debug != VAR_21)
{
if (VAR_6->interlace != VAR_50)
(void) LogMagickEvent(VAR_44,GetMagickModule(),
""Interlace: progressive"");
else
(void) LogMagickEvent(VAR_44,GetMagickModule(),
""Interlace: nonprogressive"");
(void) LogMagickEvent(VAR_44,GetMagickModule(),""Data precision: %d"",
(int) VAR_15.data_precision);
(void) LogMagickEvent(VAR_44,GetMagickModule(),""Geometry: %dx%d"",
(int) VAR_15.output_width,(int) VAR_15.output_height);
}
JPEGSetImageQuality(&VAR_15,VAR_6);
JPEGSetImageSamplingFactor(&VAR_15,VAR_6);
(void) FormatLocaleString(VAR_2,VAR_3,""%.20g"",(double)
VAR_15.out_color_space);
(void) SetImageProperty(VAR_6,""jpeg:colorspace"",VAR_2);
if (VAR_0->ping != VAR_21)
{
jpeg_destroy_decompress(&VAR_15);
(void) CloseBlob(VAR_6);
return(GetFirstImageInList(VAR_6));
}
VAR_11=SetImageExtent(VAR_6,VAR_6->columns,VAR_6->rows);
if (VAR_11 == VAR_21)
{
jpeg_destroy_decompress(&VAR_15);
InheritException(VAR_1,&VAR_6->exception);
return(DestroyImageList(VAR_6));
}
if ((VAR_15.output_components != 1) &&
(VAR_15.output_components != 3) && (VAR_15.output_components != 4))
{
jpeg_destroy_decompress(&VAR_15);
ThrowReaderException(VAR_68,""ImageTypeNotSupported"");
}
VAR_13=AcquireVirtualMemory((size_t) VAR_6->columns,
VAR_15.output_components*sizeof(*VAR_8));
if (VAR_13 == (MemoryInfo *) NULL)
{
jpeg_destroy_decompress(&VAR_15);
ThrowReaderException(VAR_69,""MemoryAllocationFailed"");
}
VAR_8=(JSAMPLE *) GetVirtualMemoryBlob(VAR_13);
if (setjmp(VAR_5.error_recovery) != 0)
{
if (VAR_13 != (MemoryInfo *) NULL)
VAR_13=RelinquishVirtualMemory(VAR_13);
jpeg_destroy_decompress(&VAR_15);
(void) CloseBlob(VAR_6);
VAR_12=(MagickSizeType) VAR_6->columns*VAR_6->rows;
if (VAR_12 != 0)
return(GetFirstImageInList(VAR_6));
return(DestroyImage(VAR_6));
}
if (VAR_15.quantize_colors != 0)
{
VAR_6->colors=(size_t) VAR_15.actual_number_of_colors;
if (VAR_15.out_color_space == VAR_62)
for (VAR_14=0; VAR_14 < (ssize_t) VAR_6->colors; VAR_14++)
{
VAR_6->colormap[VAR_14].red=ScaleCharToQuantum(VAR_15.colormap[0][VAR_14]);
VAR_6->colormap[VAR_14].green=VAR_6->colormap[VAR_14].red;
VAR_6->colormap[VAR_14].blue=VAR_6->colormap[VAR_14].red;
VAR_6->colormap[VAR_14].opacity=VAR_70;
}
else
for (VAR_14=0; VAR_14 < (ssize_t) VAR_6->colors; VAR_14++)
{
VAR_6->colormap[VAR_14].red=ScaleCharToQuantum(VAR_15.colormap[0][VAR_14]);
VAR_6->colormap[VAR_14].green=ScaleCharToQuantum(VAR_15.colormap[1][VAR_14]);
VAR_6->colormap[VAR_14].blue=ScaleCharToQuantum(VAR_15.colormap[2][VAR_14]);
VAR_6->colormap[VAR_14].opacity=VAR_70;
}
}
VAR_9[0]=(JSAMPROW) VAR_8;
for (VAR_19=0; VAR_19 < (ssize_t) VAR_6->rows; VAR_19++)
{
register IndexPacket
*magick_restrict VAR_71;
register ssize_t
VAR_72;
register PixelPacket
*magick_restrict VAR_73;
if (jpeg_read_scanlines(&VAR_15,VAR_9,1) != 1)
{
(void) ThrowMagickException(VAR_1,GetMagickModule(),
VAR_74,""SkipToSyncByte"",""`%s'"",VAR_6->filename);
continue;
}
VAR_17=VAR_8;
VAR_73=QueueAuthenticPixels(VAR_6,0,VAR_19,VAR_6->columns,1,VAR_1);
if (VAR_73 == (PixelPacket *) NULL)
break;
VAR_71=GetAuthenticIndexQueue(VAR_6);
if (VAR_15.data_precision > 8)
{
unsigned short
VAR_75;
VAR_75=65535/(unsigned short) GetQuantumRange((size_t)
VAR_15.data_precision);
if (VAR_15.output_components == 1)
for (VAR_72=0; VAR_72 < (ssize_t) VAR_6->columns; VAR_72++)
{
size_t
VAR_76;
VAR_76=(size_t) (VAR_75*GETJSAMPLE(*VAR_17));
VAR_7=ConstrainColormapIndex(VAR_6,VAR_76);
SetPixelIndex(VAR_71+VAR_72,VAR_7);
SetPixelRGBO(VAR_73,VAR_6->colormap+(ssize_t) VAR_7);
VAR_17++;
VAR_73++;
}
else
if (VAR_6->colorspace != VAR_65)
for (VAR_72=0; VAR_72 < (ssize_t) VAR_6->columns; VAR_72++)
{
SetPixelRed(VAR_73,ScaleShortToQuantum((unsigned short)
(VAR_75*GETJSAMPLE(*VAR_17++))));
SetPixelGreen(VAR_73,ScaleShortToQuantum((unsigned short)
(VAR_75*GETJSAMPLE(*VAR_17++))));
SetPixelBlue(VAR_73,ScaleShortToQuantum((unsigned short)
(VAR_75*GETJSAMPLE(*VAR_17++))));
SetPixelOpacity(VAR_73,VAR_70);
VAR_73++;
}
else
for (VAR_72=0; VAR_72 < (ssize_t) VAR_6->columns; VAR_72++)
{
SetPixelCyan(VAR_73,VAR_77-ScaleShortToQuantum(
(unsigned short) (VAR_75*GETJSAMPLE(*VAR_17++))));
SetPixelMagenta(VAR_73,VAR_77-ScaleShortToQuantum(
(unsigned short) (VAR_75*GETJSAMPLE(*VAR_17++))));
SetPixelYellow(VAR_73,VAR_77-ScaleShortToQuantum(
(unsigned short) (VAR_75*GETJSAMPLE(*VAR_17++))));
SetPixelBlack(VAR_71+VAR_72,VAR_77-ScaleShortToQuantum(
(unsigned short) (VAR_75*GETJSAMPLE(*VAR_17++))));
SetPixelOpacity(VAR_73,VAR_70);
VAR_73++;
}
}
else
if (VAR_15.output_components == 1)
for (VAR_72=0; VAR_72 < (ssize_t) VAR_6->columns; VAR_72++)
{
VAR_7=ConstrainColormapIndex(VAR_6,(size_t) GETJSAMPLE(*VAR_17));
SetPixelIndex(VAR_71+VAR_72,VAR_7);
SetPixelRGBO(VAR_73,VAR_6->colormap+(ssize_t) VAR_7);
VAR_17++;
VAR_73++;
}
else
if (VAR_6->colorspace != VAR_65)
for (VAR_72=0; VAR_72 < (ssize_t) VAR_6->columns; VAR_72++)
{
SetPixelRed(VAR_73,ScaleCharToQuantum((unsigned char)
GETJSAMPLE(*VAR_17++)));
SetPixelGreen(VAR_73,ScaleCharToQuantum((unsigned char)
GETJSAMPLE(*VAR_17++)));
SetPixelBlue(VAR_73,ScaleCharToQuantum((unsigned char)
GETJSAMPLE(*VAR_17++)));
SetPixelOpacity(VAR_73,VAR_70);
VAR_73++;
}
else
for (VAR_72=0; VAR_72 < (ssize_t) VAR_6->columns; VAR_72++)
{
SetPixelCyan(VAR_73,VAR_77-ScaleCharToQuantum((unsigned char)
GETJSAMPLE(*VAR_17++)));
SetPixelMagenta(VAR_73,VAR_77-ScaleCharToQuantum((unsigned char)
GETJSAMPLE(*VAR_17++)));
SetPixelYellow(VAR_73,VAR_77-ScaleCharToQuantum((unsigned char)
GETJSAMPLE(*VAR_17++)));
SetPixelBlack(VAR_71+VAR_72,VAR_77-ScaleCharToQuantum(
(unsigned char) GETJSAMPLE(*VAR_17++)));
SetPixelOpacity(VAR_73,VAR_70);
VAR_73++;
}
if (SyncAuthenticPixels(VAR_6,VAR_1) == VAR_21)
break;
VAR_11=SetImageProgress(VAR_6,VAR_78,(MagickOffsetType) VAR_19,
VAR_6->rows);
if (VAR_11 == VAR_21)
{
jpeg_abort_decompress(&VAR_15);
break;
}
}
if (VAR_11 != VAR_21)
{
VAR_5.finished=VAR_79;
if (setjmp(VAR_5.error_recovery) == 0)
(void) jpeg_finish_decompress(&VAR_15);
}
jpeg_destroy_decompress(&VAR_15);
VAR_13=RelinquishVirtualMemory(VAR_13);
(void) CloseBlob(VAR_6);
return(GetFirstImageInList(VAR_6));
}",ImageMagick/948356eec65aea91995d4b7cc487d197d2c5f602/jpeg.c/vul/before/0.json,"static Image *ReadJPEGImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  char
    value[MaxTextExtent];

  const char
    *option;

  ErrorManager
    error_manager;

  Image
    *image;

  IndexPacket
    index;

  JSAMPLE
    *volatile jpeg_pixels;

  JSAMPROW
    scanline[1];

  MagickBooleanType
    debug,
    status;

  MagickSizeType
    number_pixels;

  MemoryInfo
    *memory_info;

  register ssize_t
    i;

  struct jpeg_decompress_struct
    jpeg_info;

  struct jpeg_error_mgr
    jpeg_error;

  register JSAMPLE
    *p;

  size_t
    units;

  ssize_t
    y;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  debug=IsEventLogging();
  (void) debug;
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Verify that file size large enough to contain a JPEG datastream.
  */
  if (GetBlobSize(image) < 107)
    ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
  /*
    Initialize JPEG parameters.
  */
  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));
  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));
  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));
  jpeg_info.err=jpeg_std_error(&jpeg_error);
  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;
  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;
  memory_info=(MemoryInfo *) NULL;
  error_manager.image=image;
  if (setjmp(error_manager.error_recovery) != 0)
    {
      jpeg_destroy_decompress(&jpeg_info);
      if (error_manager.profile != (StringInfo *) NULL)
        error_manager.profile=DestroyStringInfo(error_manager.profile);
      (void) CloseBlob(image);
      number_pixels=(MagickSizeType) image->columns*image->rows;
      if (number_pixels != 0)
        return(GetFirstImageInList(image));
      InheritException(exception,&image->exception);
      return(DestroyImage(image));
    }
  jpeg_info.client_data=(void *) &error_manager;
  jpeg_create_decompress(&jpeg_info);
  JPEGSourceManager(&jpeg_info,image);
  jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);
  option=GetImageOption(image_info,""profile:skip"");
  if (IsOptionMember(""ICC"",option) == MagickFalse)
    jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);
  if (IsOptionMember(""IPTC"",option) == MagickFalse)
    jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);
  for (i=1; i < 16; i++)
    if ((i != 2) && (i != 13) && (i != 14))
      if (IsOptionMember(""APP"",option) == MagickFalse)
        jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);
  i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);
  if ((image_info->colorspace == YCbCrColorspace) ||
      (image_info->colorspace == Rec601YCbCrColorspace) ||
      (image_info->colorspace == Rec709YCbCrColorspace))
    jpeg_info.out_color_space=JCS_YCbCr;
  /*
    Set image resolution.
  */
  units=0;
  if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&
      (jpeg_info.Y_density != 1))
    {
      image->x_resolution=(double) jpeg_info.X_density;
      image->y_resolution=(double) jpeg_info.Y_density;
      units=(size_t) jpeg_info.density_unit;
    }
  if (units == 1)
    image->units=PixelsPerInchResolution;
  if (units == 2)
    image->units=PixelsPerCentimeterResolution;
  number_pixels=(MagickSizeType) image->columns*image->rows;
  option=GetImageOption(image_info,""jpeg:size"");
  if ((option != (const char *) NULL) &&
      (jpeg_info.out_color_space != JCS_YCbCr))
    {
      double
        scale_factor;

      GeometryInfo
        geometry_info;

      MagickStatusType
        flags;

      /*
        Scale the image.
      */
      flags=ParseGeometry(option,&geometry_info);
      if ((flags & SigmaValue) == 0)
        geometry_info.sigma=geometry_info.rho;
      jpeg_calc_output_dimensions(&jpeg_info);
      image->magick_columns=jpeg_info.output_width;
      image->magick_rows=jpeg_info.output_height;
      scale_factor=1.0;
      if (geometry_info.rho != 0.0)
        scale_factor=jpeg_info.output_width/geometry_info.rho;
      if ((geometry_info.sigma != 0.0) &&
          (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))
        scale_factor=jpeg_info.output_height/geometry_info.sigma;
      jpeg_info.scale_num=1U;
      jpeg_info.scale_denom=(unsigned int) scale_factor;
      jpeg_calc_output_dimensions(&jpeg_info);
      if (image->debug != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""Scale factor: %.20g"",(double) scale_factor);
    }
#if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)
#if defined(D_LOSSLESS_SUPPORTED)
  image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?
    JPEGInterlace : NoInterlace;
  image->compression=jpeg_info.process == JPROC_LOSSLESS ?
    LosslessJPEGCompression : JPEGCompression;
  if (jpeg_info.data_precision > 8)
    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
      ""12-bit JPEG not supported. Reducing pixel data to 8 bits"",""`%s'"",
      image->filename);
  if (jpeg_info.data_precision == 16)
    jpeg_info.data_precision=12;
#else
  image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :
    NoInterlace;
  image->compression=JPEGCompression;
#endif
#else
  image->compression=JPEGCompression;
  image->interlace=JPEGInterlace;
#endif
  option=GetImageOption(image_info,""jpeg:colors"");
  if (option != (const char *) NULL)
    {
      /*
        Let the JPEG library quantize for us.
      */
      jpeg_info.quantize_colors=TRUE;
      jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);
    }
  option=GetImageOption(image_info,""jpeg:block-smoothing"");
  if (option != (const char *) NULL)
    jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :
      FALSE;
  jpeg_info.dct_method=JDCT_FLOAT;
  option=GetImageOption(image_info,""jpeg:dct-method"");
  if (option != (const char *) NULL)
    switch (*option)
    {
      case 'D':
      case 'd':
      {
        if (LocaleCompare(option,""default"") == 0)
          jpeg_info.dct_method=JDCT_DEFAULT;
        break;
      }
      case 'F':
      case 'f':
      {
        if (LocaleCompare(option,""fastest"") == 0)
          jpeg_info.dct_method=JDCT_FASTEST;
        if (LocaleCompare(option,""float"") == 0)
          jpeg_info.dct_method=JDCT_FLOAT;
        break;
      }
      case 'I':
      case 'i':
      {
        if (LocaleCompare(option,""ifast"") == 0)
          jpeg_info.dct_method=JDCT_IFAST;
        if (LocaleCompare(option,""islow"") == 0)
          jpeg_info.dct_method=JDCT_ISLOW;
        break;
      }
    }
  option=GetImageOption(image_info,""jpeg:fancy-upsampling"");
  if (option != (const char *) NULL)
    jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :
      FALSE;
  (void) jpeg_start_decompress(&jpeg_info);
  image->columns=jpeg_info.output_width;
  image->rows=jpeg_info.output_height;
  image->depth=(size_t) jpeg_info.data_precision;
  switch (jpeg_info.out_color_space)
  {
    case JCS_RGB:
    default:
    {
      (void) SetImageColorspace(image,sRGBColorspace);
      break;
    }
    case JCS_GRAYSCALE:
    {
      (void) SetImageColorspace(image,GRAYColorspace);
      break;
    }
    case JCS_YCbCr:
    {
      (void) SetImageColorspace(image,YCbCrColorspace);
      break;
    }
    case JCS_CMYK:
    {
      (void) SetImageColorspace(image,CMYKColorspace);
      break;
    }
  }
  if (IsITUFaxImage(image) != MagickFalse)
    {
      (void) SetImageColorspace(image,LabColorspace);
      jpeg_info.out_color_space=JCS_YCbCr;
    }
  option=GetImageOption(image_info,""jpeg:colors"");
  if (option != (const char *) NULL)
    if (AcquireImageColormap(image,StringToUnsignedLong(option)) == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
  if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))
    {
      size_t
        colors;

      colors=(size_t) GetQuantumRange(image->depth)+1;
      if (AcquireImageColormap(image,colors) == MagickFalse)
        {
          InheritException(exception,&image->exception);
          return(DestroyImageList(image));
        }
    }
  if (image->debug != MagickFalse)
    {
      if (image->interlace != NoInterlace)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""Interlace: progressive"");
      else
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""Interlace: nonprogressive"");
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Data precision: %d"",
        (int) jpeg_info.data_precision);
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Geometry: %dx%d"",
        (int) jpeg_info.output_width,(int) jpeg_info.output_height);
    }
  JPEGSetImageQuality(&jpeg_info,image);
  JPEGSetImageSamplingFactor(&jpeg_info,image);
  (void) FormatLocaleString(value,MaxTextExtent,""%.20g"",(double)
    jpeg_info.out_color_space);
  (void) SetImageProperty(image,""jpeg:colorspace"",value);
  if (image_info->ping != MagickFalse)
    {
      jpeg_destroy_decompress(&jpeg_info);
      (void) CloseBlob(image);
      return(GetFirstImageInList(image));
    }
  status=SetImageExtent(image,image->columns,image->rows);
  if (status == MagickFalse)
    {
      jpeg_destroy_decompress(&jpeg_info);
      InheritException(exception,&image->exception);
      return(DestroyImageList(image));
    }
  if ((jpeg_info.output_components != 1) &&
      (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))
    {
      jpeg_destroy_decompress(&jpeg_info);
      ThrowReaderException(CorruptImageError,""ImageTypeNotSupported"");
    }
  memory_info=AcquireVirtualMemory((size_t) image->columns,
    jpeg_info.output_components*sizeof(*jpeg_pixels));
  if (memory_info == (MemoryInfo *) NULL)
    {
      jpeg_destroy_decompress(&jpeg_info);
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    }
  jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);
  /*
    Convert JPEG pixels to pixel packets.
  */
  if (setjmp(error_manager.error_recovery) != 0)
    {
      if (memory_info != (MemoryInfo *) NULL)
        memory_info=RelinquishVirtualMemory(memory_info);
      jpeg_destroy_decompress(&jpeg_info);
      (void) CloseBlob(image);
      number_pixels=(MagickSizeType) image->columns*image->rows;
      if (number_pixels != 0)
        return(GetFirstImageInList(image));
      return(DestroyImage(image));
    }
  if (jpeg_info.quantize_colors != 0)
    {
      image->colors=(size_t) jpeg_info.actual_number_of_colors;
      if (jpeg_info.out_color_space == JCS_GRAYSCALE)
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);
          image->colormap[i].green=image->colormap[i].red;
          image->colormap[i].blue=image->colormap[i].red;
          image->colormap[i].opacity=OpaqueOpacity;
        }
      else
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);
          image->colormap[i].green=ScaleCharToQuantum(jpeg_info.colormap[1][i]);
          image->colormap[i].blue=ScaleCharToQuantum(jpeg_info.colormap[2][i]);
          image->colormap[i].opacity=OpaqueOpacity;
        }
    }
  scanline[0]=(JSAMPROW) jpeg_pixels;
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register IndexPacket
      *magick_restrict indexes;

    register ssize_t
      x;

    register PixelPacket
      *magick_restrict q;

    if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)
      {
        (void) ThrowMagickException(exception,GetMagickModule(),
          CorruptImageWarning,""SkipToSyncByte"",""`%s'"",image->filename);
        continue;
      }
    p=jpeg_pixels;
    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (PixelPacket *) NULL)
      break;
    indexes=GetAuthenticIndexQueue(image);
    if (jpeg_info.data_precision > 8)
      {
        unsigned short
          scale;

        scale=65535/(unsigned short) GetQuantumRange((size_t)
          jpeg_info.data_precision);
        if (jpeg_info.output_components == 1)
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            size_t
              pixel;

            pixel=(size_t) (scale*GETJSAMPLE(*p));
            index=ConstrainColormapIndex(image,pixel);
            SetPixelIndex(indexes+x,index);
            SetPixelRGBO(q,image->colormap+(ssize_t) index);
            p++;
            q++;
          }
        else
          if (image->colorspace != CMYKColorspace)
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelRed(q,ScaleShortToQuantum((unsigned short)
                (scale*GETJSAMPLE(*p++))));
              SetPixelGreen(q,ScaleShortToQuantum((unsigned short)
                (scale*GETJSAMPLE(*p++))));
              SetPixelBlue(q,ScaleShortToQuantum((unsigned short)
                (scale*GETJSAMPLE(*p++))));
              SetPixelOpacity(q,OpaqueOpacity);
              q++;
            }
          else
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelCyan(q,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelMagenta(q,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelYellow(q,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelBlack(indexes+x,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelOpacity(q,OpaqueOpacity);
              q++;
            }
      }
    else
      if (jpeg_info.output_components == 1)
        for (x=0; x < (ssize_t) image->columns; x++)
        {
          index=ConstrainColormapIndex(image,(size_t) GETJSAMPLE(*p));
          SetPixelIndex(indexes+x,index);
          SetPixelRGBO(q,image->colormap+(ssize_t) index);
          p++;
          q++;
        }
      else
        if (image->colorspace != CMYKColorspace)
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelRed(q,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelGreen(q,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelBlue(q,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelOpacity(q,OpaqueOpacity);
            q++;
          }
        else
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelCyan(q,QuantumRange-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelMagenta(q,QuantumRange-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelYellow(q,QuantumRange-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelBlack(indexes+x,QuantumRange-ScaleCharToQuantum(
              (unsigned char) GETJSAMPLE(*p++)));
            SetPixelOpacity(q,OpaqueOpacity);
            q++;
          }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
      image->rows);
    if (status == MagickFalse)
      {
        jpeg_abort_decompress(&jpeg_info);
        break;
      }
  }
  if (status != MagickFalse)
    {
      error_manager.finished=MagickTrue;
      if (setjmp(error_manager.error_recovery) == 0)
        (void) jpeg_finish_decompress(&jpeg_info);
    }
  /*
    Free jpeg resources.
  */
  jpeg_destroy_decompress(&jpeg_info);
  memory_info=RelinquishVirtualMemory(memory_info);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}","static Image *ReadJPEGImage(const ImageInfo *VAR_0,
  ExceptionInfo *VAR_1)
{
  char
    VAR_2[VAR_3];

  const char
    *VAR_4;

  ErrorManager
    VAR_5;

  Image
    *VAR_6;

  IndexPacket
    VAR_7;

  JSAMPLE
    *volatile VAR_8;

  JSAMPROW
    VAR_9[1];

  MagickBooleanType
    VAR_10,
    VAR_11;

  MagickSizeType
    VAR_12;

  MemoryInfo
    *VAR_13;

  register ssize_t
    VAR_14;

  struct jpeg_decompress_struct
    VAR_15;

  struct jpeg_error_mgr
    VAR_16;

  register JSAMPLE
    *VAR_17;

  size_t
    VAR_18;

  ssize_t
    VAR_19;

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_20);
  if (VAR_0->debug != VAR_21)
    (void) LogMagickEvent(VAR_22,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_20);
  VAR_10=IsEventLogging();
  (void) VAR_10;
  VAR_6=AcquireImage(VAR_0);
  VAR_11=OpenBlob(VAR_0,VAR_6,VAR_23,VAR_1);
  if (VAR_11 == VAR_21)
    {
      VAR_6=DestroyImageList(VAR_6);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                                                                    
    
  if (GetBlobSize(VAR_6) < 107)
    ThrowReaderException(VAR_24,""InsufficientImageDataInFile"");
  /* COMMENT_6 */
                               
    
  (void) ResetMagickMemory(&VAR_5,0,sizeof(VAR_5));
  (void) ResetMagickMemory(&VAR_15,0,sizeof(VAR_15));
  (void) ResetMagickMemory(&VAR_16,0,sizeof(VAR_16));
  VAR_15.err=jpeg_std_error(&VAR_16);
  VAR_15.err->emit_message=(void (*)(j_common_ptr,int)) VAR_25;
  VAR_15.err->error_exit=(void (*)(j_common_ptr)) VAR_26;
  VAR_13=(MemoryInfo *) NULL;
  VAR_5.image=VAR_6;
  if (setjmp(VAR_5.error_recovery) != 0)
    {
      jpeg_destroy_decompress(&VAR_15);
      if (VAR_5.profile != (StringInfo *) NULL)
        VAR_5.profile=DestroyStringInfo(VAR_5.profile);
      (void) CloseBlob(VAR_6);
      VAR_12=(MagickSizeType) VAR_6->columns*VAR_6->rows;
      if (VAR_12 != 0)
        return(GetFirstImageInList(VAR_6));
      InheritException(VAR_1,&VAR_6->exception);
      return(DestroyImage(VAR_6));
    }
  VAR_15.client_data=(void *) &VAR_5;
  jpeg_create_decompress(&VAR_15);
  JPEGSourceManager(&VAR_15,VAR_6);
  jpeg_set_marker_processor(&VAR_15,VAR_27,VAR_28);
  VAR_4=GetImageOption(VAR_0,""profile:skip"");
  if (IsOptionMember(""ICC"",VAR_4) == VAR_21)
    jpeg_set_marker_processor(&VAR_15,VAR_29,VAR_30);
  if (IsOptionMember(""IPTC"",VAR_4) == VAR_21)
    jpeg_set_marker_processor(&VAR_15,VAR_31,VAR_32);
  for (VAR_14=1; VAR_14 < 16; VAR_14++)
    if ((VAR_14 != 2) && (VAR_14 != 13) && (VAR_14 != 14))
      if (IsOptionMember(""APP"",VAR_4) == VAR_21)
        jpeg_set_marker_processor(&VAR_15,(int) (VAR_33+VAR_14),VAR_34);
  VAR_14=(ssize_t) jpeg_read_header(&VAR_15,TRUE);
  if ((VAR_0->colorspace == VAR_35) ||
      (VAR_0->colorspace == VAR_36) ||
      (VAR_0->colorspace == VAR_37))
    VAR_15.out_color_space=VAR_38;
  /* COMMENT_9 */
                         
    
  VAR_18=0;
  if ((VAR_15.saw_JFIF_marker != 0) && (VAR_15.X_density != 1) &&
      (VAR_15.Y_density != 1))
    {
      VAR_6->x_resolution=(double) VAR_15.X_density;
      VAR_6->y_resolution=(double) VAR_15.Y_density;
      VAR_18=(size_t) VAR_15.density_unit;
    }
  if (VAR_18 == 1)
    VAR_6->units=VAR_39;
  if (VAR_18 == 2)
    VAR_6->units=VAR_40;
  VAR_12=(MagickSizeType) VAR_6->columns*VAR_6->rows;
  VAR_4=GetImageOption(VAR_0,""jpeg:size"");
  if ((VAR_4 != (const char *) NULL) &&
      (VAR_15.out_color_space != VAR_38))
    {
      double
        VAR_41;

      GeometryInfo
        VAR_42;

      MagickStatusType
        VAR_43;

      /* COMMENT_12 */
                        
        
      VAR_43=ParseGeometry(VAR_4,&VAR_42);
      if ((VAR_43 & VAR_44) == 0)
        VAR_42.sigma=VAR_42.rho;
      jpeg_calc_output_dimensions(&VAR_15);
      VAR_6->magick_columns=VAR_15.output_width;
      VAR_6->magick_rows=VAR_15.output_height;
      VAR_41=1.0;
      if (VAR_42.rho != 0.0)
        VAR_41=VAR_15.output_width/VAR_42.rho;
      if ((VAR_42.sigma != 0.0) &&
          (VAR_41 > (VAR_15.output_height/VAR_42.sigma)))
        VAR_41=VAR_15.output_height/VAR_42.sigma;
      VAR_15.scale_num=1U;
      VAR_15.scale_denom=(unsigned int) VAR_41;
      jpeg_calc_output_dimensions(&VAR_15);
      if (VAR_6->debug != VAR_21)
        (void) LogMagickEvent(VAR_45,GetMagickModule(),
          ""Scale factor: %.20g"",(double) VAR_41);
    }
#if (VAR_46 >= 61) && defined(VAR_47)
#if defined(VAR_48)
  VAR_6->interlace=VAR_15.process == VAR_49 ?
    VAR_50 : VAR_51;
  VAR_6->compression=VAR_15.process == VAR_52 ?
    VAR_53 : VAR_54;
  if (VAR_15.data_precision > 8)
    (void) ThrowMagickException(VAR_1,GetMagickModule(),VAR_55,
      ""12-bit JPEG not supported. Reducing pixel data to 8 bits"",""`%s'"",
      VAR_6->filename);
  if (VAR_15.data_precision == 16)
    VAR_15.data_precision=12;
#else
  VAR_6->interlace=VAR_15.progressive_mode != 0 ? VAR_50 :
    VAR_51;
  VAR_6->compression=VAR_54;
#endif
#else
  VAR_6->compression=VAR_54;
  VAR_6->interlace=VAR_50;
#endif
  VAR_4=GetImageOption(VAR_0,""jpeg:colors"");
  if (VAR_4 != (const char *) NULL)
    {
      /* COMMENT_15 */
                                             
        
      VAR_15.quantize_colors=TRUE;
      VAR_15.desired_number_of_colors=(int) StringToUnsignedLong(VAR_4);
    }
  VAR_4=GetImageOption(VAR_0,""jpeg:block-smoothing"");
  if (VAR_4 != (const char *) NULL)
    VAR_15.do_block_smoothing=IsStringTrue(VAR_4) != VAR_21 ? TRUE :
      FALSE;
  VAR_15.dct_method=VAR_56;
  VAR_4=GetImageOption(VAR_0,""jpeg:dct-method"");
  if (VAR_4 != (const char *) NULL)
    switch (*VAR_4)
    {
      case 'D':
      case 'd':
      {
        if (LocaleCompare(VAR_4,""default"") == 0)
          VAR_15.dct_method=VAR_57;
        break;
      }
      case 'F':
      case 'f':
      {
        if (LocaleCompare(VAR_4,""fastest"") == 0)
          VAR_15.dct_method=VAR_58;
        if (LocaleCompare(VAR_4,""float"") == 0)
          VAR_15.dct_method=VAR_56;
        break;
      }
      case 'I':
      case 'i':
      {
        if (LocaleCompare(VAR_4,""ifast"") == 0)
          VAR_15.dct_method=VAR_59;
        if (LocaleCompare(VAR_4,""islow"") == 0)
          VAR_15.dct_method=VAR_60;
        break;
      }
    }
  VAR_4=GetImageOption(VAR_0,""jpeg:fancy-upsampling"");
  if (VAR_4 != (const char *) NULL)
    VAR_15.do_fancy_upsampling=IsStringTrue(VAR_4) != VAR_21 ? TRUE :
      FALSE;
  (void) jpeg_start_decompress(&VAR_15);
  VAR_6->columns=VAR_15.output_width;
  VAR_6->rows=VAR_15.output_height;
  VAR_6->depth=(size_t) VAR_15.data_precision;
  switch (VAR_15.out_color_space)
  {
    case VAR_61:
    default:
    {
      (void) SetImageColorspace(VAR_6,VAR_62);
      break;
    }
    case VAR_63:
    {
      (void) SetImageColorspace(VAR_6,VAR_64);
      break;
    }
    case VAR_38:
    {
      (void) SetImageColorspace(VAR_6,VAR_35);
      break;
    }
    case VAR_65:
    {
      (void) SetImageColorspace(VAR_6,VAR_66);
      break;
    }
  }
  if (IsITUFaxImage(VAR_6) != VAR_21)
    {
      (void) SetImageColorspace(VAR_6,VAR_67);
      VAR_15.out_color_space=VAR_38;
    }
  VAR_4=GetImageOption(VAR_0,""jpeg:colors"");
  if (VAR_4 != (const char *) NULL)
    if (AcquireImageColormap(VAR_6,StringToUnsignedLong(VAR_4)) == VAR_21)
      {
        InheritException(VAR_1,&VAR_6->exception);
        return(DestroyImageList(VAR_6));
      }
  if ((VAR_15.output_components == 1) && (VAR_15.quantize_colors == 0))
    {
      size_t
        VAR_68;

      VAR_68=(size_t) GetQuantumRange(VAR_6->depth)+1;
      if (AcquireImageColormap(VAR_6,VAR_68) == VAR_21)
        {
          InheritException(VAR_1,&VAR_6->exception);
          return(DestroyImageList(VAR_6));
        }
    }
  if (VAR_6->debug != VAR_21)
    {
      if (VAR_6->interlace != VAR_51)
        (void) LogMagickEvent(VAR_45,GetMagickModule(),
          ""Interlace: progressive"");
      else
        (void) LogMagickEvent(VAR_45,GetMagickModule(),
          ""Interlace: nonprogressive"");
      (void) LogMagickEvent(VAR_45,GetMagickModule(),""Data precision: %d"",
        (int) VAR_15.data_precision);
      (void) LogMagickEvent(VAR_45,GetMagickModule(),""Geometry: %dx%d"",
        (int) VAR_15.output_width,(int) VAR_15.output_height);
    }
  JPEGSetImageQuality(&VAR_15,VAR_6);
  JPEGSetImageSamplingFactor(&VAR_15,VAR_6);
  (void) FormatLocaleString(VAR_2,VAR_3,""%.20g"",(double)
    VAR_15.out_color_space);
  (void) SetImageProperty(VAR_6,""jpeg:colorspace"",VAR_2);
  if (VAR_0->ping != VAR_21)
    {
      jpeg_destroy_decompress(&VAR_15);
      (void) CloseBlob(VAR_6);
      return(GetFirstImageInList(VAR_6));
    }
  VAR_11=SetImageExtent(VAR_6,VAR_6->columns,VAR_6->rows);
  if (VAR_11 == VAR_21)
    {
      jpeg_destroy_decompress(&VAR_15);
      InheritException(VAR_1,&VAR_6->exception);
      return(DestroyImageList(VAR_6));
    }
  if ((VAR_15.output_components != 1) &&
      (VAR_15.output_components != 3) && (VAR_15.output_components != 4))
    {
      jpeg_destroy_decompress(&VAR_15);
      ThrowReaderException(VAR_24,""ImageTypeNotSupported"");
    }
  VAR_13=AcquireVirtualMemory((size_t) VAR_6->columns,
    VAR_15.output_components*sizeof(*VAR_8));
  if (VAR_13 == (MemoryInfo *) NULL)
    {
      jpeg_destroy_decompress(&VAR_15);
      ThrowReaderException(VAR_69,""MemoryAllocationFailed"");
    }
  VAR_8=(JSAMPLE *) GetVirtualMemoryBlob(VAR_13);
  /* COMMENT_18 */
                                         
    
  if (setjmp(VAR_5.error_recovery) != 0)
    {
      if (VAR_13 != (MemoryInfo *) NULL)
        VAR_13=RelinquishVirtualMemory(VAR_13);
      jpeg_destroy_decompress(&VAR_15);
      (void) CloseBlob(VAR_6);
      VAR_12=(MagickSizeType) VAR_6->columns*VAR_6->rows;
      if (VAR_12 != 0)
        return(GetFirstImageInList(VAR_6));
      return(DestroyImage(VAR_6));
    }
  if (VAR_15.quantize_colors != 0)
    {
      VAR_6->colors=(size_t) VAR_15.actual_number_of_colors;
      if (VAR_15.out_color_space == VAR_63)
        for (VAR_14=0; VAR_14 < (ssize_t) VAR_6->colors; VAR_14++)
        {
          VAR_6->colormap[VAR_14].red=ScaleCharToQuantum(VAR_15.colormap[0][VAR_14]);
          VAR_6->colormap[VAR_14].green=VAR_6->colormap[VAR_14].red;
          VAR_6->colormap[VAR_14].blue=VAR_6->colormap[VAR_14].red;
          VAR_6->colormap[VAR_14].opacity=VAR_70;
        }
      else
        for (VAR_14=0; VAR_14 < (ssize_t) VAR_6->colors; VAR_14++)
        {
          VAR_6->colormap[VAR_14].red=ScaleCharToQuantum(VAR_15.colormap[0][VAR_14]);
          VAR_6->colormap[VAR_14].green=ScaleCharToQuantum(VAR_15.colormap[1][VAR_14]);
          VAR_6->colormap[VAR_14].blue=ScaleCharToQuantum(VAR_15.colormap[2][VAR_14]);
          VAR_6->colormap[VAR_14].opacity=VAR_70;
        }
    }
  VAR_9[0]=(JSAMPROW) VAR_8;
  for (VAR_19=0; VAR_19 < (ssize_t) VAR_6->rows; VAR_19++)
  {
    register IndexPacket
      *magick_restrict VAR_71;

    register ssize_t
      VAR_72;

    register PixelPacket
      *magick_restrict VAR_73;

    if (jpeg_read_scanlines(&VAR_15,VAR_9,1) != 1)
      {
        (void) ThrowMagickException(VAR_1,GetMagickModule(),
          VAR_74,""SkipToSyncByte"",""`%s'"",VAR_6->filename);
        continue;
      }
    VAR_17=VAR_8;
    VAR_73=QueueAuthenticPixels(VAR_6,0,VAR_19,VAR_6->columns,1,VAR_1);
    if (VAR_73 == (PixelPacket *) NULL)
      break;
    VAR_71=GetAuthenticIndexQueue(VAR_6);
    if (VAR_15.data_precision > 8)
      {
        unsigned short
          VAR_75;

        VAR_75=65535/(unsigned short) GetQuantumRange((size_t)
          VAR_15.data_precision);
        if (VAR_15.output_components == 1)
          for (VAR_72=0; VAR_72 < (ssize_t) VAR_6->columns; VAR_72++)
          {
            size_t
              VAR_76;

            VAR_76=(size_t) (VAR_75*GETJSAMPLE(*VAR_17));
            VAR_7=ConstrainColormapIndex(VAR_6,VAR_76);
            SetPixelIndex(VAR_71+VAR_72,VAR_7);
            SetPixelRGBO(VAR_73,VAR_6->colormap+(ssize_t) VAR_7);
            VAR_17++;
            VAR_73++;
          }
        else
          if (VAR_6->colorspace != VAR_66)
            for (VAR_72=0; VAR_72 < (ssize_t) VAR_6->columns; VAR_72++)
            {
              SetPixelRed(VAR_73,ScaleShortToQuantum((unsigned short)
                (VAR_75*GETJSAMPLE(*VAR_17++))));
              SetPixelGreen(VAR_73,ScaleShortToQuantum((unsigned short)
                (VAR_75*GETJSAMPLE(*VAR_17++))));
              SetPixelBlue(VAR_73,ScaleShortToQuantum((unsigned short)
                (VAR_75*GETJSAMPLE(*VAR_17++))));
              SetPixelOpacity(VAR_73,VAR_70);
              VAR_73++;
            }
          else
            for (VAR_72=0; VAR_72 < (ssize_t) VAR_6->columns; VAR_72++)
            {
              SetPixelCyan(VAR_73,VAR_77-ScaleShortToQuantum(
                (unsigned short) (VAR_75*GETJSAMPLE(*VAR_17++))));
              SetPixelMagenta(VAR_73,VAR_77-ScaleShortToQuantum(
                (unsigned short) (VAR_75*GETJSAMPLE(*VAR_17++))));
              SetPixelYellow(VAR_73,VAR_77-ScaleShortToQuantum(
                (unsigned short) (VAR_75*GETJSAMPLE(*VAR_17++))));
              SetPixelBlack(VAR_71+VAR_72,VAR_77-ScaleShortToQuantum(
                (unsigned short) (VAR_75*GETJSAMPLE(*VAR_17++))));
              SetPixelOpacity(VAR_73,VAR_70);
              VAR_73++;
            }
      }
    else
      if (VAR_15.output_components == 1)
        for (VAR_72=0; VAR_72 < (ssize_t) VAR_6->columns; VAR_72++)
        {
          VAR_7=ConstrainColormapIndex(VAR_6,(size_t) GETJSAMPLE(*VAR_17));
          SetPixelIndex(VAR_71+VAR_72,VAR_7);
          SetPixelRGBO(VAR_73,VAR_6->colormap+(ssize_t) VAR_7);
          VAR_17++;
          VAR_73++;
        }
      else
        if (VAR_6->colorspace != VAR_66)
          for (VAR_72=0; VAR_72 < (ssize_t) VAR_6->columns; VAR_72++)
          {
            SetPixelRed(VAR_73,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*VAR_17++)));
            SetPixelGreen(VAR_73,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*VAR_17++)));
            SetPixelBlue(VAR_73,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*VAR_17++)));
            SetPixelOpacity(VAR_73,VAR_70);
            VAR_73++;
          }
        else
          for (VAR_72=0; VAR_72 < (ssize_t) VAR_6->columns; VAR_72++)
          {
            SetPixelCyan(VAR_73,VAR_77-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*VAR_17++)));
            SetPixelMagenta(VAR_73,VAR_77-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*VAR_17++)));
            SetPixelYellow(VAR_73,VAR_77-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*VAR_17++)));
            SetPixelBlack(VAR_71+VAR_72,VAR_77-ScaleCharToQuantum(
              (unsigned char) GETJSAMPLE(*VAR_17++)));
            SetPixelOpacity(VAR_73,VAR_70);
            VAR_73++;
          }
    if (SyncAuthenticPixels(VAR_6,VAR_1) == VAR_21)
      break;
    VAR_11=SetImageProgress(VAR_6,VAR_78,(MagickOffsetType) VAR_19,
      VAR_6->rows);
    if (VAR_11 == VAR_21)
      {
        jpeg_abort_decompress(&VAR_15);
        break;
      }
  }
  if (VAR_11 != VAR_21)
    {
      VAR_5.finished=VAR_79;
      if (setjmp(VAR_5.error_recovery) == 0)
        (void) jpeg_finish_decompress(&VAR_15);
    }
  /* COMMENT_21 */
                        
    
  jpeg_destroy_decompress(&VAR_15);
  VAR_13=RelinquishVirtualMemory(VAR_13);
  (void) CloseBlob(VAR_6);
  return(GetFirstImageInList(VAR_6));
}",ImageMagick/948356eec65aea91995d4b7cc487d197d2c5f602/jpeg.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -69,6 +69,11 @@
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
+  /*
+    Verify that file size large enough to contain a JPEG datastream.
+  */
+  if (GetBlobSize(image) < 107)
+    ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
   /*
     Initialize JPEG parameters.
   */","{'deleted_lines': [], 'added_lines': ['  /*', '    Verify that file size large enough to contain a JPEG datastream.', '  */', '  if (GetBlobSize(image) < 107)', '    ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");']}",True,coders/jpeg.c in ImageMagick before 7.0.6-1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via JPEG data that is too short.,8.8,HIGH,2,test,2017-07-03T00:38:07Z,1
CVE-2017-11450,['CWE-Other'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ImageMagick,...,948356eec65aea91995d4b7cc487d197d2c5f602,https://github.com/ImageMagick/ImageMagick/commit/948356eec65aea91995d4b7cc487d197d2c5f602,coders/jpeg.c,RegisterJPEGImage,"ModuleExport size_t RegisterJPEGImage(void)
{
char
version[MaxTextExtent];
MagickInfo
*entry;
static const char
description[] = ""Joint Photographic Experts Group JFIF format"";
*version='\0';
#if defined(JPEG_LIB_VERSION)
(void) FormatLocaleString(version,MaxTextExtent,""%d"",JPEG_LIB_VERSION);
#endif
entry=SetMagickInfo(""JPE"");
#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)
entry->thread_support=NoThreadSupport;
#endif
#if defined(MAGICKCORE_JPEG_DELEGATE)
entry->decoder=(DecodeImageHandler *) ReadJPEGImage;
entry->encoder=(EncodeImageHandler *) WriteJPEGImage;
#endif
entry->magick=(IsImageFormatHandler *) IsJPEG;
entry->adjoin=MagickFalse;
entry->description=ConstantString(description);
if (*version != '\0')
entry->version=ConstantString(version);
entry->mime_type=ConstantString(""image/jpeg"");
entry->module=ConstantString(""JPEG"");
(void) RegisterMagickInfo(entry);
entry=SetMagickInfo(""JPEG"");
#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)
entry->thread_support=NoThreadSupport;
#endif
#if defined(MAGICKCORE_JPEG_DELEGATE)
entry->decoder=(DecodeImageHandler *) ReadJPEGImage;
entry->encoder=(EncodeImageHandler *) WriteJPEGImage;
#endif
entry->magick=(IsImageFormatHandler *) IsJPEG;
entry->adjoin=MagickFalse;
entry->description=ConstantString(description);
if (*version != '\0')
entry->version=ConstantString(version);
entry->mime_type=ConstantString(""image/jpeg"");
entry->module=ConstantString(""JPEG"");
(void) RegisterMagickInfo(entry);
entry=SetMagickInfo(""JPG"");
#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)
entry->thread_support=NoThreadSupport;
#endif
#if defined(MAGICKCORE_JPEG_DELEGATE)
entry->decoder=(DecodeImageHandler *) ReadJPEGImage;
entry->encoder=(EncodeImageHandler *) WriteJPEGImage;
#endif
entry->adjoin=MagickFalse;
entry->description=ConstantString(description);
if (*version != '\0')
entry->version=ConstantString(version);
entry->mime_type=ConstantString(""image/jpeg"");
entry->module=ConstantString(""JPEG"");
(void) RegisterMagickInfo(entry);
entry=SetMagickInfo(""JPS"");
#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)
entry->thread_support=NoThreadSupport;
#endif
#if defined(MAGICKCORE_JPEG_DELEGATE)
entry->decoder=(DecodeImageHandler *) ReadJPEGImage;
entry->encoder=(EncodeImageHandler *) WriteJPEGImage;
#endif
entry->adjoin=MagickFalse;
entry->description=ConstantString(description);
if (*version != '\0')
entry->version=ConstantString(version);
entry->mime_type=ConstantString(""image/jpeg"");
entry->module=ConstantString(""JPEG"");
(void) RegisterMagickInfo(entry);
entry=SetMagickInfo(""PJPEG"");
#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)
entry->thread_support=NoThreadSupport;
#endif
#if defined(MAGICKCORE_JPEG_DELEGATE)
entry->decoder=(DecodeImageHandler *) ReadJPEGImage;
entry->encoder=(EncodeImageHandler *) WriteJPEGImage;
#endif
entry->adjoin=MagickFalse;
entry->description=ConstantString(description);
if (*version != '\0')
entry->version=ConstantString(version);
entry->mime_type=ConstantString(""image/jpeg"");
entry->module=ConstantString(""JPEG"");
(void) RegisterMagickInfo(entry);
return(MagickImageCoderSignature);
}","ModuleExport VAR_0 RegisterJPEGImage(void)
{
char
VAR_1[VAR_2];
MagickInfo
*VAR_3;
static const char
VAR_4[] = ""Joint Photographic Experts Group JFIF format"";
*VAR_1='\0';
#if defined(VAR_5)
(void) FormatLocaleString(VAR_1,VAR_2,""%d"",VAR_5);
#endif
VAR_3=SetMagickInfo(""JPE"");
#if (VAR_5 < 80) && !defined(VAR_6)
VAR_3->thread_support=VAR_7;
#endif
#if defined(VAR_8)
VAR_3->decoder=(DecodeImageHandler *) VAR_9;
VAR_3->encoder=(EncodeImageHandler *) VAR_10;
#endif
VAR_3->magick=(IsImageFormatHandler *) VAR_11;
VAR_3->adjoin=VAR_12;
VAR_3->description=ConstantString(VAR_4);
if (*VAR_1 != '\0')
VAR_3->version=ConstantString(VAR_1);
VAR_3->mime_type=ConstantString(""image/jpeg"");
VAR_3->module=ConstantString(""JPEG"");
(void) RegisterMagickInfo(VAR_3);
VAR_3=SetMagickInfo(""JPEG"");
#if (VAR_5 < 80) && !defined(VAR_6)
VAR_3->thread_support=VAR_7;
#endif
#if defined(VAR_8)
VAR_3->decoder=(DecodeImageHandler *) VAR_9;
VAR_3->encoder=(EncodeImageHandler *) VAR_10;
#endif
VAR_3->magick=(IsImageFormatHandler *) VAR_11;
VAR_3->adjoin=VAR_12;
VAR_3->description=ConstantString(VAR_4);
if (*VAR_1 != '\0')
VAR_3->version=ConstantString(VAR_1);
VAR_3->mime_type=ConstantString(""image/jpeg"");
VAR_3->module=ConstantString(""JPEG"");
(void) RegisterMagickInfo(VAR_3);
VAR_3=SetMagickInfo(""JPG"");
#if (VAR_5 < 80) && !defined(VAR_6)
VAR_3->thread_support=VAR_7;
#endif
#if defined(VAR_8)
VAR_3->decoder=(DecodeImageHandler *) VAR_9;
VAR_3->encoder=(EncodeImageHandler *) VAR_10;
#endif
VAR_3->adjoin=VAR_12;
VAR_3->description=ConstantString(VAR_4);
if (*VAR_1 != '\0')
VAR_3->version=ConstantString(VAR_1);
VAR_3->mime_type=ConstantString(""image/jpeg"");
VAR_3->module=ConstantString(""JPEG"");
(void) RegisterMagickInfo(VAR_3);
VAR_3=SetMagickInfo(""JPS"");
#if (VAR_5 < 80) && !defined(VAR_6)
VAR_3->thread_support=VAR_7;
#endif
#if defined(VAR_8)
VAR_3->decoder=(DecodeImageHandler *) VAR_9;
VAR_3->encoder=(EncodeImageHandler *) VAR_10;
#endif
VAR_3->adjoin=VAR_12;
VAR_3->description=ConstantString(VAR_4);
if (*VAR_1 != '\0')
VAR_3->version=ConstantString(VAR_1);
VAR_3->mime_type=ConstantString(""image/jpeg"");
VAR_3->module=ConstantString(""JPEG"");
(void) RegisterMagickInfo(VAR_3);
VAR_3=SetMagickInfo(""PJPEG"");
#if (VAR_5 < 80) && !defined(VAR_6)
VAR_3->thread_support=VAR_7;
#endif
#if defined(VAR_8)
VAR_3->decoder=(DecodeImageHandler *) VAR_9;
VAR_3->encoder=(EncodeImageHandler *) VAR_10;
#endif
VAR_3->adjoin=VAR_12;
VAR_3->description=ConstantString(VAR_4);
if (*VAR_1 != '\0')
VAR_3->version=ConstantString(VAR_1);
VAR_3->mime_type=ConstantString(""image/jpeg"");
VAR_3->module=ConstantString(""JPEG"");
(void) RegisterMagickInfo(VAR_3);
return(VAR_13);
}",,"ModuleExport size_t RegisterJPEGImage(void)
{
  char
    version[MaxTextExtent];

  MagickInfo
    *entry;

  static const char
    description[] = ""Joint Photographic Experts Group JFIF format"";

  *version='\0';
#if defined(JPEG_LIB_VERSION)
  (void) FormatLocaleString(version,MaxTextExtent,""%d"",JPEG_LIB_VERSION);
#endif
  entry=SetMagickInfo(""JPE"");
#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)
  entry->thread_support=NoThreadSupport;
#endif
#if defined(MAGICKCORE_JPEG_DELEGATE)
  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;
  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;
#endif
  entry->magick=(IsImageFormatHandler *) IsJPEG;
  entry->adjoin=MagickFalse;
  entry->seekable_stream=MagickTrue;
  entry->description=ConstantString(description);
  if (*version != '\0')
    entry->version=ConstantString(version);
  entry->mime_type=ConstantString(""image/jpeg"");
  entry->module=ConstantString(""JPEG"");
  (void) RegisterMagickInfo(entry);
  entry=SetMagickInfo(""JPEG"");
#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)
  entry->thread_support=NoThreadSupport;
#endif
#if defined(MAGICKCORE_JPEG_DELEGATE)
  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;
  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;
#endif
  entry->magick=(IsImageFormatHandler *) IsJPEG;
  entry->adjoin=MagickFalse;
  entry->seekable_stream=MagickTrue;
  entry->description=ConstantString(description);
  if (*version != '\0')
    entry->version=ConstantString(version);
  entry->mime_type=ConstantString(""image/jpeg"");
  entry->module=ConstantString(""JPEG"");
  (void) RegisterMagickInfo(entry);
  entry=SetMagickInfo(""JPG"");
#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)
  entry->thread_support=NoThreadSupport;
#endif
#if defined(MAGICKCORE_JPEG_DELEGATE)
  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;
  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;
#endif
  entry->adjoin=MagickFalse;
  entry->seekable_stream=MagickTrue;
  entry->description=ConstantString(description);
  if (*version != '\0')
    entry->version=ConstantString(version);
  entry->mime_type=ConstantString(""image/jpeg"");
  entry->module=ConstantString(""JPEG"");
  (void) RegisterMagickInfo(entry);
  entry=SetMagickInfo(""JPS"");
#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)
  entry->thread_support=NoThreadSupport;
#endif
#if defined(MAGICKCORE_JPEG_DELEGATE)
  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;
  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;
#endif
  entry->adjoin=MagickFalse;
  entry->seekable_stream=MagickTrue;
  entry->description=ConstantString(description);
  if (*version != '\0')
    entry->version=ConstantString(version);
  entry->mime_type=ConstantString(""image/jpeg"");
  entry->module=ConstantString(""JPEG"");
  (void) RegisterMagickInfo(entry);
  entry=SetMagickInfo(""PJPEG"");
#if (JPEG_LIB_VERSION < 80) && !defined(LIBJPEG_TURBO_VERSION)
  entry->thread_support=NoThreadSupport;
#endif
#if defined(MAGICKCORE_JPEG_DELEGATE)
  entry->decoder=(DecodeImageHandler *) ReadJPEGImage;
  entry->encoder=(EncodeImageHandler *) WriteJPEGImage;
#endif
  entry->adjoin=MagickFalse;
  entry->seekable_stream=MagickTrue;
  entry->description=ConstantString(description);
  if (*version != '\0')
    entry->version=ConstantString(version);
  entry->mime_type=ConstantString(""image/jpeg"");
  entry->module=ConstantString(""JPEG"");
  (void) RegisterMagickInfo(entry);
  return(MagickImageCoderSignature);
}","ModuleExport VAR_0 RegisterJPEGImage(void)
{
  char
    VAR_1[VAR_2];

  MagickInfo
    *VAR_3;

  static const char
    VAR_4[] = ""Joint Photographic Experts Group JFIF format"";

  *VAR_1='\0';
#if defined(VAR_5)
  (void) FormatLocaleString(VAR_1,VAR_2,""%d"",VAR_5);
#endif
  VAR_3=SetMagickInfo(""JPE"");
#if (VAR_5 < 80) && !defined(VAR_6)
  VAR_3->thread_support=VAR_7;
#endif
#if defined(VAR_8)
  VAR_3->decoder=(DecodeImageHandler *) VAR_9;
  VAR_3->encoder=(EncodeImageHandler *) VAR_10;
#endif
  VAR_3->magick=(IsImageFormatHandler *) VAR_11;
  VAR_3->adjoin=VAR_12;
  VAR_3->seekable_stream=VAR_13;
  VAR_3->description=ConstantString(VAR_4);
  if (*VAR_1 != '\0')
    VAR_3->version=ConstantString(VAR_1);
  VAR_3->mime_type=ConstantString(""image/jpeg"");
  VAR_3->module=ConstantString(""JPEG"");
  (void) RegisterMagickInfo(VAR_3);
  VAR_3=SetMagickInfo(""JPEG"");
#if (VAR_5 < 80) && !defined(VAR_6)
  VAR_3->thread_support=VAR_7;
#endif
#if defined(VAR_8)
  VAR_3->decoder=(DecodeImageHandler *) VAR_9;
  VAR_3->encoder=(EncodeImageHandler *) VAR_10;
#endif
  VAR_3->magick=(IsImageFormatHandler *) VAR_11;
  VAR_3->adjoin=VAR_12;
  VAR_3->seekable_stream=VAR_13;
  VAR_3->description=ConstantString(VAR_4);
  if (*VAR_1 != '\0')
    VAR_3->version=ConstantString(VAR_1);
  VAR_3->mime_type=ConstantString(""image/jpeg"");
  VAR_3->module=ConstantString(""JPEG"");
  (void) RegisterMagickInfo(VAR_3);
  VAR_3=SetMagickInfo(""JPG"");
#if (VAR_5 < 80) && !defined(VAR_6)
  VAR_3->thread_support=VAR_7;
#endif
#if defined(VAR_8)
  VAR_3->decoder=(DecodeImageHandler *) VAR_9;
  VAR_3->encoder=(EncodeImageHandler *) VAR_10;
#endif
  VAR_3->adjoin=VAR_12;
  VAR_3->seekable_stream=VAR_13;
  VAR_3->description=ConstantString(VAR_4);
  if (*VAR_1 != '\0')
    VAR_3->version=ConstantString(VAR_1);
  VAR_3->mime_type=ConstantString(""image/jpeg"");
  VAR_3->module=ConstantString(""JPEG"");
  (void) RegisterMagickInfo(VAR_3);
  VAR_3=SetMagickInfo(""JPS"");
#if (VAR_5 < 80) && !defined(VAR_6)
  VAR_3->thread_support=VAR_7;
#endif
#if defined(VAR_8)
  VAR_3->decoder=(DecodeImageHandler *) VAR_9;
  VAR_3->encoder=(EncodeImageHandler *) VAR_10;
#endif
  VAR_3->adjoin=VAR_12;
  VAR_3->seekable_stream=VAR_13;
  VAR_3->description=ConstantString(VAR_4);
  if (*VAR_1 != '\0')
    VAR_3->version=ConstantString(VAR_1);
  VAR_3->mime_type=ConstantString(""image/jpeg"");
  VAR_3->module=ConstantString(""JPEG"");
  (void) RegisterMagickInfo(VAR_3);
  VAR_3=SetMagickInfo(""PJPEG"");
#if (VAR_5 < 80) && !defined(VAR_6)
  VAR_3->thread_support=VAR_7;
#endif
#if defined(VAR_8)
  VAR_3->decoder=(DecodeImageHandler *) VAR_9;
  VAR_3->encoder=(EncodeImageHandler *) VAR_10;
#endif
  VAR_3->adjoin=VAR_12;
  VAR_3->seekable_stream=VAR_13;
  VAR_3->description=ConstantString(VAR_4);
  if (*VAR_1 != '\0')
    VAR_3->version=ConstantString(VAR_1);
  VAR_3->mime_type=ConstantString(""image/jpeg"");
  VAR_3->module=ConstantString(""JPEG"");
  (void) RegisterMagickInfo(VAR_3);
  return(VAR_14);
}",,"--- func_before
+++ func_after
@@ -23,6 +23,7 @@
 #endif
   entry->magick=(IsImageFormatHandler *) IsJPEG;
   entry->adjoin=MagickFalse;
+  entry->seekable_stream=MagickTrue;
   entry->description=ConstantString(description);
   if (*version != '\0')
     entry->version=ConstantString(version);
@@ -39,6 +40,7 @@
 #endif
   entry->magick=(IsImageFormatHandler *) IsJPEG;
   entry->adjoin=MagickFalse;
+  entry->seekable_stream=MagickTrue;
   entry->description=ConstantString(description);
   if (*version != '\0')
     entry->version=ConstantString(version);
@@ -54,6 +56,7 @@
   entry->encoder=(EncodeImageHandler *) WriteJPEGImage;
 #endif
   entry->adjoin=MagickFalse;
+  entry->seekable_stream=MagickTrue;
   entry->description=ConstantString(description);
   if (*version != '\0')
     entry->version=ConstantString(version);
@@ -69,6 +72,7 @@
   entry->encoder=(EncodeImageHandler *) WriteJPEGImage;
 #endif
   entry->adjoin=MagickFalse;
+  entry->seekable_stream=MagickTrue;
   entry->description=ConstantString(description);
   if (*version != '\0')
     entry->version=ConstantString(version);
@@ -84,6 +88,7 @@
   entry->encoder=(EncodeImageHandler *) WriteJPEGImage;
 #endif
   entry->adjoin=MagickFalse;
+  entry->seekable_stream=MagickTrue;
   entry->description=ConstantString(description);
   if (*version != '\0')
     entry->version=ConstantString(version);","{'deleted_lines': [], 'added_lines': ['  entry->seekable_stream=MagickTrue;', '  entry->seekable_stream=MagickTrue;', '  entry->seekable_stream=MagickTrue;', '  entry->seekable_stream=MagickTrue;', '  entry->seekable_stream=MagickTrue;']}",True,coders/jpeg.c in ImageMagick before 7.0.6-1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via JPEG data that is too short.,8.8,HIGH,2,test,2017-07-03T00:38:07Z,1
CVE-2017-11446,['CWE-835'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,ImageMagick,https://github.com/ImageMagick/ImageMagick/issues/537,787ee25e9fb0e4e0509121342371d925fe5044f8,https://github.com/ImageMagick/ImageMagick/commit/787ee25e9fb0e4e0509121342371d925fe5044f8,coders/pes.c,ReadPESImage,"static Image *ReadPESImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
char
filename[MagickPathExtent];
FILE
*file;
Image
*image;
ImageInfo
*read_info;
int
delta_x,
delta_y,
j,
unique_file,
x,
y;
MagickBooleanType
status;
PESBlockInfo
blocks[256];
PointInfo
*stitches;
SegmentInfo
bounds;
register ssize_t
i;
size_t
number_blocks,
number_colors,
number_stitches;
ssize_t
count,
offset;
unsigned char
magick[4],
version[4];
assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
image=AcquireImage(image_info,exception);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
count=ReadBlob(image,4,magick);
if ((count != 4) || (LocaleNCompare((char *) magick,""#PES"",4) != 0))
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
count=ReadBlob(image,4,version);
offset=ReadBlobLSBSignedLong(image);
if (DiscardBlobBytes(image,offset+36) == MagickFalse)
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
if (EOFBlob(image) != MagickFalse)
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
number_colors=(size_t) ReadBlobByte(image)+1;
for (i=0; i < (ssize_t) number_colors; i++)
{
j=ReadBlobByte(image);
blocks[i].color=PESColor+(j < 0 ? 0 : j);
blocks[i].offset=0;
}
for ( ; i < 256L; i++)
{
blocks[i].offset=0;
blocks[i].color=PESColor;
}
if (DiscardBlobBytes(image,532L-number_colors-21) == MagickFalse)
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
if (EOFBlob(image) != MagickFalse)
ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
number_stitches=64;
stitches=(PointInfo *) AcquireQuantumMemory(number_stitches,
sizeof(*stitches));
if (stitches == (PointInfo *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
bounds.x1=65535.0;
bounds.y1=65535.0;
bounds.x2=(-65535.0);
bounds.y2=(-65535.0);
i=0;
j=0;
delta_x=0;
delta_y=0;
while (EOFBlob(image) != EOF)
{
x=ReadBlobByte(image);
y=ReadBlobByte(image);
if ((x == 0xff) && (y == 0))
break;
if ((x == 254) && (y == 176))
{
j++;
blocks[j].offset=(ssize_t) i;
if (j >= 256)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
(void) ReadBlobByte(image);
continue;
}
if ((x & 0x80) == 0)
{
if ((x & 0x40) != 0)
x-=0x80;
}
else
{
x=((x & 0x0f) << 8)+y;
if ((x & 0x800) != 0)
x-=0x1000;
y=ReadBlobByte(image);
}
if ((y & 0x80) == 0)
{
if ((y & 0x40) != 0)
y-=0x80;
}
else
{
y=((y & 0x0f) << 8)+ReadBlobByte(image);
if ((y & 0x800) != 0)
y-=0x1000;
}
x+=delta_x;
y+=delta_y;
delta_x=x;
delta_y=y;
stitches[i].x=(double) x;
stitches[i].y=(double) y;
if ((double) x < bounds.x1)
bounds.x1=(double) x;
if ((double) x > bounds.x2)
bounds.x2=(double) x;
if ((double) y < bounds.y1)
bounds.y1=(double) y;
if ((double) y > bounds.y2)
bounds.y2=(double) y;
i++;
if (i >= (ssize_t) number_stitches)
{
number_stitches<<=1;
stitches=(PointInfo *)  ResizeQuantumMemory(stitches,(size_t)
number_stitches,sizeof(*stitches));
if (stitches == (PointInfo *) NULL)
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
}
}
j++;
blocks[j].offset=(ssize_t) i;
number_blocks=(size_t) j;
file=(FILE *) NULL;
unique_file=AcquireUniqueFileResource(filename);
if (unique_file != -1)
file=fdopen(unique_file,""wb"");
if ((unique_file == -1) || (file == (FILE *) NULL))
ThrowImageException(FileOpenError,""UnableToCreateTemporaryFile"");
(void) FormatLocaleFile(file,""<?xml version=\""1.0\""?>\n"");
(void) FormatLocaleFile(file,""<svg xmlns=\""http:    ""xlink=\""http:    ""ev=\""http:    ""baseProfile=\""full\"" width=\""%g\"" height=\""%g\"">\n"",bounds.x2-bounds.x1,
bounds.y2-bounds.y1);
for (i=0; i < (ssize_t) number_blocks; i++)
{
offset=blocks[i].offset;
(void) FormatLocaleFile(file,""  <path stroke=\""#%02x%02x%02x\"" ""
""fill=\""none\"" d=\""M %g %g"",blocks[i].color->red,blocks[i].color->green,
blocks[i].color->blue,stitches[offset].x-bounds.x1,
stitches[offset].y-bounds.y1);
for (j=1; j < (ssize_t) (blocks[i+1].offset-offset); j++)
(void) FormatLocaleFile(file,"" L %g %g"",stitches[offset+j].x-bounds.x1,
stitches[offset+j].y-bounds.y1);
(void) FormatLocaleFile(file,""\""/>\n"");
}
(void) FormatLocaleFile(file,""</svg>\n"");
(void) fclose(file);
(void) CloseBlob(image);
image=DestroyImage(image);
read_info=CloneImageInfo(image_info);
SetImageInfoBlob(read_info,(void *) NULL,0);
(void) FormatLocaleString(read_info->filename,MagickPathExtent,""svg:%s"",
filename);
image=ReadImage(read_info,exception);
if (image != (Image *) NULL)
{
(void) CopyMagickString(image->filename,image_info->filename,
MagickPathExtent);
(void) CopyMagickString(image->magick_filename,image_info->filename,
MagickPathExtent);
(void) CopyMagickString(image->magick,""PES"",MagickPathExtent);
}
read_info=DestroyImageInfo(read_info);
(void) RelinquishUniqueFileResource(filename);
return(GetFirstImageInList(image));
}","static Image *ReadPESImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
char
VAR_2[VAR_3];
FILE
*VAR_4;
Image
*VAR_5;
ImageInfo
*VAR_6;
int
VAR_7,
VAR_8,
VAR_9,
VAR_10,
VAR_11,
VAR_12;
MagickBooleanType
VAR_13;
PESBlockInfo
VAR_14[256];
PointInfo
*VAR_15;
SegmentInfo
VAR_16;
register ssize_t
VAR_17;
size_t
VAR_18,
VAR_19,
VAR_20;
ssize_t
VAR_21,
VAR_22;
unsigned char
VAR_23[4],
VAR_24[4];
assert(VAR_0 != (const ImageInfo *) NULL);
assert(VAR_0->signature == VAR_25);
if (VAR_0->debug != VAR_26)
(void) LogMagickEvent(VAR_27,GetMagickModule(),""%s"",
VAR_0->filename);
assert(VAR_1 != (ExceptionInfo *) NULL);
assert(VAR_1->signature == VAR_25);
VAR_5=AcquireImage(VAR_0,VAR_1);
VAR_13=OpenBlob(VAR_0,VAR_5,VAR_28,VAR_1);
if (VAR_13 == VAR_26)
{
VAR_5=DestroyImageList(VAR_5);
return((Image *) NULL);
}
VAR_21=ReadBlob(VAR_5,4,VAR_23);
if ((VAR_21 != 4) || (LocaleNCompare((char *) VAR_23,""#PES"",4) != 0))
ThrowReaderException(VAR_29,""ImproperImageHeader"");
VAR_21=ReadBlob(VAR_5,4,VAR_24);
VAR_22=ReadBlobLSBSignedLong(VAR_5);
if (DiscardBlobBytes(VAR_5,VAR_22+36) == VAR_26)
ThrowFileException(VAR_1,VAR_29,""UnexpectedEndOfFile"",
VAR_5->filename);
if (EOFBlob(VAR_5) != VAR_26)
ThrowReaderException(VAR_29,""UnexpectedEndOfFile"");
VAR_19=(size_t) ReadBlobByte(VAR_5)+1;
for (VAR_17=0; VAR_17 < (ssize_t) VAR_19; VAR_17++)
{
VAR_9=ReadBlobByte(VAR_5);
VAR_14[VAR_17].color=VAR_30+(VAR_9 < 0 ? 0 : VAR_9);
VAR_14[VAR_17].offset=0;
}
for ( ; VAR_17 < 256L; VAR_17++)
{
VAR_14[VAR_17].offset=0;
VAR_14[VAR_17].color=VAR_30;
}
if (DiscardBlobBytes(VAR_5,532L-VAR_19-21) == VAR_26)
ThrowFileException(VAR_1,VAR_29,""UnexpectedEndOfFile"",
VAR_5->filename);
if (EOFBlob(VAR_5) != VAR_26)
ThrowReaderException(VAR_29,""UnexpectedEndOfFile"");
VAR_20=64;
VAR_15=(PointInfo *) AcquireQuantumMemory(VAR_20,
sizeof(*VAR_15));
if (VAR_15 == (PointInfo *) NULL)
ThrowReaderException(VAR_31,""MemoryAllocationFailed"");
VAR_16.x1=65535.0;
VAR_16.y1=65535.0;
VAR_16.x2=(-65535.0);
VAR_16.y2=(-65535.0);
VAR_17=0;
VAR_9=0;
VAR_7=0;
VAR_8=0;
while (EOFBlob(VAR_5) != VAR_32)
{
VAR_11=ReadBlobByte(VAR_5);
VAR_12=ReadBlobByte(VAR_5);
if ((VAR_11 == 0xff) && (VAR_12 == 0))
break;
if ((VAR_11 == 254) && (VAR_12 == 176))
{
VAR_9++;
VAR_14[VAR_9].offset=(ssize_t) VAR_17;
if (VAR_9 >= 256)
ThrowReaderException(VAR_31,""MemoryAllocationFailed"");
(void) ReadBlobByte(VAR_5);
continue;
}
if ((VAR_11 & 0x80) == 0)
{
if ((VAR_11 & 0x40) != 0)
VAR_11-=0x80;
}
else
{
VAR_11=((VAR_11 & 0x0f) << 8)+VAR_12;
if ((VAR_11 & 0x800) != 0)
VAR_11-=0x1000;
VAR_12=ReadBlobByte(VAR_5);
}
if ((VAR_12 & 0x80) == 0)
{
if ((VAR_12 & 0x40) != 0)
VAR_12-=0x80;
}
else
{
VAR_12=((VAR_12 & 0x0f) << 8)+ReadBlobByte(VAR_5);
if ((VAR_12 & 0x800) != 0)
VAR_12-=0x1000;
}
VAR_11+=VAR_7;
VAR_12+=VAR_8;
VAR_7=VAR_11;
VAR_8=VAR_12;
VAR_15[VAR_17].x=(double) VAR_11;
VAR_15[VAR_17].y=(double) VAR_12;
if ((double) VAR_11 < VAR_16.x1)
VAR_16.x1=(double) VAR_11;
if ((double) VAR_11 > VAR_16.x2)
VAR_16.x2=(double) VAR_11;
if ((double) VAR_12 < VAR_16.y1)
VAR_16.y1=(double) VAR_12;
if ((double) VAR_12 > VAR_16.y2)
VAR_16.y2=(double) VAR_12;
VAR_17++;
if (VAR_17 >= (ssize_t) VAR_20)
{
VAR_20<<=1;
VAR_15=(PointInfo *)  ResizeQuantumMemory(VAR_15,(size_t)
VAR_20,sizeof(*VAR_15));
if (VAR_15 == (PointInfo *) NULL)
ThrowReaderException(VAR_31,""MemoryAllocationFailed"");
}
}
VAR_9++;
VAR_14[VAR_9].offset=(ssize_t) VAR_17;
VAR_18=(size_t) VAR_9;
VAR_4=(FILE *) NULL;
VAR_10=AcquireUniqueFileResource(VAR_2);
if (VAR_10 != -1)
VAR_4=fdopen(VAR_10,""wb"");
if ((VAR_10 == -1) || (VAR_4 == (FILE *) NULL))
ThrowImageException(VAR_33,""UnableToCreateTemporaryFile"");
(void) FormatLocaleFile(VAR_4,""<?xml version=\""1.0\""?>\n"");
(void) FormatLocaleFile(VAR_4,""<svg xmlns=\""http://www.w3.org/2000/svg\"" ""
""xlink=\""http://www.w3.org/1999/xlink\"" ""
""ev=\""http://www.w3.org/2001/xml-events\"" version=\""1.1\"" ""
""baseProfile=\""full\"" width=\""%g\"" height=\""%g\"">\n"",VAR_16.x2-VAR_16.x1,
VAR_16.y2-VAR_16.y1);
for (VAR_17=0; VAR_17 < (ssize_t) VAR_18; VAR_17++)
{
VAR_22=VAR_14[VAR_17].offset;
(void) FormatLocaleFile(VAR_4,""  <path stroke=\""#%02x%02x%02x\"" ""
""fill=\""none\"" d=\""M %g %g"",VAR_14[VAR_17].color->red,VAR_14[VAR_17].color->green,
VAR_14[VAR_17].color->blue,VAR_15[VAR_22].x-VAR_16.x1,
VAR_15[VAR_22].y-VAR_16.y1);
for (VAR_9=1; VAR_9 < (ssize_t) (VAR_14[VAR_17+1].offset-VAR_22); VAR_9++)
(void) FormatLocaleFile(VAR_4,"" L %g %g"",VAR_15[VAR_22+VAR_9].x-VAR_16.x1,
VAR_15[VAR_22+VAR_9].y-VAR_16.y1);
(void) FormatLocaleFile(VAR_4,""\""/>\n"");
}
(void) FormatLocaleFile(VAR_4,""</svg>\n"");
(void) fclose(VAR_4);
(void) CloseBlob(VAR_5);
VAR_5=DestroyImage(VAR_5);
VAR_6=CloneImageInfo(VAR_0);
SetImageInfoBlob(VAR_6,(void *) NULL,0);
(void) FormatLocaleString(VAR_6->filename,VAR_3,""svg:%s"",
VAR_2);
VAR_5=ReadImage(VAR_6,VAR_1);
if (VAR_5 != (Image *) NULL)
{
(void) CopyMagickString(VAR_5->filename,VAR_0->filename,
VAR_3);
(void) CopyMagickString(VAR_5->magick_filename,VAR_0->filename,
VAR_3);
(void) CopyMagickString(VAR_5->magick,""PES"",VAR_3);
}
VAR_6=DestroyImageInfo(VAR_6);
(void) RelinquishUniqueFileResource(VAR_2);
return(GetFirstImageInList(VAR_5));
}",ImageMagick/787ee25e9fb0e4e0509121342371d925fe5044f8/pes.c/vul/before/0.json,"static Image *ReadPESImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  char
    filename[MagickPathExtent];

  FILE
    *file;

  Image
    *image;

  ImageInfo
    *read_info;

  int
    delta_x,
    delta_y,
    j,
    unique_file,
    x,
    y;

  MagickBooleanType
    status;

  PESBlockInfo
    blocks[256];

  PointInfo
    *stitches;

  SegmentInfo
    bounds;

  register ssize_t
    i;

  size_t
    number_blocks,
    number_colors,
    number_stitches;

  ssize_t
    count,
    offset;

  unsigned char
    magick[4],
    version[4];

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  /*
    Verify PES identifier.
  */
  count=ReadBlob(image,4,magick);
  if ((count != 4) || (LocaleNCompare((char *) magick,""#PES"",4) != 0))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  count=ReadBlob(image,4,version);
  offset=ReadBlobLSBSignedLong(image);
  if (DiscardBlobBytes(image,offset+36) == MagickFalse)
    ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
      image->filename);
  if (EOFBlob(image) != MagickFalse)
    ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
  /*
    Get PES colors.
  */
  number_colors=(size_t) ReadBlobByte(image)+1;
  for (i=0; i < (ssize_t) number_colors; i++)
  {
    j=ReadBlobByte(image);
    blocks[i].color=PESColor+(j < 0 ? 0 : j);
    blocks[i].offset=0;
  }
  for ( ; i < 256L; i++)
  {
    blocks[i].offset=0;
    blocks[i].color=PESColor;
  }
  if (DiscardBlobBytes(image,532L-number_colors-21) == MagickFalse)
    ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
      image->filename);
  if (EOFBlob(image) != MagickFalse)
    ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
  /*
    Stitch away.
  */
  number_stitches=64;
  stitches=(PointInfo *) AcquireQuantumMemory(number_stitches,
    sizeof(*stitches));
  if (stitches == (PointInfo *) NULL)
    ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
  bounds.x1=65535.0;
  bounds.y1=65535.0;
  bounds.x2=(-65535.0);
  bounds.y2=(-65535.0);
  i=0;
  j=0;
  delta_x=0;
  delta_y=0;
  while (EOFBlob(image) == MagickFalse)
  {
    x=ReadBlobByte(image);
    y=ReadBlobByte(image);
    if ((x == 0xff) && (y == 0))
      break;
    if ((x == 254) && (y == 176))
      {
        /*
          Start a new stitch block.
        */
        j++;
        blocks[j].offset=(ssize_t) i;
        if (j >= 256)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        (void) ReadBlobByte(image);
        continue;
      }
    if ((x & 0x80) == 0)
      {
        /*
          Normal stitch.
        */
        if ((x & 0x40) != 0)
          x-=0x80;
      }
    else
      {
        /*
          Jump stitch.
        */
        x=((x & 0x0f) << 8)+y;
        if ((x & 0x800) != 0)
          x-=0x1000;
        y=ReadBlobByte(image);
      }
    if ((y & 0x80) == 0)
      {
        /*
          Normal stitch.
        */
        if ((y & 0x40) != 0)
          y-=0x80;
      }
    else
      {
        /*
          Jump stitch.
        */
        y=((y & 0x0f) << 8)+ReadBlobByte(image);
        if ((y & 0x800) != 0)
          y-=0x1000;
      }
    /*
      Note stitch (x,y).
    */
    x+=delta_x;
    y+=delta_y;
    delta_x=x;
    delta_y=y;
    stitches[i].x=(double) x;
    stitches[i].y=(double) y;
    if ((double) x < bounds.x1)
      bounds.x1=(double) x;
    if ((double) x > bounds.x2)
      bounds.x2=(double) x;
    if ((double) y < bounds.y1)
      bounds.y1=(double) y;
    if ((double) y > bounds.y2)
      bounds.y2=(double) y;
    i++;
    if (i >= (ssize_t) number_stitches)
      {
        /*
          Make room for more stitches.
        */
        number_stitches<<=1;
        stitches=(PointInfo *)  ResizeQuantumMemory(stitches,(size_t)
          number_stitches,sizeof(*stitches));
        if (stitches == (PointInfo *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     }
  }
  j++;
  blocks[j].offset=(ssize_t) i;
  number_blocks=(size_t) j;
  image->columns=bounds.x2-bounds.x1;
  image->rows=bounds.y2-bounds.y1;
  status=SetImageExtent(image,image->columns,image->rows,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  /*
    Write stitches as SVG file.
  */
  file=(FILE *) NULL;
  unique_file=AcquireUniqueFileResource(filename);
  if (unique_file != -1)
    file=fdopen(unique_file,""wb"");
  if ((unique_file == -1) || (file == (FILE *) NULL))
    ThrowImageException(FileOpenError,""UnableToCreateTemporaryFile"");
  (void) FormatLocaleFile(file,""<?xml version=\""1.0\""?>\n"");
  (void) FormatLocaleFile(file,""<svg xmlns=\""http://www.w3.org/2000/svg\"" ""
    ""xlink=\""http://www.w3.org/1999/xlink\"" ""
    ""ev=\""http://www.w3.org/2001/xml-events\"" version=\""1.1\"" ""
    ""baseProfile=\""full\"" width=\""%g\"" height=\""%g\"">\n"",(double)
    image->columns,(double) image->rows);
  for (i=0; i < (ssize_t) number_blocks; i++)
  {
    offset=blocks[i].offset;
    (void) FormatLocaleFile(file,""  <path stroke=\""#%02x%02x%02x\"" ""
      ""fill=\""none\"" d=\""M %g %g"",blocks[i].color->red,blocks[i].color->green,
      blocks[i].color->blue,stitches[offset].x-bounds.x1,
      stitches[offset].y-bounds.y1);
    for (j=1; j < (ssize_t) (blocks[i+1].offset-offset); j++)
      (void) FormatLocaleFile(file,"" L %g %g"",stitches[offset+j].x-bounds.x1,
        stitches[offset+j].y-bounds.y1);
    (void) FormatLocaleFile(file,""\""/>\n"");
  }
  (void) FormatLocaleFile(file,""</svg>\n"");
  (void) fclose(file);
  (void) CloseBlob(image);
  image=DestroyImage(image);
  /*
    Read SVG file.
  */
  read_info=CloneImageInfo(image_info);
  SetImageInfoBlob(read_info,(void *) NULL,0);
  (void) FormatLocaleString(read_info->filename,MagickPathExtent,""svg:%s"",
    filename);
  image=ReadImage(read_info,exception);
  if (image != (Image *) NULL)
    {
      (void) CopyMagickString(image->filename,image_info->filename,
        MagickPathExtent);
      (void) CopyMagickString(image->magick_filename,image_info->filename,
        MagickPathExtent);
      (void) CopyMagickString(image->magick,""PES"",MagickPathExtent);
    }
  read_info=DestroyImageInfo(read_info);
  (void) RelinquishUniqueFileResource(filename);
  return(GetFirstImageInList(image));
}","static Image *ReadPESImage(const ImageInfo *VAR_0,ExceptionInfo *VAR_1)
{
  char
    VAR_2[VAR_3];

  FILE
    *VAR_4;

  Image
    *VAR_5;

  ImageInfo
    *VAR_6;

  int
    VAR_7,
    VAR_8,
    VAR_9,
    VAR_10,
    VAR_11,
    VAR_12;

  MagickBooleanType
    VAR_13;

  PESBlockInfo
    VAR_14[256];

  PointInfo
    *VAR_15;

  SegmentInfo
    VAR_16;

  register ssize_t
    VAR_17;

  size_t
    VAR_18,
    VAR_19,
    VAR_20;

  ssize_t
    VAR_21,
    VAR_22;

  unsigned char
    VAR_23[4],
    VAR_24[4];

  /* COMMENT_0 */
                    
    
  assert(VAR_0 != (const ImageInfo *) NULL);
  assert(VAR_0->signature == VAR_25);
  if (VAR_0->debug != VAR_26)
    (void) LogMagickEvent(VAR_27,GetMagickModule(),""%s"",
      VAR_0->filename);
  assert(VAR_1 != (ExceptionInfo *) NULL);
  assert(VAR_1->signature == VAR_25);
  VAR_5=AcquireImage(VAR_0,VAR_1);
  VAR_13=OpenBlob(VAR_0,VAR_5,VAR_28,VAR_1);
  if (VAR_13 == VAR_26)
    {
      VAR_5=DestroyImageList(VAR_5);
      return((Image *) NULL);
    }
  /* COMMENT_3 */
                          
    
  VAR_21=ReadBlob(VAR_5,4,VAR_23);
  if ((VAR_21 != 4) || (LocaleNCompare((char *) VAR_23,""#PES"",4) != 0))
    ThrowReaderException(VAR_29,""ImproperImageHeader"");
  VAR_21=ReadBlob(VAR_5,4,VAR_24);
  VAR_22=ReadBlobLSBSignedLong(VAR_5);
  if (DiscardBlobBytes(VAR_5,VAR_22+36) == VAR_26)
    ThrowFileException(VAR_1,VAR_29,""UnexpectedEndOfFile"",
      VAR_5->filename);
  if (EOFBlob(VAR_5) != VAR_26)
    ThrowReaderException(VAR_29,""UnexpectedEndOfFile"");
  /* COMMENT_6 */
                   
    
  VAR_19=(size_t) ReadBlobByte(VAR_5)+1;
  for (VAR_17=0; VAR_17 < (ssize_t) VAR_19; VAR_17++)
  {
    VAR_9=ReadBlobByte(VAR_5);
    VAR_14[VAR_17].color=VAR_30+(VAR_9 < 0 ? 0 : VAR_9);
    VAR_14[VAR_17].offset=0;
  }
  for ( ; VAR_17 < 256L; VAR_17++)
  {
    VAR_14[VAR_17].offset=0;
    VAR_14[VAR_17].color=VAR_30;
  }
  if (DiscardBlobBytes(VAR_5,532L-VAR_19-21) == VAR_26)
    ThrowFileException(VAR_1,VAR_29,""UnexpectedEndOfFile"",
      VAR_5->filename);
  if (EOFBlob(VAR_5) != VAR_26)
    ThrowReaderException(VAR_29,""UnexpectedEndOfFile"");
  /* COMMENT_9 */
                
    
  VAR_20=64;
  VAR_15=(PointInfo *) AcquireQuantumMemory(VAR_20,
    sizeof(*VAR_15));
  if (VAR_15 == (PointInfo *) NULL)
    ThrowReaderException(VAR_31,""MemoryAllocationFailed"");
  VAR_16.x1=65535.0;
  VAR_16.y1=65535.0;
  VAR_16.x2=(-65535.0);
  VAR_16.y2=(-65535.0);
  VAR_17=0;
  VAR_9=0;
  VAR_7=0;
  VAR_8=0;
  while (EOFBlob(VAR_5) == VAR_26)
  {
    VAR_11=ReadBlobByte(VAR_5);
    VAR_12=ReadBlobByte(VAR_5);
    if ((VAR_11 == 0xff) && (VAR_12 == 0))
      break;
    if ((VAR_11 == 254) && (VAR_12 == 176))
      {
        /* COMMENT_12 */
                                   
          
        VAR_9++;
        VAR_14[VAR_9].offset=(ssize_t) VAR_17;
        if (VAR_9 >= 256)
          ThrowReaderException(VAR_31,""MemoryAllocationFailed"");
        (void) ReadBlobByte(VAR_5);
        continue;
      }
    if ((VAR_11 & 0x80) == 0)
      {
        /* COMMENT_15 */
                        
          
        if ((VAR_11 & 0x40) != 0)
          VAR_11-=0x80;
      }
    else
      {
        /* COMMENT_18 */
                      
          
        VAR_11=((VAR_11 & 0x0f) << 8)+VAR_12;
        if ((VAR_11 & 0x800) != 0)
          VAR_11-=0x1000;
        VAR_12=ReadBlobByte(VAR_5);
      }
    if ((VAR_12 & 0x80) == 0)
      {
        /* COMMENT_21 */
                        
          
        if ((VAR_12 & 0x40) != 0)
          VAR_12-=0x80;
      }
    else
      {
        /* COMMENT_24 */
                      
          
        VAR_12=((VAR_12 & 0x0f) << 8)+ReadBlobByte(VAR_5);
        if ((VAR_12 & 0x800) != 0)
          VAR_12-=0x1000;
      }
    /* COMMENT_27 */
                        
      
    VAR_11+=VAR_7;
    VAR_12+=VAR_8;
    VAR_7=VAR_11;
    VAR_8=VAR_12;
    VAR_15[VAR_17].x=(double) VAR_11;
    VAR_15[VAR_17].y=(double) VAR_12;
    if ((double) VAR_11 < VAR_16.x1)
      VAR_16.x1=(double) VAR_11;
    if ((double) VAR_11 > VAR_16.x2)
      VAR_16.x2=(double) VAR_11;
    if ((double) VAR_12 < VAR_16.y1)
      VAR_16.y1=(double) VAR_12;
    if ((double) VAR_12 > VAR_16.y2)
      VAR_16.y2=(double) VAR_12;
    VAR_17++;
    if (VAR_17 >= (ssize_t) VAR_20)
      {
        /* COMMENT_30 */
                                      
          
        VAR_20<<=1;
        VAR_15=(PointInfo *)  ResizeQuantumMemory(VAR_15,(size_t)
          VAR_20,sizeof(*VAR_15));
        if (VAR_15 == (PointInfo *) NULL)
          ThrowReaderException(VAR_31,""MemoryAllocationFailed"");
     }
  }
  VAR_9++;
  VAR_14[VAR_9].offset=(ssize_t) VAR_17;
  VAR_18=(size_t) VAR_9;
  VAR_5->columns=VAR_16.x2-VAR_16.x1;
  VAR_5->rows=VAR_16.y2-VAR_16.y1;
  VAR_13=SetImageExtent(VAR_5,VAR_5->columns,VAR_5->rows,VAR_1);
  if (VAR_13 == VAR_26)
    return(DestroyImageList(VAR_5));
  /* COMMENT_33 */
                               
    
  VAR_4=(FILE *) NULL;
  VAR_10=AcquireUniqueFileResource(VAR_2);
  if (VAR_10 != -1)
    VAR_4=fdopen(VAR_10,""wb"");
  if ((VAR_10 == -1) || (VAR_4 == (FILE *) NULL))
    ThrowImageException(VAR_32,""UnableToCreateTemporaryFile"");
  (void) FormatLocaleFile(VAR_4,""<?xml version=\""1.0\""?>\n"");
  (void) FormatLocaleFile(VAR_4,""<svg xmlns=\""http://www.w3.org/2000/svg\"" ""
    ""xlink=\""http://www.w3.org/1999/xlink\"" ""
    ""ev=\""http://www.w3.org/2001/xml-events\"" version=\""1.1\"" ""
    ""baseProfile=\""full\"" width=\""%g\"" height=\""%g\"">\n"",(double)
    VAR_5->columns,(double) VAR_5->rows);
  for (VAR_17=0; VAR_17 < (ssize_t) VAR_18; VAR_17++)
  {
    VAR_22=VAR_14[VAR_17].offset;
    (void) FormatLocaleFile(VAR_4,""  <path stroke=\""#%02x%02x%02x\"" ""
      ""fill=\""none\"" d=\""M %g %g"",VAR_14[VAR_17].color->red,VAR_14[VAR_17].color->green,
      VAR_14[VAR_17].color->blue,VAR_15[VAR_22].x-VAR_16.x1,
      VAR_15[VAR_22].y-VAR_16.y1);
    for (VAR_9=1; VAR_9 < (ssize_t) (VAR_14[VAR_17+1].offset-VAR_22); VAR_9++)
      (void) FormatLocaleFile(VAR_4,"" L %g %g"",VAR_15[VAR_22+VAR_9].x-VAR_16.x1,
        VAR_15[VAR_22+VAR_9].y-VAR_16.y1);
    (void) FormatLocaleFile(VAR_4,""\""/>\n"");
  }
  (void) FormatLocaleFile(VAR_4,""</svg>\n"");
  (void) fclose(VAR_4);
  (void) CloseBlob(VAR_5);
  VAR_5=DestroyImage(VAR_5);
  /* COMMENT_36 */
                  
    
  VAR_6=CloneImageInfo(VAR_0);
  SetImageInfoBlob(VAR_6,(void *) NULL,0);
  (void) FormatLocaleString(VAR_6->filename,VAR_3,""svg:%s"",
    VAR_2);
  VAR_5=ReadImage(VAR_6,VAR_1);
  if (VAR_5 != (Image *) NULL)
    {
      (void) CopyMagickString(VAR_5->filename,VAR_0->filename,
        VAR_3);
      (void) CopyMagickString(VAR_5->magick_filename,VAR_0->filename,
        VAR_3);
      (void) CopyMagickString(VAR_5->magick,""PES"",VAR_3);
    }
  VAR_6=DestroyImageInfo(VAR_6);
  (void) RelinquishUniqueFileResource(VAR_2);
  return(GetFirstImageInList(VAR_5));
}",ImageMagick/787ee25e9fb0e4e0509121342371d925fe5044f8/pes.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -114,7 +114,7 @@
   j=0;
   delta_x=0;
   delta_y=0;
-  while (EOFBlob(image) != EOF)
+  while (EOFBlob(image) == MagickFalse)
   {
     x=ReadBlobByte(image);
     y=ReadBlobByte(image);
@@ -200,6 +200,11 @@
   j++;
   blocks[j].offset=(ssize_t) i;
   number_blocks=(size_t) j;
+  image->columns=bounds.x2-bounds.x1;
+  image->rows=bounds.y2-bounds.y1;
+  status=SetImageExtent(image,image->columns,image->rows,exception);
+  if (status == MagickFalse)
+    return(DestroyImageList(image));
   /*
     Write stitches as SVG file.
   */
@@ -213,8 +218,8 @@
   (void) FormatLocaleFile(file,""<svg xmlns=\""http://www.w3.org/2000/svg\"" ""
     ""xlink=\""http://www.w3.org/1999/xlink\"" ""
     ""ev=\""http://www.w3.org/2001/xml-events\"" version=\""1.1\"" ""
-    ""baseProfile=\""full\"" width=\""%g\"" height=\""%g\"">\n"",bounds.x2-bounds.x1,
-    bounds.y2-bounds.y1);
+    ""baseProfile=\""full\"" width=\""%g\"" height=\""%g\"">\n"",(double)
+    image->columns,(double) image->rows);
   for (i=0; i < (ssize_t) number_blocks; i++)
   {
     offset=blocks[i].offset;","{'deleted_lines': ['  while (EOFBlob(image) != EOF)', '    ""baseProfile=\\""full\\"" width=\\""%g\\"" height=\\""%g\\"">\\n"",bounds.x2-bounds.x1,', '    bounds.y2-bounds.y1);'], 'added_lines': ['  while (EOFBlob(image) == MagickFalse)', '  image->columns=bounds.x2-bounds.x1;', '  image->rows=bounds.y2-bounds.y1;', '  status=SetImageExtent(image,image->columns,image->rows,exception);', '  if (status == MagickFalse)', '    return(DestroyImageList(image));', '    ""baseProfile=\\""full\\"" width=\\""%g\\"" height=\\""%g\\"">\\n"",(double)', '    image->columns,(double) image->rows);']}",True,The ReadPESImage function in coders\pes.c in ImageMagick 7.0.6-1 has an infinite loop vulnerability that can cause CPU exhaustion via a crafted PES file.,6.5,MEDIUM,1,test,2017-07-04T18:17:55Z,1
