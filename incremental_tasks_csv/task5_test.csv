cve_id,cwe_ids,cvss_vector,cvss_is_v3,repo_name,commit_msg,commit_hash,git_url,file_path,func_name,func_before,abstract_func_before,func_graph_path_before,func,abstract_func,func_graph_path,diff_func,diff_line_info,is_vul,description,Base Score,Base Severity,severity,source,commit_time,task
CVE-2014-125021,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ffmpeg,"
eacmv: clear references on frame dimensions change

Fixes invalid reads.

Found-by: Mateusz ""j00ru"" Jurczyk and Gynvael Coldwind
CC:libav-stable@libav.org
",5430839144c6da0160e8e0cfb0c8db01de432e94,http://git.videolan.org/?p=ffmpeg.git;a=commit;h=5430839144,libavcodec/eacmv.c,cmv_process_header,"static int cmv_process_header(CmvContext *s, const uint8_t *buf, const uint8_t *buf_end)
{
int pal_start, pal_count, i, ret, fps;
if(buf_end - buf < 16) {
av_log(s->avctx, AV_LOG_WARNING, ""truncated header\n"");
return AVERROR_INVALIDDATA;
}
s->width  = AV_RL16(&buf[4]);
s->height = AV_RL16(&buf[6]);
ret = ff_set_dimensions(s->avctx, s->width, s->height);
if (ret < 0)
return ret;
fps = AV_RL16(&buf[10]);
if (fps > 0)
s->avctx->time_base = (AVRational){ 1, fps };
pal_start = AV_RL16(&buf[12]);
pal_count = AV_RL16(&buf[14]);
buf += 16;
for (i=pal_start; i<pal_start+pal_count && i<AVPALETTE_COUNT && buf_end - buf >= 3; i++) {
s->palette[i] = AV_RB24(buf);
buf += 3;
}
return 0;
}","static int cmv_process_header(CmvContext *VAR_0, const uint8_t *VAR_1, const uint8_t *VAR_2)
{
int VAR_3, VAR_4, VAR_5, VAR_6, VAR_7;
if(VAR_2 - VAR_1 < 16) {
av_log(VAR_0->avctx, VAR_8, ""truncated header\n"");
return VAR_9;
}
VAR_0->width  = AV_RL16(&VAR_1[4]);
VAR_0->height = AV_RL16(&VAR_1[6]);
VAR_6 = ff_set_dimensions(VAR_0->avctx, VAR_0->width, VAR_0->height);
if (VAR_6 < 0)
return VAR_6;
VAR_7 = AV_RL16(&VAR_1[10]);
if (VAR_7 > 0)
VAR_0->avctx->time_base = (AVRational){ 1, VAR_7 };
VAR_3 = AV_RL16(&VAR_1[12]);
VAR_4 = AV_RL16(&VAR_1[14]);
VAR_1 += 16;
for (VAR_5=VAR_3; VAR_5<VAR_3+VAR_4 && VAR_5<VAR_10 && VAR_2 - VAR_1 >= 3; VAR_5++) {
VAR_0->palette[VAR_5] = AV_RB24(VAR_1);
VAR_1 += 3;
}
return 0;
}",ffmpeg/5430839144c6da0160e8e0cfb0c8db01de432e94/eacmv.c/vul/before/0.json,"static int cmv_process_header(CmvContext *s, const uint8_t *buf, const uint8_t *buf_end)
{
    int pal_start, pal_count, i, ret, fps;

    if(buf_end - buf < 16) {
        av_log(s->avctx, AV_LOG_WARNING, ""truncated header\n"");
        return AVERROR_INVALIDDATA;
    }

    s->width  = AV_RL16(&buf[4]);
    s->height = AV_RL16(&buf[6]);

    if (s->width  != s->avctx->width ||
        s->height != s->avctx->height) {
        av_frame_unref(s->last_frame);
        av_frame_unref(s->last2_frame);
    }

    ret = ff_set_dimensions(s->avctx, s->width, s->height);
    if (ret < 0)
        return ret;

    fps = AV_RL16(&buf[10]);
    if (fps > 0)
        s->avctx->time_base = (AVRational){ 1, fps };

    pal_start = AV_RL16(&buf[12]);
    pal_count = AV_RL16(&buf[14]);

    buf += 16;
    for (i=pal_start; i<pal_start+pal_count && i<AVPALETTE_COUNT && buf_end - buf >= 3; i++) {
        s->palette[i] = AV_RB24(buf);
        buf += 3;
    }

    return 0;
}","static int cmv_process_header(CmvContext *VAR_0, const uint8_t *VAR_1, const uint8_t *VAR_2)
{
    int VAR_3, VAR_4, VAR_5, VAR_6, VAR_7;

    if(VAR_2 - VAR_1 < 16) {
        av_log(VAR_0->avctx, VAR_8, ""truncated header\n"");
        return VAR_9;
    }

    VAR_0->width  = AV_RL16(&VAR_1[4]);
    VAR_0->height = AV_RL16(&VAR_1[6]);

    if (VAR_0->width  != VAR_0->avctx->width ||
        VAR_0->height != VAR_0->avctx->height) {
        av_frame_unref(VAR_0->last_frame);
        av_frame_unref(VAR_0->last2_frame);
    }

    VAR_6 = ff_set_dimensions(VAR_0->avctx, VAR_0->width, VAR_0->height);
    if (VAR_6 < 0)
        return VAR_6;

    VAR_7 = AV_RL16(&VAR_1[10]);
    if (VAR_7 > 0)
        VAR_0->avctx->time_base = (AVRational){ 1, VAR_7 };

    VAR_3 = AV_RL16(&VAR_1[12]);
    VAR_4 = AV_RL16(&VAR_1[14]);

    VAR_1 += 16;
    for (VAR_5=VAR_3; VAR_5<VAR_3+VAR_4 && VAR_5<VAR_10 && VAR_2 - VAR_1 >= 3; VAR_5++) {
        VAR_0->palette[VAR_5] = AV_RB24(VAR_1);
        VAR_1 += 3;
    }

    return 0;
}",ffmpeg/5430839144c6da0160e8e0cfb0c8db01de432e94/eacmv.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,6 +9,12 @@
 
     s->width  = AV_RL16(&buf[4]);
     s->height = AV_RL16(&buf[6]);
+
+    if (s->width  != s->avctx->width ||
+        s->height != s->avctx->height) {
+        av_frame_unref(s->last_frame);
+        av_frame_unref(s->last2_frame);
+    }
 
     ret = ff_set_dimensions(s->avctx, s->width, s->height);
     if (ret < 0)","{'deleted_lines': [], 'added_lines': ['', '    if (s->width  != s->avctx->width ||', '        s->height != s->avctx->height) {', '        av_frame_unref(s->last_frame);', '        av_frame_unref(s->last2_frame);', '    }']}",True,A vulnerability was found in FFmpeg 2.0 and classified as problematic. This issue affects the function cmv_process_header. The manipulation leads to memory corruption. The attack may be initiated remotely. It is recommended to apply a patch to fix this issue.,5.5,MEDIUM,1,test,,5
CVE-2014-125024,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ffmpeg,"
lagarith: reallocate rgb_planes when needed

Fixes invalid writes on pixel format changes.

Found-by: Mateusz ""j00ru"" Jurczyk and Gynvael Coldwind
CC:libav-stable@libav.org
",4c3e1956ee35fdcc5ffdb28782050164b4623c0b,http://git.videolan.org/?p=ffmpeg.git;a=commit;h=4c3e1956ee,libavcodec/lagarith.c,lag_decode_frame,"static int lag_decode_frame(AVCodecContext *avctx,
void *data, int *got_frame, AVPacket *avpkt)
{
const uint8_t *buf = avpkt->data;
int buf_size = avpkt->size;
LagarithContext *l = avctx->priv_data;
ThreadFrame frame = { .f = data };
AVFrame *const p  = data;
uint8_t frametype = 0;
uint32_t offset_gu = 0, offset_bv = 0, offset_ry = 9;
uint32_t offs[4];
uint8_t *srcs[4], *dst;
int i, j, planes = 3;
p->key_frame = 1;
frametype = buf[0];
offset_gu = AV_RL32(buf + 1);
offset_bv = AV_RL32(buf + 5);
switch (frametype) {
case FRAME_SOLID_RGBA:
avctx->pix_fmt = AV_PIX_FMT_RGB32;
if (ff_thread_get_buffer(avctx, &frame, 0) < 0) {
av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
return -1;
}
dst = p->data[0];
for (j = 0; j < avctx->height; j++) {
for (i = 0; i < avctx->width; i++)
AV_WN32(dst + i * 4, offset_gu);
dst += p->linesize[0];
}
break;
case FRAME_ARITH_RGBA:
avctx->pix_fmt = AV_PIX_FMT_RGB32;
planes = 4;
offset_ry += 4;
offs[3] = AV_RL32(buf + 9);
case FRAME_ARITH_RGB24:
case FRAME_U_RGB24:
if (frametype == FRAME_ARITH_RGB24 || frametype == FRAME_U_RGB24)
avctx->pix_fmt = AV_PIX_FMT_RGB24;
if (ff_thread_get_buffer(avctx, &frame, 0) < 0) {
av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
return -1;
}
offs[0] = offset_bv;
offs[1] = offset_gu;
offs[2] = offset_ry;
if (!l->rgb_planes) {
l->rgb_stride = FFALIGN(avctx->width, 16);
l->rgb_planes = av_malloc(l->rgb_stride * avctx->height * planes + 1);
if (!l->rgb_planes) {
av_log(avctx, AV_LOG_ERROR, ""cannot allocate temporary buffer\n"");
return AVERROR(ENOMEM);
}
}
for (i = 0; i < planes; i++)
srcs[i] = l->rgb_planes + (i + 1) * l->rgb_stride * avctx->height - l->rgb_stride;
if (offset_ry >= buf_size ||
offset_gu >= buf_size ||
offset_bv >= buf_size ||
(planes == 4 && offs[3] >= buf_size)) {
av_log(avctx, AV_LOG_ERROR,
""Invalid frame offsets\n"");
return AVERROR_INVALIDDATA;
}
for (i = 0; i < planes; i++)
lag_decode_arith_plane(l, srcs[i],
avctx->width, avctx->height,
-l->rgb_stride, buf + offs[i],
buf_size - offs[i]);
dst = p->data[0];
for (i = 0; i < planes; i++)
srcs[i] = l->rgb_planes + i * l->rgb_stride * avctx->height;
for (j = 0; j < avctx->height; j++) {
for (i = 0; i < avctx->width; i++) {
uint8_t r, g, b, a;
r = srcs[0][i];
g = srcs[1][i];
b = srcs[2][i];
r += g;
b += g;
if (frametype == FRAME_ARITH_RGBA) {
a = srcs[3][i];
AV_WN32(dst + i * 4, MKBETAG(a, r, g, b));
} else {
dst[i * 3 + 0] = r;
dst[i * 3 + 1] = g;
dst[i * 3 + 2] = b;
}
}
dst += p->linesize[0];
for (i = 0; i < planes; i++)
srcs[i] += l->rgb_stride;
}
break;
case FRAME_ARITH_YUY2:
avctx->pix_fmt = AV_PIX_FMT_YUV422P;
if (ff_thread_get_buffer(avctx, &frame, 0) < 0) {
av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
return -1;
}
if (offset_ry >= buf_size ||
offset_gu >= buf_size ||
offset_bv >= buf_size) {
av_log(avctx, AV_LOG_ERROR,
""Invalid frame offsets\n"");
return AVERROR_INVALIDDATA;
}
lag_decode_arith_plane(l, p->data[0], avctx->width, avctx->height,
p->linesize[0], buf + offset_ry,
buf_size - offset_ry);
lag_decode_arith_plane(l, p->data[1], avctx->width / 2,
avctx->height, p->linesize[1],
buf + offset_gu, buf_size - offset_gu);
lag_decode_arith_plane(l, p->data[2], avctx->width / 2,
avctx->height, p->linesize[2],
buf + offset_bv, buf_size - offset_bv);
break;
case FRAME_ARITH_YV12:
avctx->pix_fmt = AV_PIX_FMT_YUV420P;
if (ff_thread_get_buffer(avctx, &frame, 0) < 0) {
av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
return -1;
}
if (offset_ry >= buf_size ||
offset_gu >= buf_size ||
offset_bv >= buf_size) {
av_log(avctx, AV_LOG_ERROR,
""Invalid frame offsets\n"");
return AVERROR_INVALIDDATA;
}
lag_decode_arith_plane(l, p->data[0], avctx->width, avctx->height,
p->linesize[0], buf + offset_ry,
buf_size - offset_ry);
lag_decode_arith_plane(l, p->data[2], avctx->width / 2,
avctx->height / 2, p->linesize[2],
buf + offset_gu, buf_size - offset_gu);
lag_decode_arith_plane(l, p->data[1], avctx->width / 2,
avctx->height / 2, p->linesize[1],
buf + offset_bv, buf_size - offset_bv);
break;
default:
av_log(avctx, AV_LOG_ERROR,
""Unsupported Lagarith frame type: %#x\n"", frametype);
return -1;
}
*got_frame = 1;
return buf_size;
}","static int lag_decode_frame(AVCodecContext *VAR_0,
void *VAR_1, int *VAR_2, AVPacket *VAR_3)
{
const uint8_t *VAR_4 = VAR_3->data;
int VAR_5 = VAR_3->size;
LagarithContext *VAR_6 = VAR_0->priv_data;
ThreadFrame VAR_7 = { .f = VAR_1 };
AVFrame *const VAR_8  = VAR_1;
uint8_t VAR_9 = 0;
uint32_t VAR_10 = 0, VAR_11 = 0, VAR_12 = 9;
uint32_t VAR_13[4];
uint8_t *VAR_14[4], *VAR_15;
int VAR_16, VAR_17, VAR_18 = 3;
VAR_8->key_frame = 1;
VAR_9 = VAR_4[0];
VAR_10 = AV_RL32(VAR_4 + 1);
VAR_11 = AV_RL32(VAR_4 + 5);
switch (VAR_9) {
case VAR_19:
VAR_0->pix_fmt = VAR_20;
if (ff_thread_get_buffer(VAR_0, &VAR_7, 0) < 0) {
av_log(VAR_0, VAR_21, ""get_buffer() failed\n"");
return -1;
}
VAR_15 = VAR_8->data[0];
for (VAR_17 = 0; VAR_17 < VAR_0->height; VAR_17++) {
for (VAR_16 = 0; VAR_16 < VAR_0->width; VAR_16++)
AV_WN32(VAR_15 + VAR_16 * 4, VAR_10);
VAR_15 += VAR_8->linesize[0];
}
break;
case VAR_22:
VAR_0->pix_fmt = VAR_20;
VAR_18 = 4;
VAR_12 += 4;
VAR_13[3] = AV_RL32(VAR_4 + 9);
case VAR_23:
case VAR_24:
if (VAR_9 == VAR_23 || VAR_9 == VAR_24)
VAR_0->pix_fmt = VAR_25;
if (ff_thread_get_buffer(VAR_0, &VAR_7, 0) < 0) {
av_log(VAR_0, VAR_21, ""get_buffer() failed\n"");
return -1;
}
VAR_13[0] = VAR_11;
VAR_13[1] = VAR_10;
VAR_13[2] = VAR_12;
if (!VAR_6->rgb_planes) {
VAR_6->rgb_stride = FFALIGN(VAR_0->width, 16);
VAR_6->rgb_planes = av_malloc(VAR_6->rgb_stride * VAR_0->height * VAR_18 + 1);
if (!VAR_6->rgb_planes) {
av_log(VAR_0, VAR_21, ""cannot allocate temporary buffer\n"");
return AVERROR(VAR_26);
}
}
for (VAR_16 = 0; VAR_16 < VAR_18; VAR_16++)
VAR_14[VAR_16] = VAR_6->rgb_planes + (VAR_16 + 1) * VAR_6->rgb_stride * VAR_0->height - VAR_6->rgb_stride;
if (VAR_12 >= VAR_5 ||
VAR_10 >= VAR_5 ||
VAR_11 >= VAR_5 ||
(VAR_18 == 4 && VAR_13[3] >= VAR_5)) {
av_log(VAR_0, VAR_21,
""Invalid frame offsets\n"");
return VAR_27;
}
for (VAR_16 = 0; VAR_16 < VAR_18; VAR_16++)
lag_decode_arith_plane(VAR_6, VAR_14[VAR_16],
VAR_0->width, VAR_0->height,
-VAR_6->rgb_stride, VAR_4 + VAR_13[VAR_16],
VAR_5 - VAR_13[VAR_16]);
VAR_15 = VAR_8->data[0];
for (VAR_16 = 0; VAR_16 < VAR_18; VAR_16++)
VAR_14[VAR_16] = VAR_6->rgb_planes + VAR_16 * VAR_6->rgb_stride * VAR_0->height;
for (VAR_17 = 0; VAR_17 < VAR_0->height; VAR_17++) {
for (VAR_16 = 0; VAR_16 < VAR_0->width; VAR_16++) {
uint8_t VAR_28, VAR_29, VAR_30, VAR_31;
VAR_28 = VAR_14[0][VAR_16];
VAR_29 = VAR_14[1][VAR_16];
VAR_30 = VAR_14[2][VAR_16];
VAR_28 += VAR_29;
VAR_30 += VAR_29;
if (VAR_9 == VAR_22) {
VAR_31 = VAR_14[3][VAR_16];
AV_WN32(VAR_15 + VAR_16 * 4, MKBETAG(VAR_31, VAR_28, VAR_29, VAR_30));
} else {
VAR_15[VAR_16 * 3 + 0] = VAR_28;
VAR_15[VAR_16 * 3 + 1] = VAR_29;
VAR_15[VAR_16 * 3 + 2] = VAR_30;
}
}
VAR_15 += VAR_8->linesize[0];
for (VAR_16 = 0; VAR_16 < VAR_18; VAR_16++)
VAR_14[VAR_16] += VAR_6->rgb_stride;
}
break;
case VAR_32:
VAR_0->pix_fmt = VAR_33;
if (ff_thread_get_buffer(VAR_0, &VAR_7, 0) < 0) {
av_log(VAR_0, VAR_21, ""get_buffer() failed\n"");
return -1;
}
if (VAR_12 >= VAR_5 ||
VAR_10 >= VAR_5 ||
VAR_11 >= VAR_5) {
av_log(VAR_0, VAR_21,
""Invalid frame offsets\n"");
return VAR_27;
}
lag_decode_arith_plane(VAR_6, VAR_8->data[0], VAR_0->width, VAR_0->height,
VAR_8->linesize[0], VAR_4 + VAR_12,
VAR_5 - VAR_12);
lag_decode_arith_plane(VAR_6, VAR_8->data[1], VAR_0->width / 2,
VAR_0->height, VAR_8->linesize[1],
VAR_4 + VAR_10, VAR_5 - VAR_10);
lag_decode_arith_plane(VAR_6, VAR_8->data[2], VAR_0->width / 2,
VAR_0->height, VAR_8->linesize[2],
VAR_4 + VAR_11, VAR_5 - VAR_11);
break;
case VAR_34:
VAR_0->pix_fmt = VAR_35;
if (ff_thread_get_buffer(VAR_0, &VAR_7, 0) < 0) {
av_log(VAR_0, VAR_21, ""get_buffer() failed\n"");
return -1;
}
if (VAR_12 >= VAR_5 ||
VAR_10 >= VAR_5 ||
VAR_11 >= VAR_5) {
av_log(VAR_0, VAR_21,
""Invalid frame offsets\n"");
return VAR_27;
}
lag_decode_arith_plane(VAR_6, VAR_8->data[0], VAR_0->width, VAR_0->height,
VAR_8->linesize[0], VAR_4 + VAR_12,
VAR_5 - VAR_12);
lag_decode_arith_plane(VAR_6, VAR_8->data[2], VAR_0->width / 2,
VAR_0->height / 2, VAR_8->linesize[2],
VAR_4 + VAR_10, VAR_5 - VAR_10);
lag_decode_arith_plane(VAR_6, VAR_8->data[1], VAR_0->width / 2,
VAR_0->height / 2, VAR_8->linesize[1],
VAR_4 + VAR_11, VAR_5 - VAR_11);
break;
default:
av_log(VAR_0, VAR_21,
""Unsupported Lagarith frame type: %#x\n"", VAR_9);
return -1;
}
*VAR_2 = 1;
return VAR_5;
}",ffmpeg/4c3e1956ee35fdcc5ffdb28782050164b4623c0b/lagarith.c/vul/before/0.json,"static int lag_decode_frame(AVCodecContext *avctx,
                            void *data, int *got_frame, AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    LagarithContext *l = avctx->priv_data;
    ThreadFrame frame = { .f = data };
    AVFrame *const p  = data;
    uint8_t frametype = 0;
    uint32_t offset_gu = 0, offset_bv = 0, offset_ry = 9;
    uint32_t offs[4];
    uint8_t *srcs[4], *dst;
    int i, j, planes = 3;

    p->key_frame = 1;

    frametype = buf[0];

    offset_gu = AV_RL32(buf + 1);
    offset_bv = AV_RL32(buf + 5);

    switch (frametype) {
    case FRAME_SOLID_RGBA:
        avctx->pix_fmt = AV_PIX_FMT_RGB32;

        if (ff_thread_get_buffer(avctx, &frame, 0) < 0) {
            av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
            return -1;
        }

        dst = p->data[0];
        for (j = 0; j < avctx->height; j++) {
            for (i = 0; i < avctx->width; i++)
                AV_WN32(dst + i * 4, offset_gu);
            dst += p->linesize[0];
        }
        break;
    case FRAME_ARITH_RGBA:
        avctx->pix_fmt = AV_PIX_FMT_RGB32;
        planes = 4;
        offset_ry += 4;
        offs[3] = AV_RL32(buf + 9);
    case FRAME_ARITH_RGB24:
    case FRAME_U_RGB24:
        if (frametype == FRAME_ARITH_RGB24 || frametype == FRAME_U_RGB24)
            avctx->pix_fmt = AV_PIX_FMT_RGB24;

        if (ff_thread_get_buffer(avctx, &frame, 0) < 0) {
            av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
            return -1;
        }

        offs[0] = offset_bv;
        offs[1] = offset_gu;
        offs[2] = offset_ry;

        l->rgb_stride = FFALIGN(avctx->width, 16);
        av_fast_malloc(&l->rgb_planes, &l->rgb_planes_allocated,
                       l->rgb_stride * avctx->height * planes + 1);
        if (!l->rgb_planes) {
            av_log(avctx, AV_LOG_ERROR, ""cannot allocate temporary buffer\n"");
            return AVERROR(ENOMEM);
        }
        for (i = 0; i < planes; i++)
            srcs[i] = l->rgb_planes + (i + 1) * l->rgb_stride * avctx->height - l->rgb_stride;
        if (offset_ry >= buf_size ||
            offset_gu >= buf_size ||
            offset_bv >= buf_size ||
            (planes == 4 && offs[3] >= buf_size)) {
            av_log(avctx, AV_LOG_ERROR,
                    ""Invalid frame offsets\n"");
            return AVERROR_INVALIDDATA;
        }
        for (i = 0; i < planes; i++)
            lag_decode_arith_plane(l, srcs[i],
                                   avctx->width, avctx->height,
                                   -l->rgb_stride, buf + offs[i],
                                   buf_size - offs[i]);
        dst = p->data[0];
        for (i = 0; i < planes; i++)
            srcs[i] = l->rgb_planes + i * l->rgb_stride * avctx->height;
        for (j = 0; j < avctx->height; j++) {
            for (i = 0; i < avctx->width; i++) {
                uint8_t r, g, b, a;
                r = srcs[0][i];
                g = srcs[1][i];
                b = srcs[2][i];
                r += g;
                b += g;
                if (frametype == FRAME_ARITH_RGBA) {
                    a = srcs[3][i];
                    AV_WN32(dst + i * 4, MKBETAG(a, r, g, b));
                } else {
                    dst[i * 3 + 0] = r;
                    dst[i * 3 + 1] = g;
                    dst[i * 3 + 2] = b;
                }
            }
            dst += p->linesize[0];
            for (i = 0; i < planes; i++)
                srcs[i] += l->rgb_stride;
        }
        break;
    case FRAME_ARITH_YUY2:
        avctx->pix_fmt = AV_PIX_FMT_YUV422P;

        if (ff_thread_get_buffer(avctx, &frame, 0) < 0) {
            av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
            return -1;
        }

        if (offset_ry >= buf_size ||
            offset_gu >= buf_size ||
            offset_bv >= buf_size) {
            av_log(avctx, AV_LOG_ERROR,
                   ""Invalid frame offsets\n"");
            return AVERROR_INVALIDDATA;
        }

        lag_decode_arith_plane(l, p->data[0], avctx->width, avctx->height,
                               p->linesize[0], buf + offset_ry,
                               buf_size - offset_ry);
        lag_decode_arith_plane(l, p->data[1], avctx->width / 2,
                               avctx->height, p->linesize[1],
                               buf + offset_gu, buf_size - offset_gu);
        lag_decode_arith_plane(l, p->data[2], avctx->width / 2,
                               avctx->height, p->linesize[2],
                               buf + offset_bv, buf_size - offset_bv);
        break;
    case FRAME_ARITH_YV12:
        avctx->pix_fmt = AV_PIX_FMT_YUV420P;

        if (ff_thread_get_buffer(avctx, &frame, 0) < 0) {
            av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
            return -1;
        }

        if (offset_ry >= buf_size ||
            offset_gu >= buf_size ||
            offset_bv >= buf_size) {
            av_log(avctx, AV_LOG_ERROR,
                   ""Invalid frame offsets\n"");
            return AVERROR_INVALIDDATA;
        }

        lag_decode_arith_plane(l, p->data[0], avctx->width, avctx->height,
                               p->linesize[0], buf + offset_ry,
                               buf_size - offset_ry);
        lag_decode_arith_plane(l, p->data[2], avctx->width / 2,
                               avctx->height / 2, p->linesize[2],
                               buf + offset_gu, buf_size - offset_gu);
        lag_decode_arith_plane(l, p->data[1], avctx->width / 2,
                               avctx->height / 2, p->linesize[1],
                               buf + offset_bv, buf_size - offset_bv);
        break;
    default:
        av_log(avctx, AV_LOG_ERROR,
               ""Unsupported Lagarith frame type: %#x\n"", frametype);
        return -1;
    }

    *got_frame = 1;

    return buf_size;
}","static int lag_decode_frame(AVCodecContext *VAR_0,
                            void *VAR_1, int *VAR_2, AVPacket *VAR_3)
{
    const uint8_t *VAR_4 = VAR_3->data;
    int VAR_5 = VAR_3->size;
    LagarithContext *VAR_6 = VAR_0->priv_data;
    ThreadFrame VAR_7 = { .f = VAR_1 };
    AVFrame *const VAR_8  = VAR_1;
    uint8_t VAR_9 = 0;
    uint32_t VAR_10 = 0, VAR_11 = 0, VAR_12 = 9;
    uint32_t VAR_13[4];
    uint8_t *VAR_14[4], *VAR_15;
    int VAR_16, VAR_17, VAR_18 = 3;

    VAR_8->key_frame = 1;

    VAR_9 = VAR_4[0];

    VAR_10 = AV_RL32(VAR_4 + 1);
    VAR_11 = AV_RL32(VAR_4 + 5);

    switch (VAR_9) {
    case VAR_19:
        VAR_0->pix_fmt = VAR_20;

        if (ff_thread_get_buffer(VAR_0, &VAR_7, 0) < 0) {
            av_log(VAR_0, VAR_21, ""get_buffer() failed\n"");
            return -1;
        }

        VAR_15 = VAR_8->data[0];
        for (VAR_17 = 0; VAR_17 < VAR_0->height; VAR_17++) {
            for (VAR_16 = 0; VAR_16 < VAR_0->width; VAR_16++)
                AV_WN32(VAR_15 + VAR_16 * 4, VAR_10);
            VAR_15 += VAR_8->linesize[0];
        }
        break;
    case VAR_22:
        VAR_0->pix_fmt = VAR_20;
        VAR_18 = 4;
        VAR_12 += 4;
        VAR_13[3] = AV_RL32(VAR_4 + 9);
    case VAR_23:
    case VAR_24:
        if (VAR_9 == VAR_23 || VAR_9 == VAR_24)
            VAR_0->pix_fmt = VAR_25;

        if (ff_thread_get_buffer(VAR_0, &VAR_7, 0) < 0) {
            av_log(VAR_0, VAR_21, ""get_buffer() failed\n"");
            return -1;
        }

        VAR_13[0] = VAR_11;
        VAR_13[1] = VAR_10;
        VAR_13[2] = VAR_12;

        VAR_6->rgb_stride = FFALIGN(VAR_0->width, 16);
        av_fast_malloc(&VAR_6->rgb_planes, &VAR_6->rgb_planes_allocated,
                       VAR_6->rgb_stride * VAR_0->height * VAR_18 + 1);
        if (!VAR_6->rgb_planes) {
            av_log(VAR_0, VAR_21, ""cannot allocate temporary buffer\n"");
            return AVERROR(VAR_26);
        }
        for (VAR_16 = 0; VAR_16 < VAR_18; VAR_16++)
            VAR_14[VAR_16] = VAR_6->rgb_planes + (VAR_16 + 1) * VAR_6->rgb_stride * VAR_0->height - VAR_6->rgb_stride;
        if (VAR_12 >= VAR_5 ||
            VAR_10 >= VAR_5 ||
            VAR_11 >= VAR_5 ||
            (VAR_18 == 4 && VAR_13[3] >= VAR_5)) {
            av_log(VAR_0, VAR_21,
                    ""Invalid frame offsets\n"");
            return VAR_27;
        }
        for (VAR_16 = 0; VAR_16 < VAR_18; VAR_16++)
            lag_decode_arith_plane(VAR_6, VAR_14[VAR_16],
                                   VAR_0->width, VAR_0->height,
                                   -VAR_6->rgb_stride, VAR_4 + VAR_13[VAR_16],
                                   VAR_5 - VAR_13[VAR_16]);
        VAR_15 = VAR_8->data[0];
        for (VAR_16 = 0; VAR_16 < VAR_18; VAR_16++)
            VAR_14[VAR_16] = VAR_6->rgb_planes + VAR_16 * VAR_6->rgb_stride * VAR_0->height;
        for (VAR_17 = 0; VAR_17 < VAR_0->height; VAR_17++) {
            for (VAR_16 = 0; VAR_16 < VAR_0->width; VAR_16++) {
                uint8_t VAR_28, VAR_29, VAR_30, VAR_31;
                VAR_28 = VAR_14[0][VAR_16];
                VAR_29 = VAR_14[1][VAR_16];
                VAR_30 = VAR_14[2][VAR_16];
                VAR_28 += VAR_29;
                VAR_30 += VAR_29;
                if (VAR_9 == VAR_22) {
                    VAR_31 = VAR_14[3][VAR_16];
                    AV_WN32(VAR_15 + VAR_16 * 4, MKBETAG(VAR_31, VAR_28, VAR_29, VAR_30));
                } else {
                    VAR_15[VAR_16 * 3 + 0] = VAR_28;
                    VAR_15[VAR_16 * 3 + 1] = VAR_29;
                    VAR_15[VAR_16 * 3 + 2] = VAR_30;
                }
            }
            VAR_15 += VAR_8->linesize[0];
            for (VAR_16 = 0; VAR_16 < VAR_18; VAR_16++)
                VAR_14[VAR_16] += VAR_6->rgb_stride;
        }
        break;
    case VAR_32:
        VAR_0->pix_fmt = VAR_33;

        if (ff_thread_get_buffer(VAR_0, &VAR_7, 0) < 0) {
            av_log(VAR_0, VAR_21, ""get_buffer() failed\n"");
            return -1;
        }

        if (VAR_12 >= VAR_5 ||
            VAR_10 >= VAR_5 ||
            VAR_11 >= VAR_5) {
            av_log(VAR_0, VAR_21,
                   ""Invalid frame offsets\n"");
            return VAR_27;
        }

        lag_decode_arith_plane(VAR_6, VAR_8->data[0], VAR_0->width, VAR_0->height,
                               VAR_8->linesize[0], VAR_4 + VAR_12,
                               VAR_5 - VAR_12);
        lag_decode_arith_plane(VAR_6, VAR_8->data[1], VAR_0->width / 2,
                               VAR_0->height, VAR_8->linesize[1],
                               VAR_4 + VAR_10, VAR_5 - VAR_10);
        lag_decode_arith_plane(VAR_6, VAR_8->data[2], VAR_0->width / 2,
                               VAR_0->height, VAR_8->linesize[2],
                               VAR_4 + VAR_11, VAR_5 - VAR_11);
        break;
    case VAR_34:
        VAR_0->pix_fmt = VAR_35;

        if (ff_thread_get_buffer(VAR_0, &VAR_7, 0) < 0) {
            av_log(VAR_0, VAR_21, ""get_buffer() failed\n"");
            return -1;
        }

        if (VAR_12 >= VAR_5 ||
            VAR_10 >= VAR_5 ||
            VAR_11 >= VAR_5) {
            av_log(VAR_0, VAR_21,
                   ""Invalid frame offsets\n"");
            return VAR_27;
        }

        lag_decode_arith_plane(VAR_6, VAR_8->data[0], VAR_0->width, VAR_0->height,
                               VAR_8->linesize[0], VAR_4 + VAR_12,
                               VAR_5 - VAR_12);
        lag_decode_arith_plane(VAR_6, VAR_8->data[2], VAR_0->width / 2,
                               VAR_0->height / 2, VAR_8->linesize[2],
                               VAR_4 + VAR_10, VAR_5 - VAR_10);
        lag_decode_arith_plane(VAR_6, VAR_8->data[1], VAR_0->width / 2,
                               VAR_0->height / 2, VAR_8->linesize[1],
                               VAR_4 + VAR_11, VAR_5 - VAR_11);
        break;
    default:
        av_log(VAR_0, VAR_21,
               ""Unsupported Lagarith frame type: %#x\n"", VAR_9);
        return -1;
    }

    *VAR_2 = 1;

    return VAR_5;
}",ffmpeg/4c3e1956ee35fdcc5ffdb28782050164b4623c0b/lagarith.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -54,13 +54,12 @@
         offs[1] = offset_gu;
         offs[2] = offset_ry;
 
+        l->rgb_stride = FFALIGN(avctx->width, 16);
+        av_fast_malloc(&l->rgb_planes, &l->rgb_planes_allocated,
+                       l->rgb_stride * avctx->height * planes + 1);
         if (!l->rgb_planes) {
-            l->rgb_stride = FFALIGN(avctx->width, 16);
-            l->rgb_planes = av_malloc(l->rgb_stride * avctx->height * planes + 1);
-            if (!l->rgb_planes) {
-                av_log(avctx, AV_LOG_ERROR, ""cannot allocate temporary buffer\n"");
-                return AVERROR(ENOMEM);
-            }
+            av_log(avctx, AV_LOG_ERROR, ""cannot allocate temporary buffer\n"");
+            return AVERROR(ENOMEM);
         }
         for (i = 0; i < planes; i++)
             srcs[i] = l->rgb_planes + (i + 1) * l->rgb_stride * avctx->height - l->rgb_stride;","{'deleted_lines': ['            l->rgb_stride = FFALIGN(avctx->width, 16);', '            l->rgb_planes = av_malloc(l->rgb_stride * avctx->height * planes + 1);', '            if (!l->rgb_planes) {', '                av_log(avctx, AV_LOG_ERROR, ""cannot allocate temporary buffer\\n"");', '                return AVERROR(ENOMEM);', '            }'], 'added_lines': ['        l->rgb_stride = FFALIGN(avctx->width, 16);', '        av_fast_malloc(&l->rgb_planes, &l->rgb_planes_allocated,', '                       l->rgb_stride * avctx->height * planes + 1);', '            av_log(avctx, AV_LOG_ERROR, ""cannot allocate temporary buffer\\n"");', '            return AVERROR(ENOMEM);']}",True,A vulnerability was found in FFmpeg 2.0. It has been rated as critical. Affected by this issue is the function lag_decode_frame. The manipulation leads to memory corruption. The attack may be launched remotely. It is recommended to apply a patch to fix this issue.,7.8,HIGH,2,test,,5
CVE-2019-11479,['CWE-770'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,kernel/git/netdev/net,"Some TCP peers announce a very small MSS option in their SYN and/or
SYN/ACK messages.

This forces the stack to send packets with a very high network/cpu
overhead.

Linux has enforced a minimal value of 48. Since this value includes
the size of TCP options, and that the options can consume up to 40
bytes, this means that each segment can include only 8 bytes of payload.

In some cases, it can be useful to increase the minimal value
to a saner value.

We still let the default to 48 (TCP_MIN_SND_MSS), for compatibility
reasons.

Note that TCP_MAXSEG socket option enforces a minimal value
of (TCP_MIN_MSS). David Miller increased this minimal value
in commit c39508d6f118 (""tcp: Make TCP_MAXSEG minimum more correct."")
from 64 to 88.

We might in the future merge TCP_MIN_SND_MSS and TCP_MIN_MSS.

CVE-2019-11479 -- tcp mss hardcoded to 48

Signed-off-by: Eric Dumazet <edumazet@google.com>
Suggested-by: Jonathan Looney <jtl@netflix.com>
Acked-by: Neal Cardwell <ncardwell@google.com>
Cc: Yuchung Cheng <ycheng@google.com>
Cc: Tyler Hicks <tyhicks@canonical.com>
Cc: Bruce Curtis <brucec@netflix.com>
Cc: Jonathan Lemon <jonathan.lemon@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
",5f3e2bf008c2221478101ee72f5cb4654b9fc363,https://git.kernel.org/pub/scm/linux/kernel/git/davem/net.git/commit/?h=5f3e2bf008c2221478101ee72f5cb4654b9fc363,net/ipv4/tcp_ipv4.c,tcp_sk_init,"static int __net_init tcp_sk_init(struct net *net)
{
int res, cpu, cnt;
net->ipv4.tcp_sk = alloc_percpu(struct sock *);
if (!net->ipv4.tcp_sk)
return -ENOMEM;
for_each_possible_cpu(cpu) {
struct sock *sk;
res = inet_ctl_sock_create(&sk, PF_INET, SOCK_RAW,
IPPROTO_TCP, net);
if (res)
goto fail;
sock_set_flag(sk, SOCK_USE_WRITE_QUEUE);
inet_sk(sk)->pmtudisc = IP_PMTUDISC_DO;
*per_cpu_ptr(net->ipv4.tcp_sk, cpu) = sk;
}
net->ipv4.sysctl_tcp_ecn = 2;
net->ipv4.sysctl_tcp_ecn_fallback = 1;
net->ipv4.sysctl_tcp_base_mss = TCP_BASE_MSS;
net->ipv4.sysctl_tcp_probe_threshold = TCP_PROBE_THRESHOLD;
net->ipv4.sysctl_tcp_probe_interval = TCP_PROBE_INTERVAL;
net->ipv4.sysctl_tcp_keepalive_time = TCP_KEEPALIVE_TIME;
net->ipv4.sysctl_tcp_keepalive_probes = TCP_KEEPALIVE_PROBES;
net->ipv4.sysctl_tcp_keepalive_intvl = TCP_KEEPALIVE_INTVL;
net->ipv4.sysctl_tcp_syn_retries = TCP_SYN_RETRIES;
net->ipv4.sysctl_tcp_synack_retries = TCP_SYNACK_RETRIES;
net->ipv4.sysctl_tcp_syncookies = 1;
net->ipv4.sysctl_tcp_reordering = TCP_FASTRETRANS_THRESH;
net->ipv4.sysctl_tcp_retries1 = TCP_RETR1;
net->ipv4.sysctl_tcp_retries2 = TCP_RETR2;
net->ipv4.sysctl_tcp_orphan_retries = 0;
net->ipv4.sysctl_tcp_fin_timeout = TCP_FIN_TIMEOUT;
net->ipv4.sysctl_tcp_notsent_lowat = UINT_MAX;
net->ipv4.sysctl_tcp_tw_reuse = 2;
cnt = tcp_hashinfo.ehash_mask + 1;
net->ipv4.tcp_death_row.sysctl_max_tw_buckets = cnt / 2;
net->ipv4.tcp_death_row.hashinfo = &tcp_hashinfo;
net->ipv4.sysctl_max_syn_backlog = max(128, cnt / 256);
net->ipv4.sysctl_tcp_sack = 1;
net->ipv4.sysctl_tcp_window_scaling = 1;
net->ipv4.sysctl_tcp_timestamps = 1;
net->ipv4.sysctl_tcp_early_retrans = 3;
net->ipv4.sysctl_tcp_recovery = TCP_RACK_LOSS_DETECTION;
net->ipv4.sysctl_tcp_slow_start_after_idle = 1; 
net->ipv4.sysctl_tcp_retrans_collapse = 1;
net->ipv4.sysctl_tcp_max_reordering = 300;
net->ipv4.sysctl_tcp_dsack = 1;
net->ipv4.sysctl_tcp_app_win = 31;
net->ipv4.sysctl_tcp_adv_win_scale = 1;
net->ipv4.sysctl_tcp_frto = 2;
net->ipv4.sysctl_tcp_moderate_rcvbuf = 1;
net->ipv4.sysctl_tcp_tso_win_divisor = 3;
net->ipv4.sysctl_tcp_limit_output_bytes = 16 * 65536;
net->ipv4.sysctl_tcp_challenge_ack_limit = 1000;
net->ipv4.sysctl_tcp_min_tso_segs = 2;
net->ipv4.sysctl_tcp_min_rtt_wlen = 300;
net->ipv4.sysctl_tcp_autocorking = 1;
net->ipv4.sysctl_tcp_invalid_ratelimit = HZ/2;
net->ipv4.sysctl_tcp_pacing_ss_ratio = 200;
net->ipv4.sysctl_tcp_pacing_ca_ratio = 120;
if (net != &init_net) {
memcpy(net->ipv4.sysctl_tcp_rmem,
init_net.ipv4.sysctl_tcp_rmem,
sizeof(init_net.ipv4.sysctl_tcp_rmem));
memcpy(net->ipv4.sysctl_tcp_wmem,
init_net.ipv4.sysctl_tcp_wmem,
sizeof(init_net.ipv4.sysctl_tcp_wmem));
}
net->ipv4.sysctl_tcp_comp_sack_delay_ns = NSEC_PER_MSEC;
net->ipv4.sysctl_tcp_comp_sack_nr = 44;
net->ipv4.sysctl_tcp_fastopen = TFO_CLIENT_ENABLE;
spin_lock_init(&net->ipv4.tcp_fastopen_ctx_lock);
net->ipv4.sysctl_tcp_fastopen_blackhole_timeout = 60 * 60;
atomic_set(&net->ipv4.tfo_active_disable_times, 0);
if (!net_eq(net, &init_net) &&
try_module_get(init_net.ipv4.tcp_congestion_control->owner))
net->ipv4.tcp_congestion_control = init_net.ipv4.tcp_congestion_control;
else
net->ipv4.tcp_congestion_control = &tcp_reno;
return 0;
fail:
tcp_sk_exit(net);
return res;
}","static int VAR_0 tcp_sk_init(struct net *net)
{
int VAR_1, VAR_2, VAR_3;
net->ipv4.tcp_sk = alloc_percpu(struct VAR_4 *VAR_5);
if (!net->ipv4.tcp_sk)
return -VAR_6;
for_each_possible_cpu(VAR_2) {
struct sock *VAR_7;
VAR_1 = inet_ctl_sock_create(&VAR_7, VAR_8, VAR_9,
VAR_10, net);
if (VAR_1)
goto fail;
sock_set_flag(VAR_7, VAR_11);
inet_sk(VAR_7)->pmtudisc = VAR_12;
*per_cpu_ptr(net->ipv4.tcp_sk, VAR_2) = VAR_7;
}
net->ipv4.sysctl_tcp_ecn = 2;
net->ipv4.sysctl_tcp_ecn_fallback = 1;
net->ipv4.sysctl_tcp_base_mss = VAR_13;
net->ipv4.sysctl_tcp_probe_threshold = VAR_14;
net->ipv4.sysctl_tcp_probe_interval = VAR_15;
net->ipv4.sysctl_tcp_keepalive_time = VAR_16;
net->ipv4.sysctl_tcp_keepalive_probes = VAR_17;
net->ipv4.sysctl_tcp_keepalive_intvl = VAR_18;
net->ipv4.sysctl_tcp_syn_retries = VAR_19;
net->ipv4.sysctl_tcp_synack_retries = VAR_20;
net->ipv4.sysctl_tcp_syncookies = 1;
net->ipv4.sysctl_tcp_reordering = VAR_21;
net->ipv4.sysctl_tcp_retries1 = VAR_22;
net->ipv4.sysctl_tcp_retries2 = VAR_23;
net->ipv4.sysctl_tcp_orphan_retries = 0;
net->ipv4.sysctl_tcp_fin_timeout = VAR_24;
net->ipv4.sysctl_tcp_notsent_lowat = VAR_25;
net->ipv4.sysctl_tcp_tw_reuse = 2;
VAR_3 = VAR_26.ehash_mask + 1;
net->ipv4.tcp_death_row.sysctl_max_tw_buckets = VAR_3 / 2;
net->ipv4.tcp_death_row.hashinfo = &VAR_26;
net->ipv4.sysctl_max_syn_backlog = max(128, VAR_3 / 256);
net->ipv4.sysctl_tcp_sack = 1;
net->ipv4.sysctl_tcp_window_scaling = 1;
net->ipv4.sysctl_tcp_timestamps = 1;
net->ipv4.sysctl_tcp_early_retrans = 3;
net->ipv4.sysctl_tcp_recovery = VAR_27;
net->ipv4.sysctl_tcp_slow_start_after_idle = 1; 
net->ipv4.sysctl_tcp_retrans_collapse = 1;
net->ipv4.sysctl_tcp_max_reordering = 300;
net->ipv4.sysctl_tcp_dsack = 1;
net->ipv4.sysctl_tcp_app_win = 31;
net->ipv4.sysctl_tcp_adv_win_scale = 1;
net->ipv4.sysctl_tcp_frto = 2;
net->ipv4.sysctl_tcp_moderate_rcvbuf = 1;
net->ipv4.sysctl_tcp_tso_win_divisor = 3;
net->ipv4.sysctl_tcp_limit_output_bytes = 16 * 65536;
net->ipv4.sysctl_tcp_challenge_ack_limit = 1000;
net->ipv4.sysctl_tcp_min_tso_segs = 2;
net->ipv4.sysctl_tcp_min_rtt_wlen = 300;
net->ipv4.sysctl_tcp_autocorking = 1;
net->ipv4.sysctl_tcp_invalid_ratelimit = VAR_28/2;
net->ipv4.sysctl_tcp_pacing_ss_ratio = 200;
net->ipv4.sysctl_tcp_pacing_ca_ratio = 120;
if (net != &VAR_29) {
memcpy(net->ipv4.sysctl_tcp_rmem,
VAR_29.ipv4.sysctl_tcp_rmem,
sizeof(VAR_29.ipv4.sysctl_tcp_rmem));
memcpy(net->ipv4.sysctl_tcp_wmem,
VAR_29.ipv4.sysctl_tcp_wmem,
sizeof(VAR_29.ipv4.sysctl_tcp_wmem));
}
net->ipv4.sysctl_tcp_comp_sack_delay_ns = VAR_30;
net->ipv4.sysctl_tcp_comp_sack_nr = 44;
net->ipv4.sysctl_tcp_fastopen = VAR_31;
spin_lock_init(&net->ipv4.tcp_fastopen_ctx_lock);
net->ipv4.sysctl_tcp_fastopen_blackhole_timeout = 60 * 60;
atomic_set(&net->ipv4.tfo_active_disable_times, 0);
if (!net_eq(net, &VAR_29) &&
try_module_get(VAR_29.ipv4.tcp_congestion_control->owner))
net->ipv4.tcp_congestion_control = VAR_29.ipv4.tcp_congestion_control;
else
net->ipv4.tcp_congestion_control = &VAR_32;
return 0;
fail:
tcp_sk_exit(net);
return VAR_1;
}",,"static int __net_init tcp_sk_init(struct net *net)
{
	int res, cpu, cnt;

	net->ipv4.tcp_sk = alloc_percpu(struct sock *);
	if (!net->ipv4.tcp_sk)
		return -ENOMEM;

	for_each_possible_cpu(cpu) {
		struct sock *sk;

		res = inet_ctl_sock_create(&sk, PF_INET, SOCK_RAW,
					   IPPROTO_TCP, net);
		if (res)
			goto fail;
		sock_set_flag(sk, SOCK_USE_WRITE_QUEUE);

		/* Please enforce IP_DF and IPID==0 for RST and
		 * ACK sent in SYN-RECV and TIME-WAIT state.
		 */
		inet_sk(sk)->pmtudisc = IP_PMTUDISC_DO;

		*per_cpu_ptr(net->ipv4.tcp_sk, cpu) = sk;
	}

	net->ipv4.sysctl_tcp_ecn = 2;
	net->ipv4.sysctl_tcp_ecn_fallback = 1;

	net->ipv4.sysctl_tcp_base_mss = TCP_BASE_MSS;
	net->ipv4.sysctl_tcp_min_snd_mss = TCP_MIN_SND_MSS;
	net->ipv4.sysctl_tcp_probe_threshold = TCP_PROBE_THRESHOLD;
	net->ipv4.sysctl_tcp_probe_interval = TCP_PROBE_INTERVAL;

	net->ipv4.sysctl_tcp_keepalive_time = TCP_KEEPALIVE_TIME;
	net->ipv4.sysctl_tcp_keepalive_probes = TCP_KEEPALIVE_PROBES;
	net->ipv4.sysctl_tcp_keepalive_intvl = TCP_KEEPALIVE_INTVL;

	net->ipv4.sysctl_tcp_syn_retries = TCP_SYN_RETRIES;
	net->ipv4.sysctl_tcp_synack_retries = TCP_SYNACK_RETRIES;
	net->ipv4.sysctl_tcp_syncookies = 1;
	net->ipv4.sysctl_tcp_reordering = TCP_FASTRETRANS_THRESH;
	net->ipv4.sysctl_tcp_retries1 = TCP_RETR1;
	net->ipv4.sysctl_tcp_retries2 = TCP_RETR2;
	net->ipv4.sysctl_tcp_orphan_retries = 0;
	net->ipv4.sysctl_tcp_fin_timeout = TCP_FIN_TIMEOUT;
	net->ipv4.sysctl_tcp_notsent_lowat = UINT_MAX;
	net->ipv4.sysctl_tcp_tw_reuse = 2;

	cnt = tcp_hashinfo.ehash_mask + 1;
	net->ipv4.tcp_death_row.sysctl_max_tw_buckets = cnt / 2;
	net->ipv4.tcp_death_row.hashinfo = &tcp_hashinfo;

	net->ipv4.sysctl_max_syn_backlog = max(128, cnt / 256);
	net->ipv4.sysctl_tcp_sack = 1;
	net->ipv4.sysctl_tcp_window_scaling = 1;
	net->ipv4.sysctl_tcp_timestamps = 1;
	net->ipv4.sysctl_tcp_early_retrans = 3;
	net->ipv4.sysctl_tcp_recovery = TCP_RACK_LOSS_DETECTION;
	net->ipv4.sysctl_tcp_slow_start_after_idle = 1; /* By default, RFC2861 behavior.  */
	net->ipv4.sysctl_tcp_retrans_collapse = 1;
	net->ipv4.sysctl_tcp_max_reordering = 300;
	net->ipv4.sysctl_tcp_dsack = 1;
	net->ipv4.sysctl_tcp_app_win = 31;
	net->ipv4.sysctl_tcp_adv_win_scale = 1;
	net->ipv4.sysctl_tcp_frto = 2;
	net->ipv4.sysctl_tcp_moderate_rcvbuf = 1;
	/* This limits the percentage of the congestion window which we
	 * will allow a single TSO frame to consume.  Building TSO frames
	 * which are too large can cause TCP streams to be bursty.
	 */
	net->ipv4.sysctl_tcp_tso_win_divisor = 3;
	/* Default TSQ limit of 16 TSO segments */
	net->ipv4.sysctl_tcp_limit_output_bytes = 16 * 65536;
	/* rfc5961 challenge ack rate limiting */
	net->ipv4.sysctl_tcp_challenge_ack_limit = 1000;
	net->ipv4.sysctl_tcp_min_tso_segs = 2;
	net->ipv4.sysctl_tcp_min_rtt_wlen = 300;
	net->ipv4.sysctl_tcp_autocorking = 1;
	net->ipv4.sysctl_tcp_invalid_ratelimit = HZ/2;
	net->ipv4.sysctl_tcp_pacing_ss_ratio = 200;
	net->ipv4.sysctl_tcp_pacing_ca_ratio = 120;
	if (net != &init_net) {
		memcpy(net->ipv4.sysctl_tcp_rmem,
		       init_net.ipv4.sysctl_tcp_rmem,
		       sizeof(init_net.ipv4.sysctl_tcp_rmem));
		memcpy(net->ipv4.sysctl_tcp_wmem,
		       init_net.ipv4.sysctl_tcp_wmem,
		       sizeof(init_net.ipv4.sysctl_tcp_wmem));
	}
	net->ipv4.sysctl_tcp_comp_sack_delay_ns = NSEC_PER_MSEC;
	net->ipv4.sysctl_tcp_comp_sack_nr = 44;
	net->ipv4.sysctl_tcp_fastopen = TFO_CLIENT_ENABLE;
	spin_lock_init(&net->ipv4.tcp_fastopen_ctx_lock);
	net->ipv4.sysctl_tcp_fastopen_blackhole_timeout = 60 * 60;
	atomic_set(&net->ipv4.tfo_active_disable_times, 0);

	/* Reno is always built in */
	if (!net_eq(net, &init_net) &&
	    try_module_get(init_net.ipv4.tcp_congestion_control->owner))
		net->ipv4.tcp_congestion_control = init_net.ipv4.tcp_congestion_control;
	else
		net->ipv4.tcp_congestion_control = &tcp_reno;

	return 0;
fail:
	tcp_sk_exit(net);

	return res;
}","static int VAR_0 tcp_sk_init(struct net *net)
{
	int VAR_1, VAR_2, VAR_3;

	net->ipv4.tcp_sk = alloc_percpu(struct VAR_4 *VAR_5);
	if (!net->ipv4.tcp_sk)
		return -VAR_6;

	for_each_possible_cpu(VAR_2) {
		struct sock *VAR_7;

		VAR_1 = inet_ctl_sock_create(&VAR_7, VAR_8, VAR_9,
					   VAR_10, net);
		if (VAR_1)
			goto fail;
		sock_set_flag(VAR_7, VAR_11);

		/* COMMENT_0 */
                                              
     
		inet_sk(VAR_7)->pmtudisc = VAR_12;

		*per_cpu_ptr(net->ipv4.tcp_sk, VAR_2) = VAR_7;
	}

	net->ipv4.sysctl_tcp_ecn = 2;
	net->ipv4.sysctl_tcp_ecn_fallback = 1;

	net->ipv4.sysctl_tcp_base_mss = VAR_13;
	net->ipv4.sysctl_tcp_min_snd_mss = VAR_14;
	net->ipv4.sysctl_tcp_probe_threshold = VAR_15;
	net->ipv4.sysctl_tcp_probe_interval = VAR_16;

	net->ipv4.sysctl_tcp_keepalive_time = VAR_17;
	net->ipv4.sysctl_tcp_keepalive_probes = VAR_18;
	net->ipv4.sysctl_tcp_keepalive_intvl = VAR_19;

	net->ipv4.sysctl_tcp_syn_retries = VAR_20;
	net->ipv4.sysctl_tcp_synack_retries = VAR_21;
	net->ipv4.sysctl_tcp_syncookies = 1;
	net->ipv4.sysctl_tcp_reordering = VAR_22;
	net->ipv4.sysctl_tcp_retries1 = VAR_23;
	net->ipv4.sysctl_tcp_retries2 = VAR_24;
	net->ipv4.sysctl_tcp_orphan_retries = 0;
	net->ipv4.sysctl_tcp_fin_timeout = VAR_25;
	net->ipv4.sysctl_tcp_notsent_lowat = VAR_26;
	net->ipv4.sysctl_tcp_tw_reuse = 2;

	VAR_3 = VAR_27.ehash_mask + 1;
	net->ipv4.tcp_death_row.sysctl_max_tw_buckets = VAR_3 / 2;
	net->ipv4.tcp_death_row.hashinfo = &VAR_27;

	net->ipv4.sysctl_max_syn_backlog = max(128, VAR_3 / 256);
	net->ipv4.sysctl_tcp_sack = 1;
	net->ipv4.sysctl_tcp_window_scaling = 1;
	net->ipv4.sysctl_tcp_timestamps = 1;
	net->ipv4.sysctl_tcp_early_retrans = 3;
	net->ipv4.sysctl_tcp_recovery = VAR_28;
	net->ipv4.sysctl_tcp_slow_start_after_idle = 1; /* COMMENT_3 */
	net->ipv4.sysctl_tcp_retrans_collapse = 1;
	net->ipv4.sysctl_tcp_max_reordering = 300;
	net->ipv4.sysctl_tcp_dsack = 1;
	net->ipv4.sysctl_tcp_app_win = 31;
	net->ipv4.sysctl_tcp_adv_win_scale = 1;
	net->ipv4.sysctl_tcp_frto = 2;
	net->ipv4.sysctl_tcp_moderate_rcvbuf = 1;
	/* COMMENT_4 */
                                                                  
                                                           
    
	net->ipv4.sysctl_tcp_tso_win_divisor = 3;
	/* COMMENT_8 */
	net->ipv4.sysctl_tcp_limit_output_bytes = 16 * 65536;
	/* COMMENT_9 */
	net->ipv4.sysctl_tcp_challenge_ack_limit = 1000;
	net->ipv4.sysctl_tcp_min_tso_segs = 2;
	net->ipv4.sysctl_tcp_min_rtt_wlen = 300;
	net->ipv4.sysctl_tcp_autocorking = 1;
	net->ipv4.sysctl_tcp_invalid_ratelimit = VAR_29/2;
	net->ipv4.sysctl_tcp_pacing_ss_ratio = 200;
	net->ipv4.sysctl_tcp_pacing_ca_ratio = 120;
	if (net != &VAR_30) {
		memcpy(net->ipv4.sysctl_tcp_rmem,
		       VAR_30.ipv4.sysctl_tcp_rmem,
		       sizeof(VAR_30.ipv4.sysctl_tcp_rmem));
		memcpy(net->ipv4.sysctl_tcp_wmem,
		       VAR_30.ipv4.sysctl_tcp_wmem,
		       sizeof(VAR_30.ipv4.sysctl_tcp_wmem));
	}
	net->ipv4.sysctl_tcp_comp_sack_delay_ns = VAR_31;
	net->ipv4.sysctl_tcp_comp_sack_nr = 44;
	net->ipv4.sysctl_tcp_fastopen = VAR_32;
	spin_lock_init(&net->ipv4.tcp_fastopen_ctx_lock);
	net->ipv4.sysctl_tcp_fastopen_blackhole_timeout = 60 * 60;
	atomic_set(&net->ipv4.tfo_active_disable_times, 0);

	/* COMMENT_10 */
	if (!net_eq(net, &VAR_30) &&
	    try_module_get(VAR_30.ipv4.tcp_congestion_control->owner))
		net->ipv4.tcp_congestion_control = VAR_30.ipv4.tcp_congestion_control;
	else
		net->ipv4.tcp_congestion_control = &VAR_33;

	return 0;
fail:
	tcp_sk_exit(net);

	return VAR_1;
}",,"--- func_before
+++ func_after
@@ -27,6 +27,7 @@
 	net->ipv4.sysctl_tcp_ecn_fallback = 1;
 
 	net->ipv4.sysctl_tcp_base_mss = TCP_BASE_MSS;
+	net->ipv4.sysctl_tcp_min_snd_mss = TCP_MIN_SND_MSS;
 	net->ipv4.sysctl_tcp_probe_threshold = TCP_PROBE_THRESHOLD;
 	net->ipv4.sysctl_tcp_probe_interval = TCP_PROBE_INTERVAL;
 ","{'deleted_lines': [], 'added_lines': ['\tnet->ipv4.sysctl_tcp_min_snd_mss = TCP_MIN_SND_MSS;']}",True,"Jonathan Looney discovered that the Linux kernel default MSS is hard-coded to 48 bytes. This allows a remote peer to fragment TCP resend queues significantly more than if a larger MSS were enforced. A remote attacker could use this to cause a denial of service. This has been fixed in stable kernel releases 4.4.182, 4.9.182, 4.14.127, 4.19.52, 5.1.11, and is fixed in commits 967c05aee439e6e5d7d805e195b3a20ef5c433d6 and 5f3e2bf008c2221478101ee72f5cb4654b9fc363.",7.5,HIGH,2,test,,5
CVE-2019-11479,['CWE-770'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,kernel/git/netdev/net,"Some TCP peers announce a very small MSS option in their SYN and/or
SYN/ACK messages.

This forces the stack to send packets with a very high network/cpu
overhead.

Linux has enforced a minimal value of 48. Since this value includes
the size of TCP options, and that the options can consume up to 40
bytes, this means that each segment can include only 8 bytes of payload.

In some cases, it can be useful to increase the minimal value
to a saner value.

We still let the default to 48 (TCP_MIN_SND_MSS), for compatibility
reasons.

Note that TCP_MAXSEG socket option enforces a minimal value
of (TCP_MIN_MSS). David Miller increased this minimal value
in commit c39508d6f118 (""tcp: Make TCP_MAXSEG minimum more correct."")
from 64 to 88.

We might in the future merge TCP_MIN_SND_MSS and TCP_MIN_MSS.

CVE-2019-11479 -- tcp mss hardcoded to 48

Signed-off-by: Eric Dumazet <edumazet@google.com>
Suggested-by: Jonathan Looney <jtl@netflix.com>
Acked-by: Neal Cardwell <ncardwell@google.com>
Cc: Yuchung Cheng <ycheng@google.com>
Cc: Tyler Hicks <tyhicks@canonical.com>
Cc: Bruce Curtis <brucec@netflix.com>
Cc: Jonathan Lemon <jonathan.lemon@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
",5f3e2bf008c2221478101ee72f5cb4654b9fc363,https://git.kernel.org/pub/scm/linux/kernel/git/davem/net.git/commit/?h=5f3e2bf008c2221478101ee72f5cb4654b9fc363,net/ipv4/tcp_output.c,__tcp_mtu_to_mss,"static inline int __tcp_mtu_to_mss(struct sock *sk, int pmtu)
{
const struct tcp_sock *tp = tcp_sk(sk);
const struct inet_connection_sock *icsk = inet_csk(sk);
int mss_now;
mss_now = pmtu - icsk->icsk_af_ops->net_header_len - sizeof(struct tcphdr);
if (icsk->icsk_af_ops->net_frag_header_len) {
const struct dst_entry *dst = __sk_dst_get(sk);
if (dst && dst_allfrag(dst))
mss_now -= icsk->icsk_af_ops->net_frag_header_len;
}
if (mss_now > tp->rx_opt.mss_clamp)
mss_now = tp->rx_opt.mss_clamp;
mss_now -= icsk->icsk_ext_hdr_len;
if (mss_now < TCP_MIN_SND_MSS)
mss_now = TCP_MIN_SND_MSS;
return mss_now;
}","static inline int __tcp_mtu_to_mss(struct sock *VAR_0, int VAR_1)
{
const struct tcp_sock *VAR_2 = tcp_sk(VAR_0);
const struct inet_connection_sock *VAR_3 = inet_csk(VAR_0);
int VAR_4;
VAR_4 = VAR_1 - VAR_3->icsk_af_ops->net_header_len - sizeof(struct tcphdr);
if (VAR_3->icsk_af_ops->net_frag_header_len) {
const struct dst_entry *VAR_5 = __sk_dst_get(VAR_0);
if (VAR_5 && dst_allfrag(VAR_5))
VAR_4 -= VAR_3->icsk_af_ops->net_frag_header_len;
}
if (VAR_4 > VAR_2->rx_opt.mss_clamp)
VAR_4 = VAR_2->rx_opt.mss_clamp;
VAR_4 -= VAR_3->icsk_ext_hdr_len;
if (VAR_4 < VAR_6)
VAR_4 = VAR_6;
return VAR_4;
}",kernel/git/netdev/net/5f3e2bf008c2221478101ee72f5cb4654b9fc363/tcp_output.c/vul/before/0.json,"static inline int __tcp_mtu_to_mss(struct sock *sk, int pmtu)
{
	const struct tcp_sock *tp = tcp_sk(sk);
	const struct inet_connection_sock *icsk = inet_csk(sk);
	int mss_now;

	/* Calculate base mss without TCP options:
	   It is MMS_S - sizeof(tcphdr) of rfc1122
	 */
	mss_now = pmtu - icsk->icsk_af_ops->net_header_len - sizeof(struct tcphdr);

	/* IPv6 adds a frag_hdr in case RTAX_FEATURE_ALLFRAG is set */
	if (icsk->icsk_af_ops->net_frag_header_len) {
		const struct dst_entry *dst = __sk_dst_get(sk);

		if (dst && dst_allfrag(dst))
			mss_now -= icsk->icsk_af_ops->net_frag_header_len;
	}

	/* Clamp it (mss_clamp does not include tcp options) */
	if (mss_now > tp->rx_opt.mss_clamp)
		mss_now = tp->rx_opt.mss_clamp;

	/* Now subtract optional transport overhead */
	mss_now -= icsk->icsk_ext_hdr_len;

	/* Then reserve room for full set of TCP options and 8 bytes of data */
	mss_now = max(mss_now, sock_net(sk)->ipv4.sysctl_tcp_min_snd_mss);
	return mss_now;
}","static inline int __tcp_mtu_to_mss(struct sock *VAR_0, int VAR_1)
{
	const struct tcp_sock *VAR_2 = tcp_sk(VAR_0);
	const struct inet_connection_sock *VAR_3 = inet_csk(VAR_0);
	int VAR_4;

	/* COMMENT_0 */
                                           
    
	VAR_4 = VAR_1 - VAR_3->icsk_af_ops->net_header_len - sizeof(struct tcphdr);

	/* COMMENT_3 */
	if (VAR_3->icsk_af_ops->net_frag_header_len) {
		const struct dst_entry *VAR_5 = __sk_dst_get(VAR_0);

		if (VAR_5 && dst_allfrag(VAR_5))
			VAR_4 -= VAR_3->icsk_af_ops->net_frag_header_len;
	}

	/* COMMENT_4 */
	if (VAR_4 > VAR_2->rx_opt.mss_clamp)
		VAR_4 = VAR_2->rx_opt.mss_clamp;

	/* COMMENT_5 */
	VAR_4 -= VAR_3->icsk_ext_hdr_len;

	/* COMMENT_6 */
	VAR_4 = max(VAR_4, sock_net(VAR_0)->ipv4.sysctl_tcp_min_snd_mss);
	return VAR_4;
}",kernel/git/netdev/net/5f3e2bf008c2221478101ee72f5cb4654b9fc363/tcp_output.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -25,7 +25,6 @@
 	mss_now -= icsk->icsk_ext_hdr_len;
 
 	/* Then reserve room for full set of TCP options and 8 bytes of data */
-	if (mss_now < TCP_MIN_SND_MSS)
-		mss_now = TCP_MIN_SND_MSS;
+	mss_now = max(mss_now, sock_net(sk)->ipv4.sysctl_tcp_min_snd_mss);
 	return mss_now;
 }","{'deleted_lines': ['\tif (mss_now < TCP_MIN_SND_MSS)', '\t\tmss_now = TCP_MIN_SND_MSS;'], 'added_lines': ['\tmss_now = max(mss_now, sock_net(sk)->ipv4.sysctl_tcp_min_snd_mss);']}",True,"Jonathan Looney discovered that the Linux kernel default MSS is hard-coded to 48 bytes. This allows a remote peer to fragment TCP resend queues significantly more than if a larger MSS were enforced. A remote attacker could use this to cause a denial of service. This has been fixed in stable kernel releases 4.4.182, 4.9.182, 4.14.127, 4.19.52, 5.1.11, and is fixed in commits 967c05aee439e6e5d7d805e195b3a20ef5c433d6 and 5f3e2bf008c2221478101ee72f5cb4654b9fc363.",7.5,HIGH,2,test,,5
CVE-2019-11479,['CWE-770'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,kernel/git/netdev/net,"If mtu probing is enabled tcp_mtu_probing() could very well end up
with a too small MSS.

Use the new sysctl tcp_min_snd_mss to make sure MSS search
is performed in an acceptable range.

CVE-2019-11479 -- tcp mss hardcoded to 48

Signed-off-by: Eric Dumazet <edumazet@google.com>
Reported-by: Jonathan Lemon <jonathan.lemon@gmail.com>
Cc: Jonathan Looney <jtl@netflix.com>
Acked-by: Neal Cardwell <ncardwell@google.com>
Cc: Yuchung Cheng <ycheng@google.com>
Cc: Tyler Hicks <tyhicks@canonical.com>
Cc: Bruce Curtis <brucec@netflix.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
",967c05aee439e6e5d7d805e195b3a20ef5c433d6,https://git.kernel.org/pub/scm/linux/kernel/git/davem/net.git/commit/?h=967c05aee439e6e5d7d805e195b3a20ef5c433d6,net/ipv4/tcp_timer.c,tcp_mtu_probing,"static void tcp_mtu_probing(struct inet_connection_sock *icsk, struct sock *sk)
{
const struct net *net = sock_net(sk);
int mss;
if (!net->ipv4.sysctl_tcp_mtu_probing)
return;
if (!icsk->icsk_mtup.enabled) {
icsk->icsk_mtup.enabled = 1;
icsk->icsk_mtup.probe_timestamp = tcp_jiffies32;
} else {
mss = tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_low) >> 1;
mss = min(net->ipv4.sysctl_tcp_base_mss, mss);
mss = max(mss, 68 - tcp_sk(sk)->tcp_header_len);
icsk->icsk_mtup.search_low = tcp_mss_to_mtu(sk, mss);
}
tcp_sync_mss(sk, icsk->icsk_pmtu_cookie);
}","static void tcp_mtu_probing(struct inet_connection_sock *VAR_0, struct sock *VAR_1)
{
const struct net *net = sock_net(VAR_1);
int VAR_2;
if (!net->ipv4.sysctl_tcp_mtu_probing)
return;
if (!VAR_0->icsk_mtup.enabled) {
VAR_0->icsk_mtup.enabled = 1;
VAR_0->icsk_mtup.probe_timestamp = VAR_3;
} else {
VAR_2 = tcp_mtu_to_mss(VAR_1, VAR_0->icsk_mtup.search_low) >> 1;
VAR_2 = min(net->ipv4.sysctl_tcp_base_mss, VAR_2);
VAR_2 = max(VAR_2, 68 - tcp_sk(VAR_1)->tcp_header_len);
VAR_0->icsk_mtup.search_low = tcp_mss_to_mtu(VAR_1, VAR_2);
}
tcp_sync_mss(VAR_1, VAR_0->icsk_pmtu_cookie);
}",kernel/git/netdev/net/967c05aee439e6e5d7d805e195b3a20ef5c433d6/tcp_timer.c/vul/before/0.json,"static void tcp_mtu_probing(struct inet_connection_sock *icsk, struct sock *sk)
{
	const struct net *net = sock_net(sk);
	int mss;

	/* Black hole detection */
	if (!net->ipv4.sysctl_tcp_mtu_probing)
		return;

	if (!icsk->icsk_mtup.enabled) {
		icsk->icsk_mtup.enabled = 1;
		icsk->icsk_mtup.probe_timestamp = tcp_jiffies32;
	} else {
		mss = tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_low) >> 1;
		mss = min(net->ipv4.sysctl_tcp_base_mss, mss);
		mss = max(mss, 68 - tcp_sk(sk)->tcp_header_len);
		mss = max(mss, net->ipv4.sysctl_tcp_min_snd_mss);
		icsk->icsk_mtup.search_low = tcp_mss_to_mtu(sk, mss);
	}
	tcp_sync_mss(sk, icsk->icsk_pmtu_cookie);
}","static void tcp_mtu_probing(struct inet_connection_sock *VAR_0, struct sock *VAR_1)
{
	const struct net *net = sock_net(VAR_1);
	int VAR_2;

	/* COMMENT_0 */
	if (!net->ipv4.sysctl_tcp_mtu_probing)
		return;

	if (!VAR_0->icsk_mtup.enabled) {
		VAR_0->icsk_mtup.enabled = 1;
		VAR_0->icsk_mtup.probe_timestamp = VAR_3;
	} else {
		VAR_2 = tcp_mtu_to_mss(VAR_1, VAR_0->icsk_mtup.search_low) >> 1;
		VAR_2 = min(net->ipv4.sysctl_tcp_base_mss, VAR_2);
		VAR_2 = max(VAR_2, 68 - tcp_sk(VAR_1)->tcp_header_len);
		VAR_2 = max(VAR_2, net->ipv4.sysctl_tcp_min_snd_mss);
		VAR_0->icsk_mtup.search_low = tcp_mss_to_mtu(VAR_1, VAR_2);
	}
	tcp_sync_mss(VAR_1, VAR_0->icsk_pmtu_cookie);
}",kernel/git/netdev/net/967c05aee439e6e5d7d805e195b3a20ef5c433d6/tcp_timer.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,6 +14,7 @@
 		mss = tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_low) >> 1;
 		mss = min(net->ipv4.sysctl_tcp_base_mss, mss);
 		mss = max(mss, 68 - tcp_sk(sk)->tcp_header_len);
+		mss = max(mss, net->ipv4.sysctl_tcp_min_snd_mss);
 		icsk->icsk_mtup.search_low = tcp_mss_to_mtu(sk, mss);
 	}
 	tcp_sync_mss(sk, icsk->icsk_pmtu_cookie);","{'deleted_lines': [], 'added_lines': ['\t\tmss = max(mss, net->ipv4.sysctl_tcp_min_snd_mss);']}",True,"Jonathan Looney discovered that the Linux kernel default MSS is hard-coded to 48 bytes. This allows a remote peer to fragment TCP resend queues significantly more than if a larger MSS were enforced. A remote attacker could use this to cause a denial of service. This has been fixed in stable kernel releases 4.4.182, 4.9.182, 4.14.127, 4.19.52, 5.1.11, and is fixed in commits 967c05aee439e6e5d7d805e195b3a20ef5c433d6 and 5f3e2bf008c2221478101ee72f5cb4654b9fc363.",7.5,HIGH,2,test,,5
CVE-2017-18552,['CWE-787'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"Larger than supported value can lead to array read/write overflow.

Reported-by: Colin Ian King <colin.king@canonical.com>
Signed-off-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
",780e982905bef61d13496d9af5310bf4af3a64d3,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=780e982905bef61d13496d9af5310bf4af3a64d3,net/rds/af_rds.c,rds_recv_track_latency,"static int rds_recv_track_latency(struct rds_sock *rs, char __user *optval,
int optlen)
{
struct rds_rx_trace_so trace;
int i;
if (optlen != sizeof(struct rds_rx_trace_so))
return -EFAULT;
if (copy_from_user(&trace, optval, sizeof(trace)))
return -EFAULT;
rs->rs_rx_traces = trace.rx_traces;
for (i = 0; i < rs->rs_rx_traces; i++) {
if (trace.rx_trace_pos[i] > RDS_MSG_RX_DGRAM_TRACE_MAX) {
rs->rs_rx_traces = 0;
return -EFAULT;
}
rs->rs_rx_trace[i] = trace.rx_trace_pos[i];
}
return 0;
}","static int rds_recv_track_latency(struct rds_sock *VAR_0, char __user *VAR_1,
int VAR_2)
{
struct rds_rx_trace_so VAR_3;
int VAR_4;
if (VAR_2 != sizeof(struct rds_rx_trace_so))
return -VAR_5;
if (copy_from_user(&VAR_3, VAR_1, sizeof(VAR_3)))
return -VAR_5;
VAR_0->rs_rx_traces = VAR_3.rx_traces;
for (VAR_4 = 0; VAR_4 < VAR_0->rs_rx_traces; VAR_4++) {
if (VAR_3.rx_trace_pos[VAR_4] > VAR_6) {
VAR_0->rs_rx_traces = 0;
return -VAR_5;
}
VAR_0->rs_rx_trace[VAR_4] = VAR_3.rx_trace_pos[VAR_4];
}
return 0;
}",,"static int rds_recv_track_latency(struct rds_sock *rs, char __user *optval,
				  int optlen)
{
	struct rds_rx_trace_so trace;
	int i;

	if (optlen != sizeof(struct rds_rx_trace_so))
		return -EFAULT;

	if (copy_from_user(&trace, optval, sizeof(trace)))
		return -EFAULT;

	if (trace.rx_traces > RDS_MSG_RX_DGRAM_TRACE_MAX)
		return -EFAULT;

	rs->rs_rx_traces = trace.rx_traces;
	for (i = 0; i < rs->rs_rx_traces; i++) {
		if (trace.rx_trace_pos[i] > RDS_MSG_RX_DGRAM_TRACE_MAX) {
			rs->rs_rx_traces = 0;
			return -EFAULT;
		}
		rs->rs_rx_trace[i] = trace.rx_trace_pos[i];
	}

	return 0;
}","static int rds_recv_track_latency(struct rds_sock *VAR_0, char __user *VAR_1,
				  int VAR_2)
{
	struct rds_rx_trace_so VAR_3;
	int VAR_4;

	if (VAR_2 != sizeof(struct rds_rx_trace_so))
		return -VAR_5;

	if (copy_from_user(&VAR_3, VAR_1, sizeof(VAR_3)))
		return -VAR_5;

	if (VAR_3.rx_traces > VAR_6)
		return -VAR_5;

	VAR_0->rs_rx_traces = VAR_3.rx_traces;
	for (VAR_4 = 0; VAR_4 < VAR_0->rs_rx_traces; VAR_4++) {
		if (VAR_3.rx_trace_pos[VAR_4] > VAR_6) {
			VAR_0->rs_rx_traces = 0;
			return -VAR_5;
		}
		VAR_0->rs_rx_trace[VAR_4] = VAR_3.rx_trace_pos[VAR_4];
	}

	return 0;
}",,"--- func_before
+++ func_after
@@ -8,6 +8,9 @@
 		return -EFAULT;
 
 	if (copy_from_user(&trace, optval, sizeof(trace)))
+		return -EFAULT;
+
+	if (trace.rx_traces > RDS_MSG_RX_DGRAM_TRACE_MAX)
 		return -EFAULT;
 
 	rs->rs_rx_traces = trace.rx_traces;","{'deleted_lines': [], 'added_lines': ['\t\treturn -EFAULT;', '', '\tif (trace.rx_traces > RDS_MSG_RX_DGRAM_TRACE_MAX)']}",True,An issue was discovered in net/rds/af_rds.c in the Linux kernel before 4.11. There is an out of bounds write and read in the function rds_recv_track_latency.,7.8,HIGH,2,test,,5
CVE-2019-15214,['CWE-416'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"There is a small race window in the card disconnection code that
allows the registration of another card with the very same card id.
This leads to a warning in procfs creation as caught by syzkaller.

The problem is that we delete snd_cards and snd_cards_lock entries at
the very beginning of the disconnection procedure.  This makes the
slot available to be assigned for another card object while the
disconnection procedure is being processed.  Then it becomes possible
to issue a procfs registration with the existing file name although we
check the conflict beforehand.

The fix is simply to move the snd_cards and snd_cards_lock clearances
at the end of the disconnection procedure.  The references to these
entries are merely either from the global proc files like
/proc/asound/cards or from the card registration / disconnection, so
it should be fine to shift at the very end.

Reported-by: syzbot+48df349490c36f9f54ab@syzkaller.appspotmail.com
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>
",2a3f7221acddfe1caa9ff09b3a8158c39b2fdeac,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=2a3f7221acddfe1caa9ff09b3a8158c39b2fdeac,sound/core/init.c,snd_card_disconnect,"int snd_card_disconnect(struct snd_card *card)
{
struct snd_monitor_file *mfile;
if (!card)
return -EINVAL;
spin_lock(&card->files_lock);
if (card->shutdown) {
spin_unlock(&card->files_lock);
return 0;
}
card->shutdown = 1;
spin_unlock(&card->files_lock);
mutex_lock(&snd_card_mutex);
snd_cards[card->number] = NULL;
clear_bit(card->number, snd_cards_lock);
mutex_unlock(&snd_card_mutex);
spin_lock(&card->files_lock);
list_for_each_entry(mfile, &card->files_list, list) {
mfile->disconnected_f_op = mfile->file->f_op;
spin_lock(&shutdown_lock);
list_add(&mfile->shutdown_list, &shutdown_files);
spin_unlock(&shutdown_lock);
mfile->file->f_op = &snd_shutdown_f_ops;
fops_get(mfile->file->f_op);
}
spin_unlock(&card->files_lock);
#if IS_ENABLED(CONFIG_SND_MIXER_OSS)
if (snd_mixer_oss_notify_callback)
snd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_DISCONNECT);
#endif
snd_device_disconnect_all(card);
snd_info_card_disconnect(card);
if (card->registered) {
device_del(&card->card_dev);
card->registered = false;
}
#ifdef CONFIG_PM
wake_up(&card->power_sleep);
#endif
return 0;
}","int snd_card_disconnect(struct snd_card *VAR_0)
{
struct snd_monitor_file *VAR_1;
if (!VAR_0)
return -VAR_2;
spin_lock(&VAR_0->files_lock);
if (VAR_0->shutdown) {
spin_unlock(&VAR_0->files_lock);
return 0;
}
VAR_0->shutdown = 1;
spin_unlock(&VAR_0->files_lock);
mutex_lock(&VAR_3);
VAR_4[VAR_0->number] = NULL;
clear_bit(VAR_0->number, VAR_5);
mutex_unlock(&VAR_3);
spin_lock(&VAR_0->files_lock);
list_for_each_entry(VAR_1, &VAR_0->files_list, VAR_6) {
VAR_1->disconnected_f_op = VAR_1->file->f_op;
spin_lock(&VAR_7);
list_add(&VAR_1->shutdown_list, &VAR_8);
spin_unlock(&VAR_7);
VAR_1->file->f_op = &VAR_9;
fops_get(VAR_1->file->f_op);
}
spin_unlock(&VAR_0->files_lock);
#if IS_ENABLED(VAR_10)
if (VAR_11)
VAR_11(VAR_0, VAR_12);
#endif
snd_device_disconnect_all(VAR_0);
snd_info_card_disconnect(VAR_0);
if (VAR_0->registered) {
device_del(&VAR_0->card_dev);
VAR_0->registered = false;
}
#ifdef VAR_13
wake_up(&VAR_0->power_sleep);
#endif
return 0;
}",torvalds/linux/2a3f7221acddfe1caa9ff09b3a8158c39b2fdeac/init.c/vul/before/0.json,"int snd_card_disconnect(struct snd_card *card)
{
	struct snd_monitor_file *mfile;

	if (!card)
		return -EINVAL;

	spin_lock(&card->files_lock);
	if (card->shutdown) {
		spin_unlock(&card->files_lock);
		return 0;
	}
	card->shutdown = 1;
	spin_unlock(&card->files_lock);

	/* replace file->f_op with special dummy operations */
	spin_lock(&card->files_lock);
	list_for_each_entry(mfile, &card->files_list, list) {
		/* it's critical part, use endless loop */
		/* we have no room to fail */
		mfile->disconnected_f_op = mfile->file->f_op;

		spin_lock(&shutdown_lock);
		list_add(&mfile->shutdown_list, &shutdown_files);
		spin_unlock(&shutdown_lock);

		mfile->file->f_op = &snd_shutdown_f_ops;
		fops_get(mfile->file->f_op);
	}
	spin_unlock(&card->files_lock);	

	/* notify all connected devices about disconnection */
	/* at this point, they cannot respond to any calls except release() */

#if IS_ENABLED(CONFIG_SND_MIXER_OSS)
	if (snd_mixer_oss_notify_callback)
		snd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_DISCONNECT);
#endif

	/* notify all devices that we are disconnected */
	snd_device_disconnect_all(card);

	snd_info_card_disconnect(card);
	if (card->registered) {
		device_del(&card->card_dev);
		card->registered = false;
	}

	/* disable fops (user space) operations for ALSA API */
	mutex_lock(&snd_card_mutex);
	snd_cards[card->number] = NULL;
	clear_bit(card->number, snd_cards_lock);
	mutex_unlock(&snd_card_mutex);

#ifdef CONFIG_PM
	wake_up(&card->power_sleep);
#endif
	return 0;	
}","int snd_card_disconnect(struct snd_card *VAR_0)
{
	struct snd_monitor_file *VAR_1;

	if (!VAR_0)
		return -VAR_2;

	spin_lock(&VAR_0->files_lock);
	if (VAR_0->shutdown) {
		spin_unlock(&VAR_0->files_lock);
		return 0;
	}
	VAR_0->shutdown = 1;
	spin_unlock(&VAR_0->files_lock);

	/* COMMENT_0 */
	spin_lock(&VAR_0->files_lock);
	list_for_each_entry(VAR_1, &VAR_0->files_list, VAR_3) {
		/* COMMENT_1 */
		/* COMMENT_2 */
		VAR_1->disconnected_f_op = VAR_1->file->f_op;

		spin_lock(&VAR_4);
		list_add(&VAR_1->shutdown_list, &VAR_5);
		spin_unlock(&VAR_4);

		VAR_1->file->f_op = &VAR_6;
		fops_get(VAR_1->file->f_op);
	}
	spin_unlock(&VAR_0->files_lock);	

	/* COMMENT_3 */
	/* COMMENT_4 */

#if IS_ENABLED(VAR_7)
	if (VAR_8)
		VAR_8(VAR_0, VAR_9);
#endif

	/* COMMENT_5 */
	snd_device_disconnect_all(VAR_0);

	snd_info_card_disconnect(VAR_0);
	if (VAR_0->registered) {
		device_del(&VAR_0->card_dev);
		VAR_0->registered = false;
	}

	/* COMMENT_6 */
	mutex_lock(&VAR_10);
	VAR_11[VAR_0->number] = NULL;
	clear_bit(VAR_0->number, VAR_12);
	mutex_unlock(&VAR_10);

#ifdef VAR_13
	wake_up(&VAR_0->power_sleep);
#endif
	return 0;	
}",torvalds/linux/2a3f7221acddfe1caa9ff09b3a8158c39b2fdeac/init.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,14 +13,7 @@
 	card->shutdown = 1;
 	spin_unlock(&card->files_lock);
 
-	/* phase 1: disable fops (user space) operations for ALSA API */
-	mutex_lock(&snd_card_mutex);
-	snd_cards[card->number] = NULL;
-	clear_bit(card->number, snd_cards_lock);
-	mutex_unlock(&snd_card_mutex);
-	
-	/* phase 2: replace file->f_op with special dummy operations */
-	
+	/* replace file->f_op with special dummy operations */
 	spin_lock(&card->files_lock);
 	list_for_each_entry(mfile, &card->files_list, list) {
 		/* it's critical part, use endless loop */
@@ -36,7 +29,7 @@
 	}
 	spin_unlock(&card->files_lock);	
 
-	/* phase 3: notify all connected devices about disconnection */
+	/* notify all connected devices about disconnection */
 	/* at this point, they cannot respond to any calls except release() */
 
 #if IS_ENABLED(CONFIG_SND_MIXER_OSS)
@@ -52,6 +45,13 @@
 		device_del(&card->card_dev);
 		card->registered = false;
 	}
+
+	/* disable fops (user space) operations for ALSA API */
+	mutex_lock(&snd_card_mutex);
+	snd_cards[card->number] = NULL;
+	clear_bit(card->number, snd_cards_lock);
+	mutex_unlock(&snd_card_mutex);
+
 #ifdef CONFIG_PM
 	wake_up(&card->power_sleep);
 #endif","{'deleted_lines': ['\t/* phase 1: disable fops (user space) operations for ALSA API */', '\tmutex_lock(&snd_card_mutex);', '\tsnd_cards[card->number] = NULL;', '\tclear_bit(card->number, snd_cards_lock);', '\tmutex_unlock(&snd_card_mutex);', '\t', '\t/* phase 2: replace file->f_op with special dummy operations */', '\t', '\t/* phase 3: notify all connected devices about disconnection */'], 'added_lines': ['\t/* replace file->f_op with special dummy operations */', '\t/* notify all connected devices about disconnection */', '', '\t/* disable fops (user space) operations for ALSA API */', '\tmutex_lock(&snd_card_mutex);', '\tsnd_cards[card->number] = NULL;', '\tclear_bit(card->number, snd_cards_lock);', '\tmutex_unlock(&snd_card_mutex);', '']}",True,An issue was discovered in the Linux kernel before 5.0.10. There is a use-after-free in the sound subsystem because card disconnection causes certain data structures to be deleted too early. This is related to sound/core/init.c and sound/core/info.c.,6.4,MEDIUM,1,test,,5
CVE-2019-15214,['CWE-416'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"The ALSA proc helper manages the child nodes in a linked list, but its
addition and deletion is done without any lock.  This leads to a
corruption if they are operated concurrently.  Usually this isn't a
problem because the proc entries are added sequentially in the driver
probe procedure itself.  But the card registrations are done often
asynchronously, and the crash could be actually reproduced with
syzkaller.

This patch papers over it by protecting the link addition and deletion
with the parent's mutex.  There is ""access"" mutex that is used for the
file access, and this can be reused for this purpose as well.

Reported-by: syzbot+48df349490c36f9f54ab@syzkaller.appspotmail.com
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>
",8c2f870890fd28e023b0fcf49dcee333f2c8bad7,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=8c2f870890fd28e023b0fcf49dcee333f2c8bad7,sound/core/info.c,snd_info_create_entry,"static struct snd_info_entry *
snd_info_create_entry(const char *name, struct snd_info_entry *parent,
struct module *module)
{
struct snd_info_entry *entry;
entry = kzalloc(sizeof(*entry), GFP_KERNEL);
if (entry == NULL)
return NULL;
entry->name = kstrdup(name, GFP_KERNEL);
if (entry->name == NULL) {
kfree(entry);
return NULL;
}
entry->mode = S_IFREG | 0444;
entry->content = SNDRV_INFO_CONTENT_TEXT;
mutex_init(&entry->access);
INIT_LIST_HEAD(&entry->children);
INIT_LIST_HEAD(&entry->list);
entry->parent = parent;
entry->module = module;
if (parent)
list_add_tail(&entry->list, &parent->children);
return entry;
}","static struct snd_info_entry *
snd_info_create_entry(const char *VAR_0, struct snd_info_entry *VAR_1,
struct module *module)
{
struct snd_info_entry *VAR_2;
VAR_2 = kzalloc(sizeof(*VAR_2), VAR_3);
if (VAR_2 == NULL)
return NULL;
VAR_2->name = kstrdup(VAR_0, VAR_3);
if (VAR_2->name == NULL) {
kfree(VAR_2);
return NULL;
}
VAR_2->mode = VAR_4 | 0444;
VAR_2->content = VAR_5;
mutex_init(&VAR_2->access);
INIT_LIST_HEAD(&VAR_2->children);
INIT_LIST_HEAD(&VAR_2->list);
VAR_2->parent = VAR_1;
VAR_2->module = module;
if (VAR_1)
list_add_tail(&VAR_2->list, &VAR_1->children);
return VAR_2;
}",torvalds/linux/8c2f870890fd28e023b0fcf49dcee333f2c8bad7/info.c/vul/before/0.json,"static struct snd_info_entry *
snd_info_create_entry(const char *name, struct snd_info_entry *parent,
		      struct module *module)
{
	struct snd_info_entry *entry;
	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
	if (entry == NULL)
		return NULL;
	entry->name = kstrdup(name, GFP_KERNEL);
	if (entry->name == NULL) {
		kfree(entry);
		return NULL;
	}
	entry->mode = S_IFREG | 0444;
	entry->content = SNDRV_INFO_CONTENT_TEXT;
	mutex_init(&entry->access);
	INIT_LIST_HEAD(&entry->children);
	INIT_LIST_HEAD(&entry->list);
	entry->parent = parent;
	entry->module = module;
	if (parent) {
		mutex_lock(&parent->access);
		list_add_tail(&entry->list, &parent->children);
		mutex_unlock(&parent->access);
	}
	return entry;
}","static struct snd_info_entry *
snd_info_create_entry(const char *VAR_0, struct snd_info_entry *VAR_1,
		      struct module *module)
{
	struct snd_info_entry *VAR_2;
	VAR_2 = kzalloc(sizeof(*VAR_2), VAR_3);
	if (VAR_2 == NULL)
		return NULL;
	VAR_2->name = kstrdup(VAR_0, VAR_3);
	if (VAR_2->name == NULL) {
		kfree(VAR_2);
		return NULL;
	}
	VAR_2->mode = VAR_4 | 0444;
	VAR_2->content = VAR_5;
	mutex_init(&VAR_2->access);
	INIT_LIST_HEAD(&VAR_2->children);
	INIT_LIST_HEAD(&VAR_2->list);
	VAR_2->parent = VAR_1;
	VAR_2->module = module;
	if (VAR_1) {
		mutex_lock(&VAR_1->access);
		list_add_tail(&VAR_2->list, &VAR_1->children);
		mutex_unlock(&VAR_1->access);
	}
	return VAR_2;
}",torvalds/linux/8c2f870890fd28e023b0fcf49dcee333f2c8bad7/info.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -18,7 +18,10 @@
 	INIT_LIST_HEAD(&entry->list);
 	entry->parent = parent;
 	entry->module = module;
-	if (parent)
+	if (parent) {
+		mutex_lock(&parent->access);
 		list_add_tail(&entry->list, &parent->children);
+		mutex_unlock(&parent->access);
+	}
 	return entry;
 }","{'deleted_lines': ['\tif (parent)'], 'added_lines': ['\tif (parent) {', '\t\tmutex_lock(&parent->access);', '\t\tmutex_unlock(&parent->access);', '\t}']}",True,An issue was discovered in the Linux kernel before 5.0.10. There is a use-after-free in the sound subsystem because card disconnection causes certain data structures to be deleted too early. This is related to sound/core/init.c and sound/core/info.c.,6.4,MEDIUM,1,test,,5
CVE-2019-15214,['CWE-416'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"The ALSA proc helper manages the child nodes in a linked list, but its
addition and deletion is done without any lock.  This leads to a
corruption if they are operated concurrently.  Usually this isn't a
problem because the proc entries are added sequentially in the driver
probe procedure itself.  But the card registrations are done often
asynchronously, and the crash could be actually reproduced with
syzkaller.

This patch papers over it by protecting the link addition and deletion
with the parent's mutex.  There is ""access"" mutex that is used for the
file access, and this can be reused for this purpose as well.

Reported-by: syzbot+48df349490c36f9f54ab@syzkaller.appspotmail.com
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>
",8c2f870890fd28e023b0fcf49dcee333f2c8bad7,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=8c2f870890fd28e023b0fcf49dcee333f2c8bad7,sound/core/info.c,snd_info_free_entry,"void snd_info_free_entry(struct snd_info_entry * entry)
{
struct snd_info_entry *p, *n;
if (!entry)
return;
if (entry->p) {
mutex_lock(&info_mutex);
snd_info_disconnect(entry);
mutex_unlock(&info_mutex);
}
list_for_each_entry_safe(p, n, &entry->children, list)
snd_info_free_entry(p);
list_del(&entry->list);
kfree(entry->name);
if (entry->private_free)
entry->private_free(entry);
kfree(entry);
}","void snd_info_free_entry(struct snd_info_entry * VAR_0)
{
struct snd_info_entry *VAR_1, *VAR_2;
if (!VAR_0)
return;
if (VAR_0->p) {
mutex_lock(&VAR_3);
snd_info_disconnect(VAR_0);
mutex_unlock(&VAR_3);
}
list_for_each_entry_safe(VAR_1, VAR_2, &VAR_0->children, VAR_4)
snd_info_free_entry(VAR_1);
list_del(&VAR_0->list);
kfree(VAR_0->name);
if (VAR_0->private_free)
VAR_0->private_free(VAR_0);
kfree(VAR_0);
}",torvalds/linux/8c2f870890fd28e023b0fcf49dcee333f2c8bad7/info.c/vul/before/1.json,"void snd_info_free_entry(struct snd_info_entry * entry)
{
	struct snd_info_entry *p, *n;

	if (!entry)
		return;
	if (entry->p) {
		mutex_lock(&info_mutex);
		snd_info_disconnect(entry);
		mutex_unlock(&info_mutex);
	}

	/* free all children at first */
	list_for_each_entry_safe(p, n, &entry->children, list)
		snd_info_free_entry(p);

	p = entry->parent;
	if (p) {
		mutex_lock(&p->access);
		list_del(&entry->list);
		mutex_unlock(&p->access);
	}
	kfree(entry->name);
	if (entry->private_free)
		entry->private_free(entry);
	kfree(entry);
}","void snd_info_free_entry(struct snd_info_entry * VAR_0)
{
	struct snd_info_entry *VAR_1, *VAR_2;

	if (!VAR_0)
		return;
	if (VAR_0->p) {
		mutex_lock(&VAR_3);
		snd_info_disconnect(VAR_0);
		mutex_unlock(&VAR_3);
	}

	/* COMMENT_0 */
	list_for_each_entry_safe(VAR_1, VAR_2, &VAR_0->children, VAR_4)
		snd_info_free_entry(VAR_1);

	VAR_1 = VAR_0->parent;
	if (VAR_1) {
		mutex_lock(&VAR_1->access);
		list_del(&VAR_0->list);
		mutex_unlock(&VAR_1->access);
	}
	kfree(VAR_0->name);
	if (VAR_0->private_free)
		VAR_0->private_free(VAR_0);
	kfree(VAR_0);
}",torvalds/linux/8c2f870890fd28e023b0fcf49dcee333f2c8bad7/info.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -14,7 +14,12 @@
 	list_for_each_entry_safe(p, n, &entry->children, list)
 		snd_info_free_entry(p);
 
-	list_del(&entry->list);
+	p = entry->parent;
+	if (p) {
+		mutex_lock(&p->access);
+		list_del(&entry->list);
+		mutex_unlock(&p->access);
+	}
 	kfree(entry->name);
 	if (entry->private_free)
 		entry->private_free(entry);","{'deleted_lines': ['\tlist_del(&entry->list);'], 'added_lines': ['\tp = entry->parent;', '\tif (p) {', '\t\tmutex_lock(&p->access);', '\t\tlist_del(&entry->list);', '\t\tmutex_unlock(&p->access);', '\t}']}",True,An issue was discovered in the Linux kernel before 5.0.10. There is a use-after-free in the sound subsystem because card disconnection causes certain data structures to be deleted too early. This is related to sound/core/init.c and sound/core/info.c.,6.4,MEDIUM,1,test,,5
CVE-2019-15239,['CWE-416'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"syzkaller found a reliable way to crash the host, hitting a BUG()
in __tcp_retransmit_skb()

Malicous MSG_FASTOPEN is the root cause. We need to purge write queue
in tcp_connect_init() at the point we init snd_una/write_seq.

This patch also replaces the BUG() by a less intrusive WARN_ON_ONCE()

kernel BUG at net/ipv4/tcp_output.c:2837!
invalid opcode: 0000 [#1] SMP KASAN
Dumping ftrace buffer:
   (ftrace buffer empty)
Modules linked in:
CPU: 0 PID: 5276 Comm: syz-executor0 Not tainted 4.17.0-rc3+ #51
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
RIP: 0010:__tcp_retransmit_skb+0x2992/0x2eb0 net/ipv4/tcp_output.c:2837
RSP: 0000:ffff8801dae06ff8 EFLAGS: 00010206
RAX: ffff8801b9fe61c0 RBX: 00000000ffc18a16 RCX: ffffffff864e1a49
RDX: 0000000000000100 RSI: ffffffff864e2e12 RDI: 0000000000000005
RBP: ffff8801dae073a0 R08: ffff8801b9fe61c0 R09: ffffed0039c40dd2
R10: ffffed0039c40dd2 R11: ffff8801ce206e93 R12: 00000000421eeaad
R13: ffff8801ce206d4e R14: ffff8801ce206cc0 R15: ffff8801cd4f4a80
FS:  0000000000000000(0000) GS:ffff8801dae00000(0063) knlGS:00000000096bc900
CS:  0010 DS: 002b ES: 002b CR0: 0000000080050033
CR2: 0000000020000000 CR3: 00000001c47b6000 CR4: 00000000001406f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <IRQ>
 tcp_retransmit_skb+0x2e/0x250 net/ipv4/tcp_output.c:2923
 tcp_retransmit_timer+0xc50/0x3060 net/ipv4/tcp_timer.c:488
 tcp_write_timer_handler+0x339/0x960 net/ipv4/tcp_timer.c:573
 tcp_write_timer+0x111/0x1d0 net/ipv4/tcp_timer.c:593
 call_timer_fn+0x230/0x940 kernel/time/timer.c:1326
 expire_timers kernel/time/timer.c:1363 [inline]
 __run_timers+0x79e/0xc50 kernel/time/timer.c:1666
 run_timer_softirq+0x4c/0x70 kernel/time/timer.c:1692
 __do_softirq+0x2e0/0xaf5 kernel/softirq.c:285
 invoke_softirq kernel/softirq.c:365 [inline]
 irq_exit+0x1d1/0x200 kernel/softirq.c:405
 exiting_irq arch/x86/include/asm/apic.h:525 [inline]
 smp_apic_timer_interrupt+0x17e/0x710 arch/x86/kernel/apic/apic.c:1052
 apic_timer_interrupt+0xf/0x20 arch/x86/entry/entry_64.S:863

Fixes: cf60af03ca4e (""net-tcp: Fast Open client - sendmsg(MSG_FASTOPEN)"")
Signed-off-by: Eric Dumazet <edumazet@google.com>
Cc: Yuchung Cheng <ycheng@google.com>
Cc: Neal Cardwell <ncardwell@google.com>
Reported-by: syzbot <syzkaller@googlegroups.com>
Acked-by: Neal Cardwell <ncardwell@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
",7f582b248d0a86bae5788c548d7bb5bca6f7691a,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=7f582b248d0a86bae5788c548d7bb5bca6f7691a,net/ipv4/tcp_output.c,__tcp_retransmit_skb,"int __tcp_retransmit_skb(struct sock *sk, struct sk_buff *skb, int segs)
{
struct inet_connection_sock *icsk = inet_csk(sk);
struct tcp_sock *tp = tcp_sk(sk);
unsigned int cur_mss;
int diff, len, err;
if (icsk->icsk_mtup.probe_size)
icsk->icsk_mtup.probe_size = 0;
if (refcount_read(&sk->sk_wmem_alloc) >
min_t(u32, sk->sk_wmem_queued + (sk->sk_wmem_queued >> 2),
sk->sk_sndbuf))
return -EAGAIN;
if (skb_still_in_host_queue(sk, skb))
return -EBUSY;
if (before(TCP_SKB_CB(skb)->seq, tp->snd_una)) {
if (before(TCP_SKB_CB(skb)->end_seq, tp->snd_una))
BUG();
if (tcp_trim_head(sk, skb, tp->snd_una - TCP_SKB_CB(skb)->seq))
return -ENOMEM;
}
if (inet_csk(sk)->icsk_af_ops->rebuild_header(sk))
return -EHOSTUNREACH; 
cur_mss = tcp_current_mss(sk);
if (!before(TCP_SKB_CB(skb)->seq, tcp_wnd_end(tp)) &&
TCP_SKB_CB(skb)->seq != tp->snd_una)
return -EAGAIN;
len = cur_mss * segs;
if (skb->len > len) {
if (tcp_fragment(sk, TCP_FRAG_IN_RTX_QUEUE, skb, len,
cur_mss, GFP_ATOMIC))
return -ENOMEM; 
} else {
if (skb_unclone(skb, GFP_ATOMIC))
return -ENOMEM;
diff = tcp_skb_pcount(skb);
tcp_set_skb_tso_segs(skb, cur_mss);
diff -= tcp_skb_pcount(skb);
if (diff)
tcp_adjust_pcount(sk, skb, diff);
if (skb->len < cur_mss)
tcp_retrans_try_collapse(sk, skb, cur_mss);
}
if ((TCP_SKB_CB(skb)->tcp_flags & TCPHDR_SYN_ECN) == TCPHDR_SYN_ECN)
tcp_ecn_clear_syn(sk, skb);
segs = tcp_skb_pcount(skb);
TCP_ADD_STATS(sock_net(sk), TCP_MIB_RETRANSSEGS, segs);
if (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_SYN)
__NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPSYNRETRANS);
tp->total_retrans += segs;
if (unlikely((NET_IP_ALIGN && ((unsigned long)skb->data & 3)) ||
skb_headroom(skb) >= 0xFFFF)) {
struct sk_buff *nskb;
tcp_skb_tsorted_save(skb) {
nskb = __pskb_copy(skb, MAX_TCP_HEADER, GFP_ATOMIC);
err = nskb ? tcp_transmit_skb(sk, nskb, 0, GFP_ATOMIC) :
-ENOBUFS;
} tcp_skb_tsorted_restore(skb);
if (!err) {
tcp_update_skb_after_send(tp, skb);
tcp_rate_skb_sent(sk, skb);
}
} else {
err = tcp_transmit_skb(sk, skb, 1, GFP_ATOMIC);
}
if (BPF_SOCK_OPS_TEST_FLAG(tp, BPF_SOCK_OPS_RETRANS_CB_FLAG))
tcp_call_bpf_3arg(sk, BPF_SOCK_OPS_RETRANS_CB,
TCP_SKB_CB(skb)->seq, segs, err);
if (likely(!err)) {
TCP_SKB_CB(skb)->sacked |= TCPCB_EVER_RETRANS;
trace_tcp_retransmit_skb(sk, skb);
} else if (err != -EBUSY) {
NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPRETRANSFAIL);
}
return err;
}","int __tcp_retransmit_skb(struct sock *VAR_0, struct sk_buff *VAR_1, int VAR_2)
{
struct inet_connection_sock *VAR_3 = inet_csk(VAR_0);
struct tcp_sock *VAR_4 = tcp_sk(VAR_0);
unsigned int VAR_5;
int VAR_6, VAR_7, VAR_8;
if (VAR_3->icsk_mtup.probe_size)
VAR_3->icsk_mtup.probe_size = 0;
if (refcount_read(&VAR_0->sk_wmem_alloc) >
min_t(VAR_9, VAR_0->sk_wmem_queued + (VAR_0->sk_wmem_queued >> 2),
VAR_0->sk_sndbuf))
return -VAR_10;
if (skb_still_in_host_queue(VAR_0, VAR_1))
return -VAR_11;
if (before(TCP_SKB_CB(VAR_1)->seq, VAR_4->snd_una)) {
if (before(TCP_SKB_CB(VAR_1)->end_seq, VAR_4->snd_una))
BUG();
if (tcp_trim_head(VAR_0, VAR_1, VAR_4->snd_una - TCP_SKB_CB(VAR_1)->seq))
return -VAR_12;
}
if (inet_csk(VAR_0)->icsk_af_ops->rebuild_header(VAR_0))
return -VAR_13; 
VAR_5 = tcp_current_mss(VAR_0);
if (!before(TCP_SKB_CB(VAR_1)->seq, tcp_wnd_end(VAR_4)) &&
TCP_SKB_CB(VAR_1)->seq != VAR_4->snd_una)
return -VAR_10;
VAR_7 = VAR_5 * VAR_2;
if (VAR_1->len > VAR_7) {
if (tcp_fragment(VAR_0, VAR_14, VAR_1, VAR_7,
VAR_5, VAR_15))
return -VAR_12; 
} else {
if (skb_unclone(VAR_1, VAR_15))
return -VAR_12;
VAR_6 = tcp_skb_pcount(VAR_1);
tcp_set_skb_tso_segs(VAR_1, VAR_5);
VAR_6 -= tcp_skb_pcount(VAR_1);
if (VAR_6)
tcp_adjust_pcount(VAR_0, VAR_1, VAR_6);
if (VAR_1->len < VAR_5)
tcp_retrans_try_collapse(VAR_0, VAR_1, VAR_5);
}
if ((TCP_SKB_CB(VAR_1)->tcp_flags & VAR_16) == VAR_16)
tcp_ecn_clear_syn(VAR_0, VAR_1);
VAR_2 = tcp_skb_pcount(VAR_1);
TCP_ADD_STATS(sock_net(VAR_0), VAR_17, VAR_2);
if (TCP_SKB_CB(VAR_1)->tcp_flags & VAR_18)
__NET_INC_STATS(sock_net(VAR_0), VAR_19);
VAR_4->total_retrans += VAR_2;
if (unlikely((VAR_20 && ((unsigned long)VAR_1->data & 3)) ||
skb_headroom(VAR_1) >= 0xFFFF)) {
struct sk_buff *VAR_21;
tcp_skb_tsorted_save(VAR_1) {
VAR_21 = __pskb_copy(VAR_1, VAR_22, VAR_15);
VAR_8 = VAR_21 ? tcp_transmit_skb(VAR_0, VAR_21, 0, VAR_15) :
-VAR_23;
} tcp_skb_tsorted_restore(VAR_1);
if (!VAR_8) {
tcp_update_skb_after_send(VAR_4, VAR_1);
tcp_rate_skb_sent(VAR_0, VAR_1);
}
} else {
VAR_8 = tcp_transmit_skb(VAR_0, VAR_1, 1, VAR_15);
}
if (BPF_SOCK_OPS_TEST_FLAG(VAR_4, VAR_24))
tcp_call_bpf_3arg(VAR_0, VAR_25,
TCP_SKB_CB(VAR_1)->seq, VAR_2, VAR_8);
if (likely(!VAR_8)) {
TCP_SKB_CB(VAR_1)->sacked |= VAR_26;
trace_tcp_retransmit_skb(VAR_0, VAR_1);
} else if (VAR_8 != -VAR_11) {
NET_INC_STATS(sock_net(VAR_0), VAR_27);
}
return VAR_8;
}",torvalds/linux/7f582b248d0a86bae5788c548d7bb5bca6f7691a/tcp_output.c/vul/before/0.json,"int __tcp_retransmit_skb(struct sock *sk, struct sk_buff *skb, int segs)
{
	struct inet_connection_sock *icsk = inet_csk(sk);
	struct tcp_sock *tp = tcp_sk(sk);
	unsigned int cur_mss;
	int diff, len, err;


	/* Inconclusive MTU probe */
	if (icsk->icsk_mtup.probe_size)
		icsk->icsk_mtup.probe_size = 0;

	/* Do not sent more than we queued. 1/4 is reserved for possible
	 * copying overhead: fragmentation, tunneling, mangling etc.
	 */
	if (refcount_read(&sk->sk_wmem_alloc) >
	    min_t(u32, sk->sk_wmem_queued + (sk->sk_wmem_queued >> 2),
		  sk->sk_sndbuf))
		return -EAGAIN;

	if (skb_still_in_host_queue(sk, skb))
		return -EBUSY;

	if (before(TCP_SKB_CB(skb)->seq, tp->snd_una)) {
		if (unlikely(before(TCP_SKB_CB(skb)->end_seq, tp->snd_una))) {
			WARN_ON_ONCE(1);
			return -EINVAL;
		}
		if (tcp_trim_head(sk, skb, tp->snd_una - TCP_SKB_CB(skb)->seq))
			return -ENOMEM;
	}

	if (inet_csk(sk)->icsk_af_ops->rebuild_header(sk))
		return -EHOSTUNREACH; /* Routing failure or similar. */

	cur_mss = tcp_current_mss(sk);

	/* If receiver has shrunk his window, and skb is out of
	 * new window, do not retransmit it. The exception is the
	 * case, when window is shrunk to zero. In this case
	 * our retransmit serves as a zero window probe.
	 */
	if (!before(TCP_SKB_CB(skb)->seq, tcp_wnd_end(tp)) &&
	    TCP_SKB_CB(skb)->seq != tp->snd_una)
		return -EAGAIN;

	len = cur_mss * segs;
	if (skb->len > len) {
		if (tcp_fragment(sk, TCP_FRAG_IN_RTX_QUEUE, skb, len,
				 cur_mss, GFP_ATOMIC))
			return -ENOMEM; /* We'll try again later. */
	} else {
		if (skb_unclone(skb, GFP_ATOMIC))
			return -ENOMEM;

		diff = tcp_skb_pcount(skb);
		tcp_set_skb_tso_segs(skb, cur_mss);
		diff -= tcp_skb_pcount(skb);
		if (diff)
			tcp_adjust_pcount(sk, skb, diff);
		if (skb->len < cur_mss)
			tcp_retrans_try_collapse(sk, skb, cur_mss);
	}

	/* RFC3168, section 6.1.1.1. ECN fallback */
	if ((TCP_SKB_CB(skb)->tcp_flags & TCPHDR_SYN_ECN) == TCPHDR_SYN_ECN)
		tcp_ecn_clear_syn(sk, skb);

	/* Update global and local TCP statistics. */
	segs = tcp_skb_pcount(skb);
	TCP_ADD_STATS(sock_net(sk), TCP_MIB_RETRANSSEGS, segs);
	if (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_SYN)
		__NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPSYNRETRANS);
	tp->total_retrans += segs;

	/* make sure skb->data is aligned on arches that require it
	 * and check if ack-trimming & collapsing extended the headroom
	 * beyond what csum_start can cover.
	 */
	if (unlikely((NET_IP_ALIGN && ((unsigned long)skb->data & 3)) ||
		     skb_headroom(skb) >= 0xFFFF)) {
		struct sk_buff *nskb;

		tcp_skb_tsorted_save(skb) {
			nskb = __pskb_copy(skb, MAX_TCP_HEADER, GFP_ATOMIC);
			err = nskb ? tcp_transmit_skb(sk, nskb, 0, GFP_ATOMIC) :
				     -ENOBUFS;
		} tcp_skb_tsorted_restore(skb);

		if (!err) {
			tcp_update_skb_after_send(tp, skb);
			tcp_rate_skb_sent(sk, skb);
		}
	} else {
		err = tcp_transmit_skb(sk, skb, 1, GFP_ATOMIC);
	}

	if (BPF_SOCK_OPS_TEST_FLAG(tp, BPF_SOCK_OPS_RETRANS_CB_FLAG))
		tcp_call_bpf_3arg(sk, BPF_SOCK_OPS_RETRANS_CB,
				  TCP_SKB_CB(skb)->seq, segs, err);

	if (likely(!err)) {
		TCP_SKB_CB(skb)->sacked |= TCPCB_EVER_RETRANS;
		trace_tcp_retransmit_skb(sk, skb);
	} else if (err != -EBUSY) {
		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPRETRANSFAIL);
	}
	return err;
}","int __tcp_retransmit_skb(struct sock *VAR_0, struct sk_buff *VAR_1, int VAR_2)
{
	struct inet_connection_sock *VAR_3 = inet_csk(VAR_0);
	struct tcp_sock *VAR_4 = tcp_sk(VAR_0);
	unsigned int VAR_5;
	int VAR_6, VAR_7, VAR_8;


	/* COMMENT_0 */
	if (VAR_3->icsk_mtup.probe_size)
		VAR_3->icsk_mtup.probe_size = 0;

	/* COMMENT_1 */
                                                             
    
	if (refcount_read(&VAR_0->sk_wmem_alloc) >
	    min_t(VAR_9, VAR_0->sk_wmem_queued + (VAR_0->sk_wmem_queued >> 2),
		  VAR_0->sk_sndbuf))
		return -VAR_10;

	if (skb_still_in_host_queue(VAR_0, VAR_1))
		return -VAR_11;

	if (before(TCP_SKB_CB(VAR_1)->seq, VAR_4->snd_una)) {
		if (unlikely(before(TCP_SKB_CB(VAR_1)->end_seq, VAR_4->snd_una))) {
			WARN_ON_ONCE(1);
			return -VAR_12;
		}
		if (tcp_trim_head(VAR_0, VAR_1, VAR_4->snd_una - TCP_SKB_CB(VAR_1)->seq))
			return -VAR_13;
	}

	if (inet_csk(VAR_0)->icsk_af_ops->rebuild_header(VAR_0))
		return -VAR_14; /* COMMENT_4 */

	VAR_5 = tcp_current_mss(VAR_0);

	/* COMMENT_5 */
                                                          
                                                     
                                                 
    
	if (!before(TCP_SKB_CB(VAR_1)->seq, tcp_wnd_end(VAR_4)) &&
	    TCP_SKB_CB(VAR_1)->seq != VAR_4->snd_una)
		return -VAR_10;

	VAR_7 = VAR_5 * VAR_2;
	if (VAR_1->len > VAR_7) {
		if (tcp_fragment(VAR_0, VAR_15, VAR_1, VAR_7,
				 VAR_5, VAR_16))
			return -VAR_13; /* COMMENT_10 */
	} else {
		if (skb_unclone(VAR_1, VAR_16))
			return -VAR_13;

		VAR_6 = tcp_skb_pcount(VAR_1);
		tcp_set_skb_tso_segs(VAR_1, VAR_5);
		VAR_6 -= tcp_skb_pcount(VAR_1);
		if (VAR_6)
			tcp_adjust_pcount(VAR_0, VAR_1, VAR_6);
		if (VAR_1->len < VAR_5)
			tcp_retrans_try_collapse(VAR_0, VAR_1, VAR_5);
	}

	/* COMMENT_11 */
	if ((TCP_SKB_CB(VAR_1)->tcp_flags & VAR_17) == VAR_17)
		tcp_ecn_clear_syn(VAR_0, VAR_1);

	/* COMMENT_12 */
	VAR_2 = tcp_skb_pcount(VAR_1);
	TCP_ADD_STATS(sock_net(VAR_0), VAR_18, VAR_2);
	if (TCP_SKB_CB(VAR_1)->tcp_flags & VAR_19)
		__NET_INC_STATS(sock_net(VAR_0), VAR_20);
	VAR_4->total_retrans += VAR_2;

	/* COMMENT_13 */
                                                                
                                     
    
	if (unlikely((VAR_21 && ((unsigned long)VAR_1->data & 3)) ||
		     skb_headroom(VAR_1) >= 0xFFFF)) {
		struct sk_buff *VAR_22;

		tcp_skb_tsorted_save(VAR_1) {
			VAR_22 = __pskb_copy(VAR_1, VAR_23, VAR_16);
			VAR_8 = VAR_22 ? tcp_transmit_skb(VAR_0, VAR_22, 0, VAR_16) :
				     -VAR_24;
		} tcp_skb_tsorted_restore(VAR_1);

		if (!VAR_8) {
			tcp_update_skb_after_send(VAR_4, VAR_1);
			tcp_rate_skb_sent(VAR_0, VAR_1);
		}
	} else {
		VAR_8 = tcp_transmit_skb(VAR_0, VAR_1, 1, VAR_16);
	}

	if (BPF_SOCK_OPS_TEST_FLAG(VAR_4, VAR_25))
		tcp_call_bpf_3arg(VAR_0, VAR_26,
				  TCP_SKB_CB(VAR_1)->seq, VAR_2, VAR_8);

	if (likely(!VAR_8)) {
		TCP_SKB_CB(VAR_1)->sacked |= VAR_27;
		trace_tcp_retransmit_skb(VAR_0, VAR_1);
	} else if (VAR_8 != -VAR_11) {
		NET_INC_STATS(sock_net(VAR_0), VAR_28);
	}
	return VAR_8;
}",torvalds/linux/7f582b248d0a86bae5788c548d7bb5bca6f7691a/tcp_output.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -22,8 +22,10 @@
 		return -EBUSY;
 
 	if (before(TCP_SKB_CB(skb)->seq, tp->snd_una)) {
-		if (before(TCP_SKB_CB(skb)->end_seq, tp->snd_una))
-			BUG();
+		if (unlikely(before(TCP_SKB_CB(skb)->end_seq, tp->snd_una))) {
+			WARN_ON_ONCE(1);
+			return -EINVAL;
+		}
 		if (tcp_trim_head(sk, skb, tp->snd_una - TCP_SKB_CB(skb)->seq))
 			return -ENOMEM;
 	}","{'deleted_lines': ['\t\tif (before(TCP_SKB_CB(skb)->end_seq, tp->snd_una))', '\t\t\tBUG();'], 'added_lines': ['\t\tif (unlikely(before(TCP_SKB_CB(skb)->end_seq, tp->snd_una))) {', '\t\t\tWARN_ON_ONCE(1);', '\t\t\treturn -EINVAL;', '\t\t}']}",True,"In the Linux kernel, a certain net/ipv4/tcp_output.c change, which was properly incorporated into 4.16.12, was incorrectly backported to the earlier longterm kernels, introducing a new vulnerability that was potentially more severe than the issue that was intended to be fixed by backporting. Specifically, by adding to a write queue between disconnection and re-connection, a local attacker can trigger multiple use-after-free conditions. This can result in a kernel crash, or potentially in privilege escalation. NOTE: this affects (for example) Linux distributions that use 4.9.x longterm kernels before 4.9.190 or 4.14.x longterm kernels before 4.14.139.",7.8,HIGH,2,test,,5
CVE-2019-15239,['CWE-416'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"syzkaller found a reliable way to crash the host, hitting a BUG()
in __tcp_retransmit_skb()

Malicous MSG_FASTOPEN is the root cause. We need to purge write queue
in tcp_connect_init() at the point we init snd_una/write_seq.

This patch also replaces the BUG() by a less intrusive WARN_ON_ONCE()

kernel BUG at net/ipv4/tcp_output.c:2837!
invalid opcode: 0000 [#1] SMP KASAN
Dumping ftrace buffer:
   (ftrace buffer empty)
Modules linked in:
CPU: 0 PID: 5276 Comm: syz-executor0 Not tainted 4.17.0-rc3+ #51
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
RIP: 0010:__tcp_retransmit_skb+0x2992/0x2eb0 net/ipv4/tcp_output.c:2837
RSP: 0000:ffff8801dae06ff8 EFLAGS: 00010206
RAX: ffff8801b9fe61c0 RBX: 00000000ffc18a16 RCX: ffffffff864e1a49
RDX: 0000000000000100 RSI: ffffffff864e2e12 RDI: 0000000000000005
RBP: ffff8801dae073a0 R08: ffff8801b9fe61c0 R09: ffffed0039c40dd2
R10: ffffed0039c40dd2 R11: ffff8801ce206e93 R12: 00000000421eeaad
R13: ffff8801ce206d4e R14: ffff8801ce206cc0 R15: ffff8801cd4f4a80
FS:  0000000000000000(0000) GS:ffff8801dae00000(0063) knlGS:00000000096bc900
CS:  0010 DS: 002b ES: 002b CR0: 0000000080050033
CR2: 0000000020000000 CR3: 00000001c47b6000 CR4: 00000000001406f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <IRQ>
 tcp_retransmit_skb+0x2e/0x250 net/ipv4/tcp_output.c:2923
 tcp_retransmit_timer+0xc50/0x3060 net/ipv4/tcp_timer.c:488
 tcp_write_timer_handler+0x339/0x960 net/ipv4/tcp_timer.c:573
 tcp_write_timer+0x111/0x1d0 net/ipv4/tcp_timer.c:593
 call_timer_fn+0x230/0x940 kernel/time/timer.c:1326
 expire_timers kernel/time/timer.c:1363 [inline]
 __run_timers+0x79e/0xc50 kernel/time/timer.c:1666
 run_timer_softirq+0x4c/0x70 kernel/time/timer.c:1692
 __do_softirq+0x2e0/0xaf5 kernel/softirq.c:285
 invoke_softirq kernel/softirq.c:365 [inline]
 irq_exit+0x1d1/0x200 kernel/softirq.c:405
 exiting_irq arch/x86/include/asm/apic.h:525 [inline]
 smp_apic_timer_interrupt+0x17e/0x710 arch/x86/kernel/apic/apic.c:1052
 apic_timer_interrupt+0xf/0x20 arch/x86/entry/entry_64.S:863

Fixes: cf60af03ca4e (""net-tcp: Fast Open client - sendmsg(MSG_FASTOPEN)"")
Signed-off-by: Eric Dumazet <edumazet@google.com>
Cc: Yuchung Cheng <ycheng@google.com>
Cc: Neal Cardwell <ncardwell@google.com>
Reported-by: syzbot <syzkaller@googlegroups.com>
Acked-by: Neal Cardwell <ncardwell@google.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
",7f582b248d0a86bae5788c548d7bb5bca6f7691a,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=7f582b248d0a86bae5788c548d7bb5bca6f7691a,net/ipv4/tcp_output.c,tcp_connect_init,"static void tcp_connect_init(struct sock *sk)
{
const struct dst_entry *dst = __sk_dst_get(sk);
struct tcp_sock *tp = tcp_sk(sk);
__u8 rcv_wscale;
u32 rcv_wnd;
tp->tcp_header_len = sizeof(struct tcphdr);
if (sock_net(sk)->ipv4.sysctl_tcp_timestamps)
tp->tcp_header_len += TCPOLEN_TSTAMP_ALIGNED;
#ifdef CONFIG_TCP_MD5SIG
if (tp->af_specific->md5_lookup(sk, sk))
tp->tcp_header_len += TCPOLEN_MD5SIG_ALIGNED;
#endif
if (tp->rx_opt.user_mss)
tp->rx_opt.mss_clamp = tp->rx_opt.user_mss;
tp->max_window = 0;
tcp_mtup_init(sk);
tcp_sync_mss(sk, dst_mtu(dst));
tcp_ca_dst_init(sk, dst);
if (!tp->window_clamp)
tp->window_clamp = dst_metric(dst, RTAX_WINDOW);
tp->advmss = tcp_mss_clamp(tp, dst_metric_advmss(dst));
tcp_initialize_rcv_mss(sk);
if (sk->sk_userlocks & SOCK_RCVBUF_LOCK &&
(tp->window_clamp > tcp_full_space(sk) || tp->window_clamp == 0))
tp->window_clamp = tcp_full_space(sk);
rcv_wnd = tcp_rwnd_init_bpf(sk);
if (rcv_wnd == 0)
rcv_wnd = dst_metric(dst, RTAX_INITRWND);
tcp_select_initial_window(sk, tcp_full_space(sk),
tp->advmss - (tp->rx_opt.ts_recent_stamp ? tp->tcp_header_len - sizeof(struct tcphdr) : 0),
&tp->rcv_wnd,
&tp->window_clamp,
sock_net(sk)->ipv4.sysctl_tcp_window_scaling,
&rcv_wscale,
rcv_wnd);
tp->rx_opt.rcv_wscale = rcv_wscale;
tp->rcv_ssthresh = tp->rcv_wnd;
sk->sk_err = 0;
sock_reset_flag(sk, SOCK_DONE);
tp->snd_wnd = 0;
tcp_init_wl(tp, 0);
tp->snd_una = tp->write_seq;
tp->snd_sml = tp->write_seq;
tp->snd_up = tp->write_seq;
tp->snd_nxt = tp->write_seq;
if (likely(!tp->repair))
tp->rcv_nxt = 0;
else
tp->rcv_tstamp = tcp_jiffies32;
tp->rcv_wup = tp->rcv_nxt;
tp->copied_seq = tp->rcv_nxt;
inet_csk(sk)->icsk_rto = tcp_timeout_init(sk);
inet_csk(sk)->icsk_retransmits = 0;
tcp_clear_retrans(tp);
}","static void tcp_connect_init(struct sock *VAR_0)
{
const struct dst_entry *VAR_1 = __sk_dst_get(VAR_0);
struct tcp_sock *VAR_2 = tcp_sk(VAR_0);
__u8 VAR_3;
u32 VAR_4;
VAR_2->tcp_header_len = sizeof(struct tcphdr);
if (sock_net(VAR_0)->ipv4.sysctl_tcp_timestamps)
VAR_2->tcp_header_len += VAR_5;
#ifdef VAR_6
if (VAR_2->af_specific->md5_lookup(VAR_0, VAR_0))
VAR_2->tcp_header_len += VAR_7;
#endif
if (VAR_2->rx_opt.user_mss)
VAR_2->rx_opt.mss_clamp = VAR_2->rx_opt.user_mss;
VAR_2->max_window = 0;
tcp_mtup_init(VAR_0);
tcp_sync_mss(VAR_0, dst_mtu(VAR_1));
tcp_ca_dst_init(VAR_0, VAR_1);
if (!VAR_2->window_clamp)
VAR_2->window_clamp = dst_metric(VAR_1, VAR_8);
VAR_2->advmss = tcp_mss_clamp(VAR_2, dst_metric_advmss(VAR_1));
tcp_initialize_rcv_mss(VAR_0);
if (VAR_0->sk_userlocks & VAR_9 &&
(VAR_2->window_clamp > tcp_full_space(VAR_0) || VAR_2->window_clamp == 0))
VAR_2->window_clamp = tcp_full_space(VAR_0);
VAR_4 = tcp_rwnd_init_bpf(VAR_0);
if (VAR_4 == 0)
VAR_4 = dst_metric(VAR_1, VAR_10);
tcp_select_initial_window(VAR_0, tcp_full_space(VAR_0),
VAR_2->advmss - (VAR_2->rx_opt.ts_recent_stamp ? VAR_2->tcp_header_len - sizeof(struct tcphdr) : 0),
&VAR_2->rcv_wnd,
&VAR_2->window_clamp,
sock_net(VAR_0)->ipv4.sysctl_tcp_window_scaling,
&VAR_3,
VAR_4);
VAR_2->rx_opt.rcv_wscale = VAR_3;
VAR_2->rcv_ssthresh = VAR_2->rcv_wnd;
VAR_0->sk_err = 0;
sock_reset_flag(VAR_0, VAR_11);
VAR_2->snd_wnd = 0;
tcp_init_wl(VAR_2, 0);
VAR_2->snd_una = VAR_2->write_seq;
VAR_2->snd_sml = VAR_2->write_seq;
VAR_2->snd_up = VAR_2->write_seq;
VAR_2->snd_nxt = VAR_2->write_seq;
if (likely(!VAR_2->repair))
VAR_2->rcv_nxt = 0;
else
VAR_2->rcv_tstamp = VAR_12;
VAR_2->rcv_wup = VAR_2->rcv_nxt;
VAR_2->copied_seq = VAR_2->rcv_nxt;
inet_csk(VAR_0)->icsk_rto = tcp_timeout_init(VAR_0);
inet_csk(VAR_0)->icsk_retransmits = 0;
tcp_clear_retrans(VAR_2);
}",torvalds/linux/7f582b248d0a86bae5788c548d7bb5bca6f7691a/tcp_output.c/vul/before/1.json,"static void tcp_connect_init(struct sock *sk)
{
	const struct dst_entry *dst = __sk_dst_get(sk);
	struct tcp_sock *tp = tcp_sk(sk);
	__u8 rcv_wscale;
	u32 rcv_wnd;

	/* We'll fix this up when we get a response from the other end.
	 * See tcp_input.c:tcp_rcv_state_process case TCP_SYN_SENT.
	 */
	tp->tcp_header_len = sizeof(struct tcphdr);
	if (sock_net(sk)->ipv4.sysctl_tcp_timestamps)
		tp->tcp_header_len += TCPOLEN_TSTAMP_ALIGNED;

#ifdef CONFIG_TCP_MD5SIG
	if (tp->af_specific->md5_lookup(sk, sk))
		tp->tcp_header_len += TCPOLEN_MD5SIG_ALIGNED;
#endif

	/* If user gave his TCP_MAXSEG, record it to clamp */
	if (tp->rx_opt.user_mss)
		tp->rx_opt.mss_clamp = tp->rx_opt.user_mss;
	tp->max_window = 0;
	tcp_mtup_init(sk);
	tcp_sync_mss(sk, dst_mtu(dst));

	tcp_ca_dst_init(sk, dst);

	if (!tp->window_clamp)
		tp->window_clamp = dst_metric(dst, RTAX_WINDOW);
	tp->advmss = tcp_mss_clamp(tp, dst_metric_advmss(dst));

	tcp_initialize_rcv_mss(sk);

	/* limit the window selection if the user enforce a smaller rx buffer */
	if (sk->sk_userlocks & SOCK_RCVBUF_LOCK &&
	    (tp->window_clamp > tcp_full_space(sk) || tp->window_clamp == 0))
		tp->window_clamp = tcp_full_space(sk);

	rcv_wnd = tcp_rwnd_init_bpf(sk);
	if (rcv_wnd == 0)
		rcv_wnd = dst_metric(dst, RTAX_INITRWND);

	tcp_select_initial_window(sk, tcp_full_space(sk),
				  tp->advmss - (tp->rx_opt.ts_recent_stamp ? tp->tcp_header_len - sizeof(struct tcphdr) : 0),
				  &tp->rcv_wnd,
				  &tp->window_clamp,
				  sock_net(sk)->ipv4.sysctl_tcp_window_scaling,
				  &rcv_wscale,
				  rcv_wnd);

	tp->rx_opt.rcv_wscale = rcv_wscale;
	tp->rcv_ssthresh = tp->rcv_wnd;

	sk->sk_err = 0;
	sock_reset_flag(sk, SOCK_DONE);
	tp->snd_wnd = 0;
	tcp_init_wl(tp, 0);
	tcp_write_queue_purge(sk);
	tp->snd_una = tp->write_seq;
	tp->snd_sml = tp->write_seq;
	tp->snd_up = tp->write_seq;
	tp->snd_nxt = tp->write_seq;

	if (likely(!tp->repair))
		tp->rcv_nxt = 0;
	else
		tp->rcv_tstamp = tcp_jiffies32;
	tp->rcv_wup = tp->rcv_nxt;
	tp->copied_seq = tp->rcv_nxt;

	inet_csk(sk)->icsk_rto = tcp_timeout_init(sk);
	inet_csk(sk)->icsk_retransmits = 0;
	tcp_clear_retrans(tp);
}","static void tcp_connect_init(struct sock *VAR_0)
{
	const struct dst_entry *VAR_1 = __sk_dst_get(VAR_0);
	struct tcp_sock *VAR_2 = tcp_sk(VAR_0);
	__u8 VAR_3;
	u32 VAR_4;

	/* COMMENT_0 */
                                                            
    
	VAR_2->tcp_header_len = sizeof(struct tcphdr);
	if (sock_net(VAR_0)->ipv4.sysctl_tcp_timestamps)
		VAR_2->tcp_header_len += VAR_5;

#ifdef VAR_6
	if (VAR_2->af_specific->md5_lookup(VAR_0, VAR_0))
		VAR_2->tcp_header_len += VAR_7;
#endif

	/* COMMENT_3 */
	if (VAR_2->rx_opt.user_mss)
		VAR_2->rx_opt.mss_clamp = VAR_2->rx_opt.user_mss;
	VAR_2->max_window = 0;
	tcp_mtup_init(VAR_0);
	tcp_sync_mss(VAR_0, dst_mtu(VAR_1));

	tcp_ca_dst_init(VAR_0, VAR_1);

	if (!VAR_2->window_clamp)
		VAR_2->window_clamp = dst_metric(VAR_1, VAR_8);
	VAR_2->advmss = tcp_mss_clamp(VAR_2, dst_metric_advmss(VAR_1));

	tcp_initialize_rcv_mss(VAR_0);

	/* COMMENT_4 */
	if (VAR_0->sk_userlocks & VAR_9 &&
	    (VAR_2->window_clamp > tcp_full_space(VAR_0) || VAR_2->window_clamp == 0))
		VAR_2->window_clamp = tcp_full_space(VAR_0);

	VAR_4 = tcp_rwnd_init_bpf(VAR_0);
	if (VAR_4 == 0)
		VAR_4 = dst_metric(VAR_1, VAR_10);

	tcp_select_initial_window(VAR_0, tcp_full_space(VAR_0),
				  VAR_2->advmss - (VAR_2->rx_opt.ts_recent_stamp ? VAR_2->tcp_header_len - sizeof(struct tcphdr) : 0),
				  &VAR_2->rcv_wnd,
				  &VAR_2->window_clamp,
				  sock_net(VAR_0)->ipv4.sysctl_tcp_window_scaling,
				  &VAR_3,
				  VAR_4);

	VAR_2->rx_opt.rcv_wscale = VAR_3;
	VAR_2->rcv_ssthresh = VAR_2->rcv_wnd;

	VAR_0->sk_err = 0;
	sock_reset_flag(VAR_0, VAR_11);
	VAR_2->snd_wnd = 0;
	tcp_init_wl(VAR_2, 0);
	tcp_write_queue_purge(VAR_0);
	VAR_2->snd_una = VAR_2->write_seq;
	VAR_2->snd_sml = VAR_2->write_seq;
	VAR_2->snd_up = VAR_2->write_seq;
	VAR_2->snd_nxt = VAR_2->write_seq;

	if (likely(!VAR_2->repair))
		VAR_2->rcv_nxt = 0;
	else
		VAR_2->rcv_tstamp = VAR_12;
	VAR_2->rcv_wup = VAR_2->rcv_nxt;
	VAR_2->copied_seq = VAR_2->rcv_nxt;

	inet_csk(VAR_0)->icsk_rto = tcp_timeout_init(VAR_0);
	inet_csk(VAR_0)->icsk_retransmits = 0;
	tcp_clear_retrans(VAR_2);
}",torvalds/linux/7f582b248d0a86bae5788c548d7bb5bca6f7691a/tcp_output.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -56,6 +56,7 @@
 	sock_reset_flag(sk, SOCK_DONE);
 	tp->snd_wnd = 0;
 	tcp_init_wl(tp, 0);
+	tcp_write_queue_purge(sk);
 	tp->snd_una = tp->write_seq;
 	tp->snd_sml = tp->write_seq;
 	tp->snd_up = tp->write_seq;","{'deleted_lines': [], 'added_lines': ['\ttcp_write_queue_purge(sk);']}",True,"In the Linux kernel, a certain net/ipv4/tcp_output.c change, which was properly incorporated into 4.16.12, was incorrectly backported to the earlier longterm kernels, introducing a new vulnerability that was potentially more severe than the issue that was intended to be fixed by backporting. Specifically, by adding to a write queue between disconnection and re-connection, a local attacker can trigger multiple use-after-free conditions. This can result in a kernel crash, or potentially in privilege escalation. NOTE: this affects (for example) Linux distributions that use 4.9.x longterm kernels before 4.9.190 or 4.14.x longterm kernels before 4.14.139.",7.8,HIGH,2,test,,5
CVE-2019-15030,['CWE-862'],AV:L/AC:L/Au:N/C:P/I:N/A:P,0,torvalds/linux,"When we take an FP unavailable exception in a transaction we have to
account for the hardware FP TM checkpointed registers being
incorrect. In this case for this process we know the current and
checkpointed FP registers must be the same (since FP wasn't used
inside the transaction) hence in the thread_struct we copy the current
FP registers to the checkpointed ones.

This copy is done in tm_reclaim_thread(). We use thread->ckpt_regs.msr
to determine if FP was on when in userspace. thread->ckpt_regs.msr
represents the state of the MSR when exiting userspace. This is setup
by check_if_tm_restore_required().

Unfortunatley there is an optimisation in giveup_all() which returns
early if tsk->thread.regs->msr (via local variable `usermsr`) has
FP=VEC=VSX=SPE=0. This optimisation means that
check_if_tm_restore_required() is not called and hence
thread->ckpt_regs.msr is not updated and will contain an old value.

This can happen if due to load_fp=255 we start a userspace process
with MSR FP=1 and then we are context switched out. In this case
thread->ckpt_regs.msr will contain FP=1. If that same process is then
context switched in and load_fp overflows, MSR will have FP=0. If that
process now enters a transaction and does an FP instruction, the FP
unavailable will not update thread->ckpt_regs.msr (the bug) and MSR
FP=1 will be retained in thread->ckpt_regs.msr.  tm_reclaim_thread()
will then not perform the required memcpy and the checkpointed FP regs
in the thread struct will contain the wrong values.

The code path for this happening is:

       Userspace:                      Kernel
                   Start userspace
                    with MSR FP/VEC/VSX/SPE=0 TM=1
                      < -----
       ...
       tbegin
       bne
       fp instruction
                   FP unavailable
                       ---- >
                                        fp_unavailable_tm()
					  tm_reclaim_current()
					    tm_reclaim_thread()
					      giveup_all()
					        return early since FP/VMX/VSX=0
						/* ckpt MSR not updated (Incorrect) */
					      tm_reclaim()
					        /* thread_struct ckpt FP regs contain junk (OK) */
                                              /* Sees ckpt MSR FP=1 (Incorrect) */
					      no memcpy() performed
					        /* thread_struct ckpt FP regs not fixed (Incorrect) */
					  tm_recheckpoint()
					     /* Put junk in hardware checkpoint FP regs */
                                         ....
                      < -----
                   Return to userspace
                     with MSR TM=1 FP=1
                     with junk in the FP TM checkpoint
       TM rollback
       reads FP junk

This is a data integrity problem for the current process as the FP
registers are corrupted. It's also a security problem as the FP
registers from one process may be leaked to another.

This patch moves up check_if_tm_restore_required() in giveup_all() to
ensure thread->ckpt_regs.msr is updated correctly.

A simple testcase to replicate this will be posted to
tools/testing/selftests/powerpc/tm/tm-poison.c

Similarly for VMX.

This fixes CVE-2019-15030.

Fixes: f48e91e87e67 (""powerpc/tm: Fix FP and VMX register corruption"")
Cc: stable@vger.kernel.org # 4.12+
Signed-off-by: Gustavo Romero <gromero@linux.vnet.ibm.com>
Signed-off-by: Michael Neuling <mikey@neuling.org>
Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20190904045529.23002-1-gromero@linux.vnet.ibm.com
",8205d5d98ef7f155de211f5e2eb6ca03d95a5a60,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=8205d5d98ef7f155de211f5e2eb6ca03d95a5a60,arch/powerpc/kernel/process.c,giveup_all,"void giveup_all(struct task_struct *tsk)
{
unsigned long usermsr;
if (!tsk->thread.regs)
return;
usermsr = tsk->thread.regs->msr;
if ((usermsr & msr_all_available) == 0)
return;
msr_check_and_set(msr_all_available);
check_if_tm_restore_required(tsk);
WARN_ON((usermsr & MSR_VSX) && !((usermsr & MSR_FP) && (usermsr & MSR_VEC)));
#ifdef CONFIG_PPC_FPU
if (usermsr & MSR_FP)
__giveup_fpu(tsk);
#endif
#ifdef CONFIG_ALTIVEC
if (usermsr & MSR_VEC)
__giveup_altivec(tsk);
#endif
#ifdef CONFIG_SPE
if (usermsr & MSR_SPE)
__giveup_spe(tsk);
#endif
msr_check_and_clear(msr_all_available);
}","void giveup_all(struct task_struct *VAR_0)
{
unsigned long VAR_1;
if (!VAR_0->thread.regs)
return;
VAR_1 = VAR_0->thread.regs->msr;
if ((VAR_1 & VAR_2) == 0)
return;
msr_check_and_set(VAR_2);
check_if_tm_restore_required(VAR_0);
WARN_ON((VAR_1 & VAR_3) && !((VAR_1 & VAR_4) && (VAR_1 & VAR_5)));
#ifdef VAR_6
if (VAR_1 & VAR_4)
__giveup_fpu(VAR_0);
#endif
#ifdef VAR_7
if (VAR_1 & VAR_5)
__giveup_altivec(VAR_0);
#endif
#ifdef VAR_8
if (VAR_1 & VAR_9)
__giveup_spe(VAR_0);
#endif
msr_check_and_clear(VAR_2);
}",torvalds/linux/8205d5d98ef7f155de211f5e2eb6ca03d95a5a60/process.c/vul/before/0.json,"void giveup_all(struct task_struct *tsk)
{
	unsigned long usermsr;

	if (!tsk->thread.regs)
		return;

	check_if_tm_restore_required(tsk);

	usermsr = tsk->thread.regs->msr;

	if ((usermsr & msr_all_available) == 0)
		return;

	msr_check_and_set(msr_all_available);

	WARN_ON((usermsr & MSR_VSX) && !((usermsr & MSR_FP) && (usermsr & MSR_VEC)));

#ifdef CONFIG_PPC_FPU
	if (usermsr & MSR_FP)
		__giveup_fpu(tsk);
#endif
#ifdef CONFIG_ALTIVEC
	if (usermsr & MSR_VEC)
		__giveup_altivec(tsk);
#endif
#ifdef CONFIG_SPE
	if (usermsr & MSR_SPE)
		__giveup_spe(tsk);
#endif

	msr_check_and_clear(msr_all_available);
}","void giveup_all(struct task_struct *VAR_0)
{
	unsigned long VAR_1;

	if (!VAR_0->thread.regs)
		return;

	check_if_tm_restore_required(VAR_0);

	VAR_1 = VAR_0->thread.regs->msr;

	if ((VAR_1 & VAR_2) == 0)
		return;

	msr_check_and_set(VAR_2);

	WARN_ON((VAR_1 & VAR_3) && !((VAR_1 & VAR_4) && (VAR_1 & VAR_5)));

#ifdef VAR_6
	if (VAR_1 & VAR_4)
		__giveup_fpu(VAR_0);
#endif
#ifdef VAR_7
	if (VAR_1 & VAR_5)
		__giveup_altivec(VAR_0);
#endif
#ifdef VAR_8
	if (VAR_1 & VAR_9)
		__giveup_spe(VAR_0);
#endif

	msr_check_and_clear(VAR_2);
}",torvalds/linux/8205d5d98ef7f155de211f5e2eb6ca03d95a5a60/process.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,13 +5,14 @@
 	if (!tsk->thread.regs)
 		return;
 
+	check_if_tm_restore_required(tsk);
+
 	usermsr = tsk->thread.regs->msr;
 
 	if ((usermsr & msr_all_available) == 0)
 		return;
 
 	msr_check_and_set(msr_all_available);
-	check_if_tm_restore_required(tsk);
 
 	WARN_ON((usermsr & MSR_VSX) && !((usermsr & MSR_FP) && (usermsr & MSR_VEC)));
 ","{'deleted_lines': ['\tcheck_if_tm_restore_required(tsk);'], 'added_lines': ['\tcheck_if_tm_restore_required(tsk);', '']}",True,"In the Linux kernel through 5.2.14 on the powerpc platform, a local user can read vector registers of other users' processes via a Facility Unavailable exception. To exploit the venerability, a local user starts a transaction (via the hardware transactional memory instruction tbegin) and then accesses vector registers. At some point, the vector registers will be corrupted with the values from a different local Linux process because of a missing arch/powerpc/kernel/process.c check.",4.4,MEDIUM,1,test,,5
CVE-2021-3929,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H,1,qemu-project/qemu,"hw/nvme: fix CVE-2021-3929

This fixes CVE-2021-3929 ""locally"" by denying DMA to the iomem of the
device itself. This still allows DMA to MMIO regions of other devices
(e.g. doing P2P DMA to the controller memory buffer of another NVMe
device).

Fixes: CVE-2021-3929
Reported-by: Qiuhao Li <Qiuhao.Li@outlook.com>
Reviewed-by: Keith Busch <kbusch@kernel.org>
Reviewed-by: Philippe Mathieu-Daud <f4bug@amsat.org>
Signed-off-by: Klaus Jensen <k.jensen@samsung.com>
",736b01642d85be832385,https://gitlab.com/qemu-project/qemu/-/commit/736b01642d85be832385063f278fe7cd4ffb5221,hw/nvme/ctrl.c,nvme_map_addr,"static uint16_t nvme_map_addr(NvmeCtrl *n, NvmeSg *sg, hwaddr addr, size_t len)
{
bool cmb = false, pmr = false;
if (!len) {
return NVME_SUCCESS;
}
trace_pci_nvme_map_addr(addr, len);
if (nvme_addr_is_cmb(n, addr)) {
cmb = true;
} else if (nvme_addr_is_pmr(n, addr)) {
pmr = true;
}
if (cmb || pmr) {
if (sg->flags & NVME_SG_DMA) {
return NVME_INVALID_USE_OF_CMB | NVME_DNR;
}
if (sg->iov.niov + 1 > IOV_MAX) {
goto max_mappings_exceeded;
}
if (cmb) {
return nvme_map_addr_cmb(n, &sg->iov, addr, len);
} else {
return nvme_map_addr_pmr(n, &sg->iov, addr, len);
}
}
if (!(sg->flags & NVME_SG_DMA)) {
return NVME_INVALID_USE_OF_CMB | NVME_DNR;
}
if (sg->qsg.nsg + 1 > IOV_MAX) {
goto max_mappings_exceeded;
}
qemu_sglist_add(&sg->qsg, addr, len);
return NVME_SUCCESS;
max_mappings_exceeded:
NVME_GUEST_ERR(pci_nvme_ub_too_many_mappings,
""number of mappings exceed 1024"");
return NVME_INTERNAL_DEV_ERROR | NVME_DNR;
}","static uint16_t nvme_map_addr(NvmeCtrl *VAR_0, NvmeSg *VAR_1, hwaddr VAR_2, size_t VAR_3)
{
bool VAR_4 = false, VAR_5 = false;
if (!VAR_3) {
return VAR_6;
}
trace_pci_nvme_map_addr(VAR_2, VAR_3);
if (nvme_addr_is_cmb(VAR_0, VAR_2)) {
VAR_4 = true;
} else if (nvme_addr_is_pmr(VAR_0, VAR_2)) {
VAR_5 = true;
}
if (VAR_4 || VAR_5) {
if (VAR_1->flags & VAR_7) {
return VAR_8 | VAR_9;
}
if (VAR_1->iov.niov + 1 > VAR_10) {
goto max_mappings_exceeded;
}
if (VAR_4) {
return nvme_map_addr_cmb(VAR_0, &VAR_1->iov, VAR_2, VAR_3);
} else {
return nvme_map_addr_pmr(VAR_0, &VAR_1->iov, VAR_2, VAR_3);
}
}
if (!(VAR_1->flags & VAR_7)) {
return VAR_8 | VAR_9;
}
if (VAR_1->qsg.nsg + 1 > VAR_10) {
goto max_mappings_exceeded;
}
qemu_sglist_add(&VAR_1->qsg, VAR_2, VAR_3);
return VAR_6;
max_mappings_exceeded:
NVME_GUEST_ERR(VAR_11,
""number of mappings exceed 1024"");
return VAR_12 | VAR_9;
}",qemu-project/qemu/736b01642d85be832385/ctrl.c/vul/before/0.json,"static uint16_t nvme_map_addr(NvmeCtrl *n, NvmeSg *sg, hwaddr addr, size_t len)
{
    bool cmb = false, pmr = false;

    if (!len) {
        return NVME_SUCCESS;
    }

    trace_pci_nvme_map_addr(addr, len);

    if (nvme_addr_is_iomem(n, addr)) {
        return NVME_DATA_TRAS_ERROR;
    }

    if (nvme_addr_is_cmb(n, addr)) {
        cmb = true;
    } else if (nvme_addr_is_pmr(n, addr)) {
        pmr = true;
    }

    if (cmb || pmr) {
        if (sg->flags & NVME_SG_DMA) {
            return NVME_INVALID_USE_OF_CMB | NVME_DNR;
        }

        if (sg->iov.niov + 1 > IOV_MAX) {
            goto max_mappings_exceeded;
        }

        if (cmb) {
            return nvme_map_addr_cmb(n, &sg->iov, addr, len);
        } else {
            return nvme_map_addr_pmr(n, &sg->iov, addr, len);
        }
    }

    if (!(sg->flags & NVME_SG_DMA)) {
        return NVME_INVALID_USE_OF_CMB | NVME_DNR;
    }

    if (sg->qsg.nsg + 1 > IOV_MAX) {
        goto max_mappings_exceeded;
    }

    qemu_sglist_add(&sg->qsg, addr, len);

    return NVME_SUCCESS;

max_mappings_exceeded:
    NVME_GUEST_ERR(pci_nvme_ub_too_many_mappings,
                   ""number of mappings exceed 1024"");
    return NVME_INTERNAL_DEV_ERROR | NVME_DNR;
}","static uint16_t nvme_map_addr(NvmeCtrl *VAR_0, NvmeSg *VAR_1, hwaddr VAR_2, size_t VAR_3)
{
    bool VAR_4 = false, VAR_5 = false;

    if (!VAR_3) {
        return VAR_6;
    }

    trace_pci_nvme_map_addr(VAR_2, VAR_3);

    if (nvme_addr_is_iomem(VAR_0, VAR_2)) {
        return VAR_7;
    }

    if (nvme_addr_is_cmb(VAR_0, VAR_2)) {
        VAR_4 = true;
    } else if (nvme_addr_is_pmr(VAR_0, VAR_2)) {
        VAR_5 = true;
    }

    if (VAR_4 || VAR_5) {
        if (VAR_1->flags & VAR_8) {
            return VAR_9 | VAR_10;
        }

        if (VAR_1->iov.niov + 1 > VAR_11) {
            goto max_mappings_exceeded;
        }

        if (VAR_4) {
            return nvme_map_addr_cmb(VAR_0, &VAR_1->iov, VAR_2, VAR_3);
        } else {
            return nvme_map_addr_pmr(VAR_0, &VAR_1->iov, VAR_2, VAR_3);
        }
    }

    if (!(VAR_1->flags & VAR_8)) {
        return VAR_9 | VAR_10;
    }

    if (VAR_1->qsg.nsg + 1 > VAR_11) {
        goto max_mappings_exceeded;
    }

    qemu_sglist_add(&VAR_1->qsg, VAR_2, VAR_3);

    return VAR_6;

max_mappings_exceeded:
    NVME_GUEST_ERR(VAR_12,
                   ""number of mappings exceed 1024"");
    return VAR_13 | VAR_10;
}",qemu-project/qemu/736b01642d85be832385/ctrl.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,6 +7,10 @@
     }
 
     trace_pci_nvme_map_addr(addr, len);
+
+    if (nvme_addr_is_iomem(n, addr)) {
+        return NVME_DATA_TRAS_ERROR;
+    }
 
     if (nvme_addr_is_cmb(n, addr)) {
         cmb = true;","{'deleted_lines': [], 'added_lines': ['', '    if (nvme_addr_is_iomem(n, addr)) {', '        return NVME_DATA_TRAS_ERROR;', '    }']}",True,"A DMA reentrancy issue was found in the NVM Express Controller (NVME) emulation in QEMU. This CVE is similar to CVE-2021-3750 and, just like it, when the reentrancy write triggers the reset function nvme_ctrl_reset(), data structs will be freed leading to a use-after-free issue. A malicious guest could use this flaw to crash the QEMU process on the host, resulting in a denial of service condition or, potentially, executing arbitrary code within the context of the QEMU process on the host.",8.2,HIGH,2,test,,5
CVE-2022-3623,['CWE-362'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,kernel/git/bpf/bpf-next,"On some architectures (like ARM64), it can support CONT-PTE/PMD size
hugetlb, which means it can support not only PMD/PUD size hugetlb (2M and
1G), but also CONT-PTE/PMD size(64K and 32M) if a 4K page size specified.

So when looking up a CONT-PTE size hugetlb page by follow_page(), it will
use pte_offset_map_lock() to get the pte entry lock for the CONT-PTE size
hugetlb in follow_page_pte().  However this pte entry lock is incorrect
for the CONT-PTE size hugetlb, since we should use huge_pte_lock() to get
the correct lock, which is mm->page_table_lock.

That means the pte entry of the CONT-PTE size hugetlb under current pte
lock is unstable in follow_page_pte(), we can continue to migrate or
poison the pte entry of the CONT-PTE size hugetlb, which can cause some
potential race issues, even though they are under the 'pte lock'.

For example, suppose thread A is trying to look up a CONT-PTE size hugetlb
page by move_pages() syscall under the lock, however antoher thread B can
migrate the CONT-PTE hugetlb page at the same time, which will cause
thread A to get an incorrect page, if thread A also wants to do page
migration, then data inconsistency error occurs.

Moreover we have the same issue for CONT-PMD size hugetlb in
follow_huge_pmd().

To fix above issues, rename the follow_huge_pmd() as follow_huge_pmd_pte()
to handle PMD and PTE level size hugetlb, which uses huge_pte_lock() to
get the correct pte entry lock to make the pte entry stable.

Mike said:

Support for CONT_PMD/_PTE was added with bb9dd3df8ee9 (""arm64: hugetlb:
refactor find_num_contig()"").  Patch series ""Support for contiguous pte
hugepages"", v4.  However, I do not believe these code paths were
executed until migration support was added with 5480280d3f2d (""arm64/mm:
enable HugeTLB migration for contiguous bit HugeTLB pages"") I would go
with 5480280d3f2d for the Fixes: targe.

Link: https://lkml.kernel.org/r/635f43bdd85ac2615a58405da82b4d33c6e5eb05.1662017562.git.baolin.wang@linux.alibaba.com
Fixes: 5480280d3f2d (""arm64/mm: enable HugeTLB migration for contiguous bit HugeTLB pages"")
Signed-off-by: Baolin Wang <baolin.wang@linux.alibaba.com>
Suggested-by: Mike Kravetz <mike.kravetz@oracle.com>
Reviewed-by: Mike Kravetz <mike.kravetz@oracle.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: Muchun Song <songmuchun@bytedance.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",fac35ba763ed07ba93154c95ffc0c4a55023707f,https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next.git/commit/?h=fac35ba763ed07ba93154c95ffc0c4a55023707f,mm/gup.c,follow_pmd_mask,"static struct page *follow_pmd_mask(struct vm_area_struct *vma,
unsigned long address, pud_t *pudp,
unsigned int flags,
struct follow_page_context *ctx)
{
pmd_t *pmd, pmdval;
spinlock_t *ptl;
struct page *page;
struct mm_struct *mm = vma->vm_mm;
pmd = pmd_offset(pudp, address);
pmdval = READ_ONCE(*pmd);
if (pmd_none(pmdval))
return no_page_table(vma, flags);
if (pmd_huge(pmdval) && is_vm_hugetlb_page(vma)) {
page = follow_huge_pmd(mm, address, pmd, flags);
if (page)
return page;
return no_page_table(vma, flags);
}
if (is_hugepd(__hugepd(pmd_val(pmdval)))) {
page = follow_huge_pd(vma, address,
__hugepd(pmd_val(pmdval)), flags,
PMD_SHIFT);
if (page)
return page;
return no_page_table(vma, flags);
}
retry:
if (!pmd_present(pmdval)) {
VM_BUG_ON(!thp_migration_supported() ||
!is_pmd_migration_entry(pmdval));
if (likely(!(flags & FOLL_MIGRATION)))
return no_page_table(vma, flags);
pmd_migration_entry_wait(mm, pmd);
pmdval = READ_ONCE(*pmd);
if (pmd_none(pmdval))
return no_page_table(vma, flags);
goto retry;
}
if (pmd_devmap(pmdval)) {
ptl = pmd_lock(mm, pmd);
page = follow_devmap_pmd(vma, address, pmd, flags, &ctx->pgmap);
spin_unlock(ptl);
if (page)
return page;
}
if (likely(!pmd_trans_huge(pmdval)))
return follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);
if ((flags & FOLL_NUMA) && pmd_protnone(pmdval))
return no_page_table(vma, flags);
retry_locked:
ptl = pmd_lock(mm, pmd);
if (unlikely(pmd_none(*pmd))) {
spin_unlock(ptl);
return no_page_table(vma, flags);
}
if (unlikely(!pmd_present(*pmd))) {
spin_unlock(ptl);
if (likely(!(flags & FOLL_MIGRATION)))
return no_page_table(vma, flags);
pmd_migration_entry_wait(mm, pmd);
goto retry_locked;
}
if (unlikely(!pmd_trans_huge(*pmd))) {
spin_unlock(ptl);
return follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);
}
if (flags & FOLL_SPLIT_PMD) {
int ret;
page = pmd_page(*pmd);
if (is_huge_zero_page(page)) {
spin_unlock(ptl);
ret = 0;
split_huge_pmd(vma, pmd, address);
if (pmd_trans_unstable(pmd))
ret = -EBUSY;
} else {
spin_unlock(ptl);
split_huge_pmd(vma, pmd, address);
ret = pte_alloc(mm, pmd) ? -ENOMEM : 0;
}
return ret ? ERR_PTR(ret) :
follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);
}
page = follow_trans_huge_pmd(vma, address, pmd, flags);
spin_unlock(ptl);
ctx->page_mask = HPAGE_PMD_NR - 1;
return page;
}","static struct page *follow_pmd_mask(struct vm_area_struct *VAR_0,
unsigned long VAR_1, pud_t *VAR_2,
unsigned int VAR_3,
struct follow_page_context *VAR_4)
{
pmd_t *VAR_5, VAR_6;
spinlock_t *VAR_7;
struct page *page;
struct mm_struct *VAR_8 = VAR_0->vm_mm;
VAR_5 = pmd_offset(VAR_2, VAR_1);
VAR_6 = READ_ONCE(*VAR_5);
if (pmd_none(VAR_6))
return no_page_table(VAR_0, VAR_3);
if (pmd_huge(VAR_6) && is_vm_hugetlb_page(VAR_0)) {
page = follow_huge_pmd(VAR_8, VAR_1, VAR_5, VAR_3);
if (page)
return page;
return no_page_table(VAR_0, VAR_3);
}
if (is_hugepd(__hugepd(pmd_val(VAR_6)))) {
page = follow_huge_pd(VAR_0, VAR_1,
__hugepd(pmd_val(VAR_6)), VAR_3,
VAR_9);
if (page)
return page;
return no_page_table(VAR_0, VAR_3);
}
retry:
if (!pmd_present(VAR_6)) {
VM_BUG_ON(!thp_migration_supported() ||
!is_pmd_migration_entry(VAR_6));
if (likely(!(VAR_3 & VAR_10)))
return no_page_table(VAR_0, VAR_3);
pmd_migration_entry_wait(VAR_8, VAR_5);
VAR_6 = READ_ONCE(*VAR_5);
if (pmd_none(VAR_6))
return no_page_table(VAR_0, VAR_3);
goto retry;
}
if (pmd_devmap(VAR_6)) {
VAR_7 = pmd_lock(VAR_8, VAR_5);
page = follow_devmap_pmd(VAR_0, VAR_1, VAR_5, VAR_3, &VAR_4->pgmap);
spin_unlock(VAR_7);
if (page)
return page;
}
if (likely(!pmd_trans_huge(VAR_6)))
return follow_page_pte(VAR_0, VAR_1, VAR_5, VAR_3, &VAR_4->pgmap);
if ((VAR_3 & VAR_11) && pmd_protnone(VAR_6))
return no_page_table(VAR_0, VAR_3);
retry_locked:
VAR_7 = pmd_lock(VAR_8, VAR_5);
if (unlikely(pmd_none(*VAR_5))) {
spin_unlock(VAR_7);
return no_page_table(VAR_0, VAR_3);
}
if (unlikely(!pmd_present(*VAR_5))) {
spin_unlock(VAR_7);
if (likely(!(VAR_3 & VAR_10)))
return no_page_table(VAR_0, VAR_3);
pmd_migration_entry_wait(VAR_8, VAR_5);
goto retry_locked;
}
if (unlikely(!pmd_trans_huge(*VAR_5))) {
spin_unlock(VAR_7);
return follow_page_pte(VAR_0, VAR_1, VAR_5, VAR_3, &VAR_4->pgmap);
}
if (VAR_3 & VAR_12) {
int VAR_13;
page = pmd_page(*VAR_5);
if (is_huge_zero_page(page)) {
spin_unlock(VAR_7);
VAR_13 = 0;
split_huge_pmd(VAR_0, VAR_5, VAR_1);
if (pmd_trans_unstable(VAR_5))
VAR_13 = -VAR_14;
} else {
spin_unlock(VAR_7);
split_huge_pmd(VAR_0, VAR_5, VAR_1);
VAR_13 = pte_alloc(VAR_8, VAR_5) ? -VAR_15 : 0;
}
return VAR_13 ? ERR_PTR(VAR_13) :
follow_page_pte(VAR_0, VAR_1, VAR_5, VAR_3, &VAR_4->pgmap);
}
page = follow_trans_huge_pmd(VAR_0, VAR_1, VAR_5, VAR_3);
spin_unlock(VAR_7);
VAR_4->page_mask = VAR_16 - 1;
return page;
}",kernel/git/bpf/bpf-next/fac35ba763ed07ba93154c95ffc0c4a55023707f/gup.c/vul/before/0.json,"static struct page *follow_pmd_mask(struct vm_area_struct *vma,
				    unsigned long address, pud_t *pudp,
				    unsigned int flags,
				    struct follow_page_context *ctx)
{
	pmd_t *pmd, pmdval;
	spinlock_t *ptl;
	struct page *page;
	struct mm_struct *mm = vma->vm_mm;

	pmd = pmd_offset(pudp, address);
	/*
	 * The READ_ONCE() will stabilize the pmdval in a register or
	 * on the stack so that it will stop changing under the code.
	 */
	pmdval = READ_ONCE(*pmd);
	if (pmd_none(pmdval))
		return no_page_table(vma, flags);
	if (pmd_huge(pmdval) && is_vm_hugetlb_page(vma)) {
		page = follow_huge_pmd_pte(vma, address, flags);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
	if (is_hugepd(__hugepd(pmd_val(pmdval)))) {
		page = follow_huge_pd(vma, address,
				      __hugepd(pmd_val(pmdval)), flags,
				      PMD_SHIFT);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}
retry:
	if (!pmd_present(pmdval)) {
		/*
		 * Should never reach here, if thp migration is not supported;
		 * Otherwise, it must be a thp migration entry.
		 */
		VM_BUG_ON(!thp_migration_supported() ||
				  !is_pmd_migration_entry(pmdval));

		if (likely(!(flags & FOLL_MIGRATION)))
			return no_page_table(vma, flags);

		pmd_migration_entry_wait(mm, pmd);
		pmdval = READ_ONCE(*pmd);
		/*
		 * MADV_DONTNEED may convert the pmd to null because
		 * mmap_lock is held in read mode
		 */
		if (pmd_none(pmdval))
			return no_page_table(vma, flags);
		goto retry;
	}
	if (pmd_devmap(pmdval)) {
		ptl = pmd_lock(mm, pmd);
		page = follow_devmap_pmd(vma, address, pmd, flags, &ctx->pgmap);
		spin_unlock(ptl);
		if (page)
			return page;
	}
	if (likely(!pmd_trans_huge(pmdval)))
		return follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);

	if ((flags & FOLL_NUMA) && pmd_protnone(pmdval))
		return no_page_table(vma, flags);

retry_locked:
	ptl = pmd_lock(mm, pmd);
	if (unlikely(pmd_none(*pmd))) {
		spin_unlock(ptl);
		return no_page_table(vma, flags);
	}
	if (unlikely(!pmd_present(*pmd))) {
		spin_unlock(ptl);
		if (likely(!(flags & FOLL_MIGRATION)))
			return no_page_table(vma, flags);
		pmd_migration_entry_wait(mm, pmd);
		goto retry_locked;
	}
	if (unlikely(!pmd_trans_huge(*pmd))) {
		spin_unlock(ptl);
		return follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);
	}
	if (flags & FOLL_SPLIT_PMD) {
		int ret;
		page = pmd_page(*pmd);
		if (is_huge_zero_page(page)) {
			spin_unlock(ptl);
			ret = 0;
			split_huge_pmd(vma, pmd, address);
			if (pmd_trans_unstable(pmd))
				ret = -EBUSY;
		} else {
			spin_unlock(ptl);
			split_huge_pmd(vma, pmd, address);
			ret = pte_alloc(mm, pmd) ? -ENOMEM : 0;
		}

		return ret ? ERR_PTR(ret) :
			follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);
	}
	page = follow_trans_huge_pmd(vma, address, pmd, flags);
	spin_unlock(ptl);
	ctx->page_mask = HPAGE_PMD_NR - 1;
	return page;
}","static struct page *follow_pmd_mask(struct vm_area_struct *VAR_0,
				    unsigned long VAR_1, pud_t *VAR_2,
				    unsigned int VAR_3,
				    struct follow_page_context *VAR_4)
{
	pmd_t *VAR_5, VAR_6;
	spinlock_t *VAR_7;
	struct page *page;
	struct mm_struct *VAR_8 = VAR_0->vm_mm;

	VAR_5 = pmd_offset(VAR_2, VAR_1);
	/* COMMENT_0 */
                                                              
                                                              
    
	VAR_6 = READ_ONCE(*VAR_5);
	if (pmd_none(VAR_6))
		return no_page_table(VAR_0, VAR_3);
	if (pmd_huge(VAR_6) && is_vm_hugetlb_page(VAR_0)) {
		page = follow_huge_pmd_pte(VAR_0, VAR_1, VAR_3);
		if (page)
			return page;
		return no_page_table(VAR_0, VAR_3);
	}
	if (is_hugepd(__hugepd(pmd_val(VAR_6)))) {
		page = follow_huge_pd(VAR_0, VAR_1,
				      __hugepd(pmd_val(VAR_6)), VAR_3,
				      VAR_9);
		if (page)
			return page;
		return no_page_table(VAR_0, VAR_3);
	}
retry:
	if (!pmd_present(VAR_6)) {
		/* COMMENT_4 */
                                                                
                                                 
     
		VM_BUG_ON(!thp_migration_supported() ||
				  !is_pmd_migration_entry(VAR_6));

		if (likely(!(VAR_3 & VAR_10)))
			return no_page_table(VAR_0, VAR_3);

		pmd_migration_entry_wait(VAR_8, VAR_5);
		VAR_6 = READ_ONCE(*VAR_5);
		/* COMMENT_8 */
                                                      
                                   
     
		if (pmd_none(VAR_6))
			return no_page_table(VAR_0, VAR_3);
		goto retry;
	}
	if (pmd_devmap(VAR_6)) {
		VAR_7 = pmd_lock(VAR_8, VAR_5);
		page = follow_devmap_pmd(VAR_0, VAR_1, VAR_5, VAR_3, &VAR_4->pgmap);
		spin_unlock(VAR_7);
		if (page)
			return page;
	}
	if (likely(!pmd_trans_huge(VAR_6)))
		return follow_page_pte(VAR_0, VAR_1, VAR_5, VAR_3, &VAR_4->pgmap);

	if ((VAR_3 & VAR_11) && pmd_protnone(VAR_6))
		return no_page_table(VAR_0, VAR_3);

retry_locked:
	VAR_7 = pmd_lock(VAR_8, VAR_5);
	if (unlikely(pmd_none(*VAR_5))) {
		spin_unlock(VAR_7);
		return no_page_table(VAR_0, VAR_3);
	}
	if (unlikely(!pmd_present(*VAR_5))) {
		spin_unlock(VAR_7);
		if (likely(!(VAR_3 & VAR_10)))
			return no_page_table(VAR_0, VAR_3);
		pmd_migration_entry_wait(VAR_8, VAR_5);
		goto retry_locked;
	}
	if (unlikely(!pmd_trans_huge(*VAR_5))) {
		spin_unlock(VAR_7);
		return follow_page_pte(VAR_0, VAR_1, VAR_5, VAR_3, &VAR_4->pgmap);
	}
	if (VAR_3 & VAR_12) {
		int VAR_13;
		page = pmd_page(*VAR_5);
		if (is_huge_zero_page(page)) {
			spin_unlock(VAR_7);
			VAR_13 = 0;
			split_huge_pmd(VAR_0, VAR_5, VAR_1);
			if (pmd_trans_unstable(VAR_5))
				VAR_13 = -VAR_14;
		} else {
			spin_unlock(VAR_7);
			split_huge_pmd(VAR_0, VAR_5, VAR_1);
			VAR_13 = pte_alloc(VAR_8, VAR_5) ? -VAR_15 : 0;
		}

		return VAR_13 ? ERR_PTR(VAR_13) :
			follow_page_pte(VAR_0, VAR_1, VAR_5, VAR_3, &VAR_4->pgmap);
	}
	page = follow_trans_huge_pmd(VAR_0, VAR_1, VAR_5, VAR_3);
	spin_unlock(VAR_7);
	VAR_4->page_mask = VAR_16 - 1;
	return page;
}",kernel/git/bpf/bpf-next/fac35ba763ed07ba93154c95ffc0c4a55023707f/gup.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,7 +17,7 @@
 	if (pmd_none(pmdval))
 		return no_page_table(vma, flags);
 	if (pmd_huge(pmdval) && is_vm_hugetlb_page(vma)) {
-		page = follow_huge_pmd(mm, address, pmd, flags);
+		page = follow_huge_pmd_pte(vma, address, flags);
 		if (page)
 			return page;
 		return no_page_table(vma, flags);","{'deleted_lines': ['\t\tpage = follow_huge_pmd(mm, address, pmd, flags);'], 'added_lines': ['\t\tpage = follow_huge_pmd_pte(vma, address, flags);']}",True,A vulnerability was found in Linux Kernel. It has been declared as problematic. Affected by this vulnerability is the function follow_page_pte of the file mm/gup.c of the component BPF. The manipulation leads to race condition. The attack can be launched remotely. It is recommended to apply a patch to fix this issue. The identifier VDB-211921 was assigned to this vulnerability.,7.5,HIGH,2,test,,5
CVE-2022-3623,['CWE-362'],CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,kernel/git/bpf/bpf-next,"On some architectures (like ARM64), it can support CONT-PTE/PMD size
hugetlb, which means it can support not only PMD/PUD size hugetlb (2M and
1G), but also CONT-PTE/PMD size(64K and 32M) if a 4K page size specified.

So when looking up a CONT-PTE size hugetlb page by follow_page(), it will
use pte_offset_map_lock() to get the pte entry lock for the CONT-PTE size
hugetlb in follow_page_pte().  However this pte entry lock is incorrect
for the CONT-PTE size hugetlb, since we should use huge_pte_lock() to get
the correct lock, which is mm->page_table_lock.

That means the pte entry of the CONT-PTE size hugetlb under current pte
lock is unstable in follow_page_pte(), we can continue to migrate or
poison the pte entry of the CONT-PTE size hugetlb, which can cause some
potential race issues, even though they are under the 'pte lock'.

For example, suppose thread A is trying to look up a CONT-PTE size hugetlb
page by move_pages() syscall under the lock, however antoher thread B can
migrate the CONT-PTE hugetlb page at the same time, which will cause
thread A to get an incorrect page, if thread A also wants to do page
migration, then data inconsistency error occurs.

Moreover we have the same issue for CONT-PMD size hugetlb in
follow_huge_pmd().

To fix above issues, rename the follow_huge_pmd() as follow_huge_pmd_pte()
to handle PMD and PTE level size hugetlb, which uses huge_pte_lock() to
get the correct pte entry lock to make the pte entry stable.

Mike said:

Support for CONT_PMD/_PTE was added with bb9dd3df8ee9 (""arm64: hugetlb:
refactor find_num_contig()"").  Patch series ""Support for contiguous pte
hugepages"", v4.  However, I do not believe these code paths were
executed until migration support was added with 5480280d3f2d (""arm64/mm:
enable HugeTLB migration for contiguous bit HugeTLB pages"") I would go
with 5480280d3f2d for the Fixes: targe.

Link: https://lkml.kernel.org/r/635f43bdd85ac2615a58405da82b4d33c6e5eb05.1662017562.git.baolin.wang@linux.alibaba.com
Fixes: 5480280d3f2d (""arm64/mm: enable HugeTLB migration for contiguous bit HugeTLB pages"")
Signed-off-by: Baolin Wang <baolin.wang@linux.alibaba.com>
Suggested-by: Mike Kravetz <mike.kravetz@oracle.com>
Reviewed-by: Mike Kravetz <mike.kravetz@oracle.com>
Cc: David Hildenbrand <david@redhat.com>
Cc: Muchun Song <songmuchun@bytedance.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",fac35ba763ed07ba93154c95ffc0c4a55023707f,https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next.git/commit/?h=fac35ba763ed07ba93154c95ffc0c4a55023707f,mm/gup.c,follow_page_pte,"static struct page *follow_page_pte(struct vm_area_struct *vma,
unsigned long address, pmd_t *pmd, unsigned int flags,
struct dev_pagemap **pgmap)
{
struct mm_struct *mm = vma->vm_mm;
struct page *page;
spinlock_t *ptl;
pte_t *ptep, pte;
int ret;
if (WARN_ON_ONCE((flags & (FOLL_PIN | FOLL_GET)) ==
(FOLL_PIN | FOLL_GET)))
return ERR_PTR(-EINVAL);
retry:
if (unlikely(pmd_bad(*pmd)))
return no_page_table(vma, flags);
ptep = pte_offset_map_lock(mm, pmd, address, &ptl);
pte = *ptep;
if (!pte_present(pte)) {
swp_entry_t entry;
if (likely(!(flags & FOLL_MIGRATION)))
goto no_page;
if (pte_none(pte))
goto no_page;
entry = pte_to_swp_entry(pte);
if (!is_migration_entry(entry))
goto no_page;
pte_unmap_unlock(ptep, ptl);
migration_entry_wait(mm, pmd, address);
goto retry;
}
if ((flags & FOLL_NUMA) && pte_protnone(pte))
goto no_page;
page = vm_normal_page(vma, address, pte);
if ((flags & FOLL_WRITE) &&
!can_follow_write_pte(pte, page, vma, flags)) {
page = NULL;
goto out;
}
if (!page && pte_devmap(pte) && (flags & (FOLL_GET | FOLL_PIN))) {
*pgmap = get_dev_pagemap(pte_pfn(pte), *pgmap);
if (*pgmap)
page = pte_page(pte);
else
goto no_page;
} else if (unlikely(!page)) {
if (flags & FOLL_DUMP) {
page = ERR_PTR(-EFAULT);
goto out;
}
if (is_zero_pfn(pte_pfn(pte))) {
page = pte_page(pte);
} else {
ret = follow_pfn_pte(vma, address, ptep, flags);
page = ERR_PTR(ret);
goto out;
}
}
if (!pte_write(pte) && gup_must_unshare(flags, page)) {
page = ERR_PTR(-EMLINK);
goto out;
}
VM_BUG_ON_PAGE((flags & FOLL_PIN) && PageAnon(page) &&
!PageAnonExclusive(page), page);
if (unlikely(!try_grab_page(page, flags))) {
page = ERR_PTR(-ENOMEM);
goto out;
}
if (flags & FOLL_PIN) {
ret = arch_make_page_accessible(page);
if (ret) {
unpin_user_page(page);
page = ERR_PTR(ret);
goto out;
}
}
if (flags & FOLL_TOUCH) {
if ((flags & FOLL_WRITE) &&
!pte_dirty(pte) && !PageDirty(page))
set_page_dirty(page);
mark_page_accessed(page);
}
out:
pte_unmap_unlock(ptep, ptl);
return page;
no_page:
pte_unmap_unlock(ptep, ptl);
if (!pte_none(pte))
return NULL;
return no_page_table(vma, flags);
}","static struct page *follow_page_pte(struct vm_area_struct *VAR_0,
unsigned long VAR_1, pmd_t *VAR_2, unsigned int VAR_3,
struct dev_pagemap **VAR_4)
{
struct mm_struct *VAR_5 = VAR_0->vm_mm;
struct page *page;
spinlock_t *VAR_6;
pte_t *VAR_7, VAR_8;
int VAR_9;
if (WARN_ON_ONCE((VAR_3 & (VAR_10 | VAR_11)) ==
(VAR_10 | VAR_11)))
return ERR_PTR(-VAR_12);
retry:
if (unlikely(pmd_bad(*VAR_2)))
return no_page_table(VAR_0, VAR_3);
VAR_7 = pte_offset_map_lock(VAR_5, VAR_2, VAR_1, &VAR_6);
VAR_8 = *VAR_7;
if (!pte_present(VAR_8)) {
swp_entry_t VAR_13;
if (likely(!(VAR_3 & VAR_14)))
goto no_page;
if (pte_none(VAR_8))
goto no_page;
VAR_13 = pte_to_swp_entry(VAR_8);
if (!is_migration_entry(VAR_13))
goto no_page;
pte_unmap_unlock(VAR_7, VAR_6);
migration_entry_wait(VAR_5, VAR_2, VAR_1);
goto retry;
}
if ((VAR_3 & VAR_15) && pte_protnone(VAR_8))
goto no_page;
page = vm_normal_page(VAR_0, VAR_1, VAR_8);
if ((VAR_3 & VAR_16) &&
!can_follow_write_pte(VAR_8, page, VAR_0, VAR_3)) {
page = NULL;
goto out;
}
if (!page && pte_devmap(VAR_8) && (VAR_3 & (VAR_11 | VAR_10))) {
*VAR_4 = get_dev_pagemap(pte_pfn(VAR_8), *VAR_4);
if (*VAR_4)
page = pte_page(VAR_8);
else
goto no_page;
} else if (unlikely(!page)) {
if (VAR_3 & VAR_17) {
page = ERR_PTR(-VAR_18);
goto out;
}
if (is_zero_pfn(pte_pfn(VAR_8))) {
page = pte_page(VAR_8);
} else {
VAR_9 = follow_pfn_pte(VAR_0, VAR_1, VAR_7, VAR_3);
page = ERR_PTR(VAR_9);
goto out;
}
}
if (!pte_write(VAR_8) && gup_must_unshare(VAR_3, page)) {
page = ERR_PTR(-VAR_19);
goto out;
}
VM_BUG_ON_PAGE((VAR_3 & VAR_10) && PageAnon(page) &&
!PageAnonExclusive(page), page);
if (unlikely(!try_grab_page(page, VAR_3))) {
page = ERR_PTR(-VAR_20);
goto out;
}
if (VAR_3 & VAR_10) {
VAR_9 = arch_make_page_accessible(page);
if (VAR_9) {
unpin_user_page(page);
page = ERR_PTR(VAR_9);
goto out;
}
}
if (VAR_3 & VAR_21) {
if ((VAR_3 & VAR_16) &&
!pte_dirty(VAR_8) && !PageDirty(page))
set_page_dirty(page);
mark_page_accessed(page);
}
out:
pte_unmap_unlock(VAR_7, VAR_6);
return page;
no_page:
pte_unmap_unlock(VAR_7, VAR_6);
if (!pte_none(VAR_8))
return NULL;
return no_page_table(VAR_0, VAR_3);
}",kernel/git/bpf/bpf-next/fac35ba763ed07ba93154c95ffc0c4a55023707f/gup.c/vul/before/1.json,"static struct page *follow_page_pte(struct vm_area_struct *vma,
		unsigned long address, pmd_t *pmd, unsigned int flags,
		struct dev_pagemap **pgmap)
{
	struct mm_struct *mm = vma->vm_mm;
	struct page *page;
	spinlock_t *ptl;
	pte_t *ptep, pte;
	int ret;

	/* FOLL_GET and FOLL_PIN are mutually exclusive. */
	if (WARN_ON_ONCE((flags & (FOLL_PIN | FOLL_GET)) ==
			 (FOLL_PIN | FOLL_GET)))
		return ERR_PTR(-EINVAL);

	/*
	 * Considering PTE level hugetlb, like continuous-PTE hugetlb on
	 * ARM64 architecture.
	 */
	if (is_vm_hugetlb_page(vma)) {
		page = follow_huge_pmd_pte(vma, address, flags);
		if (page)
			return page;
		return no_page_table(vma, flags);
	}

retry:
	if (unlikely(pmd_bad(*pmd)))
		return no_page_table(vma, flags);

	ptep = pte_offset_map_lock(mm, pmd, address, &ptl);
	pte = *ptep;
	if (!pte_present(pte)) {
		swp_entry_t entry;
		/*
		 * KSM's break_ksm() relies upon recognizing a ksm page
		 * even while it is being migrated, so for that case we
		 * need migration_entry_wait().
		 */
		if (likely(!(flags & FOLL_MIGRATION)))
			goto no_page;
		if (pte_none(pte))
			goto no_page;
		entry = pte_to_swp_entry(pte);
		if (!is_migration_entry(entry))
			goto no_page;
		pte_unmap_unlock(ptep, ptl);
		migration_entry_wait(mm, pmd, address);
		goto retry;
	}
	if ((flags & FOLL_NUMA) && pte_protnone(pte))
		goto no_page;

	page = vm_normal_page(vma, address, pte);

	/*
	 * We only care about anon pages in can_follow_write_pte() and don't
	 * have to worry about pte_devmap() because they are never anon.
	 */
	if ((flags & FOLL_WRITE) &&
	    !can_follow_write_pte(pte, page, vma, flags)) {
		page = NULL;
		goto out;
	}

	if (!page && pte_devmap(pte) && (flags & (FOLL_GET | FOLL_PIN))) {
		/*
		 * Only return device mapping pages in the FOLL_GET or FOLL_PIN
		 * case since they are only valid while holding the pgmap
		 * reference.
		 */
		*pgmap = get_dev_pagemap(pte_pfn(pte), *pgmap);
		if (*pgmap)
			page = pte_page(pte);
		else
			goto no_page;
	} else if (unlikely(!page)) {
		if (flags & FOLL_DUMP) {
			/* Avoid special (like zero) pages in core dumps */
			page = ERR_PTR(-EFAULT);
			goto out;
		}

		if (is_zero_pfn(pte_pfn(pte))) {
			page = pte_page(pte);
		} else {
			ret = follow_pfn_pte(vma, address, ptep, flags);
			page = ERR_PTR(ret);
			goto out;
		}
	}

	if (!pte_write(pte) && gup_must_unshare(flags, page)) {
		page = ERR_PTR(-EMLINK);
		goto out;
	}

	VM_BUG_ON_PAGE((flags & FOLL_PIN) && PageAnon(page) &&
		       !PageAnonExclusive(page), page);

	/* try_grab_page() does nothing unless FOLL_GET or FOLL_PIN is set. */
	if (unlikely(!try_grab_page(page, flags))) {
		page = ERR_PTR(-ENOMEM);
		goto out;
	}
	/*
	 * We need to make the page accessible if and only if we are going
	 * to access its content (the FOLL_PIN case).  Please see
	 * Documentation/core-api/pin_user_pages.rst for details.
	 */
	if (flags & FOLL_PIN) {
		ret = arch_make_page_accessible(page);
		if (ret) {
			unpin_user_page(page);
			page = ERR_PTR(ret);
			goto out;
		}
	}
	if (flags & FOLL_TOUCH) {
		if ((flags & FOLL_WRITE) &&
		    !pte_dirty(pte) && !PageDirty(page))
			set_page_dirty(page);
		/*
		 * pte_mkyoung() would be more correct here, but atomic care
		 * is needed to avoid losing the dirty bit: it is easier to use
		 * mark_page_accessed().
		 */
		mark_page_accessed(page);
	}
out:
	pte_unmap_unlock(ptep, ptl);
	return page;
no_page:
	pte_unmap_unlock(ptep, ptl);
	if (!pte_none(pte))
		return NULL;
	return no_page_table(vma, flags);
}","static struct page *follow_page_pte(struct vm_area_struct *VAR_0,
		unsigned long VAR_1, pmd_t *VAR_2, unsigned int VAR_3,
		struct dev_pagemap **VAR_4)
{
	struct mm_struct *VAR_5 = VAR_0->vm_mm;
	struct page *page;
	spinlock_t *VAR_6;
	pte_t *VAR_7, VAR_8;
	int VAR_9;

	/* COMMENT_0 */
	if (WARN_ON_ONCE((VAR_3 & (VAR_10 | VAR_11)) ==
			 (VAR_10 | VAR_11)))
		return ERR_PTR(-VAR_12);

	/* COMMENT_1 */
                                                                 
                       
    
	if (is_vm_hugetlb_page(VAR_0)) {
		page = follow_huge_pmd_pte(VAR_0, VAR_1, VAR_3);
		if (page)
			return page;
		return no_page_table(VAR_0, VAR_3);
	}

retry:
	if (unlikely(pmd_bad(*VAR_2)))
		return no_page_table(VAR_0, VAR_3);

	VAR_7 = pte_offset_map_lock(VAR_5, VAR_2, VAR_1, &VAR_6);
	VAR_8 = *VAR_7;
	if (!pte_present(VAR_8)) {
		swp_entry_t VAR_13;
		/* COMMENT_5 */
                                                         
                                                         
                                 
     
		if (likely(!(VAR_3 & VAR_14)))
			goto no_page;
		if (pte_none(VAR_8))
			goto no_page;
		VAR_13 = pte_to_swp_entry(VAR_8);
		if (!is_migration_entry(VAR_13))
			goto no_page;
		pte_unmap_unlock(VAR_7, VAR_6);
		migration_entry_wait(VAR_5, VAR_2, VAR_1);
		goto retry;
	}
	if ((VAR_3 & VAR_15) && pte_protnone(VAR_8))
		goto no_page;

	page = vm_normal_page(VAR_0, VAR_1, VAR_8);

	/* COMMENT_10 */
                                                                     
                                                                 
    
	if ((VAR_3 & VAR_16) &&
	    !can_follow_write_pte(VAR_8, page, VAR_0, VAR_3)) {
		page = NULL;
		goto out;
	}

	if (!page && pte_devmap(VAR_8) && (VAR_3 & (VAR_11 | VAR_10))) {
		/* COMMENT_14 */
                                                                 
                                                           
               
     
		*VAR_4 = get_dev_pagemap(pte_pfn(VAR_8), *VAR_4);
		if (*VAR_4)
			page = pte_page(VAR_8);
		else
			goto no_page;
	} else if (unlikely(!page)) {
		if (VAR_3 & VAR_17) {
			/* COMMENT_19 */
			page = ERR_PTR(-VAR_18);
			goto out;
		}

		if (is_zero_pfn(pte_pfn(VAR_8))) {
			page = pte_page(VAR_8);
		} else {
			VAR_9 = follow_pfn_pte(VAR_0, VAR_1, VAR_7, VAR_3);
			page = ERR_PTR(VAR_9);
			goto out;
		}
	}

	if (!pte_write(VAR_8) && gup_must_unshare(VAR_3, page)) {
		page = ERR_PTR(-VAR_19);
		goto out;
	}

	VM_BUG_ON_PAGE((VAR_3 & VAR_10) && PageAnon(page) &&
		       !PageAnonExclusive(page), page);

	/* COMMENT_20 */
	if (unlikely(!try_grab_page(page, VAR_3))) {
		page = ERR_PTR(-VAR_20);
		goto out;
	}
	/* COMMENT_21 */
                                                                   
                                                          
                                                          
    
	if (VAR_3 & VAR_10) {
		VAR_9 = arch_make_page_accessible(page);
		if (VAR_9) {
			unpin_user_page(page);
			page = ERR_PTR(VAR_9);
			goto out;
		}
	}
	if (VAR_3 & VAR_21) {
		if ((VAR_3 & VAR_16) &&
		    !pte_dirty(VAR_8) && !PageDirty(page))
			set_page_dirty(page);
		/* COMMENT_26 */
                                                              
                                                                 
                          
     
		mark_page_accessed(page);
	}
out:
	pte_unmap_unlock(VAR_7, VAR_6);
	return page;
no_page:
	pte_unmap_unlock(VAR_7, VAR_6);
	if (!pte_none(VAR_8))
		return NULL;
	return no_page_table(VAR_0, VAR_3);
}",kernel/git/bpf/bpf-next/fac35ba763ed07ba93154c95ffc0c4a55023707f/gup.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -12,6 +12,18 @@
 	if (WARN_ON_ONCE((flags & (FOLL_PIN | FOLL_GET)) ==
 			 (FOLL_PIN | FOLL_GET)))
 		return ERR_PTR(-EINVAL);
+
+	/*
+	 * Considering PTE level hugetlb, like continuous-PTE hugetlb on
+	 * ARM64 architecture.
+	 */
+	if (is_vm_hugetlb_page(vma)) {
+		page = follow_huge_pmd_pte(vma, address, flags);
+		if (page)
+			return page;
+		return no_page_table(vma, flags);
+	}
+
 retry:
 	if (unlikely(pmd_bad(*pmd)))
 		return no_page_table(vma, flags);","{'deleted_lines': [], 'added_lines': ['', '\t/*', '\t * Considering PTE level hugetlb, like continuous-PTE hugetlb on', '\t * ARM64 architecture.', '\t */', '\tif (is_vm_hugetlb_page(vma)) {', '\t\tpage = follow_huge_pmd_pte(vma, address, flags);', '\t\tif (page)', '\t\t\treturn page;', '\t\treturn no_page_table(vma, flags);', '\t}', '']}",True,A vulnerability was found in Linux Kernel. It has been declared as problematic. Affected by this vulnerability is the function follow_page_pte of the file mm/gup.c of the component BPF. The manipulation leads to race condition. The attack can be launched remotely. It is recommended to apply a patch to fix this issue. The identifier VDB-211921 was assigned to this vulnerability.,7.5,HIGH,2,test,,5
CVE-2022-3649,['CWE-119'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,kernel/git/bpf/bpf-next,"If the beginning of the inode bitmap area is corrupted on disk, an inode
with the same inode number as the root inode can be allocated and fail
soon after.  In this case, the subsequent call to nilfs_clear_inode() on
that bogus root inode will wrongly decrement the reference counter of
struct nilfs_root, and this will erroneously free struct nilfs_root,
causing kernel oopses.

This fixes the problem by changing nilfs_new_inode() to skip reserved
inode numbers while repairing the inode bitmap.

Link: https://lkml.kernel.org/r/20221003150519.39789-1-konishi.ryusuke@gmail.com
Signed-off-by: Ryusuke Konishi <konishi.ryusuke@gmail.com>
Reported-by: syzbot+b8c672b0e22615c80fe0@syzkaller.appspotmail.com
Reported-by: Khalid Masum <khalid.masum.92@gmail.com>
Tested-by: Ryusuke Konishi <konishi.ryusuke@gmail.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
",d325dc6eb763c10f591c239550b8c7e5466a5d09,https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next.git/commit/?h=d325dc6eb763c10f591c239550b8c7e5466a5d09,fs/nilfs2/inode.c,nilfs_new_inode,"struct inode *nilfs_new_inode(struct inode *dir, umode_t mode)
{
struct super_block *sb = dir->i_sb;
struct the_nilfs *nilfs = sb->s_fs_info;
struct inode *inode;
struct nilfs_inode_info *ii;
struct nilfs_root *root;
int err = -ENOMEM;
ino_t ino;
inode = new_inode(sb);
if (unlikely(!inode))
goto failed;
mapping_set_gfp_mask(inode->i_mapping,
mapping_gfp_constraint(inode->i_mapping, ~__GFP_FS));
root = NILFS_I(dir)->i_root;
ii = NILFS_I(inode);
ii->i_state = BIT(NILFS_I_NEW);
ii->i_root = root;
err = nilfs_ifile_create_inode(root->ifile, &ino, &ii->i_bh);
if (unlikely(err))
goto failed_ifile_create_inode;
atomic64_inc(&root->inodes_count);
inode_init_owner(&init_user_ns, inode, dir, mode);
inode->i_ino = ino;
inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
if (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)) {
err = nilfs_bmap_read(ii->i_bmap, NULL);
if (err < 0)
goto failed_after_creation;
set_bit(NILFS_I_BMAP, &ii->i_state);
}
ii->i_flags = nilfs_mask_flags(
mode, NILFS_I(dir)->i_flags & NILFS_FL_INHERITED);
ii->i_dir_start_lookup = 0;
nilfs_set_inode_flags(inode);
spin_lock(&nilfs->ns_next_gen_lock);
inode->i_generation = nilfs->ns_next_generation++;
spin_unlock(&nilfs->ns_next_gen_lock);
if (nilfs_insert_inode_locked(inode, root, ino) < 0) {
err = -EIO;
goto failed_after_creation;
}
err = nilfs_init_acl(inode, dir);
if (unlikely(err))
goto failed_after_creation;
return inode;
failed_after_creation:
clear_nlink(inode);
if (inode->i_state & I_NEW)
unlock_new_inode(inode);
iput(inode);  
goto failed;
failed_ifile_create_inode:
make_bad_inode(inode);
iput(inode);
failed:
return ERR_PTR(err);
}","struct inode *nilfs_new_inode(struct inode *VAR_0, umode_t VAR_1)
{
struct super_block *VAR_2 = VAR_0->i_sb;
struct the_nilfs *VAR_3 = VAR_2->s_fs_info;
struct inode *inode;
struct nilfs_inode_info *VAR_4;
struct nilfs_root *VAR_5;
int VAR_6 = -VAR_7;
ino_t VAR_8;
inode = new_inode(VAR_2);
if (unlikely(!inode))
goto failed;
mapping_set_gfp_mask(inode->i_mapping,
mapping_gfp_constraint(inode->i_mapping, ~VAR_9));
VAR_5 = NILFS_I(VAR_0)->i_root;
VAR_4 = NILFS_I(inode);
VAR_4->i_state = BIT(VAR_10);
VAR_4->i_root = VAR_5;
VAR_6 = nilfs_ifile_create_inode(VAR_5->ifile, &VAR_8, &VAR_4->i_bh);
if (unlikely(VAR_6))
goto failed_ifile_create_inode;
atomic64_inc(&VAR_5->inodes_count);
inode_init_owner(&VAR_11, inode, VAR_0, VAR_1);
inode->i_ino = VAR_8;
inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);
if (S_ISREG(VAR_1) || S_ISDIR(VAR_1) || S_ISLNK(VAR_1)) {
VAR_6 = nilfs_bmap_read(VAR_4->i_bmap, NULL);
if (VAR_6 < 0)
goto failed_after_creation;
set_bit(VAR_12, &VAR_4->i_state);
}
VAR_4->i_flags = nilfs_mask_flags(
VAR_1, NILFS_I(VAR_0)->i_flags & VAR_13);
VAR_4->i_dir_start_lookup = 0;
nilfs_set_inode_flags(inode);
spin_lock(&VAR_3->ns_next_gen_lock);
inode->i_generation = VAR_3->ns_next_generation++;
spin_unlock(&VAR_3->ns_next_gen_lock);
if (nilfs_insert_inode_locked(inode, VAR_5, VAR_8) < 0) {
VAR_6 = -VAR_14;
goto failed_after_creation;
}
VAR_6 = nilfs_init_acl(inode, VAR_0);
if (unlikely(VAR_6))
goto failed_after_creation;
return inode;
failed_after_creation:
clear_nlink(inode);
if (inode->i_state & VAR_15)
unlock_new_inode(inode);
iput(inode);  
goto failed;
failed_ifile_create_inode:
make_bad_inode(inode);
iput(inode);
failed:
return ERR_PTR(VAR_6);
}",kernel/git/bpf/bpf-next/d325dc6eb763c10f591c239550b8c7e5466a5d09/inode.c/vul/before/0.json,"struct inode *nilfs_new_inode(struct inode *dir, umode_t mode)
{
	struct super_block *sb = dir->i_sb;
	struct the_nilfs *nilfs = sb->s_fs_info;
	struct inode *inode;
	struct nilfs_inode_info *ii;
	struct nilfs_root *root;
	struct buffer_head *bh;
	int err = -ENOMEM;
	ino_t ino;

	inode = new_inode(sb);
	if (unlikely(!inode))
		goto failed;

	mapping_set_gfp_mask(inode->i_mapping,
			   mapping_gfp_constraint(inode->i_mapping, ~__GFP_FS));

	root = NILFS_I(dir)->i_root;
	ii = NILFS_I(inode);
	ii->i_state = BIT(NILFS_I_NEW);
	ii->i_root = root;

	err = nilfs_ifile_create_inode(root->ifile, &ino, &bh);
	if (unlikely(err))
		goto failed_ifile_create_inode;
	/* reference count of i_bh inherits from nilfs_mdt_read_block() */

	if (unlikely(ino < NILFS_USER_INO)) {
		nilfs_warn(sb,
			   ""inode bitmap is inconsistent for reserved inodes"");
		do {
			brelse(bh);
			err = nilfs_ifile_create_inode(root->ifile, &ino, &bh);
			if (unlikely(err))
				goto failed_ifile_create_inode;
		} while (ino < NILFS_USER_INO);

		nilfs_info(sb, ""repaired inode bitmap for reserved inodes"");
	}
	ii->i_bh = bh;

	atomic64_inc(&root->inodes_count);
	inode_init_owner(&init_user_ns, inode, dir, mode);
	inode->i_ino = ino;
	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);

	if (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)) {
		err = nilfs_bmap_read(ii->i_bmap, NULL);
		if (err < 0)
			goto failed_after_creation;

		set_bit(NILFS_I_BMAP, &ii->i_state);
		/* No lock is needed; iget() ensures it. */
	}

	ii->i_flags = nilfs_mask_flags(
		mode, NILFS_I(dir)->i_flags & NILFS_FL_INHERITED);

	/* ii->i_file_acl = 0; */
	/* ii->i_dir_acl = 0; */
	ii->i_dir_start_lookup = 0;
	nilfs_set_inode_flags(inode);
	spin_lock(&nilfs->ns_next_gen_lock);
	inode->i_generation = nilfs->ns_next_generation++;
	spin_unlock(&nilfs->ns_next_gen_lock);
	if (nilfs_insert_inode_locked(inode, root, ino) < 0) {
		err = -EIO;
		goto failed_after_creation;
	}

	err = nilfs_init_acl(inode, dir);
	if (unlikely(err))
		/*
		 * Never occur.  When supporting nilfs_init_acl(),
		 * proper cancellation of above jobs should be considered.
		 */
		goto failed_after_creation;

	return inode;

 failed_after_creation:
	clear_nlink(inode);
	if (inode->i_state & I_NEW)
		unlock_new_inode(inode);
	iput(inode);  /*
		       * raw_inode will be deleted through
		       * nilfs_evict_inode().
		       */
	goto failed;

 failed_ifile_create_inode:
	make_bad_inode(inode);
	iput(inode);
 failed:
	return ERR_PTR(err);
}","struct inode *nilfs_new_inode(struct inode *VAR_0, umode_t VAR_1)
{
	struct super_block *VAR_2 = VAR_0->i_sb;
	struct the_nilfs *VAR_3 = VAR_2->s_fs_info;
	struct inode *inode;
	struct nilfs_inode_info *VAR_4;
	struct nilfs_root *VAR_5;
	struct buffer_head *VAR_6;
	int VAR_7 = -VAR_8;
	ino_t VAR_9;

	inode = new_inode(VAR_2);
	if (unlikely(!inode))
		goto failed;

	mapping_set_gfp_mask(inode->i_mapping,
			   mapping_gfp_constraint(inode->i_mapping, ~VAR_10));

	VAR_5 = NILFS_I(VAR_0)->i_root;
	VAR_4 = NILFS_I(inode);
	VAR_4->i_state = BIT(VAR_11);
	VAR_4->i_root = VAR_5;

	VAR_7 = nilfs_ifile_create_inode(VAR_5->ifile, &VAR_9, &VAR_6);
	if (unlikely(VAR_7))
		goto failed_ifile_create_inode;
	/* COMMENT_0 */

	if (unlikely(VAR_9 < VAR_12)) {
		nilfs_warn(VAR_2,
			   ""inode bitmap is inconsistent for reserved inodes"");
		do {
			brelse(VAR_6);
			VAR_7 = nilfs_ifile_create_inode(VAR_5->ifile, &VAR_9, &VAR_6);
			if (unlikely(VAR_7))
				goto failed_ifile_create_inode;
		} while (VAR_9 < VAR_12);

		nilfs_info(VAR_2, ""repaired inode bitmap for reserved inodes"");
	}
	VAR_4->i_bh = VAR_6;

	atomic64_inc(&VAR_5->inodes_count);
	inode_init_owner(&VAR_13, inode, VAR_0, VAR_1);
	inode->i_ino = VAR_9;
	inode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);

	if (S_ISREG(VAR_1) || S_ISDIR(VAR_1) || S_ISLNK(VAR_1)) {
		VAR_7 = nilfs_bmap_read(VAR_4->i_bmap, NULL);
		if (VAR_7 < 0)
			goto failed_after_creation;

		set_bit(VAR_14, &VAR_4->i_state);
		/* COMMENT_1 */
	}

	VAR_4->i_flags = nilfs_mask_flags(
		VAR_1, NILFS_I(VAR_0)->i_flags & VAR_15);

	/* COMMENT_2 */
	/* COMMENT_3 */
	VAR_4->i_dir_start_lookup = 0;
	nilfs_set_inode_flags(inode);
	spin_lock(&VAR_3->ns_next_gen_lock);
	inode->i_generation = VAR_3->ns_next_generation++;
	spin_unlock(&VAR_3->ns_next_gen_lock);
	if (nilfs_insert_inode_locked(inode, VAR_5, VAR_9) < 0) {
		VAR_7 = -VAR_16;
		goto failed_after_creation;
	}

	VAR_7 = nilfs_init_acl(inode, VAR_0);
	if (unlikely(VAR_7))
		/* COMMENT_4 */
                                                    
                                                            
     
		goto failed_after_creation;

	return inode;

 failed_after_creation:
	clear_nlink(inode);
	if (inode->i_state & VAR_17)
		unlock_new_inode(inode);
	iput(inode);  /* COMMENT_8 */
                                            
                               
           
	goto failed;

 failed_ifile_create_inode:
	make_bad_inode(inode);
	iput(inode);
 failed:
	return ERR_PTR(VAR_7);
}",kernel/git/bpf/bpf-next/d325dc6eb763c10f591c239550b8c7e5466a5d09/inode.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,6 +5,7 @@
 	struct inode *inode;
 	struct nilfs_inode_info *ii;
 	struct nilfs_root *root;
+	struct buffer_head *bh;
 	int err = -ENOMEM;
 	ino_t ino;
 
@@ -20,10 +21,24 @@
 	ii->i_state = BIT(NILFS_I_NEW);
 	ii->i_root = root;
 
-	err = nilfs_ifile_create_inode(root->ifile, &ino, &ii->i_bh);
+	err = nilfs_ifile_create_inode(root->ifile, &ino, &bh);
 	if (unlikely(err))
 		goto failed_ifile_create_inode;
 	/* reference count of i_bh inherits from nilfs_mdt_read_block() */
+
+	if (unlikely(ino < NILFS_USER_INO)) {
+		nilfs_warn(sb,
+			   ""inode bitmap is inconsistent for reserved inodes"");
+		do {
+			brelse(bh);
+			err = nilfs_ifile_create_inode(root->ifile, &ino, &bh);
+			if (unlikely(err))
+				goto failed_ifile_create_inode;
+		} while (ino < NILFS_USER_INO);
+
+		nilfs_info(sb, ""repaired inode bitmap for reserved inodes"");
+	}
+	ii->i_bh = bh;
 
 	atomic64_inc(&root->inodes_count);
 	inode_init_owner(&init_user_ns, inode, dir, mode);","{'deleted_lines': ['\terr = nilfs_ifile_create_inode(root->ifile, &ino, &ii->i_bh);'], 'added_lines': ['\tstruct buffer_head *bh;', '\terr = nilfs_ifile_create_inode(root->ifile, &ino, &bh);', '', '\tif (unlikely(ino < NILFS_USER_INO)) {', '\t\tnilfs_warn(sb,', '\t\t\t   ""inode bitmap is inconsistent for reserved inodes"");', '\t\tdo {', '\t\t\tbrelse(bh);', '\t\t\terr = nilfs_ifile_create_inode(root->ifile, &ino, &bh);', '\t\t\tif (unlikely(err))', '\t\t\t\tgoto failed_ifile_create_inode;', '\t\t} while (ino < NILFS_USER_INO);', '', '\t\tnilfs_info(sb, ""repaired inode bitmap for reserved inodes"");', '\t}', '\tii->i_bh = bh;']}",True,A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is the function nilfs_new_inode of the file fs/nilfs2/inode.c of the component BPF. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211992.,7.0,HIGH,2,test,,5
CVE-2017-13722,['CWE-125'],AV:L/AC:L/Au:N/C:P/I:N/A:P,0,xorg/lib/libXfont,"Without the checks a malformed PCF file can cause the library to make
atom from random heap memory that was behind the `strings` buffer.
This may crash the process or leak information.

Signed-off-by: Julien Cristau <jcristau@debian.org>
",672bb944311392e2415b39c0d63b1e1902905bcd,https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=672bb944311392e2415b39c0d63b1e1902905bcd,src/bitmap/pcfread.c,pcfGetProperties,"static Bool
pcfGetProperties(FontInfoPtr pFontInfo, FontFilePtr file,
PCFTablePtr tables, int ntables)
{
FontPropPtr props = 0;
int         nprops;
char       *isStringProp = 0;
CARD32      format;
int         i;
CARD32      size;
int         string_size;
char       *strings;
if (!pcfSeekToType(file, tables, ntables, PCF_PROPERTIES, &format, &size))
goto Bail;
format = pcfGetLSB32(file);
if (!PCF_FORMAT_MATCH(format, PCF_DEFAULT_FORMAT))
goto Bail;
nprops = pcfGetINT32(file, format);
if (nprops <= 0 || nprops > INT32_MAX / sizeof(FontPropRec)) {
pcfError(""pcfGetProperties(): invalid nprops value (%d)\n"", nprops);
goto Bail;
}
if (IS_EOF(file)) goto Bail;
props = malloc(nprops * sizeof(FontPropRec));
if (!props) {
pcfError(""pcfGetProperties(): Couldn't allocate props (%d*%d)\n"",
nprops, (int) sizeof(FontPropRec));
goto Bail;
}
isStringProp = malloc(nprops * sizeof(char));
if (!isStringProp) {
pcfError(""pcfGetProperties(): Couldn't allocate isStringProp (%d*%d)\n"",
nprops, (int) sizeof(char));
goto Bail;
}
for (i = 0; i < nprops; i++) {
props[i].name = pcfGetINT32(file, format);
isStringProp[i] = pcfGetINT8(file, format);
props[i].value = pcfGetINT32(file, format);
if (props[i].name < 0
|| (isStringProp[i] != 0 && isStringProp[i] != 1)
|| (isStringProp[i] && props[i].value < 0)) {
pcfError(""pcfGetProperties(): invalid file format %ld %d %ld\n"",
props[i].name, isStringProp[i], props[i].value);
goto Bail;
}
if (IS_EOF(file)) goto Bail;
}
if (nprops & 3)
{
i = 4 - (nprops & 3);
(void)FontFileSkip(file, i);
position += i;
}
if (IS_EOF(file)) goto Bail;
string_size = pcfGetINT32(file, format);
if (string_size < 0) goto Bail;
if (IS_EOF(file)) goto Bail;
strings = malloc(string_size);
if (!strings) {
pcfError(""pcfGetProperties(): Couldn't allocate strings (%d)\n"", string_size);
goto Bail;
}
FontFileRead(file, strings, string_size);
if (IS_EOF(file)) goto Bail;
position += string_size;
for (i = 0; i < nprops; i++) {
props[i].name = MakeAtom(strings + props[i].name,
strlen(strings + props[i].name), TRUE);
if (isStringProp[i]) {
props[i].value = MakeAtom(strings + props[i].value,
strlen(strings + props[i].value), TRUE);
}
}
free(strings);
pFontInfo->isStringProp = isStringProp;
pFontInfo->props = props;
pFontInfo->nprops = nprops;
return TRUE;
Bail:
free(isStringProp);
free(props);
return FALSE;
}","static Bool
pcfGetProperties(FontInfoPtr VAR_0, FontFilePtr VAR_1,
PCFTablePtr VAR_2, int VAR_3)
{
FontPropPtr VAR_4 = 0;
int         VAR_5;
char       *VAR_6 = 0;
CARD32      VAR_7;
int         VAR_8;
CARD32      VAR_9;
int         VAR_10;
char       *VAR_11;
if (!pcfSeekToType(VAR_1, VAR_2, VAR_3, VAR_12, &VAR_7, &VAR_9))
goto Bail;
VAR_7 = pcfGetLSB32(VAR_1);
if (!PCF_FORMAT_MATCH(VAR_7, VAR_13))
goto Bail;
VAR_5 = pcfGetINT32(VAR_1, VAR_7);
if (VAR_5 <= 0 || VAR_5 > VAR_14 / sizeof(VAR_15)) {
pcfError(""pcfGetProperties(): invalid nprops value (%d)\n"", VAR_5);
goto Bail;
}
if (IS_EOF(VAR_1)) goto Bail;
VAR_4 = malloc(VAR_5 * sizeof(VAR_15));
if (!VAR_4) {
pcfError(""pcfGetProperties(): Couldn't allocate props (%d*%d)\n"",
VAR_5, (int) sizeof(VAR_15));
goto Bail;
}
VAR_6 = malloc(VAR_5 * sizeof(char));
if (!VAR_6) {
pcfError(""pcfGetProperties(): Couldn't allocate isStringProp (%d*%d)\n"",
VAR_5, (int) sizeof(char));
goto Bail;
}
for (VAR_8 = 0; VAR_8 < VAR_5; VAR_8++) {
VAR_4[VAR_8].name = pcfGetINT32(VAR_1, VAR_7);
VAR_6[VAR_8] = pcfGetINT8(VAR_1, VAR_7);
VAR_4[VAR_8].value = pcfGetINT32(VAR_1, VAR_7);
if (VAR_4[VAR_8].name < 0
|| (VAR_6[VAR_8] != 0 && VAR_6[VAR_8] != 1)
|| (VAR_6[VAR_8] && VAR_4[VAR_8].value < 0)) {
pcfError(""pcfGetProperties(): invalid file format %ld %d %ld\n"",
VAR_4[VAR_8].name, VAR_6[VAR_8], VAR_4[VAR_8].value);
goto Bail;
}
if (IS_EOF(VAR_1)) goto Bail;
}
if (VAR_5 & 3)
{
VAR_8 = 4 - (VAR_5 & 3);
(void)FontFileSkip(VAR_1, VAR_8);
VAR_16 += VAR_8;
}
if (IS_EOF(VAR_1)) goto Bail;
VAR_10 = pcfGetINT32(VAR_1, VAR_7);
if (VAR_10 < 0) goto Bail;
if (IS_EOF(VAR_1)) goto Bail;
VAR_11 = malloc(VAR_10);
if (!VAR_11) {
pcfError(""pcfGetProperties(): Couldn't allocate strings (%d)\n"", VAR_10);
goto Bail;
}
FontFileRead(VAR_1, VAR_11, VAR_10);
if (IS_EOF(VAR_1)) goto Bail;
VAR_16 += VAR_10;
for (VAR_8 = 0; VAR_8 < VAR_5; VAR_8++) {
VAR_4[VAR_8].name = MakeAtom(VAR_11 + VAR_4[VAR_8].name,
strlen(VAR_11 + VAR_4[VAR_8].name), TRUE);
if (VAR_6[VAR_8]) {
VAR_4[VAR_8].value = MakeAtom(VAR_11 + VAR_4[VAR_8].value,
strlen(VAR_11 + VAR_4[VAR_8].value), TRUE);
}
}
free(VAR_11);
VAR_0->isStringProp = VAR_6;
VAR_0->props = VAR_4;
VAR_0->nprops = VAR_5;
return TRUE;
Bail:
free(VAR_6);
free(VAR_4);
return FALSE;
}",xorg/lib/libXfont/672bb944311392e2415b39c0d63b1e1902905bcd/pcfread.c/vul/before/0.json,"static Bool
pcfGetProperties(FontInfoPtr pFontInfo, FontFilePtr file,
		 PCFTablePtr tables, int ntables)
{
    FontPropPtr props = 0;
    int         nprops;
    char       *isStringProp = 0;
    CARD32      format;
    int         i;
    CARD32      size;
    int         string_size;
    char       *strings;

    /* font properties */

    if (!pcfSeekToType(file, tables, ntables, PCF_PROPERTIES, &format, &size))
	goto Bail;
    format = pcfGetLSB32(file);
    if (!PCF_FORMAT_MATCH(format, PCF_DEFAULT_FORMAT))
	goto Bail;
    nprops = pcfGetINT32(file, format);
    if (nprops <= 0 || nprops > INT32_MAX / sizeof(FontPropRec)) {
	pcfError(""pcfGetProperties(): invalid nprops value (%d)\n"", nprops);
	goto Bail;
    }
    if (IS_EOF(file)) goto Bail;
    props = malloc(nprops * sizeof(FontPropRec));
    if (!props) {
	pcfError(""pcfGetProperties(): Couldn't allocate props (%d*%d)\n"",
	       nprops, (int) sizeof(FontPropRec));
	goto Bail;
    }
    isStringProp = malloc(nprops * sizeof(char));
    if (!isStringProp) {
	pcfError(""pcfGetProperties(): Couldn't allocate isStringProp (%d*%d)\n"",
	       nprops, (int) sizeof(char));
	goto Bail;
    }
    for (i = 0; i < nprops; i++) {
	props[i].name = pcfGetINT32(file, format);
	isStringProp[i] = pcfGetINT8(file, format);
	props[i].value = pcfGetINT32(file, format);
	if (props[i].name < 0
	    || (isStringProp[i] != 0 && isStringProp[i] != 1)
	    || (isStringProp[i] && props[i].value < 0)) {
	    pcfError(""pcfGetProperties(): invalid file format %ld %d %ld\n"",
		     props[i].name, isStringProp[i], props[i].value);
	    goto Bail;
	}
	if (IS_EOF(file)) goto Bail;
    }
    /* pad the property array */
    /*
     * clever here - nprops is the same as the number of odd-units read, as
     * only isStringProp are odd length
     */
    if (nprops & 3)
    {
	i = 4 - (nprops & 3);
	(void)FontFileSkip(file, i);
	position += i;
    }
    if (IS_EOF(file)) goto Bail;
    string_size = pcfGetINT32(file, format);
    if (string_size < 0) goto Bail;
    if (IS_EOF(file)) goto Bail;
    strings = malloc(string_size);
    if (!strings) {
      pcfError(""pcfGetProperties(): Couldn't allocate strings (%d)\n"", string_size);
	goto Bail;
    }
    FontFileRead(file, strings, string_size);
    if (IS_EOF(file)) goto Bail;
    position += string_size;
    for (i = 0; i < nprops; i++) {
	if (props[i].name >= string_size) {
	    pcfError(""pcfGetProperties(): String starts out of bounds (%ld/%d)\n"", props[i].name, string_size);
	    goto Bail;
	}
	props[i].name = MakeAtom(strings + props[i].name,
				 strnlen(strings + props[i].name, string_size - props[i].name), TRUE);
	if (isStringProp[i]) {
	    if (props[i].value >= string_size) {
		pcfError(""pcfGetProperties(): String starts out of bounds (%ld/%d)\n"", props[i].value, string_size);
		goto Bail;
	    }
	    props[i].value = MakeAtom(strings + props[i].value,
				      strnlen(strings + props[i].value, string_size - props[i].value), TRUE);
	}
    }
    free(strings);
    pFontInfo->isStringProp = isStringProp;
    pFontInfo->props = props;
    pFontInfo->nprops = nprops;
    return TRUE;
Bail:
    free(isStringProp);
    free(props);
    return FALSE;
}","static Bool
pcfGetProperties(FontInfoPtr VAR_0, FontFilePtr VAR_1,
		 PCFTablePtr VAR_2, int VAR_3)
{
    FontPropPtr VAR_4 = 0;
    int         VAR_5;
    char       *VAR_6 = 0;
    CARD32      VAR_7;
    int         VAR_8;
    CARD32      VAR_9;
    int         VAR_10;
    char       *VAR_11;

    /* COMMENT_0 */

    if (!pcfSeekToType(VAR_1, VAR_2, VAR_3, VAR_12, &VAR_7, &VAR_9))
	goto Bail;
    VAR_7 = pcfGetLSB32(VAR_1);
    if (!PCF_FORMAT_MATCH(VAR_7, VAR_13))
	goto Bail;
    VAR_5 = pcfGetINT32(VAR_1, VAR_7);
    if (VAR_5 <= 0 || VAR_5 > VAR_14 / sizeof(VAR_15)) {
	pcfError(""pcfGetProperties(): invalid nprops value (%d)\n"", VAR_5);
	goto Bail;
    }
    if (IS_EOF(VAR_1)) goto Bail;
    VAR_4 = malloc(VAR_5 * sizeof(VAR_15));
    if (!VAR_4) {
	pcfError(""pcfGetProperties(): Couldn't allocate props (%d*%d)\n"",
	       VAR_5, (int) sizeof(VAR_15));
	goto Bail;
    }
    VAR_6 = malloc(VAR_5 * sizeof(char));
    if (!VAR_6) {
	pcfError(""pcfGetProperties(): Couldn't allocate isStringProp (%d*%d)\n"",
	       VAR_5, (int) sizeof(char));
	goto Bail;
    }
    for (VAR_8 = 0; VAR_8 < VAR_5; VAR_8++) {
	VAR_4[VAR_8].name = pcfGetINT32(VAR_1, VAR_7);
	VAR_6[VAR_8] = pcfGetINT8(VAR_1, VAR_7);
	VAR_4[VAR_8].value = pcfGetINT32(VAR_1, VAR_7);
	if (VAR_4[VAR_8].name < 0
	    || (VAR_6[VAR_8] != 0 && VAR_6[VAR_8] != 1)
	    || (VAR_6[VAR_8] && VAR_4[VAR_8].value < 0)) {
	    pcfError(""pcfGetProperties(): invalid file format %ld %d %ld\n"",
		     VAR_4[VAR_8].name, VAR_6[VAR_8], VAR_4[VAR_8].value);
	    goto Bail;
	}
	if (IS_EOF(VAR_1)) goto Bail;
    }
    /* COMMENT_1 */
    /* COMMENT_2 */
                                                                           
                                       
       
    if (VAR_5 & 3)
    {
	VAR_8 = 4 - (VAR_5 & 3);
	(void)FontFileSkip(VAR_1, VAR_8);
	VAR_16 += VAR_8;
    }
    if (IS_EOF(VAR_1)) goto Bail;
    VAR_10 = pcfGetINT32(VAR_1, VAR_7);
    if (VAR_10 < 0) goto Bail;
    if (IS_EOF(VAR_1)) goto Bail;
    VAR_11 = malloc(VAR_10);
    if (!VAR_11) {
      pcfError(""pcfGetProperties(): Couldn't allocate strings (%d)\n"", VAR_10);
	goto Bail;
    }
    FontFileRead(VAR_1, VAR_11, VAR_10);
    if (IS_EOF(VAR_1)) goto Bail;
    VAR_16 += VAR_10;
    for (VAR_8 = 0; VAR_8 < VAR_5; VAR_8++) {
	if (VAR_4[VAR_8].name >= VAR_10) {
	    pcfError(""pcfGetProperties(): String starts out of bounds (%ld/%d)\n"", VAR_4[VAR_8].name, VAR_10);
	    goto Bail;
	}
	VAR_4[VAR_8].name = MakeAtom(VAR_11 + VAR_4[VAR_8].name,
				 strnlen(VAR_11 + VAR_4[VAR_8].name, VAR_10 - VAR_4[VAR_8].name), TRUE);
	if (VAR_6[VAR_8]) {
	    if (VAR_4[VAR_8].value >= VAR_10) {
		pcfError(""pcfGetProperties(): String starts out of bounds (%ld/%d)\n"", VAR_4[VAR_8].value, VAR_10);
		goto Bail;
	    }
	    VAR_4[VAR_8].value = MakeAtom(VAR_11 + VAR_4[VAR_8].value,
				      strnlen(VAR_11 + VAR_4[VAR_8].value, VAR_10 - VAR_4[VAR_8].value), TRUE);
	}
    }
    free(VAR_11);
    VAR_0->isStringProp = VAR_6;
    VAR_0->props = VAR_4;
    VAR_0->nprops = VAR_5;
    return TRUE;
Bail:
    free(VAR_6);
    free(VAR_4);
    return FALSE;
}",xorg/lib/libXfont/672bb944311392e2415b39c0d63b1e1902905bcd/pcfread.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -73,11 +73,19 @@
     if (IS_EOF(file)) goto Bail;
     position += string_size;
     for (i = 0; i < nprops; i++) {
+	if (props[i].name >= string_size) {
+	    pcfError(""pcfGetProperties(): String starts out of bounds (%ld/%d)\n"", props[i].name, string_size);
+	    goto Bail;
+	}
 	props[i].name = MakeAtom(strings + props[i].name,
-				 strlen(strings + props[i].name), TRUE);
+				 strnlen(strings + props[i].name, string_size - props[i].name), TRUE);
 	if (isStringProp[i]) {
+	    if (props[i].value >= string_size) {
+		pcfError(""pcfGetProperties(): String starts out of bounds (%ld/%d)\n"", props[i].value, string_size);
+		goto Bail;
+	    }
 	    props[i].value = MakeAtom(strings + props[i].value,
-				      strlen(strings + props[i].value), TRUE);
+				      strnlen(strings + props[i].value, string_size - props[i].value), TRUE);
 	}
     }
     free(strings);","{'deleted_lines': ['\t\t\t\t strlen(strings + props[i].name), TRUE);', '\t\t\t\t      strlen(strings + props[i].value), TRUE);'], 'added_lines': ['\tif (props[i].name >= string_size) {', '\t    pcfError(""pcfGetProperties(): String starts out of bounds (%ld/%d)\\n"", props[i].name, string_size);', '\t    goto Bail;', '\t}', '\t\t\t\t strnlen(strings + props[i].name, string_size - props[i].name), TRUE);', '\t    if (props[i].value >= string_size) {', '\t\tpcfError(""pcfGetProperties(): String starts out of bounds (%ld/%d)\\n"", props[i].value, string_size);', '\t\tgoto Bail;', '\t    }', '\t\t\t\t      strnlen(strings + props[i].value, string_size - props[i].value), TRUE);']}",True,"In the pcfGetProperties function in bitmap/pcfread.c in libXfont through 1.5.2 and 2.x before 2.0.2, a missing boundary check (for PCF files) could be used by local attackers authenticated to an Xserver for a buffer over-read, for information disclosure or a crash of the X server.",7.1,HIGH,2,test,,5
CVE-2017-13089,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,wget,"* src/http.c (skip_short_body): Return error on negative chunk size

Reported-by: Antti Levomki, Christian Jalio, Joonas Pihlaja from Forcepoint
Reported-by: Juhani Eronen from Finnish National Cyber Security Centre
",d892291fb8ace4c3b734ea5125770989c215df3f,http://git.savannah.gnu.org/cgit/wget.git/commit/?id=d892291fb8ace4c3b734ea5125770989c215df3f,src/http.c,skip_short_body,"static bool
skip_short_body (int fd, wgint contlen, bool chunked)
{
enum {
SKIP_SIZE = 512,                
SKIP_THRESHOLD = 4096        
};
wgint remaining_chunk_size = 0;
char dlbuf[SKIP_SIZE + 1];
dlbuf[SKIP_SIZE] = '\0';        
if (contlen > SKIP_THRESHOLD)
return false;
while (contlen > 0 || chunked)
{
int ret;
if (chunked)
{
if (remaining_chunk_size == 0)
{
char *line = fd_read_line (fd);
char *endl;
if (line == NULL)
break;
remaining_chunk_size = strtol (line, &endl, 16);
xfree (line);
if (remaining_chunk_size == 0)
{
line = fd_read_line (fd);
xfree (line);
break;
}
}
contlen = MIN (remaining_chunk_size, SKIP_SIZE);
}
DEBUGP ((""Skipping %s bytes of body: ["", number_to_static_string (contlen)));
ret = fd_read (fd, dlbuf, MIN (contlen, SKIP_SIZE), -1);
if (ret <= 0)
{
DEBUGP ((""] aborting (%s).\n"",
ret < 0 ? fd_errstr (fd) : ""EOF received""));
return false;
}
contlen -= ret;
if (chunked)
{
remaining_chunk_size -= ret;
if (remaining_chunk_size == 0)
{
char *line = fd_read_line (fd);
if (line == NULL)
return false;
else
xfree (line);
}
}
DEBUGP ((""%.*s"", ret, dlbuf));
}
DEBUGP ((""] done.\n""));
return true;
}","static bool
skip_short_body (int VAR_0, wgint VAR_1, bool VAR_2)
{
enum {
VAR_3 = 512,                
VAR_4 = 4096        
};
wgint VAR_5 = 0;
char VAR_6[VAR_3 + 1];
VAR_6[VAR_3] = '\0';        
if (VAR_1 > VAR_4)
return false;
while (VAR_1 > 0 || VAR_2)
{
int VAR_7;
if (VAR_2)
{
if (VAR_5 == 0)
{
char *VAR_8 = fd_read_line (VAR_0);
char *VAR_9;
if (VAR_8 == NULL)
break;
VAR_5 = strtol (VAR_8, &VAR_9, 16);
xfree (VAR_8);
if (VAR_5 == 0)
{
VAR_8 = fd_read_line (VAR_0);
xfree (VAR_8);
break;
}
}
VAR_1 = MIN (VAR_5, VAR_3);
}
DEBUGP ((""Skipping %s bytes of body: ["", number_to_static_string (VAR_1)));
VAR_7 = fd_read (VAR_0, VAR_6, MIN (VAR_1, VAR_3), -1);
if (VAR_7 <= 0)
{
DEBUGP ((""] aborting (%s).\n"",
VAR_7 < 0 ? fd_errstr (VAR_0) : ""EOF received""));
return false;
}
VAR_1 -= VAR_7;
if (VAR_2)
{
VAR_5 -= VAR_7;
if (VAR_5 == 0)
{
char *VAR_8 = fd_read_line (VAR_0);
if (VAR_8 == NULL)
return false;
else
xfree (VAR_8);
}
}
DEBUGP ((""%.*s"", VAR_7, VAR_6));
}
DEBUGP ((""] done.\n""));
return true;
}",wget/d892291fb8ace4c3b734ea5125770989c215df3f/http.c/vul/before/0.json,"static bool
skip_short_body (int fd, wgint contlen, bool chunked)
{
  enum {
    SKIP_SIZE = 512,                /* size of the download buffer */
    SKIP_THRESHOLD = 4096        /* the largest size we read */
  };
  wgint remaining_chunk_size = 0;
  char dlbuf[SKIP_SIZE + 1];
  dlbuf[SKIP_SIZE] = '\0';        /* so DEBUGP can safely print it */

  /* If the body is too large, it makes more sense to simply close the
     connection than to try to read the body.  */
  if (contlen > SKIP_THRESHOLD)
    return false;

  while (contlen > 0 || chunked)
    {
      int ret;
      if (chunked)
        {
          if (remaining_chunk_size == 0)
            {
              char *line = fd_read_line (fd);
              char *endl;
              if (line == NULL)
                break;

              remaining_chunk_size = strtol (line, &endl, 16);
              xfree (line);

              if (remaining_chunk_size < 0)
                return false;

              if (remaining_chunk_size == 0)
                {
                  line = fd_read_line (fd);
                  xfree (line);
                  break;
                }
            }

          contlen = MIN (remaining_chunk_size, SKIP_SIZE);
        }

      DEBUGP ((""Skipping %s bytes of body: ["", number_to_static_string (contlen)));

      ret = fd_read (fd, dlbuf, MIN (contlen, SKIP_SIZE), -1);
      if (ret <= 0)
        {
          /* Don't normally report the error since this is an
             optimization that should be invisible to the user.  */
          DEBUGP ((""] aborting (%s).\n"",
                   ret < 0 ? fd_errstr (fd) : ""EOF received""));
          return false;
        }
      contlen -= ret;

      if (chunked)
        {
          remaining_chunk_size -= ret;
          if (remaining_chunk_size == 0)
            {
              char *line = fd_read_line (fd);
              if (line == NULL)
                return false;
              else
                xfree (line);
            }
        }

      /* Safe even if %.*s bogusly expects terminating \0 because
         we've zero-terminated dlbuf above.  */
      DEBUGP ((""%.*s"", ret, dlbuf));
    }

  DEBUGP ((""] done.\n""));
  return true;
}","static bool
skip_short_body (int VAR_0, wgint VAR_1, bool VAR_2)
{
  enum {
    VAR_3 = 512,                /* COMMENT_0 */
    VAR_4 = 4096        /* COMMENT_1 */
  };
  wgint VAR_5 = 0;
  char VAR_6[VAR_3 + 1];
  VAR_6[VAR_3] = '\0';        /* COMMENT_2 */

  /* COMMENT_3 */
                                                 
  if (VAR_1 > VAR_4)
    return false;

  while (VAR_1 > 0 || VAR_2)
    {
      int VAR_7;
      if (VAR_2)
        {
          if (VAR_5 == 0)
            {
              char *VAR_8 = fd_read_line (VAR_0);
              char *VAR_9;
              if (VAR_8 == NULL)
                break;

              VAR_5 = strtol (VAR_8, &VAR_9, 16);
              xfree (VAR_8);

              if (VAR_5 < 0)
                return false;

              if (VAR_5 == 0)
                {
                  VAR_8 = fd_read_line (VAR_0);
                  xfree (VAR_8);
                  break;
                }
            }

          VAR_1 = MIN (VAR_5, VAR_3);
        }

      DEBUGP ((""Skipping %s bytes of body: ["", number_to_static_string (VAR_1)));

      VAR_7 = fd_read (VAR_0, VAR_6, MIN (VAR_1, VAR_3), -1);
      if (VAR_7 <= 0)
        {
          /* COMMENT_5 */
                                                                   
          DEBUGP ((""] aborting (%s).\n"",
                   VAR_7 < 0 ? fd_errstr (VAR_0) : ""EOF received""));
          return false;
        }
      VAR_1 -= VAR_7;

      if (VAR_2)
        {
          VAR_5 -= VAR_7;
          if (VAR_5 == 0)
            {
              char *VAR_8 = fd_read_line (VAR_0);
              if (VAR_8 == NULL)
                return false;
              else
                xfree (VAR_8);
            }
        }

      /* COMMENT_7 */
                                               
      DEBUGP ((""%.*s"", VAR_7, VAR_6));
    }

  DEBUGP ((""] done.\n""));
  return true;
}",wget/d892291fb8ace4c3b734ea5125770989c215df3f/http.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -28,6 +28,9 @@
 
               remaining_chunk_size = strtol (line, &endl, 16);
               xfree (line);
+
+              if (remaining_chunk_size < 0)
+                return false;
 
               if (remaining_chunk_size == 0)
                 {","{'deleted_lines': [], 'added_lines': ['', '              if (remaining_chunk_size < 0)', '                return false;']}",True,"The http.c:skip_short_body() function is called in some circumstances, such as when processing redirects. When the response is sent chunked in wget before 1.19.2, the chunk parser uses strtol() to read each chunk's length, but doesn't check that the chunk length is a non-negative number. The code then tries to skip the chunk in pieces of 512 bytes by using the MIN() macro, but ends up passing the negative chunk length to connect.c:fd_read(). As fd_read() takes an int argument, the high 32 bits of the chunk length are discarded, leaving fd_read() with a completely attacker controlled length argument.",8.8,HIGH,2,test,,5
CVE-2017-13090,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,wget,"* src/retr.c (fd_read_body): Stop processing on negative chunk size

Reported-by: Antti Levomki, Christian Jalio, Joonas Pihlaja from Forcepoint
Reported-by: Juhani Eronen from Finnish National Cyber Security Centre
",ba6b44f6745b14dce414761a8e4b35d31b176bba,http://git.savannah.gnu.org/cgit/wget.git/commit/?id=ba6b44f6745b14dce414761a8e4b35d31b176bba,src/retr.c,fd_read_body,"int
fd_read_body (const char *downloaded_filename, int fd, FILE *out, wgint toread, wgint startpos,
wgint *qtyread, wgint *qtywritten, double *elapsed, int flags,
FILE *out2)
{
int ret = 0;
#undef max
#define max(a,b) ((a) > (b) ? (a) : (b))
int dlbufsize = max (BUFSIZ, 8 * 1024);
char *dlbuf = xmalloc (dlbufsize);
struct ptimer *timer = NULL;
double last_successful_read_tm = 0;
void *progress = NULL;
bool progress_interactive = false;
bool exact = !!(flags & rb_read_exactly);
bool chunked = flags & rb_chunked_transfer_encoding;
wgint skip = 0;
wgint sum_read = 0;
wgint sum_written = 0;
wgint remaining_chunk_size = 0;
#ifdef HAVE_LIBZ
unsigned int gzbufsize = dlbufsize * 4;
char *gzbuf = NULL;
z_stream gzstream;
if (flags & rb_compressed_gzip)
{
gzbuf = xmalloc (gzbufsize);
if (gzbuf != NULL)
{
gzstream.zalloc = zalloc;
gzstream.zfree = zfree;
gzstream.opaque = Z_NULL;
gzstream.next_in = Z_NULL;
gzstream.avail_in = 0;
#define GZIP_DETECT 32 
#define GZIP_WINDOW 15 
ret = inflateInit2 (&gzstream, GZIP_DETECT | GZIP_WINDOW);
if (ret != Z_OK)
{
xfree (gzbuf);
errno = (ret == Z_MEM_ERROR) ? ENOMEM : EINVAL;
ret = -1;
goto out;
}
}
else
{
errno = ENOMEM;
ret = -1;
goto out;
}
}
#endif
if (flags & rb_skip_startpos)
skip = startpos;
if (opt.show_progress)
{
const char *filename_progress;
wgint start = skip ? 0 : startpos;
if (opt.dir_prefix)
filename_progress = downloaded_filename + strlen (opt.dir_prefix) + 1;
else
filename_progress = downloaded_filename;
progress = progress_create (filename_progress, start, start + toread);
progress_interactive = progress_interactive_p (progress);
}
if (opt.limit_rate)
limit_bandwidth_reset ();
if (progress || opt.limit_rate || elapsed)
{
timer = ptimer_new ();
last_successful_read_tm = 0;
}
if (opt.limit_rate && opt.limit_rate < dlbufsize)
dlbufsize = opt.limit_rate;
while (!exact || (sum_read < toread))
{
int rdsize;
double tmout = opt.read_timeout;
if (chunked)
{
if (remaining_chunk_size == 0)
{
char *line = fd_read_line (fd);
char *endl;
if (line == NULL)
{
ret = -1;
break;
}
else if (out2 != NULL)
fwrite (line, 1, strlen (line), out2);
remaining_chunk_size = strtol (line, &endl, 16);
xfree (line);
if (remaining_chunk_size == 0)
{
ret = 0;
line = fd_read_line (fd);
if (line == NULL)
ret = -1;
else
{
if (out2 != NULL)
fwrite (line, 1, strlen (line), out2);
xfree (line);
}
break;
}
}
rdsize = MIN (remaining_chunk_size, dlbufsize);
}
else
rdsize = exact ? MIN (toread - sum_read, dlbufsize) : dlbufsize;
if (progress_interactive)
{
tmout = 0.95;
if (opt.read_timeout)
{
double waittm;
waittm = ptimer_read (timer) - last_successful_read_tm;
if (waittm + tmout > opt.read_timeout)
{
tmout = opt.read_timeout - waittm;
if (tmout < 0)
{
ret = -1, errno = ETIMEDOUT;
break;
}
}
}
}
ret = fd_read (fd, dlbuf, rdsize, tmout);
if (progress_interactive && ret < 0 && errno == ETIMEDOUT)
ret = 0;                
else if (ret <= 0)
break;                  
if (progress || opt.limit_rate || elapsed)
{
ptimer_measure (timer);
if (ret > 0)
last_successful_read_tm = ptimer_read (timer);
}
if (ret > 0)
{
int write_res;
sum_read += ret;
#ifdef HAVE_LIBZ
if (gzbuf != NULL)
{
int err;
int towrite;
gzstream.avail_in = ret;
gzstream.next_in = (unsigned char *) dlbuf;
do
{
gzstream.avail_out = gzbufsize;
gzstream.next_out = (unsigned char *) gzbuf;
err = inflate (&gzstream, Z_NO_FLUSH);
switch (err)
{
case Z_MEM_ERROR:
errno = ENOMEM;
ret = -1;
goto out;
case Z_NEED_DICT:
case Z_DATA_ERROR:
errno = EINVAL;
ret = -1;
goto out;
case Z_STREAM_END:
if (exact && sum_read != toread)
{
DEBUGP((""zlib stream ended unexpectedly after ""
""%ld/%ld bytes\n"", sum_read, toread));
}
}
towrite = gzbufsize - gzstream.avail_out;
write_res = write_data (out, out2, gzbuf, towrite, &skip,
&sum_written);
if (write_res < 0)
{
ret = (write_res == -3) ? -3 : -2;
goto out;
}
}
while (gzstream.avail_out == 0);
}
else
#endif
{
write_res = write_data (out, out2, dlbuf, ret, &skip,
&sum_written);
if (write_res < 0)
{
ret = (write_res == -3) ? -3 : -2;
goto out;
}
}
if (chunked)
{
remaining_chunk_size -= ret;
if (remaining_chunk_size == 0)
{
char *line = fd_read_line (fd);
if (line == NULL)
{
ret = -1;
break;
}
else
{
if (out2 != NULL)
fwrite (line, 1, strlen (line), out2);
xfree (line);
}
}
}
}
if (opt.limit_rate)
limit_bandwidth (ret, timer);
if (progress)
progress_update (progress, ret, ptimer_read (timer));
#ifdef WINDOWS
if (toread > 0 && opt.show_progress)
ws_percenttitle (100.0 *
(startpos + sum_read) / (startpos + toread));
#endif
}
if (ret < -1)
ret = -1;
out:
if (progress)
progress_finish (progress, ptimer_read (timer));
if (elapsed)
*elapsed = ptimer_read (timer);
if (timer)
ptimer_destroy (timer);
#ifdef HAVE_LIBZ
if (gzbuf != NULL)
{
int err = inflateEnd (&gzstream);
if (ret >= 0)
{
if (err == Z_OK)
ret = 0;
else
{
errno = EINVAL;
ret = -1;
}
}
xfree (gzbuf);
if (gzstream.total_in != sum_read)
{
DEBUGP((""zlib read size differs from raw read size (%lu/%lu)\n"",
gzstream.total_in, sum_read));
}
}
#endif
if (qtyread)
*qtyread += sum_read;
if (qtywritten)
*qtywritten += sum_written;
xfree (dlbuf);
return ret;
}","int
fd_read_body (const char *VAR_0, int VAR_1, FILE *VAR_2, wgint VAR_3, wgint VAR_4,
wgint *VAR_5, wgint *VAR_6, double *VAR_7, int VAR_8,
FILE *VAR_9)
{
int VAR_10 = 0;
#undef max
#define max(VAR_11,VAR_12) ((a) > (b) ? (a) : (b))
int VAR_13 = max (VAR_14, 8 * 1024);
char *VAR_15 = xmalloc (VAR_13);
struct ptimer *VAR_16 = NULL;
double VAR_17 = 0;
void *VAR_18 = NULL;
bool VAR_19 = false;
bool VAR_20 = !!(VAR_8 & VAR_21);
bool VAR_22 = VAR_8 & VAR_23;
wgint VAR_24 = 0;
wgint VAR_25 = 0;
wgint VAR_26 = 0;
wgint VAR_27 = 0;
#ifdef VAR_28
unsigned int VAR_29 = VAR_13 * 4;
char *VAR_30 = NULL;
z_stream VAR_31;
if (VAR_8 & VAR_32)
{
VAR_30 = xmalloc (VAR_29);
if (VAR_30 != NULL)
{
VAR_31.zalloc = VAR_33;
VAR_31.zfree = VAR_34;
VAR_31.opaque = VAR_35;
VAR_31.next_in = VAR_35;
VAR_31.avail_in = 0;
#define VAR_36 32 
#define VAR_37 15 
VAR_10 = inflateInit2 (&VAR_31, VAR_36 | VAR_37);
if (VAR_10 != VAR_38)
{
xfree (VAR_30);
VAR_39 = (VAR_10 == VAR_40) ? VAR_41 : VAR_42;
VAR_10 = -1;
goto out;
}
}
else
{
VAR_39 = VAR_41;
VAR_10 = -1;
goto out;
}
}
#endif
if (VAR_8 & VAR_43)
VAR_24 = VAR_4;
if (VAR_44.show_progress)
{
const char *VAR_45;
wgint VAR_46 = VAR_24 ? 0 : VAR_4;
if (VAR_44.dir_prefix)
VAR_45 = VAR_0 + strlen (VAR_44.dir_prefix) + 1;
else
VAR_45 = VAR_0;
VAR_18 = progress_create (VAR_45, VAR_46, VAR_46 + VAR_3);
VAR_19 = progress_interactive_p (VAR_18);
}
if (VAR_44.limit_rate)
limit_bandwidth_reset ();
if (VAR_18 || VAR_44.limit_rate || VAR_7)
{
VAR_16 = ptimer_new ();
VAR_17 = 0;
}
if (VAR_44.limit_rate && VAR_44.limit_rate < VAR_13)
VAR_13 = VAR_44.limit_rate;
while (!VAR_20 || (VAR_25 < VAR_3))
{
int VAR_47;
double VAR_48 = VAR_44.read_timeout;
if (VAR_22)
{
if (VAR_27 == 0)
{
char *VAR_49 = fd_read_line (VAR_1);
char *VAR_50;
if (VAR_49 == NULL)
{
VAR_10 = -1;
break;
}
else if (VAR_9 != NULL)
fwrite (VAR_49, 1, strlen (VAR_49), VAR_9);
VAR_27 = strtol (VAR_49, &VAR_50, 16);
xfree (VAR_49);
if (VAR_27 == 0)
{
VAR_10 = 0;
VAR_49 = fd_read_line (VAR_1);
if (VAR_49 == NULL)
VAR_10 = -1;
else
{
if (VAR_9 != NULL)
fwrite (VAR_49, 1, strlen (VAR_49), VAR_9);
xfree (VAR_49);
}
break;
}
}
VAR_47 = MIN (VAR_27, VAR_13);
}
else
VAR_47 = VAR_20 ? MIN (VAR_3 - VAR_25, VAR_13) : VAR_13;
if (VAR_19)
{
VAR_48 = 0.95;
if (VAR_44.read_timeout)
{
double VAR_51;
VAR_51 = ptimer_read (VAR_16) - VAR_17;
if (VAR_51 + VAR_48 > VAR_44.read_timeout)
{
VAR_48 = VAR_44.read_timeout - VAR_51;
if (VAR_48 < 0)
{
VAR_10 = -1, VAR_39 = VAR_52;
break;
}
}
}
}
VAR_10 = fd_read (VAR_1, VAR_15, VAR_47, VAR_48);
if (VAR_19 && VAR_10 < 0 && VAR_39 == VAR_52)
VAR_10 = 0;                
else if (VAR_10 <= 0)
break;                  
if (VAR_18 || VAR_44.limit_rate || VAR_7)
{
ptimer_measure (VAR_16);
if (VAR_10 > 0)
VAR_17 = ptimer_read (VAR_16);
}
if (VAR_10 > 0)
{
int VAR_53;
VAR_25 += VAR_10;
#ifdef VAR_28
if (VAR_30 != NULL)
{
int VAR_54;
int VAR_55;
VAR_31.avail_in = VAR_10;
VAR_31.next_in = (unsigned char *) VAR_15;
do
{
VAR_31.avail_out = VAR_29;
VAR_31.next_out = (unsigned char *) VAR_30;
VAR_54 = inflate (&VAR_31, VAR_56);
switch (VAR_54)
{
case VAR_40:
VAR_39 = VAR_41;
VAR_10 = -1;
goto out;
case VAR_57:
case VAR_58:
VAR_39 = VAR_42;
VAR_10 = -1;
goto out;
case VAR_59:
if (VAR_20 && VAR_25 != VAR_3)
{
DEBUGP((""zlib stream ended unexpectedly after ""
""%ld/%ld bytes\n"", VAR_25, VAR_3));
}
}
VAR_55 = VAR_29 - VAR_31.avail_out;
VAR_53 = write_data (VAR_2, VAR_9, VAR_30, VAR_55, &VAR_24,
&VAR_26);
if (VAR_53 < 0)
{
VAR_10 = (VAR_53 == -3) ? -3 : -2;
goto out;
}
}
while (VAR_31.avail_out == 0);
}
else
#endif
{
VAR_53 = write_data (VAR_2, VAR_9, VAR_15, VAR_10, &VAR_24,
&VAR_26);
if (VAR_53 < 0)
{
VAR_10 = (VAR_53 == -3) ? -3 : -2;
goto out;
}
}
if (VAR_22)
{
VAR_27 -= VAR_10;
if (VAR_27 == 0)
{
char *VAR_49 = fd_read_line (VAR_1);
if (VAR_49 == NULL)
{
VAR_10 = -1;
break;
}
else
{
if (VAR_9 != NULL)
fwrite (VAR_49, 1, strlen (VAR_49), VAR_9);
xfree (VAR_49);
}
}
}
}
if (VAR_44.limit_rate)
limit_bandwidth (VAR_10, VAR_16);
if (VAR_18)
progress_update (VAR_18, VAR_10, ptimer_read (VAR_16));
#ifdef VAR_60
if (VAR_3 > 0 && VAR_44.show_progress)
ws_percenttitle (100.0 *
(VAR_4 + VAR_25) / (VAR_4 + VAR_3));
#endif
}
if (VAR_10 < -1)
VAR_10 = -1;
out:
if (VAR_18)
progress_finish (VAR_18, ptimer_read (VAR_16));
if (VAR_7)
*VAR_7 = ptimer_read (VAR_16);
if (VAR_16)
ptimer_destroy (VAR_16);
#ifdef VAR_28
if (VAR_30 != NULL)
{
int VAR_54 = inflateEnd (&VAR_31);
if (VAR_10 >= 0)
{
if (VAR_54 == VAR_38)
VAR_10 = 0;
else
{
VAR_39 = VAR_42;
VAR_10 = -1;
}
}
xfree (VAR_30);
if (VAR_31.total_in != VAR_25)
{
DEBUGP((""zlib read size differs from raw read size (%lu/%lu)\n"",
VAR_31.total_in, VAR_25));
}
}
#endif
if (VAR_5)
*VAR_5 += VAR_25;
if (VAR_6)
*VAR_6 += VAR_26;
xfree (VAR_15);
return VAR_10;
}",wget/ba6b44f6745b14dce414761a8e4b35d31b176bba/retr.c/vul/before/0.json,"int
fd_read_body (const char *downloaded_filename, int fd, FILE *out, wgint toread, wgint startpos,

              wgint *qtyread, wgint *qtywritten, double *elapsed, int flags,
              FILE *out2)
{
  int ret = 0;
#undef max
#define max(a,b) ((a) > (b) ? (a) : (b))
  int dlbufsize = max (BUFSIZ, 8 * 1024);
  char *dlbuf = xmalloc (dlbufsize);

  struct ptimer *timer = NULL;
  double last_successful_read_tm = 0;

  /* The progress gauge, set according to the user preferences. */
  void *progress = NULL;

  /* Non-zero if the progress gauge is interactive, i.e. if it can
     continually update the display.  When true, smaller timeout
     values are used so that the gauge can update the display when
     data arrives slowly. */
  bool progress_interactive = false;

  bool exact = !!(flags & rb_read_exactly);

  /* Used only by HTTP/HTTPS chunked transfer encoding.  */
  bool chunked = flags & rb_chunked_transfer_encoding;
  wgint skip = 0;

  /* How much data we've read/written.  */
  wgint sum_read = 0;
  wgint sum_written = 0;
  wgint remaining_chunk_size = 0;

#ifdef HAVE_LIBZ
  /* try to minimize the number of calls to inflate() and write_data() per
     call to fd_read() */
  unsigned int gzbufsize = dlbufsize * 4;
  char *gzbuf = NULL;
  z_stream gzstream;

  if (flags & rb_compressed_gzip)
    {
      gzbuf = xmalloc (gzbufsize);
      if (gzbuf != NULL)
        {
          gzstream.zalloc = zalloc;
          gzstream.zfree = zfree;
          gzstream.opaque = Z_NULL;
          gzstream.next_in = Z_NULL;
          gzstream.avail_in = 0;

          #define GZIP_DETECT 32 /* gzip format detection */
          #define GZIP_WINDOW 15 /* logarithmic window size (default: 15) */
          ret = inflateInit2 (&gzstream, GZIP_DETECT | GZIP_WINDOW);
          if (ret != Z_OK)
            {
              xfree (gzbuf);
              errno = (ret == Z_MEM_ERROR) ? ENOMEM : EINVAL;
              ret = -1;
              goto out;
            }
        }
      else
        {
          errno = ENOMEM;
          ret = -1;
          goto out;
        }
    }
#endif

  if (flags & rb_skip_startpos)
    skip = startpos;

  if (opt.show_progress)
    {
      const char *filename_progress;
      /* If we're skipping STARTPOS bytes, pass 0 as the INITIAL
         argument to progress_create because the indicator doesn't
         (yet) know about ""skipping"" data.  */
      wgint start = skip ? 0 : startpos;
      if (opt.dir_prefix)
        filename_progress = downloaded_filename + strlen (opt.dir_prefix) + 1;
      else
        filename_progress = downloaded_filename;
      progress = progress_create (filename_progress, start, start + toread);
      progress_interactive = progress_interactive_p (progress);
    }

  if (opt.limit_rate)
    limit_bandwidth_reset ();

  /* A timer is needed for tracking progress, for throttling, and for
     tracking elapsed time.  If either of these are requested, start
     the timer.  */
  if (progress || opt.limit_rate || elapsed)
    {
      timer = ptimer_new ();
      last_successful_read_tm = 0;
    }

  /* Use a smaller buffer for low requested bandwidths.  For example,
     with --limit-rate=2k, it doesn't make sense to slurp in 16K of
     data and then sleep for 8s.  With buffer size equal to the limit,
     we never have to sleep for more than one second.  */
  if (opt.limit_rate && opt.limit_rate < dlbufsize)
    dlbufsize = opt.limit_rate;

  /* Read from FD while there is data to read.  Normally toread==0
     means that it is unknown how much data is to arrive.  However, if
     EXACT is set, then toread==0 means what it says: that no data
     should be read.  */
  while (!exact || (sum_read < toread))
    {
      int rdsize;
      double tmout = opt.read_timeout;

      if (chunked)
        {
          if (remaining_chunk_size == 0)
            {
              char *line = fd_read_line (fd);
              char *endl;
              if (line == NULL)
                {
                  ret = -1;
                  break;
                }
              else if (out2 != NULL)
                fwrite (line, 1, strlen (line), out2);

              remaining_chunk_size = strtol (line, &endl, 16);
              xfree (line);

              if (remaining_chunk_size < 0)
                {
                  ret = -1;
                  break;
                }

              if (remaining_chunk_size == 0)
                {
                  ret = 0;
                  line = fd_read_line (fd);
                  if (line == NULL)
                    ret = -1;
                  else
                    {
                      if (out2 != NULL)
                        fwrite (line, 1, strlen (line), out2);
                      xfree (line);
                    }
                  break;
                }
            }

          rdsize = MIN (remaining_chunk_size, dlbufsize);
        }
      else
        rdsize = exact ? MIN (toread - sum_read, dlbufsize) : dlbufsize;

      if (progress_interactive)
        {
          /* For interactive progress gauges, always specify a ~1s
             timeout, so that the gauge can be updated regularly even
             when the data arrives very slowly or stalls.  */
          tmout = 0.95;
          if (opt.read_timeout)
            {
              double waittm;
              waittm = ptimer_read (timer) - last_successful_read_tm;
              if (waittm + tmout > opt.read_timeout)
                {
                  /* Don't let total idle time exceed read timeout. */
                  tmout = opt.read_timeout - waittm;
                  if (tmout < 0)
                    {
                      /* We've already exceeded the timeout. */
                      ret = -1, errno = ETIMEDOUT;
                      break;
                    }
                }
            }
        }
      ret = fd_read (fd, dlbuf, rdsize, tmout);

      if (progress_interactive && ret < 0 && errno == ETIMEDOUT)
        ret = 0;                /* interactive timeout, handled above */
      else if (ret <= 0)
        break;                  /* EOF or read error */

      if (progress || opt.limit_rate || elapsed)
        {
          ptimer_measure (timer);
          if (ret > 0)
            last_successful_read_tm = ptimer_read (timer);
        }

      if (ret > 0)
        {
          int write_res;

          sum_read += ret;

#ifdef HAVE_LIBZ
          if (gzbuf != NULL)
            {
              int err;
              int towrite;
              gzstream.avail_in = ret;
              gzstream.next_in = (unsigned char *) dlbuf;

              do
                {
                  gzstream.avail_out = gzbufsize;
                  gzstream.next_out = (unsigned char *) gzbuf;

                  err = inflate (&gzstream, Z_NO_FLUSH);

                  switch (err)
                    {
                    case Z_MEM_ERROR:
                      errno = ENOMEM;
                      ret = -1;
                      goto out;
                    case Z_NEED_DICT:
                    case Z_DATA_ERROR:
                      errno = EINVAL;
                      ret = -1;
                      goto out;
                    case Z_STREAM_END:
                      if (exact && sum_read != toread)
                        {
                          DEBUGP((""zlib stream ended unexpectedly after ""
                                  ""%ld/%ld bytes\n"", sum_read, toread));
                        }
                    }

                  towrite = gzbufsize - gzstream.avail_out;
                  write_res = write_data (out, out2, gzbuf, towrite, &skip,
                                          &sum_written);
                  if (write_res < 0)
                    {
                      ret = (write_res == -3) ? -3 : -2;
                      goto out;
                    }
                }
              while (gzstream.avail_out == 0);
            }
          else
#endif
            {
              write_res = write_data (out, out2, dlbuf, ret, &skip,
                                      &sum_written);
              if (write_res < 0)
                {
                  ret = (write_res == -3) ? -3 : -2;
                  goto out;
                }
            }

          if (chunked)
            {
              remaining_chunk_size -= ret;
              if (remaining_chunk_size == 0)
                {
                  char *line = fd_read_line (fd);
                  if (line == NULL)
                    {
                      ret = -1;
                      break;
                    }
                  else
                    {
                      if (out2 != NULL)
                        fwrite (line, 1, strlen (line), out2);
                      xfree (line);
                    }
                }
            }
        }

      if (opt.limit_rate)
        limit_bandwidth (ret, timer);

      if (progress)
        progress_update (progress, ret, ptimer_read (timer));
#ifdef WINDOWS
      if (toread > 0 && opt.show_progress)
        ws_percenttitle (100.0 *
                         (startpos + sum_read) / (startpos + toread));
#endif
    }
  if (ret < -1)
    ret = -1;

 out:
  if (progress)
    progress_finish (progress, ptimer_read (timer));

  if (elapsed)
    *elapsed = ptimer_read (timer);
  if (timer)
    ptimer_destroy (timer);

#ifdef HAVE_LIBZ
  if (gzbuf != NULL)
    {
      int err = inflateEnd (&gzstream);
      if (ret >= 0)
        {
          /* with compression enabled, ret must be 0 if successful */
          if (err == Z_OK)
            ret = 0;
          else
            {
              errno = EINVAL;
              ret = -1;
            }
        }
      xfree (gzbuf);

      if (gzstream.total_in != sum_read)
        {
          DEBUGP((""zlib read size differs from raw read size (%lu/%lu)\n"",
                  gzstream.total_in, sum_read));
        }
    }
#endif

  if (qtyread)
    *qtyread += sum_read;
  if (qtywritten)
    *qtywritten += sum_written;

  xfree (dlbuf);

  return ret;
}","int
fd_read_body (const char *VAR_0, int VAR_1, FILE *VAR_2, wgint VAR_3, wgint VAR_4,

              wgint *VAR_5, wgint *VAR_6, double *VAR_7, int VAR_8,
              FILE *VAR_9)
{
  int VAR_10 = 0;
#undef max
#define max(VAR_11,VAR_12) ((a) > (b) ? (a) : (b))
  int VAR_13 = max (VAR_14, 8 * 1024);
  char *VAR_15 = xmalloc (VAR_13);

  struct ptimer *VAR_16 = NULL;
  double VAR_17 = 0;

  /* COMMENT_0 */
  void *VAR_18 = NULL;

  /* COMMENT_1 */
                                                                
                                                                  
                            
  bool VAR_19 = false;

  bool VAR_20 = !!(VAR_8 & VAR_21);

  /* COMMENT_5 */
  bool VAR_22 = VAR_8 & VAR_23;
  wgint VAR_24 = 0;

  /* COMMENT_6 */
  wgint VAR_25 = 0;
  wgint VAR_26 = 0;
  wgint VAR_27 = 0;

#ifdef VAR_28
  /* COMMENT_7 */
                         
  unsigned int VAR_29 = VAR_13 * 4;
  char *VAR_30 = NULL;
  z_stream VAR_31;

  if (VAR_8 & VAR_32)
    {
      VAR_30 = xmalloc (VAR_29);
      if (VAR_30 != NULL)
        {
          VAR_31.zalloc = VAR_33;
          VAR_31.zfree = VAR_34;
          VAR_31.opaque = VAR_35;
          VAR_31.next_in = VAR_35;
          VAR_31.avail_in = 0;

          #define VAR_36 32 /* gzip format detection */
          #define VAR_37 15 /* logarithmic window size (default: 15) */
          VAR_10 = inflateInit2 (&VAR_31, VAR_36 | VAR_37);
          if (VAR_10 != VAR_38)
            {
              xfree (VAR_30);
              VAR_39 = (VAR_10 == VAR_40) ? VAR_41 : VAR_42;
              VAR_10 = -1;
              goto out;
            }
        }
      else
        {
          VAR_39 = VAR_41;
          VAR_10 = -1;
          goto out;
        }
    }
#endif

  if (VAR_8 & VAR_43)
    VAR_24 = VAR_4;

  if (VAR_44.show_progress)
    {
      const char *VAR_45;
      /* COMMENT_9 */
                                                                  
                                              
      wgint VAR_46 = VAR_24 ? 0 : VAR_4;
      if (VAR_44.dir_prefix)
        VAR_45 = VAR_0 + strlen (VAR_44.dir_prefix) + 1;
      else
        VAR_45 = VAR_0;
      VAR_18 = progress_create (VAR_45, VAR_46, VAR_46 + VAR_3);
      VAR_19 = progress_interactive_p (VAR_18);
    }

  if (VAR_44.limit_rate)
    limit_bandwidth_reset ();

  /* COMMENT_12 */
                                                                    
                   
  if (VAR_18 || VAR_44.limit_rate || VAR_7)
    {
      VAR_16 = ptimer_new ();
      VAR_17 = 0;
    }

  /* COMMENT_15 */
                                                                   
                                                                      
                                                         
  if (VAR_44.limit_rate && VAR_44.limit_rate < VAR_13)
    VAR_13 = VAR_44.limit_rate;

  /* COMMENT_19 */
                                                                      
                                                                  
                        
  while (!VAR_20 || (VAR_25 < VAR_3))
    {
      int VAR_47;
      double VAR_48 = VAR_44.read_timeout;

      if (VAR_22)
        {
          if (VAR_27 == 0)
            {
              char *VAR_49 = fd_read_line (VAR_1);
              char *VAR_50;
              if (VAR_49 == NULL)
                {
                  VAR_10 = -1;
                  break;
                }
              else if (VAR_9 != NULL)
                fwrite (VAR_49, 1, strlen (VAR_49), VAR_9);

              VAR_27 = strtol (VAR_49, &VAR_50, 16);
              xfree (VAR_49);

              if (VAR_27 < 0)
                {
                  VAR_10 = -1;
                  break;
                }

              if (VAR_27 == 0)
                {
                  VAR_10 = 0;
                  VAR_49 = fd_read_line (VAR_1);
                  if (VAR_49 == NULL)
                    VAR_10 = -1;
                  else
                    {
                      if (VAR_9 != NULL)
                        fwrite (VAR_49, 1, strlen (VAR_49), VAR_9);
                      xfree (VAR_49);
                    }
                  break;
                }
            }

          VAR_47 = MIN (VAR_27, VAR_13);
        }
      else
        VAR_47 = VAR_20 ? MIN (VAR_3 - VAR_25, VAR_13) : VAR_13;

      if (VAR_19)
        {
          /* COMMENT_23 */
                                                                     
                                                             
          VAR_48 = 0.95;
          if (VAR_44.read_timeout)
            {
              double VAR_51;
              VAR_51 = ptimer_read (VAR_16) - VAR_17;
              if (VAR_51 + VAR_48 > VAR_44.read_timeout)
                {
                  /* COMMENT_26 */
                  VAR_48 = VAR_44.read_timeout - VAR_51;
                  if (VAR_48 < 0)
                    {
                      /* COMMENT_27 */
                      VAR_10 = -1, VAR_39 = VAR_52;
                      break;
                    }
                }
            }
        }
      VAR_10 = fd_read (VAR_1, VAR_15, VAR_47, VAR_48);

      if (VAR_19 && VAR_10 < 0 && VAR_39 == VAR_52)
        VAR_10 = 0;                /* COMMENT_28 */
      else if (VAR_10 <= 0)
        break;                  /* COMMENT_29 */

      if (VAR_18 || VAR_44.limit_rate || VAR_7)
        {
          ptimer_measure (VAR_16);
          if (VAR_10 > 0)
            VAR_17 = ptimer_read (VAR_16);
        }

      if (VAR_10 > 0)
        {
          int VAR_53;

          VAR_25 += VAR_10;

#ifdef VAR_28
          if (VAR_30 != NULL)
            {
              int VAR_54;
              int VAR_55;
              VAR_31.avail_in = VAR_10;
              VAR_31.next_in = (unsigned char *) VAR_15;

              do
                {
                  VAR_31.avail_out = VAR_29;
                  VAR_31.next_out = (unsigned char *) VAR_30;

                  VAR_54 = inflate (&VAR_31, VAR_56);

                  switch (VAR_54)
                    {
                    case VAR_40:
                      VAR_39 = VAR_41;
                      VAR_10 = -1;
                      goto out;
                    case VAR_57:
                    case VAR_58:
                      VAR_39 = VAR_42;
                      VAR_10 = -1;
                      goto out;
                    case VAR_59:
                      if (VAR_20 && VAR_25 != VAR_3)
                        {
                          DEBUGP((""zlib stream ended unexpectedly after ""
                                  ""%ld/%ld bytes\n"", VAR_25, VAR_3));
                        }
                    }

                  VAR_55 = VAR_29 - VAR_31.avail_out;
                  VAR_53 = write_data (VAR_2, VAR_9, VAR_30, VAR_55, &VAR_24,
                                          &VAR_26);
                  if (VAR_53 < 0)
                    {
                      VAR_10 = (VAR_53 == -3) ? -3 : -2;
                      goto out;
                    }
                }
              while (VAR_31.avail_out == 0);
            }
          else
#endif
            {
              VAR_53 = write_data (VAR_2, VAR_9, VAR_15, VAR_10, &VAR_24,
                                      &VAR_26);
              if (VAR_53 < 0)
                {
                  VAR_10 = (VAR_53 == -3) ? -3 : -2;
                  goto out;
                }
            }

          if (VAR_22)
            {
              VAR_27 -= VAR_10;
              if (VAR_27 == 0)
                {
                  char *VAR_49 = fd_read_line (VAR_1);
                  if (VAR_49 == NULL)
                    {
                      VAR_10 = -1;
                      break;
                    }
                  else
                    {
                      if (VAR_9 != NULL)
                        fwrite (VAR_49, 1, strlen (VAR_49), VAR_9);
                      xfree (VAR_49);
                    }
                }
            }
        }

      if (VAR_44.limit_rate)
        limit_bandwidth (VAR_10, VAR_16);

      if (VAR_18)
        progress_update (VAR_18, VAR_10, ptimer_read (VAR_16));
#ifdef VAR_60
      if (VAR_3 > 0 && VAR_44.show_progress)
        ws_percenttitle (100.0 *
                         (VAR_4 + VAR_25) / (VAR_4 + VAR_3));
#endif
    }
  if (VAR_10 < -1)
    VAR_10 = -1;

 out:
  if (VAR_18)
    progress_finish (VAR_18, ptimer_read (VAR_16));

  if (VAR_7)
    *VAR_7 = ptimer_read (VAR_16);
  if (VAR_16)
    ptimer_destroy (VAR_16);

#ifdef VAR_28
  if (VAR_30 != NULL)
    {
      int VAR_54 = inflateEnd (&VAR_31);
      if (VAR_10 >= 0)
        {
          /* COMMENT_30 */
          if (VAR_54 == VAR_38)
            VAR_10 = 0;
          else
            {
              VAR_39 = VAR_42;
              VAR_10 = -1;
            }
        }
      xfree (VAR_30);

      if (VAR_31.total_in != VAR_25)
        {
          DEBUGP((""zlib read size differs from raw read size (%lu/%lu)\n"",
                  VAR_31.total_in, VAR_25));
        }
    }
#endif

  if (VAR_5)
    *VAR_5 += VAR_25;
  if (VAR_6)
    *VAR_6 += VAR_26;

  xfree (VAR_15);

  return VAR_10;
}",wget/ba6b44f6745b14dce414761a8e4b35d31b176bba/retr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -133,6 +133,12 @@
 
               remaining_chunk_size = strtol (line, &endl, 16);
               xfree (line);
+
+              if (remaining_chunk_size < 0)
+                {
+                  ret = -1;
+                  break;
+                }
 
               if (remaining_chunk_size == 0)
                 {","{'deleted_lines': [], 'added_lines': ['', '              if (remaining_chunk_size < 0)', '                {', '                  ret = -1;', '                  break;', '                }']}",True,"The retr.c:fd_read_body() function is called when processing OK responses. When the response is sent chunked in wget before 1.19.2, the chunk parser uses strtol() to read each chunk's length, but doesn't check that the chunk length is a non-negative number. The code then tries to read the chunk in pieces of 8192 bytes by using the MIN() macro, but ends up passing the negative chunk length to retr.c:fd_read(). As fd_read() takes an int argument, the high 32 bits of the chunk length are discarded, leaving fd_read() with a completely attacker controlled length argument. The attacker can corrupt malloc metadata after the allocated buffer.",8.8,HIGH,2,test,,5
CVE-2017-12133,['CWE-416'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,glibc,"
sunrpc: Avoid use-after-free read access in clntudp_call [BZ #21115]

After commit bc779a1a5b3035133024b21e2f339fe4219fb11c
(CVE-2016-4429: sunrpc: Do not use alloca in clntudp_call
[BZ #20112]), ancillary data is stored on the heap,
but it is accessed after it has been freed.

The test case must be run under a heap debugger such as valgrind
to observe the invalid access.  A malloc implementation which
immediately calls munmap on free would catch this bug as well.
",d42eed4a044e5e10dfb885cf9891c2518a72a491,https://sourceware.org/git/gitweb.cgi?p=glibc.git;h=d42eed4a044e5e10dfb885cf9891c2518a72a491,sunrpc/clnt_udp.c,clntudp_call,"static enum clnt_stat
clntudp_call (
CLIENT *cl,
u_long proc,
xdrproc_t xargs,
caddr_t argsp,
xdrproc_t xresults,
caddr_t resultsp,
struct timeval utimeout)
{
struct cu_data *cu = (struct cu_data *) cl->cl_private;
XDR *xdrs;
int outlen = 0;
int inlen;
socklen_t fromlen;
struct pollfd fd;
int milliseconds = (cu->cu_wait.tv_sec * 1000) +
(cu->cu_wait.tv_usec / 1000);
struct sockaddr_in from;
struct rpc_msg reply_msg;
XDR reply_xdrs;
struct timeval time_waited;
bool_t ok;
int nrefreshes = 2;
struct timeval timeout;
int anyup;
if (cu->cu_total.tv_usec == -1)
{
timeout = utimeout;
}
else
{
timeout = cu->cu_total;
}
time_waited.tv_sec = 0;
time_waited.tv_usec = 0;
call_again:
xdrs = &(cu->cu_outxdrs);
if (xargs == NULL)
goto get_reply;
xdrs->x_op = XDR_ENCODE;
XDR_SETPOS (xdrs, cu->cu_xdrpos);
(*(uint32_t *) (cu->cu_outbuf))++;
if ((!XDR_PUTLONG (xdrs, (long *) &proc)) ||
(!AUTH_MARSHALL (cl->cl_auth, xdrs)) ||
(!(*xargs) (xdrs, argsp)))
return (cu->cu_error.re_status = RPC_CANTENCODEARGS);
outlen = (int) XDR_GETPOS (xdrs);
send_again:
if (__sendto (cu->cu_sock, cu->cu_outbuf, outlen, 0,
(struct sockaddr *) &(cu->cu_raddr), cu->cu_rlen)
!= outlen)
{
cu->cu_error.re_errno = errno;
return (cu->cu_error.re_status = RPC_CANTSEND);
}
if (timeout.tv_sec == 0 && timeout.tv_usec == 0)
{
return (cu->cu_error.re_status = RPC_TIMEDOUT);
}
get_reply:
reply_msg.acpted_rply.ar_verf = _null_auth;
reply_msg.acpted_rply.ar_results.where = resultsp;
reply_msg.acpted_rply.ar_results.proc = xresults;
fd.fd = cu->cu_sock;
fd.events = POLLIN;
anyup = 0;
for (;;)
{
switch (__poll (&fd, 1, milliseconds))
{
case 0:
if (anyup == 0)
{
anyup = is_network_up (cu->cu_sock);
if (!anyup)
return (cu->cu_error.re_status = RPC_CANTRECV);
}
time_waited.tv_sec += cu->cu_wait.tv_sec;
time_waited.tv_usec += cu->cu_wait.tv_usec;
while (time_waited.tv_usec >= 1000000)
{
time_waited.tv_sec++;
time_waited.tv_usec -= 1000000;
}
if ((time_waited.tv_sec < timeout.tv_sec) ||
((time_waited.tv_sec == timeout.tv_sec) &&
(time_waited.tv_usec < timeout.tv_usec)))
goto send_again;
return (cu->cu_error.re_status = RPC_TIMEDOUT);
case -1:
if (errno == EINTR)
continue;
cu->cu_error.re_errno = errno;
return (cu->cu_error.re_status = RPC_CANTRECV);
}
#ifdef IP_RECVERR
if (fd.revents & POLLERR)
{
struct msghdr msg;
struct cmsghdr *cmsg;
struct sock_extended_err *e;
struct sockaddr_in err_addr;
struct iovec iov;
char *cbuf = malloc (outlen + 256);
int ret;
if (cbuf == NULL)
{
cu->cu_error.re_errno = errno;
return (cu->cu_error.re_status = RPC_CANTRECV);
}
iov.iov_base = cbuf + 256;
iov.iov_len = outlen;
msg.msg_name = (void *) &err_addr;
msg.msg_namelen = sizeof (err_addr);
msg.msg_iov = &iov;
msg.msg_iovlen = 1;
msg.msg_flags = 0;
msg.msg_control = cbuf;
msg.msg_controllen = 256;
ret = __recvmsg (cu->cu_sock, &msg, MSG_ERRQUEUE);
if (ret >= 0
&& memcmp (cbuf + 256, cu->cu_outbuf, ret) == 0
&& (msg.msg_flags & MSG_ERRQUEUE)
&& ((msg.msg_namelen == 0
&& ret >= 12)
|| (msg.msg_namelen == sizeof (err_addr)
&& err_addr.sin_family == AF_INET
&& memcmp (&err_addr.sin_addr, &cu->cu_raddr.sin_addr,
sizeof (err_addr.sin_addr)) == 0
&& err_addr.sin_port == cu->cu_raddr.sin_port)))
for (cmsg = CMSG_FIRSTHDR (&msg); cmsg;
cmsg = CMSG_NXTHDR (&msg, cmsg))
if (cmsg->cmsg_level == SOL_IP && cmsg->cmsg_type == IP_RECVERR)
{
free (cbuf);
e = (struct sock_extended_err *) CMSG_DATA(cmsg);
cu->cu_error.re_errno = e->ee_errno;
return (cu->cu_error.re_status = RPC_CANTRECV);
}
free (cbuf);
}
#endif
do
{
fromlen = sizeof (struct sockaddr);
inlen = __recvfrom (cu->cu_sock, cu->cu_inbuf,
(int) cu->cu_recvsz, MSG_DONTWAIT,
(struct sockaddr *) &from, &fromlen);
}
while (inlen < 0 && errno == EINTR);
if (inlen < 0)
{
if (errno == EWOULDBLOCK)
continue;
cu->cu_error.re_errno = errno;
return (cu->cu_error.re_status = RPC_CANTRECV);
}
if (inlen < 4)
continue;
if (xargs != NULL
&& memcmp (cu->cu_inbuf, cu->cu_outbuf, sizeof (u_int32_t)) != 0)
continue;
break;
}
xdrmem_create (&reply_xdrs, cu->cu_inbuf, (u_int) inlen, XDR_DECODE);
ok = xdr_replymsg (&reply_xdrs, &reply_msg);
if (ok)
{
_seterr_reply (&reply_msg, &(cu->cu_error));
if (cu->cu_error.re_status == RPC_SUCCESS)
{
if (!AUTH_VALIDATE (cl->cl_auth,
&reply_msg.acpted_rply.ar_verf))
{
cu->cu_error.re_status = RPC_AUTHERROR;
cu->cu_error.re_why = AUTH_INVALIDRESP;
}
if (reply_msg.acpted_rply.ar_verf.oa_base != NULL)
{
xdrs->x_op = XDR_FREE;
(void) xdr_opaque_auth (xdrs, &(reply_msg.acpted_rply.ar_verf));
}
}
else
{
if (nrefreshes > 0 && AUTH_REFRESH (cl->cl_auth))
{
nrefreshes--;
goto call_again;
}
}
}
else
{
cu->cu_error.re_status = RPC_CANTDECODERES;
}
return cu->cu_error.re_status;
}","static enum clnt_stat
clntudp_call (
CLIENT *VAR_0,
u_long VAR_1,
xdrproc_t VAR_2,
caddr_t VAR_3,
xdrproc_t VAR_4,
caddr_t VAR_5,
struct timeval VAR_6)
{
struct cu_data *VAR_7 = (struct cu_data *) VAR_0->cl_private;
XDR *VAR_8;
int VAR_9 = 0;
int VAR_10;
socklen_t VAR_11;
struct pollfd VAR_12;
int VAR_13 = (VAR_7->cu_wait.tv_sec * 1000) +
(VAR_7->cu_wait.tv_usec / 1000);
struct sockaddr_in VAR_14;
struct rpc_msg VAR_15;
XDR VAR_16;
struct timeval VAR_17;
bool_t VAR_18;
int VAR_19 = 2;
struct timeval VAR_20;
int VAR_21;
if (VAR_7->cu_total.tv_usec == -1)
{
VAR_20 = VAR_6;
}
else
{
VAR_20 = VAR_7->cu_total;
}
VAR_17.tv_sec = 0;
VAR_17.tv_usec = 0;
call_again:
VAR_8 = &(VAR_7->cu_outxdrs);
if (VAR_2 == NULL)
goto get_reply;
VAR_8->x_op = VAR_22;
XDR_SETPOS (VAR_8, VAR_7->cu_xdrpos);
(*(uint32_t *) (VAR_7->cu_outbuf))++;
if ((!XDR_PUTLONG (VAR_8, (long *) &VAR_1)) ||
(!AUTH_MARSHALL (VAR_0->cl_auth, VAR_8)) ||
(!(*VAR_2) (VAR_8, VAR_3)))
return (VAR_7->cu_error.re_status = VAR_23);
VAR_9 = (int) XDR_GETPOS (VAR_8);
send_again:
if (__sendto (VAR_7->cu_sock, VAR_7->cu_outbuf, VAR_9, 0,
(struct sockaddr *) &(VAR_7->cu_raddr), VAR_7->cu_rlen)
!= VAR_9)
{
VAR_7->cu_error.re_errno = VAR_24;
return (VAR_7->cu_error.re_status = VAR_25);
}
if (VAR_20.tv_sec == 0 && VAR_20.tv_usec == 0)
{
return (VAR_7->cu_error.re_status = VAR_26);
}
get_reply:
VAR_15.acpted_rply.ar_verf = VAR_27;
VAR_15.acpted_rply.ar_results.where = VAR_5;
VAR_15.acpted_rply.ar_results.proc = VAR_4;
VAR_12.fd = VAR_7->cu_sock;
VAR_12.events = VAR_28;
VAR_21 = 0;
for (;;)
{
switch (__poll (&VAR_12, 1, VAR_13))
{
case 0:
if (VAR_21 == 0)
{
VAR_21 = is_network_up (VAR_7->cu_sock);
if (!VAR_21)
return (VAR_7->cu_error.re_status = VAR_29);
}
VAR_17.tv_sec += VAR_7->cu_wait.tv_sec;
VAR_17.tv_usec += VAR_7->cu_wait.tv_usec;
while (VAR_17.tv_usec >= 1000000)
{
VAR_17.tv_sec++;
VAR_17.tv_usec -= 1000000;
}
if ((VAR_17.tv_sec < VAR_20.tv_sec) ||
((VAR_17.tv_sec == VAR_20.tv_sec) &&
(VAR_17.tv_usec < VAR_20.tv_usec)))
goto send_again;
return (VAR_7->cu_error.re_status = VAR_26);
case -1:
if (VAR_24 == VAR_30)
continue;
VAR_7->cu_error.re_errno = VAR_24;
return (VAR_7->cu_error.re_status = VAR_29);
}
#ifdef VAR_31
if (VAR_12.revents & VAR_32)
{
struct msghdr VAR_33;
struct cmsghdr *VAR_34;
struct sock_extended_err *VAR_35;
struct sockaddr_in VAR_36;
struct iovec VAR_37;
char *VAR_38 = malloc (VAR_9 + 256);
int VAR_39;
if (VAR_38 == NULL)
{
VAR_7->cu_error.re_errno = VAR_24;
return (VAR_7->cu_error.re_status = VAR_29);
}
VAR_37.iov_base = VAR_38 + 256;
VAR_37.iov_len = VAR_9;
VAR_33.msg_name = (void *) &VAR_36;
VAR_33.msg_namelen = sizeof (VAR_36);
VAR_33.msg_iov = &VAR_37;
VAR_33.msg_iovlen = 1;
VAR_33.msg_flags = 0;
VAR_33.msg_control = VAR_38;
VAR_33.msg_controllen = 256;
VAR_39 = __recvmsg (VAR_7->cu_sock, &VAR_33, VAR_40);
if (VAR_39 >= 0
&& memcmp (VAR_38 + 256, VAR_7->cu_outbuf, VAR_39) == 0
&& (VAR_33.msg_flags & VAR_40)
&& ((VAR_33.msg_namelen == 0
&& VAR_39 >= 12)
|| (VAR_33.msg_namelen == sizeof (VAR_36)
&& VAR_36.sin_family == VAR_41
&& memcmp (&VAR_36.sin_addr, &VAR_7->cu_raddr.sin_addr,
sizeof (VAR_36.sin_addr)) == 0
&& VAR_36.sin_port == VAR_7->cu_raddr.sin_port)))
for (VAR_34 = CMSG_FIRSTHDR (&VAR_33); VAR_34;
VAR_34 = CMSG_NXTHDR (&VAR_33, VAR_34))
if (VAR_34->cmsg_level == VAR_42 && VAR_34->cmsg_type == VAR_31)
{
free (VAR_38);
VAR_35 = (struct sock_extended_err *) CMSG_DATA(VAR_34);
VAR_7->cu_error.re_errno = VAR_35->ee_errno;
return (VAR_7->cu_error.re_status = VAR_29);
}
free (VAR_38);
}
#endif
do
{
VAR_11 = sizeof (struct sockaddr);
VAR_10 = __recvfrom (VAR_7->cu_sock, VAR_7->cu_inbuf,
(int) VAR_7->cu_recvsz, VAR_43,
(struct sockaddr *) &VAR_14, &VAR_11);
}
while (VAR_10 < 0 && VAR_24 == VAR_30);
if (VAR_10 < 0)
{
if (VAR_24 == VAR_44)
continue;
VAR_7->cu_error.re_errno = VAR_24;
return (VAR_7->cu_error.re_status = VAR_29);
}
if (VAR_10 < 4)
continue;
if (VAR_2 != NULL
&& memcmp (VAR_7->cu_inbuf, VAR_7->cu_outbuf, sizeof (VAR_45)) != 0)
continue;
break;
}
xdrmem_create (&VAR_16, VAR_7->cu_inbuf, (u_int) VAR_10, VAR_46);
VAR_18 = xdr_replymsg (&VAR_16, &VAR_15);
if (VAR_18)
{
_seterr_reply (&VAR_15, &(VAR_7->cu_error));
if (VAR_7->cu_error.re_status == VAR_47)
{
if (!AUTH_VALIDATE (VAR_0->cl_auth,
&VAR_15.acpted_rply.ar_verf))
{
VAR_7->cu_error.re_status = VAR_48;
VAR_7->cu_error.re_why = VAR_49;
}
if (VAR_15.acpted_rply.ar_verf.oa_base != NULL)
{
VAR_8->x_op = VAR_50;
(void) xdr_opaque_auth (VAR_8, &(VAR_15.acpted_rply.ar_verf));
}
}
else
{
if (VAR_19 > 0 && AUTH_REFRESH (VAR_0->cl_auth))
{
VAR_19--;
goto call_again;
}
}
}
else
{
VAR_7->cu_error.re_status = VAR_51;
}
return VAR_7->cu_error.re_status;
}",glibc/d42eed4a044e5e10dfb885cf9891c2518a72a491/clnt_udp.c/vul/before/0.json,"static enum clnt_stat
clntudp_call (/* client handle */
	      CLIENT *cl,
	      /* procedure number */
	      u_long proc,
	      /* xdr routine for args */
	      xdrproc_t xargs,
	      /* pointer to args */
	      caddr_t argsp,
	      /* xdr routine for results */
	      xdrproc_t xresults,
	      /* pointer to results */
	      caddr_t resultsp,
	      /* seconds to wait before giving up */
	      struct timeval utimeout)
{
  struct cu_data *cu = (struct cu_data *) cl->cl_private;
  XDR *xdrs;
  int outlen = 0;
  int inlen;
  socklen_t fromlen;
  struct pollfd fd;
  int milliseconds = (cu->cu_wait.tv_sec * 1000) +
    (cu->cu_wait.tv_usec / 1000);
  struct sockaddr_in from;
  struct rpc_msg reply_msg;
  XDR reply_xdrs;
  struct timeval time_waited;
  bool_t ok;
  int nrefreshes = 2;		/* number of times to refresh cred */
  struct timeval timeout;
  int anyup;			/* any network interface up */

  if (cu->cu_total.tv_usec == -1)
    {
      timeout = utimeout;	/* use supplied timeout */
    }
  else
    {
      timeout = cu->cu_total;	/* use default timeout */
    }

  time_waited.tv_sec = 0;
  time_waited.tv_usec = 0;
call_again:
  xdrs = &(cu->cu_outxdrs);
  if (xargs == NULL)
    goto get_reply;
  xdrs->x_op = XDR_ENCODE;
  XDR_SETPOS (xdrs, cu->cu_xdrpos);
  /*
   * the transaction is the first thing in the out buffer
   */
  (*(uint32_t *) (cu->cu_outbuf))++;
  if ((!XDR_PUTLONG (xdrs, (long *) &proc)) ||
      (!AUTH_MARSHALL (cl->cl_auth, xdrs)) ||
      (!(*xargs) (xdrs, argsp)))
    return (cu->cu_error.re_status = RPC_CANTENCODEARGS);
  outlen = (int) XDR_GETPOS (xdrs);

send_again:
  if (__sendto (cu->cu_sock, cu->cu_outbuf, outlen, 0,
		(struct sockaddr *) &(cu->cu_raddr), cu->cu_rlen)
      != outlen)
    {
      cu->cu_error.re_errno = errno;
      return (cu->cu_error.re_status = RPC_CANTSEND);
    }

  /*
   * Hack to provide rpc-based message passing
   */
  if (timeout.tv_sec == 0 && timeout.tv_usec == 0)
    {
      return (cu->cu_error.re_status = RPC_TIMEDOUT);
    }
 get_reply:
  /*
   * sub-optimal code appears here because we have
   * some clock time to spare while the packets are in flight.
   * (We assume that this is actually only executed once.)
   */
  reply_msg.acpted_rply.ar_verf = _null_auth;
  reply_msg.acpted_rply.ar_results.where = resultsp;
  reply_msg.acpted_rply.ar_results.proc = xresults;
  fd.fd = cu->cu_sock;
  fd.events = POLLIN;
  anyup = 0;
  for (;;)
    {
      switch (__poll (&fd, 1, milliseconds))
	{

	case 0:
	  if (anyup == 0)
	    {
	      anyup = is_network_up (cu->cu_sock);
	      if (!anyup)
		return (cu->cu_error.re_status = RPC_CANTRECV);
	    }

	  time_waited.tv_sec += cu->cu_wait.tv_sec;
	  time_waited.tv_usec += cu->cu_wait.tv_usec;
	  while (time_waited.tv_usec >= 1000000)
	    {
	      time_waited.tv_sec++;
	      time_waited.tv_usec -= 1000000;
	    }
	  if ((time_waited.tv_sec < timeout.tv_sec) ||
	      ((time_waited.tv_sec == timeout.tv_sec) &&
	       (time_waited.tv_usec < timeout.tv_usec)))
	    goto send_again;
	  return (cu->cu_error.re_status = RPC_TIMEDOUT);

	  /*
	   * buggy in other cases because time_waited is not being
	   * updated.
	   */
	case -1:
	  if (errno == EINTR)
	    continue;
	  cu->cu_error.re_errno = errno;
	  return (cu->cu_error.re_status = RPC_CANTRECV);
	}
#ifdef IP_RECVERR
      if (fd.revents & POLLERR)
	{
	  struct msghdr msg;
	  struct cmsghdr *cmsg;
	  struct sock_extended_err *e;
	  struct sockaddr_in err_addr;
	  struct iovec iov;
	  char *cbuf = malloc (outlen + 256);
	  int ret;

	  if (cbuf == NULL)
	    {
	      cu->cu_error.re_errno = errno;
	      return (cu->cu_error.re_status = RPC_CANTRECV);
	    }

	  iov.iov_base = cbuf + 256;
	  iov.iov_len = outlen;
	  msg.msg_name = (void *) &err_addr;
	  msg.msg_namelen = sizeof (err_addr);
	  msg.msg_iov = &iov;
	  msg.msg_iovlen = 1;
	  msg.msg_flags = 0;
	  msg.msg_control = cbuf;
	  msg.msg_controllen = 256;
	  ret = __recvmsg (cu->cu_sock, &msg, MSG_ERRQUEUE);
	  if (ret >= 0
	      && memcmp (cbuf + 256, cu->cu_outbuf, ret) == 0
	      && (msg.msg_flags & MSG_ERRQUEUE)
	      && ((msg.msg_namelen == 0
		   && ret >= 12)
		  || (msg.msg_namelen == sizeof (err_addr)
		      && err_addr.sin_family == AF_INET
		      && memcmp (&err_addr.sin_addr, &cu->cu_raddr.sin_addr,
				 sizeof (err_addr.sin_addr)) == 0
		      && err_addr.sin_port == cu->cu_raddr.sin_port)))
	    for (cmsg = CMSG_FIRSTHDR (&msg); cmsg;
		 cmsg = CMSG_NXTHDR (&msg, cmsg))
	      if (cmsg->cmsg_level == SOL_IP && cmsg->cmsg_type == IP_RECVERR)
		{
		  e = (struct sock_extended_err *) CMSG_DATA(cmsg);
		  cu->cu_error.re_errno = e->ee_errno;
		  free (cbuf);
		  return (cu->cu_error.re_status = RPC_CANTRECV);
		}
	  free (cbuf);
	}
#endif
      do
	{
	  fromlen = sizeof (struct sockaddr);
	  inlen = __recvfrom (cu->cu_sock, cu->cu_inbuf,
			      (int) cu->cu_recvsz, MSG_DONTWAIT,
			      (struct sockaddr *) &from, &fromlen);
	}
      while (inlen < 0 && errno == EINTR);
      if (inlen < 0)
	{
	  if (errno == EWOULDBLOCK)
	    continue;
	  cu->cu_error.re_errno = errno;
	  return (cu->cu_error.re_status = RPC_CANTRECV);
	}
      if (inlen < 4)
	continue;

      /* see if reply transaction id matches sent id.
	Don't do this if we only wait for a replay */
      if (xargs != NULL
	  && memcmp (cu->cu_inbuf, cu->cu_outbuf, sizeof (u_int32_t)) != 0)
	continue;
      /* we now assume we have the proper reply */
      break;
    }

  /*
   * now decode and validate the response
   */
  xdrmem_create (&reply_xdrs, cu->cu_inbuf, (u_int) inlen, XDR_DECODE);
  ok = xdr_replymsg (&reply_xdrs, &reply_msg);
  /* XDR_DESTROY(&reply_xdrs);  save a few cycles on noop destroy */
  if (ok)
    {
      _seterr_reply (&reply_msg, &(cu->cu_error));
      if (cu->cu_error.re_status == RPC_SUCCESS)
	{
	  if (!AUTH_VALIDATE (cl->cl_auth,
			      &reply_msg.acpted_rply.ar_verf))
	    {
	      cu->cu_error.re_status = RPC_AUTHERROR;
	      cu->cu_error.re_why = AUTH_INVALIDRESP;
	    }
	  if (reply_msg.acpted_rply.ar_verf.oa_base != NULL)
	    {
	      xdrs->x_op = XDR_FREE;
	      (void) xdr_opaque_auth (xdrs, &(reply_msg.acpted_rply.ar_verf));
	    }
	}			/* end successful completion */
      else
	{
	  /* maybe our credentials need to be refreshed ... */
	  if (nrefreshes > 0 && AUTH_REFRESH (cl->cl_auth))
	    {
	      nrefreshes--;
	      goto call_again;
	    }
	}			/* end of unsuccessful completion */
    }				/* end of valid reply message */
  else
    {
      cu->cu_error.re_status = RPC_CANTDECODERES;
    }
  return cu->cu_error.re_status;
}","static enum clnt_stat
clntudp_call (/* COMMENT_0 */
	      CLIENT *VAR_0,
	      /* COMMENT_1 */
	      u_long VAR_1,
	      /* COMMENT_2 */
	      xdrproc_t VAR_2,
	      /* COMMENT_3 */
	      caddr_t VAR_3,
	      /* COMMENT_4 */
	      xdrproc_t VAR_4,
	      /* COMMENT_5 */
	      caddr_t VAR_5,
	      /* COMMENT_6 */
	      struct timeval VAR_6)
{
  struct cu_data *VAR_7 = (struct cu_data *) VAR_0->cl_private;
  XDR *VAR_8;
  int VAR_9 = 0;
  int VAR_10;
  socklen_t VAR_11;
  struct pollfd VAR_12;
  int VAR_13 = (VAR_7->cu_wait.tv_sec * 1000) +
    (VAR_7->cu_wait.tv_usec / 1000);
  struct sockaddr_in VAR_14;
  struct rpc_msg VAR_15;
  XDR VAR_16;
  struct timeval VAR_17;
  bool_t VAR_18;
  int VAR_19 = 2;		/* COMMENT_7 */
  struct timeval VAR_20;
  int VAR_21;			/* COMMENT_8 */

  if (VAR_7->cu_total.tv_usec == -1)
    {
      VAR_20 = VAR_6;	/* COMMENT_9 */
    }
  else
    {
      VAR_20 = VAR_7->cu_total;	/* COMMENT_10 */
    }

  VAR_17.tv_sec = 0;
  VAR_17.tv_usec = 0;
call_again:
  VAR_8 = &(VAR_7->cu_outxdrs);
  if (VAR_2 == NULL)
    goto get_reply;
  VAR_8->x_op = VAR_22;
  XDR_SETPOS (VAR_8, VAR_7->cu_xdrpos);
  /* COMMENT_11 */
                                                         
     
  (*(uint32_t *) (VAR_7->cu_outbuf))++;
  if ((!XDR_PUTLONG (VAR_8, (long *) &VAR_1)) ||
      (!AUTH_MARSHALL (VAR_0->cl_auth, VAR_8)) ||
      (!(*VAR_2) (VAR_8, VAR_3)))
    return (VAR_7->cu_error.re_status = VAR_23);
  VAR_9 = (int) XDR_GETPOS (VAR_8);

send_again:
  if (__sendto (VAR_7->cu_sock, VAR_7->cu_outbuf, VAR_9, 0,
		(struct sockaddr *) &(VAR_7->cu_raddr), VAR_7->cu_rlen)
      != VAR_9)
    {
      VAR_7->cu_error.re_errno = VAR_24;
      return (VAR_7->cu_error.re_status = VAR_25);
    }

  /* COMMENT_14 */
                                              
     
  if (VAR_20.tv_sec == 0 && VAR_20.tv_usec == 0)
    {
      return (VAR_7->cu_error.re_status = VAR_26);
    }
 get_reply:
  /* COMMENT_17 */
                                                  
                                                              
                                                          
     
  VAR_15.acpted_rply.ar_verf = VAR_27;
  VAR_15.acpted_rply.ar_results.where = VAR_5;
  VAR_15.acpted_rply.ar_results.proc = VAR_4;
  VAR_12.fd = VAR_7->cu_sock;
  VAR_12.events = VAR_28;
  VAR_21 = 0;
  for (;;)
    {
      switch (__poll (&VAR_12, 1, VAR_13))
	{

	case 0:
	  if (VAR_21 == 0)
	    {
	      VAR_21 = is_network_up (VAR_7->cu_sock);
	      if (!VAR_21)
		return (VAR_7->cu_error.re_status = VAR_29);
	    }

	  VAR_17.tv_sec += VAR_7->cu_wait.tv_sec;
	  VAR_17.tv_usec += VAR_7->cu_wait.tv_usec;
	  while (VAR_17.tv_usec >= 1000000)
	    {
	      VAR_17.tv_sec++;
	      VAR_17.tv_usec -= 1000000;
	    }
	  if ((VAR_17.tv_sec < VAR_20.tv_sec) ||
	      ((VAR_17.tv_sec == VAR_20.tv_sec) &&
	       (VAR_17.tv_usec < VAR_20.tv_usec)))
	    goto send_again;
	  return (VAR_7->cu_error.re_status = VAR_26);

	  /* COMMENT_22 */
                                                           
              
      
	case -1:
	  if (VAR_24 == VAR_30)
	    continue;
	  VAR_7->cu_error.re_errno = VAR_24;
	  return (VAR_7->cu_error.re_status = VAR_29);
	}
#ifdef VAR_31
      if (VAR_12.revents & VAR_32)
	{
	  struct msghdr VAR_33;
	  struct cmsghdr *VAR_34;
	  struct sock_extended_err *VAR_35;
	  struct sockaddr_in VAR_36;
	  struct iovec VAR_37;
	  char *VAR_38 = malloc (VAR_9 + 256);
	  int VAR_39;

	  if (VAR_38 == NULL)
	    {
	      VAR_7->cu_error.re_errno = VAR_24;
	      return (VAR_7->cu_error.re_status = VAR_29);
	    }

	  VAR_37.iov_base = VAR_38 + 256;
	  VAR_37.iov_len = VAR_9;
	  VAR_33.msg_name = (void *) &VAR_36;
	  VAR_33.msg_namelen = sizeof (VAR_36);
	  VAR_33.msg_iov = &VAR_37;
	  VAR_33.msg_iovlen = 1;
	  VAR_33.msg_flags = 0;
	  VAR_33.msg_control = VAR_38;
	  VAR_33.msg_controllen = 256;
	  VAR_39 = __recvmsg (VAR_7->cu_sock, &VAR_33, VAR_40);
	  if (VAR_39 >= 0
	      && memcmp (VAR_38 + 256, VAR_7->cu_outbuf, VAR_39) == 0
	      && (VAR_33.msg_flags & VAR_40)
	      && ((VAR_33.msg_namelen == 0
		   && VAR_39 >= 12)
		  || (VAR_33.msg_namelen == sizeof (VAR_36)
		      && VAR_36.sin_family == VAR_41
		      && memcmp (&VAR_36.sin_addr, &VAR_7->cu_raddr.sin_addr,
				 sizeof (VAR_36.sin_addr)) == 0
		      && VAR_36.sin_port == VAR_7->cu_raddr.sin_port)))
	    for (VAR_34 = CMSG_FIRSTHDR (&VAR_33); VAR_34;
		 VAR_34 = CMSG_NXTHDR (&VAR_33, VAR_34))
	      if (VAR_34->cmsg_level == VAR_42 && VAR_34->cmsg_type == VAR_31)
		{
		  VAR_35 = (struct sock_extended_err *) CMSG_DATA(VAR_34);
		  VAR_7->cu_error.re_errno = VAR_35->ee_errno;
		  free (VAR_38);
		  return (VAR_7->cu_error.re_status = VAR_29);
		}
	  free (VAR_38);
	}
#endif
      do
	{
	  VAR_11 = sizeof (struct sockaddr);
	  VAR_10 = __recvfrom (VAR_7->cu_sock, VAR_7->cu_inbuf,
			      (int) VAR_7->cu_recvsz, VAR_43,
			      (struct sockaddr *) &VAR_14, &VAR_11);
	}
      while (VAR_10 < 0 && VAR_24 == VAR_30);
      if (VAR_10 < 0)
	{
	  if (VAR_24 == VAR_44)
	    continue;
	  VAR_7->cu_error.re_errno = VAR_24;
	  return (VAR_7->cu_error.re_status = VAR_29);
	}
      if (VAR_10 < 4)
	continue;

      /* COMMENT_26 */
                                              
      if (VAR_2 != NULL
	  && memcmp (VAR_7->cu_inbuf, VAR_7->cu_outbuf, sizeof (VAR_45)) != 0)
	continue;
      /* COMMENT_28 */
      break;
    }

  /* COMMENT_29 */
                                         
     
  xdrmem_create (&VAR_16, VAR_7->cu_inbuf, (u_int) VAR_10, VAR_46);
  VAR_18 = xdr_replymsg (&VAR_16, &VAR_15);
  /* COMMENT_32 */
  if (VAR_18)
    {
      _seterr_reply (&VAR_15, &(VAR_7->cu_error));
      if (VAR_7->cu_error.re_status == VAR_47)
	{
	  if (!AUTH_VALIDATE (VAR_0->cl_auth,
			      &VAR_15.acpted_rply.ar_verf))
	    {
	      VAR_7->cu_error.re_status = VAR_48;
	      VAR_7->cu_error.re_why = VAR_49;
	    }
	  if (VAR_15.acpted_rply.ar_verf.oa_base != NULL)
	    {
	      VAR_8->x_op = VAR_50;
	      (void) xdr_opaque_auth (VAR_8, &(VAR_15.acpted_rply.ar_verf));
	    }
	}			/* COMMENT_33 */
      else
	{
	  /* COMMENT_34 */
	  if (VAR_19 > 0 && AUTH_REFRESH (VAR_0->cl_auth))
	    {
	      VAR_19--;
	      goto call_again;
	    }
	}			/* COMMENT_35 */
    }				/* COMMENT_36 */
  else
    {
      VAR_7->cu_error.re_status = VAR_51;
    }
  return VAR_7->cu_error.re_status;
}",glibc/d42eed4a044e5e10dfb885cf9891c2518a72a491/clnt_udp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -163,9 +163,9 @@
 		 cmsg = CMSG_NXTHDR (&msg, cmsg))
 	      if (cmsg->cmsg_level == SOL_IP && cmsg->cmsg_type == IP_RECVERR)
 		{
-		  free (cbuf);
 		  e = (struct sock_extended_err *) CMSG_DATA(cmsg);
 		  cu->cu_error.re_errno = e->ee_errno;
+		  free (cbuf);
 		  return (cu->cu_error.re_status = RPC_CANTRECV);
 		}
 	  free (cbuf);","{'deleted_lines': ['\t\t  free (cbuf);'], 'added_lines': ['\t\t  free (cbuf);']}",True,Use-after-free vulnerability in the clntudp_call function in sunrpc/clnt_udp.c in the GNU C Library (aka glibc or libc6) before 2.26 allows remote attackers to have unspecified impact via vectors related to error path.,5.9,MEDIUM,1,test,,5
CVE-2017-14729,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,binutils-gdb,"
x86: Guard against corrupted PLT

There should be only one entry in PLT for a given symbol.  Set howto to
NULL after processing a PLT entry to guard against corrupted PLT so that
the duplicated PLT entries are skipped.

	PR binutils/22170
	 * elf32-i386.c (elf_i386_get_synthetic_symtab): Guard against
	 corrupted PLT.
	 * elf64-x86-64.c (elf_x86_64_get_synthetic_symtab): Likewise.

(cherry picked from commit 61e3bf5f83f7e505b6bc51ef65426e5b31e6e360)
",56933f9e3e90eebf1018ed7417d6c1184b91db6b,https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=56933f9e3e90eebf1018ed7417d6c1184b91db6b,bfd/elf32-i386.c,elf_i386_get_synthetic_symtab,"static long
elf_i386_get_synthetic_symtab (bfd *abfd,
long symcount ATTRIBUTE_UNUSED,
asymbol **syms ATTRIBUTE_UNUSED,
long dynsymcount,
asymbol **dynsyms,
asymbol **ret)
{
long size, count, i, n;
int j;
unsigned int plt_got_offset, plt_entry_size;
asymbol *s;
bfd_byte *plt_contents;
long dynrelcount, relsize;
arelent **dynrelbuf;
const struct elf_i386_lazy_plt_layout *lazy_plt;
const struct elf_i386_non_lazy_plt_layout *non_lazy_plt;
const struct elf_i386_lazy_plt_layout *lazy_ibt_plt;
const struct elf_i386_non_lazy_plt_layout *non_lazy_ibt_plt;
asection *plt;
bfd_vma got_addr;
char *names;
enum elf_i386_plt_type plt_type;
struct elf_i386_plt plts[] =
{
{ "".plt"", NULL, NULL, plt_unknown, 0, 0, 0 },
{ "".plt.got"", NULL, NULL, plt_non_lazy, 0, 0, 0 },
{ "".plt.sec"", NULL, NULL, plt_second, 0, 0, 0 },
{ NULL, NULL, NULL, plt_non_lazy, 0, 0, 0 }
};
*ret = NULL;
if ((abfd->flags & (DYNAMIC | EXEC_P)) == 0)
return 0;
if (dynsymcount <= 0)
return 0;
relsize = bfd_get_dynamic_reloc_upper_bound (abfd);
if (relsize <= 0)
return -1;
dynrelbuf = (arelent **) bfd_malloc (relsize);
if (dynrelbuf == NULL)
return -1;
dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf,
dynsyms);
if (dynrelcount <= 0)
return -1;
qsort (dynrelbuf, dynrelcount, sizeof (arelent *), compare_relocs);
non_lazy_plt = NULL;
lazy_plt = NULL;
non_lazy_ibt_plt = NULL;
lazy_ibt_plt = NULL;
switch (get_elf_i386_backend_data (abfd)->os)
{
case is_normal:
non_lazy_plt = &elf_i386_non_lazy_plt;
lazy_ibt_plt = &elf_i386_lazy_ibt_plt;
non_lazy_ibt_plt = &elf_i386_non_lazy_ibt_plt;
case is_vxworks:
lazy_plt = &elf_i386_lazy_plt;
break;
case is_nacl:
lazy_plt = &elf_i386_nacl_plt;
break;
}
got_addr = 0;
count = 0;
for (j = 0; plts[j].name != NULL; j++)
{
plt = bfd_get_section_by_name (abfd, plts[j].name);
if (plt == NULL || plt->size == 0)
continue;
plt_contents = (bfd_byte *) bfd_malloc (plt->size);
if (plt_contents == NULL)
break;
if (!bfd_get_section_contents (abfd, (asection *) plt,
plt_contents, 0, plt->size))
{
free (plt_contents);
break;
}
plt_type = plt_unknown;
if (plts[j].type == plt_unknown
&& (plt->size >= (lazy_plt->plt0_entry_size
+ lazy_plt->plt_entry_size)))
{
if (memcmp (plt_contents, lazy_plt->plt0_entry,
lazy_plt->plt0_got1_offset) == 0)
{
if (lazy_ibt_plt != NULL
&& (memcmp (plt_contents + lazy_ibt_plt->plt0_entry_size,
lazy_ibt_plt->plt_entry,
lazy_ibt_plt->plt_got_offset) == 0))
plt_type = plt_lazy | plt_second;
else
plt_type = plt_lazy;
}
else if (memcmp (plt_contents, lazy_plt->pic_plt0_entry,
lazy_plt->plt0_got1_offset) == 0)
{
if (lazy_ibt_plt != NULL
&& (memcmp (plt_contents + lazy_ibt_plt->plt0_entry_size,
lazy_ibt_plt->pic_plt_entry,
lazy_ibt_plt->plt_got_offset) == 0))
plt_type = plt_lazy | plt_pic | plt_second;
else
plt_type = plt_lazy | plt_pic;
}
}
if (non_lazy_plt != NULL
&& (plt_type == plt_unknown || plt_type == plt_non_lazy)
&& plt->size >= non_lazy_plt->plt_entry_size)
{
if (memcmp (plt_contents, non_lazy_plt->plt_entry,
non_lazy_plt->plt_got_offset) == 0)
plt_type = plt_non_lazy;
else if (memcmp (plt_contents, non_lazy_plt->pic_plt_entry,
non_lazy_plt->plt_got_offset) == 0)
plt_type = plt_pic;
}
if ((non_lazy_ibt_plt != NULL)
&& (plt_type == plt_unknown || plt_type == plt_second)
&& plt->size >= non_lazy_ibt_plt->plt_entry_size)
{
if (memcmp (plt_contents,
non_lazy_ibt_plt->plt_entry,
non_lazy_ibt_plt->plt_got_offset) == 0)
{
plt_type = plt_second;
non_lazy_plt = non_lazy_ibt_plt;
}
else if (memcmp (plt_contents,
non_lazy_ibt_plt->pic_plt_entry,
non_lazy_ibt_plt->plt_got_offset) == 0)
{
plt_type = plt_second | plt_pic;
non_lazy_plt = non_lazy_ibt_plt;
}
}
if (plt_type == plt_unknown)
continue;
plts[j].sec = plt;
plts[j].type = plt_type;
if ((plt_type & plt_lazy))
{
plts[j].plt_got_offset = lazy_plt->plt_got_offset;
plts[j].plt_entry_size = lazy_plt->plt_entry_size;
i = 1;
}
else
{
plts[j].plt_got_offset = non_lazy_plt->plt_got_offset;
plts[j].plt_entry_size = non_lazy_plt->plt_entry_size;
i = 0;
}
if ((plt_type & (plt_lazy | plt_second))
== (plt_lazy | plt_second))
plts[j].count = 0;
else
{
n = plt->size / plts[j].plt_entry_size;
plts[j].count = n;
count += n - i;
}
plts[j].contents = plt_contents;
if ((plt_type & plt_pic))
got_addr = (bfd_vma) -1;
}
if (count == 0)
return -1;
size = count * sizeof (asymbol);
s = *ret = (asymbol *) bfd_zmalloc (size);
if (s == NULL)
{
bad_return:
for (j = 0; plts[j].name != NULL; j++)
if (plts[j].contents != NULL)
free (plts[j].contents);
free (dynrelbuf);
return -1;
}
if (got_addr)
{
asection *sec = bfd_get_section_by_name (abfd, "".got.plt"");
if (sec != NULL)
got_addr = sec->vma;
else
{
sec = bfd_get_section_by_name (abfd, "".got"");
if (sec != NULL)
got_addr = sec->vma;
}
if (got_addr == (bfd_vma) -1)
goto bad_return;
}
size = 0;
n = 0;
for (j = 0; plts[j].name != NULL; j++)
if ((plt_contents = plts[j].contents) != NULL)
{
long k;
bfd_vma offset;
plt_got_offset = plts[j].plt_got_offset;
plt_entry_size = plts[j].plt_entry_size;
plt = plts[j].sec;
if ((plts[j].type & plt_lazy))
{
k = 1;
offset = plt_entry_size;
}
else
{
k = 0;
offset = 0;
}
for (; k < plts[j].count; k++)
{
int off;
bfd_vma got_vma;
long min, max, mid;
arelent *p;
off = H_GET_32 (abfd, (plt_contents + offset
+ plt_got_offset));
got_vma = got_addr + off;
p = dynrelbuf[0];
min = 0;
max = dynrelcount;
while ((min + 1) < max)
{
arelent *r;
mid = (min + max) / 2;
r = dynrelbuf[mid];
if (got_vma > r->address)
min = mid;
else if (got_vma < r->address)
max = mid;
else
{
p = r;
break;
}
}
if (got_vma == p->address
&& p->howto != NULL
&& (p->howto->type == R_386_JUMP_SLOT
|| p->howto->type == R_386_GLOB_DAT
|| p->howto->type == R_386_IRELATIVE))
{
*s = **p->sym_ptr_ptr;
if ((s->flags & BSF_LOCAL) == 0)
s->flags |= BSF_GLOBAL;
s->flags |= BSF_SYNTHETIC;
s->flags &= ~BSF_SECTION_SYM;
s->section = plt;
s->the_bfd = plt->owner;
s->value = offset;
s->udata.p = p;
size += strlen (s->name) + sizeof (""@plt"");
if (p->addend != 0)
size += sizeof (""+0x"") - 1 + 8;
n++;
s++;
}
offset += plt_entry_size;
}
}
if (n == 0)
goto bad_return;
count = n;
names = (char *) bfd_malloc (size);
if (s == NULL)
goto bad_return;
s = *ret;
for (i = 0; i < count; i++)
{
arelent *p = (arelent *) s->udata.p;
s->udata.p = NULL;
size = strlen (s->name);
memcpy (names, s->name, size);
s->name = names;
names += size;
if (p->addend != 0)
{
char buf[30], *a;
memcpy (names, ""+0x"", sizeof (""+0x"") - 1);
names += sizeof (""+0x"") - 1;
bfd_sprintf_vma (abfd, buf, p->addend);
for (a = buf; *a == '0'; ++a)
;
size = strlen (a);
memcpy (names, a, size);
names += size;
}
memcpy (names, ""@plt"", sizeof (""@plt""));
names += sizeof (""@plt"");
s++;
}
for (j = 0; plts[j].name != NULL; j++)
if (plts[j].contents != NULL)
free (plts[j].contents);
free (dynrelbuf);
return count;
}","static long
elf_i386_get_synthetic_symtab (bfd *VAR_0,
long VAR_1 ATTRIBUTE_UNUSED,
asymbol **VAR_2 ATTRIBUTE_UNUSED,
long VAR_3,
asymbol **VAR_4,
asymbol **VAR_5)
{
long VAR_6, VAR_7, VAR_8, VAR_9;
int VAR_10;
unsigned int VAR_11, VAR_12;
asymbol *VAR_13;
bfd_byte *VAR_14;
long VAR_15, VAR_16;
arelent **VAR_17;
const struct elf_i386_lazy_plt_layout *VAR_18;
const struct elf_i386_non_lazy_plt_layout *VAR_19;
const struct elf_i386_lazy_plt_layout *VAR_20;
const struct elf_i386_non_lazy_plt_layout *VAR_21;
asection *VAR_22;
bfd_vma VAR_23;
char *VAR_24;
enum elf_i386_plt_type VAR_25;
struct elf_i386_plt VAR_26[] =
{
{ "".plt"", NULL, NULL, VAR_27, 0, 0, 0 },
{ "".plt.got"", NULL, NULL, VAR_28, 0, 0, 0 },
{ "".plt.sec"", NULL, NULL, VAR_29, 0, 0, 0 },
{ NULL, NULL, NULL, VAR_28, 0, 0, 0 }
};
*VAR_5 = NULL;
if ((VAR_0->flags & (VAR_30 | VAR_31)) == 0)
return 0;
if (VAR_3 <= 0)
return 0;
VAR_16 = bfd_get_dynamic_reloc_upper_bound (VAR_0);
if (VAR_16 <= 0)
return -1;
VAR_17 = (arelent **) bfd_malloc (VAR_16);
if (VAR_17 == NULL)
return -1;
VAR_15 = bfd_canonicalize_dynamic_reloc (VAR_0, VAR_17,
VAR_4);
if (VAR_15 <= 0)
return -1;
qsort (VAR_17, VAR_15, sizeof (arelent *), VAR_32);
VAR_19 = NULL;
VAR_18 = NULL;
VAR_21 = NULL;
VAR_20 = NULL;
switch (get_elf_i386_backend_data (VAR_0)->os)
{
case VAR_33:
VAR_19 = &VAR_34;
VAR_20 = &VAR_35;
VAR_21 = &VAR_36;
case VAR_37:
VAR_18 = &VAR_38;
break;
case VAR_39:
VAR_18 = &VAR_40;
break;
}
VAR_23 = 0;
VAR_7 = 0;
for (VAR_10 = 0; VAR_26[VAR_10].name != NULL; VAR_10++)
{
VAR_22 = bfd_get_section_by_name (VAR_0, VAR_26[VAR_10].name);
if (VAR_22 == NULL || VAR_22->size == 0)
continue;
VAR_14 = (bfd_byte *) bfd_malloc (VAR_22->size);
if (VAR_14 == NULL)
break;
if (!bfd_get_section_contents (VAR_0, (asection *) VAR_22,
VAR_14, 0, VAR_22->size))
{
free (VAR_14);
break;
}
VAR_25 = VAR_27;
if (VAR_26[VAR_10].type == VAR_27
&& (VAR_22->size >= (VAR_18->plt0_entry_size
+ VAR_18->plt_entry_size)))
{
if (memcmp (VAR_14, VAR_18->plt0_entry,
VAR_18->plt0_got1_offset) == 0)
{
if (VAR_20 != NULL
&& (memcmp (VAR_14 + VAR_20->plt0_entry_size,
VAR_20->plt_entry,
VAR_20->plt_got_offset) == 0))
VAR_25 = VAR_41 | VAR_29;
else
VAR_25 = VAR_41;
}
else if (memcmp (VAR_14, VAR_18->pic_plt0_entry,
VAR_18->plt0_got1_offset) == 0)
{
if (VAR_20 != NULL
&& (memcmp (VAR_14 + VAR_20->plt0_entry_size,
VAR_20->pic_plt_entry,
VAR_20->plt_got_offset) == 0))
VAR_25 = VAR_41 | VAR_42 | VAR_29;
else
VAR_25 = VAR_41 | VAR_42;
}
}
if (VAR_19 != NULL
&& (VAR_25 == VAR_27 || VAR_25 == VAR_28)
&& VAR_22->size >= VAR_19->plt_entry_size)
{
if (memcmp (VAR_14, VAR_19->plt_entry,
VAR_19->plt_got_offset) == 0)
VAR_25 = VAR_28;
else if (memcmp (VAR_14, VAR_19->pic_plt_entry,
VAR_19->plt_got_offset) == 0)
VAR_25 = VAR_42;
}
if ((VAR_21 != NULL)
&& (VAR_25 == VAR_27 || VAR_25 == VAR_29)
&& VAR_22->size >= VAR_21->plt_entry_size)
{
if (memcmp (VAR_14,
VAR_21->plt_entry,
VAR_21->plt_got_offset) == 0)
{
VAR_25 = VAR_29;
VAR_19 = VAR_21;
}
else if (memcmp (VAR_14,
VAR_21->pic_plt_entry,
VAR_21->plt_got_offset) == 0)
{
VAR_25 = VAR_29 | VAR_42;
VAR_19 = VAR_21;
}
}
if (VAR_25 == VAR_27)
continue;
VAR_26[VAR_10].sec = VAR_22;
VAR_26[VAR_10].type = VAR_25;
if ((VAR_25 & VAR_41))
{
VAR_26[VAR_10].plt_got_offset = VAR_18->plt_got_offset;
VAR_26[VAR_10].plt_entry_size = VAR_18->plt_entry_size;
VAR_8 = 1;
}
else
{
VAR_26[VAR_10].plt_got_offset = VAR_19->plt_got_offset;
VAR_26[VAR_10].plt_entry_size = VAR_19->plt_entry_size;
VAR_8 = 0;
}
if ((VAR_25 & (VAR_41 | VAR_29))
== (VAR_41 | VAR_29))
VAR_26[VAR_10].count = 0;
else
{
VAR_9 = VAR_22->size / VAR_26[VAR_10].plt_entry_size;
VAR_26[VAR_10].count = VAR_9;
VAR_7 += VAR_9 - VAR_8;
}
VAR_26[VAR_10].contents = VAR_14;
if ((VAR_25 & VAR_42))
VAR_23 = (bfd_vma) -1;
}
if (VAR_7 == 0)
return -1;
VAR_6 = VAR_7 * sizeof (asymbol);
VAR_13 = *VAR_5 = (asymbol *) bfd_zmalloc (VAR_6);
if (VAR_13 == NULL)
{
bad_return:
for (VAR_10 = 0; VAR_26[VAR_10].name != NULL; VAR_10++)
if (VAR_26[VAR_10].contents != NULL)
free (VAR_26[VAR_10].contents);
free (VAR_17);
return -1;
}
if (VAR_23)
{
asection *VAR_43 = bfd_get_section_by_name (VAR_0, "".got.plt"");
if (VAR_43 != NULL)
VAR_23 = VAR_43->vma;
else
{
VAR_43 = bfd_get_section_by_name (VAR_0, "".got"");
if (VAR_43 != NULL)
VAR_23 = VAR_43->vma;
}
if (VAR_23 == (bfd_vma) -1)
goto bad_return;
}
VAR_6 = 0;
VAR_9 = 0;
for (VAR_10 = 0; VAR_26[VAR_10].name != NULL; VAR_10++)
if ((VAR_14 = VAR_26[VAR_10].contents) != NULL)
{
long VAR_44;
bfd_vma VAR_45;
VAR_11 = VAR_26[VAR_10].plt_got_offset;
VAR_12 = VAR_26[VAR_10].plt_entry_size;
VAR_22 = VAR_26[VAR_10].sec;
if ((VAR_26[VAR_10].type & VAR_41))
{
VAR_44 = 1;
VAR_45 = VAR_12;
}
else
{
VAR_44 = 0;
VAR_45 = 0;
}
for (; VAR_44 < VAR_26[VAR_10].count; VAR_44++)
{
int VAR_46;
bfd_vma VAR_47;
long VAR_48, VAR_49, VAR_50;
arelent *VAR_51;
VAR_46 = H_GET_32 (VAR_0, (VAR_14 + VAR_45
+ VAR_11));
VAR_47 = VAR_23 + VAR_46;
VAR_51 = VAR_17[0];
VAR_48 = 0;
VAR_49 = VAR_15;
while ((VAR_48 + 1) < VAR_49)
{
arelent *VAR_52;
VAR_50 = (VAR_48 + VAR_49) / 2;
VAR_52 = VAR_17[VAR_50];
if (VAR_47 > VAR_52->address)
VAR_48 = VAR_50;
else if (VAR_47 < VAR_52->address)
VAR_49 = VAR_50;
else
{
VAR_51 = VAR_52;
break;
}
}
if (VAR_47 == VAR_51->address
&& VAR_51->howto != NULL
&& (VAR_51->howto->type == VAR_53
|| VAR_51->howto->type == VAR_54
|| VAR_51->howto->type == VAR_55))
{
*VAR_13 = **VAR_51->sym_ptr_ptr;
if ((VAR_13->flags & VAR_56) == 0)
VAR_13->flags |= VAR_57;
VAR_13->flags |= VAR_58;
VAR_13->flags &= ~VAR_59;
VAR_13->section = VAR_22;
VAR_13->the_bfd = VAR_22->owner;
VAR_13->value = VAR_45;
VAR_13->udata.p = VAR_51;
VAR_6 += strlen (VAR_13->name) + sizeof (""@plt"");
if (VAR_51->addend != 0)
VAR_6 += sizeof (""+0x"") - 1 + 8;
VAR_9++;
VAR_13++;
}
VAR_45 += VAR_12;
}
}
if (VAR_9 == 0)
goto bad_return;
VAR_7 = VAR_9;
VAR_24 = (char *) bfd_malloc (VAR_6);
if (VAR_13 == NULL)
goto bad_return;
VAR_13 = *VAR_5;
for (VAR_8 = 0; VAR_8 < VAR_7; VAR_8++)
{
arelent *VAR_51 = (arelent *) VAR_13->udata.p;
VAR_13->udata.p = NULL;
VAR_6 = strlen (VAR_13->name);
memcpy (VAR_24, VAR_13->name, VAR_6);
VAR_13->name = VAR_24;
VAR_24 += VAR_6;
if (VAR_51->addend != 0)
{
char VAR_60[30], *VAR_61;
memcpy (VAR_24, ""+0x"", sizeof (""+0x"") - 1);
VAR_24 += sizeof (""+0x"") - 1;
bfd_sprintf_vma (VAR_0, VAR_60, VAR_51->addend);
for (VAR_61 = VAR_60; *VAR_61 == '0'; ++VAR_61)
;
VAR_6 = strlen (VAR_61);
memcpy (VAR_24, VAR_61, VAR_6);
VAR_24 += VAR_6;
}
memcpy (VAR_24, ""@plt"", sizeof (""@plt""));
VAR_24 += sizeof (""@plt"");
VAR_13++;
}
for (VAR_10 = 0; VAR_26[VAR_10].name != NULL; VAR_10++)
if (VAR_26[VAR_10].contents != NULL)
free (VAR_26[VAR_10].contents);
free (VAR_17);
return VAR_7;
}",,"static long
elf_i386_get_synthetic_symtab (bfd *abfd,
			       long symcount ATTRIBUTE_UNUSED,
			       asymbol **syms ATTRIBUTE_UNUSED,
			       long dynsymcount,
			       asymbol **dynsyms,
			       asymbol **ret)
{
  long size, count, i, n;
  int j;
  unsigned int plt_got_offset, plt_entry_size;
  asymbol *s;
  bfd_byte *plt_contents;
  long dynrelcount, relsize;
  arelent **dynrelbuf;
  const struct elf_i386_lazy_plt_layout *lazy_plt;
  const struct elf_i386_non_lazy_plt_layout *non_lazy_plt;
  const struct elf_i386_lazy_plt_layout *lazy_ibt_plt;
  const struct elf_i386_non_lazy_plt_layout *non_lazy_ibt_plt;
  asection *plt;
  bfd_vma got_addr;
  char *names;
  enum elf_i386_plt_type plt_type;
  struct elf_i386_plt plts[] =
    {
      { "".plt"", NULL, NULL, plt_unknown, 0, 0, 0 },
      { "".plt.got"", NULL, NULL, plt_non_lazy, 0, 0, 0 },
      { "".plt.sec"", NULL, NULL, plt_second, 0, 0, 0 },
      { NULL, NULL, NULL, plt_non_lazy, 0, 0, 0 }
    };

  *ret = NULL;

  if ((abfd->flags & (DYNAMIC | EXEC_P)) == 0)
    return 0;

  if (dynsymcount <= 0)
    return 0;

  relsize = bfd_get_dynamic_reloc_upper_bound (abfd);
  if (relsize <= 0)
    return -1;

  dynrelbuf = (arelent **) bfd_malloc (relsize);
  if (dynrelbuf == NULL)
    return -1;

  dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf,
						dynsyms);
  if (dynrelcount <= 0)
    return -1;

  /* Sort the relocs by address.  */
  qsort (dynrelbuf, dynrelcount, sizeof (arelent *), compare_relocs);

  non_lazy_plt = NULL;
  /* Silence GCC 6.  */
  lazy_plt = NULL;
  non_lazy_ibt_plt = NULL;
  lazy_ibt_plt = NULL;
  switch (get_elf_i386_backend_data (abfd)->os)
    {
    case is_normal:
      non_lazy_plt = &elf_i386_non_lazy_plt;
      lazy_ibt_plt = &elf_i386_lazy_ibt_plt;
      non_lazy_ibt_plt = &elf_i386_non_lazy_ibt_plt;
      /* Fall through */
    case is_vxworks:
      lazy_plt = &elf_i386_lazy_plt;
      break;
    case is_nacl:
      lazy_plt = &elf_i386_nacl_plt;
      break;
    }

  got_addr = 0;

  count = 0;
  for (j = 0; plts[j].name != NULL; j++)
    {
      plt = bfd_get_section_by_name (abfd, plts[j].name);
      if (plt == NULL || plt->size == 0)
	continue;

      /* Get the PLT section contents.  */
      plt_contents = (bfd_byte *) bfd_malloc (plt->size);
      if (plt_contents == NULL)
	break;
      if (!bfd_get_section_contents (abfd, (asection *) plt,
				     plt_contents, 0, plt->size))
	{
	  free (plt_contents);
	  break;
	}

      /* Check what kind of PLT it is.  */
      plt_type = plt_unknown;
      if (plts[j].type == plt_unknown
	  && (plt->size >= (lazy_plt->plt0_entry_size
			    + lazy_plt->plt_entry_size)))
	{
	  /* Match lazy PLT first.  */
	  if (memcmp (plt_contents, lazy_plt->plt0_entry,
		      lazy_plt->plt0_got1_offset) == 0)
	    {
	      /* The fist entry in the lazy IBT PLT is the same as the
		 normal lazy PLT.  */
	      if (lazy_ibt_plt != NULL
		  && (memcmp (plt_contents + lazy_ibt_plt->plt0_entry_size,
			      lazy_ibt_plt->plt_entry,
			      lazy_ibt_plt->plt_got_offset) == 0))
		plt_type = plt_lazy | plt_second;
	      else
		plt_type = plt_lazy;
	    }
	  else if (memcmp (plt_contents, lazy_plt->pic_plt0_entry,
			   lazy_plt->plt0_got1_offset) == 0)
	    {
	      /* The fist entry in the PIC lazy IBT PLT is the same as
		 the normal PIC lazy PLT.  */
	      if (lazy_ibt_plt != NULL
		  && (memcmp (plt_contents + lazy_ibt_plt->plt0_entry_size,
			      lazy_ibt_plt->pic_plt_entry,
			      lazy_ibt_plt->plt_got_offset) == 0))
		plt_type = plt_lazy | plt_pic | plt_second;
	      else
		plt_type = plt_lazy | plt_pic;
	    }
	}

      if (non_lazy_plt != NULL
	  && (plt_type == plt_unknown || plt_type == plt_non_lazy)
	  && plt->size >= non_lazy_plt->plt_entry_size)
	{
	  /* Match non-lazy PLT.  */
	  if (memcmp (plt_contents, non_lazy_plt->plt_entry,
		      non_lazy_plt->plt_got_offset) == 0)
	    plt_type = plt_non_lazy;
	  else if (memcmp (plt_contents, non_lazy_plt->pic_plt_entry,
			   non_lazy_plt->plt_got_offset) == 0)
	    plt_type = plt_pic;
	}

      if ((non_lazy_ibt_plt != NULL)
	  && (plt_type == plt_unknown || plt_type == plt_second)
	  && plt->size >= non_lazy_ibt_plt->plt_entry_size)
	{
	  if (memcmp (plt_contents,
		      non_lazy_ibt_plt->plt_entry,
		      non_lazy_ibt_plt->plt_got_offset) == 0)
	    {
	      /* Match IBT PLT.  */
	      plt_type = plt_second;
	      non_lazy_plt = non_lazy_ibt_plt;
	    }
	  else if (memcmp (plt_contents,
			   non_lazy_ibt_plt->pic_plt_entry,
			   non_lazy_ibt_plt->plt_got_offset) == 0)
	    {
	      /* Match PIC IBT PLT.  */
	      plt_type = plt_second | plt_pic;
	      non_lazy_plt = non_lazy_ibt_plt;
	    }
	}

      if (plt_type == plt_unknown)
	continue;

      plts[j].sec = plt;
      plts[j].type = plt_type;

      if ((plt_type & plt_lazy))
	{
	  plts[j].plt_got_offset = lazy_plt->plt_got_offset;
	  plts[j].plt_entry_size = lazy_plt->plt_entry_size;
	  /* Skip PLT0 in lazy PLT.  */
	  i = 1;
	}
      else
	{
	  plts[j].plt_got_offset = non_lazy_plt->plt_got_offset;
	  plts[j].plt_entry_size = non_lazy_plt->plt_entry_size;
	  i = 0;
	}

      /* Skip lazy PLT when the second PLT is used.  */
      if ((plt_type & (plt_lazy | plt_second))
	  == (plt_lazy | plt_second))
	plts[j].count = 0;
      else
	{
	  n = plt->size / plts[j].plt_entry_size;
	  plts[j].count = n;
	  count += n - i;
	}

      plts[j].contents = plt_contents;

      /* The _GLOBAL_OFFSET_TABLE_ address is needed.  */
      if ((plt_type & plt_pic))
	got_addr = (bfd_vma) -1;
    }

  if (count == 0)
    return -1;

  size = count * sizeof (asymbol);
  s = *ret = (asymbol *) bfd_zmalloc (size);
  if (s == NULL)
    {
bad_return:
      for (j = 0; plts[j].name != NULL; j++)
	if (plts[j].contents != NULL)
	  free (plts[j].contents);
      free (dynrelbuf);
      return -1;
    }

  if (got_addr)
    {
      /* Check .got.plt and then .got to get the _GLOBAL_OFFSET_TABLE_
	 address.  */
      asection *sec = bfd_get_section_by_name (abfd, "".got.plt"");
      if (sec != NULL)
	got_addr = sec->vma;
      else
	{
	  sec = bfd_get_section_by_name (abfd, "".got"");
	  if (sec != NULL)
	    got_addr = sec->vma;
	}

      if (got_addr == (bfd_vma) -1)
	goto bad_return;
    }

  /* Check for each PLT section.  */
  size = 0;
  n = 0;
  for (j = 0; plts[j].name != NULL; j++)
    if ((plt_contents = plts[j].contents) != NULL)
      {
	long k;
	bfd_vma offset;

	plt_got_offset = plts[j].plt_got_offset;
	plt_entry_size = plts[j].plt_entry_size;

	plt = plts[j].sec;

	if ((plts[j].type & plt_lazy))
	  {
	    /* Skip PLT0 in lazy PLT.  */
	    k = 1;
	    offset = plt_entry_size;
	  }
	else
	  {
	    k = 0;
	    offset = 0;
	  }

	/* Check each PLT entry against dynamic relocations.  */
	for (; k < plts[j].count; k++)
	  {
	    int off;
	    bfd_vma got_vma;
	    long min, max, mid;
	    arelent *p;

	    /* Get the GOT offset, a signed 32-bit integer.  */
	    off = H_GET_32 (abfd, (plt_contents + offset
				   + plt_got_offset));
	    got_vma = got_addr + off;

	    /* Binary search.  */
	    p = dynrelbuf[0];
	    min = 0;
	    max = dynrelcount;
	    while ((min + 1) < max)
	      {
		arelent *r;

		mid = (min + max) / 2;
		r = dynrelbuf[mid];
		if (got_vma > r->address)
		  min = mid;
		else if (got_vma < r->address)
		  max = mid;
		else
		  {
		    p = r;
		    break;
		  }
	      }

	    /* Skip unknown relocation.  PR 17512: file: bc9d6cf5.  */
	    if (got_vma == p->address
		&& p->howto != NULL
		&& (p->howto->type == R_386_JUMP_SLOT
		    || p->howto->type == R_386_GLOB_DAT
		    || p->howto->type == R_386_IRELATIVE))
	      {
		*s = **p->sym_ptr_ptr;
		/* Undefined syms won't have BSF_LOCAL or BSF_GLOBAL
		   set.  Since we are defining a symbol, ensure one
		   of them is set.  */
		if ((s->flags & BSF_LOCAL) == 0)
		  s->flags |= BSF_GLOBAL;
		s->flags |= BSF_SYNTHETIC;
		/* This is no longer a section symbol.  */
		s->flags &= ~BSF_SECTION_SYM;
		s->section = plt;
		s->the_bfd = plt->owner;
		s->value = offset;
		/* Store relocation for later use.  */
		s->udata.p = p;
		/* Add @plt to function name later.  */
		size += strlen (s->name) + sizeof (""@plt"");
		if (p->addend != 0)
		  size += sizeof (""+0x"") - 1 + 8;
		n++;
		s++;
		/* There should be only one entry in PLT for a given
		   symbol.  Set howto to NULL after processing a PLT
		   entry to guard against corrupted PLT.  */
		p->howto = NULL;
	      }
	    offset += plt_entry_size;
	  }
      }

  /* PLT entries with R_386_TLS_DESC relocations are skipped.  */
  if (n == 0)
    goto bad_return;

  count = n;

  /* Allocate space for @plt suffixes.  */
  names = (char *) bfd_malloc (size);
  if (s == NULL)
    goto bad_return;

  s = *ret;
  for (i = 0; i < count; i++)
    {
      /* Add @plt to function name.  */
      arelent *p = (arelent *) s->udata.p;
      /* Clear it now.  */
      s->udata.p = NULL;
      size = strlen (s->name);
      memcpy (names, s->name, size);
      s->name = names;
      names += size;
      if (p->addend != 0)
	{
	  char buf[30], *a;

	  memcpy (names, ""+0x"", sizeof (""+0x"") - 1);
	  names += sizeof (""+0x"") - 1;
	  bfd_sprintf_vma (abfd, buf, p->addend);
	  for (a = buf; *a == '0'; ++a)
	    ;
	  size = strlen (a);
	  memcpy (names, a, size);
	  names += size;
	}
      memcpy (names, ""@plt"", sizeof (""@plt""));
      names += sizeof (""@plt"");
      s++;
    }

  for (j = 0; plts[j].name != NULL; j++)
    if (plts[j].contents != NULL)
      free (plts[j].contents);

  free (dynrelbuf);

  return count;
}","static long
elf_i386_get_synthetic_symtab (bfd *VAR_0,
			       long VAR_1 ATTRIBUTE_UNUSED,
			       asymbol **VAR_2 ATTRIBUTE_UNUSED,
			       long VAR_3,
			       asymbol **VAR_4,
			       asymbol **VAR_5)
{
  long VAR_6, VAR_7, VAR_8, VAR_9;
  int VAR_10;
  unsigned int VAR_11, VAR_12;
  asymbol *VAR_13;
  bfd_byte *VAR_14;
  long VAR_15, VAR_16;
  arelent **VAR_17;
  const struct elf_i386_lazy_plt_layout *VAR_18;
  const struct elf_i386_non_lazy_plt_layout *VAR_19;
  const struct elf_i386_lazy_plt_layout *VAR_20;
  const struct elf_i386_non_lazy_plt_layout *VAR_21;
  asection *VAR_22;
  bfd_vma VAR_23;
  char *VAR_24;
  enum elf_i386_plt_type VAR_25;
  struct elf_i386_plt VAR_26[] =
    {
      { "".plt"", NULL, NULL, VAR_27, 0, 0, 0 },
      { "".plt.got"", NULL, NULL, VAR_28, 0, 0, 0 },
      { "".plt.sec"", NULL, NULL, VAR_29, 0, 0, 0 },
      { NULL, NULL, NULL, VAR_28, 0, 0, 0 }
    };

  *VAR_5 = NULL;

  if ((VAR_0->flags & (VAR_30 | VAR_31)) == 0)
    return 0;

  if (VAR_3 <= 0)
    return 0;

  VAR_16 = bfd_get_dynamic_reloc_upper_bound (VAR_0);
  if (VAR_16 <= 0)
    return -1;

  VAR_17 = (arelent **) bfd_malloc (VAR_16);
  if (VAR_17 == NULL)
    return -1;

  VAR_15 = bfd_canonicalize_dynamic_reloc (VAR_0, VAR_17,
						VAR_4);
  if (VAR_15 <= 0)
    return -1;

  /* COMMENT_0 */
  qsort (VAR_17, VAR_15, sizeof (arelent *), VAR_32);

  VAR_19 = NULL;
  /* COMMENT_1 */
  VAR_18 = NULL;
  VAR_21 = NULL;
  VAR_20 = NULL;
  switch (get_elf_i386_backend_data (VAR_0)->os)
    {
    case VAR_33:
      VAR_19 = &VAR_34;
      VAR_20 = &VAR_35;
      VAR_21 = &VAR_36;
      /* COMMENT_2 */
    case VAR_37:
      VAR_18 = &VAR_38;
      break;
    case VAR_39:
      VAR_18 = &VAR_40;
      break;
    }

  VAR_23 = 0;

  VAR_7 = 0;
  for (VAR_10 = 0; VAR_26[VAR_10].name != NULL; VAR_10++)
    {
      VAR_22 = bfd_get_section_by_name (VAR_0, VAR_26[VAR_10].name);
      if (VAR_22 == NULL || VAR_22->size == 0)
	continue;

      /* COMMENT_3 */
      VAR_14 = (bfd_byte *) bfd_malloc (VAR_22->size);
      if (VAR_14 == NULL)
	break;
      if (!bfd_get_section_contents (VAR_0, (asection *) VAR_22,
				     VAR_14, 0, VAR_22->size))
	{
	  free (VAR_14);
	  break;
	}

      /* COMMENT_4 */
      VAR_25 = VAR_27;
      if (VAR_26[VAR_10].type == VAR_27
	  && (VAR_22->size >= (VAR_18->plt0_entry_size
			    + VAR_18->plt_entry_size)))
	{
	  /* COMMENT_5 */
	  if (memcmp (VAR_14, VAR_18->plt0_entry,
		      VAR_18->plt0_got1_offset) == 0)
	    {
	      /* COMMENT_6 */
                       
	      if (VAR_20 != NULL
		  && (memcmp (VAR_14 + VAR_20->plt0_entry_size,
			      VAR_20->plt_entry,
			      VAR_20->plt_got_offset) == 0))
		VAR_25 = VAR_41 | VAR_29;
	      else
		VAR_25 = VAR_41;
	    }
	  else if (memcmp (VAR_14, VAR_18->pic_plt0_entry,
			   VAR_18->plt0_got1_offset) == 0)
	    {
	      /* COMMENT_8 */
                               
	      if (VAR_20 != NULL
		  && (memcmp (VAR_14 + VAR_20->plt0_entry_size,
			      VAR_20->pic_plt_entry,
			      VAR_20->plt_got_offset) == 0))
		VAR_25 = VAR_41 | VAR_42 | VAR_29;
	      else
		VAR_25 = VAR_41 | VAR_42;
	    }
	}

      if (VAR_19 != NULL
	  && (VAR_25 == VAR_27 || VAR_25 == VAR_28)
	  && VAR_22->size >= VAR_19->plt_entry_size)
	{
	  /* COMMENT_10 */
	  if (memcmp (VAR_14, VAR_19->plt_entry,
		      VAR_19->plt_got_offset) == 0)
	    VAR_25 = VAR_28;
	  else if (memcmp (VAR_14, VAR_19->pic_plt_entry,
			   VAR_19->plt_got_offset) == 0)
	    VAR_25 = VAR_42;
	}

      if ((VAR_21 != NULL)
	  && (VAR_25 == VAR_27 || VAR_25 == VAR_29)
	  && VAR_22->size >= VAR_21->plt_entry_size)
	{
	  if (memcmp (VAR_14,
		      VAR_21->plt_entry,
		      VAR_21->plt_got_offset) == 0)
	    {
	      /* COMMENT_11 */
	      VAR_25 = VAR_29;
	      VAR_19 = VAR_21;
	    }
	  else if (memcmp (VAR_14,
			   VAR_21->pic_plt_entry,
			   VAR_21->plt_got_offset) == 0)
	    {
	      /* COMMENT_12 */
	      VAR_25 = VAR_29 | VAR_42;
	      VAR_19 = VAR_21;
	    }
	}

      if (VAR_25 == VAR_27)
	continue;

      VAR_26[VAR_10].sec = VAR_22;
      VAR_26[VAR_10].type = VAR_25;

      if ((VAR_25 & VAR_41))
	{
	  VAR_26[VAR_10].plt_got_offset = VAR_18->plt_got_offset;
	  VAR_26[VAR_10].plt_entry_size = VAR_18->plt_entry_size;
	  /* COMMENT_13 */
	  VAR_8 = 1;
	}
      else
	{
	  VAR_26[VAR_10].plt_got_offset = VAR_19->plt_got_offset;
	  VAR_26[VAR_10].plt_entry_size = VAR_19->plt_entry_size;
	  VAR_8 = 0;
	}

      /* COMMENT_14 */
      if ((VAR_25 & (VAR_41 | VAR_29))
	  == (VAR_41 | VAR_29))
	VAR_26[VAR_10].count = 0;
      else
	{
	  VAR_9 = VAR_22->size / VAR_26[VAR_10].plt_entry_size;
	  VAR_26[VAR_10].count = VAR_9;
	  VAR_7 += VAR_9 - VAR_8;
	}

      VAR_26[VAR_10].contents = VAR_14;

      /* COMMENT_15 */
      if ((VAR_25 & VAR_42))
	VAR_23 = (bfd_vma) -1;
    }

  if (VAR_7 == 0)
    return -1;

  VAR_6 = VAR_7 * sizeof (asymbol);
  VAR_13 = *VAR_5 = (asymbol *) bfd_zmalloc (VAR_6);
  if (VAR_13 == NULL)
    {
bad_return:
      for (VAR_10 = 0; VAR_26[VAR_10].name != NULL; VAR_10++)
	if (VAR_26[VAR_10].contents != NULL)
	  free (VAR_26[VAR_10].contents);
      free (VAR_17);
      return -1;
    }

  if (VAR_23)
    {
      /* COMMENT_16 */
              
      asection *VAR_43 = bfd_get_section_by_name (VAR_0, "".got.plt"");
      if (VAR_43 != NULL)
	VAR_23 = VAR_43->vma;
      else
	{
	  VAR_43 = bfd_get_section_by_name (VAR_0, "".got"");
	  if (VAR_43 != NULL)
	    VAR_23 = VAR_43->vma;
	}

      if (VAR_23 == (bfd_vma) -1)
	goto bad_return;
    }

  /* COMMENT_18 */
  VAR_6 = 0;
  VAR_9 = 0;
  for (VAR_10 = 0; VAR_26[VAR_10].name != NULL; VAR_10++)
    if ((VAR_14 = VAR_26[VAR_10].contents) != NULL)
      {
	long VAR_44;
	bfd_vma VAR_45;

	VAR_11 = VAR_26[VAR_10].plt_got_offset;
	VAR_12 = VAR_26[VAR_10].plt_entry_size;

	VAR_22 = VAR_26[VAR_10].sec;

	if ((VAR_26[VAR_10].type & VAR_41))
	  {
	    /* COMMENT_13 */
	    VAR_44 = 1;
	    VAR_45 = VAR_12;
	  }
	else
	  {
	    VAR_44 = 0;
	    VAR_45 = 0;
	  }

	/* COMMENT_19 */
	for (; VAR_44 < VAR_26[VAR_10].count; VAR_44++)
	  {
	    int VAR_46;
	    bfd_vma VAR_47;
	    long VAR_48, VAR_49, VAR_50;
	    arelent *VAR_51;

	    /* COMMENT_20 */
	    VAR_46 = H_GET_32 (VAR_0, (VAR_14 + VAR_45
				   + VAR_11));
	    VAR_47 = VAR_23 + VAR_46;

	    /* COMMENT_21 */
	    VAR_51 = VAR_17[0];
	    VAR_48 = 0;
	    VAR_49 = VAR_15;
	    while ((VAR_48 + 1) < VAR_49)
	      {
		arelent *VAR_52;

		VAR_50 = (VAR_48 + VAR_49) / 2;
		VAR_52 = VAR_17[VAR_50];
		if (VAR_47 > VAR_52->address)
		  VAR_48 = VAR_50;
		else if (VAR_47 < VAR_52->address)
		  VAR_49 = VAR_50;
		else
		  {
		    VAR_51 = VAR_52;
		    break;
		  }
	      }

	    /* COMMENT_22 */
	    if (VAR_47 == VAR_51->address
		&& VAR_51->howto != NULL
		&& (VAR_51->howto->type == VAR_53
		    || VAR_51->howto->type == VAR_54
		    || VAR_51->howto->type == VAR_55))
	      {
		*VAR_13 = **VAR_51->sym_ptr_ptr;
		/* COMMENT_23 */
                                                     
                        
		if ((VAR_13->flags & VAR_56) == 0)
		  VAR_13->flags |= VAR_57;
		VAR_13->flags |= VAR_58;
		/* COMMENT_26 */
		VAR_13->flags &= ~VAR_59;
		VAR_13->section = VAR_22;
		VAR_13->the_bfd = VAR_22->owner;
		VAR_13->value = VAR_45;
		/* COMMENT_27 */
		VAR_13->udata.p = VAR_51;
		/* COMMENT_28 */
		VAR_6 += strlen (VAR_13->name) + sizeof (""@plt"");
		if (VAR_51->addend != 0)
		  VAR_6 += sizeof (""+0x"") - 1 + 8;
		VAR_9++;
		VAR_13++;
		/* COMMENT_29 */
                                                      
                                              
		VAR_51->howto = NULL;
	      }
	    VAR_45 += VAR_12;
	  }
      }

  /* COMMENT_32 */
  if (VAR_9 == 0)
    goto bad_return;

  VAR_7 = VAR_9;

  /* COMMENT_33 */
  VAR_24 = (char *) bfd_malloc (VAR_6);
  if (VAR_13 == NULL)
    goto bad_return;

  VAR_13 = *VAR_5;
  for (VAR_8 = 0; VAR_8 < VAR_7; VAR_8++)
    {
      /* COMMENT_34 */
      arelent *VAR_51 = (arelent *) VAR_13->udata.p;
      /* COMMENT_35 */
      VAR_13->udata.p = NULL;
      VAR_6 = strlen (VAR_13->name);
      memcpy (VAR_24, VAR_13->name, VAR_6);
      VAR_13->name = VAR_24;
      VAR_24 += VAR_6;
      if (VAR_51->addend != 0)
	{
	  char VAR_60[30], *VAR_61;

	  memcpy (VAR_24, ""+0x"", sizeof (""+0x"") - 1);
	  VAR_24 += sizeof (""+0x"") - 1;
	  bfd_sprintf_vma (VAR_0, VAR_60, VAR_51->addend);
	  for (VAR_61 = VAR_60; *VAR_61 == '0'; ++VAR_61)
	    ;
	  VAR_6 = strlen (VAR_61);
	  memcpy (VAR_24, VAR_61, VAR_6);
	  VAR_24 += VAR_6;
	}
      memcpy (VAR_24, ""@plt"", sizeof (""@plt""));
      VAR_24 += sizeof (""@plt"");
      VAR_13++;
    }

  for (VAR_10 = 0; VAR_26[VAR_10].name != NULL; VAR_10++)
    if (VAR_26[VAR_10].contents != NULL)
      free (VAR_26[VAR_10].contents);

  free (VAR_17);

  return VAR_7;
}",,"--- func_before
+++ func_after
@@ -321,6 +321,10 @@
 		  size += sizeof (""+0x"") - 1 + 8;
 		n++;
 		s++;
+		/* There should be only one entry in PLT for a given
+		   symbol.  Set howto to NULL after processing a PLT
+		   entry to guard against corrupted PLT.  */
+		p->howto = NULL;
 	      }
 	    offset += plt_entry_size;
 	  }","{'deleted_lines': [], 'added_lines': ['\t\t/* There should be only one entry in PLT for a given', '\t\t   symbol.  Set howto to NULL after processing a PLT', '\t\t   entry to guard against corrupted PLT.  */', '\t\tp->howto = NULL;']}",True,"The *_get_synthetic_symtab functions in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, do not ensure a unique PLT entry for a symbol, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted ELF file, related to elf32-i386.c and elf64-x86-64.c.",7.8,HIGH,2,test,,5
CVE-2017-14729,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,binutils-gdb,"
x86: Guard against corrupted PLT

There should be only one entry in PLT for a given symbol.  Set howto to
NULL after processing a PLT entry to guard against corrupted PLT so that
the duplicated PLT entries are skipped.

	PR binutils/22170
	 * elf32-i386.c (elf_i386_get_synthetic_symtab): Guard against
	 corrupted PLT.
	 * elf64-x86-64.c (elf_x86_64_get_synthetic_symtab): Likewise.

(cherry picked from commit 61e3bf5f83f7e505b6bc51ef65426e5b31e6e360)
",56933f9e3e90eebf1018ed7417d6c1184b91db6b,https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=56933f9e3e90eebf1018ed7417d6c1184b91db6b,bfd/elf64-x86-64.c,elf_x86_64_get_synthetic_symtab,"static long
elf_x86_64_get_synthetic_symtab (bfd *abfd,
long symcount ATTRIBUTE_UNUSED,
asymbol **syms ATTRIBUTE_UNUSED,
long dynsymcount,
asymbol **dynsyms,
asymbol **ret)
{
long size, count, i, n;
int j;
unsigned int plt_got_offset, plt_entry_size, plt_got_insn_size;
asymbol *s;
bfd_byte *plt_contents;
long dynrelcount, relsize;
arelent **dynrelbuf;
const struct elf_x86_64_lazy_plt_layout *lazy_plt;
const struct elf_x86_64_non_lazy_plt_layout *non_lazy_plt;
const struct elf_x86_64_lazy_plt_layout *lazy_bnd_plt;
const struct elf_x86_64_non_lazy_plt_layout *non_lazy_bnd_plt;
const struct elf_x86_64_lazy_plt_layout *lazy_ibt_plt;
const struct elf_x86_64_non_lazy_plt_layout *non_lazy_ibt_plt;
asection *plt;
char *names;
enum elf_x86_64_plt_type plt_type;
struct elf_x86_64_plt plts[] =
{
{ "".plt"", NULL, NULL, plt_unknown, 0, 0, 0, 0 },
{ "".plt.got"", NULL, NULL, plt_non_lazy, 0, 0, 0, 0 },
{ "".plt.sec"", NULL, NULL, plt_second, 0, 0, 0, 0 },
{ "".plt.bnd"", NULL, NULL, plt_second, 0, 0, 0, 0 },
{ NULL, NULL, NULL, plt_non_lazy, 0, 0, 0, 0 }
};
*ret = NULL;
if ((abfd->flags & (DYNAMIC | EXEC_P)) == 0)
return 0;
if (dynsymcount <= 0)
return 0;
relsize = bfd_get_dynamic_reloc_upper_bound (abfd);
if (relsize <= 0)
return -1;
dynrelbuf = (arelent **) bfd_malloc (relsize);
if (dynrelbuf == NULL)
return -1;
dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf,
dynsyms);
if (dynrelcount <= 0)
return -1;
qsort (dynrelbuf, dynrelcount, sizeof (arelent *), compare_relocs);
if (get_elf_x86_64_backend_data (abfd)->os == is_normal)
{
lazy_plt = &elf_x86_64_lazy_plt;
non_lazy_plt = &elf_x86_64_non_lazy_plt;
lazy_bnd_plt = &elf_x86_64_lazy_bnd_plt;
non_lazy_bnd_plt = &elf_x86_64_non_lazy_bnd_plt;
if (ABI_64_P (abfd))
{
lazy_ibt_plt = &elf_x86_64_lazy_ibt_plt;
non_lazy_ibt_plt = &elf_x86_64_non_lazy_ibt_plt;
}
else
{
lazy_ibt_plt = &elf_x32_lazy_ibt_plt;
non_lazy_ibt_plt = &elf_x32_non_lazy_ibt_plt;
}
}
else
{
lazy_plt = &elf_x86_64_nacl_plt;
non_lazy_plt = NULL;
lazy_bnd_plt = NULL;
non_lazy_bnd_plt = NULL;
lazy_ibt_plt = NULL;
non_lazy_ibt_plt = NULL;
}
count = 0;
for (j = 0; plts[j].name != NULL; j++)
{
plt = bfd_get_section_by_name (abfd, plts[j].name);
if (plt == NULL || plt->size == 0)
continue;
plt_contents = (bfd_byte *) bfd_malloc (plt->size);
if (plt_contents == NULL)
break;
if (!bfd_get_section_contents (abfd, (asection *) plt,
plt_contents, 0, plt->size))
{
free (plt_contents);
break;
}
plt_type = plt_unknown;
if (plts[j].type == plt_unknown
&& (plt->size >= (lazy_plt->plt_entry_size
+ lazy_plt->plt_entry_size)))
{
if ((memcmp (plt_contents, lazy_plt->plt0_entry,
lazy_plt->plt0_got1_offset) == 0)
&& (memcmp (plt_contents + 6, lazy_plt->plt0_entry + 6,
2) == 0))
plt_type = plt_lazy;
else if (lazy_bnd_plt != NULL
&& (memcmp (plt_contents, lazy_bnd_plt->plt0_entry,
lazy_bnd_plt->plt0_got1_offset) == 0)
&& (memcmp (plt_contents + 6,
lazy_bnd_plt->plt0_entry + 6, 3) == 0))
{
plt_type = plt_lazy | plt_second;
if ((memcmp (plt_contents + lazy_ibt_plt->plt_entry_size,
lazy_ibt_plt->plt_entry,
lazy_ibt_plt->plt_got_offset) == 0))
lazy_plt = lazy_ibt_plt;
else
lazy_plt = lazy_bnd_plt;
}
}
if (non_lazy_plt != NULL
&& (plt_type == plt_unknown || plt_type == plt_non_lazy)
&& plt->size >= non_lazy_plt->plt_entry_size)
{
if (memcmp (plt_contents, non_lazy_plt->plt_entry,
non_lazy_plt->plt_got_offset) == 0)
plt_type = plt_non_lazy;
}
if (plt_type == plt_unknown || plt_type == plt_second)
{
if (non_lazy_bnd_plt != NULL
&& plt->size >= non_lazy_bnd_plt->plt_entry_size
&& (memcmp (plt_contents, non_lazy_bnd_plt->plt_entry,
non_lazy_bnd_plt->plt_got_offset) == 0))
{
plt_type = plt_second;
non_lazy_plt = non_lazy_bnd_plt;
}
else if (non_lazy_ibt_plt != NULL
&& plt->size >= non_lazy_ibt_plt->plt_entry_size
&& (memcmp (plt_contents,
non_lazy_ibt_plt->plt_entry,
non_lazy_ibt_plt->plt_got_offset) == 0))
{
plt_type = plt_second;
non_lazy_plt = non_lazy_ibt_plt;
}
}
if (plt_type == plt_unknown)
continue;
plts[j].sec = plt;
plts[j].type = plt_type;
if ((plt_type & plt_lazy))
{
plts[j].plt_got_offset = lazy_plt->plt_got_offset;
plts[j].plt_got_insn_size = lazy_plt->plt_got_insn_size;
plts[j].plt_entry_size = lazy_plt->plt_entry_size;
i = 1;
}
else
{
plts[j].plt_got_offset = non_lazy_plt->plt_got_offset;
plts[j].plt_got_insn_size = non_lazy_plt->plt_got_insn_size;
plts[j].plt_entry_size = non_lazy_plt->plt_entry_size;
i = 0;
}
if (plt_type == (plt_lazy | plt_second))
plts[j].count = 0;
else
{
n = plt->size / plts[j].plt_entry_size;
plts[j].count = n;
count += n - i;
}
plts[j].contents = plt_contents;
}
if (count == 0)
return -1;
size = count * sizeof (asymbol);
s = *ret = (asymbol *) bfd_zmalloc (size);
if (s == NULL)
{
bad_return:
for (j = 0; plts[j].name != NULL; j++)
if (plts[j].contents != NULL)
free (plts[j].contents);
free (dynrelbuf);
return -1;
}
size = 0;
n = 0;
for (j = 0; plts[j].name != NULL; j++)
if ((plt_contents = plts[j].contents) != NULL)
{
long k;
bfd_vma offset;
plt_got_offset = plts[j].plt_got_offset;
plt_got_insn_size = plts[j].plt_got_insn_size;
plt_entry_size = plts[j].plt_entry_size;
plt = plts[j].sec;
if ((plts[j].type & plt_lazy))
{
k = 1;
offset = plt_entry_size;
}
else
{
k = 0;
offset = 0;
}
for (; k < plts[j].count; k++)
{
int off;
bfd_vma got_vma;
long min, max, mid;
arelent *p;
off = H_GET_32 (abfd, (plt_contents + offset
+ plt_got_offset));
got_vma = plt->vma + offset + off + plt_got_insn_size;
p = dynrelbuf[0];
min = 0;
max = dynrelcount;
while ((min + 1) < max)
{
arelent *r;
mid = (min + max) / 2;
r = dynrelbuf[mid];
if (got_vma > r->address)
min = mid;
else if (got_vma < r->address)
max = mid;
else
{
p = r;
break;
}
}
if (got_vma == p->address
&& p->howto != NULL
&& (p->howto->type == R_X86_64_JUMP_SLOT
|| p->howto->type == R_X86_64_GLOB_DAT
|| p->howto->type == R_X86_64_IRELATIVE))
{
*s = **p->sym_ptr_ptr;
if ((s->flags & BSF_LOCAL) == 0)
s->flags |= BSF_GLOBAL;
s->flags |= BSF_SYNTHETIC;
s->flags &= ~BSF_SECTION_SYM;
s->section = plt;
s->the_bfd = plt->owner;
s->value = offset;
s->udata.p = p;
size += strlen (s->name) + sizeof (""@plt"");
if (p->addend != 0)
size += sizeof (""+0x"") - 1 + 8 + 8 * ABI_64_P (abfd);
n++;
s++;
}
offset += plt_entry_size;
}
}
if (n == 0)
goto bad_return;
count = n;
names = (char *) bfd_malloc (size);
if (s == NULL)
goto bad_return;
s = *ret;
for (i = 0; i < count; i++)
{
arelent *p = (arelent *) s->udata.p;
s->udata.p = NULL;
size = strlen (s->name);
memcpy (names, s->name, size);
s->name = names;
names += size;
if (p->addend != 0)
{
char buf[30], *a;
memcpy (names, ""+0x"", sizeof (""+0x"") - 1);
names += sizeof (""+0x"") - 1;
bfd_sprintf_vma (abfd, buf, p->addend);
for (a = buf; *a == '0'; ++a)
;
size = strlen (a);
memcpy (names, a, size);
names += size;
}
memcpy (names, ""@plt"", sizeof (""@plt""));
names += sizeof (""@plt"");
s++;
}
for (j = 0; plts[j].name != NULL; j++)
if (plts[j].contents != NULL)
free (plts[j].contents);
free (dynrelbuf);
return count;
}","static long
elf_x86_64_get_synthetic_symtab (bfd *VAR_0,
long VAR_1 ATTRIBUTE_UNUSED,
asymbol **VAR_2 ATTRIBUTE_UNUSED,
long VAR_3,
asymbol **VAR_4,
asymbol **VAR_5)
{
long VAR_6, VAR_7, VAR_8, VAR_9;
int VAR_10;
unsigned int VAR_11, VAR_12, VAR_13;
asymbol *VAR_14;
bfd_byte *VAR_15;
long VAR_16, VAR_17;
arelent **VAR_18;
const struct elf_x86_64_lazy_plt_layout *VAR_19;
const struct elf_x86_64_non_lazy_plt_layout *VAR_20;
const struct elf_x86_64_lazy_plt_layout *VAR_21;
const struct elf_x86_64_non_lazy_plt_layout *VAR_22;
const struct elf_x86_64_lazy_plt_layout *VAR_23;
const struct elf_x86_64_non_lazy_plt_layout *VAR_24;
asection *VAR_25;
char *VAR_26;
enum elf_x86_64_plt_type VAR_27;
struct elf_x86_64_plt VAR_28[] =
{
{ "".plt"", NULL, NULL, VAR_29, 0, 0, 0, 0 },
{ "".plt.got"", NULL, NULL, VAR_30, 0, 0, 0, 0 },
{ "".plt.sec"", NULL, NULL, VAR_31, 0, 0, 0, 0 },
{ "".plt.bnd"", NULL, NULL, VAR_31, 0, 0, 0, 0 },
{ NULL, NULL, NULL, VAR_30, 0, 0, 0, 0 }
};
*VAR_5 = NULL;
if ((VAR_0->flags & (VAR_32 | VAR_33)) == 0)
return 0;
if (VAR_3 <= 0)
return 0;
VAR_17 = bfd_get_dynamic_reloc_upper_bound (VAR_0);
if (VAR_17 <= 0)
return -1;
VAR_18 = (arelent **) bfd_malloc (VAR_17);
if (VAR_18 == NULL)
return -1;
VAR_16 = bfd_canonicalize_dynamic_reloc (VAR_0, VAR_18,
VAR_4);
if (VAR_16 <= 0)
return -1;
qsort (VAR_18, VAR_16, sizeof (arelent *), VAR_34);
if (get_elf_x86_64_backend_data (VAR_0)->os == VAR_35)
{
VAR_19 = &VAR_36;
VAR_20 = &VAR_37;
VAR_21 = &VAR_38;
VAR_22 = &VAR_39;
if (ABI_64_P (VAR_0))
{
VAR_23 = &VAR_40;
VAR_24 = &VAR_41;
}
else
{
VAR_23 = &VAR_42;
VAR_24 = &VAR_43;
}
}
else
{
VAR_19 = &VAR_44;
VAR_20 = NULL;
VAR_21 = NULL;
VAR_22 = NULL;
VAR_23 = NULL;
VAR_24 = NULL;
}
VAR_7 = 0;
for (VAR_10 = 0; VAR_28[VAR_10].name != NULL; VAR_10++)
{
VAR_25 = bfd_get_section_by_name (VAR_0, VAR_28[VAR_10].name);
if (VAR_25 == NULL || VAR_25->size == 0)
continue;
VAR_15 = (bfd_byte *) bfd_malloc (VAR_25->size);
if (VAR_15 == NULL)
break;
if (!bfd_get_section_contents (VAR_0, (asection *) VAR_25,
VAR_15, 0, VAR_25->size))
{
free (VAR_15);
break;
}
VAR_27 = VAR_29;
if (VAR_28[VAR_10].type == VAR_29
&& (VAR_25->size >= (VAR_19->plt_entry_size
+ VAR_19->plt_entry_size)))
{
if ((memcmp (VAR_15, VAR_19->plt0_entry,
VAR_19->plt0_got1_offset) == 0)
&& (memcmp (VAR_15 + 6, VAR_19->plt0_entry + 6,
2) == 0))
VAR_27 = VAR_45;
else if (VAR_21 != NULL
&& (memcmp (VAR_15, VAR_21->plt0_entry,
VAR_21->plt0_got1_offset) == 0)
&& (memcmp (VAR_15 + 6,
VAR_21->plt0_entry + 6, 3) == 0))
{
VAR_27 = VAR_45 | VAR_31;
if ((memcmp (VAR_15 + VAR_23->plt_entry_size,
VAR_23->plt_entry,
VAR_23->plt_got_offset) == 0))
VAR_19 = VAR_23;
else
VAR_19 = VAR_21;
}
}
if (VAR_20 != NULL
&& (VAR_27 == VAR_29 || VAR_27 == VAR_30)
&& VAR_25->size >= VAR_20->plt_entry_size)
{
if (memcmp (VAR_15, VAR_20->plt_entry,
VAR_20->plt_got_offset) == 0)
VAR_27 = VAR_30;
}
if (VAR_27 == VAR_29 || VAR_27 == VAR_31)
{
if (VAR_22 != NULL
&& VAR_25->size >= VAR_22->plt_entry_size
&& (memcmp (VAR_15, VAR_22->plt_entry,
VAR_22->plt_got_offset) == 0))
{
VAR_27 = VAR_31;
VAR_20 = VAR_22;
}
else if (VAR_24 != NULL
&& VAR_25->size >= VAR_24->plt_entry_size
&& (memcmp (VAR_15,
VAR_24->plt_entry,
VAR_24->plt_got_offset) == 0))
{
VAR_27 = VAR_31;
VAR_20 = VAR_24;
}
}
if (VAR_27 == VAR_29)
continue;
VAR_28[VAR_10].sec = VAR_25;
VAR_28[VAR_10].type = VAR_27;
if ((VAR_27 & VAR_45))
{
VAR_28[VAR_10].plt_got_offset = VAR_19->plt_got_offset;
VAR_28[VAR_10].plt_got_insn_size = VAR_19->plt_got_insn_size;
VAR_28[VAR_10].plt_entry_size = VAR_19->plt_entry_size;
VAR_8 = 1;
}
else
{
VAR_28[VAR_10].plt_got_offset = VAR_20->plt_got_offset;
VAR_28[VAR_10].plt_got_insn_size = VAR_20->plt_got_insn_size;
VAR_28[VAR_10].plt_entry_size = VAR_20->plt_entry_size;
VAR_8 = 0;
}
if (VAR_27 == (VAR_45 | VAR_31))
VAR_28[VAR_10].count = 0;
else
{
VAR_9 = VAR_25->size / VAR_28[VAR_10].plt_entry_size;
VAR_28[VAR_10].count = VAR_9;
VAR_7 += VAR_9 - VAR_8;
}
VAR_28[VAR_10].contents = VAR_15;
}
if (VAR_7 == 0)
return -1;
VAR_6 = VAR_7 * sizeof (asymbol);
VAR_14 = *VAR_5 = (asymbol *) bfd_zmalloc (VAR_6);
if (VAR_14 == NULL)
{
bad_return:
for (VAR_10 = 0; VAR_28[VAR_10].name != NULL; VAR_10++)
if (VAR_28[VAR_10].contents != NULL)
free (VAR_28[VAR_10].contents);
free (VAR_18);
return -1;
}
VAR_6 = 0;
VAR_9 = 0;
for (VAR_10 = 0; VAR_28[VAR_10].name != NULL; VAR_10++)
if ((VAR_15 = VAR_28[VAR_10].contents) != NULL)
{
long VAR_46;
bfd_vma VAR_47;
VAR_11 = VAR_28[VAR_10].plt_got_offset;
VAR_13 = VAR_28[VAR_10].plt_got_insn_size;
VAR_12 = VAR_28[VAR_10].plt_entry_size;
VAR_25 = VAR_28[VAR_10].sec;
if ((VAR_28[VAR_10].type & VAR_45))
{
VAR_46 = 1;
VAR_47 = VAR_12;
}
else
{
VAR_46 = 0;
VAR_47 = 0;
}
for (; VAR_46 < VAR_28[VAR_10].count; VAR_46++)
{
int VAR_48;
bfd_vma VAR_49;
long VAR_50, VAR_51, VAR_52;
arelent *VAR_53;
VAR_48 = H_GET_32 (VAR_0, (VAR_15 + VAR_47
+ VAR_11));
VAR_49 = VAR_25->vma + VAR_47 + VAR_48 + VAR_13;
VAR_53 = VAR_18[0];
VAR_50 = 0;
VAR_51 = VAR_16;
while ((VAR_50 + 1) < VAR_51)
{
arelent *VAR_54;
VAR_52 = (VAR_50 + VAR_51) / 2;
VAR_54 = VAR_18[VAR_52];
if (VAR_49 > VAR_54->address)
VAR_50 = VAR_52;
else if (VAR_49 < VAR_54->address)
VAR_51 = VAR_52;
else
{
VAR_53 = VAR_54;
break;
}
}
if (VAR_49 == VAR_53->address
&& VAR_53->howto != NULL
&& (VAR_53->howto->type == VAR_55
|| VAR_53->howto->type == VAR_56
|| VAR_53->howto->type == VAR_57))
{
*VAR_14 = **VAR_53->sym_ptr_ptr;
if ((VAR_14->flags & VAR_58) == 0)
VAR_14->flags |= VAR_59;
VAR_14->flags |= VAR_60;
VAR_14->flags &= ~VAR_61;
VAR_14->section = VAR_25;
VAR_14->the_bfd = VAR_25->owner;
VAR_14->value = VAR_47;
VAR_14->udata.p = VAR_53;
VAR_6 += strlen (VAR_14->name) + sizeof (""@plt"");
if (VAR_53->addend != 0)
VAR_6 += sizeof (""+0x"") - 1 + 8 + 8 * ABI_64_P (VAR_0);
VAR_9++;
VAR_14++;
}
VAR_47 += VAR_12;
}
}
if (VAR_9 == 0)
goto bad_return;
VAR_7 = VAR_9;
VAR_26 = (char *) bfd_malloc (VAR_6);
if (VAR_14 == NULL)
goto bad_return;
VAR_14 = *VAR_5;
for (VAR_8 = 0; VAR_8 < VAR_7; VAR_8++)
{
arelent *VAR_53 = (arelent *) VAR_14->udata.p;
VAR_14->udata.p = NULL;
VAR_6 = strlen (VAR_14->name);
memcpy (VAR_26, VAR_14->name, VAR_6);
VAR_14->name = VAR_26;
VAR_26 += VAR_6;
if (VAR_53->addend != 0)
{
char VAR_62[30], *VAR_63;
memcpy (VAR_26, ""+0x"", sizeof (""+0x"") - 1);
VAR_26 += sizeof (""+0x"") - 1;
bfd_sprintf_vma (VAR_0, VAR_62, VAR_53->addend);
for (VAR_63 = VAR_62; *VAR_63 == '0'; ++VAR_63)
;
VAR_6 = strlen (VAR_63);
memcpy (VAR_26, VAR_63, VAR_6);
VAR_26 += VAR_6;
}
memcpy (VAR_26, ""@plt"", sizeof (""@plt""));
VAR_26 += sizeof (""@plt"");
VAR_14++;
}
for (VAR_10 = 0; VAR_28[VAR_10].name != NULL; VAR_10++)
if (VAR_28[VAR_10].contents != NULL)
free (VAR_28[VAR_10].contents);
free (VAR_18);
return VAR_7;
}",,"static long
elf_x86_64_get_synthetic_symtab (bfd *abfd,
				 long symcount ATTRIBUTE_UNUSED,
				 asymbol **syms ATTRIBUTE_UNUSED,
				 long dynsymcount,
				 asymbol **dynsyms,
				 asymbol **ret)
{
  long size, count, i, n;
  int j;
  unsigned int plt_got_offset, plt_entry_size, plt_got_insn_size;
  asymbol *s;
  bfd_byte *plt_contents;
  long dynrelcount, relsize;
  arelent **dynrelbuf;
  const struct elf_x86_64_lazy_plt_layout *lazy_plt;
  const struct elf_x86_64_non_lazy_plt_layout *non_lazy_plt;
  const struct elf_x86_64_lazy_plt_layout *lazy_bnd_plt;
  const struct elf_x86_64_non_lazy_plt_layout *non_lazy_bnd_plt;
  const struct elf_x86_64_lazy_plt_layout *lazy_ibt_plt;
  const struct elf_x86_64_non_lazy_plt_layout *non_lazy_ibt_plt;
  asection *plt;
  char *names;
  enum elf_x86_64_plt_type plt_type;
  struct elf_x86_64_plt plts[] =
    {
      { "".plt"", NULL, NULL, plt_unknown, 0, 0, 0, 0 },
      { "".plt.got"", NULL, NULL, plt_non_lazy, 0, 0, 0, 0 },
      { "".plt.sec"", NULL, NULL, plt_second, 0, 0, 0, 0 },
      { "".plt.bnd"", NULL, NULL, plt_second, 0, 0, 0, 0 },
      { NULL, NULL, NULL, plt_non_lazy, 0, 0, 0, 0 }
    };

  *ret = NULL;

  if ((abfd->flags & (DYNAMIC | EXEC_P)) == 0)
    return 0;

  if (dynsymcount <= 0)
    return 0;

  relsize = bfd_get_dynamic_reloc_upper_bound (abfd);
  if (relsize <= 0)
    return -1;

  dynrelbuf = (arelent **) bfd_malloc (relsize);
  if (dynrelbuf == NULL)
    return -1;

  dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf,
						dynsyms);
  if (dynrelcount <= 0)
    return -1;

  /* Sort the relocs by address.  */
  qsort (dynrelbuf, dynrelcount, sizeof (arelent *), compare_relocs);

  if (get_elf_x86_64_backend_data (abfd)->os == is_normal)
    {
      lazy_plt = &elf_x86_64_lazy_plt;
      non_lazy_plt = &elf_x86_64_non_lazy_plt;
      lazy_bnd_plt = &elf_x86_64_lazy_bnd_plt;
      non_lazy_bnd_plt = &elf_x86_64_non_lazy_bnd_plt;
      if (ABI_64_P (abfd))
	{
	  lazy_ibt_plt = &elf_x86_64_lazy_ibt_plt;
	  non_lazy_ibt_plt = &elf_x86_64_non_lazy_ibt_plt;
	}
      else
	{
	  lazy_ibt_plt = &elf_x32_lazy_ibt_plt;
	  non_lazy_ibt_plt = &elf_x32_non_lazy_ibt_plt;
	}
    }
  else
    {
      lazy_plt = &elf_x86_64_nacl_plt;
      non_lazy_plt = NULL;
      lazy_bnd_plt = NULL;
      non_lazy_bnd_plt = NULL;
      lazy_ibt_plt = NULL;
      non_lazy_ibt_plt = NULL;
    }

  count = 0;
  for (j = 0; plts[j].name != NULL; j++)
    {
      plt = bfd_get_section_by_name (abfd, plts[j].name);
      if (plt == NULL || plt->size == 0)
	continue;

      /* Get the PLT section contents.  */
      plt_contents = (bfd_byte *) bfd_malloc (plt->size);
      if (plt_contents == NULL)
	break;
      if (!bfd_get_section_contents (abfd, (asection *) plt,
				     plt_contents, 0, plt->size))
	{
	  free (plt_contents);
	  break;
	}

      /* Check what kind of PLT it is.  */
      plt_type = plt_unknown;
      if (plts[j].type == plt_unknown
	  && (plt->size >= (lazy_plt->plt_entry_size
			    + lazy_plt->plt_entry_size)))
	{
	  /* Match lazy PLT first.  Need to check the first two
	     instructions.   */
	  if ((memcmp (plt_contents, lazy_plt->plt0_entry,
		       lazy_plt->plt0_got1_offset) == 0)
	      && (memcmp (plt_contents + 6, lazy_plt->plt0_entry + 6,
			  2) == 0))
	    plt_type = plt_lazy;
	  else if (lazy_bnd_plt != NULL
		   && (memcmp (plt_contents, lazy_bnd_plt->plt0_entry,
			       lazy_bnd_plt->plt0_got1_offset) == 0)
		   && (memcmp (plt_contents + 6,
			       lazy_bnd_plt->plt0_entry + 6, 3) == 0))
	    {
	      plt_type = plt_lazy | plt_second;
	      /* The fist entry in the lazy IBT PLT is the same as the
		 lazy BND PLT.  */
	      if ((memcmp (plt_contents + lazy_ibt_plt->plt_entry_size,
			   lazy_ibt_plt->plt_entry,
			   lazy_ibt_plt->plt_got_offset) == 0))
		lazy_plt = lazy_ibt_plt;
	      else
		lazy_plt = lazy_bnd_plt;
	    }
	}

      if (non_lazy_plt != NULL
	  && (plt_type == plt_unknown || plt_type == plt_non_lazy)
	  && plt->size >= non_lazy_plt->plt_entry_size)
	{
	  /* Match non-lazy PLT.  */
	  if (memcmp (plt_contents, non_lazy_plt->plt_entry,
		      non_lazy_plt->plt_got_offset) == 0)
	    plt_type = plt_non_lazy;
	}

      if (plt_type == plt_unknown || plt_type == plt_second)
	{
	  if (non_lazy_bnd_plt != NULL
	      && plt->size >= non_lazy_bnd_plt->plt_entry_size
	      && (memcmp (plt_contents, non_lazy_bnd_plt->plt_entry,
			  non_lazy_bnd_plt->plt_got_offset) == 0))
	    {
	      /* Match BND PLT.  */
	      plt_type = plt_second;
	      non_lazy_plt = non_lazy_bnd_plt;
	    }
	  else if (non_lazy_ibt_plt != NULL
		   && plt->size >= non_lazy_ibt_plt->plt_entry_size
		   && (memcmp (plt_contents,
			       non_lazy_ibt_plt->plt_entry,
			       non_lazy_ibt_plt->plt_got_offset) == 0))
	    {
	      /* Match IBT PLT.  */
	      plt_type = plt_second;
	      non_lazy_plt = non_lazy_ibt_plt;
	    }
	}

      if (plt_type == plt_unknown)
	continue;

      plts[j].sec = plt;
      plts[j].type = plt_type;

      if ((plt_type & plt_lazy))
	{
	  plts[j].plt_got_offset = lazy_plt->plt_got_offset;
	  plts[j].plt_got_insn_size = lazy_plt->plt_got_insn_size;
	  plts[j].plt_entry_size = lazy_plt->plt_entry_size;
	  /* Skip PLT0 in lazy PLT.  */
	  i = 1;
	}
      else
	{
	  plts[j].plt_got_offset = non_lazy_plt->plt_got_offset;
	  plts[j].plt_got_insn_size = non_lazy_plt->plt_got_insn_size;
	  plts[j].plt_entry_size = non_lazy_plt->plt_entry_size;
	  i = 0;
	}

      /* Skip lazy PLT when the second PLT is used.  */
      if (plt_type == (plt_lazy | plt_second))
	plts[j].count = 0;
      else
	{
	  n = plt->size / plts[j].plt_entry_size;
	  plts[j].count = n;
	  count += n - i;
	}

      plts[j].contents = plt_contents;
    }

  if (count == 0)
    return -1;

  size = count * sizeof (asymbol);
  s = *ret = (asymbol *) bfd_zmalloc (size);
  if (s == NULL)
    {
bad_return:
      for (j = 0; plts[j].name != NULL; j++)
	if (plts[j].contents != NULL)
	  free (plts[j].contents);
      free (dynrelbuf);
      return -1;
    }

  /* Check for each PLT section.  */
  size = 0;
  n = 0;
  for (j = 0; plts[j].name != NULL; j++)
    if ((plt_contents = plts[j].contents) != NULL)
      {
	long k;
	bfd_vma offset;

	plt_got_offset = plts[j].plt_got_offset;
	plt_got_insn_size = plts[j].plt_got_insn_size;
	plt_entry_size = plts[j].plt_entry_size;

	plt = plts[j].sec;

	if ((plts[j].type & plt_lazy))
	  {
	    /* Skip PLT0 in lazy PLT.  */
	    k = 1;
	    offset = plt_entry_size;
	  }
	else
	  {
	    k = 0;
	    offset = 0;
	  }

	/* Check each PLT entry against dynamic relocations.  */
	for (; k < plts[j].count; k++)
	  {
	    int off;
	    bfd_vma got_vma;
	    long min, max, mid;
	    arelent *p;

	    /* Get the PC-relative offset, a signed 32-bit integer.  */
	    off = H_GET_32 (abfd, (plt_contents + offset
				   + plt_got_offset));
	    got_vma = plt->vma + offset + off + plt_got_insn_size;

	    /* Binary search.  */
	    p = dynrelbuf[0];
	    min = 0;
	    max = dynrelcount;
	    while ((min + 1) < max)
	      {
		arelent *r;

		mid = (min + max) / 2;
		r = dynrelbuf[mid];
		if (got_vma > r->address)
		  min = mid;
		else if (got_vma < r->address)
		  max = mid;
		else
		  {
		    p = r;
		    break;
		  }
	      }

	    /* Skip unknown relocation.  PR 17512: file: bc9d6cf5.  */
	    if (got_vma == p->address
		&& p->howto != NULL
		&& (p->howto->type == R_X86_64_JUMP_SLOT
		    || p->howto->type == R_X86_64_GLOB_DAT
		    || p->howto->type == R_X86_64_IRELATIVE))
	      {
		*s = **p->sym_ptr_ptr;
		/* Undefined syms won't have BSF_LOCAL or BSF_GLOBAL
		   set.  Since we are defining a symbol, ensure one
		   of them is set.  */
		if ((s->flags & BSF_LOCAL) == 0)
		  s->flags |= BSF_GLOBAL;
		s->flags |= BSF_SYNTHETIC;
		/* This is no longer a section symbol.  */
		s->flags &= ~BSF_SECTION_SYM;
		s->section = plt;
		s->the_bfd = plt->owner;
		s->value = offset;
		/* Store relocation for later use.  */
		s->udata.p = p;
		/* Add @plt to function name later.  */
		size += strlen (s->name) + sizeof (""@plt"");
		if (p->addend != 0)
		  size += sizeof (""+0x"") - 1 + 8 + 8 * ABI_64_P (abfd);
		n++;
		s++;
		/* There should be only one entry in PLT for a given
		   symbol.  Set howto to NULL after processing a PLT
		   entry to guard against corrupted PLT.  */
		p->howto = NULL;
	      }
	    offset += plt_entry_size;
	  }
      }

  /* PLT entries with R_X86_64_TLSDESC relocations are skipped.  */
  if (n == 0)
    goto bad_return;

  count = n;

  /* Allocate space for @plt suffixes.  */
  names = (char *) bfd_malloc (size);
  if (s == NULL)
    goto bad_return;

  s = *ret;
  for (i = 0; i < count; i++)
    {
      /* Add @plt to function name.  */
      arelent *p = (arelent *) s->udata.p;
      /* Clear it now.  */
      s->udata.p = NULL;
      size = strlen (s->name);
      memcpy (names, s->name, size);
      s->name = names;
      names += size;
      if (p->addend != 0)
	{
	  char buf[30], *a;

	  memcpy (names, ""+0x"", sizeof (""+0x"") - 1);
	  names += sizeof (""+0x"") - 1;
	  bfd_sprintf_vma (abfd, buf, p->addend);
	  for (a = buf; *a == '0'; ++a)
	    ;
	  size = strlen (a);
	  memcpy (names, a, size);
	  names += size;
	}
      memcpy (names, ""@plt"", sizeof (""@plt""));
      names += sizeof (""@plt"");
      s++;
    }

  for (j = 0; plts[j].name != NULL; j++)
    if (plts[j].contents != NULL)
      free (plts[j].contents);

  free (dynrelbuf);

  return count;
}","static long
elf_x86_64_get_synthetic_symtab (bfd *VAR_0,
				 long VAR_1 ATTRIBUTE_UNUSED,
				 asymbol **VAR_2 ATTRIBUTE_UNUSED,
				 long VAR_3,
				 asymbol **VAR_4,
				 asymbol **VAR_5)
{
  long VAR_6, VAR_7, VAR_8, VAR_9;
  int VAR_10;
  unsigned int VAR_11, VAR_12, VAR_13;
  asymbol *VAR_14;
  bfd_byte *VAR_15;
  long VAR_16, VAR_17;
  arelent **VAR_18;
  const struct elf_x86_64_lazy_plt_layout *VAR_19;
  const struct elf_x86_64_non_lazy_plt_layout *VAR_20;
  const struct elf_x86_64_lazy_plt_layout *VAR_21;
  const struct elf_x86_64_non_lazy_plt_layout *VAR_22;
  const struct elf_x86_64_lazy_plt_layout *VAR_23;
  const struct elf_x86_64_non_lazy_plt_layout *VAR_24;
  asection *VAR_25;
  char *VAR_26;
  enum elf_x86_64_plt_type VAR_27;
  struct elf_x86_64_plt VAR_28[] =
    {
      { "".plt"", NULL, NULL, VAR_29, 0, 0, 0, 0 },
      { "".plt.got"", NULL, NULL, VAR_30, 0, 0, 0, 0 },
      { "".plt.sec"", NULL, NULL, VAR_31, 0, 0, 0, 0 },
      { "".plt.bnd"", NULL, NULL, VAR_31, 0, 0, 0, 0 },
      { NULL, NULL, NULL, VAR_30, 0, 0, 0, 0 }
    };

  *VAR_5 = NULL;

  if ((VAR_0->flags & (VAR_32 | VAR_33)) == 0)
    return 0;

  if (VAR_3 <= 0)
    return 0;

  VAR_17 = bfd_get_dynamic_reloc_upper_bound (VAR_0);
  if (VAR_17 <= 0)
    return -1;

  VAR_18 = (arelent **) bfd_malloc (VAR_17);
  if (VAR_18 == NULL)
    return -1;

  VAR_16 = bfd_canonicalize_dynamic_reloc (VAR_0, VAR_18,
						VAR_4);
  if (VAR_16 <= 0)
    return -1;

  /* COMMENT_0 */
  qsort (VAR_18, VAR_16, sizeof (arelent *), VAR_34);

  if (get_elf_x86_64_backend_data (VAR_0)->os == VAR_35)
    {
      VAR_19 = &VAR_36;
      VAR_20 = &VAR_37;
      VAR_21 = &VAR_38;
      VAR_22 = &VAR_39;
      if (ABI_64_P (VAR_0))
	{
	  VAR_23 = &VAR_40;
	  VAR_24 = &VAR_41;
	}
      else
	{
	  VAR_23 = &VAR_42;
	  VAR_24 = &VAR_43;
	}
    }
  else
    {
      VAR_19 = &VAR_44;
      VAR_20 = NULL;
      VAR_21 = NULL;
      VAR_22 = NULL;
      VAR_23 = NULL;
      VAR_24 = NULL;
    }

  VAR_7 = 0;
  for (VAR_10 = 0; VAR_28[VAR_10].name != NULL; VAR_10++)
    {
      VAR_25 = bfd_get_section_by_name (VAR_0, VAR_28[VAR_10].name);
      if (VAR_25 == NULL || VAR_25->size == 0)
	continue;

      /* COMMENT_1 */
      VAR_15 = (bfd_byte *) bfd_malloc (VAR_25->size);
      if (VAR_15 == NULL)
	break;
      if (!bfd_get_section_contents (VAR_0, (asection *) VAR_25,
				     VAR_15, 0, VAR_25->size))
	{
	  free (VAR_15);
	  break;
	}

      /* COMMENT_2 */
      VAR_27 = VAR_29;
      if (VAR_28[VAR_10].type == VAR_29
	  && (VAR_25->size >= (VAR_19->plt_entry_size
			    + VAR_19->plt_entry_size)))
	{
	  /* COMMENT_3 */
                        
	  if ((memcmp (VAR_15, VAR_19->plt0_entry,
		       VAR_19->plt0_got1_offset) == 0)
	      && (memcmp (VAR_15 + 6, VAR_19->plt0_entry + 6,
			  2) == 0))
	    VAR_27 = VAR_45;
	  else if (VAR_21 != NULL
		   && (memcmp (VAR_15, VAR_21->plt0_entry,
			       VAR_21->plt0_got1_offset) == 0)
		   && (memcmp (VAR_15 + 6,
			       VAR_21->plt0_entry + 6, 3) == 0))
	    {
	      VAR_27 = VAR_45 | VAR_31;
	      /* COMMENT_5 */
                    
	      if ((memcmp (VAR_15 + VAR_23->plt_entry_size,
			   VAR_23->plt_entry,
			   VAR_23->plt_got_offset) == 0))
		VAR_19 = VAR_23;
	      else
		VAR_19 = VAR_21;
	    }
	}

      if (VAR_20 != NULL
	  && (VAR_27 == VAR_29 || VAR_27 == VAR_30)
	  && VAR_25->size >= VAR_20->plt_entry_size)
	{
	  /* COMMENT_7 */
	  if (memcmp (VAR_15, VAR_20->plt_entry,
		      VAR_20->plt_got_offset) == 0)
	    VAR_27 = VAR_30;
	}

      if (VAR_27 == VAR_29 || VAR_27 == VAR_31)
	{
	  if (VAR_22 != NULL
	      && VAR_25->size >= VAR_22->plt_entry_size
	      && (memcmp (VAR_15, VAR_22->plt_entry,
			  VAR_22->plt_got_offset) == 0))
	    {
	      /* COMMENT_8 */
	      VAR_27 = VAR_31;
	      VAR_20 = VAR_22;
	    }
	  else if (VAR_24 != NULL
		   && VAR_25->size >= VAR_24->plt_entry_size
		   && (memcmp (VAR_15,
			       VAR_24->plt_entry,
			       VAR_24->plt_got_offset) == 0))
	    {
	      /* COMMENT_9 */
	      VAR_27 = VAR_31;
	      VAR_20 = VAR_24;
	    }
	}

      if (VAR_27 == VAR_29)
	continue;

      VAR_28[VAR_10].sec = VAR_25;
      VAR_28[VAR_10].type = VAR_27;

      if ((VAR_27 & VAR_45))
	{
	  VAR_28[VAR_10].plt_got_offset = VAR_19->plt_got_offset;
	  VAR_28[VAR_10].plt_got_insn_size = VAR_19->plt_got_insn_size;
	  VAR_28[VAR_10].plt_entry_size = VAR_19->plt_entry_size;
	  /* COMMENT_10 */
	  VAR_8 = 1;
	}
      else
	{
	  VAR_28[VAR_10].plt_got_offset = VAR_20->plt_got_offset;
	  VAR_28[VAR_10].plt_got_insn_size = VAR_20->plt_got_insn_size;
	  VAR_28[VAR_10].plt_entry_size = VAR_20->plt_entry_size;
	  VAR_8 = 0;
	}

      /* COMMENT_11 */
      if (VAR_27 == (VAR_45 | VAR_31))
	VAR_28[VAR_10].count = 0;
      else
	{
	  VAR_9 = VAR_25->size / VAR_28[VAR_10].plt_entry_size;
	  VAR_28[VAR_10].count = VAR_9;
	  VAR_7 += VAR_9 - VAR_8;
	}

      VAR_28[VAR_10].contents = VAR_15;
    }

  if (VAR_7 == 0)
    return -1;

  VAR_6 = VAR_7 * sizeof (asymbol);
  VAR_14 = *VAR_5 = (asymbol *) bfd_zmalloc (VAR_6);
  if (VAR_14 == NULL)
    {
bad_return:
      for (VAR_10 = 0; VAR_28[VAR_10].name != NULL; VAR_10++)
	if (VAR_28[VAR_10].contents != NULL)
	  free (VAR_28[VAR_10].contents);
      free (VAR_18);
      return -1;
    }

  /* COMMENT_12 */
  VAR_6 = 0;
  VAR_9 = 0;
  for (VAR_10 = 0; VAR_28[VAR_10].name != NULL; VAR_10++)
    if ((VAR_15 = VAR_28[VAR_10].contents) != NULL)
      {
	long VAR_46;
	bfd_vma VAR_47;

	VAR_11 = VAR_28[VAR_10].plt_got_offset;
	VAR_13 = VAR_28[VAR_10].plt_got_insn_size;
	VAR_12 = VAR_28[VAR_10].plt_entry_size;

	VAR_25 = VAR_28[VAR_10].sec;

	if ((VAR_28[VAR_10].type & VAR_45))
	  {
	    /* COMMENT_10 */
	    VAR_46 = 1;
	    VAR_47 = VAR_12;
	  }
	else
	  {
	    VAR_46 = 0;
	    VAR_47 = 0;
	  }

	/* COMMENT_13 */
	for (; VAR_46 < VAR_28[VAR_10].count; VAR_46++)
	  {
	    int VAR_48;
	    bfd_vma VAR_49;
	    long VAR_50, VAR_51, VAR_52;
	    arelent *VAR_53;

	    /* COMMENT_14 */
	    VAR_48 = H_GET_32 (VAR_0, (VAR_15 + VAR_47
				   + VAR_11));
	    VAR_49 = VAR_25->vma + VAR_47 + VAR_48 + VAR_13;

	    /* COMMENT_15 */
	    VAR_53 = VAR_18[0];
	    VAR_50 = 0;
	    VAR_51 = VAR_16;
	    while ((VAR_50 + 1) < VAR_51)
	      {
		arelent *VAR_54;

		VAR_52 = (VAR_50 + VAR_51) / 2;
		VAR_54 = VAR_18[VAR_52];
		if (VAR_49 > VAR_54->address)
		  VAR_50 = VAR_52;
		else if (VAR_49 < VAR_54->address)
		  VAR_51 = VAR_52;
		else
		  {
		    VAR_53 = VAR_54;
		    break;
		  }
	      }

	    /* COMMENT_16 */
	    if (VAR_49 == VAR_53->address
		&& VAR_53->howto != NULL
		&& (VAR_53->howto->type == VAR_55
		    || VAR_53->howto->type == VAR_56
		    || VAR_53->howto->type == VAR_57))
	      {
		*VAR_14 = **VAR_53->sym_ptr_ptr;
		/* COMMENT_17 */
                                                     
                        
		if ((VAR_14->flags & VAR_58) == 0)
		  VAR_14->flags |= VAR_59;
		VAR_14->flags |= VAR_60;
		/* COMMENT_20 */
		VAR_14->flags &= ~VAR_61;
		VAR_14->section = VAR_25;
		VAR_14->the_bfd = VAR_25->owner;
		VAR_14->value = VAR_47;
		/* COMMENT_21 */
		VAR_14->udata.p = VAR_53;
		/* COMMENT_22 */
		VAR_6 += strlen (VAR_14->name) + sizeof (""@plt"");
		if (VAR_53->addend != 0)
		  VAR_6 += sizeof (""+0x"") - 1 + 8 + 8 * ABI_64_P (VAR_0);
		VAR_9++;
		VAR_14++;
		/* COMMENT_23 */
                                                      
                                              
		VAR_53->howto = NULL;
	      }
	    VAR_47 += VAR_12;
	  }
      }

  /* COMMENT_26 */
  if (VAR_9 == 0)
    goto bad_return;

  VAR_7 = VAR_9;

  /* COMMENT_27 */
  VAR_26 = (char *) bfd_malloc (VAR_6);
  if (VAR_14 == NULL)
    goto bad_return;

  VAR_14 = *VAR_5;
  for (VAR_8 = 0; VAR_8 < VAR_7; VAR_8++)
    {
      /* COMMENT_28 */
      arelent *VAR_53 = (arelent *) VAR_14->udata.p;
      /* COMMENT_29 */
      VAR_14->udata.p = NULL;
      VAR_6 = strlen (VAR_14->name);
      memcpy (VAR_26, VAR_14->name, VAR_6);
      VAR_14->name = VAR_26;
      VAR_26 += VAR_6;
      if (VAR_53->addend != 0)
	{
	  char VAR_62[30], *VAR_63;

	  memcpy (VAR_26, ""+0x"", sizeof (""+0x"") - 1);
	  VAR_26 += sizeof (""+0x"") - 1;
	  bfd_sprintf_vma (VAR_0, VAR_62, VAR_53->addend);
	  for (VAR_63 = VAR_62; *VAR_63 == '0'; ++VAR_63)
	    ;
	  VAR_6 = strlen (VAR_63);
	  memcpy (VAR_26, VAR_63, VAR_6);
	  VAR_26 += VAR_6;
	}
      memcpy (VAR_26, ""@plt"", sizeof (""@plt""));
      VAR_26 += sizeof (""@plt"");
      VAR_14++;
    }

  for (VAR_10 = 0; VAR_28[VAR_10].name != NULL; VAR_10++)
    if (VAR_28[VAR_10].contents != NULL)
      free (VAR_28[VAR_10].contents);

  free (VAR_18);

  return VAR_7;
}",,"--- func_before
+++ func_after
@@ -302,6 +302,10 @@
 		  size += sizeof (""+0x"") - 1 + 8 + 8 * ABI_64_P (abfd);
 		n++;
 		s++;
+		/* There should be only one entry in PLT for a given
+		   symbol.  Set howto to NULL after processing a PLT
+		   entry to guard against corrupted PLT.  */
+		p->howto = NULL;
 	      }
 	    offset += plt_entry_size;
 	  }","{'deleted_lines': [], 'added_lines': ['\t\t/* There should be only one entry in PLT for a given', '\t\t   symbol.  Set howto to NULL after processing a PLT', '\t\t   entry to guard against corrupted PLT.  */', '\t\tp->howto = NULL;']}",True,"The *_get_synthetic_symtab functions in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, do not ensure a unique PLT entry for a symbol, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted ELF file, related to elf32-i386.c and elf64-x86-64.c.",7.8,HIGH,2,test,,5
CVE-2017-14729,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,binutils-gdb,"
x86: Guard against corrupted PLT

There should be only one entry in PLT for a given symbol.  Set howto to
NULL after processing a PLT entry to guard against corrupted PLT so that
the duplicated PLT entries are skipped.

	PR binutils/22170
	* elfxx-x86.c (_bfd_x86_elf_get_synthetic_symtab): Guard against
	corrupted PLT.
",61e3bf5f83f7e505b6bc51ef65426e5b31e6e360,https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=61e3bf5f83f7e505b6bc51ef65426e5b31e6e360,bfd/elfxx-x86.c,_bfd_x86_elf_get_synthetic_symtab,"long
_bfd_x86_elf_get_synthetic_symtab (bfd *abfd,
long count,
long relsize,
bfd_vma got_addr,
struct elf_x86_plt plts[],
asymbol **dynsyms,
asymbol **ret)
{
long size, i, n, len;
int j;
unsigned int plt_got_offset, plt_entry_size;
asymbol *s;
bfd_byte *plt_contents;
long dynrelcount;
arelent **dynrelbuf, *p;
char *names;
const struct elf_backend_data *bed;
bfd_vma (*get_plt_got_vma) (struct elf_x86_plt *, bfd_vma, bfd_vma,
bfd_vma);
bfd_boolean (*valid_plt_reloc_p) (unsigned int);
if (count == 0)
return -1;
dynrelbuf = (arelent **) bfd_malloc (relsize);
if (dynrelbuf == NULL)
return -1;
dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf,
dynsyms);
if (dynrelcount <= 0)
return -1;
qsort (dynrelbuf, dynrelcount, sizeof (arelent *),
_bfd_x86_elf_compare_relocs);
size = count * sizeof (asymbol);
n = 0;
for (i = 0; i < dynrelcount; i++)
{
p = dynrelbuf[i];
size += strlen ((*p->sym_ptr_ptr)->name) + sizeof (""@plt"");
if (p->addend != 0)
size += sizeof (""+0x"") - 1 + 8 + 8 * ABI_64_P (abfd);
}
s = *ret = (asymbol *) bfd_zmalloc (size);
if (s == NULL)
goto bad_return;
bed = get_elf_backend_data (abfd);
if (bed->target_id == X86_64_ELF_DATA)
{
get_plt_got_vma = elf_x86_64_get_plt_got_vma;
valid_plt_reloc_p = elf_x86_64_valid_plt_reloc_p;
}
else
{
get_plt_got_vma = elf_i386_get_plt_got_vma;
valid_plt_reloc_p = elf_i386_valid_plt_reloc_p;
if (got_addr)
{
asection *sec = bfd_get_section_by_name (abfd, "".got.plt"");
if (sec != NULL)
got_addr = sec->vma;
else
{
sec = bfd_get_section_by_name (abfd, "".got"");
if (sec != NULL)
got_addr = sec->vma;
}
if (got_addr == (bfd_vma) -1)
goto bad_return;
}
}
names = (char *) (s + count);
size = 0;
n = 0;
for (j = 0; plts[j].name != NULL; j++)
if ((plt_contents = plts[j].contents) != NULL)
{
long k;
bfd_vma offset;
asection *plt;
struct elf_x86_plt *plt_p = &plts[j];
plt_got_offset = plt_p->plt_got_offset;
plt_entry_size = plt_p->plt_entry_size;
plt = plt_p->sec;
if ((plt_p->type & plt_lazy))
{
k = 1;
offset = plt_entry_size;
}
else
{
k = 0;
offset = 0;
}
for (; k < plt_p->count; k++)
{
int off;
bfd_vma got_vma;
long min, max, mid;
off = H_GET_32 (abfd, (plt_contents + offset
+ plt_got_offset));
got_vma = get_plt_got_vma (plt_p, off, offset, got_addr);
p = dynrelbuf[0];
min = 0;
max = dynrelcount;
while ((min + 1) < max)
{
arelent *r;
mid = (min + max) / 2;
r = dynrelbuf[mid];
if (got_vma > r->address)
min = mid;
else if (got_vma < r->address)
max = mid;
else
{
p = r;
break;
}
}
if (got_vma == p->address
&& p->howto != NULL
&& valid_plt_reloc_p (p->howto->type))
{
*s = **p->sym_ptr_ptr;
if ((s->flags & BSF_LOCAL) == 0)
s->flags |= BSF_GLOBAL;
s->flags |= BSF_SYNTHETIC;
s->flags &= ~BSF_SECTION_SYM;
s->section = plt;
s->the_bfd = plt->owner;
s->value = offset;
s->udata.p = NULL;
s->name = names;
len = strlen ((*p->sym_ptr_ptr)->name);
memcpy (names, (*p->sym_ptr_ptr)->name, len);
names += len;
if (p->addend != 0)
{
char buf[30], *a;
memcpy (names, ""+0x"", sizeof (""+0x"") - 1);
names += sizeof (""+0x"") - 1;
bfd_sprintf_vma (abfd, buf, p->addend);
for (a = buf; *a == '0'; ++a)
;
size = strlen (a);
memcpy (names, a, size);
names += size;
}
memcpy (names, ""@plt"", sizeof (""@plt""));
names += sizeof (""@plt"");
n++;
s++;
}
offset += plt_entry_size;
}
}
if (n == 0)
{
bad_return:
count = -1;
}
else
count = n;
for (j = 0; plts[j].name != NULL; j++)
if (plts[j].contents != NULL)
free (plts[j].contents);
free (dynrelbuf);
return count;
}","long
_bfd_x86_elf_get_synthetic_symtab (bfd *VAR_0,
long VAR_1,
long VAR_2,
bfd_vma VAR_3,
struct elf_x86_plt VAR_4[],
asymbol **VAR_5,
asymbol **VAR_6)
{
long VAR_7, VAR_8, VAR_9, VAR_10;
int VAR_11;
unsigned int VAR_12, VAR_13;
asymbol *VAR_14;
bfd_byte *VAR_15;
long VAR_16;
arelent **VAR_17, *VAR_18;
char *VAR_19;
const struct elf_backend_data *VAR_20;
bfd_vma (*VAR_21) (struct elf_x86_plt *, bfd_vma, bfd_vma,
bfd_vma);
bfd_boolean (*VAR_22) (unsigned int);
if (VAR_1 == 0)
return -1;
VAR_17 = (arelent **) bfd_malloc (VAR_2);
if (VAR_17 == NULL)
return -1;
VAR_16 = bfd_canonicalize_dynamic_reloc (VAR_0, VAR_17,
VAR_5);
if (VAR_16 <= 0)
return -1;
qsort (VAR_17, VAR_16, sizeof (arelent *),
VAR_23);
VAR_7 = VAR_1 * sizeof (asymbol);
VAR_9 = 0;
for (VAR_8 = 0; VAR_8 < VAR_16; VAR_8++)
{
VAR_18 = VAR_17[VAR_8];
VAR_7 += strlen ((*VAR_18->sym_ptr_ptr)->name) + sizeof (""@plt"");
if (VAR_18->addend != 0)
VAR_7 += sizeof (""+0x"") - 1 + 8 + 8 * ABI_64_P (VAR_0);
}
VAR_14 = *VAR_6 = (asymbol *) bfd_zmalloc (VAR_7);
if (VAR_14 == NULL)
goto bad_return;
VAR_20 = get_elf_backend_data (VAR_0);
if (VAR_20->target_id == VAR_24)
{
VAR_21 = VAR_25;
VAR_22 = VAR_26;
}
else
{
VAR_21 = VAR_27;
VAR_22 = VAR_28;
if (VAR_3)
{
asection *VAR_29 = bfd_get_section_by_name (VAR_0, "".got.plt"");
if (VAR_29 != NULL)
VAR_3 = VAR_29->vma;
else
{
VAR_29 = bfd_get_section_by_name (VAR_0, "".got"");
if (VAR_29 != NULL)
VAR_3 = VAR_29->vma;
}
if (VAR_3 == (bfd_vma) -1)
goto bad_return;
}
}
VAR_19 = (char *) (VAR_14 + VAR_1);
VAR_7 = 0;
VAR_9 = 0;
for (VAR_11 = 0; VAR_4[VAR_11].name != NULL; VAR_11++)
if ((VAR_15 = VAR_4[VAR_11].contents) != NULL)
{
long VAR_30;
bfd_vma VAR_31;
asection *VAR_32;
struct elf_x86_plt *VAR_33 = &VAR_4[VAR_11];
VAR_12 = VAR_33->plt_got_offset;
VAR_13 = VAR_33->plt_entry_size;
VAR_32 = VAR_33->sec;
if ((VAR_33->type & VAR_34))
{
VAR_30 = 1;
VAR_31 = VAR_13;
}
else
{
VAR_30 = 0;
VAR_31 = 0;
}
for (; VAR_30 < VAR_33->count; VAR_30++)
{
int VAR_35;
bfd_vma VAR_36;
long VAR_37, VAR_38, VAR_39;
VAR_35 = H_GET_32 (VAR_0, (VAR_15 + VAR_31
+ VAR_12));
VAR_36 = VAR_21 (VAR_33, VAR_35, VAR_31, VAR_3);
VAR_18 = VAR_17[0];
VAR_37 = 0;
VAR_38 = VAR_16;
while ((VAR_37 + 1) < VAR_38)
{
arelent *VAR_40;
VAR_39 = (VAR_37 + VAR_38) / 2;
VAR_40 = VAR_17[VAR_39];
if (VAR_36 > VAR_40->address)
VAR_37 = VAR_39;
else if (VAR_36 < VAR_40->address)
VAR_38 = VAR_39;
else
{
VAR_18 = VAR_40;
break;
}
}
if (VAR_36 == VAR_18->address
&& VAR_18->howto != NULL
&& VAR_22 (VAR_18->howto->type))
{
*VAR_14 = **VAR_18->sym_ptr_ptr;
if ((VAR_14->flags & VAR_41) == 0)
VAR_14->flags |= VAR_42;
VAR_14->flags |= VAR_43;
VAR_14->flags &= ~VAR_44;
VAR_14->section = VAR_32;
VAR_14->the_bfd = VAR_32->owner;
VAR_14->value = VAR_31;
VAR_14->udata.p = NULL;
VAR_14->name = VAR_19;
VAR_10 = strlen ((*VAR_18->sym_ptr_ptr)->name);
memcpy (VAR_19, (*VAR_18->sym_ptr_ptr)->name, VAR_10);
VAR_19 += VAR_10;
if (VAR_18->addend != 0)
{
char VAR_45[30], *VAR_46;
memcpy (VAR_19, ""+0x"", sizeof (""+0x"") - 1);
VAR_19 += sizeof (""+0x"") - 1;
bfd_sprintf_vma (VAR_0, VAR_45, VAR_18->addend);
for (VAR_46 = VAR_45; *VAR_46 == '0'; ++VAR_46)
;
VAR_7 = strlen (VAR_46);
memcpy (VAR_19, VAR_46, VAR_7);
VAR_19 += VAR_7;
}
memcpy (VAR_19, ""@plt"", sizeof (""@plt""));
VAR_19 += sizeof (""@plt"");
VAR_9++;
VAR_14++;
}
VAR_31 += VAR_13;
}
}
if (VAR_9 == 0)
{
bad_return:
VAR_1 = -1;
}
else
VAR_1 = VAR_9;
for (VAR_11 = 0; VAR_4[VAR_11].name != NULL; VAR_11++)
if (VAR_4[VAR_11].contents != NULL)
free (VAR_4[VAR_11].contents);
free (VAR_17);
return VAR_1;
}",binutils-gdb/61e3bf5f83f7e505b6bc51ef65426e5b31e6e360/elfxx-x86.c/vul/before/0.json,"long
_bfd_x86_elf_get_synthetic_symtab (bfd *abfd,
				   long count,
				   long relsize,
				   bfd_vma got_addr,
				   struct elf_x86_plt plts[],
				   asymbol **dynsyms,
				   asymbol **ret)
{
  long size, i, n, len;
  int j;
  unsigned int plt_got_offset, plt_entry_size;
  asymbol *s;
  bfd_byte *plt_contents;
  long dynrelcount;
  arelent **dynrelbuf, *p;
  char *names;
  const struct elf_backend_data *bed;
  bfd_vma (*get_plt_got_vma) (struct elf_x86_plt *, bfd_vma, bfd_vma,
			      bfd_vma);
  bfd_boolean (*valid_plt_reloc_p) (unsigned int);

  if (count == 0)
    return -1;

  dynrelbuf = (arelent **) bfd_malloc (relsize);
  if (dynrelbuf == NULL)
    return -1;

  dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf,
						dynsyms);
  if (dynrelcount <= 0)
    return -1;

  /* Sort the relocs by address.  */
  qsort (dynrelbuf, dynrelcount, sizeof (arelent *),
	 _bfd_x86_elf_compare_relocs);

  size = count * sizeof (asymbol);

  /* Allocate space for @plt suffixes.  */
  n = 0;
  for (i = 0; i < dynrelcount; i++)
    {
      p = dynrelbuf[i];
      size += strlen ((*p->sym_ptr_ptr)->name) + sizeof (""@plt"");
      if (p->addend != 0)
	size += sizeof (""+0x"") - 1 + 8 + 8 * ABI_64_P (abfd);
    }

  s = *ret = (asymbol *) bfd_zmalloc (size);
  if (s == NULL)
    goto bad_return;

  bed = get_elf_backend_data (abfd);

  if (bed->target_id == X86_64_ELF_DATA)
    {
      get_plt_got_vma = elf_x86_64_get_plt_got_vma;
      valid_plt_reloc_p = elf_x86_64_valid_plt_reloc_p;
    }
  else
    {
      get_plt_got_vma = elf_i386_get_plt_got_vma;
      valid_plt_reloc_p = elf_i386_valid_plt_reloc_p;
      if (got_addr)
	{
	  /* Check .got.plt and then .got to get the _GLOBAL_OFFSET_TABLE_
	     address.  */
	  asection *sec = bfd_get_section_by_name (abfd, "".got.plt"");
	  if (sec != NULL)
	    got_addr = sec->vma;
	  else
	    {
	      sec = bfd_get_section_by_name (abfd, "".got"");
	      if (sec != NULL)
		got_addr = sec->vma;
	    }

	  if (got_addr == (bfd_vma) -1)
	    goto bad_return;
	}
    }

  /* Check for each PLT section.  */
  names = (char *) (s + count);
  size = 0;
  n = 0;
  for (j = 0; plts[j].name != NULL; j++)
    if ((plt_contents = plts[j].contents) != NULL)
      {
	long k;
	bfd_vma offset;
	asection *plt;
	struct elf_x86_plt *plt_p = &plts[j];

	plt_got_offset = plt_p->plt_got_offset;
	plt_entry_size = plt_p->plt_entry_size;

	plt = plt_p->sec;

	if ((plt_p->type & plt_lazy))
	  {
	    /* Skip PLT0 in lazy PLT.  */
	    k = 1;
	    offset = plt_entry_size;
	  }
	else
	  {
	    k = 0;
	    offset = 0;
	  }

	/* Check each PLT entry against dynamic relocations.  */
	for (; k < plt_p->count; k++)
	  {
	    int off;
	    bfd_vma got_vma;
	    long min, max, mid;

	    /* Get the GOT offset for i386 or the PC-relative offset
	       for x86-64, a signed 32-bit integer.  */
	    off = H_GET_32 (abfd, (plt_contents + offset
				   + plt_got_offset));
	    got_vma = get_plt_got_vma (plt_p, off, offset, got_addr);

	    /* Binary search.  */
	    p = dynrelbuf[0];
	    min = 0;
	    max = dynrelcount;
	    while ((min + 1) < max)
	      {
		arelent *r;

		mid = (min + max) / 2;
		r = dynrelbuf[mid];
		if (got_vma > r->address)
		  min = mid;
		else if (got_vma < r->address)
		  max = mid;
		else
		  {
		    p = r;
		    break;
		  }
	      }

	    /* Skip unknown relocation.  PR 17512: file: bc9d6cf5.  */
	    if (got_vma == p->address
		&& p->howto != NULL
		&& valid_plt_reloc_p (p->howto->type))
	      {
		*s = **p->sym_ptr_ptr;
		/* Undefined syms won't have BSF_LOCAL or BSF_GLOBAL
		   set.  Since we are defining a symbol, ensure one
		   of them is set.  */
		if ((s->flags & BSF_LOCAL) == 0)
		  s->flags |= BSF_GLOBAL;
		s->flags |= BSF_SYNTHETIC;
		/* This is no longer a section symbol.  */
		s->flags &= ~BSF_SECTION_SYM;
		s->section = plt;
		s->the_bfd = plt->owner;
		s->value = offset;
		s->udata.p = NULL;
		s->name = names;
		len = strlen ((*p->sym_ptr_ptr)->name);
		memcpy (names, (*p->sym_ptr_ptr)->name, len);
		names += len;
		if (p->addend != 0)
		  {
		    char buf[30], *a;

		    memcpy (names, ""+0x"", sizeof (""+0x"") - 1);
		    names += sizeof (""+0x"") - 1;
		    bfd_sprintf_vma (abfd, buf, p->addend);
		    for (a = buf; *a == '0'; ++a)
		      ;
		    size = strlen (a);
		    memcpy (names, a, size);
		    names += size;
		  }
		memcpy (names, ""@plt"", sizeof (""@plt""));
		names += sizeof (""@plt"");
		n++;
		s++;
		/* There should be only one entry in PLT for a given
		   symbol.  Set howto to NULL after processing a PLT
		   entry to guard against corrupted PLT.  */
		p->howto = NULL;
	      }
	    offset += plt_entry_size;
	  }
      }

  /* PLT entries with R_386_TLS_DESC relocations are skipped.  */
  if (n == 0)
    {
bad_return:
      count = -1;
    }
  else
    count = n;

  for (j = 0; plts[j].name != NULL; j++)
    if (plts[j].contents != NULL)
      free (plts[j].contents);

  free (dynrelbuf);

  return count;
}","long
_bfd_x86_elf_get_synthetic_symtab (bfd *VAR_0,
				   long VAR_1,
				   long VAR_2,
				   bfd_vma VAR_3,
				   struct elf_x86_plt VAR_4[],
				   asymbol **VAR_5,
				   asymbol **VAR_6)
{
  long VAR_7, VAR_8, VAR_9, VAR_10;
  int VAR_11;
  unsigned int VAR_12, VAR_13;
  asymbol *VAR_14;
  bfd_byte *VAR_15;
  long VAR_16;
  arelent **VAR_17, *VAR_18;
  char *VAR_19;
  const struct elf_backend_data *VAR_20;
  bfd_vma (*VAR_21) (struct elf_x86_plt *, bfd_vma, bfd_vma,
			      bfd_vma);
  bfd_boolean (*VAR_22) (unsigned int);

  if (VAR_1 == 0)
    return -1;

  VAR_17 = (arelent **) bfd_malloc (VAR_2);
  if (VAR_17 == NULL)
    return -1;

  VAR_16 = bfd_canonicalize_dynamic_reloc (VAR_0, VAR_17,
						VAR_5);
  if (VAR_16 <= 0)
    return -1;

  /* COMMENT_0 */
  qsort (VAR_17, VAR_16, sizeof (arelent *),
	 VAR_23);

  VAR_7 = VAR_1 * sizeof (asymbol);

  /* COMMENT_1 */
  VAR_9 = 0;
  for (VAR_8 = 0; VAR_8 < VAR_16; VAR_8++)
    {
      VAR_18 = VAR_17[VAR_8];
      VAR_7 += strlen ((*VAR_18->sym_ptr_ptr)->name) + sizeof (""@plt"");
      if (VAR_18->addend != 0)
	VAR_7 += sizeof (""+0x"") - 1 + 8 + 8 * ABI_64_P (VAR_0);
    }

  VAR_14 = *VAR_6 = (asymbol *) bfd_zmalloc (VAR_7);
  if (VAR_14 == NULL)
    goto bad_return;

  VAR_20 = get_elf_backend_data (VAR_0);

  if (VAR_20->target_id == VAR_24)
    {
      VAR_21 = VAR_25;
      VAR_22 = VAR_26;
    }
  else
    {
      VAR_21 = VAR_27;
      VAR_22 = VAR_28;
      if (VAR_3)
	{
	  /* COMMENT_2 */
                  
	  asection *VAR_29 = bfd_get_section_by_name (VAR_0, "".got.plt"");
	  if (VAR_29 != NULL)
	    VAR_3 = VAR_29->vma;
	  else
	    {
	      VAR_29 = bfd_get_section_by_name (VAR_0, "".got"");
	      if (VAR_29 != NULL)
		VAR_3 = VAR_29->vma;
	    }

	  if (VAR_3 == (bfd_vma) -1)
	    goto bad_return;
	}
    }

  /* COMMENT_4 */
  VAR_19 = (char *) (VAR_14 + VAR_1);
  VAR_7 = 0;
  VAR_9 = 0;
  for (VAR_11 = 0; VAR_4[VAR_11].name != NULL; VAR_11++)
    if ((VAR_15 = VAR_4[VAR_11].contents) != NULL)
      {
	long VAR_30;
	bfd_vma VAR_31;
	asection *VAR_32;
	struct elf_x86_plt *VAR_33 = &VAR_4[VAR_11];

	VAR_12 = VAR_33->plt_got_offset;
	VAR_13 = VAR_33->plt_entry_size;

	VAR_32 = VAR_33->sec;

	if ((VAR_33->type & VAR_34))
	  {
	    /* COMMENT_5 */
	    VAR_30 = 1;
	    VAR_31 = VAR_13;
	  }
	else
	  {
	    VAR_30 = 0;
	    VAR_31 = 0;
	  }

	/* COMMENT_6 */
	for (; VAR_30 < VAR_33->count; VAR_30++)
	  {
	    int VAR_35;
	    bfd_vma VAR_36;
	    long VAR_37, VAR_38, VAR_39;

	    /* COMMENT_7 */
                                                
	    VAR_35 = H_GET_32 (VAR_0, (VAR_15 + VAR_31
				   + VAR_12));
	    VAR_36 = VAR_21 (VAR_33, VAR_35, VAR_31, VAR_3);

	    /* COMMENT_9 */
	    VAR_18 = VAR_17[0];
	    VAR_37 = 0;
	    VAR_38 = VAR_16;
	    while ((VAR_37 + 1) < VAR_38)
	      {
		arelent *VAR_40;

		VAR_39 = (VAR_37 + VAR_38) / 2;
		VAR_40 = VAR_17[VAR_39];
		if (VAR_36 > VAR_40->address)
		  VAR_37 = VAR_39;
		else if (VAR_36 < VAR_40->address)
		  VAR_38 = VAR_39;
		else
		  {
		    VAR_18 = VAR_40;
		    break;
		  }
	      }

	    /* COMMENT_10 */
	    if (VAR_36 == VAR_18->address
		&& VAR_18->howto != NULL
		&& VAR_22 (VAR_18->howto->type))
	      {
		*VAR_14 = **VAR_18->sym_ptr_ptr;
		/* COMMENT_11 */
                                                     
                        
		if ((VAR_14->flags & VAR_41) == 0)
		  VAR_14->flags |= VAR_42;
		VAR_14->flags |= VAR_43;
		/* COMMENT_14 */
		VAR_14->flags &= ~VAR_44;
		VAR_14->section = VAR_32;
		VAR_14->the_bfd = VAR_32->owner;
		VAR_14->value = VAR_31;
		VAR_14->udata.p = NULL;
		VAR_14->name = VAR_19;
		VAR_10 = strlen ((*VAR_18->sym_ptr_ptr)->name);
		memcpy (VAR_19, (*VAR_18->sym_ptr_ptr)->name, VAR_10);
		VAR_19 += VAR_10;
		if (VAR_18->addend != 0)
		  {
		    char VAR_45[30], *VAR_46;

		    memcpy (VAR_19, ""+0x"", sizeof (""+0x"") - 1);
		    VAR_19 += sizeof (""+0x"") - 1;
		    bfd_sprintf_vma (VAR_0, VAR_45, VAR_18->addend);
		    for (VAR_46 = VAR_45; *VAR_46 == '0'; ++VAR_46)
		      ;
		    VAR_7 = strlen (VAR_46);
		    memcpy (VAR_19, VAR_46, VAR_7);
		    VAR_19 += VAR_7;
		  }
		memcpy (VAR_19, ""@plt"", sizeof (""@plt""));
		VAR_19 += sizeof (""@plt"");
		VAR_9++;
		VAR_14++;
		/* COMMENT_15 */
                                                      
                                              
		VAR_18->howto = NULL;
	      }
	    VAR_31 += VAR_13;
	  }
      }

  /* COMMENT_18 */
  if (VAR_9 == 0)
    {
bad_return:
      VAR_1 = -1;
    }
  else
    VAR_1 = VAR_9;

  for (VAR_11 = 0; VAR_4[VAR_11].name != NULL; VAR_11++)
    if (VAR_4[VAR_11].contents != NULL)
      free (VAR_4[VAR_11].contents);

  free (VAR_17);

  return VAR_1;
}",binutils-gdb/61e3bf5f83f7e505b6bc51ef65426e5b31e6e360/elfxx-x86.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -184,6 +184,10 @@
 		names += sizeof (""@plt"");
 		n++;
 		s++;
+		/* There should be only one entry in PLT for a given
+		   symbol.  Set howto to NULL after processing a PLT
+		   entry to guard against corrupted PLT.  */
+		p->howto = NULL;
 	      }
 	    offset += plt_entry_size;
 	  }","{'deleted_lines': [], 'added_lines': ['\t\t/* There should be only one entry in PLT for a given', '\t\t   symbol.  Set howto to NULL after processing a PLT', '\t\t   entry to guard against corrupted PLT.  */', '\t\tp->howto = NULL;']}",True,"The *_get_synthetic_symtab functions in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, do not ensure a unique PLT entry for a symbol, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted ELF file, related to elf32-i386.c and elf64-x86-64.c.",7.8,HIGH,2,test,,5
CVE-2017-14974,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,binutils-gdb,"
x86: Return -1 if bfd_canonicalize_dynamic_reloc returns 0

Stop if bfd_canonicalize_dynamic_reloc returns 0.

	PR binutils/22163
	* elf32-i386.c (elf_i386_get_synthetic_symtab): Also return -1
	if bfd_canonicalize_dynamic_reloc returns 0.
	* elf64-x86-64.c (elf_x86_64_get_synthetic_symtab): Likewise.

(cherry picked from commit b69e9267d15a09ce3f3d4599eae2952dfc6df502)
",e70c19e3a4c26e9c1ebf0c9170d105039b56d7cf,https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=e70c19e3a4c26e9c1ebf0c9170d105039b56d7cf,bfd/elf32-i386.c,elf_i386_get_synthetic_symtab,"static long
elf_i386_get_synthetic_symtab (bfd *abfd,
long symcount ATTRIBUTE_UNUSED,
asymbol **syms ATTRIBUTE_UNUSED,
long dynsymcount,
asymbol **dynsyms,
asymbol **ret)
{
long size, count, i, n;
int j;
unsigned int plt_got_offset, plt_entry_size;
asymbol *s;
bfd_byte *plt_contents;
long dynrelcount, relsize;
arelent **dynrelbuf;
const struct elf_i386_lazy_plt_layout *lazy_plt;
const struct elf_i386_non_lazy_plt_layout *non_lazy_plt;
const struct elf_i386_lazy_plt_layout *lazy_ibt_plt;
const struct elf_i386_non_lazy_plt_layout *non_lazy_ibt_plt;
asection *plt;
bfd_vma got_addr;
char *names;
enum elf_i386_plt_type plt_type;
struct elf_i386_plt plts[] =
{
{ "".plt"", NULL, NULL, plt_unknown, 0, 0, 0 },
{ "".plt.got"", NULL, NULL, plt_non_lazy, 0, 0, 0 },
{ "".plt.sec"", NULL, NULL, plt_second, 0, 0, 0 },
{ NULL, NULL, NULL, plt_non_lazy, 0, 0, 0 }
};
*ret = NULL;
if ((abfd->flags & (DYNAMIC | EXEC_P)) == 0)
return 0;
if (dynsymcount <= 0)
return 0;
relsize = bfd_get_dynamic_reloc_upper_bound (abfd);
if (relsize <= 0)
return -1;
dynrelbuf = (arelent **) bfd_malloc (relsize);
if (dynrelbuf == NULL)
return -1;
dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf,
dynsyms);
if (dynrelcount < 0)
return -1;
qsort (dynrelbuf, dynrelcount, sizeof (arelent *), compare_relocs);
non_lazy_plt = NULL;
lazy_plt = NULL;
non_lazy_ibt_plt = NULL;
lazy_ibt_plt = NULL;
switch (get_elf_i386_backend_data (abfd)->os)
{
case is_normal:
non_lazy_plt = &elf_i386_non_lazy_plt;
lazy_ibt_plt = &elf_i386_lazy_ibt_plt;
non_lazy_ibt_plt = &elf_i386_non_lazy_ibt_plt;
case is_vxworks:
lazy_plt = &elf_i386_lazy_plt;
break;
case is_nacl:
lazy_plt = &elf_i386_nacl_plt;
break;
}
got_addr = 0;
count = 0;
for (j = 0; plts[j].name != NULL; j++)
{
plt = bfd_get_section_by_name (abfd, plts[j].name);
if (plt == NULL || plt->size == 0)
continue;
plt_contents = (bfd_byte *) bfd_malloc (plt->size);
if (plt_contents == NULL)
break;
if (!bfd_get_section_contents (abfd, (asection *) plt,
plt_contents, 0, plt->size))
{
free (plt_contents);
break;
}
plt_type = plt_unknown;
if (plts[j].type == plt_unknown
&& (plt->size >= (lazy_plt->plt0_entry_size
+ lazy_plt->plt_entry_size)))
{
if (memcmp (plt_contents, lazy_plt->plt0_entry,
lazy_plt->plt0_got1_offset) == 0)
{
if (lazy_ibt_plt != NULL
&& (memcmp (plt_contents + lazy_ibt_plt->plt0_entry_size,
lazy_ibt_plt->plt_entry,
lazy_ibt_plt->plt_got_offset) == 0))
plt_type = plt_lazy | plt_second;
else
plt_type = plt_lazy;
}
else if (memcmp (plt_contents, lazy_plt->pic_plt0_entry,
lazy_plt->plt0_got1_offset) == 0)
{
if (lazy_ibt_plt != NULL
&& (memcmp (plt_contents + lazy_ibt_plt->plt0_entry_size,
lazy_ibt_plt->pic_plt_entry,
lazy_ibt_plt->plt_got_offset) == 0))
plt_type = plt_lazy | plt_pic | plt_second;
else
plt_type = plt_lazy | plt_pic;
}
}
if (non_lazy_plt != NULL
&& (plt_type == plt_unknown || plt_type == plt_non_lazy)
&& plt->size >= non_lazy_plt->plt_entry_size)
{
if (memcmp (plt_contents, non_lazy_plt->plt_entry,
non_lazy_plt->plt_got_offset) == 0)
plt_type = plt_non_lazy;
else if (memcmp (plt_contents, non_lazy_plt->pic_plt_entry,
non_lazy_plt->plt_got_offset) == 0)
plt_type = plt_pic;
}
if ((non_lazy_ibt_plt != NULL)
&& (plt_type == plt_unknown || plt_type == plt_second)
&& plt->size >= non_lazy_ibt_plt->plt_entry_size)
{
if (memcmp (plt_contents,
non_lazy_ibt_plt->plt_entry,
non_lazy_ibt_plt->plt_got_offset) == 0)
{
plt_type = plt_second;
non_lazy_plt = non_lazy_ibt_plt;
}
else if (memcmp (plt_contents,
non_lazy_ibt_plt->pic_plt_entry,
non_lazy_ibt_plt->plt_got_offset) == 0)
{
plt_type = plt_second | plt_pic;
non_lazy_plt = non_lazy_ibt_plt;
}
}
if (plt_type == plt_unknown)
continue;
plts[j].sec = plt;
plts[j].type = plt_type;
if ((plt_type & plt_lazy))
{
plts[j].plt_got_offset = lazy_plt->plt_got_offset;
plts[j].plt_entry_size = lazy_plt->plt_entry_size;
i = 1;
}
else
{
plts[j].plt_got_offset = non_lazy_plt->plt_got_offset;
plts[j].plt_entry_size = non_lazy_plt->plt_entry_size;
i = 0;
}
if ((plt_type & (plt_lazy | plt_second))
== (plt_lazy | plt_second))
plts[j].count = 0;
else
{
n = plt->size / plts[j].plt_entry_size;
plts[j].count = n;
count += n - i;
}
plts[j].contents = plt_contents;
if ((plt_type & plt_pic))
got_addr = (bfd_vma) -1;
}
if (count == 0)
return -1;
size = count * sizeof (asymbol);
s = *ret = (asymbol *) bfd_zmalloc (size);
if (s == NULL)
{
bad_return:
for (j = 0; plts[j].name != NULL; j++)
if (plts[j].contents != NULL)
free (plts[j].contents);
free (dynrelbuf);
return -1;
}
if (got_addr)
{
asection *sec = bfd_get_section_by_name (abfd, "".got.plt"");
if (sec != NULL)
got_addr = sec->vma;
else
{
sec = bfd_get_section_by_name (abfd, "".got"");
if (sec != NULL)
got_addr = sec->vma;
}
if (got_addr == (bfd_vma) -1)
goto bad_return;
}
size = 0;
n = 0;
for (j = 0; plts[j].name != NULL; j++)
if ((plt_contents = plts[j].contents) != NULL)
{
long k;
bfd_vma offset;
plt_got_offset = plts[j].plt_got_offset;
plt_entry_size = plts[j].plt_entry_size;
plt = plts[j].sec;
if ((plts[j].type & plt_lazy))
{
k = 1;
offset = plt_entry_size;
}
else
{
k = 0;
offset = 0;
}
for (; k < plts[j].count; k++)
{
int off;
bfd_vma got_vma;
long min, max, mid;
arelent *p;
off = H_GET_32 (abfd, (plt_contents + offset
+ plt_got_offset));
got_vma = got_addr + off;
p = dynrelbuf[0];
min = 0;
max = dynrelcount;
while ((min + 1) < max)
{
arelent *r;
mid = (min + max) / 2;
r = dynrelbuf[mid];
if (got_vma > r->address)
min = mid;
else if (got_vma < r->address)
max = mid;
else
{
p = r;
break;
}
}
if (got_vma == p->address
&& p->howto != NULL
&& (p->howto->type == R_386_JUMP_SLOT
|| p->howto->type == R_386_GLOB_DAT
|| p->howto->type == R_386_IRELATIVE))
{
*s = **p->sym_ptr_ptr;
if ((s->flags & BSF_LOCAL) == 0)
s->flags |= BSF_GLOBAL;
s->flags |= BSF_SYNTHETIC;
s->flags &= ~BSF_SECTION_SYM;
s->section = plt;
s->the_bfd = plt->owner;
s->value = offset;
s->udata.p = p;
size += strlen (s->name) + sizeof (""@plt"");
if (p->addend != 0)
size += sizeof (""+0x"") - 1 + 8;
n++;
s++;
}
offset += plt_entry_size;
}
}
if (n == 0)
goto bad_return;
count = n;
names = (char *) bfd_malloc (size);
if (s == NULL)
goto bad_return;
s = *ret;
for (i = 0; i < count; i++)
{
arelent *p = (arelent *) s->udata.p;
s->udata.p = NULL;
size = strlen (s->name);
memcpy (names, s->name, size);
s->name = names;
names += size;
if (p->addend != 0)
{
char buf[30], *a;
memcpy (names, ""+0x"", sizeof (""+0x"") - 1);
names += sizeof (""+0x"") - 1;
bfd_sprintf_vma (abfd, buf, p->addend);
for (a = buf; *a == '0'; ++a)
;
size = strlen (a);
memcpy (names, a, size);
names += size;
}
memcpy (names, ""@plt"", sizeof (""@plt""));
names += sizeof (""@plt"");
s++;
}
for (j = 0; plts[j].name != NULL; j++)
if (plts[j].contents != NULL)
free (plts[j].contents);
free (dynrelbuf);
return count;
}","static long
elf_i386_get_synthetic_symtab (bfd *VAR_0,
long VAR_1 ATTRIBUTE_UNUSED,
asymbol **VAR_2 ATTRIBUTE_UNUSED,
long VAR_3,
asymbol **VAR_4,
asymbol **VAR_5)
{
long VAR_6, VAR_7, VAR_8, VAR_9;
int VAR_10;
unsigned int VAR_11, VAR_12;
asymbol *VAR_13;
bfd_byte *VAR_14;
long VAR_15, VAR_16;
arelent **VAR_17;
const struct elf_i386_lazy_plt_layout *VAR_18;
const struct elf_i386_non_lazy_plt_layout *VAR_19;
const struct elf_i386_lazy_plt_layout *VAR_20;
const struct elf_i386_non_lazy_plt_layout *VAR_21;
asection *VAR_22;
bfd_vma VAR_23;
char *VAR_24;
enum elf_i386_plt_type VAR_25;
struct elf_i386_plt VAR_26[] =
{
{ "".plt"", NULL, NULL, VAR_27, 0, 0, 0 },
{ "".plt.got"", NULL, NULL, VAR_28, 0, 0, 0 },
{ "".plt.sec"", NULL, NULL, VAR_29, 0, 0, 0 },
{ NULL, NULL, NULL, VAR_28, 0, 0, 0 }
};
*VAR_5 = NULL;
if ((VAR_0->flags & (VAR_30 | VAR_31)) == 0)
return 0;
if (VAR_3 <= 0)
return 0;
VAR_16 = bfd_get_dynamic_reloc_upper_bound (VAR_0);
if (VAR_16 <= 0)
return -1;
VAR_17 = (arelent **) bfd_malloc (VAR_16);
if (VAR_17 == NULL)
return -1;
VAR_15 = bfd_canonicalize_dynamic_reloc (VAR_0, VAR_17,
VAR_4);
if (VAR_15 < 0)
return -1;
qsort (VAR_17, VAR_15, sizeof (arelent *), VAR_32);
VAR_19 = NULL;
VAR_18 = NULL;
VAR_21 = NULL;
VAR_20 = NULL;
switch (get_elf_i386_backend_data (VAR_0)->os)
{
case VAR_33:
VAR_19 = &VAR_34;
VAR_20 = &VAR_35;
VAR_21 = &VAR_36;
case VAR_37:
VAR_18 = &VAR_38;
break;
case VAR_39:
VAR_18 = &VAR_40;
break;
}
VAR_23 = 0;
VAR_7 = 0;
for (VAR_10 = 0; VAR_26[VAR_10].name != NULL; VAR_10++)
{
VAR_22 = bfd_get_section_by_name (VAR_0, VAR_26[VAR_10].name);
if (VAR_22 == NULL || VAR_22->size == 0)
continue;
VAR_14 = (bfd_byte *) bfd_malloc (VAR_22->size);
if (VAR_14 == NULL)
break;
if (!bfd_get_section_contents (VAR_0, (asection *) VAR_22,
VAR_14, 0, VAR_22->size))
{
free (VAR_14);
break;
}
VAR_25 = VAR_27;
if (VAR_26[VAR_10].type == VAR_27
&& (VAR_22->size >= (VAR_18->plt0_entry_size
+ VAR_18->plt_entry_size)))
{
if (memcmp (VAR_14, VAR_18->plt0_entry,
VAR_18->plt0_got1_offset) == 0)
{
if (VAR_20 != NULL
&& (memcmp (VAR_14 + VAR_20->plt0_entry_size,
VAR_20->plt_entry,
VAR_20->plt_got_offset) == 0))
VAR_25 = VAR_41 | VAR_29;
else
VAR_25 = VAR_41;
}
else if (memcmp (VAR_14, VAR_18->pic_plt0_entry,
VAR_18->plt0_got1_offset) == 0)
{
if (VAR_20 != NULL
&& (memcmp (VAR_14 + VAR_20->plt0_entry_size,
VAR_20->pic_plt_entry,
VAR_20->plt_got_offset) == 0))
VAR_25 = VAR_41 | VAR_42 | VAR_29;
else
VAR_25 = VAR_41 | VAR_42;
}
}
if (VAR_19 != NULL
&& (VAR_25 == VAR_27 || VAR_25 == VAR_28)
&& VAR_22->size >= VAR_19->plt_entry_size)
{
if (memcmp (VAR_14, VAR_19->plt_entry,
VAR_19->plt_got_offset) == 0)
VAR_25 = VAR_28;
else if (memcmp (VAR_14, VAR_19->pic_plt_entry,
VAR_19->plt_got_offset) == 0)
VAR_25 = VAR_42;
}
if ((VAR_21 != NULL)
&& (VAR_25 == VAR_27 || VAR_25 == VAR_29)
&& VAR_22->size >= VAR_21->plt_entry_size)
{
if (memcmp (VAR_14,
VAR_21->plt_entry,
VAR_21->plt_got_offset) == 0)
{
VAR_25 = VAR_29;
VAR_19 = VAR_21;
}
else if (memcmp (VAR_14,
VAR_21->pic_plt_entry,
VAR_21->plt_got_offset) == 0)
{
VAR_25 = VAR_29 | VAR_42;
VAR_19 = VAR_21;
}
}
if (VAR_25 == VAR_27)
continue;
VAR_26[VAR_10].sec = VAR_22;
VAR_26[VAR_10].type = VAR_25;
if ((VAR_25 & VAR_41))
{
VAR_26[VAR_10].plt_got_offset = VAR_18->plt_got_offset;
VAR_26[VAR_10].plt_entry_size = VAR_18->plt_entry_size;
VAR_8 = 1;
}
else
{
VAR_26[VAR_10].plt_got_offset = VAR_19->plt_got_offset;
VAR_26[VAR_10].plt_entry_size = VAR_19->plt_entry_size;
VAR_8 = 0;
}
if ((VAR_25 & (VAR_41 | VAR_29))
== (VAR_41 | VAR_29))
VAR_26[VAR_10].count = 0;
else
{
VAR_9 = VAR_22->size / VAR_26[VAR_10].plt_entry_size;
VAR_26[VAR_10].count = VAR_9;
VAR_7 += VAR_9 - VAR_8;
}
VAR_26[VAR_10].contents = VAR_14;
if ((VAR_25 & VAR_42))
VAR_23 = (bfd_vma) -1;
}
if (VAR_7 == 0)
return -1;
VAR_6 = VAR_7 * sizeof (asymbol);
VAR_13 = *VAR_5 = (asymbol *) bfd_zmalloc (VAR_6);
if (VAR_13 == NULL)
{
bad_return:
for (VAR_10 = 0; VAR_26[VAR_10].name != NULL; VAR_10++)
if (VAR_26[VAR_10].contents != NULL)
free (VAR_26[VAR_10].contents);
free (VAR_17);
return -1;
}
if (VAR_23)
{
asection *VAR_43 = bfd_get_section_by_name (VAR_0, "".got.plt"");
if (VAR_43 != NULL)
VAR_23 = VAR_43->vma;
else
{
VAR_43 = bfd_get_section_by_name (VAR_0, "".got"");
if (VAR_43 != NULL)
VAR_23 = VAR_43->vma;
}
if (VAR_23 == (bfd_vma) -1)
goto bad_return;
}
VAR_6 = 0;
VAR_9 = 0;
for (VAR_10 = 0; VAR_26[VAR_10].name != NULL; VAR_10++)
if ((VAR_14 = VAR_26[VAR_10].contents) != NULL)
{
long VAR_44;
bfd_vma VAR_45;
VAR_11 = VAR_26[VAR_10].plt_got_offset;
VAR_12 = VAR_26[VAR_10].plt_entry_size;
VAR_22 = VAR_26[VAR_10].sec;
if ((VAR_26[VAR_10].type & VAR_41))
{
VAR_44 = 1;
VAR_45 = VAR_12;
}
else
{
VAR_44 = 0;
VAR_45 = 0;
}
for (; VAR_44 < VAR_26[VAR_10].count; VAR_44++)
{
int VAR_46;
bfd_vma VAR_47;
long VAR_48, VAR_49, VAR_50;
arelent *VAR_51;
VAR_46 = H_GET_32 (VAR_0, (VAR_14 + VAR_45
+ VAR_11));
VAR_47 = VAR_23 + VAR_46;
VAR_51 = VAR_17[0];
VAR_48 = 0;
VAR_49 = VAR_15;
while ((VAR_48 + 1) < VAR_49)
{
arelent *VAR_52;
VAR_50 = (VAR_48 + VAR_49) / 2;
VAR_52 = VAR_17[VAR_50];
if (VAR_47 > VAR_52->address)
VAR_48 = VAR_50;
else if (VAR_47 < VAR_52->address)
VAR_49 = VAR_50;
else
{
VAR_51 = VAR_52;
break;
}
}
if (VAR_47 == VAR_51->address
&& VAR_51->howto != NULL
&& (VAR_51->howto->type == VAR_53
|| VAR_51->howto->type == VAR_54
|| VAR_51->howto->type == VAR_55))
{
*VAR_13 = **VAR_51->sym_ptr_ptr;
if ((VAR_13->flags & VAR_56) == 0)
VAR_13->flags |= VAR_57;
VAR_13->flags |= VAR_58;
VAR_13->flags &= ~VAR_59;
VAR_13->section = VAR_22;
VAR_13->the_bfd = VAR_22->owner;
VAR_13->value = VAR_45;
VAR_13->udata.p = VAR_51;
VAR_6 += strlen (VAR_13->name) + sizeof (""@plt"");
if (VAR_51->addend != 0)
VAR_6 += sizeof (""+0x"") - 1 + 8;
VAR_9++;
VAR_13++;
}
VAR_45 += VAR_12;
}
}
if (VAR_9 == 0)
goto bad_return;
VAR_7 = VAR_9;
VAR_24 = (char *) bfd_malloc (VAR_6);
if (VAR_13 == NULL)
goto bad_return;
VAR_13 = *VAR_5;
for (VAR_8 = 0; VAR_8 < VAR_7; VAR_8++)
{
arelent *VAR_51 = (arelent *) VAR_13->udata.p;
VAR_13->udata.p = NULL;
VAR_6 = strlen (VAR_13->name);
memcpy (VAR_24, VAR_13->name, VAR_6);
VAR_13->name = VAR_24;
VAR_24 += VAR_6;
if (VAR_51->addend != 0)
{
char VAR_60[30], *VAR_61;
memcpy (VAR_24, ""+0x"", sizeof (""+0x"") - 1);
VAR_24 += sizeof (""+0x"") - 1;
bfd_sprintf_vma (VAR_0, VAR_60, VAR_51->addend);
for (VAR_61 = VAR_60; *VAR_61 == '0'; ++VAR_61)
;
VAR_6 = strlen (VAR_61);
memcpy (VAR_24, VAR_61, VAR_6);
VAR_24 += VAR_6;
}
memcpy (VAR_24, ""@plt"", sizeof (""@plt""));
VAR_24 += sizeof (""@plt"");
VAR_13++;
}
for (VAR_10 = 0; VAR_26[VAR_10].name != NULL; VAR_10++)
if (VAR_26[VAR_10].contents != NULL)
free (VAR_26[VAR_10].contents);
free (VAR_17);
return VAR_7;
}",,"static long
elf_i386_get_synthetic_symtab (bfd *abfd,
			       long symcount ATTRIBUTE_UNUSED,
			       asymbol **syms ATTRIBUTE_UNUSED,
			       long dynsymcount,
			       asymbol **dynsyms,
			       asymbol **ret)
{
  long size, count, i, n;
  int j;
  unsigned int plt_got_offset, plt_entry_size;
  asymbol *s;
  bfd_byte *plt_contents;
  long dynrelcount, relsize;
  arelent **dynrelbuf;
  const struct elf_i386_lazy_plt_layout *lazy_plt;
  const struct elf_i386_non_lazy_plt_layout *non_lazy_plt;
  const struct elf_i386_lazy_plt_layout *lazy_ibt_plt;
  const struct elf_i386_non_lazy_plt_layout *non_lazy_ibt_plt;
  asection *plt;
  bfd_vma got_addr;
  char *names;
  enum elf_i386_plt_type plt_type;
  struct elf_i386_plt plts[] =
    {
      { "".plt"", NULL, NULL, plt_unknown, 0, 0, 0 },
      { "".plt.got"", NULL, NULL, plt_non_lazy, 0, 0, 0 },
      { "".plt.sec"", NULL, NULL, plt_second, 0, 0, 0 },
      { NULL, NULL, NULL, plt_non_lazy, 0, 0, 0 }
    };

  *ret = NULL;

  if ((abfd->flags & (DYNAMIC | EXEC_P)) == 0)
    return 0;

  if (dynsymcount <= 0)
    return 0;

  relsize = bfd_get_dynamic_reloc_upper_bound (abfd);
  if (relsize <= 0)
    return -1;

  dynrelbuf = (arelent **) bfd_malloc (relsize);
  if (dynrelbuf == NULL)
    return -1;

  dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf,
						dynsyms);
  if (dynrelcount <= 0)
    return -1;

  /* Sort the relocs by address.  */
  qsort (dynrelbuf, dynrelcount, sizeof (arelent *), compare_relocs);

  non_lazy_plt = NULL;
  /* Silence GCC 6.  */
  lazy_plt = NULL;
  non_lazy_ibt_plt = NULL;
  lazy_ibt_plt = NULL;
  switch (get_elf_i386_backend_data (abfd)->os)
    {
    case is_normal:
      non_lazy_plt = &elf_i386_non_lazy_plt;
      lazy_ibt_plt = &elf_i386_lazy_ibt_plt;
      non_lazy_ibt_plt = &elf_i386_non_lazy_ibt_plt;
      /* Fall through */
    case is_vxworks:
      lazy_plt = &elf_i386_lazy_plt;
      break;
    case is_nacl:
      lazy_plt = &elf_i386_nacl_plt;
      break;
    }

  got_addr = 0;

  count = 0;
  for (j = 0; plts[j].name != NULL; j++)
    {
      plt = bfd_get_section_by_name (abfd, plts[j].name);
      if (plt == NULL || plt->size == 0)
	continue;

      /* Get the PLT section contents.  */
      plt_contents = (bfd_byte *) bfd_malloc (plt->size);
      if (plt_contents == NULL)
	break;
      if (!bfd_get_section_contents (abfd, (asection *) plt,
				     plt_contents, 0, plt->size))
	{
	  free (plt_contents);
	  break;
	}

      /* Check what kind of PLT it is.  */
      plt_type = plt_unknown;
      if (plts[j].type == plt_unknown
	  && (plt->size >= (lazy_plt->plt0_entry_size
			    + lazy_plt->plt_entry_size)))
	{
	  /* Match lazy PLT first.  */
	  if (memcmp (plt_contents, lazy_plt->plt0_entry,
		      lazy_plt->plt0_got1_offset) == 0)
	    {
	      /* The fist entry in the lazy IBT PLT is the same as the
		 normal lazy PLT.  */
	      if (lazy_ibt_plt != NULL
		  && (memcmp (plt_contents + lazy_ibt_plt->plt0_entry_size,
			      lazy_ibt_plt->plt_entry,
			      lazy_ibt_plt->plt_got_offset) == 0))
		plt_type = plt_lazy | plt_second;
	      else
		plt_type = plt_lazy;
	    }
	  else if (memcmp (plt_contents, lazy_plt->pic_plt0_entry,
			   lazy_plt->plt0_got1_offset) == 0)
	    {
	      /* The fist entry in the PIC lazy IBT PLT is the same as
		 the normal PIC lazy PLT.  */
	      if (lazy_ibt_plt != NULL
		  && (memcmp (plt_contents + lazy_ibt_plt->plt0_entry_size,
			      lazy_ibt_plt->pic_plt_entry,
			      lazy_ibt_plt->plt_got_offset) == 0))
		plt_type = plt_lazy | plt_pic | plt_second;
	      else
		plt_type = plt_lazy | plt_pic;
	    }
	}

      if (non_lazy_plt != NULL
	  && (plt_type == plt_unknown || plt_type == plt_non_lazy)
	  && plt->size >= non_lazy_plt->plt_entry_size)
	{
	  /* Match non-lazy PLT.  */
	  if (memcmp (plt_contents, non_lazy_plt->plt_entry,
		      non_lazy_plt->plt_got_offset) == 0)
	    plt_type = plt_non_lazy;
	  else if (memcmp (plt_contents, non_lazy_plt->pic_plt_entry,
			   non_lazy_plt->plt_got_offset) == 0)
	    plt_type = plt_pic;
	}

      if ((non_lazy_ibt_plt != NULL)
	  && (plt_type == plt_unknown || plt_type == plt_second)
	  && plt->size >= non_lazy_ibt_plt->plt_entry_size)
	{
	  if (memcmp (plt_contents,
		      non_lazy_ibt_plt->plt_entry,
		      non_lazy_ibt_plt->plt_got_offset) == 0)
	    {
	      /* Match IBT PLT.  */
	      plt_type = plt_second;
	      non_lazy_plt = non_lazy_ibt_plt;
	    }
	  else if (memcmp (plt_contents,
			   non_lazy_ibt_plt->pic_plt_entry,
			   non_lazy_ibt_plt->plt_got_offset) == 0)
	    {
	      /* Match PIC IBT PLT.  */
	      plt_type = plt_second | plt_pic;
	      non_lazy_plt = non_lazy_ibt_plt;
	    }
	}

      if (plt_type == plt_unknown)
	continue;

      plts[j].sec = plt;
      plts[j].type = plt_type;

      if ((plt_type & plt_lazy))
	{
	  plts[j].plt_got_offset = lazy_plt->plt_got_offset;
	  plts[j].plt_entry_size = lazy_plt->plt_entry_size;
	  /* Skip PLT0 in lazy PLT.  */
	  i = 1;
	}
      else
	{
	  plts[j].plt_got_offset = non_lazy_plt->plt_got_offset;
	  plts[j].plt_entry_size = non_lazy_plt->plt_entry_size;
	  i = 0;
	}

      /* Skip lazy PLT when the second PLT is used.  */
      if ((plt_type & (plt_lazy | plt_second))
	  == (plt_lazy | plt_second))
	plts[j].count = 0;
      else
	{
	  n = plt->size / plts[j].plt_entry_size;
	  plts[j].count = n;
	  count += n - i;
	}

      plts[j].contents = plt_contents;

      /* The _GLOBAL_OFFSET_TABLE_ address is needed.  */
      if ((plt_type & plt_pic))
	got_addr = (bfd_vma) -1;
    }

  if (count == 0)
    return -1;

  size = count * sizeof (asymbol);
  s = *ret = (asymbol *) bfd_zmalloc (size);
  if (s == NULL)
    {
bad_return:
      for (j = 0; plts[j].name != NULL; j++)
	if (plts[j].contents != NULL)
	  free (plts[j].contents);
      free (dynrelbuf);
      return -1;
    }

  if (got_addr)
    {
      /* Check .got.plt and then .got to get the _GLOBAL_OFFSET_TABLE_
	 address.  */
      asection *sec = bfd_get_section_by_name (abfd, "".got.plt"");
      if (sec != NULL)
	got_addr = sec->vma;
      else
	{
	  sec = bfd_get_section_by_name (abfd, "".got"");
	  if (sec != NULL)
	    got_addr = sec->vma;
	}

      if (got_addr == (bfd_vma) -1)
	goto bad_return;
    }

  /* Check for each PLT section.  */
  size = 0;
  n = 0;
  for (j = 0; plts[j].name != NULL; j++)
    if ((plt_contents = plts[j].contents) != NULL)
      {
	long k;
	bfd_vma offset;

	plt_got_offset = plts[j].plt_got_offset;
	plt_entry_size = plts[j].plt_entry_size;

	plt = plts[j].sec;

	if ((plts[j].type & plt_lazy))
	  {
	    /* Skip PLT0 in lazy PLT.  */
	    k = 1;
	    offset = plt_entry_size;
	  }
	else
	  {
	    k = 0;
	    offset = 0;
	  }

	/* Check each PLT entry against dynamic relocations.  */
	for (; k < plts[j].count; k++)
	  {
	    int off;
	    bfd_vma got_vma;
	    long min, max, mid;
	    arelent *p;

	    /* Get the GOT offset, a signed 32-bit integer.  */
	    off = H_GET_32 (abfd, (plt_contents + offset
				   + plt_got_offset));
	    got_vma = got_addr + off;

	    /* Binary search.  */
	    p = dynrelbuf[0];
	    min = 0;
	    max = dynrelcount;
	    while ((min + 1) < max)
	      {
		arelent *r;

		mid = (min + max) / 2;
		r = dynrelbuf[mid];
		if (got_vma > r->address)
		  min = mid;
		else if (got_vma < r->address)
		  max = mid;
		else
		  {
		    p = r;
		    break;
		  }
	      }

	    /* Skip unknown relocation.  PR 17512: file: bc9d6cf5.  */
	    if (got_vma == p->address
		&& p->howto != NULL
		&& (p->howto->type == R_386_JUMP_SLOT
		    || p->howto->type == R_386_GLOB_DAT
		    || p->howto->type == R_386_IRELATIVE))
	      {
		*s = **p->sym_ptr_ptr;
		/* Undefined syms won't have BSF_LOCAL or BSF_GLOBAL
		   set.  Since we are defining a symbol, ensure one
		   of them is set.  */
		if ((s->flags & BSF_LOCAL) == 0)
		  s->flags |= BSF_GLOBAL;
		s->flags |= BSF_SYNTHETIC;
		/* This is no longer a section symbol.  */
		s->flags &= ~BSF_SECTION_SYM;
		s->section = plt;
		s->the_bfd = plt->owner;
		s->value = offset;
		/* Store relocation for later use.  */
		s->udata.p = p;
		/* Add @plt to function name later.  */
		size += strlen (s->name) + sizeof (""@plt"");
		if (p->addend != 0)
		  size += sizeof (""+0x"") - 1 + 8;
		n++;
		s++;
	      }
	    offset += plt_entry_size;
	  }
      }

  /* PLT entries with R_386_TLS_DESC relocations are skipped.  */
  if (n == 0)
    goto bad_return;

  count = n;

  /* Allocate space for @plt suffixes.  */
  names = (char *) bfd_malloc (size);
  if (s == NULL)
    goto bad_return;

  s = *ret;
  for (i = 0; i < count; i++)
    {
      /* Add @plt to function name.  */
      arelent *p = (arelent *) s->udata.p;
      /* Clear it now.  */
      s->udata.p = NULL;
      size = strlen (s->name);
      memcpy (names, s->name, size);
      s->name = names;
      names += size;
      if (p->addend != 0)
	{
	  char buf[30], *a;

	  memcpy (names, ""+0x"", sizeof (""+0x"") - 1);
	  names += sizeof (""+0x"") - 1;
	  bfd_sprintf_vma (abfd, buf, p->addend);
	  for (a = buf; *a == '0'; ++a)
	    ;
	  size = strlen (a);
	  memcpy (names, a, size);
	  names += size;
	}
      memcpy (names, ""@plt"", sizeof (""@plt""));
      names += sizeof (""@plt"");
      s++;
    }

  for (j = 0; plts[j].name != NULL; j++)
    if (plts[j].contents != NULL)
      free (plts[j].contents);

  free (dynrelbuf);

  return count;
}","static long
elf_i386_get_synthetic_symtab (bfd *VAR_0,
			       long VAR_1 ATTRIBUTE_UNUSED,
			       asymbol **VAR_2 ATTRIBUTE_UNUSED,
			       long VAR_3,
			       asymbol **VAR_4,
			       asymbol **VAR_5)
{
  long VAR_6, VAR_7, VAR_8, VAR_9;
  int VAR_10;
  unsigned int VAR_11, VAR_12;
  asymbol *VAR_13;
  bfd_byte *VAR_14;
  long VAR_15, VAR_16;
  arelent **VAR_17;
  const struct elf_i386_lazy_plt_layout *VAR_18;
  const struct elf_i386_non_lazy_plt_layout *VAR_19;
  const struct elf_i386_lazy_plt_layout *VAR_20;
  const struct elf_i386_non_lazy_plt_layout *VAR_21;
  asection *VAR_22;
  bfd_vma VAR_23;
  char *VAR_24;
  enum elf_i386_plt_type VAR_25;
  struct elf_i386_plt VAR_26[] =
    {
      { "".plt"", NULL, NULL, VAR_27, 0, 0, 0 },
      { "".plt.got"", NULL, NULL, VAR_28, 0, 0, 0 },
      { "".plt.sec"", NULL, NULL, VAR_29, 0, 0, 0 },
      { NULL, NULL, NULL, VAR_28, 0, 0, 0 }
    };

  *VAR_5 = NULL;

  if ((VAR_0->flags & (VAR_30 | VAR_31)) == 0)
    return 0;

  if (VAR_3 <= 0)
    return 0;

  VAR_16 = bfd_get_dynamic_reloc_upper_bound (VAR_0);
  if (VAR_16 <= 0)
    return -1;

  VAR_17 = (arelent **) bfd_malloc (VAR_16);
  if (VAR_17 == NULL)
    return -1;

  VAR_15 = bfd_canonicalize_dynamic_reloc (VAR_0, VAR_17,
						VAR_4);
  if (VAR_15 <= 0)
    return -1;

  /* COMMENT_0 */
  qsort (VAR_17, VAR_15, sizeof (arelent *), VAR_32);

  VAR_19 = NULL;
  /* COMMENT_1 */
  VAR_18 = NULL;
  VAR_21 = NULL;
  VAR_20 = NULL;
  switch (get_elf_i386_backend_data (VAR_0)->os)
    {
    case VAR_33:
      VAR_19 = &VAR_34;
      VAR_20 = &VAR_35;
      VAR_21 = &VAR_36;
      /* COMMENT_2 */
    case VAR_37:
      VAR_18 = &VAR_38;
      break;
    case VAR_39:
      VAR_18 = &VAR_40;
      break;
    }

  VAR_23 = 0;

  VAR_7 = 0;
  for (VAR_10 = 0; VAR_26[VAR_10].name != NULL; VAR_10++)
    {
      VAR_22 = bfd_get_section_by_name (VAR_0, VAR_26[VAR_10].name);
      if (VAR_22 == NULL || VAR_22->size == 0)
	continue;

      /* COMMENT_3 */
      VAR_14 = (bfd_byte *) bfd_malloc (VAR_22->size);
      if (VAR_14 == NULL)
	break;
      if (!bfd_get_section_contents (VAR_0, (asection *) VAR_22,
				     VAR_14, 0, VAR_22->size))
	{
	  free (VAR_14);
	  break;
	}

      /* COMMENT_4 */
      VAR_25 = VAR_27;
      if (VAR_26[VAR_10].type == VAR_27
	  && (VAR_22->size >= (VAR_18->plt0_entry_size
			    + VAR_18->plt_entry_size)))
	{
	  /* COMMENT_5 */
	  if (memcmp (VAR_14, VAR_18->plt0_entry,
		      VAR_18->plt0_got1_offset) == 0)
	    {
	      /* COMMENT_6 */
                       
	      if (VAR_20 != NULL
		  && (memcmp (VAR_14 + VAR_20->plt0_entry_size,
			      VAR_20->plt_entry,
			      VAR_20->plt_got_offset) == 0))
		VAR_25 = VAR_41 | VAR_29;
	      else
		VAR_25 = VAR_41;
	    }
	  else if (memcmp (VAR_14, VAR_18->pic_plt0_entry,
			   VAR_18->plt0_got1_offset) == 0)
	    {
	      /* COMMENT_8 */
                               
	      if (VAR_20 != NULL
		  && (memcmp (VAR_14 + VAR_20->plt0_entry_size,
			      VAR_20->pic_plt_entry,
			      VAR_20->plt_got_offset) == 0))
		VAR_25 = VAR_41 | VAR_42 | VAR_29;
	      else
		VAR_25 = VAR_41 | VAR_42;
	    }
	}

      if (VAR_19 != NULL
	  && (VAR_25 == VAR_27 || VAR_25 == VAR_28)
	  && VAR_22->size >= VAR_19->plt_entry_size)
	{
	  /* COMMENT_10 */
	  if (memcmp (VAR_14, VAR_19->plt_entry,
		      VAR_19->plt_got_offset) == 0)
	    VAR_25 = VAR_28;
	  else if (memcmp (VAR_14, VAR_19->pic_plt_entry,
			   VAR_19->plt_got_offset) == 0)
	    VAR_25 = VAR_42;
	}

      if ((VAR_21 != NULL)
	  && (VAR_25 == VAR_27 || VAR_25 == VAR_29)
	  && VAR_22->size >= VAR_21->plt_entry_size)
	{
	  if (memcmp (VAR_14,
		      VAR_21->plt_entry,
		      VAR_21->plt_got_offset) == 0)
	    {
	      /* COMMENT_11 */
	      VAR_25 = VAR_29;
	      VAR_19 = VAR_21;
	    }
	  else if (memcmp (VAR_14,
			   VAR_21->pic_plt_entry,
			   VAR_21->plt_got_offset) == 0)
	    {
	      /* COMMENT_12 */
	      VAR_25 = VAR_29 | VAR_42;
	      VAR_19 = VAR_21;
	    }
	}

      if (VAR_25 == VAR_27)
	continue;

      VAR_26[VAR_10].sec = VAR_22;
      VAR_26[VAR_10].type = VAR_25;

      if ((VAR_25 & VAR_41))
	{
	  VAR_26[VAR_10].plt_got_offset = VAR_18->plt_got_offset;
	  VAR_26[VAR_10].plt_entry_size = VAR_18->plt_entry_size;
	  /* COMMENT_13 */
	  VAR_8 = 1;
	}
      else
	{
	  VAR_26[VAR_10].plt_got_offset = VAR_19->plt_got_offset;
	  VAR_26[VAR_10].plt_entry_size = VAR_19->plt_entry_size;
	  VAR_8 = 0;
	}

      /* COMMENT_14 */
      if ((VAR_25 & (VAR_41 | VAR_29))
	  == (VAR_41 | VAR_29))
	VAR_26[VAR_10].count = 0;
      else
	{
	  VAR_9 = VAR_22->size / VAR_26[VAR_10].plt_entry_size;
	  VAR_26[VAR_10].count = VAR_9;
	  VAR_7 += VAR_9 - VAR_8;
	}

      VAR_26[VAR_10].contents = VAR_14;

      /* COMMENT_15 */
      if ((VAR_25 & VAR_42))
	VAR_23 = (bfd_vma) -1;
    }

  if (VAR_7 == 0)
    return -1;

  VAR_6 = VAR_7 * sizeof (asymbol);
  VAR_13 = *VAR_5 = (asymbol *) bfd_zmalloc (VAR_6);
  if (VAR_13 == NULL)
    {
bad_return:
      for (VAR_10 = 0; VAR_26[VAR_10].name != NULL; VAR_10++)
	if (VAR_26[VAR_10].contents != NULL)
	  free (VAR_26[VAR_10].contents);
      free (VAR_17);
      return -1;
    }

  if (VAR_23)
    {
      /* COMMENT_16 */
              
      asection *VAR_43 = bfd_get_section_by_name (VAR_0, "".got.plt"");
      if (VAR_43 != NULL)
	VAR_23 = VAR_43->vma;
      else
	{
	  VAR_43 = bfd_get_section_by_name (VAR_0, "".got"");
	  if (VAR_43 != NULL)
	    VAR_23 = VAR_43->vma;
	}

      if (VAR_23 == (bfd_vma) -1)
	goto bad_return;
    }

  /* COMMENT_18 */
  VAR_6 = 0;
  VAR_9 = 0;
  for (VAR_10 = 0; VAR_26[VAR_10].name != NULL; VAR_10++)
    if ((VAR_14 = VAR_26[VAR_10].contents) != NULL)
      {
	long VAR_44;
	bfd_vma VAR_45;

	VAR_11 = VAR_26[VAR_10].plt_got_offset;
	VAR_12 = VAR_26[VAR_10].plt_entry_size;

	VAR_22 = VAR_26[VAR_10].sec;

	if ((VAR_26[VAR_10].type & VAR_41))
	  {
	    /* COMMENT_13 */
	    VAR_44 = 1;
	    VAR_45 = VAR_12;
	  }
	else
	  {
	    VAR_44 = 0;
	    VAR_45 = 0;
	  }

	/* COMMENT_19 */
	for (; VAR_44 < VAR_26[VAR_10].count; VAR_44++)
	  {
	    int VAR_46;
	    bfd_vma VAR_47;
	    long VAR_48, VAR_49, VAR_50;
	    arelent *VAR_51;

	    /* COMMENT_20 */
	    VAR_46 = H_GET_32 (VAR_0, (VAR_14 + VAR_45
				   + VAR_11));
	    VAR_47 = VAR_23 + VAR_46;

	    /* COMMENT_21 */
	    VAR_51 = VAR_17[0];
	    VAR_48 = 0;
	    VAR_49 = VAR_15;
	    while ((VAR_48 + 1) < VAR_49)
	      {
		arelent *VAR_52;

		VAR_50 = (VAR_48 + VAR_49) / 2;
		VAR_52 = VAR_17[VAR_50];
		if (VAR_47 > VAR_52->address)
		  VAR_48 = VAR_50;
		else if (VAR_47 < VAR_52->address)
		  VAR_49 = VAR_50;
		else
		  {
		    VAR_51 = VAR_52;
		    break;
		  }
	      }

	    /* COMMENT_22 */
	    if (VAR_47 == VAR_51->address
		&& VAR_51->howto != NULL
		&& (VAR_51->howto->type == VAR_53
		    || VAR_51->howto->type == VAR_54
		    || VAR_51->howto->type == VAR_55))
	      {
		*VAR_13 = **VAR_51->sym_ptr_ptr;
		/* COMMENT_23 */
                                                     
                        
		if ((VAR_13->flags & VAR_56) == 0)
		  VAR_13->flags |= VAR_57;
		VAR_13->flags |= VAR_58;
		/* COMMENT_26 */
		VAR_13->flags &= ~VAR_59;
		VAR_13->section = VAR_22;
		VAR_13->the_bfd = VAR_22->owner;
		VAR_13->value = VAR_45;
		/* COMMENT_27 */
		VAR_13->udata.p = VAR_51;
		/* COMMENT_28 */
		VAR_6 += strlen (VAR_13->name) + sizeof (""@plt"");
		if (VAR_51->addend != 0)
		  VAR_6 += sizeof (""+0x"") - 1 + 8;
		VAR_9++;
		VAR_13++;
	      }
	    VAR_45 += VAR_12;
	  }
      }

  /* COMMENT_29 */
  if (VAR_9 == 0)
    goto bad_return;

  VAR_7 = VAR_9;

  /* COMMENT_30 */
  VAR_24 = (char *) bfd_malloc (VAR_6);
  if (VAR_13 == NULL)
    goto bad_return;

  VAR_13 = *VAR_5;
  for (VAR_8 = 0; VAR_8 < VAR_7; VAR_8++)
    {
      /* COMMENT_31 */
      arelent *VAR_51 = (arelent *) VAR_13->udata.p;
      /* COMMENT_32 */
      VAR_13->udata.p = NULL;
      VAR_6 = strlen (VAR_13->name);
      memcpy (VAR_24, VAR_13->name, VAR_6);
      VAR_13->name = VAR_24;
      VAR_24 += VAR_6;
      if (VAR_51->addend != 0)
	{
	  char VAR_60[30], *VAR_61;

	  memcpy (VAR_24, ""+0x"", sizeof (""+0x"") - 1);
	  VAR_24 += sizeof (""+0x"") - 1;
	  bfd_sprintf_vma (VAR_0, VAR_60, VAR_51->addend);
	  for (VAR_61 = VAR_60; *VAR_61 == '0'; ++VAR_61)
	    ;
	  VAR_6 = strlen (VAR_61);
	  memcpy (VAR_24, VAR_61, VAR_6);
	  VAR_24 += VAR_6;
	}
      memcpy (VAR_24, ""@plt"", sizeof (""@plt""));
      VAR_24 += sizeof (""@plt"");
      VAR_13++;
    }

  for (VAR_10 = 0; VAR_26[VAR_10].name != NULL; VAR_10++)
    if (VAR_26[VAR_10].contents != NULL)
      free (VAR_26[VAR_10].contents);

  free (VAR_17);

  return VAR_7;
}",,"--- func_before
+++ func_after
@@ -47,7 +47,7 @@
 
   dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf,
 						dynsyms);
-  if (dynrelcount < 0)
+  if (dynrelcount <= 0)
     return -1;
 
   /* Sort the relocs by address.  */","{'deleted_lines': ['  if (dynrelcount < 0)'], 'added_lines': ['  if (dynrelcount <= 0)']}",True,"The *_get_synthetic_symtab functions in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, mishandle the failure of a certain canonicalization step, which allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted ELF file, related to elf32-i386.c and elf64-x86-64.c.",5.5,MEDIUM,1,test,,5
CVE-2017-14974,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,binutils-gdb,"
x86: Return -1 if bfd_canonicalize_dynamic_reloc returns 0

Stop if bfd_canonicalize_dynamic_reloc returns 0.

	PR binutils/22163
	* elf32-i386.c (elf_i386_get_synthetic_symtab): Also return -1
	if bfd_canonicalize_dynamic_reloc returns 0.
	* elf64-x86-64.c (elf_x86_64_get_synthetic_symtab): Likewise.

(cherry picked from commit b69e9267d15a09ce3f3d4599eae2952dfc6df502)
",e70c19e3a4c26e9c1ebf0c9170d105039b56d7cf,https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=e70c19e3a4c26e9c1ebf0c9170d105039b56d7cf,bfd/elf64-x86-64.c,elf_x86_64_get_synthetic_symtab,"static long
elf_x86_64_get_synthetic_symtab (bfd *abfd,
long symcount ATTRIBUTE_UNUSED,
asymbol **syms ATTRIBUTE_UNUSED,
long dynsymcount,
asymbol **dynsyms,
asymbol **ret)
{
long size, count, i, n;
int j;
unsigned int plt_got_offset, plt_entry_size, plt_got_insn_size;
asymbol *s;
bfd_byte *plt_contents;
long dynrelcount, relsize;
arelent **dynrelbuf;
const struct elf_x86_64_lazy_plt_layout *lazy_plt;
const struct elf_x86_64_non_lazy_plt_layout *non_lazy_plt;
const struct elf_x86_64_lazy_plt_layout *lazy_bnd_plt;
const struct elf_x86_64_non_lazy_plt_layout *non_lazy_bnd_plt;
const struct elf_x86_64_lazy_plt_layout *lazy_ibt_plt;
const struct elf_x86_64_non_lazy_plt_layout *non_lazy_ibt_plt;
asection *plt;
char *names;
enum elf_x86_64_plt_type plt_type;
struct elf_x86_64_plt plts[] =
{
{ "".plt"", NULL, NULL, plt_unknown, 0, 0, 0, 0 },
{ "".plt.got"", NULL, NULL, plt_non_lazy, 0, 0, 0, 0 },
{ "".plt.sec"", NULL, NULL, plt_second, 0, 0, 0, 0 },
{ "".plt.bnd"", NULL, NULL, plt_second, 0, 0, 0, 0 },
{ NULL, NULL, NULL, plt_non_lazy, 0, 0, 0, 0 }
};
*ret = NULL;
if ((abfd->flags & (DYNAMIC | EXEC_P)) == 0)
return 0;
if (dynsymcount <= 0)
return 0;
relsize = bfd_get_dynamic_reloc_upper_bound (abfd);
if (relsize <= 0)
return -1;
dynrelbuf = (arelent **) bfd_malloc (relsize);
if (dynrelbuf == NULL)
return -1;
dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf,
dynsyms);
if (dynrelcount < 0)
return -1;
qsort (dynrelbuf, dynrelcount, sizeof (arelent *), compare_relocs);
if (get_elf_x86_64_backend_data (abfd)->os == is_normal)
{
lazy_plt = &elf_x86_64_lazy_plt;
non_lazy_plt = &elf_x86_64_non_lazy_plt;
lazy_bnd_plt = &elf_x86_64_lazy_bnd_plt;
non_lazy_bnd_plt = &elf_x86_64_non_lazy_bnd_plt;
if (ABI_64_P (abfd))
{
lazy_ibt_plt = &elf_x86_64_lazy_ibt_plt;
non_lazy_ibt_plt = &elf_x86_64_non_lazy_ibt_plt;
}
else
{
lazy_ibt_plt = &elf_x32_lazy_ibt_plt;
non_lazy_ibt_plt = &elf_x32_non_lazy_ibt_plt;
}
}
else
{
lazy_plt = &elf_x86_64_nacl_plt;
non_lazy_plt = NULL;
lazy_bnd_plt = NULL;
non_lazy_bnd_plt = NULL;
lazy_ibt_plt = NULL;
non_lazy_ibt_plt = NULL;
}
count = 0;
for (j = 0; plts[j].name != NULL; j++)
{
plt = bfd_get_section_by_name (abfd, plts[j].name);
if (plt == NULL || plt->size == 0)
continue;
plt_contents = (bfd_byte *) bfd_malloc (plt->size);
if (plt_contents == NULL)
break;
if (!bfd_get_section_contents (abfd, (asection *) plt,
plt_contents, 0, plt->size))
{
free (plt_contents);
break;
}
plt_type = plt_unknown;
if (plts[j].type == plt_unknown
&& (plt->size >= (lazy_plt->plt_entry_size
+ lazy_plt->plt_entry_size)))
{
if ((memcmp (plt_contents, lazy_plt->plt0_entry,
lazy_plt->plt0_got1_offset) == 0)
&& (memcmp (plt_contents + 6, lazy_plt->plt0_entry + 6,
2) == 0))
plt_type = plt_lazy;
else if (lazy_bnd_plt != NULL
&& (memcmp (plt_contents, lazy_bnd_plt->plt0_entry,
lazy_bnd_plt->plt0_got1_offset) == 0)
&& (memcmp (plt_contents + 6,
lazy_bnd_plt->plt0_entry + 6, 3) == 0))
{
plt_type = plt_lazy | plt_second;
if ((memcmp (plt_contents + lazy_ibt_plt->plt_entry_size,
lazy_ibt_plt->plt_entry,
lazy_ibt_plt->plt_got_offset) == 0))
lazy_plt = lazy_ibt_plt;
else
lazy_plt = lazy_bnd_plt;
}
}
if (non_lazy_plt != NULL
&& (plt_type == plt_unknown || plt_type == plt_non_lazy)
&& plt->size >= non_lazy_plt->plt_entry_size)
{
if (memcmp (plt_contents, non_lazy_plt->plt_entry,
non_lazy_plt->plt_got_offset) == 0)
plt_type = plt_non_lazy;
}
if (plt_type == plt_unknown || plt_type == plt_second)
{
if (non_lazy_bnd_plt != NULL
&& plt->size >= non_lazy_bnd_plt->plt_entry_size
&& (memcmp (plt_contents, non_lazy_bnd_plt->plt_entry,
non_lazy_bnd_plt->plt_got_offset) == 0))
{
plt_type = plt_second;
non_lazy_plt = non_lazy_bnd_plt;
}
else if (non_lazy_ibt_plt != NULL
&& plt->size >= non_lazy_ibt_plt->plt_entry_size
&& (memcmp (plt_contents,
non_lazy_ibt_plt->plt_entry,
non_lazy_ibt_plt->plt_got_offset) == 0))
{
plt_type = plt_second;
non_lazy_plt = non_lazy_ibt_plt;
}
}
if (plt_type == plt_unknown)
continue;
plts[j].sec = plt;
plts[j].type = plt_type;
if ((plt_type & plt_lazy))
{
plts[j].plt_got_offset = lazy_plt->plt_got_offset;
plts[j].plt_got_insn_size = lazy_plt->plt_got_insn_size;
plts[j].plt_entry_size = lazy_plt->plt_entry_size;
i = 1;
}
else
{
plts[j].plt_got_offset = non_lazy_plt->plt_got_offset;
plts[j].plt_got_insn_size = non_lazy_plt->plt_got_insn_size;
plts[j].plt_entry_size = non_lazy_plt->plt_entry_size;
i = 0;
}
if (plt_type == (plt_lazy | plt_second))
plts[j].count = 0;
else
{
n = plt->size / plts[j].plt_entry_size;
plts[j].count = n;
count += n - i;
}
plts[j].contents = plt_contents;
}
if (count == 0)
return -1;
size = count * sizeof (asymbol);
s = *ret = (asymbol *) bfd_zmalloc (size);
if (s == NULL)
{
bad_return:
for (j = 0; plts[j].name != NULL; j++)
if (plts[j].contents != NULL)
free (plts[j].contents);
free (dynrelbuf);
return -1;
}
size = 0;
n = 0;
for (j = 0; plts[j].name != NULL; j++)
if ((plt_contents = plts[j].contents) != NULL)
{
long k;
bfd_vma offset;
plt_got_offset = plts[j].plt_got_offset;
plt_got_insn_size = plts[j].plt_got_insn_size;
plt_entry_size = plts[j].plt_entry_size;
plt = plts[j].sec;
if ((plts[j].type & plt_lazy))
{
k = 1;
offset = plt_entry_size;
}
else
{
k = 0;
offset = 0;
}
for (; k < plts[j].count; k++)
{
int off;
bfd_vma got_vma;
long min, max, mid;
arelent *p;
off = H_GET_32 (abfd, (plt_contents + offset
+ plt_got_offset));
got_vma = plt->vma + offset + off + plt_got_insn_size;
p = dynrelbuf[0];
min = 0;
max = dynrelcount;
while ((min + 1) < max)
{
arelent *r;
mid = (min + max) / 2;
r = dynrelbuf[mid];
if (got_vma > r->address)
min = mid;
else if (got_vma < r->address)
max = mid;
else
{
p = r;
break;
}
}
if (got_vma == p->address
&& p->howto != NULL
&& (p->howto->type == R_X86_64_JUMP_SLOT
|| p->howto->type == R_X86_64_GLOB_DAT
|| p->howto->type == R_X86_64_IRELATIVE))
{
*s = **p->sym_ptr_ptr;
if ((s->flags & BSF_LOCAL) == 0)
s->flags |= BSF_GLOBAL;
s->flags |= BSF_SYNTHETIC;
s->flags &= ~BSF_SECTION_SYM;
s->section = plt;
s->the_bfd = plt->owner;
s->value = offset;
s->udata.p = p;
size += strlen (s->name) + sizeof (""@plt"");
if (p->addend != 0)
size += sizeof (""+0x"") - 1 + 8 + 8 * ABI_64_P (abfd);
n++;
s++;
}
offset += plt_entry_size;
}
}
if (n == 0)
goto bad_return;
count = n;
names = (char *) bfd_malloc (size);
if (s == NULL)
goto bad_return;
s = *ret;
for (i = 0; i < count; i++)
{
arelent *p = (arelent *) s->udata.p;
s->udata.p = NULL;
size = strlen (s->name);
memcpy (names, s->name, size);
s->name = names;
names += size;
if (p->addend != 0)
{
char buf[30], *a;
memcpy (names, ""+0x"", sizeof (""+0x"") - 1);
names += sizeof (""+0x"") - 1;
bfd_sprintf_vma (abfd, buf, p->addend);
for (a = buf; *a == '0'; ++a)
;
size = strlen (a);
memcpy (names, a, size);
names += size;
}
memcpy (names, ""@plt"", sizeof (""@plt""));
names += sizeof (""@plt"");
s++;
}
for (j = 0; plts[j].name != NULL; j++)
if (plts[j].contents != NULL)
free (plts[j].contents);
free (dynrelbuf);
return count;
}","static long
elf_x86_64_get_synthetic_symtab (bfd *VAR_0,
long VAR_1 ATTRIBUTE_UNUSED,
asymbol **VAR_2 ATTRIBUTE_UNUSED,
long VAR_3,
asymbol **VAR_4,
asymbol **VAR_5)
{
long VAR_6, VAR_7, VAR_8, VAR_9;
int VAR_10;
unsigned int VAR_11, VAR_12, VAR_13;
asymbol *VAR_14;
bfd_byte *VAR_15;
long VAR_16, VAR_17;
arelent **VAR_18;
const struct elf_x86_64_lazy_plt_layout *VAR_19;
const struct elf_x86_64_non_lazy_plt_layout *VAR_20;
const struct elf_x86_64_lazy_plt_layout *VAR_21;
const struct elf_x86_64_non_lazy_plt_layout *VAR_22;
const struct elf_x86_64_lazy_plt_layout *VAR_23;
const struct elf_x86_64_non_lazy_plt_layout *VAR_24;
asection *VAR_25;
char *VAR_26;
enum elf_x86_64_plt_type VAR_27;
struct elf_x86_64_plt VAR_28[] =
{
{ "".plt"", NULL, NULL, VAR_29, 0, 0, 0, 0 },
{ "".plt.got"", NULL, NULL, VAR_30, 0, 0, 0, 0 },
{ "".plt.sec"", NULL, NULL, VAR_31, 0, 0, 0, 0 },
{ "".plt.bnd"", NULL, NULL, VAR_31, 0, 0, 0, 0 },
{ NULL, NULL, NULL, VAR_30, 0, 0, 0, 0 }
};
*VAR_5 = NULL;
if ((VAR_0->flags & (VAR_32 | VAR_33)) == 0)
return 0;
if (VAR_3 <= 0)
return 0;
VAR_17 = bfd_get_dynamic_reloc_upper_bound (VAR_0);
if (VAR_17 <= 0)
return -1;
VAR_18 = (arelent **) bfd_malloc (VAR_17);
if (VAR_18 == NULL)
return -1;
VAR_16 = bfd_canonicalize_dynamic_reloc (VAR_0, VAR_18,
VAR_4);
if (VAR_16 < 0)
return -1;
qsort (VAR_18, VAR_16, sizeof (arelent *), VAR_34);
if (get_elf_x86_64_backend_data (VAR_0)->os == VAR_35)
{
VAR_19 = &VAR_36;
VAR_20 = &VAR_37;
VAR_21 = &VAR_38;
VAR_22 = &VAR_39;
if (ABI_64_P (VAR_0))
{
VAR_23 = &VAR_40;
VAR_24 = &VAR_41;
}
else
{
VAR_23 = &VAR_42;
VAR_24 = &VAR_43;
}
}
else
{
VAR_19 = &VAR_44;
VAR_20 = NULL;
VAR_21 = NULL;
VAR_22 = NULL;
VAR_23 = NULL;
VAR_24 = NULL;
}
VAR_7 = 0;
for (VAR_10 = 0; VAR_28[VAR_10].name != NULL; VAR_10++)
{
VAR_25 = bfd_get_section_by_name (VAR_0, VAR_28[VAR_10].name);
if (VAR_25 == NULL || VAR_25->size == 0)
continue;
VAR_15 = (bfd_byte *) bfd_malloc (VAR_25->size);
if (VAR_15 == NULL)
break;
if (!bfd_get_section_contents (VAR_0, (asection *) VAR_25,
VAR_15, 0, VAR_25->size))
{
free (VAR_15);
break;
}
VAR_27 = VAR_29;
if (VAR_28[VAR_10].type == VAR_29
&& (VAR_25->size >= (VAR_19->plt_entry_size
+ VAR_19->plt_entry_size)))
{
if ((memcmp (VAR_15, VAR_19->plt0_entry,
VAR_19->plt0_got1_offset) == 0)
&& (memcmp (VAR_15 + 6, VAR_19->plt0_entry + 6,
2) == 0))
VAR_27 = VAR_45;
else if (VAR_21 != NULL
&& (memcmp (VAR_15, VAR_21->plt0_entry,
VAR_21->plt0_got1_offset) == 0)
&& (memcmp (VAR_15 + 6,
VAR_21->plt0_entry + 6, 3) == 0))
{
VAR_27 = VAR_45 | VAR_31;
if ((memcmp (VAR_15 + VAR_23->plt_entry_size,
VAR_23->plt_entry,
VAR_23->plt_got_offset) == 0))
VAR_19 = VAR_23;
else
VAR_19 = VAR_21;
}
}
if (VAR_20 != NULL
&& (VAR_27 == VAR_29 || VAR_27 == VAR_30)
&& VAR_25->size >= VAR_20->plt_entry_size)
{
if (memcmp (VAR_15, VAR_20->plt_entry,
VAR_20->plt_got_offset) == 0)
VAR_27 = VAR_30;
}
if (VAR_27 == VAR_29 || VAR_27 == VAR_31)
{
if (VAR_22 != NULL
&& VAR_25->size >= VAR_22->plt_entry_size
&& (memcmp (VAR_15, VAR_22->plt_entry,
VAR_22->plt_got_offset) == 0))
{
VAR_27 = VAR_31;
VAR_20 = VAR_22;
}
else if (VAR_24 != NULL
&& VAR_25->size >= VAR_24->plt_entry_size
&& (memcmp (VAR_15,
VAR_24->plt_entry,
VAR_24->plt_got_offset) == 0))
{
VAR_27 = VAR_31;
VAR_20 = VAR_24;
}
}
if (VAR_27 == VAR_29)
continue;
VAR_28[VAR_10].sec = VAR_25;
VAR_28[VAR_10].type = VAR_27;
if ((VAR_27 & VAR_45))
{
VAR_28[VAR_10].plt_got_offset = VAR_19->plt_got_offset;
VAR_28[VAR_10].plt_got_insn_size = VAR_19->plt_got_insn_size;
VAR_28[VAR_10].plt_entry_size = VAR_19->plt_entry_size;
VAR_8 = 1;
}
else
{
VAR_28[VAR_10].plt_got_offset = VAR_20->plt_got_offset;
VAR_28[VAR_10].plt_got_insn_size = VAR_20->plt_got_insn_size;
VAR_28[VAR_10].plt_entry_size = VAR_20->plt_entry_size;
VAR_8 = 0;
}
if (VAR_27 == (VAR_45 | VAR_31))
VAR_28[VAR_10].count = 0;
else
{
VAR_9 = VAR_25->size / VAR_28[VAR_10].plt_entry_size;
VAR_28[VAR_10].count = VAR_9;
VAR_7 += VAR_9 - VAR_8;
}
VAR_28[VAR_10].contents = VAR_15;
}
if (VAR_7 == 0)
return -1;
VAR_6 = VAR_7 * sizeof (asymbol);
VAR_14 = *VAR_5 = (asymbol *) bfd_zmalloc (VAR_6);
if (VAR_14 == NULL)
{
bad_return:
for (VAR_10 = 0; VAR_28[VAR_10].name != NULL; VAR_10++)
if (VAR_28[VAR_10].contents != NULL)
free (VAR_28[VAR_10].contents);
free (VAR_18);
return -1;
}
VAR_6 = 0;
VAR_9 = 0;
for (VAR_10 = 0; VAR_28[VAR_10].name != NULL; VAR_10++)
if ((VAR_15 = VAR_28[VAR_10].contents) != NULL)
{
long VAR_46;
bfd_vma VAR_47;
VAR_11 = VAR_28[VAR_10].plt_got_offset;
VAR_13 = VAR_28[VAR_10].plt_got_insn_size;
VAR_12 = VAR_28[VAR_10].plt_entry_size;
VAR_25 = VAR_28[VAR_10].sec;
if ((VAR_28[VAR_10].type & VAR_45))
{
VAR_46 = 1;
VAR_47 = VAR_12;
}
else
{
VAR_46 = 0;
VAR_47 = 0;
}
for (; VAR_46 < VAR_28[VAR_10].count; VAR_46++)
{
int VAR_48;
bfd_vma VAR_49;
long VAR_50, VAR_51, VAR_52;
arelent *VAR_53;
VAR_48 = H_GET_32 (VAR_0, (VAR_15 + VAR_47
+ VAR_11));
VAR_49 = VAR_25->vma + VAR_47 + VAR_48 + VAR_13;
VAR_53 = VAR_18[0];
VAR_50 = 0;
VAR_51 = VAR_16;
while ((VAR_50 + 1) < VAR_51)
{
arelent *VAR_54;
VAR_52 = (VAR_50 + VAR_51) / 2;
VAR_54 = VAR_18[VAR_52];
if (VAR_49 > VAR_54->address)
VAR_50 = VAR_52;
else if (VAR_49 < VAR_54->address)
VAR_51 = VAR_52;
else
{
VAR_53 = VAR_54;
break;
}
}
if (VAR_49 == VAR_53->address
&& VAR_53->howto != NULL
&& (VAR_53->howto->type == VAR_55
|| VAR_53->howto->type == VAR_56
|| VAR_53->howto->type == VAR_57))
{
*VAR_14 = **VAR_53->sym_ptr_ptr;
if ((VAR_14->flags & VAR_58) == 0)
VAR_14->flags |= VAR_59;
VAR_14->flags |= VAR_60;
VAR_14->flags &= ~VAR_61;
VAR_14->section = VAR_25;
VAR_14->the_bfd = VAR_25->owner;
VAR_14->value = VAR_47;
VAR_14->udata.p = VAR_53;
VAR_6 += strlen (VAR_14->name) + sizeof (""@plt"");
if (VAR_53->addend != 0)
VAR_6 += sizeof (""+0x"") - 1 + 8 + 8 * ABI_64_P (VAR_0);
VAR_9++;
VAR_14++;
}
VAR_47 += VAR_12;
}
}
if (VAR_9 == 0)
goto bad_return;
VAR_7 = VAR_9;
VAR_26 = (char *) bfd_malloc (VAR_6);
if (VAR_14 == NULL)
goto bad_return;
VAR_14 = *VAR_5;
for (VAR_8 = 0; VAR_8 < VAR_7; VAR_8++)
{
arelent *VAR_53 = (arelent *) VAR_14->udata.p;
VAR_14->udata.p = NULL;
VAR_6 = strlen (VAR_14->name);
memcpy (VAR_26, VAR_14->name, VAR_6);
VAR_14->name = VAR_26;
VAR_26 += VAR_6;
if (VAR_53->addend != 0)
{
char VAR_62[30], *VAR_63;
memcpy (VAR_26, ""+0x"", sizeof (""+0x"") - 1);
VAR_26 += sizeof (""+0x"") - 1;
bfd_sprintf_vma (VAR_0, VAR_62, VAR_53->addend);
for (VAR_63 = VAR_62; *VAR_63 == '0'; ++VAR_63)
;
VAR_6 = strlen (VAR_63);
memcpy (VAR_26, VAR_63, VAR_6);
VAR_26 += VAR_6;
}
memcpy (VAR_26, ""@plt"", sizeof (""@plt""));
VAR_26 += sizeof (""@plt"");
VAR_14++;
}
for (VAR_10 = 0; VAR_28[VAR_10].name != NULL; VAR_10++)
if (VAR_28[VAR_10].contents != NULL)
free (VAR_28[VAR_10].contents);
free (VAR_18);
return VAR_7;
}",,"static long
elf_x86_64_get_synthetic_symtab (bfd *abfd,
				 long symcount ATTRIBUTE_UNUSED,
				 asymbol **syms ATTRIBUTE_UNUSED,
				 long dynsymcount,
				 asymbol **dynsyms,
				 asymbol **ret)
{
  long size, count, i, n;
  int j;
  unsigned int plt_got_offset, plt_entry_size, plt_got_insn_size;
  asymbol *s;
  bfd_byte *plt_contents;
  long dynrelcount, relsize;
  arelent **dynrelbuf;
  const struct elf_x86_64_lazy_plt_layout *lazy_plt;
  const struct elf_x86_64_non_lazy_plt_layout *non_lazy_plt;
  const struct elf_x86_64_lazy_plt_layout *lazy_bnd_plt;
  const struct elf_x86_64_non_lazy_plt_layout *non_lazy_bnd_plt;
  const struct elf_x86_64_lazy_plt_layout *lazy_ibt_plt;
  const struct elf_x86_64_non_lazy_plt_layout *non_lazy_ibt_plt;
  asection *plt;
  char *names;
  enum elf_x86_64_plt_type plt_type;
  struct elf_x86_64_plt plts[] =
    {
      { "".plt"", NULL, NULL, plt_unknown, 0, 0, 0, 0 },
      { "".plt.got"", NULL, NULL, plt_non_lazy, 0, 0, 0, 0 },
      { "".plt.sec"", NULL, NULL, plt_second, 0, 0, 0, 0 },
      { "".plt.bnd"", NULL, NULL, plt_second, 0, 0, 0, 0 },
      { NULL, NULL, NULL, plt_non_lazy, 0, 0, 0, 0 }
    };

  *ret = NULL;

  if ((abfd->flags & (DYNAMIC | EXEC_P)) == 0)
    return 0;

  if (dynsymcount <= 0)
    return 0;

  relsize = bfd_get_dynamic_reloc_upper_bound (abfd);
  if (relsize <= 0)
    return -1;

  dynrelbuf = (arelent **) bfd_malloc (relsize);
  if (dynrelbuf == NULL)
    return -1;

  dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf,
						dynsyms);
  if (dynrelcount <= 0)
    return -1;

  /* Sort the relocs by address.  */
  qsort (dynrelbuf, dynrelcount, sizeof (arelent *), compare_relocs);

  if (get_elf_x86_64_backend_data (abfd)->os == is_normal)
    {
      lazy_plt = &elf_x86_64_lazy_plt;
      non_lazy_plt = &elf_x86_64_non_lazy_plt;
      lazy_bnd_plt = &elf_x86_64_lazy_bnd_plt;
      non_lazy_bnd_plt = &elf_x86_64_non_lazy_bnd_plt;
      if (ABI_64_P (abfd))
	{
	  lazy_ibt_plt = &elf_x86_64_lazy_ibt_plt;
	  non_lazy_ibt_plt = &elf_x86_64_non_lazy_ibt_plt;
	}
      else
	{
	  lazy_ibt_plt = &elf_x32_lazy_ibt_plt;
	  non_lazy_ibt_plt = &elf_x32_non_lazy_ibt_plt;
	}
    }
  else
    {
      lazy_plt = &elf_x86_64_nacl_plt;
      non_lazy_plt = NULL;
      lazy_bnd_plt = NULL;
      non_lazy_bnd_plt = NULL;
      lazy_ibt_plt = NULL;
      non_lazy_ibt_plt = NULL;
    }

  count = 0;
  for (j = 0; plts[j].name != NULL; j++)
    {
      plt = bfd_get_section_by_name (abfd, plts[j].name);
      if (plt == NULL || plt->size == 0)
	continue;

      /* Get the PLT section contents.  */
      plt_contents = (bfd_byte *) bfd_malloc (plt->size);
      if (plt_contents == NULL)
	break;
      if (!bfd_get_section_contents (abfd, (asection *) plt,
				     plt_contents, 0, plt->size))
	{
	  free (plt_contents);
	  break;
	}

      /* Check what kind of PLT it is.  */
      plt_type = plt_unknown;
      if (plts[j].type == plt_unknown
	  && (plt->size >= (lazy_plt->plt_entry_size
			    + lazy_plt->plt_entry_size)))
	{
	  /* Match lazy PLT first.  Need to check the first two
	     instructions.   */
	  if ((memcmp (plt_contents, lazy_plt->plt0_entry,
		       lazy_plt->plt0_got1_offset) == 0)
	      && (memcmp (plt_contents + 6, lazy_plt->plt0_entry + 6,
			  2) == 0))
	    plt_type = plt_lazy;
	  else if (lazy_bnd_plt != NULL
		   && (memcmp (plt_contents, lazy_bnd_plt->plt0_entry,
			       lazy_bnd_plt->plt0_got1_offset) == 0)
		   && (memcmp (plt_contents + 6,
			       lazy_bnd_plt->plt0_entry + 6, 3) == 0))
	    {
	      plt_type = plt_lazy | plt_second;
	      /* The fist entry in the lazy IBT PLT is the same as the
		 lazy BND PLT.  */
	      if ((memcmp (plt_contents + lazy_ibt_plt->plt_entry_size,
			   lazy_ibt_plt->plt_entry,
			   lazy_ibt_plt->plt_got_offset) == 0))
		lazy_plt = lazy_ibt_plt;
	      else
		lazy_plt = lazy_bnd_plt;
	    }
	}

      if (non_lazy_plt != NULL
	  && (plt_type == plt_unknown || plt_type == plt_non_lazy)
	  && plt->size >= non_lazy_plt->plt_entry_size)
	{
	  /* Match non-lazy PLT.  */
	  if (memcmp (plt_contents, non_lazy_plt->plt_entry,
		      non_lazy_plt->plt_got_offset) == 0)
	    plt_type = plt_non_lazy;
	}

      if (plt_type == plt_unknown || plt_type == plt_second)
	{
	  if (non_lazy_bnd_plt != NULL
	      && plt->size >= non_lazy_bnd_plt->plt_entry_size
	      && (memcmp (plt_contents, non_lazy_bnd_plt->plt_entry,
			  non_lazy_bnd_plt->plt_got_offset) == 0))
	    {
	      /* Match BND PLT.  */
	      plt_type = plt_second;
	      non_lazy_plt = non_lazy_bnd_plt;
	    }
	  else if (non_lazy_ibt_plt != NULL
		   && plt->size >= non_lazy_ibt_plt->plt_entry_size
		   && (memcmp (plt_contents,
			       non_lazy_ibt_plt->plt_entry,
			       non_lazy_ibt_plt->plt_got_offset) == 0))
	    {
	      /* Match IBT PLT.  */
	      plt_type = plt_second;
	      non_lazy_plt = non_lazy_ibt_plt;
	    }
	}

      if (plt_type == plt_unknown)
	continue;

      plts[j].sec = plt;
      plts[j].type = plt_type;

      if ((plt_type & plt_lazy))
	{
	  plts[j].plt_got_offset = lazy_plt->plt_got_offset;
	  plts[j].plt_got_insn_size = lazy_plt->plt_got_insn_size;
	  plts[j].plt_entry_size = lazy_plt->plt_entry_size;
	  /* Skip PLT0 in lazy PLT.  */
	  i = 1;
	}
      else
	{
	  plts[j].plt_got_offset = non_lazy_plt->plt_got_offset;
	  plts[j].plt_got_insn_size = non_lazy_plt->plt_got_insn_size;
	  plts[j].plt_entry_size = non_lazy_plt->plt_entry_size;
	  i = 0;
	}

      /* Skip lazy PLT when the second PLT is used.  */
      if (plt_type == (plt_lazy | plt_second))
	plts[j].count = 0;
      else
	{
	  n = plt->size / plts[j].plt_entry_size;
	  plts[j].count = n;
	  count += n - i;
	}

      plts[j].contents = plt_contents;
    }

  if (count == 0)
    return -1;

  size = count * sizeof (asymbol);
  s = *ret = (asymbol *) bfd_zmalloc (size);
  if (s == NULL)
    {
bad_return:
      for (j = 0; plts[j].name != NULL; j++)
	if (plts[j].contents != NULL)
	  free (plts[j].contents);
      free (dynrelbuf);
      return -1;
    }

  /* Check for each PLT section.  */
  size = 0;
  n = 0;
  for (j = 0; plts[j].name != NULL; j++)
    if ((plt_contents = plts[j].contents) != NULL)
      {
	long k;
	bfd_vma offset;

	plt_got_offset = plts[j].plt_got_offset;
	plt_got_insn_size = plts[j].plt_got_insn_size;
	plt_entry_size = plts[j].plt_entry_size;

	plt = plts[j].sec;

	if ((plts[j].type & plt_lazy))
	  {
	    /* Skip PLT0 in lazy PLT.  */
	    k = 1;
	    offset = plt_entry_size;
	  }
	else
	  {
	    k = 0;
	    offset = 0;
	  }

	/* Check each PLT entry against dynamic relocations.  */
	for (; k < plts[j].count; k++)
	  {
	    int off;
	    bfd_vma got_vma;
	    long min, max, mid;
	    arelent *p;

	    /* Get the PC-relative offset, a signed 32-bit integer.  */
	    off = H_GET_32 (abfd, (plt_contents + offset
				   + plt_got_offset));
	    got_vma = plt->vma + offset + off + plt_got_insn_size;

	    /* Binary search.  */
	    p = dynrelbuf[0];
	    min = 0;
	    max = dynrelcount;
	    while ((min + 1) < max)
	      {
		arelent *r;

		mid = (min + max) / 2;
		r = dynrelbuf[mid];
		if (got_vma > r->address)
		  min = mid;
		else if (got_vma < r->address)
		  max = mid;
		else
		  {
		    p = r;
		    break;
		  }
	      }

	    /* Skip unknown relocation.  PR 17512: file: bc9d6cf5.  */
	    if (got_vma == p->address
		&& p->howto != NULL
		&& (p->howto->type == R_X86_64_JUMP_SLOT
		    || p->howto->type == R_X86_64_GLOB_DAT
		    || p->howto->type == R_X86_64_IRELATIVE))
	      {
		*s = **p->sym_ptr_ptr;
		/* Undefined syms won't have BSF_LOCAL or BSF_GLOBAL
		   set.  Since we are defining a symbol, ensure one
		   of them is set.  */
		if ((s->flags & BSF_LOCAL) == 0)
		  s->flags |= BSF_GLOBAL;
		s->flags |= BSF_SYNTHETIC;
		/* This is no longer a section symbol.  */
		s->flags &= ~BSF_SECTION_SYM;
		s->section = plt;
		s->the_bfd = plt->owner;
		s->value = offset;
		/* Store relocation for later use.  */
		s->udata.p = p;
		/* Add @plt to function name later.  */
		size += strlen (s->name) + sizeof (""@plt"");
		if (p->addend != 0)
		  size += sizeof (""+0x"") - 1 + 8 + 8 * ABI_64_P (abfd);
		n++;
		s++;
	      }
	    offset += plt_entry_size;
	  }
      }

  /* PLT entries with R_X86_64_TLSDESC relocations are skipped.  */
  if (n == 0)
    goto bad_return;

  count = n;

  /* Allocate space for @plt suffixes.  */
  names = (char *) bfd_malloc (size);
  if (s == NULL)
    goto bad_return;

  s = *ret;
  for (i = 0; i < count; i++)
    {
      /* Add @plt to function name.  */
      arelent *p = (arelent *) s->udata.p;
      /* Clear it now.  */
      s->udata.p = NULL;
      size = strlen (s->name);
      memcpy (names, s->name, size);
      s->name = names;
      names += size;
      if (p->addend != 0)
	{
	  char buf[30], *a;

	  memcpy (names, ""+0x"", sizeof (""+0x"") - 1);
	  names += sizeof (""+0x"") - 1;
	  bfd_sprintf_vma (abfd, buf, p->addend);
	  for (a = buf; *a == '0'; ++a)
	    ;
	  size = strlen (a);
	  memcpy (names, a, size);
	  names += size;
	}
      memcpy (names, ""@plt"", sizeof (""@plt""));
      names += sizeof (""@plt"");
      s++;
    }

  for (j = 0; plts[j].name != NULL; j++)
    if (plts[j].contents != NULL)
      free (plts[j].contents);

  free (dynrelbuf);

  return count;
}","static long
elf_x86_64_get_synthetic_symtab (bfd *VAR_0,
				 long VAR_1 ATTRIBUTE_UNUSED,
				 asymbol **VAR_2 ATTRIBUTE_UNUSED,
				 long VAR_3,
				 asymbol **VAR_4,
				 asymbol **VAR_5)
{
  long VAR_6, VAR_7, VAR_8, VAR_9;
  int VAR_10;
  unsigned int VAR_11, VAR_12, VAR_13;
  asymbol *VAR_14;
  bfd_byte *VAR_15;
  long VAR_16, VAR_17;
  arelent **VAR_18;
  const struct elf_x86_64_lazy_plt_layout *VAR_19;
  const struct elf_x86_64_non_lazy_plt_layout *VAR_20;
  const struct elf_x86_64_lazy_plt_layout *VAR_21;
  const struct elf_x86_64_non_lazy_plt_layout *VAR_22;
  const struct elf_x86_64_lazy_plt_layout *VAR_23;
  const struct elf_x86_64_non_lazy_plt_layout *VAR_24;
  asection *VAR_25;
  char *VAR_26;
  enum elf_x86_64_plt_type VAR_27;
  struct elf_x86_64_plt VAR_28[] =
    {
      { "".plt"", NULL, NULL, VAR_29, 0, 0, 0, 0 },
      { "".plt.got"", NULL, NULL, VAR_30, 0, 0, 0, 0 },
      { "".plt.sec"", NULL, NULL, VAR_31, 0, 0, 0, 0 },
      { "".plt.bnd"", NULL, NULL, VAR_31, 0, 0, 0, 0 },
      { NULL, NULL, NULL, VAR_30, 0, 0, 0, 0 }
    };

  *VAR_5 = NULL;

  if ((VAR_0->flags & (VAR_32 | VAR_33)) == 0)
    return 0;

  if (VAR_3 <= 0)
    return 0;

  VAR_17 = bfd_get_dynamic_reloc_upper_bound (VAR_0);
  if (VAR_17 <= 0)
    return -1;

  VAR_18 = (arelent **) bfd_malloc (VAR_17);
  if (VAR_18 == NULL)
    return -1;

  VAR_16 = bfd_canonicalize_dynamic_reloc (VAR_0, VAR_18,
						VAR_4);
  if (VAR_16 <= 0)
    return -1;

  /* COMMENT_0 */
  qsort (VAR_18, VAR_16, sizeof (arelent *), VAR_34);

  if (get_elf_x86_64_backend_data (VAR_0)->os == VAR_35)
    {
      VAR_19 = &VAR_36;
      VAR_20 = &VAR_37;
      VAR_21 = &VAR_38;
      VAR_22 = &VAR_39;
      if (ABI_64_P (VAR_0))
	{
	  VAR_23 = &VAR_40;
	  VAR_24 = &VAR_41;
	}
      else
	{
	  VAR_23 = &VAR_42;
	  VAR_24 = &VAR_43;
	}
    }
  else
    {
      VAR_19 = &VAR_44;
      VAR_20 = NULL;
      VAR_21 = NULL;
      VAR_22 = NULL;
      VAR_23 = NULL;
      VAR_24 = NULL;
    }

  VAR_7 = 0;
  for (VAR_10 = 0; VAR_28[VAR_10].name != NULL; VAR_10++)
    {
      VAR_25 = bfd_get_section_by_name (VAR_0, VAR_28[VAR_10].name);
      if (VAR_25 == NULL || VAR_25->size == 0)
	continue;

      /* COMMENT_1 */
      VAR_15 = (bfd_byte *) bfd_malloc (VAR_25->size);
      if (VAR_15 == NULL)
	break;
      if (!bfd_get_section_contents (VAR_0, (asection *) VAR_25,
				     VAR_15, 0, VAR_25->size))
	{
	  free (VAR_15);
	  break;
	}

      /* COMMENT_2 */
      VAR_27 = VAR_29;
      if (VAR_28[VAR_10].type == VAR_29
	  && (VAR_25->size >= (VAR_19->plt_entry_size
			    + VAR_19->plt_entry_size)))
	{
	  /* COMMENT_3 */
                        
	  if ((memcmp (VAR_15, VAR_19->plt0_entry,
		       VAR_19->plt0_got1_offset) == 0)
	      && (memcmp (VAR_15 + 6, VAR_19->plt0_entry + 6,
			  2) == 0))
	    VAR_27 = VAR_45;
	  else if (VAR_21 != NULL
		   && (memcmp (VAR_15, VAR_21->plt0_entry,
			       VAR_21->plt0_got1_offset) == 0)
		   && (memcmp (VAR_15 + 6,
			       VAR_21->plt0_entry + 6, 3) == 0))
	    {
	      VAR_27 = VAR_45 | VAR_31;
	      /* COMMENT_5 */
                    
	      if ((memcmp (VAR_15 + VAR_23->plt_entry_size,
			   VAR_23->plt_entry,
			   VAR_23->plt_got_offset) == 0))
		VAR_19 = VAR_23;
	      else
		VAR_19 = VAR_21;
	    }
	}

      if (VAR_20 != NULL
	  && (VAR_27 == VAR_29 || VAR_27 == VAR_30)
	  && VAR_25->size >= VAR_20->plt_entry_size)
	{
	  /* COMMENT_7 */
	  if (memcmp (VAR_15, VAR_20->plt_entry,
		      VAR_20->plt_got_offset) == 0)
	    VAR_27 = VAR_30;
	}

      if (VAR_27 == VAR_29 || VAR_27 == VAR_31)
	{
	  if (VAR_22 != NULL
	      && VAR_25->size >= VAR_22->plt_entry_size
	      && (memcmp (VAR_15, VAR_22->plt_entry,
			  VAR_22->plt_got_offset) == 0))
	    {
	      /* COMMENT_8 */
	      VAR_27 = VAR_31;
	      VAR_20 = VAR_22;
	    }
	  else if (VAR_24 != NULL
		   && VAR_25->size >= VAR_24->plt_entry_size
		   && (memcmp (VAR_15,
			       VAR_24->plt_entry,
			       VAR_24->plt_got_offset) == 0))
	    {
	      /* COMMENT_9 */
	      VAR_27 = VAR_31;
	      VAR_20 = VAR_24;
	    }
	}

      if (VAR_27 == VAR_29)
	continue;

      VAR_28[VAR_10].sec = VAR_25;
      VAR_28[VAR_10].type = VAR_27;

      if ((VAR_27 & VAR_45))
	{
	  VAR_28[VAR_10].plt_got_offset = VAR_19->plt_got_offset;
	  VAR_28[VAR_10].plt_got_insn_size = VAR_19->plt_got_insn_size;
	  VAR_28[VAR_10].plt_entry_size = VAR_19->plt_entry_size;
	  /* COMMENT_10 */
	  VAR_8 = 1;
	}
      else
	{
	  VAR_28[VAR_10].plt_got_offset = VAR_20->plt_got_offset;
	  VAR_28[VAR_10].plt_got_insn_size = VAR_20->plt_got_insn_size;
	  VAR_28[VAR_10].plt_entry_size = VAR_20->plt_entry_size;
	  VAR_8 = 0;
	}

      /* COMMENT_11 */
      if (VAR_27 == (VAR_45 | VAR_31))
	VAR_28[VAR_10].count = 0;
      else
	{
	  VAR_9 = VAR_25->size / VAR_28[VAR_10].plt_entry_size;
	  VAR_28[VAR_10].count = VAR_9;
	  VAR_7 += VAR_9 - VAR_8;
	}

      VAR_28[VAR_10].contents = VAR_15;
    }

  if (VAR_7 == 0)
    return -1;

  VAR_6 = VAR_7 * sizeof (asymbol);
  VAR_14 = *VAR_5 = (asymbol *) bfd_zmalloc (VAR_6);
  if (VAR_14 == NULL)
    {
bad_return:
      for (VAR_10 = 0; VAR_28[VAR_10].name != NULL; VAR_10++)
	if (VAR_28[VAR_10].contents != NULL)
	  free (VAR_28[VAR_10].contents);
      free (VAR_18);
      return -1;
    }

  /* COMMENT_12 */
  VAR_6 = 0;
  VAR_9 = 0;
  for (VAR_10 = 0; VAR_28[VAR_10].name != NULL; VAR_10++)
    if ((VAR_15 = VAR_28[VAR_10].contents) != NULL)
      {
	long VAR_46;
	bfd_vma VAR_47;

	VAR_11 = VAR_28[VAR_10].plt_got_offset;
	VAR_13 = VAR_28[VAR_10].plt_got_insn_size;
	VAR_12 = VAR_28[VAR_10].plt_entry_size;

	VAR_25 = VAR_28[VAR_10].sec;

	if ((VAR_28[VAR_10].type & VAR_45))
	  {
	    /* COMMENT_10 */
	    VAR_46 = 1;
	    VAR_47 = VAR_12;
	  }
	else
	  {
	    VAR_46 = 0;
	    VAR_47 = 0;
	  }

	/* COMMENT_13 */
	for (; VAR_46 < VAR_28[VAR_10].count; VAR_46++)
	  {
	    int VAR_48;
	    bfd_vma VAR_49;
	    long VAR_50, VAR_51, VAR_52;
	    arelent *VAR_53;

	    /* COMMENT_14 */
	    VAR_48 = H_GET_32 (VAR_0, (VAR_15 + VAR_47
				   + VAR_11));
	    VAR_49 = VAR_25->vma + VAR_47 + VAR_48 + VAR_13;

	    /* COMMENT_15 */
	    VAR_53 = VAR_18[0];
	    VAR_50 = 0;
	    VAR_51 = VAR_16;
	    while ((VAR_50 + 1) < VAR_51)
	      {
		arelent *VAR_54;

		VAR_52 = (VAR_50 + VAR_51) / 2;
		VAR_54 = VAR_18[VAR_52];
		if (VAR_49 > VAR_54->address)
		  VAR_50 = VAR_52;
		else if (VAR_49 < VAR_54->address)
		  VAR_51 = VAR_52;
		else
		  {
		    VAR_53 = VAR_54;
		    break;
		  }
	      }

	    /* COMMENT_16 */
	    if (VAR_49 == VAR_53->address
		&& VAR_53->howto != NULL
		&& (VAR_53->howto->type == VAR_55
		    || VAR_53->howto->type == VAR_56
		    || VAR_53->howto->type == VAR_57))
	      {
		*VAR_14 = **VAR_53->sym_ptr_ptr;
		/* COMMENT_17 */
                                                     
                        
		if ((VAR_14->flags & VAR_58) == 0)
		  VAR_14->flags |= VAR_59;
		VAR_14->flags |= VAR_60;
		/* COMMENT_20 */
		VAR_14->flags &= ~VAR_61;
		VAR_14->section = VAR_25;
		VAR_14->the_bfd = VAR_25->owner;
		VAR_14->value = VAR_47;
		/* COMMENT_21 */
		VAR_14->udata.p = VAR_53;
		/* COMMENT_22 */
		VAR_6 += strlen (VAR_14->name) + sizeof (""@plt"");
		if (VAR_53->addend != 0)
		  VAR_6 += sizeof (""+0x"") - 1 + 8 + 8 * ABI_64_P (VAR_0);
		VAR_9++;
		VAR_14++;
	      }
	    VAR_47 += VAR_12;
	  }
      }

  /* COMMENT_23 */
  if (VAR_9 == 0)
    goto bad_return;

  VAR_7 = VAR_9;

  /* COMMENT_24 */
  VAR_26 = (char *) bfd_malloc (VAR_6);
  if (VAR_14 == NULL)
    goto bad_return;

  VAR_14 = *VAR_5;
  for (VAR_8 = 0; VAR_8 < VAR_7; VAR_8++)
    {
      /* COMMENT_25 */
      arelent *VAR_53 = (arelent *) VAR_14->udata.p;
      /* COMMENT_26 */
      VAR_14->udata.p = NULL;
      VAR_6 = strlen (VAR_14->name);
      memcpy (VAR_26, VAR_14->name, VAR_6);
      VAR_14->name = VAR_26;
      VAR_26 += VAR_6;
      if (VAR_53->addend != 0)
	{
	  char VAR_62[30], *VAR_63;

	  memcpy (VAR_26, ""+0x"", sizeof (""+0x"") - 1);
	  VAR_26 += sizeof (""+0x"") - 1;
	  bfd_sprintf_vma (VAR_0, VAR_62, VAR_53->addend);
	  for (VAR_63 = VAR_62; *VAR_63 == '0'; ++VAR_63)
	    ;
	  VAR_6 = strlen (VAR_63);
	  memcpy (VAR_26, VAR_63, VAR_6);
	  VAR_26 += VAR_6;
	}
      memcpy (VAR_26, ""@plt"", sizeof (""@plt""));
      VAR_26 += sizeof (""@plt"");
      VAR_14++;
    }

  for (VAR_10 = 0; VAR_28[VAR_10].name != NULL; VAR_10++)
    if (VAR_28[VAR_10].contents != NULL)
      free (VAR_28[VAR_10].contents);

  free (VAR_18);

  return VAR_7;
}",,"--- func_before
+++ func_after
@@ -49,7 +49,7 @@
 
   dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf,
 						dynsyms);
-  if (dynrelcount < 0)
+  if (dynrelcount <= 0)
     return -1;
 
   /* Sort the relocs by address.  */","{'deleted_lines': ['  if (dynrelcount < 0)'], 'added_lines': ['  if (dynrelcount <= 0)']}",True,"The *_get_synthetic_symtab functions in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, mishandle the failure of a certain canonicalization step, which allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted ELF file, related to elf32-i386.c and elf64-x86-64.c.",5.5,MEDIUM,1,test,,5
CVE-2017-14976,['CWE-125'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,poppler,"Bug #102724
",da63c35549e8852a410946ab016a3f25ac701bdf,https://cgit.freedesktop.org/poppler/poppler/commit/?id=da63c35549e8852a410946ab016a3f25ac701bdf,fofi/FoFiType1C.cc,FoFiType1C::convertToType0,"void FoFiType1C::convertToType0(char *psName, int *codeMap, int nCodes,
FoFiOutputFunc outputFunc,
void *outputStream) {
int *cidMap;
Type1CIndex subrIdx;
Type1CIndexVal val;
int nCIDs;
GooString *buf;
Type1CEexecBuf eb;
GBool ok;
int fd, i, j, k;
if (codeMap) {
nCIDs = nCodes;
cidMap = (int *)gmallocn(nCIDs, sizeof(int));
for (i = 0; i < nCodes; ++i) {
if (codeMap[i] >= 0 && codeMap[i] < nGlyphs) {
cidMap[i] = codeMap[i];
} else {
cidMap[i] = -1;
}
}
} else if (topDict.firstOp == 0x0c1e) {
nCIDs = 0;
for (i = 0; i < nGlyphs && i < charsetLength; ++i) {
if (charset[i] >= nCIDs) {
nCIDs = charset[i] + 1;
}
}
cidMap = (int *)gmallocn(nCIDs, sizeof(int));
for (i = 0; i < nCIDs; ++i) {
cidMap[i] = -1;
}
for (i = 0; i < nGlyphs && i < charsetLength; ++i) {
cidMap[charset[i]] = i;
}
} else {
nCIDs = nGlyphs;
cidMap = (int *)gmallocn(nCIDs, sizeof(int));
for (i = 0; i < nCIDs; ++i) {
cidMap[i] = i;
}
}
if (privateDicts) {
for (i = 0; i < nCIDs; i += 256) {
fd = 0;
if (fdSelect) {
for (j = i==0 ? 1 : 0; j < 256 && i+j < nCIDs; ++j) {
if (cidMap[i+j] >= 0) {
fd = fdSelect[cidMap[i+j]];
break;
}
}
}
(*outputFunc)(outputStream, ""16 dict begin\n"", 14);
(*outputFunc)(outputStream, ""/FontName /"", 11);
(*outputFunc)(outputStream, psName, strlen(psName));
buf = GooString::format(""_{0:02x} def\n"", i >> 8);
(*outputFunc)(outputStream, buf->getCString(), buf->getLength());
delete buf;
(*outputFunc)(outputStream, ""/FontType 1 def\n"", 16);
if (privateDicts[fd].hasFontMatrix) {
buf = GooString::format(""/FontMatrix [{0:.8g} {1:.8g} {2:.8g} {3:.8g} {4:.8g} {5:.8g}] def\n"",
privateDicts[fd].fontMatrix[0],
privateDicts[fd].fontMatrix[1],
privateDicts[fd].fontMatrix[2],
privateDicts[fd].fontMatrix[3],
privateDicts[fd].fontMatrix[4],
privateDicts[fd].fontMatrix[5]);
(*outputFunc)(outputStream, buf->getCString(), buf->getLength());
delete buf;
} else if (topDict.hasFontMatrix) {
(*outputFunc)(outputStream, ""/FontMatrix [1 0 0 1 0 0] def\n"", 30);
} else {
(*outputFunc)(outputStream,
""/FontMatrix [0.001 0 0 0.001 0 0] def\n"", 38);
}
buf = GooString::format(""/FontBBox [{0:.4g} {1:.4g} {2:.4g} {3:.4g}] def\n"",
topDict.fontBBox[0], topDict.fontBBox[1],
topDict.fontBBox[2], topDict.fontBBox[3]);
(*outputFunc)(outputStream, buf->getCString(), buf->getLength());
delete buf;
buf = GooString::format(""/PaintType {0:d} def\n"", topDict.paintType);
(*outputFunc)(outputStream, buf->getCString(), buf->getLength());
delete buf;
if (topDict.paintType != 0) {
buf = GooString::format(""/StrokeWidth {0:.4g} def\n"", topDict.strokeWidth);
(*outputFunc)(outputStream, buf->getCString(), buf->getLength());
delete buf;
}
(*outputFunc)(outputStream, ""/Encoding 256 array\n"", 20);
for (j = 0; j < 256 && i+j < nCIDs; ++j) {
buf = GooString::format(""dup {0:d} /c{1:02x} put\n"", j, j);
(*outputFunc)(outputStream, buf->getCString(), buf->getLength());
delete buf;
}
if (j < 256) {
buf = GooString::format(""{0:d} 1 255 {{ 1 index exch /.notdef put }} for\n"",
j);
(*outputFunc)(outputStream, buf->getCString(), buf->getLength());
delete buf;
}
(*outputFunc)(outputStream, ""readonly def\n"", 13);
(*outputFunc)(outputStream, ""currentdict end\n"", 16);
(*outputFunc)(outputStream, ""currentfile eexec\n"", 18);
eb.outputFunc = outputFunc;
eb.outputStream = outputStream;
eb.ascii = gTrue;
eb.r1 = 55665;
eb.line = 0;
eexecWrite(&eb, ""\x83\xca\x73\xd5"");
eexecWrite(&eb, ""dup /Private 32 dict dup begin\n"");
eexecWrite(&eb, ""/RD {string currentfile exch readstring pop}""
"" executeonly def\n"");
eexecWrite(&eb, ""/ND {noaccess def} executeonly def\n"");
eexecWrite(&eb, ""/NP {noaccess put} executeonly def\n"");
eexecWrite(&eb, ""/MinFeature {16 16} def\n"");
eexecWrite(&eb, ""/password 5839 def\n"");
if (privateDicts[fd].nBlueValues) {
eexecWrite(&eb, ""/BlueValues ["");
for (k = 0; k < privateDicts[fd].nBlueValues; ++k) {
buf = GooString::format(""{0:s}{1:d}"",
k > 0 ? "" "" : """",
privateDicts[fd].blueValues[k]);
eexecWrite(&eb, buf->getCString());
delete buf;
}
eexecWrite(&eb, ""] def\n"");
}
if (privateDicts[fd].nOtherBlues) {
eexecWrite(&eb, ""/OtherBlues ["");
for (k = 0; k < privateDicts[fd].nOtherBlues; ++k) {
buf = GooString::format(""{0:s}{1:d}"",
k > 0 ? "" "" : """",
privateDicts[fd].otherBlues[k]);
eexecWrite(&eb, buf->getCString());
delete buf;
}
eexecWrite(&eb, ""] def\n"");
}
if (privateDicts[fd].nFamilyBlues) {
eexecWrite(&eb, ""/FamilyBlues ["");
for (k = 0; k < privateDicts[fd].nFamilyBlues; ++k) {
buf = GooString::format(""{0:s}{1:d}"", k > 0 ? "" "" : """",
privateDicts[fd].familyBlues[k]);
eexecWrite(&eb, buf->getCString());
delete buf;
}
eexecWrite(&eb, ""] def\n"");
}
if (privateDicts[fd].nFamilyOtherBlues) {
eexecWrite(&eb, ""/FamilyOtherBlues ["");
for (k = 0; k < privateDicts[fd].nFamilyOtherBlues; ++k) {
buf = GooString::format(""{0:s}{1:d}"", k > 0 ? "" "" : """",
privateDicts[fd].familyOtherBlues[k]);
eexecWrite(&eb, buf->getCString());
delete buf;
}
eexecWrite(&eb, ""] def\n"");
}
if (privateDicts[fd].blueScale != 0.039625) {
buf = GooString::format(""/BlueScale {0:.4g} def\n"",
privateDicts[fd].blueScale);
eexecWrite(&eb, buf->getCString());
delete buf;
}
if (privateDicts[fd].blueShift != 7) {
buf = GooString::format(""/BlueShift {0:d} def\n"",
privateDicts[fd].blueShift);
eexecWrite(&eb, buf->getCString());
delete buf;
}
if (privateDicts[fd].blueFuzz != 1) {
buf = GooString::format(""/BlueFuzz {0:d} def\n"",
privateDicts[fd].blueFuzz);
eexecWrite(&eb, buf->getCString());
delete buf;
}
if (privateDicts[fd].hasStdHW) {
buf = GooString::format(""/StdHW [{0:.4g}] def\n"", privateDicts[fd].stdHW);
eexecWrite(&eb, buf->getCString());
delete buf;
}
if (privateDicts[fd].hasStdVW) {
buf = GooString::format(""/StdVW [{0:.4g}] def\n"", privateDicts[fd].stdVW);
eexecWrite(&eb, buf->getCString());
delete buf;
}
if (privateDicts[fd].nStemSnapH) {
eexecWrite(&eb, ""/StemSnapH ["");
for (k = 0; k < privateDicts[fd].nStemSnapH; ++k) {
buf = GooString::format(""{0:s}{1:.4g}"",
k > 0 ? "" "" : """", privateDicts[fd].stemSnapH[k]);
eexecWrite(&eb, buf->getCString());
delete buf;
}
eexecWrite(&eb, ""] def\n"");
}
if (privateDicts[fd].nStemSnapV) {
eexecWrite(&eb, ""/StemSnapV ["");
for (k = 0; k < privateDicts[fd].nStemSnapV; ++k) {
buf = GooString::format(""{0:s}{1:.4g}"",
k > 0 ? "" "" : """", privateDicts[fd].stemSnapV[k]);
eexecWrite(&eb, buf->getCString());
delete buf;
}
eexecWrite(&eb, ""] def\n"");
}
if (privateDicts[fd].hasForceBold) {
buf = GooString::format(""/ForceBold {0:s} def\n"",
privateDicts[fd].forceBold ? ""true"" : ""false"");
eexecWrite(&eb, buf->getCString());
delete buf;
}
if (privateDicts[fd].forceBoldThreshold != 0) {
buf = GooString::format(""/ForceBoldThreshold {0:.4g} def\n"",
privateDicts[fd].forceBoldThreshold);
eexecWrite(&eb, buf->getCString());
delete buf;
}
if (privateDicts[fd].languageGroup != 0) {
buf = GooString::format(""/LanguageGroup {0:d} def\n"",
privateDicts[fd].languageGroup);
eexecWrite(&eb, buf->getCString());
delete buf;
}
if (privateDicts[fd].expansionFactor != 0.06) {
buf = GooString::format(""/ExpansionFactor {0:.4g} def\n"",
privateDicts[fd].expansionFactor);
eexecWrite(&eb, buf->getCString());
delete buf;
}
ok = gTrue;
getIndex(privateDicts[fd].subrsOffset, &subrIdx, &ok);
if (!ok) {
subrIdx.pos = -1;
}
eexecWrite(&eb, ""2 index /CharStrings 256 dict dup begin\n"");
ok = gTrue;
getIndexVal(&charStringsIdx, 0, &val, &ok);
if (ok) {
eexecCvtGlyph(&eb, "".notdef"", val.pos, val.len,
&subrIdx, &privateDicts[fd]);
}
for (j = 0; j < 256 && i+j < nCIDs; ++j) {
if (cidMap[i+j] >= 0) {
ok = gTrue;
getIndexVal(&charStringsIdx, cidMap[i+j], &val, &ok);
if (ok) {
buf = GooString::format(""c{0:02x}"", j);
eexecCvtGlyph(&eb, buf->getCString(), val.pos, val.len,
&subrIdx, &privateDicts[fd]);
delete buf;
}
}
}
eexecWrite(&eb, ""end\n"");
eexecWrite(&eb, ""end\n"");
eexecWrite(&eb, ""readonly put\n"");
eexecWrite(&eb, ""noaccess put\n"");
eexecWrite(&eb, ""dup /FontName get exch definefont pop\n"");
eexecWrite(&eb, ""mark currentfile closefile\n"");
if (eb.line > 0) {
(*outputFunc)(outputStream, ""\n"", 1);
}
for (j = 0; j < 8; ++j) {
(*outputFunc)(outputStream, ""0000000000000000000000000000000000000000000000000000000000000000\n"", 65);
}
(*outputFunc)(outputStream, ""cleartomark\n"", 12);
}
} else {
error(errSyntaxError, -1, ""FoFiType1C::convertToType0 without privateDicts"");
}
(*outputFunc)(outputStream, ""16 dict begin\n"", 14);
(*outputFunc)(outputStream, ""/FontName /"", 11);
(*outputFunc)(outputStream, psName, strlen(psName));
(*outputFunc)(outputStream, "" def\n"", 5);
(*outputFunc)(outputStream, ""/FontType 0 def\n"", 16);
if (topDict.hasFontMatrix) {
buf = GooString::format(""/FontMatrix [{0:.8g} {1:.8g} {2:.8g} {3:.8g} {4:.8g} {5:.8g}] def\n"",
topDict.fontMatrix[0], topDict.fontMatrix[1],
topDict.fontMatrix[2], topDict.fontMatrix[3],
topDict.fontMatrix[4], topDict.fontMatrix[5]);
(*outputFunc)(outputStream, buf->getCString(), buf->getLength());
delete buf;
} else {
(*outputFunc)(outputStream, ""/FontMatrix [1 0 0 1 0 0] def\n"", 30);
}
(*outputFunc)(outputStream, ""/FMapType 2 def\n"", 16);
(*outputFunc)(outputStream, ""/Encoding [\n"", 12);
for (i = 0; i < nCIDs; i += 256) {
buf = GooString::format(""{0:d}\n"", i >> 8);
(*outputFunc)(outputStream, buf->getCString(), buf->getLength());
delete buf;
}
(*outputFunc)(outputStream, ""] def\n"", 6);
(*outputFunc)(outputStream, ""/FDepVector [\n"", 14);
for (i = 0; i < nCIDs; i += 256) {
(*outputFunc)(outputStream, ""/"", 1);
(*outputFunc)(outputStream, psName, strlen(psName));
buf = GooString::format(""_{0:02x} findfont\n"", i >> 8);
(*outputFunc)(outputStream, buf->getCString(), buf->getLength());
delete buf;
}
(*outputFunc)(outputStream, ""] def\n"", 6);
(*outputFunc)(outputStream, ""FontName currentdict end definefont pop\n"", 40);
gfree(cidMap);
}","void FoFiType1C::convertToType0(char *VAR_0, int *VAR_1, int VAR_2,
FoFiOutputFunc VAR_3,
void *VAR_4) {
int *VAR_5;
Type1CIndex VAR_6;
Type1CIndexVal VAR_7;
int VAR_8;
GooString *VAR_9;
Type1CEexecBuf VAR_10;
GBool VAR_11;
int VAR_12, VAR_13, VAR_14, VAR_15;
if (VAR_1) {
VAR_8 = VAR_2;
VAR_5 = (int *)gmallocn(VAR_8, sizeof(int));
for (VAR_13 = 0; VAR_13 < VAR_2; ++VAR_13) {
if (VAR_1[VAR_13] >= 0 && VAR_1[VAR_13] < VAR_16) {
VAR_5[VAR_13] = VAR_1[VAR_13];
} else {
VAR_5[VAR_13] = -1;
}
}
} else if (VAR_17.firstOp == 0x0c1e) {
VAR_8 = 0;
for (VAR_13 = 0; VAR_13 < VAR_16 && VAR_13 < VAR_18; ++VAR_13) {
if (VAR_19[VAR_13] >= VAR_8) {
VAR_8 = VAR_19[VAR_13] + 1;
}
}
VAR_5 = (int *)gmallocn(VAR_8, sizeof(int));
for (VAR_13 = 0; VAR_13 < VAR_8; ++VAR_13) {
VAR_5[VAR_13] = -1;
}
for (VAR_13 = 0; VAR_13 < VAR_16 && VAR_13 < VAR_18; ++VAR_13) {
VAR_5[VAR_19[VAR_13]] = VAR_13;
}
} else {
VAR_8 = VAR_16;
VAR_5 = (int *)gmallocn(VAR_8, sizeof(int));
for (VAR_13 = 0; VAR_13 < VAR_8; ++VAR_13) {
VAR_5[VAR_13] = VAR_13;
}
}
if (VAR_20) {
for (VAR_13 = 0; VAR_13 < VAR_8; VAR_13 += 256) {
VAR_12 = 0;
if (VAR_21) {
for (VAR_14 = VAR_13==0 ? 1 : 0; VAR_14 < 256 && VAR_13+VAR_14 < VAR_8; ++VAR_14) {
if (VAR_5[VAR_13+VAR_14] >= 0) {
VAR_12 = VAR_21[VAR_5[VAR_13+VAR_14]];
break;
}
}
}
(*VAR_3)(VAR_4, ""16 dict begin\n"", 14);
(*VAR_3)(VAR_4, ""/FontName /"", 11);
(*VAR_3)(VAR_4, VAR_0, strlen(VAR_0));
VAR_9 = GooString::format(""_{0:02x} def\n"", VAR_13 >> 8);
(*VAR_3)(VAR_4, VAR_9->getCString(), VAR_9->getLength());
delete VAR_9;
(*VAR_3)(VAR_4, ""/FontType 1 def\n"", 16);
if (VAR_20[VAR_12].hasFontMatrix) {
VAR_9 = GooString::format(""/FontMatrix [{0:.8g} {1:.8g} {2:.8g} {3:.8g} {4:.8g} {5:.8g}] def\n"",
VAR_20[VAR_12].fontMatrix[0],
VAR_20[VAR_12].fontMatrix[1],
VAR_20[VAR_12].fontMatrix[2],
VAR_20[VAR_12].fontMatrix[3],
VAR_20[VAR_12].fontMatrix[4],
VAR_20[VAR_12].fontMatrix[5]);
(*VAR_3)(VAR_4, VAR_9->getCString(), VAR_9->getLength());
delete VAR_9;
} else if (VAR_17.hasFontMatrix) {
(*VAR_3)(VAR_4, ""/FontMatrix [1 0 0 1 0 0] def\n"", 30);
} else {
(*VAR_3)(VAR_4,
""/FontMatrix [0.001 0 0 0.001 0 0] def\n"", 38);
}
VAR_9 = GooString::format(""/FontBBox [{0:.4g} {1:.4g} {2:.4g} {3:.4g}] def\n"",
VAR_17.fontBBox[0], VAR_17.fontBBox[1],
VAR_17.fontBBox[2], VAR_17.fontBBox[3]);
(*VAR_3)(VAR_4, VAR_9->getCString(), VAR_9->getLength());
delete VAR_9;
VAR_9 = GooString::format(""/PaintType {0:d} def\n"", VAR_17.paintType);
(*VAR_3)(VAR_4, VAR_9->getCString(), VAR_9->getLength());
delete VAR_9;
if (VAR_17.paintType != 0) {
VAR_9 = GooString::format(""/StrokeWidth {0:.4g} def\n"", VAR_17.strokeWidth);
(*VAR_3)(VAR_4, VAR_9->getCString(), VAR_9->getLength());
delete VAR_9;
}
(*VAR_3)(VAR_4, ""/Encoding 256 array\n"", 20);
for (VAR_14 = 0; VAR_14 < 256 && VAR_13+VAR_14 < VAR_8; ++VAR_14) {
VAR_9 = GooString::format(""dup {0:d} /c{1:02x} put\n"", VAR_14, VAR_14);
(*VAR_3)(VAR_4, VAR_9->getCString(), VAR_9->getLength());
delete VAR_9;
}
if (VAR_14 < 256) {
VAR_9 = GooString::format(""{0:d} 1 255 {{ 1 index exch /.notdef put }} for\n"",
VAR_14);
(*VAR_3)(VAR_4, VAR_9->getCString(), VAR_9->getLength());
delete VAR_9;
}
(*VAR_3)(VAR_4, ""readonly def\n"", 13);
(*VAR_3)(VAR_4, ""currentdict end\n"", 16);
(*VAR_3)(VAR_4, ""currentfile eexec\n"", 18);
VAR_10.outputFunc = VAR_3;
VAR_10.outputStream = VAR_4;
VAR_10.ascii = VAR_22;
VAR_10.r1 = 55665;
VAR_10.line = 0;
eexecWrite(&VAR_10, ""\x83\xca\x73\xd5"");
eexecWrite(&VAR_10, ""dup /Private 32 dict dup begin\n"");
eexecWrite(&VAR_10, ""/RD {string currentfile exch readstring pop}""
"" executeonly def\n"");
eexecWrite(&VAR_10, ""/ND {noaccess def} executeonly def\n"");
eexecWrite(&VAR_10, ""/NP {noaccess put} executeonly def\n"");
eexecWrite(&VAR_10, ""/MinFeature {16 16} def\n"");
eexecWrite(&VAR_10, ""/password 5839 def\n"");
if (VAR_20[VAR_12].nBlueValues) {
eexecWrite(&VAR_10, ""/BlueValues ["");
for (VAR_15 = 0; VAR_15 < VAR_20[VAR_12].nBlueValues; ++VAR_15) {
VAR_9 = GooString::format(""{0:s}{1:d}"",
VAR_15 > 0 ? "" "" : """",
VAR_20[VAR_12].blueValues[VAR_15]);
eexecWrite(&VAR_10, VAR_9->getCString());
delete VAR_9;
}
eexecWrite(&VAR_10, ""] def\n"");
}
if (VAR_20[VAR_12].nOtherBlues) {
eexecWrite(&VAR_10, ""/OtherBlues ["");
for (VAR_15 = 0; VAR_15 < VAR_20[VAR_12].nOtherBlues; ++VAR_15) {
VAR_9 = GooString::format(""{0:s}{1:d}"",
VAR_15 > 0 ? "" "" : """",
VAR_20[VAR_12].otherBlues[VAR_15]);
eexecWrite(&VAR_10, VAR_9->getCString());
delete VAR_9;
}
eexecWrite(&VAR_10, ""] def\n"");
}
if (VAR_20[VAR_12].nFamilyBlues) {
eexecWrite(&VAR_10, ""/FamilyBlues ["");
for (VAR_15 = 0; VAR_15 < VAR_20[VAR_12].nFamilyBlues; ++VAR_15) {
VAR_9 = GooString::format(""{0:s}{1:d}"", VAR_15 > 0 ? "" "" : """",
VAR_20[VAR_12].familyBlues[VAR_15]);
eexecWrite(&VAR_10, VAR_9->getCString());
delete VAR_9;
}
eexecWrite(&VAR_10, ""] def\n"");
}
if (VAR_20[VAR_12].nFamilyOtherBlues) {
eexecWrite(&VAR_10, ""/FamilyOtherBlues ["");
for (VAR_15 = 0; VAR_15 < VAR_20[VAR_12].nFamilyOtherBlues; ++VAR_15) {
VAR_9 = GooString::format(""{0:s}{1:d}"", VAR_15 > 0 ? "" "" : """",
VAR_20[VAR_12].familyOtherBlues[VAR_15]);
eexecWrite(&VAR_10, VAR_9->getCString());
delete VAR_9;
}
eexecWrite(&VAR_10, ""] def\n"");
}
if (VAR_20[VAR_12].blueScale != 0.039625) {
VAR_9 = GooString::format(""/BlueScale {0:.4g} def\n"",
VAR_20[VAR_12].blueScale);
eexecWrite(&VAR_10, VAR_9->getCString());
delete VAR_9;
}
if (VAR_20[VAR_12].blueShift != 7) {
VAR_9 = GooString::format(""/BlueShift {0:d} def\n"",
VAR_20[VAR_12].blueShift);
eexecWrite(&VAR_10, VAR_9->getCString());
delete VAR_9;
}
if (VAR_20[VAR_12].blueFuzz != 1) {
VAR_9 = GooString::format(""/BlueFuzz {0:d} def\n"",
VAR_20[VAR_12].blueFuzz);
eexecWrite(&VAR_10, VAR_9->getCString());
delete VAR_9;
}
if (VAR_20[VAR_12].hasStdHW) {
VAR_9 = GooString::format(""/StdHW [{0:.4g}] def\n"", VAR_20[VAR_12].stdHW);
eexecWrite(&VAR_10, VAR_9->getCString());
delete VAR_9;
}
if (VAR_20[VAR_12].hasStdVW) {
VAR_9 = GooString::format(""/StdVW [{0:.4g}] def\n"", VAR_20[VAR_12].stdVW);
eexecWrite(&VAR_10, VAR_9->getCString());
delete VAR_9;
}
if (VAR_20[VAR_12].nStemSnapH) {
eexecWrite(&VAR_10, ""/StemSnapH ["");
for (VAR_15 = 0; VAR_15 < VAR_20[VAR_12].nStemSnapH; ++VAR_15) {
VAR_9 = GooString::format(""{0:s}{1:.4g}"",
VAR_15 > 0 ? "" "" : """", VAR_20[VAR_12].stemSnapH[VAR_15]);
eexecWrite(&VAR_10, VAR_9->getCString());
delete VAR_9;
}
eexecWrite(&VAR_10, ""] def\n"");
}
if (VAR_20[VAR_12].nStemSnapV) {
eexecWrite(&VAR_10, ""/StemSnapV ["");
for (VAR_15 = 0; VAR_15 < VAR_20[VAR_12].nStemSnapV; ++VAR_15) {
VAR_9 = GooString::format(""{0:s}{1:.4g}"",
VAR_15 > 0 ? "" "" : """", VAR_20[VAR_12].stemSnapV[VAR_15]);
eexecWrite(&VAR_10, VAR_9->getCString());
delete VAR_9;
}
eexecWrite(&VAR_10, ""] def\n"");
}
if (VAR_20[VAR_12].hasForceBold) {
VAR_9 = GooString::format(""/ForceBold {0:s} def\n"",
VAR_20[VAR_12].forceBold ? ""true"" : ""false"");
eexecWrite(&VAR_10, VAR_9->getCString());
delete VAR_9;
}
if (VAR_20[VAR_12].forceBoldThreshold != 0) {
VAR_9 = GooString::format(""/ForceBoldThreshold {0:.4g} def\n"",
VAR_20[VAR_12].forceBoldThreshold);
eexecWrite(&VAR_10, VAR_9->getCString());
delete VAR_9;
}
if (VAR_20[VAR_12].languageGroup != 0) {
VAR_9 = GooString::format(""/LanguageGroup {0:d} def\n"",
VAR_20[VAR_12].languageGroup);
eexecWrite(&VAR_10, VAR_9->getCString());
delete VAR_9;
}
if (VAR_20[VAR_12].expansionFactor != 0.06) {
VAR_9 = GooString::format(""/ExpansionFactor {0:.4g} def\n"",
VAR_20[VAR_12].expansionFactor);
eexecWrite(&VAR_10, VAR_9->getCString());
delete VAR_9;
}
VAR_11 = VAR_22;
getIndex(VAR_20[VAR_12].subrsOffset, &VAR_6, &VAR_11);
if (!VAR_11) {
VAR_6.pos = -1;
}
eexecWrite(&VAR_10, ""2 index /CharStrings 256 dict dup begin\n"");
VAR_11 = VAR_22;
getIndexVal(&VAR_23, 0, &VAR_7, &VAR_11);
if (VAR_11) {
eexecCvtGlyph(&VAR_10, "".notdef"", VAR_7.pos, VAR_7.len,
&VAR_6, &VAR_20[VAR_12]);
}
for (VAR_14 = 0; VAR_14 < 256 && VAR_13+VAR_14 < VAR_8; ++VAR_14) {
if (VAR_5[VAR_13+VAR_14] >= 0) {
VAR_11 = VAR_22;
getIndexVal(&VAR_23, VAR_5[VAR_13+VAR_14], &VAR_7, &VAR_11);
if (VAR_11) {
VAR_9 = GooString::format(""c{0:02x}"", VAR_14);
eexecCvtGlyph(&VAR_10, VAR_9->getCString(), VAR_7.pos, VAR_7.len,
&VAR_6, &VAR_20[VAR_12]);
delete VAR_9;
}
}
}
eexecWrite(&VAR_10, ""end\n"");
eexecWrite(&VAR_10, ""end\n"");
eexecWrite(&VAR_10, ""readonly put\n"");
eexecWrite(&VAR_10, ""noaccess put\n"");
eexecWrite(&VAR_10, ""dup /FontName get exch definefont pop\n"");
eexecWrite(&VAR_10, ""mark currentfile closefile\n"");
if (VAR_10.line > 0) {
(*VAR_3)(VAR_4, ""\n"", 1);
}
for (VAR_14 = 0; VAR_14 < 8; ++VAR_14) {
(*VAR_3)(VAR_4, ""0000000000000000000000000000000000000000000000000000000000000000\n"", 65);
}
(*VAR_3)(VAR_4, ""cleartomark\n"", 12);
}
} else {
error(VAR_24, -1, ""FoFiType1C::convertToType0 without privateDicts"");
}
(*VAR_3)(VAR_4, ""16 dict begin\n"", 14);
(*VAR_3)(VAR_4, ""/FontName /"", 11);
(*VAR_3)(VAR_4, VAR_0, strlen(VAR_0));
(*VAR_3)(VAR_4, "" def\n"", 5);
(*VAR_3)(VAR_4, ""/FontType 0 def\n"", 16);
if (VAR_17.hasFontMatrix) {
VAR_9 = GooString::format(""/FontMatrix [{0:.8g} {1:.8g} {2:.8g} {3:.8g} {4:.8g} {5:.8g}] def\n"",
VAR_17.fontMatrix[0], VAR_17.fontMatrix[1],
VAR_17.fontMatrix[2], VAR_17.fontMatrix[3],
VAR_17.fontMatrix[4], VAR_17.fontMatrix[5]);
(*VAR_3)(VAR_4, VAR_9->getCString(), VAR_9->getLength());
delete VAR_9;
} else {
(*VAR_3)(VAR_4, ""/FontMatrix [1 0 0 1 0 0] def\n"", 30);
}
(*VAR_3)(VAR_4, ""/FMapType 2 def\n"", 16);
(*VAR_3)(VAR_4, ""/Encoding [\n"", 12);
for (VAR_13 = 0; VAR_13 < VAR_8; VAR_13 += 256) {
VAR_9 = GooString::format(""{0:d}\n"", VAR_13 >> 8);
(*VAR_3)(VAR_4, VAR_9->getCString(), VAR_9->getLength());
delete VAR_9;
}
(*VAR_3)(VAR_4, ""] def\n"", 6);
(*VAR_3)(VAR_4, ""/FDepVector [\n"", 14);
for (VAR_13 = 0; VAR_13 < VAR_8; VAR_13 += 256) {
(*VAR_3)(VAR_4, ""/"", 1);
(*VAR_3)(VAR_4, VAR_0, strlen(VAR_0));
VAR_9 = GooString::format(""_{0:02x} findfont\n"", VAR_13 >> 8);
(*VAR_3)(VAR_4, VAR_9->getCString(), VAR_9->getLength());
delete VAR_9;
}
(*VAR_3)(VAR_4, ""] def\n"", 6);
(*VAR_3)(VAR_4, ""FontName currentdict end definefont pop\n"", 40);
gfree(VAR_5);
}",poppler/da63c35549e8852a410946ab016a3f25ac701bdf/FoFiType1C.cc/vul/before/0.json,"void FoFiType1C::convertToType0(char *psName, int *codeMap, int nCodes,
				FoFiOutputFunc outputFunc,
				void *outputStream) {
  int *cidMap;
  Type1CIndex subrIdx;
  Type1CIndexVal val;
  int nCIDs;
  GooString *buf;
  Type1CEexecBuf eb;
  GBool ok;
  int fd, i, j, k;

  // compute the CID count and build the CID-to-GID mapping
  if (codeMap) {
    nCIDs = nCodes;
    cidMap = (int *)gmallocn(nCIDs, sizeof(int));
    for (i = 0; i < nCodes; ++i) {
      if (codeMap[i] >= 0 && codeMap[i] < nGlyphs) {
	cidMap[i] = codeMap[i];
      } else {
	cidMap[i] = -1;
      }
    }
  } else if (topDict.firstOp == 0x0c1e) {
    nCIDs = 0;
    for (i = 0; i < nGlyphs && i < charsetLength; ++i) {
      if (charset[i] >= nCIDs) {
	nCIDs = charset[i] + 1;
      }
    }
    cidMap = (int *)gmallocn(nCIDs, sizeof(int));
    for (i = 0; i < nCIDs; ++i) {
      cidMap[i] = -1;
    }
    for (i = 0; i < nGlyphs && i < charsetLength; ++i) {
      cidMap[charset[i]] = i;
    }
  } else {
    nCIDs = nGlyphs;
    cidMap = (int *)gmallocn(nCIDs, sizeof(int));
    for (i = 0; i < nCIDs; ++i) {
      cidMap[i] = i;
    }
  }

  if (privateDicts) {
  // write the descendant Type 1 fonts
    for (i = 0; i < nCIDs; i += 256) {

      //~ this assumes that all CIDs in this block have the same FD --
      //~ to handle multiple FDs correctly, need to somehow divide the
      //~ font up by FD; as a kludge we ignore CID 0, which is .notdef
      fd = 0;
      // if fdSelect is NULL, we have an 8-bit font, so just leave fd=0
      if (fdSelect) {
	for (j = i==0 ? 1 : 0; j < 256 && i+j < nCIDs; ++j) {
	  if (cidMap[i+j] >= 0) {
	    fd = fdSelect[cidMap[i+j]];
	    break;
	  }
	}
      }

      if (fd >= nFDs)
	continue;

      // font dictionary (unencrypted section)
      (*outputFunc)(outputStream, ""16 dict begin\n"", 14);
      (*outputFunc)(outputStream, ""/FontName /"", 11);
      (*outputFunc)(outputStream, psName, strlen(psName));
      buf = GooString::format(""_{0:02x} def\n"", i >> 8);
      (*outputFunc)(outputStream, buf->getCString(), buf->getLength());
      delete buf;
      (*outputFunc)(outputStream, ""/FontType 1 def\n"", 16);
      if (privateDicts[fd].hasFontMatrix) {
	buf = GooString::format(""/FontMatrix [{0:.8g} {1:.8g} {2:.8g} {3:.8g} {4:.8g} {5:.8g}] def\n"",
			      privateDicts[fd].fontMatrix[0],
			      privateDicts[fd].fontMatrix[1],
			      privateDicts[fd].fontMatrix[2],
			      privateDicts[fd].fontMatrix[3],
			      privateDicts[fd].fontMatrix[4],
			      privateDicts[fd].fontMatrix[5]);
	(*outputFunc)(outputStream, buf->getCString(), buf->getLength());
	delete buf;
      } else if (topDict.hasFontMatrix) {
	(*outputFunc)(outputStream, ""/FontMatrix [1 0 0 1 0 0] def\n"", 30);
      } else {
	(*outputFunc)(outputStream,
		      ""/FontMatrix [0.001 0 0 0.001 0 0] def\n"", 38);
      }
      buf = GooString::format(""/FontBBox [{0:.4g} {1:.4g} {2:.4g} {3:.4g}] def\n"",
			    topDict.fontBBox[0], topDict.fontBBox[1],
			    topDict.fontBBox[2], topDict.fontBBox[3]);
      (*outputFunc)(outputStream, buf->getCString(), buf->getLength());
      delete buf;
      buf = GooString::format(""/PaintType {0:d} def\n"", topDict.paintType);
      (*outputFunc)(outputStream, buf->getCString(), buf->getLength());
      delete buf;
      if (topDict.paintType != 0) {
	buf = GooString::format(""/StrokeWidth {0:.4g} def\n"", topDict.strokeWidth);
	(*outputFunc)(outputStream, buf->getCString(), buf->getLength());
	delete buf;
      }
      (*outputFunc)(outputStream, ""/Encoding 256 array\n"", 20);
      for (j = 0; j < 256 && i+j < nCIDs; ++j) {
	buf = GooString::format(""dup {0:d} /c{1:02x} put\n"", j, j);
	(*outputFunc)(outputStream, buf->getCString(), buf->getLength());
	delete buf;
      }
      if (j < 256) {
	buf = GooString::format(""{0:d} 1 255 {{ 1 index exch /.notdef put }} for\n"",
			      j);
	(*outputFunc)(outputStream, buf->getCString(), buf->getLength());
	delete buf;
      }
      (*outputFunc)(outputStream, ""readonly def\n"", 13);
      (*outputFunc)(outputStream, ""currentdict end\n"", 16);

      // start the binary section
      (*outputFunc)(outputStream, ""currentfile eexec\n"", 18);
      eb.outputFunc = outputFunc;
      eb.outputStream = outputStream;
      eb.ascii = gTrue;
      eb.r1 = 55665;
      eb.line = 0;

      // start the private dictionary
      eexecWrite(&eb, ""\x83\xca\x73\xd5"");
      eexecWrite(&eb, ""dup /Private 32 dict dup begin\n"");
      eexecWrite(&eb, ""/RD {string currentfile exch readstring pop}""
		"" executeonly def\n"");
      eexecWrite(&eb, ""/ND {noaccess def} executeonly def\n"");
      eexecWrite(&eb, ""/NP {noaccess put} executeonly def\n"");
      eexecWrite(&eb, ""/MinFeature {16 16} def\n"");
      eexecWrite(&eb, ""/password 5839 def\n"");
      if (privateDicts[fd].nBlueValues) {
	eexecWrite(&eb, ""/BlueValues ["");
	for (k = 0; k < privateDicts[fd].nBlueValues; ++k) {
	  buf = GooString::format(""{0:s}{1:d}"",
				k > 0 ? "" "" : """",
				privateDicts[fd].blueValues[k]);
	  eexecWrite(&eb, buf->getCString());
	  delete buf;
	}
	eexecWrite(&eb, ""] def\n"");
      }
      if (privateDicts[fd].nOtherBlues) {
	eexecWrite(&eb, ""/OtherBlues ["");
	for (k = 0; k < privateDicts[fd].nOtherBlues; ++k) {
	  buf = GooString::format(""{0:s}{1:d}"",
				k > 0 ? "" "" : """",
				privateDicts[fd].otherBlues[k]);
	  eexecWrite(&eb, buf->getCString());
	  delete buf;
	}
	eexecWrite(&eb, ""] def\n"");
      }
      if (privateDicts[fd].nFamilyBlues) {
	eexecWrite(&eb, ""/FamilyBlues ["");
	for (k = 0; k < privateDicts[fd].nFamilyBlues; ++k) {
	  buf = GooString::format(""{0:s}{1:d}"", k > 0 ? "" "" : """",
				privateDicts[fd].familyBlues[k]);
	  eexecWrite(&eb, buf->getCString());
	  delete buf;
	}
	eexecWrite(&eb, ""] def\n"");
      }
      if (privateDicts[fd].nFamilyOtherBlues) {
	eexecWrite(&eb, ""/FamilyOtherBlues ["");
	for (k = 0; k < privateDicts[fd].nFamilyOtherBlues; ++k) {
	  buf = GooString::format(""{0:s}{1:d}"", k > 0 ? "" "" : """",
				privateDicts[fd].familyOtherBlues[k]);
	  eexecWrite(&eb, buf->getCString());
	  delete buf;
	}
	eexecWrite(&eb, ""] def\n"");
      }
      if (privateDicts[fd].blueScale != 0.039625) {
	buf = GooString::format(""/BlueScale {0:.4g} def\n"",
			      privateDicts[fd].blueScale);
	eexecWrite(&eb, buf->getCString());
	delete buf;
      }
      if (privateDicts[fd].blueShift != 7) {
	buf = GooString::format(""/BlueShift {0:d} def\n"",
			      privateDicts[fd].blueShift);
	eexecWrite(&eb, buf->getCString());
	delete buf;
      }
      if (privateDicts[fd].blueFuzz != 1) {
	buf = GooString::format(""/BlueFuzz {0:d} def\n"",
			      privateDicts[fd].blueFuzz);
	eexecWrite(&eb, buf->getCString());
	delete buf;
      }
      if (privateDicts[fd].hasStdHW) {
	buf = GooString::format(""/StdHW [{0:.4g}] def\n"", privateDicts[fd].stdHW);
	eexecWrite(&eb, buf->getCString());
	delete buf;
      }
      if (privateDicts[fd].hasStdVW) {
	buf = GooString::format(""/StdVW [{0:.4g}] def\n"", privateDicts[fd].stdVW);
	eexecWrite(&eb, buf->getCString());
	delete buf;
      }
      if (privateDicts[fd].nStemSnapH) {
	eexecWrite(&eb, ""/StemSnapH ["");
	for (k = 0; k < privateDicts[fd].nStemSnapH; ++k) {
	  buf = GooString::format(""{0:s}{1:.4g}"",
				k > 0 ? "" "" : """", privateDicts[fd].stemSnapH[k]);
	  eexecWrite(&eb, buf->getCString());
	  delete buf;
	}
	eexecWrite(&eb, ""] def\n"");
      }
      if (privateDicts[fd].nStemSnapV) {
	eexecWrite(&eb, ""/StemSnapV ["");
	for (k = 0; k < privateDicts[fd].nStemSnapV; ++k) {
	  buf = GooString::format(""{0:s}{1:.4g}"",
				k > 0 ? "" "" : """", privateDicts[fd].stemSnapV[k]);
	  eexecWrite(&eb, buf->getCString());
	  delete buf;
	}
	eexecWrite(&eb, ""] def\n"");
      }
      if (privateDicts[fd].hasForceBold) {
	buf = GooString::format(""/ForceBold {0:s} def\n"",
			      privateDicts[fd].forceBold ? ""true"" : ""false"");
	eexecWrite(&eb, buf->getCString());
	delete buf;
      }
      if (privateDicts[fd].forceBoldThreshold != 0) {
	buf = GooString::format(""/ForceBoldThreshold {0:.4g} def\n"",
			      privateDicts[fd].forceBoldThreshold);
	eexecWrite(&eb, buf->getCString());
	delete buf;
      }
      if (privateDicts[fd].languageGroup != 0) {
	buf = GooString::format(""/LanguageGroup {0:d} def\n"",
			      privateDicts[fd].languageGroup);
	eexecWrite(&eb, buf->getCString());
	delete buf;
      }
      if (privateDicts[fd].expansionFactor != 0.06) {
	buf = GooString::format(""/ExpansionFactor {0:.4g} def\n"",
			      privateDicts[fd].expansionFactor);
	eexecWrite(&eb, buf->getCString());
	delete buf;
      }

      // set up the subroutines
      ok = gTrue;
      getIndex(privateDicts[fd].subrsOffset, &subrIdx, &ok);
      if (!ok) {
	subrIdx.pos = -1;
      }

      // start the CharStrings
      eexecWrite(&eb, ""2 index /CharStrings 256 dict dup begin\n"");

      // write the .notdef CharString
      ok = gTrue;
      getIndexVal(&charStringsIdx, 0, &val, &ok);
      if (ok) {
	eexecCvtGlyph(&eb, "".notdef"", val.pos, val.len,
		      &subrIdx, &privateDicts[fd]);
      }

      // write the CharStrings
      for (j = 0; j < 256 && i+j < nCIDs; ++j) {
	if (cidMap[i+j] >= 0) {
	  ok = gTrue;
	  getIndexVal(&charStringsIdx, cidMap[i+j], &val, &ok);
	  if (ok) {
	    buf = GooString::format(""c{0:02x}"", j);
	    eexecCvtGlyph(&eb, buf->getCString(), val.pos, val.len,
			  &subrIdx, &privateDicts[fd]);
	    delete buf;
	  }
	}
      }
      eexecWrite(&eb, ""end\n"");
      eexecWrite(&eb, ""end\n"");
      eexecWrite(&eb, ""readonly put\n"");
      eexecWrite(&eb, ""noaccess put\n"");
      eexecWrite(&eb, ""dup /FontName get exch definefont pop\n"");
      eexecWrite(&eb, ""mark currentfile closefile\n"");

      // trailer
      if (eb.line > 0) {
	(*outputFunc)(outputStream, ""\n"", 1);
      }
      for (j = 0; j < 8; ++j) {
	(*outputFunc)(outputStream, ""0000000000000000000000000000000000000000000000000000000000000000\n"", 65);
      }
      (*outputFunc)(outputStream, ""cleartomark\n"", 12);
    }
  } else {
    error(errSyntaxError, -1, ""FoFiType1C::convertToType0 without privateDicts"");
  }

  // write the Type 0 parent font
  (*outputFunc)(outputStream, ""16 dict begin\n"", 14);
  (*outputFunc)(outputStream, ""/FontName /"", 11);
  (*outputFunc)(outputStream, psName, strlen(psName));
  (*outputFunc)(outputStream, "" def\n"", 5);
  (*outputFunc)(outputStream, ""/FontType 0 def\n"", 16);
  if (topDict.hasFontMatrix) {
    buf = GooString::format(""/FontMatrix [{0:.8g} {1:.8g} {2:.8g} {3:.8g} {4:.8g} {5:.8g}] def\n"",
			  topDict.fontMatrix[0], topDict.fontMatrix[1],
			  topDict.fontMatrix[2], topDict.fontMatrix[3],
			  topDict.fontMatrix[4], topDict.fontMatrix[5]);
    (*outputFunc)(outputStream, buf->getCString(), buf->getLength());
    delete buf;
  } else {
    (*outputFunc)(outputStream, ""/FontMatrix [1 0 0 1 0 0] def\n"", 30);
  }
  (*outputFunc)(outputStream, ""/FMapType 2 def\n"", 16);
  (*outputFunc)(outputStream, ""/Encoding [\n"", 12);
  for (i = 0; i < nCIDs; i += 256) {
    buf = GooString::format(""{0:d}\n"", i >> 8);
    (*outputFunc)(outputStream, buf->getCString(), buf->getLength());
    delete buf;
  }
  (*outputFunc)(outputStream, ""] def\n"", 6);
  (*outputFunc)(outputStream, ""/FDepVector [\n"", 14);
  for (i = 0; i < nCIDs; i += 256) {
    (*outputFunc)(outputStream, ""/"", 1);
    (*outputFunc)(outputStream, psName, strlen(psName));
    buf = GooString::format(""_{0:02x} findfont\n"", i >> 8);
    (*outputFunc)(outputStream, buf->getCString(), buf->getLength());
    delete buf;
  }
  (*outputFunc)(outputStream, ""] def\n"", 6);
  (*outputFunc)(outputStream, ""FontName currentdict end definefont pop\n"", 40);

  gfree(cidMap);
}","void FoFiType1C::convertToType0(char *VAR_0, int *VAR_1, int VAR_2,
				FoFiOutputFunc VAR_3,
				void *VAR_4) {
  int *VAR_5;
  Type1CIndex VAR_6;
  Type1CIndexVal VAR_7;
  int VAR_8;
  GooString *VAR_9;
  Type1CEexecBuf VAR_10;
  GBool VAR_11;
  int VAR_12, VAR_13, VAR_14, VAR_15;

  /* COMMENT_0 */
  if (VAR_1) {
    VAR_8 = VAR_2;
    VAR_5 = (int *)gmallocn(VAR_8, sizeof(int));
    for (VAR_13 = 0; VAR_13 < VAR_2; ++VAR_13) {
      if (VAR_1[VAR_13] >= 0 && VAR_1[VAR_13] < VAR_16) {
	VAR_5[VAR_13] = VAR_1[VAR_13];
      } else {
	VAR_5[VAR_13] = -1;
      }
    }
  } else if (VAR_17.firstOp == 0x0c1e) {
    VAR_8 = 0;
    for (VAR_13 = 0; VAR_13 < VAR_16 && VAR_13 < VAR_18; ++VAR_13) {
      if (VAR_19[VAR_13] >= VAR_8) {
	VAR_8 = VAR_19[VAR_13] + 1;
      }
    }
    VAR_5 = (int *)gmallocn(VAR_8, sizeof(int));
    for (VAR_13 = 0; VAR_13 < VAR_8; ++VAR_13) {
      VAR_5[VAR_13] = -1;
    }
    for (VAR_13 = 0; VAR_13 < VAR_16 && VAR_13 < VAR_18; ++VAR_13) {
      VAR_5[VAR_19[VAR_13]] = VAR_13;
    }
  } else {
    VAR_8 = VAR_16;
    VAR_5 = (int *)gmallocn(VAR_8, sizeof(int));
    for (VAR_13 = 0; VAR_13 < VAR_8; ++VAR_13) {
      VAR_5[VAR_13] = VAR_13;
    }
  }

  if (VAR_20) {
  /* COMMENT_1 */
    for (VAR_13 = 0; VAR_13 < VAR_8; VAR_13 += 256) {

      /* COMMENT_2 */
      /* COMMENT_3 */
      /* COMMENT_4 */
      VAR_12 = 0;
      /* COMMENT_5 */
      if (VAR_21) {
	for (VAR_14 = VAR_13==0 ? 1 : 0; VAR_14 < 256 && VAR_13+VAR_14 < VAR_8; ++VAR_14) {
	  if (VAR_5[VAR_13+VAR_14] >= 0) {
	    VAR_12 = VAR_21[VAR_5[VAR_13+VAR_14]];
	    break;
	  }
	}
      }

      if (VAR_12 >= VAR_22)
	continue;

      /* COMMENT_6 */
      (*VAR_3)(VAR_4, ""16 dict begin\n"", 14);
      (*VAR_3)(VAR_4, ""/FontName /"", 11);
      (*VAR_3)(VAR_4, VAR_0, strlen(VAR_0));
      VAR_9 = GooString::format(""_{0:02x} def\n"", VAR_13 >> 8);
      (*VAR_3)(VAR_4, VAR_9->getCString(), VAR_9->getLength());
      delete VAR_9;
      (*VAR_3)(VAR_4, ""/FontType 1 def\n"", 16);
      if (VAR_20[VAR_12].hasFontMatrix) {
	VAR_9 = GooString::format(""/FontMatrix [{0:.8g} {1:.8g} {2:.8g} {3:.8g} {4:.8g} {5:.8g}] def\n"",
			      VAR_20[VAR_12].fontMatrix[0],
			      VAR_20[VAR_12].fontMatrix[1],
			      VAR_20[VAR_12].fontMatrix[2],
			      VAR_20[VAR_12].fontMatrix[3],
			      VAR_20[VAR_12].fontMatrix[4],
			      VAR_20[VAR_12].fontMatrix[5]);
	(*VAR_3)(VAR_4, VAR_9->getCString(), VAR_9->getLength());
	delete VAR_9;
      } else if (VAR_17.hasFontMatrix) {
	(*VAR_3)(VAR_4, ""/FontMatrix [1 0 0 1 0 0] def\n"", 30);
      } else {
	(*VAR_3)(VAR_4,
		      ""/FontMatrix [0.001 0 0 0.001 0 0] def\n"", 38);
      }
      VAR_9 = GooString::format(""/FontBBox [{0:.4g} {1:.4g} {2:.4g} {3:.4g}] def\n"",
			    VAR_17.fontBBox[0], VAR_17.fontBBox[1],
			    VAR_17.fontBBox[2], VAR_17.fontBBox[3]);
      (*VAR_3)(VAR_4, VAR_9->getCString(), VAR_9->getLength());
      delete VAR_9;
      VAR_9 = GooString::format(""/PaintType {0:d} def\n"", VAR_17.paintType);
      (*VAR_3)(VAR_4, VAR_9->getCString(), VAR_9->getLength());
      delete VAR_9;
      if (VAR_17.paintType != 0) {
	VAR_9 = GooString::format(""/StrokeWidth {0:.4g} def\n"", VAR_17.strokeWidth);
	(*VAR_3)(VAR_4, VAR_9->getCString(), VAR_9->getLength());
	delete VAR_9;
      }
      (*VAR_3)(VAR_4, ""/Encoding 256 array\n"", 20);
      for (VAR_14 = 0; VAR_14 < 256 && VAR_13+VAR_14 < VAR_8; ++VAR_14) {
	VAR_9 = GooString::format(""dup {0:d} /c{1:02x} put\n"", VAR_14, VAR_14);
	(*VAR_3)(VAR_4, VAR_9->getCString(), VAR_9->getLength());
	delete VAR_9;
      }
      if (VAR_14 < 256) {
	VAR_9 = GooString::format(""{0:d} 1 255 {{ 1 index exch /.notdef put }} for\n"",
			      VAR_14);
	(*VAR_3)(VAR_4, VAR_9->getCString(), VAR_9->getLength());
	delete VAR_9;
      }
      (*VAR_3)(VAR_4, ""readonly def\n"", 13);
      (*VAR_3)(VAR_4, ""currentdict end\n"", 16);

      /* COMMENT_7 */
      (*VAR_3)(VAR_4, ""currentfile eexec\n"", 18);
      VAR_10.outputFunc = VAR_3;
      VAR_10.outputStream = VAR_4;
      VAR_10.ascii = VAR_23;
      VAR_10.r1 = 55665;
      VAR_10.line = 0;

      /* COMMENT_8 */
      eexecWrite(&VAR_10, ""\x83\xca\x73\xd5"");
      eexecWrite(&VAR_10, ""dup /Private 32 dict dup begin\n"");
      eexecWrite(&VAR_10, ""/RD {string currentfile exch readstring pop}""
		"" executeonly def\n"");
      eexecWrite(&VAR_10, ""/ND {noaccess def} executeonly def\n"");
      eexecWrite(&VAR_10, ""/NP {noaccess put} executeonly def\n"");
      eexecWrite(&VAR_10, ""/MinFeature {16 16} def\n"");
      eexecWrite(&VAR_10, ""/password 5839 def\n"");
      if (VAR_20[VAR_12].nBlueValues) {
	eexecWrite(&VAR_10, ""/BlueValues ["");
	for (VAR_15 = 0; VAR_15 < VAR_20[VAR_12].nBlueValues; ++VAR_15) {
	  VAR_9 = GooString::format(""{0:s}{1:d}"",
				VAR_15 > 0 ? "" "" : """",
				VAR_20[VAR_12].blueValues[VAR_15]);
	  eexecWrite(&VAR_10, VAR_9->getCString());
	  delete VAR_9;
	}
	eexecWrite(&VAR_10, ""] def\n"");
      }
      if (VAR_20[VAR_12].nOtherBlues) {
	eexecWrite(&VAR_10, ""/OtherBlues ["");
	for (VAR_15 = 0; VAR_15 < VAR_20[VAR_12].nOtherBlues; ++VAR_15) {
	  VAR_9 = GooString::format(""{0:s}{1:d}"",
				VAR_15 > 0 ? "" "" : """",
				VAR_20[VAR_12].otherBlues[VAR_15]);
	  eexecWrite(&VAR_10, VAR_9->getCString());
	  delete VAR_9;
	}
	eexecWrite(&VAR_10, ""] def\n"");
      }
      if (VAR_20[VAR_12].nFamilyBlues) {
	eexecWrite(&VAR_10, ""/FamilyBlues ["");
	for (VAR_15 = 0; VAR_15 < VAR_20[VAR_12].nFamilyBlues; ++VAR_15) {
	  VAR_9 = GooString::format(""{0:s}{1:d}"", VAR_15 > 0 ? "" "" : """",
				VAR_20[VAR_12].familyBlues[VAR_15]);
	  eexecWrite(&VAR_10, VAR_9->getCString());
	  delete VAR_9;
	}
	eexecWrite(&VAR_10, ""] def\n"");
      }
      if (VAR_20[VAR_12].nFamilyOtherBlues) {
	eexecWrite(&VAR_10, ""/FamilyOtherBlues ["");
	for (VAR_15 = 0; VAR_15 < VAR_20[VAR_12].nFamilyOtherBlues; ++VAR_15) {
	  VAR_9 = GooString::format(""{0:s}{1:d}"", VAR_15 > 0 ? "" "" : """",
				VAR_20[VAR_12].familyOtherBlues[VAR_15]);
	  eexecWrite(&VAR_10, VAR_9->getCString());
	  delete VAR_9;
	}
	eexecWrite(&VAR_10, ""] def\n"");
      }
      if (VAR_20[VAR_12].blueScale != 0.039625) {
	VAR_9 = GooString::format(""/BlueScale {0:.4g} def\n"",
			      VAR_20[VAR_12].blueScale);
	eexecWrite(&VAR_10, VAR_9->getCString());
	delete VAR_9;
      }
      if (VAR_20[VAR_12].blueShift != 7) {
	VAR_9 = GooString::format(""/BlueShift {0:d} def\n"",
			      VAR_20[VAR_12].blueShift);
	eexecWrite(&VAR_10, VAR_9->getCString());
	delete VAR_9;
      }
      if (VAR_20[VAR_12].blueFuzz != 1) {
	VAR_9 = GooString::format(""/BlueFuzz {0:d} def\n"",
			      VAR_20[VAR_12].blueFuzz);
	eexecWrite(&VAR_10, VAR_9->getCString());
	delete VAR_9;
      }
      if (VAR_20[VAR_12].hasStdHW) {
	VAR_9 = GooString::format(""/StdHW [{0:.4g}] def\n"", VAR_20[VAR_12].stdHW);
	eexecWrite(&VAR_10, VAR_9->getCString());
	delete VAR_9;
      }
      if (VAR_20[VAR_12].hasStdVW) {
	VAR_9 = GooString::format(""/StdVW [{0:.4g}] def\n"", VAR_20[VAR_12].stdVW);
	eexecWrite(&VAR_10, VAR_9->getCString());
	delete VAR_9;
      }
      if (VAR_20[VAR_12].nStemSnapH) {
	eexecWrite(&VAR_10, ""/StemSnapH ["");
	for (VAR_15 = 0; VAR_15 < VAR_20[VAR_12].nStemSnapH; ++VAR_15) {
	  VAR_9 = GooString::format(""{0:s}{1:.4g}"",
				VAR_15 > 0 ? "" "" : """", VAR_20[VAR_12].stemSnapH[VAR_15]);
	  eexecWrite(&VAR_10, VAR_9->getCString());
	  delete VAR_9;
	}
	eexecWrite(&VAR_10, ""] def\n"");
      }
      if (VAR_20[VAR_12].nStemSnapV) {
	eexecWrite(&VAR_10, ""/StemSnapV ["");
	for (VAR_15 = 0; VAR_15 < VAR_20[VAR_12].nStemSnapV; ++VAR_15) {
	  VAR_9 = GooString::format(""{0:s}{1:.4g}"",
				VAR_15 > 0 ? "" "" : """", VAR_20[VAR_12].stemSnapV[VAR_15]);
	  eexecWrite(&VAR_10, VAR_9->getCString());
	  delete VAR_9;
	}
	eexecWrite(&VAR_10, ""] def\n"");
      }
      if (VAR_20[VAR_12].hasForceBold) {
	VAR_9 = GooString::format(""/ForceBold {0:s} def\n"",
			      VAR_20[VAR_12].forceBold ? ""true"" : ""false"");
	eexecWrite(&VAR_10, VAR_9->getCString());
	delete VAR_9;
      }
      if (VAR_20[VAR_12].forceBoldThreshold != 0) {
	VAR_9 = GooString::format(""/ForceBoldThreshold {0:.4g} def\n"",
			      VAR_20[VAR_12].forceBoldThreshold);
	eexecWrite(&VAR_10, VAR_9->getCString());
	delete VAR_9;
      }
      if (VAR_20[VAR_12].languageGroup != 0) {
	VAR_9 = GooString::format(""/LanguageGroup {0:d} def\n"",
			      VAR_20[VAR_12].languageGroup);
	eexecWrite(&VAR_10, VAR_9->getCString());
	delete VAR_9;
      }
      if (VAR_20[VAR_12].expansionFactor != 0.06) {
	VAR_9 = GooString::format(""/ExpansionFactor {0:.4g} def\n"",
			      VAR_20[VAR_12].expansionFactor);
	eexecWrite(&VAR_10, VAR_9->getCString());
	delete VAR_9;
      }

      /* COMMENT_9 */
      VAR_11 = VAR_23;
      getIndex(VAR_20[VAR_12].subrsOffset, &VAR_6, &VAR_11);
      if (!VAR_11) {
	VAR_6.pos = -1;
      }

      /* COMMENT_10 */
      eexecWrite(&VAR_10, ""2 index /CharStrings 256 dict dup begin\n"");

      /* COMMENT_11 */
      VAR_11 = VAR_23;
      getIndexVal(&VAR_24, 0, &VAR_7, &VAR_11);
      if (VAR_11) {
	eexecCvtGlyph(&VAR_10, "".notdef"", VAR_7.pos, VAR_7.len,
		      &VAR_6, &VAR_20[VAR_12]);
      }

      /* COMMENT_12 */
      for (VAR_14 = 0; VAR_14 < 256 && VAR_13+VAR_14 < VAR_8; ++VAR_14) {
	if (VAR_5[VAR_13+VAR_14] >= 0) {
	  VAR_11 = VAR_23;
	  getIndexVal(&VAR_24, VAR_5[VAR_13+VAR_14], &VAR_7, &VAR_11);
	  if (VAR_11) {
	    VAR_9 = GooString::format(""c{0:02x}"", VAR_14);
	    eexecCvtGlyph(&VAR_10, VAR_9->getCString(), VAR_7.pos, VAR_7.len,
			  &VAR_6, &VAR_20[VAR_12]);
	    delete VAR_9;
	  }
	}
      }
      eexecWrite(&VAR_10, ""end\n"");
      eexecWrite(&VAR_10, ""end\n"");
      eexecWrite(&VAR_10, ""readonly put\n"");
      eexecWrite(&VAR_10, ""noaccess put\n"");
      eexecWrite(&VAR_10, ""dup /FontName get exch definefont pop\n"");
      eexecWrite(&VAR_10, ""mark currentfile closefile\n"");

      /* COMMENT_13 */
      if (VAR_10.line > 0) {
	(*VAR_3)(VAR_4, ""\n"", 1);
      }
      for (VAR_14 = 0; VAR_14 < 8; ++VAR_14) {
	(*VAR_3)(VAR_4, ""0000000000000000000000000000000000000000000000000000000000000000\n"", 65);
      }
      (*VAR_3)(VAR_4, ""cleartomark\n"", 12);
    }
  } else {
    error(VAR_25, -1, ""FoFiType1C::convertToType0 without privateDicts"");
  }

  /* COMMENT_14 */
  (*VAR_3)(VAR_4, ""16 dict begin\n"", 14);
  (*VAR_3)(VAR_4, ""/FontName /"", 11);
  (*VAR_3)(VAR_4, VAR_0, strlen(VAR_0));
  (*VAR_3)(VAR_4, "" def\n"", 5);
  (*VAR_3)(VAR_4, ""/FontType 0 def\n"", 16);
  if (VAR_17.hasFontMatrix) {
    VAR_9 = GooString::format(""/FontMatrix [{0:.8g} {1:.8g} {2:.8g} {3:.8g} {4:.8g} {5:.8g}] def\n"",
			  VAR_17.fontMatrix[0], VAR_17.fontMatrix[1],
			  VAR_17.fontMatrix[2], VAR_17.fontMatrix[3],
			  VAR_17.fontMatrix[4], VAR_17.fontMatrix[5]);
    (*VAR_3)(VAR_4, VAR_9->getCString(), VAR_9->getLength());
    delete VAR_9;
  } else {
    (*VAR_3)(VAR_4, ""/FontMatrix [1 0 0 1 0 0] def\n"", 30);
  }
  (*VAR_3)(VAR_4, ""/FMapType 2 def\n"", 16);
  (*VAR_3)(VAR_4, ""/Encoding [\n"", 12);
  for (VAR_13 = 0; VAR_13 < VAR_8; VAR_13 += 256) {
    VAR_9 = GooString::format(""{0:d}\n"", VAR_13 >> 8);
    (*VAR_3)(VAR_4, VAR_9->getCString(), VAR_9->getLength());
    delete VAR_9;
  }
  (*VAR_3)(VAR_4, ""] def\n"", 6);
  (*VAR_3)(VAR_4, ""/FDepVector [\n"", 14);
  for (VAR_13 = 0; VAR_13 < VAR_8; VAR_13 += 256) {
    (*VAR_3)(VAR_4, ""/"", 1);
    (*VAR_3)(VAR_4, VAR_0, strlen(VAR_0));
    VAR_9 = GooString::format(""_{0:02x} findfont\n"", VAR_13 >> 8);
    (*VAR_3)(VAR_4, VAR_9->getCString(), VAR_9->getLength());
    delete VAR_9;
  }
  (*VAR_3)(VAR_4, ""] def\n"", 6);
  (*VAR_3)(VAR_4, ""FontName currentdict end definefont pop\n"", 40);

  gfree(VAR_5);
}",poppler/da63c35549e8852a410946ab016a3f25ac701bdf/FoFiType1C.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -60,6 +60,9 @@
 	  }
 	}
       }
+
+      if (fd >= nFDs)
+	continue;
 
       // font dictionary (unencrypted section)
       (*outputFunc)(outputStream, ""16 dict begin\n"", 14);","{'deleted_lines': [], 'added_lines': ['', '      if (fd >= nFDs)', '\tcontinue;']}",True,"The FoFiType1C::convertToType0 function in FoFiType1C.cc in Poppler 0.59.0 has a heap-based buffer over-read vulnerability if an out-of-bounds font dictionary index is encountered, which allows an attacker to launch a denial of service attack.",7.5,HIGH,2,test,,5
CVE-2020-24394,['CWE-732'],AV:L/AC:L/Au:N/C:P/I:P/A:N,0,torvalds/linux,"The server is failing to apply the umask when creating new objects on
filesystems without ACL support.

To reproduce this, you need to use NFSv4.2 and a client and server
recent enough to support umask, and you need to export a filesystem that
lacks ACL support (for example, ext4 with the ""noacl"" mount option).

Filesystems with ACL support are expected to take care of the umask
themselves (usually by calling posix_acl_create).

For filesystems without ACL support, this is up to the caller of
vfs_create(), vfs_mknod(), or vfs_mkdir().

Reported-by: Elliott Mitchell <ehem+debian@m5p.com>
Reported-by: Salvatore Bonaccorso <carnil@debian.org>
Tested-by: Salvatore Bonaccorso <carnil@debian.org>
Fixes: 47057abde515 (""nfsd: add support for the umask attribute"")
Cc: stable@vger.kernel.org
Signed-off-by: J. Bruce Fields <bfields@redhat.com>
",22cf8419f1319ff87ec759d0ebdff4cbafaee832,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=22cf8419f1319ff87ec759d0ebdff4cbafaee832,fs/nfsd/vfs.c,do_nfsd_create,"__be32
do_nfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,
char *fname, int flen, struct iattr *iap,
struct svc_fh *resfhp, int createmode, u32 *verifier,
bool *truncp, bool *created)
{
struct dentry*dentry, *dchild = NULL;
struct inode*dirp;
__be32err;
inthost_err;
__u32v_mtime=0, v_atime=0;
err = nfserr_perm;
if (!flen)
goto out;
err = nfserr_exist;
if (isdotent(fname, flen))
goto out;
if (!(iap->ia_valid & ATTR_MODE))
iap->ia_mode = 0;
err = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);
if (err)
goto out;
dentry = fhp->fh_dentry;
dirp = d_inode(dentry);
host_err = fh_want_write(fhp);
if (host_err)
goto out_nfserr;
fh_lock_nested(fhp, I_MUTEX_PARENT);
dchild = lookup_one_len(fname, dentry, flen);
host_err = PTR_ERR(dchild);
if (IS_ERR(dchild))
goto out_nfserr;
if (d_really_is_negative(dchild)) {
err = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);
if (err)
goto out;
}
err = fh_compose(resfhp, fhp->fh_export, dchild, fhp);
if (err)
goto out;
if (nfsd_create_is_exclusive(createmode)) {
v_mtime = verifier[0]&0x7fffffff;
v_atime = verifier[1]&0x7fffffff;
}
if (d_really_is_positive(dchild)) {
err = 0;
switch (createmode) {
case NFS3_CREATE_UNCHECKED:
if (! d_is_reg(dchild))
goto out;
else if (truncp) {
*truncp = (iap->ia_valid & ATTR_SIZE) && !iap->ia_size;
}
else {
iap->ia_valid &= ATTR_SIZE;
goto set_attr;
}
break;
case NFS3_CREATE_EXCLUSIVE:
if (   d_inode(dchild)->i_mtime.tv_sec == v_mtime
&& d_inode(dchild)->i_atime.tv_sec == v_atime
&& d_inode(dchild)->i_size  == 0 ) {
if (created)
*created = true;
break;
}
case NFS4_CREATE_EXCLUSIVE4_1:
if (   d_inode(dchild)->i_mtime.tv_sec == v_mtime
&& d_inode(dchild)->i_atime.tv_sec == v_atime
&& d_inode(dchild)->i_size  == 0 ) {
if (created)
*created = true;
goto set_attr;
}
case NFS3_CREATE_GUARDED:
err = nfserr_exist;
}
fh_drop_write(fhp);
goto out;
}
host_err = vfs_create(dirp, dchild, iap->ia_mode, true);
if (host_err < 0) {
fh_drop_write(fhp);
goto out_nfserr;
}
if (created)
*created = true;
nfsd_check_ignore_resizing(iap);
if (nfsd_create_is_exclusive(createmode)) {
iap->ia_valid = ATTR_MTIME|ATTR_ATIME
| ATTR_MTIME_SET|ATTR_ATIME_SET;
iap->ia_mtime.tv_sec = v_mtime;
iap->ia_atime.tv_sec = v_atime;
iap->ia_mtime.tv_nsec = 0;
iap->ia_atime.tv_nsec = 0;
}
set_attr:
err = nfsd_create_setattr(rqstp, resfhp, iap);
if (!err)
err = nfserrno(commit_metadata(fhp));
if (!err)
err = fh_update(resfhp);
out:
fh_unlock(fhp);
if (dchild && !IS_ERR(dchild))
dput(dchild);
fh_drop_write(fhp);
return err;
out_nfserr:
err = nfserrno(host_err);
goto out;
}","__be32
do_nfsd_create(struct svc_rqst *VAR_0, struct svc_fh *VAR_1,
char *VAR_2, int VAR_3, struct iattr *VAR_4,
struct svc_fh *VAR_5, int VAR_6, u32 *VAR_7,
bool *VAR_8, bool *VAR_9)
{
struct dentry*dentry, *VAR_10 = NULL;
struct inode*VAR_11;
__be32VAR_12;
intVAR_13;
__u32VAR_14=0, VAR_15=0;
VAR_12 = VAR_16;
if (!VAR_3)
goto out;
VAR_12 = VAR_17;
if (isdotent(VAR_2, VAR_3))
goto out;
if (!(VAR_4->ia_valid & VAR_18))
VAR_4->ia_mode = 0;
VAR_12 = fh_verify(VAR_0, VAR_1, VAR_19, VAR_20);
if (VAR_12)
goto out;
dentry = VAR_1->fh_dentry;
VAR_11 = d_inode(dentry);
VAR_13 = fh_want_write(VAR_1);
if (VAR_13)
goto out_nfserr;
fh_lock_nested(VAR_1, VAR_21);
VAR_10 = lookup_one_len(VAR_2, dentry, VAR_3);
VAR_13 = PTR_ERR(VAR_10);
if (IS_ERR(VAR_10))
goto out_nfserr;
if (d_really_is_negative(VAR_10)) {
VAR_12 = fh_verify(VAR_0, VAR_1, VAR_19, VAR_22);
if (VAR_12)
goto out;
}
VAR_12 = fh_compose(VAR_5, VAR_1->fh_export, VAR_10, VAR_1);
if (VAR_12)
goto out;
if (nfsd_create_is_exclusive(VAR_6)) {
VAR_14 = VAR_7[0]&0x7fffffff;
VAR_15 = VAR_7[1]&0x7fffffff;
}
if (d_really_is_positive(VAR_10)) {
VAR_12 = 0;
switch (VAR_6) {
case VAR_23:
if (! d_is_reg(VAR_10))
goto out;
else if (VAR_8) {
*VAR_8 = (VAR_4->ia_valid & VAR_24) && !VAR_4->ia_size;
}
else {
VAR_4->ia_valid &= VAR_24;
goto set_attr;
}
break;
case VAR_25:
if (   d_inode(VAR_10)->i_mtime.tv_sec == VAR_14
&& d_inode(VAR_10)->i_atime.tv_sec == VAR_15
&& d_inode(VAR_10)->i_size  == 0 ) {
if (VAR_9)
*VAR_9 = true;
break;
}
case VAR_26:
if (   d_inode(VAR_10)->i_mtime.tv_sec == VAR_14
&& d_inode(VAR_10)->i_atime.tv_sec == VAR_15
&& d_inode(VAR_10)->i_size  == 0 ) {
if (VAR_9)
*VAR_9 = true;
goto set_attr;
}
case VAR_27:
VAR_12 = VAR_17;
}
fh_drop_write(VAR_1);
goto out;
}
VAR_13 = vfs_create(VAR_11, VAR_10, VAR_4->ia_mode, true);
if (VAR_13 < 0) {
fh_drop_write(VAR_1);
goto out_nfserr;
}
if (VAR_9)
*VAR_9 = true;
nfsd_check_ignore_resizing(VAR_4);
if (nfsd_create_is_exclusive(VAR_6)) {
VAR_4->ia_valid = VAR_28|VAR_29
| VAR_30|VAR_31;
VAR_4->ia_mtime.tv_sec = VAR_14;
VAR_4->ia_atime.tv_sec = VAR_15;
VAR_4->ia_mtime.tv_nsec = 0;
VAR_4->ia_atime.tv_nsec = 0;
}
set_attr:
VAR_12 = nfsd_create_setattr(VAR_0, VAR_5, VAR_4);
if (!VAR_12)
VAR_12 = nfserrno(commit_metadata(VAR_1));
if (!VAR_12)
VAR_12 = fh_update(VAR_5);
out:
fh_unlock(VAR_1);
if (VAR_10 && !IS_ERR(VAR_10))
dput(VAR_10);
fh_drop_write(VAR_1);
return VAR_12;
out_nfserr:
VAR_12 = nfserrno(VAR_13);
goto out;
}",torvalds/linux/22cf8419f1319ff87ec759d0ebdff4cbafaee832/vfs.c/vul/before/0.json,"__be32
do_nfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,
		char *fname, int flen, struct iattr *iap,
		struct svc_fh *resfhp, int createmode, u32 *verifier,
	        bool *truncp, bool *created)
{
	struct dentry	*dentry, *dchild = NULL;
	struct inode	*dirp;
	__be32		err;
	int		host_err;
	__u32		v_mtime=0, v_atime=0;

	err = nfserr_perm;
	if (!flen)
		goto out;
	err = nfserr_exist;
	if (isdotent(fname, flen))
		goto out;
	if (!(iap->ia_valid & ATTR_MODE))
		iap->ia_mode = 0;
	err = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);
	if (err)
		goto out;

	dentry = fhp->fh_dentry;
	dirp = d_inode(dentry);

	host_err = fh_want_write(fhp);
	if (host_err)
		goto out_nfserr;

	fh_lock_nested(fhp, I_MUTEX_PARENT);

	/*
	 * Compose the response file handle.
	 */
	dchild = lookup_one_len(fname, dentry, flen);
	host_err = PTR_ERR(dchild);
	if (IS_ERR(dchild))
		goto out_nfserr;

	/* If file doesn't exist, check for permissions to create one */
	if (d_really_is_negative(dchild)) {
		err = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);
		if (err)
			goto out;
	}

	err = fh_compose(resfhp, fhp->fh_export, dchild, fhp);
	if (err)
		goto out;

	if (nfsd_create_is_exclusive(createmode)) {
		/* solaris7 gets confused (bugid 4218508) if these have
		 * the high bit set, so just clear the high bits. If this is
		 * ever changed to use different attrs for storing the
		 * verifier, then do_open_lookup() will also need to be fixed
		 * accordingly.
		 */
		v_mtime = verifier[0]&0x7fffffff;
		v_atime = verifier[1]&0x7fffffff;
	}
	
	if (d_really_is_positive(dchild)) {
		err = 0;

		switch (createmode) {
		case NFS3_CREATE_UNCHECKED:
			if (! d_is_reg(dchild))
				goto out;
			else if (truncp) {
				/* in nfsv4, we need to treat this case a little
				 * differently.  we don't want to truncate the
				 * file now; this would be wrong if the OPEN
				 * fails for some other reason.  furthermore,
				 * if the size is nonzero, we should ignore it
				 * according to spec!
				 */
				*truncp = (iap->ia_valid & ATTR_SIZE) && !iap->ia_size;
			}
			else {
				iap->ia_valid &= ATTR_SIZE;
				goto set_attr;
			}
			break;
		case NFS3_CREATE_EXCLUSIVE:
			if (   d_inode(dchild)->i_mtime.tv_sec == v_mtime
			    && d_inode(dchild)->i_atime.tv_sec == v_atime
			    && d_inode(dchild)->i_size  == 0 ) {
				if (created)
					*created = true;
				break;
			}
			/* fall through */
		case NFS4_CREATE_EXCLUSIVE4_1:
			if (   d_inode(dchild)->i_mtime.tv_sec == v_mtime
			    && d_inode(dchild)->i_atime.tv_sec == v_atime
			    && d_inode(dchild)->i_size  == 0 ) {
				if (created)
					*created = true;
				goto set_attr;
			}
			/* fall through */
		case NFS3_CREATE_GUARDED:
			err = nfserr_exist;
		}
		fh_drop_write(fhp);
		goto out;
	}

	if (!IS_POSIXACL(dirp))
		iap->ia_mode &= ~current_umask();

	host_err = vfs_create(dirp, dchild, iap->ia_mode, true);
	if (host_err < 0) {
		fh_drop_write(fhp);
		goto out_nfserr;
	}
	if (created)
		*created = true;

	nfsd_check_ignore_resizing(iap);

	if (nfsd_create_is_exclusive(createmode)) {
		/* Cram the verifier into atime/mtime */
		iap->ia_valid = ATTR_MTIME|ATTR_ATIME
			| ATTR_MTIME_SET|ATTR_ATIME_SET;
		/* XXX someone who knows this better please fix it for nsec */ 
		iap->ia_mtime.tv_sec = v_mtime;
		iap->ia_atime.tv_sec = v_atime;
		iap->ia_mtime.tv_nsec = 0;
		iap->ia_atime.tv_nsec = 0;
	}

 set_attr:
	err = nfsd_create_setattr(rqstp, resfhp, iap);

	/*
	 * nfsd_create_setattr already committed the child
	 * (and possibly also the parent).
	 */
	if (!err)
		err = nfserrno(commit_metadata(fhp));

	/*
	 * Update the filehandle to get the new inode info.
	 */
	if (!err)
		err = fh_update(resfhp);

 out:
	fh_unlock(fhp);
	if (dchild && !IS_ERR(dchild))
		dput(dchild);
	fh_drop_write(fhp);
 	return err;
 
 out_nfserr:
	err = nfserrno(host_err);
	goto out;
}","__be32
do_nfsd_create(struct svc_rqst *VAR_0, struct svc_fh *VAR_1,
		char *VAR_2, int VAR_3, struct iattr *VAR_4,
		struct svc_fh *VAR_5, int VAR_6, u32 *VAR_7,
	        bool *VAR_8, bool *VAR_9)
{
	struct dentry	*dentry, *VAR_10 = NULL;
	struct inode	*VAR_11;
	__be32		VAR_12;
	int		VAR_13;
	__u32		VAR_14=0, VAR_15=0;

	VAR_12 = VAR_16;
	if (!VAR_3)
		goto out;
	VAR_12 = VAR_17;
	if (isdotent(VAR_2, VAR_3))
		goto out;
	if (!(VAR_4->ia_valid & VAR_18))
		VAR_4->ia_mode = 0;
	VAR_12 = fh_verify(VAR_0, VAR_1, VAR_19, VAR_20);
	if (VAR_12)
		goto out;

	dentry = VAR_1->fh_dentry;
	VAR_11 = d_inode(dentry);

	VAR_13 = fh_want_write(VAR_1);
	if (VAR_13)
		goto out_nfserr;

	fh_lock_nested(VAR_1, VAR_21);

	/* COMMENT_0 */
                                     
    
	VAR_10 = lookup_one_len(VAR_2, dentry, VAR_3);
	VAR_13 = PTR_ERR(VAR_10);
	if (IS_ERR(VAR_10))
		goto out_nfserr;

	/* COMMENT_3 */
	if (d_really_is_negative(VAR_10)) {
		VAR_12 = fh_verify(VAR_0, VAR_1, VAR_19, VAR_22);
		if (VAR_12)
			goto out;
	}

	VAR_12 = fh_compose(VAR_5, VAR_1->fh_export, VAR_10, VAR_1);
	if (VAR_12)
		goto out;

	if (nfsd_create_is_exclusive(VAR_6)) {
		/* COMMENT_4 */
                                                              
                                                        
                                                               
                 
     
		VAR_14 = VAR_7[0]&0x7fffffff;
		VAR_15 = VAR_7[1]&0x7fffffff;
	}
	
	if (d_really_is_positive(VAR_10)) {
		VAR_12 = 0;

		switch (VAR_6) {
		case VAR_23:
			if (! d_is_reg(VAR_10))
				goto out;
			else if (VAR_8) {
				/* COMMENT_10 */
                                                  
                                                
                                                 
                                                  
                         
       
				*VAR_8 = (VAR_4->ia_valid & VAR_24) && !VAR_4->ia_size;
			}
			else {
				VAR_4->ia_valid &= VAR_24;
				goto set_attr;
			}
			break;
		case VAR_25:
			if (   d_inode(VAR_10)->i_mtime.tv_sec == VAR_14
			    && d_inode(VAR_10)->i_atime.tv_sec == VAR_15
			    && d_inode(VAR_10)->i_size  == 0 ) {
				if (VAR_9)
					*VAR_9 = true;
				break;
			}
			/* COMMENT_17 */
		case VAR_26:
			if (   d_inode(VAR_10)->i_mtime.tv_sec == VAR_14
			    && d_inode(VAR_10)->i_atime.tv_sec == VAR_15
			    && d_inode(VAR_10)->i_size  == 0 ) {
				if (VAR_9)
					*VAR_9 = true;
				goto set_attr;
			}
			/* COMMENT_17 */
		case VAR_27:
			VAR_12 = VAR_17;
		}
		fh_drop_write(VAR_1);
		goto out;
	}

	if (!IS_POSIXACL(VAR_11))
		VAR_4->ia_mode &= ~current_umask();

	VAR_13 = vfs_create(VAR_11, VAR_10, VAR_4->ia_mode, true);
	if (VAR_13 < 0) {
		fh_drop_write(VAR_1);
		goto out_nfserr;
	}
	if (VAR_9)
		*VAR_9 = true;

	nfsd_check_ignore_resizing(VAR_4);

	if (nfsd_create_is_exclusive(VAR_6)) {
		/* COMMENT_18 */
		VAR_4->ia_valid = VAR_28|VAR_29
			| VAR_30|VAR_31;
		/* COMMENT_19 */ 
		VAR_4->ia_mtime.tv_sec = VAR_14;
		VAR_4->ia_atime.tv_sec = VAR_15;
		VAR_4->ia_mtime.tv_nsec = 0;
		VAR_4->ia_atime.tv_nsec = 0;
	}

 set_attr:
	VAR_12 = nfsd_create_setattr(VAR_0, VAR_5, VAR_4);

	/* COMMENT_20 */
                                                   
                                   
    
	if (!VAR_12)
		VAR_12 = nfserrno(commit_metadata(VAR_1));

	/* COMMENT_24 */
                                                    
    
	if (!VAR_12)
		VAR_12 = fh_update(VAR_5);

 out:
	fh_unlock(VAR_1);
	if (VAR_10 && !IS_ERR(VAR_10))
		dput(VAR_10);
	fh_drop_write(VAR_1);
 	return VAR_12;
 
 out_nfserr:
	VAR_12 = nfserrno(VAR_13);
	goto out;
}",torvalds/linux/22cf8419f1319ff87ec759d0ebdff4cbafaee832/vfs.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -108,6 +108,9 @@
 		goto out;
 	}
 
+	if (!IS_POSIXACL(dirp))
+		iap->ia_mode &= ~current_umask();
+
 	host_err = vfs_create(dirp, dchild, iap->ia_mode, true);
 	if (host_err < 0) {
 		fh_drop_write(fhp);","{'deleted_lines': [], 'added_lines': ['\tif (!IS_POSIXACL(dirp))', '\t\tiap->ia_mode &= ~current_umask();', '']}",True,"In the Linux kernel before 5.7.8, fs/nfsd/vfs.c (in the NFS server) can set incorrect permissions on new filesystem objects when the filesystem lacks ACL support, aka CID-22cf8419f131. This occurs because the current umask is not considered.",7.1,HIGH,2,test,,5
CVE-2020-24394,['CWE-732'],AV:L/AC:L/Au:N/C:P/I:P/A:N,0,torvalds/linux,"The server is failing to apply the umask when creating new objects on
filesystems without ACL support.

To reproduce this, you need to use NFSv4.2 and a client and server
recent enough to support umask, and you need to export a filesystem that
lacks ACL support (for example, ext4 with the ""noacl"" mount option).

Filesystems with ACL support are expected to take care of the umask
themselves (usually by calling posix_acl_create).

For filesystems without ACL support, this is up to the caller of
vfs_create(), vfs_mknod(), or vfs_mkdir().

Reported-by: Elliott Mitchell <ehem+debian@m5p.com>
Reported-by: Salvatore Bonaccorso <carnil@debian.org>
Tested-by: Salvatore Bonaccorso <carnil@debian.org>
Fixes: 47057abde515 (""nfsd: add support for the umask attribute"")
Cc: stable@vger.kernel.org
Signed-off-by: J. Bruce Fields <bfields@redhat.com>
",22cf8419f1319ff87ec759d0ebdff4cbafaee832,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=22cf8419f1319ff87ec759d0ebdff4cbafaee832,fs/nfsd/vfs.c,nfsd_create_locked,"__be32
nfsd_create_locked(struct svc_rqst *rqstp, struct svc_fh *fhp,
char *fname, int flen, struct iattr *iap,
int type, dev_t rdev, struct svc_fh *resfhp)
{
struct dentry*dentry, *dchild;
struct inode*dirp;
__be32err;
__be32err2;
inthost_err;
dentry = fhp->fh_dentry;
dirp = d_inode(dentry);
dchild = dget(resfhp->fh_dentry);
if (!fhp->fh_locked) {
WARN_ONCE(1, ""nfsd_create: parent %pd2 not locked!\n"",
dentry);
err = nfserr_io;
goto out;
}
err = nfsd_permission(rqstp, fhp->fh_export, dentry, NFSD_MAY_CREATE);
if (err)
goto out;
if (!(iap->ia_valid & ATTR_MODE))
iap->ia_mode = 0;
iap->ia_mode = (iap->ia_mode & S_IALLUGO) | type;
err = 0;
host_err = 0;
switch (type) {
case S_IFREG:
host_err = vfs_create(dirp, dchild, iap->ia_mode, true);
if (!host_err)
nfsd_check_ignore_resizing(iap);
break;
case S_IFDIR:
host_err = vfs_mkdir(dirp, dchild, iap->ia_mode);
if (!host_err && unlikely(d_unhashed(dchild))) {
struct dentry *d;
d = lookup_one_len(dchild->d_name.name,
dchild->d_parent,
dchild->d_name.len);
if (IS_ERR(d)) {
host_err = PTR_ERR(d);
break;
}
if (unlikely(d_is_negative(d))) {
dput(d);
err = nfserr_serverfault;
goto out;
}
dput(resfhp->fh_dentry);
resfhp->fh_dentry = dget(d);
err = fh_update(resfhp);
dput(dchild);
dchild = d;
if (err)
goto out;
}
break;
case S_IFCHR:
case S_IFBLK:
case S_IFIFO:
case S_IFSOCK:
host_err = vfs_mknod(dirp, dchild, iap->ia_mode, rdev);
break;
default:
printk(KERN_WARNING ""nfsd: bad file type %o in nfsd_create\n"",
type);
host_err = -EINVAL;
}
if (host_err < 0)
goto out_nfserr;
err = nfsd_create_setattr(rqstp, resfhp, iap);
err2 = nfserrno(commit_metadata(fhp));
if (err2)
err = err2;
if (!err)
err = fh_update(resfhp);
out:
dput(dchild);
return err;
out_nfserr:
err = nfserrno(host_err);
goto out;
}","__be32
nfsd_create_locked(struct svc_rqst *VAR_0, struct svc_fh *VAR_1,
char *VAR_2, int VAR_3, struct iattr *VAR_4,
int VAR_5, dev_t VAR_6, struct svc_fh *VAR_7)
{
struct dentry*dentry, *VAR_8;
struct inode*VAR_9;
__be32VAR_10;
__be32VAR_11;
intVAR_12;
dentry = VAR_1->fh_dentry;
VAR_9 = d_inode(dentry);
VAR_8 = dget(VAR_7->fh_dentry);
if (!VAR_1->fh_locked) {
WARN_ONCE(1, ""nfsd_create: parent %pd2 not locked!\n"",
dentry);
VAR_10 = VAR_13;
goto out;
}
VAR_10 = nfsd_permission(VAR_0, VAR_1->fh_export, dentry, VAR_14);
if (VAR_10)
goto out;
if (!(VAR_4->ia_valid & VAR_15))
VAR_4->ia_mode = 0;
VAR_4->ia_mode = (VAR_4->ia_mode & VAR_16) | VAR_5;
VAR_10 = 0;
VAR_12 = 0;
switch (VAR_5) {
case VAR_17:
VAR_12 = vfs_create(VAR_9, VAR_8, VAR_4->ia_mode, true);
if (!VAR_12)
nfsd_check_ignore_resizing(VAR_4);
break;
case VAR_18:
VAR_12 = vfs_mkdir(VAR_9, VAR_8, VAR_4->ia_mode);
if (!VAR_12 && unlikely(d_unhashed(VAR_8))) {
struct dentry *VAR_19;
VAR_19 = lookup_one_len(VAR_8->d_name.name,
VAR_8->d_parent,
VAR_8->d_name.len);
if (IS_ERR(VAR_19)) {
VAR_12 = PTR_ERR(VAR_19);
break;
}
if (unlikely(d_is_negative(VAR_19))) {
dput(VAR_19);
VAR_10 = VAR_20;
goto out;
}
dput(VAR_7->fh_dentry);
VAR_7->fh_dentry = dget(VAR_19);
VAR_10 = fh_update(VAR_7);
dput(VAR_8);
VAR_8 = VAR_19;
if (VAR_10)
goto out;
}
break;
case VAR_21:
case VAR_22:
case VAR_23:
case VAR_24:
VAR_12 = vfs_mknod(VAR_9, VAR_8, VAR_4->ia_mode, VAR_6);
break;
default:
printk(KERN_WARNING ""nfsd: bad file type %o in nfsd_create\n"",
VAR_5);
VAR_12 = -VAR_25;
}
if (VAR_12 < 0)
goto out_nfserr;
VAR_10 = nfsd_create_setattr(VAR_0, VAR_7, VAR_4);
VAR_11 = nfserrno(commit_metadata(VAR_1));
if (VAR_11)
VAR_10 = VAR_11;
if (!VAR_10)
VAR_10 = fh_update(VAR_7);
out:
dput(VAR_8);
return VAR_10;
out_nfserr:
VAR_10 = nfserrno(VAR_12);
goto out;
}",torvalds/linux/22cf8419f1319ff87ec759d0ebdff4cbafaee832/vfs.c/vul/before/1.json,"__be32
nfsd_create_locked(struct svc_rqst *rqstp, struct svc_fh *fhp,
		char *fname, int flen, struct iattr *iap,
		int type, dev_t rdev, struct svc_fh *resfhp)
{
	struct dentry	*dentry, *dchild;
	struct inode	*dirp;
	__be32		err;
	__be32		err2;
	int		host_err;

	dentry = fhp->fh_dentry;
	dirp = d_inode(dentry);

	dchild = dget(resfhp->fh_dentry);
	if (!fhp->fh_locked) {
		WARN_ONCE(1, ""nfsd_create: parent %pd2 not locked!\n"",
				dentry);
		err = nfserr_io;
		goto out;
	}

	err = nfsd_permission(rqstp, fhp->fh_export, dentry, NFSD_MAY_CREATE);
	if (err)
		goto out;

	if (!(iap->ia_valid & ATTR_MODE))
		iap->ia_mode = 0;
	iap->ia_mode = (iap->ia_mode & S_IALLUGO) | type;

	if (!IS_POSIXACL(dirp))
		iap->ia_mode &= ~current_umask();

	err = 0;
	host_err = 0;
	switch (type) {
	case S_IFREG:
		host_err = vfs_create(dirp, dchild, iap->ia_mode, true);
		if (!host_err)
			nfsd_check_ignore_resizing(iap);
		break;
	case S_IFDIR:
		host_err = vfs_mkdir(dirp, dchild, iap->ia_mode);
		if (!host_err && unlikely(d_unhashed(dchild))) {
			struct dentry *d;
			d = lookup_one_len(dchild->d_name.name,
					   dchild->d_parent,
					   dchild->d_name.len);
			if (IS_ERR(d)) {
				host_err = PTR_ERR(d);
				break;
			}
			if (unlikely(d_is_negative(d))) {
				dput(d);
				err = nfserr_serverfault;
				goto out;
			}
			dput(resfhp->fh_dentry);
			resfhp->fh_dentry = dget(d);
			err = fh_update(resfhp);
			dput(dchild);
			dchild = d;
			if (err)
				goto out;
		}
		break;
	case S_IFCHR:
	case S_IFBLK:
	case S_IFIFO:
	case S_IFSOCK:
		host_err = vfs_mknod(dirp, dchild, iap->ia_mode, rdev);
		break;
	default:
		printk(KERN_WARNING ""nfsd: bad file type %o in nfsd_create\n"",
		       type);
		host_err = -EINVAL;
	}
	if (host_err < 0)
		goto out_nfserr;

	err = nfsd_create_setattr(rqstp, resfhp, iap);

	/*
	 * nfsd_create_setattr already committed the child.  Transactional
	 * filesystems had a chance to commit changes for both parent and
	 * child simultaneously making the following commit_metadata a
	 * noop.
	 */
	err2 = nfserrno(commit_metadata(fhp));
	if (err2)
		err = err2;
	/*
	 * Update the file handle to get the new inode info.
	 */
	if (!err)
		err = fh_update(resfhp);
out:
	dput(dchild);
	return err;

out_nfserr:
	err = nfserrno(host_err);
	goto out;
}","__be32
nfsd_create_locked(struct svc_rqst *VAR_0, struct svc_fh *VAR_1,
		char *VAR_2, int VAR_3, struct iattr *VAR_4,
		int VAR_5, dev_t VAR_6, struct svc_fh *VAR_7)
{
	struct dentry	*dentry, *VAR_8;
	struct inode	*VAR_9;
	__be32		VAR_10;
	__be32		VAR_11;
	int		VAR_12;

	dentry = VAR_1->fh_dentry;
	VAR_9 = d_inode(dentry);

	VAR_8 = dget(VAR_7->fh_dentry);
	if (!VAR_1->fh_locked) {
		WARN_ONCE(1, ""nfsd_create: parent %pd2 not locked!\n"",
				dentry);
		VAR_10 = VAR_13;
		goto out;
	}

	VAR_10 = nfsd_permission(VAR_0, VAR_1->fh_export, dentry, VAR_14);
	if (VAR_10)
		goto out;

	if (!(VAR_4->ia_valid & VAR_15))
		VAR_4->ia_mode = 0;
	VAR_4->ia_mode = (VAR_4->ia_mode & VAR_16) | VAR_5;

	if (!IS_POSIXACL(VAR_9))
		VAR_4->ia_mode &= ~current_umask();

	VAR_10 = 0;
	VAR_12 = 0;
	switch (VAR_5) {
	case VAR_17:
		VAR_12 = vfs_create(VAR_9, VAR_8, VAR_4->ia_mode, true);
		if (!VAR_12)
			nfsd_check_ignore_resizing(VAR_4);
		break;
	case VAR_18:
		VAR_12 = vfs_mkdir(VAR_9, VAR_8, VAR_4->ia_mode);
		if (!VAR_12 && unlikely(d_unhashed(VAR_8))) {
			struct dentry *VAR_19;
			VAR_19 = lookup_one_len(VAR_8->d_name.name,
					   VAR_8->d_parent,
					   VAR_8->d_name.len);
			if (IS_ERR(VAR_19)) {
				VAR_12 = PTR_ERR(VAR_19);
				break;
			}
			if (unlikely(d_is_negative(VAR_19))) {
				dput(VAR_19);
				VAR_10 = VAR_20;
				goto out;
			}
			dput(VAR_7->fh_dentry);
			VAR_7->fh_dentry = dget(VAR_19);
			VAR_10 = fh_update(VAR_7);
			dput(VAR_8);
			VAR_8 = VAR_19;
			if (VAR_10)
				goto out;
		}
		break;
	case VAR_21:
	case VAR_22:
	case VAR_23:
	case VAR_24:
		VAR_12 = vfs_mknod(VAR_9, VAR_8, VAR_4->ia_mode, VAR_6);
		break;
	default:
		printk(KERN_WARNING ""nfsd: bad file type %o in nfsd_create\n"",
		       VAR_5);
		VAR_12 = -VAR_25;
	}
	if (VAR_12 < 0)
		goto out_nfserr;

	VAR_10 = nfsd_create_setattr(VAR_0, VAR_7, VAR_4);

	/* COMMENT_0 */
                                                                   
                                                                  
                                                               
         
    
	VAR_11 = nfserrno(commit_metadata(VAR_1));
	if (VAR_11)
		VAR_10 = VAR_11;
	/* COMMENT_6 */
                                                     
    
	if (!VAR_10)
		VAR_10 = fh_update(VAR_7);
out:
	dput(VAR_8);
	return VAR_10;

out_nfserr:
	VAR_10 = nfserrno(VAR_12);
	goto out;
}",torvalds/linux/22cf8419f1319ff87ec759d0ebdff4cbafaee832/vfs.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -27,6 +27,9 @@
 	if (!(iap->ia_valid & ATTR_MODE))
 		iap->ia_mode = 0;
 	iap->ia_mode = (iap->ia_mode & S_IALLUGO) | type;
+
+	if (!IS_POSIXACL(dirp))
+		iap->ia_mode &= ~current_umask();
 
 	err = 0;
 	host_err = 0;","{'deleted_lines': [], 'added_lines': ['', '\tif (!IS_POSIXACL(dirp))', '\t\tiap->ia_mode &= ~current_umask();']}",True,"In the Linux kernel before 5.7.8, fs/nfsd/vfs.c (in the NFS server) can set incorrect permissions on new filesystem objects when the filesystem lacks ACL support, aka CID-22cf8419f131. This occurs because the current umask is not considered.",7.1,HIGH,2,test,,5
CVE-2020-10773,['CWE-626'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,torvalds/linux,"The problem is that we were putting the NUL terminator too far:

	buf[sizeof(buf) - 1] = '\0';

If the user input isn't NUL terminated and they haven't initialized the
whole buffer then it leads to an info leak.  The NUL terminator should
be:

	buf[len - 1] = '\0';

Signed-off-by: Yihui Zeng <yzeng56@asu.edu>
Cc: stable@vger.kernel.org
Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
[heiko.carstens@de.ibm.com: keep semantics of how *lenp and *ppos are handled]
Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
",b8e51a6a9db94bc1fb18ae831b3dab106b5a4b5f,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=b8e51a6a9db94bc1fb18ae831b3dab106b5a4b5f,arch/s390/mm/cmm.c,cmm_timeout_handler,"static int cmm_timeout_handler(struct ctl_table *ctl, int write,
void __user *buffer, size_t *lenp, loff_t *ppos)
{
char buf[64], *p;
long nr, seconds;
unsigned int len;
if (!*lenp || (*ppos && !write)) {
*lenp = 0;
return 0;
}
if (write) {
len = *lenp;
if (copy_from_user(buf, buffer,
len > sizeof(buf) ? sizeof(buf) : len))
return -EFAULT;
buf[sizeof(buf) - 1] = '\0';
cmm_skip_blanks(buf, &p);
nr = simple_strtoul(p, &p, 0);
cmm_skip_blanks(p, &p);
seconds = simple_strtoul(p, &p, 0);
cmm_set_timeout(nr, seconds);
} else {
len = sprintf(buf, ""%ld %ld\n"",
cmm_timeout_pages, cmm_timeout_seconds);
if (len > *lenp)
len = *lenp;
if (copy_to_user(buffer, buf, len))
return -EFAULT;
}
*lenp = len;
*ppos += len;
return 0;
}","static int cmm_timeout_handler(struct ctl_table *VAR_0, int VAR_1,
void __user *VAR_2, size_t *VAR_3, loff_t *VAR_4)
{
char VAR_5[64], *VAR_6;
long VAR_7, VAR_8;
unsigned int VAR_9;
if (!*VAR_3 || (*VAR_4 && !VAR_1)) {
*VAR_3 = 0;
return 0;
}
if (VAR_1) {
VAR_9 = *VAR_3;
if (copy_from_user(VAR_5, VAR_2,
VAR_9 > sizeof(VAR_5) ? sizeof(VAR_5) : VAR_9))
return -VAR_10;
VAR_5[sizeof(VAR_5) - 1] = '\0';
cmm_skip_blanks(VAR_5, &VAR_6);
VAR_7 = simple_strtoul(VAR_6, &VAR_6, 0);
cmm_skip_blanks(VAR_6, &VAR_6);
VAR_8 = simple_strtoul(VAR_6, &VAR_6, 0);
cmm_set_timeout(VAR_7, VAR_8);
} else {
VAR_9 = sprintf(VAR_5, ""%ld %ld\n"",
VAR_11, VAR_12);
if (VAR_9 > *VAR_3)
VAR_9 = *VAR_3;
if (copy_to_user(VAR_2, VAR_5, VAR_9))
return -VAR_10;
}
*VAR_3 = VAR_9;
*VAR_4 += VAR_9;
return 0;
}",,"static int cmm_timeout_handler(struct ctl_table *ctl, int write,
			       void __user *buffer, size_t *lenp, loff_t *ppos)
{
	char buf[64], *p;
	long nr, seconds;
	unsigned int len;

	if (!*lenp || (*ppos && !write)) {
		*lenp = 0;
		return 0;
	}

	if (write) {
		len = min(*lenp, sizeof(buf));
		if (copy_from_user(buf, buffer, len))
			return -EFAULT;
		buf[len - 1] = '\0';
		cmm_skip_blanks(buf, &p);
		nr = simple_strtoul(p, &p, 0);
		cmm_skip_blanks(p, &p);
		seconds = simple_strtoul(p, &p, 0);
		cmm_set_timeout(nr, seconds);
		*ppos += *lenp;
	} else {
		len = sprintf(buf, ""%ld %ld\n"",
			      cmm_timeout_pages, cmm_timeout_seconds);
		if (len > *lenp)
			len = *lenp;
		if (copy_to_user(buffer, buf, len))
			return -EFAULT;
		*lenp = len;
		*ppos += len;
	}
	return 0;
}","static int cmm_timeout_handler(struct ctl_table *VAR_0, int VAR_1,
			       void __user *VAR_2, size_t *VAR_3, loff_t *VAR_4)
{
	char VAR_5[64], *VAR_6;
	long VAR_7, VAR_8;
	unsigned int VAR_9;

	if (!*VAR_3 || (*VAR_4 && !VAR_1)) {
		*VAR_3 = 0;
		return 0;
	}

	if (VAR_1) {
		VAR_9 = min(*VAR_3, sizeof(VAR_5));
		if (copy_from_user(VAR_5, VAR_2, VAR_9))
			return -VAR_10;
		VAR_5[VAR_9 - 1] = '\0';
		cmm_skip_blanks(VAR_5, &VAR_6);
		VAR_7 = simple_strtoul(VAR_6, &VAR_6, 0);
		cmm_skip_blanks(VAR_6, &VAR_6);
		VAR_8 = simple_strtoul(VAR_6, &VAR_6, 0);
		cmm_set_timeout(VAR_7, VAR_8);
		*VAR_4 += *VAR_3;
	} else {
		VAR_9 = sprintf(VAR_5, ""%ld %ld\n"",
			      VAR_11, VAR_12);
		if (VAR_9 > *VAR_3)
			VAR_9 = *VAR_3;
		if (copy_to_user(VAR_2, VAR_5, VAR_9))
			return -VAR_10;
		*VAR_3 = VAR_9;
		*VAR_4 += VAR_9;
	}
	return 0;
}",,"--- func_before
+++ func_after
@@ -11,16 +11,16 @@
 	}
 
 	if (write) {
-		len = *lenp;
-		if (copy_from_user(buf, buffer,
-				   len > sizeof(buf) ? sizeof(buf) : len))
+		len = min(*lenp, sizeof(buf));
+		if (copy_from_user(buf, buffer, len))
 			return -EFAULT;
-		buf[sizeof(buf) - 1] = '\0';
+		buf[len - 1] = '\0';
 		cmm_skip_blanks(buf, &p);
 		nr = simple_strtoul(p, &p, 0);
 		cmm_skip_blanks(p, &p);
 		seconds = simple_strtoul(p, &p, 0);
 		cmm_set_timeout(nr, seconds);
+		*ppos += *lenp;
 	} else {
 		len = sprintf(buf, ""%ld %ld\n"",
 			      cmm_timeout_pages, cmm_timeout_seconds);
@@ -28,8 +28,8 @@
 			len = *lenp;
 		if (copy_to_user(buffer, buf, len))
 			return -EFAULT;
+		*lenp = len;
+		*ppos += len;
 	}
-	*lenp = len;
-	*ppos += len;
 	return 0;
 }","{'deleted_lines': ['\t\tlen = *lenp;', '\t\tif (copy_from_user(buf, buffer,', '\t\t\t\t   len > sizeof(buf) ? sizeof(buf) : len))', ""\t\tbuf[sizeof(buf) - 1] = '\\0';"", '\t*lenp = len;', '\t*ppos += len;'], 'added_lines': ['\t\tlen = min(*lenp, sizeof(buf));', '\t\tif (copy_from_user(buf, buffer, len))', ""\t\tbuf[len - 1] = '\\0';"", '\t\t*ppos += *lenp;', '\t\t*lenp = len;', '\t\t*ppos += len;']}",True,"A stack information leak flaw was found in s390/s390x in the Linux kernels memory manager functionality, where it incorrectly writes to the /proc/sys/vm/cmm_timeout file. This flaw allows a local user to see the kernel data.",4.4,MEDIUM,1,test,,5
CVE-2020-14386,['CWE-787'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"Using tp_reserve to calculate netoff can overflow as
tp_reserve is unsigned int and netoff is unsigned short.

This may lead to macoff receving a smaller value then
sizeof(struct virtio_net_hdr), and if po->has_vnet_hdr
is set, an out-of-bounds write will occur when
calling virtio_net_hdr_from_skb.

The bug is fixed by converting netoff to unsigned int
and checking if it exceeds USHRT_MAX.

This addresses CVE-2020-14386

Fixes: 8913336a7e8d (""packet: add PACKET_RESERVE sockopt"")
Signed-off-by: Or Cohen <orcohen@paloaltonetworks.com>
Signed-off-by: Eric Dumazet <edumazet@google.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
",acf69c946233259ab4d64f8869d4037a198c7f06,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=acf69c946233259ab4d64f8869d4037a198c7f06,net/packet/af_packet.c,tpacket_rcv,"static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,
struct packet_type *pt, struct net_device *orig_dev)
{
struct sock *sk;
struct packet_sock *po;
struct sockaddr_ll *sll;
union tpacket_uhdr h;
u8 *skb_head = skb->data;
int skb_len = skb->len;
unsigned int snaplen, res;
unsigned long status = TP_STATUS_USER;
unsigned short macoff, netoff, hdrlen;
struct sk_buff *copy_skb = NULL;
struct timespec64 ts;
__u32 ts_status;
bool is_drop_n_account = false;
unsigned int slot_id = 0;
bool do_vnet = false;
BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32);
BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48);
if (skb->pkt_type == PACKET_LOOPBACK)
goto drop;
sk = pt->af_packet_priv;
po = pkt_sk(sk);
if (!net_eq(dev_net(dev), sock_net(sk)))
goto drop;
if (dev->header_ops) {
if (sk->sk_type != SOCK_DGRAM)
skb_push(skb, skb->data - skb_mac_header(skb));
else if (skb->pkt_type == PACKET_OUTGOING) {
skb_pull(skb, skb_network_offset(skb));
}
}
snaplen = skb->len;
res = run_filter(skb, sk, snaplen);
if (!res)
goto drop_n_restore;
if (__packet_rcv_has_room(po, skb) == ROOM_NONE) {
atomic_inc(&po->tp_drops);
goto drop_n_restore;
}
if (skb->ip_summed == CHECKSUM_PARTIAL)
status |= TP_STATUS_CSUMNOTREADY;
else if (skb->pkt_type != PACKET_OUTGOING &&
(skb->ip_summed == CHECKSUM_COMPLETE ||
skb_csum_unnecessary(skb)))
status |= TP_STATUS_CSUM_VALID;
if (snaplen > res)
snaplen = res;
if (sk->sk_type == SOCK_DGRAM) {
macoff = netoff = TPACKET_ALIGN(po->tp_hdrlen) + 16 +
po->tp_reserve;
} else {
unsigned int maclen = skb_network_offset(skb);
netoff = TPACKET_ALIGN(po->tp_hdrlen +
(maclen < 16 ? 16 : maclen)) +
po->tp_reserve;
if (po->has_vnet_hdr) {
netoff += sizeof(struct virtio_net_hdr);
do_vnet = true;
}
macoff = netoff - maclen;
}
if (po->tp_version <= TPACKET_V2) {
if (macoff + snaplen > po->rx_ring.frame_size) {
if (po->copy_thresh &&
atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf) {
if (skb_shared(skb)) {
copy_skb = skb_clone(skb, GFP_ATOMIC);
} else {
copy_skb = skb_get(skb);
skb_head = skb->data;
}
if (copy_skb)
skb_set_owner_r(copy_skb, sk);
}
snaplen = po->rx_ring.frame_size - macoff;
if ((int)snaplen < 0) {
snaplen = 0;
do_vnet = false;
}
}
} else if (unlikely(macoff + snaplen >
GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len)) {
u32 nval;
nval = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len - macoff;
pr_err_once(""tpacket_rcv: packet too big, clamped from %u to %u. macoff=%u\n"",
snaplen, nval, macoff);
snaplen = nval;
if (unlikely((int)snaplen < 0)) {
snaplen = 0;
macoff = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len;
do_vnet = false;
}
}
spin_lock(&sk->sk_receive_queue.lock);
h.raw = packet_current_rx_frame(po, skb,
TP_STATUS_KERNEL, (macoff+snaplen));
if (!h.raw)
goto drop_n_account;
if (po->tp_version <= TPACKET_V2) {
slot_id = po->rx_ring.head;
if (test_bit(slot_id, po->rx_ring.rx_owner_map))
goto drop_n_account;
__set_bit(slot_id, po->rx_ring.rx_owner_map);
}
if (do_vnet &&
virtio_net_hdr_from_skb(skb, h.raw + macoff -
sizeof(struct virtio_net_hdr),
vio_le(), true, 0)) {
if (po->tp_version == TPACKET_V3)
prb_clear_blk_fill_status(&po->rx_ring);
goto drop_n_account;
}
if (po->tp_version <= TPACKET_V2) {
packet_increment_rx_head(po, &po->rx_ring);
if (atomic_read(&po->tp_drops))
status |= TP_STATUS_LOSING;
}
po->stats.stats1.tp_packets++;
if (copy_skb) {
status |= TP_STATUS_COPY;
__skb_queue_tail(&sk->sk_receive_queue, copy_skb);
}
spin_unlock(&sk->sk_receive_queue.lock);
skb_copy_bits(skb, 0, h.raw + macoff, snaplen);
if (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))
ktime_get_real_ts64(&ts);
status |= ts_status;
switch (po->tp_version) {
case TPACKET_V1:
h.h1->tp_len = skb->len;
h.h1->tp_snaplen = snaplen;
h.h1->tp_mac = macoff;
h.h1->tp_net = netoff;
h.h1->tp_sec = ts.tv_sec;
h.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;
hdrlen = sizeof(*h.h1);
break;
case TPACKET_V2:
h.h2->tp_len = skb->len;
h.h2->tp_snaplen = snaplen;
h.h2->tp_mac = macoff;
h.h2->tp_net = netoff;
h.h2->tp_sec = ts.tv_sec;
h.h2->tp_nsec = ts.tv_nsec;
if (skb_vlan_tag_present(skb)) {
h.h2->tp_vlan_tci = skb_vlan_tag_get(skb);
h.h2->tp_vlan_tpid = ntohs(skb->vlan_proto);
status |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID;
} else {
h.h2->tp_vlan_tci = 0;
h.h2->tp_vlan_tpid = 0;
}
memset(h.h2->tp_padding, 0, sizeof(h.h2->tp_padding));
hdrlen = sizeof(*h.h2);
break;
case TPACKET_V3:
h.h3->tp_status |= status;
h.h3->tp_len = skb->len;
h.h3->tp_snaplen = snaplen;
h.h3->tp_mac = macoff;
h.h3->tp_net = netoff;
h.h3->tp_sec  = ts.tv_sec;
h.h3->tp_nsec = ts.tv_nsec;
memset(h.h3->tp_padding, 0, sizeof(h.h3->tp_padding));
hdrlen = sizeof(*h.h3);
break;
default:
BUG();
}
sll = h.raw + TPACKET_ALIGN(hdrlen);
sll->sll_halen = dev_parse_header(skb, sll->sll_addr);
sll->sll_family = AF_PACKET;
sll->sll_hatype = dev->type;
sll->sll_protocol = skb->protocol;
sll->sll_pkttype = skb->pkt_type;
if (unlikely(po->origdev))
sll->sll_ifindex = orig_dev->ifindex;
else
sll->sll_ifindex = dev->ifindex;
smp_mb();
#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1
if (po->tp_version <= TPACKET_V2) {
u8 *start, *end;
end = (u8 *) PAGE_ALIGN((unsigned long) h.raw +
macoff + snaplen);
for (start = h.raw; start < end; start += PAGE_SIZE)
flush_dcache_page(pgv_to_page(start));
}
smp_wmb();
#endif
if (po->tp_version <= TPACKET_V2) {
spin_lock(&sk->sk_receive_queue.lock);
__packet_set_status(po, h.raw, status);
__clear_bit(slot_id, po->rx_ring.rx_owner_map);
spin_unlock(&sk->sk_receive_queue.lock);
sk->sk_data_ready(sk);
} else if (po->tp_version == TPACKET_V3) {
prb_clear_blk_fill_status(&po->rx_ring);
}
drop_n_restore:
if (skb_head != skb->data && skb_shared(skb)) {
skb->data = skb_head;
skb->len = skb_len;
}
drop:
if (!is_drop_n_account)
consume_skb(skb);
else
kfree_skb(skb);
return 0;
drop_n_account:
spin_unlock(&sk->sk_receive_queue.lock);
atomic_inc(&po->tp_drops);
is_drop_n_account = true;
sk->sk_data_ready(sk);
kfree_skb(copy_skb);
goto drop_n_restore;
}","static int tpacket_rcv(struct sk_buff *VAR_0, struct net_device *VAR_1,
struct packet_type *VAR_2, struct net_device *VAR_3)
{
struct sock *VAR_4;
struct packet_sock *VAR_5;
struct sockaddr_ll *VAR_6;
union tpacket_uhdr VAR_7;
u8 *VAR_8 = VAR_0->data;
int VAR_9 = VAR_0->len;
unsigned int VAR_10, VAR_11;
unsigned long VAR_12 = VAR_13;
unsigned short VAR_14, VAR_15, VAR_16;
struct sk_buff *VAR_17 = NULL;
struct timespec64 VAR_18;
__u32 VAR_19;
bool VAR_20 = false;
unsigned int VAR_21 = 0;
bool VAR_22 = false;
BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*VAR_7.h2)) != 32);
BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*VAR_7.h3)) != 48);
if (VAR_0->pkt_type == VAR_23)
goto drop;
VAR_4 = VAR_2->af_packet_priv;
VAR_5 = pkt_sk(VAR_4);
if (!net_eq(dev_net(VAR_1), sock_net(VAR_4)))
goto drop;
if (VAR_1->header_ops) {
if (VAR_4->sk_type != VAR_24)
skb_push(VAR_0, VAR_0->data - skb_mac_header(VAR_0));
else if (VAR_0->pkt_type == VAR_25) {
skb_pull(VAR_0, skb_network_offset(VAR_0));
}
}
VAR_10 = VAR_0->len;
VAR_11 = run_filter(VAR_0, VAR_4, VAR_10);
if (!VAR_11)
goto drop_n_restore;
if (__packet_rcv_has_room(VAR_5, VAR_0) == VAR_26) {
atomic_inc(&VAR_5->tp_drops);
goto drop_n_restore;
}
if (VAR_0->ip_summed == VAR_27)
VAR_12 |= VAR_28;
else if (VAR_0->pkt_type != VAR_25 &&
(VAR_0->ip_summed == VAR_29 ||
skb_csum_unnecessary(VAR_0)))
VAR_12 |= VAR_30;
if (VAR_10 > VAR_11)
VAR_10 = VAR_11;
if (VAR_4->sk_type == VAR_24) {
VAR_14 = VAR_15 = TPACKET_ALIGN(VAR_5->tp_hdrlen) + 16 +
VAR_5->tp_reserve;
} else {
unsigned int VAR_31 = skb_network_offset(VAR_0);
VAR_15 = TPACKET_ALIGN(VAR_5->tp_hdrlen +
(VAR_31 < 16 ? 16 : VAR_31)) +
VAR_5->tp_reserve;
if (VAR_5->has_vnet_hdr) {
VAR_15 += sizeof(struct virtio_net_hdr);
VAR_22 = true;
}
VAR_14 = VAR_15 - VAR_31;
}
if (VAR_5->tp_version <= VAR_32) {
if (VAR_14 + VAR_10 > VAR_5->rx_ring.frame_size) {
if (VAR_5->copy_thresh &&
atomic_read(&VAR_4->sk_rmem_alloc) < VAR_4->sk_rcvbuf) {
if (skb_shared(VAR_0)) {
VAR_17 = skb_clone(VAR_0, VAR_33);
} else {
VAR_17 = skb_get(VAR_0);
VAR_8 = VAR_0->data;
}
if (VAR_17)
skb_set_owner_r(VAR_17, VAR_4);
}
VAR_10 = VAR_5->rx_ring.frame_size - VAR_14;
if ((int)VAR_10 < 0) {
VAR_10 = 0;
VAR_22 = false;
}
}
} else if (unlikely(VAR_14 + VAR_10 >
GET_PBDQC_FROM_RB(&VAR_5->rx_ring)->max_frame_len)) {
u32 VAR_34;
VAR_34 = GET_PBDQC_FROM_RB(&VAR_5->rx_ring)->max_frame_len - VAR_14;
pr_err_once(""tpacket_rcv: packet too big, clamped from %u to %u. macoff=%u\n"",
VAR_10, VAR_34, VAR_14);
VAR_10 = VAR_34;
if (unlikely((int)VAR_10 < 0)) {
VAR_10 = 0;
VAR_14 = GET_PBDQC_FROM_RB(&VAR_5->rx_ring)->max_frame_len;
VAR_22 = false;
}
}
spin_lock(&VAR_4->sk_receive_queue.lock);
VAR_7.raw = packet_current_rx_frame(VAR_5, VAR_0,
VAR_35, (VAR_14+VAR_10));
if (!VAR_7.raw)
goto drop_n_account;
if (VAR_5->tp_version <= VAR_32) {
VAR_21 = VAR_5->rx_ring.head;
if (test_bit(VAR_21, VAR_5->rx_ring.rx_owner_map))
goto drop_n_account;
__set_bit(VAR_21, VAR_5->rx_ring.rx_owner_map);
}
if (VAR_22 &&
virtio_net_hdr_from_skb(VAR_0, VAR_7.raw + VAR_14 -
sizeof(struct virtio_net_hdr),
vio_le(), true, 0)) {
if (VAR_5->tp_version == VAR_36)
prb_clear_blk_fill_status(&VAR_5->rx_ring);
goto drop_n_account;
}
if (VAR_5->tp_version <= VAR_32) {
packet_increment_rx_head(VAR_5, &VAR_5->rx_ring);
if (atomic_read(&VAR_5->tp_drops))
VAR_12 |= VAR_37;
}
VAR_5->stats.stats1.tp_packets++;
if (VAR_17) {
VAR_12 |= VAR_38;
__skb_queue_tail(&VAR_4->sk_receive_queue, VAR_17);
}
spin_unlock(&VAR_4->sk_receive_queue.lock);
skb_copy_bits(VAR_0, 0, VAR_7.raw + VAR_14, VAR_10);
if (!(VAR_19 = tpacket_get_timestamp(VAR_0, &VAR_18, VAR_5->tp_tstamp)))
ktime_get_real_ts64(&VAR_18);
VAR_12 |= VAR_19;
switch (VAR_5->tp_version) {
case VAR_39:
VAR_7.h1->tp_len = VAR_0->len;
VAR_7.h1->tp_snaplen = VAR_10;
VAR_7.h1->tp_mac = VAR_14;
VAR_7.h1->tp_net = VAR_15;
VAR_7.h1->tp_sec = VAR_18.tv_sec;
VAR_7.h1->tp_usec = VAR_18.tv_nsec / VAR_40;
VAR_16 = sizeof(*VAR_7.h1);
break;
case VAR_32:
VAR_7.h2->tp_len = VAR_0->len;
VAR_7.h2->tp_snaplen = VAR_10;
VAR_7.h2->tp_mac = VAR_14;
VAR_7.h2->tp_net = VAR_15;
VAR_7.h2->tp_sec = VAR_18.tv_sec;
VAR_7.h2->tp_nsec = VAR_18.tv_nsec;
if (skb_vlan_tag_present(VAR_0)) {
VAR_7.h2->tp_vlan_tci = skb_vlan_tag_get(VAR_0);
VAR_7.h2->tp_vlan_tpid = ntohs(VAR_0->vlan_proto);
VAR_12 |= VAR_41 | VAR_42;
} else {
VAR_7.h2->tp_vlan_tci = 0;
VAR_7.h2->tp_vlan_tpid = 0;
}
memset(VAR_7.h2->tp_padding, 0, sizeof(VAR_7.h2->tp_padding));
VAR_16 = sizeof(*VAR_7.h2);
break;
case VAR_36:
VAR_7.h3->tp_status |= VAR_12;
VAR_7.h3->tp_len = VAR_0->len;
VAR_7.h3->tp_snaplen = VAR_10;
VAR_7.h3->tp_mac = VAR_14;
VAR_7.h3->tp_net = VAR_15;
VAR_7.h3->tp_sec  = VAR_18.tv_sec;
VAR_7.h3->tp_nsec = VAR_18.tv_nsec;
memset(VAR_7.h3->tp_padding, 0, sizeof(VAR_7.h3->tp_padding));
VAR_16 = sizeof(*VAR_7.h3);
break;
default:
BUG();
}
VAR_6 = VAR_7.raw + TPACKET_ALIGN(VAR_16);
VAR_6->sll_halen = dev_parse_header(VAR_0, VAR_6->sll_addr);
VAR_6->sll_family = VAR_43;
VAR_6->sll_hatype = VAR_1->type;
VAR_6->sll_protocol = VAR_0->protocol;
VAR_6->sll_pkttype = VAR_0->pkt_type;
if (unlikely(VAR_5->origdev))
VAR_6->sll_ifindex = VAR_3->ifindex;
else
VAR_6->sll_ifindex = VAR_1->ifindex;
smp_mb();
#if VAR_44 == 1
if (VAR_5->tp_version <= VAR_32) {
u8 *VAR_45, *VAR_46;
VAR_46 = (u8 *) PAGE_ALIGN((unsigned long) VAR_7.raw +
VAR_14 + VAR_10);
for (VAR_45 = VAR_7.raw; VAR_45 < VAR_46; VAR_45 += VAR_47)
flush_dcache_page(pgv_to_page(VAR_45));
}
smp_wmb();
#endif
if (VAR_5->tp_version <= VAR_32) {
spin_lock(&VAR_4->sk_receive_queue.lock);
__packet_set_status(VAR_5, VAR_7.raw, VAR_12);
__clear_bit(VAR_21, VAR_5->rx_ring.rx_owner_map);
spin_unlock(&VAR_4->sk_receive_queue.lock);
VAR_4->sk_data_ready(VAR_4);
} else if (VAR_5->tp_version == VAR_36) {
prb_clear_blk_fill_status(&VAR_5->rx_ring);
}
drop_n_restore:
if (VAR_8 != VAR_0->data && skb_shared(VAR_0)) {
VAR_0->data = VAR_8;
VAR_0->len = VAR_9;
}
drop:
if (!VAR_20)
consume_skb(VAR_0);
else
kfree_skb(VAR_0);
return 0;
drop_n_account:
spin_unlock(&VAR_4->sk_receive_queue.lock);
atomic_inc(&VAR_5->tp_drops);
VAR_20 = true;
VAR_4->sk_data_ready(VAR_4);
kfree_skb(VAR_17);
goto drop_n_restore;
}",torvalds/linux/acf69c946233259ab4d64f8869d4037a198c7f06/af_packet.c/vul/before/0.json,"static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,
		       struct packet_type *pt, struct net_device *orig_dev)
{
	struct sock *sk;
	struct packet_sock *po;
	struct sockaddr_ll *sll;
	union tpacket_uhdr h;
	u8 *skb_head = skb->data;
	int skb_len = skb->len;
	unsigned int snaplen, res;
	unsigned long status = TP_STATUS_USER;
	unsigned short macoff, hdrlen;
	unsigned int netoff;
	struct sk_buff *copy_skb = NULL;
	struct timespec64 ts;
	__u32 ts_status;
	bool is_drop_n_account = false;
	unsigned int slot_id = 0;
	bool do_vnet = false;

	/* struct tpacket{2,3}_hdr is aligned to a multiple of TPACKET_ALIGNMENT.
	 * We may add members to them until current aligned size without forcing
	 * userspace to call getsockopt(..., PACKET_HDRLEN, ...).
	 */
	BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32);
	BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48);

	if (skb->pkt_type == PACKET_LOOPBACK)
		goto drop;

	sk = pt->af_packet_priv;
	po = pkt_sk(sk);

	if (!net_eq(dev_net(dev), sock_net(sk)))
		goto drop;

	if (dev->header_ops) {
		if (sk->sk_type != SOCK_DGRAM)
			skb_push(skb, skb->data - skb_mac_header(skb));
		else if (skb->pkt_type == PACKET_OUTGOING) {
			/* Special case: outgoing packets have ll header at head */
			skb_pull(skb, skb_network_offset(skb));
		}
	}

	snaplen = skb->len;

	res = run_filter(skb, sk, snaplen);
	if (!res)
		goto drop_n_restore;

	/* If we are flooded, just give up */
	if (__packet_rcv_has_room(po, skb) == ROOM_NONE) {
		atomic_inc(&po->tp_drops);
		goto drop_n_restore;
	}

	if (skb->ip_summed == CHECKSUM_PARTIAL)
		status |= TP_STATUS_CSUMNOTREADY;
	else if (skb->pkt_type != PACKET_OUTGOING &&
		 (skb->ip_summed == CHECKSUM_COMPLETE ||
		  skb_csum_unnecessary(skb)))
		status |= TP_STATUS_CSUM_VALID;

	if (snaplen > res)
		snaplen = res;

	if (sk->sk_type == SOCK_DGRAM) {
		macoff = netoff = TPACKET_ALIGN(po->tp_hdrlen) + 16 +
				  po->tp_reserve;
	} else {
		unsigned int maclen = skb_network_offset(skb);
		netoff = TPACKET_ALIGN(po->tp_hdrlen +
				       (maclen < 16 ? 16 : maclen)) +
				       po->tp_reserve;
		if (po->has_vnet_hdr) {
			netoff += sizeof(struct virtio_net_hdr);
			do_vnet = true;
		}
		macoff = netoff - maclen;
	}
	if (netoff > USHRT_MAX) {
		atomic_inc(&po->tp_drops);
		goto drop_n_restore;
	}
	if (po->tp_version <= TPACKET_V2) {
		if (macoff + snaplen > po->rx_ring.frame_size) {
			if (po->copy_thresh &&
			    atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf) {
				if (skb_shared(skb)) {
					copy_skb = skb_clone(skb, GFP_ATOMIC);
				} else {
					copy_skb = skb_get(skb);
					skb_head = skb->data;
				}
				if (copy_skb)
					skb_set_owner_r(copy_skb, sk);
			}
			snaplen = po->rx_ring.frame_size - macoff;
			if ((int)snaplen < 0) {
				snaplen = 0;
				do_vnet = false;
			}
		}
	} else if (unlikely(macoff + snaplen >
			    GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len)) {
		u32 nval;

		nval = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len - macoff;
		pr_err_once(""tpacket_rcv: packet too big, clamped from %u to %u. macoff=%u\n"",
			    snaplen, nval, macoff);
		snaplen = nval;
		if (unlikely((int)snaplen < 0)) {
			snaplen = 0;
			macoff = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len;
			do_vnet = false;
		}
	}
	spin_lock(&sk->sk_receive_queue.lock);
	h.raw = packet_current_rx_frame(po, skb,
					TP_STATUS_KERNEL, (macoff+snaplen));
	if (!h.raw)
		goto drop_n_account;

	if (po->tp_version <= TPACKET_V2) {
		slot_id = po->rx_ring.head;
		if (test_bit(slot_id, po->rx_ring.rx_owner_map))
			goto drop_n_account;
		__set_bit(slot_id, po->rx_ring.rx_owner_map);
	}

	if (do_vnet &&
	    virtio_net_hdr_from_skb(skb, h.raw + macoff -
				    sizeof(struct virtio_net_hdr),
				    vio_le(), true, 0)) {
		if (po->tp_version == TPACKET_V3)
			prb_clear_blk_fill_status(&po->rx_ring);
		goto drop_n_account;
	}

	if (po->tp_version <= TPACKET_V2) {
		packet_increment_rx_head(po, &po->rx_ring);
	/*
	 * LOSING will be reported till you read the stats,
	 * because it's COR - Clear On Read.
	 * Anyways, moving it for V1/V2 only as V3 doesn't need this
	 * at packet level.
	 */
		if (atomic_read(&po->tp_drops))
			status |= TP_STATUS_LOSING;
	}

	po->stats.stats1.tp_packets++;
	if (copy_skb) {
		status |= TP_STATUS_COPY;
		__skb_queue_tail(&sk->sk_receive_queue, copy_skb);
	}
	spin_unlock(&sk->sk_receive_queue.lock);

	skb_copy_bits(skb, 0, h.raw + macoff, snaplen);

	if (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))
		ktime_get_real_ts64(&ts);

	status |= ts_status;

	switch (po->tp_version) {
	case TPACKET_V1:
		h.h1->tp_len = skb->len;
		h.h1->tp_snaplen = snaplen;
		h.h1->tp_mac = macoff;
		h.h1->tp_net = netoff;
		h.h1->tp_sec = ts.tv_sec;
		h.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;
		hdrlen = sizeof(*h.h1);
		break;
	case TPACKET_V2:
		h.h2->tp_len = skb->len;
		h.h2->tp_snaplen = snaplen;
		h.h2->tp_mac = macoff;
		h.h2->tp_net = netoff;
		h.h2->tp_sec = ts.tv_sec;
		h.h2->tp_nsec = ts.tv_nsec;
		if (skb_vlan_tag_present(skb)) {
			h.h2->tp_vlan_tci = skb_vlan_tag_get(skb);
			h.h2->tp_vlan_tpid = ntohs(skb->vlan_proto);
			status |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID;
		} else {
			h.h2->tp_vlan_tci = 0;
			h.h2->tp_vlan_tpid = 0;
		}
		memset(h.h2->tp_padding, 0, sizeof(h.h2->tp_padding));
		hdrlen = sizeof(*h.h2);
		break;
	case TPACKET_V3:
		/* tp_nxt_offset,vlan are already populated above.
		 * So DONT clear those fields here
		 */
		h.h3->tp_status |= status;
		h.h3->tp_len = skb->len;
		h.h3->tp_snaplen = snaplen;
		h.h3->tp_mac = macoff;
		h.h3->tp_net = netoff;
		h.h3->tp_sec  = ts.tv_sec;
		h.h3->tp_nsec = ts.tv_nsec;
		memset(h.h3->tp_padding, 0, sizeof(h.h3->tp_padding));
		hdrlen = sizeof(*h.h3);
		break;
	default:
		BUG();
	}

	sll = h.raw + TPACKET_ALIGN(hdrlen);
	sll->sll_halen = dev_parse_header(skb, sll->sll_addr);
	sll->sll_family = AF_PACKET;
	sll->sll_hatype = dev->type;
	sll->sll_protocol = skb->protocol;
	sll->sll_pkttype = skb->pkt_type;
	if (unlikely(po->origdev))
		sll->sll_ifindex = orig_dev->ifindex;
	else
		sll->sll_ifindex = dev->ifindex;

	smp_mb();

#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1
	if (po->tp_version <= TPACKET_V2) {
		u8 *start, *end;

		end = (u8 *) PAGE_ALIGN((unsigned long) h.raw +
					macoff + snaplen);

		for (start = h.raw; start < end; start += PAGE_SIZE)
			flush_dcache_page(pgv_to_page(start));
	}
	smp_wmb();
#endif

	if (po->tp_version <= TPACKET_V2) {
		spin_lock(&sk->sk_receive_queue.lock);
		__packet_set_status(po, h.raw, status);
		__clear_bit(slot_id, po->rx_ring.rx_owner_map);
		spin_unlock(&sk->sk_receive_queue.lock);
		sk->sk_data_ready(sk);
	} else if (po->tp_version == TPACKET_V3) {
		prb_clear_blk_fill_status(&po->rx_ring);
	}

drop_n_restore:
	if (skb_head != skb->data && skb_shared(skb)) {
		skb->data = skb_head;
		skb->len = skb_len;
	}
drop:
	if (!is_drop_n_account)
		consume_skb(skb);
	else
		kfree_skb(skb);
	return 0;

drop_n_account:
	spin_unlock(&sk->sk_receive_queue.lock);
	atomic_inc(&po->tp_drops);
	is_drop_n_account = true;

	sk->sk_data_ready(sk);
	kfree_skb(copy_skb);
	goto drop_n_restore;
}","static int tpacket_rcv(struct sk_buff *VAR_0, struct net_device *VAR_1,
		       struct packet_type *VAR_2, struct net_device *VAR_3)
{
	struct sock *VAR_4;
	struct packet_sock *VAR_5;
	struct sockaddr_ll *VAR_6;
	union tpacket_uhdr VAR_7;
	u8 *VAR_8 = VAR_0->data;
	int VAR_9 = VAR_0->len;
	unsigned int VAR_10, VAR_11;
	unsigned long VAR_12 = VAR_13;
	unsigned short VAR_14, VAR_15;
	unsigned int VAR_16;
	struct sk_buff *VAR_17 = NULL;
	struct timespec64 VAR_18;
	__u32 VAR_19;
	bool VAR_20 = false;
	unsigned int VAR_21 = 0;
	bool VAR_22 = false;

	/* COMMENT_0 */
                                                                         
                                                          
    
	BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*VAR_7.h2)) != 32);
	BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*VAR_7.h3)) != 48);

	if (VAR_0->pkt_type == VAR_23)
		goto drop;

	VAR_4 = VAR_2->af_packet_priv;
	VAR_5 = pkt_sk(VAR_4);

	if (!net_eq(dev_net(VAR_1), sock_net(VAR_4)))
		goto drop;

	if (VAR_1->header_ops) {
		if (VAR_4->sk_type != VAR_24)
			skb_push(VAR_0, VAR_0->data - skb_mac_header(VAR_0));
		else if (VAR_0->pkt_type == VAR_25) {
			/* COMMENT_4 */
			skb_pull(VAR_0, skb_network_offset(VAR_0));
		}
	}

	VAR_10 = VAR_0->len;

	VAR_11 = run_filter(VAR_0, VAR_4, VAR_10);
	if (!VAR_11)
		goto drop_n_restore;

	/* COMMENT_5 */
	if (__packet_rcv_has_room(VAR_5, VAR_0) == VAR_26) {
		atomic_inc(&VAR_5->tp_drops);
		goto drop_n_restore;
	}

	if (VAR_0->ip_summed == VAR_27)
		VAR_12 |= VAR_28;
	else if (VAR_0->pkt_type != VAR_25 &&
		 (VAR_0->ip_summed == VAR_29 ||
		  skb_csum_unnecessary(VAR_0)))
		VAR_12 |= VAR_30;

	if (VAR_10 > VAR_11)
		VAR_10 = VAR_11;

	if (VAR_4->sk_type == VAR_24) {
		VAR_14 = VAR_16 = TPACKET_ALIGN(VAR_5->tp_hdrlen) + 16 +
				  VAR_5->tp_reserve;
	} else {
		unsigned int VAR_31 = skb_network_offset(VAR_0);
		VAR_16 = TPACKET_ALIGN(VAR_5->tp_hdrlen +
				       (VAR_31 < 16 ? 16 : VAR_31)) +
				       VAR_5->tp_reserve;
		if (VAR_5->has_vnet_hdr) {
			VAR_16 += sizeof(struct virtio_net_hdr);
			VAR_22 = true;
		}
		VAR_14 = VAR_16 - VAR_31;
	}
	if (VAR_16 > VAR_32) {
		atomic_inc(&VAR_5->tp_drops);
		goto drop_n_restore;
	}
	if (VAR_5->tp_version <= VAR_33) {
		if (VAR_14 + VAR_10 > VAR_5->rx_ring.frame_size) {
			if (VAR_5->copy_thresh &&
			    atomic_read(&VAR_4->sk_rmem_alloc) < VAR_4->sk_rcvbuf) {
				if (skb_shared(VAR_0)) {
					VAR_17 = skb_clone(VAR_0, VAR_34);
				} else {
					VAR_17 = skb_get(VAR_0);
					VAR_8 = VAR_0->data;
				}
				if (VAR_17)
					skb_set_owner_r(VAR_17, VAR_4);
			}
			VAR_10 = VAR_5->rx_ring.frame_size - VAR_14;
			if ((int)VAR_10 < 0) {
				VAR_10 = 0;
				VAR_22 = false;
			}
		}
	} else if (unlikely(VAR_14 + VAR_10 >
			    GET_PBDQC_FROM_RB(&VAR_5->rx_ring)->max_frame_len)) {
		u32 VAR_35;

		VAR_35 = GET_PBDQC_FROM_RB(&VAR_5->rx_ring)->max_frame_len - VAR_14;
		pr_err_once(""tpacket_rcv: packet too big, clamped from %u to %u. macoff=%u\n"",
			    VAR_10, VAR_35, VAR_14);
		VAR_10 = VAR_35;
		if (unlikely((int)VAR_10 < 0)) {
			VAR_10 = 0;
			VAR_14 = GET_PBDQC_FROM_RB(&VAR_5->rx_ring)->max_frame_len;
			VAR_22 = false;
		}
	}
	spin_lock(&VAR_4->sk_receive_queue.lock);
	VAR_7.raw = packet_current_rx_frame(VAR_5, VAR_0,
					VAR_36, (VAR_14+VAR_10));
	if (!VAR_7.raw)
		goto drop_n_account;

	if (VAR_5->tp_version <= VAR_33) {
		VAR_21 = VAR_5->rx_ring.head;
		if (test_bit(VAR_21, VAR_5->rx_ring.rx_owner_map))
			goto drop_n_account;
		__set_bit(VAR_21, VAR_5->rx_ring.rx_owner_map);
	}

	if (VAR_22 &&
	    virtio_net_hdr_from_skb(VAR_0, VAR_7.raw + VAR_14 -
				    sizeof(struct virtio_net_hdr),
				    vio_le(), true, 0)) {
		if (VAR_5->tp_version == VAR_37)
			prb_clear_blk_fill_status(&VAR_5->rx_ring);
		goto drop_n_account;
	}

	if (VAR_5->tp_version <= VAR_33) {
		packet_increment_rx_head(VAR_5, &VAR_5->rx_ring);
	/* COMMENT_6 */
                                                    
                                     
                                                             
                    
    
		if (atomic_read(&VAR_5->tp_drops))
			VAR_12 |= VAR_38;
	}

	VAR_5->stats.stats1.tp_packets++;
	if (VAR_17) {
		VAR_12 |= VAR_39;
		__skb_queue_tail(&VAR_4->sk_receive_queue, VAR_17);
	}
	spin_unlock(&VAR_4->sk_receive_queue.lock);

	skb_copy_bits(VAR_0, 0, VAR_7.raw + VAR_14, VAR_10);

	if (!(VAR_19 = tpacket_get_timestamp(VAR_0, &VAR_18, VAR_5->tp_tstamp)))
		ktime_get_real_ts64(&VAR_18);

	VAR_12 |= VAR_19;

	switch (VAR_5->tp_version) {
	case VAR_40:
		VAR_7.h1->tp_len = VAR_0->len;
		VAR_7.h1->tp_snaplen = VAR_10;
		VAR_7.h1->tp_mac = VAR_14;
		VAR_7.h1->tp_net = VAR_16;
		VAR_7.h1->tp_sec = VAR_18.tv_sec;
		VAR_7.h1->tp_usec = VAR_18.tv_nsec / VAR_41;
		VAR_15 = sizeof(*VAR_7.h1);
		break;
	case VAR_33:
		VAR_7.h2->tp_len = VAR_0->len;
		VAR_7.h2->tp_snaplen = VAR_10;
		VAR_7.h2->tp_mac = VAR_14;
		VAR_7.h2->tp_net = VAR_16;
		VAR_7.h2->tp_sec = VAR_18.tv_sec;
		VAR_7.h2->tp_nsec = VAR_18.tv_nsec;
		if (skb_vlan_tag_present(VAR_0)) {
			VAR_7.h2->tp_vlan_tci = skb_vlan_tag_get(VAR_0);
			VAR_7.h2->tp_vlan_tpid = ntohs(VAR_0->vlan_proto);
			VAR_12 |= VAR_42 | VAR_43;
		} else {
			VAR_7.h2->tp_vlan_tci = 0;
			VAR_7.h2->tp_vlan_tpid = 0;
		}
		memset(VAR_7.h2->tp_padding, 0, sizeof(VAR_7.h2->tp_padding));
		VAR_15 = sizeof(*VAR_7.h2);
		break;
	case VAR_37:
		/* COMMENT_12 */
                                    
     
		VAR_7.h3->tp_status |= VAR_12;
		VAR_7.h3->tp_len = VAR_0->len;
		VAR_7.h3->tp_snaplen = VAR_10;
		VAR_7.h3->tp_mac = VAR_14;
		VAR_7.h3->tp_net = VAR_16;
		VAR_7.h3->tp_sec  = VAR_18.tv_sec;
		VAR_7.h3->tp_nsec = VAR_18.tv_nsec;
		memset(VAR_7.h3->tp_padding, 0, sizeof(VAR_7.h3->tp_padding));
		VAR_15 = sizeof(*VAR_7.h3);
		break;
	default:
		BUG();
	}

	VAR_6 = VAR_7.raw + TPACKET_ALIGN(VAR_15);
	VAR_6->sll_halen = dev_parse_header(VAR_0, VAR_6->sll_addr);
	VAR_6->sll_family = VAR_44;
	VAR_6->sll_hatype = VAR_1->type;
	VAR_6->sll_protocol = VAR_0->protocol;
	VAR_6->sll_pkttype = VAR_0->pkt_type;
	if (unlikely(VAR_5->origdev))
		VAR_6->sll_ifindex = VAR_3->ifindex;
	else
		VAR_6->sll_ifindex = VAR_1->ifindex;

	smp_mb();

#if VAR_45 == 1
	if (VAR_5->tp_version <= VAR_33) {
		u8 *VAR_46, *VAR_47;

		VAR_47 = (u8 *) PAGE_ALIGN((unsigned long) VAR_7.raw +
					VAR_14 + VAR_10);

		for (VAR_46 = VAR_7.raw; VAR_46 < VAR_47; VAR_46 += VAR_48)
			flush_dcache_page(pgv_to_page(VAR_46));
	}
	smp_wmb();
#endif

	if (VAR_5->tp_version <= VAR_33) {
		spin_lock(&VAR_4->sk_receive_queue.lock);
		__packet_set_status(VAR_5, VAR_7.raw, VAR_12);
		__clear_bit(VAR_21, VAR_5->rx_ring.rx_owner_map);
		spin_unlock(&VAR_4->sk_receive_queue.lock);
		VAR_4->sk_data_ready(VAR_4);
	} else if (VAR_5->tp_version == VAR_37) {
		prb_clear_blk_fill_status(&VAR_5->rx_ring);
	}

drop_n_restore:
	if (VAR_8 != VAR_0->data && skb_shared(VAR_0)) {
		VAR_0->data = VAR_8;
		VAR_0->len = VAR_9;
	}
drop:
	if (!VAR_20)
		consume_skb(VAR_0);
	else
		kfree_skb(VAR_0);
	return 0;

drop_n_account:
	spin_unlock(&VAR_4->sk_receive_queue.lock);
	atomic_inc(&VAR_5->tp_drops);
	VAR_20 = true;

	VAR_4->sk_data_ready(VAR_4);
	kfree_skb(VAR_17);
	goto drop_n_restore;
}",torvalds/linux/acf69c946233259ab4d64f8869d4037a198c7f06/af_packet.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,7 +9,8 @@
 	int skb_len = skb->len;
 	unsigned int snaplen, res;
 	unsigned long status = TP_STATUS_USER;
-	unsigned short macoff, netoff, hdrlen;
+	unsigned short macoff, hdrlen;
+	unsigned int netoff;
 	struct sk_buff *copy_skb = NULL;
 	struct timespec64 ts;
 	__u32 ts_status;
@@ -77,6 +78,10 @@
 			do_vnet = true;
 		}
 		macoff = netoff - maclen;
+	}
+	if (netoff > USHRT_MAX) {
+		atomic_inc(&po->tp_drops);
+		goto drop_n_restore;
 	}
 	if (po->tp_version <= TPACKET_V2) {
 		if (macoff + snaplen > po->rx_ring.frame_size) {","{'deleted_lines': ['\tunsigned short macoff, netoff, hdrlen;'], 'added_lines': ['\tunsigned short macoff, hdrlen;', '\tunsigned int netoff;', '\t}', '\tif (netoff > USHRT_MAX) {', '\t\tatomic_inc(&po->tp_drops);', '\t\tgoto drop_n_restore;']}",True,A flaw was found in the Linux kernel before 5.9-rc4. Memory corruption can be exploited to gain root privileges from unprivileged processes. The highest threat from this vulnerability is to data confidentiality and integrity.,7.8,HIGH,2,test,,5
CVE-2023-3358,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"As the kcalloc may return NULL pointer,
it should be better to check the ishtp_dma_tx_map
before use in order to avoid NULL pointer dereference.

Fixes: 3703f53b99e4 (""HID: intel_ish-hid: ISH Transport layer"")
Signed-off-by: Jiasheng Jiang <jiasheng@iscas.ac.cn>
Acked-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Signed-off-by: Jiri Kosina <jkosina@suse.cz>
",b3d40c3ec3dc4ad78017de6c3a38979f57aaaab8,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=b3d40c3ec3dc4ad78017de6c3a38979f57aaaab8,drivers/hid/intel-ish-hid/ishtp/dma-if.c,ishtp_cl_get_dma_send_buf,"void *ishtp_cl_get_dma_send_buf(struct ishtp_device *dev,
uint32_t size)
{
unsigned longflags;
int i, j, free;
int required_slots = (size / DMA_SLOT_SIZE)
+ 1 * (size % DMA_SLOT_SIZE != 0);
spin_lock_irqsave(&dev->ishtp_dma_tx_lock, flags);
for (i = 0; i <= (dev->ishtp_dma_num_slots - required_slots); i++) {
free = 1;
for (j = 0; j < required_slots; j++)
if (dev->ishtp_dma_tx_map[i+j]) {
free = 0;
i += j;
break;
}
if (free) {
for (j = 0; j < required_slots; j++)
dev->ishtp_dma_tx_map[i+j] = 1;
spin_unlock_irqrestore(&dev->ishtp_dma_tx_lock, flags);
return (i * DMA_SLOT_SIZE) +
(unsigned char *)dev->ishtp_host_dma_tx_buf;
}
}
spin_unlock_irqrestore(&dev->ishtp_dma_tx_lock, flags);
dev_err(dev->devc, ""No free DMA buffer to send msg\n"");
return NULL;
}","void *ishtp_cl_get_dma_send_buf(struct ishtp_device *VAR_0,
uint32_t VAR_1)
{
unsigned longVAR_2;
int VAR_3, VAR_4, VAR_5;
int VAR_6 = (VAR_1 / VAR_7)
+ 1 * (VAR_1 % VAR_7 != 0);
spin_lock_irqsave(&VAR_0->ishtp_dma_tx_lock, VAR_2);
for (VAR_3 = 0; VAR_3 <= (VAR_0->ishtp_dma_num_slots - VAR_6); VAR_3++) {
VAR_5 = 1;
for (VAR_4 = 0; VAR_4 < VAR_6; VAR_4++)
if (VAR_0->ishtp_dma_tx_map[VAR_3+VAR_4]) {
VAR_5 = 0;
VAR_3 += VAR_4;
break;
}
if (VAR_5) {
for (VAR_4 = 0; VAR_4 < VAR_6; VAR_4++)
VAR_0->ishtp_dma_tx_map[VAR_3+VAR_4] = 1;
spin_unlock_irqrestore(&VAR_0->ishtp_dma_tx_lock, VAR_2);
return (VAR_3 * VAR_7) +
(unsigned char *)VAR_0->ishtp_host_dma_tx_buf;
}
}
spin_unlock_irqrestore(&VAR_0->ishtp_dma_tx_lock, VAR_2);
dev_err(VAR_0->devc, ""No free DMA buffer to send msg\n"");
return NULL;
}",torvalds/linux/b3d40c3ec3dc4ad78017de6c3a38979f57aaaab8/dma-if.c/vul/before/0.json,"void *ishtp_cl_get_dma_send_buf(struct ishtp_device *dev,
				uint32_t size)
{
	unsigned long	flags;
	int i, j, free;
	/* additional slot is needed if there is rem */
	int required_slots = (size / DMA_SLOT_SIZE)
		+ 1 * (size % DMA_SLOT_SIZE != 0);

	if (!dev->ishtp_dma_tx_map) {
		dev_err(dev->devc, ""Fail to allocate Tx map\n"");
		return NULL;
	}

	spin_lock_irqsave(&dev->ishtp_dma_tx_lock, flags);
	for (i = 0; i <= (dev->ishtp_dma_num_slots - required_slots); i++) {
		free = 1;
		for (j = 0; j < required_slots; j++)
			if (dev->ishtp_dma_tx_map[i+j]) {
				free = 0;
				i += j;
				break;
			}
		if (free) {
			/* mark memory as ""caught"" */
			for (j = 0; j < required_slots; j++)
				dev->ishtp_dma_tx_map[i+j] = 1;
			spin_unlock_irqrestore(&dev->ishtp_dma_tx_lock, flags);
			return (i * DMA_SLOT_SIZE) +
				(unsigned char *)dev->ishtp_host_dma_tx_buf;
		}
	}
	spin_unlock_irqrestore(&dev->ishtp_dma_tx_lock, flags);
	dev_err(dev->devc, ""No free DMA buffer to send msg\n"");
	return NULL;
}","void *ishtp_cl_get_dma_send_buf(struct ishtp_device *VAR_0,
				uint32_t VAR_1)
{
	unsigned long	VAR_2;
	int VAR_3, VAR_4, VAR_5;
	/* COMMENT_0 */
	int VAR_6 = (VAR_1 / VAR_7)
		+ 1 * (VAR_1 % VAR_7 != 0);

	if (!VAR_0->ishtp_dma_tx_map) {
		dev_err(VAR_0->devc, ""Fail to allocate Tx map\n"");
		return NULL;
	}

	spin_lock_irqsave(&VAR_0->ishtp_dma_tx_lock, VAR_2);
	for (VAR_3 = 0; VAR_3 <= (VAR_0->ishtp_dma_num_slots - VAR_6); VAR_3++) {
		VAR_5 = 1;
		for (VAR_4 = 0; VAR_4 < VAR_6; VAR_4++)
			if (VAR_0->ishtp_dma_tx_map[VAR_3+VAR_4]) {
				VAR_5 = 0;
				VAR_3 += VAR_4;
				break;
			}
		if (VAR_5) {
			/* COMMENT_1 */
			for (VAR_4 = 0; VAR_4 < VAR_6; VAR_4++)
				VAR_0->ishtp_dma_tx_map[VAR_3+VAR_4] = 1;
			spin_unlock_irqrestore(&VAR_0->ishtp_dma_tx_lock, VAR_2);
			return (VAR_3 * VAR_7) +
				(unsigned char *)VAR_0->ishtp_host_dma_tx_buf;
		}
	}
	spin_unlock_irqrestore(&VAR_0->ishtp_dma_tx_lock, VAR_2);
	dev_err(VAR_0->devc, ""No free DMA buffer to send msg\n"");
	return NULL;
}",torvalds/linux/b3d40c3ec3dc4ad78017de6c3a38979f57aaaab8/dma-if.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,11 @@
 	/* additional slot is needed if there is rem */
 	int required_slots = (size / DMA_SLOT_SIZE)
 		+ 1 * (size % DMA_SLOT_SIZE != 0);
+
+	if (!dev->ishtp_dma_tx_map) {
+		dev_err(dev->devc, ""Fail to allocate Tx map\n"");
+		return NULL;
+	}
 
 	spin_lock_irqsave(&dev->ishtp_dma_tx_lock, flags);
 	for (i = 0; i <= (dev->ishtp_dma_num_slots - required_slots); i++) {","{'deleted_lines': [], 'added_lines': ['', '\tif (!dev->ishtp_dma_tx_map) {', '\t\tdev_err(dev->devc, ""Fail to allocate Tx map\\n"");', '\t\treturn NULL;', '\t}']}",True,A null pointer dereference was found in the Linux kernel's Integrated Sensor Hub (ISH) driver. This issue could allow a local user to crash the system.,5.5,MEDIUM,1,test,,5
CVE-2023-3358,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"As the kcalloc may return NULL pointer,
it should be better to check the ishtp_dma_tx_map
before use in order to avoid NULL pointer dereference.

Fixes: 3703f53b99e4 (""HID: intel_ish-hid: ISH Transport layer"")
Signed-off-by: Jiasheng Jiang <jiasheng@iscas.ac.cn>
Acked-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Signed-off-by: Jiri Kosina <jkosina@suse.cz>
",b3d40c3ec3dc4ad78017de6c3a38979f57aaaab8,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=b3d40c3ec3dc4ad78017de6c3a38979f57aaaab8,drivers/hid/intel-ish-hid/ishtp/dma-if.c,ishtp_cl_release_dma_acked_mem,"void ishtp_cl_release_dma_acked_mem(struct ishtp_device *dev,
void *msg_addr,
uint8_t size)
{
unsigned longflags;
int acked_slots = (size / DMA_SLOT_SIZE)
+ 1 * (size % DMA_SLOT_SIZE != 0);
int i, j;
if ((msg_addr - dev->ishtp_host_dma_tx_buf) % DMA_SLOT_SIZE) {
dev_err(dev->devc, ""Bad DMA Tx ack address\n"");
return;
}
i = (msg_addr - dev->ishtp_host_dma_tx_buf) / DMA_SLOT_SIZE;
spin_lock_irqsave(&dev->ishtp_dma_tx_lock, flags);
for (j = 0; j < acked_slots; j++) {
if ((i + j) >= dev->ishtp_dma_num_slots ||
!dev->ishtp_dma_tx_map[i+j]) {
spin_unlock_irqrestore(&dev->ishtp_dma_tx_lock, flags);
dev_err(dev->devc, ""Bad DMA Tx ack address\n"");
return;
}
dev->ishtp_dma_tx_map[i+j] = 0;
}
spin_unlock_irqrestore(&dev->ishtp_dma_tx_lock, flags);
}","void ishtp_cl_release_dma_acked_mem(struct ishtp_device *VAR_0,
void *VAR_1,
uint8_t VAR_2)
{
unsigned longVAR_3;
int VAR_4 = (VAR_2 / VAR_5)
+ 1 * (VAR_2 % VAR_5 != 0);
int VAR_6, VAR_7;
if ((VAR_1 - VAR_0->ishtp_host_dma_tx_buf) % VAR_5) {
dev_err(VAR_0->devc, ""Bad DMA Tx ack address\n"");
return;
}
VAR_6 = (VAR_1 - VAR_0->ishtp_host_dma_tx_buf) / VAR_5;
spin_lock_irqsave(&VAR_0->ishtp_dma_tx_lock, VAR_3);
for (VAR_7 = 0; VAR_7 < VAR_4; VAR_7++) {
if ((VAR_6 + VAR_7) >= VAR_0->ishtp_dma_num_slots ||
!VAR_0->ishtp_dma_tx_map[VAR_6+VAR_7]) {
spin_unlock_irqrestore(&VAR_0->ishtp_dma_tx_lock, VAR_3);
dev_err(VAR_0->devc, ""Bad DMA Tx ack address\n"");
return;
}
VAR_0->ishtp_dma_tx_map[VAR_6+VAR_7] = 0;
}
spin_unlock_irqrestore(&VAR_0->ishtp_dma_tx_lock, VAR_3);
}",torvalds/linux/b3d40c3ec3dc4ad78017de6c3a38979f57aaaab8/dma-if.c/vul/before/1.json,"void ishtp_cl_release_dma_acked_mem(struct ishtp_device *dev,
				    void *msg_addr,
				    uint8_t size)
{
	unsigned long	flags;
	int acked_slots = (size / DMA_SLOT_SIZE)
		+ 1 * (size % DMA_SLOT_SIZE != 0);
	int i, j;

	if ((msg_addr - dev->ishtp_host_dma_tx_buf) % DMA_SLOT_SIZE) {
		dev_err(dev->devc, ""Bad DMA Tx ack address\n"");
		return;
	}

	if (!dev->ishtp_dma_tx_map) {
		dev_err(dev->devc, ""Fail to allocate Tx map\n"");
		return;
	}

	i = (msg_addr - dev->ishtp_host_dma_tx_buf) / DMA_SLOT_SIZE;
	spin_lock_irqsave(&dev->ishtp_dma_tx_lock, flags);
	for (j = 0; j < acked_slots; j++) {
		if ((i + j) >= dev->ishtp_dma_num_slots ||
					!dev->ishtp_dma_tx_map[i+j]) {
			/* no such slot, or memory is already free */
			spin_unlock_irqrestore(&dev->ishtp_dma_tx_lock, flags);
			dev_err(dev->devc, ""Bad DMA Tx ack address\n"");
			return;
		}
		dev->ishtp_dma_tx_map[i+j] = 0;
	}
	spin_unlock_irqrestore(&dev->ishtp_dma_tx_lock, flags);
}","void ishtp_cl_release_dma_acked_mem(struct ishtp_device *VAR_0,
				    void *VAR_1,
				    uint8_t VAR_2)
{
	unsigned long	VAR_3;
	int VAR_4 = (VAR_2 / VAR_5)
		+ 1 * (VAR_2 % VAR_5 != 0);
	int VAR_6, VAR_7;

	if ((VAR_1 - VAR_0->ishtp_host_dma_tx_buf) % VAR_5) {
		dev_err(VAR_0->devc, ""Bad DMA Tx ack address\n"");
		return;
	}

	if (!VAR_0->ishtp_dma_tx_map) {
		dev_err(VAR_0->devc, ""Fail to allocate Tx map\n"");
		return;
	}

	VAR_6 = (VAR_1 - VAR_0->ishtp_host_dma_tx_buf) / VAR_5;
	spin_lock_irqsave(&VAR_0->ishtp_dma_tx_lock, VAR_3);
	for (VAR_7 = 0; VAR_7 < VAR_4; VAR_7++) {
		if ((VAR_6 + VAR_7) >= VAR_0->ishtp_dma_num_slots ||
					!VAR_0->ishtp_dma_tx_map[VAR_6+VAR_7]) {
			/* COMMENT_0 */
			spin_unlock_irqrestore(&VAR_0->ishtp_dma_tx_lock, VAR_3);
			dev_err(VAR_0->devc, ""Bad DMA Tx ack address\n"");
			return;
		}
		VAR_0->ishtp_dma_tx_map[VAR_6+VAR_7] = 0;
	}
	spin_unlock_irqrestore(&VAR_0->ishtp_dma_tx_lock, VAR_3);
}",torvalds/linux/b3d40c3ec3dc4ad78017de6c3a38979f57aaaab8/dma-if.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -9,6 +9,11 @@
 
 	if ((msg_addr - dev->ishtp_host_dma_tx_buf) % DMA_SLOT_SIZE) {
 		dev_err(dev->devc, ""Bad DMA Tx ack address\n"");
+		return;
+	}
+
+	if (!dev->ishtp_dma_tx_map) {
+		dev_err(dev->devc, ""Fail to allocate Tx map\n"");
 		return;
 	}
 ","{'deleted_lines': [], 'added_lines': ['\t\treturn;', '\t}', '', '\tif (!dev->ishtp_dma_tx_map) {', '\t\tdev_err(dev->devc, ""Fail to allocate Tx map\\n"");']}",True,A null pointer dereference was found in the Linux kernel's Integrated Sensor Hub (ISH) driver. This issue could allow a local user to crash the system.,5.5,MEDIUM,1,test,,5
CVE-2023-26966,['CWE-120'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,libtiff,"tif_luv: Check and correct for NaN data in uv_encode().

Closes #530

See merge request !473
",b0e1c25dd1d065200c8d8f59ad0afe014861a1b9,https://gitlab.com/libtiff/libtiff/-/commit/b0e1c25dd1d065200c8d8f59ad0afe014861a1b9,libtiff/tif_luv.c,uv_encode,"static
#endif
int
uv_encode(double u, double v, int em) 
{
register int vi, ui;
if (v < UV_VSTART)
return oog_encode(u, v);
vi = tiff_itrunc((v - UV_VSTART) * (1. / UV_SQSIZ), em);
if (vi >= UV_NVS)
return oog_encode(u, v);
if (u < uv_row[vi].ustart)
return oog_encode(u, v);
ui = tiff_itrunc((u - uv_row[vi].ustart) * (1. / UV_SQSIZ), em);
if (ui >= uv_row[vi].nus)
return oog_encode(u, v);
return (uv_row[vi].ncum + ui);
}","static
#endif
int
uv_encode(double VAR_0, double VAR_1, int VAR_2) 
{
register int VAR_3, VAR_4;
if (VAR_1 < VAR_5)
return oog_encode(VAR_0, VAR_1);
VAR_3 = tiff_itrunc((VAR_1 - VAR_5) * (1. / VAR_6), VAR_2);
if (VAR_3 >= VAR_7)
return oog_encode(VAR_0, VAR_1);
if (VAR_0 < VAR_8[VAR_3].ustart)
return oog_encode(VAR_0, VAR_1);
VAR_4 = tiff_itrunc((VAR_0 - VAR_8[VAR_3].ustart) * (1. / VAR_6), VAR_2);
if (VAR_4 >= VAR_8[VAR_3].nus)
return oog_encode(VAR_0, VAR_1);
return (VAR_8[VAR_3].ncum + VAR_4);
}",libtiff/b0e1c25dd1d065200c8d8f59ad0afe014861a1b9/tif_luv.c/vul/before/0.json,"static
#endif
    int
    uv_encode(double u, double v, int em) /* encode (u',v') coordinates */
{
    register int vi, ui;

    /* check for NaN */
    if (u != u || v != v)
    {
        u = U_NEU;
        v = V_NEU;
    }

    if (v < UV_VSTART)
        return oog_encode(u, v);
    vi = tiff_itrunc((v - UV_VSTART) * (1. / UV_SQSIZ), em);
    if (vi >= UV_NVS)
        return oog_encode(u, v);
    if (u < uv_row[vi].ustart)
        return oog_encode(u, v);
    ui = tiff_itrunc((u - uv_row[vi].ustart) * (1. / UV_SQSIZ), em);
    if (ui >= uv_row[vi].nus)
        return oog_encode(u, v);

    return (uv_row[vi].ncum + ui);
}","static
#endif
    int
    uv_encode(double VAR_0, double VAR_1, int VAR_2) /* COMMENT_0 */
{
    register int VAR_3, VAR_4;

    /* COMMENT_1 */
    if (VAR_0 != VAR_0 || VAR_1 != VAR_1)
    {
        VAR_0 = VAR_5;
        VAR_1 = VAR_6;
    }

    if (VAR_1 < VAR_7)
        return oog_encode(VAR_0, VAR_1);
    VAR_3 = tiff_itrunc((VAR_1 - VAR_7) * (1. / VAR_8), VAR_2);
    if (VAR_3 >= VAR_9)
        return oog_encode(VAR_0, VAR_1);
    if (VAR_0 < VAR_10[VAR_3].ustart)
        return oog_encode(VAR_0, VAR_1);
    VAR_4 = tiff_itrunc((VAR_0 - VAR_10[VAR_3].ustart) * (1. / VAR_8), VAR_2);
    if (VAR_4 >= VAR_10[VAR_3].nus)
        return oog_encode(VAR_0, VAR_1);

    return (VAR_10[VAR_3].ncum + VAR_4);
}",libtiff/b0e1c25dd1d065200c8d8f59ad0afe014861a1b9/tif_luv.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,6 +4,13 @@
     uv_encode(double u, double v, int em) /* encode (u',v') coordinates */
 {
     register int vi, ui;
+
+    /* check for NaN */
+    if (u != u || v != v)
+    {
+        u = U_NEU;
+        v = V_NEU;
+    }
 
     if (v < UV_VSTART)
         return oog_encode(u, v);","{'deleted_lines': [], 'added_lines': ['', '    /* check for NaN */', '    if (u != u || v != v)', '    {', '        u = U_NEU;', '        v = V_NEU;', '    }']}",True,libtiff 4.5.0 is vulnerable to Buffer Overflow in uv_encode() when libtiff reads a corrupted little-endian TIFF file and specifies the output to be big-endian.,5.5,MEDIUM,1,test,,5
CVE-2023-21255,"['CWE-787', 'CWE-416']",CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,android,"FROMLIST: binder: fix UAF caused by faulty buffer cleanup

In binder_transaction_buffer_release() the 'failed_at' offset indicates
the number of objects to clean up. However, this function was changed by
commit 44d8047f1d87 (""binder: use standard functions to allocate fds""),
to release all the objects in the buffer when 'failed_at' is zero.

This introduced an issue when a transaction buffer is released without
any objects having been processed so far. In this case, 'failed_at' is
indeed zero yet it is misinterpreted as releasing the entire buffer.

This leads to use-after-free errors where nodes are incorrectly freed
and subsequently accessed. Such is the case in the following KASAN
report:

  ==================================================================
  BUG: KASAN: slab-use-after-free in binder_thread_read+0xc40/0x1f30
  Read of size 8 at addr ffff4faf037cfc58 by task poc/474

  CPU: 6 PID: 474 Comm: poc Not tainted 6.3.0-12570-g7df047b3f0aa #5
  Hardware name: linux,dummy-virt (DT)
  Call trace:
   dump_backtrace+0x94/0xec
   show_stack+0x18/0x24
   dump_stack_lvl+0x48/0x60
   print_report+0xf8/0x5b8
   kasan_report+0xb8/0xfc
   __asan_load8+0x9c/0xb8
   binder_thread_read+0xc40/0x1f30
   binder_ioctl+0xd9c/0x1768
   __arm64_sys_ioctl+0xd4/0x118
   invoke_syscall+0x60/0x188
  [...]

  Allocated by task 474:
   kasan_save_stack+0x3c/0x64
   kasan_set_track+0x2c/0x40
   kasan_save_alloc_info+0x24/0x34
   __kasan_kmalloc+0xb8/0xbc
   kmalloc_trace+0x48/0x5c
   binder_new_node+0x3c/0x3a4
   binder_transaction+0x2b58/0x36f0
   binder_thread_write+0x8e0/0x1b78
   binder_ioctl+0x14a0/0x1768
   __arm64_sys_ioctl+0xd4/0x118
   invoke_syscall+0x60/0x188
  [...]

  Freed by task 475:
   kasan_save_stack+0x3c/0x64
   kasan_set_track+0x2c/0x40
   kasan_save_free_info+0x38/0x5c
   __kasan_slab_free+0xe8/0x154
   __kmem_cache_free+0x128/0x2bc
   kfree+0x58/0x70
   binder_dec_node_tmpref+0x178/0x1fc
   binder_transaction_buffer_release+0x430/0x628
   binder_transaction+0x1954/0x36f0
   binder_thread_write+0x8e0/0x1b78
   binder_ioctl+0x14a0/0x1768
   __arm64_sys_ioctl+0xd4/0x118
   invoke_syscall+0x60/0x188
  [...]
  ==================================================================

In order to avoid these issues, let's always calculate the intended
'failed_at' offset beforehand. This is renamed and wrapped in a helper
function to make it clear and convenient.

Fixes: 32e9f56a96d8 (""binder: don't detect sender/target during buffer cleanup"")
Reported-by: Zi Fan Tan <zifantan@google.com>
Link: https://b.corp.google.com/issues/275041864
Cc: stable@vger.kernel.org
Signed-off-by: Carlos Llamas <cmllamas@google.com>

Bug: 275041864
Link: https://lore.kernel.org/all/20230505203020.4101154-1-cmllamas@google.com
Change-Id: I4bcc8bde77a8118872237d100cccb5caf95d99a1
Signed-off-by: Carlos Llamas <cmllamas@google.com>
",1ca1130ec62da7638497478539c0f55ffbbf9a5e,https://android.googlesource.com/kernel/common/+/1ca1130ec62d,drivers/android/binder.c,binder_free_buf,"static void
binder_free_buf(struct binder_proc *proc,
struct binder_thread *thread,
struct binder_buffer *buffer, bool is_failure)
{
binder_inner_proc_lock(proc);
if (buffer->transaction) {
buffer->transaction->buffer = NULL;
buffer->transaction = NULL;
}
binder_inner_proc_unlock(proc);
if (buffer->async_transaction && buffer->target_node) {
struct binder_node *buf_node;
struct binder_work *w;
buf_node = buffer->target_node;
binder_node_inner_lock(buf_node);
BUG_ON(!buf_node->has_async_transaction);
BUG_ON(buf_node->proc != proc);
w = binder_dequeue_work_head_ilocked(
&buf_node->async_todo);
if (!w) {
buf_node->has_async_transaction = false;
} else {
binder_enqueue_work_ilocked(
w, &proc->todo);
binder_wakeup_proc_ilocked(proc);
}
binder_node_inner_unlock(buf_node);
}
trace_binder_transaction_buffer_release(buffer);
binder_transaction_buffer_release(proc, thread, buffer, 0, is_failure);
binder_alloc_free_buf(&proc->alloc, buffer);
}","static void
binder_free_buf(struct binder_proc *VAR_0,
struct binder_thread *VAR_1,
struct binder_buffer *VAR_2, bool VAR_3)
{
binder_inner_proc_lock(VAR_0);
if (VAR_2->transaction) {
VAR_2->transaction->buffer = NULL;
VAR_2->transaction = NULL;
}
binder_inner_proc_unlock(VAR_0);
if (VAR_2->async_transaction && VAR_2->target_node) {
struct binder_node *VAR_4;
struct binder_work *VAR_5;
VAR_4 = VAR_2->target_node;
binder_node_inner_lock(VAR_4);
BUG_ON(!VAR_4->has_async_transaction);
BUG_ON(VAR_4->proc != VAR_0);
VAR_5 = binder_dequeue_work_head_ilocked(
&VAR_4->async_todo);
if (!VAR_5) {
VAR_4->has_async_transaction = false;
} else {
binder_enqueue_work_ilocked(
VAR_5, &VAR_0->todo);
binder_wakeup_proc_ilocked(VAR_0);
}
binder_node_inner_unlock(VAR_4);
}
trace_binder_transaction_buffer_release(VAR_2);
binder_transaction_buffer_release(VAR_0, VAR_1, VAR_2, 0, VAR_3);
binder_alloc_free_buf(&VAR_0->alloc, VAR_2);
}",android/1ca1130ec62da7638497478539c0f55ffbbf9a5e/binder.c/vul/before/0.json,"static void
binder_free_buf(struct binder_proc *proc,
		struct binder_thread *thread,
		struct binder_buffer *buffer, bool is_failure)
{
	binder_inner_proc_lock(proc);
	if (buffer->transaction) {
		buffer->transaction->buffer = NULL;
		buffer->transaction = NULL;
	}
	binder_inner_proc_unlock(proc);
	if (buffer->async_transaction && buffer->target_node) {
		struct binder_node *buf_node;
		struct binder_work *w;

		buf_node = buffer->target_node;
		binder_node_inner_lock(buf_node);
		BUG_ON(!buf_node->has_async_transaction);
		BUG_ON(buf_node->proc != proc);
		w = binder_dequeue_work_head_ilocked(
				&buf_node->async_todo);
		if (!w) {
			buf_node->has_async_transaction = false;
		} else {
			binder_enqueue_work_ilocked(
					w, &proc->todo);
			binder_wakeup_proc_ilocked(proc);
		}
		binder_node_inner_unlock(buf_node);
	}
	trace_binder_transaction_buffer_release(buffer);
	binder_release_entire_buffer(proc, thread, buffer, is_failure);
	binder_alloc_free_buf(&proc->alloc, buffer);
}","static void
binder_free_buf(struct binder_proc *VAR_0,
		struct binder_thread *VAR_1,
		struct binder_buffer *VAR_2, bool VAR_3)
{
	binder_inner_proc_lock(VAR_0);
	if (VAR_2->transaction) {
		VAR_2->transaction->buffer = NULL;
		VAR_2->transaction = NULL;
	}
	binder_inner_proc_unlock(VAR_0);
	if (VAR_2->async_transaction && VAR_2->target_node) {
		struct binder_node *VAR_4;
		struct binder_work *VAR_5;

		VAR_4 = VAR_2->target_node;
		binder_node_inner_lock(VAR_4);
		BUG_ON(!VAR_4->has_async_transaction);
		BUG_ON(VAR_4->proc != VAR_0);
		VAR_5 = binder_dequeue_work_head_ilocked(
				&VAR_4->async_todo);
		if (!VAR_5) {
			VAR_4->has_async_transaction = false;
		} else {
			binder_enqueue_work_ilocked(
					VAR_5, &VAR_0->todo);
			binder_wakeup_proc_ilocked(VAR_0);
		}
		binder_node_inner_unlock(VAR_4);
	}
	trace_binder_transaction_buffer_release(VAR_2);
	binder_release_entire_buffer(VAR_0, VAR_1, VAR_2, VAR_3);
	binder_alloc_free_buf(&VAR_0->alloc, VAR_2);
}",android/1ca1130ec62da7638497478539c0f55ffbbf9a5e/binder.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -29,6 +29,6 @@
 		binder_node_inner_unlock(buf_node);
 	}
 	trace_binder_transaction_buffer_release(buffer);
-	binder_transaction_buffer_release(proc, thread, buffer, 0, is_failure);
+	binder_release_entire_buffer(proc, thread, buffer, is_failure);
 	binder_alloc_free_buf(&proc->alloc, buffer);
 }","{'deleted_lines': ['\tbinder_transaction_buffer_release(proc, thread, buffer, 0, is_failure);'], 'added_lines': ['\tbinder_release_entire_buffer(proc, thread, buffer, is_failure);']}",True,"In multiple functions of binder.c, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.

",7.8,HIGH,2,test,,5
CVE-2023-21255,"['CWE-787', 'CWE-416']",CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,android,"FROMLIST: binder: fix UAF caused by faulty buffer cleanup

In binder_transaction_buffer_release() the 'failed_at' offset indicates
the number of objects to clean up. However, this function was changed by
commit 44d8047f1d87 (""binder: use standard functions to allocate fds""),
to release all the objects in the buffer when 'failed_at' is zero.

This introduced an issue when a transaction buffer is released without
any objects having been processed so far. In this case, 'failed_at' is
indeed zero yet it is misinterpreted as releasing the entire buffer.

This leads to use-after-free errors where nodes are incorrectly freed
and subsequently accessed. Such is the case in the following KASAN
report:

  ==================================================================
  BUG: KASAN: slab-use-after-free in binder_thread_read+0xc40/0x1f30
  Read of size 8 at addr ffff4faf037cfc58 by task poc/474

  CPU: 6 PID: 474 Comm: poc Not tainted 6.3.0-12570-g7df047b3f0aa #5
  Hardware name: linux,dummy-virt (DT)
  Call trace:
   dump_backtrace+0x94/0xec
   show_stack+0x18/0x24
   dump_stack_lvl+0x48/0x60
   print_report+0xf8/0x5b8
   kasan_report+0xb8/0xfc
   __asan_load8+0x9c/0xb8
   binder_thread_read+0xc40/0x1f30
   binder_ioctl+0xd9c/0x1768
   __arm64_sys_ioctl+0xd4/0x118
   invoke_syscall+0x60/0x188
  [...]

  Allocated by task 474:
   kasan_save_stack+0x3c/0x64
   kasan_set_track+0x2c/0x40
   kasan_save_alloc_info+0x24/0x34
   __kasan_kmalloc+0xb8/0xbc
   kmalloc_trace+0x48/0x5c
   binder_new_node+0x3c/0x3a4
   binder_transaction+0x2b58/0x36f0
   binder_thread_write+0x8e0/0x1b78
   binder_ioctl+0x14a0/0x1768
   __arm64_sys_ioctl+0xd4/0x118
   invoke_syscall+0x60/0x188
  [...]

  Freed by task 475:
   kasan_save_stack+0x3c/0x64
   kasan_set_track+0x2c/0x40
   kasan_save_free_info+0x38/0x5c
   __kasan_slab_free+0xe8/0x154
   __kmem_cache_free+0x128/0x2bc
   kfree+0x58/0x70
   binder_dec_node_tmpref+0x178/0x1fc
   binder_transaction_buffer_release+0x430/0x628
   binder_transaction+0x1954/0x36f0
   binder_thread_write+0x8e0/0x1b78
   binder_ioctl+0x14a0/0x1768
   __arm64_sys_ioctl+0xd4/0x118
   invoke_syscall+0x60/0x188
  [...]
  ==================================================================

In order to avoid these issues, let's always calculate the intended
'failed_at' offset beforehand. This is renamed and wrapped in a helper
function to make it clear and convenient.

Fixes: 32e9f56a96d8 (""binder: don't detect sender/target during buffer cleanup"")
Reported-by: Zi Fan Tan <zifantan@google.com>
Link: https://b.corp.google.com/issues/275041864
Cc: stable@vger.kernel.org
Signed-off-by: Carlos Llamas <cmllamas@google.com>

Bug: 275041864
Link: https://lore.kernel.org/all/20230505203020.4101154-1-cmllamas@google.com
Change-Id: I4bcc8bde77a8118872237d100cccb5caf95d99a1
Signed-off-by: Carlos Llamas <cmllamas@google.com>
",1ca1130ec62da7638497478539c0f55ffbbf9a5e,https://android.googlesource.com/kernel/common/+/1ca1130ec62d,drivers/android/binder.c,binder_proc_transaction,"static int binder_proc_transaction(struct binder_transaction *t,
struct binder_proc *proc,
struct binder_thread *thread)
{
struct binder_node *node = t->buffer->target_node;
bool oneway = !!(t->flags & TF_ONE_WAY);
bool pending_async = false;
struct binder_transaction *t_outdated = NULL;
bool skip = false;
BUG_ON(!node);
binder_node_lock(node);
if (oneway) {
BUG_ON(thread);
if (node->has_async_transaction)
pending_async = true;
else
node->has_async_transaction = true;
}
binder_inner_proc_lock(proc);
if (proc->is_frozen) {
proc->sync_recv |= !oneway;
proc->async_recv |= oneway;
}
if ((proc->is_frozen && !oneway) || proc->is_dead ||
(thread && thread->is_dead)) {
binder_inner_proc_unlock(proc);
binder_node_unlock(node);
return proc->is_frozen ? BR_FROZEN_REPLY : BR_DEAD_REPLY;
}
trace_android_vh_binder_proc_transaction_entry(proc, t,
&thread, node->debug_id, pending_async, !oneway, &skip);
if (!thread && !pending_async && !skip)
thread = binder_select_thread_ilocked(proc);
if (thread) {
binder_transaction_priority(thread, t, node);
binder_enqueue_thread_work_ilocked(thread, &t->work);
} else if (!pending_async) {
binder_enqueue_work_ilocked(&t->work, &proc->todo);
} else {
if ((t->flags & TF_UPDATE_TXN) && proc->is_frozen) {
t_outdated = binder_find_outdated_transaction_ilocked(t,
&node->async_todo);
if (t_outdated) {
binder_debug(BINDER_DEBUG_TRANSACTION,
""txn %d supersedes %d\n"",
t->debug_id, t_outdated->debug_id);
list_del_init(&t_outdated->work.entry);
proc->outstanding_txns--;
}
}
binder_enqueue_work_ilocked(&t->work, &node->async_todo);
}
trace_android_vh_binder_proc_transaction_finish(proc, t,
thread ? thread->task : NULL, pending_async, !oneway);
if (!pending_async)
binder_wakeup_thread_ilocked(proc, thread, !oneway );
proc->outstanding_txns++;
binder_inner_proc_unlock(proc);
binder_node_unlock(node);
if (t_outdated) {
struct binder_buffer *buffer = t_outdated->buffer;
t_outdated->buffer = NULL;
buffer->transaction = NULL;
trace_binder_transaction_update_buffer_release(buffer);
binder_transaction_buffer_release(proc, NULL, buffer, 0, 0);
binder_alloc_free_buf(&proc->alloc, buffer);
kfree(t_outdated);
binder_stats_deleted(BINDER_STAT_TRANSACTION);
}
return 0;
}","static int binder_proc_transaction(struct binder_transaction *VAR_0,
struct binder_proc *VAR_1,
struct binder_thread *VAR_2)
{
struct binder_node *VAR_3 = VAR_0->buffer->target_node;
bool VAR_4 = !!(VAR_0->flags & VAR_5);
bool VAR_6 = false;
struct binder_transaction *VAR_7 = NULL;
bool VAR_8 = false;
BUG_ON(!VAR_3);
binder_node_lock(VAR_3);
if (VAR_4) {
BUG_ON(VAR_2);
if (VAR_3->has_async_transaction)
VAR_6 = true;
else
VAR_3->has_async_transaction = true;
}
binder_inner_proc_lock(VAR_1);
if (VAR_1->is_frozen) {
VAR_1->sync_recv |= !VAR_4;
VAR_1->async_recv |= VAR_4;
}
if ((VAR_1->is_frozen && !VAR_4) || VAR_1->is_dead ||
(VAR_2 && VAR_2->is_dead)) {
binder_inner_proc_unlock(VAR_1);
binder_node_unlock(VAR_3);
return VAR_1->is_frozen ? VAR_9 : VAR_10;
}
trace_android_vh_binder_proc_transaction_entry(VAR_1, VAR_0,
&VAR_2, VAR_3->debug_id, VAR_6, !VAR_4, &VAR_8);
if (!VAR_2 && !VAR_6 && !VAR_8)
VAR_2 = binder_select_thread_ilocked(VAR_1);
if (VAR_2) {
binder_transaction_priority(VAR_2, VAR_0, VAR_3);
binder_enqueue_thread_work_ilocked(VAR_2, &VAR_0->work);
} else if (!VAR_6) {
binder_enqueue_work_ilocked(&VAR_0->work, &VAR_1->todo);
} else {
if ((VAR_0->flags & VAR_11) && VAR_1->is_frozen) {
VAR_7 = binder_find_outdated_transaction_ilocked(VAR_0,
&VAR_3->async_todo);
if (VAR_7) {
binder_debug(VAR_12,
""txn %d supersedes %d\n"",
VAR_0->debug_id, VAR_7->debug_id);
list_del_init(&VAR_7->work.entry);
VAR_1->outstanding_txns--;
}
}
binder_enqueue_work_ilocked(&VAR_0->work, &VAR_3->async_todo);
}
trace_android_vh_binder_proc_transaction_finish(VAR_1, VAR_0,
VAR_2 ? VAR_2->task : NULL, VAR_6, !VAR_4);
if (!VAR_6)
binder_wakeup_thread_ilocked(VAR_1, VAR_2, !VAR_4 );
VAR_1->outstanding_txns++;
binder_inner_proc_unlock(VAR_1);
binder_node_unlock(VAR_3);
if (VAR_7) {
struct binder_buffer *VAR_13 = VAR_7->buffer;
VAR_7->buffer = NULL;
VAR_13->transaction = NULL;
trace_binder_transaction_update_buffer_release(VAR_13);
binder_transaction_buffer_release(VAR_1, NULL, VAR_13, 0, 0);
binder_alloc_free_buf(&VAR_1->alloc, VAR_13);
kfree(VAR_7);
binder_stats_deleted(VAR_14);
}
return 0;
}",android/1ca1130ec62da7638497478539c0f55ffbbf9a5e/binder.c/vul/before/1.json,"static int binder_proc_transaction(struct binder_transaction *t,
				    struct binder_proc *proc,
				    struct binder_thread *thread)
{
	struct binder_node *node = t->buffer->target_node;
	bool oneway = !!(t->flags & TF_ONE_WAY);
	bool pending_async = false;
	struct binder_transaction *t_outdated = NULL;
	bool skip = false;

	BUG_ON(!node);
	binder_node_lock(node);

	if (oneway) {
		BUG_ON(thread);
		if (node->has_async_transaction)
			pending_async = true;
		else
			node->has_async_transaction = true;
	}

	binder_inner_proc_lock(proc);
	if (proc->is_frozen) {
		proc->sync_recv |= !oneway;
		proc->async_recv |= oneway;
	}

	if ((proc->is_frozen && !oneway) || proc->is_dead ||
			(thread && thread->is_dead)) {
		binder_inner_proc_unlock(proc);
		binder_node_unlock(node);
		return proc->is_frozen ? BR_FROZEN_REPLY : BR_DEAD_REPLY;
	}

	trace_android_vh_binder_proc_transaction_entry(proc, t,
		&thread, node->debug_id, pending_async, !oneway, &skip);

	if (!thread && !pending_async && !skip)
		thread = binder_select_thread_ilocked(proc);

	if (thread) {
		binder_transaction_priority(thread, t, node);
		binder_enqueue_thread_work_ilocked(thread, &t->work);
	} else if (!pending_async) {
		binder_enqueue_work_ilocked(&t->work, &proc->todo);
	} else {
		if ((t->flags & TF_UPDATE_TXN) && proc->is_frozen) {
			t_outdated = binder_find_outdated_transaction_ilocked(t,
									      &node->async_todo);
			if (t_outdated) {
				binder_debug(BINDER_DEBUG_TRANSACTION,
					     ""txn %d supersedes %d\n"",
					     t->debug_id, t_outdated->debug_id);
				list_del_init(&t_outdated->work.entry);
				proc->outstanding_txns--;
			}
		}
		binder_enqueue_work_ilocked(&t->work, &node->async_todo);
	}

	trace_android_vh_binder_proc_transaction_finish(proc, t,
		thread ? thread->task : NULL, pending_async, !oneway);
	if (!pending_async)
		binder_wakeup_thread_ilocked(proc, thread, !oneway /* sync */);

	proc->outstanding_txns++;
	binder_inner_proc_unlock(proc);
	binder_node_unlock(node);

	/*
	 * To reduce potential contention, free the outdated transaction and
	 * buffer after releasing the locks.
	 */
	if (t_outdated) {
		struct binder_buffer *buffer = t_outdated->buffer;

		t_outdated->buffer = NULL;
		buffer->transaction = NULL;
		trace_binder_transaction_update_buffer_release(buffer);
		binder_release_entire_buffer(proc, NULL, buffer, false);
		binder_alloc_free_buf(&proc->alloc, buffer);
		kfree(t_outdated);
		binder_stats_deleted(BINDER_STAT_TRANSACTION);
	}

	return 0;
}","static int binder_proc_transaction(struct binder_transaction *VAR_0,
				    struct binder_proc *VAR_1,
				    struct binder_thread *VAR_2)
{
	struct binder_node *VAR_3 = VAR_0->buffer->target_node;
	bool VAR_4 = !!(VAR_0->flags & VAR_5);
	bool VAR_6 = false;
	struct binder_transaction *VAR_7 = NULL;
	bool VAR_8 = false;

	BUG_ON(!VAR_3);
	binder_node_lock(VAR_3);

	if (VAR_4) {
		BUG_ON(VAR_2);
		if (VAR_3->has_async_transaction)
			VAR_6 = true;
		else
			VAR_3->has_async_transaction = true;
	}

	binder_inner_proc_lock(VAR_1);
	if (VAR_1->is_frozen) {
		VAR_1->sync_recv |= !VAR_4;
		VAR_1->async_recv |= VAR_4;
	}

	if ((VAR_1->is_frozen && !VAR_4) || VAR_1->is_dead ||
			(VAR_2 && VAR_2->is_dead)) {
		binder_inner_proc_unlock(VAR_1);
		binder_node_unlock(VAR_3);
		return VAR_1->is_frozen ? VAR_9 : VAR_10;
	}

	trace_android_vh_binder_proc_transaction_entry(VAR_1, VAR_0,
		&VAR_2, VAR_3->debug_id, VAR_6, !VAR_4, &VAR_8);

	if (!VAR_2 && !VAR_6 && !VAR_8)
		VAR_2 = binder_select_thread_ilocked(VAR_1);

	if (VAR_2) {
		binder_transaction_priority(VAR_2, VAR_0, VAR_3);
		binder_enqueue_thread_work_ilocked(VAR_2, &VAR_0->work);
	} else if (!VAR_6) {
		binder_enqueue_work_ilocked(&VAR_0->work, &VAR_1->todo);
	} else {
		if ((VAR_0->flags & VAR_11) && VAR_1->is_frozen) {
			VAR_7 = binder_find_outdated_transaction_ilocked(VAR_0,
									      &VAR_3->async_todo);
			if (VAR_7) {
				binder_debug(VAR_12,
					     ""txn %d supersedes %d\n"",
					     VAR_0->debug_id, VAR_7->debug_id);
				list_del_init(&VAR_7->work.entry);
				VAR_1->outstanding_txns--;
			}
		}
		binder_enqueue_work_ilocked(&VAR_0->work, &VAR_3->async_todo);
	}

	trace_android_vh_binder_proc_transaction_finish(VAR_1, VAR_0,
		VAR_2 ? VAR_2->task : NULL, VAR_6, !VAR_4);
	if (!VAR_6)
		binder_wakeup_thread_ilocked(VAR_1, VAR_2, !VAR_4 /* COMMENT_0 */);

	VAR_1->outstanding_txns++;
	binder_inner_proc_unlock(VAR_1);
	binder_node_unlock(VAR_3);

	/* COMMENT_1 */
                                                                     
                                     
    
	if (VAR_7) {
		struct binder_buffer *VAR_13 = VAR_7->buffer;

		VAR_7->buffer = NULL;
		VAR_13->transaction = NULL;
		trace_binder_transaction_update_buffer_release(VAR_13);
		binder_release_entire_buffer(VAR_1, NULL, VAR_13, false);
		binder_alloc_free_buf(&VAR_1->alloc, VAR_13);
		kfree(VAR_7);
		binder_stats_deleted(VAR_14);
	}

	return 0;
}",android/1ca1130ec62da7638497478539c0f55ffbbf9a5e/binder.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -77,7 +77,7 @@
 		t_outdated->buffer = NULL;
 		buffer->transaction = NULL;
 		trace_binder_transaction_update_buffer_release(buffer);
-		binder_transaction_buffer_release(proc, NULL, buffer, 0, 0);
+		binder_release_entire_buffer(proc, NULL, buffer, false);
 		binder_alloc_free_buf(&proc->alloc, buffer);
 		kfree(t_outdated);
 		binder_stats_deleted(BINDER_STAT_TRANSACTION);","{'deleted_lines': ['\t\tbinder_transaction_buffer_release(proc, NULL, buffer, 0, 0);'], 'added_lines': ['\t\tbinder_release_entire_buffer(proc, NULL, buffer, false);']}",True,"In multiple functions of binder.c, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.

",7.8,HIGH,2,test,,5
CVE-2023-21255,"['CWE-787', 'CWE-416']",CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,android,"FROMLIST: binder: fix UAF caused by faulty buffer cleanup

In binder_transaction_buffer_release() the 'failed_at' offset indicates
the number of objects to clean up. However, this function was changed by
commit 44d8047f1d87 (""binder: use standard functions to allocate fds""),
to release all the objects in the buffer when 'failed_at' is zero.

This introduced an issue when a transaction buffer is released without
any objects having been processed so far. In this case, 'failed_at' is
indeed zero yet it is misinterpreted as releasing the entire buffer.

This leads to use-after-free errors where nodes are incorrectly freed
and subsequently accessed. Such is the case in the following KASAN
report:

  ==================================================================
  BUG: KASAN: slab-use-after-free in binder_thread_read+0xc40/0x1f30
  Read of size 8 at addr ffff4faf037cfc58 by task poc/474

  CPU: 6 PID: 474 Comm: poc Not tainted 6.3.0-12570-g7df047b3f0aa #5
  Hardware name: linux,dummy-virt (DT)
  Call trace:
   dump_backtrace+0x94/0xec
   show_stack+0x18/0x24
   dump_stack_lvl+0x48/0x60
   print_report+0xf8/0x5b8
   kasan_report+0xb8/0xfc
   __asan_load8+0x9c/0xb8
   binder_thread_read+0xc40/0x1f30
   binder_ioctl+0xd9c/0x1768
   __arm64_sys_ioctl+0xd4/0x118
   invoke_syscall+0x60/0x188
  [...]

  Allocated by task 474:
   kasan_save_stack+0x3c/0x64
   kasan_set_track+0x2c/0x40
   kasan_save_alloc_info+0x24/0x34
   __kasan_kmalloc+0xb8/0xbc
   kmalloc_trace+0x48/0x5c
   binder_new_node+0x3c/0x3a4
   binder_transaction+0x2b58/0x36f0
   binder_thread_write+0x8e0/0x1b78
   binder_ioctl+0x14a0/0x1768
   __arm64_sys_ioctl+0xd4/0x118
   invoke_syscall+0x60/0x188
  [...]

  Freed by task 475:
   kasan_save_stack+0x3c/0x64
   kasan_set_track+0x2c/0x40
   kasan_save_free_info+0x38/0x5c
   __kasan_slab_free+0xe8/0x154
   __kmem_cache_free+0x128/0x2bc
   kfree+0x58/0x70
   binder_dec_node_tmpref+0x178/0x1fc
   binder_transaction_buffer_release+0x430/0x628
   binder_transaction+0x1954/0x36f0
   binder_thread_write+0x8e0/0x1b78
   binder_ioctl+0x14a0/0x1768
   __arm64_sys_ioctl+0xd4/0x118
   invoke_syscall+0x60/0x188
  [...]
  ==================================================================

In order to avoid these issues, let's always calculate the intended
'failed_at' offset beforehand. This is renamed and wrapped in a helper
function to make it clear and convenient.

Fixes: 32e9f56a96d8 (""binder: don't detect sender/target during buffer cleanup"")
Reported-by: Zi Fan Tan <zifantan@google.com>
Link: https://b.corp.google.com/issues/275041864
Cc: stable@vger.kernel.org
Signed-off-by: Carlos Llamas <cmllamas@google.com>

Bug: 275041864
Link: https://lore.kernel.org/all/20230505203020.4101154-1-cmllamas@google.com
Change-Id: I4bcc8bde77a8118872237d100cccb5caf95d99a1
Signed-off-by: Carlos Llamas <cmllamas@google.com>
",1ca1130ec62da7638497478539c0f55ffbbf9a5e,https://android.googlesource.com/kernel/common/+/1ca1130ec62d,drivers/android/binder.c,binder_transaction_buffer_release,"static void binder_transaction_buffer_release(struct binder_proc *proc,
struct binder_thread *thread,
struct binder_buffer *buffer,
binder_size_t failed_at,
bool is_failure)
{
int debug_id = buffer->debug_id;
binder_size_t off_start_offset, buffer_offset, off_end_offset;
binder_debug(BINDER_DEBUG_TRANSACTION,
""%d buffer release %d, size %zd-%zd, failed at %llx\n"",
proc->pid, buffer->debug_id,
buffer->data_size, buffer->offsets_size,
(unsigned long long)failed_at);
if (buffer->target_node)
binder_dec_node(buffer->target_node, 1, 0);
off_start_offset = ALIGN(buffer->data_size, sizeof(void *));
off_end_offset = is_failure && failed_at ? failed_at :
off_start_offset + buffer->offsets_size;
for (buffer_offset = off_start_offset; buffer_offset < off_end_offset;
buffer_offset += sizeof(binder_size_t)) {
struct binder_object_header *hdr;
size_t object_size = 0;
struct binder_object object;
binder_size_t object_offset;
if (!binder_alloc_copy_from_buffer(&proc->alloc, &object_offset,
buffer, buffer_offset,
sizeof(object_offset)))
object_size = binder_get_object(proc, NULL, buffer,
object_offset, &object);
if (object_size == 0) {
pr_err(""transaction release %d bad object at offset %lld, size %zd\n"",
debug_id, (u64)object_offset, buffer->data_size);
continue;
}
hdr = &object.hdr;
switch (hdr->type) {
case BINDER_TYPE_BINDER:
case BINDER_TYPE_WEAK_BINDER: {
struct flat_binder_object *fp;
struct binder_node *node;
fp = to_flat_binder_object(hdr);
node = binder_get_node(proc, fp->binder);
if (node == NULL) {
pr_err(""transaction release %d bad node %016llx\n"",
debug_id, (u64)fp->binder);
break;
}
binder_debug(BINDER_DEBUG_TRANSACTION,
""        node %d u%016llx\n"",
node->debug_id, (u64)node->ptr);
binder_dec_node(node, hdr->type == BINDER_TYPE_BINDER,
0);
binder_put_node(node);
} break;
case BINDER_TYPE_HANDLE:
case BINDER_TYPE_WEAK_HANDLE: {
struct flat_binder_object *fp;
struct binder_ref_data rdata;
int ret;
fp = to_flat_binder_object(hdr);
ret = binder_dec_ref_for_handle(proc, fp->handle,
hdr->type == BINDER_TYPE_HANDLE, &rdata);
if (ret) {
pr_err(""transaction release %d bad handle %d, ret = %d\n"",
debug_id, fp->handle, ret);
break;
}
binder_debug(BINDER_DEBUG_TRANSACTION,
""        ref %d desc %d\n"",
rdata.debug_id, rdata.desc);
} break;
case BINDER_TYPE_FD: {
} break;
case BINDER_TYPE_PTR:
break;
case BINDER_TYPE_FDA: {
struct binder_fd_array_object *fda;
struct binder_buffer_object *parent;
struct binder_object ptr_object;
binder_size_t fda_offset;
size_t fd_index;
binder_size_t fd_buf_size;
binder_size_t num_valid;
if (is_failure) {
continue;
}
num_valid = (buffer_offset - off_start_offset) /
sizeof(binder_size_t);
fda = to_binder_fd_array_object(hdr);
parent = binder_validate_ptr(proc, buffer, &ptr_object,
fda->parent,
off_start_offset,
NULL,
num_valid);
if (!parent) {
pr_err(""transaction release %d bad parent offset\n"",
debug_id);
continue;
}
fd_buf_size = sizeof(u32) * fda->num_fds;
if (fda->num_fds >= SIZE_MAX / sizeof(u32)) {
pr_err(""transaction release %d invalid number of fds (%lld)\n"",
debug_id, (u64)fda->num_fds);
continue;
}
if (fd_buf_size > parent->length ||
fda->parent_offset > parent->length - fd_buf_size) {
pr_err(""transaction release %d not enough space for %lld fds in buffer\n"",
debug_id, (u64)fda->num_fds);
continue;
}
fda_offset =
(parent->buffer - (uintptr_t)buffer->user_data) +
fda->parent_offset;
for (fd_index = 0; fd_index < fda->num_fds;
fd_index++) {
u32 fd;
int err;
binder_size_t offset = fda_offset +
fd_index * sizeof(fd);
err = binder_alloc_copy_from_buffer(
&proc->alloc, &fd, buffer,
offset, sizeof(fd));
WARN_ON(err);
if (!err) {
binder_deferred_fd_close(fd);
if (thread)
thread->looper_need_return = true;
}
}
} break;
default:
pr_err(""transaction release %d bad object type %x\n"",
debug_id, hdr->type);
break;
}
}
}","static void binder_transaction_buffer_release(struct binder_proc *VAR_0,
struct binder_thread *VAR_1,
struct binder_buffer *VAR_2,
binder_size_t VAR_3,
bool VAR_4)
{
int VAR_5 = VAR_2->debug_id;
binder_size_t VAR_6, VAR_7, VAR_8;
binder_debug(VAR_9,
""%d buffer release %d, size %zd-%zd, failed at %llx\n"",
VAR_0->pid, VAR_2->debug_id,
VAR_2->data_size, VAR_2->offsets_size,
(unsigned long long)VAR_3);
if (VAR_2->target_node)
binder_dec_node(VAR_2->target_node, 1, 0);
VAR_6 = ALIGN(VAR_2->data_size, sizeof(void *));
VAR_8 = VAR_4 && VAR_3 ? VAR_3 :
VAR_6 + VAR_2->offsets_size;
for (VAR_7 = VAR_6; VAR_7 < VAR_8;
VAR_7 += sizeof(binder_size_t)) {
struct binder_object_header *VAR_10;
size_t VAR_11 = 0;
struct binder_object VAR_12;
binder_size_t VAR_13;
if (!binder_alloc_copy_from_buffer(&VAR_0->alloc, &VAR_13,
VAR_2, VAR_7,
sizeof(VAR_13)))
VAR_11 = binder_get_object(VAR_0, NULL, VAR_2,
VAR_13, &VAR_12);
if (VAR_11 == 0) {
pr_err(""transaction release %d bad object at offset %lld, size %zd\n"",
VAR_5, (u64)VAR_13, VAR_2->data_size);
continue;
}
VAR_10 = &VAR_12.hdr;
switch (VAR_10->type) {
case VAR_14:
case VAR_15: {
struct flat_binder_object *VAR_16;
struct binder_node *VAR_17;
VAR_16 = to_flat_binder_object(VAR_10);
VAR_17 = binder_get_node(VAR_0, VAR_16->binder);
if (VAR_17 == NULL) {
pr_err(""transaction release %d bad node %016llx\n"",
VAR_5, (u64)VAR_16->binder);
break;
}
binder_debug(VAR_9,
""        node %d u%016llx\n"",
VAR_17->debug_id, (u64)VAR_17->ptr);
binder_dec_node(VAR_17, VAR_10->type == VAR_14,
0);
binder_put_node(VAR_17);
} break;
case VAR_18:
case VAR_19: {
struct flat_binder_object *VAR_16;
struct binder_ref_data VAR_20;
int VAR_21;
VAR_16 = to_flat_binder_object(VAR_10);
VAR_21 = binder_dec_ref_for_handle(VAR_0, VAR_16->handle,
VAR_10->type == VAR_18, &VAR_20);
if (VAR_21) {
pr_err(""transaction release %d bad handle %d, ret = %d\n"",
VAR_5, VAR_16->handle, VAR_21);
break;
}
binder_debug(VAR_9,
""        ref %d desc %d\n"",
VAR_20.debug_id, VAR_20.desc);
} break;
case VAR_22: {
} break;
case VAR_23:
break;
case VAR_24: {
struct binder_fd_array_object *VAR_25;
struct binder_buffer_object *VAR_26;
struct binder_object VAR_27;
binder_size_t VAR_28;
size_t VAR_29;
binder_size_t VAR_30;
binder_size_t VAR_31;
if (VAR_4) {
continue;
}
VAR_31 = (VAR_7 - VAR_6) /
sizeof(binder_size_t);
VAR_25 = to_binder_fd_array_object(VAR_10);
VAR_26 = binder_validate_ptr(VAR_0, VAR_2, &VAR_27,
VAR_25->parent,
VAR_6,
NULL,
VAR_31);
if (!VAR_26) {
pr_err(""transaction release %d bad parent offset\n"",
VAR_5);
continue;
}
VAR_30 = sizeof(VAR_32) * VAR_25->num_fds;
if (VAR_25->num_fds >= VAR_33 / sizeof(VAR_32)) {
pr_err(""transaction release %d invalid number of fds (%lld)\n"",
VAR_5, (u64)VAR_25->num_fds);
continue;
}
if (VAR_30 > VAR_26->length ||
VAR_25->parent_offset > VAR_26->length - VAR_30) {
pr_err(""transaction release %d not enough space for %lld fds in buffer\n"",
VAR_5, (u64)VAR_25->num_fds);
continue;
}
VAR_28 =
(VAR_26->buffer - (uintptr_t)VAR_2->user_data) +
VAR_25->parent_offset;
for (VAR_29 = 0; VAR_29 < VAR_25->num_fds;
VAR_29++) {
u32 VAR_34;
int VAR_35;
binder_size_t VAR_36 = VAR_28 +
VAR_29 * sizeof(VAR_34);
VAR_35 = binder_alloc_copy_from_buffer(
&VAR_0->alloc, &VAR_34, VAR_2,
VAR_36, sizeof(VAR_34));
WARN_ON(VAR_35);
if (!VAR_35) {
binder_deferred_fd_close(VAR_34);
if (VAR_1)
VAR_1->looper_need_return = true;
}
}
} break;
default:
pr_err(""transaction release %d bad object type %x\n"",
VAR_5, VAR_10->type);
break;
}
}
}",android/1ca1130ec62da7638497478539c0f55ffbbf9a5e/binder.c/vul/before/2.json,"static void binder_transaction_buffer_release(struct binder_proc *proc,
					      struct binder_thread *thread,
					      struct binder_buffer *buffer,
					      binder_size_t off_end_offset,
					      bool is_failure)
{
	int debug_id = buffer->debug_id;
	binder_size_t off_start_offset, buffer_offset;

	binder_debug(BINDER_DEBUG_TRANSACTION,
		     ""%d buffer release %d, size %zd-%zd, failed at %llx\n"",
		     proc->pid, buffer->debug_id,
		     buffer->data_size, buffer->offsets_size,
		     (unsigned long long)off_end_offset);

	if (buffer->target_node)
		binder_dec_node(buffer->target_node, 1, 0);

	off_start_offset = ALIGN(buffer->data_size, sizeof(void *));

	for (buffer_offset = off_start_offset; buffer_offset < off_end_offset;
	     buffer_offset += sizeof(binder_size_t)) {
		struct binder_object_header *hdr;
		size_t object_size = 0;
		struct binder_object object;
		binder_size_t object_offset;

		if (!binder_alloc_copy_from_buffer(&proc->alloc, &object_offset,
						   buffer, buffer_offset,
						   sizeof(object_offset)))
			object_size = binder_get_object(proc, NULL, buffer,
							object_offset, &object);
		if (object_size == 0) {
			pr_err(""transaction release %d bad object at offset %lld, size %zd\n"",
			       debug_id, (u64)object_offset, buffer->data_size);
			continue;
		}
		hdr = &object.hdr;
		switch (hdr->type) {
		case BINDER_TYPE_BINDER:
		case BINDER_TYPE_WEAK_BINDER: {
			struct flat_binder_object *fp;
			struct binder_node *node;

			fp = to_flat_binder_object(hdr);
			node = binder_get_node(proc, fp->binder);
			if (node == NULL) {
				pr_err(""transaction release %d bad node %016llx\n"",
				       debug_id, (u64)fp->binder);
				break;
			}
			binder_debug(BINDER_DEBUG_TRANSACTION,
				     ""        node %d u%016llx\n"",
				     node->debug_id, (u64)node->ptr);
			binder_dec_node(node, hdr->type == BINDER_TYPE_BINDER,
					0);
			binder_put_node(node);
		} break;
		case BINDER_TYPE_HANDLE:
		case BINDER_TYPE_WEAK_HANDLE: {
			struct flat_binder_object *fp;
			struct binder_ref_data rdata;
			int ret;

			fp = to_flat_binder_object(hdr);
			ret = binder_dec_ref_for_handle(proc, fp->handle,
				hdr->type == BINDER_TYPE_HANDLE, &rdata);

			if (ret) {
				pr_err(""transaction release %d bad handle %d, ret = %d\n"",
				 debug_id, fp->handle, ret);
				break;
			}
			binder_debug(BINDER_DEBUG_TRANSACTION,
				     ""        ref %d desc %d\n"",
				     rdata.debug_id, rdata.desc);
		} break;

		case BINDER_TYPE_FD: {
			/*
			 * No need to close the file here since user-space
			 * closes it for successfully delivered
			 * transactions. For transactions that weren't
			 * delivered, the new fd was never allocated so
			 * there is no need to close and the fput on the
			 * file is done when the transaction is torn
			 * down.
			 */
		} break;
		case BINDER_TYPE_PTR:
			/*
			 * Nothing to do here, this will get cleaned up when the
			 * transaction buffer gets freed
			 */
			break;
		case BINDER_TYPE_FDA: {
			struct binder_fd_array_object *fda;
			struct binder_buffer_object *parent;
			struct binder_object ptr_object;
			binder_size_t fda_offset;
			size_t fd_index;
			binder_size_t fd_buf_size;
			binder_size_t num_valid;

			if (is_failure) {
				/*
				 * The fd fixups have not been applied so no
				 * fds need to be closed.
				 */
				continue;
			}

			num_valid = (buffer_offset - off_start_offset) /
						sizeof(binder_size_t);
			fda = to_binder_fd_array_object(hdr);
			parent = binder_validate_ptr(proc, buffer, &ptr_object,
						     fda->parent,
						     off_start_offset,
						     NULL,
						     num_valid);
			if (!parent) {
				pr_err(""transaction release %d bad parent offset\n"",
				       debug_id);
				continue;
			}
			fd_buf_size = sizeof(u32) * fda->num_fds;
			if (fda->num_fds >= SIZE_MAX / sizeof(u32)) {
				pr_err(""transaction release %d invalid number of fds (%lld)\n"",
				       debug_id, (u64)fda->num_fds);
				continue;
			}
			if (fd_buf_size > parent->length ||
			    fda->parent_offset > parent->length - fd_buf_size) {
				/* No space for all file descriptors here. */
				pr_err(""transaction release %d not enough space for %lld fds in buffer\n"",
				       debug_id, (u64)fda->num_fds);
				continue;
			}
			/*
			 * the source data for binder_buffer_object is visible
			 * to user-space and the @buffer element is the user
			 * pointer to the buffer_object containing the fd_array.
			 * Convert the address to an offset relative to
			 * the base of the transaction buffer.
			 */
			fda_offset =
			    (parent->buffer - (uintptr_t)buffer->user_data) +
			    fda->parent_offset;
			for (fd_index = 0; fd_index < fda->num_fds;
			     fd_index++) {
				u32 fd;
				int err;
				binder_size_t offset = fda_offset +
					fd_index * sizeof(fd);

				err = binder_alloc_copy_from_buffer(
						&proc->alloc, &fd, buffer,
						offset, sizeof(fd));
				WARN_ON(err);
				if (!err) {
					binder_deferred_fd_close(fd);
					/*
					 * Need to make sure the thread goes
					 * back to userspace to complete the
					 * deferred close
					 */
					if (thread)
						thread->looper_need_return = true;
				}
			}
		} break;
		default:
			pr_err(""transaction release %d bad object type %x\n"",
				debug_id, hdr->type);
			break;
		}
	}
}","static void binder_transaction_buffer_release(struct binder_proc *VAR_0,
					      struct binder_thread *VAR_1,
					      struct binder_buffer *VAR_2,
					      binder_size_t VAR_3,
					      bool VAR_4)
{
	int VAR_5 = VAR_2->debug_id;
	binder_size_t VAR_6, VAR_7;

	binder_debug(VAR_8,
		     ""%d buffer release %d, size %zd-%zd, failed at %llx\n"",
		     VAR_0->pid, VAR_2->debug_id,
		     VAR_2->data_size, VAR_2->offsets_size,
		     (unsigned long long)VAR_3);

	if (VAR_2->target_node)
		binder_dec_node(VAR_2->target_node, 1, 0);

	VAR_6 = ALIGN(VAR_2->data_size, sizeof(void *));

	for (VAR_7 = VAR_6; VAR_7 < VAR_3;
	     VAR_7 += sizeof(binder_size_t)) {
		struct binder_object_header *VAR_9;
		size_t VAR_10 = 0;
		struct binder_object VAR_11;
		binder_size_t VAR_12;

		if (!binder_alloc_copy_from_buffer(&VAR_0->alloc, &VAR_12,
						   VAR_2, VAR_7,
						   sizeof(VAR_12)))
			VAR_10 = binder_get_object(VAR_0, NULL, VAR_2,
							VAR_12, &VAR_11);
		if (VAR_10 == 0) {
			pr_err(""transaction release %d bad object at offset %lld, size %zd\n"",
			       VAR_5, (u64)VAR_12, VAR_2->data_size);
			continue;
		}
		VAR_9 = &VAR_11.hdr;
		switch (VAR_9->type) {
		case VAR_13:
		case VAR_14: {
			struct flat_binder_object *VAR_15;
			struct binder_node *VAR_16;

			VAR_15 = to_flat_binder_object(VAR_9);
			VAR_16 = binder_get_node(VAR_0, VAR_15->binder);
			if (VAR_16 == NULL) {
				pr_err(""transaction release %d bad node %016llx\n"",
				       VAR_5, (u64)VAR_15->binder);
				break;
			}
			binder_debug(VAR_8,
				     ""        node %d u%016llx\n"",
				     VAR_16->debug_id, (u64)VAR_16->ptr);
			binder_dec_node(VAR_16, VAR_9->type == VAR_13,
					0);
			binder_put_node(VAR_16);
		} break;
		case VAR_17:
		case VAR_18: {
			struct flat_binder_object *VAR_15;
			struct binder_ref_data VAR_19;
			int VAR_20;

			VAR_15 = to_flat_binder_object(VAR_9);
			VAR_20 = binder_dec_ref_for_handle(VAR_0, VAR_15->handle,
				VAR_9->type == VAR_17, &VAR_19);

			if (VAR_20) {
				pr_err(""transaction release %d bad handle %d, ret = %d\n"",
				 VAR_5, VAR_15->handle, VAR_20);
				break;
			}
			binder_debug(VAR_8,
				     ""        ref %d desc %d\n"",
				     VAR_19.debug_id, VAR_19.desc);
		} break;

		case VAR_21: {
			/* COMMENT_0 */
                                                     
                                          
                                                 
                                                  
                                                   
                                               
           
      
		} break;
		case VAR_22:
			/* COMMENT_9 */
                                                           
                                   
      
			break;
		case VAR_23: {
			struct binder_fd_array_object *VAR_24;
			struct binder_buffer_object *VAR_25;
			struct binder_object VAR_26;
			binder_size_t VAR_27;
			size_t VAR_28;
			binder_size_t VAR_29;
			binder_size_t VAR_30;

			if (VAR_4) {
				/* COMMENT_13 */
                                                
                             
       
				continue;
			}

			VAR_30 = (VAR_7 - VAR_6) /
						sizeof(binder_size_t);
			VAR_24 = to_binder_fd_array_object(VAR_9);
			VAR_25 = binder_validate_ptr(VAR_0, VAR_2, &VAR_26,
						     VAR_24->parent,
						     VAR_6,
						     NULL,
						     VAR_30);
			if (!VAR_25) {
				pr_err(""transaction release %d bad parent offset\n"",
				       VAR_5);
				continue;
			}
			VAR_29 = sizeof(VAR_31) * VAR_24->num_fds;
			if (VAR_24->num_fds >= VAR_32 / sizeof(VAR_31)) {
				pr_err(""transaction release %d invalid number of fds (%lld)\n"",
				       VAR_5, (u64)VAR_24->num_fds);
				continue;
			}
			if (VAR_29 > VAR_25->length ||
			    VAR_24->parent_offset > VAR_25->length - VAR_29) {
				/* COMMENT_17 */
				pr_err(""transaction release %d not enough space for %lld fds in buffer\n"",
				       VAR_5, (u64)VAR_24->num_fds);
				continue;
			}
			/* COMMENT_18 */
                                                         
                                                       
                                                           
                                                  
                                         
      
			VAR_27 =
			    (VAR_25->buffer - (uintptr_t)VAR_2->user_data) +
			    VAR_24->parent_offset;
			for (VAR_28 = 0; VAR_28 < VAR_24->num_fds;
			     VAR_28++) {
				u32 VAR_33;
				int VAR_34;
				binder_size_t VAR_35 = VAR_27 +
					VAR_28 * sizeof(VAR_33);

				VAR_34 = binder_alloc_copy_from_buffer(
						&VAR_0->alloc, &VAR_33, VAR_2,
						VAR_35, sizeof(VAR_33));
				WARN_ON(VAR_34);
				if (!VAR_34) {
					binder_deferred_fd_close(VAR_33);
					/* COMMENT_25 */
                                         
                                         
                      
        
					if (VAR_1)
						VAR_1->looper_need_return = true;
				}
			}
		} break;
		default:
			pr_err(""transaction release %d bad object type %x\n"",
				VAR_5, VAR_9->type);
			break;
		}
	}
}",android/1ca1130ec62da7638497478539c0f55ffbbf9a5e/binder.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,24 +1,23 @@
 static void binder_transaction_buffer_release(struct binder_proc *proc,
 					      struct binder_thread *thread,
 					      struct binder_buffer *buffer,
-					      binder_size_t failed_at,
+					      binder_size_t off_end_offset,
 					      bool is_failure)
 {
 	int debug_id = buffer->debug_id;
-	binder_size_t off_start_offset, buffer_offset, off_end_offset;
+	binder_size_t off_start_offset, buffer_offset;
 
 	binder_debug(BINDER_DEBUG_TRANSACTION,
 		     ""%d buffer release %d, size %zd-%zd, failed at %llx\n"",
 		     proc->pid, buffer->debug_id,
 		     buffer->data_size, buffer->offsets_size,
-		     (unsigned long long)failed_at);
+		     (unsigned long long)off_end_offset);
 
 	if (buffer->target_node)
 		binder_dec_node(buffer->target_node, 1, 0);
 
 	off_start_offset = ALIGN(buffer->data_size, sizeof(void *));
-	off_end_offset = is_failure && failed_at ? failed_at :
-				off_start_offset + buffer->offsets_size;
+
 	for (buffer_offset = off_start_offset; buffer_offset < off_end_offset;
 	     buffer_offset += sizeof(binder_size_t)) {
 		struct binder_object_header *hdr;","{'deleted_lines': ['\t\t\t\t\t      binder_size_t failed_at,', '\tbinder_size_t off_start_offset, buffer_offset, off_end_offset;', '\t\t     (unsigned long long)failed_at);', '\toff_end_offset = is_failure && failed_at ? failed_at :', '\t\t\t\toff_start_offset + buffer->offsets_size;'], 'added_lines': ['\t\t\t\t\t      binder_size_t off_end_offset,', '\tbinder_size_t off_start_offset, buffer_offset;', '\t\t     (unsigned long long)off_end_offset);', '']}",True,"In multiple functions of binder.c, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.

",7.8,HIGH,2,test,,5
CVE-2023-38428,['CWE-125'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H,1,torvalds/linux,"The offset of UserName is related to the address of security
buffer. To ensure the validaty of UserName, we need to compare name_off
+ name_len with secbuf_len instead of auth_msg_len.

[   27.096243] ==================================================================
[   27.096890] BUG: KASAN: slab-out-of-bounds in smb_strndup_from_utf16+0x188/0x350
[   27.097609] Read of size 2 at addr ffff888005e3b542 by task kworker/0:0/7
...
[   27.099950] Call Trace:
[   27.100194]  <TASK>
[   27.100397]  dump_stack_lvl+0x33/0x50
[   27.100752]  print_report+0xcc/0x620
[   27.102305]  kasan_report+0xae/0xe0
[   27.103072]  kasan_check_range+0x35/0x1b0
[   27.103757]  smb_strndup_from_utf16+0x188/0x350
[   27.105474]  smb2_sess_setup+0xaf8/0x19c0
[   27.107935]  handle_ksmbd_work+0x274/0x810
[   27.108315]  process_one_work+0x419/0x760
[   27.108689]  worker_thread+0x2a2/0x6f0
[   27.109385]  kthread+0x160/0x190
[   27.110129]  ret_from_fork+0x1f/0x30
[   27.110454]  </TASK>

Cc: stable@vger.kernel.org
Signed-off-by: Chih-Yen Chang <cc85nod@gmail.com>
Acked-by: Namjae Jeon <linkinjeon@kernel.org>
Signed-off-by: Steve French <stfrench@microsoft.com>
",f0a96d1aafd8964e1f9955c830a3e5cb3c60a90f,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/fs/ksmbd?h=f0a96d1aafd8964e1f9955c830a3e5cb3c60a90f,fs/ksmbd/smb2pdu.c,session_user,"static struct ksmbd_user *session_user(struct ksmbd_conn *conn,
struct smb2_sess_setup_req *req)
{
struct authenticate_message *authblob;
struct ksmbd_user *user;
char *name;
unsigned int auth_msg_len, name_off, name_len, secbuf_len;
secbuf_len = le16_to_cpu(req->SecurityBufferLength);
if (secbuf_len < sizeof(struct authenticate_message)) {
ksmbd_debug(SMB, ""blob len %d too small\n"", secbuf_len);
return NULL;
}
authblob = user_authblob(conn, req);
name_off = le32_to_cpu(authblob->UserName.BufferOffset);
name_len = le16_to_cpu(authblob->UserName.Length);
auth_msg_len = le16_to_cpu(req->SecurityBufferOffset) + secbuf_len;
if (auth_msg_len < (u64)name_off + name_len)
return NULL;
name = smb_strndup_from_utf16((const char *)authblob + name_off,
name_len,
true,
conn->local_nls);
if (IS_ERR(name)) {
pr_err(""cannot allocate memory\n"");
return NULL;
}
ksmbd_debug(SMB, ""session setup request for user %s\n"", name);
user = ksmbd_login_user(name);
kfree(name);
return user;
}","static struct ksmbd_user *session_user(struct ksmbd_conn *VAR_0,
struct smb2_sess_setup_req *VAR_1)
{
struct authenticate_message *VAR_2;
struct ksmbd_user *VAR_3;
char *VAR_4;
unsigned int VAR_5, VAR_6, VAR_7, VAR_8;
VAR_8 = le16_to_cpu(VAR_1->SecurityBufferLength);
if (VAR_8 < sizeof(struct authenticate_message)) {
ksmbd_debug(VAR_9, ""blob len %d too small\n"", VAR_8);
return NULL;
}
VAR_2 = user_authblob(VAR_0, VAR_1);
VAR_6 = le32_to_cpu(VAR_2->UserName.BufferOffset);
VAR_7 = le16_to_cpu(VAR_2->UserName.Length);
VAR_5 = le16_to_cpu(VAR_1->SecurityBufferOffset) + VAR_8;
if (VAR_5 < (u64)VAR_6 + VAR_7)
return NULL;
VAR_4 = smb_strndup_from_utf16((const char *)VAR_2 + VAR_6,
VAR_7,
true,
VAR_0->local_nls);
if (IS_ERR(VAR_4)) {
pr_err(""cannot allocate memory\n"");
return NULL;
}
ksmbd_debug(VAR_9, ""session setup request for user %s\n"", VAR_4);
VAR_3 = ksmbd_login_user(VAR_4);
kfree(VAR_4);
return VAR_3;
}",torvalds/linux/f0a96d1aafd8964e1f9955c830a3e5cb3c60a90f/smb2pdu.c/vul/before/0.json,"static struct ksmbd_user *session_user(struct ksmbd_conn *conn,
				       struct smb2_sess_setup_req *req)
{
	struct authenticate_message *authblob;
	struct ksmbd_user *user;
	char *name;
	unsigned int name_off, name_len, secbuf_len;

	secbuf_len = le16_to_cpu(req->SecurityBufferLength);
	if (secbuf_len < sizeof(struct authenticate_message)) {
		ksmbd_debug(SMB, ""blob len %d too small\n"", secbuf_len);
		return NULL;
	}
	authblob = user_authblob(conn, req);
	name_off = le32_to_cpu(authblob->UserName.BufferOffset);
	name_len = le16_to_cpu(authblob->UserName.Length);

	if (secbuf_len < (u64)name_off + name_len)
		return NULL;

	name = smb_strndup_from_utf16((const char *)authblob + name_off,
				      name_len,
				      true,
				      conn->local_nls);
	if (IS_ERR(name)) {
		pr_err(""cannot allocate memory\n"");
		return NULL;
	}

	ksmbd_debug(SMB, ""session setup request for user %s\n"", name);
	user = ksmbd_login_user(name);
	kfree(name);
	return user;
}","static struct ksmbd_user *session_user(struct ksmbd_conn *VAR_0,
				       struct smb2_sess_setup_req *VAR_1)
{
	struct authenticate_message *VAR_2;
	struct ksmbd_user *VAR_3;
	char *VAR_4;
	unsigned int VAR_5, VAR_6, VAR_7;

	VAR_7 = le16_to_cpu(VAR_1->SecurityBufferLength);
	if (VAR_7 < sizeof(struct authenticate_message)) {
		ksmbd_debug(VAR_8, ""blob len %d too small\n"", VAR_7);
		return NULL;
	}
	VAR_2 = user_authblob(VAR_0, VAR_1);
	VAR_5 = le32_to_cpu(VAR_2->UserName.BufferOffset);
	VAR_6 = le16_to_cpu(VAR_2->UserName.Length);

	if (VAR_7 < (u64)VAR_5 + VAR_6)
		return NULL;

	VAR_4 = smb_strndup_from_utf16((const char *)VAR_2 + VAR_5,
				      VAR_6,
				      true,
				      VAR_0->local_nls);
	if (IS_ERR(VAR_4)) {
		pr_err(""cannot allocate memory\n"");
		return NULL;
	}

	ksmbd_debug(VAR_8, ""session setup request for user %s\n"", VAR_4);
	VAR_3 = ksmbd_login_user(VAR_4);
	kfree(VAR_4);
	return VAR_3;
}",torvalds/linux/f0a96d1aafd8964e1f9955c830a3e5cb3c60a90f/smb2pdu.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
 	struct authenticate_message *authblob;
 	struct ksmbd_user *user;
 	char *name;
-	unsigned int auth_msg_len, name_off, name_len, secbuf_len;
+	unsigned int name_off, name_len, secbuf_len;
 
 	secbuf_len = le16_to_cpu(req->SecurityBufferLength);
 	if (secbuf_len < sizeof(struct authenticate_message)) {
@@ -14,9 +14,8 @@
 	authblob = user_authblob(conn, req);
 	name_off = le32_to_cpu(authblob->UserName.BufferOffset);
 	name_len = le16_to_cpu(authblob->UserName.Length);
-	auth_msg_len = le16_to_cpu(req->SecurityBufferOffset) + secbuf_len;
 
-	if (auth_msg_len < (u64)name_off + name_len)
+	if (secbuf_len < (u64)name_off + name_len)
 		return NULL;
 
 	name = smb_strndup_from_utf16((const char *)authblob + name_off,","{'deleted_lines': ['\tunsigned int auth_msg_len, name_off, name_len, secbuf_len;', '\tauth_msg_len = le16_to_cpu(req->SecurityBufferOffset) + secbuf_len;', '\tif (auth_msg_len < (u64)name_off + name_len)'], 'added_lines': ['\tunsigned int name_off, name_len, secbuf_len;', '\tif (secbuf_len < (u64)name_off + name_len)']}",True,"An issue was discovered in the Linux kernel before 6.3.4. fs/ksmbd/smb2pdu.c in ksmbd does not properly check the UserName value because it does not consider the address of security buffer, leading to an out-of-bounds read.",9.1,CRITICAL,3,test,,5
CVE-2023-38432,['CWE-125'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H,1,torvalds/linux,"->StructureSize2 indicates command payload size. ksmbd should validate
this size with rfc1002 length before accessing it.
This patch remove unneeded check and add the validation for this.

[    8.912583] BUG: KASAN: slab-out-of-bounds in ksmbd_smb2_check_message+0x12a/0xc50
[    8.913051] Read of size 2 at addr ffff88800ac7d92c by task kworker/0:0/7
...
[    8.914967] Call Trace:
[    8.915126]  <TASK>
[    8.915267]  dump_stack_lvl+0x33/0x50
[    8.915506]  print_report+0xcc/0x620
[    8.916558]  kasan_report+0xae/0xe0
[    8.917080]  kasan_check_range+0x35/0x1b0
[    8.917334]  ksmbd_smb2_check_message+0x12a/0xc50
[    8.917935]  ksmbd_verify_smb_message+0xae/0xd0
[    8.918223]  handle_ksmbd_work+0x192/0x820
[    8.918478]  process_one_work+0x419/0x760
[    8.918727]  worker_thread+0x2a2/0x6f0
[    8.919222]  kthread+0x187/0x1d0
[    8.919723]  ret_from_fork+0x1f/0x30
[    8.919954]  </TASK>

Cc: stable@vger.kernel.org
Reported-by: Chih-Yen Chang <cc85nod@gmail.com>
Signed-off-by: Namjae Jeon <linkinjeon@kernel.org>
Signed-off-by: Steve French <stfrench@microsoft.com>
",2b9b8f3b68edb3d67d79962f02e26dbb5ae3808d,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/fs/smb/server?h=2b9b8f3b68edb3d67d79962f02e26dbb5ae3808d,fs/smb/server/smb2misc.c,ksmbd_smb2_check_message,"int ksmbd_smb2_check_message(struct ksmbd_work *work)
{
struct smb2_pdu *pdu = ksmbd_req_buf_next(work);
struct smb2_hdr *hdr = &pdu->hdr;
int command;
__u32 clc_len;  
__u32 len = get_rfc1002_len(work->request_buf);
if (le32_to_cpu(hdr->NextCommand) > 0)
len = le32_to_cpu(hdr->NextCommand);
else if (work->next_smb2_rcv_hdr_off)
len -= work->next_smb2_rcv_hdr_off;
if (check_smb2_hdr(hdr))
return 1;
if (hdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {
ksmbd_debug(SMB, ""Illegal structure size %u\n"",
le16_to_cpu(hdr->StructureSize));
return 1;
}
command = le16_to_cpu(hdr->Command);
if (command >= NUMBER_OF_SMB2_COMMANDS) {
ksmbd_debug(SMB, ""Illegal SMB2 command %d\n"", command);
return 1;
}
if (smb2_req_struct_sizes[command] != pdu->StructureSize2) {
if (command != SMB2_OPLOCK_BREAK_HE &&
(hdr->Status == 0 || pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2_LE)) {
ksmbd_debug(SMB,
""Illegal request size %u for command %d\n"",
le16_to_cpu(pdu->StructureSize2), command);
return 1;
} else if (command == SMB2_OPLOCK_BREAK_HE &&
hdr->Status == 0 &&
le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_20 &&
le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_21) {
ksmbd_debug(SMB,
""Illegal request size %d for oplock break\n"",
le16_to_cpu(pdu->StructureSize2));
return 1;
}
}
if (smb2_calc_size(hdr, &clc_len))
return 1;
if (len != clc_len) {
if (clc_len == len + 1)
goto validate_credit;
if (ALIGN(clc_len, 8) == len)
goto validate_credit;
if (command == SMB2_NEGOTIATE_HE)
goto validate_credit;
if (clc_len < len && (len - clc_len) <= 8)
goto validate_credit;
pr_err_ratelimited(
""cli req too short, len %d not %d. cmd:%d mid:%llu\n"",
len, clc_len, command,
le64_to_cpu(hdr->MessageId));
return 1;
}
validate_credit:
if ((work->conn->vals->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU) &&
smb2_validate_credit_charge(work->conn, hdr)) {
work->conn->ops->set_rsp_status(work, STATUS_INVALID_PARAMETER);
return 1;
}
return 0;
}","int ksmbd_smb2_check_message(struct ksmbd_work *VAR_0)
{
struct smb2_pdu *VAR_1 = ksmbd_req_buf_next(VAR_0);
struct smb2_hdr *VAR_2 = &VAR_1->hdr;
int VAR_3;
__u32 VAR_4;  
__u32 VAR_5 = get_rfc1002_len(VAR_0->request_buf);
if (le32_to_cpu(VAR_2->NextCommand) > 0)
VAR_5 = le32_to_cpu(VAR_2->NextCommand);
else if (VAR_0->next_smb2_rcv_hdr_off)
VAR_5 -= VAR_0->next_smb2_rcv_hdr_off;
if (check_smb2_hdr(VAR_2))
return 1;
if (VAR_2->StructureSize != VAR_6) {
ksmbd_debug(VAR_7, ""Illegal structure size %u\n"",
le16_to_cpu(VAR_2->StructureSize));
return 1;
}
VAR_3 = le16_to_cpu(VAR_2->Command);
if (VAR_3 >= VAR_8) {
ksmbd_debug(VAR_7, ""Illegal SMB2 command %d\n"", VAR_3);
return 1;
}
if (VAR_9[VAR_3] != VAR_1->StructureSize2) {
if (VAR_3 != VAR_10 &&
(VAR_2->Status == 0 || VAR_1->StructureSize2 != VAR_11)) {
ksmbd_debug(VAR_7,
""Illegal request size %u for command %d\n"",
le16_to_cpu(VAR_1->StructureSize2), VAR_3);
return 1;
} else if (VAR_3 == VAR_10 &&
VAR_2->Status == 0 &&
le16_to_cpu(VAR_1->StructureSize2) != VAR_12 &&
le16_to_cpu(VAR_1->StructureSize2) != VAR_13) {
ksmbd_debug(VAR_7,
""Illegal request size %d for oplock break\n"",
le16_to_cpu(VAR_1->StructureSize2));
return 1;
}
}
if (smb2_calc_size(VAR_2, &VAR_4))
return 1;
if (VAR_5 != VAR_4) {
if (VAR_4 == VAR_5 + 1)
goto validate_credit;
if (ALIGN(VAR_4, 8) == VAR_5)
goto validate_credit;
if (VAR_3 == VAR_14)
goto validate_credit;
if (VAR_4 < VAR_5 && (VAR_5 - VAR_4) <= 8)
goto validate_credit;
pr_err_ratelimited(
""cli req too short, len %d not %d. cmd:%d mid:%llu\n"",
VAR_5, VAR_4, VAR_3,
le64_to_cpu(VAR_2->MessageId));
return 1;
}
validate_credit:
if ((VAR_0->conn->vals->capabilities & VAR_15) &&
smb2_validate_credit_charge(VAR_0->conn, VAR_2)) {
VAR_0->conn->ops->set_rsp_status(VAR_0, VAR_16);
return 1;
}
return 0;
}",torvalds/linux/2b9b8f3b68edb3d67d79962f02e26dbb5ae3808d/smb2misc.c/vul/before/0.json,"int ksmbd_smb2_check_message(struct ksmbd_work *work)
{
	struct smb2_pdu *pdu = ksmbd_req_buf_next(work);
	struct smb2_hdr *hdr = &pdu->hdr;
	int command;
	__u32 clc_len;  /* calculated length */
	__u32 len = get_rfc1002_len(work->request_buf);
	__u32 req_struct_size;

	if (le32_to_cpu(hdr->NextCommand) > 0)
		len = le32_to_cpu(hdr->NextCommand);
	else if (work->next_smb2_rcv_hdr_off)
		len -= work->next_smb2_rcv_hdr_off;

	if (check_smb2_hdr(hdr))
		return 1;

	if (hdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {
		ksmbd_debug(SMB, ""Illegal structure size %u\n"",
			    le16_to_cpu(hdr->StructureSize));
		return 1;
	}

	command = le16_to_cpu(hdr->Command);
	if (command >= NUMBER_OF_SMB2_COMMANDS) {
		ksmbd_debug(SMB, ""Illegal SMB2 command %d\n"", command);
		return 1;
	}

	if (smb2_req_struct_sizes[command] != pdu->StructureSize2) {
		if (command == SMB2_OPLOCK_BREAK_HE &&
		    le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_20 &&
		    le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_21) {
			/* special case for SMB2.1 lease break message */
			ksmbd_debug(SMB,
				    ""Illegal request size %d for oplock break\n"",
				    le16_to_cpu(pdu->StructureSize2));
			return 1;
		}
	}

	req_struct_size = le16_to_cpu(pdu->StructureSize2) +
		__SMB2_HEADER_STRUCTURE_SIZE;
	if (command == SMB2_LOCK_HE)
		req_struct_size -= sizeof(struct smb2_lock_element);

	if (req_struct_size > len + 1)
		return 1;

	if (smb2_calc_size(hdr, &clc_len))
		return 1;

	if (len != clc_len) {
		/* client can return one byte more due to implied bcc[0] */
		if (clc_len == len + 1)
			goto validate_credit;

		/*
		 * Some windows servers (win2016) will pad also the final
		 * PDU in a compound to 8 bytes.
		 */
		if (ALIGN(clc_len, 8) == len)
			goto validate_credit;

		/*
		 * SMB2 NEGOTIATE request will be validated when message
		 * handling proceeds.
		 */
		if (command == SMB2_NEGOTIATE_HE)
			goto validate_credit;

		/*
		 * Allow a message that padded to 8byte boundary.
		 * Linux 4.19.217 with smb 3.0.2 are sometimes
		 * sending messages where the cls_len is exactly
		 * 8 bytes less than len.
		 */
		if (clc_len < len && (len - clc_len) <= 8)
			goto validate_credit;

		pr_err_ratelimited(
			    ""cli req too short, len %d not %d. cmd:%d mid:%llu\n"",
			    len, clc_len, command,
			    le64_to_cpu(hdr->MessageId));

		return 1;
	}

validate_credit:
	if ((work->conn->vals->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU) &&
	    smb2_validate_credit_charge(work->conn, hdr)) {
		work->conn->ops->set_rsp_status(work, STATUS_INVALID_PARAMETER);
		return 1;
	}

	return 0;
}","int ksmbd_smb2_check_message(struct ksmbd_work *VAR_0)
{
	struct smb2_pdu *VAR_1 = ksmbd_req_buf_next(VAR_0);
	struct smb2_hdr *VAR_2 = &VAR_1->hdr;
	int VAR_3;
	__u32 VAR_4;  /* COMMENT_0 */
	__u32 VAR_5 = get_rfc1002_len(VAR_0->request_buf);
	__u32 VAR_6;

	if (le32_to_cpu(VAR_2->NextCommand) > 0)
		VAR_5 = le32_to_cpu(VAR_2->NextCommand);
	else if (VAR_0->next_smb2_rcv_hdr_off)
		VAR_5 -= VAR_0->next_smb2_rcv_hdr_off;

	if (check_smb2_hdr(VAR_2))
		return 1;

	if (VAR_2->StructureSize != VAR_7) {
		ksmbd_debug(VAR_8, ""Illegal structure size %u\n"",
			    le16_to_cpu(VAR_2->StructureSize));
		return 1;
	}

	VAR_3 = le16_to_cpu(VAR_2->Command);
	if (VAR_3 >= VAR_9) {
		ksmbd_debug(VAR_8, ""Illegal SMB2 command %d\n"", VAR_3);
		return 1;
	}

	if (VAR_10[VAR_3] != VAR_1->StructureSize2) {
		if (VAR_3 == VAR_11 &&
		    le16_to_cpu(VAR_1->StructureSize2) != VAR_12 &&
		    le16_to_cpu(VAR_1->StructureSize2) != VAR_13) {
			/* COMMENT_1 */
			ksmbd_debug(VAR_8,
				    ""Illegal request size %d for oplock break\n"",
				    le16_to_cpu(VAR_1->StructureSize2));
			return 1;
		}
	}

	VAR_6 = le16_to_cpu(VAR_1->StructureSize2) +
		VAR_14;
	if (VAR_3 == VAR_15)
		VAR_6 -= sizeof(struct smb2_lock_element);

	if (VAR_6 > VAR_5 + 1)
		return 1;

	if (smb2_calc_size(VAR_2, &VAR_4))
		return 1;

	if (VAR_5 != VAR_4) {
		/* COMMENT_2 */
		if (VAR_4 == VAR_5 + 1)
			goto validate_credit;

		/* COMMENT_3 */
                                                           
                                  
     
		if (ALIGN(VAR_4, 8) == VAR_5)
			goto validate_credit;

		/* COMMENT_7 */
                                                          
                       
     
		if (VAR_3 == VAR_16)
			goto validate_credit;

		/* COMMENT_11 */
                                                   
                                                
                                                  
                           
     
		if (VAR_4 < VAR_5 && (VAR_5 - VAR_4) <= 8)
			goto validate_credit;

		pr_err_ratelimited(
			    ""cli req too short, len %d not %d. cmd:%d mid:%llu\n"",
			    VAR_5, VAR_4, VAR_3,
			    le64_to_cpu(VAR_2->MessageId));

		return 1;
	}

validate_credit:
	if ((VAR_0->conn->vals->capabilities & VAR_17) &&
	    smb2_validate_credit_charge(VAR_0->conn, VAR_2)) {
		VAR_0->conn->ops->set_rsp_status(VAR_0, VAR_18);
		return 1;
	}

	return 0;
}",torvalds/linux/2b9b8f3b68edb3d67d79962f02e26dbb5ae3808d/smb2misc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,6 +5,7 @@
 	int command;
 	__u32 clc_len;  /* calculated length */
 	__u32 len = get_rfc1002_len(work->request_buf);
+	__u32 req_struct_size;
 
 	if (le32_to_cpu(hdr->NextCommand) > 0)
 		len = le32_to_cpu(hdr->NextCommand);
@@ -27,17 +28,9 @@
 	}
 
 	if (smb2_req_struct_sizes[command] != pdu->StructureSize2) {
-		if (command != SMB2_OPLOCK_BREAK_HE &&
-		    (hdr->Status == 0 || pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2_LE)) {
-			/* error packets have 9 byte structure size */
-			ksmbd_debug(SMB,
-				    ""Illegal request size %u for command %d\n"",
-				    le16_to_cpu(pdu->StructureSize2), command);
-			return 1;
-		} else if (command == SMB2_OPLOCK_BREAK_HE &&
-			   hdr->Status == 0 &&
-			   le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_20 &&
-			   le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_21) {
+		if (command == SMB2_OPLOCK_BREAK_HE &&
+		    le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_20 &&
+		    le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_21) {
 			/* special case for SMB2.1 lease break message */
 			ksmbd_debug(SMB,
 				    ""Illegal request size %d for oplock break\n"",
@@ -45,6 +38,14 @@
 			return 1;
 		}
 	}
+
+	req_struct_size = le16_to_cpu(pdu->StructureSize2) +
+		__SMB2_HEADER_STRUCTURE_SIZE;
+	if (command == SMB2_LOCK_HE)
+		req_struct_size -= sizeof(struct smb2_lock_element);
+
+	if (req_struct_size > len + 1)
+		return 1;
 
 	if (smb2_calc_size(hdr, &clc_len))
 		return 1;","{'deleted_lines': ['\t\tif (command != SMB2_OPLOCK_BREAK_HE &&', '\t\t    (hdr->Status == 0 || pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2_LE)) {', '\t\t\t/* error packets have 9 byte structure size */', '\t\t\tksmbd_debug(SMB,', '\t\t\t\t    ""Illegal request size %u for command %d\\n"",', '\t\t\t\t    le16_to_cpu(pdu->StructureSize2), command);', '\t\t\treturn 1;', '\t\t} else if (command == SMB2_OPLOCK_BREAK_HE &&', '\t\t\t   hdr->Status == 0 &&', '\t\t\t   le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_20 &&', '\t\t\t   le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_21) {'], 'added_lines': ['\t__u32 req_struct_size;', '\t\tif (command == SMB2_OPLOCK_BREAK_HE &&', '\t\t    le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_20 &&', '\t\t    le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_21) {', '', '\treq_struct_size = le16_to_cpu(pdu->StructureSize2) +', '\t\t__SMB2_HEADER_STRUCTURE_SIZE;', '\tif (command == SMB2_LOCK_HE)', '\t\treq_struct_size -= sizeof(struct smb2_lock_element);', '', '\tif (req_struct_size > len + 1)', '\t\treturn 1;']}",True,"An issue was discovered in the Linux kernel before 6.3.10. fs/smb/server/smb2misc.c in ksmbd does not validate the relationship between the command payload size and the RFC1002 length specification, leading to an out-of-bounds read.",9.1,CRITICAL,3,test,,5
CVE-2023-0160,['CWE-667'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"When huang uses sched_switch tracepoint, the tracepoint
does only one thing in the mounted ebpf program, which
deletes the fixed elements in sockhash ([0])

It seems that elements in sockhash are rarely actively
deleted by users or ebpf program. Therefore, we do not
pay much attention to their deletion. Compared with hash
maps, sockhash only provides spin_lock_bh protection.
This causes it to appear to have self-locking behavior
in the interrupt context.

  [0]:https://lore.kernel.org/all/CABcoxUayum5oOqFMMqAeWuS8+EzojquSOSyDA3J_2omY=2EeAg@mail.gmail.com/

Reported-by: Hsin-Wei Hung <hsinweih@uci.edu>
Fixes: 604326b41a6f (""bpf, sockmap: convert to generic sk_msg interface"")
Signed-off-by: Xin Liu <liuxin350@huawei.com>
Acked-by: John Fastabend <john.fastabend@gmail.com>
Link: https://lore.kernel.org/r/20230406122622.109978-1-liuxin350@huawei.com
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
",ed17aa92dc56b6d8883e4b7a8f1c6fbf5ed6cd29,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=ed17aa92dc56,net/core/sock_map.c,__sock_map_delete,"static int __sock_map_delete(struct bpf_stab *stab, struct sock *sk_test,
struct sock **psk)
{
struct sock *sk;
int err = 0;
raw_spin_lock_bh(&stab->lock);
sk = *psk;
if (!sk_test || sk_test == sk)
sk = xchg(psk, NULL);
if (likely(sk))
sock_map_unref(sk, psk);
else
err = -EINVAL;
raw_spin_unlock_bh(&stab->lock);
return err;
}","static int __sock_map_delete(struct bpf_stab *VAR_0, struct sock *VAR_1,
struct sock **VAR_2)
{
struct sock *VAR_3;
int VAR_4 = 0;
raw_spin_lock_bh(&VAR_0->lock);
VAR_3 = *VAR_2;
if (!VAR_1 || VAR_1 == VAR_3)
VAR_3 = xchg(VAR_2, NULL);
if (likely(VAR_3))
sock_map_unref(VAR_3, VAR_2);
else
VAR_4 = -VAR_5;
raw_spin_unlock_bh(&VAR_0->lock);
return VAR_4;
}",torvalds/linux/ed17aa92dc56b6d8883e4b7a8f1c6fbf5ed6cd29/sock_map.c/vul/before/0.json,"static int __sock_map_delete(struct bpf_stab *stab, struct sock *sk_test,
			     struct sock **psk)
{
	struct sock *sk;
	int err = 0;
	unsigned long flags;

	raw_spin_lock_irqsave(&stab->lock, flags);
	sk = *psk;
	if (!sk_test || sk_test == sk)
		sk = xchg(psk, NULL);

	if (likely(sk))
		sock_map_unref(sk, psk);
	else
		err = -EINVAL;

	raw_spin_unlock_irqrestore(&stab->lock, flags);
	return err;
}","static int __sock_map_delete(struct bpf_stab *VAR_0, struct sock *VAR_1,
			     struct sock **VAR_2)
{
	struct sock *VAR_3;
	int VAR_4 = 0;
	unsigned long VAR_5;

	raw_spin_lock_irqsave(&VAR_0->lock, VAR_5);
	VAR_3 = *VAR_2;
	if (!VAR_1 || VAR_1 == VAR_3)
		VAR_3 = xchg(VAR_2, NULL);

	if (likely(VAR_3))
		sock_map_unref(VAR_3, VAR_2);
	else
		VAR_4 = -VAR_6;

	raw_spin_unlock_irqrestore(&VAR_0->lock, VAR_5);
	return VAR_4;
}",torvalds/linux/ed17aa92dc56b6d8883e4b7a8f1c6fbf5ed6cd29/sock_map.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,8 +3,9 @@
 {
 	struct sock *sk;
 	int err = 0;
+	unsigned long flags;
 
-	raw_spin_lock_bh(&stab->lock);
+	raw_spin_lock_irqsave(&stab->lock, flags);
 	sk = *psk;
 	if (!sk_test || sk_test == sk)
 		sk = xchg(psk, NULL);
@@ -14,6 +15,6 @@
 	else
 		err = -EINVAL;
 
-	raw_spin_unlock_bh(&stab->lock);
+	raw_spin_unlock_irqrestore(&stab->lock, flags);
 	return err;
 }","{'deleted_lines': ['\traw_spin_lock_bh(&stab->lock);', '\traw_spin_unlock_bh(&stab->lock);'], 'added_lines': ['\tunsigned long flags;', '\traw_spin_lock_irqsave(&stab->lock, flags);', '\traw_spin_unlock_irqrestore(&stab->lock, flags);']}",True,A deadlock flaw was found in the Linux kernels BPF subsystem. This flaw allows a local user to potentially crash the system.,4.7,MEDIUM,1,test,,5
CVE-2023-0160,['CWE-667'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"When huang uses sched_switch tracepoint, the tracepoint
does only one thing in the mounted ebpf program, which
deletes the fixed elements in sockhash ([0])

It seems that elements in sockhash are rarely actively
deleted by users or ebpf program. Therefore, we do not
pay much attention to their deletion. Compared with hash
maps, sockhash only provides spin_lock_bh protection.
This causes it to appear to have self-locking behavior
in the interrupt context.

  [0]:https://lore.kernel.org/all/CABcoxUayum5oOqFMMqAeWuS8+EzojquSOSyDA3J_2omY=2EeAg@mail.gmail.com/

Reported-by: Hsin-Wei Hung <hsinweih@uci.edu>
Fixes: 604326b41a6f (""bpf, sockmap: convert to generic sk_msg interface"")
Signed-off-by: Xin Liu <liuxin350@huawei.com>
Acked-by: John Fastabend <john.fastabend@gmail.com>
Link: https://lore.kernel.org/r/20230406122622.109978-1-liuxin350@huawei.com
Signed-off-by: Alexei Starovoitov <ast@kernel.org>
",ed17aa92dc56b6d8883e4b7a8f1c6fbf5ed6cd29,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=ed17aa92dc56,net/core/sock_map.c,sock_hash_delete_elem,"static long sock_hash_delete_elem(struct bpf_map *map, void *key)
{
struct bpf_shtab *htab = container_of(map, struct bpf_shtab, map);
u32 hash, key_size = map->key_size;
struct bpf_shtab_bucket *bucket;
struct bpf_shtab_elem *elem;
int ret = -ENOENT;
hash = sock_hash_bucket_hash(key, key_size);
bucket = sock_hash_select_bucket(htab, hash);
raw_spin_lock_bh(&bucket->lock);
elem = sock_hash_lookup_elem_raw(&bucket->head, hash, key, key_size);
if (elem) {
hlist_del_rcu(&elem->node);
sock_map_unref(elem->sk, elem);
sock_hash_free_elem(htab, elem);
ret = 0;
}
raw_spin_unlock_bh(&bucket->lock);
return ret;
}","static long sock_hash_delete_elem(struct bpf_map *VAR_0, void *VAR_1)
{
struct bpf_shtab *VAR_2 = container_of(VAR_0, struct bpf_shtab, VAR_0);
u32 VAR_3, VAR_4 = VAR_0->key_size;
struct bpf_shtab_bucket *VAR_5;
struct bpf_shtab_elem *VAR_6;
int VAR_7 = -VAR_8;
VAR_3 = sock_hash_bucket_hash(VAR_1, VAR_4);
VAR_5 = sock_hash_select_bucket(VAR_2, VAR_3);
raw_spin_lock_bh(&VAR_5->lock);
VAR_6 = sock_hash_lookup_elem_raw(&VAR_5->head, VAR_3, VAR_1, VAR_4);
if (VAR_6) {
hlist_del_rcu(&VAR_6->node);
sock_map_unref(VAR_6->sk, VAR_6);
sock_hash_free_elem(VAR_2, VAR_6);
VAR_7 = 0;
}
raw_spin_unlock_bh(&VAR_5->lock);
return VAR_7;
}",torvalds/linux/ed17aa92dc56b6d8883e4b7a8f1c6fbf5ed6cd29/sock_map.c/vul/before/1.json,"static long sock_hash_delete_elem(struct bpf_map *map, void *key)
{
	struct bpf_shtab *htab = container_of(map, struct bpf_shtab, map);
	u32 hash, key_size = map->key_size;
	struct bpf_shtab_bucket *bucket;
	struct bpf_shtab_elem *elem;
	int ret = -ENOENT;
	unsigned long flags;

	hash = sock_hash_bucket_hash(key, key_size);
	bucket = sock_hash_select_bucket(htab, hash);

	raw_spin_lock_irqsave(&bucket->lock, flags);
	elem = sock_hash_lookup_elem_raw(&bucket->head, hash, key, key_size);
	if (elem) {
		hlist_del_rcu(&elem->node);
		sock_map_unref(elem->sk, elem);
		sock_hash_free_elem(htab, elem);
		ret = 0;
	}
	raw_spin_unlock_irqrestore(&bucket->lock, flags);
	return ret;
}","static long sock_hash_delete_elem(struct bpf_map *VAR_0, void *VAR_1)
{
	struct bpf_shtab *VAR_2 = container_of(VAR_0, struct bpf_shtab, VAR_0);
	u32 VAR_3, VAR_4 = VAR_0->key_size;
	struct bpf_shtab_bucket *VAR_5;
	struct bpf_shtab_elem *VAR_6;
	int VAR_7 = -VAR_8;
	unsigned long VAR_9;

	VAR_3 = sock_hash_bucket_hash(VAR_1, VAR_4);
	VAR_5 = sock_hash_select_bucket(VAR_2, VAR_3);

	raw_spin_lock_irqsave(&VAR_5->lock, VAR_9);
	VAR_6 = sock_hash_lookup_elem_raw(&VAR_5->head, VAR_3, VAR_1, VAR_4);
	if (VAR_6) {
		hlist_del_rcu(&VAR_6->node);
		sock_map_unref(VAR_6->sk, VAR_6);
		sock_hash_free_elem(VAR_2, VAR_6);
		VAR_7 = 0;
	}
	raw_spin_unlock_irqrestore(&VAR_5->lock, VAR_9);
	return VAR_7;
}",torvalds/linux/ed17aa92dc56b6d8883e4b7a8f1c6fbf5ed6cd29/sock_map.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -5,11 +5,12 @@
 	struct bpf_shtab_bucket *bucket;
 	struct bpf_shtab_elem *elem;
 	int ret = -ENOENT;
+	unsigned long flags;
 
 	hash = sock_hash_bucket_hash(key, key_size);
 	bucket = sock_hash_select_bucket(htab, hash);
 
-	raw_spin_lock_bh(&bucket->lock);
+	raw_spin_lock_irqsave(&bucket->lock, flags);
 	elem = sock_hash_lookup_elem_raw(&bucket->head, hash, key, key_size);
 	if (elem) {
 		hlist_del_rcu(&elem->node);
@@ -17,6 +18,6 @@
 		sock_hash_free_elem(htab, elem);
 		ret = 0;
 	}
-	raw_spin_unlock_bh(&bucket->lock);
+	raw_spin_unlock_irqrestore(&bucket->lock, flags);
 	return ret;
 }","{'deleted_lines': ['\traw_spin_lock_bh(&bucket->lock);', '\traw_spin_unlock_bh(&bucket->lock);'], 'added_lines': ['\tunsigned long flags;', '\traw_spin_lock_irqsave(&bucket->lock, flags);', '\traw_spin_unlock_irqrestore(&bucket->lock, flags);']}",True,A deadlock flaw was found in the Linux kernels BPF subsystem. This flaw allows a local user to potentially crash the system.,4.7,MEDIUM,1,test,,5
CVE-2023-3609,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"In the event of a failure in tcf_change_indev(), u32_set_parms() will
immediately return without decrementing the recently incremented
reference counter.  If this happens enough times, the counter will
rollover and the reference freed, leading to a double free which can be
used to do 'bad things'.

In order to prevent this, move the point of possible failure above the
point where the reference counter is incremented.  Also save any
meaningful return values to be applied to the return data at the
appropriate point in time.

This issue was caught with KASAN.

Fixes: 705c7091262d (""net: sched: cls_u32: no need to call tcf_exts_change for newly allocated struct"")
Suggested-by: Eric Dumazet <edumazet@google.com>
Signed-off-by: Lee Jones <lee@kernel.org>
Reviewed-by: Eric Dumazet <edumazet@google.com>
Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
",04c55383fa5689357bcdd2c8036725a55ed632bc,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit?h=04c55383fa5689357bcdd2c8036725a55ed632bc,net/sched/cls_u32.c,u32_set_parms,"static int u32_set_parms(struct net *net, struct tcf_proto *tp,
unsigned long base,
struct tc_u_knode *n, struct nlattr **tb,
struct nlattr *est, u32 flags, u32 fl_flags,
struct netlink_ext_ack *extack)
{
int err;
err = tcf_exts_validate_ex(net, tp, tb, est, &n->exts, flags,
fl_flags, extack);
if (err < 0)
return err;
if (tb[TCA_U32_LINK]) {
u32 handle = nla_get_u32(tb[TCA_U32_LINK]);
struct tc_u_hnode *ht_down = NULL, *ht_old;
if (TC_U32_KEY(handle)) {
NL_SET_ERR_MSG_MOD(extack, ""u32 Link handle must be a hash table"");
return -EINVAL;
}
if (handle) {
ht_down = u32_lookup_ht(tp->data, handle);
if (!ht_down) {
NL_SET_ERR_MSG_MOD(extack, ""Link hash table not found"");
return -EINVAL;
}
if (ht_down->is_root) {
NL_SET_ERR_MSG_MOD(extack, ""Not linking to root node"");
return -EINVAL;
}
ht_down->refcnt++;
}
ht_old = rtnl_dereference(n->ht_down);
rcu_assign_pointer(n->ht_down, ht_down);
if (ht_old)
ht_old->refcnt--;
}
if (tb[TCA_U32_CLASSID]) {
n->res.classid = nla_get_u32(tb[TCA_U32_CLASSID]);
tcf_bind_filter(tp, &n->res, base);
}
if (tb[TCA_U32_INDEV]) {
int ret;
ret = tcf_change_indev(net, tb[TCA_U32_INDEV], extack);
if (ret < 0)
return -EINVAL;
n->ifindex = ret;
}
return 0;
}","static int u32_set_parms(struct net *net, struct tcf_proto *VAR_0,
unsigned long VAR_1,
struct tc_u_knode *VAR_2, struct nlattr **VAR_3,
struct nlattr *VAR_4, u32 VAR_5, u32 VAR_6,
struct netlink_ext_ack *VAR_7)
{
int VAR_8;
VAR_8 = tcf_exts_validate_ex(net, VAR_0, VAR_3, VAR_4, &VAR_2->exts, VAR_5,
VAR_6, VAR_7);
if (VAR_8 < 0)
return VAR_8;
if (VAR_3[VAR_9]) {
u32 VAR_10 = nla_get_u32(VAR_3[VAR_9]);
struct tc_u_hnode *VAR_11 = NULL, *VAR_12;
if (TC_U32_KEY(VAR_10)) {
NL_SET_ERR_MSG_MOD(VAR_7, ""u32 Link handle must be a hash table"");
return -VAR_13;
}
if (VAR_10) {
VAR_11 = u32_lookup_ht(VAR_0->data, VAR_10);
if (!VAR_11) {
NL_SET_ERR_MSG_MOD(VAR_7, ""Link hash table not found"");
return -VAR_13;
}
if (VAR_11->is_root) {
NL_SET_ERR_MSG_MOD(VAR_7, ""Not linking to root node"");
return -VAR_13;
}
VAR_11->refcnt++;
}
VAR_12 = rtnl_dereference(VAR_2->ht_down);
rcu_assign_pointer(VAR_2->ht_down, VAR_11);
if (VAR_12)
VAR_12->refcnt--;
}
if (VAR_3[VAR_14]) {
VAR_2->res.classid = nla_get_u32(VAR_3[VAR_14]);
tcf_bind_filter(VAR_0, &VAR_2->res, VAR_1);
}
if (VAR_3[VAR_15]) {
int VAR_16;
VAR_16 = tcf_change_indev(net, VAR_3[VAR_15], VAR_7);
if (VAR_16 < 0)
return -VAR_13;
VAR_2->ifindex = VAR_16;
}
return 0;
}",torvalds/linux/04c55383fa5689357bcdd2c8036725a55ed632bc/cls_u32.c/vul/before/0.json,"static int u32_set_parms(struct net *net, struct tcf_proto *tp,
			 unsigned long base,
			 struct tc_u_knode *n, struct nlattr **tb,
			 struct nlattr *est, u32 flags, u32 fl_flags,
			 struct netlink_ext_ack *extack)
{
	int err, ifindex = -1;

	err = tcf_exts_validate_ex(net, tp, tb, est, &n->exts, flags,
				   fl_flags, extack);
	if (err < 0)
		return err;

	if (tb[TCA_U32_INDEV]) {
		ifindex = tcf_change_indev(net, tb[TCA_U32_INDEV], extack);
		if (ifindex < 0)
			return -EINVAL;
	}

	if (tb[TCA_U32_LINK]) {
		u32 handle = nla_get_u32(tb[TCA_U32_LINK]);
		struct tc_u_hnode *ht_down = NULL, *ht_old;

		if (TC_U32_KEY(handle)) {
			NL_SET_ERR_MSG_MOD(extack, ""u32 Link handle must be a hash table"");
			return -EINVAL;
		}

		if (handle) {
			ht_down = u32_lookup_ht(tp->data, handle);

			if (!ht_down) {
				NL_SET_ERR_MSG_MOD(extack, ""Link hash table not found"");
				return -EINVAL;
			}
			if (ht_down->is_root) {
				NL_SET_ERR_MSG_MOD(extack, ""Not linking to root node"");
				return -EINVAL;
			}
			ht_down->refcnt++;
		}

		ht_old = rtnl_dereference(n->ht_down);
		rcu_assign_pointer(n->ht_down, ht_down);

		if (ht_old)
			ht_old->refcnt--;
	}
	if (tb[TCA_U32_CLASSID]) {
		n->res.classid = nla_get_u32(tb[TCA_U32_CLASSID]);
		tcf_bind_filter(tp, &n->res, base);
	}

	if (ifindex >= 0)
		n->ifindex = ifindex;

	return 0;
}","static int u32_set_parms(struct net *net, struct tcf_proto *VAR_0,
			 unsigned long VAR_1,
			 struct tc_u_knode *VAR_2, struct nlattr **VAR_3,
			 struct nlattr *VAR_4, u32 VAR_5, u32 VAR_6,
			 struct netlink_ext_ack *VAR_7)
{
	int VAR_8, VAR_9 = -1;

	VAR_8 = tcf_exts_validate_ex(net, VAR_0, VAR_3, VAR_4, &VAR_2->exts, VAR_5,
				   VAR_6, VAR_7);
	if (VAR_8 < 0)
		return VAR_8;

	if (VAR_3[VAR_10]) {
		VAR_9 = tcf_change_indev(net, VAR_3[VAR_10], VAR_7);
		if (VAR_9 < 0)
			return -VAR_11;
	}

	if (VAR_3[VAR_12]) {
		u32 VAR_13 = nla_get_u32(VAR_3[VAR_12]);
		struct tc_u_hnode *VAR_14 = NULL, *VAR_15;

		if (TC_U32_KEY(VAR_13)) {
			NL_SET_ERR_MSG_MOD(VAR_7, ""u32 Link handle must be a hash table"");
			return -VAR_11;
		}

		if (VAR_13) {
			VAR_14 = u32_lookup_ht(VAR_0->data, VAR_13);

			if (!VAR_14) {
				NL_SET_ERR_MSG_MOD(VAR_7, ""Link hash table not found"");
				return -VAR_11;
			}
			if (VAR_14->is_root) {
				NL_SET_ERR_MSG_MOD(VAR_7, ""Not linking to root node"");
				return -VAR_11;
			}
			VAR_14->refcnt++;
		}

		VAR_15 = rtnl_dereference(VAR_2->ht_down);
		rcu_assign_pointer(VAR_2->ht_down, VAR_14);

		if (VAR_15)
			VAR_15->refcnt--;
	}
	if (VAR_3[VAR_16]) {
		VAR_2->res.classid = nla_get_u32(VAR_3[VAR_16]);
		tcf_bind_filter(VAR_0, &VAR_2->res, VAR_1);
	}

	if (VAR_9 >= 0)
		VAR_2->ifindex = VAR_9;

	return 0;
}",torvalds/linux/04c55383fa5689357bcdd2c8036725a55ed632bc/cls_u32.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,12 +4,18 @@
 			 struct nlattr *est, u32 flags, u32 fl_flags,
 			 struct netlink_ext_ack *extack)
 {
-	int err;
+	int err, ifindex = -1;
 
 	err = tcf_exts_validate_ex(net, tp, tb, est, &n->exts, flags,
 				   fl_flags, extack);
 	if (err < 0)
 		return err;
+
+	if (tb[TCA_U32_INDEV]) {
+		ifindex = tcf_change_indev(net, tb[TCA_U32_INDEV], extack);
+		if (ifindex < 0)
+			return -EINVAL;
+	}
 
 	if (tb[TCA_U32_LINK]) {
 		u32 handle = nla_get_u32(tb[TCA_U32_LINK]);
@@ -45,12 +51,8 @@
 		tcf_bind_filter(tp, &n->res, base);
 	}
 
-	if (tb[TCA_U32_INDEV]) {
-		int ret;
-		ret = tcf_change_indev(net, tb[TCA_U32_INDEV], extack);
-		if (ret < 0)
-			return -EINVAL;
-		n->ifindex = ret;
-	}
+	if (ifindex >= 0)
+		n->ifindex = ifindex;
+
 	return 0;
 }","{'deleted_lines': ['\tint err;', '\tif (tb[TCA_U32_INDEV]) {', '\t\tint ret;', '\t\tret = tcf_change_indev(net, tb[TCA_U32_INDEV], extack);', '\t\tif (ret < 0)', '\t\t\treturn -EINVAL;', '\t\tn->ifindex = ret;', '\t}'], 'added_lines': ['\tint err, ifindex = -1;', '', '\tif (tb[TCA_U32_INDEV]) {', '\t\tifindex = tcf_change_indev(net, tb[TCA_U32_INDEV], extack);', '\t\tif (ifindex < 0)', '\t\t\treturn -EINVAL;', '\t}', '\tif (ifindex >= 0)', '\t\tn->ifindex = ifindex;', '']}",True,"A use-after-free vulnerability in the Linux kernel's net/sched: cls_u32 component can be exploited to achieve local privilege escalation.

If tcf_change_indev() fails, u32_set_parms() will immediately return an error after incrementing or decrementing the reference counter in tcf_bind_filter(). If an attacker can control the reference counter and set it to zero, they can cause the reference to be freed, leading to a use-after-free vulnerability.

We recommend upgrading past commit 04c55383fa5689357bcdd2c8036725a55ed632bc.

",7.8,HIGH,2,test,,5
CVE-2023-3817,['CWE-834'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L,1,openssl,"
DH_check(): Do not try checking q properties if it is obviously invalid

If  |q| >= |p| then the q value is obviously wrong as q
is supposed to be a prime divisor of p-1.

We check if p is overly large so this added test implies that
q is not large either when performing subsequent tests using that
q value.

Otherwise if it is too large these additional checks of the q value
such as the primality test can then trigger DoS by doing overly long
computations.

Fixes CVE-2023-3817

Reviewed-by: Matt Caswell <matt@openssl.org>
Reviewed-by: Paul Dale <pauli@openssl.org>
Reviewed-by: Tom Cosgrove <tom.cosgrove@arm.com>
Reviewed-by: Todd Short <todd.short@me.com>
(Merged from https://github.com/openssl/openssl/pull/21550)

(cherry picked from commit 1c16253f3c3a8d1e25918c3f404aae6a5b0893de)
(cherry picked from commit 6a1eb62c29db6cb5eec707f9338aee00f44e26f5)
",9002fd07327a91f35ba6c1307e71fa6fd4409b7f,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=9002fd07327a91f35ba6c1307e71fa6fd4409b7f,crypto/dh/dh_check.c,DH_check,"int DH_check(const DH *dh, int *ret)
{
#ifdef FIPS_MODULE
return DH_check_params(dh, ret);
#else
int ok = 0, r;
BN_CTX *ctx = NULL;
BIGNUM *t1 = NULL, *t2 = NULL;
int nid = DH_get_nid((DH *)dh);
*ret = 0;
if (nid != NID_undef)
return 1;
if (BN_num_bits(dh->params.p) > OPENSSL_DH_CHECK_MAX_MODULUS_BITS) {
ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);
*ret = DH_MODULUS_TOO_LARGE | DH_CHECK_P_NOT_PRIME;
return 0;
}
if (!DH_check_params(dh, ret))
return 0;
ctx = BN_CTX_new_ex(dh->libctx);
if (ctx == NULL)
goto err;
BN_CTX_start(ctx);
t1 = BN_CTX_get(ctx);
t2 = BN_CTX_get(ctx);
if (t2 == NULL)
goto err;
if (dh->params.q != NULL) {
if (BN_cmp(dh->params.g, BN_value_one()) <= 0)
*ret |= DH_NOT_SUITABLE_GENERATOR;
else if (BN_cmp(dh->params.g, dh->params.p) >= 0)
*ret |= DH_NOT_SUITABLE_GENERATOR;
else {
if (!BN_mod_exp(t1, dh->params.g, dh->params.q, dh->params.p, ctx))
goto err;
if (!BN_is_one(t1))
*ret |= DH_NOT_SUITABLE_GENERATOR;
}
r = BN_check_prime(dh->params.q, ctx, NULL);
if (r < 0)
goto err;
if (!r)
*ret |= DH_CHECK_Q_NOT_PRIME;
if (!BN_div(t1, t2, dh->params.p, dh->params.q, ctx))
goto err;
if (!BN_is_one(t2))
*ret |= DH_CHECK_INVALID_Q_VALUE;
if (dh->params.j != NULL
&& BN_cmp(dh->params.j, t1))
*ret |= DH_CHECK_INVALID_J_VALUE;
}
r = BN_check_prime(dh->params.p, ctx, NULL);
if (r < 0)
goto err;
if (!r)
*ret |= DH_CHECK_P_NOT_PRIME;
else if (dh->params.q == NULL) {
if (!BN_rshift1(t1, dh->params.p))
goto err;
r = BN_check_prime(t1, ctx, NULL);
if (r < 0)
goto err;
if (!r)
*ret |= DH_CHECK_P_NOT_SAFE_PRIME;
}
ok = 1;
err:
BN_CTX_end(ctx);
BN_CTX_free(ctx);
return ok;
#endif 
}","int DH_check(const DH *VAR_0, int *VAR_1)
{
#ifdef VAR_2
return DH_check_params(VAR_0, VAR_1);
#else
int VAR_3 = 0, VAR_4;
BN_CTX *VAR_5 = NULL;
BIGNUM *VAR_6 = NULL, *VAR_7 = NULL;
int VAR_8 = DH_get_nid((DH *)VAR_0);
*VAR_1 = 0;
if (VAR_8 != VAR_9)
return 1;
if (BN_num_bits(VAR_0->params.p) > VAR_10) {
ERR_raise(VAR_11, VAR_12);
*VAR_1 = VAR_13 | VAR_14;
return 0;
}
if (!DH_check_params(VAR_0, VAR_1))
return 0;
VAR_5 = BN_CTX_new_ex(VAR_0->libctx);
if (VAR_5 == NULL)
goto err;
BN_CTX_start(VAR_5);
VAR_6 = BN_CTX_get(VAR_5);
VAR_7 = BN_CTX_get(VAR_5);
if (VAR_7 == NULL)
goto err;
if (VAR_0->params.q != NULL) {
if (BN_cmp(VAR_0->params.g, BN_value_one()) <= 0)
*VAR_1 |= VAR_15;
else if (BN_cmp(VAR_0->params.g, VAR_0->params.p) >= 0)
*VAR_1 |= VAR_15;
else {
if (!BN_mod_exp(VAR_6, VAR_0->params.g, VAR_0->params.q, VAR_0->params.p, VAR_5))
goto err;
if (!BN_is_one(VAR_6))
*VAR_1 |= VAR_15;
}
VAR_4 = BN_check_prime(VAR_0->params.q, VAR_5, NULL);
if (VAR_4 < 0)
goto err;
if (!VAR_4)
*VAR_1 |= VAR_16;
if (!BN_div(VAR_6, VAR_7, VAR_0->params.p, VAR_0->params.q, VAR_5))
goto err;
if (!BN_is_one(VAR_7))
*VAR_1 |= VAR_17;
if (VAR_0->params.j != NULL
&& BN_cmp(VAR_0->params.j, VAR_6))
*VAR_1 |= VAR_18;
}
VAR_4 = BN_check_prime(VAR_0->params.p, VAR_5, NULL);
if (VAR_4 < 0)
goto err;
if (!VAR_4)
*VAR_1 |= VAR_14;
else if (VAR_0->params.q == NULL) {
if (!BN_rshift1(VAR_6, VAR_0->params.p))
goto err;
VAR_4 = BN_check_prime(VAR_6, VAR_5, NULL);
if (VAR_4 < 0)
goto err;
if (!VAR_4)
*VAR_1 |= VAR_19;
}
VAR_3 = 1;
err:
BN_CTX_end(VAR_5);
BN_CTX_free(VAR_5);
return VAR_3;
#endif 
}",openssl/9002fd07327a91f35ba6c1307e71fa6fd4409b7f/dh_check.c/vul/before/0.json,"int DH_check(const DH *dh, int *ret)
{
#ifdef FIPS_MODULE
    return DH_check_params(dh, ret);
#else
    int ok = 0, r, q_good = 0;
    BN_CTX *ctx = NULL;
    BIGNUM *t1 = NULL, *t2 = NULL;
    int nid = DH_get_nid((DH *)dh);

    *ret = 0;
    if (nid != NID_undef)
        return 1;

    /* Don't do any checks at all with an excessively large modulus */
    if (BN_num_bits(dh->params.p) > OPENSSL_DH_CHECK_MAX_MODULUS_BITS) {
        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);
        *ret = DH_MODULUS_TOO_LARGE | DH_CHECK_P_NOT_PRIME;
        return 0;
    }

    if (!DH_check_params(dh, ret))
        return 0;

    ctx = BN_CTX_new_ex(dh->libctx);
    if (ctx == NULL)
        goto err;
    BN_CTX_start(ctx);
    t1 = BN_CTX_get(ctx);
    t2 = BN_CTX_get(ctx);
    if (t2 == NULL)
        goto err;

    if (dh->params.q != NULL) {
        if (BN_ucmp(dh->params.p, dh->params.q) > 0)
            q_good = 1;
        else
            *ret |= DH_CHECK_INVALID_Q_VALUE;
    }

    if (q_good) {
        if (BN_cmp(dh->params.g, BN_value_one()) <= 0)
            *ret |= DH_NOT_SUITABLE_GENERATOR;
        else if (BN_cmp(dh->params.g, dh->params.p) >= 0)
            *ret |= DH_NOT_SUITABLE_GENERATOR;
        else {
            /* Check g^q == 1 mod p */
            if (!BN_mod_exp(t1, dh->params.g, dh->params.q, dh->params.p, ctx))
                goto err;
            if (!BN_is_one(t1))
                *ret |= DH_NOT_SUITABLE_GENERATOR;
        }
        r = BN_check_prime(dh->params.q, ctx, NULL);
        if (r < 0)
            goto err;
        if (!r)
            *ret |= DH_CHECK_Q_NOT_PRIME;
        /* Check p == 1 mod q  i.e. q divides p - 1 */
        if (!BN_div(t1, t2, dh->params.p, dh->params.q, ctx))
            goto err;
        if (!BN_is_one(t2))
            *ret |= DH_CHECK_INVALID_Q_VALUE;
        if (dh->params.j != NULL
            && BN_cmp(dh->params.j, t1))
            *ret |= DH_CHECK_INVALID_J_VALUE;
    }

    r = BN_check_prime(dh->params.p, ctx, NULL);
    if (r < 0)
        goto err;
    if (!r)
        *ret |= DH_CHECK_P_NOT_PRIME;
    else if (dh->params.q == NULL) {
        if (!BN_rshift1(t1, dh->params.p))
            goto err;
        r = BN_check_prime(t1, ctx, NULL);
        if (r < 0)
            goto err;
        if (!r)
            *ret |= DH_CHECK_P_NOT_SAFE_PRIME;
    }
    ok = 1;
 err:
    BN_CTX_end(ctx);
    BN_CTX_free(ctx);
    return ok;
#endif /* FIPS_MODULE */
}","int DH_check(const DH *VAR_0, int *VAR_1)
{
#ifdef VAR_2
    return DH_check_params(VAR_0, VAR_1);
#else
    int VAR_3 = 0, VAR_4, VAR_5 = 0;
    BN_CTX *VAR_6 = NULL;
    BIGNUM *VAR_7 = NULL, *VAR_8 = NULL;
    int VAR_9 = DH_get_nid((DH *)VAR_0);

    *VAR_1 = 0;
    if (VAR_9 != VAR_10)
        return 1;

    /* COMMENT_0 */
    if (BN_num_bits(VAR_0->params.p) > VAR_11) {
        ERR_raise(VAR_12, VAR_13);
        *VAR_1 = VAR_14 | VAR_15;
        return 0;
    }

    if (!DH_check_params(VAR_0, VAR_1))
        return 0;

    VAR_6 = BN_CTX_new_ex(VAR_0->libctx);
    if (VAR_6 == NULL)
        goto err;
    BN_CTX_start(VAR_6);
    VAR_7 = BN_CTX_get(VAR_6);
    VAR_8 = BN_CTX_get(VAR_6);
    if (VAR_8 == NULL)
        goto err;

    if (VAR_0->params.q != NULL) {
        if (BN_ucmp(VAR_0->params.p, VAR_0->params.q) > 0)
            VAR_5 = 1;
        else
            *VAR_1 |= VAR_16;
    }

    if (VAR_5) {
        if (BN_cmp(VAR_0->params.g, BN_value_one()) <= 0)
            *VAR_1 |= VAR_17;
        else if (BN_cmp(VAR_0->params.g, VAR_0->params.p) >= 0)
            *VAR_1 |= VAR_17;
        else {
            /* COMMENT_1 */
            if (!BN_mod_exp(VAR_7, VAR_0->params.g, VAR_0->params.q, VAR_0->params.p, VAR_6))
                goto err;
            if (!BN_is_one(VAR_7))
                *VAR_1 |= VAR_17;
        }
        VAR_4 = BN_check_prime(VAR_0->params.q, VAR_6, NULL);
        if (VAR_4 < 0)
            goto err;
        if (!VAR_4)
            *VAR_1 |= VAR_18;
        /* COMMENT_2 */
        if (!BN_div(VAR_7, VAR_8, VAR_0->params.p, VAR_0->params.q, VAR_6))
            goto err;
        if (!BN_is_one(VAR_8))
            *VAR_1 |= VAR_16;
        if (VAR_0->params.j != NULL
            && BN_cmp(VAR_0->params.j, VAR_7))
            *VAR_1 |= VAR_19;
    }

    VAR_4 = BN_check_prime(VAR_0->params.p, VAR_6, NULL);
    if (VAR_4 < 0)
        goto err;
    if (!VAR_4)
        *VAR_1 |= VAR_15;
    else if (VAR_0->params.q == NULL) {
        if (!BN_rshift1(VAR_7, VAR_0->params.p))
            goto err;
        VAR_4 = BN_check_prime(VAR_7, VAR_6, NULL);
        if (VAR_4 < 0)
            goto err;
        if (!VAR_4)
            *VAR_1 |= VAR_20;
    }
    VAR_3 = 1;
 err:
    BN_CTX_end(VAR_6);
    BN_CTX_free(VAR_6);
    return VAR_3;
#endif /* COMMENT_3 */
}",openssl/9002fd07327a91f35ba6c1307e71fa6fd4409b7f/dh_check.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 #ifdef FIPS_MODULE
     return DH_check_params(dh, ret);
 #else
-    int ok = 0, r;
+    int ok = 0, r, q_good = 0;
     BN_CTX *ctx = NULL;
     BIGNUM *t1 = NULL, *t2 = NULL;
     int nid = DH_get_nid((DH *)dh);
@@ -32,6 +32,13 @@
         goto err;
 
     if (dh->params.q != NULL) {
+        if (BN_ucmp(dh->params.p, dh->params.q) > 0)
+            q_good = 1;
+        else
+            *ret |= DH_CHECK_INVALID_Q_VALUE;
+    }
+
+    if (q_good) {
         if (BN_cmp(dh->params.g, BN_value_one()) <= 0)
             *ret |= DH_NOT_SUITABLE_GENERATOR;
         else if (BN_cmp(dh->params.g, dh->params.p) >= 0)","{'deleted_lines': ['    int ok = 0, r;'], 'added_lines': ['    int ok = 0, r, q_good = 0;', '        if (BN_ucmp(dh->params.p, dh->params.q) > 0)', '            q_good = 1;', '        else', '            *ret |= DH_CHECK_INVALID_Q_VALUE;', '    }', '', '    if (q_good) {']}",True,"Issue summary: Checking excessively long DH keys or parameters may be very slow.

Impact summary: Applications that use the functions DH_check(), DH_check_ex()
or EVP_PKEY_param_check() to check a DH key or DH parameters may experience long
delays. Where the key or parameters that are being checked have been obtained
from an untrusted source this may lead to a Denial of Service.

The function DH_check() performs various checks on DH parameters. After fixing
CVE-2023-3446 it was discovered that a large q parameter value can also trigger
an overly long computation during some of these checks. A correct q value,
if present, cannot be larger than the modulus p parameter, thus it is
unnecessary to perform these checks if q is larger than p.

An application that calls DH_check() and supplies a key or parameters obtained
from an untrusted source could be vulnerable to a Denial of Service attack.

The function DH_check() is itself called by a number of other OpenSSL functions.
An application calling any of those other functions may similarly be affected.
The other functions affected by this are DH_check_ex() and
EVP_PKEY_param_check().

Also vulnerable are the OpenSSL dhparam and pkeyparam command line applications
when using the ""-check"" option.

The OpenSSL SSL/TLS implementation is not affected by this issue.

The OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.",5.3,MEDIUM,1,test,,5
CVE-2023-3817,['CWE-834'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L,1,openssl,"
DH_check(): Do not try checking q properties if it is obviously invalid

If  |q| >= |p| then the q value is obviously wrong as q
is supposed to be a prime divisor of p-1.

We check if p is overly large so this added test implies that
q is not large either when performing subsequent tests using that
q value.

Otherwise if it is too large these additional checks of the q value
such as the primality test can then trigger DoS by doing overly long
computations.

Fixes CVE-2023-3817

Reviewed-by: Matt Caswell <matt@openssl.org>
Reviewed-by: Paul Dale <pauli@openssl.org>
Reviewed-by: Tom Cosgrove <tom.cosgrove@arm.com>
Reviewed-by: Todd Short <todd.short@me.com>
(Merged from https://github.com/openssl/openssl/pull/21550)

(cherry picked from commit 1c16253f3c3a8d1e25918c3f404aae6a5b0893de)
",6a1eb62c29db6cb5eec707f9338aee00f44e26f5,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=6a1eb62c29db6cb5eec707f9338aee00f44e26f5,crypto/dh/dh_check.c,DH_check,"int DH_check(const DH *dh, int *ret)
{
#ifdef FIPS_MODULE
return DH_check_params(dh, ret);
#else
int ok = 0, r;
BN_CTX *ctx = NULL;
BIGNUM *t1 = NULL, *t2 = NULL;
int nid = DH_get_nid((DH *)dh);
*ret = 0;
if (nid != NID_undef)
return 1;
if (BN_num_bits(dh->params.p) > OPENSSL_DH_CHECK_MAX_MODULUS_BITS) {
ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);
*ret = DH_MODULUS_TOO_LARGE | DH_CHECK_P_NOT_PRIME;
return 0;
}
if (!DH_check_params(dh, ret))
return 0;
ctx = BN_CTX_new_ex(dh->libctx);
if (ctx == NULL)
goto err;
BN_CTX_start(ctx);
t1 = BN_CTX_get(ctx);
t2 = BN_CTX_get(ctx);
if (t2 == NULL)
goto err;
if (dh->params.q != NULL) {
if (BN_cmp(dh->params.g, BN_value_one()) <= 0)
*ret |= DH_NOT_SUITABLE_GENERATOR;
else if (BN_cmp(dh->params.g, dh->params.p) >= 0)
*ret |= DH_NOT_SUITABLE_GENERATOR;
else {
if (!BN_mod_exp(t1, dh->params.g, dh->params.q, dh->params.p, ctx))
goto err;
if (!BN_is_one(t1))
*ret |= DH_NOT_SUITABLE_GENERATOR;
}
r = BN_check_prime(dh->params.q, ctx, NULL);
if (r < 0)
goto err;
if (!r)
*ret |= DH_CHECK_Q_NOT_PRIME;
if (!BN_div(t1, t2, dh->params.p, dh->params.q, ctx))
goto err;
if (!BN_is_one(t2))
*ret |= DH_CHECK_INVALID_Q_VALUE;
if (dh->params.j != NULL
&& BN_cmp(dh->params.j, t1))
*ret |= DH_CHECK_INVALID_J_VALUE;
}
r = BN_check_prime(dh->params.p, ctx, NULL);
if (r < 0)
goto err;
if (!r)
*ret |= DH_CHECK_P_NOT_PRIME;
else if (dh->params.q == NULL) {
if (!BN_rshift1(t1, dh->params.p))
goto err;
r = BN_check_prime(t1, ctx, NULL);
if (r < 0)
goto err;
if (!r)
*ret |= DH_CHECK_P_NOT_SAFE_PRIME;
}
ok = 1;
err:
BN_CTX_end(ctx);
BN_CTX_free(ctx);
return ok;
#endif 
}","int DH_check(const DH *VAR_0, int *VAR_1)
{
#ifdef VAR_2
return DH_check_params(VAR_0, VAR_1);
#else
int VAR_3 = 0, VAR_4;
BN_CTX *VAR_5 = NULL;
BIGNUM *VAR_6 = NULL, *VAR_7 = NULL;
int VAR_8 = DH_get_nid((DH *)VAR_0);
*VAR_1 = 0;
if (VAR_8 != VAR_9)
return 1;
if (BN_num_bits(VAR_0->params.p) > VAR_10) {
ERR_raise(VAR_11, VAR_12);
*VAR_1 = VAR_13 | VAR_14;
return 0;
}
if (!DH_check_params(VAR_0, VAR_1))
return 0;
VAR_5 = BN_CTX_new_ex(VAR_0->libctx);
if (VAR_5 == NULL)
goto err;
BN_CTX_start(VAR_5);
VAR_6 = BN_CTX_get(VAR_5);
VAR_7 = BN_CTX_get(VAR_5);
if (VAR_7 == NULL)
goto err;
if (VAR_0->params.q != NULL) {
if (BN_cmp(VAR_0->params.g, BN_value_one()) <= 0)
*VAR_1 |= VAR_15;
else if (BN_cmp(VAR_0->params.g, VAR_0->params.p) >= 0)
*VAR_1 |= VAR_15;
else {
if (!BN_mod_exp(VAR_6, VAR_0->params.g, VAR_0->params.q, VAR_0->params.p, VAR_5))
goto err;
if (!BN_is_one(VAR_6))
*VAR_1 |= VAR_15;
}
VAR_4 = BN_check_prime(VAR_0->params.q, VAR_5, NULL);
if (VAR_4 < 0)
goto err;
if (!VAR_4)
*VAR_1 |= VAR_16;
if (!BN_div(VAR_6, VAR_7, VAR_0->params.p, VAR_0->params.q, VAR_5))
goto err;
if (!BN_is_one(VAR_7))
*VAR_1 |= VAR_17;
if (VAR_0->params.j != NULL
&& BN_cmp(VAR_0->params.j, VAR_6))
*VAR_1 |= VAR_18;
}
VAR_4 = BN_check_prime(VAR_0->params.p, VAR_5, NULL);
if (VAR_4 < 0)
goto err;
if (!VAR_4)
*VAR_1 |= VAR_14;
else if (VAR_0->params.q == NULL) {
if (!BN_rshift1(VAR_6, VAR_0->params.p))
goto err;
VAR_4 = BN_check_prime(VAR_6, VAR_5, NULL);
if (VAR_4 < 0)
goto err;
if (!VAR_4)
*VAR_1 |= VAR_19;
}
VAR_3 = 1;
err:
BN_CTX_end(VAR_5);
BN_CTX_free(VAR_5);
return VAR_3;
#endif 
}",openssl/6a1eb62c29db6cb5eec707f9338aee00f44e26f5/dh_check.c/vul/before/0.json,"int DH_check(const DH *dh, int *ret)
{
#ifdef FIPS_MODULE
    return DH_check_params(dh, ret);
#else
    int ok = 0, r, q_good = 0;
    BN_CTX *ctx = NULL;
    BIGNUM *t1 = NULL, *t2 = NULL;
    int nid = DH_get_nid((DH *)dh);

    *ret = 0;
    if (nid != NID_undef)
        return 1;

    /* Don't do any checks at all with an excessively large modulus */
    if (BN_num_bits(dh->params.p) > OPENSSL_DH_CHECK_MAX_MODULUS_BITS) {
        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);
        *ret = DH_MODULUS_TOO_LARGE | DH_CHECK_P_NOT_PRIME;
        return 0;
    }

    if (!DH_check_params(dh, ret))
        return 0;

    ctx = BN_CTX_new_ex(dh->libctx);
    if (ctx == NULL)
        goto err;
    BN_CTX_start(ctx);
    t1 = BN_CTX_get(ctx);
    t2 = BN_CTX_get(ctx);
    if (t2 == NULL)
        goto err;

    if (dh->params.q != NULL) {
        if (BN_ucmp(dh->params.p, dh->params.q) > 0)
            q_good = 1;
        else
            *ret |= DH_CHECK_INVALID_Q_VALUE;
    }

    if (q_good) {
        if (BN_cmp(dh->params.g, BN_value_one()) <= 0)
            *ret |= DH_NOT_SUITABLE_GENERATOR;
        else if (BN_cmp(dh->params.g, dh->params.p) >= 0)
            *ret |= DH_NOT_SUITABLE_GENERATOR;
        else {
            /* Check g^q == 1 mod p */
            if (!BN_mod_exp(t1, dh->params.g, dh->params.q, dh->params.p, ctx))
                goto err;
            if (!BN_is_one(t1))
                *ret |= DH_NOT_SUITABLE_GENERATOR;
        }
        r = BN_check_prime(dh->params.q, ctx, NULL);
        if (r < 0)
            goto err;
        if (!r)
            *ret |= DH_CHECK_Q_NOT_PRIME;
        /* Check p == 1 mod q  i.e. q divides p - 1 */
        if (!BN_div(t1, t2, dh->params.p, dh->params.q, ctx))
            goto err;
        if (!BN_is_one(t2))
            *ret |= DH_CHECK_INVALID_Q_VALUE;
        if (dh->params.j != NULL
            && BN_cmp(dh->params.j, t1))
            *ret |= DH_CHECK_INVALID_J_VALUE;
    }

    r = BN_check_prime(dh->params.p, ctx, NULL);
    if (r < 0)
        goto err;
    if (!r)
        *ret |= DH_CHECK_P_NOT_PRIME;
    else if (dh->params.q == NULL) {
        if (!BN_rshift1(t1, dh->params.p))
            goto err;
        r = BN_check_prime(t1, ctx, NULL);
        if (r < 0)
            goto err;
        if (!r)
            *ret |= DH_CHECK_P_NOT_SAFE_PRIME;
    }
    ok = 1;
 err:
    BN_CTX_end(ctx);
    BN_CTX_free(ctx);
    return ok;
#endif /* FIPS_MODULE */
}","int DH_check(const DH *VAR_0, int *VAR_1)
{
#ifdef VAR_2
    return DH_check_params(VAR_0, VAR_1);
#else
    int VAR_3 = 0, VAR_4, VAR_5 = 0;
    BN_CTX *VAR_6 = NULL;
    BIGNUM *VAR_7 = NULL, *VAR_8 = NULL;
    int VAR_9 = DH_get_nid((DH *)VAR_0);

    *VAR_1 = 0;
    if (VAR_9 != VAR_10)
        return 1;

    /* COMMENT_0 */
    if (BN_num_bits(VAR_0->params.p) > VAR_11) {
        ERR_raise(VAR_12, VAR_13);
        *VAR_1 = VAR_14 | VAR_15;
        return 0;
    }

    if (!DH_check_params(VAR_0, VAR_1))
        return 0;

    VAR_6 = BN_CTX_new_ex(VAR_0->libctx);
    if (VAR_6 == NULL)
        goto err;
    BN_CTX_start(VAR_6);
    VAR_7 = BN_CTX_get(VAR_6);
    VAR_8 = BN_CTX_get(VAR_6);
    if (VAR_8 == NULL)
        goto err;

    if (VAR_0->params.q != NULL) {
        if (BN_ucmp(VAR_0->params.p, VAR_0->params.q) > 0)
            VAR_5 = 1;
        else
            *VAR_1 |= VAR_16;
    }

    if (VAR_5) {
        if (BN_cmp(VAR_0->params.g, BN_value_one()) <= 0)
            *VAR_1 |= VAR_17;
        else if (BN_cmp(VAR_0->params.g, VAR_0->params.p) >= 0)
            *VAR_1 |= VAR_17;
        else {
            /* COMMENT_1 */
            if (!BN_mod_exp(VAR_7, VAR_0->params.g, VAR_0->params.q, VAR_0->params.p, VAR_6))
                goto err;
            if (!BN_is_one(VAR_7))
                *VAR_1 |= VAR_17;
        }
        VAR_4 = BN_check_prime(VAR_0->params.q, VAR_6, NULL);
        if (VAR_4 < 0)
            goto err;
        if (!VAR_4)
            *VAR_1 |= VAR_18;
        /* COMMENT_2 */
        if (!BN_div(VAR_7, VAR_8, VAR_0->params.p, VAR_0->params.q, VAR_6))
            goto err;
        if (!BN_is_one(VAR_8))
            *VAR_1 |= VAR_16;
        if (VAR_0->params.j != NULL
            && BN_cmp(VAR_0->params.j, VAR_7))
            *VAR_1 |= VAR_19;
    }

    VAR_4 = BN_check_prime(VAR_0->params.p, VAR_6, NULL);
    if (VAR_4 < 0)
        goto err;
    if (!VAR_4)
        *VAR_1 |= VAR_15;
    else if (VAR_0->params.q == NULL) {
        if (!BN_rshift1(VAR_7, VAR_0->params.p))
            goto err;
        VAR_4 = BN_check_prime(VAR_7, VAR_6, NULL);
        if (VAR_4 < 0)
            goto err;
        if (!VAR_4)
            *VAR_1 |= VAR_20;
    }
    VAR_3 = 1;
 err:
    BN_CTX_end(VAR_6);
    BN_CTX_free(VAR_6);
    return VAR_3;
#endif /* COMMENT_3 */
}",openssl/6a1eb62c29db6cb5eec707f9338aee00f44e26f5/dh_check.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 #ifdef FIPS_MODULE
     return DH_check_params(dh, ret);
 #else
-    int ok = 0, r;
+    int ok = 0, r, q_good = 0;
     BN_CTX *ctx = NULL;
     BIGNUM *t1 = NULL, *t2 = NULL;
     int nid = DH_get_nid((DH *)dh);
@@ -32,6 +32,13 @@
         goto err;
 
     if (dh->params.q != NULL) {
+        if (BN_ucmp(dh->params.p, dh->params.q) > 0)
+            q_good = 1;
+        else
+            *ret |= DH_CHECK_INVALID_Q_VALUE;
+    }
+
+    if (q_good) {
         if (BN_cmp(dh->params.g, BN_value_one()) <= 0)
             *ret |= DH_NOT_SUITABLE_GENERATOR;
         else if (BN_cmp(dh->params.g, dh->params.p) >= 0)","{'deleted_lines': ['    int ok = 0, r;'], 'added_lines': ['    int ok = 0, r, q_good = 0;', '        if (BN_ucmp(dh->params.p, dh->params.q) > 0)', '            q_good = 1;', '        else', '            *ret |= DH_CHECK_INVALID_Q_VALUE;', '    }', '', '    if (q_good) {']}",True,"Issue summary: Checking excessively long DH keys or parameters may be very slow.

Impact summary: Applications that use the functions DH_check(), DH_check_ex()
or EVP_PKEY_param_check() to check a DH key or DH parameters may experience long
delays. Where the key or parameters that are being checked have been obtained
from an untrusted source this may lead to a Denial of Service.

The function DH_check() performs various checks on DH parameters. After fixing
CVE-2023-3446 it was discovered that a large q parameter value can also trigger
an overly long computation during some of these checks. A correct q value,
if present, cannot be larger than the modulus p parameter, thus it is
unnecessary to perform these checks if q is larger than p.

An application that calls DH_check() and supplies a key or parameters obtained
from an untrusted source could be vulnerable to a Denial of Service attack.

The function DH_check() is itself called by a number of other OpenSSL functions.
An application calling any of those other functions may similarly be affected.
The other functions affected by this are DH_check_ex() and
EVP_PKEY_param_check().

Also vulnerable are the OpenSSL dhparam and pkeyparam command line applications
when using the ""-check"" option.

The OpenSSL SSL/TLS implementation is not affected by this issue.

The OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.",5.3,MEDIUM,1,test,,5
CVE-2023-3817,['CWE-834'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L,1,openssl,"
DH_check(): Do not try checking q properties if it is obviously invalid

If  |q| >= |p| then the q value is obviously wrong as q
is supposed to be a prime divisor of p-1.

We check if p is overly large so this added test implies that
q is not large either when performing subsequent tests using that
q value.

Otherwise if it is too large these additional checks of the q value
such as the primality test can then trigger DoS by doing overly long
computations.

Fixes CVE-2023-3817

Reviewed-by: Paul Dale <pauli@openssl.org>
Reviewed-by: Matt Caswell <matt@openssl.org>
(Merged from https://github.com/openssl/openssl/pull/21551)
",91ddeba0f2269b017dc06c46c993a788974b1aa5,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=91ddeba0f2269b017dc06c46c993a788974b1aa5,crypto/dh/dh_check.c,DH_check,"int DH_check(const DH *dh, int *ret)
{
int ok = 0, r;
BN_CTX *ctx = NULL;
BIGNUM *t1 = NULL, *t2 = NULL;
if (BN_num_bits(dh->p) > OPENSSL_DH_CHECK_MAX_MODULUS_BITS) {
DHerr(DH_F_DH_CHECK, DH_R_MODULUS_TOO_LARGE);
*ret = DH_CHECK_P_NOT_PRIME;
return 0;
}
if (!DH_check_params(dh, ret))
return 0;
ctx = BN_CTX_new();
if (ctx == NULL)
goto err;
BN_CTX_start(ctx);
t1 = BN_CTX_get(ctx);
t2 = BN_CTX_get(ctx);
if (t2 == NULL)
goto err;
if (dh->q) {
if (BN_cmp(dh->g, BN_value_one()) <= 0)
*ret |= DH_NOT_SUITABLE_GENERATOR;
else if (BN_cmp(dh->g, dh->p) >= 0)
*ret |= DH_NOT_SUITABLE_GENERATOR;
else {
if (!BN_mod_exp(t1, dh->g, dh->q, dh->p, ctx))
goto err;
if (!BN_is_one(t1))
*ret |= DH_NOT_SUITABLE_GENERATOR;
}
r = BN_is_prime_ex(dh->q, DH_NUMBER_ITERATIONS_FOR_PRIME, ctx, NULL);
if (r < 0)
goto err;
if (!r)
*ret |= DH_CHECK_Q_NOT_PRIME;
if (!BN_div(t1, t2, dh->p, dh->q, ctx))
goto err;
if (!BN_is_one(t2))
*ret |= DH_CHECK_INVALID_Q_VALUE;
if (dh->j && BN_cmp(dh->j, t1))
*ret |= DH_CHECK_INVALID_J_VALUE;
}
r = BN_is_prime_ex(dh->p, DH_NUMBER_ITERATIONS_FOR_PRIME, ctx, NULL);
if (r < 0)
goto err;
if (!r)
*ret |= DH_CHECK_P_NOT_PRIME;
else if (!dh->q) {
if (!BN_rshift1(t1, dh->p))
goto err;
r = BN_is_prime_ex(t1, DH_NUMBER_ITERATIONS_FOR_PRIME, ctx, NULL);
if (r < 0)
goto err;
if (!r)
*ret |= DH_CHECK_P_NOT_SAFE_PRIME;
}
ok = 1;
err:
BN_CTX_end(ctx);
BN_CTX_free(ctx);
return ok;
}","int DH_check(const DH *VAR_0, int *VAR_1)
{
int VAR_2 = 0, VAR_3;
BN_CTX *VAR_4 = NULL;
BIGNUM *VAR_5 = NULL, *VAR_6 = NULL;
if (BN_num_bits(VAR_0->p) > VAR_7) {
DHerr(VAR_8, VAR_9);
*VAR_1 = VAR_10;
return 0;
}
if (!DH_check_params(VAR_0, VAR_1))
return 0;
VAR_4 = BN_CTX_new();
if (VAR_4 == NULL)
goto err;
BN_CTX_start(VAR_4);
VAR_5 = BN_CTX_get(VAR_4);
VAR_6 = BN_CTX_get(VAR_4);
if (VAR_6 == NULL)
goto err;
if (VAR_0->q) {
if (BN_cmp(VAR_0->g, BN_value_one()) <= 0)
*VAR_1 |= VAR_11;
else if (BN_cmp(VAR_0->g, VAR_0->p) >= 0)
*VAR_1 |= VAR_11;
else {
if (!BN_mod_exp(VAR_5, VAR_0->g, VAR_0->q, VAR_0->p, VAR_4))
goto err;
if (!BN_is_one(VAR_5))
*VAR_1 |= VAR_11;
}
VAR_3 = BN_is_prime_ex(VAR_0->q, VAR_12, VAR_4, NULL);
if (VAR_3 < 0)
goto err;
if (!VAR_3)
*VAR_1 |= VAR_13;
if (!BN_div(VAR_5, VAR_6, VAR_0->p, VAR_0->q, VAR_4))
goto err;
if (!BN_is_one(VAR_6))
*VAR_1 |= VAR_14;
if (VAR_0->j && BN_cmp(VAR_0->j, VAR_5))
*VAR_1 |= VAR_15;
}
VAR_3 = BN_is_prime_ex(VAR_0->p, VAR_12, VAR_4, NULL);
if (VAR_3 < 0)
goto err;
if (!VAR_3)
*VAR_1 |= VAR_10;
else if (!VAR_0->q) {
if (!BN_rshift1(VAR_5, VAR_0->p))
goto err;
VAR_3 = BN_is_prime_ex(VAR_5, VAR_12, VAR_4, NULL);
if (VAR_3 < 0)
goto err;
if (!VAR_3)
*VAR_1 |= VAR_16;
}
VAR_2 = 1;
err:
BN_CTX_end(VAR_4);
BN_CTX_free(VAR_4);
return VAR_2;
}",openssl/91ddeba0f2269b017dc06c46c993a788974b1aa5/dh_check.c/vul/before/0.json,"int DH_check(const DH *dh, int *ret)
{
    int ok = 0, r, q_good = 0;
    BN_CTX *ctx = NULL;
    BIGNUM *t1 = NULL, *t2 = NULL;

    /* Don't do any checks at all with an excessively large modulus */
    if (BN_num_bits(dh->p) > OPENSSL_DH_CHECK_MAX_MODULUS_BITS) {
        DHerr(DH_F_DH_CHECK, DH_R_MODULUS_TOO_LARGE);
        *ret = DH_CHECK_P_NOT_PRIME;
        return 0;
    }

    if (!DH_check_params(dh, ret))
        return 0;

    ctx = BN_CTX_new();
    if (ctx == NULL)
        goto err;
    BN_CTX_start(ctx);
    t1 = BN_CTX_get(ctx);
    t2 = BN_CTX_get(ctx);
    if (t2 == NULL)
        goto err;

    if (dh->q != NULL) {
        if (BN_ucmp(dh->p, dh->q) > 0)
            q_good = 1;
        else
            *ret |= DH_CHECK_INVALID_Q_VALUE;
    }

    if (q_good) {
        if (BN_cmp(dh->g, BN_value_one()) <= 0)
            *ret |= DH_NOT_SUITABLE_GENERATOR;
        else if (BN_cmp(dh->g, dh->p) >= 0)
            *ret |= DH_NOT_SUITABLE_GENERATOR;
        else {
            /* Check g^q == 1 mod p */
            if (!BN_mod_exp(t1, dh->g, dh->q, dh->p, ctx))
                goto err;
            if (!BN_is_one(t1))
                *ret |= DH_NOT_SUITABLE_GENERATOR;
        }
        r = BN_is_prime_ex(dh->q, DH_NUMBER_ITERATIONS_FOR_PRIME, ctx, NULL);
        if (r < 0)
            goto err;
        if (!r)
            *ret |= DH_CHECK_Q_NOT_PRIME;
        /* Check p == 1 mod q  i.e. q divides p - 1 */
        if (!BN_div(t1, t2, dh->p, dh->q, ctx))
            goto err;
        if (!BN_is_one(t2))
            *ret |= DH_CHECK_INVALID_Q_VALUE;
        if (dh->j && BN_cmp(dh->j, t1))
            *ret |= DH_CHECK_INVALID_J_VALUE;
    }

    r = BN_is_prime_ex(dh->p, DH_NUMBER_ITERATIONS_FOR_PRIME, ctx, NULL);
    if (r < 0)
        goto err;
    if (!r)
        *ret |= DH_CHECK_P_NOT_PRIME;
    else if (!dh->q) {
        if (!BN_rshift1(t1, dh->p))
            goto err;
        r = BN_is_prime_ex(t1, DH_NUMBER_ITERATIONS_FOR_PRIME, ctx, NULL);
        if (r < 0)
            goto err;
        if (!r)
            *ret |= DH_CHECK_P_NOT_SAFE_PRIME;
    }
    ok = 1;
 err:
    BN_CTX_end(ctx);
    BN_CTX_free(ctx);
    return ok;
}","int DH_check(const DH *VAR_0, int *VAR_1)
{
    int VAR_2 = 0, VAR_3, VAR_4 = 0;
    BN_CTX *VAR_5 = NULL;
    BIGNUM *VAR_6 = NULL, *VAR_7 = NULL;

    /* COMMENT_0 */
    if (BN_num_bits(VAR_0->p) > VAR_8) {
        DHerr(VAR_9, VAR_10);
        *VAR_1 = VAR_11;
        return 0;
    }

    if (!DH_check_params(VAR_0, VAR_1))
        return 0;

    VAR_5 = BN_CTX_new();
    if (VAR_5 == NULL)
        goto err;
    BN_CTX_start(VAR_5);
    VAR_6 = BN_CTX_get(VAR_5);
    VAR_7 = BN_CTX_get(VAR_5);
    if (VAR_7 == NULL)
        goto err;

    if (VAR_0->q != NULL) {
        if (BN_ucmp(VAR_0->p, VAR_0->q) > 0)
            VAR_4 = 1;
        else
            *VAR_1 |= VAR_12;
    }

    if (VAR_4) {
        if (BN_cmp(VAR_0->g, BN_value_one()) <= 0)
            *VAR_1 |= VAR_13;
        else if (BN_cmp(VAR_0->g, VAR_0->p) >= 0)
            *VAR_1 |= VAR_13;
        else {
            /* COMMENT_1 */
            if (!BN_mod_exp(VAR_6, VAR_0->g, VAR_0->q, VAR_0->p, VAR_5))
                goto err;
            if (!BN_is_one(VAR_6))
                *VAR_1 |= VAR_13;
        }
        VAR_3 = BN_is_prime_ex(VAR_0->q, VAR_14, VAR_5, NULL);
        if (VAR_3 < 0)
            goto err;
        if (!VAR_3)
            *VAR_1 |= VAR_15;
        /* COMMENT_2 */
        if (!BN_div(VAR_6, VAR_7, VAR_0->p, VAR_0->q, VAR_5))
            goto err;
        if (!BN_is_one(VAR_7))
            *VAR_1 |= VAR_12;
        if (VAR_0->j && BN_cmp(VAR_0->j, VAR_6))
            *VAR_1 |= VAR_16;
    }

    VAR_3 = BN_is_prime_ex(VAR_0->p, VAR_14, VAR_5, NULL);
    if (VAR_3 < 0)
        goto err;
    if (!VAR_3)
        *VAR_1 |= VAR_11;
    else if (!VAR_0->q) {
        if (!BN_rshift1(VAR_6, VAR_0->p))
            goto err;
        VAR_3 = BN_is_prime_ex(VAR_6, VAR_14, VAR_5, NULL);
        if (VAR_3 < 0)
            goto err;
        if (!VAR_3)
            *VAR_1 |= VAR_17;
    }
    VAR_2 = 1;
 err:
    BN_CTX_end(VAR_5);
    BN_CTX_free(VAR_5);
    return VAR_2;
}",openssl/91ddeba0f2269b017dc06c46c993a788974b1aa5/dh_check.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 int DH_check(const DH *dh, int *ret)
 {
-    int ok = 0, r;
+    int ok = 0, r, q_good = 0;
     BN_CTX *ctx = NULL;
     BIGNUM *t1 = NULL, *t2 = NULL;
 
@@ -23,7 +23,14 @@
     if (t2 == NULL)
         goto err;
 
-    if (dh->q) {
+    if (dh->q != NULL) {
+        if (BN_ucmp(dh->p, dh->q) > 0)
+            q_good = 1;
+        else
+            *ret |= DH_CHECK_INVALID_Q_VALUE;
+    }
+
+    if (q_good) {
         if (BN_cmp(dh->g, BN_value_one()) <= 0)
             *ret |= DH_NOT_SUITABLE_GENERATOR;
         else if (BN_cmp(dh->g, dh->p) >= 0)","{'deleted_lines': ['    int ok = 0, r;', '    if (dh->q) {'], 'added_lines': ['    int ok = 0, r, q_good = 0;', '    if (dh->q != NULL) {', '        if (BN_ucmp(dh->p, dh->q) > 0)', '            q_good = 1;', '        else', '            *ret |= DH_CHECK_INVALID_Q_VALUE;', '    }', '', '    if (q_good) {']}",True,"Issue summary: Checking excessively long DH keys or parameters may be very slow.

Impact summary: Applications that use the functions DH_check(), DH_check_ex()
or EVP_PKEY_param_check() to check a DH key or DH parameters may experience long
delays. Where the key or parameters that are being checked have been obtained
from an untrusted source this may lead to a Denial of Service.

The function DH_check() performs various checks on DH parameters. After fixing
CVE-2023-3446 it was discovered that a large q parameter value can also trigger
an overly long computation during some of these checks. A correct q value,
if present, cannot be larger than the modulus p parameter, thus it is
unnecessary to perform these checks if q is larger than p.

An application that calls DH_check() and supplies a key or parameters obtained
from an untrusted source could be vulnerable to a Denial of Service attack.

The function DH_check() is itself called by a number of other OpenSSL functions.
An application calling any of those other functions may similarly be affected.
The other functions affected by this are DH_check_ex() and
EVP_PKEY_param_check().

Also vulnerable are the OpenSSL dhparam and pkeyparam command line applications
when using the ""-check"" option.

The OpenSSL SSL/TLS implementation is not affected by this issue.

The OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.",5.3,MEDIUM,1,test,,5
CVE-2016-1631,['CWE-264'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,chromium,"Fix PPB_Flash_MessageLoop.

This CL suspends script callbacks and resource loads while running nested message loop using PPB_Flash_MessageLoop.

BUG=569496

Review URL: https://codereview.chromium.org/1559113002

Cr-Commit-Position: refs/heads/master@{#374529}
",dd77c2a41c72589d929db0592565125ca629fb2c,https://chromium.googlesource.com/chromium/src/+/dd77c2a41c72589d929db0592565125ca629fb2c,content/renderer/pepper/ppb_flash_message_loop_impl.cc,PPB_Flash_MessageLoop_Impl::InternalRun,"int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
const RunFromHostProxyCallback& callback) {
if (state_->run_called()) {
if (!callback.is_null())
callback.Run(PP_ERROR_FAILED);
return PP_ERROR_FAILED;
}
state_->set_run_called();
state_->set_run_callback(callback);
scoped_refptr<State> state_protector(state_);
{
base::MessageLoop::ScopedNestableTaskAllower allow(
base::MessageLoop::current());
base::MessageLoop::current()->Run();
}
return state_protector->result();
}","int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
const RunFromHostProxyCallback& VAR_0) {
if (VAR_1->run_called()) {
if (!VAR_0.is_null())
VAR_0.Run(VAR_2);
return VAR_2;
}
VAR_1->set_run_called();
VAR_1->set_run_callback(VAR_0);
scoped_refptr<State> state_protector(state_);
{
base::MessageLoop::ScopedNestableTaskAllower allow(
base::MessageLoop::current());
base::MessageLoop::current()->Run();
}
return VAR_3->result();
}",chromium/dd77c2a41c72589d929db0592565125ca629fb2c/ppb_flash_message_loop_impl.cc/vul/before/0.json,"int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
    const RunFromHostProxyCallback& callback) {
  if (state_->run_called()) {
    if (!callback.is_null())
      callback.Run(PP_ERROR_FAILED);
    return PP_ERROR_FAILED;
  }
  state_->set_run_called();
  state_->set_run_callback(callback);

  // It is possible that the PPB_Flash_MessageLoop_Impl object has been
  // destroyed when the nested message loop exits.
  scoped_refptr<State> state_protector(state_);
  {
    base::MessageLoop::ScopedNestableTaskAllower allow(
        base::MessageLoop::current());
    blink::WebView::willEnterModalLoop();

    base::MessageLoop::current()->Run();

    blink::WebView::didExitModalLoop();
  }
  // Don't access data members of the class below.

  return state_protector->result();
}","int32_t PPB_Flash_MessageLoop_Impl::InternalRun(
    const RunFromHostProxyCallback& VAR_0) {
  if (VAR_1->run_called()) {
    if (!VAR_0.is_null())
      VAR_0.Run(VAR_2);
    return VAR_2;
  }
  VAR_1->set_run_called();
  VAR_1->set_run_callback(VAR_0);

  /* COMMENT_0 */
  /* COMMENT_1 */
  scoped_refptr<State> state_protector(state_);
  {
    base::MessageLoop::ScopedNestableTaskAllower allow(
        base::MessageLoop::current());
    blink::WebView::willEnterModalLoop();

    base::MessageLoop::current()->Run();

    blink::WebView::didExitModalLoop();
  }
  /* COMMENT_2 */

  return VAR_3->result();
}",chromium/dd77c2a41c72589d929db0592565125ca629fb2c/ppb_flash_message_loop_impl.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,7 +14,11 @@
   {
     base::MessageLoop::ScopedNestableTaskAllower allow(
         base::MessageLoop::current());
+    blink::WebView::willEnterModalLoop();
+
     base::MessageLoop::current()->Run();
+
+    blink::WebView::didExitModalLoop();
   }
   // Don't access data members of the class below.
 ","{'deleted_lines': [], 'added_lines': ['    blink::WebView::willEnterModalLoop();', '', '', '    blink::WebView::didExitModalLoop();']}",True,"The PPB_Flash_MessageLoop_Impl::InternalRun function in content/renderer/pepper/ppb_flash_message_loop_impl.cc in the Pepper plugin in Google Chrome before 49.0.2623.75 mishandles nested message loops, which allows remote attackers to bypass the Same Origin Policy via a crafted web site.",8.8,HIGH,2,test,,5
CVE-2016-1643,['CWE-361'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,chromium,"ImageInputType::ensurePrimaryContent should recreate UA shadow tree.

Once the fallback shadow tree was created, it was never recreated even if
ensurePrimaryContent was called.  Such situation happens by updating |src|
attribute.

BUG=589838

Review URL: https://codereview.chromium.org/1732753004

Cr-Commit-Position: refs/heads/master@{#377804}
",2386a6a49ea992a1e859eb0296c1cc53e5772cdb,https://chromium.googlesource.com/chromium/src/+/2386a6a49ea992a1e859eb0296c1cc53e5772cdb,third_party/WebKit/Source/core/html/forms/ImageInputType.cpp,ImageInputType::ensurePrimaryContent,"void ImageInputType::ensurePrimaryContent()
{
if (!m_useFallbackContent)
return;
m_useFallbackContent = false;
reattachFallbackContent();
}","void ImageInputType::ensurePrimaryContent()
{
if (!VAR_0)
return;
VAR_0 = false;
reattachFallbackContent();
}",chromium/2386a6a49ea992a1e859eb0296c1cc53e5772cdb/ImageInputType.cpp/vul/before/0.json,"void ImageInputType::ensurePrimaryContent()
{
    if (!m_useFallbackContent)
        return;
    m_useFallbackContent = false;
    if (ShadowRoot* root = element().userAgentShadowRoot())
        root->removeChildren();
    createShadowSubtree();
    reattachFallbackContent();
}","void ImageInputType::ensurePrimaryContent()
{
    if (!VAR_0)
        return;
    VAR_0 = false;
    if (ShadowRoot* VAR_1 = element().userAgentShadowRoot())
        VAR_1->removeChildren();
    createShadowSubtree();
    reattachFallbackContent();
}",chromium/2386a6a49ea992a1e859eb0296c1cc53e5772cdb/ImageInputType.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,5 +3,8 @@
     if (!m_useFallbackContent)
         return;
     m_useFallbackContent = false;
+    if (ShadowRoot* root = element().userAgentShadowRoot())
+        root->removeChildren();
+    createShadowSubtree();
     reattachFallbackContent();
 }","{'deleted_lines': [], 'added_lines': ['    if (ShadowRoot* root = element().userAgentShadowRoot())', '        root->removeChildren();', '    createShadowSubtree();']}",True,"The ImageInputType::ensurePrimaryContent function in WebKit/Source/core/html/forms/ImageInputType.cpp in Blink, as used in Google Chrome before 49.0.2623.87, does not properly maintain the user agent shadow DOM, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that leverage ""type confusion.""",8.8,HIGH,2,test,,5
CVE-2016-0837,['CWE-119'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,android,"Also fix out of bounds access for normal read

Previous fix accidentally only fixed the fragmented read case.

Bug: 27208621
Change-Id: Ie16f1920b84c8aba613842659238fcd5925694ad
",7a282fb64fef25349e9d341f102d9cea3bf75baf,https://android.googlesource.com/platform/frameworks/av/+/7a282fb64fef25349e9d341f102d9cea3bf75baf,media/libstagefright/MPEG4Extractor.cpp,MPEG4Source::read,"status_t MPEG4Source::read(
MediaBuffer **out, const ReadOptions *options) {
Mutex::Autolock autoLock(mLock);
CHECK(mStarted);
if (mFirstMoofOffset > 0) {
return fragmentedRead(out, options);
}
*out = NULL;
int64_t targetSampleTimeUs = -1;
int64_t seekTimeUs;
ReadOptions::SeekMode mode;
if (options && options->getSeekTo(&seekTimeUs, &mode)) {
uint32_t findFlags = 0;
switch (mode) {
case ReadOptions::SEEK_PREVIOUS_SYNC:
findFlags = SampleTable::kFlagBefore;
break;
case ReadOptions::SEEK_NEXT_SYNC:
findFlags = SampleTable::kFlagAfter;
break;
case ReadOptions::SEEK_CLOSEST_SYNC:
case ReadOptions::SEEK_CLOSEST:
findFlags = SampleTable::kFlagClosest;
break;
default:
CHECK(!""Should not be here."");
break;
}
uint32_t sampleIndex;
status_t err = mSampleTable->findSampleAtTime(
seekTimeUs, 1000000, mTimescale,
&sampleIndex, findFlags);
if (mode == ReadOptions::SEEK_CLOSEST) {
findFlags = SampleTable::kFlagBefore;
}
uint32_t syncSampleIndex;
if (err == OK) {
err = mSampleTable->findSyncSampleNear(
sampleIndex, &syncSampleIndex, findFlags);
}
uint32_t sampleTime;
if (err == OK) {
err = mSampleTable->getMetaDataForSample(
sampleIndex, NULL, NULL, &sampleTime);
}
if (err != OK) {
if (err == ERROR_OUT_OF_RANGE) {
err = ERROR_END_OF_STREAM;
}
ALOGV(""end of stream"");
return err;
}
if (mode == ReadOptions::SEEK_CLOSEST) {
targetSampleTimeUs = (sampleTime * 1000000ll) / mTimescale;
}
#if 0
uint32_t syncSampleTime;
CHECK_EQ(OK, mSampleTable->getMetaDataForSample(
syncSampleIndex, NULL, NULL, &syncSampleTime));
ALOGI(""seek to time %lld us => sample at time %lld us, ""
""sync sample at time %lld us"",
seekTimeUs,
sampleTime * 1000000ll / mTimescale,
syncSampleTime * 1000000ll / mTimescale);
#endif
mCurrentSampleIndex = syncSampleIndex;
if (mBuffer != NULL) {
mBuffer->release();
mBuffer = NULL;
}
}
off64_t offset;
size_t size;
uint32_t cts, stts;
bool isSyncSample;
bool newBuffer = false;
if (mBuffer == NULL) {
newBuffer = true;
status_t err =
mSampleTable->getMetaDataForSample(
mCurrentSampleIndex, &offset, &size, &cts, &isSyncSample, &stts);
if (err != OK) {
return err;
}
err = mGroup->acquire_buffer(&mBuffer);
if (err != OK) {
CHECK(mBuffer == NULL);
return err;
}
if (size > mBuffer->size()) {
ALOGE(""buffer too small: %zu > %zu"", size, mBuffer->size());
return ERROR_BUFFER_TOO_SMALL;
}
}
if ((!mIsAVC && !mIsHEVC) || mWantsNALFragments) {
if (newBuffer) {
ssize_t num_bytes_read =
mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);
if (num_bytes_read < (ssize_t)size) {
mBuffer->release();
mBuffer = NULL;
return ERROR_IO;
}
CHECK(mBuffer != NULL);
mBuffer->set_range(0, size);
mBuffer->meta_data()->clear();
mBuffer->meta_data()->setInt64(
kKeyTime, ((int64_t)cts * 1000000) / mTimescale);
mBuffer->meta_data()->setInt64(
kKeyDuration, ((int64_t)stts * 1000000) / mTimescale);
if (targetSampleTimeUs >= 0) {
mBuffer->meta_data()->setInt64(
kKeyTargetTime, targetSampleTimeUs);
}
if (isSyncSample) {
mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);
}
++mCurrentSampleIndex;
}
if (!mIsAVC && !mIsHEVC) {
*out = mBuffer;
mBuffer = NULL;
return OK;
}
CHECK(mBuffer->range_length() >= mNALLengthSize);
const uint8_t *src =
(const uint8_t *)mBuffer->data() + mBuffer->range_offset();
size_t nal_size = parseNALSize(src);
if (mNALLengthSize > SIZE_MAX - nal_size) {
ALOGE(""b/24441553, b/24445122"");
}
if (mBuffer->range_length() - mNALLengthSize < nal_size) {
ALOGE(""incomplete NAL unit."");
mBuffer->release();
mBuffer = NULL;
return ERROR_MALFORMED;
}
MediaBuffer *clone = mBuffer->clone();
CHECK(clone != NULL);
clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size);
CHECK(mBuffer != NULL);
mBuffer->set_range(
mBuffer->range_offset() + mNALLengthSize + nal_size,
mBuffer->range_length() - mNALLengthSize - nal_size);
if (mBuffer->range_length() == 0) {
mBuffer->release();
mBuffer = NULL;
}
*out = clone;
return OK;
} else {
ssize_t num_bytes_read = 0;
int32_t drm = 0;
bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);
if (usesDRM) {
num_bytes_read =
mDataSource->readAt(offset, (uint8_t*)mBuffer->data(), size);
} else {
num_bytes_read = mDataSource->readAt(offset, mSrcBuffer, size);
}
if (num_bytes_read < (ssize_t)size) {
mBuffer->release();
mBuffer = NULL;
return ERROR_IO;
}
if (usesDRM) {
CHECK(mBuffer != NULL);
mBuffer->set_range(0, size);
} else {
uint8_t *dstData = (uint8_t *)mBuffer->data();
size_t srcOffset = 0;
size_t dstOffset = 0;
while (srcOffset < size) {
bool isMalFormed = !isInRange((size_t)0u, size, srcOffset, mNALLengthSize);
size_t nalLength = 0;
if (!isMalFormed) {
nalLength = parseNALSize(&mSrcBuffer[srcOffset]);
srcOffset += mNALLengthSize;
isMalFormed = !isInRange((size_t)0u, size, srcOffset, nalLength);
}
if (isMalFormed) {
ALOGE(""Video is malformed"");
mBuffer->release();
mBuffer = NULL;
return ERROR_MALFORMED;
}
if (nalLength == 0) {
continue;
}
CHECK(dstOffset + 4 <= mBuffer->size());
dstData[dstOffset++] = 0;
dstData[dstOffset++] = 0;
dstData[dstOffset++] = 0;
dstData[dstOffset++] = 1;
memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength);
srcOffset += nalLength;
dstOffset += nalLength;
}
CHECK_EQ(srcOffset, size);
CHECK(mBuffer != NULL);
mBuffer->set_range(0, dstOffset);
}
mBuffer->meta_data()->clear();
mBuffer->meta_data()->setInt64(
kKeyTime, ((int64_t)cts * 1000000) / mTimescale);
mBuffer->meta_data()->setInt64(
kKeyDuration, ((int64_t)stts * 1000000) / mTimescale);
if (targetSampleTimeUs >= 0) {
mBuffer->meta_data()->setInt64(
kKeyTargetTime, targetSampleTimeUs);
}
if (isSyncSample) {
mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);
}
++mCurrentSampleIndex;
*out = mBuffer;
mBuffer = NULL;
return OK;
}
}","status_t MPEG4Source::read(
MediaBuffer **VAR_0, const ReadOptions *VAR_1) {
Mutex::Autolock autoLock(mLock);
CHECK(VAR_2);
if (VAR_3 > 0) {
return fragmentedRead(VAR_0, VAR_1);
}
*VAR_0 = NULL;
int64_t VAR_4 = -1;
int64_t VAR_5;
ReadOptions::SeekMode VAR_6;
if (VAR_1 && VAR_1->getSeekTo(&VAR_5, &VAR_6)) {
uint32_t VAR_7 = 0;
switch (VAR_6) {
case ReadOptions::SEEK_PREVIOUS_SYNC:
VAR_7 = SampleTable::kFlagBefore;
break;
case ReadOptions::SEEK_NEXT_SYNC:
VAR_7 = SampleTable::kFlagAfter;
break;
case ReadOptions::SEEK_CLOSEST_SYNC:
case ReadOptions::SEEK_CLOSEST:
VAR_7 = SampleTable::kFlagClosest;
break;
default:
CHECK(!""Should not be here."");
break;
}
uint32_t VAR_8;
status_t VAR_9 = VAR_10->findSampleAtTime(
VAR_5, 1000000, VAR_11,
&VAR_8, VAR_7);
if (VAR_6 == ReadOptions::SEEK_CLOSEST) {
VAR_7 = SampleTable::kFlagBefore;
}
uint32_t VAR_12;
if (VAR_9 == VAR_13) {
VAR_9 = VAR_10->findSyncSampleNear(
VAR_8, &VAR_12, VAR_7);
}
uint32_t VAR_14;
if (VAR_9 == VAR_13) {
VAR_9 = VAR_10->getMetaDataForSample(
VAR_8, NULL, NULL, &VAR_14);
}
if (VAR_9 != VAR_13) {
if (VAR_9 == VAR_15) {
VAR_9 = VAR_16;
}
ALOGV(""end of stream"");
return VAR_9;
}
if (VAR_6 == ReadOptions::SEEK_CLOSEST) {
VAR_4 = (VAR_14 * 1000000ll) / VAR_11;
}
#if 0
uint32_t VAR_17;
CHECK_EQ(VAR_13, VAR_10->getMetaDataForSample(
VAR_12, NULL, NULL, &VAR_17));
ALOGI(""seek to time %lld us => sample at time %lld us, ""
""sync sample at time %lld us"",
VAR_5,
VAR_14 * 1000000ll / VAR_11,
VAR_17 * 1000000ll / VAR_11);
#endif
VAR_18 = VAR_12;
if (VAR_19 != NULL) {
VAR_19->release();
VAR_19 = NULL;
}
}
off64_t VAR_20;
size_t VAR_21;
uint32_t VAR_22, VAR_23;
bool VAR_24;
bool VAR_25 = false;
if (VAR_19 == NULL) {
VAR_25 = true;
status_t VAR_9 =
VAR_10->getMetaDataForSample(
VAR_18, &VAR_20, &VAR_21, &VAR_22, &VAR_24, &VAR_23);
if (VAR_9 != VAR_13) {
return VAR_9;
}
VAR_9 = VAR_26->acquire_buffer(&VAR_19);
if (VAR_9 != VAR_13) {
CHECK(VAR_19 == NULL);
return VAR_9;
}
if (VAR_21 > VAR_19->size()) {
ALOGE(""buffer too small: %zu > %zu"", VAR_21, VAR_19->size());
return VAR_27;
}
}
if ((!VAR_28 && !VAR_29) || VAR_30) {
if (VAR_25) {
ssize_t VAR_31 =
VAR_32->readAt(VAR_20, (uint8_t *)VAR_19->data(), VAR_21);
if (VAR_31 < (ssize_t)VAR_21) {
VAR_19->release();
VAR_19 = NULL;
return VAR_33;
}
CHECK(VAR_19 != NULL);
VAR_19->set_range(0, VAR_21);
VAR_19->meta_data()->clear();
VAR_19->meta_data()->setInt64(
VAR_34, ((int64_t)VAR_22 * 1000000) / VAR_11);
VAR_19->meta_data()->setInt64(
VAR_35, ((int64_t)VAR_23 * 1000000) / VAR_11);
if (VAR_4 >= 0) {
VAR_19->meta_data()->setInt64(
VAR_36, VAR_4);
}
if (VAR_24) {
VAR_19->meta_data()->setInt32(VAR_37, 1);
}
++VAR_18;
}
if (!VAR_28 && !VAR_29) {
*VAR_0 = VAR_19;
VAR_19 = NULL;
return VAR_13;
}
CHECK(VAR_19->range_length() >= VAR_38);
const uint8_t *VAR_39 =
(const uint8_t *)VAR_19->data() + VAR_19->range_offset();
size_t VAR_40 = parseNALSize(VAR_39);
if (VAR_38 > VAR_41 - VAR_40) {
ALOGE(""b/24441553, b/24445122"");
}
if (VAR_19->range_length() - VAR_38 < VAR_40) {
ALOGE(""incomplete NAL unit."");
VAR_19->release();
VAR_19 = NULL;
return VAR_42;
}
MediaBuffer *VAR_43 = VAR_19->clone();
CHECK(VAR_43 != NULL);
VAR_43->set_range(VAR_19->range_offset() + VAR_38, VAR_40);
CHECK(VAR_19 != NULL);
VAR_19->set_range(
VAR_19->range_offset() + VAR_38 + VAR_40,
VAR_19->range_length() - VAR_38 - VAR_40);
if (VAR_19->range_length() == 0) {
VAR_19->release();
VAR_19 = NULL;
}
*VAR_0 = VAR_43;
return VAR_13;
} else {
ssize_t VAR_31 = 0;
int32_t VAR_44 = 0;
bool VAR_45 = (VAR_46->findInt32(VAR_47, &VAR_44) && VAR_44 != 0);
if (VAR_45) {
VAR_31 =
VAR_32->readAt(VAR_20, (uint8_t*)VAR_19->data(), VAR_21);
} else {
VAR_31 = VAR_32->readAt(VAR_20, VAR_48, VAR_21);
}
if (VAR_31 < (ssize_t)VAR_21) {
VAR_19->release();
VAR_19 = NULL;
return VAR_33;
}
if (VAR_45) {
CHECK(VAR_19 != NULL);
VAR_19->set_range(0, VAR_21);
} else {
uint8_t *VAR_49 = (uint8_t *)VAR_19->data();
size_t VAR_50 = 0;
size_t VAR_51 = 0;
while (VAR_50 < VAR_21) {
bool VAR_52 = !isInRange((size_t)0u, VAR_21, VAR_50, VAR_38);
size_t VAR_53 = 0;
if (!VAR_52) {
VAR_53 = parseNALSize(&VAR_48[VAR_50]);
VAR_50 += VAR_38;
VAR_52 = !isInRange((size_t)0u, VAR_21, VAR_50, VAR_53);
}
if (VAR_52) {
ALOGE(""Video is malformed"");
VAR_19->release();
VAR_19 = NULL;
return VAR_42;
}
if (VAR_53 == 0) {
continue;
}
CHECK(VAR_51 + 4 <= VAR_19->size());
VAR_49[VAR_51++] = 0;
VAR_49[VAR_51++] = 0;
VAR_49[VAR_51++] = 0;
VAR_49[VAR_51++] = 1;
memcpy(&VAR_49[VAR_51], &VAR_48[VAR_50], VAR_53);
VAR_50 += VAR_53;
VAR_51 += VAR_53;
}
CHECK_EQ(VAR_50, VAR_21);
CHECK(VAR_19 != NULL);
VAR_19->set_range(0, VAR_51);
}
VAR_19->meta_data()->clear();
VAR_19->meta_data()->setInt64(
VAR_34, ((int64_t)VAR_22 * 1000000) / VAR_11);
VAR_19->meta_data()->setInt64(
VAR_35, ((int64_t)VAR_23 * 1000000) / VAR_11);
if (VAR_4 >= 0) {
VAR_19->meta_data()->setInt64(
VAR_36, VAR_4);
}
if (VAR_24) {
VAR_19->meta_data()->setInt32(VAR_37, 1);
}
++VAR_18;
*VAR_0 = VAR_19;
VAR_19 = NULL;
return VAR_13;
}
}",android/7a282fb64fef25349e9d341f102d9cea3bf75baf/MPEG4Extractor.cpp/vul/before/0.json,"status_t MPEG4Source::read(
        MediaBuffer **out, const ReadOptions *options) {
    Mutex::Autolock autoLock(mLock);

    CHECK(mStarted);

    if (mFirstMoofOffset > 0) {
        return fragmentedRead(out, options);
    }

    *out = NULL;

    int64_t targetSampleTimeUs = -1;

    int64_t seekTimeUs;
    ReadOptions::SeekMode mode;
    if (options && options->getSeekTo(&seekTimeUs, &mode)) {
        uint32_t findFlags = 0;
        switch (mode) {
            case ReadOptions::SEEK_PREVIOUS_SYNC:
                findFlags = SampleTable::kFlagBefore;
                break;
            case ReadOptions::SEEK_NEXT_SYNC:
                findFlags = SampleTable::kFlagAfter;
                break;
            case ReadOptions::SEEK_CLOSEST_SYNC:
            case ReadOptions::SEEK_CLOSEST:
                findFlags = SampleTable::kFlagClosest;
                break;
            default:
                CHECK(!""Should not be here."");
                break;
        }

        uint32_t sampleIndex;
        status_t err = mSampleTable->findSampleAtTime(
                seekTimeUs, 1000000, mTimescale,
                &sampleIndex, findFlags);

        if (mode == ReadOptions::SEEK_CLOSEST) {
            // We found the closest sample already, now we want the sync
            // sample preceding it (or the sample itself of course), even
            // if the subsequent sync sample is closer.
            findFlags = SampleTable::kFlagBefore;
        }

        uint32_t syncSampleIndex;
        if (err == OK) {
            err = mSampleTable->findSyncSampleNear(
                    sampleIndex, &syncSampleIndex, findFlags);
        }

        uint32_t sampleTime;
        if (err == OK) {
            err = mSampleTable->getMetaDataForSample(
                    sampleIndex, NULL, NULL, &sampleTime);
        }

        if (err != OK) {
            if (err == ERROR_OUT_OF_RANGE) {
                // An attempt to seek past the end of the stream would
                // normally cause this ERROR_OUT_OF_RANGE error. Propagating
                // this all the way to the MediaPlayer would cause abnormal
                // termination. Legacy behaviour appears to be to behave as if
                // we had seeked to the end of stream, ending normally.
                err = ERROR_END_OF_STREAM;
            }
            ALOGV(""end of stream"");
            return err;
        }

        if (mode == ReadOptions::SEEK_CLOSEST) {
            targetSampleTimeUs = (sampleTime * 1000000ll) / mTimescale;
        }

#if 0
        uint32_t syncSampleTime;
        CHECK_EQ(OK, mSampleTable->getMetaDataForSample(
                    syncSampleIndex, NULL, NULL, &syncSampleTime));

        ALOGI(""seek to time %lld us => sample at time %lld us, ""
             ""sync sample at time %lld us"",
             seekTimeUs,
             sampleTime * 1000000ll / mTimescale,
             syncSampleTime * 1000000ll / mTimescale);
#endif

        mCurrentSampleIndex = syncSampleIndex;
        if (mBuffer != NULL) {
            mBuffer->release();
            mBuffer = NULL;
        }

        // fall through
    }

    off64_t offset;
    size_t size;
    uint32_t cts, stts;
    bool isSyncSample;
    bool newBuffer = false;
    if (mBuffer == NULL) {
        newBuffer = true;

        status_t err =
            mSampleTable->getMetaDataForSample(
                    mCurrentSampleIndex, &offset, &size, &cts, &isSyncSample, &stts);

        if (err != OK) {
            return err;
        }

        err = mGroup->acquire_buffer(&mBuffer);

        if (err != OK) {
            CHECK(mBuffer == NULL);
            return err;
        }
        if (size > mBuffer->size()) {
            ALOGE(""buffer too small: %zu > %zu"", size, mBuffer->size());
            return ERROR_BUFFER_TOO_SMALL;
        }
    }

    if ((!mIsAVC && !mIsHEVC) || mWantsNALFragments) {
        if (newBuffer) {
            ssize_t num_bytes_read =
                mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);

            if (num_bytes_read < (ssize_t)size) {
                mBuffer->release();
                mBuffer = NULL;

                return ERROR_IO;
            }

            CHECK(mBuffer != NULL);
            mBuffer->set_range(0, size);
            mBuffer->meta_data()->clear();
            mBuffer->meta_data()->setInt64(
                    kKeyTime, ((int64_t)cts * 1000000) / mTimescale);
            mBuffer->meta_data()->setInt64(
                    kKeyDuration, ((int64_t)stts * 1000000) / mTimescale);

            if (targetSampleTimeUs >= 0) {
                mBuffer->meta_data()->setInt64(
                        kKeyTargetTime, targetSampleTimeUs);
            }

            if (isSyncSample) {
                mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);
            }

            ++mCurrentSampleIndex;
        }

        if (!mIsAVC && !mIsHEVC) {
            *out = mBuffer;
            mBuffer = NULL;

            return OK;
        }

        // Each NAL unit is split up into its constituent fragments and
        // each one of them returned in its own buffer.

        CHECK(mBuffer->range_length() >= mNALLengthSize);

        const uint8_t *src =
            (const uint8_t *)mBuffer->data() + mBuffer->range_offset();

        size_t nal_size = parseNALSize(src);
        if (mNALLengthSize > SIZE_MAX - nal_size) {
            ALOGE(""b/24441553, b/24445122"");
        }
        if (mBuffer->range_length() - mNALLengthSize < nal_size) {
            ALOGE(""incomplete NAL unit."");

            mBuffer->release();
            mBuffer = NULL;

            return ERROR_MALFORMED;
        }

        MediaBuffer *clone = mBuffer->clone();
        CHECK(clone != NULL);
        clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size);

        CHECK(mBuffer != NULL);
        mBuffer->set_range(
                mBuffer->range_offset() + mNALLengthSize + nal_size,
                mBuffer->range_length() - mNALLengthSize - nal_size);

        if (mBuffer->range_length() == 0) {
            mBuffer->release();
            mBuffer = NULL;
        }

        *out = clone;

        return OK;
    } else {
        // Whole NAL units are returned but each fragment is prefixed by
        // the start code (0x00 00 00 01).
        ssize_t num_bytes_read = 0;
        int32_t drm = 0;
        bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);
        if (usesDRM) {
            num_bytes_read =
                mDataSource->readAt(offset, (uint8_t*)mBuffer->data(), size);
        } else {
            num_bytes_read = mDataSource->readAt(offset, mSrcBuffer, size);
        }

        if (num_bytes_read < (ssize_t)size) {
            mBuffer->release();
            mBuffer = NULL;

            return ERROR_IO;
        }

        if (usesDRM) {
            CHECK(mBuffer != NULL);
            mBuffer->set_range(0, size);

        } else {
            uint8_t *dstData = (uint8_t *)mBuffer->data();
            size_t srcOffset = 0;
            size_t dstOffset = 0;

            while (srcOffset < size) {
                bool isMalFormed = !isInRange((size_t)0u, size, srcOffset, mNALLengthSize);
                size_t nalLength = 0;
                if (!isMalFormed) {
                    nalLength = parseNALSize(&mSrcBuffer[srcOffset]);
                    srcOffset += mNALLengthSize;
                    isMalFormed = !isInRange((size_t)0u, size, srcOffset, nalLength);
                }

                if (isMalFormed) {
                    ALOGE(""Video is malformed"");
                    mBuffer->release();
                    mBuffer = NULL;
                    return ERROR_MALFORMED;
                }

                if (nalLength == 0) {
                    continue;
                }

                if (dstOffset > SIZE_MAX - 4 ||
                        dstOffset + 4 > SIZE_MAX - nalLength ||
                        dstOffset + 4 + nalLength > mBuffer->size()) {
                    ALOGE(""b/27208621 : %zu %zu"", dstOffset, mBuffer->size());
                    android_errorWriteLog(0x534e4554, ""27208621"");
                    mBuffer->release();
                    mBuffer = NULL;
                    return ERROR_MALFORMED;
                }

                dstData[dstOffset++] = 0;
                dstData[dstOffset++] = 0;
                dstData[dstOffset++] = 0;
                dstData[dstOffset++] = 1;
                memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength);
                srcOffset += nalLength;
                dstOffset += nalLength;
            }
            CHECK_EQ(srcOffset, size);
            CHECK(mBuffer != NULL);
            mBuffer->set_range(0, dstOffset);
        }

        mBuffer->meta_data()->clear();
        mBuffer->meta_data()->setInt64(
                kKeyTime, ((int64_t)cts * 1000000) / mTimescale);
        mBuffer->meta_data()->setInt64(
                kKeyDuration, ((int64_t)stts * 1000000) / mTimescale);

        if (targetSampleTimeUs >= 0) {
            mBuffer->meta_data()->setInt64(
                    kKeyTargetTime, targetSampleTimeUs);
        }

        if (isSyncSample) {
            mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);
        }

        ++mCurrentSampleIndex;

        *out = mBuffer;
        mBuffer = NULL;

        return OK;
    }
}","status_t MPEG4Source::read(
        MediaBuffer **VAR_0, const ReadOptions *VAR_1) {
    Mutex::Autolock autoLock(mLock);

    CHECK(VAR_2);

    if (VAR_3 > 0) {
        return fragmentedRead(VAR_0, VAR_1);
    }

    *VAR_0 = NULL;

    int64_t VAR_4 = -1;

    int64_t VAR_5;
    ReadOptions::SeekMode VAR_6;
    if (VAR_1 && VAR_1->getSeekTo(&VAR_5, &VAR_6)) {
        uint32_t VAR_7 = 0;
        switch (VAR_6) {
            case ReadOptions::SEEK_PREVIOUS_SYNC:
                VAR_7 = SampleTable::kFlagBefore;
                break;
            case ReadOptions::SEEK_NEXT_SYNC:
                VAR_7 = SampleTable::kFlagAfter;
                break;
            case ReadOptions::SEEK_CLOSEST_SYNC:
            case ReadOptions::SEEK_CLOSEST:
                VAR_7 = SampleTable::kFlagClosest;
                break;
            default:
                CHECK(!""Should not be here."");
                break;
        }

        uint32_t VAR_8;
        status_t VAR_9 = VAR_10->findSampleAtTime(
                VAR_5, 1000000, VAR_11,
                &VAR_8, VAR_7);

        if (VAR_6 == ReadOptions::SEEK_CLOSEST) {
            /* COMMENT_0 */
            /* COMMENT_1 */
            /* COMMENT_2 */
            VAR_7 = SampleTable::kFlagBefore;
        }

        uint32_t VAR_12;
        if (VAR_9 == VAR_13) {
            VAR_9 = VAR_10->findSyncSampleNear(
                    VAR_8, &VAR_12, VAR_7);
        }

        uint32_t VAR_14;
        if (VAR_9 == VAR_13) {
            VAR_9 = VAR_10->getMetaDataForSample(
                    VAR_8, NULL, NULL, &VAR_14);
        }

        if (VAR_9 != VAR_13) {
            if (VAR_9 == VAR_15) {
                /* COMMENT_3 */
                /* COMMENT_4 */
                /* COMMENT_5 */
                /* COMMENT_6 */
                /* COMMENT_7 */
                VAR_9 = VAR_16;
            }
            ALOGV(""end of stream"");
            return VAR_9;
        }

        if (VAR_6 == ReadOptions::SEEK_CLOSEST) {
            VAR_4 = (VAR_14 * 1000000ll) / VAR_11;
        }

#if 0
        uint32_t VAR_17;
        CHECK_EQ(VAR_13, VAR_10->getMetaDataForSample(
                    VAR_12, NULL, NULL, &VAR_17));

        ALOGI(""seek to time %lld us => sample at time %lld us, ""
             ""sync sample at time %lld us"",
             VAR_5,
             VAR_14 * 1000000ll / VAR_11,
             VAR_17 * 1000000ll / VAR_11);
#endif

        VAR_18 = VAR_12;
        if (VAR_19 != NULL) {
            VAR_19->release();
            VAR_19 = NULL;
        }

        /* COMMENT_8 */
    }

    off64_t VAR_20;
    size_t VAR_21;
    uint32_t VAR_22, VAR_23;
    bool VAR_24;
    bool VAR_25 = false;
    if (VAR_19 == NULL) {
        VAR_25 = true;

        status_t VAR_9 =
            VAR_10->getMetaDataForSample(
                    VAR_18, &VAR_20, &VAR_21, &VAR_22, &VAR_24, &VAR_23);

        if (VAR_9 != VAR_13) {
            return VAR_9;
        }

        VAR_9 = VAR_26->acquire_buffer(&VAR_19);

        if (VAR_9 != VAR_13) {
            CHECK(VAR_19 == NULL);
            return VAR_9;
        }
        if (VAR_21 > VAR_19->size()) {
            ALOGE(""buffer too small: %zu > %zu"", VAR_21, VAR_19->size());
            return VAR_27;
        }
    }

    if ((!VAR_28 && !VAR_29) || VAR_30) {
        if (VAR_25) {
            ssize_t VAR_31 =
                VAR_32->readAt(VAR_20, (uint8_t *)VAR_19->data(), VAR_21);

            if (VAR_31 < (ssize_t)VAR_21) {
                VAR_19->release();
                VAR_19 = NULL;

                return VAR_33;
            }

            CHECK(VAR_19 != NULL);
            VAR_19->set_range(0, VAR_21);
            VAR_19->meta_data()->clear();
            VAR_19->meta_data()->setInt64(
                    VAR_34, ((int64_t)VAR_22 * 1000000) / VAR_11);
            VAR_19->meta_data()->setInt64(
                    VAR_35, ((int64_t)VAR_23 * 1000000) / VAR_11);

            if (VAR_4 >= 0) {
                VAR_19->meta_data()->setInt64(
                        VAR_36, VAR_4);
            }

            if (VAR_24) {
                VAR_19->meta_data()->setInt32(VAR_37, 1);
            }

            ++VAR_18;
        }

        if (!VAR_28 && !VAR_29) {
            *VAR_0 = VAR_19;
            VAR_19 = NULL;

            return VAR_13;
        }

        /* COMMENT_9 */
        /* COMMENT_10 */

        CHECK(VAR_19->range_length() >= VAR_38);

        const uint8_t *VAR_39 =
            (const uint8_t *)VAR_19->data() + VAR_19->range_offset();

        size_t VAR_40 = parseNALSize(VAR_39);
        if (VAR_38 > VAR_41 - VAR_40) {
            ALOGE(""b/24441553, b/24445122"");
        }
        if (VAR_19->range_length() - VAR_38 < VAR_40) {
            ALOGE(""incomplete NAL unit."");

            VAR_19->release();
            VAR_19 = NULL;

            return VAR_42;
        }

        MediaBuffer *VAR_43 = VAR_19->clone();
        CHECK(VAR_43 != NULL);
        VAR_43->set_range(VAR_19->range_offset() + VAR_38, VAR_40);

        CHECK(VAR_19 != NULL);
        VAR_19->set_range(
                VAR_19->range_offset() + VAR_38 + VAR_40,
                VAR_19->range_length() - VAR_38 - VAR_40);

        if (VAR_19->range_length() == 0) {
            VAR_19->release();
            VAR_19 = NULL;
        }

        *VAR_0 = VAR_43;

        return VAR_13;
    } else {
        /* COMMENT_11 */
        /* COMMENT_12 */
        ssize_t VAR_31 = 0;
        int32_t VAR_44 = 0;
        bool VAR_45 = (VAR_46->findInt32(VAR_47, &VAR_44) && VAR_44 != 0);
        if (VAR_45) {
            VAR_31 =
                VAR_32->readAt(VAR_20, (uint8_t*)VAR_19->data(), VAR_21);
        } else {
            VAR_31 = VAR_32->readAt(VAR_20, VAR_48, VAR_21);
        }

        if (VAR_31 < (ssize_t)VAR_21) {
            VAR_19->release();
            VAR_19 = NULL;

            return VAR_33;
        }

        if (VAR_45) {
            CHECK(VAR_19 != NULL);
            VAR_19->set_range(0, VAR_21);

        } else {
            uint8_t *VAR_49 = (uint8_t *)VAR_19->data();
            size_t VAR_50 = 0;
            size_t VAR_51 = 0;

            while (VAR_50 < VAR_21) {
                bool VAR_52 = !isInRange((size_t)0u, VAR_21, VAR_50, VAR_38);
                size_t VAR_53 = 0;
                if (!VAR_52) {
                    VAR_53 = parseNALSize(&VAR_48[VAR_50]);
                    VAR_50 += VAR_38;
                    VAR_52 = !isInRange((size_t)0u, VAR_21, VAR_50, VAR_53);
                }

                if (VAR_52) {
                    ALOGE(""Video is malformed"");
                    VAR_19->release();
                    VAR_19 = NULL;
                    return VAR_42;
                }

                if (VAR_53 == 0) {
                    continue;
                }

                if (VAR_51 > VAR_41 - 4 ||
                        VAR_51 + 4 > VAR_41 - VAR_53 ||
                        VAR_51 + 4 + VAR_53 > VAR_19->size()) {
                    ALOGE(""b/27208621 : %zu %zu"", VAR_51, VAR_19->size());
                    android_errorWriteLog(0x534e4554, ""27208621"");
                    VAR_19->release();
                    VAR_19 = NULL;
                    return VAR_42;
                }

                VAR_49[VAR_51++] = 0;
                VAR_49[VAR_51++] = 0;
                VAR_49[VAR_51++] = 0;
                VAR_49[VAR_51++] = 1;
                memcpy(&VAR_49[VAR_51], &VAR_48[VAR_50], VAR_53);
                VAR_50 += VAR_53;
                VAR_51 += VAR_53;
            }
            CHECK_EQ(VAR_50, VAR_21);
            CHECK(VAR_19 != NULL);
            VAR_19->set_range(0, VAR_51);
        }

        VAR_19->meta_data()->clear();
        VAR_19->meta_data()->setInt64(
                VAR_34, ((int64_t)VAR_22 * 1000000) / VAR_11);
        VAR_19->meta_data()->setInt64(
                VAR_35, ((int64_t)VAR_23 * 1000000) / VAR_11);

        if (VAR_4 >= 0) {
            VAR_19->meta_data()->setInt64(
                    VAR_36, VAR_4);
        }

        if (VAR_24) {
            VAR_19->meta_data()->setInt32(VAR_37, 1);
        }

        ++VAR_18;

        *VAR_0 = VAR_19;
        VAR_19 = NULL;

        return VAR_13;
    }
}",android/7a282fb64fef25349e9d341f102d9cea3bf75baf/MPEG4Extractor.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -248,7 +248,15 @@
                     continue;
                 }
 
-                CHECK(dstOffset + 4 <= mBuffer->size());
+                if (dstOffset > SIZE_MAX - 4 ||
+                        dstOffset + 4 > SIZE_MAX - nalLength ||
+                        dstOffset + 4 + nalLength > mBuffer->size()) {
+                    ALOGE(""b/27208621 : %zu %zu"", dstOffset, mBuffer->size());
+                    android_errorWriteLog(0x534e4554, ""27208621"");
+                    mBuffer->release();
+                    mBuffer = NULL;
+                    return ERROR_MALFORMED;
+                }
 
                 dstData[dstOffset++] = 0;
                 dstData[dstOffset++] = 0;","{'deleted_lines': ['                CHECK(dstOffset + 4 <= mBuffer->size());'], 'added_lines': ['                if (dstOffset > SIZE_MAX - 4 ||', '                        dstOffset + 4 > SIZE_MAX - nalLength ||', '                        dstOffset + 4 + nalLength > mBuffer->size()) {', '                    ALOGE(""b/27208621 : %zu %zu"", dstOffset, mBuffer->size());', '                    android_errorWriteLog(0x534e4554, ""27208621"");', '                    mBuffer->release();', '                    mBuffer = NULL;', '                    return ERROR_MALFORMED;', '                }']}",True,"MPEG4Extractor.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 allows remote attackers to execute arbitrary code or cause a denial of service (out-of-bounds read and memory corruption) via a crafted media file, aka internal bug 27208621.",9.8,CRITICAL,3,test,,5
CVE-2016-0840,['CWE-119'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,android,"Decoder: Fix stack underflow in CAVLC 4x4 parse functions

Bug: 26399350
Change-Id: Id768751672a7b093ab6e53d4fc0b3188d470920e
",c57fc3703ae2e0d41b1f6580c50015937f2d23c1,https://android.googlesource.com/platform/external/libavc/+/c57fc3703ae2e0d41b1f6580c50015937f2d23c1,decoder/ih264d_parse_cavlc.c,ih264d_cavlc_4x4res_block_totalcoeff_11to16,"WORD32 ih264d_cavlc_4x4res_block_totalcoeff_11to16(UWORD32 u4_isdc,
UWORD32 u4_total_coeff_trail_one, 
dec_bit_stream_t *ps_bitstrm )
{
UWORD32 u4_total_zeroes;
WORD32 i;
UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;
UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;
UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;
WORD16 i2_level_arr[16];
tu_sblk4x4_coeff_data_t *ps_tu_4x4;
WORD16 *pi2_coeff_data;
dec_struct_t *ps_dec = (dec_struct_t *)ps_bitstrm->pv_codec_handle;
ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;
ps_tu_4x4->u2_sig_coeff_map = 0;
pi2_coeff_data = &ps_tu_4x4->ai2_level[0];
i = u4_total_coeff - 1;
if(u4_trailing_ones)
{
UWORD32 u4_signs, u4_cnt = u4_trailing_ones;
WORD16 (*ppi2_trlone_lkup)[3] =
(WORD16 (*)[3])gai2_ih264d_trailing_one_level;
WORD16 *pi2_trlone_lkup;
GETBITS(u4_signs, u4_bitstream_offset, pu4_bitstrm_buf, u4_cnt);
pi2_trlone_lkup = ppi2_trlone_lkup[(1 << u4_cnt) - 2 + u4_signs];
while(u4_cnt--)
i2_level_arr[i--] = *pi2_trlone_lkup++;
}
if(i >= 0)
{
UWORD32 u4_lev_suffix, u4_suffix_len, u4_lev_suffix_size;
UWORD16 u2_lev_code, u2_abs_value;
UWORD32 u4_lev_prefix;
if(u4_trailing_ones < 3)
{
FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
pu4_bitstrm_buf);
u4_lev_suffix_size =
(15 <= u4_lev_prefix) ? (u4_lev_prefix - 3) : 1;
GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
u4_lev_suffix_size);
u2_lev_code = 2 + (MIN(u4_lev_prefix,15) << 1) + u4_lev_suffix;
if(16 <= u4_lev_prefix)
{
u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
}
}
else
{
FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
pu4_bitstrm_buf);
u2_lev_code = MIN(15, u4_lev_prefix);
u2_lev_code += (3 == u4_trailing_ones) ? 0 : (2);
if(14 == u4_lev_prefix)
u4_lev_suffix_size = 4;
else if(15 <= u4_lev_prefix)
{
u2_lev_code += 15;
u4_lev_suffix_size = (u4_lev_prefix - 3);
}
else
u4_lev_suffix_size = 0;
if(16 <= u4_lev_prefix)
{
u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
}
if(u4_lev_suffix_size)
{
GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
u4_lev_suffix_size);
u2_lev_code += u4_lev_suffix;
}
}
u2_abs_value = (u2_lev_code + 2) >> 1;
i2_level_arr[i--] = (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;
u4_suffix_len = (u2_abs_value > 3) ? 2 : 1;
while(i >= 0)
{
FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
pu4_bitstrm_buf);
u4_lev_suffix_size =
(15 <= u4_lev_prefix) ?
(u4_lev_prefix - 3) : u4_suffix_len;
GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
u4_lev_suffix_size);
u2_lev_code = (MIN(15,u4_lev_prefix) << u4_suffix_len)
+ u4_lev_suffix;
if(16 <= u4_lev_prefix)
{
u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
}
u2_abs_value = (u2_lev_code + 2) >> 1;
i2_level_arr[i--] =
(u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;
u4_suffix_len +=
(u4_suffix_len < 6) ?
(u2_abs_value
> (3
<< (u4_suffix_len
- 1))) :
0;
}
}
if(u4_total_coeff < (16 - u4_isdc))
{
UWORD32 u4_index;
const UWORD8 (*ppu1_total_zero_lkup)[16] =
(const UWORD8 (*)[16])gau1_ih264d_table_total_zero_11to15;
NEXTBITS(u4_index, u4_bitstream_offset, pu4_bitstrm_buf, 4);
u4_total_zeroes = ppu1_total_zero_lkup[u4_total_coeff - 11][u4_index];
FLUSHBITS(u4_bitstream_offset, (u4_total_zeroes >> 4));
u4_total_zeroes &= 0xf;
}
else
u4_total_zeroes = 0;
{
const UWORD8 *pu1_table_runbefore;
UWORD32 u4_run;
WORD32 k;
UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc;
WORD32 u4_zeroes_left = u4_total_zeroes;
k = u4_total_coeff - 1;
pu1_table_runbefore = (UWORD8 *)gau1_ih264d_table_run_before;
while((u4_zeroes_left > 0) && k)
{
UWORD32 u4_code;
NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);
u4_code = pu1_table_runbefore[u4_code + (u4_zeroes_left << 3)];
u4_run = u4_code >> 2;
FLUSHBITS(u4_bitstream_offset, (u4_code & 0x03));
SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
*pi2_coeff_data++ = i2_level_arr[k--];
u4_zeroes_left -= u4_run;
u4_scan_pos -= (u4_run + 1);
}
if(u4_zeroes_left < 0)
return -1;
while(k >= 0)
{
SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
*pi2_coeff_data++ = i2_level_arr[k--];
u4_scan_pos--;
}
}
{
WORD32 offset;
offset = (UWORD8 *)pi2_coeff_data - (UWORD8 *)ps_tu_4x4;
offset = ALIGN4(offset);
ps_dec->pv_parse_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_parse_tu_coeff_data + offset);
}
ps_bitstrm->u4_ofst = u4_bitstream_offset;
return 0;
}","WORD32 ih264d_cavlc_4x4res_block_totalcoeff_11to16(UWORD32 VAR_0,
UWORD32 VAR_1, 
dec_bit_stream_t *VAR_2 )
{
UWORD32 VAR_3;
WORD32 VAR_4;
UWORD32 *VAR_5 = VAR_2->pu4_buffer;
UWORD32 VAR_6 = VAR_2->u4_ofst;
UWORD32 VAR_7 = VAR_1 & 0xFFFF;
UWORD32 VAR_8 = VAR_1 >> 16;
WORD16 VAR_9[16];
tu_sblk4x4_coeff_data_t *VAR_10;
WORD16 *VAR_11;
dec_struct_t *VAR_12 = (dec_struct_t *)VAR_2->pv_codec_handle;
VAR_10 = (tu_sblk4x4_coeff_data_t *)VAR_12->pv_parse_tu_coeff_data;
VAR_10->u2_sig_coeff_map = 0;
VAR_11 = &VAR_10->ai2_level[0];
VAR_4 = VAR_8 - 1;
if(VAR_7)
{
UWORD32 VAR_13, VAR_14 = VAR_7;
WORD16 (*VAR_15)[3] =
(WORD16 (*)[3])VAR_16;
WORD16 *VAR_17;
GETBITS(VAR_13, VAR_6, VAR_5, VAR_14);
VAR_17 = VAR_15[(1 << VAR_14) - 2 + VAR_13];
while(VAR_14--)
VAR_9[VAR_4--] = *VAR_17++;
}
if(VAR_4 >= 0)
{
UWORD32 VAR_18, VAR_19, VAR_20;
UWORD16 VAR_21, VAR_22;
UWORD32 VAR_23;
if(VAR_7 < 3)
{
FIND_ONE_IN_STREAM_32(VAR_23, VAR_6,
VAR_5);
VAR_20 =
(15 <= VAR_23) ? (VAR_23 - 3) : 1;
GETBITS(VAR_18, VAR_6, VAR_5,
VAR_20);
VAR_21 = 2 + (MIN(VAR_23,15) << 1) + VAR_18;
if(16 <= VAR_23)
{
VAR_21 += ((1 << (VAR_23 - 3)) - 4096);
}
}
else
{
FIND_ONE_IN_STREAM_32(VAR_23, VAR_6,
VAR_5);
VAR_21 = MIN(15, VAR_23);
VAR_21 += (3 == VAR_7) ? 0 : (2);
if(14 == VAR_23)
VAR_20 = 4;
else if(15 <= VAR_23)
{
VAR_21 += 15;
VAR_20 = (VAR_23 - 3);
}
else
VAR_20 = 0;
if(16 <= VAR_23)
{
VAR_21 += ((1 << (VAR_23 - 3)) - 4096);
}
if(VAR_20)
{
GETBITS(VAR_18, VAR_6, VAR_5,
VAR_20);
VAR_21 += VAR_18;
}
}
VAR_22 = (VAR_21 + 2) >> 1;
VAR_9[VAR_4--] = (VAR_21 & 1) ? -VAR_22 : VAR_22;
VAR_19 = (VAR_22 > 3) ? 2 : 1;
while(VAR_4 >= 0)
{
FIND_ONE_IN_STREAM_32(VAR_23, VAR_6,
VAR_5);
VAR_20 =
(15 <= VAR_23) ?
(VAR_23 - 3) : VAR_19;
GETBITS(VAR_18, VAR_6, VAR_5,
VAR_20);
VAR_21 = (MIN(15,VAR_23) << VAR_19)
+ VAR_18;
if(16 <= VAR_23)
{
VAR_21 += ((1 << (VAR_23 - 3)) - 4096);
}
VAR_22 = (VAR_21 + 2) >> 1;
VAR_9[VAR_4--] =
(VAR_21 & 1) ? -VAR_22 : VAR_22;
VAR_19 +=
(VAR_19 < 6) ?
(VAR_22
> (3
<< (VAR_19
- 1))) :
0;
}
}
if(VAR_8 < (16 - VAR_0))
{
UWORD32 VAR_24;
const UWORD8 (*VAR_25)[16] =
(const UWORD8 (*)[16])VAR_26;
NEXTBITS(VAR_24, VAR_6, VAR_5, 4);
VAR_3 = VAR_25[VAR_8 - 11][VAR_24];
FLUSHBITS(VAR_6, (VAR_3 >> 4));
VAR_3 &= 0xf;
}
else
VAR_3 = 0;
{
const UWORD8 *VAR_27;
UWORD32 VAR_28;
WORD32 VAR_29;
UWORD32 VAR_30 = VAR_8 + VAR_3 - 1 + VAR_0;
WORD32 VAR_31 = VAR_3;
VAR_29 = VAR_8 - 1;
VAR_27 = (UWORD8 *)VAR_32;
while((VAR_31 > 0) && VAR_29)
{
UWORD32 VAR_33;
NEXTBITS(VAR_33, VAR_6, VAR_5, 3);
VAR_33 = VAR_27[VAR_33 + (VAR_31 << 3)];
VAR_28 = VAR_33 >> 2;
FLUSHBITS(VAR_6, (VAR_33 & 0x03));
SET_BIT(VAR_10->u2_sig_coeff_map, VAR_30);
*VAR_11++ = VAR_9[VAR_29--];
VAR_31 -= VAR_28;
VAR_30 -= (VAR_28 + 1);
}
if(VAR_31 < 0)
return -1;
while(VAR_29 >= 0)
{
SET_BIT(VAR_10->u2_sig_coeff_map, VAR_30);
*VAR_11++ = VAR_9[VAR_29--];
VAR_30--;
}
}
{
WORD32 VAR_34;
VAR_34 = (UWORD8 *)VAR_11 - (UWORD8 *)VAR_10;
VAR_34 = ALIGN4(VAR_34);
VAR_12->pv_parse_tu_coeff_data = (void *)((UWORD8 *)VAR_12->pv_parse_tu_coeff_data + VAR_34);
}
VAR_2->u4_ofst = VAR_6;
return 0;
}",android/c57fc3703ae2e0d41b1f6580c50015937f2d23c1/ih264d_parse_cavlc.c/vul/before/0.json,"WORD32 ih264d_cavlc_4x4res_block_totalcoeff_11to16(UWORD32 u4_isdc,
                                                UWORD32 u4_total_coeff_trail_one, /*!<TotalCoefficients<<16+trailingones*/
                                                dec_bit_stream_t *ps_bitstrm )
{
    UWORD32 u4_total_zeroes;
    WORD32 i;
    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
    UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;
    UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;
    UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;
    // To avoid error check at 4x4 level, allocating for 3 extra levels(16+3)
    // since u4_trailing_ones can at the max be 3. This will be required when
    // u4_total_coeff is less than u4_trailing_ones
    WORD16 ai2_level_arr[19];//
    WORD16 *i2_level_arr = &ai2_level_arr[3];

    tu_sblk4x4_coeff_data_t *ps_tu_4x4;
    WORD16 *pi2_coeff_data;
    dec_struct_t *ps_dec = (dec_struct_t *)ps_bitstrm->pv_codec_handle;

    ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;
    ps_tu_4x4->u2_sig_coeff_map = 0;
    pi2_coeff_data = &ps_tu_4x4->ai2_level[0];

    i = u4_total_coeff - 1;
    if(u4_trailing_ones)
    {
        /*********************************************************************/
        /* Decode Trailing Ones                                              */
        /* read the sign of T1's and put them in level array                 */
        /*********************************************************************/
        UWORD32 u4_signs, u4_cnt = u4_trailing_ones;
        WORD16 (*ppi2_trlone_lkup)[3] =
                        (WORD16 (*)[3])gai2_ih264d_trailing_one_level;
        WORD16 *pi2_trlone_lkup;

        GETBITS(u4_signs, u4_bitstream_offset, pu4_bitstrm_buf, u4_cnt);

        pi2_trlone_lkup = ppi2_trlone_lkup[(1 << u4_cnt) - 2 + u4_signs];

        while(u4_cnt--)
            i2_level_arr[i--] = *pi2_trlone_lkup++;
    }

    /****************************************************************/
    /* Decoding Levels Begins                                       */
    /****************************************************************/
    if(i >= 0)
    {
        /****************************************************************/
        /* First level is decoded outside the loop as it has lot of     */
        /* special cases.                                               */
        /****************************************************************/
        UWORD32 u4_lev_suffix, u4_suffix_len, u4_lev_suffix_size;
        UWORD16 u2_lev_code, u2_abs_value;
        UWORD32 u4_lev_prefix;

        if(u4_trailing_ones < 3)
        {
            /*********************************************************/
            /* u4_suffix_len = 1                                     */
            /*********************************************************/
            /***************************************************************/
            /* Find leading zeros in next 32 bits                          */
            /***************************************************************/
            FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
                                  pu4_bitstrm_buf);

            u4_lev_suffix_size =
                            (15 <= u4_lev_prefix) ? (u4_lev_prefix - 3) : 1;

            GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
                    u4_lev_suffix_size);
            u2_lev_code = 2 + (MIN(u4_lev_prefix,15) << 1) + u4_lev_suffix;

            //HP_LEVEL_PREFIX
            if(16 <= u4_lev_prefix)
            {
                u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
            }
        }
        else
        {
            /*********************************************************/
            /*u4_suffix_len = 0                                      */
            /*********************************************************/
            /***************************************************************/
            /* Find leading zeros in next 32 bits                          */
            /***************************************************************/
            FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
                                  pu4_bitstrm_buf);

            /*********************************************************/
            /* Special decoding case when trailing ones are 3        */
            /*********************************************************/
            u2_lev_code = MIN(15, u4_lev_prefix);

            u2_lev_code += (3 == u4_trailing_ones) ? 0 : (2);

            if(14 == u4_lev_prefix)
                u4_lev_suffix_size = 4;
            else if(15 <= u4_lev_prefix)
            {
                u2_lev_code += 15;
                u4_lev_suffix_size = (u4_lev_prefix - 3);
            }
            else
                u4_lev_suffix_size = 0;

            //HP_LEVEL_PREFIX
            if(16 <= u4_lev_prefix)
            {
                u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
            }
            if(u4_lev_suffix_size)
            {
                GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
                        u4_lev_suffix_size);
                u2_lev_code += u4_lev_suffix;
            }
        }

        u2_abs_value = (u2_lev_code + 2) >> 1;
        /*********************************************************/
        /* If Level code is odd, level is negative else positive */
        /*********************************************************/
        i2_level_arr[i--] = (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;

        u4_suffix_len = (u2_abs_value > 3) ? 2 : 1;

        /*********************************************************/
        /* Now loop over the remaining levels                    */
        /*********************************************************/
        while(i >= 0)
        {

            /***************************************************************/
            /* Find leading zeros in next 32 bits                          */
            /***************************************************************/
            FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
                                  pu4_bitstrm_buf);

            u4_lev_suffix_size =
                            (15 <= u4_lev_prefix) ?
                                            (u4_lev_prefix - 3) : u4_suffix_len;

            /*********************************************************/
            /* Compute level code using prefix and suffix            */
            /*********************************************************/
            GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
                    u4_lev_suffix_size);
            u2_lev_code = (MIN(15,u4_lev_prefix) << u4_suffix_len)
                            + u4_lev_suffix;

            //HP_LEVEL_PREFIX
            if(16 <= u4_lev_prefix)
            {
                u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
            }
            u2_abs_value = (u2_lev_code + 2) >> 1;

            /*********************************************************/
            /* If Level code is odd, level is negative else positive */
            /*********************************************************/
            i2_level_arr[i--] =
                            (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;

            /*********************************************************/
            /* Increment suffix length if required                   */
            /*********************************************************/
            u4_suffix_len +=
                            (u4_suffix_len < 6) ?
                                            (u2_abs_value
                                                            > (3
                                                                            << (u4_suffix_len
                                                                                            - 1))) :
                                            0;
        }

        /****************************************************************/
        /* Decoding Levels Ends                                         */
        /****************************************************************/
    }

    if(u4_total_coeff < (16 - u4_isdc))
    {
        UWORD32 u4_index;
        const UWORD8 (*ppu1_total_zero_lkup)[16] =
                        (const UWORD8 (*)[16])gau1_ih264d_table_total_zero_11to15;

        NEXTBITS(u4_index, u4_bitstream_offset, pu4_bitstrm_buf, 4);
        u4_total_zeroes = ppu1_total_zero_lkup[u4_total_coeff - 11][u4_index];

        FLUSHBITS(u4_bitstream_offset, (u4_total_zeroes >> 4));
        u4_total_zeroes &= 0xf;
    }
    else
        u4_total_zeroes = 0;

    /**************************************************************/
    /* Decode the runs and form the coefficient buffer            */
    /**************************************************************/
    {
        const UWORD8 *pu1_table_runbefore;
        UWORD32 u4_run;
        WORD32 k;
        UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc;
        WORD32 u4_zeroes_left = u4_total_zeroes;
        k = u4_total_coeff - 1;

        /**************************************************************/
        /* Decoding Runs for 0 < zeros left <=6                       */
        /**************************************************************/
        pu1_table_runbefore = (UWORD8 *)gau1_ih264d_table_run_before;
        while((u4_zeroes_left > 0) && k)
        {
            UWORD32 u4_code;
            NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);

            u4_code = pu1_table_runbefore[u4_code + (u4_zeroes_left << 3)];
            u4_run = u4_code >> 2;

            FLUSHBITS(u4_bitstream_offset, (u4_code & 0x03));
            SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
            *pi2_coeff_data++ = i2_level_arr[k--];
            u4_zeroes_left -= u4_run;
            u4_scan_pos -= (u4_run + 1);
        }
        /**************************************************************/
        /* Decoding Runs End                                          */
        /**************************************************************/

        /**************************************************************/
        /* Copy the remaining coefficients                            */
        /**************************************************************/
        if(u4_zeroes_left < 0)
            return -1;
        while(k >= 0)
        {
            SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
            *pi2_coeff_data++ = i2_level_arr[k--];
            u4_scan_pos--;
        }
    }

    {
        WORD32 offset;
        offset = (UWORD8 *)pi2_coeff_data - (UWORD8 *)ps_tu_4x4;
        offset = ALIGN4(offset);
        ps_dec->pv_parse_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_parse_tu_coeff_data + offset);
    }

    ps_bitstrm->u4_ofst = u4_bitstream_offset;
    return 0;
}","WORD32 ih264d_cavlc_4x4res_block_totalcoeff_11to16(UWORD32 VAR_0,
                                                UWORD32 VAR_1, /* COMMENT_0 */
                                                dec_bit_stream_t *VAR_2 )
{
    UWORD32 VAR_3;
    WORD32 VAR_4;
    UWORD32 *VAR_5 = VAR_2->pu4_buffer;
    UWORD32 VAR_6 = VAR_2->u4_ofst;
    UWORD32 VAR_7 = VAR_1 & 0xFFFF;
    UWORD32 VAR_8 = VAR_1 >> 16;
    /* COMMENT_1 */
    /* COMMENT_2 */
    /* COMMENT_3 */
    WORD16 VAR_9[19];/* COMMENT_4 */
    WORD16 *VAR_10 = &VAR_9[3];

    tu_sblk4x4_coeff_data_t *VAR_11;
    WORD16 *VAR_12;
    dec_struct_t *VAR_13 = (dec_struct_t *)VAR_2->pv_codec_handle;

    VAR_11 = (tu_sblk4x4_coeff_data_t *)VAR_13->pv_parse_tu_coeff_data;
    VAR_11->u2_sig_coeff_map = 0;
    VAR_12 = &VAR_11->ai2_level[0];

    VAR_4 = VAR_8 - 1;
    if(VAR_7)
    {
        /* COMMENT_5 */
        /* COMMENT_6 */
        /* COMMENT_7 */
        /* COMMENT_5 */
        UWORD32 VAR_14, VAR_15 = VAR_7;
        WORD16 (*VAR_16)[3] =
                        (WORD16 (*)[3])VAR_17;
        WORD16 *VAR_18;

        GETBITS(VAR_14, VAR_6, VAR_5, VAR_15);

        VAR_18 = VAR_16[(1 << VAR_15) - 2 + VAR_14];

        while(VAR_15--)
            VAR_10[VAR_4--] = *VAR_18++;
    }

    /* COMMENT_8 */
    /* COMMENT_9 */
    /* COMMENT_8 */
    if(VAR_4 >= 0)
    {
        /* COMMENT_8 */
        /* COMMENT_10 */
        /* COMMENT_11 */
        /* COMMENT_8 */
        UWORD32 VAR_19, VAR_20, VAR_21;
        UWORD16 VAR_22, VAR_23;
        UWORD32 VAR_24;

        if(VAR_7 < 3)
        {
            /* COMMENT_12 */
            /* COMMENT_13 */
            /* COMMENT_12 */
            /* COMMENT_14 */
            /* COMMENT_15 */
            /* COMMENT_14 */
            FIND_ONE_IN_STREAM_32(VAR_24, VAR_6,
                                  VAR_5);

            VAR_21 =
                            (15 <= VAR_24) ? (VAR_24 - 3) : 1;

            GETBITS(VAR_19, VAR_6, VAR_5,
                    VAR_21);
            VAR_22 = 2 + (MIN(VAR_24,15) << 1) + VAR_19;

            /* COMMENT_16 */
            if(16 <= VAR_24)
            {
                VAR_22 += ((1 << (VAR_24 - 3)) - 4096);
            }
        }
        else
        {
            /* COMMENT_12 */
            /* COMMENT_17 */
            /* COMMENT_12 */
            /* COMMENT_14 */
            /* COMMENT_15 */
            /* COMMENT_14 */
            FIND_ONE_IN_STREAM_32(VAR_24, VAR_6,
                                  VAR_5);

            /* COMMENT_12 */
            /* COMMENT_18 */
            /* COMMENT_12 */
            VAR_22 = MIN(15, VAR_24);

            VAR_22 += (3 == VAR_7) ? 0 : (2);

            if(14 == VAR_24)
                VAR_21 = 4;
            else if(15 <= VAR_24)
            {
                VAR_22 += 15;
                VAR_21 = (VAR_24 - 3);
            }
            else
                VAR_21 = 0;

            /* COMMENT_16 */
            if(16 <= VAR_24)
            {
                VAR_22 += ((1 << (VAR_24 - 3)) - 4096);
            }
            if(VAR_21)
            {
                GETBITS(VAR_19, VAR_6, VAR_5,
                        VAR_21);
                VAR_22 += VAR_19;
            }
        }

        VAR_23 = (VAR_22 + 2) >> 1;
        /* COMMENT_12 */
        /* COMMENT_19 */
        /* COMMENT_12 */
        VAR_10[VAR_4--] = (VAR_22 & 1) ? -VAR_23 : VAR_23;

        VAR_20 = (VAR_23 > 3) ? 2 : 1;

        /* COMMENT_12 */
        /* COMMENT_20 */
        /* COMMENT_12 */
        while(VAR_4 >= 0)
        {

            /* COMMENT_14 */
            /* COMMENT_15 */
            /* COMMENT_14 */
            FIND_ONE_IN_STREAM_32(VAR_24, VAR_6,
                                  VAR_5);

            VAR_21 =
                            (15 <= VAR_24) ?
                                            (VAR_24 - 3) : VAR_20;

            /* COMMENT_12 */
            /* COMMENT_21 */
            /* COMMENT_12 */
            GETBITS(VAR_19, VAR_6, VAR_5,
                    VAR_21);
            VAR_22 = (MIN(15,VAR_24) << VAR_20)
                            + VAR_19;

            /* COMMENT_16 */
            if(16 <= VAR_24)
            {
                VAR_22 += ((1 << (VAR_24 - 3)) - 4096);
            }
            VAR_23 = (VAR_22 + 2) >> 1;

            /* COMMENT_12 */
            /* COMMENT_19 */
            /* COMMENT_12 */
            VAR_10[VAR_4--] =
                            (VAR_22 & 1) ? -VAR_23 : VAR_23;

            /* COMMENT_12 */
            /* COMMENT_22 */
            /* COMMENT_12 */
            VAR_20 +=
                            (VAR_20 < 6) ?
                                            (VAR_23
                                                            > (3
                                                                            << (VAR_20
                                                                                            - 1))) :
                                            0;
        }

        /* COMMENT_8 */
        /* COMMENT_23 */
        /* COMMENT_8 */
    }

    if(VAR_8 < (16 - VAR_0))
    {
        UWORD32 VAR_25;
        const UWORD8 (*VAR_26)[16] =
                        (const UWORD8 (*)[16])VAR_27;

        NEXTBITS(VAR_25, VAR_6, VAR_5, 4);
        VAR_3 = VAR_26[VAR_8 - 11][VAR_25];

        FLUSHBITS(VAR_6, (VAR_3 >> 4));
        VAR_3 &= 0xf;
    }
    else
        VAR_3 = 0;

    /* COMMENT_24 */
    /* COMMENT_25 */
    /* COMMENT_24 */
    {
        const UWORD8 *VAR_28;
        UWORD32 VAR_29;
        WORD32 VAR_30;
        UWORD32 VAR_31 = VAR_8 + VAR_3 - 1 + VAR_0;
        WORD32 VAR_32 = VAR_3;
        VAR_30 = VAR_8 - 1;

        /* COMMENT_24 */
        /* COMMENT_26 */
        /* COMMENT_24 */
        VAR_28 = (UWORD8 *)VAR_33;
        while((VAR_32 > 0) && VAR_30)
        {
            UWORD32 VAR_34;
            NEXTBITS(VAR_34, VAR_6, VAR_5, 3);

            VAR_34 = VAR_28[VAR_34 + (VAR_32 << 3)];
            VAR_29 = VAR_34 >> 2;

            FLUSHBITS(VAR_6, (VAR_34 & 0x03));
            SET_BIT(VAR_11->u2_sig_coeff_map, VAR_31);
            *VAR_12++ = VAR_10[VAR_30--];
            VAR_32 -= VAR_29;
            VAR_31 -= (VAR_29 + 1);
        }
        /* COMMENT_24 */
        /* COMMENT_27 */
        /* COMMENT_24 */

        /* COMMENT_24 */
        /* COMMENT_28 */
        /* COMMENT_24 */
        if(VAR_32 < 0)
            return -1;
        while(VAR_30 >= 0)
        {
            SET_BIT(VAR_11->u2_sig_coeff_map, VAR_31);
            *VAR_12++ = VAR_10[VAR_30--];
            VAR_31--;
        }
    }

    {
        WORD32 VAR_35;
        VAR_35 = (UWORD8 *)VAR_12 - (UWORD8 *)VAR_11;
        VAR_35 = ALIGN4(VAR_35);
        VAR_13->pv_parse_tu_coeff_data = (void *)((UWORD8 *)VAR_13->pv_parse_tu_coeff_data + VAR_35);
    }

    VAR_2->u4_ofst = VAR_6;
    return 0;
}",android/c57fc3703ae2e0d41b1f6580c50015937f2d23c1/ih264d_parse_cavlc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,7 +8,11 @@
     UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;
     UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;
     UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;
-    WORD16 i2_level_arr[16];
+    // To avoid error check at 4x4 level, allocating for 3 extra levels(16+3)
+    // since u4_trailing_ones can at the max be 3. This will be required when
+    // u4_total_coeff is less than u4_trailing_ones
+    WORD16 ai2_level_arr[19];//
+    WORD16 *i2_level_arr = &ai2_level_arr[3];
 
     tu_sblk4x4_coeff_data_t *ps_tu_4x4;
     WORD16 *pi2_coeff_data;","{'deleted_lines': ['    WORD16 i2_level_arr[16];'], 'added_lines': ['    // To avoid error check at 4x4 level, allocating for 3 extra levels(16+3)', '    // since u4_trailing_ones can at the max be 3. This will be required when', '    // u4_total_coeff is less than u4_trailing_ones', '    WORD16 ai2_level_arr[19];//', '    WORD16 *i2_level_arr = &ai2_level_arr[3];']}",True,"Multiple stack-based buffer underflows in decoder/ih264d_parse_cavlc.c in mediaserver in Android 6.x before 2016-04-01 allow remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 26399350.",8.4,HIGH,2,test,,5
CVE-2016-0840,['CWE-119'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,android,"Decoder: Fix stack underflow in CAVLC 4x4 parse functions

Bug: 26399350
Change-Id: Id768751672a7b093ab6e53d4fc0b3188d470920e
",c57fc3703ae2e0d41b1f6580c50015937f2d23c1,https://android.googlesource.com/platform/external/libavc/+/c57fc3703ae2e0d41b1f6580c50015937f2d23c1,decoder/ih264d_parse_cavlc.c,ih264d_rest_of_residual_cav_chroma_dc_block,"void ih264d_rest_of_residual_cav_chroma_dc_block(UWORD32 u4_total_coeff_trail_one,
dec_bit_stream_t *ps_bitstrm)
{
UWORD32 u4_total_zeroes;
WORD16 i;
UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;
UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;
UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;
WORD16 i2_level_arr[4];
tu_sblk4x4_coeff_data_t *ps_tu_4x4;
WORD16 *pi2_coeff_data;
dec_struct_t *ps_dec = (dec_struct_t *)ps_bitstrm->pv_codec_handle;
ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;
ps_tu_4x4->u2_sig_coeff_map = 0;
pi2_coeff_data = &ps_tu_4x4->ai2_level[0];
i = u4_total_coeff - 1;
if(u4_trailing_ones)
{
UWORD32 u4_signs, u4_cnt = u4_trailing_ones;
WORD16 (*ppi2_trlone_lkup)[3] =
(WORD16 (*)[3])gai2_ih264d_trailing_one_level;
WORD16 *pi2_trlone_lkup;
GETBITS(u4_signs, u4_bitstream_offset, pu4_bitstrm_buf, u4_cnt);
pi2_trlone_lkup = ppi2_trlone_lkup[(1 << u4_cnt) - 2 + u4_signs];
while(u4_cnt--)
i2_level_arr[i--] = *pi2_trlone_lkup++;
}
if(i >= 0)
{
UWORD32 u4_lev_suffix, u4_suffix_len, u4_lev_suffix_size;
UWORD16 u2_lev_code, u2_abs_value;
UWORD32 u4_lev_prefix;
FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
pu4_bitstrm_buf);
u2_lev_code = MIN(15, u4_lev_prefix);
u2_lev_code += (3 == u4_trailing_ones) ? 0 : (2);
if(14 == u4_lev_prefix)
u4_lev_suffix_size = 4;
else if(15 <= u4_lev_prefix)
{
u2_lev_code += 15;
u4_lev_suffix_size = u4_lev_prefix - 3;
}
else
u4_lev_suffix_size = 0;
if(16 <= u4_lev_prefix)
{
u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
}
if(u4_lev_suffix_size)
{
GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
u4_lev_suffix_size);
u2_lev_code += u4_lev_suffix;
}
u2_abs_value = (u2_lev_code + 2) >> 1;
i2_level_arr[i--] = (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;
u4_suffix_len = (u2_abs_value > 3) ? 2 : 1;
while(i >= 0)
{
FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
pu4_bitstrm_buf);
u4_lev_suffix_size =
(15 <= u4_lev_prefix) ?
(u4_lev_prefix - 3) : u4_suffix_len;
GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
u4_lev_suffix_size);
u2_lev_code = (MIN(u4_lev_prefix,15) << u4_suffix_len)
+ u4_lev_suffix;
if(16 <= u4_lev_prefix)
{
u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
}
u2_abs_value = (u2_lev_code + 2) >> 1;
i2_level_arr[i--] =
(u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;
u4_suffix_len += (u2_abs_value > (3 << (u4_suffix_len - 1)));
}
}
if(u4_total_coeff < 4)
{
UWORD32 u4_max_ldz = (4 - u4_total_coeff);
FIND_ONE_IN_STREAM_LEN(u4_total_zeroes, u4_bitstream_offset,
pu4_bitstrm_buf, u4_max_ldz);
}
else
u4_total_zeroes = 0;
{
const UWORD8 *pu1_table_runbefore;
UWORD32 u4_run;
UWORD32 u4_scan_pos = (u4_total_coeff + u4_total_zeroes - 1);
UWORD32 u4_zeroes_left = u4_total_zeroes;
i = u4_total_coeff - 1;
pu1_table_runbefore = (UWORD8 *)gau1_ih264d_table_run_before;
while(u4_zeroes_left && i)
{
UWORD32 u4_code;
NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);
u4_code = pu1_table_runbefore[u4_code + (u4_zeroes_left << 3)];
u4_run = u4_code >> 2;
FLUSHBITS(u4_bitstream_offset, (u4_code & 0x03));
SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
*pi2_coeff_data++ = i2_level_arr[i--];
u4_zeroes_left -= u4_run;
u4_scan_pos -= (u4_run + 1);
}
while(i >= 0)
{
SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
*pi2_coeff_data++ = i2_level_arr[i--];
u4_scan_pos--;
}
}
{
WORD32 offset;
offset = (UWORD8 *)pi2_coeff_data - (UWORD8 *)ps_tu_4x4;
offset = ALIGN4(offset);
ps_dec->pv_parse_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_parse_tu_coeff_data + offset);
}
ps_bitstrm->u4_ofst = u4_bitstream_offset;
}","void ih264d_rest_of_residual_cav_chroma_dc_block(UWORD32 VAR_0,
dec_bit_stream_t *VAR_1)
{
UWORD32 VAR_2;
WORD16 VAR_3;
UWORD32 *VAR_4 = VAR_1->pu4_buffer;
UWORD32 VAR_5 = VAR_1->u4_ofst;
UWORD32 VAR_6 = VAR_0 & 0xFFFF;
UWORD32 VAR_7 = VAR_0 >> 16;
WORD16 VAR_8[4];
tu_sblk4x4_coeff_data_t *VAR_9;
WORD16 *VAR_10;
dec_struct_t *VAR_11 = (dec_struct_t *)VAR_1->pv_codec_handle;
VAR_9 = (tu_sblk4x4_coeff_data_t *)VAR_11->pv_parse_tu_coeff_data;
VAR_9->u2_sig_coeff_map = 0;
VAR_10 = &VAR_9->ai2_level[0];
VAR_3 = VAR_7 - 1;
if(VAR_6)
{
UWORD32 VAR_12, VAR_13 = VAR_6;
WORD16 (*VAR_14)[3] =
(WORD16 (*)[3])VAR_15;
WORD16 *VAR_16;
GETBITS(VAR_12, VAR_5, VAR_4, VAR_13);
VAR_16 = VAR_14[(1 << VAR_13) - 2 + VAR_12];
while(VAR_13--)
VAR_8[VAR_3--] = *VAR_16++;
}
if(VAR_3 >= 0)
{
UWORD32 VAR_17, VAR_18, VAR_19;
UWORD16 VAR_20, VAR_21;
UWORD32 VAR_22;
FIND_ONE_IN_STREAM_32(VAR_22, VAR_5,
VAR_4);
VAR_20 = MIN(15, VAR_22);
VAR_20 += (3 == VAR_6) ? 0 : (2);
if(14 == VAR_22)
VAR_19 = 4;
else if(15 <= VAR_22)
{
VAR_20 += 15;
VAR_19 = VAR_22 - 3;
}
else
VAR_19 = 0;
if(16 <= VAR_22)
{
VAR_20 += ((1 << (VAR_22 - 3)) - 4096);
}
if(VAR_19)
{
GETBITS(VAR_17, VAR_5, VAR_4,
VAR_19);
VAR_20 += VAR_17;
}
VAR_21 = (VAR_20 + 2) >> 1;
VAR_8[VAR_3--] = (VAR_20 & 1) ? -VAR_21 : VAR_21;
VAR_18 = (VAR_21 > 3) ? 2 : 1;
while(VAR_3 >= 0)
{
FIND_ONE_IN_STREAM_32(VAR_22, VAR_5,
VAR_4);
VAR_19 =
(15 <= VAR_22) ?
(VAR_22 - 3) : VAR_18;
GETBITS(VAR_17, VAR_5, VAR_4,
VAR_19);
VAR_20 = (MIN(VAR_22,15) << VAR_18)
+ VAR_17;
if(16 <= VAR_22)
{
VAR_20 += ((1 << (VAR_22 - 3)) - 4096);
}
VAR_21 = (VAR_20 + 2) >> 1;
VAR_8[VAR_3--] =
(VAR_20 & 1) ? -VAR_21 : VAR_21;
VAR_18 += (VAR_21 > (3 << (VAR_18 - 1)));
}
}
if(VAR_7 < 4)
{
UWORD32 VAR_23 = (4 - VAR_7);
FIND_ONE_IN_STREAM_LEN(VAR_2, VAR_5,
VAR_4, VAR_23);
}
else
VAR_2 = 0;
{
const UWORD8 *VAR_24;
UWORD32 VAR_25;
UWORD32 VAR_26 = (VAR_7 + VAR_2 - 1);
UWORD32 VAR_27 = VAR_2;
VAR_3 = VAR_7 - 1;
VAR_24 = (UWORD8 *)VAR_28;
while(VAR_27 && VAR_3)
{
UWORD32 VAR_29;
NEXTBITS(VAR_29, VAR_5, VAR_4, 3);
VAR_29 = VAR_24[VAR_29 + (VAR_27 << 3)];
VAR_25 = VAR_29 >> 2;
FLUSHBITS(VAR_5, (VAR_29 & 0x03));
SET_BIT(VAR_9->u2_sig_coeff_map, VAR_26);
*VAR_10++ = VAR_8[VAR_3--];
VAR_27 -= VAR_25;
VAR_26 -= (VAR_25 + 1);
}
while(VAR_3 >= 0)
{
SET_BIT(VAR_9->u2_sig_coeff_map, VAR_26);
*VAR_10++ = VAR_8[VAR_3--];
VAR_26--;
}
}
{
WORD32 VAR_30;
VAR_30 = (UWORD8 *)VAR_10 - (UWORD8 *)VAR_9;
VAR_30 = ALIGN4(VAR_30);
VAR_11->pv_parse_tu_coeff_data = (void *)((UWORD8 *)VAR_11->pv_parse_tu_coeff_data + VAR_30);
}
VAR_1->u4_ofst = VAR_5;
}",android/c57fc3703ae2e0d41b1f6580c50015937f2d23c1/ih264d_parse_cavlc.c/vul/before/1.json,"void ih264d_rest_of_residual_cav_chroma_dc_block(UWORD32 u4_total_coeff_trail_one,
                                                 dec_bit_stream_t *ps_bitstrm)
{
    UWORD32 u4_total_zeroes;
    WORD16 i;
    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
    UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;
    UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;
    UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;
    // To avoid error check at 4x4 level, allocating for 3 extra levels(4+3)
    // since u4_trailing_ones can at the max be 3. This will be required when
    // u4_total_coeff is less than u4_trailing_ones
    WORD16 ai2_level_arr[7];//
    WORD16 *i2_level_arr = &ai2_level_arr[3];

    tu_sblk4x4_coeff_data_t *ps_tu_4x4;
    WORD16 *pi2_coeff_data;
    dec_struct_t *ps_dec = (dec_struct_t *)ps_bitstrm->pv_codec_handle;

    ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;
    ps_tu_4x4->u2_sig_coeff_map = 0;
    pi2_coeff_data = &ps_tu_4x4->ai2_level[0];

    i = u4_total_coeff - 1;
    if(u4_trailing_ones)
    {
        /*********************************************************************/
        /* Decode Trailing Ones                                              */
        /* read the sign of T1's and put them in level array                 */
        /*********************************************************************/
        UWORD32 u4_signs, u4_cnt = u4_trailing_ones;
        WORD16 (*ppi2_trlone_lkup)[3] =
                        (WORD16 (*)[3])gai2_ih264d_trailing_one_level;
        WORD16 *pi2_trlone_lkup;

        GETBITS(u4_signs, u4_bitstream_offset, pu4_bitstrm_buf, u4_cnt);

        pi2_trlone_lkup = ppi2_trlone_lkup[(1 << u4_cnt) - 2 + u4_signs];

        while(u4_cnt--)
            i2_level_arr[i--] = *pi2_trlone_lkup++;
    }

    /****************************************************************/
    /* Decoding Levels Begins                                       */
    /****************************************************************/
    if(i >= 0)
    {
        /****************************************************************/
        /* First level is decoded outside the loop as it has lot of     */
        /* special cases.                                               */
        /****************************************************************/
        UWORD32 u4_lev_suffix, u4_suffix_len, u4_lev_suffix_size;
        UWORD16 u2_lev_code, u2_abs_value;
        UWORD32 u4_lev_prefix;

        /***************************************************************/
        /* u4_suffix_len = 0,  Find leading zeros in next 32 bits      */
        /***************************************************************/
        FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
                              pu4_bitstrm_buf);

        /*********************************************************/
        /* Special decoding case when trailing ones are 3        */
        /*********************************************************/
        u2_lev_code = MIN(15, u4_lev_prefix);

        u2_lev_code += (3 == u4_trailing_ones) ? 0 : (2);

        if(14 == u4_lev_prefix)
            u4_lev_suffix_size = 4;
        else if(15 <= u4_lev_prefix)
        {
            u2_lev_code += 15;
            u4_lev_suffix_size = u4_lev_prefix - 3;
        }
        else
            u4_lev_suffix_size = 0;

        //HP_LEVEL_PREFIX
        if(16 <= u4_lev_prefix)
        {
            u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
        }
        if(u4_lev_suffix_size)
        {
            GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
                    u4_lev_suffix_size);
            u2_lev_code += u4_lev_suffix;
        }

        u2_abs_value = (u2_lev_code + 2) >> 1;
        /*********************************************************/
        /* If Level code is odd, level is negative else positive */
        /*********************************************************/
        i2_level_arr[i--] = (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;

        u4_suffix_len = (u2_abs_value > 3) ? 2 : 1;

        /*********************************************************/
        /* Now loop over the remaining levels                    */
        /*********************************************************/
        while(i >= 0)
        {

            /***************************************************************/
            /* Find leading zeros in next 32 bits                          */
            /***************************************************************/
            FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
                                  pu4_bitstrm_buf);

            u4_lev_suffix_size =
                            (15 <= u4_lev_prefix) ?
                                            (u4_lev_prefix - 3) : u4_suffix_len;

            /*********************************************************/
            /* Compute level code using prefix and suffix            */
            /*********************************************************/
            GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
                    u4_lev_suffix_size);
            u2_lev_code = (MIN(u4_lev_prefix,15) << u4_suffix_len)
                            + u4_lev_suffix;

            //HP_LEVEL_PREFIX
            if(16 <= u4_lev_prefix)
            {
                u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
            }
            u2_abs_value = (u2_lev_code + 2) >> 1;

            /*********************************************************/
            /* If Level code is odd, level is negative else positive */
            /*********************************************************/
            i2_level_arr[i--] =
                            (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;

            /*********************************************************/
            /* Increment suffix length if required                   */
            /*********************************************************/
            u4_suffix_len += (u2_abs_value > (3 << (u4_suffix_len - 1)));
        }

        /****************************************************************/
        /* Decoding Levels Ends                                         */
        /****************************************************************/
    }

    if(u4_total_coeff < 4)
    {
        UWORD32 u4_max_ldz = (4 - u4_total_coeff);
        FIND_ONE_IN_STREAM_LEN(u4_total_zeroes, u4_bitstream_offset,
                               pu4_bitstrm_buf, u4_max_ldz);
    }
    else
        u4_total_zeroes = 0;

    /**************************************************************/
    /* Decode the runs and form the coefficient buffer            */
    /**************************************************************/
    {
        const UWORD8 *pu1_table_runbefore;
        UWORD32 u4_run;
        UWORD32 u4_scan_pos = (u4_total_coeff + u4_total_zeroes - 1);
        UWORD32 u4_zeroes_left = u4_total_zeroes;
        i = u4_total_coeff - 1;

        /**************************************************************/
        /* Decoding Runs for 0 < zeros left <=6                       */
        /**************************************************************/
        pu1_table_runbefore = (UWORD8 *)gau1_ih264d_table_run_before;
        while(u4_zeroes_left && i)
        {
            UWORD32 u4_code;
            NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);

            u4_code = pu1_table_runbefore[u4_code + (u4_zeroes_left << 3)];
            u4_run = u4_code >> 2;

            FLUSHBITS(u4_bitstream_offset, (u4_code & 0x03));
            SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
            *pi2_coeff_data++ = i2_level_arr[i--];
            u4_zeroes_left -= u4_run;
            u4_scan_pos -= (u4_run + 1);
        }
        /**************************************************************/
        /* Decoding Runs End                                          */
        /**************************************************************/

        /**************************************************************/
        /* Copy the remaining coefficients                            */
        /**************************************************************/
        while(i >= 0)
        {
            SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
            *pi2_coeff_data++ = i2_level_arr[i--];
            u4_scan_pos--;
        }
    }

    {
        WORD32 offset;
        offset = (UWORD8 *)pi2_coeff_data - (UWORD8 *)ps_tu_4x4;
        offset = ALIGN4(offset);
        ps_dec->pv_parse_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_parse_tu_coeff_data + offset);
    }

    ps_bitstrm->u4_ofst = u4_bitstream_offset;
}","void ih264d_rest_of_residual_cav_chroma_dc_block(UWORD32 VAR_0,
                                                 dec_bit_stream_t *VAR_1)
{
    UWORD32 VAR_2;
    WORD16 VAR_3;
    UWORD32 *VAR_4 = VAR_1->pu4_buffer;
    UWORD32 VAR_5 = VAR_1->u4_ofst;
    UWORD32 VAR_6 = VAR_0 & 0xFFFF;
    UWORD32 VAR_7 = VAR_0 >> 16;
    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    WORD16 VAR_8[7];/* COMMENT_3 */
    WORD16 *VAR_9 = &VAR_8[3];

    tu_sblk4x4_coeff_data_t *VAR_10;
    WORD16 *VAR_11;
    dec_struct_t *VAR_12 = (dec_struct_t *)VAR_1->pv_codec_handle;

    VAR_10 = (tu_sblk4x4_coeff_data_t *)VAR_12->pv_parse_tu_coeff_data;
    VAR_10->u2_sig_coeff_map = 0;
    VAR_11 = &VAR_10->ai2_level[0];

    VAR_3 = VAR_7 - 1;
    if(VAR_6)
    {
        /* COMMENT_4 */
        /* COMMENT_5 */
        /* COMMENT_6 */
        /* COMMENT_4 */
        UWORD32 VAR_13, VAR_14 = VAR_6;
        WORD16 (*VAR_15)[3] =
                        (WORD16 (*)[3])VAR_16;
        WORD16 *VAR_17;

        GETBITS(VAR_13, VAR_5, VAR_4, VAR_14);

        VAR_17 = VAR_15[(1 << VAR_14) - 2 + VAR_13];

        while(VAR_14--)
            VAR_9[VAR_3--] = *VAR_17++;
    }

    /* COMMENT_7 */
    /* COMMENT_8 */
    /* COMMENT_7 */
    if(VAR_3 >= 0)
    {
        /* COMMENT_7 */
        /* COMMENT_9 */
        /* COMMENT_10 */
        /* COMMENT_7 */
        UWORD32 VAR_18, VAR_19, VAR_20;
        UWORD16 VAR_21, VAR_22;
        UWORD32 VAR_23;

        /* COMMENT_11 */
        /* COMMENT_12 */
        /* COMMENT_11 */
        FIND_ONE_IN_STREAM_32(VAR_23, VAR_5,
                              VAR_4);

        /* COMMENT_13 */
        /* COMMENT_14 */
        /* COMMENT_13 */
        VAR_21 = MIN(15, VAR_23);

        VAR_21 += (3 == VAR_6) ? 0 : (2);

        if(14 == VAR_23)
            VAR_20 = 4;
        else if(15 <= VAR_23)
        {
            VAR_21 += 15;
            VAR_20 = VAR_23 - 3;
        }
        else
            VAR_20 = 0;

        /* COMMENT_15 */
        if(16 <= VAR_23)
        {
            VAR_21 += ((1 << (VAR_23 - 3)) - 4096);
        }
        if(VAR_20)
        {
            GETBITS(VAR_18, VAR_5, VAR_4,
                    VAR_20);
            VAR_21 += VAR_18;
        }

        VAR_22 = (VAR_21 + 2) >> 1;
        /* COMMENT_13 */
        /* COMMENT_16 */
        /* COMMENT_13 */
        VAR_9[VAR_3--] = (VAR_21 & 1) ? -VAR_22 : VAR_22;

        VAR_19 = (VAR_22 > 3) ? 2 : 1;

        /* COMMENT_13 */
        /* COMMENT_17 */
        /* COMMENT_13 */
        while(VAR_3 >= 0)
        {

            /* COMMENT_11 */
            /* COMMENT_18 */
            /* COMMENT_11 */
            FIND_ONE_IN_STREAM_32(VAR_23, VAR_5,
                                  VAR_4);

            VAR_20 =
                            (15 <= VAR_23) ?
                                            (VAR_23 - 3) : VAR_19;

            /* COMMENT_13 */
            /* COMMENT_19 */
            /* COMMENT_13 */
            GETBITS(VAR_18, VAR_5, VAR_4,
                    VAR_20);
            VAR_21 = (MIN(VAR_23,15) << VAR_19)
                            + VAR_18;

            /* COMMENT_15 */
            if(16 <= VAR_23)
            {
                VAR_21 += ((1 << (VAR_23 - 3)) - 4096);
            }
            VAR_22 = (VAR_21 + 2) >> 1;

            /* COMMENT_13 */
            /* COMMENT_16 */
            /* COMMENT_13 */
            VAR_9[VAR_3--] =
                            (VAR_21 & 1) ? -VAR_22 : VAR_22;

            /* COMMENT_13 */
            /* COMMENT_20 */
            /* COMMENT_13 */
            VAR_19 += (VAR_22 > (3 << (VAR_19 - 1)));
        }

        /* COMMENT_7 */
        /* COMMENT_21 */
        /* COMMENT_7 */
    }

    if(VAR_7 < 4)
    {
        UWORD32 VAR_24 = (4 - VAR_7);
        FIND_ONE_IN_STREAM_LEN(VAR_2, VAR_5,
                               VAR_4, VAR_24);
    }
    else
        VAR_2 = 0;

    /* COMMENT_22 */
    /* COMMENT_23 */
    /* COMMENT_22 */
    {
        const UWORD8 *VAR_25;
        UWORD32 VAR_26;
        UWORD32 VAR_27 = (VAR_7 + VAR_2 - 1);
        UWORD32 VAR_28 = VAR_2;
        VAR_3 = VAR_7 - 1;

        /* COMMENT_22 */
        /* COMMENT_24 */
        /* COMMENT_22 */
        VAR_25 = (UWORD8 *)VAR_29;
        while(VAR_28 && VAR_3)
        {
            UWORD32 VAR_30;
            NEXTBITS(VAR_30, VAR_5, VAR_4, 3);

            VAR_30 = VAR_25[VAR_30 + (VAR_28 << 3)];
            VAR_26 = VAR_30 >> 2;

            FLUSHBITS(VAR_5, (VAR_30 & 0x03));
            SET_BIT(VAR_10->u2_sig_coeff_map, VAR_27);
            *VAR_11++ = VAR_9[VAR_3--];
            VAR_28 -= VAR_26;
            VAR_27 -= (VAR_26 + 1);
        }
        /* COMMENT_22 */
        /* COMMENT_25 */
        /* COMMENT_22 */

        /* COMMENT_22 */
        /* COMMENT_26 */
        /* COMMENT_22 */
        while(VAR_3 >= 0)
        {
            SET_BIT(VAR_10->u2_sig_coeff_map, VAR_27);
            *VAR_11++ = VAR_9[VAR_3--];
            VAR_27--;
        }
    }

    {
        WORD32 VAR_31;
        VAR_31 = (UWORD8 *)VAR_11 - (UWORD8 *)VAR_10;
        VAR_31 = ALIGN4(VAR_31);
        VAR_12->pv_parse_tu_coeff_data = (void *)((UWORD8 *)VAR_12->pv_parse_tu_coeff_data + VAR_31);
    }

    VAR_1->u4_ofst = VAR_5;
}",android/c57fc3703ae2e0d41b1f6580c50015937f2d23c1/ih264d_parse_cavlc.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -7,7 +7,11 @@
     UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;
     UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;
     UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;
-    WORD16 i2_level_arr[4];
+    // To avoid error check at 4x4 level, allocating for 3 extra levels(4+3)
+    // since u4_trailing_ones can at the max be 3. This will be required when
+    // u4_total_coeff is less than u4_trailing_ones
+    WORD16 ai2_level_arr[7];//
+    WORD16 *i2_level_arr = &ai2_level_arr[3];
 
     tu_sblk4x4_coeff_data_t *ps_tu_4x4;
     WORD16 *pi2_coeff_data;","{'deleted_lines': ['    WORD16 i2_level_arr[4];'], 'added_lines': ['    // To avoid error check at 4x4 level, allocating for 3 extra levels(4+3)', '    // since u4_trailing_ones can at the max be 3. This will be required when', '    // u4_total_coeff is less than u4_trailing_ones', '    WORD16 ai2_level_arr[7];//', '    WORD16 *i2_level_arr = &ai2_level_arr[3];']}",True,"Multiple stack-based buffer underflows in decoder/ih264d_parse_cavlc.c in mediaserver in Android 6.x before 2016-04-01 allow remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 26399350.",8.4,HIGH,2,test,,5
CVE-2016-0840,['CWE-119'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,android,"Decoder: Fix stack underflow in CAVLC 4x4 parse functions

Bug: 26399350
Change-Id: Id768751672a7b093ab6e53d4fc0b3188d470920e
",c57fc3703ae2e0d41b1f6580c50015937f2d23c1,https://android.googlesource.com/platform/external/libavc/+/c57fc3703ae2e0d41b1f6580c50015937f2d23c1,decoder/ih264d_parse_cavlc.c,ih264d_cavlc_4x4res_block_totalcoeff_2to10,"WORD32 ih264d_cavlc_4x4res_block_totalcoeff_2to10(UWORD32 u4_isdc,
UWORD32 u4_total_coeff_trail_one, 
dec_bit_stream_t *ps_bitstrm)
{
UWORD32 u4_total_zeroes;
WORD32 i;
UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;
UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;
UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;
WORD16 i2_level_arr[16];
tu_sblk4x4_coeff_data_t *ps_tu_4x4;
WORD16 *pi2_coeff_data;
dec_struct_t *ps_dec = (dec_struct_t *)ps_bitstrm->pv_codec_handle;
ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;
ps_tu_4x4->u2_sig_coeff_map = 0;
pi2_coeff_data = &ps_tu_4x4->ai2_level[0];
i = u4_total_coeff - 1;
if(u4_trailing_ones)
{
UWORD32 u4_signs, u4_cnt = u4_trailing_ones;
WORD16 (*ppi2_trlone_lkup)[3] =
(WORD16 (*)[3])gai2_ih264d_trailing_one_level;
WORD16 *pi2_trlone_lkup;
GETBITS(u4_signs, u4_bitstream_offset, pu4_bitstrm_buf, u4_cnt);
pi2_trlone_lkup = ppi2_trlone_lkup[(1 << u4_cnt) - 2 + u4_signs];
while(u4_cnt--)
i2_level_arr[i--] = *pi2_trlone_lkup++;
}
if(i >= 0)
{
UWORD32 u4_lev_suffix, u4_suffix_len, u4_lev_suffix_size;
WORD32 u2_lev_code, u2_abs_value;
UWORD32 u4_lev_prefix;
FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
pu4_bitstrm_buf);
u2_lev_code = MIN(15, u4_lev_prefix);
u2_lev_code += (3 == u4_trailing_ones) ? 0 : 2;
if(14 == u4_lev_prefix)
u4_lev_suffix_size = 4;
else if(15 <= u4_lev_prefix)
{
u2_lev_code += 15;
u4_lev_suffix_size = u4_lev_prefix - 3;
}
else
u4_lev_suffix_size = 0;
if(16 <= u4_lev_prefix)
{
u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
}
if(u4_lev_suffix_size)
{
GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
u4_lev_suffix_size);
u2_lev_code += u4_lev_suffix;
}
u2_abs_value = (u2_lev_code + 2) >> 1;
i2_level_arr[i--] = (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;
u4_suffix_len = (u2_abs_value > 3) ? 2 : 1;
while(i >= 0)
{
FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
pu4_bitstrm_buf);
u4_lev_suffix_size =
(15 <= u4_lev_prefix) ?
(u4_lev_prefix - 3) : u4_suffix_len;
GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
u4_lev_suffix_size);
u2_lev_code = (MIN(15,u4_lev_prefix) << u4_suffix_len)
+ u4_lev_suffix;
if(16 <= u4_lev_prefix)
{
u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
}
u2_abs_value = (u2_lev_code + 2) >> 1;
i2_level_arr[i--] =
(u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;
u4_suffix_len +=
(u4_suffix_len < 6) ?
(u2_abs_value
> (3
<< (u4_suffix_len
- 1))) :
0;
}
}
{
UWORD32 u4_index;
const UWORD8 (*ppu1_total_zero_lkup)[64] =
(const UWORD8 (*)[64])gau1_ih264d_table_total_zero_2to10;
NEXTBITS(u4_index, u4_bitstream_offset, pu4_bitstrm_buf, 6);
u4_total_zeroes = ppu1_total_zero_lkup[u4_total_coeff - 2][u4_index];
FLUSHBITS(u4_bitstream_offset, (u4_total_zeroes >> 4));
u4_total_zeroes &= 0xf;
}
{
const UWORD8 *pu1_table_runbefore;
UWORD32 u4_run;
WORD32 k;
UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc;
WORD32 u4_zeroes_left = u4_total_zeroes;
k = u4_total_coeff - 1;
while((u4_zeroes_left > 6) && k)
{
UWORD32 u4_code;
NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);
if(u4_code != 0)
{
FLUSHBITS(u4_bitstream_offset, 3);
u4_run = (7 - u4_code);
}
else
{
FIND_ONE_IN_STREAM_LEN(u4_code, u4_bitstream_offset,
pu4_bitstrm_buf, 11);
u4_run = (4 + u4_code);
}
SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
*pi2_coeff_data++ = i2_level_arr[k--];
u4_zeroes_left -= u4_run;
u4_scan_pos -= (u4_run + 1);
}
pu1_table_runbefore = (UWORD8 *)gau1_ih264d_table_run_before;
while((u4_zeroes_left > 0) && k)
{
UWORD32 u4_code;
NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);
u4_code = pu1_table_runbefore[u4_code + (u4_zeroes_left << 3)];
u4_run = u4_code >> 2;
FLUSHBITS(u4_bitstream_offset, (u4_code & 0x03));
SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
*pi2_coeff_data++ = i2_level_arr[k--];
u4_zeroes_left -= u4_run;
u4_scan_pos -= (u4_run + 1);
}
if(u4_zeroes_left < 0)
return -1;
while(k >= 0)
{
SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
*pi2_coeff_data++ = i2_level_arr[k--];
u4_scan_pos--;
}
}
{
WORD32 offset;
offset = (UWORD8 *)pi2_coeff_data - (UWORD8 *)ps_tu_4x4;
offset = ALIGN4(offset);
ps_dec->pv_parse_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_parse_tu_coeff_data + offset);
}
ps_bitstrm->u4_ofst = u4_bitstream_offset;
return 0;
}","WORD32 ih264d_cavlc_4x4res_block_totalcoeff_2to10(UWORD32 VAR_0,
UWORD32 VAR_1, 
dec_bit_stream_t *VAR_2)
{
UWORD32 VAR_3;
WORD32 VAR_4;
UWORD32 *VAR_5 = VAR_2->pu4_buffer;
UWORD32 VAR_6 = VAR_2->u4_ofst;
UWORD32 VAR_7 = VAR_1 & 0xFFFF;
UWORD32 VAR_8 = VAR_1 >> 16;
WORD16 VAR_9[16];
tu_sblk4x4_coeff_data_t *VAR_10;
WORD16 *VAR_11;
dec_struct_t *VAR_12 = (dec_struct_t *)VAR_2->pv_codec_handle;
VAR_10 = (tu_sblk4x4_coeff_data_t *)VAR_12->pv_parse_tu_coeff_data;
VAR_10->u2_sig_coeff_map = 0;
VAR_11 = &VAR_10->ai2_level[0];
VAR_4 = VAR_8 - 1;
if(VAR_7)
{
UWORD32 VAR_13, VAR_14 = VAR_7;
WORD16 (*VAR_15)[3] =
(WORD16 (*)[3])VAR_16;
WORD16 *VAR_17;
GETBITS(VAR_13, VAR_6, VAR_5, VAR_14);
VAR_17 = VAR_15[(1 << VAR_14) - 2 + VAR_13];
while(VAR_14--)
VAR_9[VAR_4--] = *VAR_17++;
}
if(VAR_4 >= 0)
{
UWORD32 VAR_18, VAR_19, VAR_20;
WORD32 VAR_21, VAR_22;
UWORD32 VAR_23;
FIND_ONE_IN_STREAM_32(VAR_23, VAR_6,
VAR_5);
VAR_21 = MIN(15, VAR_23);
VAR_21 += (3 == VAR_7) ? 0 : 2;
if(14 == VAR_23)
VAR_20 = 4;
else if(15 <= VAR_23)
{
VAR_21 += 15;
VAR_20 = VAR_23 - 3;
}
else
VAR_20 = 0;
if(16 <= VAR_23)
{
VAR_21 += ((1 << (VAR_23 - 3)) - 4096);
}
if(VAR_20)
{
GETBITS(VAR_18, VAR_6, VAR_5,
VAR_20);
VAR_21 += VAR_18;
}
VAR_22 = (VAR_21 + 2) >> 1;
VAR_9[VAR_4--] = (VAR_21 & 1) ? -VAR_22 : VAR_22;
VAR_19 = (VAR_22 > 3) ? 2 : 1;
while(VAR_4 >= 0)
{
FIND_ONE_IN_STREAM_32(VAR_23, VAR_6,
VAR_5);
VAR_20 =
(15 <= VAR_23) ?
(VAR_23 - 3) : VAR_19;
GETBITS(VAR_18, VAR_6, VAR_5,
VAR_20);
VAR_21 = (MIN(15,VAR_23) << VAR_19)
+ VAR_18;
if(16 <= VAR_23)
{
VAR_21 += ((1 << (VAR_23 - 3)) - 4096);
}
VAR_22 = (VAR_21 + 2) >> 1;
VAR_9[VAR_4--] =
(VAR_21 & 1) ? -VAR_22 : VAR_22;
VAR_19 +=
(VAR_19 < 6) ?
(VAR_22
> (3
<< (VAR_19
- 1))) :
0;
}
}
{
UWORD32 VAR_24;
const UWORD8 (*VAR_25)[64] =
(const UWORD8 (*)[64])VAR_26;
NEXTBITS(VAR_24, VAR_6, VAR_5, 6);
VAR_3 = VAR_25[VAR_8 - 2][VAR_24];
FLUSHBITS(VAR_6, (VAR_3 >> 4));
VAR_3 &= 0xf;
}
{
const UWORD8 *VAR_27;
UWORD32 VAR_28;
WORD32 VAR_29;
UWORD32 VAR_30 = VAR_8 + VAR_3 - 1 + VAR_0;
WORD32 VAR_31 = VAR_3;
VAR_29 = VAR_8 - 1;
while((VAR_31 > 6) && VAR_29)
{
UWORD32 VAR_32;
NEXTBITS(VAR_32, VAR_6, VAR_5, 3);
if(VAR_32 != 0)
{
FLUSHBITS(VAR_6, 3);
VAR_28 = (7 - VAR_32);
}
else
{
FIND_ONE_IN_STREAM_LEN(VAR_32, VAR_6,
VAR_5, 11);
VAR_28 = (4 + VAR_32);
}
SET_BIT(VAR_10->u2_sig_coeff_map, VAR_30);
*VAR_11++ = VAR_9[VAR_29--];
VAR_31 -= VAR_28;
VAR_30 -= (VAR_28 + 1);
}
VAR_27 = (UWORD8 *)VAR_33;
while((VAR_31 > 0) && VAR_29)
{
UWORD32 VAR_32;
NEXTBITS(VAR_32, VAR_6, VAR_5, 3);
VAR_32 = VAR_27[VAR_32 + (VAR_31 << 3)];
VAR_28 = VAR_32 >> 2;
FLUSHBITS(VAR_6, (VAR_32 & 0x03));
SET_BIT(VAR_10->u2_sig_coeff_map, VAR_30);
*VAR_11++ = VAR_9[VAR_29--];
VAR_31 -= VAR_28;
VAR_30 -= (VAR_28 + 1);
}
if(VAR_31 < 0)
return -1;
while(VAR_29 >= 0)
{
SET_BIT(VAR_10->u2_sig_coeff_map, VAR_30);
*VAR_11++ = VAR_9[VAR_29--];
VAR_30--;
}
}
{
WORD32 VAR_34;
VAR_34 = (UWORD8 *)VAR_11 - (UWORD8 *)VAR_10;
VAR_34 = ALIGN4(VAR_34);
VAR_12->pv_parse_tu_coeff_data = (void *)((UWORD8 *)VAR_12->pv_parse_tu_coeff_data + VAR_34);
}
VAR_2->u4_ofst = VAR_6;
return 0;
}",android/c57fc3703ae2e0d41b1f6580c50015937f2d23c1/ih264d_parse_cavlc.c/vul/before/2.json,"WORD32 ih264d_cavlc_4x4res_block_totalcoeff_2to10(UWORD32 u4_isdc,
                                               UWORD32 u4_total_coeff_trail_one, /*!<TotalCoefficients<<16+trailingones*/
                                               dec_bit_stream_t *ps_bitstrm)
{
    UWORD32 u4_total_zeroes;
    WORD32 i;
    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
    UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;
    UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;
    UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;
    // To avoid error check at 4x4 level, allocating for 3 extra levels(16+3)
    // since u4_trailing_ones can at the max be 3. This will be required when
    // u4_total_coeff is less than u4_trailing_ones
    WORD16 ai2_level_arr[19];
    WORD16 *i2_level_arr = &ai2_level_arr[3];

    tu_sblk4x4_coeff_data_t *ps_tu_4x4;
    WORD16 *pi2_coeff_data;
    dec_struct_t *ps_dec = (dec_struct_t *)ps_bitstrm->pv_codec_handle;

    ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;
    ps_tu_4x4->u2_sig_coeff_map = 0;
    pi2_coeff_data = &ps_tu_4x4->ai2_level[0];

    i = u4_total_coeff - 1;

    if(u4_trailing_ones)
    {
        /*********************************************************************/
        /* Decode Trailing Ones                                              */
        /* read the sign of T1's and put them in level array                 */
        /*********************************************************************/
        UWORD32 u4_signs, u4_cnt = u4_trailing_ones;
        WORD16 (*ppi2_trlone_lkup)[3] =
                        (WORD16 (*)[3])gai2_ih264d_trailing_one_level;
        WORD16 *pi2_trlone_lkup;

        GETBITS(u4_signs, u4_bitstream_offset, pu4_bitstrm_buf, u4_cnt);

        pi2_trlone_lkup = ppi2_trlone_lkup[(1 << u4_cnt) - 2 + u4_signs];

        while(u4_cnt--)
            i2_level_arr[i--] = *pi2_trlone_lkup++;
    }

    /****************************************************************/
    /* Decoding Levels Begins                                       */
    /****************************************************************/
    if(i >= 0)
    {
        /****************************************************************/
        /* First level is decoded outside the loop as it has lot of     */
        /* special cases.                                               */
        /****************************************************************/
        UWORD32 u4_lev_suffix, u4_suffix_len, u4_lev_suffix_size;
        WORD32 u2_lev_code, u2_abs_value;
        UWORD32 u4_lev_prefix;

        /***************************************************************/
        /* u4_suffix_len = 0,  Find leading zeros in next 32 bits      */
        /***************************************************************/
        FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
                              pu4_bitstrm_buf);

        /*********************************************************/
        /* Special decoding case when trailing ones are 3        */
        /*********************************************************/
        u2_lev_code = MIN(15, u4_lev_prefix);

        u2_lev_code += (3 == u4_trailing_ones) ? 0 : 2;

        if(14 == u4_lev_prefix)
            u4_lev_suffix_size = 4;
        else if(15 <= u4_lev_prefix)
        {
            u2_lev_code += 15;
            u4_lev_suffix_size = u4_lev_prefix - 3;
        }
        else
            u4_lev_suffix_size = 0;

        //HP_LEVEL_PREFIX
        if(16 <= u4_lev_prefix)
        {
            u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
        }
        if(u4_lev_suffix_size)
        {
            GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
                    u4_lev_suffix_size);
            u2_lev_code += u4_lev_suffix;
        }

        u2_abs_value = (u2_lev_code + 2) >> 1;
        /*********************************************************/
        /* If Level code is odd, level is negative else positive */
        /*********************************************************/
        i2_level_arr[i--] = (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;

        u4_suffix_len = (u2_abs_value > 3) ? 2 : 1;

        /*********************************************************/
        /* Now loop over the remaining levels                    */
        /*********************************************************/
        while(i >= 0)
        {

            /***************************************************************/
            /* Find leading zeros in next 32 bits                          */
            /***************************************************************/
            FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
                                  pu4_bitstrm_buf);

            u4_lev_suffix_size =
                            (15 <= u4_lev_prefix) ?
                                            (u4_lev_prefix - 3) : u4_suffix_len;

            /*********************************************************/
            /* Compute level code using prefix and suffix            */
            /*********************************************************/
            GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
                    u4_lev_suffix_size);
            u2_lev_code = (MIN(15,u4_lev_prefix) << u4_suffix_len)
                            + u4_lev_suffix;

            //HP_LEVEL_PREFIX
            if(16 <= u4_lev_prefix)
            {
                u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
            }
            u2_abs_value = (u2_lev_code + 2) >> 1;

            /*********************************************************/
            /* If Level code is odd, level is negative else positive */
            /*********************************************************/
            i2_level_arr[i--] =
                            (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;

            /*********************************************************/
            /* Increment suffix length if required                   */
            /*********************************************************/
            u4_suffix_len +=
                            (u4_suffix_len < 6) ?
                                            (u2_abs_value
                                                            > (3
                                                                            << (u4_suffix_len
                                                                                            - 1))) :
                                            0;
        }

        /****************************************************************/
        /* Decoding Levels Ends                                         */
        /****************************************************************/
    }

    /****************************************************************/
    /* Decoding total zeros as in section 9.2.3, table 9.7          */
    /****************************************************************/
    {
        UWORD32 u4_index;
        const UWORD8 (*ppu1_total_zero_lkup)[64] =
                        (const UWORD8 (*)[64])gau1_ih264d_table_total_zero_2to10;

        NEXTBITS(u4_index, u4_bitstream_offset, pu4_bitstrm_buf, 6);
        u4_total_zeroes = ppu1_total_zero_lkup[u4_total_coeff - 2][u4_index];

        FLUSHBITS(u4_bitstream_offset, (u4_total_zeroes >> 4));
        u4_total_zeroes &= 0xf;
    }

    /**************************************************************/
    /* Decode the runs and form the coefficient buffer            */
    /**************************************************************/
    {
        const UWORD8 *pu1_table_runbefore;
        UWORD32 u4_run;
        WORD32 k;
        UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc;
        WORD32 u4_zeroes_left = u4_total_zeroes;
        k = u4_total_coeff - 1;

        /**************************************************************/
        /* Decoding Runs Begin for zeros left > 6                     */
        /**************************************************************/
        while((u4_zeroes_left > 6) && k)
        {
            UWORD32 u4_code;

            NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);

            if(u4_code != 0)
            {
                FLUSHBITS(u4_bitstream_offset, 3);
                u4_run = (7 - u4_code);
            }
            else
            {

                FIND_ONE_IN_STREAM_LEN(u4_code, u4_bitstream_offset,
                                       pu4_bitstrm_buf, 11);
                u4_run = (4 + u4_code);
            }

            SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
            *pi2_coeff_data++ = i2_level_arr[k--];
            u4_zeroes_left -= u4_run;
            u4_scan_pos -= (u4_run + 1);
        }

        /**************************************************************/
        /* Decoding Runs for 0 < zeros left <=6                       */
        /**************************************************************/
        pu1_table_runbefore = (UWORD8 *)gau1_ih264d_table_run_before;
        while((u4_zeroes_left > 0) && k)
        {
            UWORD32 u4_code;
            NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);

            u4_code = pu1_table_runbefore[u4_code + (u4_zeroes_left << 3)];
            u4_run = u4_code >> 2;

            FLUSHBITS(u4_bitstream_offset, (u4_code & 0x03));

            SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
            *pi2_coeff_data++ = i2_level_arr[k--];
            u4_zeroes_left -= u4_run;
            u4_scan_pos -= (u4_run + 1);
        }
        /**************************************************************/
        /* Decoding Runs End                                          */
        /**************************************************************/

        /**************************************************************/
        /* Copy the remaining coefficients                            */
        /**************************************************************/
        if(u4_zeroes_left < 0)
            return -1;
        while(k >= 0)
        {

            SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
            *pi2_coeff_data++ = i2_level_arr[k--];
            u4_scan_pos--;
        }
    }

    {
        WORD32 offset;
        offset = (UWORD8 *)pi2_coeff_data - (UWORD8 *)ps_tu_4x4;
        offset = ALIGN4(offset);
        ps_dec->pv_parse_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_parse_tu_coeff_data + offset);
    }

    ps_bitstrm->u4_ofst = u4_bitstream_offset;
    return 0;
}","WORD32 ih264d_cavlc_4x4res_block_totalcoeff_2to10(UWORD32 VAR_0,
                                               UWORD32 VAR_1, /* COMMENT_0 */
                                               dec_bit_stream_t *VAR_2)
{
    UWORD32 VAR_3;
    WORD32 VAR_4;
    UWORD32 *VAR_5 = VAR_2->pu4_buffer;
    UWORD32 VAR_6 = VAR_2->u4_ofst;
    UWORD32 VAR_7 = VAR_1 & 0xFFFF;
    UWORD32 VAR_8 = VAR_1 >> 16;
    /* COMMENT_1 */
    /* COMMENT_2 */
    /* COMMENT_3 */
    WORD16 VAR_9[19];
    WORD16 *VAR_10 = &VAR_9[3];

    tu_sblk4x4_coeff_data_t *VAR_11;
    WORD16 *VAR_12;
    dec_struct_t *VAR_13 = (dec_struct_t *)VAR_2->pv_codec_handle;

    VAR_11 = (tu_sblk4x4_coeff_data_t *)VAR_13->pv_parse_tu_coeff_data;
    VAR_11->u2_sig_coeff_map = 0;
    VAR_12 = &VAR_11->ai2_level[0];

    VAR_4 = VAR_8 - 1;

    if(VAR_7)
    {
        /* COMMENT_4 */
        /* COMMENT_5 */
        /* COMMENT_6 */
        /* COMMENT_4 */
        UWORD32 VAR_14, VAR_15 = VAR_7;
        WORD16 (*VAR_16)[3] =
                        (WORD16 (*)[3])VAR_17;
        WORD16 *VAR_18;

        GETBITS(VAR_14, VAR_6, VAR_5, VAR_15);

        VAR_18 = VAR_16[(1 << VAR_15) - 2 + VAR_14];

        while(VAR_15--)
            VAR_10[VAR_4--] = *VAR_18++;
    }

    /* COMMENT_7 */
    /* COMMENT_8 */
    /* COMMENT_7 */
    if(VAR_4 >= 0)
    {
        /* COMMENT_7 */
        /* COMMENT_9 */
        /* COMMENT_10 */
        /* COMMENT_7 */
        UWORD32 VAR_19, VAR_20, VAR_21;
        WORD32 VAR_22, VAR_23;
        UWORD32 VAR_24;

        /* COMMENT_11 */
        /* COMMENT_12 */
        /* COMMENT_11 */
        FIND_ONE_IN_STREAM_32(VAR_24, VAR_6,
                              VAR_5);

        /* COMMENT_13 */
        /* COMMENT_14 */
        /* COMMENT_13 */
        VAR_22 = MIN(15, VAR_24);

        VAR_22 += (3 == VAR_7) ? 0 : 2;

        if(14 == VAR_24)
            VAR_21 = 4;
        else if(15 <= VAR_24)
        {
            VAR_22 += 15;
            VAR_21 = VAR_24 - 3;
        }
        else
            VAR_21 = 0;

        /* COMMENT_15 */
        if(16 <= VAR_24)
        {
            VAR_22 += ((1 << (VAR_24 - 3)) - 4096);
        }
        if(VAR_21)
        {
            GETBITS(VAR_19, VAR_6, VAR_5,
                    VAR_21);
            VAR_22 += VAR_19;
        }

        VAR_23 = (VAR_22 + 2) >> 1;
        /* COMMENT_13 */
        /* COMMENT_16 */
        /* COMMENT_13 */
        VAR_10[VAR_4--] = (VAR_22 & 1) ? -VAR_23 : VAR_23;

        VAR_20 = (VAR_23 > 3) ? 2 : 1;

        /* COMMENT_13 */
        /* COMMENT_17 */
        /* COMMENT_13 */
        while(VAR_4 >= 0)
        {

            /* COMMENT_11 */
            /* COMMENT_18 */
            /* COMMENT_11 */
            FIND_ONE_IN_STREAM_32(VAR_24, VAR_6,
                                  VAR_5);

            VAR_21 =
                            (15 <= VAR_24) ?
                                            (VAR_24 - 3) : VAR_20;

            /* COMMENT_13 */
            /* COMMENT_19 */
            /* COMMENT_13 */
            GETBITS(VAR_19, VAR_6, VAR_5,
                    VAR_21);
            VAR_22 = (MIN(15,VAR_24) << VAR_20)
                            + VAR_19;

            /* COMMENT_15 */
            if(16 <= VAR_24)
            {
                VAR_22 += ((1 << (VAR_24 - 3)) - 4096);
            }
            VAR_23 = (VAR_22 + 2) >> 1;

            /* COMMENT_13 */
            /* COMMENT_16 */
            /* COMMENT_13 */
            VAR_10[VAR_4--] =
                            (VAR_22 & 1) ? -VAR_23 : VAR_23;

            /* COMMENT_13 */
            /* COMMENT_20 */
            /* COMMENT_13 */
            VAR_20 +=
                            (VAR_20 < 6) ?
                                            (VAR_23
                                                            > (3
                                                                            << (VAR_20
                                                                                            - 1))) :
                                            0;
        }

        /* COMMENT_7 */
        /* COMMENT_21 */
        /* COMMENT_7 */
    }

    /* COMMENT_7 */
    /* COMMENT_22 */
    /* COMMENT_7 */
    {
        UWORD32 VAR_25;
        const UWORD8 (*VAR_26)[64] =
                        (const UWORD8 (*)[64])VAR_27;

        NEXTBITS(VAR_25, VAR_6, VAR_5, 6);
        VAR_3 = VAR_26[VAR_8 - 2][VAR_25];

        FLUSHBITS(VAR_6, (VAR_3 >> 4));
        VAR_3 &= 0xf;
    }

    /* COMMENT_23 */
    /* COMMENT_24 */
    /* COMMENT_23 */
    {
        const UWORD8 *VAR_28;
        UWORD32 VAR_29;
        WORD32 VAR_30;
        UWORD32 VAR_31 = VAR_8 + VAR_3 - 1 + VAR_0;
        WORD32 VAR_32 = VAR_3;
        VAR_30 = VAR_8 - 1;

        /* COMMENT_23 */
        /* COMMENT_25 */
        /* COMMENT_23 */
        while((VAR_32 > 6) && VAR_30)
        {
            UWORD32 VAR_33;

            NEXTBITS(VAR_33, VAR_6, VAR_5, 3);

            if(VAR_33 != 0)
            {
                FLUSHBITS(VAR_6, 3);
                VAR_29 = (7 - VAR_33);
            }
            else
            {

                FIND_ONE_IN_STREAM_LEN(VAR_33, VAR_6,
                                       VAR_5, 11);
                VAR_29 = (4 + VAR_33);
            }

            SET_BIT(VAR_11->u2_sig_coeff_map, VAR_31);
            *VAR_12++ = VAR_10[VAR_30--];
            VAR_32 -= VAR_29;
            VAR_31 -= (VAR_29 + 1);
        }

        /* COMMENT_23 */
        /* COMMENT_26 */
        /* COMMENT_23 */
        VAR_28 = (UWORD8 *)VAR_34;
        while((VAR_32 > 0) && VAR_30)
        {
            UWORD32 VAR_33;
            NEXTBITS(VAR_33, VAR_6, VAR_5, 3);

            VAR_33 = VAR_28[VAR_33 + (VAR_32 << 3)];
            VAR_29 = VAR_33 >> 2;

            FLUSHBITS(VAR_6, (VAR_33 & 0x03));

            SET_BIT(VAR_11->u2_sig_coeff_map, VAR_31);
            *VAR_12++ = VAR_10[VAR_30--];
            VAR_32 -= VAR_29;
            VAR_31 -= (VAR_29 + 1);
        }
        /* COMMENT_23 */
        /* COMMENT_27 */
        /* COMMENT_23 */

        /* COMMENT_23 */
        /* COMMENT_28 */
        /* COMMENT_23 */
        if(VAR_32 < 0)
            return -1;
        while(VAR_30 >= 0)
        {

            SET_BIT(VAR_11->u2_sig_coeff_map, VAR_31);
            *VAR_12++ = VAR_10[VAR_30--];
            VAR_31--;
        }
    }

    {
        WORD32 VAR_35;
        VAR_35 = (UWORD8 *)VAR_12 - (UWORD8 *)VAR_11;
        VAR_35 = ALIGN4(VAR_35);
        VAR_13->pv_parse_tu_coeff_data = (void *)((UWORD8 *)VAR_13->pv_parse_tu_coeff_data + VAR_35);
    }

    VAR_2->u4_ofst = VAR_6;
    return 0;
}",android/c57fc3703ae2e0d41b1f6580c50015937f2d23c1/ih264d_parse_cavlc.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -8,7 +8,11 @@
     UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;
     UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;
     UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;
-    WORD16 i2_level_arr[16];
+    // To avoid error check at 4x4 level, allocating for 3 extra levels(16+3)
+    // since u4_trailing_ones can at the max be 3. This will be required when
+    // u4_total_coeff is less than u4_trailing_ones
+    WORD16 ai2_level_arr[19];
+    WORD16 *i2_level_arr = &ai2_level_arr[3];
 
     tu_sblk4x4_coeff_data_t *ps_tu_4x4;
     WORD16 *pi2_coeff_data;","{'deleted_lines': ['    WORD16 i2_level_arr[16];'], 'added_lines': ['    // To avoid error check at 4x4 level, allocating for 3 extra levels(16+3)', '    // since u4_trailing_ones can at the max be 3. This will be required when', '    // u4_total_coeff is less than u4_trailing_ones', '    WORD16 ai2_level_arr[19];', '    WORD16 *i2_level_arr = &ai2_level_arr[3];']}",True,"Multiple stack-based buffer underflows in decoder/ih264d_parse_cavlc.c in mediaserver in Android 6.x before 2016-04-01 allow remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 26399350.",8.4,HIGH,2,test,,5
CVE-2016-0842,['CWE-119'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,android,"Return error when there are more mmco params than allocated size

Bug: 25818142

Change-Id: I5c1b23985eeca5192b42703c627ca3d060e4e13d
",943323f1d9d3dd5c2634deb26cbe72343ca6b3db,https://android.googlesource.com/platform/external/libavc/+/943323f1d9d3dd5c2634deb26cbe72343ca6b3db,decoder/ih264d_parse_bslice.c,ih264d_parse_bslice,"WORD32 ih264d_parse_bslice(dec_struct_t * ps_dec, UWORD16 u2_first_mb_in_slice)
{
dec_pic_params_t * ps_pps = ps_dec->ps_cur_pps;
dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
dec_bit_stream_t * ps_bitstrm = ps_dec->ps_bitstrm;
UWORD8 u1_ref_idx_re_flag_lx;
UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
UWORD32 u4_temp, ui_temp1;
WORD32 i_temp;
WORD32 ret;
{
WORD8 *pi1_buf;
WORD16 *pi2_mv = ps_dec->s_default_mv_pred.i2_mv;
WORD32 *pi4_mv = (WORD32*)pi2_mv;
WORD16 *pi16_refFrame;
pi1_buf = ps_dec->s_default_mv_pred.i1_ref_frame;
pi16_refFrame = (WORD16*)pi1_buf;
*pi4_mv = 0;
*(pi4_mv + 1) = 0;
*pi16_refFrame = OUT_OF_RANGE_REF;
ps_dec->s_default_mv_pred.u1_col_ref_pic_idx = (UWORD8)-1;
ps_dec->s_default_mv_pred.u1_pic_type = (UWORD8)-1;
}
ps_slice->u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264(
ps_bitstrm);
COPYTHECONTEXT(""SH: num_ref_idx_override_flag"",
ps_slice->u1_num_ref_idx_active_override_flag);
u4_temp = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[0];
ui_temp1 = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[1];
if(ps_slice->u1_num_ref_idx_active_override_flag)
{
u4_temp = 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
COPYTHECONTEXT(""SH: num_ref_idx_l0_active_minus1"",
u4_temp - 1);
ui_temp1 = 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
COPYTHECONTEXT(""SH: num_ref_idx_l1_active_minus1"",
ui_temp1 - 1);
}
{
UWORD8 u1_max_ref_idx = MAX_FRAMES;
if(ps_slice->u1_field_pic_flag)
{
u1_max_ref_idx = MAX_FRAMES << 1;
}
if((u4_temp > u1_max_ref_idx) || (ui_temp1 > u1_max_ref_idx))
{
return ERROR_NUM_REF;
}
ps_slice->u1_num_ref_idx_lx_active[0] = u4_temp;
ps_slice->u1_num_ref_idx_lx_active[1] = ui_temp1;
}
{
UWORD8 init_idx_flg = (ps_dec->u1_pr_sl_type
!= ps_dec->ps_cur_slice->u1_slice_type);
if(ps_dec->u1_first_pb_nal_in_pic
|| (init_idx_flg & !ps_dec->u1_sl_typ_5_9)
|| ps_dec->u1_num_ref_idx_lx_active_prev
!= ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0])
ih264d_init_ref_idx_lx_b(ps_dec);
if(ps_dec->u1_first_pb_nal_in_pic & ps_dec->u1_sl_typ_5_9)
ps_dec->u1_first_pb_nal_in_pic = 0;
}
ps_dec->u1_num_ref_idx_lx_active_prev =
ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];
u1_ref_idx_re_flag_lx = ih264d_get_bit_h264(ps_bitstrm);
COPYTHECONTEXT(""SH: ref_pic_list_reordering_flag_l0"",u1_ref_idx_re_flag_lx);
if(u1_ref_idx_re_flag_lx)
{
WORD8 ret;
ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_mod_dpb[0];
ret = ih264d_ref_idx_reordering(ps_dec, 0);
if(ret == -1)
return ERROR_REFIDX_ORDER_T;
}
else
ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];
u1_ref_idx_re_flag_lx = ih264d_get_bit_h264(ps_bitstrm);
COPYTHECONTEXT(""SH: ref_pic_list_reordering_flag_l1"",u1_ref_idx_re_flag_lx);
if(u1_ref_idx_re_flag_lx)
{
WORD8 ret;
ps_dec->ps_ref_pic_buf_lx[1] = ps_dec->ps_dpb_mgr->ps_mod_dpb[1];
ret = ih264d_ref_idx_reordering(ps_dec, 1);
if(ret == -1)
return ERROR_REFIDX_ORDER_T;
}
else
ps_dec->ps_ref_pic_buf_lx[1] = ps_dec->ps_dpb_mgr->ps_init_dpb[1];
{
void **ppv_map_ref_idx_to_poc_lx;
WORD8 idx;
struct pic_buffer_t *ps_pic;
ppv_map_ref_idx_to_poc_lx = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L0;
ppv_map_ref_idx_to_poc_lx[0] = 0;
ppv_map_ref_idx_to_poc_lx++;
for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];
idx++)
{
ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
ppv_map_ref_idx_to_poc_lx[idx] = (ps_pic->pu1_buf1);
}
ppv_map_ref_idx_to_poc_lx = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L1;
ppv_map_ref_idx_to_poc_lx[0] = 0;
ppv_map_ref_idx_to_poc_lx++;
for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1];
idx++)
{
ps_pic = ps_dec->ps_ref_pic_buf_lx[1][idx];
ppv_map_ref_idx_to_poc_lx[idx] = (ps_pic->pu1_buf1);
}
if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
{
void **ppv_map_ref_idx_to_poc_lx_t, **ppv_map_ref_idx_to_poc_lx_b;
ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc
+ TOP_LIST_FLD_L0;
ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc
+ BOT_LIST_FLD_L0;
ppv_map_ref_idx_to_poc_lx_t[0] = 0;
ppv_map_ref_idx_to_poc_lx_t++;
ppv_map_ref_idx_to_poc_lx_b[0] = 0;
ppv_map_ref_idx_to_poc_lx_b++;
for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];
idx++)
{
ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
ppv_map_ref_idx_to_poc_lx_t[0] = (ps_pic->pu1_buf1);
ppv_map_ref_idx_to_poc_lx_b[1] = (ps_pic->pu1_buf1);
ppv_map_ref_idx_to_poc_lx_b[0] = (ps_pic->pu1_buf1) + 1;
ppv_map_ref_idx_to_poc_lx_t[1] = (ps_pic->pu1_buf1) + 1;
ppv_map_ref_idx_to_poc_lx_t += 2;
ppv_map_ref_idx_to_poc_lx_b += 2;
}
ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc
+ TOP_LIST_FLD_L1;
ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc
+ BOT_LIST_FLD_L1;
ppv_map_ref_idx_to_poc_lx_t[0] = 0;
ppv_map_ref_idx_to_poc_lx_t++;
ppv_map_ref_idx_to_poc_lx_b[0] = 0;
ppv_map_ref_idx_to_poc_lx_b++;
for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1];
idx++)
{
UWORD8 u1_tmp_idx = idx << 1;
ps_pic = ps_dec->ps_ref_pic_buf_lx[1][idx];
ppv_map_ref_idx_to_poc_lx_t[u1_tmp_idx] = (ps_pic->pu1_buf1);
ppv_map_ref_idx_to_poc_lx_b[u1_tmp_idx + 1] = (ps_pic->pu1_buf1);
ppv_map_ref_idx_to_poc_lx_b[u1_tmp_idx] = (ps_pic->pu1_buf1) + 1;
ppv_map_ref_idx_to_poc_lx_t[u1_tmp_idx + 1] = (ps_pic->pu1_buf1) + 1;
}
}
if(ps_dec->u4_num_cores >= 3)
{
WORD32 num_entries;
WORD32 size;
num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);
num_entries = 2 * ((2 * num_entries) + 1);
size = num_entries * sizeof(void *);
size += PAD_MAP_IDX_POC * sizeof(void *);
memcpy((void *)ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc,
ps_dec->ppv_map_ref_idx_to_poc,
size);
}
}
if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag
&& (ps_dec->ps_cur_slice->u1_field_pic_flag == 0))
{
ih264d_convert_frm_mbaff_list(ps_dec);
}
if(ps_pps->u1_wted_bipred_idc == 1)
{
ret = ih264d_parse_pred_weight_table(ps_slice, ps_bitstrm);
if(ret != OK)
return ret;
ih264d_form_pred_weight_matrix(ps_dec);
ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
}
else if(ps_pps->u1_wted_bipred_idc == 2)
{
ps_slice->u2_log2Y_crwd = 0x0505;
ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
ih264d_get_implicit_weights(ps_dec);
}
else
ps_dec->ps_cur_slice->u2_log2Y_crwd = 0;
ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =
ps_dec->ps_cur_slice->u2_log2Y_crwd;
if(ps_slice->u1_nal_ref_idc != 0)
{
if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
ps_dec->u4_bitoffset = ih264d_read_mmco_commands(ps_dec);
else
ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;
}
if(ps_pps->u1_entropy_coding_mode == CABAC)
{
u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
if(u4_temp > MAX_CABAC_INIT_IDC)
{
return ERROR_INV_SLICE_HDR_T;
}
ps_slice->u1_cabac_init_idc = u4_temp;
COPYTHECONTEXT(""SH: cabac_init_idc"",ps_slice->u1_cabac_init_idc);
}
i_temp = ps_pps->u1_pic_init_qp
+ ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
if((i_temp < 0) || (i_temp > 51))
{
return ERROR_INV_RANGE_QP_T;
}
ps_slice->u1_slice_qp = i_temp;
COPYTHECONTEXT(""SH: slice_qp_delta"",
(WORD8)(ps_slice->u1_slice_qp - ps_pps->u1_pic_init_qp));
if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)
{
u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)
{
return ERROR_INV_SLICE_HDR_T;
} COPYTHECONTEXT(""SH: disable_deblocking_filter_idc"", u4_temp);
ps_slice->u1_disable_dblk_filter_idc = u4_temp;
if(u4_temp != 1)
{
i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
<< 1;
if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
{
return ERROR_INV_SLICE_HDR_T;
}
ps_slice->i1_slice_alpha_c0_offset = i_temp;
COPYTHECONTEXT(""SH: slice_alpha_c0_offset_div2"",
ps_slice->i1_slice_alpha_c0_offset >> 1);
i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
<< 1;
if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
{
return ERROR_INV_SLICE_HDR_T;
}
ps_slice->i1_slice_beta_offset = i_temp;
COPYTHECONTEXT(""SH: slice_beta_offset_div2"",
ps_slice->i1_slice_beta_offset >> 1);
}
else
{
ps_slice->i1_slice_alpha_c0_offset = 0;
ps_slice->i1_slice_beta_offset = 0;
}
}
else
{
ps_slice->u1_disable_dblk_filter_idc = 0;
ps_slice->i1_slice_alpha_c0_offset = 0;
ps_slice->i1_slice_beta_offset = 0;
}
ps_dec->u1_slice_header_done = 2;
if(ps_pps->u1_entropy_coding_mode)
{
SWITCHOFFTRACE; SWITCHONTRACECABAC;
ps_dec->pf_parse_inter_slice = ih264d_parse_inter_slice_data_cabac;
ps_dec->pf_parse_inter_mb = ih264d_parse_bmb_cabac;
ih264d_init_cabac_contexts(B_SLICE, ps_dec);
if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;
else
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff;
}
else
{
SWITCHONTRACE; SWITCHOFFTRACECABAC;
ps_dec->pf_parse_inter_slice = ih264d_parse_inter_slice_data_cavlc;
ps_dec->pf_parse_inter_mb = ih264d_parse_bmb_cavlc;
if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;
else
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff;
}
ret = ih264d_cal_col_pic(ps_dec);
if(ret != OK)
return ret;
ps_dec->u1_B = 1;
ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_bmb;
ret = ps_dec->pf_parse_inter_slice(ps_dec, ps_slice, u2_first_mb_in_slice);
if(ret != OK)
return ret;
return OK;
}","WORD32 ih264d_parse_bslice(dec_struct_t * VAR_0, UWORD16 VAR_1)
{
dec_pic_params_t * VAR_2 = VAR_0->ps_cur_pps;
dec_slice_params_t * VAR_3 = VAR_0->ps_cur_slice;
dec_bit_stream_t * VAR_4 = VAR_0->ps_bitstrm;
UWORD8 VAR_5;
UWORD32 *VAR_6 = VAR_4->pu4_buffer;
UWORD32 *VAR_7 = &VAR_4->u4_ofst;
UWORD32 VAR_8, VAR_9;
WORD32 VAR_10;
WORD32 VAR_11;
{
WORD8 *VAR_12;
WORD16 *VAR_13 = VAR_0->s_default_mv_pred.i2_mv;
WORD32 *VAR_14 = (WORD32*)VAR_13;
WORD16 *VAR_15;
VAR_12 = VAR_0->s_default_mv_pred.i1_ref_frame;
VAR_15 = (WORD16*)VAR_12;
*VAR_14 = 0;
*(VAR_14 + 1) = 0;
*VAR_15 = VAR_16;
VAR_0->s_default_mv_pred.u1_col_ref_pic_idx = (UWORD8)-1;
VAR_0->s_default_mv_pred.u1_pic_type = (UWORD8)-1;
}
VAR_3->u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264(
VAR_4);
COPYTHECONTEXT(""SH: num_ref_idx_override_flag"",
VAR_3->u1_num_ref_idx_active_override_flag);
VAR_8 = VAR_0->ps_cur_pps->u1_num_ref_idx_lx_active[0];
VAR_9 = VAR_0->ps_cur_pps->u1_num_ref_idx_lx_active[1];
if(VAR_3->u1_num_ref_idx_active_override_flag)
{
VAR_8 = 1 + ih264d_uev(VAR_7, VAR_6);
COPYTHECONTEXT(""SH: num_ref_idx_l0_active_minus1"",
VAR_8 - 1);
VAR_9 = 1 + ih264d_uev(VAR_7, VAR_6);
COPYTHECONTEXT(""SH: num_ref_idx_l1_active_minus1"",
VAR_9 - 1);
}
{
UWORD8 VAR_17 = VAR_18;
if(VAR_3->u1_field_pic_flag)
{
VAR_17 = VAR_18 << 1;
}
if((VAR_8 > VAR_17) || (VAR_9 > VAR_17))
{
return VAR_19;
}
VAR_3->u1_num_ref_idx_lx_active[0] = VAR_8;
VAR_3->u1_num_ref_idx_lx_active[1] = VAR_9;
}
{
UWORD8 VAR_20 = (VAR_0->u1_pr_sl_type
!= VAR_0->ps_cur_slice->u1_slice_type);
if(VAR_0->u1_first_pb_nal_in_pic
|| (VAR_20 & !VAR_0->u1_sl_typ_5_9)
|| VAR_0->u1_num_ref_idx_lx_active_prev
!= VAR_0->ps_cur_slice->u1_num_ref_idx_lx_active[0])
ih264d_init_ref_idx_lx_b(VAR_0);
if(VAR_0->u1_first_pb_nal_in_pic & VAR_0->u1_sl_typ_5_9)
VAR_0->u1_first_pb_nal_in_pic = 0;
}
VAR_0->u1_num_ref_idx_lx_active_prev =
VAR_0->ps_cur_slice->u1_num_ref_idx_lx_active[0];
VAR_5 = ih264d_get_bit_h264(VAR_4);
COPYTHECONTEXT(""SH: ref_pic_list_reordering_flag_l0"",VAR_5);
if(VAR_5)
{
WORD8 VAR_11;
VAR_0->ps_ref_pic_buf_lx[0] = VAR_0->ps_dpb_mgr->ps_mod_dpb[0];
VAR_11 = ih264d_ref_idx_reordering(VAR_0, 0);
if(VAR_11 == -1)
return VAR_21;
}
else
VAR_0->ps_ref_pic_buf_lx[0] = VAR_0->ps_dpb_mgr->ps_init_dpb[0];
VAR_5 = ih264d_get_bit_h264(VAR_4);
COPYTHECONTEXT(""SH: ref_pic_list_reordering_flag_l1"",VAR_5);
if(VAR_5)
{
WORD8 VAR_11;
VAR_0->ps_ref_pic_buf_lx[1] = VAR_0->ps_dpb_mgr->ps_mod_dpb[1];
VAR_11 = ih264d_ref_idx_reordering(VAR_0, 1);
if(VAR_11 == -1)
return VAR_21;
}
else
VAR_0->ps_ref_pic_buf_lx[1] = VAR_0->ps_dpb_mgr->ps_init_dpb[1];
{
void **VAR_22;
WORD8 VAR_23;
struct pic_buffer_t *VAR_24;
VAR_22 = VAR_0->ppv_map_ref_idx_to_poc + VAR_25;
VAR_22[0] = 0;
VAR_22++;
for(VAR_23 = 0; VAR_23 < VAR_0->ps_cur_slice->u1_num_ref_idx_lx_active[0];
VAR_23++)
{
VAR_24 = VAR_0->ps_ref_pic_buf_lx[0][VAR_23];
VAR_22[VAR_23] = (VAR_24->pu1_buf1);
}
VAR_22 = VAR_0->ppv_map_ref_idx_to_poc + VAR_26;
VAR_22[0] = 0;
VAR_22++;
for(VAR_23 = 0; VAR_23 < VAR_0->ps_cur_slice->u1_num_ref_idx_lx_active[1];
VAR_23++)
{
VAR_24 = VAR_0->ps_ref_pic_buf_lx[1][VAR_23];
VAR_22[VAR_23] = (VAR_24->pu1_buf1);
}
if(VAR_0->ps_cur_slice->u1_mbaff_frame_flag)
{
void **VAR_27, **VAR_28;
VAR_27 = VAR_0->ppv_map_ref_idx_to_poc
+ VAR_29;
VAR_28 = VAR_0->ppv_map_ref_idx_to_poc
+ VAR_30;
VAR_27[0] = 0;
VAR_27++;
VAR_28[0] = 0;
VAR_28++;
for(VAR_23 = 0; VAR_23 < VAR_0->ps_cur_slice->u1_num_ref_idx_lx_active[0];
VAR_23++)
{
VAR_24 = VAR_0->ps_ref_pic_buf_lx[0][VAR_23];
VAR_27[0] = (VAR_24->pu1_buf1);
VAR_28[1] = (VAR_24->pu1_buf1);
VAR_28[0] = (VAR_24->pu1_buf1) + 1;
VAR_27[1] = (VAR_24->pu1_buf1) + 1;
VAR_27 += 2;
VAR_28 += 2;
}
VAR_27 = VAR_0->ppv_map_ref_idx_to_poc
+ VAR_31;
VAR_28 = VAR_0->ppv_map_ref_idx_to_poc
+ VAR_32;
VAR_27[0] = 0;
VAR_27++;
VAR_28[0] = 0;
VAR_28++;
for(VAR_23 = 0; VAR_23 < VAR_0->ps_cur_slice->u1_num_ref_idx_lx_active[1];
VAR_23++)
{
UWORD8 VAR_33 = VAR_23 << 1;
VAR_24 = VAR_0->ps_ref_pic_buf_lx[1][VAR_23];
VAR_27[VAR_33] = (VAR_24->pu1_buf1);
VAR_28[VAR_33 + 1] = (VAR_24->pu1_buf1);
VAR_28[VAR_33] = (VAR_24->pu1_buf1) + 1;
VAR_27[VAR_33 + 1] = (VAR_24->pu1_buf1) + 1;
}
}
if(VAR_0->u4_num_cores >= 3)
{
WORD32 VAR_34;
WORD32 VAR_35;
VAR_34 = MIN(VAR_18, VAR_0->u4_num_ref_frames_at_init);
VAR_34 = 2 * ((2 * VAR_34) + 1);
VAR_35 = VAR_34 * sizeof(void *);
VAR_35 += VAR_36 * sizeof(void *);
memcpy((void *)VAR_0->ps_parse_cur_slice->ppv_map_ref_idx_to_poc,
VAR_0->ppv_map_ref_idx_to_poc,
VAR_35);
}
}
if(VAR_0->ps_cur_slice->u1_mbaff_frame_flag
&& (VAR_0->ps_cur_slice->u1_field_pic_flag == 0))
{
ih264d_convert_frm_mbaff_list(VAR_0);
}
if(VAR_2->u1_wted_bipred_idc == 1)
{
VAR_11 = ih264d_parse_pred_weight_table(VAR_3, VAR_4);
if(VAR_11 != VAR_37)
return VAR_11;
ih264d_form_pred_weight_matrix(VAR_0);
VAR_0->pu4_wt_ofsts = VAR_0->pu4_wts_ofsts_mat;
}
else if(VAR_2->u1_wted_bipred_idc == 2)
{
VAR_3->u2_log2Y_crwd = 0x0505;
VAR_0->pu4_wt_ofsts = VAR_0->pu4_wts_ofsts_mat;
ih264d_get_implicit_weights(VAR_0);
}
else
VAR_0->ps_cur_slice->u2_log2Y_crwd = 0;
VAR_0->ps_parse_cur_slice->u2_log2Y_crwd =
VAR_0->ps_cur_slice->u2_log2Y_crwd;
if(VAR_3->u1_nal_ref_idc != 0)
{
if(!VAR_0->ps_dpb_cmds->u1_dpb_commands_read)
VAR_0->u4_bitoffset = ih264d_read_mmco_commands(VAR_0);
else
VAR_4->u4_ofst += VAR_0->u4_bitoffset;
}
if(VAR_2->u1_entropy_coding_mode == VAR_38)
{
VAR_8 = ih264d_uev(VAR_7, VAR_6);
if(VAR_8 > VAR_39)
{
return VAR_40;
}
VAR_3->u1_cabac_init_idc = VAR_8;
COPYTHECONTEXT(""SH: cabac_init_idc"",VAR_3->u1_cabac_init_idc);
}
VAR_10 = VAR_2->u1_pic_init_qp
+ ih264d_sev(VAR_7, VAR_6);
if((VAR_10 < 0) || (VAR_10 > 51))
{
return VAR_41;
}
VAR_3->u1_slice_qp = VAR_10;
COPYTHECONTEXT(""SH: slice_qp_delta"",
(WORD8)(VAR_3->u1_slice_qp - VAR_2->u1_pic_init_qp));
if(VAR_2->u1_deblocking_filter_parameters_present_flag == 1)
{
VAR_8 = ih264d_uev(VAR_7, VAR_6);
if(VAR_8 > VAR_42)
{
return VAR_40;
} COPYTHECONTEXT(""SH: disable_deblocking_filter_idc"", VAR_8);
VAR_3->u1_disable_dblk_filter_idc = VAR_8;
if(VAR_8 != 1)
{
VAR_10 = ih264d_sev(VAR_7, VAR_6)
<< 1;
if((VAR_43 > VAR_10) || (VAR_10 > VAR_44))
{
return VAR_40;
}
VAR_3->i1_slice_alpha_c0_offset = VAR_10;
COPYTHECONTEXT(""SH: slice_alpha_c0_offset_div2"",
VAR_3->i1_slice_alpha_c0_offset >> 1);
VAR_10 = ih264d_sev(VAR_7, VAR_6)
<< 1;
if((VAR_43 > VAR_10) || (VAR_10 > VAR_44))
{
return VAR_40;
}
VAR_3->i1_slice_beta_offset = VAR_10;
COPYTHECONTEXT(""SH: slice_beta_offset_div2"",
VAR_3->i1_slice_beta_offset >> 1);
}
else
{
VAR_3->i1_slice_alpha_c0_offset = 0;
VAR_3->i1_slice_beta_offset = 0;
}
}
else
{
VAR_3->u1_disable_dblk_filter_idc = 0;
VAR_3->i1_slice_alpha_c0_offset = 0;
VAR_3->i1_slice_beta_offset = 0;
}
VAR_0->u1_slice_header_done = 2;
if(VAR_2->u1_entropy_coding_mode)
{
VAR_45; VAR_46;
VAR_0->pf_parse_inter_slice = VAR_47;
VAR_0->pf_parse_inter_mb = VAR_48;
ih264d_init_cabac_contexts(VAR_49, VAR_0);
if(VAR_0->ps_cur_slice->u1_mbaff_frame_flag)
VAR_0->pf_get_mb_info = VAR_50;
else
VAR_0->pf_get_mb_info = VAR_51;
}
else
{
VAR_52; VAR_53;
VAR_0->pf_parse_inter_slice = VAR_54;
VAR_0->pf_parse_inter_mb = VAR_55;
if(VAR_0->ps_cur_slice->u1_mbaff_frame_flag)
VAR_0->pf_get_mb_info = VAR_56;
else
VAR_0->pf_get_mb_info = VAR_57;
}
VAR_11 = ih264d_cal_col_pic(VAR_0);
if(VAR_11 != VAR_37)
return VAR_11;
VAR_0->u1_B = 1;
VAR_0->pf_mvpred_ref_tfr_nby2mb = VAR_58;
VAR_11 = VAR_0->pf_parse_inter_slice(VAR_0, VAR_3, VAR_1);
if(VAR_11 != VAR_37)
return VAR_11;
return VAR_37;
}",android/943323f1d9d3dd5c2634deb26cbe72343ca6b3db/ih264d_parse_bslice.c/vul/before/0.json,"WORD32 ih264d_parse_bslice(dec_struct_t * ps_dec, UWORD16 u2_first_mb_in_slice)
{
    dec_pic_params_t * ps_pps = ps_dec->ps_cur_pps;
    dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
    dec_bit_stream_t * ps_bitstrm = ps_dec->ps_bitstrm;
    UWORD8 u1_ref_idx_re_flag_lx;
    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;

    UWORD32 u4_temp, ui_temp1;
    WORD32 i_temp;
    WORD32 ret;

    /*--------------------------------------------------------------------*/
    /* Read remaining contents of the slice header                        */
    /*--------------------------------------------------------------------*/
    {
        WORD8 *pi1_buf;
        WORD16 *pi2_mv = ps_dec->s_default_mv_pred.i2_mv;
        WORD32 *pi4_mv = (WORD32*)pi2_mv;
        WORD16 *pi16_refFrame;
        pi1_buf = ps_dec->s_default_mv_pred.i1_ref_frame;
        pi16_refFrame = (WORD16*)pi1_buf;
        *pi4_mv = 0;
        *(pi4_mv + 1) = 0;
        *pi16_refFrame = OUT_OF_RANGE_REF;
        ps_dec->s_default_mv_pred.u1_col_ref_pic_idx = (UWORD8)-1;
        ps_dec->s_default_mv_pred.u1_pic_type = (UWORD8)-1;
    }

    ps_slice->u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264(
                    ps_bitstrm);
    COPYTHECONTEXT(""SH: num_ref_idx_override_flag"",
                    ps_slice->u1_num_ref_idx_active_override_flag);

    u4_temp = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[0];
    ui_temp1 = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[1];
    if(ps_slice->u1_num_ref_idx_active_override_flag)
    {
        u4_temp = 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
        COPYTHECONTEXT(""SH: num_ref_idx_l0_active_minus1"",
                        u4_temp - 1);
        ui_temp1 = 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
        COPYTHECONTEXT(""SH: num_ref_idx_l1_active_minus1"",
                        ui_temp1 - 1);
    }

    {
        UWORD8 u1_max_ref_idx = MAX_FRAMES;
        if(ps_slice->u1_field_pic_flag)
        {
            u1_max_ref_idx = MAX_FRAMES << 1;
        }
        if((u4_temp > u1_max_ref_idx) || (ui_temp1 > u1_max_ref_idx))
        {
            return ERROR_NUM_REF;
        }
        ps_slice->u1_num_ref_idx_lx_active[0] = u4_temp;
        ps_slice->u1_num_ref_idx_lx_active[1] = ui_temp1;
    }
    /* Initialize the Reference list once in Picture if the slice type    */
    /* of first slice is between 5 to 9 defined in table 7.3 of standard  */
    /* If picture contains both P & B slices then Initialize the Reference*/
    /* List only when it switches from P to B and B to P                     */

    {
        UWORD8 init_idx_flg = (ps_dec->u1_pr_sl_type
                        != ps_dec->ps_cur_slice->u1_slice_type);
        if(ps_dec->u1_first_pb_nal_in_pic
                        || (init_idx_flg & !ps_dec->u1_sl_typ_5_9)
                        || ps_dec->u1_num_ref_idx_lx_active_prev
                                        != ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0])
            ih264d_init_ref_idx_lx_b(ps_dec);
        if(ps_dec->u1_first_pb_nal_in_pic & ps_dec->u1_sl_typ_5_9)
            ps_dec->u1_first_pb_nal_in_pic = 0;
    }
    /* Store the value for future slices in the same picture */
    ps_dec->u1_num_ref_idx_lx_active_prev =
                    ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];

    u1_ref_idx_re_flag_lx = ih264d_get_bit_h264(ps_bitstrm);
    COPYTHECONTEXT(""SH: ref_pic_list_reordering_flag_l0"",u1_ref_idx_re_flag_lx);

    /* Modified temporarily */
    if(u1_ref_idx_re_flag_lx)
    {
        WORD8 ret;
        ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_mod_dpb[0];
        ret = ih264d_ref_idx_reordering(ps_dec, 0);
        if(ret == -1)
            return ERROR_REFIDX_ORDER_T;
    }
    else
        ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];

    u1_ref_idx_re_flag_lx = ih264d_get_bit_h264(ps_bitstrm);
    COPYTHECONTEXT(""SH: ref_pic_list_reordering_flag_l1"",u1_ref_idx_re_flag_lx);

    /* Modified temporarily */
    if(u1_ref_idx_re_flag_lx)
    {
        WORD8 ret;
        ps_dec->ps_ref_pic_buf_lx[1] = ps_dec->ps_dpb_mgr->ps_mod_dpb[1];
        ret = ih264d_ref_idx_reordering(ps_dec, 1);
        if(ret == -1)
            return ERROR_REFIDX_ORDER_T;
    }
    else
        ps_dec->ps_ref_pic_buf_lx[1] = ps_dec->ps_dpb_mgr->ps_init_dpb[1];

    /* Create refIdx to POC mapping */
    {
        void **ppv_map_ref_idx_to_poc_lx;
        WORD8 idx;
        struct pic_buffer_t *ps_pic;

        ppv_map_ref_idx_to_poc_lx = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L0;
        ppv_map_ref_idx_to_poc_lx[0] = 0;
        ppv_map_ref_idx_to_poc_lx++;
        for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];
                        idx++)
        {
            ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
            ppv_map_ref_idx_to_poc_lx[idx] = (ps_pic->pu1_buf1);
        }

        ppv_map_ref_idx_to_poc_lx = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L1;

        ppv_map_ref_idx_to_poc_lx[0] = 0;
        ppv_map_ref_idx_to_poc_lx++;
        for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1];
                        idx++)
        {
            ps_pic = ps_dec->ps_ref_pic_buf_lx[1][idx];
            ppv_map_ref_idx_to_poc_lx[idx] = (ps_pic->pu1_buf1);
        }

        if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
        {
            void **ppv_map_ref_idx_to_poc_lx_t, **ppv_map_ref_idx_to_poc_lx_b;

            ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc
                            + TOP_LIST_FLD_L0;
            ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc
                            + BOT_LIST_FLD_L0;

            ppv_map_ref_idx_to_poc_lx_t[0] = 0;
            ppv_map_ref_idx_to_poc_lx_t++;
            ppv_map_ref_idx_to_poc_lx_b[0] = 0;
            ppv_map_ref_idx_to_poc_lx_b++;
            for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];
                            idx++)
            {
                ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
                ppv_map_ref_idx_to_poc_lx_t[0] = (ps_pic->pu1_buf1);
                ppv_map_ref_idx_to_poc_lx_b[1] = (ps_pic->pu1_buf1);

                ppv_map_ref_idx_to_poc_lx_b[0] = (ps_pic->pu1_buf1) + 1;
                ppv_map_ref_idx_to_poc_lx_t[1] = (ps_pic->pu1_buf1) + 1;

                ppv_map_ref_idx_to_poc_lx_t += 2;
                ppv_map_ref_idx_to_poc_lx_b += 2;
            }

            ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc
                            + TOP_LIST_FLD_L1;
            ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc
                            + BOT_LIST_FLD_L1;

            ppv_map_ref_idx_to_poc_lx_t[0] = 0;
            ppv_map_ref_idx_to_poc_lx_t++;
            ppv_map_ref_idx_to_poc_lx_b[0] = 0;
            ppv_map_ref_idx_to_poc_lx_b++;
            for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1];
                            idx++)
            {
                UWORD8 u1_tmp_idx = idx << 1;
                ps_pic = ps_dec->ps_ref_pic_buf_lx[1][idx];
                ppv_map_ref_idx_to_poc_lx_t[u1_tmp_idx] = (ps_pic->pu1_buf1);
                ppv_map_ref_idx_to_poc_lx_b[u1_tmp_idx + 1] = (ps_pic->pu1_buf1);

                ppv_map_ref_idx_to_poc_lx_b[u1_tmp_idx] = (ps_pic->pu1_buf1) + 1;
                ppv_map_ref_idx_to_poc_lx_t[u1_tmp_idx + 1] = (ps_pic->pu1_buf1) + 1;

            }
        }

        if(ps_dec->u4_num_cores >= 3)
        {
            WORD32 num_entries;
            WORD32 size;

            num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);
            num_entries = 2 * ((2 * num_entries) + 1);

            size = num_entries * sizeof(void *);
            size += PAD_MAP_IDX_POC * sizeof(void *);

            memcpy((void *)ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc,
               ps_dec->ppv_map_ref_idx_to_poc,
               size);
        }

    }

    if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag
                    && (ps_dec->ps_cur_slice->u1_field_pic_flag == 0))
    {
        ih264d_convert_frm_mbaff_list(ps_dec);
    }

    if(ps_pps->u1_wted_bipred_idc == 1)
    {
        ret = ih264d_parse_pred_weight_table(ps_slice, ps_bitstrm);
        if(ret != OK)
            return ret;
        ih264d_form_pred_weight_matrix(ps_dec);
        ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
    }
    else if(ps_pps->u1_wted_bipred_idc == 2)
    {
        /* Implicit Weighted prediction */
        ps_slice->u2_log2Y_crwd = 0x0505;
        ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
        ih264d_get_implicit_weights(ps_dec);
    }
    else
        ps_dec->ps_cur_slice->u2_log2Y_crwd = 0;

    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =
                    ps_dec->ps_cur_slice->u2_log2Y_crwd;

    /* G050 */
    if(ps_slice->u1_nal_ref_idc != 0)
    {
        if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
        {
            i_temp = ih264d_read_mmco_commands(ps_dec);
            if (i_temp < 0)
            {
                return ERROR_DBP_MANAGER_T;
            }
            ps_dec->u4_bitoffset = i_temp;
        }
        else
            ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;
    }
    /* G050 */

    if(ps_pps->u1_entropy_coding_mode == CABAC)
    {
        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
        if(u4_temp > MAX_CABAC_INIT_IDC)
        {
            return ERROR_INV_SLICE_HDR_T;
        }
        ps_slice->u1_cabac_init_idc = u4_temp;
        COPYTHECONTEXT(""SH: cabac_init_idc"",ps_slice->u1_cabac_init_idc);
    }

    /* Read slice_qp_delta */
    i_temp = ps_pps->u1_pic_init_qp
                    + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
    if((i_temp < 0) || (i_temp > 51))
    {
        return ERROR_INV_RANGE_QP_T;
    }
    ps_slice->u1_slice_qp = i_temp;
    COPYTHECONTEXT(""SH: slice_qp_delta"",
                    (WORD8)(ps_slice->u1_slice_qp - ps_pps->u1_pic_init_qp));

    if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)
    {
        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
        if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)
        {
            return ERROR_INV_SLICE_HDR_T;
        } COPYTHECONTEXT(""SH: disable_deblocking_filter_idc"", u4_temp);
        ps_slice->u1_disable_dblk_filter_idc = u4_temp;
        if(u4_temp != 1)
        {
            i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
                            << 1;
            if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
            {
                return ERROR_INV_SLICE_HDR_T;
            }
            ps_slice->i1_slice_alpha_c0_offset = i_temp;
            COPYTHECONTEXT(""SH: slice_alpha_c0_offset_div2"",
                            ps_slice->i1_slice_alpha_c0_offset >> 1);

            i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
                            << 1;
            if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
            {
                return ERROR_INV_SLICE_HDR_T;
            }
            ps_slice->i1_slice_beta_offset = i_temp;
            COPYTHECONTEXT(""SH: slice_beta_offset_div2"",
                            ps_slice->i1_slice_beta_offset >> 1);

        }
        else
        {
            ps_slice->i1_slice_alpha_c0_offset = 0;
            ps_slice->i1_slice_beta_offset = 0;
        }
    }
    else
    {
        ps_slice->u1_disable_dblk_filter_idc = 0;
        ps_slice->i1_slice_alpha_c0_offset = 0;
        ps_slice->i1_slice_beta_offset = 0;
    }

    ps_dec->u1_slice_header_done = 2;

    if(ps_pps->u1_entropy_coding_mode)
    {
        SWITCHOFFTRACE; SWITCHONTRACECABAC;
        ps_dec->pf_parse_inter_slice = ih264d_parse_inter_slice_data_cabac;
        ps_dec->pf_parse_inter_mb = ih264d_parse_bmb_cabac;
        ih264d_init_cabac_contexts(B_SLICE, ps_dec);

        if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;
        else
            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff;
    }
    else
    {
        SWITCHONTRACE; SWITCHOFFTRACECABAC;
        ps_dec->pf_parse_inter_slice = ih264d_parse_inter_slice_data_cavlc;
        ps_dec->pf_parse_inter_mb = ih264d_parse_bmb_cavlc;
        if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;
        else
            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff;
    }

    ret = ih264d_cal_col_pic(ps_dec);
    if(ret != OK)
        return ret;
    ps_dec->u1_B = 1;
    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_bmb;
    ret = ps_dec->pf_parse_inter_slice(ps_dec, ps_slice, u2_first_mb_in_slice);
    if(ret != OK)
        return ret;
    return OK;
}","WORD32 ih264d_parse_bslice(dec_struct_t * VAR_0, UWORD16 VAR_1)
{
    dec_pic_params_t * VAR_2 = VAR_0->ps_cur_pps;
    dec_slice_params_t * VAR_3 = VAR_0->ps_cur_slice;
    dec_bit_stream_t * VAR_4 = VAR_0->ps_bitstrm;
    UWORD8 VAR_5;
    UWORD32 *VAR_6 = VAR_4->pu4_buffer;
    UWORD32 *VAR_7 = &VAR_4->u4_ofst;

    UWORD32 VAR_8, VAR_9;
    WORD32 VAR_10;
    WORD32 VAR_11;

    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_0 */
    {
        WORD8 *VAR_12;
        WORD16 *VAR_13 = VAR_0->s_default_mv_pred.i2_mv;
        WORD32 *VAR_14 = (WORD32*)VAR_13;
        WORD16 *VAR_15;
        VAR_12 = VAR_0->s_default_mv_pred.i1_ref_frame;
        VAR_15 = (WORD16*)VAR_12;
        *VAR_14 = 0;
        *(VAR_14 + 1) = 0;
        *VAR_15 = VAR_16;
        VAR_0->s_default_mv_pred.u1_col_ref_pic_idx = (UWORD8)-1;
        VAR_0->s_default_mv_pred.u1_pic_type = (UWORD8)-1;
    }

    VAR_3->u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264(
                    VAR_4);
    COPYTHECONTEXT(""SH: num_ref_idx_override_flag"",
                    VAR_3->u1_num_ref_idx_active_override_flag);

    VAR_8 = VAR_0->ps_cur_pps->u1_num_ref_idx_lx_active[0];
    VAR_9 = VAR_0->ps_cur_pps->u1_num_ref_idx_lx_active[1];
    if(VAR_3->u1_num_ref_idx_active_override_flag)
    {
        VAR_8 = 1 + ih264d_uev(VAR_7, VAR_6);
        COPYTHECONTEXT(""SH: num_ref_idx_l0_active_minus1"",
                        VAR_8 - 1);
        VAR_9 = 1 + ih264d_uev(VAR_7, VAR_6);
        COPYTHECONTEXT(""SH: num_ref_idx_l1_active_minus1"",
                        VAR_9 - 1);
    }

    {
        UWORD8 VAR_17 = VAR_18;
        if(VAR_3->u1_field_pic_flag)
        {
            VAR_17 = VAR_18 << 1;
        }
        if((VAR_8 > VAR_17) || (VAR_9 > VAR_17))
        {
            return VAR_19;
        }
        VAR_3->u1_num_ref_idx_lx_active[0] = VAR_8;
        VAR_3->u1_num_ref_idx_lx_active[1] = VAR_9;
    }
    /* COMMENT_2 */
    /* COMMENT_3 */
    /* COMMENT_4 */
    /* COMMENT_5 */

    {
        UWORD8 VAR_20 = (VAR_0->u1_pr_sl_type
                        != VAR_0->ps_cur_slice->u1_slice_type);
        if(VAR_0->u1_first_pb_nal_in_pic
                        || (VAR_20 & !VAR_0->u1_sl_typ_5_9)
                        || VAR_0->u1_num_ref_idx_lx_active_prev
                                        != VAR_0->ps_cur_slice->u1_num_ref_idx_lx_active[0])
            ih264d_init_ref_idx_lx_b(VAR_0);
        if(VAR_0->u1_first_pb_nal_in_pic & VAR_0->u1_sl_typ_5_9)
            VAR_0->u1_first_pb_nal_in_pic = 0;
    }
    /* COMMENT_6 */
    VAR_0->u1_num_ref_idx_lx_active_prev =
                    VAR_0->ps_cur_slice->u1_num_ref_idx_lx_active[0];

    VAR_5 = ih264d_get_bit_h264(VAR_4);
    COPYTHECONTEXT(""SH: ref_pic_list_reordering_flag_l0"",VAR_5);

    /* COMMENT_7 */
    if(VAR_5)
    {
        WORD8 VAR_11;
        VAR_0->ps_ref_pic_buf_lx[0] = VAR_0->ps_dpb_mgr->ps_mod_dpb[0];
        VAR_11 = ih264d_ref_idx_reordering(VAR_0, 0);
        if(VAR_11 == -1)
            return VAR_21;
    }
    else
        VAR_0->ps_ref_pic_buf_lx[0] = VAR_0->ps_dpb_mgr->ps_init_dpb[0];

    VAR_5 = ih264d_get_bit_h264(VAR_4);
    COPYTHECONTEXT(""SH: ref_pic_list_reordering_flag_l1"",VAR_5);

    /* COMMENT_7 */
    if(VAR_5)
    {
        WORD8 VAR_11;
        VAR_0->ps_ref_pic_buf_lx[1] = VAR_0->ps_dpb_mgr->ps_mod_dpb[1];
        VAR_11 = ih264d_ref_idx_reordering(VAR_0, 1);
        if(VAR_11 == -1)
            return VAR_21;
    }
    else
        VAR_0->ps_ref_pic_buf_lx[1] = VAR_0->ps_dpb_mgr->ps_init_dpb[1];

    /* COMMENT_8 */
    {
        void **VAR_22;
        WORD8 VAR_23;
        struct pic_buffer_t *VAR_24;

        VAR_22 = VAR_0->ppv_map_ref_idx_to_poc + VAR_25;
        VAR_22[0] = 0;
        VAR_22++;
        for(VAR_23 = 0; VAR_23 < VAR_0->ps_cur_slice->u1_num_ref_idx_lx_active[0];
                        VAR_23++)
        {
            VAR_24 = VAR_0->ps_ref_pic_buf_lx[0][VAR_23];
            VAR_22[VAR_23] = (VAR_24->pu1_buf1);
        }

        VAR_22 = VAR_0->ppv_map_ref_idx_to_poc + VAR_26;

        VAR_22[0] = 0;
        VAR_22++;
        for(VAR_23 = 0; VAR_23 < VAR_0->ps_cur_slice->u1_num_ref_idx_lx_active[1];
                        VAR_23++)
        {
            VAR_24 = VAR_0->ps_ref_pic_buf_lx[1][VAR_23];
            VAR_22[VAR_23] = (VAR_24->pu1_buf1);
        }

        if(VAR_0->ps_cur_slice->u1_mbaff_frame_flag)
        {
            void **VAR_27, **VAR_28;

            VAR_27 = VAR_0->ppv_map_ref_idx_to_poc
                            + VAR_29;
            VAR_28 = VAR_0->ppv_map_ref_idx_to_poc
                            + VAR_30;

            VAR_27[0] = 0;
            VAR_27++;
            VAR_28[0] = 0;
            VAR_28++;
            for(VAR_23 = 0; VAR_23 < VAR_0->ps_cur_slice->u1_num_ref_idx_lx_active[0];
                            VAR_23++)
            {
                VAR_24 = VAR_0->ps_ref_pic_buf_lx[0][VAR_23];
                VAR_27[0] = (VAR_24->pu1_buf1);
                VAR_28[1] = (VAR_24->pu1_buf1);

                VAR_28[0] = (VAR_24->pu1_buf1) + 1;
                VAR_27[1] = (VAR_24->pu1_buf1) + 1;

                VAR_27 += 2;
                VAR_28 += 2;
            }

            VAR_27 = VAR_0->ppv_map_ref_idx_to_poc
                            + VAR_31;
            VAR_28 = VAR_0->ppv_map_ref_idx_to_poc
                            + VAR_32;

            VAR_27[0] = 0;
            VAR_27++;
            VAR_28[0] = 0;
            VAR_28++;
            for(VAR_23 = 0; VAR_23 < VAR_0->ps_cur_slice->u1_num_ref_idx_lx_active[1];
                            VAR_23++)
            {
                UWORD8 VAR_33 = VAR_23 << 1;
                VAR_24 = VAR_0->ps_ref_pic_buf_lx[1][VAR_23];
                VAR_27[VAR_33] = (VAR_24->pu1_buf1);
                VAR_28[VAR_33 + 1] = (VAR_24->pu1_buf1);

                VAR_28[VAR_33] = (VAR_24->pu1_buf1) + 1;
                VAR_27[VAR_33 + 1] = (VAR_24->pu1_buf1) + 1;

            }
        }

        if(VAR_0->u4_num_cores >= 3)
        {
            WORD32 VAR_34;
            WORD32 VAR_35;

            VAR_34 = MIN(VAR_18, VAR_0->u4_num_ref_frames_at_init);
            VAR_34 = 2 * ((2 * VAR_34) + 1);

            VAR_35 = VAR_34 * sizeof(void *);
            VAR_35 += VAR_36 * sizeof(void *);

            memcpy((void *)VAR_0->ps_parse_cur_slice->ppv_map_ref_idx_to_poc,
               VAR_0->ppv_map_ref_idx_to_poc,
               VAR_35);
        }

    }

    if(VAR_0->ps_cur_slice->u1_mbaff_frame_flag
                    && (VAR_0->ps_cur_slice->u1_field_pic_flag == 0))
    {
        ih264d_convert_frm_mbaff_list(VAR_0);
    }

    if(VAR_2->u1_wted_bipred_idc == 1)
    {
        VAR_11 = ih264d_parse_pred_weight_table(VAR_3, VAR_4);
        if(VAR_11 != VAR_37)
            return VAR_11;
        ih264d_form_pred_weight_matrix(VAR_0);
        VAR_0->pu4_wt_ofsts = VAR_0->pu4_wts_ofsts_mat;
    }
    else if(VAR_2->u1_wted_bipred_idc == 2)
    {
        /* COMMENT_9 */
        VAR_3->u2_log2Y_crwd = 0x0505;
        VAR_0->pu4_wt_ofsts = VAR_0->pu4_wts_ofsts_mat;
        ih264d_get_implicit_weights(VAR_0);
    }
    else
        VAR_0->ps_cur_slice->u2_log2Y_crwd = 0;

    VAR_0->ps_parse_cur_slice->u2_log2Y_crwd =
                    VAR_0->ps_cur_slice->u2_log2Y_crwd;

    /* COMMENT_10 */
    if(VAR_3->u1_nal_ref_idc != 0)
    {
        if(!VAR_0->ps_dpb_cmds->u1_dpb_commands_read)
        {
            VAR_10 = ih264d_read_mmco_commands(VAR_0);
            if (VAR_10 < 0)
            {
                return VAR_38;
            }
            VAR_0->u4_bitoffset = VAR_10;
        }
        else
            VAR_4->u4_ofst += VAR_0->u4_bitoffset;
    }
    /* COMMENT_10 */

    if(VAR_2->u1_entropy_coding_mode == VAR_39)
    {
        VAR_8 = ih264d_uev(VAR_7, VAR_6);
        if(VAR_8 > VAR_40)
        {
            return VAR_41;
        }
        VAR_3->u1_cabac_init_idc = VAR_8;
        COPYTHECONTEXT(""SH: cabac_init_idc"",VAR_3->u1_cabac_init_idc);
    }

    /* COMMENT_11 */
    VAR_10 = VAR_2->u1_pic_init_qp
                    + ih264d_sev(VAR_7, VAR_6);
    if((VAR_10 < 0) || (VAR_10 > 51))
    {
        return VAR_42;
    }
    VAR_3->u1_slice_qp = VAR_10;
    COPYTHECONTEXT(""SH: slice_qp_delta"",
                    (WORD8)(VAR_3->u1_slice_qp - VAR_2->u1_pic_init_qp));

    if(VAR_2->u1_deblocking_filter_parameters_present_flag == 1)
    {
        VAR_8 = ih264d_uev(VAR_7, VAR_6);
        if(VAR_8 > VAR_43)
        {
            return VAR_41;
        } COPYTHECONTEXT(""SH: disable_deblocking_filter_idc"", VAR_8);
        VAR_3->u1_disable_dblk_filter_idc = VAR_8;
        if(VAR_8 != 1)
        {
            VAR_10 = ih264d_sev(VAR_7, VAR_6)
                            << 1;
            if((VAR_44 > VAR_10) || (VAR_10 > VAR_45))
            {
                return VAR_41;
            }
            VAR_3->i1_slice_alpha_c0_offset = VAR_10;
            COPYTHECONTEXT(""SH: slice_alpha_c0_offset_div2"",
                            VAR_3->i1_slice_alpha_c0_offset >> 1);

            VAR_10 = ih264d_sev(VAR_7, VAR_6)
                            << 1;
            if((VAR_44 > VAR_10) || (VAR_10 > VAR_45))
            {
                return VAR_41;
            }
            VAR_3->i1_slice_beta_offset = VAR_10;
            COPYTHECONTEXT(""SH: slice_beta_offset_div2"",
                            VAR_3->i1_slice_beta_offset >> 1);

        }
        else
        {
            VAR_3->i1_slice_alpha_c0_offset = 0;
            VAR_3->i1_slice_beta_offset = 0;
        }
    }
    else
    {
        VAR_3->u1_disable_dblk_filter_idc = 0;
        VAR_3->i1_slice_alpha_c0_offset = 0;
        VAR_3->i1_slice_beta_offset = 0;
    }

    VAR_0->u1_slice_header_done = 2;

    if(VAR_2->u1_entropy_coding_mode)
    {
        VAR_46; VAR_47;
        VAR_0->pf_parse_inter_slice = VAR_48;
        VAR_0->pf_parse_inter_mb = VAR_49;
        ih264d_init_cabac_contexts(VAR_50, VAR_0);

        if(VAR_0->ps_cur_slice->u1_mbaff_frame_flag)
            VAR_0->pf_get_mb_info = VAR_51;
        else
            VAR_0->pf_get_mb_info = VAR_52;
    }
    else
    {
        VAR_53; VAR_54;
        VAR_0->pf_parse_inter_slice = VAR_55;
        VAR_0->pf_parse_inter_mb = VAR_56;
        if(VAR_0->ps_cur_slice->u1_mbaff_frame_flag)
            VAR_0->pf_get_mb_info = VAR_57;
        else
            VAR_0->pf_get_mb_info = VAR_58;
    }

    VAR_11 = ih264d_cal_col_pic(VAR_0);
    if(VAR_11 != VAR_37)
        return VAR_11;
    VAR_0->u1_B = 1;
    VAR_0->pf_mvpred_ref_tfr_nby2mb = VAR_59;
    VAR_11 = VAR_0->pf_parse_inter_slice(VAR_0, VAR_3, VAR_1);
    if(VAR_11 != VAR_37)
        return VAR_11;
    return VAR_37;
}",android/943323f1d9d3dd5c2634deb26cbe72343ca6b3db/ih264d_parse_bslice.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -234,7 +234,14 @@
     if(ps_slice->u1_nal_ref_idc != 0)
     {
         if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
-            ps_dec->u4_bitoffset = ih264d_read_mmco_commands(ps_dec);
+        {
+            i_temp = ih264d_read_mmco_commands(ps_dec);
+            if (i_temp < 0)
+            {
+                return ERROR_DBP_MANAGER_T;
+            }
+            ps_dec->u4_bitoffset = i_temp;
+        }
         else
             ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;
     }","{'deleted_lines': ['            ps_dec->u4_bitoffset = ih264d_read_mmco_commands(ps_dec);'], 'added_lines': ['        {', '            i_temp = ih264d_read_mmco_commands(ps_dec);', '            if (i_temp < 0)', '            {', '                return ERROR_DBP_MANAGER_T;', '            }', '            ps_dec->u4_bitoffset = i_temp;', '        }']}",True,"The H.264 decoder in libstagefright in Android 6.x before 2016-04-01 mishandles Memory Management Control Operation (MMCO) data, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 25818142.",8.4,HIGH,2,test,,5
CVE-2016-0842,['CWE-119'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,android,"Return error when there are more mmco params than allocated size

Bug: 25818142

Change-Id: I5c1b23985eeca5192b42703c627ca3d060e4e13d
",943323f1d9d3dd5c2634deb26cbe72343ca6b3db,https://android.googlesource.com/platform/external/libavc/+/943323f1d9d3dd5c2634deb26cbe72343ca6b3db,decoder/ih264d_parse_islice.c,ih264d_parse_islice,"WORD32 ih264d_parse_islice(dec_struct_t *ps_dec,
UWORD16 u2_first_mb_in_slice)
{
dec_pic_params_t * ps_pps = ps_dec->ps_cur_pps;
dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;
UWORD32 *pu4_bitstrm_ofst = &ps_dec->ps_bitstrm->u4_ofst;
UWORD32 u4_temp;
WORD32 i_temp;
WORD32 ret;
if(ps_slice->u1_nal_ref_idc != 0)
{
if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
ps_dec->u4_bitoffset = ih264d_read_mmco_commands(
ps_dec);
else
ps_dec->ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;
}
i_temp = ps_pps->u1_pic_init_qp
+ ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
if((i_temp < 0) || (i_temp > 51))
return ERROR_INV_RANGE_QP_T;
ps_slice->u1_slice_qp = i_temp;
COPYTHECONTEXT(""SH: slice_qp_delta"",
ps_slice->u1_slice_qp - ps_pps->u1_pic_init_qp);
if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)
{
u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
COPYTHECONTEXT(""SH: disable_deblocking_filter_idc"", u4_temp);
if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)
{
return ERROR_INV_SLICE_HDR_T;
}
ps_slice->u1_disable_dblk_filter_idc = u4_temp;
if(u4_temp != 1)
{
i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
<< 1;
if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
{
return ERROR_INV_SLICE_HDR_T;
}
ps_slice->i1_slice_alpha_c0_offset = i_temp;
COPYTHECONTEXT(""SH: slice_alpha_c0_offset_div2"",
ps_slice->i1_slice_alpha_c0_offset >> 1);
i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
<< 1;
if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
{
return ERROR_INV_SLICE_HDR_T;
}
ps_slice->i1_slice_beta_offset = i_temp;
COPYTHECONTEXT(""SH: slice_beta_offset_div2"",
ps_slice->i1_slice_beta_offset >> 1);
}
else
{
ps_slice->i1_slice_alpha_c0_offset = 0;
ps_slice->i1_slice_beta_offset = 0;
}
}
else
{
ps_slice->u1_disable_dblk_filter_idc = 0;
ps_slice->i1_slice_alpha_c0_offset = 0;
ps_slice->i1_slice_beta_offset = 0;
}
ps_dec->u2_mv_2mb[0] = 0;
ps_dec->u2_mv_2mb[1] = 0;
ps_dec->u1_slice_header_done = 2;
if(ps_pps->u1_entropy_coding_mode)
{
SWITCHOFFTRACE; SWITCHONTRACECABAC;
if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
{
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;
}
else
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff;
ret = ih264d_parse_islice_data_cabac(ps_dec, ps_slice,
u2_first_mb_in_slice);
if(ret != OK)
return ret;
SWITCHONTRACE; SWITCHOFFTRACECABAC;
}
else
{
if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
{
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;
}
else
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff;
ret = ih264d_parse_islice_data_cavlc(ps_dec, ps_slice,
u2_first_mb_in_slice);
if(ret != OK)
return ret;
}
return OK;
}","WORD32 ih264d_parse_islice(dec_struct_t *VAR_0,
UWORD16 VAR_1)
{
dec_pic_params_t * VAR_2 = VAR_0->ps_cur_pps;
dec_slice_params_t * VAR_3 = VAR_0->ps_cur_slice;
UWORD32 *VAR_4 = VAR_0->ps_bitstrm->pu4_buffer;
UWORD32 *VAR_5 = &VAR_0->ps_bitstrm->u4_ofst;
UWORD32 VAR_6;
WORD32 VAR_7;
WORD32 VAR_8;
if(VAR_3->u1_nal_ref_idc != 0)
{
if(!VAR_0->ps_dpb_cmds->u1_dpb_commands_read)
VAR_0->u4_bitoffset = ih264d_read_mmco_commands(
VAR_0);
else
VAR_0->ps_bitstrm->u4_ofst += VAR_0->u4_bitoffset;
}
VAR_7 = VAR_2->u1_pic_init_qp
+ ih264d_sev(VAR_5, VAR_4);
if((VAR_7 < 0) || (VAR_7 > 51))
return VAR_9;
VAR_3->u1_slice_qp = VAR_7;
COPYTHECONTEXT(""SH: slice_qp_delta"",
VAR_3->u1_slice_qp - VAR_2->u1_pic_init_qp);
if(VAR_2->u1_deblocking_filter_parameters_present_flag == 1)
{
VAR_6 = ih264d_uev(VAR_5, VAR_4);
COPYTHECONTEXT(""SH: disable_deblocking_filter_idc"", VAR_6);
if(VAR_6 > VAR_10)
{
return VAR_11;
}
VAR_3->u1_disable_dblk_filter_idc = VAR_6;
if(VAR_6 != 1)
{
VAR_7 = ih264d_sev(VAR_5, VAR_4)
<< 1;
if((VAR_12 > VAR_7) || (VAR_7 > VAR_13))
{
return VAR_11;
}
VAR_3->i1_slice_alpha_c0_offset = VAR_7;
COPYTHECONTEXT(""SH: slice_alpha_c0_offset_div2"",
VAR_3->i1_slice_alpha_c0_offset >> 1);
VAR_7 = ih264d_sev(VAR_5, VAR_4)
<< 1;
if((VAR_12 > VAR_7) || (VAR_7 > VAR_13))
{
return VAR_11;
}
VAR_3->i1_slice_beta_offset = VAR_7;
COPYTHECONTEXT(""SH: slice_beta_offset_div2"",
VAR_3->i1_slice_beta_offset >> 1);
}
else
{
VAR_3->i1_slice_alpha_c0_offset = 0;
VAR_3->i1_slice_beta_offset = 0;
}
}
else
{
VAR_3->u1_disable_dblk_filter_idc = 0;
VAR_3->i1_slice_alpha_c0_offset = 0;
VAR_3->i1_slice_beta_offset = 0;
}
VAR_0->u2_mv_2mb[0] = 0;
VAR_0->u2_mv_2mb[1] = 0;
VAR_0->u1_slice_header_done = 2;
if(VAR_2->u1_entropy_coding_mode)
{
VAR_14; VAR_15;
if(VAR_0->ps_cur_slice->u1_mbaff_frame_flag)
{
VAR_0->pf_get_mb_info = VAR_16;
}
else
VAR_0->pf_get_mb_info = VAR_17;
VAR_8 = ih264d_parse_islice_data_cabac(VAR_0, VAR_3,
VAR_1);
if(VAR_8 != VAR_18)
return VAR_8;
VAR_19; VAR_20;
}
else
{
if(VAR_0->ps_cur_slice->u1_mbaff_frame_flag)
{
VAR_0->pf_get_mb_info = VAR_21;
}
else
VAR_0->pf_get_mb_info = VAR_22;
VAR_8 = ih264d_parse_islice_data_cavlc(VAR_0, VAR_3,
VAR_1);
if(VAR_8 != VAR_18)
return VAR_8;
}
return VAR_18;
}",android/943323f1d9d3dd5c2634deb26cbe72343ca6b3db/ih264d_parse_islice.c/vul/before/0.json,"WORD32 ih264d_parse_islice(dec_struct_t *ps_dec,
                            UWORD16 u2_first_mb_in_slice)
{
    dec_pic_params_t * ps_pps = ps_dec->ps_cur_pps;
    dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
    UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;
    UWORD32 *pu4_bitstrm_ofst = &ps_dec->ps_bitstrm->u4_ofst;
    UWORD32 u4_temp;
    WORD32 i_temp;
    WORD32 ret;

    /*--------------------------------------------------------------------*/
    /* Read remaining contents of the slice header                        */
    /*--------------------------------------------------------------------*/
    /* dec_ref_pic_marking function */
    /* G050 */
    if(ps_slice->u1_nal_ref_idc != 0)
    {
        if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
        {
            i_temp = ih264d_read_mmco_commands(ps_dec);
            if (i_temp < 0)
            {
                return ERROR_DBP_MANAGER_T;
            }
            ps_dec->u4_bitoffset = i_temp;
        }
        else
            ps_dec->ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;
    }
    /* G050 */

    /* Read slice_qp_delta */
    i_temp = ps_pps->u1_pic_init_qp
                    + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
    if((i_temp < 0) || (i_temp > 51))
        return ERROR_INV_RANGE_QP_T;
    ps_slice->u1_slice_qp = i_temp;
    COPYTHECONTEXT(""SH: slice_qp_delta"",
                    ps_slice->u1_slice_qp - ps_pps->u1_pic_init_qp);

    if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)
    {
        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
        COPYTHECONTEXT(""SH: disable_deblocking_filter_idc"", u4_temp);

        if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)
        {
            return ERROR_INV_SLICE_HDR_T;
        }
        ps_slice->u1_disable_dblk_filter_idc = u4_temp;
        if(u4_temp != 1)
        {
            i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
                            << 1;
            if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
            {
                return ERROR_INV_SLICE_HDR_T;
            }
            ps_slice->i1_slice_alpha_c0_offset = i_temp;
            COPYTHECONTEXT(""SH: slice_alpha_c0_offset_div2"",
                            ps_slice->i1_slice_alpha_c0_offset >> 1);

            i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
                            << 1;
            if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
            {
                return ERROR_INV_SLICE_HDR_T;
            }
            ps_slice->i1_slice_beta_offset = i_temp;
            COPYTHECONTEXT(""SH: slice_beta_offset_div2"",
                            ps_slice->i1_slice_beta_offset >> 1);

        }
        else
        {
            ps_slice->i1_slice_alpha_c0_offset = 0;
            ps_slice->i1_slice_beta_offset = 0;
        }
    }
    else
    {
        ps_slice->u1_disable_dblk_filter_idc = 0;
        ps_slice->i1_slice_alpha_c0_offset = 0;
        ps_slice->i1_slice_beta_offset = 0;
    }

    /* Initialization to check if number of motion vector per 2 Mbs */
    /* are exceeding the range or not */
    ps_dec->u2_mv_2mb[0] = 0;
    ps_dec->u2_mv_2mb[1] = 0;


    /*set slice header cone to 2 ,to indicate  correct header*/
    ps_dec->u1_slice_header_done = 2;

    if(ps_pps->u1_entropy_coding_mode)
    {
        SWITCHOFFTRACE; SWITCHONTRACECABAC;
        if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
        {
            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;
        }
        else
            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff;

        ret = ih264d_parse_islice_data_cabac(ps_dec, ps_slice,
                                             u2_first_mb_in_slice);
        if(ret != OK)
            return ret;
        SWITCHONTRACE; SWITCHOFFTRACECABAC;
    }
    else
    {
        if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
        {
            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;
        }
        else
            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff;
        ret = ih264d_parse_islice_data_cavlc(ps_dec, ps_slice,
                                       u2_first_mb_in_slice);
        if(ret != OK)
            return ret;
    }

    return OK;
}","WORD32 ih264d_parse_islice(dec_struct_t *VAR_0,
                            UWORD16 VAR_1)
{
    dec_pic_params_t * VAR_2 = VAR_0->ps_cur_pps;
    dec_slice_params_t * VAR_3 = VAR_0->ps_cur_slice;
    UWORD32 *VAR_4 = VAR_0->ps_bitstrm->pu4_buffer;
    UWORD32 *VAR_5 = &VAR_0->ps_bitstrm->u4_ofst;
    UWORD32 VAR_6;
    WORD32 VAR_7;
    WORD32 VAR_8;

    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_0 */
    /* COMMENT_2 */
    /* COMMENT_3 */
    if(VAR_3->u1_nal_ref_idc != 0)
    {
        if(!VAR_0->ps_dpb_cmds->u1_dpb_commands_read)
        {
            VAR_7 = ih264d_read_mmco_commands(VAR_0);
            if (VAR_7 < 0)
            {
                return VAR_9;
            }
            VAR_0->u4_bitoffset = VAR_7;
        }
        else
            VAR_0->ps_bitstrm->u4_ofst += VAR_0->u4_bitoffset;
    }
    /* COMMENT_3 */

    /* COMMENT_4 */
    VAR_7 = VAR_2->u1_pic_init_qp
                    + ih264d_sev(VAR_5, VAR_4);
    if((VAR_7 < 0) || (VAR_7 > 51))
        return VAR_10;
    VAR_3->u1_slice_qp = VAR_7;
    COPYTHECONTEXT(""SH: slice_qp_delta"",
                    VAR_3->u1_slice_qp - VAR_2->u1_pic_init_qp);

    if(VAR_2->u1_deblocking_filter_parameters_present_flag == 1)
    {
        VAR_6 = ih264d_uev(VAR_5, VAR_4);
        COPYTHECONTEXT(""SH: disable_deblocking_filter_idc"", VAR_6);

        if(VAR_6 > VAR_11)
        {
            return VAR_12;
        }
        VAR_3->u1_disable_dblk_filter_idc = VAR_6;
        if(VAR_6 != 1)
        {
            VAR_7 = ih264d_sev(VAR_5, VAR_4)
                            << 1;
            if((VAR_13 > VAR_7) || (VAR_7 > VAR_14))
            {
                return VAR_12;
            }
            VAR_3->i1_slice_alpha_c0_offset = VAR_7;
            COPYTHECONTEXT(""SH: slice_alpha_c0_offset_div2"",
                            VAR_3->i1_slice_alpha_c0_offset >> 1);

            VAR_7 = ih264d_sev(VAR_5, VAR_4)
                            << 1;
            if((VAR_13 > VAR_7) || (VAR_7 > VAR_14))
            {
                return VAR_12;
            }
            VAR_3->i1_slice_beta_offset = VAR_7;
            COPYTHECONTEXT(""SH: slice_beta_offset_div2"",
                            VAR_3->i1_slice_beta_offset >> 1);

        }
        else
        {
            VAR_3->i1_slice_alpha_c0_offset = 0;
            VAR_3->i1_slice_beta_offset = 0;
        }
    }
    else
    {
        VAR_3->u1_disable_dblk_filter_idc = 0;
        VAR_3->i1_slice_alpha_c0_offset = 0;
        VAR_3->i1_slice_beta_offset = 0;
    }

    /* COMMENT_5 */
    /* COMMENT_6 */
    VAR_0->u2_mv_2mb[0] = 0;
    VAR_0->u2_mv_2mb[1] = 0;


    /* COMMENT_7 */
    VAR_0->u1_slice_header_done = 2;

    if(VAR_2->u1_entropy_coding_mode)
    {
        VAR_15; VAR_16;
        if(VAR_0->ps_cur_slice->u1_mbaff_frame_flag)
        {
            VAR_0->pf_get_mb_info = VAR_17;
        }
        else
            VAR_0->pf_get_mb_info = VAR_18;

        VAR_8 = ih264d_parse_islice_data_cabac(VAR_0, VAR_3,
                                             VAR_1);
        if(VAR_8 != VAR_19)
            return VAR_8;
        VAR_20; VAR_21;
    }
    else
    {
        if(VAR_0->ps_cur_slice->u1_mbaff_frame_flag)
        {
            VAR_0->pf_get_mb_info = VAR_22;
        }
        else
            VAR_0->pf_get_mb_info = VAR_23;
        VAR_8 = ih264d_parse_islice_data_cavlc(VAR_0, VAR_3,
                                       VAR_1);
        if(VAR_8 != VAR_19)
            return VAR_8;
    }

    return VAR_19;
}",android/943323f1d9d3dd5c2634deb26cbe72343ca6b3db/ih264d_parse_islice.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,8 +17,14 @@
     if(ps_slice->u1_nal_ref_idc != 0)
     {
         if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
-            ps_dec->u4_bitoffset = ih264d_read_mmco_commands(
-                            ps_dec);
+        {
+            i_temp = ih264d_read_mmco_commands(ps_dec);
+            if (i_temp < 0)
+            {
+                return ERROR_DBP_MANAGER_T;
+            }
+            ps_dec->u4_bitoffset = i_temp;
+        }
         else
             ps_dec->ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;
     }","{'deleted_lines': ['            ps_dec->u4_bitoffset = ih264d_read_mmco_commands(', '                            ps_dec);'], 'added_lines': ['        {', '            i_temp = ih264d_read_mmco_commands(ps_dec);', '            if (i_temp < 0)', '            {', '                return ERROR_DBP_MANAGER_T;', '            }', '            ps_dec->u4_bitoffset = i_temp;', '        }']}",True,"The H.264 decoder in libstagefright in Android 6.x before 2016-04-01 mishandles Memory Management Control Operation (MMCO) data, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 25818142.",8.4,HIGH,2,test,,5
CVE-2016-0842,['CWE-119'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,android,"Return error when there are more mmco params than allocated size

Bug: 25818142

Change-Id: I5c1b23985eeca5192b42703c627ca3d060e4e13d
",943323f1d9d3dd5c2634deb26cbe72343ca6b3db,https://android.googlesource.com/platform/external/libavc/+/943323f1d9d3dd5c2634deb26cbe72343ca6b3db,decoder/ih264d_dpb_mgr.c,ih264d_read_mmco_commands,"WORD32 ih264d_read_mmco_commands(struct _DecStruct * ps_dec)
{
dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;
dpb_commands_t *ps_dpb_cmds = ps_dec->ps_dpb_cmds;
dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
WORD32 j;
UWORD8 u1_buf_mode;
struct MMCParams *ps_mmc_params;
UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;
UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
UWORD32 u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst;
ps_slice->u1_mmco_equalto5 = 0;
{
if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)
{
ps_slice->u1_no_output_of_prior_pics_flag =
ih264d_get_bit_h264(ps_bitstrm);
COPYTHECONTEXT(""SH: no_output_of_prior_pics_flag"",
ps_slice->u1_no_output_of_prior_pics_flag);
ps_slice->u1_long_term_reference_flag = ih264d_get_bit_h264(
ps_bitstrm);
COPYTHECONTEXT(""SH: long_term_reference_flag"",
ps_slice->u1_long_term_reference_flag);
ps_dpb_cmds->u1_idr_pic = 1;
ps_dpb_cmds->u1_no_output_of_prior_pics_flag =
ps_slice->u1_no_output_of_prior_pics_flag;
ps_dpb_cmds->u1_long_term_reference_flag =
ps_slice->u1_long_term_reference_flag;
}
else
{
u1_buf_mode = ih264d_get_bit_h264(ps_bitstrm);             COPYTHECONTEXT(""SH: adaptive_ref_pic_buffering_flag"", u1_buf_mode);
ps_dpb_cmds->u1_buf_mode = u1_buf_mode;
j = 0;
if(u1_buf_mode == 1)
{
UWORD32 u4_mmco;
UWORD32 u4_diff_pic_num;
UWORD32 u4_lt_idx, u4_max_lt_idx;
u4_mmco = ih264d_uev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
while(u4_mmco != END_OF_MMCO)
{
ps_mmc_params = &ps_dpb_cmds->as_mmc_params[j];
ps_mmc_params->u4_mmco = u4_mmco;
switch(u4_mmco)
{
case MARK_ST_PICNUM_AS_NONREF:
u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num;
break;
case MARK_LT_INDEX_AS_NONREF:
u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
ps_mmc_params->u4_lt_idx = u4_lt_idx;
break;
case MARK_ST_PICNUM_AS_LT_INDEX:
u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num;
u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
ps_mmc_params->u4_lt_idx = u4_lt_idx;
break;
case SET_MAX_LT_INDEX:
{
u4_max_lt_idx = ih264d_uev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
ps_mmc_params->u4_max_lt_idx_plus1 = u4_max_lt_idx;
break;
}
case RESET_REF_PICTURES:
{
ps_slice->u1_mmco_equalto5 = 1;
break;
}
case SET_LT_INDEX:
u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
ps_mmc_params->u4_lt_idx = u4_lt_idx;
break;
default:
break;
}
u4_mmco = ih264d_uev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
j++;
}
ps_dpb_cmds->u1_num_of_commands = j;
}
}
ps_dpb_cmds->u1_dpb_commands_read = 1;
ps_dpb_cmds->u1_dpb_commands_read_slc = 1;
}
u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst - u4_bit_ofst;
return u4_bit_ofst;
}","WORD32 ih264d_read_mmco_commands(struct _DecStruct * VAR_0)
{
dec_bit_stream_t *VAR_1 = VAR_0->ps_bitstrm;
dpb_commands_t *VAR_2 = VAR_0->ps_dpb_cmds;
dec_slice_params_t * VAR_3 = VAR_0->ps_cur_slice;
WORD32 VAR_4;
UWORD8 VAR_5;
struct MMCParams *VAR_6;
UWORD32 *VAR_7 = VAR_0->ps_bitstrm->pu4_buffer;
UWORD32 *VAR_8 = &VAR_1->u4_ofst;
UWORD32 VAR_9 = VAR_0->ps_bitstrm->u4_ofst;
VAR_3->u1_mmco_equalto5 = 0;
{
if(VAR_0->u1_nal_unit_type == VAR_10)
{
VAR_3->u1_no_output_of_prior_pics_flag =
ih264d_get_bit_h264(VAR_1);
COPYTHECONTEXT(""SH: no_output_of_prior_pics_flag"",
VAR_3->u1_no_output_of_prior_pics_flag);
VAR_3->u1_long_term_reference_flag = ih264d_get_bit_h264(
VAR_1);
COPYTHECONTEXT(""SH: long_term_reference_flag"",
VAR_3->u1_long_term_reference_flag);
VAR_2->u1_idr_pic = 1;
VAR_2->u1_no_output_of_prior_pics_flag =
VAR_3->u1_no_output_of_prior_pics_flag;
VAR_2->u1_long_term_reference_flag =
VAR_3->u1_long_term_reference_flag;
}
else
{
VAR_5 = ih264d_get_bit_h264(VAR_1); 
COPYTHECONTEXT(""SH: adaptive_ref_pic_buffering_flag"", VAR_5);
VAR_2->u1_buf_mode = VAR_5;
VAR_4 = 0;
if(VAR_5 == 1)
{
UWORD32 VAR_11;
UWORD32 VAR_12;
UWORD32 VAR_13, VAR_14;
VAR_11 = ih264d_uev(VAR_8,
VAR_7);
while(VAR_11 != VAR_15)
{
VAR_6 = &VAR_2->as_mmc_params[VAR_4];
VAR_6->u4_mmco = VAR_11;
switch(VAR_11)
{
case VAR_16:
VAR_12 = ih264d_uev(VAR_8,
VAR_7);
VAR_6->u4_diff_pic_num = VAR_12;
break;
case VAR_17:
VAR_13 = ih264d_uev(VAR_8,
VAR_7);
VAR_6->u4_lt_idx = VAR_13;
break;
case VAR_18:
VAR_12 = ih264d_uev(VAR_8,
VAR_7);
VAR_6->u4_diff_pic_num = VAR_12;
VAR_13 = ih264d_uev(VAR_8,
VAR_7);
VAR_6->u4_lt_idx = VAR_13;
break;
case VAR_19:
{
VAR_14 = ih264d_uev(VAR_8,
VAR_7);
VAR_6->u4_max_lt_idx_plus1 = VAR_14;
break;
}
case VAR_20:
{
VAR_3->u1_mmco_equalto5 = 1;
break;
}
case VAR_21:
VAR_13 = ih264d_uev(VAR_8,
VAR_7);
VAR_6->u4_lt_idx = VAR_13;
break;
default:
break;
}
VAR_11 = ih264d_uev(VAR_8,
VAR_7);
VAR_4++;
}
VAR_2->u1_num_of_commands = VAR_4;
}
}
VAR_2->u1_dpb_commands_read = 1;
VAR_2->u1_dpb_commands_read_slc = 1;
}
VAR_9 = VAR_0->ps_bitstrm->u4_ofst - VAR_9;
return VAR_9;
}",android/943323f1d9d3dd5c2634deb26cbe72343ca6b3db/ih264d_dpb_mgr.c/vul/before/0.json,"WORD32 ih264d_read_mmco_commands(struct _DecStruct * ps_dec)
{
    dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;
    dpb_commands_t *ps_dpb_cmds = ps_dec->ps_dpb_cmds;
    dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
    WORD32 j;
    UWORD8 u1_buf_mode;
    struct MMCParams *ps_mmc_params;
    UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;
    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
    UWORD32 u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst;

    ps_slice->u1_mmco_equalto5 = 0;
    {
        if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)
        {
            ps_slice->u1_no_output_of_prior_pics_flag =
                            ih264d_get_bit_h264(ps_bitstrm);
            COPYTHECONTEXT(""SH: no_output_of_prior_pics_flag"",
                            ps_slice->u1_no_output_of_prior_pics_flag);
            ps_slice->u1_long_term_reference_flag = ih264d_get_bit_h264(
                            ps_bitstrm);
            COPYTHECONTEXT(""SH: long_term_reference_flag"",
                            ps_slice->u1_long_term_reference_flag);
            ps_dpb_cmds->u1_idr_pic = 1;
            ps_dpb_cmds->u1_no_output_of_prior_pics_flag =
                            ps_slice->u1_no_output_of_prior_pics_flag;
            ps_dpb_cmds->u1_long_term_reference_flag =
                            ps_slice->u1_long_term_reference_flag;
        }
        else
        {
            u1_buf_mode = ih264d_get_bit_h264(ps_bitstrm); //0 - sliding window; 1 - arbitrary
            COPYTHECONTEXT(""SH: adaptive_ref_pic_buffering_flag"", u1_buf_mode);
            ps_dpb_cmds->u1_buf_mode = u1_buf_mode;
            j = 0;

            if(u1_buf_mode == 1)
            {
                UWORD32 u4_mmco;
                UWORD32 u4_diff_pic_num;
                UWORD32 u4_lt_idx, u4_max_lt_idx;

                u4_mmco = ih264d_uev(pu4_bitstrm_ofst,
                                     pu4_bitstrm_buf);
                while(u4_mmco != END_OF_MMCO)
                {
                    if (j >= MAX_REF_BUFS)
                    {
                        ALOGE(""b/25818142"");
                        android_errorWriteLog(0x534e4554, ""25818142"");
                        ps_dpb_cmds->u1_num_of_commands = 0;
                        return -1;
                    }
                    ps_mmc_params = &ps_dpb_cmds->as_mmc_params[j];
                    ps_mmc_params->u4_mmco = u4_mmco;
                    switch(u4_mmco)
                    {
                        case MARK_ST_PICNUM_AS_NONREF:
                            u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst,
                                                         pu4_bitstrm_buf);
                            //Get absDiffPicnumMinus1
                            ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num;
                            break;

                        case MARK_LT_INDEX_AS_NONREF:
                            u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,
                                                   pu4_bitstrm_buf);
                            ps_mmc_params->u4_lt_idx = u4_lt_idx;
                            break;

                        case MARK_ST_PICNUM_AS_LT_INDEX:
                            u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst,
                                                         pu4_bitstrm_buf);
                            ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num;
                            u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,
                                                   pu4_bitstrm_buf);
                            ps_mmc_params->u4_lt_idx = u4_lt_idx;
                            break;

                        case SET_MAX_LT_INDEX:
                        {
                            u4_max_lt_idx = ih264d_uev(pu4_bitstrm_ofst,
                                                       pu4_bitstrm_buf);
                            ps_mmc_params->u4_max_lt_idx_plus1 = u4_max_lt_idx;
                            break;
                        }
                        case RESET_REF_PICTURES:
                        {
                            ps_slice->u1_mmco_equalto5 = 1;
                            break;
                        }

                        case SET_LT_INDEX:
                            u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,
                                                   pu4_bitstrm_buf);
                            ps_mmc_params->u4_lt_idx = u4_lt_idx;
                            break;

                        default:
                            break;
                    }
                    u4_mmco = ih264d_uev(pu4_bitstrm_ofst,
                                         pu4_bitstrm_buf);

                    j++;
                }
                ps_dpb_cmds->u1_num_of_commands = j;

            }
        }
        ps_dpb_cmds->u1_dpb_commands_read = 1;
        ps_dpb_cmds->u1_dpb_commands_read_slc = 1;

    }
    u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst - u4_bit_ofst;
    return u4_bit_ofst;
}","WORD32 ih264d_read_mmco_commands(struct _DecStruct * VAR_0)
{
    dec_bit_stream_t *VAR_1 = VAR_0->ps_bitstrm;
    dpb_commands_t *VAR_2 = VAR_0->ps_dpb_cmds;
    dec_slice_params_t * VAR_3 = VAR_0->ps_cur_slice;
    WORD32 VAR_4;
    UWORD8 VAR_5;
    struct MMCParams *VAR_6;
    UWORD32 *VAR_7 = VAR_0->ps_bitstrm->pu4_buffer;
    UWORD32 *VAR_8 = &VAR_1->u4_ofst;
    UWORD32 VAR_9 = VAR_0->ps_bitstrm->u4_ofst;

    VAR_3->u1_mmco_equalto5 = 0;
    {
        if(VAR_0->u1_nal_unit_type == VAR_10)
        {
            VAR_3->u1_no_output_of_prior_pics_flag =
                            ih264d_get_bit_h264(VAR_1);
            COPYTHECONTEXT(""SH: no_output_of_prior_pics_flag"",
                            VAR_3->u1_no_output_of_prior_pics_flag);
            VAR_3->u1_long_term_reference_flag = ih264d_get_bit_h264(
                            VAR_1);
            COPYTHECONTEXT(""SH: long_term_reference_flag"",
                            VAR_3->u1_long_term_reference_flag);
            VAR_2->u1_idr_pic = 1;
            VAR_2->u1_no_output_of_prior_pics_flag =
                            VAR_3->u1_no_output_of_prior_pics_flag;
            VAR_2->u1_long_term_reference_flag =
                            VAR_3->u1_long_term_reference_flag;
        }
        else
        {
            VAR_5 = ih264d_get_bit_h264(VAR_1); /* COMMENT_0 */
            COPYTHECONTEXT(""SH: adaptive_ref_pic_buffering_flag"", VAR_5);
            VAR_2->u1_buf_mode = VAR_5;
            VAR_4 = 0;

            if(VAR_5 == 1)
            {
                UWORD32 VAR_11;
                UWORD32 VAR_12;
                UWORD32 VAR_13, VAR_14;

                VAR_11 = ih264d_uev(VAR_8,
                                     VAR_7);
                while(VAR_11 != VAR_15)
                {
                    if (VAR_4 >= VAR_16)
                    {
                        ALOGE(""b/25818142"");
                        android_errorWriteLog(0x534e4554, ""25818142"");
                        VAR_2->u1_num_of_commands = 0;
                        return -1;
                    }
                    VAR_6 = &VAR_2->as_mmc_params[VAR_4];
                    VAR_6->u4_mmco = VAR_11;
                    switch(VAR_11)
                    {
                        case VAR_17:
                            VAR_12 = ih264d_uev(VAR_8,
                                                         VAR_7);
                            /* COMMENT_1 */
                            VAR_6->u4_diff_pic_num = VAR_12;
                            break;

                        case VAR_18:
                            VAR_13 = ih264d_uev(VAR_8,
                                                   VAR_7);
                            VAR_6->u4_lt_idx = VAR_13;
                            break;

                        case VAR_19:
                            VAR_12 = ih264d_uev(VAR_8,
                                                         VAR_7);
                            VAR_6->u4_diff_pic_num = VAR_12;
                            VAR_13 = ih264d_uev(VAR_8,
                                                   VAR_7);
                            VAR_6->u4_lt_idx = VAR_13;
                            break;

                        case VAR_20:
                        {
                            VAR_14 = ih264d_uev(VAR_8,
                                                       VAR_7);
                            VAR_6->u4_max_lt_idx_plus1 = VAR_14;
                            break;
                        }
                        case VAR_21:
                        {
                            VAR_3->u1_mmco_equalto5 = 1;
                            break;
                        }

                        case VAR_22:
                            VAR_13 = ih264d_uev(VAR_8,
                                                   VAR_7);
                            VAR_6->u4_lt_idx = VAR_13;
                            break;

                        default:
                            break;
                    }
                    VAR_11 = ih264d_uev(VAR_8,
                                         VAR_7);

                    VAR_4++;
                }
                VAR_2->u1_num_of_commands = VAR_4;

            }
        }
        VAR_2->u1_dpb_commands_read = 1;
        VAR_2->u1_dpb_commands_read_slc = 1;

    }
    VAR_9 = VAR_0->ps_bitstrm->u4_ofst - VAR_9;
    return VAR_9;
}",android/943323f1d9d3dd5c2634deb26cbe72343ca6b3db/ih264d_dpb_mgr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -45,6 +45,13 @@
                                      pu4_bitstrm_buf);
                 while(u4_mmco != END_OF_MMCO)
                 {
+                    if (j >= MAX_REF_BUFS)
+                    {
+                        ALOGE(""b/25818142"");
+                        android_errorWriteLog(0x534e4554, ""25818142"");
+                        ps_dpb_cmds->u1_num_of_commands = 0;
+                        return -1;
+                    }
                     ps_mmc_params = &ps_dpb_cmds->as_mmc_params[j];
                     ps_mmc_params->u4_mmco = u4_mmco;
                     switch(u4_mmco)","{'deleted_lines': [], 'added_lines': ['                    if (j >= MAX_REF_BUFS)', '                    {', '                        ALOGE(""b/25818142"");', '                        android_errorWriteLog(0x534e4554, ""25818142"");', '                        ps_dpb_cmds->u1_num_of_commands = 0;', '                        return -1;', '                    }']}",True,"The H.264 decoder in libstagefright in Android 6.x before 2016-04-01 mishandles Memory Management Control Operation (MMCO) data, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 25818142.",8.4,HIGH,2,test,,5
CVE-2016-0842,['CWE-119'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,android,"Return error when there are more mmco params than allocated size

Bug: 25818142

Change-Id: I5c1b23985eeca5192b42703c627ca3d060e4e13d
",943323f1d9d3dd5c2634deb26cbe72343ca6b3db,https://android.googlesource.com/platform/external/libavc/+/943323f1d9d3dd5c2634deb26cbe72343ca6b3db,decoder/ih264d_parse_pslice.c,ih264d_parse_pslice,"WORD32 ih264d_parse_pslice(dec_struct_t *ps_dec, UWORD16 u2_first_mb_in_slice)
{
dec_pic_params_t * ps_pps = ps_dec->ps_cur_pps;
dec_slice_params_t * ps_cur_slice = ps_dec->ps_cur_slice;
dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;
UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
UWORD8 u1_mbaff = ps_dec->ps_cur_slice->u1_mbaff_frame_flag;     UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;
UWORD32 u4_temp;
WORD32 i_temp;
WORD32 ret;
{
WORD8 *pi1_buf;
WORD16 *pi2_mv = ps_dec->s_default_mv_pred.i2_mv;
WORD32 *pi4_mv = (WORD32*)pi2_mv;
WORD16 *pi16_refFrame;
pi1_buf = ps_dec->s_default_mv_pred.i1_ref_frame;
pi16_refFrame = (WORD16*)pi1_buf;
*pi4_mv = 0;
*(pi4_mv + 1) = 0;
*pi16_refFrame = OUT_OF_RANGE_REF;
ps_dec->s_default_mv_pred.u1_col_ref_pic_idx = (UWORD8)-1;
ps_dec->s_default_mv_pred.u1_pic_type = (UWORD8)-1;
}
ps_cur_slice->u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264(
ps_bitstrm);
COPYTHECONTEXT(""SH: num_ref_idx_override_flag"",
ps_cur_slice->u1_num_ref_idx_active_override_flag);
u4_temp = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[0];
if(ps_cur_slice->u1_num_ref_idx_active_override_flag)
{
u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf) + 1;
}
{
UWORD8 u1_max_ref_idx = MAX_FRAMES << u1_field_pic_flag;
if(u4_temp > u1_max_ref_idx)
{
return ERROR_NUM_REF;
}
ps_cur_slice->u1_num_ref_idx_lx_active[0] = u4_temp;
COPYTHECONTEXT(""SH: num_ref_idx_l0_active_minus1"",
ps_cur_slice->u1_num_ref_idx_lx_active[0] - 1);
}
{
UWORD8 uc_refIdxReFlagL0 = ih264d_get_bit_h264(ps_bitstrm);
COPYTHECONTEXT(""SH: ref_pic_list_reordering_flag_l0"",uc_refIdxReFlagL0);
{
UWORD8 init_idx_flg = (ps_dec->u1_pr_sl_type
!= ps_dec->ps_cur_slice->u1_slice_type);
if(ps_dec->u1_first_pb_nal_in_pic
|| (init_idx_flg & !ps_dec->u1_sl_typ_5_9)
|| ps_dec->u1_num_ref_idx_lx_active_prev
!= ps_cur_slice->u1_num_ref_idx_lx_active[0])
{
ih264d_init_ref_idx_lx_p(ps_dec);
}
if(ps_dec->u1_first_pb_nal_in_pic & ps_dec->u1_sl_typ_5_9)
ps_dec->u1_first_pb_nal_in_pic = 0;
}
ps_dec->u1_num_ref_idx_lx_active_prev =
ps_cur_slice->u1_num_ref_idx_lx_active[0];
if(uc_refIdxReFlagL0)
{
WORD8 ret;
ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_mod_dpb[0];
ret = ih264d_ref_idx_reordering(ps_dec, 0);
if(ret == -1)
return ERROR_REFIDX_ORDER_T;
ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_mod_dpb[0];
}
else
ps_dec->ps_ref_pic_buf_lx[0] =
ps_dec->ps_dpb_mgr->ps_init_dpb[0];
}
{
void **pui_map_ref_idx_to_poc_lx0, **pui_map_ref_idx_to_poc_lx1;
WORD8 idx;
struct pic_buffer_t *ps_pic;
pui_map_ref_idx_to_poc_lx0 = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L0;
pui_map_ref_idx_to_poc_lx0[0] = 0;         pui_map_ref_idx_to_poc_lx0++;
for(idx = 0; idx < ps_cur_slice->u1_num_ref_idx_lx_active[0]; idx++)
{
ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
pui_map_ref_idx_to_poc_lx0[idx] = (ps_pic->pu1_buf1);
}
pui_map_ref_idx_to_poc_lx1 = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L1;
pui_map_ref_idx_to_poc_lx1[0] = 0;
if(u1_mbaff)
{
void **ppv_map_ref_idx_to_poc_lx_t, **ppv_map_ref_idx_to_poc_lx_b;
void **ppv_map_ref_idx_to_poc_lx_t1, **ppv_map_ref_idx_to_poc_lx_b1;
ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc
+ TOP_LIST_FLD_L0;
ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc
+ BOT_LIST_FLD_L0;
ppv_map_ref_idx_to_poc_lx_t[0] = 0;             ppv_map_ref_idx_to_poc_lx_t++;
ppv_map_ref_idx_to_poc_lx_b[0] = 0;             ppv_map_ref_idx_to_poc_lx_b++;
idx = 0;
for(idx = 0; idx < ps_cur_slice->u1_num_ref_idx_lx_active[0]; idx++)
{
ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
ppv_map_ref_idx_to_poc_lx_t[0] = (ps_pic->pu1_buf1);
ppv_map_ref_idx_to_poc_lx_b[1] = (ps_pic->pu1_buf1);
ppv_map_ref_idx_to_poc_lx_b[0] = (ps_pic->pu1_buf1) + 1;
ppv_map_ref_idx_to_poc_lx_t[1] = (ps_pic->pu1_buf1) + 1;
ppv_map_ref_idx_to_poc_lx_t += 2;
ppv_map_ref_idx_to_poc_lx_b += 2;
}
ppv_map_ref_idx_to_poc_lx_t1 = ps_dec->ppv_map_ref_idx_to_poc
+ TOP_LIST_FLD_L1;
ppv_map_ref_idx_to_poc_lx_t1[0] = 0;
ppv_map_ref_idx_to_poc_lx_b1 = ps_dec->ppv_map_ref_idx_to_poc
+ BOT_LIST_FLD_L1;
ppv_map_ref_idx_to_poc_lx_b1[0] = 0;
}
if(ps_dec->u4_num_cores >= 3)
{
WORD32 num_entries;
WORD32 size;
num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);
num_entries = 2 * ((2 * num_entries) + 1);
size = num_entries * sizeof(void *);
size += PAD_MAP_IDX_POC * sizeof(void *);
memcpy((void *)ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc,
ps_dec->ppv_map_ref_idx_to_poc,
size);
}
}
if(ps_pps->u1_wted_pred_flag)
{
ret = ih264d_parse_pred_weight_table(ps_cur_slice, ps_bitstrm);
if(ret != OK)
return ret;
ih264d_form_pred_weight_matrix(ps_dec);
ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
}
else
{
ps_dec->ps_cur_slice->u2_log2Y_crwd = 0;
ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
}
ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =
ps_dec->ps_cur_slice->u2_log2Y_crwd;
if(u1_mbaff && (u1_field_pic_flag == 0))
{
ih264d_convert_frm_mbaff_list(ps_dec);
}
if(ps_cur_slice->u1_nal_ref_idc != 0)
{
if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
ps_dec->u4_bitoffset = ih264d_read_mmco_commands(ps_dec);
else
ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;
}
if(ps_pps->u1_entropy_coding_mode == CABAC)
{
u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
if(u4_temp > MAX_CABAC_INIT_IDC)
{
return ERROR_INV_SLICE_HDR_T;
}
ps_cur_slice->u1_cabac_init_idc = u4_temp;
COPYTHECONTEXT(""SH: cabac_init_idc"",ps_cur_slice->u1_cabac_init_idc);
}
i_temp = ps_pps->u1_pic_init_qp
+ ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
if((i_temp < 0) || (i_temp > 51))
{
return ERROR_INV_RANGE_QP_T;
}
ps_cur_slice->u1_slice_qp = i_temp;
COPYTHECONTEXT(""SH: slice_qp_delta"",
(WORD8)(ps_cur_slice->u1_slice_qp - ps_pps->u1_pic_init_qp));
if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)
{
u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)
{
return ERROR_INV_SLICE_HDR_T;
}
COPYTHECONTEXT(""SH: disable_deblocking_filter_idc"", u4_temp);
ps_cur_slice->u1_disable_dblk_filter_idc = u4_temp;
if(u4_temp != 1)
{
i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
<< 1;
if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
{
return ERROR_INV_SLICE_HDR_T;
}
ps_cur_slice->i1_slice_alpha_c0_offset = i_temp;
COPYTHECONTEXT(""SH: slice_alpha_c0_offset_div2"",
ps_cur_slice->i1_slice_alpha_c0_offset >> 1);
i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
<< 1;
if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
{
return ERROR_INV_SLICE_HDR_T;
}
ps_cur_slice->i1_slice_beta_offset = i_temp;
COPYTHECONTEXT(""SH: slice_beta_offset_div2"",
ps_cur_slice->i1_slice_beta_offset >> 1);
}
else
{
ps_cur_slice->i1_slice_alpha_c0_offset = 0;
ps_cur_slice->i1_slice_beta_offset = 0;
}
}
else
{
ps_cur_slice->u1_disable_dblk_filter_idc = 0;
ps_cur_slice->i1_slice_alpha_c0_offset = 0;
ps_cur_slice->i1_slice_beta_offset = 0;
}
ps_dec->u1_slice_header_done = 2;
if(ps_pps->u1_entropy_coding_mode)
{
SWITCHOFFTRACE; SWITCHONTRACECABAC;
ps_dec->pf_parse_inter_slice = ih264d_parse_inter_slice_data_cabac;
ps_dec->pf_parse_inter_mb = ih264d_parse_pmb_cabac;
ih264d_init_cabac_contexts(P_SLICE, ps_dec);
if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;
else
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff;
}
else
{
SWITCHONTRACE; SWITCHOFFTRACECABAC;
ps_dec->pf_parse_inter_slice = ih264d_parse_inter_slice_data_cavlc;
ps_dec->pf_parse_inter_mb = ih264d_parse_pmb_cavlc;
if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
{
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;
}
else
ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff;
}
ps_dec->u1_B = 0;
ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;
ret = ps_dec->pf_parse_inter_slice(ps_dec, ps_cur_slice, u2_first_mb_in_slice);
if(ret != OK)
return ret;
return OK;
}","WORD32 ih264d_parse_pslice(dec_struct_t *VAR_0, UWORD16 VAR_1)
{
dec_pic_params_t * VAR_2 = VAR_0->ps_cur_pps;
dec_slice_params_t * VAR_3 = VAR_0->ps_cur_slice;
dec_bit_stream_t *VAR_4 = VAR_0->ps_bitstrm;
UWORD32 *VAR_5 = VAR_4->pu4_buffer;
UWORD32 *VAR_6 = &VAR_4->u4_ofst;
UWORD8 VAR_7 = VAR_0->ps_cur_slice->u1_mbaff_frame_flag; 
UWORD8 VAR_8 = VAR_3->u1_field_pic_flag;
UWORD32 VAR_9;
WORD32 VAR_10;
WORD32 VAR_11;
{
WORD8 *VAR_12;
WORD16 *VAR_13 = VAR_0->s_default_mv_pred.i2_mv;
WORD32 *VAR_14 = (WORD32*)VAR_13;
WORD16 *VAR_15;
VAR_12 = VAR_0->s_default_mv_pred.i1_ref_frame;
VAR_15 = (WORD16*)VAR_12;
*VAR_14 = 0;
*(VAR_14 + 1) = 0;
*VAR_15 = VAR_16;
VAR_0->s_default_mv_pred.u1_col_ref_pic_idx = (UWORD8)-1;
VAR_0->s_default_mv_pred.u1_pic_type = (UWORD8)-1;
}
VAR_3->u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264(
VAR_4);
COPYTHECONTEXT(""SH: num_ref_idx_override_flag"",
VAR_3->u1_num_ref_idx_active_override_flag);
VAR_9 = VAR_0->ps_cur_pps->u1_num_ref_idx_lx_active[0];
if(VAR_3->u1_num_ref_idx_active_override_flag)
{
VAR_9 = ih264d_uev(VAR_6, VAR_5) + 1;
}
{
UWORD8 VAR_17 = VAR_18 << VAR_8;
if(VAR_9 > VAR_17)
{
return VAR_19;
}
VAR_3->u1_num_ref_idx_lx_active[0] = VAR_9;
COPYTHECONTEXT(""SH: num_ref_idx_l0_active_minus1"",
VAR_3->u1_num_ref_idx_lx_active[0] - 1);
}
{
UWORD8 VAR_20 = ih264d_get_bit_h264(VAR_4);
COPYTHECONTEXT(""SH: ref_pic_list_reordering_flag_l0"",VAR_20);
{
UWORD8 VAR_21 = (VAR_0->u1_pr_sl_type
!= VAR_0->ps_cur_slice->u1_slice_type);
if(VAR_0->u1_first_pb_nal_in_pic
|| (VAR_21 & !VAR_0->u1_sl_typ_5_9)
|| VAR_0->u1_num_ref_idx_lx_active_prev
!= VAR_3->u1_num_ref_idx_lx_active[0])
{
ih264d_init_ref_idx_lx_p(VAR_0);
}
if(VAR_0->u1_first_pb_nal_in_pic & VAR_0->u1_sl_typ_5_9)
VAR_0->u1_first_pb_nal_in_pic = 0;
}
VAR_0->u1_num_ref_idx_lx_active_prev =
VAR_3->u1_num_ref_idx_lx_active[0];
if(VAR_20)
{
WORD8 VAR_11;
VAR_0->ps_ref_pic_buf_lx[0] = VAR_0->ps_dpb_mgr->ps_mod_dpb[0];
VAR_11 = ih264d_ref_idx_reordering(VAR_0, 0);
if(VAR_11 == -1)
return VAR_22;
VAR_0->ps_ref_pic_buf_lx[0] = VAR_0->ps_dpb_mgr->ps_mod_dpb[0];
}
else
VAR_0->ps_ref_pic_buf_lx[0] =
VAR_0->ps_dpb_mgr->ps_init_dpb[0];
}
{
void **VAR_23, **VAR_24;
WORD8 VAR_25;
struct pic_buffer_t *VAR_26;
VAR_23 = VAR_0->ppv_map_ref_idx_to_poc + VAR_27;
VAR_23[0] = 0; 
VAR_23++;
for(VAR_25 = 0; VAR_25 < VAR_3->u1_num_ref_idx_lx_active[0]; VAR_25++)
{
VAR_26 = VAR_0->ps_ref_pic_buf_lx[0][VAR_25];
VAR_23[VAR_25] = (VAR_26->pu1_buf1);
}
VAR_24 = VAR_0->ppv_map_ref_idx_to_poc + VAR_28;
VAR_24[0] = 0;
if(VAR_7)
{
void **VAR_29, **VAR_30;
void **VAR_31, **VAR_32;
VAR_29 = VAR_0->ppv_map_ref_idx_to_poc
+ VAR_33;
VAR_30 = VAR_0->ppv_map_ref_idx_to_poc
+ VAR_34;
VAR_29[0] = 0; 
VAR_29++;
VAR_30[0] = 0; 
VAR_30++;
VAR_25 = 0;
for(VAR_25 = 0; VAR_25 < VAR_3->u1_num_ref_idx_lx_active[0]; VAR_25++)
{
VAR_26 = VAR_0->ps_ref_pic_buf_lx[0][VAR_25];
VAR_29[0] = (VAR_26->pu1_buf1);
VAR_30[1] = (VAR_26->pu1_buf1);
VAR_30[0] = (VAR_26->pu1_buf1) + 1;
VAR_29[1] = (VAR_26->pu1_buf1) + 1;
VAR_29 += 2;
VAR_30 += 2;
}
VAR_31 = VAR_0->ppv_map_ref_idx_to_poc
+ VAR_35;
VAR_31[0] = 0;
VAR_32 = VAR_0->ppv_map_ref_idx_to_poc
+ VAR_36;
VAR_32[0] = 0;
}
if(VAR_0->u4_num_cores >= 3)
{
WORD32 VAR_37;
WORD32 VAR_38;
VAR_37 = MIN(VAR_18, VAR_0->u4_num_ref_frames_at_init);
VAR_37 = 2 * ((2 * VAR_37) + 1);
VAR_38 = VAR_37 * sizeof(void *);
VAR_38 += VAR_39 * sizeof(void *);
memcpy((void *)VAR_0->ps_parse_cur_slice->ppv_map_ref_idx_to_poc,
VAR_0->ppv_map_ref_idx_to_poc,
VAR_38);
}
}
if(VAR_2->u1_wted_pred_flag)
{
VAR_11 = ih264d_parse_pred_weight_table(VAR_3, VAR_4);
if(VAR_11 != VAR_40)
return VAR_11;
ih264d_form_pred_weight_matrix(VAR_0);
VAR_0->pu4_wt_ofsts = VAR_0->pu4_wts_ofsts_mat;
}
else
{
VAR_0->ps_cur_slice->u2_log2Y_crwd = 0;
VAR_0->pu4_wt_ofsts = VAR_0->pu4_wts_ofsts_mat;
}
VAR_0->ps_parse_cur_slice->u2_log2Y_crwd =
VAR_0->ps_cur_slice->u2_log2Y_crwd;
if(VAR_7 && (VAR_8 == 0))
{
ih264d_convert_frm_mbaff_list(VAR_0);
}
if(VAR_3->u1_nal_ref_idc != 0)
{
if(!VAR_0->ps_dpb_cmds->u1_dpb_commands_read)
VAR_0->u4_bitoffset = ih264d_read_mmco_commands(VAR_0);
else
VAR_4->u4_ofst += VAR_0->u4_bitoffset;
}
if(VAR_2->u1_entropy_coding_mode == VAR_41)
{
VAR_9 = ih264d_uev(VAR_6, VAR_5);
if(VAR_9 > VAR_42)
{
return VAR_43;
}
VAR_3->u1_cabac_init_idc = VAR_9;
COPYTHECONTEXT(""SH: cabac_init_idc"",VAR_3->u1_cabac_init_idc);
}
VAR_10 = VAR_2->u1_pic_init_qp
+ ih264d_sev(VAR_6, VAR_5);
if((VAR_10 < 0) || (VAR_10 > 51))
{
return VAR_44;
}
VAR_3->u1_slice_qp = VAR_10;
COPYTHECONTEXT(""SH: slice_qp_delta"",
(WORD8)(VAR_3->u1_slice_qp - VAR_2->u1_pic_init_qp));
if(VAR_2->u1_deblocking_filter_parameters_present_flag == 1)
{
VAR_9 = ih264d_uev(VAR_6, VAR_5);
if(VAR_9 > VAR_45)
{
return VAR_43;
}
COPYTHECONTEXT(""SH: disable_deblocking_filter_idc"", VAR_9);
VAR_3->u1_disable_dblk_filter_idc = VAR_9;
if(VAR_9 != 1)
{
VAR_10 = ih264d_sev(VAR_6, VAR_5)
<< 1;
if((VAR_46 > VAR_10) || (VAR_10 > VAR_47))
{
return VAR_43;
}
VAR_3->i1_slice_alpha_c0_offset = VAR_10;
COPYTHECONTEXT(""SH: slice_alpha_c0_offset_div2"",
VAR_3->i1_slice_alpha_c0_offset >> 1);
VAR_10 = ih264d_sev(VAR_6, VAR_5)
<< 1;
if((VAR_46 > VAR_10) || (VAR_10 > VAR_47))
{
return VAR_43;
}
VAR_3->i1_slice_beta_offset = VAR_10;
COPYTHECONTEXT(""SH: slice_beta_offset_div2"",
VAR_3->i1_slice_beta_offset >> 1);
}
else
{
VAR_3->i1_slice_alpha_c0_offset = 0;
VAR_3->i1_slice_beta_offset = 0;
}
}
else
{
VAR_3->u1_disable_dblk_filter_idc = 0;
VAR_3->i1_slice_alpha_c0_offset = 0;
VAR_3->i1_slice_beta_offset = 0;
}
VAR_0->u1_slice_header_done = 2;
if(VAR_2->u1_entropy_coding_mode)
{
VAR_48; VAR_49;
VAR_0->pf_parse_inter_slice = VAR_50;
VAR_0->pf_parse_inter_mb = VAR_51;
ih264d_init_cabac_contexts(VAR_52, VAR_0);
if(VAR_0->ps_cur_slice->u1_mbaff_frame_flag)
VAR_0->pf_get_mb_info = VAR_53;
else
VAR_0->pf_get_mb_info = VAR_54;
}
else
{
VAR_55; VAR_56;
VAR_0->pf_parse_inter_slice = VAR_57;
VAR_0->pf_parse_inter_mb = VAR_58;
if(VAR_0->ps_cur_slice->u1_mbaff_frame_flag)
{
VAR_0->pf_get_mb_info = VAR_59;
}
else
VAR_0->pf_get_mb_info = VAR_60;
}
VAR_0->u1_B = 0;
VAR_0->pf_mvpred_ref_tfr_nby2mb = VAR_61;
VAR_11 = VAR_0->pf_parse_inter_slice(VAR_0, VAR_3, VAR_1);
if(VAR_11 != VAR_40)
return VAR_11;
return VAR_40;
}",android/943323f1d9d3dd5c2634deb26cbe72343ca6b3db/ih264d_parse_pslice.c/vul/before/0.json,"WORD32 ih264d_parse_pslice(dec_struct_t *ps_dec, UWORD16 u2_first_mb_in_slice)
{
    dec_pic_params_t * ps_pps = ps_dec->ps_cur_pps;
    dec_slice_params_t * ps_cur_slice = ps_dec->ps_cur_slice;
    dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;
    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
    UWORD8 u1_mbaff = ps_dec->ps_cur_slice->u1_mbaff_frame_flag; //ps_dec->ps_cur_sps->u1_mb_aff_flag;
    UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;

    UWORD32 u4_temp;
    WORD32 i_temp;
    WORD32 ret;

    /*--------------------------------------------------------------------*/
    /* Read remaining contents of the slice header                        */
    /*--------------------------------------------------------------------*/
    {
        WORD8 *pi1_buf;
        WORD16 *pi2_mv = ps_dec->s_default_mv_pred.i2_mv;
        WORD32 *pi4_mv = (WORD32*)pi2_mv;
        WORD16 *pi16_refFrame;

        pi1_buf = ps_dec->s_default_mv_pred.i1_ref_frame;
        pi16_refFrame = (WORD16*)pi1_buf;
        *pi4_mv = 0;
        *(pi4_mv + 1) = 0;
        *pi16_refFrame = OUT_OF_RANGE_REF;
        ps_dec->s_default_mv_pred.u1_col_ref_pic_idx = (UWORD8)-1;
        ps_dec->s_default_mv_pred.u1_pic_type = (UWORD8)-1;
    }

    ps_cur_slice->u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264(
                    ps_bitstrm);

    COPYTHECONTEXT(""SH: num_ref_idx_override_flag"",
                    ps_cur_slice->u1_num_ref_idx_active_override_flag);

    u4_temp = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[0];
    if(ps_cur_slice->u1_num_ref_idx_active_override_flag)
    {
        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf) + 1;
    }

    {



        UWORD8 u1_max_ref_idx = MAX_FRAMES << u1_field_pic_flag;
        if(u4_temp > u1_max_ref_idx)
        {
            return ERROR_NUM_REF;
        }
        ps_cur_slice->u1_num_ref_idx_lx_active[0] = u4_temp;
        COPYTHECONTEXT(""SH: num_ref_idx_l0_active_minus1"",
                        ps_cur_slice->u1_num_ref_idx_lx_active[0] - 1);

    }

    {
        UWORD8 uc_refIdxReFlagL0 = ih264d_get_bit_h264(ps_bitstrm);
        COPYTHECONTEXT(""SH: ref_pic_list_reordering_flag_l0"",uc_refIdxReFlagL0);

        /* Initialize the Reference list once in Picture if the slice type    */
        /* of first slice is between 5 to 9 defined in table 7.3 of standard  */
        /* If picture contains both P & B slices then Initialize the Reference*/
        /* List only when it switches from P to B and B to P                     */
        {
            UWORD8 init_idx_flg = (ps_dec->u1_pr_sl_type
                            != ps_dec->ps_cur_slice->u1_slice_type);
            if(ps_dec->u1_first_pb_nal_in_pic
                            || (init_idx_flg & !ps_dec->u1_sl_typ_5_9)
                            || ps_dec->u1_num_ref_idx_lx_active_prev
                                            != ps_cur_slice->u1_num_ref_idx_lx_active[0])
            {
                ih264d_init_ref_idx_lx_p(ps_dec);
            }
            if(ps_dec->u1_first_pb_nal_in_pic & ps_dec->u1_sl_typ_5_9)
                ps_dec->u1_first_pb_nal_in_pic = 0;
        }
        /* Store the value for future slices in the same picture */
        ps_dec->u1_num_ref_idx_lx_active_prev =
                        ps_cur_slice->u1_num_ref_idx_lx_active[0];

        /* Modified temporarily */
        if(uc_refIdxReFlagL0)
        {
            WORD8 ret;
            ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_mod_dpb[0];
            ret = ih264d_ref_idx_reordering(ps_dec, 0);
            if(ret == -1)
                return ERROR_REFIDX_ORDER_T;
            ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_mod_dpb[0];
        }
        else
            ps_dec->ps_ref_pic_buf_lx[0] =
                            ps_dec->ps_dpb_mgr->ps_init_dpb[0];
    }
    /* Create refIdx to POC mapping */
    {
        void **pui_map_ref_idx_to_poc_lx0, **pui_map_ref_idx_to_poc_lx1;
        WORD8 idx;
        struct pic_buffer_t *ps_pic;

        pui_map_ref_idx_to_poc_lx0 = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L0;
        pui_map_ref_idx_to_poc_lx0[0] = 0; //For ref_idx = -1
        pui_map_ref_idx_to_poc_lx0++;
        for(idx = 0; idx < ps_cur_slice->u1_num_ref_idx_lx_active[0]; idx++)
        {
            ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
            pui_map_ref_idx_to_poc_lx0[idx] = (ps_pic->pu1_buf1);
        }

        /* Bug Fix Deblocking */
        pui_map_ref_idx_to_poc_lx1 = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L1;
        pui_map_ref_idx_to_poc_lx1[0] = 0;

        if(u1_mbaff)
        {
            void **ppv_map_ref_idx_to_poc_lx_t, **ppv_map_ref_idx_to_poc_lx_b;
            void **ppv_map_ref_idx_to_poc_lx_t1, **ppv_map_ref_idx_to_poc_lx_b1;
            ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc
                            + TOP_LIST_FLD_L0;
            ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc
                            + BOT_LIST_FLD_L0;

            ppv_map_ref_idx_to_poc_lx_t[0] = 0; //  For ref_idx = -1
            ppv_map_ref_idx_to_poc_lx_t++;
            ppv_map_ref_idx_to_poc_lx_b[0] = 0; // For ref_idx = -1
            ppv_map_ref_idx_to_poc_lx_b++;

            idx = 0;
            for(idx = 0; idx < ps_cur_slice->u1_num_ref_idx_lx_active[0]; idx++)
            {
                ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
                ppv_map_ref_idx_to_poc_lx_t[0] = (ps_pic->pu1_buf1);
                ppv_map_ref_idx_to_poc_lx_b[1] = (ps_pic->pu1_buf1);

                ppv_map_ref_idx_to_poc_lx_b[0] = (ps_pic->pu1_buf1) + 1;
                ppv_map_ref_idx_to_poc_lx_t[1] = (ps_pic->pu1_buf1) + 1;

                ppv_map_ref_idx_to_poc_lx_t += 2;
                ppv_map_ref_idx_to_poc_lx_b += 2;
            }
            ppv_map_ref_idx_to_poc_lx_t1 = ps_dec->ppv_map_ref_idx_to_poc
                            + TOP_LIST_FLD_L1;
            ppv_map_ref_idx_to_poc_lx_t1[0] = 0;
            ppv_map_ref_idx_to_poc_lx_b1 = ps_dec->ppv_map_ref_idx_to_poc
                            + BOT_LIST_FLD_L1;
            ppv_map_ref_idx_to_poc_lx_b1[0] = 0;

        }

        if(ps_dec->u4_num_cores >= 3)
        {
            WORD32 num_entries;
            WORD32 size;

            num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);
            num_entries = 2 * ((2 * num_entries) + 1);

            size = num_entries * sizeof(void *);
            size += PAD_MAP_IDX_POC * sizeof(void *);

            memcpy((void *)ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc,
                   ps_dec->ppv_map_ref_idx_to_poc,
                   size);
        }


    }
    if(ps_pps->u1_wted_pred_flag)
    {
        ret = ih264d_parse_pred_weight_table(ps_cur_slice, ps_bitstrm);
        if(ret != OK)
            return ret;
        ih264d_form_pred_weight_matrix(ps_dec);
        ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
    }
    else
    {
        ps_dec->ps_cur_slice->u2_log2Y_crwd = 0;
        ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
    }

    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =
                    ps_dec->ps_cur_slice->u2_log2Y_crwd;

    if(u1_mbaff && (u1_field_pic_flag == 0))
    {
        ih264d_convert_frm_mbaff_list(ps_dec);
    }

    /* G050 */
    if(ps_cur_slice->u1_nal_ref_idc != 0)
    {
        if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
        {
            i_temp = ih264d_read_mmco_commands(ps_dec);
            if (i_temp < 0)
            {
                return ERROR_DBP_MANAGER_T;
            }
            ps_dec->u4_bitoffset = i_temp;
        }
        else
            ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;

    }
    /* G050 */

    if(ps_pps->u1_entropy_coding_mode == CABAC)
    {
        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);

        if(u4_temp > MAX_CABAC_INIT_IDC)
        {
            return ERROR_INV_SLICE_HDR_T;
        }
        ps_cur_slice->u1_cabac_init_idc = u4_temp;
        COPYTHECONTEXT(""SH: cabac_init_idc"",ps_cur_slice->u1_cabac_init_idc);
    }

    /* Read slice_qp_delta */
    i_temp = ps_pps->u1_pic_init_qp
                    + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
    if((i_temp < 0) || (i_temp > 51))
    {
        return ERROR_INV_RANGE_QP_T;
    }
    ps_cur_slice->u1_slice_qp = i_temp;
    COPYTHECONTEXT(""SH: slice_qp_delta"",
                    (WORD8)(ps_cur_slice->u1_slice_qp - ps_pps->u1_pic_init_qp));

    if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)
    {
        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
        if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)
        {
            return ERROR_INV_SLICE_HDR_T;
        }

        COPYTHECONTEXT(""SH: disable_deblocking_filter_idc"", u4_temp);
        ps_cur_slice->u1_disable_dblk_filter_idc = u4_temp;
        if(u4_temp != 1)
        {
            i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
                            << 1;
            if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
            {
                return ERROR_INV_SLICE_HDR_T;
            }
            ps_cur_slice->i1_slice_alpha_c0_offset = i_temp;
            COPYTHECONTEXT(""SH: slice_alpha_c0_offset_div2"",
                            ps_cur_slice->i1_slice_alpha_c0_offset >> 1);

            i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
                            << 1;
            if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
            {
                return ERROR_INV_SLICE_HDR_T;
            }
            ps_cur_slice->i1_slice_beta_offset = i_temp;
            COPYTHECONTEXT(""SH: slice_beta_offset_div2"",
                            ps_cur_slice->i1_slice_beta_offset >> 1);
        }
        else
        {
            ps_cur_slice->i1_slice_alpha_c0_offset = 0;
            ps_cur_slice->i1_slice_beta_offset = 0;
        }
    }
    else
    {
        ps_cur_slice->u1_disable_dblk_filter_idc = 0;
        ps_cur_slice->i1_slice_alpha_c0_offset = 0;
        ps_cur_slice->i1_slice_beta_offset = 0;
    }

    ps_dec->u1_slice_header_done = 2;

    if(ps_pps->u1_entropy_coding_mode)
    {
        SWITCHOFFTRACE; SWITCHONTRACECABAC;
        ps_dec->pf_parse_inter_slice = ih264d_parse_inter_slice_data_cabac;
        ps_dec->pf_parse_inter_mb = ih264d_parse_pmb_cabac;
        ih264d_init_cabac_contexts(P_SLICE, ps_dec);

        if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;
        else
            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff;
    }
    else
    {
        SWITCHONTRACE; SWITCHOFFTRACECABAC;
        ps_dec->pf_parse_inter_slice = ih264d_parse_inter_slice_data_cavlc;
        ps_dec->pf_parse_inter_mb = ih264d_parse_pmb_cavlc;
        if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
        {
            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;
        }
        else
            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff;
    }

    ps_dec->u1_B = 0;
    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;
    ret = ps_dec->pf_parse_inter_slice(ps_dec, ps_cur_slice, u2_first_mb_in_slice);
    if(ret != OK)
        return ret;
//    ps_dec->curr_slice_in_error = 0 ;
    return OK;
}","WORD32 ih264d_parse_pslice(dec_struct_t *VAR_0, UWORD16 VAR_1)
{
    dec_pic_params_t * VAR_2 = VAR_0->ps_cur_pps;
    dec_slice_params_t * VAR_3 = VAR_0->ps_cur_slice;
    dec_bit_stream_t *VAR_4 = VAR_0->ps_bitstrm;
    UWORD32 *VAR_5 = VAR_4->pu4_buffer;
    UWORD32 *VAR_6 = &VAR_4->u4_ofst;
    UWORD8 VAR_7 = VAR_0->ps_cur_slice->u1_mbaff_frame_flag; /* COMMENT_0 */
    UWORD8 VAR_8 = VAR_3->u1_field_pic_flag;

    UWORD32 VAR_9;
    WORD32 VAR_10;
    WORD32 VAR_11;

    /* COMMENT_1 */
    /* COMMENT_2 */
    /* COMMENT_1 */
    {
        WORD8 *VAR_12;
        WORD16 *VAR_13 = VAR_0->s_default_mv_pred.i2_mv;
        WORD32 *VAR_14 = (WORD32*)VAR_13;
        WORD16 *VAR_15;

        VAR_12 = VAR_0->s_default_mv_pred.i1_ref_frame;
        VAR_15 = (WORD16*)VAR_12;
        *VAR_14 = 0;
        *(VAR_14 + 1) = 0;
        *VAR_15 = VAR_16;
        VAR_0->s_default_mv_pred.u1_col_ref_pic_idx = (UWORD8)-1;
        VAR_0->s_default_mv_pred.u1_pic_type = (UWORD8)-1;
    }

    VAR_3->u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264(
                    VAR_4);

    COPYTHECONTEXT(""SH: num_ref_idx_override_flag"",
                    VAR_3->u1_num_ref_idx_active_override_flag);

    VAR_9 = VAR_0->ps_cur_pps->u1_num_ref_idx_lx_active[0];
    if(VAR_3->u1_num_ref_idx_active_override_flag)
    {
        VAR_9 = ih264d_uev(VAR_6, VAR_5) + 1;
    }

    {



        UWORD8 VAR_17 = VAR_18 << VAR_8;
        if(VAR_9 > VAR_17)
        {
            return VAR_19;
        }
        VAR_3->u1_num_ref_idx_lx_active[0] = VAR_9;
        COPYTHECONTEXT(""SH: num_ref_idx_l0_active_minus1"",
                        VAR_3->u1_num_ref_idx_lx_active[0] - 1);

    }

    {
        UWORD8 VAR_20 = ih264d_get_bit_h264(VAR_4);
        COPYTHECONTEXT(""SH: ref_pic_list_reordering_flag_l0"",VAR_20);

        /* COMMENT_3 */
        /* COMMENT_4 */
        /* COMMENT_5 */
        /* COMMENT_6 */
        {
            UWORD8 VAR_21 = (VAR_0->u1_pr_sl_type
                            != VAR_0->ps_cur_slice->u1_slice_type);
            if(VAR_0->u1_first_pb_nal_in_pic
                            || (VAR_21 & !VAR_0->u1_sl_typ_5_9)
                            || VAR_0->u1_num_ref_idx_lx_active_prev
                                            != VAR_3->u1_num_ref_idx_lx_active[0])
            {
                ih264d_init_ref_idx_lx_p(VAR_0);
            }
            if(VAR_0->u1_first_pb_nal_in_pic & VAR_0->u1_sl_typ_5_9)
                VAR_0->u1_first_pb_nal_in_pic = 0;
        }
        /* COMMENT_7 */
        VAR_0->u1_num_ref_idx_lx_active_prev =
                        VAR_3->u1_num_ref_idx_lx_active[0];

        /* COMMENT_8 */
        if(VAR_20)
        {
            WORD8 VAR_11;
            VAR_0->ps_ref_pic_buf_lx[0] = VAR_0->ps_dpb_mgr->ps_mod_dpb[0];
            VAR_11 = ih264d_ref_idx_reordering(VAR_0, 0);
            if(VAR_11 == -1)
                return VAR_22;
            VAR_0->ps_ref_pic_buf_lx[0] = VAR_0->ps_dpb_mgr->ps_mod_dpb[0];
        }
        else
            VAR_0->ps_ref_pic_buf_lx[0] =
                            VAR_0->ps_dpb_mgr->ps_init_dpb[0];
    }
    /* COMMENT_9 */
    {
        void **VAR_23, **VAR_24;
        WORD8 VAR_25;
        struct pic_buffer_t *VAR_26;

        VAR_23 = VAR_0->ppv_map_ref_idx_to_poc + VAR_27;
        VAR_23[0] = 0; /* COMMENT_10 */
        VAR_23++;
        for(VAR_25 = 0; VAR_25 < VAR_3->u1_num_ref_idx_lx_active[0]; VAR_25++)
        {
            VAR_26 = VAR_0->ps_ref_pic_buf_lx[0][VAR_25];
            VAR_23[VAR_25] = (VAR_26->pu1_buf1);
        }

        /* COMMENT_11 */
        VAR_24 = VAR_0->ppv_map_ref_idx_to_poc + VAR_28;
        VAR_24[0] = 0;

        if(VAR_7)
        {
            void **VAR_29, **VAR_30;
            void **VAR_31, **VAR_32;
            VAR_29 = VAR_0->ppv_map_ref_idx_to_poc
                            + VAR_33;
            VAR_30 = VAR_0->ppv_map_ref_idx_to_poc
                            + VAR_34;

            VAR_29[0] = 0; /* COMMENT_12 */
            VAR_29++;
            VAR_30[0] = 0; /* COMMENT_13 */
            VAR_30++;

            VAR_25 = 0;
            for(VAR_25 = 0; VAR_25 < VAR_3->u1_num_ref_idx_lx_active[0]; VAR_25++)
            {
                VAR_26 = VAR_0->ps_ref_pic_buf_lx[0][VAR_25];
                VAR_29[0] = (VAR_26->pu1_buf1);
                VAR_30[1] = (VAR_26->pu1_buf1);

                VAR_30[0] = (VAR_26->pu1_buf1) + 1;
                VAR_29[1] = (VAR_26->pu1_buf1) + 1;

                VAR_29 += 2;
                VAR_30 += 2;
            }
            VAR_31 = VAR_0->ppv_map_ref_idx_to_poc
                            + VAR_35;
            VAR_31[0] = 0;
            VAR_32 = VAR_0->ppv_map_ref_idx_to_poc
                            + VAR_36;
            VAR_32[0] = 0;

        }

        if(VAR_0->u4_num_cores >= 3)
        {
            WORD32 VAR_37;
            WORD32 VAR_38;

            VAR_37 = MIN(VAR_18, VAR_0->u4_num_ref_frames_at_init);
            VAR_37 = 2 * ((2 * VAR_37) + 1);

            VAR_38 = VAR_37 * sizeof(void *);
            VAR_38 += VAR_39 * sizeof(void *);

            memcpy((void *)VAR_0->ps_parse_cur_slice->ppv_map_ref_idx_to_poc,
                   VAR_0->ppv_map_ref_idx_to_poc,
                   VAR_38);
        }


    }
    if(VAR_2->u1_wted_pred_flag)
    {
        VAR_11 = ih264d_parse_pred_weight_table(VAR_3, VAR_4);
        if(VAR_11 != VAR_40)
            return VAR_11;
        ih264d_form_pred_weight_matrix(VAR_0);
        VAR_0->pu4_wt_ofsts = VAR_0->pu4_wts_ofsts_mat;
    }
    else
    {
        VAR_0->ps_cur_slice->u2_log2Y_crwd = 0;
        VAR_0->pu4_wt_ofsts = VAR_0->pu4_wts_ofsts_mat;
    }

    VAR_0->ps_parse_cur_slice->u2_log2Y_crwd =
                    VAR_0->ps_cur_slice->u2_log2Y_crwd;

    if(VAR_7 && (VAR_8 == 0))
    {
        ih264d_convert_frm_mbaff_list(VAR_0);
    }

    /* COMMENT_14 */
    if(VAR_3->u1_nal_ref_idc != 0)
    {
        if(!VAR_0->ps_dpb_cmds->u1_dpb_commands_read)
        {
            VAR_10 = ih264d_read_mmco_commands(VAR_0);
            if (VAR_10 < 0)
            {
                return VAR_41;
            }
            VAR_0->u4_bitoffset = VAR_10;
        }
        else
            VAR_4->u4_ofst += VAR_0->u4_bitoffset;

    }
    /* COMMENT_14 */

    if(VAR_2->u1_entropy_coding_mode == VAR_42)
    {
        VAR_9 = ih264d_uev(VAR_6, VAR_5);

        if(VAR_9 > VAR_43)
        {
            return VAR_44;
        }
        VAR_3->u1_cabac_init_idc = VAR_9;
        COPYTHECONTEXT(""SH: cabac_init_idc"",VAR_3->u1_cabac_init_idc);
    }

    /* COMMENT_15 */
    VAR_10 = VAR_2->u1_pic_init_qp
                    + ih264d_sev(VAR_6, VAR_5);
    if((VAR_10 < 0) || (VAR_10 > 51))
    {
        return VAR_45;
    }
    VAR_3->u1_slice_qp = VAR_10;
    COPYTHECONTEXT(""SH: slice_qp_delta"",
                    (WORD8)(VAR_3->u1_slice_qp - VAR_2->u1_pic_init_qp));

    if(VAR_2->u1_deblocking_filter_parameters_present_flag == 1)
    {
        VAR_9 = ih264d_uev(VAR_6, VAR_5);
        if(VAR_9 > VAR_46)
        {
            return VAR_44;
        }

        COPYTHECONTEXT(""SH: disable_deblocking_filter_idc"", VAR_9);
        VAR_3->u1_disable_dblk_filter_idc = VAR_9;
        if(VAR_9 != 1)
        {
            VAR_10 = ih264d_sev(VAR_6, VAR_5)
                            << 1;
            if((VAR_47 > VAR_10) || (VAR_10 > VAR_48))
            {
                return VAR_44;
            }
            VAR_3->i1_slice_alpha_c0_offset = VAR_10;
            COPYTHECONTEXT(""SH: slice_alpha_c0_offset_div2"",
                            VAR_3->i1_slice_alpha_c0_offset >> 1);

            VAR_10 = ih264d_sev(VAR_6, VAR_5)
                            << 1;
            if((VAR_47 > VAR_10) || (VAR_10 > VAR_48))
            {
                return VAR_44;
            }
            VAR_3->i1_slice_beta_offset = VAR_10;
            COPYTHECONTEXT(""SH: slice_beta_offset_div2"",
                            VAR_3->i1_slice_beta_offset >> 1);
        }
        else
        {
            VAR_3->i1_slice_alpha_c0_offset = 0;
            VAR_3->i1_slice_beta_offset = 0;
        }
    }
    else
    {
        VAR_3->u1_disable_dblk_filter_idc = 0;
        VAR_3->i1_slice_alpha_c0_offset = 0;
        VAR_3->i1_slice_beta_offset = 0;
    }

    VAR_0->u1_slice_header_done = 2;

    if(VAR_2->u1_entropy_coding_mode)
    {
        VAR_49; VAR_50;
        VAR_0->pf_parse_inter_slice = VAR_51;
        VAR_0->pf_parse_inter_mb = VAR_52;
        ih264d_init_cabac_contexts(VAR_53, VAR_0);

        if(VAR_0->ps_cur_slice->u1_mbaff_frame_flag)
            VAR_0->pf_get_mb_info = VAR_54;
        else
            VAR_0->pf_get_mb_info = VAR_55;
    }
    else
    {
        VAR_56; VAR_57;
        VAR_0->pf_parse_inter_slice = VAR_58;
        VAR_0->pf_parse_inter_mb = VAR_59;
        if(VAR_0->ps_cur_slice->u1_mbaff_frame_flag)
        {
            VAR_0->pf_get_mb_info = VAR_60;
        }
        else
            VAR_0->pf_get_mb_info = VAR_61;
    }

    VAR_0->u1_B = 0;
    VAR_0->pf_mvpred_ref_tfr_nby2mb = VAR_62;
    VAR_11 = VAR_0->pf_parse_inter_slice(VAR_0, VAR_3, VAR_1);
    if(VAR_11 != VAR_40)
        return VAR_11;
/* COMMENT_16 */
    return VAR_40;
}",android/943323f1d9d3dd5c2634deb26cbe72343ca6b3db/ih264d_parse_pslice.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -195,7 +195,14 @@
     if(ps_cur_slice->u1_nal_ref_idc != 0)
     {
         if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
-            ps_dec->u4_bitoffset = ih264d_read_mmco_commands(ps_dec);
+        {
+            i_temp = ih264d_read_mmco_commands(ps_dec);
+            if (i_temp < 0)
+            {
+                return ERROR_DBP_MANAGER_T;
+            }
+            ps_dec->u4_bitoffset = i_temp;
+        }
         else
             ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;
 ","{'deleted_lines': ['            ps_dec->u4_bitoffset = ih264d_read_mmco_commands(ps_dec);'], 'added_lines': ['        {', '            i_temp = ih264d_read_mmco_commands(ps_dec);', '            if (i_temp < 0)', '            {', '                return ERROR_DBP_MANAGER_T;', '            }', '            ps_dec->u4_bitoffset = i_temp;', '        }']}",True,"The H.264 decoder in libstagefright in Android 6.x before 2016-04-01 mishandles Memory Management Control Operation (MMCO) data, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 25818142.",8.4,HIGH,2,test,,5
CVE-2016-0849,['CWE-189'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,android,"Fix integer overflows in recovery procedure.

Bug: 26960931
Change-Id: Ieae45caccfb4728fcf514f0d920976585d8e6caf
(cherry picked from commit 4f2df162c6ab4a71ca86e4b38735b681729c353b)
",28a566f7731b4cb76d2a9ba16d997ac5aeb07dad,https://android.googlesource.com/platform/bootable/recovery/+/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad,minzip/SysUtil.c,sysMapFile,"int sysMapFile(const char* fn, MemMapping* pMap)
{
memset(pMap, 0, sizeof(*pMap));
if (fn && fn[0] == '@') {
FILE* mapf = fopen(fn+1, ""r"");
if (mapf == NULL) {
LOGV(""Unable to open '%s': %s\n"", fn+1, strerror(errno));
return -1;
}
if (sysMapBlockFile(mapf, pMap) != 0) {
LOGW(""Map of '%s' failed\n"", fn);
return -1;
}
fclose(mapf);
} else {
int fd = open(fn, O_RDONLY, 0);
if (fd < 0) {
LOGE(""Unable to open '%s': %s\n"", fn, strerror(errno));
return -1;
}
if (sysMapFD(fd, pMap) != 0) {
LOGE(""Map of '%s' failed\n"", fn);
close(fd);
return -1;
}
close(fd);
}
return 0;
}","int sysMapFile(const char* VAR_0, MemMapping* VAR_1)
{
memset(VAR_1, 0, sizeof(*VAR_1));
if (VAR_0 && VAR_0[0] == '@') {
FILE* VAR_2 = fopen(VAR_0+1, ""r"");
if (VAR_2 == NULL) {
LOGV(""Unable to open '%s': %s\n"", VAR_0+1, strerror(VAR_3));
return -1;
}
if (sysMapBlockFile(VAR_2, VAR_1) != 0) {
LOGW(""Map of '%s' failed\n"", VAR_0);
return -1;
}
fclose(VAR_2);
} else {
int VAR_4 = open(VAR_0, VAR_5, 0);
if (VAR_4 < 0) {
LOGE(""Unable to open '%s': %s\n"", VAR_0, strerror(VAR_3));
return -1;
}
if (sysMapFD(VAR_4, VAR_1) != 0) {
LOGE(""Map of '%s' failed\n"", VAR_0);
close(VAR_4);
return -1;
}
close(VAR_4);
}
return 0;
}",android/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad/SysUtil.c/vul/before/0.json,"int sysMapFile(const char* fn, MemMapping* pMap)
{
    memset(pMap, 0, sizeof(*pMap));

    if (fn && fn[0] == '@') {
        // A map of blocks
        FILE* mapf = fopen(fn+1, ""r"");
        if (mapf == NULL) {
            LOGV(""Unable to open '%s': %s\n"", fn+1, strerror(errno));
            return -1;
        }

        if (sysMapBlockFile(mapf, pMap) != 0) {
            LOGW(""Map of '%s' failed\n"", fn);
            fclose(mapf);
            return -1;
        }

        fclose(mapf);
    } else {
        // This is a regular file.
        int fd = open(fn, O_RDONLY, 0);
        if (fd < 0) {
            LOGE(""Unable to open '%s': %s\n"", fn, strerror(errno));
            return -1;
        }

        if (sysMapFD(fd, pMap) != 0) {
            LOGE(""Map of '%s' failed\n"", fn);
            close(fd);
            return -1;
        }

        close(fd);
    }
    return 0;
}","int sysMapFile(const char* VAR_0, MemMapping* VAR_1)
{
    memset(VAR_1, 0, sizeof(*VAR_1));

    if (VAR_0 && VAR_0[0] == '@') {
        /* COMMENT_0 */
        FILE* VAR_2 = fopen(VAR_0+1, ""r"");
        if (VAR_2 == NULL) {
            LOGV(""Unable to open '%s': %s\n"", VAR_0+1, strerror(VAR_3));
            return -1;
        }

        if (sysMapBlockFile(VAR_2, VAR_1) != 0) {
            LOGW(""Map of '%s' failed\n"", VAR_0);
            fclose(VAR_2);
            return -1;
        }

        fclose(VAR_2);
    } else {
        /* COMMENT_1 */
        int VAR_4 = open(VAR_0, VAR_5, 0);
        if (VAR_4 < 0) {
            LOGE(""Unable to open '%s': %s\n"", VAR_0, strerror(VAR_3));
            return -1;
        }

        if (sysMapFD(VAR_4, VAR_1) != 0) {
            LOGE(""Map of '%s' failed\n"", VAR_0);
            close(VAR_4);
            return -1;
        }

        close(VAR_4);
    }
    return 0;
}",android/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad/SysUtil.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,6 +12,7 @@
 
         if (sysMapBlockFile(mapf, pMap) != 0) {
             LOGW(""Map of '%s' failed\n"", fn);
+            fclose(mapf);
             return -1;
         }
 ","{'deleted_lines': [], 'added_lines': ['            fclose(mapf);']}",True,"Multiple integer overflows in minzip/SysUtil.c in the Recovery Procedure in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 allow attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26960931.",8.4,HIGH,2,test,,5
CVE-2016-0849,['CWE-189'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,android,"Fix integer overflows in recovery procedure.

Bug: 26960931
Change-Id: Ieae45caccfb4728fcf514f0d920976585d8e6caf
(cherry picked from commit 4f2df162c6ab4a71ca86e4b38735b681729c353b)
",28a566f7731b4cb76d2a9ba16d997ac5aeb07dad,https://android.googlesource.com/platform/bootable/recovery/+/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad,minzip/SysUtil.c,sysMapFD,"static int sysMapFD(int fd, MemMapping* pMap)
{
off_t start;
size_t length;
void* memPtr;
assert(pMap != NULL);
if (getFileStartAndLength(fd, &start, &length) < 0)
return -1;
memPtr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, start);
if (memPtr == MAP_FAILED) {
LOGW(""mmap(%d, R, PRIVATE, %d, %d) failed: %s\n"", (int) length,
fd, (int) start, strerror(errno));
return -1;
}
pMap->addr = memPtr;
pMap->length = length;
pMap->range_count = 1;
pMap->ranges = malloc(sizeof(MappedRange));
pMap->ranges[0].addr = memPtr;
pMap->ranges[0].length = length;
return 0;
}","static int sysMapFD(int VAR_0, MemMapping* VAR_1)
{
off_t VAR_2;
size_t VAR_3;
void* VAR_4;
assert(VAR_1 != NULL);
if (getFileStartAndLength(VAR_0, &VAR_2, &VAR_3) < 0)
return -1;
VAR_4 = mmap(NULL, VAR_3, VAR_5, VAR_6, VAR_0, VAR_2);
if (VAR_4 == VAR_7) {
LOGW(""mmap(%d, R, PRIVATE, %d, %d) failed: %s\n"", (int) VAR_3,
VAR_0, (int) VAR_2, strerror(VAR_8));
return -1;
}
VAR_1->addr = VAR_4;
VAR_1->length = VAR_3;
VAR_1->range_count = 1;
VAR_1->ranges = malloc(sizeof(VAR_9));
VAR_1->ranges[0].addr = VAR_4;
VAR_1->ranges[0].length = VAR_3;
return 0;
}",android/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad/SysUtil.c/vul/before/1.json,"static int sysMapFD(int fd, MemMapping* pMap)
{
    off_t start;
    size_t length;
    void* memPtr;

    assert(pMap != NULL);

    if (getFileStartAndLength(fd, &start, &length) < 0)
        return -1;

    memPtr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, start);
    if (memPtr == MAP_FAILED) {
        LOGW(""mmap(%d, R, PRIVATE, %d, %d) failed: %s\n"", (int) length,
            fd, (int) start, strerror(errno));
        return -1;
    }

    pMap->addr = memPtr;
    pMap->length = length;
    pMap->range_count = 1;
    pMap->ranges = malloc(sizeof(MappedRange));
    if (pMap->ranges == NULL) {
        LOGE(""malloc failed: %s\n"", strerror(errno));
        munmap(memPtr, length);
        return -1;
    }
    pMap->ranges[0].addr = memPtr;
    pMap->ranges[0].length = length;

    return 0;
}","static int sysMapFD(int VAR_0, MemMapping* VAR_1)
{
    off_t VAR_2;
    size_t VAR_3;
    void* VAR_4;

    assert(VAR_1 != NULL);

    if (getFileStartAndLength(VAR_0, &VAR_2, &VAR_3) < 0)
        return -1;

    VAR_4 = mmap(NULL, VAR_3, VAR_5, VAR_6, VAR_0, VAR_2);
    if (VAR_4 == VAR_7) {
        LOGW(""mmap(%d, R, PRIVATE, %d, %d) failed: %s\n"", (int) VAR_3,
            VAR_0, (int) VAR_2, strerror(VAR_8));
        return -1;
    }

    VAR_1->addr = VAR_4;
    VAR_1->length = VAR_3;
    VAR_1->range_count = 1;
    VAR_1->ranges = malloc(sizeof(VAR_9));
    if (VAR_1->ranges == NULL) {
        LOGE(""malloc failed: %s\n"", strerror(VAR_8));
        munmap(VAR_4, VAR_3);
        return -1;
    }
    VAR_1->ranges[0].addr = VAR_4;
    VAR_1->ranges[0].length = VAR_3;

    return 0;
}",android/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad/SysUtil.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -20,6 +20,11 @@
     pMap->length = length;
     pMap->range_count = 1;
     pMap->ranges = malloc(sizeof(MappedRange));
+    if (pMap->ranges == NULL) {
+        LOGE(""malloc failed: %s\n"", strerror(errno));
+        munmap(memPtr, length);
+        return -1;
+    }
     pMap->ranges[0].addr = memPtr;
     pMap->ranges[0].length = length;
 ","{'deleted_lines': [], 'added_lines': ['    if (pMap->ranges == NULL) {', '        LOGE(""malloc failed: %s\\n"", strerror(errno));', '        munmap(memPtr, length);', '        return -1;', '    }']}",True,"Multiple integer overflows in minzip/SysUtil.c in the Recovery Procedure in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 allow attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26960931.",8.4,HIGH,2,test,,5
CVE-2016-0849,['CWE-189'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,android,"Fix integer overflows in recovery procedure.

Bug: 26960931
Change-Id: Ieae45caccfb4728fcf514f0d920976585d8e6caf
(cherry picked from commit 4f2df162c6ab4a71ca86e4b38735b681729c353b)
",28a566f7731b4cb76d2a9ba16d997ac5aeb07dad,https://android.googlesource.com/platform/bootable/recovery/+/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad,minzip/SysUtil.c,sysMapBlockFile,"static int sysMapBlockFile(FILE* mapf, MemMapping* pMap)
{
char block_dev[PATH_MAX+1];
size_t size;
unsigned int blksize;
unsigned int blocks;
unsigned int range_count;
unsigned int i;
if (fgets(block_dev, sizeof(block_dev), mapf) == NULL) {
LOGW(""failed to read block device from header\n"");
return -1;
}
for (i = 0; i < sizeof(block_dev); ++i) {
if (block_dev[i] == '\n') {
block_dev[i] = 0;
break;
}
}
if (fscanf(mapf, ""%zu %u\n%u\n"", &size, &blksize, &range_count) != 3) {
LOGW(""failed to parse block map header\n"");
return -1;
}
blocks = ((size-1) / blksize) + 1;
pMap->range_count = range_count;
pMap->ranges = malloc(range_count * sizeof(MappedRange));
memset(pMap->ranges, 0, range_count * sizeof(MappedRange));
unsigned char* reserve;
reserve = mmap64(NULL, blocks * blksize, PROT_NONE, MAP_PRIVATE | MAP_ANON, -1, 0);
if (reserve == MAP_FAILED) {
LOGW(""failed to reserve address space: %s\n"", strerror(errno));
return -1;
}
pMap->ranges[range_count-1].addr = reserve;
pMap->ranges[range_count-1].length = blocks * blksize;
int fd = open(block_dev, O_RDONLY);
if (fd < 0) {
LOGW(""failed to open block device %s: %s\n"", block_dev, strerror(errno));
return -1;
}
unsigned char* next = reserve;
for (i = 0; i < range_count; ++i) {
int start, end;
if (fscanf(mapf, ""%d %d\n"", &start, &end) != 2) {
LOGW(""failed to parse range %d in block map\n"", i);
return -1;
}
void* addr = mmap64(next, (end-start)*blksize, PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, ((off64_t)start)*blksize);
if (addr == MAP_FAILED) {
LOGW(""failed to map block %d: %s\n"", i, strerror(errno));
return -1;
}
pMap->ranges[i].addr = addr;
pMap->ranges[i].length = (end-start)*blksize;
next += pMap->ranges[i].length;
}
pMap->addr = reserve;
pMap->length = size;
LOGI(""mmapped %d ranges\n"", range_count);
return 0;
}","static int sysMapBlockFile(FILE* VAR_0, MemMapping* VAR_1)
{
char VAR_2[VAR_3+1];
size_t VAR_4;
unsigned int VAR_5;
unsigned int VAR_6;
unsigned int VAR_7;
unsigned int VAR_8;
if (fgets(VAR_2, sizeof(VAR_2), VAR_0) == NULL) {
LOGW(""failed to read block device from header\n"");
return -1;
}
for (VAR_8 = 0; VAR_8 < sizeof(VAR_2); ++VAR_8) {
if (VAR_2[VAR_8] == '\n') {
VAR_2[VAR_8] = 0;
break;
}
}
if (fscanf(VAR_0, ""%zu %u\n%u\n"", &VAR_4, &VAR_5, &VAR_7) != 3) {
LOGW(""failed to parse block map header\n"");
return -1;
}
VAR_6 = ((VAR_4-1) / VAR_5) + 1;
VAR_1->range_count = VAR_7;
VAR_1->ranges = malloc(VAR_7 * sizeof(VAR_9));
memset(VAR_1->ranges, 0, VAR_7 * sizeof(VAR_9));
unsigned char* VAR_10;
VAR_10 = mmap64(NULL, VAR_6 * VAR_5, VAR_11, VAR_12 | VAR_13, -1, 0);
if (VAR_10 == VAR_14) {
LOGW(""failed to reserve address space: %s\n"", strerror(VAR_15));
return -1;
}
VAR_1->ranges[VAR_7-1].addr = VAR_10;
VAR_1->ranges[VAR_7-1].length = VAR_6 * VAR_5;
int VAR_16 = open(VAR_2, VAR_17);
if (VAR_16 < 0) {
LOGW(""failed to open block device %s: %s\n"", VAR_2, strerror(VAR_15));
return -1;
}
unsigned char* VAR_18 = VAR_10;
for (VAR_8 = 0; VAR_8 < VAR_7; ++VAR_8) {
int VAR_19, VAR_20;
if (fscanf(VAR_0, ""%d %d\n"", &VAR_19, &VAR_20) != 2) {
LOGW(""failed to parse range %d in block map\n"", VAR_8);
return -1;
}
void* VAR_21 = mmap64(VAR_18, (VAR_20-VAR_19)*VAR_5, VAR_22, VAR_12 | VAR_23, VAR_16, ((off64_t)VAR_19)*VAR_5);
if (VAR_21 == VAR_14) {
LOGW(""failed to map block %d: %s\n"", VAR_8, strerror(VAR_15));
return -1;
}
VAR_1->ranges[VAR_8].addr = VAR_21;
VAR_1->ranges[VAR_8].length = (VAR_20-VAR_19)*VAR_5;
VAR_18 += VAR_1->ranges[VAR_8].length;
}
VAR_1->addr = VAR_10;
VAR_1->length = VAR_4;
LOGI(""mmapped %d ranges\n"", VAR_7);
return 0;
}",android/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad/SysUtil.c/vul/before/2.json,"static int sysMapBlockFile(FILE* mapf, MemMapping* pMap)
{
    char block_dev[PATH_MAX+1];
    size_t size;
    unsigned int blksize;
    size_t blocks;
    unsigned int range_count;
    unsigned int i;

    if (fgets(block_dev, sizeof(block_dev), mapf) == NULL) {
        LOGW(""failed to read block device from header\n"");
        return -1;
    }
    for (i = 0; i < sizeof(block_dev); ++i) {
        if (block_dev[i] == '\n') {
            block_dev[i] = 0;
            break;
        }
    }

    if (fscanf(mapf, ""%zu %u\n%u\n"", &size, &blksize, &range_count) != 3) {
        LOGW(""failed to parse block map header\n"");
        return -1;
    }
    if (blksize != 0) {
        blocks = ((size-1) / blksize) + 1;
    }
    if (size == 0 || blksize == 0 || blocks > SIZE_MAX / blksize || range_count == 0) {
        LOGE(""invalid data in block map file: size %zu, blksize %u, range_count %u\n"",
             size, blksize, range_count);
        return -1;
    }

    pMap->range_count = range_count;
    pMap->ranges = calloc(range_count, sizeof(MappedRange));
    if (pMap->ranges == NULL) {
        LOGE(""calloc(%u, %zu) failed: %s\n"", range_count, sizeof(MappedRange), strerror(errno));
        return -1;
    }

    // Reserve enough contiguous address space for the whole file.
    unsigned char* reserve;
    reserve = mmap64(NULL, blocks * blksize, PROT_NONE, MAP_PRIVATE | MAP_ANON, -1, 0);
    if (reserve == MAP_FAILED) {
        LOGW(""failed to reserve address space: %s\n"", strerror(errno));
        free(pMap->ranges);
        return -1;
    }

    int fd = open(block_dev, O_RDONLY);
    if (fd < 0) {
        LOGW(""failed to open block device %s: %s\n"", block_dev, strerror(errno));
        munmap(reserve, blocks * blksize);
        free(pMap->ranges);
        return -1;
    }

    unsigned char* next = reserve;
    size_t remaining_size = blocks * blksize;
    bool success = true;
    for (i = 0; i < range_count; ++i) {
        size_t start, end;
        if (fscanf(mapf, ""%zu %zu\n"", &start, &end) != 2) {
            LOGW(""failed to parse range %d in block map\n"", i);
            success = false;
            break;
        }
        size_t length = (end - start) * blksize;
        if (end <= start || (end - start) > SIZE_MAX / blksize || length > remaining_size) {
          LOGE(""unexpected range in block map: %zu %zu\n"", start, end);
          success = false;
          break;
        }

        void* addr = mmap64(next, length, PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, ((off64_t)start)*blksize);
        if (addr == MAP_FAILED) {
            LOGW(""failed to map block %d: %s\n"", i, strerror(errno));
            success = false;
            break;
        }
        pMap->ranges[i].addr = addr;
        pMap->ranges[i].length = length;

        next += length;
        remaining_size -= length;
    }
    if (success && remaining_size != 0) {
      LOGE(""ranges in block map are invalid: remaining_size = %zu\n"", remaining_size);
      success = false;
    }
    if (!success) {
      close(fd);
      munmap(reserve, blocks * blksize);
      free(pMap->ranges);
      return -1;
    }

    close(fd);
    pMap->addr = reserve;
    pMap->length = size;

    LOGI(""mmapped %d ranges\n"", range_count);

    return 0;
}","static int sysMapBlockFile(FILE* VAR_0, MemMapping* VAR_1)
{
    char VAR_2[VAR_3+1];
    size_t VAR_4;
    unsigned int VAR_5;
    size_t VAR_6;
    unsigned int VAR_7;
    unsigned int VAR_8;

    if (fgets(VAR_2, sizeof(VAR_2), VAR_0) == NULL) {
        LOGW(""failed to read block device from header\n"");
        return -1;
    }
    for (VAR_8 = 0; VAR_8 < sizeof(VAR_2); ++VAR_8) {
        if (VAR_2[VAR_8] == '\n') {
            VAR_2[VAR_8] = 0;
            break;
        }
    }

    if (fscanf(VAR_0, ""%zu %u\n%u\n"", &VAR_4, &VAR_5, &VAR_7) != 3) {
        LOGW(""failed to parse block map header\n"");
        return -1;
    }
    if (VAR_5 != 0) {
        VAR_6 = ((VAR_4-1) / VAR_5) + 1;
    }
    if (VAR_4 == 0 || VAR_5 == 0 || VAR_6 > VAR_9 / VAR_5 || VAR_7 == 0) {
        LOGE(""invalid data in block map file: size %zu, blksize %u, range_count %u\n"",
             VAR_4, VAR_5, VAR_7);
        return -1;
    }

    VAR_1->range_count = VAR_7;
    VAR_1->ranges = calloc(VAR_7, sizeof(VAR_10));
    if (VAR_1->ranges == NULL) {
        LOGE(""calloc(%u, %zu) failed: %s\n"", VAR_7, sizeof(VAR_10), strerror(VAR_11));
        return -1;
    }

    /* COMMENT_0 */
    unsigned char* VAR_12;
    VAR_12 = mmap64(NULL, VAR_6 * VAR_5, VAR_13, VAR_14 | VAR_15, -1, 0);
    if (VAR_12 == VAR_16) {
        LOGW(""failed to reserve address space: %s\n"", strerror(VAR_11));
        free(VAR_1->ranges);
        return -1;
    }

    int VAR_17 = open(VAR_2, VAR_18);
    if (VAR_17 < 0) {
        LOGW(""failed to open block device %s: %s\n"", VAR_2, strerror(VAR_11));
        munmap(VAR_12, VAR_6 * VAR_5);
        free(VAR_1->ranges);
        return -1;
    }

    unsigned char* VAR_19 = VAR_12;
    size_t VAR_20 = VAR_6 * VAR_5;
    bool VAR_21 = true;
    for (VAR_8 = 0; VAR_8 < VAR_7; ++VAR_8) {
        size_t VAR_22, VAR_23;
        if (fscanf(VAR_0, ""%zu %zu\n"", &VAR_22, &VAR_23) != 2) {
            LOGW(""failed to parse range %d in block map\n"", VAR_8);
            VAR_21 = false;
            break;
        }
        size_t VAR_24 = (VAR_23 - VAR_22) * VAR_5;
        if (VAR_23 <= VAR_22 || (VAR_23 - VAR_22) > VAR_9 / VAR_5 || VAR_24 > VAR_20) {
          LOGE(""unexpected range in block map: %zu %zu\n"", VAR_22, VAR_23);
          VAR_21 = false;
          break;
        }

        void* VAR_25 = mmap64(VAR_19, VAR_24, VAR_26, VAR_14 | VAR_27, VAR_17, ((off64_t)VAR_22)*VAR_5);
        if (VAR_25 == VAR_16) {
            LOGW(""failed to map block %d: %s\n"", VAR_8, strerror(VAR_11));
            VAR_21 = false;
            break;
        }
        VAR_1->ranges[VAR_8].addr = VAR_25;
        VAR_1->ranges[VAR_8].length = VAR_24;

        VAR_19 += VAR_24;
        VAR_20 -= VAR_24;
    }
    if (VAR_21 && VAR_20 != 0) {
      LOGE(""ranges in block map are invalid: remaining_size = %zu\n"", VAR_20);
      VAR_21 = false;
    }
    if (!VAR_21) {
      close(VAR_17);
      munmap(VAR_12, VAR_6 * VAR_5);
      free(VAR_1->ranges);
      return -1;
    }

    close(VAR_17);
    VAR_1->addr = VAR_12;
    VAR_1->length = VAR_4;

    LOGI(""mmapped %d ranges\n"", VAR_7);

    return 0;
}",android/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad/SysUtil.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
     char block_dev[PATH_MAX+1];
     size_t size;
     unsigned int blksize;
-    unsigned int blocks;
+    size_t blocks;
     unsigned int range_count;
     unsigned int i;
 
@@ -22,49 +22,80 @@
         LOGW(""failed to parse block map header\n"");
         return -1;
     }
-
-    blocks = ((size-1) / blksize) + 1;
+    if (blksize != 0) {
+        blocks = ((size-1) / blksize) + 1;
+    }
+    if (size == 0 || blksize == 0 || blocks > SIZE_MAX / blksize || range_count == 0) {
+        LOGE(""invalid data in block map file: size %zu, blksize %u, range_count %u\n"",
+             size, blksize, range_count);
+        return -1;
+    }
 
     pMap->range_count = range_count;
-    pMap->ranges = malloc(range_count * sizeof(MappedRange));
-    memset(pMap->ranges, 0, range_count * sizeof(MappedRange));
+    pMap->ranges = calloc(range_count, sizeof(MappedRange));
+    if (pMap->ranges == NULL) {
+        LOGE(""calloc(%u, %zu) failed: %s\n"", range_count, sizeof(MappedRange), strerror(errno));
+        return -1;
+    }
 
     // Reserve enough contiguous address space for the whole file.
     unsigned char* reserve;
     reserve = mmap64(NULL, blocks * blksize, PROT_NONE, MAP_PRIVATE | MAP_ANON, -1, 0);
     if (reserve == MAP_FAILED) {
         LOGW(""failed to reserve address space: %s\n"", strerror(errno));
+        free(pMap->ranges);
         return -1;
     }
-
-    pMap->ranges[range_count-1].addr = reserve;
-    pMap->ranges[range_count-1].length = blocks * blksize;
 
     int fd = open(block_dev, O_RDONLY);
     if (fd < 0) {
         LOGW(""failed to open block device %s: %s\n"", block_dev, strerror(errno));
+        munmap(reserve, blocks * blksize);
+        free(pMap->ranges);
         return -1;
     }
 
     unsigned char* next = reserve;
+    size_t remaining_size = blocks * blksize;
+    bool success = true;
     for (i = 0; i < range_count; ++i) {
-        int start, end;
-        if (fscanf(mapf, ""%d %d\n"", &start, &end) != 2) {
+        size_t start, end;
+        if (fscanf(mapf, ""%zu %zu\n"", &start, &end) != 2) {
             LOGW(""failed to parse range %d in block map\n"", i);
-            return -1;
+            success = false;
+            break;
+        }
+        size_t length = (end - start) * blksize;
+        if (end <= start || (end - start) > SIZE_MAX / blksize || length > remaining_size) {
+          LOGE(""unexpected range in block map: %zu %zu\n"", start, end);
+          success = false;
+          break;
         }
 
-        void* addr = mmap64(next, (end-start)*blksize, PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, ((off64_t)start)*blksize);
+        void* addr = mmap64(next, length, PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, ((off64_t)start)*blksize);
         if (addr == MAP_FAILED) {
             LOGW(""failed to map block %d: %s\n"", i, strerror(errno));
-            return -1;
+            success = false;
+            break;
         }
         pMap->ranges[i].addr = addr;
-        pMap->ranges[i].length = (end-start)*blksize;
+        pMap->ranges[i].length = length;
 
-        next += pMap->ranges[i].length;
+        next += length;
+        remaining_size -= length;
+    }
+    if (success && remaining_size != 0) {
+      LOGE(""ranges in block map are invalid: remaining_size = %zu\n"", remaining_size);
+      success = false;
+    }
+    if (!success) {
+      close(fd);
+      munmap(reserve, blocks * blksize);
+      free(pMap->ranges);
+      return -1;
     }
 
+    close(fd);
     pMap->addr = reserve;
     pMap->length = size;
 ","{'deleted_lines': ['    unsigned int blocks;', '', '    blocks = ((size-1) / blksize) + 1;', '    pMap->ranges = malloc(range_count * sizeof(MappedRange));', '    memset(pMap->ranges, 0, range_count * sizeof(MappedRange));', '', '    pMap->ranges[range_count-1].addr = reserve;', '    pMap->ranges[range_count-1].length = blocks * blksize;', '        int start, end;', '        if (fscanf(mapf, ""%d %d\\n"", &start, &end) != 2) {', '            return -1;', '        void* addr = mmap64(next, (end-start)*blksize, PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, ((off64_t)start)*blksize);', '            return -1;', '        pMap->ranges[i].length = (end-start)*blksize;', '        next += pMap->ranges[i].length;'], 'added_lines': ['    size_t blocks;', '    if (blksize != 0) {', '        blocks = ((size-1) / blksize) + 1;', '    }', '    if (size == 0 || blksize == 0 || blocks > SIZE_MAX / blksize || range_count == 0) {', '        LOGE(""invalid data in block map file: size %zu, blksize %u, range_count %u\\n"",', '             size, blksize, range_count);', '        return -1;', '    }', '    pMap->ranges = calloc(range_count, sizeof(MappedRange));', '    if (pMap->ranges == NULL) {', '        LOGE(""calloc(%u, %zu) failed: %s\\n"", range_count, sizeof(MappedRange), strerror(errno));', '        return -1;', '    }', '        free(pMap->ranges);', '        munmap(reserve, blocks * blksize);', '        free(pMap->ranges);', '    size_t remaining_size = blocks * blksize;', '    bool success = true;', '        size_t start, end;', '        if (fscanf(mapf, ""%zu %zu\\n"", &start, &end) != 2) {', '            success = false;', '            break;', '        }', '        size_t length = (end - start) * blksize;', '        if (end <= start || (end - start) > SIZE_MAX / blksize || length > remaining_size) {', '          LOGE(""unexpected range in block map: %zu %zu\\n"", start, end);', '          success = false;', '          break;', '        void* addr = mmap64(next, length, PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, ((off64_t)start)*blksize);', '            success = false;', '            break;', '        pMap->ranges[i].length = length;', '        next += length;', '        remaining_size -= length;', '    }', '    if (success && remaining_size != 0) {', '      LOGE(""ranges in block map are invalid: remaining_size = %zu\\n"", remaining_size);', '      success = false;', '    }', '    if (!success) {', '      close(fd);', '      munmap(reserve, blocks * blksize);', '      free(pMap->ranges);', '      return -1;', '    close(fd);']}",True,"Multiple integer overflows in minzip/SysUtil.c in the Recovery Procedure in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 allow attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26960931.",8.4,HIGH,2,test,,5
CVE-2016-1652,"['CWE-284', 'CWE-79', 'CWE-254']",AV:N/AC:M/Au:N/C:N/I:P/A:N,0,chromium,"[Extensions] Harden against bindings interception

There's more we can do but this is a start.

BUG=590275
BUG=590118

Review URL: https://codereview.chromium.org/1748943002

Cr-Commit-Position: refs/heads/master@{#378621}
",75b803b1c81ed9fa5513cbff550232b4fb915e7b,https://chromium.googlesource.com/chromium/src/+/75b803b1c81ed9fa5513cbff550232b4fb915e7b,extensions/renderer/module_system.cc,ModuleSystem::RequireForJsInner,"v8::Local<v8::Value> ModuleSystem::RequireForJsInner(
v8::Local<v8::String> module_name) {
v8::EscapableHandleScope handle_scope(GetIsolate());
v8::Local<v8::Context> v8_context = context()->v8_context();
v8::Context::Scope context_scope(v8_context);
v8::Local<v8::Object> global(context()->v8_context()->Global());
v8::Local<v8::Value> modules_value;
if (!GetPrivate(global, kModulesField, &modules_value) ||
modules_value->IsUndefined()) {
Warn(GetIsolate(), ""Extension view no longer exists"");
return v8::Undefined(GetIsolate());
}
v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));
v8::Local<v8::Value> exports;
if (!GetProperty(v8_context, modules, module_name, &exports) ||
!exports->IsUndefined())
return handle_scope.Escape(exports);
exports = LoadModule(*v8::String::Utf8Value(module_name));
SetProperty(v8_context, modules, module_name, exports);
return handle_scope.Escape(exports);
}","v8::Local<v8::Value> ModuleSystem::RequireForJsInner(
v8::Local<v8::String> VAR_0) {
v8::EscapableHandleScope handle_scope(GetIsolate());
v8::Local<v8::Context> VAR_1 = context()->v8_context();
v8::Context::Scope context_scope(v8_context);
v8::Local<v8::Object> global(context()->v8_context()->Global());
v8::Local<v8::Value> VAR_2;
if (!GetPrivate(VAR_3, VAR_4, &VAR_2) ||
VAR_2->IsUndefined()) {
Warn(GetIsolate(), ""Extension view no longer exists"");
return v8::Undefined(GetIsolate());
}
v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));
v8::Local<v8::Value> VAR_5;
if (!GetProperty(v8_context, VAR_6, VAR_0, &VAR_5) ||
!VAR_5->IsUndefined())
return VAR_7.Escape(VAR_5);
VAR_5 = LoadModule(*v8::String::Utf8Value(VAR_0));
SetProperty(v8_context, VAR_6, VAR_0, VAR_5);
return VAR_7.Escape(VAR_5);
}",chromium/75b803b1c81ed9fa5513cbff550232b4fb915e7b/module_system.cc/vul/before/0.json,"v8::Local<v8::Value> ModuleSystem::RequireForJsInner(
    v8::Local<v8::String> module_name) {
  v8::EscapableHandleScope handle_scope(GetIsolate());
  v8::Local<v8::Context> v8_context = context()->v8_context();
  v8::Context::Scope context_scope(v8_context);

  v8::Local<v8::Object> global(context()->v8_context()->Global());

  // The module system might have been deleted. This can happen if a different
  // context keeps a reference to us, but our frame is destroyed (e.g.
  // background page keeps reference to chrome object in a closed popup).
  v8::Local<v8::Value> modules_value;
  if (!GetPrivate(global, kModulesField, &modules_value) ||
      modules_value->IsUndefined()) {
    Warn(GetIsolate(), ""Extension view no longer exists"");
    return v8::Undefined(GetIsolate());
  }

  v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));
  v8::Local<v8::Value> exports;
  if (!GetPrivateProperty(v8_context, modules, module_name, &exports) ||
      !exports->IsUndefined())
    return handle_scope.Escape(exports);

  exports = LoadModule(*v8::String::Utf8Value(module_name));
  SetPrivateProperty(v8_context, modules, module_name, exports);
  return handle_scope.Escape(exports);
}","v8::Local<v8::Value> ModuleSystem::RequireForJsInner(
    v8::Local<v8::String> VAR_0) {
  v8::EscapableHandleScope handle_scope(GetIsolate());
  v8::Local<v8::Context> VAR_1 = context()->v8_context();
  v8::Context::Scope context_scope(v8_context);

  v8::Local<v8::Object> global(context()->v8_context()->Global());

  /* COMMENT_0 */
  /* COMMENT_1 */
  /* COMMENT_2 */
  v8::Local<v8::Value> VAR_2;
  if (!GetPrivate(VAR_3, VAR_4, &VAR_2) ||
      VAR_2->IsUndefined()) {
    Warn(GetIsolate(), ""Extension view no longer exists"");
    return v8::Undefined(GetIsolate());
  }

  v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));
  v8::Local<v8::Value> VAR_5;
  if (!GetPrivateProperty(v8_context, VAR_6, VAR_0, &VAR_5) ||
      !VAR_5->IsUndefined())
    return VAR_7.Escape(VAR_5);

  VAR_5 = LoadModule(*v8::String::Utf8Value(VAR_0));
  SetPrivateProperty(v8_context, VAR_6, VAR_0, VAR_5);
  return VAR_7.Escape(VAR_5);
}",chromium/75b803b1c81ed9fa5513cbff550232b4fb915e7b/module_system.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -18,11 +18,11 @@
 
   v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));
   v8::Local<v8::Value> exports;
-  if (!GetProperty(v8_context, modules, module_name, &exports) ||
+  if (!GetPrivateProperty(v8_context, modules, module_name, &exports) ||
       !exports->IsUndefined())
     return handle_scope.Escape(exports);
 
   exports = LoadModule(*v8::String::Utf8Value(module_name));
-  SetProperty(v8_context, modules, module_name, exports);
+  SetPrivateProperty(v8_context, modules, module_name, exports);
   return handle_scope.Escape(exports);
 }","{'deleted_lines': ['  if (!GetProperty(v8_context, modules, module_name, &exports) ||', '  SetProperty(v8_context, modules, module_name, exports);'], 'added_lines': ['  if (!GetPrivateProperty(v8_context, modules, module_name, &exports) ||', '  SetPrivateProperty(v8_context, modules, module_name, exports);']}",True,"Cross-site scripting (XSS) vulnerability in the ModuleSystem::RequireForJsInner function in extensions/renderer/module_system.cc in the Extensions subsystem in Google Chrome before 50.0.2661.75 allows remote attackers to inject arbitrary web script or HTML via a crafted web site, aka ""Universal XSS (UXSS).""",6.1,MEDIUM,1,test,,5
CVE-2016-1653,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,chromium,"[turbofan] Bailout if LoadBuffer typing assumption doesn't hold.

The LoadBuffer operator that is used for asm.js heap access claims to
return only the appropriate typed array type, but out of bounds access
could make it return undefined. So far we tried to ""repair"" the graph
later if we see that our assumption was wrong, and for various reasons
that worked for some time. But now that wrong type information that is
propagated earlier is picked up appropriately and thus we generate wrong
code, i.e. we in the repro case we feed NaN into ChangeFloat64Uint32 and
thus get 2147483648 instead of 0 (with proper JS truncation).

This was always considered a temporary hack until we have a proper
asm.js pipeline, but since we still run asm.js through the generic
JavaScript pipeline, we have to address this now. Quickfix is to just
bailout from the pipeline when we see that the LoadBuffer type was
wrong, i.e. the result of LoadBuffer is not properly truncated and thus
undefined or NaN would be observable.

R=mstarzinger@chromium.org, jarin@chromium.org
BUG=chromium:589792
LOG=y

Review URL: https://codereview.chromium.org/1740123002

Cr-Commit-Position: refs/heads/master@{#34322}
",58ab990aa8c3aeee38e888c1c33404f4b5a14759,https://chromium.googlesource.com/v8/v8/+/58ab990aa8c3aeee38e888c1c33404f4b5a14759,src/compiler/simplified-lowering.cc,VisitNode,"void VisitNode(Node* node, Truncation truncation,
SimplifiedLowering* lowering) {
switch (node->opcode()) {
case IrOpcode::kStart:
case IrOpcode::kDead:
return VisitLeaf(node, NodeOutputInfo::None());
case IrOpcode::kParameter: {
Type* type = NodeProperties::GetType(node);
ProcessInput(node, 0, UseInfo::None());
SetOutput(node, NodeOutputInfo(MachineRepresentation::kTagged, type));
return;
}
case IrOpcode::kInt32Constant:
return VisitLeaf(node, NodeOutputInfo::Int32());
case IrOpcode::kInt64Constant:
return VisitLeaf(node, NodeOutputInfo::Int64());
case IrOpcode::kFloat32Constant:
return VisitLeaf(node, NodeOutputInfo::Float32());
case IrOpcode::kFloat64Constant:
return VisitLeaf(node, NodeOutputInfo::Float64());
case IrOpcode::kExternalConstant:
return VisitLeaf(node, NodeOutputInfo::Pointer());
case IrOpcode::kNumberConstant:
return VisitLeaf(node, NodeOutputInfo::NumberTagged());
case IrOpcode::kHeapConstant:
return VisitLeaf(node, NodeOutputInfo::AnyTagged());
case IrOpcode::kDeoptimizeIf:
case IrOpcode::kDeoptimizeUnless:
ProcessInput(node, 0, UseInfo::Bool());
ProcessInput(node, 1, UseInfo::AnyTagged());
ProcessRemainingInputs(node, 2);
break;
case IrOpcode::kBranch:
ProcessInput(node, 0, UseInfo::Bool());
EnqueueInput(node, NodeProperties::FirstControlIndex(node));
break;
case IrOpcode::kSwitch:
ProcessInput(node, 0, UseInfo::TruncatingWord32());
EnqueueInput(node, NodeProperties::FirstControlIndex(node));
break;
case IrOpcode::kSelect:
return VisitSelect(node, truncation, lowering);
case IrOpcode::kPhi:
return VisitPhi(node, truncation, lowering);
case IrOpcode::kCall:
return VisitCall(node, lowering);
#define DEFINE_JS_CASE(x) case IrOpcode::k##x:
JS_OP_LIST(DEFINE_JS_CASE)
#undef DEFINE_JS_CASE
VisitInputs(node);
return SetOutput(node, NodeOutputInfo::AnyTagged());
case IrOpcode::kBooleanNot: {
if (lower()) {
NodeInfo* input_info = GetInfo(node->InputAt(0));
if (input_info->representation() == MachineRepresentation::kBit) {
node->AppendInput(jsgraph_->zone(), jsgraph_->Int32Constant(0));
NodeProperties::ChangeOp(node, lowering->machine()->Word32Equal());
} else {
node->AppendInput(jsgraph_->zone(), jsgraph_->FalseConstant());
NodeProperties::ChangeOp(node, lowering->machine()->WordEqual());
}
} else {
ProcessInput(node, 0, UseInfo::AnyTruncatingToBool());
SetOutput(node, NodeOutputInfo::Bool());
}
break;
}
case IrOpcode::kBooleanToNumber: {
if (lower()) {
NodeInfo* input_info = GetInfo(node->InputAt(0));
if (input_info->representation() == MachineRepresentation::kBit) {
DeferReplacement(node, node->InputAt(0));
} else {
node->AppendInput(jsgraph_->zone(), jsgraph_->TrueConstant());
NodeProperties::ChangeOp(node, lowering->machine()->WordEqual());
}
} else {
ProcessInput(node, 0, UseInfo::AnyTruncatingToBool());
SetOutput(node, NodeOutputInfo::Int32());
}
break;
}
case IrOpcode::kNumberEqual:
case IrOpcode::kNumberLessThan:
case IrOpcode::kNumberLessThanOrEqual: {
if (BothInputsAreSigned32(node)) {
VisitInt32Cmp(node);
if (lower()) NodeProperties::ChangeOp(node, Int32Op(node));
} else if (BothInputsAreUnsigned32(node)) {
VisitUint32Cmp(node);
if (lower()) NodeProperties::ChangeOp(node, Uint32Op(node));
} else {
VisitFloat64Cmp(node);
if (lower()) NodeProperties::ChangeOp(node, Float64Op(node));
}
break;
}
case IrOpcode::kNumberAdd:
case IrOpcode::kNumberSubtract: {
if (BothInputsAre(node, Type::Signed32()) &&
NodeProperties::GetType(node)->Is(Type::Signed32())) {
VisitInt32Binop(node);
if (lower()) NodeProperties::ChangeOp(node, Int32Op(node));
} else if (BothInputsAre(node, type_cache_.kAdditiveSafeInteger) &&
truncation.TruncatesToWord32()) {
VisitWord32TruncatingBinop(node);
if (lower()) NodeProperties::ChangeOp(node, Int32Op(node));
} else {
VisitFloat64Binop(node);
if (lower()) NodeProperties::ChangeOp(node, Float64Op(node));
}
break;
}
case IrOpcode::kNumberMultiply: {
if (BothInputsAreSigned32(node)) {
if (NodeProperties::GetType(node)->Is(Type::Signed32())) {
VisitInt32Binop(node);
if (lower()) NodeProperties::ChangeOp(node, Int32Op(node));
break;
}
if (truncation.TruncatesToWord32() &&
NodeProperties::GetType(node)->Is(type_cache_.kSafeInteger)) {
VisitWord32TruncatingBinop(node);
if (lower()) NodeProperties::ChangeOp(node, Int32Op(node));
break;
}
}
VisitFloat64Binop(node);
if (lower()) NodeProperties::ChangeOp(node, Float64Op(node));
break;
}
case IrOpcode::kNumberDivide: {
if (BothInputsAreSigned32(node)) {
if (NodeProperties::GetType(node)->Is(Type::Signed32())) {
VisitInt32Binop(node);
if (lower()) DeferReplacement(node, lowering->Int32Div(node));
break;
}
if (truncation.TruncatesToWord32()) {
VisitWord32TruncatingBinop(node);
if (lower()) DeferReplacement(node, lowering->Int32Div(node));
break;
}
}
if (BothInputsAreUnsigned32(node) && truncation.TruncatesToWord32()) {
VisitWord32TruncatingBinop(node);
if (lower()) DeferReplacement(node, lowering->Uint32Div(node));
break;
}
VisitFloat64Binop(node);
if (lower()) NodeProperties::ChangeOp(node, Float64Op(node));
break;
}
case IrOpcode::kNumberModulus: {
if (BothInputsAreSigned32(node)) {
if (NodeProperties::GetType(node)->Is(Type::Signed32())) {
VisitInt32Binop(node);
if (lower()) DeferReplacement(node, lowering->Int32Mod(node));
break;
}
if (truncation.TruncatesToWord32()) {
VisitWord32TruncatingBinop(node);
if (lower()) DeferReplacement(node, lowering->Int32Mod(node));
break;
}
}
if (BothInputsAreUnsigned32(node) && truncation.TruncatesToWord32()) {
VisitWord32TruncatingBinop(node);
if (lower()) DeferReplacement(node, lowering->Uint32Mod(node));
break;
}
VisitFloat64Binop(node);
if (lower()) NodeProperties::ChangeOp(node, Float64Op(node));
break;
}
case IrOpcode::kNumberBitwiseOr:
case IrOpcode::kNumberBitwiseXor:
case IrOpcode::kNumberBitwiseAnd: {
VisitInt32Binop(node);
if (lower()) NodeProperties::ChangeOp(node, Int32Op(node));
break;
}
case IrOpcode::kNumberShiftLeft: {
Type* rhs_type = GetInfo(node->InputAt(1))->output_type();
VisitBinop(node, UseInfo::TruncatingWord32(),
UseInfo::TruncatingWord32(), NodeOutputInfo::Int32());
if (lower()) {
lowering->DoShift(node, lowering->machine()->Word32Shl(), rhs_type);
}
break;
}
case IrOpcode::kNumberShiftRight: {
Type* rhs_type = GetInfo(node->InputAt(1))->output_type();
VisitBinop(node, UseInfo::TruncatingWord32(),
UseInfo::TruncatingWord32(), NodeOutputInfo::Int32());
if (lower()) {
lowering->DoShift(node, lowering->machine()->Word32Sar(), rhs_type);
}
break;
}
case IrOpcode::kNumberShiftRightLogical: {
Type* rhs_type = GetInfo(node->InputAt(1))->output_type();
VisitBinop(node, UseInfo::TruncatingWord32(),
UseInfo::TruncatingWord32(), NodeOutputInfo::Uint32());
if (lower()) {
lowering->DoShift(node, lowering->machine()->Word32Shr(), rhs_type);
}
break;
}
case IrOpcode::kNumberToInt32: {
VisitUnop(node, UseInfo::TruncatingWord32(), NodeOutputInfo::Int32());
if (lower()) DeferReplacement(node, node->InputAt(0));
break;
}
case IrOpcode::kNumberToUint32: {
VisitUnop(node, UseInfo::TruncatingWord32(), NodeOutputInfo::Uint32());
if (lower()) DeferReplacement(node, node->InputAt(0));
break;
}
case IrOpcode::kNumberIsHoleNaN: {
VisitUnop(node, UseInfo::Float64(), NodeOutputInfo::Bool());
if (lower()) {
node->ReplaceInput(0,
jsgraph_->graph()->NewNode(
lowering->machine()->Float64ExtractLowWord32(),
node->InputAt(0)));
node->AppendInput(jsgraph_->zone(),
jsgraph_->Int32Constant(kHoleNanLower32));
NodeProperties::ChangeOp(node, jsgraph_->machine()->Word32Equal());
}
break;
}
case IrOpcode::kPlainPrimitiveToNumber: {
VisitUnop(node, UseInfo::AnyTagged(), NodeOutputInfo::NumberTagged());
if (lower()) {
Operator::Properties properties = node->op()->properties();
Callable callable = CodeFactory::ToNumber(jsgraph_->isolate());
CallDescriptor::Flags flags = CallDescriptor::kNoFlags;
CallDescriptor* desc = Linkage::GetStubCallDescriptor(
jsgraph_->isolate(), jsgraph_->zone(), callable.descriptor(), 0,
flags, properties);
node->InsertInput(jsgraph_->zone(), 0,
jsgraph_->HeapConstant(callable.code()));
node->AppendInput(jsgraph_->zone(), jsgraph_->NoContextConstant());
NodeProperties::ChangeOp(node, jsgraph_->common()->Call(desc));
}
break;
}
case IrOpcode::kReferenceEqual: {
VisitBinop(node, UseInfo::AnyTagged(), NodeOutputInfo::Bool());
if (lower()) {
NodeProperties::ChangeOp(node, lowering->machine()->WordEqual());
}
break;
}
case IrOpcode::kStringEqual: {
VisitBinop(node, UseInfo::AnyTagged(), NodeOutputInfo::Bool());
if (lower()) lowering->DoStringEqual(node);
break;
}
case IrOpcode::kStringLessThan: {
VisitBinop(node, UseInfo::AnyTagged(), NodeOutputInfo::Bool());
if (lower()) lowering->DoStringLessThan(node);
break;
}
case IrOpcode::kStringLessThanOrEqual: {
VisitBinop(node, UseInfo::AnyTagged(), NodeOutputInfo::Bool());
if (lower()) lowering->DoStringLessThanOrEqual(node);
break;
}
case IrOpcode::kAllocate: {
ProcessInput(node, 0, UseInfo::AnyTagged());
ProcessRemainingInputs(node, 1);
SetOutput(node, NodeOutputInfo::AnyTagged());
break;
}
case IrOpcode::kLoadField: {
FieldAccess access = FieldAccessOf(node->op());
ProcessInput(node, 0, UseInfoForBasePointer(access));
ProcessRemainingInputs(node, 1);
SetOutputFromMachineType(node, access.machine_type);
break;
}
case IrOpcode::kStoreField: {
FieldAccess access = FieldAccessOf(node->op());
ProcessInput(node, 0, UseInfoForBasePointer(access));
ProcessInput(node, 1, TruncatingUseInfoFromRepresentation(
access.machine_type.representation()));
ProcessRemainingInputs(node, 2);
SetOutput(node, NodeOutputInfo::None());
break;
}
case IrOpcode::kLoadBuffer: {
BufferAccess access = BufferAccessOf(node->op());
ProcessInput(node, 0, UseInfo::PointerInt());                ProcessInput(node, 1, UseInfo::TruncatingWord32());          ProcessInput(node, 2, UseInfo::TruncatingWord32());          ProcessRemainingInputs(node, 3);
NodeOutputInfo output_info;
if (truncation.TruncatesUndefinedToZeroOrNaN()) {
if (truncation.TruncatesNaNToZero()) {
output_info = NodeOutputInfo(access.machine_type().representation(),
NodeProperties::GetType(node));
} else {
if (access.machine_type().representation() ==
MachineRepresentation::kFloat32) {
output_info =
NodeOutputInfo(access.machine_type().representation(),
NodeProperties::GetType(node));
} else {
output_info = NodeOutputInfo::Float64();
}
}
} else {
output_info = NodeOutputInfo::AnyTagged();
}
SetOutput(node, output_info);
if (lower())
lowering->DoLoadBuffer(node, output_info.representation(), changer_);
break;
}
case IrOpcode::kStoreBuffer: {
BufferAccess access = BufferAccessOf(node->op());
ProcessInput(node, 0, UseInfo::PointerInt());                ProcessInput(node, 1, UseInfo::TruncatingWord32());          ProcessInput(node, 2, UseInfo::TruncatingWord32());          ProcessInput(node, 3,
TruncatingUseInfoFromRepresentation(
access.machine_type().representation()));          ProcessRemainingInputs(node, 4);
SetOutput(node, NodeOutputInfo::None());
if (lower()) lowering->DoStoreBuffer(node);
break;
}
case IrOpcode::kLoadElement: {
ElementAccess access = ElementAccessOf(node->op());
ProcessInput(node, 0, UseInfoForBasePointer(access));          ProcessInput(node, 1, UseInfo::TruncatingWord32());            ProcessRemainingInputs(node, 2);
SetOutputFromMachineType(node, access.machine_type);
break;
}
case IrOpcode::kStoreElement: {
ElementAccess access = ElementAccessOf(node->op());
ProcessInput(node, 0, UseInfoForBasePointer(access));          ProcessInput(node, 1, UseInfo::TruncatingWord32());            ProcessInput(node, 2,
TruncatingUseInfoFromRepresentation(
access.machine_type.representation()));          ProcessRemainingInputs(node, 3);
SetOutput(node, NodeOutputInfo::None());
break;
}
case IrOpcode::kObjectIsNumber: {
ProcessInput(node, 0, UseInfo::AnyTagged());
SetOutput(node, NodeOutputInfo::Bool());
break;
}
case IrOpcode::kObjectIsReceiver: {
ProcessInput(node, 0, UseInfo::AnyTagged());
SetOutput(node, NodeOutputInfo::Bool());
break;
}
case IrOpcode::kObjectIsSmi: {
ProcessInput(node, 0, UseInfo::AnyTagged());
SetOutput(node, NodeOutputInfo::Bool());
break;
}
case IrOpcode::kLoad: {
LoadRepresentation rep = LoadRepresentationOf(node->op());
ProcessInput(node, 0, UseInfo::AnyTagged());           ProcessInput(node, 1, UseInfo::PointerInt());          ProcessRemainingInputs(node, 2);
SetOutputFromMachineType(node, rep);
break;
}
case IrOpcode::kStore: {
StoreRepresentation rep = StoreRepresentationOf(node->op());
ProcessInput(node, 0, UseInfo::AnyTagged());           ProcessInput(node, 1, UseInfo::PointerInt());          ProcessInput(node, 2,
TruncatingUseInfoFromRepresentation(rep.representation()));
ProcessRemainingInputs(node, 3);
SetOutput(node, NodeOutputInfo::None());
break;
}
case IrOpcode::kWord32Shr:
return VisitBinop(node, UseInfo::TruncatingWord32(),
NodeOutputInfo::Uint32());
case IrOpcode::kWord32And:
case IrOpcode::kWord32Or:
case IrOpcode::kWord32Xor:
case IrOpcode::kWord32Shl:
case IrOpcode::kWord32Sar:
return VisitBinop(node, UseInfo::TruncatingWord32(),
NodeOutputInfo::Int32());
case IrOpcode::kWord32Equal:
return VisitBinop(node, UseInfo::TruncatingWord32(),
NodeOutputInfo::Bool());
case IrOpcode::kWord32Clz:
return VisitUnop(node, UseInfo::TruncatingWord32(),
NodeOutputInfo::Uint32());
case IrOpcode::kInt32Add:
case IrOpcode::kInt32Sub:
case IrOpcode::kInt32Mul:
case IrOpcode::kInt32MulHigh:
case IrOpcode::kInt32Div:
case IrOpcode::kInt32Mod:
return VisitInt32Binop(node);
case IrOpcode::kUint32Div:
case IrOpcode::kUint32Mod:
case IrOpcode::kUint32MulHigh:
return VisitUint32Binop(node);
case IrOpcode::kInt32LessThan:
case IrOpcode::kInt32LessThanOrEqual:
return VisitInt32Cmp(node);
case IrOpcode::kUint32LessThan:
case IrOpcode::kUint32LessThanOrEqual:
return VisitUint32Cmp(node);
case IrOpcode::kInt64Add:
case IrOpcode::kInt64Sub:
case IrOpcode::kInt64Mul:
case IrOpcode::kInt64Div:
case IrOpcode::kInt64Mod:
return VisitInt64Binop(node);
case IrOpcode::kInt64LessThan:
case IrOpcode::kInt64LessThanOrEqual:
return VisitInt64Cmp(node);
case IrOpcode::kUint64LessThan:
return VisitUint64Cmp(node);
case IrOpcode::kUint64Div:
case IrOpcode::kUint64Mod:
return VisitUint64Binop(node);
case IrOpcode::kWord64And:
case IrOpcode::kWord64Or:
case IrOpcode::kWord64Xor:
case IrOpcode::kWord64Shl:
case IrOpcode::kWord64Shr:
case IrOpcode::kWord64Sar:
return VisitBinop(node, UseInfo::TruncatingWord64(),
NodeOutputInfo::Int64());
case IrOpcode::kWord64Equal:
return VisitBinop(node, UseInfo::TruncatingWord64(),
NodeOutputInfo::Bool());
case IrOpcode::kChangeInt32ToInt64:
return VisitUnop(
node, UseInfo::TruncatingWord32(),
NodeOutputInfo(MachineRepresentation::kWord64, Type::Signed32()));
case IrOpcode::kChangeUint32ToUint64:
return VisitUnop(
node, UseInfo::TruncatingWord32(),
NodeOutputInfo(MachineRepresentation::kWord64, Type::Unsigned32()));
case IrOpcode::kTruncateFloat64ToFloat32:
return VisitUnop(node, UseInfo::Float64(), NodeOutputInfo::Float32());
case IrOpcode::kTruncateFloat64ToInt32:
return VisitUnop(node, UseInfo::Float64(), NodeOutputInfo::Int32());
case IrOpcode::kTruncateInt64ToInt32:
return VisitUnop(node, UseInfo::Word64TruncatingToWord32(),
NodeOutputInfo::Int32());
case IrOpcode::kChangeFloat32ToFloat64:
return VisitUnop(node, UseInfo::Float32(), NodeOutputInfo::Float64());
case IrOpcode::kChangeInt32ToFloat64:
return VisitUnop(
node, UseInfo::TruncatingWord32(),
NodeOutputInfo(MachineRepresentation::kFloat64, Type::Signed32()));
case IrOpcode::kChangeUint32ToFloat64:
return VisitUnop(node, UseInfo::TruncatingWord32(),
NodeOutputInfo(MachineRepresentation::kFloat64,
Type::Unsigned32()));
case IrOpcode::kChangeFloat64ToInt32:
return VisitUnop(node, UseInfo::Float64TruncatingToWord32(),
NodeOutputInfo::Int32());
case IrOpcode::kChangeFloat64ToUint32:
return VisitUnop(node, UseInfo::Float64TruncatingToWord32(),
NodeOutputInfo::Uint32());
case IrOpcode::kFloat64Add:
case IrOpcode::kFloat64Sub:
case IrOpcode::kFloat64Mul:
case IrOpcode::kFloat64Div:
case IrOpcode::kFloat64Mod:
case IrOpcode::kFloat64Min:
return VisitFloat64Binop(node);
case IrOpcode::kFloat64Abs:
case IrOpcode::kFloat64Sqrt:
case IrOpcode::kFloat64RoundDown:
case IrOpcode::kFloat64RoundTruncate:
case IrOpcode::kFloat64RoundTiesAway:
case IrOpcode::kFloat64RoundUp:
return VisitUnop(node, UseInfo::Float64(), NodeOutputInfo::Float64());
case IrOpcode::kFloat64Equal:
case IrOpcode::kFloat64LessThan:
case IrOpcode::kFloat64LessThanOrEqual:
return VisitFloat64Cmp(node);
case IrOpcode::kFloat64ExtractLowWord32:
case IrOpcode::kFloat64ExtractHighWord32:
return VisitUnop(node, UseInfo::Float64(), NodeOutputInfo::Int32());
case IrOpcode::kFloat64InsertLowWord32:
case IrOpcode::kFloat64InsertHighWord32:
return VisitBinop(node, UseInfo::Float64(), UseInfo::TruncatingWord32(),
NodeOutputInfo::Float64());
case IrOpcode::kLoadStackPointer:
case IrOpcode::kLoadFramePointer:
case IrOpcode::kLoadParentFramePointer:
return VisitLeaf(node, NodeOutputInfo::Pointer());
case IrOpcode::kStateValues:
VisitStateValues(node);
break;
default:
VisitInputs(node);
SetOutput(node, NodeOutputInfo::AnyTagged());
break;
}
}","void VisitNode(Node* VAR_0, Truncation VAR_1,
SimplifiedLowering* VAR_2) {
switch (VAR_0->opcode()) {
case IrOpcode::kStart:
case IrOpcode::kDead:
return VisitLeaf(VAR_0, NodeOutputInfo::None());
case IrOpcode::kParameter: {
Type* VAR_3 = NodeProperties::GetType(VAR_0);
ProcessInput(VAR_0, 0, UseInfo::None());
SetOutput(VAR_0, NodeOutputInfo(MachineRepresentation::kTagged, VAR_3));
return;
}
case IrOpcode::kInt32Constant:
return VisitLeaf(VAR_0, NodeOutputInfo::Int32());
case IrOpcode::kInt64Constant:
return VisitLeaf(VAR_0, NodeOutputInfo::Int64());
case IrOpcode::kFloat32Constant:
return VisitLeaf(VAR_0, NodeOutputInfo::Float32());
case IrOpcode::kFloat64Constant:
return VisitLeaf(VAR_0, NodeOutputInfo::Float64());
case IrOpcode::kExternalConstant:
return VisitLeaf(VAR_0, NodeOutputInfo::Pointer());
case IrOpcode::kNumberConstant:
return VisitLeaf(VAR_0, NodeOutputInfo::NumberTagged());
case IrOpcode::kHeapConstant:
return VisitLeaf(VAR_0, NodeOutputInfo::AnyTagged());
case IrOpcode::kDeoptimizeIf:
case IrOpcode::kDeoptimizeUnless:
ProcessInput(VAR_0, 0, UseInfo::Bool());
ProcessInput(VAR_0, 1, UseInfo::AnyTagged());
ProcessRemainingInputs(VAR_0, 2);
break;
case IrOpcode::kBranch:
ProcessInput(VAR_0, 0, UseInfo::Bool());
EnqueueInput(VAR_0, NodeProperties::FirstControlIndex(VAR_0));
break;
case IrOpcode::kSwitch:
ProcessInput(VAR_0, 0, UseInfo::TruncatingWord32());
EnqueueInput(VAR_0, NodeProperties::FirstControlIndex(VAR_0));
break;
case IrOpcode::kSelect:
return VisitSelect(VAR_0, VAR_1, VAR_2);
case IrOpcode::kPhi:
return VisitPhi(VAR_0, VAR_1, VAR_2);
case IrOpcode::kCall:
return VisitCall(VAR_0, VAR_2);
#define DEFINE_JS_CASE(VAR_4) case IrOpcode::k##x:
JS_OP_LIST(VAR_5)
#undef DEFINE_JS_CASE
VisitInputs(VAR_0);
return SetOutput(VAR_0, NodeOutputInfo::AnyTagged());
case IrOpcode::kBooleanNot: {
if (lower()) {
NodeInfo* VAR_6 = GetInfo(VAR_0->InputAt(0));
if (VAR_6->representation() == MachineRepresentation::kBit) {
VAR_0->AppendInput(VAR_7->zone(), VAR_7->Int32Constant(0));
NodeProperties::ChangeOp(VAR_0, VAR_2->machine()->Word32Equal());
} else {
VAR_0->AppendInput(VAR_7->zone(), VAR_7->FalseConstant());
NodeProperties::ChangeOp(VAR_0, VAR_2->machine()->WordEqual());
}
} else {
ProcessInput(VAR_0, 0, UseInfo::AnyTruncatingToBool());
SetOutput(VAR_0, NodeOutputInfo::Bool());
}
break;
}
case IrOpcode::kBooleanToNumber: {
if (lower()) {
NodeInfo* VAR_6 = GetInfo(VAR_0->InputAt(0));
if (VAR_6->representation() == MachineRepresentation::kBit) {
DeferReplacement(VAR_0, VAR_0->InputAt(0));
} else {
VAR_0->AppendInput(VAR_7->zone(), VAR_7->TrueConstant());
NodeProperties::ChangeOp(VAR_0, VAR_2->machine()->WordEqual());
}
} else {
ProcessInput(VAR_0, 0, UseInfo::AnyTruncatingToBool());
SetOutput(VAR_0, NodeOutputInfo::Int32());
}
break;
}
case IrOpcode::kNumberEqual:
case IrOpcode::kNumberLessThan:
case IrOpcode::kNumberLessThanOrEqual: {
if (BothInputsAreSigned32(VAR_0)) {
VisitInt32Cmp(VAR_0);
if (lower()) NodeProperties::ChangeOp(VAR_0, Int32Op(VAR_0));
} else if (BothInputsAreUnsigned32(VAR_0)) {
VisitUint32Cmp(VAR_0);
if (lower()) NodeProperties::ChangeOp(VAR_0, Uint32Op(VAR_0));
} else {
VisitFloat64Cmp(VAR_0);
if (lower()) NodeProperties::ChangeOp(VAR_0, Float64Op(VAR_0));
}
break;
}
case IrOpcode::kNumberAdd:
case IrOpcode::kNumberSubtract: {
if (BothInputsAre(VAR_0, Type::Signed32()) &&
NodeProperties::GetType(VAR_0)->Is(Type::Signed32())) {
VisitInt32Binop(VAR_0);
if (lower()) NodeProperties::ChangeOp(VAR_0, Int32Op(VAR_0));
} else if (BothInputsAre(VAR_0, VAR_8.kAdditiveSafeInteger) &&
VAR_1.TruncatesToWord32()) {
VisitWord32TruncatingBinop(VAR_0);
if (lower()) NodeProperties::ChangeOp(VAR_0, Int32Op(VAR_0));
} else {
VisitFloat64Binop(VAR_0);
if (lower()) NodeProperties::ChangeOp(VAR_0, Float64Op(VAR_0));
}
break;
}
case IrOpcode::kNumberMultiply: {
if (BothInputsAreSigned32(VAR_0)) {
if (NodeProperties::GetType(VAR_0)->Is(Type::Signed32())) {
VisitInt32Binop(VAR_0);
if (lower()) NodeProperties::ChangeOp(VAR_0, Int32Op(VAR_0));
break;
}
if (VAR_1.TruncatesToWord32() &&
NodeProperties::GetType(VAR_0)->Is(VAR_8.kSafeInteger)) {
VisitWord32TruncatingBinop(VAR_0);
if (lower()) NodeProperties::ChangeOp(VAR_0, Int32Op(VAR_0));
break;
}
}
VisitFloat64Binop(VAR_0);
if (lower()) NodeProperties::ChangeOp(VAR_0, Float64Op(VAR_0));
break;
}
case IrOpcode::kNumberDivide: {
if (BothInputsAreSigned32(VAR_0)) {
if (NodeProperties::GetType(VAR_0)->Is(Type::Signed32())) {
VisitInt32Binop(VAR_0);
if (lower()) DeferReplacement(VAR_0, VAR_2->Int32Div(VAR_0));
break;
}
if (VAR_1.TruncatesToWord32()) {
VisitWord32TruncatingBinop(VAR_0);
if (lower()) DeferReplacement(VAR_0, VAR_2->Int32Div(VAR_0));
break;
}
}
if (BothInputsAreUnsigned32(VAR_0) && VAR_1.TruncatesToWord32()) {
VisitWord32TruncatingBinop(VAR_0);
if (lower()) DeferReplacement(VAR_0, VAR_2->Uint32Div(VAR_0));
break;
}
VisitFloat64Binop(VAR_0);
if (lower()) NodeProperties::ChangeOp(VAR_0, Float64Op(VAR_0));
break;
}
case IrOpcode::kNumberModulus: {
if (BothInputsAreSigned32(VAR_0)) {
if (NodeProperties::GetType(VAR_0)->Is(Type::Signed32())) {
VisitInt32Binop(VAR_0);
if (lower()) DeferReplacement(VAR_0, VAR_2->Int32Mod(VAR_0));
break;
}
if (VAR_1.TruncatesToWord32()) {
VisitWord32TruncatingBinop(VAR_0);
if (lower()) DeferReplacement(VAR_0, VAR_2->Int32Mod(VAR_0));
break;
}
}
if (BothInputsAreUnsigned32(VAR_0) && VAR_1.TruncatesToWord32()) {
VisitWord32TruncatingBinop(VAR_0);
if (lower()) DeferReplacement(VAR_0, VAR_2->Uint32Mod(VAR_0));
break;
}
VisitFloat64Binop(VAR_0);
if (lower()) NodeProperties::ChangeOp(VAR_0, Float64Op(VAR_0));
break;
}
case IrOpcode::kNumberBitwiseOr:
case IrOpcode::kNumberBitwiseXor:
case IrOpcode::kNumberBitwiseAnd: {
VisitInt32Binop(VAR_0);
if (lower()) NodeProperties::ChangeOp(VAR_0, Int32Op(VAR_0));
break;
}
case IrOpcode::kNumberShiftLeft: {
Type* VAR_9 = GetInfo(VAR_0->InputAt(1))->output_type();
VisitBinop(VAR_0, UseInfo::TruncatingWord32(),
UseInfo::TruncatingWord32(), NodeOutputInfo::Int32());
if (lower()) {
VAR_2->DoShift(VAR_0, VAR_2->machine()->Word32Shl(), VAR_9);
}
break;
}
case IrOpcode::kNumberShiftRight: {
Type* VAR_9 = GetInfo(VAR_0->InputAt(1))->output_type();
VisitBinop(VAR_0, UseInfo::TruncatingWord32(),
UseInfo::TruncatingWord32(), NodeOutputInfo::Int32());
if (lower()) {
VAR_2->DoShift(VAR_0, VAR_2->machine()->Word32Sar(), VAR_9);
}
break;
}
case IrOpcode::kNumberShiftRightLogical: {
Type* VAR_9 = GetInfo(VAR_0->InputAt(1))->output_type();
VisitBinop(VAR_0, UseInfo::TruncatingWord32(),
UseInfo::TruncatingWord32(), NodeOutputInfo::Uint32());
if (lower()) {
VAR_2->DoShift(VAR_0, VAR_2->machine()->Word32Shr(), VAR_9);
}
break;
}
case IrOpcode::kNumberToInt32: {
VisitUnop(VAR_0, UseInfo::TruncatingWord32(), NodeOutputInfo::Int32());
if (lower()) DeferReplacement(VAR_0, VAR_0->InputAt(0));
break;
}
case IrOpcode::kNumberToUint32: {
VisitUnop(VAR_0, UseInfo::TruncatingWord32(), NodeOutputInfo::Uint32());
if (lower()) DeferReplacement(VAR_0, VAR_0->InputAt(0));
break;
}
case IrOpcode::kNumberIsHoleNaN: {
VisitUnop(VAR_0, UseInfo::Float64(), NodeOutputInfo::Bool());
if (lower()) {
VAR_0->ReplaceInput(0,
VAR_7->graph()->NewNode(
VAR_2->machine()->Float64ExtractLowWord32(),
VAR_0->InputAt(0)));
VAR_0->AppendInput(VAR_7->zone(),
VAR_7->Int32Constant(VAR_10));
NodeProperties::ChangeOp(VAR_0, VAR_7->machine()->Word32Equal());
}
break;
}
case IrOpcode::kPlainPrimitiveToNumber: {
VisitUnop(VAR_0, UseInfo::AnyTagged(), NodeOutputInfo::NumberTagged());
if (lower()) {
Operator::Properties VAR_11 = VAR_0->op()->properties();
Callable VAR_12 = CodeFactory::ToNumber(VAR_7->isolate());
CallDescriptor::Flags VAR_13 = CallDescriptor::kNoFlags;
CallDescriptor* VAR_14 = Linkage::GetStubCallDescriptor(
VAR_7->isolate(), VAR_7->zone(), VAR_12.descriptor(), 0,
VAR_13, VAR_11);
VAR_0->InsertInput(VAR_7->zone(), 0,
VAR_7->HeapConstant(VAR_12.code()));
VAR_0->AppendInput(VAR_7->zone(), VAR_7->NoContextConstant());
NodeProperties::ChangeOp(VAR_0, VAR_7->common()->Call(VAR_14));
}
break;
}
case IrOpcode::kReferenceEqual: {
VisitBinop(VAR_0, UseInfo::AnyTagged(), NodeOutputInfo::Bool());
if (lower()) {
NodeProperties::ChangeOp(VAR_0, VAR_2->machine()->WordEqual());
}
break;
}
case IrOpcode::kStringEqual: {
VisitBinop(VAR_0, UseInfo::AnyTagged(), NodeOutputInfo::Bool());
if (lower()) VAR_2->DoStringEqual(VAR_0);
break;
}
case IrOpcode::kStringLessThan: {
VisitBinop(VAR_0, UseInfo::AnyTagged(), NodeOutputInfo::Bool());
if (lower()) VAR_2->DoStringLessThan(VAR_0);
break;
}
case IrOpcode::kStringLessThanOrEqual: {
VisitBinop(VAR_0, UseInfo::AnyTagged(), NodeOutputInfo::Bool());
if (lower()) VAR_2->DoStringLessThanOrEqual(VAR_0);
break;
}
case IrOpcode::kAllocate: {
ProcessInput(VAR_0, 0, UseInfo::AnyTagged());
ProcessRemainingInputs(VAR_0, 1);
SetOutput(VAR_0, NodeOutputInfo::AnyTagged());
break;
}
case IrOpcode::kLoadField: {
FieldAccess VAR_15 = FieldAccessOf(VAR_0->op());
ProcessInput(VAR_0, 0, UseInfoForBasePointer(VAR_15));
ProcessRemainingInputs(VAR_0, 1);
SetOutputFromMachineType(VAR_0, VAR_15.machine_type);
break;
}
case IrOpcode::kStoreField: {
FieldAccess VAR_15 = FieldAccessOf(VAR_0->op());
ProcessInput(VAR_0, 0, UseInfoForBasePointer(VAR_15));
ProcessInput(VAR_0, 1, TruncatingUseInfoFromRepresentation(
VAR_15.machine_type.representation()));
ProcessRemainingInputs(VAR_0, 2);
SetOutput(VAR_0, NodeOutputInfo::None());
break;
}
case IrOpcode::kLoadBuffer: {
BufferAccess VAR_15 = BufferAccessOf(VAR_0->op());
ProcessInput(VAR_0, 0, UseInfo::PointerInt());        
ProcessInput(VAR_0, 1, UseInfo::TruncatingWord32());  
ProcessInput(VAR_0, 2, UseInfo::TruncatingWord32());  
ProcessRemainingInputs(VAR_0, 3);
NodeOutputInfo VAR_16;
if (VAR_1.TruncatesUndefinedToZeroOrNaN()) {
if (VAR_1.TruncatesNaNToZero()) {
VAR_16 = NodeOutputInfo(VAR_15.machine_type().representation(),
NodeProperties::GetType(VAR_0));
} else {
if (VAR_15.machine_type().representation() ==
MachineRepresentation::kFloat32) {
VAR_16 =
NodeOutputInfo(VAR_15.machine_type().representation(),
NodeProperties::GetType(VAR_0));
} else {
VAR_16 = NodeOutputInfo::Float64();
}
}
} else {
VAR_16 = NodeOutputInfo::AnyTagged();
}
SetOutput(VAR_0, VAR_16);
if (lower())
VAR_2->DoLoadBuffer(VAR_0, VAR_16.representation(), VAR_17);
break;
}
case IrOpcode::kStoreBuffer: {
BufferAccess VAR_15 = BufferAccessOf(VAR_0->op());
ProcessInput(VAR_0, 0, UseInfo::PointerInt());        
ProcessInput(VAR_0, 1, UseInfo::TruncatingWord32());  
ProcessInput(VAR_0, 2, UseInfo::TruncatingWord32());  
ProcessInput(VAR_0, 3,
TruncatingUseInfoFromRepresentation(
VAR_15.machine_type().representation()));  
ProcessRemainingInputs(VAR_0, 4);
SetOutput(VAR_0, NodeOutputInfo::None());
if (lower()) VAR_2->DoStoreBuffer(VAR_0);
break;
}
case IrOpcode::kLoadElement: {
ElementAccess VAR_15 = ElementAccessOf(VAR_0->op());
ProcessInput(VAR_0, 0, UseInfoForBasePointer(VAR_15));  
ProcessInput(VAR_0, 1, UseInfo::TruncatingWord32());    
ProcessRemainingInputs(VAR_0, 2);
SetOutputFromMachineType(VAR_0, VAR_15.machine_type);
break;
}
case IrOpcode::kStoreElement: {
ElementAccess VAR_15 = ElementAccessOf(VAR_0->op());
ProcessInput(VAR_0, 0, UseInfoForBasePointer(VAR_15));  
ProcessInput(VAR_0, 1, UseInfo::TruncatingWord32());    
ProcessInput(VAR_0, 2,
TruncatingUseInfoFromRepresentation(
VAR_15.machine_type.representation()));  
ProcessRemainingInputs(VAR_0, 3);
SetOutput(VAR_0, NodeOutputInfo::None());
break;
}
case IrOpcode::kObjectIsNumber: {
ProcessInput(VAR_0, 0, UseInfo::AnyTagged());
SetOutput(VAR_0, NodeOutputInfo::Bool());
break;
}
case IrOpcode::kObjectIsReceiver: {
ProcessInput(VAR_0, 0, UseInfo::AnyTagged());
SetOutput(VAR_0, NodeOutputInfo::Bool());
break;
}
case IrOpcode::kObjectIsSmi: {
ProcessInput(VAR_0, 0, UseInfo::AnyTagged());
SetOutput(VAR_0, NodeOutputInfo::Bool());
break;
}
case IrOpcode::kLoad: {
LoadRepresentation VAR_18 = LoadRepresentationOf(VAR_0->op());
ProcessInput(VAR_0, 0, UseInfo::AnyTagged());   
ProcessInput(VAR_0, 1, UseInfo::PointerInt());  
ProcessRemainingInputs(VAR_0, 2);
SetOutputFromMachineType(VAR_0, VAR_18);
break;
}
case IrOpcode::kStore: {
StoreRepresentation VAR_18 = StoreRepresentationOf(VAR_0->op());
ProcessInput(VAR_0, 0, UseInfo::AnyTagged());   
ProcessInput(VAR_0, 1, UseInfo::PointerInt());  
ProcessInput(VAR_0, 2,
TruncatingUseInfoFromRepresentation(VAR_18.representation()));
ProcessRemainingInputs(VAR_0, 3);
SetOutput(VAR_0, NodeOutputInfo::None());
break;
}
case IrOpcode::kWord32Shr:
return VisitBinop(VAR_0, UseInfo::TruncatingWord32(),
NodeOutputInfo::Uint32());
case IrOpcode::kWord32And:
case IrOpcode::kWord32Or:
case IrOpcode::kWord32Xor:
case IrOpcode::kWord32Shl:
case IrOpcode::kWord32Sar:
return VisitBinop(VAR_0, UseInfo::TruncatingWord32(),
NodeOutputInfo::Int32());
case IrOpcode::kWord32Equal:
return VisitBinop(VAR_0, UseInfo::TruncatingWord32(),
NodeOutputInfo::Bool());
case IrOpcode::kWord32Clz:
return VisitUnop(VAR_0, UseInfo::TruncatingWord32(),
NodeOutputInfo::Uint32());
case IrOpcode::kInt32Add:
case IrOpcode::kInt32Sub:
case IrOpcode::kInt32Mul:
case IrOpcode::kInt32MulHigh:
case IrOpcode::kInt32Div:
case IrOpcode::kInt32Mod:
return VisitInt32Binop(VAR_0);
case IrOpcode::kUint32Div:
case IrOpcode::kUint32Mod:
case IrOpcode::kUint32MulHigh:
return VisitUint32Binop(VAR_0);
case IrOpcode::kInt32LessThan:
case IrOpcode::kInt32LessThanOrEqual:
return VisitInt32Cmp(VAR_0);
case IrOpcode::kUint32LessThan:
case IrOpcode::kUint32LessThanOrEqual:
return VisitUint32Cmp(VAR_0);
case IrOpcode::kInt64Add:
case IrOpcode::kInt64Sub:
case IrOpcode::kInt64Mul:
case IrOpcode::kInt64Div:
case IrOpcode::kInt64Mod:
return VisitInt64Binop(VAR_0);
case IrOpcode::kInt64LessThan:
case IrOpcode::kInt64LessThanOrEqual:
return VisitInt64Cmp(VAR_0);
case IrOpcode::kUint64LessThan:
return VisitUint64Cmp(VAR_0);
case IrOpcode::kUint64Div:
case IrOpcode::kUint64Mod:
return VisitUint64Binop(VAR_0);
case IrOpcode::kWord64And:
case IrOpcode::kWord64Or:
case IrOpcode::kWord64Xor:
case IrOpcode::kWord64Shl:
case IrOpcode::kWord64Shr:
case IrOpcode::kWord64Sar:
return VisitBinop(VAR_0, UseInfo::TruncatingWord64(),
NodeOutputInfo::Int64());
case IrOpcode::kWord64Equal:
return VisitBinop(VAR_0, UseInfo::TruncatingWord64(),
NodeOutputInfo::Bool());
case IrOpcode::kChangeInt32ToInt64:
return VisitUnop(
VAR_0, UseInfo::TruncatingWord32(),
NodeOutputInfo(MachineRepresentation::kWord64, Type::Signed32()));
case IrOpcode::kChangeUint32ToUint64:
return VisitUnop(
VAR_0, UseInfo::TruncatingWord32(),
NodeOutputInfo(MachineRepresentation::kWord64, Type::Unsigned32()));
case IrOpcode::kTruncateFloat64ToFloat32:
return VisitUnop(VAR_0, UseInfo::Float64(), NodeOutputInfo::Float32());
case IrOpcode::kTruncateFloat64ToInt32:
return VisitUnop(VAR_0, UseInfo::Float64(), NodeOutputInfo::Int32());
case IrOpcode::kTruncateInt64ToInt32:
return VisitUnop(VAR_0, UseInfo::Word64TruncatingToWord32(),
NodeOutputInfo::Int32());
case IrOpcode::kChangeFloat32ToFloat64:
return VisitUnop(VAR_0, UseInfo::Float32(), NodeOutputInfo::Float64());
case IrOpcode::kChangeInt32ToFloat64:
return VisitUnop(
VAR_0, UseInfo::TruncatingWord32(),
NodeOutputInfo(MachineRepresentation::kFloat64, Type::Signed32()));
case IrOpcode::kChangeUint32ToFloat64:
return VisitUnop(VAR_0, UseInfo::TruncatingWord32(),
NodeOutputInfo(MachineRepresentation::kFloat64,
Type::Unsigned32()));
case IrOpcode::kChangeFloat64ToInt32:
return VisitUnop(VAR_0, UseInfo::Float64TruncatingToWord32(),
NodeOutputInfo::Int32());
case IrOpcode::kChangeFloat64ToUint32:
return VisitUnop(VAR_0, UseInfo::Float64TruncatingToWord32(),
NodeOutputInfo::Uint32());
case IrOpcode::kFloat64Add:
case IrOpcode::kFloat64Sub:
case IrOpcode::kFloat64Mul:
case IrOpcode::kFloat64Div:
case IrOpcode::kFloat64Mod:
case IrOpcode::kFloat64Min:
return VisitFloat64Binop(VAR_0);
case IrOpcode::kFloat64Abs:
case IrOpcode::kFloat64Sqrt:
case IrOpcode::kFloat64RoundDown:
case IrOpcode::kFloat64RoundTruncate:
case IrOpcode::kFloat64RoundTiesAway:
case IrOpcode::kFloat64RoundUp:
return VisitUnop(VAR_0, UseInfo::Float64(), NodeOutputInfo::Float64());
case IrOpcode::kFloat64Equal:
case IrOpcode::kFloat64LessThan:
case IrOpcode::kFloat64LessThanOrEqual:
return VisitFloat64Cmp(VAR_0);
case IrOpcode::kFloat64ExtractLowWord32:
case IrOpcode::kFloat64ExtractHighWord32:
return VisitUnop(VAR_0, UseInfo::Float64(), NodeOutputInfo::Int32());
case IrOpcode::kFloat64InsertLowWord32:
case IrOpcode::kFloat64InsertHighWord32:
return VisitBinop(VAR_0, UseInfo::Float64(), UseInfo::TruncatingWord32(),
NodeOutputInfo::Float64());
case IrOpcode::kLoadStackPointer:
case IrOpcode::kLoadFramePointer:
case IrOpcode::kLoadParentFramePointer:
return VisitLeaf(VAR_0, NodeOutputInfo::Pointer());
case IrOpcode::kStateValues:
VisitStateValues(VAR_0);
break;
default:
VisitInputs(VAR_0);
SetOutput(VAR_0, NodeOutputInfo::AnyTagged());
break;
}
}",chromium/58ab990aa8c3aeee38e888c1c33404f4b5a14759/simplified-lowering.cc/vul/before/0.json,"void VisitNode(Node* node, Truncation truncation,
                 SimplifiedLowering* lowering) {
    switch (node->opcode()) {
      //------------------------------------------------------------------
      // Common operators.
      //------------------------------------------------------------------
      case IrOpcode::kStart:
      case IrOpcode::kDead:
        return VisitLeaf(node, NodeOutputInfo::None());
      case IrOpcode::kParameter: {
        // TODO(titzer): use representation from linkage.
        Type* type = NodeProperties::GetType(node);
        ProcessInput(node, 0, UseInfo::None());
        SetOutput(node, NodeOutputInfo(MachineRepresentation::kTagged, type));
        return;
      }
      case IrOpcode::kInt32Constant:
        return VisitLeaf(node, NodeOutputInfo::Int32());
      case IrOpcode::kInt64Constant:
        return VisitLeaf(node, NodeOutputInfo::Int64());
      case IrOpcode::kFloat32Constant:
        return VisitLeaf(node, NodeOutputInfo::Float32());
      case IrOpcode::kFloat64Constant:
        return VisitLeaf(node, NodeOutputInfo::Float64());
      case IrOpcode::kExternalConstant:
        return VisitLeaf(node, NodeOutputInfo::Pointer());
      case IrOpcode::kNumberConstant:
        return VisitLeaf(node, NodeOutputInfo::NumberTagged());
      case IrOpcode::kHeapConstant:
        return VisitLeaf(node, NodeOutputInfo::AnyTagged());

      case IrOpcode::kDeoptimizeIf:
      case IrOpcode::kDeoptimizeUnless:
        ProcessInput(node, 0, UseInfo::Bool());
        ProcessInput(node, 1, UseInfo::AnyTagged());
        ProcessRemainingInputs(node, 2);
        break;
      case IrOpcode::kBranch:
        ProcessInput(node, 0, UseInfo::Bool());
        EnqueueInput(node, NodeProperties::FirstControlIndex(node));
        break;
      case IrOpcode::kSwitch:
        ProcessInput(node, 0, UseInfo::TruncatingWord32());
        EnqueueInput(node, NodeProperties::FirstControlIndex(node));
        break;
      case IrOpcode::kSelect:
        return VisitSelect(node, truncation, lowering);
      case IrOpcode::kPhi:
        return VisitPhi(node, truncation, lowering);
      case IrOpcode::kCall:
        return VisitCall(node, lowering);

//------------------------------------------------------------------
// JavaScript operators.
//------------------------------------------------------------------
// For now, we assume that all JS operators were too complex to lower
// to Simplified and that they will always require tagged value inputs
// and produce tagged value outputs.
// TODO(turbofan): it might be possible to lower some JSOperators here,
// but that responsibility really lies in the typed lowering phase.
#define DEFINE_JS_CASE(x) case IrOpcode::k##x:
        JS_OP_LIST(DEFINE_JS_CASE)
#undef DEFINE_JS_CASE
        VisitInputs(node);
        return SetOutput(node, NodeOutputInfo::AnyTagged());

      //------------------------------------------------------------------
      // Simplified operators.
      //------------------------------------------------------------------
      case IrOpcode::kBooleanNot: {
        if (lower()) {
          NodeInfo* input_info = GetInfo(node->InputAt(0));
          if (input_info->representation() == MachineRepresentation::kBit) {
            // BooleanNot(x: kRepBit) => Word32Equal(x, #0)
            node->AppendInput(jsgraph_->zone(), jsgraph_->Int32Constant(0));
            NodeProperties::ChangeOp(node, lowering->machine()->Word32Equal());
          } else {
            // BooleanNot(x: kRepTagged) => WordEqual(x, #false)
            node->AppendInput(jsgraph_->zone(), jsgraph_->FalseConstant());
            NodeProperties::ChangeOp(node, lowering->machine()->WordEqual());
          }
        } else {
          // No input representation requirement; adapt during lowering.
          ProcessInput(node, 0, UseInfo::AnyTruncatingToBool());
          SetOutput(node, NodeOutputInfo::Bool());
        }
        break;
      }
      case IrOpcode::kBooleanToNumber: {
        if (lower()) {
          NodeInfo* input_info = GetInfo(node->InputAt(0));
          if (input_info->representation() == MachineRepresentation::kBit) {
            // BooleanToNumber(x: kRepBit) => x
            DeferReplacement(node, node->InputAt(0));
          } else {
            // BooleanToNumber(x: kRepTagged) => WordEqual(x, #true)
            node->AppendInput(jsgraph_->zone(), jsgraph_->TrueConstant());
            NodeProperties::ChangeOp(node, lowering->machine()->WordEqual());
          }
        } else {
          // No input representation requirement; adapt during lowering.
          ProcessInput(node, 0, UseInfo::AnyTruncatingToBool());
          SetOutput(node, NodeOutputInfo::Int32());
        }
        break;
      }
      case IrOpcode::kNumberEqual:
      case IrOpcode::kNumberLessThan:
      case IrOpcode::kNumberLessThanOrEqual: {
        // Number comparisons reduce to integer comparisons for integer inputs.
        if (BothInputsAreSigned32(node)) {
          // => signed Int32Cmp
          VisitInt32Cmp(node);
          if (lower()) NodeProperties::ChangeOp(node, Int32Op(node));
        } else if (BothInputsAreUnsigned32(node)) {
          // => unsigned Int32Cmp
          VisitUint32Cmp(node);
          if (lower()) NodeProperties::ChangeOp(node, Uint32Op(node));
        } else {
          // => Float64Cmp
          VisitFloat64Cmp(node);
          if (lower()) NodeProperties::ChangeOp(node, Float64Op(node));
        }
        break;
      }
      case IrOpcode::kNumberAdd:
      case IrOpcode::kNumberSubtract: {
        if (BothInputsAre(node, Type::Signed32()) &&
            NodeProperties::GetType(node)->Is(Type::Signed32())) {
          // int32 + int32 = int32
          // => signed Int32Add/Sub
          VisitInt32Binop(node);
          if (lower()) NodeProperties::ChangeOp(node, Int32Op(node));
        } else if (BothInputsAre(node, type_cache_.kAdditiveSafeInteger) &&
                   truncation.TruncatesToWord32()) {
          // safe-int + safe-int = x (truncated to int32)
          // => signed Int32Add/Sub (truncated)
          VisitWord32TruncatingBinop(node);
          if (lower()) NodeProperties::ChangeOp(node, Int32Op(node));
        } else {
          // => Float64Add/Sub
          VisitFloat64Binop(node);
          if (lower()) NodeProperties::ChangeOp(node, Float64Op(node));
        }
        break;
      }
      case IrOpcode::kNumberMultiply: {
        if (BothInputsAreSigned32(node)) {
          if (NodeProperties::GetType(node)->Is(Type::Signed32())) {
            // Multiply reduces to Int32Mul if the inputs and the output
            // are integers.
            VisitInt32Binop(node);
            if (lower()) NodeProperties::ChangeOp(node, Int32Op(node));
            break;
          }
          if (truncation.TruncatesToWord32() &&
              NodeProperties::GetType(node)->Is(type_cache_.kSafeInteger)) {
            // Multiply reduces to Int32Mul if the inputs are integers,
            // the uses are truncating and the result is in the safe
            // integer range.
            VisitWord32TruncatingBinop(node);
            if (lower()) NodeProperties::ChangeOp(node, Int32Op(node));
            break;
          }
        }
        // => Float64Mul
        VisitFloat64Binop(node);
        if (lower()) NodeProperties::ChangeOp(node, Float64Op(node));
        break;
      }
      case IrOpcode::kNumberDivide: {
        if (BothInputsAreSigned32(node)) {
          if (NodeProperties::GetType(node)->Is(Type::Signed32())) {
          // => signed Int32Div
          VisitInt32Binop(node);
          if (lower()) DeferReplacement(node, lowering->Int32Div(node));
          break;
          }
          if (truncation.TruncatesToWord32()) {
            // => signed Int32Div
            VisitWord32TruncatingBinop(node);
            if (lower()) DeferReplacement(node, lowering->Int32Div(node));
            break;
          }
        }
        if (BothInputsAreUnsigned32(node) && truncation.TruncatesToWord32()) {
          // => unsigned Uint32Div
          VisitWord32TruncatingBinop(node);
          if (lower()) DeferReplacement(node, lowering->Uint32Div(node));
          break;
        }
        // => Float64Div
        VisitFloat64Binop(node);
        if (lower()) NodeProperties::ChangeOp(node, Float64Op(node));
        break;
      }
      case IrOpcode::kNumberModulus: {
        if (BothInputsAreSigned32(node)) {
          if (NodeProperties::GetType(node)->Is(Type::Signed32())) {
            // => signed Int32Mod
            VisitInt32Binop(node);
            if (lower()) DeferReplacement(node, lowering->Int32Mod(node));
            break;
          }
          if (truncation.TruncatesToWord32()) {
            // => signed Int32Mod
            VisitWord32TruncatingBinop(node);
            if (lower()) DeferReplacement(node, lowering->Int32Mod(node));
            break;
          }
        }
        if (BothInputsAreUnsigned32(node) && truncation.TruncatesToWord32()) {
          // => unsigned Uint32Mod
          VisitWord32TruncatingBinop(node);
          if (lower()) DeferReplacement(node, lowering->Uint32Mod(node));
          break;
        }
        // => Float64Mod
        VisitFloat64Binop(node);
        if (lower()) NodeProperties::ChangeOp(node, Float64Op(node));
        break;
      }
      case IrOpcode::kNumberBitwiseOr:
      case IrOpcode::kNumberBitwiseXor:
      case IrOpcode::kNumberBitwiseAnd: {
        VisitInt32Binop(node);
        if (lower()) NodeProperties::ChangeOp(node, Int32Op(node));
        break;
      }
      case IrOpcode::kNumberShiftLeft: {
        Type* rhs_type = GetInfo(node->InputAt(1))->output_type();
        VisitBinop(node, UseInfo::TruncatingWord32(),
                   UseInfo::TruncatingWord32(), NodeOutputInfo::Int32());
        if (lower()) {
          lowering->DoShift(node, lowering->machine()->Word32Shl(), rhs_type);
        }
        break;
      }
      case IrOpcode::kNumberShiftRight: {
        Type* rhs_type = GetInfo(node->InputAt(1))->output_type();
        VisitBinop(node, UseInfo::TruncatingWord32(),
                   UseInfo::TruncatingWord32(), NodeOutputInfo::Int32());
        if (lower()) {
          lowering->DoShift(node, lowering->machine()->Word32Sar(), rhs_type);
        }
        break;
      }
      case IrOpcode::kNumberShiftRightLogical: {
        Type* rhs_type = GetInfo(node->InputAt(1))->output_type();
        VisitBinop(node, UseInfo::TruncatingWord32(),
                   UseInfo::TruncatingWord32(), NodeOutputInfo::Uint32());
        if (lower()) {
          lowering->DoShift(node, lowering->machine()->Word32Shr(), rhs_type);
        }
        break;
      }
      case IrOpcode::kNumberToInt32: {
        // Just change representation if necessary.
        VisitUnop(node, UseInfo::TruncatingWord32(), NodeOutputInfo::Int32());
        if (lower()) DeferReplacement(node, node->InputAt(0));
        break;
      }
      case IrOpcode::kNumberToUint32: {
        // Just change representation if necessary.
        VisitUnop(node, UseInfo::TruncatingWord32(), NodeOutputInfo::Uint32());
        if (lower()) DeferReplacement(node, node->InputAt(0));
        break;
      }
      case IrOpcode::kNumberIsHoleNaN: {
        VisitUnop(node, UseInfo::Float64(), NodeOutputInfo::Bool());
        if (lower()) {
          // NumberIsHoleNaN(x) => Word32Equal(Float64ExtractLowWord32(x),
          //                                   #HoleNaNLower32)
          node->ReplaceInput(0,
                             jsgraph_->graph()->NewNode(
                                 lowering->machine()->Float64ExtractLowWord32(),
                                 node->InputAt(0)));
          node->AppendInput(jsgraph_->zone(),
                            jsgraph_->Int32Constant(kHoleNanLower32));
          NodeProperties::ChangeOp(node, jsgraph_->machine()->Word32Equal());
        }
        break;
      }
      case IrOpcode::kPlainPrimitiveToNumber: {
        VisitUnop(node, UseInfo::AnyTagged(), NodeOutputInfo::NumberTagged());
        if (lower()) {
          // PlainPrimitiveToNumber(x) => Call(ToNumberStub, x, no-context)
          Operator::Properties properties = node->op()->properties();
          Callable callable = CodeFactory::ToNumber(jsgraph_->isolate());
          CallDescriptor::Flags flags = CallDescriptor::kNoFlags;
          CallDescriptor* desc = Linkage::GetStubCallDescriptor(
              jsgraph_->isolate(), jsgraph_->zone(), callable.descriptor(), 0,
              flags, properties);
          node->InsertInput(jsgraph_->zone(), 0,
                            jsgraph_->HeapConstant(callable.code()));
          node->AppendInput(jsgraph_->zone(), jsgraph_->NoContextConstant());
          NodeProperties::ChangeOp(node, jsgraph_->common()->Call(desc));
        }
        break;
      }
      case IrOpcode::kReferenceEqual: {
        VisitBinop(node, UseInfo::AnyTagged(), NodeOutputInfo::Bool());
        if (lower()) {
          NodeProperties::ChangeOp(node, lowering->machine()->WordEqual());
        }
        break;
      }
      case IrOpcode::kStringEqual: {
        VisitBinop(node, UseInfo::AnyTagged(), NodeOutputInfo::Bool());
        if (lower()) lowering->DoStringEqual(node);
        break;
      }
      case IrOpcode::kStringLessThan: {
        VisitBinop(node, UseInfo::AnyTagged(), NodeOutputInfo::Bool());
        if (lower()) lowering->DoStringLessThan(node);
        break;
      }
      case IrOpcode::kStringLessThanOrEqual: {
        VisitBinop(node, UseInfo::AnyTagged(), NodeOutputInfo::Bool());
        if (lower()) lowering->DoStringLessThanOrEqual(node);
        break;
      }
      case IrOpcode::kAllocate: {
        ProcessInput(node, 0, UseInfo::AnyTagged());
        ProcessRemainingInputs(node, 1);
        SetOutput(node, NodeOutputInfo::AnyTagged());
        break;
      }
      case IrOpcode::kLoadField: {
        FieldAccess access = FieldAccessOf(node->op());
        ProcessInput(node, 0, UseInfoForBasePointer(access));
        ProcessRemainingInputs(node, 1);
        SetOutputFromMachineType(node, access.machine_type);
        break;
      }
      case IrOpcode::kStoreField: {
        FieldAccess access = FieldAccessOf(node->op());
        ProcessInput(node, 0, UseInfoForBasePointer(access));
        ProcessInput(node, 1, TruncatingUseInfoFromRepresentation(
                                  access.machine_type.representation()));
        ProcessRemainingInputs(node, 2);
        SetOutput(node, NodeOutputInfo::None());
        break;
      }
      case IrOpcode::kLoadBuffer: {
        BufferAccess access = BufferAccessOf(node->op());
        ProcessInput(node, 0, UseInfo::PointerInt());        // buffer
        ProcessInput(node, 1, UseInfo::TruncatingWord32());  // offset
        ProcessInput(node, 2, UseInfo::TruncatingWord32());  // length
        ProcessRemainingInputs(node, 3);

        NodeOutputInfo output_info;
        if (truncation.TruncatesUndefinedToZeroOrNaN()) {
          if (truncation.TruncatesNaNToZero()) {
            // If undefined is truncated to a non-NaN number, we can use
            // the load's representation.
            output_info = NodeOutputInfo(access.machine_type().representation(),
                                         NodeProperties::GetType(node));
          } else {
            // If undefined is truncated to a number, but the use can
            // observe NaN, we need to output at least the float32
            // representation.
            if (access.machine_type().representation() ==
                MachineRepresentation::kFloat32) {
              output_info =
                  NodeOutputInfo(access.machine_type().representation(),
                                 NodeProperties::GetType(node));
            } else {
              if (access.machine_type().representation() !=
                  MachineRepresentation::kFloat64) {
                // TODO(bmeurer): See comment on abort_compilation_.
                if (lower()) lowering->abort_compilation_ = true;
              }
              output_info = NodeOutputInfo::Float64();
            }
          }
        } else {
          // TODO(bmeurer): See comment on abort_compilation_.
          if (lower()) lowering->abort_compilation_ = true;

          // If undefined is not truncated away, we need to have the tagged
          // representation.
          output_info = NodeOutputInfo::AnyTagged();
        }
        SetOutput(node, output_info);
        if (lower())
          lowering->DoLoadBuffer(node, output_info.representation(), changer_);
        break;
      }
      case IrOpcode::kStoreBuffer: {
        BufferAccess access = BufferAccessOf(node->op());
        ProcessInput(node, 0, UseInfo::PointerInt());        // buffer
        ProcessInput(node, 1, UseInfo::TruncatingWord32());  // offset
        ProcessInput(node, 2, UseInfo::TruncatingWord32());  // length
        ProcessInput(node, 3,
                     TruncatingUseInfoFromRepresentation(
                         access.machine_type().representation()));  // value
        ProcessRemainingInputs(node, 4);
        SetOutput(node, NodeOutputInfo::None());
        if (lower()) lowering->DoStoreBuffer(node);
        break;
      }
      case IrOpcode::kLoadElement: {
        ElementAccess access = ElementAccessOf(node->op());
        ProcessInput(node, 0, UseInfoForBasePointer(access));  // base
        ProcessInput(node, 1, UseInfo::TruncatingWord32());    // index
        ProcessRemainingInputs(node, 2);
        SetOutputFromMachineType(node, access.machine_type);
        break;
      }
      case IrOpcode::kStoreElement: {
        ElementAccess access = ElementAccessOf(node->op());
        ProcessInput(node, 0, UseInfoForBasePointer(access));  // base
        ProcessInput(node, 1, UseInfo::TruncatingWord32());    // index
        ProcessInput(node, 2,
                     TruncatingUseInfoFromRepresentation(
                         access.machine_type.representation()));  // value
        ProcessRemainingInputs(node, 3);
        SetOutput(node, NodeOutputInfo::None());
        break;
      }
      case IrOpcode::kObjectIsNumber: {
        ProcessInput(node, 0, UseInfo::AnyTagged());
        SetOutput(node, NodeOutputInfo::Bool());
        break;
      }
      case IrOpcode::kObjectIsReceiver: {
        ProcessInput(node, 0, UseInfo::AnyTagged());
        SetOutput(node, NodeOutputInfo::Bool());
        break;
      }
      case IrOpcode::kObjectIsSmi: {
        ProcessInput(node, 0, UseInfo::AnyTagged());
        SetOutput(node, NodeOutputInfo::Bool());
        break;
      }

      //------------------------------------------------------------------
      // Machine-level operators.
      //------------------------------------------------------------------
      case IrOpcode::kLoad: {
        // TODO(jarin) Eventually, we should get rid of all machine stores
        // from the high-level phases, then this becomes UNREACHABLE.
        LoadRepresentation rep = LoadRepresentationOf(node->op());
        ProcessInput(node, 0, UseInfo::AnyTagged());   // tagged pointer
        ProcessInput(node, 1, UseInfo::PointerInt());  // index
        ProcessRemainingInputs(node, 2);
        SetOutputFromMachineType(node, rep);
        break;
      }
      case IrOpcode::kStore: {
        // TODO(jarin) Eventually, we should get rid of all machine stores
        // from the high-level phases, then this becomes UNREACHABLE.
        StoreRepresentation rep = StoreRepresentationOf(node->op());
        ProcessInput(node, 0, UseInfo::AnyTagged());   // tagged pointer
        ProcessInput(node, 1, UseInfo::PointerInt());  // index
        ProcessInput(node, 2,
                     TruncatingUseInfoFromRepresentation(rep.representation()));
        ProcessRemainingInputs(node, 3);
        SetOutput(node, NodeOutputInfo::None());
        break;
      }
      case IrOpcode::kWord32Shr:
        // We output unsigned int32 for shift right because JavaScript.
        return VisitBinop(node, UseInfo::TruncatingWord32(),
                          NodeOutputInfo::Uint32());
      case IrOpcode::kWord32And:
      case IrOpcode::kWord32Or:
      case IrOpcode::kWord32Xor:
      case IrOpcode::kWord32Shl:
      case IrOpcode::kWord32Sar:
        // We use signed int32 as the output type for these word32 operations,
        // though the machine bits are the same for either signed or unsigned,
        // because JavaScript considers the result from these operations signed.
        return VisitBinop(node, UseInfo::TruncatingWord32(),
                          NodeOutputInfo::Int32());
      case IrOpcode::kWord32Equal:
        return VisitBinop(node, UseInfo::TruncatingWord32(),
                          NodeOutputInfo::Bool());

      case IrOpcode::kWord32Clz:
        return VisitUnop(node, UseInfo::TruncatingWord32(),
                         NodeOutputInfo::Uint32());

      case IrOpcode::kInt32Add:
      case IrOpcode::kInt32Sub:
      case IrOpcode::kInt32Mul:
      case IrOpcode::kInt32MulHigh:
      case IrOpcode::kInt32Div:
      case IrOpcode::kInt32Mod:
        return VisitInt32Binop(node);
      case IrOpcode::kUint32Div:
      case IrOpcode::kUint32Mod:
      case IrOpcode::kUint32MulHigh:
        return VisitUint32Binop(node);
      case IrOpcode::kInt32LessThan:
      case IrOpcode::kInt32LessThanOrEqual:
        return VisitInt32Cmp(node);

      case IrOpcode::kUint32LessThan:
      case IrOpcode::kUint32LessThanOrEqual:
        return VisitUint32Cmp(node);

      case IrOpcode::kInt64Add:
      case IrOpcode::kInt64Sub:
      case IrOpcode::kInt64Mul:
      case IrOpcode::kInt64Div:
      case IrOpcode::kInt64Mod:
        return VisitInt64Binop(node);
      case IrOpcode::kInt64LessThan:
      case IrOpcode::kInt64LessThanOrEqual:
        return VisitInt64Cmp(node);

      case IrOpcode::kUint64LessThan:
        return VisitUint64Cmp(node);

      case IrOpcode::kUint64Div:
      case IrOpcode::kUint64Mod:
        return VisitUint64Binop(node);

      case IrOpcode::kWord64And:
      case IrOpcode::kWord64Or:
      case IrOpcode::kWord64Xor:
      case IrOpcode::kWord64Shl:
      case IrOpcode::kWord64Shr:
      case IrOpcode::kWord64Sar:
        return VisitBinop(node, UseInfo::TruncatingWord64(),
                          NodeOutputInfo::Int64());
      case IrOpcode::kWord64Equal:
        return VisitBinop(node, UseInfo::TruncatingWord64(),
                          NodeOutputInfo::Bool());

      case IrOpcode::kChangeInt32ToInt64:
        return VisitUnop(
            node, UseInfo::TruncatingWord32(),
            NodeOutputInfo(MachineRepresentation::kWord64, Type::Signed32()));
      case IrOpcode::kChangeUint32ToUint64:
        return VisitUnop(
            node, UseInfo::TruncatingWord32(),
            NodeOutputInfo(MachineRepresentation::kWord64, Type::Unsigned32()));
      case IrOpcode::kTruncateFloat64ToFloat32:
        return VisitUnop(node, UseInfo::Float64(), NodeOutputInfo::Float32());
      case IrOpcode::kTruncateFloat64ToInt32:
        return VisitUnop(node, UseInfo::Float64(), NodeOutputInfo::Int32());
      case IrOpcode::kTruncateInt64ToInt32:
        // TODO(titzer): Is kTypeInt32 correct here?
        return VisitUnop(node, UseInfo::Word64TruncatingToWord32(),
                         NodeOutputInfo::Int32());

      case IrOpcode::kChangeFloat32ToFloat64:
        return VisitUnop(node, UseInfo::Float32(), NodeOutputInfo::Float64());
      case IrOpcode::kChangeInt32ToFloat64:
        return VisitUnop(
            node, UseInfo::TruncatingWord32(),
            NodeOutputInfo(MachineRepresentation::kFloat64, Type::Signed32()));
      case IrOpcode::kChangeUint32ToFloat64:
        return VisitUnop(node, UseInfo::TruncatingWord32(),
                         NodeOutputInfo(MachineRepresentation::kFloat64,
                                        Type::Unsigned32()));
      case IrOpcode::kChangeFloat64ToInt32:
        return VisitUnop(node, UseInfo::Float64TruncatingToWord32(),
                         NodeOutputInfo::Int32());
      case IrOpcode::kChangeFloat64ToUint32:
        return VisitUnop(node, UseInfo::Float64TruncatingToWord32(),
                         NodeOutputInfo::Uint32());

      case IrOpcode::kFloat64Add:
      case IrOpcode::kFloat64Sub:
      case IrOpcode::kFloat64Mul:
      case IrOpcode::kFloat64Div:
      case IrOpcode::kFloat64Mod:
      case IrOpcode::kFloat64Min:
        return VisitFloat64Binop(node);
      case IrOpcode::kFloat64Abs:
      case IrOpcode::kFloat64Sqrt:
      case IrOpcode::kFloat64RoundDown:
      case IrOpcode::kFloat64RoundTruncate:
      case IrOpcode::kFloat64RoundTiesAway:
      case IrOpcode::kFloat64RoundUp:
        return VisitUnop(node, UseInfo::Float64(), NodeOutputInfo::Float64());
      case IrOpcode::kFloat64Equal:
      case IrOpcode::kFloat64LessThan:
      case IrOpcode::kFloat64LessThanOrEqual:
        return VisitFloat64Cmp(node);
      case IrOpcode::kFloat64ExtractLowWord32:
      case IrOpcode::kFloat64ExtractHighWord32:
        return VisitUnop(node, UseInfo::Float64(), NodeOutputInfo::Int32());
      case IrOpcode::kFloat64InsertLowWord32:
      case IrOpcode::kFloat64InsertHighWord32:
        return VisitBinop(node, UseInfo::Float64(), UseInfo::TruncatingWord32(),
                          NodeOutputInfo::Float64());
      case IrOpcode::kLoadStackPointer:
      case IrOpcode::kLoadFramePointer:
      case IrOpcode::kLoadParentFramePointer:
        return VisitLeaf(node, NodeOutputInfo::Pointer());
      case IrOpcode::kStateValues:
        VisitStateValues(node);
        break;
      default:
        VisitInputs(node);
        // Assume the output is tagged.
        SetOutput(node, NodeOutputInfo::AnyTagged());
        break;
    }
  }","void VisitNode(Node* VAR_0, Truncation VAR_1,
                 SimplifiedLowering* VAR_2) {
    switch (VAR_0->opcode()) {
      /* COMMENT_0 */
      /* COMMENT_1 */
      /* COMMENT_0 */
      case IrOpcode::kStart:
      case IrOpcode::kDead:
        return VisitLeaf(VAR_0, NodeOutputInfo::None());
      case IrOpcode::kParameter: {
        /* COMMENT_2 */
        Type* VAR_3 = NodeProperties::GetType(VAR_0);
        ProcessInput(VAR_0, 0, UseInfo::None());
        SetOutput(VAR_0, NodeOutputInfo(MachineRepresentation::kTagged, VAR_3));
        return;
      }
      case IrOpcode::kInt32Constant:
        return VisitLeaf(VAR_0, NodeOutputInfo::Int32());
      case IrOpcode::kInt64Constant:
        return VisitLeaf(VAR_0, NodeOutputInfo::Int64());
      case IrOpcode::kFloat32Constant:
        return VisitLeaf(VAR_0, NodeOutputInfo::Float32());
      case IrOpcode::kFloat64Constant:
        return VisitLeaf(VAR_0, NodeOutputInfo::Float64());
      case IrOpcode::kExternalConstant:
        return VisitLeaf(VAR_0, NodeOutputInfo::Pointer());
      case IrOpcode::kNumberConstant:
        return VisitLeaf(VAR_0, NodeOutputInfo::NumberTagged());
      case IrOpcode::kHeapConstant:
        return VisitLeaf(VAR_0, NodeOutputInfo::AnyTagged());

      case IrOpcode::kDeoptimizeIf:
      case IrOpcode::kDeoptimizeUnless:
        ProcessInput(VAR_0, 0, UseInfo::Bool());
        ProcessInput(VAR_0, 1, UseInfo::AnyTagged());
        ProcessRemainingInputs(VAR_0, 2);
        break;
      case IrOpcode::kBranch:
        ProcessInput(VAR_0, 0, UseInfo::Bool());
        EnqueueInput(VAR_0, NodeProperties::FirstControlIndex(VAR_0));
        break;
      case IrOpcode::kSwitch:
        ProcessInput(VAR_0, 0, UseInfo::TruncatingWord32());
        EnqueueInput(VAR_0, NodeProperties::FirstControlIndex(VAR_0));
        break;
      case IrOpcode::kSelect:
        return VisitSelect(VAR_0, VAR_1, VAR_2);
      case IrOpcode::kPhi:
        return VisitPhi(VAR_0, VAR_1, VAR_2);
      case IrOpcode::kCall:
        return VisitCall(VAR_0, VAR_2);

/* COMMENT_0 */
/* COMMENT_3 */
/* COMMENT_0 */
/* COMMENT_4 */
/* COMMENT_5 */
/* COMMENT_6 */
/* COMMENT_7 */
/* COMMENT_8 */
#define DEFINE_JS_CASE(VAR_4) case IrOpcode::k##x:
        JS_OP_LIST(VAR_5)
#undef DEFINE_JS_CASE
        VisitInputs(VAR_0);
        return SetOutput(VAR_0, NodeOutputInfo::AnyTagged());

      /* COMMENT_0 */
      /* COMMENT_9 */
      /* COMMENT_0 */
      case IrOpcode::kBooleanNot: {
        if (lower()) {
          NodeInfo* VAR_6 = GetInfo(VAR_0->InputAt(0));
          if (VAR_6->representation() == MachineRepresentation::kBit) {
            /* COMMENT_10 */
            VAR_0->AppendInput(VAR_7->zone(), VAR_7->Int32Constant(0));
            NodeProperties::ChangeOp(VAR_0, VAR_2->machine()->Word32Equal());
          } else {
            /* COMMENT_11 */
            VAR_0->AppendInput(VAR_7->zone(), VAR_7->FalseConstant());
            NodeProperties::ChangeOp(VAR_0, VAR_2->machine()->WordEqual());
          }
        } else {
          /* COMMENT_12 */
          ProcessInput(VAR_0, 0, UseInfo::AnyTruncatingToBool());
          SetOutput(VAR_0, NodeOutputInfo::Bool());
        }
        break;
      }
      case IrOpcode::kBooleanToNumber: {
        if (lower()) {
          NodeInfo* VAR_6 = GetInfo(VAR_0->InputAt(0));
          if (VAR_6->representation() == MachineRepresentation::kBit) {
            /* COMMENT_13 */
            DeferReplacement(VAR_0, VAR_0->InputAt(0));
          } else {
            /* COMMENT_14 */
            VAR_0->AppendInput(VAR_7->zone(), VAR_7->TrueConstant());
            NodeProperties::ChangeOp(VAR_0, VAR_2->machine()->WordEqual());
          }
        } else {
          /* COMMENT_12 */
          ProcessInput(VAR_0, 0, UseInfo::AnyTruncatingToBool());
          SetOutput(VAR_0, NodeOutputInfo::Int32());
        }
        break;
      }
      case IrOpcode::kNumberEqual:
      case IrOpcode::kNumberLessThan:
      case IrOpcode::kNumberLessThanOrEqual: {
        /* COMMENT_15 */
        if (BothInputsAreSigned32(VAR_0)) {
          /* COMMENT_16 */
          VisitInt32Cmp(VAR_0);
          if (lower()) NodeProperties::ChangeOp(VAR_0, Int32Op(VAR_0));
        } else if (BothInputsAreUnsigned32(VAR_0)) {
          /* COMMENT_17 */
          VisitUint32Cmp(VAR_0);
          if (lower()) NodeProperties::ChangeOp(VAR_0, Uint32Op(VAR_0));
        } else {
          /* COMMENT_18 */
          VisitFloat64Cmp(VAR_0);
          if (lower()) NodeProperties::ChangeOp(VAR_0, Float64Op(VAR_0));
        }
        break;
      }
      case IrOpcode::kNumberAdd:
      case IrOpcode::kNumberSubtract: {
        if (BothInputsAre(VAR_0, Type::Signed32()) &&
            NodeProperties::GetType(VAR_0)->Is(Type::Signed32())) {
          /* COMMENT_19 */
          /* COMMENT_20 */
          VisitInt32Binop(VAR_0);
          if (lower()) NodeProperties::ChangeOp(VAR_0, Int32Op(VAR_0));
        } else if (BothInputsAre(VAR_0, VAR_8.kAdditiveSafeInteger) &&
                   VAR_1.TruncatesToWord32()) {
          /* COMMENT_21 */
          /* COMMENT_22 */
          VisitWord32TruncatingBinop(VAR_0);
          if (lower()) NodeProperties::ChangeOp(VAR_0, Int32Op(VAR_0));
        } else {
          /* COMMENT_23 */
          VisitFloat64Binop(VAR_0);
          if (lower()) NodeProperties::ChangeOp(VAR_0, Float64Op(VAR_0));
        }
        break;
      }
      case IrOpcode::kNumberMultiply: {
        if (BothInputsAreSigned32(VAR_0)) {
          if (NodeProperties::GetType(VAR_0)->Is(Type::Signed32())) {
            /* COMMENT_24 */
            /* COMMENT_25 */
            VisitInt32Binop(VAR_0);
            if (lower()) NodeProperties::ChangeOp(VAR_0, Int32Op(VAR_0));
            break;
          }
          if (VAR_1.TruncatesToWord32() &&
              NodeProperties::GetType(VAR_0)->Is(VAR_8.kSafeInteger)) {
            /* COMMENT_26 */
            /* COMMENT_27 */
            /* COMMENT_28 */
            VisitWord32TruncatingBinop(VAR_0);
            if (lower()) NodeProperties::ChangeOp(VAR_0, Int32Op(VAR_0));
            break;
          }
        }
        /* COMMENT_29 */
        VisitFloat64Binop(VAR_0);
        if (lower()) NodeProperties::ChangeOp(VAR_0, Float64Op(VAR_0));
        break;
      }
      case IrOpcode::kNumberDivide: {
        if (BothInputsAreSigned32(VAR_0)) {
          if (NodeProperties::GetType(VAR_0)->Is(Type::Signed32())) {
          /* COMMENT_30 */
          VisitInt32Binop(VAR_0);
          if (lower()) DeferReplacement(VAR_0, VAR_2->Int32Div(VAR_0));
          break;
          }
          if (VAR_1.TruncatesToWord32()) {
            /* COMMENT_30 */
            VisitWord32TruncatingBinop(VAR_0);
            if (lower()) DeferReplacement(VAR_0, VAR_2->Int32Div(VAR_0));
            break;
          }
        }
        if (BothInputsAreUnsigned32(VAR_0) && VAR_1.TruncatesToWord32()) {
          /* COMMENT_31 */
          VisitWord32TruncatingBinop(VAR_0);
          if (lower()) DeferReplacement(VAR_0, VAR_2->Uint32Div(VAR_0));
          break;
        }
        /* COMMENT_32 */
        VisitFloat64Binop(VAR_0);
        if (lower()) NodeProperties::ChangeOp(VAR_0, Float64Op(VAR_0));
        break;
      }
      case IrOpcode::kNumberModulus: {
        if (BothInputsAreSigned32(VAR_0)) {
          if (NodeProperties::GetType(VAR_0)->Is(Type::Signed32())) {
            /* COMMENT_33 */
            VisitInt32Binop(VAR_0);
            if (lower()) DeferReplacement(VAR_0, VAR_2->Int32Mod(VAR_0));
            break;
          }
          if (VAR_1.TruncatesToWord32()) {
            /* COMMENT_33 */
            VisitWord32TruncatingBinop(VAR_0);
            if (lower()) DeferReplacement(VAR_0, VAR_2->Int32Mod(VAR_0));
            break;
          }
        }
        if (BothInputsAreUnsigned32(VAR_0) && VAR_1.TruncatesToWord32()) {
          /* COMMENT_34 */
          VisitWord32TruncatingBinop(VAR_0);
          if (lower()) DeferReplacement(VAR_0, VAR_2->Uint32Mod(VAR_0));
          break;
        }
        /* COMMENT_35 */
        VisitFloat64Binop(VAR_0);
        if (lower()) NodeProperties::ChangeOp(VAR_0, Float64Op(VAR_0));
        break;
      }
      case IrOpcode::kNumberBitwiseOr:
      case IrOpcode::kNumberBitwiseXor:
      case IrOpcode::kNumberBitwiseAnd: {
        VisitInt32Binop(VAR_0);
        if (lower()) NodeProperties::ChangeOp(VAR_0, Int32Op(VAR_0));
        break;
      }
      case IrOpcode::kNumberShiftLeft: {
        Type* VAR_9 = GetInfo(VAR_0->InputAt(1))->output_type();
        VisitBinop(VAR_0, UseInfo::TruncatingWord32(),
                   UseInfo::TruncatingWord32(), NodeOutputInfo::Int32());
        if (lower()) {
          VAR_2->DoShift(VAR_0, VAR_2->machine()->Word32Shl(), VAR_9);
        }
        break;
      }
      case IrOpcode::kNumberShiftRight: {
        Type* VAR_9 = GetInfo(VAR_0->InputAt(1))->output_type();
        VisitBinop(VAR_0, UseInfo::TruncatingWord32(),
                   UseInfo::TruncatingWord32(), NodeOutputInfo::Int32());
        if (lower()) {
          VAR_2->DoShift(VAR_0, VAR_2->machine()->Word32Sar(), VAR_9);
        }
        break;
      }
      case IrOpcode::kNumberShiftRightLogical: {
        Type* VAR_9 = GetInfo(VAR_0->InputAt(1))->output_type();
        VisitBinop(VAR_0, UseInfo::TruncatingWord32(),
                   UseInfo::TruncatingWord32(), NodeOutputInfo::Uint32());
        if (lower()) {
          VAR_2->DoShift(VAR_0, VAR_2->machine()->Word32Shr(), VAR_9);
        }
        break;
      }
      case IrOpcode::kNumberToInt32: {
        /* COMMENT_36 */
        VisitUnop(VAR_0, UseInfo::TruncatingWord32(), NodeOutputInfo::Int32());
        if (lower()) DeferReplacement(VAR_0, VAR_0->InputAt(0));
        break;
      }
      case IrOpcode::kNumberToUint32: {
        /* COMMENT_36 */
        VisitUnop(VAR_0, UseInfo::TruncatingWord32(), NodeOutputInfo::Uint32());
        if (lower()) DeferReplacement(VAR_0, VAR_0->InputAt(0));
        break;
      }
      case IrOpcode::kNumberIsHoleNaN: {
        VisitUnop(VAR_0, UseInfo::Float64(), NodeOutputInfo::Bool());
        if (lower()) {
          /* COMMENT_37 */
          /* COMMENT_38 */
          VAR_0->ReplaceInput(0,
                             VAR_7->graph()->NewNode(
                                 VAR_2->machine()->Float64ExtractLowWord32(),
                                 VAR_0->InputAt(0)));
          VAR_0->AppendInput(VAR_7->zone(),
                            VAR_7->Int32Constant(VAR_10));
          NodeProperties::ChangeOp(VAR_0, VAR_7->machine()->Word32Equal());
        }
        break;
      }
      case IrOpcode::kPlainPrimitiveToNumber: {
        VisitUnop(VAR_0, UseInfo::AnyTagged(), NodeOutputInfo::NumberTagged());
        if (lower()) {
          /* COMMENT_39 */
          Operator::Properties VAR_11 = VAR_0->op()->properties();
          Callable VAR_12 = CodeFactory::ToNumber(VAR_7->isolate());
          CallDescriptor::Flags VAR_13 = CallDescriptor::kNoFlags;
          CallDescriptor* VAR_14 = Linkage::GetStubCallDescriptor(
              VAR_7->isolate(), VAR_7->zone(), VAR_12.descriptor(), 0,
              VAR_13, VAR_11);
          VAR_0->InsertInput(VAR_7->zone(), 0,
                            VAR_7->HeapConstant(VAR_12.code()));
          VAR_0->AppendInput(VAR_7->zone(), VAR_7->NoContextConstant());
          NodeProperties::ChangeOp(VAR_0, VAR_7->common()->Call(VAR_14));
        }
        break;
      }
      case IrOpcode::kReferenceEqual: {
        VisitBinop(VAR_0, UseInfo::AnyTagged(), NodeOutputInfo::Bool());
        if (lower()) {
          NodeProperties::ChangeOp(VAR_0, VAR_2->machine()->WordEqual());
        }
        break;
      }
      case IrOpcode::kStringEqual: {
        VisitBinop(VAR_0, UseInfo::AnyTagged(), NodeOutputInfo::Bool());
        if (lower()) VAR_2->DoStringEqual(VAR_0);
        break;
      }
      case IrOpcode::kStringLessThan: {
        VisitBinop(VAR_0, UseInfo::AnyTagged(), NodeOutputInfo::Bool());
        if (lower()) VAR_2->DoStringLessThan(VAR_0);
        break;
      }
      case IrOpcode::kStringLessThanOrEqual: {
        VisitBinop(VAR_0, UseInfo::AnyTagged(), NodeOutputInfo::Bool());
        if (lower()) VAR_2->DoStringLessThanOrEqual(VAR_0);
        break;
      }
      case IrOpcode::kAllocate: {
        ProcessInput(VAR_0, 0, UseInfo::AnyTagged());
        ProcessRemainingInputs(VAR_0, 1);
        SetOutput(VAR_0, NodeOutputInfo::AnyTagged());
        break;
      }
      case IrOpcode::kLoadField: {
        FieldAccess VAR_15 = FieldAccessOf(VAR_0->op());
        ProcessInput(VAR_0, 0, UseInfoForBasePointer(VAR_15));
        ProcessRemainingInputs(VAR_0, 1);
        SetOutputFromMachineType(VAR_0, VAR_15.machine_type);
        break;
      }
      case IrOpcode::kStoreField: {
        FieldAccess VAR_15 = FieldAccessOf(VAR_0->op());
        ProcessInput(VAR_0, 0, UseInfoForBasePointer(VAR_15));
        ProcessInput(VAR_0, 1, TruncatingUseInfoFromRepresentation(
                                  VAR_15.machine_type.representation()));
        ProcessRemainingInputs(VAR_0, 2);
        SetOutput(VAR_0, NodeOutputInfo::None());
        break;
      }
      case IrOpcode::kLoadBuffer: {
        BufferAccess VAR_15 = BufferAccessOf(VAR_0->op());
        ProcessInput(VAR_0, 0, UseInfo::PointerInt());        /* COMMENT_40 */
        ProcessInput(VAR_0, 1, UseInfo::TruncatingWord32());  /* COMMENT_41 */
        ProcessInput(VAR_0, 2, UseInfo::TruncatingWord32());  /* COMMENT_42 */
        ProcessRemainingInputs(VAR_0, 3);

        NodeOutputInfo VAR_16;
        if (VAR_1.TruncatesUndefinedToZeroOrNaN()) {
          if (VAR_1.TruncatesNaNToZero()) {
            /* COMMENT_43 */
            /* COMMENT_44 */
            VAR_16 = NodeOutputInfo(VAR_15.machine_type().representation(),
                                         NodeProperties::GetType(VAR_0));
          } else {
            /* COMMENT_45 */
            /* COMMENT_46 */
            /* COMMENT_47 */
            if (VAR_15.machine_type().representation() ==
                MachineRepresentation::kFloat32) {
              VAR_16 =
                  NodeOutputInfo(VAR_15.machine_type().representation(),
                                 NodeProperties::GetType(VAR_0));
            } else {
              if (VAR_15.machine_type().representation() !=
                  MachineRepresentation::kFloat64) {
                /* COMMENT_48 */
                if (lower()) VAR_2->abort_compilation_ = true;
              }
              VAR_16 = NodeOutputInfo::Float64();
            }
          }
        } else {
          /* COMMENT_48 */
          if (lower()) VAR_2->abort_compilation_ = true;

          /* COMMENT_49 */
          /* COMMENT_47 */
          VAR_16 = NodeOutputInfo::AnyTagged();
        }
        SetOutput(VAR_0, VAR_16);
        if (lower())
          VAR_2->DoLoadBuffer(VAR_0, VAR_16.representation(), VAR_17);
        break;
      }
      case IrOpcode::kStoreBuffer: {
        BufferAccess VAR_15 = BufferAccessOf(VAR_0->op());
        ProcessInput(VAR_0, 0, UseInfo::PointerInt());        /* COMMENT_40 */
        ProcessInput(VAR_0, 1, UseInfo::TruncatingWord32());  /* COMMENT_41 */
        ProcessInput(VAR_0, 2, UseInfo::TruncatingWord32());  /* COMMENT_42 */
        ProcessInput(VAR_0, 3,
                     TruncatingUseInfoFromRepresentation(
                         VAR_15.machine_type().representation()));  /* COMMENT_50 */
        ProcessRemainingInputs(VAR_0, 4);
        SetOutput(VAR_0, NodeOutputInfo::None());
        if (lower()) VAR_2->DoStoreBuffer(VAR_0);
        break;
      }
      case IrOpcode::kLoadElement: {
        ElementAccess VAR_15 = ElementAccessOf(VAR_0->op());
        ProcessInput(VAR_0, 0, UseInfoForBasePointer(VAR_15));  /* COMMENT_51 */
        ProcessInput(VAR_0, 1, UseInfo::TruncatingWord32());    /* COMMENT_52 */
        ProcessRemainingInputs(VAR_0, 2);
        SetOutputFromMachineType(VAR_0, VAR_15.machine_type);
        break;
      }
      case IrOpcode::kStoreElement: {
        ElementAccess VAR_15 = ElementAccessOf(VAR_0->op());
        ProcessInput(VAR_0, 0, UseInfoForBasePointer(VAR_15));  /* COMMENT_51 */
        ProcessInput(VAR_0, 1, UseInfo::TruncatingWord32());    /* COMMENT_52 */
        ProcessInput(VAR_0, 2,
                     TruncatingUseInfoFromRepresentation(
                         VAR_15.machine_type.representation()));  /* COMMENT_50 */
        ProcessRemainingInputs(VAR_0, 3);
        SetOutput(VAR_0, NodeOutputInfo::None());
        break;
      }
      case IrOpcode::kObjectIsNumber: {
        ProcessInput(VAR_0, 0, UseInfo::AnyTagged());
        SetOutput(VAR_0, NodeOutputInfo::Bool());
        break;
      }
      case IrOpcode::kObjectIsReceiver: {
        ProcessInput(VAR_0, 0, UseInfo::AnyTagged());
        SetOutput(VAR_0, NodeOutputInfo::Bool());
        break;
      }
      case IrOpcode::kObjectIsSmi: {
        ProcessInput(VAR_0, 0, UseInfo::AnyTagged());
        SetOutput(VAR_0, NodeOutputInfo::Bool());
        break;
      }

      /* COMMENT_0 */
      /* COMMENT_53 */
      /* COMMENT_0 */
      case IrOpcode::kLoad: {
        /* COMMENT_54 */
        /* COMMENT_55 */
        LoadRepresentation VAR_18 = LoadRepresentationOf(VAR_0->op());
        ProcessInput(VAR_0, 0, UseInfo::AnyTagged());   /* COMMENT_56 */
        ProcessInput(VAR_0, 1, UseInfo::PointerInt());  /* COMMENT_52 */
        ProcessRemainingInputs(VAR_0, 2);
        SetOutputFromMachineType(VAR_0, VAR_18);
        break;
      }
      case IrOpcode::kStore: {
        /* COMMENT_54 */
        /* COMMENT_55 */
        StoreRepresentation VAR_18 = StoreRepresentationOf(VAR_0->op());
        ProcessInput(VAR_0, 0, UseInfo::AnyTagged());   /* COMMENT_56 */
        ProcessInput(VAR_0, 1, UseInfo::PointerInt());  /* COMMENT_52 */
        ProcessInput(VAR_0, 2,
                     TruncatingUseInfoFromRepresentation(VAR_18.representation()));
        ProcessRemainingInputs(VAR_0, 3);
        SetOutput(VAR_0, NodeOutputInfo::None());
        break;
      }
      case IrOpcode::kWord32Shr:
        /* COMMENT_57 */
        return VisitBinop(VAR_0, UseInfo::TruncatingWord32(),
                          NodeOutputInfo::Uint32());
      case IrOpcode::kWord32And:
      case IrOpcode::kWord32Or:
      case IrOpcode::kWord32Xor:
      case IrOpcode::kWord32Shl:
      case IrOpcode::kWord32Sar:
        /* COMMENT_58 */
        /* COMMENT_59 */
        /* COMMENT_60 */
        return VisitBinop(VAR_0, UseInfo::TruncatingWord32(),
                          NodeOutputInfo::Int32());
      case IrOpcode::kWord32Equal:
        return VisitBinop(VAR_0, UseInfo::TruncatingWord32(),
                          NodeOutputInfo::Bool());

      case IrOpcode::kWord32Clz:
        return VisitUnop(VAR_0, UseInfo::TruncatingWord32(),
                         NodeOutputInfo::Uint32());

      case IrOpcode::kInt32Add:
      case IrOpcode::kInt32Sub:
      case IrOpcode::kInt32Mul:
      case IrOpcode::kInt32MulHigh:
      case IrOpcode::kInt32Div:
      case IrOpcode::kInt32Mod:
        return VisitInt32Binop(VAR_0);
      case IrOpcode::kUint32Div:
      case IrOpcode::kUint32Mod:
      case IrOpcode::kUint32MulHigh:
        return VisitUint32Binop(VAR_0);
      case IrOpcode::kInt32LessThan:
      case IrOpcode::kInt32LessThanOrEqual:
        return VisitInt32Cmp(VAR_0);

      case IrOpcode::kUint32LessThan:
      case IrOpcode::kUint32LessThanOrEqual:
        return VisitUint32Cmp(VAR_0);

      case IrOpcode::kInt64Add:
      case IrOpcode::kInt64Sub:
      case IrOpcode::kInt64Mul:
      case IrOpcode::kInt64Div:
      case IrOpcode::kInt64Mod:
        return VisitInt64Binop(VAR_0);
      case IrOpcode::kInt64LessThan:
      case IrOpcode::kInt64LessThanOrEqual:
        return VisitInt64Cmp(VAR_0);

      case IrOpcode::kUint64LessThan:
        return VisitUint64Cmp(VAR_0);

      case IrOpcode::kUint64Div:
      case IrOpcode::kUint64Mod:
        return VisitUint64Binop(VAR_0);

      case IrOpcode::kWord64And:
      case IrOpcode::kWord64Or:
      case IrOpcode::kWord64Xor:
      case IrOpcode::kWord64Shl:
      case IrOpcode::kWord64Shr:
      case IrOpcode::kWord64Sar:
        return VisitBinop(VAR_0, UseInfo::TruncatingWord64(),
                          NodeOutputInfo::Int64());
      case IrOpcode::kWord64Equal:
        return VisitBinop(VAR_0, UseInfo::TruncatingWord64(),
                          NodeOutputInfo::Bool());

      case IrOpcode::kChangeInt32ToInt64:
        return VisitUnop(
            VAR_0, UseInfo::TruncatingWord32(),
            NodeOutputInfo(MachineRepresentation::kWord64, Type::Signed32()));
      case IrOpcode::kChangeUint32ToUint64:
        return VisitUnop(
            VAR_0, UseInfo::TruncatingWord32(),
            NodeOutputInfo(MachineRepresentation::kWord64, Type::Unsigned32()));
      case IrOpcode::kTruncateFloat64ToFloat32:
        return VisitUnop(VAR_0, UseInfo::Float64(), NodeOutputInfo::Float32());
      case IrOpcode::kTruncateFloat64ToInt32:
        return VisitUnop(VAR_0, UseInfo::Float64(), NodeOutputInfo::Int32());
      case IrOpcode::kTruncateInt64ToInt32:
        /* COMMENT_61 */
        return VisitUnop(VAR_0, UseInfo::Word64TruncatingToWord32(),
                         NodeOutputInfo::Int32());

      case IrOpcode::kChangeFloat32ToFloat64:
        return VisitUnop(VAR_0, UseInfo::Float32(), NodeOutputInfo::Float64());
      case IrOpcode::kChangeInt32ToFloat64:
        return VisitUnop(
            VAR_0, UseInfo::TruncatingWord32(),
            NodeOutputInfo(MachineRepresentation::kFloat64, Type::Signed32()));
      case IrOpcode::kChangeUint32ToFloat64:
        return VisitUnop(VAR_0, UseInfo::TruncatingWord32(),
                         NodeOutputInfo(MachineRepresentation::kFloat64,
                                        Type::Unsigned32()));
      case IrOpcode::kChangeFloat64ToInt32:
        return VisitUnop(VAR_0, UseInfo::Float64TruncatingToWord32(),
                         NodeOutputInfo::Int32());
      case IrOpcode::kChangeFloat64ToUint32:
        return VisitUnop(VAR_0, UseInfo::Float64TruncatingToWord32(),
                         NodeOutputInfo::Uint32());

      case IrOpcode::kFloat64Add:
      case IrOpcode::kFloat64Sub:
      case IrOpcode::kFloat64Mul:
      case IrOpcode::kFloat64Div:
      case IrOpcode::kFloat64Mod:
      case IrOpcode::kFloat64Min:
        return VisitFloat64Binop(VAR_0);
      case IrOpcode::kFloat64Abs:
      case IrOpcode::kFloat64Sqrt:
      case IrOpcode::kFloat64RoundDown:
      case IrOpcode::kFloat64RoundTruncate:
      case IrOpcode::kFloat64RoundTiesAway:
      case IrOpcode::kFloat64RoundUp:
        return VisitUnop(VAR_0, UseInfo::Float64(), NodeOutputInfo::Float64());
      case IrOpcode::kFloat64Equal:
      case IrOpcode::kFloat64LessThan:
      case IrOpcode::kFloat64LessThanOrEqual:
        return VisitFloat64Cmp(VAR_0);
      case IrOpcode::kFloat64ExtractLowWord32:
      case IrOpcode::kFloat64ExtractHighWord32:
        return VisitUnop(VAR_0, UseInfo::Float64(), NodeOutputInfo::Int32());
      case IrOpcode::kFloat64InsertLowWord32:
      case IrOpcode::kFloat64InsertHighWord32:
        return VisitBinop(VAR_0, UseInfo::Float64(), UseInfo::TruncatingWord32(),
                          NodeOutputInfo::Float64());
      case IrOpcode::kLoadStackPointer:
      case IrOpcode::kLoadFramePointer:
      case IrOpcode::kLoadParentFramePointer:
        return VisitLeaf(VAR_0, NodeOutputInfo::Pointer());
      case IrOpcode::kStateValues:
        VisitStateValues(VAR_0);
        break;
      default:
        VisitInputs(VAR_0);
        /* COMMENT_62 */
        SetOutput(VAR_0, NodeOutputInfo::AnyTagged());
        break;
    }
  }",chromium/58ab990aa8c3aeee38e888c1c33404f4b5a14759/simplified-lowering.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -366,10 +366,18 @@
                   NodeOutputInfo(access.machine_type().representation(),
                                  NodeProperties::GetType(node));
             } else {
+              if (access.machine_type().representation() !=
+                  MachineRepresentation::kFloat64) {
+                // TODO(bmeurer): See comment on abort_compilation_.
+                if (lower()) lowering->abort_compilation_ = true;
+              }
               output_info = NodeOutputInfo::Float64();
             }
           }
         } else {
+          // TODO(bmeurer): See comment on abort_compilation_.
+          if (lower()) lowering->abort_compilation_ = true;
+
           // If undefined is not truncated away, we need to have the tagged
           // representation.
           output_info = NodeOutputInfo::AnyTagged();","{'deleted_lines': [], 'added_lines': ['              if (access.machine_type().representation() !=', '                  MachineRepresentation::kFloat64) {', '                // TODO(bmeurer): See comment on abort_compilation_.', '                if (lower()) lowering->abort_compilation_ = true;', '              }', '          // TODO(bmeurer): See comment on abort_compilation_.', '          if (lower()) lowering->abort_compilation_ = true;', '']}",True,"The LoadBuffer implementation in Google V8, as used in Google Chrome before 50.0.2661.75, mishandles data types, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted JavaScript code that triggers an out-of-bounds write operation, related to compiler/pipeline.cc and compiler/simplified-lowering.cc.",8.8,HIGH,2,test,,5
CVE-2016-1653,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,chromium,"[turbofan] Bailout if LoadBuffer typing assumption doesn't hold.

The LoadBuffer operator that is used for asm.js heap access claims to
return only the appropriate typed array type, but out of bounds access
could make it return undefined. So far we tried to ""repair"" the graph
later if we see that our assumption was wrong, and for various reasons
that worked for some time. But now that wrong type information that is
propagated earlier is picked up appropriately and thus we generate wrong
code, i.e. we in the repro case we feed NaN into ChangeFloat64Uint32 and
thus get 2147483648 instead of 0 (with proper JS truncation).

This was always considered a temporary hack until we have a proper
asm.js pipeline, but since we still run asm.js through the generic
JavaScript pipeline, we have to address this now. Quickfix is to just
bailout from the pipeline when we see that the LoadBuffer type was
wrong, i.e. the result of LoadBuffer is not properly truncated and thus
undefined or NaN would be observable.

R=mstarzinger@chromium.org, jarin@chromium.org
BUG=chromium:589792
LOG=y

Review URL: https://codereview.chromium.org/1740123002

Cr-Commit-Position: refs/heads/master@{#34322}
",58ab990aa8c3aeee38e888c1c33404f4b5a14759,https://chromium.googlesource.com/v8/v8/+/58ab990aa8c3aeee38e888c1c33404f4b5a14759,src/compiler/pipeline.cc,Pipeline::GenerateCode,"Handle<Code> Pipeline::GenerateCode() {
ZonePool zone_pool;
base::SmartPointer<PipelineStatistics> pipeline_statistics;
if (FLAG_turbo_stats) {
pipeline_statistics.Reset(new PipelineStatistics(info(), &zone_pool));
pipeline_statistics->BeginPhaseKind(""initializing"");
}
if (FLAG_trace_turbo) {
FILE* json_file = OpenVisualizerLogFile(info(), nullptr, ""json"", ""w+"");
if (json_file != nullptr) {
OFStream json_of(json_file);
Handle<Script> script = info()->script();
base::SmartArrayPointer<char> function_name = info()->GetDebugName();
int pos = info()->shared_info()->start_position();
json_of << ""{\""function\"":\"""" << function_name.get()
<< ""\"", \""sourcePosition\"":"" << pos << "", \""source\"":\"""";
if (info()->has_literal() && !script->IsUndefined() &&
!script->source()->IsUndefined()) {
DisallowHeapAllocation no_allocation;
FunctionLiteral* function = info()->literal();
int start = function->start_position();
int len = function->end_position() - start;
String::SubStringRange source(String::cast(script->source()), start,
len);
for (const auto& c : source) {
json_of << AsEscapedUC16ForJSON(c);
}
}
json_of << ""\"",\n\""phases\"":["";
fclose(json_file);
}
}
PipelineData data(&zone_pool, info(), pipeline_statistics.get());
this->data_ = &data;
BeginPhaseKind(""graph creation"");
if (FLAG_trace_turbo) {
OFStream os(stdout);
os << ""---------------------------------------------------\n""
<< ""Begin compiling method "" << info()->GetDebugName().get()
<< "" using Turbofan"" << std::endl;
TurboCfgFile tcf(isolate());
tcf << AsC1VCompilation(info());
}
data.source_positions()->AddDecorator();
if (FLAG_loop_assignment_analysis) {
Run<LoopAssignmentAnalysisPhase>();
}
if (info()->is_typing_enabled()) {
Run<TypeHintAnalysisPhase>();
}
Run<GraphBuilderPhase>();
if (data.compilation_failed()) return Handle<Code>::null();
RunPrintAndVerify(""Initial untyped"", true);
if (info()->is_osr()) {
Run<OsrDeconstructionPhase>();
RunPrintAndVerify(""OSR deconstruction"", true);
}
Run<InliningPhase>();
RunPrintAndVerify(""Inlined"", true);
Run<EarlyGraphTrimmingPhase>();
RunPrintAndVerify(""Early trimmed"", true);
if (FLAG_print_turbo_replay) {
GraphReplayPrinter::PrintReplay(data.graph());
}
base::SmartPointer<Typer> typer;
if (info()->is_typing_enabled()) {
typer.Reset(new Typer(isolate(), data.graph(),
info()->is_deoptimization_enabled()
? Typer::kDeoptimizationEnabled
: Typer::kNoFlags,
info()->dependencies()));
Run<TyperPhase>(typer.get());
RunPrintAndVerify(""Typed"");
}
BeginPhaseKind(""lowering"");
if (info()->is_typing_enabled()) {
Run<TypedLoweringPhase>();
RunPrintAndVerify(""Lowered typed"");
if (FLAG_turbo_stress_loop_peeling) {
Run<StressLoopPeelingPhase>();
RunPrintAndVerify(""Loop peeled"");
}
if (FLAG_turbo_escape) {
Run<EscapeAnalysisPhase>();
RunPrintAndVerify(""Escape Analysed"");
}
Run<SimplifiedLoweringPhase>();
RunPrintAndVerify(""Lowered simplified"");
Run<BranchEliminationPhase>();
RunPrintAndVerify(""Branch conditions eliminated"");
if (FLAG_turbo_cf_optimization) {
Run<ControlFlowOptimizationPhase>();
RunPrintAndVerify(""Control flow optimized"");
}
Run<ChangeLoweringPhase>();
RunPrintAndVerify(""Lowered changes"", true);
}
Run<GenericLoweringPhase>();
RunPrintAndVerify(""Lowered generic"", true);
Run<LateGraphTrimmingPhase>();
RunPrintAndVerify(""Late trimmed"", true);
BeginPhaseKind(""block building"");
data.source_positions()->RemoveDecorator();
typer.Reset(nullptr);
return ScheduleAndGenerateCode(
Linkage::ComputeIncoming(data.instruction_zone(), info()));
}","Handle<Code> Pipeline::GenerateCode() {
ZonePool VAR_0;
base::SmartPointer<PipelineStatistics> VAR_1;
if (VAR_2) {
VAR_1.Reset(new PipelineStatistics(info(), &VAR_0));
VAR_1->BeginPhaseKind(""initializing"");
}
if (VAR_3) {
FILE* VAR_4 = OpenVisualizerLogFile(info(), nullptr, ""json"", ""w+"");
if (VAR_4 != nullptr) {
OFStream json_of(json_file);
Handle<Script> VAR_5 = info()->script();
base::SmartArrayPointer<char> VAR_6 = info()->GetDebugName();
int VAR_7 = info()->shared_info()->start_position();
VAR_8 << ""{\""function\"":\"""" << VAR_6.get()
<< ""\"", \""sourcePosition\"":"" << VAR_7 << "", \""source\"":\"""";
if (info()->has_literal() && !VAR_5->IsUndefined() &&
!VAR_5->source()->IsUndefined()) {
DisallowHeapAllocation VAR_9;
FunctionLiteral* VAR_10 = info()->literal();
int VAR_11 = VAR_10->start_position();
int VAR_12 = VAR_10->end_position() - VAR_11;
String::SubStringRange VAR_13(String::cast(VAR_5->source()), VAR_11,
VAR_12);
for (const auto& VAR_14 : VAR_13) {
VAR_8 << AsEscapedUC16ForJSON(VAR_14);
}
}
VAR_8 << ""\"",\n\""phases\"":["";
fclose(json_file);
}
}
PipelineData VAR_15(&VAR_0, info(), VAR_1.get());
this->data_ = &VAR_15;
BeginPhaseKind(""graph creation"");
if (VAR_3) {
OFStream os(stdout);
VAR_16 << ""---------------------------------------------------\n""
<< ""Begin compiling method "" << info()->GetDebugName().get()
<< "" using Turbofan"" << std::endl;
TurboCfgFile tcf(isolate());
VAR_17 << AsC1VCompilation(info());
}
VAR_15.source_positions()->AddDecorator();
if (VAR_18) {
VAR_19<LoopAssignmentAnalysisPhase>();
}
if (info()->is_typing_enabled()) {
VAR_19<TypeHintAnalysisPhase>();
}
VAR_19<GraphBuilderPhase>();
if (VAR_15.compilation_failed()) return Handle<Code>::null();
RunPrintAndVerify(""Initial untyped"", true);
if (info()->is_osr()) {
VAR_19<OsrDeconstructionPhase>();
RunPrintAndVerify(""OSR deconstruction"", true);
}
VAR_19<InliningPhase>();
RunPrintAndVerify(""Inlined"", true);
VAR_19<EarlyGraphTrimmingPhase>();
RunPrintAndVerify(""Early trimmed"", true);
if (VAR_20) {
GraphReplayPrinter::PrintReplay(VAR_15.graph());
}
base::SmartPointer<Typer> VAR_21;
if (info()->is_typing_enabled()) {
VAR_21.Reset(new Typer(isolate(), VAR_15.graph(),
info()->is_deoptimization_enabled()
? Typer::kDeoptimizationEnabled
: Typer::kNoFlags,
info()->dependencies()));
VAR_19<TyperPhase>(VAR_21.get());
RunPrintAndVerify(""Typed"");
}
BeginPhaseKind(""lowering"");
if (info()->is_typing_enabled()) {
VAR_19<TypedLoweringPhase>();
RunPrintAndVerify(""Lowered typed"");
if (VAR_22) {
VAR_19<StressLoopPeelingPhase>();
RunPrintAndVerify(""Loop peeled"");
}
if (VAR_23) {
VAR_19<EscapeAnalysisPhase>();
RunPrintAndVerify(""Escape Analysed"");
}
VAR_19<SimplifiedLoweringPhase>();
RunPrintAndVerify(""Lowered simplified"");
VAR_19<BranchEliminationPhase>();
RunPrintAndVerify(""Branch conditions eliminated"");
if (VAR_24) {
VAR_19<ControlFlowOptimizationPhase>();
RunPrintAndVerify(""Control flow optimized"");
}
VAR_19<ChangeLoweringPhase>();
RunPrintAndVerify(""Lowered changes"", true);
}
VAR_19<GenericLoweringPhase>();
RunPrintAndVerify(""Lowered generic"", true);
VAR_19<LateGraphTrimmingPhase>();
RunPrintAndVerify(""Late trimmed"", true);
BeginPhaseKind(""block building"");
VAR_15.source_positions()->RemoveDecorator();
VAR_21.Reset(nullptr);
return ScheduleAndGenerateCode(
Linkage::ComputeIncoming(VAR_15.instruction_zone(), info()));
}",chromium/58ab990aa8c3aeee38e888c1c33404f4b5a14759/pipeline.cc/vul/before/0.json,"Handle<Code> Pipeline::GenerateCode() {
  ZonePool zone_pool;
  base::SmartPointer<PipelineStatistics> pipeline_statistics;

  if (FLAG_turbo_stats) {
    pipeline_statistics.Reset(new PipelineStatistics(info(), &zone_pool));
    pipeline_statistics->BeginPhaseKind(""initializing"");
  }

  if (FLAG_trace_turbo) {
    FILE* json_file = OpenVisualizerLogFile(info(), nullptr, ""json"", ""w+"");
    if (json_file != nullptr) {
      OFStream json_of(json_file);
      Handle<Script> script = info()->script();
      base::SmartArrayPointer<char> function_name = info()->GetDebugName();
      int pos = info()->shared_info()->start_position();
      json_of << ""{\""function\"":\"""" << function_name.get()
              << ""\"", \""sourcePosition\"":"" << pos << "", \""source\"":\"""";
      if (info()->has_literal() && !script->IsUndefined() &&
          !script->source()->IsUndefined()) {
        DisallowHeapAllocation no_allocation;
        FunctionLiteral* function = info()->literal();
        int start = function->start_position();
        int len = function->end_position() - start;
        String::SubStringRange source(String::cast(script->source()), start,
                                      len);
        for (const auto& c : source) {
          json_of << AsEscapedUC16ForJSON(c);
        }
      }
      json_of << ""\"",\n\""phases\"":["";
      fclose(json_file);
    }
  }

  PipelineData data(&zone_pool, info(), pipeline_statistics.get());
  this->data_ = &data;

  BeginPhaseKind(""graph creation"");

  if (FLAG_trace_turbo) {
    OFStream os(stdout);
    os << ""---------------------------------------------------\n""
       << ""Begin compiling method "" << info()->GetDebugName().get()
       << "" using Turbofan"" << std::endl;
    TurboCfgFile tcf(isolate());
    tcf << AsC1VCompilation(info());
  }

  data.source_positions()->AddDecorator();

  if (FLAG_loop_assignment_analysis) {
    Run<LoopAssignmentAnalysisPhase>();
  }

  if (info()->is_typing_enabled()) {
    Run<TypeHintAnalysisPhase>();
  }

  Run<GraphBuilderPhase>();
  if (data.compilation_failed()) return Handle<Code>::null();
  RunPrintAndVerify(""Initial untyped"", true);

  // Perform OSR deconstruction.
  if (info()->is_osr()) {
    Run<OsrDeconstructionPhase>();
    RunPrintAndVerify(""OSR deconstruction"", true);
  }

  // Perform function context specialization and inlining (if enabled).
  Run<InliningPhase>();
  RunPrintAndVerify(""Inlined"", true);

  // Remove dead->live edges from the graph.
  Run<EarlyGraphTrimmingPhase>();
  RunPrintAndVerify(""Early trimmed"", true);

  if (FLAG_print_turbo_replay) {
    // Print a replay of the initial graph.
    GraphReplayPrinter::PrintReplay(data.graph());
  }

  base::SmartPointer<Typer> typer;
  if (info()->is_typing_enabled()) {
    // Type the graph.
    typer.Reset(new Typer(isolate(), data.graph(),
                          info()->is_deoptimization_enabled()
                              ? Typer::kDeoptimizationEnabled
                              : Typer::kNoFlags,
                          info()->dependencies()));
    Run<TyperPhase>(typer.get());
    RunPrintAndVerify(""Typed"");
  }

  BeginPhaseKind(""lowering"");

  if (info()->is_typing_enabled()) {
    // Lower JSOperators where we can determine types.
    Run<TypedLoweringPhase>();
    RunPrintAndVerify(""Lowered typed"");

    if (FLAG_turbo_stress_loop_peeling) {
      Run<StressLoopPeelingPhase>();
      RunPrintAndVerify(""Loop peeled"");
    }

    if (FLAG_turbo_escape) {
      Run<EscapeAnalysisPhase>();
      RunPrintAndVerify(""Escape Analysed"");
    }

    // Lower simplified operators and insert changes.
    Run<SimplifiedLoweringPhase>();
    RunPrintAndVerify(""Lowered simplified"");

    Run<BranchEliminationPhase>();
    RunPrintAndVerify(""Branch conditions eliminated"");

    // Optimize control flow.
    if (FLAG_turbo_cf_optimization) {
      Run<ControlFlowOptimizationPhase>();
      RunPrintAndVerify(""Control flow optimized"");
    }

    // Lower changes that have been inserted before.
    Run<ChangeLoweringPhase>();
    // TODO(jarin, rossberg): Remove UNTYPED once machine typing works.
    RunPrintAndVerify(""Lowered changes"", true);
  }

  // Lower any remaining generic JSOperators.
  Run<GenericLoweringPhase>();
  // TODO(jarin, rossberg): Remove UNTYPED once machine typing works.
  RunPrintAndVerify(""Lowered generic"", true);

  Run<LateGraphTrimmingPhase>();
  // TODO(jarin, rossberg): Remove UNTYPED once machine typing works.
  RunPrintAndVerify(""Late trimmed"", true);

  BeginPhaseKind(""block building"");

  data.source_positions()->RemoveDecorator();

  // Kill the Typer and thereby uninstall the decorator (if any).
  typer.Reset(nullptr);

  // TODO(bmeurer): See comment on SimplifiedLowering::abort_compilation_.
  if (data.compilation_failed()) return Handle<Code>::null();

  return ScheduleAndGenerateCode(
      Linkage::ComputeIncoming(data.instruction_zone(), info()));
}","Handle<Code> Pipeline::GenerateCode() {
  ZonePool VAR_0;
  base::SmartPointer<PipelineStatistics> VAR_1;

  if (VAR_2) {
    VAR_1.Reset(new PipelineStatistics(info(), &VAR_0));
    VAR_1->BeginPhaseKind(""initializing"");
  }

  if (VAR_3) {
    FILE* VAR_4 = OpenVisualizerLogFile(info(), nullptr, ""json"", ""w+"");
    if (VAR_4 != nullptr) {
      OFStream json_of(json_file);
      Handle<Script> VAR_5 = info()->script();
      base::SmartArrayPointer<char> VAR_6 = info()->GetDebugName();
      int VAR_7 = info()->shared_info()->start_position();
      VAR_8 << ""{\""function\"":\"""" << VAR_6.get()
              << ""\"", \""sourcePosition\"":"" << VAR_7 << "", \""source\"":\"""";
      if (info()->has_literal() && !VAR_5->IsUndefined() &&
          !VAR_5->source()->IsUndefined()) {
        DisallowHeapAllocation VAR_9;
        FunctionLiteral* VAR_10 = info()->literal();
        int VAR_11 = VAR_10->start_position();
        int VAR_12 = VAR_10->end_position() - VAR_11;
        String::SubStringRange VAR_13(String::cast(VAR_5->source()), VAR_11,
                                      VAR_12);
        for (const auto& VAR_14 : VAR_13) {
          VAR_8 << AsEscapedUC16ForJSON(VAR_14);
        }
      }
      VAR_8 << ""\"",\n\""phases\"":["";
      fclose(json_file);
    }
  }

  PipelineData VAR_15(&VAR_0, info(), VAR_1.get());
  this->data_ = &VAR_15;

  BeginPhaseKind(""graph creation"");

  if (VAR_3) {
    OFStream os(stdout);
    VAR_16 << ""---------------------------------------------------\n""
       << ""Begin compiling method "" << info()->GetDebugName().get()
       << "" using Turbofan"" << std::endl;
    TurboCfgFile tcf(isolate());
    VAR_17 << AsC1VCompilation(info());
  }

  VAR_15.source_positions()->AddDecorator();

  if (VAR_18) {
    VAR_19<LoopAssignmentAnalysisPhase>();
  }

  if (info()->is_typing_enabled()) {
    VAR_19<TypeHintAnalysisPhase>();
  }

  VAR_19<GraphBuilderPhase>();
  if (VAR_15.compilation_failed()) return Handle<Code>::null();
  RunPrintAndVerify(""Initial untyped"", true);

  /* COMMENT_0 */
  if (info()->is_osr()) {
    VAR_19<OsrDeconstructionPhase>();
    RunPrintAndVerify(""OSR deconstruction"", true);
  }

  /* COMMENT_1 */
  VAR_19<InliningPhase>();
  RunPrintAndVerify(""Inlined"", true);

  /* COMMENT_2 */
  VAR_19<EarlyGraphTrimmingPhase>();
  RunPrintAndVerify(""Early trimmed"", true);

  if (VAR_20) {
    /* COMMENT_3 */
    GraphReplayPrinter::PrintReplay(VAR_15.graph());
  }

  base::SmartPointer<Typer> VAR_21;
  if (info()->is_typing_enabled()) {
    /* COMMENT_4 */
    VAR_21.Reset(new Typer(isolate(), VAR_15.graph(),
                          info()->is_deoptimization_enabled()
                              ? Typer::kDeoptimizationEnabled
                              : Typer::kNoFlags,
                          info()->dependencies()));
    VAR_19<TyperPhase>(VAR_21.get());
    RunPrintAndVerify(""Typed"");
  }

  BeginPhaseKind(""lowering"");

  if (info()->is_typing_enabled()) {
    /* COMMENT_5 */
    VAR_19<TypedLoweringPhase>();
    RunPrintAndVerify(""Lowered typed"");

    if (VAR_22) {
      VAR_19<StressLoopPeelingPhase>();
      RunPrintAndVerify(""Loop peeled"");
    }

    if (VAR_23) {
      VAR_19<EscapeAnalysisPhase>();
      RunPrintAndVerify(""Escape Analysed"");
    }

    /* COMMENT_6 */
    VAR_19<SimplifiedLoweringPhase>();
    RunPrintAndVerify(""Lowered simplified"");

    VAR_19<BranchEliminationPhase>();
    RunPrintAndVerify(""Branch conditions eliminated"");

    /* COMMENT_7 */
    if (VAR_24) {
      VAR_19<ControlFlowOptimizationPhase>();
      RunPrintAndVerify(""Control flow optimized"");
    }

    /* COMMENT_8 */
    VAR_19<ChangeLoweringPhase>();
    /* COMMENT_9 */
    RunPrintAndVerify(""Lowered changes"", true);
  }

  /* COMMENT_10 */
  VAR_19<GenericLoweringPhase>();
  /* COMMENT_9 */
  RunPrintAndVerify(""Lowered generic"", true);

  VAR_19<LateGraphTrimmingPhase>();
  /* COMMENT_9 */
  RunPrintAndVerify(""Late trimmed"", true);

  BeginPhaseKind(""block building"");

  VAR_15.source_positions()->RemoveDecorator();

  /* COMMENT_11 */
  VAR_21.Reset(nullptr);

  /* COMMENT_12 */
  if (VAR_15.compilation_failed()) return Handle<Code>::null();

  return ScheduleAndGenerateCode(
      Linkage::ComputeIncoming(VAR_15.instruction_zone(), info()));
}",chromium/58ab990aa8c3aeee38e888c1c33404f4b5a14759/pipeline.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -144,6 +144,9 @@
   // Kill the Typer and thereby uninstall the decorator (if any).
   typer.Reset(nullptr);
 
+  // TODO(bmeurer): See comment on SimplifiedLowering::abort_compilation_.
+  if (data.compilation_failed()) return Handle<Code>::null();
+
   return ScheduleAndGenerateCode(
       Linkage::ComputeIncoming(data.instruction_zone(), info()));
 }","{'deleted_lines': [], 'added_lines': ['  // TODO(bmeurer): See comment on SimplifiedLowering::abort_compilation_.', '  if (data.compilation_failed()) return Handle<Code>::null();', '']}",True,"The LoadBuffer implementation in Google V8, as used in Google Chrome before 50.0.2661.75, mishandles data types, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted JavaScript code that triggers an out-of-bounds write operation, related to compiler/pipeline.cc and compiler/simplified-lowering.cc.",8.8,HIGH,2,test,,5
CVE-2016-1657,['CWE-254'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,chromium,"Don't focus the location bar in a phishy situation.

There is logic to focus the location bar for editing if the URL is about:blank.
However, if the page transition type is PAGE_TRANSITION_LINK, bypass that logic;
it's not really a blank page. This avoids a phishy edge case with window.open.

BUG=567445

Review URL: https://codereview.chromium.org/1678233003

Cr-Commit-Position: refs/heads/master@{#379396}
",c70cb1fe9303df33b11187d0f5f60d22938e6e63,https://chromium.googlesource.com/chromium/src/+/c70cb1fe9303df33b11187d0f5f60d22938e6e63,content/browser/web_contents/web_contents_impl.cc,WebContentsImpl::FocusLocationBarByDefault,"bool WebContentsImpl::FocusLocationBarByDefault() {
NavigationEntry* entry = controller_.GetVisibleEntry();
if (entry && entry->GetURL() == GURL(url::kAboutBlankURL))
return true;
return delegate_ && delegate_->ShouldFocusLocationBarByDefault(this);
}","bool WebContentsImpl::FocusLocationBarByDefault() {
NavigationEntry* VAR_0 = VAR_1.GetVisibleEntry();
if (VAR_0 && VAR_0->GetURL() == GURL(url::kAboutBlankURL))
return true;
return VAR_2 && VAR_2->ShouldFocusLocationBarByDefault(this);
}",chromium/c70cb1fe9303df33b11187d0f5f60d22938e6e63/web_contents_impl.cc/vul/before/0.json,"bool WebContentsImpl::FocusLocationBarByDefault() {
  // When the browser is started with about:blank as the startup URL, focus
  // the location bar (which will also select its contents) so people can
  // simply begin typing to navigate elsewhere.
  //
  // We need to be careful not to trigger this for anything other than the
  // startup navigation. In particular, if we allow an attacker to open a
  // popup to about:blank, then navigate, focusing the Omnibox will cause the
  // end of the new URL to be scrolled into view instead of the start,
  // allowing the attacker to spoof other URLs. The conditions checked here
  // are all aimed at ensuring no such attacker-controlled navigation can
  // trigger this.
  //
  // Note that we check the pending entry instead of the visible one; for the
  // startup URL case these are the same, but for the attacker-controlled
  // navigation case the visible entry is the committed ""about:blank"" URL and
  // the pending entry is the problematic navigation elsewhere.
  NavigationEntryImpl* entry = controller_.GetPendingEntry();
  if (controller_.IsInitialNavigation() && entry &&
      !entry->is_renderer_initiated() &&
      entry->GetURL() == GURL(url::kAboutBlankURL)) {
    return true;
  }
  return delegate_ && delegate_->ShouldFocusLocationBarByDefault(this);
}","bool WebContentsImpl::FocusLocationBarByDefault() {
  /* COMMENT_0 */
  /* COMMENT_1 */
  /* COMMENT_2 */
  /* COMMENT_3 */
  /* COMMENT_4 */
  /* COMMENT_5 */
  /* COMMENT_6 */
  /* COMMENT_7 */
  /* COMMENT_8 */
  /* COMMENT_9 */
  /* COMMENT_10 */
  /* COMMENT_3 */
  /* COMMENT_11 */
  /* COMMENT_12 */
  /* COMMENT_13 */
  /* COMMENT_14 */
  NavigationEntryImpl* VAR_0 = VAR_1.GetPendingEntry();
  if (VAR_1.IsInitialNavigation() && VAR_0 &&
      !VAR_0->is_renderer_initiated() &&
      VAR_0->GetURL() == GURL(url::kAboutBlankURL)) {
    return true;
  }
  return VAR_2 && VAR_2->ShouldFocusLocationBarByDefault(this);
}",chromium/c70cb1fe9303df33b11187d0f5f60d22938e6e63/web_contents_impl.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,25 @@
 bool WebContentsImpl::FocusLocationBarByDefault() {
-  NavigationEntry* entry = controller_.GetVisibleEntry();
-  if (entry && entry->GetURL() == GURL(url::kAboutBlankURL))
+  // When the browser is started with about:blank as the startup URL, focus
+  // the location bar (which will also select its contents) so people can
+  // simply begin typing to navigate elsewhere.
+  //
+  // We need to be careful not to trigger this for anything other than the
+  // startup navigation. In particular, if we allow an attacker to open a
+  // popup to about:blank, then navigate, focusing the Omnibox will cause the
+  // end of the new URL to be scrolled into view instead of the start,
+  // allowing the attacker to spoof other URLs. The conditions checked here
+  // are all aimed at ensuring no such attacker-controlled navigation can
+  // trigger this.
+  //
+  // Note that we check the pending entry instead of the visible one; for the
+  // startup URL case these are the same, but for the attacker-controlled
+  // navigation case the visible entry is the committed ""about:blank"" URL and
+  // the pending entry is the problematic navigation elsewhere.
+  NavigationEntryImpl* entry = controller_.GetPendingEntry();
+  if (controller_.IsInitialNavigation() && entry &&
+      !entry->is_renderer_initiated() &&
+      entry->GetURL() == GURL(url::kAboutBlankURL)) {
     return true;
+  }
   return delegate_ && delegate_->ShouldFocusLocationBarByDefault(this);
 }","{'deleted_lines': ['  NavigationEntry* entry = controller_.GetVisibleEntry();', '  if (entry && entry->GetURL() == GURL(url::kAboutBlankURL))'], 'added_lines': ['  // When the browser is started with about:blank as the startup URL, focus', '  // the location bar (which will also select its contents) so people can', '  // simply begin typing to navigate elsewhere.', '  //', '  // We need to be careful not to trigger this for anything other than the', '  // startup navigation. In particular, if we allow an attacker to open a', '  // popup to about:blank, then navigate, focusing the Omnibox will cause the', '  // end of the new URL to be scrolled into view instead of the start,', '  // allowing the attacker to spoof other URLs. The conditions checked here', '  // are all aimed at ensuring no such attacker-controlled navigation can', '  // trigger this.', '  //', '  // Note that we check the pending entry instead of the visible one; for the', '  // startup URL case these are the same, but for the attacker-controlled', '  // navigation case the visible entry is the committed ""about:blank"" URL and', '  // the pending entry is the problematic navigation elsewhere.', '  NavigationEntryImpl* entry = controller_.GetPendingEntry();', '  if (controller_.IsInitialNavigation() && entry &&', '      !entry->is_renderer_initiated() &&', '      entry->GetURL() == GURL(url::kAboutBlankURL)) {', '  }']}",True,"The WebContentsImpl::FocusLocationBarByDefault function in content/browser/web_contents/web_contents_impl.cc in Google Chrome before 50.0.2661.75 mishandles focus for certain about:blank pages, which allows remote attackers to spoof the address bar via a crafted URL.",4.3,MEDIUM,1,test,,5
CVE-2016-2106,['CWE-189'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,openssl,"
Fix encrypt overflow

An overflow can occur in the EVP_EncryptUpdate function. If an attacker is
able to supply very large amounts of input data after a previous call to
EVP_EncryptUpdate with a partial block then a length check can overflow
resulting in a heap corruption.

Following an analysis of all OpenSSL internal usage of the
EVP_EncryptUpdate function all usage is one of two forms.

The first form is like this:
EVP_EncryptInit()
EVP_EncryptUpdate()

i.e. where the EVP_EncryptUpdate() call is known to be the first called
function after an EVP_EncryptInit(), and therefore that specific call
must be safe.

The second form is where the length passed to EVP_EncryptUpdate() can be
seen from the code to be some small value and therefore there is no
possibility of an overflow.

Since all instances are one of these two forms, I believe that there can
be no overflows in internal code due to this problem.

It should be noted that EVP_DecryptUpdate() can call EVP_EncryptUpdate()
in certain code paths. Also EVP_CipherUpdate() is a synonym for
EVP_EncryptUpdate(). Therefore I have checked all instances of these
calls too, and came to the same conclusion, i.e. there are no instances
in internal usage where an overflow could occur.

This could still represent a security issue for end user code that calls
this function directly.

CVE-2016-2106

Issue reported by Guido Vranken.

Reviewed-by: Tim Hudson <tjh@openssl.org>
",3f3582139fbb259a1c3cbb0a25236500a409bf26,https://git.openssl.org/?p=openssl.git;a=commit;h=3f3582139fbb259a1c3cbb0a25236500a409bf26,crypto/evp/evp_enc.c,EVP_EncryptUpdate,"int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
const unsigned char *in, int inl)
{
int i, j, bl;
if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {
i = ctx->cipher->do_cipher(ctx, out, in, inl);
if (i < 0)
return 0;
else
*outl = i;
return 1;
}
if (inl <= 0) {
*outl = 0;
return inl == 0;
}
if (ctx->buf_len == 0 && (inl & (ctx->block_mask)) == 0) {
if (ctx->cipher->do_cipher(ctx, out, in, inl)) {
*outl = inl;
return 1;
} else {
*outl = 0;
return 0;
}
}
i = ctx->buf_len;
bl = ctx->cipher->block_size;
OPENSSL_assert(bl <= (int)sizeof(ctx->buf));
if (i != 0) {
if (i + inl < bl) {
memcpy(&(ctx->buf[i]), in, inl);
ctx->buf_len += inl;
*outl = 0;
return 1;
} else {
j = bl - i;
memcpy(&(ctx->buf[i]), in, j);
if (!ctx->cipher->do_cipher(ctx, out, ctx->buf, bl))
return 0;
inl -= j;
in += j;
out += bl;
*outl = bl;
}
} else
*outl = 0;
i = inl & (bl - 1);
inl -= i;
if (inl > 0) {
if (!ctx->cipher->do_cipher(ctx, out, in, inl))
return 0;
*outl += inl;
}
if (i != 0)
memcpy(ctx->buf, &(in[inl]), i);
ctx->buf_len = i;
return 1;
}","int EVP_EncryptUpdate(EVP_CIPHER_CTX *VAR_0, unsigned char *VAR_1, int *VAR_2,
const unsigned char *VAR_3, int VAR_4)
{
int VAR_5, VAR_6, VAR_7;
if (VAR_0->cipher->flags & VAR_8) {
VAR_5 = VAR_0->cipher->do_cipher(VAR_0, VAR_1, VAR_3, VAR_4);
if (VAR_5 < 0)
return 0;
else
*VAR_2 = VAR_5;
return 1;
}
if (VAR_4 <= 0) {
*VAR_2 = 0;
return VAR_4 == 0;
}
if (VAR_0->buf_len == 0 && (VAR_4 & (VAR_0->block_mask)) == 0) {
if (VAR_0->cipher->do_cipher(VAR_0, VAR_1, VAR_3, VAR_4)) {
*VAR_2 = VAR_4;
return 1;
} else {
*VAR_2 = 0;
return 0;
}
}
VAR_5 = VAR_0->buf_len;
VAR_7 = VAR_0->cipher->block_size;
OPENSSL_assert(VAR_7 <= (int)sizeof(VAR_0->buf));
if (VAR_5 != 0) {
if (VAR_5 + VAR_4 < VAR_7) {
memcpy(&(VAR_0->buf[VAR_5]), VAR_3, VAR_4);
VAR_0->buf_len += VAR_4;
*VAR_2 = 0;
return 1;
} else {
VAR_6 = VAR_7 - VAR_5;
memcpy(&(VAR_0->buf[VAR_5]), VAR_3, VAR_6);
if (!VAR_0->cipher->do_cipher(VAR_0, VAR_1, VAR_0->buf, VAR_7))
return 0;
VAR_4 -= VAR_6;
VAR_3 += VAR_6;
VAR_1 += VAR_7;
*VAR_2 = VAR_7;
}
} else
*VAR_2 = 0;
VAR_5 = VAR_4 & (VAR_7 - 1);
VAR_4 -= VAR_5;
if (VAR_4 > 0) {
if (!VAR_0->cipher->do_cipher(VAR_0, VAR_1, VAR_3, VAR_4))
return 0;
*VAR_2 += VAR_4;
}
if (VAR_5 != 0)
memcpy(VAR_0->buf, &(VAR_3[VAR_4]), VAR_5);
VAR_0->buf_len = VAR_5;
return 1;
}",openssl/3f3582139fbb259a1c3cbb0a25236500a409bf26/evp_enc.c/vul/before/0.json,"int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
                      const unsigned char *in, int inl)
{
    int i, j, bl;

    if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {
        i = ctx->cipher->do_cipher(ctx, out, in, inl);
        if (i < 0)
            return 0;
        else
            *outl = i;
        return 1;
    }

    if (inl <= 0) {
        *outl = 0;
        return inl == 0;
    }

    if (ctx->buf_len == 0 && (inl & (ctx->block_mask)) == 0) {
        if (ctx->cipher->do_cipher(ctx, out, in, inl)) {
            *outl = inl;
            return 1;
        } else {
            *outl = 0;
            return 0;
        }
    }
    i = ctx->buf_len;
    bl = ctx->cipher->block_size;
    OPENSSL_assert(bl <= (int)sizeof(ctx->buf));
    if (i != 0) {
        if (bl - i > inl) {
            memcpy(&(ctx->buf[i]), in, inl);
            ctx->buf_len += inl;
            *outl = 0;
            return 1;
        } else {
            j = bl - i;
            memcpy(&(ctx->buf[i]), in, j);
            if (!ctx->cipher->do_cipher(ctx, out, ctx->buf, bl))
                return 0;
            inl -= j;
            in += j;
            out += bl;
            *outl = bl;
        }
    } else
        *outl = 0;
    i = inl & (bl - 1);
    inl -= i;
    if (inl > 0) {
        if (!ctx->cipher->do_cipher(ctx, out, in, inl))
            return 0;
        *outl += inl;
    }

    if (i != 0)
        memcpy(ctx->buf, &(in[inl]), i);
    ctx->buf_len = i;
    return 1;
}","int EVP_EncryptUpdate(EVP_CIPHER_CTX *VAR_0, unsigned char *VAR_1, int *VAR_2,
                      const unsigned char *VAR_3, int VAR_4)
{
    int VAR_5, VAR_6, VAR_7;

    if (VAR_0->cipher->flags & VAR_8) {
        VAR_5 = VAR_0->cipher->do_cipher(VAR_0, VAR_1, VAR_3, VAR_4);
        if (VAR_5 < 0)
            return 0;
        else
            *VAR_2 = VAR_5;
        return 1;
    }

    if (VAR_4 <= 0) {
        *VAR_2 = 0;
        return VAR_4 == 0;
    }

    if (VAR_0->buf_len == 0 && (VAR_4 & (VAR_0->block_mask)) == 0) {
        if (VAR_0->cipher->do_cipher(VAR_0, VAR_1, VAR_3, VAR_4)) {
            *VAR_2 = VAR_4;
            return 1;
        } else {
            *VAR_2 = 0;
            return 0;
        }
    }
    VAR_5 = VAR_0->buf_len;
    VAR_7 = VAR_0->cipher->block_size;
    OPENSSL_assert(VAR_7 <= (int)sizeof(VAR_0->buf));
    if (VAR_5 != 0) {
        if (VAR_7 - VAR_5 > VAR_4) {
            memcpy(&(VAR_0->buf[VAR_5]), VAR_3, VAR_4);
            VAR_0->buf_len += VAR_4;
            *VAR_2 = 0;
            return 1;
        } else {
            VAR_6 = VAR_7 - VAR_5;
            memcpy(&(VAR_0->buf[VAR_5]), VAR_3, VAR_6);
            if (!VAR_0->cipher->do_cipher(VAR_0, VAR_1, VAR_0->buf, VAR_7))
                return 0;
            VAR_4 -= VAR_6;
            VAR_3 += VAR_6;
            VAR_1 += VAR_7;
            *VAR_2 = VAR_7;
        }
    } else
        *VAR_2 = 0;
    VAR_5 = VAR_4 & (VAR_7 - 1);
    VAR_4 -= VAR_5;
    if (VAR_4 > 0) {
        if (!VAR_0->cipher->do_cipher(VAR_0, VAR_1, VAR_3, VAR_4))
            return 0;
        *VAR_2 += VAR_4;
    }

    if (VAR_5 != 0)
        memcpy(VAR_0->buf, &(VAR_3[VAR_4]), VAR_5);
    VAR_0->buf_len = VAR_5;
    return 1;
}",openssl/3f3582139fbb259a1c3cbb0a25236500a409bf26/evp_enc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -30,7 +30,7 @@
     bl = ctx->cipher->block_size;
     OPENSSL_assert(bl <= (int)sizeof(ctx->buf));
     if (i != 0) {
-        if (i + inl < bl) {
+        if (bl - i > inl) {
             memcpy(&(ctx->buf[i]), in, inl);
             ctx->buf_len += inl;
             *outl = 0;","{'deleted_lines': ['        if (i + inl < bl) {'], 'added_lines': ['        if (bl - i > inl) {']}",True,Integer overflow in the EVP_EncryptUpdate function in crypto/evp/evp_enc.c in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h allows remote attackers to cause a denial of service (heap memory corruption) via a large amount of data.,7.5,HIGH,2,test,,5
CVE-2016-2430,['CWE-264'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"Don't demangle symbol names.

Bug: http://b/27299236
Change-Id: I26ef47f80d4d6048a316ba51e83365ff65d70439
",ad54cfed4516292654c997910839153264ae00a0,https://android.googlesource.com/platform/system/core/+/ad54cfed4516292654c997910839153264ae00a0,libbacktrace/Backtrace.cpp,Backtrace::GetFunctionName,"std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
std::string func_name = GetFunctionNameRaw(pc, offset);
if (!func_name.empty()) {
#if defined(__APPLE__)
if (func_name[0] != '_') {
return func_name;
}
#endif
char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);
if (name) {
func_name = name;
free(name);
}
}
return func_name;
}","std::string Backtrace::GetFunctionName(uintptr_t VAR_0, uintptr_t* VAR_1) {
std::string VAR_2 = GetFunctionNameRaw(VAR_0, VAR_1);
if (!VAR_2.empty()) {
#if defined(VAR_3)
if (VAR_2[0] != '_') {
return VAR_2;
}
#endif
char* VAR_4 = __cxa_demangle(VAR_2.c_str(), 0, 0, 0);
if (VAR_4) {
VAR_2 = VAR_4;
free(VAR_4);
}
}
return VAR_2;
}",android/ad54cfed4516292654c997910839153264ae00a0/Backtrace.cpp/vul/before/0.json,"std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
  std::string func_name = GetFunctionNameRaw(pc, offset);
  return func_name;
}","std::string Backtrace::GetFunctionName(uintptr_t VAR_0, uintptr_t* VAR_1) {
  std::string VAR_2 = GetFunctionNameRaw(VAR_0, VAR_1);
  return VAR_2;
}",android/ad54cfed4516292654c997910839153264ae00a0/Backtrace.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,17 +1,4 @@
 std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
-  if (!func_name.empty()) {
-#if defined(__APPLE__)
-    // Mac OS' __cxa_demangle demangles ""f"" as ""float""; last tested on 10.7.
-    if (func_name[0] != '_') {
-      return func_name;
-    }
-#endif
-    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);
-    if (name) {
-      func_name = name;
-      free(name);
-    }
-  }
   return func_name;
 }","{'deleted_lines': ['  if (!func_name.empty()) {', '#if defined(__APPLE__)', '    // Mac OS\' __cxa_demangle demangles ""f"" as ""float""; last tested on 10.7.', ""    if (func_name[0] != '_') {"", '      return func_name;', '    }', '#endif', '    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);', '    if (name) {', '      func_name = name;', '      free(name);', '    }', '  }'], 'added_lines': []}",True,"libbacktrace/Backtrace.cpp in debuggerd in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 allows attackers to gain privileges via an application containing a crafted symbol name, aka internal bug 27299236.",7.8,HIGH,2,test,,5
CVE-2016-1671,['CWE-22'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,chromium,"FileURLToFilePath:  Don't unescape '/' and '\\'.

GURL leaves these escaped, and unescaping them in paths changes the
meaning of the path.

Added two values to the UnescapeRule enumeration:
PATH_SEPARATORS and URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS.

In followup CLs, I intend to replace all uses of URL_SPECIAL_CHARS,
in favor of one or both the two new values, and eventually remove
the value, as it's easily to use in an unsafe manner.

BUG=586657

Review URL: https://codereview.chromium.org/1704163003

Cr-Commit-Position: refs/heads/master@{#377013}
",30408ae67a9f6aea074b2883ba861613f52bd246,https://chromium.googlesource.com/chromium/src/+/30408ae67a9f6aea074b2883ba861613f52bd246,net/base/filename_util.cc,FileURLToFilePath,"bool FileURLToFilePath(const GURL& url, base::FilePath* file_path) {
*file_path = base::FilePath();
base::FilePath::StringType& file_path_str =
const_cast<base::FilePath::StringType&>(file_path->value());
file_path_str.clear();
if (!url.is_valid())
return false;
#if defined(OS_WIN)
std::string path;
std::string host = url.host();
if (host.empty()) {
path = url.path();
size_t first_non_slash = path.find_first_not_of(""/\\"");
if (first_non_slash != std::string::npos && first_non_slash > 0)
path.erase(0, first_non_slash);
} else {
path = ""\\\\"";
path.append(host);
path.append(url.path());
}
std::replace(path.begin(), path.end(), '/', '\\');
#else            std::string path = url.path();
#endif  
if (path.empty())
return false;
path = UnescapeURLComponent(
path, UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS);
#if defined(OS_WIN)
if (base::IsStringUTF8(path)) {
file_path_str.assign(base::UTF8ToWide(path));
} else {
file_path_str = base::SysNativeMBToWide(path);
}
#else      std::string new_path;
do {
new_path = path;
base::ReplaceSubstringsAfterOffset(&new_path, 0, ""    path.swap(new_path);
} while (new_path != path);
file_path_str.assign(path);
#endif  
return !file_path_str.empty();
}","bool FileURLToFilePath(const GURL& VAR_0, base::FilePath* VAR_1) {
*VAR_1 = base::FilePath();
base::FilePath::StringType& VAR_2 =
VAR_3<base::FilePath::StringType&>(VAR_1->value());
VAR_2.clear();
if (!VAR_0.is_valid())
return false;
#if defined(VAR_4)
std::string VAR_5;
std::string VAR_6 = VAR_0.host();
if (VAR_6.empty()) {
VAR_5 = VAR_0.path();
size_t VAR_7 = VAR_5.find_first_not_of(""/\\"");
if (VAR_7 != std::string::npos && VAR_7 > 0)
VAR_5.erase(0, VAR_7);
} else {
VAR_5 = ""\\\\"";
VAR_5.append(VAR_6);
VAR_5.append(VAR_0.path());
}
std::replace(VAR_5.begin(), VAR_5.end(), '/', '\\');
#else  
std::string VAR_5 = VAR_0.path();
#endif  
if (VAR_5.empty())
return false;
VAR_5 = UnescapeURLComponent(
VAR_5, UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS);
#if defined(VAR_4)
if (base::IsStringUTF8(VAR_5)) {
VAR_2.assign(base::UTF8ToWide(VAR_5));
} else {
VAR_2 = base::SysNativeMBToWide(VAR_5);
}
#else  
std::string VAR_8;
do {
VAR_8 = VAR_5;
base::ReplaceSubstringsAfterOffset(&VAR_8, 0, ""//"", ""/"");
VAR_5.swap(VAR_8);
} while (VAR_8 != VAR_5);
VAR_2.assign(VAR_5);
#endif  
return !VAR_2.empty();
}",chromium/30408ae67a9f6aea074b2883ba861613f52bd246/filename_util.cc/vul/before/0.json,"bool FileURLToFilePath(const GURL& url, base::FilePath* file_path) {
  *file_path = base::FilePath();
  base::FilePath::StringType& file_path_str =
      const_cast<base::FilePath::StringType&>(file_path->value());
  file_path_str.clear();

  if (!url.is_valid())
    return false;

#if defined(OS_WIN)
  std::string path;
  std::string host = url.host();
  if (host.empty()) {
    // URL contains no host, the path is the filename. In this case, the path
    // will probably be preceeded with a slash, as in ""/C:/foo.txt"", so we
    // trim out that here.
    path = url.path();
    size_t first_non_slash = path.find_first_not_of(""/\\"");
    if (first_non_slash != std::string::npos && first_non_slash > 0)
      path.erase(0, first_non_slash);
  } else {
    // URL contains a host: this means it's UNC. We keep the preceeding slash
    // on the path.
    path = ""\\\\"";
    path.append(host);
    path.append(url.path());
  }
  std::replace(path.begin(), path.end(), '/', '\\');
#else  // defined(OS_WIN)
  // Firefox seems to ignore the ""host"" of a file url if there is one. That is,
  // file://foo/bar.txt maps to /bar.txt.
  // TODO(dhg): This should probably take into account UNCs which could
  // include a hostname other than localhost or blank
  std::string path = url.path();
#endif  // !defined(OS_WIN)

  if (path.empty())
    return false;

  // GURL stores strings as percent-encoded 8-bit, this will undo if possible.
  path = UnescapeURLComponent(
      path, UnescapeRule::SPACES |
                UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS);

#if defined(OS_WIN)
  if (base::IsStringUTF8(path)) {
    file_path_str.assign(base::UTF8ToWide(path));
    // We used to try too hard and see if |path| made up entirely of
    // the 1st 256 characters in the Unicode was a zero-extended UTF-16.
    // If so, we converted it to 'Latin-1' and checked if the result was UTF-8.
    // If the check passed, we converted the result to UTF-8.
    // Otherwise, we treated the result as the native OS encoding.
    // However, that led to http://crbug.com/4619 and http://crbug.com/14153
  } else {
    // Not UTF-8, assume encoding is native codepage and we're done. We know we
    // are giving the conversion function a nonempty string, and it may fail if
    // the given string is not in the current encoding and give us an empty
    // string back. We detect this and report failure.
    file_path_str = base::SysNativeMBToWide(path);
  }
#else  // defined(OS_WIN)
  // Collapse multiple path slashes into a single path slash.
  std::string new_path;
  do {
    new_path = path;
    base::ReplaceSubstringsAfterOffset(&new_path, 0, ""//"", ""/"");
    path.swap(new_path);
  } while (new_path != path);

  file_path_str.assign(path);
#endif  // !defined(OS_WIN)

  return !file_path_str.empty();
}","bool FileURLToFilePath(const GURL& VAR_0, base::FilePath* VAR_1) {
  *VAR_1 = base::FilePath();
  base::FilePath::StringType& VAR_2 =
      VAR_3<base::FilePath::StringType&>(VAR_1->value());
  VAR_2.clear();

  if (!VAR_0.is_valid())
    return false;

#if defined(VAR_4)
  std::string VAR_5;
  std::string VAR_6 = VAR_0.host();
  if (VAR_6.empty()) {
    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    VAR_5 = VAR_0.path();
    size_t VAR_7 = VAR_5.find_first_not_of(""/\\"");
    if (VAR_7 != std::string::npos && VAR_7 > 0)
      VAR_5.erase(0, VAR_7);
  } else {
    /* COMMENT_3 */
    /* COMMENT_4 */
    VAR_5 = ""\\\\"";
    VAR_5.append(VAR_6);
    VAR_5.append(VAR_0.path());
  }
  std::replace(VAR_5.begin(), VAR_5.end(), '/', '\\');
#else  /* COMMENT_5 */
  /* COMMENT_6 */
  /* COMMENT_7 */
  /* COMMENT_8 */
  /* COMMENT_9 */
  std::string VAR_5 = VAR_0.path();
#endif  /* COMMENT_10 */

  if (VAR_5.empty())
    return false;

  /* COMMENT_11 */
  VAR_5 = UnescapeURLComponent(
      VAR_5, UnescapeRule::SPACES |
                UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS);

#if defined(VAR_4)
  if (base::IsStringUTF8(VAR_5)) {
    VAR_2.assign(base::UTF8ToWide(VAR_5));
    /* COMMENT_12 */
    /* COMMENT_13 */
    /* COMMENT_14 */
    /* COMMENT_15 */
    /* COMMENT_16 */
    /* COMMENT_17 */
  } else {
    /* COMMENT_18 */
    /* COMMENT_19 */
    /* COMMENT_20 */
    /* COMMENT_21 */
    VAR_2 = base::SysNativeMBToWide(VAR_5);
  }
#else  /* COMMENT_5 */
  /* COMMENT_22 */
  std::string VAR_8;
  do {
    VAR_8 = VAR_5;
    base::ReplaceSubstringsAfterOffset(&VAR_8, 0, ""//"", ""/"");
    VAR_5.swap(VAR_8);
  } while (VAR_8 != VAR_5);

  VAR_2.assign(VAR_5);
#endif  /* COMMENT_10 */

  return !VAR_2.empty();
}",chromium/30408ae67a9f6aea074b2883ba861613f52bd246/filename_util.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -39,7 +39,8 @@
 
   // GURL stores strings as percent-encoded 8-bit, this will undo if possible.
   path = UnescapeURLComponent(
-      path, UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS);
+      path, UnescapeRule::SPACES |
+                UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS);
 
 #if defined(OS_WIN)
   if (base::IsStringUTF8(path)) {","{'deleted_lines': ['      path, UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS);'], 'added_lines': ['      path, UnescapeRule::SPACES |', '                UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS);']}",True,"Google Chrome before 50.0.2661.102 on Android mishandles / (slash) and \ (backslash) characters, which allows attackers to conduct directory traversal attacks via a file: URL, related to net/base/escape.cc and net/base/filename_util.cc.",8.1,HIGH,2,test,,5
CVE-2016-1671,['CWE-22'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,chromium,"FileURLToFilePath:  Don't unescape '/' and '\\'.

GURL leaves these escaped, and unescaping them in paths changes the
meaning of the path.

Added two values to the UnescapeRule enumeration:
PATH_SEPARATORS and URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS.

In followup CLs, I intend to replace all uses of URL_SPECIAL_CHARS,
in favor of one or both the two new values, and eventually remove
the value, as it's easily to use in an unsafe manner.

BUG=586657

Review URL: https://codereview.chromium.org/1704163003

Cr-Commit-Position: refs/heads/master@{#377013}
",30408ae67a9f6aea074b2883ba861613f52bd246,https://chromium.googlesource.com/chromium/src/+/30408ae67a9f6aea074b2883ba861613f52bd246,net/base/escape.cc,UnescapeURLWithAdjustmentsImpl,"STR UnescapeURLWithAdjustmentsImpl(
const STR& escaped_text,
UnescapeRule::Type rules,
base::OffsetAdjuster::Adjustments* adjustments) {
if (adjustments)
adjustments->clear();
if (rules == UnescapeRule::NONE)
return escaped_text;
STR result;
result.reserve(escaped_text.length());
for (size_t i = 0, max = escaped_text.size(); i < max; ++i) {
if (static_cast<unsigned char>(escaped_text[i]) >= 128) {
result.push_back(escaped_text[i]);
continue;
}
unsigned char first_byte;
if (UnescapeUnsignedCharAtIndex(escaped_text, i, &first_byte)) {
if (!(rules & UnescapeRule::SPOOFING_AND_CONTROL_CHARS)) {
if (HasArabicLanguageMarkAtIndex(escaped_text, first_byte, i)) {
result.append(escaped_text, i, 6);
i += 5;
continue;
}
if (HasThreeByteBidiControlCharAtIndex(escaped_text, first_byte, i)) {
result.append(escaped_text, i, 9);
i += 8;
continue;
}
if (HasFourByteBannedCharAtIndex(escaped_text, first_byte, i)) {
result.append(escaped_text, i, 12);
i += 11;
continue;
}
}
if (first_byte >= 0x80 ||                      (kUrlUnescape[first_byte] ||
(first_byte == ' ' && (rules & UnescapeRule::SPACES)) ||
(first_byte > ' ' && (rules & UnescapeRule::URL_SPECIAL_CHARS)) ||
(first_byte < ' ' &&
(rules & UnescapeRule::SPOOFING_AND_CONTROL_CHARS)))) {
if (adjustments)
adjustments->push_back(base::OffsetAdjuster::Adjustment(i, 3, 1));
result.push_back(first_byte);
i += 2;
} else {
result.push_back('%');
}
} else if ((rules & UnescapeRule::REPLACE_PLUS_WITH_SPACE) &&
escaped_text[i] == '+') {
result.push_back(' ');
} else {
result.push_back(escaped_text[i]);
}
}
return result;
}","STR UnescapeURLWithAdjustmentsImpl(
const STR& VAR_0,
UnescapeRule::Type VAR_1,
base::OffsetAdjuster::Adjustments* VAR_2) {
if (VAR_2)
VAR_2->clear();
if (VAR_1 == UnescapeRule::NONE)
return VAR_0;
STR VAR_3;
VAR_3.reserve(VAR_0.length());
for (size_t VAR_4 = 0, VAR_5 = VAR_0.size(); VAR_4 < VAR_5; ++VAR_4) {
if (VAR_6<unsigned char>(VAR_0[VAR_4]) >= 128) {
VAR_3.push_back(VAR_0[VAR_4]);
continue;
}
unsigned char VAR_7;
if (UnescapeUnsignedCharAtIndex(VAR_0, VAR_4, &VAR_7)) {
if (!(VAR_1 & UnescapeRule::SPOOFING_AND_CONTROL_CHARS)) {
if (HasArabicLanguageMarkAtIndex(VAR_0, VAR_7, VAR_4)) {
VAR_3.append(VAR_0, VAR_4, 6);
VAR_4 += 5;
continue;
}
if (HasThreeByteBidiControlCharAtIndex(VAR_0, VAR_7, VAR_4)) {
VAR_3.append(VAR_0, VAR_4, 9);
VAR_4 += 8;
continue;
}
if (HasFourByteBannedCharAtIndex(VAR_0, VAR_7, VAR_4)) {
VAR_3.append(VAR_0, VAR_4, 12);
VAR_4 += 11;
continue;
}
}
if (VAR_7 >= 0x80 ||  
(VAR_8[VAR_7] ||
(VAR_7 == ' ' && (VAR_1 & UnescapeRule::SPACES)) ||
(VAR_7 > ' ' && (VAR_1 & UnescapeRule::URL_SPECIAL_CHARS)) ||
(VAR_7 < ' ' &&
(VAR_1 & UnescapeRule::SPOOFING_AND_CONTROL_CHARS)))) {
if (VAR_2)
VAR_2->push_back(base::OffsetAdjuster::Adjustment(VAR_4, 3, 1));
VAR_3.push_back(VAR_7);
VAR_4 += 2;
} else {
VAR_3.push_back('%');
}
} else if ((VAR_1 & UnescapeRule::REPLACE_PLUS_WITH_SPACE) &&
VAR_0[VAR_4] == '+') {
VAR_3.push_back(' ');
} else {
VAR_3.push_back(VAR_0[VAR_4]);
}
}
return VAR_3;
}",chromium/30408ae67a9f6aea074b2883ba861613f52bd246/escape.cc/vul/before/0.json,"STR UnescapeURLWithAdjustmentsImpl(
    const STR& escaped_text,
    UnescapeRule::Type rules,
    base::OffsetAdjuster::Adjustments* adjustments) {
  if (adjustments)
    adjustments->clear();
  // Do not unescape anything, return the |escaped_text| text.
  if (rules == UnescapeRule::NONE)
    return escaped_text;

  // The output of the unescaping is always smaller than the input, so we can
  // reserve the input size to make sure we have enough buffer and don't have
  // to allocate in the loop below.
  STR result;
  result.reserve(escaped_text.length());

  // Locations of adjusted text.
  for (size_t i = 0, max = escaped_text.size(); i < max; ++i) {
    if (static_cast<unsigned char>(escaped_text[i]) >= 128) {
      // Non ASCII character, append as is.
      result.push_back(escaped_text[i]);
      continue;
    }

    unsigned char first_byte;
    if (UnescapeUnsignedCharAtIndex(escaped_text, i, &first_byte)) {
      // Per http://tools.ietf.org/html/rfc3987#section-4.1, the following BiDi
      // control characters are not allowed to appear unescaped in URLs:
      //
      // U+200E LEFT-TO-RIGHT MARK         (%E2%80%8E)
      // U+200F RIGHT-TO-LEFT MARK         (%E2%80%8F)
      // U+202A LEFT-TO-RIGHT EMBEDDING    (%E2%80%AA)
      // U+202B RIGHT-TO-LEFT EMBEDDING    (%E2%80%AB)
      // U+202C POP DIRECTIONAL FORMATTING (%E2%80%AC)
      // U+202D LEFT-TO-RIGHT OVERRIDE     (%E2%80%AD)
      // U+202E RIGHT-TO-LEFT OVERRIDE     (%E2%80%AE)
      //
      // Additionally, the Unicode Technical Report (TR9) as referenced by RFC
      // 3987 above has since added some new BiDi control characters.
      // http://www.unicode.org/reports/tr9
      //
      // U+061C ARABIC LETTER MARK         (%D8%9C)
      // U+2066 LEFT-TO-RIGHT ISOLATE      (%E2%81%A6)
      // U+2067 RIGHT-TO-LEFT ISOLATE      (%E2%81%A7)
      // U+2068 FIRST STRONG ISOLATE       (%E2%81%A8)
      // U+2069 POP DIRECTIONAL ISOLATE    (%E2%81%A9)
      //
      // The following spoofable characters are also banned, because they could
      // be used to imitate parts of a web browser's UI.
      //
      // U+1F50F LOCK WITH INK PEN         (%F0%9F%94%8F)
      // U+1F510 CLOSED LOCK WITH KEY      (%F0%9F%94%90)
      // U+1F512 LOCK                      (%F0%9F%94%92)
      // U+1F513 OPEN LOCK                 (%F0%9F%94%93)
      //
      // However, some schemes such as data: and file: need to parse the exact
      // binary data when loading the URL. For that reason,
      // SPOOFING_AND_CONTROL_CHARS allows unescaping BiDi control characters.
      // DO NOT use SPOOFING_AND_CONTROL_CHARS if the parsed URL is going to be
      // displayed in the UI.
      if (!(rules & UnescapeRule::SPOOFING_AND_CONTROL_CHARS)) {
        if (HasArabicLanguageMarkAtIndex(escaped_text, first_byte, i)) {
          // Keep Arabic Language Mark escaped.
          result.append(escaped_text, i, 6);
          i += 5;
          continue;
        }
        if (HasThreeByteBidiControlCharAtIndex(escaped_text, first_byte, i)) {
          // Keep BiDi control char escaped.
          result.append(escaped_text, i, 9);
          i += 8;
          continue;
        }
        if (HasFourByteBannedCharAtIndex(escaped_text, first_byte, i)) {
          // Keep banned char escaped.
          result.append(escaped_text, i, 12);
          i += 11;
          continue;
        }
      }

      if (first_byte >= 0x80 ||  // Unescape all high-bit characters.
          // For 7-bit characters, the lookup table tells us all valid chars.
          (kUrlUnescape[first_byte] ||
           // ...and we allow some additional unescaping when flags are set.
           (first_byte == ' ' && (rules & UnescapeRule::SPACES)) ||
           // Allow any of the prohibited but non-control characters when
           // we're doing ""special"" chars.
           ((first_byte == '/' || first_byte == '\\') &&
            (rules & UnescapeRule::PATH_SEPARATORS)) ||
           (first_byte > ' ' && first_byte != '/' && first_byte != '\\' &&
            (rules & UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS)) ||
           // Additionally allow non-display characters if requested.
           (first_byte < ' ' &&
            (rules & UnescapeRule::SPOOFING_AND_CONTROL_CHARS)))) {
        // Use the unescaped version of the character.
        if (adjustments)
          adjustments->push_back(base::OffsetAdjuster::Adjustment(i, 3, 1));
        result.push_back(first_byte);
        i += 2;
      } else {
        // Keep escaped. Append a percent and we'll get the following two
        // digits on the next loops through.
        result.push_back('%');
      }
    } else if ((rules & UnescapeRule::REPLACE_PLUS_WITH_SPACE) &&
               escaped_text[i] == '+') {
      result.push_back(' ');
    } else {
      // Normal case for unescaped characters.
      result.push_back(escaped_text[i]);
    }
  }

  return result;
}","STR UnescapeURLWithAdjustmentsImpl(
    const STR& VAR_0,
    UnescapeRule::Type VAR_1,
    base::OffsetAdjuster::Adjustments* VAR_2) {
  if (VAR_2)
    VAR_2->clear();
  /* COMMENT_0 */
  if (VAR_1 == UnescapeRule::NONE)
    return VAR_0;

  /* COMMENT_1 */
  /* COMMENT_2 */
  /* COMMENT_3 */
  STR VAR_3;
  VAR_3.reserve(VAR_0.length());

  /* COMMENT_4 */
  for (size_t VAR_4 = 0, VAR_5 = VAR_0.size(); VAR_4 < VAR_5; ++VAR_4) {
    if (VAR_6<unsigned char>(VAR_0[VAR_4]) >= 128) {
      /* COMMENT_5 */
      VAR_3.push_back(VAR_0[VAR_4]);
      continue;
    }

    unsigned char VAR_7;
    if (UnescapeUnsignedCharAtIndex(VAR_0, VAR_4, &VAR_7)) {
      /* COMMENT_6 */
      /* COMMENT_7 */
      /* COMMENT_8 */
      /* COMMENT_9 */
      /* COMMENT_10 */
      /* COMMENT_11 */
      /* COMMENT_12 */
      /* COMMENT_13 */
      /* COMMENT_14 */
      /* COMMENT_15 */
      /* COMMENT_8 */
      /* COMMENT_16 */
      /* COMMENT_17 */
      /* COMMENT_18 */
      /* COMMENT_8 */
      /* COMMENT_19 */
      /* COMMENT_20 */
      /* COMMENT_21 */
      /* COMMENT_22 */
      /* COMMENT_23 */
      /* COMMENT_8 */
      /* COMMENT_24 */
      /* COMMENT_25 */
      /* COMMENT_8 */
      /* COMMENT_26 */
      /* COMMENT_27 */
      /* COMMENT_28 */
      /* COMMENT_29 */
      /* COMMENT_8 */
      /* COMMENT_30 */
      /* COMMENT_31 */
      /* COMMENT_32 */
      /* COMMENT_33 */
      /* COMMENT_34 */
      if (!(VAR_1 & UnescapeRule::SPOOFING_AND_CONTROL_CHARS)) {
        if (HasArabicLanguageMarkAtIndex(VAR_0, VAR_7, VAR_4)) {
          /* COMMENT_35 */
          VAR_3.append(VAR_0, VAR_4, 6);
          VAR_4 += 5;
          continue;
        }
        if (HasThreeByteBidiControlCharAtIndex(VAR_0, VAR_7, VAR_4)) {
          /* COMMENT_36 */
          VAR_3.append(VAR_0, VAR_4, 9);
          VAR_4 += 8;
          continue;
        }
        if (HasFourByteBannedCharAtIndex(VAR_0, VAR_7, VAR_4)) {
          /* COMMENT_37 */
          VAR_3.append(VAR_0, VAR_4, 12);
          VAR_4 += 11;
          continue;
        }
      }

      if (VAR_7 >= 0x80 ||  /* COMMENT_38 */
          /* COMMENT_39 */
          (VAR_8[VAR_7] ||
           /* COMMENT_40 */
           (VAR_7 == ' ' && (VAR_1 & UnescapeRule::SPACES)) ||
           /* COMMENT_41 */
           /* COMMENT_42 */
           ((VAR_7 == '/' || VAR_7 == '\\') &&
            (VAR_1 & UnescapeRule::PATH_SEPARATORS)) ||
           (VAR_7 > ' ' && VAR_7 != '/' && VAR_7 != '\\' &&
            (VAR_1 & UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS)) ||
           /* COMMENT_43 */
           (VAR_7 < ' ' &&
            (VAR_1 & UnescapeRule::SPOOFING_AND_CONTROL_CHARS)))) {
        /* COMMENT_44 */
        if (VAR_2)
          VAR_2->push_back(base::OffsetAdjuster::Adjustment(VAR_4, 3, 1));
        VAR_3.push_back(VAR_7);
        VAR_4 += 2;
      } else {
        /* COMMENT_45 */
        /* COMMENT_46 */
        VAR_3.push_back('%');
      }
    } else if ((VAR_1 & UnescapeRule::REPLACE_PLUS_WITH_SPACE) &&
               VAR_0[VAR_4] == '+') {
      VAR_3.push_back(' ');
    } else {
      /* COMMENT_47 */
      VAR_3.push_back(VAR_0[VAR_4]);
    }
  }

  return VAR_3;
}",chromium/30408ae67a9f6aea074b2883ba861613f52bd246/escape.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -86,7 +86,10 @@
            (first_byte == ' ' && (rules & UnescapeRule::SPACES)) ||
            // Allow any of the prohibited but non-control characters when
            // we're doing ""special"" chars.
-           (first_byte > ' ' && (rules & UnescapeRule::URL_SPECIAL_CHARS)) ||
+           ((first_byte == '/' || first_byte == '\\') &&
+            (rules & UnescapeRule::PATH_SEPARATORS)) ||
+           (first_byte > ' ' && first_byte != '/' && first_byte != '\\' &&
+            (rules & UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS)) ||
            // Additionally allow non-display characters if requested.
            (first_byte < ' ' &&
             (rules & UnescapeRule::SPOOFING_AND_CONTROL_CHARS)))) {","{'deleted_lines': [""           (first_byte > ' ' && (rules & UnescapeRule::URL_SPECIAL_CHARS)) ||""], 'added_lines': [""           ((first_byte == '/' || first_byte == '\\\\') &&"", '            (rules & UnescapeRule::PATH_SEPARATORS)) ||', ""           (first_byte > ' ' && first_byte != '/' && first_byte != '\\\\' &&"", '            (rules & UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS)) ||']}",True,"Google Chrome before 50.0.2661.102 on Android mishandles / (slash) and \ (backslash) characters, which allows attackers to conduct directory traversal attacks via a file: URL, related to net/base/escape.cc and net/base/filename_util.cc.",8.1,HIGH,2,test,,5
CVE-2016-1234,['CWE-119'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,glibc,"
CVE-2016-1234: glob: Do not copy d_name field of struct dirent [BZ #19779]

Instead, we store the data we need from the return value of
readdir in an object of the new type struct readdir_result.
This type is independent of the layout of struct dirent.
",5171f3079f2cc53e0548fc4967361f4d1ce9d7ea,https://sourceware.org/git/gitweb.cgi?p=glibc.git;h=5171f3079f2cc53e0548fc4967361f4d1ce9d7ea,posix/glob.c,glob_in_dir,"static int
glob_in_dir (const char *pattern, const char *directory, int flags,
int (*errfunc) (const char *, int),
glob_t *pglob, size_t alloca_used)
{
size_t dirlen = strlen (directory);
void *stream = NULL;
struct globnames
{
struct globnames *next;
size_t count;
char *name[64];
};
#define INITIAL_COUNT sizeof (init_names.name) / sizeof (init_names.name[0])
struct globnames init_names;
struct globnames *names = &init_names;
struct globnames *names_alloca = &init_names;
size_t nfound = 0;
size_t cur = 0;
int meta;
int save;
alloca_used += sizeof (init_names);
init_names.next = NULL;
init_names.count = INITIAL_COUNT;
meta = __glob_pattern_type (pattern, !(flags & GLOB_NOESCAPE));
if (meta == 0 && (flags & (GLOB_NOCHECK|GLOB_NOMAGIC)))
{
flags |= GLOB_NOCHECK;
}
else if (meta == 0)
{
union
{
struct stat st;
struct_stat64 st64;
} ust;
size_t patlen = strlen (pattern);
int alloca_fullname = __libc_use_alloca (alloca_used
+ dirlen + 1 + patlen + 1);
char *fullname;
if (alloca_fullname)
fullname = alloca_account (dirlen + 1 + patlen + 1, alloca_used);
else
{
fullname = malloc (dirlen + 1 + patlen + 1);
if (fullname == NULL)
return GLOB_NOSPACE;
}
mempcpy (mempcpy (mempcpy (fullname, directory, dirlen),
""/"", 1),
pattern, patlen + 1);
if ((__builtin_expect (flags & GLOB_ALTDIRFUNC, 0)
? (*pglob->gl_stat) (fullname, &ust.st)
: __stat64 (fullname, &ust.st64)) == 0)
flags |= GLOB_NOCHECK;
if (__glibc_unlikely (!alloca_fullname))
free (fullname);
}
else
{
stream = (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0)
? (*pglob->gl_opendir) (directory)
: opendir (directory));
if (stream == NULL)
{
if (errno != ENOTDIR
&& ((errfunc != NULL && (*errfunc) (directory, errno))
|| (flags & GLOB_ERR)))
return GLOB_ABORTED;
}
else
{
#ifdef _LIBC
int dfd = (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0)
? -1 : dirfd ((DIR *) stream));
#endif
int fnm_flags = ((!(flags & GLOB_PERIOD) ? FNM_PERIOD : 0)
| ((flags & GLOB_NOESCAPE) ? FNM_NOESCAPE : 0)
#if defined _AMIGA || defined VMS
| FNM_CASEFOLD
#endif
);
flags |= GLOB_MAGCHAR;
while (1)
{
const char *name;
#if defined _LIBC && !defined COMPILE_GLOB64
struct dirent64 *d;
union
{
struct dirent64 d64;
char room [offsetof (struct dirent64, d_name[0])
+ NAME_MAX + 1];
}
d64buf;
if (__glibc_unlikely (flags & GLOB_ALTDIRFUNC))
{
struct dirent *d32 = (*pglob->gl_readdir) (stream);
if (d32 != NULL)
{
CONVERT_DIRENT_DIRENT64 (&d64buf.d64, d32);
d = &d64buf.d64;
}
else
d = NULL;
}
else
d = __readdir64 (stream);
#else
struct dirent *d = (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0)
? ((struct dirent *)
(*pglob->gl_readdir) (stream))
: __readdir (stream));
#endif
if (d == NULL)
break;
if (! REAL_DIR_ENTRY (d))
continue;
if ((flags & GLOB_ONLYDIR) && !DIRENT_MIGHT_BE_DIR (d))
continue;
name = d->d_name;
if (fnmatch (pattern, name, fnm_flags) == 0)
{
if (!DIRENT_MIGHT_BE_SYMLINK (d)
|| link_exists_p (dfd, directory, dirlen, name, pglob,
flags))
{
if (cur == names->count)
{
struct globnames *newnames;
size_t count = names->count * 2;
size_t size = (sizeof (struct globnames)
+ ((count - INITIAL_COUNT)
* sizeof (char *)));
if (__libc_use_alloca (alloca_used + size))
newnames = names_alloca
= alloca_account (size, alloca_used);
else if ((newnames = malloc (size))
== NULL)
goto memory_error;
newnames->count = count;
newnames->next = names;
names = newnames;
cur = 0;
}
names->name[cur] = strdup (d->d_name);
if (names->name[cur] == NULL)
goto memory_error;
++cur;
++nfound;
}
}
}
}
}
if (nfound == 0 && (flags & GLOB_NOCHECK))
{
size_t len = strlen (pattern);
nfound = 1;
names->name[cur] = (char *) malloc (len + 1);
if (names->name[cur] == NULL)
goto memory_error;
*((char *) mempcpy (names->name[cur++], pattern, len)) = '\0';
}
int result = GLOB_NOMATCH;
if (nfound != 0)
{
result = 0;
if (pglob->gl_pathc > UINTPTR_MAX - pglob->gl_offs
|| pglob->gl_pathc + pglob->gl_offs > UINTPTR_MAX - nfound
|| pglob->gl_pathc + pglob->gl_offs + nfound > UINTPTR_MAX - 1
|| (pglob->gl_pathc + pglob->gl_offs + nfound + 1
> UINTPTR_MAX / sizeof (char *)))
goto memory_error;
char **new_gl_pathv;
new_gl_pathv
= (char **) realloc (pglob->gl_pathv,
(pglob->gl_pathc + pglob->gl_offs + nfound + 1)
* sizeof (char *));
if (new_gl_pathv == NULL)
{
memory_error:
while (1)
{
struct globnames *old = names;
for (size_t i = 0; i < cur; ++i)
free (names->name[i]);
names = names->next;
if (names == NULL)
{
assert (old == &init_names);
break;
}
cur = names->count;
if (old == names_alloca)
names_alloca = names;
else
free (old);
}
result = GLOB_NOSPACE;
}
else
{
while (1)
{
struct globnames *old = names;
for (size_t i = 0; i < cur; ++i)
new_gl_pathv[pglob->gl_offs + pglob->gl_pathc++]
= names->name[i];
names = names->next;
if (names == NULL)
{
assert (old == &init_names);
break;
}
cur = names->count;
if (old == names_alloca)
names_alloca = names;
else
free (old);
}
pglob->gl_pathv = new_gl_pathv;
pglob->gl_pathv[pglob->gl_offs + pglob->gl_pathc] = NULL;
pglob->gl_flags = flags;
}
}
if (stream != NULL)
{
save = errno;
if (__glibc_unlikely (flags & GLOB_ALTDIRFUNC))
(*pglob->gl_closedir) (stream);
else
closedir (stream);
__set_errno (save);
}
return result;
}","static int
glob_in_dir (const char *VAR_0, const char *VAR_1, int VAR_2,
int (*VAR_3) (const char *, int),
glob_t *VAR_4, size_t VAR_5)
{
size_t VAR_6 = strlen (VAR_1);
void *VAR_7 = NULL;
struct globnames
{
struct globnames *next;
size_t count;
char *name[64];
};
#define VAR_8 sizeof (init_names.name) / sizeof (init_names.name[0])
struct globnames VAR_9;
struct globnames *VAR_10 = &VAR_9;
struct globnames *VAR_11 = &VAR_9;
size_t VAR_12 = 0;
size_t VAR_13 = 0;
int VAR_14;
int VAR_15;
VAR_5 += sizeof (VAR_9);
VAR_9.next = NULL;
VAR_9.count = VAR_8;
VAR_14 = __glob_pattern_type (VAR_0, !(VAR_2 & VAR_16));
if (VAR_14 == 0 && (VAR_2 & (VAR_17|VAR_18)))
{
VAR_2 |= VAR_17;
}
else if (VAR_14 == 0)
{
union
{
struct stat st;
struct_stat64 st64;
} VAR_19;
size_t VAR_20 = strlen (VAR_0);
int VAR_21 = __libc_use_alloca (VAR_5
+ VAR_6 + 1 + VAR_20 + 1);
char *VAR_22;
if (VAR_21)
VAR_22 = alloca_account (VAR_6 + 1 + VAR_20 + 1, VAR_5);
else
{
VAR_22 = malloc (VAR_6 + 1 + VAR_20 + 1);
if (VAR_22 == NULL)
return VAR_23;
}
mempcpy (mempcpy (mempcpy (VAR_22, VAR_1, VAR_6),
""/"", 1),
VAR_0, VAR_20 + 1);
if ((__builtin_expect (VAR_2 & VAR_24, 0)
? (*VAR_4->gl_stat) (VAR_22, &VAR_19.st)
: __stat64 (VAR_22, &VAR_19.st64)) == 0)
VAR_2 |= VAR_17;
if (__glibc_unlikely (!VAR_21))
free (VAR_22);
}
else
{
VAR_7 = (__builtin_expect (VAR_2 & VAR_24, 0)
? (*VAR_4->gl_opendir) (VAR_1)
: opendir (VAR_1));
if (VAR_7 == NULL)
{
if (VAR_25 != VAR_26
&& ((VAR_3 != NULL && (*VAR_3) (VAR_1, VAR_25))
|| (VAR_2 & VAR_27)))
return VAR_28;
}
else
{
#ifdef VAR_29
int VAR_30 = (__builtin_expect (VAR_2 & VAR_24, 0)
? -1 : dirfd ((DIR *) VAR_7));
#endif
int VAR_31 = ((!(VAR_2 & VAR_32) ? VAR_33 : 0)
| ((VAR_2 & VAR_16) ? VAR_34 : 0)
#if defined VAR_35 || VAR_36 VAR_37
| VAR_38
#endif
);
VAR_2 |= VAR_39;
while (1)
{
const char *VAR_40;
#if defined VAR_29 && !defined VAR_41
struct dirent64 *VAR_42;
union
{
struct dirent64 d64;
char room [offsetof (struct dirent64, VAR_43[0])
+ VAR_44 + 1];
}
VAR_45;
if (__glibc_unlikely (VAR_2 & VAR_24))
{
struct dirent *VAR_46 = (*VAR_4->gl_readdir) (VAR_7);
if (VAR_46 != NULL)
{
CONVERT_DIRENT_DIRENT64 (&VAR_45.d64, VAR_46);
VAR_42 = &VAR_45.d64;
}
else
VAR_42 = NULL;
}
else
VAR_42 = __readdir64 (VAR_7);
#else
struct dirent *VAR_42 = (__builtin_expect (VAR_2 & VAR_24, 0)
? ((struct dirent *)
(*VAR_4->gl_readdir) (VAR_7))
: __readdir (VAR_7));
#endif
if (VAR_42 == NULL)
break;
if (! REAL_DIR_ENTRY (VAR_42))
continue;
if ((VAR_2 & VAR_47) && !DIRENT_MIGHT_BE_DIR (VAR_42))
continue;
VAR_40 = VAR_42->d_name;
if (fnmatch (VAR_0, VAR_40, VAR_31) == 0)
{
if (!DIRENT_MIGHT_BE_SYMLINK (VAR_42)
|| link_exists_p (VAR_30, VAR_1, VAR_6, VAR_40, VAR_4,
VAR_2))
{
if (VAR_13 == VAR_10->count)
{
struct globnames *VAR_48;
size_t VAR_49 = VAR_10->count * 2;
size_t VAR_50 = (sizeof (struct globnames)
+ ((VAR_49 - VAR_8)
* sizeof (char *)));
if (__libc_use_alloca (VAR_5 + VAR_50))
VAR_48 = VAR_11
= alloca_account (VAR_50, VAR_5);
else if ((VAR_48 = malloc (VAR_50))
== NULL)
goto memory_error;
VAR_48->count = VAR_49;
VAR_48->next = VAR_10;
VAR_10 = VAR_48;
VAR_13 = 0;
}
VAR_10->name[VAR_13] = strdup (VAR_42->d_name);
if (VAR_10->name[VAR_13] == NULL)
goto memory_error;
++VAR_13;
++VAR_12;
}
}
}
}
}
if (VAR_12 == 0 && (VAR_2 & VAR_17))
{
size_t VAR_51 = strlen (VAR_0);
VAR_12 = 1;
VAR_10->name[VAR_13] = (char *) malloc (VAR_51 + 1);
if (VAR_10->name[VAR_13] == NULL)
goto memory_error;
*((char *) mempcpy (VAR_10->name[VAR_13++], VAR_0, VAR_51)) = '\0';
}
int VAR_52 = VAR_53;
if (VAR_12 != 0)
{
VAR_52 = 0;
if (VAR_4->gl_pathc > VAR_54 - VAR_4->gl_offs
|| VAR_4->gl_pathc + VAR_4->gl_offs > VAR_54 - VAR_12
|| VAR_4->gl_pathc + VAR_4->gl_offs + VAR_12 > VAR_54 - 1
|| (VAR_4->gl_pathc + VAR_4->gl_offs + VAR_12 + 1
> VAR_54 / sizeof (char *)))
goto memory_error;
char **VAR_55;
VAR_55
= (char **) realloc (VAR_4->gl_pathv,
(VAR_4->gl_pathc + VAR_4->gl_offs + VAR_12 + 1)
* sizeof (char *));
if (VAR_55 == NULL)
{
memory_error:
while (1)
{
struct globnames *VAR_56 = VAR_10;
for (size_t VAR_57 = 0; VAR_57 < VAR_13; ++VAR_57)
free (VAR_10->name[VAR_57]);
VAR_10 = VAR_10->next;
if (VAR_10 == NULL)
{
assert (VAR_56 == &VAR_9);
break;
}
VAR_13 = VAR_10->count;
if (VAR_56 == VAR_11)
VAR_11 = VAR_10;
else
free (VAR_56);
}
VAR_52 = VAR_23;
}
else
{
while (1)
{
struct globnames *VAR_56 = VAR_10;
for (size_t VAR_57 = 0; VAR_57 < VAR_13; ++VAR_57)
VAR_55[VAR_4->gl_offs + VAR_4->gl_pathc++]
= VAR_10->name[VAR_57];
VAR_10 = VAR_10->next;
if (VAR_10 == NULL)
{
assert (VAR_56 == &VAR_9);
break;
}
VAR_13 = VAR_10->count;
if (VAR_56 == VAR_11)
VAR_11 = VAR_10;
else
free (VAR_56);
}
VAR_4->gl_pathv = VAR_55;
VAR_4->gl_pathv[VAR_4->gl_offs + VAR_4->gl_pathc] = NULL;
VAR_4->gl_flags = VAR_2;
}
}
if (VAR_7 != NULL)
{
VAR_15 = VAR_25;
if (__glibc_unlikely (VAR_2 & VAR_24))
(*VAR_4->gl_closedir) (VAR_7);
else
closedir (VAR_7);
__set_errno (VAR_15);
}
return VAR_52;
}",glibc/5171f3079f2cc53e0548fc4967361f4d1ce9d7ea/glob.c/vul/before/0.json,"static int
glob_in_dir (const char *pattern, const char *directory, int flags,
	     int (*errfunc) (const char *, int),
	     glob_t *pglob, size_t alloca_used)
{
  size_t dirlen = strlen (directory);
  void *stream = NULL;
  struct globnames
    {
      struct globnames *next;
      size_t count;
      char *name[64];
    };
#define INITIAL_COUNT sizeof (init_names.name) / sizeof (init_names.name[0])
  struct globnames init_names;
  struct globnames *names = &init_names;
  struct globnames *names_alloca = &init_names;
  size_t nfound = 0;
  size_t cur = 0;
  int meta;
  int save;

  alloca_used += sizeof (init_names);

  init_names.next = NULL;
  init_names.count = INITIAL_COUNT;

  meta = __glob_pattern_type (pattern, !(flags & GLOB_NOESCAPE));
  if (meta == 0 && (flags & (GLOB_NOCHECK|GLOB_NOMAGIC)))
    {
      /* We need not do any tests.  The PATTERN contains no meta
	 characters and we must not return an error therefore the
	 result will always contain exactly one name.  */
      flags |= GLOB_NOCHECK;
    }
  else if (meta == 0)
    {
      /* Since we use the normal file functions we can also use stat()
	 to verify the file is there.  */
      union
      {
	struct stat st;
	struct_stat64 st64;
      } ust;
      size_t patlen = strlen (pattern);
      int alloca_fullname = __libc_use_alloca (alloca_used
					       + dirlen + 1 + patlen + 1);
      char *fullname;
      if (alloca_fullname)
	fullname = alloca_account (dirlen + 1 + patlen + 1, alloca_used);
      else
	{
	  fullname = malloc (dirlen + 1 + patlen + 1);
	  if (fullname == NULL)
	    return GLOB_NOSPACE;
	}

      mempcpy (mempcpy (mempcpy (fullname, directory, dirlen),
			""/"", 1),
	       pattern, patlen + 1);
      if ((__builtin_expect (flags & GLOB_ALTDIRFUNC, 0)
	   ? (*pglob->gl_stat) (fullname, &ust.st)
	   : __stat64 (fullname, &ust.st64)) == 0)
	/* We found this file to be existing.  Now tell the rest
	   of the function to copy this name into the result.  */
	flags |= GLOB_NOCHECK;

      if (__glibc_unlikely (!alloca_fullname))
	free (fullname);
    }
  else
    {
      stream = (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0)
		? (*pglob->gl_opendir) (directory)
		: opendir (directory));
      if (stream == NULL)
	{
	  if (errno != ENOTDIR
	      && ((errfunc != NULL && (*errfunc) (directory, errno))
		  || (flags & GLOB_ERR)))
	    return GLOB_ABORTED;
	}
      else
	{
#ifdef _LIBC
	  int dfd = (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0)
		     ? -1 : dirfd ((DIR *) stream));
#endif
	  int fnm_flags = ((!(flags & GLOB_PERIOD) ? FNM_PERIOD : 0)
			   | ((flags & GLOB_NOESCAPE) ? FNM_NOESCAPE : 0)
#if defined _AMIGA || defined VMS
			   | FNM_CASEFOLD
#endif
			   );
	  flags |= GLOB_MAGCHAR;

	  while (1)
	    {
	      struct readdir_result d;
	      {
		if (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0))
		  d = convert_dirent (GL_READDIR (pglob, stream));
		else
		  {
#ifdef COMPILE_GLOB64
		    d = convert_dirent (__readdir (stream));
#else
		    d = convert_dirent64 (__readdir64 (stream));
#endif
		  }
	      }
	      if (d.name == NULL)
		break;
	      if (d.skip_entry)
		continue;

	      /* If we shall match only directories use the information
		 provided by the dirent call if possible.  */
	      if ((flags & GLOB_ONLYDIR) && !readdir_result_might_be_dir (d))
		continue;

	      if (fnmatch (pattern, d.name, fnm_flags) == 0)
		{
		  /* If the file we found is a symlink we have to
		     make sure the target file exists.  */
		  if (!readdir_result_might_be_symlink (d)
		      || link_exists_p (dfd, directory, dirlen, d.name,
					pglob, flags))
		    {
		      if (cur == names->count)
			{
			  struct globnames *newnames;
			  size_t count = names->count * 2;
			  size_t size = (sizeof (struct globnames)
					 + ((count - INITIAL_COUNT)
					    * sizeof (char *)));
			  if (__libc_use_alloca (alloca_used + size))
			    newnames = names_alloca
			      = alloca_account (size, alloca_used);
			  else if ((newnames = malloc (size))
				   == NULL)
			    goto memory_error;
			  newnames->count = count;
			  newnames->next = names;
			  names = newnames;
			  cur = 0;
			}
		      names->name[cur] = strdup (d.name);
		      if (names->name[cur] == NULL)
			goto memory_error;
		      ++cur;
		      ++nfound;
		    }
		}
	    }
	}
    }

  if (nfound == 0 && (flags & GLOB_NOCHECK))
    {
      size_t len = strlen (pattern);
      nfound = 1;
      names->name[cur] = (char *) malloc (len + 1);
      if (names->name[cur] == NULL)
	goto memory_error;
      *((char *) mempcpy (names->name[cur++], pattern, len)) = '\0';
    }

  int result = GLOB_NOMATCH;
  if (nfound != 0)
    {
      result = 0;

      if (pglob->gl_pathc > UINTPTR_MAX - pglob->gl_offs
	  || pglob->gl_pathc + pglob->gl_offs > UINTPTR_MAX - nfound
	  || pglob->gl_pathc + pglob->gl_offs + nfound > UINTPTR_MAX - 1
	  || (pglob->gl_pathc + pglob->gl_offs + nfound + 1
	      > UINTPTR_MAX / sizeof (char *)))
	goto memory_error;

      char **new_gl_pathv;
      new_gl_pathv
	= (char **) realloc (pglob->gl_pathv,
			     (pglob->gl_pathc + pglob->gl_offs + nfound + 1)
			     * sizeof (char *));
      if (new_gl_pathv == NULL)
	{
	memory_error:
	  while (1)
	    {
	      struct globnames *old = names;
	      for (size_t i = 0; i < cur; ++i)
		free (names->name[i]);
	      names = names->next;
	      /* NB: we will not leak memory here if we exit without
		 freeing the current block assigned to OLD.  At least
		 the very first block is always allocated on the stack
		 and this is the block assigned to OLD here.  */
	      if (names == NULL)
		{
		  assert (old == &init_names);
		  break;
		}
	      cur = names->count;
	      if (old == names_alloca)
		names_alloca = names;
	      else
		free (old);
	    }
	  result = GLOB_NOSPACE;
	}
      else
	{
	  while (1)
	    {
	      struct globnames *old = names;
	      for (size_t i = 0; i < cur; ++i)
		new_gl_pathv[pglob->gl_offs + pglob->gl_pathc++]
		  = names->name[i];
	      names = names->next;
	      /* NB: we will not leak memory here if we exit without
		 freeing the current block assigned to OLD.  At least
		 the very first block is always allocated on the stack
		 and this is the block assigned to OLD here.  */
	      if (names == NULL)
		{
		  assert (old == &init_names);
		  break;
		}
	      cur = names->count;
	      if (old == names_alloca)
		names_alloca = names;
	      else
		free (old);
	    }

	  pglob->gl_pathv = new_gl_pathv;

	  pglob->gl_pathv[pglob->gl_offs + pglob->gl_pathc] = NULL;

	  pglob->gl_flags = flags;
	}
    }

  if (stream != NULL)
    {
      save = errno;
      if (__glibc_unlikely (flags & GLOB_ALTDIRFUNC))
	(*pglob->gl_closedir) (stream);
      else
	closedir (stream);
      __set_errno (save);
    }

  return result;
}","static int
glob_in_dir (const char *VAR_0, const char *VAR_1, int VAR_2,
	     int (*VAR_3) (const char *, int),
	     glob_t *VAR_4, size_t VAR_5)
{
  size_t VAR_6 = strlen (VAR_1);
  void *VAR_7 = NULL;
  struct globnames
    {
      struct globnames *next;
      size_t count;
      char *name[64];
    };
#define VAR_8 sizeof (init_names.name) / sizeof (init_names.name[0])
  struct globnames VAR_9;
  struct globnames *VAR_10 = &VAR_9;
  struct globnames *VAR_11 = &VAR_9;
  size_t VAR_12 = 0;
  size_t VAR_13 = 0;
  int VAR_14;
  int VAR_15;

  VAR_5 += sizeof (VAR_9);

  VAR_9.next = NULL;
  VAR_9.count = VAR_8;

  VAR_14 = __glob_pattern_type (VAR_0, !(VAR_2 & VAR_16));
  if (VAR_14 == 0 && (VAR_2 & (VAR_17|VAR_18)))
    {
      /* COMMENT_0 */
                                                          
                                                  
      VAR_2 |= VAR_17;
    }
  else if (VAR_14 == 0)
    {
      /* COMMENT_3 */
                                  
      union
      {
	struct stat st;
	struct_stat64 st64;
      } VAR_19;
      size_t VAR_20 = strlen (VAR_0);
      int VAR_21 = __libc_use_alloca (VAR_5
					       + VAR_6 + 1 + VAR_20 + 1);
      char *VAR_22;
      if (VAR_21)
	VAR_22 = alloca_account (VAR_6 + 1 + VAR_20 + 1, VAR_5);
      else
	{
	  VAR_22 = malloc (VAR_6 + 1 + VAR_20 + 1);
	  if (VAR_22 == NULL)
	    return VAR_23;
	}

      mempcpy (mempcpy (mempcpy (VAR_22, VAR_1, VAR_6),
			""/"", 1),
	       VAR_0, VAR_20 + 1);
      if ((__builtin_expect (VAR_2 & VAR_24, 0)
	   ? (*VAR_4->gl_stat) (VAR_22, &VAR_19.st)
	   : __stat64 (VAR_22, &VAR_19.st64)) == 0)
	/* COMMENT_5 */
                                                          
	VAR_2 |= VAR_17;

      if (__glibc_unlikely (!VAR_21))
	free (VAR_22);
    }
  else
    {
      VAR_7 = (__builtin_expect (VAR_2 & VAR_24, 0)
		? (*VAR_4->gl_opendir) (VAR_1)
		: opendir (VAR_1));
      if (VAR_7 == NULL)
	{
	  if (VAR_25 != VAR_26
	      && ((VAR_3 != NULL && (*VAR_3) (VAR_1, VAR_25))
		  || (VAR_2 & VAR_27)))
	    return VAR_28;
	}
      else
	{
#ifdef VAR_29
	  int VAR_30 = (__builtin_expect (VAR_2 & VAR_24, 0)
		     ? -1 : dirfd ((DIR *) VAR_7));
#endif
	  int VAR_31 = ((!(VAR_2 & VAR_32) ? VAR_33 : 0)
			   | ((VAR_2 & VAR_16) ? VAR_34 : 0)
#if defined VAR_35 || VAR_36 VAR_37
			   | VAR_38
#endif
			   );
	  VAR_2 |= VAR_39;

	  while (1)
	    {
	      struct readdir_result VAR_40;
	      {
		if (__builtin_expect (VAR_2 & VAR_24, 0))
		  VAR_40 = convert_dirent (GL_READDIR (VAR_4, VAR_7));
		else
		  {
#ifdef VAR_41
		    VAR_40 = convert_dirent (__readdir (VAR_7));
#else
		    VAR_40 = convert_dirent64 (__readdir64 (VAR_7));
#endif
		  }
	      }
	      if (VAR_40.name == NULL)
		break;
	      if (VAR_40.skip_entry)
		continue;

	      /* COMMENT_7 */
                                               
	      if ((VAR_2 & VAR_42) && !readdir_result_might_be_dir (VAR_40))
		continue;

	      if (fnmatch (VAR_0, VAR_40.name, VAR_31) == 0)
		{
		  /* COMMENT_9 */
                                            
		  if (!readdir_result_might_be_symlink (VAR_40)
		      || link_exists_p (VAR_30, VAR_1, VAR_6, VAR_40.name,
					VAR_4, VAR_2))
		    {
		      if (VAR_13 == VAR_10->count)
			{
			  struct globnames *VAR_43;
			  size_t VAR_44 = VAR_10->count * 2;
			  size_t VAR_45 = (sizeof (struct globnames)
					 + ((VAR_44 - VAR_8)
					    * sizeof (char *)));
			  if (__libc_use_alloca (VAR_5 + VAR_45))
			    VAR_43 = VAR_11
			      = alloca_account (VAR_45, VAR_5);
			  else if ((VAR_43 = malloc (VAR_45))
				   == NULL)
			    goto memory_error;
			  VAR_43->count = VAR_44;
			  VAR_43->next = VAR_10;
			  VAR_10 = VAR_43;
			  VAR_13 = 0;
			}
		      VAR_10->name[VAR_13] = strdup (VAR_40.name);
		      if (VAR_10->name[VAR_13] == NULL)
			goto memory_error;
		      ++VAR_13;
		      ++VAR_12;
		    }
		}
	    }
	}
    }

  if (VAR_12 == 0 && (VAR_2 & VAR_17))
    {
      size_t VAR_46 = strlen (VAR_0);
      VAR_12 = 1;
      VAR_10->name[VAR_13] = (char *) malloc (VAR_46 + 1);
      if (VAR_10->name[VAR_13] == NULL)
	goto memory_error;
      *((char *) mempcpy (VAR_10->name[VAR_13++], VAR_0, VAR_46)) = '\0';
    }

  int VAR_47 = VAR_48;
  if (VAR_12 != 0)
    {
      VAR_47 = 0;

      if (VAR_4->gl_pathc > VAR_49 - VAR_4->gl_offs
	  || VAR_4->gl_pathc + VAR_4->gl_offs > VAR_49 - VAR_12
	  || VAR_4->gl_pathc + VAR_4->gl_offs + VAR_12 > VAR_49 - 1
	  || (VAR_4->gl_pathc + VAR_4->gl_offs + VAR_12 + 1
	      > VAR_49 / sizeof (char *)))
	goto memory_error;

      char **VAR_50;
      VAR_50
	= (char **) realloc (VAR_4->gl_pathv,
			     (VAR_4->gl_pathc + VAR_4->gl_offs + VAR_12 + 1)
			     * sizeof (char *));
      if (VAR_50 == NULL)
	{
	memory_error:
	  while (1)
	    {
	      struct globnames *VAR_51 = VAR_10;
	      for (size_t VAR_52 = 0; VAR_52 < VAR_13; ++VAR_52)
		free (VAR_10->name[VAR_52]);
	      VAR_10 = VAR_10->next;
	      /* COMMENT_11 */
                                                       
                                                        
                                                  
	      if (VAR_10 == NULL)
		{
		  assert (VAR_51 == &VAR_9);
		  break;
		}
	      VAR_13 = VAR_10->count;
	      if (VAR_51 == VAR_11)
		VAR_11 = VAR_10;
	      else
		free (VAR_51);
	    }
	  VAR_47 = VAR_23;
	}
      else
	{
	  while (1)
	    {
	      struct globnames *VAR_51 = VAR_10;
	      for (size_t VAR_52 = 0; VAR_52 < VAR_13; ++VAR_52)
		VAR_50[VAR_4->gl_offs + VAR_4->gl_pathc++]
		  = VAR_10->name[VAR_52];
	      VAR_10 = VAR_10->next;
	      /* COMMENT_15 */
                                                       
                                                        
                                                  
	      if (VAR_10 == NULL)
		{
		  assert (VAR_51 == &VAR_9);
		  break;
		}
	      VAR_13 = VAR_10->count;
	      if (VAR_51 == VAR_11)
		VAR_11 = VAR_10;
	      else
		free (VAR_51);
	    }

	  VAR_4->gl_pathv = VAR_50;

	  VAR_4->gl_pathv[VAR_4->gl_offs + VAR_4->gl_pathc] = NULL;

	  VAR_4->gl_flags = VAR_2;
	}
    }

  if (VAR_7 != NULL)
    {
      VAR_15 = VAR_25;
      if (__glibc_unlikely (VAR_2 & VAR_24))
	(*VAR_4->gl_closedir) (VAR_7);
      else
	closedir (VAR_7);
      __set_errno (VAR_15);
    }

  return VAR_47;
}",glibc/5171f3079f2cc53e0548fc4967361f4d1ce9d7ea/glob.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -96,55 +96,36 @@
 
 	  while (1)
 	    {
-	      const char *name;
-#if defined _LIBC && !defined COMPILE_GLOB64
-	      struct dirent64 *d;
-	      union
-		{
-		  struct dirent64 d64;
-		  char room [offsetof (struct dirent64, d_name[0])
-			     + NAME_MAX + 1];
-		}
-	      d64buf;
-
-	      if (__glibc_unlikely (flags & GLOB_ALTDIRFUNC))
-		{
-		  struct dirent *d32 = (*pglob->gl_readdir) (stream);
-		  if (d32 != NULL)
-		    {
-		      CONVERT_DIRENT_DIRENT64 (&d64buf.d64, d32);
-		      d = &d64buf.d64;
-		    }
-		  else
-		    d = NULL;
-		}
-	      else
-		d = __readdir64 (stream);
+	      struct readdir_result d;
+	      {
+		if (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0))
+		  d = convert_dirent (GL_READDIR (pglob, stream));
+		else
+		  {
+#ifdef COMPILE_GLOB64
+		    d = convert_dirent (__readdir (stream));
 #else
-	      struct dirent *d = (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0)
-				  ? ((struct dirent *)
-				     (*pglob->gl_readdir) (stream))
-				  : __readdir (stream));
+		    d = convert_dirent64 (__readdir64 (stream));
 #endif
-	      if (d == NULL)
+		  }
+	      }
+	      if (d.name == NULL)
 		break;
-	      if (! REAL_DIR_ENTRY (d))
+	      if (d.skip_entry)
 		continue;
 
 	      /* If we shall match only directories use the information
 		 provided by the dirent call if possible.  */
-	      if ((flags & GLOB_ONLYDIR) && !DIRENT_MIGHT_BE_DIR (d))
+	      if ((flags & GLOB_ONLYDIR) && !readdir_result_might_be_dir (d))
 		continue;
 
-	      name = d->d_name;
-
-	      if (fnmatch (pattern, name, fnm_flags) == 0)
+	      if (fnmatch (pattern, d.name, fnm_flags) == 0)
 		{
 		  /* If the file we found is a symlink we have to
 		     make sure the target file exists.  */
-		  if (!DIRENT_MIGHT_BE_SYMLINK (d)
-		      || link_exists_p (dfd, directory, dirlen, name, pglob,
-					flags))
+		  if (!readdir_result_might_be_symlink (d)
+		      || link_exists_p (dfd, directory, dirlen, d.name,
+					pglob, flags))
 		    {
 		      if (cur == names->count)
 			{
@@ -164,7 +145,7 @@
 			  names = newnames;
 			  cur = 0;
 			}
-		      names->name[cur] = strdup (d->d_name);
+		      names->name[cur] = strdup (d.name);
 		      if (names->name[cur] == NULL)
 			goto memory_error;
 		      ++cur;","{'deleted_lines': ['\t      const char *name;', '#if defined _LIBC && !defined COMPILE_GLOB64', '\t      struct dirent64 *d;', '\t      union', '\t\t{', '\t\t  struct dirent64 d64;', '\t\t  char room [offsetof (struct dirent64, d_name[0])', '\t\t\t     + NAME_MAX + 1];', '\t\t}', '\t      d64buf;', '', '\t      if (__glibc_unlikely (flags & GLOB_ALTDIRFUNC))', '\t\t{', '\t\t  struct dirent *d32 = (*pglob->gl_readdir) (stream);', '\t\t  if (d32 != NULL)', '\t\t    {', '\t\t      CONVERT_DIRENT_DIRENT64 (&d64buf.d64, d32);', '\t\t      d = &d64buf.d64;', '\t\t    }', '\t\t  else', '\t\t    d = NULL;', '\t\t}', '\t      else', '\t\td = __readdir64 (stream);', '\t      struct dirent *d = (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0)', '\t\t\t\t  ? ((struct dirent *)', '\t\t\t\t     (*pglob->gl_readdir) (stream))', '\t\t\t\t  : __readdir (stream));', '\t      if (d == NULL)', '\t      if (! REAL_DIR_ENTRY (d))', '\t      if ((flags & GLOB_ONLYDIR) && !DIRENT_MIGHT_BE_DIR (d))', '\t      name = d->d_name;', '', '\t      if (fnmatch (pattern, name, fnm_flags) == 0)', '\t\t  if (!DIRENT_MIGHT_BE_SYMLINK (d)', '\t\t      || link_exists_p (dfd, directory, dirlen, name, pglob,', '\t\t\t\t\tflags))', '\t\t      names->name[cur] = strdup (d->d_name);'], 'added_lines': ['\t      struct readdir_result d;', '\t      {', '\t\tif (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0))', '\t\t  d = convert_dirent (GL_READDIR (pglob, stream));', '\t\telse', '\t\t  {', '#ifdef COMPILE_GLOB64', '\t\t    d = convert_dirent (__readdir (stream));', '\t\t    d = convert_dirent64 (__readdir64 (stream));', '\t\t  }', '\t      }', '\t      if (d.name == NULL)', '\t      if (d.skip_entry)', '\t      if ((flags & GLOB_ONLYDIR) && !readdir_result_might_be_dir (d))', '\t      if (fnmatch (pattern, d.name, fnm_flags) == 0)', '\t\t  if (!readdir_result_might_be_symlink (d)', '\t\t      || link_exists_p (dfd, directory, dirlen, d.name,', '\t\t\t\t\tpglob, flags))', '\t\t      names->name[cur] = strdup (d.name);']}",True,"Stack-based buffer overflow in the glob implementation in GNU C Library (aka glibc) before 2.24, when GLOB_ALTDIRFUNC is used, allows context-dependent attackers to cause a denial of service (crash) via a long name.",7.5,HIGH,2,test,,5
CVE-2016-2486,['CWE-20'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"Check mp3 output buffer size

Bug: 27793371
Change-Id: I0fe40a4cfd0a5b488f93d3f3ba6f9495235926ac
",ad40e57890f81a3cf436c5f06da66396010bd9e5,https://android.googlesource.com/platform/frameworks/av/+/ad40e57890f81a3cf436c5f06da66396010bd9e5,media/libstagefright/codecs/mp3dec/SoftMP3.cpp,SoftMP3::onQueueFilled,"void SoftMP3::onQueueFilled(OMX_U32 ) {
if (mSignalledError || mOutputPortSettingsChange != NONE) {
return;
}
List<BufferInfo *> &inQueue = getPortQueue(0);
List<BufferInfo *> &outQueue = getPortQueue(1);
while ((!inQueue.empty() || (mSawInputEos && !mSignalledOutputEos)) && !outQueue.empty()) {
BufferInfo *inInfo = NULL;
OMX_BUFFERHEADERTYPE *inHeader = NULL;
if (!inQueue.empty()) {
inInfo = *inQueue.begin();
inHeader = inInfo->mHeader;
}
BufferInfo *outInfo = *outQueue.begin();
OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
outHeader->nFlags = 0;
if (inHeader) {
if (inHeader->nOffset == 0 && inHeader->nFilledLen) {
mAnchorTimeUs = inHeader->nTimeStamp;
mNumFramesOutput = 0;
}
if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
mSawInputEos = true;
}
mConfig->pInputBuffer =
inHeader->pBuffer + inHeader->nOffset;
mConfig->inputBufferCurrentLength = inHeader->nFilledLen;
} else {
mConfig->pInputBuffer = NULL;
mConfig->inputBufferCurrentLength = 0;
}
mConfig->inputBufferMaxLength = 0;
mConfig->inputBufferUsedLength = 0;
mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);
mConfig->pOutputBuffer =
reinterpret_cast<int16_t *>(outHeader->pBuffer);
ERROR_CODE decoderErr;
if ((decoderErr = pvmp3_framedecoder(mConfig, mDecoderBuf))
!= NO_DECODING_ERROR) {
ALOGV(""mp3 decoder returned error %d"", decoderErr);
if (decoderErr != NO_ENOUGH_MAIN_DATA_ERROR
&& decoderErr != SIDE_INFO_ERROR) {
ALOGE(""mp3 decoder returned error %d"", decoderErr);
notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);
mSignalledError = true;
return;
}
if (mConfig->outputFrameSize == 0) {
mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);
}
if (decoderErr == NO_ENOUGH_MAIN_DATA_ERROR && mSawInputEos) {
if (!mIsFirst) {
outHeader->nOffset = 0;
outHeader->nFilledLen = kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);
memset(outHeader->pBuffer, 0, outHeader->nFilledLen);
}
outHeader->nFlags = OMX_BUFFERFLAG_EOS;
mSignalledOutputEos = true;
} else {
ALOGV_IF(mIsFirst, ""insufficient data for first frame, sending silence"");
memset(outHeader->pBuffer,
0,
mConfig->outputFrameSize * sizeof(int16_t));
if (inHeader) {
mConfig->inputBufferUsedLength = inHeader->nFilledLen;
}
}
} else if (mConfig->samplingRate != mSamplingRate
|| mConfig->num_channels != mNumChannels) {
mSamplingRate = mConfig->samplingRate;
mNumChannels = mConfig->num_channels;
notify(OMX_EventPortSettingsChanged, 1, 0, NULL);
mOutputPortSettingsChange = AWAITING_DISABLED;
return;
}
if (mIsFirst) {
mIsFirst = false;
outHeader->nOffset =
kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);
outHeader->nFilledLen =
mConfig->outputFrameSize * sizeof(int16_t) - outHeader->nOffset;
} else if (!mSignalledOutputEos) {
outHeader->nOffset = 0;
outHeader->nFilledLen = mConfig->outputFrameSize * sizeof(int16_t);
}
outHeader->nTimeStamp =
mAnchorTimeUs + (mNumFramesOutput * 1000000ll) / mSamplingRate;
if (inHeader) {
CHECK_GE(inHeader->nFilledLen, mConfig->inputBufferUsedLength);
inHeader->nOffset += mConfig->inputBufferUsedLength;
inHeader->nFilledLen -= mConfig->inputBufferUsedLength;
if (inHeader->nFilledLen == 0) {
inInfo->mOwnedByUs = false;
inQueue.erase(inQueue.begin());
inInfo = NULL;
notifyEmptyBufferDone(inHeader);
inHeader = NULL;
}
}
mNumFramesOutput += mConfig->outputFrameSize / mNumChannels;
outInfo->mOwnedByUs = false;
outQueue.erase(outQueue.begin());
outInfo = NULL;
notifyFillBufferDone(outHeader);
outHeader = NULL;
}
}","void SoftMP3::onQueueFilled(OMX_U32 ) {
if (VAR_0 || VAR_1 != VAR_2) {
return;
}
List<BufferInfo *> &VAR_3 = getPortQueue(0);
List<BufferInfo *> &VAR_4 = getPortQueue(1);
while ((!VAR_3.empty() || (VAR_5 && !VAR_6)) && !VAR_4.empty()) {
BufferInfo *VAR_7 = NULL;
OMX_BUFFERHEADERTYPE *VAR_8 = NULL;
if (!VAR_3.empty()) {
VAR_7 = *VAR_3.begin();
VAR_8 = VAR_7->mHeader;
}
BufferInfo *VAR_9 = *VAR_4.begin();
OMX_BUFFERHEADERTYPE *VAR_10 = VAR_9->mHeader;
VAR_10->nFlags = 0;
if (VAR_8) {
if (VAR_8->nOffset == 0 && VAR_8->nFilledLen) {
VAR_11 = VAR_8->nTimeStamp;
VAR_12 = 0;
}
if (VAR_8->nFlags & VAR_13) {
VAR_5 = true;
}
VAR_14->pInputBuffer =
VAR_8->pBuffer + VAR_8->nOffset;
VAR_14->inputBufferCurrentLength = VAR_8->nFilledLen;
} else {
VAR_14->pInputBuffer = NULL;
VAR_14->inputBufferCurrentLength = 0;
}
VAR_14->inputBufferMaxLength = 0;
VAR_14->inputBufferUsedLength = 0;
VAR_14->outputFrameSize = VAR_15 / sizeof(int16_t);
VAR_14->pOutputBuffer =
VAR_16<int16_t *>(VAR_10->pBuffer);
ERROR_CODE VAR_17;
if ((VAR_17 = pvmp3_framedecoder(VAR_14, VAR_18))
!= VAR_19) {
ALOGV(""mp3 decoder returned error %d"", VAR_17);
if (VAR_17 != VAR_20
&& VAR_17 != VAR_21) {
ALOGE(""mp3 decoder returned error %d"", VAR_17);
notify(VAR_22, VAR_23, VAR_17, NULL);
VAR_0 = true;
return;
}
if (VAR_14->outputFrameSize == 0) {
VAR_14->outputFrameSize = VAR_15 / sizeof(int16_t);
}
if (VAR_17 == VAR_20 && VAR_5) {
if (!VAR_24) {
VAR_10->nOffset = 0;
VAR_10->nFilledLen = VAR_25 * VAR_26 * sizeof(int16_t);
memset(VAR_10->pBuffer, 0, VAR_10->nFilledLen);
}
VAR_10->nFlags = VAR_13;
VAR_6 = true;
} else {
ALOGV_IF(VAR_24, ""insufficient data for first frame, sending silence"");
memset(VAR_10->pBuffer,
0,
VAR_14->outputFrameSize * sizeof(int16_t));
if (VAR_8) {
VAR_14->inputBufferUsedLength = VAR_8->nFilledLen;
}
}
} else if (VAR_14->samplingRate != VAR_27
|| VAR_14->num_channels != VAR_26) {
VAR_27 = VAR_14->samplingRate;
VAR_26 = VAR_14->num_channels;
notify(VAR_28, 1, 0, NULL);
VAR_1 = VAR_29;
return;
}
if (VAR_24) {
VAR_24 = false;
VAR_10->nOffset =
VAR_25 * VAR_26 * sizeof(int16_t);
VAR_10->nFilledLen =
VAR_14->outputFrameSize * sizeof(int16_t) - VAR_10->nOffset;
} else if (!VAR_6) {
VAR_10->nOffset = 0;
VAR_10->nFilledLen = VAR_14->outputFrameSize * sizeof(int16_t);
}
VAR_10->nTimeStamp =
VAR_11 + (VAR_12 * 1000000ll) / VAR_27;
if (VAR_8) {
CHECK_GE(VAR_8->nFilledLen, VAR_14->inputBufferUsedLength);
VAR_8->nOffset += VAR_14->inputBufferUsedLength;
VAR_8->nFilledLen -= VAR_14->inputBufferUsedLength;
if (VAR_8->nFilledLen == 0) {
VAR_7->mOwnedByUs = false;
VAR_3.erase(VAR_3.begin());
VAR_7 = NULL;
notifyEmptyBufferDone(VAR_8);
VAR_8 = NULL;
}
}
VAR_12 += VAR_14->outputFrameSize / VAR_26;
VAR_9->mOwnedByUs = false;
VAR_4.erase(VAR_4.begin());
VAR_9 = NULL;
notifyFillBufferDone(VAR_10);
VAR_10 = NULL;
}
}",android/ad40e57890f81a3cf436c5f06da66396010bd9e5/SoftMP3.cpp/vul/before/0.json,"void SoftMP3::onQueueFilled(OMX_U32 /* portIndex */) {
    if (mSignalledError || mOutputPortSettingsChange != NONE) {
        return;
    }

    List<BufferInfo *> &inQueue = getPortQueue(0);
    List<BufferInfo *> &outQueue = getPortQueue(1);

    while ((!inQueue.empty() || (mSawInputEos && !mSignalledOutputEos)) && !outQueue.empty()) {
        BufferInfo *inInfo = NULL;
        OMX_BUFFERHEADERTYPE *inHeader = NULL;
        if (!inQueue.empty()) {
            inInfo = *inQueue.begin();
            inHeader = inInfo->mHeader;
        }

        BufferInfo *outInfo = *outQueue.begin();
        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
        outHeader->nFlags = 0;

        if (inHeader) {
            if (inHeader->nOffset == 0 && inHeader->nFilledLen) {
                mAnchorTimeUs = inHeader->nTimeStamp;
                mNumFramesOutput = 0;
            }

            if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {
                mSawInputEos = true;
            }

            mConfig->pInputBuffer =
                inHeader->pBuffer + inHeader->nOffset;

            mConfig->inputBufferCurrentLength = inHeader->nFilledLen;
        } else {
            mConfig->pInputBuffer = NULL;
            mConfig->inputBufferCurrentLength = 0;
        }
        mConfig->inputBufferMaxLength = 0;
        mConfig->inputBufferUsedLength = 0;

        mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);
        if ((int32)outHeader->nAllocLen < mConfig->outputFrameSize) {
            ALOGE(""input buffer too small: got %lu, expected %u"",
                outHeader->nAllocLen, mConfig->outputFrameSize);
            android_errorWriteLog(0x534e4554, ""27793371"");
            notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
            mSignalledError = true;
            return;
        }

        mConfig->pOutputBuffer =
            reinterpret_cast<int16_t *>(outHeader->pBuffer);

        ERROR_CODE decoderErr;
        if ((decoderErr = pvmp3_framedecoder(mConfig, mDecoderBuf))
                != NO_DECODING_ERROR) {
            ALOGV(""mp3 decoder returned error %d"", decoderErr);

            if (decoderErr != NO_ENOUGH_MAIN_DATA_ERROR
                        && decoderErr != SIDE_INFO_ERROR) {
                ALOGE(""mp3 decoder returned error %d"", decoderErr);

                notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);
                mSignalledError = true;
                return;
            }

            if (mConfig->outputFrameSize == 0) {
                mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);
            }

            if (decoderErr == NO_ENOUGH_MAIN_DATA_ERROR && mSawInputEos) {
                if (!mIsFirst) {
                    // pad the end of the stream with 529 samples, since that many samples
                    // were trimmed off the beginning when decoding started
                    outHeader->nOffset = 0;
                    outHeader->nFilledLen = kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);

                    memset(outHeader->pBuffer, 0, outHeader->nFilledLen);
                }
                outHeader->nFlags = OMX_BUFFERFLAG_EOS;
                mSignalledOutputEos = true;
            } else {
                // This is recoverable, just ignore the current frame and
                // play silence instead.

                // TODO: should we skip silence (and consume input data)
                // if mIsFirst is true as we may not have a valid
                // mConfig->samplingRate and mConfig->num_channels?
                ALOGV_IF(mIsFirst, ""insufficient data for first frame, sending silence"");
                memset(outHeader->pBuffer,
                       0,
                       mConfig->outputFrameSize * sizeof(int16_t));

                if (inHeader) {
                    mConfig->inputBufferUsedLength = inHeader->nFilledLen;
                }
            }
        } else if (mConfig->samplingRate != mSamplingRate
                || mConfig->num_channels != mNumChannels) {
            mSamplingRate = mConfig->samplingRate;
            mNumChannels = mConfig->num_channels;

            notify(OMX_EventPortSettingsChanged, 1, 0, NULL);
            mOutputPortSettingsChange = AWAITING_DISABLED;
            return;
        }

        if (mIsFirst) {
            mIsFirst = false;
            // The decoder delay is 529 samples, so trim that many samples off
            // the start of the first output buffer. This essentially makes this
            // decoder have zero delay, which the rest of the pipeline assumes.
            outHeader->nOffset =
                kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);

            outHeader->nFilledLen =
                mConfig->outputFrameSize * sizeof(int16_t) - outHeader->nOffset;
        } else if (!mSignalledOutputEos) {
            outHeader->nOffset = 0;
            outHeader->nFilledLen = mConfig->outputFrameSize * sizeof(int16_t);
        }

        outHeader->nTimeStamp =
            mAnchorTimeUs + (mNumFramesOutput * 1000000ll) / mSamplingRate;

        if (inHeader) {
            CHECK_GE(inHeader->nFilledLen, mConfig->inputBufferUsedLength);

            inHeader->nOffset += mConfig->inputBufferUsedLength;
            inHeader->nFilledLen -= mConfig->inputBufferUsedLength;


            if (inHeader->nFilledLen == 0) {
                inInfo->mOwnedByUs = false;
                inQueue.erase(inQueue.begin());
                inInfo = NULL;
                notifyEmptyBufferDone(inHeader);
                inHeader = NULL;
            }
        }

        mNumFramesOutput += mConfig->outputFrameSize / mNumChannels;

        outInfo->mOwnedByUs = false;
        outQueue.erase(outQueue.begin());
        outInfo = NULL;
        notifyFillBufferDone(outHeader);
        outHeader = NULL;
    }
}","void SoftMP3::onQueueFilled(OMX_U32 /* COMMENT_0 */) {
    if (VAR_0 || VAR_1 != VAR_2) {
        return;
    }

    List<BufferInfo *> &VAR_3 = getPortQueue(0);
    List<BufferInfo *> &VAR_4 = getPortQueue(1);

    while ((!VAR_3.empty() || (VAR_5 && !VAR_6)) && !VAR_4.empty()) {
        BufferInfo *VAR_7 = NULL;
        OMX_BUFFERHEADERTYPE *VAR_8 = NULL;
        if (!VAR_3.empty()) {
            VAR_7 = *VAR_3.begin();
            VAR_8 = VAR_7->mHeader;
        }

        BufferInfo *VAR_9 = *VAR_4.begin();
        OMX_BUFFERHEADERTYPE *VAR_10 = VAR_9->mHeader;
        VAR_10->nFlags = 0;

        if (VAR_8) {
            if (VAR_8->nOffset == 0 && VAR_8->nFilledLen) {
                VAR_11 = VAR_8->nTimeStamp;
                VAR_12 = 0;
            }

            if (VAR_8->nFlags & VAR_13) {
                VAR_5 = true;
            }

            VAR_14->pInputBuffer =
                VAR_8->pBuffer + VAR_8->nOffset;

            VAR_14->inputBufferCurrentLength = VAR_8->nFilledLen;
        } else {
            VAR_14->pInputBuffer = NULL;
            VAR_14->inputBufferCurrentLength = 0;
        }
        VAR_14->inputBufferMaxLength = 0;
        VAR_14->inputBufferUsedLength = 0;

        VAR_14->outputFrameSize = VAR_15 / sizeof(int16_t);
        if ((int32)VAR_10->nAllocLen < VAR_14->outputFrameSize) {
            ALOGE(""input buffer too small: got %lu, expected %u"",
                VAR_10->nAllocLen, VAR_14->outputFrameSize);
            android_errorWriteLog(0x534e4554, ""27793371"");
            notify(VAR_16, VAR_17, VAR_18, NULL);
            VAR_0 = true;
            return;
        }

        VAR_14->pOutputBuffer =
            VAR_19<int16_t *>(VAR_10->pBuffer);

        ERROR_CODE VAR_20;
        if ((VAR_20 = pvmp3_framedecoder(VAR_14, VAR_21))
                != VAR_22) {
            ALOGV(""mp3 decoder returned error %d"", VAR_20);

            if (VAR_20 != VAR_23
                        && VAR_20 != VAR_24) {
                ALOGE(""mp3 decoder returned error %d"", VAR_20);

                notify(VAR_16, VAR_17, VAR_20, NULL);
                VAR_0 = true;
                return;
            }

            if (VAR_14->outputFrameSize == 0) {
                VAR_14->outputFrameSize = VAR_15 / sizeof(int16_t);
            }

            if (VAR_20 == VAR_23 && VAR_5) {
                if (!VAR_25) {
                    /* COMMENT_1 */
                    /* COMMENT_2 */
                    VAR_10->nOffset = 0;
                    VAR_10->nFilledLen = VAR_26 * VAR_27 * sizeof(int16_t);

                    memset(VAR_10->pBuffer, 0, VAR_10->nFilledLen);
                }
                VAR_10->nFlags = VAR_13;
                VAR_6 = true;
            } else {
                /* COMMENT_3 */
                /* COMMENT_4 */

                /* COMMENT_5 */
                /* COMMENT_6 */
                /* COMMENT_7 */
                ALOGV_IF(VAR_25, ""insufficient data for first frame, sending silence"");
                memset(VAR_10->pBuffer,
                       0,
                       VAR_14->outputFrameSize * sizeof(int16_t));

                if (VAR_8) {
                    VAR_14->inputBufferUsedLength = VAR_8->nFilledLen;
                }
            }
        } else if (VAR_14->samplingRate != VAR_28
                || VAR_14->num_channels != VAR_27) {
            VAR_28 = VAR_14->samplingRate;
            VAR_27 = VAR_14->num_channels;

            notify(VAR_29, 1, 0, NULL);
            VAR_1 = VAR_30;
            return;
        }

        if (VAR_25) {
            VAR_25 = false;
            /* COMMENT_8 */
            /* COMMENT_9 */
            /* COMMENT_10 */
            VAR_10->nOffset =
                VAR_26 * VAR_27 * sizeof(int16_t);

            VAR_10->nFilledLen =
                VAR_14->outputFrameSize * sizeof(int16_t) - VAR_10->nOffset;
        } else if (!VAR_6) {
            VAR_10->nOffset = 0;
            VAR_10->nFilledLen = VAR_14->outputFrameSize * sizeof(int16_t);
        }

        VAR_10->nTimeStamp =
            VAR_11 + (VAR_12 * 1000000ll) / VAR_28;

        if (VAR_8) {
            CHECK_GE(VAR_8->nFilledLen, VAR_14->inputBufferUsedLength);

            VAR_8->nOffset += VAR_14->inputBufferUsedLength;
            VAR_8->nFilledLen -= VAR_14->inputBufferUsedLength;


            if (VAR_8->nFilledLen == 0) {
                VAR_7->mOwnedByUs = false;
                VAR_3.erase(VAR_3.begin());
                VAR_7 = NULL;
                notifyEmptyBufferDone(VAR_8);
                VAR_8 = NULL;
            }
        }

        VAR_12 += VAR_14->outputFrameSize / VAR_27;

        VAR_9->mOwnedByUs = false;
        VAR_4.erase(VAR_4.begin());
        VAR_9 = NULL;
        notifyFillBufferDone(VAR_10);
        VAR_10 = NULL;
    }
}",android/ad40e57890f81a3cf436c5f06da66396010bd9e5/SoftMP3.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -40,6 +40,14 @@
         mConfig->inputBufferUsedLength = 0;
 
         mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);
+        if ((int32)outHeader->nAllocLen < mConfig->outputFrameSize) {
+            ALOGE(""input buffer too small: got %lu, expected %u"",
+                outHeader->nAllocLen, mConfig->outputFrameSize);
+            android_errorWriteLog(0x534e4554, ""27793371"");
+            notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
+            mSignalledError = true;
+            return;
+        }
 
         mConfig->pOutputBuffer =
             reinterpret_cast<int16_t *>(outHeader->pBuffer);","{'deleted_lines': [], 'added_lines': ['        if ((int32)outHeader->nAllocLen < mConfig->outputFrameSize) {', '            ALOGE(""input buffer too small: got %lu, expected %u"",', '                outHeader->nAllocLen, mConfig->outputFrameSize);', '            android_errorWriteLog(0x534e4554, ""27793371"");', '            notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);', '            mSignalledError = true;', '            return;', '        }']}",True,"mp3dec/SoftMP3.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not validate the relationship between allocated memory and the frame size, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27793371.",7.8,HIGH,2,test,,5
CVE-2019-9631,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,poppler,"Pass address of the first byte after end of the source buffer
to downsample_row_box_filter() so that we can check
that we don't run out of it.

Fixes issue #736
",8122f6d6d409b53151a20c5578fc525ee97315e8,https://cgit.freedesktop.org/poppler/poppler/commit/?id=8122f6d6d409b53151a20c5578fc525ee97315e8,poppler/CairoRescaleBox.cc,downsample_row_box_filter,"static void downsample_row_box_filter (
int start, int width,
uint32_t *src, uint32_t *dest,
int coverage[], int pixel_coverage)
{
int x = 0;
while (x < start)
{
int box = 1 << FIXED_SHIFT;
int start_coverage = coverage[x];
box -= start_coverage;
src++;
while (box >= pixel_coverage)
{
src++;
box -= pixel_coverage;
}
x++;
}
while (x < start + width)
{
uint32_t a = 0;
uint32_t r = 0;
uint32_t g = 0;
uint32_t b = 0;
int box = 1 << FIXED_SHIFT;
int start_coverage = coverage[x];
a = ((*src >> 24) & 0xff) * start_coverage;
r = ((*src >> 16) & 0xff) * start_coverage;
g = ((*src >>  8) & 0xff) * start_coverage;
b = ((*src >>  0) & 0xff) * start_coverage;
src++;
x++;
box -= start_coverage;
while (box >= pixel_coverage)
{
a += ((*src >> 24) & 0xff) * pixel_coverage;
r += ((*src >> 16) & 0xff) * pixel_coverage;
g += ((*src >>  8) & 0xff) * pixel_coverage;
b += ((*src >>  0) & 0xff) * pixel_coverage;
src++;
box -= pixel_coverage;
}
if (box > 0)
{
a += ((*src >> 24) & 0xff) * box;
r += ((*src >> 16) & 0xff) * box;
g += ((*src >>  8) & 0xff) * box;
b += ((*src >>  0) & 0xff) * box;
}
a >>= FIXED_SHIFT;
r >>= FIXED_SHIFT;
g >>= FIXED_SHIFT;
b >>= FIXED_SHIFT;
*dest = (a << 24) | (r << 16) | (g << 8) | b;
dest++;
}
}","static void downsample_row_box_filter (
int VAR_0, int VAR_1,
uint32_t *VAR_2, uint32_t *VAR_3,
int VAR_4[], int VAR_5)
{
int VAR_6 = 0;
while (VAR_6 < VAR_0)
{
int VAR_7 = 1 << VAR_8;
int VAR_9 = VAR_4[VAR_6];
VAR_7 -= VAR_9;
VAR_2++;
while (VAR_7 >= VAR_5)
{
VAR_2++;
VAR_7 -= VAR_5;
}
VAR_6++;
}
while (VAR_6 < VAR_0 + VAR_1)
{
uint32_t VAR_10 = 0;
uint32_t VAR_11 = 0;
uint32_t VAR_12 = 0;
uint32_t VAR_13 = 0;
int VAR_7 = 1 << VAR_8;
int VAR_9 = VAR_4[VAR_6];
VAR_10 = ((*VAR_2 >> 24) & 0xff) * VAR_9;
VAR_11 = ((*VAR_2 >> 16) & 0xff) * VAR_9;
VAR_12 = ((*VAR_2 >>  8) & 0xff) * VAR_9;
VAR_13 = ((*VAR_2 >>  0) & 0xff) * VAR_9;
VAR_2++;
VAR_6++;
VAR_7 -= VAR_9;
while (VAR_7 >= VAR_5)
{
VAR_10 += ((*VAR_2 >> 24) & 0xff) * VAR_5;
VAR_11 += ((*VAR_2 >> 16) & 0xff) * VAR_5;
VAR_12 += ((*VAR_2 >>  8) & 0xff) * VAR_5;
VAR_13 += ((*VAR_2 >>  0) & 0xff) * VAR_5;
VAR_2++;
VAR_7 -= VAR_5;
}
if (VAR_7 > 0)
{
VAR_10 += ((*VAR_2 >> 24) & 0xff) * VAR_7;
VAR_11 += ((*VAR_2 >> 16) & 0xff) * VAR_7;
VAR_12 += ((*VAR_2 >>  8) & 0xff) * VAR_7;
VAR_13 += ((*VAR_2 >>  0) & 0xff) * VAR_7;
}
VAR_10 >>= VAR_8;
VAR_11 >>= VAR_8;
VAR_12 >>= VAR_8;
VAR_13 >>= VAR_8;
*VAR_3 = (VAR_10 << 24) | (VAR_11 << 16) | (VAR_12 << 8) | VAR_13;
VAR_3++;
}
}",poppler/8122f6d6d409b53151a20c5578fc525ee97315e8/CairoRescaleBox.cc/vul/before/0.json,"static void downsample_row_box_filter (
        int start, int width,
        uint32_t *src, uint32_t *src_limit, uint32_t *dest,
        int coverage[], int pixel_coverage)
{
    /* we need an array of the pixel contribution of each destination pixel on the boundaries.
     * we invert the value to get the value on the other size of the box */
    /*

       value  = a * contribution * 1/box_size
       value += a * 1/box_size
       value += a * 1/box_size
       value += a * 1/box_size
       value += a * (1 - contribution) * 1/box_size
                a * (1/box_size - contribution * 1/box_size)

        box size is constant


       value = a * contribution_a * 1/box_size + b * contribution_b * 1/box_size
               contribution_b = (1 - contribution_a)
                              = (1 - contribution_a_next)
    */

    /* box size = ceil(src_width/dest_width) */
    int x = 0;

    /* skip to start */
    /* XXX: it might be possible to do this directly instead of iteratively, however
     * the iterative solution is simple */
    while (x < start && src < src_limit)
    {
        int box = 1 << FIXED_SHIFT;
        int start_coverage = coverage[x];
        box -= start_coverage;
        src++;
        while (box >= pixel_coverage && src < src_limit)
        {
            src++;
            box -= pixel_coverage;
        }
        x++;
    }

    while (x < start + width && src < src_limit)
    {
        uint32_t a = 0;
        uint32_t r = 0;
        uint32_t g = 0;
        uint32_t b = 0;
        int box = 1 << FIXED_SHIFT;
        int start_coverage = coverage[x];

        a = ((*src >> 24) & 0xff) * start_coverage;
        r = ((*src >> 16) & 0xff) * start_coverage;
        g = ((*src >>  8) & 0xff) * start_coverage;
        b = ((*src >>  0) & 0xff) * start_coverage;
        src++;
        x++;
        box -= start_coverage;

        while (box >= pixel_coverage && src < src_limit)
        {
            a += ((*src >> 24) & 0xff) * pixel_coverage;
            r += ((*src >> 16) & 0xff) * pixel_coverage;
            g += ((*src >>  8) & 0xff) * pixel_coverage;
            b += ((*src >>  0) & 0xff) * pixel_coverage;
            src++;

            box -= pixel_coverage;
        }

        /* multiply by whatever is leftover
         * this ensures that we don't bias down.
         * i.e. start_coverage + n*pixel_coverage + box == 1 << 24 */
        if (box > 0 && src < src_limit)
        {
            a += ((*src >> 24) & 0xff) * box;
            r += ((*src >> 16) & 0xff) * box;
            g += ((*src >>  8) & 0xff) * box;
            b += ((*src >>  0) & 0xff) * box;
        }

        a >>= FIXED_SHIFT;
        r >>= FIXED_SHIFT;
        g >>= FIXED_SHIFT;
        b >>= FIXED_SHIFT;

        *dest = (a << 24) | (r << 16) | (g << 8) | b;
        dest++;
    }
}","static void downsample_row_box_filter (
        int VAR_0, int VAR_1,
        uint32_t *VAR_2, uint32_t *VAR_3, uint32_t *VAR_4,
        int VAR_5[], int VAR_6)
{
    /* COMMENT_0 */
                                                                           
    /* COMMENT_2 */

                                             
                              
                              
                              
                                                   
                                                            

                            


                                                                                
                                                    
                                                         
      

    /* COMMENT_13 */
    int VAR_7 = 0;

    /* COMMENT_14 */
    /* COMMENT_15 */
                                          
    while (VAR_7 < VAR_0 && VAR_2 < VAR_3)
    {
        int VAR_8 = 1 << VAR_9;
        int VAR_10 = VAR_5[VAR_7];
        VAR_8 -= VAR_10;
        VAR_2++;
        while (VAR_8 >= VAR_6 && VAR_2 < VAR_3)
        {
            VAR_2++;
            VAR_8 -= VAR_6;
        }
        VAR_7++;
    }

    while (VAR_7 < VAR_0 + VAR_1 && VAR_2 < VAR_3)
    {
        uint32_t VAR_11 = 0;
        uint32_t VAR_12 = 0;
        uint32_t VAR_13 = 0;
        uint32_t VAR_14 = 0;
        int VAR_8 = 1 << VAR_9;
        int VAR_10 = VAR_5[VAR_7];

        VAR_11 = ((*VAR_2 >> 24) & 0xff) * VAR_10;
        VAR_12 = ((*VAR_2 >> 16) & 0xff) * VAR_10;
        VAR_13 = ((*VAR_2 >>  8) & 0xff) * VAR_10;
        VAR_14 = ((*VAR_2 >>  0) & 0xff) * VAR_10;
        VAR_2++;
        VAR_7++;
        VAR_8 -= VAR_10;

        while (VAR_8 >= VAR_6 && VAR_2 < VAR_3)
        {
            VAR_11 += ((*VAR_2 >> 24) & 0xff) * VAR_6;
            VAR_12 += ((*VAR_2 >> 16) & 0xff) * VAR_6;
            VAR_13 += ((*VAR_2 >>  8) & 0xff) * VAR_6;
            VAR_14 += ((*VAR_2 >>  0) & 0xff) * VAR_6;
            VAR_2++;

            VAR_8 -= VAR_6;
        }

        /* COMMENT_17 */
                                                
                                                                     
        if (VAR_8 > 0 && VAR_2 < VAR_3)
        {
            VAR_11 += ((*VAR_2 >> 24) & 0xff) * VAR_8;
            VAR_12 += ((*VAR_2 >> 16) & 0xff) * VAR_8;
            VAR_13 += ((*VAR_2 >>  8) & 0xff) * VAR_8;
            VAR_14 += ((*VAR_2 >>  0) & 0xff) * VAR_8;
        }

        VAR_11 >>= VAR_9;
        VAR_12 >>= VAR_9;
        VAR_13 >>= VAR_9;
        VAR_14 >>= VAR_9;

        *VAR_4 = (VAR_11 << 24) | (VAR_12 << 16) | (VAR_13 << 8) | VAR_14;
        VAR_4++;
    }
}",poppler/8122f6d6d409b53151a20c5578fc525ee97315e8/CairoRescaleBox.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static void downsample_row_box_filter (
         int start, int width,
-        uint32_t *src, uint32_t *dest,
+        uint32_t *src, uint32_t *src_limit, uint32_t *dest,
         int coverage[], int pixel_coverage)
 {
     /* we need an array of the pixel contribution of each destination pixel on the boundaries.
@@ -28,13 +28,13 @@
     /* skip to start */
     /* XXX: it might be possible to do this directly instead of iteratively, however
      * the iterative solution is simple */
-    while (x < start)
+    while (x < start && src < src_limit)
     {
         int box = 1 << FIXED_SHIFT;
         int start_coverage = coverage[x];
         box -= start_coverage;
         src++;
-        while (box >= pixel_coverage)
+        while (box >= pixel_coverage && src < src_limit)
         {
             src++;
             box -= pixel_coverage;
@@ -42,7 +42,7 @@
         x++;
     }
 
-    while (x < start + width)
+    while (x < start + width && src < src_limit)
     {
         uint32_t a = 0;
         uint32_t r = 0;
@@ -59,7 +59,7 @@
         x++;
         box -= start_coverage;
 
-        while (box >= pixel_coverage)
+        while (box >= pixel_coverage && src < src_limit)
         {
             a += ((*src >> 24) & 0xff) * pixel_coverage;
             r += ((*src >> 16) & 0xff) * pixel_coverage;
@@ -73,7 +73,7 @@
         /* multiply by whatever is leftover
          * this ensures that we don't bias down.
          * i.e. start_coverage + n*pixel_coverage + box == 1 << 24 */
-        if (box > 0)
+        if (box > 0 && src < src_limit)
         {
             a += ((*src >> 24) & 0xff) * box;
             r += ((*src >> 16) & 0xff) * box;","{'deleted_lines': ['        uint32_t *src, uint32_t *dest,', '    while (x < start)', '        while (box >= pixel_coverage)', '    while (x < start + width)', '        while (box >= pixel_coverage)', '        if (box > 0)'], 'added_lines': ['        uint32_t *src, uint32_t *src_limit, uint32_t *dest,', '    while (x < start && src < src_limit)', '        while (box >= pixel_coverage && src < src_limit)', '    while (x < start + width && src < src_limit)', '        while (box >= pixel_coverage && src < src_limit)', '        if (box > 0 && src < src_limit)']}",True,Poppler 0.74.0 has a heap-based buffer over-read in the CairoRescaleBox.cc downsample_row_box_filter function.,9.8,CRITICAL,3,test,,5
CVE-2019-9631,['CWE-125'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,poppler,"Pass address of the first byte after end of the source buffer
to downsample_row_box_filter() so that we can check
that we don't run out of it.

Fixes issue #736
",8122f6d6d409b53151a20c5578fc525ee97315e8,https://cgit.freedesktop.org/poppler/poppler/commit/?id=8122f6d6d409b53151a20c5578fc525ee97315e8,poppler/CairoRescaleBox.cc,CairoRescaleBox::downScaleImage,"bool CairoRescaleBox::downScaleImage(unsigned orig_width, unsigned orig_height,
signed scaled_width, signed scaled_height,
unsigned short int start_column, unsigned short int start_row,
unsigned short int width, unsigned short int height,
cairo_surface_t *dest_surface) {
int pixel_coverage_x, pixel_coverage_y;
int dest_y;
int src_y = 0;
uint32_t *scanline;
int *x_coverage = nullptr;
int *y_coverage = nullptr;
uint32_t *temp_buf = nullptr;
bool retval = false;
unsigned int *dest;
int dst_stride;
dest = reinterpret_cast<unsigned int *>(cairo_image_surface_get_data (dest_surface));
dst_stride = cairo_image_surface_get_stride (dest_surface);
scanline = (uint32_t*)gmallocn (orig_width, sizeof(int));
x_coverage = (int *)gmallocn (orig_width, sizeof(int));
y_coverage = (int *)gmallocn (orig_height, sizeof(int));
temp_buf = (uint32_t *)gmallocn3 ((orig_height + scaled_height-1)/scaled_height+1, scaled_width, sizeof(uint32_t));
if (!x_coverage || !y_coverage || !scanline || !temp_buf)
goto cleanup;
pixel_coverage_x = compute_coverage (x_coverage, orig_width, scaled_width);
pixel_coverage_y = compute_coverage (y_coverage, orig_height, scaled_height);
assert (width + start_column <= scaled_width);
for (dest_y = 0; dest_y < start_row; dest_y++)
{
int box = 1 << FIXED_SHIFT;
int start_coverage_y = y_coverage[dest_y];
box -= start_coverage_y;
src_y++;
while (box >= pixel_coverage_y)
{
box -= pixel_coverage_y;
src_y++;
}
}
for (; dest_y < start_row + height; dest_y++)
{
int columns = 0;
int box = 1 << FIXED_SHIFT;
int start_coverage_y = y_coverage[dest_y];
getRow(src_y, scanline);
downsample_row_box_filter (start_column, width, scanline, temp_buf + width * columns, x_coverage, pixel_coverage_x);
columns++;
src_y++;
box -= start_coverage_y;
while (box >= pixel_coverage_y)
{
getRow(src_y, scanline);
downsample_row_box_filter (start_column, width, scanline, temp_buf + width * columns, x_coverage, pixel_coverage_x);
columns++;
src_y++;
box -= pixel_coverage_y;
}
if (box > 0)
{
getRow(src_y, scanline);
downsample_row_box_filter (start_column, width, scanline, temp_buf + width * columns, x_coverage, pixel_coverage_x);
columns++;
}
downsample_columns_box_filter (width, start_coverage_y, pixel_coverage_y, temp_buf, dest);
dest += dst_stride / 4;
}
retval = true;
cleanup:
free (x_coverage);
free (y_coverage);
free (temp_buf);
free (scanline);
return retval;
}","bool CairoRescaleBox::downScaleImage(unsigned VAR_0, unsigned VAR_1,
signed VAR_2, signed VAR_3,
unsigned short int VAR_4, unsigned short int VAR_5,
unsigned short int VAR_6, unsigned short int VAR_7,
cairo_surface_t *VAR_8) {
int VAR_9, VAR_10;
int VAR_11;
int VAR_12 = 0;
uint32_t *VAR_13;
int *VAR_14 = nullptr;
int *VAR_15 = nullptr;
uint32_t *VAR_16 = nullptr;
bool VAR_17 = false;
unsigned int *VAR_18;
int VAR_19;
VAR_18 = VAR_20<unsigned int *>(cairo_image_surface_get_data (VAR_8));
VAR_19 = cairo_image_surface_get_stride (VAR_8);
VAR_13 = (uint32_t*)gmallocn (VAR_0, sizeof(int));
VAR_14 = (int *)gmallocn (VAR_0, sizeof(int));
VAR_15 = (int *)gmallocn (VAR_1, sizeof(int));
VAR_16 = (uint32_t *)gmallocn3 ((VAR_1 + VAR_3-1)/VAR_3+1, VAR_2, sizeof(uint32_t));
if (!VAR_14 || !VAR_15 || !VAR_13 || !VAR_16)
goto cleanup;
VAR_9 = compute_coverage (VAR_14, VAR_0, VAR_2);
VAR_10 = compute_coverage (VAR_15, VAR_1, VAR_3);
assert (VAR_6 + VAR_4 <= VAR_2);
for (VAR_11 = 0; VAR_11 < VAR_5; VAR_11++)
{
int VAR_21 = 1 << VAR_22;
int VAR_23 = VAR_15[VAR_11];
VAR_21 -= VAR_23;
VAR_12++;
while (VAR_21 >= VAR_10)
{
VAR_21 -= VAR_10;
VAR_12++;
}
}
for (; VAR_11 < VAR_5 + VAR_7; VAR_11++)
{
int VAR_24 = 0;
int VAR_21 = 1 << VAR_22;
int VAR_23 = VAR_15[VAR_11];
getRow(VAR_12, VAR_13);
downsample_row_box_filter (VAR_4, VAR_6, VAR_13, VAR_16 + VAR_6 * VAR_24, VAR_14, VAR_9);
VAR_24++;
VAR_12++;
VAR_21 -= VAR_23;
while (VAR_21 >= VAR_10)
{
getRow(VAR_12, VAR_13);
downsample_row_box_filter (VAR_4, VAR_6, VAR_13, VAR_16 + VAR_6 * VAR_24, VAR_14, VAR_9);
VAR_24++;
VAR_12++;
VAR_21 -= VAR_10;
}
if (VAR_21 > 0)
{
getRow(VAR_12, VAR_13);
downsample_row_box_filter (VAR_4, VAR_6, VAR_13, VAR_16 + VAR_6 * VAR_24, VAR_14, VAR_9);
VAR_24++;
}
downsample_columns_box_filter (VAR_6, VAR_23, VAR_10, VAR_16, VAR_18);
VAR_18 += VAR_19 / 4;
}
VAR_17 = true;
cleanup:
free (VAR_14);
free (VAR_15);
free (VAR_16);
free (VAR_13);
return VAR_17;
}",poppler/8122f6d6d409b53151a20c5578fc525ee97315e8/CairoRescaleBox.cc/vul/before/1.json,"bool CairoRescaleBox::downScaleImage(unsigned orig_width, unsigned orig_height,
                                      signed scaled_width, signed scaled_height,
                                      unsigned short int start_column, unsigned short int start_row,
                                      unsigned short int width, unsigned short int height,
                                      cairo_surface_t *dest_surface) {
  int pixel_coverage_x, pixel_coverage_y;
  int dest_y;
  int src_y = 0;
  uint32_t *scanline;
  int *x_coverage = nullptr;
  int *y_coverage = nullptr;
  uint32_t *temp_buf = nullptr;
  bool retval = false;
  unsigned int *dest;
  int dst_stride;

  dest = reinterpret_cast<unsigned int *>(cairo_image_surface_get_data (dest_surface));
  dst_stride = cairo_image_surface_get_stride (dest_surface);

  scanline = (uint32_t*)gmallocn (orig_width, sizeof(int));

  x_coverage = (int *)gmallocn (orig_width, sizeof(int));
  y_coverage = (int *)gmallocn (orig_height, sizeof(int));

  /* we need to allocate enough room for ceil(src_height/dest_height)+1
     Example:
     src_height = 140
     dest_height = 50
     src_height/dest_height = 2.8

     |-------------|       2.8 pixels
     |----|----|----|----| 4 pixels
     need to sample 3 pixels

     |-------------|       2.8 pixels
     |----|----|----|----| 4 pixels
     need to sample 4 pixels
  */

  temp_buf = (uint32_t *)gmallocn3 ((orig_height + scaled_height-1)/scaled_height+1, scaled_width, sizeof(uint32_t));

  if (!x_coverage || !y_coverage || !scanline || !temp_buf)
    goto cleanup;

  pixel_coverage_x = compute_coverage (x_coverage, orig_width, scaled_width);
  pixel_coverage_y = compute_coverage (y_coverage, orig_height, scaled_height);

  assert (width + start_column <= scaled_width);



  /* skip the rows at the beginning */
  for (dest_y = 0; dest_y < start_row; dest_y++)
  {
    int box = 1 << FIXED_SHIFT;
    int start_coverage_y = y_coverage[dest_y];
    box -= start_coverage_y;
    src_y++;
    while (box >= pixel_coverage_y)
    {
      box -= pixel_coverage_y;
      src_y++;
    }
  }

  for (; dest_y < start_row + height; dest_y++)
  {
    int columns = 0;
    int box = 1 << FIXED_SHIFT;
    int start_coverage_y = y_coverage[dest_y];

    getRow(src_y, scanline);
    downsample_row_box_filter (start_column, width, scanline, scanline + orig_width, temp_buf + width * columns, x_coverage, pixel_coverage_x);
    columns++;
    src_y++;
    box -= start_coverage_y;

    while (box >= pixel_coverage_y)
    {
      getRow(src_y, scanline);
      downsample_row_box_filter (start_column, width, scanline, scanline + orig_width, temp_buf + width * columns, x_coverage, pixel_coverage_x);
      columns++;
      src_y++;
      box -= pixel_coverage_y;
    }

    /* downsample any leftovers */
    if (box > 0)
    {
      getRow(src_y, scanline);
      downsample_row_box_filter (start_column, width, scanline, scanline + orig_width, temp_buf + width * columns, x_coverage, pixel_coverage_x);
      columns++;
    }

    /* now scale the rows we just downsampled in the y direction */
    downsample_columns_box_filter (width, start_coverage_y, pixel_coverage_y, temp_buf, dest);
    dest += dst_stride / 4;

//        assert(width*columns <= ((orig_height + scaled_height-1)/scaled_height+1) * width);
  }
//    assert (src_y<=orig_height);

  retval = true;

cleanup:
  free (x_coverage);
  free (y_coverage);
  free (temp_buf);
  free (scanline);

  return retval;
}","bool CairoRescaleBox::downScaleImage(unsigned VAR_0, unsigned VAR_1,
                                      signed VAR_2, signed VAR_3,
                                      unsigned short int VAR_4, unsigned short int VAR_5,
                                      unsigned short int VAR_6, unsigned short int VAR_7,
                                      cairo_surface_t *VAR_8) {
  int VAR_9, VAR_10;
  int VAR_11;
  int VAR_12 = 0;
  uint32_t *VAR_13;
  int *VAR_14 = nullptr;
  int *VAR_15 = nullptr;
  uint32_t *VAR_16 = nullptr;
  bool VAR_17 = false;
  unsigned int *VAR_18;
  int VAR_19;

  VAR_18 = VAR_20<unsigned int *>(cairo_image_surface_get_data (VAR_8));
  VAR_19 = cairo_image_surface_get_stride (VAR_8);

  VAR_13 = (uint32_t*)gmallocn (VAR_0, sizeof(int));

  VAR_14 = (int *)gmallocn (VAR_0, sizeof(int));
  VAR_15 = (int *)gmallocn (VAR_1, sizeof(int));

  /* COMMENT_0 */
             
                     
                     
                                 

                                     
                                   
                            

                                     
                                   
                            
    

  VAR_16 = (uint32_t *)gmallocn3 ((VAR_1 + VAR_3-1)/VAR_3+1, VAR_2, sizeof(uint32_t));

  if (!VAR_14 || !VAR_15 || !VAR_13 || !VAR_16)
    goto cleanup;

  VAR_9 = compute_coverage (VAR_14, VAR_0, VAR_2);
  VAR_10 = compute_coverage (VAR_15, VAR_1, VAR_3);

  assert (VAR_6 + VAR_4 <= VAR_2);



  /* COMMENT_11 */
  for (VAR_11 = 0; VAR_11 < VAR_5; VAR_11++)
  {
    int VAR_21 = 1 << VAR_22;
    int VAR_23 = VAR_15[VAR_11];
    VAR_21 -= VAR_23;
    VAR_12++;
    while (VAR_21 >= VAR_10)
    {
      VAR_21 -= VAR_10;
      VAR_12++;
    }
  }

  for (; VAR_11 < VAR_5 + VAR_7; VAR_11++)
  {
    int VAR_24 = 0;
    int VAR_21 = 1 << VAR_22;
    int VAR_23 = VAR_15[VAR_11];

    getRow(VAR_12, VAR_13);
    downsample_row_box_filter (VAR_4, VAR_6, VAR_13, VAR_13 + VAR_0, VAR_16 + VAR_6 * VAR_24, VAR_14, VAR_9);
    VAR_24++;
    VAR_12++;
    VAR_21 -= VAR_23;

    while (VAR_21 >= VAR_10)
    {
      getRow(VAR_12, VAR_13);
      downsample_row_box_filter (VAR_4, VAR_6, VAR_13, VAR_13 + VAR_0, VAR_16 + VAR_6 * VAR_24, VAR_14, VAR_9);
      VAR_24++;
      VAR_12++;
      VAR_21 -= VAR_10;
    }

    /* COMMENT_12 */
    if (VAR_21 > 0)
    {
      getRow(VAR_12, VAR_13);
      downsample_row_box_filter (VAR_4, VAR_6, VAR_13, VAR_13 + VAR_0, VAR_16 + VAR_6 * VAR_24, VAR_14, VAR_9);
      VAR_24++;
    }

    /* COMMENT_13 */
    downsample_columns_box_filter (VAR_6, VAR_23, VAR_10, VAR_16, VAR_18);
    VAR_18 += VAR_19 / 4;

/* COMMENT_14 */
  }
/* COMMENT_15 */

  VAR_17 = true;

cleanup:
  free (VAR_14);
  free (VAR_15);
  free (VAR_16);
  free (VAR_13);

  return VAR_17;
}",poppler/8122f6d6d409b53151a20c5578fc525ee97315e8/CairoRescaleBox.cc/vul/after/1.json,"--- func_before
+++ func_after
@@ -70,7 +70,7 @@
     int start_coverage_y = y_coverage[dest_y];
 
     getRow(src_y, scanline);
-    downsample_row_box_filter (start_column, width, scanline, temp_buf + width * columns, x_coverage, pixel_coverage_x);
+    downsample_row_box_filter (start_column, width, scanline, scanline + orig_width, temp_buf + width * columns, x_coverage, pixel_coverage_x);
     columns++;
     src_y++;
     box -= start_coverage_y;
@@ -78,7 +78,7 @@
     while (box >= pixel_coverage_y)
     {
       getRow(src_y, scanline);
-      downsample_row_box_filter (start_column, width, scanline, temp_buf + width * columns, x_coverage, pixel_coverage_x);
+      downsample_row_box_filter (start_column, width, scanline, scanline + orig_width, temp_buf + width * columns, x_coverage, pixel_coverage_x);
       columns++;
       src_y++;
       box -= pixel_coverage_y;
@@ -88,7 +88,7 @@
     if (box > 0)
     {
       getRow(src_y, scanline);
-      downsample_row_box_filter (start_column, width, scanline, temp_buf + width * columns, x_coverage, pixel_coverage_x);
+      downsample_row_box_filter (start_column, width, scanline, scanline + orig_width, temp_buf + width * columns, x_coverage, pixel_coverage_x);
       columns++;
     }
 ","{'deleted_lines': ['    downsample_row_box_filter (start_column, width, scanline, temp_buf + width * columns, x_coverage, pixel_coverage_x);', '      downsample_row_box_filter (start_column, width, scanline, temp_buf + width * columns, x_coverage, pixel_coverage_x);', '      downsample_row_box_filter (start_column, width, scanline, temp_buf + width * columns, x_coverage, pixel_coverage_x);'], 'added_lines': ['    downsample_row_box_filter (start_column, width, scanline, scanline + orig_width, temp_buf + width * columns, x_coverage, pixel_coverage_x);', '      downsample_row_box_filter (start_column, width, scanline, scanline + orig_width, temp_buf + width * columns, x_coverage, pixel_coverage_x);', '      downsample_row_box_filter (start_column, width, scanline, scanline + orig_width, temp_buf + width * columns, x_coverage, pixel_coverage_x);']}",True,Poppler 0.74.0 has a heap-based buffer over-read in the CairoRescaleBox.cc downsample_row_box_filter function.,9.8,CRITICAL,3,test,,5
CVE-2021-40490,['CWE-362'],AV:L/AC:M/Au:N/C:P/I:P/A:P,0,kernel/git/tytso/ext4,"The location of the system.data extended attribute can change whenever
xattr_sem is not taken.  So we need to recalculate the i_inline_off
field since it mgiht have changed between ext4_write_begin() and
ext4_write_end().

This means that caching i_inline_off is probably not helpful, so in
the long run we should probably get rid of it and shrink the in-memory
ext4 inode slightly, but let's fix the race the simple way for now.

Cc: stable@kernel.org
Fixes: f19d5870cbf72 (""ext4: add normal write support for inline data"")
Reported-by: syzbot+13146364637c7363a7de@syzkaller.appspotmail.com
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
",9e445093e523f3277081314c864f708fd4bd34aa,https://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4.git/commit/?h=9e445093e523f3277081314c864f708fd4bd34aa,fs/ext4/inline.c,ext4_write_inline_data_end,"int ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,
unsigned copied, struct page *page)
{
int ret, no_expand;
void *kaddr;
struct ext4_iloc iloc;
if (unlikely(copied < len)) {
if (!PageUptodate(page)) {
copied = 0;
goto out;
}
}
ret = ext4_get_inode_loc(inode, &iloc);
if (ret) {
ext4_std_error(inode->i_sb, ret);
copied = 0;
goto out;
}
ext4_write_lock_xattr(inode, &no_expand);
BUG_ON(!ext4_has_inline_data(inode));
kaddr = kmap_atomic(page);
ext4_write_inline_data(inode, &iloc, kaddr, pos, len);
kunmap_atomic(kaddr);
SetPageUptodate(page);
ClearPageDirty(page);
ext4_write_unlock_xattr(inode, &no_expand);
brelse(iloc.bh);
mark_inode_dirty(inode);
out:
return copied;
}","int ext4_write_inline_data_end(struct inode *inode, loff_t VAR_0, unsigned VAR_1,
unsigned VAR_2, struct page *page)
{
int VAR_3, VAR_4;
void *VAR_5;
struct ext4_iloc VAR_6;
if (unlikely(VAR_2 < VAR_1)) {
if (!PageUptodate(page)) {
VAR_2 = 0;
goto out;
}
}
VAR_3 = ext4_get_inode_loc(inode, &VAR_6);
if (VAR_3) {
ext4_std_error(inode->i_sb, VAR_3);
VAR_2 = 0;
goto out;
}
ext4_write_lock_xattr(inode, &VAR_4);
BUG_ON(!ext4_has_inline_data(inode));
VAR_5 = kmap_atomic(page);
ext4_write_inline_data(inode, &VAR_6, VAR_5, VAR_0, VAR_1);
kunmap_atomic(VAR_5);
SetPageUptodate(page);
ClearPageDirty(page);
ext4_write_unlock_xattr(inode, &VAR_4);
brelse(VAR_6.bh);
mark_inode_dirty(inode);
out:
return VAR_2;
}",kernel/git/tytso/ext4/9e445093e523f3277081314c864f708fd4bd34aa/inline.c/vul/before/0.json,"int ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,
			       unsigned copied, struct page *page)
{
	int ret, no_expand;
	void *kaddr;
	struct ext4_iloc iloc;

	if (unlikely(copied < len)) {
		if (!PageUptodate(page)) {
			copied = 0;
			goto out;
		}
	}

	ret = ext4_get_inode_loc(inode, &iloc);
	if (ret) {
		ext4_std_error(inode->i_sb, ret);
		copied = 0;
		goto out;
	}

	ext4_write_lock_xattr(inode, &no_expand);
	BUG_ON(!ext4_has_inline_data(inode));

	/*
	 * ei->i_inline_off may have changed since ext4_write_begin()
	 * called ext4_try_to_write_inline_data()
	 */
	(void) ext4_find_inline_data_nolock(inode);

	kaddr = kmap_atomic(page);
	ext4_write_inline_data(inode, &iloc, kaddr, pos, len);
	kunmap_atomic(kaddr);
	SetPageUptodate(page);
	/* clear page dirty so that writepages wouldn't work for us. */
	ClearPageDirty(page);

	ext4_write_unlock_xattr(inode, &no_expand);
	brelse(iloc.bh);
	mark_inode_dirty(inode);
out:
	return copied;
}","int ext4_write_inline_data_end(struct inode *inode, loff_t VAR_0, unsigned VAR_1,
			       unsigned VAR_2, struct page *page)
{
	int VAR_3, VAR_4;
	void *VAR_5;
	struct ext4_iloc VAR_6;

	if (unlikely(VAR_2 < VAR_1)) {
		if (!PageUptodate(page)) {
			VAR_2 = 0;
			goto out;
		}
	}

	VAR_3 = ext4_get_inode_loc(inode, &VAR_6);
	if (VAR_3) {
		ext4_std_error(inode->i_sb, VAR_3);
		VAR_2 = 0;
		goto out;
	}

	ext4_write_lock_xattr(inode, &VAR_4);
	BUG_ON(!ext4_has_inline_data(inode));

	/* COMMENT_0 */
                                                              
                                          
    
	(void) ext4_find_inline_data_nolock(inode);

	VAR_5 = kmap_atomic(page);
	ext4_write_inline_data(inode, &VAR_6, VAR_5, VAR_0, VAR_1);
	kunmap_atomic(VAR_5);
	SetPageUptodate(page);
	/* COMMENT_4 */
	ClearPageDirty(page);

	ext4_write_unlock_xattr(inode, &VAR_4);
	brelse(VAR_6.bh);
	mark_inode_dirty(inode);
out:
	return VAR_2;
}",kernel/git/tytso/ext4/9e445093e523f3277081314c864f708fd4bd34aa/inline.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -22,6 +22,12 @@
 	ext4_write_lock_xattr(inode, &no_expand);
 	BUG_ON(!ext4_has_inline_data(inode));
 
+	/*
+	 * ei->i_inline_off may have changed since ext4_write_begin()
+	 * called ext4_try_to_write_inline_data()
+	 */
+	(void) ext4_find_inline_data_nolock(inode);
+
 	kaddr = kmap_atomic(page);
 	ext4_write_inline_data(inode, &iloc, kaddr, pos, len);
 	kunmap_atomic(kaddr);","{'deleted_lines': [], 'added_lines': ['\t/*', '\t * ei->i_inline_off may have changed since ext4_write_begin()', '\t * called ext4_try_to_write_inline_data()', '\t */', '\t(void) ext4_find_inline_data_nolock(inode);', '']}",True,A race condition was discovered in ext4_write_inline_data_end in fs/ext4/inline.c in the ext4 subsystem in the Linux kernel through 5.13.13.,7.0,HIGH,2,test,,5
CVE-2017-16827,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,binutils-gdb,"
PR22306, Invalid free() in slurp_symtab()

	PR 22306
	* aoutx.h (aout_get_external_symbols): Handle stringsize of zero,
	and error for any other size that doesn't cover the header word.
",0301ce1486b1450f219202677f30d0fa97335419,https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=0301ce1486b1450f219202677f30d0fa97335419,bfd/aoutx.h,aout_get_external_symbols,"static bfd_boolean
aout_get_external_symbols (bfd *abfd)
{
if (obj_aout_external_syms (abfd) == NULL)
{
bfd_size_type count;
struct external_nlist *syms;
bfd_size_type amt = exec_hdr (abfd)->a_syms;
count = amt / EXTERNAL_NLIST_SIZE;
if (count == 0)
return TRUE;
#ifdef USE_MMAP
if (! bfd_get_file_window (abfd, obj_sym_filepos (abfd), amt,
&obj_aout_sym_window (abfd), TRUE))
return FALSE;
syms = (struct external_nlist *) obj_aout_sym_window (abfd).data;
#else
syms = (struct external_nlist *) bfd_malloc (amt);
if (syms == NULL)
return FALSE;
if (bfd_seek (abfd, obj_sym_filepos (abfd), SEEK_SET) != 0
|| bfd_bread (syms, amt, abfd) != amt)
{
free (syms);
return FALSE;
}
#endif
obj_aout_external_syms (abfd) = syms;
obj_aout_external_sym_count (abfd) = count;
}
if (obj_aout_external_strings (abfd) == NULL
&& exec_hdr (abfd)->a_syms != 0)
{
unsigned char string_chars[BYTES_IN_WORD];
bfd_size_type stringsize;
char *strings;
bfd_size_type amt = BYTES_IN_WORD;
if (bfd_seek (abfd, obj_str_filepos (abfd), SEEK_SET) != 0
|| bfd_bread ((void *) string_chars, amt, abfd) != amt)
return FALSE;
stringsize = GET_WORD (abfd, string_chars);
#ifdef USE_MMAP
if (! bfd_get_file_window (abfd, obj_str_filepos (abfd), stringsize,
&obj_aout_string_window (abfd), TRUE))
return FALSE;
strings = (char *) obj_aout_string_window (abfd).data;
#else
strings = (char *) bfd_malloc (stringsize + 1);
if (strings == NULL)
return FALSE;
amt = stringsize - BYTES_IN_WORD;
if (bfd_bread (strings + BYTES_IN_WORD, amt, abfd) != amt)
{
free (strings);
return FALSE;
}
#endif
strings[0] = '\0';
strings[stringsize - 1] = 0;
obj_aout_external_strings (abfd) = strings;
obj_aout_external_string_size (abfd) = stringsize;
}
return TRUE;
}","static bfd_boolean
aout_get_external_symbols (bfd *VAR_0)
{
if (obj_aout_external_syms (VAR_0) == NULL)
{
bfd_size_type VAR_1;
struct external_nlist *VAR_2;
bfd_size_type VAR_3 = exec_hdr (VAR_0)->a_syms;
VAR_1 = VAR_3 / VAR_4;
if (VAR_1 == 0)
return TRUE;
#ifdef VAR_5
if (! bfd_get_file_window (VAR_0, obj_sym_filepos (VAR_0), VAR_3,
&obj_aout_sym_window (VAR_0), TRUE))
return FALSE;
VAR_2 = (struct external_nlist *) obj_aout_sym_window (VAR_0).data;
#else
VAR_2 = (struct external_nlist *) bfd_malloc (VAR_3);
if (VAR_2 == NULL)
return FALSE;
if (bfd_seek (VAR_0, obj_sym_filepos (VAR_0), VAR_6) != 0
|| bfd_bread (VAR_2, VAR_3, VAR_0) != VAR_3)
{
free (VAR_2);
return FALSE;
}
#endif
obj_aout_external_syms (VAR_0) = VAR_2;
obj_aout_external_sym_count (VAR_0) = VAR_1;
}
if (obj_aout_external_strings (VAR_0) == NULL
&& exec_hdr (VAR_0)->a_syms != 0)
{
unsigned char VAR_7[VAR_8];
bfd_size_type VAR_9;
char *VAR_10;
bfd_size_type VAR_3 = VAR_8;
if (bfd_seek (VAR_0, obj_str_filepos (VAR_0), VAR_6) != 0
|| bfd_bread ((void *) VAR_7, VAR_3, VAR_0) != VAR_3)
return FALSE;
VAR_9 = GET_WORD (VAR_0, VAR_7);
#ifdef VAR_5
if (! bfd_get_file_window (VAR_0, obj_str_filepos (VAR_0), VAR_9,
&obj_aout_string_window (VAR_0), TRUE))
return FALSE;
VAR_10 = (char *) obj_aout_string_window (VAR_0).data;
#else
VAR_10 = (char *) bfd_malloc (VAR_9 + 1);
if (VAR_10 == NULL)
return FALSE;
VAR_3 = VAR_9 - VAR_8;
if (bfd_bread (VAR_10 + VAR_8, VAR_3, VAR_0) != VAR_3)
{
free (VAR_10);
return FALSE;
}
#endif
VAR_10[0] = '\0';
VAR_10[VAR_9 - 1] = 0;
obj_aout_external_strings (VAR_0) = VAR_10;
obj_aout_external_string_size (VAR_0) = VAR_9;
}
return TRUE;
}",binutils-gdb/0301ce1486b1450f219202677f30d0fa97335419/aoutx.h/vul/before/0.json,"static bfd_boolean
aout_get_external_symbols (bfd *abfd)
{
  if (obj_aout_external_syms (abfd) == NULL)
    {
      bfd_size_type count;
      struct external_nlist *syms;
      bfd_size_type amt = exec_hdr (abfd)->a_syms;

      count = amt / EXTERNAL_NLIST_SIZE;
      if (count == 0)
	return TRUE;		/* Nothing to do.  */

#ifdef USE_MMAP
      if (! bfd_get_file_window (abfd, obj_sym_filepos (abfd), amt,
				 &obj_aout_sym_window (abfd), TRUE))
	return FALSE;
      syms = (struct external_nlist *) obj_aout_sym_window (abfd).data;
#else
      /* We allocate using malloc to make the values easy to free
	 later on.  If we put them on the objalloc it might not be
	 possible to free them.  */
      syms = (struct external_nlist *) bfd_malloc (amt);
      if (syms == NULL)
	return FALSE;

      if (bfd_seek (abfd, obj_sym_filepos (abfd), SEEK_SET) != 0
	  || bfd_bread (syms, amt, abfd) != amt)
	{
	  free (syms);
	  return FALSE;
	}
#endif

      obj_aout_external_syms (abfd) = syms;
      obj_aout_external_sym_count (abfd) = count;
    }

  if (obj_aout_external_strings (abfd) == NULL
      && exec_hdr (abfd)->a_syms != 0)
    {
      unsigned char string_chars[BYTES_IN_WORD];
      bfd_size_type stringsize;
      char *strings;
      bfd_size_type amt = BYTES_IN_WORD;

      /* Get the size of the strings.  */
      if (bfd_seek (abfd, obj_str_filepos (abfd), SEEK_SET) != 0
	  || bfd_bread ((void *) string_chars, amt, abfd) != amt)
	return FALSE;
      stringsize = GET_WORD (abfd, string_chars);
      if (stringsize == 0)
	stringsize = 1;
      else if (stringsize < BYTES_IN_WORD
	       || (size_t) stringsize != stringsize)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

#ifdef USE_MMAP
      if (stringsize >= BYTES_IN_WORD)
	{
	  if (! bfd_get_file_window (abfd, obj_str_filepos (abfd), stringsize,
				     &obj_aout_string_window (abfd), TRUE))
	    return FALSE;
	  strings = (char *) obj_aout_string_window (abfd).data;
	}
      else
#endif
	{
	  strings = (char *) bfd_malloc (stringsize);
	  if (strings == NULL)
	    return FALSE;

	  if (stringsize >= BYTES_IN_WORD)
	    {
	      /* Keep the string count in the buffer for convenience
		 when indexing with e_strx.  */
	      amt = stringsize - BYTES_IN_WORD;
	      if (bfd_bread (strings + BYTES_IN_WORD, amt, abfd) != amt)
		{
		  free (strings);
		  return FALSE;
		}
	    }
	}
      /* Ensure that a zero index yields an empty string.  */
      strings[0] = '\0';

      strings[stringsize - 1] = 0;

      obj_aout_external_strings (abfd) = strings;
      obj_aout_external_string_size (abfd) = stringsize;
    }

  return TRUE;
}","static bfd_boolean
aout_get_external_symbols (bfd *VAR_0)
{
  if (obj_aout_external_syms (VAR_0) == NULL)
    {
      bfd_size_type VAR_1;
      struct external_nlist *VAR_2;
      bfd_size_type VAR_3 = exec_hdr (VAR_0)->a_syms;

      VAR_1 = VAR_3 / VAR_4;
      if (VAR_1 == 0)
	return TRUE;		/* COMMENT_0 */

#ifdef VAR_5
      if (! bfd_get_file_window (VAR_0, obj_sym_filepos (VAR_0), VAR_3,
				 &obj_aout_sym_window (VAR_0), TRUE))
	return FALSE;
      VAR_2 = (struct external_nlist *) obj_aout_sym_window (VAR_0).data;
#else
      /* COMMENT_1 */
                                                           
                            
      VAR_2 = (struct external_nlist *) bfd_malloc (VAR_3);
      if (VAR_2 == NULL)
	return FALSE;

      if (bfd_seek (VAR_0, obj_sym_filepos (VAR_0), VAR_6) != 0
	  || bfd_bread (VAR_2, VAR_3, VAR_0) != VAR_3)
	{
	  free (VAR_2);
	  return FALSE;
	}
#endif

      obj_aout_external_syms (VAR_0) = VAR_2;
      obj_aout_external_sym_count (VAR_0) = VAR_1;
    }

  if (obj_aout_external_strings (VAR_0) == NULL
      && exec_hdr (VAR_0)->a_syms != 0)
    {
      unsigned char VAR_7[VAR_8];
      bfd_size_type VAR_9;
      char *VAR_10;
      bfd_size_type VAR_3 = VAR_8;

      /* COMMENT_4 */
      if (bfd_seek (VAR_0, obj_str_filepos (VAR_0), VAR_6) != 0
	  || bfd_bread ((void *) VAR_7, VAR_3, VAR_0) != VAR_3)
	return FALSE;
      VAR_9 = GET_WORD (VAR_0, VAR_7);
      if (VAR_9 == 0)
	VAR_9 = 1;
      else if (VAR_9 < VAR_8
	       || (size_t) VAR_9 != VAR_9)
	{
	  bfd_set_error (VAR_11);
	  return FALSE;
	}

#ifdef VAR_5
      if (VAR_9 >= VAR_8)
	{
	  if (! bfd_get_file_window (VAR_0, obj_str_filepos (VAR_0), VAR_9,
				     &obj_aout_string_window (VAR_0), TRUE))
	    return FALSE;
	  VAR_10 = (char *) obj_aout_string_window (VAR_0).data;
	}
      else
#endif
	{
	  VAR_10 = (char *) bfd_malloc (VAR_9);
	  if (VAR_10 == NULL)
	    return FALSE;

	  if (VAR_9 >= VAR_8)
	    {
	      /* COMMENT_5 */
                                 
	      VAR_3 = VAR_9 - VAR_8;
	      if (bfd_bread (VAR_10 + VAR_8, VAR_3, VAR_0) != VAR_3)
		{
		  free (VAR_10);
		  return FALSE;
		}
	    }
	}
      /* COMMENT_7 */
      VAR_10[0] = '\0';

      VAR_10[VAR_9 - 1] = 0;

      obj_aout_external_strings (VAR_0) = VAR_10;
      obj_aout_external_string_size (VAR_0) = VAR_9;
    }

  return TRUE;
}",binutils-gdb/0301ce1486b1450f219202677f30d0fa97335419/aoutx.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -49,27 +49,42 @@
 	  || bfd_bread ((void *) string_chars, amt, abfd) != amt)
 	return FALSE;
       stringsize = GET_WORD (abfd, string_chars);
+      if (stringsize == 0)
+	stringsize = 1;
+      else if (stringsize < BYTES_IN_WORD
+	       || (size_t) stringsize != stringsize)
+	{
+	  bfd_set_error (bfd_error_bad_value);
+	  return FALSE;
+	}
 
 #ifdef USE_MMAP
-      if (! bfd_get_file_window (abfd, obj_str_filepos (abfd), stringsize,
-				 &obj_aout_string_window (abfd), TRUE))
-	return FALSE;
-      strings = (char *) obj_aout_string_window (abfd).data;
-#else
-      strings = (char *) bfd_malloc (stringsize + 1);
-      if (strings == NULL)
-	return FALSE;
+      if (stringsize >= BYTES_IN_WORD)
+	{
+	  if (! bfd_get_file_window (abfd, obj_str_filepos (abfd), stringsize,
+				     &obj_aout_string_window (abfd), TRUE))
+	    return FALSE;
+	  strings = (char *) obj_aout_string_window (abfd).data;
+	}
+      else
+#endif
+	{
+	  strings = (char *) bfd_malloc (stringsize);
+	  if (strings == NULL)
+	    return FALSE;
 
-      /* Skip space for the string count in the buffer for convenience
-	 when using indexes.  */
-      amt = stringsize - BYTES_IN_WORD;
-      if (bfd_bread (strings + BYTES_IN_WORD, amt, abfd) != amt)
-	{
-	  free (strings);
-	  return FALSE;
+	  if (stringsize >= BYTES_IN_WORD)
+	    {
+	      /* Keep the string count in the buffer for convenience
+		 when indexing with e_strx.  */
+	      amt = stringsize - BYTES_IN_WORD;
+	      if (bfd_bread (strings + BYTES_IN_WORD, amt, abfd) != amt)
+		{
+		  free (strings);
+		  return FALSE;
+		}
+	    }
 	}
-#endif
-
       /* Ensure that a zero index yields an empty string.  */
       strings[0] = '\0';
 ","{'deleted_lines': ['      if (! bfd_get_file_window (abfd, obj_str_filepos (abfd), stringsize,', '\t\t\t\t &obj_aout_string_window (abfd), TRUE))', '\treturn FALSE;', '      strings = (char *) obj_aout_string_window (abfd).data;', '#else', '      strings = (char *) bfd_malloc (stringsize + 1);', '      if (strings == NULL)', '\treturn FALSE;', '      /* Skip space for the string count in the buffer for convenience', '\t when using indexes.  */', '      amt = stringsize - BYTES_IN_WORD;', '      if (bfd_bread (strings + BYTES_IN_WORD, amt, abfd) != amt)', '\t{', '\t  free (strings);', '\t  return FALSE;', '#endif', ''], 'added_lines': ['      if (stringsize == 0)', '\tstringsize = 1;', '      else if (stringsize < BYTES_IN_WORD', '\t       || (size_t) stringsize != stringsize)', '\t{', '\t  bfd_set_error (bfd_error_bad_value);', '\t  return FALSE;', '\t}', '      if (stringsize >= BYTES_IN_WORD)', '\t{', '\t  if (! bfd_get_file_window (abfd, obj_str_filepos (abfd), stringsize,', '\t\t\t\t     &obj_aout_string_window (abfd), TRUE))', '\t    return FALSE;', '\t  strings = (char *) obj_aout_string_window (abfd).data;', '\t}', '      else', '#endif', '\t{', '\t  strings = (char *) bfd_malloc (stringsize);', '\t  if (strings == NULL)', '\t    return FALSE;', '\t  if (stringsize >= BYTES_IN_WORD)', '\t    {', '\t      /* Keep the string count in the buffer for convenience', '\t\t when indexing with e_strx.  */', '\t      amt = stringsize - BYTES_IN_WORD;', '\t      if (bfd_bread (strings + BYTES_IN_WORD, amt, abfd) != amt)', '\t\t{', '\t\t  free (strings);', '\t\t  return FALSE;', '\t\t}', '\t    }']}",True,"The aout_get_external_symbols function in aoutx.h in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29.1, allows remote attackers to cause a denial of service (slurp_symtab invalid free and application crash) or possibly have unspecified other impact via a crafted ELF file.",7.8,HIGH,2,test,,5
CVE-2017-16832,['CWE-190'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,binutils-gdb,"
Fix illegal memory access triggered when parsing a PE binary with a corrupt data dictionary.

	PR 22373
	* peicode.h (pe_bfd_read_buildid): Check for invalid size and data
	offset values.
",0bb6961f18b8e832d88b490d421ca56cea16c45b,https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=0bb6961f18b8e832d88b490d421ca56cea16c45b,bfd/peicode.h,pe_bfd_read_buildid,"static void
pe_bfd_read_buildid (bfd *abfd)
{
pe_data_type *pe = pe_data (abfd);
struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;
asection *section;
bfd_byte *data = 0;
bfd_size_type dataoff;
unsigned int i;
bfd_vma addr = extra->DataDirectory[PE_DEBUG_DATA].VirtualAddress;
bfd_size_type size = extra->DataDirectory[PE_DEBUG_DATA].Size;
if (size == 0)
return;
addr += extra->ImageBase;
for (section = abfd->sections; section != NULL; section = section->next)
{
if ((addr >= section->vma) && (addr < (section->vma + section->size)))
break;
}
if (section == NULL)
return;
if (!(section->flags & SEC_HAS_CONTENTS))
return;
dataoff = addr - section->vma;
if (dataoff + size > section->size)
{
_bfd_error_handler (_(""%B: Error: Debug Data ends beyond end of debug directory.""),
abfd);
return;
}
if (!bfd_malloc_and_get_section (abfd, section, &data))
{
if (data != NULL)
free (data);
return;
}
for (i = 0; i < size / sizeof (struct external_IMAGE_DEBUG_DIRECTORY); i++)
{
struct external_IMAGE_DEBUG_DIRECTORY *ext
= &((struct external_IMAGE_DEBUG_DIRECTORY *)(data + dataoff))[i];
struct internal_IMAGE_DEBUG_DIRECTORY idd;
_bfd_XXi_swap_debugdir_in (abfd, ext, &idd);
if (idd.Type == PE_IMAGE_DEBUG_TYPE_CODEVIEW)
{
char buffer[256 + 1];
CODEVIEW_INFO *cvinfo = (CODEVIEW_INFO *) buffer;
if (_bfd_XXi_slurp_codeview_record (abfd,
(file_ptr) idd.PointerToRawData,
idd.SizeOfData, cvinfo))
{
struct bfd_build_id* build_id = bfd_alloc (abfd,
sizeof (struct bfd_build_id) + cvinfo->SignatureLength);
if (build_id)
{
build_id->size = cvinfo->SignatureLength;
memcpy(build_id->data,  cvinfo->Signature,
cvinfo->SignatureLength);
abfd->build_id = build_id;
}
}
break;
}
}
}","static void
pe_bfd_read_buildid (bfd *VAR_0)
{
pe_data_type *VAR_1 = pe_data (VAR_0);
struct internal_extra_pe_aouthdr *VAR_2 = &VAR_1->pe_opthdr;
asection *VAR_3;
bfd_byte *VAR_4 = 0;
bfd_size_type VAR_5;
unsigned int VAR_6;
bfd_vma VAR_7 = VAR_2->DataDirectory[VAR_8].VirtualAddress;
bfd_size_type VAR_9 = VAR_2->DataDirectory[VAR_8].Size;
if (VAR_9 == 0)
return;
VAR_7 += VAR_2->ImageBase;
for (VAR_3 = VAR_0->sections; VAR_3 != NULL; VAR_3 = VAR_3->next)
{
if ((VAR_7 >= VAR_3->vma) && (VAR_7 < (VAR_3->vma + VAR_3->size)))
break;
}
if (VAR_3 == NULL)
return;
if (!(VAR_3->flags & VAR_10))
return;
VAR_5 = VAR_7 - VAR_3->vma;
if (VAR_5 + VAR_9 > VAR_3->size)
{
_bfd_error_handler (_(""%B: Error: Debug Data ends beyond end of debug directory.""),
VAR_0);
return;
}
if (!bfd_malloc_and_get_section (VAR_0, VAR_3, &VAR_4))
{
if (VAR_4 != NULL)
free (VAR_4);
return;
}
for (VAR_6 = 0; VAR_6 < VAR_9 / sizeof (struct external_IMAGE_DEBUG_DIRECTORY); VAR_6++)
{
struct external_IMAGE_DEBUG_DIRECTORY *VAR_11
= &((struct external_IMAGE_DEBUG_DIRECTORY *)(VAR_4 + VAR_5))[VAR_6];
struct internal_IMAGE_DEBUG_DIRECTORY VAR_12;
_bfd_XXi_swap_debugdir_in (VAR_0, VAR_11, &VAR_12);
if (VAR_12.Type == VAR_13)
{
char VAR_14[256 + 1];
CODEVIEW_INFO *VAR_15 = (CODEVIEW_INFO *) VAR_14;
if (_bfd_XXi_slurp_codeview_record (VAR_0,
(file_ptr) VAR_12.PointerToRawData,
VAR_12.SizeOfData, VAR_15))
{
struct bfd_build_id* VAR_16 = bfd_alloc (VAR_0,
sizeof (struct bfd_build_id) + VAR_15->SignatureLength);
if (VAR_16)
{
VAR_16->size = VAR_15->SignatureLength;
memcpy(VAR_16->data,  VAR_15->Signature,
VAR_15->SignatureLength);
VAR_0->build_id = VAR_16;
}
}
break;
}
}
}",binutils-gdb/0bb6961f18b8e832d88b490d421ca56cea16c45b/peicode.h/vul/before/0.json,"static void
pe_bfd_read_buildid (bfd *abfd)
{
  pe_data_type *pe = pe_data (abfd);
  struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;
  asection *section;
  bfd_byte *data = 0;
  bfd_size_type dataoff;
  unsigned int i;
  bfd_vma addr = extra->DataDirectory[PE_DEBUG_DATA].VirtualAddress;
  bfd_size_type size = extra->DataDirectory[PE_DEBUG_DATA].Size;

  if (size == 0)
    return;

  addr += extra->ImageBase;

  /* Search for the section containing the DebugDirectory.  */
  for (section = abfd->sections; section != NULL; section = section->next)
    {
      if ((addr >= section->vma) && (addr < (section->vma + section->size)))
        break;
    }

  if (section == NULL)
    return;

  if (!(section->flags & SEC_HAS_CONTENTS))
    return;

  dataoff = addr - section->vma;

  /* PR 20605 and 22373: Make sure that the data is really there.
     Note - since we are dealing with unsigned quantities we have
     to be careful to check for potential overflows.  */
  if (dataoff > section->size
      || size > section->size
      || dataoff + size > section->size)
    {
      _bfd_error_handler (_(""%B: Error: Debug Data ends beyond end of debug directory.""),
			  abfd);
      return;
    }
  
  /* Read the whole section. */
  if (!bfd_malloc_and_get_section (abfd, section, &data))
    {
      if (data != NULL)
	free (data);
      return;
    }

  /* Search for a CodeView entry in the DebugDirectory */
  for (i = 0; i < size / sizeof (struct external_IMAGE_DEBUG_DIRECTORY); i++)
    {
      struct external_IMAGE_DEBUG_DIRECTORY *ext
	= &((struct external_IMAGE_DEBUG_DIRECTORY *)(data + dataoff))[i];
      struct internal_IMAGE_DEBUG_DIRECTORY idd;

      _bfd_XXi_swap_debugdir_in (abfd, ext, &idd);

      if (idd.Type == PE_IMAGE_DEBUG_TYPE_CODEVIEW)
        {
          char buffer[256 + 1];
          CODEVIEW_INFO *cvinfo = (CODEVIEW_INFO *) buffer;

          /*
            The debug entry doesn't have to have to be in a section, in which
            case AddressOfRawData is 0, so always use PointerToRawData.
          */
          if (_bfd_XXi_slurp_codeview_record (abfd,
                                              (file_ptr) idd.PointerToRawData,
                                              idd.SizeOfData, cvinfo))
            {
              struct bfd_build_id* build_id = bfd_alloc (abfd,
                         sizeof (struct bfd_build_id) + cvinfo->SignatureLength);
              if (build_id)
                {
                  build_id->size = cvinfo->SignatureLength;
                  memcpy(build_id->data,  cvinfo->Signature,
                         cvinfo->SignatureLength);
                  abfd->build_id = build_id;
                }
            }
          break;
        }
    }
}","static void
pe_bfd_read_buildid (bfd *VAR_0)
{
  pe_data_type *VAR_1 = pe_data (VAR_0);
  struct internal_extra_pe_aouthdr *VAR_2 = &VAR_1->pe_opthdr;
  asection *VAR_3;
  bfd_byte *VAR_4 = 0;
  bfd_size_type VAR_5;
  unsigned int VAR_6;
  bfd_vma VAR_7 = VAR_2->DataDirectory[VAR_8].VirtualAddress;
  bfd_size_type VAR_9 = VAR_2->DataDirectory[VAR_8].Size;

  if (VAR_9 == 0)
    return;

  VAR_7 += VAR_2->ImageBase;

  /* COMMENT_0 */
  for (VAR_3 = VAR_0->sections; VAR_3 != NULL; VAR_3 = VAR_3->next)
    {
      if ((VAR_7 >= VAR_3->vma) && (VAR_7 < (VAR_3->vma + VAR_3->size)))
        break;
    }

  if (VAR_3 == NULL)
    return;

  if (!(VAR_3->flags & VAR_10))
    return;

  VAR_5 = VAR_7 - VAR_3->vma;

  /* COMMENT_1 */
                                                                 
                                                        
  if (VAR_5 > VAR_3->size
      || VAR_9 > VAR_3->size
      || VAR_5 + VAR_9 > VAR_3->size)
    {
      _bfd_error_handler (_(""%B: Error: Debug Data ends beyond end of debug directory.""),
			  VAR_0);
      return;
    }
  
  /* COMMENT_4 */
  if (!bfd_malloc_and_get_section (VAR_0, VAR_3, &VAR_4))
    {
      if (VAR_4 != NULL)
	free (VAR_4);
      return;
    }

  /* COMMENT_5 */
  for (VAR_6 = 0; VAR_6 < VAR_9 / sizeof (struct external_IMAGE_DEBUG_DIRECTORY); VAR_6++)
    {
      struct external_IMAGE_DEBUG_DIRECTORY *VAR_11
	= &((struct external_IMAGE_DEBUG_DIRECTORY *)(VAR_4 + VAR_5))[VAR_6];
      struct internal_IMAGE_DEBUG_DIRECTORY VAR_12;

      _bfd_XXi_swap_debugdir_in (VAR_0, VAR_11, &VAR_12);

      if (VAR_12.Type == VAR_13)
        {
          char VAR_14[256 + 1];
          CODEVIEW_INFO *VAR_15 = (CODEVIEW_INFO *) VAR_14;

          /* COMMENT_6 */
                                                                             
                                                                       
            
          if (_bfd_XXi_slurp_codeview_record (VAR_0,
                                              (file_ptr) VAR_12.PointerToRawData,
                                              VAR_12.SizeOfData, VAR_15))
            {
              struct bfd_build_id* VAR_16 = bfd_alloc (VAR_0,
                         sizeof (struct bfd_build_id) + VAR_15->SignatureLength);
              if (VAR_16)
                {
                  VAR_16->size = VAR_15->SignatureLength;
                  memcpy(VAR_16->data,  VAR_15->Signature,
                         VAR_15->SignatureLength);
                  VAR_0->build_id = VAR_16;
                }
            }
          break;
        }
    }
}",binutils-gdb/0bb6961f18b8e832d88b490d421ca56cea16c45b/peicode.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,7 +7,6 @@
   bfd_byte *data = 0;
   bfd_size_type dataoff;
   unsigned int i;
-
   bfd_vma addr = extra->DataDirectory[PE_DEBUG_DATA].VirtualAddress;
   bfd_size_type size = extra->DataDirectory[PE_DEBUG_DATA].Size;
 
@@ -31,8 +30,12 @@
 
   dataoff = addr - section->vma;
 
-  /* PR 20605: Make sure that the data is really there.  */
-  if (dataoff + size > section->size)
+  /* PR 20605 and 22373: Make sure that the data is really there.
+     Note - since we are dealing with unsigned quantities we have
+     to be careful to check for potential overflows.  */
+  if (dataoff > section->size
+      || size > section->size
+      || dataoff + size > section->size)
     {
       _bfd_error_handler (_(""%B: Error: Debug Data ends beyond end of debug directory.""),
 			  abfd);","{'deleted_lines': ['', '  /* PR 20605: Make sure that the data is really there.  */', '  if (dataoff + size > section->size)'], 'added_lines': ['  /* PR 20605 and 22373: Make sure that the data is really there.', '     Note - since we are dealing with unsigned quantities we have', '     to be careful to check for potential overflows.  */', '  if (dataoff > section->size', '      || size > section->size', '      || dataoff + size > section->size)']}",True,"The pe_bfd_read_buildid function in peicode.h in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29.1, does not validate size and offset values in the data dictionary, which allows remote attackers to cause a denial of service (segmentation violation and application crash) or possibly have unspecified other impact via a crafted PE file.",7.8,HIGH,2,test,,5
CVE-2017-17426,['CWE-190'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,glibc,"
Fix integer overflow in malloc when tcache is enabled [BZ #22375]

When the per-thread cache is enabled, __libc_malloc uses request2size (which
does not perform an overflow check) to calculate the chunk size from the
requested allocation size. This leads to an integer overflow causing malloc
to incorrectly return the last successfully allocated block when called with
a very large size argument (close to SIZE_MAX).

This commit uses checked_request2size instead, removing the overflow.
",34697694e8a93b325b18f25f7dcded55d6baeaf6,https://sourceware.org/git/gitweb.cgi?p=glibc.git;h=34697694e8a93b325b18f25f7dcded55d6baeaf6,malloc/malloc.c,__libc_malloc,"void *
__libc_malloc (size_t bytes)
{
mstate ar_ptr;
void *victim;
void *(*hook) (size_t, const void *)
= atomic_forced_read (__malloc_hook);
if (__builtin_expect (hook != NULL, 0))
return (*hook)(bytes, RETURN_ADDRESS (0));
#if USE_TCACHE
size_t tbytes = request2size (bytes);
size_t tc_idx = csize2tidx (tbytes);
MAYBE_INIT_TCACHE ();
DIAG_PUSH_NEEDS_COMMENT;
if (tc_idx < mp_.tcache_bins
&& tcache
&& tcache->entries[tc_idx] != NULL)
{
return tcache_get (tc_idx);
}
DIAG_POP_NEEDS_COMMENT;
#endif
if (SINGLE_THREAD_P)
{
victim = _int_malloc (&main_arena, bytes);
assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||
&main_arena == arena_for_chunk (mem2chunk (victim)));
return victim;
}
arena_get (ar_ptr, bytes);
victim = _int_malloc (ar_ptr, bytes);
if (!victim && ar_ptr != NULL)
{
LIBC_PROBE (memory_malloc_retry, 1, bytes);
ar_ptr = arena_get_retry (ar_ptr, bytes);
victim = _int_malloc (ar_ptr, bytes);
}
if (ar_ptr != NULL)
__libc_lock_unlock (ar_ptr->mutex);
assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||
ar_ptr == arena_for_chunk (mem2chunk (victim)));
return victim;
}","void *
__libc_malloc (size_t VAR_0)
{
mstate VAR_1;
void *VAR_2;
void *(*VAR_3) (size_t, const void *)
= atomic_forced_read (VAR_4);
if (__builtin_expect (VAR_3 != NULL, 0))
return (*VAR_3)(VAR_0, RETURN_ADDRESS (0));
#if VAR_5
size_t VAR_6 = request2size (VAR_0);
size_t VAR_7 = csize2tidx (VAR_6);
MAYBE_INIT_TCACHE ();
VAR_8;
if (VAR_7 < VAR_9.tcache_bins
&& VAR_10
&& VAR_10->entries[VAR_7] != NULL)
{
return tcache_get (VAR_7);
}
VAR_11;
#endif
if (VAR_12)
{
VAR_2 = _int_malloc (&VAR_13, VAR_0);
assert (!VAR_2 || chunk_is_mmapped (mem2chunk (VAR_2)) ||
&VAR_13 == arena_for_chunk (mem2chunk (VAR_2)));
return VAR_2;
}
arena_get (VAR_1, VAR_0);
VAR_2 = _int_malloc (VAR_1, VAR_0);
if (!VAR_2 && VAR_1 != NULL)
{
LIBC_PROBE (VAR_14, 1, VAR_0);
VAR_1 = arena_get_retry (VAR_1, VAR_0);
VAR_2 = _int_malloc (VAR_1, VAR_0);
}
if (VAR_1 != NULL)
__libc_lock_unlock (VAR_1->mutex);
assert (!VAR_2 || chunk_is_mmapped (mem2chunk (VAR_2)) ||
VAR_1 == arena_for_chunk (mem2chunk (VAR_2)));
return VAR_2;
}",glibc/34697694e8a93b325b18f25f7dcded55d6baeaf6/malloc.c/vul/before/0.json,"void *
__libc_malloc (size_t bytes)
{
  mstate ar_ptr;
  void *victim;

  void *(*hook) (size_t, const void *)
    = atomic_forced_read (__malloc_hook);
  if (__builtin_expect (hook != NULL, 0))
    return (*hook)(bytes, RETURN_ADDRESS (0));
#if USE_TCACHE
  /* int_free also calls request2size, be careful to not pad twice.  */
  size_t tbytes;
  checked_request2size (bytes, tbytes);
  size_t tc_idx = csize2tidx (tbytes);

  MAYBE_INIT_TCACHE ();

  DIAG_PUSH_NEEDS_COMMENT;
  if (tc_idx < mp_.tcache_bins
      /*&& tc_idx < TCACHE_MAX_BINS*/ /* to appease gcc */
      && tcache
      && tcache->entries[tc_idx] != NULL)
    {
      return tcache_get (tc_idx);
    }
  DIAG_POP_NEEDS_COMMENT;
#endif

  if (SINGLE_THREAD_P)
    {
      victim = _int_malloc (&main_arena, bytes);
      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||
	      &main_arena == arena_for_chunk (mem2chunk (victim)));
      return victim;
    }

  arena_get (ar_ptr, bytes);

  victim = _int_malloc (ar_ptr, bytes);
  /* Retry with another arena only if we were able to find a usable arena
     before.  */
  if (!victim && ar_ptr != NULL)
    {
      LIBC_PROBE (memory_malloc_retry, 1, bytes);
      ar_ptr = arena_get_retry (ar_ptr, bytes);
      victim = _int_malloc (ar_ptr, bytes);
    }

  if (ar_ptr != NULL)
    __libc_lock_unlock (ar_ptr->mutex);

  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||
          ar_ptr == arena_for_chunk (mem2chunk (victim)));
  return victim;
}","void *
__libc_malloc (size_t VAR_0)
{
  mstate VAR_1;
  void *VAR_2;

  void *(*VAR_3) (size_t, const void *)
    = atomic_forced_read (VAR_4);
  if (__builtin_expect (VAR_3 != NULL, 0))
    return (*VAR_3)(VAR_0, RETURN_ADDRESS (0));
#if VAR_5
  /* COMMENT_0 */
  size_t VAR_6;
  checked_request2size (VAR_0, VAR_6);
  size_t VAR_7 = csize2tidx (VAR_6);

  MAYBE_INIT_TCACHE ();

  VAR_8;
  if (VAR_7 < VAR_9.tcache_bins
      /* COMMENT_1 */ /* COMMENT_2 */
      && VAR_10
      && VAR_10->entries[VAR_7] != NULL)
    {
      return tcache_get (VAR_7);
    }
  VAR_11;
#endif

  if (VAR_12)
    {
      VAR_2 = _int_malloc (&VAR_13, VAR_0);
      assert (!VAR_2 || chunk_is_mmapped (mem2chunk (VAR_2)) ||
	      &VAR_13 == arena_for_chunk (mem2chunk (VAR_2)));
      return VAR_2;
    }

  arena_get (VAR_1, VAR_0);

  VAR_2 = _int_malloc (VAR_1, VAR_0);
  /* COMMENT_3 */
                
  if (!VAR_2 && VAR_1 != NULL)
    {
      LIBC_PROBE (VAR_14, 1, VAR_0);
      VAR_1 = arena_get_retry (VAR_1, VAR_0);
      VAR_2 = _int_malloc (VAR_1, VAR_0);
    }

  if (VAR_1 != NULL)
    __libc_lock_unlock (VAR_1->mutex);

  assert (!VAR_2 || chunk_is_mmapped (mem2chunk (VAR_2)) ||
          VAR_1 == arena_for_chunk (mem2chunk (VAR_2)));
  return VAR_2;
}",glibc/34697694e8a93b325b18f25f7dcded55d6baeaf6/malloc.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,7 +10,8 @@
     return (*hook)(bytes, RETURN_ADDRESS (0));
 #if USE_TCACHE
   /* int_free also calls request2size, be careful to not pad twice.  */
-  size_t tbytes = request2size (bytes);
+  size_t tbytes;
+  checked_request2size (bytes, tbytes);
   size_t tc_idx = csize2tidx (tbytes);
 
   MAYBE_INIT_TCACHE ();","{'deleted_lines': ['  size_t tbytes = request2size (bytes);'], 'added_lines': ['  size_t tbytes;', '  checked_request2size (bytes, tbytes);']}",True,"The malloc function in the GNU C Library (aka glibc or libc6) 2.26 could return a memory block that is too small if an attempt is made to allocate an object whose size is close to SIZE_MAX, potentially leading to a subsequent heap overflow. This occurs because the per-thread cache (aka tcache) feature enables a code path that lacks an integer overflow check.",8.1,HIGH,2,test,,5
CVE-2017-13186,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,android,"Decoder: Fixed incorrect use of mmco parameters.

Added extra structure to read mmco values and copied only once per
picture.

Bug: 65735716

Change-Id: I25b08a37bc78342042c52957774b089abce1a54b
(cherry picked from commit 3c70b9a190875938fc57164d9295a3ec791554df)
",6c327afb263837bc90760c55c6605b26161a4eb9,https://android.googlesource.com/platform/external/libavc/+/6c327afb263837bc90760c55c6605b26161a4eb9,decoder/ih264d_dpb_mgr.c,ih264d_read_mmco_commands,"WORD32 ih264d_read_mmco_commands(struct _DecStruct * ps_dec)
{
dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;
dpb_commands_t *ps_dpb_cmds = ps_dec->ps_dpb_cmds;
dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
WORD32 j;
UWORD8 u1_buf_mode;
struct MMCParams *ps_mmc_params;
UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;
UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
UWORD32 u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst;
ps_slice->u1_mmco_equalto5 = 0;
{
if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)
{
ps_slice->u1_no_output_of_prior_pics_flag =
ih264d_get_bit_h264(ps_bitstrm);
COPYTHECONTEXT(""SH: no_output_of_prior_pics_flag"",
ps_slice->u1_no_output_of_prior_pics_flag);
ps_slice->u1_long_term_reference_flag = ih264d_get_bit_h264(
ps_bitstrm);
COPYTHECONTEXT(""SH: long_term_reference_flag"",
ps_slice->u1_long_term_reference_flag);
ps_dpb_cmds->u1_idr_pic = 1;
ps_dpb_cmds->u1_no_output_of_prior_pics_flag =
ps_slice->u1_no_output_of_prior_pics_flag;
ps_dpb_cmds->u1_long_term_reference_flag =
ps_slice->u1_long_term_reference_flag;
}
else
{
u1_buf_mode = ih264d_get_bit_h264(ps_bitstrm);             COPYTHECONTEXT(""SH: adaptive_ref_pic_buffering_flag"", u1_buf_mode);
ps_dpb_cmds->u1_buf_mode = u1_buf_mode;
j = 0;
if(u1_buf_mode == 1)
{
UWORD32 u4_mmco;
UWORD32 u4_diff_pic_num;
UWORD32 u4_lt_idx, u4_max_lt_idx;
u4_mmco = ih264d_uev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
while(u4_mmco != END_OF_MMCO)
{
if (j >= MAX_REF_BUFS)
{
#ifdef __ANDROID__
ALOGE(""b/25818142"");
android_errorWriteLog(0x534e4554, ""25818142"");
#endif
ps_dpb_cmds->u1_num_of_commands = 0;
return -1;
}
ps_mmc_params = &ps_dpb_cmds->as_mmc_params[j];
ps_mmc_params->u4_mmco = u4_mmco;
switch(u4_mmco)
{
case MARK_ST_PICNUM_AS_NONREF:
u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num;
break;
case MARK_LT_INDEX_AS_NONREF:
u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
ps_mmc_params->u4_lt_idx = u4_lt_idx;
break;
case MARK_ST_PICNUM_AS_LT_INDEX:
u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num;
u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
ps_mmc_params->u4_lt_idx = u4_lt_idx;
break;
case SET_MAX_LT_INDEX:
{
u4_max_lt_idx = ih264d_uev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
ps_mmc_params->u4_max_lt_idx_plus1 = u4_max_lt_idx;
break;
}
case RESET_REF_PICTURES:
{
ps_slice->u1_mmco_equalto5 = 1;
break;
}
case SET_LT_INDEX:
u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
ps_mmc_params->u4_lt_idx = u4_lt_idx;
break;
default:
break;
}
u4_mmco = ih264d_uev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
j++;
}
ps_dpb_cmds->u1_num_of_commands = j;
}
}
ps_dpb_cmds->u1_dpb_commands_read = 1;
ps_dpb_cmds->u1_dpb_commands_read_slc = 1;
}
u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst - u4_bit_ofst;
return u4_bit_ofst;
}","WORD32 ih264d_read_mmco_commands(struct _DecStruct * VAR_0)
{
dec_bit_stream_t *VAR_1 = VAR_0->ps_bitstrm;
dpb_commands_t *VAR_2 = VAR_0->ps_dpb_cmds;
dec_slice_params_t * VAR_3 = VAR_0->ps_cur_slice;
WORD32 VAR_4;
UWORD8 VAR_5;
struct MMCParams *VAR_6;
UWORD32 *VAR_7 = VAR_0->ps_bitstrm->pu4_buffer;
UWORD32 *VAR_8 = &VAR_1->u4_ofst;
UWORD32 VAR_9 = VAR_0->ps_bitstrm->u4_ofst;
VAR_3->u1_mmco_equalto5 = 0;
{
if(VAR_0->u1_nal_unit_type == VAR_10)
{
VAR_3->u1_no_output_of_prior_pics_flag =
ih264d_get_bit_h264(VAR_1);
COPYTHECONTEXT(""SH: no_output_of_prior_pics_flag"",
VAR_3->u1_no_output_of_prior_pics_flag);
VAR_3->u1_long_term_reference_flag = ih264d_get_bit_h264(
VAR_1);
COPYTHECONTEXT(""SH: long_term_reference_flag"",
VAR_3->u1_long_term_reference_flag);
VAR_2->u1_idr_pic = 1;
VAR_2->u1_no_output_of_prior_pics_flag =
VAR_3->u1_no_output_of_prior_pics_flag;
VAR_2->u1_long_term_reference_flag =
VAR_3->u1_long_term_reference_flag;
}
else
{
VAR_5 = ih264d_get_bit_h264(VAR_1); 
COPYTHECONTEXT(""SH: adaptive_ref_pic_buffering_flag"", VAR_5);
VAR_2->u1_buf_mode = VAR_5;
VAR_4 = 0;
if(VAR_5 == 1)
{
UWORD32 VAR_11;
UWORD32 VAR_12;
UWORD32 VAR_13, VAR_14;
VAR_11 = ih264d_uev(VAR_8,
VAR_7);
while(VAR_11 != VAR_15)
{
if (VAR_4 >= VAR_16)
{
#ifdef VAR_17
ALOGE(""b/25818142"");
android_errorWriteLog(0x534e4554, ""25818142"");
#endif
VAR_2->u1_num_of_commands = 0;
return -1;
}
VAR_6 = &VAR_2->as_mmc_params[VAR_4];
VAR_6->u4_mmco = VAR_11;
switch(VAR_11)
{
case VAR_18:
VAR_12 = ih264d_uev(VAR_8,
VAR_7);
VAR_6->u4_diff_pic_num = VAR_12;
break;
case VAR_19:
VAR_13 = ih264d_uev(VAR_8,
VAR_7);
VAR_6->u4_lt_idx = VAR_13;
break;
case VAR_20:
VAR_12 = ih264d_uev(VAR_8,
VAR_7);
VAR_6->u4_diff_pic_num = VAR_12;
VAR_13 = ih264d_uev(VAR_8,
VAR_7);
VAR_6->u4_lt_idx = VAR_13;
break;
case VAR_21:
{
VAR_14 = ih264d_uev(VAR_8,
VAR_7);
VAR_6->u4_max_lt_idx_plus1 = VAR_14;
break;
}
case VAR_22:
{
VAR_3->u1_mmco_equalto5 = 1;
break;
}
case VAR_23:
VAR_13 = ih264d_uev(VAR_8,
VAR_7);
VAR_6->u4_lt_idx = VAR_13;
break;
default:
break;
}
VAR_11 = ih264d_uev(VAR_8,
VAR_7);
VAR_4++;
}
VAR_2->u1_num_of_commands = VAR_4;
}
}
VAR_2->u1_dpb_commands_read = 1;
VAR_2->u1_dpb_commands_read_slc = 1;
}
VAR_9 = VAR_0->ps_bitstrm->u4_ofst - VAR_9;
return VAR_9;
}",android/6c327afb263837bc90760c55c6605b26161a4eb9/ih264d_dpb_mgr.c/vul/before/0.json,"WORD32 ih264d_read_mmco_commands(struct _DecStruct * ps_dec)
{
    dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;
    dpb_commands_t *ps_dpb_cmds = &(ps_dec->s_dpb_cmds_scratch);
    dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
    WORD32 j;
    UWORD8 u1_buf_mode;
    struct MMCParams *ps_mmc_params;
    UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;
    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
    UWORD32 u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst;

    ps_slice->u1_mmco_equalto5 = 0;
    {
        if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)
        {
            ps_slice->u1_no_output_of_prior_pics_flag =
                            ih264d_get_bit_h264(ps_bitstrm);
            COPYTHECONTEXT(""SH: no_output_of_prior_pics_flag"",
                            ps_slice->u1_no_output_of_prior_pics_flag);
            ps_slice->u1_long_term_reference_flag = ih264d_get_bit_h264(
                            ps_bitstrm);
            COPYTHECONTEXT(""SH: long_term_reference_flag"",
                            ps_slice->u1_long_term_reference_flag);
            ps_dpb_cmds->u1_idr_pic = 1;
            ps_dpb_cmds->u1_no_output_of_prior_pics_flag =
                            ps_slice->u1_no_output_of_prior_pics_flag;
            ps_dpb_cmds->u1_long_term_reference_flag =
                            ps_slice->u1_long_term_reference_flag;
        }
        else
        {
            u1_buf_mode = ih264d_get_bit_h264(ps_bitstrm); //0 - sliding window; 1 - arbitrary
            COPYTHECONTEXT(""SH: adaptive_ref_pic_buffering_flag"", u1_buf_mode);
            ps_dpb_cmds->u1_buf_mode = u1_buf_mode;
            j = 0;

            if(u1_buf_mode == 1)
            {
                UWORD32 u4_mmco;
                UWORD32 u4_diff_pic_num;
                UWORD32 u4_lt_idx, u4_max_lt_idx;

                u4_mmco = ih264d_uev(pu4_bitstrm_ofst,
                                     pu4_bitstrm_buf);
                while(u4_mmco != END_OF_MMCO)
                {
                    if (j >= MAX_REF_BUFS)
                    {
#ifdef __ANDROID__
                        ALOGE(""b/25818142"");
                        android_errorWriteLog(0x534e4554, ""25818142"");
#endif
                        ps_dpb_cmds->u1_num_of_commands = 0;
                        return -1;
                    }
                    ps_mmc_params = &ps_dpb_cmds->as_mmc_params[j];
                    ps_mmc_params->u4_mmco = u4_mmco;
                    switch(u4_mmco)
                    {
                        case MARK_ST_PICNUM_AS_NONREF:
                            u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst,
                                                         pu4_bitstrm_buf);
                            //Get absDiffPicnumMinus1
                            ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num;
                            break;

                        case MARK_LT_INDEX_AS_NONREF:
                            u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,
                                                   pu4_bitstrm_buf);
                            ps_mmc_params->u4_lt_idx = u4_lt_idx;
                            break;

                        case MARK_ST_PICNUM_AS_LT_INDEX:
                            u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst,
                                                         pu4_bitstrm_buf);
                            ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num;
                            u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,
                                                   pu4_bitstrm_buf);
                            ps_mmc_params->u4_lt_idx = u4_lt_idx;
                            break;

                        case SET_MAX_LT_INDEX:
                        {
                            u4_max_lt_idx = ih264d_uev(pu4_bitstrm_ofst,
                                                       pu4_bitstrm_buf);
                            ps_mmc_params->u4_max_lt_idx_plus1 = u4_max_lt_idx;
                            break;
                        }
                        case RESET_REF_PICTURES:
                        {
                            ps_slice->u1_mmco_equalto5 = 1;
                            break;
                        }

                        case SET_LT_INDEX:
                            u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,
                                                   pu4_bitstrm_buf);
                            ps_mmc_params->u4_lt_idx = u4_lt_idx;
                            break;

                        default:
                            break;
                    }
                    u4_mmco = ih264d_uev(pu4_bitstrm_ofst,
                                         pu4_bitstrm_buf);

                    j++;
                }
                ps_dpb_cmds->u1_num_of_commands = j;

            }
        }
        ps_dpb_cmds->u1_dpb_commands_read = 1;
        ps_dpb_cmds->u1_dpb_commands_read_slc = 1;

    }
    u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst - u4_bit_ofst;
    return u4_bit_ofst;
}","WORD32 ih264d_read_mmco_commands(struct _DecStruct * VAR_0)
{
    dec_bit_stream_t *VAR_1 = VAR_0->ps_bitstrm;
    dpb_commands_t *VAR_2 = &(VAR_0->s_dpb_cmds_scratch);
    dec_slice_params_t * VAR_3 = VAR_0->ps_cur_slice;
    WORD32 VAR_4;
    UWORD8 VAR_5;
    struct MMCParams *VAR_6;
    UWORD32 *VAR_7 = VAR_0->ps_bitstrm->pu4_buffer;
    UWORD32 *VAR_8 = &VAR_1->u4_ofst;
    UWORD32 VAR_9 = VAR_0->ps_bitstrm->u4_ofst;

    VAR_3->u1_mmco_equalto5 = 0;
    {
        if(VAR_0->u1_nal_unit_type == VAR_10)
        {
            VAR_3->u1_no_output_of_prior_pics_flag =
                            ih264d_get_bit_h264(VAR_1);
            COPYTHECONTEXT(""SH: no_output_of_prior_pics_flag"",
                            VAR_3->u1_no_output_of_prior_pics_flag);
            VAR_3->u1_long_term_reference_flag = ih264d_get_bit_h264(
                            VAR_1);
            COPYTHECONTEXT(""SH: long_term_reference_flag"",
                            VAR_3->u1_long_term_reference_flag);
            VAR_2->u1_idr_pic = 1;
            VAR_2->u1_no_output_of_prior_pics_flag =
                            VAR_3->u1_no_output_of_prior_pics_flag;
            VAR_2->u1_long_term_reference_flag =
                            VAR_3->u1_long_term_reference_flag;
        }
        else
        {
            VAR_5 = ih264d_get_bit_h264(VAR_1); /* COMMENT_0 */
            COPYTHECONTEXT(""SH: adaptive_ref_pic_buffering_flag"", VAR_5);
            VAR_2->u1_buf_mode = VAR_5;
            VAR_4 = 0;

            if(VAR_5 == 1)
            {
                UWORD32 VAR_11;
                UWORD32 VAR_12;
                UWORD32 VAR_13, VAR_14;

                VAR_11 = ih264d_uev(VAR_8,
                                     VAR_7);
                while(VAR_11 != VAR_15)
                {
                    if (VAR_4 >= VAR_16)
                    {
#ifdef VAR_17
                        ALOGE(""b/25818142"");
                        android_errorWriteLog(0x534e4554, ""25818142"");
#endif
                        VAR_2->u1_num_of_commands = 0;
                        return -1;
                    }
                    VAR_6 = &VAR_2->as_mmc_params[VAR_4];
                    VAR_6->u4_mmco = VAR_11;
                    switch(VAR_11)
                    {
                        case VAR_18:
                            VAR_12 = ih264d_uev(VAR_8,
                                                         VAR_7);
                            /* COMMENT_1 */
                            VAR_6->u4_diff_pic_num = VAR_12;
                            break;

                        case VAR_19:
                            VAR_13 = ih264d_uev(VAR_8,
                                                   VAR_7);
                            VAR_6->u4_lt_idx = VAR_13;
                            break;

                        case VAR_20:
                            VAR_12 = ih264d_uev(VAR_8,
                                                         VAR_7);
                            VAR_6->u4_diff_pic_num = VAR_12;
                            VAR_13 = ih264d_uev(VAR_8,
                                                   VAR_7);
                            VAR_6->u4_lt_idx = VAR_13;
                            break;

                        case VAR_21:
                        {
                            VAR_14 = ih264d_uev(VAR_8,
                                                       VAR_7);
                            VAR_6->u4_max_lt_idx_plus1 = VAR_14;
                            break;
                        }
                        case VAR_22:
                        {
                            VAR_3->u1_mmco_equalto5 = 1;
                            break;
                        }

                        case VAR_23:
                            VAR_13 = ih264d_uev(VAR_8,
                                                   VAR_7);
                            VAR_6->u4_lt_idx = VAR_13;
                            break;

                        default:
                            break;
                    }
                    VAR_11 = ih264d_uev(VAR_8,
                                         VAR_7);

                    VAR_4++;
                }
                VAR_2->u1_num_of_commands = VAR_4;

            }
        }
        VAR_2->u1_dpb_commands_read = 1;
        VAR_2->u1_dpb_commands_read_slc = 1;

    }
    VAR_9 = VAR_0->ps_bitstrm->u4_ofst - VAR_9;
    return VAR_9;
}",android/6c327afb263837bc90760c55c6605b26161a4eb9/ih264d_dpb_mgr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
 WORD32 ih264d_read_mmco_commands(struct _DecStruct * ps_dec)
 {
     dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;
-    dpb_commands_t *ps_dpb_cmds = ps_dec->ps_dpb_cmds;
+    dpb_commands_t *ps_dpb_cmds = &(ps_dec->s_dpb_cmds_scratch);
     dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
     WORD32 j;
     UWORD8 u1_buf_mode;","{'deleted_lines': ['    dpb_commands_t *ps_dpb_cmds = ps_dec->ps_dpb_cmds;'], 'added_lines': ['    dpb_commands_t *ps_dpb_cmds = &(ps_dec->s_dpb_cmds_scratch);']}",True,"A vulnerability in the Android media framework (libavc) related to incorrect use of mmco parameters. Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-65735716.",7.5,HIGH,2,test,,5
CVE-2017-12183,['CWE-20'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,xorg/xserver,"v2: Use before swap (Jeremy Huddleston Sequoia)

v3: Fix wrong XFixesCopyRegion checks (Alan Coopersmith)

Reviewed-by: Alan Coopersmith <alan.coopersmith@oracle.com>
Reviewed-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
Reviewed-by: Julien Cristau <jcristau@debian.org>
Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
Signed-off-by: Nathan Kidd <nkidd@opentext.com>
Signed-off-by: Julien Cristau <jcristau@debian.org>
",55caa8b08c84af2b50fbc936cf334a5a93dd7db5,https://cgit.freedesktop.org/xorg/xserver/commit/?id=55caa8b08c84af2b50fbc936cf334a5a93dd7db5,xfixes/saveset.c,SProcXFixesChangeSaveSet,"int _X_COLD
SProcXFixesChangeSaveSet(ClientPtr client)
{
REQUEST(xXFixesChangeSaveSetReq);
swaps(&stuff->length);
swapl(&stuff->window);
return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}","int VAR_0
SProcXFixesChangeSaveSet(ClientPtr VAR_1)
{
REQUEST(VAR_2);
swaps(&VAR_3->length);
swapl(&VAR_3->window);
return (*VAR_4[VAR_3->xfixesReqType]) (VAR_1);
}",,"int _X_COLD
SProcXFixesChangeSaveSet(ClientPtr client)
{
    REQUEST(xXFixesChangeSaveSetReq);
    REQUEST_SIZE_MATCH(xXFixesChangeSaveSetReq);

    swaps(&stuff->length);
    swapl(&stuff->window);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}","int VAR_0
SProcXFixesChangeSaveSet(ClientPtr VAR_1)
{
    REQUEST(VAR_2);
    REQUEST_SIZE_MATCH(VAR_2);

    swaps(&VAR_3->length);
    swapl(&VAR_3->window);
    return (*VAR_4[VAR_3->xfixesReqType]) (VAR_1);
}",,"--- func_before
+++ func_after
@@ -2,6 +2,7 @@
 SProcXFixesChangeSaveSet(ClientPtr client)
 {
     REQUEST(xXFixesChangeSaveSetReq);
+    REQUEST_SIZE_MATCH(xXFixesChangeSaveSetReq);
 
     swaps(&stuff->length);
     swapl(&stuff->window);","{'deleted_lines': [], 'added_lines': ['    REQUEST_SIZE_MATCH(xXFixesChangeSaveSetReq);']}",True,xorg-x11-server before 1.19.5 was missing length validation in XFIXES extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,9.8,CRITICAL,3,test,,5
CVE-2017-12183,['CWE-20'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,xorg/xserver,"v2: Use before swap (Jeremy Huddleston Sequoia)

v3: Fix wrong XFixesCopyRegion checks (Alan Coopersmith)

Reviewed-by: Alan Coopersmith <alan.coopersmith@oracle.com>
Reviewed-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
Reviewed-by: Julien Cristau <jcristau@debian.org>
Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
Signed-off-by: Nathan Kidd <nkidd@opentext.com>
Signed-off-by: Julien Cristau <jcristau@debian.org>
",55caa8b08c84af2b50fbc936cf334a5a93dd7db5,https://cgit.freedesktop.org/xorg/xserver/commit/?id=55caa8b08c84af2b50fbc936cf334a5a93dd7db5,xfixes/region.c,ProcXFixesCopyRegion,"int
ProcXFixesCopyRegion(ClientPtr client)
{
RegionPtr pSource, pDestination;
REQUEST(xXFixesCopyRegionReq);
VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);
VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);
if (!RegionCopy(pDestination, pSource))
return BadAlloc;
return Success;
}","int
ProcXFixesCopyRegion(ClientPtr VAR_0)
{
RegionPtr VAR_1, VAR_2;
REQUEST(VAR_3);
VERIFY_REGION(VAR_1, VAR_4->source, VAR_0, VAR_5);
VERIFY_REGION(VAR_2, VAR_4->destination, VAR_0, VAR_6);
if (!RegionCopy(VAR_2, VAR_1))
return VAR_7;
return VAR_8;
}",xorg/xserver/55caa8b08c84af2b50fbc936cf334a5a93dd7db5/region.c/vul/before/0.json,"int
ProcXFixesCopyRegion(ClientPtr client)
{
    RegionPtr pSource, pDestination;

    REQUEST(xXFixesCopyRegionReq);
    REQUEST_SIZE_MATCH(xXFixesCopyRegionReq);

    VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);

    if (!RegionCopy(pDestination, pSource))
        return BadAlloc;

    return Success;
}","int
ProcXFixesCopyRegion(ClientPtr VAR_0)
{
    RegionPtr VAR_1, VAR_2;

    REQUEST(VAR_3);
    REQUEST_SIZE_MATCH(VAR_3);

    VERIFY_REGION(VAR_1, VAR_4->source, VAR_0, VAR_5);
    VERIFY_REGION(VAR_2, VAR_4->destination, VAR_0, VAR_6);

    if (!RegionCopy(VAR_2, VAR_1))
        return VAR_7;

    return VAR_8;
}",xorg/xserver/55caa8b08c84af2b50fbc936cf334a5a93dd7db5/region.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,6 +4,7 @@
     RegionPtr pSource, pDestination;
 
     REQUEST(xXFixesCopyRegionReq);
+    REQUEST_SIZE_MATCH(xXFixesCopyRegionReq);
 
     VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);
     VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);","{'deleted_lines': [], 'added_lines': ['    REQUEST_SIZE_MATCH(xXFixesCopyRegionReq);']}",True,xorg-x11-server before 1.19.5 was missing length validation in XFIXES extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,9.8,CRITICAL,3,test,,5
CVE-2017-12183,['CWE-20'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,xorg/xserver,"v2: Use before swap (Jeremy Huddleston Sequoia)

v3: Fix wrong XFixesCopyRegion checks (Alan Coopersmith)

Reviewed-by: Alan Coopersmith <alan.coopersmith@oracle.com>
Reviewed-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
Reviewed-by: Julien Cristau <jcristau@debian.org>
Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
Signed-off-by: Nathan Kidd <nkidd@opentext.com>
Signed-off-by: Julien Cristau <jcristau@debian.org>
",55caa8b08c84af2b50fbc936cf334a5a93dd7db5,https://cgit.freedesktop.org/xorg/xserver/commit/?id=55caa8b08c84af2b50fbc936cf334a5a93dd7db5,xfixes/region.c,SProcXFixesCopyRegion,"int _X_COLD
SProcXFixesCopyRegion(ClientPtr client)
{
REQUEST(xXFixesCopyRegionReq);
swaps(&stuff->length);
REQUEST_AT_LEAST_SIZE(xXFixesCopyRegionReq);
swapl(&stuff->source);
swapl(&stuff->destination);
return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}","int VAR_0
SProcXFixesCopyRegion(ClientPtr VAR_1)
{
REQUEST(VAR_2);
swaps(&VAR_3->length);
REQUEST_AT_LEAST_SIZE(VAR_2);
swapl(&VAR_3->source);
swapl(&VAR_3->destination);
return (*VAR_4[VAR_3->xfixesReqType]) (VAR_1);
}",,"int _X_COLD
SProcXFixesCopyRegion(ClientPtr client)
{
    REQUEST(xXFixesCopyRegionReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXFixesCopyRegionReq);
    swapl(&stuff->source);
    swapl(&stuff->destination);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}","int VAR_0
SProcXFixesCopyRegion(ClientPtr VAR_1)
{
    REQUEST(VAR_2);

    swaps(&VAR_3->length);
    REQUEST_SIZE_MATCH(VAR_2);
    swapl(&VAR_3->source);
    swapl(&VAR_3->destination);
    return (*VAR_4[VAR_3->xfixesReqType]) (VAR_1);
}",,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
     REQUEST(xXFixesCopyRegionReq);
 
     swaps(&stuff->length);
-    REQUEST_AT_LEAST_SIZE(xXFixesCopyRegionReq);
+    REQUEST_SIZE_MATCH(xXFixesCopyRegionReq);
     swapl(&stuff->source);
     swapl(&stuff->destination);
     return (*ProcXFixesVector[stuff->xfixesReqType]) (client);","{'deleted_lines': ['    REQUEST_AT_LEAST_SIZE(xXFixesCopyRegionReq);'], 'added_lines': ['    REQUEST_SIZE_MATCH(xXFixesCopyRegionReq);']}",True,xorg-x11-server before 1.19.5 was missing length validation in XFIXES extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,9.8,CRITICAL,3,test,,5
CVE-2017-12183,['CWE-20'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,xorg/xserver,"v2: Use before swap (Jeremy Huddleston Sequoia)

v3: Fix wrong XFixesCopyRegion checks (Alan Coopersmith)

Reviewed-by: Alan Coopersmith <alan.coopersmith@oracle.com>
Reviewed-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
Reviewed-by: Julien Cristau <jcristau@debian.org>
Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
Signed-off-by: Nathan Kidd <nkidd@opentext.com>
Signed-off-by: Julien Cristau <jcristau@debian.org>
",55caa8b08c84af2b50fbc936cf334a5a93dd7db5,https://cgit.freedesktop.org/xorg/xserver/commit/?id=55caa8b08c84af2b50fbc936cf334a5a93dd7db5,xfixes/cursor.c,SProcXFixesCreatePointerBarrier,"int _X_COLD
SProcXFixesCreatePointerBarrier(ClientPtr client)
{
REQUEST(xXFixesCreatePointerBarrierReq);
int i;
CARD16 *in_devices = (CARD16 *) &stuff[1];
swaps(&stuff->length);
swaps(&stuff->num_devices);
REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq, pad_to_int32(stuff->num_devices));
swapl(&stuff->barrier);
swapl(&stuff->window);
swaps(&stuff->x1);
swaps(&stuff->y1);
swaps(&stuff->x2);
swaps(&stuff->y2);
swapl(&stuff->directions);
for (i = 0; i < stuff->num_devices; i++) {
swaps(in_devices + i);
}
return ProcXFixesVector[stuff->xfixesReqType] (client);
}","int VAR_0
SProcXFixesCreatePointerBarrier(ClientPtr VAR_1)
{
REQUEST(VAR_2);
int VAR_3;
CARD16 *VAR_4 = (CARD16 *) &VAR_5[1];
swaps(&VAR_5->length);
swaps(&VAR_5->num_devices);
REQUEST_FIXED_SIZE(VAR_2, pad_to_int32(VAR_5->num_devices));
swapl(&VAR_5->barrier);
swapl(&VAR_5->window);
swaps(&VAR_5->x1);
swaps(&VAR_5->y1);
swaps(&VAR_5->x2);
swaps(&VAR_5->y2);
swapl(&VAR_5->directions);
for (VAR_3 = 0; VAR_3 < VAR_5->num_devices; VAR_3++) {
swaps(VAR_4 + VAR_3);
}
return VAR_6[VAR_5->xfixesReqType] (VAR_1);
}",,"int _X_COLD
SProcXFixesCreatePointerBarrier(ClientPtr client)
{
    REQUEST(xXFixesCreatePointerBarrierReq);
    int i;
    CARD16 *in_devices = (CARD16 *) &stuff[1];

    REQUEST_AT_LEAST_SIZE(xXFixesCreatePointerBarrierReq);

    swaps(&stuff->length);
    swaps(&stuff->num_devices);
    REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq, pad_to_int32(stuff->num_devices));

    swapl(&stuff->barrier);
    swapl(&stuff->window);
    swaps(&stuff->x1);
    swaps(&stuff->y1);
    swaps(&stuff->x2);
    swaps(&stuff->y2);
    swapl(&stuff->directions);
    for (i = 0; i < stuff->num_devices; i++) {
        swaps(in_devices + i);
    }

    return ProcXFixesVector[stuff->xfixesReqType] (client);
}","int VAR_0
SProcXFixesCreatePointerBarrier(ClientPtr VAR_1)
{
    REQUEST(VAR_2);
    int VAR_3;
    CARD16 *VAR_4 = (CARD16 *) &VAR_5[1];

    REQUEST_AT_LEAST_SIZE(VAR_2);

    swaps(&VAR_5->length);
    swaps(&VAR_5->num_devices);
    REQUEST_FIXED_SIZE(VAR_2, pad_to_int32(VAR_5->num_devices));

    swapl(&VAR_5->barrier);
    swapl(&VAR_5->window);
    swaps(&VAR_5->x1);
    swaps(&VAR_5->y1);
    swaps(&VAR_5->x2);
    swaps(&VAR_5->y2);
    swapl(&VAR_5->directions);
    for (VAR_3 = 0; VAR_3 < VAR_5->num_devices; VAR_3++) {
        swaps(VAR_4 + VAR_3);
    }

    return VAR_6[VAR_5->xfixesReqType] (VAR_1);
}",,"--- func_before
+++ func_after
@@ -4,6 +4,8 @@
     REQUEST(xXFixesCreatePointerBarrierReq);
     int i;
     CARD16 *in_devices = (CARD16 *) &stuff[1];
+
+    REQUEST_AT_LEAST_SIZE(xXFixesCreatePointerBarrierReq);
 
     swaps(&stuff->length);
     swaps(&stuff->num_devices);","{'deleted_lines': [], 'added_lines': ['', '    REQUEST_AT_LEAST_SIZE(xXFixesCreatePointerBarrierReq);']}",True,xorg-x11-server before 1.19.5 was missing length validation in XFIXES extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,9.8,CRITICAL,3,test,,5
CVE-2017-12183,['CWE-20'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,xorg/xserver,"v2: Use before swap (Jeremy Huddleston Sequoia)

v3: Fix wrong XFixesCopyRegion checks (Alan Coopersmith)

Reviewed-by: Alan Coopersmith <alan.coopersmith@oracle.com>
Reviewed-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
Reviewed-by: Julien Cristau <jcristau@debian.org>
Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
Signed-off-by: Nathan Kidd <nkidd@opentext.com>
Signed-off-by: Julien Cristau <jcristau@debian.org>
",55caa8b08c84af2b50fbc936cf334a5a93dd7db5,https://cgit.freedesktop.org/xorg/xserver/commit/?id=55caa8b08c84af2b50fbc936cf334a5a93dd7db5,xfixes/cursor.c,ProcXFixesSetCursorName,"int
ProcXFixesSetCursorName(ClientPtr client)
{
CursorPtr pCursor;
char *tchar;
REQUEST(xXFixesSetCursorNameReq);
Atom atom;
REQUEST_AT_LEAST_SIZE(xXFixesSetCursorNameReq);
VERIFY_CURSOR(pCursor, stuff->cursor, client, DixSetAttrAccess);
tchar = (char *) &stuff[1];
atom = MakeAtom(tchar, stuff->nbytes, TRUE);
if (atom == BAD_RESOURCE)
return BadAlloc;
pCursor->name = atom;
return Success;
}","int
ProcXFixesSetCursorName(ClientPtr VAR_0)
{
CursorPtr VAR_1;
char *VAR_2;
REQUEST(VAR_3);
Atom VAR_4;
REQUEST_AT_LEAST_SIZE(VAR_3);
VERIFY_CURSOR(VAR_1, VAR_5->cursor, VAR_0, VAR_6);
VAR_2 = (char *) &VAR_5[1];
VAR_4 = MakeAtom(VAR_2, VAR_5->nbytes, TRUE);
if (VAR_4 == VAR_7)
return VAR_8;
VAR_1->name = VAR_4;
return VAR_9;
}",xorg/xserver/55caa8b08c84af2b50fbc936cf334a5a93dd7db5/cursor.c/vul/before/1.json,"int
ProcXFixesSetCursorName(ClientPtr client)
{
    CursorPtr pCursor;
    char *tchar;

    REQUEST(xXFixesSetCursorNameReq);
    Atom atom;

    REQUEST_FIXED_SIZE(xXFixesSetCursorNameReq, stuff->nbytes);
    VERIFY_CURSOR(pCursor, stuff->cursor, client, DixSetAttrAccess);
    tchar = (char *) &stuff[1];
    atom = MakeAtom(tchar, stuff->nbytes, TRUE);
    if (atom == BAD_RESOURCE)
        return BadAlloc;

    pCursor->name = atom;
    return Success;
}","int
ProcXFixesSetCursorName(ClientPtr VAR_0)
{
    CursorPtr VAR_1;
    char *VAR_2;

    REQUEST(VAR_3);
    Atom VAR_4;

    REQUEST_FIXED_SIZE(VAR_3, VAR_5->nbytes);
    VERIFY_CURSOR(VAR_1, VAR_5->cursor, VAR_0, VAR_6);
    VAR_2 = (char *) &VAR_5[1];
    VAR_4 = MakeAtom(VAR_2, VAR_5->nbytes, TRUE);
    if (VAR_4 == VAR_7)
        return VAR_8;

    VAR_1->name = VAR_4;
    return VAR_9;
}",xorg/xserver/55caa8b08c84af2b50fbc936cf334a5a93dd7db5/cursor.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
     REQUEST(xXFixesSetCursorNameReq);
     Atom atom;
 
-    REQUEST_AT_LEAST_SIZE(xXFixesSetCursorNameReq);
+    REQUEST_FIXED_SIZE(xXFixesSetCursorNameReq, stuff->nbytes);
     VERIFY_CURSOR(pCursor, stuff->cursor, client, DixSetAttrAccess);
     tchar = (char *) &stuff[1];
     atom = MakeAtom(tchar, stuff->nbytes, TRUE);","{'deleted_lines': ['    REQUEST_AT_LEAST_SIZE(xXFixesSetCursorNameReq);'], 'added_lines': ['    REQUEST_FIXED_SIZE(xXFixesSetCursorNameReq, stuff->nbytes);']}",True,xorg-x11-server before 1.19.5 was missing length validation in XFIXES extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,9.8,CRITICAL,3,test,,5
CVE-2017-12183,['CWE-20'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,xorg/xserver,"v2: Use before swap (Jeremy Huddleston Sequoia)

v3: Fix wrong XFixesCopyRegion checks (Alan Coopersmith)

Reviewed-by: Alan Coopersmith <alan.coopersmith@oracle.com>
Reviewed-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
Reviewed-by: Julien Cristau <jcristau@debian.org>
Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
Signed-off-by: Nathan Kidd <nkidd@opentext.com>
Signed-off-by: Julien Cristau <jcristau@debian.org>
",55caa8b08c84af2b50fbc936cf334a5a93dd7db5,https://cgit.freedesktop.org/xorg/xserver/commit/?id=55caa8b08c84af2b50fbc936cf334a5a93dd7db5,xfixes/cursor.c,SProcXFixesSelectCursorInput,"int _X_COLD
SProcXFixesSelectCursorInput(ClientPtr client)
{
REQUEST(xXFixesSelectCursorInputReq);
swaps(&stuff->length);
swapl(&stuff->window);
swapl(&stuff->eventMask);
return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}","int VAR_0
SProcXFixesSelectCursorInput(ClientPtr VAR_1)
{
REQUEST(VAR_2);
swaps(&VAR_3->length);
swapl(&VAR_3->window);
swapl(&VAR_3->eventMask);
return (*VAR_4[VAR_3->xfixesReqType]) (VAR_1);
}",,"int _X_COLD
SProcXFixesSelectCursorInput(ClientPtr client)
{
    REQUEST(xXFixesSelectCursorInputReq);
    REQUEST_SIZE_MATCH(xXFixesSelectCursorInputReq);

    swaps(&stuff->length);
    swapl(&stuff->window);
    swapl(&stuff->eventMask);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}","int VAR_0
SProcXFixesSelectCursorInput(ClientPtr VAR_1)
{
    REQUEST(VAR_2);
    REQUEST_SIZE_MATCH(VAR_2);

    swaps(&VAR_3->length);
    swapl(&VAR_3->window);
    swapl(&VAR_3->eventMask);
    return (*VAR_4[VAR_3->xfixesReqType]) (VAR_1);
}",,"--- func_before
+++ func_after
@@ -2,6 +2,7 @@
 SProcXFixesSelectCursorInput(ClientPtr client)
 {
     REQUEST(xXFixesSelectCursorInputReq);
+    REQUEST_SIZE_MATCH(xXFixesSelectCursorInputReq);
 
     swaps(&stuff->length);
     swapl(&stuff->window);","{'deleted_lines': [], 'added_lines': ['    REQUEST_SIZE_MATCH(xXFixesSelectCursorInputReq);']}",True,xorg-x11-server before 1.19.5 was missing length validation in XFIXES extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,9.8,CRITICAL,3,test,,5
CVE-2017-12183,['CWE-20'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,xorg/xserver,"v2: Use before swap (Jeremy Huddleston Sequoia)

v3: Fix wrong XFixesCopyRegion checks (Alan Coopersmith)

Reviewed-by: Alan Coopersmith <alan.coopersmith@oracle.com>
Reviewed-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
Reviewed-by: Julien Cristau <jcristau@debian.org>
Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
Signed-off-by: Nathan Kidd <nkidd@opentext.com>
Signed-off-by: Julien Cristau <jcristau@debian.org>
",55caa8b08c84af2b50fbc936cf334a5a93dd7db5,https://cgit.freedesktop.org/xorg/xserver/commit/?id=55caa8b08c84af2b50fbc936cf334a5a93dd7db5,xfixes/xfixes.c,SProcXFixesQueryVersion,"static _X_COLD int
SProcXFixesQueryVersion(ClientPtr client)
{
REQUEST(xXFixesQueryVersionReq);
swaps(&stuff->length);
swapl(&stuff->majorVersion);
swapl(&stuff->minorVersion);
return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}","static _X_COLD VAR_0
SProcXFixesQueryVersion(ClientPtr VAR_1)
{
REQUEST(VAR_2);
swaps(&VAR_3->length);
swapl(&VAR_3->majorVersion);
swapl(&VAR_3->minorVersion);
return (*VAR_4[VAR_3->xfixesReqType]) (VAR_1);
}",,"static _X_COLD int
SProcXFixesQueryVersion(ClientPtr client)
{
    REQUEST(xXFixesQueryVersionReq);
    REQUEST_SIZE_MATCH(xXFixesQueryVersionReq);

    swaps(&stuff->length);
    swapl(&stuff->majorVersion);
    swapl(&stuff->minorVersion);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}","static _X_COLD VAR_0
SProcXFixesQueryVersion(ClientPtr VAR_1)
{
    REQUEST(VAR_2);
    REQUEST_SIZE_MATCH(VAR_2);

    swaps(&VAR_3->length);
    swapl(&VAR_3->majorVersion);
    swapl(&VAR_3->minorVersion);
    return (*VAR_4[VAR_3->xfixesReqType]) (VAR_1);
}",,"--- func_before
+++ func_after
@@ -2,6 +2,7 @@
 SProcXFixesQueryVersion(ClientPtr client)
 {
     REQUEST(xXFixesQueryVersionReq);
+    REQUEST_SIZE_MATCH(xXFixesQueryVersionReq);
 
     swaps(&stuff->length);
     swapl(&stuff->majorVersion);","{'deleted_lines': [], 'added_lines': ['    REQUEST_SIZE_MATCH(xXFixesQueryVersionReq);']}",True,xorg-x11-server before 1.19.5 was missing length validation in XFIXES extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,9.8,CRITICAL,3,test,,5
CVE-2018-1000028,['CWE-269'],AV:N/AC:M/Au:N/C:P/I:P/A:N,0,torvalds/linux,"Commit bdcf0a423ea1 (""kernel: make groups_sort calling a responsibility
group_info allocators"") appears to break nfsd rootsquash in a pretty
major way.

It adds a call to groups_sort() inside the loop that copies/squashes
gids, which means the valid gids are sorted along with the following
garbage.  The net result is that the highest numbered valid gids are
replaced with any lower-valued garbage gids, possibly including 0.

We should sort only once, after filling in all the gids.

Fixes: bdcf0a423ea1 (""kernel: make groups_sort calling a responsibility ..."")
Signed-off-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
Acked-by: J. Bruce Fields <bfields@redhat.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
",1995266727fa8143897e89b55f5d3c79aa828420,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=1995266727fa8143897e89b55f5d3c79aa828420,fs/nfsd/auth.c,nfsd_setuser,"int nfsd_setuser(struct svc_rqst *rqstp, struct svc_export *exp)
{
struct group_info *rqgi;
struct group_info *gi;
struct cred *new;
int i;
int flags = nfsexp_flags(rqstp, exp);
validate_process_creds();
revert_creds(get_cred(current_real_cred()));
new = prepare_creds();
if (!new)
return -ENOMEM;
new->fsuid = rqstp->rq_cred.cr_uid;
new->fsgid = rqstp->rq_cred.cr_gid;
rqgi = rqstp->rq_cred.cr_group_info;
if (flags & NFSEXP_ALLSQUASH) {
new->fsuid = exp->ex_anon_uid;
new->fsgid = exp->ex_anon_gid;
gi = groups_alloc(0);
if (!gi)
goto oom;
} else if (flags & NFSEXP_ROOTSQUASH) {
if (uid_eq(new->fsuid, GLOBAL_ROOT_UID))
new->fsuid = exp->ex_anon_uid;
if (gid_eq(new->fsgid, GLOBAL_ROOT_GID))
new->fsgid = exp->ex_anon_gid;
gi = groups_alloc(rqgi->ngroups);
if (!gi)
goto oom;
for (i = 0; i < rqgi->ngroups; i++) {
if (gid_eq(GLOBAL_ROOT_GID, rqgi->gid[i]))
gi->gid[i] = exp->ex_anon_gid;
else
gi->gid[i] = rqgi->gid[i];
groups_sort(gi);
}
} else {
gi = get_group_info(rqgi);
}
if (uid_eq(new->fsuid, INVALID_UID))
new->fsuid = exp->ex_anon_uid;
if (gid_eq(new->fsgid, INVALID_GID))
new->fsgid = exp->ex_anon_gid;
set_groups(new, gi);
put_group_info(gi);
if (!uid_eq(new->fsuid, GLOBAL_ROOT_UID))
new->cap_effective = cap_drop_nfsd_set(new->cap_effective);
else
new->cap_effective = cap_raise_nfsd_set(new->cap_effective,
new->cap_permitted);
validate_process_creds();
put_cred(override_creds(new));
put_cred(new);
validate_process_creds();
return 0;
oom:
abort_creds(new);
return -ENOMEM;
}","int nfsd_setuser(struct svc_rqst *VAR_0, struct svc_export *VAR_1)
{
struct group_info *VAR_2;
struct group_info *VAR_3;
struct cred *VAR_4;
int VAR_5;
int VAR_6 = nfsexp_flags(VAR_0, VAR_1);
validate_process_creds();
revert_creds(get_cred(current_real_cred()));
VAR_4 = prepare_creds();
if (!VAR_4)
return -VAR_7;
VAR_4->fsuid = VAR_0->rq_cred.cr_uid;
VAR_4->fsgid = VAR_0->rq_cred.cr_gid;
VAR_2 = VAR_0->rq_cred.cr_group_info;
if (VAR_6 & VAR_8) {
VAR_4->fsuid = VAR_1->ex_anon_uid;
VAR_4->fsgid = VAR_1->ex_anon_gid;
VAR_3 = groups_alloc(0);
if (!VAR_3)
goto oom;
} else if (VAR_6 & VAR_9) {
if (uid_eq(VAR_4->fsuid, VAR_10))
VAR_4->fsuid = VAR_1->ex_anon_uid;
if (gid_eq(VAR_4->fsgid, VAR_11))
VAR_4->fsgid = VAR_1->ex_anon_gid;
VAR_3 = groups_alloc(VAR_2->ngroups);
if (!VAR_3)
goto oom;
for (VAR_5 = 0; VAR_5 < VAR_2->ngroups; VAR_5++) {
if (gid_eq(VAR_11, VAR_2->gid[VAR_5]))
VAR_3->gid[VAR_5] = VAR_1->ex_anon_gid;
else
VAR_3->gid[VAR_5] = VAR_2->gid[VAR_5];
groups_sort(VAR_3);
}
} else {
VAR_3 = get_group_info(VAR_2);
}
if (uid_eq(VAR_4->fsuid, VAR_12))
VAR_4->fsuid = VAR_1->ex_anon_uid;
if (gid_eq(VAR_4->fsgid, VAR_13))
VAR_4->fsgid = VAR_1->ex_anon_gid;
set_groups(VAR_4, VAR_3);
put_group_info(VAR_3);
if (!uid_eq(VAR_4->fsuid, VAR_10))
VAR_4->cap_effective = cap_drop_nfsd_set(VAR_4->cap_effective);
else
VAR_4->cap_effective = cap_raise_nfsd_set(VAR_4->cap_effective,
VAR_4->cap_permitted);
validate_process_creds();
put_cred(override_creds(VAR_4));
put_cred(VAR_4);
validate_process_creds();
return 0;
oom:
abort_creds(VAR_4);
return -VAR_7;
}",torvalds/linux/1995266727fa8143897e89b55f5d3c79aa828420/auth.c/vul/before/0.json,"int nfsd_setuser(struct svc_rqst *rqstp, struct svc_export *exp)
{
	struct group_info *rqgi;
	struct group_info *gi;
	struct cred *new;
	int i;
	int flags = nfsexp_flags(rqstp, exp);

	validate_process_creds();

	/* discard any old override before preparing the new set */
	revert_creds(get_cred(current_real_cred()));
	new = prepare_creds();
	if (!new)
		return -ENOMEM;

	new->fsuid = rqstp->rq_cred.cr_uid;
	new->fsgid = rqstp->rq_cred.cr_gid;

	rqgi = rqstp->rq_cred.cr_group_info;

	if (flags & NFSEXP_ALLSQUASH) {
		new->fsuid = exp->ex_anon_uid;
		new->fsgid = exp->ex_anon_gid;
		gi = groups_alloc(0);
		if (!gi)
			goto oom;
	} else if (flags & NFSEXP_ROOTSQUASH) {
		if (uid_eq(new->fsuid, GLOBAL_ROOT_UID))
			new->fsuid = exp->ex_anon_uid;
		if (gid_eq(new->fsgid, GLOBAL_ROOT_GID))
			new->fsgid = exp->ex_anon_gid;

		gi = groups_alloc(rqgi->ngroups);
		if (!gi)
			goto oom;

		for (i = 0; i < rqgi->ngroups; i++) {
			if (gid_eq(GLOBAL_ROOT_GID, rqgi->gid[i]))
				gi->gid[i] = exp->ex_anon_gid;
			else
				gi->gid[i] = rqgi->gid[i];
		}

		/* Each thread allocates its own gi, no race */
		groups_sort(gi);
	} else {
		gi = get_group_info(rqgi);
	}

	if (uid_eq(new->fsuid, INVALID_UID))
		new->fsuid = exp->ex_anon_uid;
	if (gid_eq(new->fsgid, INVALID_GID))
		new->fsgid = exp->ex_anon_gid;

	set_groups(new, gi);
	put_group_info(gi);

	if (!uid_eq(new->fsuid, GLOBAL_ROOT_UID))
		new->cap_effective = cap_drop_nfsd_set(new->cap_effective);
	else
		new->cap_effective = cap_raise_nfsd_set(new->cap_effective,
							new->cap_permitted);
	validate_process_creds();
	put_cred(override_creds(new));
	put_cred(new);
	validate_process_creds();
	return 0;

oom:
	abort_creds(new);
	return -ENOMEM;
}","int nfsd_setuser(struct svc_rqst *VAR_0, struct svc_export *VAR_1)
{
	struct group_info *VAR_2;
	struct group_info *VAR_3;
	struct cred *VAR_4;
	int VAR_5;
	int VAR_6 = nfsexp_flags(VAR_0, VAR_1);

	validate_process_creds();

	/* COMMENT_0 */
	revert_creds(get_cred(current_real_cred()));
	VAR_4 = prepare_creds();
	if (!VAR_4)
		return -VAR_7;

	VAR_4->fsuid = VAR_0->rq_cred.cr_uid;
	VAR_4->fsgid = VAR_0->rq_cred.cr_gid;

	VAR_2 = VAR_0->rq_cred.cr_group_info;

	if (VAR_6 & VAR_8) {
		VAR_4->fsuid = VAR_1->ex_anon_uid;
		VAR_4->fsgid = VAR_1->ex_anon_gid;
		VAR_3 = groups_alloc(0);
		if (!VAR_3)
			goto oom;
	} else if (VAR_6 & VAR_9) {
		if (uid_eq(VAR_4->fsuid, VAR_10))
			VAR_4->fsuid = VAR_1->ex_anon_uid;
		if (gid_eq(VAR_4->fsgid, VAR_11))
			VAR_4->fsgid = VAR_1->ex_anon_gid;

		VAR_3 = groups_alloc(VAR_2->ngroups);
		if (!VAR_3)
			goto oom;

		for (VAR_5 = 0; VAR_5 < VAR_2->ngroups; VAR_5++) {
			if (gid_eq(VAR_11, VAR_2->gid[VAR_5]))
				VAR_3->gid[VAR_5] = VAR_1->ex_anon_gid;
			else
				VAR_3->gid[VAR_5] = VAR_2->gid[VAR_5];
		}

		/* COMMENT_1 */
		groups_sort(VAR_3);
	} else {
		VAR_3 = get_group_info(VAR_2);
	}

	if (uid_eq(VAR_4->fsuid, VAR_12))
		VAR_4->fsuid = VAR_1->ex_anon_uid;
	if (gid_eq(VAR_4->fsgid, VAR_13))
		VAR_4->fsgid = VAR_1->ex_anon_gid;

	set_groups(VAR_4, VAR_3);
	put_group_info(VAR_3);

	if (!uid_eq(VAR_4->fsuid, VAR_10))
		VAR_4->cap_effective = cap_drop_nfsd_set(VAR_4->cap_effective);
	else
		VAR_4->cap_effective = cap_raise_nfsd_set(VAR_4->cap_effective,
							VAR_4->cap_permitted);
	validate_process_creds();
	put_cred(override_creds(VAR_4));
	put_cred(VAR_4);
	validate_process_creds();
	return 0;

oom:
	abort_creds(VAR_4);
	return -VAR_7;
}",torvalds/linux/1995266727fa8143897e89b55f5d3c79aa828420/auth.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -40,10 +40,10 @@
 				gi->gid[i] = exp->ex_anon_gid;
 			else
 				gi->gid[i] = rqgi->gid[i];
+		}
 
-			/* Each thread allocates its own gi, no race */
-			groups_sort(gi);
-		}
+		/* Each thread allocates its own gi, no race */
+		groups_sort(gi);
 	} else {
 		gi = get_group_info(rqgi);
 	}","{'deleted_lines': ['\t\t\t/* Each thread allocates its own gi, no race */', '\t\t\tgroups_sort(gi);', '\t\t}'], 'added_lines': ['\t\t}', '\t\t/* Each thread allocates its own gi, no race */', '\t\tgroups_sort(gi);']}",True,"Linux kernel version after commit bdcf0a423ea1 - 4.15-rc4+, 4.14.8+, 4.9.76+, 4.4.111+ contains a Incorrect Access Control vulnerability in NFS server (nfsd) that can result in remote users reading or writing files they should not be able to via NFS. This attack appear to be exploitable via NFS server must export a filesystem with the ""rootsquash"" options enabled. This vulnerability appears to have been fixed in after commit 1995266727fa.",7.4,HIGH,2,test,,5
CVE-2022-47929,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"While experimenting with applying noqueue to a classful queue discipline,
we discovered a NULL pointer dereference in the __dev_queue_xmit()
path that generates a kernel OOPS:

    # dev=enp0s5
    # tc qdisc replace dev $dev root handle 1: htb default 1
    # tc class add dev $dev parent 1: classid 1:1 htb rate 10mbit
    # tc qdisc add dev $dev parent 1:1 handle 10: noqueue
    # ping -I $dev -w 1 -c 1 1.1.1.1

[    2.172856] BUG: kernel NULL pointer dereference, address: 0000000000000000
[    2.173217] #PF: supervisor instruction fetch in kernel mode
...
[    2.178451] Call Trace:
[    2.178577]  <TASK>
[    2.178686]  htb_enqueue+0x1c8/0x370
[    2.178880]  dev_qdisc_enqueue+0x15/0x90
[    2.179093]  __dev_queue_xmit+0x798/0xd00
[    2.179305]  ? _raw_write_lock_bh+0xe/0x30
[    2.179522]  ? __local_bh_enable_ip+0x32/0x70
[    2.179759]  ? ___neigh_create+0x610/0x840
[    2.179968]  ? eth_header+0x21/0xc0
[    2.180144]  ip_finish_output2+0x15e/0x4f0
[    2.180348]  ? dst_output+0x30/0x30
[    2.180525]  ip_push_pending_frames+0x9d/0xb0
[    2.180739]  raw_sendmsg+0x601/0xcb0
[    2.180916]  ? _raw_spin_trylock+0xe/0x50
[    2.181112]  ? _raw_spin_unlock_irqrestore+0x16/0x30
[    2.181354]  ? get_page_from_freelist+0xcd6/0xdf0
[    2.181594]  ? sock_sendmsg+0x56/0x60
[    2.181781]  sock_sendmsg+0x56/0x60
[    2.181958]  __sys_sendto+0xf7/0x160
[    2.182139]  ? handle_mm_fault+0x6e/0x1d0
[    2.182366]  ? do_user_addr_fault+0x1e1/0x660
[    2.182627]  __x64_sys_sendto+0x1b/0x30
[    2.182881]  do_syscall_64+0x38/0x90
[    2.183085]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
...
[    2.187402]  </TASK>

Previously in commit d66d6c3152e8 (""net: sched: register noqueue
qdisc""), NULL was set for the noqueue discipline on noqueue init
so that __dev_queue_xmit() falls through for the noqueue case. This
also sets a bypass of the enqueue NULL check in the
register_qdisc() function for the struct noqueue_disc_ops.

Classful queue disciplines make it past the NULL check in
__dev_queue_xmit() because the discipline is set to htb (in this case),
and then in the call to __dev_xmit_skb(), it calls into htb_enqueue()
which grabs a leaf node for a class and then calls qdisc_enqueue() by
passing in a queue discipline which assumes ->enqueue() is not set to NULL.

Fix this by not allowing classes to be assigned to the noqueue
discipline. Linux TC Notes states that classes cannot be set to
the noqueue discipline. [1] Let's enforce that here.

Links:
1. https://linux-tc-notes.sourceforge.net/tc/doc/sch_noqueue.txt

Fixes: d66d6c3152e8 (""net: sched: register noqueue qdisc"")
Cc: stable@vger.kernel.org
Signed-off-by: Frederick Lawler <fred@cloudflare.com>
Reviewed-by: Jakub Sitnicki <jakub@cloudflare.com>
Link: https://lore.kernel.org/r/20230109163906.706000-1-fred@cloudflare.com
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
",96398560f26aa07e8f2969d73c8197e6a6d10407,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=96398560f26aa07e8f2969d73c8197e6a6d10407,net/sched/sch_api.c,qdisc_graft,"static int qdisc_graft(struct net_device *dev, struct Qdisc *parent,
struct sk_buff *skb, struct nlmsghdr *n, u32 classid,
struct Qdisc *new, struct Qdisc *old,
struct netlink_ext_ack *extack)
{
struct Qdisc *q = old;
struct net *net = dev_net(dev);
if (parent == NULL) {
unsigned int i, num_q, ingress;
ingress = 0;
num_q = dev->num_tx_queues;
if ((q && q->flags & TCQ_F_INGRESS) ||
(new && new->flags & TCQ_F_INGRESS)) {
num_q = 1;
ingress = 1;
if (!dev_ingress_queue(dev)) {
NL_SET_ERR_MSG(extack, ""Device does not have an ingress queue"");
return -ENOENT;
}
}
if (dev->flags & IFF_UP)
dev_deactivate(dev);
qdisc_offload_graft_root(dev, new, old, extack);
if (new && new->ops->attach && !ingress)
goto skip;
for (i = 0; i < num_q; i++) {
struct netdev_queue *dev_queue = dev_ingress_queue(dev);
if (!ingress)
dev_queue = netdev_get_tx_queue(dev, i);
old = dev_graft_qdisc(dev_queue, new);
if (new && i > 0)
qdisc_refcount_inc(new);
if (!ingress)
qdisc_put(old);
}
skip:
if (!ingress) {
old = rtnl_dereference(dev->qdisc);
if (new && !new->ops->attach)
qdisc_refcount_inc(new);
rcu_assign_pointer(dev->qdisc, new ? : &noop_qdisc);
notify_and_destroy(net, skb, n, classid, old, new);
if (new && new->ops->attach)
new->ops->attach(new);
} else {
notify_and_destroy(net, skb, n, classid, old, new);
}
if (dev->flags & IFF_UP)
dev_activate(dev);
} else {
const struct Qdisc_class_ops *cops = parent->ops->cl_ops;
unsigned long cl;
int err;
if (new && (new->flags & TCQ_F_NOLOCK) && !(parent->flags & TCQ_F_NOLOCK))
qdisc_clear_nolock(new);
if (!cops || !cops->graft)
return -EOPNOTSUPP;
cl = cops->find(parent, classid);
if (!cl) {
NL_SET_ERR_MSG(extack, ""Specified class not found"");
return -ENOENT;
}
err = cops->graft(parent, cl, new, &old, extack);
if (err)
return err;
notify_and_destroy(net, skb, n, classid, old, new);
}
return 0;
}","static int qdisc_graft(struct net_device *VAR_0, struct Qdisc *VAR_1,
struct sk_buff *VAR_2, struct nlmsghdr *VAR_3, u32 VAR_4,
struct Qdisc *VAR_5, struct Qdisc *VAR_6,
struct netlink_ext_ack *VAR_7)
{
struct Qdisc *VAR_8 = VAR_6;
struct net *net = dev_net(VAR_0);
if (VAR_1 == NULL) {
unsigned int VAR_9, VAR_10, VAR_11;
VAR_11 = 0;
VAR_10 = VAR_0->num_tx_queues;
if ((VAR_8 && VAR_8->flags & VAR_12) ||
(VAR_5 && VAR_5->flags & VAR_12)) {
VAR_10 = 1;
VAR_11 = 1;
if (!dev_ingress_queue(VAR_0)) {
NL_SET_ERR_MSG(VAR_7, ""Device does not have an ingress queue"");
return -VAR_13;
}
}
if (VAR_0->flags & VAR_14)
dev_deactivate(VAR_0);
qdisc_offload_graft_root(VAR_0, VAR_5, VAR_6, VAR_7);
if (VAR_5 && VAR_5->ops->attach && !VAR_11)
goto skip;
for (VAR_9 = 0; VAR_9 < VAR_10; VAR_9++) {
struct netdev_queue *VAR_15 = dev_ingress_queue(VAR_0);
if (!VAR_11)
VAR_15 = netdev_get_tx_queue(VAR_0, VAR_9);
VAR_6 = dev_graft_qdisc(VAR_15, VAR_5);
if (VAR_5 && VAR_9 > 0)
qdisc_refcount_inc(VAR_5);
if (!VAR_11)
qdisc_put(VAR_6);
}
skip:
if (!VAR_11) {
VAR_6 = rtnl_dereference(VAR_0->qdisc);
if (VAR_5 && !VAR_5->ops->attach)
qdisc_refcount_inc(VAR_5);
rcu_assign_pointer(VAR_0->qdisc, VAR_5 ?VAR_16 : &VAR_17);
notify_and_destroy(net, VAR_2, VAR_3, VAR_4, VAR_6, VAR_5);
if (VAR_5 && VAR_5->ops->attach)
VAR_5->ops->attach(VAR_5);
} else {
notify_and_destroy(net, VAR_2, VAR_3, VAR_4, VAR_6, VAR_5);
}
if (VAR_0->flags & VAR_14)
dev_activate(VAR_0);
} else {
const struct Qdisc_class_ops *VAR_18 = VAR_1->ops->cl_ops;
unsigned long VAR_19;
int VAR_20;
if (VAR_5 && (VAR_5->flags & VAR_21) && !(VAR_1->flags & VAR_21))
qdisc_clear_nolock(VAR_5);
if (!VAR_18 || !VAR_18->graft)
return -VAR_22;
VAR_19 = VAR_18->find(VAR_1, VAR_4);
if (!VAR_19) {
NL_SET_ERR_MSG(VAR_7, ""Specified class not found"");
return -VAR_13;
}
VAR_20 = VAR_18->graft(VAR_1, VAR_19, VAR_5, &VAR_6, VAR_7);
if (VAR_20)
return VAR_20;
notify_and_destroy(net, VAR_2, VAR_3, VAR_4, VAR_6, VAR_5);
}
return 0;
}",torvalds/linux/96398560f26aa07e8f2969d73c8197e6a6d10407/sch_api.c/vul/before/0.json,"static int qdisc_graft(struct net_device *dev, struct Qdisc *parent,
		       struct sk_buff *skb, struct nlmsghdr *n, u32 classid,
		       struct Qdisc *new, struct Qdisc *old,
		       struct netlink_ext_ack *extack)
{
	struct Qdisc *q = old;
	struct net *net = dev_net(dev);

	if (parent == NULL) {
		unsigned int i, num_q, ingress;

		ingress = 0;
		num_q = dev->num_tx_queues;
		if ((q && q->flags & TCQ_F_INGRESS) ||
		    (new && new->flags & TCQ_F_INGRESS)) {
			num_q = 1;
			ingress = 1;
			if (!dev_ingress_queue(dev)) {
				NL_SET_ERR_MSG(extack, ""Device does not have an ingress queue"");
				return -ENOENT;
			}
		}

		if (dev->flags & IFF_UP)
			dev_deactivate(dev);

		qdisc_offload_graft_root(dev, new, old, extack);

		if (new && new->ops->attach && !ingress)
			goto skip;

		for (i = 0; i < num_q; i++) {
			struct netdev_queue *dev_queue = dev_ingress_queue(dev);

			if (!ingress)
				dev_queue = netdev_get_tx_queue(dev, i);

			old = dev_graft_qdisc(dev_queue, new);
			if (new && i > 0)
				qdisc_refcount_inc(new);

			if (!ingress)
				qdisc_put(old);
		}

skip:
		if (!ingress) {
			old = rtnl_dereference(dev->qdisc);
			if (new && !new->ops->attach)
				qdisc_refcount_inc(new);
			rcu_assign_pointer(dev->qdisc, new ? : &noop_qdisc);

			notify_and_destroy(net, skb, n, classid, old, new);

			if (new && new->ops->attach)
				new->ops->attach(new);
		} else {
			notify_and_destroy(net, skb, n, classid, old, new);
		}

		if (dev->flags & IFF_UP)
			dev_activate(dev);
	} else {
		const struct Qdisc_class_ops *cops = parent->ops->cl_ops;
		unsigned long cl;
		int err;

		/* Only support running class lockless if parent is lockless */
		if (new && (new->flags & TCQ_F_NOLOCK) && !(parent->flags & TCQ_F_NOLOCK))
			qdisc_clear_nolock(new);

		if (!cops || !cops->graft)
			return -EOPNOTSUPP;

		cl = cops->find(parent, classid);
		if (!cl) {
			NL_SET_ERR_MSG(extack, ""Specified class not found"");
			return -ENOENT;
		}

		if (new && new->ops == &noqueue_qdisc_ops) {
			NL_SET_ERR_MSG(extack, ""Cannot assign noqueue to a class"");
			return -EINVAL;
		}

		err = cops->graft(parent, cl, new, &old, extack);
		if (err)
			return err;
		notify_and_destroy(net, skb, n, classid, old, new);
	}
	return 0;
}","static int qdisc_graft(struct net_device *VAR_0, struct Qdisc *VAR_1,
		       struct sk_buff *VAR_2, struct nlmsghdr *VAR_3, u32 VAR_4,
		       struct Qdisc *VAR_5, struct Qdisc *VAR_6,
		       struct netlink_ext_ack *VAR_7)
{
	struct Qdisc *VAR_8 = VAR_6;
	struct net *net = dev_net(VAR_0);

	if (VAR_1 == NULL) {
		unsigned int VAR_9, VAR_10, VAR_11;

		VAR_11 = 0;
		VAR_10 = VAR_0->num_tx_queues;
		if ((VAR_8 && VAR_8->flags & VAR_12) ||
		    (VAR_5 && VAR_5->flags & VAR_12)) {
			VAR_10 = 1;
			VAR_11 = 1;
			if (!dev_ingress_queue(VAR_0)) {
				NL_SET_ERR_MSG(VAR_7, ""Device does not have an ingress queue"");
				return -VAR_13;
			}
		}

		if (VAR_0->flags & VAR_14)
			dev_deactivate(VAR_0);

		qdisc_offload_graft_root(VAR_0, VAR_5, VAR_6, VAR_7);

		if (VAR_5 && VAR_5->ops->attach && !VAR_11)
			goto skip;

		for (VAR_9 = 0; VAR_9 < VAR_10; VAR_9++) {
			struct netdev_queue *VAR_15 = dev_ingress_queue(VAR_0);

			if (!VAR_11)
				VAR_15 = netdev_get_tx_queue(VAR_0, VAR_9);

			VAR_6 = dev_graft_qdisc(VAR_15, VAR_5);
			if (VAR_5 && VAR_9 > 0)
				qdisc_refcount_inc(VAR_5);

			if (!VAR_11)
				qdisc_put(VAR_6);
		}

skip:
		if (!VAR_11) {
			VAR_6 = rtnl_dereference(VAR_0->qdisc);
			if (VAR_5 && !VAR_5->ops->attach)
				qdisc_refcount_inc(VAR_5);
			rcu_assign_pointer(VAR_0->qdisc, VAR_5 ?VAR_16 : &VAR_17);

			notify_and_destroy(net, VAR_2, VAR_3, VAR_4, VAR_6, VAR_5);

			if (VAR_5 && VAR_5->ops->attach)
				VAR_5->ops->attach(VAR_5);
		} else {
			notify_and_destroy(net, VAR_2, VAR_3, VAR_4, VAR_6, VAR_5);
		}

		if (VAR_0->flags & VAR_14)
			dev_activate(VAR_0);
	} else {
		const struct Qdisc_class_ops *VAR_18 = VAR_1->ops->cl_ops;
		unsigned long VAR_19;
		int VAR_20;

		/* COMMENT_0 */
		if (VAR_5 && (VAR_5->flags & VAR_21) && !(VAR_1->flags & VAR_21))
			qdisc_clear_nolock(VAR_5);

		if (!VAR_18 || !VAR_18->graft)
			return -VAR_22;

		VAR_19 = VAR_18->find(VAR_1, VAR_4);
		if (!VAR_19) {
			NL_SET_ERR_MSG(VAR_7, ""Specified class not found"");
			return -VAR_13;
		}

		if (VAR_5 && VAR_5->ops == &VAR_23) {
			NL_SET_ERR_MSG(VAR_7, ""Cannot assign noqueue to a class"");
			return -VAR_24;
		}

		VAR_20 = VAR_18->graft(VAR_1, VAR_19, VAR_5, &VAR_6, VAR_7);
		if (VAR_20)
			return VAR_20;
		notify_and_destroy(net, VAR_2, VAR_3, VAR_4, VAR_6, VAR_5);
	}
	return 0;
}",torvalds/linux/96398560f26aa07e8f2969d73c8197e6a6d10407/sch_api.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -78,6 +78,11 @@
 			return -ENOENT;
 		}
 
+		if (new && new->ops == &noqueue_qdisc_ops) {
+			NL_SET_ERR_MSG(extack, ""Cannot assign noqueue to a class"");
+			return -EINVAL;
+		}
+
 		err = cops->graft(parent, cl, new, &old, extack);
 		if (err)
 			return err;","{'deleted_lines': [], 'added_lines': ['\t\tif (new && new->ops == &noqueue_qdisc_ops) {', '\t\t\tNL_SET_ERR_MSG(extack, ""Cannot assign noqueue to a class"");', '\t\t\treturn -EINVAL;', '\t\t}', '']}",True,"In the Linux kernel before 6.1.6, a NULL pointer dereference bug in the traffic control subsystem allows an unprivileged user to trigger a denial of service (system crash) via a crafted traffic control configuration that is set up with ""tc qdisc"" and ""tc class"" commands. This affects qdisc_graft in net/sched/sch_api.c.",5.5,MEDIUM,1,test,,5
CVE-2023-0401,['CWE-476'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,openssl,"
pk7_doit.c: Check return of BIO_set_md() calls

These calls invoke EVP_DigestInit() which can fail for digests
with implicit fetches. Subsequent EVP_DigestUpdate() from BIO_write()
or EVP_DigestFinal() from BIO_read() will segfault on NULL
dereference. This can be triggered by an attacker providing
PKCS7 data digested with MD4 for example if the legacy provider
is not loaded.

If BIO_set_md() fails the md BIO cannot be used.

CVE-2023-0401

Reviewed-by: Paul Dale <pauli@openssl.org>
Reviewed-by: Dmitry Belyavskiy <beldmit@gmail.com>
",d3b6dfd70db844c4499bec6ad6601623a565e674,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=d3b6dfd70db844c4499bec6ad6601623a565e674,crypto/pkcs7/pk7_doit.c,PKCS7_dataDecode,"BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
{
int i, len;
BIO *out = NULL, *btmp = NULL, *etmp = NULL, *bio = NULL;
X509_ALGOR *xa;
ASN1_OCTET_STRING *data_body = NULL;
EVP_MD *evp_md = NULL;
const EVP_MD *md;
EVP_CIPHER *evp_cipher = NULL;
const EVP_CIPHER *cipher = NULL;
EVP_CIPHER_CTX *evp_ctx = NULL;
X509_ALGOR *enc_alg = NULL;
STACK_OF(X509_ALGOR) *md_sk = NULL;
STACK_OF(PKCS7_RECIP_INFO) *rsk = NULL;
PKCS7_RECIP_INFO *ri = NULL;
unsigned char *ek = NULL, *tkey = NULL;
int eklen = 0, tkeylen = 0;
char name[OSSL_MAX_NAME_SIZE];
const PKCS7_CTX *p7_ctx;
OSSL_LIB_CTX *libctx;
const char *propq;
if (p7 == NULL) {
ERR_raise(ERR_LIB_PKCS7, PKCS7_R_INVALID_NULL_POINTER);
return NULL;
}
p7_ctx = ossl_pkcs7_get0_ctx(p7);
libctx = ossl_pkcs7_ctx_get0_libctx(p7_ctx);
propq = ossl_pkcs7_ctx_get0_propq(p7_ctx);
if (p7->d.ptr == NULL) {
ERR_raise(ERR_LIB_PKCS7, PKCS7_R_NO_CONTENT);
return NULL;
}
i = OBJ_obj2nid(p7->type);
p7->state = PKCS7_S_HEADER;
switch (i) {
case NID_pkcs7_signed:
data_body = PKCS7_get_octet_string(p7->d.sign->contents);
if (!PKCS7_is_detached(p7) && data_body == NULL) {
ERR_raise(ERR_LIB_PKCS7, PKCS7_R_INVALID_SIGNED_DATA_TYPE);
goto err;
}
md_sk = p7->d.sign->md_algs;
break;
case NID_pkcs7_signedAndEnveloped:
rsk = p7->d.signed_and_enveloped->recipientinfo;
md_sk = p7->d.signed_and_enveloped->md_algs;
data_body = p7->d.signed_and_enveloped->enc_data->enc_data;
enc_alg = p7->d.signed_and_enveloped->enc_data->algorithm;
OBJ_obj2txt(name, sizeof(name), enc_alg->algorithm, 0);
(void)ERR_set_mark();
evp_cipher = EVP_CIPHER_fetch(libctx, name, propq);
if (evp_cipher != NULL)
cipher = evp_cipher;
else
cipher = EVP_get_cipherbyname(name);
if (cipher == NULL) {
(void)ERR_clear_last_mark();
ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNSUPPORTED_CIPHER_TYPE);
goto err;
}
(void)ERR_pop_to_mark();
break;
case NID_pkcs7_enveloped:
rsk = p7->d.enveloped->recipientinfo;
enc_alg = p7->d.enveloped->enc_data->algorithm;
data_body = p7->d.enveloped->enc_data->enc_data;
OBJ_obj2txt(name, sizeof(name), enc_alg->algorithm, 0);
(void)ERR_set_mark();
evp_cipher = EVP_CIPHER_fetch(libctx, name, propq);
if (evp_cipher != NULL)
cipher = evp_cipher;
else
cipher = EVP_get_cipherbyname(name);
if (cipher == NULL) {
(void)ERR_clear_last_mark();
ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNSUPPORTED_CIPHER_TYPE);
goto err;
}
(void)ERR_pop_to_mark();
break;
default:
ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
goto err;
}
if (data_body == NULL && in_bio == NULL) {
ERR_raise(ERR_LIB_PKCS7, PKCS7_R_NO_CONTENT);
goto err;
}
if (md_sk != NULL) {
for (i = 0; i < sk_X509_ALGOR_num(md_sk); i++) {
xa = sk_X509_ALGOR_value(md_sk, i);
if ((btmp = BIO_new(BIO_f_md())) == NULL) {
ERR_raise(ERR_LIB_PKCS7, ERR_R_BIO_LIB);
goto err;
}
OBJ_obj2txt(name, sizeof(name), xa->algorithm, 0);
(void)ERR_set_mark();
evp_md = EVP_MD_fetch(libctx, name, propq);
if (evp_md != NULL)
md = evp_md;
else
md = EVP_get_digestbyname(name);
if (md == NULL) {
(void)ERR_clear_last_mark();
ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNKNOWN_DIGEST_TYPE);
goto err;
}
(void)ERR_pop_to_mark();
BIO_set_md(btmp, md);
EVP_MD_free(evp_md);
if (out == NULL)
out = btmp;
else
BIO_push(out, btmp);
btmp = NULL;
}
}
if (cipher != NULL) {
if ((etmp = BIO_new(BIO_f_cipher())) == NULL) {
ERR_raise(ERR_LIB_PKCS7, ERR_R_BIO_LIB);
goto err;
}
if (pcert) {
for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {
ri = sk_PKCS7_RECIP_INFO_value(rsk, i);
if (!pkcs7_cmp_ri(ri, pcert))
break;
ri = NULL;
}
if (ri == NULL) {
ERR_raise(ERR_LIB_PKCS7,
PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE);
goto err;
}
}
if (pcert == NULL) {
for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {
ri = sk_PKCS7_RECIP_INFO_value(rsk, i);
ri->ctx = p7_ctx;
if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey,
EVP_CIPHER_get_key_length(cipher)) < 0)
goto err;
ERR_clear_error();
}
} else {
ri->ctx = p7_ctx;
if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey, 0) < 0)
goto err;
ERR_clear_error();
}
evp_ctx = NULL;
BIO_get_cipher_ctx(etmp, &evp_ctx);
if (EVP_CipherInit_ex(evp_ctx, cipher, NULL, NULL, NULL, 0) <= 0)
goto err;
if (EVP_CIPHER_asn1_to_param(evp_ctx, enc_alg->parameter) <= 0)
goto err;
len = EVP_CIPHER_CTX_get_key_length(evp_ctx);
if (len <= 0)
goto err;
tkeylen = (size_t)len;
tkey = OPENSSL_malloc(tkeylen);
if (tkey == NULL)
goto err;
if (EVP_CIPHER_CTX_rand_key(evp_ctx, tkey) <= 0)
goto err;
if (ek == NULL) {
ek = tkey;
eklen = tkeylen;
tkey = NULL;
}
if (eklen != EVP_CIPHER_CTX_get_key_length(evp_ctx)) {
if (EVP_CIPHER_CTX_set_key_length(evp_ctx, eklen) <= 0) {
OPENSSL_clear_free(ek, eklen);
ek = tkey;
eklen = tkeylen;
tkey = NULL;
}
}
ERR_clear_error();
if (EVP_CipherInit_ex(evp_ctx, NULL, NULL, ek, NULL, 0) <= 0)
goto err;
OPENSSL_clear_free(ek, eklen);
ek = NULL;
OPENSSL_clear_free(tkey, tkeylen);
tkey = NULL;
if (out == NULL)
out = etmp;
else
BIO_push(out, etmp);
etmp = NULL;
}
if (in_bio != NULL) {
bio = in_bio;
} else {
if (data_body->length > 0)
bio = BIO_new_mem_buf(data_body->data, data_body->length);
else {
bio = BIO_new(BIO_s_mem());
if (bio == NULL)
goto err;
BIO_set_mem_eof_return(bio, 0);
}
if (bio == NULL)
goto err;
}
BIO_push(out, bio);
bio = NULL;
EVP_CIPHER_free(evp_cipher);
return out;
err:
EVP_CIPHER_free(evp_cipher);
OPENSSL_clear_free(ek, eklen);
OPENSSL_clear_free(tkey, tkeylen);
BIO_free_all(out);
BIO_free_all(btmp);
BIO_free_all(etmp);
BIO_free_all(bio);
return NULL;
}","BIO *PKCS7_dataDecode(PKCS7 *VAR_0, EVP_PKEY *VAR_1, BIO *VAR_2, X509 *VAR_3)
{
int VAR_4, VAR_5;
BIO *VAR_6 = NULL, *VAR_7 = NULL, *VAR_8 = NULL, *VAR_9 = NULL;
X509_ALGOR *VAR_10;
ASN1_OCTET_STRING *VAR_11 = NULL;
EVP_MD *VAR_12 = NULL;
const EVP_MD *VAR_13;
EVP_CIPHER *VAR_14 = NULL;
const EVP_CIPHER *VAR_15 = NULL;
EVP_CIPHER_CTX *VAR_16 = NULL;
X509_ALGOR *VAR_17 = NULL;
STACK_OF(X509_ALGOR) *VAR_18 = NULL;
STACK_OF(VAR_19) *VAR_20 = NULL;
PKCS7_RECIP_INFO *VAR_21 = NULL;
unsigned char *VAR_22 = NULL, *VAR_23 = NULL;
int VAR_24 = 0, VAR_25 = 0;
char VAR_26[VAR_27];
const PKCS7_CTX *VAR_28;
OSSL_LIB_CTX *VAR_29;
const char *VAR_30;
if (VAR_0 == NULL) {
ERR_raise(VAR_31, VAR_32);
return NULL;
}
VAR_28 = ossl_pkcs7_get0_ctx(VAR_0);
VAR_29 = ossl_pkcs7_ctx_get0_libctx(VAR_28);
VAR_30 = ossl_pkcs7_ctx_get0_propq(VAR_28);
if (VAR_0->d.ptr == NULL) {
ERR_raise(VAR_31, VAR_33);
return NULL;
}
VAR_4 = OBJ_obj2nid(VAR_0->type);
VAR_0->state = VAR_34;
switch (VAR_4) {
case VAR_35:
VAR_11 = PKCS7_get_octet_string(VAR_0->d.sign->contents);
if (!PKCS7_is_detached(VAR_0) && VAR_11 == NULL) {
ERR_raise(VAR_31, VAR_36);
goto err;
}
VAR_18 = VAR_0->d.sign->md_algs;
break;
case VAR_37:
VAR_20 = VAR_0->d.signed_and_enveloped->recipientinfo;
VAR_18 = VAR_0->d.signed_and_enveloped->md_algs;
VAR_11 = VAR_0->d.signed_and_enveloped->enc_data->enc_data;
VAR_17 = VAR_0->d.signed_and_enveloped->enc_data->algorithm;
OBJ_obj2txt(VAR_26, sizeof(VAR_26), VAR_17->algorithm, 0);
(void)ERR_set_mark();
VAR_14 = EVP_CIPHER_fetch(VAR_29, VAR_26, VAR_30);
if (VAR_14 != NULL)
VAR_15 = VAR_14;
else
VAR_15 = EVP_get_cipherbyname(VAR_26);
if (VAR_15 == NULL) {
(void)ERR_clear_last_mark();
ERR_raise(VAR_31, VAR_38);
goto err;
}
(void)ERR_pop_to_mark();
break;
case VAR_39:
VAR_20 = VAR_0->d.enveloped->recipientinfo;
VAR_17 = VAR_0->d.enveloped->enc_data->algorithm;
VAR_11 = VAR_0->d.enveloped->enc_data->enc_data;
OBJ_obj2txt(VAR_26, sizeof(VAR_26), VAR_17->algorithm, 0);
(void)ERR_set_mark();
VAR_14 = EVP_CIPHER_fetch(VAR_29, VAR_26, VAR_30);
if (VAR_14 != NULL)
VAR_15 = VAR_14;
else
VAR_15 = EVP_get_cipherbyname(VAR_26);
if (VAR_15 == NULL) {
(void)ERR_clear_last_mark();
ERR_raise(VAR_31, VAR_38);
goto err;
}
(void)ERR_pop_to_mark();
break;
default:
ERR_raise(VAR_31, VAR_40);
goto err;
}
if (VAR_11 == NULL && VAR_2 == NULL) {
ERR_raise(VAR_31, VAR_33);
goto err;
}
if (VAR_18 != NULL) {
for (VAR_4 = 0; VAR_4 < sk_X509_ALGOR_num(VAR_18); VAR_4++) {
VAR_10 = sk_X509_ALGOR_value(VAR_18, VAR_4);
if ((VAR_7 = BIO_new(BIO_f_md())) == NULL) {
ERR_raise(VAR_31, VAR_41);
goto err;
}
OBJ_obj2txt(VAR_26, sizeof(VAR_26), VAR_10->algorithm, 0);
(void)ERR_set_mark();
VAR_12 = EVP_MD_fetch(VAR_29, VAR_26, VAR_30);
if (VAR_12 != NULL)
VAR_13 = VAR_12;
else
VAR_13 = EVP_get_digestbyname(VAR_26);
if (VAR_13 == NULL) {
(void)ERR_clear_last_mark();
ERR_raise(VAR_31, VAR_42);
goto err;
}
(void)ERR_pop_to_mark();
BIO_set_md(VAR_7, VAR_13);
EVP_MD_free(VAR_12);
if (VAR_6 == NULL)
VAR_6 = VAR_7;
else
BIO_push(VAR_6, VAR_7);
VAR_7 = NULL;
}
}
if (VAR_15 != NULL) {
if ((VAR_8 = BIO_new(BIO_f_cipher())) == NULL) {
ERR_raise(VAR_31, VAR_41);
goto err;
}
if (VAR_3) {
for (VAR_4 = 0; VAR_4 < sk_PKCS7_RECIP_INFO_num(VAR_20); VAR_4++) {
VAR_21 = sk_PKCS7_RECIP_INFO_value(VAR_20, VAR_4);
if (!pkcs7_cmp_ri(VAR_21, VAR_3))
break;
VAR_21 = NULL;
}
if (VAR_21 == NULL) {
ERR_raise(VAR_31,
VAR_43);
goto err;
}
}
if (VAR_3 == NULL) {
for (VAR_4 = 0; VAR_4 < sk_PKCS7_RECIP_INFO_num(VAR_20); VAR_4++) {
VAR_21 = sk_PKCS7_RECIP_INFO_value(VAR_20, VAR_4);
VAR_21->ctx = VAR_28;
if (pkcs7_decrypt_rinfo(&VAR_22, &VAR_24, VAR_21, VAR_1,
EVP_CIPHER_get_key_length(VAR_15)) < 0)
goto err;
ERR_clear_error();
}
} else {
VAR_21->ctx = VAR_28;
if (pkcs7_decrypt_rinfo(&VAR_22, &VAR_24, VAR_21, VAR_1, 0) < 0)
goto err;
ERR_clear_error();
}
VAR_16 = NULL;
BIO_get_cipher_ctx(VAR_8, &VAR_16);
if (EVP_CipherInit_ex(VAR_16, VAR_15, NULL, NULL, NULL, 0) <= 0)
goto err;
if (EVP_CIPHER_asn1_to_param(VAR_16, VAR_17->parameter) <= 0)
goto err;
VAR_5 = EVP_CIPHER_CTX_get_key_length(VAR_16);
if (VAR_5 <= 0)
goto err;
VAR_25 = (size_t)VAR_5;
VAR_23 = OPENSSL_malloc(VAR_25);
if (VAR_23 == NULL)
goto err;
if (EVP_CIPHER_CTX_rand_key(VAR_16, VAR_23) <= 0)
goto err;
if (VAR_22 == NULL) {
VAR_22 = VAR_23;
VAR_24 = VAR_25;
VAR_23 = NULL;
}
if (VAR_24 != EVP_CIPHER_CTX_get_key_length(VAR_16)) {
if (EVP_CIPHER_CTX_set_key_length(VAR_16, VAR_24) <= 0) {
OPENSSL_clear_free(VAR_22, VAR_24);
VAR_22 = VAR_23;
VAR_24 = VAR_25;
VAR_23 = NULL;
}
}
ERR_clear_error();
if (EVP_CipherInit_ex(VAR_16, NULL, NULL, VAR_22, NULL, 0) <= 0)
goto err;
OPENSSL_clear_free(VAR_22, VAR_24);
VAR_22 = NULL;
OPENSSL_clear_free(VAR_23, VAR_25);
VAR_23 = NULL;
if (VAR_6 == NULL)
VAR_6 = VAR_8;
else
BIO_push(VAR_6, VAR_8);
VAR_8 = NULL;
}
if (VAR_2 != NULL) {
VAR_9 = VAR_2;
} else {
if (VAR_11->length > 0)
VAR_9 = BIO_new_mem_buf(VAR_11->data, VAR_11->length);
else {
VAR_9 = BIO_new(BIO_s_mem());
if (VAR_9 == NULL)
goto err;
BIO_set_mem_eof_return(VAR_9, 0);
}
if (VAR_9 == NULL)
goto err;
}
BIO_push(VAR_6, VAR_9);
VAR_9 = NULL;
EVP_CIPHER_free(VAR_14);
return VAR_6;
err:
EVP_CIPHER_free(VAR_14);
OPENSSL_clear_free(VAR_22, VAR_24);
OPENSSL_clear_free(VAR_23, VAR_25);
BIO_free_all(VAR_6);
BIO_free_all(VAR_7);
BIO_free_all(VAR_8);
BIO_free_all(VAR_9);
return NULL;
}",openssl/d3b6dfd70db844c4499bec6ad6601623a565e674/pk7_doit.c/vul/before/0.json,"BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
{
    int i, len;
    BIO *out = NULL, *btmp = NULL, *etmp = NULL, *bio = NULL;
    X509_ALGOR *xa;
    ASN1_OCTET_STRING *data_body = NULL;
    EVP_MD *evp_md = NULL;
    const EVP_MD *md;
    EVP_CIPHER *evp_cipher = NULL;
    const EVP_CIPHER *cipher = NULL;
    EVP_CIPHER_CTX *evp_ctx = NULL;
    X509_ALGOR *enc_alg = NULL;
    STACK_OF(X509_ALGOR) *md_sk = NULL;
    STACK_OF(PKCS7_RECIP_INFO) *rsk = NULL;
    PKCS7_RECIP_INFO *ri = NULL;
    unsigned char *ek = NULL, *tkey = NULL;
    int eklen = 0, tkeylen = 0;
    char name[OSSL_MAX_NAME_SIZE];
    const PKCS7_CTX *p7_ctx;
    OSSL_LIB_CTX *libctx;
    const char *propq;

    if (p7 == NULL) {
        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_INVALID_NULL_POINTER);
        return NULL;
    }

    p7_ctx = ossl_pkcs7_get0_ctx(p7);
    libctx = ossl_pkcs7_ctx_get0_libctx(p7_ctx);
    propq = ossl_pkcs7_ctx_get0_propq(p7_ctx);

    if (p7->d.ptr == NULL) {
        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_NO_CONTENT);
        return NULL;
    }

    i = OBJ_obj2nid(p7->type);
    p7->state = PKCS7_S_HEADER;

    switch (i) {
    case NID_pkcs7_signed:
        /*
         * p7->d.sign->contents is a PKCS7 structure consisting of a contentType
         * field and optional content.
         * data_body is NULL if that structure has no (=detached) content
         * or if the contentType is wrong (i.e., not ""data"").
         */
        data_body = PKCS7_get_octet_string(p7->d.sign->contents);
        if (!PKCS7_is_detached(p7) && data_body == NULL) {
            ERR_raise(ERR_LIB_PKCS7, PKCS7_R_INVALID_SIGNED_DATA_TYPE);
            goto err;
        }
        md_sk = p7->d.sign->md_algs;
        break;
    case NID_pkcs7_signedAndEnveloped:
        rsk = p7->d.signed_and_enveloped->recipientinfo;
        md_sk = p7->d.signed_and_enveloped->md_algs;
        /* data_body is NULL if the optional EncryptedContent is missing. */
        data_body = p7->d.signed_and_enveloped->enc_data->enc_data;
        enc_alg = p7->d.signed_and_enveloped->enc_data->algorithm;

        OBJ_obj2txt(name, sizeof(name), enc_alg->algorithm, 0);

        (void)ERR_set_mark();
        evp_cipher = EVP_CIPHER_fetch(libctx, name, propq);
        if (evp_cipher != NULL)
            cipher = evp_cipher;
        else
            cipher = EVP_get_cipherbyname(name);

        if (cipher == NULL) {
            (void)ERR_clear_last_mark();
            ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNSUPPORTED_CIPHER_TYPE);
            goto err;
        }
        (void)ERR_pop_to_mark();
        break;
    case NID_pkcs7_enveloped:
        rsk = p7->d.enveloped->recipientinfo;
        enc_alg = p7->d.enveloped->enc_data->algorithm;
        /* data_body is NULL if the optional EncryptedContent is missing. */
        data_body = p7->d.enveloped->enc_data->enc_data;
        OBJ_obj2txt(name, sizeof(name), enc_alg->algorithm, 0);

        (void)ERR_set_mark();
        evp_cipher = EVP_CIPHER_fetch(libctx, name, propq);
        if (evp_cipher != NULL)
            cipher = evp_cipher;
        else
            cipher = EVP_get_cipherbyname(name);

        if (cipher == NULL) {
            (void)ERR_clear_last_mark();
            ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNSUPPORTED_CIPHER_TYPE);
            goto err;
        }
        (void)ERR_pop_to_mark();
        break;
    default:
        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
        goto err;
    }

    /* Detached content must be supplied via in_bio instead. */
    if (data_body == NULL && in_bio == NULL) {
        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_NO_CONTENT);
        goto err;
    }

    /* We will be checking the signature */
    if (md_sk != NULL) {
        for (i = 0; i < sk_X509_ALGOR_num(md_sk); i++) {
            xa = sk_X509_ALGOR_value(md_sk, i);
            if ((btmp = BIO_new(BIO_f_md())) == NULL) {
                ERR_raise(ERR_LIB_PKCS7, ERR_R_BIO_LIB);
                goto err;
            }

            OBJ_obj2txt(name, sizeof(name), xa->algorithm, 0);

            (void)ERR_set_mark();
            evp_md = EVP_MD_fetch(libctx, name, propq);
            if (evp_md != NULL)
                md = evp_md;
            else
                md = EVP_get_digestbyname(name);

            if (md == NULL) {
                (void)ERR_clear_last_mark();
                ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNKNOWN_DIGEST_TYPE);
                goto err;
            }
            (void)ERR_pop_to_mark();

            if (BIO_set_md(btmp, md) <= 0) {
                EVP_MD_free(evp_md);
                ERR_raise(ERR_LIB_PKCS7, ERR_R_BIO_LIB);
                goto err;
            }
            EVP_MD_free(evp_md);
            if (out == NULL)
                out = btmp;
            else
                BIO_push(out, btmp);
            btmp = NULL;
        }
    }

    if (cipher != NULL) {
        if ((etmp = BIO_new(BIO_f_cipher())) == NULL) {
            ERR_raise(ERR_LIB_PKCS7, ERR_R_BIO_LIB);
            goto err;
        }

        /*
         * It was encrypted, we need to decrypt the secret key with the
         * private key
         */

        /*
         * Find the recipientInfo which matches the passed certificate (if
         * any)
         */

        if (pcert) {
            for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {
                ri = sk_PKCS7_RECIP_INFO_value(rsk, i);
                if (!pkcs7_cmp_ri(ri, pcert))
                    break;
                ri = NULL;
            }
            if (ri == NULL) {
                ERR_raise(ERR_LIB_PKCS7,
                          PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE);
                goto err;
            }
        }

        /* If we haven't got a certificate try each ri in turn */
        if (pcert == NULL) {
            /*
             * Always attempt to decrypt all rinfo even after success as a
             * defence against MMA timing attacks.
             */
            for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {
                ri = sk_PKCS7_RECIP_INFO_value(rsk, i);
                ri->ctx = p7_ctx;
                if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey,
                        EVP_CIPHER_get_key_length(cipher)) < 0)
                    goto err;
                ERR_clear_error();
            }
        } else {
            ri->ctx = p7_ctx;
            /* Only exit on fatal errors, not decrypt failure */
            if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey, 0) < 0)
                goto err;
            ERR_clear_error();
        }

        evp_ctx = NULL;
        BIO_get_cipher_ctx(etmp, &evp_ctx);
        if (EVP_CipherInit_ex(evp_ctx, cipher, NULL, NULL, NULL, 0) <= 0)
            goto err;
        if (EVP_CIPHER_asn1_to_param(evp_ctx, enc_alg->parameter) <= 0)
            goto err;
        /* Generate random key as MMA defence */
        len = EVP_CIPHER_CTX_get_key_length(evp_ctx);
        if (len <= 0)
            goto err;
        tkeylen = (size_t)len;
        tkey = OPENSSL_malloc(tkeylen);
        if (tkey == NULL)
            goto err;
        if (EVP_CIPHER_CTX_rand_key(evp_ctx, tkey) <= 0)
            goto err;
        if (ek == NULL) {
            ek = tkey;
            eklen = tkeylen;
            tkey = NULL;
        }

        if (eklen != EVP_CIPHER_CTX_get_key_length(evp_ctx)) {
            /*
             * Some S/MIME clients don't use the same key and effective key
             * length. The key length is determined by the size of the
             * decrypted RSA key.
             */
            if (EVP_CIPHER_CTX_set_key_length(evp_ctx, eklen) <= 0) {
                /* Use random key as MMA defence */
                OPENSSL_clear_free(ek, eklen);
                ek = tkey;
                eklen = tkeylen;
                tkey = NULL;
            }
        }
        /* Clear errors so we don't leak information useful in MMA */
        ERR_clear_error();
        if (EVP_CipherInit_ex(evp_ctx, NULL, NULL, ek, NULL, 0) <= 0)
            goto err;

        OPENSSL_clear_free(ek, eklen);
        ek = NULL;
        OPENSSL_clear_free(tkey, tkeylen);
        tkey = NULL;

        if (out == NULL)
            out = etmp;
        else
            BIO_push(out, etmp);
        etmp = NULL;
    }
    if (in_bio != NULL) {
        bio = in_bio;
    } else {
        if (data_body->length > 0)
            bio = BIO_new_mem_buf(data_body->data, data_body->length);
        else {
            bio = BIO_new(BIO_s_mem());
            if (bio == NULL)
                goto err;
            BIO_set_mem_eof_return(bio, 0);
        }
        if (bio == NULL)
            goto err;
    }
    BIO_push(out, bio);
    bio = NULL;
    EVP_CIPHER_free(evp_cipher);
    return out;

 err:
    EVP_CIPHER_free(evp_cipher);
    OPENSSL_clear_free(ek, eklen);
    OPENSSL_clear_free(tkey, tkeylen);
    BIO_free_all(out);
    BIO_free_all(btmp);
    BIO_free_all(etmp);
    BIO_free_all(bio);
    return NULL;
}","BIO *PKCS7_dataDecode(PKCS7 *VAR_0, EVP_PKEY *VAR_1, BIO *VAR_2, X509 *VAR_3)
{
    int VAR_4, VAR_5;
    BIO *VAR_6 = NULL, *VAR_7 = NULL, *VAR_8 = NULL, *VAR_9 = NULL;
    X509_ALGOR *VAR_10;
    ASN1_OCTET_STRING *VAR_11 = NULL;
    EVP_MD *VAR_12 = NULL;
    const EVP_MD *VAR_13;
    EVP_CIPHER *VAR_14 = NULL;
    const EVP_CIPHER *VAR_15 = NULL;
    EVP_CIPHER_CTX *VAR_16 = NULL;
    X509_ALGOR *VAR_17 = NULL;
    STACK_OF(X509_ALGOR) *VAR_18 = NULL;
    STACK_OF(VAR_19) *VAR_20 = NULL;
    PKCS7_RECIP_INFO *VAR_21 = NULL;
    unsigned char *VAR_22 = NULL, *VAR_23 = NULL;
    int VAR_24 = 0, VAR_25 = 0;
    char VAR_26[VAR_27];
    const PKCS7_CTX *VAR_28;
    OSSL_LIB_CTX *VAR_29;
    const char *VAR_30;

    if (VAR_0 == NULL) {
        ERR_raise(VAR_31, VAR_32);
        return NULL;
    }

    VAR_28 = ossl_pkcs7_get0_ctx(VAR_0);
    VAR_29 = ossl_pkcs7_ctx_get0_libctx(VAR_28);
    VAR_30 = ossl_pkcs7_ctx_get0_propq(VAR_28);

    if (VAR_0->d.ptr == NULL) {
        ERR_raise(VAR_31, VAR_33);
        return NULL;
    }

    VAR_4 = OBJ_obj2nid(VAR_0->type);
    VAR_0->state = VAR_34;

    switch (VAR_4) {
    case VAR_35:
        /* COMMENT_0 */
                                                                                
                                      
                                                                         
                                                             
           
        VAR_11 = PKCS7_get_octet_string(VAR_0->d.sign->contents);
        if (!PKCS7_is_detached(VAR_0) && VAR_11 == NULL) {
            ERR_raise(VAR_31, VAR_36);
            goto err;
        }
        VAR_18 = VAR_0->d.sign->md_algs;
        break;
    case VAR_37:
        VAR_20 = VAR_0->d.signed_and_enveloped->recipientinfo;
        VAR_18 = VAR_0->d.signed_and_enveloped->md_algs;
        /* COMMENT_6 */
        VAR_11 = VAR_0->d.signed_and_enveloped->enc_data->enc_data;
        VAR_17 = VAR_0->d.signed_and_enveloped->enc_data->algorithm;

        OBJ_obj2txt(VAR_26, sizeof(VAR_26), VAR_17->algorithm, 0);

        (void)ERR_set_mark();
        VAR_14 = EVP_CIPHER_fetch(VAR_29, VAR_26, VAR_30);
        if (VAR_14 != NULL)
            VAR_15 = VAR_14;
        else
            VAR_15 = EVP_get_cipherbyname(VAR_26);

        if (VAR_15 == NULL) {
            (void)ERR_clear_last_mark();
            ERR_raise(VAR_31, VAR_38);
            goto err;
        }
        (void)ERR_pop_to_mark();
        break;
    case VAR_39:
        VAR_20 = VAR_0->d.enveloped->recipientinfo;
        VAR_17 = VAR_0->d.enveloped->enc_data->algorithm;
        /* COMMENT_6 */
        VAR_11 = VAR_0->d.enveloped->enc_data->enc_data;
        OBJ_obj2txt(VAR_26, sizeof(VAR_26), VAR_17->algorithm, 0);

        (void)ERR_set_mark();
        VAR_14 = EVP_CIPHER_fetch(VAR_29, VAR_26, VAR_30);
        if (VAR_14 != NULL)
            VAR_15 = VAR_14;
        else
            VAR_15 = EVP_get_cipherbyname(VAR_26);

        if (VAR_15 == NULL) {
            (void)ERR_clear_last_mark();
            ERR_raise(VAR_31, VAR_38);
            goto err;
        }
        (void)ERR_pop_to_mark();
        break;
    default:
        ERR_raise(VAR_31, VAR_40);
        goto err;
    }

    /* COMMENT_7 */
    if (VAR_11 == NULL && VAR_2 == NULL) {
        ERR_raise(VAR_31, VAR_33);
        goto err;
    }

    /* COMMENT_8 */
    if (VAR_18 != NULL) {
        for (VAR_4 = 0; VAR_4 < sk_X509_ALGOR_num(VAR_18); VAR_4++) {
            VAR_10 = sk_X509_ALGOR_value(VAR_18, VAR_4);
            if ((VAR_7 = BIO_new(BIO_f_md())) == NULL) {
                ERR_raise(VAR_31, VAR_41);
                goto err;
            }

            OBJ_obj2txt(VAR_26, sizeof(VAR_26), VAR_10->algorithm, 0);

            (void)ERR_set_mark();
            VAR_12 = EVP_MD_fetch(VAR_29, VAR_26, VAR_30);
            if (VAR_12 != NULL)
                VAR_13 = VAR_12;
            else
                VAR_13 = EVP_get_digestbyname(VAR_26);

            if (VAR_13 == NULL) {
                (void)ERR_clear_last_mark();
                ERR_raise(VAR_31, VAR_42);
                goto err;
            }
            (void)ERR_pop_to_mark();

            if (BIO_set_md(VAR_7, VAR_13) <= 0) {
                EVP_MD_free(VAR_12);
                ERR_raise(VAR_31, VAR_41);
                goto err;
            }
            EVP_MD_free(VAR_12);
            if (VAR_6 == NULL)
                VAR_6 = VAR_7;
            else
                BIO_push(VAR_6, VAR_7);
            VAR_7 = NULL;
        }
    }

    if (VAR_15 != NULL) {
        if ((VAR_8 = BIO_new(BIO_f_cipher())) == NULL) {
            ERR_raise(VAR_31, VAR_41);
            goto err;
        }

        /* COMMENT_9 */
                                                                       
                      
           

        /* COMMENT_13 */
                                                                          
               
           

        if (VAR_3) {
            for (VAR_4 = 0; VAR_4 < sk_PKCS7_RECIP_INFO_num(VAR_20); VAR_4++) {
                VAR_21 = sk_PKCS7_RECIP_INFO_value(VAR_20, VAR_4);
                if (!pkcs7_cmp_ri(VAR_21, VAR_3))
                    break;
                VAR_21 = NULL;
            }
            if (VAR_21 == NULL) {
                ERR_raise(VAR_31,
                          VAR_43);
                goto err;
            }
        }

        /* COMMENT_17 */
        if (VAR_3 == NULL) {
            /* COMMENT_18 */
                                                                          
                                                  
               
            for (VAR_4 = 0; VAR_4 < sk_PKCS7_RECIP_INFO_num(VAR_20); VAR_4++) {
                VAR_21 = sk_PKCS7_RECIP_INFO_value(VAR_20, VAR_4);
                VAR_21->ctx = VAR_28;
                if (pkcs7_decrypt_rinfo(&VAR_22, &VAR_24, VAR_21, VAR_1,
                        EVP_CIPHER_get_key_length(VAR_15)) < 0)
                    goto err;
                ERR_clear_error();
            }
        } else {
            VAR_21->ctx = VAR_28;
            /* COMMENT_22 */
            if (pkcs7_decrypt_rinfo(&VAR_22, &VAR_24, VAR_21, VAR_1, 0) < 0)
                goto err;
            ERR_clear_error();
        }

        VAR_16 = NULL;
        BIO_get_cipher_ctx(VAR_8, &VAR_16);
        if (EVP_CipherInit_ex(VAR_16, VAR_15, NULL, NULL, NULL, 0) <= 0)
            goto err;
        if (EVP_CIPHER_asn1_to_param(VAR_16, VAR_17->parameter) <= 0)
            goto err;
        /* COMMENT_23 */
        VAR_5 = EVP_CIPHER_CTX_get_key_length(VAR_16);
        if (VAR_5 <= 0)
            goto err;
        VAR_25 = (size_t)VAR_5;
        VAR_23 = OPENSSL_malloc(VAR_25);
        if (VAR_23 == NULL)
            goto err;
        if (EVP_CIPHER_CTX_rand_key(VAR_16, VAR_23) <= 0)
            goto err;
        if (VAR_22 == NULL) {
            VAR_22 = VAR_23;
            VAR_24 = VAR_25;
            VAR_23 = NULL;
        }

        if (VAR_24 != EVP_CIPHER_CTX_get_key_length(VAR_16)) {
            /* COMMENT_24 */
                                                                           
                                                                      
                                 
               
            if (EVP_CIPHER_CTX_set_key_length(VAR_16, VAR_24) <= 0) {
                /* COMMENT_29 */
                OPENSSL_clear_free(VAR_22, VAR_24);
                VAR_22 = VAR_23;
                VAR_24 = VAR_25;
                VAR_23 = NULL;
            }
        }
        /* COMMENT_30 */
        ERR_clear_error();
        if (EVP_CipherInit_ex(VAR_16, NULL, NULL, VAR_22, NULL, 0) <= 0)
            goto err;

        OPENSSL_clear_free(VAR_22, VAR_24);
        VAR_22 = NULL;
        OPENSSL_clear_free(VAR_23, VAR_25);
        VAR_23 = NULL;

        if (VAR_6 == NULL)
            VAR_6 = VAR_8;
        else
            BIO_push(VAR_6, VAR_8);
        VAR_8 = NULL;
    }
    if (VAR_2 != NULL) {
        VAR_9 = VAR_2;
    } else {
        if (VAR_11->length > 0)
            VAR_9 = BIO_new_mem_buf(VAR_11->data, VAR_11->length);
        else {
            VAR_9 = BIO_new(BIO_s_mem());
            if (VAR_9 == NULL)
                goto err;
            BIO_set_mem_eof_return(VAR_9, 0);
        }
        if (VAR_9 == NULL)
            goto err;
    }
    BIO_push(VAR_6, VAR_9);
    VAR_9 = NULL;
    EVP_CIPHER_free(VAR_14);
    return VAR_6;

 err:
    EVP_CIPHER_free(VAR_14);
    OPENSSL_clear_free(VAR_22, VAR_24);
    OPENSSL_clear_free(VAR_23, VAR_25);
    BIO_free_all(VAR_6);
    BIO_free_all(VAR_7);
    BIO_free_all(VAR_8);
    BIO_free_all(VAR_9);
    return NULL;
}",openssl/d3b6dfd70db844c4499bec6ad6601623a565e674/pk7_doit.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -132,7 +132,11 @@
             }
             (void)ERR_pop_to_mark();
 
-            BIO_set_md(btmp, md);
+            if (BIO_set_md(btmp, md) <= 0) {
+                EVP_MD_free(evp_md);
+                ERR_raise(ERR_LIB_PKCS7, ERR_R_BIO_LIB);
+                goto err;
+            }
             EVP_MD_free(evp_md);
             if (out == NULL)
                 out = btmp;","{'deleted_lines': ['            BIO_set_md(btmp, md);'], 'added_lines': ['            if (BIO_set_md(btmp, md) <= 0) {', '                EVP_MD_free(evp_md);', '                ERR_raise(ERR_LIB_PKCS7, ERR_R_BIO_LIB);', '                goto err;', '            }']}",True,"A NULL pointer can be dereferenced when signatures are being
verified on PKCS7 signed or signedAndEnveloped data. In case the hash
algorithm used for the signature is known to the OpenSSL library but
the implementation of the hash algorithm is not available the digest
initialization will fail. There is a missing check for the return
value from the initialization function which later leads to invalid
usage of the digest API most likely leading to a crash.

The unavailability of an algorithm can be caused by using FIPS
enabled configuration of providers or more commonly by not loading
the legacy provider.

PKCS7 data is processed by the SMIME library calls and also by the
time stamp (TS) library calls. The TLS implementation in OpenSSL does
not call these functions however third party applications would be
affected if they call these functions to verify signatures on untrusted
data.

",7.5,HIGH,2,test,,5
CVE-2023-0401,['CWE-476'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,openssl,"
pk7_doit.c: Check return of BIO_set_md() calls

These calls invoke EVP_DigestInit() which can fail for digests
with implicit fetches. Subsequent EVP_DigestUpdate() from BIO_write()
or EVP_DigestFinal() from BIO_read() will segfault on NULL
dereference. This can be triggered by an attacker providing
PKCS7 data digested with MD4 for example if the legacy provider
is not loaded.

If BIO_set_md() fails the md BIO cannot be used.

CVE-2023-0401

Reviewed-by: Paul Dale <pauli@openssl.org>
Reviewed-by: Dmitry Belyavskiy <beldmit@gmail.com>
",d3b6dfd70db844c4499bec6ad6601623a565e674,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=d3b6dfd70db844c4499bec6ad6601623a565e674,crypto/pkcs7/pk7_doit.c,pkcs7_bio_add_digest,"static int pkcs7_bio_add_digest(BIO **pbio, X509_ALGOR *alg,
const PKCS7_CTX *ctx)
{
BIO *btmp;
char name[OSSL_MAX_NAME_SIZE];
EVP_MD *fetched = NULL;
const EVP_MD *md;
if ((btmp = BIO_new(BIO_f_md())) == NULL) {
ERR_raise(ERR_LIB_PKCS7, ERR_R_BIO_LIB);
goto err;
}
OBJ_obj2txt(name, sizeof(name), alg->algorithm, 0);
(void)ERR_set_mark();
fetched = EVP_MD_fetch(ossl_pkcs7_ctx_get0_libctx(ctx), name,
ossl_pkcs7_ctx_get0_propq(ctx));
if (fetched != NULL)
md = fetched;
else
md = EVP_get_digestbyname(name);
if (md == NULL) {
(void)ERR_clear_last_mark();
ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNKNOWN_DIGEST_TYPE);
goto err;
}
(void)ERR_pop_to_mark();
BIO_set_md(btmp, md);
EVP_MD_free(fetched);
if (*pbio == NULL)
*pbio = btmp;
else if (!BIO_push(*pbio, btmp)) {
ERR_raise(ERR_LIB_PKCS7, ERR_R_BIO_LIB);
goto err;
}
btmp = NULL;
return 1;
err:
BIO_free(btmp);
return 0;
}","static int pkcs7_bio_add_digest(BIO **VAR_0, X509_ALGOR *VAR_1,
const PKCS7_CTX *VAR_2)
{
BIO *VAR_3;
char VAR_4[VAR_5];
EVP_MD *VAR_6 = NULL;
const EVP_MD *VAR_7;
if ((VAR_3 = BIO_new(BIO_f_md())) == NULL) {
ERR_raise(VAR_8, VAR_9);
goto err;
}
OBJ_obj2txt(VAR_4, sizeof(VAR_4), VAR_1->algorithm, 0);
(void)ERR_set_mark();
VAR_6 = EVP_MD_fetch(ossl_pkcs7_ctx_get0_libctx(VAR_2), VAR_4,
ossl_pkcs7_ctx_get0_propq(VAR_2));
if (VAR_6 != NULL)
VAR_7 = VAR_6;
else
VAR_7 = EVP_get_digestbyname(VAR_4);
if (VAR_7 == NULL) {
(void)ERR_clear_last_mark();
ERR_raise(VAR_8, VAR_10);
goto err;
}
(void)ERR_pop_to_mark();
BIO_set_md(VAR_3, VAR_7);
EVP_MD_free(VAR_6);
if (*VAR_0 == NULL)
*VAR_0 = VAR_3;
else if (!BIO_push(*VAR_0, VAR_3)) {
ERR_raise(VAR_8, VAR_9);
goto err;
}
VAR_3 = NULL;
return 1;
err:
BIO_free(VAR_3);
return 0;
}",openssl/d3b6dfd70db844c4499bec6ad6601623a565e674/pk7_doit.c/vul/before/1.json,"static int pkcs7_bio_add_digest(BIO **pbio, X509_ALGOR *alg,
                                const PKCS7_CTX *ctx)
{
    BIO *btmp;
    char name[OSSL_MAX_NAME_SIZE];
    EVP_MD *fetched = NULL;
    const EVP_MD *md;

    if ((btmp = BIO_new(BIO_f_md())) == NULL) {
        ERR_raise(ERR_LIB_PKCS7, ERR_R_BIO_LIB);
        goto err;
    }

    OBJ_obj2txt(name, sizeof(name), alg->algorithm, 0);

    (void)ERR_set_mark();
    fetched = EVP_MD_fetch(ossl_pkcs7_ctx_get0_libctx(ctx), name,
                           ossl_pkcs7_ctx_get0_propq(ctx));
    if (fetched != NULL)
        md = fetched;
    else
        md = EVP_get_digestbyname(name);

    if (md == NULL) {
        (void)ERR_clear_last_mark();
        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNKNOWN_DIGEST_TYPE);
        goto err;
    }
    (void)ERR_pop_to_mark();

    if (BIO_set_md(btmp, md) <= 0) {
        ERR_raise(ERR_LIB_PKCS7, ERR_R_BIO_LIB);
        EVP_MD_free(fetched);
        goto err;
    }
    EVP_MD_free(fetched);
    if (*pbio == NULL)
        *pbio = btmp;
    else if (!BIO_push(*pbio, btmp)) {
        ERR_raise(ERR_LIB_PKCS7, ERR_R_BIO_LIB);
        goto err;
    }
    btmp = NULL;

    return 1;

 err:
    BIO_free(btmp);
    return 0;
}","static int pkcs7_bio_add_digest(BIO **VAR_0, X509_ALGOR *VAR_1,
                                const PKCS7_CTX *VAR_2)
{
    BIO *VAR_3;
    char VAR_4[VAR_5];
    EVP_MD *VAR_6 = NULL;
    const EVP_MD *VAR_7;

    if ((VAR_3 = BIO_new(BIO_f_md())) == NULL) {
        ERR_raise(VAR_8, VAR_9);
        goto err;
    }

    OBJ_obj2txt(VAR_4, sizeof(VAR_4), VAR_1->algorithm, 0);

    (void)ERR_set_mark();
    VAR_6 = EVP_MD_fetch(ossl_pkcs7_ctx_get0_libctx(VAR_2), VAR_4,
                           ossl_pkcs7_ctx_get0_propq(VAR_2));
    if (VAR_6 != NULL)
        VAR_7 = VAR_6;
    else
        VAR_7 = EVP_get_digestbyname(VAR_4);

    if (VAR_7 == NULL) {
        (void)ERR_clear_last_mark();
        ERR_raise(VAR_8, VAR_10);
        goto err;
    }
    (void)ERR_pop_to_mark();

    if (BIO_set_md(VAR_3, VAR_7) <= 0) {
        ERR_raise(VAR_8, VAR_9);
        EVP_MD_free(VAR_6);
        goto err;
    }
    EVP_MD_free(VAR_6);
    if (*VAR_0 == NULL)
        *VAR_0 = VAR_3;
    else if (!BIO_push(*VAR_0, VAR_3)) {
        ERR_raise(VAR_8, VAR_9);
        goto err;
    }
    VAR_3 = NULL;

    return 1;

 err:
    BIO_free(VAR_3);
    return 0;
}",openssl/d3b6dfd70db844c4499bec6ad6601623a565e674/pk7_doit.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -28,7 +28,11 @@
     }
     (void)ERR_pop_to_mark();
 
-    BIO_set_md(btmp, md);
+    if (BIO_set_md(btmp, md) <= 0) {
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_BIO_LIB);
+        EVP_MD_free(fetched);
+        goto err;
+    }
     EVP_MD_free(fetched);
     if (*pbio == NULL)
         *pbio = btmp;","{'deleted_lines': ['    BIO_set_md(btmp, md);'], 'added_lines': ['    if (BIO_set_md(btmp, md) <= 0) {', '        ERR_raise(ERR_LIB_PKCS7, ERR_R_BIO_LIB);', '        EVP_MD_free(fetched);', '        goto err;', '    }']}",True,"A NULL pointer can be dereferenced when signatures are being
verified on PKCS7 signed or signedAndEnveloped data. In case the hash
algorithm used for the signature is known to the OpenSSL library but
the implementation of the hash algorithm is not available the digest
initialization will fail. There is a missing check for the return
value from the initialization function which later leads to invalid
usage of the digest API most likely leading to a crash.

The unavailability of an algorithm can be caused by using FIPS
enabled configuration of providers or more commonly by not loading
the legacy provider.

PKCS7 data is processed by the SMIME library calls and also by the
time stamp (TS) library calls. The TLS implementation in OpenSSL does
not call these functions however third party applications would be
affected if they call these functions to verify signatures on untrusted
data.

",7.5,HIGH,2,test,,5
CVE-2023-26605,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"After commit cbfecb927f42 (""fs: record I_DIRTY_TIME even if inode
already has I_DIRTY_INODE"") writeback_single_inode can push inode with
I_DIRTY_TIME set to b_dirty_time list. In case of freeing inode with
I_DIRTY_TIME set this can happen after deletion of inode from i_io_list
at evict. Stack trace is following.

evict
fat_evict_inode
fat_truncate_blocks
fat_flush_inodes
writeback_inode
sync_inode_metadata(inode, sync=0)
writeback_single_inode(inode, wbc) <- wbc->sync_mode == WB_SYNC_NONE

This will lead to use after free in flusher thread.

Similar issue can be triggered if writeback_single_inode in the
stack trace update inode->i_io_list. Add explicit check to avoid it.

Fixes: cbfecb927f42 (""fs: record I_DIRTY_TIME even if inode already has I_DIRTY_INODE"")
Reported-by: syzbot+6ba92bd00d5093f7e371@syzkaller.appspotmail.com
Reviewed-by: Jan Kara <jack@suse.cz>
Signed-off-by: Svyatoslav Feldsherov <feldsherov@google.com>
Link: https://lore.kernel.org/r/20221115202001.324188-1-feldsherov@google.com
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
",4e3c51f4e805291b057d12f5dda5aeb50a538dc4,https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=4e3c51f4e805291b057d12f5dda5aeb50a538dc4,fs/fs-writeback.c,writeback_single_inode,"static int writeback_single_inode(struct inode *inode,
struct writeback_control *wbc)
{
struct bdi_writeback *wb;
int ret = 0;
spin_lock(&inode->i_lock);
if (!atomic_read(&inode->i_count))
WARN_ON(!(inode->i_state & (I_WILL_FREE|I_FREEING)));
else
WARN_ON(inode->i_state & I_WILL_FREE);
if (inode->i_state & I_SYNC) {
if (wbc->sync_mode != WB_SYNC_ALL)
goto out;
__inode_wait_for_writeback(inode);
}
WARN_ON(inode->i_state & I_SYNC);
if (!(inode->i_state & I_DIRTY_ALL) &&
(wbc->sync_mode != WB_SYNC_ALL ||
!mapping_tagged(inode->i_mapping, PAGECACHE_TAG_WRITEBACK)))
goto out;
inode->i_state |= I_SYNC;
wbc_attach_and_unlock_inode(wbc, inode);
ret = __writeback_single_inode(inode, wbc);
wbc_detach_inode(wbc);
wb = inode_to_wb_and_lock_list(inode);
spin_lock(&inode->i_lock);
if (!(inode->i_state & I_DIRTY_ALL))
inode_cgwb_move_to_attached(inode, wb);
else if (!(inode->i_state & I_SYNC_QUEUED)) {
if ((inode->i_state & I_DIRTY))
redirty_tail_locked(inode, wb);
else if (inode->i_state & I_DIRTY_TIME) {
inode->dirtied_when = jiffies;
inode_io_list_move_locked(inode, wb, &wb->b_dirty_time);
}
}
spin_unlock(&wb->list_lock);
inode_sync_complete(inode);
out:
spin_unlock(&inode->i_lock);
return ret;
}","static int writeback_single_inode(struct inode *inode,
struct writeback_control *VAR_0)
{
struct bdi_writeback *VAR_1;
int VAR_2 = 0;
spin_lock(&inode->i_lock);
if (!atomic_read(&inode->i_count))
WARN_ON(!(inode->i_state & (VAR_3|VAR_4)));
else
WARN_ON(inode->i_state & VAR_3);
if (inode->i_state & VAR_5) {
if (VAR_0->sync_mode != VAR_6)
goto out;
__inode_wait_for_writeback(inode);
}
WARN_ON(inode->i_state & VAR_5);
if (!(inode->i_state & VAR_7) &&
(VAR_0->sync_mode != VAR_6 ||
!mapping_tagged(inode->i_mapping, VAR_8)))
goto out;
inode->i_state |= VAR_5;
wbc_attach_and_unlock_inode(VAR_0, inode);
VAR_2 = __writeback_single_inode(inode, VAR_0);
wbc_detach_inode(VAR_0);
VAR_1 = inode_to_wb_and_lock_list(inode);
spin_lock(&inode->i_lock);
if (!(inode->i_state & VAR_7))
inode_cgwb_move_to_attached(inode, VAR_1);
else if (!(inode->i_state & VAR_9)) {
if ((inode->i_state & VAR_10))
redirty_tail_locked(inode, VAR_1);
else if (inode->i_state & VAR_11) {
inode->dirtied_when = VAR_12;
inode_io_list_move_locked(inode, VAR_1, &VAR_1->b_dirty_time);
}
}
spin_unlock(&VAR_1->list_lock);
inode_sync_complete(inode);
out:
spin_unlock(&inode->i_lock);
return VAR_2;
}",torvalds/linux/4e3c51f4e805291b057d12f5dda5aeb50a538dc4/fs-writeback.c/vul/before/0.json,"static int writeback_single_inode(struct inode *inode,
				  struct writeback_control *wbc)
{
	struct bdi_writeback *wb;
	int ret = 0;

	spin_lock(&inode->i_lock);
	if (!atomic_read(&inode->i_count))
		WARN_ON(!(inode->i_state & (I_WILL_FREE|I_FREEING)));
	else
		WARN_ON(inode->i_state & I_WILL_FREE);

	if (inode->i_state & I_SYNC) {
		/*
		 * Writeback is already running on the inode.  For WB_SYNC_NONE,
		 * that's enough and we can just return.  For WB_SYNC_ALL, we
		 * must wait for the existing writeback to complete, then do
		 * writeback again if there's anything left.
		 */
		if (wbc->sync_mode != WB_SYNC_ALL)
			goto out;
		__inode_wait_for_writeback(inode);
	}
	WARN_ON(inode->i_state & I_SYNC);
	/*
	 * If the inode is already fully clean, then there's nothing to do.
	 *
	 * For data-integrity syncs we also need to check whether any pages are
	 * still under writeback, e.g. due to prior WB_SYNC_NONE writeback.  If
	 * there are any such pages, we'll need to wait for them.
	 */
	if (!(inode->i_state & I_DIRTY_ALL) &&
	    (wbc->sync_mode != WB_SYNC_ALL ||
	     !mapping_tagged(inode->i_mapping, PAGECACHE_TAG_WRITEBACK)))
		goto out;
	inode->i_state |= I_SYNC;
	wbc_attach_and_unlock_inode(wbc, inode);

	ret = __writeback_single_inode(inode, wbc);

	wbc_detach_inode(wbc);

	wb = inode_to_wb_and_lock_list(inode);
	spin_lock(&inode->i_lock);
	/*
	 * If the inode is freeing, its i_io_list shoudn't be updated
	 * as it can be finally deleted at this moment.
	 */
	if (!(inode->i_state & I_FREEING)) {
		/*
		 * If the inode is now fully clean, then it can be safely
		 * removed from its writeback list (if any). Otherwise the
		 * flusher threads are responsible for the writeback lists.
		 */
		if (!(inode->i_state & I_DIRTY_ALL))
			inode_cgwb_move_to_attached(inode, wb);
		else if (!(inode->i_state & I_SYNC_QUEUED)) {
			if ((inode->i_state & I_DIRTY))
				redirty_tail_locked(inode, wb);
			else if (inode->i_state & I_DIRTY_TIME) {
				inode->dirtied_when = jiffies;
				inode_io_list_move_locked(inode,
							  wb,
							  &wb->b_dirty_time);
			}
		}
	}

	spin_unlock(&wb->list_lock);
	inode_sync_complete(inode);
out:
	spin_unlock(&inode->i_lock);
	return ret;
}","static int writeback_single_inode(struct inode *inode,
				  struct writeback_control *VAR_0)
{
	struct bdi_writeback *VAR_1;
	int VAR_2 = 0;

	spin_lock(&inode->i_lock);
	if (!atomic_read(&inode->i_count))
		WARN_ON(!(inode->i_state & (VAR_3|VAR_4)));
	else
		WARN_ON(inode->i_state & VAR_3);

	if (inode->i_state & VAR_5) {
		/* COMMENT_0 */
                                                                  
                                                               
                                                              
                                              
     
		if (VAR_0->sync_mode != VAR_6)
			goto out;
		__inode_wait_for_writeback(inode);
	}
	WARN_ON(inode->i_state & VAR_5);
	/* COMMENT_6 */
                                                                    
   
                                                                        
                                                                        
                                                          
    
	if (!(inode->i_state & VAR_7) &&
	    (VAR_0->sync_mode != VAR_6 ||
	     !mapping_tagged(inode->i_mapping, VAR_8)))
		goto out;
	inode->i_state |= VAR_5;
	wbc_attach_and_unlock_inode(VAR_0, inode);

	VAR_2 = __writeback_single_inode(inode, VAR_0);

	wbc_detach_inode(VAR_0);

	VAR_1 = inode_to_wb_and_lock_list(inode);
	spin_lock(&inode->i_lock);
	/* COMMENT_13 */
                                                              
                                                
    
	if (!(inode->i_state & VAR_4)) {
		/* COMMENT_17 */
                                                           
                                                            
                                                             
     
		if (!(inode->i_state & VAR_7))
			inode_cgwb_move_to_attached(inode, VAR_1);
		else if (!(inode->i_state & VAR_9)) {
			if ((inode->i_state & VAR_10))
				redirty_tail_locked(inode, VAR_1);
			else if (inode->i_state & VAR_11) {
				inode->dirtied_when = VAR_12;
				inode_io_list_move_locked(inode,
							  VAR_1,
							  &VAR_1->b_dirty_time);
			}
		}
	}

	spin_unlock(&VAR_1->list_lock);
	inode_sync_complete(inode);
out:
	spin_unlock(&inode->i_lock);
	return VAR_2;
}",torvalds/linux/4e3c51f4e805291b057d12f5dda5aeb50a538dc4/fs-writeback.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -43,18 +43,26 @@
 	wb = inode_to_wb_and_lock_list(inode);
 	spin_lock(&inode->i_lock);
 	/*
-	 * If the inode is now fully clean, then it can be safely removed from
-	 * its writeback list (if any).  Otherwise the flusher threads are
-	 * responsible for the writeback lists.
+	 * If the inode is freeing, its i_io_list shoudn't be updated
+	 * as it can be finally deleted at this moment.
 	 */
-	if (!(inode->i_state & I_DIRTY_ALL))
-		inode_cgwb_move_to_attached(inode, wb);
-	else if (!(inode->i_state & I_SYNC_QUEUED)) {
-		if ((inode->i_state & I_DIRTY))
-			redirty_tail_locked(inode, wb);
-		else if (inode->i_state & I_DIRTY_TIME) {
-			inode->dirtied_when = jiffies;
-			inode_io_list_move_locked(inode, wb, &wb->b_dirty_time);
+	if (!(inode->i_state & I_FREEING)) {
+		/*
+		 * If the inode is now fully clean, then it can be safely
+		 * removed from its writeback list (if any). Otherwise the
+		 * flusher threads are responsible for the writeback lists.
+		 */
+		if (!(inode->i_state & I_DIRTY_ALL))
+			inode_cgwb_move_to_attached(inode, wb);
+		else if (!(inode->i_state & I_SYNC_QUEUED)) {
+			if ((inode->i_state & I_DIRTY))
+				redirty_tail_locked(inode, wb);
+			else if (inode->i_state & I_DIRTY_TIME) {
+				inode->dirtied_when = jiffies;
+				inode_io_list_move_locked(inode,
+							  wb,
+							  &wb->b_dirty_time);
+			}
 		}
 	}
 ","{'deleted_lines': ['\t * If the inode is now fully clean, then it can be safely removed from', '\t * its writeback list (if any).  Otherwise the flusher threads are', '\t * responsible for the writeback lists.', '\tif (!(inode->i_state & I_DIRTY_ALL))', '\t\tinode_cgwb_move_to_attached(inode, wb);', '\telse if (!(inode->i_state & I_SYNC_QUEUED)) {', '\t\tif ((inode->i_state & I_DIRTY))', '\t\t\tredirty_tail_locked(inode, wb);', '\t\telse if (inode->i_state & I_DIRTY_TIME) {', '\t\t\tinode->dirtied_when = jiffies;', '\t\t\tinode_io_list_move_locked(inode, wb, &wb->b_dirty_time);'], 'added_lines': [""\t * If the inode is freeing, its i_io_list shoudn't be updated"", '\t * as it can be finally deleted at this moment.', '\tif (!(inode->i_state & I_FREEING)) {', '\t\t/*', '\t\t * If the inode is now fully clean, then it can be safely', '\t\t * removed from its writeback list (if any). Otherwise the', '\t\t * flusher threads are responsible for the writeback lists.', '\t\t */', '\t\tif (!(inode->i_state & I_DIRTY_ALL))', '\t\t\tinode_cgwb_move_to_attached(inode, wb);', '\t\telse if (!(inode->i_state & I_SYNC_QUEUED)) {', '\t\t\tif ((inode->i_state & I_DIRTY))', '\t\t\t\tredirty_tail_locked(inode, wb);', '\t\t\telse if (inode->i_state & I_DIRTY_TIME) {', '\t\t\t\tinode->dirtied_when = jiffies;', '\t\t\t\tinode_io_list_move_locked(inode,', '\t\t\t\t\t\t\t  wb,', '\t\t\t\t\t\t\t  &wb->b_dirty_time);', '\t\t\t}']}",True,"In the Linux kernel 6.0.8, there is a use-after-free in inode_cgwb_move_to_attached in fs/fs-writeback.c, related to __list_del_entry_valid.",7.8,HIGH,2,test,,5
CVE-2021-3716,['CWE-924'],AV:N/AC:M/Au:S/C:N/I:N/A:P,0,nbdkit,"server: reset meta context replies on starttls

Related to CVE-2021-3716, but not as severe.  No compliant client will
send NBD_CMD_BLOCK_STATUS unless it first negotiates
NBD_OPT_SET_META_CONTEXT.  If an attacker injects a premature
SET_META_CONTEXT, either the client will never notice (because it
never uses BLOCK_STATUS), or the client will overwrite the attacker's
attempt with the client's own SET_META_CONTEXT request after
encryption is enabled.  So I don't class this as having the potential
to trigger denial-of-service due to any protocol mismatch between
compliant client and server (I don't care what happens with
non-compliant clients).

Fixes: 26455d45 (server: protocol: Implement Block Status ""base:allocation"".)
",6c5faac6a37077cf2366388a80862bb00616d0d8,https://gitlab.com/nbdkit/nbdkit/-/commit/6c5faac6a37077cf2366388a80862bb00616d0d8,server/protocol-handshake-newstyle.c,negotiate_handshake_newstyle_options,"static int
negotiate_handshake_newstyle_options (void)
{
GET_CONN;
struct nbd_new_option new_option;
size_t nr_options;
bool list_seen = false;
uint64_t version;
uint32_t option;
uint32_t optlen;
struct nbd_export_name_option_reply handshake_finish;
const char *optname;
uint64_t exportsize;
struct backend *b;
for (nr_options = MAX_NR_OPTIONS; nr_options > 0; --nr_options) {
CLEANUP_FREE char *data = NULL;
if (conn_recv_full (&new_option, sizeof new_option,
""reading option: conn->recv: %m"") == -1)
return -1;
version = be64toh (new_option.version);
if (version != NBD_NEW_VERSION) {
nbdkit_error (""unknown option version %"" PRIx64
"", expecting %"" PRIx64,
version, NBD_NEW_VERSION);
return -1;
}
optlen = be32toh (new_option.optlen);
if (optlen > MAX_REQUEST_SIZE) {
nbdkit_error (""client option data too long (%"" PRIu32 "")"", optlen);
return -1;
}
data = malloc (optlen + 1); 
if (data == NULL) {
nbdkit_error (""malloc: %m"");
return -1;
}
option = be32toh (new_option.option);
optname = name_of_nbd_opt (option);
if (!(conn->cflags & NBD_FLAG_FIXED_NEWSTYLE) &&
option != NBD_OPT_EXPORT_NAME) {
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID))
return -1;
continue;
}
if (tls == 2 && !conn->using_tls &&
!(option == NBD_OPT_ABORT || option == NBD_OPT_STARTTLS)) {
if (send_newstyle_option_reply (option, NBD_REP_ERR_TLS_REQD))
return -1;
continue;
}
switch (option) {
case NBD_OPT_EXPORT_NAME:
if (conn_recv_full (data, optlen,
""read: %s: %m"", name_of_nbd_opt (option)) == -1)
return -1;
if (check_export_name (option, data, optlen, optlen) == -1)
return -1;
if (finish_newstyle_options (&exportsize, data, optlen) == -1)
return -1;
memset (&handshake_finish, 0, sizeof handshake_finish);
handshake_finish.exportsize = htobe64 (exportsize);
handshake_finish.eflags = htobe16 (conn->eflags);
if (conn->send (&handshake_finish,
(conn->cflags & NBD_FLAG_NO_ZEROES)
? offsetof (struct nbd_export_name_option_reply, zeroes)
: sizeof handshake_finish, 0) == -1) {
nbdkit_error (""write: %s: %m"", optname);
return -1;
}
break;
case NBD_OPT_ABORT:
if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
return -1;
debug (""client sent %s to abort the connection"",
name_of_nbd_opt (option));
return -1;
case NBD_OPT_LIST:
if (optlen != 0) {
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
== -1)
return -1;
if (conn_recv_full (data, optlen,
""read: %s: %m"", name_of_nbd_opt (option)) == -1)
return -1;
continue;
}
if (list_seen) {
debug (""newstyle negotiation: %s: export list already advertised"",
name_of_nbd_opt (option));
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)
return -1;
continue;
}
else {
debug (""newstyle negotiation: %s: advertising exports"",
name_of_nbd_opt (option));
if (send_newstyle_option_reply_exportnames (option, &nr_options) == -1)
return -1;
list_seen = true;
}
break;
case NBD_OPT_STARTTLS:
if (optlen != 0) {
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
== -1)
return -1;
if (conn_recv_full (data, optlen,
""read: %s: %m"", name_of_nbd_opt (option)) == -1)
return -1;
continue;
}
if (tls == 0) {           
#ifdef HAVE_GNUTLS
#define NO_TLS_REPLY NBD_REP_ERR_POLICY
#else
#define NO_TLS_REPLY NBD_REP_ERR_UNSUP
#endif
if (send_newstyle_option_reply (option, NO_TLS_REPLY) == -1)
return -1;
}
else  {
if (conn->using_tls) {
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)
return -1;
continue;
}
if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
return -1;
if (crypto_negotiate_tls (conn->sockin, conn->sockout) == -1)
return -1;
conn->using_tls = true;
debug (""using TLS on this connection"");
conn->structured_replies = false;
for_each_backend (b) {
free (conn->default_exportname[b->i]);
conn->default_exportname[b->i] = NULL;
}
}
break;
case NBD_OPT_INFO:
case NBD_OPT_GO:
if (conn_recv_full (data, optlen, ""read: %s: %m"", optname) == -1)
return -1;
if (optlen < 6) { 
debug (""newstyle negotiation: %s option length < 6"", optname);
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
== -1)
return -1;
continue;
}
{
uint32_t exportnamelen;
uint16_t nrinfos;
uint16_t info;
size_t i;
memcpy (&exportnamelen, &data[0], 4);
exportnamelen = be32toh (exportnamelen);
if (exportnamelen > optlen-6 ) {
debug (""newstyle negotiation: %s: export name too long"", optname);
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
== -1)
return -1;
continue;
}
memcpy (&nrinfos, &data[exportnamelen+4], 2);
nrinfos = be16toh (nrinfos);
if (optlen != 4 + exportnamelen + 2 + 2*nrinfos) {
debug (""newstyle negotiation: %s: ""
""number of information requests incorrect"", optname);
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
== -1)
return -1;
continue;
}
if (check_export_name (option, &data[4], exportnamelen,
optlen - 6) == -1) {
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
== -1)
return -1;
continue;
}
if (finish_newstyle_options (&exportsize,
&data[4], exportnamelen) == -1) {
if (conn->top_context) {
if (backend_finalize (conn->top_context) == -1)
return -1;
backend_close (conn->top_context);
conn->top_context = NULL;
}
if (send_newstyle_option_reply (option, NBD_REP_ERR_UNKNOWN) == -1)
return -1;
continue;
}
if (send_newstyle_option_reply_info_export (option,
NBD_REP_INFO,
NBD_INFO_EXPORT,
exportsize) == -1)
return -1;
for (i = 0; i < nrinfos; ++i) {
memcpy (&info, &data[4 + exportnamelen + 2 + i*2], 2);
info = be16toh (info);
switch (info) {
case NBD_INFO_EXPORT:  break;
case NBD_INFO_NAME:
{
const char *name = &data[4];
size_t namelen = exportnamelen;
if (exportnamelen == 0) {
name = backend_default_export (top, read_only);
if (!name) {
debug (""newstyle negotiation: %s: ""
""NBD_INFO_NAME: no name to send"", optname);
break;
}
namelen = -1;
}
if (send_newstyle_option_reply_info_str (option,
NBD_REP_INFO,
NBD_INFO_NAME,
name, namelen) == -1)
return -1;
}
break;
case NBD_INFO_DESCRIPTION:
{
const char *desc = backend_export_description (conn->top_context);
if (!desc) {
debug (""newstyle negotiation: %s: ""
""NBD_INFO_DESCRIPTION: no description to send"",
optname);
break;
}
if (send_newstyle_option_reply_info_str (option,
NBD_REP_INFO,
NBD_INFO_DESCRIPTION,
desc, -1) == -1)
return -1;
}
break;
default:
debug (""newstyle negotiation: %s: ""
""ignoring NBD_INFO_* request %u (%s)"",
optname, (unsigned) info, name_of_nbd_info (info));
break;
}
}
}
if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
return -1;
if (option == NBD_OPT_INFO) {
if (backend_finalize (conn->top_context) == -1)
return -1;
backend_close (conn->top_context);
conn->top_context = NULL;
}
break;
case NBD_OPT_STRUCTURED_REPLY:
if (optlen != 0) {
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
== -1)
return -1;
if (conn_recv_full (data, optlen,
""read: %s: %m"", name_of_nbd_opt (option)) == -1)
return -1;
continue;
}
debug (""newstyle negotiation: %s: client requested structured replies"",
name_of_nbd_opt (option));
if (no_sr) {
if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)
return -1;
debug (""newstyle negotiation: %s: structured replies are disabled"",
name_of_nbd_opt (option));
break;
}
if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
return -1;
conn->structured_replies = true;
break;
case NBD_OPT_LIST_META_CONTEXT:
case NBD_OPT_SET_META_CONTEXT:
{
uint32_t opt_index;
uint32_t exportnamelen;
uint32_t nr_queries;
uint32_t querylen;
const char *what;
if (conn_recv_full (data, optlen, ""read: %s: %m"", optname) == -1)
return -1;
if (!conn->structured_replies) {
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
== -1)
return -1;
continue;
}
what = ""optlen < 8"";
if (optlen < 8) {
opt_meta_invalid_option_len:
debug (""newstyle negotiation: %s: invalid option length: %s"",
optname, what);
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
== -1)
return -1;
continue;
}
memcpy (&exportnamelen, &data[0], 4);
exportnamelen = be32toh (exportnamelen);
what = ""validating export name"";
if (check_export_name (option, &data[4], exportnamelen,
optlen - 8) == -1)
goto opt_meta_invalid_option_len;
if (option == NBD_OPT_SET_META_CONTEXT) {
conn->exportname_from_set_meta_context =
strndup (&data[4], exportnamelen);
if (conn->exportname_from_set_meta_context == NULL) {
nbdkit_error (""malloc: %m"");
return -1;
}
}
opt_index = 4 + exportnamelen;
what = ""reading number of queries"";
if (opt_index+4 > optlen)
goto opt_meta_invalid_option_len;
memcpy (&nr_queries, &data[opt_index], 4);
nr_queries = be32toh (nr_queries);
opt_index += 4;
debug (""newstyle negotiation: %s: %s count: %d"", optname,
option == NBD_OPT_LIST_META_CONTEXT ? ""query"" : ""set"",
nr_queries);
if (option == NBD_OPT_SET_META_CONTEXT)
conn->meta_context_base_allocation = false;
if (nr_queries == 0) {
if (option == NBD_OPT_LIST_META_CONTEXT) {
if (send_newstyle_option_reply_meta_context (option,
NBD_REP_META_CONTEXT,
0, ""base:allocation"")
== -1)
return -1;
}
if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
return -1;
}
else {
while (nr_queries > 0) {
what = ""reading query string length"";
if (opt_index+4 > optlen)
goto opt_meta_invalid_option_len;
memcpy (&querylen, &data[opt_index], 4);
querylen = be32toh (querylen);
opt_index += 4;
what = ""reading query string"";
if (check_string (option, &data[opt_index], querylen,
optlen - opt_index, ""meta context query"") == -1)
goto opt_meta_invalid_option_len;
debug (""newstyle negotiation: %s: %s %.*s"",
optname,
option == NBD_OPT_LIST_META_CONTEXT ? ""query"" : ""set"",
(int) querylen, &data[opt_index]);
if (option == NBD_OPT_LIST_META_CONTEXT &&
querylen == 5 &&
strncmp (&data[opt_index], ""base:"", 5) == 0) {
if (send_newstyle_option_reply_meta_context
(option, NBD_REP_META_CONTEXT,
0, ""base:allocation"") == -1)
return -1;
}
else if (querylen == 15 &&
strncmp (&data[opt_index], ""base:allocation"", 15) == 0) {
if (send_newstyle_option_reply_meta_context
(option, NBD_REP_META_CONTEXT,
option == NBD_OPT_SET_META_CONTEXT
? base_allocation_id : 0,
""base:allocation"") == -1)
return -1;
if (option == NBD_OPT_SET_META_CONTEXT)
conn->meta_context_base_allocation = true;
}
opt_index += querylen;
nr_queries--;
}
if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
return -1;
}
debug (""newstyle negotiation: %s: reply complete"", optname);
}
break;
default:
if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)
return -1;
if (conn_recv_full (data, optlen,
""reading unknown option data: conn->recv: %m"") == -1)
return -1;
}
if (option == NBD_OPT_EXPORT_NAME || option == NBD_OPT_GO)
break;
}
if (nr_options == 0) {
nbdkit_error (""client spent too much time negotiating without selecting ""
""an export"");
return -1;
}
if (tls == 2 && !conn->using_tls) {
nbdkit_error (""non-TLS client tried to connect in --tls=require mode"");
return -1;
}
return 0;
}","static int
negotiate_handshake_newstyle_options (void)
{
VAR_0;
struct nbd_new_option VAR_1;
size_t VAR_2;
bool VAR_3 = false;
uint64_t VAR_4;
uint32_t VAR_5;
uint32_t VAR_6;
struct nbd_export_name_option_reply VAR_7;
const char *VAR_8;
uint64_t VAR_9;
struct backend *VAR_10;
for (VAR_2 = VAR_11; VAR_2 > 0; --VAR_2) {
CLEANUP_FREE char *VAR_12 = NULL;
if (conn_recv_full (&VAR_1, sizeof VAR_1,
""reading option: conn->recv: %m"") == -1)
return -1;
VAR_4 = be64toh (VAR_1.version);
if (VAR_4 != VAR_13) {
nbdkit_error (""unknown option version %"" VAR_14
"", expecting %"" VAR_14,
VAR_4, VAR_13);
return -1;
}
VAR_6 = be32toh (VAR_1.optlen);
if (VAR_6 > VAR_15) {
nbdkit_error (""client option data too long (%"" VAR_16 "")"", VAR_6);
return -1;
}
VAR_12 = malloc (VAR_6 + 1); 
if (VAR_12 == NULL) {
nbdkit_error (""malloc: %m"");
return -1;
}
VAR_5 = be32toh (VAR_1.option);
VAR_8 = name_of_nbd_opt (VAR_5);
if (!(VAR_17->cflags & VAR_18) &&
VAR_5 != VAR_19) {
if (send_newstyle_option_reply (VAR_5, VAR_20))
return -1;
continue;
}
if (VAR_21 == 2 && !VAR_17->using_tls &&
!(VAR_5 == VAR_22 || VAR_5 == VAR_23)) {
if (send_newstyle_option_reply (VAR_5, VAR_24))
return -1;
continue;
}
switch (VAR_5) {
case VAR_19:
if (conn_recv_full (VAR_12, VAR_6,
""read: %s: %m"", name_of_nbd_opt (VAR_5)) == -1)
return -1;
if (check_export_name (VAR_5, VAR_12, VAR_6, VAR_6) == -1)
return -1;
if (finish_newstyle_options (&VAR_9, VAR_12, VAR_6) == -1)
return -1;
memset (&VAR_7, 0, sizeof VAR_7);
VAR_7.exportsize = htobe64 (VAR_9);
VAR_7.eflags = htobe16 (VAR_17->eflags);
if (VAR_17->send (&VAR_7,
(VAR_17->cflags & VAR_25)
? offsetof (struct nbd_export_name_option_reply, VAR_26)
: sizeof VAR_7, 0) == -1) {
nbdkit_error (""write: %s: %m"", VAR_8);
return -1;
}
break;
case VAR_22:
if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
return -1;
debug (""client sent %s to abort the connection"",
name_of_nbd_opt (VAR_5));
return -1;
case VAR_28:
if (VAR_6 != 0) {
if (send_newstyle_option_reply (VAR_5, VAR_20)
== -1)
return -1;
if (conn_recv_full (VAR_12, VAR_6,
""read: %s: %m"", name_of_nbd_opt (VAR_5)) == -1)
return -1;
continue;
}
if (VAR_3) {
debug (""newstyle negotiation: %s: export list already advertised"",
name_of_nbd_opt (VAR_5));
if (send_newstyle_option_reply (VAR_5, VAR_20) == -1)
return -1;
continue;
}
else {
debug (""newstyle negotiation: %s: advertising exports"",
name_of_nbd_opt (VAR_5));
if (send_newstyle_option_reply_exportnames (VAR_5, &VAR_2) == -1)
return -1;
VAR_3 = true;
}
break;
case VAR_23:
if (VAR_6 != 0) {
if (send_newstyle_option_reply (VAR_5, VAR_20)
== -1)
return -1;
if (conn_recv_full (VAR_12, VAR_6,
""read: %s: %m"", name_of_nbd_opt (VAR_5)) == -1)
return -1;
continue;
}
if (VAR_21 == 0) {           
#ifdef VAR_29
#define VAR_30 NBD_REP_ERR_POLICY
#else
#define VAR_30 NBD_REP_ERR_UNSUP
#endif
if (send_newstyle_option_reply (VAR_5, VAR_30) == -1)
return -1;
}
else  {
if (VAR_17->using_tls) {
if (send_newstyle_option_reply (VAR_5, VAR_20) == -1)
return -1;
continue;
}
if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
return -1;
if (crypto_negotiate_tls (VAR_17->sockin, VAR_17->sockout) == -1)
return -1;
VAR_17->using_tls = true;
debug (""using TLS on this connection"");
VAR_17->structured_replies = false;
for_each_backend (VAR_10) {
free (VAR_17->default_exportname[VAR_10->i]);
VAR_17->default_exportname[VAR_10->i] = NULL;
}
}
break;
case VAR_31:
case VAR_32:
if (conn_recv_full (VAR_12, VAR_6, ""read: %s: %m"", VAR_8) == -1)
return -1;
if (VAR_6 < 6) { 
debug (""newstyle negotiation: %s option length < 6"", VAR_8);
if (send_newstyle_option_reply (VAR_5, VAR_20)
== -1)
return -1;
continue;
}
{
uint32_t VAR_33;
uint16_t VAR_34;
uint16_t VAR_35;
size_t VAR_36;
memcpy (&VAR_33, &VAR_12[0], 4);
VAR_33 = be32toh (VAR_33);
if (VAR_33 > VAR_6-6 ) {
debug (""newstyle negotiation: %s: export name too long"", VAR_8);
if (send_newstyle_option_reply (VAR_5, VAR_20)
== -1)
return -1;
continue;
}
memcpy (&VAR_34, &VAR_12[VAR_33+4], 2);
VAR_34 = be16toh (VAR_34);
if (VAR_6 != 4 + VAR_33 + 2 + 2*VAR_34) {
debug (""newstyle negotiation: %s: ""
""number of information requests incorrect"", VAR_8);
if (send_newstyle_option_reply (VAR_5, VAR_20)
== -1)
return -1;
continue;
}
if (check_export_name (VAR_5, &VAR_12[4], VAR_33,
VAR_6 - 6) == -1) {
if (send_newstyle_option_reply (VAR_5, VAR_20)
== -1)
return -1;
continue;
}
if (finish_newstyle_options (&VAR_9,
&VAR_12[4], VAR_33) == -1) {
if (VAR_17->top_context) {
if (backend_finalize (VAR_17->top_context) == -1)
return -1;
backend_close (VAR_17->top_context);
VAR_17->top_context = NULL;
}
if (send_newstyle_option_reply (VAR_5, VAR_37) == -1)
return -1;
continue;
}
if (send_newstyle_option_reply_info_export (VAR_5,
VAR_38,
VAR_39,
VAR_9) == -1)
return -1;
for (VAR_36 = 0; VAR_36 < VAR_34; ++VAR_36) {
memcpy (&VAR_35, &VAR_12[4 + VAR_33 + 2 + VAR_36*2], 2);
VAR_35 = be16toh (VAR_35);
switch (VAR_35) {
case VAR_39:  break;
case VAR_40:
{
const char *VAR_41 = &VAR_12[4];
size_t VAR_42 = VAR_33;
if (VAR_33 == 0) {
VAR_41 = backend_default_export (VAR_43, VAR_44);
if (!VAR_41) {
debug (""newstyle negotiation: %s: ""
""NBD_INFO_NAME: no name to send"", VAR_8);
break;
}
VAR_42 = -1;
}
if (send_newstyle_option_reply_info_str (VAR_5,
VAR_38,
VAR_40,
VAR_41, VAR_42) == -1)
return -1;
}
break;
case VAR_45:
{
const char *VAR_46 = backend_export_description (VAR_17->top_context);
if (!VAR_46) {
debug (""newstyle negotiation: %s: ""
""NBD_INFO_DESCRIPTION: no description to send"",
VAR_8);
break;
}
if (send_newstyle_option_reply_info_str (VAR_5,
VAR_38,
VAR_45,
VAR_46, -1) == -1)
return -1;
}
break;
default:
debug (""newstyle negotiation: %s: ""
""ignoring NBD_INFO_* request %u (%s)"",
VAR_8, (unsigned) VAR_35, name_of_nbd_info (VAR_35));
break;
}
}
}
if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
return -1;
if (VAR_5 == VAR_31) {
if (backend_finalize (VAR_17->top_context) == -1)
return -1;
backend_close (VAR_17->top_context);
VAR_17->top_context = NULL;
}
break;
case VAR_47:
if (VAR_6 != 0) {
if (send_newstyle_option_reply (VAR_5, VAR_20)
== -1)
return -1;
if (conn_recv_full (VAR_12, VAR_6,
""read: %s: %m"", name_of_nbd_opt (VAR_5)) == -1)
return -1;
continue;
}
debug (""newstyle negotiation: %s: client requested structured replies"",
name_of_nbd_opt (VAR_5));
if (VAR_48) {
if (send_newstyle_option_reply (VAR_5, VAR_49) == -1)
return -1;
debug (""newstyle negotiation: %s: structured replies are disabled"",
name_of_nbd_opt (VAR_5));
break;
}
if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
return -1;
VAR_17->structured_replies = true;
break;
case VAR_50:
case VAR_51:
{
uint32_t VAR_52;
uint32_t VAR_33;
uint32_t VAR_53;
uint32_t VAR_54;
const char *VAR_55;
if (conn_recv_full (VAR_12, VAR_6, ""read: %s: %m"", VAR_8) == -1)
return -1;
if (!VAR_17->structured_replies) {
if (send_newstyle_option_reply (VAR_5, VAR_20)
== -1)
return -1;
continue;
}
VAR_55 = ""optlen < 8"";
if (VAR_6 < 8) {
opt_meta_invalid_option_len:
debug (""newstyle negotiation: %s: invalid option length: %s"",
VAR_8, VAR_55);
if (send_newstyle_option_reply (VAR_5, VAR_20)
== -1)
return -1;
continue;
}
memcpy (&VAR_33, &VAR_12[0], 4);
VAR_33 = be32toh (VAR_33);
VAR_55 = ""validating export name"";
if (check_export_name (VAR_5, &VAR_12[4], VAR_33,
VAR_6 - 8) == -1)
goto opt_meta_invalid_option_len;
if (VAR_5 == VAR_51) {
VAR_17->exportname_from_set_meta_context =
strndup (&VAR_12[4], VAR_33);
if (VAR_17->exportname_from_set_meta_context == NULL) {
nbdkit_error (""malloc: %m"");
return -1;
}
}
VAR_52 = 4 + VAR_33;
VAR_55 = ""reading number of queries"";
if (VAR_52+4 > VAR_6)
goto opt_meta_invalid_option_len;
memcpy (&VAR_53, &VAR_12[VAR_52], 4);
VAR_53 = be32toh (VAR_53);
VAR_52 += 4;
debug (""newstyle negotiation: %s: %s count: %d"", VAR_8,
VAR_5 == VAR_50 ? ""query"" : ""set"",
VAR_53);
if (VAR_5 == VAR_51)
VAR_17->meta_context_base_allocation = false;
if (VAR_53 == 0) {
if (VAR_5 == VAR_50) {
if (send_newstyle_option_reply_meta_context (VAR_5,
VAR_56,
0, ""base:allocation"")
== -1)
return -1;
}
if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
return -1;
}
else {
while (VAR_53 > 0) {
VAR_55 = ""reading query string length"";
if (VAR_52+4 > VAR_6)
goto opt_meta_invalid_option_len;
memcpy (&VAR_54, &VAR_12[VAR_52], 4);
VAR_54 = be32toh (VAR_54);
VAR_52 += 4;
VAR_55 = ""reading query string"";
if (check_string (VAR_5, &VAR_12[VAR_52], VAR_54,
VAR_6 - VAR_52, ""meta context query"") == -1)
goto opt_meta_invalid_option_len;
debug (""newstyle negotiation: %s: %s %.*s"",
VAR_8,
VAR_5 == VAR_50 ? ""query"" : ""set"",
(int) VAR_54, &VAR_12[VAR_52]);
if (VAR_5 == VAR_50 &&
VAR_54 == 5 &&
strncmp (&VAR_12[VAR_52], ""base:"", 5) == 0) {
if (send_newstyle_option_reply_meta_context
(VAR_5, VAR_56,
0, ""base:allocation"") == -1)
return -1;
}
else if (VAR_54 == 15 &&
strncmp (&VAR_12[VAR_52], ""base:allocation"", 15) == 0) {
if (send_newstyle_option_reply_meta_context
(VAR_5, VAR_56,
VAR_5 == VAR_51
? VAR_57 : 0,
""base:allocation"") == -1)
return -1;
if (VAR_5 == VAR_51)
VAR_17->meta_context_base_allocation = true;
}
VAR_52 += VAR_54;
VAR_53--;
}
if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
return -1;
}
debug (""newstyle negotiation: %s: reply complete"", VAR_8);
}
break;
default:
if (send_newstyle_option_reply (VAR_5, VAR_49) == -1)
return -1;
if (conn_recv_full (VAR_12, VAR_6,
""reading unknown option data: conn->recv: %m"") == -1)
return -1;
}
if (VAR_5 == VAR_19 || VAR_5 == VAR_32)
break;
}
if (VAR_2 == 0) {
nbdkit_error (""client spent too much time negotiating without selecting ""
""an export"");
return -1;
}
if (VAR_21 == 2 && !VAR_17->using_tls) {
nbdkit_error (""non-TLS client tried to connect in --tls=require mode"");
return -1;
}
return 0;
}",nbdkit/6c5faac6a37077cf2366388a80862bb00616d0d8/protocol-handshake-newstyle.c/vul/before/0.json,"static int
negotiate_handshake_newstyle_options (void)
{
  GET_CONN;
  struct nbd_new_option new_option;
  size_t nr_options;
  bool list_seen = false;
  uint64_t version;
  uint32_t option;
  uint32_t optlen;
  struct nbd_export_name_option_reply handshake_finish;
  const char *optname;
  uint64_t exportsize;
  struct backend *b;

  for (nr_options = MAX_NR_OPTIONS; nr_options > 0; --nr_options) {
    CLEANUP_FREE char *data = NULL;

    if (conn_recv_full (&new_option, sizeof new_option,
                        ""reading option: conn->recv: %m"") == -1)
      return -1;

    version = be64toh (new_option.version);
    if (version != NBD_NEW_VERSION) {
      nbdkit_error (""unknown option version %"" PRIx64
                    "", expecting %"" PRIx64,
                    version, NBD_NEW_VERSION);
      return -1;
    }

    /* There is a maximum option length we will accept, regardless
     * of the option type.
     */
    optlen = be32toh (new_option.optlen);
    if (optlen > MAX_REQUEST_SIZE) {
      nbdkit_error (""client option data too long (%"" PRIu32 "")"", optlen);
      return -1;
    }
    data = malloc (optlen + 1); /* Allowing a trailing NUL helps some uses */
    if (data == NULL) {
      nbdkit_error (""malloc: %m"");
      return -1;
    }

    option = be32toh (new_option.option);
    optname = name_of_nbd_opt (option);

    /* If the client lacks fixed newstyle support, it should only send
     * NBD_OPT_EXPORT_NAME.
     */
    if (!(conn->cflags & NBD_FLAG_FIXED_NEWSTYLE) &&
        option != NBD_OPT_EXPORT_NAME) {
      if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID))
        return -1;
      continue;
    }

    /* In --tls=require / FORCEDTLS mode the only options allowed
     * before TLS negotiation are NBD_OPT_ABORT and NBD_OPT_STARTTLS.
     */
    if (tls == 2 && !conn->using_tls &&
        !(option == NBD_OPT_ABORT || option == NBD_OPT_STARTTLS)) {
      if (send_newstyle_option_reply (option, NBD_REP_ERR_TLS_REQD))
        return -1;
      continue;
    }

    switch (option) {
    case NBD_OPT_EXPORT_NAME:
      if (conn_recv_full (data, optlen,
                          ""read: %s: %m"", name_of_nbd_opt (option)) == -1)
        return -1;
      if (check_export_name (option, data, optlen, optlen) == -1)
        return -1;

      /* We have to finish the handshake by sending handshake_finish.
       * On failure, we have to disconnect.
       */
      if (finish_newstyle_options (&exportsize, data, optlen) == -1)
        return -1;

      memset (&handshake_finish, 0, sizeof handshake_finish);
      handshake_finish.exportsize = htobe64 (exportsize);
      handshake_finish.eflags = htobe16 (conn->eflags);

      if (conn->send (&handshake_finish,
                      (conn->cflags & NBD_FLAG_NO_ZEROES)
                      ? offsetof (struct nbd_export_name_option_reply, zeroes)
                      : sizeof handshake_finish, 0) == -1) {
        nbdkit_error (""write: %s: %m"", optname);
        return -1;
      }
      break;

    case NBD_OPT_ABORT:
      if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
        return -1;
      debug (""client sent %s to abort the connection"",
             name_of_nbd_opt (option));
      return -1;

    case NBD_OPT_LIST:
      if (optlen != 0) {
        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
            == -1)
          return -1;
        if (conn_recv_full (data, optlen,
                            ""read: %s: %m"", name_of_nbd_opt (option)) == -1)
          return -1;
        continue;
      }

      if (list_seen) {
        debug (""newstyle negotiation: %s: export list already advertised"",
               name_of_nbd_opt (option));
        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)
          return -1;
        continue;
      }
      else {
        /* Send back the exportname list. */
        debug (""newstyle negotiation: %s: advertising exports"",
               name_of_nbd_opt (option));
        if (send_newstyle_option_reply_exportnames (option, &nr_options) == -1)
          return -1;
        list_seen = true;
      }
      break;

    case NBD_OPT_STARTTLS:
      if (optlen != 0) {
        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
            == -1)
          return -1;
        if (conn_recv_full (data, optlen,
                            ""read: %s: %m"", name_of_nbd_opt (option)) == -1)
          return -1;
        continue;
      }

      if (tls == 0) {           /* --tls=off (NOTLS mode). */
#ifdef HAVE_GNUTLS
#define NO_TLS_REPLY NBD_REP_ERR_POLICY
#else
#define NO_TLS_REPLY NBD_REP_ERR_UNSUP
#endif
        if (send_newstyle_option_reply (option, NO_TLS_REPLY) == -1)
          return -1;
      }
      else /* --tls=on or --tls=require */ {
        /* We can't upgrade to TLS twice on the same connection. */
        if (conn->using_tls) {
          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)
            return -1;
          continue;
        }

        /* We have to send the (unencrypted) reply before starting
         * the handshake.
         */
        if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
          return -1;

        /* Upgrade the connection to TLS.  Also performs access control. */
        if (crypto_negotiate_tls (conn->sockin, conn->sockout) == -1)
          return -1;
        conn->using_tls = true;
        debug (""using TLS on this connection"");
        /* Wipe out any cached state. */
        conn->structured_replies = false;
        free (conn->exportname_from_set_meta_context);
        conn->exportname_from_set_meta_context = NULL;
        conn->meta_context_base_allocation = false;
        for_each_backend (b) {
          free (conn->default_exportname[b->i]);
          conn->default_exportname[b->i] = NULL;
        }
      }
      break;

    case NBD_OPT_INFO:
    case NBD_OPT_GO:
      if (conn_recv_full (data, optlen, ""read: %s: %m"", optname) == -1)
        return -1;

      if (optlen < 6) { /* 32 bit export length + 16 bit nr info */
        debug (""newstyle negotiation: %s option length < 6"", optname);

        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
            == -1)
          return -1;
        continue;
      }

      {
        uint32_t exportnamelen;
        uint16_t nrinfos;
        uint16_t info;
        size_t i;

        /* Validate the name length and number of INFO requests. */
        memcpy (&exportnamelen, &data[0], 4);
        exportnamelen = be32toh (exportnamelen);
        if (exportnamelen > optlen-6 /* NB optlen >= 6, see above */) {
          debug (""newstyle negotiation: %s: export name too long"", optname);
          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
              == -1)
            return -1;
          continue;
        }
        memcpy (&nrinfos, &data[exportnamelen+4], 2);
        nrinfos = be16toh (nrinfos);
        if (optlen != 4 + exportnamelen + 2 + 2*nrinfos) {
          debug (""newstyle negotiation: %s: ""
                 ""number of information requests incorrect"", optname);
          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
              == -1)
            return -1;
          continue;
        }

        /* As with NBD_OPT_EXPORT_NAME we print the export name and
         * save it in the connection.  If an earlier
         * NBD_OPT_SET_META_CONTEXT used an export name, it must match
         * or else we drop the support for that context.
         */
        if (check_export_name (option, &data[4], exportnamelen,
                               optlen - 6) == -1) {
          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
              == -1)
            return -1;
          continue;
        }

        /* The spec is confusing, but it is required that we send back
         * NBD_INFO_EXPORT, even if the client did not request it!
         * qemu client in particular does not request this, but will
         * fail if we don't send it.  Note that if .open fails, but we
         * succeed at .close, then we merely return an error to the
         * client and let them try another NBD_OPT, rather than
         * disconnecting.
         */
        if (finish_newstyle_options (&exportsize,
                                     &data[4], exportnamelen) == -1) {
          if (conn->top_context) {
            if (backend_finalize (conn->top_context) == -1)
              return -1;
            backend_close (conn->top_context);
            conn->top_context = NULL;
          }
          if (send_newstyle_option_reply (option, NBD_REP_ERR_UNKNOWN) == -1)
            return -1;
          continue;
        }

        if (send_newstyle_option_reply_info_export (option,
                                                    NBD_REP_INFO,
                                                    NBD_INFO_EXPORT,
                                                    exportsize) == -1)
          return -1;

        /* For now we send NBD_INFO_NAME and NBD_INFO_DESCRIPTION if
         * requested, and ignore all other info requests (including
         * NBD_INFO_EXPORT if it was requested, because we replied
         * already above).
         */
        for (i = 0; i < nrinfos; ++i) {
          memcpy (&info, &data[4 + exportnamelen + 2 + i*2], 2);
          info = be16toh (info);
          switch (info) {
          case NBD_INFO_EXPORT: /* ignore - reply sent above */ break;
          case NBD_INFO_NAME:
            {
              const char *name = &data[4];
              size_t namelen = exportnamelen;

              if (exportnamelen == 0) {
                name = backend_default_export (top, read_only);
                if (!name) {
                  debug (""newstyle negotiation: %s: ""
                         ""NBD_INFO_NAME: no name to send"", optname);
                  break;
                }
                namelen = -1;
              }
              if (send_newstyle_option_reply_info_str (option,
                                                       NBD_REP_INFO,
                                                       NBD_INFO_NAME,
                                                       name, namelen) == -1)
                return -1;
            }
            break;
          case NBD_INFO_DESCRIPTION:
            {
              const char *desc = backend_export_description (conn->top_context);

              if (!desc) {
                debug (""newstyle negotiation: %s: ""
                       ""NBD_INFO_DESCRIPTION: no description to send"",
                       optname);
                break;
              }
              if (send_newstyle_option_reply_info_str (option,
                                                       NBD_REP_INFO,
                                                       NBD_INFO_DESCRIPTION,
                                                       desc, -1) == -1)
                return -1;
            }
            break;
          default:
            debug (""newstyle negotiation: %s: ""
                   ""ignoring NBD_INFO_* request %u (%s)"",
                   optname, (unsigned) info, name_of_nbd_info (info));
            break;
          }
        }
      }

      /* Unlike NBD_OPT_EXPORT_NAME, NBD_OPT_GO sends back an ACK
       * or ERROR packet.  If this was NBD_OPT_LIST, call .close.
       */
      if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
        return -1;

      if (option == NBD_OPT_INFO) {
        if (backend_finalize (conn->top_context) == -1)
          return -1;
        backend_close (conn->top_context);
        conn->top_context = NULL;
      }

      break;

    case NBD_OPT_STRUCTURED_REPLY:
      if (optlen != 0) {
        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
            == -1)
          return -1;
        if (conn_recv_full (data, optlen,
                            ""read: %s: %m"", name_of_nbd_opt (option)) == -1)
          return -1;
        continue;
      }

      debug (""newstyle negotiation: %s: client requested structured replies"",
             name_of_nbd_opt (option));

      if (no_sr) {
        /* Must fail with ERR_UNSUP for qemu 4.2 to remain happy;
         * but failing with ERR_POLICY would have been nicer.
         */
        if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)
          return -1;
        debug (""newstyle negotiation: %s: structured replies are disabled"",
               name_of_nbd_opt (option));
        break;
      }

      if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
        return -1;

      conn->structured_replies = true;
      break;

    case NBD_OPT_LIST_META_CONTEXT:
    case NBD_OPT_SET_META_CONTEXT:
      {
        uint32_t opt_index;
        uint32_t exportnamelen;
        uint32_t nr_queries;
        uint32_t querylen;
        const char *what;

        if (conn_recv_full (data, optlen, ""read: %s: %m"", optname) == -1)
          return -1;

        /* Note that we support base:allocation whether or not the plugin
         * supports can_extents.
         */
        if (!conn->structured_replies) {
          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
              == -1)
            return -1;
          continue;
        }

        /* Minimum length of the option payload is:
         *   32 bit export name length followed by empty export name
         * + 32 bit number of queries followed by no queries
         * = 8 bytes.
         */
        what = ""optlen < 8"";
        if (optlen < 8) {
        opt_meta_invalid_option_len:
          debug (""newstyle negotiation: %s: invalid option length: %s"",
                 optname, what);

          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
              == -1)
            return -1;
          continue;
        }

        memcpy (&exportnamelen, &data[0], 4);
        exportnamelen = be32toh (exportnamelen);
        what = ""validating export name"";
        if (check_export_name (option, &data[4], exportnamelen,
                               optlen - 8) == -1)
          goto opt_meta_invalid_option_len;

        /* Remember the export name: the NBD spec says that if the client
         * later uses NBD_OPT_GO on a different export, then the context
         * returned here is not usable.
         */
        if (option == NBD_OPT_SET_META_CONTEXT) {
          conn->exportname_from_set_meta_context =
            strndup (&data[4], exportnamelen);
          if (conn->exportname_from_set_meta_context == NULL) {
            nbdkit_error (""malloc: %m"");
            return -1;
          }
        }

        opt_index = 4 + exportnamelen;

        /* Read the number of queries. */
        what = ""reading number of queries"";
        if (opt_index+4 > optlen)
          goto opt_meta_invalid_option_len;
        memcpy (&nr_queries, &data[opt_index], 4);
        nr_queries = be32toh (nr_queries);
        opt_index += 4;

        /* for LIST: nr_queries == 0 means return all meta contexts
         * for SET: nr_queries == 0 means reset all contexts
         */
        debug (""newstyle negotiation: %s: %s count: %d"", optname,
               option == NBD_OPT_LIST_META_CONTEXT ? ""query"" : ""set"",
               nr_queries);
        if (option == NBD_OPT_SET_META_CONTEXT)
          conn->meta_context_base_allocation = false;
        if (nr_queries == 0) {
          if (option == NBD_OPT_LIST_META_CONTEXT) {
            if (send_newstyle_option_reply_meta_context (option,
                                                         NBD_REP_META_CONTEXT,
                                                         0, ""base:allocation"")
                == -1)
              return -1;
          }

          if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
            return -1;
        }
        else {
          /* Read and answer each query. */
          while (nr_queries > 0) {
            what = ""reading query string length"";
            if (opt_index+4 > optlen)
              goto opt_meta_invalid_option_len;
            memcpy (&querylen, &data[opt_index], 4);
            querylen = be32toh (querylen);
            opt_index += 4;
            what = ""reading query string"";
            if (check_string (option, &data[opt_index], querylen,
                              optlen - opt_index, ""meta context query"") == -1)
              goto opt_meta_invalid_option_len;

            debug (""newstyle negotiation: %s: %s %.*s"",
                   optname,
                   option == NBD_OPT_LIST_META_CONTEXT ? ""query"" : ""set"",
                   (int) querylen, &data[opt_index]);

            /* For LIST, ""base:"" returns all supported contexts in the
             * base namespace.  We only support ""base:allocation"".
             */
            if (option == NBD_OPT_LIST_META_CONTEXT &&
                querylen == 5 &&
                strncmp (&data[opt_index], ""base:"", 5) == 0) {
              if (send_newstyle_option_reply_meta_context
                  (option, NBD_REP_META_CONTEXT,
                   0, ""base:allocation"") == -1)
                return -1;
            }
            /* ""base:allocation"" requested by name. */
            else if (querylen == 15 &&
                     strncmp (&data[opt_index], ""base:allocation"", 15) == 0) {
              if (send_newstyle_option_reply_meta_context
                  (option, NBD_REP_META_CONTEXT,
                   option == NBD_OPT_SET_META_CONTEXT
                   ? base_allocation_id : 0,
                   ""base:allocation"") == -1)
                return -1;
              if (option == NBD_OPT_SET_META_CONTEXT)
                conn->meta_context_base_allocation = true;
            }
            /* Every other query must be ignored. */

            opt_index += querylen;
            nr_queries--;
          }
          if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
            return -1;
        }
        debug (""newstyle negotiation: %s: reply complete"", optname);
      }
      break;

    default:
      /* Unknown option. */
      if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)
        return -1;
      if (conn_recv_full (data, optlen,
                          ""reading unknown option data: conn->recv: %m"") == -1)
        return -1;
    }

    /* Note, since it's not very clear from the protocol doc, that the
     * client must send NBD_OPT_EXPORT_NAME or NBD_OPT_GO last, and
     * that ends option negotiation.
     */
    if (option == NBD_OPT_EXPORT_NAME || option == NBD_OPT_GO)
      break;
  }

  if (nr_options == 0) {
    nbdkit_error (""client spent too much time negotiating without selecting ""
                  ""an export"");
    return -1;
  }

  /* In --tls=require / FORCEDTLS mode, we must have upgraded to TLS
   * by the time we finish option negotiation.  If not, give up.
   */
  if (tls == 2 && !conn->using_tls) {
    nbdkit_error (""non-TLS client tried to connect in --tls=require mode"");
    return -1;
  }

  return 0;
}","static int
negotiate_handshake_newstyle_options (void)
{
  VAR_0;
  struct nbd_new_option VAR_1;
  size_t VAR_2;
  bool VAR_3 = false;
  uint64_t VAR_4;
  uint32_t VAR_5;
  uint32_t VAR_6;
  struct nbd_export_name_option_reply VAR_7;
  const char *VAR_8;
  uint64_t VAR_9;
  struct backend *VAR_10;

  for (VAR_2 = VAR_11; VAR_2 > 0; --VAR_2) {
    CLEANUP_FREE char *VAR_12 = NULL;

    if (conn_recv_full (&VAR_1, sizeof VAR_1,
                        ""reading option: conn->recv: %m"") == -1)
      return -1;

    VAR_4 = be64toh (VAR_1.version);
    if (VAR_4 != VAR_13) {
      nbdkit_error (""unknown option version %"" VAR_14
                    "", expecting %"" VAR_14,
                    VAR_4, VAR_13);
      return -1;
    }

    /* COMMENT_0 */
                          
       
    VAR_6 = be32toh (VAR_1.optlen);
    if (VAR_6 > VAR_15) {
      nbdkit_error (""client option data too long (%"" VAR_16 "")"", VAR_6);
      return -1;
    }
    VAR_12 = malloc (VAR_6 + 1); /* COMMENT_3 */
    if (VAR_12 == NULL) {
      nbdkit_error (""malloc: %m"");
      return -1;
    }

    VAR_5 = be32toh (VAR_1.option);
    VAR_8 = name_of_nbd_opt (VAR_5);

    /* COMMENT_4 */
                           
       
    if (!(VAR_17->cflags & VAR_18) &&
        VAR_5 != VAR_19) {
      if (send_newstyle_option_reply (VAR_5, VAR_20))
        return -1;
      continue;
    }

    /* COMMENT_7 */
                                                                     
       
    if (VAR_21 == 2 && !VAR_17->using_tls &&
        !(VAR_5 == VAR_22 || VAR_5 == VAR_23)) {
      if (send_newstyle_option_reply (VAR_5, VAR_24))
        return -1;
      continue;
    }

    switch (VAR_5) {
    case VAR_19:
      if (conn_recv_full (VAR_12, VAR_6,
                          ""read: %s: %m"", name_of_nbd_opt (VAR_5)) == -1)
        return -1;
      if (check_export_name (VAR_5, VAR_12, VAR_6, VAR_6) == -1)
        return -1;

      /* COMMENT_10 */
                                           
         
      if (finish_newstyle_options (&VAR_9, VAR_12, VAR_6) == -1)
        return -1;

      memset (&VAR_7, 0, sizeof VAR_7);
      VAR_7.exportsize = htobe64 (VAR_9);
      VAR_7.eflags = htobe16 (VAR_17->eflags);

      if (VAR_17->send (&VAR_7,
                      (VAR_17->cflags & VAR_25)
                      ? offsetof (struct nbd_export_name_option_reply, VAR_26)
                      : sizeof VAR_7, 0) == -1) {
        nbdkit_error (""write: %s: %m"", VAR_8);
        return -1;
      }
      break;

    case VAR_22:
      if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
        return -1;
      debug (""client sent %s to abort the connection"",
             name_of_nbd_opt (VAR_5));
      return -1;

    case VAR_28:
      if (VAR_6 != 0) {
        if (send_newstyle_option_reply (VAR_5, VAR_20)
            == -1)
          return -1;
        if (conn_recv_full (VAR_12, VAR_6,
                            ""read: %s: %m"", name_of_nbd_opt (VAR_5)) == -1)
          return -1;
        continue;
      }

      if (VAR_3) {
        debug (""newstyle negotiation: %s: export list already advertised"",
               name_of_nbd_opt (VAR_5));
        if (send_newstyle_option_reply (VAR_5, VAR_20) == -1)
          return -1;
        continue;
      }
      else {
        /* COMMENT_13 */
        debug (""newstyle negotiation: %s: advertising exports"",
               name_of_nbd_opt (VAR_5));
        if (send_newstyle_option_reply_exportnames (VAR_5, &VAR_2) == -1)
          return -1;
        VAR_3 = true;
      }
      break;

    case VAR_23:
      if (VAR_6 != 0) {
        if (send_newstyle_option_reply (VAR_5, VAR_20)
            == -1)
          return -1;
        if (conn_recv_full (VAR_12, VAR_6,
                            ""read: %s: %m"", name_of_nbd_opt (VAR_5)) == -1)
          return -1;
        continue;
      }

      if (VAR_21 == 0) {           /* COMMENT_14 */
#ifdef VAR_29
#define VAR_30 NBD_REP_ERR_POLICY
#else
#define VAR_30 NBD_REP_ERR_UNSUP
#endif
        if (send_newstyle_option_reply (VAR_5, VAR_30) == -1)
          return -1;
      }
      else /* COMMENT_15 */ {
        /* COMMENT_16 */
        if (VAR_17->using_tls) {
          if (send_newstyle_option_reply (VAR_5, VAR_20) == -1)
            return -1;
          continue;
        }

        /* COMMENT_17 */
                         
           
        if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
          return -1;

        /* COMMENT_20 */
        if (crypto_negotiate_tls (VAR_17->sockin, VAR_17->sockout) == -1)
          return -1;
        VAR_17->using_tls = true;
        debug (""using TLS on this connection"");
        /* COMMENT_21 */
        VAR_17->structured_replies = false;
        free (VAR_17->exportname_from_set_meta_context);
        VAR_17->exportname_from_set_meta_context = NULL;
        VAR_17->meta_context_base_allocation = false;
        for_each_backend (VAR_10) {
          free (VAR_17->default_exportname[VAR_10->i]);
          VAR_17->default_exportname[VAR_10->i] = NULL;
        }
      }
      break;

    case VAR_31:
    case VAR_32:
      if (conn_recv_full (VAR_12, VAR_6, ""read: %s: %m"", VAR_8) == -1)
        return -1;

      if (VAR_6 < 6) { /* COMMENT_22 */
        debug (""newstyle negotiation: %s option length < 6"", VAR_8);

        if (send_newstyle_option_reply (VAR_5, VAR_20)
            == -1)
          return -1;
        continue;
      }

      {
        uint32_t VAR_33;
        uint16_t VAR_34;
        uint16_t VAR_35;
        size_t VAR_36;

        /* COMMENT_23 */
        memcpy (&VAR_33, &VAR_12[0], 4);
        VAR_33 = be32toh (VAR_33);
        if (VAR_33 > VAR_6-6 /* COMMENT_24 */) {
          debug (""newstyle negotiation: %s: export name too long"", VAR_8);
          if (send_newstyle_option_reply (VAR_5, VAR_20)
              == -1)
            return -1;
          continue;
        }
        memcpy (&VAR_34, &VAR_12[VAR_33+4], 2);
        VAR_34 = be16toh (VAR_34);
        if (VAR_6 != 4 + VAR_33 + 2 + 2*VAR_34) {
          debug (""newstyle negotiation: %s: ""
                 ""number of information requests incorrect"", VAR_8);
          if (send_newstyle_option_reply (VAR_5, VAR_20)
              == -1)
            return -1;
          continue;
        }

        /* COMMENT_25 */
                                                    
                                                                      
                                                        
           
        if (check_export_name (VAR_5, &VAR_12[4], VAR_33,
                               VAR_6 - 6) == -1) {
          if (send_newstyle_option_reply (VAR_5, VAR_20)
              == -1)
            return -1;
          continue;
        }

        /* COMMENT_30 */
                                                                  
                                                                    
                                                                      
                                                                   
                                                               
                         
           
        if (finish_newstyle_options (&VAR_9,
                                     &VAR_12[4], VAR_33) == -1) {
          if (VAR_17->top_context) {
            if (backend_finalize (VAR_17->top_context) == -1)
              return -1;
            backend_close (VAR_17->top_context);
            VAR_17->top_context = NULL;
          }
          if (send_newstyle_option_reply (VAR_5, VAR_37) == -1)
            return -1;
          continue;
        }

        if (send_newstyle_option_reply_info_export (VAR_5,
                                                    VAR_38,
                                                    VAR_39,
                                                    VAR_9) == -1)
          return -1;

        /* COMMENT_38 */
                                                                   
                                                                  
                          
           
        for (VAR_36 = 0; VAR_36 < VAR_34; ++VAR_36) {
          memcpy (&VAR_35, &VAR_12[4 + VAR_33 + 2 + VAR_36*2], 2);
          VAR_35 = be16toh (VAR_35);
          switch (VAR_35) {
          case VAR_39: /* COMMENT_43 */ break;
          case VAR_40:
            {
              const char *VAR_41 = &VAR_12[4];
              size_t VAR_42 = VAR_33;

              if (VAR_33 == 0) {
                VAR_41 = backend_default_export (VAR_43, VAR_44);
                if (!VAR_41) {
                  debug (""newstyle negotiation: %s: ""
                         ""NBD_INFO_NAME: no name to send"", VAR_8);
                  break;
                }
                VAR_42 = -1;
              }
              if (send_newstyle_option_reply_info_str (VAR_5,
                                                       VAR_38,
                                                       VAR_40,
                                                       VAR_41, VAR_42) == -1)
                return -1;
            }
            break;
          case VAR_45:
            {
              const char *VAR_46 = backend_export_description (VAR_17->top_context);

              if (!VAR_46) {
                debug (""newstyle negotiation: %s: ""
                       ""NBD_INFO_DESCRIPTION: no description to send"",
                       VAR_8);
                break;
              }
              if (send_newstyle_option_reply_info_str (VAR_5,
                                                       VAR_38,
                                                       VAR_45,
                                                       VAR_46, -1) == -1)
                return -1;
            }
            break;
          default:
            debug (""newstyle negotiation: %s: ""
                   ""ignoring NBD_INFO_* request %u (%s)"",
                   VAR_8, (unsigned) VAR_35, name_of_nbd_info (VAR_35));
            break;
          }
        }
      }

      /* COMMENT_44 */
                                                                 
         
      if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
        return -1;

      if (VAR_5 == VAR_31) {
        if (backend_finalize (VAR_17->top_context) == -1)
          return -1;
        backend_close (VAR_17->top_context);
        VAR_17->top_context = NULL;
      }

      break;

    case VAR_47:
      if (VAR_6 != 0) {
        if (send_newstyle_option_reply (VAR_5, VAR_20)
            == -1)
          return -1;
        if (conn_recv_full (VAR_12, VAR_6,
                            ""read: %s: %m"", name_of_nbd_opt (VAR_5)) == -1)
          return -1;
        continue;
      }

      debug (""newstyle negotiation: %s: client requested structured replies"",
             name_of_nbd_opt (VAR_5));

      if (VAR_48) {
        /* COMMENT_47 */
                                                             
           
        if (send_newstyle_option_reply (VAR_5, VAR_49) == -1)
          return -1;
        debug (""newstyle negotiation: %s: structured replies are disabled"",
               name_of_nbd_opt (VAR_5));
        break;
      }

      if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
        return -1;

      VAR_17->structured_replies = true;
      break;

    case VAR_50:
    case VAR_51:
      {
        uint32_t VAR_52;
        uint32_t VAR_33;
        uint32_t VAR_53;
        uint32_t VAR_54;
        const char *VAR_55;

        if (conn_recv_full (VAR_12, VAR_6, ""read: %s: %m"", VAR_8) == -1)
          return -1;

        /* COMMENT_50 */
                                
           
        if (!VAR_17->structured_replies) {
          if (send_newstyle_option_reply (VAR_5, VAR_20)
              == -1)
            return -1;
          continue;
        }

        /* COMMENT_53 */
                                                                    
                                                            
                     
           
        VAR_55 = ""optlen < 8"";
        if (VAR_6 < 8) {
        opt_meta_invalid_option_len:
          debug (""newstyle negotiation: %s: invalid option length: %s"",
                 VAR_8, VAR_55);

          if (send_newstyle_option_reply (VAR_5, VAR_20)
              == -1)
            return -1;
          continue;
        }

        memcpy (&VAR_33, &VAR_12[0], 4);
        VAR_33 = be32toh (VAR_33);
        VAR_55 = ""validating export name"";
        if (check_export_name (VAR_5, &VAR_12[4], VAR_33,
                               VAR_6 - 8) == -1)
          goto opt_meta_invalid_option_len;

        /* COMMENT_58 */
                                                                        
                                       
           
        if (VAR_5 == VAR_51) {
          VAR_17->exportname_from_set_meta_context =
            strndup (&VAR_12[4], VAR_33);
          if (VAR_17->exportname_from_set_meta_context == NULL) {
            nbdkit_error (""malloc: %m"");
            return -1;
          }
        }

        VAR_52 = 4 + VAR_33;

        /* COMMENT_62 */
        VAR_55 = ""reading number of queries"";
        if (VAR_52+4 > VAR_6)
          goto opt_meta_invalid_option_len;
        memcpy (&VAR_53, &VAR_12[VAR_52], 4);
        VAR_53 = be32toh (VAR_53);
        VAR_52 += 4;

        /* COMMENT_63 */
                                                            
           
        debug (""newstyle negotiation: %s: %s count: %d"", VAR_8,
               VAR_5 == VAR_50 ? ""query"" : ""set"",
               VAR_53);
        if (VAR_5 == VAR_51)
          VAR_17->meta_context_base_allocation = false;
        if (VAR_53 == 0) {
          if (VAR_5 == VAR_50) {
            if (send_newstyle_option_reply_meta_context (VAR_5,
                                                         VAR_56,
                                                         0, ""base:allocation"")
                == -1)
              return -1;
          }

          if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
            return -1;
        }
        else {
          /* COMMENT_66 */
          while (VAR_53 > 0) {
            VAR_55 = ""reading query string length"";
            if (VAR_52+4 > VAR_6)
              goto opt_meta_invalid_option_len;
            memcpy (&VAR_54, &VAR_12[VAR_52], 4);
            VAR_54 = be32toh (VAR_54);
            VAR_52 += 4;
            VAR_55 = ""reading query string"";
            if (check_string (VAR_5, &VAR_12[VAR_52], VAR_54,
                              VAR_6 - VAR_52, ""meta context query"") == -1)
              goto opt_meta_invalid_option_len;

            debug (""newstyle negotiation: %s: %s %.*s"",
                   VAR_8,
                   VAR_5 == VAR_50 ? ""query"" : ""set"",
                   (int) VAR_54, &VAR_12[VAR_52]);

            /* COMMENT_67 */
                                                                  
               
            if (VAR_5 == VAR_50 &&
                VAR_54 == 5 &&
                strncmp (&VAR_12[VAR_52], ""base:"", 5) == 0) {
              if (send_newstyle_option_reply_meta_context
                  (VAR_5, VAR_56,
                   0, ""base:allocation"") == -1)
                return -1;
            }
            /* COMMENT_70 */
            else if (VAR_54 == 15 &&
                     strncmp (&VAR_12[VAR_52], ""base:allocation"", 15) == 0) {
              if (send_newstyle_option_reply_meta_context
                  (VAR_5, VAR_56,
                   VAR_5 == VAR_51
                   ? VAR_57 : 0,
                   ""base:allocation"") == -1)
                return -1;
              if (VAR_5 == VAR_51)
                VAR_17->meta_context_base_allocation = true;
            }
            /* COMMENT_71 */

            VAR_52 += VAR_54;
            VAR_53--;
          }
          if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
            return -1;
        }
        debug (""newstyle negotiation: %s: reply complete"", VAR_8);
      }
      break;

    default:
      /* COMMENT_72 */
      if (send_newstyle_option_reply (VAR_5, VAR_49) == -1)
        return -1;
      if (conn_recv_full (VAR_12, VAR_6,
                          ""reading unknown option data: conn->recv: %m"") == -1)
        return -1;
    }

    /* COMMENT_73 */
                                                                   
                                    
       
    if (VAR_5 == VAR_19 || VAR_5 == VAR_32)
      break;
  }

  if (VAR_2 == 0) {
    nbdkit_error (""client spent too much time negotiating without selecting ""
                  ""an export"");
    return -1;
  }

  /* COMMENT_77 */
                                                                
     
  if (VAR_21 == 2 && !VAR_17->using_tls) {
    nbdkit_error (""non-TLS client tried to connect in --tls=require mode"");
    return -1;
  }

  return 0;
}",nbdkit/6c5faac6a37077cf2366388a80862bb00616d0d8/protocol-handshake-newstyle.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -168,6 +168,9 @@
         debug (""using TLS on this connection"");
         /* Wipe out any cached state. */
         conn->structured_replies = false;
+        free (conn->exportname_from_set_meta_context);
+        conn->exportname_from_set_meta_context = NULL;
+        conn->meta_context_base_allocation = false;
         for_each_backend (b) {
           free (conn->default_exportname[b->i]);
           conn->default_exportname[b->i] = NULL;","{'deleted_lines': [], 'added_lines': ['        free (conn->exportname_from_set_meta_context);', '        conn->exportname_from_set_meta_context = NULL;', '        conn->meta_context_base_allocation = false;']}",True,"A flaw was found in nbdkit due to to improperly caching plaintext state across the STARTTLS encryption boundary. A MitM attacker could use this flaw to inject a plaintext NBD_OPT_STRUCTURED_REPLY before proxying everything else a client sends to the server, potentially leading the client to terminate the NBD session. The highest threat from this vulnerability is to system availability.",3.1,LOW,0,test,,5
CVE-2021-3716,['CWE-924'],AV:N/AC:M/Au:S/C:N/I:N/A:P,0,nbdkit,"server: CVE-2021-3716 reset structured replies on starttls

https://nostarttls.secvuln.info/ pointed out a series of CVEs in
common implementation flaw in various SMTP and IMAP clients and
servers, all with a common thread of improperly caching plaintext
state across the STARTTLS encryption boundary; and recommended that
other protocols with a STARTTLS operation perform a similar audit.

It turns out that nbdkit has the same vulnerability in regards to the
NBD protocol: when nbdkit is run in opportunistic TLS mode, an
attacker is able to inject a plaintext NBD_OPT_STRUCTURED_REPLY before
proxying everything else a client sends to the server; if the server
then acts on that plaintext request (as nbdkit did before this patch),
then the server ends up sending structured replies to at least
NBD_CMD_READ, even though the client was assuming that the transition
to TLS has ruled out a MitM attack.

On the bright side, nbdkit's behavior on a second
NBD_OPT_STRUCTURED_REPLY was to still reply with success, so a client
that always requests structured replies after starting TLS sees no
difference in behavior (that is, qemu 2.12 and later are immune) (had
nbdkit given an error to the second request, that may have caused
confusion to more clients).  And there is always the mitigation of
using --tls=require, which lets nbdkit reject the MitM message
pre-encryption.  However, nbd-client 3.15 to the present do not
understand structured replies, and I have confirmed that a MitM
attacker can thus cause a denial-of-service attack that does not
trigger until the client does its first encrypted NBD_CMD_READ.

The NBD spec has been recently tightened to declare the nbdkit
behavior to be a security hole:
https://github.com/NetworkBlockDevice/nbd/commit/77e55378096aa
",09a13dafb7bb3a38ab52eb5501cba786365ba7fd,https://gitlab.com/nbdkit/nbdkit/-/commit/09a13dafb7bb3a38ab52eb5501cba786365ba7fd,server/protocol-handshake-newstyle.c,negotiate_handshake_newstyle_options,"static int
negotiate_handshake_newstyle_options (void)
{
GET_CONN;
struct nbd_new_option new_option;
size_t nr_options;
bool list_seen = false;
uint64_t version;
uint32_t option;
uint32_t optlen;
struct nbd_export_name_option_reply handshake_finish;
const char *optname;
uint64_t exportsize;
struct backend *b;
for (nr_options = MAX_NR_OPTIONS; nr_options > 0; --nr_options) {
CLEANUP_FREE char *data = NULL;
if (conn_recv_full (&new_option, sizeof new_option,
""reading option: conn->recv: %m"") == -1)
return -1;
version = be64toh (new_option.version);
if (version != NBD_NEW_VERSION) {
nbdkit_error (""unknown option version %"" PRIx64
"", expecting %"" PRIx64,
version, NBD_NEW_VERSION);
return -1;
}
optlen = be32toh (new_option.optlen);
if (optlen > MAX_REQUEST_SIZE) {
nbdkit_error (""client option data too long (%"" PRIu32 "")"", optlen);
return -1;
}
data = malloc (optlen + 1); 
if (data == NULL) {
nbdkit_error (""malloc: %m"");
return -1;
}
option = be32toh (new_option.option);
optname = name_of_nbd_opt (option);
if (!(conn->cflags & NBD_FLAG_FIXED_NEWSTYLE) &&
option != NBD_OPT_EXPORT_NAME) {
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID))
return -1;
continue;
}
if (tls == 2 && !conn->using_tls &&
!(option == NBD_OPT_ABORT || option == NBD_OPT_STARTTLS)) {
if (send_newstyle_option_reply (option, NBD_REP_ERR_TLS_REQD))
return -1;
continue;
}
switch (option) {
case NBD_OPT_EXPORT_NAME:
if (conn_recv_full (data, optlen,
""read: %s: %m"", name_of_nbd_opt (option)) == -1)
return -1;
if (check_export_name (option, data, optlen, optlen) == -1)
return -1;
if (finish_newstyle_options (&exportsize, data, optlen) == -1)
return -1;
memset (&handshake_finish, 0, sizeof handshake_finish);
handshake_finish.exportsize = htobe64 (exportsize);
handshake_finish.eflags = htobe16 (conn->eflags);
if (conn->send (&handshake_finish,
(conn->cflags & NBD_FLAG_NO_ZEROES)
? offsetof (struct nbd_export_name_option_reply, zeroes)
: sizeof handshake_finish, 0) == -1) {
nbdkit_error (""write: %s: %m"", optname);
return -1;
}
break;
case NBD_OPT_ABORT:
if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
return -1;
debug (""client sent %s to abort the connection"",
name_of_nbd_opt (option));
return -1;
case NBD_OPT_LIST:
if (optlen != 0) {
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
== -1)
return -1;
if (conn_recv_full (data, optlen,
""read: %s: %m"", name_of_nbd_opt (option)) == -1)
return -1;
continue;
}
if (list_seen) {
debug (""newstyle negotiation: %s: export list already advertised"",
name_of_nbd_opt (option));
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)
return -1;
continue;
}
else {
debug (""newstyle negotiation: %s: advertising exports"",
name_of_nbd_opt (option));
if (send_newstyle_option_reply_exportnames (option, &nr_options) == -1)
return -1;
list_seen = true;
}
break;
case NBD_OPT_STARTTLS:
if (optlen != 0) {
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
== -1)
return -1;
if (conn_recv_full (data, optlen,
""read: %s: %m"", name_of_nbd_opt (option)) == -1)
return -1;
continue;
}
if (tls == 0) {           
#ifdef HAVE_GNUTLS
#define NO_TLS_REPLY NBD_REP_ERR_POLICY
#else
#define NO_TLS_REPLY NBD_REP_ERR_UNSUP
#endif
if (send_newstyle_option_reply (option, NO_TLS_REPLY) == -1)
return -1;
}
else  {
if (conn->using_tls) {
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)
return -1;
continue;
}
if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
return -1;
if (crypto_negotiate_tls (conn->sockin, conn->sockout) == -1)
return -1;
conn->using_tls = true;
debug (""using TLS on this connection"");
for_each_backend (b) {
free (conn->default_exportname[b->i]);
conn->default_exportname[b->i] = NULL;
}
}
break;
case NBD_OPT_INFO:
case NBD_OPT_GO:
if (conn_recv_full (data, optlen, ""read: %s: %m"", optname) == -1)
return -1;
if (optlen < 6) { 
debug (""newstyle negotiation: %s option length < 6"", optname);
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
== -1)
return -1;
continue;
}
{
uint32_t exportnamelen;
uint16_t nrinfos;
uint16_t info;
size_t i;
memcpy (&exportnamelen, &data[0], 4);
exportnamelen = be32toh (exportnamelen);
if (exportnamelen > optlen-6 ) {
debug (""newstyle negotiation: %s: export name too long"", optname);
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
== -1)
return -1;
continue;
}
memcpy (&nrinfos, &data[exportnamelen+4], 2);
nrinfos = be16toh (nrinfos);
if (optlen != 4 + exportnamelen + 2 + 2*nrinfos) {
debug (""newstyle negotiation: %s: ""
""number of information requests incorrect"", optname);
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
== -1)
return -1;
continue;
}
if (check_export_name (option, &data[4], exportnamelen,
optlen - 6) == -1) {
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
== -1)
return -1;
continue;
}
if (finish_newstyle_options (&exportsize,
&data[4], exportnamelen) == -1) {
if (conn->top_context) {
if (backend_finalize (conn->top_context) == -1)
return -1;
backend_close (conn->top_context);
conn->top_context = NULL;
}
if (send_newstyle_option_reply (option, NBD_REP_ERR_UNKNOWN) == -1)
return -1;
continue;
}
if (send_newstyle_option_reply_info_export (option,
NBD_REP_INFO,
NBD_INFO_EXPORT,
exportsize) == -1)
return -1;
for (i = 0; i < nrinfos; ++i) {
memcpy (&info, &data[4 + exportnamelen + 2 + i*2], 2);
info = be16toh (info);
switch (info) {
case NBD_INFO_EXPORT:  break;
case NBD_INFO_NAME:
{
const char *name = &data[4];
size_t namelen = exportnamelen;
if (exportnamelen == 0) {
name = backend_default_export (top, read_only);
if (!name) {
debug (""newstyle negotiation: %s: ""
""NBD_INFO_NAME: no name to send"", optname);
break;
}
namelen = -1;
}
if (send_newstyle_option_reply_info_str (option,
NBD_REP_INFO,
NBD_INFO_NAME,
name, namelen) == -1)
return -1;
}
break;
case NBD_INFO_DESCRIPTION:
{
const char *desc = backend_export_description (conn->top_context);
if (!desc) {
debug (""newstyle negotiation: %s: ""
""NBD_INFO_DESCRIPTION: no description to send"",
optname);
break;
}
if (send_newstyle_option_reply_info_str (option,
NBD_REP_INFO,
NBD_INFO_DESCRIPTION,
desc, -1) == -1)
return -1;
}
break;
default:
debug (""newstyle negotiation: %s: ""
""ignoring NBD_INFO_* request %u (%s)"",
optname, (unsigned) info, name_of_nbd_info (info));
break;
}
}
}
if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
return -1;
if (option == NBD_OPT_INFO) {
if (backend_finalize (conn->top_context) == -1)
return -1;
backend_close (conn->top_context);
conn->top_context = NULL;
}
break;
case NBD_OPT_STRUCTURED_REPLY:
if (optlen != 0) {
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
== -1)
return -1;
if (conn_recv_full (data, optlen,
""read: %s: %m"", name_of_nbd_opt (option)) == -1)
return -1;
continue;
}
debug (""newstyle negotiation: %s: client requested structured replies"",
name_of_nbd_opt (option));
if (no_sr) {
if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)
return -1;
debug (""newstyle negotiation: %s: structured replies are disabled"",
name_of_nbd_opt (option));
break;
}
if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
return -1;
conn->structured_replies = true;
break;
case NBD_OPT_LIST_META_CONTEXT:
case NBD_OPT_SET_META_CONTEXT:
{
uint32_t opt_index;
uint32_t exportnamelen;
uint32_t nr_queries;
uint32_t querylen;
const char *what;
if (conn_recv_full (data, optlen, ""read: %s: %m"", optname) == -1)
return -1;
if (!conn->structured_replies) {
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
== -1)
return -1;
continue;
}
what = ""optlen < 8"";
if (optlen < 8) {
opt_meta_invalid_option_len:
debug (""newstyle negotiation: %s: invalid option length: %s"",
optname, what);
if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
== -1)
return -1;
continue;
}
memcpy (&exportnamelen, &data[0], 4);
exportnamelen = be32toh (exportnamelen);
what = ""validating export name"";
if (check_export_name (option, &data[4], exportnamelen,
optlen - 8) == -1)
goto opt_meta_invalid_option_len;
if (option == NBD_OPT_SET_META_CONTEXT) {
conn->exportname_from_set_meta_context =
strndup (&data[4], exportnamelen);
if (conn->exportname_from_set_meta_context == NULL) {
nbdkit_error (""malloc: %m"");
return -1;
}
}
opt_index = 4 + exportnamelen;
what = ""reading number of queries"";
if (opt_index+4 > optlen)
goto opt_meta_invalid_option_len;
memcpy (&nr_queries, &data[opt_index], 4);
nr_queries = be32toh (nr_queries);
opt_index += 4;
debug (""newstyle negotiation: %s: %s count: %d"", optname,
option == NBD_OPT_LIST_META_CONTEXT ? ""query"" : ""set"",
nr_queries);
if (option == NBD_OPT_SET_META_CONTEXT)
conn->meta_context_base_allocation = false;
if (nr_queries == 0) {
if (option == NBD_OPT_LIST_META_CONTEXT) {
if (send_newstyle_option_reply_meta_context (option,
NBD_REP_META_CONTEXT,
0, ""base:allocation"")
== -1)
return -1;
}
if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
return -1;
}
else {
while (nr_queries > 0) {
what = ""reading query string length"";
if (opt_index+4 > optlen)
goto opt_meta_invalid_option_len;
memcpy (&querylen, &data[opt_index], 4);
querylen = be32toh (querylen);
opt_index += 4;
what = ""reading query string"";
if (check_string (option, &data[opt_index], querylen,
optlen - opt_index, ""meta context query"") == -1)
goto opt_meta_invalid_option_len;
debug (""newstyle negotiation: %s: %s %.*s"",
optname,
option == NBD_OPT_LIST_META_CONTEXT ? ""query"" : ""set"",
(int) querylen, &data[opt_index]);
if (option == NBD_OPT_LIST_META_CONTEXT &&
querylen == 5 &&
strncmp (&data[opt_index], ""base:"", 5) == 0) {
if (send_newstyle_option_reply_meta_context
(option, NBD_REP_META_CONTEXT,
0, ""base:allocation"") == -1)
return -1;
}
else if (querylen == 15 &&
strncmp (&data[opt_index], ""base:allocation"", 15) == 0) {
if (send_newstyle_option_reply_meta_context
(option, NBD_REP_META_CONTEXT,
option == NBD_OPT_SET_META_CONTEXT
? base_allocation_id : 0,
""base:allocation"") == -1)
return -1;
if (option == NBD_OPT_SET_META_CONTEXT)
conn->meta_context_base_allocation = true;
}
opt_index += querylen;
nr_queries--;
}
if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
return -1;
}
debug (""newstyle negotiation: %s: reply complete"", optname);
}
break;
default:
if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)
return -1;
if (conn_recv_full (data, optlen,
""reading unknown option data: conn->recv: %m"") == -1)
return -1;
}
if (option == NBD_OPT_EXPORT_NAME || option == NBD_OPT_GO)
break;
}
if (nr_options == 0) {
nbdkit_error (""client spent too much time negotiating without selecting ""
""an export"");
return -1;
}
if (tls == 2 && !conn->using_tls) {
nbdkit_error (""non-TLS client tried to connect in --tls=require mode"");
return -1;
}
return 0;
}","static int
negotiate_handshake_newstyle_options (void)
{
VAR_0;
struct nbd_new_option VAR_1;
size_t VAR_2;
bool VAR_3 = false;
uint64_t VAR_4;
uint32_t VAR_5;
uint32_t VAR_6;
struct nbd_export_name_option_reply VAR_7;
const char *VAR_8;
uint64_t VAR_9;
struct backend *VAR_10;
for (VAR_2 = VAR_11; VAR_2 > 0; --VAR_2) {
CLEANUP_FREE char *VAR_12 = NULL;
if (conn_recv_full (&VAR_1, sizeof VAR_1,
""reading option: conn->recv: %m"") == -1)
return -1;
VAR_4 = be64toh (VAR_1.version);
if (VAR_4 != VAR_13) {
nbdkit_error (""unknown option version %"" VAR_14
"", expecting %"" VAR_14,
VAR_4, VAR_13);
return -1;
}
VAR_6 = be32toh (VAR_1.optlen);
if (VAR_6 > VAR_15) {
nbdkit_error (""client option data too long (%"" VAR_16 "")"", VAR_6);
return -1;
}
VAR_12 = malloc (VAR_6 + 1); 
if (VAR_12 == NULL) {
nbdkit_error (""malloc: %m"");
return -1;
}
VAR_5 = be32toh (VAR_1.option);
VAR_8 = name_of_nbd_opt (VAR_5);
if (!(VAR_17->cflags & VAR_18) &&
VAR_5 != VAR_19) {
if (send_newstyle_option_reply (VAR_5, VAR_20))
return -1;
continue;
}
if (VAR_21 == 2 && !VAR_17->using_tls &&
!(VAR_5 == VAR_22 || VAR_5 == VAR_23)) {
if (send_newstyle_option_reply (VAR_5, VAR_24))
return -1;
continue;
}
switch (VAR_5) {
case VAR_19:
if (conn_recv_full (VAR_12, VAR_6,
""read: %s: %m"", name_of_nbd_opt (VAR_5)) == -1)
return -1;
if (check_export_name (VAR_5, VAR_12, VAR_6, VAR_6) == -1)
return -1;
if (finish_newstyle_options (&VAR_9, VAR_12, VAR_6) == -1)
return -1;
memset (&VAR_7, 0, sizeof VAR_7);
VAR_7.exportsize = htobe64 (VAR_9);
VAR_7.eflags = htobe16 (VAR_17->eflags);
if (VAR_17->send (&VAR_7,
(VAR_17->cflags & VAR_25)
? offsetof (struct nbd_export_name_option_reply, VAR_26)
: sizeof VAR_7, 0) == -1) {
nbdkit_error (""write: %s: %m"", VAR_8);
return -1;
}
break;
case VAR_22:
if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
return -1;
debug (""client sent %s to abort the connection"",
name_of_nbd_opt (VAR_5));
return -1;
case VAR_28:
if (VAR_6 != 0) {
if (send_newstyle_option_reply (VAR_5, VAR_20)
== -1)
return -1;
if (conn_recv_full (VAR_12, VAR_6,
""read: %s: %m"", name_of_nbd_opt (VAR_5)) == -1)
return -1;
continue;
}
if (VAR_3) {
debug (""newstyle negotiation: %s: export list already advertised"",
name_of_nbd_opt (VAR_5));
if (send_newstyle_option_reply (VAR_5, VAR_20) == -1)
return -1;
continue;
}
else {
debug (""newstyle negotiation: %s: advertising exports"",
name_of_nbd_opt (VAR_5));
if (send_newstyle_option_reply_exportnames (VAR_5, &VAR_2) == -1)
return -1;
VAR_3 = true;
}
break;
case VAR_23:
if (VAR_6 != 0) {
if (send_newstyle_option_reply (VAR_5, VAR_20)
== -1)
return -1;
if (conn_recv_full (VAR_12, VAR_6,
""read: %s: %m"", name_of_nbd_opt (VAR_5)) == -1)
return -1;
continue;
}
if (VAR_21 == 0) {           
#ifdef VAR_29
#define VAR_30 NBD_REP_ERR_POLICY
#else
#define VAR_30 NBD_REP_ERR_UNSUP
#endif
if (send_newstyle_option_reply (VAR_5, VAR_30) == -1)
return -1;
}
else  {
if (VAR_17->using_tls) {
if (send_newstyle_option_reply (VAR_5, VAR_20) == -1)
return -1;
continue;
}
if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
return -1;
if (crypto_negotiate_tls (VAR_17->sockin, VAR_17->sockout) == -1)
return -1;
VAR_17->using_tls = true;
debug (""using TLS on this connection"");
for_each_backend (VAR_10) {
free (VAR_17->default_exportname[VAR_10->i]);
VAR_17->default_exportname[VAR_10->i] = NULL;
}
}
break;
case VAR_31:
case VAR_32:
if (conn_recv_full (VAR_12, VAR_6, ""read: %s: %m"", VAR_8) == -1)
return -1;
if (VAR_6 < 6) { 
debug (""newstyle negotiation: %s option length < 6"", VAR_8);
if (send_newstyle_option_reply (VAR_5, VAR_20)
== -1)
return -1;
continue;
}
{
uint32_t VAR_33;
uint16_t VAR_34;
uint16_t VAR_35;
size_t VAR_36;
memcpy (&VAR_33, &VAR_12[0], 4);
VAR_33 = be32toh (VAR_33);
if (VAR_33 > VAR_6-6 ) {
debug (""newstyle negotiation: %s: export name too long"", VAR_8);
if (send_newstyle_option_reply (VAR_5, VAR_20)
== -1)
return -1;
continue;
}
memcpy (&VAR_34, &VAR_12[VAR_33+4], 2);
VAR_34 = be16toh (VAR_34);
if (VAR_6 != 4 + VAR_33 + 2 + 2*VAR_34) {
debug (""newstyle negotiation: %s: ""
""number of information requests incorrect"", VAR_8);
if (send_newstyle_option_reply (VAR_5, VAR_20)
== -1)
return -1;
continue;
}
if (check_export_name (VAR_5, &VAR_12[4], VAR_33,
VAR_6 - 6) == -1) {
if (send_newstyle_option_reply (VAR_5, VAR_20)
== -1)
return -1;
continue;
}
if (finish_newstyle_options (&VAR_9,
&VAR_12[4], VAR_33) == -1) {
if (VAR_17->top_context) {
if (backend_finalize (VAR_17->top_context) == -1)
return -1;
backend_close (VAR_17->top_context);
VAR_17->top_context = NULL;
}
if (send_newstyle_option_reply (VAR_5, VAR_37) == -1)
return -1;
continue;
}
if (send_newstyle_option_reply_info_export (VAR_5,
VAR_38,
VAR_39,
VAR_9) == -1)
return -1;
for (VAR_36 = 0; VAR_36 < VAR_34; ++VAR_36) {
memcpy (&VAR_35, &VAR_12[4 + VAR_33 + 2 + VAR_36*2], 2);
VAR_35 = be16toh (VAR_35);
switch (VAR_35) {
case VAR_39:  break;
case VAR_40:
{
const char *VAR_41 = &VAR_12[4];
size_t VAR_42 = VAR_33;
if (VAR_33 == 0) {
VAR_41 = backend_default_export (VAR_43, VAR_44);
if (!VAR_41) {
debug (""newstyle negotiation: %s: ""
""NBD_INFO_NAME: no name to send"", VAR_8);
break;
}
VAR_42 = -1;
}
if (send_newstyle_option_reply_info_str (VAR_5,
VAR_38,
VAR_40,
VAR_41, VAR_42) == -1)
return -1;
}
break;
case VAR_45:
{
const char *VAR_46 = backend_export_description (VAR_17->top_context);
if (!VAR_46) {
debug (""newstyle negotiation: %s: ""
""NBD_INFO_DESCRIPTION: no description to send"",
VAR_8);
break;
}
if (send_newstyle_option_reply_info_str (VAR_5,
VAR_38,
VAR_45,
VAR_46, -1) == -1)
return -1;
}
break;
default:
debug (""newstyle negotiation: %s: ""
""ignoring NBD_INFO_* request %u (%s)"",
VAR_8, (unsigned) VAR_35, name_of_nbd_info (VAR_35));
break;
}
}
}
if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
return -1;
if (VAR_5 == VAR_31) {
if (backend_finalize (VAR_17->top_context) == -1)
return -1;
backend_close (VAR_17->top_context);
VAR_17->top_context = NULL;
}
break;
case VAR_47:
if (VAR_6 != 0) {
if (send_newstyle_option_reply (VAR_5, VAR_20)
== -1)
return -1;
if (conn_recv_full (VAR_12, VAR_6,
""read: %s: %m"", name_of_nbd_opt (VAR_5)) == -1)
return -1;
continue;
}
debug (""newstyle negotiation: %s: client requested structured replies"",
name_of_nbd_opt (VAR_5));
if (VAR_48) {
if (send_newstyle_option_reply (VAR_5, VAR_49) == -1)
return -1;
debug (""newstyle negotiation: %s: structured replies are disabled"",
name_of_nbd_opt (VAR_5));
break;
}
if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
return -1;
VAR_17->structured_replies = true;
break;
case VAR_50:
case VAR_51:
{
uint32_t VAR_52;
uint32_t VAR_33;
uint32_t VAR_53;
uint32_t VAR_54;
const char *VAR_55;
if (conn_recv_full (VAR_12, VAR_6, ""read: %s: %m"", VAR_8) == -1)
return -1;
if (!VAR_17->structured_replies) {
if (send_newstyle_option_reply (VAR_5, VAR_20)
== -1)
return -1;
continue;
}
VAR_55 = ""optlen < 8"";
if (VAR_6 < 8) {
opt_meta_invalid_option_len:
debug (""newstyle negotiation: %s: invalid option length: %s"",
VAR_8, VAR_55);
if (send_newstyle_option_reply (VAR_5, VAR_20)
== -1)
return -1;
continue;
}
memcpy (&VAR_33, &VAR_12[0], 4);
VAR_33 = be32toh (VAR_33);
VAR_55 = ""validating export name"";
if (check_export_name (VAR_5, &VAR_12[4], VAR_33,
VAR_6 - 8) == -1)
goto opt_meta_invalid_option_len;
if (VAR_5 == VAR_51) {
VAR_17->exportname_from_set_meta_context =
strndup (&VAR_12[4], VAR_33);
if (VAR_17->exportname_from_set_meta_context == NULL) {
nbdkit_error (""malloc: %m"");
return -1;
}
}
VAR_52 = 4 + VAR_33;
VAR_55 = ""reading number of queries"";
if (VAR_52+4 > VAR_6)
goto opt_meta_invalid_option_len;
memcpy (&VAR_53, &VAR_12[VAR_52], 4);
VAR_53 = be32toh (VAR_53);
VAR_52 += 4;
debug (""newstyle negotiation: %s: %s count: %d"", VAR_8,
VAR_5 == VAR_50 ? ""query"" : ""set"",
VAR_53);
if (VAR_5 == VAR_51)
VAR_17->meta_context_base_allocation = false;
if (VAR_53 == 0) {
if (VAR_5 == VAR_50) {
if (send_newstyle_option_reply_meta_context (VAR_5,
VAR_56,
0, ""base:allocation"")
== -1)
return -1;
}
if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
return -1;
}
else {
while (VAR_53 > 0) {
VAR_55 = ""reading query string length"";
if (VAR_52+4 > VAR_6)
goto opt_meta_invalid_option_len;
memcpy (&VAR_54, &VAR_12[VAR_52], 4);
VAR_54 = be32toh (VAR_54);
VAR_52 += 4;
VAR_55 = ""reading query string"";
if (check_string (VAR_5, &VAR_12[VAR_52], VAR_54,
VAR_6 - VAR_52, ""meta context query"") == -1)
goto opt_meta_invalid_option_len;
debug (""newstyle negotiation: %s: %s %.*s"",
VAR_8,
VAR_5 == VAR_50 ? ""query"" : ""set"",
(int) VAR_54, &VAR_12[VAR_52]);
if (VAR_5 == VAR_50 &&
VAR_54 == 5 &&
strncmp (&VAR_12[VAR_52], ""base:"", 5) == 0) {
if (send_newstyle_option_reply_meta_context
(VAR_5, VAR_56,
0, ""base:allocation"") == -1)
return -1;
}
else if (VAR_54 == 15 &&
strncmp (&VAR_12[VAR_52], ""base:allocation"", 15) == 0) {
if (send_newstyle_option_reply_meta_context
(VAR_5, VAR_56,
VAR_5 == VAR_51
? VAR_57 : 0,
""base:allocation"") == -1)
return -1;
if (VAR_5 == VAR_51)
VAR_17->meta_context_base_allocation = true;
}
VAR_52 += VAR_54;
VAR_53--;
}
if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
return -1;
}
debug (""newstyle negotiation: %s: reply complete"", VAR_8);
}
break;
default:
if (send_newstyle_option_reply (VAR_5, VAR_49) == -1)
return -1;
if (conn_recv_full (VAR_12, VAR_6,
""reading unknown option data: conn->recv: %m"") == -1)
return -1;
}
if (VAR_5 == VAR_19 || VAR_5 == VAR_32)
break;
}
if (VAR_2 == 0) {
nbdkit_error (""client spent too much time negotiating without selecting ""
""an export"");
return -1;
}
if (VAR_21 == 2 && !VAR_17->using_tls) {
nbdkit_error (""non-TLS client tried to connect in --tls=require mode"");
return -1;
}
return 0;
}",nbdkit/09a13dafb7bb3a38ab52eb5501cba786365ba7fd/protocol-handshake-newstyle.c/vul/before/0.json,"static int
negotiate_handshake_newstyle_options (void)
{
  GET_CONN;
  struct nbd_new_option new_option;
  size_t nr_options;
  bool list_seen = false;
  uint64_t version;
  uint32_t option;
  uint32_t optlen;
  struct nbd_export_name_option_reply handshake_finish;
  const char *optname;
  uint64_t exportsize;
  struct backend *b;

  for (nr_options = MAX_NR_OPTIONS; nr_options > 0; --nr_options) {
    CLEANUP_FREE char *data = NULL;

    if (conn_recv_full (&new_option, sizeof new_option,
                        ""reading option: conn->recv: %m"") == -1)
      return -1;

    version = be64toh (new_option.version);
    if (version != NBD_NEW_VERSION) {
      nbdkit_error (""unknown option version %"" PRIx64
                    "", expecting %"" PRIx64,
                    version, NBD_NEW_VERSION);
      return -1;
    }

    /* There is a maximum option length we will accept, regardless
     * of the option type.
     */
    optlen = be32toh (new_option.optlen);
    if (optlen > MAX_REQUEST_SIZE) {
      nbdkit_error (""client option data too long (%"" PRIu32 "")"", optlen);
      return -1;
    }
    data = malloc (optlen + 1); /* Allowing a trailing NUL helps some uses */
    if (data == NULL) {
      nbdkit_error (""malloc: %m"");
      return -1;
    }

    option = be32toh (new_option.option);
    optname = name_of_nbd_opt (option);

    /* If the client lacks fixed newstyle support, it should only send
     * NBD_OPT_EXPORT_NAME.
     */
    if (!(conn->cflags & NBD_FLAG_FIXED_NEWSTYLE) &&
        option != NBD_OPT_EXPORT_NAME) {
      if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID))
        return -1;
      continue;
    }

    /* In --tls=require / FORCEDTLS mode the only options allowed
     * before TLS negotiation are NBD_OPT_ABORT and NBD_OPT_STARTTLS.
     */
    if (tls == 2 && !conn->using_tls &&
        !(option == NBD_OPT_ABORT || option == NBD_OPT_STARTTLS)) {
      if (send_newstyle_option_reply (option, NBD_REP_ERR_TLS_REQD))
        return -1;
      continue;
    }

    switch (option) {
    case NBD_OPT_EXPORT_NAME:
      if (conn_recv_full (data, optlen,
                          ""read: %s: %m"", name_of_nbd_opt (option)) == -1)
        return -1;
      if (check_export_name (option, data, optlen, optlen) == -1)
        return -1;

      /* We have to finish the handshake by sending handshake_finish.
       * On failure, we have to disconnect.
       */
      if (finish_newstyle_options (&exportsize, data, optlen) == -1)
        return -1;

      memset (&handshake_finish, 0, sizeof handshake_finish);
      handshake_finish.exportsize = htobe64 (exportsize);
      handshake_finish.eflags = htobe16 (conn->eflags);

      if (conn->send (&handshake_finish,
                      (conn->cflags & NBD_FLAG_NO_ZEROES)
                      ? offsetof (struct nbd_export_name_option_reply, zeroes)
                      : sizeof handshake_finish, 0) == -1) {
        nbdkit_error (""write: %s: %m"", optname);
        return -1;
      }
      break;

    case NBD_OPT_ABORT:
      if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
        return -1;
      debug (""client sent %s to abort the connection"",
             name_of_nbd_opt (option));
      return -1;

    case NBD_OPT_LIST:
      if (optlen != 0) {
        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
            == -1)
          return -1;
        if (conn_recv_full (data, optlen,
                            ""read: %s: %m"", name_of_nbd_opt (option)) == -1)
          return -1;
        continue;
      }

      if (list_seen) {
        debug (""newstyle negotiation: %s: export list already advertised"",
               name_of_nbd_opt (option));
        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)
          return -1;
        continue;
      }
      else {
        /* Send back the exportname list. */
        debug (""newstyle negotiation: %s: advertising exports"",
               name_of_nbd_opt (option));
        if (send_newstyle_option_reply_exportnames (option, &nr_options) == -1)
          return -1;
        list_seen = true;
      }
      break;

    case NBD_OPT_STARTTLS:
      if (optlen != 0) {
        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
            == -1)
          return -1;
        if (conn_recv_full (data, optlen,
                            ""read: %s: %m"", name_of_nbd_opt (option)) == -1)
          return -1;
        continue;
      }

      if (tls == 0) {           /* --tls=off (NOTLS mode). */
#ifdef HAVE_GNUTLS
#define NO_TLS_REPLY NBD_REP_ERR_POLICY
#else
#define NO_TLS_REPLY NBD_REP_ERR_UNSUP
#endif
        if (send_newstyle_option_reply (option, NO_TLS_REPLY) == -1)
          return -1;
      }
      else /* --tls=on or --tls=require */ {
        /* We can't upgrade to TLS twice on the same connection. */
        if (conn->using_tls) {
          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)
            return -1;
          continue;
        }

        /* We have to send the (unencrypted) reply before starting
         * the handshake.
         */
        if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
          return -1;

        /* Upgrade the connection to TLS.  Also performs access control. */
        if (crypto_negotiate_tls (conn->sockin, conn->sockout) == -1)
          return -1;
        conn->using_tls = true;
        debug (""using TLS on this connection"");
        /* Wipe out any cached state. */
        conn->structured_replies = false;
        for_each_backend (b) {
          free (conn->default_exportname[b->i]);
          conn->default_exportname[b->i] = NULL;
        }
      }
      break;

    case NBD_OPT_INFO:
    case NBD_OPT_GO:
      if (conn_recv_full (data, optlen, ""read: %s: %m"", optname) == -1)
        return -1;

      if (optlen < 6) { /* 32 bit export length + 16 bit nr info */
        debug (""newstyle negotiation: %s option length < 6"", optname);

        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
            == -1)
          return -1;
        continue;
      }

      {
        uint32_t exportnamelen;
        uint16_t nrinfos;
        uint16_t info;
        size_t i;

        /* Validate the name length and number of INFO requests. */
        memcpy (&exportnamelen, &data[0], 4);
        exportnamelen = be32toh (exportnamelen);
        if (exportnamelen > optlen-6 /* NB optlen >= 6, see above */) {
          debug (""newstyle negotiation: %s: export name too long"", optname);
          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
              == -1)
            return -1;
          continue;
        }
        memcpy (&nrinfos, &data[exportnamelen+4], 2);
        nrinfos = be16toh (nrinfos);
        if (optlen != 4 + exportnamelen + 2 + 2*nrinfos) {
          debug (""newstyle negotiation: %s: ""
                 ""number of information requests incorrect"", optname);
          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
              == -1)
            return -1;
          continue;
        }

        /* As with NBD_OPT_EXPORT_NAME we print the export name and
         * save it in the connection.  If an earlier
         * NBD_OPT_SET_META_CONTEXT used an export name, it must match
         * or else we drop the support for that context.
         */
        if (check_export_name (option, &data[4], exportnamelen,
                               optlen - 6) == -1) {
          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
              == -1)
            return -1;
          continue;
        }

        /* The spec is confusing, but it is required that we send back
         * NBD_INFO_EXPORT, even if the client did not request it!
         * qemu client in particular does not request this, but will
         * fail if we don't send it.  Note that if .open fails, but we
         * succeed at .close, then we merely return an error to the
         * client and let them try another NBD_OPT, rather than
         * disconnecting.
         */
        if (finish_newstyle_options (&exportsize,
                                     &data[4], exportnamelen) == -1) {
          if (conn->top_context) {
            if (backend_finalize (conn->top_context) == -1)
              return -1;
            backend_close (conn->top_context);
            conn->top_context = NULL;
          }
          if (send_newstyle_option_reply (option, NBD_REP_ERR_UNKNOWN) == -1)
            return -1;
          continue;
        }

        if (send_newstyle_option_reply_info_export (option,
                                                    NBD_REP_INFO,
                                                    NBD_INFO_EXPORT,
                                                    exportsize) == -1)
          return -1;

        /* For now we send NBD_INFO_NAME and NBD_INFO_DESCRIPTION if
         * requested, and ignore all other info requests (including
         * NBD_INFO_EXPORT if it was requested, because we replied
         * already above).
         */
        for (i = 0; i < nrinfos; ++i) {
          memcpy (&info, &data[4 + exportnamelen + 2 + i*2], 2);
          info = be16toh (info);
          switch (info) {
          case NBD_INFO_EXPORT: /* ignore - reply sent above */ break;
          case NBD_INFO_NAME:
            {
              const char *name = &data[4];
              size_t namelen = exportnamelen;

              if (exportnamelen == 0) {
                name = backend_default_export (top, read_only);
                if (!name) {
                  debug (""newstyle negotiation: %s: ""
                         ""NBD_INFO_NAME: no name to send"", optname);
                  break;
                }
                namelen = -1;
              }
              if (send_newstyle_option_reply_info_str (option,
                                                       NBD_REP_INFO,
                                                       NBD_INFO_NAME,
                                                       name, namelen) == -1)
                return -1;
            }
            break;
          case NBD_INFO_DESCRIPTION:
            {
              const char *desc = backend_export_description (conn->top_context);

              if (!desc) {
                debug (""newstyle negotiation: %s: ""
                       ""NBD_INFO_DESCRIPTION: no description to send"",
                       optname);
                break;
              }
              if (send_newstyle_option_reply_info_str (option,
                                                       NBD_REP_INFO,
                                                       NBD_INFO_DESCRIPTION,
                                                       desc, -1) == -1)
                return -1;
            }
            break;
          default:
            debug (""newstyle negotiation: %s: ""
                   ""ignoring NBD_INFO_* request %u (%s)"",
                   optname, (unsigned) info, name_of_nbd_info (info));
            break;
          }
        }
      }

      /* Unlike NBD_OPT_EXPORT_NAME, NBD_OPT_GO sends back an ACK
       * or ERROR packet.  If this was NBD_OPT_LIST, call .close.
       */
      if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
        return -1;

      if (option == NBD_OPT_INFO) {
        if (backend_finalize (conn->top_context) == -1)
          return -1;
        backend_close (conn->top_context);
        conn->top_context = NULL;
      }

      break;

    case NBD_OPT_STRUCTURED_REPLY:
      if (optlen != 0) {
        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
            == -1)
          return -1;
        if (conn_recv_full (data, optlen,
                            ""read: %s: %m"", name_of_nbd_opt (option)) == -1)
          return -1;
        continue;
      }

      debug (""newstyle negotiation: %s: client requested structured replies"",
             name_of_nbd_opt (option));

      if (no_sr) {
        /* Must fail with ERR_UNSUP for qemu 4.2 to remain happy;
         * but failing with ERR_POLICY would have been nicer.
         */
        if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)
          return -1;
        debug (""newstyle negotiation: %s: structured replies are disabled"",
               name_of_nbd_opt (option));
        break;
      }

      if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
        return -1;

      conn->structured_replies = true;
      break;

    case NBD_OPT_LIST_META_CONTEXT:
    case NBD_OPT_SET_META_CONTEXT:
      {
        uint32_t opt_index;
        uint32_t exportnamelen;
        uint32_t nr_queries;
        uint32_t querylen;
        const char *what;

        if (conn_recv_full (data, optlen, ""read: %s: %m"", optname) == -1)
          return -1;

        /* Note that we support base:allocation whether or not the plugin
         * supports can_extents.
         */
        if (!conn->structured_replies) {
          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
              == -1)
            return -1;
          continue;
        }

        /* Minimum length of the option payload is:
         *   32 bit export name length followed by empty export name
         * + 32 bit number of queries followed by no queries
         * = 8 bytes.
         */
        what = ""optlen < 8"";
        if (optlen < 8) {
        opt_meta_invalid_option_len:
          debug (""newstyle negotiation: %s: invalid option length: %s"",
                 optname, what);

          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)
              == -1)
            return -1;
          continue;
        }

        memcpy (&exportnamelen, &data[0], 4);
        exportnamelen = be32toh (exportnamelen);
        what = ""validating export name"";
        if (check_export_name (option, &data[4], exportnamelen,
                               optlen - 8) == -1)
          goto opt_meta_invalid_option_len;

        /* Remember the export name: the NBD spec says that if the client
         * later uses NBD_OPT_GO on a different export, then the context
         * returned here is not usable.
         */
        if (option == NBD_OPT_SET_META_CONTEXT) {
          conn->exportname_from_set_meta_context =
            strndup (&data[4], exportnamelen);
          if (conn->exportname_from_set_meta_context == NULL) {
            nbdkit_error (""malloc: %m"");
            return -1;
          }
        }

        opt_index = 4 + exportnamelen;

        /* Read the number of queries. */
        what = ""reading number of queries"";
        if (opt_index+4 > optlen)
          goto opt_meta_invalid_option_len;
        memcpy (&nr_queries, &data[opt_index], 4);
        nr_queries = be32toh (nr_queries);
        opt_index += 4;

        /* for LIST: nr_queries == 0 means return all meta contexts
         * for SET: nr_queries == 0 means reset all contexts
         */
        debug (""newstyle negotiation: %s: %s count: %d"", optname,
               option == NBD_OPT_LIST_META_CONTEXT ? ""query"" : ""set"",
               nr_queries);
        if (option == NBD_OPT_SET_META_CONTEXT)
          conn->meta_context_base_allocation = false;
        if (nr_queries == 0) {
          if (option == NBD_OPT_LIST_META_CONTEXT) {
            if (send_newstyle_option_reply_meta_context (option,
                                                         NBD_REP_META_CONTEXT,
                                                         0, ""base:allocation"")
                == -1)
              return -1;
          }

          if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
            return -1;
        }
        else {
          /* Read and answer each query. */
          while (nr_queries > 0) {
            what = ""reading query string length"";
            if (opt_index+4 > optlen)
              goto opt_meta_invalid_option_len;
            memcpy (&querylen, &data[opt_index], 4);
            querylen = be32toh (querylen);
            opt_index += 4;
            what = ""reading query string"";
            if (check_string (option, &data[opt_index], querylen,
                              optlen - opt_index, ""meta context query"") == -1)
              goto opt_meta_invalid_option_len;

            debug (""newstyle negotiation: %s: %s %.*s"",
                   optname,
                   option == NBD_OPT_LIST_META_CONTEXT ? ""query"" : ""set"",
                   (int) querylen, &data[opt_index]);

            /* For LIST, ""base:"" returns all supported contexts in the
             * base namespace.  We only support ""base:allocation"".
             */
            if (option == NBD_OPT_LIST_META_CONTEXT &&
                querylen == 5 &&
                strncmp (&data[opt_index], ""base:"", 5) == 0) {
              if (send_newstyle_option_reply_meta_context
                  (option, NBD_REP_META_CONTEXT,
                   0, ""base:allocation"") == -1)
                return -1;
            }
            /* ""base:allocation"" requested by name. */
            else if (querylen == 15 &&
                     strncmp (&data[opt_index], ""base:allocation"", 15) == 0) {
              if (send_newstyle_option_reply_meta_context
                  (option, NBD_REP_META_CONTEXT,
                   option == NBD_OPT_SET_META_CONTEXT
                   ? base_allocation_id : 0,
                   ""base:allocation"") == -1)
                return -1;
              if (option == NBD_OPT_SET_META_CONTEXT)
                conn->meta_context_base_allocation = true;
            }
            /* Every other query must be ignored. */

            opt_index += querylen;
            nr_queries--;
          }
          if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)
            return -1;
        }
        debug (""newstyle negotiation: %s: reply complete"", optname);
      }
      break;

    default:
      /* Unknown option. */
      if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)
        return -1;
      if (conn_recv_full (data, optlen,
                          ""reading unknown option data: conn->recv: %m"") == -1)
        return -1;
    }

    /* Note, since it's not very clear from the protocol doc, that the
     * client must send NBD_OPT_EXPORT_NAME or NBD_OPT_GO last, and
     * that ends option negotiation.
     */
    if (option == NBD_OPT_EXPORT_NAME || option == NBD_OPT_GO)
      break;
  }

  if (nr_options == 0) {
    nbdkit_error (""client spent too much time negotiating without selecting ""
                  ""an export"");
    return -1;
  }

  /* In --tls=require / FORCEDTLS mode, we must have upgraded to TLS
   * by the time we finish option negotiation.  If not, give up.
   */
  if (tls == 2 && !conn->using_tls) {
    nbdkit_error (""non-TLS client tried to connect in --tls=require mode"");
    return -1;
  }

  return 0;
}","static int
negotiate_handshake_newstyle_options (void)
{
  VAR_0;
  struct nbd_new_option VAR_1;
  size_t VAR_2;
  bool VAR_3 = false;
  uint64_t VAR_4;
  uint32_t VAR_5;
  uint32_t VAR_6;
  struct nbd_export_name_option_reply VAR_7;
  const char *VAR_8;
  uint64_t VAR_9;
  struct backend *VAR_10;

  for (VAR_2 = VAR_11; VAR_2 > 0; --VAR_2) {
    CLEANUP_FREE char *VAR_12 = NULL;

    if (conn_recv_full (&VAR_1, sizeof VAR_1,
                        ""reading option: conn->recv: %m"") == -1)
      return -1;

    VAR_4 = be64toh (VAR_1.version);
    if (VAR_4 != VAR_13) {
      nbdkit_error (""unknown option version %"" VAR_14
                    "", expecting %"" VAR_14,
                    VAR_4, VAR_13);
      return -1;
    }

    /* COMMENT_0 */
                          
       
    VAR_6 = be32toh (VAR_1.optlen);
    if (VAR_6 > VAR_15) {
      nbdkit_error (""client option data too long (%"" VAR_16 "")"", VAR_6);
      return -1;
    }
    VAR_12 = malloc (VAR_6 + 1); /* COMMENT_3 */
    if (VAR_12 == NULL) {
      nbdkit_error (""malloc: %m"");
      return -1;
    }

    VAR_5 = be32toh (VAR_1.option);
    VAR_8 = name_of_nbd_opt (VAR_5);

    /* COMMENT_4 */
                           
       
    if (!(VAR_17->cflags & VAR_18) &&
        VAR_5 != VAR_19) {
      if (send_newstyle_option_reply (VAR_5, VAR_20))
        return -1;
      continue;
    }

    /* COMMENT_7 */
                                                                     
       
    if (VAR_21 == 2 && !VAR_17->using_tls &&
        !(VAR_5 == VAR_22 || VAR_5 == VAR_23)) {
      if (send_newstyle_option_reply (VAR_5, VAR_24))
        return -1;
      continue;
    }

    switch (VAR_5) {
    case VAR_19:
      if (conn_recv_full (VAR_12, VAR_6,
                          ""read: %s: %m"", name_of_nbd_opt (VAR_5)) == -1)
        return -1;
      if (check_export_name (VAR_5, VAR_12, VAR_6, VAR_6) == -1)
        return -1;

      /* COMMENT_10 */
                                           
         
      if (finish_newstyle_options (&VAR_9, VAR_12, VAR_6) == -1)
        return -1;

      memset (&VAR_7, 0, sizeof VAR_7);
      VAR_7.exportsize = htobe64 (VAR_9);
      VAR_7.eflags = htobe16 (VAR_17->eflags);

      if (VAR_17->send (&VAR_7,
                      (VAR_17->cflags & VAR_25)
                      ? offsetof (struct nbd_export_name_option_reply, VAR_26)
                      : sizeof VAR_7, 0) == -1) {
        nbdkit_error (""write: %s: %m"", VAR_8);
        return -1;
      }
      break;

    case VAR_22:
      if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
        return -1;
      debug (""client sent %s to abort the connection"",
             name_of_nbd_opt (VAR_5));
      return -1;

    case VAR_28:
      if (VAR_6 != 0) {
        if (send_newstyle_option_reply (VAR_5, VAR_20)
            == -1)
          return -1;
        if (conn_recv_full (VAR_12, VAR_6,
                            ""read: %s: %m"", name_of_nbd_opt (VAR_5)) == -1)
          return -1;
        continue;
      }

      if (VAR_3) {
        debug (""newstyle negotiation: %s: export list already advertised"",
               name_of_nbd_opt (VAR_5));
        if (send_newstyle_option_reply (VAR_5, VAR_20) == -1)
          return -1;
        continue;
      }
      else {
        /* COMMENT_13 */
        debug (""newstyle negotiation: %s: advertising exports"",
               name_of_nbd_opt (VAR_5));
        if (send_newstyle_option_reply_exportnames (VAR_5, &VAR_2) == -1)
          return -1;
        VAR_3 = true;
      }
      break;

    case VAR_23:
      if (VAR_6 != 0) {
        if (send_newstyle_option_reply (VAR_5, VAR_20)
            == -1)
          return -1;
        if (conn_recv_full (VAR_12, VAR_6,
                            ""read: %s: %m"", name_of_nbd_opt (VAR_5)) == -1)
          return -1;
        continue;
      }

      if (VAR_21 == 0) {           /* COMMENT_14 */
#ifdef VAR_29
#define VAR_30 NBD_REP_ERR_POLICY
#else
#define VAR_30 NBD_REP_ERR_UNSUP
#endif
        if (send_newstyle_option_reply (VAR_5, VAR_30) == -1)
          return -1;
      }
      else /* COMMENT_15 */ {
        /* COMMENT_16 */
        if (VAR_17->using_tls) {
          if (send_newstyle_option_reply (VAR_5, VAR_20) == -1)
            return -1;
          continue;
        }

        /* COMMENT_17 */
                         
           
        if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
          return -1;

        /* COMMENT_20 */
        if (crypto_negotiate_tls (VAR_17->sockin, VAR_17->sockout) == -1)
          return -1;
        VAR_17->using_tls = true;
        debug (""using TLS on this connection"");
        /* COMMENT_21 */
        VAR_17->structured_replies = false;
        for_each_backend (VAR_10) {
          free (VAR_17->default_exportname[VAR_10->i]);
          VAR_17->default_exportname[VAR_10->i] = NULL;
        }
      }
      break;

    case VAR_31:
    case VAR_32:
      if (conn_recv_full (VAR_12, VAR_6, ""read: %s: %m"", VAR_8) == -1)
        return -1;

      if (VAR_6 < 6) { /* COMMENT_22 */
        debug (""newstyle negotiation: %s option length < 6"", VAR_8);

        if (send_newstyle_option_reply (VAR_5, VAR_20)
            == -1)
          return -1;
        continue;
      }

      {
        uint32_t VAR_33;
        uint16_t VAR_34;
        uint16_t VAR_35;
        size_t VAR_36;

        /* COMMENT_23 */
        memcpy (&VAR_33, &VAR_12[0], 4);
        VAR_33 = be32toh (VAR_33);
        if (VAR_33 > VAR_6-6 /* COMMENT_24 */) {
          debug (""newstyle negotiation: %s: export name too long"", VAR_8);
          if (send_newstyle_option_reply (VAR_5, VAR_20)
              == -1)
            return -1;
          continue;
        }
        memcpy (&VAR_34, &VAR_12[VAR_33+4], 2);
        VAR_34 = be16toh (VAR_34);
        if (VAR_6 != 4 + VAR_33 + 2 + 2*VAR_34) {
          debug (""newstyle negotiation: %s: ""
                 ""number of information requests incorrect"", VAR_8);
          if (send_newstyle_option_reply (VAR_5, VAR_20)
              == -1)
            return -1;
          continue;
        }

        /* COMMENT_25 */
                                                    
                                                                      
                                                        
           
        if (check_export_name (VAR_5, &VAR_12[4], VAR_33,
                               VAR_6 - 6) == -1) {
          if (send_newstyle_option_reply (VAR_5, VAR_20)
              == -1)
            return -1;
          continue;
        }

        /* COMMENT_30 */
                                                                  
                                                                    
                                                                      
                                                                   
                                                               
                         
           
        if (finish_newstyle_options (&VAR_9,
                                     &VAR_12[4], VAR_33) == -1) {
          if (VAR_17->top_context) {
            if (backend_finalize (VAR_17->top_context) == -1)
              return -1;
            backend_close (VAR_17->top_context);
            VAR_17->top_context = NULL;
          }
          if (send_newstyle_option_reply (VAR_5, VAR_37) == -1)
            return -1;
          continue;
        }

        if (send_newstyle_option_reply_info_export (VAR_5,
                                                    VAR_38,
                                                    VAR_39,
                                                    VAR_9) == -1)
          return -1;

        /* COMMENT_38 */
                                                                   
                                                                  
                          
           
        for (VAR_36 = 0; VAR_36 < VAR_34; ++VAR_36) {
          memcpy (&VAR_35, &VAR_12[4 + VAR_33 + 2 + VAR_36*2], 2);
          VAR_35 = be16toh (VAR_35);
          switch (VAR_35) {
          case VAR_39: /* COMMENT_43 */ break;
          case VAR_40:
            {
              const char *VAR_41 = &VAR_12[4];
              size_t VAR_42 = VAR_33;

              if (VAR_33 == 0) {
                VAR_41 = backend_default_export (VAR_43, VAR_44);
                if (!VAR_41) {
                  debug (""newstyle negotiation: %s: ""
                         ""NBD_INFO_NAME: no name to send"", VAR_8);
                  break;
                }
                VAR_42 = -1;
              }
              if (send_newstyle_option_reply_info_str (VAR_5,
                                                       VAR_38,
                                                       VAR_40,
                                                       VAR_41, VAR_42) == -1)
                return -1;
            }
            break;
          case VAR_45:
            {
              const char *VAR_46 = backend_export_description (VAR_17->top_context);

              if (!VAR_46) {
                debug (""newstyle negotiation: %s: ""
                       ""NBD_INFO_DESCRIPTION: no description to send"",
                       VAR_8);
                break;
              }
              if (send_newstyle_option_reply_info_str (VAR_5,
                                                       VAR_38,
                                                       VAR_45,
                                                       VAR_46, -1) == -1)
                return -1;
            }
            break;
          default:
            debug (""newstyle negotiation: %s: ""
                   ""ignoring NBD_INFO_* request %u (%s)"",
                   VAR_8, (unsigned) VAR_35, name_of_nbd_info (VAR_35));
            break;
          }
        }
      }

      /* COMMENT_44 */
                                                                 
         
      if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
        return -1;

      if (VAR_5 == VAR_31) {
        if (backend_finalize (VAR_17->top_context) == -1)
          return -1;
        backend_close (VAR_17->top_context);
        VAR_17->top_context = NULL;
      }

      break;

    case VAR_47:
      if (VAR_6 != 0) {
        if (send_newstyle_option_reply (VAR_5, VAR_20)
            == -1)
          return -1;
        if (conn_recv_full (VAR_12, VAR_6,
                            ""read: %s: %m"", name_of_nbd_opt (VAR_5)) == -1)
          return -1;
        continue;
      }

      debug (""newstyle negotiation: %s: client requested structured replies"",
             name_of_nbd_opt (VAR_5));

      if (VAR_48) {
        /* COMMENT_47 */
                                                             
           
        if (send_newstyle_option_reply (VAR_5, VAR_49) == -1)
          return -1;
        debug (""newstyle negotiation: %s: structured replies are disabled"",
               name_of_nbd_opt (VAR_5));
        break;
      }

      if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
        return -1;

      VAR_17->structured_replies = true;
      break;

    case VAR_50:
    case VAR_51:
      {
        uint32_t VAR_52;
        uint32_t VAR_33;
        uint32_t VAR_53;
        uint32_t VAR_54;
        const char *VAR_55;

        if (conn_recv_full (VAR_12, VAR_6, ""read: %s: %m"", VAR_8) == -1)
          return -1;

        /* COMMENT_50 */
                                
           
        if (!VAR_17->structured_replies) {
          if (send_newstyle_option_reply (VAR_5, VAR_20)
              == -1)
            return -1;
          continue;
        }

        /* COMMENT_53 */
                                                                    
                                                            
                     
           
        VAR_55 = ""optlen < 8"";
        if (VAR_6 < 8) {
        opt_meta_invalid_option_len:
          debug (""newstyle negotiation: %s: invalid option length: %s"",
                 VAR_8, VAR_55);

          if (send_newstyle_option_reply (VAR_5, VAR_20)
              == -1)
            return -1;
          continue;
        }

        memcpy (&VAR_33, &VAR_12[0], 4);
        VAR_33 = be32toh (VAR_33);
        VAR_55 = ""validating export name"";
        if (check_export_name (VAR_5, &VAR_12[4], VAR_33,
                               VAR_6 - 8) == -1)
          goto opt_meta_invalid_option_len;

        /* COMMENT_58 */
                                                                        
                                       
           
        if (VAR_5 == VAR_51) {
          VAR_17->exportname_from_set_meta_context =
            strndup (&VAR_12[4], VAR_33);
          if (VAR_17->exportname_from_set_meta_context == NULL) {
            nbdkit_error (""malloc: %m"");
            return -1;
          }
        }

        VAR_52 = 4 + VAR_33;

        /* COMMENT_62 */
        VAR_55 = ""reading number of queries"";
        if (VAR_52+4 > VAR_6)
          goto opt_meta_invalid_option_len;
        memcpy (&VAR_53, &VAR_12[VAR_52], 4);
        VAR_53 = be32toh (VAR_53);
        VAR_52 += 4;

        /* COMMENT_63 */
                                                            
           
        debug (""newstyle negotiation: %s: %s count: %d"", VAR_8,
               VAR_5 == VAR_50 ? ""query"" : ""set"",
               VAR_53);
        if (VAR_5 == VAR_51)
          VAR_17->meta_context_base_allocation = false;
        if (VAR_53 == 0) {
          if (VAR_5 == VAR_50) {
            if (send_newstyle_option_reply_meta_context (VAR_5,
                                                         VAR_56,
                                                         0, ""base:allocation"")
                == -1)
              return -1;
          }

          if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
            return -1;
        }
        else {
          /* COMMENT_66 */
          while (VAR_53 > 0) {
            VAR_55 = ""reading query string length"";
            if (VAR_52+4 > VAR_6)
              goto opt_meta_invalid_option_len;
            memcpy (&VAR_54, &VAR_12[VAR_52], 4);
            VAR_54 = be32toh (VAR_54);
            VAR_52 += 4;
            VAR_55 = ""reading query string"";
            if (check_string (VAR_5, &VAR_12[VAR_52], VAR_54,
                              VAR_6 - VAR_52, ""meta context query"") == -1)
              goto opt_meta_invalid_option_len;

            debug (""newstyle negotiation: %s: %s %.*s"",
                   VAR_8,
                   VAR_5 == VAR_50 ? ""query"" : ""set"",
                   (int) VAR_54, &VAR_12[VAR_52]);

            /* COMMENT_67 */
                                                                  
               
            if (VAR_5 == VAR_50 &&
                VAR_54 == 5 &&
                strncmp (&VAR_12[VAR_52], ""base:"", 5) == 0) {
              if (send_newstyle_option_reply_meta_context
                  (VAR_5, VAR_56,
                   0, ""base:allocation"") == -1)
                return -1;
            }
            /* COMMENT_70 */
            else if (VAR_54 == 15 &&
                     strncmp (&VAR_12[VAR_52], ""base:allocation"", 15) == 0) {
              if (send_newstyle_option_reply_meta_context
                  (VAR_5, VAR_56,
                   VAR_5 == VAR_51
                   ? VAR_57 : 0,
                   ""base:allocation"") == -1)
                return -1;
              if (VAR_5 == VAR_51)
                VAR_17->meta_context_base_allocation = true;
            }
            /* COMMENT_71 */

            VAR_52 += VAR_54;
            VAR_53--;
          }
          if (send_newstyle_option_reply (VAR_5, VAR_27) == -1)
            return -1;
        }
        debug (""newstyle negotiation: %s: reply complete"", VAR_8);
      }
      break;

    default:
      /* COMMENT_72 */
      if (send_newstyle_option_reply (VAR_5, VAR_49) == -1)
        return -1;
      if (conn_recv_full (VAR_12, VAR_6,
                          ""reading unknown option data: conn->recv: %m"") == -1)
        return -1;
    }

    /* COMMENT_73 */
                                                                   
                                    
       
    if (VAR_5 == VAR_19 || VAR_5 == VAR_32)
      break;
  }

  if (VAR_2 == 0) {
    nbdkit_error (""client spent too much time negotiating without selecting ""
                  ""an export"");
    return -1;
  }

  /* COMMENT_77 */
                                                                
     
  if (VAR_21 == 2 && !VAR_17->using_tls) {
    nbdkit_error (""non-TLS client tried to connect in --tls=require mode"");
    return -1;
  }

  return 0;
}",nbdkit/09a13dafb7bb3a38ab52eb5501cba786365ba7fd/protocol-handshake-newstyle.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -166,7 +166,8 @@
           return -1;
         conn->using_tls = true;
         debug (""using TLS on this connection"");
-        /* Wipe out any cached default export name. */
+        /* Wipe out any cached state. */
+        conn->structured_replies = false;
         for_each_backend (b) {
           free (conn->default_exportname[b->i]);
           conn->default_exportname[b->i] = NULL;","{'deleted_lines': ['        /* Wipe out any cached default export name. */'], 'added_lines': ['        /* Wipe out any cached state. */', '        conn->structured_replies = false;']}",True,"A flaw was found in nbdkit due to to improperly caching plaintext state across the STARTTLS encryption boundary. A MitM attacker could use this flaw to inject a plaintext NBD_OPT_STRUCTURED_REPLY before proxying everything else a client sends to the server, potentially leading the client to terminate the NBD session. The highest threat from this vulnerability is to system availability.",3.1,LOW,0,test,,5
CVE-2022-0742,['CWE-401'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"While investigating on why a synchronize_net() has been added recently
in ipv6_mc_down(), I found that igmp6_event_query() and igmp6_event_report()
might drop skbs in some cases.

Discussion about removing synchronize_net() from ipv6_mc_down()
will happen in a different thread.

Fixes: f185de28d9ae (""mld: add new workqueues for process mld events"")
Signed-off-by: Eric Dumazet <edumazet@google.com>
Cc: Taehee Yoo <ap420073@gmail.com>
Cc: Cong Wang <xiyou.wangcong@gmail.com>
Cc: David Ahern <dsahern@kernel.org>
Link: https://lore.kernel.org/r/20220303173728.937869-1-eric.dumazet@gmail.com
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
",2d3916f3189172d5c69d33065c3c21119fe539fc,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=2d3916f3189172d5c69d33065c3c21119fe539fc,net/ipv6/mcast.c,igmp6_event_report,"int igmp6_event_report(struct sk_buff *skb)
{
struct inet6_dev *idev = __in6_dev_get(skb->dev);
if (!idev)
return -EINVAL;
if (idev->dead) {
kfree_skb(skb);
return -ENODEV;
}
spin_lock_bh(&idev->mc_report_lock);
if (skb_queue_len(&idev->mc_report_queue) < MLD_MAX_SKBS) {
__skb_queue_tail(&idev->mc_report_queue, skb);
if (!mod_delayed_work(mld_wq, &idev->mc_report_work, 0))
in6_dev_hold(idev);
}
spin_unlock_bh(&idev->mc_report_lock);
return 0;
}","int igmp6_event_report(struct sk_buff *VAR_0)
{
struct inet6_dev *VAR_1 = __in6_dev_get(VAR_0->dev);
if (!VAR_1)
return -VAR_2;
if (VAR_1->dead) {
kfree_skb(VAR_0);
return -VAR_3;
}
spin_lock_bh(&VAR_1->mc_report_lock);
if (skb_queue_len(&VAR_1->mc_report_queue) < VAR_4) {
__skb_queue_tail(&VAR_1->mc_report_queue, VAR_0);
if (!mod_delayed_work(VAR_5, &VAR_1->mc_report_work, 0))
in6_dev_hold(VAR_1);
}
spin_unlock_bh(&VAR_1->mc_report_lock);
return 0;
}",torvalds/linux/2d3916f3189172d5c69d33065c3c21119fe539fc/mcast.c/vul/before/0.json,"void igmp6_event_report(struct sk_buff *skb)
{
	struct inet6_dev *idev = __in6_dev_get(skb->dev);

	if (!idev || idev->dead)
		goto out;

	spin_lock_bh(&idev->mc_report_lock);
	if (skb_queue_len(&idev->mc_report_queue) < MLD_MAX_SKBS) {
		__skb_queue_tail(&idev->mc_report_queue, skb);
		if (!mod_delayed_work(mld_wq, &idev->mc_report_work, 0))
			in6_dev_hold(idev);
		skb = NULL;
	}
	spin_unlock_bh(&idev->mc_report_lock);
out:
	kfree_skb(skb);
}","void igmp6_event_report(struct sk_buff *VAR_0)
{
	struct inet6_dev *VAR_1 = __in6_dev_get(VAR_0->dev);

	if (!VAR_1 || VAR_1->dead)
		goto out;

	spin_lock_bh(&VAR_1->mc_report_lock);
	if (skb_queue_len(&VAR_1->mc_report_queue) < VAR_2) {
		__skb_queue_tail(&VAR_1->mc_report_queue, VAR_0);
		if (!mod_delayed_work(VAR_3, &VAR_1->mc_report_work, 0))
			in6_dev_hold(VAR_1);
		VAR_0 = NULL;
	}
	spin_unlock_bh(&VAR_1->mc_report_lock);
out:
	kfree_skb(VAR_0);
}",torvalds/linux/2d3916f3189172d5c69d33065c3c21119fe539fc/mcast.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,22 +1,18 @@
-int igmp6_event_report(struct sk_buff *skb)
+void igmp6_event_report(struct sk_buff *skb)
 {
 	struct inet6_dev *idev = __in6_dev_get(skb->dev);
 
-	if (!idev)
-		return -EINVAL;
-
-	if (idev->dead) {
-		kfree_skb(skb);
-		return -ENODEV;
-	}
+	if (!idev || idev->dead)
+		goto out;
 
 	spin_lock_bh(&idev->mc_report_lock);
 	if (skb_queue_len(&idev->mc_report_queue) < MLD_MAX_SKBS) {
 		__skb_queue_tail(&idev->mc_report_queue, skb);
 		if (!mod_delayed_work(mld_wq, &idev->mc_report_work, 0))
 			in6_dev_hold(idev);
+		skb = NULL;
 	}
 	spin_unlock_bh(&idev->mc_report_lock);
-
-	return 0;
+out:
+	kfree_skb(skb);
 }","{'deleted_lines': ['int igmp6_event_report(struct sk_buff *skb)', '\tif (!idev)', '\t\treturn -EINVAL;', '', '\tif (idev->dead) {', '\t\tkfree_skb(skb);', '\t\treturn -ENODEV;', '\t}', '', '\treturn 0;'], 'added_lines': ['void igmp6_event_report(struct sk_buff *skb)', '\tif (!idev || idev->dead)', '\t\tgoto out;', '\t\tskb = NULL;', 'out:', '\tkfree_skb(skb);']}",True,Memory leak in icmp6 implementation in Linux Kernel 5.13+ allows a remote attacker to DoS a host by making it go out-of-memory via icmp6 packets of type 130 or 131. We recommend upgrading past commit 2d3916f3189172d5c69d33065c3c21119fe539fc.,7.5,HIGH,2,test,,5
CVE-2022-0742,['CWE-401'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"While investigating on why a synchronize_net() has been added recently
in ipv6_mc_down(), I found that igmp6_event_query() and igmp6_event_report()
might drop skbs in some cases.

Discussion about removing synchronize_net() from ipv6_mc_down()
will happen in a different thread.

Fixes: f185de28d9ae (""mld: add new workqueues for process mld events"")
Signed-off-by: Eric Dumazet <edumazet@google.com>
Cc: Taehee Yoo <ap420073@gmail.com>
Cc: Cong Wang <xiyou.wangcong@gmail.com>
Cc: David Ahern <dsahern@kernel.org>
Link: https://lore.kernel.org/r/20220303173728.937869-1-eric.dumazet@gmail.com
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
",2d3916f3189172d5c69d33065c3c21119fe539fc,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=2d3916f3189172d5c69d33065c3c21119fe539fc,net/ipv6/mcast.c,igmp6_event_query,"int igmp6_event_query(struct sk_buff *skb)
{
struct inet6_dev *idev = __in6_dev_get(skb->dev);
if (!idev)
return -EINVAL;
if (idev->dead) {
kfree_skb(skb);
return -ENODEV;
}
spin_lock_bh(&idev->mc_query_lock);
if (skb_queue_len(&idev->mc_query_queue) < MLD_MAX_SKBS) {
__skb_queue_tail(&idev->mc_query_queue, skb);
if (!mod_delayed_work(mld_wq, &idev->mc_query_work, 0))
in6_dev_hold(idev);
}
spin_unlock_bh(&idev->mc_query_lock);
return 0;
}","int igmp6_event_query(struct sk_buff *VAR_0)
{
struct inet6_dev *VAR_1 = __in6_dev_get(VAR_0->dev);
if (!VAR_1)
return -VAR_2;
if (VAR_1->dead) {
kfree_skb(VAR_0);
return -VAR_3;
}
spin_lock_bh(&VAR_1->mc_query_lock);
if (skb_queue_len(&VAR_1->mc_query_queue) < VAR_4) {
__skb_queue_tail(&VAR_1->mc_query_queue, VAR_0);
if (!mod_delayed_work(VAR_5, &VAR_1->mc_query_work, 0))
in6_dev_hold(VAR_1);
}
spin_unlock_bh(&VAR_1->mc_query_lock);
return 0;
}",torvalds/linux/2d3916f3189172d5c69d33065c3c21119fe539fc/mcast.c/vul/before/1.json,"void igmp6_event_query(struct sk_buff *skb)
{
	struct inet6_dev *idev = __in6_dev_get(skb->dev);

	if (!idev || idev->dead)
		goto out;

	spin_lock_bh(&idev->mc_query_lock);
	if (skb_queue_len(&idev->mc_query_queue) < MLD_MAX_SKBS) {
		__skb_queue_tail(&idev->mc_query_queue, skb);
		if (!mod_delayed_work(mld_wq, &idev->mc_query_work, 0))
			in6_dev_hold(idev);
		skb = NULL;
	}
	spin_unlock_bh(&idev->mc_query_lock);
out:
	kfree_skb(skb);
}","void igmp6_event_query(struct sk_buff *VAR_0)
{
	struct inet6_dev *VAR_1 = __in6_dev_get(VAR_0->dev);

	if (!VAR_1 || VAR_1->dead)
		goto out;

	spin_lock_bh(&VAR_1->mc_query_lock);
	if (skb_queue_len(&VAR_1->mc_query_queue) < VAR_2) {
		__skb_queue_tail(&VAR_1->mc_query_queue, VAR_0);
		if (!mod_delayed_work(VAR_3, &VAR_1->mc_query_work, 0))
			in6_dev_hold(VAR_1);
		VAR_0 = NULL;
	}
	spin_unlock_bh(&VAR_1->mc_query_lock);
out:
	kfree_skb(VAR_0);
}",torvalds/linux/2d3916f3189172d5c69d33065c3c21119fe539fc/mcast.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,22 +1,18 @@
-int igmp6_event_query(struct sk_buff *skb)
+void igmp6_event_query(struct sk_buff *skb)
 {
 	struct inet6_dev *idev = __in6_dev_get(skb->dev);
 
-	if (!idev)
-		return -EINVAL;
-
-	if (idev->dead) {
-		kfree_skb(skb);
-		return -ENODEV;
-	}
+	if (!idev || idev->dead)
+		goto out;
 
 	spin_lock_bh(&idev->mc_query_lock);
 	if (skb_queue_len(&idev->mc_query_queue) < MLD_MAX_SKBS) {
 		__skb_queue_tail(&idev->mc_query_queue, skb);
 		if (!mod_delayed_work(mld_wq, &idev->mc_query_work, 0))
 			in6_dev_hold(idev);
+		skb = NULL;
 	}
 	spin_unlock_bh(&idev->mc_query_lock);
-
-	return 0;
+out:
+	kfree_skb(skb);
 }","{'deleted_lines': ['int igmp6_event_query(struct sk_buff *skb)', '\tif (!idev)', '\t\treturn -EINVAL;', '', '\tif (idev->dead) {', '\t\tkfree_skb(skb);', '\t\treturn -ENODEV;', '\t}', '', '\treturn 0;'], 'added_lines': ['void igmp6_event_query(struct sk_buff *skb)', '\tif (!idev || idev->dead)', '\t\tgoto out;', '\t\tskb = NULL;', 'out:', '\tkfree_skb(skb);']}",True,Memory leak in icmp6 implementation in Linux Kernel 5.13+ allows a remote attacker to DoS a host by making it go out-of-memory via icmp6 packets of type 130 or 131. We recommend upgrading past commit 2d3916f3189172d5c69d33065c3c21119fe539fc.,7.5,HIGH,2,test,,5
CVE-2022-0322,['CWE-704'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,torvalds/linux,"sctp_make_strreset_req() makes repeated calls to sctp_addto_chunk()
which will automatically account for padding on each call. inreq and
outreq are already 4 bytes aligned, but the payload is not and doing
SCTP_PAD4(a + b) (which _sctp_make_chunk() did implicitly here) is
different from SCTP_PAD4(a) + SCTP_PAD4(b) and not enough. It led to
possible attempt to use more buffer than it was allocated and triggered
a BUG_ON.

Cc: Vlad Yasevich <vyasevich@gmail.com>
Cc: Neil Horman <nhorman@tuxdriver.com>
Cc: Greg KH <gregkh@linuxfoundation.org>
Fixes: cc16f00f6529 (""sctp: add support for generating stream reconf ssn reset request chunk"")
Reported-by: Eiichi Tsukata <eiichi.tsukata@nutanix.com>
Signed-off-by: Eiichi Tsukata <eiichi.tsukata@nutanix.com>
Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Signed-off-by: Marcelo Ricardo Leitner <mleitner@redhat.com>
Reviewed-by: Xin Long <lucien.xin@gmail.com>
Link: https://lore.kernel.org/r/b97c1f8b0c7ff79ac4ed206fc2c49d3612e0850c.1634156849.git.mleitner@redhat.com
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
",a2d859e3fc97e79d907761550dbc03ff1b36479c,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=a2d859e3fc97e79d907761550dbc03ff1b36479c,net/sctp/sm_make_chunk.c,sctp_make_strreset_req,"struct sctp_chunk *sctp_make_strreset_req(
const struct sctp_association *asoc,
__u16 stream_num, __be16 *stream_list,
bool out, bool in)
{
__u16 stream_len = stream_num * sizeof(__u16);
struct sctp_strreset_outreq outreq;
struct sctp_strreset_inreq inreq;
struct sctp_chunk *retval;
__u16 outlen, inlen;
outlen = (sizeof(outreq) + stream_len) * out;
inlen = (sizeof(inreq) + stream_len) * in;
retval = sctp_make_reconf(asoc, outlen + inlen);
if (!retval)
return NULL;
if (outlen) {
outreq.param_hdr.type = SCTP_PARAM_RESET_OUT_REQUEST;
outreq.param_hdr.length = htons(outlen);
outreq.request_seq = htonl(asoc->strreset_outseq);
outreq.response_seq = htonl(asoc->strreset_inseq - 1);
outreq.send_reset_at_tsn = htonl(asoc->next_tsn - 1);
sctp_addto_chunk(retval, sizeof(outreq), &outreq);
if (stream_len)
sctp_addto_chunk(retval, stream_len, stream_list);
}
if (inlen) {
inreq.param_hdr.type = SCTP_PARAM_RESET_IN_REQUEST;
inreq.param_hdr.length = htons(inlen);
inreq.request_seq = htonl(asoc->strreset_outseq + out);
sctp_addto_chunk(retval, sizeof(inreq), &inreq);
if (stream_len)
sctp_addto_chunk(retval, stream_len, stream_list);
}
return retval;
}","struct sctp_chunk *sctp_make_strreset_req(
const struct sctp_association *VAR_0,
__u16 VAR_1, __be16 *stream_list,
bool VAR_2, bool VAR_3)
{
__u16 VAR_4 = VAR_1 * sizeof(__u16);
struct sctp_strreset_outreq VAR_5;
struct sctp_strreset_inreq VAR_6;
struct sctp_chunk *VAR_7;
__u16 VAR_8, VAR_9;
VAR_8 = (sizeof(VAR_5) + VAR_4) * VAR_2;
VAR_9 = (sizeof(VAR_6) + VAR_4) * VAR_3;
VAR_7 = sctp_make_reconf(VAR_0, VAR_8 + VAR_9);
if (!VAR_7)
return NULL;
if (VAR_8) {
VAR_5.param_hdr.type = VAR_10;
VAR_5.param_hdr.length = htons(VAR_8);
VAR_5.request_seq = htonl(VAR_0->strreset_outseq);
VAR_5.response_seq = htonl(VAR_0->strreset_inseq - 1);
VAR_5.send_reset_at_tsn = htonl(VAR_0->next_tsn - 1);
sctp_addto_chunk(VAR_7, sizeof(VAR_5), &VAR_5);
if (VAR_4)
sctp_addto_chunk(VAR_7, VAR_4, stream_list);
}
if (VAR_9) {
VAR_6.param_hdr.type = VAR_11;
VAR_6.param_hdr.length = htons(VAR_9);
VAR_6.request_seq = htonl(VAR_0->strreset_outseq + VAR_2);
sctp_addto_chunk(VAR_7, sizeof(VAR_6), &VAR_6);
if (VAR_4)
sctp_addto_chunk(VAR_7, VAR_4, stream_list);
}
return VAR_7;
}",torvalds/linux/a2d859e3fc97e79d907761550dbc03ff1b36479c/sm_make_chunk.c/vul/before/0.json,"struct sctp_chunk *sctp_make_strreset_req(
					const struct sctp_association *asoc,
					__u16 stream_num, __be16 *stream_list,
					bool out, bool in)
{
	__u16 stream_len = stream_num * sizeof(__u16);
	struct sctp_strreset_outreq outreq;
	struct sctp_strreset_inreq inreq;
	struct sctp_chunk *retval;
	__u16 outlen, inlen;

	outlen = (sizeof(outreq) + stream_len) * out;
	inlen = (sizeof(inreq) + stream_len) * in;

	retval = sctp_make_reconf(asoc, SCTP_PAD4(outlen) + SCTP_PAD4(inlen));
	if (!retval)
		return NULL;

	if (outlen) {
		outreq.param_hdr.type = SCTP_PARAM_RESET_OUT_REQUEST;
		outreq.param_hdr.length = htons(outlen);
		outreq.request_seq = htonl(asoc->strreset_outseq);
		outreq.response_seq = htonl(asoc->strreset_inseq - 1);
		outreq.send_reset_at_tsn = htonl(asoc->next_tsn - 1);

		sctp_addto_chunk(retval, sizeof(outreq), &outreq);

		if (stream_len)
			sctp_addto_chunk(retval, stream_len, stream_list);
	}

	if (inlen) {
		inreq.param_hdr.type = SCTP_PARAM_RESET_IN_REQUEST;
		inreq.param_hdr.length = htons(inlen);
		inreq.request_seq = htonl(asoc->strreset_outseq + out);

		sctp_addto_chunk(retval, sizeof(inreq), &inreq);

		if (stream_len)
			sctp_addto_chunk(retval, stream_len, stream_list);
	}

	return retval;
}","struct sctp_chunk *sctp_make_strreset_req(
					const struct sctp_association *VAR_0,
					__u16 VAR_1, __be16 *stream_list,
					bool VAR_2, bool VAR_3)
{
	__u16 VAR_4 = VAR_1 * sizeof(__u16);
	struct sctp_strreset_outreq VAR_5;
	struct sctp_strreset_inreq VAR_6;
	struct sctp_chunk *VAR_7;
	__u16 VAR_8, VAR_9;

	VAR_8 = (sizeof(VAR_5) + VAR_4) * VAR_2;
	VAR_9 = (sizeof(VAR_6) + VAR_4) * VAR_3;

	VAR_7 = sctp_make_reconf(VAR_0, SCTP_PAD4(VAR_8) + SCTP_PAD4(VAR_9));
	if (!VAR_7)
		return NULL;

	if (VAR_8) {
		VAR_5.param_hdr.type = VAR_10;
		VAR_5.param_hdr.length = htons(VAR_8);
		VAR_5.request_seq = htonl(VAR_0->strreset_outseq);
		VAR_5.response_seq = htonl(VAR_0->strreset_inseq - 1);
		VAR_5.send_reset_at_tsn = htonl(VAR_0->next_tsn - 1);

		sctp_addto_chunk(VAR_7, sizeof(VAR_5), &VAR_5);

		if (VAR_4)
			sctp_addto_chunk(VAR_7, VAR_4, stream_list);
	}

	if (VAR_9) {
		VAR_6.param_hdr.type = VAR_11;
		VAR_6.param_hdr.length = htons(VAR_9);
		VAR_6.request_seq = htonl(VAR_0->strreset_outseq + VAR_2);

		sctp_addto_chunk(VAR_7, sizeof(VAR_6), &VAR_6);

		if (VAR_4)
			sctp_addto_chunk(VAR_7, VAR_4, stream_list);
	}

	return VAR_7;
}",torvalds/linux/a2d859e3fc97e79d907761550dbc03ff1b36479c/sm_make_chunk.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,7 +12,7 @@
 	outlen = (sizeof(outreq) + stream_len) * out;
 	inlen = (sizeof(inreq) + stream_len) * in;
 
-	retval = sctp_make_reconf(asoc, outlen + inlen);
+	retval = sctp_make_reconf(asoc, SCTP_PAD4(outlen) + SCTP_PAD4(inlen));
 	if (!retval)
 		return NULL;
 ","{'deleted_lines': ['\tretval = sctp_make_reconf(asoc, outlen + inlen);'], 'added_lines': ['\tretval = sctp_make_reconf(asoc, SCTP_PAD4(outlen) + SCTP_PAD4(inlen));']}",True,"A flaw was found in the sctp_make_strreset_req function in net/sctp/sm_make_chunk.c in the SCTP network protocol in the Linux kernel with a local user privilege access. In this flaw, an attempt to use more buffer than is allocated triggers a BUG_ON issue, leading to a denial of service (DOS).",5.5,MEDIUM,1,test,,5
CVE-2022-1943,['CWE-787'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"udf_write_fi() uses lengthOfImpUse of the entry it is writing to.
However this field has not yet been initialized so it either contains
completely bogus value or value from last directory entry at that place.
In either case this is wrong and can lead to filesystem corruption or
kernel crashes.

Reported-by: butt3rflyh4ck <butterflyhuangxx@gmail.com>
CC: stable@vger.kernel.org
Fixes: 979a6e28dd96 (""udf: Get rid of 0-length arrays in struct fileIdentDesc"")
Signed-off-by: Jan Kara <jack@suse.cz>
",c1ad35dd0548ce947d97aaf92f7f2f9a202951cf,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=c1ad35dd0548ce947d97aaf92f7f2f9a202951cf,fs/udf/namei.c,udf_write_fi,"int udf_write_fi(struct inode *inode, struct fileIdentDesc *cfi,
struct fileIdentDesc *sfi, struct udf_fileident_bh *fibh,
uint8_t *impuse, uint8_t *fileident)
{
uint16_t crclen = fibh->eoffset - fibh->soffset - sizeof(struct tag);
uint16_t crc;
int offset;
uint16_t liu = le16_to_cpu(cfi->lengthOfImpUse);
uint8_t lfi = cfi->lengthFileIdent;
int padlen = fibh->eoffset - fibh->soffset - liu - lfi -
sizeof(struct fileIdentDesc);
int adinicb = 0;
if (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)
adinicb = 1;
offset = fibh->soffset + sizeof(struct fileIdentDesc);
if (impuse) {
if (adinicb || (offset + liu < 0)) {
memcpy((uint8_t *)sfi->impUse, impuse, liu);
} else if (offset >= 0) {
memcpy(fibh->ebh->b_data + offset, impuse, liu);
} else {
memcpy((uint8_t *)sfi->impUse, impuse, -offset);
memcpy(fibh->ebh->b_data, impuse - offset,
liu + offset);
}
}
offset += liu;
if (fileident) {
if (adinicb || (offset + lfi < 0)) {
memcpy(udf_get_fi_ident(sfi), fileident, lfi);
} else if (offset >= 0) {
memcpy(fibh->ebh->b_data + offset, fileident, lfi);
} else {
memcpy(udf_get_fi_ident(sfi), fileident, -offset);
memcpy(fibh->ebh->b_data, fileident - offset,
lfi + offset);
}
}
offset += lfi;
if (adinicb || (offset + padlen < 0)) {
memset(udf_get_fi_ident(sfi) + lfi, 0x00, padlen);
} else if (offset >= 0) {
memset(fibh->ebh->b_data + offset, 0x00, padlen);
} else {
memset(udf_get_fi_ident(sfi) + lfi, 0x00, -offset);
memset(fibh->ebh->b_data, 0x00, padlen + offset);
}
crc = crc_itu_t(0, (uint8_t *)cfi + sizeof(struct tag),
sizeof(struct fileIdentDesc) - sizeof(struct tag));
if (fibh->sbh == fibh->ebh) {
crc = crc_itu_t(crc, (uint8_t *)sfi->impUse,
crclen + sizeof(struct tag) -
sizeof(struct fileIdentDesc));
} else if (sizeof(struct fileIdentDesc) >= -fibh->soffset) {
crc = crc_itu_t(crc, fibh->ebh->b_data +
sizeof(struct fileIdentDesc) +
fibh->soffset,
crclen + sizeof(struct tag) -
sizeof(struct fileIdentDesc));
} else {
crc = crc_itu_t(crc, (uint8_t *)sfi->impUse,
-fibh->soffset - sizeof(struct fileIdentDesc));
crc = crc_itu_t(crc, fibh->ebh->b_data, fibh->eoffset);
}
cfi->descTag.descCRC = cpu_to_le16(crc);
cfi->descTag.descCRCLength = cpu_to_le16(crclen);
cfi->descTag.tagChecksum = udf_tag_checksum(&cfi->descTag);
if (adinicb || (sizeof(struct fileIdentDesc) <= -fibh->soffset)) {
memcpy((uint8_t *)sfi, (uint8_t *)cfi,
sizeof(struct fileIdentDesc));
} else {
memcpy((uint8_t *)sfi, (uint8_t *)cfi, -fibh->soffset);
memcpy(fibh->ebh->b_data, (uint8_t *)cfi - fibh->soffset,
sizeof(struct fileIdentDesc) + fibh->soffset);
}
if (adinicb) {
mark_inode_dirty(inode);
} else {
if (fibh->sbh != fibh->ebh)
mark_buffer_dirty_inode(fibh->ebh, inode);
mark_buffer_dirty_inode(fibh->sbh, inode);
}
inode_inc_iversion(inode);
return 0;
}","int udf_write_fi(struct inode *inode, struct fileIdentDesc *VAR_0,
struct fileIdentDesc *VAR_1, struct udf_fileident_bh *VAR_2,
uint8_t *VAR_3, uint8_t *VAR_4)
{
uint16_t VAR_5 = VAR_2->eoffset - VAR_2->soffset - sizeof(struct tag);
uint16_t VAR_6;
int VAR_7;
uint16_t VAR_8 = le16_to_cpu(VAR_0->lengthOfImpUse);
uint8_t VAR_9 = VAR_0->lengthFileIdent;
int VAR_10 = VAR_2->eoffset - VAR_2->soffset - VAR_8 - VAR_9 -
sizeof(struct fileIdentDesc);
int VAR_11 = 0;
if (UDF_I(inode)->i_alloc_type == VAR_12)
VAR_11 = 1;
VAR_7 = VAR_2->soffset + sizeof(struct fileIdentDesc);
if (VAR_3) {
if (VAR_11 || (VAR_7 + VAR_8 < 0)) {
memcpy((uint8_t *)VAR_1->impUse, VAR_3, VAR_8);
} else if (VAR_7 >= 0) {
memcpy(VAR_2->ebh->b_data + VAR_7, VAR_3, VAR_8);
} else {
memcpy((uint8_t *)VAR_1->impUse, VAR_3, -VAR_7);
memcpy(VAR_2->ebh->b_data, VAR_3 - VAR_7,
VAR_8 + VAR_7);
}
}
VAR_7 += VAR_8;
if (VAR_4) {
if (VAR_11 || (VAR_7 + VAR_9 < 0)) {
memcpy(udf_get_fi_ident(VAR_1), VAR_4, VAR_9);
} else if (VAR_7 >= 0) {
memcpy(VAR_2->ebh->b_data + VAR_7, VAR_4, VAR_9);
} else {
memcpy(udf_get_fi_ident(VAR_1), VAR_4, -VAR_7);
memcpy(VAR_2->ebh->b_data, VAR_4 - VAR_7,
VAR_9 + VAR_7);
}
}
VAR_7 += VAR_9;
if (VAR_11 || (VAR_7 + VAR_10 < 0)) {
memset(udf_get_fi_ident(VAR_1) + VAR_9, 0x00, VAR_10);
} else if (VAR_7 >= 0) {
memset(VAR_2->ebh->b_data + VAR_7, 0x00, VAR_10);
} else {
memset(udf_get_fi_ident(VAR_1) + VAR_9, 0x00, -VAR_7);
memset(VAR_2->ebh->b_data, 0x00, VAR_10 + VAR_7);
}
VAR_6 = crc_itu_t(0, (uint8_t *)VAR_0 + sizeof(struct tag),
sizeof(struct fileIdentDesc) - sizeof(struct tag));
if (VAR_2->sbh == VAR_2->ebh) {
VAR_6 = crc_itu_t(VAR_6, (uint8_t *)VAR_1->impUse,
VAR_5 + sizeof(struct tag) -
sizeof(struct fileIdentDesc));
} else if (sizeof(struct fileIdentDesc) >= -VAR_2->soffset) {
VAR_6 = crc_itu_t(VAR_6, VAR_2->ebh->b_data +
sizeof(struct fileIdentDesc) +
VAR_2->soffset,
VAR_5 + sizeof(struct tag) -
sizeof(struct fileIdentDesc));
} else {
VAR_6 = crc_itu_t(VAR_6, (uint8_t *)VAR_1->impUse,
-VAR_2->soffset - sizeof(struct fileIdentDesc));
VAR_6 = crc_itu_t(VAR_6, VAR_2->ebh->b_data, VAR_2->eoffset);
}
VAR_0->descTag.descCRC = cpu_to_le16(VAR_6);
VAR_0->descTag.descCRCLength = cpu_to_le16(VAR_5);
VAR_0->descTag.tagChecksum = udf_tag_checksum(&VAR_0->descTag);
if (VAR_11 || (sizeof(struct fileIdentDesc) <= -VAR_2->soffset)) {
memcpy((uint8_t *)VAR_1, (uint8_t *)VAR_0,
sizeof(struct fileIdentDesc));
} else {
memcpy((uint8_t *)VAR_1, (uint8_t *)VAR_0, -VAR_2->soffset);
memcpy(VAR_2->ebh->b_data, (uint8_t *)VAR_0 - VAR_2->soffset,
sizeof(struct fileIdentDesc) + VAR_2->soffset);
}
if (VAR_11) {
mark_inode_dirty(inode);
} else {
if (VAR_2->sbh != VAR_2->ebh)
mark_buffer_dirty_inode(VAR_2->ebh, inode);
mark_buffer_dirty_inode(VAR_2->sbh, inode);
}
inode_inc_iversion(inode);
return 0;
}",torvalds/linux/c1ad35dd0548ce947d97aaf92f7f2f9a202951cf/namei.c/vul/before/0.json,"int udf_write_fi(struct inode *inode, struct fileIdentDesc *cfi,
		 struct fileIdentDesc *sfi, struct udf_fileident_bh *fibh,
		 uint8_t *impuse, uint8_t *fileident)
{
	uint16_t crclen = fibh->eoffset - fibh->soffset - sizeof(struct tag);
	uint16_t crc;
	int offset;
	uint16_t liu = le16_to_cpu(cfi->lengthOfImpUse);
	uint8_t lfi = cfi->lengthFileIdent;
	int padlen = fibh->eoffset - fibh->soffset - liu - lfi -
		sizeof(struct fileIdentDesc);
	int adinicb = 0;

	if (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)
		adinicb = 1;

	offset = fibh->soffset + sizeof(struct fileIdentDesc);

	if (impuse) {
		if (adinicb || (offset + liu < 0)) {
			memcpy((uint8_t *)sfi->impUse, impuse, liu);
		} else if (offset >= 0) {
			memcpy(fibh->ebh->b_data + offset, impuse, liu);
		} else {
			memcpy((uint8_t *)sfi->impUse, impuse, -offset);
			memcpy(fibh->ebh->b_data, impuse - offset,
				liu + offset);
		}
	}

	offset += liu;

	if (fileident) {
		if (adinicb || (offset + lfi < 0)) {
			memcpy(sfi->impUse + liu, fileident, lfi);
		} else if (offset >= 0) {
			memcpy(fibh->ebh->b_data + offset, fileident, lfi);
		} else {
			memcpy(sfi->impUse + liu, fileident, -offset);
			memcpy(fibh->ebh->b_data, fileident - offset,
				lfi + offset);
		}
	}

	offset += lfi;

	if (adinicb || (offset + padlen < 0)) {
		memset(sfi->impUse + liu + lfi, 0x00, padlen);
	} else if (offset >= 0) {
		memset(fibh->ebh->b_data + offset, 0x00, padlen);
	} else {
		memset(sfi->impUse + liu + lfi, 0x00, -offset);
		memset(fibh->ebh->b_data, 0x00, padlen + offset);
	}

	crc = crc_itu_t(0, (uint8_t *)cfi + sizeof(struct tag),
		      sizeof(struct fileIdentDesc) - sizeof(struct tag));

	if (fibh->sbh == fibh->ebh) {
		crc = crc_itu_t(crc, (uint8_t *)sfi->impUse,
			      crclen + sizeof(struct tag) -
			      sizeof(struct fileIdentDesc));
	} else if (sizeof(struct fileIdentDesc) >= -fibh->soffset) {
		crc = crc_itu_t(crc, fibh->ebh->b_data +
					sizeof(struct fileIdentDesc) +
					fibh->soffset,
			      crclen + sizeof(struct tag) -
					sizeof(struct fileIdentDesc));
	} else {
		crc = crc_itu_t(crc, (uint8_t *)sfi->impUse,
			      -fibh->soffset - sizeof(struct fileIdentDesc));
		crc = crc_itu_t(crc, fibh->ebh->b_data, fibh->eoffset);
	}

	cfi->descTag.descCRC = cpu_to_le16(crc);
	cfi->descTag.descCRCLength = cpu_to_le16(crclen);
	cfi->descTag.tagChecksum = udf_tag_checksum(&cfi->descTag);

	if (adinicb || (sizeof(struct fileIdentDesc) <= -fibh->soffset)) {
		memcpy((uint8_t *)sfi, (uint8_t *)cfi,
			sizeof(struct fileIdentDesc));
	} else {
		memcpy((uint8_t *)sfi, (uint8_t *)cfi, -fibh->soffset);
		memcpy(fibh->ebh->b_data, (uint8_t *)cfi - fibh->soffset,
		       sizeof(struct fileIdentDesc) + fibh->soffset);
	}

	if (adinicb) {
		mark_inode_dirty(inode);
	} else {
		if (fibh->sbh != fibh->ebh)
			mark_buffer_dirty_inode(fibh->ebh, inode);
		mark_buffer_dirty_inode(fibh->sbh, inode);
	}
	inode_inc_iversion(inode);

	return 0;
}","int udf_write_fi(struct inode *inode, struct fileIdentDesc *VAR_0,
		 struct fileIdentDesc *VAR_1, struct udf_fileident_bh *VAR_2,
		 uint8_t *VAR_3, uint8_t *VAR_4)
{
	uint16_t VAR_5 = VAR_2->eoffset - VAR_2->soffset - sizeof(struct tag);
	uint16_t VAR_6;
	int VAR_7;
	uint16_t VAR_8 = le16_to_cpu(VAR_0->lengthOfImpUse);
	uint8_t VAR_9 = VAR_0->lengthFileIdent;
	int VAR_10 = VAR_2->eoffset - VAR_2->soffset - VAR_8 - VAR_9 -
		sizeof(struct fileIdentDesc);
	int VAR_11 = 0;

	if (UDF_I(inode)->i_alloc_type == VAR_12)
		VAR_11 = 1;

	VAR_7 = VAR_2->soffset + sizeof(struct fileIdentDesc);

	if (VAR_3) {
		if (VAR_11 || (VAR_7 + VAR_8 < 0)) {
			memcpy((uint8_t *)VAR_1->impUse, VAR_3, VAR_8);
		} else if (VAR_7 >= 0) {
			memcpy(VAR_2->ebh->b_data + VAR_7, VAR_3, VAR_8);
		} else {
			memcpy((uint8_t *)VAR_1->impUse, VAR_3, -VAR_7);
			memcpy(VAR_2->ebh->b_data, VAR_3 - VAR_7,
				VAR_8 + VAR_7);
		}
	}

	VAR_7 += VAR_8;

	if (VAR_4) {
		if (VAR_11 || (VAR_7 + VAR_9 < 0)) {
			memcpy(VAR_1->impUse + VAR_8, VAR_4, VAR_9);
		} else if (VAR_7 >= 0) {
			memcpy(VAR_2->ebh->b_data + VAR_7, VAR_4, VAR_9);
		} else {
			memcpy(VAR_1->impUse + VAR_8, VAR_4, -VAR_7);
			memcpy(VAR_2->ebh->b_data, VAR_4 - VAR_7,
				VAR_9 + VAR_7);
		}
	}

	VAR_7 += VAR_9;

	if (VAR_11 || (VAR_7 + VAR_10 < 0)) {
		memset(VAR_1->impUse + VAR_8 + VAR_9, 0x00, VAR_10);
	} else if (VAR_7 >= 0) {
		memset(VAR_2->ebh->b_data + VAR_7, 0x00, VAR_10);
	} else {
		memset(VAR_1->impUse + VAR_8 + VAR_9, 0x00, -VAR_7);
		memset(VAR_2->ebh->b_data, 0x00, VAR_10 + VAR_7);
	}

	VAR_6 = crc_itu_t(0, (uint8_t *)VAR_0 + sizeof(struct tag),
		      sizeof(struct fileIdentDesc) - sizeof(struct tag));

	if (VAR_2->sbh == VAR_2->ebh) {
		VAR_6 = crc_itu_t(VAR_6, (uint8_t *)VAR_1->impUse,
			      VAR_5 + sizeof(struct tag) -
			      sizeof(struct fileIdentDesc));
	} else if (sizeof(struct fileIdentDesc) >= -VAR_2->soffset) {
		VAR_6 = crc_itu_t(VAR_6, VAR_2->ebh->b_data +
					sizeof(struct fileIdentDesc) +
					VAR_2->soffset,
			      VAR_5 + sizeof(struct tag) -
					sizeof(struct fileIdentDesc));
	} else {
		VAR_6 = crc_itu_t(VAR_6, (uint8_t *)VAR_1->impUse,
			      -VAR_2->soffset - sizeof(struct fileIdentDesc));
		VAR_6 = crc_itu_t(VAR_6, VAR_2->ebh->b_data, VAR_2->eoffset);
	}

	VAR_0->descTag.descCRC = cpu_to_le16(VAR_6);
	VAR_0->descTag.descCRCLength = cpu_to_le16(VAR_5);
	VAR_0->descTag.tagChecksum = udf_tag_checksum(&VAR_0->descTag);

	if (VAR_11 || (sizeof(struct fileIdentDesc) <= -VAR_2->soffset)) {
		memcpy((uint8_t *)VAR_1, (uint8_t *)VAR_0,
			sizeof(struct fileIdentDesc));
	} else {
		memcpy((uint8_t *)VAR_1, (uint8_t *)VAR_0, -VAR_2->soffset);
		memcpy(VAR_2->ebh->b_data, (uint8_t *)VAR_0 - VAR_2->soffset,
		       sizeof(struct fileIdentDesc) + VAR_2->soffset);
	}

	if (VAR_11) {
		mark_inode_dirty(inode);
	} else {
		if (VAR_2->sbh != VAR_2->ebh)
			mark_buffer_dirty_inode(VAR_2->ebh, inode);
		mark_buffer_dirty_inode(VAR_2->sbh, inode);
	}
	inode_inc_iversion(inode);

	return 0;
}",torvalds/linux/c1ad35dd0548ce947d97aaf92f7f2f9a202951cf/namei.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -32,11 +32,11 @@
 
 	if (fileident) {
 		if (adinicb || (offset + lfi < 0)) {
-			memcpy(udf_get_fi_ident(sfi), fileident, lfi);
+			memcpy(sfi->impUse + liu, fileident, lfi);
 		} else if (offset >= 0) {
 			memcpy(fibh->ebh->b_data + offset, fileident, lfi);
 		} else {
-			memcpy(udf_get_fi_ident(sfi), fileident, -offset);
+			memcpy(sfi->impUse + liu, fileident, -offset);
 			memcpy(fibh->ebh->b_data, fileident - offset,
 				lfi + offset);
 		}
@@ -45,11 +45,11 @@
 	offset += lfi;
 
 	if (adinicb || (offset + padlen < 0)) {
-		memset(udf_get_fi_ident(sfi) + lfi, 0x00, padlen);
+		memset(sfi->impUse + liu + lfi, 0x00, padlen);
 	} else if (offset >= 0) {
 		memset(fibh->ebh->b_data + offset, 0x00, padlen);
 	} else {
-		memset(udf_get_fi_ident(sfi) + lfi, 0x00, -offset);
+		memset(sfi->impUse + liu + lfi, 0x00, -offset);
 		memset(fibh->ebh->b_data, 0x00, padlen + offset);
 	}
 ","{'deleted_lines': ['\t\t\tmemcpy(udf_get_fi_ident(sfi), fileident, lfi);', '\t\t\tmemcpy(udf_get_fi_ident(sfi), fileident, -offset);', '\t\tmemset(udf_get_fi_ident(sfi) + lfi, 0x00, padlen);', '\t\tmemset(udf_get_fi_ident(sfi) + lfi, 0x00, -offset);'], 'added_lines': ['\t\t\tmemcpy(sfi->impUse + liu, fileident, lfi);', '\t\t\tmemcpy(sfi->impUse + liu, fileident, -offset);', '\t\tmemset(sfi->impUse + liu + lfi, 0x00, padlen);', '\t\tmemset(sfi->impUse + liu + lfi, 0x00, -offset);']}",True,A flaw out of bounds memory write in the Linux kernel UDF file system functionality was found in the way user triggers some file operation which triggers udf_write_fi(). A local user could use this flaw to crash the system or potentially,7.8,HIGH,2,test,,5
CVE-2016-2505,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"Check section size when verifying CRC

Bug: 28333006
Change-Id: Ief7a2da848face78f0edde21e2f2009316076679
",4f236c532039a61f0cf681d2e3c6e022911bbb5c,https://android.googlesource.com/platform/frameworks/av/+/4f236c532039a61f0cf681d2e3c6e022911bbb5c,media/libstagefright/mpeg2ts/ATSParser.cpp,ATSParser::PSISection::isCRCOkay,"bool ATSParser::PSISection::isCRCOkay() const {
if (!isComplete()) {
return false;
}
uint8_t* data = mBuffer->data();
if ((data[1] & 0x80) == 0) {
return true;
}
unsigned sectionLength = U16_AT(data + 1) & 0xfff;
ALOGV(""sectionLength %u, skip %u"", sectionLength, mSkipBytes);
sectionLength -= mSkipBytes;
uint32_t crc = 0xffffffff;
for(unsigned i = 0; i < sectionLength + 4 ; i++) {
uint8_t b = data[i];
int index = ((crc >> 24) ^ (b & 0xff)) & 0xff;
crc = CRC_TABLE[index] ^ (crc << 8);
}
ALOGV(""crc: %08x\n"", crc);
return (crc == 0);
}","bool ATSParser::PSISection::isCRCOkay() const {
if (!isComplete()) {
return false;
}
uint8_t* VAR_0 = VAR_1->data();
if ((VAR_0[1] & 0x80) == 0) {
return true;
}
unsigned VAR_2 = U16_AT(VAR_0 + 1) & 0xfff;
ALOGV(""sectionLength %u, skip %u"", VAR_2, VAR_3);
VAR_2 -= VAR_3;
uint32_t VAR_4 = 0xffffffff;
for(unsigned VAR_5 = 0; VAR_5 < VAR_2 + 4 ; VAR_5++) {
uint8_t VAR_6 = VAR_0[VAR_5];
int VAR_7 = ((VAR_4 >> 24) ^ (VAR_6 & 0xff)) & 0xff;
VAR_4 = VAR_8[VAR_7] ^ (VAR_4 << 8);
}
ALOGV(""crc: %08x\n"", VAR_4);
return (VAR_4 == 0);
}",android/4f236c532039a61f0cf681d2e3c6e022911bbb5c/ATSParser.cpp/vul/before/0.json,"bool ATSParser::PSISection::isCRCOkay() const {
    if (!isComplete()) {
        return false;
    }
    uint8_t* data = mBuffer->data();

    // Return true if section_syntax_indicator says no section follows the field section_length.
    if ((data[1] & 0x80) == 0) {
        return true;
    }

    unsigned sectionLength = U16_AT(data + 1) & 0xfff;
    ALOGV(""sectionLength %u, skip %u"", sectionLength, mSkipBytes);


    if(sectionLength < mSkipBytes) {
        ALOGE(""b/28333006"");
        android_errorWriteLog(0x534e4554, ""28333006"");
        return false;
    }

    // Skip the preceding field present when payload start indicator is on.
    sectionLength -= mSkipBytes;

    uint32_t crc = 0xffffffff;
    for(unsigned i = 0; i < sectionLength + 4 /* crc */; i++) {
        uint8_t b = data[i];
        int index = ((crc >> 24) ^ (b & 0xff)) & 0xff;
        crc = CRC_TABLE[index] ^ (crc << 8);
    }
    ALOGV(""crc: %08x\n"", crc);
    return (crc == 0);
}","bool ATSParser::PSISection::isCRCOkay() const {
    if (!isComplete()) {
        return false;
    }
    uint8_t* VAR_0 = VAR_1->data();

    /* COMMENT_0 */
    if ((VAR_0[1] & 0x80) == 0) {
        return true;
    }

    unsigned VAR_2 = U16_AT(VAR_0 + 1) & 0xfff;
    ALOGV(""sectionLength %u, skip %u"", VAR_2, VAR_3);


    if(VAR_2 < VAR_3) {
        ALOGE(""b/28333006"");
        android_errorWriteLog(0x534e4554, ""28333006"");
        return false;
    }

    /* COMMENT_1 */
    VAR_2 -= VAR_3;

    uint32_t VAR_4 = 0xffffffff;
    for(unsigned VAR_5 = 0; VAR_5 < VAR_2 + 4 /* COMMENT_2 */; VAR_5++) {
        uint8_t VAR_6 = VAR_0[VAR_5];
        int VAR_7 = ((VAR_4 >> 24) ^ (VAR_6 & 0xff)) & 0xff;
        VAR_4 = VAR_8[VAR_7] ^ (VAR_4 << 8);
    }
    ALOGV(""crc: %08x\n"", VAR_4);
    return (VAR_4 == 0);
}",android/4f236c532039a61f0cf681d2e3c6e022911bbb5c/ATSParser.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -12,6 +12,13 @@
     unsigned sectionLength = U16_AT(data + 1) & 0xfff;
     ALOGV(""sectionLength %u, skip %u"", sectionLength, mSkipBytes);
 
+
+    if(sectionLength < mSkipBytes) {
+        ALOGE(""b/28333006"");
+        android_errorWriteLog(0x534e4554, ""28333006"");
+        return false;
+    }
+
     // Skip the preceding field present when payload start indicator is on.
     sectionLength -= mSkipBytes;
 ","{'deleted_lines': [], 'added_lines': ['', '    if(sectionLength < mSkipBytes) {', '        ALOGE(""b/28333006"");', '        android_errorWriteLog(0x534e4554, ""28333006"");', '        return false;', '    }', '']}",True,"mpeg2ts/ATSParser.cpp in libstagefright in mediaserver in Android 6.x before 2016-07-01 does not validate a certain section length, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 28333006.",7.8,HIGH,2,test,,5
CVE-2016-2506,['CWE-119'],AV:N/AC:L/Au:N/C:C/I:C/A:C,0,android,"Fix security vulnerability in libstagefright

bug: 28175045
Change-Id: Icee6c7eb5b761da4aa3e412fb71825508d74d38f
",e248db02fbab2ee9162940bc19f087fd7d96cb9d,https://android.googlesource.com/platform/frameworks/av/+/e248db02fbab2ee9162940bc19f087fd7d96cb9d,media/libstagefright/DRMExtractor.cpp,DRMSource::read,"status_t DRMSource::read(MediaBuffer **buffer, const ReadOptions *options) {
Mutex::Autolock autoLock(mDRMLock);
status_t err;
if ((err = mOriginalMediaSource->read(buffer, options)) != OK) {
return err;
}
size_t len = (*buffer)->range_length();
char *src = (char *)(*buffer)->data() + (*buffer)->range_offset();
DrmBuffer encryptedDrmBuffer(src, len);
DrmBuffer decryptedDrmBuffer;
decryptedDrmBuffer.length = len;
decryptedDrmBuffer.data = new char[len];
DrmBuffer *pDecryptedDrmBuffer = &decryptedDrmBuffer;
if ((err = mDrmManagerClient->decrypt(mDecryptHandle, mTrackId,
&encryptedDrmBuffer, &pDecryptedDrmBuffer)) != NO_ERROR) {
if (decryptedDrmBuffer.data) {
delete [] decryptedDrmBuffer.data;
decryptedDrmBuffer.data = NULL;
}
return err;
}
CHECK(pDecryptedDrmBuffer == &decryptedDrmBuffer);
const char *mime;
CHECK(getFormat()->findCString(kKeyMIMEType, &mime));
if (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC) && !mWantsNALFragments) {
uint8_t *dstData = (uint8_t*)src;
size_t srcOffset = 0;
size_t dstOffset = 0;
len = decryptedDrmBuffer.length;
while (srcOffset < len) {
CHECK(srcOffset + mNALLengthSize <= len);
size_t nalLength = 0;
const uint8_t* data = (const uint8_t*)(&decryptedDrmBuffer.data[srcOffset]);
switch (mNALLengthSize) {
case 1:
nalLength = *data;
break;
case 2:
nalLength = U16_AT(data);
break;
case 3:
nalLength = ((size_t)data[0] << 16) | U16_AT(&data[1]);
break;
case 4:
nalLength = U32_AT(data);
break;
default:
CHECK(!""Should not be here."");
break;
}
srcOffset += mNALLengthSize;
size_t end = srcOffset + nalLength;
if (end > len || end < srcOffset) {
if (decryptedDrmBuffer.data) {
delete [] decryptedDrmBuffer.data;
decryptedDrmBuffer.data = NULL;
}
return ERROR_MALFORMED;
}
if (nalLength == 0) {
continue;
}
CHECK(dstOffset + 4 <= (*buffer)->size());
dstData[dstOffset++] = 0;
dstData[dstOffset++] = 0;
dstData[dstOffset++] = 0;
dstData[dstOffset++] = 1;
memcpy(&dstData[dstOffset], &decryptedDrmBuffer.data[srcOffset], nalLength);
srcOffset += nalLength;
dstOffset += nalLength;
}
CHECK_EQ(srcOffset, len);
(*buffer)->set_range((*buffer)->range_offset(), dstOffset);
} else {
memcpy(src, decryptedDrmBuffer.data, decryptedDrmBuffer.length);
(*buffer)->set_range((*buffer)->range_offset(), decryptedDrmBuffer.length);
}
if (decryptedDrmBuffer.data) {
delete [] decryptedDrmBuffer.data;
decryptedDrmBuffer.data = NULL;
}
return OK;
}","status_t DRMSource::read(MediaBuffer **VAR_0, const ReadOptions *VAR_1) {
Mutex::Autolock autoLock(mDRMLock);
status_t VAR_2;
if ((VAR_2 = VAR_3->read(VAR_0, VAR_1)) != VAR_4) {
return VAR_2;
}
size_t VAR_5 = (*VAR_0)->range_length();
char *VAR_6 = (char *)(*VAR_0)->data() + (*VAR_0)->range_offset();
DrmBuffer encryptedDrmBuffer(src, len);
DrmBuffer VAR_7;
VAR_7.length = len;
VAR_7.data = new char[len];
DrmBuffer *VAR_8 = &VAR_7;
if ((VAR_2 = VAR_9->decrypt(VAR_10, VAR_11,
&VAR_12, &VAR_8)) != VAR_13) {
if (VAR_7.data) {
delete [] VAR_7.data;
VAR_7.data = NULL;
}
return VAR_2;
}
CHECK(VAR_8 == &VAR_7);
const char *VAR_14;
CHECK(getFormat()->findCString(VAR_15, &VAR_14));
if (!strcasecmp(VAR_14, VAR_16) && !VAR_17) {
uint8_t *VAR_18 = (uint8_t*)src;
size_t VAR_19 = 0;
size_t VAR_20 = 0;
len = VAR_7.length;
while (VAR_19 < len) {
CHECK(VAR_19 + VAR_21 <= len);
size_t VAR_22 = 0;
const uint8_t* VAR_23 = (const uint8_t*)(&VAR_7.data[VAR_19]);
switch (VAR_21) {
case 1:
VAR_22 = *VAR_23;
break;
case 2:
VAR_22 = U16_AT(VAR_23);
break;
case 3:
VAR_22 = ((size_t)VAR_23[0] << 16) | U16_AT(&VAR_23[1]);
break;
case 4:
VAR_22 = U32_AT(VAR_23);
break;
default:
CHECK(!""Should not be here."");
break;
}
VAR_19 += VAR_21;
size_t VAR_24 = VAR_19 + VAR_22;
if (VAR_24 > len || VAR_24 < VAR_19) {
if (VAR_7.data) {
delete [] VAR_7.data;
VAR_7.data = NULL;
}
return VAR_25;
}
if (VAR_22 == 0) {
continue;
}
CHECK(VAR_20 + 4 <= (*VAR_0)->size());
VAR_18[VAR_20++] = 0;
VAR_18[VAR_20++] = 0;
VAR_18[VAR_20++] = 0;
VAR_18[VAR_20++] = 1;
memcpy(&VAR_18[VAR_20], &VAR_7.data[VAR_19], VAR_22);
VAR_19 += VAR_22;
VAR_20 += VAR_22;
}
CHECK_EQ(VAR_19, len);
(*VAR_0)->set_range((*VAR_0)->range_offset(), VAR_20);
} else {
memcpy(src, VAR_7.data, VAR_7.length);
(*VAR_0)->set_range((*VAR_0)->range_offset(), VAR_7.length);
}
if (VAR_7.data) {
delete [] VAR_7.data;
VAR_7.data = NULL;
}
return VAR_4;
}",android/e248db02fbab2ee9162940bc19f087fd7d96cb9d/DRMExtractor.cpp/vul/before/0.json,"status_t DRMSource::read(MediaBuffer **buffer, const ReadOptions *options) {
    Mutex::Autolock autoLock(mDRMLock);
    status_t err;
    if ((err = mOriginalMediaSource->read(buffer, options)) != OK) {
        return err;
    }

    size_t len = (*buffer)->range_length();

    char *src = (char *)(*buffer)->data() + (*buffer)->range_offset();

    DrmBuffer encryptedDrmBuffer(src, len);
    DrmBuffer decryptedDrmBuffer;
    decryptedDrmBuffer.length = len;
    decryptedDrmBuffer.data = new char[len];
    DrmBuffer *pDecryptedDrmBuffer = &decryptedDrmBuffer;

    if ((err = mDrmManagerClient->decrypt(mDecryptHandle, mTrackId,
            &encryptedDrmBuffer, &pDecryptedDrmBuffer)) != NO_ERROR) {

        if (decryptedDrmBuffer.data) {
            delete [] decryptedDrmBuffer.data;
            decryptedDrmBuffer.data = NULL;
        }

        return err;
    }
    CHECK(pDecryptedDrmBuffer == &decryptedDrmBuffer);

    const char *mime;
    CHECK(getFormat()->findCString(kKeyMIMEType, &mime));

    if (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC) && !mWantsNALFragments) {
        uint8_t *dstData = (uint8_t*)src;
        size_t srcOffset = 0;
        size_t dstOffset = 0;

        len = decryptedDrmBuffer.length;
        while (srcOffset < len) {
            CHECK(srcOffset + mNALLengthSize <= len);
            size_t nalLength = 0;
            const uint8_t* data = (const uint8_t*)(&decryptedDrmBuffer.data[srcOffset]);

            switch (mNALLengthSize) {
                case 1:
                    nalLength = *data;
                    break;
                case 2:
                    nalLength = U16_AT(data);
                    break;
                case 3:
                    nalLength = ((size_t)data[0] << 16) | U16_AT(&data[1]);
                    break;
                case 4:
                    nalLength = U32_AT(data);
                    break;
                default:
                    CHECK(!""Should not be here."");
                    break;
            }

            srcOffset += mNALLengthSize;

            size_t end = srcOffset + nalLength;
            if (end > len || end < srcOffset) {
                if (decryptedDrmBuffer.data) {
                    delete [] decryptedDrmBuffer.data;
                    decryptedDrmBuffer.data = NULL;
                }

                return ERROR_MALFORMED;
            }

            if (nalLength == 0) {
                continue;
            }

            if (dstOffset > SIZE_MAX - 4 ||
                dstOffset + 4 > SIZE_MAX - nalLength ||
                dstOffset + 4 + nalLength > (*buffer)->size()) {
                (*buffer)->release();
                (*buffer) = NULL;
                if (decryptedDrmBuffer.data) {
                    delete [] decryptedDrmBuffer.data;
                    decryptedDrmBuffer.data = NULL;
                }
                return ERROR_MALFORMED;
            }

            dstData[dstOffset++] = 0;
            dstData[dstOffset++] = 0;
            dstData[dstOffset++] = 0;
            dstData[dstOffset++] = 1;
            memcpy(&dstData[dstOffset], &decryptedDrmBuffer.data[srcOffset], nalLength);
            srcOffset += nalLength;
            dstOffset += nalLength;
        }

        CHECK_EQ(srcOffset, len);
        (*buffer)->set_range((*buffer)->range_offset(), dstOffset);

    } else {
        memcpy(src, decryptedDrmBuffer.data, decryptedDrmBuffer.length);
        (*buffer)->set_range((*buffer)->range_offset(), decryptedDrmBuffer.length);
    }

    if (decryptedDrmBuffer.data) {
        delete [] decryptedDrmBuffer.data;
        decryptedDrmBuffer.data = NULL;
    }

    return OK;
}","status_t DRMSource::read(MediaBuffer **VAR_0, const ReadOptions *VAR_1) {
    Mutex::Autolock autoLock(mDRMLock);
    status_t VAR_2;
    if ((VAR_2 = VAR_3->read(VAR_0, VAR_1)) != VAR_4) {
        return VAR_2;
    }

    size_t VAR_5 = (*VAR_0)->range_length();

    char *VAR_6 = (char *)(*VAR_0)->data() + (*VAR_0)->range_offset();

    DrmBuffer encryptedDrmBuffer(src, len);
    DrmBuffer VAR_7;
    VAR_7.length = len;
    VAR_7.data = new char[len];
    DrmBuffer *VAR_8 = &VAR_7;

    if ((VAR_2 = VAR_9->decrypt(VAR_10, VAR_11,
            &VAR_12, &VAR_8)) != VAR_13) {

        if (VAR_7.data) {
            delete [] VAR_7.data;
            VAR_7.data = NULL;
        }

        return VAR_2;
    }
    CHECK(VAR_8 == &VAR_7);

    const char *VAR_14;
    CHECK(getFormat()->findCString(VAR_15, &VAR_14));

    if (!strcasecmp(VAR_14, VAR_16) && !VAR_17) {
        uint8_t *VAR_18 = (uint8_t*)src;
        size_t VAR_19 = 0;
        size_t VAR_20 = 0;

        len = VAR_7.length;
        while (VAR_19 < len) {
            CHECK(VAR_19 + VAR_21 <= len);
            size_t VAR_22 = 0;
            const uint8_t* VAR_23 = (const uint8_t*)(&VAR_7.data[VAR_19]);

            switch (VAR_21) {
                case 1:
                    VAR_22 = *VAR_23;
                    break;
                case 2:
                    VAR_22 = U16_AT(VAR_23);
                    break;
                case 3:
                    VAR_22 = ((size_t)VAR_23[0] << 16) | U16_AT(&VAR_23[1]);
                    break;
                case 4:
                    VAR_22 = U32_AT(VAR_23);
                    break;
                default:
                    CHECK(!""Should not be here."");
                    break;
            }

            VAR_19 += VAR_21;

            size_t VAR_24 = VAR_19 + VAR_22;
            if (VAR_24 > len || VAR_24 < VAR_19) {
                if (VAR_7.data) {
                    delete [] VAR_7.data;
                    VAR_7.data = NULL;
                }

                return VAR_25;
            }

            if (VAR_22 == 0) {
                continue;
            }

            if (VAR_20 > VAR_26 - 4 ||
                VAR_20 + 4 > VAR_26 - VAR_22 ||
                VAR_20 + 4 + VAR_22 > (*VAR_0)->size()) {
                (*VAR_0)->release();
                (*VAR_0) = NULL;
                if (VAR_7.data) {
                    delete [] VAR_7.data;
                    VAR_7.data = NULL;
                }
                return VAR_25;
            }

            VAR_18[VAR_20++] = 0;
            VAR_18[VAR_20++] = 0;
            VAR_18[VAR_20++] = 0;
            VAR_18[VAR_20++] = 1;
            memcpy(&VAR_18[VAR_20], &VAR_7.data[VAR_19], VAR_22);
            VAR_19 += VAR_22;
            VAR_20 += VAR_22;
        }

        CHECK_EQ(VAR_19, len);
        (*VAR_0)->set_range((*VAR_0)->range_offset(), VAR_20);

    } else {
        memcpy(src, VAR_7.data, VAR_7.length);
        (*VAR_0)->set_range((*VAR_0)->range_offset(), VAR_7.length);
    }

    if (VAR_7.data) {
        delete [] VAR_7.data;
        VAR_7.data = NULL;
    }

    return VAR_4;
}",android/e248db02fbab2ee9162940bc19f087fd7d96cb9d/DRMExtractor.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -75,7 +75,17 @@
                 continue;
             }
 
-            CHECK(dstOffset + 4 <= (*buffer)->size());
+            if (dstOffset > SIZE_MAX - 4 ||
+                dstOffset + 4 > SIZE_MAX - nalLength ||
+                dstOffset + 4 + nalLength > (*buffer)->size()) {
+                (*buffer)->release();
+                (*buffer) = NULL;
+                if (decryptedDrmBuffer.data) {
+                    delete [] decryptedDrmBuffer.data;
+                    decryptedDrmBuffer.data = NULL;
+                }
+                return ERROR_MALFORMED;
+            }
 
             dstData[dstOffset++] = 0;
             dstData[dstOffset++] = 0;","{'deleted_lines': ['            CHECK(dstOffset + 4 <= (*buffer)->size());'], 'added_lines': ['            if (dstOffset > SIZE_MAX - 4 ||', '                dstOffset + 4 > SIZE_MAX - nalLength ||', '                dstOffset + 4 + nalLength > (*buffer)->size()) {', '                (*buffer)->release();', '                (*buffer) = NULL;', '                if (decryptedDrmBuffer.data) {', '                    delete [] decryptedDrmBuffer.data;', '                    decryptedDrmBuffer.data = NULL;', '                }', '                return ERROR_MALFORMED;', '            }']}",True,"DRMExtractor.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 does not validate a certain offset value, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 28175045.",9.8,CRITICAL,3,test,,5
CVE-2016-3743,['CWE-20'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,android,"Decoder: Memset few structures to zero to handle error clips

Bug: 27907656
Change-Id: I671d135dd5c324c39b4ede990b7225d52ba882cd
",ecf6c7ce6d5a22d52160698aab44fc234c63291a,https://android.googlesource.com/platform/external/libavc/+/ecf6c7ce6d5a22d52160698aab44fc234c63291a,decoder/ih264d_api.c,ih264d_init_decoder,"void ih264d_init_decoder(void * ps_dec_params)
{
dec_struct_t * ps_dec = (dec_struct_t *)ps_dec_params;
dec_slice_params_t *ps_cur_slice;
pocstruct_t *ps_prev_poc, *ps_cur_poc;
ih264d_free_dynamic_bufs(ps_dec);
ps_cur_slice = ps_dec->ps_cur_slice;
ps_dec->init_done = 0;
ps_dec->u4_num_cores = 1;
ps_dec->u2_pic_ht = ps_dec->u2_pic_wd = 0;
ps_dec->u1_separate_parse = DEFAULT_SEPARATE_PARSE;
ps_dec->u4_app_disable_deblk_frm = 0;
ps_dec->i4_degrade_type = 0;
ps_dec->i4_degrade_pics = 0;
ps_dec->i4_app_skip_mode = IVD_SKIP_NONE;
ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;
memset(ps_dec->ps_pps, 0,
((sizeof(dec_pic_params_t)) * MAX_NUM_PIC_PARAMS));
memset(ps_dec->ps_sps, 0,
((sizeof(dec_seq_params_t)) * MAX_NUM_SEQ_PARAMS));
ps_dec->p_DeblockPicture[0] = ih264d_deblock_picture_non_mbaff;
ps_dec->p_DeblockPicture[1] = ih264d_deblock_picture_mbaff;
ps_dec->s_cab_dec_env.pv_codec_handle = ps_dec;
ps_dec->u4_num_fld_in_frm = 0;
ps_dec->ps_dpb_mgr->pv_codec_handle = ps_dec;
ps_dec->ps_sei->u1_is_valid = 0;
ps_dec->ps_cur_pps = NULL;
ps_dec->ps_cur_sps = NULL;
ps_dec->u1_init_dec_flag = 0;
ps_dec->u1_first_slice_in_stream = 1;
ps_dec->u1_first_pb_nal_in_pic = 1;
ps_dec->u1_last_pic_not_decoded = 0;
ps_dec->u4_app_disp_width = 0;
ps_dec->i4_header_decoded = 0;
ps_dec->u4_total_frames_decoded = 0;
ps_dec->i4_error_code = 0;
ps_dec->i4_content_type = -1;
ps_dec->ps_cur_slice->u1_mbaff_frame_flag = 0;
ps_dec->ps_dec_err_status->u1_err_flag = ACCEPT_ALL_PICS;     ps_dec->ps_dec_err_status->u1_cur_pic_type = PIC_TYPE_UNKNOWN;
ps_dec->ps_dec_err_status->u4_frm_sei_sync = SYNC_FRM_DEFAULT;
ps_dec->ps_dec_err_status->u4_cur_frm = INIT_FRAME;
ps_dec->ps_dec_err_status->u1_pic_aud_i = PIC_TYPE_UNKNOWN;
ps_dec->u1_pr_sl_type = 0xFF;
ps_dec->u2_mbx = 0xffff;
ps_dec->u2_mby = 0;
ps_dec->u2_total_mbs_coded = 0;
ps_prev_poc = &ps_dec->s_prev_pic_poc;
ps_cur_poc = &ps_dec->s_cur_pic_poc;
ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb = 0;
ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb = 0;
ps_prev_poc->i4_delta_pic_order_cnt_bottom =
ps_cur_poc->i4_delta_pic_order_cnt_bottom = 0;
ps_prev_poc->i4_delta_pic_order_cnt[0] =
ps_cur_poc->i4_delta_pic_order_cnt[0] = 0;
ps_prev_poc->i4_delta_pic_order_cnt[1] =
ps_cur_poc->i4_delta_pic_order_cnt[1] = 0;
ps_prev_poc->u1_mmco_equalto5 = ps_cur_poc->u1_mmco_equalto5 = 0;
ps_prev_poc->i4_top_field_order_count = ps_cur_poc->i4_top_field_order_count =
0;
ps_prev_poc->i4_bottom_field_order_count =
ps_cur_poc->i4_bottom_field_order_count = 0;
ps_prev_poc->u1_bot_field = ps_cur_poc->u1_bot_field = 0;
ps_prev_poc->u1_mmco_equalto5 = ps_cur_poc->u1_mmco_equalto5 = 0;
ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst = 0;
ps_cur_slice->u1_mmco_equalto5 = 0;
ps_cur_slice->u2_frame_num = 0;
ps_dec->i4_max_poc = 0;
ps_dec->i4_prev_max_display_seq = 0;
ps_dec->u1_recon_mb_grp = 4;
ps_dec->u1_second_field = 0;
ps_dec->s_prev_seq_params.u1_eoseq_pending = 0;
ps_dec->u2_crop_offset_y = 0;
ps_dec->u2_crop_offset_uv = 0;
ps_dec->i4_vui_frame_rate = -1;
ps_dec->i4_pic_type = -1;
ps_dec->i4_frametype = -1;
ps_dec->i4_content_type = -1;
ps_dec->u1_res_changed = 0;
ps_dec->u1_frame_decoded_flag = 0;
ps_dec->u4_skip_frm_mask = SKIP_NONE;
ps_dec->pf_cavlc_4x4res_block[0] = ih264d_cavlc_4x4res_block_totalcoeff_1;
ps_dec->pf_cavlc_4x4res_block[1] =
ih264d_cavlc_4x4res_block_totalcoeff_2to10;
ps_dec->pf_cavlc_4x4res_block[2] =
ih264d_cavlc_4x4res_block_totalcoeff_11to16;
ps_dec->pf_cavlc_parse4x4coeff[0] = ih264d_cavlc_parse4x4coeff_n0to7;
ps_dec->pf_cavlc_parse4x4coeff[1] = ih264d_cavlc_parse4x4coeff_n8;
ps_dec->pf_cavlc_parse_8x8block[0] =
ih264d_cavlc_parse_8x8block_none_available;
ps_dec->pf_cavlc_parse_8x8block[1] =
ih264d_cavlc_parse_8x8block_left_available;
ps_dec->pf_cavlc_parse_8x8block[2] =
ih264d_cavlc_parse_8x8block_top_available;
ps_dec->pf_cavlc_parse_8x8block[3] =
ih264d_cavlc_parse_8x8block_both_available;
ps_dec->pf_fill_bs1[0][0] = ih264d_fill_bs1_16x16mb_pslice;
ps_dec->pf_fill_bs1[0][1] = ih264d_fill_bs1_non16x16mb_pslice;
ps_dec->pf_fill_bs1[1][0] = ih264d_fill_bs1_16x16mb_bslice;
ps_dec->pf_fill_bs1[1][1] = ih264d_fill_bs1_non16x16mb_bslice;
ps_dec->pf_fill_bs_xtra_left_edge[0] =
ih264d_fill_bs_xtra_left_edge_cur_frm;
ps_dec->pf_fill_bs_xtra_left_edge[1] =
ih264d_fill_bs_xtra_left_edge_cur_fld;
ih264d_init_ref_bufs(ps_dec->ps_dpb_mgr);
ps_dec->u2_prv_frame_num = 0;
ps_dec->u1_top_bottom_decoded = 0;
ps_dec->u1_dangling_field = 0;
ps_dec->s_cab_dec_env.cabac_table = gau4_ih264d_cabac_table;
ps_dec->pu1_left_mv_ctxt_inc = ps_dec->u1_left_mv_ctxt_inc_arr[0];
ps_dec->pi1_left_ref_idx_ctxt_inc =
&ps_dec->i1_left_ref_idx_ctx_inc_arr[0][0];
ps_dec->pu1_left_yuv_dc_csbp = &ps_dec->u1_yuv_dc_csbp_topmb;
ps_dec->u1_flushfrm = 0;
{
ps_dec->s_cab_dec_env.pv_codec_handle = (void*)ps_dec;
ps_dec->ps_bitstrm->pv_codec_handle = (void*)ps_dec;
ps_dec->ps_cur_slice->pv_codec_handle = (void*)ps_dec;
ps_dec->ps_dpb_mgr->pv_codec_handle = (void*)ps_dec;
}
memset(ps_dec->disp_bufs, 0, (MAX_DISP_BUFS_NEW) * sizeof(disp_buf_t));
memset(ps_dec->u4_disp_buf_mapping, 0,
(MAX_DISP_BUFS_NEW) * sizeof(UWORD32));
memset(ps_dec->u4_disp_buf_to_be_freed, 0,
(MAX_DISP_BUFS_NEW) * sizeof(UWORD32));
ih264d_init_arch(ps_dec);
ih264d_init_function_ptr(ps_dec);
ps_dec->e_frm_out_mode = IVD_DISPLAY_FRAME_OUT;
ps_dec->init_done = 1;
}","void ih264d_init_decoder(void * VAR_0)
{
dec_struct_t * VAR_1 = (dec_struct_t *)VAR_0;
dec_slice_params_t *VAR_2;
pocstruct_t *VAR_3, *VAR_4;
ih264d_free_dynamic_bufs(VAR_1);
VAR_2 = VAR_1->ps_cur_slice;
VAR_1->init_done = 0;
VAR_1->u4_num_cores = 1;
VAR_1->u2_pic_ht = VAR_1->u2_pic_wd = 0;
VAR_1->u1_separate_parse = VAR_5;
VAR_1->u4_app_disable_deblk_frm = 0;
VAR_1->i4_degrade_type = 0;
VAR_1->i4_degrade_pics = 0;
VAR_1->i4_app_skip_mode = VAR_6;
VAR_1->i4_dec_skip_mode = VAR_6;
memset(VAR_1->ps_pps, 0,
((sizeof(VAR_7)) * VAR_8));
memset(VAR_1->ps_sps, 0,
((sizeof(VAR_9)) * VAR_10));
VAR_1->p_DeblockPicture[0] = VAR_11;
VAR_1->p_DeblockPicture[1] = VAR_12;
VAR_1->s_cab_dec_env.pv_codec_handle = VAR_1;
VAR_1->u4_num_fld_in_frm = 0;
VAR_1->ps_dpb_mgr->pv_codec_handle = VAR_1;
VAR_1->ps_sei->u1_is_valid = 0;
VAR_1->ps_cur_pps = NULL;
VAR_1->ps_cur_sps = NULL;
VAR_1->u1_init_dec_flag = 0;
VAR_1->u1_first_slice_in_stream = 1;
VAR_1->u1_first_pb_nal_in_pic = 1;
VAR_1->u1_last_pic_not_decoded = 0;
VAR_1->u4_app_disp_width = 0;
VAR_1->i4_header_decoded = 0;
VAR_1->u4_total_frames_decoded = 0;
VAR_1->i4_error_code = 0;
VAR_1->i4_content_type = -1;
VAR_1->ps_cur_slice->u1_mbaff_frame_flag = 0;
VAR_1->ps_dec_err_status->u1_err_flag = VAR_13; 
VAR_1->ps_dec_err_status->u1_cur_pic_type = VAR_14;
VAR_1->ps_dec_err_status->u4_frm_sei_sync = VAR_15;
VAR_1->ps_dec_err_status->u4_cur_frm = VAR_16;
VAR_1->ps_dec_err_status->u1_pic_aud_i = VAR_14;
VAR_1->u1_pr_sl_type = 0xFF;
VAR_1->u2_mbx = 0xffff;
VAR_1->u2_mby = 0;
VAR_1->u2_total_mbs_coded = 0;
VAR_3 = &VAR_1->s_prev_pic_poc;
VAR_4 = &VAR_1->s_cur_pic_poc;
VAR_3->i4_pic_order_cnt_lsb = VAR_4->i4_pic_order_cnt_lsb = 0;
VAR_3->i4_pic_order_cnt_msb = VAR_4->i4_pic_order_cnt_msb = 0;
VAR_3->i4_delta_pic_order_cnt_bottom =
VAR_4->i4_delta_pic_order_cnt_bottom = 0;
VAR_3->i4_delta_pic_order_cnt[0] =
VAR_4->i4_delta_pic_order_cnt[0] = 0;
VAR_3->i4_delta_pic_order_cnt[1] =
VAR_4->i4_delta_pic_order_cnt[1] = 0;
VAR_3->u1_mmco_equalto5 = VAR_4->u1_mmco_equalto5 = 0;
VAR_3->i4_top_field_order_count = VAR_4->i4_top_field_order_count =
0;
VAR_3->i4_bottom_field_order_count =
VAR_4->i4_bottom_field_order_count = 0;
VAR_3->u1_bot_field = VAR_4->u1_bot_field = 0;
VAR_3->u1_mmco_equalto5 = VAR_4->u1_mmco_equalto5 = 0;
VAR_3->i4_prev_frame_num_ofst = VAR_4->i4_prev_frame_num_ofst = 0;
VAR_2->u1_mmco_equalto5 = 0;
VAR_2->u2_frame_num = 0;
VAR_1->i4_max_poc = 0;
VAR_1->i4_prev_max_display_seq = 0;
VAR_1->u1_recon_mb_grp = 4;
VAR_1->u1_second_field = 0;
VAR_1->s_prev_seq_params.u1_eoseq_pending = 0;
VAR_1->u2_crop_offset_y = 0;
VAR_1->u2_crop_offset_uv = 0;
VAR_1->i4_vui_frame_rate = -1;
VAR_1->i4_pic_type = -1;
VAR_1->i4_frametype = -1;
VAR_1->i4_content_type = -1;
VAR_1->u1_res_changed = 0;
VAR_1->u1_frame_decoded_flag = 0;
VAR_1->u4_skip_frm_mask = VAR_17;
VAR_1->pf_cavlc_4x4res_block[0] = VAR_18;
VAR_1->pf_cavlc_4x4res_block[1] =
VAR_19;
VAR_1->pf_cavlc_4x4res_block[2] =
VAR_20;
VAR_1->pf_cavlc_parse4x4coeff[0] = VAR_21;
VAR_1->pf_cavlc_parse4x4coeff[1] = VAR_22;
VAR_1->pf_cavlc_parse_8x8block[0] =
VAR_23;
VAR_1->pf_cavlc_parse_8x8block[1] =
VAR_24;
VAR_1->pf_cavlc_parse_8x8block[2] =
VAR_25;
VAR_1->pf_cavlc_parse_8x8block[3] =
VAR_26;
VAR_1->pf_fill_bs1[0][0] = VAR_27;
VAR_1->pf_fill_bs1[0][1] = VAR_28;
VAR_1->pf_fill_bs1[1][0] = VAR_29;
VAR_1->pf_fill_bs1[1][1] = VAR_30;
VAR_1->pf_fill_bs_xtra_left_edge[0] =
VAR_31;
VAR_1->pf_fill_bs_xtra_left_edge[1] =
VAR_32;
ih264d_init_ref_bufs(VAR_1->ps_dpb_mgr);
VAR_1->u2_prv_frame_num = 0;
VAR_1->u1_top_bottom_decoded = 0;
VAR_1->u1_dangling_field = 0;
VAR_1->s_cab_dec_env.cabac_table = VAR_33;
VAR_1->pu1_left_mv_ctxt_inc = VAR_1->u1_left_mv_ctxt_inc_arr[0];
VAR_1->pi1_left_ref_idx_ctxt_inc =
&VAR_1->i1_left_ref_idx_ctx_inc_arr[0][0];
VAR_1->pu1_left_yuv_dc_csbp = &VAR_1->u1_yuv_dc_csbp_topmb;
VAR_1->u1_flushfrm = 0;
{
VAR_1->s_cab_dec_env.pv_codec_handle = (void*)VAR_1;
VAR_1->ps_bitstrm->pv_codec_handle = (void*)VAR_1;
VAR_1->ps_cur_slice->pv_codec_handle = (void*)VAR_1;
VAR_1->ps_dpb_mgr->pv_codec_handle = (void*)VAR_1;
}
memset(VAR_1->disp_bufs, 0, (VAR_34) * sizeof(VAR_35));
memset(VAR_1->u4_disp_buf_mapping, 0,
(VAR_34) * sizeof(VAR_36));
memset(VAR_1->u4_disp_buf_to_be_freed, 0,
(VAR_34) * sizeof(VAR_36));
ih264d_init_arch(VAR_1);
ih264d_init_function_ptr(VAR_1);
VAR_1->e_frm_out_mode = VAR_37;
VAR_1->init_done = 1;
}",android/ecf6c7ce6d5a22d52160698aab44fc234c63291a/ih264d_api.c/vul/before/0.json,"void ih264d_init_decoder(void * ps_dec_params)
{
    dec_struct_t * ps_dec = (dec_struct_t *)ps_dec_params;
    dec_slice_params_t *ps_cur_slice;
    pocstruct_t *ps_prev_poc, *ps_cur_poc;
    WORD32 size;

    size = sizeof(pred_info_t) * 2 * 32;
    memset(ps_dec->ps_pred, 0 , size);

    size = sizeof(disp_mgr_t);
    memset(ps_dec->pv_disp_buf_mgr, 0 , size);

    size = sizeof(buf_mgr_t) + ithread_get_mutex_lock_size();
    memset(ps_dec->pv_pic_buf_mgr, 0, size);

    size = sizeof(dec_err_status_t);
    memset(ps_dec->ps_dec_err_status, 0, size);

    size = sizeof(sei);
    memset(ps_dec->ps_sei, 0, size);

    size = sizeof(dpb_commands_t);
    memset(ps_dec->ps_dpb_cmds, 0, size);

    size = sizeof(dec_bit_stream_t);
    memset(ps_dec->ps_bitstrm, 0, size);

    size = sizeof(dec_slice_params_t);
    memset(ps_dec->ps_cur_slice, 0, size);

    size = MAX(sizeof(dec_seq_params_t), sizeof(dec_pic_params_t));
    memset(ps_dec->pv_scratch_sps_pps, 0, size);

    size = sizeof(ctxt_inc_mb_info_t);
    memset(ps_dec->ps_left_mb_ctxt_info, 0, size);

    size = (sizeof(neighbouradd_t) << 2);
    memset(ps_dec->ps_left_mvpred_addr, 0 ,size);

    size = sizeof(buf_mgr_t) + ithread_get_mutex_lock_size();
    memset(ps_dec->pv_mv_buf_mgr, 0, size);

    /* Free any dynamic buffers that are allocated */
    ih264d_free_dynamic_bufs(ps_dec);

    ps_cur_slice = ps_dec->ps_cur_slice;
    ps_dec->init_done = 0;

    ps_dec->u4_num_cores = 1;

    ps_dec->u2_pic_ht = ps_dec->u2_pic_wd = 0;

    ps_dec->u1_separate_parse = DEFAULT_SEPARATE_PARSE;
    ps_dec->u4_app_disable_deblk_frm = 0;
    ps_dec->i4_degrade_type = 0;
    ps_dec->i4_degrade_pics = 0;

    ps_dec->i4_app_skip_mode = IVD_SKIP_NONE;
    ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;

    memset(ps_dec->ps_pps, 0,
           ((sizeof(dec_pic_params_t)) * MAX_NUM_PIC_PARAMS));
    memset(ps_dec->ps_sps, 0,
           ((sizeof(dec_seq_params_t)) * MAX_NUM_SEQ_PARAMS));

    /* Initialization of function pointers ih264d_deblock_picture function*/

    ps_dec->p_DeblockPicture[0] = ih264d_deblock_picture_non_mbaff;
    ps_dec->p_DeblockPicture[1] = ih264d_deblock_picture_mbaff;

    ps_dec->s_cab_dec_env.pv_codec_handle = ps_dec;

    ps_dec->u4_num_fld_in_frm = 0;

    ps_dec->ps_dpb_mgr->pv_codec_handle = ps_dec;

    /* Initialize the sei validity u4_flag with zero indiacting sei is not valid*/
    ps_dec->ps_sei->u1_is_valid = 0;

    /* decParams Initializations */
    ps_dec->ps_cur_pps = NULL;
    ps_dec->ps_cur_sps = NULL;
    ps_dec->u1_init_dec_flag = 0;
    ps_dec->u1_first_slice_in_stream = 1;
    ps_dec->u1_first_pb_nal_in_pic = 1;
    ps_dec->u1_last_pic_not_decoded = 0;
    ps_dec->u4_app_disp_width = 0;
    ps_dec->i4_header_decoded = 0;
    ps_dec->u4_total_frames_decoded = 0;

    ps_dec->i4_error_code = 0;
    ps_dec->i4_content_type = -1;
    ps_dec->ps_cur_slice->u1_mbaff_frame_flag = 0;

    ps_dec->ps_dec_err_status->u1_err_flag = ACCEPT_ALL_PICS; //REJECT_PB_PICS;
    ps_dec->ps_dec_err_status->u1_cur_pic_type = PIC_TYPE_UNKNOWN;
    ps_dec->ps_dec_err_status->u4_frm_sei_sync = SYNC_FRM_DEFAULT;
    ps_dec->ps_dec_err_status->u4_cur_frm = INIT_FRAME;
    ps_dec->ps_dec_err_status->u1_pic_aud_i = PIC_TYPE_UNKNOWN;

    ps_dec->u1_pr_sl_type = 0xFF;
    ps_dec->u2_mbx = 0xffff;
    ps_dec->u2_mby = 0;
    ps_dec->u2_total_mbs_coded = 0;

    /* POC initializations */
    ps_prev_poc = &ps_dec->s_prev_pic_poc;
    ps_cur_poc = &ps_dec->s_cur_pic_poc;
    ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb = 0;
    ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb = 0;
    ps_prev_poc->i4_delta_pic_order_cnt_bottom =
                    ps_cur_poc->i4_delta_pic_order_cnt_bottom = 0;
    ps_prev_poc->i4_delta_pic_order_cnt[0] =
                    ps_cur_poc->i4_delta_pic_order_cnt[0] = 0;
    ps_prev_poc->i4_delta_pic_order_cnt[1] =
                    ps_cur_poc->i4_delta_pic_order_cnt[1] = 0;
    ps_prev_poc->u1_mmco_equalto5 = ps_cur_poc->u1_mmco_equalto5 = 0;
    ps_prev_poc->i4_top_field_order_count = ps_cur_poc->i4_top_field_order_count =
                    0;
    ps_prev_poc->i4_bottom_field_order_count =
                    ps_cur_poc->i4_bottom_field_order_count = 0;
    ps_prev_poc->u1_bot_field = ps_cur_poc->u1_bot_field = 0;
    ps_prev_poc->u1_mmco_equalto5 = ps_cur_poc->u1_mmco_equalto5 = 0;
    ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst = 0;
    ps_cur_slice->u1_mmco_equalto5 = 0;
    ps_cur_slice->u2_frame_num = 0;

    ps_dec->i4_max_poc = 0;
    ps_dec->i4_prev_max_display_seq = 0;
    ps_dec->u1_recon_mb_grp = 4;

    /* Field PIC initializations */
    ps_dec->u1_second_field = 0;
    ps_dec->s_prev_seq_params.u1_eoseq_pending = 0;

    /* Set the cropping parameters as zero */
    ps_dec->u2_crop_offset_y = 0;
    ps_dec->u2_crop_offset_uv = 0;

    /* The Initial Frame Rate Info is not Present */
    ps_dec->i4_vui_frame_rate = -1;
    ps_dec->i4_pic_type = -1;
    ps_dec->i4_frametype = -1;
    ps_dec->i4_content_type = -1;

    ps_dec->u1_res_changed = 0;


    ps_dec->u1_frame_decoded_flag = 0;

    /* Set the default frame seek mask mode */
    ps_dec->u4_skip_frm_mask = SKIP_NONE;

    /********************************************************/
    /* Initialize CAVLC residual decoding function pointers */
    /********************************************************/
    ps_dec->pf_cavlc_4x4res_block[0] = ih264d_cavlc_4x4res_block_totalcoeff_1;
    ps_dec->pf_cavlc_4x4res_block[1] =
                    ih264d_cavlc_4x4res_block_totalcoeff_2to10;
    ps_dec->pf_cavlc_4x4res_block[2] =
                    ih264d_cavlc_4x4res_block_totalcoeff_11to16;

    ps_dec->pf_cavlc_parse4x4coeff[0] = ih264d_cavlc_parse4x4coeff_n0to7;
    ps_dec->pf_cavlc_parse4x4coeff[1] = ih264d_cavlc_parse4x4coeff_n8;

    ps_dec->pf_cavlc_parse_8x8block[0] =
                    ih264d_cavlc_parse_8x8block_none_available;
    ps_dec->pf_cavlc_parse_8x8block[1] =
                    ih264d_cavlc_parse_8x8block_left_available;
    ps_dec->pf_cavlc_parse_8x8block[2] =
                    ih264d_cavlc_parse_8x8block_top_available;
    ps_dec->pf_cavlc_parse_8x8block[3] =
                    ih264d_cavlc_parse_8x8block_both_available;

    /***************************************************************************/
    /* Initialize Bs calculation function pointers for P and B, 16x16/non16x16 */
    /***************************************************************************/
    ps_dec->pf_fill_bs1[0][0] = ih264d_fill_bs1_16x16mb_pslice;
    ps_dec->pf_fill_bs1[0][1] = ih264d_fill_bs1_non16x16mb_pslice;

    ps_dec->pf_fill_bs1[1][0] = ih264d_fill_bs1_16x16mb_bslice;
    ps_dec->pf_fill_bs1[1][1] = ih264d_fill_bs1_non16x16mb_bslice;

    ps_dec->pf_fill_bs_xtra_left_edge[0] =
                    ih264d_fill_bs_xtra_left_edge_cur_frm;
    ps_dec->pf_fill_bs_xtra_left_edge[1] =
                    ih264d_fill_bs_xtra_left_edge_cur_fld;

    /* Initialize Reference Pic Buffers */
    ih264d_init_ref_bufs(ps_dec->ps_dpb_mgr);

    ps_dec->u2_prv_frame_num = 0;
    ps_dec->u1_top_bottom_decoded = 0;
    ps_dec->u1_dangling_field = 0;

    ps_dec->s_cab_dec_env.cabac_table = gau4_ih264d_cabac_table;

    ps_dec->pu1_left_mv_ctxt_inc = ps_dec->u1_left_mv_ctxt_inc_arr[0];
    ps_dec->pi1_left_ref_idx_ctxt_inc =
                    &ps_dec->i1_left_ref_idx_ctx_inc_arr[0][0];
    ps_dec->pu1_left_yuv_dc_csbp = &ps_dec->u1_yuv_dc_csbp_topmb;

    /* ! */
    /* Initializing flush frame u4_flag */
    ps_dec->u1_flushfrm = 0;

    {
        ps_dec->s_cab_dec_env.pv_codec_handle = (void*)ps_dec;
        ps_dec->ps_bitstrm->pv_codec_handle = (void*)ps_dec;
        ps_dec->ps_cur_slice->pv_codec_handle = (void*)ps_dec;
        ps_dec->ps_dpb_mgr->pv_codec_handle = (void*)ps_dec;
    }

    memset(ps_dec->disp_bufs, 0, (MAX_DISP_BUFS_NEW) * sizeof(disp_buf_t));
    memset(ps_dec->u4_disp_buf_mapping, 0,
           (MAX_DISP_BUFS_NEW) * sizeof(UWORD32));
    memset(ps_dec->u4_disp_buf_to_be_freed, 0,
           (MAX_DISP_BUFS_NEW) * sizeof(UWORD32));

    ih264d_init_arch(ps_dec);
    ih264d_init_function_ptr(ps_dec);
    ps_dec->e_frm_out_mode = IVD_DISPLAY_FRAME_OUT;
    ps_dec->init_done = 1;

}","void ih264d_init_decoder(void * VAR_0)
{
    dec_struct_t * VAR_1 = (dec_struct_t *)VAR_0;
    dec_slice_params_t *VAR_2;
    pocstruct_t *VAR_3, *VAR_4;
    WORD32 VAR_5;

    VAR_5 = sizeof(VAR_6) * 2 * 32;
    memset(VAR_1->ps_pred, 0 , VAR_5);

    VAR_5 = sizeof(VAR_7);
    memset(VAR_1->pv_disp_buf_mgr, 0 , VAR_5);

    VAR_5 = sizeof(VAR_8) + ithread_get_mutex_lock_size();
    memset(VAR_1->pv_pic_buf_mgr, 0, VAR_5);

    VAR_5 = sizeof(VAR_9);
    memset(VAR_1->ps_dec_err_status, 0, VAR_5);

    VAR_5 = sizeof(VAR_10);
    memset(VAR_1->ps_sei, 0, VAR_5);

    VAR_5 = sizeof(VAR_11);
    memset(VAR_1->ps_dpb_cmds, 0, VAR_5);

    VAR_5 = sizeof(VAR_12);
    memset(VAR_1->ps_bitstrm, 0, VAR_5);

    VAR_5 = sizeof(dec_slice_params_t);
    memset(VAR_1->ps_cur_slice, 0, VAR_5);

    VAR_5 = MAX(sizeof(VAR_13), sizeof(VAR_14));
    memset(VAR_1->pv_scratch_sps_pps, 0, VAR_5);

    VAR_5 = sizeof(VAR_15);
    memset(VAR_1->ps_left_mb_ctxt_info, 0, VAR_5);

    VAR_5 = (sizeof(neighbouradd_t) << 2);
    memset(VAR_1->ps_left_mvpred_addr, 0 ,VAR_5);

    VAR_5 = sizeof(VAR_8) + ithread_get_mutex_lock_size();
    memset(VAR_1->pv_mv_buf_mgr, 0, VAR_5);

    /* COMMENT_0 */
    ih264d_free_dynamic_bufs(VAR_1);

    VAR_2 = VAR_1->ps_cur_slice;
    VAR_1->init_done = 0;

    VAR_1->u4_num_cores = 1;

    VAR_1->u2_pic_ht = VAR_1->u2_pic_wd = 0;

    VAR_1->u1_separate_parse = VAR_16;
    VAR_1->u4_app_disable_deblk_frm = 0;
    VAR_1->i4_degrade_type = 0;
    VAR_1->i4_degrade_pics = 0;

    VAR_1->i4_app_skip_mode = VAR_17;
    VAR_1->i4_dec_skip_mode = VAR_17;

    memset(VAR_1->ps_pps, 0,
           ((sizeof(VAR_14)) * VAR_18));
    memset(VAR_1->ps_sps, 0,
           ((sizeof(VAR_13)) * VAR_19));

    /* COMMENT_1 */

    VAR_1->p_DeblockPicture[0] = VAR_20;
    VAR_1->p_DeblockPicture[1] = VAR_21;

    VAR_1->s_cab_dec_env.pv_codec_handle = VAR_1;

    VAR_1->u4_num_fld_in_frm = 0;

    VAR_1->ps_dpb_mgr->pv_codec_handle = VAR_1;

    /* COMMENT_2 */
    VAR_1->ps_sei->u1_is_valid = 0;

    /* COMMENT_3 */
    VAR_1->ps_cur_pps = NULL;
    VAR_1->ps_cur_sps = NULL;
    VAR_1->u1_init_dec_flag = 0;
    VAR_1->u1_first_slice_in_stream = 1;
    VAR_1->u1_first_pb_nal_in_pic = 1;
    VAR_1->u1_last_pic_not_decoded = 0;
    VAR_1->u4_app_disp_width = 0;
    VAR_1->i4_header_decoded = 0;
    VAR_1->u4_total_frames_decoded = 0;

    VAR_1->i4_error_code = 0;
    VAR_1->i4_content_type = -1;
    VAR_1->ps_cur_slice->u1_mbaff_frame_flag = 0;

    VAR_1->ps_dec_err_status->u1_err_flag = VAR_22; /* COMMENT_4 */
    VAR_1->ps_dec_err_status->u1_cur_pic_type = VAR_23;
    VAR_1->ps_dec_err_status->u4_frm_sei_sync = VAR_24;
    VAR_1->ps_dec_err_status->u4_cur_frm = VAR_25;
    VAR_1->ps_dec_err_status->u1_pic_aud_i = VAR_23;

    VAR_1->u1_pr_sl_type = 0xFF;
    VAR_1->u2_mbx = 0xffff;
    VAR_1->u2_mby = 0;
    VAR_1->u2_total_mbs_coded = 0;

    /* COMMENT_5 */
    VAR_3 = &VAR_1->s_prev_pic_poc;
    VAR_4 = &VAR_1->s_cur_pic_poc;
    VAR_3->i4_pic_order_cnt_lsb = VAR_4->i4_pic_order_cnt_lsb = 0;
    VAR_3->i4_pic_order_cnt_msb = VAR_4->i4_pic_order_cnt_msb = 0;
    VAR_3->i4_delta_pic_order_cnt_bottom =
                    VAR_4->i4_delta_pic_order_cnt_bottom = 0;
    VAR_3->i4_delta_pic_order_cnt[0] =
                    VAR_4->i4_delta_pic_order_cnt[0] = 0;
    VAR_3->i4_delta_pic_order_cnt[1] =
                    VAR_4->i4_delta_pic_order_cnt[1] = 0;
    VAR_3->u1_mmco_equalto5 = VAR_4->u1_mmco_equalto5 = 0;
    VAR_3->i4_top_field_order_count = VAR_4->i4_top_field_order_count =
                    0;
    VAR_3->i4_bottom_field_order_count =
                    VAR_4->i4_bottom_field_order_count = 0;
    VAR_3->u1_bot_field = VAR_4->u1_bot_field = 0;
    VAR_3->u1_mmco_equalto5 = VAR_4->u1_mmco_equalto5 = 0;
    VAR_3->i4_prev_frame_num_ofst = VAR_4->i4_prev_frame_num_ofst = 0;
    VAR_2->u1_mmco_equalto5 = 0;
    VAR_2->u2_frame_num = 0;

    VAR_1->i4_max_poc = 0;
    VAR_1->i4_prev_max_display_seq = 0;
    VAR_1->u1_recon_mb_grp = 4;

    /* COMMENT_6 */
    VAR_1->u1_second_field = 0;
    VAR_1->s_prev_seq_params.u1_eoseq_pending = 0;

    /* COMMENT_7 */
    VAR_1->u2_crop_offset_y = 0;
    VAR_1->u2_crop_offset_uv = 0;

    /* COMMENT_8 */
    VAR_1->i4_vui_frame_rate = -1;
    VAR_1->i4_pic_type = -1;
    VAR_1->i4_frametype = -1;
    VAR_1->i4_content_type = -1;

    VAR_1->u1_res_changed = 0;


    VAR_1->u1_frame_decoded_flag = 0;

    /* COMMENT_9 */
    VAR_1->u4_skip_frm_mask = VAR_26;

    /* COMMENT_10 */
    /* COMMENT_11 */
    /* COMMENT_10 */
    VAR_1->pf_cavlc_4x4res_block[0] = VAR_27;
    VAR_1->pf_cavlc_4x4res_block[1] =
                    VAR_28;
    VAR_1->pf_cavlc_4x4res_block[2] =
                    VAR_29;

    VAR_1->pf_cavlc_parse4x4coeff[0] = VAR_30;
    VAR_1->pf_cavlc_parse4x4coeff[1] = VAR_31;

    VAR_1->pf_cavlc_parse_8x8block[0] =
                    VAR_32;
    VAR_1->pf_cavlc_parse_8x8block[1] =
                    VAR_33;
    VAR_1->pf_cavlc_parse_8x8block[2] =
                    VAR_34;
    VAR_1->pf_cavlc_parse_8x8block[3] =
                    VAR_35;

    /* COMMENT_12 */
    /* COMMENT_13 */
    /* COMMENT_12 */
    VAR_1->pf_fill_bs1[0][0] = VAR_36;
    VAR_1->pf_fill_bs1[0][1] = VAR_37;

    VAR_1->pf_fill_bs1[1][0] = VAR_38;
    VAR_1->pf_fill_bs1[1][1] = VAR_39;

    VAR_1->pf_fill_bs_xtra_left_edge[0] =
                    VAR_40;
    VAR_1->pf_fill_bs_xtra_left_edge[1] =
                    VAR_41;

    /* COMMENT_14 */
    ih264d_init_ref_bufs(VAR_1->ps_dpb_mgr);

    VAR_1->u2_prv_frame_num = 0;
    VAR_1->u1_top_bottom_decoded = 0;
    VAR_1->u1_dangling_field = 0;

    VAR_1->s_cab_dec_env.cabac_table = VAR_42;

    VAR_1->pu1_left_mv_ctxt_inc = VAR_1->u1_left_mv_ctxt_inc_arr[0];
    VAR_1->pi1_left_ref_idx_ctxt_inc =
                    &VAR_1->i1_left_ref_idx_ctx_inc_arr[0][0];
    VAR_1->pu1_left_yuv_dc_csbp = &VAR_1->u1_yuv_dc_csbp_topmb;

    /* COMMENT_15 */
    /* COMMENT_16 */
    VAR_1->u1_flushfrm = 0;

    {
        VAR_1->s_cab_dec_env.pv_codec_handle = (void*)VAR_1;
        VAR_1->ps_bitstrm->pv_codec_handle = (void*)VAR_1;
        VAR_1->ps_cur_slice->pv_codec_handle = (void*)VAR_1;
        VAR_1->ps_dpb_mgr->pv_codec_handle = (void*)VAR_1;
    }

    memset(VAR_1->disp_bufs, 0, (VAR_43) * sizeof(VAR_44));
    memset(VAR_1->u4_disp_buf_mapping, 0,
           (VAR_43) * sizeof(VAR_45));
    memset(VAR_1->u4_disp_buf_to_be_freed, 0,
           (VAR_43) * sizeof(VAR_45));

    ih264d_init_arch(VAR_1);
    ih264d_init_function_ptr(VAR_1);
    VAR_1->e_frm_out_mode = VAR_46;
    VAR_1->init_done = 1;

}",android/ecf6c7ce6d5a22d52160698aab44fc234c63291a/ih264d_api.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,6 +3,43 @@
     dec_struct_t * ps_dec = (dec_struct_t *)ps_dec_params;
     dec_slice_params_t *ps_cur_slice;
     pocstruct_t *ps_prev_poc, *ps_cur_poc;
+    WORD32 size;
+
+    size = sizeof(pred_info_t) * 2 * 32;
+    memset(ps_dec->ps_pred, 0 , size);
+
+    size = sizeof(disp_mgr_t);
+    memset(ps_dec->pv_disp_buf_mgr, 0 , size);
+
+    size = sizeof(buf_mgr_t) + ithread_get_mutex_lock_size();
+    memset(ps_dec->pv_pic_buf_mgr, 0, size);
+
+    size = sizeof(dec_err_status_t);
+    memset(ps_dec->ps_dec_err_status, 0, size);
+
+    size = sizeof(sei);
+    memset(ps_dec->ps_sei, 0, size);
+
+    size = sizeof(dpb_commands_t);
+    memset(ps_dec->ps_dpb_cmds, 0, size);
+
+    size = sizeof(dec_bit_stream_t);
+    memset(ps_dec->ps_bitstrm, 0, size);
+
+    size = sizeof(dec_slice_params_t);
+    memset(ps_dec->ps_cur_slice, 0, size);
+
+    size = MAX(sizeof(dec_seq_params_t), sizeof(dec_pic_params_t));
+    memset(ps_dec->pv_scratch_sps_pps, 0, size);
+
+    size = sizeof(ctxt_inc_mb_info_t);
+    memset(ps_dec->ps_left_mb_ctxt_info, 0, size);
+
+    size = (sizeof(neighbouradd_t) << 2);
+    memset(ps_dec->ps_left_mvpred_addr, 0 ,size);
+
+    size = sizeof(buf_mgr_t) + ithread_get_mutex_lock_size();
+    memset(ps_dec->pv_mv_buf_mgr, 0, size);
 
     /* Free any dynamic buffers that are allocated */
     ih264d_free_dynamic_bufs(ps_dec);","{'deleted_lines': [], 'added_lines': ['    WORD32 size;', '', '    size = sizeof(pred_info_t) * 2 * 32;', '    memset(ps_dec->ps_pred, 0 , size);', '', '    size = sizeof(disp_mgr_t);', '    memset(ps_dec->pv_disp_buf_mgr, 0 , size);', '', '    size = sizeof(buf_mgr_t) + ithread_get_mutex_lock_size();', '    memset(ps_dec->pv_pic_buf_mgr, 0, size);', '', '    size = sizeof(dec_err_status_t);', '    memset(ps_dec->ps_dec_err_status, 0, size);', '', '    size = sizeof(sei);', '    memset(ps_dec->ps_sei, 0, size);', '', '    size = sizeof(dpb_commands_t);', '    memset(ps_dec->ps_dpb_cmds, 0, size);', '', '    size = sizeof(dec_bit_stream_t);', '    memset(ps_dec->ps_bitstrm, 0, size);', '', '    size = sizeof(dec_slice_params_t);', '    memset(ps_dec->ps_cur_slice, 0, size);', '', '    size = MAX(sizeof(dec_seq_params_t), sizeof(dec_pic_params_t));', '    memset(ps_dec->pv_scratch_sps_pps, 0, size);', '', '    size = sizeof(ctxt_inc_mb_info_t);', '    memset(ps_dec->ps_left_mb_ctxt_info, 0, size);', '', '    size = (sizeof(neighbouradd_t) << 2);', '    memset(ps_dec->ps_left_mvpred_addr, 0 ,size);', '', '    size = sizeof(buf_mgr_t) + ithread_get_mutex_lock_size();', '    memset(ps_dec->pv_mv_buf_mgr, 0, size);']}",True,"decoder/ih264d_api.c in mediaserver in Android 6.x before 2016-07-01 does not initialize certain data structures, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 27907656.",9.8,CRITICAL,3,test,,5
CVE-2016-5131,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,chromium,"Delete obsolete XPointer range-to function.

BUG=623378

Review-Url: https://codereview.chromium.org/2127493002
Cr-Commit-Position: refs/heads/master@{#403859}
",b6ad54b72c7f8c422c288dd9c8756d2a15f30e53,https://chromium.googlesource.com/chromium/src/+/b6ad54b72c7f8c422c288dd9c8756d2a15f30e53,third_party/libxml/src/xpath.c,xmlXPathCompPathExpr,"static void
xmlXPathCompPathExpr(xmlXPathParserContextPtr ctxt) {
int lc = 1;           
xmlChar *name = NULL; 
SKIP_BLANKS;
if ((CUR == '$') || (CUR == '(') ||
(IS_ASCII_DIGIT(CUR)) ||
(CUR == '\'') || (CUR == '""') ||
(CUR == '.' && IS_ASCII_DIGIT(NXT(1)))) {
lc = 0;
} else if (CUR == '*') {
lc = 1;
} else if (CUR == '/') {
lc = 1;
} else if (CUR == '@') {
lc = 1;
} else if (CUR == '.') {
lc = 1;
} else {
SKIP_BLANKS;
name = xmlXPathScanName(ctxt);
if ((name != NULL) && (xmlStrstr(name, (xmlChar *) ""::"") != NULL)) {
#ifdef DEBUG_STEP
xmlGenericError(xmlGenericErrorContext,
""PathExpr: Axis\n"");
#endif
lc = 1;
xmlFree(name);
} else if (name != NULL) {
int len =xmlStrlen(name);
while (NXT(len) != 0) {
if (NXT(len) == '/') {
#ifdef DEBUG_STEP
xmlGenericError(xmlGenericErrorContext,
""PathExpr: AbbrRelLocation\n"");
#endif
lc = 1;
break;
} else if (IS_BLANK_CH(NXT(len))) {
;
} else if (NXT(len) == ':') {
#ifdef DEBUG_STEP
xmlGenericError(xmlGenericErrorContext,
""PathExpr: AbbrRelLocation\n"");
#endif
lc = 1;
break;
} else if ((NXT(len) == '(')) {
if (xmlXPathIsNodeType(name)) {
#ifdef DEBUG_STEP
xmlGenericError(xmlGenericErrorContext,
""PathExpr: Type search\n"");
#endif
lc = 1;
} else {
#ifdef DEBUG_STEP
xmlGenericError(xmlGenericErrorContext,
""PathExpr: function call\n"");
#endif
lc = 0;
}
break;
} else if ((NXT(len) == '[')) {
#ifdef DEBUG_STEP
xmlGenericError(xmlGenericErrorContext,
""PathExpr: AbbrRelLocation\n"");
#endif
lc = 1;
break;
} else if ((NXT(len) == '<') || (NXT(len) == '>') ||
(NXT(len) == '=')) {
lc = 1;
break;
} else {
lc = 1;
break;
}
len++;
}
if (NXT(len) == 0) {
#ifdef DEBUG_STEP
xmlGenericError(xmlGenericErrorContext,
""PathExpr: AbbrRelLocation\n"");
#endif
lc = 1;
}
xmlFree(name);
} else {
XP_ERROR(XPATH_EXPR_ERROR);
}
}
if (lc) {
if (CUR == '/') {
PUSH_LEAVE_EXPR(XPATH_OP_ROOT, 0, 0);
} else {
PUSH_LEAVE_EXPR(XPATH_OP_NODE, 0, 0);
}
xmlXPathCompLocationPath(ctxt);
} else {
xmlXPathCompFilterExpr(ctxt);
CHECK_ERROR;
if ((CUR == '/') && (NXT(1) == '/')) {
SKIP(2);
SKIP_BLANKS;
PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,
NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);
PUSH_UNARY_EXPR(XPATH_OP_RESET, ctxt->comp->last, 1, 0);
xmlXPathCompRelativeLocationPath(ctxt);
} else if (CUR == '/') {
xmlXPathCompRelativeLocationPath(ctxt);
}
}
SKIP_BLANKS;
}","static void
xmlXPathCompPathExpr(xmlXPathParserContextPtr VAR_0) {
int VAR_1 = 1;           
xmlChar *VAR_2 = NULL; 
VAR_3;
if ((VAR_4 == '$') || (VAR_4 == '(') ||
(IS_ASCII_DIGIT(VAR_4)) ||
(VAR_4 == '\'') || (VAR_4 == '""') ||
(VAR_4 == '.' && IS_ASCII_DIGIT(NXT(1)))) {
VAR_1 = 0;
} else if (VAR_4 == '*') {
VAR_1 = 1;
} else if (VAR_4 == '/') {
VAR_1 = 1;
} else if (VAR_4 == '@') {
VAR_1 = 1;
} else if (VAR_4 == '.') {
VAR_1 = 1;
} else {
VAR_3;
VAR_2 = xmlXPathScanName(VAR_0);
if ((VAR_2 != NULL) && (xmlStrstr(VAR_2, (xmlChar *) ""::"") != NULL)) {
#ifdef VAR_5
xmlGenericError(VAR_6,
""PathExpr: Axis\n"");
#endif
VAR_1 = 1;
xmlFree(VAR_2);
} else if (VAR_2 != NULL) {
int VAR_7 =xmlStrlen(VAR_2);
while (NXT(VAR_7) != 0) {
if (NXT(VAR_7) == '/') {
#ifdef VAR_5
xmlGenericError(VAR_6,
""PathExpr: AbbrRelLocation\n"");
#endif
VAR_1 = 1;
break;
} else if (IS_BLANK_CH(NXT(VAR_7))) {
;
} else if (NXT(VAR_7) == ':') {
#ifdef VAR_5
xmlGenericError(VAR_6,
""PathExpr: AbbrRelLocation\n"");
#endif
VAR_1 = 1;
break;
} else if ((NXT(VAR_7) == '(')) {
if (xmlXPathIsNodeType(VAR_2)) {
#ifdef VAR_5
xmlGenericError(VAR_6,
""PathExpr: Type search\n"");
#endif
VAR_1 = 1;
} else {
#ifdef VAR_5
xmlGenericError(VAR_6,
""PathExpr: function call\n"");
#endif
VAR_1 = 0;
}
break;
} else if ((NXT(VAR_7) == '[')) {
#ifdef VAR_5
xmlGenericError(VAR_6,
""PathExpr: AbbrRelLocation\n"");
#endif
VAR_1 = 1;
break;
} else if ((NXT(VAR_7) == '<') || (NXT(VAR_7) == '>') ||
(NXT(VAR_7) == '=')) {
VAR_1 = 1;
break;
} else {
VAR_1 = 1;
break;
}
VAR_7++;
}
if (NXT(VAR_7) == 0) {
#ifdef VAR_5
xmlGenericError(VAR_6,
""PathExpr: AbbrRelLocation\n"");
#endif
VAR_1 = 1;
}
xmlFree(VAR_2);
} else {
XP_ERROR(VAR_8);
}
}
if (VAR_1) {
if (VAR_4 == '/') {
PUSH_LEAVE_EXPR(VAR_9, 0, 0);
} else {
PUSH_LEAVE_EXPR(VAR_10, 0, 0);
}
xmlXPathCompLocationPath(VAR_0);
} else {
xmlXPathCompFilterExpr(VAR_0);
VAR_11;
if ((VAR_4 == '/') && (NXT(1) == '/')) {
SKIP(2);
VAR_3;
PUSH_LONG_EXPR(VAR_12, VAR_13,
VAR_14, VAR_15, NULL, NULL);
PUSH_UNARY_EXPR(VAR_16, VAR_0->comp->last, 1, 0);
xmlXPathCompRelativeLocationPath(VAR_0);
} else if (VAR_4 == '/') {
xmlXPathCompRelativeLocationPath(VAR_0);
}
}
VAR_3;
}",chromium/b6ad54b72c7f8c422c288dd9c8756d2a15f30e53/xpath.c/vul/before/0.json,"static void
xmlXPathCompPathExpr(xmlXPathParserContextPtr ctxt) {
    int lc = 1;           /* Should we branch to LocationPath ?         */
    xmlChar *name = NULL; /* we may have to preparse a name to find out */

    SKIP_BLANKS;
    if ((CUR == '$') || (CUR == '(') ||
	(IS_ASCII_DIGIT(CUR)) ||
        (CUR == '\'') || (CUR == '""') ||
	(CUR == '.' && IS_ASCII_DIGIT(NXT(1)))) {
	lc = 0;
    } else if (CUR == '*') {
	/* relative or absolute location path */
	lc = 1;
    } else if (CUR == '/') {
	/* relative or absolute location path */
	lc = 1;
    } else if (CUR == '@') {
	/* relative abbreviated attribute location path */
	lc = 1;
    } else if (CUR == '.') {
	/* relative abbreviated attribute location path */
	lc = 1;
    } else {
	/*
	 * Problem is finding if we have a name here whether it's:
	 *   - a nodetype
	 *   - a function call in which case it's followed by '('
	 *   - an axis in which case it's followed by ':'
	 *   - a element name
	 * We do an a priori analysis here rather than having to
	 * maintain parsed token content through the recursive function
	 * calls. This looks uglier but makes the code easier to
	 * read/write/debug.
	 */
	SKIP_BLANKS;
	name = xmlXPathScanName(ctxt);
	if ((name != NULL) && (xmlStrstr(name, (xmlChar *) ""::"") != NULL)) {
#ifdef DEBUG_STEP
	    xmlGenericError(xmlGenericErrorContext,
		    ""PathExpr: Axis\n"");
#endif
	    lc = 1;
	    xmlFree(name);
	} else if (name != NULL) {
	    int len =xmlStrlen(name);


	    while (NXT(len) != 0) {
		if (NXT(len) == '/') {
		    /* element name */
#ifdef DEBUG_STEP
		    xmlGenericError(xmlGenericErrorContext,
			    ""PathExpr: AbbrRelLocation\n"");
#endif
		    lc = 1;
		    break;
		} else if (IS_BLANK_CH(NXT(len))) {
		    /* ignore blanks */
		    ;
		} else if (NXT(len) == ':') {
#ifdef DEBUG_STEP
		    xmlGenericError(xmlGenericErrorContext,
			    ""PathExpr: AbbrRelLocation\n"");
#endif
		    lc = 1;
		    break;
		} else if ((NXT(len) == '(')) {
		    /* Node Type or Function */
		    if (xmlXPathIsNodeType(name)) {
#ifdef DEBUG_STEP
		        xmlGenericError(xmlGenericErrorContext,
				""PathExpr: Type search\n"");
#endif
			lc = 1;
                    } else if (ctxt->xptr &&
                               xmlStrEqual(name, BAD_CAST ""range-to"")) {
                        lc = 1;
		    } else {
#ifdef DEBUG_STEP
		        xmlGenericError(xmlGenericErrorContext,
				""PathExpr: function call\n"");
#endif
			lc = 0;
		    }
                    break;
		} else if ((NXT(len) == '[')) {
		    /* element name */
#ifdef DEBUG_STEP
		    xmlGenericError(xmlGenericErrorContext,
			    ""PathExpr: AbbrRelLocation\n"");
#endif
		    lc = 1;
		    break;
		} else if ((NXT(len) == '<') || (NXT(len) == '>') ||
			   (NXT(len) == '=')) {
		    lc = 1;
		    break;
		} else {
		    lc = 1;
		    break;
		}
		len++;
	    }
	    if (NXT(len) == 0) {
#ifdef DEBUG_STEP
		xmlGenericError(xmlGenericErrorContext,
			""PathExpr: AbbrRelLocation\n"");
#endif
		/* element name */
		lc = 1;
	    }
	    xmlFree(name);
	} else {
	    /* make sure all cases are covered explicitly */
	    XP_ERROR(XPATH_EXPR_ERROR);
	}
    }

    if (lc) {
	if (CUR == '/') {
	    PUSH_LEAVE_EXPR(XPATH_OP_ROOT, 0, 0);
	} else {
	    PUSH_LEAVE_EXPR(XPATH_OP_NODE, 0, 0);
	}
	xmlXPathCompLocationPath(ctxt);
    } else {
	xmlXPathCompFilterExpr(ctxt);
	CHECK_ERROR;
	if ((CUR == '/') && (NXT(1) == '/')) {
	    SKIP(2);
	    SKIP_BLANKS;

	    PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,
		    NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);
	    PUSH_UNARY_EXPR(XPATH_OP_RESET, ctxt->comp->last, 1, 0);

	    xmlXPathCompRelativeLocationPath(ctxt);
	} else if (CUR == '/') {
	    xmlXPathCompRelativeLocationPath(ctxt);
	}
    }
    SKIP_BLANKS;
}","static void
xmlXPathCompPathExpr(xmlXPathParserContextPtr VAR_0) {
    int VAR_1 = 1;           /* COMMENT_0 */
    xmlChar *VAR_2 = NULL; /* COMMENT_1 */

    VAR_3;
    if ((VAR_4 == '$') || (VAR_4 == '(') ||
	(IS_ASCII_DIGIT(VAR_4)) ||
        (VAR_4 == '\'') || (VAR_4 == '""') ||
	(VAR_4 == '.' && IS_ASCII_DIGIT(NXT(1)))) {
	VAR_1 = 0;
    } else if (VAR_4 == '*') {
	/* COMMENT_2 */
	VAR_1 = 1;
    } else if (VAR_4 == '/') {
	/* COMMENT_2 */
	VAR_1 = 1;
    } else if (VAR_4 == '@') {
	/* COMMENT_3 */
	VAR_1 = 1;
    } else if (VAR_4 == '.') {
	/* COMMENT_3 */
	VAR_1 = 1;
    } else {
	/* COMMENT_4 */
                                                           
                  
                                                          
                                                  
                      
                                                         
                                                                
                                                         
                     
    
	VAR_3;
	VAR_2 = xmlXPathScanName(VAR_0);
	if ((VAR_2 != NULL) && (xmlStrstr(VAR_2, (xmlChar *) ""::"") != NULL)) {
#ifdef VAR_5
	    xmlGenericError(VAR_6,
		    ""PathExpr: Axis\n"");
#endif
	    VAR_1 = 1;
	    xmlFree(VAR_2);
	} else if (VAR_2 != NULL) {
	    int VAR_7 =xmlStrlen(VAR_2);


	    while (NXT(VAR_7) != 0) {
		if (NXT(VAR_7) == '/') {
		    /* COMMENT_15 */
#ifdef VAR_5
		    xmlGenericError(VAR_6,
			    ""PathExpr: AbbrRelLocation\n"");
#endif
		    VAR_1 = 1;
		    break;
		} else if (IS_BLANK_CH(NXT(VAR_7))) {
		    /* COMMENT_16 */
		    ;
		} else if (NXT(VAR_7) == ':') {
#ifdef VAR_5
		    xmlGenericError(VAR_6,
			    ""PathExpr: AbbrRelLocation\n"");
#endif
		    VAR_1 = 1;
		    break;
		} else if ((NXT(VAR_7) == '(')) {
		    /* COMMENT_17 */
		    if (xmlXPathIsNodeType(VAR_2)) {
#ifdef VAR_5
		        xmlGenericError(VAR_6,
				""PathExpr: Type search\n"");
#endif
			VAR_1 = 1;
                    } else if (VAR_0->xptr &&
                               xmlStrEqual(VAR_2, VAR_8 ""range-to"")) {
                        VAR_1 = 1;
		    } else {
#ifdef VAR_5
		        xmlGenericError(VAR_6,
				""PathExpr: function call\n"");
#endif
			VAR_1 = 0;
		    }
                    break;
		} else if ((NXT(VAR_7) == '[')) {
		    /* COMMENT_15 */
#ifdef VAR_5
		    xmlGenericError(VAR_6,
			    ""PathExpr: AbbrRelLocation\n"");
#endif
		    VAR_1 = 1;
		    break;
		} else if ((NXT(VAR_7) == '<') || (NXT(VAR_7) == '>') ||
			   (NXT(VAR_7) == '=')) {
		    VAR_1 = 1;
		    break;
		} else {
		    VAR_1 = 1;
		    break;
		}
		VAR_7++;
	    }
	    if (NXT(VAR_7) == 0) {
#ifdef VAR_5
		xmlGenericError(VAR_6,
			""PathExpr: AbbrRelLocation\n"");
#endif
		/* COMMENT_15 */
		VAR_1 = 1;
	    }
	    xmlFree(VAR_2);
	} else {
	    /* COMMENT_18 */
	    XP_ERROR(VAR_9);
	}
    }

    if (VAR_1) {
	if (VAR_4 == '/') {
	    PUSH_LEAVE_EXPR(VAR_10, 0, 0);
	} else {
	    PUSH_LEAVE_EXPR(VAR_11, 0, 0);
	}
	xmlXPathCompLocationPath(VAR_0);
    } else {
	xmlXPathCompFilterExpr(VAR_0);
	VAR_12;
	if ((VAR_4 == '/') && (NXT(1) == '/')) {
	    SKIP(2);
	    VAR_3;

	    PUSH_LONG_EXPR(VAR_13, VAR_14,
		    VAR_15, VAR_16, NULL, NULL);
	    PUSH_UNARY_EXPR(VAR_17, VAR_0->comp->last, 1, 0);

	    xmlXPathCompRelativeLocationPath(VAR_0);
	} else if (VAR_4 == '/') {
	    xmlXPathCompRelativeLocationPath(VAR_0);
	}
    }
    VAR_3;
}",chromium/b6ad54b72c7f8c422c288dd9c8756d2a15f30e53/xpath.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -66,13 +66,16 @@
 		    lc = 1;
 		    break;
 		} else if ((NXT(len) == '(')) {
-		    /* Note Type or Function */
+		    /* Node Type or Function */
 		    if (xmlXPathIsNodeType(name)) {
 #ifdef DEBUG_STEP
 		        xmlGenericError(xmlGenericErrorContext,
 				""PathExpr: Type search\n"");
 #endif
 			lc = 1;
+                    } else if (ctxt->xptr &&
+                               xmlStrEqual(name, BAD_CAST ""range-to"")) {
+                        lc = 1;
 		    } else {
 #ifdef DEBUG_STEP
 		        xmlGenericError(xmlGenericErrorContext,","{'deleted_lines': ['\t\t    /* Note Type or Function */'], 'added_lines': ['\t\t    /* Node Type or Function */', '                    } else if (ctxt->xptr &&', '                               xmlStrEqual(name, BAD_CAST ""range-to"")) {', '                        lc = 1;']}",True,"Use-after-free vulnerability in libxml2 through 2.9.4, as used in Google Chrome before 52.0.2743.82, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the XPointer range-to function.",8.8,HIGH,2,test,,5
CVE-2016-5131,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,chromium,"Delete obsolete XPointer range-to function.

BUG=623378

Review-Url: https://codereview.chromium.org/2127493002
Cr-Commit-Position: refs/heads/master@{#403859}
",b6ad54b72c7f8c422c288dd9c8756d2a15f30e53,https://chromium.googlesource.com/chromium/src/+/b6ad54b72c7f8c422c288dd9c8756d2a15f30e53,third_party/libxml/src/xpointer.c,xmlXPtrNewContext,"xmlXPathContextPtr
xmlXPtrNewContext(xmlDocPtr doc, xmlNodePtr here, xmlNodePtr origin) {
xmlXPathContextPtr ret;
ret = xmlXPathNewContext(doc);
if (ret == NULL)
return(ret);
ret->xptr = 1;
ret->here = here;
ret->origin = origin;
xmlXPathRegisterFunc(ret, (xmlChar *)""range-to"",
xmlXPtrRangeToFunction);
xmlXPathRegisterFunc(ret, (xmlChar *)""range"",
xmlXPtrRangeFunction);
xmlXPathRegisterFunc(ret, (xmlChar *)""range-inside"",
xmlXPtrRangeInsideFunction);
xmlXPathRegisterFunc(ret, (xmlChar *)""string-range"",
xmlXPtrStringRangeFunction);
xmlXPathRegisterFunc(ret, (xmlChar *)""start-point"",
xmlXPtrStartPointFunction);
xmlXPathRegisterFunc(ret, (xmlChar *)""end-point"",
xmlXPtrEndPointFunction);
xmlXPathRegisterFunc(ret, (xmlChar *)""here"",
xmlXPtrHereFunction);
xmlXPathRegisterFunc(ret, (xmlChar *)"" origin"",
xmlXPtrOriginFunction);
return(ret);
}","xmlXPathContextPtr
xmlXPtrNewContext(xmlDocPtr VAR_0, xmlNodePtr VAR_1, xmlNodePtr VAR_2) {
xmlXPathContextPtr VAR_3;
VAR_3 = xmlXPathNewContext(VAR_0);
if (VAR_3 == NULL)
return(VAR_3);
VAR_3->xptr = 1;
VAR_3->here = VAR_1;
VAR_3->origin = VAR_2;
xmlXPathRegisterFunc(VAR_3, (xmlChar *)""range-to"",
VAR_4);
xmlXPathRegisterFunc(VAR_3, (xmlChar *)""range"",
VAR_5);
xmlXPathRegisterFunc(VAR_3, (xmlChar *)""range-inside"",
VAR_6);
xmlXPathRegisterFunc(VAR_3, (xmlChar *)""string-range"",
VAR_7);
xmlXPathRegisterFunc(VAR_3, (xmlChar *)""start-point"",
VAR_8);
xmlXPathRegisterFunc(VAR_3, (xmlChar *)""end-point"",
VAR_9);
xmlXPathRegisterFunc(VAR_3, (xmlChar *)""here"",
VAR_10);
xmlXPathRegisterFunc(VAR_3, (xmlChar *)"" origin"",
VAR_11);
return(VAR_3);
}",chromium/b6ad54b72c7f8c422c288dd9c8756d2a15f30e53/xpointer.c/vul/before/0.json,"xmlXPathContextPtr
xmlXPtrNewContext(xmlDocPtr doc, xmlNodePtr here, xmlNodePtr origin) {
    xmlXPathContextPtr ret;

    ret = xmlXPathNewContext(doc);
    if (ret == NULL)
	return(ret);
    ret->xptr = 1;
    ret->here = here;
    ret->origin = origin;

    xmlXPathRegisterFunc(ret, (xmlChar *)""range"",
	                 xmlXPtrRangeFunction);
    xmlXPathRegisterFunc(ret, (xmlChar *)""range-inside"",
	                 xmlXPtrRangeInsideFunction);
    xmlXPathRegisterFunc(ret, (xmlChar *)""string-range"",
	                 xmlXPtrStringRangeFunction);
    xmlXPathRegisterFunc(ret, (xmlChar *)""start-point"",
	                 xmlXPtrStartPointFunction);
    xmlXPathRegisterFunc(ret, (xmlChar *)""end-point"",
	                 xmlXPtrEndPointFunction);
    xmlXPathRegisterFunc(ret, (xmlChar *)""here"",
	                 xmlXPtrHereFunction);
    xmlXPathRegisterFunc(ret, (xmlChar *)"" origin"",
	                 xmlXPtrOriginFunction);

    return(ret);
}","xmlXPathContextPtr
xmlXPtrNewContext(xmlDocPtr VAR_0, xmlNodePtr VAR_1, xmlNodePtr VAR_2) {
    xmlXPathContextPtr VAR_3;

    VAR_3 = xmlXPathNewContext(VAR_0);
    if (VAR_3 == NULL)
	return(VAR_3);
    VAR_3->xptr = 1;
    VAR_3->here = VAR_1;
    VAR_3->origin = VAR_2;

    xmlXPathRegisterFunc(VAR_3, (xmlChar *)""range"",
	                 VAR_4);
    xmlXPathRegisterFunc(VAR_3, (xmlChar *)""range-inside"",
	                 VAR_5);
    xmlXPathRegisterFunc(VAR_3, (xmlChar *)""string-range"",
	                 VAR_6);
    xmlXPathRegisterFunc(VAR_3, (xmlChar *)""start-point"",
	                 VAR_7);
    xmlXPathRegisterFunc(VAR_3, (xmlChar *)""end-point"",
	                 VAR_8);
    xmlXPathRegisterFunc(VAR_3, (xmlChar *)""here"",
	                 VAR_9);
    xmlXPathRegisterFunc(VAR_3, (xmlChar *)"" origin"",
	                 VAR_10);

    return(VAR_3);
}",chromium/b6ad54b72c7f8c422c288dd9c8756d2a15f30e53/xpointer.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,8 +9,6 @@
     ret->here = here;
     ret->origin = origin;
 
-    xmlXPathRegisterFunc(ret, (xmlChar *)""range-to"",
-	                 xmlXPtrRangeToFunction);
     xmlXPathRegisterFunc(ret, (xmlChar *)""range"",
 	                 xmlXPtrRangeFunction);
     xmlXPathRegisterFunc(ret, (xmlChar *)""range-inside"",","{'deleted_lines': ['    xmlXPathRegisterFunc(ret, (xmlChar *)""range-to"",', '\t                 xmlXPtrRangeToFunction);'], 'added_lines': []}",True,"Use-after-free vulnerability in libxml2 through 2.9.4, as used in Google Chrome before 52.0.2743.82, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the XPointer range-to function.",8.8,HIGH,2,test,,5
CVE-2016-5131,['CWE-416'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,chromium,"Delete obsolete XPointer range-to function.

BUG=623378

Review-Url: https://codereview.chromium.org/2127493002
Cr-Commit-Position: refs/heads/master@{#403859}
",b6ad54b72c7f8c422c288dd9c8756d2a15f30e53,https://chromium.googlesource.com/chromium/src/+/b6ad54b72c7f8c422c288dd9c8756d2a15f30e53,third_party/libxml/src/xpointer.c,xmlXPtrRangeToFunction,"void
xmlXPtrRangeToFunction(xmlXPathParserContextPtr ctxt, int nargs) {
xmlXPathObjectPtr range;
const xmlChar *cur;
xmlXPathObjectPtr res, obj;
xmlXPathObjectPtr tmp;
xmlLocationSetPtr newset = NULL;
xmlNodeSetPtr oldset;
int i;
if (ctxt == NULL) return;
CHECK_ARITY(1);
CHECK_TYPE(XPATH_NODESET);
obj = valuePop(ctxt);
oldset = obj->nodesetval;
ctxt->context->node = NULL;
cur = ctxt->cur;
newset = xmlXPtrLocationSetCreate(NULL);
for (i = 0; i < oldset->nodeNr; i++) {
ctxt->cur = cur;
ctxt->context->node = oldset->nodeTab[i];
tmp = xmlXPathNewNodeSet(ctxt->context->node);
valuePush(ctxt, tmp);
xmlXPathEvalExpr(ctxt);
CHECK_ERROR;
res = valuePop(ctxt);
range = xmlXPtrNewRangeNodeObject(oldset->nodeTab[i], res);
if (range != NULL) {
xmlXPtrLocationSetAdd(newset, range);
}
if (res != NULL)
xmlXPathFreeObject(res);
if (ctxt->value == tmp) {
res = valuePop(ctxt);
xmlXPathFreeObject(res);
}
ctxt->context->node = NULL;
}
xmlXPathFreeObject(obj);
ctxt->context->node = NULL;
ctxt->context->contextSize = -1;
ctxt->context->proximityPosition = -1;
valuePush(ctxt, xmlXPtrWrapLocationSet(newset));
}","void
xmlXPtrRangeToFunction(xmlXPathParserContextPtr VAR_0, int VAR_1) {
xmlXPathObjectPtr VAR_2;
const xmlChar *VAR_3;
xmlXPathObjectPtr VAR_4, VAR_5;
xmlXPathObjectPtr VAR_6;
xmlLocationSetPtr VAR_7 = NULL;
xmlNodeSetPtr VAR_8;
int VAR_9;
if (VAR_0 == NULL) return;
CHECK_ARITY(1);
CHECK_TYPE(VAR_10);
VAR_5 = valuePop(VAR_0);
VAR_8 = VAR_5->nodesetval;
VAR_0->context->node = NULL;
VAR_3 = VAR_0->cur;
VAR_7 = xmlXPtrLocationSetCreate(NULL);
for (VAR_9 = 0; VAR_9 < VAR_8->nodeNr; VAR_9++) {
VAR_0->cur = VAR_3;
VAR_0->context->node = VAR_8->nodeTab[VAR_9];
VAR_6 = xmlXPathNewNodeSet(VAR_0->context->node);
valuePush(VAR_0, VAR_6);
xmlXPathEvalExpr(VAR_0);
VAR_11;
VAR_4 = valuePop(VAR_0);
VAR_2 = xmlXPtrNewRangeNodeObject(VAR_8->nodeTab[VAR_9], VAR_4);
if (VAR_2 != NULL) {
xmlXPtrLocationSetAdd(VAR_7, VAR_2);
}
if (VAR_4 != NULL)
xmlXPathFreeObject(VAR_4);
if (VAR_0->value == VAR_6) {
VAR_4 = valuePop(VAR_0);
xmlXPathFreeObject(VAR_4);
}
VAR_0->context->node = NULL;
}
xmlXPathFreeObject(VAR_5);
VAR_0->context->node = NULL;
VAR_0->context->contextSize = -1;
VAR_0->context->proximityPosition = -1;
valuePush(VAR_0, xmlXPtrWrapLocationSet(VAR_7));
}",,"void
xmlXPtrRangeToFunction(xmlXPathParserContextPtr ctxt,
                       int nargs ATTRIBUTE_UNUSED) {
    XP_ERROR(XPATH_EXPR_ERROR);
}","void
xmlXPtrRangeToFunction(xmlXPathParserContextPtr VAR_0,
                       int VAR_1 ATTRIBUTE_UNUSED) {
    XP_ERROR(VAR_2);
}",,"--- func_before
+++ func_after
@@ -1,70 +1,5 @@
 void
-xmlXPtrRangeToFunction(xmlXPathParserContextPtr ctxt, int nargs) {
-    xmlXPathObjectPtr range;
-    const xmlChar *cur;
-    xmlXPathObjectPtr res, obj;
-    xmlXPathObjectPtr tmp;
-    xmlLocationSetPtr newset = NULL;
-    xmlNodeSetPtr oldset;
-    int i;
-
-    if (ctxt == NULL) return;
-    CHECK_ARITY(1);
-    /*
-     * Save the expression pointer since we will have to evaluate
-     * it multiple times. Initialize the new set.
-     */
-    CHECK_TYPE(XPATH_NODESET);
-    obj = valuePop(ctxt);
-    oldset = obj->nodesetval;
-    ctxt->context->node = NULL;
-
-    cur = ctxt->cur;
-    newset = xmlXPtrLocationSetCreate(NULL);
-
-    for (i = 0; i < oldset->nodeNr; i++) {
-	ctxt->cur = cur;
-
-	/*
-	 * Run the evaluation with a node list made of a single item
-	 * in the nodeset.
-	 */
-	ctxt->context->node = oldset->nodeTab[i];
-	tmp = xmlXPathNewNodeSet(ctxt->context->node);
-	valuePush(ctxt, tmp);
-
-	xmlXPathEvalExpr(ctxt);
-	CHECK_ERROR;
-
-	/*
-	 * The result of the evaluation need to be tested to
-	 * decided whether the filter succeeded or not
-	 */
-	res = valuePop(ctxt);
-	range = xmlXPtrNewRangeNodeObject(oldset->nodeTab[i], res);
-	if (range != NULL) {
-	    xmlXPtrLocationSetAdd(newset, range);
-	}
-
-	/*
-	 * Cleanup
-	 */
-	if (res != NULL)
-	    xmlXPathFreeObject(res);
-	if (ctxt->value == tmp) {
-	    res = valuePop(ctxt);
-	    xmlXPathFreeObject(res);
-	}
-
-	ctxt->context->node = NULL;
-    }
-
-    /*
-     * The result is used as the new evaluation set.
-     */
-    xmlXPathFreeObject(obj);
-    ctxt->context->node = NULL;
-    ctxt->context->contextSize = -1;
-    ctxt->context->proximityPosition = -1;
-    valuePush(ctxt, xmlXPtrWrapLocationSet(newset));
+xmlXPtrRangeToFunction(xmlXPathParserContextPtr ctxt,
+                       int nargs ATTRIBUTE_UNUSED) {
+    XP_ERROR(XPATH_EXPR_ERROR);
 }","{'deleted_lines': ['xmlXPtrRangeToFunction(xmlXPathParserContextPtr ctxt, int nargs) {', '    xmlXPathObjectPtr range;', '    const xmlChar *cur;', '    xmlXPathObjectPtr res, obj;', '    xmlXPathObjectPtr tmp;', '    xmlLocationSetPtr newset = NULL;', '    xmlNodeSetPtr oldset;', '    int i;', '', '    if (ctxt == NULL) return;', '    CHECK_ARITY(1);', '    /*', '     * Save the expression pointer since we will have to evaluate', '     * it multiple times. Initialize the new set.', '     */', '    CHECK_TYPE(XPATH_NODESET);', '    obj = valuePop(ctxt);', '    oldset = obj->nodesetval;', '    ctxt->context->node = NULL;', '', '    cur = ctxt->cur;', '    newset = xmlXPtrLocationSetCreate(NULL);', '', '    for (i = 0; i < oldset->nodeNr; i++) {', '\tctxt->cur = cur;', '', '\t/*', '\t * Run the evaluation with a node list made of a single item', '\t * in the nodeset.', '\t */', '\tctxt->context->node = oldset->nodeTab[i];', '\ttmp = xmlXPathNewNodeSet(ctxt->context->node);', '\tvaluePush(ctxt, tmp);', '', '\txmlXPathEvalExpr(ctxt);', '\tCHECK_ERROR;', '', '\t/*', '\t * The result of the evaluation need to be tested to', '\t * decided whether the filter succeeded or not', '\t */', '\tres = valuePop(ctxt);', '\trange = xmlXPtrNewRangeNodeObject(oldset->nodeTab[i], res);', '\tif (range != NULL) {', '\t    xmlXPtrLocationSetAdd(newset, range);', '\t}', '', '\t/*', '\t * Cleanup', '\t */', '\tif (res != NULL)', '\t    xmlXPathFreeObject(res);', '\tif (ctxt->value == tmp) {', '\t    res = valuePop(ctxt);', '\t    xmlXPathFreeObject(res);', '\t}', '', '\tctxt->context->node = NULL;', '    }', '', '    /*', '     * The result is used as the new evaluation set.', '     */', '    xmlXPathFreeObject(obj);', '    ctxt->context->node = NULL;', '    ctxt->context->contextSize = -1;', '    ctxt->context->proximityPosition = -1;', '    valuePush(ctxt, xmlXPtrWrapLocationSet(newset));'], 'added_lines': ['xmlXPtrRangeToFunction(xmlXPathParserContextPtr ctxt,', '                       int nargs ATTRIBUTE_UNUSED) {', '    XP_ERROR(XPATH_EXPR_ERROR);']}",True,"Use-after-free vulnerability in libxml2 through 2.9.4, as used in Google Chrome before 52.0.2743.82, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the XPointer range-to function.",8.8,HIGH,2,test,,5
CVE-2016-5133,['CWE-287'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,chromium,"Use correct origin when prompting for proxy authentication.

Since M49, Chrome has been prompting for proxy authentication
credentials using the target origin instead of the origin of the proxy
server. Even if the proxy origin was displayed correctly, a mischievous
network operator could still spoof the proxy server origin. To mitigate
these problems, this CL:

* Fixes the origin used in the proxy authentication login prompt to use
  the origin of the proxy server.

* Indicate if the proxy server connection is insecure.

* Always throw up an interstitial and clear the omnibox when showing a
  proxy auth prompt.

* Use the correct origin when saving proxy authentication credentials.

BUG=613626, 620737

Review-Url: https://codereview.chromium.org/2067933002
Cr-Commit-Position: refs/heads/master@{#400247}
",098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98,https://chromium.googlesource.com/chromium/src/+/098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98,net/base/auth.cc,AuthChallengeInfo::Equals,"bool AuthChallengeInfo::Equals(const AuthChallengeInfo& that) const {
return (this->is_proxy == that.is_proxy &&
this->challenger.Equals(that.challenger) &&
this->scheme == that.scheme &&
this->realm == that.realm);
}","bool AuthChallengeInfo::Equals(const AuthChallengeInfo& VAR_0) const {
return (this->is_proxy == VAR_0.is_proxy &&
this->challenger.Equals(VAR_0.challenger) &&
this->scheme == VAR_0.scheme &&
this->realm == VAR_0.realm);
}",chromium/098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98/auth.cc/vul/before/0.json,"bool AuthChallengeInfo::Equals(const AuthChallengeInfo& that) const {
  return (this->is_proxy == that.is_proxy &&
          this->challenger == that.challenger && this->scheme == that.scheme &&
          this->realm == that.realm);
}","bool AuthChallengeInfo::Equals(const AuthChallengeInfo& VAR_0) const {
  return (this->is_proxy == VAR_0.is_proxy &&
          this->challenger == VAR_0.challenger && this->scheme == VAR_0.scheme &&
          this->realm == VAR_0.realm);
}",chromium/098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98/auth.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,5 @@
 bool AuthChallengeInfo::Equals(const AuthChallengeInfo& that) const {
   return (this->is_proxy == that.is_proxy &&
-          this->challenger.Equals(that.challenger) &&
-          this->scheme == that.scheme &&
+          this->challenger == that.challenger && this->scheme == that.scheme &&
           this->realm == that.realm);
 }","{'deleted_lines': ['          this->challenger.Equals(that.challenger) &&', '          this->scheme == that.scheme &&'], 'added_lines': ['          this->challenger == that.challenger && this->scheme == that.scheme &&']}",True,"Google Chrome before 52.0.2743.82 mishandles origin information during proxy authentication, which allows man-in-the-middle attackers to spoof a proxy-authentication login prompt or trigger incorrect credential storage by modifying the client-server data stream.",5.3,MEDIUM,1,test,,5
CVE-2016-5133,['CWE-287'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,chromium,"Use correct origin when prompting for proxy authentication.

Since M49, Chrome has been prompting for proxy authentication
credentials using the target origin instead of the origin of the proxy
server. Even if the proxy origin was displayed correctly, a mischievous
network operator could still spoof the proxy server origin. To mitigate
these problems, this CL:

* Fixes the origin used in the proxy authentication login prompt to use
  the origin of the proxy server.

* Indicate if the proxy server connection is insecure.

* Always throw up an interstitial and clear the omnibox when showing a
  proxy auth prompt.

* Use the correct origin when saving proxy authentication credentials.

BUG=613626, 620737

Review-Url: https://codereview.chromium.org/2067933002
Cr-Commit-Position: refs/heads/master@{#400247}
",098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98,https://chromium.googlesource.com/chromium/src/+/098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98,chrome/browser/ui/login/login_handler.cc,CreateLoginPrompt,"LoginHandler* CreateLoginPrompt(net::AuthChallengeInfo* auth_info,
net::URLRequest* request) {
bool is_main_frame = (request->load_flags() & net::LOAD_MAIN_FRAME) != 0;
LoginHandler* handler = LoginHandler::Create(auth_info, request);
BrowserThread::PostTask(
BrowserThread::UI, FROM_HERE,
base::Bind(&LoginDialogCallback, request->url(),
base::RetainedRef(auth_info), base::RetainedRef(handler),
is_main_frame));
return handler;
}","LoginHandler* CreateLoginPrompt(net::AuthChallengeInfo* VAR_0,
net::URLRequest* VAR_1) {
bool VAR_2 = (VAR_1->load_flags() & net::LOAD_MAIN_FRAME) != 0;
LoginHandler* VAR_3 = LoginHandler::Create(VAR_0, VAR_1);
BrowserThread::PostTask(
BrowserThread::UI, VAR_4,
base::Bind(&VAR_5, VAR_1->url(),
base::RetainedRef(VAR_0), base::RetainedRef(VAR_3),
VAR_2));
return VAR_3;
}",chromium/098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98/login_handler.cc/vul/before/0.json,"LoginHandler* CreateLoginPrompt(net::AuthChallengeInfo* auth_info,
                                net::URLRequest* request) {
  bool is_main_frame = (request->load_flags() & net::LOAD_MAIN_FRAME) != 0;
  LoginHandler* handler = LoginHandler::Create(auth_info, request);
  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(&LoginHandler::LoginDialogCallback, request->url(),
                 base::RetainedRef(auth_info), base::RetainedRef(handler),
                 is_main_frame));
  return handler;
}","LoginHandler* CreateLoginPrompt(net::AuthChallengeInfo* VAR_0,
                                net::URLRequest* VAR_1) {
  bool VAR_2 = (VAR_1->load_flags() & net::LOAD_MAIN_FRAME) != 0;
  LoginHandler* VAR_3 = LoginHandler::Create(VAR_0, VAR_1);
  BrowserThread::PostTask(
      BrowserThread::UI, VAR_4,
      base::Bind(&LoginHandler::LoginDialogCallback, VAR_1->url(),
                 base::RetainedRef(VAR_0), base::RetainedRef(VAR_3),
                 VAR_2));
  return VAR_3;
}",chromium/098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98/login_handler.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
   LoginHandler* handler = LoginHandler::Create(auth_info, request);
   BrowserThread::PostTask(
       BrowserThread::UI, FROM_HERE,
-      base::Bind(&LoginDialogCallback, request->url(),
+      base::Bind(&LoginHandler::LoginDialogCallback, request->url(),
                  base::RetainedRef(auth_info), base::RetainedRef(handler),
                  is_main_frame));
   return handler;","{'deleted_lines': ['      base::Bind(&LoginDialogCallback, request->url(),'], 'added_lines': ['      base::Bind(&LoginHandler::LoginDialogCallback, request->url(),']}",True,"Google Chrome before 52.0.2743.82 mishandles origin information during proxy authentication, which allows man-in-the-middle attackers to spoof a proxy-authentication login prompt or trigger incorrect credential storage by modifying the client-server data stream.",5.3,MEDIUM,1,test,,5
CVE-2016-5133,['CWE-287'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,chromium,"Use correct origin when prompting for proxy authentication.

Since M49, Chrome has been prompting for proxy authentication
credentials using the target origin instead of the origin of the proxy
server. Even if the proxy origin was displayed correctly, a mischievous
network operator could still spoof the proxy server origin. To mitigate
these problems, this CL:

* Fixes the origin used in the proxy authentication login prompt to use
  the origin of the proxy server.

* Indicate if the proxy server connection is insecure.

* Always throw up an interstitial and clear the omnibox when showing a
  proxy auth prompt.

* Use the correct origin when saving proxy authentication credentials.

BUG=613626, 620737

Review-Url: https://codereview.chromium.org/2067933002
Cr-Commit-Position: refs/heads/master@{#400247}
",098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98,https://chromium.googlesource.com/chromium/src/+/098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98,net/http/http_auth_controller.cc,HttpAuthController::PopulateAuthChallenge,"void HttpAuthController::PopulateAuthChallenge() {
DCHECK(CalledOnValidThread());
auth_info_ = new AuthChallengeInfo;
auth_info_->is_proxy = (target_ == HttpAuth::AUTH_PROXY);
auth_info_->challenger = HostPortPair::FromURL(auth_origin_);
auth_info_->scheme = HttpAuth::SchemeToString(handler_->auth_scheme());
auth_info_->realm = handler_->realm();
}","void HttpAuthController::PopulateAuthChallenge() {
DCHECK(CalledOnValidThread());
VAR_0 = new AuthChallengeInfo;
VAR_0->is_proxy = (VAR_1 == HttpAuth::AUTH_PROXY);
VAR_0->challenger = HostPortPair::FromURL(VAR_2);
VAR_0->scheme = HttpAuth::SchemeToString(VAR_3->auth_scheme());
VAR_0->realm = VAR_3->realm();
}",chromium/098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98/http_auth_controller.cc/vul/before/0.json,"void HttpAuthController::PopulateAuthChallenge() {
  DCHECK(CalledOnValidThread());

  // Populates response_.auth_challenge with the authentication challenge info.
  // This info is consumed by URLRequestHttpJob::GetAuthChallengeInfo().

  auth_info_ = new AuthChallengeInfo;
  auth_info_->is_proxy = (target_ == HttpAuth::AUTH_PROXY);
  auth_info_->challenger = url::Origin(auth_origin_);
  auth_info_->scheme = HttpAuth::SchemeToString(handler_->auth_scheme());
  auth_info_->realm = handler_->realm();
}","void HttpAuthController::PopulateAuthChallenge() {
  DCHECK(CalledOnValidThread());

  /* COMMENT_0 */
  /* COMMENT_1 */

  VAR_0 = new AuthChallengeInfo;
  VAR_0->is_proxy = (VAR_1 == HttpAuth::AUTH_PROXY);
  VAR_0->challenger = url::Origin(VAR_2);
  VAR_0->scheme = HttpAuth::SchemeToString(VAR_3->auth_scheme());
  VAR_0->realm = VAR_3->realm();
}",chromium/098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98/http_auth_controller.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
 
   auth_info_ = new AuthChallengeInfo;
   auth_info_->is_proxy = (target_ == HttpAuth::AUTH_PROXY);
-  auth_info_->challenger = HostPortPair::FromURL(auth_origin_);
+  auth_info_->challenger = url::Origin(auth_origin_);
   auth_info_->scheme = HttpAuth::SchemeToString(handler_->auth_scheme());
   auth_info_->realm = handler_->realm();
 }","{'deleted_lines': ['  auth_info_->challenger = HostPortPair::FromURL(auth_origin_);'], 'added_lines': ['  auth_info_->challenger = url::Origin(auth_origin_);']}",True,"Google Chrome before 52.0.2743.82 mishandles origin information during proxy authentication, which allows man-in-the-middle attackers to spoof a proxy-authentication login prompt or trigger incorrect credential storage by modifying the client-server data stream.",5.3,MEDIUM,1,test,,5
CVE-2016-5133,['CWE-287'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,chromium,"Use correct origin when prompting for proxy authentication.

Since M49, Chrome has been prompting for proxy authentication
credentials using the target origin instead of the origin of the proxy
server. Even if the proxy origin was displayed correctly, a mischievous
network operator could still spoof the proxy server origin. To mitigate
these problems, this CL:

* Fixes the origin used in the proxy authentication login prompt to use
  the origin of the proxy server.

* Indicate if the proxy server connection is insecure.

* Always throw up an interstitial and clear the omnibox when showing a
  proxy auth prompt.

* Use the correct origin when saving proxy authentication credentials.

BUG=613626, 620737

Review-Url: https://codereview.chromium.org/2067933002
Cr-Commit-Position: refs/heads/master@{#400247}
",098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98,https://chromium.googlesource.com/chromium/src/+/098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98,net/url_request/url_request_ftp_job.cc,URLRequestFtpJob::GetAuthChallengeInfo,"void URLRequestFtpJob::GetAuthChallengeInfo(
scoped_refptr<AuthChallengeInfo>* result) {
DCHECK(NeedsAuth());
if (http_response_info_) {
*result = http_response_info_->auth_challenge;
return;
}
scoped_refptr<AuthChallengeInfo> auth_info(new AuthChallengeInfo);
auth_info->is_proxy = false;
auth_info->challenger = HostPortPair::FromURL(request_->url());
DCHECK(auth_info->scheme.empty());
DCHECK(auth_info->realm.empty());
result->swap(auth_info);
}","void URLRequestFtpJob::GetAuthChallengeInfo(
scoped_refptr<AuthChallengeInfo>* VAR_0) {
DCHECK(NeedsAuth());
if (VAR_1) {
*VAR_0 = VAR_1->auth_challenge;
return;
}
scoped_refptr<AuthChallengeInfo> VAR_2(new AuthChallengeInfo);
VAR_2->is_proxy = false;
VAR_2->challenger = HostPortPair::FromURL(VAR_3->url());
DCHECK(VAR_2->scheme.empty());
DCHECK(VAR_2->realm.empty());
VAR_0->swap(VAR_2);
}",chromium/098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98/url_request_ftp_job.cc/vul/before/0.json,"void URLRequestFtpJob::GetAuthChallengeInfo(
    scoped_refptr<AuthChallengeInfo>* result) {
  DCHECK(NeedsAuth());

  if (http_response_info_) {
    *result = http_response_info_->auth_challenge;
    return;
  }

  scoped_refptr<AuthChallengeInfo> auth_info(new AuthChallengeInfo);
  auth_info->is_proxy = false;
  auth_info->challenger = url::Origin(request_->url());
  // scheme and realm are kept empty.
  DCHECK(auth_info->scheme.empty());
  DCHECK(auth_info->realm.empty());
  result->swap(auth_info);
}","void URLRequestFtpJob::GetAuthChallengeInfo(
    scoped_refptr<AuthChallengeInfo>* VAR_0) {
  DCHECK(NeedsAuth());

  if (VAR_1) {
    *VAR_0 = VAR_1->auth_challenge;
    return;
  }

  scoped_refptr<AuthChallengeInfo> VAR_2(new AuthChallengeInfo);
  VAR_2->is_proxy = false;
  VAR_2->challenger = url::Origin(VAR_3->url());
  /* COMMENT_0 */
  DCHECK(VAR_2->scheme.empty());
  DCHECK(VAR_2->realm.empty());
  VAR_0->swap(VAR_2);
}",chromium/098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98/url_request_ftp_job.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,7 +9,7 @@
 
   scoped_refptr<AuthChallengeInfo> auth_info(new AuthChallengeInfo);
   auth_info->is_proxy = false;
-  auth_info->challenger = HostPortPair::FromURL(request_->url());
+  auth_info->challenger = url::Origin(request_->url());
   // scheme and realm are kept empty.
   DCHECK(auth_info->scheme.empty());
   DCHECK(auth_info->realm.empty());","{'deleted_lines': ['  auth_info->challenger = HostPortPair::FromURL(request_->url());'], 'added_lines': ['  auth_info->challenger = url::Origin(request_->url());']}",True,"Google Chrome before 52.0.2743.82 mishandles origin information during proxy authentication, which allows man-in-the-middle attackers to spoof a proxy-authentication login prompt or trigger incorrect credential storage by modifying the client-server data stream.",5.3,MEDIUM,1,test,,5
CVE-2016-5133,['CWE-287'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,chromium,"Use correct origin when prompting for proxy authentication.

Since M49, Chrome has been prompting for proxy authentication
credentials using the target origin instead of the origin of the proxy
server. Even if the proxy origin was displayed correctly, a mischievous
network operator could still spoof the proxy server origin. To mitigate
these problems, this CL:

* Fixes the origin used in the proxy authentication login prompt to use
  the origin of the proxy server.

* Indicate if the proxy server connection is insecure.

* Always throw up an interstitial and clear the omnibox when showing a
  proxy auth prompt.

* Use the correct origin when saving proxy authentication credentials.

BUG=613626, 620737

Review-Url: https://codereview.chromium.org/2067933002
Cr-Commit-Position: refs/heads/master@{#400247}
",098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98,https://chromium.googlesource.com/chromium/src/+/098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98,content/shell/browser/shell_login_dialog.cc,ShellLoginDialog::ShellLoginDialog,"ShellLoginDialog::ShellLoginDialog(
net::AuthChallengeInfo* auth_info,
net::URLRequest* request) : auth_info_(auth_info),
request_(request) {
DCHECK_CURRENTLY_ON(BrowserThread::IO);
BrowserThread::PostTask(
BrowserThread::UI, FROM_HERE,
base::Bind(&ShellLoginDialog::PrepDialog, this,
base::ASCIIToUTF16(auth_info->challenger.ToString()),
base::UTF8ToUTF16(auth_info->realm)));
}","ShellLoginDialog::ShellLoginDialog(
net::AuthChallengeInfo* VAR_0,
net::URLRequest* VAR_1) : auth_info_(VAR_0),
request_(VAR_1) {
DCHECK_CURRENTLY_ON(BrowserThread::IO);
BrowserThread::PostTask(
BrowserThread::UI, VAR_2,
base::Bind(&ShellLoginDialog::PrepDialog, this,
base::ASCIIToUTF16(VAR_0->challenger.ToString()),
base::UTF8ToUTF16(VAR_0->realm)));
}",chromium/098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98/shell_login_dialog.cc/vul/before/0.json,"ShellLoginDialog::ShellLoginDialog(
    net::AuthChallengeInfo* auth_info,
    net::URLRequest* request) : auth_info_(auth_info),
                                request_(request) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(
          &ShellLoginDialog::PrepDialog, this,
          url_formatter::FormatOriginForSecurityDisplay(auth_info->challenger),
          base::UTF8ToUTF16(auth_info->realm)));
}","ShellLoginDialog::ShellLoginDialog(
    net::AuthChallengeInfo* VAR_0,
    net::URLRequest* VAR_1) : auth_info_(VAR_0),
                                request_(VAR_1) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  BrowserThread::PostTask(
      BrowserThread::UI, VAR_2,
      base::Bind(
          &ShellLoginDialog::PrepDialog, this,
          url_formatter::FormatOriginForSecurityDisplay(VAR_0->challenger),
          base::UTF8ToUTF16(VAR_0->realm)));
}",chromium/098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98/shell_login_dialog.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,7 +5,8 @@
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
   BrowserThread::PostTask(
       BrowserThread::UI, FROM_HERE,
-      base::Bind(&ShellLoginDialog::PrepDialog, this,
-                 base::ASCIIToUTF16(auth_info->challenger.ToString()),
-                 base::UTF8ToUTF16(auth_info->realm)));
+      base::Bind(
+          &ShellLoginDialog::PrepDialog, this,
+          url_formatter::FormatOriginForSecurityDisplay(auth_info->challenger),
+          base::UTF8ToUTF16(auth_info->realm)));
 }","{'deleted_lines': ['      base::Bind(&ShellLoginDialog::PrepDialog, this,', '                 base::ASCIIToUTF16(auth_info->challenger.ToString()),', '                 base::UTF8ToUTF16(auth_info->realm)));'], 'added_lines': ['      base::Bind(', '          &ShellLoginDialog::PrepDialog, this,', '          url_formatter::FormatOriginForSecurityDisplay(auth_info->challenger),', '          base::UTF8ToUTF16(auth_info->realm)));']}",True,"Google Chrome before 52.0.2743.82 mishandles origin information during proxy authentication, which allows man-in-the-middle attackers to spoof a proxy-authentication login prompt or trigger incorrect credential storage by modifying the client-server data stream.",5.3,MEDIUM,1,test,,5
CVE-2016-5134,['CWE-200'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,chromium,"Sanitize https:// URLs before sending them to PAC scripts.

This additionally strips the path and query components for https:// URL (embedded identity and reference fragment were already being stripped).

For debugging purposes this behavior can be disabled with the command line flag --unsafe-pac-url.

BUG=593759
R=mmenke@chromium.org

Review URL: https://codereview.chromium.org/1996773002 .

Cr-Commit-Position: refs/heads/master@{#395266}
",81357b39c643fc746517fd6ce5cb2076b7ddc3f4,https://chromium.googlesource.com/chromium/src/+/81357b39c643fc746517fd6ce5cb2076b7ddc3f4,net/proxy/proxy_service.cc,ProxyService::ResolveProxyHelper,"int ProxyService::ResolveProxyHelper(const GURL& raw_url,
const std::string& method,
int load_flags,
ProxyInfo* result,
const CompletionCallback& callback,
PacRequest** pac_request,
ProxyDelegate* proxy_delegate,
const BoundNetLog& net_log) {
DCHECK(CalledOnValidThread());
net_log.BeginEvent(NetLog::TYPE_PROXY_SERVICE);
config_service_->OnLazyPoll();
if (script_poller_.get())
script_poller_->OnLazyPoll();
if (current_state_ == STATE_NONE)
ApplyProxyConfigIfAvailable();
GURL url = SimplifyUrlForRequest(raw_url);
int rv = TryToCompleteSynchronously(url, load_flags, proxy_delegate, result);
if (rv != ERR_IO_PENDING) {
rv = DidFinishResolvingProxy(
url, method, load_flags, proxy_delegate, result, rv, net_log,
callback.is_null() ? TimeTicks() : TimeTicks::Now(), false);
return rv;
}
if (callback.is_null())
return ERR_IO_PENDING;
scoped_refptr<PacRequest> req(new PacRequest(this, url, method, load_flags,
proxy_delegate, result, callback,
net_log));
if (current_state_ == STATE_READY) {
rv = req->Start();
if (rv != ERR_IO_PENDING)
return req->QueryDidComplete(rv);
} else {
req->net_log()->BeginEvent(NetLog::TYPE_PROXY_SERVICE_WAITING_FOR_INIT_PAC);
}
DCHECK_EQ(ERR_IO_PENDING, rv);
DCHECK(!ContainsPendingRequest(req.get()));
pending_requests_.insert(req);
if (pac_request)
*pac_request = req.get();
return rv;  }","int ProxyService::ResolveProxyHelper(const GURL& VAR_0,
const std::string& VAR_1,
int VAR_2,
ProxyInfo* VAR_3,
const CompletionCallback& VAR_4,
PacRequest** VAR_5,
ProxyDelegate* VAR_6,
const BoundNetLog& VAR_7) {
DCHECK(CalledOnValidThread());
VAR_7.BeginEvent(NetLog::TYPE_PROXY_SERVICE);
VAR_8->OnLazyPoll();
if (VAR_9.get())
VAR_9->OnLazyPoll();
if (VAR_10 == VAR_11)
ApplyProxyConfigIfAvailable();
GURL VAR_12 = SimplifyUrlForRequest(VAR_0);
int VAR_13 = TryToCompleteSynchronously(VAR_12, VAR_2, VAR_6, VAR_3);
if (VAR_13 != VAR_14) {
VAR_13 = DidFinishResolvingProxy(
VAR_12, VAR_1, VAR_2, VAR_6, VAR_3, VAR_13, VAR_7,
VAR_4.is_null() ? TimeTicks() : TimeTicks::Now(), false);
return VAR_13;
}
if (VAR_4.is_null())
return VAR_14;
scoped_refptr<PacRequest> VAR_15(new PacRequest(this, VAR_12, VAR_1, VAR_2,
VAR_6, VAR_3, VAR_4,
VAR_7));
if (VAR_10 == VAR_16) {
VAR_13 = VAR_15->Start();
if (VAR_13 != VAR_14)
return VAR_15->QueryDidComplete(VAR_13);
} else {
VAR_15->net_log()->BeginEvent(NetLog::TYPE_PROXY_SERVICE_WAITING_FOR_INIT_PAC);
}
DCHECK_EQ(VAR_14, VAR_13);
DCHECK(!ContainsPendingRequest(VAR_15.get()));
VAR_17.insert(VAR_15);
if (VAR_5)
*VAR_5 = VAR_15.get();
return VAR_13;  
}",chromium/81357b39c643fc746517fd6ce5cb2076b7ddc3f4/proxy_service.cc/vul/before/0.json,"int ProxyService::ResolveProxyHelper(const GURL& raw_url,
                                     const std::string& method,
                                     int load_flags,
                                     ProxyInfo* result,
                                     const CompletionCallback& callback,
                                     PacRequest** pac_request,
                                     ProxyDelegate* proxy_delegate,
                                     const BoundNetLog& net_log) {
  DCHECK(CalledOnValidThread());

  net_log.BeginEvent(NetLog::TYPE_PROXY_SERVICE);

  // Notify our polling-based dependencies that a resolve is taking place.
  // This way they can schedule their polls in response to network activity.
  config_service_->OnLazyPoll();
  if (script_poller_.get())
     script_poller_->OnLazyPoll();

  if (current_state_ == STATE_NONE)
    ApplyProxyConfigIfAvailable();

  // Sanitize the URL before passing it on to the proxy resolver (i.e. PAC
  // script). The goal is to remove sensitive data (like embedded user names
  // and password), and local data (i.e. reference fragment) which does not need
  // to be disclosed to the resolver.
  GURL url = SanitizeUrl(raw_url, sanitize_url_policy_);

  // Check if the request can be completed right away. (This is the case when
  // using a direct connection for example).
  int rv = TryToCompleteSynchronously(url, load_flags, proxy_delegate, result);
  if (rv != ERR_IO_PENDING) {
    rv = DidFinishResolvingProxy(
        url, method, load_flags, proxy_delegate, result, rv, net_log,
        callback.is_null() ? TimeTicks() : TimeTicks::Now(), false);
    return rv;
  }

  if (callback.is_null())
    return ERR_IO_PENDING;

  scoped_refptr<PacRequest> req(new PacRequest(this, url, method, load_flags,
                                               proxy_delegate, result, callback,
                                               net_log));

  if (current_state_ == STATE_READY) {
    // Start the resolve request.
    rv = req->Start();
    if (rv != ERR_IO_PENDING)
      return req->QueryDidComplete(rv);
  } else {
    req->net_log()->BeginEvent(NetLog::TYPE_PROXY_SERVICE_WAITING_FOR_INIT_PAC);
  }

  DCHECK_EQ(ERR_IO_PENDING, rv);
  DCHECK(!ContainsPendingRequest(req.get()));
  pending_requests_.insert(req);

  // Completion will be notified through |callback|, unless the caller cancels
  // the request using |pac_request|.
  if (pac_request)
    *pac_request = req.get();
  return rv;  // ERR_IO_PENDING
}","int ProxyService::ResolveProxyHelper(const GURL& VAR_0,
                                     const std::string& VAR_1,
                                     int VAR_2,
                                     ProxyInfo* VAR_3,
                                     const CompletionCallback& VAR_4,
                                     PacRequest** VAR_5,
                                     ProxyDelegate* VAR_6,
                                     const BoundNetLog& VAR_7) {
  DCHECK(CalledOnValidThread());

  VAR_7.BeginEvent(NetLog::TYPE_PROXY_SERVICE);

  /* COMMENT_0 */
  /* COMMENT_1 */
  VAR_8->OnLazyPoll();
  if (VAR_9.get())
     VAR_9->OnLazyPoll();

  if (VAR_10 == VAR_11)
    ApplyProxyConfigIfAvailable();

  /* COMMENT_2 */
  /* COMMENT_3 */
  /* COMMENT_4 */
  /* COMMENT_5 */
  GURL VAR_12 = SanitizeUrl(VAR_0, VAR_13);

  /* COMMENT_6 */
  /* COMMENT_7 */
  int VAR_14 = TryToCompleteSynchronously(VAR_12, VAR_2, VAR_6, VAR_3);
  if (VAR_14 != VAR_15) {
    VAR_14 = DidFinishResolvingProxy(
        VAR_12, VAR_1, VAR_2, VAR_6, VAR_3, VAR_14, VAR_7,
        VAR_4.is_null() ? TimeTicks() : TimeTicks::Now(), false);
    return VAR_14;
  }

  if (VAR_4.is_null())
    return VAR_15;

  scoped_refptr<PacRequest> VAR_16(new PacRequest(this, VAR_12, VAR_1, VAR_2,
                                               VAR_6, VAR_3, VAR_4,
                                               VAR_7));

  if (VAR_10 == VAR_17) {
    /* COMMENT_8 */
    VAR_14 = VAR_16->Start();
    if (VAR_14 != VAR_15)
      return VAR_16->QueryDidComplete(VAR_14);
  } else {
    VAR_16->net_log()->BeginEvent(NetLog::TYPE_PROXY_SERVICE_WAITING_FOR_INIT_PAC);
  }

  DCHECK_EQ(VAR_15, VAR_14);
  DCHECK(!ContainsPendingRequest(VAR_16.get()));
  VAR_18.insert(VAR_16);

  /* COMMENT_9 */
  /* COMMENT_10 */
  if (VAR_5)
    *VAR_5 = VAR_16.get();
  return VAR_14;  /* COMMENT_11 */
}",chromium/81357b39c643fc746517fd6ce5cb2076b7ddc3f4/proxy_service.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -19,9 +19,11 @@
   if (current_state_ == STATE_NONE)
     ApplyProxyConfigIfAvailable();
 
-  // Strip away any reference fragments and the username/password, as they
-  // are not relevant to proxy resolution.
-  GURL url = SimplifyUrlForRequest(raw_url);
+  // Sanitize the URL before passing it on to the proxy resolver (i.e. PAC
+  // script). The goal is to remove sensitive data (like embedded user names
+  // and password), and local data (i.e. reference fragment) which does not need
+  // to be disclosed to the resolver.
+  GURL url = SanitizeUrl(raw_url, sanitize_url_policy_);
 
   // Check if the request can be completed right away. (This is the case when
   // using a direct connection for example).","{'deleted_lines': ['  // Strip away any reference fragments and the username/password, as they', '  // are not relevant to proxy resolution.', '  GURL url = SimplifyUrlForRequest(raw_url);'], 'added_lines': ['  // Sanitize the URL before passing it on to the proxy resolver (i.e. PAC', '  // script). The goal is to remove sensitive data (like embedded user names', '  // and password), and local data (i.e. reference fragment) which does not need', '  // to be disclosed to the resolver.', '  GURL url = SanitizeUrl(raw_url, sanitize_url_policy_);']}",True,"net/proxy/proxy_service.cc in the Proxy Auto-Config (PAC) feature in Google Chrome before 52.0.2743.82 does not ensure that URL information is restricted to a scheme, host, and port, which allows remote attackers to discover credentials by operating a server with a PAC script, a related issue to CVE-2016-3763.",8.8,HIGH,2,test,,5
CVE-2016-5134,['CWE-200'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,chromium,"Sanitize https:// URLs before sending them to PAC scripts.

This additionally strips the path and query components for https:// URL (embedded identity and reference fragment were already being stripped).

For debugging purposes this behavior can be disabled with the command line flag --unsafe-pac-url.

BUG=593759
R=mmenke@chromium.org

Review URL: https://codereview.chromium.org/1996773002 .

Cr-Commit-Position: refs/heads/master@{#395266}
",81357b39c643fc746517fd6ce5cb2076b7ddc3f4,https://chromium.googlesource.com/chromium/src/+/81357b39c643fc746517fd6ce5cb2076b7ddc3f4,net/proxy/proxy_service.cc,ProxyService::ProxyService,"ProxyService::ProxyService(
std::unique_ptr<ProxyConfigService> config_service,
std::unique_ptr<ProxyResolverFactory> resolver_factory,
NetLog* net_log)
: resolver_factory_(std::move(resolver_factory)),
next_config_id_(1),
current_state_(STATE_NONE),
net_log_(net_log),
stall_proxy_auto_config_delay_(
TimeDelta::FromMilliseconds(kDelayAfterNetworkChangesMs)),
quick_check_enabled_(true) {
NetworkChangeNotifier::AddIPAddressObserver(this);
NetworkChangeNotifier::AddDNSObserver(this);
ResetConfigService(std::move(config_service));
}","ProxyService::ProxyService(
std::unique_ptr<VAR_0> VAR_1,
std::unique_ptr<ProxyResolverFactory> VAR_2,
NetLog* VAR_3)
: resolver_factory_(std::move(VAR_2)),
next_config_id_(1),
current_state_(VAR_4),
net_log_(VAR_3),
stall_proxy_auto_config_delay_(
TimeDelta::FromMilliseconds(VAR_5)),
quick_check_enabled_(true) {
NetworkChangeNotifier::AddIPAddressObserver(this);
NetworkChangeNotifier::AddDNSObserver(this);
ResetConfigService(std::move(VAR_1));
}",chromium/81357b39c643fc746517fd6ce5cb2076b7ddc3f4/proxy_service.cc/vul/before/1.json,"ProxyService::ProxyService(
    std::unique_ptr<ProxyConfigService> config_service,
    std::unique_ptr<ProxyResolverFactory> resolver_factory,
    NetLog* net_log)
    : resolver_factory_(std::move(resolver_factory)),
      next_config_id_(1),
      current_state_(STATE_NONE),
      net_log_(net_log),
      stall_proxy_auto_config_delay_(
          TimeDelta::FromMilliseconds(kDelayAfterNetworkChangesMs)),
      quick_check_enabled_(true),
      sanitize_url_policy_(SanitizeUrlPolicy::SAFE) {
  NetworkChangeNotifier::AddIPAddressObserver(this);
  NetworkChangeNotifier::AddDNSObserver(this);
  ResetConfigService(std::move(config_service));
}","ProxyService::ProxyService(
    std::unique_ptr<VAR_0> VAR_1,
    std::unique_ptr<ProxyResolverFactory> VAR_2,
    NetLog* VAR_3)
    : resolver_factory_(std::move(VAR_2)),
      next_config_id_(1),
      current_state_(VAR_4),
      net_log_(VAR_3),
      stall_proxy_auto_config_delay_(
          TimeDelta::FromMilliseconds(VAR_5)),
      quick_check_enabled_(true),
      sanitize_url_policy_(SanitizeUrlPolicy::SAFE) {
  NetworkChangeNotifier::AddIPAddressObserver(this);
  NetworkChangeNotifier::AddDNSObserver(this);
  ResetConfigService(std::move(VAR_1));
}",chromium/81357b39c643fc746517fd6ce5cb2076b7ddc3f4/proxy_service.cc/vul/after/1.json,"--- func_before
+++ func_after
@@ -8,7 +8,8 @@
       net_log_(net_log),
       stall_proxy_auto_config_delay_(
           TimeDelta::FromMilliseconds(kDelayAfterNetworkChangesMs)),
-      quick_check_enabled_(true) {
+      quick_check_enabled_(true),
+      sanitize_url_policy_(SanitizeUrlPolicy::SAFE) {
   NetworkChangeNotifier::AddIPAddressObserver(this);
   NetworkChangeNotifier::AddDNSObserver(this);
   ResetConfigService(std::move(config_service));","{'deleted_lines': ['      quick_check_enabled_(true) {'], 'added_lines': ['      quick_check_enabled_(true),', '      sanitize_url_policy_(SanitizeUrlPolicy::SAFE) {']}",True,"net/proxy/proxy_service.cc in the Proxy Auto-Config (PAC) feature in Google Chrome before 52.0.2743.82 does not ensure that URL information is restricted to a scheme, host, and port, which allows remote attackers to discover credentials by operating a server with a PAC script, a related issue to CVE-2016-3763.",8.8,HIGH,2,test,,5
CVE-2016-5134,['CWE-200'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,chromium,"Sanitize https:// URLs before sending them to PAC scripts.

This additionally strips the path and query components for https:// URL (embedded identity and reference fragment were already being stripped).

For debugging purposes this behavior can be disabled with the command line flag --unsafe-pac-url.

BUG=593759
R=mmenke@chromium.org

Review URL: https://codereview.chromium.org/1996773002 .

Cr-Commit-Position: refs/heads/master@{#395266}
",81357b39c643fc746517fd6ce5cb2076b7ddc3f4,https://chromium.googlesource.com/chromium/src/+/81357b39c643fc746517fd6ce5cb2076b7ddc3f4,chrome/browser/net/proxy_service_factory.cc,ProxyServiceFactory::CreateProxyService,"std::unique_ptr<net::ProxyService> ProxyServiceFactory::CreateProxyService(
net::NetLog* net_log,
net::URLRequestContext* context,
net::NetworkDelegate* network_delegate,
std::unique_ptr<net::ProxyConfigService> proxy_config_service,
const base::CommandLine& command_line,
bool quick_check_enabled) {
DCHECK_CURRENTLY_ON(BrowserThread::IO);
bool use_v8 = !command_line.HasSwitch(switches::kWinHttpProxyResolver);
if (use_v8 && command_line.HasSwitch(switches::kSingleProcess)) {
LOG(ERROR) << ""Cannot use V8 Proxy resolver in single process mode."";
use_v8 = false;    }
size_t num_pac_threads = 0u;  
if (command_line.HasSwitch(switches::kNumPacThreads)) {
std::string s = command_line.GetSwitchValueASCII(switches::kNumPacThreads);
int n;
if (base::StringToInt(s, &n) && n > 0) {
num_pac_threads = static_cast<size_t>(n);
} else {
LOG(ERROR) << ""Invalid switch for number of PAC threads: "" << s;
}
}
std::unique_ptr<net::ProxyService> proxy_service;
if (use_v8) {
std::unique_ptr<net::DhcpProxyScriptFetcher> dhcp_proxy_script_fetcher;
#if defined(OS_CHROMEOS)
dhcp_proxy_script_fetcher.reset(
new chromeos::DhcpProxyScriptFetcherChromeos(context));
#else
net::DhcpProxyScriptFetcherFactory dhcp_factory;
dhcp_proxy_script_fetcher = dhcp_factory.Create(context);
#endif
#if !defined(OS_ANDROID)
if (command_line.HasSwitch(switches::kV8PacMojoInProcess)) {
proxy_service = net::CreateProxyServiceUsingMojoInProcess(
std::move(proxy_config_service),
new net::ProxyScriptFetcherImpl(context),
std::move(dhcp_proxy_script_fetcher), context->host_resolver(),
net_log, network_delegate);
} else if (EnableOutOfProcessV8Pac(command_line)) {
proxy_service = net::CreateProxyServiceUsingMojoFactory(
UtilityProcessMojoProxyResolverFactory::GetInstance(),
std::move(proxy_config_service),
new net::ProxyScriptFetcherImpl(context),
std::move(dhcp_proxy_script_fetcher), context->host_resolver(),
net_log, network_delegate);
}
#endif  
if (!proxy_service) {
proxy_service = net::CreateProxyServiceUsingV8ProxyResolver(
std::move(proxy_config_service),
new net::ProxyScriptFetcherImpl(context),
std::move(dhcp_proxy_script_fetcher), context->host_resolver(),
net_log, network_delegate);
}
} else {
proxy_service = net::ProxyService::CreateUsingSystemProxyResolver(
std::move(proxy_config_service), num_pac_threads, net_log);
}
proxy_service->set_quick_check_enabled(quick_check_enabled);
return proxy_service;
}","std::unique_ptr<net::ProxyService> ProxyServiceFactory::CreateProxyService(
net::NetLog* VAR_0,
net::URLRequestContext* VAR_1,
net::NetworkDelegate* VAR_2,
std::unique_ptr<net::ProxyConfigService> VAR_3,
const base::CommandLine& VAR_4,
bool VAR_5) {
DCHECK_CURRENTLY_ON(BrowserThread::IO);
bool VAR_6 = !VAR_4.HasSwitch(switches::kWinHttpProxyResolver);
if (VAR_6 && VAR_4.HasSwitch(switches::kSingleProcess)) {
LOG(VAR_7) << ""Cannot use V8 Proxy resolver in single process mode."";
VAR_6 = false;  
}
size_t VAR_8 = 0u;  
if (VAR_4.HasSwitch(switches::kNumPacThreads)) {
std::string VAR_9 = VAR_4.GetSwitchValueASCII(switches::kNumPacThreads);
int VAR_10;
if (base::StringToInt(VAR_9, &VAR_10) && VAR_10 > 0) {
VAR_8 = VAR_11<size_t>(VAR_10);
} else {
LOG(VAR_7) << ""Invalid switch for number of PAC threads: "" << VAR_9;
}
}
std::unique_ptr<net::ProxyService> VAR_12;
if (VAR_6) {
std::unique_ptr<net::DhcpProxyScriptFetcher> VAR_13;
#if defined(VAR_14)
VAR_13.reset(
new chromeos::DhcpProxyScriptFetcherChromeos(VAR_1));
#else
net::DhcpProxyScriptFetcherFactory VAR_15;
VAR_13 = VAR_15.Create(VAR_1);
#endif
#if !defined(VAR_16)
if (VAR_4.HasSwitch(switches::kV8PacMojoInProcess)) {
VAR_12 = net::CreateProxyServiceUsingMojoInProcess(
std::move(VAR_3),
new net::ProxyScriptFetcherImpl(VAR_1),
std::move(VAR_13), VAR_1->host_resolver(),
VAR_0, VAR_2);
} else if (EnableOutOfProcessV8Pac(VAR_4)) {
VAR_12 = net::CreateProxyServiceUsingMojoFactory(
UtilityProcessMojoProxyResolverFactory::GetInstance(),
std::move(VAR_3),
new net::ProxyScriptFetcherImpl(VAR_1),
std::move(VAR_13), VAR_1->host_resolver(),
VAR_0, VAR_2);
}
#endif  
if (!VAR_12) {
VAR_12 = net::CreateProxyServiceUsingV8ProxyResolver(
std::move(VAR_3),
new net::ProxyScriptFetcherImpl(VAR_1),
std::move(VAR_13), VAR_1->host_resolver(),
VAR_0, VAR_2);
}
} else {
VAR_12 = net::ProxyService::CreateUsingSystemProxyResolver(
std::move(VAR_3), VAR_8, VAR_0);
}
VAR_12->set_quick_check_enabled(VAR_5);
return VAR_12;
}",chromium/81357b39c643fc746517fd6ce5cb2076b7ddc3f4/proxy_service_factory.cc/vul/before/0.json,"std::unique_ptr<net::ProxyService> ProxyServiceFactory::CreateProxyService(
    net::NetLog* net_log,
    net::URLRequestContext* context,
    net::NetworkDelegate* network_delegate,
    std::unique_ptr<net::ProxyConfigService> proxy_config_service,
    const base::CommandLine& command_line,
    bool quick_check_enabled) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  bool use_v8 = !command_line.HasSwitch(switches::kWinHttpProxyResolver);
  // TODO(eroman): Figure out why this doesn't work in single-process mode.
  // Should be possible now that a private isolate is used.
  // http://crbug.com/474654
  if (use_v8 && command_line.HasSwitch(switches::kSingleProcess)) {
    LOG(ERROR) << ""Cannot use V8 Proxy resolver in single process mode."";
    use_v8 = false;  // Fallback to non-v8 implementation.
  }

  size_t num_pac_threads = 0u;  // Use default number of threads.

  // Check the command line for an override on the number of proxy resolver
  // threads to use.
  if (command_line.HasSwitch(switches::kNumPacThreads)) {
    std::string s = command_line.GetSwitchValueASCII(switches::kNumPacThreads);

    // Parse the switch (it should be a positive integer formatted as decimal).
    int n;
    if (base::StringToInt(s, &n) && n > 0) {
      num_pac_threads = static_cast<size_t>(n);
    } else {
      LOG(ERROR) << ""Invalid switch for number of PAC threads: "" << s;
    }
  }

  std::unique_ptr<net::ProxyService> proxy_service;
  if (use_v8) {
    std::unique_ptr<net::DhcpProxyScriptFetcher> dhcp_proxy_script_fetcher;
#if defined(OS_CHROMEOS)
    dhcp_proxy_script_fetcher.reset(
        new chromeos::DhcpProxyScriptFetcherChromeos(context));
#else
    net::DhcpProxyScriptFetcherFactory dhcp_factory;
    dhcp_proxy_script_fetcher = dhcp_factory.Create(context);
#endif

#if !defined(OS_ANDROID)
    // In-process Mojo PAC can only be set on the command line, so its presence
    // should override other options.
    if (command_line.HasSwitch(switches::kV8PacMojoInProcess)) {
      proxy_service = net::CreateProxyServiceUsingMojoInProcess(
          std::move(proxy_config_service),
          new net::ProxyScriptFetcherImpl(context),
          std::move(dhcp_proxy_script_fetcher), context->host_resolver(),
          net_log, network_delegate);
    } else if (EnableOutOfProcessV8Pac(command_line)) {
      proxy_service = net::CreateProxyServiceUsingMojoFactory(
          UtilityProcessMojoProxyResolverFactory::GetInstance(),
          std::move(proxy_config_service),
          new net::ProxyScriptFetcherImpl(context),
          std::move(dhcp_proxy_script_fetcher), context->host_resolver(),
          net_log, network_delegate);
    }
#endif  // !defined(OS_ANDROID)

    if (!proxy_service) {
      proxy_service = net::CreateProxyServiceUsingV8ProxyResolver(
          std::move(proxy_config_service),
          new net::ProxyScriptFetcherImpl(context),
          std::move(dhcp_proxy_script_fetcher), context->host_resolver(),
          net_log, network_delegate);
    }
  } else {
    proxy_service = net::ProxyService::CreateUsingSystemProxyResolver(
        std::move(proxy_config_service), num_pac_threads, net_log);
  }

  proxy_service->set_quick_check_enabled(quick_check_enabled);

  if (command_line.HasSwitch(switches::kUnsafePacUrl)) {
    proxy_service->set_sanitize_url_policy(
        net::ProxyService::SanitizeUrlPolicy::UNSAFE);
  }

  return proxy_service;
}","std::unique_ptr<net::ProxyService> ProxyServiceFactory::CreateProxyService(
    net::NetLog* VAR_0,
    net::URLRequestContext* VAR_1,
    net::NetworkDelegate* VAR_2,
    std::unique_ptr<net::ProxyConfigService> VAR_3,
    const base::CommandLine& VAR_4,
    bool VAR_5) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  bool VAR_6 = !VAR_4.HasSwitch(switches::kWinHttpProxyResolver);
  /* COMMENT_0 */
  /* COMMENT_1 */
  /* COMMENT_2 */
  if (VAR_6 && VAR_4.HasSwitch(switches::kSingleProcess)) {
    LOG(VAR_7) << ""Cannot use V8 Proxy resolver in single process mode."";
    VAR_6 = false;  /* COMMENT_3 */
  }

  size_t VAR_8 = 0u;  /* COMMENT_4 */

  /* COMMENT_5 */
  /* COMMENT_6 */
  if (VAR_4.HasSwitch(switches::kNumPacThreads)) {
    std::string VAR_9 = VAR_4.GetSwitchValueASCII(switches::kNumPacThreads);

    /* COMMENT_7 */
    int VAR_10;
    if (base::StringToInt(VAR_9, &VAR_10) && VAR_10 > 0) {
      VAR_8 = VAR_11<size_t>(VAR_10);
    } else {
      LOG(VAR_7) << ""Invalid switch for number of PAC threads: "" << VAR_9;
    }
  }

  std::unique_ptr<net::ProxyService> VAR_12;
  if (VAR_6) {
    std::unique_ptr<net::DhcpProxyScriptFetcher> VAR_13;
#if defined(VAR_14)
    VAR_13.reset(
        new chromeos::DhcpProxyScriptFetcherChromeos(VAR_1));
#else
    net::DhcpProxyScriptFetcherFactory VAR_15;
    VAR_13 = VAR_15.Create(VAR_1);
#endif

#if !defined(VAR_16)
    /* COMMENT_8 */
    /* COMMENT_9 */
    if (VAR_4.HasSwitch(switches::kV8PacMojoInProcess)) {
      VAR_12 = net::CreateProxyServiceUsingMojoInProcess(
          std::move(VAR_3),
          new net::ProxyScriptFetcherImpl(VAR_1),
          std::move(VAR_13), VAR_1->host_resolver(),
          VAR_0, VAR_2);
    } else if (EnableOutOfProcessV8Pac(VAR_4)) {
      VAR_12 = net::CreateProxyServiceUsingMojoFactory(
          UtilityProcessMojoProxyResolverFactory::GetInstance(),
          std::move(VAR_3),
          new net::ProxyScriptFetcherImpl(VAR_1),
          std::move(VAR_13), VAR_1->host_resolver(),
          VAR_0, VAR_2);
    }
#endif  /* COMMENT_10 */

    if (!VAR_12) {
      VAR_12 = net::CreateProxyServiceUsingV8ProxyResolver(
          std::move(VAR_3),
          new net::ProxyScriptFetcherImpl(VAR_1),
          std::move(VAR_13), VAR_1->host_resolver(),
          VAR_0, VAR_2);
    }
  } else {
    VAR_12 = net::ProxyService::CreateUsingSystemProxyResolver(
        std::move(VAR_3), VAR_8, VAR_0);
  }

  VAR_12->set_quick_check_enabled(VAR_5);

  if (VAR_4.HasSwitch(switches::kUnsafePacUrl)) {
    VAR_12->set_sanitize_url_policy(
        net::ProxyService::SanitizeUrlPolicy::UNSAFE);
  }

  return VAR_12;
}",chromium/81357b39c643fc746517fd6ce5cb2076b7ddc3f4/proxy_service_factory.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -75,5 +75,10 @@
 
   proxy_service->set_quick_check_enabled(quick_check_enabled);
 
+  if (command_line.HasSwitch(switches::kUnsafePacUrl)) {
+    proxy_service->set_sanitize_url_policy(
+        net::ProxyService::SanitizeUrlPolicy::UNSAFE);
+  }
+
   return proxy_service;
 }","{'deleted_lines': [], 'added_lines': ['  if (command_line.HasSwitch(switches::kUnsafePacUrl)) {', '    proxy_service->set_sanitize_url_policy(', '        net::ProxyService::SanitizeUrlPolicy::UNSAFE);', '  }', '']}",True,"net/proxy/proxy_service.cc in the Proxy Auto-Config (PAC) feature in Google Chrome before 52.0.2743.82 does not ensure that URL information is restricted to a scheme, host, and port, which allows remote attackers to discover credentials by operating a server with a PAC script, a related issue to CVE-2016-3763.",8.8,HIGH,2,test,,5
CVE-2016-3837,['CWE-200'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,android,"Deal correctly with short strings

The parseMacAddress function anticipates only properly formed
MAC addresses (6 hexadecimal octets separated by "":"").  This
change properly deals with situations where the string is
shorter than expected, making sure that the passed in char*
reference in parseHexByte never exceeds the end of the string.

BUG: 28164077
TEST: Added a main function:

int main(int argc, char **argv) {
   unsigned char addr[6];
   if (argc > 1) {
      memset(addr, 0, sizeof(addr));
      parseMacAddress(argv[1], addr);
      printf(""Result: %02x:%02x:%02x:%02x:%02x:%02x\n"",
              addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
   }
}

Tested with """", ""a"" ""ab"" ""ab:c"" ""abxc"".

Change-Id: I0db8d0037e48b62333d475296a45b22ab0efe386
",a209ff12ba9617c10550678ff93d01fb72a33399,https://android.googlesource.com/platform/frameworks/opt/net/wifi/+/a209ff12ba9617c10550678ff93d01fb72a33399,service/jni/com_android_server_wifi_WifiNative.cpp,parseHexByte,"static byte parseHexByte(const char * &str) {
byte b = parseHexChar(str[0]);
if (str[1] == ':' || str[1] == '\0') {
str += 2;
return b;
} else {
b = b << 4 | parseHexChar(str[1]);
str += 3;
return b;
}
}","static byte parseHexByte(const char * &VAR_0) {
byte VAR_1 = parseHexChar(VAR_0[0]);
if (VAR_0[1] == ':' || VAR_0[1] == '\0') {
VAR_0 += 2;
return VAR_1;
} else {
VAR_1 = VAR_1 << 4 | parseHexChar(VAR_0[1]);
VAR_0 += 3;
return VAR_1;
}
}",android/a209ff12ba9617c10550678ff93d01fb72a33399/com_android_server_wifi_WifiNative.cpp/vul/before/0.json,"static byte parseHexByte(const char * &str) {
    if (str[0] == '\0') {
        ALOGE(""Passed an empty string"");
        return 0;
    }
    byte b = parseHexChar(str[0]);
    if (str[1] == '\0' || str[1] == ':') {
        str ++;
    } else {
        b = b << 4 | parseHexChar(str[1]);
        str += 2;
    }

    // Skip trailing delimiter if not at the end of the string.
    if (str[0] != '\0') {
        str++;
    }
    return b;
}","static byte parseHexByte(const char * &VAR_0) {
    if (VAR_0[0] == '\0') {
        ALOGE(""Passed an empty string"");
        return 0;
    }
    byte VAR_1 = parseHexChar(VAR_0[0]);
    if (VAR_0[1] == '\0' || VAR_0[1] == ':') {
        VAR_0 ++;
    } else {
        VAR_1 = VAR_1 << 4 | parseHexChar(VAR_0[1]);
        VAR_0 += 2;
    }

    /* COMMENT_0 */
    if (VAR_0[0] != '\0') {
        VAR_0++;
    }
    return VAR_1;
}",android/a209ff12ba9617c10550678ff93d01fb72a33399/com_android_server_wifi_WifiNative.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,11 +1,19 @@
 static byte parseHexByte(const char * &str) {
+    if (str[0] == '\0') {
+        ALOGE(""Passed an empty string"");
+        return 0;
+    }
     byte b = parseHexChar(str[0]);
-    if (str[1] == ':' || str[1] == '\0') {
-        str += 2;
-        return b;
+    if (str[1] == '\0' || str[1] == ':') {
+        str ++;
     } else {
         b = b << 4 | parseHexChar(str[1]);
-        str += 3;
-        return b;
+        str += 2;
     }
+
+    // Skip trailing delimiter if not at the end of the string.
+    if (str[0] != '\0') {
+        str++;
+    }
+    return b;
 }","{'deleted_lines': [""    if (str[1] == ':' || str[1] == '\\0') {"", '        str += 2;', '        return b;', '        str += 3;', '        return b;'], 'added_lines': [""    if (str[0] == '\\0') {"", '        ALOGE(""Passed an empty string"");', '        return 0;', '    }', ""    if (str[1] == '\\0' || str[1] == ':') {"", '        str ++;', '        str += 2;', '', '    // Skip trailing delimiter if not at the end of the string.', ""    if (str[0] != '\\0') {"", '        str++;', '    }', '    return b;']}",True,"service/jni/com_android_server_wifi_WifiNative.cpp in Wi-Fi in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to obtain sensitive information via a crafted application that provides a MAC address with too few characters, aka internal bug 28164077.",5.5,MEDIUM,1,test,,5
CVE-2016-5384,['CWE-415'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,fontconfig,"The cache files are insufficiently validated. Even though the magic
number at the beginning of the file as well as time stamps are checked,
it is not verified if contained offsets are in legal ranges or are
even pointers.

The lack of validation allows an attacker to trigger arbitrary free()
calls, which in turn allows double free attacks and therefore arbitrary
code execution. Due to the conversion from offsets into pointers through
macros, this even allows to circumvent ASLR protections.

This attack vector allows privilege escalation when used with setuid
binaries like fbterm. A user can create ~/.fonts or any other
system-defined user-private font directory, run fc-cache and adjust
cache files in ~/.cache/fontconfig. The execution of setuid binaries will
scan these files and therefore are prone to attacks.

If it's not about code execution, an endless loop can be created by
letting linked lists become circular linked lists.

This patch verifies that:

- The file is not larger than the maximum addressable space, which
  basically only affects 32 bit systems. This allows out of boundary
  access into unallocated memory.
- Offsets are always positive or zero
- Offsets do not point outside file boundaries
- No pointers are allowed in cache files, every ""pointer or offset""
  field must be an offset or NULL
- Iterating linked lists must not take longer than the amount of elements
  specified. A violation of this rule can break a possible endless loop.

If one or more of these points are violated, the cache is recreated.
This is current behaviour.

Even though this patch fixes many issues, the use of mmap() shall be
forbidden in setuid binaries. It is impossible to guarantee with these
checks that a malicious user does not change cache files after
verification. This should be handled in a different patch.

Signed-off-by: Tobias Stoeckmann <tobias@stoeckmann.org>
",7a4a5bd7897d216f0794ca9dbce0a4a5c9d14940,https://cgit.freedesktop.org/fontconfig/commit/?id=7a4a5bd7897d216f0794ca9dbce0a4a5c9d14940,src/fccache.c,FcDirCacheMapFd,"static FcCache *
FcDirCacheMapFd (FcConfig *config, int fd, struct stat *fd_stat, struct stat *dir_stat)
{
FcCache*cache;
FcBoolallocated = FcFalse;
if (fd_stat->st_size < (int) sizeof (FcCache))
return NULL;
cache = FcCacheFindByStat (fd_stat);
if (cache)
{
if (FcCacheTimeValid (config, cache, dir_stat))
return cache;
FcDirCacheUnload (cache);
cache = NULL;
}
if (FcCacheIsMmapSafe (fd) && fd_stat->st_size >= FC_CACHE_MIN_MMAP)
{
#if defined(HAVE_MMAP) || defined(__CYGWIN__)
cache = mmap (0, fd_stat->st_size, PROT_READ, MAP_SHARED, fd, 0);
#if (HAVE_POSIX_FADVISE) && defined(POSIX_FADV_WILLNEED)
posix_fadvise (fd, 0, fd_stat->st_size, POSIX_FADV_WILLNEED);
#endif
if (cache == MAP_FAILED)
cache = NULL;
#elif defined(_WIN32)
{
HANDLE hFileMap;
cache = NULL;
hFileMap = CreateFileMapping((HANDLE) _get_osfhandle(fd), NULL,
PAGE_READONLY, 0, 0, NULL);
if (hFileMap != NULL)
{
cache = MapViewOfFile (hFileMap, FILE_MAP_READ, 0, 0,
fd_stat->st_size);
CloseHandle (hFileMap);
}
}
#endif
}
if (!cache)
{
cache = malloc (fd_stat->st_size);
if (!cache)
return NULL;
if (read (fd, cache, fd_stat->st_size) != fd_stat->st_size)
{
free (cache);
return NULL;
}
allocated = FcTrue;
}
if (cache->magic != FC_CACHE_MAGIC_MMAP ||
cache->version < FC_CACHE_VERSION_NUMBER ||
cache->size != (intptr_t) fd_stat->st_size ||
!FcCacheTimeValid (config, cache, dir_stat) ||
!FcCacheInsert (cache, fd_stat))
{
if (allocated)
free (cache);
else
{
#if defined(HAVE_MMAP) || defined(__CYGWIN__)
munmap (cache, fd_stat->st_size);
#elif defined(_WIN32)
UnmapViewOfFile (cache);
#endif
}
return NULL;
}
if (allocated)
cache->magic = FC_CACHE_MAGIC_ALLOC;
return cache;
}","static FcCache *
FcDirCacheMapFd (FcConfig *VAR_0, int VAR_1, struct stat *VAR_2, struct stat *VAR_3)
{
FcCache*VAR_4;
FcBoolVAR_5 = VAR_6;
if (VAR_2->st_size < (int) sizeof (FcCache))
return NULL;
VAR_4 = FcCacheFindByStat (VAR_2);
if (VAR_4)
{
if (FcCacheTimeValid (VAR_0, VAR_4, VAR_3))
return VAR_4;
FcDirCacheUnload (VAR_4);
VAR_4 = NULL;
}
if (FcCacheIsMmapSafe (VAR_1) && VAR_2->st_size >= VAR_7)
{
#if defined(VAR_8) || defined(VAR_9)
VAR_4 = mmap (0, VAR_2->st_size, VAR_10, VAR_11, VAR_1, 0);
#if (VAR_12) && defined(VAR_13)
posix_fadvise (VAR_1, 0, VAR_2->st_size, VAR_13);
#endif
if (VAR_4 == VAR_14)
VAR_4 = NULL;
#elif defined(VAR_15)
{
HANDLE VAR_16;
VAR_4 = NULL;
VAR_16 = CreateFileMapping((HANDLE) _get_osfhandle(VAR_1), NULL,
VAR_17, 0, 0, NULL);
if (VAR_16 != NULL)
{
VAR_4 = MapViewOfFile (VAR_16, VAR_18, 0, 0,
VAR_2->st_size);
CloseHandle (VAR_16);
}
}
#endif
}
if (!VAR_4)
{
VAR_4 = malloc (VAR_2->st_size);
if (!VAR_4)
return NULL;
if (read (VAR_1, VAR_4, VAR_2->st_size) != VAR_2->st_size)
{
free (VAR_4);
return NULL;
}
VAR_5 = VAR_19;
}
if (VAR_4->magic != VAR_20 ||
VAR_4->version < VAR_21 ||
VAR_4->size != (intptr_t) VAR_2->st_size ||
!FcCacheTimeValid (VAR_0, VAR_4, VAR_3) ||
!FcCacheInsert (VAR_4, VAR_2))
{
if (VAR_5)
free (VAR_4);
else
{
#if defined(VAR_8) || defined(VAR_9)
munmap (VAR_4, VAR_2->st_size);
#elif defined(VAR_15)
UnmapViewOfFile (VAR_4);
#endif
}
return NULL;
}
if (VAR_5)
VAR_4->magic = VAR_22;
return VAR_4;
}",fontconfig/7a4a5bd7897d216f0794ca9dbce0a4a5c9d14940/fccache.c/vul/before/0.json,"static FcCache *
FcDirCacheMapFd (FcConfig *config, int fd, struct stat *fd_stat, struct stat *dir_stat)
{
    FcCache	*cache;
    FcBool	allocated = FcFalse;

    if (fd_stat->st_size > INTPTR_MAX ||
        fd_stat->st_size < (int) sizeof (FcCache))
	return NULL;
    cache = FcCacheFindByStat (fd_stat);
    if (cache)
    {
	if (FcCacheTimeValid (config, cache, dir_stat))
	    return cache;
	FcDirCacheUnload (cache);
	cache = NULL;
    }

    /*
     * Large cache files are mmap'ed, smaller cache files are read. This
     * balances the system cost of mmap against per-process memory usage.
     */
    if (FcCacheIsMmapSafe (fd) && fd_stat->st_size >= FC_CACHE_MIN_MMAP)
    {
#if defined(HAVE_MMAP) || defined(__CYGWIN__)
	cache = mmap (0, fd_stat->st_size, PROT_READ, MAP_SHARED, fd, 0);
#if (HAVE_POSIX_FADVISE) && defined(POSIX_FADV_WILLNEED)
	posix_fadvise (fd, 0, fd_stat->st_size, POSIX_FADV_WILLNEED);
#endif
	if (cache == MAP_FAILED)
	    cache = NULL;
#elif defined(_WIN32)
	{
	    HANDLE hFileMap;

	    cache = NULL;
	    hFileMap = CreateFileMapping((HANDLE) _get_osfhandle(fd), NULL,
					 PAGE_READONLY, 0, 0, NULL);
	    if (hFileMap != NULL)
	    {
		cache = MapViewOfFile (hFileMap, FILE_MAP_READ, 0, 0,
				       fd_stat->st_size);
		CloseHandle (hFileMap);
	    }
	}
#endif
    }
    if (!cache)
    {
	cache = malloc (fd_stat->st_size);
	if (!cache)
	    return NULL;

	if (read (fd, cache, fd_stat->st_size) != fd_stat->st_size)
	{
	    free (cache);
	    return NULL;
	}
	allocated = FcTrue;
    }
    if (cache->magic != FC_CACHE_MAGIC_MMAP ||
	cache->version < FC_CACHE_VERSION_NUMBER ||
	cache->size != (intptr_t) fd_stat->st_size ||
        !FcCacheOffsetsValid (cache) ||
	!FcCacheTimeValid (config, cache, dir_stat) ||
	!FcCacheInsert (cache, fd_stat))
    {
	if (allocated)
	    free (cache);
	else
	{
#if defined(HAVE_MMAP) || defined(__CYGWIN__)
	    munmap (cache, fd_stat->st_size);
#elif defined(_WIN32)
	    UnmapViewOfFile (cache);
#endif
	}
	return NULL;
    }

    /* Mark allocated caches so they're freed rather than unmapped */
    if (allocated)
	cache->magic = FC_CACHE_MAGIC_ALLOC;
	
    return cache;
}","static FcCache *
FcDirCacheMapFd (FcConfig *VAR_0, int VAR_1, struct stat *VAR_2, struct stat *VAR_3)
{
    FcCache	*VAR_4;
    FcBool	VAR_5 = VAR_6;

    if (VAR_2->st_size > VAR_7 ||
        VAR_2->st_size < (int) sizeof (FcCache))
	return NULL;
    VAR_4 = FcCacheFindByStat (VAR_2);
    if (VAR_4)
    {
	if (FcCacheTimeValid (VAR_0, VAR_4, VAR_3))
	    return VAR_4;
	FcDirCacheUnload (VAR_4);
	VAR_4 = NULL;
    }

    /* COMMENT_0 */
                                                                        
                                                                         
       
    if (FcCacheIsMmapSafe (VAR_1) && VAR_2->st_size >= VAR_8)
    {
#if defined(VAR_9) || defined(VAR_10)
	VAR_4 = mmap (0, VAR_2->st_size, VAR_11, VAR_12, VAR_1, 0);
#if (VAR_13) && defined(VAR_14)
	posix_fadvise (VAR_1, 0, VAR_2->st_size, VAR_14);
#endif
	if (VAR_4 == VAR_15)
	    VAR_4 = NULL;
#elif defined(VAR_16)
	{
	    HANDLE VAR_17;

	    VAR_4 = NULL;
	    VAR_17 = CreateFileMapping((HANDLE) _get_osfhandle(VAR_1), NULL,
					 VAR_18, 0, 0, NULL);
	    if (VAR_17 != NULL)
	    {
		VAR_4 = MapViewOfFile (VAR_17, VAR_19, 0, 0,
				       VAR_2->st_size);
		CloseHandle (VAR_17);
	    }
	}
#endif
    }
    if (!VAR_4)
    {
	VAR_4 = malloc (VAR_2->st_size);
	if (!VAR_4)
	    return NULL;

	if (read (VAR_1, VAR_4, VAR_2->st_size) != VAR_2->st_size)
	{
	    free (VAR_4);
	    return NULL;
	}
	VAR_5 = VAR_20;
    }
    if (VAR_4->magic != VAR_21 ||
	VAR_4->version < VAR_22 ||
	VAR_4->size != (intptr_t) VAR_2->st_size ||
        !FcCacheOffsetsValid (VAR_4) ||
	!FcCacheTimeValid (VAR_0, VAR_4, VAR_3) ||
	!FcCacheInsert (VAR_4, VAR_2))
    {
	if (VAR_5)
	    free (VAR_4);
	else
	{
#if defined(VAR_9) || defined(VAR_10)
	    munmap (VAR_4, VAR_2->st_size);
#elif defined(VAR_16)
	    UnmapViewOfFile (VAR_4);
#endif
	}
	return NULL;
    }

    /* COMMENT_4 */
    if (VAR_5)
	VAR_4->magic = VAR_23;
	
    return VAR_4;
}",fontconfig/7a4a5bd7897d216f0794ca9dbce0a4a5c9d14940/fccache.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,7 +4,8 @@
     FcCache	*cache;
     FcBool	allocated = FcFalse;
 
-    if (fd_stat->st_size < (int) sizeof (FcCache))
+    if (fd_stat->st_size > INTPTR_MAX ||
+        fd_stat->st_size < (int) sizeof (FcCache))
 	return NULL;
     cache = FcCacheFindByStat (fd_stat);
     if (cache)
@@ -60,6 +61,7 @@
     if (cache->magic != FC_CACHE_MAGIC_MMAP ||
 	cache->version < FC_CACHE_VERSION_NUMBER ||
 	cache->size != (intptr_t) fd_stat->st_size ||
+        !FcCacheOffsetsValid (cache) ||
 	!FcCacheTimeValid (config, cache, dir_stat) ||
 	!FcCacheInsert (cache, fd_stat))
     {","{'deleted_lines': ['    if (fd_stat->st_size < (int) sizeof (FcCache))'], 'added_lines': ['    if (fd_stat->st_size > INTPTR_MAX ||', '        fd_stat->st_size < (int) sizeof (FcCache))', '        !FcCacheOffsetsValid (cache) ||']}",True,"fontconfig before 2.12.1 does not validate offsets, which allows local users to trigger arbitrary free calls and consequently conduct double free attacks and execute arbitrary code via a crafted cache file.",7.8,HIGH,2,test,,5
CVE-2016-5155,['CWE-254'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,chromium,"binding: Moves the check for the first access to the initial document into BindingSecurity.

Checks the access to the initial document and reports it not only at
securityCheck() in V8Window.cpp but also at every call to
BindingSecurity::shouldAllowAccessTo() because V8 only calls back
securityCheck() on property lookups, and not for function invocation.

BindingSecurity::shouldAllowAccessTo() is called with every possible
cross-origin window, which means every possible new window.  Thus,
shouldAllowAccessTo() should be the right place to check the access
to the initial document.

BUG=630662
TBR=benwells@chromium.org

Review-Url: https://codereview.chromium.org/2209303002
Cr-Commit-Position: refs/heads/master@{#412195}
",b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6,https://chromium.googlesource.com/chromium/src/+/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6,third_party/WebKit/Source/bindings/core/v8/BindingSecurity.cpp,BindingSecurity::shouldAllowAccessTo,"bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Node* target, ExceptionState& exceptionState)
{
if (!target)
return false;
return canAccessFrame(isolate, accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), exceptionState);
}","bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* VAR_0, const LocalDOMWindow* VAR_1, const Node* VAR_2, ExceptionState& VAR_3)
{
if (!VAR_2)
return false;
return canAccessFrame(VAR_0, VAR_1, VAR_2->document().getSecurityOrigin(), VAR_2->document().domWindow(), VAR_3);
}",chromium/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6/BindingSecurity.cpp/vul/before/0.json,"bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Node* target, ExceptionState& exceptionState)
{
    if (!target)
        return false;
    return canAccessFrame(accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), exceptionState);
}","bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* VAR_0, const LocalDOMWindow* VAR_1, const Node* VAR_2, ExceptionState& VAR_3)
{
    if (!VAR_2)
        return false;
    return canAccessFrame(VAR_1, VAR_2->document().getSecurityOrigin(), VAR_2->document().domWindow(), VAR_3);
}",chromium/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6/BindingSecurity.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,5 +2,5 @@
 {
     if (!target)
         return false;
-    return canAccessFrame(isolate, accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), exceptionState);
+    return canAccessFrame(accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), exceptionState);
 }","{'deleted_lines': ['    return canAccessFrame(isolate, accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), exceptionState);'], 'added_lines': ['    return canAccessFrame(accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), exceptionState);']}",True,"Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site.",6.5,MEDIUM,1,test,,5
CVE-2016-5155,['CWE-254'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,chromium,"binding: Moves the check for the first access to the initial document into BindingSecurity.

Checks the access to the initial document and reports it not only at
securityCheck() in V8Window.cpp but also at every call to
BindingSecurity::shouldAllowAccessTo() because V8 only calls back
securityCheck() on property lookups, and not for function invocation.

BindingSecurity::shouldAllowAccessTo() is called with every possible
cross-origin window, which means every possible new window.  Thus,
shouldAllowAccessTo() should be the right place to check the access
to the initial document.

BUG=630662
TBR=benwells@chromium.org

Review-Url: https://codereview.chromium.org/2209303002
Cr-Commit-Position: refs/heads/master@{#412195}
",b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6,https://chromium.googlesource.com/chromium/src/+/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6,third_party/WebKit/Source/bindings/core/v8/BindingSecurity.cpp,BindingSecurity::shouldAllowAccessTo,"bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, v8::Local<v8::Context> context, const ExecutionContext* executionContext, const MainThreadWorkletGlobalScope* workletGlobalScope, SecurityReportingOption reportingOption)
{
DCHECK(executionContext);
DOMWindow* domWindow = toDOMWindow(context);
if (executionContext->isMainThreadWorkletGlobalScope()) {
Frame* callingFrame = toMainThreadWorkletGlobalScope(executionContext)->frame();
domWindow = callingFrame ? callingFrame->domWindow() : nullptr;
}
DCHECK(workletGlobalScope);
const Frame* workletGlobalScopeFrame = workletGlobalScope->frame();
if (!workletGlobalScopeFrame || !workletGlobalScopeFrame->securityContext())
return false;
return domWindow && canAccessFrame(isolate, toLocalDOMWindow(domWindow), workletGlobalScopeFrame->securityContext()->getSecurityOrigin(), workletGlobalScopeFrame->domWindow(), reportingOption);
}","bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* VAR_0, v8::Local<v8::Context> VAR_1, const ExecutionContext* VAR_2, const MainThreadWorkletGlobalScope* VAR_3, SecurityReportingOption VAR_4)
{
DCHECK(VAR_2);
DOMWindow* VAR_5 = toDOMWindow(VAR_1);
if (VAR_2->isMainThreadWorkletGlobalScope()) {
Frame* VAR_6 = toMainThreadWorkletGlobalScope(VAR_2)->frame();
VAR_5 = VAR_6 ? VAR_6->domWindow() : nullptr;
}
DCHECK(VAR_3);
const Frame* VAR_7 = VAR_3->frame();
if (!VAR_7 || !VAR_7->securityContext())
return false;
return VAR_5 && canAccessFrame(VAR_0, toLocalDOMWindow(VAR_5), VAR_7->securityContext()->getSecurityOrigin(), VAR_7->domWindow(), VAR_4);
}",chromium/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6/BindingSecurity.cpp/vul/before/1.json,"bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, v8::Local<v8::Context> context, const ExecutionContext* executionContext, const MainThreadWorkletGlobalScope* workletGlobalScope, SecurityReportingOption reportingOption)
{
    DCHECK(executionContext);
    DOMWindow* domWindow = toDOMWindow(context);
    if (executionContext->isMainThreadWorkletGlobalScope()) {
        Frame* callingFrame = toMainThreadWorkletGlobalScope(executionContext)->frame();
        domWindow = callingFrame ? callingFrame->domWindow() : nullptr;
    }

    DCHECK(workletGlobalScope);
    const Frame* workletGlobalScopeFrame = workletGlobalScope->frame();
    if (!workletGlobalScopeFrame || !workletGlobalScopeFrame->securityContext())
        return false;

    return domWindow && canAccessFrame(toLocalDOMWindow(domWindow), workletGlobalScopeFrame->securityContext()->getSecurityOrigin(), workletGlobalScopeFrame->domWindow(), reportingOption);
}","bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* VAR_0, v8::Local<v8::Context> VAR_1, const ExecutionContext* VAR_2, const MainThreadWorkletGlobalScope* VAR_3, SecurityReportingOption VAR_4)
{
    DCHECK(VAR_2);
    DOMWindow* VAR_5 = toDOMWindow(VAR_1);
    if (VAR_2->isMainThreadWorkletGlobalScope()) {
        Frame* VAR_6 = toMainThreadWorkletGlobalScope(VAR_2)->frame();
        VAR_5 = VAR_6 ? VAR_6->domWindow() : nullptr;
    }

    DCHECK(VAR_3);
    const Frame* VAR_7 = VAR_3->frame();
    if (!VAR_7 || !VAR_7->securityContext())
        return false;

    return VAR_5 && canAccessFrame(toLocalDOMWindow(VAR_5), VAR_7->securityContext()->getSecurityOrigin(), VAR_7->domWindow(), VAR_4);
}",chromium/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6/BindingSecurity.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -12,5 +12,5 @@
     if (!workletGlobalScopeFrame || !workletGlobalScopeFrame->securityContext())
         return false;
 
-    return domWindow && canAccessFrame(isolate, toLocalDOMWindow(domWindow), workletGlobalScopeFrame->securityContext()->getSecurityOrigin(), workletGlobalScopeFrame->domWindow(), reportingOption);
+    return domWindow && canAccessFrame(toLocalDOMWindow(domWindow), workletGlobalScopeFrame->securityContext()->getSecurityOrigin(), workletGlobalScopeFrame->domWindow(), reportingOption);
 }","{'deleted_lines': ['    return domWindow && canAccessFrame(isolate, toLocalDOMWindow(domWindow), workletGlobalScopeFrame->securityContext()->getSecurityOrigin(), workletGlobalScopeFrame->domWindow(), reportingOption);'], 'added_lines': ['    return domWindow && canAccessFrame(toLocalDOMWindow(domWindow), workletGlobalScopeFrame->securityContext()->getSecurityOrigin(), workletGlobalScopeFrame->domWindow(), reportingOption);']}",True,"Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site.",6.5,MEDIUM,1,test,,5
CVE-2016-5155,['CWE-254'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,chromium,"binding: Moves the check for the first access to the initial document into BindingSecurity.

Checks the access to the initial document and reports it not only at
securityCheck() in V8Window.cpp but also at every call to
BindingSecurity::shouldAllowAccessTo() because V8 only calls back
securityCheck() on property lookups, and not for function invocation.

BindingSecurity::shouldAllowAccessTo() is called with every possible
cross-origin window, which means every possible new window.  Thus,
shouldAllowAccessTo() should be the right place to check the access
to the initial document.

BUG=630662
TBR=benwells@chromium.org

Review-Url: https://codereview.chromium.org/2209303002
Cr-Commit-Position: refs/heads/master@{#412195}
",b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6,https://chromium.googlesource.com/chromium/src/+/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6,third_party/WebKit/Source/bindings/core/v8/BindingSecurity.cpp,BindingSecurity::shouldAllowAccessTo,"bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Location* target, ExceptionState& exceptionState)
{
ASSERT(target);
const Frame* frame = target->frame();
if (!frame || !frame->securityContext())
return false;
return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), exceptionState);
}","bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* VAR_0, const LocalDOMWindow* VAR_1, const Location* VAR_2, ExceptionState& VAR_3)
{
ASSERT(VAR_2);
const Frame* VAR_4 = VAR_2->frame();
if (!VAR_4 || !VAR_4->securityContext())
return false;
return canAccessFrame(VAR_0, VAR_1, VAR_4->securityContext()->getSecurityOrigin(), VAR_4->domWindow(), VAR_3);
}",chromium/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6/BindingSecurity.cpp/vul/before/2.json,"bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Location* target, ExceptionState& exceptionState)
{
    ASSERT(target);
    const Frame* frame = target->frame();
    if (!frame || !frame->securityContext())
        return false;
    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), exceptionState);
}","bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* VAR_0, const LocalDOMWindow* VAR_1, const Location* VAR_2, ExceptionState& VAR_3)
{
    ASSERT(VAR_2);
    const Frame* VAR_4 = VAR_2->frame();
    if (!VAR_4 || !VAR_4->securityContext())
        return false;
    return canAccessFrame(VAR_1, VAR_4->securityContext()->getSecurityOrigin(), VAR_4->domWindow(), VAR_3);
}",chromium/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6/BindingSecurity.cpp/vul/after/2.json,"--- func_before
+++ func_after
@@ -4,5 +4,5 @@
     const Frame* frame = target->frame();
     if (!frame || !frame->securityContext())
         return false;
-    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), exceptionState);
+    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), exceptionState);
 }","{'deleted_lines': ['    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), exceptionState);'], 'added_lines': ['    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), exceptionState);']}",True,"Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site.",6.5,MEDIUM,1,test,,5
CVE-2016-5155,['CWE-254'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,chromium,"binding: Moves the check for the first access to the initial document into BindingSecurity.

Checks the access to the initial document and reports it not only at
securityCheck() in V8Window.cpp but also at every call to
BindingSecurity::shouldAllowAccessTo() because V8 only calls back
securityCheck() on property lookups, and not for function invocation.

BindingSecurity::shouldAllowAccessTo() is called with every possible
cross-origin window, which means every possible new window.  Thus,
shouldAllowAccessTo() should be the right place to check the access
to the initial document.

BUG=630662
TBR=benwells@chromium.org

Review-Url: https://codereview.chromium.org/2209303002
Cr-Commit-Position: refs/heads/master@{#412195}
",b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6,https://chromium.googlesource.com/chromium/src/+/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6,third_party/WebKit/Source/bindings/core/v8/BindingSecurity.cpp,BindingSecurity::shouldAllowAccessTo,"bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const DOMWindow* target, ExceptionState& exceptionState)
{
ASSERT(target);
const Frame* frame = target->frame();
if (!frame || !frame->securityContext())
return false;
return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), target, exceptionState);
}","bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* VAR_0, const LocalDOMWindow* VAR_1, const DOMWindow* VAR_2, ExceptionState& VAR_3)
{
ASSERT(VAR_2);
const Frame* VAR_4 = VAR_2->frame();
if (!VAR_4 || !VAR_4->securityContext())
return false;
return canAccessFrame(VAR_0, VAR_1, VAR_4->securityContext()->getSecurityOrigin(), VAR_2, VAR_3);
}",chromium/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6/BindingSecurity.cpp/vul/before/3.json,"bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const DOMWindow* target, ExceptionState& exceptionState)
{
    ASSERT(target);
    const Frame* frame = target->frame();
    if (!frame || !frame->securityContext())
        return false;
    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), target, exceptionState);
}","bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* VAR_0, const LocalDOMWindow* VAR_1, const DOMWindow* VAR_2, ExceptionState& VAR_3)
{
    ASSERT(VAR_2);
    const Frame* VAR_4 = VAR_2->frame();
    if (!VAR_4 || !VAR_4->securityContext())
        return false;
    return canAccessFrame(VAR_1, VAR_4->securityContext()->getSecurityOrigin(), VAR_2, VAR_3);
}",chromium/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6/BindingSecurity.cpp/vul/after/3.json,"--- func_before
+++ func_after
@@ -4,5 +4,5 @@
     const Frame* frame = target->frame();
     if (!frame || !frame->securityContext())
         return false;
-    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), target, exceptionState);
+    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), target, exceptionState);
 }","{'deleted_lines': ['    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), target, exceptionState);'], 'added_lines': ['    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), target, exceptionState);']}",True,"Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site.",6.5,MEDIUM,1,test,,5
CVE-2016-5155,['CWE-254'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,chromium,"binding: Moves the check for the first access to the initial document into BindingSecurity.

Checks the access to the initial document and reports it not only at
securityCheck() in V8Window.cpp but also at every call to
BindingSecurity::shouldAllowAccessTo() because V8 only calls back
securityCheck() on property lookups, and not for function invocation.

BindingSecurity::shouldAllowAccessTo() is called with every possible
cross-origin window, which means every possible new window.  Thus,
shouldAllowAccessTo() should be the right place to check the access
to the initial document.

BUG=630662
TBR=benwells@chromium.org

Review-Url: https://codereview.chromium.org/2209303002
Cr-Commit-Position: refs/heads/master@{#412195}
",b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6,https://chromium.googlesource.com/chromium/src/+/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6,third_party/WebKit/Source/bindings/core/v8/BindingSecurity.cpp,BindingSecurity::shouldAllowAccessTo,"bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const DOMWindow* target, SecurityReportingOption reportingOption)
{
ASSERT(target);
const Frame* frame = target->frame();
if (!frame || !frame->securityContext())
return false;
return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), target, reportingOption);
}","bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* VAR_0, const LocalDOMWindow* VAR_1, const DOMWindow* VAR_2, SecurityReportingOption VAR_3)
{
ASSERT(VAR_2);
const Frame* VAR_4 = VAR_2->frame();
if (!VAR_4 || !VAR_4->securityContext())
return false;
return canAccessFrame(VAR_0, VAR_1, VAR_4->securityContext()->getSecurityOrigin(), VAR_2, VAR_3);
}",chromium/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6/BindingSecurity.cpp/vul/before/4.json,"bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const DOMWindow* target, SecurityReportingOption reportingOption)
{
    ASSERT(target);
    const Frame* frame = target->frame();
    if (!frame || !frame->securityContext())
        return false;
    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), target, reportingOption);
}","bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* VAR_0, const LocalDOMWindow* VAR_1, const DOMWindow* VAR_2, SecurityReportingOption VAR_3)
{
    ASSERT(VAR_2);
    const Frame* VAR_4 = VAR_2->frame();
    if (!VAR_4 || !VAR_4->securityContext())
        return false;
    return canAccessFrame(VAR_1, VAR_4->securityContext()->getSecurityOrigin(), VAR_2, VAR_3);
}",chromium/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6/BindingSecurity.cpp/vul/after/4.json,"--- func_before
+++ func_after
@@ -4,5 +4,5 @@
     const Frame* frame = target->frame();
     if (!frame || !frame->securityContext())
         return false;
-    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), target, reportingOption);
+    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), target, reportingOption);
 }","{'deleted_lines': ['    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), target, reportingOption);'], 'added_lines': ['    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), target, reportingOption);']}",True,"Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site.",6.5,MEDIUM,1,test,,5
CVE-2016-5155,['CWE-254'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,chromium,"binding: Moves the check for the first access to the initial document into BindingSecurity.

Checks the access to the initial document and reports it not only at
securityCheck() in V8Window.cpp but also at every call to
BindingSecurity::shouldAllowAccessTo() because V8 only calls back
securityCheck() on property lookups, and not for function invocation.

BindingSecurity::shouldAllowAccessTo() is called with every possible
cross-origin window, which means every possible new window.  Thus,
shouldAllowAccessTo() should be the right place to check the access
to the initial document.

BUG=630662
TBR=benwells@chromium.org

Review-Url: https://codereview.chromium.org/2209303002
Cr-Commit-Position: refs/heads/master@{#412195}
",b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6,https://chromium.googlesource.com/chromium/src/+/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6,third_party/WebKit/Source/bindings/core/v8/BindingSecurity.cpp,BindingSecurity::shouldAllowAccessTo,"bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Node* target, SecurityReportingOption reportingOption)
{
if (!target)
return false;
return canAccessFrame(isolate, accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), reportingOption);
}","bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* VAR_0, const LocalDOMWindow* VAR_1, const Node* VAR_2, SecurityReportingOption VAR_3)
{
if (!VAR_2)
return false;
return canAccessFrame(VAR_0, VAR_1, VAR_2->document().getSecurityOrigin(), VAR_2->document().domWindow(), VAR_3);
}",chromium/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6/BindingSecurity.cpp/vul/before/5.json,"bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Node* target, SecurityReportingOption reportingOption)
{
    if (!target)
        return false;
    return canAccessFrame(accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), reportingOption);
}","bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* VAR_0, const LocalDOMWindow* VAR_1, const Node* VAR_2, SecurityReportingOption VAR_3)
{
    if (!VAR_2)
        return false;
    return canAccessFrame(VAR_1, VAR_2->document().getSecurityOrigin(), VAR_2->document().domWindow(), VAR_3);
}",chromium/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6/BindingSecurity.cpp/vul/after/5.json,"--- func_before
+++ func_after
@@ -2,5 +2,5 @@
 {
     if (!target)
         return false;
-    return canAccessFrame(isolate, accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), reportingOption);
+    return canAccessFrame(accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), reportingOption);
 }","{'deleted_lines': ['    return canAccessFrame(isolate, accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), reportingOption);'], 'added_lines': ['    return canAccessFrame(accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), reportingOption);']}",True,"Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site.",6.5,MEDIUM,1,test,,5
CVE-2016-5155,['CWE-254'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,chromium,"binding: Moves the check for the first access to the initial document into BindingSecurity.

Checks the access to the initial document and reports it not only at
securityCheck() in V8Window.cpp but also at every call to
BindingSecurity::shouldAllowAccessTo() because V8 only calls back
securityCheck() on property lookups, and not for function invocation.

BindingSecurity::shouldAllowAccessTo() is called with every possible
cross-origin window, which means every possible new window.  Thus,
shouldAllowAccessTo() should be the right place to check the access
to the initial document.

BUG=630662
TBR=benwells@chromium.org

Review-Url: https://codereview.chromium.org/2209303002
Cr-Commit-Position: refs/heads/master@{#412195}
",b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6,https://chromium.googlesource.com/chromium/src/+/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6,third_party/WebKit/Source/bindings/core/v8/BindingSecurity.cpp,BindingSecurity::shouldAllowAccessTo,"bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const EventTarget* target, ExceptionState& exceptionState)
{
ASSERT(target);
const DOMWindow* window = target->toDOMWindow();
if (!window) {
return true;
}
const Frame* frame = window->frame();
if (!frame || !frame->securityContext())
return false;
return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), window, exceptionState);
}","bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* VAR_0, const LocalDOMWindow* VAR_1, const EventTarget* VAR_2, ExceptionState& VAR_3)
{
ASSERT(VAR_2);
const DOMWindow* VAR_4 = VAR_2->toDOMWindow();
if (!VAR_4) {
return true;
}
const Frame* VAR_5 = VAR_4->frame();
if (!VAR_5 || !VAR_5->securityContext())
return false;
return canAccessFrame(VAR_0, VAR_1, VAR_5->securityContext()->getSecurityOrigin(), VAR_4, VAR_3);
}",chromium/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6/BindingSecurity.cpp/vul/before/6.json,"bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const EventTarget* target, ExceptionState& exceptionState)
{
    ASSERT(target);
    const DOMWindow* window = target->toDOMWindow();
    if (!window) {
        // We only need to check the access to Window objects which are
        // cross-origin accessible.  If it's not a Window, the object's
        // origin must always be the same origin (or it already leaked).
        return true;
    }
    const Frame* frame = window->frame();
    if (!frame || !frame->securityContext())
        return false;
    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), window, exceptionState);
}","bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* VAR_0, const LocalDOMWindow* VAR_1, const EventTarget* VAR_2, ExceptionState& VAR_3)
{
    ASSERT(VAR_2);
    const DOMWindow* VAR_4 = VAR_2->toDOMWindow();
    if (!VAR_4) {
        /* COMMENT_0 */
        /* COMMENT_1 */
        /* COMMENT_2 */
        return true;
    }
    const Frame* VAR_5 = VAR_4->frame();
    if (!VAR_5 || !VAR_5->securityContext())
        return false;
    return canAccessFrame(VAR_1, VAR_5->securityContext()->getSecurityOrigin(), VAR_4, VAR_3);
}",chromium/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6/BindingSecurity.cpp/vul/after/6.json,"--- func_before
+++ func_after
@@ -11,5 +11,5 @@
     const Frame* frame = window->frame();
     if (!frame || !frame->securityContext())
         return false;
-    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), window, exceptionState);
+    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), window, exceptionState);
 }","{'deleted_lines': ['    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), window, exceptionState);'], 'added_lines': ['    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), window, exceptionState);']}",True,"Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site.",6.5,MEDIUM,1,test,,5
CVE-2016-5155,['CWE-254'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,chromium,"binding: Moves the check for the first access to the initial document into BindingSecurity.

Checks the access to the initial document and reports it not only at
securityCheck() in V8Window.cpp but also at every call to
BindingSecurity::shouldAllowAccessTo() because V8 only calls back
securityCheck() on property lookups, and not for function invocation.

BindingSecurity::shouldAllowAccessTo() is called with every possible
cross-origin window, which means every possible new window.  Thus,
shouldAllowAccessTo() should be the right place to check the access
to the initial document.

BUG=630662
TBR=benwells@chromium.org

Review-Url: https://codereview.chromium.org/2209303002
Cr-Commit-Position: refs/heads/master@{#412195}
",b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6,https://chromium.googlesource.com/chromium/src/+/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6,third_party/WebKit/Source/bindings/core/v8/BindingSecurity.cpp,BindingSecurity::shouldAllowAccessTo,"bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Location* target, SecurityReportingOption reportingOption)
{
ASSERT(target);
const Frame* frame = target->frame();
if (!frame || !frame->securityContext())
return false;
return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), reportingOption);
}","bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* VAR_0, const LocalDOMWindow* VAR_1, const Location* VAR_2, SecurityReportingOption VAR_3)
{
ASSERT(VAR_2);
const Frame* VAR_4 = VAR_2->frame();
if (!VAR_4 || !VAR_4->securityContext())
return false;
return canAccessFrame(VAR_0, VAR_1, VAR_4->securityContext()->getSecurityOrigin(), VAR_4->domWindow(), VAR_3);
}",chromium/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6/BindingSecurity.cpp/vul/before/7.json,"bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Location* target, SecurityReportingOption reportingOption)
{
    ASSERT(target);
    const Frame* frame = target->frame();
    if (!frame || !frame->securityContext())
        return false;
    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), reportingOption);
}","bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* VAR_0, const LocalDOMWindow* VAR_1, const Location* VAR_2, SecurityReportingOption VAR_3)
{
    ASSERT(VAR_2);
    const Frame* VAR_4 = VAR_2->frame();
    if (!VAR_4 || !VAR_4->securityContext())
        return false;
    return canAccessFrame(VAR_1, VAR_4->securityContext()->getSecurityOrigin(), VAR_4->domWindow(), VAR_3);
}",chromium/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6/BindingSecurity.cpp/vul/after/7.json,"--- func_before
+++ func_after
@@ -4,5 +4,5 @@
     const Frame* frame = target->frame();
     if (!frame || !frame->securityContext())
         return false;
-    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), reportingOption);
+    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), reportingOption);
 }","{'deleted_lines': ['    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), reportingOption);'], 'added_lines': ['    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), reportingOption);']}",True,"Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site.",6.5,MEDIUM,1,test,,5
CVE-2016-5155,['CWE-254'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,chromium,"binding: Moves the check for the first access to the initial document into BindingSecurity.

Checks the access to the initial document and reports it not only at
securityCheck() in V8Window.cpp but also at every call to
BindingSecurity::shouldAllowAccessTo() because V8 only calls back
securityCheck() on property lookups, and not for function invocation.

BindingSecurity::shouldAllowAccessTo() is called with every possible
cross-origin window, which means every possible new window.  Thus,
shouldAllowAccessTo() should be the right place to check the access
to the initial document.

BUG=630662
TBR=benwells@chromium.org

Review-Url: https://codereview.chromium.org/2209303002
Cr-Commit-Position: refs/heads/master@{#412195}
",b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6,https://chromium.googlesource.com/chromium/src/+/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6,third_party/WebKit/Source/bindings/core/v8/BindingSecurity.cpp,BindingSecurity::shouldAllowAccessToFrame,"bool BindingSecurity::shouldAllowAccessToFrame(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Frame* target, SecurityReportingOption reportingOption)
{
if (!target || !target->securityContext())
return false;
return canAccessFrame(isolate, accessingWindow, target->securityContext()->getSecurityOrigin(), target->domWindow(), reportingOption);
}","bool BindingSecurity::shouldAllowAccessToFrame(v8::Isolate* VAR_0, const LocalDOMWindow* VAR_1, const Frame* VAR_2, SecurityReportingOption VAR_3)
{
if (!VAR_2 || !VAR_2->securityContext())
return false;
return canAccessFrame(VAR_0, VAR_1, VAR_2->securityContext()->getSecurityOrigin(), VAR_2->domWindow(), VAR_3);
}",chromium/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6/BindingSecurity.cpp/vul/before/8.json,"bool BindingSecurity::shouldAllowAccessToFrame(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Frame* target, SecurityReportingOption reportingOption)
{
    if (!target || !target->securityContext())
        return false;
    return canAccessFrame(accessingWindow, target->securityContext()->getSecurityOrigin(), target->domWindow(), reportingOption);
}","bool BindingSecurity::shouldAllowAccessToFrame(v8::Isolate* VAR_0, const LocalDOMWindow* VAR_1, const Frame* VAR_2, SecurityReportingOption VAR_3)
{
    if (!VAR_2 || !VAR_2->securityContext())
        return false;
    return canAccessFrame(VAR_1, VAR_2->securityContext()->getSecurityOrigin(), VAR_2->domWindow(), VAR_3);
}",chromium/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6/BindingSecurity.cpp/vul/after/8.json,"--- func_before
+++ func_after
@@ -2,5 +2,5 @@
 {
     if (!target || !target->securityContext())
         return false;
-    return canAccessFrame(isolate, accessingWindow, target->securityContext()->getSecurityOrigin(), target->domWindow(), reportingOption);
+    return canAccessFrame(accessingWindow, target->securityContext()->getSecurityOrigin(), target->domWindow(), reportingOption);
 }","{'deleted_lines': ['    return canAccessFrame(isolate, accessingWindow, target->securityContext()->getSecurityOrigin(), target->domWindow(), reportingOption);'], 'added_lines': ['    return canAccessFrame(accessingWindow, target->securityContext()->getSecurityOrigin(), target->domWindow(), reportingOption);']}",True,"Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site.",6.5,MEDIUM,1,test,,5
CVE-2016-3870,['CWE-264'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"omx: prevent input port enable/disable for software codecs

Bug: 29421804
Change-Id: Iba1011e9af942a6dff7f659af769a51e3f5ba66f
",1e9801783770917728b7edbdeff3d0ec09c621ac,https://android.googlesource.com/platform/frameworks/av/+/1e9801783770917728b7edbdeff3d0ec09c621ac,media/libstagefright/omx/SimpleSoftOMXComponent.cpp,SimpleSoftOMXComponent::onPortEnable,"void SimpleSoftOMXComponent::onPortEnable(OMX_U32 portIndex, bool enable) {
CHECK_LT(portIndex, mPorts.size());
PortInfo *port = &mPorts.editItemAt(portIndex);
CHECK_EQ((int)port->mTransition, (int)PortInfo::NONE);
CHECK(port->mDef.bEnabled == !enable);
if (!enable) {
port->mDef.bEnabled = OMX_FALSE;
port->mTransition = PortInfo::DISABLING;
for (size_t i = 0; i < port->mBuffers.size(); ++i) {
BufferInfo *buffer = &port->mBuffers.editItemAt(i);
if (buffer->mOwnedByUs) {
buffer->mOwnedByUs = false;
if (port->mDef.eDir == OMX_DirInput) {
notifyEmptyBufferDone(buffer->mHeader);
} else {
CHECK_EQ(port->mDef.eDir, OMX_DirOutput);
notifyFillBufferDone(buffer->mHeader);
}
}
}
port->mQueue.clear();
} else {
port->mTransition = PortInfo::ENABLING;
}
checkTransitions();
}","void SimpleSoftOMXComponent::onPortEnable(OMX_U32 VAR_0, bool VAR_1) {
CHECK_LT(VAR_0, VAR_2.size());
PortInfo *VAR_3 = &VAR_2.editItemAt(VAR_0);
CHECK_EQ((int)VAR_3->mTransition, (int)PortInfo::NONE);
CHECK(VAR_3->mDef.bEnabled == !VAR_1);
if (!VAR_1) {
VAR_3->mDef.bEnabled = VAR_4;
VAR_3->mTransition = PortInfo::DISABLING;
for (size_t VAR_5 = 0; VAR_5 < VAR_3->mBuffers.size(); ++VAR_5) {
BufferInfo *VAR_6 = &VAR_3->mBuffers.editItemAt(VAR_5);
if (VAR_6->mOwnedByUs) {
VAR_6->mOwnedByUs = false;
if (VAR_3->mDef.eDir == VAR_7) {
notifyEmptyBufferDone(VAR_6->mHeader);
} else {
CHECK_EQ(VAR_3->mDef.eDir, VAR_8);
notifyFillBufferDone(VAR_6->mHeader);
}
}
}
VAR_3->mQueue.clear();
} else {
VAR_3->mTransition = PortInfo::ENABLING;
}
checkTransitions();
}",android/1e9801783770917728b7edbdeff3d0ec09c621ac/SimpleSoftOMXComponent.cpp/vul/before/0.json,"void SimpleSoftOMXComponent::onPortEnable(OMX_U32 portIndex, bool enable) {
    CHECK_LT(portIndex, mPorts.size());

    PortInfo *port = &mPorts.editItemAt(portIndex);
    CHECK_EQ((int)port->mTransition, (int)PortInfo::NONE);
    CHECK(port->mDef.bEnabled == !enable);

    if (port->mDef.eDir != OMX_DirOutput) {
        ALOGE(""Port enable/disable allowed only on output ports."");
        notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
        android_errorWriteLog(0x534e4554, ""29421804"");
        return;
    }

    if (!enable) {
        port->mDef.bEnabled = OMX_FALSE;
        port->mTransition = PortInfo::DISABLING;

        for (size_t i = 0; i < port->mBuffers.size(); ++i) {
            BufferInfo *buffer = &port->mBuffers.editItemAt(i);

            if (buffer->mOwnedByUs) {
                buffer->mOwnedByUs = false;

                if (port->mDef.eDir == OMX_DirInput) {
                    notifyEmptyBufferDone(buffer->mHeader);
                } else {
                    CHECK_EQ(port->mDef.eDir, OMX_DirOutput);
                    notifyFillBufferDone(buffer->mHeader);
                }
            }
        }

        port->mQueue.clear();
    } else {
        port->mTransition = PortInfo::ENABLING;
    }

    checkTransitions();
}","void SimpleSoftOMXComponent::onPortEnable(OMX_U32 VAR_0, bool VAR_1) {
    CHECK_LT(VAR_0, VAR_2.size());

    PortInfo *VAR_3 = &VAR_2.editItemAt(VAR_0);
    CHECK_EQ((int)VAR_3->mTransition, (int)PortInfo::NONE);
    CHECK(VAR_3->mDef.bEnabled == !VAR_1);

    if (VAR_3->mDef.eDir != VAR_4) {
        ALOGE(""Port enable/disable allowed only on output ports."");
        notify(VAR_5, VAR_6, 0, NULL);
        android_errorWriteLog(0x534e4554, ""29421804"");
        return;
    }

    if (!VAR_1) {
        VAR_3->mDef.bEnabled = VAR_7;
        VAR_3->mTransition = PortInfo::DISABLING;

        for (size_t VAR_8 = 0; VAR_8 < VAR_3->mBuffers.size(); ++VAR_8) {
            BufferInfo *VAR_9 = &VAR_3->mBuffers.editItemAt(VAR_8);

            if (VAR_9->mOwnedByUs) {
                VAR_9->mOwnedByUs = false;

                if (VAR_3->mDef.eDir == VAR_10) {
                    notifyEmptyBufferDone(VAR_9->mHeader);
                } else {
                    CHECK_EQ(VAR_3->mDef.eDir, VAR_4);
                    notifyFillBufferDone(VAR_9->mHeader);
                }
            }
        }

        VAR_3->mQueue.clear();
    } else {
        VAR_3->mTransition = PortInfo::ENABLING;
    }

    checkTransitions();
}",android/1e9801783770917728b7edbdeff3d0ec09c621ac/SimpleSoftOMXComponent.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,6 +4,13 @@
     PortInfo *port = &mPorts.editItemAt(portIndex);
     CHECK_EQ((int)port->mTransition, (int)PortInfo::NONE);
     CHECK(port->mDef.bEnabled == !enable);
+
+    if (port->mDef.eDir != OMX_DirOutput) {
+        ALOGE(""Port enable/disable allowed only on output ports."");
+        notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
+        android_errorWriteLog(0x534e4554, ""29421804"");
+        return;
+    }
 
     if (!enable) {
         port->mDef.bEnabled = OMX_FALSE;","{'deleted_lines': [], 'added_lines': ['', '    if (port->mDef.eDir != OMX_DirOutput) {', '        ALOGE(""Port enable/disable allowed only on output ports."");', '        notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);', '        android_errorWriteLog(0x534e4554, ""29421804"");', '        return;', '    }']}",True,"omx/SimpleSoftOMXComponent.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 does not prevent input-port changes, which allows attackers to gain privileges via a crafted application, aka internal bug 29421804.",7.8,HIGH,2,test,,5
CVE-2016-2181,['CWE-189'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,openssl,"
Fix DTLS replay protection

The DTLS implementation provides some protection against replay attacks
in accordance with RFC6347 section 4.1.2.6.

A sliding ""window"" of valid record sequence numbers is maintained with
the ""right"" hand edge of the window set to the highest sequence number we
have received so far. Records that arrive that are off the ""left"" hand
edge of the window are rejected. Records within the window are checked
against a list of records received so far. If we already received it then
we also reject the new record.

If we have not already received the record, or the sequence number is off
the right hand edge of the window then we verify the MAC of the record.
If MAC verification fails then we discard the record. Otherwise we mark
the record as received. If the sequence number was off the right hand edge
of the window, then we slide the window along so that the right hand edge
is in line with the newly received sequence number.

Records may arrive for future epochs, i.e. a record from after a CCS being
sent, can arrive before the CCS does if the packets get re-ordered. As we
have not yet received the CCS we are not yet in a position to decrypt or
validate the MAC of those records. OpenSSL places those records on an
unprocessed records queue. It additionally updates the window immediately,
even though we have not yet verified the MAC. This will only occur if
currently in a handshake/renegotiation.

This could be exploited by an attacker by sending a record for the next
epoch (which does not have to decrypt or have a valid MAC), with a very
large sequence number. This means the right hand edge of the window is
moved very far to the right, and all subsequent legitimate packets are
dropped causing a denial of service.

A similar effect can be achieved during the initial handshake. In this
case there is no MAC key negotiated yet. Therefore an attacker can send a
message for the current epoch with a very large sequence number. The code
will process the record as normal. If the hanshake message sequence number
(as opposed to the record sequence number that we have been talking about
so far) is in the future then the injected message is bufferred to be
handled later, but the window is still updated. Therefore all subsequent
legitimate handshake records are dropped. This aspect is not considered a
security issue because there are many ways for an attacker to disrupt the
initial handshake and prevent it from completing successfully (e.g.
injection of a handshake message will cause the Finished MAC to fail and
the handshake to be aborted). This issue comes about as a result of trying
to do replay protection, but having no integrity mechanism in place yet.
Does it even make sense to have replay protection in epoch 0? That
issue isn't addressed here though.

This addressed an OCAP Audit issue.

CVE-2016-2181

Reviewed-by: Richard Levitte <levitte@openssl.org>
",1fb9fdc3027b27d8eb6a1e6a846435b070980770,https://git.openssl.org/?p=openssl.git;a=commit;h=1fb9fdc3027b27d8eb6a1e6a846435b070980770,ssl/record/rec_layer_d1.c,dtls1_process_buffered_records,"int dtls1_process_buffered_records(SSL *s)
{
pitem *item;
SSL3_BUFFER *rb;
item = pqueue_peek(s->rlayer.d->unprocessed_rcds.q);
if (item) {
if (s->rlayer.d->unprocessed_rcds.epoch != s->rlayer.d->r_epoch)
return (1);         
rb = RECORD_LAYER_get_rbuf(&s->rlayer);
if (SSL3_BUFFER_get_left(rb) > 0) {
return 1;
}
while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {
dtls1_get_unprocessed_record(s);
if (!dtls1_process_record(s))
return (0);
if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),
SSL3_RECORD_get_seq_num(s->rlayer.rrec)) <
0)
return -1;
}
}
s->rlayer.d->processed_rcds.epoch = s->rlayer.d->r_epoch;
s->rlayer.d->unprocessed_rcds.epoch = s->rlayer.d->r_epoch + 1;
return (1);
}","int dtls1_process_buffered_records(SSL *VAR_0)
{
pitem *VAR_1;
SSL3_BUFFER *VAR_2;
VAR_1 = pqueue_peek(VAR_0->rlayer.d->unprocessed_rcds.q);
if (VAR_1) {
if (VAR_0->rlayer.d->unprocessed_rcds.epoch != VAR_0->rlayer.d->r_epoch)
return (1);         
VAR_2 = RECORD_LAYER_get_rbuf(&VAR_0->rlayer);
if (SSL3_BUFFER_get_left(VAR_2) > 0) {
return 1;
}
while (pqueue_peek(VAR_0->rlayer.d->unprocessed_rcds.q)) {
dtls1_get_unprocessed_record(VAR_0);
if (!dtls1_process_record(VAR_0))
return (0);
if (dtls1_buffer_record(VAR_0, &(VAR_0->rlayer.d->processed_rcds),
SSL3_RECORD_get_seq_num(VAR_0->rlayer.rrec)) <
0)
return -1;
}
}
VAR_0->rlayer.d->processed_rcds.epoch = VAR_0->rlayer.d->r_epoch;
VAR_0->rlayer.d->unprocessed_rcds.epoch = VAR_0->rlayer.d->r_epoch + 1;
return (1);
}",openssl/1fb9fdc3027b27d8eb6a1e6a846435b070980770/rec_layer_d1.c/vul/before/0.json,"int dtls1_process_buffered_records(SSL *s)
{
    pitem *item;
    SSL3_BUFFER *rb;
    SSL3_RECORD *rr;
    DTLS1_BITMAP *bitmap;
    unsigned int is_next_epoch;
    int replayok = 1;

    item = pqueue_peek(s->rlayer.d->unprocessed_rcds.q);
    if (item) {
        /* Check if epoch is current. */
        if (s->rlayer.d->unprocessed_rcds.epoch != s->rlayer.d->r_epoch)
            return 1;         /* Nothing to do. */

        rr = RECORD_LAYER_get_rrec(&s->rlayer);

        rb = RECORD_LAYER_get_rbuf(&s->rlayer);

        if (SSL3_BUFFER_get_left(rb) > 0) {
            /*
             * We've still got data from the current packet to read. There could
             * be a record from the new epoch in it - so don't overwrite it
             * with the unprocessed records yet (we'll do it when we've
             * finished reading the current packet).
             */
            return 1;
        }

        /* Process all the records. */
        while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {
            dtls1_get_unprocessed_record(s);
            bitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);
            if (bitmap == NULL) {
                /*
                 * Should not happen. This will only ever be NULL when the
                 * current record is from a different epoch. But that cannot
                 * be the case because we already checked the epoch above
                 */
                 SSLerr(SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS,
                        ERR_R_INTERNAL_ERROR);
                 return 0;
            }
#ifndef OPENSSL_NO_SCTP
            /* Only do replay check if no SCTP bio */
            if (!BIO_dgram_is_sctp(SSL_get_rbio(s)))
#endif
            {
                /*
                 * Check whether this is a repeat, or aged record. We did this
                 * check once already when we first received the record - but
                 * we might have updated the window since then due to
                 * records we subsequently processed.
                 */
                replayok = dtls1_record_replay_check(s, bitmap);
            }

            if (!replayok || !dtls1_process_record(s, bitmap)) {
                /* dump this record */
                rr->length = 0;
                RECORD_LAYER_reset_packet_length(&s->rlayer);
                continue;
            }

            if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),
                    SSL3_RECORD_get_seq_num(s->rlayer.rrec)) < 0)
                return 0;
        }
    }

    /*
     * sync epoch numbers once all the unprocessed records have been
     * processed
     */
    s->rlayer.d->processed_rcds.epoch = s->rlayer.d->r_epoch;
    s->rlayer.d->unprocessed_rcds.epoch = s->rlayer.d->r_epoch + 1;

    return 1;
}","int dtls1_process_buffered_records(SSL *VAR_0)
{
    pitem *VAR_1;
    SSL3_BUFFER *VAR_2;
    SSL3_RECORD *VAR_3;
    DTLS1_BITMAP *VAR_4;
    unsigned int VAR_5;
    int VAR_6 = 1;

    VAR_1 = pqueue_peek(VAR_0->rlayer.d->unprocessed_rcds.q);
    if (VAR_1) {
        /* COMMENT_0 */
        if (VAR_0->rlayer.d->unprocessed_rcds.epoch != VAR_0->rlayer.d->r_epoch)
            return 1;         /* COMMENT_1 */

        VAR_3 = RECORD_LAYER_get_rrec(&VAR_0->rlayer);

        VAR_2 = RECORD_LAYER_get_rbuf(&VAR_0->rlayer);

        if (SSL3_BUFFER_get_left(VAR_2) > 0) {
            /* COMMENT_2 */
                                                                                
                                                                           
                                                                       
                                                    
               
            return 1;
        }

        /* COMMENT_8 */
        while (pqueue_peek(VAR_0->rlayer.d->unprocessed_rcds.q)) {
            dtls1_get_unprocessed_record(VAR_0);
            VAR_4 = dtls1_get_bitmap(VAR_0, VAR_3, &VAR_5);
            if (VAR_4 == NULL) {
                /* COMMENT_9 */
                                                                          
                                                                            
                                                                         
                   
                 SSLerr(VAR_7,
                        VAR_8);
                 return 0;
            }
#ifndef VAR_9
            /* COMMENT_14 */
            if (!BIO_dgram_is_sctp(SSL_get_rbio(VAR_0)))
#endif
            {
                /* COMMENT_15 */
                                                                              
                                                                             
                                                                     
                                                     
                   
                VAR_6 = dtls1_record_replay_check(VAR_0, VAR_4);
            }

            if (!VAR_6 || !dtls1_process_record(VAR_0, VAR_4)) {
                /* COMMENT_21 */
                VAR_3->length = 0;
                RECORD_LAYER_reset_packet_length(&VAR_0->rlayer);
                continue;
            }

            if (dtls1_buffer_record(VAR_0, &(VAR_0->rlayer.d->processed_rcds),
                    SSL3_RECORD_get_seq_num(VAR_0->rlayer.rrec)) < 0)
                return 0;
        }
    }

    /* COMMENT_22 */
                                                                    
                
       
    VAR_0->rlayer.d->processed_rcds.epoch = VAR_0->rlayer.d->r_epoch;
    VAR_0->rlayer.d->unprocessed_rcds.epoch = VAR_0->rlayer.d->r_epoch + 1;

    return 1;
}",openssl/1fb9fdc3027b27d8eb6a1e6a846435b070980770/rec_layer_d1.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,12 +2,18 @@
 {
     pitem *item;
     SSL3_BUFFER *rb;
+    SSL3_RECORD *rr;
+    DTLS1_BITMAP *bitmap;
+    unsigned int is_next_epoch;
+    int replayok = 1;
 
     item = pqueue_peek(s->rlayer.d->unprocessed_rcds.q);
     if (item) {
         /* Check if epoch is current. */
         if (s->rlayer.d->unprocessed_rcds.epoch != s->rlayer.d->r_epoch)
-            return (1);         /* Nothing to do. */
+            return 1;         /* Nothing to do. */
+
+        rr = RECORD_LAYER_get_rrec(&s->rlayer);
 
         rb = RECORD_LAYER_get_rbuf(&s->rlayer);
 
@@ -24,12 +30,41 @@
         /* Process all the records. */
         while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {
             dtls1_get_unprocessed_record(s);
-            if (!dtls1_process_record(s))
-                return (0);
+            bitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);
+            if (bitmap == NULL) {
+                /*
+                 * Should not happen. This will only ever be NULL when the
+                 * current record is from a different epoch. But that cannot
+                 * be the case because we already checked the epoch above
+                 */
+                 SSLerr(SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS,
+                        ERR_R_INTERNAL_ERROR);
+                 return 0;
+            }
+#ifndef OPENSSL_NO_SCTP
+            /* Only do replay check if no SCTP bio */
+            if (!BIO_dgram_is_sctp(SSL_get_rbio(s)))
+#endif
+            {
+                /*
+                 * Check whether this is a repeat, or aged record. We did this
+                 * check once already when we first received the record - but
+                 * we might have updated the window since then due to
+                 * records we subsequently processed.
+                 */
+                replayok = dtls1_record_replay_check(s, bitmap);
+            }
+
+            if (!replayok || !dtls1_process_record(s, bitmap)) {
+                /* dump this record */
+                rr->length = 0;
+                RECORD_LAYER_reset_packet_length(&s->rlayer);
+                continue;
+            }
+
             if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),
-                                    SSL3_RECORD_get_seq_num(s->rlayer.rrec)) <
-                0)
-                return -1;
+                    SSL3_RECORD_get_seq_num(s->rlayer.rrec)) < 0)
+                return 0;
         }
     }
 
@@ -40,5 +75,5 @@
     s->rlayer.d->processed_rcds.epoch = s->rlayer.d->r_epoch;
     s->rlayer.d->unprocessed_rcds.epoch = s->rlayer.d->r_epoch + 1;
 
-    return (1);
+    return 1;
 }","{'deleted_lines': ['            return (1);         /* Nothing to do. */', '            if (!dtls1_process_record(s))', '                return (0);', '                                    SSL3_RECORD_get_seq_num(s->rlayer.rrec)) <', '                0)', '                return -1;', '    return (1);'], 'added_lines': ['    SSL3_RECORD *rr;', '    DTLS1_BITMAP *bitmap;', '    unsigned int is_next_epoch;', '    int replayok = 1;', '            return 1;         /* Nothing to do. */', '', '        rr = RECORD_LAYER_get_rrec(&s->rlayer);', '            bitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);', '            if (bitmap == NULL) {', '                /*', '                 * Should not happen. This will only ever be NULL when the', '                 * current record is from a different epoch. But that cannot', '                 * be the case because we already checked the epoch above', '                 */', '                 SSLerr(SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS,', '                        ERR_R_INTERNAL_ERROR);', '                 return 0;', '            }', '#ifndef OPENSSL_NO_SCTP', '            /* Only do replay check if no SCTP bio */', '            if (!BIO_dgram_is_sctp(SSL_get_rbio(s)))', '#endif', '            {', '                /*', '                 * Check whether this is a repeat, or aged record. We did this', '                 * check once already when we first received the record - but', '                 * we might have updated the window since then due to', '                 * records we subsequently processed.', '                 */', '                replayok = dtls1_record_replay_check(s, bitmap);', '            }', '', '            if (!replayok || !dtls1_process_record(s, bitmap)) {', '                /* dump this record */', '                rr->length = 0;', '                RECORD_LAYER_reset_packet_length(&s->rlayer);', '                continue;', '            }', '', '                    SSL3_RECORD_get_seq_num(s->rlayer.rrec)) < 0)', '                return 0;', '    return 1;']}",True,"The Anti-Replay feature in the DTLS implementation in OpenSSL before 1.1.0 mishandles early use of a new epoch number in conjunction with a large sequence number, which allows remote attackers to cause a denial of service (false-positive packet drops) via spoofed DTLS records, related to rec_layer_d1.c and ssl3_record.c.",7.5,HIGH,2,test,,5
CVE-2016-2181,['CWE-189'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,openssl,"
Fix DTLS replay protection

The DTLS implementation provides some protection against replay attacks
in accordance with RFC6347 section 4.1.2.6.

A sliding ""window"" of valid record sequence numbers is maintained with
the ""right"" hand edge of the window set to the highest sequence number we
have received so far. Records that arrive that are off the ""left"" hand
edge of the window are rejected. Records within the window are checked
against a list of records received so far. If we already received it then
we also reject the new record.

If we have not already received the record, or the sequence number is off
the right hand edge of the window then we verify the MAC of the record.
If MAC verification fails then we discard the record. Otherwise we mark
the record as received. If the sequence number was off the right hand edge
of the window, then we slide the window along so that the right hand edge
is in line with the newly received sequence number.

Records may arrive for future epochs, i.e. a record from after a CCS being
sent, can arrive before the CCS does if the packets get re-ordered. As we
have not yet received the CCS we are not yet in a position to decrypt or
validate the MAC of those records. OpenSSL places those records on an
unprocessed records queue. It additionally updates the window immediately,
even though we have not yet verified the MAC. This will only occur if
currently in a handshake/renegotiation.

This could be exploited by an attacker by sending a record for the next
epoch (which does not have to decrypt or have a valid MAC), with a very
large sequence number. This means the right hand edge of the window is
moved very far to the right, and all subsequent legitimate packets are
dropped causing a denial of service.

A similar effect can be achieved during the initial handshake. In this
case there is no MAC key negotiated yet. Therefore an attacker can send a
message for the current epoch with a very large sequence number. The code
will process the record as normal. If the hanshake message sequence number
(as opposed to the record sequence number that we have been talking about
so far) is in the future then the injected message is bufferred to be
handled later, but the window is still updated. Therefore all subsequent
legitimate handshake records are dropped. This aspect is not considered a
security issue because there are many ways for an attacker to disrupt the
initial handshake and prevent it from completing successfully (e.g.
injection of a handshake message will cause the Finished MAC to fail and
the handshake to be aborted). This issue comes about as a result of trying
to do replay protection, but having no integrity mechanism in place yet.
Does it even make sense to have replay protection in epoch 0? That
issue isn't addressed here though.

This addressed an OCAP Audit issue.

CVE-2016-2181

Reviewed-by: Richard Levitte <levitte@openssl.org>
",1fb9fdc3027b27d8eb6a1e6a846435b070980770,https://git.openssl.org/?p=openssl.git;a=commit;h=1fb9fdc3027b27d8eb6a1e6a846435b070980770,ssl/record/ssl3_record.c,dtls1_get_record,"int dtls1_get_record(SSL *s)
{
int ssl_major, ssl_minor;
int i, n;
SSL3_RECORD *rr;
unsigned char *p = NULL;
unsigned short version;
DTLS1_BITMAP *bitmap;
unsigned int is_next_epoch;
rr = RECORD_LAYER_get_rrec(&s->rlayer);
again:
if (dtls1_process_buffered_records(s) < 0)
return -1;
if (dtls1_get_processed_record(s))
return 1;
if ((RECORD_LAYER_get_rstate(&s->rlayer) != SSL_ST_READ_BODY) ||
(RECORD_LAYER_get_packet_length(&s->rlayer) < DTLS1_RT_HEADER_LENGTH)) {
n = ssl3_read_n(s, DTLS1_RT_HEADER_LENGTH,
SSL3_BUFFER_get_len(&s->rlayer.rbuf), 0, 1);
if (n <= 0)
return (n);         
if (RECORD_LAYER_get_packet_length(&s->rlayer) !=
DTLS1_RT_HEADER_LENGTH) {
RECORD_LAYER_reset_packet_length(&s->rlayer);
goto again;
}
RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_BODY);
p = RECORD_LAYER_get_packet(&s->rlayer);
if (s->msg_callback)
s->msg_callback(0, 0, SSL3_RT_HEADER, p, DTLS1_RT_HEADER_LENGTH,
s, s->msg_callback_arg);
rr->type = *(p++);
ssl_major = *(p++);
ssl_minor = *(p++);
version = (ssl_major << 8) | ssl_minor;
n2s(p, rr->epoch);
memcpy(&(RECORD_LAYER_get_read_sequence(&s->rlayer)[2]), p, 6);
p += 6;
n2s(p, rr->length);
if (!s->first_packet) {
if (version != s->version) {
rr->length = 0;
RECORD_LAYER_reset_packet_length(&s->rlayer);
goto again;
}
}
if ((version & 0xff00) != (s->version & 0xff00)) {
rr->length = 0;
RECORD_LAYER_reset_packet_length(&s->rlayer);
goto again;
}
if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {
rr->length = 0;
RECORD_LAYER_reset_packet_length(&s->rlayer);
goto again;
}
}
if (rr->length >
RECORD_LAYER_get_packet_length(&s->rlayer) - DTLS1_RT_HEADER_LENGTH) {
i = rr->length;
n = ssl3_read_n(s, i, i, 1, 1);
if (n != i) {
rr->length = 0;
RECORD_LAYER_reset_packet_length(&s->rlayer);
goto again;
}
}
RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_HEADER);
bitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);
if (bitmap == NULL) {
rr->length = 0;
RECORD_LAYER_reset_packet_length(&s->rlayer); 
goto again;             
}
#ifndef OPENSSL_NO_SCTP
if (!BIO_dgram_is_sctp(SSL_get_rbio(s))) {
#endif
if (!dtls1_record_replay_check(s, bitmap)) {
rr->length = 0;
RECORD_LAYER_reset_packet_length(&s->rlayer); 
goto again;         
}
#ifndef OPENSSL_NO_SCTP
}
#endif
if (rr->length == 0)
goto again;
if (is_next_epoch) {
if ((SSL_in_init(s) || ossl_statem_get_in_handshake(s))) {
if (dtls1_buffer_record
(s, &(DTLS_RECORD_LAYER_get_unprocessed_rcds(&s->rlayer)),
rr->seq_num) < 0)
return -1;
dtls1_record_bitmap_update(s, bitmap);
}
rr->length = 0;
RECORD_LAYER_reset_packet_length(&s->rlayer);
goto again;
}
if (!dtls1_process_record(s)) {
rr->length = 0;
RECORD_LAYER_reset_packet_length(&s->rlayer); 
goto again;             
}
dtls1_record_bitmap_update(s, bitmap); 
return (1);
}","int dtls1_get_record(SSL *VAR_0)
{
int VAR_1, VAR_2;
int VAR_3, VAR_4;
SSL3_RECORD *VAR_5;
unsigned char *VAR_6 = NULL;
unsigned short VAR_7;
DTLS1_BITMAP *VAR_8;
unsigned int VAR_9;
VAR_5 = RECORD_LAYER_get_rrec(&VAR_0->rlayer);
again:
if (dtls1_process_buffered_records(VAR_0) < 0)
return -1;
if (dtls1_get_processed_record(VAR_0))
return 1;
if ((RECORD_LAYER_get_rstate(&VAR_0->rlayer) != VAR_10) ||
(RECORD_LAYER_get_packet_length(&VAR_0->rlayer) < VAR_11)) {
VAR_4 = ssl3_read_n(VAR_0, VAR_11,
SSL3_BUFFER_get_len(&VAR_0->rlayer.rbuf), 0, 1);
if (VAR_4 <= 0)
return (VAR_4);         
if (RECORD_LAYER_get_packet_length(&VAR_0->rlayer) !=
VAR_11) {
RECORD_LAYER_reset_packet_length(&VAR_0->rlayer);
goto again;
}
RECORD_LAYER_set_rstate(&VAR_0->rlayer, VAR_10);
VAR_6 = RECORD_LAYER_get_packet(&VAR_0->rlayer);
if (VAR_0->msg_callback)
VAR_0->msg_callback(0, 0, VAR_12, VAR_6, VAR_11,
VAR_0, VAR_0->msg_callback_arg);
VAR_5->type = *(VAR_6++);
VAR_1 = *(VAR_6++);
VAR_2 = *(VAR_6++);
VAR_7 = (VAR_1 << 8) | VAR_2;
n2s(VAR_6, VAR_5->epoch);
memcpy(&(RECORD_LAYER_get_read_sequence(&VAR_0->rlayer)[2]), VAR_6, 6);
VAR_6 += 6;
n2s(VAR_6, VAR_5->length);
if (!VAR_0->first_packet) {
if (VAR_7 != VAR_0->version) {
VAR_5->length = 0;
RECORD_LAYER_reset_packet_length(&VAR_0->rlayer);
goto again;
}
}
if ((VAR_7 & 0xff00) != (VAR_0->version & 0xff00)) {
VAR_5->length = 0;
RECORD_LAYER_reset_packet_length(&VAR_0->rlayer);
goto again;
}
if (VAR_5->length > VAR_13) {
VAR_5->length = 0;
RECORD_LAYER_reset_packet_length(&VAR_0->rlayer);
goto again;
}
}
if (VAR_5->length >
RECORD_LAYER_get_packet_length(&VAR_0->rlayer) - VAR_11) {
VAR_3 = VAR_5->length;
VAR_4 = ssl3_read_n(VAR_0, VAR_3, VAR_3, 1, 1);
if (VAR_4 != VAR_3) {
VAR_5->length = 0;
RECORD_LAYER_reset_packet_length(&VAR_0->rlayer);
goto again;
}
}
RECORD_LAYER_set_rstate(&VAR_0->rlayer, VAR_14);
VAR_8 = dtls1_get_bitmap(VAR_0, VAR_5, &VAR_9);
if (VAR_8 == NULL) {
VAR_5->length = 0;
RECORD_LAYER_reset_packet_length(&VAR_0->rlayer); 
goto again;             
}
#ifndef VAR_15
if (!BIO_dgram_is_sctp(SSL_get_rbio(VAR_0))) {
#endif
if (!dtls1_record_replay_check(s, bitmap)) {
VAR_5->length = 0;
RECORD_LAYER_reset_packet_length(&VAR_0->rlayer); 
goto again;         
}
#ifndef VAR_15
}
#endif
if (VAR_5->length == 0)
goto again;
if (VAR_9) {
if ((SSL_in_init(VAR_0) || ossl_statem_get_in_handshake(VAR_0))) {
if (dtls1_buffer_record
(VAR_0, &(DTLS_RECORD_LAYER_get_unprocessed_rcds(&VAR_0->rlayer)),
VAR_5->seq_num) < 0)
return -1;
dtls1_record_bitmap_update(VAR_0, VAR_8);
}
VAR_5->length = 0;
RECORD_LAYER_reset_packet_length(&VAR_0->rlayer);
goto again;
}
if (!dtls1_process_record(VAR_0)) {
VAR_5->length = 0;
RECORD_LAYER_reset_packet_length(&VAR_0->rlayer); 
goto again;             
}
dtls1_record_bitmap_update(VAR_0, VAR_8); 
return (1);
}",openssl/1fb9fdc3027b27d8eb6a1e6a846435b070980770/ssl3_record.c/vul/before/0.json,"int dtls1_get_record(SSL *s)
{
    int ssl_major, ssl_minor;
    int i, n;
    SSL3_RECORD *rr;
    unsigned char *p = NULL;
    unsigned short version;
    DTLS1_BITMAP *bitmap;
    unsigned int is_next_epoch;

    rr = RECORD_LAYER_get_rrec(&s->rlayer);

 again:
    /*
     * The epoch may have changed.  If so, process all the pending records.
     * This is a non-blocking operation.
     */
    if (!dtls1_process_buffered_records(s))
        return -1;

    /* if we're renegotiating, then there may be buffered records */
    if (dtls1_get_processed_record(s))
        return 1;

    /* get something from the wire */

    /* check if we have the header */
    if ((RECORD_LAYER_get_rstate(&s->rlayer) != SSL_ST_READ_BODY) ||
        (RECORD_LAYER_get_packet_length(&s->rlayer) < DTLS1_RT_HEADER_LENGTH)) {
        n = ssl3_read_n(s, DTLS1_RT_HEADER_LENGTH,
                        SSL3_BUFFER_get_len(&s->rlayer.rbuf), 0, 1);
        /* read timeout is handled by dtls1_read_bytes */
        if (n <= 0)
            return (n);         /* error or non-blocking */

        /* this packet contained a partial record, dump it */
        if (RECORD_LAYER_get_packet_length(&s->rlayer) !=
            DTLS1_RT_HEADER_LENGTH) {
            RECORD_LAYER_reset_packet_length(&s->rlayer);
            goto again;
        }

        RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_BODY);

        p = RECORD_LAYER_get_packet(&s->rlayer);

        if (s->msg_callback)
            s->msg_callback(0, 0, SSL3_RT_HEADER, p, DTLS1_RT_HEADER_LENGTH,
                            s, s->msg_callback_arg);

        /* Pull apart the header into the DTLS1_RECORD */
        rr->type = *(p++);
        ssl_major = *(p++);
        ssl_minor = *(p++);
        version = (ssl_major << 8) | ssl_minor;

        /* sequence number is 64 bits, with top 2 bytes = epoch */
        n2s(p, rr->epoch);

        memcpy(&(RECORD_LAYER_get_read_sequence(&s->rlayer)[2]), p, 6);
        p += 6;

        n2s(p, rr->length);

        /* Lets check version */
        if (!s->first_packet) {
            if (version != s->version) {
                /* unexpected version, silently discard */
                rr->length = 0;
                RECORD_LAYER_reset_packet_length(&s->rlayer);
                goto again;
            }
        }

        if ((version & 0xff00) != (s->version & 0xff00)) {
            /* wrong version, silently discard record */
            rr->length = 0;
            RECORD_LAYER_reset_packet_length(&s->rlayer);
            goto again;
        }

        if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {
            /* record too long, silently discard it */
            rr->length = 0;
            RECORD_LAYER_reset_packet_length(&s->rlayer);
            goto again;
        }

        /* now s->rlayer.rstate == SSL_ST_READ_BODY */
    }

    /* s->rlayer.rstate == SSL_ST_READ_BODY, get and decode the data */

    if (rr->length >
        RECORD_LAYER_get_packet_length(&s->rlayer) - DTLS1_RT_HEADER_LENGTH) {
        /* now s->packet_length == DTLS1_RT_HEADER_LENGTH */
        i = rr->length;
        n = ssl3_read_n(s, i, i, 1, 1);
        /* this packet contained a partial record, dump it */
        if (n != i) {
            rr->length = 0;
            RECORD_LAYER_reset_packet_length(&s->rlayer);
            goto again;
        }

        /*
         * now n == rr->length, and s->packet_length ==
         * DTLS1_RT_HEADER_LENGTH + rr->length
         */
    }
    /* set state for later operations */
    RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_HEADER);

    /* match epochs.  NULL means the packet is dropped on the floor */
    bitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);
    if (bitmap == NULL) {
        rr->length = 0;
        RECORD_LAYER_reset_packet_length(&s->rlayer); /* dump this record */
        goto again;             /* get another record */
    }
#ifndef OPENSSL_NO_SCTP
    /* Only do replay check if no SCTP bio */
    if (!BIO_dgram_is_sctp(SSL_get_rbio(s))) {
#endif
        /* Check whether this is a repeat, or aged record. */
        /*
         * TODO: Does it make sense to have replay protection in epoch 0 where
         * we have no integrity negotiated yet?
         */
        if (!dtls1_record_replay_check(s, bitmap)) {
            rr->length = 0;
            RECORD_LAYER_reset_packet_length(&s->rlayer); /* dump this record */
            goto again;         /* get another record */
        }
#ifndef OPENSSL_NO_SCTP
    }
#endif

    /* just read a 0 length packet */
    if (rr->length == 0)
        goto again;

    /*
     * If this record is from the next epoch (either HM or ALERT), and a
     * handshake is currently in progress, buffer it since it cannot be
     * processed at this time.
     */
    if (is_next_epoch) {
        if ((SSL_in_init(s) || ossl_statem_get_in_handshake(s))) {
            if (dtls1_buffer_record
                (s, &(DTLS_RECORD_LAYER_get_unprocessed_rcds(&s->rlayer)),
                 rr->seq_num) < 0)
                return -1;
        }
        rr->length = 0;
        RECORD_LAYER_reset_packet_length(&s->rlayer);
        goto again;
    }

    if (!dtls1_process_record(s, bitmap)) {
        rr->length = 0;
        RECORD_LAYER_reset_packet_length(&s->rlayer); /* dump this record */
        goto again;             /* get another record */
    }

    return (1);

}","int dtls1_get_record(SSL *VAR_0)
{
    int VAR_1, VAR_2;
    int VAR_3, VAR_4;
    SSL3_RECORD *VAR_5;
    unsigned char *VAR_6 = NULL;
    unsigned short VAR_7;
    DTLS1_BITMAP *VAR_8;
    unsigned int VAR_9;

    VAR_5 = RECORD_LAYER_get_rrec(&VAR_0->rlayer);

 again:
    /* COMMENT_0 */
                                                                           
                                        
       
    if (!dtls1_process_buffered_records(VAR_0))
        return -1;

    /* COMMENT_4 */
    if (dtls1_get_processed_record(VAR_0))
        return 1;

    /* COMMENT_5 */

    /* COMMENT_6 */
    if ((RECORD_LAYER_get_rstate(&VAR_0->rlayer) != VAR_10) ||
        (RECORD_LAYER_get_packet_length(&VAR_0->rlayer) < VAR_11)) {
        VAR_4 = ssl3_read_n(VAR_0, VAR_11,
                        SSL3_BUFFER_get_len(&VAR_0->rlayer.rbuf), 0, 1);
        /* COMMENT_7 */
        if (VAR_4 <= 0)
            return (VAR_4);         /* COMMENT_8 */

        /* COMMENT_9 */
        if (RECORD_LAYER_get_packet_length(&VAR_0->rlayer) !=
            VAR_11) {
            RECORD_LAYER_reset_packet_length(&VAR_0->rlayer);
            goto again;
        }

        RECORD_LAYER_set_rstate(&VAR_0->rlayer, VAR_10);

        VAR_6 = RECORD_LAYER_get_packet(&VAR_0->rlayer);

        if (VAR_0->msg_callback)
            VAR_0->msg_callback(0, 0, VAR_12, VAR_6, VAR_11,
                            VAR_0, VAR_0->msg_callback_arg);

        /* COMMENT_10 */
        VAR_5->type = *(VAR_6++);
        VAR_1 = *(VAR_6++);
        VAR_2 = *(VAR_6++);
        VAR_7 = (VAR_1 << 8) | VAR_2;

        /* COMMENT_11 */
        n2s(VAR_6, VAR_5->epoch);

        memcpy(&(RECORD_LAYER_get_read_sequence(&VAR_0->rlayer)[2]), VAR_6, 6);
        VAR_6 += 6;

        n2s(VAR_6, VAR_5->length);

        /* COMMENT_12 */
        if (!VAR_0->first_packet) {
            if (VAR_7 != VAR_0->version) {
                /* COMMENT_13 */
                VAR_5->length = 0;
                RECORD_LAYER_reset_packet_length(&VAR_0->rlayer);
                goto again;
            }
        }

        if ((VAR_7 & 0xff00) != (VAR_0->version & 0xff00)) {
            /* COMMENT_14 */
            VAR_5->length = 0;
            RECORD_LAYER_reset_packet_length(&VAR_0->rlayer);
            goto again;
        }

        if (VAR_5->length > VAR_13) {
            /* COMMENT_15 */
            VAR_5->length = 0;
            RECORD_LAYER_reset_packet_length(&VAR_0->rlayer);
            goto again;
        }

        /* COMMENT_16 */
    }

    /* COMMENT_17 */

    if (VAR_5->length >
        RECORD_LAYER_get_packet_length(&VAR_0->rlayer) - VAR_11) {
        /* COMMENT_18 */
        VAR_3 = VAR_5->length;
        VAR_4 = ssl3_read_n(VAR_0, VAR_3, VAR_3, 1, 1);
        /* COMMENT_9 */
        if (VAR_4 != VAR_3) {
            VAR_5->length = 0;
            RECORD_LAYER_reset_packet_length(&VAR_0->rlayer);
            goto again;
        }

        /* COMMENT_19 */
                                                       
                                              
           
    }
    /* COMMENT_23 */
    RECORD_LAYER_set_rstate(&VAR_0->rlayer, VAR_14);

    /* COMMENT_24 */
    VAR_8 = dtls1_get_bitmap(VAR_0, VAR_5, &VAR_9);
    if (VAR_8 == NULL) {
        VAR_5->length = 0;
        RECORD_LAYER_reset_packet_length(&VAR_0->rlayer); /* COMMENT_25 */
        goto again;             /* COMMENT_26 */
    }
#ifndef VAR_15
    /* COMMENT_27 */
    if (!BIO_dgram_is_sctp(SSL_get_rbio(VAR_0))) {
#endif/* COMMENT_28 */
                                                             /* COMMENT_30 */
          
                                                                              
                                               
           
        if (!dtls1_record_replay_check(s, bitmap)) {
            VAR_5->length = 0;
            RECORD_LAYER_reset_packet_length(&VAR_0->rlayer); /* COMMENT_25 */
            goto again;         /* COMMENT_26 */
        }
#ifndef VAR_15
    }
#endif

    /* COMMENT_35 */
    if (VAR_5->length == 0)
        goto again;

    /* COMMENT_36 */
                                                                        
                                                                       
                              
       
    if (VAR_9) {
        if ((SSL_in_init(VAR_0) || ossl_statem_get_in_handshake(VAR_0))) {
            if (dtls1_buffer_record
                (VAR_0, &(DTLS_RECORD_LAYER_get_unprocessed_rcds(&VAR_0->rlayer)),
                 VAR_5->seq_num) < 0)
                return -1;
        }
        VAR_5->length = 0;
        RECORD_LAYER_reset_packet_length(&VAR_0->rlayer);
        goto again;
    }

    if (!dtls1_process_record(VAR_0, VAR_8)) {
        VAR_5->length = 0;
        RECORD_LAYER_reset_packet_length(&VAR_0->rlayer); /* COMMENT_25 */
        goto again;             /* COMMENT_26 */
    }

    return (1);

}",openssl/1fb9fdc3027b27d8eb6a1e6a846435b070980770/ssl3_record.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -15,7 +15,7 @@
      * The epoch may have changed.  If so, process all the pending records.
      * This is a non-blocking operation.
      */
-    if (dtls1_process_buffered_records(s) < 0)
+    if (!dtls1_process_buffered_records(s))
         return -1;
 
     /* if we're renegotiating, then there may be buffered records */
@@ -123,6 +123,10 @@
     if (!BIO_dgram_is_sctp(SSL_get_rbio(s))) {
 #endif
         /* Check whether this is a repeat, or aged record. */
+        /*
+         * TODO: Does it make sense to have replay protection in epoch 0 where
+         * we have no integrity negotiated yet?
+         */
         if (!dtls1_record_replay_check(s, bitmap)) {
             rr->length = 0;
             RECORD_LAYER_reset_packet_length(&s->rlayer); /* dump this record */
@@ -147,20 +151,17 @@
                 (s, &(DTLS_RECORD_LAYER_get_unprocessed_rcds(&s->rlayer)),
                  rr->seq_num) < 0)
                 return -1;
-            /* Mark receipt of record. */
-            dtls1_record_bitmap_update(s, bitmap);
         }
         rr->length = 0;
         RECORD_LAYER_reset_packet_length(&s->rlayer);
         goto again;
     }
 
-    if (!dtls1_process_record(s)) {
+    if (!dtls1_process_record(s, bitmap)) {
         rr->length = 0;
         RECORD_LAYER_reset_packet_length(&s->rlayer); /* dump this record */
         goto again;             /* get another record */
     }
-    dtls1_record_bitmap_update(s, bitmap); /* Mark receipt of record. */
 
     return (1);
 ","{'deleted_lines': ['    if (dtls1_process_buffered_records(s) < 0)', '            /* Mark receipt of record. */', '            dtls1_record_bitmap_update(s, bitmap);', '    if (!dtls1_process_record(s)) {', '    dtls1_record_bitmap_update(s, bitmap); /* Mark receipt of record. */'], 'added_lines': ['    if (!dtls1_process_buffered_records(s))', '        /*', '         * TODO: Does it make sense to have replay protection in epoch 0 where', '         * we have no integrity negotiated yet?', '         */', '    if (!dtls1_process_record(s, bitmap)) {']}",True,"The Anti-Replay feature in the DTLS implementation in OpenSSL before 1.1.0 mishandles early use of a new epoch number in conjunction with a large sequence number, which allows remote attackers to cause a denial of service (false-positive packet drops) via spoofed DTLS records, related to rec_layer_d1.c and ssl3_record.c.",7.5,HIGH,2,test,,5
CVE-2016-2181,['CWE-189'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,openssl,"
Fix DTLS replay protection

The DTLS implementation provides some protection against replay attacks
in accordance with RFC6347 section 4.1.2.6.

A sliding ""window"" of valid record sequence numbers is maintained with
the ""right"" hand edge of the window set to the highest sequence number we
have received so far. Records that arrive that are off the ""left"" hand
edge of the window are rejected. Records within the window are checked
against a list of records received so far. If we already received it then
we also reject the new record.

If we have not already received the record, or the sequence number is off
the right hand edge of the window then we verify the MAC of the record.
If MAC verification fails then we discard the record. Otherwise we mark
the record as received. If the sequence number was off the right hand edge
of the window, then we slide the window along so that the right hand edge
is in line with the newly received sequence number.

Records may arrive for future epochs, i.e. a record from after a CCS being
sent, can arrive before the CCS does if the packets get re-ordered. As we
have not yet received the CCS we are not yet in a position to decrypt or
validate the MAC of those records. OpenSSL places those records on an
unprocessed records queue. It additionally updates the window immediately,
even though we have not yet verified the MAC. This will only occur if
currently in a handshake/renegotiation.

This could be exploited by an attacker by sending a record for the next
epoch (which does not have to decrypt or have a valid MAC), with a very
large sequence number. This means the right hand edge of the window is
moved very far to the right, and all subsequent legitimate packets are
dropped causing a denial of service.

A similar effect can be achieved during the initial handshake. In this
case there is no MAC key negotiated yet. Therefore an attacker can send a
message for the current epoch with a very large sequence number. The code
will process the record as normal. If the hanshake message sequence number
(as opposed to the record sequence number that we have been talking about
so far) is in the future then the injected message is bufferred to be
handled later, but the window is still updated. Therefore all subsequent
legitimate handshake records are dropped. This aspect is not considered a
security issue because there are many ways for an attacker to disrupt the
initial handshake and prevent it from completing successfully (e.g.
injection of a handshake message will cause the Finished MAC to fail and
the handshake to be aborted). This issue comes about as a result of trying
to do replay protection, but having no integrity mechanism in place yet.
Does it even make sense to have replay protection in epoch 0? That
issue isn't addressed here though.

This addressed an OCAP Audit issue.

CVE-2016-2181

Reviewed-by: Richard Levitte <levitte@openssl.org>
",1fb9fdc3027b27d8eb6a1e6a846435b070980770,https://git.openssl.org/?p=openssl.git;a=commit;h=1fb9fdc3027b27d8eb6a1e6a846435b070980770,ssl/record/ssl3_record.c,dtls1_process_record,"int dtls1_process_record(SSL *s)
{
int i, al;
int enc_err;
SSL_SESSION *sess;
SSL3_RECORD *rr;
unsigned int mac_size;
unsigned char md[EVP_MAX_MD_SIZE];
rr = RECORD_LAYER_get_rrec(&s->rlayer);
sess = s->session;
rr->input = &(RECORD_LAYER_get_packet(&s->rlayer)[DTLS1_RT_HEADER_LENGTH]);
if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {
al = SSL_AD_RECORD_OVERFLOW;
SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);
goto f_err;
}
rr->data = rr->input;
rr->orig_len = rr->length;
enc_err = s->method->ssl3_enc->enc(s, rr, 1, 0);
if (enc_err == 0) {
rr->length = 0;
RECORD_LAYER_reset_packet_length(&s->rlayer);
goto err;
}
#ifdef SSL_DEBUG
printf(""dec %d\n"", rr->length);
{
unsigned int z;
for (z = 0; z < rr->length; z++)
printf(""%02X%c"", rr->data[z], ((z + 1) % 16) ? ' ' : '\n');
}
printf(""\n"");
#endif
if ((sess != NULL) &&
(s->enc_read_ctx != NULL) && (EVP_MD_CTX_md(s->read_hash) != NULL)) {
unsigned char *mac = NULL;
unsigned char mac_tmp[EVP_MAX_MD_SIZE];
mac_size = EVP_MD_CTX_size(s->read_hash);
OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);
if (rr->orig_len < mac_size ||
(EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
rr->orig_len < mac_size + 1)) {
al = SSL_AD_DECODE_ERROR;
SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_LENGTH_TOO_SHORT);
goto f_err;
}
if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE) {
mac = mac_tmp;
ssl3_cbc_copy_mac(mac_tmp, rr, mac_size);
rr->length -= mac_size;
} else {
rr->length -= mac_size;
mac = &rr->data[rr->length];
}
i = s->method->ssl3_enc->mac(s, rr, md, 0  );
if (i < 0 || mac == NULL
|| CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)
enc_err = -1;
if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size)
enc_err = -1;
}
if (enc_err < 0) {
rr->length = 0;
RECORD_LAYER_reset_packet_length(&s->rlayer);
goto err;
}
if (s->expand != NULL) {
if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH) {
al = SSL_AD_RECORD_OVERFLOW;
SSLerr(SSL_F_DTLS1_PROCESS_RECORD,
SSL_R_COMPRESSED_LENGTH_TOO_LONG);
goto f_err;
}
if (!ssl3_do_uncompress(s, rr)) {
al = SSL_AD_DECOMPRESSION_FAILURE;
SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_BAD_DECOMPRESSION);
goto f_err;
}
}
if (rr->length > SSL3_RT_MAX_PLAIN_LENGTH) {
al = SSL_AD_RECORD_OVERFLOW;
SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_DATA_LENGTH_TOO_LONG);
goto f_err;
}
rr->off = 0;
RECORD_LAYER_reset_packet_length(&s->rlayer);
return (1);
f_err:
ssl3_send_alert(s, SSL3_AL_FATAL, al);
err:
return (0);
}","int dtls1_process_record(SSL *VAR_0)
{
int VAR_1, VAR_2;
int VAR_3;
SSL_SESSION *VAR_4;
SSL3_RECORD *VAR_5;
unsigned int VAR_6;
unsigned char VAR_7[VAR_8];
VAR_5 = RECORD_LAYER_get_rrec(&VAR_0->rlayer);
VAR_4 = VAR_0->session;
VAR_5->input = &(RECORD_LAYER_get_packet(&VAR_0->rlayer)[VAR_9]);
if (VAR_5->length > VAR_10) {
VAR_2 = VAR_11;
SSLerr(VAR_12, VAR_13);
goto f_err;
}
VAR_5->data = VAR_5->input;
VAR_5->orig_len = VAR_5->length;
VAR_3 = VAR_0->method->ssl3_enc->enc(VAR_0, VAR_5, 1, 0);
if (VAR_3 == 0) {
VAR_5->length = 0;
RECORD_LAYER_reset_packet_length(&VAR_0->rlayer);
goto err;
}
#ifdef VAR_14
printf(""dec %d\n"", VAR_5->length);
{
unsigned int VAR_15;
for (VAR_15 = 0; VAR_15 < VAR_5->length; VAR_15++)
printf(""%02X%c"", VAR_5->data[VAR_15], ((VAR_15 + 1) % 16) ? ' ' : '\n');
}
printf(""\n"");
#endif
if ((VAR_4 != NULL) &&
(VAR_0->enc_read_ctx != NULL) && (EVP_MD_CTX_md(VAR_0->read_hash) != NULL)) {
unsigned char *VAR_16 = NULL;
unsigned char VAR_17[VAR_8];
VAR_6 = EVP_MD_CTX_size(VAR_0->read_hash);
OPENSSL_assert(VAR_6 <= VAR_8);
if (VAR_5->orig_len < VAR_6 ||
(EVP_CIPHER_CTX_mode(VAR_0->enc_read_ctx) == VAR_18 &&
VAR_5->orig_len < VAR_6 + 1)) {
VAR_2 = VAR_19;
SSLerr(VAR_12, VAR_20);
goto f_err;
}
if (EVP_CIPHER_CTX_mode(VAR_0->enc_read_ctx) == VAR_18) {
VAR_16 = VAR_17;
ssl3_cbc_copy_mac(VAR_17, VAR_5, VAR_6);
VAR_5->length -= VAR_6;
} else {
VAR_5->length -= VAR_6;
VAR_16 = &VAR_5->data[VAR_5->length];
}
VAR_1 = VAR_0->method->ssl3_enc->mac(VAR_0, VAR_5, VAR_7, 0  );
if (VAR_1 < 0 || VAR_16 == NULL
|| CRYPTO_memcmp(VAR_7, VAR_16, (size_t)VAR_6) != 0)
VAR_3 = -1;
if (VAR_5->length > VAR_21 + VAR_6)
VAR_3 = -1;
}
if (VAR_3 < 0) {
VAR_5->length = 0;
RECORD_LAYER_reset_packet_length(&VAR_0->rlayer);
goto err;
}
if (VAR_0->expand != NULL) {
if (VAR_5->length > VAR_21) {
VAR_2 = VAR_11;
SSLerr(VAR_12,
VAR_22);
goto f_err;
}
if (!ssl3_do_uncompress(VAR_0, VAR_5)) {
VAR_2 = VAR_23;
SSLerr(VAR_12, VAR_24);
goto f_err;
}
}
if (VAR_5->length > VAR_25) {
VAR_2 = VAR_11;
SSLerr(VAR_12, VAR_26);
goto f_err;
}
VAR_5->off = 0;
RECORD_LAYER_reset_packet_length(&VAR_0->rlayer);
return (1);
f_err:
ssl3_send_alert(VAR_0, VAR_27, VAR_2);
err:
return (0);
}",openssl/1fb9fdc3027b27d8eb6a1e6a846435b070980770/ssl3_record.c/vul/before/1.json,"int dtls1_process_record(SSL *s, DTLS1_BITMAP *bitmap)
{
    int i, al;
    int enc_err;
    SSL_SESSION *sess;
    SSL3_RECORD *rr;
    unsigned int mac_size;
    unsigned char md[EVP_MAX_MD_SIZE];

    rr = RECORD_LAYER_get_rrec(&s->rlayer);
    sess = s->session;

    /*
     * At this point, s->packet_length == SSL3_RT_HEADER_LNGTH + rr->length,
     * and we have that many bytes in s->packet
     */
    rr->input = &(RECORD_LAYER_get_packet(&s->rlayer)[DTLS1_RT_HEADER_LENGTH]);

    /*
     * ok, we can now read from 's->packet' data into 'rr' rr->input points
     * at rr->length bytes, which need to be copied into rr->data by either
     * the decryption or by the decompression When the data is 'copied' into
     * the rr->data buffer, rr->input will be pointed at the new buffer
     */

    /*
     * We now have - encrypted [ MAC [ compressed [ plain ] ] ] rr->length
     * bytes of encrypted compressed stuff.
     */

    /* check is not needed I believe */
    if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {
        al = SSL_AD_RECORD_OVERFLOW;
        SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);
        goto f_err;
    }

    /* decrypt in place in 'rr->input' */
    rr->data = rr->input;
    rr->orig_len = rr->length;

    enc_err = s->method->ssl3_enc->enc(s, rr, 1, 0);
    /*-
     * enc_err is:
     *    0: (in non-constant time) if the record is publically invalid.
     *    1: if the padding is valid
     *   -1: if the padding is invalid
     */
    if (enc_err == 0) {
        /* For DTLS we simply ignore bad packets. */
        rr->length = 0;
        RECORD_LAYER_reset_packet_length(&s->rlayer);
        goto err;
    }
#ifdef SSL_DEBUG
    printf(""dec %d\n"", rr->length);
    {
        unsigned int z;
        for (z = 0; z < rr->length; z++)
            printf(""%02X%c"", rr->data[z], ((z + 1) % 16) ? ' ' : '\n');
    }
    printf(""\n"");
#endif

    /* r->length is now the compressed data plus mac */
    if ((sess != NULL) &&
        (s->enc_read_ctx != NULL) && (EVP_MD_CTX_md(s->read_hash) != NULL)) {
        /* s->read_hash != NULL => mac_size != -1 */
        unsigned char *mac = NULL;
        unsigned char mac_tmp[EVP_MAX_MD_SIZE];
        mac_size = EVP_MD_CTX_size(s->read_hash);
        OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);

        /*
         * orig_len is the length of the record before any padding was
         * removed. This is public information, as is the MAC in use,
         * therefore we can safely process the record in a different amount
         * of time if it's too short to possibly contain a MAC.
         */
        if (rr->orig_len < mac_size ||
            /* CBC records must have a padding length byte too. */
            (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
             rr->orig_len < mac_size + 1)) {
            al = SSL_AD_DECODE_ERROR;
            SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_LENGTH_TOO_SHORT);
            goto f_err;
        }

        if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE) {
            /*
             * We update the length so that the TLS header bytes can be
             * constructed correctly but we need to extract the MAC in
             * constant time from within the record, without leaking the
             * contents of the padding bytes.
             */
            mac = mac_tmp;
            ssl3_cbc_copy_mac(mac_tmp, rr, mac_size);
            rr->length -= mac_size;
        } else {
            /*
             * In this case there's no padding, so |rec->orig_len| equals
             * |rec->length| and we checked that there's enough bytes for
             * |mac_size| above.
             */
            rr->length -= mac_size;
            mac = &rr->data[rr->length];
        }

        i = s->method->ssl3_enc->mac(s, rr, md, 0 /* not send */ );
        if (i < 0 || mac == NULL
            || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)
            enc_err = -1;
        if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size)
            enc_err = -1;
    }

    if (enc_err < 0) {
        /* decryption failed, silently discard message */
        rr->length = 0;
        RECORD_LAYER_reset_packet_length(&s->rlayer);
        goto err;
    }

    /* r->length is now just compressed */
    if (s->expand != NULL) {
        if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH) {
            al = SSL_AD_RECORD_OVERFLOW;
            SSLerr(SSL_F_DTLS1_PROCESS_RECORD,
                   SSL_R_COMPRESSED_LENGTH_TOO_LONG);
            goto f_err;
        }
        if (!ssl3_do_uncompress(s, rr)) {
            al = SSL_AD_DECOMPRESSION_FAILURE;
            SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_BAD_DECOMPRESSION);
            goto f_err;
        }
    }

    if (rr->length > SSL3_RT_MAX_PLAIN_LENGTH) {
        al = SSL_AD_RECORD_OVERFLOW;
        SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_DATA_LENGTH_TOO_LONG);
        goto f_err;
    }

    rr->off = 0;
    /*-
     * So at this point the following is true
     * ssl->s3->rrec.type   is the type of record
     * ssl->s3->rrec.length == number of bytes in record
     * ssl->s3->rrec.off    == offset to first valid byte
     * ssl->s3->rrec.data   == where to take bytes from, increment
     *                         after use :-).
     */

    /* we have pulled in a full packet so zero things */
    RECORD_LAYER_reset_packet_length(&s->rlayer);

    /* Mark receipt of record. */
    dtls1_record_bitmap_update(s, bitmap);

    return (1);

 f_err:
    ssl3_send_alert(s, SSL3_AL_FATAL, al);
 err:
    return (0);
}","int dtls1_process_record(SSL *VAR_0, DTLS1_BITMAP *VAR_1)
{
    int VAR_2, VAR_3;
    int VAR_4;
    SSL_SESSION *VAR_5;
    SSL3_RECORD *VAR_6;
    unsigned int VAR_7;
    unsigned char VAR_8[VAR_9];

    VAR_6 = RECORD_LAYER_get_rrec(&VAR_0->rlayer);
    VAR_5 = VAR_0->session;

    /* COMMENT_0 */
                                                                            
                                               
       
    VAR_6->input = &(RECORD_LAYER_get_packet(&VAR_0->rlayer)[VAR_10]);

    /* COMMENT_4 */
                                                                           
                                                                           
                                                                            
                                                                       
       

    /* COMMENT_10 */
                                                                          
                                           
       

    /* COMMENT_14 */
    if (VAR_6->length > VAR_11) {
        VAR_3 = VAR_12;
        SSLerr(VAR_13, VAR_14);
        goto f_err;
    }

    /* COMMENT_15 */
    VAR_6->data = VAR_6->input;
    VAR_6->orig_len = VAR_6->length;

    VAR_4 = VAR_0->method->ssl3_enc->enc(VAR_0, VAR_6, 1, 0);
    /* COMMENT_16 */
                  
                                                                        
                                    
                                      
       
    if (VAR_4 == 0) {
        /* COMMENT_22 */
        VAR_6->length = 0;
        RECORD_LAYER_reset_packet_length(&VAR_0->rlayer);
        goto err;
    }
#ifdef VAR_15
    printf(""dec %d\n"", VAR_6->length);
    {
        unsigned int VAR_16;
        for (VAR_16 = 0; VAR_16 < VAR_6->length; VAR_16++)
            printf(""%02X%c"", VAR_6->data[VAR_16], ((VAR_16 + 1) % 16) ? ' ' : '\n');
    }
    printf(""\n"");
#endif

    /* COMMENT_23 */
    if ((VAR_5 != NULL) &&
        (VAR_0->enc_read_ctx != NULL) && (EVP_MD_CTX_md(VAR_0->read_hash) != NULL)) {
        /* COMMENT_24 */
        unsigned char *VAR_17 = NULL;
        unsigned char VAR_18[VAR_9];
        VAR_7 = EVP_MD_CTX_size(VAR_0->read_hash);
        OPENSSL_assert(VAR_7 <= VAR_9);

        /* COMMENT_25 */
                                                                      
                                                                     
                                                                           
                                                               
           
        if (VAR_6->orig_len < VAR_7 ||
            /* COMMENT_31 */
            (EVP_CIPHER_CTX_mode(VAR_0->enc_read_ctx) == VAR_19 &&
             VAR_6->orig_len < VAR_7 + 1)) {
            VAR_3 = VAR_20;
            SSLerr(VAR_13, VAR_21);
            goto f_err;
        }

        if (EVP_CIPHER_CTX_mode(VAR_0->enc_read_ctx) == VAR_19) {
            /* COMMENT_32 */
                                                                       
                                                                      
                                                                        
                                             
               
            VAR_17 = VAR_18;
            ssl3_cbc_copy_mac(VAR_18, VAR_6, VAR_7);
            VAR_6->length -= VAR_7;
        } else {
            /* COMMENT_38 */
                                                                         
                                                                         
                                
               
            VAR_6->length -= VAR_7;
            VAR_17 = &VAR_6->data[VAR_6->length];
        }

        VAR_2 = VAR_0->method->ssl3_enc->mac(VAR_0, VAR_6, VAR_8, 0 /* COMMENT_43 */ );
        if (VAR_2 < 0 || VAR_17 == NULL
            || CRYPTO_memcmp(VAR_8, VAR_17, (size_t)VAR_7) != 0)
            VAR_4 = -1;
        if (VAR_6->length > VAR_22 + VAR_7)
            VAR_4 = -1;
    }

    if (VAR_4 < 0) {
        /* COMMENT_44 */
        VAR_6->length = 0;
        RECORD_LAYER_reset_packet_length(&VAR_0->rlayer);
        goto err;
    }

    /* COMMENT_45 */
    if (VAR_0->expand != NULL) {
        if (VAR_6->length > VAR_22) {
            VAR_3 = VAR_12;
            SSLerr(VAR_13,
                   VAR_23);
            goto f_err;
        }
        if (!ssl3_do_uncompress(VAR_0, VAR_6)) {
            VAR_3 = VAR_24;
            SSLerr(VAR_13, VAR_25);
            goto f_err;
        }
    }

    if (VAR_6->length > VAR_26) {
        VAR_3 = VAR_12;
        SSLerr(VAR_13, VAR_27);
        goto f_err;
    }

    VAR_6->off = 0;
    /* COMMENT_46 */
                                             
                                                 
                                                        
                                                         
                                                                  
                                             
       

    /* COMMENT_54 */
    RECORD_LAYER_reset_packet_length(&VAR_0->rlayer);

    /* COMMENT_55 */
    dtls1_record_bitmap_update(VAR_0, VAR_1);

    return (1);

 f_err:
    ssl3_send_alert(VAR_0, VAR_28, VAR_3);
 err:
    return (0);
}",openssl/1fb9fdc3027b27d8eb6a1e6a846435b070980770/ssl3_record.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-int dtls1_process_record(SSL *s)
+int dtls1_process_record(SSL *s, DTLS1_BITMAP *bitmap)
 {
     int i, al;
     int enc_err;
@@ -154,6 +154,10 @@
 
     /* we have pulled in a full packet so zero things */
     RECORD_LAYER_reset_packet_length(&s->rlayer);
+
+    /* Mark receipt of record. */
+    dtls1_record_bitmap_update(s, bitmap);
+
     return (1);
 
  f_err:","{'deleted_lines': ['int dtls1_process_record(SSL *s)'], 'added_lines': ['int dtls1_process_record(SSL *s, DTLS1_BITMAP *bitmap)', '', '    /* Mark receipt of record. */', '    dtls1_record_bitmap_update(s, bitmap);', '']}",True,"The Anti-Replay feature in the DTLS implementation in OpenSSL before 1.1.0 mishandles early use of a new epoch number in conjunction with a large sequence number, which allows remote attackers to cause a denial of service (false-positive packet drops) via spoofed DTLS records, related to rec_layer_d1.c and ssl3_record.c.",7.5,HIGH,2,test,,5
CVE-2016-6302,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,openssl,"
Sanity check ticket length.

If a ticket callback changes the HMAC digest to SHA512 the existing
sanity checks are not sufficient and an attacker could perform a DoS
attack with a malformed ticket. Add additional checks based on
HMAC size.

Thanks to Shi Lei for reporting this bug.

CVE-2016-6302

Reviewed-by: Viktor Dukhovni <viktor@openssl.org>
",e97763c92c655dcf4af2860b3abd2bc4c8a267f9,https://git.openssl.org/?p=openssl.git;a=commit;h=e97763c92c655dcf4af2860b3abd2bc4c8a267f9,ssl/t1_lib.c,tls_decrypt_ticket,"static int tls_decrypt_ticket(SSL *s, const unsigned char *etick,
int eticklen, const unsigned char *sess_id,
int sesslen, SSL_SESSION **psess)
{
SSL_SESSION *sess;
unsigned char *sdec;
const unsigned char *p;
int slen, mlen, renew_ticket = 0, ret = -1;
unsigned char tick_hmac[EVP_MAX_MD_SIZE];
HMAC_CTX *hctx = NULL;
EVP_CIPHER_CTX *ctx;
SSL_CTX *tctx = s->initial_ctx;
if (eticklen < 48)
return 2;
hctx = HMAC_CTX_new();
if (hctx == NULL)
return -2;
ctx = EVP_CIPHER_CTX_new();
if (ctx == NULL) {
ret = -2;
goto err;
}
if (tctx->tlsext_ticket_key_cb) {
unsigned char *nctick = (unsigned char *)etick;
int rv = tctx->tlsext_ticket_key_cb(s, nctick, nctick + 16,
ctx, hctx, 0);
if (rv < 0)
goto err;
if (rv == 0) {
ret = 2;
goto err;
}
if (rv == 2)
renew_ticket = 1;
} else {
if (memcmp(etick, tctx->tlsext_tick_key_name,
sizeof(tctx->tlsext_tick_key_name)) != 0) {
ret = 2;
goto err;
}
if (HMAC_Init_ex(hctx, tctx->tlsext_tick_hmac_key,
sizeof(tctx->tlsext_tick_hmac_key),
EVP_sha256(), NULL) <= 0
|| EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL,
tctx->tlsext_tick_aes_key,
etick + sizeof(tctx->tlsext_tick_key_name)) <=
0) {
goto err;
}
}
mlen = HMAC_size(hctx);
if (mlen < 0) {
goto err;
}
eticklen -= mlen;
if (HMAC_Update(hctx, etick, eticklen) <= 0
|| HMAC_Final(hctx, tick_hmac, NULL) <= 0) {
goto err;
}
HMAC_CTX_free(hctx);
if (CRYPTO_memcmp(tick_hmac, etick + eticklen, mlen)) {
EVP_CIPHER_CTX_free(ctx);
return 2;
}
p = etick + 16 + EVP_CIPHER_CTX_iv_length(ctx);
eticklen -= 16 + EVP_CIPHER_CTX_iv_length(ctx);
sdec = OPENSSL_malloc(eticklen);
if (sdec == NULL || EVP_DecryptUpdate(ctx, sdec, &slen, p, eticklen) <= 0) {
EVP_CIPHER_CTX_free(ctx);
OPENSSL_free(sdec);
return -1;
}
if (EVP_DecryptFinal(ctx, sdec + slen, &mlen) <= 0) {
EVP_CIPHER_CTX_free(ctx);
OPENSSL_free(sdec);
return 2;
}
slen += mlen;
EVP_CIPHER_CTX_free(ctx);
ctx = NULL;
p = sdec;
sess = d2i_SSL_SESSION(NULL, &p, slen);
OPENSSL_free(sdec);
if (sess) {
if (sesslen)
memcpy(sess->session_id, sess_id, sesslen);
sess->session_id_length = sesslen;
*psess = sess;
if (renew_ticket)
return 4;
else
return 3;
}
ERR_clear_error();
return 2;
err:
EVP_CIPHER_CTX_free(ctx);
HMAC_CTX_free(hctx);
return ret;
}","static int tls_decrypt_ticket(SSL *VAR_0, const unsigned char *VAR_1,
int VAR_2, const unsigned char *VAR_3,
int VAR_4, SSL_SESSION **VAR_5)
{
SSL_SESSION *VAR_6;
unsigned char *VAR_7;
const unsigned char *VAR_8;
int VAR_9, VAR_10, VAR_11 = 0, VAR_12 = -1;
unsigned char VAR_13[VAR_14];
HMAC_CTX *VAR_15 = NULL;
EVP_CIPHER_CTX *VAR_16;
SSL_CTX *VAR_17 = VAR_0->initial_ctx;
if (VAR_2 < 48)
return 2;
VAR_15 = HMAC_CTX_new();
if (VAR_15 == NULL)
return -2;
VAR_16 = EVP_CIPHER_CTX_new();
if (VAR_16 == NULL) {
VAR_12 = -2;
goto err;
}
if (VAR_17->tlsext_ticket_key_cb) {
unsigned char *VAR_18 = (unsigned char *)VAR_1;
int VAR_19 = VAR_17->tlsext_ticket_key_cb(VAR_0, VAR_18, VAR_18 + 16,
VAR_16, VAR_15, 0);
if (VAR_19 < 0)
goto err;
if (VAR_19 == 0) {
VAR_12 = 2;
goto err;
}
if (VAR_19 == 2)
VAR_11 = 1;
} else {
if (memcmp(VAR_1, VAR_17->tlsext_tick_key_name,
sizeof(VAR_17->tlsext_tick_key_name)) != 0) {
VAR_12 = 2;
goto err;
}
if (HMAC_Init_ex(VAR_15, VAR_17->tlsext_tick_hmac_key,
sizeof(VAR_17->tlsext_tick_hmac_key),
EVP_sha256(), NULL) <= 0
|| EVP_DecryptInit_ex(VAR_16, EVP_aes_256_cbc(), NULL,
VAR_17->tlsext_tick_aes_key,
VAR_1 + sizeof(VAR_17->tlsext_tick_key_name)) <=
0) {
goto err;
}
}
VAR_10 = HMAC_size(VAR_15);
if (VAR_10 < 0) {
goto err;
}
VAR_2 -= VAR_10;
if (HMAC_Update(VAR_15, VAR_1, VAR_2) <= 0
|| HMAC_Final(VAR_15, VAR_13, NULL) <= 0) {
goto err;
}
HMAC_CTX_free(VAR_15);
if (CRYPTO_memcmp(VAR_13, VAR_1 + VAR_2, VAR_10)) {
EVP_CIPHER_CTX_free(VAR_16);
return 2;
}
VAR_8 = VAR_1 + 16 + EVP_CIPHER_CTX_iv_length(VAR_16);
VAR_2 -= 16 + EVP_CIPHER_CTX_iv_length(VAR_16);
VAR_7 = OPENSSL_malloc(VAR_2);
if (VAR_7 == NULL || EVP_DecryptUpdate(VAR_16, VAR_7, &VAR_9, VAR_8, VAR_2) <= 0) {
EVP_CIPHER_CTX_free(VAR_16);
OPENSSL_free(VAR_7);
return -1;
}
if (EVP_DecryptFinal(VAR_16, VAR_7 + VAR_9, &VAR_10) <= 0) {
EVP_CIPHER_CTX_free(VAR_16);
OPENSSL_free(VAR_7);
return 2;
}
VAR_9 += VAR_10;
EVP_CIPHER_CTX_free(VAR_16);
VAR_16 = NULL;
VAR_8 = VAR_7;
VAR_6 = d2i_SSL_SESSION(NULL, &VAR_8, VAR_9);
OPENSSL_free(VAR_7);
if (VAR_6) {
if (VAR_4)
memcpy(VAR_6->session_id, VAR_3, VAR_4);
VAR_6->session_id_length = VAR_4;
*VAR_5 = VAR_6;
if (VAR_11)
return 4;
else
return 3;
}
ERR_clear_error();
return 2;
err:
EVP_CIPHER_CTX_free(VAR_16);
HMAC_CTX_free(VAR_15);
return VAR_12;
}",openssl/e97763c92c655dcf4af2860b3abd2bc4c8a267f9/t1_lib.c/vul/before/0.json,"static int tls_decrypt_ticket(SSL *s, const unsigned char *etick,
                              int eticklen, const unsigned char *sess_id,
                              int sesslen, SSL_SESSION **psess)
{
    SSL_SESSION *sess;
    unsigned char *sdec;
    const unsigned char *p;
    int slen, mlen, renew_ticket = 0, ret = -1;
    unsigned char tick_hmac[EVP_MAX_MD_SIZE];
    HMAC_CTX *hctx = NULL;
    EVP_CIPHER_CTX *ctx;
    SSL_CTX *tctx = s->initial_ctx;

    /* Initialize session ticket encryption and HMAC contexts */
    hctx = HMAC_CTX_new();
    if (hctx == NULL)
        return -2;
    ctx = EVP_CIPHER_CTX_new();
    if (ctx == NULL) {
        ret = -2;
        goto err;
    }
    if (tctx->tlsext_ticket_key_cb) {
        unsigned char *nctick = (unsigned char *)etick;
        int rv = tctx->tlsext_ticket_key_cb(s, nctick, nctick + 16,
                                            ctx, hctx, 0);
        if (rv < 0)
            goto err;
        if (rv == 0) {
            ret = 2;
            goto err;
        }
        if (rv == 2)
            renew_ticket = 1;
    } else {
        /* Check key name matches */
        if (memcmp(etick, tctx->tlsext_tick_key_name,
                   sizeof(tctx->tlsext_tick_key_name)) != 0) {
            ret = 2;
            goto err;
        }
        if (HMAC_Init_ex(hctx, tctx->tlsext_tick_hmac_key,
                         sizeof(tctx->tlsext_tick_hmac_key),
                         EVP_sha256(), NULL) <= 0
            || EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL,
                                  tctx->tlsext_tick_aes_key,
                                  etick + sizeof(tctx->tlsext_tick_key_name)) <=
            0) {
            goto err;
        }
    }
    /*
     * Attempt to process session ticket, first conduct sanity and integrity
     * checks on ticket.
     */
    mlen = HMAC_size(hctx);
    if (mlen < 0) {
        goto err;
    }
    /* Sanity check ticket length: must exceed keyname + IV + HMAC */
    if (eticklen <=
        TLSEXT_KEYNAME_LENGTH + EVP_CIPHER_CTX_iv_length(ctx) + mlen) {
        ret = 2;
        goto err;
    }
    eticklen -= mlen;
    /* Check HMAC of encrypted ticket */
    if (HMAC_Update(hctx, etick, eticklen) <= 0
        || HMAC_Final(hctx, tick_hmac, NULL) <= 0) {
        goto err;
    }
    HMAC_CTX_free(hctx);
    if (CRYPTO_memcmp(tick_hmac, etick + eticklen, mlen)) {
        EVP_CIPHER_CTX_free(ctx);
        return 2;
    }
    /* Attempt to decrypt session data */
    /* Move p after IV to start of encrypted ticket, update length */
    p = etick + 16 + EVP_CIPHER_CTX_iv_length(ctx);
    eticklen -= 16 + EVP_CIPHER_CTX_iv_length(ctx);
    sdec = OPENSSL_malloc(eticklen);
    if (sdec == NULL || EVP_DecryptUpdate(ctx, sdec, &slen, p, eticklen) <= 0) {
        EVP_CIPHER_CTX_free(ctx);
        OPENSSL_free(sdec);
        return -1;
    }
    if (EVP_DecryptFinal(ctx, sdec + slen, &mlen) <= 0) {
        EVP_CIPHER_CTX_free(ctx);
        OPENSSL_free(sdec);
        return 2;
    }
    slen += mlen;
    EVP_CIPHER_CTX_free(ctx);
    ctx = NULL;
    p = sdec;

    sess = d2i_SSL_SESSION(NULL, &p, slen);
    OPENSSL_free(sdec);
    if (sess) {
        /*
         * The session ID, if non-empty, is used by some clients to detect
         * that the ticket has been accepted. So we copy it to the session
         * structure. If it is empty set length to zero as required by
         * standard.
         */
        if (sesslen)
            memcpy(sess->session_id, sess_id, sesslen);
        sess->session_id_length = sesslen;
        *psess = sess;
        if (renew_ticket)
            return 4;
        else
            return 3;
    }
    ERR_clear_error();
    /*
     * For session parse failure, indicate that we need to send a new ticket.
     */
    return 2;
 err:
    EVP_CIPHER_CTX_free(ctx);
    HMAC_CTX_free(hctx);
    return ret;
}","static int tls_decrypt_ticket(SSL *VAR_0, const unsigned char *VAR_1,
                              int VAR_2, const unsigned char *VAR_3,
                              int VAR_4, SSL_SESSION **VAR_5)
{
    SSL_SESSION *VAR_6;
    unsigned char *VAR_7;
    const unsigned char *VAR_8;
    int VAR_9, VAR_10, VAR_11 = 0, VAR_12 = -1;
    unsigned char VAR_13[VAR_14];
    HMAC_CTX *VAR_15 = NULL;
    EVP_CIPHER_CTX *VAR_16;
    SSL_CTX *VAR_17 = VAR_0->initial_ctx;

    /* COMMENT_0 */
    VAR_15 = HMAC_CTX_new();
    if (VAR_15 == NULL)
        return -2;
    VAR_16 = EVP_CIPHER_CTX_new();
    if (VAR_16 == NULL) {
        VAR_12 = -2;
        goto err;
    }
    if (VAR_17->tlsext_ticket_key_cb) {
        unsigned char *VAR_18 = (unsigned char *)VAR_1;
        int VAR_19 = VAR_17->tlsext_ticket_key_cb(VAR_0, VAR_18, VAR_18 + 16,
                                            VAR_16, VAR_15, 0);
        if (VAR_19 < 0)
            goto err;
        if (VAR_19 == 0) {
            VAR_12 = 2;
            goto err;
        }
        if (VAR_19 == 2)
            VAR_11 = 1;
    } else {
        /* COMMENT_1 */
        if (memcmp(VAR_1, VAR_17->tlsext_tick_key_name,
                   sizeof(VAR_17->tlsext_tick_key_name)) != 0) {
            VAR_12 = 2;
            goto err;
        }
        if (HMAC_Init_ex(VAR_15, VAR_17->tlsext_tick_hmac_key,
                         sizeof(VAR_17->tlsext_tick_hmac_key),
                         EVP_sha256(), NULL) <= 0
            || EVP_DecryptInit_ex(VAR_16, EVP_aes_256_cbc(), NULL,
                                  VAR_17->tlsext_tick_aes_key,
                                  VAR_1 + sizeof(VAR_17->tlsext_tick_key_name)) <=
            0) {
            goto err;
        }
    }
    /* COMMENT_2 */
                                                                            
                        
       
    VAR_10 = HMAC_size(VAR_15);
    if (VAR_10 < 0) {
        goto err;
    }
    /* COMMENT_6 */
    if (VAR_2 <=
        VAR_20 + EVP_CIPHER_CTX_iv_length(VAR_16) + VAR_10) {
        VAR_12 = 2;
        goto err;
    }
    VAR_2 -= VAR_10;
    /* COMMENT_7 */
    if (HMAC_Update(VAR_15, VAR_1, VAR_2) <= 0
        || HMAC_Final(VAR_15, VAR_13, NULL) <= 0) {
        goto err;
    }
    HMAC_CTX_free(VAR_15);
    if (CRYPTO_memcmp(VAR_13, VAR_1 + VAR_2, VAR_10)) {
        EVP_CIPHER_CTX_free(VAR_16);
        return 2;
    }
    /* COMMENT_8 */
    /* COMMENT_9 */
    VAR_8 = VAR_1 + 16 + EVP_CIPHER_CTX_iv_length(VAR_16);
    VAR_2 -= 16 + EVP_CIPHER_CTX_iv_length(VAR_16);
    VAR_7 = OPENSSL_malloc(VAR_2);
    if (VAR_7 == NULL || EVP_DecryptUpdate(VAR_16, VAR_7, &VAR_9, VAR_8, VAR_2) <= 0) {
        EVP_CIPHER_CTX_free(VAR_16);
        OPENSSL_free(VAR_7);
        return -1;
    }
    if (EVP_DecryptFinal(VAR_16, VAR_7 + VAR_9, &VAR_10) <= 0) {
        EVP_CIPHER_CTX_free(VAR_16);
        OPENSSL_free(VAR_7);
        return 2;
    }
    VAR_9 += VAR_10;
    EVP_CIPHER_CTX_free(VAR_16);
    VAR_16 = NULL;
    VAR_8 = VAR_7;

    VAR_6 = d2i_SSL_SESSION(NULL, &VAR_8, VAR_9);
    OPENSSL_free(VAR_7);
    if (VAR_6) {
        /* COMMENT_10 */
                                                                          
                                                                          
                                                                      
                    
           
        if (VAR_4)
            memcpy(VAR_6->session_id, VAR_3, VAR_4);
        VAR_6->session_id_length = VAR_4;
        *VAR_5 = VAR_6;
        if (VAR_11)
            return 4;
        else
            return 3;
    }
    ERR_clear_error();
    /* COMMENT_16 */
                                                                             
       
    return 2;
 err:
    EVP_CIPHER_CTX_free(VAR_16);
    HMAC_CTX_free(VAR_15);
    return VAR_12;
}",openssl/e97763c92c655dcf4af2860b3abd2bc4c8a267f9/t1_lib.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,9 +10,7 @@
     HMAC_CTX *hctx = NULL;
     EVP_CIPHER_CTX *ctx;
     SSL_CTX *tctx = s->initial_ctx;
-    /* Need at least keyname + iv + some encrypted data */
-    if (eticklen < 48)
-        return 2;
+
     /* Initialize session ticket encryption and HMAC contexts */
     hctx = HMAC_CTX_new();
     if (hctx == NULL)
@@ -57,6 +55,12 @@
      */
     mlen = HMAC_size(hctx);
     if (mlen < 0) {
+        goto err;
+    }
+    /* Sanity check ticket length: must exceed keyname + IV + HMAC */
+    if (eticklen <=
+        TLSEXT_KEYNAME_LENGTH + EVP_CIPHER_CTX_iv_length(ctx) + mlen) {
+        ret = 2;
         goto err;
     }
     eticklen -= mlen;","{'deleted_lines': ['    /* Need at least keyname + iv + some encrypted data */', '    if (eticklen < 48)', '        return 2;'], 'added_lines': ['', '        goto err;', '    }', '    /* Sanity check ticket length: must exceed keyname + IV + HMAC */', '    if (eticklen <=', '        TLSEXT_KEYNAME_LENGTH + EVP_CIPHER_CTX_iv_length(ctx) + mlen) {', '        ret = 2;']}",True,"The tls_decrypt_ticket function in ssl/t1_lib.c in OpenSSL before 1.1.0 does not consider the HMAC size during validation of the ticket length, which allows remote attackers to cause a denial of service via a ticket that is too short.",7.5,HIGH,2,test,,5
CVE-2016-5172,['CWE-200'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,chromium,"Rewrite scopes of non-simple default arguments

Default parameters have additional declaration block scopes inserted
around them when something in the function scope calls eval. This
patch sets the parent scope of the expressions introduced due to
those defaults to the new block scope.

R=adamk
BUG=chromium:616386

Review-Url: https://codereview.chromium.org/2077283004
Cr-Commit-Position: refs/heads/master@{#37198}
",0e14baf712955a1993f742647bb2adc293702b80,https://chromium.googlesource.com/v8/v8/+/0e14baf712955a1993f742647bb2adc293702b80,src/parsing/parameter-initializer-rewriter.cc,Rewriter::VisitVariableProxy,"void Rewriter::VisitVariableProxy(VariableProxy* proxy) {
if (proxy->is_resolved()) {
Variable* var = proxy->var();
if (var->mode() != TEMPORARY) return;
int index = old_scope_->RemoveTemporary(var);
if (index >= 0) {
temps_.push_back(std::make_pair(var, index));
}
} else if (old_scope_->RemoveUnresolved(proxy)) {
new_scope_->AddUnresolved(proxy);
}
}","void Rewriter::VisitVariableProxy(VariableProxy* VAR_0) {
if (VAR_0->is_resolved()) {
Variable* VAR_1 = VAR_0->var();
if (VAR_1->mode() != VAR_2) return;
int VAR_3 = VAR_4->RemoveTemporary(VAR_1);
if (VAR_3 >= 0) {
VAR_5.push_back(std::make_pair(VAR_1, VAR_3));
}
} else if (VAR_4->RemoveUnresolved(VAR_0)) {
VAR_6->AddUnresolved(VAR_0);
}
}",chromium/0e14baf712955a1993f742647bb2adc293702b80/parameter-initializer-rewriter.cc/vul/before/0.json,"void Rewriter::VisitVariableProxy(VariableProxy* proxy) {
  if (proxy->is_resolved()) {
    Variable* var = proxy->var();
    if (var->mode() != TEMPORARY) return;
    // For rewriting inside the same ClosureScope (e.g., putting default
    // parameter values in their own inner scope in certain cases), refrain
    // from invalidly moving temporaries to a block scope.
    if (var->scope()->ClosureScope() == new_scope_->ClosureScope()) return;
    int index = old_scope_->RemoveTemporary(var);
    if (index >= 0) {
      temps_.push_back(std::make_pair(var, index));
    }
  } else if (old_scope_->RemoveUnresolved(proxy)) {
    new_scope_->AddUnresolved(proxy);
  }
}","void Rewriter::VisitVariableProxy(VariableProxy* VAR_0) {
  if (VAR_0->is_resolved()) {
    Variable* VAR_1 = VAR_0->var();
    if (VAR_1->mode() != VAR_2) return;
    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    if (VAR_1->scope()->ClosureScope() == VAR_3->ClosureScope()) return;
    int VAR_4 = VAR_5->RemoveTemporary(VAR_1);
    if (VAR_4 >= 0) {
      VAR_6.push_back(std::make_pair(VAR_1, VAR_4));
    }
  } else if (VAR_5->RemoveUnresolved(VAR_0)) {
    VAR_3->AddUnresolved(VAR_0);
  }
}",chromium/0e14baf712955a1993f742647bb2adc293702b80/parameter-initializer-rewriter.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,6 +2,10 @@
   if (proxy->is_resolved()) {
     Variable* var = proxy->var();
     if (var->mode() != TEMPORARY) return;
+    // For rewriting inside the same ClosureScope (e.g., putting default
+    // parameter values in their own inner scope in certain cases), refrain
+    // from invalidly moving temporaries to a block scope.
+    if (var->scope()->ClosureScope() == new_scope_->ClosureScope()) return;
     int index = old_scope_->RemoveTemporary(var);
     if (index >= 0) {
       temps_.push_back(std::make_pair(var, index));","{'deleted_lines': [], 'added_lines': ['    // For rewriting inside the same ClosureScope (e.g., putting default', '    // parameter values in their own inner scope in certain cases), refrain', '    // from invalidly moving temporaries to a block scope.', '    if (var->scope()->ClosureScope() == new_scope_->ClosureScope()) return;']}",True,"The parser in Google V8, as used in Google Chrome before 53.0.2785.113, mishandles scopes, which allows remote attackers to obtain sensitive information from arbitrary memory locations via crafted JavaScript code.",6.5,MEDIUM,1,test,,5
CVE-2016-5172,['CWE-200'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,chromium,"Rewrite scopes of non-simple default arguments

Default parameters have additional declaration block scopes inserted
around them when something in the function scope calls eval. This
patch sets the parent scope of the expressions introduced due to
those defaults to the new block scope.

R=adamk
BUG=chromium:616386

Review-Url: https://codereview.chromium.org/2077283004
Cr-Commit-Position: refs/heads/master@{#37198}
",0e14baf712955a1993f742647bb2adc293702b80,https://chromium.googlesource.com/v8/v8/+/0e14baf712955a1993f742647bb2adc293702b80,src/parsing/parser.cc,Parser::BuildParameterInitializationBlock,"Block* Parser::BuildParameterInitializationBlock(
const ParserFormalParameters& parameters, bool* ok) {
DCHECK(!parameters.is_simple);
DCHECK(scope_->is_function_scope());
Block* init_block =
factory()->NewBlock(NULL, 1, true, RelocInfo::kNoPosition);
for (int i = 0; i < parameters.params.length(); ++i) {
auto parameter = parameters.params[i];
if (parameter.is_rest && parameter.pattern->IsVariableProxy()) break;
DeclarationDescriptor descriptor;
descriptor.declaration_kind = DeclarationDescriptor::PARAMETER;
descriptor.parser = this;
descriptor.scope = scope_;
descriptor.hoist_scope = nullptr;
descriptor.mode = LET;
descriptor.declaration_pos = parameter.pattern->position();
descriptor.initialization_pos = parameter.pattern->position();
int initializer_position = parameter.pattern->position();
Expression* initial_value =
factory()->NewVariableProxy(parameters.scope->parameter(i));
if (parameter.initializer != nullptr) {
RewriteParameterInitializer(parameter.initializer, scope_);
auto condition = factory()->NewCompareOperation(
Token::EQ_STRICT,
factory()->NewVariableProxy(parameters.scope->parameter(i)),
factory()->NewUndefinedLiteral(RelocInfo::kNoPosition),
RelocInfo::kNoPosition);
initial_value = factory()->NewConditional(
condition, parameter.initializer, initial_value,
RelocInfo::kNoPosition);
descriptor.initialization_pos = parameter.initializer->position();
initializer_position = parameter.initializer_end_position;
}
Scope* param_scope = scope_;
Block* param_block = init_block;
if (!parameter.is_simple() && scope_->calls_sloppy_eval()) {
param_scope = NewScope(scope_, BLOCK_SCOPE);
param_scope->set_is_declaration_scope();
param_scope->set_start_position(descriptor.initialization_pos);
param_scope->set_end_position(parameter.initializer_end_position);
param_scope->RecordEvalCall();
param_block = factory()->NewBlock(NULL, 8, true, RelocInfo::kNoPosition);
param_block->set_scope(param_scope);
descriptor.hoist_scope = scope_;
}
{
BlockState block_state(&scope_, param_scope);
DeclarationParsingResult::Declaration decl(
parameter.pattern, initializer_position, initial_value);
PatternRewriter::DeclareAndInitializeVariables(param_block, &descriptor,
&decl, nullptr, CHECK_OK);
}
if (!parameter.is_simple() && scope_->calls_sloppy_eval()) {
param_scope = param_scope->FinalizeBlockScope();
if (param_scope != nullptr) {
CheckConflictingVarDeclarations(param_scope, CHECK_OK);
}
init_block->statements()->Add(param_block, zone());
}
}
return init_block;
}","Block* Parser::BuildParameterInitializationBlock(
const ParserFormalParameters& VAR_0, bool* VAR_1) {
DCHECK(!VAR_0.is_simple);
DCHECK(VAR_2->is_function_scope());
Block* VAR_3 =
factory()->NewBlock(NULL, 1, true, RelocInfo::kNoPosition);
for (int VAR_4 = 0; VAR_4 < VAR_0.params.length(); ++VAR_4) {
auto VAR_5 = VAR_0.params[VAR_4];
if (VAR_5.is_rest && VAR_5.pattern->IsVariableProxy()) break;
DeclarationDescriptor VAR_6;
VAR_6.declaration_kind = DeclarationDescriptor::PARAMETER;
VAR_6.parser = this;
VAR_6.scope = VAR_2;
VAR_6.hoist_scope = nullptr;
VAR_6.mode = VAR_7;
VAR_6.declaration_pos = VAR_5.pattern->position();
VAR_6.initialization_pos = VAR_5.pattern->position();
int VAR_8 = VAR_5.pattern->position();
Expression* VAR_9 =
factory()->NewVariableProxy(VAR_0.scope->parameter(VAR_4));
if (VAR_5.initializer != nullptr) {
RewriteParameterInitializer(VAR_5.initializer, VAR_2);
auto VAR_10 = factory()->NewCompareOperation(
Token::EQ_STRICT,
factory()->NewVariableProxy(VAR_0.scope->parameter(VAR_4)),
factory()->NewUndefinedLiteral(RelocInfo::kNoPosition),
RelocInfo::kNoPosition);
VAR_9 = factory()->NewConditional(
VAR_10, VAR_5.initializer, VAR_9,
RelocInfo::kNoPosition);
VAR_6.initialization_pos = VAR_5.initializer->position();
VAR_8 = VAR_5.initializer_end_position;
}
Scope* VAR_11 = VAR_2;
Block* VAR_12 = VAR_3;
if (!VAR_5.is_simple() && VAR_2->calls_sloppy_eval()) {
VAR_11 = NewScope(VAR_2, VAR_13);
VAR_11->set_is_declaration_scope();
VAR_11->set_start_position(VAR_6.initialization_pos);
VAR_11->set_end_position(VAR_5.initializer_end_position);
VAR_11->RecordEvalCall();
VAR_12 = factory()->NewBlock(NULL, 8, true, RelocInfo::kNoPosition);
VAR_12->set_scope(VAR_11);
VAR_6.hoist_scope = VAR_2;
}
{
BlockState VAR_14(&VAR_2, VAR_11);
DeclarationParsingResult::Declaration VAR_15(
VAR_5.pattern, VAR_8, VAR_9);
PatternRewriter::DeclareAndInitializeVariables(VAR_12, &VAR_6,
&VAR_15, nullptr, VAR_16);
}
if (!VAR_5.is_simple() && VAR_2->calls_sloppy_eval()) {
VAR_11 = VAR_11->FinalizeBlockScope();
if (VAR_11 != nullptr) {
CheckConflictingVarDeclarations(VAR_11, VAR_16);
}
VAR_3->statements()->Add(VAR_12, zone());
}
}
return VAR_3;
}",chromium/0e14baf712955a1993f742647bb2adc293702b80/parser.cc/vul/before/0.json,"Block* Parser::BuildParameterInitializationBlock(
    const ParserFormalParameters& parameters, bool* ok) {
  DCHECK(!parameters.is_simple);
  DCHECK(scope_->is_function_scope());
  Block* init_block =
      factory()->NewBlock(NULL, 1, true, RelocInfo::kNoPosition);
  for (int i = 0; i < parameters.params.length(); ++i) {
    auto parameter = parameters.params[i];
    if (parameter.is_rest && parameter.pattern->IsVariableProxy()) break;
    DeclarationDescriptor descriptor;
    descriptor.declaration_kind = DeclarationDescriptor::PARAMETER;
    descriptor.parser = this;
    descriptor.scope = scope_;
    descriptor.hoist_scope = nullptr;
    descriptor.mode = LET;
    descriptor.declaration_pos = parameter.pattern->position();
    // The position that will be used by the AssignmentExpression
    // which copies from the temp parameter to the pattern.
    //
    // TODO(adamk): Should this be RelocInfo::kNoPosition, since
    // it's just copying from a temp var to the real param var?
    descriptor.initialization_pos = parameter.pattern->position();
    // The initializer position which will end up in,
    // Variable::initializer_position(), used for hole check elimination.
    int initializer_position = parameter.pattern->position();
    Expression* initial_value =
        factory()->NewVariableProxy(parameters.scope->parameter(i));
    if (parameter.initializer != nullptr) {
      // IS_UNDEFINED($param) ? initializer : $param

      // Ensure initializer is rewritten
      RewriteParameterInitializer(parameter.initializer, scope_);

      auto condition = factory()->NewCompareOperation(
          Token::EQ_STRICT,
          factory()->NewVariableProxy(parameters.scope->parameter(i)),
          factory()->NewUndefinedLiteral(RelocInfo::kNoPosition),
          RelocInfo::kNoPosition);
      initial_value = factory()->NewConditional(
          condition, parameter.initializer, initial_value,
          RelocInfo::kNoPosition);
      descriptor.initialization_pos = parameter.initializer->position();
      initializer_position = parameter.initializer_end_position;
    }

    Scope* param_scope = scope_;
    Block* param_block = init_block;
    if (!parameter.is_simple() && scope_->calls_sloppy_eval()) {
      param_scope = NewScope(scope_, BLOCK_SCOPE);
      param_scope->set_is_declaration_scope();
      param_scope->set_start_position(descriptor.initialization_pos);
      param_scope->set_end_position(parameter.initializer_end_position);
      param_scope->RecordEvalCall();
      param_block = factory()->NewBlock(NULL, 8, true, RelocInfo::kNoPosition);
      param_block->set_scope(param_scope);
      descriptor.hoist_scope = scope_;
      // Pass the appropriate scope in so that PatternRewriter can appropriately
      // rewrite inner initializers of the pattern to param_scope
      descriptor.scope = param_scope;
      // Rewrite the outer initializer to point to param_scope
      RewriteParameterInitializerScope(stack_limit(), initial_value, scope_,
                                       param_scope);
    }

    {
      BlockState block_state(&scope_, param_scope);
      DeclarationParsingResult::Declaration decl(
          parameter.pattern, initializer_position, initial_value);
      PatternRewriter::DeclareAndInitializeVariables(param_block, &descriptor,
                                                     &decl, nullptr, CHECK_OK);
    }

    if (!parameter.is_simple() && scope_->calls_sloppy_eval()) {
      param_scope = param_scope->FinalizeBlockScope();
      if (param_scope != nullptr) {
        CheckConflictingVarDeclarations(param_scope, CHECK_OK);
      }
      init_block->statements()->Add(param_block, zone());
    }
  }
  return init_block;
}","Block* Parser::BuildParameterInitializationBlock(
    const ParserFormalParameters& VAR_0, bool* VAR_1) {
  DCHECK(!VAR_0.is_simple);
  DCHECK(VAR_2->is_function_scope());
  Block* VAR_3 =
      factory()->NewBlock(NULL, 1, true, RelocInfo::kNoPosition);
  for (int VAR_4 = 0; VAR_4 < VAR_0.params.length(); ++VAR_4) {
    auto VAR_5 = VAR_0.params[VAR_4];
    if (VAR_5.is_rest && VAR_5.pattern->IsVariableProxy()) break;
    DeclarationDescriptor VAR_6;
    VAR_6.declaration_kind = DeclarationDescriptor::PARAMETER;
    VAR_6.parser = this;
    VAR_6.scope = VAR_2;
    VAR_6.hoist_scope = nullptr;
    VAR_6.mode = VAR_7;
    VAR_6.declaration_pos = VAR_5.pattern->position();
    /* COMMENT_0 */
    /* COMMENT_1 */
    /* COMMENT_2 */
    /* COMMENT_3 */
    /* COMMENT_4 */
    VAR_6.initialization_pos = VAR_5.pattern->position();
    /* COMMENT_5 */
    /* COMMENT_6 */
    int VAR_8 = VAR_5.pattern->position();
    Expression* VAR_9 =
        factory()->NewVariableProxy(VAR_0.scope->parameter(VAR_4));
    if (VAR_5.initializer != nullptr) {
      /* COMMENT_7 */

      /* COMMENT_8 */
      RewriteParameterInitializer(VAR_5.initializer, VAR_2);

      auto VAR_10 = factory()->NewCompareOperation(
          Token::EQ_STRICT,
          factory()->NewVariableProxy(VAR_0.scope->parameter(VAR_4)),
          factory()->NewUndefinedLiteral(RelocInfo::kNoPosition),
          RelocInfo::kNoPosition);
      VAR_9 = factory()->NewConditional(
          VAR_10, VAR_5.initializer, VAR_9,
          RelocInfo::kNoPosition);
      VAR_6.initialization_pos = VAR_5.initializer->position();
      VAR_8 = VAR_5.initializer_end_position;
    }

    Scope* VAR_11 = VAR_2;
    Block* VAR_12 = VAR_3;
    if (!VAR_5.is_simple() && VAR_2->calls_sloppy_eval()) {
      VAR_11 = NewScope(VAR_2, VAR_13);
      VAR_11->set_is_declaration_scope();
      VAR_11->set_start_position(VAR_6.initialization_pos);
      VAR_11->set_end_position(VAR_5.initializer_end_position);
      VAR_11->RecordEvalCall();
      VAR_12 = factory()->NewBlock(NULL, 8, true, RelocInfo::kNoPosition);
      VAR_12->set_scope(VAR_11);
      VAR_6.hoist_scope = VAR_2;
      /* COMMENT_9 */
      /* COMMENT_10 */
      VAR_6.scope = VAR_11;
      /* COMMENT_11 */
      RewriteParameterInitializerScope(stack_limit(), VAR_9, VAR_2,
                                       VAR_11);
    }

    {
      BlockState VAR_14(&VAR_2, VAR_11);
      DeclarationParsingResult::Declaration VAR_15(
          VAR_5.pattern, VAR_8, VAR_9);
      PatternRewriter::DeclareAndInitializeVariables(VAR_12, &VAR_6,
                                                     &VAR_15, nullptr, VAR_16);
    }

    if (!VAR_5.is_simple() && VAR_2->calls_sloppy_eval()) {
      VAR_11 = VAR_11->FinalizeBlockScope();
      if (VAR_11 != nullptr) {
        CheckConflictingVarDeclarations(VAR_11, VAR_16);
      }
      VAR_3->statements()->Add(VAR_12, zone());
    }
  }
  return VAR_3;
}",chromium/0e14baf712955a1993f742647bb2adc293702b80/parser.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -54,6 +54,12 @@
       param_block = factory()->NewBlock(NULL, 8, true, RelocInfo::kNoPosition);
       param_block->set_scope(param_scope);
       descriptor.hoist_scope = scope_;
+      // Pass the appropriate scope in so that PatternRewriter can appropriately
+      // rewrite inner initializers of the pattern to param_scope
+      descriptor.scope = param_scope;
+      // Rewrite the outer initializer to point to param_scope
+      RewriteParameterInitializerScope(stack_limit(), initial_value, scope_,
+                                       param_scope);
     }
 
     {","{'deleted_lines': [], 'added_lines': ['      // Pass the appropriate scope in so that PatternRewriter can appropriately', '      // rewrite inner initializers of the pattern to param_scope', '      descriptor.scope = param_scope;', '      // Rewrite the outer initializer to point to param_scope', '      RewriteParameterInitializerScope(stack_limit(), initial_value, scope_,', '                                       param_scope);']}",True,"The parser in Google V8, as used in Google Chrome before 53.0.2785.113, mishandles scopes, which allows remote attackers to obtain sensitive information from arbitrary memory locations via crafted JavaScript code.",6.5,MEDIUM,1,test,,5
CVE-2016-5172,['CWE-200'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,chromium,"Rewrite scopes of non-simple default arguments

Default parameters have additional declaration block scopes inserted
around them when something in the function scope calls eval. This
patch sets the parent scope of the expressions introduced due to
those defaults to the new block scope.

R=adamk
BUG=chromium:616386

Review-Url: https://codereview.chromium.org/2077283004
Cr-Commit-Position: refs/heads/master@{#37198}
",0e14baf712955a1993f742647bb2adc293702b80,https://chromium.googlesource.com/v8/v8/+/0e14baf712955a1993f742647bb2adc293702b80,src/parsing/pattern-rewriter.cc,Parser::PatternRewriter::VisitAssignment,"void Parser::PatternRewriter::VisitAssignment(Assignment* node) {
DCHECK_EQ(Token::ASSIGN, node->op());
auto initializer = node->value();
auto value = initializer;
auto temp = CreateTempVar(current_value_);
if (IsInitializerContext()) {
Expression* is_undefined = factory()->NewCompareOperation(
Token::EQ_STRICT, factory()->NewVariableProxy(temp),
factory()->NewUndefinedLiteral(RelocInfo::kNoPosition),
RelocInfo::kNoPosition);
value = factory()->NewConditional(is_undefined, initializer,
factory()->NewVariableProxy(temp),
RelocInfo::kNoPosition);
}
if (IsBindingContext() &&
descriptor_->declaration_kind == DeclarationDescriptor::PARAMETER &&
scope()->is_arrow_scope()) {
RewriteParameterInitializerScope(parser_->stack_limit(), initializer,
scope()->outer_scope(), scope());
}
PatternContext old_context = SetAssignmentContextIfNeeded(initializer);
RecurseIntoSubpattern(node->target(), value);
set_context(old_context);
}","void Parser::PatternRewriter::VisitAssignment(Assignment* VAR_0) {
DCHECK_EQ(Token::ASSIGN, VAR_0->op());
auto VAR_1 = VAR_0->value();
auto VAR_2 = VAR_1;
auto VAR_3 = CreateTempVar(VAR_4);
if (IsInitializerContext()) {
Expression* VAR_5 = factory()->NewCompareOperation(
Token::EQ_STRICT, factory()->NewVariableProxy(VAR_3),
factory()->NewUndefinedLiteral(RelocInfo::kNoPosition),
RelocInfo::kNoPosition);
VAR_2 = factory()->NewConditional(VAR_5, VAR_1,
factory()->NewVariableProxy(VAR_3),
RelocInfo::kNoPosition);
}
if (IsBindingContext() &&
VAR_6->declaration_kind == DeclarationDescriptor::PARAMETER &&
scope()->is_arrow_scope()) {
RewriteParameterInitializerScope(VAR_7->stack_limit(), VAR_1,
scope()->outer_scope(), scope());
}
PatternContext VAR_8 = SetAssignmentContextIfNeeded(VAR_1);
RecurseIntoSubpattern(VAR_0->target(), VAR_2);
set_context(VAR_8);
}",chromium/0e14baf712955a1993f742647bb2adc293702b80/pattern-rewriter.cc/vul/before/0.json,"void Parser::PatternRewriter::VisitAssignment(Assignment* node) {
  // let {<pattern> = <init>} = <value>
  //   becomes
  // temp = <value>;
  // <pattern> = temp === undefined ? <init> : temp;
  DCHECK_EQ(Token::ASSIGN, node->op());

  auto initializer = node->value();
  auto value = initializer;
  auto temp = CreateTempVar(current_value_);

  if (IsInitializerContext()) {
    Expression* is_undefined = factory()->NewCompareOperation(
        Token::EQ_STRICT, factory()->NewVariableProxy(temp),
        factory()->NewUndefinedLiteral(RelocInfo::kNoPosition),
        RelocInfo::kNoPosition);
    value = factory()->NewConditional(is_undefined, initializer,
                                      factory()->NewVariableProxy(temp),
                                      RelocInfo::kNoPosition);
  }

  // Two cases for scope rewriting the scope of default parameters:
  // - Eagerly parsed arrow functions are initially parsed as having
  //   initializers in the enclosing scope, but when the arrow is encountered,
  //   need to be in the scope of the function.
  // - When an extra declaration scope needs to be inserted to account for
  //   a sloppy eval in a default parameter or function body, the initializer
  //   needs to be in that new inner scope which was added after initial
  //   parsing.
  // Each of these cases can be handled by rewriting the contents of the
  // initializer to the current scope. The source scope is typically the outer
  // scope when one case occurs; when both cases occur, both scopes need to
  // be included as the outer scope. (Both rewritings still need to be done
  // to account for lazily parsed arrow functions which hit the second case.)
  // TODO(littledan): Remove the outer_scope parameter of
  //                  RewriteParameterInitializerScope
  if (IsBindingContext() &&
      descriptor_->declaration_kind == DeclarationDescriptor::PARAMETER &&
      (scope()->is_arrow_scope() || scope()->is_block_scope())) {
    if (scope()->outer_scope()->is_arrow_scope() && scope()->is_block_scope()) {
      RewriteParameterInitializerScope(parser_->stack_limit(), initializer,
                                       scope()->outer_scope()->outer_scope(),
                                       scope());
    }
    RewriteParameterInitializerScope(parser_->stack_limit(), initializer,
                                     scope()->outer_scope(), scope());
  }

  PatternContext old_context = SetAssignmentContextIfNeeded(initializer);
  RecurseIntoSubpattern(node->target(), value);
  set_context(old_context);
}","void Parser::PatternRewriter::VisitAssignment(Assignment* VAR_0) {
  /* COMMENT_0 */
  /* COMMENT_1 */
  /* COMMENT_2 */
  /* COMMENT_3 */
  DCHECK_EQ(Token::ASSIGN, VAR_0->op());

  auto VAR_1 = VAR_0->value();
  auto VAR_2 = VAR_1;
  auto VAR_3 = CreateTempVar(VAR_4);

  if (IsInitializerContext()) {
    Expression* VAR_5 = factory()->NewCompareOperation(
        Token::EQ_STRICT, factory()->NewVariableProxy(VAR_3),
        factory()->NewUndefinedLiteral(RelocInfo::kNoPosition),
        RelocInfo::kNoPosition);
    VAR_2 = factory()->NewConditional(VAR_5, VAR_1,
                                      factory()->NewVariableProxy(VAR_3),
                                      RelocInfo::kNoPosition);
  }

  /* COMMENT_4 */
  /* COMMENT_5 */
  /* COMMENT_6 */
  /* COMMENT_7 */
  /* COMMENT_8 */
  /* COMMENT_9 */
  /* COMMENT_10 */
  /* COMMENT_11 */
  /* COMMENT_12 */
  /* COMMENT_13 */
  /* COMMENT_14 */
  /* COMMENT_15 */
  /* COMMENT_16 */
  /* COMMENT_17 */
  /* COMMENT_18 */
  if (IsBindingContext() &&
      VAR_6->declaration_kind == DeclarationDescriptor::PARAMETER &&
      (scope()->is_arrow_scope() || scope()->is_block_scope())) {
    if (scope()->outer_scope()->is_arrow_scope() && scope()->is_block_scope()) {
      RewriteParameterInitializerScope(VAR_7->stack_limit(), VAR_1,
                                       scope()->outer_scope()->outer_scope(),
                                       scope());
    }
    RewriteParameterInitializerScope(VAR_7->stack_limit(), VAR_1,
                                     scope()->outer_scope(), scope());
  }

  PatternContext VAR_8 = SetAssignmentContextIfNeeded(VAR_1);
  RecurseIntoSubpattern(VAR_0->target(), VAR_2);
  set_context(VAR_8);
}",chromium/0e14baf712955a1993f742647bb2adc293702b80/pattern-rewriter.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -19,9 +19,29 @@
                                       RelocInfo::kNoPosition);
   }
 
+  // Two cases for scope rewriting the scope of default parameters:
+  // - Eagerly parsed arrow functions are initially parsed as having
+  //   initializers in the enclosing scope, but when the arrow is encountered,
+  //   need to be in the scope of the function.
+  // - When an extra declaration scope needs to be inserted to account for
+  //   a sloppy eval in a default parameter or function body, the initializer
+  //   needs to be in that new inner scope which was added after initial
+  //   parsing.
+  // Each of these cases can be handled by rewriting the contents of the
+  // initializer to the current scope. The source scope is typically the outer
+  // scope when one case occurs; when both cases occur, both scopes need to
+  // be included as the outer scope. (Both rewritings still need to be done
+  // to account for lazily parsed arrow functions which hit the second case.)
+  // TODO(littledan): Remove the outer_scope parameter of
+  //                  RewriteParameterInitializerScope
   if (IsBindingContext() &&
       descriptor_->declaration_kind == DeclarationDescriptor::PARAMETER &&
-      scope()->is_arrow_scope()) {
+      (scope()->is_arrow_scope() || scope()->is_block_scope())) {
+    if (scope()->outer_scope()->is_arrow_scope() && scope()->is_block_scope()) {
+      RewriteParameterInitializerScope(parser_->stack_limit(), initializer,
+                                       scope()->outer_scope()->outer_scope(),
+                                       scope());
+    }
     RewriteParameterInitializerScope(parser_->stack_limit(), initializer,
                                      scope()->outer_scope(), scope());
   }","{'deleted_lines': ['      scope()->is_arrow_scope()) {'], 'added_lines': ['  // Two cases for scope rewriting the scope of default parameters:', '  // - Eagerly parsed arrow functions are initially parsed as having', '  //   initializers in the enclosing scope, but when the arrow is encountered,', '  //   need to be in the scope of the function.', '  // - When an extra declaration scope needs to be inserted to account for', '  //   a sloppy eval in a default parameter or function body, the initializer', '  //   needs to be in that new inner scope which was added after initial', '  //   parsing.', '  // Each of these cases can be handled by rewriting the contents of the', '  // initializer to the current scope. The source scope is typically the outer', '  // scope when one case occurs; when both cases occur, both scopes need to', '  // be included as the outer scope. (Both rewritings still need to be done', '  // to account for lazily parsed arrow functions which hit the second case.)', '  // TODO(littledan): Remove the outer_scope parameter of', '  //                  RewriteParameterInitializerScope', '      (scope()->is_arrow_scope() || scope()->is_block_scope())) {', '    if (scope()->outer_scope()->is_arrow_scope() && scope()->is_block_scope()) {', '      RewriteParameterInitializerScope(parser_->stack_limit(), initializer,', '                                       scope()->outer_scope()->outer_scope(),', '                                       scope());', '    }']}",True,"The parser in Google V8, as used in Google Chrome before 53.0.2785.113, mishandles scopes, which allows remote attackers to obtain sensitive information from arbitrary memory locations via crafted JavaScript code.",6.5,MEDIUM,1,test,,5
CVE-2016-3900,['CWE-264'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"ServiceManager: Restore basic uid check

Prevent apps from registering services without relying on selinux checks.

Bug: 29431260

Change-Id: I38c6e8bc7f7cba1cbd3568e8fed1ae7ac2054a9b
(cherry picked from commit 2b74d2c1d2a2c1bb6e9c420f7e9b339ba2a95179)
",d3c6ce463ac91ecbeb2128beb475d31d3ca6ef42,https://android.googlesource.com/platform/frameworks/native/+/d3c6ce463ac91ecbeb2128beb475d31d3ca6ef42,cmds/servicemanager/service_manager.c,svc_can_register,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)
{
const char *perm = ""add"";
return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}","static int svc_can_register(const uint16_t *VAR_0, size_t VAR_1, pid_t VAR_2, uid_t VAR_3)
{
const char *VAR_4 = ""add"";
return check_mac_perms_from_lookup(VAR_2, VAR_3, VAR_4, str8(VAR_0, VAR_1)) ? 1 : 0;
}",android/d3c6ce463ac91ecbeb2128beb475d31d3ca6ef42/service_manager.c/vul/before/0.json,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)
{
    const char *perm = ""add"";

    if (uid >= AID_APP) {
        return 0; /* Don't allow apps to register services */
    }

    return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}","static int svc_can_register(const uint16_t *VAR_0, size_t VAR_1, pid_t VAR_2, uid_t VAR_3)
{
    const char *VAR_4 = ""add"";

    if (VAR_3 >= VAR_5) {
        return 0; /* COMMENT_0 */
    }

    return check_mac_perms_from_lookup(VAR_2, VAR_3, VAR_4, str8(VAR_0, VAR_1)) ? 1 : 0;
}",android/d3c6ce463ac91ecbeb2128beb475d31d3ca6ef42/service_manager.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,10 @@
 static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)
 {
     const char *perm = ""add"";
+
+    if (uid >= AID_APP) {
+        return 0; /* Don't allow apps to register services */
+    }
+
     return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
 }","{'deleted_lines': [], 'added_lines': ['', '    if (uid >= AID_APP) {', ""        return 0; /* Don't allow apps to register services */"", '    }', '']}",True,"cmds/servicemanager/service_manager.c in ServiceManager in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 does not properly restrict service registration, which allows attackers to gain privileges via a crafted application, aka internal bug 29431260.",7.8,HIGH,2,test,,5
CVE-2016-3900,['CWE-264'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"ServiceManager: Allow system services running as secondary users to add services

This should be reverted when all system services have been cleaned up to not
do this. A process looking up a service while running in the background will
see the service registered by the active user (assuming the service is
registered on every user switch), not the service registered by the user that
the process itself belongs to.

BUG: 30795333
Change-Id: I1b74d58be38ed358f43c163692f9e704f8f31dbe
(cherry picked from commit e6bbe69ba739c8a08837134437aaccfea5f1d943)
",047eec456943dc082e33220d28abb7df4e089f69,https://android.googlesource.com/platform/frameworks/native/+/047eec456943dc082e33220d28abb7df4e089f69,cmds/servicemanager/service_manager.c,svc_can_register,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)
{
const char *perm = ""add"";
if (uid >= AID_APP) {
return 0; 
}
return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}","static int svc_can_register(const uint16_t *VAR_0, size_t VAR_1, pid_t VAR_2, uid_t VAR_3)
{
const char *VAR_4 = ""add"";
if (VAR_3 >= VAR_5) {
return 0; 
}
return check_mac_perms_from_lookup(VAR_2, VAR_3, VAR_4, str8(VAR_0, VAR_1)) ? 1 : 0;
}",android/047eec456943dc082e33220d28abb7df4e089f69/service_manager.c/vul/before/0.json,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)
{
    const char *perm = ""add"";

    if (multiuser_get_app_id(uid) >= AID_APP) {
        return 0; /* Don't allow apps to register services */
    }

    return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}","static int svc_can_register(const uint16_t *VAR_0, size_t VAR_1, pid_t VAR_2, uid_t VAR_3)
{
    const char *VAR_4 = ""add"";

    if (multiuser_get_app_id(VAR_3) >= VAR_5) {
        return 0; /* COMMENT_0 */
    }

    return check_mac_perms_from_lookup(VAR_2, VAR_3, VAR_4, str8(VAR_0, VAR_1)) ? 1 : 0;
}",android/047eec456943dc082e33220d28abb7df4e089f69/service_manager.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 {
     const char *perm = ""add"";
 
-    if (uid >= AID_APP) {
+    if (multiuser_get_app_id(uid) >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 ","{'deleted_lines': ['    if (uid >= AID_APP) {'], 'added_lines': ['    if (multiuser_get_app_id(uid) >= AID_APP) {']}",True,"cmds/servicemanager/service_manager.c in ServiceManager in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 does not properly restrict service registration, which allows attackers to gain privileges via a crafted application, aka internal bug 29431260.",7.8,HIGH,2,test,,5
CVE-2016-6722,['CWE-200'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,android,"SampleIterator: clear members on seekTo error

Bug: 31091777
Change-Id: Iddf99d0011961d0fd3d755e57db4365b6a6a1193
(cherry picked from commit 03237ce0f9584c98ccda76c2474a4ae84c763f5b)
",89c03b3b9ff74a507a8b8334c50b08b334483556,https://android.googlesource.com/platform/frameworks/av/+/89c03b3b9ff74a507a8b8334c50b08b334483556,media/libstagefright/SampleIterator.cpp,SampleIterator::seekTo,"status_t SampleIterator::seekTo(uint32_t sampleIndex) {
ALOGV(""seekTo(%d)"", sampleIndex);
if (sampleIndex >= mTable->mNumSampleSizes) {
return ERROR_END_OF_STREAM;
}
if (mTable->mSampleToChunkOffset < 0
|| mTable->mChunkOffsetOffset < 0
|| mTable->mSampleSizeOffset < 0
|| mTable->mTimeToSampleCount == 0) {
return ERROR_MALFORMED;
}
if (mInitialized && mCurrentSampleIndex == sampleIndex) {
return OK;
}
if (!mInitialized || sampleIndex < mFirstChunkSampleIndex) {
reset();
}
if (sampleIndex >= mStopChunkSampleIndex) {
status_t err;
if ((err = findChunkRange(sampleIndex)) != OK) {
ALOGE(""findChunkRange failed"");
return err;
}
}
CHECK(sampleIndex < mStopChunkSampleIndex);
if (mSamplesPerChunk == 0) {
ALOGE(""b/22802344"");
return ERROR_MALFORMED;
}
uint32_t chunk =
(sampleIndex - mFirstChunkSampleIndex) / mSamplesPerChunk
+ mFirstChunk;
if (!mInitialized || chunk != mCurrentChunkIndex) {
mCurrentChunkIndex = chunk;
status_t err;
if ((err = getChunkOffset(chunk, &mCurrentChunkOffset)) != OK) {
ALOGE(""getChunkOffset return error"");
return err;
}
mCurrentChunkSampleSizes.clear();
uint32_t firstChunkSampleIndex =
mFirstChunkSampleIndex
+ mSamplesPerChunk * (mCurrentChunkIndex - mFirstChunk);
for (uint32_t i = 0; i < mSamplesPerChunk; ++i) {
size_t sampleSize;
if ((err = getSampleSizeDirect(
firstChunkSampleIndex + i, &sampleSize)) != OK) {
ALOGE(""getSampleSizeDirect return error"");
return err;
}
mCurrentChunkSampleSizes.push(sampleSize);
}
}
uint32_t chunkRelativeSampleIndex =
(sampleIndex - mFirstChunkSampleIndex) % mSamplesPerChunk;
mCurrentSampleOffset = mCurrentChunkOffset;
for (uint32_t i = 0; i < chunkRelativeSampleIndex; ++i) {
mCurrentSampleOffset += mCurrentChunkSampleSizes[i];
}
mCurrentSampleSize = mCurrentChunkSampleSizes[chunkRelativeSampleIndex];
if (sampleIndex < mTTSSampleIndex) {
mTimeToSampleIndex = 0;
mTTSSampleIndex = 0;
mTTSSampleTime = 0;
mTTSCount = 0;
mTTSDuration = 0;
}
status_t err;
if ((err = findSampleTimeAndDuration(
sampleIndex, &mCurrentSampleTime, &mCurrentSampleDuration)) != OK) {
ALOGE(""findSampleTime return error"");
return err;
}
mCurrentSampleIndex = sampleIndex;
mInitialized = true;
return OK;
}","status_t SampleIterator::seekTo(uint32_t VAR_0) {
ALOGV(""seekTo(%d)"", VAR_0);
if (VAR_0 >= VAR_1->mNumSampleSizes) {
return VAR_2;
}
if (VAR_1->mSampleToChunkOffset < 0
|| VAR_1->mChunkOffsetOffset < 0
|| VAR_1->mSampleSizeOffset < 0
|| VAR_1->mTimeToSampleCount == 0) {
return VAR_3;
}
if (VAR_4 && VAR_5 == VAR_0) {
return VAR_6;
}
if (!VAR_4 || VAR_0 < VAR_7) {
reset();
}
if (VAR_0 >= VAR_8) {
status_t VAR_9;
if ((VAR_9 = findChunkRange(VAR_0)) != VAR_6) {
ALOGE(""findChunkRange failed"");
return VAR_9;
}
}
CHECK(VAR_0 < VAR_8);
if (VAR_10 == 0) {
ALOGE(""b/22802344"");
return VAR_3;
}
uint32_t VAR_11 =
(VAR_0 - VAR_7) / VAR_10
+ VAR_12;
if (!VAR_4 || VAR_11 != VAR_13) {
VAR_13 = VAR_11;
status_t VAR_9;
if ((VAR_9 = getChunkOffset(VAR_11, &VAR_14)) != VAR_6) {
ALOGE(""getChunkOffset return error"");
return VAR_9;
}
VAR_15.clear();
uint32_t VAR_16 =
VAR_7
+ VAR_10 * (VAR_13 - VAR_12);
for (uint32_t VAR_17 = 0; VAR_17 < VAR_10; ++VAR_17) {
size_t VAR_18;
if ((VAR_9 = getSampleSizeDirect(
VAR_16 + VAR_17, &VAR_18)) != VAR_6) {
ALOGE(""getSampleSizeDirect return error"");
return VAR_9;
}
VAR_15.push(VAR_18);
}
}
uint32_t VAR_19 =
(VAR_0 - VAR_7) % VAR_10;
VAR_20 = VAR_14;
for (uint32_t VAR_17 = 0; VAR_17 < VAR_19; ++VAR_17) {
VAR_20 += VAR_15[VAR_17];
}
VAR_21 = VAR_15[VAR_19];
if (VAR_0 < VAR_22) {
VAR_23 = 0;
VAR_22 = 0;
VAR_24 = 0;
VAR_25 = 0;
VAR_26 = 0;
}
status_t VAR_9;
if ((VAR_9 = findSampleTimeAndDuration(
VAR_0, &VAR_27, &VAR_28)) != VAR_6) {
ALOGE(""findSampleTime return error"");
return VAR_9;
}
VAR_5 = VAR_0;
VAR_4 = true;
return VAR_6;
}",android/89c03b3b9ff74a507a8b8334c50b08b334483556/SampleIterator.cpp/vul/before/0.json,"status_t SampleIterator::seekTo(uint32_t sampleIndex) {
    ALOGV(""seekTo(%d)"", sampleIndex);

    if (sampleIndex >= mTable->mNumSampleSizes) {
        return ERROR_END_OF_STREAM;
    }

    if (mTable->mSampleToChunkOffset < 0
            || mTable->mChunkOffsetOffset < 0
            || mTable->mSampleSizeOffset < 0
            || mTable->mTimeToSampleCount == 0) {

        return ERROR_MALFORMED;
    }

    if (mInitialized && mCurrentSampleIndex == sampleIndex) {
        return OK;
    }

    if (!mInitialized || sampleIndex < mFirstChunkSampleIndex) {
        reset();
    }

    if (sampleIndex >= mStopChunkSampleIndex) {
        status_t err;
        if ((err = findChunkRange(sampleIndex)) != OK) {
            ALOGE(""findChunkRange failed"");
            return err;
        }
    }

    CHECK(sampleIndex < mStopChunkSampleIndex);

    if (mSamplesPerChunk == 0) {
        ALOGE(""b/22802344"");
        return ERROR_MALFORMED;
    }

    uint32_t chunk =
        (sampleIndex - mFirstChunkSampleIndex) / mSamplesPerChunk
        + mFirstChunk;

    if (!mInitialized || chunk != mCurrentChunkIndex) {
        status_t err;
        if ((err = getChunkOffset(chunk, &mCurrentChunkOffset)) != OK) {
            ALOGE(""getChunkOffset return error"");
            return err;
        }

        mCurrentChunkSampleSizes.clear();

        uint32_t firstChunkSampleIndex =
            mFirstChunkSampleIndex
                + mSamplesPerChunk * (chunk - mFirstChunk);

        for (uint32_t i = 0; i < mSamplesPerChunk; ++i) {
            size_t sampleSize;
            if ((err = getSampleSizeDirect(
                            firstChunkSampleIndex + i, &sampleSize)) != OK) {
                ALOGE(""getSampleSizeDirect return error"");
                mCurrentChunkSampleSizes.clear();
                return err;
            }

            mCurrentChunkSampleSizes.push(sampleSize);
        }

        mCurrentChunkIndex = chunk;
    }

    uint32_t chunkRelativeSampleIndex =
        (sampleIndex - mFirstChunkSampleIndex) % mSamplesPerChunk;

    mCurrentSampleOffset = mCurrentChunkOffset;
    for (uint32_t i = 0; i < chunkRelativeSampleIndex; ++i) {
        mCurrentSampleOffset += mCurrentChunkSampleSizes[i];
    }

    mCurrentSampleSize = mCurrentChunkSampleSizes[chunkRelativeSampleIndex];
    if (sampleIndex < mTTSSampleIndex) {
        mTimeToSampleIndex = 0;
        mTTSSampleIndex = 0;
        mTTSSampleTime = 0;
        mTTSCount = 0;
        mTTSDuration = 0;
    }

    status_t err;
    if ((err = findSampleTimeAndDuration(
            sampleIndex, &mCurrentSampleTime, &mCurrentSampleDuration)) != OK) {
        ALOGE(""findSampleTime return error"");
        return err;
    }

    mCurrentSampleIndex = sampleIndex;

    mInitialized = true;

    return OK;
}","status_t SampleIterator::seekTo(uint32_t VAR_0) {
    ALOGV(""seekTo(%d)"", VAR_0);

    if (VAR_0 >= VAR_1->mNumSampleSizes) {
        return VAR_2;
    }

    if (VAR_1->mSampleToChunkOffset < 0
            || VAR_1->mChunkOffsetOffset < 0
            || VAR_1->mSampleSizeOffset < 0
            || VAR_1->mTimeToSampleCount == 0) {

        return VAR_3;
    }

    if (VAR_4 && VAR_5 == VAR_0) {
        return VAR_6;
    }

    if (!VAR_4 || VAR_0 < VAR_7) {
        reset();
    }

    if (VAR_0 >= VAR_8) {
        status_t VAR_9;
        if ((VAR_9 = findChunkRange(VAR_0)) != VAR_6) {
            ALOGE(""findChunkRange failed"");
            return VAR_9;
        }
    }

    CHECK(VAR_0 < VAR_8);

    if (VAR_10 == 0) {
        ALOGE(""b/22802344"");
        return VAR_3;
    }

    uint32_t VAR_11 =
        (VAR_0 - VAR_7) / VAR_10
        + VAR_12;

    if (!VAR_4 || VAR_11 != VAR_13) {
        status_t VAR_9;
        if ((VAR_9 = getChunkOffset(VAR_11, &VAR_14)) != VAR_6) {
            ALOGE(""getChunkOffset return error"");
            return VAR_9;
        }

        VAR_15.clear();

        uint32_t VAR_16 =
            VAR_7
                + VAR_10 * (VAR_11 - VAR_12);

        for (uint32_t VAR_17 = 0; VAR_17 < VAR_10; ++VAR_17) {
            size_t VAR_18;
            if ((VAR_9 = getSampleSizeDirect(
                            VAR_16 + VAR_17, &VAR_18)) != VAR_6) {
                ALOGE(""getSampleSizeDirect return error"");
                VAR_15.clear();
                return VAR_9;
            }

            VAR_15.push(VAR_18);
        }

        VAR_13 = VAR_11;
    }

    uint32_t VAR_19 =
        (VAR_0 - VAR_7) % VAR_10;

    VAR_20 = VAR_14;
    for (uint32_t VAR_17 = 0; VAR_17 < VAR_19; ++VAR_17) {
        VAR_20 += VAR_15[VAR_17];
    }

    VAR_21 = VAR_15[VAR_19];
    if (VAR_0 < VAR_22) {
        VAR_23 = 0;
        VAR_22 = 0;
        VAR_24 = 0;
        VAR_25 = 0;
        VAR_26 = 0;
    }

    status_t VAR_9;
    if ((VAR_9 = findSampleTimeAndDuration(
            VAR_0, &VAR_27, &VAR_28)) != VAR_6) {
        ALOGE(""findSampleTime return error"");
        return VAR_9;
    }

    VAR_5 = VAR_0;

    VAR_4 = true;

    return VAR_6;
}",android/89c03b3b9ff74a507a8b8334c50b08b334483556/SampleIterator.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -41,8 +41,6 @@
         + mFirstChunk;
 
     if (!mInitialized || chunk != mCurrentChunkIndex) {
-        mCurrentChunkIndex = chunk;
-
         status_t err;
         if ((err = getChunkOffset(chunk, &mCurrentChunkOffset)) != OK) {
             ALOGE(""getChunkOffset return error"");
@@ -53,18 +51,21 @@
 
         uint32_t firstChunkSampleIndex =
             mFirstChunkSampleIndex
-                + mSamplesPerChunk * (mCurrentChunkIndex - mFirstChunk);
+                + mSamplesPerChunk * (chunk - mFirstChunk);
 
         for (uint32_t i = 0; i < mSamplesPerChunk; ++i) {
             size_t sampleSize;
             if ((err = getSampleSizeDirect(
                             firstChunkSampleIndex + i, &sampleSize)) != OK) {
                 ALOGE(""getSampleSizeDirect return error"");
+                mCurrentChunkSampleSizes.clear();
                 return err;
             }
 
             mCurrentChunkSampleSizes.push(sampleSize);
         }
+
+        mCurrentChunkIndex = chunk;
     }
 
     uint32_t chunkRelativeSampleIndex =","{'deleted_lines': ['        mCurrentChunkIndex = chunk;', '', '                + mSamplesPerChunk * (mCurrentChunkIndex - mFirstChunk);'], 'added_lines': ['                + mSamplesPerChunk * (chunk - mFirstChunk);', '                mCurrentChunkSampleSizes.clear();', '', '        mCurrentChunkIndex = chunk;']}",True,"An information disclosure vulnerability in libstagefright in Mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-11-01, and 7.0 before 2016-11-01 could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Android ID: A-31091777.",5.5,MEDIUM,1,test,,5
CVE-2017-0396,['CWE-200'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,android,"Visualizer: Check capture size and latency parameters

Bug: 31781965
Change-Id: I1c439a0d0f6aa0057b3c651499f28426e1e1f5e4
(cherry picked from commit 9a2732ba0a8d609ab040d2c1ddee28577ead9772)
",557bd7bfe6c4895faee09e46fc9b5304a956c8b7,https://android.googlesource.com/platform/frameworks/av/+/557bd7bfe6c4895faee09e46fc9b5304a956c8b7,media/libeffects/visualizer/EffectVisualizer.cpp,Visualizer_command,"int Visualizer_command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,
void *pCmdData, uint32_t *replySize, void *pReplyData) {
VisualizerContext * pContext = (VisualizerContext *)self;
int retsize;
if (pContext == NULL || pContext->mState == VISUALIZER_STATE_UNINITIALIZED) {
return -EINVAL;
}
switch (cmdCode) {
case EFFECT_CMD_INIT:
if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
return -EINVAL;
}
*(int *) pReplyData = Visualizer_init(pContext);
break;
case EFFECT_CMD_SET_CONFIG:
if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)
|| pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
return -EINVAL;
}
*(int *) pReplyData = Visualizer_setConfig(pContext,
(effect_config_t *) pCmdData);
break;
case EFFECT_CMD_GET_CONFIG:
if (pReplyData == NULL || replySize == NULL ||
*replySize != sizeof(effect_config_t)) {
return -EINVAL;
}
Visualizer_getConfig(pContext, (effect_config_t *)pReplyData);
break;
case EFFECT_CMD_RESET:
Visualizer_reset(pContext);
break;
case EFFECT_CMD_ENABLE:
if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
return -EINVAL;
}
if (pContext->mState != VISUALIZER_STATE_INITIALIZED) {
return -ENOSYS;
}
pContext->mState = VISUALIZER_STATE_ACTIVE;
ALOGV(""EFFECT_CMD_ENABLE() OK"");
*(int *)pReplyData = 0;
break;
case EFFECT_CMD_DISABLE:
if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
return -EINVAL;
}
if (pContext->mState != VISUALIZER_STATE_ACTIVE) {
return -ENOSYS;
}
pContext->mState = VISUALIZER_STATE_INITIALIZED;
ALOGV(""EFFECT_CMD_DISABLE() OK"");
*(int *)pReplyData = 0;
break;
case EFFECT_CMD_GET_PARAM: {
if (pCmdData == NULL ||
cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||
pReplyData == NULL || replySize == NULL ||
*replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t))) {
return -EINVAL;
}
memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(uint32_t));
effect_param_t *p = (effect_param_t *)pReplyData;
p->status = 0;
*replySize = sizeof(effect_param_t) + sizeof(uint32_t);
if (p->psize != sizeof(uint32_t)) {
p->status = -EINVAL;
break;
}
switch (*(uint32_t *)p->data) {
case VISUALIZER_PARAM_CAPTURE_SIZE:
ALOGV(""get mCaptureSize = %"" PRIu32, pContext->mCaptureSize);
*((uint32_t *)p->data + 1) = pContext->mCaptureSize;
p->vsize = sizeof(uint32_t);
*replySize += sizeof(uint32_t);
break;
case VISUALIZER_PARAM_SCALING_MODE:
ALOGV(""get mScalingMode = %"" PRIu32, pContext->mScalingMode);
*((uint32_t *)p->data + 1) = pContext->mScalingMode;
p->vsize = sizeof(uint32_t);
*replySize += sizeof(uint32_t);
break;
case VISUALIZER_PARAM_MEASUREMENT_MODE:
ALOGV(""get mMeasurementMode = %"" PRIu32, pContext->mMeasurementMode);
*((uint32_t *)p->data + 1) = pContext->mMeasurementMode;
p->vsize = sizeof(uint32_t);
*replySize += sizeof(uint32_t);
break;
default:
p->status = -EINVAL;
}
} break;
case EFFECT_CMD_SET_PARAM: {
if (pCmdData == NULL ||
cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||
pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {
return -EINVAL;
}
*(int32_t *)pReplyData = 0;
effect_param_t *p = (effect_param_t *)pCmdData;
if (p->psize != sizeof(uint32_t) || p->vsize != sizeof(uint32_t)) {
*(int32_t *)pReplyData = -EINVAL;
break;
}
switch (*(uint32_t *)p->data) {
case VISUALIZER_PARAM_CAPTURE_SIZE:
pContext->mCaptureSize = *((uint32_t *)p->data + 1);
ALOGV(""set mCaptureSize = %"" PRIu32, pContext->mCaptureSize);
break;
case VISUALIZER_PARAM_SCALING_MODE:
pContext->mScalingMode = *((uint32_t *)p->data + 1);
ALOGV(""set mScalingMode = %"" PRIu32, pContext->mScalingMode);
break;
case VISUALIZER_PARAM_LATENCY:
pContext->mLatency = *((uint32_t *)p->data + 1);
ALOGV(""set mLatency = %"" PRIu32, pContext->mLatency);
break;
case VISUALIZER_PARAM_MEASUREMENT_MODE:
pContext->mMeasurementMode = *((uint32_t *)p->data + 1);
ALOGV(""set mMeasurementMode = %"" PRIu32, pContext->mMeasurementMode);
break;
default:
*(int32_t *)pReplyData = -EINVAL;
}
} break;
case EFFECT_CMD_SET_DEVICE:
case EFFECT_CMD_SET_VOLUME:
case EFFECT_CMD_SET_AUDIO_MODE:
break;
case VISUALIZER_CMD_CAPTURE: {
uint32_t captureSize = pContext->mCaptureSize;
if (pReplyData == NULL || replySize == NULL || *replySize != captureSize) {
ALOGV(""VISUALIZER_CMD_CAPTURE() error *replySize %"" PRIu32 "" captureSize %"" PRIu32,
*replySize, captureSize);
return -EINVAL;
}
if (pContext->mState == VISUALIZER_STATE_ACTIVE) {
const uint32_t deltaMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);
if ((pContext->mLastCaptureIdx == pContext->mCaptureIdx) &&
(pContext->mBufferUpdateTime.tv_sec != 0) &&
(deltaMs > MAX_STALL_TIME_MS)) {
ALOGV(""capture going to idle"");
pContext->mBufferUpdateTime.tv_sec = 0;
memset(pReplyData, 0x80, captureSize);
} else {
int32_t latencyMs = pContext->mLatency;
latencyMs -= deltaMs;
if (latencyMs < 0) {
latencyMs = 0;
}
const uint32_t deltaSmpl =
pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;
int32_t capturePoint = pContext->mCaptureIdx - captureSize - deltaSmpl;
if (capturePoint < 0) {
uint32_t size = -capturePoint;
if (size > captureSize) {
size = captureSize;
}
memcpy(pReplyData,
pContext->mCaptureBuf + CAPTURE_BUF_SIZE + capturePoint,
size);
pReplyData = (char *)pReplyData + size;
captureSize -= size;
capturePoint = 0;
}
memcpy(pReplyData,
pContext->mCaptureBuf + capturePoint,
captureSize);
}
pContext->mLastCaptureIdx = pContext->mCaptureIdx;
} else {
memset(pReplyData, 0x80, captureSize);
}
} break;
case VISUALIZER_CMD_MEASURE: {
if (pReplyData == NULL || replySize == NULL ||
*replySize < (sizeof(int32_t) * MEASUREMENT_COUNT)) {
if (replySize == NULL) {
ALOGV(""VISUALIZER_CMD_MEASURE() error replySize NULL"");
} else {
ALOGV(""VISUALIZER_CMD_MEASURE() error *replySize %"" PRIu32
"" < (sizeof(int32_t) * MEASUREMENT_COUNT) %"" PRIu32,
*replySize,
uint32_t(sizeof(int32_t)) * MEASUREMENT_COUNT);
}
android_errorWriteLog(0x534e4554, ""30229821"");
return -EINVAL;
}
uint16_t peakU16 = 0;
float sumRmsSquared = 0.0f;
uint8_t nbValidMeasurements = 0;
const int32_t delayMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);
if (delayMs > DISCARD_MEASUREMENTS_TIME_MS) {
ALOGV(""Discarding measurements, last measurement is %"" PRId32 ""ms old"", delayMs);
for (uint32_t i=0 ; i<pContext->mMeasurementWindowSizeInBuffers ; i++) {
pContext->mPastMeasurements[i].mIsValid = false;
pContext->mPastMeasurements[i].mPeakU16 = 0;
pContext->mPastMeasurements[i].mRmsSquared = 0;
}
pContext->mMeasurementBufferIdx = 0;
} else {
for (uint32_t i=0 ; i < pContext->mMeasurementWindowSizeInBuffers ; i++) {
if (pContext->mPastMeasurements[i].mIsValid) {
if (pContext->mPastMeasurements[i].mPeakU16 > peakU16) {
peakU16 = pContext->mPastMeasurements[i].mPeakU16;
}
sumRmsSquared += pContext->mPastMeasurements[i].mRmsSquared;
nbValidMeasurements++;
}
}
}
float rms = nbValidMeasurements == 0 ? 0.0f : sqrtf(sumRmsSquared / nbValidMeasurements);
int32_t* pIntReplyData = (int32_t*)pReplyData;
if (rms < 0.000016f) {
pIntReplyData[MEASUREMENT_IDX_RMS] = -9600;         } else {
pIntReplyData[MEASUREMENT_IDX_RMS] = (int32_t) (2000 * log10(rms / 32767.0f));
}
if (peakU16 == 0) {
pIntReplyData[MEASUREMENT_IDX_PEAK] = -9600;         } else {
pIntReplyData[MEASUREMENT_IDX_PEAK] = (int32_t) (2000 * log10(peakU16 / 32767.0f));
}
ALOGV(""VISUALIZER_CMD_MEASURE peak=%"" PRIu16 "" (%"" PRId32 ""mB), rms=%.1f (%"" PRId32 ""mB)"",
peakU16, pIntReplyData[MEASUREMENT_IDX_PEAK],
rms, pIntReplyData[MEASUREMENT_IDX_RMS]);
}
break;
default:
ALOGW(""Visualizer_command invalid command %"" PRIu32, cmdCode);
return -EINVAL;
}
return 0;
}","int Visualizer_command(effect_handle_t VAR_0, uint32_t VAR_1, uint32_t VAR_2,
void *VAR_3, uint32_t *VAR_4, void *VAR_5) {
VisualizerContext * VAR_6 = (VisualizerContext *)VAR_0;
int VAR_7;
if (VAR_6 == NULL || VAR_6->mState == VAR_8) {
return -VAR_9;
}
switch (VAR_1) {
case VAR_10:
if (VAR_5 == NULL || VAR_4 == NULL || *VAR_4 != sizeof(int)) {
return -VAR_9;
}
*(int *) VAR_5 = Visualizer_init(VAR_6);
break;
case VAR_11:
if (VAR_3 == NULL || VAR_2 != sizeof(VAR_12)
|| VAR_5 == NULL || VAR_4 == NULL || *VAR_4 != sizeof(int)) {
return -VAR_9;
}
*(int *) VAR_5 = Visualizer_setConfig(VAR_6,
(effect_config_t *) VAR_3);
break;
case VAR_13:
if (VAR_5 == NULL || VAR_4 == NULL ||
*VAR_4 != sizeof(effect_config_t)) {
return -VAR_9;
}
Visualizer_getConfig(VAR_6, (effect_config_t *)VAR_5);
break;
case VAR_14:
Visualizer_reset(VAR_6);
break;
case VAR_15:
if (VAR_5 == NULL || VAR_4 == NULL || *VAR_4 != sizeof(int)) {
return -VAR_9;
}
if (VAR_6->mState != VAR_16) {
return -VAR_17;
}
VAR_6->mState = VAR_18;
ALOGV(""EFFECT_CMD_ENABLE() OK"");
*(int *)VAR_5 = 0;
break;
case VAR_19:
if (VAR_5 == NULL || VAR_4 == NULL || *VAR_4 != sizeof(int)) {
return -VAR_9;
}
if (VAR_6->mState != VAR_18) {
return -VAR_17;
}
VAR_6->mState = VAR_16;
ALOGV(""EFFECT_CMD_DISABLE() OK"");
*(int *)VAR_5 = 0;
break;
case VAR_20: {
if (VAR_3 == NULL ||
VAR_2 != (int)(sizeof(VAR_21) + sizeof(uint32_t)) ||
VAR_5 == NULL || VAR_4 == NULL ||
*VAR_4 < (int)(sizeof(VAR_21) + sizeof(uint32_t) + sizeof(uint32_t))) {
return -VAR_9;
}
memcpy(VAR_5, VAR_3, sizeof(VAR_21) + sizeof(uint32_t));
effect_param_t *VAR_22 = (effect_param_t *)VAR_5;
VAR_22->status = 0;
*VAR_4 = sizeof(effect_param_t) + sizeof(uint32_t);
if (VAR_22->psize != sizeof(uint32_t)) {
VAR_22->status = -VAR_9;
break;
}
switch (*(uint32_t *)VAR_22->data) {
case VAR_23:
ALOGV(""get mCaptureSize = %"" VAR_24, VAR_6->mCaptureSize);
*((uint32_t *)VAR_22->data + 1) = VAR_6->mCaptureSize;
VAR_22->vsize = sizeof(uint32_t);
*VAR_4 += sizeof(uint32_t);
break;
case VAR_25:
ALOGV(""get mScalingMode = %"" VAR_24, VAR_6->mScalingMode);
*((uint32_t *)VAR_22->data + 1) = VAR_6->mScalingMode;
VAR_22->vsize = sizeof(uint32_t);
*VAR_4 += sizeof(uint32_t);
break;
case VAR_26:
ALOGV(""get mMeasurementMode = %"" VAR_24, VAR_6->mMeasurementMode);
*((uint32_t *)VAR_22->data + 1) = VAR_6->mMeasurementMode;
VAR_22->vsize = sizeof(uint32_t);
*VAR_4 += sizeof(uint32_t);
break;
default:
VAR_22->status = -VAR_9;
}
} break;
case VAR_27: {
if (VAR_3 == NULL ||
VAR_2 != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||
VAR_5 == NULL || VAR_4 == NULL || *VAR_4 != sizeof(int32_t)) {
return -VAR_9;
}
*(int32_t *)VAR_5 = 0;
effect_param_t *VAR_22 = (effect_param_t *)VAR_3;
if (VAR_22->psize != sizeof(uint32_t) || VAR_22->vsize != sizeof(uint32_t)) {
*(int32_t *)VAR_5 = -VAR_9;
break;
}
switch (*(uint32_t *)VAR_22->data) {
case VAR_23:
VAR_6->mCaptureSize = *((uint32_t *)VAR_22->data + 1);
ALOGV(""set mCaptureSize = %"" VAR_24, VAR_6->mCaptureSize);
break;
case VAR_25:
VAR_6->mScalingMode = *((uint32_t *)VAR_22->data + 1);
ALOGV(""set mScalingMode = %"" VAR_24, VAR_6->mScalingMode);
break;
case VAR_28:
VAR_6->mLatency = *((uint32_t *)VAR_22->data + 1);
ALOGV(""set mLatency = %"" VAR_24, VAR_6->mLatency);
break;
case VAR_26:
VAR_6->mMeasurementMode = *((uint32_t *)VAR_22->data + 1);
ALOGV(""set mMeasurementMode = %"" VAR_24, VAR_6->mMeasurementMode);
break;
default:
*(int32_t *)VAR_5 = -VAR_9;
}
} break;
case VAR_29:
case VAR_30:
case VAR_31:
break;
case VAR_32: {
uint32_t VAR_33 = VAR_6->mCaptureSize;
if (VAR_5 == NULL || VAR_4 == NULL || *VAR_4 != VAR_33) {
ALOGV(""VISUALIZER_CMD_CAPTURE() error *replySize %"" VAR_24 "" captureSize %"" VAR_24,
*VAR_4, VAR_33);
return -VAR_9;
}
if (VAR_6->mState == VAR_18) {
const uint32_t VAR_34 = Visualizer_getDeltaTimeMsFromUpdatedTime(VAR_6);
if ((VAR_6->mLastCaptureIdx == VAR_6->mCaptureIdx) &&
(VAR_6->mBufferUpdateTime.tv_sec != 0) &&
(VAR_34 > VAR_35)) {
ALOGV(""capture going to idle"");
VAR_6->mBufferUpdateTime.tv_sec = 0;
memset(VAR_5, 0x80, VAR_33);
} else {
int32_t VAR_36 = VAR_6->mLatency;
VAR_36 -= VAR_34;
if (VAR_36 < 0) {
VAR_36 = 0;
}
const uint32_t VAR_37 =
VAR_6->mConfig.inputCfg.samplingRate * VAR_36 / 1000;
int32_t VAR_38 = VAR_6->mCaptureIdx - VAR_33 - VAR_37;
if (VAR_38 < 0) {
uint32_t VAR_39 = -VAR_38;
if (VAR_39 > VAR_33) {
VAR_39 = VAR_33;
}
memcpy(VAR_5,
VAR_6->mCaptureBuf + VAR_40 + VAR_38,
VAR_39);
VAR_5 = (char *)VAR_5 + VAR_39;
VAR_33 -= VAR_39;
VAR_38 = 0;
}
memcpy(VAR_5,
VAR_6->mCaptureBuf + VAR_38,
VAR_33);
}
VAR_6->mLastCaptureIdx = VAR_6->mCaptureIdx;
} else {
memset(VAR_5, 0x80, VAR_33);
}
} break;
case VAR_41: {
if (VAR_5 == NULL || VAR_4 == NULL ||
*VAR_4 < (sizeof(int32_t) * VAR_42)) {
if (VAR_4 == NULL) {
ALOGV(""VISUALIZER_CMD_MEASURE() error replySize NULL"");
} else {
ALOGV(""VISUALIZER_CMD_MEASURE() error *replySize %"" VAR_24
"" < (sizeof(int32_t) * MEASUREMENT_COUNT) %"" VAR_24,
*VAR_4,
uint32_t(sizeof(int32_t)) * VAR_42);
}
android_errorWriteLog(0x534e4554, ""30229821"");
return -VAR_9;
}
uint16_t VAR_43 = 0;
float VAR_44 = 0.0f;
uint8_t VAR_45 = 0;
const int32_t VAR_46 = Visualizer_getDeltaTimeMsFromUpdatedTime(VAR_6);
if (VAR_46 > VAR_47) {
ALOGV(""Discarding measurements, last measurement is %"" VAR_48 ""ms old"", VAR_46);
for (uint32_t VAR_49=0 ; VAR_49<VAR_6->mMeasurementWindowSizeInBuffers ; VAR_49++) {
VAR_6->mPastMeasurements[VAR_49].mIsValid = false;
VAR_6->mPastMeasurements[VAR_49].mPeakU16 = 0;
VAR_6->mPastMeasurements[VAR_49].mRmsSquared = 0;
}
VAR_6->mMeasurementBufferIdx = 0;
} else {
for (uint32_t VAR_49=0 ; VAR_49 < VAR_6->mMeasurementWindowSizeInBuffers ; VAR_49++) {
if (VAR_6->mPastMeasurements[VAR_49].mIsValid) {
if (VAR_6->mPastMeasurements[VAR_49].mPeakU16 > VAR_43) {
VAR_43 = VAR_6->mPastMeasurements[VAR_49].mPeakU16;
}
VAR_44 += VAR_6->mPastMeasurements[VAR_49].mRmsSquared;
VAR_45++;
}
}
}
float VAR_50 = VAR_45 == 0 ? 0.0f : sqrtf(VAR_44 / VAR_45);
int32_t* VAR_51 = (int32_t*)VAR_5;
if (VAR_50 < 0.000016f) {
VAR_51[VAR_52] = -9600; 
} else {
VAR_51[VAR_52] = (int32_t) (2000 * log10(VAR_50 / 32767.0f));
}
if (VAR_43 == 0) {
VAR_51[VAR_53] = -9600; 
} else {
VAR_51[VAR_53] = (int32_t) (2000 * log10(VAR_43 / 32767.0f));
}
ALOGV(""VISUALIZER_CMD_MEASURE peak=%"" VAR_54 "" (%"" VAR_48 ""mB), rms=%.1f (%"" VAR_48 ""mB)"",
VAR_43, VAR_51[VAR_53],
VAR_50, VAR_51[VAR_52]);
}
break;
default:
ALOGW(""Visualizer_command invalid command %"" VAR_24, VAR_1);
return -VAR_9;
}
return 0;
}",android/557bd7bfe6c4895faee09e46fc9b5304a956c8b7/EffectVisualizer.cpp/vul/before/0.json,"int Visualizer_command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,
        void *pCmdData, uint32_t *replySize, void *pReplyData) {

    VisualizerContext * pContext = (VisualizerContext *)self;
    int retsize;

    if (pContext == NULL || pContext->mState == VISUALIZER_STATE_UNINITIALIZED) {
        return -EINVAL;
    }

//    ALOGV(""Visualizer_command command %"" PRIu32 "" cmdSize %"" PRIu32, cmdCode, cmdSize);

    switch (cmdCode) {
    case EFFECT_CMD_INIT:
        if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
            return -EINVAL;
        }
        *(int *) pReplyData = Visualizer_init(pContext);
        break;
    case EFFECT_CMD_SET_CONFIG:
        if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)
                || pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
            return -EINVAL;
        }
        *(int *) pReplyData = Visualizer_setConfig(pContext,
                (effect_config_t *) pCmdData);
        break;
    case EFFECT_CMD_GET_CONFIG:
        if (pReplyData == NULL || replySize == NULL ||
            *replySize != sizeof(effect_config_t)) {
            return -EINVAL;
        }
        Visualizer_getConfig(pContext, (effect_config_t *)pReplyData);
        break;
    case EFFECT_CMD_RESET:
        Visualizer_reset(pContext);
        break;
    case EFFECT_CMD_ENABLE:
        if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
            return -EINVAL;
        }
        if (pContext->mState != VISUALIZER_STATE_INITIALIZED) {
            return -ENOSYS;
        }
        pContext->mState = VISUALIZER_STATE_ACTIVE;
        ALOGV(""EFFECT_CMD_ENABLE() OK"");
        *(int *)pReplyData = 0;
        break;
    case EFFECT_CMD_DISABLE:
        if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
            return -EINVAL;
        }
        if (pContext->mState != VISUALIZER_STATE_ACTIVE) {
            return -ENOSYS;
        }
        pContext->mState = VISUALIZER_STATE_INITIALIZED;
        ALOGV(""EFFECT_CMD_DISABLE() OK"");
        *(int *)pReplyData = 0;
        break;
    case EFFECT_CMD_GET_PARAM: {
        if (pCmdData == NULL ||
            cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||
            pReplyData == NULL || replySize == NULL ||
            *replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t))) {
            return -EINVAL;
        }
        memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(uint32_t));
        effect_param_t *p = (effect_param_t *)pReplyData;
        p->status = 0;
        *replySize = sizeof(effect_param_t) + sizeof(uint32_t);
        if (p->psize != sizeof(uint32_t)) {
            p->status = -EINVAL;
            break;
        }
        switch (*(uint32_t *)p->data) {
        case VISUALIZER_PARAM_CAPTURE_SIZE:
            ALOGV(""get mCaptureSize = %"" PRIu32, pContext->mCaptureSize);
            *((uint32_t *)p->data + 1) = pContext->mCaptureSize;
            p->vsize = sizeof(uint32_t);
            *replySize += sizeof(uint32_t);
            break;
        case VISUALIZER_PARAM_SCALING_MODE:
            ALOGV(""get mScalingMode = %"" PRIu32, pContext->mScalingMode);
            *((uint32_t *)p->data + 1) = pContext->mScalingMode;
            p->vsize = sizeof(uint32_t);
            *replySize += sizeof(uint32_t);
            break;
        case VISUALIZER_PARAM_MEASUREMENT_MODE:
            ALOGV(""get mMeasurementMode = %"" PRIu32, pContext->mMeasurementMode);
            *((uint32_t *)p->data + 1) = pContext->mMeasurementMode;
            p->vsize = sizeof(uint32_t);
            *replySize += sizeof(uint32_t);
            break;
        default:
            p->status = -EINVAL;
        }
        } break;
    case EFFECT_CMD_SET_PARAM: {
        if (pCmdData == NULL ||
            cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||
            pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {
            return -EINVAL;
        }
        *(int32_t *)pReplyData = 0;
        effect_param_t *p = (effect_param_t *)pCmdData;
        if (p->psize != sizeof(uint32_t) || p->vsize != sizeof(uint32_t)) {
            *(int32_t *)pReplyData = -EINVAL;
            break;
        }
        switch (*(uint32_t *)p->data) {
        case VISUALIZER_PARAM_CAPTURE_SIZE: {
            const uint32_t captureSize = *((uint32_t *)p->data + 1);
            if (captureSize > VISUALIZER_CAPTURE_SIZE_MAX) {
                android_errorWriteLog(0x534e4554, ""31781965"");
                *(int32_t *)pReplyData = -EINVAL;
                ALOGW(""set mCaptureSize = %u > %u"", captureSize, VISUALIZER_CAPTURE_SIZE_MAX);
            } else {
                pContext->mCaptureSize = captureSize;
                ALOGV(""set mCaptureSize = %u"", captureSize);
            }
            } break;
        case VISUALIZER_PARAM_SCALING_MODE:
            pContext->mScalingMode = *((uint32_t *)p->data + 1);
            ALOGV(""set mScalingMode = %"" PRIu32, pContext->mScalingMode);
            break;
        case VISUALIZER_PARAM_LATENCY: {
            uint32_t latency = *((uint32_t *)p->data + 1);
            if (latency > MAX_LATENCY_MS) {
                latency = MAX_LATENCY_MS; // clamp latency b/31781965
            }
            pContext->mLatency = latency;
            ALOGV(""set mLatency = %u"", latency);
            } break;
        case VISUALIZER_PARAM_MEASUREMENT_MODE:
            pContext->mMeasurementMode = *((uint32_t *)p->data + 1);
            ALOGV(""set mMeasurementMode = %"" PRIu32, pContext->mMeasurementMode);
            break;
        default:
            *(int32_t *)pReplyData = -EINVAL;
        }
        } break;
    case EFFECT_CMD_SET_DEVICE:
    case EFFECT_CMD_SET_VOLUME:
    case EFFECT_CMD_SET_AUDIO_MODE:
        break;


    case VISUALIZER_CMD_CAPTURE: {
        uint32_t captureSize = pContext->mCaptureSize;
        if (pReplyData == NULL || replySize == NULL || *replySize != captureSize) {
            ALOGV(""VISUALIZER_CMD_CAPTURE() error *replySize %"" PRIu32 "" captureSize %"" PRIu32,
                    *replySize, captureSize);
            return -EINVAL;
        }
        if (pContext->mState == VISUALIZER_STATE_ACTIVE) {
            const uint32_t deltaMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);

            // if audio framework has stopped playing audio although the effect is still
            // active we must clear the capture buffer to return silence
            if ((pContext->mLastCaptureIdx == pContext->mCaptureIdx) &&
                    (pContext->mBufferUpdateTime.tv_sec != 0) &&
                    (deltaMs > MAX_STALL_TIME_MS)) {
                    ALOGV(""capture going to idle"");
                    pContext->mBufferUpdateTime.tv_sec = 0;
                    memset(pReplyData, 0x80, captureSize);
            } else {
                int32_t latencyMs = pContext->mLatency;
                latencyMs -= deltaMs;
                if (latencyMs < 0) {
                    latencyMs = 0;
                }
                uint32_t deltaSmpl = captureSize
                        + pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;

                // large sample rate, latency, or capture size, could cause overflow.
                // do not offset more than the size of buffer.
                if (deltaSmpl > CAPTURE_BUF_SIZE) {
                    android_errorWriteLog(0x534e4554, ""31781965"");
                    deltaSmpl = CAPTURE_BUF_SIZE;
                }

                int32_t capturePoint = pContext->mCaptureIdx - deltaSmpl;
                // a negative capturePoint means we wrap the buffer.
                if (capturePoint < 0) {
                    uint32_t size = -capturePoint;
                    if (size > captureSize) {
                        size = captureSize;
                    }
                    memcpy(pReplyData,
                           pContext->mCaptureBuf + CAPTURE_BUF_SIZE + capturePoint,
                           size);
                    pReplyData = (char *)pReplyData + size;
                    captureSize -= size;
                    capturePoint = 0;
                }
                memcpy(pReplyData,
                       pContext->mCaptureBuf + capturePoint,
                       captureSize);
            }

            pContext->mLastCaptureIdx = pContext->mCaptureIdx;
        } else {
            memset(pReplyData, 0x80, captureSize);
        }

        } break;

    case VISUALIZER_CMD_MEASURE: {
        if (pReplyData == NULL || replySize == NULL ||
                *replySize < (sizeof(int32_t) * MEASUREMENT_COUNT)) {
            if (replySize == NULL) {
                ALOGV(""VISUALIZER_CMD_MEASURE() error replySize NULL"");
            } else {
                ALOGV(""VISUALIZER_CMD_MEASURE() error *replySize %"" PRIu32
                        "" < (sizeof(int32_t) * MEASUREMENT_COUNT) %"" PRIu32,
                        *replySize,
                        uint32_t(sizeof(int32_t)) * MEASUREMENT_COUNT);
            }
            android_errorWriteLog(0x534e4554, ""30229821"");
            return -EINVAL;
        }
        uint16_t peakU16 = 0;
        float sumRmsSquared = 0.0f;
        uint8_t nbValidMeasurements = 0;
        // reset measurements if last measurement was too long ago (which implies stored
        // measurements aren't relevant anymore and shouldn't bias the new one)
        const int32_t delayMs = Visualizer_getDeltaTimeMsFromUpdatedTime(pContext);
        if (delayMs > DISCARD_MEASUREMENTS_TIME_MS) {
            ALOGV(""Discarding measurements, last measurement is %"" PRId32 ""ms old"", delayMs);
            for (uint32_t i=0 ; i<pContext->mMeasurementWindowSizeInBuffers ; i++) {
                pContext->mPastMeasurements[i].mIsValid = false;
                pContext->mPastMeasurements[i].mPeakU16 = 0;
                pContext->mPastMeasurements[i].mRmsSquared = 0;
            }
            pContext->mMeasurementBufferIdx = 0;
        } else {
            // only use actual measurements, otherwise the first RMS measure happening before
            // MEASUREMENT_WINDOW_MAX_SIZE_IN_BUFFERS have been played will always be artificially
            // low
            for (uint32_t i=0 ; i < pContext->mMeasurementWindowSizeInBuffers ; i++) {
                if (pContext->mPastMeasurements[i].mIsValid) {
                    if (pContext->mPastMeasurements[i].mPeakU16 > peakU16) {
                        peakU16 = pContext->mPastMeasurements[i].mPeakU16;
                    }
                    sumRmsSquared += pContext->mPastMeasurements[i].mRmsSquared;
                    nbValidMeasurements++;
                }
            }
        }
        float rms = nbValidMeasurements == 0 ? 0.0f : sqrtf(sumRmsSquared / nbValidMeasurements);
        int32_t* pIntReplyData = (int32_t*)pReplyData;
        // convert from I16 sample values to mB and write results
        if (rms < 0.000016f) {
            pIntReplyData[MEASUREMENT_IDX_RMS] = -9600; //-96dB
        } else {
            pIntReplyData[MEASUREMENT_IDX_RMS] = (int32_t) (2000 * log10(rms / 32767.0f));
        }
        if (peakU16 == 0) {
            pIntReplyData[MEASUREMENT_IDX_PEAK] = -9600; //-96dB
        } else {
            pIntReplyData[MEASUREMENT_IDX_PEAK] = (int32_t) (2000 * log10(peakU16 / 32767.0f));
        }
        ALOGV(""VISUALIZER_CMD_MEASURE peak=%"" PRIu16 "" (%"" PRId32 ""mB), rms=%.1f (%"" PRId32 ""mB)"",
                peakU16, pIntReplyData[MEASUREMENT_IDX_PEAK],
                rms, pIntReplyData[MEASUREMENT_IDX_RMS]);
        }
        break;

    default:
        ALOGW(""Visualizer_command invalid command %"" PRIu32, cmdCode);
        return -EINVAL;
    }

    return 0;
}","int Visualizer_command(effect_handle_t VAR_0, uint32_t VAR_1, uint32_t VAR_2,
        void *VAR_3, uint32_t *VAR_4, void *VAR_5) {

    VisualizerContext * VAR_6 = (VisualizerContext *)VAR_0;
    int VAR_7;

    if (VAR_6 == NULL || VAR_6->mState == VAR_8) {
        return -VAR_9;
    }

/* COMMENT_0 */

    switch (VAR_1) {
    case VAR_10:
        if (VAR_5 == NULL || VAR_4 == NULL || *VAR_4 != sizeof(int)) {
            return -VAR_9;
        }
        *(int *) VAR_5 = Visualizer_init(VAR_6);
        break;
    case VAR_11:
        if (VAR_3 == NULL || VAR_2 != sizeof(VAR_12)
                || VAR_5 == NULL || VAR_4 == NULL || *VAR_4 != sizeof(int)) {
            return -VAR_9;
        }
        *(int *) VAR_5 = Visualizer_setConfig(VAR_6,
                (effect_config_t *) VAR_3);
        break;
    case VAR_13:
        if (VAR_5 == NULL || VAR_4 == NULL ||
            *VAR_4 != sizeof(effect_config_t)) {
            return -VAR_9;
        }
        Visualizer_getConfig(VAR_6, (effect_config_t *)VAR_5);
        break;
    case VAR_14:
        Visualizer_reset(VAR_6);
        break;
    case VAR_15:
        if (VAR_5 == NULL || VAR_4 == NULL || *VAR_4 != sizeof(int)) {
            return -VAR_9;
        }
        if (VAR_6->mState != VAR_16) {
            return -VAR_17;
        }
        VAR_6->mState = VAR_18;
        ALOGV(""EFFECT_CMD_ENABLE() OK"");
        *(int *)VAR_5 = 0;
        break;
    case VAR_19:
        if (VAR_5 == NULL || VAR_4 == NULL || *VAR_4 != sizeof(int)) {
            return -VAR_9;
        }
        if (VAR_6->mState != VAR_18) {
            return -VAR_17;
        }
        VAR_6->mState = VAR_16;
        ALOGV(""EFFECT_CMD_DISABLE() OK"");
        *(int *)VAR_5 = 0;
        break;
    case VAR_20: {
        if (VAR_3 == NULL ||
            VAR_2 != (int)(sizeof(VAR_21) + sizeof(uint32_t)) ||
            VAR_5 == NULL || VAR_4 == NULL ||
            *VAR_4 < (int)(sizeof(VAR_21) + sizeof(uint32_t) + sizeof(uint32_t))) {
            return -VAR_9;
        }
        memcpy(VAR_5, VAR_3, sizeof(VAR_21) + sizeof(uint32_t));
        effect_param_t *VAR_22 = (effect_param_t *)VAR_5;
        VAR_22->status = 0;
        *VAR_4 = sizeof(effect_param_t) + sizeof(uint32_t);
        if (VAR_22->psize != sizeof(uint32_t)) {
            VAR_22->status = -VAR_9;
            break;
        }
        switch (*(uint32_t *)VAR_22->data) {
        case VAR_23:
            ALOGV(""get mCaptureSize = %"" VAR_24, VAR_6->mCaptureSize);
            *((uint32_t *)VAR_22->data + 1) = VAR_6->mCaptureSize;
            VAR_22->vsize = sizeof(uint32_t);
            *VAR_4 += sizeof(uint32_t);
            break;
        case VAR_25:
            ALOGV(""get mScalingMode = %"" VAR_24, VAR_6->mScalingMode);
            *((uint32_t *)VAR_22->data + 1) = VAR_6->mScalingMode;
            VAR_22->vsize = sizeof(uint32_t);
            *VAR_4 += sizeof(uint32_t);
            break;
        case VAR_26:
            ALOGV(""get mMeasurementMode = %"" VAR_24, VAR_6->mMeasurementMode);
            *((uint32_t *)VAR_22->data + 1) = VAR_6->mMeasurementMode;
            VAR_22->vsize = sizeof(uint32_t);
            *VAR_4 += sizeof(uint32_t);
            break;
        default:
            VAR_22->status = -VAR_9;
        }
        } break;
    case VAR_27: {
        if (VAR_3 == NULL ||
            VAR_2 != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||
            VAR_5 == NULL || VAR_4 == NULL || *VAR_4 != sizeof(int32_t)) {
            return -VAR_9;
        }
        *(int32_t *)VAR_5 = 0;
        effect_param_t *VAR_22 = (effect_param_t *)VAR_3;
        if (VAR_22->psize != sizeof(uint32_t) || VAR_22->vsize != sizeof(uint32_t)) {
            *(int32_t *)VAR_5 = -VAR_9;
            break;
        }
        switch (*(uint32_t *)VAR_22->data) {
        case VAR_23: {
            const uint32_t VAR_28 = *((uint32_t *)VAR_22->data + 1);
            if (VAR_28 > VAR_29) {
                android_errorWriteLog(0x534e4554, ""31781965"");
                *(int32_t *)VAR_5 = -VAR_9;
                ALOGW(""set mCaptureSize = %u > %u"", VAR_28, VAR_29);
            } else {
                VAR_6->mCaptureSize = VAR_28;
                ALOGV(""set mCaptureSize = %u"", VAR_28);
            }
            } break;
        case VAR_25:
            VAR_6->mScalingMode = *((uint32_t *)VAR_22->data + 1);
            ALOGV(""set mScalingMode = %"" VAR_24, VAR_6->mScalingMode);
            break;
        case VAR_30: {
            uint32_t VAR_31 = *((uint32_t *)VAR_22->data + 1);
            if (VAR_31 > VAR_32) {
                VAR_31 = VAR_32; /* COMMENT_1 */
            }
            VAR_6->mLatency = VAR_31;
            ALOGV(""set mLatency = %u"", VAR_31);
            } break;
        case VAR_26:
            VAR_6->mMeasurementMode = *((uint32_t *)VAR_22->data + 1);
            ALOGV(""set mMeasurementMode = %"" VAR_24, VAR_6->mMeasurementMode);
            break;
        default:
            *(int32_t *)VAR_5 = -VAR_9;
        }
        } break;
    case VAR_33:
    case VAR_34:
    case VAR_35:
        break;


    case VAR_36: {
        uint32_t VAR_28 = VAR_6->mCaptureSize;
        if (VAR_5 == NULL || VAR_4 == NULL || *VAR_4 != VAR_28) {
            ALOGV(""VISUALIZER_CMD_CAPTURE() error *replySize %"" VAR_24 "" captureSize %"" VAR_24,
                    *VAR_4, VAR_28);
            return -VAR_9;
        }
        if (VAR_6->mState == VAR_18) {
            const uint32_t VAR_37 = Visualizer_getDeltaTimeMsFromUpdatedTime(VAR_6);

            /* COMMENT_2 */
            /* COMMENT_3 */
            if ((VAR_6->mLastCaptureIdx == VAR_6->mCaptureIdx) &&
                    (VAR_6->mBufferUpdateTime.tv_sec != 0) &&
                    (VAR_37 > VAR_38)) {
                    ALOGV(""capture going to idle"");
                    VAR_6->mBufferUpdateTime.tv_sec = 0;
                    memset(VAR_5, 0x80, VAR_28);
            } else {
                int32_t VAR_39 = VAR_6->mLatency;
                VAR_39 -= VAR_37;
                if (VAR_39 < 0) {
                    VAR_39 = 0;
                }
                uint32_t VAR_40 = VAR_28
                        + VAR_6->mConfig.inputCfg.samplingRate * VAR_39 / 1000;

                /* COMMENT_4 */
                /* COMMENT_5 */
                if (VAR_40 > VAR_41) {
                    android_errorWriteLog(0x534e4554, ""31781965"");
                    VAR_40 = VAR_41;
                }

                int32_t VAR_42 = VAR_6->mCaptureIdx - VAR_40;
                /* COMMENT_6 */
                if (VAR_42 < 0) {
                    uint32_t VAR_43 = -VAR_42;
                    if (VAR_43 > VAR_28) {
                        VAR_43 = VAR_28;
                    }
                    memcpy(VAR_5,
                           VAR_6->mCaptureBuf + VAR_41 + VAR_42,
                           VAR_43);
                    VAR_5 = (char *)VAR_5 + VAR_43;
                    VAR_28 -= VAR_43;
                    VAR_42 = 0;
                }
                memcpy(VAR_5,
                       VAR_6->mCaptureBuf + VAR_42,
                       VAR_28);
            }

            VAR_6->mLastCaptureIdx = VAR_6->mCaptureIdx;
        } else {
            memset(VAR_5, 0x80, VAR_28);
        }

        } break;

    case VAR_44: {
        if (VAR_5 == NULL || VAR_4 == NULL ||
                *VAR_4 < (sizeof(int32_t) * VAR_45)) {
            if (VAR_4 == NULL) {
                ALOGV(""VISUALIZER_CMD_MEASURE() error replySize NULL"");
            } else {
                ALOGV(""VISUALIZER_CMD_MEASURE() error *replySize %"" VAR_24
                        "" < (sizeof(int32_t) * MEASUREMENT_COUNT) %"" VAR_24,
                        *VAR_4,
                        uint32_t(sizeof(int32_t)) * VAR_45);
            }
            android_errorWriteLog(0x534e4554, ""30229821"");
            return -VAR_9;
        }
        uint16_t VAR_46 = 0;
        float VAR_47 = 0.0f;
        uint8_t VAR_48 = 0;
        /* COMMENT_7 */
        /* COMMENT_8 */
        const int32_t VAR_49 = Visualizer_getDeltaTimeMsFromUpdatedTime(VAR_6);
        if (VAR_49 > VAR_50) {
            ALOGV(""Discarding measurements, last measurement is %"" VAR_51 ""ms old"", VAR_49);
            for (uint32_t VAR_52=0 ; VAR_52<VAR_6->mMeasurementWindowSizeInBuffers ; VAR_52++) {
                VAR_6->mPastMeasurements[VAR_52].mIsValid = false;
                VAR_6->mPastMeasurements[VAR_52].mPeakU16 = 0;
                VAR_6->mPastMeasurements[VAR_52].mRmsSquared = 0;
            }
            VAR_6->mMeasurementBufferIdx = 0;
        } else {
            /* COMMENT_9 */
            /* COMMENT_10 */
            /* COMMENT_11 */
            for (uint32_t VAR_52=0 ; VAR_52 < VAR_6->mMeasurementWindowSizeInBuffers ; VAR_52++) {
                if (VAR_6->mPastMeasurements[VAR_52].mIsValid) {
                    if (VAR_6->mPastMeasurements[VAR_52].mPeakU16 > VAR_46) {
                        VAR_46 = VAR_6->mPastMeasurements[VAR_52].mPeakU16;
                    }
                    VAR_47 += VAR_6->mPastMeasurements[VAR_52].mRmsSquared;
                    VAR_48++;
                }
            }
        }
        float VAR_53 = VAR_48 == 0 ? 0.0f : sqrtf(VAR_47 / VAR_48);
        int32_t* VAR_54 = (int32_t*)VAR_5;
        /* COMMENT_12 */
        if (VAR_53 < 0.000016f) {
            VAR_54[VAR_55] = -9600; /* COMMENT_13 */
        } else {
            VAR_54[VAR_55] = (int32_t) (2000 * log10(VAR_53 / 32767.0f));
        }
        if (VAR_46 == 0) {
            VAR_54[VAR_56] = -9600; /* COMMENT_13 */
        } else {
            VAR_54[VAR_56] = (int32_t) (2000 * log10(VAR_46 / 32767.0f));
        }
        ALOGV(""VISUALIZER_CMD_MEASURE peak=%"" VAR_57 "" (%"" VAR_51 ""mB), rms=%.1f (%"" VAR_51 ""mB)"",
                VAR_46, VAR_54[VAR_56],
                VAR_53, VAR_54[VAR_55]);
        }
        break;

    default:
        ALOGW(""Visualizer_command invalid command %"" VAR_24, VAR_1);
        return -VAR_9;
    }

    return 0;
}",android/557bd7bfe6c4895faee09e46fc9b5304a956c8b7/EffectVisualizer.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -108,18 +108,29 @@
             break;
         }
         switch (*(uint32_t *)p->data) {
-        case VISUALIZER_PARAM_CAPTURE_SIZE:
-            pContext->mCaptureSize = *((uint32_t *)p->data + 1);
-            ALOGV(""set mCaptureSize = %"" PRIu32, pContext->mCaptureSize);
-            break;
+        case VISUALIZER_PARAM_CAPTURE_SIZE: {
+            const uint32_t captureSize = *((uint32_t *)p->data + 1);
+            if (captureSize > VISUALIZER_CAPTURE_SIZE_MAX) {
+                android_errorWriteLog(0x534e4554, ""31781965"");
+                *(int32_t *)pReplyData = -EINVAL;
+                ALOGW(""set mCaptureSize = %u > %u"", captureSize, VISUALIZER_CAPTURE_SIZE_MAX);
+            } else {
+                pContext->mCaptureSize = captureSize;
+                ALOGV(""set mCaptureSize = %u"", captureSize);
+            }
+            } break;
         case VISUALIZER_PARAM_SCALING_MODE:
             pContext->mScalingMode = *((uint32_t *)p->data + 1);
             ALOGV(""set mScalingMode = %"" PRIu32, pContext->mScalingMode);
             break;
-        case VISUALIZER_PARAM_LATENCY:
-            pContext->mLatency = *((uint32_t *)p->data + 1);
-            ALOGV(""set mLatency = %"" PRIu32, pContext->mLatency);
-            break;
+        case VISUALIZER_PARAM_LATENCY: {
+            uint32_t latency = *((uint32_t *)p->data + 1);
+            if (latency > MAX_LATENCY_MS) {
+                latency = MAX_LATENCY_MS; // clamp latency b/31781965
+            }
+            pContext->mLatency = latency;
+            ALOGV(""set mLatency = %u"", latency);
+            } break;
         case VISUALIZER_PARAM_MEASUREMENT_MODE:
             pContext->mMeasurementMode = *((uint32_t *)p->data + 1);
             ALOGV(""set mMeasurementMode = %"" PRIu32, pContext->mMeasurementMode);
@@ -158,10 +169,18 @@
                 if (latencyMs < 0) {
                     latencyMs = 0;
                 }
-                const uint32_t deltaSmpl =
-                    pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;
-                int32_t capturePoint = pContext->mCaptureIdx - captureSize - deltaSmpl;
-
+                uint32_t deltaSmpl = captureSize
+                        + pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;
+
+                // large sample rate, latency, or capture size, could cause overflow.
+                // do not offset more than the size of buffer.
+                if (deltaSmpl > CAPTURE_BUF_SIZE) {
+                    android_errorWriteLog(0x534e4554, ""31781965"");
+                    deltaSmpl = CAPTURE_BUF_SIZE;
+                }
+
+                int32_t capturePoint = pContext->mCaptureIdx - deltaSmpl;
+                // a negative capturePoint means we wrap the buffer.
                 if (capturePoint < 0) {
                     uint32_t size = -capturePoint;
                     if (size > captureSize) {","{'deleted_lines': ['        case VISUALIZER_PARAM_CAPTURE_SIZE:', '            pContext->mCaptureSize = *((uint32_t *)p->data + 1);', '            ALOGV(""set mCaptureSize = %"" PRIu32, pContext->mCaptureSize);', '            break;', '        case VISUALIZER_PARAM_LATENCY:', '            pContext->mLatency = *((uint32_t *)p->data + 1);', '            ALOGV(""set mLatency = %"" PRIu32, pContext->mLatency);', '            break;', '                const uint32_t deltaSmpl =', '                    pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;', '                int32_t capturePoint = pContext->mCaptureIdx - captureSize - deltaSmpl;', ''], 'added_lines': ['        case VISUALIZER_PARAM_CAPTURE_SIZE: {', '            const uint32_t captureSize = *((uint32_t *)p->data + 1);', '            if (captureSize > VISUALIZER_CAPTURE_SIZE_MAX) {', '                android_errorWriteLog(0x534e4554, ""31781965"");', '                *(int32_t *)pReplyData = -EINVAL;', '                ALOGW(""set mCaptureSize = %u > %u"", captureSize, VISUALIZER_CAPTURE_SIZE_MAX);', '            } else {', '                pContext->mCaptureSize = captureSize;', '                ALOGV(""set mCaptureSize = %u"", captureSize);', '            }', '            } break;', '        case VISUALIZER_PARAM_LATENCY: {', '            uint32_t latency = *((uint32_t *)p->data + 1);', '            if (latency > MAX_LATENCY_MS) {', '                latency = MAX_LATENCY_MS; // clamp latency b/31781965', '            }', '            pContext->mLatency = latency;', '            ALOGV(""set mLatency = %u"", latency);', '            } break;', '                uint32_t deltaSmpl = captureSize', '                        + pContext->mConfig.inputCfg.samplingRate * latencyMs / 1000;', '', '                // large sample rate, latency, or capture size, could cause overflow.', '                // do not offset more than the size of buffer.', '                if (deltaSmpl > CAPTURE_BUF_SIZE) {', '                    android_errorWriteLog(0x534e4554, ""31781965"");', '                    deltaSmpl = CAPTURE_BUF_SIZE;', '                }', '', '                int32_t capturePoint = pContext->mCaptureIdx - deltaSmpl;', '                // a negative capturePoint means we wrap the buffer.']}",True,"An information disclosure vulnerability in visualizer/EffectVisualizer.cpp in libeffects in Mediaserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1. Android ID: A-31781965.",5.5,MEDIUM,1,test,,5
CVE-2015-3194,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,openssl,"
Add PSS parameter check.

Avoid seg fault by checking mgf1 parameter is not NULL. This can be
triggered during certificate verification so could be a DoS attack
against a client or a server enabling client authentication.

Thanks to Loic Jonas Etienne (Qnective AG) for discovering this bug.

CVE-2015-3194

Reviewed-by: Matt Caswell <matt@openssl.org>
",d8541d7e9e63bf5f343af24644046c8d96498c17,https://git.openssl.org/?p=openssl.git;a=commit;h=d8541d7e9e63bf5f343af24644046c8d96498c17,crypto/rsa/rsa_ameth.c,rsa_pss_decode,"static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,
X509_ALGOR **pmaskHash)
{
const unsigned char *p;
int plen;
RSA_PSS_PARAMS *pss;
*pmaskHash = NULL;
if (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)
return NULL;
p = alg->parameter->value.sequence->data;
plen = alg->parameter->value.sequence->length;
pss = d2i_RSA_PSS_PARAMS(NULL, &p, plen);
if (!pss)
return NULL;
if (pss->maskGenAlgorithm) {
ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;
if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_mgf1
&& param->type == V_ASN1_SEQUENCE) {
p = param->value.sequence->data;
plen = param->value.sequence->length;
*pmaskHash = d2i_X509_ALGOR(NULL, &p, plen);
}
}
return pss;
}","static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *VAR_0,
X509_ALGOR **VAR_1)
{
const unsigned char *VAR_2;
int VAR_3;
RSA_PSS_PARAMS *VAR_4;
*VAR_1 = NULL;
if (!VAR_0->parameter || VAR_0->parameter->type != VAR_5)
return NULL;
VAR_2 = VAR_0->parameter->value.sequence->data;
VAR_3 = VAR_0->parameter->value.sequence->length;
VAR_4 = d2i_RSA_PSS_PARAMS(NULL, &VAR_2, VAR_3);
if (!VAR_4)
return NULL;
if (VAR_4->maskGenAlgorithm) {
ASN1_TYPE *VAR_6 = VAR_4->maskGenAlgorithm->parameter;
if (OBJ_obj2nid(VAR_4->maskGenAlgorithm->algorithm) == VAR_7
&& VAR_6->type == VAR_5) {
VAR_2 = VAR_6->value.sequence->data;
VAR_3 = VAR_6->value.sequence->length;
*VAR_1 = d2i_X509_ALGOR(NULL, &VAR_2, VAR_3);
}
}
return VAR_4;
}",openssl/d8541d7e9e63bf5f343af24644046c8d96498c17/rsa_ameth.c/vul/before/0.json,"static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,
                                      X509_ALGOR **pmaskHash)
{
    const unsigned char *p;
    int plen;
    RSA_PSS_PARAMS *pss;

    *pmaskHash = NULL;

    if (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)
        return NULL;
    p = alg->parameter->value.sequence->data;
    plen = alg->parameter->value.sequence->length;
    pss = d2i_RSA_PSS_PARAMS(NULL, &p, plen);

    if (!pss)
        return NULL;

    if (pss->maskGenAlgorithm) {
        ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;
        if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_mgf1
            && param && param->type == V_ASN1_SEQUENCE) {
            p = param->value.sequence->data;
            plen = param->value.sequence->length;
            *pmaskHash = d2i_X509_ALGOR(NULL, &p, plen);
        }
    }

    return pss;
}","static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *VAR_0,
                                      X509_ALGOR **VAR_1)
{
    const unsigned char *VAR_2;
    int VAR_3;
    RSA_PSS_PARAMS *VAR_4;

    *VAR_1 = NULL;

    if (!VAR_0->parameter || VAR_0->parameter->type != VAR_5)
        return NULL;
    VAR_2 = VAR_0->parameter->value.sequence->data;
    VAR_3 = VAR_0->parameter->value.sequence->length;
    VAR_4 = d2i_RSA_PSS_PARAMS(NULL, &VAR_2, VAR_3);

    if (!VAR_4)
        return NULL;

    if (VAR_4->maskGenAlgorithm) {
        ASN1_TYPE *VAR_6 = VAR_4->maskGenAlgorithm->parameter;
        if (OBJ_obj2nid(VAR_4->maskGenAlgorithm->algorithm) == VAR_7
            && VAR_6 && VAR_6->type == VAR_5) {
            VAR_2 = VAR_6->value.sequence->data;
            VAR_3 = VAR_6->value.sequence->length;
            *VAR_1 = d2i_X509_ALGOR(NULL, &VAR_2, VAR_3);
        }
    }

    return VAR_4;
}",openssl/d8541d7e9e63bf5f343af24644046c8d96498c17/rsa_ameth.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -19,7 +19,7 @@
     if (pss->maskGenAlgorithm) {
         ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;
         if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_mgf1
-            && param->type == V_ASN1_SEQUENCE) {
+            && param && param->type == V_ASN1_SEQUENCE) {
             p = param->value.sequence->data;
             plen = param->value.sequence->length;
             *pmaskHash = d2i_X509_ALGOR(NULL, &p, plen);","{'deleted_lines': ['            && param->type == V_ASN1_SEQUENCE) {'], 'added_lines': ['            && param && param->type == V_ASN1_SEQUENCE) {']}",True,crypto/rsa/rsa_ameth.c in OpenSSL 1.0.1 before 1.0.1q and 1.0.2 before 1.0.2e allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an RSA PSS ASN.1 signature that lacks a mask generation function parameter.,7.5,HIGH,2,test,,5
CVE-2015-3194,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,openssl,"
Add PSS parameter check.

Avoid seg fault by checking mgf1 parameter is not NULL. This can be
triggered during certificate verification so could be a DoS attack
against a client or a server enabling client authentication.

Thanks to Loic Jonas Etienne (Qnective AG) for discovering this bug.

CVE-2015-3194

Reviewed-by: Richard Levitte <levitte@openssl.org>
",c394a488942387246653833359a5c94b5832674e,https://git.openssl.org/?p=openssl.git;a=commit;h=c394a488942387246653833359a5c94b5832674e,crypto/rsa/rsa_ameth.c,rsa_mgf1_decode,"static X509_ALGOR *rsa_mgf1_decode(X509_ALGOR *alg)
{
const unsigned char *p;
int plen;
if (alg == NULL)
return NULL;
if (OBJ_obj2nid(alg->algorithm) != NID_mgf1)
return NULL;
if (alg->parameter->type != V_ASN1_SEQUENCE)
return NULL;
p = alg->parameter->value.sequence->data;
plen = alg->parameter->value.sequence->length;
return d2i_X509_ALGOR(NULL, &p, plen);
}","static X509_ALGOR *rsa_mgf1_decode(X509_ALGOR *VAR_0)
{
const unsigned char *VAR_1;
int VAR_2;
if (VAR_0 == NULL)
return NULL;
if (OBJ_obj2nid(VAR_0->algorithm) != VAR_3)
return NULL;
if (VAR_0->parameter->type != VAR_4)
return NULL;
VAR_1 = VAR_0->parameter->value.sequence->data;
VAR_2 = VAR_0->parameter->value.sequence->length;
return d2i_X509_ALGOR(NULL, &VAR_1, VAR_2);
}",openssl/c394a488942387246653833359a5c94b5832674e/rsa_ameth.c/vul/before/0.json,"static X509_ALGOR *rsa_mgf1_decode(X509_ALGOR *alg)
{
    const unsigned char *p;
    int plen;
    if (alg == NULL || alg->parameter == NULL)
        return NULL;
    if (OBJ_obj2nid(alg->algorithm) != NID_mgf1)
        return NULL;
    if (alg->parameter->type != V_ASN1_SEQUENCE)
        return NULL;

    p = alg->parameter->value.sequence->data;
    plen = alg->parameter->value.sequence->length;
    return d2i_X509_ALGOR(NULL, &p, plen);
}","static X509_ALGOR *rsa_mgf1_decode(X509_ALGOR *VAR_0)
{
    const unsigned char *VAR_1;
    int VAR_2;
    if (VAR_0 == NULL || VAR_0->parameter == NULL)
        return NULL;
    if (OBJ_obj2nid(VAR_0->algorithm) != VAR_3)
        return NULL;
    if (VAR_0->parameter->type != VAR_4)
        return NULL;

    VAR_1 = VAR_0->parameter->value.sequence->data;
    VAR_2 = VAR_0->parameter->value.sequence->length;
    return d2i_X509_ALGOR(NULL, &VAR_1, VAR_2);
}",openssl/c394a488942387246653833359a5c94b5832674e/rsa_ameth.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 {
     const unsigned char *p;
     int plen;
-    if (alg == NULL)
+    if (alg == NULL || alg->parameter == NULL)
         return NULL;
     if (OBJ_obj2nid(alg->algorithm) != NID_mgf1)
         return NULL;","{'deleted_lines': ['    if (alg == NULL)'], 'added_lines': ['    if (alg == NULL || alg->parameter == NULL)']}",True,crypto/rsa/rsa_ameth.c in OpenSSL 1.0.1 before 1.0.1q and 1.0.2 before 1.0.2e allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an RSA PSS ASN.1 signature that lacks a mask generation function parameter.,7.5,HIGH,2,test,,5
CVE-2015-8662,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,ffmpeg,"
avcodec/jpeg2000dwt: Check ndeclevels before calling dwt_decode*()

Fixes out of array access
Fixes: 01859c9a9ac6cd60a008274123275574/asan_heap-oob_1dff571_8250_50d3d1611e294c3519fd1fa82198b69b.avi

Found-by: Mateusz ""j00ru"" Jurczyk and Gynvael Coldwind
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>
",75422280fbcdfbe9dc56bde5525b4d8b280f1bc5,http://git.videolan.org/?p=ffmpeg.git;a=commit;h=75422280fbcdfbe9dc56bde5525b4d8b280f1bc5,libavcodec/jpeg2000dwt.c,ff_dwt_decode,"int ff_dwt_decode(DWTContext *s, void *t)
{
switch (s->type) {
case FF_DWT97:
dwt_decode97_float(s, t);
break;
case FF_DWT97_INT:
dwt_decode97_int(s, t);
break;
case FF_DWT53:
dwt_decode53(s, t);
break;
default:
return -1;
}
return 0;
}","int ff_dwt_decode(DWTContext *VAR_0, void *VAR_1)
{
switch (VAR_0->type) {
case VAR_2:
dwt_decode97_float(VAR_0, VAR_1);
break;
case VAR_3:
dwt_decode97_int(VAR_0, VAR_1);
break;
case VAR_4:
dwt_decode53(VAR_0, VAR_1);
break;
default:
return -1;
}
return 0;
}",ffmpeg/75422280fbcdfbe9dc56bde5525b4d8b280f1bc5/jpeg2000dwt.c/vul/before/0.json,"int ff_dwt_decode(DWTContext *s, void *t)
{
    if (s->ndeclevels == 0)
        return 0;

    switch (s->type) {
    case FF_DWT97:
        dwt_decode97_float(s, t);
        break;
    case FF_DWT97_INT:
        dwt_decode97_int(s, t);
        break;
    case FF_DWT53:
        dwt_decode53(s, t);
        break;
    default:
        return -1;
    }
    return 0;
}","int ff_dwt_decode(DWTContext *VAR_0, void *VAR_1)
{
    if (VAR_0->ndeclevels == 0)
        return 0;

    switch (VAR_0->type) {
    case VAR_2:
        dwt_decode97_float(VAR_0, VAR_1);
        break;
    case VAR_3:
        dwt_decode97_int(VAR_0, VAR_1);
        break;
    case VAR_4:
        dwt_decode53(VAR_0, VAR_1);
        break;
    default:
        return -1;
    }
    return 0;
}",ffmpeg/75422280fbcdfbe9dc56bde5525b4d8b280f1bc5/jpeg2000dwt.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,8 @@
 int ff_dwt_decode(DWTContext *s, void *t)
 {
+    if (s->ndeclevels == 0)
+        return 0;
+
     switch (s->type) {
     case FF_DWT97:
         dwt_decode97_float(s, t);","{'deleted_lines': [], 'added_lines': ['    if (s->ndeclevels == 0)', '        return 0;', '']}",True,"The ff_dwt_decode function in libavcodec/jpeg2000dwt.c in FFmpeg before 2.8.4 does not validate the number of decomposition levels before proceeding with Discrete Wavelet Transform decoding, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG 2000 data.",7.3,HIGH,2,test,,5
CVE-2016-1612,['CWE-20'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,chromium,"[IC] Fix ""compatible receiver"" checks hidden behind interceptors

BUG=chromium:497632
LOG=y

Review URL: https://codereview.chromium.org/1531583005

Cr-Commit-Position: refs/heads/master@{#32945}
",cfbd16172fa165cc33ce0e2e72f74e5561168a61,https://chromium.googlesource.com/v8/v8/+/cfbd16172fa165cc33ce0e2e72f74e5561168a61,src/ic/ic.cc,LoadIC::UpdateCaches,"void LoadIC::UpdateCaches(LookupIterator* lookup) {
if (state() == UNINITIALIZED) {
ConfigureVectorState(PREMONOMORPHIC);
TRACE_IC(""LoadIC"", lookup->name());
return;
}
Handle<Code> code;
if (lookup->state() == LookupIterator::JSPROXY ||
lookup->state() == LookupIterator::ACCESS_CHECK) {
code = slow_stub();
} else if (!lookup->IsFound()) {
if (kind() == Code::LOAD_IC && !is_strong(language_mode())) {
code = NamedLoadHandlerCompiler::ComputeLoadNonexistent(lookup->name(),
receiver_map());
if (code.is_null()) code = slow_stub();
} else {
code = slow_stub();
}
} else {
if (lookup->state() == LookupIterator::ACCESSOR) {
Handle<Object> accessors = lookup->GetAccessors();
Handle<Map> map = receiver_map();
if (accessors->IsExecutableAccessorInfo()) {
Handle<ExecutableAccessorInfo> info =
Handle<ExecutableAccessorInfo>::cast(accessors);
if ((v8::ToCData<Address>(info->getter()) != 0) &&
!ExecutableAccessorInfo::IsCompatibleReceiverMap(isolate(), info,
map)) {
TRACE_GENERIC_IC(isolate(), ""LoadIC"", ""incompatible receiver type"");
code = slow_stub();
}
} else if (accessors->IsAccessorPair()) {
Handle<Object> getter(Handle<AccessorPair>::cast(accessors)->getter(),
isolate());
Handle<JSObject> holder = lookup->GetHolder<JSObject>();
Handle<Object> receiver = lookup->GetReceiver();
if (getter->IsJSFunction() && holder->HasFastProperties()) {
Handle<JSFunction> function = Handle<JSFunction>::cast(getter);
if (receiver->IsJSObject() || function->shared()->IsBuiltin() ||
!is_sloppy(function->shared()->language_mode())) {
CallOptimization call_optimization(function);
if (call_optimization.is_simple_api_call() &&
!call_optimization.IsCompatibleReceiver(receiver, holder)) {
TRACE_GENERIC_IC(isolate(), ""LoadIC"",
""incompatible receiver type"");
code = slow_stub();
}
}
}
}
}
if (code.is_null()) code = ComputeHandler(lookup);
}
PatchCache(lookup->name(), code);
TRACE_IC(""LoadIC"", lookup->name());
}","void LoadIC::UpdateCaches(LookupIterator* VAR_0) {
if (state() == VAR_1) {
ConfigureVectorState(VAR_2);
TRACE_IC(""LoadIC"", VAR_0->name());
return;
}
Handle<Code> VAR_3;
if (VAR_0->state() == LookupIterator::JSPROXY ||
VAR_0->state() == LookupIterator::ACCESS_CHECK) {
VAR_3 = slow_stub();
} else if (!VAR_0->IsFound()) {
if (kind() == Code::LOAD_IC && !is_strong(language_mode())) {
VAR_3 = NamedLoadHandlerCompiler::ComputeLoadNonexistent(VAR_0->name(),
receiver_map());
if (VAR_3.is_null()) VAR_3 = slow_stub();
} else {
VAR_3 = slow_stub();
}
} else {
if (VAR_0->state() == LookupIterator::ACCESSOR) {
Handle<Object> VAR_4 = VAR_0->GetAccessors();
Handle<Map> VAR_5 = receiver_map();
if (VAR_4->IsExecutableAccessorInfo()) {
Handle<ExecutableAccessorInfo> VAR_6 =
Handle<ExecutableAccessorInfo>::cast(VAR_4);
if ((v8::VAR_7<Address>(VAR_6->getter()) != 0) &&
!ExecutableAccessorInfo::IsCompatibleReceiverMap(isolate(), VAR_6,
VAR_5)) {
TRACE_GENERIC_IC(isolate(), ""LoadIC"", ""incompatible receiver type"");
VAR_3 = slow_stub();
}
} else if (VAR_4->IsAccessorPair()) {
Handle<Object> getter(Handle<AccessorPair>::cast(accessors)->getter(),
isolate());
Handle<JSObject> VAR_8 = VAR_0->GetHolder<JSObject>();
Handle<Object> VAR_9 = VAR_0->GetReceiver();
if (getter->IsJSFunction() && VAR_8->HasFastProperties()) {
Handle<JSFunction> VAR_10 = Handle<JSFunction>::cast(getter);
if (VAR_9->IsJSObject() || VAR_10->shared()->IsBuiltin() ||
!is_sloppy(VAR_10->shared()->language_mode())) {
CallOptimization call_optimization(function);
if (VAR_11.is_simple_api_call() &&
!VAR_11.IsCompatibleReceiver(VAR_9, VAR_8)) {
TRACE_GENERIC_IC(isolate(), ""LoadIC"",
""incompatible receiver type"");
VAR_3 = slow_stub();
}
}
}
}
}
if (VAR_3.is_null()) VAR_3 = ComputeHandler(VAR_0);
}
PatchCache(VAR_0->name(), VAR_3);
TRACE_IC(""LoadIC"", VAR_0->name());
}",chromium/cfbd16172fa165cc33ce0e2e72f74e5561168a61/ic.cc/vul/before/0.json,"void LoadIC::UpdateCaches(LookupIterator* lookup) {
  if (state() == UNINITIALIZED) {
    // This is the first time we execute this inline cache. Set the target to
    // the pre monomorphic stub to delay setting the monomorphic state.
    ConfigureVectorState(PREMONOMORPHIC);
    TRACE_IC(""LoadIC"", lookup->name());
    return;
  }

  Handle<Code> code;
  if (lookup->state() == LookupIterator::JSPROXY ||
      lookup->state() == LookupIterator::ACCESS_CHECK) {
    code = slow_stub();
  } else if (!lookup->IsFound()) {
    if (kind() == Code::LOAD_IC && !is_strong(language_mode())) {
      code = NamedLoadHandlerCompiler::ComputeLoadNonexistent(lookup->name(),
                                                              receiver_map());
      // TODO(jkummerow/verwaest): Introduce a builtin that handles this case.
      if (code.is_null()) code = slow_stub();
    } else {
      code = slow_stub();
    }
  } else {
    if (lookup->state() == LookupIterator::ACCESSOR) {
      if (!IsCompatibleReceiver(lookup, receiver_map())) {
        TRACE_GENERIC_IC(isolate(), ""LoadIC"", ""incompatible receiver type"");
        code = slow_stub();
      }
    } else if (lookup->state() == LookupIterator::INTERCEPTOR) {
      // Perform a lookup behind the interceptor. Copy the LookupIterator since
      // the original iterator will be used to fetch the value.
      LookupIterator it = *lookup;
      it.Next();
      LookupForRead(&it);
      if (it.state() == LookupIterator::ACCESSOR &&
          !IsCompatibleReceiver(&it, receiver_map())) {
        TRACE_GENERIC_IC(isolate(), ""LoadIC"", ""incompatible receiver type"");
        code = slow_stub();
      }
    }
    if (code.is_null()) code = ComputeHandler(lookup);
  }

  PatchCache(lookup->name(), code);
  TRACE_IC(""LoadIC"", lookup->name());
}","void LoadIC::UpdateCaches(LookupIterator* VAR_0) {
  if (state() == VAR_1) {
    /* COMMENT_0 */
    /* COMMENT_1 */
    ConfigureVectorState(VAR_2);
    TRACE_IC(""LoadIC"", VAR_0->name());
    return;
  }

  Handle<Code> VAR_3;
  if (VAR_0->state() == LookupIterator::JSPROXY ||
      VAR_0->state() == LookupIterator::ACCESS_CHECK) {
    VAR_3 = slow_stub();
  } else if (!VAR_0->IsFound()) {
    if (kind() == Code::LOAD_IC && !is_strong(language_mode())) {
      VAR_3 = NamedLoadHandlerCompiler::ComputeLoadNonexistent(VAR_0->name(),
                                                              receiver_map());
      /* COMMENT_2 */
      if (VAR_3.is_null()) VAR_3 = slow_stub();
    } else {
      VAR_3 = slow_stub();
    }
  } else {
    if (VAR_0->state() == LookupIterator::ACCESSOR) {
      if (!IsCompatibleReceiver(VAR_0, receiver_map())) {
        TRACE_GENERIC_IC(isolate(), ""LoadIC"", ""incompatible receiver type"");
        VAR_3 = slow_stub();
      }
    } else if (VAR_0->state() == LookupIterator::INTERCEPTOR) {
      /* COMMENT_3 */
      /* COMMENT_4 */
      LookupIterator VAR_4 = *VAR_0;
      VAR_4.Next();
      LookupForRead(&VAR_4);
      if (VAR_4.state() == LookupIterator::ACCESSOR &&
          !IsCompatibleReceiver(&VAR_4, receiver_map())) {
        TRACE_GENERIC_IC(isolate(), ""LoadIC"", ""incompatible receiver type"");
        VAR_3 = slow_stub();
      }
    }
    if (VAR_3.is_null()) VAR_3 = ComputeHandler(VAR_0);
  }

  PatchCache(VAR_0->name(), VAR_3);
  TRACE_IC(""LoadIC"", VAR_0->name());
}",chromium/cfbd16172fa165cc33ce0e2e72f74e5561168a61/ic.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -22,35 +22,20 @@
     }
   } else {
     if (lookup->state() == LookupIterator::ACCESSOR) {
-      Handle<Object> accessors = lookup->GetAccessors();
-      Handle<Map> map = receiver_map();
-      if (accessors->IsExecutableAccessorInfo()) {
-        Handle<ExecutableAccessorInfo> info =
-            Handle<ExecutableAccessorInfo>::cast(accessors);
-        if ((v8::ToCData<Address>(info->getter()) != 0) &&
-            !ExecutableAccessorInfo::IsCompatibleReceiverMap(isolate(), info,
-                                                             map)) {
-          TRACE_GENERIC_IC(isolate(), ""LoadIC"", ""incompatible receiver type"");
-          code = slow_stub();
-        }
-      } else if (accessors->IsAccessorPair()) {
-        Handle<Object> getter(Handle<AccessorPair>::cast(accessors)->getter(),
-                              isolate());
-        Handle<JSObject> holder = lookup->GetHolder<JSObject>();
-        Handle<Object> receiver = lookup->GetReceiver();
-        if (getter->IsJSFunction() && holder->HasFastProperties()) {
-          Handle<JSFunction> function = Handle<JSFunction>::cast(getter);
-          if (receiver->IsJSObject() || function->shared()->IsBuiltin() ||
-              !is_sloppy(function->shared()->language_mode())) {
-            CallOptimization call_optimization(function);
-            if (call_optimization.is_simple_api_call() &&
-                !call_optimization.IsCompatibleReceiver(receiver, holder)) {
-              TRACE_GENERIC_IC(isolate(), ""LoadIC"",
-                               ""incompatible receiver type"");
-              code = slow_stub();
-            }
-          }
-        }
+      if (!IsCompatibleReceiver(lookup, receiver_map())) {
+        TRACE_GENERIC_IC(isolate(), ""LoadIC"", ""incompatible receiver type"");
+        code = slow_stub();
+      }
+    } else if (lookup->state() == LookupIterator::INTERCEPTOR) {
+      // Perform a lookup behind the interceptor. Copy the LookupIterator since
+      // the original iterator will be used to fetch the value.
+      LookupIterator it = *lookup;
+      it.Next();
+      LookupForRead(&it);
+      if (it.state() == LookupIterator::ACCESSOR &&
+          !IsCompatibleReceiver(&it, receiver_map())) {
+        TRACE_GENERIC_IC(isolate(), ""LoadIC"", ""incompatible receiver type"");
+        code = slow_stub();
       }
     }
     if (code.is_null()) code = ComputeHandler(lookup);","{'deleted_lines': ['      Handle<Object> accessors = lookup->GetAccessors();', '      Handle<Map> map = receiver_map();', '      if (accessors->IsExecutableAccessorInfo()) {', '        Handle<ExecutableAccessorInfo> info =', '            Handle<ExecutableAccessorInfo>::cast(accessors);', '        if ((v8::ToCData<Address>(info->getter()) != 0) &&', '            !ExecutableAccessorInfo::IsCompatibleReceiverMap(isolate(), info,', '                                                             map)) {', '          TRACE_GENERIC_IC(isolate(), ""LoadIC"", ""incompatible receiver type"");', '          code = slow_stub();', '        }', '      } else if (accessors->IsAccessorPair()) {', '        Handle<Object> getter(Handle<AccessorPair>::cast(accessors)->getter(),', '                              isolate());', '        Handle<JSObject> holder = lookup->GetHolder<JSObject>();', '        Handle<Object> receiver = lookup->GetReceiver();', '        if (getter->IsJSFunction() && holder->HasFastProperties()) {', '          Handle<JSFunction> function = Handle<JSFunction>::cast(getter);', '          if (receiver->IsJSObject() || function->shared()->IsBuiltin() ||', '              !is_sloppy(function->shared()->language_mode())) {', '            CallOptimization call_optimization(function);', '            if (call_optimization.is_simple_api_call() &&', '                !call_optimization.IsCompatibleReceiver(receiver, holder)) {', '              TRACE_GENERIC_IC(isolate(), ""LoadIC"",', '                               ""incompatible receiver type"");', '              code = slow_stub();', '            }', '          }', '        }'], 'added_lines': ['      if (!IsCompatibleReceiver(lookup, receiver_map())) {', '        TRACE_GENERIC_IC(isolate(), ""LoadIC"", ""incompatible receiver type"");', '        code = slow_stub();', '      }', '    } else if (lookup->state() == LookupIterator::INTERCEPTOR) {', '      // Perform a lookup behind the interceptor. Copy the LookupIterator since', '      // the original iterator will be used to fetch the value.', '      LookupIterator it = *lookup;', '      it.Next();', '      LookupForRead(&it);', '      if (it.state() == LookupIterator::ACCESSOR &&', '          !IsCompatibleReceiver(&it, receiver_map())) {', '        TRACE_GENERIC_IC(isolate(), ""LoadIC"", ""incompatible receiver type"");', '        code = slow_stub();']}",True,"The LoadIC::UpdateCaches function in ic/ic.cc in Google V8, as used in Google Chrome before 48.0.2564.82, does not ensure receiver compatibility before performing a cast of an unspecified variable, which allows remote attackers to cause a denial of service or possibly have unknown other impact via crafted JavaScript code.",7.6,HIGH,2,test,,5
CVE-2016-1614,['CWE-200'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,chromium,"ImageBitmap: Change two enum uses.

An earlier CL (https://codereview.chromium.org/1382883002/) made two changes
which seem to have unintended effects on behaviour.

1. The ImageBitmap constructor asserts that its data is opaque (whereas
previously it took the default NonOpaque opacity mode), but if this is so
it should have a comment justifying it.

2. UnacceleratedImageBufferSurface is clearings the SkSurface if it was
told _not_ to initialize image pixels, which seems like an inversion of the
intended condition.

BUG=543515,544691

Review URL: https://codereview.chromium.org/1407393002

Cr-Commit-Position: refs/heads/master@{#354880}
",1998d1cc5f2985cdeac94d3e669b0e7901a77bbb,https://chromium.googlesource.com/chromium/src/+/1998d1cc5f2985cdeac94d3e669b0e7901a77bbb,third_party/WebKit/Source/core/frame/ImageBitmap.cpp,ImageBitmap::ImageBitmap,"ImageBitmap::ImageBitmap(ImageData* data, const IntRect& cropRect)
: m_imageElement(nullptr)
, m_cropRect(cropRect)
, m_bitmapOffset(IntPoint())
{
IntRect srcRect = intersection(cropRect, IntRect(IntPoint(), data->size()));
OwnPtr<ImageBuffer> buffer = ImageBuffer::create(data->size(), Opaque, DoNotInitializeImagePixels);
if (!buffer)
return;
if (srcRect.width() > 0 && srcRect.height() > 0)
buffer->putByteArray(Premultiplied, data->data()->data(), data->size(), srcRect, IntPoint(std::min(0, -cropRect.x()), std::min(0, -cropRect.y())));
m_bitmap = buffer->newImageSnapshot();
m_bitmapRect = IntRect(IntPoint(std::max(0, -cropRect.x()), std::max(0, -cropRect.y())),  srcRect.size());
}","ImageBitmap::ImageBitmap(ImageData* VAR_0, const IntRect& VAR_1)
: m_imageElement(nullptr)
, m_cropRect(VAR_1)
, m_bitmapOffset(IntPoint())
{
IntRect VAR_2 = intersection(VAR_1, IntRect(IntPoint(), VAR_0->size()));
OwnPtr<ImageBuffer> VAR_3 = ImageBuffer::create(VAR_0->size(), VAR_4, VAR_5);
if (!VAR_3)
return;
if (VAR_2.width() > 0 && VAR_2.height() > 0)
VAR_3->putByteArray(VAR_6, VAR_0->data()->data(), VAR_0->size(), VAR_2, IntPoint(std::min(0, -VAR_1.x()), std::min(0, -VAR_1.y())));
VAR_7 = VAR_3->newImageSnapshot();
VAR_8 = IntRect(IntPoint(std::max(0, -VAR_1.x()), std::max(0, -VAR_1.y())),  VAR_2.size());
}",chromium/1998d1cc5f2985cdeac94d3e669b0e7901a77bbb/ImageBitmap.cpp/vul/before/0.json,"ImageBitmap::ImageBitmap(ImageData* data, const IntRect& cropRect)
    : m_imageElement(nullptr)
    , m_cropRect(cropRect)
    , m_bitmapOffset(IntPoint())
{
    IntRect srcRect = intersection(cropRect, IntRect(IntPoint(), data->size()));
    OwnPtr<ImageBuffer> buffer = ImageBuffer::create(data->size(), NonOpaque, DoNotInitializeImagePixels);
    if (!buffer)
        return;

    if (srcRect.width() > 0 && srcRect.height() > 0)
        buffer->putByteArray(Premultiplied, data->data()->data(), data->size(), srcRect, IntPoint(std::min(0, -cropRect.x()), std::min(0, -cropRect.y())));

    m_bitmap = buffer->newImageSnapshot();
    m_bitmapRect = IntRect(IntPoint(std::max(0, -cropRect.x()), std::max(0, -cropRect.y())),  srcRect.size());
}","ImageBitmap::ImageBitmap(ImageData* VAR_0, const IntRect& VAR_1)
    : m_imageElement(nullptr)
    , m_cropRect(VAR_1)
    , m_bitmapOffset(IntPoint())
{
    IntRect VAR_2 = intersection(VAR_1, IntRect(IntPoint(), VAR_0->size()));
    OwnPtr<ImageBuffer> VAR_3 = ImageBuffer::create(VAR_0->size(), VAR_4, VAR_5);
    if (!VAR_3)
        return;

    if (VAR_2.width() > 0 && VAR_2.height() > 0)
        VAR_3->putByteArray(VAR_6, VAR_0->data()->data(), VAR_0->size(), VAR_2, IntPoint(std::min(0, -VAR_1.x()), std::min(0, -VAR_1.y())));

    VAR_7 = VAR_3->newImageSnapshot();
    VAR_8 = IntRect(IntPoint(std::max(0, -VAR_1.x()), std::max(0, -VAR_1.y())),  VAR_2.size());
}",chromium/1998d1cc5f2985cdeac94d3e669b0e7901a77bbb/ImageBitmap.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,7 +4,7 @@
     , m_bitmapOffset(IntPoint())
 {
     IntRect srcRect = intersection(cropRect, IntRect(IntPoint(), data->size()));
-    OwnPtr<ImageBuffer> buffer = ImageBuffer::create(data->size(), Opaque, DoNotInitializeImagePixels);
+    OwnPtr<ImageBuffer> buffer = ImageBuffer::create(data->size(), NonOpaque, DoNotInitializeImagePixels);
     if (!buffer)
         return;
 ","{'deleted_lines': ['    OwnPtr<ImageBuffer> buffer = ImageBuffer::create(data->size(), Opaque, DoNotInitializeImagePixels);'], 'added_lines': ['    OwnPtr<ImageBuffer> buffer = ImageBuffer::create(data->size(), NonOpaque, DoNotInitializeImagePixels);']}",True,"The UnacceleratedImageBufferSurface class in WebKit/Source/platform/graphics/UnacceleratedImageBufferSurface.cpp in Blink, as used in Google Chrome before 48.0.2564.82, mishandles the initialization mode, which allows remote attackers to obtain sensitive information from process memory via a crafted web site.",4.3,MEDIUM,1,test,,5
CVE-2016-1614,['CWE-200'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,chromium,"ImageBitmap: Change two enum uses.

An earlier CL (https://codereview.chromium.org/1382883002/) made two changes
which seem to have unintended effects on behaviour.

1. The ImageBitmap constructor asserts that its data is opaque (whereas
previously it took the default NonOpaque opacity mode), but if this is so
it should have a comment justifying it.

2. UnacceleratedImageBufferSurface is clearings the SkSurface if it was
told _not_ to initialize image pixels, which seems like an inversion of the
intended condition.

BUG=543515,544691

Review URL: https://codereview.chromium.org/1407393002

Cr-Commit-Position: refs/heads/master@{#354880}
",1998d1cc5f2985cdeac94d3e669b0e7901a77bbb,https://chromium.googlesource.com/chromium/src/+/1998d1cc5f2985cdeac94d3e669b0e7901a77bbb,third_party/WebKit/Source/platform/graphics/UnacceleratedImageBufferSurface.cpp,UnacceleratedImageBufferSurface::UnacceleratedImageBufferSurface,"UnacceleratedImageBufferSurface::UnacceleratedImageBufferSurface(const IntSize& size, OpacityMode opacityMode, ImageInitializationMode initializationMode)
: ImageBufferSurface(size, opacityMode)
{
SkAlphaType alphaType = (Opaque == opacityMode) ? kOpaque_SkAlphaType : kPremul_SkAlphaType;
SkImageInfo info = SkImageInfo::MakeN32(size.width(), size.height(), alphaType);
SkSurfaceProps disableLCDProps(0, kUnknown_SkPixelGeometry);
m_surface = adoptRef(SkSurface::NewRaster(info, Opaque == opacityMode ? 0 : &disableLCDProps));
if (initializationMode == DoNotInitializeImagePixels) {
if (m_surface)
clear();
}
}","UnacceleratedImageBufferSurface::UnacceleratedImageBufferSurface(const IntSize& VAR_0, OpacityMode VAR_1, ImageInitializationMode VAR_2)
: ImageBufferSurface(VAR_0, VAR_1)
{
SkAlphaType VAR_3 = (VAR_4 == VAR_1) ? VAR_5 : VAR_6;
SkImageInfo VAR_7 = SkImageInfo::MakeN32(VAR_0.width(), VAR_0.height(), VAR_3);
SkSurfaceProps VAR_8(0, VAR_9);
VAR_10 = adoptRef(SkSurface::NewRaster(VAR_7, VAR_4 == VAR_1 ? 0 : &VAR_8));
if (VAR_2 == VAR_11) {
if (VAR_10)
clear();
}
}",chromium/1998d1cc5f2985cdeac94d3e669b0e7901a77bbb/UnacceleratedImageBufferSurface.cpp/vul/before/0.json,"UnacceleratedImageBufferSurface::UnacceleratedImageBufferSurface(const IntSize& size, OpacityMode opacityMode, ImageInitializationMode initializationMode)
    : ImageBufferSurface(size, opacityMode)
{
    SkAlphaType alphaType = (Opaque == opacityMode) ? kOpaque_SkAlphaType : kPremul_SkAlphaType;
    SkImageInfo info = SkImageInfo::MakeN32(size.width(), size.height(), alphaType);
    SkSurfaceProps disableLCDProps(0, kUnknown_SkPixelGeometry);
    m_surface = adoptRef(SkSurface::NewRaster(info, Opaque == opacityMode ? 0 : &disableLCDProps));

    if (initializationMode == InitializeImagePixels) {
        if (m_surface)
            clear();
    }
}","UnacceleratedImageBufferSurface::UnacceleratedImageBufferSurface(const IntSize& VAR_0, OpacityMode VAR_1, ImageInitializationMode VAR_2)
    : ImageBufferSurface(VAR_0, VAR_1)
{
    SkAlphaType VAR_3 = (VAR_4 == VAR_1) ? VAR_5 : VAR_6;
    SkImageInfo VAR_7 = SkImageInfo::MakeN32(VAR_0.width(), VAR_0.height(), VAR_3);
    SkSurfaceProps VAR_8(0, VAR_9);
    VAR_10 = adoptRef(SkSurface::NewRaster(VAR_7, VAR_4 == VAR_1 ? 0 : &VAR_8));

    if (VAR_2 == VAR_11) {
        if (VAR_10)
            clear();
    }
}",chromium/1998d1cc5f2985cdeac94d3e669b0e7901a77bbb/UnacceleratedImageBufferSurface.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
     SkSurfaceProps disableLCDProps(0, kUnknown_SkPixelGeometry);
     m_surface = adoptRef(SkSurface::NewRaster(info, Opaque == opacityMode ? 0 : &disableLCDProps));
 
-    if (initializationMode == DoNotInitializeImagePixels) {
+    if (initializationMode == InitializeImagePixels) {
         if (m_surface)
             clear();
     }","{'deleted_lines': ['    if (initializationMode == DoNotInitializeImagePixels) {'], 'added_lines': ['    if (initializationMode == InitializeImagePixels) {']}",True,"The UnacceleratedImageBufferSurface class in WebKit/Source/platform/graphics/UnacceleratedImageBufferSurface.cpp in Blink, as used in Google Chrome before 48.0.2564.82, mishandles the initialization mode, which allows remote attackers to obtain sensitive information from process memory via a crafted web site.",4.3,MEDIUM,1,test,,5
CVE-2016-1619,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,pdfium,"Merge to XFA: Fix integer and bounds issues in sycc4{22,44}_to_rgb.

Also clean up while we're here.

BUG=557223
TBR=tsepez@chromium.org

Original Review URL: https://codereview.chromium.org/1512833008 .

(cherry picked from commit 08750d0400f1635ac33c3234cb11b192f31a1eeb)

Review URL: https://codereview.chromium.org/1521473003 .
",b9882f4fbcc5f6a9cea49f5c2ec6b91aafac1032,https://pdfium.googlesource.com/pdfium/+/b9882f4fbcc5f6a9cea49f5c2ec6b91aafac1032,core/src/fxcodec/codec/fx_codec_jpx_opj.cpp,sycc422_to_rgb,"static void sycc422_to_rgb(opj_image_t* img) {
int *d0, *d1, *d2, *r, *g, *b;
const int *y, *cb, *cr;
int maxw, maxh, max, offset, upb;
int i, j;
i = (int)img->comps[0].prec;
offset = 1 << (i - 1);
upb = (1 << i) - 1;
maxw = (int)img->comps[0].w;
maxh = (int)img->comps[0].h;
max = maxw * maxh;
y = img->comps[0].data;
cb = img->comps[1].data;
cr = img->comps[2].data;
d0 = r = FX_Alloc(int, (size_t)max);
d1 = g = FX_Alloc(int, (size_t)max);
d2 = b = FX_Alloc(int, (size_t)max);
for (i = 0; i < maxh; ++i) {
for (j = 0; (OPJ_UINT32)j < (maxw & ~(OPJ_UINT32)1); j += 2) {
sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
++y;
++r;
++g;
++b;
sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
++y;
++r;
++g;
++b;
++cb;
++cr;
}
if (j < maxw) {
sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
++y;
++r;
++g;
++b;
++cb;
++cr;
}
}
FX_Free(img->comps[0].data);
img->comps[0].data = d0;
FX_Free(img->comps[1].data);
img->comps[1].data = d1;
FX_Free(img->comps[2].data);
img->comps[2].data = d2;
img->comps[1].w = maxw;
img->comps[1].h = maxh;
img->comps[2].w = maxw;
img->comps[2].h = maxh;
img->comps[1].w = (OPJ_UINT32)maxw;
img->comps[1].h = (OPJ_UINT32)maxh;
img->comps[2].w = (OPJ_UINT32)maxw;
img->comps[2].h = (OPJ_UINT32)maxh;
img->comps[1].dx = img->comps[0].dx;
img->comps[2].dx = img->comps[0].dx;
img->comps[1].dy = img->comps[0].dy;
img->comps[2].dy = img->comps[0].dy;
}","static void sycc422_to_rgb(opj_image_t* VAR_0) {
int *VAR_1, *VAR_2, *VAR_3, *VAR_4, *VAR_5, *VAR_6;
const int *VAR_7, *VAR_8, *VAR_9;
int VAR_10, VAR_11, VAR_12, VAR_13, VAR_14;
int VAR_15, VAR_16;
VAR_15 = (int)VAR_0->comps[0].prec;
VAR_13 = 1 << (VAR_15 - 1);
VAR_14 = (1 << VAR_15) - 1;
VAR_10 = (int)VAR_0->comps[0].w;
VAR_11 = (int)VAR_0->comps[0].h;
VAR_12 = VAR_10 * VAR_11;
VAR_7 = VAR_0->comps[0].data;
VAR_8 = VAR_0->comps[1].data;
VAR_9 = VAR_0->comps[2].data;
VAR_1 = VAR_4 = VAR_17(int, (size_t)VAR_12);
VAR_2 = VAR_5 = VAR_17(int, (size_t)VAR_12);
VAR_3 = VAR_6 = VAR_17(int, (size_t)VAR_12);
for (VAR_15 = 0; VAR_15 < VAR_11; ++VAR_15) {
for (VAR_16 = 0; (OPJ_UINT32)VAR_16 < (VAR_10 & ~(OPJ_UINT32)1); VAR_16 += 2) {
sycc_to_rgb(VAR_13, VAR_14, *VAR_7, *VAR_8, *VAR_9, VAR_4, VAR_5, VAR_6);
++VAR_7;
++VAR_4;
++VAR_5;
++VAR_6;
sycc_to_rgb(VAR_13, VAR_14, *VAR_7, *VAR_8, *VAR_9, VAR_4, VAR_5, VAR_6);
++VAR_7;
++VAR_4;
++VAR_5;
++VAR_6;
++VAR_8;
++VAR_9;
}
if (VAR_16 < VAR_10) {
sycc_to_rgb(VAR_13, VAR_14, *VAR_7, *VAR_8, *VAR_9, VAR_4, VAR_5, VAR_6);
++VAR_7;
++VAR_4;
++VAR_5;
++VAR_6;
++VAR_8;
++VAR_9;
}
}
FX_Free(VAR_0->comps[0].data);
VAR_0->comps[0].data = VAR_1;
FX_Free(VAR_0->comps[1].data);
VAR_0->comps[1].data = VAR_2;
FX_Free(VAR_0->comps[2].data);
VAR_0->comps[2].data = VAR_3;
VAR_0->comps[1].w = VAR_10;
VAR_0->comps[1].h = VAR_11;
VAR_0->comps[2].w = VAR_10;
VAR_0->comps[2].h = VAR_11;
VAR_0->comps[1].w = (OPJ_UINT32)VAR_10;
VAR_0->comps[1].h = (OPJ_UINT32)VAR_11;
VAR_0->comps[2].w = (OPJ_UINT32)VAR_10;
VAR_0->comps[2].h = (OPJ_UINT32)VAR_11;
VAR_0->comps[1].dx = VAR_0->comps[0].dx;
VAR_0->comps[2].dx = VAR_0->comps[0].dx;
VAR_0->comps[1].dy = VAR_0->comps[0].dy;
VAR_0->comps[2].dy = VAR_0->comps[0].dy;
}",pdfium/b9882f4fbcc5f6a9cea49f5c2ec6b91aafac1032/fx_codec_jpx_opj.cpp/vul/before/0.json,"static void sycc422_to_rgb(opj_image_t* img) {
  int prec = img->comps[0].prec;
  int offset = 1 << (prec - 1);
  int upb = (1 << prec) - 1;
  OPJ_UINT32 maxw =
      std::min(std::min(img->comps[0].w, img->comps[1].w), img->comps[2].w);
  OPJ_UINT32 maxh =
      std::min(std::min(img->comps[0].h, img->comps[1].h), img->comps[2].h);
  FX_SAFE_SIZE_T max_size = maxw;
  max_size *= maxh;
  if (!max_size.IsValid())
    return;

  const int* y = img->comps[0].data;
  const int* cb = img->comps[1].data;
  const int* cr = img->comps[2].data;
  int *d0, *d1, *d2, *r, *g, *b;
  d0 = r = FX_Alloc(int, max_size.ValueOrDie());
  d1 = g = FX_Alloc(int, max_size.ValueOrDie());
  d2 = b = FX_Alloc(int, max_size.ValueOrDie());
  for (uint32_t i = 0; i < maxh; ++i) {
    OPJ_UINT32 j;
    for (j = 0; j < (maxw & ~static_cast<OPJ_UINT32>(1)); j += 2) {
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
      ++y;
      ++r;
      ++g;
      ++b;
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
      ++y;
      ++r;
      ++g;
      ++b;
      ++cb;
      ++cr;
    }
    if (j < maxw) {
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
      ++y;
      ++r;
      ++g;
      ++b;
      ++cb;
      ++cr;
    }
  }
  FX_Free(img->comps[0].data);
  img->comps[0].data = d0;
  FX_Free(img->comps[1].data);
  img->comps[1].data = d1;
  FX_Free(img->comps[2].data);
  img->comps[2].data = d2;
  img->comps[1].w = maxw;
  img->comps[1].h = maxh;
  img->comps[2].w = maxw;
  img->comps[2].h = maxh;
  img->comps[1].dx = img->comps[0].dx;
  img->comps[2].dx = img->comps[0].dx;
  img->comps[1].dy = img->comps[0].dy;
  img->comps[2].dy = img->comps[0].dy;
}","static void sycc422_to_rgb(opj_image_t* VAR_0) {
  int VAR_1 = VAR_0->comps[0].prec;
  int VAR_2 = 1 << (VAR_1 - 1);
  int VAR_3 = (1 << VAR_1) - 1;
  OPJ_UINT32 VAR_4 =
      std::min(std::min(VAR_0->comps[0].w, VAR_0->comps[1].w), VAR_0->comps[2].w);
  OPJ_UINT32 VAR_5 =
      std::min(std::min(VAR_0->comps[0].h, VAR_0->comps[1].h), VAR_0->comps[2].h);
  FX_SAFE_SIZE_T VAR_6 = VAR_4;
  VAR_6 *= VAR_5;
  if (!VAR_6.IsValid())
    return;

  const int* VAR_7 = VAR_0->comps[0].data;
  const int* VAR_8 = VAR_0->comps[1].data;
  const int* VAR_9 = VAR_0->comps[2].data;
  int *VAR_10, *VAR_11, *VAR_12, *VAR_13, *VAR_14, *VAR_15;
  VAR_10 = VAR_13 = FX_Alloc(int, VAR_6.ValueOrDie());
  VAR_11 = VAR_14 = FX_Alloc(int, VAR_6.ValueOrDie());
  VAR_12 = VAR_15 = FX_Alloc(int, VAR_6.ValueOrDie());
  for (uint32_t VAR_16 = 0; VAR_16 < VAR_5; ++VAR_16) {
    OPJ_UINT32 VAR_17;
    for (VAR_17 = 0; VAR_17 < (VAR_4 & ~VAR_18<OPJ_UINT32>(1)); VAR_17 += 2) {
      sycc_to_rgb(VAR_2, VAR_3, *VAR_7, *VAR_8, *VAR_9, VAR_13, VAR_14, VAR_15);
      ++VAR_7;
      ++VAR_13;
      ++VAR_14;
      ++VAR_15;
      sycc_to_rgb(VAR_2, VAR_3, *VAR_7, *VAR_8, *VAR_9, VAR_13, VAR_14, VAR_15);
      ++VAR_7;
      ++VAR_13;
      ++VAR_14;
      ++VAR_15;
      ++VAR_8;
      ++VAR_9;
    }
    if (VAR_17 < VAR_4) {
      sycc_to_rgb(VAR_2, VAR_3, *VAR_7, *VAR_8, *VAR_9, VAR_13, VAR_14, VAR_15);
      ++VAR_7;
      ++VAR_13;
      ++VAR_14;
      ++VAR_15;
      ++VAR_8;
      ++VAR_9;
    }
  }
  FX_Free(VAR_0->comps[0].data);
  VAR_0->comps[0].data = VAR_10;
  FX_Free(VAR_0->comps[1].data);
  VAR_0->comps[1].data = VAR_11;
  FX_Free(VAR_0->comps[2].data);
  VAR_0->comps[2].data = VAR_12;
  VAR_0->comps[1].w = VAR_4;
  VAR_0->comps[1].h = VAR_5;
  VAR_0->comps[2].w = VAR_4;
  VAR_0->comps[2].h = VAR_5;
  VAR_0->comps[1].dx = VAR_0->comps[0].dx;
  VAR_0->comps[2].dx = VAR_0->comps[0].dx;
  VAR_0->comps[1].dy = VAR_0->comps[0].dy;
  VAR_0->comps[2].dy = VAR_0->comps[0].dy;
}",pdfium/b9882f4fbcc5f6a9cea49f5c2ec6b91aafac1032/fx_codec_jpx_opj.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,22 +1,26 @@
 static void sycc422_to_rgb(opj_image_t* img) {
+  int prec = img->comps[0].prec;
+  int offset = 1 << (prec - 1);
+  int upb = (1 << prec) - 1;
+  OPJ_UINT32 maxw =
+      std::min(std::min(img->comps[0].w, img->comps[1].w), img->comps[2].w);
+  OPJ_UINT32 maxh =
+      std::min(std::min(img->comps[0].h, img->comps[1].h), img->comps[2].h);
+  FX_SAFE_SIZE_T max_size = maxw;
+  max_size *= maxh;
+  if (!max_size.IsValid())
+    return;
+
+  const int* y = img->comps[0].data;
+  const int* cb = img->comps[1].data;
+  const int* cr = img->comps[2].data;
   int *d0, *d1, *d2, *r, *g, *b;
-  const int *y, *cb, *cr;
-  int maxw, maxh, max, offset, upb;
-  int i, j;
-  i = (int)img->comps[0].prec;
-  offset = 1 << (i - 1);
-  upb = (1 << i) - 1;
-  maxw = (int)img->comps[0].w;
-  maxh = (int)img->comps[0].h;
-  max = maxw * maxh;
-  y = img->comps[0].data;
-  cb = img->comps[1].data;
-  cr = img->comps[2].data;
-  d0 = r = FX_Alloc(int, (size_t)max);
-  d1 = g = FX_Alloc(int, (size_t)max);
-  d2 = b = FX_Alloc(int, (size_t)max);
-  for (i = 0; i < maxh; ++i) {
-    for (j = 0; (OPJ_UINT32)j < (maxw & ~(OPJ_UINT32)1); j += 2) {
+  d0 = r = FX_Alloc(int, max_size.ValueOrDie());
+  d1 = g = FX_Alloc(int, max_size.ValueOrDie());
+  d2 = b = FX_Alloc(int, max_size.ValueOrDie());
+  for (uint32_t i = 0; i < maxh; ++i) {
+    OPJ_UINT32 j;
+    for (j = 0; j < (maxw & ~static_cast<OPJ_UINT32>(1)); j += 2) {
       sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
       ++y;
       ++r;
@@ -50,10 +54,6 @@
   img->comps[1].h = maxh;
   img->comps[2].w = maxw;
   img->comps[2].h = maxh;
-  img->comps[1].w = (OPJ_UINT32)maxw;
-  img->comps[1].h = (OPJ_UINT32)maxh;
-  img->comps[2].w = (OPJ_UINT32)maxw;
-  img->comps[2].h = (OPJ_UINT32)maxh;
   img->comps[1].dx = img->comps[0].dx;
   img->comps[2].dx = img->comps[0].dx;
   img->comps[1].dy = img->comps[0].dy;","{'deleted_lines': ['  const int *y, *cb, *cr;', '  int maxw, maxh, max, offset, upb;', '  int i, j;', '  i = (int)img->comps[0].prec;', '  offset = 1 << (i - 1);', '  upb = (1 << i) - 1;', '  maxw = (int)img->comps[0].w;', '  maxh = (int)img->comps[0].h;', '  max = maxw * maxh;', '  y = img->comps[0].data;', '  cb = img->comps[1].data;', '  cr = img->comps[2].data;', '  d0 = r = FX_Alloc(int, (size_t)max);', '  d1 = g = FX_Alloc(int, (size_t)max);', '  d2 = b = FX_Alloc(int, (size_t)max);', '  for (i = 0; i < maxh; ++i) {', '    for (j = 0; (OPJ_UINT32)j < (maxw & ~(OPJ_UINT32)1); j += 2) {', '  img->comps[1].w = (OPJ_UINT32)maxw;', '  img->comps[1].h = (OPJ_UINT32)maxh;', '  img->comps[2].w = (OPJ_UINT32)maxw;', '  img->comps[2].h = (OPJ_UINT32)maxh;'], 'added_lines': ['  int prec = img->comps[0].prec;', '  int offset = 1 << (prec - 1);', '  int upb = (1 << prec) - 1;', '  OPJ_UINT32 maxw =', '      std::min(std::min(img->comps[0].w, img->comps[1].w), img->comps[2].w);', '  OPJ_UINT32 maxh =', '      std::min(std::min(img->comps[0].h, img->comps[1].h), img->comps[2].h);', '  FX_SAFE_SIZE_T max_size = maxw;', '  max_size *= maxh;', '  if (!max_size.IsValid())', '    return;', '', '  const int* y = img->comps[0].data;', '  const int* cb = img->comps[1].data;', '  const int* cr = img->comps[2].data;', '  d0 = r = FX_Alloc(int, max_size.ValueOrDie());', '  d1 = g = FX_Alloc(int, max_size.ValueOrDie());', '  d2 = b = FX_Alloc(int, max_size.ValueOrDie());', '  for (uint32_t i = 0; i < maxh; ++i) {', '    OPJ_UINT32 j;', '    for (j = 0; j < (maxw & ~static_cast<OPJ_UINT32>(1)); j += 2) {']}",True,"Multiple integer overflows in the (1) sycc422_to_rgb and (2) sycc444_to_rgb functions in fxcodec/codec/fx_codec_jpx_opj.cpp in PDFium, as used in Google Chrome before 48.0.2564.82, allow remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted PDF document.",7.6,HIGH,2,test,,5
CVE-2016-1619,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,pdfium,"Merge to XFA: Fix integer and bounds issues in sycc4{22,44}_to_rgb.

Also clean up while we're here.

BUG=557223
TBR=tsepez@chromium.org

Original Review URL: https://codereview.chromium.org/1512833008 .

(cherry picked from commit 08750d0400f1635ac33c3234cb11b192f31a1eeb)

Review URL: https://codereview.chromium.org/1521473003 .
",b9882f4fbcc5f6a9cea49f5c2ec6b91aafac1032,https://pdfium.googlesource.com/pdfium/+/b9882f4fbcc5f6a9cea49f5c2ec6b91aafac1032,core/src/fxcodec/codec/fx_codec_jpx_opj.cpp,sycc444_to_rgb,"static void sycc444_to_rgb(opj_image_t* img) {
int *d0, *d1, *d2, *r, *g, *b;
const int *y, *cb, *cr;
int maxw, maxh, max, i, offset, upb;
i = (int)img->comps[0].prec;
offset = 1 << (i - 1);
upb = (1 << i) - 1;
maxw = (int)img->comps[0].w;
maxh = (int)img->comps[0].h;
max = maxw * maxh;
y = img->comps[0].data;
cb = img->comps[1].data;
cr = img->comps[2].data;
d0 = r = FX_Alloc(int, (size_t)max);
d1 = g = FX_Alloc(int, (size_t)max);
d2 = b = FX_Alloc(int, (size_t)max);
for (i = 0; i < max; ++i) {
sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
++y;
++cb;
++cr;
++r;
++g;
++b;
}
FX_Free(img->comps[0].data);
img->comps[0].data = d0;
FX_Free(img->comps[1].data);
img->comps[1].data = d1;
FX_Free(img->comps[2].data);
img->comps[2].data = d2;
}","static void sycc444_to_rgb(opj_image_t* VAR_0) {
int *VAR_1, *VAR_2, *VAR_3, *VAR_4, *VAR_5, *VAR_6;
const int *VAR_7, *VAR_8, *VAR_9;
int VAR_10, VAR_11, VAR_12, VAR_13, VAR_14, VAR_15;
VAR_13 = (int)VAR_0->comps[0].prec;
VAR_14 = 1 << (VAR_13 - 1);
VAR_15 = (1 << VAR_13) - 1;
VAR_10 = (int)VAR_0->comps[0].w;
VAR_11 = (int)VAR_0->comps[0].h;
VAR_12 = VAR_10 * VAR_11;
VAR_7 = VAR_0->comps[0].data;
VAR_8 = VAR_0->comps[1].data;
VAR_9 = VAR_0->comps[2].data;
VAR_1 = VAR_4 = VAR_16(int, (size_t)VAR_12);
VAR_2 = VAR_5 = VAR_16(int, (size_t)VAR_12);
VAR_3 = VAR_6 = VAR_16(int, (size_t)VAR_12);
for (VAR_13 = 0; VAR_13 < VAR_12; ++VAR_13) {
sycc_to_rgb(VAR_14, VAR_15, *VAR_7, *VAR_8, *VAR_9, VAR_4, VAR_5, VAR_6);
++VAR_7;
++VAR_8;
++VAR_9;
++VAR_4;
++VAR_5;
++VAR_6;
}
FX_Free(VAR_0->comps[0].data);
VAR_0->comps[0].data = VAR_1;
FX_Free(VAR_0->comps[1].data);
VAR_0->comps[1].data = VAR_2;
FX_Free(VAR_0->comps[2].data);
VAR_0->comps[2].data = VAR_3;
}",pdfium/b9882f4fbcc5f6a9cea49f5c2ec6b91aafac1032/fx_codec_jpx_opj.cpp/vul/before/1.json,"static void sycc444_to_rgb(opj_image_t* img) {
  int prec = img->comps[0].prec;
  int offset = 1 << (prec - 1);
  int upb = (1 << prec) - 1;
  OPJ_UINT32 maxw =
      std::min(std::min(img->comps[0].w, img->comps[1].w), img->comps[2].w);
  OPJ_UINT32 maxh =
      std::min(std::min(img->comps[0].h, img->comps[1].h), img->comps[2].h);
  FX_SAFE_SIZE_T max_size = maxw;
  max_size *= maxh;
  if (!max_size.IsValid())
    return;

  const int* y = img->comps[0].data;
  const int* cb = img->comps[1].data;
  const int* cr = img->comps[2].data;
  int *d0, *d1, *d2, *r, *g, *b;
  d0 = r = FX_Alloc(int, max_size.ValueOrDie());
  d1 = g = FX_Alloc(int, max_size.ValueOrDie());
  d2 = b = FX_Alloc(int, max_size.ValueOrDie());
  for (size_t i = 0; i < max_size.ValueOrDie(); ++i) {
    sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
    ++y;
    ++cb;
    ++cr;
    ++r;
    ++g;
    ++b;
  }
  FX_Free(img->comps[0].data);
  img->comps[0].data = d0;
  FX_Free(img->comps[1].data);
  img->comps[1].data = d1;
  FX_Free(img->comps[2].data);
  img->comps[2].data = d2;
}","static void sycc444_to_rgb(opj_image_t* VAR_0) {
  int VAR_1 = VAR_0->comps[0].prec;
  int VAR_2 = 1 << (VAR_1 - 1);
  int VAR_3 = (1 << VAR_1) - 1;
  OPJ_UINT32 VAR_4 =
      std::min(std::min(VAR_0->comps[0].w, VAR_0->comps[1].w), VAR_0->comps[2].w);
  OPJ_UINT32 VAR_5 =
      std::min(std::min(VAR_0->comps[0].h, VAR_0->comps[1].h), VAR_0->comps[2].h);
  FX_SAFE_SIZE_T VAR_6 = VAR_4;
  VAR_6 *= VAR_5;
  if (!VAR_6.IsValid())
    return;

  const int* VAR_7 = VAR_0->comps[0].data;
  const int* VAR_8 = VAR_0->comps[1].data;
  const int* VAR_9 = VAR_0->comps[2].data;
  int *VAR_10, *VAR_11, *VAR_12, *VAR_13, *VAR_14, *VAR_15;
  VAR_10 = VAR_13 = FX_Alloc(int, VAR_6.ValueOrDie());
  VAR_11 = VAR_14 = FX_Alloc(int, VAR_6.ValueOrDie());
  VAR_12 = VAR_15 = FX_Alloc(int, VAR_6.ValueOrDie());
  for (size_t VAR_16 = 0; VAR_16 < VAR_6.ValueOrDie(); ++VAR_16) {
    sycc_to_rgb(VAR_2, VAR_3, *VAR_7, *VAR_8, *VAR_9, VAR_13, VAR_14, VAR_15);
    ++VAR_7;
    ++VAR_8;
    ++VAR_9;
    ++VAR_13;
    ++VAR_14;
    ++VAR_15;
  }
  FX_Free(VAR_0->comps[0].data);
  VAR_0->comps[0].data = VAR_10;
  FX_Free(VAR_0->comps[1].data);
  VAR_0->comps[1].data = VAR_11;
  FX_Free(VAR_0->comps[2].data);
  VAR_0->comps[2].data = VAR_12;
}",pdfium/b9882f4fbcc5f6a9cea49f5c2ec6b91aafac1032/fx_codec_jpx_opj.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,20 +1,24 @@
 static void sycc444_to_rgb(opj_image_t* img) {
+  int prec = img->comps[0].prec;
+  int offset = 1 << (prec - 1);
+  int upb = (1 << prec) - 1;
+  OPJ_UINT32 maxw =
+      std::min(std::min(img->comps[0].w, img->comps[1].w), img->comps[2].w);
+  OPJ_UINT32 maxh =
+      std::min(std::min(img->comps[0].h, img->comps[1].h), img->comps[2].h);
+  FX_SAFE_SIZE_T max_size = maxw;
+  max_size *= maxh;
+  if (!max_size.IsValid())
+    return;
+
+  const int* y = img->comps[0].data;
+  const int* cb = img->comps[1].data;
+  const int* cr = img->comps[2].data;
   int *d0, *d1, *d2, *r, *g, *b;
-  const int *y, *cb, *cr;
-  int maxw, maxh, max, i, offset, upb;
-  i = (int)img->comps[0].prec;
-  offset = 1 << (i - 1);
-  upb = (1 << i) - 1;
-  maxw = (int)img->comps[0].w;
-  maxh = (int)img->comps[0].h;
-  max = maxw * maxh;
-  y = img->comps[0].data;
-  cb = img->comps[1].data;
-  cr = img->comps[2].data;
-  d0 = r = FX_Alloc(int, (size_t)max);
-  d1 = g = FX_Alloc(int, (size_t)max);
-  d2 = b = FX_Alloc(int, (size_t)max);
-  for (i = 0; i < max; ++i) {
+  d0 = r = FX_Alloc(int, max_size.ValueOrDie());
+  d1 = g = FX_Alloc(int, max_size.ValueOrDie());
+  d2 = b = FX_Alloc(int, max_size.ValueOrDie());
+  for (size_t i = 0; i < max_size.ValueOrDie(); ++i) {
     sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
     ++y;
     ++cb;","{'deleted_lines': ['  const int *y, *cb, *cr;', '  int maxw, maxh, max, i, offset, upb;', '  i = (int)img->comps[0].prec;', '  offset = 1 << (i - 1);', '  upb = (1 << i) - 1;', '  maxw = (int)img->comps[0].w;', '  maxh = (int)img->comps[0].h;', '  max = maxw * maxh;', '  y = img->comps[0].data;', '  cb = img->comps[1].data;', '  cr = img->comps[2].data;', '  d0 = r = FX_Alloc(int, (size_t)max);', '  d1 = g = FX_Alloc(int, (size_t)max);', '  d2 = b = FX_Alloc(int, (size_t)max);', '  for (i = 0; i < max; ++i) {'], 'added_lines': ['  int prec = img->comps[0].prec;', '  int offset = 1 << (prec - 1);', '  int upb = (1 << prec) - 1;', '  OPJ_UINT32 maxw =', '      std::min(std::min(img->comps[0].w, img->comps[1].w), img->comps[2].w);', '  OPJ_UINT32 maxh =', '      std::min(std::min(img->comps[0].h, img->comps[1].h), img->comps[2].h);', '  FX_SAFE_SIZE_T max_size = maxw;', '  max_size *= maxh;', '  if (!max_size.IsValid())', '    return;', '', '  const int* y = img->comps[0].data;', '  const int* cb = img->comps[1].data;', '  const int* cr = img->comps[2].data;', '  d0 = r = FX_Alloc(int, max_size.ValueOrDie());', '  d1 = g = FX_Alloc(int, max_size.ValueOrDie());', '  d2 = b = FX_Alloc(int, max_size.ValueOrDie());', '  for (size_t i = 0; i < max_size.ValueOrDie(); ++i) {']}",True,"Multiple integer overflows in the (1) sycc422_to_rgb and (2) sycc444_to_rgb functions in fxcodec/codec/fx_codec_jpx_opj.cpp in PDFium, as used in Google Chrome before 48.0.2564.82, allow remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted PDF document.",7.6,HIGH,2,test,,5
CVE-2016-2329,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ffmpeg,"
avcodec/tiff: Check subsample & rps values more completely

Fixes out of array access
Fixes: 83aedfb29af669c4d6e10f1bfad974d2/asan_heap-oob_1ab42fe_4984_9f6ec14462f8d8a00ea24b320572a963.tif

Found-by: Mateusz ""j00ru"" Jurczyk and Gynvael Coldwind
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>
",89f464e9c229006e16f6bb5403c5529fdd0a9edd,http://git.videolan.org/?p=ffmpeg.git;a=commit;h=89f464e9c229006e16f6bb5403c5529fdd0a9edd,libavcodec/tiff.c,tiff_decode_tag,"static int tiff_decode_tag(TiffContext *s, AVFrame *frame)
{
unsigned tag, type, count, off, value = 0, value2 = 0;
int i, start;
int pos;
int ret;
double *dp;
ret = ff_tread_tag(&s->gb, s->le, &tag, &type, &count, &start);
if (ret < 0) {
goto end;
}
off = bytestream2_tell(&s->gb);
if (count == 1) {
switch (type) {
case TIFF_BYTE:
case TIFF_SHORT:
case TIFF_LONG:
value = ff_tget(&s->gb, type, s->le);
break;
case TIFF_RATIONAL:
value  = ff_tget(&s->gb, TIFF_LONG, s->le);
value2 = ff_tget(&s->gb, TIFF_LONG, s->le);
break;
case TIFF_STRING:
if (count <= 4) {
break;
}
default:
value = UINT_MAX;
}
}
switch (tag) {
case TIFF_WIDTH:
s->width = value;
break;
case TIFF_HEIGHT:
s->height = value;
break;
case TIFF_BPP:
if (count > 4U) {
av_log(s->avctx, AV_LOG_ERROR,
""This format is not supported (bpp=%d, %d components)\n"",
value, count);
return AVERROR_INVALIDDATA;
}
s->bppcount = count;
if (count == 1)
s->bpp = value;
else {
switch (type) {
case TIFF_BYTE:
case TIFF_SHORT:
case TIFF_LONG:
s->bpp = 0;
if (bytestream2_get_bytes_left(&s->gb) < type_sizes[type] * count)
return AVERROR_INVALIDDATA;
for (i = 0; i < count; i++)
s->bpp += ff_tget(&s->gb, type, s->le);
break;
default:
s->bpp = -1;
}
}
break;
case TIFF_SAMPLES_PER_PIXEL:
if (count != 1) {
av_log(s->avctx, AV_LOG_ERROR,
""Samples per pixel requires a single value, many provided\n"");
return AVERROR_INVALIDDATA;
}
if (value > 4U) {
av_log(s->avctx, AV_LOG_ERROR,
""Samples per pixel %d is too large\n"", value);
return AVERROR_INVALIDDATA;
}
if (s->bppcount == 1)
s->bpp *= value;
s->bppcount = value;
break;
case TIFF_COMPR:
s->compr     = value;
s->predictor = 0;
switch (s->compr) {
case TIFF_RAW:
case TIFF_PACKBITS:
case TIFF_LZW:
case TIFF_CCITT_RLE:
break;
case TIFF_G3:
case TIFF_G4:
s->fax_opts = 0;
break;
case TIFF_DEFLATE:
case TIFF_ADOBE_DEFLATE:
#if CONFIG_ZLIB
break;
#else
av_log(s->avctx, AV_LOG_ERROR, ""Deflate: ZLib not compiled in\n"");
return AVERROR(ENOSYS);
#endif
case TIFF_JPEG:
case TIFF_NEWJPEG:
avpriv_report_missing_feature(s->avctx, ""JPEG compression"");
return AVERROR_PATCHWELCOME;
case TIFF_LZMA:
#if CONFIG_LZMA
break;
#else
av_log(s->avctx, AV_LOG_ERROR, ""LZMA not compiled in\n"");
return AVERROR(ENOSYS);
#endif
default:
av_log(s->avctx, AV_LOG_ERROR, ""Unknown compression method %i\n"",
s->compr);
return AVERROR_INVALIDDATA;
}
break;
case TIFF_ROWSPERSTRIP:
if (!value || (type == TIFF_LONG && value == UINT_MAX))
value = s->height;
s->rps = FFMIN(value, s->height);
break;
case TIFF_STRIP_OFFS:
if (count == 1) {
s->strippos = 0;
s->stripoff = value;
} else
s->strippos = off;
s->strips = count;
if (s->strips == 1)
s->rps = s->height;
s->sot = type;
break;
case TIFF_STRIP_SIZE:
if (count == 1) {
s->stripsizesoff = 0;
s->stripsize     = value;
s->strips        = 1;
} else {
s->stripsizesoff = off;
}
s->strips = count;
s->sstype = type;
break;
case TIFF_XRES:
case TIFF_YRES:
set_sar(s, tag, value, value2);
break;
case TIFF_TILE_BYTE_COUNTS:
case TIFF_TILE_LENGTH:
case TIFF_TILE_OFFSETS:
case TIFF_TILE_WIDTH:
av_log(s->avctx, AV_LOG_ERROR, ""Tiled images are not supported\n"");
return AVERROR_PATCHWELCOME;
break;
case TIFF_PREDICTOR:
s->predictor = value;
break;
case TIFF_PHOTOMETRIC:
switch (value) {
case TIFF_PHOTOMETRIC_WHITE_IS_ZERO:
case TIFF_PHOTOMETRIC_BLACK_IS_ZERO:
case TIFF_PHOTOMETRIC_RGB:
case TIFF_PHOTOMETRIC_PALETTE:
case TIFF_PHOTOMETRIC_YCBCR:
s->photometric = value;
break;
case TIFF_PHOTOMETRIC_ALPHA_MASK:
case TIFF_PHOTOMETRIC_SEPARATED:
case TIFF_PHOTOMETRIC_CIE_LAB:
case TIFF_PHOTOMETRIC_ICC_LAB:
case TIFF_PHOTOMETRIC_ITU_LAB:
case TIFF_PHOTOMETRIC_CFA:
case TIFF_PHOTOMETRIC_LOG_L:
case TIFF_PHOTOMETRIC_LOG_LUV:
case TIFF_PHOTOMETRIC_LINEAR_RAW:
avpriv_report_missing_feature(s->avctx,
""PhotometricInterpretation 0x%04X"",
value);
return AVERROR_PATCHWELCOME;
default:
av_log(s->avctx, AV_LOG_ERROR, ""PhotometricInterpretation %u is ""
""unknown\n"", value);
return AVERROR_INVALIDDATA;
}
break;
case TIFF_FILL_ORDER:
if (value < 1 || value > 2) {
av_log(s->avctx, AV_LOG_ERROR,
""Unknown FillOrder value %d, trying default one\n"", value);
value = 1;
}
s->fill_order = value - 1;
break;
case TIFF_PAL: {
GetByteContext pal_gb[3];
off = type_sizes[type];
if (count / 3 > 256 ||
bytestream2_get_bytes_left(&s->gb) < count / 3 * off * 3)
return AVERROR_INVALIDDATA;
pal_gb[0] = pal_gb[1] = pal_gb[2] = s->gb;
bytestream2_skip(&pal_gb[1], count / 3 * off);
bytestream2_skip(&pal_gb[2], count / 3 * off * 2);
off = (type_sizes[type] - 1) << 3;
for (i = 0; i < count / 3; i++) {
uint32_t p = 0xFF000000;
p |= (ff_tget(&pal_gb[0], type, s->le) >> off) << 16;
p |= (ff_tget(&pal_gb[1], type, s->le) >> off) << 8;
p |=  ff_tget(&pal_gb[2], type, s->le) >> off;
s->palette[i] = p;
}
s->palette_is_set = 1;
break;
}
case TIFF_PLANAR:
s->planar = value == 2;
break;
case TIFF_YCBCR_SUBSAMPLING:
if (count != 2) {
av_log(s->avctx, AV_LOG_ERROR, ""subsample count invalid\n"");
return AVERROR_INVALIDDATA;
}
for (i = 0; i < count; i++)
s->subsampling[i] = ff_tget(&s->gb, type, s->le);
break;
case TIFF_T4OPTIONS:
if (s->compr == TIFF_G3)
s->fax_opts = value;
break;
case TIFF_T6OPTIONS:
if (s->compr == TIFF_G4)
s->fax_opts = value;
break;
#define ADD_METADATA(count, name, sep)\
if ((ret = add_metadata(count, type, name, sep, s, frame)) < 0) {\
av_log(s->avctx, AV_LOG_ERROR, ""Error allocating temporary buffer\n"");\
goto end;\
}
case TIFF_MODEL_PIXEL_SCALE:
ADD_METADATA(count, ""ModelPixelScaleTag"", NULL);
break;
case TIFF_MODEL_TRANSFORMATION:
ADD_METADATA(count, ""ModelTransformationTag"", NULL);
break;
case TIFF_MODEL_TIEPOINT:
ADD_METADATA(count, ""ModelTiepointTag"", NULL);
break;
case TIFF_GEO_KEY_DIRECTORY:
ADD_METADATA(1, ""GeoTIFF_Version"", NULL);
ADD_METADATA(2, ""GeoTIFF_Key_Revision"", ""."");
s->geotag_count   = ff_tget_short(&s->gb, s->le);
if (s->geotag_count > count / 4 - 1) {
s->geotag_count = count / 4 - 1;
av_log(s->avctx, AV_LOG_WARNING, ""GeoTIFF key directory buffer shorter than specified\n"");
}
if (bytestream2_get_bytes_left(&s->gb) < s->geotag_count * sizeof(int16_t) * 4) {
s->geotag_count = 0;
return -1;
}
s->geotags = av_mallocz_array(s->geotag_count, sizeof(TiffGeoTag));
if (!s->geotags) {
av_log(s->avctx, AV_LOG_ERROR, ""Error allocating temporary buffer\n"");
s->geotag_count = 0;
goto end;
}
for (i = 0; i < s->geotag_count; i++) {
s->geotags[i].key    = ff_tget_short(&s->gb, s->le);
s->geotags[i].type   = ff_tget_short(&s->gb, s->le);
s->geotags[i].count  = ff_tget_short(&s->gb, s->le);
if (!s->geotags[i].type)
s->geotags[i].val  = get_geokey_val(s->geotags[i].key, ff_tget_short(&s->gb, s->le));
else
s->geotags[i].offset = ff_tget_short(&s->gb, s->le);
}
break;
case TIFF_GEO_DOUBLE_PARAMS:
if (count >= INT_MAX / sizeof(int64_t))
return AVERROR_INVALIDDATA;
if (bytestream2_get_bytes_left(&s->gb) < count * sizeof(int64_t))
return AVERROR_INVALIDDATA;
dp = av_malloc_array(count, sizeof(double));
if (!dp) {
av_log(s->avctx, AV_LOG_ERROR, ""Error allocating temporary buffer\n"");
goto end;
}
for (i = 0; i < count; i++)
dp[i] = ff_tget_double(&s->gb, s->le);
for (i = 0; i < s->geotag_count; i++) {
if (s->geotags[i].type == TIFF_GEO_DOUBLE_PARAMS) {
if (s->geotags[i].count == 0
|| s->geotags[i].offset + s->geotags[i].count > count) {
av_log(s->avctx, AV_LOG_WARNING, ""Invalid GeoTIFF key %d\n"", s->geotags[i].key);
} else {
char *ap = doubles2str(&dp[s->geotags[i].offset], s->geotags[i].count, "", "");
if (!ap) {
av_log(s->avctx, AV_LOG_ERROR, ""Error allocating temporary buffer\n"");
av_freep(&dp);
return AVERROR(ENOMEM);
}
s->geotags[i].val = ap;
}
}
}
av_freep(&dp);
break;
case TIFF_GEO_ASCII_PARAMS:
pos = bytestream2_tell(&s->gb);
for (i = 0; i < s->geotag_count; i++) {
if (s->geotags[i].type == TIFF_GEO_ASCII_PARAMS) {
if (s->geotags[i].count == 0
|| s->geotags[i].offset +  s->geotags[i].count > count) {
av_log(s->avctx, AV_LOG_WARNING, ""Invalid GeoTIFF key %d\n"", s->geotags[i].key);
} else {
char *ap;
bytestream2_seek(&s->gb, pos + s->geotags[i].offset, SEEK_SET);
if (bytestream2_get_bytes_left(&s->gb) < s->geotags[i].count)
return AVERROR_INVALIDDATA;
ap = av_malloc(s->geotags[i].count);
if (!ap) {
av_log(s->avctx, AV_LOG_ERROR, ""Error allocating temporary buffer\n"");
return AVERROR(ENOMEM);
}
bytestream2_get_bufferu(&s->gb, ap, s->geotags[i].count);
ap[s->geotags[i].count - 1] = '\0';                     s->geotags[i].val = ap;
}
}
}
break;
case TIFF_ARTIST:
ADD_METADATA(count, ""artist"", NULL);
break;
case TIFF_COPYRIGHT:
ADD_METADATA(count, ""copyright"", NULL);
break;
case TIFF_DATE:
ADD_METADATA(count, ""date"", NULL);
break;
case TIFF_DOCUMENT_NAME:
ADD_METADATA(count, ""document_name"", NULL);
break;
case TIFF_HOST_COMPUTER:
ADD_METADATA(count, ""computer"", NULL);
break;
case TIFF_IMAGE_DESCRIPTION:
ADD_METADATA(count, ""description"", NULL);
break;
case TIFF_MAKE:
ADD_METADATA(count, ""make"", NULL);
break;
case TIFF_MODEL:
ADD_METADATA(count, ""model"", NULL);
break;
case TIFF_PAGE_NAME:
ADD_METADATA(count, ""page_name"", NULL);
break;
case TIFF_PAGE_NUMBER:
ADD_METADATA(count, ""page_number"", "" / "");
break;
case TIFF_SOFTWARE_NAME:
ADD_METADATA(count, ""software"", NULL);
break;
default:
if (s->avctx->err_recognition & AV_EF_EXPLODE) {
av_log(s->avctx, AV_LOG_ERROR,
""Unknown or unsupported tag %d/0X%0X\n"",
tag, tag);
return AVERROR_INVALIDDATA;
}
}
end:
if (s->bpp > 64U) {
av_log(s->avctx, AV_LOG_ERROR,
""This format is not supported (bpp=%d, %d components)\n"",
s->bpp, count);
s->bpp = 0;
return AVERROR_INVALIDDATA;
}
bytestream2_seek(&s->gb, start, SEEK_SET);
return 0;
}","static int tiff_decode_tag(TiffContext *VAR_0, AVFrame *VAR_1)
{
unsigned VAR_2, VAR_3, VAR_4, VAR_5, VAR_6 = 0, VAR_7 = 0;
int VAR_8, VAR_9;
int VAR_10;
int VAR_11;
double *VAR_12;
VAR_11 = ff_tread_tag(&VAR_0->gb, VAR_0->le, &VAR_2, &VAR_3, &VAR_4, &VAR_9);
if (VAR_11 < 0) {
goto end;
}
VAR_5 = bytestream2_tell(&VAR_0->gb);
if (VAR_4 == 1) {
switch (VAR_3) {
case VAR_13:
case VAR_14:
case VAR_15:
VAR_6 = ff_tget(&VAR_0->gb, VAR_3, VAR_0->le);
break;
case VAR_16:
VAR_6  = ff_tget(&VAR_0->gb, VAR_15, VAR_0->le);
VAR_7 = ff_tget(&VAR_0->gb, VAR_15, VAR_0->le);
break;
case VAR_17:
if (VAR_4 <= 4) {
break;
}
default:
VAR_6 = VAR_18;
}
}
switch (VAR_2) {
case VAR_19:
VAR_0->width = VAR_6;
break;
case VAR_20:
VAR_0->height = VAR_6;
break;
case VAR_21:
if (VAR_4 > 4U) {
av_log(VAR_0->avctx, VAR_22,
""This format is not supported (bpp=%d, %d components)\n"",
VAR_6, VAR_4);
return VAR_23;
}
VAR_0->bppcount = VAR_4;
if (VAR_4 == 1)
VAR_0->bpp = VAR_6;
else {
switch (VAR_3) {
case VAR_13:
case VAR_14:
case VAR_15:
VAR_0->bpp = 0;
if (bytestream2_get_bytes_left(&VAR_0->gb) < VAR_24[VAR_3] * VAR_4)
return VAR_23;
for (VAR_8 = 0; VAR_8 < VAR_4; VAR_8++)
VAR_0->bpp += ff_tget(&VAR_0->gb, VAR_3, VAR_0->le);
break;
default:
VAR_0->bpp = -1;
}
}
break;
case VAR_25:
if (VAR_4 != 1) {
av_log(VAR_0->avctx, VAR_22,
""Samples per pixel requires a single value, many provided\n"");
return VAR_23;
}
if (VAR_6 > 4U) {
av_log(VAR_0->avctx, VAR_22,
""Samples per pixel %d is too large\n"", VAR_6);
return VAR_23;
}
if (VAR_0->bppcount == 1)
VAR_0->bpp *= VAR_6;
VAR_0->bppcount = VAR_6;
break;
case VAR_26:
VAR_0->compr     = VAR_6;
VAR_0->predictor = 0;
switch (VAR_0->compr) {
case VAR_27:
case VAR_28:
case VAR_29:
case VAR_30:
break;
case VAR_31:
case VAR_32:
VAR_0->fax_opts = 0;
break;
case VAR_33:
case VAR_34:
#if VAR_35
break;
#else
av_log(VAR_0->avctx, VAR_22, ""Deflate: ZLib not compiled in\n"");
return AVERROR(VAR_36);
#endif
case VAR_37:
case VAR_38:
avpriv_report_missing_feature(VAR_0->avctx, ""JPEG compression"");
return VAR_39;
case VAR_40:
#if VAR_41
break;
#else
av_log(VAR_0->avctx, VAR_22, ""LZMA not compiled in\n"");
return AVERROR(VAR_36);
#endif
default:
av_log(VAR_0->avctx, VAR_22, ""Unknown compression method %i\n"",
VAR_0->compr);
return VAR_23;
}
break;
case VAR_42:
if (!VAR_6 || (VAR_3 == VAR_15 && VAR_6 == VAR_18))
VAR_6 = VAR_0->height;
VAR_0->rps = FFMIN(VAR_6, VAR_0->height);
break;
case VAR_43:
if (VAR_4 == 1) {
VAR_0->strippos = 0;
VAR_0->stripoff = VAR_6;
} else
VAR_0->strippos = VAR_5;
VAR_0->strips = VAR_4;
if (VAR_0->strips == 1)
VAR_0->rps = VAR_0->height;
VAR_0->sot = VAR_3;
break;
case VAR_44:
if (VAR_4 == 1) {
VAR_0->stripsizesoff = 0;
VAR_0->stripsize     = VAR_6;
VAR_0->strips        = 1;
} else {
VAR_0->stripsizesoff = VAR_5;
}
VAR_0->strips = VAR_4;
VAR_0->sstype = VAR_3;
break;
case VAR_45:
case VAR_46:
set_sar(VAR_0, VAR_2, VAR_6, VAR_7);
break;
case VAR_47:
case VAR_48:
case VAR_49:
case VAR_50:
av_log(VAR_0->avctx, VAR_22, ""Tiled images are not supported\n"");
return VAR_39;
break;
case VAR_51:
VAR_0->predictor = VAR_6;
break;
case VAR_52:
switch (VAR_6) {
case VAR_53:
case VAR_54:
case VAR_55:
case VAR_56:
case VAR_57:
VAR_0->photometric = VAR_6;
break;
case VAR_58:
case VAR_59:
case VAR_60:
case VAR_61:
case VAR_62:
case VAR_63:
case VAR_64:
case VAR_65:
case VAR_66:
avpriv_report_missing_feature(VAR_0->avctx,
""PhotometricInterpretation 0x%04X"",
VAR_6);
return VAR_39;
default:
av_log(VAR_0->avctx, VAR_22, ""PhotometricInterpretation %u is ""
""unknown\n"", VAR_6);
return VAR_23;
}
break;
case VAR_67:
if (VAR_6 < 1 || VAR_6 > 2) {
av_log(VAR_0->avctx, VAR_22,
""Unknown FillOrder value %d, trying default one\n"", VAR_6);
VAR_6 = 1;
}
VAR_0->fill_order = VAR_6 - 1;
break;
case VAR_68: {
GetByteContext VAR_69[3];
VAR_5 = VAR_24[VAR_3];
if (VAR_4 / 3 > 256 ||
bytestream2_get_bytes_left(&VAR_0->gb) < VAR_4 / 3 * VAR_5 * 3)
return VAR_23;
VAR_69[0] = VAR_69[1] = VAR_69[2] = VAR_0->gb;
bytestream2_skip(&VAR_69[1], VAR_4 / 3 * VAR_5);
bytestream2_skip(&VAR_69[2], VAR_4 / 3 * VAR_5 * 2);
VAR_5 = (VAR_24[VAR_3] - 1) << 3;
for (VAR_8 = 0; VAR_8 < VAR_4 / 3; VAR_8++) {
uint32_t VAR_70 = 0xFF000000;
VAR_70 |= (ff_tget(&VAR_69[0], VAR_3, VAR_0->le) >> VAR_5) << 16;
VAR_70 |= (ff_tget(&VAR_69[1], VAR_3, VAR_0->le) >> VAR_5) << 8;
VAR_70 |=  ff_tget(&VAR_69[2], VAR_3, VAR_0->le) >> VAR_5;
VAR_0->palette[VAR_8] = VAR_70;
}
VAR_0->palette_is_set = 1;
break;
}
case VAR_71:
VAR_0->planar = VAR_6 == 2;
break;
case VAR_72:
if (VAR_4 != 2) {
av_log(VAR_0->avctx, VAR_22, ""subsample count invalid\n"");
return VAR_23;
}
for (VAR_8 = 0; VAR_8 < VAR_4; VAR_8++)
VAR_0->subsampling[VAR_8] = ff_tget(&VAR_0->gb, VAR_3, VAR_0->le);
break;
case VAR_73:
if (VAR_0->compr == VAR_31)
VAR_0->fax_opts = VAR_6;
break;
case VAR_74:
if (VAR_0->compr == VAR_32)
VAR_0->fax_opts = VAR_6;
break;
#define ADD_METADATA(VAR_4, VAR_75, VAR_76)\
if ((ret = add_metadata(count, type, name, sep, s, frame)) < 0) {\
av_log(s->avctx, AV_LOG_ERROR, ""Error allocating temporary buffer\n"");\
goto end;\
}
case VAR_77:
ADD_METADATA(VAR_4, ""ModelPixelScaleTag"", NULL);
break;
case VAR_78:
ADD_METADATA(VAR_4, ""ModelTransformationTag"", NULL);
break;
case VAR_79:
ADD_METADATA(VAR_4, ""ModelTiepointTag"", NULL);
break;
case VAR_80:
ADD_METADATA(1, ""GeoTIFF_Version"", NULL);
ADD_METADATA(2, ""GeoTIFF_Key_Revision"", ""."");
VAR_0->geotag_count   = ff_tget_short(&VAR_0->gb, VAR_0->le);
if (VAR_0->geotag_count > VAR_4 / 4 - 1) {
VAR_0->geotag_count = VAR_4 / 4 - 1;
av_log(VAR_0->avctx, VAR_81, ""GeoTIFF key directory buffer shorter than specified\n"");
}
if (bytestream2_get_bytes_left(&VAR_0->gb) < VAR_0->geotag_count * sizeof(int16_t) * 4) {
VAR_0->geotag_count = 0;
return -1;
}
VAR_0->geotags = av_mallocz_array(VAR_0->geotag_count, sizeof(VAR_82));
if (!VAR_0->geotags) {
av_log(VAR_0->avctx, VAR_22, ""Error allocating temporary buffer\n"");
VAR_0->geotag_count = 0;
goto end;
}
for (VAR_8 = 0; VAR_8 < VAR_0->geotag_count; VAR_8++) {
VAR_0->geotags[VAR_8].key    = ff_tget_short(&VAR_0->gb, VAR_0->le);
VAR_0->geotags[VAR_8].type   = ff_tget_short(&VAR_0->gb, VAR_0->le);
VAR_0->geotags[VAR_8].count  = ff_tget_short(&VAR_0->gb, VAR_0->le);
if (!VAR_0->geotags[VAR_8].type)
VAR_0->geotags[VAR_8].val  = get_geokey_val(VAR_0->geotags[VAR_8].key, ff_tget_short(&VAR_0->gb, VAR_0->le));
else
VAR_0->geotags[VAR_8].offset = ff_tget_short(&VAR_0->gb, VAR_0->le);
}
break;
case VAR_83:
if (VAR_4 >= VAR_84 / sizeof(int64_t))
return VAR_23;
if (bytestream2_get_bytes_left(&VAR_0->gb) < VAR_4 * sizeof(int64_t))
return VAR_23;
VAR_12 = av_malloc_array(VAR_4, sizeof(double));
if (!VAR_12) {
av_log(VAR_0->avctx, VAR_22, ""Error allocating temporary buffer\n"");
goto end;
}
for (VAR_8 = 0; VAR_8 < VAR_4; VAR_8++)
VAR_12[VAR_8] = ff_tget_double(&VAR_0->gb, VAR_0->le);
for (VAR_8 = 0; VAR_8 < VAR_0->geotag_count; VAR_8++) {
if (VAR_0->geotags[VAR_8].type == VAR_83) {
if (VAR_0->geotags[VAR_8].count == 0
|| VAR_0->geotags[VAR_8].offset + VAR_0->geotags[VAR_8].count > VAR_4) {
av_log(VAR_0->avctx, VAR_81, ""Invalid GeoTIFF key %d\n"", VAR_0->geotags[VAR_8].key);
} else {
char *VAR_85 = doubles2str(&VAR_12[VAR_0->geotags[VAR_8].offset], VAR_0->geotags[VAR_8].count, "", "");
if (!VAR_85) {
av_log(VAR_0->avctx, VAR_22, ""Error allocating temporary buffer\n"");
av_freep(&VAR_12);
return AVERROR(VAR_86);
}
VAR_0->geotags[VAR_8].val = VAR_85;
}
}
}
av_freep(&VAR_12);
break;
case VAR_87:
VAR_10 = bytestream2_tell(&VAR_0->gb);
for (VAR_8 = 0; VAR_8 < VAR_0->geotag_count; VAR_8++) {
if (VAR_0->geotags[VAR_8].type == VAR_87) {
if (VAR_0->geotags[VAR_8].count == 0
|| VAR_0->geotags[VAR_8].offset +  VAR_0->geotags[VAR_8].count > VAR_4) {
av_log(VAR_0->avctx, VAR_81, ""Invalid GeoTIFF key %d\n"", VAR_0->geotags[VAR_8].key);
} else {
char *VAR_85;
bytestream2_seek(&VAR_0->gb, VAR_10 + VAR_0->geotags[VAR_8].offset, VAR_88);
if (bytestream2_get_bytes_left(&VAR_0->gb) < VAR_0->geotags[VAR_8].count)
return VAR_23;
VAR_85 = av_malloc(VAR_0->geotags[VAR_8].count);
if (!VAR_85) {
av_log(VAR_0->avctx, VAR_22, ""Error allocating temporary buffer\n"");
return AVERROR(VAR_86);
}
bytestream2_get_bufferu(&VAR_0->gb, VAR_85, VAR_0->geotags[VAR_8].count);
VAR_85[VAR_0->geotags[VAR_8].count - 1] = '\0'; 
VAR_0->geotags[VAR_8].val = VAR_85;
}
}
}
break;
case VAR_89:
ADD_METADATA(VAR_4, ""artist"", NULL);
break;
case VAR_90:
ADD_METADATA(VAR_4, ""copyright"", NULL);
break;
case VAR_91:
ADD_METADATA(VAR_4, ""date"", NULL);
break;
case VAR_92:
ADD_METADATA(VAR_4, ""document_name"", NULL);
break;
case VAR_93:
ADD_METADATA(VAR_4, ""computer"", NULL);
break;
case VAR_94:
ADD_METADATA(VAR_4, ""description"", NULL);
break;
case VAR_95:
ADD_METADATA(VAR_4, ""make"", NULL);
break;
case VAR_96:
ADD_METADATA(VAR_4, ""model"", NULL);
break;
case VAR_97:
ADD_METADATA(VAR_4, ""page_name"", NULL);
break;
case VAR_98:
ADD_METADATA(VAR_4, ""page_number"", "" / "");
break;
case VAR_99:
ADD_METADATA(VAR_4, ""software"", NULL);
break;
default:
if (VAR_0->avctx->err_recognition & VAR_100) {
av_log(VAR_0->avctx, VAR_22,
""Unknown or unsupported tag %d/0X%0X\n"",
VAR_2, VAR_2);
return VAR_23;
}
}
end:
if (VAR_0->bpp > 64U) {
av_log(VAR_0->avctx, VAR_22,
""This format is not supported (bpp=%d, %d components)\n"",
VAR_0->bpp, VAR_4);
VAR_0->bpp = 0;
return VAR_23;
}
bytestream2_seek(&VAR_0->gb, VAR_9, VAR_88);
return 0;
}",ffmpeg/89f464e9c229006e16f6bb5403c5529fdd0a9edd/tiff.c/vul/before/0.json,"static int tiff_decode_tag(TiffContext *s, AVFrame *frame)
{
    unsigned tag, type, count, off, value = 0, value2 = 0;
    int i, start;
    int pos;
    int ret;
    double *dp;

    ret = ff_tread_tag(&s->gb, s->le, &tag, &type, &count, &start);
    if (ret < 0) {
        goto end;
    }

    off = bytestream2_tell(&s->gb);
    if (count == 1) {
        switch (type) {
        case TIFF_BYTE:
        case TIFF_SHORT:
        case TIFF_LONG:
            value = ff_tget(&s->gb, type, s->le);
            break;
        case TIFF_RATIONAL:
            value  = ff_tget(&s->gb, TIFF_LONG, s->le);
            value2 = ff_tget(&s->gb, TIFF_LONG, s->le);
            break;
        case TIFF_STRING:
            if (count <= 4) {
                break;
            }
        default:
            value = UINT_MAX;
        }
    }

    switch (tag) {
    case TIFF_WIDTH:
        s->width = value;
        break;
    case TIFF_HEIGHT:
        s->height = value;
        break;
    case TIFF_BPP:
        if (count > 4U) {
            av_log(s->avctx, AV_LOG_ERROR,
                   ""This format is not supported (bpp=%d, %d components)\n"",
                   value, count);
            return AVERROR_INVALIDDATA;
        }
        s->bppcount = count;
        if (count == 1)
            s->bpp = value;
        else {
            switch (type) {
            case TIFF_BYTE:
            case TIFF_SHORT:
            case TIFF_LONG:
                s->bpp = 0;
                if (bytestream2_get_bytes_left(&s->gb) < type_sizes[type] * count)
                    return AVERROR_INVALIDDATA;
                for (i = 0; i < count; i++)
                    s->bpp += ff_tget(&s->gb, type, s->le);
                break;
            default:
                s->bpp = -1;
            }
        }
        break;
    case TIFF_SAMPLES_PER_PIXEL:
        if (count != 1) {
            av_log(s->avctx, AV_LOG_ERROR,
                   ""Samples per pixel requires a single value, many provided\n"");
            return AVERROR_INVALIDDATA;
        }
        if (value > 4U) {
            av_log(s->avctx, AV_LOG_ERROR,
                   ""Samples per pixel %d is too large\n"", value);
            return AVERROR_INVALIDDATA;
        }
        if (s->bppcount == 1)
            s->bpp *= value;
        s->bppcount = value;
        break;
    case TIFF_COMPR:
        s->compr     = value;
        s->predictor = 0;
        switch (s->compr) {
        case TIFF_RAW:
        case TIFF_PACKBITS:
        case TIFF_LZW:
        case TIFF_CCITT_RLE:
            break;
        case TIFF_G3:
        case TIFF_G4:
            s->fax_opts = 0;
            break;
        case TIFF_DEFLATE:
        case TIFF_ADOBE_DEFLATE:
#if CONFIG_ZLIB
            break;
#else
            av_log(s->avctx, AV_LOG_ERROR, ""Deflate: ZLib not compiled in\n"");
            return AVERROR(ENOSYS);
#endif
        case TIFF_JPEG:
        case TIFF_NEWJPEG:
            avpriv_report_missing_feature(s->avctx, ""JPEG compression"");
            return AVERROR_PATCHWELCOME;
        case TIFF_LZMA:
#if CONFIG_LZMA
            break;
#else
            av_log(s->avctx, AV_LOG_ERROR, ""LZMA not compiled in\n"");
            return AVERROR(ENOSYS);
#endif
        default:
            av_log(s->avctx, AV_LOG_ERROR, ""Unknown compression method %i\n"",
                   s->compr);
            return AVERROR_INVALIDDATA;
        }
        break;
    case TIFF_ROWSPERSTRIP:
        if (!value || (type == TIFF_LONG && value == UINT_MAX))
            value = s->height;
        s->rps = FFMIN(value, s->height);
        break;
    case TIFF_STRIP_OFFS:
        if (count == 1) {
            s->strippos = 0;
            s->stripoff = value;
        } else
            s->strippos = off;
        s->strips = count;
        if (s->strips == 1)
            s->rps = s->height;
        s->sot = type;
        break;
    case TIFF_STRIP_SIZE:
        if (count == 1) {
            s->stripsizesoff = 0;
            s->stripsize     = value;
            s->strips        = 1;
        } else {
            s->stripsizesoff = off;
        }
        s->strips = count;
        s->sstype = type;
        break;
    case TIFF_XRES:
    case TIFF_YRES:
        set_sar(s, tag, value, value2);
        break;
    case TIFF_TILE_BYTE_COUNTS:
    case TIFF_TILE_LENGTH:
    case TIFF_TILE_OFFSETS:
    case TIFF_TILE_WIDTH:
        av_log(s->avctx, AV_LOG_ERROR, ""Tiled images are not supported\n"");
        return AVERROR_PATCHWELCOME;
        break;
    case TIFF_PREDICTOR:
        s->predictor = value;
        break;
    case TIFF_PHOTOMETRIC:
        switch (value) {
        case TIFF_PHOTOMETRIC_WHITE_IS_ZERO:
        case TIFF_PHOTOMETRIC_BLACK_IS_ZERO:
        case TIFF_PHOTOMETRIC_RGB:
        case TIFF_PHOTOMETRIC_PALETTE:
        case TIFF_PHOTOMETRIC_YCBCR:
            s->photometric = value;
            break;
        case TIFF_PHOTOMETRIC_ALPHA_MASK:
        case TIFF_PHOTOMETRIC_SEPARATED:
        case TIFF_PHOTOMETRIC_CIE_LAB:
        case TIFF_PHOTOMETRIC_ICC_LAB:
        case TIFF_PHOTOMETRIC_ITU_LAB:
        case TIFF_PHOTOMETRIC_CFA:
        case TIFF_PHOTOMETRIC_LOG_L:
        case TIFF_PHOTOMETRIC_LOG_LUV:
        case TIFF_PHOTOMETRIC_LINEAR_RAW:
            avpriv_report_missing_feature(s->avctx,
                                          ""PhotometricInterpretation 0x%04X"",
                                          value);
            return AVERROR_PATCHWELCOME;
        default:
            av_log(s->avctx, AV_LOG_ERROR, ""PhotometricInterpretation %u is ""
                   ""unknown\n"", value);
            return AVERROR_INVALIDDATA;
        }
        break;
    case TIFF_FILL_ORDER:
        if (value < 1 || value > 2) {
            av_log(s->avctx, AV_LOG_ERROR,
                   ""Unknown FillOrder value %d, trying default one\n"", value);
            value = 1;
        }
        s->fill_order = value - 1;
        break;
    case TIFF_PAL: {
        GetByteContext pal_gb[3];
        off = type_sizes[type];
        if (count / 3 > 256 ||
            bytestream2_get_bytes_left(&s->gb) < count / 3 * off * 3)
            return AVERROR_INVALIDDATA;

        pal_gb[0] = pal_gb[1] = pal_gb[2] = s->gb;
        bytestream2_skip(&pal_gb[1], count / 3 * off);
        bytestream2_skip(&pal_gb[2], count / 3 * off * 2);

        off = (type_sizes[type] - 1) << 3;
        for (i = 0; i < count / 3; i++) {
            uint32_t p = 0xFF000000;
            p |= (ff_tget(&pal_gb[0], type, s->le) >> off) << 16;
            p |= (ff_tget(&pal_gb[1], type, s->le) >> off) << 8;
            p |=  ff_tget(&pal_gb[2], type, s->le) >> off;
            s->palette[i] = p;
        }
        s->palette_is_set = 1;
        break;
    }
    case TIFF_PLANAR:
        s->planar = value == 2;
        break;
    case TIFF_YCBCR_SUBSAMPLING:
        if (count != 2) {
            av_log(s->avctx, AV_LOG_ERROR, ""subsample count invalid\n"");
            return AVERROR_INVALIDDATA;
        }
        for (i = 0; i < count; i++) {
            s->subsampling[i] = ff_tget(&s->gb, type, s->le);
            if (s->subsampling[i] <= 0) {
                av_log(s->avctx, AV_LOG_ERROR, ""subsampling %d is invalid\n"", s->subsampling[i]);
                return AVERROR_INVALIDDATA;
            }
        }
        break;
    case TIFF_T4OPTIONS:
        if (s->compr == TIFF_G3)
            s->fax_opts = value;
        break;
    case TIFF_T6OPTIONS:
        if (s->compr == TIFF_G4)
            s->fax_opts = value;
        break;
#define ADD_METADATA(count, name, sep)\
    if ((ret = add_metadata(count, type, name, sep, s, frame)) < 0) {\
        av_log(s->avctx, AV_LOG_ERROR, ""Error allocating temporary buffer\n"");\
        goto end;\
    }
    case TIFF_MODEL_PIXEL_SCALE:
        ADD_METADATA(count, ""ModelPixelScaleTag"", NULL);
        break;
    case TIFF_MODEL_TRANSFORMATION:
        ADD_METADATA(count, ""ModelTransformationTag"", NULL);
        break;
    case TIFF_MODEL_TIEPOINT:
        ADD_METADATA(count, ""ModelTiepointTag"", NULL);
        break;
    case TIFF_GEO_KEY_DIRECTORY:
        ADD_METADATA(1, ""GeoTIFF_Version"", NULL);
        ADD_METADATA(2, ""GeoTIFF_Key_Revision"", ""."");
        s->geotag_count   = ff_tget_short(&s->gb, s->le);
        if (s->geotag_count > count / 4 - 1) {
            s->geotag_count = count / 4 - 1;
            av_log(s->avctx, AV_LOG_WARNING, ""GeoTIFF key directory buffer shorter than specified\n"");
        }
        if (bytestream2_get_bytes_left(&s->gb) < s->geotag_count * sizeof(int16_t) * 4) {
            s->geotag_count = 0;
            return -1;
        }
        s->geotags = av_mallocz_array(s->geotag_count, sizeof(TiffGeoTag));
        if (!s->geotags) {
            av_log(s->avctx, AV_LOG_ERROR, ""Error allocating temporary buffer\n"");
            s->geotag_count = 0;
            goto end;
        }
        for (i = 0; i < s->geotag_count; i++) {
            s->geotags[i].key    = ff_tget_short(&s->gb, s->le);
            s->geotags[i].type   = ff_tget_short(&s->gb, s->le);
            s->geotags[i].count  = ff_tget_short(&s->gb, s->le);

            if (!s->geotags[i].type)
                s->geotags[i].val  = get_geokey_val(s->geotags[i].key, ff_tget_short(&s->gb, s->le));
            else
                s->geotags[i].offset = ff_tget_short(&s->gb, s->le);
        }
        break;
    case TIFF_GEO_DOUBLE_PARAMS:
        if (count >= INT_MAX / sizeof(int64_t))
            return AVERROR_INVALIDDATA;
        if (bytestream2_get_bytes_left(&s->gb) < count * sizeof(int64_t))
            return AVERROR_INVALIDDATA;
        dp = av_malloc_array(count, sizeof(double));
        if (!dp) {
            av_log(s->avctx, AV_LOG_ERROR, ""Error allocating temporary buffer\n"");
            goto end;
        }
        for (i = 0; i < count; i++)
            dp[i] = ff_tget_double(&s->gb, s->le);
        for (i = 0; i < s->geotag_count; i++) {
            if (s->geotags[i].type == TIFF_GEO_DOUBLE_PARAMS) {
                if (s->geotags[i].count == 0
                    || s->geotags[i].offset + s->geotags[i].count > count) {
                    av_log(s->avctx, AV_LOG_WARNING, ""Invalid GeoTIFF key %d\n"", s->geotags[i].key);
                } else {
                    char *ap = doubles2str(&dp[s->geotags[i].offset], s->geotags[i].count, "", "");
                    if (!ap) {
                        av_log(s->avctx, AV_LOG_ERROR, ""Error allocating temporary buffer\n"");
                        av_freep(&dp);
                        return AVERROR(ENOMEM);
                    }
                    s->geotags[i].val = ap;
                }
            }
        }
        av_freep(&dp);
        break;
    case TIFF_GEO_ASCII_PARAMS:
        pos = bytestream2_tell(&s->gb);
        for (i = 0; i < s->geotag_count; i++) {
            if (s->geotags[i].type == TIFF_GEO_ASCII_PARAMS) {
                if (s->geotags[i].count == 0
                    || s->geotags[i].offset +  s->geotags[i].count > count) {
                    av_log(s->avctx, AV_LOG_WARNING, ""Invalid GeoTIFF key %d\n"", s->geotags[i].key);
                } else {
                    char *ap;

                    bytestream2_seek(&s->gb, pos + s->geotags[i].offset, SEEK_SET);
                    if (bytestream2_get_bytes_left(&s->gb) < s->geotags[i].count)
                        return AVERROR_INVALIDDATA;
                    ap = av_malloc(s->geotags[i].count);
                    if (!ap) {
                        av_log(s->avctx, AV_LOG_ERROR, ""Error allocating temporary buffer\n"");
                        return AVERROR(ENOMEM);
                    }
                    bytestream2_get_bufferu(&s->gb, ap, s->geotags[i].count);
                    ap[s->geotags[i].count - 1] = '\0'; //replace the ""|"" delimiter with a 0 byte
                    s->geotags[i].val = ap;
                }
            }
        }
        break;
    case TIFF_ARTIST:
        ADD_METADATA(count, ""artist"", NULL);
        break;
    case TIFF_COPYRIGHT:
        ADD_METADATA(count, ""copyright"", NULL);
        break;
    case TIFF_DATE:
        ADD_METADATA(count, ""date"", NULL);
        break;
    case TIFF_DOCUMENT_NAME:
        ADD_METADATA(count, ""document_name"", NULL);
        break;
    case TIFF_HOST_COMPUTER:
        ADD_METADATA(count, ""computer"", NULL);
        break;
    case TIFF_IMAGE_DESCRIPTION:
        ADD_METADATA(count, ""description"", NULL);
        break;
    case TIFF_MAKE:
        ADD_METADATA(count, ""make"", NULL);
        break;
    case TIFF_MODEL:
        ADD_METADATA(count, ""model"", NULL);
        break;
    case TIFF_PAGE_NAME:
        ADD_METADATA(count, ""page_name"", NULL);
        break;
    case TIFF_PAGE_NUMBER:
        ADD_METADATA(count, ""page_number"", "" / "");
        break;
    case TIFF_SOFTWARE_NAME:
        ADD_METADATA(count, ""software"", NULL);
        break;
    default:
        if (s->avctx->err_recognition & AV_EF_EXPLODE) {
            av_log(s->avctx, AV_LOG_ERROR,
                   ""Unknown or unsupported tag %d/0X%0X\n"",
                   tag, tag);
            return AVERROR_INVALIDDATA;
        }
    }
end:
    if (s->bpp > 64U) {
        av_log(s->avctx, AV_LOG_ERROR,
                ""This format is not supported (bpp=%d, %d components)\n"",
                s->bpp, count);
        s->bpp = 0;
        return AVERROR_INVALIDDATA;
    }
    bytestream2_seek(&s->gb, start, SEEK_SET);
    return 0;
}","static int tiff_decode_tag(TiffContext *VAR_0, AVFrame *VAR_1)
{
    unsigned VAR_2, VAR_3, VAR_4, VAR_5, VAR_6 = 0, VAR_7 = 0;
    int VAR_8, VAR_9;
    int VAR_10;
    int VAR_11;
    double *VAR_12;

    VAR_11 = ff_tread_tag(&VAR_0->gb, VAR_0->le, &VAR_2, &VAR_3, &VAR_4, &VAR_9);
    if (VAR_11 < 0) {
        goto end;
    }

    VAR_5 = bytestream2_tell(&VAR_0->gb);
    if (VAR_4 == 1) {
        switch (VAR_3) {
        case VAR_13:
        case VAR_14:
        case VAR_15:
            VAR_6 = ff_tget(&VAR_0->gb, VAR_3, VAR_0->le);
            break;
        case VAR_16:
            VAR_6  = ff_tget(&VAR_0->gb, VAR_15, VAR_0->le);
            VAR_7 = ff_tget(&VAR_0->gb, VAR_15, VAR_0->le);
            break;
        case VAR_17:
            if (VAR_4 <= 4) {
                break;
            }
        default:
            VAR_6 = VAR_18;
        }
    }

    switch (VAR_2) {
    case VAR_19:
        VAR_0->width = VAR_6;
        break;
    case VAR_20:
        VAR_0->height = VAR_6;
        break;
    case VAR_21:
        if (VAR_4 > 4U) {
            av_log(VAR_0->avctx, VAR_22,
                   ""This format is not supported (bpp=%d, %d components)\n"",
                   VAR_6, VAR_4);
            return VAR_23;
        }
        VAR_0->bppcount = VAR_4;
        if (VAR_4 == 1)
            VAR_0->bpp = VAR_6;
        else {
            switch (VAR_3) {
            case VAR_13:
            case VAR_14:
            case VAR_15:
                VAR_0->bpp = 0;
                if (bytestream2_get_bytes_left(&VAR_0->gb) < VAR_24[VAR_3] * VAR_4)
                    return VAR_23;
                for (VAR_8 = 0; VAR_8 < VAR_4; VAR_8++)
                    VAR_0->bpp += ff_tget(&VAR_0->gb, VAR_3, VAR_0->le);
                break;
            default:
                VAR_0->bpp = -1;
            }
        }
        break;
    case VAR_25:
        if (VAR_4 != 1) {
            av_log(VAR_0->avctx, VAR_22,
                   ""Samples per pixel requires a single value, many provided\n"");
            return VAR_23;
        }
        if (VAR_6 > 4U) {
            av_log(VAR_0->avctx, VAR_22,
                   ""Samples per pixel %d is too large\n"", VAR_6);
            return VAR_23;
        }
        if (VAR_0->bppcount == 1)
            VAR_0->bpp *= VAR_6;
        VAR_0->bppcount = VAR_6;
        break;
    case VAR_26:
        VAR_0->compr     = VAR_6;
        VAR_0->predictor = 0;
        switch (VAR_0->compr) {
        case VAR_27:
        case VAR_28:
        case VAR_29:
        case VAR_30:
            break;
        case VAR_31:
        case VAR_32:
            VAR_0->fax_opts = 0;
            break;
        case VAR_33:
        case VAR_34:
#if VAR_35
            break;
#else
            av_log(VAR_0->avctx, VAR_22, ""Deflate: ZLib not compiled in\n"");
            return AVERROR(VAR_36);
#endif
        case VAR_37:
        case VAR_38:
            avpriv_report_missing_feature(VAR_0->avctx, ""JPEG compression"");
            return VAR_39;
        case VAR_40:
#if VAR_41
            break;
#else
            av_log(VAR_0->avctx, VAR_22, ""LZMA not compiled in\n"");
            return AVERROR(VAR_36);
#endif
        default:
            av_log(VAR_0->avctx, VAR_22, ""Unknown compression method %i\n"",
                   VAR_0->compr);
            return VAR_23;
        }
        break;
    case VAR_42:
        if (!VAR_6 || (VAR_3 == VAR_15 && VAR_6 == VAR_18))
            VAR_6 = VAR_0->height;
        VAR_0->rps = FFMIN(VAR_6, VAR_0->height);
        break;
    case VAR_43:
        if (VAR_4 == 1) {
            VAR_0->strippos = 0;
            VAR_0->stripoff = VAR_6;
        } else
            VAR_0->strippos = VAR_5;
        VAR_0->strips = VAR_4;
        if (VAR_0->strips == 1)
            VAR_0->rps = VAR_0->height;
        VAR_0->sot = VAR_3;
        break;
    case VAR_44:
        if (VAR_4 == 1) {
            VAR_0->stripsizesoff = 0;
            VAR_0->stripsize     = VAR_6;
            VAR_0->strips        = 1;
        } else {
            VAR_0->stripsizesoff = VAR_5;
        }
        VAR_0->strips = VAR_4;
        VAR_0->sstype = VAR_3;
        break;
    case VAR_45:
    case VAR_46:
        set_sar(VAR_0, VAR_2, VAR_6, VAR_7);
        break;
    case VAR_47:
    case VAR_48:
    case VAR_49:
    case VAR_50:
        av_log(VAR_0->avctx, VAR_22, ""Tiled images are not supported\n"");
        return VAR_39;
        break;
    case VAR_51:
        VAR_0->predictor = VAR_6;
        break;
    case VAR_52:
        switch (VAR_6) {
        case VAR_53:
        case VAR_54:
        case VAR_55:
        case VAR_56:
        case VAR_57:
            VAR_0->photometric = VAR_6;
            break;
        case VAR_58:
        case VAR_59:
        case VAR_60:
        case VAR_61:
        case VAR_62:
        case VAR_63:
        case VAR_64:
        case VAR_65:
        case VAR_66:
            avpriv_report_missing_feature(VAR_0->avctx,
                                          ""PhotometricInterpretation 0x%04X"",
                                          VAR_6);
            return VAR_39;
        default:
            av_log(VAR_0->avctx, VAR_22, ""PhotometricInterpretation %u is ""
                   ""unknown\n"", VAR_6);
            return VAR_23;
        }
        break;
    case VAR_67:
        if (VAR_6 < 1 || VAR_6 > 2) {
            av_log(VAR_0->avctx, VAR_22,
                   ""Unknown FillOrder value %d, trying default one\n"", VAR_6);
            VAR_6 = 1;
        }
        VAR_0->fill_order = VAR_6 - 1;
        break;
    case VAR_68: {
        GetByteContext VAR_69[3];
        VAR_5 = VAR_24[VAR_3];
        if (VAR_4 / 3 > 256 ||
            bytestream2_get_bytes_left(&VAR_0->gb) < VAR_4 / 3 * VAR_5 * 3)
            return VAR_23;

        VAR_69[0] = VAR_69[1] = VAR_69[2] = VAR_0->gb;
        bytestream2_skip(&VAR_69[1], VAR_4 / 3 * VAR_5);
        bytestream2_skip(&VAR_69[2], VAR_4 / 3 * VAR_5 * 2);

        VAR_5 = (VAR_24[VAR_3] - 1) << 3;
        for (VAR_8 = 0; VAR_8 < VAR_4 / 3; VAR_8++) {
            uint32_t VAR_70 = 0xFF000000;
            VAR_70 |= (ff_tget(&VAR_69[0], VAR_3, VAR_0->le) >> VAR_5) << 16;
            VAR_70 |= (ff_tget(&VAR_69[1], VAR_3, VAR_0->le) >> VAR_5) << 8;
            VAR_70 |=  ff_tget(&VAR_69[2], VAR_3, VAR_0->le) >> VAR_5;
            VAR_0->palette[VAR_8] = VAR_70;
        }
        VAR_0->palette_is_set = 1;
        break;
    }
    case VAR_71:
        VAR_0->planar = VAR_6 == 2;
        break;
    case VAR_72:
        if (VAR_4 != 2) {
            av_log(VAR_0->avctx, VAR_22, ""subsample count invalid\n"");
            return VAR_23;
        }
        for (VAR_8 = 0; VAR_8 < VAR_4; VAR_8++) {
            VAR_0->subsampling[VAR_8] = ff_tget(&VAR_0->gb, VAR_3, VAR_0->le);
            if (VAR_0->subsampling[VAR_8] <= 0) {
                av_log(VAR_0->avctx, VAR_22, ""subsampling %d is invalid\n"", VAR_0->subsampling[VAR_8]);
                return VAR_23;
            }
        }
        break;
    case VAR_73:
        if (VAR_0->compr == VAR_31)
            VAR_0->fax_opts = VAR_6;
        break;
    case VAR_74:
        if (VAR_0->compr == VAR_32)
            VAR_0->fax_opts = VAR_6;
        break;
#define ADD_METADATA(VAR_4, VAR_75, VAR_76)\
    if ((ret = add_metadata(count, type, name, sep, s, frame)) < 0) {\
        av_log(s->avctx, AV_LOG_ERROR, ""Error allocating temporary buffer\n"");\
        goto end;\
    }
    case VAR_77:
        ADD_METADATA(VAR_4, ""ModelPixelScaleTag"", NULL);
        break;
    case VAR_78:
        ADD_METADATA(VAR_4, ""ModelTransformationTag"", NULL);
        break;
    case VAR_79:
        ADD_METADATA(VAR_4, ""ModelTiepointTag"", NULL);
        break;
    case VAR_80:
        ADD_METADATA(1, ""GeoTIFF_Version"", NULL);
        ADD_METADATA(2, ""GeoTIFF_Key_Revision"", ""."");
        VAR_0->geotag_count   = ff_tget_short(&VAR_0->gb, VAR_0->le);
        if (VAR_0->geotag_count > VAR_4 / 4 - 1) {
            VAR_0->geotag_count = VAR_4 / 4 - 1;
            av_log(VAR_0->avctx, VAR_81, ""GeoTIFF key directory buffer shorter than specified\n"");
        }
        if (bytestream2_get_bytes_left(&VAR_0->gb) < VAR_0->geotag_count * sizeof(int16_t) * 4) {
            VAR_0->geotag_count = 0;
            return -1;
        }
        VAR_0->geotags = av_mallocz_array(VAR_0->geotag_count, sizeof(VAR_82));
        if (!VAR_0->geotags) {
            av_log(VAR_0->avctx, VAR_22, ""Error allocating temporary buffer\n"");
            VAR_0->geotag_count = 0;
            goto end;
        }
        for (VAR_8 = 0; VAR_8 < VAR_0->geotag_count; VAR_8++) {
            VAR_0->geotags[VAR_8].key    = ff_tget_short(&VAR_0->gb, VAR_0->le);
            VAR_0->geotags[VAR_8].type   = ff_tget_short(&VAR_0->gb, VAR_0->le);
            VAR_0->geotags[VAR_8].count  = ff_tget_short(&VAR_0->gb, VAR_0->le);

            if (!VAR_0->geotags[VAR_8].type)
                VAR_0->geotags[VAR_8].val  = get_geokey_val(VAR_0->geotags[VAR_8].key, ff_tget_short(&VAR_0->gb, VAR_0->le));
            else
                VAR_0->geotags[VAR_8].offset = ff_tget_short(&VAR_0->gb, VAR_0->le);
        }
        break;
    case VAR_83:
        if (VAR_4 >= VAR_84 / sizeof(int64_t))
            return VAR_23;
        if (bytestream2_get_bytes_left(&VAR_0->gb) < VAR_4 * sizeof(int64_t))
            return VAR_23;
        VAR_12 = av_malloc_array(VAR_4, sizeof(double));
        if (!VAR_12) {
            av_log(VAR_0->avctx, VAR_22, ""Error allocating temporary buffer\n"");
            goto end;
        }
        for (VAR_8 = 0; VAR_8 < VAR_4; VAR_8++)
            VAR_12[VAR_8] = ff_tget_double(&VAR_0->gb, VAR_0->le);
        for (VAR_8 = 0; VAR_8 < VAR_0->geotag_count; VAR_8++) {
            if (VAR_0->geotags[VAR_8].type == VAR_83) {
                if (VAR_0->geotags[VAR_8].count == 0
                    || VAR_0->geotags[VAR_8].offset + VAR_0->geotags[VAR_8].count > VAR_4) {
                    av_log(VAR_0->avctx, VAR_81, ""Invalid GeoTIFF key %d\n"", VAR_0->geotags[VAR_8].key);
                } else {
                    char *VAR_85 = doubles2str(&VAR_12[VAR_0->geotags[VAR_8].offset], VAR_0->geotags[VAR_8].count, "", "");
                    if (!VAR_85) {
                        av_log(VAR_0->avctx, VAR_22, ""Error allocating temporary buffer\n"");
                        av_freep(&VAR_12);
                        return AVERROR(VAR_86);
                    }
                    VAR_0->geotags[VAR_8].val = VAR_85;
                }
            }
        }
        av_freep(&VAR_12);
        break;
    case VAR_87:
        VAR_10 = bytestream2_tell(&VAR_0->gb);
        for (VAR_8 = 0; VAR_8 < VAR_0->geotag_count; VAR_8++) {
            if (VAR_0->geotags[VAR_8].type == VAR_87) {
                if (VAR_0->geotags[VAR_8].count == 0
                    || VAR_0->geotags[VAR_8].offset +  VAR_0->geotags[VAR_8].count > VAR_4) {
                    av_log(VAR_0->avctx, VAR_81, ""Invalid GeoTIFF key %d\n"", VAR_0->geotags[VAR_8].key);
                } else {
                    char *VAR_85;

                    bytestream2_seek(&VAR_0->gb, VAR_10 + VAR_0->geotags[VAR_8].offset, VAR_88);
                    if (bytestream2_get_bytes_left(&VAR_0->gb) < VAR_0->geotags[VAR_8].count)
                        return VAR_23;
                    VAR_85 = av_malloc(VAR_0->geotags[VAR_8].count);
                    if (!VAR_85) {
                        av_log(VAR_0->avctx, VAR_22, ""Error allocating temporary buffer\n"");
                        return AVERROR(VAR_86);
                    }
                    bytestream2_get_bufferu(&VAR_0->gb, VAR_85, VAR_0->geotags[VAR_8].count);
                    VAR_85[VAR_0->geotags[VAR_8].count - 1] = '\0'; /* COMMENT_0 */
                    VAR_0->geotags[VAR_8].val = VAR_85;
                }
            }
        }
        break;
    case VAR_89:
        ADD_METADATA(VAR_4, ""artist"", NULL);
        break;
    case VAR_90:
        ADD_METADATA(VAR_4, ""copyright"", NULL);
        break;
    case VAR_91:
        ADD_METADATA(VAR_4, ""date"", NULL);
        break;
    case VAR_92:
        ADD_METADATA(VAR_4, ""document_name"", NULL);
        break;
    case VAR_93:
        ADD_METADATA(VAR_4, ""computer"", NULL);
        break;
    case VAR_94:
        ADD_METADATA(VAR_4, ""description"", NULL);
        break;
    case VAR_95:
        ADD_METADATA(VAR_4, ""make"", NULL);
        break;
    case VAR_96:
        ADD_METADATA(VAR_4, ""model"", NULL);
        break;
    case VAR_97:
        ADD_METADATA(VAR_4, ""page_name"", NULL);
        break;
    case VAR_98:
        ADD_METADATA(VAR_4, ""page_number"", "" / "");
        break;
    case VAR_99:
        ADD_METADATA(VAR_4, ""software"", NULL);
        break;
    default:
        if (VAR_0->avctx->err_recognition & VAR_100) {
            av_log(VAR_0->avctx, VAR_22,
                   ""Unknown or unsupported tag %d/0X%0X\n"",
                   VAR_2, VAR_2);
            return VAR_23;
        }
    }
end:
    if (VAR_0->bpp > 64U) {
        av_log(VAR_0->avctx, VAR_22,
                ""This format is not supported (bpp=%d, %d components)\n"",
                VAR_0->bpp, VAR_4);
        VAR_0->bpp = 0;
        return VAR_23;
    }
    bytestream2_seek(&VAR_0->gb, VAR_9, VAR_88);
    return 0;
}",ffmpeg/89f464e9c229006e16f6bb5403c5529fdd0a9edd/tiff.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -225,8 +225,13 @@
             av_log(s->avctx, AV_LOG_ERROR, ""subsample count invalid\n"");
             return AVERROR_INVALIDDATA;
         }
-        for (i = 0; i < count; i++)
+        for (i = 0; i < count; i++) {
             s->subsampling[i] = ff_tget(&s->gb, type, s->le);
+            if (s->subsampling[i] <= 0) {
+                av_log(s->avctx, AV_LOG_ERROR, ""subsampling %d is invalid\n"", s->subsampling[i]);
+                return AVERROR_INVALIDDATA;
+            }
+        }
         break;
     case TIFF_T4OPTIONS:
         if (s->compr == TIFF_G3)","{'deleted_lines': ['        for (i = 0; i < count; i++)'], 'added_lines': ['        for (i = 0; i < count; i++) {', '            if (s->subsampling[i] <= 0) {', '                av_log(s->avctx, AV_LOG_ERROR, ""subsampling %d is invalid\\n"", s->subsampling[i]);', '                return AVERROR_INVALIDDATA;', '            }', '        }']}",True,"libavcodec/tiff.c in FFmpeg before 2.8.6 does not properly validate RowsPerStrip values and YCbCr chrominance subsampling factors, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted TIFF file, related to the tiff_decode_tag and decode_frame functions.",8.8,HIGH,2,test,,5
CVE-2016-2329,['CWE-119'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ffmpeg,"
avcodec/tiff: Check subsample & rps values more completely

Fixes out of array access
Fixes: 83aedfb29af669c4d6e10f1bfad974d2/asan_heap-oob_1ab42fe_4984_9f6ec14462f8d8a00ea24b320572a963.tif

Found-by: Mateusz ""j00ru"" Jurczyk and Gynvael Coldwind
Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>
",89f464e9c229006e16f6bb5403c5529fdd0a9edd,http://git.videolan.org/?p=ffmpeg.git;a=commit;h=89f464e9c229006e16f6bb5403c5529fdd0a9edd,libavcodec/tiff.c,decode_frame,"static int decode_frame(AVCodecContext *avctx,
void *data, int *got_frame, AVPacket *avpkt)
{
TiffContext *const s = avctx->priv_data;
AVFrame *const p = data;
ThreadFrame frame = { .f = data };
unsigned off;
int le, ret, plane, planes;
int i, j, entries, stride;
unsigned soff, ssize;
uint8_t *dst;
GetByteContext stripsizes;
GetByteContext stripdata;
bytestream2_init(&s->gb, avpkt->data, avpkt->size);
if ((ret = ff_tdecode_header(&s->gb, &le, &off))) {
av_log(avctx, AV_LOG_ERROR, ""Invalid TIFF header\n"");
return ret;
} else if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {
av_log(avctx, AV_LOG_ERROR, ""IFD offset is greater than image size\n"");
return AVERROR_INVALIDDATA;
}
s->le          = le;
s->bppcount    = s->bpp = 1;
s->photometric = TIFF_PHOTOMETRIC_NONE;
s->compr       = TIFF_RAW;
s->fill_order  = 0;
free_geotags(s);
s->stripsizesoff = s->strippos = 0;
bytestream2_seek(&s->gb, off, SEEK_SET);
entries = ff_tget_short(&s->gb, le);
if (bytestream2_get_bytes_left(&s->gb) < entries * 12)
return AVERROR_INVALIDDATA;
for (i = 0; i < entries; i++) {
if ((ret = tiff_decode_tag(s, p)) < 0)
return ret;
}
for (i = 0; i<s->geotag_count; i++) {
const char *keyname = get_geokey_name(s->geotags[i].key);
if (!keyname) {
av_log(avctx, AV_LOG_WARNING, ""Unknown or unsupported GeoTIFF key %d\n"", s->geotags[i].key);
continue;
}
if (get_geokey_type(s->geotags[i].key) != s->geotags[i].type) {
av_log(avctx, AV_LOG_WARNING, ""Type of GeoTIFF key %d is wrong\n"", s->geotags[i].key);
continue;
}
ret = av_dict_set(avpriv_frame_get_metadatap(p), keyname, s->geotags[i].val, 0);
if (ret<0) {
av_log(avctx, AV_LOG_ERROR, ""Writing metadata with key '%s' failed\n"", keyname);
return ret;
}
}
if (!s->strippos && !s->stripoff) {
av_log(avctx, AV_LOG_ERROR, ""Image data is missing\n"");
return AVERROR_INVALIDDATA;
}
if ((ret = init_image(s, &frame)) < 0)
return ret;
if (s->strips == 1 && !s->stripsize) {
av_log(avctx, AV_LOG_WARNING, ""Image data size missing\n"");
s->stripsize = avpkt->size - s->stripoff;
}
if (s->stripsizesoff) {
if (s->stripsizesoff >= (unsigned)avpkt->size)
return AVERROR_INVALIDDATA;
bytestream2_init(&stripsizes, avpkt->data + s->stripsizesoff,
avpkt->size - s->stripsizesoff);
}
if (s->strippos) {
if (s->strippos >= (unsigned)avpkt->size)
return AVERROR_INVALIDDATA;
bytestream2_init(&stripdata, avpkt->data + s->strippos,
avpkt->size - s->strippos);
}
if (s->rps <= 0) {
av_log(avctx, AV_LOG_ERROR, ""rps %d invalid\n"", s->rps);
return AVERROR_INVALIDDATA;
}
planes = s->planar ? s->bppcount : 1;
for (plane = 0; plane < planes; plane++) {
stride = p->linesize[plane];
dst = p->data[plane];
for (i = 0; i < s->height; i += s->rps) {
if (s->stripsizesoff)
ssize = ff_tget(&stripsizes, s->sstype, le);
else
ssize = s->stripsize;
if (s->strippos)
soff = ff_tget(&stripdata, s->sot, le);
else
soff = s->stripoff;
if (soff > avpkt->size || ssize > avpkt->size - soff) {
av_log(avctx, AV_LOG_ERROR, ""Invalid strip size/offset\n"");
return AVERROR_INVALIDDATA;
}
if ((ret = tiff_unpack_strip(s, p, dst, stride, avpkt->data + soff, ssize, i,
FFMIN(s->rps, s->height - i))) < 0) {
if (avctx->err_recognition & AV_EF_EXPLODE)
return ret;
break;
}
dst += s->rps * stride;
}
if (s->predictor == 2) {
if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) {
av_log(s->avctx, AV_LOG_ERROR, ""predictor == 2 with YUV is unsupported"");
return AVERROR_PATCHWELCOME;
}
dst   = p->data[plane];
soff  = s->bpp >> 3;
if (s->planar)
soff  = FFMAX(soff / s->bppcount, 1);
ssize = s->width * soff;
if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48LE ||
s->avctx->pix_fmt == AV_PIX_FMT_RGBA64LE ||
s->avctx->pix_fmt == AV_PIX_FMT_GRAY16LE ||
s->avctx->pix_fmt == AV_PIX_FMT_YA16LE ||
s->avctx->pix_fmt == AV_PIX_FMT_GBRP16LE ||
s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16LE) {
for (i = 0; i < s->height; i++) {
for (j = soff; j < ssize; j += 2)
AV_WL16(dst + j, AV_RL16(dst + j) + AV_RL16(dst + j - soff));
dst += stride;
}
} else if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||
s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE ||
s->avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||
s->avctx->pix_fmt == AV_PIX_FMT_YA16BE ||
s->avctx->pix_fmt == AV_PIX_FMT_GBRP16BE ||
s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16BE) {
for (i = 0; i < s->height; i++) {
for (j = soff; j < ssize; j += 2)
AV_WB16(dst + j, AV_RB16(dst + j) + AV_RB16(dst + j - soff));
dst += stride;
}
} else {
for (i = 0; i < s->height; i++) {
for (j = soff; j < ssize; j++)
dst[j] += dst[j - soff];
dst += stride;
}
}
}
if (s->photometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) {
dst = p->data[plane];
for (i = 0; i < s->height; i++) {
for (j = 0; j < stride; j++)
dst[j] = (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 ? (1<<s->bpp) - 1 : 255) - dst[j];
dst += stride;
}
}
}
if (s->planar && s->bppcount > 2) {
FFSWAP(uint8_t*, p->data[0],     p->data[2]);
FFSWAP(int,      p->linesize[0], p->linesize[2]);
FFSWAP(uint8_t*, p->data[0],     p->data[1]);
FFSWAP(int,      p->linesize[0], p->linesize[1]);
}
*got_frame = 1;
return avpkt->size;
}","static int decode_frame(AVCodecContext *VAR_0,
void *VAR_1, int *VAR_2, AVPacket *VAR_3)
{
TiffContext *const VAR_4 = VAR_0->priv_data;
AVFrame *const VAR_5 = VAR_1;
ThreadFrame VAR_6 = { .f = VAR_1 };
unsigned VAR_7;
int VAR_8, VAR_9, VAR_10, VAR_11;
int VAR_12, VAR_13, VAR_14, VAR_15;
unsigned VAR_16, VAR_17;
uint8_t *VAR_18;
GetByteContext VAR_19;
GetByteContext VAR_20;
bytestream2_init(&VAR_4->gb, VAR_3->data, VAR_3->size);
if ((VAR_9 = ff_tdecode_header(&VAR_4->gb, &VAR_8, &VAR_7))) {
av_log(VAR_0, VAR_21, ""Invalid TIFF header\n"");
return VAR_9;
} else if (VAR_7 >= VAR_22 - 14 || VAR_3->size < VAR_7 + 14) {
av_log(VAR_0, VAR_21, ""IFD offset is greater than image size\n"");
return VAR_23;
}
VAR_4->le          = VAR_8;
VAR_4->bppcount    = VAR_4->bpp = 1;
VAR_4->photometric = VAR_24;
VAR_4->compr       = VAR_25;
VAR_4->fill_order  = 0;
free_geotags(VAR_4);
VAR_4->stripsizesoff = VAR_4->strippos = 0;
bytestream2_seek(&VAR_4->gb, VAR_7, VAR_26);
VAR_14 = ff_tget_short(&VAR_4->gb, VAR_8);
if (bytestream2_get_bytes_left(&VAR_4->gb) < VAR_14 * 12)
return VAR_23;
for (VAR_12 = 0; VAR_12 < VAR_14; VAR_12++) {
if ((VAR_9 = tiff_decode_tag(VAR_4, VAR_5)) < 0)
return VAR_9;
}
for (VAR_12 = 0; VAR_12<VAR_4->geotag_count; VAR_12++) {
const char *VAR_27 = get_geokey_name(VAR_4->geotags[VAR_12].key);
if (!VAR_27) {
av_log(VAR_0, VAR_28, ""Unknown or unsupported GeoTIFF key %d\n"", VAR_4->geotags[VAR_12].key);
continue;
}
if (get_geokey_type(VAR_4->geotags[VAR_12].key) != VAR_4->geotags[VAR_12].type) {
av_log(VAR_0, VAR_28, ""Type of GeoTIFF key %d is wrong\n"", VAR_4->geotags[VAR_12].key);
continue;
}
VAR_9 = av_dict_set(avpriv_frame_get_metadatap(VAR_5), VAR_27, VAR_4->geotags[VAR_12].val, 0);
if (VAR_9<0) {
av_log(VAR_0, VAR_21, ""Writing metadata with key '%s' failed\n"", VAR_27);
return VAR_9;
}
}
if (!VAR_4->strippos && !VAR_4->stripoff) {
av_log(VAR_0, VAR_21, ""Image data is missing\n"");
return VAR_23;
}
if ((VAR_9 = init_image(VAR_4, &VAR_6)) < 0)
return VAR_9;
if (VAR_4->strips == 1 && !VAR_4->stripsize) {
av_log(VAR_0, VAR_28, ""Image data size missing\n"");
VAR_4->stripsize = VAR_3->size - VAR_4->stripoff;
}
if (VAR_4->stripsizesoff) {
if (VAR_4->stripsizesoff >= (unsigned)VAR_3->size)
return VAR_23;
bytestream2_init(&VAR_19, VAR_3->data + VAR_4->stripsizesoff,
VAR_3->size - VAR_4->stripsizesoff);
}
if (VAR_4->strippos) {
if (VAR_4->strippos >= (unsigned)VAR_3->size)
return VAR_23;
bytestream2_init(&VAR_20, VAR_3->data + VAR_4->strippos,
VAR_3->size - VAR_4->strippos);
}
if (VAR_4->rps <= 0) {
av_log(VAR_0, VAR_21, ""rps %d invalid\n"", VAR_4->rps);
return VAR_23;
}
VAR_11 = VAR_4->planar ? VAR_4->bppcount : 1;
for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
VAR_15 = VAR_5->linesize[VAR_10];
VAR_18 = VAR_5->data[VAR_10];
for (VAR_12 = 0; VAR_12 < VAR_4->height; VAR_12 += VAR_4->rps) {
if (VAR_4->stripsizesoff)
VAR_17 = ff_tget(&VAR_19, VAR_4->sstype, VAR_8);
else
VAR_17 = VAR_4->stripsize;
if (VAR_4->strippos)
VAR_16 = ff_tget(&VAR_20, VAR_4->sot, VAR_8);
else
VAR_16 = VAR_4->stripoff;
if (VAR_16 > VAR_3->size || VAR_17 > VAR_3->size - VAR_16) {
av_log(VAR_0, VAR_21, ""Invalid strip size/offset\n"");
return VAR_23;
}
if ((VAR_9 = tiff_unpack_strip(VAR_4, VAR_5, VAR_18, VAR_15, VAR_3->data + VAR_16, VAR_17, VAR_12,
FFMIN(VAR_4->rps, VAR_4->height - VAR_12))) < 0) {
if (VAR_0->err_recognition & VAR_29)
return VAR_9;
break;
}
VAR_18 += VAR_4->rps * VAR_15;
}
if (VAR_4->predictor == 2) {
if (VAR_4->photometric == VAR_30) {
av_log(VAR_4->avctx, VAR_21, ""predictor == 2 with YUV is unsupported"");
return VAR_31;
}
VAR_18   = VAR_5->data[VAR_10];
VAR_16  = VAR_4->bpp >> 3;
if (VAR_4->planar)
VAR_16  = FFMAX(VAR_16 / VAR_4->bppcount, 1);
VAR_17 = VAR_4->width * VAR_16;
if (VAR_4->avctx->pix_fmt == VAR_32 ||
VAR_4->avctx->pix_fmt == VAR_33 ||
VAR_4->avctx->pix_fmt == VAR_34 ||
VAR_4->avctx->pix_fmt == VAR_35 ||
VAR_4->avctx->pix_fmt == VAR_36 ||
VAR_4->avctx->pix_fmt == VAR_37) {
for (VAR_12 = 0; VAR_12 < VAR_4->height; VAR_12++) {
for (VAR_13 = VAR_16; VAR_13 < VAR_17; VAR_13 += 2)
AV_WL16(VAR_18 + VAR_13, AV_RL16(VAR_18 + VAR_13) + AV_RL16(VAR_18 + VAR_13 - VAR_16));
VAR_18 += VAR_15;
}
} else if (VAR_4->avctx->pix_fmt == VAR_38 ||
VAR_4->avctx->pix_fmt == VAR_39 ||
VAR_4->avctx->pix_fmt == VAR_40 ||
VAR_4->avctx->pix_fmt == VAR_41 ||
VAR_4->avctx->pix_fmt == VAR_42 ||
VAR_4->avctx->pix_fmt == VAR_43) {
for (VAR_12 = 0; VAR_12 < VAR_4->height; VAR_12++) {
for (VAR_13 = VAR_16; VAR_13 < VAR_17; VAR_13 += 2)
AV_WB16(VAR_18 + VAR_13, AV_RB16(VAR_18 + VAR_13) + AV_RB16(VAR_18 + VAR_13 - VAR_16));
VAR_18 += VAR_15;
}
} else {
for (VAR_12 = 0; VAR_12 < VAR_4->height; VAR_12++) {
for (VAR_13 = VAR_16; VAR_13 < VAR_17; VAR_13++)
VAR_18[VAR_13] += VAR_18[VAR_13 - VAR_16];
VAR_18 += VAR_15;
}
}
}
if (VAR_4->photometric == VAR_44) {
VAR_18 = VAR_5->data[VAR_10];
for (VAR_12 = 0; VAR_12 < VAR_4->height; VAR_12++) {
for (VAR_13 = 0; VAR_13 < VAR_15; VAR_13++)
VAR_18[VAR_13] = (VAR_4->avctx->pix_fmt == VAR_45 ? (1<<VAR_4->bpp) - 1 : 255) - VAR_18[VAR_13];
VAR_18 += VAR_15;
}
}
}
if (VAR_4->planar && VAR_4->bppcount > 2) {
VAR_46(uint8_t*, VAR_5->data[0],     VAR_5->data[2]);
VAR_46(int,      VAR_5->linesize[0], VAR_5->linesize[2]);
VAR_46(uint8_t*, VAR_5->data[0],     VAR_5->data[1]);
VAR_46(int,      VAR_5->linesize[0], VAR_5->linesize[1]);
}
*VAR_2 = 1;
return VAR_3->size;
}",ffmpeg/89f464e9c229006e16f6bb5403c5529fdd0a9edd/tiff.c/vul/before/1.json,"static int decode_frame(AVCodecContext *avctx,
                        void *data, int *got_frame, AVPacket *avpkt)
{
    TiffContext *const s = avctx->priv_data;
    AVFrame *const p = data;
    ThreadFrame frame = { .f = data };
    unsigned off;
    int le, ret, plane, planes;
    int i, j, entries, stride;
    unsigned soff, ssize;
    uint8_t *dst;
    GetByteContext stripsizes;
    GetByteContext stripdata;

    bytestream2_init(&s->gb, avpkt->data, avpkt->size);

    // parse image header
    if ((ret = ff_tdecode_header(&s->gb, &le, &off))) {
        av_log(avctx, AV_LOG_ERROR, ""Invalid TIFF header\n"");
        return ret;
    } else if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {
        av_log(avctx, AV_LOG_ERROR, ""IFD offset is greater than image size\n"");
        return AVERROR_INVALIDDATA;
    }
    s->le          = le;
    // TIFF_BPP is not a required tag and defaults to 1
    s->bppcount    = s->bpp = 1;
    s->photometric = TIFF_PHOTOMETRIC_NONE;
    s->compr       = TIFF_RAW;
    s->fill_order  = 0;
    free_geotags(s);

    // Reset these offsets so we can tell if they were set this frame
    s->stripsizesoff = s->strippos = 0;
    /* parse image file directory */
    bytestream2_seek(&s->gb, off, SEEK_SET);
    entries = ff_tget_short(&s->gb, le);
    if (bytestream2_get_bytes_left(&s->gb) < entries * 12)
        return AVERROR_INVALIDDATA;
    for (i = 0; i < entries; i++) {
        if ((ret = tiff_decode_tag(s, p)) < 0)
            return ret;
    }

    for (i = 0; i<s->geotag_count; i++) {
        const char *keyname = get_geokey_name(s->geotags[i].key);
        if (!keyname) {
            av_log(avctx, AV_LOG_WARNING, ""Unknown or unsupported GeoTIFF key %d\n"", s->geotags[i].key);
            continue;
        }
        if (get_geokey_type(s->geotags[i].key) != s->geotags[i].type) {
            av_log(avctx, AV_LOG_WARNING, ""Type of GeoTIFF key %d is wrong\n"", s->geotags[i].key);
            continue;
        }
        ret = av_dict_set(avpriv_frame_get_metadatap(p), keyname, s->geotags[i].val, 0);
        if (ret<0) {
            av_log(avctx, AV_LOG_ERROR, ""Writing metadata with key '%s' failed\n"", keyname);
            return ret;
        }
    }

    if (!s->strippos && !s->stripoff) {
        av_log(avctx, AV_LOG_ERROR, ""Image data is missing\n"");
        return AVERROR_INVALIDDATA;
    }
    /* now we have the data and may start decoding */
    if ((ret = init_image(s, &frame)) < 0)
        return ret;

    if (s->strips == 1 && !s->stripsize) {
        av_log(avctx, AV_LOG_WARNING, ""Image data size missing\n"");
        s->stripsize = avpkt->size - s->stripoff;
    }

    if (s->stripsizesoff) {
        if (s->stripsizesoff >= (unsigned)avpkt->size)
            return AVERROR_INVALIDDATA;
        bytestream2_init(&stripsizes, avpkt->data + s->stripsizesoff,
                         avpkt->size - s->stripsizesoff);
    }
    if (s->strippos) {
        if (s->strippos >= (unsigned)avpkt->size)
            return AVERROR_INVALIDDATA;
        bytestream2_init(&stripdata, avpkt->data + s->strippos,
                         avpkt->size - s->strippos);
    }

    if (s->rps <= 0 || s->rps % s->subsampling[1]) {
        av_log(avctx, AV_LOG_ERROR, ""rps %d invalid\n"", s->rps);
        return AVERROR_INVALIDDATA;
    }

    planes = s->planar ? s->bppcount : 1;
    for (plane = 0; plane < planes; plane++) {
        stride = p->linesize[plane];
        dst = p->data[plane];
        for (i = 0; i < s->height; i += s->rps) {
            if (s->stripsizesoff)
                ssize = ff_tget(&stripsizes, s->sstype, le);
            else
                ssize = s->stripsize;

            if (s->strippos)
                soff = ff_tget(&stripdata, s->sot, le);
            else
                soff = s->stripoff;

            if (soff > avpkt->size || ssize > avpkt->size - soff) {
                av_log(avctx, AV_LOG_ERROR, ""Invalid strip size/offset\n"");
                return AVERROR_INVALIDDATA;
            }
            if ((ret = tiff_unpack_strip(s, p, dst, stride, avpkt->data + soff, ssize, i,
                                         FFMIN(s->rps, s->height - i))) < 0) {
                if (avctx->err_recognition & AV_EF_EXPLODE)
                    return ret;
                break;
            }
            dst += s->rps * stride;
        }
        if (s->predictor == 2) {
            if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) {
                av_log(s->avctx, AV_LOG_ERROR, ""predictor == 2 with YUV is unsupported"");
                return AVERROR_PATCHWELCOME;
            }
            dst   = p->data[plane];
            soff  = s->bpp >> 3;
            if (s->planar)
                soff  = FFMAX(soff / s->bppcount, 1);
            ssize = s->width * soff;
            if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48LE ||
                s->avctx->pix_fmt == AV_PIX_FMT_RGBA64LE ||
                s->avctx->pix_fmt == AV_PIX_FMT_GRAY16LE ||
                s->avctx->pix_fmt == AV_PIX_FMT_YA16LE ||
                s->avctx->pix_fmt == AV_PIX_FMT_GBRP16LE ||
                s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16LE) {
                for (i = 0; i < s->height; i++) {
                    for (j = soff; j < ssize; j += 2)
                        AV_WL16(dst + j, AV_RL16(dst + j) + AV_RL16(dst + j - soff));
                    dst += stride;
                }
            } else if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||
                       s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE ||
                       s->avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||
                       s->avctx->pix_fmt == AV_PIX_FMT_YA16BE ||
                       s->avctx->pix_fmt == AV_PIX_FMT_GBRP16BE ||
                       s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16BE) {
                for (i = 0; i < s->height; i++) {
                    for (j = soff; j < ssize; j += 2)
                        AV_WB16(dst + j, AV_RB16(dst + j) + AV_RB16(dst + j - soff));
                    dst += stride;
                }
            } else {
                for (i = 0; i < s->height; i++) {
                    for (j = soff; j < ssize; j++)
                        dst[j] += dst[j - soff];
                    dst += stride;
                }
            }
        }

        if (s->photometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) {
            dst = p->data[plane];
            for (i = 0; i < s->height; i++) {
                for (j = 0; j < stride; j++)
                    dst[j] = (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 ? (1<<s->bpp) - 1 : 255) - dst[j];
                dst += stride;
            }
        }
    }

    if (s->planar && s->bppcount > 2) {
        FFSWAP(uint8_t*, p->data[0],     p->data[2]);
        FFSWAP(int,      p->linesize[0], p->linesize[2]);
        FFSWAP(uint8_t*, p->data[0],     p->data[1]);
        FFSWAP(int,      p->linesize[0], p->linesize[1]);
    }

    *got_frame = 1;

    return avpkt->size;
}","static int decode_frame(AVCodecContext *VAR_0,
                        void *VAR_1, int *VAR_2, AVPacket *VAR_3)
{
    TiffContext *const VAR_4 = VAR_0->priv_data;
    AVFrame *const VAR_5 = VAR_1;
    ThreadFrame VAR_6 = { .f = VAR_1 };
    unsigned VAR_7;
    int VAR_8, VAR_9, VAR_10, VAR_11;
    int VAR_12, VAR_13, VAR_14, VAR_15;
    unsigned VAR_16, VAR_17;
    uint8_t *VAR_18;
    GetByteContext VAR_19;
    GetByteContext VAR_20;

    bytestream2_init(&VAR_4->gb, VAR_3->data, VAR_3->size);

    /* COMMENT_0 */
    if ((VAR_9 = ff_tdecode_header(&VAR_4->gb, &VAR_8, &VAR_7))) {
        av_log(VAR_0, VAR_21, ""Invalid TIFF header\n"");
        return VAR_9;
    } else if (VAR_7 >= VAR_22 - 14 || VAR_3->size < VAR_7 + 14) {
        av_log(VAR_0, VAR_21, ""IFD offset is greater than image size\n"");
        return VAR_23;
    }
    VAR_4->le          = VAR_8;
    /* COMMENT_1 */
    VAR_4->bppcount    = VAR_4->bpp = 1;
    VAR_4->photometric = VAR_24;
    VAR_4->compr       = VAR_25;
    VAR_4->fill_order  = 0;
    free_geotags(VAR_4);

    /* COMMENT_2 */
    VAR_4->stripsizesoff = VAR_4->strippos = 0;
    /* COMMENT_3 */
    bytestream2_seek(&VAR_4->gb, VAR_7, VAR_26);
    VAR_14 = ff_tget_short(&VAR_4->gb, VAR_8);
    if (bytestream2_get_bytes_left(&VAR_4->gb) < VAR_14 * 12)
        return VAR_23;
    for (VAR_12 = 0; VAR_12 < VAR_14; VAR_12++) {
        if ((VAR_9 = tiff_decode_tag(VAR_4, VAR_5)) < 0)
            return VAR_9;
    }

    for (VAR_12 = 0; VAR_12<VAR_4->geotag_count; VAR_12++) {
        const char *VAR_27 = get_geokey_name(VAR_4->geotags[VAR_12].key);
        if (!VAR_27) {
            av_log(VAR_0, VAR_28, ""Unknown or unsupported GeoTIFF key %d\n"", VAR_4->geotags[VAR_12].key);
            continue;
        }
        if (get_geokey_type(VAR_4->geotags[VAR_12].key) != VAR_4->geotags[VAR_12].type) {
            av_log(VAR_0, VAR_28, ""Type of GeoTIFF key %d is wrong\n"", VAR_4->geotags[VAR_12].key);
            continue;
        }
        VAR_9 = av_dict_set(avpriv_frame_get_metadatap(VAR_5), VAR_27, VAR_4->geotags[VAR_12].val, 0);
        if (VAR_9<0) {
            av_log(VAR_0, VAR_21, ""Writing metadata with key '%s' failed\n"", VAR_27);
            return VAR_9;
        }
    }

    if (!VAR_4->strippos && !VAR_4->stripoff) {
        av_log(VAR_0, VAR_21, ""Image data is missing\n"");
        return VAR_23;
    }
    /* COMMENT_4 */
    if ((VAR_9 = init_image(VAR_4, &VAR_6)) < 0)
        return VAR_9;

    if (VAR_4->strips == 1 && !VAR_4->stripsize) {
        av_log(VAR_0, VAR_28, ""Image data size missing\n"");
        VAR_4->stripsize = VAR_3->size - VAR_4->stripoff;
    }

    if (VAR_4->stripsizesoff) {
        if (VAR_4->stripsizesoff >= (unsigned)VAR_3->size)
            return VAR_23;
        bytestream2_init(&VAR_19, VAR_3->data + VAR_4->stripsizesoff,
                         VAR_3->size - VAR_4->stripsizesoff);
    }
    if (VAR_4->strippos) {
        if (VAR_4->strippos >= (unsigned)VAR_3->size)
            return VAR_23;
        bytestream2_init(&VAR_20, VAR_3->data + VAR_4->strippos,
                         VAR_3->size - VAR_4->strippos);
    }

    if (VAR_4->rps <= 0 || VAR_4->rps % VAR_4->subsampling[1]) {
        av_log(VAR_0, VAR_21, ""rps %d invalid\n"", VAR_4->rps);
        return VAR_23;
    }

    VAR_11 = VAR_4->planar ? VAR_4->bppcount : 1;
    for (VAR_10 = 0; VAR_10 < VAR_11; VAR_10++) {
        VAR_15 = VAR_5->linesize[VAR_10];
        VAR_18 = VAR_5->data[VAR_10];
        for (VAR_12 = 0; VAR_12 < VAR_4->height; VAR_12 += VAR_4->rps) {
            if (VAR_4->stripsizesoff)
                VAR_17 = ff_tget(&VAR_19, VAR_4->sstype, VAR_8);
            else
                VAR_17 = VAR_4->stripsize;

            if (VAR_4->strippos)
                VAR_16 = ff_tget(&VAR_20, VAR_4->sot, VAR_8);
            else
                VAR_16 = VAR_4->stripoff;

            if (VAR_16 > VAR_3->size || VAR_17 > VAR_3->size - VAR_16) {
                av_log(VAR_0, VAR_21, ""Invalid strip size/offset\n"");
                return VAR_23;
            }
            if ((VAR_9 = tiff_unpack_strip(VAR_4, VAR_5, VAR_18, VAR_15, VAR_3->data + VAR_16, VAR_17, VAR_12,
                                         FFMIN(VAR_4->rps, VAR_4->height - VAR_12))) < 0) {
                if (VAR_0->err_recognition & VAR_29)
                    return VAR_9;
                break;
            }
            VAR_18 += VAR_4->rps * VAR_15;
        }
        if (VAR_4->predictor == 2) {
            if (VAR_4->photometric == VAR_30) {
                av_log(VAR_4->avctx, VAR_21, ""predictor == 2 with YUV is unsupported"");
                return VAR_31;
            }
            VAR_18   = VAR_5->data[VAR_10];
            VAR_16  = VAR_4->bpp >> 3;
            if (VAR_4->planar)
                VAR_16  = FFMAX(VAR_16 / VAR_4->bppcount, 1);
            VAR_17 = VAR_4->width * VAR_16;
            if (VAR_4->avctx->pix_fmt == VAR_32 ||
                VAR_4->avctx->pix_fmt == VAR_33 ||
                VAR_4->avctx->pix_fmt == VAR_34 ||
                VAR_4->avctx->pix_fmt == VAR_35 ||
                VAR_4->avctx->pix_fmt == VAR_36 ||
                VAR_4->avctx->pix_fmt == VAR_37) {
                for (VAR_12 = 0; VAR_12 < VAR_4->height; VAR_12++) {
                    for (VAR_13 = VAR_16; VAR_13 < VAR_17; VAR_13 += 2)
                        AV_WL16(VAR_18 + VAR_13, AV_RL16(VAR_18 + VAR_13) + AV_RL16(VAR_18 + VAR_13 - VAR_16));
                    VAR_18 += VAR_15;
                }
            } else if (VAR_4->avctx->pix_fmt == VAR_38 ||
                       VAR_4->avctx->pix_fmt == VAR_39 ||
                       VAR_4->avctx->pix_fmt == VAR_40 ||
                       VAR_4->avctx->pix_fmt == VAR_41 ||
                       VAR_4->avctx->pix_fmt == VAR_42 ||
                       VAR_4->avctx->pix_fmt == VAR_43) {
                for (VAR_12 = 0; VAR_12 < VAR_4->height; VAR_12++) {
                    for (VAR_13 = VAR_16; VAR_13 < VAR_17; VAR_13 += 2)
                        AV_WB16(VAR_18 + VAR_13, AV_RB16(VAR_18 + VAR_13) + AV_RB16(VAR_18 + VAR_13 - VAR_16));
                    VAR_18 += VAR_15;
                }
            } else {
                for (VAR_12 = 0; VAR_12 < VAR_4->height; VAR_12++) {
                    for (VAR_13 = VAR_16; VAR_13 < VAR_17; VAR_13++)
                        VAR_18[VAR_13] += VAR_18[VAR_13 - VAR_16];
                    VAR_18 += VAR_15;
                }
            }
        }

        if (VAR_4->photometric == VAR_44) {
            VAR_18 = VAR_5->data[VAR_10];
            for (VAR_12 = 0; VAR_12 < VAR_4->height; VAR_12++) {
                for (VAR_13 = 0; VAR_13 < VAR_15; VAR_13++)
                    VAR_18[VAR_13] = (VAR_4->avctx->pix_fmt == VAR_45 ? (1<<VAR_4->bpp) - 1 : 255) - VAR_18[VAR_13];
                VAR_18 += VAR_15;
            }
        }
    }

    if (VAR_4->planar && VAR_4->bppcount > 2) {
        VAR_46(uint8_t*, VAR_5->data[0],     VAR_5->data[2]);
        VAR_46(int,      VAR_5->linesize[0], VAR_5->linesize[2]);
        VAR_46(uint8_t*, VAR_5->data[0],     VAR_5->data[1]);
        VAR_46(int,      VAR_5->linesize[0], VAR_5->linesize[1]);
    }

    *VAR_2 = 1;

    return VAR_3->size;
}",ffmpeg/89f464e9c229006e16f6bb5403c5529fdd0a9edd/tiff.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -85,7 +85,7 @@
                          avpkt->size - s->strippos);
     }
 
-    if (s->rps <= 0) {
+    if (s->rps <= 0 || s->rps % s->subsampling[1]) {
         av_log(avctx, AV_LOG_ERROR, ""rps %d invalid\n"", s->rps);
         return AVERROR_INVALIDDATA;
     }","{'deleted_lines': ['    if (s->rps <= 0) {'], 'added_lines': ['    if (s->rps <= 0 || s->rps % s->subsampling[1]) {']}",True,"libavcodec/tiff.c in FFmpeg before 2.8.6 does not properly validate RowsPerStrip values and YCbCr chrominance subsampling factors, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted TIFF file, related to the tiff_decode_tag and decode_frame functions.",8.8,HIGH,2,test,,5
CVE-2016-1625,['CWE-264'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,chromium,"NTP: don't allow navigateContentWindow to navigate where it pleases.

BUG=509313

Review URL: https://codereview.chromium.org/1669723002

Cr-Commit-Position: refs/heads/master@{#373598}
",d523a41aed4e321d4c8197b5cccb73be23c8dcc2,https://chromium.googlesource.com/chromium/src/+/d523a41aed4e321d4c8197b5cccb73be23c8dcc2,chrome/browser/ui/search/search_tab_helper.cc,SearchTabHelper::NavigateToURL,"void SearchTabHelper::NavigateToURL(const GURL& url,
WindowOpenDisposition disposition,
bool is_most_visited_item_url) {
if (is_most_visited_item_url) {
content::RecordAction(
base::UserMetricsAction(""InstantExtended.MostVisitedClicked""));
}
if (delegate_)
delegate_->NavigateOnThumbnailClick(url, disposition, web_contents_);
}","void SearchTabHelper::NavigateToURL(const GURL& VAR_0,
WindowOpenDisposition VAR_1,
bool VAR_2) {
if (VAR_2) {
content::RecordAction(
base::UserMetricsAction(""InstantExtended.MostVisitedClicked""));
}
if (VAR_3)
VAR_3->NavigateOnThumbnailClick(VAR_0, VAR_1, VAR_4);
}",chromium/d523a41aed4e321d4c8197b5cccb73be23c8dcc2/search_tab_helper.cc/vul/before/0.json,"void SearchTabHelper::NavigateToURL(const GURL& url,
                                    WindowOpenDisposition disposition,
                                    bool is_most_visited_item_url) {
  // Make sure the specified URL is actually on the most visited or suggested
  // items list.
  // TODO(treib): The |is_most_visited_item_url| is meaningless: the way it's
  // currently set by the renderer means it can't be used to decide which list
  // of items (most visited or suggestions) to use for the validation check. Can
  // it be removed?
  if (!instant_service_ || !instant_service_->IsValidURLForNavigation(url))
    return;

  if (is_most_visited_item_url) {
    content::RecordAction(
        base::UserMetricsAction(""InstantExtended.MostVisitedClicked""));
  }

  if (delegate_)
    delegate_->NavigateOnThumbnailClick(url, disposition, web_contents_);
}","void SearchTabHelper::NavigateToURL(const GURL& VAR_0,
                                    WindowOpenDisposition VAR_1,
                                    bool VAR_2) {
  /* COMMENT_0 */
  /* COMMENT_1 */
  /* COMMENT_2 */
  /* COMMENT_3 */
  /* COMMENT_4 */
  /* COMMENT_5 */
  if (!VAR_3 || !VAR_3->IsValidURLForNavigation(VAR_0))
    return;

  if (VAR_2) {
    content::RecordAction(
        base::UserMetricsAction(""InstantExtended.MostVisitedClicked""));
  }

  if (VAR_4)
    VAR_4->NavigateOnThumbnailClick(VAR_0, VAR_1, VAR_5);
}",chromium/d523a41aed4e321d4c8197b5cccb73be23c8dcc2/search_tab_helper.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,15 @@
 void SearchTabHelper::NavigateToURL(const GURL& url,
                                     WindowOpenDisposition disposition,
                                     bool is_most_visited_item_url) {
+  // Make sure the specified URL is actually on the most visited or suggested
+  // items list.
+  // TODO(treib): The |is_most_visited_item_url| is meaningless: the way it's
+  // currently set by the renderer means it can't be used to decide which list
+  // of items (most visited or suggestions) to use for the validation check. Can
+  // it be removed?
+  if (!instant_service_ || !instant_service_->IsValidURLForNavigation(url))
+    return;
+
   if (is_most_visited_item_url) {
     content::RecordAction(
         base::UserMetricsAction(""InstantExtended.MostVisitedClicked""));","{'deleted_lines': [], 'added_lines': ['  // Make sure the specified URL is actually on the most visited or suggested', '  // items list.', ""  // TODO(treib): The |is_most_visited_item_url| is meaningless: the way it's"", ""  // currently set by the renderer means it can't be used to decide which list"", '  // of items (most visited or suggestions) to use for the validation check. Can', '  // it be removed?', '  if (!instant_service_ || !instant_service_->IsValidURLForNavigation(url))', '    return;', '']}",True,"The Chrome Instant feature in Google Chrome before 48.0.2564.109 does not ensure that a New Tab Page (NTP) navigation target is on the most-visited or suggestions list, which allows remote attackers to bypass intended restrictions via unspecified vectors, related to instant_service.cc and search_tab_helper.cc.",4.3,MEDIUM,1,test,,5
CVE-2016-1625,['CWE-264'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,chromium,"NTP: don't allow navigateContentWindow to navigate where it pleases.

BUG=509313

Review URL: https://codereview.chromium.org/1669723002

Cr-Commit-Position: refs/heads/master@{#373598}
",d523a41aed4e321d4c8197b5cccb73be23c8dcc2,https://chromium.googlesource.com/chromium/src/+/d523a41aed4e321d4c8197b5cccb73be23c8dcc2,chrome/renderer/searchbox/searchbox_extension.cc,SearchBoxExtensionWrapper::NavigateContentWindow,"void SearchBoxExtensionWrapper::NavigateContentWindow(
const v8::FunctionCallbackInfo<v8::Value>& args) {
content::RenderView* render_view = GetRenderView();
if (!render_view) return;
if (!args.Length()) {
ThrowInvalidParameters(args);
return;
}
GURL destination_url;
bool is_most_visited_item_url = false;
if (args[0]->IsNumber()) {
InstantMostVisitedItem item;
if (SearchBox::Get(render_view)->GetMostVisitedItemWithID(
args[0]->IntegerValue(), &item)) {
destination_url = item.url;
is_most_visited_item_url = true;
}
} else {
const base::string16& possibly_relative_url = V8ValueToUTF16(args[0]);
GURL current_url = GetCurrentURL(render_view);
destination_url = internal::ResolveURL(current_url, possibly_relative_url);
}
DVLOG(1) << render_view << "" NavigateContentWindow: "" << destination_url;
if (destination_url.is_valid() &&
!destination_url.SchemeIs(url::kJavaScriptScheme)) {
WindowOpenDisposition disposition = CURRENT_TAB;
if (args[1]->IsNumber()) {
disposition = (WindowOpenDisposition) args[1]->Uint32Value();
}
SearchBox::Get(render_view)->NavigateToURL(destination_url, disposition,
is_most_visited_item_url);
}
}","void SearchBoxExtensionWrapper::NavigateContentWindow(
const v8::FunctionCallbackInfo<v8::Value>& VAR_0) {
content::RenderView* VAR_1 = GetRenderView();
if (!VAR_1) return;
if (!VAR_0.Length()) {
ThrowInvalidParameters(VAR_0);
return;
}
GURL VAR_2;
bool VAR_3 = false;
if (VAR_0[0]->IsNumber()) {
InstantMostVisitedItem VAR_4;
if (SearchBox::Get(VAR_1)->GetMostVisitedItemWithID(
VAR_0[0]->IntegerValue(), &VAR_4)) {
VAR_2 = VAR_4.url;
VAR_3 = true;
}
} else {
const base::string16& VAR_5 = V8ValueToUTF16(VAR_0[0]);
GURL VAR_6 = GetCurrentURL(VAR_1);
VAR_2 = internal::ResolveURL(VAR_6, VAR_5);
}
DVLOG(1) << VAR_1 << "" NavigateContentWindow: "" << VAR_2;
if (VAR_2.is_valid() &&
!VAR_2.SchemeIs(url::kJavaScriptScheme)) {
WindowOpenDisposition VAR_7 = VAR_8;
if (VAR_0[1]->IsNumber()) {
VAR_7 = (WindowOpenDisposition) VAR_0[1]->Uint32Value();
}
SearchBox::Get(VAR_1)->NavigateToURL(VAR_2, VAR_7,
VAR_3);
}
}",chromium/d523a41aed4e321d4c8197b5cccb73be23c8dcc2/searchbox_extension.cc/vul/before/0.json,"void SearchBoxExtensionWrapper::NavigateContentWindow(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  content::RenderView* render_view = GetRenderView();
  if (!render_view) return;

  if (!args.Length()) {
    ThrowInvalidParameters(args);
    return;
  }

  GURL destination_url;
  bool is_most_visited_item_url = false;
  // Check if the url is a rid
  if (args[0]->IsNumber()) {
    InstantMostVisitedItem item;
    if (SearchBox::Get(render_view)->GetMostVisitedItemWithID(
            args[0]->IntegerValue(), &item)) {
      destination_url = item.url;
      is_most_visited_item_url = true;
    }
  } else {
    // Resolve the URL
    const base::string16& possibly_relative_url = V8ValueToUTF16(args[0]);
  GURL current_url = GetCurrentURL(render_view);
    destination_url = internal::ResolveURL(current_url, possibly_relative_url);
  }

  DVLOG(1) << render_view << "" NavigateContentWindow: "" << destination_url;

  // Navigate the main frame. Note that the security checks are enforced by the
  // browser process in InstantService::IsValidURLForNavigation(), but some
  // simple checks here are useful for avoiding unnecessary IPCs.
  if (destination_url.is_valid() &&
      !destination_url.SchemeIs(url::kJavaScriptScheme)) {
    WindowOpenDisposition disposition = CURRENT_TAB;
    if (args[1]->IsNumber()) {
      disposition = (WindowOpenDisposition) args[1]->Uint32Value();
    }
    SearchBox::Get(render_view)->NavigateToURL(destination_url, disposition,
                                               is_most_visited_item_url);
  }
}","void SearchBoxExtensionWrapper::NavigateContentWindow(
    const v8::FunctionCallbackInfo<v8::Value>& VAR_0) {
  content::RenderView* VAR_1 = GetRenderView();
  if (!VAR_1) return;

  if (!VAR_0.Length()) {
    ThrowInvalidParameters(VAR_0);
    return;
  }

  GURL VAR_2;
  bool VAR_3 = false;
  /* COMMENT_0 */
  if (VAR_0[0]->IsNumber()) {
    InstantMostVisitedItem VAR_4;
    if (SearchBox::Get(VAR_1)->GetMostVisitedItemWithID(
            VAR_0[0]->IntegerValue(), &VAR_4)) {
      VAR_2 = VAR_4.url;
      VAR_3 = true;
    }
  } else {
    /* COMMENT_1 */
    const base::string16& VAR_5 = V8ValueToUTF16(VAR_0[0]);
  GURL VAR_6 = GetCurrentURL(VAR_1);
    VAR_2 = internal::ResolveURL(VAR_6, VAR_5);
  }

  DVLOG(1) << VAR_1 << "" NavigateContentWindow: "" << VAR_2;

  /* COMMENT_2 */
  /* COMMENT_3 */
  /* COMMENT_4 */
  if (VAR_2.is_valid() &&
      !VAR_2.SchemeIs(url::kJavaScriptScheme)) {
    WindowOpenDisposition VAR_7 = VAR_8;
    if (VAR_0[1]->IsNumber()) {
      VAR_7 = (WindowOpenDisposition) VAR_0[1]->Uint32Value();
    }
    SearchBox::Get(VAR_1)->NavigateToURL(VAR_2, VAR_7,
                                               VAR_3);
  }
}",chromium/d523a41aed4e321d4c8197b5cccb73be23c8dcc2/searchbox_extension.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -27,7 +27,9 @@
 
   DVLOG(1) << render_view << "" NavigateContentWindow: "" << destination_url;
 
-  // Navigate the main frame.
+  // Navigate the main frame. Note that the security checks are enforced by the
+  // browser process in InstantService::IsValidURLForNavigation(), but some
+  // simple checks here are useful for avoiding unnecessary IPCs.
   if (destination_url.is_valid() &&
       !destination_url.SchemeIs(url::kJavaScriptScheme)) {
     WindowOpenDisposition disposition = CURRENT_TAB;","{'deleted_lines': ['  // Navigate the main frame.'], 'added_lines': ['  // Navigate the main frame. Note that the security checks are enforced by the', '  // browser process in InstantService::IsValidURLForNavigation(), but some', '  // simple checks here are useful for avoiding unnecessary IPCs.']}",True,"The Chrome Instant feature in Google Chrome before 48.0.2564.109 does not ensure that a New Tab Page (NTP) navigation target is on the most-visited or suggestions list, which allows remote attackers to bypass intended restrictions via unspecified vectors, related to instant_service.cc and search_tab_helper.cc.",4.3,MEDIUM,1,test,,5
CVE-2017-5993,['CWE-772'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,virglrenderer,"The 'blit_ctx->initialised' is not setted to true.
Every time init blit context, it will create a new
'blit_ctx->gl_context' thus causing a memory leak.
This patch avoid this.

Signed-off-by: Li Qiang <liq3ea@gmail.com>
Signed-off-by: Dave Airlie <airlied@redhat.com>
",6eb13f7a2dcf391ec9e19b4c2a79e68305f63c22,https://cgit.freedesktop.org/virglrenderer/commit/?id=6eb13f7a2dcf391ec9e19b4c2a79e68305f63c22,src/vrend_blitter.c,vrend_renderer_init_blit_ctx,"static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)
{
struct virgl_gl_ctx_param ctx_params;
int i;
if (blit_ctx->initialised) {
vrend_clicbs->make_current(0, blit_ctx->gl_context);
return;
}
ctx_params.shared = true;
ctx_params.major_ver = VREND_GL_VER_MAJOR;
ctx_params.minor_ver = VREND_GL_VER_MINOR;
blit_ctx->gl_context = vrend_clicbs->create_gl_context(0, &ctx_params);
vrend_clicbs->make_current(0, blit_ctx->gl_context);
glGenVertexArrays(1, &blit_ctx->vaoid);
glGenFramebuffers(1, &blit_ctx->fb_id);
glGenBuffers(1, &blit_ctx->vbo_id);
blit_build_vs_passthrough(blit_ctx);
for (i = 0; i < 4; i++)
blit_ctx->vertices[i][0][3] = 1; 
glBindVertexArray(blit_ctx->vaoid);
glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);
}","static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *VAR_0)
{
struct virgl_gl_ctx_param VAR_1;
int VAR_2;
if (VAR_0->initialised) {
VAR_3->make_current(0, VAR_0->gl_context);
return;
}
VAR_1.shared = true;
VAR_1.major_ver = VAR_4;
VAR_1.minor_ver = VAR_5;
VAR_0->gl_context = VAR_3->create_gl_context(0, &VAR_1);
VAR_3->make_current(0, VAR_0->gl_context);
glGenVertexArrays(1, &VAR_0->vaoid);
glGenFramebuffers(1, &VAR_0->fb_id);
glGenBuffers(1, &VAR_0->vbo_id);
blit_build_vs_passthrough(VAR_0);
for (VAR_2 = 0; VAR_2 < 4; VAR_2++)
VAR_0->vertices[VAR_2][0][3] = 1; 
glBindVertexArray(VAR_0->vaoid);
glBindBuffer(VAR_6, VAR_0->vbo_id);
}",virglrenderer/6eb13f7a2dcf391ec9e19b4c2a79e68305f63c22/vrend_blitter.c/vul/before/0.json,"static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)
{
   struct virgl_gl_ctx_param ctx_params;
   int i;
   if (blit_ctx->initialised) {
      vrend_clicbs->make_current(0, blit_ctx->gl_context);
      return;
   }

   blit_ctx->initialised = true;
   ctx_params.shared = true;
   ctx_params.major_ver = VREND_GL_VER_MAJOR;
   ctx_params.minor_ver = VREND_GL_VER_MINOR;
   blit_ctx->gl_context = vrend_clicbs->create_gl_context(0, &ctx_params);

   vrend_clicbs->make_current(0, blit_ctx->gl_context);
   glGenVertexArrays(1, &blit_ctx->vaoid);
   glGenFramebuffers(1, &blit_ctx->fb_id);

   glGenBuffers(1, &blit_ctx->vbo_id);
   blit_build_vs_passthrough(blit_ctx);

   for (i = 0; i < 4; i++)
      blit_ctx->vertices[i][0][3] = 1; /*v.w*/
   glBindVertexArray(blit_ctx->vaoid);
   glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);
}","static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *VAR_0)
{
   struct virgl_gl_ctx_param VAR_1;
   int VAR_2;
   if (VAR_0->initialised) {
      VAR_3->make_current(0, VAR_0->gl_context);
      return;
   }

   VAR_0->initialised = true;
   VAR_1.shared = true;
   VAR_1.major_ver = VAR_4;
   VAR_1.minor_ver = VAR_5;
   VAR_0->gl_context = VAR_3->create_gl_context(0, &VAR_1);

   VAR_3->make_current(0, VAR_0->gl_context);
   glGenVertexArrays(1, &VAR_0->vaoid);
   glGenFramebuffers(1, &VAR_0->fb_id);

   glGenBuffers(1, &VAR_0->vbo_id);
   blit_build_vs_passthrough(VAR_0);

   for (VAR_2 = 0; VAR_2 < 4; VAR_2++)
      VAR_0->vertices[VAR_2][0][3] = 1; /* COMMENT_0 */
   glBindVertexArray(VAR_0->vaoid);
   glBindBuffer(VAR_6, VAR_0->vbo_id);
}",virglrenderer/6eb13f7a2dcf391ec9e19b4c2a79e68305f63c22/vrend_blitter.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -7,6 +7,7 @@
       return;
    }
 
+   blit_ctx->initialised = true;
    ctx_params.shared = true;
    ctx_params.major_ver = VREND_GL_VER_MAJOR;
    ctx_params.minor_ver = VREND_GL_VER_MINOR;","{'deleted_lines': [], 'added_lines': ['   blit_ctx->initialised = true;']}",True,Memory leak in the vrend_renderer_init_blit_ctx function in vrend_blitter.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (host memory consumption) via a large number of VIRGL_CCMD_BLIT commands.,6.5,MEDIUM,1,test,,5
CVE-2017-6210,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,virglrenderer,"There will be a crash if the guest destroy context 0. As the context 0 is
allocate in renderer init, not destroy in vrend_renderer_context_destroy.
The context will be freed in renderer fini by calling vrend_decode_reset.

Signed-off-by: Li Qiang <liq3ea@gmail.com>
Signed-off-by: Dave Airlie <airlied@redhat.com>
",0a5dff15912207b83018485f83e067474e818bab,https://cgit.freedesktop.org/virglrenderer/commit/?id=0a5dff15912207b83018485f83e067474e818bab,src/vrend_decode.c,vrend_renderer_context_destroy,"void vrend_renderer_context_destroy(uint32_t handle)
{
struct vrend_decode_ctx *ctx;
bool ret;
if (handle >= VREND_MAX_CTX)
return;
ctx = dec_ctx[handle];
if (!ctx)
return;
dec_ctx[handle] = NULL;
ret = vrend_destroy_context(ctx->grctx);
free(ctx);
if (ret && handle != 0)
vrend_hw_switch_context(dec_ctx[0]->grctx, true);
}","void vrend_renderer_context_destroy(uint32_t VAR_0)
{
struct vrend_decode_ctx *VAR_1;
bool VAR_2;
if (VAR_0 >= VAR_3)
return;
VAR_1 = VAR_4[VAR_0];
if (!VAR_1)
return;
VAR_4[VAR_0] = NULL;
VAR_2 = vrend_destroy_context(VAR_1->grctx);
free(VAR_1);
if (VAR_2 && VAR_0 != 0)
vrend_hw_switch_context(VAR_4[0]->grctx, true);
}",virglrenderer/0a5dff15912207b83018485f83e067474e818bab/vrend_decode.c/vul/before/0.json,"void vrend_renderer_context_destroy(uint32_t handle)
{
   struct vrend_decode_ctx *ctx;
   bool ret;

   if (handle >= VREND_MAX_CTX)
      return;

   /* never destroy context 0 here, it will be destroyed in vrend_decode_reset()*/
   if (handle == 0) {
      return;
   }

   ctx = dec_ctx[handle];
   if (!ctx)
      return;
   dec_ctx[handle] = NULL;
   ret = vrend_destroy_context(ctx->grctx);
   free(ctx);
   /* switch to ctx 0 */
   if (ret && handle != 0)
      vrend_hw_switch_context(dec_ctx[0]->grctx, true);
}","void vrend_renderer_context_destroy(uint32_t VAR_0)
{
   struct vrend_decode_ctx *VAR_1;
   bool VAR_2;

   if (VAR_0 >= VAR_3)
      return;

   /* COMMENT_0 */
   if (VAR_0 == 0) {
      return;
   }

   VAR_1 = VAR_4[VAR_0];
   if (!VAR_1)
      return;
   VAR_4[VAR_0] = NULL;
   VAR_2 = vrend_destroy_context(VAR_1->grctx);
   free(VAR_1);
   /* COMMENT_1 */
   if (VAR_2 && VAR_0 != 0)
      vrend_hw_switch_context(VAR_4[0]->grctx, true);
}",virglrenderer/0a5dff15912207b83018485f83e067474e818bab/vrend_decode.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,6 +5,11 @@
 
    if (handle >= VREND_MAX_CTX)
       return;
+
+   /* never destroy context 0 here, it will be destroyed in vrend_decode_reset()*/
+   if (handle == 0) {
+      return;
+   }
 
    ctx = dec_ctx[handle];
    if (!ctx)","{'deleted_lines': [], 'added_lines': ['', '   /* never destroy context 0 here, it will be destroyed in vrend_decode_reset()*/', '   if (handle == 0) {', '      return;', '   }']}",True,The vrend_decode_reset function in vrend_decode.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (NULL pointer dereference and QEMU process crash) by destroying context 0 (zero).,6.5,MEDIUM,1,test,,5
CVE-2017-0540,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"Fix in handling wrong cu_qp_delta

cu_qp_delta is now checked for the range as specified in the spec
Bug: 33966031

Change-Id: I00420bf68081af92e9f2be9af7ce58d0683094ca
",01ca88bb6c5bdd44e071f8effebe12f1d7da9853,https://android.googlesource.com/platform/external/libhevc/+/01ca88bb6c5bdd44e071f8effebe12f1d7da9853,decoder/ihevcd_parse_slice.c,ihevcd_parse_transform_tree,"WORD32 ihevcd_parse_transform_tree(codec_t *ps_codec,
WORD32 x0, WORD32 y0,
WORD32 cu_x_base, WORD32 cu_y_base,
WORD32 log2_trafo_size,
WORD32 trafo_depth,
WORD32 blk_idx,
WORD32 intra_pred_mode)
{
IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
sps_t *ps_sps;
pps_t *ps_pps;
WORD32 value;
WORD32 x1, y1;
WORD32 max_trafo_depth;
bitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;
WORD32 intra_split_flag;
WORD32 split_transform_flag;
WORD32 ctxt_idx;
cab_ctxt_t *ps_cabac = &ps_codec->s_parse.s_cabac;
max_trafo_depth = ps_codec->s_parse.s_cu.i4_max_trafo_depth;
ps_sps = ps_codec->s_parse.ps_sps;
ps_pps = ps_codec->s_parse.ps_pps;
intra_split_flag = ps_codec->s_parse.s_cu.i4_intra_split_flag;
{
split_transform_flag = 0;
if((log2_trafo_size <= ps_sps->i1_log2_max_transform_block_size) &&
(log2_trafo_size > ps_sps->i1_log2_min_transform_block_size) &&
(trafo_depth < max_trafo_depth) &&
!(intra_split_flag && (trafo_depth == 0)))
{
ctxt_idx = IHEVC_CAB_SPLIT_TFM + (5 - log2_trafo_size);
TRACE_CABAC_CTXT(""split_transform_flag"", ps_cabac->u4_range, ctxt_idx);
split_transform_flag = ihevcd_cabac_decode_bin(ps_cabac, ps_bitstrm, ctxt_idx);
AEV_TRACE(""split_transform_flag"", split_transform_flag,
ps_cabac->u4_range);
}
else
{
WORD32 inter_split_flag = 0;
if((0 == ps_sps->i1_max_transform_hierarchy_depth_inter) &&
(PRED_MODE_INTER == ps_codec->s_parse.s_cu.i4_pred_mode) &&
(PART_2Nx2N != ps_codec->s_parse.s_cu.i4_part_mode) &&
(0 == trafo_depth))
{
inter_split_flag = 1;
}
if((log2_trafo_size > ps_sps->i1_log2_max_transform_block_size) ||
((1 == intra_split_flag) && (0 == trafo_depth)) ||
(1 == inter_split_flag))
{
split_transform_flag = 1;
}
}
if(0 == trafo_depth)
{
ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth] = 0;
ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth] = 0;
}
else
{
ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth] = ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth - 1];
ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth] = ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth - 1];
}
if(trafo_depth == 0 || log2_trafo_size > 2)
{
ctxt_idx = IHEVC_CAB_CBCR_IDX + trafo_depth;
if((trafo_depth == 0) || ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth - 1])
{
TRACE_CABAC_CTXT(""cbf_cb"", ps_cabac->u4_range, ctxt_idx);
value = ihevcd_cabac_decode_bin(ps_cabac, ps_bitstrm, ctxt_idx);
AEV_TRACE(""cbf_cb"", value, ps_cabac->u4_range);
ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth] = value;
}
if((trafo_depth == 0) || ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth - 1])
{
TRACE_CABAC_CTXT(""cbf_cr"", ps_cabac->u4_range, ctxt_idx);
value = ihevcd_cabac_decode_bin(ps_cabac, ps_bitstrm, ctxt_idx);
AEV_TRACE(""cbf_cr"", value, ps_cabac->u4_range);
ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth] = value;
}
}
if(split_transform_flag)
{
WORD32 intra_pred_mode_tmp;
x1 = x0 + ((1 << log2_trafo_size) >> 1);
y1 = y0 + ((1 << log2_trafo_size) >> 1);
intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[0];
ihevcd_parse_transform_tree(ps_codec, x0, y0, x0, y0, log2_trafo_size - 1, trafo_depth + 1, 0, intra_pred_mode_tmp);
intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[1];
ihevcd_parse_transform_tree(ps_codec, x1, y0, x0, y0, log2_trafo_size - 1, trafo_depth + 1, 1, intra_pred_mode_tmp);
intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[2];
ihevcd_parse_transform_tree(ps_codec, x0, y1, x0, y0, log2_trafo_size - 1, trafo_depth + 1, 2, intra_pred_mode_tmp);
intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[3];
ihevcd_parse_transform_tree(ps_codec, x1, y1, x0, y0, log2_trafo_size - 1, trafo_depth + 1, 3, intra_pred_mode_tmp);
}
else
{
WORD32 ctb_x_base;
WORD32 ctb_y_base;
WORD32 cu_qp_delta_abs;
tu_t *ps_tu = ps_codec->s_parse.ps_tu;
cu_qp_delta_abs = 0;
ctb_x_base = ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size;
ctb_y_base = ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size;
if((ps_codec->s_parse.s_cu.i4_pred_mode == PRED_MODE_INTRA) ||
(trafo_depth != 0) ||
(ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth]) ||
(ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth]))
{
ctxt_idx = IHEVC_CAB_CBF_LUMA_IDX;
ctxt_idx += (trafo_depth == 0) ? 1 : 0;
TRACE_CABAC_CTXT(""cbf_luma"", ps_cabac->u4_range, ctxt_idx);
value = ihevcd_cabac_decode_bin(ps_cabac, ps_bitstrm, ctxt_idx);
AEV_TRACE(""cbf_luma"", value, ps_cabac->u4_range);
ps_codec->s_parse.s_cu.i1_cbf_luma = value;
}
else
{
ps_codec->s_parse.s_cu.i1_cbf_luma = 1;
}
ps_tu->b1_cb_cbf = 0;
ps_tu->b1_cr_cbf = 0;
ps_tu->b1_y_cbf = 0;
ps_tu->b4_pos_x = ((x0 - ctb_x_base) >> 2);
ps_tu->b4_pos_y = ((y0 - ctb_y_base) >> 2);
ps_tu->b1_transquant_bypass = ps_codec->s_parse.s_cu.i4_cu_transquant_bypass;
ps_tu->b3_size = (log2_trafo_size - 2);
ps_tu->b7_qp = ps_codec->s_parse.u4_qp;
ps_tu->b6_luma_intra_mode = intra_pred_mode;
ps_tu->b3_chroma_intra_mode_idx = ps_codec->s_parse.s_cu.i4_intra_chroma_pred_mode_idx;
if(ps_codec->s_parse.s_cu.i1_cbf_luma ||
ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth] ||
ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth])
{
WORD32 intra_pred_mode_chroma;
if(ps_pps->i1_cu_qp_delta_enabled_flag && !ps_codec->s_parse.i4_is_cu_qp_delta_coded)
{
WORD32 c_max        = TU_MAX_QP_DELTA_ABS;
WORD32 ctxt_inc     = IHEVC_CAB_QP_DELTA_ABS;
WORD32 ctxt_inc_max = CTXT_MAX_QP_DELTA_ABS;
TRACE_CABAC_CTXT(""cu_qp_delta_abs"", ps_cabac->u4_range, ctxt_inc);
cu_qp_delta_abs = ihevcd_cabac_decode_bins_tunary(ps_cabac,
ps_bitstrm,
c_max,
ctxt_inc,
0,
ctxt_inc_max);
if(cu_qp_delta_abs >= c_max)
{
value = ihevcd_cabac_decode_bypass_bins_egk(ps_cabac, ps_bitstrm, 0);
cu_qp_delta_abs += value;
}
AEV_TRACE(""cu_qp_delta_abs"", cu_qp_delta_abs, ps_cabac->u4_range);
ps_codec->s_parse.i4_is_cu_qp_delta_coded = 1;
if(cu_qp_delta_abs)
{
value = ihevcd_cabac_decode_bypass_bin(ps_cabac, ps_bitstrm);
AEV_TRACE(""cu_qp_delta_sign"", value, ps_cabac->u4_range);
if(value)
cu_qp_delta_abs = -cu_qp_delta_abs;
}
ps_codec->s_parse.s_cu.i4_cu_qp_delta = cu_qp_delta_abs;
}
if(ps_codec->s_parse.s_cu.i1_cbf_luma)
{
ps_tu->b1_y_cbf = 1;
ihevcd_parse_residual_coding(ps_codec, x0, y0, log2_trafo_size, 0, intra_pred_mode);
}
if(4 == ps_codec->s_parse.s_cu.i4_intra_chroma_pred_mode_idx)
intra_pred_mode_chroma = ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[0];
else
{
intra_pred_mode_chroma = gau1_intra_pred_chroma_modes[ps_codec->s_parse.s_cu.i4_intra_chroma_pred_mode_idx];
if(intra_pred_mode_chroma ==
ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[0])
{
intra_pred_mode_chroma = INTRA_ANGULAR(34);
}
}
if(log2_trafo_size > 2)
{
if(ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth])
{
ps_tu->b1_cb_cbf = 1;
ihevcd_parse_residual_coding(ps_codec, x0, y0, log2_trafo_size - 1, 1, intra_pred_mode_chroma);
}
if(ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth])
{
ps_tu->b1_cr_cbf = 1;
ihevcd_parse_residual_coding(ps_codec, x0, y0, log2_trafo_size - 1, 2, intra_pred_mode_chroma);
}
}
else if(blk_idx == 3)
{
if(ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth])
{
ps_tu->b1_cb_cbf = 1;
ihevcd_parse_residual_coding(ps_codec, cu_x_base, cu_y_base, log2_trafo_size, 1, intra_pred_mode_chroma);
}
if(ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth])
{
ps_tu->b1_cr_cbf = 1;
ihevcd_parse_residual_coding(ps_codec, cu_x_base, cu_y_base, log2_trafo_size, 2, intra_pred_mode_chroma);
}
}
else
{
ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;
}
}
else
{
if((3 != blk_idx) && (2 == log2_trafo_size))
{
ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;
}
}
{
if((ps_codec->s_parse.s_cu.i4_pos_x << 3) == (ps_tu->b4_pos_x << 2) &&
(ps_codec->s_parse.s_cu.i4_pos_y << 3) == (ps_tu->b4_pos_y << 2))
{
ps_tu->b1_first_tu_in_cu = 1;
}
else
{
ps_tu->b1_first_tu_in_cu = 0;
}
}
ps_codec->s_parse.ps_tu++;
ps_codec->s_parse.s_cu.i4_tu_cnt++;
ps_codec->s_parse.i4_pic_tu_idx++;
}
}
return ret;
}","WORD32 ihevcd_parse_transform_tree(codec_t *VAR_0,
WORD32 VAR_1, WORD32 VAR_2,
WORD32 VAR_3, WORD32 VAR_4,
WORD32 VAR_5,
WORD32 VAR_6,
WORD32 VAR_7,
WORD32 VAR_8)
{
IHEVCD_ERROR_T VAR_9 = (IHEVCD_ERROR_T)VAR_10;
sps_t *VAR_11;
pps_t *VAR_12;
WORD32 VAR_13;
WORD32 VAR_14, VAR_15;
WORD32 VAR_16;
bitstrm_t *VAR_17 = &VAR_0->s_parse.s_bitstrm;
WORD32 VAR_18;
WORD32 VAR_19;
WORD32 VAR_20;
cab_ctxt_t *VAR_21 = &VAR_0->s_parse.s_cabac;
VAR_16 = VAR_0->s_parse.s_cu.i4_max_trafo_depth;
VAR_11 = VAR_0->s_parse.ps_sps;
VAR_12 = VAR_0->s_parse.ps_pps;
VAR_18 = VAR_0->s_parse.s_cu.i4_intra_split_flag;
{
VAR_19 = 0;
if((VAR_5 <= VAR_11->i1_log2_max_transform_block_size) &&
(VAR_5 > VAR_11->i1_log2_min_transform_block_size) &&
(VAR_6 < VAR_16) &&
!(VAR_18 && (VAR_6 == 0)))
{
VAR_20 = VAR_22 + (5 - VAR_5);
TRACE_CABAC_CTXT(""split_transform_flag"", VAR_21->u4_range, VAR_20);
VAR_19 = ihevcd_cabac_decode_bin(VAR_21, VAR_17, VAR_20);
AEV_TRACE(""split_transform_flag"", VAR_19,
VAR_21->u4_range);
}
else
{
WORD32 VAR_23 = 0;
if((0 == VAR_11->i1_max_transform_hierarchy_depth_inter) &&
(VAR_24 == VAR_0->s_parse.s_cu.i4_pred_mode) &&
(VAR_25 != VAR_0->s_parse.s_cu.i4_part_mode) &&
(0 == VAR_6))
{
VAR_23 = 1;
}
if((VAR_5 > VAR_11->i1_log2_max_transform_block_size) ||
((1 == VAR_18) && (0 == VAR_6)) ||
(1 == VAR_23))
{
VAR_19 = 1;
}
}
if(0 == VAR_6)
{
VAR_0->s_parse.s_cu.ai1_cbf_cr[VAR_6] = 0;
VAR_0->s_parse.s_cu.ai1_cbf_cb[VAR_6] = 0;
}
else
{
VAR_0->s_parse.s_cu.ai1_cbf_cb[VAR_6] = VAR_0->s_parse.s_cu.ai1_cbf_cb[VAR_6 - 1];
VAR_0->s_parse.s_cu.ai1_cbf_cr[VAR_6] = VAR_0->s_parse.s_cu.ai1_cbf_cr[VAR_6 - 1];
}
if(VAR_6 == 0 || VAR_5 > 2)
{
VAR_20 = VAR_26 + VAR_6;
if((VAR_6 == 0) || VAR_0->s_parse.s_cu.ai1_cbf_cb[VAR_6 - 1])
{
TRACE_CABAC_CTXT(""cbf_cb"", VAR_21->u4_range, VAR_20);
VAR_13 = ihevcd_cabac_decode_bin(VAR_21, VAR_17, VAR_20);
AEV_TRACE(""cbf_cb"", VAR_13, VAR_21->u4_range);
VAR_0->s_parse.s_cu.ai1_cbf_cb[VAR_6] = VAR_13;
}
if((VAR_6 == 0) || VAR_0->s_parse.s_cu.ai1_cbf_cr[VAR_6 - 1])
{
TRACE_CABAC_CTXT(""cbf_cr"", VAR_21->u4_range, VAR_20);
VAR_13 = ihevcd_cabac_decode_bin(VAR_21, VAR_17, VAR_20);
AEV_TRACE(""cbf_cr"", VAR_13, VAR_21->u4_range);
VAR_0->s_parse.s_cu.ai1_cbf_cr[VAR_6] = VAR_13;
}
}
if(VAR_19)
{
WORD32 VAR_27;
VAR_14 = VAR_1 + ((1 << VAR_5) >> 1);
VAR_15 = VAR_2 + ((1 << VAR_5) >> 1);
VAR_27 = VAR_6 ? VAR_8 : VAR_0->s_parse.s_cu.ai4_intra_luma_pred_mode[0];
ihevcd_parse_transform_tree(VAR_0, VAR_1, VAR_2, VAR_1, VAR_2, VAR_5 - 1, VAR_6 + 1, 0, VAR_27);
VAR_27 = VAR_6 ? VAR_8 : VAR_0->s_parse.s_cu.ai4_intra_luma_pred_mode[1];
ihevcd_parse_transform_tree(VAR_0, VAR_14, VAR_2, VAR_1, VAR_2, VAR_5 - 1, VAR_6 + 1, 1, VAR_27);
VAR_27 = VAR_6 ? VAR_8 : VAR_0->s_parse.s_cu.ai4_intra_luma_pred_mode[2];
ihevcd_parse_transform_tree(VAR_0, VAR_1, VAR_15, VAR_1, VAR_2, VAR_5 - 1, VAR_6 + 1, 2, VAR_27);
VAR_27 = VAR_6 ? VAR_8 : VAR_0->s_parse.s_cu.ai4_intra_luma_pred_mode[3];
ihevcd_parse_transform_tree(VAR_0, VAR_14, VAR_15, VAR_1, VAR_2, VAR_5 - 1, VAR_6 + 1, 3, VAR_27);
}
else
{
WORD32 VAR_28;
WORD32 VAR_29;
WORD32 VAR_30;
tu_t *VAR_31 = VAR_0->s_parse.ps_tu;
VAR_30 = 0;
VAR_28 = VAR_0->s_parse.i4_ctb_x << VAR_11->i1_log2_ctb_size;
VAR_29 = VAR_0->s_parse.i4_ctb_y << VAR_11->i1_log2_ctb_size;
if((VAR_0->s_parse.s_cu.i4_pred_mode == VAR_32) ||
(VAR_6 != 0) ||
(VAR_0->s_parse.s_cu.ai1_cbf_cb[VAR_6]) ||
(VAR_0->s_parse.s_cu.ai1_cbf_cr[VAR_6]))
{
VAR_20 = VAR_33;
VAR_20 += (VAR_6 == 0) ? 1 : 0;
TRACE_CABAC_CTXT(""cbf_luma"", VAR_21->u4_range, VAR_20);
VAR_13 = ihevcd_cabac_decode_bin(VAR_21, VAR_17, VAR_20);
AEV_TRACE(""cbf_luma"", VAR_13, VAR_21->u4_range);
VAR_0->s_parse.s_cu.i1_cbf_luma = VAR_13;
}
else
{
VAR_0->s_parse.s_cu.i1_cbf_luma = 1;
}
VAR_31->b1_cb_cbf = 0;
VAR_31->b1_cr_cbf = 0;
VAR_31->b1_y_cbf = 0;
VAR_31->b4_pos_x = ((VAR_1 - VAR_28) >> 2);
VAR_31->b4_pos_y = ((VAR_2 - VAR_29) >> 2);
VAR_31->b1_transquant_bypass = VAR_0->s_parse.s_cu.i4_cu_transquant_bypass;
VAR_31->b3_size = (VAR_5 - 2);
VAR_31->b7_qp = VAR_0->s_parse.u4_qp;
VAR_31->b6_luma_intra_mode = VAR_8;
VAR_31->b3_chroma_intra_mode_idx = VAR_0->s_parse.s_cu.i4_intra_chroma_pred_mode_idx;
if(VAR_0->s_parse.s_cu.i1_cbf_luma ||
VAR_0->s_parse.s_cu.ai1_cbf_cb[VAR_6] ||
VAR_0->s_parse.s_cu.ai1_cbf_cr[VAR_6])
{
WORD32 VAR_34;
if(VAR_12->i1_cu_qp_delta_enabled_flag && !VAR_0->s_parse.i4_is_cu_qp_delta_coded)
{
WORD32 VAR_35        = VAR_36;
WORD32 VAR_37     = VAR_38;
WORD32 VAR_39 = VAR_40;
TRACE_CABAC_CTXT(""cu_qp_delta_abs"", VAR_21->u4_range, VAR_37);
VAR_30 = ihevcd_cabac_decode_bins_tunary(VAR_21,
VAR_17,
VAR_35,
VAR_37,
0,
VAR_39);
if(VAR_30 >= VAR_35)
{
VAR_13 = ihevcd_cabac_decode_bypass_bins_egk(VAR_21, VAR_17, 0);
VAR_30 += VAR_13;
}
AEV_TRACE(""cu_qp_delta_abs"", VAR_30, VAR_21->u4_range);
VAR_0->s_parse.i4_is_cu_qp_delta_coded = 1;
if(VAR_30)
{
VAR_13 = ihevcd_cabac_decode_bypass_bin(VAR_21, VAR_17);
AEV_TRACE(""cu_qp_delta_sign"", VAR_13, VAR_21->u4_range);
if(VAR_13)
VAR_30 = -VAR_30;
}
VAR_0->s_parse.s_cu.i4_cu_qp_delta = VAR_30;
}
if(VAR_0->s_parse.s_cu.i1_cbf_luma)
{
VAR_31->b1_y_cbf = 1;
ihevcd_parse_residual_coding(VAR_0, VAR_1, VAR_2, VAR_5, 0, VAR_8);
}
if(4 == VAR_0->s_parse.s_cu.i4_intra_chroma_pred_mode_idx)
VAR_34 = VAR_0->s_parse.s_cu.ai4_intra_luma_pred_mode[0];
else
{
VAR_34 = VAR_41[VAR_0->s_parse.s_cu.i4_intra_chroma_pred_mode_idx];
if(VAR_34 ==
VAR_0->s_parse.s_cu.ai4_intra_luma_pred_mode[0])
{
VAR_34 = INTRA_ANGULAR(34);
}
}
if(VAR_5 > 2)
{
if(VAR_0->s_parse.s_cu.ai1_cbf_cb[VAR_6])
{
VAR_31->b1_cb_cbf = 1;
ihevcd_parse_residual_coding(VAR_0, VAR_1, VAR_2, VAR_5 - 1, 1, VAR_34);
}
if(VAR_0->s_parse.s_cu.ai1_cbf_cr[VAR_6])
{
VAR_31->b1_cr_cbf = 1;
ihevcd_parse_residual_coding(VAR_0, VAR_1, VAR_2, VAR_5 - 1, 2, VAR_34);
}
}
else if(VAR_7 == 3)
{
if(VAR_0->s_parse.s_cu.ai1_cbf_cb[VAR_6])
{
VAR_31->b1_cb_cbf = 1;
ihevcd_parse_residual_coding(VAR_0, VAR_3, VAR_4, VAR_5, 1, VAR_34);
}
if(VAR_0->s_parse.s_cu.ai1_cbf_cr[VAR_6])
{
VAR_31->b1_cr_cbf = 1;
ihevcd_parse_residual_coding(VAR_0, VAR_3, VAR_4, VAR_5, 2, VAR_34);
}
}
else
{
VAR_31->b3_chroma_intra_mode_idx = VAR_42;
}
}
else
{
if((3 != VAR_7) && (2 == VAR_5))
{
VAR_31->b3_chroma_intra_mode_idx = VAR_42;
}
}
{
if((VAR_0->s_parse.s_cu.i4_pos_x << 3) == (VAR_31->b4_pos_x << 2) &&
(VAR_0->s_parse.s_cu.i4_pos_y << 3) == (VAR_31->b4_pos_y << 2))
{
VAR_31->b1_first_tu_in_cu = 1;
}
else
{
VAR_31->b1_first_tu_in_cu = 0;
}
}
VAR_0->s_parse.ps_tu++;
VAR_0->s_parse.s_cu.i4_tu_cnt++;
VAR_0->s_parse.i4_pic_tu_idx++;
}
}
return VAR_9;
}",android/01ca88bb6c5bdd44e071f8effebe12f1d7da9853/ihevcd_parse_slice.c/vul/before/0.json,"WORD32 ihevcd_parse_transform_tree(codec_t *ps_codec,
                                   WORD32 x0, WORD32 y0,
                                   WORD32 cu_x_base, WORD32 cu_y_base,
                                   WORD32 log2_trafo_size,
                                   WORD32 trafo_depth,
                                   WORD32 blk_idx,
                                   WORD32 intra_pred_mode)
{
    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
    sps_t *ps_sps;
    pps_t *ps_pps;
    WORD32 value;
    WORD32 x1, y1;
    WORD32 max_trafo_depth;

    bitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;
    WORD32 intra_split_flag;
    WORD32 split_transform_flag;
    WORD32 ctxt_idx;
    cab_ctxt_t *ps_cabac = &ps_codec->s_parse.s_cabac;

    max_trafo_depth = ps_codec->s_parse.s_cu.i4_max_trafo_depth;
    ps_sps = ps_codec->s_parse.ps_sps;
    ps_pps = ps_codec->s_parse.ps_pps;
    intra_split_flag = ps_codec->s_parse.s_cu.i4_intra_split_flag;

    {
        split_transform_flag = 0;
        if((log2_trafo_size <= ps_sps->i1_log2_max_transform_block_size) &&
                        (log2_trafo_size > ps_sps->i1_log2_min_transform_block_size) &&
                        (trafo_depth < max_trafo_depth) &&
                        !(intra_split_flag && (trafo_depth == 0)))
        {
            /* encode the split transform flag, context derived as per Table9-37 */
            ctxt_idx = IHEVC_CAB_SPLIT_TFM + (5 - log2_trafo_size);

            TRACE_CABAC_CTXT(""split_transform_flag"", ps_cabac->u4_range, ctxt_idx);
            split_transform_flag = ihevcd_cabac_decode_bin(ps_cabac, ps_bitstrm, ctxt_idx);
            AEV_TRACE(""split_transform_flag"", split_transform_flag,
                      ps_cabac->u4_range);

        }
        else
        {
            WORD32 inter_split_flag = 0;

            if((0 == ps_sps->i1_max_transform_hierarchy_depth_inter) &&
                            (PRED_MODE_INTER == ps_codec->s_parse.s_cu.i4_pred_mode) &&
                            (PART_2Nx2N != ps_codec->s_parse.s_cu.i4_part_mode) &&
                            (0 == trafo_depth))
            {
                inter_split_flag = 1;
            }

            if((log2_trafo_size > ps_sps->i1_log2_max_transform_block_size) ||
                            ((1 == intra_split_flag) && (0 == trafo_depth)) ||
                            (1 == inter_split_flag))
            {
                split_transform_flag = 1;
            }
        }

        if(0 == trafo_depth)
        {
            ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth] = 0;
            ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth] = 0;
        }
        else
        {
            ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth] = ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth - 1];
            ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth] = ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth - 1];
        }
        if(trafo_depth == 0 || log2_trafo_size > 2)
        {
            ctxt_idx = IHEVC_CAB_CBCR_IDX + trafo_depth;
            /* CBF for Cb/Cr is sent only if the parent CBF for Cb/Cr is non-zero */
            if((trafo_depth == 0) || ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth - 1])
            {
                TRACE_CABAC_CTXT(""cbf_cb"", ps_cabac->u4_range, ctxt_idx);
                value = ihevcd_cabac_decode_bin(ps_cabac, ps_bitstrm, ctxt_idx);
                AEV_TRACE(""cbf_cb"", value, ps_cabac->u4_range);
                ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth] = value;
            }

            if((trafo_depth == 0) || ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth - 1])
            {
                TRACE_CABAC_CTXT(""cbf_cr"", ps_cabac->u4_range, ctxt_idx);
                value = ihevcd_cabac_decode_bin(ps_cabac, ps_bitstrm, ctxt_idx);
                AEV_TRACE(""cbf_cr"", value, ps_cabac->u4_range);
                ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth] = value;
            }
        }
        if(split_transform_flag)
        {
            WORD32 intra_pred_mode_tmp;
            x1 = x0 + ((1 << log2_trafo_size) >> 1);
            y1 = y0 + ((1 << log2_trafo_size) >> 1);

            /* For transform depth of zero, intra pred mode as decoded at CU */
            /* level is sent to the transform tree nodes */
            /* When depth is non-zero intra pred mode of parent node is sent */
            /* This takes care of passing correct mode to all the child nodes */
            intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[0];
            ihevcd_parse_transform_tree(ps_codec, x0, y0, x0, y0, log2_trafo_size - 1, trafo_depth + 1, 0, intra_pred_mode_tmp);

            intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[1];
            ihevcd_parse_transform_tree(ps_codec, x1, y0, x0, y0, log2_trafo_size - 1, trafo_depth + 1, 1, intra_pred_mode_tmp);

            intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[2];
            ihevcd_parse_transform_tree(ps_codec, x0, y1, x0, y0, log2_trafo_size - 1, trafo_depth + 1, 2, intra_pred_mode_tmp);

            intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[3];
            ihevcd_parse_transform_tree(ps_codec, x1, y1, x0, y0, log2_trafo_size - 1, trafo_depth + 1, 3, intra_pred_mode_tmp);

        }
        else
        {
            WORD32 ctb_x_base;
            WORD32 ctb_y_base;
            WORD32 cu_qp_delta_abs;



            tu_t *ps_tu = ps_codec->s_parse.ps_tu;
            cu_qp_delta_abs = 0;
            ctb_x_base = ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size;
            ctb_y_base = ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size;

            if((ps_codec->s_parse.s_cu.i4_pred_mode == PRED_MODE_INTRA) ||
                            (trafo_depth != 0) ||
                            (ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth]) ||
                            (ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth]))
            {
                ctxt_idx = IHEVC_CAB_CBF_LUMA_IDX;
                ctxt_idx += (trafo_depth == 0) ? 1 : 0;

                TRACE_CABAC_CTXT(""cbf_luma"", ps_cabac->u4_range, ctxt_idx);
                value = ihevcd_cabac_decode_bin(ps_cabac, ps_bitstrm, ctxt_idx);
                AEV_TRACE(""cbf_luma"", value, ps_cabac->u4_range);

                ps_codec->s_parse.s_cu.i1_cbf_luma = value;
            }
            else
            {
                ps_codec->s_parse.s_cu.i1_cbf_luma = 1;
            }

            /* Initialize ps_tu to default values */
            /* If required change this to WORD32 packed write */
            ps_tu->b1_cb_cbf = 0;
            ps_tu->b1_cr_cbf = 0;
            ps_tu->b1_y_cbf = 0;
            ps_tu->b4_pos_x = ((x0 - ctb_x_base) >> 2);
            ps_tu->b4_pos_y = ((y0 - ctb_y_base) >> 2);
            ps_tu->b1_transquant_bypass = ps_codec->s_parse.s_cu.i4_cu_transquant_bypass;
            ps_tu->b3_size = (log2_trafo_size - 2);
            ps_tu->b7_qp = ps_codec->s_parse.u4_qp;

            ps_tu->b6_luma_intra_mode = intra_pred_mode;
            ps_tu->b3_chroma_intra_mode_idx = ps_codec->s_parse.s_cu.i4_intra_chroma_pred_mode_idx;

            /* Section:7.3.12  Transform unit syntax inlined here */
            if(ps_codec->s_parse.s_cu.i1_cbf_luma ||
                            ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth] ||
                            ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth])
            {
                WORD32 intra_pred_mode_chroma;
                if(ps_pps->i1_cu_qp_delta_enabled_flag && !ps_codec->s_parse.i4_is_cu_qp_delta_coded)
                {


                    WORD32 c_max        = TU_MAX_QP_DELTA_ABS;
                    WORD32 ctxt_inc     = IHEVC_CAB_QP_DELTA_ABS;
                    WORD32 ctxt_inc_max = CTXT_MAX_QP_DELTA_ABS;

                    TRACE_CABAC_CTXT(""cu_qp_delta_abs"", ps_cabac->u4_range, ctxt_inc);
                    /* qp_delta_abs is coded as combination of tunary and eg0 code  */
                    /* See Table 9-32 and Table 9-37 for details on cu_qp_delta_abs */
                    cu_qp_delta_abs = ihevcd_cabac_decode_bins_tunary(ps_cabac,
                                                                      ps_bitstrm,
                                                                      c_max,
                                                                      ctxt_inc,
                                                                      0,
                                                                      ctxt_inc_max);
                    if(cu_qp_delta_abs >= c_max)
                    {
                        value = ihevcd_cabac_decode_bypass_bins_egk(ps_cabac, ps_bitstrm, 0);
                        cu_qp_delta_abs += value;
                    }
                    AEV_TRACE(""cu_qp_delta_abs"", cu_qp_delta_abs, ps_cabac->u4_range);

                    ps_codec->s_parse.i4_is_cu_qp_delta_coded = 1;


                    if(cu_qp_delta_abs)
                    {
                        value = ihevcd_cabac_decode_bypass_bin(ps_cabac, ps_bitstrm);
                        AEV_TRACE(""cu_qp_delta_sign"", value, ps_cabac->u4_range);

                        if(value)
                            cu_qp_delta_abs = -cu_qp_delta_abs;

                    }

                    if (cu_qp_delta_abs < MIN_CU_QP_DELTA_ABS(ps_sps->i1_bit_depth_luma_minus8)
                                    || cu_qp_delta_abs > MAX_CU_QP_DELTA_ABS(ps_sps->i1_bit_depth_luma_minus8))
                    {
                        return IHEVCD_INVALID_PARAMETER;
                    }

                    ps_codec->s_parse.s_cu.i4_cu_qp_delta = cu_qp_delta_abs;

                }

                if(ps_codec->s_parse.s_cu.i1_cbf_luma)
                {
                    ps_tu->b1_y_cbf = 1;
                    ihevcd_parse_residual_coding(ps_codec, x0, y0, log2_trafo_size, 0, intra_pred_mode);
                }

                if(4 == ps_codec->s_parse.s_cu.i4_intra_chroma_pred_mode_idx)
                    intra_pred_mode_chroma = ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[0];
                else
                {
                    intra_pred_mode_chroma = gau1_intra_pred_chroma_modes[ps_codec->s_parse.s_cu.i4_intra_chroma_pred_mode_idx];

                    if(intra_pred_mode_chroma ==
                                    ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[0])
                    {
                        intra_pred_mode_chroma = INTRA_ANGULAR(34);
                    }

                }
                if(log2_trafo_size > 2)
                {
                    if(ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth])
                    {
                        ps_tu->b1_cb_cbf = 1;
                        ihevcd_parse_residual_coding(ps_codec, x0, y0, log2_trafo_size - 1, 1, intra_pred_mode_chroma);
                    }

                    if(ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth])
                    {
                        ps_tu->b1_cr_cbf = 1;
                        ihevcd_parse_residual_coding(ps_codec, x0, y0, log2_trafo_size - 1, 2, intra_pred_mode_chroma);
                    }
                }
                else if(blk_idx == 3)
                {
                    if(ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth])
                    {
                        ps_tu->b1_cb_cbf = 1;
                        ihevcd_parse_residual_coding(ps_codec, cu_x_base, cu_y_base, log2_trafo_size, 1, intra_pred_mode_chroma);
                    }

                    if(ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth])
                    {
                        ps_tu->b1_cr_cbf = 1;
                        ihevcd_parse_residual_coding(ps_codec, cu_x_base, cu_y_base, log2_trafo_size, 2, intra_pred_mode_chroma);
                    }
                }
                else
                {
                    //ps_tu->b1_chroma_present = 0;
                    ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;
                }
            }
            else
            {
                if((3 != blk_idx) && (2 == log2_trafo_size))
                {
                    ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE;
                }
            }

            /* Set the first TU in CU flag */
            {
                if((ps_codec->s_parse.s_cu.i4_pos_x << 3) == (ps_tu->b4_pos_x << 2) &&
                                (ps_codec->s_parse.s_cu.i4_pos_y << 3) == (ps_tu->b4_pos_y << 2))
                {
                    ps_tu->b1_first_tu_in_cu = 1;
                }
                else
                {
                    ps_tu->b1_first_tu_in_cu = 0;
                }
            }
            ps_codec->s_parse.ps_tu++;
            ps_codec->s_parse.s_cu.i4_tu_cnt++;
            ps_codec->s_parse.i4_pic_tu_idx++;
        }
    }
    return ret;
}","WORD32 ihevcd_parse_transform_tree(codec_t *VAR_0,
                                   WORD32 VAR_1, WORD32 VAR_2,
                                   WORD32 VAR_3, WORD32 VAR_4,
                                   WORD32 VAR_5,
                                   WORD32 VAR_6,
                                   WORD32 VAR_7,
                                   WORD32 VAR_8)
{
    IHEVCD_ERROR_T VAR_9 = (IHEVCD_ERROR_T)VAR_10;
    sps_t *VAR_11;
    pps_t *VAR_12;
    WORD32 VAR_13;
    WORD32 VAR_14, VAR_15;
    WORD32 VAR_16;

    bitstrm_t *VAR_17 = &VAR_0->s_parse.s_bitstrm;
    WORD32 VAR_18;
    WORD32 VAR_19;
    WORD32 VAR_20;
    cab_ctxt_t *VAR_21 = &VAR_0->s_parse.s_cabac;

    VAR_16 = VAR_0->s_parse.s_cu.i4_max_trafo_depth;
    VAR_11 = VAR_0->s_parse.ps_sps;
    VAR_12 = VAR_0->s_parse.ps_pps;
    VAR_18 = VAR_0->s_parse.s_cu.i4_intra_split_flag;

    {
        VAR_19 = 0;
        if((VAR_5 <= VAR_11->i1_log2_max_transform_block_size) &&
                        (VAR_5 > VAR_11->i1_log2_min_transform_block_size) &&
                        (VAR_6 < VAR_16) &&
                        !(VAR_18 && (VAR_6 == 0)))
        {
            /* COMMENT_0 */
            VAR_20 = VAR_22 + (5 - VAR_5);

            TRACE_CABAC_CTXT(""split_transform_flag"", VAR_21->u4_range, VAR_20);
            VAR_19 = ihevcd_cabac_decode_bin(VAR_21, VAR_17, VAR_20);
            AEV_TRACE(""split_transform_flag"", VAR_19,
                      VAR_21->u4_range);

        }
        else
        {
            WORD32 VAR_23 = 0;

            if((0 == VAR_11->i1_max_transform_hierarchy_depth_inter) &&
                            (VAR_24 == VAR_0->s_parse.s_cu.i4_pred_mode) &&
                            (VAR_25 != VAR_0->s_parse.s_cu.i4_part_mode) &&
                            (0 == VAR_6))
            {
                VAR_23 = 1;
            }

            if((VAR_5 > VAR_11->i1_log2_max_transform_block_size) ||
                            ((1 == VAR_18) && (0 == VAR_6)) ||
                            (1 == VAR_23))
            {
                VAR_19 = 1;
            }
        }

        if(0 == VAR_6)
        {
            VAR_0->s_parse.s_cu.ai1_cbf_cr[VAR_6] = 0;
            VAR_0->s_parse.s_cu.ai1_cbf_cb[VAR_6] = 0;
        }
        else
        {
            VAR_0->s_parse.s_cu.ai1_cbf_cb[VAR_6] = VAR_0->s_parse.s_cu.ai1_cbf_cb[VAR_6 - 1];
            VAR_0->s_parse.s_cu.ai1_cbf_cr[VAR_6] = VAR_0->s_parse.s_cu.ai1_cbf_cr[VAR_6 - 1];
        }
        if(VAR_6 == 0 || VAR_5 > 2)
        {
            VAR_20 = VAR_26 + VAR_6;
            /* COMMENT_1 */
            if((VAR_6 == 0) || VAR_0->s_parse.s_cu.ai1_cbf_cb[VAR_6 - 1])
            {
                TRACE_CABAC_CTXT(""cbf_cb"", VAR_21->u4_range, VAR_20);
                VAR_13 = ihevcd_cabac_decode_bin(VAR_21, VAR_17, VAR_20);
                AEV_TRACE(""cbf_cb"", VAR_13, VAR_21->u4_range);
                VAR_0->s_parse.s_cu.ai1_cbf_cb[VAR_6] = VAR_13;
            }

            if((VAR_6 == 0) || VAR_0->s_parse.s_cu.ai1_cbf_cr[VAR_6 - 1])
            {
                TRACE_CABAC_CTXT(""cbf_cr"", VAR_21->u4_range, VAR_20);
                VAR_13 = ihevcd_cabac_decode_bin(VAR_21, VAR_17, VAR_20);
                AEV_TRACE(""cbf_cr"", VAR_13, VAR_21->u4_range);
                VAR_0->s_parse.s_cu.ai1_cbf_cr[VAR_6] = VAR_13;
            }
        }
        if(VAR_19)
        {
            WORD32 VAR_27;
            VAR_14 = VAR_1 + ((1 << VAR_5) >> 1);
            VAR_15 = VAR_2 + ((1 << VAR_5) >> 1);

            /* COMMENT_2 */
            /* COMMENT_3 */
            /* COMMENT_4 */
            /* COMMENT_5 */
            VAR_27 = VAR_6 ? VAR_8 : VAR_0->s_parse.s_cu.ai4_intra_luma_pred_mode[0];
            ihevcd_parse_transform_tree(VAR_0, VAR_1, VAR_2, VAR_1, VAR_2, VAR_5 - 1, VAR_6 + 1, 0, VAR_27);

            VAR_27 = VAR_6 ? VAR_8 : VAR_0->s_parse.s_cu.ai4_intra_luma_pred_mode[1];
            ihevcd_parse_transform_tree(VAR_0, VAR_14, VAR_2, VAR_1, VAR_2, VAR_5 - 1, VAR_6 + 1, 1, VAR_27);

            VAR_27 = VAR_6 ? VAR_8 : VAR_0->s_parse.s_cu.ai4_intra_luma_pred_mode[2];
            ihevcd_parse_transform_tree(VAR_0, VAR_1, VAR_15, VAR_1, VAR_2, VAR_5 - 1, VAR_6 + 1, 2, VAR_27);

            VAR_27 = VAR_6 ? VAR_8 : VAR_0->s_parse.s_cu.ai4_intra_luma_pred_mode[3];
            ihevcd_parse_transform_tree(VAR_0, VAR_14, VAR_15, VAR_1, VAR_2, VAR_5 - 1, VAR_6 + 1, 3, VAR_27);

        }
        else
        {
            WORD32 VAR_28;
            WORD32 VAR_29;
            WORD32 VAR_30;



            tu_t *VAR_31 = VAR_0->s_parse.ps_tu;
            VAR_30 = 0;
            VAR_28 = VAR_0->s_parse.i4_ctb_x << VAR_11->i1_log2_ctb_size;
            VAR_29 = VAR_0->s_parse.i4_ctb_y << VAR_11->i1_log2_ctb_size;

            if((VAR_0->s_parse.s_cu.i4_pred_mode == VAR_32) ||
                            (VAR_6 != 0) ||
                            (VAR_0->s_parse.s_cu.ai1_cbf_cb[VAR_6]) ||
                            (VAR_0->s_parse.s_cu.ai1_cbf_cr[VAR_6]))
            {
                VAR_20 = VAR_33;
                VAR_20 += (VAR_6 == 0) ? 1 : 0;

                TRACE_CABAC_CTXT(""cbf_luma"", VAR_21->u4_range, VAR_20);
                VAR_13 = ihevcd_cabac_decode_bin(VAR_21, VAR_17, VAR_20);
                AEV_TRACE(""cbf_luma"", VAR_13, VAR_21->u4_range);

                VAR_0->s_parse.s_cu.i1_cbf_luma = VAR_13;
            }
            else
            {
                VAR_0->s_parse.s_cu.i1_cbf_luma = 1;
            }

            /* COMMENT_6 */
            /* COMMENT_7 */
            VAR_31->b1_cb_cbf = 0;
            VAR_31->b1_cr_cbf = 0;
            VAR_31->b1_y_cbf = 0;
            VAR_31->b4_pos_x = ((VAR_1 - VAR_28) >> 2);
            VAR_31->b4_pos_y = ((VAR_2 - VAR_29) >> 2);
            VAR_31->b1_transquant_bypass = VAR_0->s_parse.s_cu.i4_cu_transquant_bypass;
            VAR_31->b3_size = (VAR_5 - 2);
            VAR_31->b7_qp = VAR_0->s_parse.u4_qp;

            VAR_31->b6_luma_intra_mode = VAR_8;
            VAR_31->b3_chroma_intra_mode_idx = VAR_0->s_parse.s_cu.i4_intra_chroma_pred_mode_idx;

            /* COMMENT_8 */
            if(VAR_0->s_parse.s_cu.i1_cbf_luma ||
                            VAR_0->s_parse.s_cu.ai1_cbf_cb[VAR_6] ||
                            VAR_0->s_parse.s_cu.ai1_cbf_cr[VAR_6])
            {
                WORD32 VAR_34;
                if(VAR_12->i1_cu_qp_delta_enabled_flag && !VAR_0->s_parse.i4_is_cu_qp_delta_coded)
                {


                    WORD32 VAR_35        = VAR_36;
                    WORD32 VAR_37     = VAR_38;
                    WORD32 VAR_39 = VAR_40;

                    TRACE_CABAC_CTXT(""cu_qp_delta_abs"", VAR_21->u4_range, VAR_37);
                    /* COMMENT_9 */
                    /* COMMENT_10 */
                    VAR_30 = ihevcd_cabac_decode_bins_tunary(VAR_21,
                                                                      VAR_17,
                                                                      VAR_35,
                                                                      VAR_37,
                                                                      0,
                                                                      VAR_39);
                    if(VAR_30 >= VAR_35)
                    {
                        VAR_13 = ihevcd_cabac_decode_bypass_bins_egk(VAR_21, VAR_17, 0);
                        VAR_30 += VAR_13;
                    }
                    AEV_TRACE(""cu_qp_delta_abs"", VAR_30, VAR_21->u4_range);

                    VAR_0->s_parse.i4_is_cu_qp_delta_coded = 1;


                    if(VAR_30)
                    {
                        VAR_13 = ihevcd_cabac_decode_bypass_bin(VAR_21, VAR_17);
                        AEV_TRACE(""cu_qp_delta_sign"", VAR_13, VAR_21->u4_range);

                        if(VAR_13)
                            VAR_30 = -VAR_30;

                    }

                    if (VAR_30 < MIN_CU_QP_DELTA_ABS(VAR_11->i1_bit_depth_luma_minus8)
                                    || VAR_30 > MAX_CU_QP_DELTA_ABS(VAR_11->i1_bit_depth_luma_minus8))
                    {
                        return VAR_41;
                    }

                    VAR_0->s_parse.s_cu.i4_cu_qp_delta = VAR_30;

                }

                if(VAR_0->s_parse.s_cu.i1_cbf_luma)
                {
                    VAR_31->b1_y_cbf = 1;
                    ihevcd_parse_residual_coding(VAR_0, VAR_1, VAR_2, VAR_5, 0, VAR_8);
                }

                if(4 == VAR_0->s_parse.s_cu.i4_intra_chroma_pred_mode_idx)
                    VAR_34 = VAR_0->s_parse.s_cu.ai4_intra_luma_pred_mode[0];
                else
                {
                    VAR_34 = VAR_42[VAR_0->s_parse.s_cu.i4_intra_chroma_pred_mode_idx];

                    if(VAR_34 ==
                                    VAR_0->s_parse.s_cu.ai4_intra_luma_pred_mode[0])
                    {
                        VAR_34 = INTRA_ANGULAR(34);
                    }

                }
                if(VAR_5 > 2)
                {
                    if(VAR_0->s_parse.s_cu.ai1_cbf_cb[VAR_6])
                    {
                        VAR_31->b1_cb_cbf = 1;
                        ihevcd_parse_residual_coding(VAR_0, VAR_1, VAR_2, VAR_5 - 1, 1, VAR_34);
                    }

                    if(VAR_0->s_parse.s_cu.ai1_cbf_cr[VAR_6])
                    {
                        VAR_31->b1_cr_cbf = 1;
                        ihevcd_parse_residual_coding(VAR_0, VAR_1, VAR_2, VAR_5 - 1, 2, VAR_34);
                    }
                }
                else if(VAR_7 == 3)
                {
                    if(VAR_0->s_parse.s_cu.ai1_cbf_cb[VAR_6])
                    {
                        VAR_31->b1_cb_cbf = 1;
                        ihevcd_parse_residual_coding(VAR_0, VAR_3, VAR_4, VAR_5, 1, VAR_34);
                    }

                    if(VAR_0->s_parse.s_cu.ai1_cbf_cr[VAR_6])
                    {
                        VAR_31->b1_cr_cbf = 1;
                        ihevcd_parse_residual_coding(VAR_0, VAR_3, VAR_4, VAR_5, 2, VAR_34);
                    }
                }
                else
                {
                    /* COMMENT_11 */
                    VAR_31->b3_chroma_intra_mode_idx = VAR_43;
                }
            }
            else
            {
                if((3 != VAR_7) && (2 == VAR_5))
                {
                    VAR_31->b3_chroma_intra_mode_idx = VAR_43;
                }
            }

            /* COMMENT_12 */
            {
                if((VAR_0->s_parse.s_cu.i4_pos_x << 3) == (VAR_31->b4_pos_x << 2) &&
                                (VAR_0->s_parse.s_cu.i4_pos_y << 3) == (VAR_31->b4_pos_y << 2))
                {
                    VAR_31->b1_first_tu_in_cu = 1;
                }
                else
                {
                    VAR_31->b1_first_tu_in_cu = 0;
                }
            }
            VAR_0->s_parse.ps_tu++;
            VAR_0->s_parse.s_cu.i4_tu_cnt++;
            VAR_0->s_parse.i4_pic_tu_idx++;
        }
    }
    return VAR_9;
}",android/01ca88bb6c5bdd44e071f8effebe12f1d7da9853/ihevcd_parse_slice.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -189,7 +189,6 @@
                     }
                     AEV_TRACE(""cu_qp_delta_abs"", cu_qp_delta_abs, ps_cabac->u4_range);
 
-
                     ps_codec->s_parse.i4_is_cu_qp_delta_coded = 1;
 
 
@@ -202,6 +201,13 @@
                             cu_qp_delta_abs = -cu_qp_delta_abs;
 
                     }
+
+                    if (cu_qp_delta_abs < MIN_CU_QP_DELTA_ABS(ps_sps->i1_bit_depth_luma_minus8)
+                                    || cu_qp_delta_abs > MAX_CU_QP_DELTA_ABS(ps_sps->i1_bit_depth_luma_minus8))
+                    {
+                        return IHEVCD_INVALID_PARAMETER;
+                    }
+
                     ps_codec->s_parse.s_cu.i4_cu_qp_delta = cu_qp_delta_abs;
 
                 }","{'deleted_lines': [''], 'added_lines': ['', '                    if (cu_qp_delta_abs < MIN_CU_QP_DELTA_ABS(ps_sps->i1_bit_depth_luma_minus8)', '                                    || cu_qp_delta_abs > MAX_CU_QP_DELTA_ABS(ps_sps->i1_bit_depth_luma_minus8))', '                    {', '                        return IHEVCD_INVALID_PARAMETER;', '                    }', '']}",True,"A remote code execution vulnerability in libhevc in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-33966031.",7.8,HIGH,2,test,,5
CVE-2017-0540,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"Fix in handling wrong cu_qp_delta

cu_qp_delta is now checked for the range as specified in the spec
Bug: 33966031

Change-Id: I00420bf68081af92e9f2be9af7ce58d0683094ca
",01ca88bb6c5bdd44e071f8effebe12f1d7da9853,https://android.googlesource.com/platform/external/libhevc/+/01ca88bb6c5bdd44e071f8effebe12f1d7da9853,decoder/ihevcd_cabac.c,ihevcd_cabac_decode_bypass_bins_egk,"UWORD32 ihevcd_cabac_decode_bypass_bins_egk(cab_ctxt_t *ps_cabac,
bitstrm_t *ps_bitstrm,
WORD32 k)
{
UWORD32 u4_sym;
WORD32 numones;
WORD32 bin;
ASSERT((k >= 0));
numones = k;
bin = 1;
u4_sym = 0;
while(bin)
{
IHEVCD_CABAC_DECODE_BYPASS_BIN(bin, ps_cabac, ps_bitstrm);
u4_sym += bin << numones++;
}
numones -= 1;
numones = CLIP3(numones, 0, 16);
if(numones)
{
UWORD32 u4_suffix;
IHEVCD_CABAC_DECODE_BYPASS_BINS(u4_suffix, ps_cabac, ps_bitstrm, numones);
u4_sym += u4_suffix;
}
return (u4_sym);
}","UWORD32 ihevcd_cabac_decode_bypass_bins_egk(cab_ctxt_t *VAR_0,
bitstrm_t *VAR_1,
WORD32 VAR_2)
{
UWORD32 VAR_3;
WORD32 VAR_4;
WORD32 VAR_5;
ASSERT((VAR_2 >= 0));
VAR_4 = VAR_2;
VAR_5 = 1;
VAR_3 = 0;
while(VAR_5)
{
IHEVCD_CABAC_DECODE_BYPASS_BIN(VAR_5, VAR_0, VAR_1);
VAR_3 += VAR_5 << VAR_4++;
}
VAR_4 -= 1;
VAR_4 = CLIP3(VAR_4, 0, 16);
if(VAR_4)
{
UWORD32 VAR_6;
IHEVCD_CABAC_DECODE_BYPASS_BINS(VAR_6, VAR_0, VAR_1, VAR_4);
VAR_3 += VAR_6;
}
return (VAR_3);
}",android/01ca88bb6c5bdd44e071f8effebe12f1d7da9853/ihevcd_cabac.c/vul/before/0.json,"UWORD32 ihevcd_cabac_decode_bypass_bins_egk(cab_ctxt_t *ps_cabac,
                                            bitstrm_t *ps_bitstrm,
                                            WORD32 k)
{

    UWORD32 u4_sym;
    WORD32 numones;
    WORD32 bin;

    /* Sanity checks */
    ASSERT((k >= 0));

    numones = k;
    bin = 1;
    u4_sym = 0;
    while(bin && (numones <= 16))
    {
        IHEVCD_CABAC_DECODE_BYPASS_BIN(bin, ps_cabac, ps_bitstrm);
        u4_sym += bin << numones++;
    }

    numones -= 1;

    if(numones)
    {
        UWORD32 u4_suffix;

        IHEVCD_CABAC_DECODE_BYPASS_BINS(u4_suffix, ps_cabac, ps_bitstrm, numones);
        u4_sym += u4_suffix;
    }
    return (u4_sym);
}","UWORD32 ihevcd_cabac_decode_bypass_bins_egk(cab_ctxt_t *VAR_0,
                                            bitstrm_t *VAR_1,
                                            WORD32 VAR_2)
{

    UWORD32 VAR_3;
    WORD32 VAR_4;
    WORD32 VAR_5;

    /* COMMENT_0 */
    ASSERT((VAR_2 >= 0));

    VAR_4 = VAR_2;
    VAR_5 = 1;
    VAR_3 = 0;
    while(VAR_5 && (VAR_4 <= 16))
    {
        IHEVCD_CABAC_DECODE_BYPASS_BIN(VAR_5, VAR_0, VAR_1);
        VAR_3 += VAR_5 << VAR_4++;
    }

    VAR_4 -= 1;

    if(VAR_4)
    {
        UWORD32 VAR_6;

        IHEVCD_CABAC_DECODE_BYPASS_BINS(VAR_6, VAR_0, VAR_1, VAR_4);
        VAR_3 += VAR_6;
    }
    return (VAR_3);
}",android/01ca88bb6c5bdd44e071f8effebe12f1d7da9853/ihevcd_cabac.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,14 +13,13 @@
     numones = k;
     bin = 1;
     u4_sym = 0;
-    while(bin)
+    while(bin && (numones <= 16))
     {
         IHEVCD_CABAC_DECODE_BYPASS_BIN(bin, ps_cabac, ps_bitstrm);
         u4_sym += bin << numones++;
     }
 
     numones -= 1;
-    numones = CLIP3(numones, 0, 16);
 
     if(numones)
     {","{'deleted_lines': ['    while(bin)', '    numones = CLIP3(numones, 0, 16);'], 'added_lines': ['    while(bin && (numones <= 16))']}",True,"A remote code execution vulnerability in libhevc in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-33966031.",7.8,HIGH,2,test,,5
CVE-2017-0557,['CWE-200'],AV:N/AC:M/Au:N/C:P/I:N/A:N,0,android,"Error Check for VLD Symbols Read

The maximum number of lead zeros in a VLD symbol (17 bits long) is 11.

Bug: 34093073
Change-Id: Ifd3f64a3a5199d6e4c33ca65449fc396cfb2f3fc
(cherry picked from commit 75e0ad5127752ce37e3fc78a156652e5da435f14)
",227c1f829127405e21dab1664393050c652ef71e,https://android.googlesource.com/platform/external/libmpeg2/+/227c1f829127405e21dab1664393050c652ef71e,decoder/impeg2d_vld.c,impeg2d_vld_decode,"IMPEG2D_ERROR_CODES_T impeg2d_vld_decode(
dec_state_t *ps_dec,
WORD16      *pi2_outAddr,       
const UWORD8 *pu1_scan,         
UWORD8      *pu1_pos,       
UWORD16     u2_intra_flag,      
UWORD16     u2_chroma_flag,     
UWORD16     u2_d_picture,       
UWORD16     u2_intra_vlc_format, 
UWORD16     u2_mpeg2,          
WORD32      *pi4_num_coeffs 
)
{
UWORD32 u4_sym_len;
UWORD32 u4_decoded_value;
UWORD32 u4_level_first_byte;
WORD32  u4_level;
UWORD32 u4_run, u4_numCoeffs;
UWORD32 u4_buf;
UWORD32 u4_buf_nxt;
UWORD32 u4_offset;
UWORD32 *pu4_buf_aligned;
UWORD32 u4_bits;
stream_t *ps_stream = &ps_dec->s_bit_stream;
WORD32  u4_pos;
UWORD32 u4_nz_cols;
UWORD32 u4_nz_rows;
*pi4_num_coeffs = 0;
ps_dec->u4_non_zero_cols = 0;
ps_dec->u4_non_zero_rows = 0;
u4_nz_cols = ps_dec->u4_non_zero_cols;
u4_nz_rows = ps_dec->u4_non_zero_rows;
GET_TEMP_STREAM_DATA(u4_buf,u4_buf_nxt,u4_offset,pu4_buf_aligned,ps_stream)
if(u2_intra_flag)
{
WORD32 dc_size;
WORD32 dc_diff;
WORD32 maxLen;
WORD32 idx;
maxLen = MPEG2_DCT_DC_SIZE_LEN;
idx = 0;
if(u2_chroma_flag != 0)
{
maxLen += 1;
idx++;
}
{
WORD16  end = 0;
UWORD32 maxLen_tmp = maxLen;
UWORD16 m_iBit;
IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,maxLen)
do
{
maxLen_tmp--;
m_iBit = (UWORD8)((u4_bits >> maxLen_tmp) & 0x1);
end = gai2_impeg2d_dct_dc_size[idx][end][m_iBit];
}while(end > 0);
dc_size = end + MPEG2_DCT_DC_SIZE_OFFSET;
FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,(maxLen - maxLen_tmp),pu4_buf_aligned)
}
if (dc_size != 0)
{
UWORD32 u4_bits;
IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, dc_size)
dc_diff = u4_bits;
if ((dc_diff & (1 << (dc_size - 1))) == 0)                 dc_diff -= (1 << dc_size) - 1;
}
else
{
dc_diff = 0;
}
pi2_outAddr[*pi4_num_coeffs]    = dc_diff;
pu1_pos[*pi4_num_coeffs]    = pu1_scan[0];
(*pi4_num_coeffs)++;
if (0 != dc_diff)
{
u4_nz_cols |= 0x01;
u4_nz_rows |= 0x01;
}
u4_numCoeffs = 1;
}
else
{
UWORD32 u4_bits;
IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,1)
if(u4_bits == 1)
{
FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,1, pu4_buf_aligned)
IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, 1)
if(u4_bits == 1)
{
pi2_outAddr[*pi4_num_coeffs] = -1;
}
else
{
pi2_outAddr[*pi4_num_coeffs] = 1;
}
pu1_pos[*pi4_num_coeffs]    = pu1_scan[0];
(*pi4_num_coeffs)++;
u4_numCoeffs = 1;
u4_nz_cols |= 0x01;
u4_nz_rows |= 0x01;
}
else
{
u4_numCoeffs = 0;
}
}
if (1 == u2_d_picture)
{
PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)
ps_dec->u4_non_zero_cols  = u4_nz_cols;
ps_dec->u4_non_zero_rows  = u4_nz_rows;
return ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE);
}
if (1 == u2_intra_vlc_format && u2_intra_flag)
{
while(1)
{
UWORD32 lead_zeros;
WORD16 DecodedValue;
u4_sym_len = 17;
IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,u4_sym_len)
DecodedValue = gau2_impeg2d_tab_one_1_9[u4_bits >> 8];
u4_sym_len = (DecodedValue & 0xf);
u4_level = DecodedValue >> 9;
if(0 != u4_level)
{
u4_run = ((DecodedValue >> 4) & 0x1f);
u4_numCoeffs       += u4_run;
u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
pu1_pos[*pi4_num_coeffs]    = u4_pos;
FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
pi2_outAddr[*pi4_num_coeffs]    = u4_level;
(*pi4_num_coeffs)++;
}
else
{
if (DecodedValue == END_OF_BLOCK_ONE)
{
u4_sym_len = 4;
break;
}
else
{
lead_zeros = CLZ(u4_bits) - 20;
if (0 != lead_zeros)
{
u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;
if (1 == lead_zeros)
{
u4_sym_len         = ((u4_bits & 0x18) >> 3) == 2 ? 11:10;
}
else
{
u4_sym_len         = 11 + lead_zeros;
}
FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;
DecodedValue    = gau2_impeg2d_tab_one_10_16[u4_bits];
u4_run = BITS(DecodedValue, 8,4);
u4_level = ((WORD16) DecodedValue) >> 9;
u4_numCoeffs       += u4_run;
u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
pu1_pos[*pi4_num_coeffs]    = u4_pos;
pi2_outAddr[*pi4_num_coeffs]    = u4_level;
(*pi4_num_coeffs)++;
}
else if(u2_mpeg2 == 1)
{
u4_sym_len         = 6;
FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)
u4_decoded_value    = u4_bits;
u4_run             = (u4_decoded_value >> 12);
u4_level           = (u4_decoded_value & 0x0FFF);
if (u4_level)
u4_level = (u4_level - ((u4_level & 0x0800) << 1));
u4_numCoeffs       += u4_run;
u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
pu1_pos[*pi4_num_coeffs]    = u4_pos;
pi2_outAddr[*pi4_num_coeffs]    = u4_level;
(*pi4_num_coeffs)++;
}
else
{
u4_sym_len         = 6;
FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)
u4_decoded_value     = u4_bits;
u4_run              = (u4_decoded_value >> 8);
u4_level_first_byte = (u4_decoded_value & 0x0FF);
if(u4_level_first_byte & 0x7F)
{
u4_level = (u4_level_first_byte -
((u4_level_first_byte & 0x80) << 1));
}
else
{
IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)
u4_level = u4_bits;
u4_level = (u4_level - (u4_level_first_byte << 1));
}
u4_numCoeffs += u4_run;
u4_pos = pu1_scan[u4_numCoeffs++ & 63];
pu1_pos[*pi4_num_coeffs]    = u4_pos;
pi2_outAddr[*pi4_num_coeffs]    = u4_level;
(*pi4_num_coeffs)++;
}
}
}
u4_nz_cols |= 1 << (u4_pos & 0x7);
u4_nz_rows |= 1 << (u4_pos >> 0x3);
if (u4_numCoeffs > 64)
{
return IMPEG2D_MB_TEX_DECODE_ERR;
}
}
IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)
}
else
{
while(1)
{
UWORD32 lead_zeros;
UWORD16 DecodedValue;
u4_sym_len = 17;
IBITS_NXT(u4_buf, u4_buf_nxt, u4_offset, u4_bits, u4_sym_len)
DecodedValue = gau2_impeg2d_tab_zero_1_9[u4_bits >> 8];
u4_sym_len = BITS(DecodedValue, 3, 0);
u4_level = ((WORD16) DecodedValue) >> 9;
if (0 != u4_level)
{
u4_run = BITS(DecodedValue, 8,4);
u4_numCoeffs       += u4_run;
u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
pu1_pos[*pi4_num_coeffs]    = u4_pos;
FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
pi2_outAddr[*pi4_num_coeffs]    = u4_level;
(*pi4_num_coeffs)++;
}
else
{
if(DecodedValue == END_OF_BLOCK_ZERO)
{
u4_sym_len = 2;
break;
}
else
{
lead_zeros = CLZ(u4_bits) - 20;
if (0 != lead_zeros)
{
u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;
u4_sym_len         = 11 + lead_zeros;
u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;
DecodedValue    = gau2_impeg2d_tab_zero_10_16[u4_bits];
u4_run = BITS(DecodedValue, 8,4);
u4_level = ((WORD16) DecodedValue) >> 9;
u4_numCoeffs       += u4_run;
u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
pu1_pos[*pi4_num_coeffs]    = u4_pos;
if (1 == lead_zeros)
u4_sym_len--;
FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
pi2_outAddr[*pi4_num_coeffs]    = u4_level;
(*pi4_num_coeffs)++;
}
else if(u2_mpeg2 == 1)
{
u4_sym_len         = 6;
FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)
u4_decoded_value    = u4_bits;
u4_run             = (u4_decoded_value >> 12);
u4_level           = (u4_decoded_value & 0x0FFF);
if (u4_level)
u4_level = (u4_level - ((u4_level & 0x0800) << 1));
u4_numCoeffs           += u4_run;
u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
pu1_pos[*pi4_num_coeffs]    = u4_pos;
pi2_outAddr[*pi4_num_coeffs]    = u4_level;
(*pi4_num_coeffs)++;
}
else
{
u4_sym_len             = 6;
FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)
u4_decoded_value        = u4_bits;
u4_run                 = (u4_decoded_value >> 8);
u4_level_first_byte    = (u4_decoded_value & 0x0FF);
if(u4_level_first_byte & 0x7F)
{
u4_level = (u4_level_first_byte -
((u4_level_first_byte & 0x80) << 1));
}
else
{
IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)
u4_level = u4_bits;
u4_level = (u4_level - (u4_level_first_byte << 1));
}
u4_numCoeffs           += u4_run;
u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
pu1_pos[*pi4_num_coeffs]    = u4_pos;
pi2_outAddr[*pi4_num_coeffs]    = u4_level;
(*pi4_num_coeffs)++;
}
}
}
u4_nz_cols |= 1 << (u4_pos & 0x7);
u4_nz_rows |= 1 << (u4_pos >> 0x3);
if (u4_numCoeffs > 64)
{
return IMPEG2D_MB_TEX_DECODE_ERR;
}
}
IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)
}
PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)
ps_dec->u4_non_zero_cols  = u4_nz_cols;
ps_dec->u4_non_zero_rows  = u4_nz_rows;
return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}","IMPEG2D_ERROR_CODES_T impeg2d_vld_decode(
dec_state_t *VAR_0,
WORD16      *VAR_1,       
const UWORD8 *VAR_2,         
UWORD8      *VAR_3,       
UWORD16     VAR_4,      
UWORD16     VAR_5,     
UWORD16     VAR_6,       
UWORD16     VAR_7, 
UWORD16     VAR_8,          
WORD32      *VAR_9 
)
{
UWORD32 VAR_10;
UWORD32 VAR_11;
UWORD32 VAR_12;
WORD32  VAR_13;
UWORD32 VAR_14, VAR_15;
UWORD32 VAR_16;
UWORD32 VAR_17;
UWORD32 VAR_18;
UWORD32 *VAR_19;
UWORD32 VAR_20;
stream_t *VAR_21 = &VAR_0->s_bit_stream;
WORD32  VAR_22;
UWORD32 VAR_23;
UWORD32 VAR_24;
*VAR_9 = 0;
VAR_0->u4_non_zero_cols = 0;
VAR_0->u4_non_zero_rows = 0;
VAR_23 = VAR_0->u4_non_zero_cols;
VAR_24 = VAR_0->u4_non_zero_rows;
GET_TEMP_STREAM_DATA(VAR_16,VAR_17,VAR_18,VAR_19,VAR_21)
if(VAR_4)
{
WORD32 VAR_25;
WORD32 VAR_26;
WORD32 VAR_27;
WORD32 VAR_28;
VAR_27 = VAR_29;
VAR_28 = 0;
if(VAR_5 != 0)
{
VAR_27 += 1;
VAR_28++;
}
{
WORD16  VAR_30 = 0;
UWORD32 VAR_31 = VAR_27;
UWORD16 VAR_32;
IBITS_NXT(VAR_16,VAR_17,VAR_18,VAR_20,VAR_27)
do
{
VAR_31--;
VAR_32 = (UWORD8)((VAR_20 >> VAR_31) & 0x1);
VAR_30 = VAR_33[VAR_28][VAR_30][VAR_32];
}while(VAR_30 > 0);
VAR_25 = VAR_30 + VAR_34;
FLUSH_BITS(VAR_18,VAR_16,VAR_17,(VAR_27 - VAR_31),VAR_19)
}
if (VAR_25 != 0)
{
UWORD32 VAR_20;
IBITS_GET(VAR_16,VAR_17,VAR_18,VAR_20,VAR_19, VAR_25)
VAR_26 = VAR_20;
if ((VAR_26 & (1 << (VAR_25 - 1))) == 0) 
VAR_26 -= (1 << VAR_25) - 1;
}
else
{
VAR_26 = 0;
}
VAR_1[*VAR_9]    = VAR_26;
VAR_3[*VAR_9]    = VAR_2[0];
(*VAR_9)++;
if (0 != VAR_26)
{
VAR_23 |= 0x01;
VAR_24 |= 0x01;
}
VAR_15 = 1;
}
else
{
UWORD32 VAR_20;
IBITS_NXT(VAR_16,VAR_17,VAR_18,VAR_20,1)
if(VAR_20 == 1)
{
FLUSH_BITS(VAR_18,VAR_16,VAR_17,1, VAR_19)
IBITS_GET(VAR_16,VAR_17,VAR_18,VAR_20,VAR_19, 1)
if(VAR_20 == 1)
{
VAR_1[*VAR_9] = -1;
}
else
{
VAR_1[*VAR_9] = 1;
}
VAR_3[*VAR_9]    = VAR_2[0];
(*VAR_9)++;
VAR_15 = 1;
VAR_23 |= 0x01;
VAR_24 |= 0x01;
}
else
{
VAR_15 = 0;
}
}
if (1 == VAR_6)
{
PUT_TEMP_STREAM_DATA(VAR_16, VAR_17, VAR_18, VAR_19, VAR_21)
VAR_0->u4_non_zero_cols  = VAR_23;
VAR_0->u4_non_zero_rows  = VAR_24;
return ((IMPEG2D_ERROR_CODES_T)VAR_35);
}
if (1 == VAR_7 && VAR_4)
{
while(1)
{
UWORD32 VAR_36;
WORD16 VAR_37;
VAR_10 = 17;
IBITS_NXT(VAR_16,VAR_17,VAR_18,VAR_20,VAR_10)
VAR_37 = VAR_38[VAR_20 >> 8];
VAR_10 = (VAR_37 & 0xf);
VAR_13 = VAR_37 >> 9;
if(0 != VAR_13)
{
VAR_14 = ((VAR_37 >> 4) & 0x1f);
VAR_15       += VAR_14;
VAR_22             = VAR_2[VAR_15++ & 63];
VAR_3[*VAR_9]    = VAR_22;
FLUSH_BITS(VAR_18,VAR_16,VAR_17,VAR_10,VAR_19)
VAR_1[*VAR_9]    = VAR_13;
(*VAR_9)++;
}
else
{
if (VAR_37 == VAR_39)
{
VAR_10 = 4;
break;
}
else
{
VAR_36 = CLZ(VAR_20) - 20;
if (0 != VAR_36)
{
VAR_20         = (VAR_20 >> (6 - VAR_36)) & 0x001F;
if (1 == VAR_36)
{
VAR_10         = ((VAR_20 & 0x18) >> 3) == 2 ? 11:10;
}
else
{
VAR_10         = 11 + VAR_36;
}
FLUSH_BITS(VAR_18,VAR_16,VAR_17,VAR_10,VAR_19)
VAR_20         = ((VAR_36 - 1) << 5) + VAR_20;
VAR_37    = VAR_40[VAR_20];
VAR_14 = BITS(VAR_37, 8,4);
VAR_13 = ((WORD16) VAR_37) >> 9;
VAR_15       += VAR_14;
VAR_22             = VAR_2[VAR_15++ & 63];
VAR_3[*VAR_9]    = VAR_22;
VAR_1[*VAR_9]    = VAR_13;
(*VAR_9)++;
}
else if(VAR_8 == 1)
{
VAR_10         = 6;
FLUSH_BITS(VAR_18,VAR_16,VAR_17,VAR_10,VAR_19)
IBITS_GET(VAR_16,VAR_17,VAR_18,VAR_20,VAR_19,18)
VAR_11    = VAR_20;
VAR_14             = (VAR_11 >> 12);
VAR_13           = (VAR_11 & 0x0FFF);
if (VAR_13)
VAR_13 = (VAR_13 - ((VAR_13 & 0x0800) << 1));
VAR_15       += VAR_14;
VAR_22             = VAR_2[VAR_15++ & 63];
VAR_3[*VAR_9]    = VAR_22;
VAR_1[*VAR_9]    = VAR_13;
(*VAR_9)++;
}
else
{
VAR_10         = 6;
FLUSH_BITS(VAR_18,VAR_16,VAR_17,VAR_10,VAR_19)
IBITS_GET(VAR_16,VAR_17,VAR_18,VAR_20,VAR_19,14)
VAR_11     = VAR_20;
VAR_14              = (VAR_11 >> 8);
VAR_12 = (VAR_11 & 0x0FF);
if(VAR_12 & 0x7F)
{
VAR_13 = (VAR_12 -
((VAR_12 & 0x80) << 1));
}
else
{
IBITS_GET(VAR_16,VAR_17,VAR_18,VAR_20,VAR_19,8)
VAR_13 = VAR_20;
VAR_13 = (VAR_13 - (VAR_12 << 1));
}
VAR_15 += VAR_14;
VAR_22 = VAR_2[VAR_15++ & 63];
VAR_3[*VAR_9]    = VAR_22;
VAR_1[*VAR_9]    = VAR_13;
(*VAR_9)++;
}
}
}
VAR_23 |= 1 << (VAR_22 & 0x7);
VAR_24 |= 1 << (VAR_22 >> 0x3);
if (VAR_15 > 64)
{
return VAR_41;
}
}
IBITS_GET(VAR_16,VAR_17,VAR_18,VAR_20,VAR_19,VAR_10)
}
else
{
while(1)
{
UWORD32 VAR_36;
UWORD16 VAR_37;
VAR_10 = 17;
IBITS_NXT(VAR_16, VAR_17, VAR_18, VAR_20, VAR_10)
VAR_37 = VAR_42[VAR_20 >> 8];
VAR_10 = BITS(VAR_37, 3, 0);
VAR_13 = ((WORD16) VAR_37) >> 9;
if (0 != VAR_13)
{
VAR_14 = BITS(VAR_37, 8,4);
VAR_15       += VAR_14;
VAR_22                 = VAR_2[VAR_15++ & 63];
VAR_3[*VAR_9]    = VAR_22;
FLUSH_BITS(VAR_18,VAR_16,VAR_17,VAR_10,VAR_19)
VAR_1[*VAR_9]    = VAR_13;
(*VAR_9)++;
}
else
{
if(VAR_37 == VAR_43)
{
VAR_10 = 2;
break;
}
else
{
VAR_36 = CLZ(VAR_20) - 20;
if (0 != VAR_36)
{
VAR_20         = (VAR_20 >> (6 - VAR_36)) & 0x001F;
VAR_10         = 11 + VAR_36;
VAR_20         = ((VAR_36 - 1) << 5) + VAR_20;
VAR_37    = VAR_44[VAR_20];
VAR_14 = BITS(VAR_37, 8,4);
VAR_13 = ((WORD16) VAR_37) >> 9;
VAR_15       += VAR_14;
VAR_22                 = VAR_2[VAR_15++ & 63];
VAR_3[*VAR_9]    = VAR_22;
if (1 == VAR_36)
VAR_10--;
FLUSH_BITS(VAR_18,VAR_16,VAR_17,VAR_10,VAR_19)
VAR_1[*VAR_9]    = VAR_13;
(*VAR_9)++;
}
else if(VAR_8 == 1)
{
VAR_10         = 6;
FLUSH_BITS(VAR_18,VAR_16,VAR_17,VAR_10,VAR_19)
IBITS_GET(VAR_16,VAR_17,VAR_18,VAR_20,VAR_19,18)
VAR_11    = VAR_20;
VAR_14             = (VAR_11 >> 12);
VAR_13           = (VAR_11 & 0x0FFF);
if (VAR_13)
VAR_13 = (VAR_13 - ((VAR_13 & 0x0800) << 1));
VAR_15           += VAR_14;
VAR_22                 = VAR_2[VAR_15++ & 63];
VAR_3[*VAR_9]    = VAR_22;
VAR_1[*VAR_9]    = VAR_13;
(*VAR_9)++;
}
else
{
VAR_10             = 6;
FLUSH_BITS(VAR_18,VAR_16,VAR_17,VAR_10,VAR_19)
IBITS_GET(VAR_16,VAR_17,VAR_18,VAR_20,VAR_19,14)
VAR_11        = VAR_20;
VAR_14                 = (VAR_11 >> 8);
VAR_12    = (VAR_11 & 0x0FF);
if(VAR_12 & 0x7F)
{
VAR_13 = (VAR_12 -
((VAR_12 & 0x80) << 1));
}
else
{
IBITS_GET(VAR_16,VAR_17,VAR_18,VAR_20,VAR_19,8)
VAR_13 = VAR_20;
VAR_13 = (VAR_13 - (VAR_12 << 1));
}
VAR_15           += VAR_14;
VAR_22                 = VAR_2[VAR_15++ & 63];
VAR_3[*VAR_9]    = VAR_22;
VAR_1[*VAR_9]    = VAR_13;
(*VAR_9)++;
}
}
}
VAR_23 |= 1 << (VAR_22 & 0x7);
VAR_24 |= 1 << (VAR_22 >> 0x3);
if (VAR_15 > 64)
{
return VAR_41;
}
}
IBITS_GET(VAR_16,VAR_17,VAR_18,VAR_20,VAR_19,VAR_10)
}
PUT_TEMP_STREAM_DATA(VAR_16, VAR_17, VAR_18, VAR_19, VAR_21)
VAR_0->u4_non_zero_cols  = VAR_23;
VAR_0->u4_non_zero_rows  = VAR_24;
return (IMPEG2D_ERROR_CODES_T)VAR_35;
}",android/227c1f829127405e21dab1664393050c652ef71e/impeg2d_vld.c/vul/before/0.json,"IMPEG2D_ERROR_CODES_T impeg2d_vld_decode(
    dec_state_t *ps_dec,
    WORD16      *pi2_outAddr,       /*!< Address where decoded symbols will be stored */
    const UWORD8 *pu1_scan,         /*!< Scan table to be used */
    UWORD8      *pu1_pos,       /*!< Scan table to be used */
    UWORD16     u2_intra_flag,      /*!< Intra Macroblock or not */
    UWORD16     u2_chroma_flag,     /*!< Chroma Block or not */
    UWORD16     u2_d_picture,       /*!< D Picture or not */
    UWORD16     u2_intra_vlc_format, /*!< Intra VLC format */
    UWORD16     u2_mpeg2,          /*!< MPEG-2 or not */
    WORD32      *pi4_num_coeffs /*!< Returns the number of coeffs in block */
    )
{

    UWORD32 u4_sym_len;

    UWORD32 u4_decoded_value;
    UWORD32 u4_level_first_byte;
    WORD32  u4_level;
    UWORD32 u4_run, u4_numCoeffs;
    UWORD32 u4_buf;
    UWORD32 u4_buf_nxt;
    UWORD32 u4_offset;
    UWORD32 *pu4_buf_aligned;
    UWORD32 u4_bits;
    stream_t *ps_stream = &ps_dec->s_bit_stream;
    WORD32  u4_pos;
    UWORD32 u4_nz_cols;
    UWORD32 u4_nz_rows;

    *pi4_num_coeffs = 0;

    ps_dec->u4_non_zero_cols = 0;
    ps_dec->u4_non_zero_rows = 0;
    u4_nz_cols = ps_dec->u4_non_zero_cols;
    u4_nz_rows = ps_dec->u4_non_zero_rows;

    GET_TEMP_STREAM_DATA(u4_buf,u4_buf_nxt,u4_offset,pu4_buf_aligned,ps_stream)
    /**************************************************************************/
    /* Decode the DC coefficient in case of Intra block                       */
    /**************************************************************************/
    if(u2_intra_flag)
    {
        WORD32 dc_size;
        WORD32 dc_diff;
        WORD32 maxLen;
        WORD32 idx;


        maxLen = MPEG2_DCT_DC_SIZE_LEN;
        idx = 0;
        if(u2_chroma_flag != 0)
        {
            maxLen += 1;
            idx++;
        }


        {
            WORD16  end = 0;
            UWORD32 maxLen_tmp = maxLen;
            UWORD16 m_iBit;


            /* Get the maximum number of bits needed to decode a symbol */
            IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,maxLen)
            do
            {
                maxLen_tmp--;
                /* Read one bit at a time from the variable to decode the huffman code */
                m_iBit = (UWORD8)((u4_bits >> maxLen_tmp) & 0x1);

                /* Get the next node pointer or the symbol from the tree */
                end = gai2_impeg2d_dct_dc_size[idx][end][m_iBit];
            }while(end > 0);
            dc_size = end + MPEG2_DCT_DC_SIZE_OFFSET;

            /* Flush the appropriate number of bits from the stream */
            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,(maxLen - maxLen_tmp),pu4_buf_aligned)

        }



        if (dc_size != 0)
        {
            UWORD32 u4_bits;

            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, dc_size)
            dc_diff = u4_bits;

            if ((dc_diff & (1 << (dc_size - 1))) == 0) //v Probably the prediction algo?
                dc_diff -= (1 << dc_size) - 1;
        }
        else
        {
            dc_diff = 0;
        }


        pi2_outAddr[*pi4_num_coeffs]    = dc_diff;
        /* This indicates the position of the coefficient. Since this is the DC
         * coefficient, we put the position as 0.
         */
        pu1_pos[*pi4_num_coeffs]    = pu1_scan[0];
        (*pi4_num_coeffs)++;

        if (0 != dc_diff)
        {
            u4_nz_cols |= 0x01;
            u4_nz_rows |= 0x01;
        }

        u4_numCoeffs = 1;
    }
    /**************************************************************************/
    /* Decoding of first AC coefficient in case of non Intra block            */
    /**************************************************************************/
    else
    {
        /* First symbol can be 1s */
        UWORD32 u4_bits;

        IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,1)

        if(u4_bits == 1)
        {

            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,1, pu4_buf_aligned)
            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, 1)
            if(u4_bits == 1)
            {
                pi2_outAddr[*pi4_num_coeffs] = -1;
            }
            else
            {
                pi2_outAddr[*pi4_num_coeffs] = 1;
            }

            /* This indicates the position of the coefficient. Since this is the DC
             * coefficient, we put the position as 0.
             */
            pu1_pos[*pi4_num_coeffs]    = pu1_scan[0];
            (*pi4_num_coeffs)++;
            u4_numCoeffs = 1;

            u4_nz_cols |= 0x01;
            u4_nz_rows |= 0x01;
        }
        else
        {
            u4_numCoeffs = 0;
        }
    }
    if (1 == u2_d_picture)
    {
        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)
        ps_dec->u4_non_zero_cols  = u4_nz_cols;
        ps_dec->u4_non_zero_rows  = u4_nz_rows;
        return ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE);
    }



        if (1 == u2_intra_vlc_format && u2_intra_flag)
        {

            while(1)
            {
                //Putting the impeg2d_dec_ac_coeff_one function inline.

                UWORD32 lead_zeros;
                WORD16 DecodedValue;

                u4_sym_len = 17;
                IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,u4_sym_len)

                /* There cannot be more than 11 leading zeros in the decoded
                 * symbol. The symbol is only 17 bits long, so we subtract 15.
                 */
                lead_zeros = CLZ(u4_bits) - 15;
                if (lead_zeros > 11)
                {
                    return IMPEG2D_MB_DATA_DECODE_ERR;
                }

                DecodedValue = gau2_impeg2d_tab_one_1_9[u4_bits >> 8];
                u4_sym_len = (DecodedValue & 0xf);
                u4_level = DecodedValue >> 9;
                /* One table lookup */
                if(0 != u4_level)
                {
                    u4_run = ((DecodedValue >> 4) & 0x1f);
                    u4_numCoeffs       += u4_run;
                    u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
                    pu1_pos[*pi4_num_coeffs]    = u4_pos;

                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                    pi2_outAddr[*pi4_num_coeffs]    = u4_level;

                    (*pi4_num_coeffs)++;
                }
                else
                {
                    if (DecodedValue == END_OF_BLOCK_ONE)
                    {
                        u4_sym_len = 4;

                        break;
                    }
                    else
                    {
                        /*Second table lookup*/
                        lead_zeros = CLZ(u4_bits) - 20;/* -16 since we are dealing with WORD32 */
                        if (0 != lead_zeros)
                        {

                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;

                            /* Flush the number of bits */
                            if (1 == lead_zeros)
                            {
                                u4_sym_len         = ((u4_bits & 0x18) >> 3) == 2 ? 11:10;
                            }
                            else
                            {
                                u4_sym_len         = 11 + lead_zeros;
                            }
                            /* flushing */
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)

                            /* Calculate the address */
                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;

                            DecodedValue    = gau2_impeg2d_tab_one_10_16[u4_bits];

                            u4_run = BITS(DecodedValue, 8,4);
                            u4_level = ((WORD16) DecodedValue) >> 9;

                            u4_numCoeffs       += u4_run;
                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs]    = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs]    = u4_level;
                            (*pi4_num_coeffs)++;
                        }
                        /*********************************************************************/
                        /* MPEG2 Escape Code                                                 */
                        /*********************************************************************/
                        else if(u2_mpeg2 == 1)
                        {
                            u4_sym_len         = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)
                                u4_decoded_value    = u4_bits;
                            u4_run             = (u4_decoded_value >> 12);
                            u4_level           = (u4_decoded_value & 0x0FFF);

                            if (u4_level)
                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));

                            u4_numCoeffs       += u4_run;
                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs]    = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs]    = u4_level;
                            (*pi4_num_coeffs)++;
                        }
                        /*********************************************************************/
                        /* MPEG1 Escape Code                                                 */
                        /*********************************************************************/
                        else
                        {
                            /*-----------------------------------------------------------
                            * MPEG-1 Stream
                            *
                            * <See D.9.3 of MPEG-2> Run-level escape syntax
                            * Run-level values that cannot be coded with a VLC are coded
                            * by the escape code '0000 01' followed by
                            * either a 14-bit FLC (127 <= level <= 127),
                            * or a 22-bit FLC (255 <= level <= 255).
                            * This is described in Annex B,B.5f of MPEG-1.standard
                            *-----------------------------------------------------------*/

                            /*-----------------------------------------------------------
                            * First 6 bits are the value of the Run. Next is First 8 bits
                            * of Level. These bits decide whether it is 14 bit FLC or
                            * 22-bit FLC.
                            *
                            * If( first 8 bits of Level == '1000000' or '00000000')
                            *      then its is 22-bit FLC.
                            * else
                            *      it is 14-bit FLC.
                            *-----------------------------------------------------------*/
                            u4_sym_len         = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)
                                u4_decoded_value     = u4_bits;
                            u4_run              = (u4_decoded_value >> 8);
                            u4_level_first_byte = (u4_decoded_value & 0x0FF);
                            if(u4_level_first_byte & 0x7F)
                            {
                                /*-------------------------------------------------------
                                * First 8 bits of level are neither 1000000 nor 00000000
                                * Hence 14-bit FLC (Last 8 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_First_Byte - 256 : Level_First_Byte
                                *-------------------------------------------------------*/
                                u4_level = (u4_level_first_byte -
                                    ((u4_level_first_byte & 0x80) << 1));
                            }
                            else
                            {
                                /*-------------------------------------------------------
                                * Next 8 bits are either 1000000 or 00000000
                                * Hence 22-bit FLC (Last 16 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_Second_Byte - 256 : Level_Second_Byte
                                *-------------------------------------------------------*/
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)
                                    u4_level = u4_bits;
                                u4_level = (u4_level - (u4_level_first_byte << 1));
                            }
                            u4_numCoeffs += u4_run;

                            u4_pos = pu1_scan[u4_numCoeffs++ & 63];

                            pu1_pos[*pi4_num_coeffs]    = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs]    = u4_level;
                            (*pi4_num_coeffs)++;
                        }
                    }
                }

                u4_nz_cols |= 1 << (u4_pos & 0x7);
                u4_nz_rows |= 1 << (u4_pos >> 0x3);

                if (u4_numCoeffs > 64)
                {
                    return IMPEG2D_MB_TEX_DECODE_ERR;
                }

            }
            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)
        }
        else
        {
            // Inline
            while(1)
            {

                UWORD32 lead_zeros;
                UWORD16 DecodedValue;

                u4_sym_len = 17;
                IBITS_NXT(u4_buf, u4_buf_nxt, u4_offset, u4_bits, u4_sym_len)

                /* There cannot be more than 11 leading zeros in the decoded
                 * symbol. The symbol is only 17 bits long, so we subtract 15.
                 */
                lead_zeros = CLZ(u4_bits) - 15;
                if (lead_zeros > 11)
                {
                    return IMPEG2D_MB_DATA_DECODE_ERR;
                }

                DecodedValue = gau2_impeg2d_tab_zero_1_9[u4_bits >> 8];
                u4_sym_len = BITS(DecodedValue, 3, 0);
                u4_level = ((WORD16) DecodedValue) >> 9;

                if (0 != u4_level)
                {
                    u4_run = BITS(DecodedValue, 8,4);

                    u4_numCoeffs       += u4_run;

                    u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                    pu1_pos[*pi4_num_coeffs]    = u4_pos;

                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                    pi2_outAddr[*pi4_num_coeffs]    = u4_level;
                    (*pi4_num_coeffs)++;
                }
                else
                {
                    if(DecodedValue == END_OF_BLOCK_ZERO)
                    {
                        u4_sym_len = 2;

                        break;
                    }
                    else
                    {
                        lead_zeros = CLZ(u4_bits) - 20;/* -15 since we are dealing with WORD32 */
                        /*Second table lookup*/
                        if (0 != lead_zeros)
                        {
                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;

                            /* Flush the number of bits */
                            u4_sym_len         = 11 + lead_zeros;

                            /* Calculate the address */
                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;

                            DecodedValue    = gau2_impeg2d_tab_zero_10_16[u4_bits];

                            u4_run = BITS(DecodedValue, 8,4);
                            u4_level = ((WORD16) DecodedValue) >> 9;

                            u4_numCoeffs       += u4_run;

                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs]    = u4_pos;
                            if (1 == lead_zeros)
                                u4_sym_len--;
                            /* flushing */
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                            pi2_outAddr[*pi4_num_coeffs]    = u4_level;

                            (*pi4_num_coeffs)++;
                        }
                        /*Escape Sequence*/
                        else if(u2_mpeg2 == 1)
                        {
                            u4_sym_len         = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)
                            u4_decoded_value    = u4_bits;
                            u4_run             = (u4_decoded_value >> 12);
                            u4_level           = (u4_decoded_value & 0x0FFF);

                            if (u4_level)
                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));

                            u4_numCoeffs           += u4_run;

                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs]    = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs]    = u4_level;

                            (*pi4_num_coeffs)++;
                        }
                        /*********************************************************************/
                        /* MPEG1 Escape Code                                                 */
                        /*********************************************************************/
                        else
                        {
                            /*-----------------------------------------------------------
                            * MPEG-1 Stream
                            *
                            * <See D.9.3 of MPEG-2> Run-level escape syntax
                            * Run-level values that cannot be coded with a VLC are coded
                            * by the escape code '0000 01' followed by
                            * either a 14-bit FLC (127 <= level <= 127),
                            * or a 22-bit FLC (255 <= level <= 255).
                            * This is described in Annex B,B.5f of MPEG-1.standard
                            *-----------------------------------------------------------*/

                            /*-----------------------------------------------------------
                            * First 6 bits are the value of the Run. Next is First 8 bits
                            * of Level. These bits decide whether it is 14 bit FLC or
                            * 22-bit FLC.
                            *
                            * If( first 8 bits of Level == '1000000' or '00000000')
                            *      then its is 22-bit FLC.
                            * else
                            *      it is 14-bit FLC.
                            *-----------------------------------------------------------*/
                            u4_sym_len             = 6;
                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)
                            u4_decoded_value        = u4_bits;
                            u4_run                 = (u4_decoded_value >> 8);
                            u4_level_first_byte    = (u4_decoded_value & 0x0FF);
                            if(u4_level_first_byte & 0x7F)
                            {
                                /*-------------------------------------------------------
                                * First 8 bits of level are neither 1000000 nor 00000000
                                * Hence 14-bit FLC (Last 8 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_First_Byte - 256 : Level_First_Byte
                                *-------------------------------------------------------*/
                                u4_level = (u4_level_first_byte -
                                    ((u4_level_first_byte & 0x80) << 1));
                            }
                            else
                            {
                                /*-------------------------------------------------------
                                * Next 8 bits are either 1000000 or 00000000
                                * Hence 22-bit FLC (Last 16 bits are used to get level)
                                *
                                *  Level = (msb of Level_First_Byte is 1)?
                                *          Level_Second_Byte - 256 : Level_Second_Byte
                                *-------------------------------------------------------*/
                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)
                                u4_level = u4_bits;
                                u4_level = (u4_level - (u4_level_first_byte << 1));
                            }
                            u4_numCoeffs           += u4_run;

                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
                            pu1_pos[*pi4_num_coeffs]    = u4_pos;
                            pi2_outAddr[*pi4_num_coeffs]    = u4_level;

                            (*pi4_num_coeffs)++;
                        }
                    }
                }

                u4_nz_cols |= 1 << (u4_pos & 0x7);
                u4_nz_rows |= 1 << (u4_pos >> 0x3);
                if (u4_numCoeffs > 64)
                {
                    return IMPEG2D_MB_TEX_DECODE_ERR;
                }

            }

            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)

        }

        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)

        ps_dec->u4_non_zero_cols  = u4_nz_cols;
        ps_dec->u4_non_zero_rows  = u4_nz_rows;

            return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}","IMPEG2D_ERROR_CODES_T impeg2d_vld_decode(
    dec_state_t *VAR_0,
    WORD16      *VAR_1,       /* COMMENT_0 */
    const UWORD8 *VAR_2,         /* COMMENT_1 */
    UWORD8      *VAR_3,       /* COMMENT_1 */
    UWORD16     VAR_4,      /* COMMENT_2 */
    UWORD16     VAR_5,     /* COMMENT_3 */
    UWORD16     VAR_6,       /* COMMENT_4 */
    UWORD16     VAR_7, /* COMMENT_5 */
    UWORD16     VAR_8,          /* COMMENT_6 */
    WORD32      *VAR_9 /* COMMENT_7 */
    )
{

    UWORD32 VAR_10;

    UWORD32 VAR_11;
    UWORD32 VAR_12;
    WORD32  VAR_13;
    UWORD32 VAR_14, VAR_15;
    UWORD32 VAR_16;
    UWORD32 VAR_17;
    UWORD32 VAR_18;
    UWORD32 *VAR_19;
    UWORD32 VAR_20;
    stream_t *VAR_21 = &VAR_0->s_bit_stream;
    WORD32  VAR_22;
    UWORD32 VAR_23;
    UWORD32 VAR_24;

    *VAR_9 = 0;

    VAR_0->u4_non_zero_cols = 0;
    VAR_0->u4_non_zero_rows = 0;
    VAR_23 = VAR_0->u4_non_zero_cols;
    VAR_24 = VAR_0->u4_non_zero_rows;

    GET_TEMP_STREAM_DATA(VAR_16,VAR_17,VAR_18,VAR_19,VAR_21)
    /* COMMENT_8 */
    /* COMMENT_9 */
    /* COMMENT_8 */
    if(VAR_4)
    {
        WORD32 VAR_25;
        WORD32 VAR_26;
        WORD32 VAR_27;
        WORD32 VAR_28;


        VAR_27 = VAR_29;
        VAR_28 = 0;
        if(VAR_5 != 0)
        {
            VAR_27 += 1;
            VAR_28++;
        }


        {
            WORD16  VAR_30 = 0;
            UWORD32 VAR_31 = VAR_27;
            UWORD16 VAR_32;


            /* COMMENT_10 */
            IBITS_NXT(VAR_16,VAR_17,VAR_18,VAR_20,VAR_27)
            do
            {
                VAR_31--;
                /* COMMENT_11 */
                VAR_32 = (UWORD8)((VAR_20 >> VAR_31) & 0x1);

                /* COMMENT_12 */
                VAR_30 = VAR_33[VAR_28][VAR_30][VAR_32];
            }while(VAR_30 > 0);
            VAR_25 = VAR_30 + VAR_34;

            /* COMMENT_13 */
            FLUSH_BITS(VAR_18,VAR_16,VAR_17,(VAR_27 - VAR_31),VAR_19)

        }



        if (VAR_25 != 0)
        {
            UWORD32 VAR_20;

            IBITS_GET(VAR_16,VAR_17,VAR_18,VAR_20,VAR_19, VAR_25)
            VAR_26 = VAR_20;

            if ((VAR_26 & (1 << (VAR_25 - 1))) == 0) /* COMMENT_14 */
                VAR_26 -= (1 << VAR_25) - 1;
        }
        else
        {
            VAR_26 = 0;
        }


        VAR_1[*VAR_9]    = VAR_26;
        /* COMMENT_15 */
                                                 
           
        VAR_3[*VAR_9]    = VAR_2[0];
        (*VAR_9)++;

        if (0 != VAR_26)
        {
            VAR_23 |= 0x01;
            VAR_24 |= 0x01;
        }

        VAR_15 = 1;
    }
    /* COMMENT_8 */
    /* COMMENT_18 */
    /* COMMENT_8 */
    else
    {
        /* COMMENT_19 */
        UWORD32 VAR_20;

        IBITS_NXT(VAR_16,VAR_17,VAR_18,VAR_20,1)

        if(VAR_20 == 1)
        {

            FLUSH_BITS(VAR_18,VAR_16,VAR_17,1, VAR_19)
            IBITS_GET(VAR_16,VAR_17,VAR_18,VAR_20,VAR_19, 1)
            if(VAR_20 == 1)
            {
                VAR_1[*VAR_9] = -1;
            }
            else
            {
                VAR_1[*VAR_9] = 1;
            }

            /* COMMENT_20 */
                                                     
               
            VAR_3[*VAR_9]    = VAR_2[0];
            (*VAR_9)++;
            VAR_15 = 1;

            VAR_23 |= 0x01;
            VAR_24 |= 0x01;
        }
        else
        {
            VAR_15 = 0;
        }
    }
    if (1 == VAR_6)
    {
        PUT_TEMP_STREAM_DATA(VAR_16, VAR_17, VAR_18, VAR_19, VAR_21)
        VAR_0->u4_non_zero_cols  = VAR_23;
        VAR_0->u4_non_zero_rows  = VAR_24;
        return ((IMPEG2D_ERROR_CODES_T)VAR_35);
    }



        if (1 == VAR_7 && VAR_4)
        {

            while(1)
            {
                /* COMMENT_23 */

                UWORD32 VAR_36;
                WORD16 VAR_37;

                VAR_10 = 17;
                IBITS_NXT(VAR_16,VAR_17,VAR_18,VAR_20,VAR_10)

                /* COMMENT_24 */
                                                                              
                   
                VAR_36 = CLZ(VAR_20) - 15;
                if (VAR_36 > 11)
                {
                    return VAR_38;
                }

                VAR_37 = VAR_39[VAR_20 >> 8];
                VAR_10 = (VAR_37 & 0xf);
                VAR_13 = VAR_37 >> 9;
                /* COMMENT_27 */
                if(0 != VAR_13)
                {
                    VAR_14 = ((VAR_37 >> 4) & 0x1f);
                    VAR_15       += VAR_14;
                    VAR_22             = VAR_2[VAR_15++ & 63];
                    VAR_3[*VAR_9]    = VAR_22;

                    FLUSH_BITS(VAR_18,VAR_16,VAR_17,VAR_10,VAR_19)
                    VAR_1[*VAR_9]    = VAR_13;

                    (*VAR_9)++;
                }
                else
                {
                    if (VAR_37 == VAR_40)
                    {
                        VAR_10 = 4;

                        break;
                    }
                    else
                    {
                        /* COMMENT_28 */
                        VAR_36 = CLZ(VAR_20) - 20;/* COMMENT_29 */
                        if (0 != VAR_36)
                        {

                            VAR_20         = (VAR_20 >> (6 - VAR_36)) & 0x001F;

                            /* COMMENT_30 */
                            if (1 == VAR_36)
                            {
                                VAR_10         = ((VAR_20 & 0x18) >> 3) == 2 ? 11:10;
                            }
                            else
                            {
                                VAR_10         = 11 + VAR_36;
                            }
                            /* COMMENT_31 */
                            FLUSH_BITS(VAR_18,VAR_16,VAR_17,VAR_10,VAR_19)

                            /* COMMENT_32 */
                            VAR_20         = ((VAR_36 - 1) << 5) + VAR_20;

                            VAR_37    = VAR_41[VAR_20];

                            VAR_14 = BITS(VAR_37, 8,4);
                            VAR_13 = ((WORD16) VAR_37) >> 9;

                            VAR_15       += VAR_14;
                            VAR_22             = VAR_2[VAR_15++ & 63];
                            VAR_3[*VAR_9]    = VAR_22;
                            VAR_1[*VAR_9]    = VAR_13;
                            (*VAR_9)++;
                        }
                        /* COMMENT_33 */
                        /* COMMENT_34 */
                        /* COMMENT_33 */
                        else if(VAR_8 == 1)
                        {
                            VAR_10         = 6;
                            FLUSH_BITS(VAR_18,VAR_16,VAR_17,VAR_10,VAR_19)
                                IBITS_GET(VAR_16,VAR_17,VAR_18,VAR_20,VAR_19,18)
                                VAR_11    = VAR_20;
                            VAR_14             = (VAR_11 >> 12);
                            VAR_13           = (VAR_11 & 0x0FFF);

                            if (VAR_13)
                                VAR_13 = (VAR_13 - ((VAR_13 & 0x0800) << 1));

                            VAR_15       += VAR_14;
                            VAR_22             = VAR_2[VAR_15++ & 63];
                            VAR_3[*VAR_9]    = VAR_22;
                            VAR_1[*VAR_9]    = VAR_13;
                            (*VAR_9)++;
                        }
                        /* COMMENT_33 */
                        /* COMMENT_35 */
                        /* COMMENT_33 */
                        else
                        {
                            /* COMMENT_36 */
                                           
                             
                                                                           
                                                                                        
                                                                      
                                                                        
                                                                    
                                                                                  
                                                                                          

                            /* COMMENT_46 */
                                                                                         
                                                                                     
                                         
                             
                                                                                   
                                                          
                                  
                                                    
                                                                                          
                            VAR_10         = 6;
                            FLUSH_BITS(VAR_18,VAR_16,VAR_17,VAR_10,VAR_19)
                                IBITS_GET(VAR_16,VAR_17,VAR_18,VAR_20,VAR_19,14)
                                VAR_11     = VAR_20;
                            VAR_14              = (VAR_11 >> 8);
                            VAR_12 = (VAR_11 & 0x0FF);
                            if(VAR_12 & 0x7F)
                            {
                                /* COMMENT_56 */
                                                                                        
                                                                                      
                                 
                                                                          
                                                                                    
                                                                                          
                                VAR_13 = (VAR_12 -
                                    ((VAR_12 & 0x80) << 1));
                            }
                            else
                            {
                                /* COMMENT_63 */
                                                                            
                                                                                       
                                 
                                                                          
                                                                                      
                                                                                          
                                IBITS_GET(VAR_16,VAR_17,VAR_18,VAR_20,VAR_19,8)
                                    VAR_13 = VAR_20;
                                VAR_13 = (VAR_13 - (VAR_12 << 1));
                            }
                            VAR_15 += VAR_14;

                            VAR_22 = VAR_2[VAR_15++ & 63];

                            VAR_3[*VAR_9]    = VAR_22;
                            VAR_1[*VAR_9]    = VAR_13;
                            (*VAR_9)++;
                        }
                    }
                }

                VAR_23 |= 1 << (VAR_22 & 0x7);
                VAR_24 |= 1 << (VAR_22 >> 0x3);

                if (VAR_15 > 64)
                {
                    return VAR_42;
                }

            }
            IBITS_GET(VAR_16,VAR_17,VAR_18,VAR_20,VAR_19,VAR_10)
        }
        else
        {
            /* COMMENT_70 */
            while(1)
            {

                UWORD32 VAR_36;
                UWORD16 VAR_37;

                VAR_10 = 17;
                IBITS_NXT(VAR_16, VAR_17, VAR_18, VAR_20, VAR_10)

                /* COMMENT_71 */
                                                                              
                   
                VAR_36 = CLZ(VAR_20) - 15;
                if (VAR_36 > 11)
                {
                    return VAR_38;
                }

                VAR_37 = VAR_43[VAR_20 >> 8];
                VAR_10 = BITS(VAR_37, 3, 0);
                VAR_13 = ((WORD16) VAR_37) >> 9;

                if (0 != VAR_13)
                {
                    VAR_14 = BITS(VAR_37, 8,4);

                    VAR_15       += VAR_14;

                    VAR_22                 = VAR_2[VAR_15++ & 63];
                    VAR_3[*VAR_9]    = VAR_22;

                    FLUSH_BITS(VAR_18,VAR_16,VAR_17,VAR_10,VAR_19)
                    VAR_1[*VAR_9]    = VAR_13;
                    (*VAR_9)++;
                }
                else
                {
                    if(VAR_37 == VAR_44)
                    {
                        VAR_10 = 2;

                        break;
                    }
                    else
                    {
                        VAR_36 = CLZ(VAR_20) - 20;/* COMMENT_74 */
                        /* COMMENT_28 */
                        if (0 != VAR_36)
                        {
                            VAR_20         = (VAR_20 >> (6 - VAR_36)) & 0x001F;

                            /* COMMENT_30 */
                            VAR_10         = 11 + VAR_36;

                            /* COMMENT_32 */
                            VAR_20         = ((VAR_36 - 1) << 5) + VAR_20;

                            VAR_37    = VAR_45[VAR_20];

                            VAR_14 = BITS(VAR_37, 8,4);
                            VAR_13 = ((WORD16) VAR_37) >> 9;

                            VAR_15       += VAR_14;

                            VAR_22                 = VAR_2[VAR_15++ & 63];
                            VAR_3[*VAR_9]    = VAR_22;
                            if (1 == VAR_36)
                                VAR_10--;
                            /* COMMENT_31 */
                            FLUSH_BITS(VAR_18,VAR_16,VAR_17,VAR_10,VAR_19)
                            VAR_1[*VAR_9]    = VAR_13;

                            (*VAR_9)++;
                        }
                        /* COMMENT_75 */
                        else if(VAR_8 == 1)
                        {
                            VAR_10         = 6;
                            FLUSH_BITS(VAR_18,VAR_16,VAR_17,VAR_10,VAR_19)
                            IBITS_GET(VAR_16,VAR_17,VAR_18,VAR_20,VAR_19,18)
                            VAR_11    = VAR_20;
                            VAR_14             = (VAR_11 >> 12);
                            VAR_13           = (VAR_11 & 0x0FFF);

                            if (VAR_13)
                                VAR_13 = (VAR_13 - ((VAR_13 & 0x0800) << 1));

                            VAR_15           += VAR_14;

                            VAR_22                 = VAR_2[VAR_15++ & 63];
                            VAR_3[*VAR_9]    = VAR_22;
                            VAR_1[*VAR_9]    = VAR_13;

                            (*VAR_9)++;
                        }
                        /* COMMENT_33 */
                        /* COMMENT_35 */
                        /* COMMENT_33 */
                        else
                        {
                            /* COMMENT_76 */
                                           
                             
                                                                           
                                                                                        
                                                                      
                                                                        
                                                                    
                                                                                  
                                                                                          

                            /* COMMENT_86 */
                                                                                         
                                                                                     
                                         
                             
                                                                                   
                                                          
                                  
                                                    
                                                                                          
                            VAR_10             = 6;
                            FLUSH_BITS(VAR_18,VAR_16,VAR_17,VAR_10,VAR_19)
                            IBITS_GET(VAR_16,VAR_17,VAR_18,VAR_20,VAR_19,14)
                            VAR_11        = VAR_20;
                            VAR_14                 = (VAR_11 >> 8);
                            VAR_12    = (VAR_11 & 0x0FF);
                            if(VAR_12 & 0x7F)
                            {
                                /* COMMENT_96 */
                                                                                        
                                                                                      
                                 
                                                                          
                                                                                    
                                                                                          
                                VAR_13 = (VAR_12 -
                                    ((VAR_12 & 0x80) << 1));
                            }
                            else
                            {
                                /* COMMENT_103 */
                                                                            
                                                                                       
                                 
                                                                          
                                                                                      
                                                                                          
                                IBITS_GET(VAR_16,VAR_17,VAR_18,VAR_20,VAR_19,8)
                                VAR_13 = VAR_20;
                                VAR_13 = (VAR_13 - (VAR_12 << 1));
                            }
                            VAR_15           += VAR_14;

                            VAR_22                 = VAR_2[VAR_15++ & 63];
                            VAR_3[*VAR_9]    = VAR_22;
                            VAR_1[*VAR_9]    = VAR_13;

                            (*VAR_9)++;
                        }
                    }
                }

                VAR_23 |= 1 << (VAR_22 & 0x7);
                VAR_24 |= 1 << (VAR_22 >> 0x3);
                if (VAR_15 > 64)
                {
                    return VAR_42;
                }

            }

            IBITS_GET(VAR_16,VAR_17,VAR_18,VAR_20,VAR_19,VAR_10)

        }

        PUT_TEMP_STREAM_DATA(VAR_16, VAR_17, VAR_18, VAR_19, VAR_21)

        VAR_0->u4_non_zero_cols  = VAR_23;
        VAR_0->u4_non_zero_rows  = VAR_24;

            return (IMPEG2D_ERROR_CODES_T)VAR_35;
}",android/227c1f829127405e21dab1664393050c652ef71e/impeg2d_vld.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -174,6 +174,15 @@
 
                 u4_sym_len = 17;
                 IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,u4_sym_len)
+
+                /* There cannot be more than 11 leading zeros in the decoded
+                 * symbol. The symbol is only 17 bits long, so we subtract 15.
+                 */
+                lead_zeros = CLZ(u4_bits) - 15;
+                if (lead_zeros > 11)
+                {
+                    return IMPEG2D_MB_DATA_DECODE_ERR;
+                }
 
                 DecodedValue = gau2_impeg2d_tab_one_1_9[u4_bits >> 8];
                 u4_sym_len = (DecodedValue & 0xf);
@@ -346,6 +355,14 @@
                 u4_sym_len = 17;
                 IBITS_NXT(u4_buf, u4_buf_nxt, u4_offset, u4_bits, u4_sym_len)
 
+                /* There cannot be more than 11 leading zeros in the decoded
+                 * symbol. The symbol is only 17 bits long, so we subtract 15.
+                 */
+                lead_zeros = CLZ(u4_bits) - 15;
+                if (lead_zeros > 11)
+                {
+                    return IMPEG2D_MB_DATA_DECODE_ERR;
+                }
 
                 DecodedValue = gau2_impeg2d_tab_zero_1_9[u4_bits >> 8];
                 u4_sym_len = BITS(DecodedValue, 3, 0);","{'deleted_lines': [], 'added_lines': ['', '                /* There cannot be more than 11 leading zeros in the decoded', '                 * symbol. The symbol is only 17 bits long, so we subtract 15.', '                 */', '                lead_zeros = CLZ(u4_bits) - 15;', '                if (lead_zeros > 11)', '                {', '                    return IMPEG2D_MB_DATA_DECODE_ERR;', '                }', '                /* There cannot be more than 11 leading zeros in the decoded', '                 * symbol. The symbol is only 17 bits long, so we subtract 15.', '                 */', '                lead_zeros = CLZ(u4_bits) - 15;', '                if (lead_zeros > 11)', '                {', '                    return IMPEG2D_MB_DATA_DECODE_ERR;', '                }']}",True,"An information disclosure vulnerability in libmpeg2 in Mediaserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access data without permission. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-34093073.",5.5,MEDIUM,1,test,,5
CVE-2016-5011,['CWE-Other'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,util-linux,"If the extended partition starts at zero LBA then MBR is interpreted
as EBR and all is recursively parsed... result is out-of-memory.

 MBR --extended-partition--> EBR --> MBR --> ENB --> MBR ...

Note that such PT is not possible to create by standard partitioning
tools.

Addresses: https://bugzilla.redhat.com/show_bug.cgi?id=1349536
Signed-off-by: Karel Zak <kzak@redhat.com>
",7164a1c34d18831ac61c6744ad14ce916d389b3f,https://git.kernel.org/pub/scm/utils/util-linux/util-linux.git/commit/?h=7164a1c3,libblkid/src/partitions/dos.c,parse_dos_extended,"static int parse_dos_extended(blkid_probe pr, blkid_parttable tab,
uint32_t ex_start, uint32_t ex_size, int ssf)
{
blkid_partlist ls = blkid_probe_get_partlist(pr);
uint32_t cur_start = ex_start, cur_size = ex_size;
unsigned char *data;
int ct_nodata = 0;
int i;
while (1) {
struct dos_partition *p, *p0;
uint32_t start, size;
if (++ct_nodata > 100)
return BLKID_PROBE_OK;
data = blkid_probe_get_sector(pr, cur_start);
if (!data) {
if (errno)
return -errno;
goto leave;
}
if (!mbr_is_valid_magic(data))
goto leave;
p0 = mbr_get_partition(data, 0);
for (p = p0, i = 0; i < 4; i++, p++) {
uint32_t abs_start;
blkid_partition par;
start = dos_partition_get_start(p) * ssf;
size = dos_partition_get_size(p) * ssf;
abs_start = cur_start + start;
if (!size || is_extended(p))
continue;
if (i >= 2) {
if (start + size > cur_size)
continue;
if (abs_start < ex_start)
continue;
if (abs_start + size > ex_start + ex_size)
continue;
}
par = blkid_partlist_add_partition(ls, tab, abs_start, size);
if (!par)
return -ENOMEM;
blkid_partition_set_type(par, p->sys_ind);
blkid_partition_set_flags(par, p->boot_ind);
blkid_partition_gen_uuid(par);
ct_nodata = 0;
}
for (p = p0, i = 0; i < 4; i++, p++) {
start = dos_partition_get_start(p) * ssf;
size = dos_partition_get_size(p) * ssf;
if (size && is_extended(p))
break;
}
if (i == 4)
goto leave;
cur_start = ex_start + start;
cur_size = size;
}
leave:
return BLKID_PROBE_OK;
}","static int parse_dos_extended(blkid_probe VAR_0, blkid_parttable VAR_1,
uint32_t VAR_2, uint32_t VAR_3, int VAR_4)
{
blkid_partlist VAR_5 = blkid_probe_get_partlist(VAR_0);
uint32_t VAR_6 = VAR_2, VAR_7 = VAR_3;
unsigned char *VAR_8;
int VAR_9 = 0;
int VAR_10;
while (1) {
struct dos_partition *VAR_11, *VAR_12;
uint32_t VAR_13, VAR_14;
if (++VAR_9 > 100)
return VAR_15;
VAR_8 = blkid_probe_get_sector(VAR_0, VAR_6);
if (!VAR_8) {
if (VAR_16)
return -VAR_16;
goto leave;
}
if (!mbr_is_valid_magic(VAR_8))
goto leave;
VAR_12 = mbr_get_partition(VAR_8, 0);
for (VAR_11 = VAR_12, VAR_10 = 0; VAR_10 < 4; VAR_10++, VAR_11++) {
uint32_t VAR_17;
blkid_partition VAR_18;
VAR_13 = dos_partition_get_start(VAR_11) * VAR_4;
VAR_14 = dos_partition_get_size(VAR_11) * VAR_4;
VAR_17 = VAR_6 + VAR_13;
if (!VAR_14 || is_extended(VAR_11))
continue;
if (VAR_10 >= 2) {
if (VAR_13 + VAR_14 > VAR_7)
continue;
if (VAR_17 < VAR_2)
continue;
if (VAR_17 + VAR_14 > VAR_2 + VAR_3)
continue;
}
VAR_18 = blkid_partlist_add_partition(VAR_5, VAR_1, VAR_17, VAR_14);
if (!VAR_18)
return -VAR_19;
blkid_partition_set_type(VAR_18, VAR_11->sys_ind);
blkid_partition_set_flags(VAR_18, VAR_11->boot_ind);
blkid_partition_gen_uuid(VAR_18);
VAR_9 = 0;
}
for (VAR_11 = VAR_12, VAR_10 = 0; VAR_10 < 4; VAR_10++, VAR_11++) {
VAR_13 = dos_partition_get_start(VAR_11) * VAR_4;
VAR_14 = dos_partition_get_size(VAR_11) * VAR_4;
if (VAR_14 && is_extended(VAR_11))
break;
}
if (VAR_10 == 4)
goto leave;
VAR_6 = VAR_2 + VAR_13;
VAR_7 = VAR_14;
}
leave:
return VAR_15;
}",util-linux/7164a1c34d18831ac61c6744ad14ce916d389b3f/dos.c/vul/before/0.json,"static int parse_dos_extended(blkid_probe pr, blkid_parttable tab,
		uint32_t ex_start, uint32_t ex_size, int ssf)
{
	blkid_partlist ls = blkid_probe_get_partlist(pr);
	uint32_t cur_start = ex_start, cur_size = ex_size;
	unsigned char *data;
	int ct_nodata = 0;	/* count ext.partitions without data partitions */
	int i;

	DBG(LOWPROBE, ul_debug(""parse EBR [start=%d, size=%d]"", ex_start/ssf, ex_size/ssf));
	if (ex_start == 0) {
		DBG(LOWPROBE, ul_debug(""Bad offset in primary extended partition -- ignore""));
		return 0;
	}

	while (1) {
		struct dos_partition *p, *p0;
		uint32_t start, size;

		if (++ct_nodata > 100)
			return BLKID_PROBE_OK;
		data = blkid_probe_get_sector(pr, cur_start);
		if (!data) {
			if (errno)
				return -errno;
			goto leave;	/* malformed partition? */
		}

		if (!mbr_is_valid_magic(data))
			goto leave;

		p0 = mbr_get_partition(data, 0);

		/* Usually, the first entry is the real data partition,
		 * the 2nd entry is the next extended partition, or empty,
		 * and the 3rd and 4th entries are unused.
		 * However, DRDOS sometimes has the extended partition as
		 * the first entry (when the data partition is empty),
		 * and OS/2 seems to use all four entries.
		 * -- Linux kernel fs/partitions/dos.c
		 *
		 * See also http://en.wikipedia.org/wiki/Extended_boot_record
		 */

		/* Parse data partition */
		for (p = p0, i = 0; i < 4; i++, p++) {
			uint32_t abs_start;
			blkid_partition par;

			/* the start is relative to the parental ext.partition */
			start = dos_partition_get_start(p) * ssf;
			size = dos_partition_get_size(p) * ssf;
			abs_start = cur_start + start;	/* absolute start */

			if (!size || is_extended(p))
				continue;
			if (i >= 2) {
				/* extra checks to detect real data on
				 * 3rd and 4th entries */
				if (start + size > cur_size)
					continue;
				if (abs_start < ex_start)
					continue;
				if (abs_start + size > ex_start + ex_size)
					continue;
			}

			par = blkid_partlist_add_partition(ls, tab, abs_start, size);
			if (!par)
				return -ENOMEM;

			blkid_partition_set_type(par, p->sys_ind);
			blkid_partition_set_flags(par, p->boot_ind);
			blkid_partition_gen_uuid(par);
			ct_nodata = 0;
		}
		/* The first nested ext.partition should be a link to the next
		 * logical partition. Everything other (recursive ext.partitions)
		 * is junk.
		 */
		for (p = p0, i = 0; i < 4; i++, p++) {
			start = dos_partition_get_start(p) * ssf;
			size = dos_partition_get_size(p) * ssf;

			if (size && is_extended(p)) {
				if (start == 0)
					DBG(LOWPROBE, ul_debug(""#%d: EBR link offset is zero -- ignore"", i + 1));
				else
					break;
			}
		}
		if (i == 4)
			goto leave;

		cur_start = ex_start + start;
		cur_size = size;
	}
leave:
	return BLKID_PROBE_OK;
}","static int parse_dos_extended(blkid_probe VAR_0, blkid_parttable VAR_1,
		uint32_t VAR_2, uint32_t VAR_3, int VAR_4)
{
	blkid_partlist VAR_5 = blkid_probe_get_partlist(VAR_0);
	uint32_t VAR_6 = VAR_2, VAR_7 = VAR_3;
	unsigned char *VAR_8;
	int VAR_9 = 0;	/* COMMENT_0 */
	int VAR_10;

	DBG(VAR_11, ul_debug(""parse EBR [start=%d, size=%d]"", VAR_2/VAR_4, VAR_3/VAR_4));
	if (VAR_2 == 0) {
		DBG(VAR_11, ul_debug(""Bad offset in primary extended partition -- ignore""));
		return 0;
	}

	while (1) {
		struct dos_partition *VAR_12, *VAR_13;
		uint32_t VAR_14, VAR_15;

		if (++VAR_9 > 100)
			return VAR_16;
		VAR_8 = blkid_probe_get_sector(VAR_0, VAR_6);
		if (!VAR_8) {
			if (VAR_17)
				return -VAR_17;
			goto leave;	/* COMMENT_1 */
		}

		if (!mbr_is_valid_magic(VAR_8))
			goto leave;

		VAR_13 = mbr_get_partition(VAR_8, 0);

		/* COMMENT_2 */
                                                            
                                            
                                                           
                                                        
                                            
                                        
    
                                                               
     

		/* COMMENT_12 */
		for (VAR_12 = VAR_13, VAR_10 = 0; VAR_10 < 4; VAR_10++, VAR_12++) {
			uint32_t VAR_18;
			blkid_partition VAR_19;

			/* COMMENT_13 */
			VAR_14 = dos_partition_get_start(VAR_12) * VAR_4;
			VAR_15 = dos_partition_get_size(VAR_12) * VAR_4;
			VAR_18 = VAR_6 + VAR_14;	/* COMMENT_14 */

			if (!VAR_15 || is_extended(VAR_12))
				continue;
			if (VAR_10 >= 2) {
				/* COMMENT_15 */
                             
				if (VAR_14 + VAR_15 > VAR_7)
					continue;
				if (VAR_18 < VAR_2)
					continue;
				if (VAR_18 + VAR_15 > VAR_2 + VAR_3)
					continue;
			}

			VAR_19 = blkid_partlist_add_partition(VAR_5, VAR_1, VAR_18, VAR_15);
			if (!VAR_19)
				return -VAR_20;

			blkid_partition_set_type(VAR_19, VAR_12->sys_ind);
			blkid_partition_set_flags(VAR_19, VAR_12->boot_ind);
			blkid_partition_gen_uuid(VAR_19);
			VAR_9 = 0;
		}
		/* COMMENT_17 */
                                                                   
             
     
		for (VAR_12 = VAR_13, VAR_10 = 0; VAR_10 < 4; VAR_10++, VAR_12++) {
			VAR_14 = dos_partition_get_start(VAR_12) * VAR_4;
			VAR_15 = dos_partition_get_size(VAR_12) * VAR_4;

			if (VAR_15 && is_extended(VAR_12)) {
				if (VAR_14 == 0)
					DBG(VAR_11, ul_debug(""#%d: EBR link offset is zero -- ignore"", VAR_10 + 1));
				else
					break;
			}
		}
		if (VAR_10 == 4)
			goto leave;

		VAR_6 = VAR_2 + VAR_14;
		VAR_7 = VAR_15;
	}
leave:
	return VAR_16;
}",util-linux/7164a1c34d18831ac61c6744ad14ce916d389b3f/dos.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,12 @@
 	unsigned char *data;
 	int ct_nodata = 0;	/* count ext.partitions without data partitions */
 	int i;
+
+	DBG(LOWPROBE, ul_debug(""parse EBR [start=%d, size=%d]"", ex_start/ssf, ex_size/ssf));
+	if (ex_start == 0) {
+		DBG(LOWPROBE, ul_debug(""Bad offset in primary extended partition -- ignore""));
+		return 0;
+	}
 
 	while (1) {
 		struct dos_partition *p, *p0;
@@ -76,8 +82,12 @@
 			start = dos_partition_get_start(p) * ssf;
 			size = dos_partition_get_size(p) * ssf;
 
-			if (size && is_extended(p))
-				break;
+			if (size && is_extended(p)) {
+				if (start == 0)
+					DBG(LOWPROBE, ul_debug(""#%d: EBR link offset is zero -- ignore"", i + 1));
+				else
+					break;
+			}
 		}
 		if (i == 4)
 			goto leave;","{'deleted_lines': ['\t\t\tif (size && is_extended(p))', '\t\t\t\tbreak;'], 'added_lines': ['', '\tDBG(LOWPROBE, ul_debug(""parse EBR [start=%d, size=%d]"", ex_start/ssf, ex_size/ssf));', '\tif (ex_start == 0) {', '\t\tDBG(LOWPROBE, ul_debug(""Bad offset in primary extended partition -- ignore""));', '\t\treturn 0;', '\t}', '\t\t\tif (size && is_extended(p)) {', '\t\t\t\tif (start == 0)', '\t\t\t\t\tDBG(LOWPROBE, ul_debug(""#%d: EBR link offset is zero -- ignore"", i + 1));', '\t\t\t\telse', '\t\t\t\t\tbreak;', '\t\t\t}']}",True,The parse_dos_extended function in partitions/dos.c in the libblkid library in util-linux allows physically proximate attackers to cause a denial of service (memory consumption) via a crafted MSDOS partition table with an extended partition boot record at zero offset.,4.6,MEDIUM,1,test,,5
CVE-2017-7477,['CWE-119'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,kernel/git/netdev/net,"We call skb_cow_data, which is good anyway to ensure we can actually
modify the skb as such (another error from prior). Now that we have the
number of fragments required, we can safely allocate exactly that amount
of memory.

Fixes: c09440f7dcb3 (""macsec: introduce IEEE 802.1AE driver"")
Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
Acked-by: Sabrina Dubroca <sd@queasysnail.net>
Signed-off-by: David S. Miller <davem@davemloft.net>
",5294b83086cc1c35b4efeca03644cf9d12282e5b,https://git.kernel.org/pub/scm/linux/kernel/git/davem/net.git/commit/?h=5294b83086cc1c35b4efeca03644cf9d12282e5b,drivers/net/macsec.c,macsec_alloc_req,"static struct aead_request *macsec_alloc_req(struct crypto_aead *tfm,
unsigned char **iv,
struct scatterlist **sg)
{
size_t size, iv_offset, sg_offset;
struct aead_request *req;
void *tmp;
size = sizeof(struct aead_request) + crypto_aead_reqsize(tfm);
iv_offset = size;
size += GCM_AES_IV_LEN;
size = ALIGN(size, __alignof__(struct scatterlist));
sg_offset = size;
size += sizeof(struct scatterlist) * (MAX_SKB_FRAGS + 1);
tmp = kmalloc(size, GFP_ATOMIC);
if (!tmp)
return NULL;
*iv = (unsigned char *)(tmp + iv_offset);
*sg = (struct scatterlist *)(tmp + sg_offset);
req = tmp;
aead_request_set_tfm(req, tfm);
return req;
}","static struct aead_request *macsec_alloc_req(struct crypto_aead *VAR_0,
unsigned char **VAR_1,
struct scatterlist **VAR_2)
{
size_t VAR_3, VAR_4, VAR_5;
struct aead_request *VAR_6;
void *VAR_7;
VAR_3 = sizeof(struct aead_request) + crypto_aead_reqsize(VAR_0);
VAR_4 = VAR_3;
VAR_3 += VAR_8;
VAR_3 = ALIGN(VAR_3, __alignof__(struct scatterlist));
VAR_5 = VAR_3;
VAR_3 += sizeof(struct scatterlist) * (VAR_9 + 1);
VAR_7 = kmalloc(VAR_3, VAR_10);
if (!VAR_7)
return NULL;
*VAR_1 = (unsigned char *)(VAR_7 + VAR_4);
*VAR_2 = (struct scatterlist *)(VAR_7 + VAR_5);
VAR_6 = VAR_7;
aead_request_set_tfm(VAR_6, VAR_0);
return VAR_6;
}",kernel/git/netdev/net/5294b83086cc1c35b4efeca03644cf9d12282e5b/macsec.c/vul/before/0.json,"static struct aead_request *macsec_alloc_req(struct crypto_aead *tfm,
					     unsigned char **iv,
					     struct scatterlist **sg,
					     int num_frags)
{
	size_t size, iv_offset, sg_offset;
	struct aead_request *req;
	void *tmp;

	size = sizeof(struct aead_request) + crypto_aead_reqsize(tfm);
	iv_offset = size;
	size += GCM_AES_IV_LEN;

	size = ALIGN(size, __alignof__(struct scatterlist));
	sg_offset = size;
	size += sizeof(struct scatterlist) * num_frags;

	tmp = kmalloc(size, GFP_ATOMIC);
	if (!tmp)
		return NULL;

	*iv = (unsigned char *)(tmp + iv_offset);
	*sg = (struct scatterlist *)(tmp + sg_offset);
	req = tmp;

	aead_request_set_tfm(req, tfm);

	return req;
}","static struct aead_request *macsec_alloc_req(struct crypto_aead *VAR_0,
					     unsigned char **VAR_1,
					     struct scatterlist **VAR_2,
					     int VAR_3)
{
	size_t VAR_4, VAR_5, VAR_6;
	struct aead_request *VAR_7;
	void *VAR_8;

	VAR_4 = sizeof(struct aead_request) + crypto_aead_reqsize(VAR_0);
	VAR_5 = VAR_4;
	VAR_4 += VAR_9;

	VAR_4 = ALIGN(VAR_4, __alignof__(struct scatterlist));
	VAR_6 = VAR_4;
	VAR_4 += sizeof(struct scatterlist) * VAR_3;

	VAR_8 = kmalloc(VAR_4, VAR_10);
	if (!VAR_8)
		return NULL;

	*VAR_1 = (unsigned char *)(VAR_8 + VAR_5);
	*VAR_2 = (struct scatterlist *)(VAR_8 + VAR_6);
	VAR_7 = VAR_8;

	aead_request_set_tfm(VAR_7, VAR_0);

	return VAR_7;
}",kernel/git/netdev/net/5294b83086cc1c35b4efeca03644cf9d12282e5b/macsec.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,7 @@
 static struct aead_request *macsec_alloc_req(struct crypto_aead *tfm,
 					     unsigned char **iv,
-					     struct scatterlist **sg)
+					     struct scatterlist **sg,
+					     int num_frags)
 {
 	size_t size, iv_offset, sg_offset;
 	struct aead_request *req;
@@ -12,7 +13,7 @@
 
 	size = ALIGN(size, __alignof__(struct scatterlist));
 	sg_offset = size;
-	size += sizeof(struct scatterlist) * (MAX_SKB_FRAGS + 1);
+	size += sizeof(struct scatterlist) * num_frags;
 
 	tmp = kmalloc(size, GFP_ATOMIC);
 	if (!tmp)","{'deleted_lines': ['\t\t\t\t\t     struct scatterlist **sg)', '\tsize += sizeof(struct scatterlist) * (MAX_SKB_FRAGS + 1);'], 'added_lines': ['\t\t\t\t\t     struct scatterlist **sg,', '\t\t\t\t\t     int num_frags)', '\tsize += sizeof(struct scatterlist) * num_frags;']}",True,"Heap-based buffer overflow in drivers/net/macsec.c in the MACsec module in the Linux kernel through 4.10.12 allows attackers to cause a denial of service or possibly have unspecified other impact by leveraging the use of a MAX_SKB_FRAGS+1 size in conjunction with the NETIF_F_FRAGLIST feature, leading to an error in the skb_to_sgvec function.",7.0,HIGH,2,test,,5
CVE-2017-7477,['CWE-119'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,kernel/git/netdev/net,"We call skb_cow_data, which is good anyway to ensure we can actually
modify the skb as such (another error from prior). Now that we have the
number of fragments required, we can safely allocate exactly that amount
of memory.

Fixes: c09440f7dcb3 (""macsec: introduce IEEE 802.1AE driver"")
Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
Acked-by: Sabrina Dubroca <sd@queasysnail.net>
Signed-off-by: David S. Miller <davem@davemloft.net>
",5294b83086cc1c35b4efeca03644cf9d12282e5b,https://git.kernel.org/pub/scm/linux/kernel/git/davem/net.git/commit/?h=5294b83086cc1c35b4efeca03644cf9d12282e5b,drivers/net/macsec.c,macsec_decrypt,"static struct sk_buff *macsec_decrypt(struct sk_buff *skb,
struct net_device *dev,
struct macsec_rx_sa *rx_sa,
sci_t sci,
struct macsec_secy *secy)
{
int ret;
struct scatterlist *sg;
unsigned char *iv;
struct aead_request *req;
struct macsec_eth_header *hdr;
u16 icv_len = secy->icv_len;
macsec_skb_cb(skb)->valid = false;
skb = skb_share_check(skb, GFP_ATOMIC);
if (!skb)
return ERR_PTR(-ENOMEM);
req = macsec_alloc_req(rx_sa->key.tfm, &iv, &sg);
if (!req) {
kfree_skb(skb);
return ERR_PTR(-ENOMEM);
}
hdr = (struct macsec_eth_header *)skb->data;
macsec_fill_iv(iv, sci, ntohl(hdr->packet_number));
sg_init_table(sg, MAX_SKB_FRAGS + 1);
skb_to_sgvec(skb, sg, 0, skb->len);
if (hdr->tci_an & MACSEC_TCI_E) {
int len = skb->len - macsec_hdr_len(macsec_skb_cb(skb)->has_sci);
aead_request_set_crypt(req, sg, sg, len, iv);
aead_request_set_ad(req, macsec_hdr_len(macsec_skb_cb(skb)->has_sci));
skb = skb_unshare(skb, GFP_ATOMIC);
if (!skb) {
aead_request_free(req);
return ERR_PTR(-ENOMEM);
}
} else {
aead_request_set_crypt(req, sg, sg, icv_len, iv);
aead_request_set_ad(req, skb->len - icv_len);
}
macsec_skb_cb(skb)->req = req;
skb->dev = dev;
aead_request_set_callback(req, 0, macsec_decrypt_done, skb);
dev_hold(dev);
ret = crypto_aead_decrypt(req);
if (ret == -EINPROGRESS) {
return ERR_PTR(ret);
} else if (ret != 0) {
if (ret != -EBADMSG) {
kfree_skb(skb);
skb = ERR_PTR(ret);
}
} else {
macsec_skb_cb(skb)->valid = true;
}
dev_put(dev);
aead_request_free(req);
return skb;
}","static struct sk_buff *macsec_decrypt(struct sk_buff *VAR_0,
struct net_device *VAR_1,
struct macsec_rx_sa *VAR_2,
sci_t VAR_3,
struct macsec_secy *VAR_4)
{
int VAR_5;
struct scatterlist *VAR_6;
unsigned char *VAR_7;
struct aead_request *VAR_8;
struct macsec_eth_header *VAR_9;
u16 VAR_10 = VAR_4->icv_len;
macsec_skb_cb(VAR_0)->valid = false;
VAR_0 = skb_share_check(VAR_0, VAR_11);
if (!VAR_0)
return ERR_PTR(-VAR_12);
VAR_8 = macsec_alloc_req(VAR_2->key.tfm, &VAR_7, &VAR_6);
if (!VAR_8) {
kfree_skb(VAR_0);
return ERR_PTR(-VAR_12);
}
VAR_9 = (struct macsec_eth_header *)VAR_0->data;
macsec_fill_iv(VAR_7, VAR_3, ntohl(VAR_9->packet_number));
sg_init_table(VAR_6, VAR_13 + 1);
skb_to_sgvec(VAR_0, VAR_6, 0, VAR_0->len);
if (VAR_9->tci_an & VAR_14) {
int VAR_15 = VAR_0->len - macsec_hdr_len(macsec_skb_cb(VAR_0)->has_sci);
aead_request_set_crypt(VAR_8, VAR_6, VAR_6, VAR_15, VAR_7);
aead_request_set_ad(VAR_8, macsec_hdr_len(macsec_skb_cb(VAR_0)->has_sci));
VAR_0 = skb_unshare(VAR_0, VAR_11);
if (!VAR_0) {
aead_request_free(VAR_8);
return ERR_PTR(-VAR_12);
}
} else {
aead_request_set_crypt(VAR_8, VAR_6, VAR_6, VAR_10, VAR_7);
aead_request_set_ad(VAR_8, VAR_0->len - VAR_10);
}
macsec_skb_cb(VAR_0)->req = VAR_8;
VAR_0->dev = VAR_1;
aead_request_set_callback(VAR_8, 0, VAR_16, VAR_0);
dev_hold(VAR_1);
VAR_5 = crypto_aead_decrypt(VAR_8);
if (VAR_5 == -VAR_17) {
return ERR_PTR(VAR_5);
} else if (VAR_5 != 0) {
if (VAR_5 != -VAR_18) {
kfree_skb(VAR_0);
VAR_0 = ERR_PTR(VAR_5);
}
} else {
macsec_skb_cb(VAR_0)->valid = true;
}
dev_put(VAR_1);
aead_request_free(VAR_8);
return VAR_0;
}",kernel/git/netdev/net/5294b83086cc1c35b4efeca03644cf9d12282e5b/macsec.c/vul/before/1.json,"static struct sk_buff *macsec_decrypt(struct sk_buff *skb,
				      struct net_device *dev,
				      struct macsec_rx_sa *rx_sa,
				      sci_t sci,
				      struct macsec_secy *secy)
{
	int ret;
	struct scatterlist *sg;
	struct sk_buff *trailer;
	unsigned char *iv;
	struct aead_request *req;
	struct macsec_eth_header *hdr;
	u16 icv_len = secy->icv_len;

	macsec_skb_cb(skb)->valid = false;
	skb = skb_share_check(skb, GFP_ATOMIC);
	if (!skb)
		return ERR_PTR(-ENOMEM);

	ret = skb_cow_data(skb, 0, &trailer);
	if (unlikely(ret < 0)) {
		kfree_skb(skb);
		return ERR_PTR(ret);
	}
	req = macsec_alloc_req(rx_sa->key.tfm, &iv, &sg, ret);
	if (!req) {
		kfree_skb(skb);
		return ERR_PTR(-ENOMEM);
	}

	hdr = (struct macsec_eth_header *)skb->data;
	macsec_fill_iv(iv, sci, ntohl(hdr->packet_number));

	sg_init_table(sg, ret);
	skb_to_sgvec(skb, sg, 0, skb->len);

	if (hdr->tci_an & MACSEC_TCI_E) {
		/* confidentiality: ethernet + macsec header
		 * authenticated, encrypted payload
		 */
		int len = skb->len - macsec_hdr_len(macsec_skb_cb(skb)->has_sci);

		aead_request_set_crypt(req, sg, sg, len, iv);
		aead_request_set_ad(req, macsec_hdr_len(macsec_skb_cb(skb)->has_sci));
		skb = skb_unshare(skb, GFP_ATOMIC);
		if (!skb) {
			aead_request_free(req);
			return ERR_PTR(-ENOMEM);
		}
	} else {
		/* integrity only: all headers + data authenticated */
		aead_request_set_crypt(req, sg, sg, icv_len, iv);
		aead_request_set_ad(req, skb->len - icv_len);
	}

	macsec_skb_cb(skb)->req = req;
	skb->dev = dev;
	aead_request_set_callback(req, 0, macsec_decrypt_done, skb);

	dev_hold(dev);
	ret = crypto_aead_decrypt(req);
	if (ret == -EINPROGRESS) {
		return ERR_PTR(ret);
	} else if (ret != 0) {
		/* decryption/authentication failed
		 * 10.6 if validateFrames is disabled, deliver anyway
		 */
		if (ret != -EBADMSG) {
			kfree_skb(skb);
			skb = ERR_PTR(ret);
		}
	} else {
		macsec_skb_cb(skb)->valid = true;
	}
	dev_put(dev);

	aead_request_free(req);

	return skb;
}","static struct sk_buff *macsec_decrypt(struct sk_buff *VAR_0,
				      struct net_device *VAR_1,
				      struct macsec_rx_sa *VAR_2,
				      sci_t VAR_3,
				      struct macsec_secy *VAR_4)
{
	int VAR_5;
	struct scatterlist *VAR_6;
	struct sk_buff *VAR_7;
	unsigned char *VAR_8;
	struct aead_request *VAR_9;
	struct macsec_eth_header *VAR_10;
	u16 VAR_11 = VAR_4->icv_len;

	macsec_skb_cb(VAR_0)->valid = false;
	VAR_0 = skb_share_check(VAR_0, VAR_12);
	if (!VAR_0)
		return ERR_PTR(-VAR_13);

	VAR_5 = skb_cow_data(VAR_0, 0, &VAR_7);
	if (unlikely(VAR_5 < 0)) {
		kfree_skb(VAR_0);
		return ERR_PTR(VAR_5);
	}
	VAR_9 = macsec_alloc_req(VAR_2->key.tfm, &VAR_8, &VAR_6, VAR_5);
	if (!VAR_9) {
		kfree_skb(VAR_0);
		return ERR_PTR(-VAR_13);
	}

	VAR_10 = (struct macsec_eth_header *)VAR_0->data;
	macsec_fill_iv(VAR_8, VAR_3, ntohl(VAR_10->packet_number));

	sg_init_table(VAR_6, VAR_5);
	skb_to_sgvec(VAR_0, VAR_6, 0, VAR_0->len);

	if (VAR_10->tci_an & VAR_14) {
		/* COMMENT_0 */
                                     
     
		int VAR_15 = VAR_0->len - macsec_hdr_len(macsec_skb_cb(VAR_0)->has_sci);

		aead_request_set_crypt(VAR_9, VAR_6, VAR_6, VAR_15, VAR_8);
		aead_request_set_ad(VAR_9, macsec_hdr_len(macsec_skb_cb(VAR_0)->has_sci));
		VAR_0 = skb_unshare(VAR_0, VAR_12);
		if (!VAR_0) {
			aead_request_free(VAR_9);
			return ERR_PTR(-VAR_13);
		}
	} else {
		/* COMMENT_3 */
		aead_request_set_crypt(VAR_9, VAR_6, VAR_6, VAR_11, VAR_8);
		aead_request_set_ad(VAR_9, VAR_0->len - VAR_11);
	}

	macsec_skb_cb(VAR_0)->req = VAR_9;
	VAR_0->dev = VAR_1;
	aead_request_set_callback(VAR_9, 0, VAR_16, VAR_0);

	dev_hold(VAR_1);
	VAR_5 = crypto_aead_decrypt(VAR_9);
	if (VAR_5 == -VAR_17) {
		return ERR_PTR(VAR_5);
	} else if (VAR_5 != 0) {
		/* COMMENT_4 */
                                                       
     
		if (VAR_5 != -VAR_18) {
			kfree_skb(VAR_0);
			VAR_0 = ERR_PTR(VAR_5);
		}
	} else {
		macsec_skb_cb(VAR_0)->valid = true;
	}
	dev_put(VAR_1);

	aead_request_free(VAR_9);

	return VAR_0;
}",kernel/git/netdev/net/5294b83086cc1c35b4efeca03644cf9d12282e5b/macsec.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -6,6 +6,7 @@
 {
 	int ret;
 	struct scatterlist *sg;
+	struct sk_buff *trailer;
 	unsigned char *iv;
 	struct aead_request *req;
 	struct macsec_eth_header *hdr;
@@ -16,7 +17,12 @@
 	if (!skb)
 		return ERR_PTR(-ENOMEM);
 
-	req = macsec_alloc_req(rx_sa->key.tfm, &iv, &sg);
+	ret = skb_cow_data(skb, 0, &trailer);
+	if (unlikely(ret < 0)) {
+		kfree_skb(skb);
+		return ERR_PTR(ret);
+	}
+	req = macsec_alloc_req(rx_sa->key.tfm, &iv, &sg, ret);
 	if (!req) {
 		kfree_skb(skb);
 		return ERR_PTR(-ENOMEM);
@@ -25,7 +31,7 @@
 	hdr = (struct macsec_eth_header *)skb->data;
 	macsec_fill_iv(iv, sci, ntohl(hdr->packet_number));
 
-	sg_init_table(sg, MAX_SKB_FRAGS + 1);
+	sg_init_table(sg, ret);
 	skb_to_sgvec(skb, sg, 0, skb->len);
 
 	if (hdr->tci_an & MACSEC_TCI_E) {","{'deleted_lines': ['\treq = macsec_alloc_req(rx_sa->key.tfm, &iv, &sg);', '\tsg_init_table(sg, MAX_SKB_FRAGS + 1);'], 'added_lines': ['\tstruct sk_buff *trailer;', '\tret = skb_cow_data(skb, 0, &trailer);', '\tif (unlikely(ret < 0)) {', '\t\tkfree_skb(skb);', '\t\treturn ERR_PTR(ret);', '\t}', '\treq = macsec_alloc_req(rx_sa->key.tfm, &iv, &sg, ret);', '\tsg_init_table(sg, ret);']}",True,"Heap-based buffer overflow in drivers/net/macsec.c in the MACsec module in the Linux kernel through 4.10.12 allows attackers to cause a denial of service or possibly have unspecified other impact by leveraging the use of a MAX_SKB_FRAGS+1 size in conjunction with the NETIF_F_FRAGLIST feature, leading to an error in the skb_to_sgvec function.",7.0,HIGH,2,test,,5
CVE-2017-7477,['CWE-119'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,kernel/git/netdev/net,"We call skb_cow_data, which is good anyway to ensure we can actually
modify the skb as such (another error from prior). Now that we have the
number of fragments required, we can safely allocate exactly that amount
of memory.

Fixes: c09440f7dcb3 (""macsec: introduce IEEE 802.1AE driver"")
Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
Acked-by: Sabrina Dubroca <sd@queasysnail.net>
Signed-off-by: David S. Miller <davem@davemloft.net>
",5294b83086cc1c35b4efeca03644cf9d12282e5b,https://git.kernel.org/pub/scm/linux/kernel/git/davem/net.git/commit/?h=5294b83086cc1c35b4efeca03644cf9d12282e5b,drivers/net/macsec.c,macsec_encrypt,"static struct sk_buff *macsec_encrypt(struct sk_buff *skb,
struct net_device *dev)
{
int ret;
struct scatterlist *sg;
unsigned char *iv;
struct ethhdr *eth;
struct macsec_eth_header *hh;
size_t unprotected_len;
struct aead_request *req;
struct macsec_secy *secy;
struct macsec_tx_sc *tx_sc;
struct macsec_tx_sa *tx_sa;
struct macsec_dev *macsec = macsec_priv(dev);
bool sci_present;
u32 pn;
secy = &macsec->secy;
tx_sc = &secy->tx_sc;
tx_sa = macsec_txsa_get(tx_sc->sa[tx_sc->encoding_sa]);
if (!tx_sa) {
secy->operational = false;
kfree_skb(skb);
return ERR_PTR(-EINVAL);
}
if (unlikely(skb_headroom(skb) < MACSEC_NEEDED_HEADROOM ||
skb_tailroom(skb) < MACSEC_NEEDED_TAILROOM)) {
struct sk_buff *nskb = skb_copy_expand(skb,
MACSEC_NEEDED_HEADROOM,
MACSEC_NEEDED_TAILROOM,
GFP_ATOMIC);
if (likely(nskb)) {
consume_skb(skb);
skb = nskb;
} else {
macsec_txsa_put(tx_sa);
kfree_skb(skb);
return ERR_PTR(-ENOMEM);
}
} else {
skb = skb_unshare(skb, GFP_ATOMIC);
if (!skb) {
macsec_txsa_put(tx_sa);
return ERR_PTR(-ENOMEM);
}
}
unprotected_len = skb->len;
eth = eth_hdr(skb);
sci_present = send_sci(secy);
hh = (struct macsec_eth_header *)skb_push(skb, macsec_extra_len(sci_present));
memmove(hh, eth, 2 * ETH_ALEN);
pn = tx_sa_update_pn(tx_sa, secy);
if (pn == 0) {
macsec_txsa_put(tx_sa);
kfree_skb(skb);
return ERR_PTR(-ENOLINK);
}
macsec_fill_sectag(hh, secy, pn, sci_present);
macsec_set_shortlen(hh, unprotected_len - 2 * ETH_ALEN);
skb_put(skb, secy->icv_len);
if (skb->len - ETH_HLEN > macsec_priv(dev)->real_dev->mtu) {
struct pcpu_secy_stats *secy_stats = this_cpu_ptr(macsec->stats);
u64_stats_update_begin(&secy_stats->syncp);
secy_stats->stats.OutPktsTooLong++;
u64_stats_update_end(&secy_stats->syncp);
macsec_txsa_put(tx_sa);
kfree_skb(skb);
return ERR_PTR(-EINVAL);
}
req = macsec_alloc_req(tx_sa->key.tfm, &iv, &sg);
if (!req) {
macsec_txsa_put(tx_sa);
kfree_skb(skb);
return ERR_PTR(-ENOMEM);
}
macsec_fill_iv(iv, secy->sci, pn);
sg_init_table(sg, MAX_SKB_FRAGS + 1);
skb_to_sgvec(skb, sg, 0, skb->len);
if (tx_sc->encrypt) {
int len = skb->len - macsec_hdr_len(sci_present) -
secy->icv_len;
aead_request_set_crypt(req, sg, sg, len, iv);
aead_request_set_ad(req, macsec_hdr_len(sci_present));
} else {
aead_request_set_crypt(req, sg, sg, 0, iv);
aead_request_set_ad(req, skb->len - secy->icv_len);
}
macsec_skb_cb(skb)->req = req;
macsec_skb_cb(skb)->tx_sa = tx_sa;
aead_request_set_callback(req, 0, macsec_encrypt_done, skb);
dev_hold(skb->dev);
ret = crypto_aead_encrypt(req);
if (ret == -EINPROGRESS) {
return ERR_PTR(ret);
} else if (ret != 0) {
dev_put(skb->dev);
kfree_skb(skb);
aead_request_free(req);
macsec_txsa_put(tx_sa);
return ERR_PTR(-EINVAL);
}
dev_put(skb->dev);
aead_request_free(req);
macsec_txsa_put(tx_sa);
return skb;
}","static struct sk_buff *macsec_encrypt(struct sk_buff *VAR_0,
struct net_device *VAR_1)
{
int VAR_2;
struct scatterlist *VAR_3;
unsigned char *VAR_4;
struct ethhdr *VAR_5;
struct macsec_eth_header *VAR_6;
size_t VAR_7;
struct aead_request *VAR_8;
struct macsec_secy *VAR_9;
struct macsec_tx_sc *VAR_10;
struct macsec_tx_sa *VAR_11;
struct macsec_dev *VAR_12 = macsec_priv(VAR_1);
bool VAR_13;
u32 VAR_14;
VAR_9 = &VAR_12->secy;
VAR_10 = &VAR_9->tx_sc;
VAR_11 = macsec_txsa_get(VAR_10->sa[VAR_10->encoding_sa]);
if (!VAR_11) {
VAR_9->operational = false;
kfree_skb(VAR_0);
return ERR_PTR(-VAR_15);
}
if (unlikely(skb_headroom(VAR_0) < VAR_16 ||
skb_tailroom(VAR_0) < VAR_17)) {
struct sk_buff *VAR_18 = skb_copy_expand(VAR_0,
VAR_16,
VAR_17,
VAR_19);
if (likely(VAR_18)) {
consume_skb(VAR_0);
VAR_0 = VAR_18;
} else {
macsec_txsa_put(VAR_11);
kfree_skb(VAR_0);
return ERR_PTR(-VAR_20);
}
} else {
VAR_0 = skb_unshare(VAR_0, VAR_19);
if (!VAR_0) {
macsec_txsa_put(VAR_11);
return ERR_PTR(-VAR_20);
}
}
VAR_7 = VAR_0->len;
VAR_5 = eth_hdr(VAR_0);
VAR_13 = send_sci(VAR_9);
VAR_6 = (struct macsec_eth_header *)skb_push(VAR_0, macsec_extra_len(VAR_13));
memmove(VAR_6, VAR_5, 2 * VAR_21);
VAR_14 = tx_sa_update_pn(VAR_11, VAR_9);
if (VAR_14 == 0) {
macsec_txsa_put(VAR_11);
kfree_skb(VAR_0);
return ERR_PTR(-VAR_22);
}
macsec_fill_sectag(VAR_6, VAR_9, VAR_14, VAR_13);
macsec_set_shortlen(VAR_6, VAR_7 - 2 * VAR_21);
skb_put(VAR_0, VAR_9->icv_len);
if (VAR_0->len - VAR_23 > macsec_priv(VAR_1)->real_dev->mtu) {
struct pcpu_secy_stats *VAR_24 = this_cpu_ptr(VAR_12->stats);
u64_stats_update_begin(&VAR_24->syncp);
VAR_24->stats.OutPktsTooLong++;
u64_stats_update_end(&VAR_24->syncp);
macsec_txsa_put(VAR_11);
kfree_skb(VAR_0);
return ERR_PTR(-VAR_15);
}
VAR_8 = macsec_alloc_req(VAR_11->key.tfm, &VAR_4, &VAR_3);
if (!VAR_8) {
macsec_txsa_put(VAR_11);
kfree_skb(VAR_0);
return ERR_PTR(-VAR_20);
}
macsec_fill_iv(VAR_4, VAR_9->sci, VAR_14);
sg_init_table(VAR_3, VAR_25 + 1);
skb_to_sgvec(VAR_0, VAR_3, 0, VAR_0->len);
if (VAR_10->encrypt) {
int VAR_26 = VAR_0->len - macsec_hdr_len(VAR_13) -
VAR_9->icv_len;
aead_request_set_crypt(VAR_8, VAR_3, VAR_3, VAR_26, VAR_4);
aead_request_set_ad(VAR_8, macsec_hdr_len(VAR_13));
} else {
aead_request_set_crypt(VAR_8, VAR_3, VAR_3, 0, VAR_4);
aead_request_set_ad(VAR_8, VAR_0->len - VAR_9->icv_len);
}
macsec_skb_cb(VAR_0)->req = VAR_8;
macsec_skb_cb(VAR_0)->tx_sa = VAR_11;
aead_request_set_callback(VAR_8, 0, VAR_27, VAR_0);
dev_hold(VAR_0->dev);
VAR_2 = crypto_aead_encrypt(VAR_8);
if (VAR_2 == -VAR_28) {
return ERR_PTR(VAR_2);
} else if (VAR_2 != 0) {
dev_put(VAR_0->dev);
kfree_skb(VAR_0);
aead_request_free(VAR_8);
macsec_txsa_put(VAR_11);
return ERR_PTR(-VAR_15);
}
dev_put(VAR_0->dev);
aead_request_free(VAR_8);
macsec_txsa_put(VAR_11);
return VAR_0;
}",kernel/git/netdev/net/5294b83086cc1c35b4efeca03644cf9d12282e5b/macsec.c/vul/before/2.json,"static struct sk_buff *macsec_encrypt(struct sk_buff *skb,
				      struct net_device *dev)
{
	int ret;
	struct scatterlist *sg;
	struct sk_buff *trailer;
	unsigned char *iv;
	struct ethhdr *eth;
	struct macsec_eth_header *hh;
	size_t unprotected_len;
	struct aead_request *req;
	struct macsec_secy *secy;
	struct macsec_tx_sc *tx_sc;
	struct macsec_tx_sa *tx_sa;
	struct macsec_dev *macsec = macsec_priv(dev);
	bool sci_present;
	u32 pn;

	secy = &macsec->secy;
	tx_sc = &secy->tx_sc;

	/* 10.5.1 TX SA assignment */
	tx_sa = macsec_txsa_get(tx_sc->sa[tx_sc->encoding_sa]);
	if (!tx_sa) {
		secy->operational = false;
		kfree_skb(skb);
		return ERR_PTR(-EINVAL);
	}

	if (unlikely(skb_headroom(skb) < MACSEC_NEEDED_HEADROOM ||
		     skb_tailroom(skb) < MACSEC_NEEDED_TAILROOM)) {
		struct sk_buff *nskb = skb_copy_expand(skb,
						       MACSEC_NEEDED_HEADROOM,
						       MACSEC_NEEDED_TAILROOM,
						       GFP_ATOMIC);
		if (likely(nskb)) {
			consume_skb(skb);
			skb = nskb;
		} else {
			macsec_txsa_put(tx_sa);
			kfree_skb(skb);
			return ERR_PTR(-ENOMEM);
		}
	} else {
		skb = skb_unshare(skb, GFP_ATOMIC);
		if (!skb) {
			macsec_txsa_put(tx_sa);
			return ERR_PTR(-ENOMEM);
		}
	}

	unprotected_len = skb->len;
	eth = eth_hdr(skb);
	sci_present = send_sci(secy);
	hh = (struct macsec_eth_header *)skb_push(skb, macsec_extra_len(sci_present));
	memmove(hh, eth, 2 * ETH_ALEN);

	pn = tx_sa_update_pn(tx_sa, secy);
	if (pn == 0) {
		macsec_txsa_put(tx_sa);
		kfree_skb(skb);
		return ERR_PTR(-ENOLINK);
	}
	macsec_fill_sectag(hh, secy, pn, sci_present);
	macsec_set_shortlen(hh, unprotected_len - 2 * ETH_ALEN);

	skb_put(skb, secy->icv_len);

	if (skb->len - ETH_HLEN > macsec_priv(dev)->real_dev->mtu) {
		struct pcpu_secy_stats *secy_stats = this_cpu_ptr(macsec->stats);

		u64_stats_update_begin(&secy_stats->syncp);
		secy_stats->stats.OutPktsTooLong++;
		u64_stats_update_end(&secy_stats->syncp);

		macsec_txsa_put(tx_sa);
		kfree_skb(skb);
		return ERR_PTR(-EINVAL);
	}

	ret = skb_cow_data(skb, 0, &trailer);
	if (unlikely(ret < 0)) {
		macsec_txsa_put(tx_sa);
		kfree_skb(skb);
		return ERR_PTR(ret);
	}

	req = macsec_alloc_req(tx_sa->key.tfm, &iv, &sg, ret);
	if (!req) {
		macsec_txsa_put(tx_sa);
		kfree_skb(skb);
		return ERR_PTR(-ENOMEM);
	}

	macsec_fill_iv(iv, secy->sci, pn);

	sg_init_table(sg, ret);
	skb_to_sgvec(skb, sg, 0, skb->len);

	if (tx_sc->encrypt) {
		int len = skb->len - macsec_hdr_len(sci_present) -
			  secy->icv_len;
		aead_request_set_crypt(req, sg, sg, len, iv);
		aead_request_set_ad(req, macsec_hdr_len(sci_present));
	} else {
		aead_request_set_crypt(req, sg, sg, 0, iv);
		aead_request_set_ad(req, skb->len - secy->icv_len);
	}

	macsec_skb_cb(skb)->req = req;
	macsec_skb_cb(skb)->tx_sa = tx_sa;
	aead_request_set_callback(req, 0, macsec_encrypt_done, skb);

	dev_hold(skb->dev);
	ret = crypto_aead_encrypt(req);
	if (ret == -EINPROGRESS) {
		return ERR_PTR(ret);
	} else if (ret != 0) {
		dev_put(skb->dev);
		kfree_skb(skb);
		aead_request_free(req);
		macsec_txsa_put(tx_sa);
		return ERR_PTR(-EINVAL);
	}

	dev_put(skb->dev);
	aead_request_free(req);
	macsec_txsa_put(tx_sa);

	return skb;
}","static struct sk_buff *macsec_encrypt(struct sk_buff *VAR_0,
				      struct net_device *VAR_1)
{
	int VAR_2;
	struct scatterlist *VAR_3;
	struct sk_buff *VAR_4;
	unsigned char *VAR_5;
	struct ethhdr *VAR_6;
	struct macsec_eth_header *VAR_7;
	size_t VAR_8;
	struct aead_request *VAR_9;
	struct macsec_secy *VAR_10;
	struct macsec_tx_sc *VAR_11;
	struct macsec_tx_sa *VAR_12;
	struct macsec_dev *VAR_13 = macsec_priv(VAR_1);
	bool VAR_14;
	u32 VAR_15;

	VAR_10 = &VAR_13->secy;
	VAR_11 = &VAR_10->tx_sc;

	/* COMMENT_0 */
	VAR_12 = macsec_txsa_get(VAR_11->sa[VAR_11->encoding_sa]);
	if (!VAR_12) {
		VAR_10->operational = false;
		kfree_skb(VAR_0);
		return ERR_PTR(-VAR_16);
	}

	if (unlikely(skb_headroom(VAR_0) < VAR_17 ||
		     skb_tailroom(VAR_0) < VAR_18)) {
		struct sk_buff *VAR_19 = skb_copy_expand(VAR_0,
						       VAR_17,
						       VAR_18,
						       VAR_20);
		if (likely(VAR_19)) {
			consume_skb(VAR_0);
			VAR_0 = VAR_19;
		} else {
			macsec_txsa_put(VAR_12);
			kfree_skb(VAR_0);
			return ERR_PTR(-VAR_21);
		}
	} else {
		VAR_0 = skb_unshare(VAR_0, VAR_20);
		if (!VAR_0) {
			macsec_txsa_put(VAR_12);
			return ERR_PTR(-VAR_21);
		}
	}

	VAR_8 = VAR_0->len;
	VAR_6 = eth_hdr(VAR_0);
	VAR_14 = send_sci(VAR_10);
	VAR_7 = (struct macsec_eth_header *)skb_push(VAR_0, macsec_extra_len(VAR_14));
	memmove(VAR_7, VAR_6, 2 * VAR_22);

	VAR_15 = tx_sa_update_pn(VAR_12, VAR_10);
	if (VAR_15 == 0) {
		macsec_txsa_put(VAR_12);
		kfree_skb(VAR_0);
		return ERR_PTR(-VAR_23);
	}
	macsec_fill_sectag(VAR_7, VAR_10, VAR_15, VAR_14);
	macsec_set_shortlen(VAR_7, VAR_8 - 2 * VAR_22);

	skb_put(VAR_0, VAR_10->icv_len);

	if (VAR_0->len - VAR_24 > macsec_priv(VAR_1)->real_dev->mtu) {
		struct pcpu_secy_stats *VAR_25 = this_cpu_ptr(VAR_13->stats);

		u64_stats_update_begin(&VAR_25->syncp);
		VAR_25->stats.OutPktsTooLong++;
		u64_stats_update_end(&VAR_25->syncp);

		macsec_txsa_put(VAR_12);
		kfree_skb(VAR_0);
		return ERR_PTR(-VAR_16);
	}

	VAR_2 = skb_cow_data(VAR_0, 0, &VAR_4);
	if (unlikely(VAR_2 < 0)) {
		macsec_txsa_put(VAR_12);
		kfree_skb(VAR_0);
		return ERR_PTR(VAR_2);
	}

	VAR_9 = macsec_alloc_req(VAR_12->key.tfm, &VAR_5, &VAR_3, VAR_2);
	if (!VAR_9) {
		macsec_txsa_put(VAR_12);
		kfree_skb(VAR_0);
		return ERR_PTR(-VAR_21);
	}

	macsec_fill_iv(VAR_5, VAR_10->sci, VAR_15);

	sg_init_table(VAR_3, VAR_2);
	skb_to_sgvec(VAR_0, VAR_3, 0, VAR_0->len);

	if (VAR_11->encrypt) {
		int VAR_26 = VAR_0->len - macsec_hdr_len(VAR_14) -
			  VAR_10->icv_len;
		aead_request_set_crypt(VAR_9, VAR_3, VAR_3, VAR_26, VAR_5);
		aead_request_set_ad(VAR_9, macsec_hdr_len(VAR_14));
	} else {
		aead_request_set_crypt(VAR_9, VAR_3, VAR_3, 0, VAR_5);
		aead_request_set_ad(VAR_9, VAR_0->len - VAR_10->icv_len);
	}

	macsec_skb_cb(VAR_0)->req = VAR_9;
	macsec_skb_cb(VAR_0)->tx_sa = VAR_12;
	aead_request_set_callback(VAR_9, 0, VAR_27, VAR_0);

	dev_hold(VAR_0->dev);
	VAR_2 = crypto_aead_encrypt(VAR_9);
	if (VAR_2 == -VAR_28) {
		return ERR_PTR(VAR_2);
	} else if (VAR_2 != 0) {
		dev_put(VAR_0->dev);
		kfree_skb(VAR_0);
		aead_request_free(VAR_9);
		macsec_txsa_put(VAR_12);
		return ERR_PTR(-VAR_16);
	}

	dev_put(VAR_0->dev);
	aead_request_free(VAR_9);
	macsec_txsa_put(VAR_12);

	return VAR_0;
}",kernel/git/netdev/net/5294b83086cc1c35b4efeca03644cf9d12282e5b/macsec.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -3,6 +3,7 @@
 {
 	int ret;
 	struct scatterlist *sg;
+	struct sk_buff *trailer;
 	unsigned char *iv;
 	struct ethhdr *eth;
 	struct macsec_eth_header *hh;
@@ -77,7 +78,14 @@
 		return ERR_PTR(-EINVAL);
 	}
 
-	req = macsec_alloc_req(tx_sa->key.tfm, &iv, &sg);
+	ret = skb_cow_data(skb, 0, &trailer);
+	if (unlikely(ret < 0)) {
+		macsec_txsa_put(tx_sa);
+		kfree_skb(skb);
+		return ERR_PTR(ret);
+	}
+
+	req = macsec_alloc_req(tx_sa->key.tfm, &iv, &sg, ret);
 	if (!req) {
 		macsec_txsa_put(tx_sa);
 		kfree_skb(skb);
@@ -86,7 +94,7 @@
 
 	macsec_fill_iv(iv, secy->sci, pn);
 
-	sg_init_table(sg, MAX_SKB_FRAGS + 1);
+	sg_init_table(sg, ret);
 	skb_to_sgvec(skb, sg, 0, skb->len);
 
 	if (tx_sc->encrypt) {","{'deleted_lines': ['\treq = macsec_alloc_req(tx_sa->key.tfm, &iv, &sg);', '\tsg_init_table(sg, MAX_SKB_FRAGS + 1);'], 'added_lines': ['\tstruct sk_buff *trailer;', '\tret = skb_cow_data(skb, 0, &trailer);', '\tif (unlikely(ret < 0)) {', '\t\tmacsec_txsa_put(tx_sa);', '\t\tkfree_skb(skb);', '\t\treturn ERR_PTR(ret);', '\t}', '', '\treq = macsec_alloc_req(tx_sa->key.tfm, &iv, &sg, ret);', '\tsg_init_table(sg, ret);']}",True,"Heap-based buffer overflow in drivers/net/macsec.c in the MACsec module in the Linux kernel through 4.10.12 allows attackers to cause a denial of service or possibly have unspecified other impact by leveraging the use of a MAX_SKB_FRAGS+1 size in conjunction with the NETIF_F_FRAGLIST feature, leading to an error in the skb_to_sgvec function.",7.0,HIGH,2,test,,5
CVE-2017-8287,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,freetype/freetype2,"Reported as

  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=941
",3774fc08b502c3e685afca098b6e8a195aded6a0,http://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=3774fc08b502c3e685afca098b6e8a195aded6a0,src/psaux/psobjs.c,t1_builder_close_contour,"FT_LOCAL_DEF( void )
t1_builder_close_contour( T1_Builder  builder )
{
FT_Outline*  outline = builder->current;
FT_Int       first;
if ( !outline )
return;
first = outline->n_contours <= 1
? 0 : outline->contours[outline->n_contours - 2] + 1;
if ( outline->n_points > 1 )
{
FT_Vector*  p1      = outline->points + first;
FT_Vector*  p2      = outline->points + outline->n_points - 1;
FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points - 1;
if ( p1->x == p2->x && p1->y == p2->y )
if ( *control == FT_CURVE_TAG_ON )
outline->n_points--;
}
if ( outline->n_contours > 0 )
{
if ( first == outline->n_points - 1 )
{
outline->n_contours--;
outline->n_points--;
}
else
outline->contours[outline->n_contours - 1] =
(short)( outline->n_points - 1 );
}
}","VAR_0( void )
t1_builder_close_contour( T1_Builder  VAR_1 )
{
FT_Outline*  VAR_2 = VAR_1->current;
FT_Int       VAR_3;
if ( !VAR_2 )
return;
VAR_3 = VAR_2->n_contours <= 1
? 0 : VAR_2->contours[VAR_2->n_contours - 2] + 1;
if ( VAR_2->n_points > 1 )
{
FT_Vector*  VAR_4      = VAR_2->points + VAR_3;
FT_Vector*  VAR_5      = VAR_2->points + VAR_2->n_points - 1;
FT_Byte*    VAR_6 = (FT_Byte*)VAR_2->tags + VAR_2->n_points - 1;
if ( VAR_4->x == VAR_5->x && VAR_4->y == VAR_5->y )
if ( *VAR_6 == VAR_7 )
VAR_2->n_points--;
}
if ( VAR_2->n_contours > 0 )
{
if ( VAR_3 == VAR_2->n_points - 1 )
{
VAR_2->n_contours--;
VAR_2->n_points--;
}
else
VAR_2->contours[VAR_2->n_contours - 1] =
(short)( VAR_2->n_points - 1 );
}
}",,"FT_LOCAL_DEF( void )
  t1_builder_close_contour( T1_Builder  builder )
  {
    FT_Outline*  outline = builder->current;
    FT_Int       first;


    if ( !outline )
      return;

    first = outline->n_contours <= 1
            ? 0 : outline->contours[outline->n_contours - 2] + 1;

    /* in malformed fonts it can happen that a contour was started */
    /* but no points were added                                    */
    if ( outline->n_contours && first == outline->n_points )
    {
      outline->n_contours--;
      return;
    }

    /* We must not include the last point in the path if it */
    /* is located on the first point.                       */
    if ( outline->n_points > 1 )
    {
      FT_Vector*  p1      = outline->points + first;
      FT_Vector*  p2      = outline->points + outline->n_points - 1;
      FT_Byte*    control = (FT_Byte*)outline->tags + outline->n_points - 1;


      /* `delete' last point only if it coincides with the first */
      /* point and it is not a control point (which can happen). */
      if ( p1->x == p2->x && p1->y == p2->y )
        if ( *control == FT_CURVE_TAG_ON )
          outline->n_points--;
    }

    if ( outline->n_contours > 0 )
    {
      /* Don't add contours only consisting of one point, i.e.,  */
      /* check whether the first and the last point is the same. */
      if ( first == outline->n_points - 1 )
      {
        outline->n_contours--;
        outline->n_points--;
      }
      else
        outline->contours[outline->n_contours - 1] =
          (short)( outline->n_points - 1 );
    }
  }","VAR_0( void )
  t1_builder_close_contour( T1_Builder  VAR_1 )
  {
    FT_Outline*  VAR_2 = VAR_1->current;
    FT_Int       VAR_3;


    if ( !VAR_2 )
      return;

    VAR_3 = VAR_2->n_contours <= 1
            ? 0 : VAR_2->contours[VAR_2->n_contours - 2] + 1;

    /* COMMENT_0 */
    /* COMMENT_1 */
    if ( VAR_2->n_contours && VAR_3 == VAR_2->n_points )
    {
      VAR_2->n_contours--;
      return;
    }

    /* COMMENT_2 */
    /* COMMENT_3 */
    if ( VAR_2->n_points > 1 )
    {
      FT_Vector*  VAR_4      = VAR_2->points + VAR_3;
      FT_Vector*  VAR_5      = VAR_2->points + VAR_2->n_points - 1;
      FT_Byte*    VAR_6 = (FT_Byte*)VAR_2->tags + VAR_2->n_points - 1;


      /* COMMENT_4 */
      /* COMMENT_5 */
      if ( VAR_4->x == VAR_5->x && VAR_4->y == VAR_5->y )
        if ( *VAR_6 == VAR_7 )
          VAR_2->n_points--;
    }

    if ( VAR_2->n_contours > 0 )
    {
      /* COMMENT_6 */
      /* COMMENT_7 */
      if ( VAR_3 == VAR_2->n_points - 1 )
      {
        VAR_2->n_contours--;
        VAR_2->n_points--;
      }
      else
        VAR_2->contours[VAR_2->n_contours - 1] =
          (short)( VAR_2->n_points - 1 );
    }
  }",,"--- func_before
+++ func_after
@@ -10,6 +10,14 @@
 
     first = outline->n_contours <= 1
             ? 0 : outline->contours[outline->n_contours - 2] + 1;
+
+    /* in malformed fonts it can happen that a contour was started */
+    /* but no points were added                                    */
+    if ( outline->n_contours && first == outline->n_points )
+    {
+      outline->n_contours--;
+      return;
+    }
 
     /* We must not include the last point in the path if it */
     /* is located on the first point.                       */","{'deleted_lines': [], 'added_lines': ['', '    /* in malformed fonts it can happen that a contour was started */', '    /* but no points were added                                    */', '    if ( outline->n_contours && first == outline->n_points )', '    {', '      outline->n_contours--;', '      return;', '    }']}",True,FreeType 2 before 2017-03-26 has an out-of-bounds write caused by a heap-based buffer overflow related to the t1_builder_close_contour function in psaux/psobjs.c.,9.8,CRITICAL,3,test,,5
CVE-2017-0592,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"FLACExtractor: copy protect mWriteBuffer

Bug: 30895578
Change-Id: I4cba36bbe3502678210e5925181683df9726b431
",acc192347665943ca674acf117e4f74a88436922,https://android.googlesource.com/platform/frameworks/av/+/acc192347665943ca674acf117e4f74a88436922,media/libstagefright/FLACExtractor.cpp,copyStereo16,"static void copyStereo16(
short *dst,
const int *const *src,
unsigned nSamples,
unsigned ) {
for (unsigned i = 0; i < nSamples; ++i) {
*dst++ = src[0][i];
*dst++ = src[1][i];
}
}","static void copyStereo16(
short *VAR_0,
const int *const *VAR_1,
unsigned VAR_2,
unsigned ) {
for (unsigned VAR_3 = 0; VAR_3 < VAR_2; ++VAR_3) {
*VAR_0++ = VAR_1[0][VAR_3];
*VAR_0++ = VAR_1[1][VAR_3];
}
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/before/0.json,"static void copyStereo16(
        short *dst,
        const int * src[FLACParser::kMaxChannels],
        unsigned nSamples,
        unsigned /* nChannels */) {
    for (unsigned i = 0; i < nSamples; ++i) {
        *dst++ = src[0][i];
        *dst++ = src[1][i];
    }
}","static void copyStereo16(
        short *VAR_0,
        const int * VAR_1[FLACParser::kMaxChannels],
        unsigned VAR_2,
        unsigned /* COMMENT_0 */) {
    for (unsigned VAR_3 = 0; VAR_3 < VAR_2; ++VAR_3) {
        *VAR_0++ = VAR_1[0][VAR_3];
        *VAR_0++ = VAR_1[1][VAR_3];
    }
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static void copyStereo16(
         short *dst,
-        const int *const *src,
+        const int * src[FLACParser::kMaxChannels],
         unsigned nSamples,
         unsigned /* nChannels */) {
     for (unsigned i = 0; i < nSamples; ++i) {","{'deleted_lines': ['        const int *const *src,'], 'added_lines': ['        const int * src[FLACParser::kMaxChannels],']}",True,"A remote code execution vulnerability in FLACExtractor.cpp in libstagefright in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34970788.",7.8,HIGH,2,test,,5
CVE-2017-0592,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"FLACExtractor: copy protect mWriteBuffer

Bug: 30895578
Change-Id: I4cba36bbe3502678210e5925181683df9726b431
",acc192347665943ca674acf117e4f74a88436922,https://android.googlesource.com/platform/frameworks/av/+/acc192347665943ca674acf117e4f74a88436922,media/libstagefright/FLACExtractor.cpp,copyMono16,"static void copyMono16(
short *dst,
const int *const *src,
unsigned nSamples,
unsigned ) {
for (unsigned i = 0; i < nSamples; ++i) {
*dst++ = src[0][i];
}
}","static void copyMono16(
short *VAR_0,
const int *const *VAR_1,
unsigned VAR_2,
unsigned ) {
for (unsigned VAR_3 = 0; VAR_3 < VAR_2; ++VAR_3) {
*VAR_0++ = VAR_1[0][VAR_3];
}
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/before/1.json,"static void copyMono16(
        short *dst,
        const int * src[FLACParser::kMaxChannels],
        unsigned nSamples,
        unsigned /* nChannels */) {
    for (unsigned i = 0; i < nSamples; ++i) {
        *dst++ = src[0][i];
    }
}","static void copyMono16(
        short *VAR_0,
        const int * VAR_1[FLACParser::kMaxChannels],
        unsigned VAR_2,
        unsigned /* COMMENT_0 */) {
    for (unsigned VAR_3 = 0; VAR_3 < VAR_2; ++VAR_3) {
        *VAR_0++ = VAR_1[0][VAR_3];
    }
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static void copyMono16(
         short *dst,
-        const int *const *src,
+        const int * src[FLACParser::kMaxChannels],
         unsigned nSamples,
         unsigned /* nChannels */) {
     for (unsigned i = 0; i < nSamples; ++i) {","{'deleted_lines': ['        const int *const *src,'], 'added_lines': ['        const int * src[FLACParser::kMaxChannels],']}",True,"A remote code execution vulnerability in FLACExtractor.cpp in libstagefright in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34970788.",7.8,HIGH,2,test,,5
CVE-2017-0592,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"FLACExtractor: copy protect mWriteBuffer

Bug: 30895578
Change-Id: I4cba36bbe3502678210e5925181683df9726b431
",acc192347665943ca674acf117e4f74a88436922,https://android.googlesource.com/platform/frameworks/av/+/acc192347665943ca674acf117e4f74a88436922,media/libstagefright/FLACExtractor.cpp,copyMono8,"static void copyMono8(
short *dst,
const int *const *src,
unsigned nSamples,
unsigned ) {
for (unsigned i = 0; i < nSamples; ++i) {
*dst++ = src[0][i] << 8;
}
}","static void copyMono8(
short *VAR_0,
const int *const *VAR_1,
unsigned VAR_2,
unsigned ) {
for (unsigned VAR_3 = 0; VAR_3 < VAR_2; ++VAR_3) {
*VAR_0++ = VAR_1[0][VAR_3] << 8;
}
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/before/2.json,"static void copyMono8(
        short *dst,
        const int * src[FLACParser::kMaxChannels],
        unsigned nSamples,
        unsigned /* nChannels */) {
    for (unsigned i = 0; i < nSamples; ++i) {
        *dst++ = src[0][i] << 8;
    }
}","static void copyMono8(
        short *VAR_0,
        const int * VAR_1[FLACParser::kMaxChannels],
        unsigned VAR_2,
        unsigned /* COMMENT_0 */) {
    for (unsigned VAR_3 = 0; VAR_3 < VAR_2; ++VAR_3) {
        *VAR_0++ = VAR_1[0][VAR_3] << 8;
    }
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static void copyMono8(
         short *dst,
-        const int *const *src,
+        const int * src[FLACParser::kMaxChannels],
         unsigned nSamples,
         unsigned /* nChannels */) {
     for (unsigned i = 0; i < nSamples; ++i) {","{'deleted_lines': ['        const int *const *src,'], 'added_lines': ['        const int * src[FLACParser::kMaxChannels],']}",True,"A remote code execution vulnerability in FLACExtractor.cpp in libstagefright in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34970788.",7.8,HIGH,2,test,,5
CVE-2017-0592,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"FLACExtractor: copy protect mWriteBuffer

Bug: 30895578
Change-Id: I4cba36bbe3502678210e5925181683df9726b431
",acc192347665943ca674acf117e4f74a88436922,https://android.googlesource.com/platform/frameworks/av/+/acc192347665943ca674acf117e4f74a88436922,media/libstagefright/FLACExtractor.cpp,copyMono24,"static void copyMono24(
short *dst,
const int *const *src,
unsigned nSamples,
unsigned ) {
for (unsigned i = 0; i < nSamples; ++i) {
*dst++ = src[0][i] >> 8;
}
}","static void copyMono24(
short *VAR_0,
const int *const *VAR_1,
unsigned VAR_2,
unsigned ) {
for (unsigned VAR_3 = 0; VAR_3 < VAR_2; ++VAR_3) {
*VAR_0++ = VAR_1[0][VAR_3] >> 8;
}
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/before/3.json,"static void copyMono24(
        short *dst,
        const int * src[FLACParser::kMaxChannels],
        unsigned nSamples,
        unsigned /* nChannels */) {
    for (unsigned i = 0; i < nSamples; ++i) {
        *dst++ = src[0][i] >> 8;
    }
}","static void copyMono24(
        short *VAR_0,
        const int * VAR_1[FLACParser::kMaxChannels],
        unsigned VAR_2,
        unsigned /* COMMENT_0 */) {
    for (unsigned VAR_3 = 0; VAR_3 < VAR_2; ++VAR_3) {
        *VAR_0++ = VAR_1[0][VAR_3] >> 8;
    }
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/after/3.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static void copyMono24(
         short *dst,
-        const int *const *src,
+        const int * src[FLACParser::kMaxChannels],
         unsigned nSamples,
         unsigned /* nChannels */) {
     for (unsigned i = 0; i < nSamples; ++i) {","{'deleted_lines': ['        const int *const *src,'], 'added_lines': ['        const int * src[FLACParser::kMaxChannels],']}",True,"A remote code execution vulnerability in FLACExtractor.cpp in libstagefright in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34970788.",7.8,HIGH,2,test,,5
CVE-2017-0592,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"FLACExtractor: copy protect mWriteBuffer

Bug: 30895578
Change-Id: I4cba36bbe3502678210e5925181683df9726b431
",acc192347665943ca674acf117e4f74a88436922,https://android.googlesource.com/platform/frameworks/av/+/acc192347665943ca674acf117e4f74a88436922,media/libstagefright/FLACExtractor.cpp,FLACParser::FLACParser,"FLACParser::FLACParser(
const sp<DataSource> &dataSource,
const sp<MetaData> &fileMetadata,
const sp<MetaData> &trackMetadata)
: mDataSource(dataSource),
mFileMetadata(fileMetadata),
mTrackMetadata(trackMetadata),
mInitCheck(false),
mMaxBufferSize(0),
mGroup(NULL),
mCopy(copyTrespass),
mDecoder(NULL),
mCurrentPos(0LL),
mEOF(false),
mStreamInfoValid(false),
mWriteRequested(false),
mWriteCompleted(false),
mWriteBuffer(NULL),
mErrorStatus((FLAC__StreamDecoderErrorStatus) -1)
{
ALOGV(""FLACParser::FLACParser"");
memset(&mStreamInfo, 0, sizeof(mStreamInfo));
memset(&mWriteHeader, 0, sizeof(mWriteHeader));
mInitCheck = init();
}","FLACParser::FLACParser(
const sp<DataSource> &VAR_0,
const sp<MetaData> &VAR_1,
const sp<MetaData> &VAR_2)
: mDataSource(VAR_0),
mFileMetadata(VAR_1),
mTrackMetadata(VAR_2),
mInitCheck(false),
mMaxBufferSize(0),
mGroup(NULL),
mCopy(VAR_3),
mDecoder(NULL),
mCurrentPos(0LL),
mEOF(false),
mStreamInfoValid(false),
mWriteRequested(false),
mWriteCompleted(false),
mWriteBuffer(NULL),
mErrorStatus((VAR_4) -1)
{
ALOGV(""FLACParser::FLACParser"");
memset(&VAR_5, 0, sizeof(VAR_5));
memset(&VAR_6, 0, sizeof(VAR_6));
VAR_7 = init();
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/before/4.json,"FLACParser::FLACParser(
        const sp<DataSource> &dataSource,
        const sp<MetaData> &fileMetadata,
        const sp<MetaData> &trackMetadata)
    : mDataSource(dataSource),
      mFileMetadata(fileMetadata),
      mTrackMetadata(trackMetadata),
      mInitCheck(false),
      mMaxBufferSize(0),
      mGroup(NULL),
      mCopy(copyTrespass),
      mDecoder(NULL),
      mCurrentPos(0LL),
      mEOF(false),
      mStreamInfoValid(false),
      mWriteRequested(false),
      mWriteCompleted(false),
      mErrorStatus((FLAC__StreamDecoderErrorStatus) -1)
{
    ALOGV(""FLACParser::FLACParser"");
    memset(&mStreamInfo, 0, sizeof(mStreamInfo));
    memset(&mWriteHeader, 0, sizeof(mWriteHeader));
    mInitCheck = init();
}","FLACParser::FLACParser(
        const sp<DataSource> &VAR_0,
        const sp<MetaData> &VAR_1,
        const sp<MetaData> &VAR_2)
    : mDataSource(VAR_0),
      mFileMetadata(VAR_1),
      mTrackMetadata(VAR_2),
      mInitCheck(false),
      mMaxBufferSize(0),
      mGroup(NULL),
      mCopy(VAR_3),
      mDecoder(NULL),
      mCurrentPos(0LL),
      mEOF(false),
      mStreamInfoValid(false),
      mWriteRequested(false),
      mWriteCompleted(false),
      mErrorStatus((VAR_4) -1)
{
    ALOGV(""FLACParser::FLACParser"");
    memset(&VAR_5, 0, sizeof(VAR_5));
    memset(&VAR_6, 0, sizeof(VAR_6));
    VAR_7 = init();
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/after/4.json,"--- func_before
+++ func_after
@@ -15,7 +15,6 @@
       mStreamInfoValid(false),
       mWriteRequested(false),
       mWriteCompleted(false),
-      mWriteBuffer(NULL),
       mErrorStatus((FLAC__StreamDecoderErrorStatus) -1)
 {
     ALOGV(""FLACParser::FLACParser"");","{'deleted_lines': ['      mWriteBuffer(NULL),'], 'added_lines': []}",True,"A remote code execution vulnerability in FLACExtractor.cpp in libstagefright in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34970788.",7.8,HIGH,2,test,,5
CVE-2017-0592,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"FLACExtractor: copy protect mWriteBuffer

Bug: 30895578
Change-Id: I4cba36bbe3502678210e5925181683df9726b431
",acc192347665943ca674acf117e4f74a88436922,https://android.googlesource.com/platform/frameworks/av/+/acc192347665943ca674acf117e4f74a88436922,media/libstagefright/FLACExtractor.cpp,copyTrespass,"static void copyTrespass(
short * ,
const int *const * ,
unsigned ,
unsigned ) {
TRESPASS();
}","static void copyTrespass(
short * ,
const int *const * ,
unsigned ,
unsigned ) {
TRESPASS();
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/before/5.json,"static void copyTrespass(
        short * /* dst */,
        const int *[FLACParser::kMaxChannels] /* src */,
        unsigned /* nSamples */,
        unsigned /* nChannels */) {
    TRESPASS();
}","static void copyTrespass(
        short * /* COMMENT_0 */,
        const int *[FLACParser::kMaxChannels] /* COMMENT_1 */,
        unsigned /* COMMENT_2 */,
        unsigned /* COMMENT_3 */) {
    TRESPASS();
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/after/5.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static void copyTrespass(
         short * /* dst */,
-        const int *const * /* src */,
+        const int *[FLACParser::kMaxChannels] /* src */,
         unsigned /* nSamples */,
         unsigned /* nChannels */) {
     TRESPASS();","{'deleted_lines': ['        const int *const * /* src */,'], 'added_lines': ['        const int *[FLACParser::kMaxChannels] /* src */,']}",True,"A remote code execution vulnerability in FLACExtractor.cpp in libstagefright in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34970788.",7.8,HIGH,2,test,,5
CVE-2017-0592,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"FLACExtractor: copy protect mWriteBuffer

Bug: 30895578
Change-Id: I4cba36bbe3502678210e5925181683df9726b431
",acc192347665943ca674acf117e4f74a88436922,https://android.googlesource.com/platform/frameworks/av/+/acc192347665943ca674acf117e4f74a88436922,media/libstagefright/FLACExtractor.cpp,FLACParser::writeCallback,"FLAC__StreamDecoderWriteStatus FLACParser::writeCallback(
const FLAC__Frame *frame, const FLAC__int32 * const buffer[])
{
if (mWriteRequested) {
mWriteRequested = false;
mWriteHeader = frame->header;
mWriteBuffer = buffer;
mWriteCompleted = true;
return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
} else {
ALOGE(""FLACParser::writeCallback unexpected"");
return FLAC__STREAM_DECODER_WRITE_STATUS_ABORT;
}
}","FLAC__StreamDecoderWriteStatus FLACParser::writeCallback(
const FLAC__Frame *VAR_0, const FLAC__int32 * const VAR_1[])
{
if (VAR_2) {
VAR_2 = false;
VAR_3 = VAR_0->header;
VAR_4 = VAR_1;
VAR_5 = true;
return VAR_6;
} else {
ALOGE(""FLACParser::writeCallback unexpected"");
return VAR_7;
}
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/before/6.json,"FLAC__StreamDecoderWriteStatus FLACParser::writeCallback(
        const FLAC__Frame *frame, const FLAC__int32 * const buffer[])
{
    if (mWriteRequested) {
        mWriteRequested = false;
        // FLAC parser doesn't free or realloc buffer until next frame or finish
        mWriteHeader = frame->header;
        memmove(mWriteBuffer, buffer, sizeof(const FLAC__int32 * const) * getChannels());
        mWriteCompleted = true;
        return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
    } else {
        ALOGE(""FLACParser::writeCallback unexpected"");
        return FLAC__STREAM_DECODER_WRITE_STATUS_ABORT;
    }
}","FLAC__StreamDecoderWriteStatus FLACParser::writeCallback(
        const FLAC__Frame *VAR_0, const FLAC__int32 * const VAR_1[])
{
    if (VAR_2) {
        VAR_2 = false;
        /* COMMENT_0 */
        VAR_3 = VAR_0->header;
        memmove(VAR_4, VAR_1, sizeof(const FLAC__int32 * const) * getChannels());
        VAR_5 = true;
        return VAR_6;
    } else {
        ALOGE(""FLACParser::writeCallback unexpected"");
        return VAR_7;
    }
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/after/6.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
         mWriteRequested = false;
         // FLAC parser doesn't free or realloc buffer until next frame or finish
         mWriteHeader = frame->header;
-        mWriteBuffer = buffer;
+        memmove(mWriteBuffer, buffer, sizeof(const FLAC__int32 * const) * getChannels());
         mWriteCompleted = true;
         return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
     } else {","{'deleted_lines': ['        mWriteBuffer = buffer;'], 'added_lines': ['        memmove(mWriteBuffer, buffer, sizeof(const FLAC__int32 * const) * getChannels());']}",True,"A remote code execution vulnerability in FLACExtractor.cpp in libstagefright in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34970788.",7.8,HIGH,2,test,,5
CVE-2017-0592,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"FLACExtractor: copy protect mWriteBuffer

Bug: 30895578
Change-Id: I4cba36bbe3502678210e5925181683df9726b431
",acc192347665943ca674acf117e4f74a88436922,https://android.googlesource.com/platform/frameworks/av/+/acc192347665943ca674acf117e4f74a88436922,media/libstagefright/FLACExtractor.cpp,copyStereo24,"static void copyStereo24(
short *dst,
const int *const *src,
unsigned nSamples,
unsigned ) {
for (unsigned i = 0; i < nSamples; ++i) {
*dst++ = src[0][i] >> 8;
*dst++ = src[1][i] >> 8;
}
}","static void copyStereo24(
short *VAR_0,
const int *const *VAR_1,
unsigned VAR_2,
unsigned ) {
for (unsigned VAR_3 = 0; VAR_3 < VAR_2; ++VAR_3) {
*VAR_0++ = VAR_1[0][VAR_3] >> 8;
*VAR_0++ = VAR_1[1][VAR_3] >> 8;
}
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/before/7.json,"static void copyStereo24(
        short *dst,
        const int * src[FLACParser::kMaxChannels],
        unsigned nSamples,
        unsigned /* nChannels */) {
    for (unsigned i = 0; i < nSamples; ++i) {
        *dst++ = src[0][i] >> 8;
        *dst++ = src[1][i] >> 8;
    }
}","static void copyStereo24(
        short *VAR_0,
        const int * VAR_1[FLACParser::kMaxChannels],
        unsigned VAR_2,
        unsigned /* COMMENT_0 */) {
    for (unsigned VAR_3 = 0; VAR_3 < VAR_2; ++VAR_3) {
        *VAR_0++ = VAR_1[0][VAR_3] >> 8;
        *VAR_0++ = VAR_1[1][VAR_3] >> 8;
    }
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/after/7.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static void copyStereo24(
         short *dst,
-        const int *const *src,
+        const int * src[FLACParser::kMaxChannels],
         unsigned nSamples,
         unsigned /* nChannels */) {
     for (unsigned i = 0; i < nSamples; ++i) {","{'deleted_lines': ['        const int *const *src,'], 'added_lines': ['        const int * src[FLACParser::kMaxChannels],']}",True,"A remote code execution vulnerability in FLACExtractor.cpp in libstagefright in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34970788.",7.8,HIGH,2,test,,5
CVE-2017-0592,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"FLACExtractor: copy protect mWriteBuffer

Bug: 30895578
Change-Id: I4cba36bbe3502678210e5925181683df9726b431
",acc192347665943ca674acf117e4f74a88436922,https://android.googlesource.com/platform/frameworks/av/+/acc192347665943ca674acf117e4f74a88436922,media/libstagefright/FLACExtractor.cpp,copyMultiCh8,"static void copyMultiCh8(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
{
for (unsigned i = 0; i < nSamples; ++i) {
for (unsigned c = 0; c < nChannels; ++c) {
*dst++ = src[c][i] << 8;
}
}
}","static void copyMultiCh8(short *VAR_0, const int *const *VAR_1, unsigned VAR_2, unsigned VAR_3)
{
for (unsigned VAR_4 = 0; VAR_4 < VAR_2; ++VAR_4) {
for (unsigned VAR_5 = 0; VAR_5 < VAR_3; ++VAR_5) {
*VAR_0++ = VAR_1[VAR_5][VAR_4] << 8;
}
}
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/before/8.json,"static void copyMultiCh8(short *dst, const int * src[FLACParser::kMaxChannels], unsigned nSamples, unsigned nChannels)
{
    for (unsigned i = 0; i < nSamples; ++i) {
        for (unsigned c = 0; c < nChannels; ++c) {
            *dst++ = src[c][i] << 8;
        }
    }
}","static void copyMultiCh8(short *VAR_0, const int * VAR_1[FLACParser::kMaxChannels], unsigned VAR_2, unsigned VAR_3)
{
    for (unsigned VAR_4 = 0; VAR_4 < VAR_2; ++VAR_4) {
        for (unsigned VAR_5 = 0; VAR_5 < VAR_3; ++VAR_5) {
            *VAR_0++ = VAR_1[VAR_5][VAR_4] << 8;
        }
    }
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/after/8.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-static void copyMultiCh8(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
+static void copyMultiCh8(short *dst, const int * src[FLACParser::kMaxChannels], unsigned nSamples, unsigned nChannels)
 {
     for (unsigned i = 0; i < nSamples; ++i) {
         for (unsigned c = 0; c < nChannels; ++c) {","{'deleted_lines': ['static void copyMultiCh8(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)'], 'added_lines': ['static void copyMultiCh8(short *dst, const int * src[FLACParser::kMaxChannels], unsigned nSamples, unsigned nChannels)']}",True,"A remote code execution vulnerability in FLACExtractor.cpp in libstagefright in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34970788.",7.8,HIGH,2,test,,5
CVE-2017-0592,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"FLACExtractor: copy protect mWriteBuffer

Bug: 30895578
Change-Id: I4cba36bbe3502678210e5925181683df9726b431
",acc192347665943ca674acf117e4f74a88436922,https://android.googlesource.com/platform/frameworks/av/+/acc192347665943ca674acf117e4f74a88436922,media/libstagefright/FLACExtractor.cpp,FLACParser::init,"status_t FLACParser::init()
{
mDecoder = FLAC__stream_decoder_new();
if (mDecoder == NULL) {
ALOGE(""new failed"");
return NO_INIT;
}
FLAC__stream_decoder_set_md5_checking(mDecoder, false);
FLAC__stream_decoder_set_metadata_ignore_all(mDecoder);
FLAC__stream_decoder_set_metadata_respond(
mDecoder, FLAC__METADATA_TYPE_STREAMINFO);
FLAC__stream_decoder_set_metadata_respond(
mDecoder, FLAC__METADATA_TYPE_PICTURE);
FLAC__stream_decoder_set_metadata_respond(
mDecoder, FLAC__METADATA_TYPE_VORBIS_COMMENT);
FLAC__StreamDecoderInitStatus initStatus;
initStatus = FLAC__stream_decoder_init_stream(
mDecoder,
read_callback, seek_callback, tell_callback,
length_callback, eof_callback, write_callback,
metadata_callback, error_callback, (void *) this);
if (initStatus != FLAC__STREAM_DECODER_INIT_STATUS_OK) {
ALOGE(""init_stream failed %d"", initStatus);
return NO_INIT;
}
if (!FLAC__stream_decoder_process_until_end_of_metadata(mDecoder)) {
ALOGE(""end_of_metadata failed"");
return NO_INIT;
}
if (mStreamInfoValid) {
if (getChannels() == 0 || getChannels() > 8) {
ALOGE(""unsupported channel count %u"", getChannels());
return NO_INIT;
}
switch (getBitsPerSample()) {
case 8:
case 16:
case 24:
break;
default:
ALOGE(""unsupported bits per sample %u"", getBitsPerSample());
return NO_INIT;
}
switch (getSampleRate()) {
case  8000:
case 11025:
case 12000:
case 16000:
case 22050:
case 24000:
case 32000:
case 44100:
case 48000:
case 88200:
case 96000:
break;
default:
ALOGE(""unsupported sample rate %u"", getSampleRate());
return NO_INIT;
}
static const struct {
unsigned mChannels;
unsigned mBitsPerSample;
void (*mCopy)(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels);
} table[] = {
{ 1,  8, copyMono8    },
{ 2,  8, copyStereo8  },
{ 8,  8, copyMultiCh8  },
{ 1, 16, copyMono16   },
{ 2, 16, copyStereo16 },
{ 8, 16, copyMultiCh16 },
{ 1, 24, copyMono24   },
{ 2, 24, copyStereo24 },
{ 8, 24, copyMultiCh24 },
};
for (unsigned i = 0; i < sizeof(table)/sizeof(table[0]); ++i) {
if (table[i].mChannels >= getChannels() &&
table[i].mBitsPerSample == getBitsPerSample()) {
mCopy = table[i].mCopy;
break;
}
}
if (mTrackMetadata != 0) {
mTrackMetadata->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_RAW);
mTrackMetadata->setInt32(kKeyChannelCount, getChannels());
mTrackMetadata->setInt32(kKeySampleRate, getSampleRate());
mTrackMetadata->setInt32(kKeyPcmEncoding, kAudioEncodingPcm16bit);
mTrackMetadata->setInt64(kKeyDuration,
(getTotalSamples() * 1000000LL) / getSampleRate());
}
} else {
ALOGE(""missing STREAMINFO"");
return NO_INIT;
}
if (mFileMetadata != 0) {
mFileMetadata->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_FLAC);
}
return OK;
}","status_t FLACParser::init()
{
VAR_0 = FLAC__stream_decoder_new();
if (VAR_0 == NULL) {
ALOGE(""new failed"");
return VAR_1;
}
FLAC__stream_decoder_set_md5_checking(VAR_0, false);
FLAC__stream_decoder_set_metadata_ignore_all(VAR_0);
FLAC__stream_decoder_set_metadata_respond(
VAR_0, VAR_2);
FLAC__stream_decoder_set_metadata_respond(
VAR_0, VAR_3);
FLAC__stream_decoder_set_metadata_respond(
VAR_0, VAR_4);
FLAC__StreamDecoderInitStatus VAR_5;
VAR_5 = FLAC__stream_decoder_init_stream(
VAR_0,
VAR_6, VAR_7, VAR_8,
VAR_9, VAR_10, VAR_11,
VAR_12, VAR_13, (void *) this);
if (VAR_5 != VAR_14) {
ALOGE(""init_stream failed %d"", VAR_5);
return VAR_1;
}
if (!FLAC__stream_decoder_process_until_end_of_metadata(VAR_0)) {
ALOGE(""end_of_metadata failed"");
return VAR_1;
}
if (VAR_15) {
if (getChannels() == 0 || getChannels() > 8) {
ALOGE(""unsupported channel count %u"", getChannels());
return VAR_1;
}
switch (getBitsPerSample()) {
case 8:
case 16:
case 24:
break;
default:
ALOGE(""unsupported bits per sample %u"", getBitsPerSample());
return VAR_1;
}
switch (getSampleRate()) {
case  8000:
case 11025:
case 12000:
case 16000:
case 22050:
case 24000:
case 32000:
case 44100:
case 48000:
case 88200:
case 96000:
break;
default:
ALOGE(""unsupported sample rate %u"", getSampleRate());
return VAR_1;
}
static const struct {
unsigned mChannels;
unsigned mBitsPerSample;
void (*mCopy)(short *VAR_16, const int *const *VAR_17, unsigned VAR_18, unsigned VAR_19);
} VAR_20[] = {
{ 1,  8, VAR_21    },
{ 2,  8, VAR_22  },
{ 8,  8, VAR_23  },
{ 1, 16, VAR_24   },
{ 2, 16, VAR_25 },
{ 8, 16, VAR_26 },
{ 1, 24, VAR_27   },
{ 2, 24, VAR_28 },
{ 8, 24, VAR_29 },
};
for (unsigned VAR_30 = 0; VAR_30 < sizeof(table)/sizeof(table[0]); ++VAR_30) {
if (table[VAR_30].mChannels >= getChannels() &&
table[VAR_30].mBitsPerSample == getBitsPerSample()) {
VAR_31 = table[VAR_30].mCopy;
break;
}
}
if (VAR_32 != 0) {
VAR_32->setCString(VAR_33, VAR_34);
VAR_32->setInt32(VAR_35, getChannels());
VAR_32->setInt32(VAR_36, getSampleRate());
VAR_32->setInt32(VAR_37, VAR_38);
VAR_32->setInt64(VAR_39,
(getTotalSamples() * 1000000LL) / getSampleRate());
}
} else {
ALOGE(""missing STREAMINFO"");
return VAR_1;
}
if (VAR_40 != 0) {
VAR_40->setCString(VAR_33, VAR_41);
}
return VAR_42;
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/before/9.json,"status_t FLACParser::init()
{
    // setup libFLAC parser
    mDecoder = FLAC__stream_decoder_new();
    if (mDecoder == NULL) {
        // The new should succeed, since probably all it does is a malloc
        // that always succeeds in Android.  But to avoid dependence on the
        // libFLAC internals, we check and log here.
        ALOGE(""new failed"");
        return NO_INIT;
    }
    FLAC__stream_decoder_set_md5_checking(mDecoder, false);
    FLAC__stream_decoder_set_metadata_ignore_all(mDecoder);
    FLAC__stream_decoder_set_metadata_respond(
            mDecoder, FLAC__METADATA_TYPE_STREAMINFO);
    FLAC__stream_decoder_set_metadata_respond(
            mDecoder, FLAC__METADATA_TYPE_PICTURE);
    FLAC__stream_decoder_set_metadata_respond(
            mDecoder, FLAC__METADATA_TYPE_VORBIS_COMMENT);
    FLAC__StreamDecoderInitStatus initStatus;
    initStatus = FLAC__stream_decoder_init_stream(
            mDecoder,
            read_callback, seek_callback, tell_callback,
            length_callback, eof_callback, write_callback,
            metadata_callback, error_callback, (void *) this);
    if (initStatus != FLAC__STREAM_DECODER_INIT_STATUS_OK) {
        // A failure here probably indicates a programming error and so is
        // unlikely to happen. But we check and log here similarly to above.
        ALOGE(""init_stream failed %d"", initStatus);
        return NO_INIT;
    }
    // parse all metadata
    if (!FLAC__stream_decoder_process_until_end_of_metadata(mDecoder)) {
        ALOGE(""end_of_metadata failed"");
        return NO_INIT;
    }
    if (mStreamInfoValid) {
        // check channel count
        if (getChannels() == 0 || getChannels() > kMaxChannels) {
            ALOGE(""unsupported channel count %u"", getChannels());
            return NO_INIT;
        }
        // check bit depth
        switch (getBitsPerSample()) {
        case 8:
        case 16:
        case 24:
            break;
        default:
            ALOGE(""unsupported bits per sample %u"", getBitsPerSample());
            return NO_INIT;
        }
        // check sample rate
        switch (getSampleRate()) {
        case  8000:
        case 11025:
        case 12000:
        case 16000:
        case 22050:
        case 24000:
        case 32000:
        case 44100:
        case 48000:
        case 88200:
        case 96000:
            break;
        default:
            ALOGE(""unsupported sample rate %u"", getSampleRate());
            return NO_INIT;
        }
        // configure the appropriate copy function, defaulting to trespass
        static const struct {
            unsigned mChannels;
            unsigned mBitsPerSample;
            void (*mCopy)(short *dst, const int * src[kMaxChannels], unsigned nSamples, unsigned nChannels);
        } table[] = {
            { 1,  8, copyMono8    },
            { 2,  8, copyStereo8  },
            { 8,  8, copyMultiCh8  },
            { 1, 16, copyMono16   },
            { 2, 16, copyStereo16 },
            { 8, 16, copyMultiCh16 },
            { 1, 24, copyMono24   },
            { 2, 24, copyStereo24 },
            { 8, 24, copyMultiCh24 },
        };
        for (unsigned i = 0; i < sizeof(table)/sizeof(table[0]); ++i) {
            if (table[i].mChannels >= getChannels() &&
                    table[i].mBitsPerSample == getBitsPerSample()) {
                mCopy = table[i].mCopy;
                break;
            }
        }
        // populate track metadata
        if (mTrackMetadata != 0) {
            mTrackMetadata->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_RAW);
            mTrackMetadata->setInt32(kKeyChannelCount, getChannels());
            mTrackMetadata->setInt32(kKeySampleRate, getSampleRate());
            mTrackMetadata->setInt32(kKeyPcmEncoding, kAudioEncodingPcm16bit);
            // sample rate is non-zero, so division by zero not possible
            mTrackMetadata->setInt64(kKeyDuration,
                    (getTotalSamples() * 1000000LL) / getSampleRate());
        }
    } else {
        ALOGE(""missing STREAMINFO"");
        return NO_INIT;
    }
    if (mFileMetadata != 0) {
        mFileMetadata->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_FLAC);
    }
    return OK;
}","status_t FLACParser::init()
{
    /* COMMENT_0 */
    VAR_0 = FLAC__stream_decoder_new();
    if (VAR_0 == NULL) {
        /* COMMENT_1 */
        /* COMMENT_2 */
        /* COMMENT_3 */
        ALOGE(""new failed"");
        return VAR_1;
    }
    FLAC__stream_decoder_set_md5_checking(VAR_0, false);
    FLAC__stream_decoder_set_metadata_ignore_all(VAR_0);
    FLAC__stream_decoder_set_metadata_respond(
            VAR_0, VAR_2);
    FLAC__stream_decoder_set_metadata_respond(
            VAR_0, VAR_3);
    FLAC__stream_decoder_set_metadata_respond(
            VAR_0, VAR_4);
    FLAC__StreamDecoderInitStatus VAR_5;
    VAR_5 = FLAC__stream_decoder_init_stream(
            VAR_0,
            VAR_6, VAR_7, VAR_8,
            VAR_9, VAR_10, VAR_11,
            VAR_12, VAR_13, (void *) this);
    if (VAR_5 != VAR_14) {
        /* COMMENT_4 */
        /* COMMENT_5 */
        ALOGE(""init_stream failed %d"", VAR_5);
        return VAR_1;
    }
    /* COMMENT_6 */
    if (!FLAC__stream_decoder_process_until_end_of_metadata(VAR_0)) {
        ALOGE(""end_of_metadata failed"");
        return VAR_1;
    }
    if (VAR_15) {
        /* COMMENT_7 */
        if (getChannels() == 0 || getChannels() > VAR_16) {
            ALOGE(""unsupported channel count %u"", getChannels());
            return VAR_1;
        }
        /* COMMENT_8 */
        switch (getBitsPerSample()) {
        case 8:
        case 16:
        case 24:
            break;
        default:
            ALOGE(""unsupported bits per sample %u"", getBitsPerSample());
            return VAR_1;
        }
        /* COMMENT_9 */
        switch (getSampleRate()) {
        case  8000:
        case 11025:
        case 12000:
        case 16000:
        case 22050:
        case 24000:
        case 32000:
        case 44100:
        case 48000:
        case 88200:
        case 96000:
            break;
        default:
            ALOGE(""unsupported sample rate %u"", getSampleRate());
            return VAR_1;
        }
        /* COMMENT_10 */
        static const struct {
            unsigned mChannels;
            unsigned mBitsPerSample;
            void (*mCopy)(short *VAR_17, const int * VAR_18[VAR_16], unsigned VAR_19, unsigned VAR_20);
        } VAR_21[] = {
            { 1,  8, VAR_22    },
            { 2,  8, VAR_23  },
            { 8,  8, VAR_24  },
            { 1, 16, VAR_25   },
            { 2, 16, VAR_26 },
            { 8, 16, VAR_27 },
            { 1, 24, VAR_28   },
            { 2, 24, VAR_29 },
            { 8, 24, VAR_30 },
        };
        for (unsigned VAR_31 = 0; VAR_31 < sizeof(table)/sizeof(table[0]); ++VAR_31) {
            if (table[VAR_31].mChannels >= getChannels() &&
                    table[VAR_31].mBitsPerSample == getBitsPerSample()) {
                VAR_32 = table[VAR_31].mCopy;
                break;
            }
        }
        /* COMMENT_11 */
        if (VAR_33 != 0) {
            VAR_33->setCString(VAR_34, VAR_35);
            VAR_33->setInt32(VAR_36, getChannels());
            VAR_33->setInt32(VAR_37, getSampleRate());
            VAR_33->setInt32(VAR_38, VAR_39);
            /* COMMENT_12 */
            VAR_33->setInt64(VAR_40,
                    (getTotalSamples() * 1000000LL) / getSampleRate());
        }
    } else {
        ALOGE(""missing STREAMINFO"");
        return VAR_1;
    }
    if (VAR_41 != 0) {
        VAR_41->setCString(VAR_34, VAR_42);
    }
    return VAR_43;
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/after/9.json,"--- func_before
+++ func_after
@@ -36,7 +36,7 @@
     }
     if (mStreamInfoValid) {
         // check channel count
-        if (getChannels() == 0 || getChannels() > 8) {
+        if (getChannels() == 0 || getChannels() > kMaxChannels) {
             ALOGE(""unsupported channel count %u"", getChannels());
             return NO_INIT;
         }
@@ -72,7 +72,7 @@
         static const struct {
             unsigned mChannels;
             unsigned mBitsPerSample;
-            void (*mCopy)(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels);
+            void (*mCopy)(short *dst, const int * src[kMaxChannels], unsigned nSamples, unsigned nChannels);
         } table[] = {
             { 1,  8, copyMono8    },
             { 2,  8, copyStereo8  },","{'deleted_lines': ['        if (getChannels() == 0 || getChannels() > 8) {', '            void (*mCopy)(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels);'], 'added_lines': ['        if (getChannels() == 0 || getChannels() > kMaxChannels) {', '            void (*mCopy)(short *dst, const int * src[kMaxChannels], unsigned nSamples, unsigned nChannels);']}",True,"A remote code execution vulnerability in FLACExtractor.cpp in libstagefright in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34970788.",7.8,HIGH,2,test,,5
CVE-2017-0592,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"FLACExtractor: copy protect mWriteBuffer

Bug: 30895578
Change-Id: I4cba36bbe3502678210e5925181683df9726b431
",acc192347665943ca674acf117e4f74a88436922,https://android.googlesource.com/platform/frameworks/av/+/acc192347665943ca674acf117e4f74a88436922,media/libstagefright/FLACExtractor.cpp,copyMultiCh16,"static void copyMultiCh16(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
{
for (unsigned i = 0; i < nSamples; ++i) {
for (unsigned c = 0; c < nChannels; ++c) {
*dst++ = src[c][i];
}
}
}","static void copyMultiCh16(short *VAR_0, const int *const *VAR_1, unsigned VAR_2, unsigned VAR_3)
{
for (unsigned VAR_4 = 0; VAR_4 < VAR_2; ++VAR_4) {
for (unsigned VAR_5 = 0; VAR_5 < VAR_3; ++VAR_5) {
*VAR_0++ = VAR_1[VAR_5][VAR_4];
}
}
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/before/10.json,"static void copyMultiCh16(short *dst, const int * src[FLACParser::kMaxChannels], unsigned nSamples, unsigned nChannels)
{
    for (unsigned i = 0; i < nSamples; ++i) {
        for (unsigned c = 0; c < nChannels; ++c) {
            *dst++ = src[c][i];
        }
    }
}","static void copyMultiCh16(short *VAR_0, const int * VAR_1[FLACParser::kMaxChannels], unsigned VAR_2, unsigned VAR_3)
{
    for (unsigned VAR_4 = 0; VAR_4 < VAR_2; ++VAR_4) {
        for (unsigned VAR_5 = 0; VAR_5 < VAR_3; ++VAR_5) {
            *VAR_0++ = VAR_1[VAR_5][VAR_4];
        }
    }
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/after/10.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-static void copyMultiCh16(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
+static void copyMultiCh16(short *dst, const int * src[FLACParser::kMaxChannels], unsigned nSamples, unsigned nChannels)
 {
     for (unsigned i = 0; i < nSamples; ++i) {
         for (unsigned c = 0; c < nChannels; ++c) {","{'deleted_lines': ['static void copyMultiCh16(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)'], 'added_lines': ['static void copyMultiCh16(short *dst, const int * src[FLACParser::kMaxChannels], unsigned nSamples, unsigned nChannels)']}",True,"A remote code execution vulnerability in FLACExtractor.cpp in libstagefright in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34970788.",7.8,HIGH,2,test,,5
CVE-2017-0592,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"FLACExtractor: copy protect mWriteBuffer

Bug: 30895578
Change-Id: I4cba36bbe3502678210e5925181683df9726b431
",acc192347665943ca674acf117e4f74a88436922,https://android.googlesource.com/platform/frameworks/av/+/acc192347665943ca674acf117e4f74a88436922,media/libstagefright/FLACExtractor.cpp,copyMultiCh24,"static void copyMultiCh24(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
{
for (unsigned i = 0; i < nSamples; ++i) {
for (unsigned c = 0; c < nChannels; ++c) {
*dst++ = src[c][i] >> 8;
}
}
}","static void copyMultiCh24(short *VAR_0, const int *const *VAR_1, unsigned VAR_2, unsigned VAR_3)
{
for (unsigned VAR_4 = 0; VAR_4 < VAR_2; ++VAR_4) {
for (unsigned VAR_5 = 0; VAR_5 < VAR_3; ++VAR_5) {
*VAR_0++ = VAR_1[VAR_5][VAR_4] >> 8;
}
}
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/before/11.json,"static void copyMultiCh24(short *dst, const int * src[FLACParser::kMaxChannels], unsigned nSamples, unsigned nChannels)
{
    for (unsigned i = 0; i < nSamples; ++i) {
        for (unsigned c = 0; c < nChannels; ++c) {
            *dst++ = src[c][i] >> 8;
        }
    }
}","static void copyMultiCh24(short *VAR_0, const int * VAR_1[FLACParser::kMaxChannels], unsigned VAR_2, unsigned VAR_3)
{
    for (unsigned VAR_4 = 0; VAR_4 < VAR_2; ++VAR_4) {
        for (unsigned VAR_5 = 0; VAR_5 < VAR_3; ++VAR_5) {
            *VAR_0++ = VAR_1[VAR_5][VAR_4] >> 8;
        }
    }
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/after/11.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-static void copyMultiCh24(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
+static void copyMultiCh24(short *dst, const int * src[FLACParser::kMaxChannels], unsigned nSamples, unsigned nChannels)
 {
     for (unsigned i = 0; i < nSamples; ++i) {
         for (unsigned c = 0; c < nChannels; ++c) {","{'deleted_lines': ['static void copyMultiCh24(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)'], 'added_lines': ['static void copyMultiCh24(short *dst, const int * src[FLACParser::kMaxChannels], unsigned nSamples, unsigned nChannels)']}",True,"A remote code execution vulnerability in FLACExtractor.cpp in libstagefright in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34970788.",7.8,HIGH,2,test,,5
CVE-2017-0592,['CWE-119'],AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"FLACExtractor: copy protect mWriteBuffer

Bug: 30895578
Change-Id: I4cba36bbe3502678210e5925181683df9726b431
",acc192347665943ca674acf117e4f74a88436922,https://android.googlesource.com/platform/frameworks/av/+/acc192347665943ca674acf117e4f74a88436922,media/libstagefright/FLACExtractor.cpp,copyStereo8,"static void copyStereo8(
short *dst,
const int *const *src,
unsigned nSamples,
unsigned ) {
for (unsigned i = 0; i < nSamples; ++i) {
*dst++ = src[0][i] << 8;
*dst++ = src[1][i] << 8;
}
}","static void copyStereo8(
short *VAR_0,
const int *const *VAR_1,
unsigned VAR_2,
unsigned ) {
for (unsigned VAR_3 = 0; VAR_3 < VAR_2; ++VAR_3) {
*VAR_0++ = VAR_1[0][VAR_3] << 8;
*VAR_0++ = VAR_1[1][VAR_3] << 8;
}
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/before/12.json,"static void copyStereo8(
        short *dst,
        const int * src[FLACParser::kMaxChannels],
        unsigned nSamples,
        unsigned /* nChannels */) {
    for (unsigned i = 0; i < nSamples; ++i) {
        *dst++ = src[0][i] << 8;
        *dst++ = src[1][i] << 8;
    }
}","static void copyStereo8(
        short *VAR_0,
        const int * VAR_1[FLACParser::kMaxChannels],
        unsigned VAR_2,
        unsigned /* COMMENT_0 */) {
    for (unsigned VAR_3 = 0; VAR_3 < VAR_2; ++VAR_3) {
        *VAR_0++ = VAR_1[0][VAR_3] << 8;
        *VAR_0++ = VAR_1[1][VAR_3] << 8;
    }
}",android/acc192347665943ca674acf117e4f74a88436922/FLACExtractor.cpp/vul/after/12.json,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 static void copyStereo8(
         short *dst,
-        const int *const *src,
+        const int * src[FLACParser::kMaxChannels],
         unsigned nSamples,
         unsigned /* nChannels */) {
     for (unsigned i = 0; i < nSamples; ++i) {","{'deleted_lines': ['        const int *const *src,'], 'added_lines': ['        const int * src[FLACParser::kMaxChannels],']}",True,"A remote code execution vulnerability in FLACExtractor.cpp in libstagefright in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34970788.",7.8,HIGH,2,test,,5
CVE-2018-7728,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,exempi,,e163667a06a9b656a047b0ec660b871f29a83c9f,https://cgit.freedesktop.org/exempi/commit/?id=e163667a06a9b656a047b0ec660b871f29a83c9f,XMPFiles/source/FileHandlers/TIFF_Handler.cpp,TIFF_MetaHandler::ProcessXMP,"void TIFF_MetaHandler::ProcessXMP()
{
this->processedXMP = true;
bool found;
bool readOnly = ((this->parent->openFlags & kXMPFiles_OpenForUpdate) == 0);
if ( readOnly ) {
this->psirMgr = new PSIR_MemoryReader();
this->iptcMgr = new IPTC_Reader();
} else {
this->psirMgr = new PSIR_FileWriter();
this->iptcMgr = new IPTC_Writer();}
TIFF_Manager & tiff = this->tiffMgr;PSIR_Manager & psir = *this->psirMgr;
IPTC_Manager & iptc = *this->iptcMgr;
TIFF_Manager::TagInfo psirInfo;
bool havePSIR = tiff.GetTag ( kTIFF_PrimaryIFD, kTIFF_PSIR, &psirInfo );
if ( havePSIR ) {psir.ParseMemoryResources ( psirInfo.dataPtr, psirInfo.dataLen );
PSIR_Manager::ImgRsrcInfo buriedExif;
found = psir.GetImgRsrc ( kPSIR_Exif, &buriedExif );
if ( found ) {
tiff.IntegrateFromPShop6 ( buriedExif.dataPtr, buriedExif.dataLen );
if ( ! readOnly ) psir.DeleteImgRsrc ( kPSIR_Exif );
}
}
TIFF_Manager::TagInfo iptcInfo;
bool haveIPTC = tiff.GetTag ( kTIFF_PrimaryIFD, kTIFF_IPTC, &iptcInfo );int iptcDigestState = kDigestMatches;
if ( haveIPTC ) {
bool haveDigest = false;
PSIR_Manager::ImgRsrcInfo digestInfo;
if ( havePSIR ) haveDigest = psir.GetImgRsrc ( kPSIR_IPTCDigest, &digestInfo );
if ( digestInfo.dataLen != 16 ) haveDigest = false;
if ( ! haveDigest ) {
iptcDigestState = kDigestMissing;
} else {
iptcDigestState = PhotoDataUtils::CheckIPTCDigest ( iptcInfo.dataPtr, iptcInfo.dataLen, digestInfo.dataPtr );
if ( (iptcDigestState == kDigestDiffers) && (kTIFF_TypeSizes[iptcInfo.type] > 1) ) {
XMP_Uns8 * endPtr = (XMP_Uns8*)iptcInfo.dataPtr + iptcInfo.dataLen - 1;
XMP_Uns8 * minPtr = endPtr - kTIFF_TypeSizes[iptcInfo.type] + 1;
while ( (endPtr >= minPtr) && (*endPtr == 0) ) --endPtr;
XMP_Uns32 unpaddedLen = (XMP_Uns32) (endPtr - (XMP_Uns8*)iptcInfo.dataPtr + 1);
iptcDigestState = PhotoDataUtils::CheckIPTCDigest ( iptcInfo.dataPtr, unpaddedLen, digestInfo.dataPtr );
}
}
}
XMP_OptionBits options = k2XMP_FileHadExif;if ( haveIPTC ) options |= k2XMP_FileHadIPTC;
if ( this->containsXMP ) options |= k2XMP_FileHadXMP;
bool haveXMP = false;
if ( ! this->xmpPacket.empty() ) {
XMP_Assert ( this->containsXMP );
XMP_StringPtr packetStr = this->xmpPacket.c_str();
XMP_StringLen packetLen = (XMP_StringLen)this->xmpPacket.size();
try {
this->xmpObj.ParseFromBuffer ( packetStr, packetLen );
} catch ( ... ) {  }
haveXMP = true;
}
if ( haveIPTC && (! haveXMP) && (iptcDigestState == kDigestMatches) ) iptcDigestState = kDigestMissing;
bool parseIPTC = (iptcDigestState != kDigestMatches) || (! readOnly);
if ( parseIPTC ) iptc.ParseMemoryDataSets ( iptcInfo.dataPtr, iptcInfo.dataLen );
ImportPhotoData ( tiff, iptc, psir, iptcDigestState, &this->xmpObj, options );
this->containsXMP = true;
}","void TIFF_MetaHandler::ProcessXMP()
{
this->processedXMP = true;
bool VAR_0;
bool VAR_1 = ((this->parent->openFlags & VAR_2) == 0);
if ( VAR_1 ) {
this->psirMgr = new PSIR_MemoryReader();
this->iptcMgr = new IPTC_Reader();
} else {
this->psirMgr = new PSIR_FileWriter();
this->iptcMgr = new IPTC_Writer();
}
TIFF_Manager & VAR_3 = this->tiffMgr;
PSIR_Manager & VAR_4 = *this->psirMgr;
IPTC_Manager & VAR_5 = *this->iptcMgr;
TIFF_Manager::TagInfo VAR_6;
bool VAR_7 = VAR_3.GetTag ( VAR_8, VAR_9, &VAR_6 );
if ( VAR_7 ) {
VAR_4.ParseMemoryResources ( VAR_6.dataPtr, VAR_6.dataLen );
PSIR_Manager::ImgRsrcInfo VAR_10;
VAR_0 = VAR_4.GetImgRsrc ( VAR_11, &VAR_10 );
if ( VAR_0 ) {
VAR_3.IntegrateFromPShop6 ( VAR_10.dataPtr, VAR_10.dataLen );
if ( ! VAR_1 ) VAR_4.DeleteImgRsrc ( VAR_11 );
}
}
TIFF_Manager::TagInfo VAR_12;
bool VAR_13 = VAR_3.GetTag ( VAR_8, VAR_14, &VAR_12 );
int VAR_15 = VAR_16;
if ( VAR_13 ) {
bool VAR_17 = false;
PSIR_Manager::ImgRsrcInfo VAR_18;
if ( VAR_7 ) VAR_17 = VAR_4.GetImgRsrc ( VAR_19, &VAR_18 );
if ( VAR_18.dataLen != 16 ) VAR_17 = false;
if ( ! VAR_17 ) {
VAR_15 = VAR_20;
} else {
VAR_15 = PhotoDataUtils::CheckIPTCDigest ( VAR_12.dataPtr, VAR_12.dataLen, VAR_18.dataPtr );
if ( (VAR_15 == VAR_21) && (VAR_22[VAR_12.type] > 1) ) {
XMP_Uns8 * VAR_23 = (XMP_Uns8*)VAR_12.dataPtr + VAR_12.dataLen - 1;
XMP_Uns8 * VAR_24 = VAR_23 - VAR_22[VAR_12.type] + 1;
while ( (VAR_23 >= VAR_24) && (*VAR_23 == 0) ) --VAR_23;
XMP_Uns32 VAR_25 = (XMP_Uns32) (VAR_23 - (XMP_Uns8*)VAR_12.dataPtr + 1);
VAR_15 = PhotoDataUtils::CheckIPTCDigest ( VAR_12.dataPtr, VAR_25, VAR_18.dataPtr );
}
}
}
XMP_OptionBits VAR_26 = VAR_27;
if ( VAR_13 ) VAR_26 |= VAR_28;
if ( this->containsXMP ) VAR_26 |= VAR_29;
bool VAR_30 = false;
if ( ! this->xmpPacket.empty() ) {
XMP_Assert ( this->containsXMP );
XMP_StringPtr VAR_31 = this->xmpPacket.c_str();
XMP_StringLen VAR_32 = (XMP_StringLen)this->xmpPacket.size();
try {
this->xmpObj.ParseFromBuffer ( VAR_31, VAR_32 );
} catch ( ... ) {  }
VAR_30 = true;
}
if ( VAR_13 && (! VAR_30) && (VAR_15 == VAR_16) ) VAR_15 = VAR_20;
bool VAR_33 = (VAR_15 != VAR_16) || (! VAR_1);
if ( VAR_33 ) VAR_5.ParseMemoryDataSets ( VAR_12.dataPtr, VAR_12.dataLen );
ImportPhotoData ( VAR_3, VAR_5, VAR_4, VAR_15, &this->xmpObj, VAR_26 );
this->containsXMP = true;
}",,"void TIFF_MetaHandler::ProcessXMP()
{

	this->processedXMP = true;	// Make sure we only come through here once.

	// Set up everything for the legacy import, but don't do it yet. This lets us do a forced legacy
	// import if the XMP packet gets parsing errors.

	// ! Photoshop 6 wrote annoyingly wacky TIFF files. It buried a lot of the Exif metadata inside
	// ! image resource 1058, itself inside of tag 34377 in the 0th IFD. Take care of this before
	// ! doing any of the legacy metadata presence or priority analysis. Delete image resource 1058
	// ! to get rid of the buried Exif, but don't mark the XMPFiles object as changed. This change
	// ! should not trigger an update, but should be included as part of a normal update.

	bool found;
	bool readOnly = ((this->parent->openFlags & kXMPFiles_OpenForUpdate) == 0);

	if ( readOnly ) {
		this->psirMgr = new PSIR_MemoryReader();
		this->iptcMgr = new IPTC_Reader();
	} else {
		this->psirMgr = new PSIR_FileWriter();
		this->iptcMgr = new IPTC_Writer();	// ! Parse it later.
	}

	TIFF_Manager & tiff = this->tiffMgr;	// Give the compiler help in recognizing non-aliases.
	PSIR_Manager & psir = *this->psirMgr;
	IPTC_Manager & iptc = *this->iptcMgr;

	TIFF_Manager::TagInfo psirInfo;
	bool havePSIR = tiff.GetTag ( kTIFF_PrimaryIFD, kTIFF_PSIR, &psirInfo );

	if ( havePSIR ) {	// ! Do the Photoshop 6 integration before other legacy analysis.
		psir.ParseMemoryResources ( psirInfo.dataPtr, psirInfo.dataLen );
		PSIR_Manager::ImgRsrcInfo buriedExif;
		found = psir.GetImgRsrc ( kPSIR_Exif, &buriedExif );
		if ( found ) {
			tiff.IntegrateFromPShop6 ( buriedExif.dataPtr, buriedExif.dataLen );
			if ( ! readOnly ) psir.DeleteImgRsrc ( kPSIR_Exif );
		}
	}

	TIFF_Manager::TagInfo iptcInfo;
	bool haveIPTC = tiff.GetTag ( kTIFF_PrimaryIFD, kTIFF_IPTC, &iptcInfo );	// The TIFF IPTC tag.
	int iptcDigestState = kDigestMatches;

	if ( haveIPTC ) {

		bool haveDigest = false;
		PSIR_Manager::ImgRsrcInfo digestInfo;
		if ( havePSIR ) haveDigest = psir.GetImgRsrc ( kPSIR_IPTCDigest, &digestInfo );
		if ( digestInfo.dataLen != 16 ) haveDigest = false;

		if ( ! haveDigest ) {

			iptcDigestState = kDigestMissing;

		} else {

			// Older versions of Photoshop wrote tag 33723 with type LONG, but ignored the trailing
			// zero padding for the IPTC digest. If the full digest differs, recheck without the padding.

			iptcDigestState = PhotoDataUtils::CheckIPTCDigest ( iptcInfo.dataPtr, iptcInfo.dataLen, digestInfo.dataPtr );
			// See bug https://bugs.freedesktop.org/show_bug.cgi?id=105205
			// if iptcInfo.dataLen is 0, then there is no digest.
			if ( (iptcDigestState == kDigestDiffers) && (kTIFF_TypeSizes[iptcInfo.type] > 1) && iptcInfo.dataLen > 0 ) {
				XMP_Uns8 * endPtr = (XMP_Uns8*)iptcInfo.dataPtr + iptcInfo.dataLen - 1;
				XMP_Uns8 * minPtr = endPtr - kTIFF_TypeSizes[iptcInfo.type] + 1;
				while ( (endPtr >= minPtr) && (*endPtr == 0) ) --endPtr;
				XMP_Uns32 unpaddedLen = (XMP_Uns32) (endPtr - (XMP_Uns8*)iptcInfo.dataPtr + 1);
				iptcDigestState = PhotoDataUtils::CheckIPTCDigest ( iptcInfo.dataPtr, unpaddedLen, digestInfo.dataPtr );
			}

		}

	}

	XMP_OptionBits options = k2XMP_FileHadExif;	// TIFF files are presumed to have Exif legacy.
	if ( haveIPTC ) options |= k2XMP_FileHadIPTC;
	if ( this->containsXMP ) options |= k2XMP_FileHadXMP;

	// Process the XMP packet. If it fails to parse, do a forced legacy import but still throw an
	// exception. This tells the caller that an error happened, but gives them recovered legacy
	// should they want to proceed with that.

	bool haveXMP = false;

	if ( ! this->xmpPacket.empty() ) {
		XMP_Assert ( this->containsXMP );
		// Common code takes care of packetInfo.charForm, .padSize, and .writeable.
		XMP_StringPtr packetStr = this->xmpPacket.c_str();
		XMP_StringLen packetLen = (XMP_StringLen)this->xmpPacket.size();
		try {
			this->xmpObj.ParseFromBuffer ( packetStr, packetLen );
		} catch ( ... ) { /* Ignore parsing failures, someday we hope to get partial XMP back. */ }
		haveXMP = true;
	}

	// Process the legacy metadata.

	if ( haveIPTC && (! haveXMP) && (iptcDigestState == kDigestMatches) ) iptcDigestState = kDigestMissing;
	bool parseIPTC = (iptcDigestState != kDigestMatches) || (! readOnly);
	if ( parseIPTC ) iptc.ParseMemoryDataSets ( iptcInfo.dataPtr, iptcInfo.dataLen );
	ImportPhotoData ( tiff, iptc, psir, iptcDigestState, &this->xmpObj, options );

	this->containsXMP = true;	// Assume we now have something in the XMP.

}","void TIFF_MetaHandler::ProcessXMP()
{

	this->processedXMP = true;	/* COMMENT_0 */

	/* COMMENT_1 */
	/* COMMENT_2 */

	/* COMMENT_3 */
	/* COMMENT_4 */
	/* COMMENT_5 */
	/* COMMENT_6 */
	/* COMMENT_7 */

	bool VAR_0;
	bool VAR_1 = ((this->parent->openFlags & VAR_2) == 0);

	if ( VAR_1 ) {
		this->psirMgr = new PSIR_MemoryReader();
		this->iptcMgr = new IPTC_Reader();
	} else {
		this->psirMgr = new PSIR_FileWriter();
		this->iptcMgr = new IPTC_Writer();	/* COMMENT_8 */
	}

	TIFF_Manager & VAR_3 = this->tiffMgr;	/* COMMENT_9 */
	PSIR_Manager & VAR_4 = *this->psirMgr;
	IPTC_Manager & VAR_5 = *this->iptcMgr;

	TIFF_Manager::TagInfo VAR_6;
	bool VAR_7 = VAR_3.GetTag ( VAR_8, VAR_9, &VAR_6 );

	if ( VAR_7 ) {	/* COMMENT_10 */
		VAR_4.ParseMemoryResources ( VAR_6.dataPtr, VAR_6.dataLen );
		PSIR_Manager::ImgRsrcInfo VAR_10;
		VAR_0 = VAR_4.GetImgRsrc ( VAR_11, &VAR_10 );
		if ( VAR_0 ) {
			VAR_3.IntegrateFromPShop6 ( VAR_10.dataPtr, VAR_10.dataLen );
			if ( ! VAR_1 ) VAR_4.DeleteImgRsrc ( VAR_11 );
		}
	}

	TIFF_Manager::TagInfo VAR_12;
	bool VAR_13 = VAR_3.GetTag ( VAR_8, VAR_14, &VAR_12 );	/* COMMENT_11 */
	int VAR_15 = VAR_16;

	if ( VAR_13 ) {

		bool VAR_17 = false;
		PSIR_Manager::ImgRsrcInfo VAR_18;
		if ( VAR_7 ) VAR_17 = VAR_4.GetImgRsrc ( VAR_19, &VAR_18 );
		if ( VAR_18.dataLen != 16 ) VAR_17 = false;

		if ( ! VAR_17 ) {

			VAR_15 = VAR_20;

		} else {

			/* COMMENT_12 */
			/* COMMENT_13 */

			VAR_15 = PhotoDataUtils::CheckIPTCDigest ( VAR_12.dataPtr, VAR_12.dataLen, VAR_18.dataPtr );
			/* COMMENT_14 */
			/* COMMENT_15 */
			if ( (VAR_15 == VAR_21) && (VAR_22[VAR_12.type] > 1) && VAR_12.dataLen > 0 ) {
				XMP_Uns8 * VAR_23 = (XMP_Uns8*)VAR_12.dataPtr + VAR_12.dataLen - 1;
				XMP_Uns8 * VAR_24 = VAR_23 - VAR_22[VAR_12.type] + 1;
				while ( (VAR_23 >= VAR_24) && (*VAR_23 == 0) ) --VAR_23;
				XMP_Uns32 VAR_25 = (XMP_Uns32) (VAR_23 - (XMP_Uns8*)VAR_12.dataPtr + 1);
				VAR_15 = PhotoDataUtils::CheckIPTCDigest ( VAR_12.dataPtr, VAR_25, VAR_18.dataPtr );
			}

		}

	}

	XMP_OptionBits VAR_26 = VAR_27;	/* COMMENT_16 */
	if ( VAR_13 ) VAR_26 |= VAR_28;
	if ( this->containsXMP ) VAR_26 |= VAR_29;

	/* COMMENT_17 */
	/* COMMENT_18 */
	/* COMMENT_19 */

	bool VAR_30 = false;

	if ( ! this->xmpPacket.empty() ) {
		XMP_Assert ( this->containsXMP );
		/* COMMENT_20 */
		XMP_StringPtr VAR_31 = this->xmpPacket.c_str();
		XMP_StringLen VAR_32 = (XMP_StringLen)this->xmpPacket.size();
		try {
			this->xmpObj.ParseFromBuffer ( VAR_31, VAR_32 );
		} catch ( ... ) { /* COMMENT_21 */ }
		VAR_30 = true;
	}

	/* COMMENT_22 */

	if ( VAR_13 && (! VAR_30) && (VAR_15 == VAR_16) ) VAR_15 = VAR_20;
	bool VAR_33 = (VAR_15 != VAR_16) || (! VAR_1);
	if ( VAR_33 ) VAR_5.ParseMemoryDataSets ( VAR_12.dataPtr, VAR_12.dataLen );
	ImportPhotoData ( VAR_3, VAR_5, VAR_4, VAR_15, &this->xmpObj, VAR_26 );

	this->containsXMP = true;	/* COMMENT_23 */

}",,"--- func_before
+++ func_after
@@ -61,8 +61,9 @@
 			// zero padding for the IPTC digest. If the full digest differs, recheck without the padding.
 
 			iptcDigestState = PhotoDataUtils::CheckIPTCDigest ( iptcInfo.dataPtr, iptcInfo.dataLen, digestInfo.dataPtr );
-
-			if ( (iptcDigestState == kDigestDiffers) && (kTIFF_TypeSizes[iptcInfo.type] > 1) ) {
+			// See bug https://bugs.freedesktop.org/show_bug.cgi?id=105205
+			// if iptcInfo.dataLen is 0, then there is no digest.
+			if ( (iptcDigestState == kDigestDiffers) && (kTIFF_TypeSizes[iptcInfo.type] > 1) && iptcInfo.dataLen > 0 ) {
 				XMP_Uns8 * endPtr = (XMP_Uns8*)iptcInfo.dataPtr + iptcInfo.dataLen - 1;
 				XMP_Uns8 * minPtr = endPtr - kTIFF_TypeSizes[iptcInfo.type] + 1;
 				while ( (endPtr >= minPtr) && (*endPtr == 0) ) --endPtr;","{'deleted_lines': ['', '\t\t\tif ( (iptcDigestState == kDigestDiffers) && (kTIFF_TypeSizes[iptcInfo.type] > 1) ) {'], 'added_lines': ['\t\t\t// See bug https://bugs.freedesktop.org/show_bug.cgi?id=105205', '\t\t\t// if iptcInfo.dataLen is 0, then there is no digest.', '\t\t\tif ( (iptcDigestState == kDigestDiffers) && (kTIFF_TypeSizes[iptcInfo.type] > 1) && iptcInfo.dataLen > 0 ) {']}",True,"An issue was discovered in Exempi through 2.4.4. XMPFiles/source/FileHandlers/TIFF_Handler.cpp mishandles a case of a zero length, leading to a heap-based buffer over-read in the MD5Update() function in third-party/zuid/interfaces/MD5.cpp.",5.5,MEDIUM,1,test,,5
CVE-2018-7729,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,exempi,,baa4b8a02c1ffab9645d13f0bfb1c0d10d311a0c,https://cgit.freedesktop.org/exempi/commit/?id=baa4b8a02c1ffab9645d13f0bfb1c0d10d311a0c,XMPFiles/source/FileHandlers/PostScript_Handler.cpp,PostScript_MetaHandler::ParsePSFile,"void PostScript_MetaHandler::ParsePSFile()
{
bool     found = false;
IOBuffer ioBuf;
XMP_IO* fileRef = this->parent->ioRef;
XMP_AbortProc abortProc  = this->parent->abortProc;
void *        abortArg   = this->parent->abortArg;
const bool    checkAbort = (abortProc != 0);
if ( ! PostScript_Support::IsValidPSFile(fileRef,this->fileformat) ) return ; 
fileRef->Rewind();
if ( ! CheckFileSpace ( fileRef, &ioBuf, 4 ) ) return ;
XMP_Uns32 fileheader = GetUns32BE ( ioBuf.ptr );
if ( fileheader == 0xC5D0D3C6 ) 
{
if ( ! CheckFileSpace ( fileRef, &ioBuf, 30 ) ) return ;
XMP_Uns32 psOffset = GetUns32LE ( ioBuf.ptr+4 );XMP_Uns32 psLength = GetUns32LE ( ioBuf.ptr+8 );
setTokenInfo(kPS_EndPostScript,psOffset+psLength,0);
MoveToOffset ( fileRef, psOffset, &ioBuf );
}
while ( true ) 
{
if ( checkAbort && abortProc(abortArg) ) {
XMP_Throw ( ""PostScript_MetaHandler::FindPostScriptHint - User abort"", kXMPErr_UserAbort );
}
if ( ! CheckFileSpace ( fileRef, &ioBuf, kPSContainsForString.length() ) ) return ;
if ( (CheckFileSpace ( fileRef, &ioBuf, kPSEndCommentString.length() )&& 
CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSEndCommentString.c_str()), kPSEndCommentString.length() )
)|| *ioBuf.ptr!='%' || !(*(ioBuf.ptr+1)>32 && *(ioBuf.ptr+1)<=126 )) {
if (CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSEndCommentString.c_str()), kPSEndCommentString.length() ))
{
setTokenInfo(kPS_EndComments,ioBuf.filePos+ioBuf.ptr-ioBuf.data,kPSEndCommentString.length());
ioBuf.ptr+=kPSEndCommentString.length();
}
else
{
setTokenInfo(kPS_EndComments,ioBuf.filePos+ioBuf.ptr-ioBuf.data,0);
}
while(true)
{
if ( ! CheckFileSpace ( fileRef, &ioBuf, 1 ) ) return ;
if (! IsWhitespace (*ioBuf.ptr)) break;
++ioBuf.ptr;
} 
while(true)
{
if ( ! CheckFileSpace ( fileRef, &ioBuf, 5 ) ) return ;
if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""/DOCI""), 5 ) 
&& CheckFileSpace ( fileRef, &ioBuf, kPSContainsDocInfoString.length() )
&&CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsDocInfoString.c_str()), kPSContainsDocInfoString.length() ))
{
ioBuf.ptr+=kPSContainsDocInfoString.length();
ExtractDocInfoDict(ioBuf);
}else if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""%%Beg""), 5 ))
{XMP_Int64 begStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;
ioBuf.ptr+=5;
if (!CheckFileSpace ( fileRef, &ioBuf, 6 )) return;
if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""inProl""), 6 ))
{ioBuf.ptr+=6;
if (!CheckFileSpace ( fileRef, &ioBuf, 2 ))return;
if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""og""), 2 ))
{
ioBuf.ptr+=2;
setTokenInfo(kPS_BeginProlog,begStartpos,13);
}
}
else if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""inSetu""), 6 ))
{ioBuf.ptr+=6;
if (!CheckFileSpace ( fileRef, &ioBuf, 1 ))return;
if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""p""), 1 ))
{
ioBuf.ptr+=1;
setTokenInfo(kPS_BeginSetup,begStartpos,12);
}
}
else if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""inBina""), 6 ))
{ioBuf.ptr+=6;
if (!CheckFileSpace ( fileRef, &ioBuf, 3 ))return;
if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""ry""), 3 ))
{
ioBuf.ptr+=3;
while(true)
{
if (!CheckFileSpace ( fileRef, &ioBuf, 12 ))return;
if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""%%EndBinary""), 11 ))
{
ioBuf.ptr+=11;
if (IsWhitespace(*ioBuf.ptr))
{
ioBuf.ptr++;
break;
}
}
++ioBuf.ptr;
}
}
}
else if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""inData""), 6 ))
{ioBuf.ptr+=6;
if (!CheckFileSpace ( fileRef, &ioBuf, 1 ))return;
if(CheckBytes ( ioBuf.ptr, Uns8Ptr("":""), 1 ))
{
while(true)
{
if (!CheckFileSpace ( fileRef, &ioBuf, 10 ))return;
if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""%%EndData""), 9 ))
{
ioBuf.ptr+=9;
if (IsWhitespace(*ioBuf.ptr))
{
ioBuf.ptr++;
break;
}
}
++ioBuf.ptr;
}
}
}
else if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""inDocu""), 6 ))
{ioBuf.ptr+=6;
if (!CheckFileSpace ( fileRef, &ioBuf, 5 ))return;
if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""ment:""), 5 ))
{
ioBuf.ptr+=5;
while(true)
{
if (!CheckFileSpace ( fileRef, &ioBuf, 14 ))return;
if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""%%EndDocument""), 13 ))
{
ioBuf.ptr+=13;
if (IsWhitespace(*ioBuf.ptr))
{
ioBuf.ptr++;
break;
}
}
++ioBuf.ptr;
}
}
}
else if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""inPage""), 6 ))
{ioBuf.ptr+=6;
if (!CheckFileSpace ( fileRef, &ioBuf, 5 ))return;
if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""Setup""), 5 ))
{
ioBuf.ptr+=5;
setTokenInfo(kPS_BeginPageSetup,begStartpos,16);
}
}
}
else if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""%%End""), 5 ))
{XMP_Int64 begStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;
ioBuf.ptr+=5;
if ( ! CheckFileSpace ( fileRef, &ioBuf, 5 ) ) return ;
if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""Prolo""), 5 ))
{ioBuf.ptr+=5;
if ( ! CheckFileSpace ( fileRef, &ioBuf, 1 ) ) return ;
if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""g""), 1 ))
{
ioBuf.ptr+=1;
setTokenInfo(kPS_EndProlog,begStartpos,11);
}
}
else if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""Setup""), 5 ))
{ioBuf.ptr+=5;
setTokenInfo(kPS_EndSetup,begStartpos,10);
}
else if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""PageS""), 5 ))
{ioBuf.ptr+=5;
if ( ! CheckFileSpace ( fileRef, &ioBuf, 4 ) ) return ;
if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""etup""), 4 ))
{
ioBuf.ptr+=4;
setTokenInfo(kPS_EndPageSetup,begStartpos,14);
}
}
else if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""PageC""), 5 ))
{ioBuf.ptr+=5;
if ( ! CheckFileSpace ( fileRef, &ioBuf, 7 ) ) return ;
if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""omments""), 7 ))
{
ioBuf.ptr+=7;
setTokenInfo(kPS_EndPageComments,begStartpos,17);
}
}
}
else if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""%%Pag""), 5 ))
{
XMP_Int64 begStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;
ioBuf.ptr+=5;
if ( ! CheckFileSpace ( fileRef, &ioBuf, 2 ) ) return ;
if (CheckBytes ( ioBuf.ptr, Uns8Ptr("":""), 2 ))
{
ioBuf.ptr+=2;
while(!IsNewline(*ioBuf.ptr))
{
if ( ! CheckFileSpace ( fileRef, &ioBuf, 1 ) ) return ;
++ioBuf.ptr;
}
setTokenInfo(kPS_Page,begStartpos,ioBuf.filePos+ioBuf.ptr-ioBuf.data-begStartpos);
}
}
else if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""%%Tra""), 5 ))
{
XMP_Int64 begStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;
ioBuf.ptr+=5;
if ( ! CheckFileSpace ( fileRef, &ioBuf, 4 ) ) return ;
if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""iler""), 4 ))
{
ioBuf.ptr+=4;
while(!IsNewline(*ioBuf.ptr)) ++ioBuf.ptr;
setTokenInfo(kPS_Trailer,begStartpos,ioBuf.filePos+ioBuf.ptr-ioBuf.data-begStartpos);
}
}
else if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""%%EOF""), 5 ))
{
ioBuf.ptr+=5;
setTokenInfo(kPS_EOF,ioBuf.filePos+ioBuf.ptr-ioBuf.data,5);
}
if ( ! CheckFileSpace ( fileRef, &ioBuf, 1 ) ) return ;
++ioBuf.ptr;
}
return;
}else if (!(kPS_Creator & dscFlags) && 
CheckFileSpace ( fileRef, &ioBuf, kPSContainsForString.length() )&&
CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsForString.c_str()), kPSContainsForString.length() ))
{
ioBuf.ptr+=kPSContainsForString.length();
if ( ! ExtractDSCCommentValue(ioBuf,kPS_dscFor) ) return ;
}
else if (!(kPS_CreatorTool & dscFlags) &&
CheckFileSpace ( fileRef, &ioBuf, kPSContainsCreatorString.length() )&&
CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsCreatorString.c_str()), kPSContainsCreatorString.length() ))
{
ioBuf.ptr+=kPSContainsCreatorString.length();
if ( ! ExtractDSCCommentValue(ioBuf,kPS_dscCreator) ) return ;
}
else if (!(kPS_CreateDate & dscFlags) &&
CheckFileSpace ( fileRef, &ioBuf, kPSContainsCreateDateString.length() )&&
CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsCreateDateString.c_str()), kPSContainsCreateDateString.length() ))
{
ioBuf.ptr+=kPSContainsCreateDateString.length();
if ( ! ExtractDSCCommentValue(ioBuf,kPS_dscCreateDate) ) return ;
}
else if (!(kPS_Title & dscFlags) &&
CheckFileSpace ( fileRef, &ioBuf, kPSContainsTitleString.length() )&&
CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsTitleString.c_str()), kPSContainsTitleString.length() ))
{
ioBuf.ptr+=kPSContainsTitleString.length();
if ( ! ExtractDSCCommentValue(ioBuf,kPS_dscTitle) ) return ;
}
else if( CheckFileSpace ( fileRef, &ioBuf, kPSContainsXMPString.length() )&&
(  CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsXMPString.c_str()), kPSContainsXMPString.length()    ) )) {
XMP_Int64 containsXMPStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;
ioBuf.ptr += kPSContainsXMPString.length();
ExtractContainsXMPHint(ioBuf,containsXMPStartpos);
}if ( ! PostScript_Support::SkipUntilNewline(fileRef,ioBuf) ) return ;
}
return ;
}","void PostScript_MetaHandler::ParsePSFile()
{
bool     VAR_0 = false;
IOBuffer VAR_1;
XMP_IO* VAR_2 = this->parent->ioRef;
XMP_AbortProc VAR_3  = this->parent->abortProc;
void *        VAR_4   = this->parent->abortArg;
const bool    VAR_5 = (VAR_3 != 0);
if ( ! PostScript_Support::IsValidPSFile(VAR_2,this->fileformat) ) return ; 
VAR_2->Rewind();
if ( ! CheckFileSpace ( VAR_2, &VAR_1, 4 ) ) return ;
XMP_Uns32 VAR_6 = GetUns32BE ( VAR_1.ptr );
if ( VAR_6 == 0xC5D0D3C6 ) 
{
if ( ! CheckFileSpace ( VAR_2, &VAR_1, 30 ) ) return ;
XMP_Uns32 VAR_7 = GetUns32LE ( VAR_1.ptr+4 );
XMP_Uns32 VAR_8 = GetUns32LE ( VAR_1.ptr+8 );
setTokenInfo(VAR_9,VAR_7+VAR_8,0);
MoveToOffset ( VAR_2, VAR_7, &VAR_1 );
}
while ( true ) 
{
if ( VAR_5 && VAR_3(VAR_4) ) {
XMP_Throw ( ""PostScript_MetaHandler::FindPostScriptHint - User abort"", VAR_10 );
}
if ( ! CheckFileSpace ( VAR_2, &VAR_1, VAR_11.length() ) ) return ;
if ( (CheckFileSpace ( VAR_2, &VAR_1, VAR_12.length() )&& 
CheckBytes ( VAR_1.ptr, Uns8Ptr(VAR_12.c_str()), VAR_12.length() )
)|| *VAR_1.ptr!='%' || !(*(VAR_1.ptr+1)>32 && *(VAR_1.ptr+1)<=126 )) 
{
if (CheckBytes ( VAR_1.ptr, Uns8Ptr(VAR_12.c_str()), VAR_12.length() ))
{
setTokenInfo(VAR_13,VAR_1.filePos+VAR_1.ptr-VAR_1.data,VAR_12.length());
VAR_1.ptr+=VAR_12.length();
}
else
{
setTokenInfo(VAR_13,VAR_1.filePos+VAR_1.ptr-VAR_1.data,0);
}
while(true)
{
if ( ! CheckFileSpace ( VAR_2, &VAR_1, 1 ) ) return ;
if (! IsWhitespace (*VAR_1.ptr)) break;
++VAR_1.ptr;
} 
while(true)
{
if ( ! CheckFileSpace ( VAR_2, &VAR_1, 5 ) ) return ;
if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""/DOCI""), 5 ) 
&& CheckFileSpace ( VAR_2, &VAR_1, VAR_14.length() )
&&CheckBytes ( VAR_1.ptr, Uns8Ptr(VAR_14.c_str()), VAR_14.length() ))
{
VAR_1.ptr+=VAR_14.length();
ExtractDocInfoDict(VAR_1);
}
else if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""%%Beg""), 5 ))
{
XMP_Int64 VAR_15=VAR_1.filePos+VAR_1.ptr-VAR_1.data;
VAR_1.ptr+=5;
if (!CheckFileSpace ( VAR_2, &VAR_1, 6 )) return;
if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""inProl""), 6 ))
{
VAR_1.ptr+=6;
if (!CheckFileSpace ( VAR_2, &VAR_1, 2 ))return;
if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""og""), 2 ))
{
VAR_1.ptr+=2;
setTokenInfo(VAR_16,VAR_15,13);
}
}
else if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""inSetu""), 6 ))
{
VAR_1.ptr+=6;
if (!CheckFileSpace ( VAR_2, &VAR_1, 1 ))return;
if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""p""), 1 ))
{
VAR_1.ptr+=1;
setTokenInfo(VAR_17,VAR_15,12);
}
}
else if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""inBina""), 6 ))
{
VAR_1.ptr+=6;
if (!CheckFileSpace ( VAR_2, &VAR_1, 3 ))return;
if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""ry""), 3 ))
{
VAR_1.ptr+=3;
while(true)
{
if (!CheckFileSpace ( VAR_2, &VAR_1, 12 ))return;
if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""%%EndBinary""), 11 ))
{
VAR_1.ptr+=11;
if (IsWhitespace(*VAR_1.ptr))
{
VAR_1.ptr++;
break;
}
}
++VAR_1.ptr;
}
}
}
else if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""inData""), 6 ))
{
VAR_1.ptr+=6;
if (!CheckFileSpace ( VAR_2, &VAR_1, 1 ))return;
if(CheckBytes ( VAR_1.ptr, Uns8Ptr("":""), 1 ))
{
while(true)
{
if (!CheckFileSpace ( VAR_2, &VAR_1, 10 ))return;
if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""%%EndData""), 9 ))
{
VAR_1.ptr+=9;
if (IsWhitespace(*VAR_1.ptr))
{
VAR_1.ptr++;
break;
}
}
++VAR_1.ptr;
}
}
}
else if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""inDocu""), 6 ))
{
VAR_1.ptr+=6;
if (!CheckFileSpace ( VAR_2, &VAR_1, 5 ))return;
if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""ment:""), 5 ))
{
VAR_1.ptr+=5;
while(true)
{
if (!CheckFileSpace ( VAR_2, &VAR_1, 14 ))return;
if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""%%EndDocument""), 13 ))
{
VAR_1.ptr+=13;
if (IsWhitespace(*VAR_1.ptr))
{
VAR_1.ptr++;
break;
}
}
++VAR_1.ptr;
}
}
}
else if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""inPage""), 6 ))
{
VAR_1.ptr+=6;
if (!CheckFileSpace ( VAR_2, &VAR_1, 5 ))return;
if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""Setup""), 5 ))
{
VAR_1.ptr+=5;
setTokenInfo(VAR_18,VAR_15,16);
}
}
}
else if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""%%End""), 5 ))
{
XMP_Int64 VAR_15=VAR_1.filePos+VAR_1.ptr-VAR_1.data;
VAR_1.ptr+=5;
if ( ! CheckFileSpace ( VAR_2, &VAR_1, 5 ) ) return ;
if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""Prolo""), 5 ))
{
VAR_1.ptr+=5;
if ( ! CheckFileSpace ( VAR_2, &VAR_1, 1 ) ) return ;
if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""g""), 1 ))
{
VAR_1.ptr+=1;
setTokenInfo(VAR_19,VAR_15,11);
}
}
else if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""Setup""), 5 ))
{
VAR_1.ptr+=5;
setTokenInfo(VAR_20,VAR_15,10);
}
else if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""PageS""), 5 ))
{
VAR_1.ptr+=5;
if ( ! CheckFileSpace ( VAR_2, &VAR_1, 4 ) ) return ;
if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""etup""), 4 ))
{
VAR_1.ptr+=4;
setTokenInfo(VAR_21,VAR_15,14);
}
}
else if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""PageC""), 5 ))
{
VAR_1.ptr+=5;
if ( ! CheckFileSpace ( VAR_2, &VAR_1, 7 ) ) return ;
if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""omments""), 7 ))
{
VAR_1.ptr+=7;
setTokenInfo(VAR_22,VAR_15,17);
}
}
}
else if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""%%Pag""), 5 ))
{
XMP_Int64 VAR_15=VAR_1.filePos+VAR_1.ptr-VAR_1.data;
VAR_1.ptr+=5;
if ( ! CheckFileSpace ( VAR_2, &VAR_1, 2 ) ) return ;
if (CheckBytes ( VAR_1.ptr, Uns8Ptr("":""), 2 ))
{
VAR_1.ptr+=2;
while(!IsNewline(*VAR_1.ptr))
{
if ( ! CheckFileSpace ( VAR_2, &VAR_1, 1 ) ) return ;
++VAR_1.ptr;
}
setTokenInfo(VAR_23,VAR_15,VAR_1.filePos+VAR_1.ptr-VAR_1.data-VAR_15);
}
}
else if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""%%Tra""), 5 ))
{
XMP_Int64 VAR_15=VAR_1.filePos+VAR_1.ptr-VAR_1.data;
VAR_1.ptr+=5;
if ( ! CheckFileSpace ( VAR_2, &VAR_1, 4 ) ) return ;
if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""iler""), 4 ))
{
VAR_1.ptr+=4;
while(!IsNewline(*VAR_1.ptr)) ++VAR_1.ptr;
setTokenInfo(VAR_24,VAR_15,VAR_1.filePos+VAR_1.ptr-VAR_1.data-VAR_15);
}
}
else if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""%%EOF""), 5 ))
{
VAR_1.ptr+=5;
setTokenInfo(VAR_25,VAR_1.filePos+VAR_1.ptr-VAR_1.data,5);
}
if ( ! CheckFileSpace ( VAR_2, &VAR_1, 1 ) ) return ;
++VAR_1.ptr;
}
return;
}else if (!(VAR_26 & VAR_27) && 
CheckFileSpace ( VAR_2, &VAR_1, VAR_11.length() )&&
CheckBytes ( VAR_1.ptr, Uns8Ptr(VAR_11.c_str()), VAR_11.length() ))
{
VAR_1.ptr+=VAR_11.length();
if ( ! ExtractDSCCommentValue(VAR_1,VAR_28) ) return ;
}
else if (!(VAR_29 & VAR_27) &&
CheckFileSpace ( VAR_2, &VAR_1, VAR_30.length() )&&
CheckBytes ( VAR_1.ptr, Uns8Ptr(VAR_30.c_str()), VAR_30.length() ))
{
VAR_1.ptr+=VAR_30.length();
if ( ! ExtractDSCCommentValue(VAR_1,VAR_31) ) return ;
}
else if (!(VAR_32 & VAR_27) &&
CheckFileSpace ( VAR_2, &VAR_1, VAR_33.length() )&&
CheckBytes ( VAR_1.ptr, Uns8Ptr(VAR_33.c_str()), VAR_33.length() ))
{
VAR_1.ptr+=VAR_33.length();
if ( ! ExtractDSCCommentValue(VAR_1,VAR_34) ) return ;
}
else if (!(VAR_35 & VAR_27) &&
CheckFileSpace ( VAR_2, &VAR_1, VAR_36.length() )&&
CheckBytes ( VAR_1.ptr, Uns8Ptr(VAR_36.c_str()), VAR_36.length() ))
{
VAR_1.ptr+=VAR_36.length();
if ( ! ExtractDSCCommentValue(VAR_1,VAR_37) ) return ;
}
else if( CheckFileSpace ( VAR_2, &VAR_1, VAR_38.length() )&&
(  CheckBytes ( VAR_1.ptr, Uns8Ptr(VAR_38.c_str()), VAR_38.length()    ) )) {
XMP_Int64 VAR_39=VAR_1.filePos+VAR_1.ptr-VAR_1.data;
VAR_1.ptr += VAR_38.length();
ExtractContainsXMPHint(VAR_1,VAR_39);
}
if ( ! PostScript_Support::SkipUntilNewline(VAR_2,VAR_1) ) return ;
}
return ;
}",exempi/baa4b8a02c1ffab9645d13f0bfb1c0d10d311a0c/PostScript_Handler.cpp/vul/before/0.json,"void PostScript_MetaHandler::ParsePSFile()
{
	bool     found = false;
	IOBuffer ioBuf;

	XMP_IO* fileRef = this->parent->ioRef;

	XMP_AbortProc abortProc  = this->parent->abortProc;
	void *        abortArg   = this->parent->abortArg;
	const bool    checkAbort = (abortProc != 0);

	//Determine the file type PS or EPS
	if ( ! PostScript_Support::IsValidPSFile(fileRef,this->fileformat) ) return ; 
	// Check for the binary EPSF preview header.

	fileRef->Rewind();
	if ( ! CheckFileSpace ( fileRef, &ioBuf, 4 ) ) return ;
	XMP_Uns32 fileheader = GetUns32BE ( ioBuf.ptr );

	if ( fileheader == 0xC5D0D3C6 ) 
	{

		if ( ! CheckFileSpace ( fileRef, &ioBuf, 30 ) ) return ;

		XMP_Uns32 psOffset = GetUns32LE ( ioBuf.ptr+4 );	// PostScript offset.
		XMP_Uns32 psLength = GetUns32LE ( ioBuf.ptr+8 );	// PostScript length.

		setTokenInfo(kPS_EndPostScript,psOffset+psLength,0);
		MoveToOffset ( fileRef, psOffset, &ioBuf );

	}

	while ( true ) 
	{
		if ( checkAbort && abortProc(abortArg) ) {
			XMP_Throw ( ""PostScript_MetaHandler::FindPostScriptHint - User abort"", kXMPErr_UserAbort );
		}

		if ( ! CheckFileSpace ( fileRef, &ioBuf, kPSContainsForString.length() ) ) return ;

		if ( (CheckFileSpace ( fileRef, &ioBuf, kPSEndCommentString.length() )&& 
				CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSEndCommentString.c_str()), kPSEndCommentString.length() )
				)|| *ioBuf.ptr!='%' || !(*(ioBuf.ptr+1)>32 && *(ioBuf.ptr+1)<=126 )) // implicit endcomment check
		{
			if (CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSEndCommentString.c_str()), kPSEndCommentString.length() ))
			{
				setTokenInfo(kPS_EndComments,ioBuf.filePos+ioBuf.ptr-ioBuf.data,kPSEndCommentString.length());
				ioBuf.ptr+=kPSEndCommentString.length();
			}
			else
			{
				setTokenInfo(kPS_EndComments,ioBuf.filePos+ioBuf.ptr-ioBuf.data,0);
			}
			// Found ""%%EndComments"", look for docInfo Dictionary
			// skip past the end of this line.
			while(true)
			{
				if ( ! CheckFileSpace ( fileRef, &ioBuf, 1 ) ) return ;
				if (! IsWhitespace (*ioBuf.ptr)) break;
				++ioBuf.ptr;
			} 
			// search for /DOCINFO
			while(true)
			{
				if ( ! CheckFileSpace ( fileRef, &ioBuf, 5 ) ) return ;
				if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""/DOCI""), 5 ) 
					&& CheckFileSpace ( fileRef, &ioBuf, kPSContainsDocInfoString.length() )
					&&CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsDocInfoString.c_str()), kPSContainsDocInfoString.length() ))
					
				{
					
					ioBuf.ptr+=kPSContainsDocInfoString.length();
					ExtractDocInfoDict(ioBuf);
				}// DOCINFO Not found in document
				else if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""%%Beg""), 5 ))
				{//possibly one of %%BeginProlog %%BeginSetup %%BeginBinary %%BeginData 
					// %%BeginDocument %%BeginPageSetup
					XMP_Int64 begStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;
					ioBuf.ptr+=5;
					if (!CheckFileSpace ( fileRef, &ioBuf, 6 )) return;
					if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""inProl""), 6 ))
					{//%%BeginProlog
						ioBuf.ptr+=6;
						if (!CheckFileSpace ( fileRef, &ioBuf, 2 ))return;
						if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""og""), 2 ))
						{
							ioBuf.ptr+=2;
							setTokenInfo(kPS_BeginProlog,begStartpos,13);
						}
					}
					else if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""inSetu""), 6 ))
					{//%%BeginSetup 
						ioBuf.ptr+=6;
						if (!CheckFileSpace ( fileRef, &ioBuf, 1 ))return;
						if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""p""), 1 ))
						{
							ioBuf.ptr+=1;
							setTokenInfo(kPS_BeginSetup,begStartpos,12);
						}
					}
					else if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""inBina""), 6 ))
					{//%%BeginBinary
						ioBuf.ptr+=6;
						if (!CheckFileSpace ( fileRef, &ioBuf, 3 ))return;
						if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""ry""), 3 ))
						{
							ioBuf.ptr+=3;
							//ignore till %%EndBinary
							while(true)
							{
								if (!CheckFileSpace ( fileRef, &ioBuf, 12 ))return;
								if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""%%EndBinary""), 11 ))
								{
									ioBuf.ptr+=11;
									if (IsWhitespace(*ioBuf.ptr))
									{
										ioBuf.ptr++;
										break;
									}
								}
								++ioBuf.ptr;
							}
						}
					}
					else if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""inData""), 6 ))
					{//%%BeginData
						ioBuf.ptr+=6;
						if (!CheckFileSpace ( fileRef, &ioBuf, 1 ))return;
						if(CheckBytes ( ioBuf.ptr, Uns8Ptr("":""), 1 ))
						{
							//ignore till %%EndData
							while(true)
							{
								if (!CheckFileSpace ( fileRef, &ioBuf, 10 ))return;
								if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""%%EndData""), 9 ))
								{
									ioBuf.ptr+=9;
									if (IsWhitespace(*ioBuf.ptr))
									{
										ioBuf.ptr++;
										break;
									}
								}
								++ioBuf.ptr;
							}
						}
					}
					else if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""inDocu""), 6 ))
					{// %%BeginDocument
						ioBuf.ptr+=6;
						if (!CheckFileSpace ( fileRef, &ioBuf, 5 ))return;
						if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""ment:""), 5 ))
						{
							ioBuf.ptr+=5;
							//ignore till %%EndDocument
							while(true)
							{
								if (!CheckFileSpace ( fileRef, &ioBuf, 14 ))return;
								if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""%%EndDocument""), 13 ))
								{
									ioBuf.ptr+=13;
									if (IsWhitespace(*ioBuf.ptr))
									{
										ioBuf.ptr++;
										break;
									}
								}
								++ioBuf.ptr;
							}
						}
					}
					else if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""inPage""), 6 ))
					{// %%BeginPageSetup
						ioBuf.ptr+=6;
						if (!CheckFileSpace ( fileRef, &ioBuf, 5 ))return;
						if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""Setup""), 5 ))
						{
							ioBuf.ptr+=5;
							setTokenInfo(kPS_BeginPageSetup,begStartpos,16);
						}
					}
				}
				else if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""%%End""), 5 ))
				{//possibly %%EndProlog %%EndSetup %%EndPageSetup %%EndPageComments
					XMP_Int64 begStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;
					ioBuf.ptr+=5;
					if ( ! CheckFileSpace ( fileRef, &ioBuf, 5 ) ) return ;
					if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""Prolo""), 5 ))
					{// %%EndProlog
						ioBuf.ptr+=5;
						if ( ! CheckFileSpace ( fileRef, &ioBuf, 1 ) ) return ;
						if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""g""), 1 ))
						{
							ioBuf.ptr+=1;
							setTokenInfo(kPS_EndProlog,begStartpos,11);
						}
					}
					else if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""Setup""), 5 ))
					{//%%EndSetup
						ioBuf.ptr+=5;
						setTokenInfo(kPS_EndSetup,begStartpos,10);
					}
					else if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""PageS""), 5 ))
					{//%%EndPageSetup
						ioBuf.ptr+=5;
						if ( ! CheckFileSpace ( fileRef, &ioBuf, 4 ) ) return ;
						if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""etup""), 4 ))
						{
							ioBuf.ptr+=4;
							setTokenInfo(kPS_EndPageSetup,begStartpos,14);
						}
					}
					else if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""PageC""), 5 ))
					{//%%EndPageComments
						ioBuf.ptr+=5;
						if ( ! CheckFileSpace ( fileRef, &ioBuf, 7 ) ) return ;
						if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""omments""), 7 ))
						{
							ioBuf.ptr+=7;
							setTokenInfo(kPS_EndPageComments,begStartpos,17);
						}
					}
				}
				else if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""%%Pag""), 5 ))
				{
					XMP_Int64 begStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;
					ioBuf.ptr+=5;
					if ( ! CheckFileSpace ( fileRef, &ioBuf, 2 ) ) return ;
					if (CheckBytes ( ioBuf.ptr, Uns8Ptr("":""), 2 ))
					{
						ioBuf.ptr+=2;
						while(!IsNewline(*ioBuf.ptr))
						{
							if ( ! CheckFileSpace ( fileRef, &ioBuf, 1 ) ) return ;
							++ioBuf.ptr;
						}
						setTokenInfo(kPS_Page,begStartpos,ioBuf.filePos+ioBuf.ptr-ioBuf.data-begStartpos);
					}

				}
				else if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""%%Tra""), 5 ))
				{
					XMP_Int64 begStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;
					ioBuf.ptr+=5;
					if ( ! CheckFileSpace ( fileRef, &ioBuf, 4 ) ) return ;
					if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""iler""), 4 ))
					{
						ioBuf.ptr+=4;
						while(ioBuf.ptr < ioBuf.limit &&
                                                      !IsNewline(*ioBuf.ptr))
                                                    ++ioBuf.ptr;
						setTokenInfo(kPS_Trailer,begStartpos,ioBuf.filePos+ioBuf.ptr-ioBuf.data-begStartpos);
					}
				}
				else if(CheckBytes ( ioBuf.ptr, Uns8Ptr(""%%EOF""), 5 ))
				{
					ioBuf.ptr+=5;
					setTokenInfo(kPS_EOF,ioBuf.filePos+ioBuf.ptr-ioBuf.data,5);
				}
				if ( ! CheckFileSpace ( fileRef, &ioBuf, 1 ) ) return ;
				++ioBuf.ptr;
			}
			//dont have to search after this DOCINFO last thing 
			return;

		}else if (!(kPS_Creator & dscFlags) && 
			 CheckFileSpace ( fileRef, &ioBuf, kPSContainsForString.length() )&&
			CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsForString.c_str()), kPSContainsForString.length() ))
		{
			ioBuf.ptr+=kPSContainsForString.length();
			if ( ! ExtractDSCCommentValue(ioBuf,kPS_dscFor) ) return ;
		}
		else if (!(kPS_CreatorTool & dscFlags) &&
			 CheckFileSpace ( fileRef, &ioBuf, kPSContainsCreatorString.length() )&&
			 CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsCreatorString.c_str()), kPSContainsCreatorString.length() ))
		{
			ioBuf.ptr+=kPSContainsCreatorString.length();
			if ( ! ExtractDSCCommentValue(ioBuf,kPS_dscCreator) ) return ;
		}
		else if (!(kPS_CreateDate & dscFlags) &&
			 CheckFileSpace ( fileRef, &ioBuf, kPSContainsCreateDateString.length() )&&
			CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsCreateDateString.c_str()), kPSContainsCreateDateString.length() ))
		{
			
			ioBuf.ptr+=kPSContainsCreateDateString.length();
			if ( ! ExtractDSCCommentValue(ioBuf,kPS_dscCreateDate) ) return ;
		}
		else if (!(kPS_Title & dscFlags) &&
			 CheckFileSpace ( fileRef, &ioBuf, kPSContainsTitleString.length() )&&
			CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsTitleString.c_str()), kPSContainsTitleString.length() ))
		{
						
			ioBuf.ptr+=kPSContainsTitleString.length();
			if ( ! ExtractDSCCommentValue(ioBuf,kPS_dscTitle) ) return ;
		}
		else if( CheckFileSpace ( fileRef, &ioBuf, kPSContainsXMPString.length() )&&
			 (  CheckBytes ( ioBuf.ptr, Uns8Ptr(kPSContainsXMPString.c_str()), kPSContainsXMPString.length()    ) )) {

			// Found ""%ADO_ContainsXMP:"", look for the main packet location option.
			
			XMP_Int64 containsXMPStartpos=ioBuf.filePos+ioBuf.ptr-ioBuf.data;
			ioBuf.ptr += kPSContainsXMPString.length();
			ExtractContainsXMPHint(ioBuf,containsXMPStartpos);

		}	// Found ""%ADO_ContainsXMP:"".
		//Some other DSC comments skip past the end of this line.
		if ( ! PostScript_Support::SkipUntilNewline(fileRef,ioBuf) ) return ;

	}	// Outer marker loop.

	return ;	// Should never reach here.

}","void PostScript_MetaHandler::ParsePSFile()
{
	bool     VAR_0 = false;
	IOBuffer VAR_1;

	XMP_IO* VAR_2 = this->parent->ioRef;

	XMP_AbortProc VAR_3  = this->parent->abortProc;
	void *        VAR_4   = this->parent->abortArg;
	const bool    VAR_5 = (VAR_3 != 0);

	/* COMMENT_0 */
	if ( ! PostScript_Support::IsValidPSFile(VAR_2,this->fileformat) ) return ; 
	/* COMMENT_1 */

	VAR_2->Rewind();
	if ( ! CheckFileSpace ( VAR_2, &VAR_1, 4 ) ) return ;
	XMP_Uns32 VAR_6 = GetUns32BE ( VAR_1.ptr );

	if ( VAR_6 == 0xC5D0D3C6 ) 
	{

		if ( ! CheckFileSpace ( VAR_2, &VAR_1, 30 ) ) return ;

		XMP_Uns32 VAR_7 = GetUns32LE ( VAR_1.ptr+4 );	/* COMMENT_2 */
		XMP_Uns32 VAR_8 = GetUns32LE ( VAR_1.ptr+8 );	/* COMMENT_3 */

		setTokenInfo(VAR_9,VAR_7+VAR_8,0);
		MoveToOffset ( VAR_2, VAR_7, &VAR_1 );

	}

	while ( true ) 
	{
		if ( VAR_5 && VAR_3(VAR_4) ) {
			XMP_Throw ( ""PostScript_MetaHandler::FindPostScriptHint - User abort"", VAR_10 );
		}

		if ( ! CheckFileSpace ( VAR_2, &VAR_1, VAR_11.length() ) ) return ;

		if ( (CheckFileSpace ( VAR_2, &VAR_1, VAR_12.length() )&& 
				CheckBytes ( VAR_1.ptr, Uns8Ptr(VAR_12.c_str()), VAR_12.length() )
				)|| *VAR_1.ptr!='%' || !(*(VAR_1.ptr+1)>32 && *(VAR_1.ptr+1)<=126 )) /* COMMENT_4 */
		{
			if (CheckBytes ( VAR_1.ptr, Uns8Ptr(VAR_12.c_str()), VAR_12.length() ))
			{
				setTokenInfo(VAR_13,VAR_1.filePos+VAR_1.ptr-VAR_1.data,VAR_12.length());
				VAR_1.ptr+=VAR_12.length();
			}
			else
			{
				setTokenInfo(VAR_13,VAR_1.filePos+VAR_1.ptr-VAR_1.data,0);
			}
			/* COMMENT_5 */
			/* COMMENT_6 */
			while(true)
			{
				if ( ! CheckFileSpace ( VAR_2, &VAR_1, 1 ) ) return ;
				if (! IsWhitespace (*VAR_1.ptr)) break;
				++VAR_1.ptr;
			} 
			/* COMMENT_7 */
			while(true)
			{
				if ( ! CheckFileSpace ( VAR_2, &VAR_1, 5 ) ) return ;
				if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""/DOCI""), 5 ) 
					&& CheckFileSpace ( VAR_2, &VAR_1, VAR_14.length() )
					&&CheckBytes ( VAR_1.ptr, Uns8Ptr(VAR_14.c_str()), VAR_14.length() ))
					
				{
					
					VAR_1.ptr+=VAR_14.length();
					ExtractDocInfoDict(VAR_1);
				}/* COMMENT_8 */
				else if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""%%Beg""), 5 ))
				{/* COMMENT_9 */
					/* COMMENT_10 */
					XMP_Int64 VAR_15=VAR_1.filePos+VAR_1.ptr-VAR_1.data;
					VAR_1.ptr+=5;
					if (!CheckFileSpace ( VAR_2, &VAR_1, 6 )) return;
					if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""inProl""), 6 ))
					{/* COMMENT_11 */
						VAR_1.ptr+=6;
						if (!CheckFileSpace ( VAR_2, &VAR_1, 2 ))return;
						if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""og""), 2 ))
						{
							VAR_1.ptr+=2;
							setTokenInfo(VAR_16,VAR_15,13);
						}
					}
					else if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""inSetu""), 6 ))
					{/* COMMENT_12 */
						VAR_1.ptr+=6;
						if (!CheckFileSpace ( VAR_2, &VAR_1, 1 ))return;
						if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""p""), 1 ))
						{
							VAR_1.ptr+=1;
							setTokenInfo(VAR_17,VAR_15,12);
						}
					}
					else if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""inBina""), 6 ))
					{/* COMMENT_13 */
						VAR_1.ptr+=6;
						if (!CheckFileSpace ( VAR_2, &VAR_1, 3 ))return;
						if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""ry""), 3 ))
						{
							VAR_1.ptr+=3;
							/* COMMENT_14 */
							while(true)
							{
								if (!CheckFileSpace ( VAR_2, &VAR_1, 12 ))return;
								if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""%%EndBinary""), 11 ))
								{
									VAR_1.ptr+=11;
									if (IsWhitespace(*VAR_1.ptr))
									{
										VAR_1.ptr++;
										break;
									}
								}
								++VAR_1.ptr;
							}
						}
					}
					else if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""inData""), 6 ))
					{/* COMMENT_15 */
						VAR_1.ptr+=6;
						if (!CheckFileSpace ( VAR_2, &VAR_1, 1 ))return;
						if(CheckBytes ( VAR_1.ptr, Uns8Ptr("":""), 1 ))
						{
							/* COMMENT_16 */
							while(true)
							{
								if (!CheckFileSpace ( VAR_2, &VAR_1, 10 ))return;
								if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""%%EndData""), 9 ))
								{
									VAR_1.ptr+=9;
									if (IsWhitespace(*VAR_1.ptr))
									{
										VAR_1.ptr++;
										break;
									}
								}
								++VAR_1.ptr;
							}
						}
					}
					else if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""inDocu""), 6 ))
					{/* COMMENT_17 */
						VAR_1.ptr+=6;
						if (!CheckFileSpace ( VAR_2, &VAR_1, 5 ))return;
						if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""ment:""), 5 ))
						{
							VAR_1.ptr+=5;
							/* COMMENT_18 */
							while(true)
							{
								if (!CheckFileSpace ( VAR_2, &VAR_1, 14 ))return;
								if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""%%EndDocument""), 13 ))
								{
									VAR_1.ptr+=13;
									if (IsWhitespace(*VAR_1.ptr))
									{
										VAR_1.ptr++;
										break;
									}
								}
								++VAR_1.ptr;
							}
						}
					}
					else if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""inPage""), 6 ))
					{/* COMMENT_19 */
						VAR_1.ptr+=6;
						if (!CheckFileSpace ( VAR_2, &VAR_1, 5 ))return;
						if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""Setup""), 5 ))
						{
							VAR_1.ptr+=5;
							setTokenInfo(VAR_18,VAR_15,16);
						}
					}
				}
				else if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""%%End""), 5 ))
				{/* COMMENT_20 */
					XMP_Int64 VAR_15=VAR_1.filePos+VAR_1.ptr-VAR_1.data;
					VAR_1.ptr+=5;
					if ( ! CheckFileSpace ( VAR_2, &VAR_1, 5 ) ) return ;
					if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""Prolo""), 5 ))
					{/* COMMENT_21 */
						VAR_1.ptr+=5;
						if ( ! CheckFileSpace ( VAR_2, &VAR_1, 1 ) ) return ;
						if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""g""), 1 ))
						{
							VAR_1.ptr+=1;
							setTokenInfo(VAR_19,VAR_15,11);
						}
					}
					else if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""Setup""), 5 ))
					{/* COMMENT_22 */
						VAR_1.ptr+=5;
						setTokenInfo(VAR_20,VAR_15,10);
					}
					else if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""PageS""), 5 ))
					{/* COMMENT_23 */
						VAR_1.ptr+=5;
						if ( ! CheckFileSpace ( VAR_2, &VAR_1, 4 ) ) return ;
						if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""etup""), 4 ))
						{
							VAR_1.ptr+=4;
							setTokenInfo(VAR_21,VAR_15,14);
						}
					}
					else if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""PageC""), 5 ))
					{/* COMMENT_24 */
						VAR_1.ptr+=5;
						if ( ! CheckFileSpace ( VAR_2, &VAR_1, 7 ) ) return ;
						if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""omments""), 7 ))
						{
							VAR_1.ptr+=7;
							setTokenInfo(VAR_22,VAR_15,17);
						}
					}
				}
				else if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""%%Pag""), 5 ))
				{
					XMP_Int64 VAR_15=VAR_1.filePos+VAR_1.ptr-VAR_1.data;
					VAR_1.ptr+=5;
					if ( ! CheckFileSpace ( VAR_2, &VAR_1, 2 ) ) return ;
					if (CheckBytes ( VAR_1.ptr, Uns8Ptr("":""), 2 ))
					{
						VAR_1.ptr+=2;
						while(!IsNewline(*VAR_1.ptr))
						{
							if ( ! CheckFileSpace ( VAR_2, &VAR_1, 1 ) ) return ;
							++VAR_1.ptr;
						}
						setTokenInfo(VAR_23,VAR_15,VAR_1.filePos+VAR_1.ptr-VAR_1.data-VAR_15);
					}

				}
				else if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""%%Tra""), 5 ))
				{
					XMP_Int64 VAR_15=VAR_1.filePos+VAR_1.ptr-VAR_1.data;
					VAR_1.ptr+=5;
					if ( ! CheckFileSpace ( VAR_2, &VAR_1, 4 ) ) return ;
					if (CheckBytes ( VAR_1.ptr, Uns8Ptr(""iler""), 4 ))
					{
						VAR_1.ptr+=4;
						while(VAR_1.ptr < VAR_1.limit &&
                                                      !IsNewline(*VAR_1.ptr))
                                                    ++VAR_1.ptr;
						setTokenInfo(VAR_24,VAR_15,VAR_1.filePos+VAR_1.ptr-VAR_1.data-VAR_15);
					}
				}
				else if(CheckBytes ( VAR_1.ptr, Uns8Ptr(""%%EOF""), 5 ))
				{
					VAR_1.ptr+=5;
					setTokenInfo(VAR_25,VAR_1.filePos+VAR_1.ptr-VAR_1.data,5);
				}
				if ( ! CheckFileSpace ( VAR_2, &VAR_1, 1 ) ) return ;
				++VAR_1.ptr;
			}
			/* COMMENT_25 */
			return;

		}else if (!(VAR_26 & VAR_27) && 
			 CheckFileSpace ( VAR_2, &VAR_1, VAR_11.length() )&&
			CheckBytes ( VAR_1.ptr, Uns8Ptr(VAR_11.c_str()), VAR_11.length() ))
		{
			VAR_1.ptr+=VAR_11.length();
			if ( ! ExtractDSCCommentValue(VAR_1,VAR_28) ) return ;
		}
		else if (!(VAR_29 & VAR_27) &&
			 CheckFileSpace ( VAR_2, &VAR_1, VAR_30.length() )&&
			 CheckBytes ( VAR_1.ptr, Uns8Ptr(VAR_30.c_str()), VAR_30.length() ))
		{
			VAR_1.ptr+=VAR_30.length();
			if ( ! ExtractDSCCommentValue(VAR_1,VAR_31) ) return ;
		}
		else if (!(VAR_32 & VAR_27) &&
			 CheckFileSpace ( VAR_2, &VAR_1, VAR_33.length() )&&
			CheckBytes ( VAR_1.ptr, Uns8Ptr(VAR_33.c_str()), VAR_33.length() ))
		{
			
			VAR_1.ptr+=VAR_33.length();
			if ( ! ExtractDSCCommentValue(VAR_1,VAR_34) ) return ;
		}
		else if (!(VAR_35 & VAR_27) &&
			 CheckFileSpace ( VAR_2, &VAR_1, VAR_36.length() )&&
			CheckBytes ( VAR_1.ptr, Uns8Ptr(VAR_36.c_str()), VAR_36.length() ))
		{
						
			VAR_1.ptr+=VAR_36.length();
			if ( ! ExtractDSCCommentValue(VAR_1,VAR_37) ) return ;
		}
		else if( CheckFileSpace ( VAR_2, &VAR_1, VAR_38.length() )&&
			 (  CheckBytes ( VAR_1.ptr, Uns8Ptr(VAR_38.c_str()), VAR_38.length()    ) )) {

			/* COMMENT_26 */
			
			XMP_Int64 VAR_39=VAR_1.filePos+VAR_1.ptr-VAR_1.data;
			VAR_1.ptr += VAR_38.length();
			ExtractContainsXMPHint(VAR_1,VAR_39);

		}	/* COMMENT_27 */
		/* COMMENT_28 */
		if ( ! PostScript_Support::SkipUntilNewline(VAR_2,VAR_1) ) return ;

	}	/* COMMENT_29 */

	return ;	/* COMMENT_30 */

}",exempi/baa4b8a02c1ffab9645d13f0bfb1c0d10d311a0c/PostScript_Handler.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -246,7 +246,9 @@
 					if (CheckBytes ( ioBuf.ptr, Uns8Ptr(""iler""), 4 ))
 					{
 						ioBuf.ptr+=4;
-						while(!IsNewline(*ioBuf.ptr)) ++ioBuf.ptr;
+						while(ioBuf.ptr < ioBuf.limit &&
+                                                      !IsNewline(*ioBuf.ptr))
+                                                    ++ioBuf.ptr;
 						setTokenInfo(kPS_Trailer,begStartpos,ioBuf.filePos+ioBuf.ptr-ioBuf.data-begStartpos);
 					}
 				}","{'deleted_lines': ['\t\t\t\t\t\twhile(!IsNewline(*ioBuf.ptr)) ++ioBuf.ptr;'], 'added_lines': ['\t\t\t\t\t\twhile(ioBuf.ptr < ioBuf.limit &&', '                                                      !IsNewline(*ioBuf.ptr))', '                                                    ++ioBuf.ptr;']}",True,An issue was discovered in Exempi through 2.4.4. There is a stack-based buffer over-read in the PostScript_MetaHandler::ParsePSFile() function in XMPFiles/source/FileHandlers/PostScript_Handler.cpp.,5.5,MEDIUM,1,test,,5
CVE-2017-2634,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"This fixes a nasty bug: dccp_send_reset() is called by both DCCPv4 and DCCPv6, but uses
inet_sk_rebuild_header() in each case. This leads to unpredictable and weird behaviour:
under some conditions, DCCPv6 Resets were sent, in other not.

The fix is to use the AF-independent rebuild_header routine.

Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
",f53dc67c5e7babafe239b93a11678b0e05bead51,https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=f53dc67c5e7babafe239b93a11678b0e05bead51,net/dccp/output.c,dccp_send_reset,"int dccp_send_reset(struct sock *sk, enum dccp_reset_codes code)
{
struct sk_buff *skb;
int err = inet_sk_rebuild_header(sk);
if (err != 0)
return err;
skb = sock_wmalloc(sk, sk->sk_prot->max_header, 1, GFP_ATOMIC);
if (skb == NULL)
return -ENOBUFS;
skb_reserve(skb, sk->sk_prot->max_header);
DCCP_SKB_CB(skb)->dccpd_type   = DCCP_PKT_RESET;
DCCP_SKB_CB(skb)->dccpd_reset_code = code;
return dccp_transmit_skb(sk, skb);
}","int dccp_send_reset(struct sock *VAR_0, enum dccp_reset_codes VAR_1)
{
struct sk_buff *VAR_2;
int VAR_3 = inet_sk_rebuild_header(VAR_0);
if (VAR_3 != 0)
return VAR_3;
VAR_2 = sock_wmalloc(VAR_0, VAR_0->sk_prot->max_header, 1, VAR_4);
if (VAR_2 == NULL)
return -VAR_5;
skb_reserve(VAR_2, VAR_0->sk_prot->max_header);
DCCP_SKB_CB(VAR_2)->dccpd_type   = VAR_6;
DCCP_SKB_CB(VAR_2)->dccpd_reset_code = VAR_1;
return dccp_transmit_skb(VAR_0, VAR_2);
}",torvalds/linux/f53dc67c5e7babafe239b93a11678b0e05bead51/output.c/vul/before/0.json,"int dccp_send_reset(struct sock *sk, enum dccp_reset_codes code)
{
	struct sk_buff *skb;
	/*
	 * FIXME: what if rebuild_header fails?
	 * Should we be doing a rebuild_header here?
	 */
	int err = inet_csk(sk)->icsk_af_ops->rebuild_header(sk);

	if (err != 0)
		return err;

	skb = sock_wmalloc(sk, sk->sk_prot->max_header, 1, GFP_ATOMIC);
	if (skb == NULL)
		return -ENOBUFS;

	/* Reserve space for headers and prepare control bits. */
	skb_reserve(skb, sk->sk_prot->max_header);
	DCCP_SKB_CB(skb)->dccpd_type	   = DCCP_PKT_RESET;
	DCCP_SKB_CB(skb)->dccpd_reset_code = code;

	return dccp_transmit_skb(sk, skb);
}","int dccp_send_reset(struct sock *VAR_0, enum dccp_reset_codes VAR_1)
{
	struct sk_buff *VAR_2;
	/* COMMENT_0 */
                                        
                                             
    
	int VAR_3 = inet_csk(VAR_0)->icsk_af_ops->rebuild_header(VAR_0);

	if (VAR_3 != 0)
		return VAR_3;

	VAR_2 = sock_wmalloc(VAR_0, VAR_0->sk_prot->max_header, 1, VAR_4);
	if (VAR_2 == NULL)
		return -VAR_5;

	/* COMMENT_4 */
	skb_reserve(VAR_2, VAR_0->sk_prot->max_header);
	DCCP_SKB_CB(VAR_2)->dccpd_type	   = VAR_6;
	DCCP_SKB_CB(VAR_2)->dccpd_reset_code = VAR_1;

	return dccp_transmit_skb(VAR_0, VAR_2);
}",torvalds/linux/f53dc67c5e7babafe239b93a11678b0e05bead51/output.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
 	 * FIXME: what if rebuild_header fails?
 	 * Should we be doing a rebuild_header here?
 	 */
-	int err = inet_sk_rebuild_header(sk);
+	int err = inet_csk(sk)->icsk_af_ops->rebuild_header(sk);
 
 	if (err != 0)
 		return err;","{'deleted_lines': ['\tint err = inet_sk_rebuild_header(sk);'], 'added_lines': ['\tint err = inet_csk(sk)->icsk_af_ops->rebuild_header(sk);']}",True,"It was found that the Linux kernel's Datagram Congestion Control Protocol (DCCP) implementation before 2.6.22.17 used the IPv4-only inet_sk_rebuild_header() function for both IPv4 and IPv6 DCCP connections, which could result in memory corruptions. A remote attacker could use this flaw to crash the system.",7.5,HIGH,2,test,,5
CVE-2018-10883,['CWE-787'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Do not set the b_modified flag in block's journal head should not
until after we're sure that jbd2_journal_dirty_metadat() will not
abort with an error due to there not being enough space reserved in
the jbd2 handle.

Otherwise, future attempts to modify the buffer may lead a large
number of spurious errors and warnings.

This addresses CVE-2018-10883.

https://bugzilla.kernel.org/show_bug.cgi?id=200071

Signed-off-by: Theodore Ts'o <tytso@mit.edu>
Cc: stable@kernel.org
",e09463f220ca9a1a1ecfda84fcda658f99a1f12a,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=e09463f220ca9a1a1ecfda84fcda658f99a1f12a,fs/jbd2/transaction.c,jbd2_journal_dirty_metadata,"int jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)
{
transaction_t *transaction = handle->h_transaction;
journal_t *journal;
struct journal_head *jh;
int ret = 0;
if (is_handle_aborted(handle))
return -EROFS;
if (!buffer_jbd(bh)) {
ret = -EUCLEAN;
goto out;
}
jh = bh2jh(bh);
if (jh->b_transaction != transaction &&
jh->b_next_transaction != transaction) {
jbd_lock_bh_state(bh);
J_ASSERT_JH(jh, jh->b_transaction == transaction ||
jh->b_next_transaction == transaction);
jbd_unlock_bh_state(bh);
}
if (jh->b_modified == 1) {
if (jh->b_transaction == transaction &&
jh->b_jlist != BJ_Metadata) {
jbd_lock_bh_state(bh);
J_ASSERT_JH(jh, jh->b_transaction != transaction ||
jh->b_jlist == BJ_Metadata);
jbd_unlock_bh_state(bh);
}
goto out;
}
journal = transaction->t_journal;
jbd_debug(5, ""journal_head %p\n"", jh);
JBUFFER_TRACE(jh, ""entry"");
jbd_lock_bh_state(bh);
if (jh->b_modified == 0) {
jh->b_modified = 1;
if (handle->h_buffer_credits <= 0) {
ret = -ENOSPC;
goto out_unlock_bh;
}
handle->h_buffer_credits--;
}
if (jh->b_transaction == transaction && jh->b_jlist == BJ_Metadata) {
JBUFFER_TRACE(jh, ""fastpath"");
if (unlikely(jh->b_transaction !=
journal->j_running_transaction)) {
printk(KERN_ERR ""JBD2: %s: ""
""jh->b_transaction (%llu, %p, %u) != ""
""journal->j_running_transaction (%p, %u)\n"",
journal->j_devname,
(unsigned long long) bh->b_blocknr,
jh->b_transaction,
jh->b_transaction ? jh->b_transaction->t_tid : 0,
journal->j_running_transaction,
journal->j_running_transaction ?
journal->j_running_transaction->t_tid : 0);
ret = -EINVAL;
}
goto out_unlock_bh;
}
set_buffer_jbddirty(bh);
if (jh->b_transaction != transaction) {
JBUFFER_TRACE(jh, ""already on other transaction"");
if (unlikely(((jh->b_transaction !=
journal->j_committing_transaction)) ||
(jh->b_next_transaction != transaction))) {
printk(KERN_ERR ""jbd2_journal_dirty_metadata: %s: ""
""bad jh for block %llu: ""
""transaction (%p, %u), ""
""jh->b_transaction (%p, %u), ""
""jh->b_next_transaction (%p, %u), jlist %u\n"",
journal->j_devname,
(unsigned long long) bh->b_blocknr,
transaction, transaction->t_tid,
jh->b_transaction,
jh->b_transaction ?
jh->b_transaction->t_tid : 0,
jh->b_next_transaction,
jh->b_next_transaction ?
jh->b_next_transaction->t_tid : 0,
jh->b_jlist);
WARN_ON(1);
ret = -EINVAL;
}
goto out_unlock_bh;
}
J_ASSERT_JH(jh, jh->b_frozen_data == NULL);
JBUFFER_TRACE(jh, ""file as BJ_Metadata"");
spin_lock(&journal->j_list_lock);
__jbd2_journal_file_buffer(jh, transaction, BJ_Metadata);
spin_unlock(&journal->j_list_lock);
out_unlock_bh:
jbd_unlock_bh_state(bh);
out:
JBUFFER_TRACE(jh, ""exit"");
return ret;
}","int jbd2_journal_dirty_metadata(handle_t *VAR_0, struct buffer_head *VAR_1)
{
transaction_t *VAR_2 = VAR_0->h_transaction;
journal_t *VAR_3;
struct journal_head *VAR_4;
int VAR_5 = 0;
if (is_handle_aborted(VAR_0))
return -VAR_6;
if (!buffer_jbd(VAR_1)) {
VAR_5 = -VAR_7;
goto out;
}
VAR_4 = bh2jh(VAR_1);
if (VAR_4->b_transaction != VAR_2 &&
VAR_4->b_next_transaction != VAR_2) {
jbd_lock_bh_state(VAR_1);
J_ASSERT_JH(VAR_4, VAR_4->b_transaction == VAR_2 ||
VAR_4->b_next_transaction == VAR_2);
jbd_unlock_bh_state(VAR_1);
}
if (VAR_4->b_modified == 1) {
if (VAR_4->b_transaction == VAR_2 &&
VAR_4->b_jlist != VAR_8) {
jbd_lock_bh_state(VAR_1);
J_ASSERT_JH(VAR_4, VAR_4->b_transaction != VAR_2 ||
VAR_4->b_jlist == VAR_8);
jbd_unlock_bh_state(VAR_1);
}
goto out;
}
VAR_3 = VAR_2->t_journal;
jbd_debug(5, ""journal_head %p\n"", VAR_4);
JBUFFER_TRACE(VAR_4, ""entry"");
jbd_lock_bh_state(VAR_1);
if (VAR_4->b_modified == 0) {
VAR_4->b_modified = 1;
if (VAR_0->h_buffer_credits <= 0) {
VAR_5 = -VAR_9;
goto out_unlock_bh;
}
VAR_0->h_buffer_credits--;
}
if (VAR_4->b_transaction == VAR_2 && VAR_4->b_jlist == VAR_8) {
JBUFFER_TRACE(VAR_4, ""fastpath"");
if (unlikely(VAR_4->b_transaction !=
VAR_3->j_running_transaction)) {
printk(KERN_ERR ""JBD2: %s: ""
""jh->b_transaction (%llu, %p, %u) != ""
""journal->j_running_transaction (%p, %u)\n"",
VAR_3->j_devname,
(unsigned long long) VAR_1->b_blocknr,
VAR_4->b_transaction,
VAR_4->b_transaction ? VAR_4->b_transaction->t_tid : 0,
VAR_3->j_running_transaction,
VAR_3->j_running_transaction ?
VAR_3->j_running_transaction->t_tid : 0);
VAR_5 = -VAR_10;
}
goto out_unlock_bh;
}
set_buffer_jbddirty(VAR_1);
if (VAR_4->b_transaction != VAR_2) {
JBUFFER_TRACE(VAR_4, ""already on other transaction"");
if (unlikely(((VAR_4->b_transaction !=
VAR_3->j_committing_transaction)) ||
(VAR_4->b_next_transaction != VAR_2))) {
printk(KERN_ERR ""jbd2_journal_dirty_metadata: %s: ""
""bad jh for block %llu: ""
""transaction (%p, %u), ""
""jh->b_transaction (%p, %u), ""
""jh->b_next_transaction (%p, %u), jlist %u\n"",
VAR_3->j_devname,
(unsigned long long) VAR_1->b_blocknr,
VAR_2, VAR_2->t_tid,
VAR_4->b_transaction,
VAR_4->b_transaction ?
VAR_4->b_transaction->t_tid : 0,
VAR_4->b_next_transaction,
VAR_4->b_next_transaction ?
VAR_4->b_next_transaction->t_tid : 0,
VAR_4->b_jlist);
WARN_ON(1);
VAR_5 = -VAR_10;
}
goto out_unlock_bh;
}
J_ASSERT_JH(VAR_4, VAR_4->b_frozen_data == NULL);
JBUFFER_TRACE(VAR_4, ""file as BJ_Metadata"");
spin_lock(&VAR_3->j_list_lock);
__jbd2_journal_file_buffer(VAR_4, VAR_2, VAR_8);
spin_unlock(&VAR_3->j_list_lock);
out_unlock_bh:
jbd_unlock_bh_state(VAR_1);
out:
JBUFFER_TRACE(VAR_4, ""exit"");
return VAR_5;
}",torvalds/linux/e09463f220ca9a1a1ecfda84fcda658f99a1f12a/transaction.c/vul/before/0.json,"int jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)
{
	transaction_t *transaction = handle->h_transaction;
	journal_t *journal;
	struct journal_head *jh;
	int ret = 0;

	if (is_handle_aborted(handle))
		return -EROFS;
	if (!buffer_jbd(bh)) {
		ret = -EUCLEAN;
		goto out;
	}
	/*
	 * We don't grab jh reference here since the buffer must be part
	 * of the running transaction.
	 */
	jh = bh2jh(bh);
	/*
	 * This and the following assertions are unreliable since we may see jh
	 * in inconsistent state unless we grab bh_state lock. But this is
	 * crucial to catch bugs so let's do a reliable check until the
	 * lockless handling is fully proven.
	 */
	if (jh->b_transaction != transaction &&
	    jh->b_next_transaction != transaction) {
		jbd_lock_bh_state(bh);
		J_ASSERT_JH(jh, jh->b_transaction == transaction ||
				jh->b_next_transaction == transaction);
		jbd_unlock_bh_state(bh);
	}
	if (jh->b_modified == 1) {
		/* If it's in our transaction it must be in BJ_Metadata list. */
		if (jh->b_transaction == transaction &&
		    jh->b_jlist != BJ_Metadata) {
			jbd_lock_bh_state(bh);
			if (jh->b_transaction == transaction &&
			    jh->b_jlist != BJ_Metadata)
				pr_err(""JBD2: assertion failure: h_type=%u ""
				       ""h_line_no=%u block_no=%llu jlist=%u\n"",
				       handle->h_type, handle->h_line_no,
				       (unsigned long long) bh->b_blocknr,
				       jh->b_jlist);
			J_ASSERT_JH(jh, jh->b_transaction != transaction ||
					jh->b_jlist == BJ_Metadata);
			jbd_unlock_bh_state(bh);
		}
		goto out;
	}

	journal = transaction->t_journal;
	jbd_debug(5, ""journal_head %p\n"", jh);
	JBUFFER_TRACE(jh, ""entry"");

	jbd_lock_bh_state(bh);

	if (jh->b_modified == 0) {
		/*
		 * This buffer's got modified and becoming part
		 * of the transaction. This needs to be done
		 * once a transaction -bzzz
		 */
		if (handle->h_buffer_credits <= 0) {
			ret = -ENOSPC;
			goto out_unlock_bh;
		}
		jh->b_modified = 1;
		handle->h_buffer_credits--;
	}

	/*
	 * fastpath, to avoid expensive locking.  If this buffer is already
	 * on the running transaction's metadata list there is nothing to do.
	 * Nobody can take it off again because there is a handle open.
	 * I _think_ we're OK here with SMP barriers - a mistaken decision will
	 * result in this test being false, so we go in and take the locks.
	 */
	if (jh->b_transaction == transaction && jh->b_jlist == BJ_Metadata) {
		JBUFFER_TRACE(jh, ""fastpath"");
		if (unlikely(jh->b_transaction !=
			     journal->j_running_transaction)) {
			printk(KERN_ERR ""JBD2: %s: ""
			       ""jh->b_transaction (%llu, %p, %u) != ""
			       ""journal->j_running_transaction (%p, %u)\n"",
			       journal->j_devname,
			       (unsigned long long) bh->b_blocknr,
			       jh->b_transaction,
			       jh->b_transaction ? jh->b_transaction->t_tid : 0,
			       journal->j_running_transaction,
			       journal->j_running_transaction ?
			       journal->j_running_transaction->t_tid : 0);
			ret = -EINVAL;
		}
		goto out_unlock_bh;
	}

	set_buffer_jbddirty(bh);

	/*
	 * Metadata already on the current transaction list doesn't
	 * need to be filed.  Metadata on another transaction's list must
	 * be committing, and will be refiled once the commit completes:
	 * leave it alone for now.
	 */
	if (jh->b_transaction != transaction) {
		JBUFFER_TRACE(jh, ""already on other transaction"");
		if (unlikely(((jh->b_transaction !=
			       journal->j_committing_transaction)) ||
			     (jh->b_next_transaction != transaction))) {
			printk(KERN_ERR ""jbd2_journal_dirty_metadata: %s: ""
			       ""bad jh for block %llu: ""
			       ""transaction (%p, %u), ""
			       ""jh->b_transaction (%p, %u), ""
			       ""jh->b_next_transaction (%p, %u), jlist %u\n"",
			       journal->j_devname,
			       (unsigned long long) bh->b_blocknr,
			       transaction, transaction->t_tid,
			       jh->b_transaction,
			       jh->b_transaction ?
			       jh->b_transaction->t_tid : 0,
			       jh->b_next_transaction,
			       jh->b_next_transaction ?
			       jh->b_next_transaction->t_tid : 0,
			       jh->b_jlist);
			WARN_ON(1);
			ret = -EINVAL;
		}
		/* And this case is illegal: we can't reuse another
		 * transaction's data buffer, ever. */
		goto out_unlock_bh;
	}

	/* That test should have eliminated the following case: */
	J_ASSERT_JH(jh, jh->b_frozen_data == NULL);

	JBUFFER_TRACE(jh, ""file as BJ_Metadata"");
	spin_lock(&journal->j_list_lock);
	__jbd2_journal_file_buffer(jh, transaction, BJ_Metadata);
	spin_unlock(&journal->j_list_lock);
out_unlock_bh:
	jbd_unlock_bh_state(bh);
out:
	JBUFFER_TRACE(jh, ""exit"");
	return ret;
}","int jbd2_journal_dirty_metadata(handle_t *VAR_0, struct buffer_head *VAR_1)
{
	transaction_t *VAR_2 = VAR_0->h_transaction;
	journal_t *VAR_3;
	struct journal_head *VAR_4;
	int VAR_5 = 0;

	if (is_handle_aborted(VAR_0))
		return -VAR_6;
	if (!buffer_jbd(VAR_1)) {
		VAR_5 = -VAR_7;
		goto out;
	}
	/* COMMENT_0 */
                                                                 
                               
    
	VAR_4 = bh2jh(VAR_1);
	/* COMMENT_4 */
                                                                        
                                                                   
                                                                
                                      
    
	if (VAR_4->b_transaction != VAR_2 &&
	    VAR_4->b_next_transaction != VAR_2) {
		jbd_lock_bh_state(VAR_1);
		J_ASSERT_JH(VAR_4, VAR_4->b_transaction == VAR_2 ||
				VAR_4->b_next_transaction == VAR_2);
		jbd_unlock_bh_state(VAR_1);
	}
	if (VAR_4->b_modified == 1) {
		/* COMMENT_10 */
		if (VAR_4->b_transaction == VAR_2 &&
		    VAR_4->b_jlist != VAR_8) {
			jbd_lock_bh_state(VAR_1);
			if (VAR_4->b_transaction == VAR_2 &&
			    VAR_4->b_jlist != VAR_8)
				pr_err(""JBD2: assertion failure: h_type=%u ""
				       ""h_line_no=%u block_no=%llu jlist=%u\n"",
				       VAR_0->h_type, VAR_0->h_line_no,
				       (unsigned long long) VAR_1->b_blocknr,
				       VAR_4->b_jlist);
			J_ASSERT_JH(VAR_4, VAR_4->b_transaction != VAR_2 ||
					VAR_4->b_jlist == VAR_8);
			jbd_unlock_bh_state(VAR_1);
		}
		goto out;
	}

	VAR_3 = VAR_2->t_journal;
	jbd_debug(5, ""journal_head %p\n"", VAR_4);
	JBUFFER_TRACE(VAR_4, ""entry"");

	jbd_lock_bh_state(VAR_1);

	if (VAR_4->b_modified == 0) {
		/* COMMENT_11 */
                                                 
                                              
                             
     
		if (VAR_0->h_buffer_credits <= 0) {
			VAR_5 = -VAR_9;
			goto out_unlock_bh;
		}
		VAR_4->b_modified = 1;
		VAR_0->h_buffer_credits--;
	}

	/* COMMENT_16 */
                                                                    
                                                                      
                                                                
                                                                        
                                                                    
    
	if (VAR_4->b_transaction == VAR_2 && VAR_4->b_jlist == VAR_8) {
		JBUFFER_TRACE(VAR_4, ""fastpath"");
		if (unlikely(VAR_4->b_transaction !=
			     VAR_3->j_running_transaction)) {
			printk(KERN_ERR ""JBD2: %s: ""
			       ""jh->b_transaction (%llu, %p, %u) != ""
			       ""journal->j_running_transaction (%p, %u)\n"",
			       VAR_3->j_devname,
			       (unsigned long long) VAR_1->b_blocknr,
			       VAR_4->b_transaction,
			       VAR_4->b_transaction ? VAR_4->b_transaction->t_tid : 0,
			       VAR_3->j_running_transaction,
			       VAR_3->j_running_transaction ?
			       VAR_3->j_running_transaction->t_tid : 0);
			VAR_5 = -VAR_10;
		}
		goto out_unlock_bh;
	}

	set_buffer_jbddirty(VAR_1);

	/* COMMENT_23 */
                                                            
                                                                  
                                                                 
                           
    
	if (VAR_4->b_transaction != VAR_2) {
		JBUFFER_TRACE(VAR_4, ""already on other transaction"");
		if (unlikely(((VAR_4->b_transaction !=
			       VAR_3->j_committing_transaction)) ||
			     (VAR_4->b_next_transaction != VAR_2))) {
			printk(KERN_ERR ""jbd2_journal_dirty_metadata: %s: ""
			       ""bad jh for block %llu: ""
			       ""transaction (%p, %u), ""
			       ""jh->b_transaction (%p, %u), ""
			       ""jh->b_next_transaction (%p, %u), jlist %u\n"",
			       VAR_3->j_devname,
			       (unsigned long long) VAR_1->b_blocknr,
			       VAR_2, VAR_2->t_tid,
			       VAR_4->b_transaction,
			       VAR_4->b_transaction ?
			       VAR_4->b_transaction->t_tid : 0,
			       VAR_4->b_next_transaction,
			       VAR_4->b_next_transaction ?
			       VAR_4->b_next_transaction->t_tid : 0,
			       VAR_4->b_jlist);
			WARN_ON(1);
			VAR_5 = -VAR_10;
		}
		/* COMMENT_29 */
                                        
		goto out_unlock_bh;
	}

	/* COMMENT_31 */
	J_ASSERT_JH(VAR_4, VAR_4->b_frozen_data == NULL);

	JBUFFER_TRACE(VAR_4, ""file as BJ_Metadata"");
	spin_lock(&VAR_3->j_list_lock);
	__jbd2_journal_file_buffer(VAR_4, VAR_2, VAR_8);
	spin_unlock(&VAR_3->j_list_lock);
out_unlock_bh:
	jbd_unlock_bh_state(VAR_1);
out:
	JBUFFER_TRACE(VAR_4, ""exit"");
	return VAR_5;
}",torvalds/linux/e09463f220ca9a1a1ecfda84fcda658f99a1f12a/transaction.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -34,6 +34,13 @@
 		if (jh->b_transaction == transaction &&
 		    jh->b_jlist != BJ_Metadata) {
 			jbd_lock_bh_state(bh);
+			if (jh->b_transaction == transaction &&
+			    jh->b_jlist != BJ_Metadata)
+				pr_err(""JBD2: assertion failure: h_type=%u ""
+				       ""h_line_no=%u block_no=%llu jlist=%u\n"",
+				       handle->h_type, handle->h_line_no,
+				       (unsigned long long) bh->b_blocknr,
+				       jh->b_jlist);
 			J_ASSERT_JH(jh, jh->b_transaction != transaction ||
 					jh->b_jlist == BJ_Metadata);
 			jbd_unlock_bh_state(bh);
@@ -53,11 +60,11 @@
 		 * of the transaction. This needs to be done
 		 * once a transaction -bzzz
 		 */
-		jh->b_modified = 1;
 		if (handle->h_buffer_credits <= 0) {
 			ret = -ENOSPC;
 			goto out_unlock_bh;
 		}
+		jh->b_modified = 1;
 		handle->h_buffer_credits--;
 	}
 ","{'deleted_lines': ['\t\tjh->b_modified = 1;'], 'added_lines': ['\t\t\tif (jh->b_transaction == transaction &&', '\t\t\t    jh->b_jlist != BJ_Metadata)', '\t\t\t\tpr_err(""JBD2: assertion failure: h_type=%u ""', '\t\t\t\t       ""h_line_no=%u block_no=%llu jlist=%u\\n"",', '\t\t\t\t       handle->h_type, handle->h_line_no,', '\t\t\t\t       (unsigned long long) bh->b_blocknr,', '\t\t\t\t       jh->b_jlist);', '\t\tjh->b_modified = 1;']}",True,"A flaw was found in the Linux kernel's ext4 filesystem. A local user can cause an out-of-bounds write in jbd2_journal_dirty_metadata(), a denial of service, and a system crash by mounting and operating on a crafted ext4 filesystem image.",4.8,MEDIUM,1,test,,5
CVE-2018-10883,['CWE-787'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Use a separate journal transaction if it turns out that we need to
convert an inline file to use an data block.  Otherwise we could end
up failing due to not having journal credits.

This addresses CVE-2018-10883.

https://bugzilla.kernel.org/show_bug.cgi?id=200071

Signed-off-by: Theodore Ts'o <tytso@mit.edu>
Cc: stable@kernel.org
",8bc1379b82b8e809eef77a9fedbb75c6c297be19,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=8bc1379b82b8e809eef77a9fedbb75c6c297be19,fs/ext4/xattr.c,ext4_xattr_ibody_inline_set,"int ext4_xattr_ibody_inline_set(handle_t *handle, struct inode *inode,
struct ext4_xattr_info *i,
struct ext4_xattr_ibody_find *is)
{
struct ext4_xattr_ibody_header *header;
struct ext4_xattr_search *s = &is->s;
int error;
if (EXT4_I(inode)->i_extra_isize == 0)
return -ENOSPC;
error = ext4_xattr_set_entry(i, s, handle, inode, false );
if (error) {
if (error == -ENOSPC &&
ext4_has_inline_data(inode)) {
error = ext4_try_to_evict_inline_data(handle, inode,
EXT4_XATTR_LEN(strlen(i->name) +
EXT4_XATTR_SIZE(i->value_len)));
if (error)
return error;
error = ext4_xattr_ibody_find(inode, i, is);
if (error)
return error;
error = ext4_xattr_set_entry(i, s, handle, inode,
false );
}
if (error)
return error;
}
header = IHDR(inode, ext4_raw_inode(&is->iloc));
if (!IS_LAST_ENTRY(s->first)) {
header->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);
ext4_set_inode_state(inode, EXT4_STATE_XATTR);
} else {
header->h_magic = cpu_to_le32(0);
ext4_clear_inode_state(inode, EXT4_STATE_XATTR);
}
return 0;
}","int ext4_xattr_ibody_inline_set(handle_t *VAR_0, struct inode *inode,
struct ext4_xattr_info *VAR_1,
struct ext4_xattr_ibody_find *VAR_2)
{
struct ext4_xattr_ibody_header *VAR_3;
struct ext4_xattr_search *VAR_4 = &VAR_2->s;
int VAR_5;
if (EXT4_I(inode)->i_extra_isize == 0)
return -VAR_6;
VAR_5 = ext4_xattr_set_entry(VAR_1, VAR_4, VAR_0, inode, false );
if (VAR_5) {
if (VAR_5 == -VAR_6 &&
ext4_has_inline_data(inode)) {
VAR_5 = ext4_try_to_evict_inline_data(VAR_0, inode,
EXT4_XATTR_LEN(strlen(VAR_1->name) +
EXT4_XATTR_SIZE(VAR_1->value_len)));
if (VAR_5)
return VAR_5;
VAR_5 = ext4_xattr_ibody_find(inode, VAR_1, VAR_2);
if (VAR_5)
return VAR_5;
VAR_5 = ext4_xattr_set_entry(VAR_1, VAR_4, VAR_0, inode,
false );
}
if (VAR_5)
return VAR_5;
}
VAR_3 = IHDR(inode, ext4_raw_inode(&VAR_2->iloc));
if (!IS_LAST_ENTRY(VAR_4->first)) {
VAR_3->h_magic = cpu_to_le32(VAR_7);
ext4_set_inode_state(inode, VAR_8);
} else {
VAR_3->h_magic = cpu_to_le32(0);
ext4_clear_inode_state(inode, VAR_8);
}
return 0;
}",torvalds/linux/8bc1379b82b8e809eef77a9fedbb75c6c297be19/xattr.c/vul/before/0.json,"int ext4_xattr_ibody_inline_set(handle_t *handle, struct inode *inode,
				struct ext4_xattr_info *i,
				struct ext4_xattr_ibody_find *is)
{
	struct ext4_xattr_ibody_header *header;
	struct ext4_xattr_search *s = &is->s;
	int error;

	if (EXT4_I(inode)->i_extra_isize == 0)
		return -ENOSPC;
	error = ext4_xattr_set_entry(i, s, handle, inode, false /* is_block */);
	if (error)
		return error;
	header = IHDR(inode, ext4_raw_inode(&is->iloc));
	if (!IS_LAST_ENTRY(s->first)) {
		header->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);
		ext4_set_inode_state(inode, EXT4_STATE_XATTR);
	} else {
		header->h_magic = cpu_to_le32(0);
		ext4_clear_inode_state(inode, EXT4_STATE_XATTR);
	}
	return 0;
}","int ext4_xattr_ibody_inline_set(handle_t *VAR_0, struct inode *inode,
				struct ext4_xattr_info *VAR_1,
				struct ext4_xattr_ibody_find *VAR_2)
{
	struct ext4_xattr_ibody_header *VAR_3;
	struct ext4_xattr_search *VAR_4 = &VAR_2->s;
	int VAR_5;

	if (EXT4_I(inode)->i_extra_isize == 0)
		return -VAR_6;
	VAR_5 = ext4_xattr_set_entry(VAR_1, VAR_4, VAR_0, inode, false /* COMMENT_0 */);
	if (VAR_5)
		return VAR_5;
	VAR_3 = IHDR(inode, ext4_raw_inode(&VAR_2->iloc));
	if (!IS_LAST_ENTRY(VAR_4->first)) {
		VAR_3->h_magic = cpu_to_le32(VAR_7);
		ext4_set_inode_state(inode, VAR_8);
	} else {
		VAR_3->h_magic = cpu_to_le32(0);
		ext4_clear_inode_state(inode, VAR_8);
	}
	return 0;
}",torvalds/linux/8bc1379b82b8e809eef77a9fedbb75c6c297be19/xattr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,23 +9,8 @@
 	if (EXT4_I(inode)->i_extra_isize == 0)
 		return -ENOSPC;
 	error = ext4_xattr_set_entry(i, s, handle, inode, false /* is_block */);
-	if (error) {
-		if (error == -ENOSPC &&
-		    ext4_has_inline_data(inode)) {
-			error = ext4_try_to_evict_inline_data(handle, inode,
-					EXT4_XATTR_LEN(strlen(i->name) +
-					EXT4_XATTR_SIZE(i->value_len)));
-			if (error)
-				return error;
-			error = ext4_xattr_ibody_find(inode, i, is);
-			if (error)
-				return error;
-			error = ext4_xattr_set_entry(i, s, handle, inode,
-						     false /* is_block */);
-		}
-		if (error)
-			return error;
-	}
+	if (error)
+		return error;
 	header = IHDR(inode, ext4_raw_inode(&is->iloc));
 	if (!IS_LAST_ENTRY(s->first)) {
 		header->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);","{'deleted_lines': ['\tif (error) {', '\t\tif (error == -ENOSPC &&', '\t\t    ext4_has_inline_data(inode)) {', '\t\t\terror = ext4_try_to_evict_inline_data(handle, inode,', '\t\t\t\t\tEXT4_XATTR_LEN(strlen(i->name) +', '\t\t\t\t\tEXT4_XATTR_SIZE(i->value_len)));', '\t\t\tif (error)', '\t\t\t\treturn error;', '\t\t\terror = ext4_xattr_ibody_find(inode, i, is);', '\t\t\tif (error)', '\t\t\t\treturn error;', '\t\t\terror = ext4_xattr_set_entry(i, s, handle, inode,', '\t\t\t\t\t\t     false /* is_block */);', '\t\t}', '\t\tif (error)', '\t\t\treturn error;', '\t}'], 'added_lines': ['\tif (error)', '\t\treturn error;']}",True,"A flaw was found in the Linux kernel's ext4 filesystem. A local user can cause an out-of-bounds write in jbd2_journal_dirty_metadata(), a denial of service, and a system crash by mounting and operating on a crafted ext4 filesystem image.",4.8,MEDIUM,1,test,,5
CVE-2018-10883,['CWE-787'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Use a separate journal transaction if it turns out that we need to
convert an inline file to use an data block.  Otherwise we could end
up failing due to not having journal credits.

This addresses CVE-2018-10883.

https://bugzilla.kernel.org/show_bug.cgi?id=200071

Signed-off-by: Theodore Ts'o <tytso@mit.edu>
Cc: stable@kernel.org
",8bc1379b82b8e809eef77a9fedbb75c6c297be19,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=8bc1379b82b8e809eef77a9fedbb75c6c297be19,fs/ext4/inline.c,ext4_da_write_inline_data_begin,"int ext4_da_write_inline_data_begin(struct address_space *mapping,
struct inode *inode,
loff_t pos, unsigned len,
unsigned flags,
struct page **pagep,
void **fsdata)
{
int ret, inline_size;
handle_t *handle;
struct page *page;
struct ext4_iloc iloc;
int retries;
ret = ext4_get_inode_loc(inode, &iloc);
if (ret)
return ret;
retry_journal:
handle = ext4_journal_start(inode, EXT4_HT_INODE, 1);
if (IS_ERR(handle)) {
ret = PTR_ERR(handle);
goto out;
}
inline_size = ext4_get_max_inline_size(inode);
ret = -ENOSPC;
if (inline_size >= pos + len) {
ret = ext4_prepare_inline_data(handle, inode, pos + len);
if (ret && ret != -ENOSPC)
goto out_journal;
}
flags |= AOP_FLAG_NOFS;
if (ret == -ENOSPC) {
ret = ext4_da_convert_inline_data_to_extent(mapping,
inode,
flags,
fsdata);
ext4_journal_stop(handle);
if (ret == -ENOSPC &&
ext4_should_retry_alloc(inode->i_sb, &retries))
goto retry_journal;
goto out;
}
page = grab_cache_page_write_begin(mapping, 0, flags);
if (!page) {
ret = -ENOMEM;
goto out_journal;
}
down_read(&EXT4_I(inode)->xattr_sem);
if (!ext4_has_inline_data(inode)) {
ret = 0;
goto out_release_page;
}
if (!PageUptodate(page)) {
ret = ext4_read_inline_page(inode, page);
if (ret < 0)
goto out_release_page;
}
up_read(&EXT4_I(inode)->xattr_sem);
*pagep = page;
brelse(iloc.bh);
return 1;
out_release_page:
up_read(&EXT4_I(inode)->xattr_sem);
unlock_page(page);
put_page(page);
out_journal:
ext4_journal_stop(handle);
out:
brelse(iloc.bh);
return ret;
}","int ext4_da_write_inline_data_begin(struct address_space *VAR_0,
struct inode *inode,
loff_t VAR_1, unsigned VAR_2,
unsigned VAR_3,
struct page **VAR_4,
void **VAR_5)
{
int VAR_6, VAR_7;
handle_t *VAR_8;
struct page *page;
struct ext4_iloc VAR_9;
int VAR_10;
VAR_6 = ext4_get_inode_loc(inode, &VAR_9);
if (VAR_6)
return VAR_6;
retry_journal:
VAR_8 = ext4_journal_start(inode, VAR_11, 1);
if (IS_ERR(VAR_8)) {
VAR_6 = PTR_ERR(VAR_8);
goto out;
}
VAR_7 = ext4_get_max_inline_size(inode);
VAR_6 = -VAR_12;
if (VAR_7 >= VAR_1 + VAR_2) {
VAR_6 = ext4_prepare_inline_data(VAR_8, inode, VAR_1 + VAR_2);
if (VAR_6 && VAR_6 != -VAR_12)
goto out_journal;
}
VAR_3 |= VAR_13;
if (VAR_6 == -VAR_12) {
VAR_6 = ext4_da_convert_inline_data_to_extent(VAR_0,
inode,
VAR_3,
VAR_5);
ext4_journal_stop(VAR_8);
if (VAR_6 == -VAR_12 &&
ext4_should_retry_alloc(inode->i_sb, &VAR_10))
goto retry_journal;
goto out;
}
page = grab_cache_page_write_begin(VAR_0, 0, VAR_3);
if (!page) {
VAR_6 = -VAR_14;
goto out_journal;
}
down_read(&EXT4_I(inode)->xattr_sem);
if (!ext4_has_inline_data(inode)) {
VAR_6 = 0;
goto out_release_page;
}
if (!PageUptodate(page)) {
VAR_6 = ext4_read_inline_page(inode, page);
if (VAR_6 < 0)
goto out_release_page;
}
up_read(&EXT4_I(inode)->xattr_sem);
*VAR_4 = page;
brelse(VAR_9.bh);
return 1;
out_release_page:
up_read(&EXT4_I(inode)->xattr_sem);
unlock_page(page);
put_page(page);
out_journal:
ext4_journal_stop(VAR_8);
out:
brelse(VAR_9.bh);
return VAR_6;
}",torvalds/linux/8bc1379b82b8e809eef77a9fedbb75c6c297be19/inline.c/vul/before/0.json,"int ext4_da_write_inline_data_begin(struct address_space *mapping,
				    struct inode *inode,
				    loff_t pos, unsigned len,
				    unsigned flags,
				    struct page **pagep,
				    void **fsdata)
{
	int ret, inline_size;
	handle_t *handle;
	struct page *page;
	struct ext4_iloc iloc;
	int retries;

	ret = ext4_get_inode_loc(inode, &iloc);
	if (ret)
		return ret;

retry_journal:
	handle = ext4_journal_start(inode, EXT4_HT_INODE, 1);
	if (IS_ERR(handle)) {
		ret = PTR_ERR(handle);
		goto out;
	}

	inline_size = ext4_get_max_inline_size(inode);

	ret = -ENOSPC;
	if (inline_size >= pos + len) {
		ret = ext4_prepare_inline_data(handle, inode, pos + len);
		if (ret && ret != -ENOSPC)
			goto out_journal;
	}

	/*
	 * We cannot recurse into the filesystem as the transaction
	 * is already started.
	 */
	flags |= AOP_FLAG_NOFS;

	if (ret == -ENOSPC) {
		ext4_journal_stop(handle);
		ret = ext4_da_convert_inline_data_to_extent(mapping,
							    inode,
							    flags,
							    fsdata);
		if (ret == -ENOSPC &&
		    ext4_should_retry_alloc(inode->i_sb, &retries))
			goto retry_journal;
		goto out;
	}


	page = grab_cache_page_write_begin(mapping, 0, flags);
	if (!page) {
		ret = -ENOMEM;
		goto out_journal;
	}

	down_read(&EXT4_I(inode)->xattr_sem);
	if (!ext4_has_inline_data(inode)) {
		ret = 0;
		goto out_release_page;
	}

	if (!PageUptodate(page)) {
		ret = ext4_read_inline_page(inode, page);
		if (ret < 0)
			goto out_release_page;
	}

	up_read(&EXT4_I(inode)->xattr_sem);
	*pagep = page;
	brelse(iloc.bh);
	return 1;
out_release_page:
	up_read(&EXT4_I(inode)->xattr_sem);
	unlock_page(page);
	put_page(page);
out_journal:
	ext4_journal_stop(handle);
out:
	brelse(iloc.bh);
	return ret;
}","int ext4_da_write_inline_data_begin(struct address_space *VAR_0,
				    struct inode *inode,
				    loff_t VAR_1, unsigned VAR_2,
				    unsigned VAR_3,
				    struct page **VAR_4,
				    void **VAR_5)
{
	int VAR_6, VAR_7;
	handle_t *VAR_8;
	struct page *page;
	struct ext4_iloc VAR_9;
	int VAR_10;

	VAR_6 = ext4_get_inode_loc(inode, &VAR_9);
	if (VAR_6)
		return VAR_6;

retry_journal:
	VAR_8 = ext4_journal_start(inode, VAR_11, 1);
	if (IS_ERR(VAR_8)) {
		VAR_6 = PTR_ERR(VAR_8);
		goto out;
	}

	VAR_7 = ext4_get_max_inline_size(inode);

	VAR_6 = -VAR_12;
	if (VAR_7 >= VAR_1 + VAR_2) {
		VAR_6 = ext4_prepare_inline_data(VAR_8, inode, VAR_1 + VAR_2);
		if (VAR_6 && VAR_6 != -VAR_12)
			goto out_journal;
	}

	/* COMMENT_0 */
                                                            
                       
    
	VAR_3 |= VAR_13;

	if (VAR_6 == -VAR_12) {
		ext4_journal_stop(VAR_8);
		VAR_6 = ext4_da_convert_inline_data_to_extent(VAR_0,
							    inode,
							    VAR_3,
							    VAR_5);
		if (VAR_6 == -VAR_12 &&
		    ext4_should_retry_alloc(inode->i_sb, &VAR_10))
			goto retry_journal;
		goto out;
	}


	page = grab_cache_page_write_begin(VAR_0, 0, VAR_3);
	if (!page) {
		VAR_6 = -VAR_14;
		goto out_journal;
	}

	down_read(&EXT4_I(inode)->xattr_sem);
	if (!ext4_has_inline_data(inode)) {
		VAR_6 = 0;
		goto out_release_page;
	}

	if (!PageUptodate(page)) {
		VAR_6 = ext4_read_inline_page(inode, page);
		if (VAR_6 < 0)
			goto out_release_page;
	}

	up_read(&EXT4_I(inode)->xattr_sem);
	*VAR_4 = page;
	brelse(VAR_9.bh);
	return 1;
out_release_page:
	up_read(&EXT4_I(inode)->xattr_sem);
	unlock_page(page);
	put_page(page);
out_journal:
	ext4_journal_stop(VAR_8);
out:
	brelse(VAR_9.bh);
	return VAR_6;
}",torvalds/linux/8bc1379b82b8e809eef77a9fedbb75c6c297be19/inline.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -38,11 +38,11 @@
 	flags |= AOP_FLAG_NOFS;
 
 	if (ret == -ENOSPC) {
+		ext4_journal_stop(handle);
 		ret = ext4_da_convert_inline_data_to_extent(mapping,
 							    inode,
 							    flags,
 							    fsdata);
-		ext4_journal_stop(handle);
 		if (ret == -ENOSPC &&
 		    ext4_should_retry_alloc(inode->i_sb, &retries))
 			goto retry_journal;","{'deleted_lines': ['\t\text4_journal_stop(handle);'], 'added_lines': ['\t\text4_journal_stop(handle);']}",True,"A flaw was found in the Linux kernel's ext4 filesystem. A local user can cause an out-of-bounds write in jbd2_journal_dirty_metadata(), a denial of service, and a system crash by mounting and operating on a crafted ext4 filesystem image.",4.8,MEDIUM,1,test,,5
CVE-2018-9498,"['CWE-190', 'CWE-787']",AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"RESTRICT AUTOMERGE: Cherry-pick ""begin cleanup of malloc porting layer""

Bug: 78354855
Test: Not feasible

Original description:
========================================================================
1. Merge some of the allocators into sk_malloc_flags by redefining a flag to mean zero-init
2. Add more private helpers to simplify our call-sites (and handle some overflow mul checks)
3. The 2-param helpers rely on the saturating SkSafeMath::Mul to pass max_size_t as the request,
which should always fail.

chromium: 508641
Reviewed-on: https://skia-review.googlesource.com/90940
Commit-Queue: Mike Reed <reed@google.com>
Reviewed-by: Robert Phillips <robertphillips@google.com>
Reviewed-by: Stephan Altmueller <stephana@google.com>
========================================================================

Conflicts:
- include/private/SkMalloc.h
Simply removed the old definitions of SK_MALLOC_TEMP and SK_MALLOC_THROW.
- public.bzl
Copied SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER into the old defines.
- src/codec/SkIcoCodec.cpp
Drop a change where we were not using malloc yet.
- src/codec/SkBmpBaseCodec.cpp
- src/core/SkBitmapCache.cpp
These files weren't yet using malloc (and SkBmpBaseCodec hadn't been
factored out).
- src/core/SkMallocPixelRef.cpp
These were still using New rather than Make (return raw pointer). Leave
them unchanged, as sk_malloc_flags is still valid.
- src/lazy/SkDiscardableMemoryPool.cpp
Leave this unchanged; sk_malloc_flags is still valid

In addition, pull in SkSafeMath.h, which was originally introduced in
https://skia-review.googlesource.com/c/skia/+/33721. This is required
for the new sk_malloc calls.

Also pull in SkSafeMath::Add and SkSafeMath::Mul, introduced in
https://skia-review.googlesource.com/88581

Also add SK_MaxSizeT, which the above depends on, introduced in
https://skia-review.googlesource.com/57084

Also, modify NewFromStream to use sk_malloc_canfail, matching pi and
avoiding a build break

Change-Id: Ib320484673a865460fc1efb900f611209e088edb
(cherry picked from commit a12cc3e14ea6734c7efe76aa6a19239909830b28)
",77c955200ddd1761d6ed7a6c1578349fedbb55e4,https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4,src/gpu/GrBuffer.cpp,GrBuffer::CreateCPUBacked,"GrBuffer* GrBuffer::CreateCPUBacked(GrGpu* gpu, size_t sizeInBytes, GrBufferType intendedType,
const void* data) {
SkASSERT(GrBufferTypeIsVertexOrIndex(intendedType));
void* cpuData;
if (gpu->caps()->mustClearUploadedBufferData()) {
cpuData = sk_calloc_throw(sizeInBytes);
} else {
cpuData = sk_malloc_flags(sizeInBytes, SK_MALLOC_THROW);
}
if (data) {
memcpy(cpuData, data, sizeInBytes);
}
return new GrBuffer(gpu, sizeInBytes, intendedType, cpuData);
}","GrBuffer* GrBuffer::CreateCPUBacked(GrGpu* VAR_0, size_t VAR_1, GrBufferType VAR_2,
const void* VAR_3) {
SkASSERT(GrBufferTypeIsVertexOrIndex(VAR_2));
void* VAR_4;
if (VAR_0->caps()->mustClearUploadedBufferData()) {
VAR_4 = sk_calloc_throw(VAR_1);
} else {
VAR_4 = sk_malloc_flags(VAR_1, VAR_5);
}
if (VAR_3) {
memcpy(VAR_4, VAR_3, VAR_1);
}
return new GrBuffer(VAR_0, VAR_1, VAR_2, VAR_4);
}",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/GrBuffer.cpp/vul/before/0.json,"GrBuffer* GrBuffer::CreateCPUBacked(GrGpu* gpu, size_t sizeInBytes, GrBufferType intendedType,
                                    const void* data) {
    SkASSERT(GrBufferTypeIsVertexOrIndex(intendedType));
    void* cpuData;
    if (gpu->caps()->mustClearUploadedBufferData()) {
        cpuData = sk_calloc_throw(sizeInBytes);
    } else {
        cpuData = sk_malloc_throw(sizeInBytes);
    }
    if (data) {
        memcpy(cpuData, data, sizeInBytes);
    }
    return new GrBuffer(gpu, sizeInBytes, intendedType, cpuData);
}","GrBuffer* GrBuffer::CreateCPUBacked(GrGpu* VAR_0, size_t VAR_1, GrBufferType VAR_2,
                                    const void* VAR_3) {
    SkASSERT(GrBufferTypeIsVertexOrIndex(VAR_2));
    void* VAR_4;
    if (VAR_0->caps()->mustClearUploadedBufferData()) {
        VAR_4 = sk_calloc_throw(VAR_1);
    } else {
        VAR_4 = sk_malloc_throw(VAR_1);
    }
    if (VAR_3) {
        memcpy(VAR_4, VAR_3, VAR_1);
    }
    return new GrBuffer(VAR_0, VAR_1, VAR_2, VAR_4);
}",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/GrBuffer.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,7 +5,7 @@
     if (gpu->caps()->mustClearUploadedBufferData()) {
         cpuData = sk_calloc_throw(sizeInBytes);
     } else {
-        cpuData = sk_malloc_flags(sizeInBytes, SK_MALLOC_THROW);
+        cpuData = sk_malloc_throw(sizeInBytes);
     }
     if (data) {
         memcpy(cpuData, data, sizeInBytes);","{'deleted_lines': ['        cpuData = sk_malloc_flags(sizeInBytes, SK_MALLOC_THROW);'], 'added_lines': ['        cpuData = sk_malloc_throw(sizeInBytes);']}",True,"In SkSampler::Fill of SkSampler.cpp, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-78354855",7.8,HIGH,2,test,,5
CVE-2018-9498,"['CWE-190', 'CWE-787']",AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"RESTRICT AUTOMERGE: Cherry-pick ""begin cleanup of malloc porting layer""

Bug: 78354855
Test: Not feasible

Original description:
========================================================================
1. Merge some of the allocators into sk_malloc_flags by redefining a flag to mean zero-init
2. Add more private helpers to simplify our call-sites (and handle some overflow mul checks)
3. The 2-param helpers rely on the saturating SkSafeMath::Mul to pass max_size_t as the request,
which should always fail.

chromium: 508641
Reviewed-on: https://skia-review.googlesource.com/90940
Commit-Queue: Mike Reed <reed@google.com>
Reviewed-by: Robert Phillips <robertphillips@google.com>
Reviewed-by: Stephan Altmueller <stephana@google.com>
========================================================================

Conflicts:
- include/private/SkMalloc.h
Simply removed the old definitions of SK_MALLOC_TEMP and SK_MALLOC_THROW.
- public.bzl
Copied SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER into the old defines.
- src/codec/SkIcoCodec.cpp
Drop a change where we were not using malloc yet.
- src/codec/SkBmpBaseCodec.cpp
- src/core/SkBitmapCache.cpp
These files weren't yet using malloc (and SkBmpBaseCodec hadn't been
factored out).
- src/core/SkMallocPixelRef.cpp
These were still using New rather than Make (return raw pointer). Leave
them unchanged, as sk_malloc_flags is still valid.
- src/lazy/SkDiscardableMemoryPool.cpp
Leave this unchanged; sk_malloc_flags is still valid

In addition, pull in SkSafeMath.h, which was originally introduced in
https://skia-review.googlesource.com/c/skia/+/33721. This is required
for the new sk_malloc calls.

Also pull in SkSafeMath::Add and SkSafeMath::Mul, introduced in
https://skia-review.googlesource.com/88581

Also add SK_MaxSizeT, which the above depends on, introduced in
https://skia-review.googlesource.com/57084

Also, modify NewFromStream to use sk_malloc_canfail, matching pi and
avoiding a build break

Change-Id: Ib320484673a865460fc1efb900f611209e088edb
(cherry picked from commit a12cc3e14ea6734c7efe76aa6a19239909830b28)
",77c955200ddd1761d6ed7a6c1578349fedbb55e4,https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4,src/core/SkAutoPixmapStorage.cpp,SkAutoPixmapStorage::tryAlloc,"bool SkAutoPixmapStorage::tryAlloc(const SkImageInfo& info) {
this->freeStorage();
size_t rb;
size_t size = AllocSize(info, &rb);
if (0 == size) {
return false;
}
void* pixels = sk_malloc_flags(size, 0);
if (nullptr == pixels) {
return false;
}
this->reset(info, pixels, rb);
fStorage = pixels;
return true;
}","bool SkAutoPixmapStorage::tryAlloc(const SkImageInfo& VAR_0) {
this->freeStorage();
size_t VAR_1;
size_t VAR_2 = AllocSize(VAR_0, &VAR_1);
if (0 == VAR_2) {
return false;
}
void* VAR_3 = sk_malloc_flags(VAR_2, 0);
if (nullptr == VAR_3) {
return false;
}
this->reset(VAR_0, VAR_3, VAR_1);
VAR_4 = VAR_3;
return true;
}",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkAutoPixmapStorage.cpp/vul/before/0.json,"bool SkAutoPixmapStorage::tryAlloc(const SkImageInfo& info) {
    this->freeStorage();

    size_t rb;
    size_t size = AllocSize(info, &rb);
    if (0 == size) {
        return false;
    }
    void* pixels = sk_malloc_canfail(size);
    if (nullptr == pixels) {
        return false;
    }
    this->reset(info, pixels, rb);
    fStorage = pixels;
    return true;
}","bool SkAutoPixmapStorage::tryAlloc(const SkImageInfo& VAR_0) {
    this->freeStorage();

    size_t VAR_1;
    size_t VAR_2 = AllocSize(VAR_0, &VAR_1);
    if (0 == VAR_2) {
        return false;
    }
    void* VAR_3 = sk_malloc_canfail(VAR_2);
    if (nullptr == VAR_3) {
        return false;
    }
    this->reset(VAR_0, VAR_3, VAR_1);
    VAR_4 = VAR_3;
    return true;
}",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkAutoPixmapStorage.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
     if (0 == size) {
         return false;
     }
-    void* pixels = sk_malloc_flags(size, 0);
+    void* pixels = sk_malloc_canfail(size);
     if (nullptr == pixels) {
         return false;
     }","{'deleted_lines': ['    void* pixels = sk_malloc_flags(size, 0);'], 'added_lines': ['    void* pixels = sk_malloc_canfail(size);']}",True,"In SkSampler::Fill of SkSampler.cpp, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-78354855",7.8,HIGH,2,test,,5
CVE-2018-9498,"['CWE-190', 'CWE-787']",AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"RESTRICT AUTOMERGE: Cherry-pick ""begin cleanup of malloc porting layer""

Bug: 78354855
Test: Not feasible

Original description:
========================================================================
1. Merge some of the allocators into sk_malloc_flags by redefining a flag to mean zero-init
2. Add more private helpers to simplify our call-sites (and handle some overflow mul checks)
3. The 2-param helpers rely on the saturating SkSafeMath::Mul to pass max_size_t as the request,
which should always fail.

chromium: 508641
Reviewed-on: https://skia-review.googlesource.com/90940
Commit-Queue: Mike Reed <reed@google.com>
Reviewed-by: Robert Phillips <robertphillips@google.com>
Reviewed-by: Stephan Altmueller <stephana@google.com>
========================================================================

Conflicts:
- include/private/SkMalloc.h
Simply removed the old definitions of SK_MALLOC_TEMP and SK_MALLOC_THROW.
- public.bzl
Copied SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER into the old defines.
- src/codec/SkIcoCodec.cpp
Drop a change where we were not using malloc yet.
- src/codec/SkBmpBaseCodec.cpp
- src/core/SkBitmapCache.cpp
These files weren't yet using malloc (and SkBmpBaseCodec hadn't been
factored out).
- src/core/SkMallocPixelRef.cpp
These were still using New rather than Make (return raw pointer). Leave
them unchanged, as sk_malloc_flags is still valid.
- src/lazy/SkDiscardableMemoryPool.cpp
Leave this unchanged; sk_malloc_flags is still valid

In addition, pull in SkSafeMath.h, which was originally introduced in
https://skia-review.googlesource.com/c/skia/+/33721. This is required
for the new sk_malloc calls.

Also pull in SkSafeMath::Add and SkSafeMath::Mul, introduced in
https://skia-review.googlesource.com/88581

Also add SK_MaxSizeT, which the above depends on, introduced in
https://skia-review.googlesource.com/57084

Also, modify NewFromStream to use sk_malloc_canfail, matching pi and
avoiding a build break

Change-Id: Ib320484673a865460fc1efb900f611209e088edb
(cherry picked from commit a12cc3e14ea6734c7efe76aa6a19239909830b28)
",77c955200ddd1761d6ed7a6c1578349fedbb55e4,https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4,src/core/SkMallocPixelRef.cpp,SkMallocPixelRef::MakeZeroed,"sk_sp<SkPixelRef> SkMallocPixelRef::MakeZeroed(const SkImageInfo& info,
size_t rowBytes) {
return MakeUsing(sk_calloc, info, rowBytes);
}","sk_sp<SkPixelRef> SkMallocPixelRef::MakeZeroed(const SkImageInfo& VAR_0,
size_t VAR_1) {
return MakeUsing(VAR_2, VAR_0, VAR_1);
}",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkMallocPixelRef.cpp/vul/before/0.json,"sk_sp<SkPixelRef> SkMallocPixelRef::MakeZeroed(const SkImageInfo& info,
                                               size_t rowBytes) {
    return MakeUsing(sk_calloc_canfail, info, rowBytes);
}","sk_sp<SkPixelRef> SkMallocPixelRef::MakeZeroed(const SkImageInfo& VAR_0,
                                               size_t VAR_1) {
    return MakeUsing(VAR_2, VAR_0, VAR_1);
}",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkMallocPixelRef.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
 sk_sp<SkPixelRef> SkMallocPixelRef::MakeZeroed(const SkImageInfo& info,
                                                size_t rowBytes) {
-    return MakeUsing(sk_calloc, info, rowBytes);
+    return MakeUsing(sk_calloc_canfail, info, rowBytes);
 }","{'deleted_lines': ['    return MakeUsing(sk_calloc, info, rowBytes);'], 'added_lines': ['    return MakeUsing(sk_calloc_canfail, info, rowBytes);']}",True,"In SkSampler::Fill of SkSampler.cpp, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-78354855",7.8,HIGH,2,test,,5
CVE-2018-9498,"['CWE-190', 'CWE-787']",AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"RESTRICT AUTOMERGE: Cherry-pick ""begin cleanup of malloc porting layer""

Bug: 78354855
Test: Not feasible

Original description:
========================================================================
1. Merge some of the allocators into sk_malloc_flags by redefining a flag to mean zero-init
2. Add more private helpers to simplify our call-sites (and handle some overflow mul checks)
3. The 2-param helpers rely on the saturating SkSafeMath::Mul to pass max_size_t as the request,
which should always fail.

chromium: 508641
Reviewed-on: https://skia-review.googlesource.com/90940
Commit-Queue: Mike Reed <reed@google.com>
Reviewed-by: Robert Phillips <robertphillips@google.com>
Reviewed-by: Stephan Altmueller <stephana@google.com>
========================================================================

Conflicts:
- include/private/SkMalloc.h
Simply removed the old definitions of SK_MALLOC_TEMP and SK_MALLOC_THROW.
- public.bzl
Copied SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER into the old defines.
- src/codec/SkIcoCodec.cpp
Drop a change where we were not using malloc yet.
- src/codec/SkBmpBaseCodec.cpp
- src/core/SkBitmapCache.cpp
These files weren't yet using malloc (and SkBmpBaseCodec hadn't been
factored out).
- src/core/SkMallocPixelRef.cpp
These were still using New rather than Make (return raw pointer). Leave
them unchanged, as sk_malloc_flags is still valid.
- src/lazy/SkDiscardableMemoryPool.cpp
Leave this unchanged; sk_malloc_flags is still valid

In addition, pull in SkSafeMath.h, which was originally introduced in
https://skia-review.googlesource.com/c/skia/+/33721. This is required
for the new sk_malloc calls.

Also pull in SkSafeMath::Add and SkSafeMath::Mul, introduced in
https://skia-review.googlesource.com/88581

Also add SK_MaxSizeT, which the above depends on, introduced in
https://skia-review.googlesource.com/57084

Also, modify NewFromStream to use sk_malloc_canfail, matching pi and
avoiding a build break

Change-Id: Ib320484673a865460fc1efb900f611209e088edb
(cherry picked from commit a12cc3e14ea6734c7efe76aa6a19239909830b28)
",77c955200ddd1761d6ed7a6c1578349fedbb55e4,https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4,src/ports/SkMemory_mozalloc.cpp,sk_malloc_flags,"void* sk_malloc_flags(size_t size, unsigned flags) {
return (flags & SK_MALLOC_THROW) ? moz_xmalloc(size) : malloc(size);
}","void* sk_malloc_flags(size_t VAR_0, unsigned VAR_1) {
return (VAR_1 & VAR_2) ? moz_xmalloc(VAR_0) : malloc(VAR_0);
}",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkMemory_mozalloc.cpp/vul/before/0.json,"void* sk_malloc_flags(size_t size, unsigned flags) {
#ifndef SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER
    if (flags & SK_MALLOC_ZERO_INITIALIZE) {
        return (flags & SK_MALLOC_THROW) ? moz_xcalloc(size, 1) : calloc(size, 1);
    }
#endif
    return (flags & SK_MALLOC_THROW) ? moz_xmalloc(size) : malloc(size);
}","void* sk_malloc_flags(size_t VAR_0, unsigned VAR_1) {
#ifndef VAR_2
    if (VAR_1 & VAR_3) {
        return (VAR_1 & VAR_4) ? moz_xcalloc(VAR_0, 1) : calloc(VAR_0, 1);
    }
#endif
    return (VAR_1 & VAR_4) ? moz_xmalloc(VAR_0) : malloc(VAR_0);
}",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkMemory_mozalloc.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,3 +1,8 @@
 void* sk_malloc_flags(size_t size, unsigned flags) {
+#ifndef SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER
+    if (flags & SK_MALLOC_ZERO_INITIALIZE) {
+        return (flags & SK_MALLOC_THROW) ? moz_xcalloc(size, 1) : calloc(size, 1);
+    }
+#endif
     return (flags & SK_MALLOC_THROW) ? moz_xmalloc(size) : malloc(size);
 }","{'deleted_lines': [], 'added_lines': ['#ifndef SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER', '    if (flags & SK_MALLOC_ZERO_INITIALIZE) {', '        return (flags & SK_MALLOC_THROW) ? moz_xcalloc(size, 1) : calloc(size, 1);', '    }', '#endif']}",True,"In SkSampler::Fill of SkSampler.cpp, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-78354855",7.8,HIGH,2,test,,5
CVE-2018-9498,"['CWE-190', 'CWE-787']",AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"RESTRICT AUTOMERGE: Cherry-pick ""begin cleanup of malloc porting layer""

Bug: 78354855
Test: Not feasible

Original description:
========================================================================
1. Merge some of the allocators into sk_malloc_flags by redefining a flag to mean zero-init
2. Add more private helpers to simplify our call-sites (and handle some overflow mul checks)
3. The 2-param helpers rely on the saturating SkSafeMath::Mul to pass max_size_t as the request,
which should always fail.

chromium: 508641
Reviewed-on: https://skia-review.googlesource.com/90940
Commit-Queue: Mike Reed <reed@google.com>
Reviewed-by: Robert Phillips <robertphillips@google.com>
Reviewed-by: Stephan Altmueller <stephana@google.com>
========================================================================

Conflicts:
- include/private/SkMalloc.h
Simply removed the old definitions of SK_MALLOC_TEMP and SK_MALLOC_THROW.
- public.bzl
Copied SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER into the old defines.
- src/codec/SkIcoCodec.cpp
Drop a change where we were not using malloc yet.
- src/codec/SkBmpBaseCodec.cpp
- src/core/SkBitmapCache.cpp
These files weren't yet using malloc (and SkBmpBaseCodec hadn't been
factored out).
- src/core/SkMallocPixelRef.cpp
These were still using New rather than Make (return raw pointer). Leave
them unchanged, as sk_malloc_flags is still valid.
- src/lazy/SkDiscardableMemoryPool.cpp
Leave this unchanged; sk_malloc_flags is still valid

In addition, pull in SkSafeMath.h, which was originally introduced in
https://skia-review.googlesource.com/c/skia/+/33721. This is required
for the new sk_malloc calls.

Also pull in SkSafeMath::Add and SkSafeMath::Mul, introduced in
https://skia-review.googlesource.com/88581

Also add SK_MaxSizeT, which the above depends on, introduced in
https://skia-review.googlesource.com/57084

Also, modify NewFromStream to use sk_malloc_canfail, matching pi and
avoiding a build break

Change-Id: Ib320484673a865460fc1efb900f611209e088edb
(cherry picked from commit a12cc3e14ea6734c7efe76aa6a19239909830b28)
",77c955200ddd1761d6ed7a6c1578349fedbb55e4,https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4,include/private/SkTemplates.h,realloc,"void realloc(size_t count) {
if (count > kCount) {
if (fPtr == fTStorage) {
fPtr = (T*)sk_malloc_throw(count * sizeof(T));
memcpy(fPtr, fTStorage, kCount * sizeof(T));
} else {
fPtr = (T*)sk_realloc_throw(fPtr, count * sizeof(T));
}
} else if (count) {
if (fPtr != fTStorage) {
fPtr = (T*)sk_realloc_throw(fPtr, count * sizeof(T));
}
} else {
this->reset(0);
}
}","void realloc(size_t VAR_0) {
if (VAR_0 > VAR_1) {
if (VAR_2 == VAR_3) {
VAR_2 = (T*)sk_malloc_throw(VAR_0 * sizeof(T));
memcpy(VAR_2, VAR_3, VAR_1 * sizeof(T));
} else {
VAR_2 = (T*)sk_realloc_throw(VAR_2, VAR_0 * sizeof(T));
}
} else if (VAR_0) {
if (VAR_2 != VAR_3) {
VAR_2 = (T*)sk_realloc_throw(VAR_2, VAR_0 * sizeof(T));
}
} else {
this->reset(0);
}
}",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkTemplates.h/vul/before/0.json,"void realloc(size_t count) {
        if (count > kCount) {
            if (fPtr == fTStorage) {
                fPtr = (T*)sk_malloc_throw(count, sizeof(T));
                memcpy(fPtr, fTStorage, kCount * sizeof(T));
            } else {
                fPtr = (T*)sk_realloc_throw(fPtr, count, sizeof(T));
            }
        } else if (count) {
            if (fPtr != fTStorage) {
                fPtr = (T*)sk_realloc_throw(fPtr, count, sizeof(T));
            }
        } else {
            this->reset(0);
        }
    }","void realloc(size_t VAR_0) {
        if (VAR_0 > VAR_1) {
            if (VAR_2 == VAR_3) {
                VAR_2 = (T*)sk_malloc_throw(VAR_0, sizeof(T));
                memcpy(VAR_2, VAR_3, VAR_1 * sizeof(T));
            } else {
                VAR_2 = (T*)sk_realloc_throw(VAR_2, VAR_0, sizeof(T));
            }
        } else if (VAR_0) {
            if (VAR_2 != VAR_3) {
                VAR_2 = (T*)sk_realloc_throw(VAR_2, VAR_0, sizeof(T));
            }
        } else {
            this->reset(0);
        }
    }",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkTemplates.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,14 +1,14 @@
 void realloc(size_t count) {
         if (count > kCount) {
             if (fPtr == fTStorage) {
-                fPtr = (T*)sk_malloc_throw(count * sizeof(T));
+                fPtr = (T*)sk_malloc_throw(count, sizeof(T));
                 memcpy(fPtr, fTStorage, kCount * sizeof(T));
             } else {
-                fPtr = (T*)sk_realloc_throw(fPtr, count * sizeof(T));
+                fPtr = (T*)sk_realloc_throw(fPtr, count, sizeof(T));
             }
         } else if (count) {
             if (fPtr != fTStorage) {
-                fPtr = (T*)sk_realloc_throw(fPtr, count * sizeof(T));
+                fPtr = (T*)sk_realloc_throw(fPtr, count, sizeof(T));
             }
         } else {
             this->reset(0);","{'deleted_lines': ['                fPtr = (T*)sk_malloc_throw(count * sizeof(T));', '                fPtr = (T*)sk_realloc_throw(fPtr, count * sizeof(T));', '                fPtr = (T*)sk_realloc_throw(fPtr, count * sizeof(T));'], 'added_lines': ['                fPtr = (T*)sk_malloc_throw(count, sizeof(T));', '                fPtr = (T*)sk_realloc_throw(fPtr, count, sizeof(T));', '                fPtr = (T*)sk_realloc_throw(fPtr, count, sizeof(T));']}",True,"In SkSampler::Fill of SkSampler.cpp, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-78354855",7.8,HIGH,2,test,,5
CVE-2018-9498,"['CWE-190', 'CWE-787']",AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"RESTRICT AUTOMERGE: Cherry-pick ""begin cleanup of malloc porting layer""

Bug: 78354855
Test: Not feasible

Original description:
========================================================================
1. Merge some of the allocators into sk_malloc_flags by redefining a flag to mean zero-init
2. Add more private helpers to simplify our call-sites (and handle some overflow mul checks)
3. The 2-param helpers rely on the saturating SkSafeMath::Mul to pass max_size_t as the request,
which should always fail.

chromium: 508641
Reviewed-on: https://skia-review.googlesource.com/90940
Commit-Queue: Mike Reed <reed@google.com>
Reviewed-by: Robert Phillips <robertphillips@google.com>
Reviewed-by: Stephan Altmueller <stephana@google.com>
========================================================================

Conflicts:
- include/private/SkMalloc.h
Simply removed the old definitions of SK_MALLOC_TEMP and SK_MALLOC_THROW.
- public.bzl
Copied SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER into the old defines.
- src/codec/SkIcoCodec.cpp
Drop a change where we were not using malloc yet.
- src/codec/SkBmpBaseCodec.cpp
- src/core/SkBitmapCache.cpp
These files weren't yet using malloc (and SkBmpBaseCodec hadn't been
factored out).
- src/core/SkMallocPixelRef.cpp
These were still using New rather than Make (return raw pointer). Leave
them unchanged, as sk_malloc_flags is still valid.
- src/lazy/SkDiscardableMemoryPool.cpp
Leave this unchanged; sk_malloc_flags is still valid

In addition, pull in SkSafeMath.h, which was originally introduced in
https://skia-review.googlesource.com/c/skia/+/33721. This is required
for the new sk_malloc calls.

Also pull in SkSafeMath::Add and SkSafeMath::Mul, introduced in
https://skia-review.googlesource.com/88581

Also add SK_MaxSizeT, which the above depends on, introduced in
https://skia-review.googlesource.com/57084

Also, modify NewFromStream to use sk_malloc_canfail, matching pi and
avoiding a build break

Change-Id: Ib320484673a865460fc1efb900f611209e088edb
(cherry picked from commit a12cc3e14ea6734c7efe76aa6a19239909830b28)
",77c955200ddd1761d6ed7a6c1578349fedbb55e4,https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4,include/private/SkTemplates.h,SkAutoTMalloc,"explicit SkAutoTMalloc(size_t count) {
fPtr = count ? (T*)sk_malloc_flags(count * sizeof(T), SK_MALLOC_THROW) : nullptr;
}","explicit SkAutoTMalloc(size_t VAR_0) {
VAR_1 = VAR_0 ? (T*)sk_malloc_flags(VAR_0 * sizeof(T), VAR_2) : nullptr;
}",,"explicit SkAutoTMalloc(size_t count) {
        fPtr = count ? (T*)sk_malloc_throw(count, sizeof(T)) : nullptr;
    }","explicit SkAutoTMalloc(size_t VAR_0) {
        VAR_1 = VAR_0 ? (T*)sk_malloc_throw(VAR_0, sizeof(T)) : nullptr;
    }",,"--- func_before
+++ func_after
@@ -1,3 +1,3 @@
 explicit SkAutoTMalloc(size_t count) {
-        fPtr = count ? (T*)sk_malloc_flags(count * sizeof(T), SK_MALLOC_THROW) : nullptr;
+        fPtr = count ? (T*)sk_malloc_throw(count, sizeof(T)) : nullptr;
     }","{'deleted_lines': ['        fPtr = count ? (T*)sk_malloc_flags(count * sizeof(T), SK_MALLOC_THROW) : nullptr;'], 'added_lines': ['        fPtr = count ? (T*)sk_malloc_throw(count, sizeof(T)) : nullptr;']}",True,"In SkSampler::Fill of SkSampler.cpp, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-78354855",7.8,HIGH,2,test,,5
CVE-2018-9498,"['CWE-190', 'CWE-787']",AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"RESTRICT AUTOMERGE: Cherry-pick ""begin cleanup of malloc porting layer""

Bug: 78354855
Test: Not feasible

Original description:
========================================================================
1. Merge some of the allocators into sk_malloc_flags by redefining a flag to mean zero-init
2. Add more private helpers to simplify our call-sites (and handle some overflow mul checks)
3. The 2-param helpers rely on the saturating SkSafeMath::Mul to pass max_size_t as the request,
which should always fail.

chromium: 508641
Reviewed-on: https://skia-review.googlesource.com/90940
Commit-Queue: Mike Reed <reed@google.com>
Reviewed-by: Robert Phillips <robertphillips@google.com>
Reviewed-by: Stephan Altmueller <stephana@google.com>
========================================================================

Conflicts:
- include/private/SkMalloc.h
Simply removed the old definitions of SK_MALLOC_TEMP and SK_MALLOC_THROW.
- public.bzl
Copied SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER into the old defines.
- src/codec/SkIcoCodec.cpp
Drop a change where we were not using malloc yet.
- src/codec/SkBmpBaseCodec.cpp
- src/core/SkBitmapCache.cpp
These files weren't yet using malloc (and SkBmpBaseCodec hadn't been
factored out).
- src/core/SkMallocPixelRef.cpp
These were still using New rather than Make (return raw pointer). Leave
them unchanged, as sk_malloc_flags is still valid.
- src/lazy/SkDiscardableMemoryPool.cpp
Leave this unchanged; sk_malloc_flags is still valid

In addition, pull in SkSafeMath.h, which was originally introduced in
https://skia-review.googlesource.com/c/skia/+/33721. This is required
for the new sk_malloc calls.

Also pull in SkSafeMath::Add and SkSafeMath::Mul, introduced in
https://skia-review.googlesource.com/88581

Also add SK_MaxSizeT, which the above depends on, introduced in
https://skia-review.googlesource.com/57084

Also, modify NewFromStream to use sk_malloc_canfail, matching pi and
avoiding a build break

Change-Id: Ib320484673a865460fc1efb900f611209e088edb
(cherry picked from commit a12cc3e14ea6734c7efe76aa6a19239909830b28)
",77c955200ddd1761d6ed7a6c1578349fedbb55e4,https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4,include/private/SkTemplates.h,reset,"T* reset(size_t count = 0) {
sk_free(fPtr);
fPtr = count ? (T*)sk_malloc_flags(count * sizeof(T), SK_MALLOC_THROW) : nullptr;
return fPtr;
}","T* reset(size_t VAR_0 = 0) {
sk_free(VAR_1);
VAR_1 = VAR_0 ? (T*)sk_malloc_flags(VAR_0 * sizeof(T), VAR_2) : nullptr;
return VAR_1;
}",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkTemplates.h/vul/before/2.json,"T* reset(size_t count = 0) {
        sk_free(fPtr);
        fPtr = count ? (T*)sk_malloc_throw(count, sizeof(T)) : nullptr;
        return fPtr;
    }","T* reset(size_t VAR_0 = 0) {
        sk_free(VAR_1);
        VAR_1 = VAR_0 ? (T*)sk_malloc_throw(VAR_0, sizeof(T)) : nullptr;
        return VAR_1;
    }",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkTemplates.h/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,5 +1,5 @@
 T* reset(size_t count = 0) {
         sk_free(fPtr);
-        fPtr = count ? (T*)sk_malloc_flags(count * sizeof(T), SK_MALLOC_THROW) : nullptr;
+        fPtr = count ? (T*)sk_malloc_throw(count, sizeof(T)) : nullptr;
         return fPtr;
     }","{'deleted_lines': ['        fPtr = count ? (T*)sk_malloc_flags(count * sizeof(T), SK_MALLOC_THROW) : nullptr;'], 'added_lines': ['        fPtr = count ? (T*)sk_malloc_throw(count, sizeof(T)) : nullptr;']}",True,"In SkSampler::Fill of SkSampler.cpp, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-78354855",7.8,HIGH,2,test,,5
CVE-2018-9498,"['CWE-190', 'CWE-787']",AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"RESTRICT AUTOMERGE: Cherry-pick ""begin cleanup of malloc porting layer""

Bug: 78354855
Test: Not feasible

Original description:
========================================================================
1. Merge some of the allocators into sk_malloc_flags by redefining a flag to mean zero-init
2. Add more private helpers to simplify our call-sites (and handle some overflow mul checks)
3. The 2-param helpers rely on the saturating SkSafeMath::Mul to pass max_size_t as the request,
which should always fail.

chromium: 508641
Reviewed-on: https://skia-review.googlesource.com/90940
Commit-Queue: Mike Reed <reed@google.com>
Reviewed-by: Robert Phillips <robertphillips@google.com>
Reviewed-by: Stephan Altmueller <stephana@google.com>
========================================================================

Conflicts:
- include/private/SkMalloc.h
Simply removed the old definitions of SK_MALLOC_TEMP and SK_MALLOC_THROW.
- public.bzl
Copied SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER into the old defines.
- src/codec/SkIcoCodec.cpp
Drop a change where we were not using malloc yet.
- src/codec/SkBmpBaseCodec.cpp
- src/core/SkBitmapCache.cpp
These files weren't yet using malloc (and SkBmpBaseCodec hadn't been
factored out).
- src/core/SkMallocPixelRef.cpp
These were still using New rather than Make (return raw pointer). Leave
them unchanged, as sk_malloc_flags is still valid.
- src/lazy/SkDiscardableMemoryPool.cpp
Leave this unchanged; sk_malloc_flags is still valid

In addition, pull in SkSafeMath.h, which was originally introduced in
https://skia-review.googlesource.com/c/skia/+/33721. This is required
for the new sk_malloc calls.

Also pull in SkSafeMath::Add and SkSafeMath::Mul, introduced in
https://skia-review.googlesource.com/88581

Also add SK_MaxSizeT, which the above depends on, introduced in
https://skia-review.googlesource.com/57084

Also, modify NewFromStream to use sk_malloc_canfail, matching pi and
avoiding a build break

Change-Id: Ib320484673a865460fc1efb900f611209e088edb
(cherry picked from commit a12cc3e14ea6734c7efe76aa6a19239909830b28)
",77c955200ddd1761d6ed7a6c1578349fedbb55e4,https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4,include/private/SkTemplates.h,SkAutoSTMalloc,"SkAutoSTMalloc(size_t count) {
if (count > kCount) {
fPtr = (T*)sk_malloc_flags(count * sizeof(T), SK_MALLOC_THROW | SK_MALLOC_TEMP);
} else if (count) {
fPtr = fTStorage;
} else {
fPtr = nullptr;
}
}","SkAutoSTMalloc(size_t VAR_0) {
if (VAR_0 > VAR_1) {
VAR_2 = (T*)sk_malloc_flags(VAR_0 * sizeof(T), VAR_3 | VAR_4);
} else if (VAR_0) {
VAR_2 = VAR_5;
} else {
VAR_2 = nullptr;
}
}",,"SkAutoSTMalloc(size_t count) {
        if (count > kCount) {
            fPtr = (T*)sk_malloc_throw(count, sizeof(T));
        } else if (count) {
            fPtr = fTStorage;
        } else {
            fPtr = nullptr;
        }
    }","SkAutoSTMalloc(size_t VAR_0) {
        if (VAR_0 > VAR_1) {
            VAR_2 = (T*)sk_malloc_throw(VAR_0, sizeof(T));
        } else if (VAR_0) {
            VAR_2 = VAR_3;
        } else {
            VAR_2 = nullptr;
        }
    }",,"--- func_before
+++ func_after
@@ -1,6 +1,6 @@
 SkAutoSTMalloc(size_t count) {
         if (count > kCount) {
-            fPtr = (T*)sk_malloc_flags(count * sizeof(T), SK_MALLOC_THROW | SK_MALLOC_TEMP);
+            fPtr = (T*)sk_malloc_throw(count, sizeof(T));
         } else if (count) {
             fPtr = fTStorage;
         } else {","{'deleted_lines': ['            fPtr = (T*)sk_malloc_flags(count * sizeof(T), SK_MALLOC_THROW | SK_MALLOC_TEMP);'], 'added_lines': ['            fPtr = (T*)sk_malloc_throw(count, sizeof(T));']}",True,"In SkSampler::Fill of SkSampler.cpp, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-78354855",7.8,HIGH,2,test,,5
CVE-2018-9498,"['CWE-190', 'CWE-787']",AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"RESTRICT AUTOMERGE: Cherry-pick ""begin cleanup of malloc porting layer""

Bug: 78354855
Test: Not feasible

Original description:
========================================================================
1. Merge some of the allocators into sk_malloc_flags by redefining a flag to mean zero-init
2. Add more private helpers to simplify our call-sites (and handle some overflow mul checks)
3. The 2-param helpers rely on the saturating SkSafeMath::Mul to pass max_size_t as the request,
which should always fail.

chromium: 508641
Reviewed-on: https://skia-review.googlesource.com/90940
Commit-Queue: Mike Reed <reed@google.com>
Reviewed-by: Robert Phillips <robertphillips@google.com>
Reviewed-by: Stephan Altmueller <stephana@google.com>
========================================================================

Conflicts:
- include/private/SkMalloc.h
Simply removed the old definitions of SK_MALLOC_TEMP and SK_MALLOC_THROW.
- public.bzl
Copied SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER into the old defines.
- src/codec/SkIcoCodec.cpp
Drop a change where we were not using malloc yet.
- src/codec/SkBmpBaseCodec.cpp
- src/core/SkBitmapCache.cpp
These files weren't yet using malloc (and SkBmpBaseCodec hadn't been
factored out).
- src/core/SkMallocPixelRef.cpp
These were still using New rather than Make (return raw pointer). Leave
them unchanged, as sk_malloc_flags is still valid.
- src/lazy/SkDiscardableMemoryPool.cpp
Leave this unchanged; sk_malloc_flags is still valid

In addition, pull in SkSafeMath.h, which was originally introduced in
https://skia-review.googlesource.com/c/skia/+/33721. This is required
for the new sk_malloc calls.

Also pull in SkSafeMath::Add and SkSafeMath::Mul, introduced in
https://skia-review.googlesource.com/88581

Also add SK_MaxSizeT, which the above depends on, introduced in
https://skia-review.googlesource.com/57084

Also, modify NewFromStream to use sk_malloc_canfail, matching pi and
avoiding a build break

Change-Id: Ib320484673a865460fc1efb900f611209e088edb
(cherry picked from commit a12cc3e14ea6734c7efe76aa6a19239909830b28)
",77c955200ddd1761d6ed7a6c1578349fedbb55e4,https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4,include/private/SkTemplates.h,reset,"void reset(int count) {
T* start = fArray;
T* iter = start + fCount;
while (iter > start) {
(--iter)->~T();
}
SkASSERT(count >= 0);
if (fCount != count) {
if (fCount > kCount) {
SkASSERT((T*) fStorage != fArray);
sk_free(fArray);
}
if (count > kCount) {
const uint64_t size64 = sk_64_mul(count, sizeof(T));
const size_t size = static_cast<size_t>(size64);
if (size != size64) {
sk_out_of_memory();
}
fArray = (T*) sk_malloc_throw(size);
} else if (count > 0) {
fArray = (T*) fStorage;
} else {
fArray = NULL;
}
fCount = count;
}
iter = fArray;
T* stop = fArray + count;
while (iter < stop) {
new (iter++) T;
}
}","void reset(int VAR_0) {
T* VAR_1 = VAR_2;
T* VAR_3 = VAR_1 + VAR_4;
while (VAR_3 > VAR_1) {
(--VAR_3)->~T();
}
SkASSERT(VAR_0 >= 0);
if (VAR_4 != VAR_0) {
if (VAR_4 > VAR_5) {
SkASSERT((T*) VAR_6 != VAR_2);
sk_free(VAR_2);
}
if (VAR_0 > VAR_5) {
const uint64_t VAR_7 = sk_64_mul(VAR_0, sizeof(T));
const size_t VAR_8 = VAR_9<size_t>(VAR_7);
if (VAR_8 != VAR_7) {
sk_out_of_memory();
}
VAR_2 = (T*) sk_malloc_throw(VAR_8);
} else if (VAR_0 > 0) {
VAR_2 = (T*) VAR_6;
} else {
VAR_2 = NULL;
}
VAR_4 = VAR_0;
}
VAR_3 = VAR_2;
T* VAR_10 = VAR_2 + VAR_0;
while (VAR_3 < VAR_10) {
new (VAR_3++) T;
}
}",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkTemplates.h/vul/before/4.json,"void reset(int count) {
        T* start = fArray;
        T* iter = start + fCount;
        while (iter > start) {
            (--iter)->~T();
        }

        SkASSERT(count >= 0);
        if (fCount != count) {
            if (fCount > kCount) {
                // 'fArray' was allocated last time so free it now
                SkASSERT((T*) fStorage != fArray);
                sk_free(fArray);
            }

            if (count > kCount) {
                fArray = (T*) sk_malloc_throw(count, sizeof(T));
            } else if (count > 0) {
                fArray = (T*) fStorage;
            } else {
                fArray = NULL;
            }

            fCount = count;
        }

        iter = fArray;
        T* stop = fArray + count;
        while (iter < stop) {
            new (iter++) T;
        }
    }","void reset(int VAR_0) {
        T* VAR_1 = VAR_2;
        T* VAR_3 = VAR_1 + VAR_4;
        while (VAR_3 > VAR_1) {
            (--VAR_3)->~T();
        }

        SkASSERT(VAR_0 >= 0);
        if (VAR_4 != VAR_0) {
            if (VAR_4 > VAR_5) {
                /* COMMENT_0 */
                SkASSERT((T*) VAR_6 != VAR_2);
                sk_free(VAR_2);
            }

            if (VAR_0 > VAR_5) {
                VAR_2 = (T*) sk_malloc_throw(VAR_0, sizeof(T));
            } else if (VAR_0 > 0) {
                VAR_2 = (T*) VAR_6;
            } else {
                VAR_2 = NULL;
            }

            VAR_4 = VAR_0;
        }

        VAR_3 = VAR_2;
        T* VAR_7 = VAR_2 + VAR_0;
        while (VAR_3 < VAR_7) {
            new (VAR_3++) T;
        }
    }",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkTemplates.h/vul/after/4.json,"--- func_before
+++ func_after
@@ -14,12 +14,7 @@
             }
 
             if (count > kCount) {
-                const uint64_t size64 = sk_64_mul(count, sizeof(T));
-                const size_t size = static_cast<size_t>(size64);
-                if (size != size64) {
-                    sk_out_of_memory();
-                }
-                fArray = (T*) sk_malloc_throw(size);
+                fArray = (T*) sk_malloc_throw(count, sizeof(T));
             } else if (count > 0) {
                 fArray = (T*) fStorage;
             } else {","{'deleted_lines': ['                const uint64_t size64 = sk_64_mul(count, sizeof(T));', '                const size_t size = static_cast<size_t>(size64);', '                if (size != size64) {', '                    sk_out_of_memory();', '                }', '                fArray = (T*) sk_malloc_throw(size);'], 'added_lines': ['                fArray = (T*) sk_malloc_throw(count, sizeof(T));']}",True,"In SkSampler::Fill of SkSampler.cpp, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-78354855",7.8,HIGH,2,test,,5
CVE-2018-9498,"['CWE-190', 'CWE-787']",AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"RESTRICT AUTOMERGE: Cherry-pick ""begin cleanup of malloc porting layer""

Bug: 78354855
Test: Not feasible

Original description:
========================================================================
1. Merge some of the allocators into sk_malloc_flags by redefining a flag to mean zero-init
2. Add more private helpers to simplify our call-sites (and handle some overflow mul checks)
3. The 2-param helpers rely on the saturating SkSafeMath::Mul to pass max_size_t as the request,
which should always fail.

chromium: 508641
Reviewed-on: https://skia-review.googlesource.com/90940
Commit-Queue: Mike Reed <reed@google.com>
Reviewed-by: Robert Phillips <robertphillips@google.com>
Reviewed-by: Stephan Altmueller <stephana@google.com>
========================================================================

Conflicts:
- include/private/SkMalloc.h
Simply removed the old definitions of SK_MALLOC_TEMP and SK_MALLOC_THROW.
- public.bzl
Copied SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER into the old defines.
- src/codec/SkIcoCodec.cpp
Drop a change where we were not using malloc yet.
- src/codec/SkBmpBaseCodec.cpp
- src/core/SkBitmapCache.cpp
These files weren't yet using malloc (and SkBmpBaseCodec hadn't been
factored out).
- src/core/SkMallocPixelRef.cpp
These were still using New rather than Make (return raw pointer). Leave
them unchanged, as sk_malloc_flags is still valid.
- src/lazy/SkDiscardableMemoryPool.cpp
Leave this unchanged; sk_malloc_flags is still valid

In addition, pull in SkSafeMath.h, which was originally introduced in
https://skia-review.googlesource.com/c/skia/+/33721. This is required
for the new sk_malloc calls.

Also pull in SkSafeMath::Add and SkSafeMath::Mul, introduced in
https://skia-review.googlesource.com/88581

Also add SK_MaxSizeT, which the above depends on, introduced in
https://skia-review.googlesource.com/57084

Also, modify NewFromStream to use sk_malloc_canfail, matching pi and
avoiding a build break

Change-Id: Ib320484673a865460fc1efb900f611209e088edb
(cherry picked from commit a12cc3e14ea6734c7efe76aa6a19239909830b28)
",77c955200ddd1761d6ed7a6c1578349fedbb55e4,https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4,include/private/SkTemplates.h,reset,"T* reset(size_t count) {
if (fPtr != fTStorage) {
sk_free(fPtr);
}
if (count > kCount) {
fPtr = (T*)sk_malloc_throw(count * sizeof(T));
} else if (count) {
fPtr = fTStorage;
} else {
fPtr = nullptr;
}
return fPtr;
}","T* reset(size_t VAR_0) {
if (VAR_1 != VAR_2) {
sk_free(VAR_1);
}
if (VAR_0 > VAR_3) {
VAR_1 = (T*)sk_malloc_throw(VAR_0 * sizeof(T));
} else if (VAR_0) {
VAR_1 = VAR_2;
} else {
VAR_1 = nullptr;
}
return VAR_1;
}",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkTemplates.h/vul/before/5.json,"T* reset(size_t count) {
        if (fPtr != fTStorage) {
            sk_free(fPtr);
        }
        if (count > kCount) {
            fPtr = (T*)sk_malloc_throw(count, sizeof(T));
        } else if (count) {
            fPtr = fTStorage;
        } else {
            fPtr = nullptr;
        }
        return fPtr;
    }","T* reset(size_t VAR_0) {
        if (VAR_1 != VAR_2) {
            sk_free(VAR_1);
        }
        if (VAR_0 > VAR_3) {
            VAR_1 = (T*)sk_malloc_throw(VAR_0, sizeof(T));
        } else if (VAR_0) {
            VAR_1 = VAR_2;
        } else {
            VAR_1 = nullptr;
        }
        return VAR_1;
    }",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkTemplates.h/vul/after/5.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
             sk_free(fPtr);
         }
         if (count > kCount) {
-            fPtr = (T*)sk_malloc_throw(count * sizeof(T));
+            fPtr = (T*)sk_malloc_throw(count, sizeof(T));
         } else if (count) {
             fPtr = fTStorage;
         } else {","{'deleted_lines': ['            fPtr = (T*)sk_malloc_throw(count * sizeof(T));'], 'added_lines': ['            fPtr = (T*)sk_malloc_throw(count, sizeof(T));']}",True,"In SkSampler::Fill of SkSampler.cpp, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-78354855",7.8,HIGH,2,test,,5
CVE-2018-9498,"['CWE-190', 'CWE-787']",AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"RESTRICT AUTOMERGE: Cherry-pick ""begin cleanup of malloc porting layer""

Bug: 78354855
Test: Not feasible

Original description:
========================================================================
1. Merge some of the allocators into sk_malloc_flags by redefining a flag to mean zero-init
2. Add more private helpers to simplify our call-sites (and handle some overflow mul checks)
3. The 2-param helpers rely on the saturating SkSafeMath::Mul to pass max_size_t as the request,
which should always fail.

chromium: 508641
Reviewed-on: https://skia-review.googlesource.com/90940
Commit-Queue: Mike Reed <reed@google.com>
Reviewed-by: Robert Phillips <robertphillips@google.com>
Reviewed-by: Stephan Altmueller <stephana@google.com>
========================================================================

Conflicts:
- include/private/SkMalloc.h
Simply removed the old definitions of SK_MALLOC_TEMP and SK_MALLOC_THROW.
- public.bzl
Copied SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER into the old defines.
- src/codec/SkIcoCodec.cpp
Drop a change where we were not using malloc yet.
- src/codec/SkBmpBaseCodec.cpp
- src/core/SkBitmapCache.cpp
These files weren't yet using malloc (and SkBmpBaseCodec hadn't been
factored out).
- src/core/SkMallocPixelRef.cpp
These were still using New rather than Make (return raw pointer). Leave
them unchanged, as sk_malloc_flags is still valid.
- src/lazy/SkDiscardableMemoryPool.cpp
Leave this unchanged; sk_malloc_flags is still valid

In addition, pull in SkSafeMath.h, which was originally introduced in
https://skia-review.googlesource.com/c/skia/+/33721. This is required
for the new sk_malloc calls.

Also pull in SkSafeMath::Add and SkSafeMath::Mul, introduced in
https://skia-review.googlesource.com/88581

Also add SK_MaxSizeT, which the above depends on, introduced in
https://skia-review.googlesource.com/57084

Also, modify NewFromStream to use sk_malloc_canfail, matching pi and
avoiding a build break

Change-Id: Ib320484673a865460fc1efb900f611209e088edb
(cherry picked from commit a12cc3e14ea6734c7efe76aa6a19239909830b28)
",77c955200ddd1761d6ed7a6c1578349fedbb55e4,https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4,src/core/SkAutoMalloc.h,reset,"void* reset(size_t size,
SkAutoMalloc::OnShrink shrink = SkAutoMalloc::kAlloc_OnShrink,
bool* didChangeAlloc = nullptr) {
size = (size < kSize) ? kSize : size;
bool alloc = size != fSize && (SkAutoMalloc::kAlloc_OnShrink == shrink || size > fSize);
if (didChangeAlloc) {
*didChangeAlloc = alloc;
}
if (alloc) {
if (fPtr != (void*)fStorage) {
sk_free(fPtr);
}
if (size == kSize) {
SkASSERT(fPtr != fStorage);                 fPtr = fStorage;
} else {
fPtr = sk_malloc_flags(size, SK_MALLOC_THROW | SK_MALLOC_TEMP);
}
fSize = size;
}
SkASSERT(fSize >= size && fSize >= kSize);
SkASSERT((fPtr == fStorage) || fSize > kSize);
return fPtr;
}","void* reset(size_t VAR_0,
SkAutoMalloc::VAR_1 VAR_2 = SkAutoMalloc::VAR_3,
bool* VAR_4 = VAR_5) {
VAR_0 = (VAR_0 < VAR_6) ? VAR_6 : VAR_0;
bool VAR_7 = VAR_0 != VAR_8 && (SkAutoMalloc::VAR_3 == VAR_2 || VAR_0 > VAR_8);
if (VAR_4) {
*VAR_4 = VAR_7;
}
if (VAR_7) {
if (VAR_9 != (void*)VAR_10) {
sk_free(VAR_9);
}
if (VAR_0 == VAR_6) {
SkASSERT(VAR_9 != VAR_10); 
VAR_9 = VAR_10;
} else {
VAR_9 = sk_malloc_flags(VAR_0, VAR_11 | VAR_12);
}
VAR_8 = VAR_0;
}
SkASSERT(VAR_8 >= VAR_0 && VAR_8 >= VAR_6);
SkASSERT((VAR_9 == VAR_10) || VAR_8 > VAR_6);
return VAR_9;
}",,"void* reset(size_t size,
                SkAutoMalloc::OnShrink shrink = SkAutoMalloc::kAlloc_OnShrink,
                bool* didChangeAlloc = nullptr) {
        size = (size < kSize) ? kSize : size;
        bool alloc = size != fSize && (SkAutoMalloc::kAlloc_OnShrink == shrink || size > fSize);
        if (didChangeAlloc) {
            *didChangeAlloc = alloc;
        }
        if (alloc) {
            if (fPtr != (void*)fStorage) {
                sk_free(fPtr);
            }

            if (size == kSize) {
                SkASSERT(fPtr != fStorage); // otherwise we lied when setting didChangeAlloc.
                fPtr = fStorage;
            } else {
                fPtr = sk_malloc_throw(size);
            }

            fSize = size;
        }
        SkASSERT(fSize >= size && fSize >= kSize);
        SkASSERT((fPtr == fStorage) || fSize > kSize);
        return fPtr;
    }","void* reset(size_t VAR_0,
                SkAutoMalloc::VAR_1 VAR_2 = SkAutoMalloc::VAR_3,
                bool* VAR_4 = VAR_5) {
        VAR_0 = (VAR_0 < VAR_6) ? VAR_6 : VAR_0;
        bool VAR_7 = VAR_0 != VAR_8 && (SkAutoMalloc::VAR_3 == VAR_2 || VAR_0 > VAR_8);
        if (VAR_4) {
            *VAR_4 = VAR_7;
        }
        if (VAR_7) {
            if (VAR_9 != (void*)VAR_10) {
                sk_free(VAR_9);
            }

            if (VAR_0 == VAR_6) {
                SkASSERT(VAR_9 != VAR_10); /* COMMENT_0 */
                VAR_9 = VAR_10;
            } else {
                VAR_9 = sk_malloc_throw(VAR_0);
            }

            VAR_8 = VAR_0;
        }
        SkASSERT(VAR_8 >= VAR_0 && VAR_8 >= VAR_6);
        SkASSERT((VAR_9 == VAR_10) || VAR_8 > VAR_6);
        return VAR_9;
    }",,"--- func_before
+++ func_after
@@ -15,7 +15,7 @@
                 SkASSERT(fPtr != fStorage); // otherwise we lied when setting didChangeAlloc.
                 fPtr = fStorage;
             } else {
-                fPtr = sk_malloc_flags(size, SK_MALLOC_THROW | SK_MALLOC_TEMP);
+                fPtr = sk_malloc_throw(size);
             }
 
             fSize = size;","{'deleted_lines': ['                fPtr = sk_malloc_flags(size, SK_MALLOC_THROW | SK_MALLOC_TEMP);'], 'added_lines': ['                fPtr = sk_malloc_throw(size);']}",True,"In SkSampler::Fill of SkSampler.cpp, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-78354855",7.8,HIGH,2,test,,5
CVE-2018-9498,"['CWE-190', 'CWE-787']",AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"RESTRICT AUTOMERGE: Cherry-pick ""begin cleanup of malloc porting layer""

Bug: 78354855
Test: Not feasible

Original description:
========================================================================
1. Merge some of the allocators into sk_malloc_flags by redefining a flag to mean zero-init
2. Add more private helpers to simplify our call-sites (and handle some overflow mul checks)
3. The 2-param helpers rely on the saturating SkSafeMath::Mul to pass max_size_t as the request,
which should always fail.

chromium: 508641
Reviewed-on: https://skia-review.googlesource.com/90940
Commit-Queue: Mike Reed <reed@google.com>
Reviewed-by: Robert Phillips <robertphillips@google.com>
Reviewed-by: Stephan Altmueller <stephana@google.com>
========================================================================

Conflicts:
- include/private/SkMalloc.h
Simply removed the old definitions of SK_MALLOC_TEMP and SK_MALLOC_THROW.
- public.bzl
Copied SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER into the old defines.
- src/codec/SkIcoCodec.cpp
Drop a change where we were not using malloc yet.
- src/codec/SkBmpBaseCodec.cpp
- src/core/SkBitmapCache.cpp
These files weren't yet using malloc (and SkBmpBaseCodec hadn't been
factored out).
- src/core/SkMallocPixelRef.cpp
These were still using New rather than Make (return raw pointer). Leave
them unchanged, as sk_malloc_flags is still valid.
- src/lazy/SkDiscardableMemoryPool.cpp
Leave this unchanged; sk_malloc_flags is still valid

In addition, pull in SkSafeMath.h, which was originally introduced in
https://skia-review.googlesource.com/c/skia/+/33721. This is required
for the new sk_malloc calls.

Also pull in SkSafeMath::Add and SkSafeMath::Mul, introduced in
https://skia-review.googlesource.com/88581

Also add SK_MaxSizeT, which the above depends on, introduced in
https://skia-review.googlesource.com/57084

Also, modify NewFromStream to use sk_malloc_canfail, matching pi and
avoiding a build break

Change-Id: Ib320484673a865460fc1efb900f611209e088edb
(cherry picked from commit a12cc3e14ea6734c7efe76aa6a19239909830b28)
",77c955200ddd1761d6ed7a6c1578349fedbb55e4,https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4,src/ports/SkMemory_malloc.cpp,sk_malloc_flags,"void* sk_malloc_flags(size_t size, unsigned flags) {
void* p = malloc(size);
if (flags & SK_MALLOC_THROW) {
return throw_on_failure(size, p);
} else {
return p;
}
}","void* sk_malloc_flags(size_t VAR_0, unsigned VAR_1) {
void* VAR_2 = malloc(VAR_0);
if (VAR_1 & VAR_3) {
return throw_on_failure(VAR_0, VAR_2);
} else {
return VAR_2;
}
}",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkMemory_malloc.cpp/vul/before/0.json,"void* sk_malloc_flags(size_t size, unsigned flags) {
    void* p;
#ifdef SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER
    p = malloc(size);
#else
    if (flags & SK_MALLOC_ZERO_INITIALIZE) {
        p = calloc(size, 1);
    } else {
        p = malloc(size);
    }
#endif
    if (flags & SK_MALLOC_THROW) {
        return throw_on_failure(size, p);
    } else {
        return p;
    }
}","void* sk_malloc_flags(size_t VAR_0, unsigned VAR_1) {
    void* VAR_2;
#ifdef VAR_3
    VAR_2 = malloc(VAR_0);
#else
    if (VAR_1 & VAR_4) {
        VAR_2 = calloc(VAR_0, 1);
    } else {
        VAR_2 = malloc(VAR_0);
    }
#endif
    if (VAR_1 & VAR_5) {
        return throw_on_failure(VAR_0, VAR_2);
    } else {
        return VAR_2;
    }
}",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkMemory_malloc.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,14 @@
 void* sk_malloc_flags(size_t size, unsigned flags) {
-    void* p = malloc(size);
+    void* p;
+#ifdef SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER
+    p = malloc(size);
+#else
+    if (flags & SK_MALLOC_ZERO_INITIALIZE) {
+        p = calloc(size, 1);
+    } else {
+        p = malloc(size);
+    }
+#endif
     if (flags & SK_MALLOC_THROW) {
         return throw_on_failure(size, p);
     } else {","{'deleted_lines': ['    void* p = malloc(size);'], 'added_lines': ['    void* p;', '#ifdef SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER', '    p = malloc(size);', '#else', '    if (flags & SK_MALLOC_ZERO_INITIALIZE) {', '        p = calloc(size, 1);', '    } else {', '        p = malloc(size);', '    }', '#endif']}",True,"In SkSampler::Fill of SkSampler.cpp, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-78354855",7.8,HIGH,2,test,,5
CVE-2018-9498,"['CWE-190', 'CWE-787']",AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"RESTRICT AUTOMERGE: Cherry-pick ""begin cleanup of malloc porting layer""

Bug: 78354855
Test: Not feasible

Original description:
========================================================================
1. Merge some of the allocators into sk_malloc_flags by redefining a flag to mean zero-init
2. Add more private helpers to simplify our call-sites (and handle some overflow mul checks)
3. The 2-param helpers rely on the saturating SkSafeMath::Mul to pass max_size_t as the request,
which should always fail.

chromium: 508641
Reviewed-on: https://skia-review.googlesource.com/90940
Commit-Queue: Mike Reed <reed@google.com>
Reviewed-by: Robert Phillips <robertphillips@google.com>
Reviewed-by: Stephan Altmueller <stephana@google.com>
========================================================================

Conflicts:
- include/private/SkMalloc.h
Simply removed the old definitions of SK_MALLOC_TEMP and SK_MALLOC_THROW.
- public.bzl
Copied SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER into the old defines.
- src/codec/SkIcoCodec.cpp
Drop a change where we were not using malloc yet.
- src/codec/SkBmpBaseCodec.cpp
- src/core/SkBitmapCache.cpp
These files weren't yet using malloc (and SkBmpBaseCodec hadn't been
factored out).
- src/core/SkMallocPixelRef.cpp
These were still using New rather than Make (return raw pointer). Leave
them unchanged, as sk_malloc_flags is still valid.
- src/lazy/SkDiscardableMemoryPool.cpp
Leave this unchanged; sk_malloc_flags is still valid

In addition, pull in SkSafeMath.h, which was originally introduced in
https://skia-review.googlesource.com/c/skia/+/33721. This is required
for the new sk_malloc calls.

Also pull in SkSafeMath::Add and SkSafeMath::Mul, introduced in
https://skia-review.googlesource.com/88581

Also add SK_MaxSizeT, which the above depends on, introduced in
https://skia-review.googlesource.com/57084

Also, modify NewFromStream to use sk_malloc_canfail, matching pi and
avoiding a build break

Change-Id: Ib320484673a865460fc1efb900f611209e088edb
(cherry picked from commit a12cc3e14ea6734c7efe76aa6a19239909830b28)
",77c955200ddd1761d6ed7a6c1578349fedbb55e4,https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4,src/core/SkRegion_path.cpp,SkRgnBuilder::init,"bool SkRgnBuilder::init(int maxHeight, int maxTransitions, bool pathIsInverse) {
if ((maxHeight | maxTransitions) < 0) {
return false;
}
if (pathIsInverse) {
maxTransitions += 2;
}
int64_t count = sk_64_mul(maxHeight + 1, 3 + maxTransitions);
if (pathIsInverse) {
count += 10;
}
if (count < 0 || !sk_64_isS32(count)) {
return false;
}
fStorageCount = sk_64_asS32(count);
int64_t size = sk_64_mul(fStorageCount, sizeof(SkRegion::RunType));
if (size < 0 || !sk_64_isS32(size)) {
return false;
}
fStorage = (SkRegion::RunType*)sk_malloc_flags(sk_64_asS32(size), 0);
if (nullptr == fStorage) {
return false;
}
fCurrScanline = nullptr;        fPrevScanline = nullptr;        return true;
}","bool SkRgnBuilder::init(int VAR_0, int VAR_1, bool VAR_2) {
if ((VAR_0 | VAR_1) < 0) {
return false;
}
if (VAR_2) {
VAR_1 += 2;
}
int64_t VAR_3 = sk_64_mul(VAR_0 + 1, 3 + VAR_1);
if (VAR_2) {
VAR_3 += 10;
}
if (VAR_3 < 0 || !sk_64_isS32(VAR_3)) {
return false;
}
VAR_4 = sk_64_asS32(VAR_3);
int64_t VAR_5 = sk_64_mul(VAR_4, sizeof(SkRegion::RunType));
if (VAR_5 < 0 || !sk_64_isS32(VAR_5)) {
return false;
}
VAR_6 = (SkRegion::RunType*)sk_malloc_flags(sk_64_asS32(VAR_5), 0);
if (nullptr == VAR_6) {
return false;
}
VAR_7 = nullptr;    
VAR_8 = nullptr;    
return true;
}",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkRegion_path.cpp/vul/before/0.json,"bool SkRgnBuilder::init(int maxHeight, int maxTransitions, bool pathIsInverse) {
    if ((maxHeight | maxTransitions) < 0) {
        return false;
    }

    if (pathIsInverse) {
        // allow for additional X transitions to ""invert"" each scanline
        // [ L' ... normal transitions ... R' ]
        //
        maxTransitions += 2;
    }

    // compute the count with +1 and +3 slop for the working buffer
    int64_t count = sk_64_mul(maxHeight + 1, 3 + maxTransitions);

    if (pathIsInverse) {
        // allow for two ""empty"" rows for the top and bottom
        //      [ Y, 1, L, R, S] == 5 (*2 for top and bottom)
        count += 10;
    }

    if (count < 0 || !sk_64_isS32(count)) {
        return false;
    }
    fStorageCount = sk_64_asS32(count);

    fStorage = (SkRegion::RunType*)sk_malloc_canfail(fStorageCount, sizeof(SkRegion::RunType));
    if (nullptr == fStorage) {
        return false;
    }

    fCurrScanline = nullptr;    // signal empty collection
    fPrevScanline = nullptr;    // signal first scanline
    return true;
}","bool SkRgnBuilder::init(int VAR_0, int VAR_1, bool VAR_2) {
    if ((VAR_0 | VAR_1) < 0) {
        return false;
    }

    if (VAR_2) {
        /* COMMENT_0 */
        /* COMMENT_1 */
        /* COMMENT_2 */
        VAR_1 += 2;
    }

    /* COMMENT_3 */
    int64_t VAR_3 = sk_64_mul(VAR_0 + 1, 3 + VAR_1);

    if (VAR_2) {
        /* COMMENT_4 */
        /* COMMENT_5 */
        VAR_3 += 10;
    }

    if (VAR_3 < 0 || !sk_64_isS32(VAR_3)) {
        return false;
    }
    VAR_4 = sk_64_asS32(VAR_3);

    VAR_5 = (SkRegion::RunType*)sk_malloc_canfail(VAR_4, sizeof(SkRegion::RunType));
    if (nullptr == VAR_5) {
        return false;
    }

    VAR_6 = nullptr;    /* COMMENT_6 */
    VAR_7 = nullptr;    /* COMMENT_7 */
    return true;
}",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkRegion_path.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -24,12 +24,7 @@
     }
     fStorageCount = sk_64_asS32(count);
 
-    int64_t size = sk_64_mul(fStorageCount, sizeof(SkRegion::RunType));
-    if (size < 0 || !sk_64_isS32(size)) {
-        return false;
-    }
-
-    fStorage = (SkRegion::RunType*)sk_malloc_flags(sk_64_asS32(size), 0);
+    fStorage = (SkRegion::RunType*)sk_malloc_canfail(fStorageCount, sizeof(SkRegion::RunType));
     if (nullptr == fStorage) {
         return false;
     }","{'deleted_lines': ['    int64_t size = sk_64_mul(fStorageCount, sizeof(SkRegion::RunType));', '    if (size < 0 || !sk_64_isS32(size)) {', '        return false;', '    }', '', '    fStorage = (SkRegion::RunType*)sk_malloc_flags(sk_64_asS32(size), 0);'], 'added_lines': ['    fStorage = (SkRegion::RunType*)sk_malloc_canfail(fStorageCount, sizeof(SkRegion::RunType));']}",True,"In SkSampler::Fill of SkSampler.cpp, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-78354855",7.8,HIGH,2,test,,5
CVE-2018-9498,"['CWE-190', 'CWE-787']",AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"RESTRICT AUTOMERGE: Cherry-pick ""begin cleanup of malloc porting layer""

Bug: 78354855
Test: Not feasible

Original description:
========================================================================
1. Merge some of the allocators into sk_malloc_flags by redefining a flag to mean zero-init
2. Add more private helpers to simplify our call-sites (and handle some overflow mul checks)
3. The 2-param helpers rely on the saturating SkSafeMath::Mul to pass max_size_t as the request,
which should always fail.

chromium: 508641
Reviewed-on: https://skia-review.googlesource.com/90940
Commit-Queue: Mike Reed <reed@google.com>
Reviewed-by: Robert Phillips <robertphillips@google.com>
Reviewed-by: Stephan Altmueller <stephana@google.com>
========================================================================

Conflicts:
- include/private/SkMalloc.h
Simply removed the old definitions of SK_MALLOC_TEMP and SK_MALLOC_THROW.
- public.bzl
Copied SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER into the old defines.
- src/codec/SkIcoCodec.cpp
Drop a change where we were not using malloc yet.
- src/codec/SkBmpBaseCodec.cpp
- src/core/SkBitmapCache.cpp
These files weren't yet using malloc (and SkBmpBaseCodec hadn't been
factored out).
- src/core/SkMallocPixelRef.cpp
These were still using New rather than Make (return raw pointer). Leave
them unchanged, as sk_malloc_flags is still valid.
- src/lazy/SkDiscardableMemoryPool.cpp
Leave this unchanged; sk_malloc_flags is still valid

In addition, pull in SkSafeMath.h, which was originally introduced in
https://skia-review.googlesource.com/c/skia/+/33721. This is required
for the new sk_malloc calls.

Also pull in SkSafeMath::Add and SkSafeMath::Mul, introduced in
https://skia-review.googlesource.com/88581

Also add SK_MaxSizeT, which the above depends on, introduced in
https://skia-review.googlesource.com/57084

Also, modify NewFromStream to use sk_malloc_canfail, matching pi and
avoiding a build break

Change-Id: Ib320484673a865460fc1efb900f611209e088edb
(cherry picked from commit a12cc3e14ea6734c7efe76aa6a19239909830b28)
",77c955200ddd1761d6ed7a6c1578349fedbb55e4,https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4,src/codec/SkIcoCodec.cpp,SkIcoCodec::NewFromStream,"SkCodec* SkIcoCodec::NewFromStream(SkStream* stream, Result* result) {
std::unique_ptr<SkStream> inputStream(stream);
static const uint32_t kIcoDirectoryBytes = 6;
static const uint32_t kIcoDirEntryBytes = 16;
std::unique_ptr<uint8_t[]> dirBuffer(new uint8_t[kIcoDirectoryBytes]);
if (inputStream.get()->read(dirBuffer.get(), kIcoDirectoryBytes) !=
kIcoDirectoryBytes) {
SkCodecPrintf(""Error: unable to read ico directory header.\n"");
*result = kIncompleteInput;
return nullptr;
}
const uint16_t numImages = get_short(dirBuffer.get(), 4);
if (0 == numImages) {
SkCodecPrintf(""Error: No images embedded in ico.\n"");
*result = kInvalidInput;
return nullptr;
}
struct Entry {
uint32_t offset;
uint32_t size;
};
SkAutoFree dirEntryBuffer(sk_malloc_flags(sizeof(Entry) * numImages,
SK_MALLOC_TEMP));
if (!dirEntryBuffer) {
SkCodecPrintf(""Error: OOM allocating ICO directory for %i images.\n"",
numImages);
*result = kInternalError;
return nullptr;
}
auto* directoryEntries = reinterpret_cast<Entry*>(dirEntryBuffer.get());
for (uint32_t i = 0; i < numImages; i++) {
uint8_t entryBuffer[kIcoDirEntryBytes];
if (inputStream->read(entryBuffer, kIcoDirEntryBytes) !=
kIcoDirEntryBytes) {
SkCodecPrintf(""Error: Dir entries truncated in ico.\n"");
*result = kIncompleteInput;
return nullptr;
}
uint32_t size = get_int(entryBuffer, 8);
uint32_t offset = get_int(entryBuffer, 12);
directoryEntries[i].offset = offset;
directoryEntries[i].size = size;
}
*result = kInvalidInput;
struct EntryLessThan {
bool operator() (Entry a, Entry b) const {
return a.offset < b.offset;
}
};
EntryLessThan lessThan;
SkTQSort(directoryEntries, &directoryEntries[numImages - 1], lessThan);
uint32_t bytesRead = kIcoDirectoryBytes + numImages * kIcoDirEntryBytes;
std::unique_ptr<SkTArray<std::unique_ptr<SkCodec>, true>> codecs(
new (SkTArray<std::unique_ptr<SkCodec>, true>)(numImages));
for (uint32_t i = 0; i < numImages; i++) {
uint32_t offset = directoryEntries[i].offset;
uint32_t size = directoryEntries[i].size;
if (offset < bytesRead) {
SkCodecPrintf(""Warning: invalid ico offset.\n"");
continue;
}
if (inputStream.get()->skip(offset - bytesRead) != offset - bytesRead) {
SkCodecPrintf(""Warning: could not skip to ico offset.\n"");
break;
}
bytesRead = offset;
SkAutoFree buffer(sk_malloc_flags(size, 0));
if (!buffer) {
SkCodecPrintf(""Warning: OOM trying to create embedded stream.\n"");
break;
}
if (inputStream->read(buffer.get(), size) != size) {
SkCodecPrintf(""Warning: could not create embedded stream.\n"");
*result = kIncompleteInput;
break;
}
sk_sp<SkData> data(SkData::MakeFromMalloc(buffer.release(), size));
std::unique_ptr<SkMemoryStream> embeddedStream(new SkMemoryStream(data));
bytesRead += size;
SkCodec* codec = nullptr;
Result dummyResult;
if (SkPngCodec::IsPng((const char*) data->bytes(), data->size())) {
codec = SkPngCodec::NewFromStream(embeddedStream.release(), &dummyResult);
} else {
codec = SkBmpCodec::NewFromIco(embeddedStream.release(), &dummyResult);
}
if (nullptr != codec) {
codecs->push_back().reset(codec);
}
}
if (0 == codecs->count()) {
SkCodecPrintf(""Error: could not find any valid embedded ico codecs.\n"");
return nullptr;
}
size_t maxSize = 0;
int maxIndex = 0;
for (int i = 0; i < codecs->count(); i++) {
SkImageInfo info = codecs->operator[](i)->getInfo();
size_t size = info.getSafeSize(info.minRowBytes());
if (size > maxSize) {
maxSize = size;
maxIndex = i;
}
}
int width = codecs->operator[](maxIndex)->getInfo().width();
int height = codecs->operator[](maxIndex)->getInfo().height();
SkEncodedInfo info = codecs->operator[](maxIndex)->getEncodedInfo();
SkColorSpace* colorSpace = codecs->operator[](maxIndex)->getInfo().colorSpace();
*result = kSuccess;
return new SkIcoCodec(width, height, info, codecs.release(), sk_ref_sp(colorSpace));
}","SkCodec* SkIcoCodec::NewFromStream(SkStream* VAR_0, Result* VAR_1) {
std::unique_ptr<SkStream> inputStream(stream);
static const uint32_t VAR_2 = 6;
static const uint32_t VAR_3 = 16;
std::unique_ptr<uint8_t[]> VAR_4(new uint8_t[VAR_2]);
if (VAR_5.get()->read(VAR_4.get(), VAR_2) !=
VAR_2) {
SkCodecPrintf(""Error: unable to read ico directory header.\n"");
*VAR_1 = VAR_6;
return nullptr;
}
const uint16_t VAR_7 = get_short(VAR_4.get(), 4);
if (0 == VAR_7) {
SkCodecPrintf(""Error: No images embedded in ico.\n"");
*VAR_1 = VAR_8;
return nullptr;
}
struct Entry {
uint32_t offset;
uint32_t size;
};
SkAutoFree VAR_9(sk_malloc_flags(sizeof(Entry) * VAR_7,
VAR_10));
if (!VAR_9) {
SkCodecPrintf(""Error: OOM allocating ICO directory for %i images.\n"",
VAR_7);
*VAR_1 = VAR_11;
return nullptr;
}
auto* VAR_12 = VAR_13<Entry*>(VAR_9.get());
for (uint32_t VAR_14 = 0; VAR_14 < VAR_7; VAR_14++) {
uint8_t VAR_15[VAR_3];
if (VAR_5->read(VAR_15, VAR_3) !=
VAR_3) {
SkCodecPrintf(""Error: Dir entries truncated in ico.\n"");
*VAR_1 = VAR_6;
return nullptr;
}
uint32_t VAR_16 = get_int(VAR_15, 8);
uint32_t VAR_17 = get_int(VAR_15, 12);
VAR_12[VAR_14].offset = VAR_17;
VAR_12[VAR_14].size = VAR_16;
}
*VAR_1 = VAR_8;
struct EntryLessThan {
bool operator() (Entry VAR_18, Entry VAR_19) const {
return VAR_18.offset < VAR_19.offset;
}
};
EntryLessThan VAR_20;
SkTQSort(VAR_12, &VAR_12[VAR_7 - 1], VAR_20);
uint32_t VAR_21 = VAR_2 + VAR_7 * VAR_3;
std::unique_ptr<SkTArray<std::unique_ptr<SkCodec>, true>> VAR_22(
new (SkTArray<std::unique_ptr<SkCodec>, true>)(VAR_7));
for (uint32_t VAR_14 = 0; VAR_14 < VAR_7; VAR_14++) {
uint32_t VAR_17 = VAR_12[VAR_14].offset;
uint32_t VAR_16 = VAR_12[VAR_14].size;
if (VAR_17 < VAR_21) {
SkCodecPrintf(""Warning: invalid ico offset.\n"");
continue;
}
if (VAR_5.get()->skip(VAR_17 - VAR_21) != VAR_17 - VAR_21) {
SkCodecPrintf(""Warning: could not skip to ico offset.\n"");
break;
}
VAR_21 = VAR_17;
SkAutoFree VAR_23(sk_malloc_flags(VAR_16, 0));
if (!VAR_23) {
SkCodecPrintf(""Warning: OOM trying to create embedded stream.\n"");
break;
}
if (VAR_5->read(VAR_23.get(), VAR_16) != VAR_16) {
SkCodecPrintf(""Warning: could not create embedded stream.\n"");
*VAR_1 = VAR_6;
break;
}
sk_sp<SkData> VAR_24(SkData::MakeFromMalloc(VAR_23.release(), VAR_16));
std::unique_ptr<SkMemoryStream> VAR_25(new SkMemoryStream(VAR_24));
VAR_21 += VAR_16;
SkCodec* VAR_26 = nullptr;
Result VAR_27;
if (SkPngCodec::IsPng((const char*) VAR_24->bytes(), VAR_24->size())) {
VAR_26 = SkPngCodec::NewFromStream(VAR_25.release(), &VAR_27);
} else {
VAR_26 = SkBmpCodec::NewFromIco(VAR_25.release(), &VAR_27);
}
if (nullptr != VAR_26) {
VAR_22->push_back().reset(VAR_26);
}
}
if (0 == VAR_22->count()) {
SkCodecPrintf(""Error: could not find any valid embedded ico codecs.\n"");
return nullptr;
}
size_t VAR_28 = 0;
int VAR_29 = 0;
for (int VAR_14 = 0; VAR_14 < VAR_22->count(); VAR_14++) {
SkImageInfo VAR_30 = VAR_22->operator[](VAR_14)->getInfo();
size_t VAR_16 = VAR_30.getSafeSize(VAR_30.minRowBytes());
if (VAR_16 > VAR_28) {
VAR_28 = VAR_16;
VAR_29 = VAR_14;
}
}
int VAR_31 = VAR_22->operator[](VAR_29)->getInfo().width();
int VAR_32 = VAR_22->operator[](VAR_29)->getInfo().height();
SkEncodedInfo VAR_30 = VAR_22->operator[](VAR_29)->getEncodedInfo();
SkColorSpace* VAR_33 = VAR_22->operator[](VAR_29)->getInfo().colorSpace();
*VAR_1 = VAR_34;
return new SkIcoCodec(VAR_31, VAR_32, VAR_30, VAR_22.release(), sk_ref_sp(VAR_33));
}",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkIcoCodec.cpp/vul/before/0.json,"SkCodec* SkIcoCodec::NewFromStream(SkStream* stream, Result* result) {
    // Ensure that we do not leak the input stream
    std::unique_ptr<SkStream> inputStream(stream);

    // Header size constants
    static const uint32_t kIcoDirectoryBytes = 6;
    static const uint32_t kIcoDirEntryBytes = 16;

    // Read the directory header
    std::unique_ptr<uint8_t[]> dirBuffer(new uint8_t[kIcoDirectoryBytes]);
    if (inputStream.get()->read(dirBuffer.get(), kIcoDirectoryBytes) !=
            kIcoDirectoryBytes) {
        SkCodecPrintf(""Error: unable to read ico directory header.\n"");
        *result = kIncompleteInput;
        return nullptr;
    }

    // Process the directory header
    const uint16_t numImages = get_short(dirBuffer.get(), 4);
    if (0 == numImages) {
        SkCodecPrintf(""Error: No images embedded in ico.\n"");
        *result = kInvalidInput;
        return nullptr;
    }

    // This structure is used to represent the vital information about entries
    // in the directory header.  We will obtain this information for each
    // directory entry.
    struct Entry {
        uint32_t offset;
        uint32_t size;
    };
    SkAutoFree dirEntryBuffer(sk_malloc_canfail(sizeof(Entry) * numImages));
    if (!dirEntryBuffer) {
        SkCodecPrintf(""Error: OOM allocating ICO directory for %i images.\n"",
                      numImages);
        *result = kInternalError;
        return nullptr;
    }
    auto* directoryEntries = reinterpret_cast<Entry*>(dirEntryBuffer.get());

    // Iterate over directory entries
    for (uint32_t i = 0; i < numImages; i++) {
        uint8_t entryBuffer[kIcoDirEntryBytes];
        if (inputStream->read(entryBuffer, kIcoDirEntryBytes) !=
                kIcoDirEntryBytes) {
            SkCodecPrintf(""Error: Dir entries truncated in ico.\n"");
            *result = kIncompleteInput;
            return nullptr;
        }

        // The directory entry contains information such as width, height,
        // bits per pixel, and number of colors in the color palette.  We will
        // ignore these fields since they are repeated in the header of the
        // embedded image.  In the event of an inconsistency, we would always
        // defer to the value in the embedded header anyway.

        // Specifies the size of the embedded image, including the header
        uint32_t size = get_int(entryBuffer, 8);

        // Specifies the offset of the embedded image from the start of file.
        // It does not indicate the start of the pixel data, but rather the
        // start of the embedded image header.
        uint32_t offset = get_int(entryBuffer, 12);

        // Save the vital fields
        directoryEntries[i].offset = offset;
        directoryEntries[i].size = size;
    }

    // Default Result, if no valid embedded codecs are found.
    *result = kInvalidInput;

    // It is ""customary"" that the embedded images will be stored in order of
    // increasing offset.  However, the specification does not indicate that
    // they must be stored in this order, so we will not trust that this is the
    // case.  Here we sort the embedded images by increasing offset.
    struct EntryLessThan {
        bool operator() (Entry a, Entry b) const {
            return a.offset < b.offset;
        }
    };
    EntryLessThan lessThan;
    SkTQSort(directoryEntries, &directoryEntries[numImages - 1], lessThan);

    // Now will construct a candidate codec for each of the embedded images
    uint32_t bytesRead = kIcoDirectoryBytes + numImages * kIcoDirEntryBytes;
    std::unique_ptr<SkTArray<std::unique_ptr<SkCodec>, true>> codecs(
            new (SkTArray<std::unique_ptr<SkCodec>, true>)(numImages));
    for (uint32_t i = 0; i < numImages; i++) {
        uint32_t offset = directoryEntries[i].offset;
        uint32_t size = directoryEntries[i].size;

        // Ensure that the offset is valid
        if (offset < bytesRead) {
            SkCodecPrintf(""Warning: invalid ico offset.\n"");
            continue;
        }

        // If we cannot skip, assume we have reached the end of the stream and
        // stop trying to make codecs
        if (inputStream.get()->skip(offset - bytesRead) != offset - bytesRead) {
            SkCodecPrintf(""Warning: could not skip to ico offset.\n"");
            break;
        }
        bytesRead = offset;

        // Create a new stream for the embedded codec
        SkAutoFree buffer(sk_malloc_canfail(size));
        if (!buffer) {
            SkCodecPrintf(""Warning: OOM trying to create embedded stream.\n"");
            break;
        }

        if (inputStream->read(buffer.get(), size) != size) {
            SkCodecPrintf(""Warning: could not create embedded stream.\n"");
            *result = kIncompleteInput;
            break;
        }

        sk_sp<SkData> data(SkData::MakeFromMalloc(buffer.release(), size));
        std::unique_ptr<SkMemoryStream> embeddedStream(new SkMemoryStream(data));
        bytesRead += size;

        // Check if the embedded codec is bmp or png and create the codec
        SkCodec* codec = nullptr;
        Result dummyResult;
        if (SkPngCodec::IsPng((const char*) data->bytes(), data->size())) {
            codec = SkPngCodec::NewFromStream(embeddedStream.release(), &dummyResult);
        } else {
            codec = SkBmpCodec::NewFromIco(embeddedStream.release(), &dummyResult);
        }

        // Save a valid codec
        if (nullptr != codec) {
            codecs->push_back().reset(codec);
        }
    }

    // Recognize if there are no valid codecs
    if (0 == codecs->count()) {
        SkCodecPrintf(""Error: could not find any valid embedded ico codecs.\n"");
        return nullptr;
    }

    // Use the largest codec as a ""suggestion"" for image info
    size_t maxSize = 0;
    int maxIndex = 0;
    for (int i = 0; i < codecs->count(); i++) {
        SkImageInfo info = codecs->operator[](i)->getInfo();
        size_t size = info.getSafeSize(info.minRowBytes());

        if (size > maxSize) {
            maxSize = size;
            maxIndex = i;
        }
    }
    int width = codecs->operator[](maxIndex)->getInfo().width();
    int height = codecs->operator[](maxIndex)->getInfo().height();
    SkEncodedInfo info = codecs->operator[](maxIndex)->getEncodedInfo();
    SkColorSpace* colorSpace = codecs->operator[](maxIndex)->getInfo().colorSpace();

    *result = kSuccess;
    // The original stream is no longer needed, because the embedded codecs own their
    // own streams.
    return new SkIcoCodec(width, height, info, codecs.release(), sk_ref_sp(colorSpace));
}","SkCodec* SkIcoCodec::NewFromStream(SkStream* VAR_0, Result* VAR_1) {
    /* COMMENT_0 */
    std::unique_ptr<SkStream> inputStream(stream);

    /* COMMENT_1 */
    static const uint32_t VAR_2 = 6;
    static const uint32_t VAR_3 = 16;

    /* COMMENT_2 */
    std::unique_ptr<uint8_t[]> VAR_4(new uint8_t[VAR_2]);
    if (VAR_5.get()->read(VAR_4.get(), VAR_2) !=
            VAR_2) {
        SkCodecPrintf(""Error: unable to read ico directory header.\n"");
        *VAR_1 = VAR_6;
        return nullptr;
    }

    /* COMMENT_3 */
    const uint16_t VAR_7 = get_short(VAR_4.get(), 4);
    if (0 == VAR_7) {
        SkCodecPrintf(""Error: No images embedded in ico.\n"");
        *VAR_1 = VAR_8;
        return nullptr;
    }

    /* COMMENT_4 */
    /* COMMENT_5 */
    /* COMMENT_6 */
    struct Entry {
        uint32_t offset;
        uint32_t size;
    };
    SkAutoFree VAR_9(sk_malloc_canfail(sizeof(Entry) * VAR_7));
    if (!VAR_9) {
        SkCodecPrintf(""Error: OOM allocating ICO directory for %i images.\n"",
                      VAR_7);
        *VAR_1 = VAR_10;
        return nullptr;
    }
    auto* VAR_11 = VAR_12<Entry*>(VAR_9.get());

    /* COMMENT_7 */
    for (uint32_t VAR_13 = 0; VAR_13 < VAR_7; VAR_13++) {
        uint8_t VAR_14[VAR_3];
        if (VAR_5->read(VAR_14, VAR_3) !=
                VAR_3) {
            SkCodecPrintf(""Error: Dir entries truncated in ico.\n"");
            *VAR_1 = VAR_6;
            return nullptr;
        }

        /* COMMENT_8 */
        /* COMMENT_9 */
        /* COMMENT_10 */
        /* COMMENT_11 */
        /* COMMENT_12 */

        /* COMMENT_13 */
        uint32_t VAR_15 = get_int(VAR_14, 8);

        /* COMMENT_14 */
        /* COMMENT_15 */
        /* COMMENT_16 */
        uint32_t VAR_16 = get_int(VAR_14, 12);

        /* COMMENT_17 */
        VAR_11[VAR_13].offset = VAR_16;
        VAR_11[VAR_13].size = VAR_15;
    }

    /* COMMENT_18 */
    *VAR_1 = VAR_8;

    /* COMMENT_19 */
    /* COMMENT_20 */
    /* COMMENT_21 */
    /* COMMENT_22 */
    struct EntryLessThan {
        bool operator() (Entry VAR_17, Entry VAR_18) const {
            return VAR_17.offset < VAR_18.offset;
        }
    };
    EntryLessThan VAR_19;
    SkTQSort(VAR_11, &VAR_11[VAR_7 - 1], VAR_19);

    /* COMMENT_23 */
    uint32_t VAR_20 = VAR_2 + VAR_7 * VAR_3;
    std::unique_ptr<SkTArray<std::unique_ptr<SkCodec>, true>> VAR_21(
            new (SkTArray<std::unique_ptr<SkCodec>, true>)(VAR_7));
    for (uint32_t VAR_13 = 0; VAR_13 < VAR_7; VAR_13++) {
        uint32_t VAR_16 = VAR_11[VAR_13].offset;
        uint32_t VAR_15 = VAR_11[VAR_13].size;

        /* COMMENT_24 */
        if (VAR_16 < VAR_20) {
            SkCodecPrintf(""Warning: invalid ico offset.\n"");
            continue;
        }

        /* COMMENT_25 */
        /* COMMENT_26 */
        if (VAR_5.get()->skip(VAR_16 - VAR_20) != VAR_16 - VAR_20) {
            SkCodecPrintf(""Warning: could not skip to ico offset.\n"");
            break;
        }
        VAR_20 = VAR_16;

        /* COMMENT_27 */
        SkAutoFree buffer(sk_malloc_canfail(size));
        if (!VAR_22) {
            SkCodecPrintf(""Warning: OOM trying to create embedded stream.\n"");
            break;
        }

        if (VAR_5->read(VAR_22.get(), size) != size) {
            SkCodecPrintf(""Warning: could not create embedded stream.\n"");
            *VAR_1 = VAR_6;
            break;
        }

        sk_sp<SkData> VAR_23(SkData::MakeFromMalloc(VAR_22.release(), size));
        std::unique_ptr<SkMemoryStream> VAR_24(new SkMemoryStream(VAR_23));
        VAR_20 += size;

        /* COMMENT_28 */
        SkCodec* VAR_25 = nullptr;
        Result VAR_26;
        if (SkPngCodec::IsPng((const char*) VAR_23->bytes(), VAR_23->size())) {
            VAR_25 = SkPngCodec::NewFromStream(VAR_24.release(), &VAR_26);
        } else {
            VAR_25 = SkBmpCodec::NewFromIco(VAR_24.release(), &VAR_26);
        }

        /* COMMENT_29 */
        if (nullptr != VAR_25) {
            VAR_21->push_back().reset(VAR_25);
        }
    }

    /* COMMENT_30 */
    if (0 == VAR_21->count()) {
        SkCodecPrintf(""Error: could not find any valid embedded ico codecs.\n"");
        return nullptr;
    }

    /* COMMENT_31 */
    size_t VAR_27 = 0;
    int VAR_28 = 0;
    for (int VAR_13 = 0; VAR_13 < VAR_21->count(); VAR_13++) {
        SkImageInfo VAR_29 = VAR_21->operator[](VAR_13)->getInfo();
        size_t size = VAR_29.getSafeSize(VAR_29.minRowBytes());

        if (size > VAR_27) {
            VAR_27 = size;
            VAR_28 = VAR_13;
        }
    }
    int VAR_30 = VAR_21->operator[](VAR_28)->getInfo().width();
    int VAR_31 = VAR_21->operator[](VAR_28)->getInfo().height();
    SkEncodedInfo VAR_29 = VAR_21->operator[](VAR_28)->getEncodedInfo();
    SkColorSpace* VAR_32 = VAR_21->operator[](VAR_28)->getInfo().colorSpace();

    *VAR_1 = VAR_33;
    /* COMMENT_32 */
    /* COMMENT_33 */
    return new SkIcoCodec(VAR_30, VAR_31, VAR_29, VAR_21.release(), sk_ref_sp(VAR_32));
}",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkIcoCodec.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -30,8 +30,7 @@
         uint32_t offset;
         uint32_t size;
     };
-    SkAutoFree dirEntryBuffer(sk_malloc_flags(sizeof(Entry) * numImages,
-                                              SK_MALLOC_TEMP));
+    SkAutoFree dirEntryBuffer(sk_malloc_canfail(sizeof(Entry) * numImages));
     if (!dirEntryBuffer) {
         SkCodecPrintf(""Error: OOM allocating ICO directory for %i images.\n"",
                       numImages);
@@ -107,7 +106,7 @@
         bytesRead = offset;
 
         // Create a new stream for the embedded codec
-        SkAutoFree buffer(sk_malloc_flags(size, 0));
+        SkAutoFree buffer(sk_malloc_canfail(size));
         if (!buffer) {
             SkCodecPrintf(""Warning: OOM trying to create embedded stream.\n"");
             break;","{'deleted_lines': ['    SkAutoFree dirEntryBuffer(sk_malloc_flags(sizeof(Entry) * numImages,', '                                              SK_MALLOC_TEMP));', '        SkAutoFree buffer(sk_malloc_flags(size, 0));'], 'added_lines': ['    SkAutoFree dirEntryBuffer(sk_malloc_canfail(sizeof(Entry) * numImages));', '        SkAutoFree buffer(sk_malloc_canfail(size));']}",True,"In SkSampler::Fill of SkSampler.cpp, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-78354855",7.8,HIGH,2,test,,5
CVE-2018-9498,"['CWE-190', 'CWE-787']",AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"RESTRICT AUTOMERGE: Cherry-pick ""begin cleanup of malloc porting layer""

Bug: 78354855
Test: Not feasible

Original description:
========================================================================
1. Merge some of the allocators into sk_malloc_flags by redefining a flag to mean zero-init
2. Add more private helpers to simplify our call-sites (and handle some overflow mul checks)
3. The 2-param helpers rely on the saturating SkSafeMath::Mul to pass max_size_t as the request,
which should always fail.

chromium: 508641
Reviewed-on: https://skia-review.googlesource.com/90940
Commit-Queue: Mike Reed <reed@google.com>
Reviewed-by: Robert Phillips <robertphillips@google.com>
Reviewed-by: Stephan Altmueller <stephana@google.com>
========================================================================

Conflicts:
- include/private/SkMalloc.h
Simply removed the old definitions of SK_MALLOC_TEMP and SK_MALLOC_THROW.
- public.bzl
Copied SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER into the old defines.
- src/codec/SkIcoCodec.cpp
Drop a change where we were not using malloc yet.
- src/codec/SkBmpBaseCodec.cpp
- src/core/SkBitmapCache.cpp
These files weren't yet using malloc (and SkBmpBaseCodec hadn't been
factored out).
- src/core/SkMallocPixelRef.cpp
These were still using New rather than Make (return raw pointer). Leave
them unchanged, as sk_malloc_flags is still valid.
- src/lazy/SkDiscardableMemoryPool.cpp
Leave this unchanged; sk_malloc_flags is still valid

In addition, pull in SkSafeMath.h, which was originally introduced in
https://skia-review.googlesource.com/c/skia/+/33721. This is required
for the new sk_malloc calls.

Also pull in SkSafeMath::Add and SkSafeMath::Mul, introduced in
https://skia-review.googlesource.com/88581

Also add SK_MaxSizeT, which the above depends on, introduced in
https://skia-review.googlesource.com/57084

Also, modify NewFromStream to use sk_malloc_canfail, matching pi and
avoiding a build break

Change-Id: Ib320484673a865460fc1efb900f611209e088edb
(cherry picked from commit a12cc3e14ea6734c7efe76aa6a19239909830b28)
",77c955200ddd1761d6ed7a6c1578349fedbb55e4,https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4,include/private/SkTArray.h,init,"void init(int count = 0, int reserveCount = 0) {
SkASSERT(count >= 0);
SkASSERT(reserveCount >= 0);
fCount = count;
if (!count && !reserveCount) {
fAllocCount = 0;
fMemArray = nullptr;
fOwnMemory = false;
fReserved = false;
} else {
fAllocCount = SkTMax(count, SkTMax(kMinHeapAllocCount, reserveCount));
fMemArray = sk_malloc_throw(fAllocCount * sizeof(T));
fOwnMemory = true;
fReserved = reserveCount > 0;
}
}","void init(int VAR_0 = 0, int VAR_1 = 0) {
SkASSERT(VAR_0 >= 0);
SkASSERT(VAR_1 >= 0);
VAR_2 = VAR_0;
if (!VAR_0 && !VAR_1) {
VAR_3 = 0;
VAR_4 = nullptr;
VAR_5 = false;
VAR_6 = false;
} else {
VAR_3 = SkTMax(VAR_0, SkTMax(VAR_7, VAR_1));
VAR_4 = sk_malloc_throw(VAR_3 * sizeof(VAR_8));
VAR_5 = true;
VAR_6 = VAR_1 > 0;
}
}",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkTArray.h/vul/before/0.json,"void init(int count = 0, int reserveCount = 0) {
        SkASSERT(count >= 0);
        SkASSERT(reserveCount >= 0);
        fCount = count;
        if (!count && !reserveCount) {
            fAllocCount = 0;
            fMemArray = nullptr;
            fOwnMemory = false;
            fReserved = false;
        } else {
            fAllocCount = SkTMax(count, SkTMax(kMinHeapAllocCount, reserveCount));
            fMemArray = sk_malloc_throw(fAllocCount, sizeof(T));
            fOwnMemory = true;
            fReserved = reserveCount > 0;
        }
    }","void init(int VAR_0 = 0, int VAR_1 = 0) {
        SkASSERT(VAR_0 >= 0);
        SkASSERT(VAR_1 >= 0);
        VAR_2 = VAR_0;
        if (!VAR_0 && !VAR_1) {
            VAR_3 = 0;
            VAR_4 = nullptr;
            VAR_5 = false;
            VAR_6 = false;
        } else {
            VAR_3 = SkTMax(VAR_0, SkTMax(VAR_7, VAR_1));
            VAR_4 = sk_malloc_throw(VAR_3, sizeof(VAR_8));
            VAR_5 = true;
            VAR_6 = VAR_1 > 0;
        }
    }",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkTArray.h/vul/after/0.json,"--- func_before
+++ func_after
@@ -9,7 +9,7 @@
             fReserved = false;
         } else {
             fAllocCount = SkTMax(count, SkTMax(kMinHeapAllocCount, reserveCount));
-            fMemArray = sk_malloc_throw(fAllocCount * sizeof(T));
+            fMemArray = sk_malloc_throw(fAllocCount, sizeof(T));
             fOwnMemory = true;
             fReserved = reserveCount > 0;
         }","{'deleted_lines': ['            fMemArray = sk_malloc_throw(fAllocCount * sizeof(T));'], 'added_lines': ['            fMemArray = sk_malloc_throw(fAllocCount, sizeof(T));']}",True,"In SkSampler::Fill of SkSampler.cpp, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-78354855",7.8,HIGH,2,test,,5
CVE-2018-9498,"['CWE-190', 'CWE-787']",AV:N/AC:M/Au:N/C:C/I:C/A:C,0,android,"RESTRICT AUTOMERGE: Cherry-pick ""begin cleanup of malloc porting layer""

Bug: 78354855
Test: Not feasible

Original description:
========================================================================
1. Merge some of the allocators into sk_malloc_flags by redefining a flag to mean zero-init
2. Add more private helpers to simplify our call-sites (and handle some overflow mul checks)
3. The 2-param helpers rely on the saturating SkSafeMath::Mul to pass max_size_t as the request,
which should always fail.

chromium: 508641
Reviewed-on: https://skia-review.googlesource.com/90940
Commit-Queue: Mike Reed <reed@google.com>
Reviewed-by: Robert Phillips <robertphillips@google.com>
Reviewed-by: Stephan Altmueller <stephana@google.com>
========================================================================

Conflicts:
- include/private/SkMalloc.h
Simply removed the old definitions of SK_MALLOC_TEMP and SK_MALLOC_THROW.
- public.bzl
Copied SK_SUPPORT_LEGACY_MALLOC_PORTING_LAYER into the old defines.
- src/codec/SkIcoCodec.cpp
Drop a change where we were not using malloc yet.
- src/codec/SkBmpBaseCodec.cpp
- src/core/SkBitmapCache.cpp
These files weren't yet using malloc (and SkBmpBaseCodec hadn't been
factored out).
- src/core/SkMallocPixelRef.cpp
These were still using New rather than Make (return raw pointer). Leave
them unchanged, as sk_malloc_flags is still valid.
- src/lazy/SkDiscardableMemoryPool.cpp
Leave this unchanged; sk_malloc_flags is still valid

In addition, pull in SkSafeMath.h, which was originally introduced in
https://skia-review.googlesource.com/c/skia/+/33721. This is required
for the new sk_malloc calls.

Also pull in SkSafeMath::Add and SkSafeMath::Mul, introduced in
https://skia-review.googlesource.com/88581

Also add SK_MaxSizeT, which the above depends on, introduced in
https://skia-review.googlesource.com/57084

Also, modify NewFromStream to use sk_malloc_canfail, matching pi and
avoiding a build break

Change-Id: Ib320484673a865460fc1efb900f611209e088edb
(cherry picked from commit a12cc3e14ea6734c7efe76aa6a19239909830b28)
",77c955200ddd1761d6ed7a6c1578349fedbb55e4,https://android.googlesource.com/platform/external/skia/+/77c955200ddd1761d6ed7a6c1578349fedbb55e4,include/private/SkTArray.h,initWithPreallocatedStorage,"void initWithPreallocatedStorage(int count, void* preallocStorage, int preallocCount) {
SkASSERT(count >= 0);
SkASSERT(preallocCount > 0);
SkASSERT(preallocStorage);
fCount = count;
fMemArray = nullptr;
fReserved = false;
if (count > preallocCount) {
fAllocCount = SkTMax(count, kMinHeapAllocCount);
fMemArray = sk_malloc_throw(fAllocCount * sizeof(T));
fOwnMemory = true;
} else {
fAllocCount = preallocCount;
fMemArray = preallocStorage;
fOwnMemory = false;
}
}","void initWithPreallocatedStorage(int VAR_0, void* VAR_1, int VAR_2) {
SkASSERT(VAR_0 >= 0);
SkASSERT(VAR_2 > 0);
SkASSERT(VAR_1);
VAR_3 = VAR_0;
VAR_4 = nullptr;
VAR_5 = false;
if (VAR_0 > VAR_2) {
VAR_6 = SkTMax(VAR_0, VAR_7);
VAR_4 = sk_malloc_throw(VAR_6 * sizeof(VAR_8));
VAR_9 = true;
} else {
VAR_6 = VAR_2;
VAR_4 = VAR_1;
VAR_9 = false;
}
}",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkTArray.h/vul/before/1.json,"void initWithPreallocatedStorage(int count, void* preallocStorage, int preallocCount) {
        SkASSERT(count >= 0);
        SkASSERT(preallocCount > 0);
        SkASSERT(preallocStorage);
        fCount = count;
        fMemArray = nullptr;
        fReserved = false;
        if (count > preallocCount) {
            fAllocCount = SkTMax(count, kMinHeapAllocCount);
            fMemArray = sk_malloc_throw(fAllocCount, sizeof(T));
            fOwnMemory = true;
        } else {
            fAllocCount = preallocCount;
            fMemArray = preallocStorage;
            fOwnMemory = false;
        }
    }","void initWithPreallocatedStorage(int VAR_0, void* VAR_1, int VAR_2) {
        SkASSERT(VAR_0 >= 0);
        SkASSERT(VAR_2 > 0);
        SkASSERT(VAR_1);
        VAR_3 = VAR_0;
        VAR_4 = nullptr;
        VAR_5 = false;
        if (VAR_0 > VAR_2) {
            VAR_6 = SkTMax(VAR_0, VAR_7);
            VAR_4 = sk_malloc_throw(VAR_6, sizeof(VAR_8));
            VAR_9 = true;
        } else {
            VAR_6 = VAR_2;
            VAR_4 = VAR_1;
            VAR_9 = false;
        }
    }",android/77c955200ddd1761d6ed7a6c1578349fedbb55e4/SkTArray.h/vul/after/1.json,"--- func_before
+++ func_after
@@ -7,7 +7,7 @@
         fReserved = false;
         if (count > preallocCount) {
             fAllocCount = SkTMax(count, kMinHeapAllocCount);
-            fMemArray = sk_malloc_throw(fAllocCount * sizeof(T));
+            fMemArray = sk_malloc_throw(fAllocCount, sizeof(T));
             fOwnMemory = true;
         } else {
             fAllocCount = preallocCount;","{'deleted_lines': ['            fMemArray = sk_malloc_throw(fAllocCount * sizeof(T));'], 'added_lines': ['            fMemArray = sk_malloc_throw(fAllocCount, sizeof(T));']}",True,"In SkSampler::Fill of SkSampler.cpp, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-78354855",7.8,HIGH,2,test,,5
CVE-2018-9507,['CWE-125'],AV:A/AC:L/Au:N/C:C/I:N/A:N,0,android,"Check packet length in bta_av_proc_meta_cmd

Bug: 111893951
Test: manual - connect A2DP
Change-Id: Ibbf347863dfd29ea3385312e9dde1082bc90d2f3
(cherry picked from commit ed51887f921263219bcd2fbf6650ead5ec8d334e)
",30cec963095366536ca0b1306089154e09bfe1a9,https://android.googlesource.com/platform/system/bt/+/30cec963095366536ca0b1306089154e09bfe1a9,bta/av/bta_av_act.cc,bta_av_proc_meta_cmd,"tBTA_AV_EVT bta_av_proc_meta_cmd(tAVRC_RESPONSE* p_rc_rsp,
tBTA_AV_RC_MSG* p_msg, uint8_t* p_ctype) {
tBTA_AV_EVT evt = BTA_AV_META_MSG_EVT;
uint8_t u8, pdu, *p;
uint16_t u16;
tAVRC_MSG_VENDOR* p_vendor = &p_msg->msg.vendor;
pdu = *(p_vendor->p_vendor_data);
p_rc_rsp->pdu = pdu;
*p_ctype = AVRC_RSP_REJ;
if ((AVRC_MIN_META_CMD_LEN + p_vendor->vendor_len) > AVRC_META_CMD_BUF_SIZE) {
p_rc_rsp->rsp.status = AVRC_STS_BAD_PARAM;
APPL_TRACE_ERROR(""%s: Invalid meta-command length: %d"", __func__,
p_vendor->vendor_len);
return 0;
}
if (p_vendor->hdr.subunit_type != AVRC_SUB_PANEL) {
APPL_TRACE_DEBUG(""%s: SUBUNIT must be PANEL"", __func__);
evt = 0;
p_vendor->hdr.ctype = AVRC_RSP_NOT_IMPL;
p_vendor->vendor_len = 0;
p_rc_rsp->rsp.status = AVRC_STS_BAD_PARAM;
} else if (!AVRC_IsValidAvcType(pdu, p_vendor->hdr.ctype)) {
APPL_TRACE_DEBUG(""%s: Invalid pdu/ctype: 0x%x, %d"", __func__, pdu,
p_vendor->hdr.ctype);
evt = 0;
p_rc_rsp->rsp.status = AVRC_STS_BAD_CMD;
} else {
switch (pdu) {
case AVRC_PDU_GET_CAPABILITIES:
evt = 0;
u8 = *(p_vendor->p_vendor_data + 4);
p = p_vendor->p_vendor_data + 2;
p_rc_rsp->get_caps.capability_id = u8;
BE_STREAM_TO_UINT16(u16, p);
if ((u16 != 1) || (p_vendor->vendor_len != 5)) {
p_rc_rsp->get_caps.status = AVRC_STS_INTERNAL_ERR;
} else {
p_rc_rsp->get_caps.status = AVRC_STS_NO_ERROR;
if (u8 == AVRC_CAP_COMPANY_ID) {
*p_ctype = AVRC_RSP_IMPL_STBL;
p_rc_rsp->get_caps.count = p_bta_av_cfg->num_co_ids;
memcpy(p_rc_rsp->get_caps.param.company_id,
p_bta_av_cfg->p_meta_co_ids,
(p_bta_av_cfg->num_co_ids << 2));
} else if (u8 == AVRC_CAP_EVENTS_SUPPORTED) {
*p_ctype = AVRC_RSP_IMPL_STBL;
p_rc_rsp->get_caps.count = p_bta_av_cfg->num_evt_ids;
memcpy(p_rc_rsp->get_caps.param.event_id,
p_bta_av_cfg->p_meta_evt_ids, p_bta_av_cfg->num_evt_ids);
} else {
APPL_TRACE_DEBUG(""%s: Invalid capability ID: 0x%x"", __func__, u8);
p_rc_rsp->get_caps.status = AVRC_STS_BAD_PARAM;
}
}
break;
case AVRC_PDU_REGISTER_NOTIFICATION:
p_rc_rsp->rsp.status = bta_av_chk_notif_evt_id(p_vendor);
if (p_rc_rsp->rsp.status != BTA_AV_STS_NO_RSP) evt = 0;
break;
}
}
return evt;
}","tBTA_AV_EVT bta_av_proc_meta_cmd(tAVRC_RESPONSE* VAR_0,
tBTA_AV_RC_MSG* VAR_1, uint8_t* VAR_2) {
tBTA_AV_EVT VAR_3 = VAR_4;
uint8_t VAR_5, VAR_6, *VAR_7;
uint16_t VAR_8;
tAVRC_MSG_VENDOR* VAR_9 = &VAR_1->msg.vendor;
VAR_6 = *(VAR_9->p_vendor_data);
VAR_0->pdu = VAR_6;
*VAR_2 = VAR_10;
if ((VAR_11 + VAR_9->vendor_len) > VAR_12) {
VAR_0->rsp.status = VAR_13;
APPL_TRACE_ERROR(""%s: Invalid meta-command length: %d"", VAR_14,
VAR_9->vendor_len);
return 0;
}
if (VAR_9->hdr.subunit_type != VAR_15) {
APPL_TRACE_DEBUG(""%s: SUBUNIT must be PANEL"", VAR_14);
VAR_3 = 0;
VAR_9->hdr.ctype = VAR_16;
VAR_9->vendor_len = 0;
VAR_0->rsp.status = VAR_13;
} else if (!AVRC_IsValidAvcType(VAR_6, VAR_9->hdr.ctype)) {
APPL_TRACE_DEBUG(""%s: Invalid pdu/ctype: 0x%x, %d"", VAR_14, VAR_6,
VAR_9->hdr.ctype);
VAR_3 = 0;
VAR_0->rsp.status = VAR_17;
} else {
switch (VAR_6) {
case VAR_18:
VAR_3 = 0;
VAR_5 = *(VAR_9->p_vendor_data + 4);
VAR_7 = VAR_9->p_vendor_data + 2;
VAR_0->get_caps.capability_id = VAR_5;
BE_STREAM_TO_UINT16(VAR_8, VAR_7);
if ((VAR_8 != 1) || (VAR_9->vendor_len != 5)) {
VAR_0->get_caps.status = VAR_19;
} else {
VAR_0->get_caps.status = VAR_20;
if (VAR_5 == VAR_21) {
*VAR_2 = VAR_22;
VAR_0->get_caps.count = VAR_23->num_co_ids;
memcpy(VAR_0->get_caps.param.company_id,
VAR_23->p_meta_co_ids,
(VAR_23->num_co_ids << 2));
} else if (VAR_5 == VAR_24) {
*VAR_2 = VAR_22;
VAR_0->get_caps.count = VAR_23->num_evt_ids;
memcpy(VAR_0->get_caps.param.event_id,
VAR_23->p_meta_evt_ids, VAR_23->num_evt_ids);
} else {
APPL_TRACE_DEBUG(""%s: Invalid capability ID: 0x%x"", VAR_14, VAR_5);
VAR_0->get_caps.status = VAR_13;
}
}
break;
case VAR_25:
VAR_0->rsp.status = bta_av_chk_notif_evt_id(VAR_9);
if (VAR_0->rsp.status != VAR_26) VAR_3 = 0;
break;
}
}
return VAR_3;
}",android/30cec963095366536ca0b1306089154e09bfe1a9/bta_av_act.cc/vul/before/0.json,"tBTA_AV_EVT bta_av_proc_meta_cmd(tAVRC_RESPONSE* p_rc_rsp,
                                 tBTA_AV_RC_MSG* p_msg, uint8_t* p_ctype) {
  tBTA_AV_EVT evt = BTA_AV_META_MSG_EVT;
  uint8_t u8, pdu, *p;
  uint16_t u16;
  tAVRC_MSG_VENDOR* p_vendor = &p_msg->msg.vendor;

  pdu = *(p_vendor->p_vendor_data);
  p_rc_rsp->pdu = pdu;
  *p_ctype = AVRC_RSP_REJ;

  /* Check to ansure a  valid minimum meta data length */
  if ((AVRC_MIN_META_CMD_LEN + p_vendor->vendor_len) > AVRC_META_CMD_BUF_SIZE) {
    /* reject it */
    p_rc_rsp->rsp.status = AVRC_STS_BAD_PARAM;
    APPL_TRACE_ERROR(""%s: Invalid meta-command length: %d"", __func__,
                     p_vendor->vendor_len);
    return 0;
  }

  /* Metadata messages only use PANEL sub-unit type */
  if (p_vendor->hdr.subunit_type != AVRC_SUB_PANEL) {
    APPL_TRACE_DEBUG(""%s: SUBUNIT must be PANEL"", __func__);
    /* reject it */
    evt = 0;
    p_vendor->hdr.ctype = AVRC_RSP_NOT_IMPL;
    p_vendor->vendor_len = 0;
    p_rc_rsp->rsp.status = AVRC_STS_BAD_PARAM;
  } else if (!AVRC_IsValidAvcType(pdu, p_vendor->hdr.ctype)) {
    APPL_TRACE_DEBUG(""%s: Invalid pdu/ctype: 0x%x, %d"", __func__, pdu,
                     p_vendor->hdr.ctype);
    /* reject invalid message without reporting to app */
    evt = 0;
    p_rc_rsp->rsp.status = AVRC_STS_BAD_CMD;
  } else {
    switch (pdu) {
      case AVRC_PDU_GET_CAPABILITIES:
        /* process GetCapabilities command without reporting the event to app */
        evt = 0;
        if (p_vendor->vendor_len != 5) {
          android_errorWriteLog(0x534e4554, ""111893951"");
          p_rc_rsp->get_caps.status = AVRC_STS_INTERNAL_ERR;
          break;
        }
        u8 = *(p_vendor->p_vendor_data + 4);
        p = p_vendor->p_vendor_data + 2;
        p_rc_rsp->get_caps.capability_id = u8;
        BE_STREAM_TO_UINT16(u16, p);
        if (u16 != 1) {
          p_rc_rsp->get_caps.status = AVRC_STS_INTERNAL_ERR;
        } else {
          p_rc_rsp->get_caps.status = AVRC_STS_NO_ERROR;
          if (u8 == AVRC_CAP_COMPANY_ID) {
            *p_ctype = AVRC_RSP_IMPL_STBL;
            p_rc_rsp->get_caps.count = p_bta_av_cfg->num_co_ids;
            memcpy(p_rc_rsp->get_caps.param.company_id,
                   p_bta_av_cfg->p_meta_co_ids,
                   (p_bta_av_cfg->num_co_ids << 2));
          } else if (u8 == AVRC_CAP_EVENTS_SUPPORTED) {
            *p_ctype = AVRC_RSP_IMPL_STBL;
            p_rc_rsp->get_caps.count = p_bta_av_cfg->num_evt_ids;
            memcpy(p_rc_rsp->get_caps.param.event_id,
                   p_bta_av_cfg->p_meta_evt_ids, p_bta_av_cfg->num_evt_ids);
          } else {
            APPL_TRACE_DEBUG(""%s: Invalid capability ID: 0x%x"", __func__, u8);
            /* reject - unknown capability ID */
            p_rc_rsp->get_caps.status = AVRC_STS_BAD_PARAM;
          }
        }
        break;

      case AVRC_PDU_REGISTER_NOTIFICATION:
        /* make sure the event_id is implemented */
        p_rc_rsp->rsp.status = bta_av_chk_notif_evt_id(p_vendor);
        if (p_rc_rsp->rsp.status != BTA_AV_STS_NO_RSP) evt = 0;
        break;
    }
  }

  return evt;
}","tBTA_AV_EVT bta_av_proc_meta_cmd(tAVRC_RESPONSE* VAR_0,
                                 tBTA_AV_RC_MSG* VAR_1, uint8_t* VAR_2) {
  tBTA_AV_EVT VAR_3 = VAR_4;
  uint8_t VAR_5, VAR_6, *VAR_7;
  uint16_t VAR_8;
  tAVRC_MSG_VENDOR* VAR_9 = &VAR_1->msg.vendor;

  VAR_6 = *(VAR_9->p_vendor_data);
  VAR_0->pdu = VAR_6;
  *VAR_2 = VAR_10;

  /* COMMENT_0 */
  if ((VAR_11 + VAR_9->vendor_len) > VAR_12) {
    /* COMMENT_1 */
    VAR_0->rsp.status = VAR_13;
    APPL_TRACE_ERROR(""%s: Invalid meta-command length: %d"", VAR_14,
                     VAR_9->vendor_len);
    return 0;
  }

  /* COMMENT_2 */
  if (VAR_9->hdr.subunit_type != VAR_15) {
    APPL_TRACE_DEBUG(""%s: SUBUNIT must be PANEL"", VAR_14);
    /* COMMENT_1 */
    VAR_3 = 0;
    VAR_9->hdr.ctype = VAR_16;
    VAR_9->vendor_len = 0;
    VAR_0->rsp.status = VAR_13;
  } else if (!AVRC_IsValidAvcType(VAR_6, VAR_9->hdr.ctype)) {
    APPL_TRACE_DEBUG(""%s: Invalid pdu/ctype: 0x%x, %d"", VAR_14, VAR_6,
                     VAR_9->hdr.ctype);
    /* COMMENT_3 */
    VAR_3 = 0;
    VAR_0->rsp.status = VAR_17;
  } else {
    switch (VAR_6) {
      case VAR_18:
        /* COMMENT_4 */
        VAR_3 = 0;
        if (VAR_9->vendor_len != 5) {
          android_errorWriteLog(0x534e4554, ""111893951"");
          VAR_0->get_caps.status = VAR_19;
          break;
        }
        VAR_5 = *(VAR_9->p_vendor_data + 4);
        VAR_7 = VAR_9->p_vendor_data + 2;
        VAR_0->get_caps.capability_id = VAR_5;
        BE_STREAM_TO_UINT16(VAR_8, VAR_7);
        if (VAR_8 != 1) {
          VAR_0->get_caps.status = VAR_19;
        } else {
          VAR_0->get_caps.status = VAR_20;
          if (VAR_5 == VAR_21) {
            *VAR_2 = VAR_22;
            VAR_0->get_caps.count = VAR_23->num_co_ids;
            memcpy(VAR_0->get_caps.param.company_id,
                   VAR_23->p_meta_co_ids,
                   (VAR_23->num_co_ids << 2));
          } else if (VAR_5 == VAR_24) {
            *VAR_2 = VAR_22;
            VAR_0->get_caps.count = VAR_23->num_evt_ids;
            memcpy(VAR_0->get_caps.param.event_id,
                   VAR_23->p_meta_evt_ids, VAR_23->num_evt_ids);
          } else {
            APPL_TRACE_DEBUG(""%s: Invalid capability ID: 0x%x"", VAR_14, VAR_5);
            /* COMMENT_5 */
            VAR_0->get_caps.status = VAR_13;
          }
        }
        break;

      case VAR_25:
        /* COMMENT_6 */
        VAR_0->rsp.status = bta_av_chk_notif_evt_id(VAR_9);
        if (VAR_0->rsp.status != VAR_26) VAR_3 = 0;
        break;
    }
  }

  return VAR_3;
}",android/30cec963095366536ca0b1306089154e09bfe1a9/bta_av_act.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -37,11 +37,16 @@
       case AVRC_PDU_GET_CAPABILITIES:
         /* process GetCapabilities command without reporting the event to app */
         evt = 0;
+        if (p_vendor->vendor_len != 5) {
+          android_errorWriteLog(0x534e4554, ""111893951"");
+          p_rc_rsp->get_caps.status = AVRC_STS_INTERNAL_ERR;
+          break;
+        }
         u8 = *(p_vendor->p_vendor_data + 4);
         p = p_vendor->p_vendor_data + 2;
         p_rc_rsp->get_caps.capability_id = u8;
         BE_STREAM_TO_UINT16(u16, p);
-        if ((u16 != 1) || (p_vendor->vendor_len != 5)) {
+        if (u16 != 1) {
           p_rc_rsp->get_caps.status = AVRC_STS_INTERNAL_ERR;
         } else {
           p_rc_rsp->get_caps.status = AVRC_STS_NO_ERROR;","{'deleted_lines': ['        if ((u16 != 1) || (p_vendor->vendor_len != 5)) {'], 'added_lines': ['        if (p_vendor->vendor_len != 5) {', '          android_errorWriteLog(0x534e4554, ""111893951"");', '          p_rc_rsp->get_caps.status = AVRC_STS_INTERNAL_ERR;', '          break;', '        }', '        if (u16 != 1) {']}",True,"In bta_av_proc_meta_cmd of bta_av_act.cc, there is a possible out of bounds read due to an incorrect bounds check. This could lead to remote information disclosure over Bluetooth with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111893951",6.5,MEDIUM,1,test,,5
CVE-2023-35666,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,android,"Fix potential abort in btu_av_act.cc

Partner analysis shows that bta_av_rc_msg does not respect handling
established for a null browse packet, instead dispatching the null
pointer to bta_av_rc_free_browse_msg.  Strictly speaking this does
not cause a UAF, as osi_free_and_reset will find the null and abort,
but it will lead to improper program termination.

Handle the case instead.

Bug: 269253349
Test: atest bluetooth_test_gd_unit
Tag: #security
Ignore-AOSP-First: Security
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:d3ee136851de30261e56c62fbb488541dc564b94)
Merged-In: I14dc4910476c733b246bcf7ff292afe9b7c0cc3d
Change-Id: I14dc4910476c733b246bcf7ff292afe9b7c0cc3d
",b7ea57f620436c83a9766f928437ddadaa232e3a,https://android.googlesource.com/platform/packages/modules/Bluetooth/+/b7ea57f620436c83a9766f928437ddadaa232e3a,system/bta/av/bta_av_act.cc,bta_av_rc_msg,"void bta_av_rc_msg(tBTA_AV_CB* p_cb, tBTA_AV_DATA* p_data) {
tBTA_AV_EVT evt = 0;
tBTA_AV av;
BT_HDR* p_pkt = NULL;
tAVRC_MSG_VENDOR* p_vendor = &p_data->rc_msg.msg.vendor;
bool is_inquiry = ((p_data->rc_msg.msg.hdr.ctype == AVRC_CMD_SPEC_INQ) ||
p_data->rc_msg.msg.hdr.ctype == AVRC_CMD_GEN_INQ);
uint8_t ctype = 0;
tAVRC_RESPONSE rc_rsp;
rc_rsp.rsp.status = BTA_AV_STS_NO_RSP;
if (NULL == p_data) {
APPL_TRACE_ERROR(""%s: Message from peer with no data"", __func__);
return;
}
APPL_TRACE_DEBUG(""%s: opcode=%x, ctype=%x"", __func__, p_data->rc_msg.opcode,
p_data->rc_msg.msg.hdr.ctype);
if (p_data->rc_msg.opcode == AVRC_OP_PASS_THRU) {
if ((p_data->rc_msg.msg.hdr.ctype == AVRC_CMD_CTRL) ||
(p_data->rc_msg.msg.hdr.ctype == AVRC_CMD_SPEC_INQ) ||
(p_data->rc_msg.msg.hdr.ctype == AVRC_CMD_GEN_INQ)) {
char avrcp_ct_support[PROPERTY_VALUE_MAX];
osi_property_get(""bluetooth.pts.avrcp_ct.support"", avrcp_ct_support,
""false"");
if (p_data->rc_msg.msg.pass.op_id == AVRC_ID_VENDOR) {
p_data->rc_msg.msg.hdr.ctype = AVRC_RSP_NOT_IMPL;
if (p_cb->features & BTA_AV_FEAT_METADATA)
p_data->rc_msg.msg.hdr.ctype = bta_av_group_navi_supported(
p_data->rc_msg.msg.pass.pass_len,
p_data->rc_msg.msg.pass.p_pass_data, is_inquiry);
} else if (((p_data->rc_msg.msg.pass.op_id == AVRC_ID_VOL_UP) ||
(p_data->rc_msg.msg.pass.op_id == AVRC_ID_VOL_DOWN)) &&
!strcmp(avrcp_ct_support, ""true"")) {
p_data->rc_msg.msg.hdr.ctype = AVRC_RSP_ACCEPT;
} else {
p_data->rc_msg.msg.hdr.ctype =
bta_av_op_supported(p_data->rc_msg.msg.pass.op_id, is_inquiry);
}
APPL_TRACE_DEBUG(""%s: ctype %d"", __func__, p_data->rc_msg.msg.hdr.ctype)
if (p_data->rc_msg.msg.hdr.ctype != AVRC_RSP_INTERIM)
AVRC_PassRsp(p_data->rc_msg.handle, p_data->rc_msg.label,
&p_data->rc_msg.msg.pass);
if (p_data->rc_msg.msg.hdr.ctype == AVRC_RSP_ACCEPT ||
p_data->rc_msg.msg.hdr.ctype == AVRC_RSP_INTERIM) {
evt = BTA_AV_REMOTE_CMD_EVT;
av.remote_cmd.rc_id = p_data->rc_msg.msg.pass.op_id;
av.remote_cmd.key_state = p_data->rc_msg.msg.pass.state;
av.remote_cmd.p_data = p_data->rc_msg.msg.pass.p_pass_data;
av.remote_cmd.len = p_data->rc_msg.msg.pass.pass_len;
memcpy(&av.remote_cmd.hdr, &p_data->rc_msg.msg.hdr, sizeof(tAVRC_HDR));
av.remote_cmd.label = p_data->rc_msg.label;
}
}
else if (p_data->rc_msg.msg.hdr.ctype >= AVRC_RSP_NOT_IMPL) {
evt = BTA_AV_REMOTE_RSP_EVT;
av.remote_rsp.rc_id = p_data->rc_msg.msg.pass.op_id;
av.remote_rsp.key_state = p_data->rc_msg.msg.pass.state;
av.remote_rsp.rsp_code = p_data->rc_msg.msg.hdr.ctype;
av.remote_rsp.label = p_data->rc_msg.label;
if ((p_data->rc_msg.msg.pass.op_id == AVRC_ID_VENDOR) &&
(p_data->rc_msg.msg.pass.pass_len > 0)) {
av.remote_rsp.p_data =
(uint8_t*)osi_malloc(p_data->rc_msg.msg.pass.pass_len);
APPL_TRACE_DEBUG(""%s: Vendor Unique data len = %d"", __func__,
p_data->rc_msg.msg.pass.pass_len);
memcpy(av.remote_rsp.p_data, p_data->rc_msg.msg.pass.p_pass_data,
p_data->rc_msg.msg.pass.pass_len);
}
}
else {
p_data->rc_msg.msg.hdr.ctype = AVRC_RSP_REJ;
AVRC_PassRsp(p_data->rc_msg.handle, p_data->rc_msg.label,
&p_data->rc_msg.msg.pass);
}
}
else if (p_data->rc_msg.opcode == AVRC_OP_VENDOR) {
av.vendor_cmd.code = p_data->rc_msg.msg.hdr.ctype;
av.vendor_cmd.company_id = p_vendor->company_id;
av.vendor_cmd.label = p_data->rc_msg.label;
av.vendor_cmd.p_data = p_vendor->p_vendor_data;
av.vendor_cmd.len = p_vendor->vendor_len;
if ((p_cb->features & BTA_AV_FEAT_VENDOR) &&
p_data->rc_msg.msg.hdr.ctype <= AVRC_CMD_GEN_INQ) {
if ((p_cb->features & BTA_AV_FEAT_METADATA) &&
(p_vendor->company_id == AVRC_CO_METADATA)) {
av.meta_msg.p_msg = &p_data->rc_msg.msg;
rc_rsp.rsp.status = BTA_AV_STS_NO_RSP;
evt = bta_av_proc_meta_cmd(&rc_rsp, &p_data->rc_msg, &ctype);
} else {
evt = BTA_AV_VENDOR_CMD_EVT;
}
} else if ((p_cb->features & BTA_AV_FEAT_VENDOR) &&
p_data->rc_msg.msg.hdr.ctype >= AVRC_RSP_NOT_IMPL) {
if ((p_cb->features & BTA_AV_FEAT_METADATA) &&
(p_vendor->company_id == AVRC_CO_METADATA)) {
av.meta_msg.p_msg = &p_data->rc_msg.msg;
evt = BTA_AV_META_MSG_EVT;
} else {
evt = BTA_AV_VENDOR_RSP_EVT;
}
} else if (!(p_cb->features & BTA_AV_FEAT_VENDOR) &&
p_data->rc_msg.msg.hdr.ctype <= AVRC_CMD_GEN_INQ) {
if (p_data->rc_msg.msg.vendor.p_vendor_data[0] == AVRC_PDU_INVALID) {
p_data->rc_msg.msg.hdr.ctype = AVRC_RSP_REJ;
p_data->rc_msg.msg.vendor.p_vendor_data[4] = AVRC_STS_BAD_CMD;
} else {
p_data->rc_msg.msg.hdr.ctype = AVRC_RSP_NOT_IMPL;
}
AVRC_VendorRsp(p_data->rc_msg.handle, p_data->rc_msg.label,
&p_data->rc_msg.msg.vendor);
}
} else if (p_data->rc_msg.opcode == AVRC_OP_BROWSE) {
av.meta_msg.rc_handle = p_data->rc_msg.handle;
av.meta_msg.company_id = p_vendor->company_id;
av.meta_msg.code = p_data->rc_msg.msg.hdr.ctype;
av.meta_msg.label = p_data->rc_msg.label;
av.meta_msg.p_msg = &p_data->rc_msg.msg;
av.meta_msg.p_data = p_data->rc_msg.msg.browse.p_browse_data;
av.meta_msg.len = p_data->rc_msg.msg.browse.browse_len;
evt = BTA_AV_META_MSG_EVT;
}
if (evt == 0 && rc_rsp.rsp.status != BTA_AV_STS_NO_RSP) {
if (!p_pkt) {
rc_rsp.rsp.opcode = p_data->rc_msg.opcode;
AVRC_BldResponse(0, &rc_rsp, &p_pkt);
}
if (p_pkt)
AVRC_MsgReq(p_data->rc_msg.handle, p_data->rc_msg.label, ctype, p_pkt);
}
if (evt != 0) {
av.remote_cmd.rc_handle = p_data->rc_msg.handle;
(*p_cb->p_cback)(evt, &av);
bta_av_rc_free_browse_msg(p_cb, p_data);
}
}","void bta_av_rc_msg(tBTA_AV_CB* VAR_0, tBTA_AV_DATA* VAR_1) {
tBTA_AV_EVT VAR_2 = 0;
tBTA_AV VAR_3;
BT_HDR* VAR_4 = NULL;
tAVRC_MSG_VENDOR* VAR_5 = &VAR_1->rc_msg.msg.vendor;
bool VAR_6 = ((VAR_1->rc_msg.msg.hdr.ctype == VAR_7) ||
VAR_1->rc_msg.msg.hdr.ctype == VAR_8);
uint8_t VAR_9 = 0;
tAVRC_RESPONSE VAR_10;
VAR_10.rsp.status = VAR_11;
if (NULL == VAR_1) {
APPL_TRACE_ERROR(""%s: Message from peer with no data"", VAR_12);
return;
}
APPL_TRACE_DEBUG(""%s: opcode=%x, ctype=%x"", VAR_12, VAR_1->rc_msg.opcode,
VAR_1->rc_msg.msg.hdr.ctype);
if (VAR_1->rc_msg.opcode == VAR_13) {
if ((VAR_1->rc_msg.msg.hdr.ctype == VAR_14) ||
(VAR_1->rc_msg.msg.hdr.ctype == VAR_7) ||
(VAR_1->rc_msg.msg.hdr.ctype == VAR_8)) {
char VAR_15[VAR_16];
osi_property_get(""bluetooth.pts.avrcp_ct.support"", VAR_15,
""false"");
if (VAR_1->rc_msg.msg.pass.op_id == VAR_17) {
VAR_1->rc_msg.msg.hdr.ctype = VAR_18;
if (VAR_0->features & VAR_19)
VAR_1->rc_msg.msg.hdr.ctype = bta_av_group_navi_supported(
VAR_1->rc_msg.msg.pass.pass_len,
VAR_1->rc_msg.msg.pass.p_pass_data, VAR_6);
} else if (((VAR_1->rc_msg.msg.pass.op_id == VAR_20) ||
(VAR_1->rc_msg.msg.pass.op_id == VAR_21)) &&
!strcmp(VAR_15, ""true"")) {
VAR_1->rc_msg.msg.hdr.ctype = VAR_22;
} else {
VAR_1->rc_msg.msg.hdr.ctype =
bta_av_op_supported(VAR_1->rc_msg.msg.pass.op_id, VAR_6);
}
APPL_TRACE_DEBUG(""%s: ctype %d"", VAR_12, VAR_1->rc_msg.msg.hdr.ctype)
if (VAR_1->rc_msg.msg.hdr.ctype != VAR_23)
AVRC_PassRsp(VAR_1->rc_msg.handle, VAR_1->rc_msg.label,
&VAR_1->rc_msg.msg.pass);
if (VAR_1->rc_msg.msg.hdr.ctype == VAR_22 ||
VAR_1->rc_msg.msg.hdr.ctype == VAR_23) {
VAR_2 = VAR_24;
VAR_3.remote_cmd.rc_id = VAR_1->rc_msg.msg.pass.op_id;
VAR_3.remote_cmd.key_state = VAR_1->rc_msg.msg.pass.state;
VAR_3.remote_cmd.p_data = VAR_1->rc_msg.msg.pass.p_pass_data;
VAR_3.remote_cmd.len = VAR_1->rc_msg.msg.pass.pass_len;
memcpy(&VAR_3.remote_cmd.hdr, &VAR_1->rc_msg.msg.hdr, sizeof(VAR_25));
VAR_3.remote_cmd.label = VAR_1->rc_msg.label;
}
}
else if (VAR_1->rc_msg.msg.hdr.ctype >= VAR_18) {
VAR_2 = VAR_26;
VAR_3.remote_rsp.rc_id = VAR_1->rc_msg.msg.pass.op_id;
VAR_3.remote_rsp.key_state = VAR_1->rc_msg.msg.pass.state;
VAR_3.remote_rsp.rsp_code = VAR_1->rc_msg.msg.hdr.ctype;
VAR_3.remote_rsp.label = VAR_1->rc_msg.label;
if ((VAR_1->rc_msg.msg.pass.op_id == VAR_17) &&
(VAR_1->rc_msg.msg.pass.pass_len > 0)) {
VAR_3.remote_rsp.p_data =
(uint8_t*)osi_malloc(VAR_1->rc_msg.msg.pass.pass_len);
APPL_TRACE_DEBUG(""%s: Vendor Unique data len = %d"", VAR_12,
VAR_1->rc_msg.msg.pass.pass_len);
memcpy(VAR_3.remote_rsp.p_data, VAR_1->rc_msg.msg.pass.p_pass_data,
VAR_1->rc_msg.msg.pass.pass_len);
}
}
else {
VAR_1->rc_msg.msg.hdr.ctype = VAR_27;
AVRC_PassRsp(VAR_1->rc_msg.handle, VAR_1->rc_msg.label,
&VAR_1->rc_msg.msg.pass);
}
}
else if (VAR_1->rc_msg.opcode == VAR_28) {
VAR_3.vendor_cmd.code = VAR_1->rc_msg.msg.hdr.ctype;
VAR_3.vendor_cmd.company_id = VAR_5->company_id;
VAR_3.vendor_cmd.label = VAR_1->rc_msg.label;
VAR_3.vendor_cmd.p_data = VAR_5->p_vendor_data;
VAR_3.vendor_cmd.len = VAR_5->vendor_len;
if ((VAR_0->features & VAR_29) &&
VAR_1->rc_msg.msg.hdr.ctype <= VAR_8) {
if ((VAR_0->features & VAR_19) &&
(VAR_5->company_id == VAR_30)) {
VAR_3.meta_msg.p_msg = &VAR_1->rc_msg.msg;
VAR_10.rsp.status = VAR_11;
VAR_2 = bta_av_proc_meta_cmd(&VAR_10, &VAR_1->rc_msg, &VAR_9);
} else {
VAR_2 = VAR_31;
}
} else if ((VAR_0->features & VAR_29) &&
VAR_1->rc_msg.msg.hdr.ctype >= VAR_18) {
if ((VAR_0->features & VAR_19) &&
(VAR_5->company_id == VAR_30)) {
VAR_3.meta_msg.p_msg = &VAR_1->rc_msg.msg;
VAR_2 = VAR_32;
} else {
VAR_2 = VAR_33;
}
} else if (!(VAR_0->features & VAR_29) &&
VAR_1->rc_msg.msg.hdr.ctype <= VAR_8) {
if (VAR_1->rc_msg.msg.vendor.p_vendor_data[0] == VAR_34) {
VAR_1->rc_msg.msg.hdr.ctype = VAR_27;
VAR_1->rc_msg.msg.vendor.p_vendor_data[4] = VAR_35;
} else {
VAR_1->rc_msg.msg.hdr.ctype = VAR_18;
}
AVRC_VendorRsp(VAR_1->rc_msg.handle, VAR_1->rc_msg.label,
&VAR_1->rc_msg.msg.vendor);
}
} else if (VAR_1->rc_msg.opcode == VAR_36) {
VAR_3.meta_msg.rc_handle = VAR_1->rc_msg.handle;
VAR_3.meta_msg.company_id = VAR_5->company_id;
VAR_3.meta_msg.code = VAR_1->rc_msg.msg.hdr.ctype;
VAR_3.meta_msg.label = VAR_1->rc_msg.label;
VAR_3.meta_msg.p_msg = &VAR_1->rc_msg.msg;
VAR_3.meta_msg.p_data = VAR_1->rc_msg.msg.browse.p_browse_data;
VAR_3.meta_msg.len = VAR_1->rc_msg.msg.browse.browse_len;
VAR_2 = VAR_32;
}
if (VAR_2 == 0 && VAR_10.rsp.status != VAR_11) {
if (!VAR_4) {
VAR_10.rsp.opcode = VAR_1->rc_msg.opcode;
AVRC_BldResponse(0, &VAR_10, &VAR_4);
}
if (VAR_4)
AVRC_MsgReq(VAR_1->rc_msg.handle, VAR_1->rc_msg.label, VAR_9, VAR_4);
}
if (VAR_2 != 0) {
VAR_3.remote_cmd.rc_handle = VAR_1->rc_msg.handle;
(*VAR_0->p_cback)(VAR_2, &VAR_3);
bta_av_rc_free_browse_msg(VAR_0, VAR_1);
}
}",android/b7ea57f620436c83a9766f928437ddadaa232e3a/bta_av_act.cc/vul/before/0.json,"void bta_av_rc_msg(tBTA_AV_CB* p_cb, tBTA_AV_DATA* p_data) {
  tBTA_AV_EVT evt = 0;
  tBTA_AV av;
  BT_HDR* p_pkt = NULL;
  tAVRC_MSG_VENDOR* p_vendor = &p_data->rc_msg.msg.vendor;
  bool is_inquiry = ((p_data->rc_msg.msg.hdr.ctype == AVRC_CMD_SPEC_INQ) ||
                     p_data->rc_msg.msg.hdr.ctype == AVRC_CMD_GEN_INQ);
  uint8_t ctype = 0;
  tAVRC_RESPONSE rc_rsp;

  rc_rsp.rsp.status = BTA_AV_STS_NO_RSP;

  if (NULL == p_data) {
    APPL_TRACE_ERROR(""%s: Message from peer with no data"", __func__);
    return;
  }

  APPL_TRACE_DEBUG(""%s: opcode=%x, ctype=%x"", __func__, p_data->rc_msg.opcode,
                   p_data->rc_msg.msg.hdr.ctype);

  if (p_data->rc_msg.opcode == AVRC_OP_PASS_THRU) {
    /* if this is a pass thru command */
    if ((p_data->rc_msg.msg.hdr.ctype == AVRC_CMD_CTRL) ||
        (p_data->rc_msg.msg.hdr.ctype == AVRC_CMD_SPEC_INQ) ||
        (p_data->rc_msg.msg.hdr.ctype == AVRC_CMD_GEN_INQ)) {
      /* check if operation is supported */
      char avrcp_ct_support[PROPERTY_VALUE_MAX];
      osi_property_get(""bluetooth.pts.avrcp_ct.support"", avrcp_ct_support,
                       ""false"");
      if (p_data->rc_msg.msg.pass.op_id == AVRC_ID_VENDOR) {
        p_data->rc_msg.msg.hdr.ctype = AVRC_RSP_NOT_IMPL;
        if (p_cb->features & BTA_AV_FEAT_METADATA)
          p_data->rc_msg.msg.hdr.ctype = bta_av_group_navi_supported(
              p_data->rc_msg.msg.pass.pass_len,
              p_data->rc_msg.msg.pass.p_pass_data, is_inquiry);
      } else if (((p_data->rc_msg.msg.pass.op_id == AVRC_ID_VOL_UP) ||
                  (p_data->rc_msg.msg.pass.op_id == AVRC_ID_VOL_DOWN)) &&
                 !strcmp(avrcp_ct_support, ""true"")) {
        p_data->rc_msg.msg.hdr.ctype = AVRC_RSP_ACCEPT;
      } else {
        p_data->rc_msg.msg.hdr.ctype =
            bta_av_op_supported(p_data->rc_msg.msg.pass.op_id, is_inquiry);
      }

      APPL_TRACE_DEBUG(""%s: ctype %d"", __func__, p_data->rc_msg.msg.hdr.ctype)

      /* send response */
      if (p_data->rc_msg.msg.hdr.ctype != AVRC_RSP_INTERIM)
        AVRC_PassRsp(p_data->rc_msg.handle, p_data->rc_msg.label,
                     &p_data->rc_msg.msg.pass);

      /* set up for callback if supported */
      if (p_data->rc_msg.msg.hdr.ctype == AVRC_RSP_ACCEPT ||
          p_data->rc_msg.msg.hdr.ctype == AVRC_RSP_INTERIM) {
        evt = BTA_AV_REMOTE_CMD_EVT;
        av.remote_cmd.rc_id = p_data->rc_msg.msg.pass.op_id;
        av.remote_cmd.key_state = p_data->rc_msg.msg.pass.state;
        av.remote_cmd.p_data = p_data->rc_msg.msg.pass.p_pass_data;
        av.remote_cmd.len = p_data->rc_msg.msg.pass.pass_len;
        memcpy(&av.remote_cmd.hdr, &p_data->rc_msg.msg.hdr, sizeof(tAVRC_HDR));
        av.remote_cmd.label = p_data->rc_msg.label;
      }
    }
    /* else if this is a pass thru response */
    /* id response type is not impl, we have to release label */
    else if (p_data->rc_msg.msg.hdr.ctype >= AVRC_RSP_NOT_IMPL) {
      /* set up for callback */
      evt = BTA_AV_REMOTE_RSP_EVT;
      av.remote_rsp.rc_id = p_data->rc_msg.msg.pass.op_id;
      av.remote_rsp.key_state = p_data->rc_msg.msg.pass.state;
      av.remote_rsp.rsp_code = p_data->rc_msg.msg.hdr.ctype;
      av.remote_rsp.label = p_data->rc_msg.label;

      /* If this response is for vendor unique command  */
      if ((p_data->rc_msg.msg.pass.op_id == AVRC_ID_VENDOR) &&
          (p_data->rc_msg.msg.pass.pass_len > 0)) {
        av.remote_rsp.p_data =
            (uint8_t*)osi_malloc(p_data->rc_msg.msg.pass.pass_len);
        APPL_TRACE_DEBUG(""%s: Vendor Unique data len = %d"", __func__,
                         p_data->rc_msg.msg.pass.pass_len);
        memcpy(av.remote_rsp.p_data, p_data->rc_msg.msg.pass.p_pass_data,
               p_data->rc_msg.msg.pass.pass_len);
      }
    }
    /* must be a bad ctype -> reject*/
    else {
      p_data->rc_msg.msg.hdr.ctype = AVRC_RSP_REJ;
      AVRC_PassRsp(p_data->rc_msg.handle, p_data->rc_msg.label,
                   &p_data->rc_msg.msg.pass);
    }
  }
  /* else if this is a vendor specific command or response */
  else if (p_data->rc_msg.opcode == AVRC_OP_VENDOR) {
    /* set up for callback */
    av.vendor_cmd.code = p_data->rc_msg.msg.hdr.ctype;
    av.vendor_cmd.company_id = p_vendor->company_id;
    av.vendor_cmd.label = p_data->rc_msg.label;
    av.vendor_cmd.p_data = p_vendor->p_vendor_data;
    av.vendor_cmd.len = p_vendor->vendor_len;

    /* if configured to support vendor specific and it's a command */
    if ((p_cb->features & BTA_AV_FEAT_VENDOR) &&
        p_data->rc_msg.msg.hdr.ctype <= AVRC_CMD_GEN_INQ) {
      if ((p_cb->features & BTA_AV_FEAT_METADATA) &&
          (p_vendor->company_id == AVRC_CO_METADATA)) {
        av.meta_msg.p_msg = &p_data->rc_msg.msg;
        rc_rsp.rsp.status = BTA_AV_STS_NO_RSP;
        evt = bta_av_proc_meta_cmd(&rc_rsp, &p_data->rc_msg, &ctype);
      } else {
        evt = BTA_AV_VENDOR_CMD_EVT;
      }
    } else if ((p_cb->features & BTA_AV_FEAT_VENDOR) &&
               p_data->rc_msg.msg.hdr.ctype >= AVRC_RSP_NOT_IMPL) {
      /* else if configured to support vendor specific and it's a response */
      if ((p_cb->features & BTA_AV_FEAT_METADATA) &&
          (p_vendor->company_id == AVRC_CO_METADATA)) {
        av.meta_msg.p_msg = &p_data->rc_msg.msg;
        evt = BTA_AV_META_MSG_EVT;
      } else {
        evt = BTA_AV_VENDOR_RSP_EVT;
      }
    } else if (!(p_cb->features & BTA_AV_FEAT_VENDOR) &&
               p_data->rc_msg.msg.hdr.ctype <= AVRC_CMD_GEN_INQ) {
      /* else if not configured to support vendor specific and it's a command */
      if (p_data->rc_msg.msg.vendor.p_vendor_data[0] == AVRC_PDU_INVALID) {
        /* reject it */
        p_data->rc_msg.msg.hdr.ctype = AVRC_RSP_REJ;
        p_data->rc_msg.msg.vendor.p_vendor_data[4] = AVRC_STS_BAD_CMD;
      } else {
        p_data->rc_msg.msg.hdr.ctype = AVRC_RSP_NOT_IMPL;
      }
      AVRC_VendorRsp(p_data->rc_msg.handle, p_data->rc_msg.label,
                     &p_data->rc_msg.msg.vendor);
    }
  } else if (p_data->rc_msg.opcode == AVRC_OP_BROWSE) {
    /* set up for callback */
    av.meta_msg.rc_handle = p_data->rc_msg.handle;
    av.meta_msg.company_id = p_vendor->company_id;
    av.meta_msg.code = p_data->rc_msg.msg.hdr.ctype;
    av.meta_msg.label = p_data->rc_msg.label;
    av.meta_msg.p_msg = &p_data->rc_msg.msg;
    av.meta_msg.p_data = p_data->rc_msg.msg.browse.p_browse_data;
    av.meta_msg.len = p_data->rc_msg.msg.browse.browse_len;
    evt = BTA_AV_META_MSG_EVT;
  }

  if (evt == 0 && rc_rsp.rsp.status != BTA_AV_STS_NO_RSP) {
    if (!p_pkt) {
      rc_rsp.rsp.opcode = p_data->rc_msg.opcode;
      AVRC_BldResponse(0, &rc_rsp, &p_pkt);
    }
    if (p_pkt)
      AVRC_MsgReq(p_data->rc_msg.handle, p_data->rc_msg.label, ctype, p_pkt);
  }

  /* call callback */
  if (evt != 0) {
    av.remote_cmd.rc_handle = p_data->rc_msg.handle;
    (*p_cb->p_cback)(evt, &av);
    /* If browsing message, then free the browse message buffer */
    if (p_data->rc_msg.opcode == AVRC_OP_BROWSE &&
        p_data->rc_msg.msg.browse.p_browse_pkt != NULL) {
      bta_av_rc_free_browse_msg(p_cb, p_data);
    }
  }
}","void bta_av_rc_msg(tBTA_AV_CB* VAR_0, tBTA_AV_DATA* VAR_1) {
  tBTA_AV_EVT VAR_2 = 0;
  tBTA_AV VAR_3;
  BT_HDR* VAR_4 = NULL;
  tAVRC_MSG_VENDOR* VAR_5 = &VAR_1->rc_msg.msg.vendor;
  bool VAR_6 = ((VAR_1->rc_msg.msg.hdr.ctype == VAR_7) ||
                     VAR_1->rc_msg.msg.hdr.ctype == VAR_8);
  uint8_t VAR_9 = 0;
  tAVRC_RESPONSE VAR_10;

  VAR_10.rsp.status = VAR_11;

  if (NULL == VAR_1) {
    APPL_TRACE_ERROR(""%s: Message from peer with no data"", VAR_12);
    return;
  }

  APPL_TRACE_DEBUG(""%s: opcode=%x, ctype=%x"", VAR_12, VAR_1->rc_msg.opcode,
                   VAR_1->rc_msg.msg.hdr.ctype);

  if (VAR_1->rc_msg.opcode == VAR_13) {
    /* COMMENT_0 */
    if ((VAR_1->rc_msg.msg.hdr.ctype == VAR_14) ||
        (VAR_1->rc_msg.msg.hdr.ctype == VAR_7) ||
        (VAR_1->rc_msg.msg.hdr.ctype == VAR_8)) {
      /* COMMENT_1 */
      char VAR_15[VAR_16];
      osi_property_get(""bluetooth.pts.avrcp_ct.support"", VAR_15,
                       ""false"");
      if (VAR_1->rc_msg.msg.pass.op_id == VAR_17) {
        VAR_1->rc_msg.msg.hdr.ctype = VAR_18;
        if (VAR_0->features & VAR_19)
          VAR_1->rc_msg.msg.hdr.ctype = bta_av_group_navi_supported(
              VAR_1->rc_msg.msg.pass.pass_len,
              VAR_1->rc_msg.msg.pass.p_pass_data, VAR_6);
      } else if (((VAR_1->rc_msg.msg.pass.op_id == VAR_20) ||
                  (VAR_1->rc_msg.msg.pass.op_id == VAR_21)) &&
                 !strcmp(VAR_15, ""true"")) {
        VAR_1->rc_msg.msg.hdr.ctype = VAR_22;
      } else {
        VAR_1->rc_msg.msg.hdr.ctype =
            bta_av_op_supported(VAR_1->rc_msg.msg.pass.op_id, VAR_6);
      }

      APPL_TRACE_DEBUG(""%s: ctype %d"", VAR_12, VAR_1->rc_msg.msg.hdr.ctype)

      /* COMMENT_2 */
      if (VAR_1->rc_msg.msg.hdr.ctype != VAR_23)
        AVRC_PassRsp(VAR_1->rc_msg.handle, VAR_1->rc_msg.label,
                     &VAR_1->rc_msg.msg.pass);

      /* COMMENT_3 */
      if (VAR_1->rc_msg.msg.hdr.ctype == VAR_22 ||
          VAR_1->rc_msg.msg.hdr.ctype == VAR_23) {
        VAR_2 = VAR_24;
        VAR_3.remote_cmd.rc_id = VAR_1->rc_msg.msg.pass.op_id;
        VAR_3.remote_cmd.key_state = VAR_1->rc_msg.msg.pass.state;
        VAR_3.remote_cmd.p_data = VAR_1->rc_msg.msg.pass.p_pass_data;
        VAR_3.remote_cmd.len = VAR_1->rc_msg.msg.pass.pass_len;
        memcpy(&VAR_3.remote_cmd.hdr, &VAR_1->rc_msg.msg.hdr, sizeof(VAR_25));
        VAR_3.remote_cmd.label = VAR_1->rc_msg.label;
      }
    }
    /* COMMENT_4 */
    /* COMMENT_5 */
    else if (VAR_1->rc_msg.msg.hdr.ctype >= VAR_18) {
      /* COMMENT_6 */
      VAR_2 = VAR_26;
      VAR_3.remote_rsp.rc_id = VAR_1->rc_msg.msg.pass.op_id;
      VAR_3.remote_rsp.key_state = VAR_1->rc_msg.msg.pass.state;
      VAR_3.remote_rsp.rsp_code = VAR_1->rc_msg.msg.hdr.ctype;
      VAR_3.remote_rsp.label = VAR_1->rc_msg.label;

      /* COMMENT_7 */
      if ((VAR_1->rc_msg.msg.pass.op_id == VAR_17) &&
          (VAR_1->rc_msg.msg.pass.pass_len > 0)) {
        VAR_3.remote_rsp.p_data =
            (uint8_t*)osi_malloc(VAR_1->rc_msg.msg.pass.pass_len);
        APPL_TRACE_DEBUG(""%s: Vendor Unique data len = %d"", VAR_12,
                         VAR_1->rc_msg.msg.pass.pass_len);
        memcpy(VAR_3.remote_rsp.p_data, VAR_1->rc_msg.msg.pass.p_pass_data,
               VAR_1->rc_msg.msg.pass.pass_len);
      }
    }
    /* COMMENT_8 */
    else {
      VAR_1->rc_msg.msg.hdr.ctype = VAR_27;
      AVRC_PassRsp(VAR_1->rc_msg.handle, VAR_1->rc_msg.label,
                   &VAR_1->rc_msg.msg.pass);
    }
  }
  /* COMMENT_9 */
  else if (VAR_1->rc_msg.opcode == VAR_28) {
    /* COMMENT_6 */
    VAR_3.vendor_cmd.code = VAR_1->rc_msg.msg.hdr.ctype;
    VAR_3.vendor_cmd.company_id = VAR_5->company_id;
    VAR_3.vendor_cmd.label = VAR_1->rc_msg.label;
    VAR_3.vendor_cmd.p_data = VAR_5->p_vendor_data;
    VAR_3.vendor_cmd.len = VAR_5->vendor_len;

    /* COMMENT_10 */
    if ((VAR_0->features & VAR_29) &&
        VAR_1->rc_msg.msg.hdr.ctype <= VAR_8) {
      if ((VAR_0->features & VAR_19) &&
          (VAR_5->company_id == VAR_30)) {
        VAR_3.meta_msg.p_msg = &VAR_1->rc_msg.msg;
        VAR_10.rsp.status = VAR_11;
        VAR_2 = bta_av_proc_meta_cmd(&VAR_10, &VAR_1->rc_msg, &VAR_9);
      } else {
        VAR_2 = VAR_31;
      }
    } else if ((VAR_0->features & VAR_29) &&
               VAR_1->rc_msg.msg.hdr.ctype >= VAR_18) {
      /* COMMENT_11 */
      if ((VAR_0->features & VAR_19) &&
          (VAR_5->company_id == VAR_30)) {
        VAR_3.meta_msg.p_msg = &VAR_1->rc_msg.msg;
        VAR_2 = VAR_32;
      } else {
        VAR_2 = VAR_33;
      }
    } else if (!(VAR_0->features & VAR_29) &&
               VAR_1->rc_msg.msg.hdr.ctype <= VAR_8) {
      /* COMMENT_12 */
      if (VAR_1->rc_msg.msg.vendor.p_vendor_data[0] == VAR_34) {
        /* COMMENT_13 */
        VAR_1->rc_msg.msg.hdr.ctype = VAR_27;
        VAR_1->rc_msg.msg.vendor.p_vendor_data[4] = VAR_35;
      } else {
        VAR_1->rc_msg.msg.hdr.ctype = VAR_18;
      }
      AVRC_VendorRsp(VAR_1->rc_msg.handle, VAR_1->rc_msg.label,
                     &VAR_1->rc_msg.msg.vendor);
    }
  } else if (VAR_1->rc_msg.opcode == VAR_36) {
    /* COMMENT_6 */
    VAR_3.meta_msg.rc_handle = VAR_1->rc_msg.handle;
    VAR_3.meta_msg.company_id = VAR_5->company_id;
    VAR_3.meta_msg.code = VAR_1->rc_msg.msg.hdr.ctype;
    VAR_3.meta_msg.label = VAR_1->rc_msg.label;
    VAR_3.meta_msg.p_msg = &VAR_1->rc_msg.msg;
    VAR_3.meta_msg.p_data = VAR_1->rc_msg.msg.browse.p_browse_data;
    VAR_3.meta_msg.len = VAR_1->rc_msg.msg.browse.browse_len;
    VAR_2 = VAR_32;
  }

  if (VAR_2 == 0 && VAR_10.rsp.status != VAR_11) {
    if (!VAR_4) {
      VAR_10.rsp.opcode = VAR_1->rc_msg.opcode;
      AVRC_BldResponse(0, &VAR_10, &VAR_4);
    }
    if (VAR_4)
      AVRC_MsgReq(VAR_1->rc_msg.handle, VAR_1->rc_msg.label, VAR_9, VAR_4);
  }

  /* COMMENT_14 */
  if (VAR_2 != 0) {
    VAR_3.remote_cmd.rc_handle = VAR_1->rc_msg.handle;
    (*VAR_0->p_cback)(VAR_2, &VAR_3);
    /* COMMENT_15 */
    if (VAR_1->rc_msg.opcode == VAR_36 &&
        VAR_1->rc_msg.msg.browse.p_browse_pkt != NULL) {
      bta_av_rc_free_browse_msg(VAR_0, VAR_1);
    }
  }
}",android/b7ea57f620436c83a9766f928437ddadaa232e3a/bta_av_act.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -158,6 +158,9 @@
     av.remote_cmd.rc_handle = p_data->rc_msg.handle;
     (*p_cb->p_cback)(evt, &av);
     /* If browsing message, then free the browse message buffer */
-    bta_av_rc_free_browse_msg(p_cb, p_data);
+    if (p_data->rc_msg.opcode == AVRC_OP_BROWSE &&
+        p_data->rc_msg.msg.browse.p_browse_pkt != NULL) {
+      bta_av_rc_free_browse_msg(p_cb, p_data);
+    }
   }
 }","{'deleted_lines': ['    bta_av_rc_free_browse_msg(p_cb, p_data);'], 'added_lines': ['    if (p_data->rc_msg.opcode == AVRC_OP_BROWSE &&', '        p_data->rc_msg.msg.browse.p_browse_pkt != NULL) {', '      bta_av_rc_free_browse_msg(p_cb, p_data);', '    }']}",True,"In bta_av_rc_msg of bta_av_act.cc, there is a possible use after free due to a logic error in the code. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.",7.8,HIGH,2,test,,5
CVE-2023-25585,['CWE-908'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,binutils-gdb,"
PR29892, Field file_table of struct module is uninitialized

	PR 29892
	* vms-alphs.c (new_module): Use bfd_zmalloc to alloc file_table.
	(parse_module): Rewrite file_table reallocation code and clear.
",65cf035b8dc1df5d8020e0b1449514a3c42933e7,https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=65cf035b8dc1df5d8020e0b1449514a3c42933e7,bfd/vms-alpha.c,new_module,"static struct module *
new_module (bfd *abfd)
{
struct module *module
= (struct module *) bfd_zalloc (abfd, sizeof (struct module));
module->file_table_count = 16; 
module->file_table
= bfd_malloc (module->file_table_count * sizeof (struct fileinfo));
return module;
}","static struct module *
new_module (bfd *VAR_0)
{
struct module *module
= (struct module *) bfd_zalloc (VAR_0, sizeof (struct module));
module->file_table_count = 16; 
module->file_table
= bfd_malloc (module->file_table_count * sizeof (struct fileinfo));
return module;
}",binutils-gdb/65cf035b8dc1df5d8020e0b1449514a3c42933e7/vms-alpha.c/vul/before/0.json,"static struct module *
new_module (bfd *abfd)
{
  struct module *module
    = (struct module *) bfd_zalloc (abfd, sizeof (struct module));
  module->file_table_count = 16; /* Arbitrary.  */
  module->file_table
    = bfd_zmalloc (module->file_table_count * sizeof (struct fileinfo));
  return module;
}","static struct module *
new_module (bfd *VAR_0)
{
  struct module *module
    = (struct module *) bfd_zalloc (VAR_0, sizeof (struct module));
  module->file_table_count = 16; /* COMMENT_0 */
  module->file_table
    = bfd_zmalloc (module->file_table_count * sizeof (struct fileinfo));
  return module;
}",binutils-gdb/65cf035b8dc1df5d8020e0b1449514a3c42933e7/vms-alpha.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,6 +5,6 @@
     = (struct module *) bfd_zalloc (abfd, sizeof (struct module));
   module->file_table_count = 16; /* Arbitrary.  */
   module->file_table
-    = bfd_malloc (module->file_table_count * sizeof (struct fileinfo));
+    = bfd_zmalloc (module->file_table_count * sizeof (struct fileinfo));
   return module;
 }","{'deleted_lines': ['    = bfd_malloc (module->file_table_count * sizeof (struct fileinfo));'], 'added_lines': ['    = bfd_zmalloc (module->file_table_count * sizeof (struct fileinfo));']}",True,A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.,4.7,MEDIUM,1,test,,5
CVE-2023-25585,['CWE-908'],CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H,1,binutils-gdb,"
PR29892, Field file_table of struct module is uninitialized

	PR 29892
	* vms-alphs.c (new_module): Use bfd_zmalloc to alloc file_table.
	(parse_module): Rewrite file_table reallocation code and clear.
",65cf035b8dc1df5d8020e0b1449514a3c42933e7,https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=65cf035b8dc1df5d8020e0b1449514a3c42933e7,bfd/vms-alpha.c,parse_module,"static bool
parse_module (bfd *abfd, struct module *module, unsigned char *ptr,
bfd_size_type length)
{
unsigned char *maxptr = ptr + length;
unsigned char *src_ptr, *pcl_ptr;
unsigned int prev_linum = 0, curr_linenum = 0;
bfd_vma prev_pc = 0, curr_pc = 0;
struct srecinfo *curr_srec, *srec;
struct lineinfo *curr_line, *line;
struct funcinfo *funcinfo;
curr_srec = (struct srecinfo *) bfd_zalloc (abfd, sizeof (struct srecinfo));
if (!curr_srec)
return false;
module->srec_table = curr_srec;
curr_line = (struct lineinfo *) bfd_zalloc (abfd, sizeof (struct lineinfo));
if (!curr_line)
return false;
module->line_table = curr_line;
while (ptr + 3 < maxptr)
{
int rec_length = bfd_getl16 (ptr) + 1;
int rec_type = bfd_getl16 (ptr + 2);
vms_debug2 ((2, ""DST record: leng %d, type %d\n"", rec_length, rec_type));
if (rec_length > maxptr - ptr)
break;
if (rec_type == DST__K_MODEND)
break;
switch (rec_type)
{
case DST__K_MODBEG:
if (rec_length <= DST_S_B_MODBEG_NAME)
break;
module->name
= _bfd_vms_save_counted_string (abfd, ptr + DST_S_B_MODBEG_NAME,
rec_length - DST_S_B_MODBEG_NAME);
curr_pc = 0;
prev_pc = 0;
curr_linenum = 0;
prev_linum = 0;
vms_debug2 ((3, ""module: %s\n"", module->name));
break;
case DST__K_MODEND:
break;
case DST__K_RTNBEG:
if (rec_length <= DST_S_B_RTNBEG_NAME)
break;
funcinfo = (struct funcinfo *)
bfd_zalloc (abfd, sizeof (struct funcinfo));
if (!funcinfo)
return false;
funcinfo->name
= _bfd_vms_save_counted_string (abfd, ptr + DST_S_B_RTNBEG_NAME,
rec_length - DST_S_B_RTNBEG_NAME);
funcinfo->low = bfd_getl32 (ptr + DST_S_L_RTNBEG_ADDRESS);
funcinfo->next = module->func_table;
module->func_table = funcinfo;
vms_debug2 ((3, ""routine: %s at 0x%lx\n"",
funcinfo->name, (unsigned long) funcinfo->low));
break;
case DST__K_RTNEND:
if (rec_length < DST_S_L_RTNEND_SIZE + 4)
break;
if (!module->func_table)
return false;
module->func_table->high = module->func_table->low
+ bfd_getl32 (ptr + DST_S_L_RTNEND_SIZE) - 1;
if (module->func_table->high > module->high)
module->high = module->func_table->high;
vms_debug2 ((3, ""end routine\n""));
break;
case DST__K_PROLOG:
vms_debug2 ((3, ""prologue\n""));
break;
case DST__K_EPILOG:
vms_debug2 ((3, ""epilog\n""));
break;
case DST__K_BLKBEG:
vms_debug2 ((3, ""block\n""));
break;
case DST__K_BLKEND:
vms_debug2 ((3, ""end block\n""));
break;
case DST__K_SOURCE:
src_ptr = ptr + DST_S_C_SOURCE_HEADER_SIZE;
vms_debug2 ((3, ""source info\n""));
while (src_ptr - ptr < rec_length)
{
int cmd = src_ptr[0], cmd_length, data;
switch (cmd)
{
case DST__K_SRC_DECLFILE:
if (src_ptr - ptr + DST_S_B_SRC_DF_LENGTH >= rec_length)
cmd_length = 0x10000;
else
cmd_length = src_ptr[DST_S_B_SRC_DF_LENGTH] + 2;
break;
case DST__K_SRC_DEFLINES_B:
cmd_length = 2;
break;
case DST__K_SRC_DEFLINES_W:
cmd_length = 3;
break;
case DST__K_SRC_INCRLNUM_B:
cmd_length = 2;
break;
case DST__K_SRC_SETFILE:
cmd_length = 3;
break;
case DST__K_SRC_SETLNUM_L:
cmd_length = 5;
break;
case DST__K_SRC_SETLNUM_W:
cmd_length = 3;
break;
case DST__K_SRC_SETREC_L:
cmd_length = 5;
break;
case DST__K_SRC_SETREC_W:
cmd_length = 3;
break;
case DST__K_SRC_FORMFEED:
cmd_length = 1;
break;
default:
cmd_length = 2;
break;
}
if (src_ptr - ptr + cmd_length > rec_length)
break;
switch (cmd)
{
case DST__K_SRC_DECLFILE:
{
unsigned int fileid
= bfd_getl16 (src_ptr + DST_S_W_SRC_DF_FILEID);
char *filename = _bfd_vms_save_counted_string
(abfd,
src_ptr + DST_S_B_SRC_DF_FILENAME,
ptr + rec_length - (src_ptr + DST_S_B_SRC_DF_FILENAME));
while (fileid >= module->file_table_count)
{
module->file_table_count *= 2;
module->file_table
= bfd_realloc_or_free (module->file_table,
module->file_table_count
* sizeof (struct fileinfo));
if (module->file_table == NULL)
return false;
}
module->file_table [fileid].name = filename;
module->file_table [fileid].srec = 1;
vms_debug2 ((4, ""DST_S_C_SRC_DECLFILE: %d, %s\n"",
fileid, module->file_table [fileid].name));
}
break;
case DST__K_SRC_DEFLINES_B:
data = src_ptr[DST_S_B_SRC_UNSBYTE];
srec = (struct srecinfo *)
bfd_zalloc (abfd, sizeof (struct srecinfo));
srec->line = curr_srec->line + data;
srec->srec = curr_srec->srec + data;
srec->sfile = curr_srec->sfile;
curr_srec->next = srec;
curr_srec = srec;
vms_debug2 ((4, ""DST_S_C_SRC_DEFLINES_B: %d\n"", data));
break;
case DST__K_SRC_DEFLINES_W:
data = bfd_getl16 (src_ptr + DST_S_W_SRC_UNSWORD);
srec = (struct srecinfo *)
bfd_zalloc (abfd, sizeof (struct srecinfo));
srec->line = curr_srec->line + data;
srec->srec = curr_srec->srec + data,
srec->sfile = curr_srec->sfile;
curr_srec->next = srec;
curr_srec = srec;
vms_debug2 ((4, ""DST_S_C_SRC_DEFLINES_W: %d\n"", data));
break;
case DST__K_SRC_INCRLNUM_B:
data = src_ptr[DST_S_B_SRC_UNSBYTE];
curr_srec->line += data;
vms_debug2 ((4, ""DST_S_C_SRC_INCRLNUM_B: %d\n"", data));
break;
case DST__K_SRC_SETFILE:
data = bfd_getl16 (src_ptr + DST_S_W_SRC_UNSWORD);
curr_srec->sfile = data;
curr_srec->srec = module->file_table[data].srec;
vms_debug2 ((4, ""DST_S_C_SRC_SETFILE: %d\n"", data));
break;
case DST__K_SRC_SETLNUM_L:
data = bfd_getl32 (src_ptr + DST_S_L_SRC_UNSLONG);
curr_srec->line = data;
vms_debug2 ((4, ""DST_S_C_SRC_SETLNUM_L: %d\n"", data));
break;
case DST__K_SRC_SETLNUM_W:
data = bfd_getl16 (src_ptr + DST_S_W_SRC_UNSWORD);
curr_srec->line = data;
vms_debug2 ((4, ""DST_S_C_SRC_SETLNUM_W: %d\n"", data));
break;
case DST__K_SRC_SETREC_L:
data = bfd_getl32 (src_ptr + DST_S_L_SRC_UNSLONG);
curr_srec->srec = data;
module->file_table[curr_srec->sfile].srec = data;
vms_debug2 ((4, ""DST_S_C_SRC_SETREC_L: %d\n"", data));
break;
case DST__K_SRC_SETREC_W:
data = bfd_getl16 (src_ptr + DST_S_W_SRC_UNSWORD);
curr_srec->srec = data;
module->file_table[curr_srec->sfile].srec = data;
vms_debug2 ((4, ""DST_S_C_SRC_SETREC_W: %d\n"", data));
break;
case DST__K_SRC_FORMFEED:
vms_debug2 ((4, ""DST_S_C_SRC_FORMFEED\n""));
break;
default:
_bfd_error_handler (_(""unknown source command %d""),
cmd);
break;
}
src_ptr += cmd_length;
}
break;
case DST__K_LINE_NUM:
pcl_ptr = ptr + DST_S_C_LINE_NUM_HEADER_SIZE;
vms_debug2 ((3, ""line info\n""));
while (pcl_ptr - ptr < rec_length)
{
int cmd = ((signed char *)pcl_ptr)[0], cmd_length, data;
switch (cmd)
{
case DST__K_DELTA_PC_W:
cmd_length = 3;
break;
case DST__K_DELTA_PC_L:
cmd_length = 5;
break;
case DST__K_INCR_LINUM:
cmd_length = 2;
break;
case DST__K_INCR_LINUM_W:
cmd_length = 3;
break;
case DST__K_INCR_LINUM_L:
cmd_length = 5;
break;
case DST__K_SET_LINUM_INCR:
cmd_length = 2;
break;
case DST__K_SET_LINUM_INCR_W:
cmd_length = 3;
break;
case DST__K_RESET_LINUM_INCR:
cmd_length = 1;
break;
case DST__K_BEG_STMT_MODE:
cmd_length = 1;
break;
case DST__K_END_STMT_MODE:
cmd_length = 1;
break;
case DST__K_SET_LINUM_B:
cmd_length = 2;
break;
case DST__K_SET_LINUM:
cmd_length = 3;
break;
case DST__K_SET_LINUM_L:
cmd_length = 5;
break;
case DST__K_SET_PC:
cmd_length = 2;
break;
case DST__K_SET_PC_W:
cmd_length = 3;
break;
case DST__K_SET_PC_L:
cmd_length = 5;
break;
case DST__K_SET_STMTNUM:
cmd_length = 2;
break;
case DST__K_TERM:
cmd_length = 2;
break;
case DST__K_TERM_W:
cmd_length = 3;
break;
case DST__K_TERM_L:
cmd_length = 5;
break;
case DST__K_SET_ABS_PC:
cmd_length = 5;
break;
default:
if (cmd <= 0)
cmd_length = 1;
else
cmd_length = 2;
break;
}
if (pcl_ptr - ptr + cmd_length > rec_length)
break;
switch (cmd)
{
case DST__K_DELTA_PC_W:
data = bfd_getl16 (pcl_ptr + DST_S_W_PCLINE_UNSWORD);
curr_pc += data;
curr_linenum += 1;
vms_debug2 ((4, ""DST__K_DELTA_PC_W: %d\n"", data));
break;
case DST__K_DELTA_PC_L:
data = bfd_getl32 (pcl_ptr + DST_S_L_PCLINE_UNSLONG);
curr_pc += data;
curr_linenum += 1;
vms_debug2 ((4, ""DST__K_DELTA_PC_L: %d\n"", data));
break;
case DST__K_INCR_LINUM:
data = pcl_ptr[DST_S_B_PCLINE_UNSBYTE];
curr_linenum += data;
vms_debug2 ((4, ""DST__K_INCR_LINUM: %d\n"", data));
break;
case DST__K_INCR_LINUM_W:
data = bfd_getl16 (pcl_ptr + DST_S_W_PCLINE_UNSWORD);
curr_linenum += data;
vms_debug2 ((4, ""DST__K_INCR_LINUM_W: %d\n"", data));
break;
case DST__K_INCR_LINUM_L:
data = bfd_getl32 (pcl_ptr + DST_S_L_PCLINE_UNSLONG);
curr_linenum += data;
vms_debug2 ((4, ""DST__K_INCR_LINUM_L: %d\n"", data));
break;
case DST__K_SET_LINUM_INCR:
_bfd_error_handler
(_(""%s not implemented""), ""DST__K_SET_LINUM_INCR"");
break;
case DST__K_SET_LINUM_INCR_W:
_bfd_error_handler
(_(""%s not implemented""), ""DST__K_SET_LINUM_INCR_W"");
break;
case DST__K_RESET_LINUM_INCR:
_bfd_error_handler
(_(""%s not implemented""), ""DST__K_RESET_LINUM_INCR"");
break;
case DST__K_BEG_STMT_MODE:
_bfd_error_handler
(_(""%s not implemented""), ""DST__K_BEG_STMT_MODE"");
break;
case DST__K_END_STMT_MODE:
_bfd_error_handler
(_(""%s not implemented""), ""DST__K_END_STMT_MODE"");
break;
case DST__K_SET_LINUM_B:
data = pcl_ptr[DST_S_B_PCLINE_UNSBYTE];
curr_linenum = data;
vms_debug2 ((4, ""DST__K_SET_LINUM_B: %d\n"", data));
break;
case DST__K_SET_LINUM:
data = bfd_getl16 (pcl_ptr + DST_S_W_PCLINE_UNSWORD);
curr_linenum = data;
vms_debug2 ((4, ""DST__K_SET_LINE_NUM: %d\n"", data));
break;
case DST__K_SET_LINUM_L:
data = bfd_getl32 (pcl_ptr + DST_S_L_PCLINE_UNSLONG);
curr_linenum = data;
vms_debug2 ((4, ""DST__K_SET_LINUM_L: %d\n"", data));
break;
case DST__K_SET_PC:
_bfd_error_handler
(_(""%s not implemented""), ""DST__K_SET_PC"");
break;
case DST__K_SET_PC_W:
_bfd_error_handler
(_(""%s not implemented""), ""DST__K_SET_PC_W"");
break;
case DST__K_SET_PC_L:
_bfd_error_handler
(_(""%s not implemented""), ""DST__K_SET_PC_L"");
break;
case DST__K_SET_STMTNUM:
_bfd_error_handler
(_(""%s not implemented""), ""DST__K_SET_STMTNUM"");
break;
case DST__K_TERM:
data = pcl_ptr[DST_S_B_PCLINE_UNSBYTE];
curr_pc += data;
vms_debug2 ((4, ""DST__K_TERM: %d\n"", data));
break;
case DST__K_TERM_W:
data = bfd_getl16 (pcl_ptr + DST_S_W_PCLINE_UNSWORD);
curr_pc += data;
vms_debug2 ((4, ""DST__K_TERM_W: %d\n"", data));
break;
case DST__K_TERM_L:
data = bfd_getl32 (pcl_ptr + DST_S_L_PCLINE_UNSLONG);
curr_pc += data;
vms_debug2 ((4, ""DST__K_TERM_L: %d\n"", data));
break;
case DST__K_SET_ABS_PC:
data = bfd_getl32 (pcl_ptr + DST_S_L_PCLINE_UNSLONG);
curr_pc = data;
vms_debug2 ((4, ""DST__K_SET_ABS_PC: 0x%x\n"", data));
break;
default:
if (cmd <= 0)
{
curr_pc -= cmd;
curr_linenum += 1;
vms_debug2 ((4, ""bump pc to 0x%lx and line to %d\n"",
(unsigned long)curr_pc, curr_linenum));
}
else
_bfd_error_handler (_(""unknown line command %d""), cmd);
break;
}
if ((curr_linenum != prev_linum && curr_pc != prev_pc)
|| cmd <= 0
|| cmd == DST__K_DELTA_PC_L
|| cmd == DST__K_DELTA_PC_W)
{
line = (struct lineinfo *)
bfd_zalloc (abfd, sizeof (struct lineinfo));
line->address = curr_pc;
line->line = curr_linenum;
curr_line->next = line;
curr_line = line;
prev_linum = curr_linenum;
prev_pc = curr_pc;
vms_debug2 ((4, ""-> correlate pc 0x%lx with line %d\n"",
(unsigned long)curr_pc, curr_linenum));
}
pcl_ptr += cmd_length;
}
break;
case 0x17: 
vms_debug2 ((3, ""undocumented type 0x17\n""));
break;
default:
vms_debug2 ((3, ""ignoring record\n""));
break;
}
ptr += rec_length;
}
srec = (struct srecinfo *) bfd_zalloc (abfd, sizeof (struct srecinfo));
srec->line = (unsigned int) -1;
srec->srec = (unsigned int) -1;
curr_srec->next = srec;
line = (struct lineinfo *) bfd_zalloc (abfd, sizeof (struct lineinfo));
line->line = (unsigned int) -1;
line->address = (bfd_vma) -1;
curr_line->next = line;
SET_MODULE_PARSED (module);
return true;
}","static bool
parse_module (bfd *VAR_0, struct module *module, unsigned char *VAR_1,
bfd_size_type VAR_2)
{
unsigned char *VAR_3 = VAR_1 + VAR_2;
unsigned char *VAR_4, *VAR_5;
unsigned int VAR_6 = 0, VAR_7 = 0;
bfd_vma VAR_8 = 0, VAR_9 = 0;
struct srecinfo *VAR_10, *VAR_11;
struct lineinfo *VAR_12, *VAR_13;
struct funcinfo *funcinfo;
VAR_10 = (struct srecinfo *) bfd_zalloc (VAR_0, sizeof (struct srecinfo));
if (!VAR_10)
return false;
module->srec_table = VAR_10;
VAR_12 = (struct lineinfo *) bfd_zalloc (VAR_0, sizeof (struct lineinfo));
if (!VAR_12)
return false;
module->line_table = VAR_12;
while (VAR_1 + 3 < VAR_3)
{
int VAR_14 = bfd_getl16 (VAR_1) + 1;
int VAR_15 = bfd_getl16 (VAR_1 + 2);
vms_debug2 ((2, ""DST record: leng %d, type %d\n"", VAR_14, VAR_15));
if (VAR_14 > VAR_3 - VAR_1)
break;
if (VAR_15 == VAR_16)
break;
switch (VAR_15)
{
case VAR_17:
if (VAR_14 <= VAR_18)
break;
module->name
= _bfd_vms_save_counted_string (VAR_0, VAR_1 + VAR_18,
VAR_14 - VAR_18);
VAR_9 = 0;
VAR_8 = 0;
VAR_7 = 0;
VAR_6 = 0;
vms_debug2 ((3, ""module: %s\n"", module->name));
break;
case VAR_16:
break;
case VAR_19:
if (VAR_14 <= VAR_20)
break;
funcinfo = (struct funcinfo *)
bfd_zalloc (VAR_0, sizeof (struct funcinfo));
if (!funcinfo)
return false;
funcinfo->name
= _bfd_vms_save_counted_string (VAR_0, VAR_1 + VAR_20,
VAR_14 - VAR_20);
funcinfo->low = bfd_getl32 (VAR_1 + VAR_21);
funcinfo->next = module->func_table;
module->func_table = funcinfo;
vms_debug2 ((3, ""routine: %s at 0x%lx\n"",
funcinfo->name, (unsigned long) funcinfo->low));
break;
case VAR_22:
if (VAR_14 < VAR_23 + 4)
break;
if (!module->func_table)
return false;
module->func_table->high = module->func_table->low
+ bfd_getl32 (VAR_1 + VAR_23) - 1;
if (module->func_table->high > module->high)
module->high = module->func_table->high;
vms_debug2 ((3, ""end routine\n""));
break;
case VAR_24:
vms_debug2 ((3, ""prologue\n""));
break;
case VAR_25:
vms_debug2 ((3, ""epilog\n""));
break;
case VAR_26:
vms_debug2 ((3, ""block\n""));
break;
case VAR_27:
vms_debug2 ((3, ""end block\n""));
break;
case VAR_28:
VAR_4 = VAR_1 + VAR_29;
vms_debug2 ((3, ""source info\n""));
while (VAR_4 - VAR_1 < VAR_14)
{
int VAR_30 = VAR_4[0], VAR_31, VAR_32;
switch (VAR_30)
{
case VAR_33:
if (VAR_4 - VAR_1 + VAR_34 >= VAR_14)
VAR_31 = 0x10000;
else
VAR_31 = VAR_4[VAR_34] + 2;
break;
case VAR_35:
VAR_31 = 2;
break;
case VAR_36:
VAR_31 = 3;
break;
case VAR_37:
VAR_31 = 2;
break;
case VAR_38:
VAR_31 = 3;
break;
case VAR_39:
VAR_31 = 5;
break;
case VAR_40:
VAR_31 = 3;
break;
case VAR_41:
VAR_31 = 5;
break;
case VAR_42:
VAR_31 = 3;
break;
case VAR_43:
VAR_31 = 1;
break;
default:
VAR_31 = 2;
break;
}
if (VAR_4 - VAR_1 + VAR_31 > VAR_14)
break;
switch (VAR_30)
{
case VAR_33:
{
unsigned int VAR_44
= bfd_getl16 (VAR_4 + VAR_45);
char *VAR_46 = _bfd_vms_save_counted_string
(VAR_0,
VAR_4 + VAR_47,
VAR_1 + VAR_14 - (VAR_4 + VAR_47));
while (VAR_44 >= module->file_table_count)
{
module->file_table_count *= 2;
module->file_table
= bfd_realloc_or_free (module->file_table,
module->file_table_count
* sizeof (struct fileinfo));
if (module->file_table == NULL)
return false;
}
module->file_table [VAR_44].name = VAR_46;
module->file_table [VAR_44].srec = 1;
vms_debug2 ((4, ""DST_S_C_SRC_DECLFILE: %d, %s\n"",
VAR_44, module->file_table [VAR_44].name));
}
break;
case VAR_35:
VAR_32 = VAR_4[VAR_48];
VAR_11 = (struct srecinfo *)
bfd_zalloc (VAR_0, sizeof (struct srecinfo));
VAR_11->line = VAR_10->line + VAR_32;
VAR_11->srec = VAR_10->srec + VAR_32;
VAR_11->sfile = VAR_10->sfile;
VAR_10->next = VAR_11;
VAR_10 = VAR_11;
vms_debug2 ((4, ""DST_S_C_SRC_DEFLINES_B: %d\n"", VAR_32));
break;
case VAR_36:
VAR_32 = bfd_getl16 (VAR_4 + VAR_49);
VAR_11 = (struct srecinfo *)
bfd_zalloc (VAR_0, sizeof (struct srecinfo));
VAR_11->line = VAR_10->line + VAR_32;
VAR_11->srec = VAR_10->srec + VAR_32,
VAR_11->sfile = VAR_10->sfile;
VAR_10->next = VAR_11;
VAR_10 = VAR_11;
vms_debug2 ((4, ""DST_S_C_SRC_DEFLINES_W: %d\n"", VAR_32));
break;
case VAR_37:
VAR_32 = VAR_4[VAR_48];
VAR_10->line += VAR_32;
vms_debug2 ((4, ""DST_S_C_SRC_INCRLNUM_B: %d\n"", VAR_32));
break;
case VAR_38:
VAR_32 = bfd_getl16 (VAR_4 + VAR_49);
VAR_10->sfile = VAR_32;
VAR_10->srec = module->file_table[VAR_32].srec;
vms_debug2 ((4, ""DST_S_C_SRC_SETFILE: %d\n"", VAR_32));
break;
case VAR_39:
VAR_32 = bfd_getl32 (VAR_4 + VAR_50);
VAR_10->line = VAR_32;
vms_debug2 ((4, ""DST_S_C_SRC_SETLNUM_L: %d\n"", VAR_32));
break;
case VAR_40:
VAR_32 = bfd_getl16 (VAR_4 + VAR_49);
VAR_10->line = VAR_32;
vms_debug2 ((4, ""DST_S_C_SRC_SETLNUM_W: %d\n"", VAR_32));
break;
case VAR_41:
VAR_32 = bfd_getl32 (VAR_4 + VAR_50);
VAR_10->srec = VAR_32;
module->file_table[VAR_10->sfile].srec = VAR_32;
vms_debug2 ((4, ""DST_S_C_SRC_SETREC_L: %d\n"", VAR_32));
break;
case VAR_42:
VAR_32 = bfd_getl16 (VAR_4 + VAR_49);
VAR_10->srec = VAR_32;
module->file_table[VAR_10->sfile].srec = VAR_32;
vms_debug2 ((4, ""DST_S_C_SRC_SETREC_W: %d\n"", VAR_32));
break;
case VAR_43:
vms_debug2 ((4, ""DST_S_C_SRC_FORMFEED\n""));
break;
default:
_bfd_error_handler (_(""unknown source command %d""),
VAR_30);
break;
}
VAR_4 += VAR_31;
}
break;
case VAR_51:
VAR_5 = VAR_1 + VAR_52;
vms_debug2 ((3, ""line info\n""));
while (VAR_5 - VAR_1 < VAR_14)
{
int VAR_30 = ((signed char *)VAR_5)[0], VAR_31, VAR_32;
switch (VAR_30)
{
case VAR_53:
VAR_31 = 3;
break;
case VAR_54:
VAR_31 = 5;
break;
case VAR_55:
VAR_31 = 2;
break;
case VAR_56:
VAR_31 = 3;
break;
case VAR_57:
VAR_31 = 5;
break;
case VAR_58:
VAR_31 = 2;
break;
case VAR_59:
VAR_31 = 3;
break;
case VAR_60:
VAR_31 = 1;
break;
case VAR_61:
VAR_31 = 1;
break;
case VAR_62:
VAR_31 = 1;
break;
case VAR_63:
VAR_31 = 2;
break;
case VAR_64:
VAR_31 = 3;
break;
case VAR_65:
VAR_31 = 5;
break;
case VAR_66:
VAR_31 = 2;
break;
case VAR_67:
VAR_31 = 3;
break;
case VAR_68:
VAR_31 = 5;
break;
case VAR_69:
VAR_31 = 2;
break;
case VAR_70:
VAR_31 = 2;
break;
case VAR_71:
VAR_31 = 3;
break;
case VAR_72:
VAR_31 = 5;
break;
case VAR_73:
VAR_31 = 5;
break;
default:
if (VAR_30 <= 0)
VAR_31 = 1;
else
VAR_31 = 2;
break;
}
if (VAR_5 - VAR_1 + VAR_31 > VAR_14)
break;
switch (VAR_30)
{
case VAR_53:
VAR_32 = bfd_getl16 (VAR_5 + VAR_74);
VAR_9 += VAR_32;
VAR_7 += 1;
vms_debug2 ((4, ""DST__K_DELTA_PC_W: %d\n"", VAR_32));
break;
case VAR_54:
VAR_32 = bfd_getl32 (VAR_5 + VAR_75);
VAR_9 += VAR_32;
VAR_7 += 1;
vms_debug2 ((4, ""DST__K_DELTA_PC_L: %d\n"", VAR_32));
break;
case VAR_55:
VAR_32 = VAR_5[VAR_76];
VAR_7 += VAR_32;
vms_debug2 ((4, ""DST__K_INCR_LINUM: %d\n"", VAR_32));
break;
case VAR_56:
VAR_32 = bfd_getl16 (VAR_5 + VAR_74);
VAR_7 += VAR_32;
vms_debug2 ((4, ""DST__K_INCR_LINUM_W: %d\n"", VAR_32));
break;
case VAR_57:
VAR_32 = bfd_getl32 (VAR_5 + VAR_75);
VAR_7 += VAR_32;
vms_debug2 ((4, ""DST__K_INCR_LINUM_L: %d\n"", VAR_32));
break;
case VAR_58:
_bfd_error_handler
(_(""%s not implemented""), ""DST__K_SET_LINUM_INCR"");
break;
case VAR_59:
_bfd_error_handler
(_(""%s not implemented""), ""DST__K_SET_LINUM_INCR_W"");
break;
case VAR_60:
_bfd_error_handler
(_(""%s not implemented""), ""DST__K_RESET_LINUM_INCR"");
break;
case VAR_61:
_bfd_error_handler
(_(""%s not implemented""), ""DST__K_BEG_STMT_MODE"");
break;
case VAR_62:
_bfd_error_handler
(_(""%s not implemented""), ""DST__K_END_STMT_MODE"");
break;
case VAR_63:
VAR_32 = VAR_5[VAR_76];
VAR_7 = VAR_32;
vms_debug2 ((4, ""DST__K_SET_LINUM_B: %d\n"", VAR_32));
break;
case VAR_64:
VAR_32 = bfd_getl16 (VAR_5 + VAR_74);
VAR_7 = VAR_32;
vms_debug2 ((4, ""DST__K_SET_LINE_NUM: %d\n"", VAR_32));
break;
case VAR_65:
VAR_32 = bfd_getl32 (VAR_5 + VAR_75);
VAR_7 = VAR_32;
vms_debug2 ((4, ""DST__K_SET_LINUM_L: %d\n"", VAR_32));
break;
case VAR_66:
_bfd_error_handler
(_(""%s not implemented""), ""DST__K_SET_PC"");
break;
case VAR_67:
_bfd_error_handler
(_(""%s not implemented""), ""DST__K_SET_PC_W"");
break;
case VAR_68:
_bfd_error_handler
(_(""%s not implemented""), ""DST__K_SET_PC_L"");
break;
case VAR_69:
_bfd_error_handler
(_(""%s not implemented""), ""DST__K_SET_STMTNUM"");
break;
case VAR_70:
VAR_32 = VAR_5[VAR_76];
VAR_9 += VAR_32;
vms_debug2 ((4, ""DST__K_TERM: %d\n"", VAR_32));
break;
case VAR_71:
VAR_32 = bfd_getl16 (VAR_5 + VAR_74);
VAR_9 += VAR_32;
vms_debug2 ((4, ""DST__K_TERM_W: %d\n"", VAR_32));
break;
case VAR_72:
VAR_32 = bfd_getl32 (VAR_5 + VAR_75);
VAR_9 += VAR_32;
vms_debug2 ((4, ""DST__K_TERM_L: %d\n"", VAR_32));
break;
case VAR_73:
VAR_32 = bfd_getl32 (VAR_5 + VAR_75);
VAR_9 = VAR_32;
vms_debug2 ((4, ""DST__K_SET_ABS_PC: 0x%x\n"", VAR_32));
break;
default:
if (VAR_30 <= 0)
{
VAR_9 -= VAR_30;
VAR_7 += 1;
vms_debug2 ((4, ""bump pc to 0x%lx and line to %d\n"",
(unsigned long)VAR_9, VAR_7));
}
else
_bfd_error_handler (_(""unknown line command %d""), VAR_30);
break;
}
if ((VAR_7 != VAR_6 && VAR_9 != VAR_8)
|| VAR_30 <= 0
|| VAR_30 == VAR_54
|| VAR_30 == VAR_53)
{
VAR_13 = (struct lineinfo *)
bfd_zalloc (VAR_0, sizeof (struct lineinfo));
VAR_13->address = VAR_9;
VAR_13->line = VAR_7;
VAR_12->next = VAR_13;
VAR_12 = VAR_13;
VAR_6 = VAR_7;
VAR_8 = VAR_9;
vms_debug2 ((4, ""-> correlate pc 0x%lx with line %d\n"",
(unsigned long)VAR_9, VAR_7));
}
VAR_5 += VAR_31;
}
break;
case 0x17: 
vms_debug2 ((3, ""undocumented type 0x17\n""));
break;
default:
vms_debug2 ((3, ""ignoring record\n""));
break;
}
VAR_1 += VAR_14;
}
VAR_11 = (struct srecinfo *) bfd_zalloc (VAR_0, sizeof (struct srecinfo));
VAR_11->line = (unsigned int) -1;
VAR_11->srec = (unsigned int) -1;
VAR_10->next = VAR_11;
VAR_13 = (struct lineinfo *) bfd_zalloc (VAR_0, sizeof (struct lineinfo));
VAR_13->line = (unsigned int) -1;
VAR_13->address = (bfd_vma) -1;
VAR_12->next = VAR_13;
SET_MODULE_PARSED (module);
return true;
}",binutils-gdb/65cf035b8dc1df5d8020e0b1449514a3c42933e7/vms-alpha.c/vul/before/1.json,"static bool
parse_module (bfd *abfd, struct module *module, unsigned char *ptr,
	      bfd_size_type length)
{
  unsigned char *maxptr = ptr + length;
  unsigned char *src_ptr, *pcl_ptr;
  unsigned int prev_linum = 0, curr_linenum = 0;
  bfd_vma prev_pc = 0, curr_pc = 0;
  struct srecinfo *curr_srec, *srec;
  struct lineinfo *curr_line, *line;
  struct funcinfo *funcinfo;

  /* Initialize tables with zero element.  */
  curr_srec = (struct srecinfo *) bfd_zalloc (abfd, sizeof (struct srecinfo));
  if (!curr_srec)
    return false;
  module->srec_table = curr_srec;

  curr_line = (struct lineinfo *) bfd_zalloc (abfd, sizeof (struct lineinfo));
  if (!curr_line)
    return false;
  module->line_table = curr_line;

  while (ptr + 3 < maxptr)
    {
      /* The first byte is not counted in the recorded length.  */
      int rec_length = bfd_getl16 (ptr) + 1;
      int rec_type = bfd_getl16 (ptr + 2);

      vms_debug2 ((2, ""DST record: leng %d, type %d\n"", rec_length, rec_type));

      if (rec_length > maxptr - ptr)
	break;
      if (rec_type == DST__K_MODEND)
	break;

      switch (rec_type)
	{
	case DST__K_MODBEG:
	  if (rec_length <= DST_S_B_MODBEG_NAME)
	    break;
	  module->name
	    = _bfd_vms_save_counted_string (abfd, ptr + DST_S_B_MODBEG_NAME,
					    rec_length - DST_S_B_MODBEG_NAME);

	  curr_pc = 0;
	  prev_pc = 0;
	  curr_linenum = 0;
	  prev_linum = 0;

	  vms_debug2 ((3, ""module: %s\n"", module->name));
	  break;

	case DST__K_MODEND:
	  break;

	case DST__K_RTNBEG:
	  if (rec_length <= DST_S_B_RTNBEG_NAME)
	    break;
	  funcinfo = (struct funcinfo *)
	    bfd_zalloc (abfd, sizeof (struct funcinfo));
	  if (!funcinfo)
	    return false;
	  funcinfo->name
	    = _bfd_vms_save_counted_string (abfd, ptr + DST_S_B_RTNBEG_NAME,
					    rec_length - DST_S_B_RTNBEG_NAME);
	  funcinfo->low = bfd_getl32 (ptr + DST_S_L_RTNBEG_ADDRESS);
	  funcinfo->next = module->func_table;
	  module->func_table = funcinfo;

	  vms_debug2 ((3, ""routine: %s at 0x%lx\n"",
		       funcinfo->name, (unsigned long) funcinfo->low));
	  break;

	case DST__K_RTNEND:
	  if (rec_length < DST_S_L_RTNEND_SIZE + 4)
	    break;
	  if (!module->func_table)
	    return false;
	  module->func_table->high = module->func_table->low
	    + bfd_getl32 (ptr + DST_S_L_RTNEND_SIZE) - 1;

	  if (module->func_table->high > module->high)
	    module->high = module->func_table->high;

	  vms_debug2 ((3, ""end routine\n""));
	  break;

	case DST__K_PROLOG:
	  vms_debug2 ((3, ""prologue\n""));
	  break;

	case DST__K_EPILOG:
	  vms_debug2 ((3, ""epilog\n""));
	  break;

	case DST__K_BLKBEG:
	  vms_debug2 ((3, ""block\n""));
	  break;

	case DST__K_BLKEND:
	  vms_debug2 ((3, ""end block\n""));
	  break;

	case DST__K_SOURCE:
	  src_ptr = ptr + DST_S_C_SOURCE_HEADER_SIZE;

	  vms_debug2 ((3, ""source info\n""));

	  while (src_ptr - ptr < rec_length)
	    {
	      int cmd = src_ptr[0], cmd_length, data;

	      switch (cmd)
		{
		case DST__K_SRC_DECLFILE:
		  if (src_ptr - ptr + DST_S_B_SRC_DF_LENGTH >= rec_length)
		    cmd_length = 0x10000;
		  else
		    cmd_length = src_ptr[DST_S_B_SRC_DF_LENGTH] + 2;
		  break;

		case DST__K_SRC_DEFLINES_B:
		  cmd_length = 2;
		  break;

		case DST__K_SRC_DEFLINES_W:
		  cmd_length = 3;
		  break;

		case DST__K_SRC_INCRLNUM_B:
		  cmd_length = 2;
		  break;

		case DST__K_SRC_SETFILE:
		  cmd_length = 3;
		  break;

		case DST__K_SRC_SETLNUM_L:
		  cmd_length = 5;
		  break;

		case DST__K_SRC_SETLNUM_W:
		  cmd_length = 3;
		  break;

		case DST__K_SRC_SETREC_L:
		  cmd_length = 5;
		  break;

		case DST__K_SRC_SETREC_W:
		  cmd_length = 3;
		  break;

		case DST__K_SRC_FORMFEED:
		  cmd_length = 1;
		  break;

		default:
		  cmd_length = 2;
		  break;
		}

	      if (src_ptr - ptr + cmd_length > rec_length)
		break;

	      switch (cmd)
		{
		case DST__K_SRC_DECLFILE:
		  {
		    unsigned int fileid
		      = bfd_getl16 (src_ptr + DST_S_W_SRC_DF_FILEID);
		    char *filename = _bfd_vms_save_counted_string
		      (abfd,
		       src_ptr + DST_S_B_SRC_DF_FILENAME,
		       ptr + rec_length - (src_ptr + DST_S_B_SRC_DF_FILENAME));

		    if (fileid >= module->file_table_count)
		      {
			unsigned int old_count = module->file_table_count;
			module->file_table_count += fileid;
			module->file_table
			  = bfd_realloc_or_free (module->file_table,
						 module->file_table_count
						 * sizeof (struct fileinfo));
			if (module->file_table == NULL)
			  return false;
			memset (module->file_table + old_count, 0,
				fileid * sizeof (struct fileinfo));
		      }

		    module->file_table [fileid].name = filename;
		    module->file_table [fileid].srec = 1;
		    vms_debug2 ((4, ""DST_S_C_SRC_DECLFILE: %d, %s\n"",
				 fileid, module->file_table [fileid].name));
		  }
		  break;

		case DST__K_SRC_DEFLINES_B:
		  /* Perform the association and set the next higher index
		     to the limit.  */
		  data = src_ptr[DST_S_B_SRC_UNSBYTE];
		  srec = (struct srecinfo *)
		    bfd_zalloc (abfd, sizeof (struct srecinfo));
		  srec->line = curr_srec->line + data;
		  srec->srec = curr_srec->srec + data;
		  srec->sfile = curr_srec->sfile;
		  curr_srec->next = srec;
		  curr_srec = srec;
		  vms_debug2 ((4, ""DST_S_C_SRC_DEFLINES_B: %d\n"", data));
		  break;

		case DST__K_SRC_DEFLINES_W:
		  /* Perform the association and set the next higher index
		     to the limit.  */
		  data = bfd_getl16 (src_ptr + DST_S_W_SRC_UNSWORD);
		  srec = (struct srecinfo *)
		    bfd_zalloc (abfd, sizeof (struct srecinfo));
		  srec->line = curr_srec->line + data;
		  srec->srec = curr_srec->srec + data,
		  srec->sfile = curr_srec->sfile;
		  curr_srec->next = srec;
		  curr_srec = srec;
		  vms_debug2 ((4, ""DST_S_C_SRC_DEFLINES_W: %d\n"", data));
		  break;

		case DST__K_SRC_INCRLNUM_B:
		  data = src_ptr[DST_S_B_SRC_UNSBYTE];
		  curr_srec->line += data;
		  vms_debug2 ((4, ""DST_S_C_SRC_INCRLNUM_B: %d\n"", data));
		  break;

		case DST__K_SRC_SETFILE:
		  data = bfd_getl16 (src_ptr + DST_S_W_SRC_UNSWORD);
		  curr_srec->sfile = data;
		  curr_srec->srec = module->file_table[data].srec;
		  vms_debug2 ((4, ""DST_S_C_SRC_SETFILE: %d\n"", data));
		  break;

		case DST__K_SRC_SETLNUM_L:
		  data = bfd_getl32 (src_ptr + DST_S_L_SRC_UNSLONG);
		  curr_srec->line = data;
		  vms_debug2 ((4, ""DST_S_C_SRC_SETLNUM_L: %d\n"", data));
		  break;

		case DST__K_SRC_SETLNUM_W:
		  data = bfd_getl16 (src_ptr + DST_S_W_SRC_UNSWORD);
		  curr_srec->line = data;
		  vms_debug2 ((4, ""DST_S_C_SRC_SETLNUM_W: %d\n"", data));
		  break;

		case DST__K_SRC_SETREC_L:
		  data = bfd_getl32 (src_ptr + DST_S_L_SRC_UNSLONG);
		  curr_srec->srec = data;
		  module->file_table[curr_srec->sfile].srec = data;
		  vms_debug2 ((4, ""DST_S_C_SRC_SETREC_L: %d\n"", data));
		  break;

		case DST__K_SRC_SETREC_W:
		  data = bfd_getl16 (src_ptr + DST_S_W_SRC_UNSWORD);
		  curr_srec->srec = data;
		  module->file_table[curr_srec->sfile].srec = data;
		  vms_debug2 ((4, ""DST_S_C_SRC_SETREC_W: %d\n"", data));
		  break;

		case DST__K_SRC_FORMFEED:
		  vms_debug2 ((4, ""DST_S_C_SRC_FORMFEED\n""));
		  break;

		default:
		  _bfd_error_handler (_(""unknown source command %d""),
				      cmd);
		  break;
		}

	      src_ptr += cmd_length;
	    }
	  break;

	case DST__K_LINE_NUM:
	  pcl_ptr = ptr + DST_S_C_LINE_NUM_HEADER_SIZE;

	  vms_debug2 ((3, ""line info\n""));

	  while (pcl_ptr - ptr < rec_length)
	    {
	      /* The command byte is signed so we must sign-extend it.  */
	      int cmd = ((signed char *)pcl_ptr)[0], cmd_length, data;

	      switch (cmd)
		{
		case DST__K_DELTA_PC_W:
		  cmd_length = 3;
		  break;

		case DST__K_DELTA_PC_L:
		  cmd_length = 5;
		  break;

		case DST__K_INCR_LINUM:
		  cmd_length = 2;
		  break;

		case DST__K_INCR_LINUM_W:
		  cmd_length = 3;
		  break;

		case DST__K_INCR_LINUM_L:
		  cmd_length = 5;
		  break;

		case DST__K_SET_LINUM_INCR:
		  cmd_length = 2;
		  break;

		case DST__K_SET_LINUM_INCR_W:
		  cmd_length = 3;
		  break;

		case DST__K_RESET_LINUM_INCR:
		  cmd_length = 1;
		  break;

		case DST__K_BEG_STMT_MODE:
		  cmd_length = 1;
		  break;

		case DST__K_END_STMT_MODE:
		  cmd_length = 1;
		  break;

		case DST__K_SET_LINUM_B:
		  cmd_length = 2;
		  break;

		case DST__K_SET_LINUM:
		  cmd_length = 3;
		  break;

		case DST__K_SET_LINUM_L:
		  cmd_length = 5;
		  break;

		case DST__K_SET_PC:
		  cmd_length = 2;
		  break;

		case DST__K_SET_PC_W:
		  cmd_length = 3;
		  break;

		case DST__K_SET_PC_L:
		  cmd_length = 5;
		  break;

		case DST__K_SET_STMTNUM:
		  cmd_length = 2;
		  break;

		case DST__K_TERM:
		  cmd_length = 2;
		  break;

		case DST__K_TERM_W:
		  cmd_length = 3;
		  break;

		case DST__K_TERM_L:
		  cmd_length = 5;
		  break;

		case DST__K_SET_ABS_PC:
		  cmd_length = 5;
		  break;

		default:
		  if (cmd <= 0)
		    cmd_length = 1;
		  else
		    cmd_length = 2;
		  break;
		}

	      if (pcl_ptr - ptr + cmd_length > rec_length)
		break;

	      switch (cmd)
		{
		case DST__K_DELTA_PC_W:
		  data = bfd_getl16 (pcl_ptr + DST_S_W_PCLINE_UNSWORD);
		  curr_pc += data;
		  curr_linenum += 1;
		  vms_debug2 ((4, ""DST__K_DELTA_PC_W: %d\n"", data));
		  break;

		case DST__K_DELTA_PC_L:
		  data = bfd_getl32 (pcl_ptr + DST_S_L_PCLINE_UNSLONG);
		  curr_pc += data;
		  curr_linenum += 1;
		  vms_debug2 ((4, ""DST__K_DELTA_PC_L: %d\n"", data));
		  break;

		case DST__K_INCR_LINUM:
		  data = pcl_ptr[DST_S_B_PCLINE_UNSBYTE];
		  curr_linenum += data;
		  vms_debug2 ((4, ""DST__K_INCR_LINUM: %d\n"", data));
		  break;

		case DST__K_INCR_LINUM_W:
		  data = bfd_getl16 (pcl_ptr + DST_S_W_PCLINE_UNSWORD);
		  curr_linenum += data;
		  vms_debug2 ((4, ""DST__K_INCR_LINUM_W: %d\n"", data));
		  break;

		case DST__K_INCR_LINUM_L:
		  data = bfd_getl32 (pcl_ptr + DST_S_L_PCLINE_UNSLONG);
		  curr_linenum += data;
		  vms_debug2 ((4, ""DST__K_INCR_LINUM_L: %d\n"", data));
		  break;

		case DST__K_SET_LINUM_INCR:
		  _bfd_error_handler
		    (_(""%s not implemented""), ""DST__K_SET_LINUM_INCR"");
		  break;

		case DST__K_SET_LINUM_INCR_W:
		  _bfd_error_handler
		    (_(""%s not implemented""), ""DST__K_SET_LINUM_INCR_W"");
		  break;

		case DST__K_RESET_LINUM_INCR:
		  _bfd_error_handler
		    (_(""%s not implemented""), ""DST__K_RESET_LINUM_INCR"");
		  break;

		case DST__K_BEG_STMT_MODE:
		  _bfd_error_handler
		    (_(""%s not implemented""), ""DST__K_BEG_STMT_MODE"");
		  break;

		case DST__K_END_STMT_MODE:
		  _bfd_error_handler
		    (_(""%s not implemented""), ""DST__K_END_STMT_MODE"");
		  break;

		case DST__K_SET_LINUM_B:
		  data = pcl_ptr[DST_S_B_PCLINE_UNSBYTE];
		  curr_linenum = data;
		  vms_debug2 ((4, ""DST__K_SET_LINUM_B: %d\n"", data));
		  break;

		case DST__K_SET_LINUM:
		  data = bfd_getl16 (pcl_ptr + DST_S_W_PCLINE_UNSWORD);
		  curr_linenum = data;
		  vms_debug2 ((4, ""DST__K_SET_LINE_NUM: %d\n"", data));
		  break;

		case DST__K_SET_LINUM_L:
		  data = bfd_getl32 (pcl_ptr + DST_S_L_PCLINE_UNSLONG);
		  curr_linenum = data;
		  vms_debug2 ((4, ""DST__K_SET_LINUM_L: %d\n"", data));
		  break;

		case DST__K_SET_PC:
		  _bfd_error_handler
		    (_(""%s not implemented""), ""DST__K_SET_PC"");
		  break;

		case DST__K_SET_PC_W:
		  _bfd_error_handler
		    (_(""%s not implemented""), ""DST__K_SET_PC_W"");
		  break;

		case DST__K_SET_PC_L:
		  _bfd_error_handler
		    (_(""%s not implemented""), ""DST__K_SET_PC_L"");
		  break;

		case DST__K_SET_STMTNUM:
		  _bfd_error_handler
		    (_(""%s not implemented""), ""DST__K_SET_STMTNUM"");
		  break;

		case DST__K_TERM:
		  data = pcl_ptr[DST_S_B_PCLINE_UNSBYTE];
		  curr_pc += data;
		  vms_debug2 ((4, ""DST__K_TERM: %d\n"", data));
		  break;

		case DST__K_TERM_W:
		  data = bfd_getl16 (pcl_ptr + DST_S_W_PCLINE_UNSWORD);
		  curr_pc += data;
		  vms_debug2 ((4, ""DST__K_TERM_W: %d\n"", data));
		  break;

		case DST__K_TERM_L:
		  data = bfd_getl32 (pcl_ptr + DST_S_L_PCLINE_UNSLONG);
		  curr_pc += data;
		  vms_debug2 ((4, ""DST__K_TERM_L: %d\n"", data));
		  break;

		case DST__K_SET_ABS_PC:
		  data = bfd_getl32 (pcl_ptr + DST_S_L_PCLINE_UNSLONG);
		  curr_pc = data;
		  vms_debug2 ((4, ""DST__K_SET_ABS_PC: 0x%x\n"", data));
		  break;

		default:
		  if (cmd <= 0)
		    {
		      curr_pc -= cmd;
		      curr_linenum += 1;
		      vms_debug2 ((4, ""bump pc to 0x%lx and line to %d\n"",
				   (unsigned long)curr_pc, curr_linenum));
		    }
		  else
		    _bfd_error_handler (_(""unknown line command %d""), cmd);
		  break;
		}

	      if ((curr_linenum != prev_linum && curr_pc != prev_pc)
		  || cmd <= 0
		  || cmd == DST__K_DELTA_PC_L
		  || cmd == DST__K_DELTA_PC_W)
		{
		  line = (struct lineinfo *)
		    bfd_zalloc (abfd, sizeof (struct lineinfo));
		  line->address = curr_pc;
		  line->line = curr_linenum;

		  curr_line->next = line;
		  curr_line = line;

		  prev_linum = curr_linenum;
		  prev_pc = curr_pc;
		  vms_debug2 ((4, ""-> correlate pc 0x%lx with line %d\n"",
			       (unsigned long)curr_pc, curr_linenum));
		}

	      pcl_ptr += cmd_length;
	    }
	  break;

	case 0x17: /* Undocumented type used by DEC C to declare equates.  */
	  vms_debug2 ((3, ""undocumented type 0x17\n""));
	  break;

	default:
	  vms_debug2 ((3, ""ignoring record\n""));
	  break;

	}

      ptr += rec_length;
    }

  /* Finalize tables with EOL marker.  */
  srec = (struct srecinfo *) bfd_zalloc (abfd, sizeof (struct srecinfo));
  srec->line = (unsigned int) -1;
  srec->srec = (unsigned int) -1;
  curr_srec->next = srec;

  line = (struct lineinfo *) bfd_zalloc (abfd, sizeof (struct lineinfo));
  line->line = (unsigned int) -1;
  line->address = (bfd_vma) -1;
  curr_line->next = line;

  /* Advertise that this module has been parsed.  This is needed
     because parsing can be either performed at module creation
     or deferred until debug info is consumed.  */
  SET_MODULE_PARSED (module);
  return true;
}","static bool
parse_module (bfd *VAR_0, struct module *module, unsigned char *VAR_1,
	      bfd_size_type VAR_2)
{
  unsigned char *VAR_3 = VAR_1 + VAR_2;
  unsigned char *VAR_4, *VAR_5;
  unsigned int VAR_6 = 0, VAR_7 = 0;
  bfd_vma VAR_8 = 0, VAR_9 = 0;
  struct srecinfo *VAR_10, *VAR_11;
  struct lineinfo *VAR_12, *VAR_13;
  struct funcinfo *funcinfo;

  /* COMMENT_0 */
  VAR_10 = (struct srecinfo *) bfd_zalloc (VAR_0, sizeof (struct srecinfo));
  if (!VAR_10)
    return false;
  module->srec_table = VAR_10;

  VAR_12 = (struct lineinfo *) bfd_zalloc (VAR_0, sizeof (struct lineinfo));
  if (!VAR_12)
    return false;
  module->line_table = VAR_12;

  while (VAR_1 + 3 < VAR_3)
    {
      /* COMMENT_1 */
      int VAR_14 = bfd_getl16 (VAR_1) + 1;
      int VAR_15 = bfd_getl16 (VAR_1 + 2);

      vms_debug2 ((2, ""DST record: leng %d, type %d\n"", VAR_14, VAR_15));

      if (VAR_14 > VAR_3 - VAR_1)
	break;
      if (VAR_15 == VAR_16)
	break;

      switch (VAR_15)
	{
	case VAR_17:
	  if (VAR_14 <= VAR_18)
	    break;
	  module->name
	    = _bfd_vms_save_counted_string (VAR_0, VAR_1 + VAR_18,
					    VAR_14 - VAR_18);

	  VAR_9 = 0;
	  VAR_8 = 0;
	  VAR_7 = 0;
	  VAR_6 = 0;

	  vms_debug2 ((3, ""module: %s\n"", module->name));
	  break;

	case VAR_16:
	  break;

	case VAR_19:
	  if (VAR_14 <= VAR_20)
	    break;
	  funcinfo = (struct funcinfo *)
	    bfd_zalloc (VAR_0, sizeof (struct funcinfo));
	  if (!funcinfo)
	    return false;
	  funcinfo->name
	    = _bfd_vms_save_counted_string (VAR_0, VAR_1 + VAR_20,
					    VAR_14 - VAR_20);
	  funcinfo->low = bfd_getl32 (VAR_1 + VAR_21);
	  funcinfo->next = module->func_table;
	  module->func_table = funcinfo;

	  vms_debug2 ((3, ""routine: %s at 0x%lx\n"",
		       funcinfo->name, (unsigned long) funcinfo->low));
	  break;

	case VAR_22:
	  if (VAR_14 < VAR_23 + 4)
	    break;
	  if (!module->func_table)
	    return false;
	  module->func_table->high = module->func_table->low
	    + bfd_getl32 (VAR_1 + VAR_23) - 1;

	  if (module->func_table->high > module->high)
	    module->high = module->func_table->high;

	  vms_debug2 ((3, ""end routine\n""));
	  break;

	case VAR_24:
	  vms_debug2 ((3, ""prologue\n""));
	  break;

	case VAR_25:
	  vms_debug2 ((3, ""epilog\n""));
	  break;

	case VAR_26:
	  vms_debug2 ((3, ""block\n""));
	  break;

	case VAR_27:
	  vms_debug2 ((3, ""end block\n""));
	  break;

	case VAR_28:
	  VAR_4 = VAR_1 + VAR_29;

	  vms_debug2 ((3, ""source info\n""));

	  while (VAR_4 - VAR_1 < VAR_14)
	    {
	      int VAR_30 = VAR_4[0], VAR_31, VAR_32;

	      switch (VAR_30)
		{
		case VAR_33:
		  if (VAR_4 - VAR_1 + VAR_34 >= VAR_14)
		    VAR_31 = 0x10000;
		  else
		    VAR_31 = VAR_4[VAR_34] + 2;
		  break;

		case VAR_35:
		  VAR_31 = 2;
		  break;

		case VAR_36:
		  VAR_31 = 3;
		  break;

		case VAR_37:
		  VAR_31 = 2;
		  break;

		case VAR_38:
		  VAR_31 = 3;
		  break;

		case VAR_39:
		  VAR_31 = 5;
		  break;

		case VAR_40:
		  VAR_31 = 3;
		  break;

		case VAR_41:
		  VAR_31 = 5;
		  break;

		case VAR_42:
		  VAR_31 = 3;
		  break;

		case VAR_43:
		  VAR_31 = 1;
		  break;

		default:
		  VAR_31 = 2;
		  break;
		}

	      if (VAR_4 - VAR_1 + VAR_31 > VAR_14)
		break;

	      switch (VAR_30)
		{
		case VAR_33:
		  {
		    unsigned int VAR_44
		      = bfd_getl16 (VAR_4 + VAR_45);
		    char *VAR_46 = _bfd_vms_save_counted_string
		      (VAR_0,
		       VAR_4 + VAR_47,
		       VAR_1 + VAR_14 - (VAR_4 + VAR_47));

		    if (VAR_44 >= module->file_table_count)
		      {
			unsigned int VAR_48 = module->file_table_count;
			module->file_table_count += VAR_44;
			module->file_table
			  = bfd_realloc_or_free (module->file_table,
						 module->file_table_count
						 * sizeof (struct fileinfo));
			if (module->file_table == NULL)
			  return false;
			memset (module->file_table + VAR_48, 0,
				VAR_44 * sizeof (struct fileinfo));
		      }

		    module->file_table [VAR_44].name = VAR_46;
		    module->file_table [VAR_44].srec = 1;
		    vms_debug2 ((4, ""DST_S_C_SRC_DECLFILE: %d, %s\n"",
				 VAR_44, module->file_table [VAR_44].name));
		  }
		  break;

		case VAR_35:
		  /* COMMENT_2 */
                        
		  VAR_32 = VAR_4[VAR_49];
		  VAR_11 = (struct srecinfo *)
		    bfd_zalloc (VAR_0, sizeof (struct srecinfo));
		  VAR_11->line = VAR_10->line + VAR_32;
		  VAR_11->srec = VAR_10->srec + VAR_32;
		  VAR_11->sfile = VAR_10->sfile;
		  VAR_10->next = VAR_11;
		  VAR_10 = VAR_11;
		  vms_debug2 ((4, ""DST_S_C_SRC_DEFLINES_B: %d\n"", VAR_32));
		  break;

		case VAR_36:
		  /* COMMENT_4 */
                        
		  VAR_32 = bfd_getl16 (VAR_4 + VAR_50);
		  VAR_11 = (struct srecinfo *)
		    bfd_zalloc (VAR_0, sizeof (struct srecinfo));
		  VAR_11->line = VAR_10->line + VAR_32;
		  VAR_11->srec = VAR_10->srec + VAR_32,
		  VAR_11->sfile = VAR_10->sfile;
		  VAR_10->next = VAR_11;
		  VAR_10 = VAR_11;
		  vms_debug2 ((4, ""DST_S_C_SRC_DEFLINES_W: %d\n"", VAR_32));
		  break;

		case VAR_37:
		  VAR_32 = VAR_4[VAR_49];
		  VAR_10->line += VAR_32;
		  vms_debug2 ((4, ""DST_S_C_SRC_INCRLNUM_B: %d\n"", VAR_32));
		  break;

		case VAR_38:
		  VAR_32 = bfd_getl16 (VAR_4 + VAR_50);
		  VAR_10->sfile = VAR_32;
		  VAR_10->srec = module->file_table[VAR_32].srec;
		  vms_debug2 ((4, ""DST_S_C_SRC_SETFILE: %d\n"", VAR_32));
		  break;

		case VAR_39:
		  VAR_32 = bfd_getl32 (VAR_4 + VAR_51);
		  VAR_10->line = VAR_32;
		  vms_debug2 ((4, ""DST_S_C_SRC_SETLNUM_L: %d\n"", VAR_32));
		  break;

		case VAR_40:
		  VAR_32 = bfd_getl16 (VAR_4 + VAR_50);
		  VAR_10->line = VAR_32;
		  vms_debug2 ((4, ""DST_S_C_SRC_SETLNUM_W: %d\n"", VAR_32));
		  break;

		case VAR_41:
		  VAR_32 = bfd_getl32 (VAR_4 + VAR_51);
		  VAR_10->srec = VAR_32;
		  module->file_table[VAR_10->sfile].srec = VAR_32;
		  vms_debug2 ((4, ""DST_S_C_SRC_SETREC_L: %d\n"", VAR_32));
		  break;

		case VAR_42:
		  VAR_32 = bfd_getl16 (VAR_4 + VAR_50);
		  VAR_10->srec = VAR_32;
		  module->file_table[VAR_10->sfile].srec = VAR_32;
		  vms_debug2 ((4, ""DST_S_C_SRC_SETREC_W: %d\n"", VAR_32));
		  break;

		case VAR_43:
		  vms_debug2 ((4, ""DST_S_C_SRC_FORMFEED\n""));
		  break;

		default:
		  _bfd_error_handler (_(""unknown source command %d""),
				      VAR_30);
		  break;
		}

	      VAR_4 += VAR_31;
	    }
	  break;

	case VAR_52:
	  VAR_5 = VAR_1 + VAR_53;

	  vms_debug2 ((3, ""line info\n""));

	  while (VAR_5 - VAR_1 < VAR_14)
	    {
	      /* COMMENT_6 */
	      int VAR_30 = ((signed char *)VAR_5)[0], VAR_31, VAR_32;

	      switch (VAR_30)
		{
		case VAR_54:
		  VAR_31 = 3;
		  break;

		case VAR_55:
		  VAR_31 = 5;
		  break;

		case VAR_56:
		  VAR_31 = 2;
		  break;

		case VAR_57:
		  VAR_31 = 3;
		  break;

		case VAR_58:
		  VAR_31 = 5;
		  break;

		case VAR_59:
		  VAR_31 = 2;
		  break;

		case VAR_60:
		  VAR_31 = 3;
		  break;

		case VAR_61:
		  VAR_31 = 1;
		  break;

		case VAR_62:
		  VAR_31 = 1;
		  break;

		case VAR_63:
		  VAR_31 = 1;
		  break;

		case VAR_64:
		  VAR_31 = 2;
		  break;

		case VAR_65:
		  VAR_31 = 3;
		  break;

		case VAR_66:
		  VAR_31 = 5;
		  break;

		case VAR_67:
		  VAR_31 = 2;
		  break;

		case VAR_68:
		  VAR_31 = 3;
		  break;

		case VAR_69:
		  VAR_31 = 5;
		  break;

		case VAR_70:
		  VAR_31 = 2;
		  break;

		case VAR_71:
		  VAR_31 = 2;
		  break;

		case VAR_72:
		  VAR_31 = 3;
		  break;

		case VAR_73:
		  VAR_31 = 5;
		  break;

		case VAR_74:
		  VAR_31 = 5;
		  break;

		default:
		  if (VAR_30 <= 0)
		    VAR_31 = 1;
		  else
		    VAR_31 = 2;
		  break;
		}

	      if (VAR_5 - VAR_1 + VAR_31 > VAR_14)
		break;

	      switch (VAR_30)
		{
		case VAR_54:
		  VAR_32 = bfd_getl16 (VAR_5 + VAR_75);
		  VAR_9 += VAR_32;
		  VAR_7 += 1;
		  vms_debug2 ((4, ""DST__K_DELTA_PC_W: %d\n"", VAR_32));
		  break;

		case VAR_55:
		  VAR_32 = bfd_getl32 (VAR_5 + VAR_76);
		  VAR_9 += VAR_32;
		  VAR_7 += 1;
		  vms_debug2 ((4, ""DST__K_DELTA_PC_L: %d\n"", VAR_32));
		  break;

		case VAR_56:
		  VAR_32 = VAR_5[VAR_77];
		  VAR_7 += VAR_32;
		  vms_debug2 ((4, ""DST__K_INCR_LINUM: %d\n"", VAR_32));
		  break;

		case VAR_57:
		  VAR_32 = bfd_getl16 (VAR_5 + VAR_75);
		  VAR_7 += VAR_32;
		  vms_debug2 ((4, ""DST__K_INCR_LINUM_W: %d\n"", VAR_32));
		  break;

		case VAR_58:
		  VAR_32 = bfd_getl32 (VAR_5 + VAR_76);
		  VAR_7 += VAR_32;
		  vms_debug2 ((4, ""DST__K_INCR_LINUM_L: %d\n"", VAR_32));
		  break;

		case VAR_59:
		  _bfd_error_handler
		    (_(""%s not implemented""), ""DST__K_SET_LINUM_INCR"");
		  break;

		case VAR_60:
		  _bfd_error_handler
		    (_(""%s not implemented""), ""DST__K_SET_LINUM_INCR_W"");
		  break;

		case VAR_61:
		  _bfd_error_handler
		    (_(""%s not implemented""), ""DST__K_RESET_LINUM_INCR"");
		  break;

		case VAR_62:
		  _bfd_error_handler
		    (_(""%s not implemented""), ""DST__K_BEG_STMT_MODE"");
		  break;

		case VAR_63:
		  _bfd_error_handler
		    (_(""%s not implemented""), ""DST__K_END_STMT_MODE"");
		  break;

		case VAR_64:
		  VAR_32 = VAR_5[VAR_77];
		  VAR_7 = VAR_32;
		  vms_debug2 ((4, ""DST__K_SET_LINUM_B: %d\n"", VAR_32));
		  break;

		case VAR_65:
		  VAR_32 = bfd_getl16 (VAR_5 + VAR_75);
		  VAR_7 = VAR_32;
		  vms_debug2 ((4, ""DST__K_SET_LINE_NUM: %d\n"", VAR_32));
		  break;

		case VAR_66:
		  VAR_32 = bfd_getl32 (VAR_5 + VAR_76);
		  VAR_7 = VAR_32;
		  vms_debug2 ((4, ""DST__K_SET_LINUM_L: %d\n"", VAR_32));
		  break;

		case VAR_67:
		  _bfd_error_handler
		    (_(""%s not implemented""), ""DST__K_SET_PC"");
		  break;

		case VAR_68:
		  _bfd_error_handler
		    (_(""%s not implemented""), ""DST__K_SET_PC_W"");
		  break;

		case VAR_69:
		  _bfd_error_handler
		    (_(""%s not implemented""), ""DST__K_SET_PC_L"");
		  break;

		case VAR_70:
		  _bfd_error_handler
		    (_(""%s not implemented""), ""DST__K_SET_STMTNUM"");
		  break;

		case VAR_71:
		  VAR_32 = VAR_5[VAR_77];
		  VAR_9 += VAR_32;
		  vms_debug2 ((4, ""DST__K_TERM: %d\n"", VAR_32));
		  break;

		case VAR_72:
		  VAR_32 = bfd_getl16 (VAR_5 + VAR_75);
		  VAR_9 += VAR_32;
		  vms_debug2 ((4, ""DST__K_TERM_W: %d\n"", VAR_32));
		  break;

		case VAR_73:
		  VAR_32 = bfd_getl32 (VAR_5 + VAR_76);
		  VAR_9 += VAR_32;
		  vms_debug2 ((4, ""DST__K_TERM_L: %d\n"", VAR_32));
		  break;

		case VAR_74:
		  VAR_32 = bfd_getl32 (VAR_5 + VAR_76);
		  VAR_9 = VAR_32;
		  vms_debug2 ((4, ""DST__K_SET_ABS_PC: 0x%x\n"", VAR_32));
		  break;

		default:
		  if (VAR_30 <= 0)
		    {
		      VAR_9 -= VAR_30;
		      VAR_7 += 1;
		      vms_debug2 ((4, ""bump pc to 0x%lx and line to %d\n"",
				   (unsigned long)VAR_9, VAR_7));
		    }
		  else
		    _bfd_error_handler (_(""unknown line command %d""), VAR_30);
		  break;
		}

	      if ((VAR_7 != VAR_6 && VAR_9 != VAR_8)
		  || VAR_30 <= 0
		  || VAR_30 == VAR_55
		  || VAR_30 == VAR_54)
		{
		  VAR_13 = (struct lineinfo *)
		    bfd_zalloc (VAR_0, sizeof (struct lineinfo));
		  VAR_13->address = VAR_9;
		  VAR_13->line = VAR_7;

		  VAR_12->next = VAR_13;
		  VAR_12 = VAR_13;

		  VAR_6 = VAR_7;
		  VAR_8 = VAR_9;
		  vms_debug2 ((4, ""-> correlate pc 0x%lx with line %d\n"",
			       (unsigned long)VAR_9, VAR_7));
		}

	      VAR_5 += VAR_31;
	    }
	  break;

	case 0x17: /* COMMENT_7 */
	  vms_debug2 ((3, ""undocumented type 0x17\n""));
	  break;

	default:
	  vms_debug2 ((3, ""ignoring record\n""));
	  break;

	}

      VAR_1 += VAR_14;
    }

  /* COMMENT_8 */
  VAR_11 = (struct srecinfo *) bfd_zalloc (VAR_0, sizeof (struct srecinfo));
  VAR_11->line = (unsigned int) -1;
  VAR_11->srec = (unsigned int) -1;
  VAR_10->next = VAR_11;

  VAR_13 = (struct lineinfo *) bfd_zalloc (VAR_0, sizeof (struct lineinfo));
  VAR_13->line = (unsigned int) -1;
  VAR_13->address = (bfd_vma) -1;
  VAR_12->next = VAR_13;

  /* COMMENT_9 */
                                                               
                                                  
  SET_MODULE_PARSED (module);
  return true;
}",binutils-gdb/65cf035b8dc1df5d8020e0b1449514a3c42933e7/vms-alpha.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -175,15 +175,18 @@
 		       src_ptr + DST_S_B_SRC_DF_FILENAME,
 		       ptr + rec_length - (src_ptr + DST_S_B_SRC_DF_FILENAME));
 
-		    while (fileid >= module->file_table_count)
+		    if (fileid >= module->file_table_count)
 		      {
-			module->file_table_count *= 2;
+			unsigned int old_count = module->file_table_count;
+			module->file_table_count += fileid;
 			module->file_table
 			  = bfd_realloc_or_free (module->file_table,
 						 module->file_table_count
 						 * sizeof (struct fileinfo));
 			if (module->file_table == NULL)
 			  return false;
+			memset (module->file_table + old_count, 0,
+				fileid * sizeof (struct fileinfo));
 		      }
 
 		    module->file_table [fileid].name = filename;","{'deleted_lines': ['\t\t    while (fileid >= module->file_table_count)', '\t\t\tmodule->file_table_count *= 2;'], 'added_lines': ['\t\t    if (fileid >= module->file_table_count)', '\t\t\tunsigned int old_count = module->file_table_count;', '\t\t\tmodule->file_table_count += fileid;', '\t\t\tmemset (module->file_table + old_count, 0,', '\t\t\t\tfileid * sizeof (struct fileinfo));']}",True,A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.,4.7,MEDIUM,1,test,,5
CVE-2023-45862,['CWE-770'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"The allocation of PageBuffer is 512 bytes in size, but the dereferencing
of struct ms_bootblock_idi (also size 512) happens at a calculated offset
within the allocation, which means the object could potentially extend
beyond the end of the allocation. Avoid this case by just allocating
enough space to catch any accesses beyond the end. Seen with GCC 13:

../drivers/usb/storage/ene_ub6250.c: In function 'ms_lib_process_bootblock':
../drivers/usb/storage/ene_ub6250.c:1050:44: warning: array subscript 'struct ms_bootblock_idi[0]' is partly outside array bounds of 'unsigned char[512]' [-Warray-bounds=]
 1050 |                         if (le16_to_cpu(idi->wIDIgeneralConfiguration) != MS_IDI_GENERAL_CONF)
      |                                            ^~
../include/uapi/linux/byteorder/little_endian.h:37:51: note: in definition of macro '__le16_to_cpu'
   37 | #define __le16_to_cpu(x) ((__force __u16)(__le16)(x))
      |                                                   ^
../drivers/usb/storage/ene_ub6250.c:1050:29: note: in expansion of macro 'le16_to_cpu'
 1050 |                         if (le16_to_cpu(idi->wIDIgeneralConfiguration) != MS_IDI_GENERAL_CONF)
      |                             ^~~~~~~~~~~
In file included from ../drivers/usb/storage/ene_ub6250.c:5:
In function 'kmalloc',
    inlined from 'ms_lib_process_bootblock' at ../drivers/usb/storage/ene_ub6250.c:942:15:
../include/linux/slab.h:580:24: note: at offset [256, 512] into object of size 512 allocated by 'kmalloc_trace'
  580 |                 return kmalloc_trace(
      |                        ^~~~~~~~~~~~~~
  581 |                                 kmalloc_caches[kmalloc_type(flags)][index],
      |                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  582 |                                 flags, size);
      |                                 ~~~~~~~~~~~~

Cc: Alan Stern <stern@rowland.harvard.edu>
Signed-off-by: Kees Cook <keescook@chromium.org>
Link: https://lore.kernel.org/r/20230204183546.never.849-kees@kernel.org
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
",ce33e64c1788912976b61314b56935abd4bc97ef,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=ce33e64c1788912976b61314b56935abd4bc97ef,drivers/usb/storage/ene_ub6250.c,ms_lib_process_bootblock,"static int ms_lib_process_bootblock(struct us_data *us, u16 PhyBlock, u8 *PageData)
{
struct ms_bootblock_sysent *SysEntry;
struct ms_bootblock_sysinf *SysInfo;
u32 i, result;
u8 PageNumber;
u8 *PageBuffer;
struct ms_lib_type_extdat ExtraData;
struct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;
PageBuffer = kmalloc(MS_BYTES_PER_PAGE, GFP_KERNEL);
if (PageBuffer == NULL)
return (u32)-1;
result = (u32)-1;
SysInfo = &(((struct ms_bootblock_page0 *)PageData)->sysinf);
if ((SysInfo->bMsClass != MS_SYSINF_MSCLASS_TYPE_1) ||
(be16_to_cpu(SysInfo->wPageSize) != MS_SYSINF_PAGE_SIZE) ||
((SysInfo->bSecuritySupport & MS_SYSINF_SECURITY) == MS_SYSINF_SECURITY_SUPPORT) ||
(SysInfo->bReserved1 != MS_SYSINF_RESERVED1) ||
(SysInfo->bReserved2 != MS_SYSINF_RESERVED2) ||
(SysInfo->bFormatType != MS_SYSINF_FORMAT_FAT) ||
(SysInfo->bUsage != MS_SYSINF_USAGE_GENERAL))
goto exit;
switch (info->MS_Lib.cardType = SysInfo->bCardType) {
case MS_SYSINF_CARDTYPE_RDONLY:
ms_lib_ctrl_set(info, MS_LIB_CTRL_RDONLY);
break;
case MS_SYSINF_CARDTYPE_RDWR:
ms_lib_ctrl_reset(info, MS_LIB_CTRL_RDONLY);
break;
case MS_SYSINF_CARDTYPE_HYBRID:
default:
goto exit;
}
info->MS_Lib.blockSize = be16_to_cpu(SysInfo->wBlockSize);
info->MS_Lib.NumberOfPhyBlock = be16_to_cpu(SysInfo->wBlockNumber);
info->MS_Lib.NumberOfLogBlock = be16_to_cpu(SysInfo->wTotalBlockNumber)-2;
info->MS_Lib.PagesPerBlock = info->MS_Lib.blockSize * SIZE_OF_KIRO / MS_BYTES_PER_PAGE;
info->MS_Lib.NumberOfSegment = info->MS_Lib.NumberOfPhyBlock / MS_PHYSICAL_BLOCKS_PER_SEGMENT;
info->MS_Model = be16_to_cpu(SysInfo->wMemorySize);
if (ms_lib_alloc_logicalmap(us))
goto exit;
ms_lib_set_bootblockmark(us, PhyBlock);
SysEntry = &(((struct ms_bootblock_page0 *)PageData)->sysent);
for (i = 0; i < MS_NUMBER_OF_SYSTEM_ENTRY; i++) {
u32  EntryOffset, EntrySize;
EntryOffset = be32_to_cpu(SysEntry->entry[i].dwStart);
if (EntryOffset == 0xffffff)
continue;
EntrySize = be32_to_cpu(SysEntry->entry[i].dwSize);
if (EntrySize == 0)
continue;
if (EntryOffset + MS_BYTES_PER_PAGE + EntrySize > info->MS_Lib.blockSize * (u32)SIZE_OF_KIRO)
continue;
if (i == 0) {
u8 PrevPageNumber = 0;
u16 phyblk;
if (SysEntry->entry[i].bType != MS_SYSENT_TYPE_INVALID_BLOCK)
goto exit;
while (EntrySize > 0) {
PageNumber = (u8)(EntryOffset / MS_BYTES_PER_PAGE + 1);
if (PageNumber != PrevPageNumber) {
switch (ms_read_readpage(us, PhyBlock, PageNumber, (u32 *)PageBuffer, &ExtraData)) {
case MS_STATUS_SUCCESS:
break;
case MS_STATUS_WRITE_PROTECT:
case MS_ERROR_FLASH_READ:
case MS_STATUS_ERROR:
default:
goto exit;
}
PrevPageNumber = PageNumber;
}
phyblk = be16_to_cpu(*(u16 *)(PageBuffer + (EntryOffset % MS_BYTES_PER_PAGE)));
if (phyblk < 0x0fff)
ms_lib_set_initialerrorblock(us, phyblk);
EntryOffset += 2;
EntrySize -= 2;
}
} else if (i == 1) {  
struct ms_bootblock_idi *idi;
if (SysEntry->entry[i].bType != MS_SYSENT_TYPE_CIS_IDI)
goto exit;
switch (ms_read_readpage(us, PhyBlock, (u8)(EntryOffset / MS_BYTES_PER_PAGE + 1), (u32 *)PageBuffer, &ExtraData)) {
case MS_STATUS_SUCCESS:
break;
case MS_STATUS_WRITE_PROTECT:
case MS_ERROR_FLASH_READ:
case MS_STATUS_ERROR:
default:
goto exit;
}
idi = &((struct ms_bootblock_cis_idi *)(PageBuffer + (EntryOffset % MS_BYTES_PER_PAGE)))->idi.idi;
if (le16_to_cpu(idi->wIDIgeneralConfiguration) != MS_IDI_GENERAL_CONF)
goto exit;
info->MS_Lib.BytesPerSector = le16_to_cpu(idi->wIDIbytesPerSector);
if (info->MS_Lib.BytesPerSector != MS_BYTES_PER_PAGE)
goto exit;
}
} 
result = 0;
exit:
if (result)
ms_lib_free_logicalmap(us);
kfree(PageBuffer);
result = 0;
return result;
}","static int ms_lib_process_bootblock(struct us_data *VAR_0, u16 VAR_1, u8 *VAR_2)
{
struct ms_bootblock_sysent *VAR_3;
struct ms_bootblock_sysinf *VAR_4;
u32 VAR_5, VAR_6;
u8 VAR_7;
u8 *VAR_8;
struct ms_lib_type_extdat VAR_9;
struct ene_ub6250_info *VAR_10 = (struct ene_ub6250_info *) VAR_0->extra;
VAR_8 = kmalloc(VAR_11, VAR_12);
if (VAR_8 == NULL)
return (u32)-1;
VAR_6 = (u32)-1;
VAR_4 = &(((struct ms_bootblock_page0 *)VAR_2)->sysinf);
if ((VAR_4->bMsClass != VAR_13) ||
(be16_to_cpu(VAR_4->wPageSize) != VAR_14) ||
((VAR_4->bSecuritySupport & VAR_15) == VAR_16) ||
(VAR_4->bReserved1 != VAR_17) ||
(VAR_4->bReserved2 != VAR_18) ||
(VAR_4->bFormatType != VAR_19) ||
(VAR_4->bUsage != VAR_20))
goto exit;
switch (VAR_10->MS_Lib.cardType = VAR_4->bCardType) {
case VAR_21:
ms_lib_ctrl_set(VAR_10, VAR_22);
break;
case VAR_23:
ms_lib_ctrl_reset(VAR_10, VAR_22);
break;
case VAR_24:
default:
goto exit;
}
VAR_10->MS_Lib.blockSize = be16_to_cpu(VAR_4->wBlockSize);
VAR_10->MS_Lib.NumberOfPhyBlock = be16_to_cpu(VAR_4->wBlockNumber);
VAR_10->MS_Lib.NumberOfLogBlock = be16_to_cpu(VAR_4->wTotalBlockNumber)-2;
VAR_10->MS_Lib.PagesPerBlock = VAR_10->MS_Lib.blockSize * VAR_25 / VAR_11;
VAR_10->MS_Lib.NumberOfSegment = VAR_10->MS_Lib.NumberOfPhyBlock / VAR_26;
VAR_10->MS_Model = be16_to_cpu(VAR_4->wMemorySize);
if (ms_lib_alloc_logicalmap(VAR_0))
goto exit;
ms_lib_set_bootblockmark(VAR_0, VAR_1);
VAR_3 = &(((struct ms_bootblock_page0 *)VAR_2)->sysent);
for (VAR_5 = 0; VAR_5 < VAR_27; VAR_5++) {
u32  VAR_28, VAR_29;
VAR_28 = be32_to_cpu(VAR_3->entry[VAR_5].dwStart);
if (VAR_28 == 0xffffff)
continue;
VAR_29 = be32_to_cpu(VAR_3->entry[VAR_5].dwSize);
if (VAR_29 == 0)
continue;
if (VAR_28 + VAR_11 + VAR_29 > VAR_10->MS_Lib.blockSize * (u32)VAR_25)
continue;
if (VAR_5 == 0) {
u8 VAR_30 = 0;
u16 VAR_31;
if (VAR_3->entry[VAR_5].bType != VAR_32)
goto exit;
while (VAR_29 > 0) {
VAR_7 = (u8)(VAR_28 / VAR_11 + 1);
if (VAR_7 != VAR_30) {
switch (ms_read_readpage(VAR_0, VAR_1, VAR_7, (u32 *)VAR_8, &VAR_9)) {
case VAR_33:
break;
case VAR_34:
case VAR_35:
case VAR_36:
default:
goto exit;
}
VAR_30 = VAR_7;
}
VAR_31 = be16_to_cpu(*(u16 *)(VAR_8 + (VAR_28 % VAR_11)));
if (VAR_31 < 0x0fff)
ms_lib_set_initialerrorblock(VAR_0, VAR_31);
VAR_28 += 2;
VAR_29 -= 2;
}
} else if (VAR_5 == 1) {  
struct ms_bootblock_idi *VAR_37;
if (VAR_3->entry[VAR_5].bType != VAR_38)
goto exit;
switch (ms_read_readpage(VAR_0, VAR_1, (u8)(VAR_28 / VAR_11 + 1), (u32 *)VAR_8, &VAR_9)) {
case VAR_33:
break;
case VAR_34:
case VAR_35:
case VAR_36:
default:
goto exit;
}
VAR_37 = &((struct ms_bootblock_cis_idi *)(VAR_8 + (VAR_28 % VAR_11)))->idi.idi;
if (le16_to_cpu(VAR_37->wIDIgeneralConfiguration) != VAR_39)
goto exit;
VAR_10->MS_Lib.BytesPerSector = le16_to_cpu(VAR_37->wIDIbytesPerSector);
if (VAR_10->MS_Lib.BytesPerSector != VAR_11)
goto exit;
}
} 
VAR_6 = 0;
exit:
if (VAR_6)
ms_lib_free_logicalmap(VAR_0);
kfree(VAR_8);
VAR_6 = 0;
return VAR_6;
}",torvalds/linux/ce33e64c1788912976b61314b56935abd4bc97ef/ene_ub6250.c/vul/before/0.json,"static int ms_lib_process_bootblock(struct us_data *us, u16 PhyBlock, u8 *PageData)
{
	struct ms_bootblock_sysent *SysEntry;
	struct ms_bootblock_sysinf *SysInfo;
	u32 i, result;
	u8 PageNumber;
	u8 *PageBuffer;
	struct ms_lib_type_extdat ExtraData;
	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;

	PageBuffer = kzalloc(MS_BYTES_PER_PAGE * 2, GFP_KERNEL);
	if (PageBuffer == NULL)
		return (u32)-1;

	result = (u32)-1;

	SysInfo = &(((struct ms_bootblock_page0 *)PageData)->sysinf);

	if ((SysInfo->bMsClass != MS_SYSINF_MSCLASS_TYPE_1) ||
		(be16_to_cpu(SysInfo->wPageSize) != MS_SYSINF_PAGE_SIZE) ||
		((SysInfo->bSecuritySupport & MS_SYSINF_SECURITY) == MS_SYSINF_SECURITY_SUPPORT) ||
		(SysInfo->bReserved1 != MS_SYSINF_RESERVED1) ||
		(SysInfo->bReserved2 != MS_SYSINF_RESERVED2) ||
		(SysInfo->bFormatType != MS_SYSINF_FORMAT_FAT) ||
		(SysInfo->bUsage != MS_SYSINF_USAGE_GENERAL))
		goto exit;
		/* */
	switch (info->MS_Lib.cardType = SysInfo->bCardType) {
	case MS_SYSINF_CARDTYPE_RDONLY:
		ms_lib_ctrl_set(info, MS_LIB_CTRL_RDONLY);
		break;
	case MS_SYSINF_CARDTYPE_RDWR:
		ms_lib_ctrl_reset(info, MS_LIB_CTRL_RDONLY);
		break;
	case MS_SYSINF_CARDTYPE_HYBRID:
	default:
		goto exit;
	}

	info->MS_Lib.blockSize = be16_to_cpu(SysInfo->wBlockSize);
	info->MS_Lib.NumberOfPhyBlock = be16_to_cpu(SysInfo->wBlockNumber);
	info->MS_Lib.NumberOfLogBlock = be16_to_cpu(SysInfo->wTotalBlockNumber)-2;
	info->MS_Lib.PagesPerBlock = info->MS_Lib.blockSize * SIZE_OF_KIRO / MS_BYTES_PER_PAGE;
	info->MS_Lib.NumberOfSegment = info->MS_Lib.NumberOfPhyBlock / MS_PHYSICAL_BLOCKS_PER_SEGMENT;
	info->MS_Model = be16_to_cpu(SysInfo->wMemorySize);

	/*Allocate to all number of logicalblock and physicalblock */
	if (ms_lib_alloc_logicalmap(us))
		goto exit;

	/* Mark the book block */
	ms_lib_set_bootblockmark(us, PhyBlock);

	SysEntry = &(((struct ms_bootblock_page0 *)PageData)->sysent);

	for (i = 0; i < MS_NUMBER_OF_SYSTEM_ENTRY; i++) {
		u32  EntryOffset, EntrySize;

		EntryOffset = be32_to_cpu(SysEntry->entry[i].dwStart);

		if (EntryOffset == 0xffffff)
			continue;
		EntrySize = be32_to_cpu(SysEntry->entry[i].dwSize);

		if (EntrySize == 0)
			continue;

		if (EntryOffset + MS_BYTES_PER_PAGE + EntrySize > info->MS_Lib.blockSize * (u32)SIZE_OF_KIRO)
			continue;

		if (i == 0) {
			u8 PrevPageNumber = 0;
			u16 phyblk;

			if (SysEntry->entry[i].bType != MS_SYSENT_TYPE_INVALID_BLOCK)
				goto exit;

			while (EntrySize > 0) {

				PageNumber = (u8)(EntryOffset / MS_BYTES_PER_PAGE + 1);
				if (PageNumber != PrevPageNumber) {
					switch (ms_read_readpage(us, PhyBlock, PageNumber, (u32 *)PageBuffer, &ExtraData)) {
					case MS_STATUS_SUCCESS:
						break;
					case MS_STATUS_WRITE_PROTECT:
					case MS_ERROR_FLASH_READ:
					case MS_STATUS_ERROR:
					default:
						goto exit;
					}

					PrevPageNumber = PageNumber;
				}

				phyblk = be16_to_cpu(*(u16 *)(PageBuffer + (EntryOffset % MS_BYTES_PER_PAGE)));
				if (phyblk < 0x0fff)
					ms_lib_set_initialerrorblock(us, phyblk);

				EntryOffset += 2;
				EntrySize -= 2;
			}
		} else if (i == 1) {  /* CIS/IDI */
			struct ms_bootblock_idi *idi;

			if (SysEntry->entry[i].bType != MS_SYSENT_TYPE_CIS_IDI)
				goto exit;

			switch (ms_read_readpage(us, PhyBlock, (u8)(EntryOffset / MS_BYTES_PER_PAGE + 1), (u32 *)PageBuffer, &ExtraData)) {
			case MS_STATUS_SUCCESS:
				break;
			case MS_STATUS_WRITE_PROTECT:
			case MS_ERROR_FLASH_READ:
			case MS_STATUS_ERROR:
			default:
				goto exit;
			}

			idi = &((struct ms_bootblock_cis_idi *)(PageBuffer + (EntryOffset % MS_BYTES_PER_PAGE)))->idi.idi;
			if (le16_to_cpu(idi->wIDIgeneralConfiguration) != MS_IDI_GENERAL_CONF)
				goto exit;

			info->MS_Lib.BytesPerSector = le16_to_cpu(idi->wIDIbytesPerSector);
			if (info->MS_Lib.BytesPerSector != MS_BYTES_PER_PAGE)
				goto exit;
		}
	} /* End for .. */

	result = 0;

exit:
	if (result)
		ms_lib_free_logicalmap(us);

	kfree(PageBuffer);

	result = 0;
	return result;
}","static int ms_lib_process_bootblock(struct us_data *VAR_0, u16 VAR_1, u8 *VAR_2)
{
	struct ms_bootblock_sysent *VAR_3;
	struct ms_bootblock_sysinf *VAR_4;
	u32 VAR_5, VAR_6;
	u8 VAR_7;
	u8 *VAR_8;
	struct ms_lib_type_extdat VAR_9;
	struct ene_ub6250_info *VAR_10 = (struct ene_ub6250_info *) VAR_0->extra;

	VAR_8 = kzalloc(VAR_11 * 2, VAR_12);
	if (VAR_8 == NULL)
		return (u32)-1;

	VAR_6 = (u32)-1;

	VAR_4 = &(((struct ms_bootblock_page0 *)VAR_2)->sysinf);

	if ((VAR_4->bMsClass != VAR_13) ||
		(be16_to_cpu(VAR_4->wPageSize) != VAR_14) ||
		((VAR_4->bSecuritySupport & VAR_15) == VAR_16) ||
		(VAR_4->bReserved1 != VAR_17) ||
		(VAR_4->bReserved2 != VAR_18) ||
		(VAR_4->bFormatType != VAR_19) ||
		(VAR_4->bUsage != VAR_20))
		goto exit;
		/* COMMENT_0 */
	switch (VAR_10->MS_Lib.cardType = VAR_4->bCardType) {
	case VAR_21:
		ms_lib_ctrl_set(VAR_10, VAR_22);
		break;
	case VAR_23:
		ms_lib_ctrl_reset(VAR_10, VAR_22);
		break;
	case VAR_24:
	default:
		goto exit;
	}

	VAR_10->MS_Lib.blockSize = be16_to_cpu(VAR_4->wBlockSize);
	VAR_10->MS_Lib.NumberOfPhyBlock = be16_to_cpu(VAR_4->wBlockNumber);
	VAR_10->MS_Lib.NumberOfLogBlock = be16_to_cpu(VAR_4->wTotalBlockNumber)-2;
	VAR_10->MS_Lib.PagesPerBlock = VAR_10->MS_Lib.blockSize * VAR_25 / VAR_11;
	VAR_10->MS_Lib.NumberOfSegment = VAR_10->MS_Lib.NumberOfPhyBlock / VAR_26;
	VAR_10->MS_Model = be16_to_cpu(VAR_4->wMemorySize);

	/* COMMENT_1 */
	if (ms_lib_alloc_logicalmap(VAR_0))
		goto exit;

	/* COMMENT_2 */
	ms_lib_set_bootblockmark(VAR_0, VAR_1);

	VAR_3 = &(((struct ms_bootblock_page0 *)VAR_2)->sysent);

	for (VAR_5 = 0; VAR_5 < VAR_27; VAR_5++) {
		u32  VAR_28, VAR_29;

		VAR_28 = be32_to_cpu(VAR_3->entry[VAR_5].dwStart);

		if (VAR_28 == 0xffffff)
			continue;
		VAR_29 = be32_to_cpu(VAR_3->entry[VAR_5].dwSize);

		if (VAR_29 == 0)
			continue;

		if (VAR_28 + VAR_11 + VAR_29 > VAR_10->MS_Lib.blockSize * (u32)VAR_25)
			continue;

		if (VAR_5 == 0) {
			u8 VAR_30 = 0;
			u16 VAR_31;

			if (VAR_3->entry[VAR_5].bType != VAR_32)
				goto exit;

			while (VAR_29 > 0) {

				VAR_7 = (u8)(VAR_28 / VAR_11 + 1);
				if (VAR_7 != VAR_30) {
					switch (ms_read_readpage(VAR_0, VAR_1, VAR_7, (u32 *)VAR_8, &VAR_9)) {
					case VAR_33:
						break;
					case VAR_34:
					case VAR_35:
					case VAR_36:
					default:
						goto exit;
					}

					VAR_30 = VAR_7;
				}

				VAR_31 = be16_to_cpu(*(u16 *)(VAR_8 + (VAR_28 % VAR_11)));
				if (VAR_31 < 0x0fff)
					ms_lib_set_initialerrorblock(VAR_0, VAR_31);

				VAR_28 += 2;
				VAR_29 -= 2;
			}
		} else if (VAR_5 == 1) {  /* COMMENT_3 */
			struct ms_bootblock_idi *VAR_37;

			if (VAR_3->entry[VAR_5].bType != VAR_38)
				goto exit;

			switch (ms_read_readpage(VAR_0, VAR_1, (u8)(VAR_28 / VAR_11 + 1), (u32 *)VAR_8, &VAR_9)) {
			case VAR_33:
				break;
			case VAR_34:
			case VAR_35:
			case VAR_36:
			default:
				goto exit;
			}

			VAR_37 = &((struct ms_bootblock_cis_idi *)(VAR_8 + (VAR_28 % VAR_11)))->idi.idi;
			if (le16_to_cpu(VAR_37->wIDIgeneralConfiguration) != VAR_39)
				goto exit;

			VAR_10->MS_Lib.BytesPerSector = le16_to_cpu(VAR_37->wIDIbytesPerSector);
			if (VAR_10->MS_Lib.BytesPerSector != VAR_11)
				goto exit;
		}
	} /* COMMENT_4 */

	VAR_6 = 0;

exit:
	if (VAR_6)
		ms_lib_free_logicalmap(VAR_0);

	kfree(VAR_8);

	VAR_6 = 0;
	return VAR_6;
}",torvalds/linux/ce33e64c1788912976b61314b56935abd4bc97ef/ene_ub6250.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,7 +8,7 @@
 	struct ms_lib_type_extdat ExtraData;
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;
 
-	PageBuffer = kmalloc(MS_BYTES_PER_PAGE, GFP_KERNEL);
+	PageBuffer = kzalloc(MS_BYTES_PER_PAGE * 2, GFP_KERNEL);
 	if (PageBuffer == NULL)
 		return (u32)-1;
 ","{'deleted_lines': ['\tPageBuffer = kmalloc(MS_BYTES_PER_PAGE, GFP_KERNEL);'], 'added_lines': ['\tPageBuffer = kzalloc(MS_BYTES_PER_PAGE * 2, GFP_KERNEL);']}",True,An issue was discovered in drivers/usb/storage/ene_ub6250.c for the ENE UB6250 reader driver in the Linux kernel before 6.2.5. An object could potentially extend beyond the end of an allocation.,7.5,HIGH,2,test,,5
CVE-2023-40129,['CWE-787'],CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,android,"Fix an integer underflow in build_read_multi_rsp

When p_buf->len is mtu - 1 and p_cmd->multi_req.variable_len
evaluates to true, integer underflow is triggered
in the following line, resulting OOB access.

```
 len = p_rsp->attr_value.len - (total_len - mtu);
```

Bug: 273874525
Test: manual
Ignore-AOSP-First: security
Tag: #security
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:85f4d53c7bf90b806639a3a302f0007ffb3b9f23)
Merged-In: Ia60dd829ff9152c083de1f4c1265bb3ad595dcc4
Change-Id: Ia60dd829ff9152c083de1f4c1265bb3ad595dcc4
",c0151aa3ba76c785b32c7f9d16c98febe53017b1,https://android.googlesource.com/platform/packages/modules/Bluetooth/+/c0151aa3ba76c785b32c7f9d16c98febe53017b1,system/stack/gatt/gatt_sr.cc,build_read_multi_rsp,"static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {
uint16_t ii;
size_t total_len, len;
uint8_t* p;
bool is_overflow = false;
len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;
BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);
p_buf->offset = L2CAP_MIN_OFFSET;
p = (uint8_t*)(p_buf + 1) + p_buf->offset;
if (p_cmd->multi_req.variable_len)
*p++ = GATT_RSP_READ_MULTI_VAR;
else
*p++ = GATT_RSP_READ_MULTI;
p_buf->len = 1;
list_t* list = NULL;
const list_node_t* node = NULL;
if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))
list = fixed_queue_get_list(p_cmd->multi_rsp_q);
for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {
tGATTS_RSP* p_rsp = NULL;
if (list != NULL) {
if (ii == 0)
node = list_begin(list);
else
node = list_next(node);
if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);
}
if (p_rsp != NULL) {
total_len = (p_buf->len + p_rsp->attr_value.len);
if (p_cmd->multi_req.variable_len) {
total_len += 2;
}
if (total_len > mtu) {
len = p_rsp->attr_value.len - (total_len - mtu);
is_overflow = true;
VLOG(1) << StringPrintf(
""multi read overflow available len=%zu val_len=%d"", len,
p_rsp->attr_value.len);
} else {
len = p_rsp->attr_value.len;
}
if (p_cmd->multi_req.variable_len) {
UINT16_TO_STREAM(p, len);
p_buf->len += 2;
}
if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {
if (p_buf->len + len <= UINT16_MAX) {
memcpy(p, p_rsp->attr_value.value, len);
if (!is_overflow) p += len;
p_buf->len += len;
} else {
p_cmd->status = GATT_NOT_FOUND;
break;
}
} else {
p_cmd->status = GATT_NOT_FOUND;
break;
}
if (is_overflow) break;
} else {
p_cmd->status = GATT_NOT_FOUND;
break;
}
} 
if (p_buf->len == 0) {
LOG(ERROR) << __func__ << "" nothing found!!"";
p_cmd->status = GATT_NOT_FOUND;
osi_free(p_buf);
VLOG(1) << __func__ << ""osi_free(p_buf)"";
} else if (p_cmd->p_rsp_msg != NULL) {
osi_free(p_buf);
} else {
p_cmd->p_rsp_msg = p_buf;
}
}","static void build_read_multi_rsp(tGATT_SR_CMD* VAR_0, uint16_t VAR_1) {
uint16_t VAR_2;
size_t VAR_3, VAR_4;
uint8_t* VAR_5;
bool VAR_6 = false;
VAR_4 = sizeof(VAR_7) + VAR_8 + VAR_1;
BT_HDR* VAR_9 = (BT_HDR*)osi_calloc(VAR_4);
VAR_9->offset = VAR_8;
VAR_5 = (uint8_t*)(VAR_9 + 1) + VAR_9->offset;
if (VAR_0->multi_req.variable_len)
*VAR_5++ = VAR_10;
else
*VAR_5++ = VAR_11;
VAR_9->len = 1;
list_t* VAR_12 = NULL;
const list_node_t* VAR_13 = NULL;
if (!fixed_queue_is_empty(VAR_0->multi_rsp_q))
VAR_12 = fixed_queue_get_list(VAR_0->multi_rsp_q);
for (VAR_2 = 0; VAR_2 < VAR_0->multi_req.num_handles; VAR_2++) {
tGATTS_RSP* VAR_14 = NULL;
if (VAR_12 != NULL) {
if (VAR_2 == 0)
VAR_13 = list_begin(VAR_12);
else
VAR_13 = list_next(VAR_13);
if (VAR_13 != list_end(VAR_12)) VAR_14 = (tGATTS_RSP*)list_node(VAR_13);
}
if (VAR_14 != NULL) {
VAR_3 = (VAR_9->len + VAR_14->attr_value.len);
if (VAR_0->multi_req.variable_len) {
VAR_3 += 2;
}
if (VAR_3 > VAR_1) {
VAR_4 = VAR_14->attr_value.len - (VAR_3 - VAR_1);
VAR_6 = true;
VLOG(1) << StringPrintf(
""multi read overflow available len=%zu val_len=%d"", VAR_4,
VAR_14->attr_value.len);
} else {
VAR_4 = VAR_14->attr_value.len;
}
if (VAR_0->multi_req.variable_len) {
UINT16_TO_STREAM(VAR_5, VAR_4);
VAR_9->len += 2;
}
if (VAR_14->attr_value.handle == VAR_0->multi_req.handles[VAR_2]) {
if (VAR_9->len + VAR_4 <= VAR_15) {
memcpy(VAR_5, VAR_14->attr_value.value, VAR_4);
if (!VAR_6) VAR_5 += VAR_4;
VAR_9->len += VAR_4;
} else {
VAR_0->status = VAR_16;
break;
}
} else {
VAR_0->status = VAR_16;
break;
}
if (VAR_6) break;
} else {
VAR_0->status = VAR_16;
break;
}
} 
if (VAR_9->len == 0) {
LOG(VAR_17) << VAR_18 << "" nothing found!!"";
VAR_0->status = VAR_16;
osi_free(VAR_9);
VLOG(1) << VAR_18 << ""osi_free(p_buf)"";
} else if (VAR_0->p_rsp_msg != NULL) {
osi_free(VAR_9);
} else {
VAR_0->p_rsp_msg = VAR_9;
}
}",android/c0151aa3ba76c785b32c7f9d16c98febe53017b1/gatt_sr.cc/vul/before/0.json,"static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) {
  uint16_t ii;
  size_t total_len, len;
  uint8_t* p;
  bool is_overflow = false;

  len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu;
  BT_HDR* p_buf = (BT_HDR*)osi_calloc(len);
  p_buf->offset = L2CAP_MIN_OFFSET;
  p = (uint8_t*)(p_buf + 1) + p_buf->offset;

  /* First byte in the response is the opcode */
  if (p_cmd->multi_req.variable_len)
    *p++ = GATT_RSP_READ_MULTI_VAR;
  else
    *p++ = GATT_RSP_READ_MULTI;

  p_buf->len = 1;

  /* Now walk through the buffers putting the data into the response in order
   */
  list_t* list = NULL;
  const list_node_t* node = NULL;
  if (!fixed_queue_is_empty(p_cmd->multi_rsp_q))
    list = fixed_queue_get_list(p_cmd->multi_rsp_q);
  for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) {
    tGATTS_RSP* p_rsp = NULL;

    if (list != NULL) {
      if (ii == 0)
        node = list_begin(list);
      else
        node = list_next(node);
      if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node);
    }

    if (p_rsp != NULL) {
      total_len = p_buf->len;
      if (p_cmd->multi_req.variable_len) {
        total_len += 2;
      }

      if (total_len > mtu) {
        VLOG(1) << ""Buffer space not enough for this data item, skipping"";
        break;
      }

      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);

      if (len == 0) {
        VLOG(1) << ""Buffer space not enough for this data item, skipping"";
        break;
      }

      if (len < p_rsp->attr_value.len) {
        is_overflow = true;
        VLOG(1) << StringPrintf(
            ""multi read overflow available len=%zu val_len=%d"", len,
            p_rsp->attr_value.len);
      }

      if (p_cmd->multi_req.variable_len) {
        UINT16_TO_STREAM(p, (uint16_t) len);
        p_buf->len += 2;
      }

      if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {
        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);
        p_buf->len += (uint16_t) len;
      } else {
        p_cmd->status = GATT_NOT_FOUND;
        break;
      }

      if (is_overflow) break;

    } else {
      p_cmd->status = GATT_NOT_FOUND;
      break;
    }

  } /* loop through all handles*/

  /* Sanity check on the buffer length */
  if (p_buf->len == 0) {
    LOG(ERROR) << __func__ << "" nothing found!!"";
    p_cmd->status = GATT_NOT_FOUND;
    osi_free(p_buf);
    VLOG(1) << __func__ << ""osi_free(p_buf)"";
  } else if (p_cmd->p_rsp_msg != NULL) {
    osi_free(p_buf);
  } else {
    p_cmd->p_rsp_msg = p_buf;
  }
}","static void build_read_multi_rsp(tGATT_SR_CMD* VAR_0, uint16_t VAR_1) {
  uint16_t VAR_2;
  size_t VAR_3, VAR_4;
  uint8_t* VAR_5;
  bool VAR_6 = false;

  VAR_4 = sizeof(VAR_7) + VAR_8 + VAR_1;
  BT_HDR* VAR_9 = (BT_HDR*)osi_calloc(VAR_4);
  VAR_9->offset = VAR_8;
  VAR_5 = (uint8_t*)(VAR_9 + 1) + VAR_9->offset;

  /* COMMENT_0 */
  if (VAR_0->multi_req.variable_len)
    *VAR_5++ = VAR_10;
  else
    *VAR_5++ = VAR_11;

  VAR_9->len = 1;

  /* COMMENT_1 */
     
  list_t* VAR_12 = NULL;
  const list_node_t* VAR_13 = NULL;
  if (!fixed_queue_is_empty(VAR_0->multi_rsp_q))
    VAR_12 = fixed_queue_get_list(VAR_0->multi_rsp_q);
  for (VAR_2 = 0; VAR_2 < VAR_0->multi_req.num_handles; VAR_2++) {
    tGATTS_RSP* VAR_14 = NULL;

    if (VAR_12 != NULL) {
      if (VAR_2 == 0)
        VAR_13 = list_begin(VAR_12);
      else
        VAR_13 = list_next(VAR_13);
      if (VAR_13 != list_end(VAR_12)) VAR_14 = (tGATTS_RSP*)list_node(VAR_13);
    }

    if (VAR_14 != NULL) {
      VAR_3 = VAR_9->len;
      if (VAR_0->multi_req.variable_len) {
        VAR_3 += 2;
      }

      if (VAR_3 > VAR_1) {
        VLOG(1) << ""Buffer space not enough for this data item, skipping"";
        break;
      }

      VAR_4 = std::min((size_t) VAR_14->attr_value.len, VAR_1 - VAR_3);

      if (VAR_4 == 0) {
        VLOG(1) << ""Buffer space not enough for this data item, skipping"";
        break;
      }

      if (VAR_4 < VAR_14->attr_value.len) {
        VAR_6 = true;
        VLOG(1) << StringPrintf(
            ""multi read overflow available len=%zu val_len=%d"", VAR_4,
            VAR_14->attr_value.len);
      }

      if (VAR_0->multi_req.variable_len) {
        UINT16_TO_STREAM(VAR_5, (uint16_t) VAR_4);
        VAR_9->len += 2;
      }

      if (VAR_14->attr_value.handle == VAR_0->multi_req.handles[VAR_2]) {
        ARRAY_TO_STREAM(VAR_5, VAR_14->attr_value.value, (uint16_t) VAR_4);
        VAR_9->len += (uint16_t) VAR_4;
      } else {
        VAR_0->status = VAR_15;
        break;
      }

      if (VAR_6) break;

    } else {
      VAR_0->status = VAR_15;
      break;
    }

  } /* COMMENT_3 */

  /* COMMENT_4 */
  if (VAR_9->len == 0) {
    LOG(VAR_16) << VAR_17 << "" nothing found!!"";
    VAR_0->status = VAR_15;
    osi_free(VAR_9);
    VLOG(1) << VAR_17 << ""osi_free(p_buf)"";
  } else if (VAR_0->p_rsp_msg != NULL) {
    osi_free(VAR_9);
  } else {
    VAR_0->p_rsp_msg = VAR_9;
  }
}",android/c0151aa3ba76c785b32c7f9d16c98febe53017b1/gatt_sr.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -35,37 +35,38 @@
     }
 
     if (p_rsp != NULL) {
-      total_len = (p_buf->len + p_rsp->attr_value.len);
+      total_len = p_buf->len;
       if (p_cmd->multi_req.variable_len) {
         total_len += 2;
       }
 
       if (total_len > mtu) {
-        /* just send the partial response for the overflow case */
-        len = p_rsp->attr_value.len - (total_len - mtu);
+        VLOG(1) << ""Buffer space not enough for this data item, skipping"";
+        break;
+      }
+
+      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);
+
+      if (len == 0) {
+        VLOG(1) << ""Buffer space not enough for this data item, skipping"";
+        break;
+      }
+
+      if (len < p_rsp->attr_value.len) {
         is_overflow = true;
         VLOG(1) << StringPrintf(
             ""multi read overflow available len=%zu val_len=%d"", len,
             p_rsp->attr_value.len);
-      } else {
-        len = p_rsp->attr_value.len;
       }
 
       if (p_cmd->multi_req.variable_len) {
-        UINT16_TO_STREAM(p, len);
+        UINT16_TO_STREAM(p, (uint16_t) len);
         p_buf->len += 2;
       }
 
       if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) {
-        // check for possible integer overflow
-        if (p_buf->len + len <= UINT16_MAX) {
-          memcpy(p, p_rsp->attr_value.value, len);
-          if (!is_overflow) p += len;
-          p_buf->len += len;
-        } else {
-          p_cmd->status = GATT_NOT_FOUND;
-          break;
-        }
+        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);
+        p_buf->len += (uint16_t) len;
       } else {
         p_cmd->status = GATT_NOT_FOUND;
         break;","{'deleted_lines': ['      total_len = (p_buf->len + p_rsp->attr_value.len);', '        /* just send the partial response for the overflow case */', '        len = p_rsp->attr_value.len - (total_len - mtu);', '      } else {', '        len = p_rsp->attr_value.len;', '        UINT16_TO_STREAM(p, len);', '        // check for possible integer overflow', '        if (p_buf->len + len <= UINT16_MAX) {', '          memcpy(p, p_rsp->attr_value.value, len);', '          if (!is_overflow) p += len;', '          p_buf->len += len;', '        } else {', '          p_cmd->status = GATT_NOT_FOUND;', '          break;', '        }'], 'added_lines': ['      total_len = p_buf->len;', '        VLOG(1) << ""Buffer space not enough for this data item, skipping"";', '        break;', '      }', '', '      len = std::min((size_t) p_rsp->attr_value.len, mtu - total_len);', '', '      if (len == 0) {', '        VLOG(1) << ""Buffer space not enough for this data item, skipping"";', '        break;', '      }', '', '      if (len < p_rsp->attr_value.len) {', '        UINT16_TO_STREAM(p, (uint16_t) len);', '        ARRAY_TO_STREAM(p, p_rsp->attr_value.value, (uint16_t) len);', '        p_buf->len += (uint16_t) len;']}",True,"In build_read_multi_rsp of gatt_sr.cc, there is a possible out of bounds write due to a heap buffer overflow. This could lead to remote (proximal/adjacent) code execution with no additional execution privileges needed. User interaction is not needed for exploitation.",8.8,HIGH,2,test,,5
CVE-2020-25668,['CWE-662'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"Some of the font tty ioctl's always used the current foreground VC for
their operations.  Don't do that then.

This fixes a data race on fg_console.

Side note: both Michael Ellerman and Jiri Slaby point out that all these
ioctls are deprecated, and should probably have been removed long ago,
and everything seems to be using the KDFONTOP ioctl instead.

In fact, Michael points out that it looks like busybox's loadfont
program seems to have switched over to using KDFONTOP exactly _because_
of this bug (ahem.. 12 years ago ;-).

Reported-by: Minh Yuan <yuanmingbuaa@gmail.com>
Acked-by: Michael Ellerman <mpe@ellerman.id.au>
Acked-by: Jiri Slaby <jirislaby@kernel.org>
Cc: Greg KH <greg@kroah.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
",90bfdeef83f1d6c696039b6a917190dcbbad3220,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit?h=90bfdeef83f1d6c696039b6a917190dcbbad3220,drivers/tty/vt/vt_ioctl.c,compat_fontx_ioctl,"static inline int
compat_fontx_ioctl(int cmd, struct compat_consolefontdesc __user *user_cfd,
int perm, struct console_font_op *op)
{
struct compat_consolefontdesc cfdarg;
int i;
if (copy_from_user(&cfdarg, user_cfd, sizeof(struct compat_consolefontdesc)))
return -EFAULT;
switch (cmd) {
case PIO_FONTX:
if (!perm)
return -EPERM;
op->op = KD_FONT_OP_SET;
op->flags = KD_FONT_FLAG_OLD;
op->width = 8;
op->height = cfdarg.charheight;
op->charcount = cfdarg.charcount;
op->data = compat_ptr(cfdarg.chardata);
return con_font_op(vc_cons[fg_console].d, op);
case GIO_FONTX:
op->op = KD_FONT_OP_GET;
op->flags = KD_FONT_FLAG_OLD;
op->width = 8;
op->height = cfdarg.charheight;
op->charcount = cfdarg.charcount;
op->data = compat_ptr(cfdarg.chardata);
i = con_font_op(vc_cons[fg_console].d, op);
if (i)
return i;
cfdarg.charheight = op->height;
cfdarg.charcount = op->charcount;
if (copy_to_user(user_cfd, &cfdarg, sizeof(struct compat_consolefontdesc)))
return -EFAULT;
return 0;
}
return -EINVAL;
}","static inline int
compat_fontx_ioctl(int VAR_0, struct compat_consolefontdesc __user *VAR_1,
int VAR_2, struct console_font_op *VAR_3)
{
struct compat_consolefontdesc VAR_4;
int VAR_5;
if (copy_from_user(&VAR_4, VAR_1, sizeof(struct compat_consolefontdesc)))
return -VAR_6;
switch (VAR_0) {
case VAR_7:
if (!VAR_2)
return -VAR_8;
VAR_3->op = VAR_9;
VAR_3->flags = VAR_10;
VAR_3->width = 8;
VAR_3->height = VAR_4.charheight;
VAR_3->charcount = VAR_4.charcount;
VAR_3->data = compat_ptr(VAR_4.chardata);
return con_font_op(VAR_11[VAR_12].d, VAR_3);
case VAR_13:
VAR_3->op = VAR_14;
VAR_3->flags = VAR_10;
VAR_3->width = 8;
VAR_3->height = VAR_4.charheight;
VAR_3->charcount = VAR_4.charcount;
VAR_3->data = compat_ptr(VAR_4.chardata);
VAR_5 = con_font_op(VAR_11[VAR_12].d, VAR_3);
if (VAR_5)
return VAR_5;
VAR_4.charheight = VAR_3->height;
VAR_4.charcount = VAR_3->charcount;
if (copy_to_user(VAR_1, &VAR_4, sizeof(struct compat_consolefontdesc)))
return -VAR_6;
return 0;
}
return -VAR_15;
}",,"static inline int
compat_fontx_ioctl(struct vc_data *vc, int cmd,
		   struct compat_consolefontdesc __user *user_cfd,
		   int perm, struct console_font_op *op)
{
	struct compat_consolefontdesc cfdarg;
	int i;

	if (copy_from_user(&cfdarg, user_cfd, sizeof(struct compat_consolefontdesc)))
		return -EFAULT;

	switch (cmd) {
	case PIO_FONTX:
		if (!perm)
			return -EPERM;
		op->op = KD_FONT_OP_SET;
		op->flags = KD_FONT_FLAG_OLD;
		op->width = 8;
		op->height = cfdarg.charheight;
		op->charcount = cfdarg.charcount;
		op->data = compat_ptr(cfdarg.chardata);
		return con_font_op(vc, op);

	case GIO_FONTX:
		op->op = KD_FONT_OP_GET;
		op->flags = KD_FONT_FLAG_OLD;
		op->width = 8;
		op->height = cfdarg.charheight;
		op->charcount = cfdarg.charcount;
		op->data = compat_ptr(cfdarg.chardata);
		i = con_font_op(vc, op);
		if (i)
			return i;
		cfdarg.charheight = op->height;
		cfdarg.charcount = op->charcount;
		if (copy_to_user(user_cfd, &cfdarg, sizeof(struct compat_consolefontdesc)))
			return -EFAULT;
		return 0;
	}
	return -EINVAL;
}","static inline int
compat_fontx_ioctl(struct vc_data *VAR_0, int VAR_1,
		   struct compat_consolefontdesc __user *VAR_2,
		   int VAR_3, struct console_font_op *VAR_4)
{
	struct compat_consolefontdesc VAR_5;
	int VAR_6;

	if (copy_from_user(&VAR_5, VAR_2, sizeof(struct compat_consolefontdesc)))
		return -VAR_7;

	switch (VAR_1) {
	case VAR_8:
		if (!VAR_3)
			return -VAR_9;
		VAR_4->op = VAR_10;
		VAR_4->flags = VAR_11;
		VAR_4->width = 8;
		VAR_4->height = VAR_5.charheight;
		VAR_4->charcount = VAR_5.charcount;
		VAR_4->data = compat_ptr(VAR_5.chardata);
		return con_font_op(VAR_0, VAR_4);

	case VAR_12:
		VAR_4->op = VAR_13;
		VAR_4->flags = VAR_11;
		VAR_4->width = 8;
		VAR_4->height = VAR_5.charheight;
		VAR_4->charcount = VAR_5.charcount;
		VAR_4->data = compat_ptr(VAR_5.chardata);
		VAR_6 = con_font_op(VAR_0, VAR_4);
		if (VAR_6)
			return VAR_6;
		VAR_5.charheight = VAR_4->height;
		VAR_5.charcount = VAR_4->charcount;
		if (copy_to_user(VAR_2, &VAR_5, sizeof(struct compat_consolefontdesc)))
			return -VAR_7;
		return 0;
	}
	return -VAR_14;
}",,"--- func_before
+++ func_after
@@ -1,6 +1,7 @@
 static inline int
-compat_fontx_ioctl(int cmd, struct compat_consolefontdesc __user *user_cfd,
-			 int perm, struct console_font_op *op)
+compat_fontx_ioctl(struct vc_data *vc, int cmd,
+		   struct compat_consolefontdesc __user *user_cfd,
+		   int perm, struct console_font_op *op)
 {
 	struct compat_consolefontdesc cfdarg;
 	int i;
@@ -18,7 +19,8 @@
 		op->height = cfdarg.charheight;
 		op->charcount = cfdarg.charcount;
 		op->data = compat_ptr(cfdarg.chardata);
-		return con_font_op(vc_cons[fg_console].d, op);
+		return con_font_op(vc, op);
+
 	case GIO_FONTX:
 		op->op = KD_FONT_OP_GET;
 		op->flags = KD_FONT_FLAG_OLD;
@@ -26,7 +28,7 @@
 		op->height = cfdarg.charheight;
 		op->charcount = cfdarg.charcount;
 		op->data = compat_ptr(cfdarg.chardata);
-		i = con_font_op(vc_cons[fg_console].d, op);
+		i = con_font_op(vc, op);
 		if (i)
 			return i;
 		cfdarg.charheight = op->height;","{'deleted_lines': ['compat_fontx_ioctl(int cmd, struct compat_consolefontdesc __user *user_cfd,', '\t\t\t int perm, struct console_font_op *op)', '\t\treturn con_font_op(vc_cons[fg_console].d, op);', '\t\ti = con_font_op(vc_cons[fg_console].d, op);'], 'added_lines': ['compat_fontx_ioctl(struct vc_data *vc, int cmd,', '\t\t   struct compat_consolefontdesc __user *user_cfd,', '\t\t   int perm, struct console_font_op *op)', '\t\treturn con_font_op(vc, op);', '', '\t\ti = con_font_op(vc, op);']}",True,A flaw was found in Linux Kernel because access to the global variable fg_console is not properly synchronized leading to a use after free in con_font_op.,7.0,HIGH,2,test,,5
CVE-2020-25668,['CWE-662'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"Some of the font tty ioctl's always used the current foreground VC for
their operations.  Don't do that then.

This fixes a data race on fg_console.

Side note: both Michael Ellerman and Jiri Slaby point out that all these
ioctls are deprecated, and should probably have been removed long ago,
and everything seems to be using the KDFONTOP ioctl instead.

In fact, Michael points out that it looks like busybox's loadfont
program seems to have switched over to using KDFONTOP exactly _because_
of this bug (ahem.. 12 years ago ;-).

Reported-by: Minh Yuan <yuanmingbuaa@gmail.com>
Acked-by: Michael Ellerman <mpe@ellerman.id.au>
Acked-by: Jiri Slaby <jirislaby@kernel.org>
Cc: Greg KH <greg@kroah.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
",90bfdeef83f1d6c696039b6a917190dcbbad3220,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit?h=90bfdeef83f1d6c696039b6a917190dcbbad3220,drivers/tty/vt/vt_ioctl.c,vt_io_ioctl,"static int vt_io_ioctl(struct vc_data *vc, unsigned int cmd, void __user *up,
bool perm)
{
struct console_font_op op;
switch (cmd) {
case PIO_FONT:
if (!perm)
return -EPERM;
op.op = KD_FONT_OP_SET;
op.flags = KD_FONT_FLAG_OLD | KD_FONT_FLAG_DONT_RECALC;
op.width = 8;
op.height = 0;
op.charcount = 256;
op.data = up;
return con_font_op(vc_cons[fg_console].d, &op);
case GIO_FONT:
op.op = KD_FONT_OP_GET;
op.flags = KD_FONT_FLAG_OLD;
op.width = 8;
op.height = 32;
op.charcount = 256;
op.data = up;
return con_font_op(vc_cons[fg_console].d, &op);
case PIO_CMAP:
if (!perm)
return -EPERM;
return con_set_cmap(up);
case GIO_CMAP:
return con_get_cmap(up);
case PIO_FONTX:
if (!perm)
return -EPERM;
fallthrough;
case GIO_FONTX:
return do_fontx_ioctl(cmd, up, &op);
case PIO_FONTRESET:
if (!perm)
return -EPERM;
return vt_io_fontreset(&op);
case PIO_SCRNMAP:
if (!perm)
return -EPERM;
return con_set_trans_old(up);
case GIO_SCRNMAP:
return con_get_trans_old(up);
case PIO_UNISCRNMAP:
if (!perm)
return -EPERM;
return con_set_trans_new(up);
case GIO_UNISCRNMAP:
return con_get_trans_new(up);
case PIO_UNIMAPCLR:
if (!perm)
return -EPERM;
con_clear_unimap(vc);
break;
case PIO_UNIMAP:
case GIO_UNIMAP:
return do_unimap_ioctl(cmd, up, perm, vc);
default:
return -ENOIOCTLCMD;
}
return 0;
}","static int vt_io_ioctl(struct vc_data *VAR_0, unsigned int VAR_1, void __user *VAR_2,
bool VAR_3)
{
struct console_font_op VAR_4;
switch (VAR_1) {
case VAR_5:
if (!VAR_3)
return -VAR_6;
VAR_4.op = VAR_7;
VAR_4.flags = VAR_8 | VAR_9;
VAR_4.width = 8;
VAR_4.height = 0;
VAR_4.charcount = 256;
VAR_4.data = VAR_2;
return con_font_op(VAR_10[VAR_11].d, &VAR_4);
case VAR_12:
VAR_4.op = VAR_13;
VAR_4.flags = VAR_8;
VAR_4.width = 8;
VAR_4.height = 32;
VAR_4.charcount = 256;
VAR_4.data = VAR_2;
return con_font_op(VAR_10[VAR_11].d, &VAR_4);
case VAR_14:
if (!VAR_3)
return -VAR_6;
return con_set_cmap(VAR_2);
case VAR_15:
return con_get_cmap(VAR_2);
case VAR_16:
if (!VAR_3)
return -VAR_6;
VAR_17;
case VAR_18:
return do_fontx_ioctl(VAR_1, VAR_2, &VAR_4);
case VAR_19:
if (!VAR_3)
return -VAR_6;
return vt_io_fontreset(&VAR_4);
case VAR_20:
if (!VAR_3)
return -VAR_6;
return con_set_trans_old(VAR_2);
case VAR_21:
return con_get_trans_old(VAR_2);
case VAR_22:
if (!VAR_3)
return -VAR_6;
return con_set_trans_new(VAR_2);
case VAR_23:
return con_get_trans_new(VAR_2);
case VAR_24:
if (!VAR_3)
return -VAR_6;
con_clear_unimap(VAR_0);
break;
case VAR_25:
case VAR_26:
return do_unimap_ioctl(VAR_1, VAR_2, VAR_3, VAR_0);
default:
return -VAR_27;
}
return 0;
}",,"static int vt_io_ioctl(struct vc_data *vc, unsigned int cmd, void __user *up,
		bool perm)
{
	struct console_font_op op;	/* used in multiple places here */

	switch (cmd) {
	case PIO_FONT:
		if (!perm)
			return -EPERM;
		op.op = KD_FONT_OP_SET;
		op.flags = KD_FONT_FLAG_OLD | KD_FONT_FLAG_DONT_RECALC;	/* Compatibility */
		op.width = 8;
		op.height = 0;
		op.charcount = 256;
		op.data = up;
		return con_font_op(vc, &op);

	case GIO_FONT:
		op.op = KD_FONT_OP_GET;
		op.flags = KD_FONT_FLAG_OLD;
		op.width = 8;
		op.height = 32;
		op.charcount = 256;
		op.data = up;
		return con_font_op(vc, &op);

	case PIO_CMAP:
                if (!perm)
			return -EPERM;
		return con_set_cmap(up);

	case GIO_CMAP:
                return con_get_cmap(up);

	case PIO_FONTX:
		if (!perm)
			return -EPERM;

		fallthrough;
	case GIO_FONTX:
		return do_fontx_ioctl(vc, cmd, up, &op);

	case PIO_FONTRESET:
		if (!perm)
			return -EPERM;

		return vt_io_fontreset(vc, &op);

	case PIO_SCRNMAP:
		if (!perm)
			return -EPERM;
		return con_set_trans_old(up);

	case GIO_SCRNMAP:
		return con_get_trans_old(up);

	case PIO_UNISCRNMAP:
		if (!perm)
			return -EPERM;
		return con_set_trans_new(up);

	case GIO_UNISCRNMAP:
		return con_get_trans_new(up);

	case PIO_UNIMAPCLR:
		if (!perm)
			return -EPERM;
		con_clear_unimap(vc);
		break;

	case PIO_UNIMAP:
	case GIO_UNIMAP:
		return do_unimap_ioctl(cmd, up, perm, vc);

	default:
		return -ENOIOCTLCMD;
	}

	return 0;
}","static int vt_io_ioctl(struct vc_data *VAR_0, unsigned int VAR_1, void __user *VAR_2,
		bool VAR_3)
{
	struct console_font_op VAR_4;	/* COMMENT_0 */

	switch (VAR_1) {
	case VAR_5:
		if (!VAR_3)
			return -VAR_6;
		VAR_4.op = VAR_7;
		VAR_4.flags = VAR_8 | VAR_9;	/* COMMENT_1 */
		VAR_4.width = 8;
		VAR_4.height = 0;
		VAR_4.charcount = 256;
		VAR_4.data = VAR_2;
		return con_font_op(VAR_0, &VAR_4);

	case VAR_10:
		VAR_4.op = VAR_11;
		VAR_4.flags = VAR_8;
		VAR_4.width = 8;
		VAR_4.height = 32;
		VAR_4.charcount = 256;
		VAR_4.data = VAR_2;
		return con_font_op(VAR_0, &VAR_4);

	case VAR_12:
                if (!VAR_3)
			return -VAR_6;
		return con_set_cmap(VAR_2);

	case VAR_13:
                return con_get_cmap(VAR_2);

	case VAR_14:
		if (!VAR_3)
			return -VAR_6;

		VAR_15;
	case VAR_16:
		return do_fontx_ioctl(VAR_0, VAR_1, VAR_2, &VAR_4);

	case VAR_17:
		if (!VAR_3)
			return -VAR_6;

		return vt_io_fontreset(VAR_0, &VAR_4);

	case VAR_18:
		if (!VAR_3)
			return -VAR_6;
		return con_set_trans_old(VAR_2);

	case VAR_19:
		return con_get_trans_old(VAR_2);

	case VAR_20:
		if (!VAR_3)
			return -VAR_6;
		return con_set_trans_new(VAR_2);

	case VAR_21:
		return con_get_trans_new(VAR_2);

	case VAR_22:
		if (!VAR_3)
			return -VAR_6;
		con_clear_unimap(VAR_0);
		break;

	case VAR_23:
	case VAR_24:
		return do_unimap_ioctl(VAR_1, VAR_2, VAR_3, VAR_0);

	default:
		return -VAR_25;
	}

	return 0;
}",,"--- func_before
+++ func_after
@@ -13,7 +13,7 @@
 		op.height = 0;
 		op.charcount = 256;
 		op.data = up;
-		return con_font_op(vc_cons[fg_console].d, &op);
+		return con_font_op(vc, &op);
 
 	case GIO_FONT:
 		op.op = KD_FONT_OP_GET;
@@ -22,7 +22,7 @@
 		op.height = 32;
 		op.charcount = 256;
 		op.data = up;
-		return con_font_op(vc_cons[fg_console].d, &op);
+		return con_font_op(vc, &op);
 
 	case PIO_CMAP:
                 if (!perm)
@@ -38,13 +38,13 @@
 
 		fallthrough;
 	case GIO_FONTX:
-		return do_fontx_ioctl(cmd, up, &op);
+		return do_fontx_ioctl(vc, cmd, up, &op);
 
 	case PIO_FONTRESET:
 		if (!perm)
 			return -EPERM;
 
-		return vt_io_fontreset(&op);
+		return vt_io_fontreset(vc, &op);
 
 	case PIO_SCRNMAP:
 		if (!perm)","{'deleted_lines': ['\t\treturn con_font_op(vc_cons[fg_console].d, &op);', '\t\treturn con_font_op(vc_cons[fg_console].d, &op);', '\t\treturn do_fontx_ioctl(cmd, up, &op);', '\t\treturn vt_io_fontreset(&op);'], 'added_lines': ['\t\treturn con_font_op(vc, &op);', '\t\treturn con_font_op(vc, &op);', '\t\treturn do_fontx_ioctl(vc, cmd, up, &op);', '\t\treturn vt_io_fontreset(vc, &op);']}",True,A flaw was found in Linux Kernel because access to the global variable fg_console is not properly synchronized leading to a use after free in con_font_op.,7.0,HIGH,2,test,,5
CVE-2020-25668,['CWE-662'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"Some of the font tty ioctl's always used the current foreground VC for
their operations.  Don't do that then.

This fixes a data race on fg_console.

Side note: both Michael Ellerman and Jiri Slaby point out that all these
ioctls are deprecated, and should probably have been removed long ago,
and everything seems to be using the KDFONTOP ioctl instead.

In fact, Michael points out that it looks like busybox's loadfont
program seems to have switched over to using KDFONTOP exactly _because_
of this bug (ahem.. 12 years ago ;-).

Reported-by: Minh Yuan <yuanmingbuaa@gmail.com>
Acked-by: Michael Ellerman <mpe@ellerman.id.au>
Acked-by: Jiri Slaby <jirislaby@kernel.org>
Cc: Greg KH <greg@kroah.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
",90bfdeef83f1d6c696039b6a917190dcbbad3220,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit?h=90bfdeef83f1d6c696039b6a917190dcbbad3220,drivers/tty/vt/vt_ioctl.c,vt_io_fontreset,"static int vt_io_fontreset(struct console_font_op *op)
{
int ret;
if (__is_defined(BROKEN_GRAPHICS_PROGRAMS)) {
return -ENOSYS;
}
op->op = KD_FONT_OP_SET_DEFAULT;
op->data = NULL;
ret = con_font_op(vc_cons[fg_console].d, op);
if (ret)
return ret;
console_lock();
con_set_default_unimap(vc_cons[fg_console].d);
console_unlock();
return 0;
}","static int vt_io_fontreset(struct console_font_op *VAR_0)
{
int VAR_1;
if (__is_defined(VAR_2)) {
return -VAR_3;
}
VAR_0->op = VAR_4;
VAR_0->data = NULL;
VAR_1 = con_font_op(VAR_5[VAR_6].d, VAR_0);
if (VAR_1)
return VAR_1;
console_lock();
con_set_default_unimap(VAR_5[VAR_6].d);
console_unlock();
return 0;
}",torvalds/linux/90bfdeef83f1d6c696039b6a917190dcbbad3220/vt_ioctl.c/vul/before/2.json,"static int vt_io_fontreset(struct vc_data *vc, struct console_font_op *op)
{
	int ret;

	if (__is_defined(BROKEN_GRAPHICS_PROGRAMS)) {
		/*
		 * With BROKEN_GRAPHICS_PROGRAMS defined, the default font is
		 * not saved.
		 */
		return -ENOSYS;
	}

	op->op = KD_FONT_OP_SET_DEFAULT;
	op->data = NULL;
	ret = con_font_op(vc, op);
	if (ret)
		return ret;

	console_lock();
	con_set_default_unimap(vc);
	console_unlock();

	return 0;
}","static int vt_io_fontreset(struct vc_data *VAR_0, struct console_font_op *VAR_1)
{
	int VAR_2;

	if (__is_defined(VAR_3)) {
		/* COMMENT_0 */
                                                               
               
     
		return -VAR_4;
	}

	VAR_1->op = VAR_5;
	VAR_1->data = NULL;
	VAR_2 = con_font_op(VAR_0, VAR_1);
	if (VAR_2)
		return VAR_2;

	console_lock();
	con_set_default_unimap(VAR_0);
	console_unlock();

	return 0;
}",torvalds/linux/90bfdeef83f1d6c696039b6a917190dcbbad3220/vt_ioctl.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-static int vt_io_fontreset(struct console_font_op *op)
+static int vt_io_fontreset(struct vc_data *vc, struct console_font_op *op)
 {
 	int ret;
 
@@ -12,12 +12,12 @@
 
 	op->op = KD_FONT_OP_SET_DEFAULT;
 	op->data = NULL;
-	ret = con_font_op(vc_cons[fg_console].d, op);
+	ret = con_font_op(vc, op);
 	if (ret)
 		return ret;
 
 	console_lock();
-	con_set_default_unimap(vc_cons[fg_console].d);
+	con_set_default_unimap(vc);
 	console_unlock();
 
 	return 0;","{'deleted_lines': ['static int vt_io_fontreset(struct console_font_op *op)', '\tret = con_font_op(vc_cons[fg_console].d, op);', '\tcon_set_default_unimap(vc_cons[fg_console].d);'], 'added_lines': ['static int vt_io_fontreset(struct vc_data *vc, struct console_font_op *op)', '\tret = con_font_op(vc, op);', '\tcon_set_default_unimap(vc);']}",True,A flaw was found in Linux Kernel because access to the global variable fg_console is not properly synchronized leading to a use after free in con_font_op.,7.0,HIGH,2,test,,5
CVE-2020-25668,['CWE-662'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"Some of the font tty ioctl's always used the current foreground VC for
their operations.  Don't do that then.

This fixes a data race on fg_console.

Side note: both Michael Ellerman and Jiri Slaby point out that all these
ioctls are deprecated, and should probably have been removed long ago,
and everything seems to be using the KDFONTOP ioctl instead.

In fact, Michael points out that it looks like busybox's loadfont
program seems to have switched over to using KDFONTOP exactly _because_
of this bug (ahem.. 12 years ago ;-).

Reported-by: Minh Yuan <yuanmingbuaa@gmail.com>
Acked-by: Michael Ellerman <mpe@ellerman.id.au>
Acked-by: Jiri Slaby <jirislaby@kernel.org>
Cc: Greg KH <greg@kroah.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
",90bfdeef83f1d6c696039b6a917190dcbbad3220,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit?h=90bfdeef83f1d6c696039b6a917190dcbbad3220,drivers/tty/vt/vt_ioctl.c,vt_compat_ioctl,"long vt_compat_ioctl(struct tty_struct *tty,
unsigned int cmd, unsigned long arg)
{
struct vc_data *vc = tty->driver_data;
struct console_font_op op;
void __user *up = compat_ptr(arg);
int perm;
perm = 0;
if (current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG))
perm = 1;
switch (cmd) {
case PIO_FONTX:
case GIO_FONTX:
return compat_fontx_ioctl(cmd, up, perm, &op);
case KDFONTOP:
return compat_kdfontop_ioctl(up, perm, &op, vc);
case PIO_UNIMAP:
case GIO_UNIMAP:
return compat_unimap_ioctl(cmd, up, perm, vc);
case KIOCSOUND:
case KDMKTONE:
#ifdef CONFIG_X86
case KDADDIO:
case KDDELIO:
#endif
case KDSETMODE:
case KDMAPDISP:
case KDUNMAPDISP:
case KDSKBMODE:
case KDSKBMETA:
case KDSKBLED:
case KDSETLED:
case KDSIGACCEPT:
case VT_ACTIVATE:
case VT_WAITACTIVE:
case VT_RELDISP:
case VT_DISALLOCATE:
case VT_RESIZE:
case VT_RESIZEX:
return vt_ioctl(tty, cmd, arg);
default:
return vt_ioctl(tty, cmd, (unsigned long)up);
}
}","long vt_compat_ioctl(struct tty_struct *VAR_0,
unsigned int VAR_1, unsigned long VAR_2)
{
struct vc_data *VAR_3 = VAR_0->driver_data;
struct console_font_op VAR_4;
void __user *VAR_5 = compat_ptr(VAR_2);
int VAR_6;
VAR_6 = 0;
if (VAR_7->signal->tty == VAR_0 || capable(VAR_8))
VAR_6 = 1;
switch (VAR_1) {
case VAR_9:
case VAR_10:
return compat_fontx_ioctl(VAR_1, VAR_5, VAR_6, &VAR_4);
case VAR_11:
return compat_kdfontop_ioctl(VAR_5, VAR_6, &VAR_4, VAR_3);
case VAR_12:
case VAR_13:
return compat_unimap_ioctl(VAR_1, VAR_5, VAR_6, VAR_3);
case VAR_14:
case VAR_15:
#ifdef VAR_16
case VAR_17:
case VAR_18:
#endif
case VAR_19:
case VAR_20:
case VAR_21:
case VAR_22:
case VAR_23:
case VAR_24:
case VAR_25:
case VAR_26:
case VAR_27:
case VAR_28:
case VAR_29:
case VAR_30:
case VAR_31:
case VAR_32:
return vt_ioctl(VAR_0, VAR_1, VAR_2);
default:
return vt_ioctl(VAR_0, VAR_1, (unsigned long)VAR_5);
}
}",torvalds/linux/90bfdeef83f1d6c696039b6a917190dcbbad3220/vt_ioctl.c/vul/before/3.json,"long vt_compat_ioctl(struct tty_struct *tty,
	     unsigned int cmd, unsigned long arg)
{
	struct vc_data *vc = tty->driver_data;
	struct console_font_op op;	/* used in multiple places here */
	void __user *up = compat_ptr(arg);
	int perm;

	/*
	 * To have permissions to do most of the vt ioctls, we either have
	 * to be the owner of the tty, or have CAP_SYS_TTY_CONFIG.
	 */
	perm = 0;
	if (current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG))
		perm = 1;

	switch (cmd) {
	/*
	 * these need special handlers for incompatible data structures
	 */
	case PIO_FONTX:
	case GIO_FONTX:
		return compat_fontx_ioctl(vc, cmd, up, perm, &op);

	case KDFONTOP:
		return compat_kdfontop_ioctl(up, perm, &op, vc);

	case PIO_UNIMAP:
	case GIO_UNIMAP:
		return compat_unimap_ioctl(cmd, up, perm, vc);

	/*
	 * all these treat 'arg' as an integer
	 */
	case KIOCSOUND:
	case KDMKTONE:
#ifdef CONFIG_X86
	case KDADDIO:
	case KDDELIO:
#endif
	case KDSETMODE:
	case KDMAPDISP:
	case KDUNMAPDISP:
	case KDSKBMODE:
	case KDSKBMETA:
	case KDSKBLED:
	case KDSETLED:
	case KDSIGACCEPT:
	case VT_ACTIVATE:
	case VT_WAITACTIVE:
	case VT_RELDISP:
	case VT_DISALLOCATE:
	case VT_RESIZE:
	case VT_RESIZEX:
		return vt_ioctl(tty, cmd, arg);

	/*
	 * the rest has a compatible data structure behind arg,
	 * but we have to convert it to a proper 64 bit pointer.
	 */
	default:
		return vt_ioctl(tty, cmd, (unsigned long)up);
	}
}","long vt_compat_ioctl(struct tty_struct *VAR_0,
	     unsigned int VAR_1, unsigned long VAR_2)
{
	struct vc_data *VAR_3 = VAR_0->driver_data;
	struct console_font_op VAR_4;	/* COMMENT_0 */
	void __user *VAR_5 = compat_ptr(VAR_2);
	int VAR_6;

	/* COMMENT_1 */
                                                                   
                                                           
    
	VAR_6 = 0;
	if (VAR_7->signal->tty == VAR_0 || capable(VAR_8))
		VAR_6 = 1;

	switch (VAR_1) {
	/* COMMENT_5 */
                                                                
    
	case VAR_9:
	case VAR_10:
		return compat_fontx_ioctl(VAR_3, VAR_1, VAR_5, VAR_6, &VAR_4);

	case VAR_11:
		return compat_kdfontop_ioctl(VAR_5, VAR_6, &VAR_4, VAR_3);

	case VAR_12:
	case VAR_13:
		return compat_unimap_ioctl(VAR_1, VAR_5, VAR_6, VAR_3);

	/* COMMENT_8 */
                                       
    
	case VAR_14:
	case VAR_15:
#ifdef VAR_16
	case VAR_17:
	case VAR_18:
#endif
	case VAR_19:
	case VAR_20:
	case VAR_21:
	case VAR_22:
	case VAR_23:
	case VAR_24:
	case VAR_25:
	case VAR_26:
	case VAR_27:
	case VAR_28:
	case VAR_29:
	case VAR_30:
	case VAR_31:
	case VAR_32:
		return vt_ioctl(VAR_0, VAR_1, VAR_2);

	/* COMMENT_11 */
                                                        
                                                         
    
	default:
		return vt_ioctl(VAR_0, VAR_1, (unsigned long)VAR_5);
	}
}",torvalds/linux/90bfdeef83f1d6c696039b6a917190dcbbad3220/vt_ioctl.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -20,7 +20,7 @@
 	 */
 	case PIO_FONTX:
 	case GIO_FONTX:
-		return compat_fontx_ioctl(cmd, up, perm, &op);
+		return compat_fontx_ioctl(vc, cmd, up, perm, &op);
 
 	case KDFONTOP:
 		return compat_kdfontop_ioctl(up, perm, &op, vc);","{'deleted_lines': ['\t\treturn compat_fontx_ioctl(cmd, up, perm, &op);'], 'added_lines': ['\t\treturn compat_fontx_ioctl(vc, cmd, up, perm, &op);']}",True,A flaw was found in Linux Kernel because access to the global variable fg_console is not properly synchronized leading to a use after free in con_font_op.,7.0,HIGH,2,test,,5
CVE-2020-25668,['CWE-662'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"Some of the font tty ioctl's always used the current foreground VC for
their operations.  Don't do that then.

This fixes a data race on fg_console.

Side note: both Michael Ellerman and Jiri Slaby point out that all these
ioctls are deprecated, and should probably have been removed long ago,
and everything seems to be using the KDFONTOP ioctl instead.

In fact, Michael points out that it looks like busybox's loadfont
program seems to have switched over to using KDFONTOP exactly _because_
of this bug (ahem.. 12 years ago ;-).

Reported-by: Minh Yuan <yuanmingbuaa@gmail.com>
Acked-by: Michael Ellerman <mpe@ellerman.id.au>
Acked-by: Jiri Slaby <jirislaby@kernel.org>
Cc: Greg KH <greg@kroah.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
",90bfdeef83f1d6c696039b6a917190dcbbad3220,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit?h=90bfdeef83f1d6c696039b6a917190dcbbad3220,drivers/tty/vt/vt_ioctl.c,do_fontx_ioctl,"static inline int do_fontx_ioctl(int cmd,
struct consolefontdesc __user *user_cfd,
struct console_font_op *op)
{
struct consolefontdesc cfdarg;
int i;
if (copy_from_user(&cfdarg, user_cfd, sizeof(struct consolefontdesc)))
return -EFAULT;
switch (cmd) {
case PIO_FONTX:
op->op = KD_FONT_OP_SET;
op->flags = KD_FONT_FLAG_OLD;
op->width = 8;
op->height = cfdarg.charheight;
op->charcount = cfdarg.charcount;
op->data = cfdarg.chardata;
return con_font_op(vc_cons[fg_console].d, op);
case GIO_FONTX: {
op->op = KD_FONT_OP_GET;
op->flags = KD_FONT_FLAG_OLD;
op->width = 8;
op->height = cfdarg.charheight;
op->charcount = cfdarg.charcount;
op->data = cfdarg.chardata;
i = con_font_op(vc_cons[fg_console].d, op);
if (i)
return i;
cfdarg.charheight = op->height;
cfdarg.charcount = op->charcount;
if (copy_to_user(user_cfd, &cfdarg, sizeof(struct consolefontdesc)))
return -EFAULT;
return 0;
}
}
return -EINVAL;
}","static inline int do_fontx_ioctl(int VAR_0,
struct consolefontdesc __user *VAR_1,
struct console_font_op *VAR_2)
{
struct consolefontdesc VAR_3;
int VAR_4;
if (copy_from_user(&VAR_3, VAR_1, sizeof(struct consolefontdesc)))
return -VAR_5;
switch (VAR_0) {
case VAR_6:
VAR_2->op = VAR_7;
VAR_2->flags = VAR_8;
VAR_2->width = 8;
VAR_2->height = VAR_3.charheight;
VAR_2->charcount = VAR_3.charcount;
VAR_2->data = VAR_3.chardata;
return con_font_op(VAR_9[VAR_10].d, VAR_2);
case VAR_11: {
VAR_2->op = VAR_12;
VAR_2->flags = VAR_8;
VAR_2->width = 8;
VAR_2->height = VAR_3.charheight;
VAR_2->charcount = VAR_3.charcount;
VAR_2->data = VAR_3.chardata;
VAR_4 = con_font_op(VAR_9[VAR_10].d, VAR_2);
if (VAR_4)
return VAR_4;
VAR_3.charheight = VAR_2->height;
VAR_3.charcount = VAR_2->charcount;
if (copy_to_user(VAR_1, &VAR_3, sizeof(struct consolefontdesc)))
return -VAR_5;
return 0;
}
}
return -VAR_13;
}",,"static inline int do_fontx_ioctl(struct vc_data *vc, int cmd,
		struct consolefontdesc __user *user_cfd,
		struct console_font_op *op)
{
	struct consolefontdesc cfdarg;
	int i;

	if (copy_from_user(&cfdarg, user_cfd, sizeof(struct consolefontdesc)))
		return -EFAULT;

	switch (cmd) {
	case PIO_FONTX:
		op->op = KD_FONT_OP_SET;
		op->flags = KD_FONT_FLAG_OLD;
		op->width = 8;
		op->height = cfdarg.charheight;
		op->charcount = cfdarg.charcount;
		op->data = cfdarg.chardata;
		return con_font_op(vc, op);

	case GIO_FONTX:
		op->op = KD_FONT_OP_GET;
		op->flags = KD_FONT_FLAG_OLD;
		op->width = 8;
		op->height = cfdarg.charheight;
		op->charcount = cfdarg.charcount;
		op->data = cfdarg.chardata;
		i = con_font_op(vc, op);
		if (i)
			return i;
		cfdarg.charheight = op->height;
		cfdarg.charcount = op->charcount;
		if (copy_to_user(user_cfd, &cfdarg, sizeof(struct consolefontdesc)))
			return -EFAULT;
		return 0;
	}
	return -EINVAL;
}","static inline int do_fontx_ioctl(struct vc_data *VAR_0, int VAR_1,
		struct consolefontdesc __user *VAR_2,
		struct console_font_op *VAR_3)
{
	struct consolefontdesc VAR_4;
	int VAR_5;

	if (copy_from_user(&VAR_4, VAR_2, sizeof(struct consolefontdesc)))
		return -VAR_6;

	switch (VAR_1) {
	case VAR_7:
		VAR_3->op = VAR_8;
		VAR_3->flags = VAR_9;
		VAR_3->width = 8;
		VAR_3->height = VAR_4.charheight;
		VAR_3->charcount = VAR_4.charcount;
		VAR_3->data = VAR_4.chardata;
		return con_font_op(VAR_0, VAR_3);

	case VAR_10:
		VAR_3->op = VAR_11;
		VAR_3->flags = VAR_9;
		VAR_3->width = 8;
		VAR_3->height = VAR_4.charheight;
		VAR_3->charcount = VAR_4.charcount;
		VAR_3->data = VAR_4.chardata;
		VAR_5 = con_font_op(VAR_0, VAR_3);
		if (VAR_5)
			return VAR_5;
		VAR_4.charheight = VAR_3->height;
		VAR_4.charcount = VAR_3->charcount;
		if (copy_to_user(VAR_2, &VAR_4, sizeof(struct consolefontdesc)))
			return -VAR_6;
		return 0;
	}
	return -VAR_12;
}",,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-static inline int do_fontx_ioctl(int cmd,
+static inline int do_fontx_ioctl(struct vc_data *vc, int cmd,
 		struct consolefontdesc __user *user_cfd,
 		struct console_font_op *op)
 {
@@ -16,15 +16,16 @@
 		op->height = cfdarg.charheight;
 		op->charcount = cfdarg.charcount;
 		op->data = cfdarg.chardata;
-		return con_font_op(vc_cons[fg_console].d, op);
-	case GIO_FONTX: {
+		return con_font_op(vc, op);
+
+	case GIO_FONTX:
 		op->op = KD_FONT_OP_GET;
 		op->flags = KD_FONT_FLAG_OLD;
 		op->width = 8;
 		op->height = cfdarg.charheight;
 		op->charcount = cfdarg.charcount;
 		op->data = cfdarg.chardata;
-		i = con_font_op(vc_cons[fg_console].d, op);
+		i = con_font_op(vc, op);
 		if (i)
 			return i;
 		cfdarg.charheight = op->height;
@@ -32,7 +33,6 @@
 		if (copy_to_user(user_cfd, &cfdarg, sizeof(struct consolefontdesc)))
 			return -EFAULT;
 		return 0;
-		}
 	}
 	return -EINVAL;
 }","{'deleted_lines': ['static inline int do_fontx_ioctl(int cmd,', '\t\treturn con_font_op(vc_cons[fg_console].d, op);', '\tcase GIO_FONTX: {', '\t\ti = con_font_op(vc_cons[fg_console].d, op);', '\t\t}'], 'added_lines': ['static inline int do_fontx_ioctl(struct vc_data *vc, int cmd,', '\t\treturn con_font_op(vc, op);', '', '\tcase GIO_FONTX:', '\t\ti = con_font_op(vc, op);']}",True,A flaw was found in Linux Kernel because access to the global variable fg_console is not properly synchronized leading to a use after free in con_font_op.,7.0,HIGH,2,test,,5
CVE-2020-22029,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,ffmpeg,"
avfilter/vf_colorconstancy: fix overreads in gauss array

Fixes #8250
",a7fd1279703683ebb548ef7baa2f1519994496ae,http://git.videolan.org/?p=ffmpeg.git;a=commit;h=a7fd1279703683ebb548ef7baa2f1519994496ae,libavfilter/vf_colorconstancy.c,slice_get_derivative,"static int slice_get_derivative(AVFilterContext* ctx, void* arg, int jobnr, int nb_jobs)
{
ColorConstancyContext *s = ctx->priv;
ThreadData *td = arg;
AVFrame *in = td->in;
const int ord = td->meta_data[INDEX_ORD];
const int dir = td->meta_data[INDEX_DIR];
const int src_index  = td->meta_data[INDEX_SRC];
const int dst_index  = td->meta_data[INDEX_DST];
const int filtersize = s->filtersize;
const double *gauss  = s->gauss[ord];
int plane;
for (plane = 0; plane < NUM_PLANES; ++plane) {
const int height      = s->planeheight[plane];
const int width       = s->planewidth[plane];
const int in_linesize = in->linesize[plane];
double *dst = td->data[dst_index][plane];
int slice_start, slice_end;
int r, c, g;
if (dir == DIR_X) {
const uint8_t *src = in->data[plane];
slice_start = (height * jobnr      ) / nb_jobs;
slice_end   = (height * (jobnr + 1)) / nb_jobs;
for (r = slice_start; r < slice_end; ++r) {
for (c = 0; c < width; ++c) {
dst[INDX2D(r, c, width)] = 0;
for (g = 0; g < filtersize; ++g) {
dst[INDX2D(r, c, width)] += GAUSS(src, r,                        c + GINDX(filtersize, g),
in_linesize, height, width, gauss[GINDX(filtersize, g)]);
}
}
}
} else {
const double *src = td->data[src_index][plane];
slice_start = (width * jobnr      ) / nb_jobs;
slice_end   = (width * (jobnr + 1)) / nb_jobs;
for (c = slice_start; c < slice_end; ++c) {
for (r = 0; r < height; ++r) {
dst[INDX2D(r, c, width)] = 0;
for (g = 0; g < filtersize; ++g) {
dst[INDX2D(r, c, width)] += GAUSS(src, r + GINDX(filtersize, g), c,
width, height, width, gauss[GINDX(filtersize, g)]);
}
}
}
}
}
return 0;
}","static int slice_get_derivative(AVFilterContext* VAR_0, void* VAR_1, int VAR_2, int VAR_3)
{
ColorConstancyContext *VAR_4 = VAR_0->priv;
ThreadData *VAR_5 = VAR_1;
AVFrame *VAR_6 = VAR_5->in;
const int VAR_7 = VAR_5->meta_data[VAR_8];
const int VAR_9 = VAR_5->meta_data[VAR_10];
const int VAR_11  = VAR_5->meta_data[VAR_12];
const int VAR_13  = VAR_5->meta_data[VAR_14];
const int VAR_15 = VAR_4->filtersize;
const double *VAR_16  = VAR_4->gauss[VAR_7];
int VAR_17;
for (VAR_17 = 0; VAR_17 < VAR_18; ++VAR_17) {
const int VAR_19      = VAR_4->planeheight[VAR_17];
const int VAR_20       = VAR_4->planewidth[VAR_17];
const int VAR_21 = VAR_6->linesize[VAR_17];
double *VAR_22 = VAR_5->data[VAR_13][VAR_17];
int VAR_23, VAR_24;
int VAR_25, VAR_26, VAR_27;
if (VAR_9 == VAR_28) {
const uint8_t *VAR_29 = VAR_6->data[VAR_17];
VAR_23 = (VAR_19 * VAR_2      ) / VAR_3;
VAR_24   = (VAR_19 * (VAR_2 + 1)) / VAR_3;
for (VAR_25 = VAR_23; VAR_25 < VAR_24; ++VAR_25) {
for (VAR_26 = 0; VAR_26 < VAR_20; ++VAR_26) {
VAR_22[INDX2D(VAR_25, VAR_26, VAR_20)] = 0;
for (VAR_27 = 0; VAR_27 < VAR_15; ++VAR_27) {
VAR_22[INDX2D(VAR_25, VAR_26, VAR_20)] += GAUSS(VAR_29, VAR_25,                        VAR_26 + GINDX(VAR_15, VAR_27),
VAR_21, VAR_19, VAR_20, VAR_16[GINDX(VAR_15, VAR_27)]);
}
}
}
} else {
const double *VAR_29 = VAR_5->data[VAR_11][VAR_17];
VAR_23 = (VAR_20 * VAR_2      ) / VAR_3;
VAR_24   = (VAR_20 * (VAR_2 + 1)) / VAR_3;
for (VAR_26 = VAR_23; VAR_26 < VAR_24; ++VAR_26) {
for (VAR_25 = 0; VAR_25 < VAR_19; ++VAR_25) {
VAR_22[INDX2D(VAR_25, VAR_26, VAR_20)] = 0;
for (VAR_27 = 0; VAR_27 < VAR_15; ++VAR_27) {
VAR_22[INDX2D(VAR_25, VAR_26, VAR_20)] += GAUSS(VAR_29, VAR_25 + GINDX(VAR_15, VAR_27), VAR_26,
VAR_20, VAR_19, VAR_20, VAR_16[GINDX(VAR_15, VAR_27)]);
}
}
}
}
}
return 0;
}",ffmpeg/a7fd1279703683ebb548ef7baa2f1519994496ae/vf_colorconstancy.c/vul/before/0.json,"static int slice_get_derivative(AVFilterContext* ctx, void* arg, int jobnr, int nb_jobs)
{
    ColorConstancyContext *s = ctx->priv;
    ThreadData *td = arg;
    AVFrame *in = td->in;
    const int ord = td->meta_data[INDEX_ORD];
    const int dir = td->meta_data[INDEX_DIR];
    const int src_index  = td->meta_data[INDEX_SRC];
    const int dst_index  = td->meta_data[INDEX_DST];
    const int filtersize = s->filtersize;
    const double *gauss  = s->gauss[ord];
    int plane;

    for (plane = 0; plane < NUM_PLANES; ++plane) {
        const int height      = s->planeheight[plane];
        const int width       = s->planewidth[plane];
        const int in_linesize = in->linesize[plane];
        double *dst = td->data[dst_index][plane];
        int slice_start, slice_end;
        int r, c, g;

        if (dir == DIR_X) {
            /** Applying gauss horizontally along each row */
            const uint8_t *src = in->data[plane];
            slice_start = (height * jobnr      ) / nb_jobs;
            slice_end   = (height * (jobnr + 1)) / nb_jobs;

            for (r = slice_start; r < slice_end; ++r) {
                for (c = 0; c < width; ++c) {
                    dst[INDX2D(r, c, width)] = 0;
                    for (g = 0; g < filtersize; ++g) {
                        dst[INDX2D(r, c, width)] += GAUSS(src, r,                        c + GINDX(filtersize, g),
                                                          in_linesize, height, width, gauss[g]);
                    }
                }
            }
        } else {
            /** Applying gauss vertically along each column */
            const double *src = td->data[src_index][plane];
            slice_start = (width * jobnr      ) / nb_jobs;
            slice_end   = (width * (jobnr + 1)) / nb_jobs;

            for (c = slice_start; c < slice_end; ++c) {
                for (r = 0; r < height; ++r) {
                    dst[INDX2D(r, c, width)] = 0;
                    for (g = 0; g < filtersize; ++g) {
                        dst[INDX2D(r, c, width)] += GAUSS(src, r + GINDX(filtersize, g), c,
                                                          width, height, width, gauss[g]);
                    }
                }
            }
        }

    }
    return 0;
}","static int slice_get_derivative(AVFilterContext* VAR_0, void* VAR_1, int VAR_2, int VAR_3)
{
    ColorConstancyContext *VAR_4 = VAR_0->priv;
    ThreadData *VAR_5 = VAR_1;
    AVFrame *VAR_6 = VAR_5->in;
    const int VAR_7 = VAR_5->meta_data[VAR_8];
    const int VAR_9 = VAR_5->meta_data[VAR_10];
    const int VAR_11  = VAR_5->meta_data[VAR_12];
    const int VAR_13  = VAR_5->meta_data[VAR_14];
    const int VAR_15 = VAR_4->filtersize;
    const double *VAR_16  = VAR_4->gauss[VAR_7];
    int VAR_17;

    for (VAR_17 = 0; VAR_17 < VAR_18; ++VAR_17) {
        const int VAR_19      = VAR_4->planeheight[VAR_17];
        const int VAR_20       = VAR_4->planewidth[VAR_17];
        const int VAR_21 = VAR_6->linesize[VAR_17];
        double *VAR_22 = VAR_5->data[VAR_13][VAR_17];
        int VAR_23, VAR_24;
        int VAR_25, VAR_26, VAR_27;

        if (VAR_9 == VAR_28) {
            /* COMMENT_0 */
            const uint8_t *VAR_29 = VAR_6->data[VAR_17];
            VAR_23 = (VAR_19 * VAR_2      ) / VAR_3;
            VAR_24   = (VAR_19 * (VAR_2 + 1)) / VAR_3;

            for (VAR_25 = VAR_23; VAR_25 < VAR_24; ++VAR_25) {
                for (VAR_26 = 0; VAR_26 < VAR_20; ++VAR_26) {
                    VAR_22[INDX2D(VAR_25, VAR_26, VAR_20)] = 0;
                    for (VAR_27 = 0; VAR_27 < VAR_15; ++VAR_27) {
                        VAR_22[INDX2D(VAR_25, VAR_26, VAR_20)] += GAUSS(VAR_29, VAR_25,                        VAR_26 + GINDX(VAR_15, VAR_27),
                                                          VAR_21, VAR_19, VAR_20, VAR_16[VAR_27]);
                    }
                }
            }
        } else {
            /* COMMENT_1 */
            const double *VAR_29 = VAR_5->data[VAR_11][VAR_17];
            VAR_23 = (VAR_20 * VAR_2      ) / VAR_3;
            VAR_24   = (VAR_20 * (VAR_2 + 1)) / VAR_3;

            for (VAR_26 = VAR_23; VAR_26 < VAR_24; ++VAR_26) {
                for (VAR_25 = 0; VAR_25 < VAR_19; ++VAR_25) {
                    VAR_22[INDX2D(VAR_25, VAR_26, VAR_20)] = 0;
                    for (VAR_27 = 0; VAR_27 < VAR_15; ++VAR_27) {
                        VAR_22[INDX2D(VAR_25, VAR_26, VAR_20)] += GAUSS(VAR_29, VAR_25 + GINDX(VAR_15, VAR_27), VAR_26,
                                                          VAR_20, VAR_19, VAR_20, VAR_16[VAR_27]);
                    }
                }
            }
        }

    }
    return 0;
}",ffmpeg/a7fd1279703683ebb548ef7baa2f1519994496ae/vf_colorconstancy.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -30,7 +30,7 @@
                     dst[INDX2D(r, c, width)] = 0;
                     for (g = 0; g < filtersize; ++g) {
                         dst[INDX2D(r, c, width)] += GAUSS(src, r,                        c + GINDX(filtersize, g),
-                                                          in_linesize, height, width, gauss[GINDX(filtersize, g)]);
+                                                          in_linesize, height, width, gauss[g]);
                     }
                 }
             }
@@ -45,7 +45,7 @@
                     dst[INDX2D(r, c, width)] = 0;
                     for (g = 0; g < filtersize; ++g) {
                         dst[INDX2D(r, c, width)] += GAUSS(src, r + GINDX(filtersize, g), c,
-                                                          width, height, width, gauss[GINDX(filtersize, g)]);
+                                                          width, height, width, gauss[g]);
                     }
                 }
             }","{'deleted_lines': ['                                                          in_linesize, height, width, gauss[GINDX(filtersize, g)]);', '                                                          width, height, width, gauss[GINDX(filtersize, g)]);'], 'added_lines': ['                                                          in_linesize, height, width, gauss[g]);', '                                                          width, height, width, gauss[g]);']}",True,"A heap-based Buffer Overflow vulnerability exists in FFmpeg 4.2 at libavfilter/vf_colorconstancy.c: in slice_get_derivative, which crossfade_samples_fltp, which might lead to memory corruption and other potential consequences.",8.8,HIGH,2,test,,5
CVE-2020-36386,['CWE-125'],AV:L/AC:L/Au:N/C:P/I:N/A:C,0,torvalds/linux,"Check upon `num_rsp` is insufficient. A malformed event packet with a
large `num_rsp` number makes hci_extended_inquiry_result_evt() go out
of bounds. Fix it.

This patch fixes the following syzbot bug:

    https://syzkaller.appspot.com/bug?id=4bf11aa05c4ca51ce0df86e500fce486552dc8d2

Reported-by: syzbot+d8489a79b781849b9c46@syzkaller.appspotmail.com
Cc: stable@vger.kernel.org
Signed-off-by: Peilin Ye <yepeilin.cs@gmail.com>
Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
",51c19bf3d5cfaa66571e4b88ba2a6f6295311101,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=51c19bf3d5cfaa66571e4b88ba2a6f6295311101,net/bluetooth/hci_event.c,hci_extended_inquiry_result_evt,"static void hci_extended_inquiry_result_evt(struct hci_dev *hdev,
struct sk_buff *skb)
{
struct inquiry_data data;
struct extended_inquiry_info *info = (void *) (skb->data + 1);
int num_rsp = *((__u8 *) skb->data);
size_t eir_len;
BT_DBG(""%s num_rsp %d"", hdev->name, num_rsp);
if (!num_rsp)
return;
if (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))
return;
hci_dev_lock(hdev);
for (; num_rsp; num_rsp--, info++) {
u32 flags;
bool name_known;
bacpy(&data.bdaddr, &info->bdaddr);
data.pscan_rep_mode= info->pscan_rep_mode;
data.pscan_period_mode= info->pscan_period_mode;
data.pscan_mode= 0x00;
memcpy(data.dev_class, info->dev_class, 3);
data.clock_offset= info->clock_offset;
data.rssi= info->rssi;
data.ssp_mode= 0x01;
if (hci_dev_test_flag(hdev, HCI_MGMT))
name_known = eir_get_data(info->data,
sizeof(info->data),
EIR_NAME_COMPLETE, NULL);
else
name_known = true;
flags = hci_inquiry_cache_update(hdev, &data, name_known);
eir_len = eir_get_length(info->data, sizeof(info->data));
mgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,
info->dev_class, info->rssi,
flags, info->data, eir_len, NULL, 0);
}
hci_dev_unlock(hdev);
}","static void hci_extended_inquiry_result_evt(struct hci_dev *VAR_0,
struct sk_buff *VAR_1)
{
struct inquiry_data VAR_2;
struct extended_inquiry_info *VAR_3 = (void *) (VAR_1->data + 1);
int VAR_4 = *((__u8 *) VAR_1->data);
size_t VAR_5;
BT_DBG(""%s num_rsp %d"", VAR_0->name, VAR_4);
if (!VAR_4)
return;
if (hci_dev_test_flag(VAR_0, VAR_6))
return;
hci_dev_lock(VAR_0);
for (; VAR_4; VAR_4--, VAR_3++) {
u32 VAR_7;
bool VAR_8;
bacpy(&VAR_2.bdaddr, &VAR_3->bdaddr);
VAR_2.pscan_rep_mode= VAR_3->pscan_rep_mode;
VAR_2.pscan_period_mode= VAR_3->pscan_period_mode;
VAR_2.pscan_mode= 0x00;
memcpy(VAR_2.dev_class, VAR_3->dev_class, 3);
VAR_2.clock_offset= VAR_3->clock_offset;
VAR_2.rssi= VAR_3->rssi;
VAR_2.ssp_mode= 0x01;
if (hci_dev_test_flag(VAR_0, VAR_9))
VAR_8 = eir_get_data(VAR_3->data,
sizeof(VAR_3->data),
VAR_10, NULL);
else
VAR_8 = true;
VAR_7 = hci_inquiry_cache_update(VAR_0, &VAR_2, VAR_8);
VAR_5 = eir_get_length(VAR_3->data, sizeof(VAR_3->data));
mgmt_device_found(VAR_0, &VAR_3->bdaddr, VAR_11, 0x00,
VAR_3->dev_class, VAR_3->rssi,
VAR_7, VAR_3->data, VAR_5, NULL, 0);
}
hci_dev_unlock(VAR_0);
}",torvalds/linux/51c19bf3d5cfaa66571e4b88ba2a6f6295311101/hci_event.c/vul/before/0.json,"static void hci_extended_inquiry_result_evt(struct hci_dev *hdev,
					    struct sk_buff *skb)
{
	struct inquiry_data data;
	struct extended_inquiry_info *info = (void *) (skb->data + 1);
	int num_rsp = *((__u8 *) skb->data);
	size_t eir_len;

	BT_DBG(""%s num_rsp %d"", hdev->name, num_rsp);

	if (!num_rsp || skb->len < num_rsp * sizeof(*info) + 1)
		return;

	if (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))
		return;

	hci_dev_lock(hdev);

	for (; num_rsp; num_rsp--, info++) {
		u32 flags;
		bool name_known;

		bacpy(&data.bdaddr, &info->bdaddr);
		data.pscan_rep_mode	= info->pscan_rep_mode;
		data.pscan_period_mode	= info->pscan_period_mode;
		data.pscan_mode		= 0x00;
		memcpy(data.dev_class, info->dev_class, 3);
		data.clock_offset	= info->clock_offset;
		data.rssi		= info->rssi;
		data.ssp_mode		= 0x01;

		if (hci_dev_test_flag(hdev, HCI_MGMT))
			name_known = eir_get_data(info->data,
						  sizeof(info->data),
						  EIR_NAME_COMPLETE, NULL);
		else
			name_known = true;

		flags = hci_inquiry_cache_update(hdev, &data, name_known);

		eir_len = eir_get_length(info->data, sizeof(info->data));

		mgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,
				  info->dev_class, info->rssi,
				  flags, info->data, eir_len, NULL, 0);
	}

	hci_dev_unlock(hdev);
}","static void hci_extended_inquiry_result_evt(struct hci_dev *VAR_0,
					    struct sk_buff *VAR_1)
{
	struct inquiry_data VAR_2;
	struct extended_inquiry_info *VAR_3 = (void *) (VAR_1->data + 1);
	int VAR_4 = *((__u8 *) VAR_1->data);
	size_t VAR_5;

	BT_DBG(""%s num_rsp %d"", VAR_0->name, VAR_4);

	if (!VAR_4 || VAR_1->len < VAR_4 * sizeof(*VAR_3) + 1)
		return;

	if (hci_dev_test_flag(VAR_0, VAR_6))
		return;

	hci_dev_lock(VAR_0);

	for (; VAR_4; VAR_4--, VAR_3++) {
		u32 VAR_7;
		bool VAR_8;

		bacpy(&VAR_2.bdaddr, &VAR_3->bdaddr);
		VAR_2.pscan_rep_mode	= VAR_3->pscan_rep_mode;
		VAR_2.pscan_period_mode	= VAR_3->pscan_period_mode;
		VAR_2.pscan_mode		= 0x00;
		memcpy(VAR_2.dev_class, VAR_3->dev_class, 3);
		VAR_2.clock_offset	= VAR_3->clock_offset;
		VAR_2.rssi		= VAR_3->rssi;
		VAR_2.ssp_mode		= 0x01;

		if (hci_dev_test_flag(VAR_0, VAR_9))
			VAR_8 = eir_get_data(VAR_3->data,
						  sizeof(VAR_3->data),
						  VAR_10, NULL);
		else
			VAR_8 = true;

		VAR_7 = hci_inquiry_cache_update(VAR_0, &VAR_2, VAR_8);

		VAR_5 = eir_get_length(VAR_3->data, sizeof(VAR_3->data));

		mgmt_device_found(VAR_0, &VAR_3->bdaddr, VAR_11, 0x00,
				  VAR_3->dev_class, VAR_3->rssi,
				  VAR_7, VAR_3->data, VAR_5, NULL, 0);
	}

	hci_dev_unlock(VAR_0);
}",torvalds/linux/51c19bf3d5cfaa66571e4b88ba2a6f6295311101/hci_event.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -8,7 +8,7 @@
 
 	BT_DBG(""%s num_rsp %d"", hdev->name, num_rsp);
 
-	if (!num_rsp)
+	if (!num_rsp || skb->len < num_rsp * sizeof(*info) + 1)
 		return;
 
 	if (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))","{'deleted_lines': ['\tif (!num_rsp)'], 'added_lines': ['\tif (!num_rsp || skb->len < num_rsp * sizeof(*info) + 1)']}",True,"An issue was discovered in the Linux kernel before 5.8.1. net/bluetooth/hci_event.c has a slab out-of-bounds read in hci_extended_inquiry_result_evt, aka CID-51c19bf3d5cf.",7.1,HIGH,2,test,,5
CVE-2020-36387,['CWE-416'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"We're holding the request reference, but we need to go one higher
to ensure that the ctx remains valid after the request has finished.
If the ring is closed with pending task_work inflight, and the
given io_kiocb finishes sync during issue, then we need a reference
to the ring itself around the task_work execution cycle.

Cc: stable@vger.kernel.org # v5.7+
Reported-by: syzbot+9b260fc33297966f5a8e@syzkaller.appspotmail.com
Signed-off-by: Jens Axboe <axboe@kernel.dk>
",6d816e088c359866f9867057e04f244c608c42fe,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=6d816e088c359866f9867057e04f244c608c42fe,fs/io_uring.c,io_rw_resubmit,"static void io_rw_resubmit(struct callback_head *cb)
{
struct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);
struct io_ring_ctx *ctx = req->ctx;
int err;
err = io_sq_thread_acquire_mm(ctx, req);
if (io_resubmit_prep(req, err)) {
refcount_inc(&req->refs);
io_queue_async_work(req);
}
}","static void io_rw_resubmit(struct callback_head *VAR_0)
{
struct io_kiocb *VAR_1 = container_of(VAR_0, struct io_kiocb, VAR_2);
struct io_ring_ctx *VAR_3 = VAR_1->ctx;
int VAR_4;
VAR_4 = io_sq_thread_acquire_mm(VAR_3, VAR_1);
if (io_resubmit_prep(VAR_1, VAR_4)) {
refcount_inc(&VAR_1->refs);
io_queue_async_work(VAR_1);
}
}",torvalds/linux/6d816e088c359866f9867057e04f244c608c42fe/io_uring.c/vul/before/0.json,"static void io_rw_resubmit(struct callback_head *cb)
{
	struct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);
	struct io_ring_ctx *ctx = req->ctx;
	int err;

	err = io_sq_thread_acquire_mm(ctx, req);

	if (io_resubmit_prep(req, err)) {
		refcount_inc(&req->refs);
		io_queue_async_work(req);
	}

	percpu_ref_put(&ctx->refs);
}","static void io_rw_resubmit(struct callback_head *VAR_0)
{
	struct io_kiocb *VAR_1 = container_of(VAR_0, struct io_kiocb, VAR_2);
	struct io_ring_ctx *VAR_3 = VAR_1->ctx;
	int VAR_4;

	VAR_4 = io_sq_thread_acquire_mm(VAR_3, VAR_1);

	if (io_resubmit_prep(VAR_1, VAR_4)) {
		refcount_inc(&VAR_1->refs);
		io_queue_async_work(VAR_1);
	}

	percpu_ref_put(&VAR_3->refs);
}",torvalds/linux/6d816e088c359866f9867057e04f244c608c42fe/io_uring.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -10,4 +10,6 @@
 		refcount_inc(&req->refs);
 		io_queue_async_work(req);
 	}
+
+	percpu_ref_put(&ctx->refs);
 }","{'deleted_lines': [], 'added_lines': ['', '\tpercpu_ref_put(&ctx->refs);']}",True,"An issue was discovered in the Linux kernel before 5.8.2. fs/io_uring.c has a use-after-free related to io_async_task_func and ctx reference holding, aka CID-6d816e088c35.",7.8,HIGH,2,test,,5
CVE-2020-36387,['CWE-416'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"We're holding the request reference, but we need to go one higher
to ensure that the ctx remains valid after the request has finished.
If the ring is closed with pending task_work inflight, and the
given io_kiocb finishes sync during issue, then we need a reference
to the ring itself around the task_work execution cycle.

Cc: stable@vger.kernel.org # v5.7+
Reported-by: syzbot+9b260fc33297966f5a8e@syzkaller.appspotmail.com
Signed-off-by: Jens Axboe <axboe@kernel.dk>
",6d816e088c359866f9867057e04f244c608c42fe,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=6d816e088c359866f9867057e04f244c608c42fe,fs/io_uring.c,io_async_task_func,"static void io_async_task_func(struct callback_head *cb)
{
struct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);
struct async_poll *apoll = req->apoll;
struct io_ring_ctx *ctx = req->ctx;
trace_io_uring_task_run(req->ctx, req->opcode, req->user_data);
if (io_poll_rewait(req, &apoll->poll)) {
spin_unlock_irq(&ctx->completion_lock);
return;
}
if (hash_hashed(&req->hash_node))
hash_del(&req->hash_node);
io_poll_remove_double(req, apoll->double_poll);
spin_unlock_irq(&ctx->completion_lock);
if (!READ_ONCE(apoll->poll.canceled))
__io_req_task_submit(req);
else
__io_req_task_cancel(req, -ECANCELED);
kfree(apoll->double_poll);
kfree(apoll);
}","static void io_async_task_func(struct callback_head *VAR_0)
{
struct io_kiocb *VAR_1 = container_of(VAR_0, struct io_kiocb, VAR_2);
struct async_poll *VAR_3 = VAR_1->apoll;
struct io_ring_ctx *VAR_4 = VAR_1->ctx;
trace_io_uring_task_run(VAR_1->ctx, VAR_1->opcode, VAR_1->user_data);
if (io_poll_rewait(VAR_1, &VAR_3->poll)) {
spin_unlock_irq(&VAR_4->completion_lock);
return;
}
if (hash_hashed(&VAR_1->hash_node))
hash_del(&VAR_1->hash_node);
io_poll_remove_double(VAR_1, VAR_3->double_poll);
spin_unlock_irq(&VAR_4->completion_lock);
if (!READ_ONCE(VAR_3->poll.canceled))
__io_req_task_submit(VAR_1);
else
__io_req_task_cancel(VAR_1, -VAR_5);
kfree(VAR_3->double_poll);
kfree(VAR_3);
}",torvalds/linux/6d816e088c359866f9867057e04f244c608c42fe/io_uring.c/vul/before/1.json,"static void io_async_task_func(struct callback_head *cb)
{
	struct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);
	struct async_poll *apoll = req->apoll;
	struct io_ring_ctx *ctx = req->ctx;

	trace_io_uring_task_run(req->ctx, req->opcode, req->user_data);

	if (io_poll_rewait(req, &apoll->poll)) {
		spin_unlock_irq(&ctx->completion_lock);
		percpu_ref_put(&ctx->refs);
		return;
	}

	/* If req is still hashed, it cannot have been canceled. Don't check. */
	if (hash_hashed(&req->hash_node))
		hash_del(&req->hash_node);

	io_poll_remove_double(req, apoll->double_poll);
	spin_unlock_irq(&ctx->completion_lock);

	if (!READ_ONCE(apoll->poll.canceled))
		__io_req_task_submit(req);
	else
		__io_req_task_cancel(req, -ECANCELED);

	percpu_ref_put(&ctx->refs);
	kfree(apoll->double_poll);
	kfree(apoll);
}","static void io_async_task_func(struct callback_head *VAR_0)
{
	struct io_kiocb *VAR_1 = container_of(VAR_0, struct io_kiocb, VAR_2);
	struct async_poll *VAR_3 = VAR_1->apoll;
	struct io_ring_ctx *VAR_4 = VAR_1->ctx;

	trace_io_uring_task_run(VAR_1->ctx, VAR_1->opcode, VAR_1->user_data);

	if (io_poll_rewait(VAR_1, &VAR_3->poll)) {
		spin_unlock_irq(&VAR_4->completion_lock);
		percpu_ref_put(&VAR_4->refs);
		return;
	}

	/* COMMENT_0 */
	if (hash_hashed(&VAR_1->hash_node))
		hash_del(&VAR_1->hash_node);

	io_poll_remove_double(VAR_1, VAR_3->double_poll);
	spin_unlock_irq(&VAR_4->completion_lock);

	if (!READ_ONCE(VAR_3->poll.canceled))
		__io_req_task_submit(VAR_1);
	else
		__io_req_task_cancel(VAR_1, -VAR_5);

	percpu_ref_put(&VAR_4->refs);
	kfree(VAR_3->double_poll);
	kfree(VAR_3);
}",torvalds/linux/6d816e088c359866f9867057e04f244c608c42fe/io_uring.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -8,6 +8,7 @@
 
 	if (io_poll_rewait(req, &apoll->poll)) {
 		spin_unlock_irq(&ctx->completion_lock);
+		percpu_ref_put(&ctx->refs);
 		return;
 	}
 
@@ -23,6 +24,7 @@
 	else
 		__io_req_task_cancel(req, -ECANCELED);
 
+	percpu_ref_put(&ctx->refs);
 	kfree(apoll->double_poll);
 	kfree(apoll);
 }","{'deleted_lines': [], 'added_lines': ['\t\tpercpu_ref_put(&ctx->refs);', '\tpercpu_ref_put(&ctx->refs);']}",True,"An issue was discovered in the Linux kernel before 5.8.2. fs/io_uring.c has a use-after-free related to io_async_task_func and ctx reference holding, aka CID-6d816e088c35.",7.8,HIGH,2,test,,5
CVE-2020-36387,['CWE-416'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"We're holding the request reference, but we need to go one higher
to ensure that the ctx remains valid after the request has finished.
If the ring is closed with pending task_work inflight, and the
given io_kiocb finishes sync during issue, then we need a reference
to the ring itself around the task_work execution cycle.

Cc: stable@vger.kernel.org # v5.7+
Reported-by: syzbot+9b260fc33297966f5a8e@syzkaller.appspotmail.com
Signed-off-by: Jens Axboe <axboe@kernel.dk>
",6d816e088c359866f9867057e04f244c608c42fe,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=6d816e088c359866f9867057e04f244c608c42fe,fs/io_uring.c,io_req_task_submit,"static void io_req_task_submit(struct callback_head *cb)
{
struct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);
__io_req_task_submit(req);
}","static void io_req_task_submit(struct callback_head *VAR_0)
{
struct io_kiocb *VAR_1 = container_of(VAR_0, struct io_kiocb, VAR_2);
__io_req_task_submit(VAR_1);
}",torvalds/linux/6d816e088c359866f9867057e04f244c608c42fe/io_uring.c/vul/before/2.json,"static void io_req_task_submit(struct callback_head *cb)
{
	struct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);
	struct io_ring_ctx *ctx = req->ctx;

	__io_req_task_submit(req);
	percpu_ref_put(&ctx->refs);
}","static void io_req_task_submit(struct callback_head *VAR_0)
{
	struct io_kiocb *VAR_1 = container_of(VAR_0, struct io_kiocb, VAR_2);
	struct io_ring_ctx *VAR_3 = VAR_1->ctx;

	__io_req_task_submit(VAR_1);
	percpu_ref_put(&VAR_3->refs);
}",torvalds/linux/6d816e088c359866f9867057e04f244c608c42fe/io_uring.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,6 +1,8 @@
 static void io_req_task_submit(struct callback_head *cb)
 {
 	struct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);
+	struct io_ring_ctx *ctx = req->ctx;
 
 	__io_req_task_submit(req);
+	percpu_ref_put(&ctx->refs);
 }","{'deleted_lines': [], 'added_lines': ['\tstruct io_ring_ctx *ctx = req->ctx;', '\tpercpu_ref_put(&ctx->refs);']}",True,"An issue was discovered in the Linux kernel before 5.8.2. fs/io_uring.c has a use-after-free related to io_async_task_func and ctx reference holding, aka CID-6d816e088c35.",7.8,HIGH,2,test,,5
CVE-2020-36387,['CWE-416'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"We're holding the request reference, but we need to go one higher
to ensure that the ctx remains valid after the request has finished.
If the ring is closed with pending task_work inflight, and the
given io_kiocb finishes sync during issue, then we need a reference
to the ring itself around the task_work execution cycle.

Cc: stable@vger.kernel.org # v5.7+
Reported-by: syzbot+9b260fc33297966f5a8e@syzkaller.appspotmail.com
Signed-off-by: Jens Axboe <axboe@kernel.dk>
",6d816e088c359866f9867057e04f244c608c42fe,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=6d816e088c359866f9867057e04f244c608c42fe,fs/io_uring.c,__io_async_wake,"static int __io_async_wake(struct io_kiocb *req, struct io_poll_iocb *poll,
__poll_t mask, task_work_func_t func)
{
int ret;
if (mask && !(mask & poll->events))
return 0;
trace_io_uring_task_add(req->ctx, req->opcode, req->user_data, mask);
list_del_init(&poll->wait.entry);
req->result = mask;
init_task_work(&req->task_work, func);
ret = io_req_task_work_add(req, &req->task_work);
if (unlikely(ret)) {
struct task_struct *tsk;
WRITE_ONCE(poll->canceled, true);
tsk = io_wq_get_task(req->ctx->io_wq);
task_work_add(tsk, &req->task_work, 0);
wake_up_process(tsk);
}
return 1;
}","static int __io_async_wake(struct io_kiocb *VAR_0, struct io_poll_iocb *VAR_1,
__poll_t VAR_2, task_work_func_t VAR_3)
{
int VAR_4;
if (VAR_2 && !(VAR_2 & VAR_1->events))
return 0;
trace_io_uring_task_add(VAR_0->ctx, VAR_0->opcode, VAR_0->user_data, VAR_2);
list_del_init(&VAR_1->wait.entry);
VAR_0->result = VAR_2;
init_task_work(&VAR_0->task_work, VAR_3);
VAR_4 = io_req_task_work_add(VAR_0, &VAR_0->task_work);
if (unlikely(VAR_4)) {
struct task_struct *VAR_5;
WRITE_ONCE(VAR_1->canceled, true);
VAR_5 = io_wq_get_task(VAR_0->ctx->io_wq);
task_work_add(VAR_5, &VAR_0->task_work, 0);
wake_up_process(VAR_5);
}
return 1;
}",torvalds/linux/6d816e088c359866f9867057e04f244c608c42fe/io_uring.c/vul/before/3.json,"static int __io_async_wake(struct io_kiocb *req, struct io_poll_iocb *poll,
			   __poll_t mask, task_work_func_t func)
{
	int ret;

	/* for instances that support it check for an event match first: */
	if (mask && !(mask & poll->events))
		return 0;

	trace_io_uring_task_add(req->ctx, req->opcode, req->user_data, mask);

	list_del_init(&poll->wait.entry);

	req->result = mask;
	init_task_work(&req->task_work, func);
	percpu_ref_get(&req->ctx->refs);

	/*
	 * If this fails, then the task is exiting. When a task exits, the
	 * work gets canceled, so just cancel this request as well instead
	 * of executing it. We can't safely execute it anyway, as we may not
	 * have the needed state needed for it anyway.
	 */
	ret = io_req_task_work_add(req, &req->task_work);
	if (unlikely(ret)) {
		struct task_struct *tsk;

		WRITE_ONCE(poll->canceled, true);
		tsk = io_wq_get_task(req->ctx->io_wq);
		task_work_add(tsk, &req->task_work, 0);
		wake_up_process(tsk);
	}
	return 1;
}","static int __io_async_wake(struct io_kiocb *VAR_0, struct io_poll_iocb *VAR_1,
			   __poll_t VAR_2, task_work_func_t VAR_3)
{
	int VAR_4;

	/* COMMENT_0 */
	if (VAR_2 && !(VAR_2 & VAR_1->events))
		return 0;

	trace_io_uring_task_add(VAR_0->ctx, VAR_0->opcode, VAR_0->user_data, VAR_2);

	list_del_init(&VAR_1->wait.entry);

	VAR_0->result = VAR_2;
	init_task_work(&VAR_0->task_work, VAR_3);
	percpu_ref_get(&VAR_0->ctx->refs);

	/* COMMENT_1 */
                                                                   
                                                                   
                                                                     
                                               
    
	VAR_4 = io_req_task_work_add(VAR_0, &VAR_0->task_work);
	if (unlikely(VAR_4)) {
		struct task_struct *VAR_5;

		WRITE_ONCE(VAR_1->canceled, true);
		VAR_5 = io_wq_get_task(VAR_0->ctx->io_wq);
		task_work_add(VAR_5, &VAR_0->task_work, 0);
		wake_up_process(VAR_5);
	}
	return 1;
}",torvalds/linux/6d816e088c359866f9867057e04f244c608c42fe/io_uring.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -13,6 +13,8 @@
 
 	req->result = mask;
 	init_task_work(&req->task_work, func);
+	percpu_ref_get(&req->ctx->refs);
+
 	/*
 	 * If this fails, then the task is exiting. When a task exits, the
 	 * work gets canceled, so just cancel this request as well instead","{'deleted_lines': [], 'added_lines': ['\tpercpu_ref_get(&req->ctx->refs);', '']}",True,"An issue was discovered in the Linux kernel before 5.8.2. fs/io_uring.c has a use-after-free related to io_async_task_func and ctx reference holding, aka CID-6d816e088c35.",7.8,HIGH,2,test,,5
CVE-2020-36387,['CWE-416'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"We're holding the request reference, but we need to go one higher
to ensure that the ctx remains valid after the request has finished.
If the ring is closed with pending task_work inflight, and the
given io_kiocb finishes sync during issue, then we need a reference
to the ring itself around the task_work execution cycle.

Cc: stable@vger.kernel.org # v5.7+
Reported-by: syzbot+9b260fc33297966f5a8e@syzkaller.appspotmail.com
Signed-off-by: Jens Axboe <axboe@kernel.dk>
",6d816e088c359866f9867057e04f244c608c42fe,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=6d816e088c359866f9867057e04f244c608c42fe,fs/io_uring.c,io_async_buf_func,"static int io_async_buf_func(struct wait_queue_entry *wait, unsigned mode,
int sync, void *arg)
{
struct wait_page_queue *wpq;
struct io_kiocb *req = wait->private;
struct wait_page_key *key = arg;
int ret;
wpq = container_of(wait, struct wait_page_queue, wait);
if (!wake_page_match(wpq, key))
return 0;
list_del_init(&wait->entry);
init_task_work(&req->task_work, io_req_task_submit);
refcount_inc(&req->refs);
ret = io_req_task_work_add(req, &req->task_work);
if (unlikely(ret)) {
struct task_struct *tsk;
init_task_work(&req->task_work, io_req_task_cancel);
tsk = io_wq_get_task(req->ctx->io_wq);
task_work_add(tsk, &req->task_work, 0);
wake_up_process(tsk);
}
return 1;
}","static int io_async_buf_func(struct wait_queue_entry *VAR_0, unsigned VAR_1,
int VAR_2, void *VAR_3)
{
struct wait_page_queue *VAR_4;
struct io_kiocb *VAR_5 = VAR_0->private;
struct wait_page_key *VAR_6 = VAR_3;
int VAR_7;
VAR_4 = container_of(VAR_0, struct wait_page_queue, VAR_0);
if (!wake_page_match(VAR_4, VAR_6))
return 0;
list_del_init(&VAR_0->entry);
init_task_work(&VAR_5->task_work, VAR_8);
refcount_inc(&VAR_5->refs);
VAR_7 = io_req_task_work_add(VAR_5, &VAR_5->task_work);
if (unlikely(VAR_7)) {
struct task_struct *VAR_9;
init_task_work(&VAR_5->task_work, VAR_10);
VAR_9 = io_wq_get_task(VAR_5->ctx->io_wq);
task_work_add(VAR_9, &VAR_5->task_work, 0);
wake_up_process(VAR_9);
}
return 1;
}",torvalds/linux/6d816e088c359866f9867057e04f244c608c42fe/io_uring.c/vul/before/4.json,"static int io_async_buf_func(struct wait_queue_entry *wait, unsigned mode,
			     int sync, void *arg)
{
	struct wait_page_queue *wpq;
	struct io_kiocb *req = wait->private;
	struct wait_page_key *key = arg;
	int ret;

	wpq = container_of(wait, struct wait_page_queue, wait);

	if (!wake_page_match(wpq, key))
		return 0;

	list_del_init(&wait->entry);

	init_task_work(&req->task_work, io_req_task_submit);
	percpu_ref_get(&req->ctx->refs);

	/* submit ref gets dropped, acquire a new one */
	refcount_inc(&req->refs);
	ret = io_req_task_work_add(req, &req->task_work);
	if (unlikely(ret)) {
		struct task_struct *tsk;

		/* queue just for cancelation */
		init_task_work(&req->task_work, io_req_task_cancel);
		tsk = io_wq_get_task(req->ctx->io_wq);
		task_work_add(tsk, &req->task_work, 0);
		wake_up_process(tsk);
	}
	return 1;
}","static int io_async_buf_func(struct wait_queue_entry *VAR_0, unsigned VAR_1,
			     int VAR_2, void *VAR_3)
{
	struct wait_page_queue *VAR_4;
	struct io_kiocb *VAR_5 = VAR_0->private;
	struct wait_page_key *VAR_6 = VAR_3;
	int VAR_7;

	VAR_4 = container_of(VAR_0, struct wait_page_queue, VAR_0);

	if (!wake_page_match(VAR_4, VAR_6))
		return 0;

	list_del_init(&VAR_0->entry);

	init_task_work(&VAR_5->task_work, VAR_8);
	percpu_ref_get(&VAR_5->ctx->refs);

	/* COMMENT_0 */
	refcount_inc(&VAR_5->refs);
	VAR_7 = io_req_task_work_add(VAR_5, &VAR_5->task_work);
	if (unlikely(VAR_7)) {
		struct task_struct *VAR_9;

		/* COMMENT_1 */
		init_task_work(&VAR_5->task_work, VAR_10);
		VAR_9 = io_wq_get_task(VAR_5->ctx->io_wq);
		task_work_add(VAR_9, &VAR_5->task_work, 0);
		wake_up_process(VAR_9);
	}
	return 1;
}",torvalds/linux/6d816e088c359866f9867057e04f244c608c42fe/io_uring.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -14,6 +14,8 @@
 	list_del_init(&wait->entry);
 
 	init_task_work(&req->task_work, io_req_task_submit);
+	percpu_ref_get(&req->ctx->refs);
+
 	/* submit ref gets dropped, acquire a new one */
 	refcount_inc(&req->refs);
 	ret = io_req_task_work_add(req, &req->task_work);","{'deleted_lines': [], 'added_lines': ['\tpercpu_ref_get(&req->ctx->refs);', '']}",True,"An issue was discovered in the Linux kernel before 5.8.2. fs/io_uring.c has a use-after-free related to io_async_task_func and ctx reference holding, aka CID-6d816e088c35.",7.8,HIGH,2,test,,5
CVE-2020-36387,['CWE-416'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"We're holding the request reference, but we need to go one higher
to ensure that the ctx remains valid after the request has finished.
If the ring is closed with pending task_work inflight, and the
given io_kiocb finishes sync during issue, then we need a reference
to the ring itself around the task_work execution cycle.

Cc: stable@vger.kernel.org # v5.7+
Reported-by: syzbot+9b260fc33297966f5a8e@syzkaller.appspotmail.com
Signed-off-by: Jens Axboe <axboe@kernel.dk>
",6d816e088c359866f9867057e04f244c608c42fe,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=6d816e088c359866f9867057e04f244c608c42fe,fs/io_uring.c,io_poll_task_func,"static void io_poll_task_func(struct callback_head *cb)
{
struct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);
struct io_kiocb *nxt = NULL;
io_poll_task_handler(req, &nxt);
if (nxt)
__io_req_task_submit(nxt);
}","static void io_poll_task_func(struct callback_head *VAR_0)
{
struct io_kiocb *VAR_1 = container_of(VAR_0, struct io_kiocb, VAR_2);
struct io_kiocb *VAR_3 = NULL;
io_poll_task_handler(VAR_1, &VAR_3);
if (VAR_3)
__io_req_task_submit(VAR_3);
}",torvalds/linux/6d816e088c359866f9867057e04f244c608c42fe/io_uring.c/vul/before/5.json,"static void io_poll_task_func(struct callback_head *cb)
{
	struct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);
	struct io_ring_ctx *ctx = req->ctx;
	struct io_kiocb *nxt = NULL;

	io_poll_task_handler(req, &nxt);
	if (nxt)
		__io_req_task_submit(nxt);
	percpu_ref_put(&ctx->refs);
}","static void io_poll_task_func(struct callback_head *VAR_0)
{
	struct io_kiocb *VAR_1 = container_of(VAR_0, struct io_kiocb, VAR_2);
	struct io_ring_ctx *VAR_3 = VAR_1->ctx;
	struct io_kiocb *VAR_4 = NULL;

	io_poll_task_handler(VAR_1, &VAR_4);
	if (VAR_4)
		__io_req_task_submit(VAR_4);
	percpu_ref_put(&VAR_3->refs);
}",torvalds/linux/6d816e088c359866f9867057e04f244c608c42fe/io_uring.c/vul/after/5.json,"--- func_before
+++ func_after
@@ -1,9 +1,11 @@
 static void io_poll_task_func(struct callback_head *cb)
 {
 	struct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);
+	struct io_ring_ctx *ctx = req->ctx;
 	struct io_kiocb *nxt = NULL;
 
 	io_poll_task_handler(req, &nxt);
 	if (nxt)
 		__io_req_task_submit(nxt);
+	percpu_ref_put(&ctx->refs);
 }","{'deleted_lines': [], 'added_lines': ['\tstruct io_ring_ctx *ctx = req->ctx;', '\tpercpu_ref_put(&ctx->refs);']}",True,"An issue was discovered in the Linux kernel before 5.8.2. fs/io_uring.c has a use-after-free related to io_async_task_func and ctx reference holding, aka CID-6d816e088c35.",7.8,HIGH,2,test,,5
CVE-2020-36387,['CWE-416'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"We're holding the request reference, but we need to go one higher
to ensure that the ctx remains valid after the request has finished.
If the ring is closed with pending task_work inflight, and the
given io_kiocb finishes sync during issue, then we need a reference
to the ring itself around the task_work execution cycle.

Cc: stable@vger.kernel.org # v5.7+
Reported-by: syzbot+9b260fc33297966f5a8e@syzkaller.appspotmail.com
Signed-off-by: Jens Axboe <axboe@kernel.dk>
",6d816e088c359866f9867057e04f244c608c42fe,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=6d816e088c359866f9867057e04f244c608c42fe,fs/io_uring.c,io_req_task_queue,"static void io_req_task_queue(struct io_kiocb *req)
{
int ret;
init_task_work(&req->task_work, io_req_task_submit);
ret = io_req_task_work_add(req, &req->task_work);
if (unlikely(ret)) {
struct task_struct *tsk;
init_task_work(&req->task_work, io_req_task_cancel);
tsk = io_wq_get_task(req->ctx->io_wq);
task_work_add(tsk, &req->task_work, 0);
wake_up_process(tsk);
}
}","static void io_req_task_queue(struct io_kiocb *VAR_0)
{
int VAR_1;
init_task_work(&VAR_0->task_work, VAR_2);
VAR_1 = io_req_task_work_add(VAR_0, &VAR_0->task_work);
if (unlikely(VAR_1)) {
struct task_struct *VAR_3;
init_task_work(&VAR_0->task_work, VAR_4);
VAR_3 = io_wq_get_task(VAR_0->ctx->io_wq);
task_work_add(VAR_3, &VAR_0->task_work, 0);
wake_up_process(VAR_3);
}
}",torvalds/linux/6d816e088c359866f9867057e04f244c608c42fe/io_uring.c/vul/before/6.json,"static void io_req_task_queue(struct io_kiocb *req)
{
	int ret;

	init_task_work(&req->task_work, io_req_task_submit);
	percpu_ref_get(&req->ctx->refs);

	ret = io_req_task_work_add(req, &req->task_work);
	if (unlikely(ret)) {
		struct task_struct *tsk;

		init_task_work(&req->task_work, io_req_task_cancel);
		tsk = io_wq_get_task(req->ctx->io_wq);
		task_work_add(tsk, &req->task_work, 0);
		wake_up_process(tsk);
	}
}","static void io_req_task_queue(struct io_kiocb *VAR_0)
{
	int VAR_1;

	init_task_work(&VAR_0->task_work, VAR_2);
	percpu_ref_get(&VAR_0->ctx->refs);

	VAR_1 = io_req_task_work_add(VAR_0, &VAR_0->task_work);
	if (unlikely(VAR_1)) {
		struct task_struct *VAR_3;

		init_task_work(&VAR_0->task_work, VAR_4);
		VAR_3 = io_wq_get_task(VAR_0->ctx->io_wq);
		task_work_add(VAR_3, &VAR_0->task_work, 0);
		wake_up_process(VAR_3);
	}
}",torvalds/linux/6d816e088c359866f9867057e04f244c608c42fe/io_uring.c/vul/after/6.json,"--- func_before
+++ func_after
@@ -3,6 +3,7 @@
 	int ret;
 
 	init_task_work(&req->task_work, io_req_task_submit);
+	percpu_ref_get(&req->ctx->refs);
 
 	ret = io_req_task_work_add(req, &req->task_work);
 	if (unlikely(ret)) {","{'deleted_lines': [], 'added_lines': ['\tpercpu_ref_get(&req->ctx->refs);']}",True,"An issue was discovered in the Linux kernel before 5.8.2. fs/io_uring.c has a use-after-free related to io_async_task_func and ctx reference holding, aka CID-6d816e088c35.",7.8,HIGH,2,test,,5
CVE-2020-36387,['CWE-416'],AV:L/AC:L/Au:N/C:C/I:C/A:C,0,torvalds/linux,"We're holding the request reference, but we need to go one higher
to ensure that the ctx remains valid after the request has finished.
If the ring is closed with pending task_work inflight, and the
given io_kiocb finishes sync during issue, then we need a reference
to the ring itself around the task_work execution cycle.

Cc: stable@vger.kernel.org # v5.7+
Reported-by: syzbot+9b260fc33297966f5a8e@syzkaller.appspotmail.com
Signed-off-by: Jens Axboe <axboe@kernel.dk>
",6d816e088c359866f9867057e04f244c608c42fe,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=6d816e088c359866f9867057e04f244c608c42fe,fs/io_uring.c,io_rw_reissue,"static bool io_rw_reissue(struct io_kiocb *req, long res)
{
#ifdef CONFIG_BLOCK
int ret;
if ((res != -EAGAIN && res != -EOPNOTSUPP) || io_wq_current_is_worker())
return false;
init_task_work(&req->task_work, io_rw_resubmit);
ret = io_req_task_work_add(req, &req->task_work);
if (!ret)
return true;
#endif
return false;
}","static bool io_rw_reissue(struct io_kiocb *VAR_0, long VAR_1)
{
#ifdef VAR_2
int VAR_3;
if ((VAR_1 != -VAR_4 && VAR_1 != -VAR_5) || io_wq_current_is_worker())
return false;
init_task_work(&VAR_0->task_work, VAR_6);
VAR_3 = io_req_task_work_add(VAR_0, &VAR_0->task_work);
if (!VAR_3)
return true;
#endif
return false;
}",torvalds/linux/6d816e088c359866f9867057e04f244c608c42fe/io_uring.c/vul/before/7.json,"static bool io_rw_reissue(struct io_kiocb *req, long res)
{
#ifdef CONFIG_BLOCK
	int ret;

	if ((res != -EAGAIN && res != -EOPNOTSUPP) || io_wq_current_is_worker())
		return false;

	init_task_work(&req->task_work, io_rw_resubmit);
	percpu_ref_get(&req->ctx->refs);

	ret = io_req_task_work_add(req, &req->task_work);
	if (!ret)
		return true;
#endif
	return false;
}","static bool io_rw_reissue(struct io_kiocb *VAR_0, long VAR_1)
{
#ifdef VAR_2
	int VAR_3;

	if ((VAR_1 != -VAR_4 && VAR_1 != -VAR_5) || io_wq_current_is_worker())
		return false;

	init_task_work(&VAR_0->task_work, VAR_6);
	percpu_ref_get(&VAR_0->ctx->refs);

	VAR_3 = io_req_task_work_add(VAR_0, &VAR_0->task_work);
	if (!VAR_3)
		return true;
#endif
	return false;
}",torvalds/linux/6d816e088c359866f9867057e04f244c608c42fe/io_uring.c/vul/after/7.json,"--- func_before
+++ func_after
@@ -7,6 +7,8 @@
 		return false;
 
 	init_task_work(&req->task_work, io_rw_resubmit);
+	percpu_ref_get(&req->ctx->refs);
+
 	ret = io_req_task_work_add(req, &req->task_work);
 	if (!ret)
 		return true;","{'deleted_lines': [], 'added_lines': ['\tpercpu_ref_get(&req->ctx->refs);', '']}",True,"An issue was discovered in the Linux kernel before 5.8.2. fs/io_uring.c has a use-after-free related to io_async_task_func and ctx reference holding, aka CID-6d816e088c35.",7.8,HIGH,2,test,,5
CVE-2014-125008,['CWE-787'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,ffmpeg,"
avformat/oggparsevorbis: check packet size before reading new_len from it

Fixes out of array read
Fixes: 34260c7981118fb38fba61809bf4dd5a-asan_heap-oob_93b923_1508_cov_951051643_DivX640x480_oggvorbis.avi
Found-by: Mateusz ""j00ru"" Jurczyk and Gynvael Coldwind
Signed-off-by: Michael Niedermayer <michaelni@gmx.at>
",f5d1d1e4667ba346ea7e0f97e6d2756bc9d4abde,http://git.videolan.org/?p=ffmpeg.git;a=commit;h=f5d1d1e4667ba346ea7e0f97e6d2756bc9d4abde,libavformat/oggparsevorbis.c,vorbis_header,"static int vorbis_header(AVFormatContext *s, int idx)
{
struct ogg *ogg = s->priv_data;
AVStream *st    = s->streams[idx];
struct ogg_stream *os = ogg->streams + idx;
struct oggvorbis_private *priv;
int pkt_type = os->buf[os->pstart];
if (!os->private) {
os->private = av_mallocz(sizeof(struct oggvorbis_private));
if (!os->private)
return AVERROR(ENOMEM);
}
if (!(pkt_type & 1))
return 0;
if (os->psize < 1 || pkt_type > 5)
return AVERROR_INVALIDDATA;
priv = os->private;
if (priv->packet[pkt_type >> 1])
return AVERROR_INVALIDDATA;
if (pkt_type > 1 && !priv->packet[0] || pkt_type > 3 && !priv->packet[1])
return AVERROR_INVALIDDATA;
priv->len[pkt_type >> 1]    = os->psize;
priv->packet[pkt_type >> 1] = av_mallocz(os->psize);
if (!priv->packet[pkt_type >> 1])
return AVERROR(ENOMEM);
memcpy(priv->packet[pkt_type >> 1], os->buf + os->pstart, os->psize);
if (os->buf[os->pstart] == 1) {
const uint8_t *p = os->buf + os->pstart + 7; 
unsigned blocksize, bs0, bs1;
int srate;
int channels;
if (os->psize != 30)
return AVERROR_INVALIDDATA;
if (bytestream_get_le32(&p) != 0) 
return AVERROR_INVALIDDATA;
channels = bytestream_get_byte(&p);
if (st->codec->channels && channels != st->codec->channels) {
av_log(s, AV_LOG_ERROR, ""Channel change is not supported\n"");
return AVERROR_PATCHWELCOME;
}
st->codec->channels = channels;
srate               = bytestream_get_le32(&p);
p += 4;         st->codec->bit_rate = bytestream_get_le32(&p);         p += 4; 
blocksize = bytestream_get_byte(&p);
bs0       = blocksize & 15;
bs1       = blocksize >> 4;
if (bs0 > bs1)
return AVERROR_INVALIDDATA;
if (bs0 < 6 || bs1 > 13)
return AVERROR_INVALIDDATA;
if (bytestream_get_byte(&p) != 1) 
return AVERROR_INVALIDDATA;
st->codec->codec_type = AVMEDIA_TYPE_AUDIO;
st->codec->codec_id   = AV_CODEC_ID_VORBIS;
if (srate > 0) {
st->codec->sample_rate = srate;
avpriv_set_pts_info(st, 64, 1, srate);
}
} else if (os->buf[os->pstart] == 3) {
if (vorbis_update_metadata(s, idx) >= 0) {
unsigned new_len = 7 + 4 + AV_RL32(priv->packet[1] + 7) + 4 + 1;
if (new_len >= 16 && new_len < os->psize) {
AV_WL32(priv->packet[1] + new_len - 5, 0);
priv->packet[1][new_len - 1] = 1;
priv->len[1]                 = new_len;
}
}
} else {
int ret = fixup_vorbis_headers(s, priv, &st->codec->extradata);
if (ret < 0) {
st->codec->extradata_size = 0;
return ret;
}
st->codec->extradata_size = ret;
if ((ret = avpriv_vorbis_parse_extradata(st->codec, &priv->vp))) {
av_freep(&st->codec->extradata);
st->codec->extradata_size = 0;
return ret;
}
}
return 1;
}","static int vorbis_header(AVFormatContext *VAR_0, int VAR_1)
{
struct ogg *ogg = VAR_0->priv_data;
AVStream *VAR_2    = VAR_0->streams[VAR_1];
struct ogg_stream *VAR_3 = ogg->streams + VAR_1;
struct oggvorbis_private *VAR_4;
int VAR_5 = VAR_3->buf[VAR_3->pstart];
if (!VAR_3->private) {
VAR_3->private = av_mallocz(sizeof(struct oggvorbis_private));
if (!VAR_3->private)
return AVERROR(VAR_6);
}
if (!(VAR_5 & 1))
return 0;
if (VAR_3->psize < 1 || VAR_5 > 5)
return VAR_7;
VAR_4 = VAR_3->private;
if (VAR_4->packet[VAR_5 >> 1])
return VAR_7;
if (VAR_5 > 1 && !VAR_4->packet[0] || VAR_5 > 3 && !VAR_4->packet[1])
return VAR_7;
VAR_4->len[VAR_5 >> 1]    = VAR_3->psize;
VAR_4->packet[VAR_5 >> 1] = av_mallocz(VAR_3->psize);
if (!VAR_4->packet[VAR_5 >> 1])
return AVERROR(VAR_6);
memcpy(VAR_4->packet[VAR_5 >> 1], VAR_3->buf + VAR_3->pstart, VAR_3->psize);
if (VAR_3->buf[VAR_3->pstart] == 1) {
const uint8_t *VAR_8 = VAR_3->buf + VAR_3->pstart + 7; 
unsigned VAR_9, VAR_10, VAR_11;
int VAR_12;
int VAR_13;
if (VAR_3->psize != 30)
return VAR_7;
if (bytestream_get_le32(&VAR_8) != 0) 
return VAR_7;
VAR_13 = bytestream_get_byte(&VAR_8);
if (VAR_2->codec->channels && VAR_13 != VAR_2->codec->channels) {
av_log(VAR_0, VAR_14, ""Channel change is not supported\n"");
return VAR_15;
}
VAR_2->codec->channels = VAR_13;
VAR_12               = bytestream_get_le32(&VAR_8);
VAR_8 += 4; 
VAR_2->codec->bit_rate = bytestream_get_le32(&VAR_8); 
VAR_8 += 4; 
VAR_9 = bytestream_get_byte(&VAR_8);
VAR_10       = VAR_9 & 15;
VAR_11       = VAR_9 >> 4;
if (VAR_10 > VAR_11)
return VAR_7;
if (VAR_10 < 6 || VAR_11 > 13)
return VAR_7;
if (bytestream_get_byte(&VAR_8) != 1) 
return VAR_7;
VAR_2->codec->codec_type = VAR_16;
VAR_2->codec->codec_id   = VAR_17;
if (VAR_12 > 0) {
VAR_2->codec->sample_rate = VAR_12;
avpriv_set_pts_info(VAR_2, 64, 1, VAR_12);
}
} else if (VAR_3->buf[VAR_3->pstart] == 3) {
if (vorbis_update_metadata(VAR_0, VAR_1) >= 0) {
unsigned VAR_18 = 7 + 4 + AV_RL32(VAR_4->packet[1] + 7) + 4 + 1;
if (VAR_18 >= 16 && VAR_18 < VAR_3->psize) {
AV_WL32(VAR_4->packet[1] + VAR_18 - 5, 0);
VAR_4->packet[1][VAR_18 - 1] = 1;
VAR_4->len[1]                 = VAR_18;
}
}
} else {
int VAR_19 = fixup_vorbis_headers(VAR_0, VAR_4, &VAR_2->codec->extradata);
if (VAR_19 < 0) {
VAR_2->codec->extradata_size = 0;
return VAR_19;
}
VAR_2->codec->extradata_size = VAR_19;
if ((VAR_19 = avpriv_vorbis_parse_extradata(VAR_2->codec, &VAR_4->vp))) {
av_freep(&VAR_2->codec->extradata);
VAR_2->codec->extradata_size = 0;
return VAR_19;
}
}
return 1;
}",ffmpeg/f5d1d1e4667ba346ea7e0f97e6d2756bc9d4abde/oggparsevorbis.c/vul/before/0.json,"static int vorbis_header(AVFormatContext *s, int idx)
{
    struct ogg *ogg = s->priv_data;
    AVStream *st    = s->streams[idx];
    struct ogg_stream *os = ogg->streams + idx;
    struct oggvorbis_private *priv;
    int pkt_type = os->buf[os->pstart];

    if (!os->private) {
        os->private = av_mallocz(sizeof(struct oggvorbis_private));
        if (!os->private)
            return AVERROR(ENOMEM);
    }

    if (!(pkt_type & 1))
        return 0;

    if (os->psize < 1 || pkt_type > 5)
        return AVERROR_INVALIDDATA;

    priv = os->private;

    if (priv->packet[pkt_type >> 1])
        return AVERROR_INVALIDDATA;
    if (pkt_type > 1 && !priv->packet[0] || pkt_type > 3 && !priv->packet[1])
        return AVERROR_INVALIDDATA;

    priv->len[pkt_type >> 1]    = os->psize;
    priv->packet[pkt_type >> 1] = av_mallocz(os->psize);
    if (!priv->packet[pkt_type >> 1])
        return AVERROR(ENOMEM);
    memcpy(priv->packet[pkt_type >> 1], os->buf + os->pstart, os->psize);
    if (os->buf[os->pstart] == 1) {
        const uint8_t *p = os->buf + os->pstart + 7; /* skip ""\001vorbis"" tag */
        unsigned blocksize, bs0, bs1;
        int srate;
        int channels;

        if (os->psize != 30)
            return AVERROR_INVALIDDATA;

        if (bytestream_get_le32(&p) != 0) /* vorbis_version */
            return AVERROR_INVALIDDATA;

        channels = bytestream_get_byte(&p);
        if (st->codec->channels && channels != st->codec->channels) {
            av_log(s, AV_LOG_ERROR, ""Channel change is not supported\n"");
            return AVERROR_PATCHWELCOME;
        }
        st->codec->channels = channels;
        srate               = bytestream_get_le32(&p);
        p += 4; // skip maximum bitrate
        st->codec->bit_rate = bytestream_get_le32(&p); // nominal bitrate
        p += 4; // skip minimum bitrate

        blocksize = bytestream_get_byte(&p);
        bs0       = blocksize & 15;
        bs1       = blocksize >> 4;

        if (bs0 > bs1)
            return AVERROR_INVALIDDATA;
        if (bs0 < 6 || bs1 > 13)
            return AVERROR_INVALIDDATA;

        if (bytestream_get_byte(&p) != 1) /* framing_flag */
            return AVERROR_INVALIDDATA;

        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;
        st->codec->codec_id   = AV_CODEC_ID_VORBIS;

        if (srate > 0) {
            st->codec->sample_rate = srate;
            avpriv_set_pts_info(st, 64, 1, srate);
        }
    } else if (os->buf[os->pstart] == 3) {
        if (vorbis_update_metadata(s, idx) >= 0 && priv->len[1] > 10) {
            // drop all metadata we parsed and which is not required by libvorbis
            unsigned new_len = 7 + 4 + AV_RL32(priv->packet[1] + 7) + 4 + 1;
            if (new_len >= 16 && new_len < os->psize) {
                AV_WL32(priv->packet[1] + new_len - 5, 0);
                priv->packet[1][new_len - 1] = 1;
                priv->len[1]                 = new_len;
            }
        }
    } else {
        int ret = fixup_vorbis_headers(s, priv, &st->codec->extradata);
        if (ret < 0) {
            st->codec->extradata_size = 0;
            return ret;
        }
        st->codec->extradata_size = ret;
        if ((ret = avpriv_vorbis_parse_extradata(st->codec, &priv->vp))) {
            av_freep(&st->codec->extradata);
            st->codec->extradata_size = 0;
            return ret;
        }
    }

    return 1;
}","static int vorbis_header(AVFormatContext *VAR_0, int VAR_1)
{
    struct ogg *ogg = VAR_0->priv_data;
    AVStream *VAR_2    = VAR_0->streams[VAR_1];
    struct ogg_stream *VAR_3 = ogg->streams + VAR_1;
    struct oggvorbis_private *VAR_4;
    int VAR_5 = VAR_3->buf[VAR_3->pstart];

    if (!VAR_3->private) {
        VAR_3->private = av_mallocz(sizeof(struct oggvorbis_private));
        if (!VAR_3->private)
            return AVERROR(VAR_6);
    }

    if (!(VAR_5 & 1))
        return 0;

    if (VAR_3->psize < 1 || VAR_5 > 5)
        return VAR_7;

    VAR_4 = VAR_3->private;

    if (VAR_4->packet[VAR_5 >> 1])
        return VAR_7;
    if (VAR_5 > 1 && !VAR_4->packet[0] || VAR_5 > 3 && !VAR_4->packet[1])
        return VAR_7;

    VAR_4->len[VAR_5 >> 1]    = VAR_3->psize;
    VAR_4->packet[VAR_5 >> 1] = av_mallocz(VAR_3->psize);
    if (!VAR_4->packet[VAR_5 >> 1])
        return AVERROR(VAR_6);
    memcpy(VAR_4->packet[VAR_5 >> 1], VAR_3->buf + VAR_3->pstart, VAR_3->psize);
    if (VAR_3->buf[VAR_3->pstart] == 1) {
        const uint8_t *VAR_8 = VAR_3->buf + VAR_3->pstart + 7; /* COMMENT_0 */
        unsigned VAR_9, VAR_10, VAR_11;
        int VAR_12;
        int VAR_13;

        if (VAR_3->psize != 30)
            return VAR_7;

        if (bytestream_get_le32(&VAR_8) != 0) /* COMMENT_1 */
            return VAR_7;

        VAR_13 = bytestream_get_byte(&VAR_8);
        if (VAR_2->codec->channels && VAR_13 != VAR_2->codec->channels) {
            av_log(VAR_0, VAR_14, ""Channel change is not supported\n"");
            return VAR_15;
        }
        VAR_2->codec->channels = VAR_13;
        VAR_12               = bytestream_get_le32(&VAR_8);
        VAR_8 += 4; /* COMMENT_2 */
        VAR_2->codec->bit_rate = bytestream_get_le32(&VAR_8); /* COMMENT_3 */
        VAR_8 += 4; /* COMMENT_4 */

        VAR_9 = bytestream_get_byte(&VAR_8);
        VAR_10       = VAR_9 & 15;
        VAR_11       = VAR_9 >> 4;

        if (VAR_10 > VAR_11)
            return VAR_7;
        if (VAR_10 < 6 || VAR_11 > 13)
            return VAR_7;

        if (bytestream_get_byte(&VAR_8) != 1) /* COMMENT_5 */
            return VAR_7;

        VAR_2->codec->codec_type = VAR_16;
        VAR_2->codec->codec_id   = VAR_17;

        if (VAR_12 > 0) {
            VAR_2->codec->sample_rate = VAR_12;
            avpriv_set_pts_info(VAR_2, 64, 1, VAR_12);
        }
    } else if (VAR_3->buf[VAR_3->pstart] == 3) {
        if (vorbis_update_metadata(VAR_0, VAR_1) >= 0 && VAR_4->len[1] > 10) {
            /* COMMENT_6 */
            unsigned VAR_18 = 7 + 4 + AV_RL32(VAR_4->packet[1] + 7) + 4 + 1;
            if (VAR_18 >= 16 && VAR_18 < VAR_3->psize) {
                AV_WL32(VAR_4->packet[1] + VAR_18 - 5, 0);
                VAR_4->packet[1][VAR_18 - 1] = 1;
                VAR_4->len[1]                 = VAR_18;
            }
        }
    } else {
        int VAR_19 = fixup_vorbis_headers(VAR_0, VAR_4, &VAR_2->codec->extradata);
        if (VAR_19 < 0) {
            VAR_2->codec->extradata_size = 0;
            return VAR_19;
        }
        VAR_2->codec->extradata_size = VAR_19;
        if ((VAR_19 = avpriv_vorbis_parse_extradata(VAR_2->codec, &VAR_4->vp))) {
            av_freep(&VAR_2->codec->extradata);
            VAR_2->codec->extradata_size = 0;
            return VAR_19;
        }
    }

    return 1;
}",ffmpeg/f5d1d1e4667ba346ea7e0f97e6d2756bc9d4abde/oggparsevorbis.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -73,7 +73,7 @@
             avpriv_set_pts_info(st, 64, 1, srate);
         }
     } else if (os->buf[os->pstart] == 3) {
-        if (vorbis_update_metadata(s, idx) >= 0) {
+        if (vorbis_update_metadata(s, idx) >= 0 && priv->len[1] > 10) {
             // drop all metadata we parsed and which is not required by libvorbis
             unsigned new_len = 7 + 4 + AV_RL32(priv->packet[1] + 7) + 4 + 1;
             if (new_len >= 16 && new_len < os->psize) {","{'deleted_lines': ['        if (vorbis_update_metadata(s, idx) >= 0) {'], 'added_lines': ['        if (vorbis_update_metadata(s, idx) >= 0 && priv->len[1] > 10) {']}",True,A vulnerability classified as problematic has been found in FFmpeg 2.0. Affected is the function vorbis_header of the file libavformat/oggparsevorbis.c. The manipulation leads to memory corruption. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue.,5.5,MEDIUM,1,test,,5
CVE-2021-45423,['CWE-120'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,merces/libpe,Checks if ordinal < exp->NumberOfFuntions before assigning value to an element in an array,9b5fedc37ccbcd23695a0e97c0fe46c999e26100,https://github.com/merces/libpe/commit/9b5fedc37ccbcd23695a0e97c0fe46c999e26100,exports.c,pe_exports,"pe_exports_t *pe_exports(pe_ctx_t *ctx) {
if (ctx->cached_data.exports != NULL)
return ctx->cached_data.exports;
pe_exports_t *exports = ctx->cached_data.exports = calloc(1, sizeof(pe_exports_t));
if (exports == NULL) {
return NULL;
}
exports->err = LIBPE_E_OK;
const IMAGE_DATA_DIRECTORY *dir = pe_directory_by_entry(ctx, IMAGE_DIRECTORY_ENTRY_EXPORT);
if (dir == NULL) { 
return exports;
}
const uint64_t va = dir->VirtualAddress;
if (va == 0) {
return exports;
}
uint64_t ofs;
ofs = pe_rva2ofs(ctx, va);
const IMAGE_EXPORT_DIRECTORY *exp = LIBPE_PTR_ADD(ctx->map_addr, ofs);
if (!pe_can_read(ctx, exp, sizeof(IMAGE_EXPORT_DIRECTORY))) {
exports->err = LIBPE_E_EXPORTS_CANT_READ_DIR;
return exports;
}
ofs = pe_rva2ofs(ctx, exp->Name);
const char *name_ptr = LIBPE_PTR_ADD(ctx->map_addr, ofs);
if (!pe_can_read(ctx, name_ptr, 1)) {
exports->err = LIBPE_E_EXPORTS_CANT_READ_RVA;
return exports;
}
exports->name = strdup(name_ptr);
const uint32_t ordinal_base = exp->Base;
ofs = pe_rva2ofs(ctx, exp->AddressOfNames);
const uint32_t *rva_ptr = LIBPE_PTR_ADD(ctx->map_addr, ofs);
if (!pe_can_read(ctx, rva_ptr, sizeof(uint32_t))) {
exports->err = LIBPE_E_EXPORTS_CANT_READ_RVA;
return exports;
}
exports->functions_count = exp->NumberOfFunctions;
exports->functions = calloc(exp->NumberOfFunctions, sizeof(pe_exported_function_t));
if (exports->functions == NULL) {
exports->err = LIBPE_E_ALLOCATION_FAILURE;
return exports;
}
const uint64_t offset_to_AddressOfFunctions = pe_rva2ofs(ctx, exp->AddressOfFunctions);
const uint64_t offset_to_AddressOfNames = pe_rva2ofs(ctx, exp->AddressOfNames);
const uint64_t offset_to_AddressOfNameOrdinals = pe_rva2ofs(ctx, exp->AddressOfNameOrdinals);
uint64_t offsets_to_Names[exp->NumberOfFunctions];
memset(offsets_to_Names, 0, sizeof(offsets_to_Names));  
for (uint32_t i=0; i < exp->NumberOfNames; i++) {
uint64_t entry_ordinal_list_ptr = offset_to_AddressOfNameOrdinals + sizeof(uint16_t) * i;
uint16_t *entry_ordinal_list = LIBPE_PTR_ADD(ctx->map_addr, entry_ordinal_list_ptr);
if (!pe_can_read(ctx, entry_ordinal_list, sizeof(uint16_t))) {
break;
}
const uint16_t ordinal = *entry_ordinal_list;
uint64_t entry_name_list_ptr = offset_to_AddressOfNames + sizeof(uint32_t) * i;
uint32_t *entry_name_list = LIBPE_PTR_ADD(ctx->map_addr, entry_name_list_ptr);
if (!pe_can_read(ctx, entry_name_list, sizeof(uint32_t))) {
break;
}
const uint32_t entry_name_rva = *entry_name_list;
const uint64_t entry_name_ofs = pe_rva2ofs(ctx, entry_name_rva);
offsets_to_Names[ordinal] = entry_name_ofs;
}
for (uint32_t i=0; i < exp->NumberOfFunctions; i++) {
uint64_t entry_va_list_ptr = offset_to_AddressOfFunctions + sizeof(uint32_t) * i;
uint32_t *entry_va_list = LIBPE_PTR_ADD(ctx->map_addr, entry_va_list_ptr);
if (!pe_can_read(ctx, entry_va_list, sizeof(uint32_t))) {
break;
}
const uint32_t entry_va = *entry_va_list;
const uint64_t entry_name_ofs = offsets_to_Names[i];
char fname[300];
fname[0] = 0;
if (entry_name_ofs != 0) {
const char *entry_name = LIBPE_PTR_ADD(ctx->map_addr, entry_name_ofs);
if (!pe_can_read(ctx, entry_name, 1)) {
break;
}
const size_t fname_size = sizeof(fname);
strncpy(fname, entry_name, fname_size-1);
fname[fname_size - 1] = '\0';
}
exports->functions[i].ordinal = ordinal_base + i;
exports->functions[i].address = entry_va;
exports->functions[i].name = strdup(fname);
if (exports->functions[i].name == NULL) {
exports->err = LIBPE_E_ALLOCATION_FAILURE;
return exports;
}
if (entry_va >= va && entry_va <= va + dir->Size) {
const uint64_t fw_entry_name_ofs = pe_rva2ofs(ctx, entry_va);
const char *fw_entry_name = LIBPE_PTR_ADD(ctx->map_addr, fw_entry_name_ofs);
if (!pe_can_read(ctx, fw_entry_name, 1)) {
break;
}
exports->functions[i].fwd_name = strdup(fw_entry_name);
if (exports->functions[i].fwd_name == NULL) {
exports->err = LIBPE_E_ALLOCATION_FAILURE;
return exports;
}
}
}
return exports;
}","pe_exports_t *pe_exports(pe_ctx_t *VAR_0) {
if (VAR_0->cached_data.exports != NULL)
return VAR_0->cached_data.exports;
pe_exports_t *VAR_1 = VAR_0->cached_data.exports = calloc(1, sizeof(pe_exports_t));
if (VAR_1 == NULL) {
return NULL;
}
VAR_1->err = VAR_2;
const IMAGE_DATA_DIRECTORY *VAR_3 = pe_directory_by_entry(VAR_0, VAR_4);
if (VAR_3 == NULL) { 
return VAR_1;
}
const uint64_t VAR_5 = VAR_3->VirtualAddress;
if (VAR_5 == 0) {
return VAR_1;
}
uint64_t VAR_6;
VAR_6 = pe_rva2ofs(VAR_0, VAR_5);
const IMAGE_EXPORT_DIRECTORY *VAR_7 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_6);
if (!pe_can_read(VAR_0, VAR_7, sizeof(IMAGE_EXPORT_DIRECTORY))) {
VAR_1->err = VAR_8;
return VAR_1;
}
VAR_6 = pe_rva2ofs(VAR_0, VAR_7->Name);
const char *VAR_9 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_6);
if (!pe_can_read(VAR_0, VAR_9, 1)) {
VAR_1->err = VAR_10;
return VAR_1;
}
VAR_1->name = strdup(VAR_9);
const uint32_t VAR_11 = VAR_7->Base;
VAR_6 = pe_rva2ofs(VAR_0, VAR_7->AddressOfNames);
const uint32_t *VAR_12 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_6);
if (!pe_can_read(VAR_0, VAR_12, sizeof(uint32_t))) {
VAR_1->err = VAR_10;
return VAR_1;
}
VAR_1->functions_count = VAR_7->NumberOfFunctions;
VAR_1->functions = calloc(VAR_7->NumberOfFunctions, sizeof(VAR_13));
if (VAR_1->functions == NULL) {
VAR_1->err = VAR_14;
return VAR_1;
}
const uint64_t VAR_15 = pe_rva2ofs(VAR_0, VAR_7->AddressOfFunctions);
const uint64_t VAR_16 = pe_rva2ofs(VAR_0, VAR_7->AddressOfNames);
const uint64_t VAR_17 = pe_rva2ofs(VAR_0, VAR_7->AddressOfNameOrdinals);
uint64_t VAR_18[VAR_7->NumberOfFunctions];
memset(VAR_18, 0, sizeof(VAR_18));  
for (uint32_t VAR_19=0; VAR_19 < VAR_7->NumberOfNames; VAR_19++) {
uint64_t VAR_20 = VAR_17 + sizeof(uint16_t) * VAR_19;
uint16_t *VAR_21 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_20);
if (!pe_can_read(VAR_0, VAR_21, sizeof(uint16_t))) {
break;
}
const uint16_t VAR_22 = *VAR_21;
uint64_t VAR_23 = VAR_16 + sizeof(uint32_t) * VAR_19;
uint32_t *VAR_24 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_23);
if (!pe_can_read(VAR_0, VAR_24, sizeof(uint32_t))) {
break;
}
const uint32_t VAR_25 = *VAR_24;
const uint64_t VAR_26 = pe_rva2ofs(VAR_0, VAR_25);
VAR_18[VAR_22] = VAR_26;
}
for (uint32_t VAR_19=0; VAR_19 < VAR_7->NumberOfFunctions; VAR_19++) {
uint64_t VAR_27 = VAR_15 + sizeof(uint32_t) * VAR_19;
uint32_t *VAR_28 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_27);
if (!pe_can_read(VAR_0, VAR_28, sizeof(uint32_t))) {
break;
}
const uint32_t VAR_29 = *VAR_28;
const uint64_t VAR_26 = VAR_18[VAR_19];
char VAR_30[300];
VAR_30[0] = 0;
if (VAR_26 != 0) {
const char *VAR_31 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_26);
if (!pe_can_read(VAR_0, VAR_31, 1)) {
break;
}
const size_t VAR_32 = sizeof(VAR_30);
strncpy(VAR_30, VAR_31, VAR_32-1);
VAR_30[VAR_32 - 1] = '\0';
}
VAR_1->functions[VAR_19].ordinal = VAR_11 + VAR_19;
VAR_1->functions[VAR_19].address = VAR_29;
VAR_1->functions[VAR_19].name = strdup(VAR_30);
if (VAR_1->functions[VAR_19].name == NULL) {
VAR_1->err = VAR_14;
return VAR_1;
}
if (VAR_29 >= VAR_5 && VAR_29 <= VAR_5 + VAR_3->Size) {
const uint64_t VAR_33 = pe_rva2ofs(VAR_0, VAR_29);
const char *VAR_34 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_33);
if (!pe_can_read(VAR_0, VAR_34, 1)) {
break;
}
VAR_1->functions[VAR_19].fwd_name = strdup(VAR_34);
if (VAR_1->functions[VAR_19].fwd_name == NULL) {
VAR_1->err = VAR_14;
return VAR_1;
}
}
}
return VAR_1;
}",merces/libpe/9b5fedc37ccbcd23695a0e97c0fe46c999e26100/exports.c/vul/before/0.json,"pe_exports_t *pe_exports(pe_ctx_t *ctx) {
	if (ctx->cached_data.exports != NULL)
		return ctx->cached_data.exports;

	pe_exports_t *exports = ctx->cached_data.exports = calloc(1, sizeof(pe_exports_t));
	if (exports == NULL) {
		// TODO(jweyrich): Should we report an error? If yes, we need a redesign.
		return NULL;
	}

	exports->err = LIBPE_E_OK;

	const IMAGE_DATA_DIRECTORY *dir = pe_directory_by_entry(ctx, IMAGE_DIRECTORY_ENTRY_EXPORT);
	if (dir == NULL) { 
		return exports;
	}

	const uint64_t va = dir->VirtualAddress;
	if (va == 0) {
		// NOTE: This file has no exported symbols.
		return exports;
	}

	uint64_t ofs;

	ofs = pe_rva2ofs(ctx, va);
	const IMAGE_EXPORT_DIRECTORY *exp = LIBPE_PTR_ADD(ctx->map_addr, ofs);
	if (!pe_can_read(ctx, exp, sizeof(IMAGE_EXPORT_DIRECTORY))) {
		exports->err = LIBPE_E_EXPORTS_CANT_READ_DIR;
		return exports;
	}

	ofs = pe_rva2ofs(ctx, exp->Name);
	const char *name_ptr = LIBPE_PTR_ADD(ctx->map_addr, ofs);
	if (!pe_can_read(ctx, name_ptr, 1)) {
		exports->err = LIBPE_E_EXPORTS_CANT_READ_RVA;
		return exports;
	}

	exports->name = strdup(name_ptr);
	
	const uint32_t ordinal_base = exp->Base;
	
	ofs = pe_rva2ofs(ctx, exp->AddressOfNames);
	const uint32_t *rva_ptr = LIBPE_PTR_ADD(ctx->map_addr, ofs);
	if (!pe_can_read(ctx, rva_ptr, sizeof(uint32_t))) {
		exports->err = LIBPE_E_EXPORTS_CANT_READ_RVA;
		return exports;
	}

	// If `NumberOfNames == 0` then all functions are exported by ordinal.
	// Otherwise `NumberOfNames` should be equal to `NumberOfFunctions`
	// if (exp->NumberOfNames != 0 && exp->NumberOfNames != exp->NumberOfFunctions) {
	// 	exports->err = LIBPE_E_EXPORTS_FUNC_NEQ_NAMES;
	// 	return exports;
	// }

	//
	// The format of IMAGE_EXPORT_DIRECTORY can be seen in http://i.msdn.microsoft.com/dynimg/IC60608.gif
	//

	// We want to use `NumberOfFunctions` for looping as it's the total number of functions/symbols
	// exported by the module. On the other hand, `NumberOfNames` is the number of
	// functions/symbols exported by name only.

	exports->functions_count = exp->NumberOfFunctions;
	exports->functions = calloc(exp->NumberOfFunctions, sizeof(pe_exported_function_t));
	if (exports->functions == NULL) {
		exports->err = LIBPE_E_ALLOCATION_FAILURE;
		return exports;
	}

	const uint64_t offset_to_AddressOfFunctions = pe_rva2ofs(ctx, exp->AddressOfFunctions);
	const uint64_t offset_to_AddressOfNames = pe_rva2ofs(ctx, exp->AddressOfNames);
	const uint64_t offset_to_AddressOfNameOrdinals = pe_rva2ofs(ctx, exp->AddressOfNameOrdinals);

	uint64_t offsets_to_Names[exp->NumberOfFunctions];
	memset(offsets_to_Names, 0, sizeof(offsets_to_Names));  // This is needed for VLAs.

	//
	// Names
	//
	
	for (uint32_t i=0; i < exp->NumberOfNames; i++) {
		uint64_t entry_ordinal_list_ptr = offset_to_AddressOfNameOrdinals + sizeof(uint16_t) * i;
		uint16_t *entry_ordinal_list = LIBPE_PTR_ADD(ctx->map_addr, entry_ordinal_list_ptr);

		if (!pe_can_read(ctx, entry_ordinal_list, sizeof(uint16_t))) {
			// TODO: Should we report something?
			break;
		}
		const uint16_t ordinal = *entry_ordinal_list;

		uint64_t entry_name_list_ptr = offset_to_AddressOfNames + sizeof(uint32_t) * i;
		uint32_t *entry_name_list = LIBPE_PTR_ADD(ctx->map_addr, entry_name_list_ptr);

		if (!pe_can_read(ctx, entry_name_list, sizeof(uint32_t))) {
			// TODO: Should we report something?
			break;
		}

		const uint32_t entry_name_rva = *entry_name_list;
		const uint64_t entry_name_ofs = pe_rva2ofs(ctx, entry_name_rva);

        if (ordinal < exp->NumberOfFuntions) {
            offsets_to_Names[ordinal] = entry_name_ofs;
        }
	}

	//
	// Functions
	//

	for (uint32_t i=0; i < exp->NumberOfFunctions; i++) {
		uint64_t entry_va_list_ptr = offset_to_AddressOfFunctions + sizeof(uint32_t) * i;
		uint32_t *entry_va_list = LIBPE_PTR_ADD(ctx->map_addr, entry_va_list_ptr);

		if (!pe_can_read(ctx, entry_va_list, sizeof(uint32_t))) {
			break;
		}

		// Add `Base` to the element of `AddressOfNameOrdinals` array to get the correct ordinal..
		//const uint16_t entry_ordinal = exp->Base + *entry_ordinal_list;
		const uint32_t entry_va = *entry_va_list;
		const uint64_t entry_name_ofs = offsets_to_Names[i];

		// FIX: Don't need to zero all elements!
		// FIXME: 300 bytes is enough or too much?
		char fname[300];
		fname[0] = 0;

		if (entry_name_ofs != 0) {
			const char *entry_name = LIBPE_PTR_ADD(ctx->map_addr, entry_name_ofs);

			// Validate whether it's ok to access at least 1 byte after entry_name.
			// It might be '\0', for example.
			if (!pe_can_read(ctx, entry_name, 1)) {
				break;
			}

			//printf(""ord=%d, va=%x, name=%s\n"", entry_ordinal, entry_va, entry_name);

			const size_t fname_size = sizeof(fname);
			strncpy(fname, entry_name, fname_size-1);
			// Because `strncpy` does not guarantee to NUL terminate the string itself, this must be done explicitly.
			fname[fname_size - 1] = '\0';
		}

		exports->functions[i].ordinal = ordinal_base + i;
		exports->functions[i].address = entry_va;

		exports->functions[i].name = strdup(fname);
		if (exports->functions[i].name == NULL) {
			exports->err = LIBPE_E_ALLOCATION_FAILURE;
			return exports;
		}

		// Check whether the exported function is forwarded.
		// It's forwarded if its RVA is inside the exports section.
		if (entry_va >= va && entry_va <= va + dir->Size) {
			// When a symbol is forwarded, its RVA points to a string containing
			// the name of the DLL and symbol to which it is forwarded.
			const uint64_t fw_entry_name_ofs = pe_rva2ofs(ctx, entry_va);
			const char *fw_entry_name = LIBPE_PTR_ADD(ctx->map_addr, fw_entry_name_ofs);

			// Validate whether it's ok to access at least 1 byte after fw_entry_name.
			// It might be '\0', for example.
			if (!pe_can_read(ctx, fw_entry_name, 1)) {
				break;
			}

			exports->functions[i].fwd_name = strdup(fw_entry_name);
			if (exports->functions[i].fwd_name == NULL) {
				exports->err = LIBPE_E_ALLOCATION_FAILURE;
				return exports;
			}
		}
	}

	return exports;
}","pe_exports_t *pe_exports(pe_ctx_t *VAR_0) {
	if (VAR_0->cached_data.exports != NULL)
		return VAR_0->cached_data.exports;

	pe_exports_t *VAR_1 = VAR_0->cached_data.exports = calloc(1, sizeof(pe_exports_t));
	if (VAR_1 == NULL) {
		/* COMMENT_0 */
		return NULL;
	}

	VAR_1->err = VAR_2;

	const IMAGE_DATA_DIRECTORY *VAR_3 = pe_directory_by_entry(VAR_0, VAR_4);
	if (VAR_3 == NULL) { 
		return VAR_1;
	}

	const uint64_t VAR_5 = VAR_3->VirtualAddress;
	if (VAR_5 == 0) {
		/* COMMENT_1 */
		return VAR_1;
	}

	uint64_t VAR_6;

	VAR_6 = pe_rva2ofs(VAR_0, VAR_5);
	const IMAGE_EXPORT_DIRECTORY *VAR_7 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_6);
	if (!pe_can_read(VAR_0, VAR_7, sizeof(IMAGE_EXPORT_DIRECTORY))) {
		VAR_1->err = VAR_8;
		return VAR_1;
	}

	VAR_6 = pe_rva2ofs(VAR_0, VAR_7->Name);
	const char *VAR_9 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_6);
	if (!pe_can_read(VAR_0, VAR_9, 1)) {
		VAR_1->err = VAR_10;
		return VAR_1;
	}

	VAR_1->name = strdup(VAR_9);
	
	const uint32_t VAR_11 = VAR_7->Base;
	
	VAR_6 = pe_rva2ofs(VAR_0, VAR_7->AddressOfNames);
	const uint32_t *VAR_12 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_6);
	if (!pe_can_read(VAR_0, VAR_12, sizeof(uint32_t))) {
		VAR_1->err = VAR_10;
		return VAR_1;
	}

	/* COMMENT_2 */
	/* COMMENT_3 */
	/* COMMENT_4 */
	/* COMMENT_5 */
	/* COMMENT_6 */
	/* COMMENT_7 */

	/* COMMENT_8 */
	/* COMMENT_9 */
	/* COMMENT_8 */

	/* COMMENT_10 */
	/* COMMENT_11 */
	/* COMMENT_12 */

	VAR_1->functions_count = VAR_7->NumberOfFunctions;
	VAR_1->functions = calloc(VAR_7->NumberOfFunctions, sizeof(VAR_13));
	if (VAR_1->functions == NULL) {
		VAR_1->err = VAR_14;
		return VAR_1;
	}

	const uint64_t VAR_15 = pe_rva2ofs(VAR_0, VAR_7->AddressOfFunctions);
	const uint64_t VAR_16 = pe_rva2ofs(VAR_0, VAR_7->AddressOfNames);
	const uint64_t VAR_17 = pe_rva2ofs(VAR_0, VAR_7->AddressOfNameOrdinals);

	uint64_t VAR_18[VAR_7->NumberOfFunctions];
	memset(VAR_18, 0, sizeof(VAR_18));  /* COMMENT_13 */

	/* COMMENT_8 */
	/* COMMENT_14 */
	/* COMMENT_8 */
	
	for (uint32_t VAR_19=0; VAR_19 < VAR_7->NumberOfNames; VAR_19++) {
		uint64_t VAR_20 = VAR_17 + sizeof(uint16_t) * VAR_19;
		uint16_t *VAR_21 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_20);

		if (!pe_can_read(VAR_0, VAR_21, sizeof(uint16_t))) {
			/* COMMENT_15 */
			break;
		}
		const uint16_t VAR_22 = *VAR_21;

		uint64_t VAR_23 = VAR_16 + sizeof(uint32_t) * VAR_19;
		uint32_t *VAR_24 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_23);

		if (!pe_can_read(VAR_0, VAR_24, sizeof(uint32_t))) {
			/* COMMENT_15 */
			break;
		}

		const uint32_t VAR_25 = *VAR_24;
		const uint64_t VAR_26 = pe_rva2ofs(VAR_0, VAR_25);

        if (VAR_22 < VAR_7->NumberOfFuntions) {
            VAR_18[VAR_22] = VAR_26;
        }
	}

	/* COMMENT_8 */
	/* COMMENT_16 */
	/* COMMENT_8 */

	for (uint32_t VAR_19=0; VAR_19 < VAR_7->NumberOfFunctions; VAR_19++) {
		uint64_t VAR_27 = VAR_15 + sizeof(uint32_t) * VAR_19;
		uint32_t *VAR_28 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_27);

		if (!pe_can_read(VAR_0, VAR_28, sizeof(uint32_t))) {
			break;
		}

		/* COMMENT_17 */
		/* COMMENT_18 */
		const uint32_t VAR_29 = *VAR_28;
		const uint64_t VAR_26 = VAR_18[VAR_19];

		/* COMMENT_19 */
		/* COMMENT_20 */
		char VAR_30[300];
		VAR_30[0] = 0;

		if (VAR_26 != 0) {
			const char *VAR_31 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_26);

			/* COMMENT_21 */
			/* COMMENT_22 */
			if (!pe_can_read(VAR_0, VAR_31, 1)) {
				break;
			}

			/* COMMENT_23 */

			const size_t VAR_32 = sizeof(VAR_30);
			strncpy(VAR_30, VAR_31, VAR_32-1);
			/* COMMENT_24 */
			VAR_30[VAR_32 - 1] = '\0';
		}

		VAR_1->functions[VAR_19].ordinal = VAR_11 + VAR_19;
		VAR_1->functions[VAR_19].address = VAR_29;

		VAR_1->functions[VAR_19].name = strdup(VAR_30);
		if (VAR_1->functions[VAR_19].name == NULL) {
			VAR_1->err = VAR_14;
			return VAR_1;
		}

		/* COMMENT_25 */
		/* COMMENT_26 */
		if (VAR_29 >= VAR_5 && VAR_29 <= VAR_5 + VAR_3->Size) {
			/* COMMENT_27 */
			/* COMMENT_28 */
			const uint64_t VAR_33 = pe_rva2ofs(VAR_0, VAR_29);
			const char *VAR_34 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_33);

			/* COMMENT_29 */
			/* COMMENT_22 */
			if (!pe_can_read(VAR_0, VAR_34, 1)) {
				break;
			}

			VAR_1->functions[VAR_19].fwd_name = strdup(VAR_34);
			if (VAR_1->functions[VAR_19].fwd_name == NULL) {
				VAR_1->err = VAR_14;
				return VAR_1;
			}
		}
	}

	return VAR_1;
}",merces/libpe/9b5fedc37ccbcd23695a0e97c0fe46c999e26100/exports.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -101,7 +101,10 @@
 
 		const uint32_t entry_name_rva = *entry_name_list;
 		const uint64_t entry_name_ofs = pe_rva2ofs(ctx, entry_name_rva);
-		offsets_to_Names[ordinal] = entry_name_ofs;
+
+        if (ordinal < exp->NumberOfFuntions) {
+            offsets_to_Names[ordinal] = entry_name_ofs;
+        }
 	}
 
 	//","{'deleted_lines': ['\t\toffsets_to_Names[ordinal] = entry_name_ofs;'], 'added_lines': ['', '        if (ordinal < exp->NumberOfFuntions) {', '            offsets_to_Names[ordinal] = entry_name_ofs;', '        }']}",True,"A Buffer Overflow vulnerabilityexists in Pev 0.81 via the pe_exports function from exports.c.. The array offsets_to_Names is dynamically allocated on the stack using exp->NumberOfFunctions as its size. However, the loop uses exp->NumberOfNames to iterate over it and set its components value. Therefore, the loop code assumes that exp->NumberOfFunctions is greater than ordinal at each iteration. This can lead to arbitrary code execution.",9.8,CRITICAL,3,test,,5
CVE-2021-45423,['CWE-120'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,merces/libpe,Fix typo,8960f7d710c4d1a43badd2bbf273721248b864f8,https://github.com/merces/libpe/commit/8960f7d710c4d1a43badd2bbf273721248b864f8,exports.c,pe_exports,"pe_exports_t *pe_exports(pe_ctx_t *ctx) {
if (ctx->cached_data.exports != NULL)
return ctx->cached_data.exports;
pe_exports_t *exports = ctx->cached_data.exports = calloc(1, sizeof(pe_exports_t));
if (exports == NULL) {
return NULL;
}
exports->err = LIBPE_E_OK;
const IMAGE_DATA_DIRECTORY *dir = pe_directory_by_entry(ctx, IMAGE_DIRECTORY_ENTRY_EXPORT);
if (dir == NULL) { 
return exports;
}
const uint64_t va = dir->VirtualAddress;
if (va == 0) {
return exports;
}
uint64_t ofs;
ofs = pe_rva2ofs(ctx, va);
const IMAGE_EXPORT_DIRECTORY *exp = LIBPE_PTR_ADD(ctx->map_addr, ofs);
if (!pe_can_read(ctx, exp, sizeof(IMAGE_EXPORT_DIRECTORY))) {
exports->err = LIBPE_E_EXPORTS_CANT_READ_DIR;
return exports;
}
ofs = pe_rva2ofs(ctx, exp->Name);
const char *name_ptr = LIBPE_PTR_ADD(ctx->map_addr, ofs);
if (!pe_can_read(ctx, name_ptr, 1)) {
exports->err = LIBPE_E_EXPORTS_CANT_READ_RVA;
return exports;
}
exports->name = strdup(name_ptr);
const uint32_t ordinal_base = exp->Base;
ofs = pe_rva2ofs(ctx, exp->AddressOfNames);
const uint32_t *rva_ptr = LIBPE_PTR_ADD(ctx->map_addr, ofs);
if (!pe_can_read(ctx, rva_ptr, sizeof(uint32_t))) {
exports->err = LIBPE_E_EXPORTS_CANT_READ_RVA;
return exports;
}
exports->functions_count = exp->NumberOfFunctions;
exports->functions = calloc(exp->NumberOfFunctions, sizeof(pe_exported_function_t));
if (exports->functions == NULL) {
exports->err = LIBPE_E_ALLOCATION_FAILURE;
return exports;
}
const uint64_t offset_to_AddressOfFunctions = pe_rva2ofs(ctx, exp->AddressOfFunctions);
const uint64_t offset_to_AddressOfNames = pe_rva2ofs(ctx, exp->AddressOfNames);
const uint64_t offset_to_AddressOfNameOrdinals = pe_rva2ofs(ctx, exp->AddressOfNameOrdinals);
uint64_t offsets_to_Names[exp->NumberOfFunctions];
memset(offsets_to_Names, 0, sizeof(offsets_to_Names));  
for (uint32_t i=0; i < exp->NumberOfNames; i++) {
uint64_t entry_ordinal_list_ptr = offset_to_AddressOfNameOrdinals + sizeof(uint16_t) * i;
uint16_t *entry_ordinal_list = LIBPE_PTR_ADD(ctx->map_addr, entry_ordinal_list_ptr);
if (!pe_can_read(ctx, entry_ordinal_list, sizeof(uint16_t))) {
break;
}
const uint16_t ordinal = *entry_ordinal_list;
uint64_t entry_name_list_ptr = offset_to_AddressOfNames + sizeof(uint32_t) * i;
uint32_t *entry_name_list = LIBPE_PTR_ADD(ctx->map_addr, entry_name_list_ptr);
if (!pe_can_read(ctx, entry_name_list, sizeof(uint32_t))) {
break;
}
const uint32_t entry_name_rva = *entry_name_list;
const uint64_t entry_name_ofs = pe_rva2ofs(ctx, entry_name_rva);
if (ordinal < exp->NumberOfFuntions) {
offsets_to_Names[ordinal] = entry_name_ofs;
}
}
for (uint32_t i=0; i < exp->NumberOfFunctions; i++) {
uint64_t entry_va_list_ptr = offset_to_AddressOfFunctions + sizeof(uint32_t) * i;
uint32_t *entry_va_list = LIBPE_PTR_ADD(ctx->map_addr, entry_va_list_ptr);
if (!pe_can_read(ctx, entry_va_list, sizeof(uint32_t))) {
break;
}
const uint32_t entry_va = *entry_va_list;
const uint64_t entry_name_ofs = offsets_to_Names[i];
char fname[300];
fname[0] = 0;
if (entry_name_ofs != 0) {
const char *entry_name = LIBPE_PTR_ADD(ctx->map_addr, entry_name_ofs);
if (!pe_can_read(ctx, entry_name, 1)) {
break;
}
const size_t fname_size = sizeof(fname);
strncpy(fname, entry_name, fname_size-1);
fname[fname_size - 1] = '\0';
}
exports->functions[i].ordinal = ordinal_base + i;
exports->functions[i].address = entry_va;
exports->functions[i].name = strdup(fname);
if (exports->functions[i].name == NULL) {
exports->err = LIBPE_E_ALLOCATION_FAILURE;
return exports;
}
if (entry_va >= va && entry_va <= va + dir->Size) {
const uint64_t fw_entry_name_ofs = pe_rva2ofs(ctx, entry_va);
const char *fw_entry_name = LIBPE_PTR_ADD(ctx->map_addr, fw_entry_name_ofs);
if (!pe_can_read(ctx, fw_entry_name, 1)) {
break;
}
exports->functions[i].fwd_name = strdup(fw_entry_name);
if (exports->functions[i].fwd_name == NULL) {
exports->err = LIBPE_E_ALLOCATION_FAILURE;
return exports;
}
}
}
return exports;
}","pe_exports_t *pe_exports(pe_ctx_t *VAR_0) {
if (VAR_0->cached_data.exports != NULL)
return VAR_0->cached_data.exports;
pe_exports_t *VAR_1 = VAR_0->cached_data.exports = calloc(1, sizeof(pe_exports_t));
if (VAR_1 == NULL) {
return NULL;
}
VAR_1->err = VAR_2;
const IMAGE_DATA_DIRECTORY *VAR_3 = pe_directory_by_entry(VAR_0, VAR_4);
if (VAR_3 == NULL) { 
return VAR_1;
}
const uint64_t VAR_5 = VAR_3->VirtualAddress;
if (VAR_5 == 0) {
return VAR_1;
}
uint64_t VAR_6;
VAR_6 = pe_rva2ofs(VAR_0, VAR_5);
const IMAGE_EXPORT_DIRECTORY *VAR_7 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_6);
if (!pe_can_read(VAR_0, VAR_7, sizeof(IMAGE_EXPORT_DIRECTORY))) {
VAR_1->err = VAR_8;
return VAR_1;
}
VAR_6 = pe_rva2ofs(VAR_0, VAR_7->Name);
const char *VAR_9 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_6);
if (!pe_can_read(VAR_0, VAR_9, 1)) {
VAR_1->err = VAR_10;
return VAR_1;
}
VAR_1->name = strdup(VAR_9);
const uint32_t VAR_11 = VAR_7->Base;
VAR_6 = pe_rva2ofs(VAR_0, VAR_7->AddressOfNames);
const uint32_t *VAR_12 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_6);
if (!pe_can_read(VAR_0, VAR_12, sizeof(uint32_t))) {
VAR_1->err = VAR_10;
return VAR_1;
}
VAR_1->functions_count = VAR_7->NumberOfFunctions;
VAR_1->functions = calloc(VAR_7->NumberOfFunctions, sizeof(VAR_13));
if (VAR_1->functions == NULL) {
VAR_1->err = VAR_14;
return VAR_1;
}
const uint64_t VAR_15 = pe_rva2ofs(VAR_0, VAR_7->AddressOfFunctions);
const uint64_t VAR_16 = pe_rva2ofs(VAR_0, VAR_7->AddressOfNames);
const uint64_t VAR_17 = pe_rva2ofs(VAR_0, VAR_7->AddressOfNameOrdinals);
uint64_t VAR_18[VAR_7->NumberOfFunctions];
memset(VAR_18, 0, sizeof(VAR_18));  
for (uint32_t VAR_19=0; VAR_19 < VAR_7->NumberOfNames; VAR_19++) {
uint64_t VAR_20 = VAR_17 + sizeof(uint16_t) * VAR_19;
uint16_t *VAR_21 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_20);
if (!pe_can_read(VAR_0, VAR_21, sizeof(uint16_t))) {
break;
}
const uint16_t VAR_22 = *VAR_21;
uint64_t VAR_23 = VAR_16 + sizeof(uint32_t) * VAR_19;
uint32_t *VAR_24 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_23);
if (!pe_can_read(VAR_0, VAR_24, sizeof(uint32_t))) {
break;
}
const uint32_t VAR_25 = *VAR_24;
const uint64_t VAR_26 = pe_rva2ofs(VAR_0, VAR_25);
if (VAR_22 < VAR_7->NumberOfFuntions) {
VAR_18[VAR_22] = VAR_26;
}
}
for (uint32_t VAR_19=0; VAR_19 < VAR_7->NumberOfFunctions; VAR_19++) {
uint64_t VAR_27 = VAR_15 + sizeof(uint32_t) * VAR_19;
uint32_t *VAR_28 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_27);
if (!pe_can_read(VAR_0, VAR_28, sizeof(uint32_t))) {
break;
}
const uint32_t VAR_29 = *VAR_28;
const uint64_t VAR_26 = VAR_18[VAR_19];
char VAR_30[300];
VAR_30[0] = 0;
if (VAR_26 != 0) {
const char *VAR_31 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_26);
if (!pe_can_read(VAR_0, VAR_31, 1)) {
break;
}
const size_t VAR_32 = sizeof(VAR_30);
strncpy(VAR_30, VAR_31, VAR_32-1);
VAR_30[VAR_32 - 1] = '\0';
}
VAR_1->functions[VAR_19].ordinal = VAR_11 + VAR_19;
VAR_1->functions[VAR_19].address = VAR_29;
VAR_1->functions[VAR_19].name = strdup(VAR_30);
if (VAR_1->functions[VAR_19].name == NULL) {
VAR_1->err = VAR_14;
return VAR_1;
}
if (VAR_29 >= VAR_5 && VAR_29 <= VAR_5 + VAR_3->Size) {
const uint64_t VAR_33 = pe_rva2ofs(VAR_0, VAR_29);
const char *VAR_34 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_33);
if (!pe_can_read(VAR_0, VAR_34, 1)) {
break;
}
VAR_1->functions[VAR_19].fwd_name = strdup(VAR_34);
if (VAR_1->functions[VAR_19].fwd_name == NULL) {
VAR_1->err = VAR_14;
return VAR_1;
}
}
}
return VAR_1;
}",merces/libpe/8960f7d710c4d1a43badd2bbf273721248b864f8/exports.c/vul/before/0.json,"pe_exports_t *pe_exports(pe_ctx_t *ctx) {
	if (ctx->cached_data.exports != NULL)
		return ctx->cached_data.exports;

	pe_exports_t *exports = ctx->cached_data.exports = calloc(1, sizeof(pe_exports_t));
	if (exports == NULL) {
		// TODO(jweyrich): Should we report an error? If yes, we need a redesign.
		return NULL;
	}

	exports->err = LIBPE_E_OK;

	const IMAGE_DATA_DIRECTORY *dir = pe_directory_by_entry(ctx, IMAGE_DIRECTORY_ENTRY_EXPORT);
	if (dir == NULL) { 
		return exports;
	}

	const uint64_t va = dir->VirtualAddress;
	if (va == 0) {
		// NOTE: This file has no exported symbols.
		return exports;
	}

	uint64_t ofs;

	ofs = pe_rva2ofs(ctx, va);
	const IMAGE_EXPORT_DIRECTORY *exp = LIBPE_PTR_ADD(ctx->map_addr, ofs);
	if (!pe_can_read(ctx, exp, sizeof(IMAGE_EXPORT_DIRECTORY))) {
		exports->err = LIBPE_E_EXPORTS_CANT_READ_DIR;
		return exports;
	}

	ofs = pe_rva2ofs(ctx, exp->Name);
	const char *name_ptr = LIBPE_PTR_ADD(ctx->map_addr, ofs);
	if (!pe_can_read(ctx, name_ptr, 1)) {
		exports->err = LIBPE_E_EXPORTS_CANT_READ_RVA;
		return exports;
	}

	exports->name = strdup(name_ptr);
	
	const uint32_t ordinal_base = exp->Base;
	
	ofs = pe_rva2ofs(ctx, exp->AddressOfNames);
	const uint32_t *rva_ptr = LIBPE_PTR_ADD(ctx->map_addr, ofs);
	if (!pe_can_read(ctx, rva_ptr, sizeof(uint32_t))) {
		exports->err = LIBPE_E_EXPORTS_CANT_READ_RVA;
		return exports;
	}

	// If `NumberOfNames == 0` then all functions are exported by ordinal.
	// Otherwise `NumberOfNames` should be equal to `NumberOfFunctions`
	// if (exp->NumberOfNames != 0 && exp->NumberOfNames != exp->NumberOfFunctions) {
	// 	exports->err = LIBPE_E_EXPORTS_FUNC_NEQ_NAMES;
	// 	return exports;
	// }

	//
	// The format of IMAGE_EXPORT_DIRECTORY can be seen in http://i.msdn.microsoft.com/dynimg/IC60608.gif
	//

	// We want to use `NumberOfFunctions` for looping as it's the total number of functions/symbols
	// exported by the module. On the other hand, `NumberOfNames` is the number of
	// functions/symbols exported by name only.

	exports->functions_count = exp->NumberOfFunctions;
	exports->functions = calloc(exp->NumberOfFunctions, sizeof(pe_exported_function_t));
	if (exports->functions == NULL) {
		exports->err = LIBPE_E_ALLOCATION_FAILURE;
		return exports;
	}

	const uint64_t offset_to_AddressOfFunctions = pe_rva2ofs(ctx, exp->AddressOfFunctions);
	const uint64_t offset_to_AddressOfNames = pe_rva2ofs(ctx, exp->AddressOfNames);
	const uint64_t offset_to_AddressOfNameOrdinals = pe_rva2ofs(ctx, exp->AddressOfNameOrdinals);

	uint64_t offsets_to_Names[exp->NumberOfFunctions];
	memset(offsets_to_Names, 0, sizeof(offsets_to_Names));  // This is needed for VLAs.

	//
	// Names
	//
	
	for (uint32_t i=0; i < exp->NumberOfNames; i++) {
		uint64_t entry_ordinal_list_ptr = offset_to_AddressOfNameOrdinals + sizeof(uint16_t) * i;
		uint16_t *entry_ordinal_list = LIBPE_PTR_ADD(ctx->map_addr, entry_ordinal_list_ptr);

		if (!pe_can_read(ctx, entry_ordinal_list, sizeof(uint16_t))) {
			// TODO: Should we report something?
			break;
		}
		const uint16_t ordinal = *entry_ordinal_list;

		uint64_t entry_name_list_ptr = offset_to_AddressOfNames + sizeof(uint32_t) * i;
		uint32_t *entry_name_list = LIBPE_PTR_ADD(ctx->map_addr, entry_name_list_ptr);

		if (!pe_can_read(ctx, entry_name_list, sizeof(uint32_t))) {
			// TODO: Should we report something?
			break;
		}

		const uint32_t entry_name_rva = *entry_name_list;
		const uint64_t entry_name_ofs = pe_rva2ofs(ctx, entry_name_rva);

        if (ordinal < exp->NumberOfFunctions) {
            offsets_to_Names[ordinal] = entry_name_ofs;
        }
	}

	//
	// Functions
	//

	for (uint32_t i=0; i < exp->NumberOfFunctions; i++) {
		uint64_t entry_va_list_ptr = offset_to_AddressOfFunctions + sizeof(uint32_t) * i;
		uint32_t *entry_va_list = LIBPE_PTR_ADD(ctx->map_addr, entry_va_list_ptr);

		if (!pe_can_read(ctx, entry_va_list, sizeof(uint32_t))) {
			break;
		}

		// Add `Base` to the element of `AddressOfNameOrdinals` array to get the correct ordinal..
		//const uint16_t entry_ordinal = exp->Base + *entry_ordinal_list;
		const uint32_t entry_va = *entry_va_list;
		const uint64_t entry_name_ofs = offsets_to_Names[i];

		// FIX: Don't need to zero all elements!
		// FIXME: 300 bytes is enough or too much?
		char fname[300];
		fname[0] = 0;

		if (entry_name_ofs != 0) {
			const char *entry_name = LIBPE_PTR_ADD(ctx->map_addr, entry_name_ofs);

			// Validate whether it's ok to access at least 1 byte after entry_name.
			// It might be '\0', for example.
			if (!pe_can_read(ctx, entry_name, 1)) {
				break;
			}

			//printf(""ord=%d, va=%x, name=%s\n"", entry_ordinal, entry_va, entry_name);

			const size_t fname_size = sizeof(fname);
			strncpy(fname, entry_name, fname_size-1);
			// Because `strncpy` does not guarantee to NUL terminate the string itself, this must be done explicitly.
			fname[fname_size - 1] = '\0';
		}

		exports->functions[i].ordinal = ordinal_base + i;
		exports->functions[i].address = entry_va;

		exports->functions[i].name = strdup(fname);
		if (exports->functions[i].name == NULL) {
			exports->err = LIBPE_E_ALLOCATION_FAILURE;
			return exports;
		}

		// Check whether the exported function is forwarded.
		// It's forwarded if its RVA is inside the exports section.
		if (entry_va >= va && entry_va <= va + dir->Size) {
			// When a symbol is forwarded, its RVA points to a string containing
			// the name of the DLL and symbol to which it is forwarded.
			const uint64_t fw_entry_name_ofs = pe_rva2ofs(ctx, entry_va);
			const char *fw_entry_name = LIBPE_PTR_ADD(ctx->map_addr, fw_entry_name_ofs);

			// Validate whether it's ok to access at least 1 byte after fw_entry_name.
			// It might be '\0', for example.
			if (!pe_can_read(ctx, fw_entry_name, 1)) {
				break;
			}

			exports->functions[i].fwd_name = strdup(fw_entry_name);
			if (exports->functions[i].fwd_name == NULL) {
				exports->err = LIBPE_E_ALLOCATION_FAILURE;
				return exports;
			}
		}
	}

	return exports;
}","pe_exports_t *pe_exports(pe_ctx_t *VAR_0) {
	if (VAR_0->cached_data.exports != NULL)
		return VAR_0->cached_data.exports;

	pe_exports_t *VAR_1 = VAR_0->cached_data.exports = calloc(1, sizeof(pe_exports_t));
	if (VAR_1 == NULL) {
		/* COMMENT_0 */
		return NULL;
	}

	VAR_1->err = VAR_2;

	const IMAGE_DATA_DIRECTORY *VAR_3 = pe_directory_by_entry(VAR_0, VAR_4);
	if (VAR_3 == NULL) { 
		return VAR_1;
	}

	const uint64_t VAR_5 = VAR_3->VirtualAddress;
	if (VAR_5 == 0) {
		/* COMMENT_1 */
		return VAR_1;
	}

	uint64_t VAR_6;

	VAR_6 = pe_rva2ofs(VAR_0, VAR_5);
	const IMAGE_EXPORT_DIRECTORY *VAR_7 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_6);
	if (!pe_can_read(VAR_0, VAR_7, sizeof(IMAGE_EXPORT_DIRECTORY))) {
		VAR_1->err = VAR_8;
		return VAR_1;
	}

	VAR_6 = pe_rva2ofs(VAR_0, VAR_7->Name);
	const char *VAR_9 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_6);
	if (!pe_can_read(VAR_0, VAR_9, 1)) {
		VAR_1->err = VAR_10;
		return VAR_1;
	}

	VAR_1->name = strdup(VAR_9);
	
	const uint32_t VAR_11 = VAR_7->Base;
	
	VAR_6 = pe_rva2ofs(VAR_0, VAR_7->AddressOfNames);
	const uint32_t *VAR_12 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_6);
	if (!pe_can_read(VAR_0, VAR_12, sizeof(uint32_t))) {
		VAR_1->err = VAR_10;
		return VAR_1;
	}

	/* COMMENT_2 */
	/* COMMENT_3 */
	/* COMMENT_4 */
	/* COMMENT_5 */
	/* COMMENT_6 */
	/* COMMENT_7 */

	/* COMMENT_8 */
	/* COMMENT_9 */
	/* COMMENT_8 */

	/* COMMENT_10 */
	/* COMMENT_11 */
	/* COMMENT_12 */

	VAR_1->functions_count = VAR_7->NumberOfFunctions;
	VAR_1->functions = calloc(VAR_7->NumberOfFunctions, sizeof(VAR_13));
	if (VAR_1->functions == NULL) {
		VAR_1->err = VAR_14;
		return VAR_1;
	}

	const uint64_t VAR_15 = pe_rva2ofs(VAR_0, VAR_7->AddressOfFunctions);
	const uint64_t VAR_16 = pe_rva2ofs(VAR_0, VAR_7->AddressOfNames);
	const uint64_t VAR_17 = pe_rva2ofs(VAR_0, VAR_7->AddressOfNameOrdinals);

	uint64_t VAR_18[VAR_7->NumberOfFunctions];
	memset(VAR_18, 0, sizeof(VAR_18));  /* COMMENT_13 */

	/* COMMENT_8 */
	/* COMMENT_14 */
	/* COMMENT_8 */
	
	for (uint32_t VAR_19=0; VAR_19 < VAR_7->NumberOfNames; VAR_19++) {
		uint64_t VAR_20 = VAR_17 + sizeof(uint16_t) * VAR_19;
		uint16_t *VAR_21 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_20);

		if (!pe_can_read(VAR_0, VAR_21, sizeof(uint16_t))) {
			/* COMMENT_15 */
			break;
		}
		const uint16_t VAR_22 = *VAR_21;

		uint64_t VAR_23 = VAR_16 + sizeof(uint32_t) * VAR_19;
		uint32_t *VAR_24 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_23);

		if (!pe_can_read(VAR_0, VAR_24, sizeof(uint32_t))) {
			/* COMMENT_15 */
			break;
		}

		const uint32_t VAR_25 = *VAR_24;
		const uint64_t VAR_26 = pe_rva2ofs(VAR_0, VAR_25);

        if (VAR_22 < VAR_7->NumberOfFunctions) {
            VAR_18[VAR_22] = VAR_26;
        }
	}

	/* COMMENT_8 */
	/* COMMENT_16 */
	/* COMMENT_8 */

	for (uint32_t VAR_19=0; VAR_19 < VAR_7->NumberOfFunctions; VAR_19++) {
		uint64_t VAR_27 = VAR_15 + sizeof(uint32_t) * VAR_19;
		uint32_t *VAR_28 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_27);

		if (!pe_can_read(VAR_0, VAR_28, sizeof(uint32_t))) {
			break;
		}

		/* COMMENT_17 */
		/* COMMENT_18 */
		const uint32_t VAR_29 = *VAR_28;
		const uint64_t VAR_26 = VAR_18[VAR_19];

		/* COMMENT_19 */
		/* COMMENT_20 */
		char VAR_30[300];
		VAR_30[0] = 0;

		if (VAR_26 != 0) {
			const char *VAR_31 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_26);

			/* COMMENT_21 */
			/* COMMENT_22 */
			if (!pe_can_read(VAR_0, VAR_31, 1)) {
				break;
			}

			/* COMMENT_23 */

			const size_t VAR_32 = sizeof(VAR_30);
			strncpy(VAR_30, VAR_31, VAR_32-1);
			/* COMMENT_24 */
			VAR_30[VAR_32 - 1] = '\0';
		}

		VAR_1->functions[VAR_19].ordinal = VAR_11 + VAR_19;
		VAR_1->functions[VAR_19].address = VAR_29;

		VAR_1->functions[VAR_19].name = strdup(VAR_30);
		if (VAR_1->functions[VAR_19].name == NULL) {
			VAR_1->err = VAR_14;
			return VAR_1;
		}

		/* COMMENT_25 */
		/* COMMENT_26 */
		if (VAR_29 >= VAR_5 && VAR_29 <= VAR_5 + VAR_3->Size) {
			/* COMMENT_27 */
			/* COMMENT_28 */
			const uint64_t VAR_33 = pe_rva2ofs(VAR_0, VAR_29);
			const char *VAR_34 = LIBPE_PTR_ADD(VAR_0->map_addr, VAR_33);

			/* COMMENT_29 */
			/* COMMENT_22 */
			if (!pe_can_read(VAR_0, VAR_34, 1)) {
				break;
			}

			VAR_1->functions[VAR_19].fwd_name = strdup(VAR_34);
			if (VAR_1->functions[VAR_19].fwd_name == NULL) {
				VAR_1->err = VAR_14;
				return VAR_1;
			}
		}
	}

	return VAR_1;
}",merces/libpe/8960f7d710c4d1a43badd2bbf273721248b864f8/exports.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -102,7 +102,7 @@
 		const uint32_t entry_name_rva = *entry_name_list;
 		const uint64_t entry_name_ofs = pe_rva2ofs(ctx, entry_name_rva);
 
-        if (ordinal < exp->NumberOfFuntions) {
+        if (ordinal < exp->NumberOfFunctions) {
             offsets_to_Names[ordinal] = entry_name_ofs;
         }
 	}","{'deleted_lines': ['        if (ordinal < exp->NumberOfFuntions) {'], 'added_lines': ['        if (ordinal < exp->NumberOfFunctions) {']}",True,"A Buffer Overflow vulnerabilityexists in Pev 0.81 via the pe_exports function from exports.c.. The array offsets_to_Names is dynamically allocated on the stack using exp->NumberOfFunctions as its size. However, the loop uses exp->NumberOfNames to iterate over it and set its components value. Therefore, the loop code assumes that exp->NumberOfFunctions is greater than ordinal at each iteration. This can lead to arbitrary code execution.",9.8,CRITICAL,3,test,,5
CVE-2023-1075,['CWE-843'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N,1,torvalds/linux,"tls_is_tx_ready() checks that list_first_entry() does not return NULL.
This condition can never happen. For empty lists, list_first_entry()
returns the list_entry() of the head, which is a type confusion.
Use list_first_entry_or_null() which returns NULL in case of empty
lists.

Fixes: a42055e8d2c3 (""net/tls: Add support for async encryption of records for performance"")
Signed-off-by: Pietro Borrello <borrello@diag.uniroma1.it>
Link: https://lore.kernel.org/r/20230128-list-entry-null-check-tls-v1-1-525bbfe6f0d0@diag.uniroma1.it
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
",ffe2a22562444720b05bdfeb999c03e810d84cbb,https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/?h=ffe2a22562444720b05bdfeb999c03e810d84cbb,net/tls/tls_sw.c,tls_is_tx_ready,"static bool tls_is_tx_ready(struct tls_sw_context_tx *ctx)
{
struct tls_rec *rec;
rec = list_first_entry(&ctx->tx_list, struct tls_rec, list);
if (!rec)
return false;
return READ_ONCE(rec->tx_ready);
}","static bool tls_is_tx_ready(struct tls_sw_context_tx *VAR_0)
{
struct tls_rec *VAR_1;
VAR_1 = list_first_entry(&VAR_0->tx_list, struct tls_rec, VAR_2);
if (!VAR_1)
return false;
return READ_ONCE(VAR_1->tx_ready);
}",torvalds/linux/ffe2a22562444720b05bdfeb999c03e810d84cbb/tls_sw.c/vul/before/0.json,"static bool tls_is_tx_ready(struct tls_sw_context_tx *ctx)
{
	struct tls_rec *rec;

	rec = list_first_entry_or_null(&ctx->tx_list, struct tls_rec, list);
	if (!rec)
		return false;

	return READ_ONCE(rec->tx_ready);
}","static bool tls_is_tx_ready(struct tls_sw_context_tx *VAR_0)
{
	struct tls_rec *VAR_1;

	VAR_1 = list_first_entry_or_null(&VAR_0->tx_list, struct tls_rec, VAR_2);
	if (!VAR_1)
		return false;

	return READ_ONCE(VAR_1->tx_ready);
}",torvalds/linux/ffe2a22562444720b05bdfeb999c03e810d84cbb/tls_sw.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
 {
 	struct tls_rec *rec;
 
-	rec = list_first_entry(&ctx->tx_list, struct tls_rec, list);
+	rec = list_first_entry_or_null(&ctx->tx_list, struct tls_rec, list);
 	if (!rec)
 		return false;
 ","{'deleted_lines': ['\trec = list_first_entry(&ctx->tx_list, struct tls_rec, list);'], 'added_lines': ['\trec = list_first_entry_or_null(&ctx->tx_list, struct tls_rec, list);']}",True,"A flaw was found in the Linux Kernel. The tls_is_tx_ready() incorrectly checks for list emptiness, potentially accessing a type confused entry to the list_head, leaking the last byte of the confused field that overlaps with rec->tx_ready.",3.3,LOW,0,test,,5
CVE-2023-0465,['CWE-295'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N,1,openssl,"
Ensure that EXFLAG_INVALID_POLICY is checked even in leaf certs

Even though we check the leaf cert to confirm it is valid, we
later ignored the invalid flag and did not notice that the leaf
cert was bad.

Fixes: CVE-2023-0465
Reviewed-by: Hugo Landau <hlandau@openssl.org>
Reviewed-by: Tomas Mraz <tomas@openssl.org>
(Merged from https://github.com/openssl/openssl/pull/20586)
",facfb1ab745646e97a1920977ae4a9965ea61d5c,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=facfb1ab745646e97a1920977ae4a9965ea61d5c,crypto/x509/x509_vfy.c,check_policy,"static int check_policy(X509_STORE_CTX *ctx)
{
int ret;
if (ctx->parent)
return 1;
if (ctx->bare_ta_signed && !sk_X509_push(ctx->chain, NULL))
goto memerr;
ret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,
ctx->param->policies, ctx->param->flags);
if (ctx->bare_ta_signed)
(void)sk_X509_pop(ctx->chain);
if (ret == X509_PCY_TREE_INTERNAL)
goto memerr;
if (ret == X509_PCY_TREE_INVALID) {
int i;
for (i = 1; i < sk_X509_num(ctx->chain); i++) {
X509 *x = sk_X509_value(ctx->chain, i);
CB_FAIL_IF((x->ex_flags & EXFLAG_INVALID_POLICY) != 0,
ctx, x, i, X509_V_ERR_INVALID_POLICY_EXTENSION);
}
return 1;
}
if (ret == X509_PCY_TREE_FAILURE) {
ctx->current_cert = NULL;
ctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;
return ctx->verify_cb(0, ctx);
}
if (ret != X509_PCY_TREE_VALID) {
ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);
return 0;
}
if ((ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY) != 0) {
ctx->current_cert = NULL;
if (!ctx->verify_cb(2, ctx))
return 0;
}
return 1;
memerr:
ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
ctx->error = X509_V_ERR_OUT_OF_MEM;
return -1;
}","static int check_policy(X509_STORE_CTX *VAR_0)
{
int VAR_1;
if (VAR_0->parent)
return 1;
if (VAR_0->bare_ta_signed && !sk_X509_push(VAR_0->chain, NULL))
goto memerr;
VAR_1 = X509_policy_check(&VAR_0->tree, &VAR_0->explicit_policy, VAR_0->chain,
VAR_0->param->policies, VAR_0->param->flags);
if (VAR_0->bare_ta_signed)
(void)sk_X509_pop(VAR_0->chain);
if (VAR_1 == VAR_2)
goto memerr;
if (VAR_1 == VAR_3) {
int VAR_4;
for (VAR_4 = 1; VAR_4 < sk_X509_num(VAR_0->chain); VAR_4++) {
X509 *VAR_5 = sk_X509_value(VAR_0->chain, VAR_4);
CB_FAIL_IF((VAR_5->ex_flags & VAR_6) != 0,
VAR_0, VAR_5, VAR_4, VAR_7);
}
return 1;
}
if (VAR_1 == VAR_8) {
VAR_0->current_cert = NULL;
VAR_0->error = VAR_9;
return VAR_0->verify_cb(0, VAR_0);
}
if (VAR_1 != VAR_10) {
ERR_raise(VAR_11, VAR_12);
return 0;
}
if ((VAR_0->param->flags & VAR_13) != 0) {
VAR_0->current_cert = NULL;
if (!VAR_0->verify_cb(2, VAR_0))
return 0;
}
return 1;
memerr:
ERR_raise(VAR_11, VAR_14);
VAR_0->error = VAR_15;
return -1;
}",openssl/facfb1ab745646e97a1920977ae4a9965ea61d5c/x509_vfy.c/vul/before/0.json,"static int check_policy(X509_STORE_CTX *ctx)
{
    int ret;

    if (ctx->parent)
        return 1;
    /*
     * With DANE, the trust anchor might be a bare public key, not a
     * certificate!  In that case our chain does not have the trust anchor
     * certificate as a top-most element.  This comports well with RFC5280
     * chain verification, since there too, the trust anchor is not part of the
     * chain to be verified.  In particular, X509_policy_check() does not look
     * at the TA cert, but assumes that it is present as the top-most chain
     * element.  We therefore temporarily push a NULL cert onto the chain if it
     * was verified via a bare public key, and pop it off right after the
     * X509_policy_check() call.
     */
    if (ctx->bare_ta_signed && !sk_X509_push(ctx->chain, NULL))
        goto memerr;
    ret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,
                            ctx->param->policies, ctx->param->flags);
    if (ctx->bare_ta_signed)
        (void)sk_X509_pop(ctx->chain);

    if (ret == X509_PCY_TREE_INTERNAL)
        goto memerr;
    /* Invalid or inconsistent extensions */
    if (ret == X509_PCY_TREE_INVALID) {
        int i, cbcalled = 0;

        /* Locate certificates with bad extensions and notify callback. */
        for (i = 0; i < sk_X509_num(ctx->chain); i++) {
            X509 *x = sk_X509_value(ctx->chain, i);

            if ((x->ex_flags & EXFLAG_INVALID_POLICY) != 0)
                cbcalled = 1;
            CB_FAIL_IF((x->ex_flags & EXFLAG_INVALID_POLICY) != 0,
                       ctx, x, i, X509_V_ERR_INVALID_POLICY_EXTENSION);
        }
        if (!cbcalled) {
            /* Should not be able to get here */
            ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);
            return 0;
        }
        /* The callback ignored the error so we return success */
        return 1;
    }
    if (ret == X509_PCY_TREE_FAILURE) {
        ctx->current_cert = NULL;
        ctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;
        return ctx->verify_cb(0, ctx);
    }
    if (ret != X509_PCY_TREE_VALID) {
        ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);
        return 0;
    }

    if ((ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY) != 0) {
        ctx->current_cert = NULL;
        /*
         * Verification errors need to be ""sticky"", a callback may have allowed
         * an SSL handshake to continue despite an error, and we must then
         * remain in an error state.  Therefore, we MUST NOT clear earlier
         * verification errors by setting the error to X509_V_OK.
         */
        if (!ctx->verify_cb(2, ctx))
            return 0;
    }

    return 1;

 memerr:
    ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
    ctx->error = X509_V_ERR_OUT_OF_MEM;
    return -1;
}","static int check_policy(X509_STORE_CTX *VAR_0)
{
    int VAR_1;

    if (VAR_0->parent)
        return 1;
    /* COMMENT_0 */
                                                                    
                                                                          
                                                                          
                                                                               
                                                                              
                                                                           
                                                                               
                                                                         
                                
       
    if (VAR_0->bare_ta_signed && !sk_X509_push(VAR_0->chain, NULL))
        goto memerr;
    VAR_1 = X509_policy_check(&VAR_0->tree, &VAR_0->explicit_policy, VAR_0->chain,
                            VAR_0->param->policies, VAR_0->param->flags);
    if (VAR_0->bare_ta_signed)
        (void)sk_X509_pop(VAR_0->chain);

    if (VAR_1 == VAR_2)
        goto memerr;
    /* COMMENT_11 */
    if (VAR_1 == VAR_3) {
        int VAR_4, VAR_5 = 0;

        /* COMMENT_12 */
        for (VAR_4 = 0; VAR_4 < sk_X509_num(VAR_0->chain); VAR_4++) {
            X509 *VAR_6 = sk_X509_value(VAR_0->chain, VAR_4);

            if ((VAR_6->ex_flags & VAR_7) != 0)
                VAR_5 = 1;
            CB_FAIL_IF((VAR_6->ex_flags & VAR_7) != 0,
                       VAR_0, VAR_6, VAR_4, VAR_8);
        }
        if (!VAR_5) {
            /* COMMENT_13 */
            ERR_raise(VAR_9, VAR_10);
            return 0;
        }
        /* COMMENT_14 */
        return 1;
    }
    if (VAR_1 == VAR_11) {
        VAR_0->current_cert = NULL;
        VAR_0->error = VAR_12;
        return VAR_0->verify_cb(0, VAR_0);
    }
    if (VAR_1 != VAR_13) {
        ERR_raise(VAR_9, VAR_10);
        return 0;
    }

    if ((VAR_0->param->flags & VAR_14) != 0) {
        VAR_0->current_cert = NULL;
        /* COMMENT_15 */
                                                                               
                                                                          
                                                                          
                                                                 
           
        if (!VAR_0->verify_cb(2, VAR_0))
            return 0;
    }

    return 1;

 memerr:
    ERR_raise(VAR_9, VAR_15);
    VAR_0->error = VAR_16;
    return -1;
}",openssl/facfb1ab745646e97a1920977ae4a9965ea61d5c/x509_vfy.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -26,15 +26,23 @@
         goto memerr;
     /* Invalid or inconsistent extensions */
     if (ret == X509_PCY_TREE_INVALID) {
-        int i;
+        int i, cbcalled = 0;
 
         /* Locate certificates with bad extensions and notify callback. */
-        for (i = 1; i < sk_X509_num(ctx->chain); i++) {
+        for (i = 0; i < sk_X509_num(ctx->chain); i++) {
             X509 *x = sk_X509_value(ctx->chain, i);
 
+            if ((x->ex_flags & EXFLAG_INVALID_POLICY) != 0)
+                cbcalled = 1;
             CB_FAIL_IF((x->ex_flags & EXFLAG_INVALID_POLICY) != 0,
                        ctx, x, i, X509_V_ERR_INVALID_POLICY_EXTENSION);
         }
+        if (!cbcalled) {
+            /* Should not be able to get here */
+            ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);
+            return 0;
+        }
+        /* The callback ignored the error so we return success */
         return 1;
     }
     if (ret == X509_PCY_TREE_FAILURE) {","{'deleted_lines': ['        int i;', '        for (i = 1; i < sk_X509_num(ctx->chain); i++) {'], 'added_lines': ['        int i, cbcalled = 0;', '        for (i = 0; i < sk_X509_num(ctx->chain); i++) {', '            if ((x->ex_flags & EXFLAG_INVALID_POLICY) != 0)', '                cbcalled = 1;', '        if (!cbcalled) {', '            /* Should not be able to get here */', '            ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);', '            return 0;', '        }', '        /* The callback ignored the error so we return success */']}",True,"Applications that use a non-default option when verifying certificates may be
vulnerable to an attack from a malicious CA to circumvent certain checks.

Invalid certificate policies in leaf certificates are silently ignored by
OpenSSL and other certificate policy checks are skipped for that certificate.
A malicious CA could use this to deliberately assert invalid certificate policies
in order to circumvent policy checking on the certificate altogether.

Policy processing is disabled by default but can be enabled by passing
the `-policy' argument to the command line utilities or by calling the
`X509_VERIFY_PARAM_set1_policies()' function.",5.3,MEDIUM,1,test,,5
CVE-2023-0465,['CWE-295'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N,1,openssl,"
Ensure that EXFLAG_INVALID_POLICY is checked even in leaf certs

Even though we check the leaf cert to confirm it is valid, we
later ignored the invalid flag and did not notice that the leaf
cert was bad.

Fixes: CVE-2023-0465
Reviewed-by: Hugo Landau <hlandau@openssl.org>
Reviewed-by: Tomas Mraz <tomas@openssl.org>
(Merged from https://github.com/openssl/openssl/pull/20587)
",1dd43e0709fece299b15208f36cc7c76209ba0bb,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=1dd43e0709fece299b15208f36cc7c76209ba0bb,crypto/x509/x509_vfy.c,check_policy,"static int check_policy(X509_STORE_CTX *ctx)
{
int ret;
if (ctx->parent)
return 1;
if (ctx->bare_ta_signed && !sk_X509_push(ctx->chain, NULL))
goto memerr;
ret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,
ctx->param->policies, ctx->param->flags);
if (ctx->bare_ta_signed)
(void)sk_X509_pop(ctx->chain);
if (ret == X509_PCY_TREE_INTERNAL)
goto memerr;
if (ret == X509_PCY_TREE_INVALID) {
int i;
for (i = 1; i < sk_X509_num(ctx->chain); i++) {
X509 *x = sk_X509_value(ctx->chain, i);
CB_FAIL_IF((x->ex_flags & EXFLAG_INVALID_POLICY) != 0,
ctx, x, i, X509_V_ERR_INVALID_POLICY_EXTENSION);
}
return 1;
}
if (ret == X509_PCY_TREE_FAILURE) {
ctx->current_cert = NULL;
ctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;
return ctx->verify_cb(0, ctx);
}
if (ret != X509_PCY_TREE_VALID) {
ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);
return 0;
}
if ((ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY) != 0) {
ctx->current_cert = NULL;
if (!ctx->verify_cb(2, ctx))
return 0;
}
return 1;
memerr:
ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
ctx->error = X509_V_ERR_OUT_OF_MEM;
return -1;
}","static int check_policy(X509_STORE_CTX *VAR_0)
{
int VAR_1;
if (VAR_0->parent)
return 1;
if (VAR_0->bare_ta_signed && !sk_X509_push(VAR_0->chain, NULL))
goto memerr;
VAR_1 = X509_policy_check(&VAR_0->tree, &VAR_0->explicit_policy, VAR_0->chain,
VAR_0->param->policies, VAR_0->param->flags);
if (VAR_0->bare_ta_signed)
(void)sk_X509_pop(VAR_0->chain);
if (VAR_1 == VAR_2)
goto memerr;
if (VAR_1 == VAR_3) {
int VAR_4;
for (VAR_4 = 1; VAR_4 < sk_X509_num(VAR_0->chain); VAR_4++) {
X509 *VAR_5 = sk_X509_value(VAR_0->chain, VAR_4);
CB_FAIL_IF((VAR_5->ex_flags & VAR_6) != 0,
VAR_0, VAR_5, VAR_4, VAR_7);
}
return 1;
}
if (VAR_1 == VAR_8) {
VAR_0->current_cert = NULL;
VAR_0->error = VAR_9;
return VAR_0->verify_cb(0, VAR_0);
}
if (VAR_1 != VAR_10) {
ERR_raise(VAR_11, VAR_12);
return 0;
}
if ((VAR_0->param->flags & VAR_13) != 0) {
VAR_0->current_cert = NULL;
if (!VAR_0->verify_cb(2, VAR_0))
return 0;
}
return 1;
memerr:
ERR_raise(VAR_11, VAR_14);
VAR_0->error = VAR_15;
return -1;
}",openssl/1dd43e0709fece299b15208f36cc7c76209ba0bb/x509_vfy.c/vul/before/0.json,"static int check_policy(X509_STORE_CTX *ctx)
{
    int ret;

    if (ctx->parent)
        return 1;
    /*
     * With DANE, the trust anchor might be a bare public key, not a
     * certificate!  In that case our chain does not have the trust anchor
     * certificate as a top-most element.  This comports well with RFC5280
     * chain verification, since there too, the trust anchor is not part of the
     * chain to be verified.  In particular, X509_policy_check() does not look
     * at the TA cert, but assumes that it is present as the top-most chain
     * element.  We therefore temporarily push a NULL cert onto the chain if it
     * was verified via a bare public key, and pop it off right after the
     * X509_policy_check() call.
     */
    if (ctx->bare_ta_signed && !sk_X509_push(ctx->chain, NULL))
        goto memerr;
    ret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,
                            ctx->param->policies, ctx->param->flags);
    if (ctx->bare_ta_signed)
        (void)sk_X509_pop(ctx->chain);

    if (ret == X509_PCY_TREE_INTERNAL)
        goto memerr;
    /* Invalid or inconsistent extensions */
    if (ret == X509_PCY_TREE_INVALID) {
        int i, cbcalled = 0;

        /* Locate certificates with bad extensions and notify callback. */
        for (i = 0; i < sk_X509_num(ctx->chain); i++) {
            X509 *x = sk_X509_value(ctx->chain, i);

            if ((x->ex_flags & EXFLAG_INVALID_POLICY) != 0)
                cbcalled = 1;
            CB_FAIL_IF((x->ex_flags & EXFLAG_INVALID_POLICY) != 0,
                       ctx, x, i, X509_V_ERR_INVALID_POLICY_EXTENSION);
        }
        if (!cbcalled) {
            /* Should not be able to get here */
            ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);
            return 0;
        }
        /* The callback ignored the error so we return success */
        return 1;
    }
    if (ret == X509_PCY_TREE_FAILURE) {
        ctx->current_cert = NULL;
        ctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;
        return ctx->verify_cb(0, ctx);
    }
    if (ret != X509_PCY_TREE_VALID) {
        ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);
        return 0;
    }

    if ((ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY) != 0) {
        ctx->current_cert = NULL;
        /*
         * Verification errors need to be ""sticky"", a callback may have allowed
         * an SSL handshake to continue despite an error, and we must then
         * remain in an error state.  Therefore, we MUST NOT clear earlier
         * verification errors by setting the error to X509_V_OK.
         */
        if (!ctx->verify_cb(2, ctx))
            return 0;
    }

    return 1;

 memerr:
    ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
    ctx->error = X509_V_ERR_OUT_OF_MEM;
    return -1;
}","static int check_policy(X509_STORE_CTX *VAR_0)
{
    int VAR_1;

    if (VAR_0->parent)
        return 1;
    /* COMMENT_0 */
                                                                    
                                                                          
                                                                          
                                                                               
                                                                              
                                                                           
                                                                               
                                                                         
                                
       
    if (VAR_0->bare_ta_signed && !sk_X509_push(VAR_0->chain, NULL))
        goto memerr;
    VAR_1 = X509_policy_check(&VAR_0->tree, &VAR_0->explicit_policy, VAR_0->chain,
                            VAR_0->param->policies, VAR_0->param->flags);
    if (VAR_0->bare_ta_signed)
        (void)sk_X509_pop(VAR_0->chain);

    if (VAR_1 == VAR_2)
        goto memerr;
    /* COMMENT_11 */
    if (VAR_1 == VAR_3) {
        int VAR_4, VAR_5 = 0;

        /* COMMENT_12 */
        for (VAR_4 = 0; VAR_4 < sk_X509_num(VAR_0->chain); VAR_4++) {
            X509 *VAR_6 = sk_X509_value(VAR_0->chain, VAR_4);

            if ((VAR_6->ex_flags & VAR_7) != 0)
                VAR_5 = 1;
            CB_FAIL_IF((VAR_6->ex_flags & VAR_7) != 0,
                       VAR_0, VAR_6, VAR_4, VAR_8);
        }
        if (!VAR_5) {
            /* COMMENT_13 */
            ERR_raise(VAR_9, VAR_10);
            return 0;
        }
        /* COMMENT_14 */
        return 1;
    }
    if (VAR_1 == VAR_11) {
        VAR_0->current_cert = NULL;
        VAR_0->error = VAR_12;
        return VAR_0->verify_cb(0, VAR_0);
    }
    if (VAR_1 != VAR_13) {
        ERR_raise(VAR_9, VAR_10);
        return 0;
    }

    if ((VAR_0->param->flags & VAR_14) != 0) {
        VAR_0->current_cert = NULL;
        /* COMMENT_15 */
                                                                               
                                                                          
                                                                          
                                                                 
           
        if (!VAR_0->verify_cb(2, VAR_0))
            return 0;
    }

    return 1;

 memerr:
    ERR_raise(VAR_9, VAR_15);
    VAR_0->error = VAR_16;
    return -1;
}",openssl/1dd43e0709fece299b15208f36cc7c76209ba0bb/x509_vfy.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -26,15 +26,23 @@
         goto memerr;
     /* Invalid or inconsistent extensions */
     if (ret == X509_PCY_TREE_INVALID) {
-        int i;
+        int i, cbcalled = 0;
 
         /* Locate certificates with bad extensions and notify callback. */
-        for (i = 1; i < sk_X509_num(ctx->chain); i++) {
+        for (i = 0; i < sk_X509_num(ctx->chain); i++) {
             X509 *x = sk_X509_value(ctx->chain, i);
 
+            if ((x->ex_flags & EXFLAG_INVALID_POLICY) != 0)
+                cbcalled = 1;
             CB_FAIL_IF((x->ex_flags & EXFLAG_INVALID_POLICY) != 0,
                        ctx, x, i, X509_V_ERR_INVALID_POLICY_EXTENSION);
         }
+        if (!cbcalled) {
+            /* Should not be able to get here */
+            ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);
+            return 0;
+        }
+        /* The callback ignored the error so we return success */
         return 1;
     }
     if (ret == X509_PCY_TREE_FAILURE) {","{'deleted_lines': ['        int i;', '        for (i = 1; i < sk_X509_num(ctx->chain); i++) {'], 'added_lines': ['        int i, cbcalled = 0;', '        for (i = 0; i < sk_X509_num(ctx->chain); i++) {', '            if ((x->ex_flags & EXFLAG_INVALID_POLICY) != 0)', '                cbcalled = 1;', '        if (!cbcalled) {', '            /* Should not be able to get here */', '            ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);', '            return 0;', '        }', '        /* The callback ignored the error so we return success */']}",True,"Applications that use a non-default option when verifying certificates may be
vulnerable to an attack from a malicious CA to circumvent certain checks.

Invalid certificate policies in leaf certificates are silently ignored by
OpenSSL and other certificate policy checks are skipped for that certificate.
A malicious CA could use this to deliberately assert invalid certificate policies
in order to circumvent policy checking on the certificate altogether.

Policy processing is disabled by default but can be enabled by passing
the `-policy' argument to the command line utilities or by calling the
`X509_VERIFY_PARAM_set1_policies()' function.",5.3,MEDIUM,1,test,,5
CVE-2023-0465,['CWE-295'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N,1,openssl,"
Ensure that EXFLAG_INVALID_POLICY is checked even in leaf certs

Even though we check the leaf cert to confirm it is valid, we
later ignored the invalid flag and did not notice that the leaf
cert was bad.

Fixes: CVE-2023-0465
Reviewed-by: Hugo Landau <hlandau@openssl.org>
Reviewed-by: Tomas Mraz <tomas@openssl.org>
(Merged from https://github.com/openssl/openssl/pull/20588)
",b013765abfa80036dc779dd0e50602c57bb3bf95,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=b013765abfa80036dc779dd0e50602c57bb3bf95,crypto/x509/x509_vfy.c,check_policy,"static int check_policy(X509_STORE_CTX *ctx)
{
int ret;
if (ctx->parent)
return 1;
if (ctx->bare_ta_signed && !sk_X509_push(ctx->chain, NULL)) {
X509err(X509_F_CHECK_POLICY, ERR_R_MALLOC_FAILURE);
ctx->error = X509_V_ERR_OUT_OF_MEM;
return 0;
}
ret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,
ctx->param->policies, ctx->param->flags);
if (ctx->bare_ta_signed)
sk_X509_pop(ctx->chain);
if (ret == X509_PCY_TREE_INTERNAL) {
X509err(X509_F_CHECK_POLICY, ERR_R_MALLOC_FAILURE);
ctx->error = X509_V_ERR_OUT_OF_MEM;
return 0;
}
if (ret == X509_PCY_TREE_INVALID) {
int i;
for (i = 1; i < sk_X509_num(ctx->chain); i++) {
X509 *x = sk_X509_value(ctx->chain, i);
if (!(x->ex_flags & EXFLAG_INVALID_POLICY))
continue;
if (!verify_cb_cert(ctx, x, i,
X509_V_ERR_INVALID_POLICY_EXTENSION))
return 0;
}
return 1;
}
if (ret == X509_PCY_TREE_FAILURE) {
ctx->current_cert = NULL;
ctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;
return ctx->verify_cb(0, ctx);
}
if (ret != X509_PCY_TREE_VALID) {
X509err(X509_F_CHECK_POLICY, ERR_R_INTERNAL_ERROR);
return 0;
}
if (ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY) {
ctx->current_cert = NULL;
if (!ctx->verify_cb(2, ctx))
return 0;
}
return 1;
}","static int check_policy(X509_STORE_CTX *VAR_0)
{
int VAR_1;
if (VAR_0->parent)
return 1;
if (VAR_0->bare_ta_signed && !sk_X509_push(VAR_0->chain, NULL)) {
X509err(VAR_2, VAR_3);
VAR_0->error = VAR_4;
return 0;
}
VAR_1 = X509_policy_check(&VAR_0->tree, &VAR_0->explicit_policy, VAR_0->chain,
VAR_0->param->policies, VAR_0->param->flags);
if (VAR_0->bare_ta_signed)
sk_X509_pop(VAR_0->chain);
if (VAR_1 == VAR_5) {
X509err(VAR_2, VAR_3);
VAR_0->error = VAR_4;
return 0;
}
if (VAR_1 == VAR_6) {
int VAR_7;
for (VAR_7 = 1; VAR_7 < sk_X509_num(VAR_0->chain); VAR_7++) {
X509 *VAR_8 = sk_X509_value(VAR_0->chain, VAR_7);
if (!(VAR_8->ex_flags & VAR_9))
continue;
if (!verify_cb_cert(VAR_0, VAR_8, VAR_7,
VAR_10))
return 0;
}
return 1;
}
if (VAR_1 == VAR_11) {
VAR_0->current_cert = NULL;
VAR_0->error = VAR_12;
return VAR_0->verify_cb(0, VAR_0);
}
if (VAR_1 != VAR_13) {
X509err(VAR_2, VAR_14);
return 0;
}
if (VAR_0->param->flags & VAR_15) {
VAR_0->current_cert = NULL;
if (!VAR_0->verify_cb(2, VAR_0))
return 0;
}
return 1;
}",openssl/b013765abfa80036dc779dd0e50602c57bb3bf95/x509_vfy.c/vul/before/0.json,"static int check_policy(X509_STORE_CTX *ctx)
{
    int ret;

    if (ctx->parent)
        return 1;
    /*
     * With DANE, the trust anchor might be a bare public key, not a
     * certificate!  In that case our chain does not have the trust anchor
     * certificate as a top-most element.  This comports well with RFC5280
     * chain verification, since there too, the trust anchor is not part of the
     * chain to be verified.  In particular, X509_policy_check() does not look
     * at the TA cert, but assumes that it is present as the top-most chain
     * element.  We therefore temporarily push a NULL cert onto the chain if it
     * was verified via a bare public key, and pop it off right after the
     * X509_policy_check() call.
     */
    if (ctx->bare_ta_signed && !sk_X509_push(ctx->chain, NULL)) {
        X509err(X509_F_CHECK_POLICY, ERR_R_MALLOC_FAILURE);
        ctx->error = X509_V_ERR_OUT_OF_MEM;
        return 0;
    }
    ret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,
                            ctx->param->policies, ctx->param->flags);
    if (ctx->bare_ta_signed)
        sk_X509_pop(ctx->chain);

    if (ret == X509_PCY_TREE_INTERNAL) {
        X509err(X509_F_CHECK_POLICY, ERR_R_MALLOC_FAILURE);
        ctx->error = X509_V_ERR_OUT_OF_MEM;
        return 0;
    }
    /* Invalid or inconsistent extensions */
    if (ret == X509_PCY_TREE_INVALID) {
        int i, cbcalled = 0;

        /* Locate certificates with bad extensions and notify callback. */
        for (i = 0; i < sk_X509_num(ctx->chain); i++) {
            X509 *x = sk_X509_value(ctx->chain, i);

            if (!(x->ex_flags & EXFLAG_INVALID_POLICY))
                continue;
            cbcalled = 1;
            if (!verify_cb_cert(ctx, x, i,
                                X509_V_ERR_INVALID_POLICY_EXTENSION))
                return 0;
        }
        if (!cbcalled) {
            /* Should not be able to get here */
            X509err(X509_F_CHECK_POLICY, ERR_R_INTERNAL_ERROR);
            return 0;
        }
        /* The callback ignored the error so we return success */
        return 1;
    }
    if (ret == X509_PCY_TREE_FAILURE) {
        ctx->current_cert = NULL;
        ctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;
        return ctx->verify_cb(0, ctx);
    }
    if (ret != X509_PCY_TREE_VALID) {
        X509err(X509_F_CHECK_POLICY, ERR_R_INTERNAL_ERROR);
        return 0;
    }

    if (ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY) {
        ctx->current_cert = NULL;
        /*
         * Verification errors need to be ""sticky"", a callback may have allowed
         * an SSL handshake to continue despite an error, and we must then
         * remain in an error state.  Therefore, we MUST NOT clear earlier
         * verification errors by setting the error to X509_V_OK.
         */
        if (!ctx->verify_cb(2, ctx))
            return 0;
    }

    return 1;
}","static int check_policy(X509_STORE_CTX *VAR_0)
{
    int VAR_1;

    if (VAR_0->parent)
        return 1;
    /* COMMENT_0 */
                                                                    
                                                                          
                                                                          
                                                                               
                                                                              
                                                                           
                                                                               
                                                                         
                                
       
    if (VAR_0->bare_ta_signed && !sk_X509_push(VAR_0->chain, NULL)) {
        X509err(VAR_2, VAR_3);
        VAR_0->error = VAR_4;
        return 0;
    }
    VAR_1 = X509_policy_check(&VAR_0->tree, &VAR_0->explicit_policy, VAR_0->chain,
                            VAR_0->param->policies, VAR_0->param->flags);
    if (VAR_0->bare_ta_signed)
        sk_X509_pop(VAR_0->chain);

    if (VAR_1 == VAR_5) {
        X509err(VAR_2, VAR_3);
        VAR_0->error = VAR_4;
        return 0;
    }
    /* COMMENT_11 */
    if (VAR_1 == VAR_6) {
        int VAR_7, VAR_8 = 0;

        /* COMMENT_12 */
        for (VAR_7 = 0; VAR_7 < sk_X509_num(VAR_0->chain); VAR_7++) {
            X509 *VAR_9 = sk_X509_value(VAR_0->chain, VAR_7);

            if (!(VAR_9->ex_flags & VAR_10))
                continue;
            VAR_8 = 1;
            if (!verify_cb_cert(VAR_0, VAR_9, VAR_7,
                                VAR_11))
                return 0;
        }
        if (!VAR_8) {
            /* COMMENT_13 */
            X509err(VAR_2, VAR_12);
            return 0;
        }
        /* COMMENT_14 */
        return 1;
    }
    if (VAR_1 == VAR_13) {
        VAR_0->current_cert = NULL;
        VAR_0->error = VAR_14;
        return VAR_0->verify_cb(0, VAR_0);
    }
    if (VAR_1 != VAR_15) {
        X509err(VAR_2, VAR_12);
        return 0;
    }

    if (VAR_0->param->flags & VAR_16) {
        VAR_0->current_cert = NULL;
        /* COMMENT_15 */
                                                                               
                                                                          
                                                                          
                                                                 
           
        if (!VAR_0->verify_cb(2, VAR_0))
            return 0;
    }

    return 1;
}",openssl/b013765abfa80036dc779dd0e50602c57bb3bf95/x509_vfy.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -32,18 +32,25 @@
     }
     /* Invalid or inconsistent extensions */
     if (ret == X509_PCY_TREE_INVALID) {
-        int i;
+        int i, cbcalled = 0;
 
         /* Locate certificates with bad extensions and notify callback. */
-        for (i = 1; i < sk_X509_num(ctx->chain); i++) {
+        for (i = 0; i < sk_X509_num(ctx->chain); i++) {
             X509 *x = sk_X509_value(ctx->chain, i);
 
             if (!(x->ex_flags & EXFLAG_INVALID_POLICY))
                 continue;
+            cbcalled = 1;
             if (!verify_cb_cert(ctx, x, i,
                                 X509_V_ERR_INVALID_POLICY_EXTENSION))
                 return 0;
         }
+        if (!cbcalled) {
+            /* Should not be able to get here */
+            X509err(X509_F_CHECK_POLICY, ERR_R_INTERNAL_ERROR);
+            return 0;
+        }
+        /* The callback ignored the error so we return success */
         return 1;
     }
     if (ret == X509_PCY_TREE_FAILURE) {","{'deleted_lines': ['        int i;', '        for (i = 1; i < sk_X509_num(ctx->chain); i++) {'], 'added_lines': ['        int i, cbcalled = 0;', '        for (i = 0; i < sk_X509_num(ctx->chain); i++) {', '            cbcalled = 1;', '        if (!cbcalled) {', '            /* Should not be able to get here */', '            X509err(X509_F_CHECK_POLICY, ERR_R_INTERNAL_ERROR);', '            return 0;', '        }', '        /* The callback ignored the error so we return success */']}",True,"Applications that use a non-default option when verifying certificates may be
vulnerable to an attack from a malicious CA to circumvent certain checks.

Invalid certificate policies in leaf certificates are silently ignored by
OpenSSL and other certificate policy checks are skipped for that certificate.
A malicious CA could use this to deliberately assert invalid certificate policies
in order to circumvent policy checking on the certificate altogether.

Policy processing is disabled by default but can be enabled by passing
the `-policy' argument to the command line utilities or by calling the
`X509_VERIFY_PARAM_set1_policies()' function.",5.3,MEDIUM,1,test,,5
CVE-2023-1992,['CWE-400'],CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H,1,wireshark,"RPCoRDMA: Frame end cleanup for global write offsets

Add a frame end routine for a global which is assigned to packet
scoped memory. It really should be made proto data, but is used
in a function in the header (that doesn't take the packet info
struct as an argument) and this fix needs to be made in stable
branches.

Fix #18852
",3c8be14c827f1587da3c2b3bb0d9c04faff57413,https://gitlab.com/wireshark/wireshark/-/commit/3c8be14c827f1587da3c2b3bb0d9c04faff57413,epan/dissectors/packet-rpcrdma.c,dissect_rpcrdma,"static int
dissect_rpcrdma(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
tvbuff_t *volatile next_tvb;
tvbuff_t *frag_tvb;
proto_item *ti;
proto_tree *rpcordma_tree;
guint offset;
guint32 msg_type;
guint32 xid;
guint32 val;
guint32 *p_msgid;
guint write_size;
int save_visited;
rdma_lists_t rdma_lists = { NULL, NULL, NULL };
if (tvb_captured_length(tvb) < MIN_RPCRDMA_HDR_SZ)
return 0;
if (tvb_get_ntohl(tvb, 4) != 1)  
return 0;
xid = tvb_get_ntohl(tvb, 0);
msg_type = tvb_get_ntohl(tvb, 12);
col_set_str(pinfo->cinfo, COL_PROTOCOL, ""RPCoRDMA"");
col_add_fstr(pinfo->cinfo, COL_INFO, ""%s XID 0x%x"",
val_to_str(msg_type, rpcordma_message_type, ""Unknown (%d)""), xid);
ti = proto_tree_add_item(tree, proto_rpcordma, tvb, 0, MIN_RPCRDMA_HDR_SZ, ENC_NA);
rpcordma_tree = proto_item_add_subtree(ti, ett_rpcordma);
offset = 0;
proto_tree_add_item(rpcordma_tree, hf_rpcordma_xid, tvb,
offset, 4, ENC_BIG_ENDIAN);
offset += 4;
proto_tree_add_item(rpcordma_tree, hf_rpcordma_vers, tvb,
offset, 4, ENC_BIG_ENDIAN);
offset += 4;
proto_tree_add_item(rpcordma_tree, hf_rpcordma_flow_control, tvb,
offset, 4, ENC_BIG_ENDIAN);
offset += 4;
proto_tree_add_item(rpcordma_tree, hf_rpcordma_message_type, tvb,
offset, 4, ENC_BIG_ENDIAN);
offset += 4;
switch (msg_type) {
case RDMA_MSG:
offset = parse_rdma_header(tvb, offset, rpcordma_tree, &rdma_lists);
proto_item_set_len(ti, offset);
frag_tvb = get_reassembled_data(tvb, offset, pinfo, tree);
if (frag_tvb) {
return call_dissector(rpc_handler, frag_tvb, pinfo, tree);
} else if (pinfo->fd->visited && !g_needs_reassembly && rdma_lists.p_read_list) {
return 0;
} else {
next_tvb = tvb_new_subset_remaining(tvb, offset);
write_size = get_rdma_list_size(rdma_lists.p_write_list, pinfo);
if (write_size > 0 && !pinfo->fd->visited) {
gp_rdma_write_offsets = wmem_array_new(wmem_packet_scope(), sizeof(gint));
TRY {
g_rpcrdma_reduced = TRUE;
call_dissector(rpc_handler, next_tvb, pinfo, tree);
}
FINALLY {
g_rpcrdma_reduced = FALSE;
}
ENDTRY;
} else if (write_size > 0 && pinfo->fd->visited) {
p_msgid = (guint32 *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rpcordma, RPCRDMA_MSG_ID);
if (p_msgid) {
save_visited = pinfo->fd->visited;
pinfo->fd->visited = 0;
end_reassembly(*p_msgid, NULL, pinfo);
pinfo->fd->visited = save_visited;
}
}
frag_tvb = process_rdma_lists(next_tvb, 0, &rdma_lists, pinfo, tree);
gp_rdma_write_offsets = NULL;
if (rdma_lists.p_read_list) {
call_data_dissector(next_tvb, pinfo, tree);
break;
} else if (frag_tvb) {
next_tvb = frag_tvb;
}
}","static int
dissect_rpcrdma(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, void* VAR_3 _U_)
{
tvbuff_t *volatile VAR_4;
tvbuff_t *VAR_5;
proto_item *VAR_6;
proto_tree *VAR_7;
guint VAR_8;
guint32 VAR_9;
guint32 VAR_10;
guint32 VAR_11;
guint32 *VAR_12;
guint VAR_13;
int VAR_14;
rdma_lists_t VAR_15 = { NULL, NULL, NULL };
if (tvb_captured_length(VAR_0) < VAR_16)
return 0;
if (tvb_get_ntohl(VAR_0, 4) != 1)  
return 0;
VAR_10 = tvb_get_ntohl(VAR_0, 0);
VAR_9 = tvb_get_ntohl(VAR_0, 12);
col_set_str(VAR_1->cinfo, VAR_17, ""RPCoRDMA"");
col_add_fstr(VAR_1->cinfo, VAR_18, ""%s XID 0x%x"",
val_to_str(VAR_9, VAR_19, ""Unknown (%d)""), VAR_10);
VAR_6 = proto_tree_add_item(VAR_2, VAR_20, VAR_0, 0, VAR_16, VAR_21);
VAR_7 = proto_item_add_subtree(VAR_6, VAR_22);
VAR_8 = 0;
proto_tree_add_item(VAR_7, VAR_23, VAR_0,
VAR_8, 4, VAR_24);
VAR_8 += 4;
proto_tree_add_item(VAR_7, VAR_25, VAR_0,
VAR_8, 4, VAR_24);
VAR_8 += 4;
proto_tree_add_item(VAR_7, VAR_26, VAR_0,
VAR_8, 4, VAR_24);
VAR_8 += 4;
proto_tree_add_item(VAR_7, VAR_27, VAR_0,
VAR_8, 4, VAR_24);
VAR_8 += 4;
switch (VAR_9) {
case VAR_28:
VAR_8 = parse_rdma_header(VAR_0, VAR_8, VAR_7, &VAR_15);
proto_item_set_len(VAR_6, VAR_8);
VAR_5 = get_reassembled_data(VAR_0, VAR_8, VAR_1, VAR_2);
if (VAR_5) {
return call_dissector(VAR_29, VAR_5, VAR_1, VAR_2);
} else if (VAR_1->fd->visited && !VAR_30 && VAR_15.p_read_list) {
return 0;
} else {
VAR_4 = tvb_new_subset_remaining(VAR_0, VAR_8);
VAR_13 = get_rdma_list_size(VAR_15.p_write_list, VAR_1);
if (VAR_13 > 0 && !VAR_1->fd->visited) {
VAR_31 = wmem_array_new(wmem_packet_scope(), sizeof(VAR_32));
TRY {
VAR_33 = TRUE;
call_dissector(VAR_29, VAR_4, VAR_1, VAR_2);
}
FINALLY {
VAR_33 = FALSE;
}
VAR_34;
} else if (VAR_13 > 0 && VAR_1->fd->visited) {
VAR_12 = (guint32 *)p_get_proto_data(wmem_file_scope(), VAR_1, VAR_20, VAR_35);
if (VAR_12) {
VAR_14 = VAR_1->fd->visited;
VAR_1->fd->visited = 0;
end_reassembly(*VAR_12, NULL, VAR_1);
VAR_1->fd->visited = VAR_14;
}
}
VAR_5 = process_rdma_lists(VAR_4, 0, &VAR_15, VAR_1, VAR_2);
VAR_31 = NULL;
if (VAR_15.p_read_list) {
call_data_dissector(VAR_4, VAR_1, VAR_2);
break;
} else if (VAR_5) {
VAR_4 = VAR_5;
}
}",,"static int
dissect_rpcrdma(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)
{
    tvbuff_t *volatile next_tvb;
    tvbuff_t *frag_tvb;
    proto_item *ti;
    proto_tree *rpcordma_tree;
    guint offset;
    guint32 msg_type;
    guint32 xid;
    guint32 val;
    guint32 *p_msgid;
    guint write_size;
    int save_visited;
    rdma_lists_t rdma_lists = { NULL, NULL, NULL };

    /* tvb_get_ntohl() should not throw an exception while checking if
       this is an rpcrdma packet */
    if (tvb_captured_length(tvb) < MIN_RPCRDMA_HDR_SZ)
        return 0;

    if (tvb_get_ntohl(tvb, 4) != 1)  /* vers */
        return 0;

    xid = tvb_get_ntohl(tvb, 0);
    msg_type = tvb_get_ntohl(tvb, 12);

    col_set_str(pinfo->cinfo, COL_PROTOCOL, ""RPCoRDMA"");
    col_add_fstr(pinfo->cinfo, COL_INFO, ""%s XID 0x%x"",
        val_to_str(msg_type, rpcordma_message_type, ""Unknown (%d)""), xid);

    ti = proto_tree_add_item(tree, proto_rpcordma, tvb, 0, MIN_RPCRDMA_HDR_SZ, ENC_NA);

    rpcordma_tree = proto_item_add_subtree(ti, ett_rpcordma);

    offset = 0;
    proto_tree_add_item(rpcordma_tree, hf_rpcordma_xid, tvb,
                offset, 4, ENC_BIG_ENDIAN);
    offset += 4;
    proto_tree_add_item(rpcordma_tree, hf_rpcordma_vers, tvb,
                offset, 4, ENC_BIG_ENDIAN);
    offset += 4;
    proto_tree_add_item(rpcordma_tree, hf_rpcordma_flow_control, tvb,
                offset, 4, ENC_BIG_ENDIAN);
    offset += 4;
    proto_tree_add_item(rpcordma_tree, hf_rpcordma_message_type, tvb,
                offset, 4, ENC_BIG_ENDIAN);
    offset += 4;

    switch (msg_type) {
    case RDMA_MSG:
        /* Parse rpc_rdma_header */
        offset = parse_rdma_header(tvb, offset, rpcordma_tree, &rdma_lists);

        proto_item_set_len(ti, offset);

        frag_tvb = get_reassembled_data(tvb, offset, pinfo, tree);
        if (frag_tvb) {
            /* Reassembled message has already been cached -- call upper dissector */
            return call_dissector(rpc_handler, frag_tvb, pinfo, tree);
        } else if (pinfo->fd->visited && !g_needs_reassembly && rdma_lists.p_read_list) {
            /* This frame has already been added as a read fragment */
            return 0;
        } else {
            next_tvb = tvb_new_subset_remaining(tvb, offset);

            /*
             * Get the total number of bytes for the write chunk list.
             * It returns 0 if there is no write chunk list, or this is an
             * RPC call (list has just been set up) or it is an RPC reply but
             * there is an error so the reply message has not been reduced.
             */
            write_size = get_rdma_list_size(rdma_lists.p_write_list, pinfo);

            if (write_size > 0 && !pinfo->fd->visited) {
                /* Initialize array of write chunk offsets */
                gp_rdma_write_offsets = wmem_array_new(wmem_packet_scope(), sizeof(gint));
                register_frame_end_routine(pinfo, reset_write_offsets);
                TRY {
                    /*
                     * Call the upper layer dissector to get a list of offsets
                     * where message has been reduced.
                     * This is done on the first pass (visited = 0)
                     */
                    g_rpcrdma_reduced = TRUE;
                    call_dissector(rpc_handler, next_tvb, pinfo, tree);
                }
                FINALLY {
                    /* Make sure to disable reduced data processing */
                    g_rpcrdma_reduced = FALSE;
                }
                ENDTRY;
            } else if (write_size > 0 && pinfo->fd->visited) {
                /*
                 * Reassembly is done on the second pass (visited = 1)
                 * This is done because dissecting the upper layer(s) again
                 * causes the upper layer(s) to be displayed twice if it is
                 * done on the same pass.
                 */
                p_msgid = (guint32 *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rpcordma, RPCRDMA_MSG_ID);
                if (p_msgid) {
                    /*
                     * All fragments were added during the first pass,
                     * reassembly just needs to be completed here
                     */
                    save_visited = pinfo->fd->visited;
                    pinfo->fd->visited = 0;
                    end_reassembly(*p_msgid, NULL, pinfo);
                    pinfo->fd->visited = save_visited;
                }
            }

            /*
             * If there is a write chunk list, process_rdma_lists will convert
             * the offsets returned by the upper layer into xdr positions
             * and break the current reduced message into separate fragments
             * and insert them into the reassembly table in the first pass.
             * On the second pass, the reassembly has just been done so
             * process_rdma_lists should only call process_reassembled_data
             * to get the reassembled data and call the dissector for the
             * upper layer with the reassembled message.
             */
            frag_tvb = process_rdma_lists(next_tvb, 0, &rdma_lists, pinfo, tree);
            gp_rdma_write_offsets = NULL;
            if (rdma_lists.p_read_list) {
                /*
                 * If there is a read chunk list, do not dissect upper layer
                 * just label rest of packet as ""Data"" since the reassembly
                 * will be done on the last read response.
                 */
                call_data_dissector(next_tvb, pinfo, tree);
                break;
            } else if (frag_tvb) {
                /* Replace current frame data with the reassembled data */
                next_tvb = frag_tvb;
            }
        }","static int
dissect_rpcrdma(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, void* VAR_3 _U_)
{
    tvbuff_t *volatile VAR_4;
    tvbuff_t *VAR_5;
    proto_item *VAR_6;
    proto_tree *VAR_7;
    guint VAR_8;
    guint32 VAR_9;
    guint32 VAR_10;
    guint32 VAR_11;
    guint32 *VAR_12;
    guint VAR_13;
    int VAR_14;
    rdma_lists_t VAR_15 = { NULL, NULL, NULL };

    /* COMMENT_0 */
                                   
    if (tvb_captured_length(VAR_0) < VAR_16)
        return 0;

    if (tvb_get_ntohl(VAR_0, 4) != 1)  /* COMMENT_2 */
        return 0;

    VAR_10 = tvb_get_ntohl(VAR_0, 0);
    VAR_9 = tvb_get_ntohl(VAR_0, 12);

    col_set_str(VAR_1->cinfo, VAR_17, ""RPCoRDMA"");
    col_add_fstr(VAR_1->cinfo, VAR_18, ""%s XID 0x%x"",
        val_to_str(VAR_9, VAR_19, ""Unknown (%d)""), VAR_10);

    VAR_6 = proto_tree_add_item(VAR_2, VAR_20, VAR_0, 0, VAR_16, VAR_21);

    VAR_7 = proto_item_add_subtree(VAR_6, VAR_22);

    VAR_8 = 0;
    proto_tree_add_item(VAR_7, VAR_23, VAR_0,
                VAR_8, 4, VAR_24);
    VAR_8 += 4;
    proto_tree_add_item(VAR_7, VAR_25, VAR_0,
                VAR_8, 4, VAR_24);
    VAR_8 += 4;
    proto_tree_add_item(VAR_7, VAR_26, VAR_0,
                VAR_8, 4, VAR_24);
    VAR_8 += 4;
    proto_tree_add_item(VAR_7, VAR_27, VAR_0,
                VAR_8, 4, VAR_24);
    VAR_8 += 4;

    switch (VAR_9) {
    case VAR_28:
        /* COMMENT_3 */
        VAR_8 = parse_rdma_header(VAR_0, VAR_8, VAR_7, &VAR_15);

        proto_item_set_len(VAR_6, VAR_8);

        VAR_5 = get_reassembled_data(VAR_0, VAR_8, VAR_1, VAR_2);
        if (VAR_5) {
            /* COMMENT_4 */
            return call_dissector(VAR_29, VAR_5, VAR_1, VAR_2);
        } else if (VAR_1->fd->visited && !VAR_30 && VAR_15.p_read_list) {
            /* COMMENT_5 */
            return 0;
        } else {
            VAR_4 = tvb_new_subset_remaining(VAR_0, VAR_8);

            /* COMMENT_6 */
                                                                      
                                                                          
                                                                             
                                                                           
               
            VAR_13 = get_rdma_list_size(VAR_15.p_write_list, VAR_1);

            if (VAR_13 > 0 && !VAR_1->fd->visited) {
                /* COMMENT_12 */
                VAR_31 = wmem_array_new(wmem_packet_scope(), sizeof(VAR_32));
                register_frame_end_routine(VAR_1, VAR_33);
                TRY {
                    /* COMMENT_13 */
                                                                              
                                                      
                                                                   
                       
                    VAR_34 = TRUE;
                    call_dissector(VAR_29, VAR_4, VAR_1, VAR_2);
                }
                FINALLY {
                    /* COMMENT_18 */
                    VAR_34 = FALSE;
                }
                VAR_35;
            } else if (VAR_13 > 0 && VAR_1->fd->visited) {
                /* COMMENT_19 */
                                                                      
                                                                           
                                                                           
                                         
                   
                VAR_12 = (guint32 *)p_get_proto_data(wmem_file_scope(), VAR_1, VAR_20, VAR_36);
                if (VAR_12) {
                    /* COMMENT_25 */
                                                                      
                                                                 
                       
                    VAR_14 = VAR_1->fd->visited;
                    VAR_1->fd->visited = 0;
                    end_reassembly(*VAR_12, NULL, VAR_1);
                    VAR_1->fd->visited = VAR_14;
                }
            }

            /* COMMENT_29 */
                                                                              
                                                                         
                                                                            
                                                                           
                                                                       
                                                                           
                                                                         
                                                        
               
            VAR_5 = process_rdma_lists(VAR_4, 0, &VAR_15, VAR_1, VAR_2);
            VAR_31 = NULL;
            if (VAR_15.p_read_list) {
                /* COMMENT_39 */
                                                                            
                                                                           
                                                          
                   
                call_data_dissector(VAR_4, VAR_1, VAR_2);
                break;
            } else if (VAR_5) {
                /* COMMENT_44 */
                VAR_4 = VAR_5;
            }
        }",,"--- func_before
+++ func_after
@@ -75,6 +75,7 @@
             if (write_size > 0 && !pinfo->fd->visited) {
                 /* Initialize array of write chunk offsets */
                 gp_rdma_write_offsets = wmem_array_new(wmem_packet_scope(), sizeof(gint));
+                register_frame_end_routine(pinfo, reset_write_offsets);
                 TRY {
                     /*
                      * Call the upper layer dissector to get a list of offsets","{'deleted_lines': [], 'added_lines': ['                register_frame_end_routine(pinfo, reset_write_offsets);']}",True,RPCoRDMA dissector crash in Wireshark 4.0.0 to 4.0.4 and 3.6.0 to 3.6.12 allows denial of service via packet injection or crafted capture file,7.5,HIGH,2,test,,5
CVE-2023-3141,['CWE-416'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H,1,torvalds/linux,"In r592_probe, dev->detect_timer was bound with r592_detect_timer.
In r592_irq function, the timer function will be invoked by mod_timer.

If we remove the module which will call hantro_release to make cleanup,
there may be a unfinished work. The possible sequence is as follows,
which will cause a typical UAF bug.

Fix it by canceling the work before cleanup in r592_remove.

CPU0                  CPU1

                    |r592_detect_timer
r592_remove         |
  memstick_free_host|
  put_device;       |
  kfree(host);      |
                    |
                    | queue_work
                    |   &host->media_checker //use

Signed-off-by: Zheng Wang <zyytlz.wz@163.com>
Link: https://lore.kernel.org/r/20230307164338.1246287-1-zyytlz.wz@163.com
Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
",63264422785021704c39b38f65a78ab9e4a186d7,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=63264422785021704c39b38f65a78ab9e4a186d7,drivers/memstick/host/r592.c,r592_remove,"static void r592_remove(struct pci_dev *pdev)
{
int error = 0;
struct r592_device *dev = pci_get_drvdata(pdev);
kthread_stop(dev->io_thread);
r592_enable_device(dev, false);
while (!error && dev->req) {
dev->req->error = -ETIME;
error = memstick_next_req(dev->host, &dev->req);
}
memstick_remove_host(dev->host);
if (dev->dummy_dma_page)
dma_free_coherent(&pdev->dev, PAGE_SIZE, dev->dummy_dma_page,
dev->dummy_dma_page_physical_address);
free_irq(dev->irq, dev);
iounmap(dev->mmio);
pci_release_regions(pdev);
pci_disable_device(pdev);
memstick_free_host(dev->host);
}","static void r592_remove(struct pci_dev *VAR_0)
{
int VAR_1 = 0;
struct r592_device *VAR_2 = pci_get_drvdata(VAR_0);
kthread_stop(VAR_2->io_thread);
r592_enable_device(VAR_2, false);
while (!VAR_1 && VAR_2->req) {
VAR_2->req->error = -VAR_3;
VAR_1 = memstick_next_req(VAR_2->host, &VAR_2->req);
}
memstick_remove_host(VAR_2->host);
if (VAR_2->dummy_dma_page)
dma_free_coherent(&VAR_0->dev, VAR_4, VAR_2->dummy_dma_page,
VAR_2->dummy_dma_page_physical_address);
free_irq(VAR_2->irq, VAR_2);
iounmap(VAR_2->mmio);
pci_release_regions(VAR_0);
pci_disable_device(VAR_0);
memstick_free_host(VAR_2->host);
}",torvalds/linux/63264422785021704c39b38f65a78ab9e4a186d7/r592.c/vul/before/0.json,"static void r592_remove(struct pci_dev *pdev)
{
	int error = 0;
	struct r592_device *dev = pci_get_drvdata(pdev);

	/* Stop the processing thread.
	That ensures that we won't take any more requests */
	kthread_stop(dev->io_thread);
	del_timer_sync(&dev->detect_timer);
	r592_enable_device(dev, false);

	while (!error && dev->req) {
		dev->req->error = -ETIME;
		error = memstick_next_req(dev->host, &dev->req);
	}
	memstick_remove_host(dev->host);

	if (dev->dummy_dma_page)
		dma_free_coherent(&pdev->dev, PAGE_SIZE, dev->dummy_dma_page,
			dev->dummy_dma_page_physical_address);

	free_irq(dev->irq, dev);
	iounmap(dev->mmio);
	pci_release_regions(pdev);
	pci_disable_device(pdev);
	memstick_free_host(dev->host);
}","static void r592_remove(struct pci_dev *VAR_0)
{
	int VAR_1 = 0;
	struct r592_device *VAR_2 = pci_get_drvdata(VAR_0);

	/* COMMENT_0 */
                                                     
	kthread_stop(VAR_2->io_thread);
	del_timer_sync(&VAR_2->detect_timer);
	r592_enable_device(VAR_2, false);

	while (!VAR_1 && VAR_2->req) {
		VAR_2->req->error = -VAR_3;
		VAR_1 = memstick_next_req(VAR_2->host, &VAR_2->req);
	}
	memstick_remove_host(VAR_2->host);

	if (VAR_2->dummy_dma_page)
		dma_free_coherent(&VAR_0->dev, VAR_4, VAR_2->dummy_dma_page,
			VAR_2->dummy_dma_page_physical_address);

	free_irq(VAR_2->irq, VAR_2);
	iounmap(VAR_2->mmio);
	pci_release_regions(VAR_0);
	pci_disable_device(VAR_0);
	memstick_free_host(VAR_2->host);
}",torvalds/linux/63264422785021704c39b38f65a78ab9e4a186d7/r592.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
 	/* Stop the processing thread.
 	That ensures that we won't take any more requests */
 	kthread_stop(dev->io_thread);
-
+	del_timer_sync(&dev->detect_timer);
 	r592_enable_device(dev, false);
 
 	while (!error && dev->req) {","{'deleted_lines': [''], 'added_lines': ['\tdel_timer_sync(&dev->detect_timer);']}",True,"A use-after-free flaw was found in r592_remove in drivers/memstick/host/r592.c in media access in the Linux Kernel. This flaw allows a local attacker to crash the system at device disconnect, possibly leading to a kernel information leak.",7.1,HIGH,2,test,,5
CVE-2010-2243,['CWE-20'],AV:N/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"Aaro Koskinen reported an issue in kernel.org bugzilla #15366, where
on non-GENERIC_TIME systems, accessing
/sys/devices/system/clocksource/clocksource0/current_clocksource
results in an oops.

It seems the timekeeper/clocksource rework missed initializing the
curr_clocksource value in the !GENERIC_TIME case.

Thanks to Aaro for reporting and diagnosing the issue as well as
testing the fix!

Reported-by: Aaro Koskinen <aaro.koskinen@iki.fi>
Signed-off-by: John Stultz <johnstul@us.ibm.com>
Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
Cc: stable@kernel.org
LKML-Reference: <1267475683.4216.61.camel@localhost.localdomain>
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

",ad6759fbf35d104dbf573cd6f4c6784ad6823f7e,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=ad6759fbf35d104dbf573cd6f4c6784ad6823f7e,kernel/time/clocksource.c,clocksource_done_booting,"static int __init clocksource_done_booting(void)
{
finished_booting = 1;
clocksource_watchdog_kthread(NULL);
mutex_lock(&clocksource_mutex);
clocksource_select();
mutex_unlock(&clocksource_mutex);
return 0;
}","static int __init clocksource_done_booting(void)
{
VAR_0 = 1;
clocksource_watchdog_kthread(NULL);
mutex_lock(&VAR_1);
clocksource_select();
mutex_unlock(&VAR_1);
return 0;
}",,"static int __init clocksource_done_booting(void)
{
	mutex_lock(&clocksource_mutex);
	curr_clocksource = clocksource_default_clock();
	mutex_unlock(&clocksource_mutex);

	finished_booting = 1;

	/*
	 * Run the watchdog first to eliminate unstable clock sources
	 */
	clocksource_watchdog_kthread(NULL);

	mutex_lock(&clocksource_mutex);
	clocksource_select();
	mutex_unlock(&clocksource_mutex);
	return 0;
}","static int __init clocksource_done_booting(void)
{
	mutex_lock(&VAR_0);
	VAR_1 = clocksource_default_clock();
	mutex_unlock(&VAR_0);

	VAR_2 = 1;

	/* COMMENT_0 */
                                                              
    
	clocksource_watchdog_kthread(NULL);

	mutex_lock(&VAR_0);
	clocksource_select();
	mutex_unlock(&VAR_0);
	return 0;
}",,"--- func_before
+++ func_after
@@ -1,5 +1,9 @@
 static int __init clocksource_done_booting(void)
 {
+	mutex_lock(&clocksource_mutex);
+	curr_clocksource = clocksource_default_clock();
+	mutex_unlock(&clocksource_mutex);
+
 	finished_booting = 1;
 
 	/*","{'deleted_lines': [], 'added_lines': ['\tmutex_lock(&clocksource_mutex);', '\tcurr_clocksource = clocksource_default_clock();', '\tmutex_unlock(&clocksource_mutex);', '']}",True,"A vulnerability exists in kernel/time/clocksource.c in the Linux kernel before 2.6.34 where on non-GENERIC_TIME systems (GENERIC_TIME=n), accessing /sys/devices/system/clocksource/clocksource0/current_clocksource results in an OOPS.",7.5,HIGH,2,test,,5
CVE-2019-19543,['CWE-416'],AV:L/AC:L/Au:N/C:P/I:P/A:P,0,torvalds/linux,"Syzkaller report this:

BUG: KASAN: use-after-free in sysfs_remove_file_ns+0x5f/0x70 fs/sysfs/file.c:468
Read of size 8 at addr ffff8881dc7ae030 by task syz-executor.0/6249

CPU: 1 PID: 6249 Comm: syz-executor.0 Not tainted 5.0.0-rc8+ #3
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
Call Trace:
 __dump_stack lib/dump_stack.c:77 [inline]
 dump_stack+0xfa/0x1ce lib/dump_stack.c:113
 print_address_description+0x65/0x270 mm/kasan/report.c:187
 kasan_report+0x149/0x18d mm/kasan/report.c:317
 ? 0xffffffffc1728000
 sysfs_remove_file_ns+0x5f/0x70 fs/sysfs/file.c:468
 sysfs_remove_file include/linux/sysfs.h:519 [inline]
 driver_remove_file+0x40/0x50 drivers/base/driver.c:122
 remove_bind_files drivers/base/bus.c:585 [inline]
 bus_remove_driver+0x186/0x220 drivers/base/bus.c:725
 driver_unregister+0x6c/0xa0 drivers/base/driver.c:197
 serial_ir_init_module+0x169/0x1000 [serial_ir]
 do_one_initcall+0xfa/0x5ca init/main.c:887
 do_init_module+0x204/0x5f6 kernel/module.c:3460
 load_module+0x66b2/0x8570 kernel/module.c:3808
 __do_sys_finit_module+0x238/0x2a0 kernel/module.c:3902
 do_syscall_64+0x147/0x600 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x49/0xbe
RIP: 0033:0x462e99
Code: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007f9450132c58 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
RAX: ffffffffffffffda RBX: 000000000073bf00 RCX: 0000000000462e99
RDX: 0000000000000000 RSI: 0000000020000100 RDI: 0000000000000003
RBP: 00007f9450132c70 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 00007f94501336bc
R13: 00000000004bcefa R14: 00000000006f6fb0 R15: 0000000000000004

Allocated by task 6249:
 set_track mm/kasan/common.c:85 [inline]
 __kasan_kmalloc.constprop.3+0xa0/0xd0 mm/kasan/common.c:495
 kmalloc include/linux/slab.h:545 [inline]
 kzalloc include/linux/slab.h:740 [inline]
 bus_add_driver+0xc0/0x610 drivers/base/bus.c:651
 driver_register+0x1bb/0x3f0 drivers/base/driver.c:170
 serial_ir_init_module+0xe8/0x1000 [serial_ir]
 do_one_initcall+0xfa/0x5ca init/main.c:887
 do_init_module+0x204/0x5f6 kernel/module.c:3460
 load_module+0x66b2/0x8570 kernel/module.c:3808
 __do_sys_finit_module+0x238/0x2a0 kernel/module.c:3902
 do_syscall_64+0x147/0x600 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x49/0xbe

Freed by task 6249:
 set_track mm/kasan/common.c:85 [inline]
 __kasan_slab_free+0x130/0x180 mm/kasan/common.c:457
 slab_free_hook mm/slub.c:1430 [inline]
 slab_free_freelist_hook mm/slub.c:1457 [inline]
 slab_free mm/slub.c:3005 [inline]
 kfree+0xe1/0x270 mm/slub.c:3957
 kobject_cleanup lib/kobject.c:662 [inline]
 kobject_release lib/kobject.c:691 [inline]
 kref_put include/linux/kref.h:67 [inline]
 kobject_put+0x146/0x240 lib/kobject.c:708
 bus_remove_driver+0x10e/0x220 drivers/base/bus.c:732
 driver_unregister+0x6c/0xa0 drivers/base/driver.c:197
 serial_ir_init_module+0x14c/0x1000 [serial_ir]
 do_one_initcall+0xfa/0x5ca init/main.c:887
 do_init_module+0x204/0x5f6 kernel/module.c:3460
 load_module+0x66b2/0x8570 kernel/module.c:3808
 __do_sys_finit_module+0x238/0x2a0 kernel/module.c:3902
 do_syscall_64+0x147/0x600 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x49/0xbe

The buggy address belongs to the object at ffff8881dc7ae000
 which belongs to the cache kmalloc-256 of size 256
The buggy address is located 48 bytes inside of
 256-byte region [ffff8881dc7ae000, ffff8881dc7ae100)
The buggy address belongs to the page:
page:ffffea000771eb80 count:1 mapcount:0 mapping:ffff8881f6c02e00 index:0x0
flags: 0x2fffc0000000200(slab)
raw: 02fffc0000000200 ffffea0007d14800 0000000400000002 ffff8881f6c02e00
raw: 0000000000000000 00000000800c000c 00000001ffffffff 0000000000000000
page dumped because: kasan: bad access detected

Memory state around the buggy address:
 ffff8881dc7adf00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
 ffff8881dc7adf80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>ffff8881dc7ae000: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                     ^
 ffff8881dc7ae080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff8881dc7ae100: fc fc fc fc fc fc fc fc 00 00 00 00 00 00 00 00

There are already cleanup handlings in serial_ir_init error path,
no need to call serial_ir_exit do it again in serial_ir_init_module,
otherwise will trigger a use-after-free issue.

Fixes: fa5dc29c1fcc (""[media] lirc_serial: move out of staging and rename to serial_ir"")

Reported-by: Hulk Robot <hulkci@huawei.com>
Signed-off-by: YueHaibing <yuehaibing@huawei.com>
Signed-off-by: Sean Young <sean@mess.org>
Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
",56cd26b618855c9af48c8301aa6754ced8dd0beb,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=56cd26b618855c9af48c8301aa6754ced8dd0beb,drivers/media/rc/serial_ir.c,serial_ir_init_module,"static int __init serial_ir_init_module(void)
{
int result;
switch (type) {
case IR_HOMEBREW:
case IR_IRDEO:
case IR_IRDEO_REMOTE:
case IR_ANIMAX:
case IR_IGOR:
io = io ? io : 0x3f8;
irq = irq ? irq : 4;
break;
default:
return -EINVAL;
}
if (!softcarrier) {
switch (type) {
case IR_HOMEBREW:
case IR_IGOR:
hardware[type].set_send_carrier = false;
hardware[type].set_duty_cycle = false;
break;
}
}
if (sense != -1)
sense = !!sense;
result = serial_ir_init();
if (!result)
return 0;
serial_ir_exit();
return result;
}","static int __init serial_ir_init_module(void)
{
int VAR_0;
switch (VAR_1) {
case VAR_2:
case VAR_3:
case VAR_4:
case VAR_5:
case VAR_6:
VAR_7 = VAR_7 ? VAR_7 : 0x3f8;
VAR_8 = VAR_8 ? VAR_8 : 4;
break;
default:
return -VAR_9;
}
if (!VAR_10) {
switch (VAR_1) {
case VAR_2:
case VAR_6:
VAR_11[VAR_1].set_send_carrier = false;
VAR_11[VAR_1].set_duty_cycle = false;
break;
}
}
if (VAR_12 != -1)
VAR_12 = !!VAR_12;
VAR_0 = serial_ir_init();
if (!VAR_0)
return 0;
serial_ir_exit();
return VAR_0;
}",,"static int __init serial_ir_init_module(void)
{
	switch (type) {
	case IR_HOMEBREW:
	case IR_IRDEO:
	case IR_IRDEO_REMOTE:
	case IR_ANIMAX:
	case IR_IGOR:
		/* if nothing specified, use ttyS0/com1 and irq 4 */
		io = io ? io : 0x3f8;
		irq = irq ? irq : 4;
		break;
	default:
		return -EINVAL;
	}
	if (!softcarrier) {
		switch (type) {
		case IR_HOMEBREW:
		case IR_IGOR:
			hardware[type].set_send_carrier = false;
			hardware[type].set_duty_cycle = false;
			break;
		}
	}

	/* make sure sense is either -1, 0, or 1 */
	if (sense != -1)
		sense = !!sense;

	return serial_ir_init();
}","static int __init serial_ir_init_module(void)
{
	switch (VAR_0) {
	case VAR_1:
	case VAR_2:
	case VAR_3:
	case VAR_4:
	case VAR_5:
		/* COMMENT_0 */
		VAR_6 = VAR_6 ? VAR_6 : 0x3f8;
		VAR_7 = VAR_7 ? VAR_7 : 4;
		break;
	default:
		return -VAR_8;
	}
	if (!VAR_9) {
		switch (VAR_0) {
		case VAR_1:
		case VAR_5:
			VAR_10[VAR_0].set_send_carrier = false;
			VAR_10[VAR_0].set_duty_cycle = false;
			break;
		}
	}

	/* COMMENT_1 */
	if (VAR_11 != -1)
		VAR_11 = !!VAR_11;

	return serial_ir_init();
}",,"--- func_before
+++ func_after
@@ -1,7 +1,5 @@
 static int __init serial_ir_init_module(void)
 {
-	int result;
-
 	switch (type) {
 	case IR_HOMEBREW:
 	case IR_IRDEO:
@@ -29,10 +27,5 @@
 	if (sense != -1)
 		sense = !!sense;
 
-	result = serial_ir_init();
-	if (!result)
-		return 0;
-
-	serial_ir_exit();
-	return result;
+	return serial_ir_init();
 }","{'deleted_lines': ['\tint result;', '', '\tresult = serial_ir_init();', '\tif (!result)', '\t\treturn 0;', '', '\tserial_ir_exit();', '\treturn result;'], 'added_lines': ['\treturn serial_ir_init();']}",True,"In the Linux kernel before 5.1.6, there is a use-after-free in serial_ir_init_module() in drivers/media/rc/serial_ir.c.",7.8,HIGH,2,test,,5
CVE-2007-5199,['CWE-119'],AV:N/AC:L/Au:N/C:P/I:P/A:P,0,xorg/lib/libXfont,"this occurs if readlink writes a result that's exactly the
size of the buffer that's passed to it. Reported by
Joerg Sonnenberger.

Re
",5bf703700ee4a5d6eae20da07cb7a29369667aef,https://cgit.freedesktop.org/xorg/lib/libXfont/commit/?id=5bf703700ee4a5d6eae20da07cb7a29369667aef,src/fontfile/catalogue.c,CatalogueRescan,"static int
CatalogueRescan (FontPathElementPtr fpe)
{
CataloguePtrcat = fpe->private;
charlink[MAXFONTFILENAMELEN];
chardest[MAXFONTFILENAMELEN];
char*attrib;
FontPathElementPtrsubfpe;
struct statstatbuf;
const char*path;
DIR*dir;
struct dirent*entry;
intlen;
intpathlen;
path = fpe->name + strlen(CataloguePrefix);
if (stat(path, &statbuf) < 0 || !S_ISDIR(statbuf.st_mode))
return BadFontPath;
if (statbuf.st_mtime <= cat->mtime)
return Successful;
dir = opendir(path);
if (dir == NULL)
{
xfree(cat);
return BadFontPath;
}
CatalogueUnrefFPEs (fpe);
while (entry = readdir(dir), entry != NULL)
{
snprintf(link, sizeof link, ""%s/%s"", path, entry->d_name);
len = readlink(link, dest, sizeof dest);
if (len < 0)
continue;
dest[len] = '\0';
if (dest[0] != '/')
{
pathlen = strlen(path);
memmove(dest + pathlen + 1, dest, sizeof dest - pathlen - 1);
memcpy(dest, path, pathlen);
memcpy(dest + pathlen, ""/"", 1);
len += pathlen + 1;
}
attrib = strchr(link, ':');
if (attrib && len + strlen(attrib) < sizeof dest)
{
memcpy(dest + len, attrib, strlen(attrib));
len += strlen(attrib);
}
subfpe = xalloc(sizeof *subfpe);
if (subfpe == NULL)
continue;
subfpe->type = fpe->type;
subfpe->name_length = len;
subfpe->name = xalloc (len + 1);
if (subfpe == NULL)
{
xfree(subfpe);
continue;
}
memcpy(subfpe->name, dest, len);
subfpe->name[len] = '\0';
subfpe->refcount = 1;
if (FontFileInitFPE (subfpe) != Successful)
{
xfree(subfpe->name);
xfree(subfpe);
continue;
}
if (CatalogueAddFPE(cat, subfpe) != Successful)
{
FontFileFreeFPE (subfpe);
xfree(subfpe);
continue;
}
}
closedir(dir);
qsort(cat->fpeList,
cat->fpeCount, sizeof cat->fpeList[0], ComparePriority);
cat->mtime = statbuf.st_mtime;
return Successful;
}","static int
CatalogueRescan (FontPathElementPtr VAR_0)
{
CataloguePtrVAR_1 = VAR_0->private;
charVAR_2[VAR_3];
charVAR_4[VAR_3];
char*VAR_5;
FontPathElementPtrVAR_6;
struct statVAR_7;
const char*VAR_8;
DIR*VAR_9;
struct dirent*VAR_10;
intVAR_11;
intVAR_12;
VAR_8 = VAR_0->name + strlen(VAR_13);
if (stat(VAR_8, &VAR_7) < 0 || !S_ISDIR(VAR_7.st_mode))
return VAR_14;
if (VAR_7.st_mtime <= VAR_1->mtime)
return VAR_15;
VAR_9 = opendir(VAR_8);
if (VAR_9 == NULL)
{
xfree(VAR_1);
return VAR_14;
}
CatalogueUnrefFPEs (VAR_0);
while (VAR_10 = readdir(VAR_9), VAR_10 != NULL)
{
snprintf(VAR_2, sizeof VAR_2, ""%s/%s"", VAR_8, VAR_10->d_name);
VAR_11 = readlink(VAR_2, VAR_4, sizeof VAR_4);
if (VAR_11 < 0)
continue;
VAR_4[VAR_11] = '\0';
if (VAR_4[0] != '/')
{
VAR_12 = strlen(VAR_8);
memmove(VAR_4 + VAR_12 + 1, VAR_4, sizeof VAR_4 - VAR_12 - 1);
memcpy(VAR_4, VAR_8, VAR_12);
memcpy(VAR_4 + VAR_12, ""/"", 1);
VAR_11 += VAR_12 + 1;
}
VAR_5 = strchr(VAR_2, ':');
if (VAR_5 && VAR_11 + strlen(VAR_5) < sizeof VAR_4)
{
memcpy(VAR_4 + VAR_11, VAR_5, strlen(VAR_5));
VAR_11 += strlen(VAR_5);
}
VAR_6 = xalloc(sizeof *VAR_6);
if (VAR_6 == NULL)
continue;
VAR_6->type = VAR_0->type;
VAR_6->name_length = VAR_11;
VAR_6->name = xalloc (VAR_11 + 1);
if (VAR_6 == NULL)
{
xfree(VAR_6);
continue;
}
memcpy(VAR_6->name, VAR_4, VAR_11);
VAR_6->name[VAR_11] = '\0';
VAR_6->refcount = 1;
if (FontFileInitFPE (VAR_6) != VAR_15)
{
xfree(VAR_6->name);
xfree(VAR_6);
continue;
}
if (CatalogueAddFPE(VAR_1, VAR_6) != VAR_15)
{
FontFileFreeFPE (VAR_6);
xfree(VAR_6);
continue;
}
}
closedir(VAR_9);
qsort(VAR_1->fpeList,
VAR_1->fpeCount, sizeof VAR_1->fpeList[0], VAR_16);
VAR_1->mtime = VAR_7.st_mtime;
return VAR_15;
}",xorg/lib/libXfont/5bf703700ee4a5d6eae20da07cb7a29369667aef/catalogue.c/vul/before/0.json,"static int
CatalogueRescan (FontPathElementPtr fpe)
{
    CataloguePtr	cat = fpe->private;
    char		link[MAXFONTFILENAMELEN];
    char		dest[MAXFONTFILENAMELEN];
    char		*attrib;
    FontPathElementPtr	subfpe;
    struct stat		statbuf;
    const char		*path;
    DIR			*dir;
    struct dirent	*entry;
    int			len;
    int			pathlen;

    path = fpe->name + strlen(CataloguePrefix);
    if (stat(path, &statbuf) < 0 || !S_ISDIR(statbuf.st_mode))
	return BadFontPath;

    if (statbuf.st_mtime <= cat->mtime)
	return Successful;

    dir = opendir(path);
    if (dir == NULL)
    {
	xfree(cat);
	return BadFontPath;
    }

    CatalogueUnrefFPEs (fpe);
    while (entry = readdir(dir), entry != NULL)
    {
	snprintf(link, sizeof link, ""%s/%s"", path, entry->d_name);
	len = readlink(link, dest, sizeof dest - 1);
	if (len < 0)
	    continue;

	dest[len] = '\0';

	if (dest[0] != '/')
	{
	   pathlen = strlen(path);
	   memmove(dest + pathlen + 1, dest, sizeof dest - pathlen - 1);
	   memcpy(dest, path, pathlen);
	   memcpy(dest + pathlen, ""/"", 1);
	   len += pathlen + 1;
	}

	attrib = strchr(link, ':');
	if (attrib && len + strlen(attrib) < sizeof dest)
	{
	    memcpy(dest + len, attrib, strlen(attrib));
	    len += strlen(attrib);
	}

	subfpe = xalloc(sizeof *subfpe);
	if (subfpe == NULL)
	    continue;

	/* The fonts returned by OpenFont will point back to the
	 * subfpe they come from.  So set the type of the subfpe to
	 * what the catalogue fpe was assigned, so calls to CloseFont
	 * (which uses font->fpe->type) goes to CatalogueCloseFont. */
	subfpe->type = fpe->type;
	subfpe->name_length = len;
	subfpe->name = xalloc (len + 1);
	if (subfpe == NULL)
	{
	    xfree(subfpe);
	    continue;
	}

	memcpy(subfpe->name, dest, len);
	subfpe->name[len] = '\0';

	/* The X server will manipulate the subfpe ref counts
	 * associated with the font in OpenFont and CloseFont, so we
	 * have to make sure it's valid. */
	subfpe->refcount = 1;

	if (FontFileInitFPE (subfpe) != Successful)
	{
	    xfree(subfpe->name);
	    xfree(subfpe);
	    continue;
	}

	if (CatalogueAddFPE(cat, subfpe) != Successful)
	{
	    FontFileFreeFPE (subfpe);
	    xfree(subfpe);
	    continue;
	}
    }

    closedir(dir);

    qsort(cat->fpeList,
	  cat->fpeCount, sizeof cat->fpeList[0], ComparePriority);

    cat->mtime = statbuf.st_mtime;

    return Successful;
}","static int
CatalogueRescan (FontPathElementPtr VAR_0)
{
    CataloguePtr	VAR_1 = VAR_0->private;
    char		VAR_2[VAR_3];
    char		VAR_4[VAR_3];
    char		*VAR_5;
    FontPathElementPtr	VAR_6;
    struct stat		VAR_7;
    const char		*VAR_8;
    DIR			*VAR_9;
    struct dirent	*VAR_10;
    int			VAR_11;
    int			VAR_12;

    VAR_8 = VAR_0->name + strlen(VAR_13);
    if (stat(VAR_8, &VAR_7) < 0 || !S_ISDIR(VAR_7.st_mode))
	return VAR_14;

    if (VAR_7.st_mtime <= VAR_1->mtime)
	return VAR_15;

    VAR_9 = opendir(VAR_8);
    if (VAR_9 == NULL)
    {
	xfree(VAR_1);
	return VAR_14;
    }

    CatalogueUnrefFPEs (VAR_0);
    while (VAR_10 = readdir(VAR_9), VAR_10 != NULL)
    {
	snprintf(VAR_2, sizeof VAR_2, ""%s/%s"", VAR_8, VAR_10->d_name);
	VAR_11 = readlink(VAR_2, VAR_4, sizeof VAR_4 - 1);
	if (VAR_11 < 0)
	    continue;

	VAR_4[VAR_11] = '\0';

	if (VAR_4[0] != '/')
	{
	   VAR_12 = strlen(VAR_8);
	   memmove(VAR_4 + VAR_12 + 1, VAR_4, sizeof VAR_4 - VAR_12 - 1);
	   memcpy(VAR_4, VAR_8, VAR_12);
	   memcpy(VAR_4 + VAR_12, ""/"", 1);
	   VAR_11 += VAR_12 + 1;
	}

	VAR_5 = strchr(VAR_2, ':');
	if (VAR_5 && VAR_11 + strlen(VAR_5) < sizeof VAR_4)
	{
	    memcpy(VAR_4 + VAR_11, VAR_5, strlen(VAR_5));
	    VAR_11 += strlen(VAR_5);
	}

	VAR_6 = xalloc(sizeof *VAR_6);
	if (VAR_6 == NULL)
	    continue;

	/* COMMENT_0 */
                                                            
                                                              
                                                               
	VAR_6->type = VAR_0->type;
	VAR_6->name_length = VAR_11;
	VAR_6->name = xalloc (VAR_11 + 1);
	if (VAR_6 == NULL)
	{
	    xfree(VAR_6);
	    continue;
	}

	memcpy(VAR_6->name, VAR_4, VAR_11);
	VAR_6->name[VAR_11] = '\0';

	/* COMMENT_4 */
                                                             
                                    
	VAR_6->refcount = 1;

	if (FontFileInitFPE (VAR_6) != VAR_15)
	{
	    xfree(VAR_6->name);
	    xfree(VAR_6);
	    continue;
	}

	if (CatalogueAddFPE(VAR_1, VAR_6) != VAR_15)
	{
	    FontFileFreeFPE (VAR_6);
	    xfree(VAR_6);
	    continue;
	}
    }

    closedir(VAR_9);

    qsort(VAR_1->fpeList,
	  VAR_1->fpeCount, sizeof VAR_1->fpeList[0], VAR_16);

    VAR_1->mtime = VAR_7.st_mtime;

    return VAR_15;
}",xorg/lib/libXfont/5bf703700ee4a5d6eae20da07cb7a29369667aef/catalogue.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -31,7 +31,7 @@
     while (entry = readdir(dir), entry != NULL)
     {
 	snprintf(link, sizeof link, ""%s/%s"", path, entry->d_name);
-	len = readlink(link, dest, sizeof dest);
+	len = readlink(link, dest, sizeof dest - 1);
 	if (len < 0)
 	    continue;
 ","{'deleted_lines': ['\tlen = readlink(link, dest, sizeof dest);'], 'added_lines': ['\tlen = readlink(link, dest, sizeof dest - 1);']}",True,A single byte overflow in catalogue.c in X.Org libXfont 1.3.1 allows remote attackers to have unspecified impact.,9.8,CRITICAL,3,test,,5
CVE-2017-14128,['CWE-125'],AV:N/AC:M/Au:N/C:N/I:N/A:P,0,binutils-gdb,"
Prevent an address violation parsing corrupt DWARF information by fixing the test for an overlong debug line info structure.

	PR 22059
	* dwarf2.c (decode_line_info): Fix test for an overlong line info
	structure.
",7e8b60085eb3e6f2c41bc0c00c0d759fa7f72780,https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=7e8b60085eb3e6f2c41bc0c00c0d759fa7f72780,bfd/dwarf2.c,decode_line_info,"static struct line_info_table*
decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
{
bfd *abfd = unit->abfd;
struct line_info_table* table;
bfd_byte *line_ptr;
bfd_byte *line_end;
struct line_head lh;
unsigned int i, bytes_read, offset_size;
char *cur_file, *cur_dir;
unsigned char op_code, extended_op, adj_opcode;
unsigned int exop_len;
bfd_size_type amt;
if (! read_section (abfd, &stash->debug_sections[debug_line],
stash->syms, unit->line_offset,
&stash->dwarf_line_buffer, &stash->dwarf_line_size))
return NULL;
amt = sizeof (struct line_info_table);
table = (struct line_info_table *) bfd_alloc (abfd, amt);
if (table == NULL)
return NULL;
table->abfd = abfd;
table->comp_dir = unit->comp_dir;
table->num_files = 0;
table->files = NULL;
table->num_dirs = 0;
table->dirs = NULL;
table->num_sequences = 0;
table->sequences = NULL;
table->lcl_head = NULL;
if (stash->dwarf_line_size < 16)
{
_bfd_error_handler
(_(""Dwarf Error: Line info section is too small (%Ld)""),
stash->dwarf_line_size);
bfd_set_error (bfd_error_bad_value);
return NULL;
}
line_ptr = stash->dwarf_line_buffer + unit->line_offset;
line_end = stash->dwarf_line_buffer + stash->dwarf_line_size;
lh.total_length = read_4_bytes (abfd, line_ptr, line_end);
line_ptr += 4;
offset_size = 4;
if (lh.total_length == 0xffffffff)
{
lh.total_length = read_8_bytes (abfd, line_ptr, line_end);
line_ptr += 8;
offset_size = 8;
}
else if (lh.total_length == 0 && unit->addr_size == 8)
{
lh.total_length = read_4_bytes (abfd, line_ptr, line_end);
line_ptr += 4;
offset_size = 8;
}
if (lh.total_length > stash->dwarf_line_size)
{
_bfd_error_handler
(_(""Dwarf Error: Line info data is bigger (%#Lx) than the section (%#Lx)""),
lh.total_length, stash->dwarf_line_size);
bfd_set_error (bfd_error_bad_value);
return NULL;
}
line_end = line_ptr + lh.total_length;
lh.version = read_2_bytes (abfd, line_ptr, line_end);
if (lh.version < 2 || lh.version > 5)
{
_bfd_error_handler
(_(""Dwarf Error: Unhandled .debug_line version %d.""), lh.version);
bfd_set_error (bfd_error_bad_value);
return NULL;
}
line_ptr += 2;
if (line_ptr + offset_size + (lh.version >= 5 ? 8 : (lh.version >= 4 ? 6 : 5))
>= line_end)
{
_bfd_error_handler
(_(""Dwarf Error: Ran out of room reading prologue""));
bfd_set_error (bfd_error_bad_value);
return NULL;
}
if (lh.version >= 5)
{
unsigned int segment_selector_size;
read_1_byte (abfd, line_ptr, line_end);
line_ptr += 1;
segment_selector_size = read_1_byte (abfd, line_ptr, line_end);
line_ptr += 1;
if (segment_selector_size != 0)
{
_bfd_error_handler
(_(""Dwarf Error: Line info unsupported segment selector size %u.""),
segment_selector_size);
bfd_set_error (bfd_error_bad_value);
return NULL;
}
}
if (offset_size == 4)
lh.prologue_length = read_4_bytes (abfd, line_ptr, line_end);
else
lh.prologue_length = read_8_bytes (abfd, line_ptr, line_end);
line_ptr += offset_size;
lh.minimum_instruction_length = read_1_byte (abfd, line_ptr, line_end);
line_ptr += 1;
if (lh.version >= 4)
{
lh.maximum_ops_per_insn = read_1_byte (abfd, line_ptr, line_end);
line_ptr += 1;
}
else
lh.maximum_ops_per_insn = 1;
if (lh.maximum_ops_per_insn == 0)
{
_bfd_error_handler
(_(""Dwarf Error: Invalid maximum operations per instruction.""));
bfd_set_error (bfd_error_bad_value);
return NULL;
}
lh.default_is_stmt = read_1_byte (abfd, line_ptr, line_end);
line_ptr += 1;
lh.line_base = read_1_signed_byte (abfd, line_ptr, line_end);
line_ptr += 1;
lh.line_range = read_1_byte (abfd, line_ptr, line_end);
line_ptr += 1;
lh.opcode_base = read_1_byte (abfd, line_ptr, line_end);
line_ptr += 1;
if (line_ptr + (lh.opcode_base - 1) >= line_end)
{
_bfd_error_handler (_(""Dwarf Error: Ran out of room reading opcodes""));
bfd_set_error (bfd_error_bad_value);
return NULL;
}
amt = lh.opcode_base * sizeof (unsigned char);
lh.standard_opcode_lengths = (unsigned char *) bfd_alloc (abfd, amt);
lh.standard_opcode_lengths[0] = 1;
for (i = 1; i < lh.opcode_base; ++i)
{
lh.standard_opcode_lengths[i] = read_1_byte (abfd, line_ptr, line_end);
line_ptr += 1;
}
if (lh.version >= 5)
{
if (!read_formatted_entries (unit, &line_ptr, line_end, table,
line_info_add_include_dir_stub))
goto fail;
if (!read_formatted_entries (unit, &line_ptr, line_end, table,
line_info_add_file_name))
goto fail;
}
else
{
while ((cur_dir = read_string (abfd, line_ptr, line_end, &bytes_read)) != NULL)
{
line_ptr += bytes_read;
if (!line_info_add_include_dir (table, cur_dir))
goto fail;
}
line_ptr += bytes_read;
while ((cur_file = read_string (abfd, line_ptr, line_end, &bytes_read)) != NULL)
{
unsigned int dir, xtime, size;
line_ptr += bytes_read;
dir = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);
line_ptr += bytes_read;
xtime = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);
line_ptr += bytes_read;
size = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);
line_ptr += bytes_read;
if (!line_info_add_file_name (table, cur_file, dir, xtime, size))
goto fail;
}
line_ptr += bytes_read;
}
while (line_ptr < line_end)
{
bfd_vma address = 0;
unsigned char op_index = 0;
char * filename = table->num_files ? concat_filename (table, 1) : NULL;
unsigned int line = 1;
unsigned int column = 0;
unsigned int discriminator = 0;
int is_stmt = lh.default_is_stmt;
int end_sequence = 0;
bfd_vma low_pc  = (bfd_vma) -1;
bfd_vma high_pc = 0;
while (! end_sequence)
{
op_code = read_1_byte (abfd, line_ptr, line_end);
line_ptr += 1;
if (op_code >= lh.opcode_base)
{
adj_opcode = op_code - lh.opcode_base;
if (lh.line_range == 0)
goto line_fail;
if (lh.maximum_ops_per_insn == 1)
address += (adj_opcode / lh.line_range
* lh.minimum_instruction_length);
else
{
address += ((op_index + adj_opcode / lh.line_range)
/ lh.maximum_ops_per_insn
* lh.minimum_instruction_length);
op_index = ((op_index + adj_opcode / lh.line_range)
% lh.maximum_ops_per_insn);
}
line += lh.line_base + (adj_opcode % lh.line_range);
if (!add_line_info (table, address, op_index, filename,
line, column, discriminator, 0))
goto line_fail;
discriminator = 0;
if (address < low_pc)
low_pc = address;
if (address > high_pc)
high_pc = address;
}
else switch (op_code)
{
case DW_LNS_extended_op:
exop_len = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
FALSE, line_end);
line_ptr += bytes_read;
extended_op = read_1_byte (abfd, line_ptr, line_end);
line_ptr += 1;
switch (extended_op)
{
case DW_LNE_end_sequence:
end_sequence = 1;
if (!add_line_info (table, address, op_index, filename, line,
column, discriminator, end_sequence))
goto line_fail;
discriminator = 0;
if (address < low_pc)
low_pc = address;
if (address > high_pc)
high_pc = address;
if (!arange_add (unit, &unit->arange, low_pc, high_pc))
goto line_fail;
break;
case DW_LNE_set_address:
address = read_address (unit, line_ptr, line_end);
op_index = 0;
line_ptr += unit->addr_size;
break;
case DW_LNE_define_file:
cur_file = read_string (abfd, line_ptr, line_end, &bytes_read);
line_ptr += bytes_read;
if ((table->num_files % FILE_ALLOC_CHUNK) == 0)
{
struct fileinfo *tmp;
amt = table->num_files + FILE_ALLOC_CHUNK;
amt *= sizeof (struct fileinfo);
tmp = (struct fileinfo *) bfd_realloc (table->files, amt);
if (tmp == NULL)
goto line_fail;
table->files = tmp;
}
table->files[table->num_files].name = cur_file;
table->files[table->num_files].dir =
_bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
FALSE, line_end);
line_ptr += bytes_read;
table->files[table->num_files].time =
_bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
FALSE, line_end);
line_ptr += bytes_read;
table->files[table->num_files].size =
_bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
FALSE, line_end);
line_ptr += bytes_read;
table->num_files++;
break;
case DW_LNE_set_discriminator:
discriminator =
_bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
FALSE, line_end);
line_ptr += bytes_read;
break;
case DW_LNE_HP_source_file_correlation:
line_ptr += exop_len - 1;
break;
default:
_bfd_error_handler
(_(""Dwarf Error: mangled line number section.""));
bfd_set_error (bfd_error_bad_value);
line_fail:
if (filename != NULL)
free (filename);
goto fail;
}
break;
case DW_LNS_copy:
if (!add_line_info (table, address, op_index,
filename, line, column, discriminator, 0))
goto line_fail;
discriminator = 0;
if (address < low_pc)
low_pc = address;
if (address > high_pc)
high_pc = address;
break;
case DW_LNS_advance_pc:
if (lh.maximum_ops_per_insn == 1)
address += (lh.minimum_instruction_length
* _bfd_safe_read_leb128 (abfd, line_ptr,
&bytes_read,
FALSE, line_end));
else
{
bfd_vma adjust = _bfd_safe_read_leb128 (abfd, line_ptr,
&bytes_read,
FALSE, line_end);
address = ((op_index + adjust) / lh.maximum_ops_per_insn
* lh.minimum_instruction_length);
op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
}
line_ptr += bytes_read;
break;
case DW_LNS_advance_line:
line += _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
TRUE, line_end);
line_ptr += bytes_read;
break;
case DW_LNS_set_file:
{
unsigned int file;
file = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
FALSE, line_end);
line_ptr += bytes_read;
if (filename)
free (filename);
filename = concat_filename (table, file);
break;
}
case DW_LNS_set_column:
column = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
FALSE, line_end);
line_ptr += bytes_read;
break;
case DW_LNS_negate_stmt:
is_stmt = (!is_stmt);
break;
case DW_LNS_set_basic_block:
break;
case DW_LNS_const_add_pc:
if (lh.maximum_ops_per_insn == 1)
address += (lh.minimum_instruction_length
* ((255 - lh.opcode_base) / lh.line_range));
else
{
bfd_vma adjust = ((255 - lh.opcode_base) / lh.line_range);
address += (lh.minimum_instruction_length
* ((op_index + adjust)
/ lh.maximum_ops_per_insn));
op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
}
break;
case DW_LNS_fixed_advance_pc:
address += read_2_bytes (abfd, line_ptr, line_end);
op_index = 0;
line_ptr += 2;
break;
default:
for (i = 0; i < lh.standard_opcode_lengths[op_code]; i++)
{
(void) _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
FALSE, line_end);
line_ptr += bytes_read;
}
break;
}
}
if (filename)
free (filename);
}
if (sort_line_sequences (table))
return table;
fail:
if (table->sequences != NULL)
free (table->sequences);
if (table->files != NULL)
free (table->files);
if (table->dirs != NULL)
free (table->dirs);
return NULL;
}","static struct line_info_table*
decode_line_info (struct comp_unit *VAR_0, struct dwarf2_debug *VAR_1)
{
bfd *VAR_2 = VAR_0->abfd;
struct line_info_table* VAR_3;
bfd_byte *VAR_4;
bfd_byte *VAR_5;
struct line_head VAR_6;
unsigned int VAR_7, VAR_8, VAR_9;
char *VAR_10, *VAR_11;
unsigned char VAR_12, VAR_13, VAR_14;
unsigned int VAR_15;
bfd_size_type VAR_16;
if (! read_section (VAR_2, &VAR_1->debug_sections[VAR_17],
VAR_1->syms, VAR_0->line_offset,
&VAR_1->dwarf_line_buffer, &VAR_1->dwarf_line_size))
return NULL;
VAR_16 = sizeof (struct line_info_table);
VAR_3 = (struct line_info_table *) bfd_alloc (VAR_2, VAR_16);
if (VAR_3 == NULL)
return NULL;
VAR_3->abfd = VAR_2;
VAR_3->comp_dir = VAR_0->comp_dir;
VAR_3->num_files = 0;
VAR_3->files = NULL;
VAR_3->num_dirs = 0;
VAR_3->dirs = NULL;
VAR_3->num_sequences = 0;
VAR_3->sequences = NULL;
VAR_3->lcl_head = NULL;
if (VAR_1->dwarf_line_size < 16)
{
_bfd_error_handler
(_(""Dwarf Error: Line info section is too small (%Ld)""),
VAR_1->dwarf_line_size);
bfd_set_error (VAR_18);
return NULL;
}
VAR_4 = VAR_1->dwarf_line_buffer + VAR_0->line_offset;
VAR_5 = VAR_1->dwarf_line_buffer + VAR_1->dwarf_line_size;
VAR_6.total_length = read_4_bytes (VAR_2, VAR_4, VAR_5);
VAR_4 += 4;
VAR_9 = 4;
if (VAR_6.total_length == 0xffffffff)
{
VAR_6.total_length = read_8_bytes (VAR_2, VAR_4, VAR_5);
VAR_4 += 8;
VAR_9 = 8;
}
else if (VAR_6.total_length == 0 && VAR_0->addr_size == 8)
{
VAR_6.total_length = read_4_bytes (VAR_2, VAR_4, VAR_5);
VAR_4 += 4;
VAR_9 = 8;
}
if (VAR_6.total_length > VAR_1->dwarf_line_size)
{
_bfd_error_handler
(_(""Dwarf Error: Line info data is bigger (%#Lx) than the section (%#Lx)""),
VAR_6.total_length, VAR_1->dwarf_line_size);
bfd_set_error (VAR_18);
return NULL;
}
VAR_5 = VAR_4 + VAR_6.total_length;
VAR_6.version = read_2_bytes (VAR_2, VAR_4, VAR_5);
if (VAR_6.version < 2 || VAR_6.version > 5)
{
_bfd_error_handler
(_(""Dwarf Error: Unhandled .debug_line version %d.""), VAR_6.version);
bfd_set_error (VAR_18);
return NULL;
}
VAR_4 += 2;
if (VAR_4 + VAR_9 + (VAR_6.version >= 5 ? 8 : (VAR_6.version >= 4 ? 6 : 5))
>= VAR_5)
{
_bfd_error_handler
(_(""Dwarf Error: Ran out of room reading prologue""));
bfd_set_error (VAR_18);
return NULL;
}
if (VAR_6.version >= 5)
{
unsigned int VAR_19;
read_1_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
VAR_19 = read_1_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
if (VAR_19 != 0)
{
_bfd_error_handler
(_(""Dwarf Error: Line info unsupported segment selector size %u.""),
VAR_19);
bfd_set_error (VAR_18);
return NULL;
}
}
if (VAR_9 == 4)
VAR_6.prologue_length = read_4_bytes (VAR_2, VAR_4, VAR_5);
else
VAR_6.prologue_length = read_8_bytes (VAR_2, VAR_4, VAR_5);
VAR_4 += VAR_9;
VAR_6.minimum_instruction_length = read_1_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
if (VAR_6.version >= 4)
{
VAR_6.maximum_ops_per_insn = read_1_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
}
else
VAR_6.maximum_ops_per_insn = 1;
if (VAR_6.maximum_ops_per_insn == 0)
{
_bfd_error_handler
(_(""Dwarf Error: Invalid maximum operations per instruction.""));
bfd_set_error (VAR_18);
return NULL;
}
VAR_6.default_is_stmt = read_1_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
VAR_6.line_base = read_1_signed_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
VAR_6.line_range = read_1_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
VAR_6.opcode_base = read_1_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
if (VAR_4 + (VAR_6.opcode_base - 1) >= VAR_5)
{
_bfd_error_handler (_(""Dwarf Error: Ran out of room reading opcodes""));
bfd_set_error (VAR_18);
return NULL;
}
VAR_16 = VAR_6.opcode_base * sizeof (unsigned char);
VAR_6.standard_opcode_lengths = (unsigned char *) bfd_alloc (VAR_2, VAR_16);
VAR_6.standard_opcode_lengths[0] = 1;
for (VAR_7 = 1; VAR_7 < VAR_6.opcode_base; ++VAR_7)
{
VAR_6.standard_opcode_lengths[VAR_7] = read_1_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
}
if (VAR_6.version >= 5)
{
if (!read_formatted_entries (VAR_0, &VAR_4, VAR_5, VAR_3,
VAR_20))
goto fail;
if (!read_formatted_entries (VAR_0, &VAR_4, VAR_5, VAR_3,
VAR_21))
goto fail;
}
else
{
while ((VAR_11 = read_string (VAR_2, VAR_4, VAR_5, &VAR_8)) != NULL)
{
VAR_4 += VAR_8;
if (!line_info_add_include_dir (VAR_3, VAR_11))
goto fail;
}
VAR_4 += VAR_8;
while ((VAR_10 = read_string (VAR_2, VAR_4, VAR_5, &VAR_8)) != NULL)
{
unsigned int VAR_22, VAR_23, VAR_24;
VAR_4 += VAR_8;
VAR_22 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8, FALSE, VAR_5);
VAR_4 += VAR_8;
VAR_23 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8, FALSE, VAR_5);
VAR_4 += VAR_8;
VAR_24 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8, FALSE, VAR_5);
VAR_4 += VAR_8;
if (!VAR_21 (VAR_3, VAR_10, VAR_22, VAR_23, VAR_24))
goto fail;
}
VAR_4 += VAR_8;
}
while (VAR_4 < VAR_5)
{
bfd_vma VAR_25 = 0;
unsigned char VAR_26 = 0;
char * VAR_27 = VAR_3->num_files ? concat_filename (VAR_3, 1) : NULL;
unsigned int VAR_28 = 1;
unsigned int VAR_29 = 0;
unsigned int VAR_30 = 0;
int VAR_31 = VAR_6.default_is_stmt;
int VAR_32 = 0;
bfd_vma VAR_33  = (bfd_vma) -1;
bfd_vma VAR_34 = 0;
while (! VAR_32)
{
VAR_12 = read_1_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
if (VAR_12 >= VAR_6.opcode_base)
{
VAR_14 = VAR_12 - VAR_6.opcode_base;
if (VAR_6.line_range == 0)
goto line_fail;
if (VAR_6.maximum_ops_per_insn == 1)
VAR_25 += (VAR_14 / VAR_6.line_range
* VAR_6.minimum_instruction_length);
else
{
VAR_25 += ((VAR_26 + VAR_14 / VAR_6.line_range)
/ VAR_6.maximum_ops_per_insn
* VAR_6.minimum_instruction_length);
VAR_26 = ((VAR_26 + VAR_14 / VAR_6.line_range)
% VAR_6.maximum_ops_per_insn);
}
VAR_28 += VAR_6.line_base + (VAR_14 % VAR_6.line_range);
if (!add_line_info (VAR_3, VAR_25, VAR_26, VAR_27,
VAR_28, VAR_29, VAR_30, 0))
goto line_fail;
VAR_30 = 0;
if (VAR_25 < VAR_33)
VAR_33 = VAR_25;
if (VAR_25 > VAR_34)
VAR_34 = VAR_25;
}
else switch (VAR_12)
{
case VAR_35:
VAR_15 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
FALSE, VAR_5);
VAR_4 += VAR_8;
VAR_13 = read_1_byte (VAR_2, VAR_4, VAR_5);
VAR_4 += 1;
switch (VAR_13)
{
case VAR_36:
VAR_32 = 1;
if (!add_line_info (VAR_3, VAR_25, VAR_26, VAR_27, VAR_28,
VAR_29, VAR_30, VAR_32))
goto line_fail;
VAR_30 = 0;
if (VAR_25 < VAR_33)
VAR_33 = VAR_25;
if (VAR_25 > VAR_34)
VAR_34 = VAR_25;
if (!arange_add (VAR_0, &VAR_0->arange, VAR_33, VAR_34))
goto line_fail;
break;
case VAR_37:
VAR_25 = read_address (VAR_0, VAR_4, VAR_5);
VAR_26 = 0;
VAR_4 += VAR_0->addr_size;
break;
case VAR_38:
VAR_10 = read_string (VAR_2, VAR_4, VAR_5, &VAR_8);
VAR_4 += VAR_8;
if ((VAR_3->num_files % VAR_39) == 0)
{
struct fileinfo *VAR_40;
VAR_16 = VAR_3->num_files + VAR_39;
VAR_16 *= sizeof (struct fileinfo);
VAR_40 = (struct fileinfo *) bfd_realloc (VAR_3->files, VAR_16);
if (VAR_40 == NULL)
goto line_fail;
VAR_3->files = VAR_40;
}
VAR_3->files[VAR_3->num_files].name = VAR_10;
VAR_3->files[VAR_3->num_files].dir =
_bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
FALSE, VAR_5);
VAR_4 += VAR_8;
VAR_3->files[VAR_3->num_files].time =
_bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
FALSE, VAR_5);
VAR_4 += VAR_8;
VAR_3->files[VAR_3->num_files].size =
_bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
FALSE, VAR_5);
VAR_4 += VAR_8;
VAR_3->num_files++;
break;
case VAR_41:
VAR_30 =
_bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
FALSE, VAR_5);
VAR_4 += VAR_8;
break;
case VAR_42:
VAR_4 += VAR_15 - 1;
break;
default:
_bfd_error_handler
(_(""Dwarf Error: mangled line number section.""));
bfd_set_error (VAR_18);
line_fail:
if (VAR_27 != NULL)
free (VAR_27);
goto fail;
}
break;
case VAR_43:
if (!add_line_info (VAR_3, VAR_25, VAR_26,
VAR_27, VAR_28, VAR_29, VAR_30, 0))
goto line_fail;
VAR_30 = 0;
if (VAR_25 < VAR_33)
VAR_33 = VAR_25;
if (VAR_25 > VAR_34)
VAR_34 = VAR_25;
break;
case VAR_44:
if (VAR_6.maximum_ops_per_insn == 1)
VAR_25 += (VAR_6.minimum_instruction_length
* _bfd_safe_read_leb128 (VAR_2, VAR_4,
&VAR_8,
FALSE, VAR_5));
else
{
bfd_vma VAR_45 = _bfd_safe_read_leb128 (VAR_2, VAR_4,
&VAR_8,
FALSE, VAR_5);
VAR_25 = ((VAR_26 + VAR_45) / VAR_6.maximum_ops_per_insn
* VAR_6.minimum_instruction_length);
VAR_26 = (VAR_26 + VAR_45) % VAR_6.maximum_ops_per_insn;
}
VAR_4 += VAR_8;
break;
case VAR_46:
VAR_28 += _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
TRUE, VAR_5);
VAR_4 += VAR_8;
break;
case VAR_47:
{
unsigned int VAR_48;
VAR_48 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
FALSE, VAR_5);
VAR_4 += VAR_8;
if (VAR_27)
free (VAR_27);
VAR_27 = concat_filename (VAR_3, VAR_48);
break;
}
case VAR_49:
VAR_29 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
FALSE, VAR_5);
VAR_4 += VAR_8;
break;
case VAR_50:
VAR_31 = (!VAR_31);
break;
case VAR_51:
break;
case VAR_52:
if (VAR_6.maximum_ops_per_insn == 1)
VAR_25 += (VAR_6.minimum_instruction_length
* ((255 - VAR_6.opcode_base) / VAR_6.line_range));
else
{
bfd_vma VAR_45 = ((255 - VAR_6.opcode_base) / VAR_6.line_range);
VAR_25 += (VAR_6.minimum_instruction_length
* ((VAR_26 + VAR_45)
/ VAR_6.maximum_ops_per_insn));
VAR_26 = (VAR_26 + VAR_45) % VAR_6.maximum_ops_per_insn;
}
break;
case VAR_53:
VAR_25 += read_2_bytes (VAR_2, VAR_4, VAR_5);
VAR_26 = 0;
VAR_4 += 2;
break;
default:
for (VAR_7 = 0; VAR_7 < VAR_6.standard_opcode_lengths[VAR_12]; VAR_7++)
{
(void) _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
FALSE, VAR_5);
VAR_4 += VAR_8;
}
break;
}
}
if (VAR_27)
free (VAR_27);
}
if (sort_line_sequences (VAR_3))
return VAR_3;
fail:
if (VAR_3->sequences != NULL)
free (VAR_3->sequences);
if (VAR_3->files != NULL)
free (VAR_3->files);
if (VAR_3->dirs != NULL)
free (VAR_3->dirs);
return NULL;
}",binutils-gdb/7e8b60085eb3e6f2c41bc0c00c0d759fa7f72780/dwarf2.c/vul/before/0.json,"static struct line_info_table*
decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
{
  bfd *abfd = unit->abfd;
  struct line_info_table* table;
  bfd_byte *line_ptr;
  bfd_byte *line_end;
  struct line_head lh;
  unsigned int i, bytes_read, offset_size;
  char *cur_file, *cur_dir;
  unsigned char op_code, extended_op, adj_opcode;
  unsigned int exop_len;
  bfd_size_type amt;

  if (! read_section (abfd, &stash->debug_sections[debug_line],
		      stash->syms, unit->line_offset,
		      &stash->dwarf_line_buffer, &stash->dwarf_line_size))
    return NULL;

  amt = sizeof (struct line_info_table);
  table = (struct line_info_table *) bfd_alloc (abfd, amt);
  if (table == NULL)
    return NULL;
  table->abfd = abfd;
  table->comp_dir = unit->comp_dir;

  table->num_files = 0;
  table->files = NULL;

  table->num_dirs = 0;
  table->dirs = NULL;

  table->num_sequences = 0;
  table->sequences = NULL;

  table->lcl_head = NULL;

  if (stash->dwarf_line_size < 16)
    {
      _bfd_error_handler
	(_(""Dwarf Error: Line info section is too small (%Ld)""),
	 stash->dwarf_line_size);
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }
  line_ptr = stash->dwarf_line_buffer + unit->line_offset;
  line_end = stash->dwarf_line_buffer + stash->dwarf_line_size;

  /* Read in the prologue.  */
  lh.total_length = read_4_bytes (abfd, line_ptr, line_end);
  line_ptr += 4;
  offset_size = 4;
  if (lh.total_length == 0xffffffff)
    {
      lh.total_length = read_8_bytes (abfd, line_ptr, line_end);
      line_ptr += 8;
      offset_size = 8;
    }
  else if (lh.total_length == 0 && unit->addr_size == 8)
    {
      /* Handle (non-standard) 64-bit DWARF2 formats.  */
      lh.total_length = read_4_bytes (abfd, line_ptr, line_end);
      line_ptr += 4;
      offset_size = 8;
    }

  if (unit->line_offset + lh.total_length > stash->dwarf_line_size)
    {
      _bfd_error_handler
	/* xgettext: c-format */
	(_(""Dwarf Error: Line info data is bigger (%#Lx) than the space remaining in the section (%#Lx)""),
	 lh.total_length, stash->dwarf_line_size - unit->line_offset);
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }

  line_end = line_ptr + lh.total_length;

  lh.version = read_2_bytes (abfd, line_ptr, line_end);
  if (lh.version < 2 || lh.version > 5)
    {
      _bfd_error_handler
	(_(""Dwarf Error: Unhandled .debug_line version %d.""), lh.version);
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }
  line_ptr += 2;

  if (line_ptr + offset_size + (lh.version >= 5 ? 8 : (lh.version >= 4 ? 6 : 5))
      >= line_end)
    {
      _bfd_error_handler
	(_(""Dwarf Error: Ran out of room reading prologue""));
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }

  if (lh.version >= 5)
    {
      unsigned int segment_selector_size;

      /* Skip address size.  */
      read_1_byte (abfd, line_ptr, line_end);
      line_ptr += 1;

      segment_selector_size = read_1_byte (abfd, line_ptr, line_end);
      line_ptr += 1;
      if (segment_selector_size != 0)
	{
	  _bfd_error_handler
	    (_(""Dwarf Error: Line info unsupported segment selector size %u.""),
	     segment_selector_size);
	  bfd_set_error (bfd_error_bad_value);
	  return NULL;
	}
    }

  if (offset_size == 4)
    lh.prologue_length = read_4_bytes (abfd, line_ptr, line_end);
  else
    lh.prologue_length = read_8_bytes (abfd, line_ptr, line_end);
  line_ptr += offset_size;

  lh.minimum_instruction_length = read_1_byte (abfd, line_ptr, line_end);
  line_ptr += 1;

  if (lh.version >= 4)
    {
      lh.maximum_ops_per_insn = read_1_byte (abfd, line_ptr, line_end);
      line_ptr += 1;
    }
  else
    lh.maximum_ops_per_insn = 1;

  if (lh.maximum_ops_per_insn == 0)
    {
      _bfd_error_handler
	(_(""Dwarf Error: Invalid maximum operations per instruction.""));
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }

  lh.default_is_stmt = read_1_byte (abfd, line_ptr, line_end);
  line_ptr += 1;

  lh.line_base = read_1_signed_byte (abfd, line_ptr, line_end);
  line_ptr += 1;

  lh.line_range = read_1_byte (abfd, line_ptr, line_end);
  line_ptr += 1;

  lh.opcode_base = read_1_byte (abfd, line_ptr, line_end);
  line_ptr += 1;

  if (line_ptr + (lh.opcode_base - 1) >= line_end)
    {
      _bfd_error_handler (_(""Dwarf Error: Ran out of room reading opcodes""));
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }

  amt = lh.opcode_base * sizeof (unsigned char);
  lh.standard_opcode_lengths = (unsigned char *) bfd_alloc (abfd, amt);

  lh.standard_opcode_lengths[0] = 1;

  for (i = 1; i < lh.opcode_base; ++i)
    {
      lh.standard_opcode_lengths[i] = read_1_byte (abfd, line_ptr, line_end);
      line_ptr += 1;
    }

  if (lh.version >= 5)
    {
      /* Read directory table.  */
      if (!read_formatted_entries (unit, &line_ptr, line_end, table,
				   line_info_add_include_dir_stub))
	goto fail;

      /* Read file name table.  */
      if (!read_formatted_entries (unit, &line_ptr, line_end, table,
				   line_info_add_file_name))
	goto fail;
    }
  else
    {
      /* Read directory table.  */
      while ((cur_dir = read_string (abfd, line_ptr, line_end, &bytes_read)) != NULL)
	{
	  line_ptr += bytes_read;

	  if (!line_info_add_include_dir (table, cur_dir))
	    goto fail;
	}

      line_ptr += bytes_read;

      /* Read file name table.  */
      while ((cur_file = read_string (abfd, line_ptr, line_end, &bytes_read)) != NULL)
	{
	  unsigned int dir, xtime, size;

	  line_ptr += bytes_read;

	  dir = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);
	  line_ptr += bytes_read;
	  xtime = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);
	  line_ptr += bytes_read;
	  size = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);
	  line_ptr += bytes_read;

	  if (!line_info_add_file_name (table, cur_file, dir, xtime, size))
	    goto fail;
	}

      line_ptr += bytes_read;
    }

  /* Read the statement sequences until there's nothing left.  */
  while (line_ptr < line_end)
    {
      /* State machine registers.  */
      bfd_vma address = 0;
      unsigned char op_index = 0;
      char * filename = table->num_files ? concat_filename (table, 1) : NULL;
      unsigned int line = 1;
      unsigned int column = 0;
      unsigned int discriminator = 0;
      int is_stmt = lh.default_is_stmt;
      int end_sequence = 0;
      /* eraxxon@alumni.rice.edu: Against the DWARF2 specs, some
	 compilers generate address sequences that are wildly out of
	 order using DW_LNE_set_address (e.g. Intel C++ 6.0 compiler
	 for ia64-Linux).  Thus, to determine the low and high
	 address, we must compare on every DW_LNS_copy, etc.  */
      bfd_vma low_pc  = (bfd_vma) -1;
      bfd_vma high_pc = 0;

      /* Decode the table.  */
      while (! end_sequence)
	{
	  op_code = read_1_byte (abfd, line_ptr, line_end);
	  line_ptr += 1;

	  if (op_code >= lh.opcode_base)
	    {
	      /* Special operand.  */
	      adj_opcode = op_code - lh.opcode_base;
	      if (lh.line_range == 0)
		goto line_fail;
	      if (lh.maximum_ops_per_insn == 1)
		address += (adj_opcode / lh.line_range
			    * lh.minimum_instruction_length);
	      else
		{
		  address += ((op_index + adj_opcode / lh.line_range)
			      / lh.maximum_ops_per_insn
			      * lh.minimum_instruction_length);
		  op_index = ((op_index + adj_opcode / lh.line_range)
			      % lh.maximum_ops_per_insn);
		}
	      line += lh.line_base + (adj_opcode % lh.line_range);
	      /* Append row to matrix using current values.  */
	      if (!add_line_info (table, address, op_index, filename,
				  line, column, discriminator, 0))
		goto line_fail;
	      discriminator = 0;
	      if (address < low_pc)
		low_pc = address;
	      if (address > high_pc)
		high_pc = address;
	    }
	  else switch (op_code)
	    {
	    case DW_LNS_extended_op:
	      exop_len = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
						FALSE, line_end);
	      line_ptr += bytes_read;
	      extended_op = read_1_byte (abfd, line_ptr, line_end);
	      line_ptr += 1;

	      switch (extended_op)
		{
		case DW_LNE_end_sequence:
		  end_sequence = 1;
		  if (!add_line_info (table, address, op_index, filename, line,
				      column, discriminator, end_sequence))
		    goto line_fail;
		  discriminator = 0;
		  if (address < low_pc)
		    low_pc = address;
		  if (address > high_pc)
		    high_pc = address;
		  if (!arange_add (unit, &unit->arange, low_pc, high_pc))
		    goto line_fail;
		  break;
		case DW_LNE_set_address:
		  address = read_address (unit, line_ptr, line_end);
		  op_index = 0;
		  line_ptr += unit->addr_size;
		  break;
		case DW_LNE_define_file:
		  cur_file = read_string (abfd, line_ptr, line_end, &bytes_read);
		  line_ptr += bytes_read;
		  if ((table->num_files % FILE_ALLOC_CHUNK) == 0)
		    {
		      struct fileinfo *tmp;

		      amt = table->num_files + FILE_ALLOC_CHUNK;
		      amt *= sizeof (struct fileinfo);
		      tmp = (struct fileinfo *) bfd_realloc (table->files, amt);
		      if (tmp == NULL)
			goto line_fail;
		      table->files = tmp;
		    }
		  table->files[table->num_files].name = cur_file;
		  table->files[table->num_files].dir =
		    _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
					   FALSE, line_end);
		  line_ptr += bytes_read;
		  table->files[table->num_files].time =
		    _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
					   FALSE, line_end);
		  line_ptr += bytes_read;
		  table->files[table->num_files].size =
		    _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
					   FALSE, line_end);
		  line_ptr += bytes_read;
		  table->num_files++;
		  break;
		case DW_LNE_set_discriminator:
		  discriminator =
		    _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
					   FALSE, line_end);
		  line_ptr += bytes_read;
		  break;
		case DW_LNE_HP_source_file_correlation:
		  line_ptr += exop_len - 1;
		  break;
		default:
		  _bfd_error_handler
		    (_(""Dwarf Error: mangled line number section.""));
		  bfd_set_error (bfd_error_bad_value);
		line_fail:
		  if (filename != NULL)
		    free (filename);
		  goto fail;
		}
	      break;
	    case DW_LNS_copy:
	      if (!add_line_info (table, address, op_index,
				  filename, line, column, discriminator, 0))
		goto line_fail;
	      discriminator = 0;
	      if (address < low_pc)
		low_pc = address;
	      if (address > high_pc)
		high_pc = address;
	      break;
	    case DW_LNS_advance_pc:
	      if (lh.maximum_ops_per_insn == 1)
		address += (lh.minimum_instruction_length
			    * _bfd_safe_read_leb128 (abfd, line_ptr,
						     &bytes_read,
						     FALSE, line_end));
	      else
		{
		  bfd_vma adjust = _bfd_safe_read_leb128 (abfd, line_ptr,
							  &bytes_read,
							  FALSE, line_end);
		  address = ((op_index + adjust) / lh.maximum_ops_per_insn
			     * lh.minimum_instruction_length);
		  op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
		}
	      line_ptr += bytes_read;
	      break;
	    case DW_LNS_advance_line:
	      line += _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
					     TRUE, line_end);
	      line_ptr += bytes_read;
	      break;
	    case DW_LNS_set_file:
	      {
		unsigned int file;

		/* The file and directory tables are 0
		   based, the references are 1 based.  */
		file = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
					      FALSE, line_end);
		line_ptr += bytes_read;
		if (filename)
		  free (filename);
		filename = concat_filename (table, file);
		break;
	      }
	    case DW_LNS_set_column:
	      column = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
					      FALSE, line_end);
	      line_ptr += bytes_read;
	      break;
	    case DW_LNS_negate_stmt:
	      is_stmt = (!is_stmt);
	      break;
	    case DW_LNS_set_basic_block:
	      break;
	    case DW_LNS_const_add_pc:
	      if (lh.maximum_ops_per_insn == 1)
		address += (lh.minimum_instruction_length
			    * ((255 - lh.opcode_base) / lh.line_range));
	      else
		{
		  bfd_vma adjust = ((255 - lh.opcode_base) / lh.line_range);
		  address += (lh.minimum_instruction_length
			      * ((op_index + adjust)
				 / lh.maximum_ops_per_insn));
		  op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
		}
	      break;
	    case DW_LNS_fixed_advance_pc:
	      address += read_2_bytes (abfd, line_ptr, line_end);
	      op_index = 0;
	      line_ptr += 2;
	      break;
	    default:
	      /* Unknown standard opcode, ignore it.  */
	      for (i = 0; i < lh.standard_opcode_lengths[op_code]; i++)
		{
		  (void) _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
						FALSE, line_end);
		  line_ptr += bytes_read;
		}
	      break;
	    }
	}

      if (filename)
	free (filename);
    }

  if (sort_line_sequences (table))
    return table;

 fail:
  if (table->sequences != NULL)
    free (table->sequences);
  if (table->files != NULL)
    free (table->files);
  if (table->dirs != NULL)
    free (table->dirs);
  return NULL;
}","static struct line_info_table*
decode_line_info (struct comp_unit *VAR_0, struct dwarf2_debug *VAR_1)
{
  bfd *VAR_2 = VAR_0->abfd;
  struct line_info_table* VAR_3;
  bfd_byte *VAR_4;
  bfd_byte *VAR_5;
  struct line_head VAR_6;
  unsigned int VAR_7, VAR_8, VAR_9;
  char *VAR_10, *VAR_11;
  unsigned char VAR_12, VAR_13, VAR_14;
  unsigned int VAR_15;
  bfd_size_type VAR_16;

  if (! read_section (VAR_2, &VAR_1->debug_sections[VAR_17],
		      VAR_1->syms, VAR_0->line_offset,
		      &VAR_1->dwarf_line_buffer, &VAR_1->dwarf_line_size))
    return NULL;

  VAR_16 = sizeof (struct line_info_table);
  VAR_3 = (struct line_info_table *) bfd_alloc (VAR_2, VAR_16);
  if (VAR_3 == NULL)
    return NULL;
  VAR_3->abfd = VAR_2;
  VAR_3->comp_dir = VAR_0->comp_dir;

  VAR_3->num_files = 0;
  VAR_3->files = NULL;

  VAR_3->num_dirs = 0;
  VAR_3->dirs = NULL;

  VAR_3->num_sequences = 0;
  VAR_3->sequences = NULL;

  VAR_3->lcl_head = NULL;

  if (VAR_1->dwarf_line_size < 16)
    {
      _bfd_error_handler
	(_(""Dwarf Error: Line info section is too small (%Ld)""),
	 VAR_1->dwarf_line_size);
      bfd_set_error (VAR_18);
      return NULL;
    }
  VAR_4 = VAR_1->dwarf_line_buffer + VAR_0->line_offset;
  VAR_5 = VAR_1->dwarf_line_buffer + VAR_1->dwarf_line_size;

  /* COMMENT_0 */
  VAR_6.total_length = read_4_bytes (VAR_2, VAR_4, VAR_5);
  VAR_4 += 4;
  VAR_9 = 4;
  if (VAR_6.total_length == 0xffffffff)
    {
      VAR_6.total_length = read_8_bytes (VAR_2, VAR_4, VAR_5);
      VAR_4 += 8;
      VAR_9 = 8;
    }
  else if (VAR_6.total_length == 0 && VAR_0->addr_size == 8)
    {
      /* COMMENT_1 */
      VAR_6.total_length = read_4_bytes (VAR_2, VAR_4, VAR_5);
      VAR_4 += 4;
      VAR_9 = 8;
    }

  if (VAR_0->line_offset + VAR_6.total_length > VAR_1->dwarf_line_size)
    {
      _bfd_error_handler
	/* COMMENT_2 */
	(_(""Dwarf Error: Line info data is bigger (%#Lx) than the space remaining in the section (%#Lx)""),
	 VAR_6.total_length, VAR_1->dwarf_line_size - VAR_0->line_offset);
      bfd_set_error (VAR_18);
      return NULL;
    }

  VAR_5 = VAR_4 + VAR_6.total_length;

  VAR_6.version = read_2_bytes (VAR_2, VAR_4, VAR_5);
  if (VAR_6.version < 2 || VAR_6.version > 5)
    {
      _bfd_error_handler
	(_(""Dwarf Error: Unhandled .debug_line version %d.""), VAR_6.version);
      bfd_set_error (VAR_18);
      return NULL;
    }
  VAR_4 += 2;

  if (VAR_4 + VAR_9 + (VAR_6.version >= 5 ? 8 : (VAR_6.version >= 4 ? 6 : 5))
      >= VAR_5)
    {
      _bfd_error_handler
	(_(""Dwarf Error: Ran out of room reading prologue""));
      bfd_set_error (VAR_18);
      return NULL;
    }

  if (VAR_6.version >= 5)
    {
      unsigned int VAR_19;

      /* COMMENT_3 */
      read_1_byte (VAR_2, VAR_4, VAR_5);
      VAR_4 += 1;

      VAR_19 = read_1_byte (VAR_2, VAR_4, VAR_5);
      VAR_4 += 1;
      if (VAR_19 != 0)
	{
	  _bfd_error_handler
	    (_(""Dwarf Error: Line info unsupported segment selector size %u.""),
	     VAR_19);
	  bfd_set_error (VAR_18);
	  return NULL;
	}
    }

  if (VAR_9 == 4)
    VAR_6.prologue_length = read_4_bytes (VAR_2, VAR_4, VAR_5);
  else
    VAR_6.prologue_length = read_8_bytes (VAR_2, VAR_4, VAR_5);
  VAR_4 += VAR_9;

  VAR_6.minimum_instruction_length = read_1_byte (VAR_2, VAR_4, VAR_5);
  VAR_4 += 1;

  if (VAR_6.version >= 4)
    {
      VAR_6.maximum_ops_per_insn = read_1_byte (VAR_2, VAR_4, VAR_5);
      VAR_4 += 1;
    }
  else
    VAR_6.maximum_ops_per_insn = 1;

  if (VAR_6.maximum_ops_per_insn == 0)
    {
      _bfd_error_handler
	(_(""Dwarf Error: Invalid maximum operations per instruction.""));
      bfd_set_error (VAR_18);
      return NULL;
    }

  VAR_6.default_is_stmt = read_1_byte (VAR_2, VAR_4, VAR_5);
  VAR_4 += 1;

  VAR_6.line_base = read_1_signed_byte (VAR_2, VAR_4, VAR_5);
  VAR_4 += 1;

  VAR_6.line_range = read_1_byte (VAR_2, VAR_4, VAR_5);
  VAR_4 += 1;

  VAR_6.opcode_base = read_1_byte (VAR_2, VAR_4, VAR_5);
  VAR_4 += 1;

  if (VAR_4 + (VAR_6.opcode_base - 1) >= VAR_5)
    {
      _bfd_error_handler (_(""Dwarf Error: Ran out of room reading opcodes""));
      bfd_set_error (VAR_18);
      return NULL;
    }

  VAR_16 = VAR_6.opcode_base * sizeof (unsigned char);
  VAR_6.standard_opcode_lengths = (unsigned char *) bfd_alloc (VAR_2, VAR_16);

  VAR_6.standard_opcode_lengths[0] = 1;

  for (VAR_7 = 1; VAR_7 < VAR_6.opcode_base; ++VAR_7)
    {
      VAR_6.standard_opcode_lengths[VAR_7] = read_1_byte (VAR_2, VAR_4, VAR_5);
      VAR_4 += 1;
    }

  if (VAR_6.version >= 5)
    {
      /* COMMENT_4 */
      if (!read_formatted_entries (VAR_0, &VAR_4, VAR_5, VAR_3,
				   VAR_20))
	goto fail;

      /* COMMENT_5 */
      if (!read_formatted_entries (VAR_0, &VAR_4, VAR_5, VAR_3,
				   VAR_21))
	goto fail;
    }
  else
    {
      /* COMMENT_4 */
      while ((VAR_11 = read_string (VAR_2, VAR_4, VAR_5, &VAR_8)) != NULL)
	{
	  VAR_4 += VAR_8;

	  if (!line_info_add_include_dir (VAR_3, VAR_11))
	    goto fail;
	}

      VAR_4 += VAR_8;

      /* COMMENT_5 */
      while ((VAR_10 = read_string (VAR_2, VAR_4, VAR_5, &VAR_8)) != NULL)
	{
	  unsigned int VAR_22, VAR_23, VAR_24;

	  VAR_4 += VAR_8;

	  VAR_22 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8, FALSE, VAR_5);
	  VAR_4 += VAR_8;
	  VAR_23 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8, FALSE, VAR_5);
	  VAR_4 += VAR_8;
	  VAR_24 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8, FALSE, VAR_5);
	  VAR_4 += VAR_8;

	  if (!VAR_21 (VAR_3, VAR_10, VAR_22, VAR_23, VAR_24))
	    goto fail;
	}

      VAR_4 += VAR_8;
    }

  /* COMMENT_6 */
  while (VAR_4 < VAR_5)
    {
      /* COMMENT_7 */
      bfd_vma VAR_25 = 0;
      unsigned char VAR_26 = 0;
      char * VAR_27 = VAR_3->num_files ? concat_filename (VAR_3, 1) : NULL;
      unsigned int VAR_28 = 1;
      unsigned int VAR_29 = 0;
      unsigned int VAR_30 = 0;
      int VAR_31 = VAR_6.default_is_stmt;
      int VAR_32 = 0;
      /* COMMENT_8 */
                                                             
                                                             
                                                       
                                                         
      bfd_vma VAR_33  = (bfd_vma) -1;
      bfd_vma VAR_34 = 0;

      /* COMMENT_13 */
      while (! VAR_32)
	{
	  VAR_12 = read_1_byte (VAR_2, VAR_4, VAR_5);
	  VAR_4 += 1;

	  if (VAR_12 >= VAR_6.opcode_base)
	    {
	      /* COMMENT_14 */
	      VAR_14 = VAR_12 - VAR_6.opcode_base;
	      if (VAR_6.line_range == 0)
		goto line_fail;
	      if (VAR_6.maximum_ops_per_insn == 1)
		VAR_25 += (VAR_14 / VAR_6.line_range
			    * VAR_6.minimum_instruction_length);
	      else
		{
		  VAR_25 += ((VAR_26 + VAR_14 / VAR_6.line_range)
			      / VAR_6.maximum_ops_per_insn
			      * VAR_6.minimum_instruction_length);
		  VAR_26 = ((VAR_26 + VAR_14 / VAR_6.line_range)
			      % VAR_6.maximum_ops_per_insn);
		}
	      VAR_28 += VAR_6.line_base + (VAR_14 % VAR_6.line_range);
	      /* COMMENT_15 */
	      if (!add_line_info (VAR_3, VAR_25, VAR_26, VAR_27,
				  VAR_28, VAR_29, VAR_30, 0))
		goto line_fail;
	      VAR_30 = 0;
	      if (VAR_25 < VAR_33)
		VAR_33 = VAR_25;
	      if (VAR_25 > VAR_34)
		VAR_34 = VAR_25;
	    }
	  else switch (VAR_12)
	    {
	    case VAR_35:
	      VAR_15 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
						FALSE, VAR_5);
	      VAR_4 += VAR_8;
	      VAR_13 = read_1_byte (VAR_2, VAR_4, VAR_5);
	      VAR_4 += 1;

	      switch (VAR_13)
		{
		case VAR_36:
		  VAR_32 = 1;
		  if (!add_line_info (VAR_3, VAR_25, VAR_26, VAR_27, VAR_28,
				      VAR_29, VAR_30, VAR_32))
		    goto line_fail;
		  VAR_30 = 0;
		  if (VAR_25 < VAR_33)
		    VAR_33 = VAR_25;
		  if (VAR_25 > VAR_34)
		    VAR_34 = VAR_25;
		  if (!arange_add (VAR_0, &VAR_0->arange, VAR_33, VAR_34))
		    goto line_fail;
		  break;
		case VAR_37:
		  VAR_25 = read_address (VAR_0, VAR_4, VAR_5);
		  VAR_26 = 0;
		  VAR_4 += VAR_0->addr_size;
		  break;
		case VAR_38:
		  VAR_10 = read_string (VAR_2, VAR_4, VAR_5, &VAR_8);
		  VAR_4 += VAR_8;
		  if ((VAR_3->num_files % VAR_39) == 0)
		    {
		      struct fileinfo *VAR_40;

		      VAR_16 = VAR_3->num_files + VAR_39;
		      VAR_16 *= sizeof (struct fileinfo);
		      VAR_40 = (struct fileinfo *) bfd_realloc (VAR_3->files, VAR_16);
		      if (VAR_40 == NULL)
			goto line_fail;
		      VAR_3->files = VAR_40;
		    }
		  VAR_3->files[VAR_3->num_files].name = VAR_10;
		  VAR_3->files[VAR_3->num_files].dir =
		    _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
					   FALSE, VAR_5);
		  VAR_4 += VAR_8;
		  VAR_3->files[VAR_3->num_files].time =
		    _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
					   FALSE, VAR_5);
		  VAR_4 += VAR_8;
		  VAR_3->files[VAR_3->num_files].size =
		    _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
					   FALSE, VAR_5);
		  VAR_4 += VAR_8;
		  VAR_3->num_files++;
		  break;
		case VAR_41:
		  VAR_30 =
		    _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
					   FALSE, VAR_5);
		  VAR_4 += VAR_8;
		  break;
		case VAR_42:
		  VAR_4 += VAR_15 - 1;
		  break;
		default:
		  _bfd_error_handler
		    (_(""Dwarf Error: mangled line number section.""));
		  bfd_set_error (VAR_18);
		line_fail:
		  if (VAR_27 != NULL)
		    free (VAR_27);
		  goto fail;
		}
	      break;
	    case VAR_43:
	      if (!add_line_info (VAR_3, VAR_25, VAR_26,
				  VAR_27, VAR_28, VAR_29, VAR_30, 0))
		goto line_fail;
	      VAR_30 = 0;
	      if (VAR_25 < VAR_33)
		VAR_33 = VAR_25;
	      if (VAR_25 > VAR_34)
		VAR_34 = VAR_25;
	      break;
	    case VAR_44:
	      if (VAR_6.maximum_ops_per_insn == 1)
		VAR_25 += (VAR_6.minimum_instruction_length
			    * _bfd_safe_read_leb128 (VAR_2, VAR_4,
						     &VAR_8,
						     FALSE, VAR_5));
	      else
		{
		  bfd_vma VAR_45 = _bfd_safe_read_leb128 (VAR_2, VAR_4,
							  &VAR_8,
							  FALSE, VAR_5);
		  VAR_25 = ((VAR_26 + VAR_45) / VAR_6.maximum_ops_per_insn
			     * VAR_6.minimum_instruction_length);
		  VAR_26 = (VAR_26 + VAR_45) % VAR_6.maximum_ops_per_insn;
		}
	      VAR_4 += VAR_8;
	      break;
	    case VAR_46:
	      VAR_28 += _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
					     TRUE, VAR_5);
	      VAR_4 += VAR_8;
	      break;
	    case VAR_47:
	      {
		unsigned int VAR_48;

		/* COMMENT_16 */
                                           
		VAR_48 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
					      FALSE, VAR_5);
		VAR_4 += VAR_8;
		if (VAR_27)
		  free (VAR_27);
		VAR_27 = concat_filename (VAR_3, VAR_48);
		break;
	      }
	    case VAR_49:
	      VAR_29 = _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
					      FALSE, VAR_5);
	      VAR_4 += VAR_8;
	      break;
	    case VAR_50:
	      VAR_31 = (!VAR_31);
	      break;
	    case VAR_51:
	      break;
	    case VAR_52:
	      if (VAR_6.maximum_ops_per_insn == 1)
		VAR_25 += (VAR_6.minimum_instruction_length
			    * ((255 - VAR_6.opcode_base) / VAR_6.line_range));
	      else
		{
		  bfd_vma VAR_45 = ((255 - VAR_6.opcode_base) / VAR_6.line_range);
		  VAR_25 += (VAR_6.minimum_instruction_length
			      * ((VAR_26 + VAR_45)
				 / VAR_6.maximum_ops_per_insn));
		  VAR_26 = (VAR_26 + VAR_45) % VAR_6.maximum_ops_per_insn;
		}
	      break;
	    case VAR_53:
	      VAR_25 += read_2_bytes (VAR_2, VAR_4, VAR_5);
	      VAR_26 = 0;
	      VAR_4 += 2;
	      break;
	    default:
	      /* COMMENT_18 */
	      for (VAR_7 = 0; VAR_7 < VAR_6.standard_opcode_lengths[VAR_12]; VAR_7++)
		{
		  (void) _bfd_safe_read_leb128 (VAR_2, VAR_4, &VAR_8,
						FALSE, VAR_5);
		  VAR_4 += VAR_8;
		}
	      break;
	    }
	}

      if (VAR_27)
	free (VAR_27);
    }

  if (sort_line_sequences (VAR_3))
    return VAR_3;

 fail:
  if (VAR_3->sequences != NULL)
    free (VAR_3->sequences);
  if (VAR_3->files != NULL)
    free (VAR_3->files);
  if (VAR_3->dirs != NULL)
    free (VAR_3->dirs);
  return NULL;
}",binutils-gdb/7e8b60085eb3e6f2c41bc0c00c0d759fa7f72780/dwarf2.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -64,12 +64,12 @@
       offset_size = 8;
     }
 
-  if (lh.total_length > stash->dwarf_line_size)
+  if (unit->line_offset + lh.total_length > stash->dwarf_line_size)
     {
       _bfd_error_handler
 	/* xgettext: c-format */
-	(_(""Dwarf Error: Line info data is bigger (%#Lx) than the section (%#Lx)""),
-	 lh.total_length, stash->dwarf_line_size);
+	(_(""Dwarf Error: Line info data is bigger (%#Lx) than the space remaining in the section (%#Lx)""),
+	 lh.total_length, stash->dwarf_line_size - unit->line_offset);
       bfd_set_error (bfd_error_bad_value);
       return NULL;
     }","{'deleted_lines': ['  if (lh.total_length > stash->dwarf_line_size)', '\t(_(""Dwarf Error: Line info data is bigger (%#Lx) than the section (%#Lx)""),', '\t lh.total_length, stash->dwarf_line_size);'], 'added_lines': ['  if (unit->line_offset + lh.total_length > stash->dwarf_line_size)', '\t(_(""Dwarf Error: Line info data is bigger (%#Lx) than the space remaining in the section (%#Lx)""),', '\t lh.total_length, stash->dwarf_line_size - unit->line_offset);']}",True,"The decode_line_info function in dwarf2.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (read_1_byte heap-based buffer over-read and application crash) via a crafted ELF file.",5.5,MEDIUM,1,test,,5
CVE-2021-43389,['CWE-125'],AV:L/AC:L/Au:N/C:N/I:N/A:P,0,torvalds/linux,"The cmtp_add_connection() would add a cmtp session to a controller
and run a kernel thread to process cmtp.

	__module_get(THIS_MODULE);
	session->task = kthread_run(cmtp_session, session, ""kcmtpd_ctr_%d"",
								session->num);

During this process, the kernel thread would call detach_capi_ctr()
to detach a register controller. if the controller
was not attached yet, detach_capi_ctr() would
trigger an array-index-out-bounds bug.

[   46.866069][ T6479] UBSAN: array-index-out-of-bounds in
drivers/isdn/capi/kcapi.c:483:21
[   46.867196][ T6479] index -1 is out of range for type 'capi_ctr *[32]'
[   46.867982][ T6479] CPU: 1 PID: 6479 Comm: kcmtpd_ctr_0 Not tainted
5.15.0-rc2+ #8
[   46.869002][ T6479] Hardware name: QEMU Standard PC (i440FX + PIIX,
1996), BIOS 1.14.0-2 04/01/2014
[   46.870107][ T6479] Call Trace:
[   46.870473][ T6479]  dump_stack_lvl+0x57/0x7d
[   46.870974][ T6479]  ubsan_epilogue+0x5/0x40
[   46.871458][ T6479]  __ubsan_handle_out_of_bounds.cold+0x43/0x48
[   46.872135][ T6479]  detach_capi_ctr+0x64/0xc0
[   46.872639][ T6479]  cmtp_session+0x5c8/0x5d0
[   46.873131][ T6479]  ? __init_waitqueue_head+0x60/0x60
[   46.873712][ T6479]  ? cmtp_add_msgpart+0x120/0x120
[   46.874256][ T6479]  kthread+0x147/0x170
[   46.874709][ T6479]  ? set_kthread_struct+0x40/0x40
[   46.875248][ T6479]  ret_from_fork+0x1f/0x30
[   46.875773][ T6479]

Signed-off-by: Xiaolong Huang <butterflyhuangxx@gmail.com>
Acked-by: Arnd Bergmann <arnd@arndb.de>
Link: https://lore.kernel.org/r/20211008065830.305057-1-butterflyhuangxx@gmail.com
Signed-off-by: Jakub Kicinski <kuba@kernel.org>
",1f3e2e97c003f80c4b087092b225c8787ff91e4d,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=1f3e2e97c003f80c4b087092b225c8787ff91e4d,drivers/isdn/capi/kcapi.c,detach_capi_ctr,"int detach_capi_ctr(struct capi_ctr *ctr)
{
int err = 0;
mutex_lock(&capi_controller_lock);
ctr_down(ctr, CAPI_CTR_DETACHED);
if (capi_controller[ctr->cnr - 1] != ctr) {
err = -EINVAL;
goto unlock_out;
}
capi_controller[ctr->cnr - 1] = NULL;
ncontrollers--;
if (ctr->procent)
remove_proc_entry(ctr->procfn, NULL);
printk(KERN_NOTICE ""kcapi: controller [%03d]: %s unregistered\n"",
ctr->cnr, ctr->name);
unlock_out:
mutex_unlock(&capi_controller_lock);
return err;
}","int detach_capi_ctr(struct capi_ctr *VAR_0)
{
int VAR_1 = 0;
mutex_lock(&VAR_2);
ctr_down(VAR_0, VAR_3);
if (VAR_4[VAR_0->cnr - 1] != VAR_0) {
VAR_1 = -VAR_5;
goto unlock_out;
}
VAR_4[VAR_0->cnr - 1] = NULL;
VAR_6--;
if (VAR_0->procent)
remove_proc_entry(VAR_0->procfn, NULL);
printk(KERN_NOTICE ""kcapi: controller [%03d]: %s unregistered\n"",
VAR_0->cnr, VAR_0->name);
unlock_out:
mutex_unlock(&VAR_2);
return VAR_1;
}",torvalds/linux/1f3e2e97c003f80c4b087092b225c8787ff91e4d/kcapi.c/vul/before/0.json,"int detach_capi_ctr(struct capi_ctr *ctr)
{
	int err = 0;

	mutex_lock(&capi_controller_lock);

	ctr_down(ctr, CAPI_CTR_DETACHED);

	if (ctr->cnr < 1 || ctr->cnr - 1 >= CAPI_MAXCONTR) {
		err = -EINVAL;
		goto unlock_out;
	}

	if (capi_controller[ctr->cnr - 1] != ctr) {
		err = -EINVAL;
		goto unlock_out;
	}
	capi_controller[ctr->cnr - 1] = NULL;
	ncontrollers--;

	if (ctr->procent)
		remove_proc_entry(ctr->procfn, NULL);

	printk(KERN_NOTICE ""kcapi: controller [%03d]: %s unregistered\n"",
	       ctr->cnr, ctr->name);

unlock_out:
	mutex_unlock(&capi_controller_lock);

	return err;
}","int detach_capi_ctr(struct capi_ctr *VAR_0)
{
	int VAR_1 = 0;

	mutex_lock(&VAR_2);

	ctr_down(VAR_0, VAR_3);

	if (VAR_0->cnr < 1 || VAR_0->cnr - 1 >= VAR_4) {
		VAR_1 = -VAR_5;
		goto unlock_out;
	}

	if (VAR_6[VAR_0->cnr - 1] != VAR_0) {
		VAR_1 = -VAR_5;
		goto unlock_out;
	}
	VAR_6[VAR_0->cnr - 1] = NULL;
	VAR_7--;

	if (VAR_0->procent)
		remove_proc_entry(VAR_0->procfn, NULL);

	printk(KERN_NOTICE ""kcapi: controller [%03d]: %s unregistered\n"",
	       VAR_0->cnr, VAR_0->name);

unlock_out:
	mutex_unlock(&VAR_2);

	return VAR_1;
}",torvalds/linux/1f3e2e97c003f80c4b087092b225c8787ff91e4d/kcapi.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,6 +5,11 @@
 	mutex_lock(&capi_controller_lock);
 
 	ctr_down(ctr, CAPI_CTR_DETACHED);
+
+	if (ctr->cnr < 1 || ctr->cnr - 1 >= CAPI_MAXCONTR) {
+		err = -EINVAL;
+		goto unlock_out;
+	}
 
 	if (capi_controller[ctr->cnr - 1] != ctr) {
 		err = -EINVAL;","{'deleted_lines': [], 'added_lines': ['', '\tif (ctr->cnr < 1 || ctr->cnr - 1 >= CAPI_MAXCONTR) {', '\t\terr = -EINVAL;', '\t\tgoto unlock_out;', '\t}']}",True,An issue was discovered in the Linux kernel before 5.14.15. There is an array-index-out-of-bounds flaw in the detach_capi_ctr function in drivers/isdn/capi/kcapi.c.,5.5,MEDIUM,1,test,,5
CVE-2021-39921,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"Modbus: Add null pointer checks.

Fixes #17703.
",bb41b6619210d998f1abacc43ee20acc985249a4,https://gitlab.com/wireshark/wireshark/-/commit/bb41b6619210d998f1abacc43ee20acc985249a4,epan/dissectors/packet-mbtcp.c,dissect_modbus_request,"static int
dissect_modbus_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *modbus_tree, guint8 function_code, gint payload_start, gint payload_len, modbus_pkt_info_t *pkt_info)
{
proto_tree    *group_tree;
gint          byte_cnt, group_offset, ii;
guint8        mei_code;
guint16       reg_base=0, diagnostic_code;
guint32       group_byte_cnt, group_word_cnt;
switch (function_code) {
case READ_COILS:
case READ_DISCRETE_INPUTS:
proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
proto_tree_add_item(modbus_tree, hf_modbus_bitcnt, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);
break;
case READ_HOLDING_REGS:
case READ_INPUT_REGS:
proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
proto_tree_add_item(modbus_tree, hf_modbus_wordcnt, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);
break;
case WRITE_SINGLE_COIL:
proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 2, 1, pkt_info->register_format, reg_base, 0);
proto_tree_add_item(modbus_tree, hf_modbus_padding, tvb, payload_start + 3, 1, ENC_NA);
break;
case WRITE_SINGLE_REG:
proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 2, 2, pkt_info->register_format, reg_base, 0);
break;
case READ_EXCEPT_STAT:
break;
case DIAGNOSTICS:
diagnostic_code = tvb_get_ntohs(tvb, payload_start);
proto_tree_add_uint(modbus_tree, hf_modbus_diag_sf, tvb, payload_start, 2, diagnostic_code);
switch(diagnostic_code)
{
case RETURN_QUERY_DATA:
if (payload_len > 2)
proto_tree_add_item(modbus_tree, hf_modbus_diag_return_query_data_request, tvb, payload_start+2, payload_len-2, ENC_NA);
break;
case RESTART_COMMUNICATION_OPTION:
proto_tree_add_item(modbus_tree, hf_modbus_diag_restart_communication_option, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
break;
case CHANGE_ASCII_INPUT_DELIMITER:
proto_tree_add_item(modbus_tree, hf_modbus_diag_ascii_input_delimiter, tvb, payload_start+2, 1, ENC_BIG_ENDIAN);
break;
case RETURN_DIAGNOSTIC_REGISTER:           
case FORCE_LISTEN_ONLY_MODE:               
case CLEAR_COUNTERS_AND_DIAG_REG:          
case RETURN_BUS_MESSAGE_COUNT:             
case RETURN_BUS_COMM_ERROR_COUNT:          
case RETURN_BUS_EXCEPTION_ERROR_COUNT:     
case RETURN_SLAVE_MESSAGE_COUNT:           
case RETURN_SLAVE_NO_RESPONSE_COUNT:       
case RETURN_SLAVE_NAK_COUNT:               
case RETURN_SLAVE_BUSY_COUNT:              
case RETURN_BUS_CHAR_OVERRUN_COUNT:        
case CLEAR_OVERRUN_COUNTER_AND_FLAG:
default:
if (payload_len > 2)
dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start+2, payload_len-2, pkt_info->register_format, reg_base, 0);
break;
}
break;
case WRITE_MULT_COILS:
proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
proto_tree_add_item(modbus_tree, hf_modbus_bitcnt, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);
byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start + 4);
proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start + 4, 1, byte_cnt);
dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 5, byte_cnt, pkt_info->register_format, reg_base, 0);
break;
case WRITE_MULT_REGS:
reg_base = tvb_get_ntohs(tvb, payload_start);
proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
proto_tree_add_item(modbus_tree, hf_modbus_wordcnt, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);
byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start + 4);
proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start + 4, 1, byte_cnt);
dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 5, byte_cnt, pkt_info->register_format, reg_base, 0);
break;
case READ_FILE_RECORD:
byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start);
proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start, 1,
byte_cnt);
group_offset = payload_start + 1;
for (ii = 0; ii < byte_cnt / 7; ii++) {
group_tree = proto_tree_add_subtree_format( modbus_tree, tvb, group_offset, 7,
ett_group_hdr, NULL, ""Group %u"", ii);
proto_tree_add_item(group_tree, hf_modbus_reftype, tvb, group_offset, 1, ENC_BIG_ENDIAN);
proto_tree_add_item(group_tree, hf_modbus_lreference, tvb, group_offset + 1, 4, ENC_BIG_ENDIAN);
proto_tree_add_item(group_tree, hf_modbus_wordcnt, tvb, group_offset + 5, 2, ENC_BIG_ENDIAN);
group_offset += 7;
}
break;
case WRITE_FILE_RECORD:
byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start);
proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start, 1, byte_cnt);
group_offset = payload_start + 1;
ii = 0;
while (byte_cnt > 0) {
group_word_cnt = tvb_get_ntohs(tvb, group_offset + 5);
group_byte_cnt = (2 * group_word_cnt) + 7;
group_tree = proto_tree_add_subtree_format( modbus_tree, tvb, group_offset,
group_byte_cnt, ett_group_hdr, NULL, ""Group %u"", ii);
proto_tree_add_item(group_tree, hf_modbus_reftype, tvb, group_offset, 1, ENC_BIG_ENDIAN);
proto_tree_add_item(group_tree, hf_modbus_lreference, tvb, group_offset + 1, 4, ENC_BIG_ENDIAN);
proto_tree_add_uint(group_tree, hf_modbus_wordcnt, tvb, group_offset + 5, 2, group_word_cnt);
dissect_modbus_data(tvb, pinfo, group_tree, function_code, group_offset + 7, group_byte_cnt - 7, pkt_info->register_format, reg_base, 0);
group_offset += group_byte_cnt;
byte_cnt -= group_byte_cnt;
ii++;
}
break;
case MASK_WRITE_REG:
proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
proto_tree_add_item(modbus_tree, hf_modbus_andmask, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);
proto_tree_add_item(modbus_tree, hf_modbus_ormask, tvb, payload_start + 4, 2, ENC_BIG_ENDIAN);
break;
case READ_WRITE_REG:
proto_tree_add_item(modbus_tree, hf_modbus_readref, tvb, payload_start, 2, ENC_BIG_ENDIAN);
proto_tree_add_item(modbus_tree, hf_modbus_readwordcnt, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);
proto_tree_add_item(modbus_tree, hf_modbus_writeref, tvb, payload_start + 4, 2, ENC_BIG_ENDIAN);
proto_tree_add_item(modbus_tree, hf_modbus_writewordcnt, tvb, payload_start + 6, 2, ENC_BIG_ENDIAN);
byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start + 8);
proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start + 8, 1, byte_cnt);
dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 9, byte_cnt, pkt_info->register_format, reg_base, 0);
break;
case READ_FIFO_QUEUE:
proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
break;
case ENCAP_INTERFACE_TRANSP:
proto_tree_add_item(modbus_tree, hf_modbus_mei, tvb, payload_start, 1, ENC_BIG_ENDIAN);
mei_code = tvb_get_guint8(tvb, payload_start);
switch (mei_code)
{
case READ_DEVICE_ID:
proto_tree_add_item(modbus_tree, hf_modbus_read_device_id, tvb, payload_start+1, 1, ENC_BIG_ENDIAN);
proto_tree_add_item(modbus_tree, hf_modbus_object_id, tvb, payload_start+2, 1, ENC_BIG_ENDIAN);
break;
case CANOPEN_REQ_RESP:
default:
if (payload_len > 1)
dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len-1, pkt_info->register_format, reg_base, 0);
break;
}
break;
case REPORT_SLAVE_ID:
default:
if (payload_len > 0)
dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len, pkt_info->register_format, reg_base, 0);
break;
} 
return tvb_captured_length(tvb);
}","static int
dissect_modbus_request(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, guint8 VAR_3, gint VAR_4, gint VAR_5, modbus_pkt_info_t *VAR_6)
{
proto_tree    *VAR_7;
gint          VAR_8, VAR_9, VAR_10;
guint8        VAR_11;
guint16       VAR_12=0, VAR_13;
guint32       VAR_14, VAR_15;
switch (VAR_3) {
case VAR_16:
case VAR_17:
proto_tree_add_item(VAR_2, VAR_18, VAR_0, VAR_4, 2, VAR_19);
proto_tree_add_item(VAR_2, VAR_20, VAR_0, VAR_4 + 2, 2, VAR_19);
break;
case VAR_21:
case VAR_22:
proto_tree_add_item(VAR_2, VAR_18, VAR_0, VAR_4, 2, VAR_19);
proto_tree_add_item(VAR_2, VAR_23, VAR_0, VAR_4 + 2, 2, VAR_19);
break;
case VAR_24:
proto_tree_add_item(VAR_2, VAR_18, VAR_0, VAR_4, 2, VAR_19);
dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 2, 1, VAR_6->register_format, VAR_12, 0);
proto_tree_add_item(VAR_2, VAR_25, VAR_0, VAR_4 + 3, 1, VAR_26);
break;
case VAR_27:
proto_tree_add_item(VAR_2, VAR_18, VAR_0, VAR_4, 2, VAR_19);
dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 2, 2, VAR_6->register_format, VAR_12, 0);
break;
case VAR_28:
break;
case VAR_29:
VAR_13 = tvb_get_ntohs(VAR_0, VAR_4);
proto_tree_add_uint(VAR_2, VAR_30, VAR_0, VAR_4, 2, VAR_13);
switch(VAR_13)
{
case VAR_31:
if (VAR_5 > 2)
proto_tree_add_item(VAR_2, VAR_32, VAR_0, VAR_4+2, VAR_5-2, VAR_26);
break;
case VAR_33:
proto_tree_add_item(VAR_2, VAR_34, VAR_0, VAR_4+2, 2, VAR_19);
break;
case VAR_35:
proto_tree_add_item(VAR_2, VAR_36, VAR_0, VAR_4+2, 1, VAR_19);
break;
case VAR_37:           
case VAR_38:               
case VAR_39:          
case VAR_40:             
case VAR_41:          
case VAR_42:     
case VAR_43:           
case VAR_44:       
case VAR_45:               
case VAR_46:              
case VAR_47:        
case VAR_48:
default:
if (VAR_5 > 2)
dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4+2, VAR_5-2, VAR_6->register_format, VAR_12, 0);
break;
}
break;
case VAR_49:
proto_tree_add_item(VAR_2, VAR_18, VAR_0, VAR_4, 2, VAR_19);
proto_tree_add_item(VAR_2, VAR_20, VAR_0, VAR_4 + 2, 2, VAR_19);
VAR_8 = (guint32)tvb_get_guint8(VAR_0, VAR_4 + 4);
proto_tree_add_uint(VAR_2, VAR_50, VAR_0, VAR_4 + 4, 1, VAR_8);
dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 5, VAR_8, VAR_6->register_format, VAR_12, 0);
break;
case VAR_51:
VAR_12 = tvb_get_ntohs(VAR_0, VAR_4);
proto_tree_add_item(VAR_2, VAR_18, VAR_0, VAR_4, 2, VAR_19);
proto_tree_add_item(VAR_2, VAR_23, VAR_0, VAR_4 + 2, 2, VAR_19);
VAR_8 = (guint32)tvb_get_guint8(VAR_0, VAR_4 + 4);
proto_tree_add_uint(VAR_2, VAR_50, VAR_0, VAR_4 + 4, 1, VAR_8);
dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 5, VAR_8, VAR_6->register_format, VAR_12, 0);
break;
case VAR_52:
VAR_8 = (guint32)tvb_get_guint8(VAR_0, VAR_4);
proto_tree_add_uint(VAR_2, VAR_50, VAR_0, VAR_4, 1,
VAR_8);
VAR_9 = VAR_4 + 1;
for (VAR_10 = 0; VAR_10 < VAR_8 / 7; VAR_10++) {
VAR_7 = proto_tree_add_subtree_format( VAR_2, VAR_0, VAR_9, 7,
VAR_53, NULL, ""Group %u"", VAR_10);
proto_tree_add_item(VAR_7, VAR_54, VAR_0, VAR_9, 1, VAR_19);
proto_tree_add_item(VAR_7, VAR_55, VAR_0, VAR_9 + 1, 4, VAR_19);
proto_tree_add_item(VAR_7, VAR_23, VAR_0, VAR_9 + 5, 2, VAR_19);
VAR_9 += 7;
}
break;
case VAR_56:
VAR_8 = (guint32)tvb_get_guint8(VAR_0, VAR_4);
proto_tree_add_uint(VAR_2, VAR_50, VAR_0, VAR_4, 1, VAR_8);
VAR_9 = VAR_4 + 1;
VAR_10 = 0;
while (VAR_8 > 0) {
VAR_15 = tvb_get_ntohs(VAR_0, VAR_9 + 5);
VAR_14 = (2 * VAR_15) + 7;
VAR_7 = proto_tree_add_subtree_format( VAR_2, VAR_0, VAR_9,
VAR_14, VAR_53, NULL, ""Group %u"", VAR_10);
proto_tree_add_item(VAR_7, VAR_54, VAR_0, VAR_9, 1, VAR_19);
proto_tree_add_item(VAR_7, VAR_55, VAR_0, VAR_9 + 1, 4, VAR_19);
proto_tree_add_uint(VAR_7, VAR_23, VAR_0, VAR_9 + 5, 2, VAR_15);
dissect_modbus_data(VAR_0, VAR_1, VAR_7, VAR_3, VAR_9 + 7, VAR_14 - 7, VAR_6->register_format, VAR_12, 0);
VAR_9 += VAR_14;
VAR_8 -= VAR_14;
VAR_10++;
}
break;
case VAR_57:
proto_tree_add_item(VAR_2, VAR_18, VAR_0, VAR_4, 2, VAR_19);
proto_tree_add_item(VAR_2, VAR_58, VAR_0, VAR_4 + 2, 2, VAR_19);
proto_tree_add_item(VAR_2, VAR_59, VAR_0, VAR_4 + 4, 2, VAR_19);
break;
case VAR_60:
proto_tree_add_item(VAR_2, VAR_61, VAR_0, VAR_4, 2, VAR_19);
proto_tree_add_item(VAR_2, VAR_62, VAR_0, VAR_4 + 2, 2, VAR_19);
proto_tree_add_item(VAR_2, VAR_63, VAR_0, VAR_4 + 4, 2, VAR_19);
proto_tree_add_item(VAR_2, VAR_64, VAR_0, VAR_4 + 6, 2, VAR_19);
VAR_8 = (guint32)tvb_get_guint8(VAR_0, VAR_4 + 8);
proto_tree_add_uint(VAR_2, VAR_50, VAR_0, VAR_4 + 8, 1, VAR_8);
dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 9, VAR_8, VAR_6->register_format, VAR_12, 0);
break;
case VAR_65:
proto_tree_add_item(VAR_2, VAR_18, VAR_0, VAR_4, 2, VAR_19);
break;
case VAR_66:
proto_tree_add_item(VAR_2, VAR_67, VAR_0, VAR_4, 1, VAR_19);
VAR_11 = tvb_get_guint8(VAR_0, VAR_4);
switch (VAR_11)
{
case VAR_68:
proto_tree_add_item(VAR_2, VAR_69, VAR_0, VAR_4+1, 1, VAR_19);
proto_tree_add_item(VAR_2, VAR_70, VAR_0, VAR_4+2, 1, VAR_19);
break;
case VAR_71:
default:
if (VAR_5 > 1)
dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5-1, VAR_6->register_format, VAR_12, 0);
break;
}
break;
case VAR_72:
default:
if (VAR_5 > 0)
dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6->register_format, VAR_12, 0);
break;
} 
return tvb_captured_length(VAR_0);
}",wireshark/bb41b6619210d998f1abacc43ee20acc985249a4/packet-mbtcp.c/vul/before/0.json,"static int
dissect_modbus_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *modbus_tree, guint8 function_code, gint payload_start, gint payload_len, modbus_pkt_info_t *pkt_info)
{
    proto_tree    *group_tree;
    gint          byte_cnt, group_offset, ii;
    guint8        mei_code;
    guint16       reg_base=0, diagnostic_code;
    guint32       group_byte_cnt, group_word_cnt;

    if (!pkt_info) {
        return 0;
    }

    switch (function_code) {

        case READ_COILS:
        case READ_DISCRETE_INPUTS:
            proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(modbus_tree, hf_modbus_bitcnt, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);
            break;

        case READ_HOLDING_REGS:
        case READ_INPUT_REGS:
            proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(modbus_tree, hf_modbus_wordcnt, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);
            break;

        case WRITE_SINGLE_COIL:
            proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
            dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 2, 1, pkt_info->register_format, reg_base, 0);
            proto_tree_add_item(modbus_tree, hf_modbus_padding, tvb, payload_start + 3, 1, ENC_NA);
            break;

        case WRITE_SINGLE_REG:
            proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
            dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 2, 2, pkt_info->register_format, reg_base, 0);
            break;

        case READ_EXCEPT_STAT:
            /* Do Nothing  */
            break;

        case DIAGNOSTICS:
            diagnostic_code = tvb_get_ntohs(tvb, payload_start);
            proto_tree_add_uint(modbus_tree, hf_modbus_diag_sf, tvb, payload_start, 2, diagnostic_code);
            switch(diagnostic_code)
            {
                case RETURN_QUERY_DATA:
                    if (payload_len > 2)
                        proto_tree_add_item(modbus_tree, hf_modbus_diag_return_query_data_request, tvb, payload_start+2, payload_len-2, ENC_NA);
                    break;
                case RESTART_COMMUNICATION_OPTION:
                    proto_tree_add_item(modbus_tree, hf_modbus_diag_restart_communication_option, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
                    break;
                case CHANGE_ASCII_INPUT_DELIMITER:
                    proto_tree_add_item(modbus_tree, hf_modbus_diag_ascii_input_delimiter, tvb, payload_start+2, 1, ENC_BIG_ENDIAN);
                    break;
                case RETURN_DIAGNOSTIC_REGISTER:           /* 00 00 Data Field */
                case FORCE_LISTEN_ONLY_MODE:               /* 00 00 Data Field */
                case CLEAR_COUNTERS_AND_DIAG_REG:          /* 00 00 Data Field */
                case RETURN_BUS_MESSAGE_COUNT:             /* 00 00 Data Field */
                case RETURN_BUS_COMM_ERROR_COUNT:          /* 00 00 Data Field */
                case RETURN_BUS_EXCEPTION_ERROR_COUNT:     /* 00 00 Data Field */
                case RETURN_SLAVE_MESSAGE_COUNT:           /* 00 00 Data Field */
                case RETURN_SLAVE_NO_RESPONSE_COUNT:       /* 00 00 Data Field */
                case RETURN_SLAVE_NAK_COUNT:               /* 00 00 Data Field */
                case RETURN_SLAVE_BUSY_COUNT:              /* 00 00 Data Field */
                case RETURN_BUS_CHAR_OVERRUN_COUNT:        /* 00 00 Data Field */
                case CLEAR_OVERRUN_COUNTER_AND_FLAG:
                default:
                    if (payload_len > 2)
                        dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start+2, payload_len-2, pkt_info->register_format, reg_base, 0);
                    break;
            }
            break;
        case WRITE_MULT_COILS:
            proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(modbus_tree, hf_modbus_bitcnt, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);
            byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start + 4);
            proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start + 4, 1, byte_cnt);
            dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 5, byte_cnt, pkt_info->register_format, reg_base, 0);
            break;

        case WRITE_MULT_REGS:
            reg_base = tvb_get_ntohs(tvb, payload_start);
            proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(modbus_tree, hf_modbus_wordcnt, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);
            byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start + 4);
            proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start + 4, 1, byte_cnt);
            dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 5, byte_cnt, pkt_info->register_format, reg_base, 0);
            break;

        case READ_FILE_RECORD:
            byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start);
            proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start, 1,
                    byte_cnt);

            /* add subtrees to describe each group of packet */
            group_offset = payload_start + 1;
            for (ii = 0; ii < byte_cnt / 7; ii++) {
                group_tree = proto_tree_add_subtree_format( modbus_tree, tvb, group_offset, 7,
                        ett_group_hdr, NULL, ""Group %u"", ii);
                proto_tree_add_item(group_tree, hf_modbus_reftype, tvb, group_offset, 1, ENC_BIG_ENDIAN);
                proto_tree_add_item(group_tree, hf_modbus_lreference, tvb, group_offset + 1, 4, ENC_BIG_ENDIAN);
                proto_tree_add_item(group_tree, hf_modbus_wordcnt, tvb, group_offset + 5, 2, ENC_BIG_ENDIAN);
                group_offset += 7;
            }
            break;

        case WRITE_FILE_RECORD:
            byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start);
            proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start, 1, byte_cnt);

            /* add subtrees to describe each group of packet */
            group_offset = payload_start + 1;
            ii = 0;
            while (byte_cnt > 0) {
                group_word_cnt = tvb_get_ntohs(tvb, group_offset + 5);
                group_byte_cnt = (2 * group_word_cnt) + 7;
                group_tree = proto_tree_add_subtree_format( modbus_tree, tvb, group_offset,
                        group_byte_cnt, ett_group_hdr, NULL, ""Group %u"", ii);
                proto_tree_add_item(group_tree, hf_modbus_reftype, tvb, group_offset, 1, ENC_BIG_ENDIAN);
                proto_tree_add_item(group_tree, hf_modbus_lreference, tvb, group_offset + 1, 4, ENC_BIG_ENDIAN);
                proto_tree_add_uint(group_tree, hf_modbus_wordcnt, tvb, group_offset + 5, 2, group_word_cnt);
                dissect_modbus_data(tvb, pinfo, group_tree, function_code, group_offset + 7, group_byte_cnt - 7, pkt_info->register_format, reg_base, 0);
                group_offset += group_byte_cnt;
                byte_cnt -= group_byte_cnt;
                ii++;
            }
            break;

        case MASK_WRITE_REG:
            proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(modbus_tree, hf_modbus_andmask, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(modbus_tree, hf_modbus_ormask, tvb, payload_start + 4, 2, ENC_BIG_ENDIAN);
            break;

        case READ_WRITE_REG:
            proto_tree_add_item(modbus_tree, hf_modbus_readref, tvb, payload_start, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(modbus_tree, hf_modbus_readwordcnt, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(modbus_tree, hf_modbus_writeref, tvb, payload_start + 4, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(modbus_tree, hf_modbus_writewordcnt, tvb, payload_start + 6, 2, ENC_BIG_ENDIAN);
            byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start + 8);
            proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start + 8, 1, byte_cnt);
            dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 9, byte_cnt, pkt_info->register_format, reg_base, 0);
            break;

        case READ_FIFO_QUEUE:
            proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
            break;

        case ENCAP_INTERFACE_TRANSP:
            proto_tree_add_item(modbus_tree, hf_modbus_mei, tvb, payload_start, 1, ENC_BIG_ENDIAN);
            mei_code = tvb_get_guint8(tvb, payload_start);
            switch (mei_code)
            {
                case READ_DEVICE_ID:
                    proto_tree_add_item(modbus_tree, hf_modbus_read_device_id, tvb, payload_start+1, 1, ENC_BIG_ENDIAN);
                    proto_tree_add_item(modbus_tree, hf_modbus_object_id, tvb, payload_start+2, 1, ENC_BIG_ENDIAN);
                    break;

                case CANOPEN_REQ_RESP:
                    /* CANopen protocol not part of the Modbus/TCP specification */
                default:
                    if (payload_len > 1)
                        dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len-1, pkt_info->register_format, reg_base, 0);
                    break;
            }

            break;

        case REPORT_SLAVE_ID:
        default:
            if (payload_len > 0)
                dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len, pkt_info->register_format, reg_base, 0);
            break;

    } /* Function Code */

    return tvb_captured_length(tvb);
}","static int
dissect_modbus_request(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, guint8 VAR_3, gint VAR_4, gint VAR_5, modbus_pkt_info_t *VAR_6)
{
    proto_tree    *VAR_7;
    gint          VAR_8, VAR_9, VAR_10;
    guint8        VAR_11;
    guint16       VAR_12=0, VAR_13;
    guint32       VAR_14, VAR_15;

    if (!VAR_6) {
        return 0;
    }

    switch (VAR_3) {

        case VAR_16:
        case VAR_17:
            proto_tree_add_item(VAR_2, VAR_18, VAR_0, VAR_4, 2, VAR_19);
            proto_tree_add_item(VAR_2, VAR_20, VAR_0, VAR_4 + 2, 2, VAR_19);
            break;

        case VAR_21:
        case VAR_22:
            proto_tree_add_item(VAR_2, VAR_18, VAR_0, VAR_4, 2, VAR_19);
            proto_tree_add_item(VAR_2, VAR_23, VAR_0, VAR_4 + 2, 2, VAR_19);
            break;

        case VAR_24:
            proto_tree_add_item(VAR_2, VAR_18, VAR_0, VAR_4, 2, VAR_19);
            dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 2, 1, VAR_6->register_format, VAR_12, 0);
            proto_tree_add_item(VAR_2, VAR_25, VAR_0, VAR_4 + 3, 1, VAR_26);
            break;

        case VAR_27:
            proto_tree_add_item(VAR_2, VAR_18, VAR_0, VAR_4, 2, VAR_19);
            dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 2, 2, VAR_6->register_format, VAR_12, 0);
            break;

        case VAR_28:
            /* COMMENT_0 */
            break;

        case VAR_29:
            VAR_13 = tvb_get_ntohs(VAR_0, VAR_4);
            proto_tree_add_uint(VAR_2, VAR_30, VAR_0, VAR_4, 2, VAR_13);
            switch(VAR_13)
            {
                case VAR_31:
                    if (VAR_5 > 2)
                        proto_tree_add_item(VAR_2, VAR_32, VAR_0, VAR_4+2, VAR_5-2, VAR_26);
                    break;
                case VAR_33:
                    proto_tree_add_item(VAR_2, VAR_34, VAR_0, VAR_4+2, 2, VAR_19);
                    break;
                case VAR_35:
                    proto_tree_add_item(VAR_2, VAR_36, VAR_0, VAR_4+2, 1, VAR_19);
                    break;
                case VAR_37:           /* COMMENT_1 */
                case VAR_38:               /* COMMENT_1 */
                case VAR_39:          /* COMMENT_1 */
                case VAR_40:             /* COMMENT_1 */
                case VAR_41:          /* COMMENT_1 */
                case VAR_42:     /* COMMENT_1 */
                case VAR_43:           /* COMMENT_1 */
                case VAR_44:       /* COMMENT_1 */
                case VAR_45:               /* COMMENT_1 */
                case VAR_46:              /* COMMENT_1 */
                case VAR_47:        /* COMMENT_1 */
                case VAR_48:
                default:
                    if (VAR_5 > 2)
                        dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4+2, VAR_5-2, VAR_6->register_format, VAR_12, 0);
                    break;
            }
            break;
        case VAR_49:
            proto_tree_add_item(VAR_2, VAR_18, VAR_0, VAR_4, 2, VAR_19);
            proto_tree_add_item(VAR_2, VAR_20, VAR_0, VAR_4 + 2, 2, VAR_19);
            VAR_8 = (guint32)tvb_get_guint8(VAR_0, VAR_4 + 4);
            proto_tree_add_uint(VAR_2, VAR_50, VAR_0, VAR_4 + 4, 1, VAR_8);
            dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 5, VAR_8, VAR_6->register_format, VAR_12, 0);
            break;

        case VAR_51:
            VAR_12 = tvb_get_ntohs(VAR_0, VAR_4);
            proto_tree_add_item(VAR_2, VAR_18, VAR_0, VAR_4, 2, VAR_19);
            proto_tree_add_item(VAR_2, VAR_23, VAR_0, VAR_4 + 2, 2, VAR_19);
            VAR_8 = (guint32)tvb_get_guint8(VAR_0, VAR_4 + 4);
            proto_tree_add_uint(VAR_2, VAR_50, VAR_0, VAR_4 + 4, 1, VAR_8);
            dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 5, VAR_8, VAR_6->register_format, VAR_12, 0);
            break;

        case VAR_52:
            VAR_8 = (guint32)tvb_get_guint8(VAR_0, VAR_4);
            proto_tree_add_uint(VAR_2, VAR_50, VAR_0, VAR_4, 1,
                    VAR_8);

            /* COMMENT_2 */
            VAR_9 = VAR_4 + 1;
            for (VAR_10 = 0; VAR_10 < VAR_8 / 7; VAR_10++) {
                VAR_7 = proto_tree_add_subtree_format( VAR_2, VAR_0, VAR_9, 7,
                        VAR_53, NULL, ""Group %u"", VAR_10);
                proto_tree_add_item(VAR_7, VAR_54, VAR_0, VAR_9, 1, VAR_19);
                proto_tree_add_item(VAR_7, VAR_55, VAR_0, VAR_9 + 1, 4, VAR_19);
                proto_tree_add_item(VAR_7, VAR_23, VAR_0, VAR_9 + 5, 2, VAR_19);
                VAR_9 += 7;
            }
            break;

        case VAR_56:
            VAR_8 = (guint32)tvb_get_guint8(VAR_0, VAR_4);
            proto_tree_add_uint(VAR_2, VAR_50, VAR_0, VAR_4, 1, VAR_8);

            /* COMMENT_2 */
            VAR_9 = VAR_4 + 1;
            VAR_10 = 0;
            while (VAR_8 > 0) {
                VAR_15 = tvb_get_ntohs(VAR_0, VAR_9 + 5);
                VAR_14 = (2 * VAR_15) + 7;
                VAR_7 = proto_tree_add_subtree_format( VAR_2, VAR_0, VAR_9,
                        VAR_14, VAR_53, NULL, ""Group %u"", VAR_10);
                proto_tree_add_item(VAR_7, VAR_54, VAR_0, VAR_9, 1, VAR_19);
                proto_tree_add_item(VAR_7, VAR_55, VAR_0, VAR_9 + 1, 4, VAR_19);
                proto_tree_add_uint(VAR_7, VAR_23, VAR_0, VAR_9 + 5, 2, VAR_15);
                dissect_modbus_data(VAR_0, VAR_1, VAR_7, VAR_3, VAR_9 + 7, VAR_14 - 7, VAR_6->register_format, VAR_12, 0);
                VAR_9 += VAR_14;
                VAR_8 -= VAR_14;
                VAR_10++;
            }
            break;

        case VAR_57:
            proto_tree_add_item(VAR_2, VAR_18, VAR_0, VAR_4, 2, VAR_19);
            proto_tree_add_item(VAR_2, VAR_58, VAR_0, VAR_4 + 2, 2, VAR_19);
            proto_tree_add_item(VAR_2, VAR_59, VAR_0, VAR_4 + 4, 2, VAR_19);
            break;

        case VAR_60:
            proto_tree_add_item(VAR_2, VAR_61, VAR_0, VAR_4, 2, VAR_19);
            proto_tree_add_item(VAR_2, VAR_62, VAR_0, VAR_4 + 2, 2, VAR_19);
            proto_tree_add_item(VAR_2, VAR_63, VAR_0, VAR_4 + 4, 2, VAR_19);
            proto_tree_add_item(VAR_2, VAR_64, VAR_0, VAR_4 + 6, 2, VAR_19);
            VAR_8 = (guint32)tvb_get_guint8(VAR_0, VAR_4 + 8);
            proto_tree_add_uint(VAR_2, VAR_50, VAR_0, VAR_4 + 8, 1, VAR_8);
            dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 9, VAR_8, VAR_6->register_format, VAR_12, 0);
            break;

        case VAR_65:
            proto_tree_add_item(VAR_2, VAR_18, VAR_0, VAR_4, 2, VAR_19);
            break;

        case VAR_66:
            proto_tree_add_item(VAR_2, VAR_67, VAR_0, VAR_4, 1, VAR_19);
            VAR_11 = tvb_get_guint8(VAR_0, VAR_4);
            switch (VAR_11)
            {
                case VAR_68:
                    proto_tree_add_item(VAR_2, VAR_69, VAR_0, VAR_4+1, 1, VAR_19);
                    proto_tree_add_item(VAR_2, VAR_70, VAR_0, VAR_4+2, 1, VAR_19);
                    break;

                case VAR_71:
                    /* COMMENT_3 */
                default:
                    if (VAR_5 > 1)
                        dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5-1, VAR_6->register_format, VAR_12, 0);
                    break;
            }

            break;

        case VAR_72:
        default:
            if (VAR_5 > 0)
                dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6->register_format, VAR_12, 0);
            break;

    } /* COMMENT_4 */

    return tvb_captured_length(VAR_0);
}",wireshark/bb41b6619210d998f1abacc43ee20acc985249a4/packet-mbtcp.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,6 +6,10 @@
     guint8        mei_code;
     guint16       reg_base=0, diagnostic_code;
     guint32       group_byte_cnt, group_word_cnt;
+
+    if (!pkt_info) {
+        return 0;
+    }
 
     switch (function_code) {
 ","{'deleted_lines': [], 'added_lines': ['', '    if (!pkt_info) {', '        return 0;', '    }']}",True,NULL pointer exception in the Modbus dissector in Wireshark 3.4.0 to 3.4.9 and 3.2.0 to 3.2.17 allows denial of service via packet injection or crafted capture file,7.5,HIGH,2,test,,5
CVE-2021-39921,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"Modbus: Add null pointer checks.

Fixes #17703.
",bb41b6619210d998f1abacc43ee20acc985249a4,https://gitlab.com/wireshark/wireshark/-/commit/bb41b6619210d998f1abacc43ee20acc985249a4,epan/dissectors/packet-mbtcp.c,dissect_modbus_response,"static int
dissect_modbus_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *modbus_tree, guint8 function_code, gint payload_start, gint payload_len, modbus_pkt_info_t *pkt_info)
{
proto_tree    *group_tree, *event_tree, *event_item_tree, *device_objects_tree, *device_objects_item_tree;
proto_item    *mei;
gint          byte_cnt, group_offset, event_index, object_index, object_len, num_objects, ii;
guint8        object_type, mei_code, event_code;
guint16       diagnostic_code, num_reg = pkt_info->num_reg;
guint32       group_byte_cnt, group_word_cnt;
nstime_t      response_time;
proto_item    *request_frame_item, *response_time_item;
if (pkt_info->request_found == TRUE) {
request_frame_item = proto_tree_add_uint(modbus_tree, hf_modbus_request_frame, tvb, 0, 0, pkt_info->req_frame_num);
proto_item_set_generated(request_frame_item);
nstime_delta(&response_time, &pinfo->abs_ts, &pkt_info->req_time);
response_time_item = proto_tree_add_time(modbus_tree, hf_modbus_response_time, tvb, 0, 0, &response_time);
proto_item_set_generated(response_time_item);
}
switch (function_code) {
case READ_COILS:
case READ_DISCRETE_INPUTS:
byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start);
proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start, 1, byte_cnt);
if (!pkt_info->request_found)
num_reg = byte_cnt*8;
dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 1, byte_cnt, pkt_info->register_format, pkt_info->reg_base, num_reg);
break;
case READ_HOLDING_REGS:
case READ_INPUT_REGS:
byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start);
proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start, 1, byte_cnt);
dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 1, byte_cnt, pkt_info->register_format, pkt_info->reg_base, 0);
break;
case WRITE_SINGLE_COIL:
proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 2, 1, pkt_info->register_format, pkt_info->reg_base, 0);
proto_tree_add_item(modbus_tree, hf_modbus_padding, tvb, payload_start + 3, 1, ENC_NA);
break;
case WRITE_SINGLE_REG:
proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 2, 2, pkt_info->register_format, pkt_info->reg_base, 0);
break;
case READ_EXCEPT_STAT:
dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start, 1, pkt_info->register_format, pkt_info->reg_base, 0);
break;
case DIAGNOSTICS:
diagnostic_code = tvb_get_ntohs(tvb, payload_start);
proto_tree_add_uint(modbus_tree, hf_modbus_diag_sf, tvb, payload_start, 2, diagnostic_code);
switch(diagnostic_code)
{
case RETURN_QUERY_DATA: 
if (payload_len > 2)
proto_tree_add_item(modbus_tree, hf_modbus_diag_return_query_data_echo, tvb, payload_start+2, payload_len-2, ENC_NA);
break;
case RESTART_COMMUNICATION_OPTION:  
proto_tree_add_item(modbus_tree, hf_modbus_diag_restart_communication_option, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
break;
case RETURN_DIAGNOSTIC_REGISTER:
proto_tree_add_item(modbus_tree, hf_modbus_diag_return_diag_register, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
break;
case CHANGE_ASCII_INPUT_DELIMITER:   
proto_tree_add_item(modbus_tree, hf_modbus_diag_ascii_input_delimiter, tvb, payload_start+2, 1, ENC_BIG_ENDIAN);
break;
case CLEAR_COUNTERS_AND_DIAG_REG:   
proto_tree_add_item(modbus_tree, hf_modbus_diag_clear_ctr_diag_reg, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
break;
case RETURN_BUS_MESSAGE_COUNT:
proto_tree_add_item(modbus_tree, hf_modbus_diag_return_bus_message_count, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
break;
case RETURN_BUS_COMM_ERROR_COUNT:
proto_tree_add_item(modbus_tree, hf_modbus_diag_return_bus_comm_error_count, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
break;
case RETURN_BUS_EXCEPTION_ERROR_COUNT:
proto_tree_add_item(modbus_tree, hf_modbus_diag_return_bus_exception_error_count, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
break;
case RETURN_SLAVE_MESSAGE_COUNT:
proto_tree_add_item(modbus_tree, hf_modbus_diag_return_slave_message_count, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
break;
case RETURN_SLAVE_NO_RESPONSE_COUNT:
proto_tree_add_item(modbus_tree, hf_modbus_diag_return_no_slave_response_count, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
break;
case RETURN_SLAVE_NAK_COUNT:
proto_tree_add_item(modbus_tree, hf_modbus_diag_return_slave_nak_count, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
break;
case RETURN_SLAVE_BUSY_COUNT:
proto_tree_add_item(modbus_tree, hf_modbus_diag_return_slave_busy_count, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
break;
case RETURN_BUS_CHAR_OVERRUN_COUNT:
proto_tree_add_item(modbus_tree, hf_modbus_diag_return_bus_char_overrun_count, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
break;
case CLEAR_OVERRUN_COUNTER_AND_FLAG:        
case FORCE_LISTEN_ONLY_MODE:                
default:
if (payload_len > 2)
dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start+2, payload_len-2, pkt_info->register_format, pkt_info->reg_base, 0);
break;
} 
break;
case GET_COMM_EVENT_CTRS:
proto_tree_add_item(modbus_tree, hf_modbus_status, tvb, payload_start, 2, ENC_BIG_ENDIAN);
proto_tree_add_item(modbus_tree, hf_modbus_event_count, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
break;
case GET_COMM_EVENT_LOG:
byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start);
proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start, 1, byte_cnt);
proto_tree_add_item(modbus_tree, hf_modbus_status, tvb, payload_start+1, 2, ENC_BIG_ENDIAN);
proto_tree_add_item(modbus_tree, hf_modbus_event_count, tvb, payload_start+3, 2, ENC_BIG_ENDIAN);
proto_tree_add_item(modbus_tree, hf_modbus_message_count, tvb, payload_start+5, 2, ENC_BIG_ENDIAN);
if (byte_cnt-6 > 0) {
byte_cnt -= 6;
event_index = 0;
event_tree = proto_tree_add_subtree(modbus_tree, tvb, payload_start+7, byte_cnt, ett_events, NULL, ""Events"");
while (byte_cnt > 0) {
event_code = tvb_get_guint8(tvb, payload_start+7+event_index);
if (event_code == 0) {
proto_tree_add_uint_format(event_tree, hf_modbus_event, tvb, payload_start+7+event_index, 1, event_code, ""Initiated Communication Restart"");
}
else if (event_code == 4) {
proto_tree_add_uint_format(event_tree, hf_modbus_event, tvb, payload_start+7+event_index, 1, event_code, ""Entered Listen Only Mode"");
}
else if (event_code & REMOTE_DEVICE_RECV_EVENT_MASK) {
mei = proto_tree_add_uint_format(event_tree, hf_modbus_event, tvb, payload_start+7+event_index, 1,
event_code, ""Receive Event: 0x%02X"", event_code);
event_item_tree = proto_item_add_subtree(mei, ett_events_recv);
proto_tree_add_item(event_item_tree, hf_modbus_event_recv_comm_err,
tvb, payload_start+7+event_index, 1, ENC_LITTLE_ENDIAN );
proto_tree_add_item(event_item_tree, hf_modbus_event_recv_char_over,
tvb, payload_start+7+event_index, 1, ENC_LITTLE_ENDIAN );
proto_tree_add_item(event_item_tree, hf_modbus_event_recv_lo_mode,
tvb, payload_start+7+event_index, 1, ENC_LITTLE_ENDIAN );
proto_tree_add_item(event_item_tree, hf_modbus_event_recv_broadcast,
tvb, payload_start+7+event_index, 1, ENC_LITTLE_ENDIAN );
}
else if ((event_code & REMOTE_DEVICE_SEND_EVENT_MASK) == REMOTE_DEVICE_SEND_EVENT_VALUE) {
mei = proto_tree_add_uint_format(event_tree, hf_modbus_event, tvb, payload_start+7+event_index, 1,
event_code, ""Send Event: 0x%02X"", event_code);
event_item_tree = proto_item_add_subtree(mei, ett_events_send);
proto_tree_add_item(event_item_tree, hf_modbus_event_send_read_ex,
tvb, payload_start+7+event_index, 1, ENC_LITTLE_ENDIAN );
proto_tree_add_item(event_item_tree, hf_modbus_event_send_slave_abort_ex,
tvb, payload_start+7+event_index, 1, ENC_LITTLE_ENDIAN );
proto_tree_add_item(event_item_tree, hf_modbus_event_send_slave_busy_ex,
tvb, payload_start+7+event_index, 1, ENC_LITTLE_ENDIAN );
proto_tree_add_item(event_item_tree, hf_modbus_event_send_slave_nak_ex,
tvb, payload_start+7+event_index, 1, ENC_LITTLE_ENDIAN );
proto_tree_add_item(event_item_tree, hf_modbus_event_send_write_timeout,
tvb, payload_start+7+event_index, 1, ENC_LITTLE_ENDIAN );
proto_tree_add_item(event_item_tree, hf_modbus_event_send_lo_mode,
tvb, payload_start+7+event_index, 1, ENC_LITTLE_ENDIAN );
}
else {
proto_tree_add_uint_format(event_tree, hf_modbus_event, tvb, payload_start+7+event_index, 1, event_code, ""Unknown Event"");
}
byte_cnt--;
event_index++;
}
}
break;
case WRITE_MULT_COILS:
proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
proto_tree_add_item(modbus_tree, hf_modbus_bitcnt, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);
break;
case WRITE_MULT_REGS:
proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
proto_tree_add_item(modbus_tree, hf_modbus_wordcnt, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);
break;
case READ_FILE_RECORD:
byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start);
proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start, 1,
byte_cnt);
group_offset = payload_start + 1;
ii = 0;
while (byte_cnt > 0) {
group_byte_cnt = (guint32)tvb_get_guint8(tvb, group_offset);
group_tree = proto_tree_add_subtree_format( modbus_tree, tvb, group_offset, group_byte_cnt + 1,
ett_group_hdr, NULL, ""Group %u"", ii);
proto_tree_add_uint(group_tree, hf_modbus_bytecnt, tvb, group_offset, 1,
group_byte_cnt);
proto_tree_add_item(group_tree, hf_modbus_reftype, tvb, group_offset + 1, 1, ENC_BIG_ENDIAN);
dissect_modbus_data(tvb, pinfo, group_tree, function_code, group_offset + 2, group_byte_cnt - 1, pkt_info->register_format, pkt_info->reg_base, 0);
group_offset += (group_byte_cnt + 1);
byte_cnt -= (group_byte_cnt + 1);
ii++;
}
break;
case WRITE_FILE_RECORD:   
byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start);
proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start, 1, byte_cnt);
group_offset = payload_start + 1;
ii = 0;
while (byte_cnt > 0) {
group_word_cnt = tvb_get_ntohs(tvb, group_offset + 5);
group_byte_cnt = (2 * group_word_cnt) + 7;
group_tree = proto_tree_add_subtree_format( modbus_tree, tvb, group_offset,
group_byte_cnt, ett_group_hdr, NULL, ""Group %u"", ii);
proto_tree_add_item(group_tree, hf_modbus_reftype, tvb, group_offset, 1, ENC_BIG_ENDIAN);
proto_tree_add_item(group_tree, hf_modbus_lreference, tvb, group_offset + 1, 4, ENC_BIG_ENDIAN);
proto_tree_add_uint(group_tree, hf_modbus_wordcnt, tvb, group_offset + 5, 2, group_word_cnt);
dissect_modbus_data(tvb, pinfo, group_tree, function_code, group_offset + 7, group_byte_cnt - 7, pkt_info->register_format, pkt_info->reg_base, 0);
group_offset += group_byte_cnt;
byte_cnt -= group_byte_cnt;
ii++;
}
break;
case MASK_WRITE_REG:      
proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
proto_tree_add_item(modbus_tree, hf_modbus_andmask, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);
proto_tree_add_item(modbus_tree, hf_modbus_ormask, tvb, payload_start + 4, 2, ENC_BIG_ENDIAN);
break;
case READ_WRITE_REG:
byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start);
proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start, 1, byte_cnt);
dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 1, byte_cnt, pkt_info->register_format, pkt_info->reg_base, 0);
break;
case READ_FIFO_QUEUE:
byte_cnt = (guint32)tvb_get_ntohs(tvb, payload_start);
proto_tree_add_uint(modbus_tree, hf_modbus_lbytecnt, tvb, payload_start, 2, byte_cnt);
proto_tree_add_item(modbus_tree, hf_modbus_wordcnt, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);
dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 4, byte_cnt - 2, pkt_info->register_format, pkt_info->reg_base, 0);
break;
case ENCAP_INTERFACE_TRANSP:
proto_tree_add_item(modbus_tree, hf_modbus_mei, tvb, payload_start, 1, ENC_BIG_ENDIAN);
mei_code = tvb_get_guint8(tvb, payload_start);
switch (mei_code)
{
case READ_DEVICE_ID:
proto_tree_add_item(modbus_tree, hf_modbus_read_device_id, tvb, payload_start+1, 1, ENC_BIG_ENDIAN);
proto_tree_add_item(modbus_tree, hf_modbus_conformity_level, tvb, payload_start+2, 1, ENC_BIG_ENDIAN);
proto_tree_add_item(modbus_tree, hf_modbus_more_follows, tvb, payload_start+3, 1, ENC_BIG_ENDIAN);
proto_tree_add_item(modbus_tree, hf_modbus_next_object_id, tvb, payload_start+4, 1, ENC_BIG_ENDIAN);
num_objects = tvb_get_guint8(tvb, payload_start+5);
proto_tree_add_uint(modbus_tree, hf_modbus_num_objects, tvb, payload_start+5, 1, num_objects);
device_objects_tree = proto_tree_add_subtree(modbus_tree, tvb, payload_start+6, payload_len-6,
ett_device_id_objects, NULL, ""Objects"");
object_index = 0;
for (ii = 0; ii < num_objects; ii++)
{
object_type = tvb_get_guint8(tvb, payload_start+6+object_index);
object_len = tvb_get_guint8(tvb, payload_start+6+object_index+1);
device_objects_item_tree = proto_tree_add_subtree_format(device_objects_tree, tvb, payload_start+6+object_index, 2+object_len,
ett_device_id_object_items, NULL, ""Object #%d"", ii+1);
proto_tree_add_item(device_objects_item_tree, hf_modbus_object_id, tvb, payload_start+6+object_index, 1, ENC_BIG_ENDIAN);
object_index++;
proto_tree_add_uint(device_objects_item_tree, hf_modbus_list_object_len, tvb, payload_start+6+object_index, 1, object_len);
object_index++;
if (object_type < 7)
{
proto_tree_add_item(device_objects_item_tree, hf_modbus_object_str_value, tvb, payload_start+6+object_index, object_len, ENC_ASCII|ENC_NA);
}
else
{
if (object_len > 0)
proto_tree_add_item(device_objects_item_tree, hf_modbus_object_value, tvb, payload_start+6+object_index, object_len, ENC_NA);
}
object_index += object_len;
} 
break;
case CANOPEN_REQ_RESP:
default:
if (payload_len > 1)
dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len-1, pkt_info->register_format, pkt_info->reg_base, 0);
break;
} 
break;
case REPORT_SLAVE_ID:
default:
if (payload_len > 0)
dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len, pkt_info->register_format, pkt_info->reg_base, 0);
break;
} 
return tvb_captured_length(tvb);
}","static int
dissect_modbus_response(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, guint8 VAR_3, gint VAR_4, gint VAR_5, modbus_pkt_info_t *VAR_6)
{
proto_tree    *VAR_7, *VAR_8, *VAR_9, *VAR_10, *VAR_11;
proto_item    *VAR_12;
gint          VAR_13, VAR_14, VAR_15, VAR_16, VAR_17, VAR_18, VAR_19;
guint8        VAR_20, VAR_21, VAR_22;
guint16       VAR_23, VAR_24 = VAR_6->num_reg;
guint32       VAR_25, VAR_26;
nstime_t      VAR_27;
proto_item    *VAR_28, *VAR_29;
if (VAR_6->request_found == TRUE) {
VAR_28 = proto_tree_add_uint(VAR_2, VAR_30, VAR_0, 0, 0, VAR_6->req_frame_num);
proto_item_set_generated(VAR_28);
nstime_delta(&VAR_27, &VAR_1->abs_ts, &VAR_6->req_time);
VAR_29 = proto_tree_add_time(VAR_2, VAR_31, VAR_0, 0, 0, &VAR_27);
proto_item_set_generated(VAR_29);
}
switch (VAR_3) {
case VAR_32:
case VAR_33:
VAR_13 = (guint32)tvb_get_guint8(VAR_0, VAR_4);
proto_tree_add_uint(VAR_2, VAR_34, VAR_0, VAR_4, 1, VAR_13);
if (!VAR_6->request_found)
VAR_24 = VAR_13*8;
dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 1, VAR_13, VAR_6->register_format, VAR_6->reg_base, VAR_24);
break;
case VAR_35:
case VAR_36:
VAR_13 = (guint32)tvb_get_guint8(VAR_0, VAR_4);
proto_tree_add_uint(VAR_2, VAR_34, VAR_0, VAR_4, 1, VAR_13);
dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 1, VAR_13, VAR_6->register_format, VAR_6->reg_base, 0);
break;
case VAR_37:
proto_tree_add_item(VAR_2, VAR_38, VAR_0, VAR_4, 2, VAR_39);
dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 2, 1, VAR_6->register_format, VAR_6->reg_base, 0);
proto_tree_add_item(VAR_2, VAR_40, VAR_0, VAR_4 + 3, 1, VAR_41);
break;
case VAR_42:
proto_tree_add_item(VAR_2, VAR_38, VAR_0, VAR_4, 2, VAR_39);
dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 2, 2, VAR_6->register_format, VAR_6->reg_base, 0);
break;
case VAR_43:
dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4, 1, VAR_6->register_format, VAR_6->reg_base, 0);
break;
case VAR_44:
VAR_23 = tvb_get_ntohs(VAR_0, VAR_4);
proto_tree_add_uint(VAR_2, VAR_45, VAR_0, VAR_4, 2, VAR_23);
switch(VAR_23)
{
case VAR_46: 
if (VAR_5 > 2)
proto_tree_add_item(VAR_2, VAR_47, VAR_0, VAR_4+2, VAR_5-2, VAR_41);
break;
case VAR_48:  
proto_tree_add_item(VAR_2, VAR_49, VAR_0, VAR_4+2, 2, VAR_39);
break;
case VAR_50:
proto_tree_add_item(VAR_2, VAR_51, VAR_0, VAR_4+2, 2, VAR_39);
break;
case VAR_52:   
proto_tree_add_item(VAR_2, VAR_53, VAR_0, VAR_4+2, 1, VAR_39);
break;
case VAR_54:   
proto_tree_add_item(VAR_2, VAR_55, VAR_0, VAR_4+2, 2, VAR_39);
break;
case VAR_56:
proto_tree_add_item(VAR_2, VAR_57, VAR_0, VAR_4+2, 2, VAR_39);
break;
case VAR_58:
proto_tree_add_item(VAR_2, VAR_59, VAR_0, VAR_4+2, 2, VAR_39);
break;
case VAR_60:
proto_tree_add_item(VAR_2, VAR_61, VAR_0, VAR_4+2, 2, VAR_39);
break;
case VAR_62:
proto_tree_add_item(VAR_2, VAR_63, VAR_0, VAR_4+2, 2, VAR_39);
break;
case VAR_64:
proto_tree_add_item(VAR_2, VAR_65, VAR_0, VAR_4+2, 2, VAR_39);
break;
case VAR_66:
proto_tree_add_item(VAR_2, VAR_67, VAR_0, VAR_4+2, 2, VAR_39);
break;
case VAR_68:
proto_tree_add_item(VAR_2, VAR_69, VAR_0, VAR_4+2, 2, VAR_39);
break;
case VAR_70:
proto_tree_add_item(VAR_2, VAR_71, VAR_0, VAR_4+2, 2, VAR_39);
break;
case VAR_72:        
case VAR_73:                
default:
if (VAR_5 > 2)
dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4+2, VAR_5-2, VAR_6->register_format, VAR_6->reg_base, 0);
break;
} 
break;
case VAR_74:
proto_tree_add_item(VAR_2, VAR_75, VAR_0, VAR_4, 2, VAR_39);
proto_tree_add_item(VAR_2, VAR_76, VAR_0, VAR_4+2, 2, VAR_39);
break;
case VAR_77:
VAR_13 = (guint32)tvb_get_guint8(VAR_0, VAR_4);
proto_tree_add_uint(VAR_2, VAR_34, VAR_0, VAR_4, 1, VAR_13);
proto_tree_add_item(VAR_2, VAR_75, VAR_0, VAR_4+1, 2, VAR_39);
proto_tree_add_item(VAR_2, VAR_76, VAR_0, VAR_4+3, 2, VAR_39);
proto_tree_add_item(VAR_2, VAR_78, VAR_0, VAR_4+5, 2, VAR_39);
if (VAR_13-6 > 0) {
VAR_13 -= 6;
VAR_15 = 0;
VAR_8 = proto_tree_add_subtree(VAR_2, VAR_0, VAR_4+7, VAR_13, VAR_79, NULL, ""Events"");
while (VAR_13 > 0) {
VAR_22 = tvb_get_guint8(VAR_0, VAR_4+7+VAR_15);
if (VAR_22 == 0) {
proto_tree_add_uint_format(VAR_8, VAR_80, VAR_0, VAR_4+7+VAR_15, 1, VAR_22, ""Initiated Communication Restart"");
}
else if (VAR_22 == 4) {
proto_tree_add_uint_format(VAR_8, VAR_80, VAR_0, VAR_4+7+VAR_15, 1, VAR_22, ""Entered Listen Only Mode"");
}
else if (VAR_22 & VAR_81) {
VAR_12 = proto_tree_add_uint_format(VAR_8, VAR_80, VAR_0, VAR_4+7+VAR_15, 1,
VAR_22, ""Receive Event: 0x%02X"", VAR_22);
VAR_9 = proto_item_add_subtree(VAR_12, VAR_82);
proto_tree_add_item(VAR_9, VAR_83,
VAR_0, VAR_4+7+VAR_15, 1, VAR_84 );
proto_tree_add_item(VAR_9, VAR_85,
VAR_0, VAR_4+7+VAR_15, 1, VAR_84 );
proto_tree_add_item(VAR_9, VAR_86,
VAR_0, VAR_4+7+VAR_15, 1, VAR_84 );
proto_tree_add_item(VAR_9, VAR_87,
VAR_0, VAR_4+7+VAR_15, 1, VAR_84 );
}
else if ((VAR_22 & VAR_88) == VAR_89) {
VAR_12 = proto_tree_add_uint_format(VAR_8, VAR_80, VAR_0, VAR_4+7+VAR_15, 1,
VAR_22, ""Send Event: 0x%02X"", VAR_22);
VAR_9 = proto_item_add_subtree(VAR_12, VAR_90);
proto_tree_add_item(VAR_9, VAR_91,
VAR_0, VAR_4+7+VAR_15, 1, VAR_84 );
proto_tree_add_item(VAR_9, VAR_92,
VAR_0, VAR_4+7+VAR_15, 1, VAR_84 );
proto_tree_add_item(VAR_9, VAR_93,
VAR_0, VAR_4+7+VAR_15, 1, VAR_84 );
proto_tree_add_item(VAR_9, VAR_94,
VAR_0, VAR_4+7+VAR_15, 1, VAR_84 );
proto_tree_add_item(VAR_9, VAR_95,
VAR_0, VAR_4+7+VAR_15, 1, VAR_84 );
proto_tree_add_item(VAR_9, VAR_96,
VAR_0, VAR_4+7+VAR_15, 1, VAR_84 );
}
else {
proto_tree_add_uint_format(VAR_8, VAR_80, VAR_0, VAR_4+7+VAR_15, 1, VAR_22, ""Unknown Event"");
}
VAR_13--;
VAR_15++;
}
}
break;
case VAR_97:
proto_tree_add_item(VAR_2, VAR_38, VAR_0, VAR_4, 2, VAR_39);
proto_tree_add_item(VAR_2, VAR_98, VAR_0, VAR_4 + 2, 2, VAR_39);
break;
case VAR_99:
proto_tree_add_item(VAR_2, VAR_38, VAR_0, VAR_4, 2, VAR_39);
proto_tree_add_item(VAR_2, VAR_100, VAR_0, VAR_4 + 2, 2, VAR_39);
break;
case VAR_101:
VAR_13 = (guint32)tvb_get_guint8(VAR_0, VAR_4);
proto_tree_add_uint(VAR_2, VAR_34, VAR_0, VAR_4, 1,
VAR_13);
VAR_14 = VAR_4 + 1;
VAR_19 = 0;
while (VAR_13 > 0) {
VAR_25 = (guint32)tvb_get_guint8(VAR_0, VAR_14);
VAR_7 = proto_tree_add_subtree_format( VAR_2, VAR_0, VAR_14, VAR_25 + 1,
VAR_102, NULL, ""Group %u"", VAR_19);
proto_tree_add_uint(VAR_7, VAR_34, VAR_0, VAR_14, 1,
VAR_25);
proto_tree_add_item(VAR_7, VAR_103, VAR_0, VAR_14 + 1, 1, VAR_39);
dissect_modbus_data(VAR_0, VAR_1, VAR_7, VAR_3, VAR_14 + 2, VAR_25 - 1, VAR_6->register_format, VAR_6->reg_base, 0);
VAR_14 += (VAR_25 + 1);
VAR_13 -= (VAR_25 + 1);
VAR_19++;
}
break;
case VAR_104:   
VAR_13 = (guint32)tvb_get_guint8(VAR_0, VAR_4);
proto_tree_add_uint(VAR_2, VAR_34, VAR_0, VAR_4, 1, VAR_13);
VAR_14 = VAR_4 + 1;
VAR_19 = 0;
while (VAR_13 > 0) {
VAR_26 = tvb_get_ntohs(VAR_0, VAR_14 + 5);
VAR_25 = (2 * VAR_26) + 7;
VAR_7 = proto_tree_add_subtree_format( VAR_2, VAR_0, VAR_14,
VAR_25, VAR_102, NULL, ""Group %u"", VAR_19);
proto_tree_add_item(VAR_7, VAR_103, VAR_0, VAR_14, 1, VAR_39);
proto_tree_add_item(VAR_7, VAR_105, VAR_0, VAR_14 + 1, 4, VAR_39);
proto_tree_add_uint(VAR_7, VAR_100, VAR_0, VAR_14 + 5, 2, VAR_26);
dissect_modbus_data(VAR_0, VAR_1, VAR_7, VAR_3, VAR_14 + 7, VAR_25 - 7, VAR_6->register_format, VAR_6->reg_base, 0);
VAR_14 += VAR_25;
VAR_13 -= VAR_25;
VAR_19++;
}
break;
case VAR_106:      
proto_tree_add_item(VAR_2, VAR_38, VAR_0, VAR_4, 2, VAR_39);
proto_tree_add_item(VAR_2, VAR_107, VAR_0, VAR_4 + 2, 2, VAR_39);
proto_tree_add_item(VAR_2, VAR_108, VAR_0, VAR_4 + 4, 2, VAR_39);
break;
case VAR_109:
VAR_13 = (guint32)tvb_get_guint8(VAR_0, VAR_4);
proto_tree_add_uint(VAR_2, VAR_34, VAR_0, VAR_4, 1, VAR_13);
dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 1, VAR_13, VAR_6->register_format, VAR_6->reg_base, 0);
break;
case VAR_110:
VAR_13 = (guint32)tvb_get_ntohs(VAR_0, VAR_4);
proto_tree_add_uint(VAR_2, VAR_111, VAR_0, VAR_4, 2, VAR_13);
proto_tree_add_item(VAR_2, VAR_100, VAR_0, VAR_4 + 2, 2, VAR_39);
dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 4, VAR_13 - 2, VAR_6->register_format, VAR_6->reg_base, 0);
break;
case VAR_112:
proto_tree_add_item(VAR_2, VAR_113, VAR_0, VAR_4, 1, VAR_39);
VAR_21 = tvb_get_guint8(VAR_0, VAR_4);
switch (VAR_21)
{
case VAR_114:
proto_tree_add_item(VAR_2, VAR_115, VAR_0, VAR_4+1, 1, VAR_39);
proto_tree_add_item(VAR_2, VAR_116, VAR_0, VAR_4+2, 1, VAR_39);
proto_tree_add_item(VAR_2, VAR_117, VAR_0, VAR_4+3, 1, VAR_39);
proto_tree_add_item(VAR_2, VAR_118, VAR_0, VAR_4+4, 1, VAR_39);
VAR_18 = tvb_get_guint8(VAR_0, VAR_4+5);
proto_tree_add_uint(VAR_2, VAR_119, VAR_0, VAR_4+5, 1, VAR_18);
VAR_10 = proto_tree_add_subtree(VAR_2, VAR_0, VAR_4+6, VAR_5-6,
VAR_120, NULL, ""Objects"");
VAR_16 = 0;
for (VAR_19 = 0; VAR_19 < VAR_18; VAR_19++)
{
VAR_20 = tvb_get_guint8(VAR_0, VAR_4+6+VAR_16);
VAR_17 = tvb_get_guint8(VAR_0, VAR_4+6+VAR_16+1);
VAR_11 = proto_tree_add_subtree_format(VAR_10, VAR_0, VAR_4+6+VAR_16, 2+VAR_17,
VAR_121, NULL, ""Object #%d"", VAR_19+1);
proto_tree_add_item(VAR_11, VAR_122, VAR_0, VAR_4+6+VAR_16, 1, VAR_39);
VAR_16++;
proto_tree_add_uint(VAR_11, VAR_123, VAR_0, VAR_4+6+VAR_16, 1, VAR_17);
VAR_16++;
if (VAR_20 < 7)
{
proto_tree_add_item(VAR_11, VAR_124, VAR_0, VAR_4+6+VAR_16, VAR_17, VAR_125|VAR_41);
}
else
{
if (VAR_17 > 0)
proto_tree_add_item(VAR_11, VAR_126, VAR_0, VAR_4+6+VAR_16, VAR_17, VAR_41);
}
VAR_16 += VAR_17;
} 
break;
case VAR_127:
default:
if (VAR_5 > 1)
dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5-1, VAR_6->register_format, VAR_6->reg_base, 0);
break;
} 
break;
case VAR_128:
default:
if (VAR_5 > 0)
dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6->register_format, VAR_6->reg_base, 0);
break;
} 
return tvb_captured_length(VAR_0);
}",wireshark/bb41b6619210d998f1abacc43ee20acc985249a4/packet-mbtcp.c/vul/before/1.json,"static int
dissect_modbus_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *modbus_tree, guint8 function_code, gint payload_start, gint payload_len, modbus_pkt_info_t *pkt_info)
{

    proto_tree    *group_tree, *event_tree, *event_item_tree, *device_objects_tree, *device_objects_item_tree;
    proto_item    *mei;
    gint          byte_cnt, group_offset, event_index, object_index, object_len, num_objects, ii;
    guint8        object_type, mei_code, event_code;
    guint16       diagnostic_code, num_reg;
    guint32       group_byte_cnt, group_word_cnt;

    nstime_t      response_time;
    proto_item    *request_frame_item, *response_time_item;

    if (!pkt_info) {
        return 0;
    }

    num_reg = pkt_info->num_reg;

    if (pkt_info->request_found == TRUE) {
        request_frame_item = proto_tree_add_uint(modbus_tree, hf_modbus_request_frame, tvb, 0, 0, pkt_info->req_frame_num);
        proto_item_set_generated(request_frame_item);

        nstime_delta(&response_time, &pinfo->abs_ts, &pkt_info->req_time);
        response_time_item = proto_tree_add_time(modbus_tree, hf_modbus_response_time, tvb, 0, 0, &response_time);
        proto_item_set_generated(response_time_item);
    }

    switch (function_code) {

        case READ_COILS:
        case READ_DISCRETE_INPUTS:
            byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start);
            proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start, 1, byte_cnt);
            //if the request wasn't found set number of coils based on byte count
            if (!pkt_info->request_found)
                num_reg = byte_cnt*8;
            dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 1, byte_cnt, pkt_info->register_format, pkt_info->reg_base, num_reg);
            break;

        case READ_HOLDING_REGS:
        case READ_INPUT_REGS:
            byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start);
            proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start, 1, byte_cnt);
            dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 1, byte_cnt, pkt_info->register_format, pkt_info->reg_base, 0);
            break;

        case WRITE_SINGLE_COIL:
            proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
            dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 2, 1, pkt_info->register_format, pkt_info->reg_base, 0);
            proto_tree_add_item(modbus_tree, hf_modbus_padding, tvb, payload_start + 3, 1, ENC_NA);
            break;

        case WRITE_SINGLE_REG:
            proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
            dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 2, 2, pkt_info->register_format, pkt_info->reg_base, 0);
            break;

        case READ_EXCEPT_STAT:
            dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start, 1, pkt_info->register_format, pkt_info->reg_base, 0);
            break;

        case DIAGNOSTICS:
            diagnostic_code = tvb_get_ntohs(tvb, payload_start);
            proto_tree_add_uint(modbus_tree, hf_modbus_diag_sf, tvb, payload_start, 2, diagnostic_code);
            switch(diagnostic_code)
            {
                case RETURN_QUERY_DATA: /* Echo of Request */
                    if (payload_len > 2)
                        proto_tree_add_item(modbus_tree, hf_modbus_diag_return_query_data_echo, tvb, payload_start+2, payload_len-2, ENC_NA);
                    break;
                case RESTART_COMMUNICATION_OPTION:  /* Echo of Request */
                    proto_tree_add_item(modbus_tree, hf_modbus_diag_restart_communication_option, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
                    break;
                case RETURN_DIAGNOSTIC_REGISTER:
                    proto_tree_add_item(modbus_tree, hf_modbus_diag_return_diag_register, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
                    break;
                case CHANGE_ASCII_INPUT_DELIMITER:   /* XXX - Do we expect this to ever be a response? */
                    proto_tree_add_item(modbus_tree, hf_modbus_diag_ascii_input_delimiter, tvb, payload_start+2, 1, ENC_BIG_ENDIAN);
                    break;
                case CLEAR_COUNTERS_AND_DIAG_REG:   /* Echo of Request */
                    proto_tree_add_item(modbus_tree, hf_modbus_diag_clear_ctr_diag_reg, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
                    break;
                case RETURN_BUS_MESSAGE_COUNT:
                    proto_tree_add_item(modbus_tree, hf_modbus_diag_return_bus_message_count, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
                    break;
                case RETURN_BUS_COMM_ERROR_COUNT:
                    proto_tree_add_item(modbus_tree, hf_modbus_diag_return_bus_comm_error_count, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
                    break;
                case RETURN_BUS_EXCEPTION_ERROR_COUNT:
                    proto_tree_add_item(modbus_tree, hf_modbus_diag_return_bus_exception_error_count, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
                    break;
                case RETURN_SLAVE_MESSAGE_COUNT:
                    proto_tree_add_item(modbus_tree, hf_modbus_diag_return_slave_message_count, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
                    break;
                case RETURN_SLAVE_NO_RESPONSE_COUNT:
                    proto_tree_add_item(modbus_tree, hf_modbus_diag_return_no_slave_response_count, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
                    break;
                case RETURN_SLAVE_NAK_COUNT:
                    proto_tree_add_item(modbus_tree, hf_modbus_diag_return_slave_nak_count, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
                    break;
                case RETURN_SLAVE_BUSY_COUNT:
                    proto_tree_add_item(modbus_tree, hf_modbus_diag_return_slave_busy_count, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
                    break;
                case RETURN_BUS_CHAR_OVERRUN_COUNT:
                    proto_tree_add_item(modbus_tree, hf_modbus_diag_return_bus_char_overrun_count, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
                    break;
                case CLEAR_OVERRUN_COUNTER_AND_FLAG:        /* Echo of Request */
                case FORCE_LISTEN_ONLY_MODE:                /* No response anticipated */
                default:
                    if (payload_len > 2)
                        dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start+2, payload_len-2, pkt_info->register_format, pkt_info->reg_base, 0);
                    break;
            } /* diagnostic_code */
            break;

        case GET_COMM_EVENT_CTRS:
            proto_tree_add_item(modbus_tree, hf_modbus_status, tvb, payload_start, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(modbus_tree, hf_modbus_event_count, tvb, payload_start+2, 2, ENC_BIG_ENDIAN);
            break;

        case GET_COMM_EVENT_LOG:
            byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start);
            proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start, 1, byte_cnt);
            proto_tree_add_item(modbus_tree, hf_modbus_status, tvb, payload_start+1, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(modbus_tree, hf_modbus_event_count, tvb, payload_start+3, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(modbus_tree, hf_modbus_message_count, tvb, payload_start+5, 2, ENC_BIG_ENDIAN);
            if (byte_cnt-6 > 0) {
                byte_cnt -= 6;
                event_index = 0;
                event_tree = proto_tree_add_subtree(modbus_tree, tvb, payload_start+7, byte_cnt, ett_events, NULL, ""Events"");
                while (byte_cnt > 0) {
                    event_code = tvb_get_guint8(tvb, payload_start+7+event_index);
                    if (event_code == 0) {
                        proto_tree_add_uint_format(event_tree, hf_modbus_event, tvb, payload_start+7+event_index, 1, event_code, ""Initiated Communication Restart"");
                    }
                    else if (event_code == 4) {
                        proto_tree_add_uint_format(event_tree, hf_modbus_event, tvb, payload_start+7+event_index, 1, event_code, ""Entered Listen Only Mode"");
                    }
                    else if (event_code & REMOTE_DEVICE_RECV_EVENT_MASK) {
                        mei = proto_tree_add_uint_format(event_tree, hf_modbus_event, tvb, payload_start+7+event_index, 1,
                                    event_code, ""Receive Event: 0x%02X"", event_code);
                        event_item_tree = proto_item_add_subtree(mei, ett_events_recv);

                        /* add subtrees to describe each event bit */
                        proto_tree_add_item(event_item_tree, hf_modbus_event_recv_comm_err,
                          tvb, payload_start+7+event_index, 1, ENC_LITTLE_ENDIAN );
                        proto_tree_add_item(event_item_tree, hf_modbus_event_recv_char_over,
                          tvb, payload_start+7+event_index, 1, ENC_LITTLE_ENDIAN );
                        proto_tree_add_item(event_item_tree, hf_modbus_event_recv_lo_mode,
                          tvb, payload_start+7+event_index, 1, ENC_LITTLE_ENDIAN );
                        proto_tree_add_item(event_item_tree, hf_modbus_event_recv_broadcast,
                          tvb, payload_start+7+event_index, 1, ENC_LITTLE_ENDIAN );
                    }
                    else if ((event_code & REMOTE_DEVICE_SEND_EVENT_MASK) == REMOTE_DEVICE_SEND_EVENT_VALUE) {
                        mei = proto_tree_add_uint_format(event_tree, hf_modbus_event, tvb, payload_start+7+event_index, 1,
                                    event_code, ""Send Event: 0x%02X"", event_code);
                        event_item_tree = proto_item_add_subtree(mei, ett_events_send);

                        /* add subtrees to describe each event bit */
                        proto_tree_add_item(event_item_tree, hf_modbus_event_send_read_ex,
                          tvb, payload_start+7+event_index, 1, ENC_LITTLE_ENDIAN );
                        proto_tree_add_item(event_item_tree, hf_modbus_event_send_slave_abort_ex,
                          tvb, payload_start+7+event_index, 1, ENC_LITTLE_ENDIAN );
                        proto_tree_add_item(event_item_tree, hf_modbus_event_send_slave_busy_ex,
                          tvb, payload_start+7+event_index, 1, ENC_LITTLE_ENDIAN );
                        proto_tree_add_item(event_item_tree, hf_modbus_event_send_slave_nak_ex,
                          tvb, payload_start+7+event_index, 1, ENC_LITTLE_ENDIAN );
                        proto_tree_add_item(event_item_tree, hf_modbus_event_send_write_timeout,
                          tvb, payload_start+7+event_index, 1, ENC_LITTLE_ENDIAN );
                        proto_tree_add_item(event_item_tree, hf_modbus_event_send_lo_mode,
                          tvb, payload_start+7+event_index, 1, ENC_LITTLE_ENDIAN );
                    }
                    else {
                        proto_tree_add_uint_format(event_tree, hf_modbus_event, tvb, payload_start+7+event_index, 1, event_code, ""Unknown Event"");
                    }

                    byte_cnt--;
                    event_index++;
                }
            }
            break;

        case WRITE_MULT_COILS:
            proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(modbus_tree, hf_modbus_bitcnt, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);
            break;

        case WRITE_MULT_REGS:
            proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(modbus_tree, hf_modbus_wordcnt, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);
            break;

        case READ_FILE_RECORD:
            byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start);
            proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start, 1,
                    byte_cnt);

            /* add subtrees to describe each group of packet */
            group_offset = payload_start + 1;
            ii = 0;
            while (byte_cnt > 0) {
                group_byte_cnt = (guint32)tvb_get_guint8(tvb, group_offset);
                group_tree = proto_tree_add_subtree_format( modbus_tree, tvb, group_offset, group_byte_cnt + 1,
                        ett_group_hdr, NULL, ""Group %u"", ii);
                proto_tree_add_uint(group_tree, hf_modbus_bytecnt, tvb, group_offset, 1,
                        group_byte_cnt);
                proto_tree_add_item(group_tree, hf_modbus_reftype, tvb, group_offset + 1, 1, ENC_BIG_ENDIAN);
                dissect_modbus_data(tvb, pinfo, group_tree, function_code, group_offset + 2, group_byte_cnt - 1, pkt_info->register_format, pkt_info->reg_base, 0);
                group_offset += (group_byte_cnt + 1);
                byte_cnt -= (group_byte_cnt + 1);
                ii++;
            }
            break;

        case WRITE_FILE_RECORD:   /* Normal response is echo of request */
            byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start);
            proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start, 1, byte_cnt);

            /* add subtrees to describe each group of packet */
            group_offset = payload_start + 1;
            ii = 0;
            while (byte_cnt > 0) {
                group_word_cnt = tvb_get_ntohs(tvb, group_offset + 5);
                group_byte_cnt = (2 * group_word_cnt) + 7;
                group_tree = proto_tree_add_subtree_format( modbus_tree, tvb, group_offset,
                        group_byte_cnt, ett_group_hdr, NULL, ""Group %u"", ii);
                proto_tree_add_item(group_tree, hf_modbus_reftype, tvb, group_offset, 1, ENC_BIG_ENDIAN);
                proto_tree_add_item(group_tree, hf_modbus_lreference, tvb, group_offset + 1, 4, ENC_BIG_ENDIAN);
                proto_tree_add_uint(group_tree, hf_modbus_wordcnt, tvb, group_offset + 5, 2, group_word_cnt);
                dissect_modbus_data(tvb, pinfo, group_tree, function_code, group_offset + 7, group_byte_cnt - 7, pkt_info->register_format, pkt_info->reg_base, 0);
                group_offset += group_byte_cnt;
                byte_cnt -= group_byte_cnt;
                ii++;
            }
            break;

        case MASK_WRITE_REG:      /* Normal response is echo of request */
            proto_tree_add_item(modbus_tree, hf_modbus_reference, tvb, payload_start, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(modbus_tree, hf_modbus_andmask, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(modbus_tree, hf_modbus_ormask, tvb, payload_start + 4, 2, ENC_BIG_ENDIAN);
            break;

        case READ_WRITE_REG:
            byte_cnt = (guint32)tvb_get_guint8(tvb, payload_start);
            proto_tree_add_uint(modbus_tree, hf_modbus_bytecnt, tvb, payload_start, 1, byte_cnt);
            dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 1, byte_cnt, pkt_info->register_format, pkt_info->reg_base, 0);
            break;

        case READ_FIFO_QUEUE:
            byte_cnt = (guint32)tvb_get_ntohs(tvb, payload_start);
            proto_tree_add_uint(modbus_tree, hf_modbus_lbytecnt, tvb, payload_start, 2, byte_cnt);
            proto_tree_add_item(modbus_tree, hf_modbus_wordcnt, tvb, payload_start + 2, 2, ENC_BIG_ENDIAN);
            dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start + 4, byte_cnt - 2, pkt_info->register_format, pkt_info->reg_base, 0);
            break;

        case ENCAP_INTERFACE_TRANSP:
            proto_tree_add_item(modbus_tree, hf_modbus_mei, tvb, payload_start, 1, ENC_BIG_ENDIAN);
            mei_code = tvb_get_guint8(tvb, payload_start);
            switch (mei_code)
            {
                case READ_DEVICE_ID:
                    proto_tree_add_item(modbus_tree, hf_modbus_read_device_id, tvb, payload_start+1, 1, ENC_BIG_ENDIAN);
                    proto_tree_add_item(modbus_tree, hf_modbus_conformity_level, tvb, payload_start+2, 1, ENC_BIG_ENDIAN);
                    proto_tree_add_item(modbus_tree, hf_modbus_more_follows, tvb, payload_start+3, 1, ENC_BIG_ENDIAN);
                    proto_tree_add_item(modbus_tree, hf_modbus_next_object_id, tvb, payload_start+4, 1, ENC_BIG_ENDIAN);
                    num_objects = tvb_get_guint8(tvb, payload_start+5);
                    proto_tree_add_uint(modbus_tree, hf_modbus_num_objects, tvb, payload_start+5, 1, num_objects);
                    device_objects_tree = proto_tree_add_subtree(modbus_tree, tvb, payload_start+6, payload_len-6,
                                                                    ett_device_id_objects, NULL, ""Objects"");

                    object_index = 0;
                    for (ii = 0; ii < num_objects; ii++)
                    {
                        /* add each ""object item"" as its own subtree */

                        /* compute length of object */
                        object_type = tvb_get_guint8(tvb, payload_start+6+object_index);
                        object_len = tvb_get_guint8(tvb, payload_start+6+object_index+1);

                        device_objects_item_tree = proto_tree_add_subtree_format(device_objects_tree, tvb, payload_start+6+object_index, 2+object_len,
                                                    ett_device_id_object_items, NULL, ""Object #%d"", ii+1);

                        proto_tree_add_item(device_objects_item_tree, hf_modbus_object_id, tvb, payload_start+6+object_index, 1, ENC_BIG_ENDIAN);
                        object_index++;

                        proto_tree_add_uint(device_objects_item_tree, hf_modbus_list_object_len, tvb, payload_start+6+object_index, 1, object_len);
                        object_index++;

                        if (object_type < 7)
                        {
                            proto_tree_add_item(device_objects_item_tree, hf_modbus_object_str_value, tvb, payload_start+6+object_index, object_len, ENC_ASCII|ENC_NA);
                        }
                        else
                        {
                            if (object_len > 0)
                                proto_tree_add_item(device_objects_item_tree, hf_modbus_object_value, tvb, payload_start+6+object_index, object_len, ENC_NA);
                        }
                        object_index += object_len;
                    } /* for ii */
                    break;

                case CANOPEN_REQ_RESP:
                    /* CANopen protocol not part of the Modbus/TCP specification */
                default:
                    if (payload_len > 1)
                        dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len-1, pkt_info->register_format, pkt_info->reg_base, 0);
                    break;
            } /* mei_code */
            break;

        case REPORT_SLAVE_ID:
        default:
            if (payload_len > 0)
                dissect_modbus_data(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len, pkt_info->register_format, pkt_info->reg_base, 0);
            break;

    } /* function code */

    return tvb_captured_length(tvb);
}","static int
dissect_modbus_response(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, guint8 VAR_3, gint VAR_4, gint VAR_5, modbus_pkt_info_t *VAR_6)
{

    proto_tree    *VAR_7, *VAR_8, *VAR_9, *VAR_10, *VAR_11;
    proto_item    *VAR_12;
    gint          VAR_13, VAR_14, VAR_15, VAR_16, VAR_17, VAR_18, VAR_19;
    guint8        VAR_20, VAR_21, VAR_22;
    guint16       VAR_23, VAR_24;
    guint32       VAR_25, VAR_26;

    nstime_t      VAR_27;
    proto_item    *VAR_28, *VAR_29;

    if (!VAR_6) {
        return 0;
    }

    VAR_24 = VAR_6->num_reg;

    if (VAR_6->request_found == TRUE) {
        VAR_28 = proto_tree_add_uint(VAR_2, VAR_30, VAR_0, 0, 0, VAR_6->req_frame_num);
        proto_item_set_generated(VAR_28);

        nstime_delta(&VAR_27, &VAR_1->abs_ts, &VAR_6->req_time);
        VAR_29 = proto_tree_add_time(VAR_2, VAR_31, VAR_0, 0, 0, &VAR_27);
        proto_item_set_generated(VAR_29);
    }

    switch (VAR_3) {

        case VAR_32:
        case VAR_33:
            VAR_13 = (guint32)tvb_get_guint8(VAR_0, VAR_4);
            proto_tree_add_uint(VAR_2, VAR_34, VAR_0, VAR_4, 1, VAR_13);
            /* COMMENT_0 */
            if (!VAR_6->request_found)
                VAR_24 = VAR_13*8;
            dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 1, VAR_13, VAR_6->register_format, VAR_6->reg_base, VAR_24);
            break;

        case VAR_35:
        case VAR_36:
            VAR_13 = (guint32)tvb_get_guint8(VAR_0, VAR_4);
            proto_tree_add_uint(VAR_2, VAR_34, VAR_0, VAR_4, 1, VAR_13);
            dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 1, VAR_13, VAR_6->register_format, VAR_6->reg_base, 0);
            break;

        case VAR_37:
            proto_tree_add_item(VAR_2, VAR_38, VAR_0, VAR_4, 2, VAR_39);
            dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 2, 1, VAR_6->register_format, VAR_6->reg_base, 0);
            proto_tree_add_item(VAR_2, VAR_40, VAR_0, VAR_4 + 3, 1, VAR_41);
            break;

        case VAR_42:
            proto_tree_add_item(VAR_2, VAR_38, VAR_0, VAR_4, 2, VAR_39);
            dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 2, 2, VAR_6->register_format, VAR_6->reg_base, 0);
            break;

        case VAR_43:
            dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4, 1, VAR_6->register_format, VAR_6->reg_base, 0);
            break;

        case VAR_44:
            VAR_23 = tvb_get_ntohs(VAR_0, VAR_4);
            proto_tree_add_uint(VAR_2, VAR_45, VAR_0, VAR_4, 2, VAR_23);
            switch(VAR_23)
            {
                case VAR_46: /* COMMENT_1 */
                    if (VAR_5 > 2)
                        proto_tree_add_item(VAR_2, VAR_47, VAR_0, VAR_4+2, VAR_5-2, VAR_41);
                    break;
                case VAR_48:  /* COMMENT_1 */
                    proto_tree_add_item(VAR_2, VAR_49, VAR_0, VAR_4+2, 2, VAR_39);
                    break;
                case VAR_50:
                    proto_tree_add_item(VAR_2, VAR_51, VAR_0, VAR_4+2, 2, VAR_39);
                    break;
                case VAR_52:   /* COMMENT_2 */
                    proto_tree_add_item(VAR_2, VAR_53, VAR_0, VAR_4+2, 1, VAR_39);
                    break;
                case VAR_54:   /* COMMENT_1 */
                    proto_tree_add_item(VAR_2, VAR_55, VAR_0, VAR_4+2, 2, VAR_39);
                    break;
                case VAR_56:
                    proto_tree_add_item(VAR_2, VAR_57, VAR_0, VAR_4+2, 2, VAR_39);
                    break;
                case VAR_58:
                    proto_tree_add_item(VAR_2, VAR_59, VAR_0, VAR_4+2, 2, VAR_39);
                    break;
                case VAR_60:
                    proto_tree_add_item(VAR_2, VAR_61, VAR_0, VAR_4+2, 2, VAR_39);
                    break;
                case VAR_62:
                    proto_tree_add_item(VAR_2, VAR_63, VAR_0, VAR_4+2, 2, VAR_39);
                    break;
                case VAR_64:
                    proto_tree_add_item(VAR_2, VAR_65, VAR_0, VAR_4+2, 2, VAR_39);
                    break;
                case VAR_66:
                    proto_tree_add_item(VAR_2, VAR_67, VAR_0, VAR_4+2, 2, VAR_39);
                    break;
                case VAR_68:
                    proto_tree_add_item(VAR_2, VAR_69, VAR_0, VAR_4+2, 2, VAR_39);
                    break;
                case VAR_70:
                    proto_tree_add_item(VAR_2, VAR_71, VAR_0, VAR_4+2, 2, VAR_39);
                    break;
                case VAR_72:        /* COMMENT_1 */
                case VAR_73:                /* COMMENT_3 */
                default:
                    if (VAR_5 > 2)
                        dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4+2, VAR_5-2, VAR_6->register_format, VAR_6->reg_base, 0);
                    break;
            } /* COMMENT_4 */
            break;

        case VAR_74:
            proto_tree_add_item(VAR_2, VAR_75, VAR_0, VAR_4, 2, VAR_39);
            proto_tree_add_item(VAR_2, VAR_76, VAR_0, VAR_4+2, 2, VAR_39);
            break;

        case VAR_77:
            VAR_13 = (guint32)tvb_get_guint8(VAR_0, VAR_4);
            proto_tree_add_uint(VAR_2, VAR_34, VAR_0, VAR_4, 1, VAR_13);
            proto_tree_add_item(VAR_2, VAR_75, VAR_0, VAR_4+1, 2, VAR_39);
            proto_tree_add_item(VAR_2, VAR_76, VAR_0, VAR_4+3, 2, VAR_39);
            proto_tree_add_item(VAR_2, VAR_78, VAR_0, VAR_4+5, 2, VAR_39);
            if (VAR_13-6 > 0) {
                VAR_13 -= 6;
                VAR_15 = 0;
                VAR_8 = proto_tree_add_subtree(VAR_2, VAR_0, VAR_4+7, VAR_13, VAR_79, NULL, ""Events"");
                while (VAR_13 > 0) {
                    VAR_22 = tvb_get_guint8(VAR_0, VAR_4+7+VAR_15);
                    if (VAR_22 == 0) {
                        proto_tree_add_uint_format(VAR_8, VAR_80, VAR_0, VAR_4+7+VAR_15, 1, VAR_22, ""Initiated Communication Restart"");
                    }
                    else if (VAR_22 == 4) {
                        proto_tree_add_uint_format(VAR_8, VAR_80, VAR_0, VAR_4+7+VAR_15, 1, VAR_22, ""Entered Listen Only Mode"");
                    }
                    else if (VAR_22 & VAR_81) {
                        VAR_12 = proto_tree_add_uint_format(VAR_8, VAR_80, VAR_0, VAR_4+7+VAR_15, 1,
                                    VAR_22, ""Receive Event: 0x%02X"", VAR_22);
                        VAR_9 = proto_item_add_subtree(VAR_12, VAR_82);

                        /* COMMENT_5 */
                        proto_tree_add_item(VAR_9, VAR_83,
                          VAR_0, VAR_4+7+VAR_15, 1, VAR_84 );
                        proto_tree_add_item(VAR_9, VAR_85,
                          VAR_0, VAR_4+7+VAR_15, 1, VAR_84 );
                        proto_tree_add_item(VAR_9, VAR_86,
                          VAR_0, VAR_4+7+VAR_15, 1, VAR_84 );
                        proto_tree_add_item(VAR_9, VAR_87,
                          VAR_0, VAR_4+7+VAR_15, 1, VAR_84 );
                    }
                    else if ((VAR_22 & VAR_88) == VAR_89) {
                        VAR_12 = proto_tree_add_uint_format(VAR_8, VAR_80, VAR_0, VAR_4+7+VAR_15, 1,
                                    VAR_22, ""Send Event: 0x%02X"", VAR_22);
                        VAR_9 = proto_item_add_subtree(VAR_12, VAR_90);

                        /* COMMENT_5 */
                        proto_tree_add_item(VAR_9, VAR_91,
                          VAR_0, VAR_4+7+VAR_15, 1, VAR_84 );
                        proto_tree_add_item(VAR_9, VAR_92,
                          VAR_0, VAR_4+7+VAR_15, 1, VAR_84 );
                        proto_tree_add_item(VAR_9, VAR_93,
                          VAR_0, VAR_4+7+VAR_15, 1, VAR_84 );
                        proto_tree_add_item(VAR_9, VAR_94,
                          VAR_0, VAR_4+7+VAR_15, 1, VAR_84 );
                        proto_tree_add_item(VAR_9, VAR_95,
                          VAR_0, VAR_4+7+VAR_15, 1, VAR_84 );
                        proto_tree_add_item(VAR_9, VAR_96,
                          VAR_0, VAR_4+7+VAR_15, 1, VAR_84 );
                    }
                    else {
                        proto_tree_add_uint_format(VAR_8, VAR_80, VAR_0, VAR_4+7+VAR_15, 1, VAR_22, ""Unknown Event"");
                    }

                    VAR_13--;
                    VAR_15++;
                }
            }
            break;

        case VAR_97:
            proto_tree_add_item(VAR_2, VAR_38, VAR_0, VAR_4, 2, VAR_39);
            proto_tree_add_item(VAR_2, VAR_98, VAR_0, VAR_4 + 2, 2, VAR_39);
            break;

        case VAR_99:
            proto_tree_add_item(VAR_2, VAR_38, VAR_0, VAR_4, 2, VAR_39);
            proto_tree_add_item(VAR_2, VAR_100, VAR_0, VAR_4 + 2, 2, VAR_39);
            break;

        case VAR_101:
            VAR_13 = (guint32)tvb_get_guint8(VAR_0, VAR_4);
            proto_tree_add_uint(VAR_2, VAR_34, VAR_0, VAR_4, 1,
                    VAR_13);

            /* COMMENT_6 */
            VAR_14 = VAR_4 + 1;
            VAR_19 = 0;
            while (VAR_13 > 0) {
                VAR_25 = (guint32)tvb_get_guint8(VAR_0, VAR_14);
                VAR_7 = proto_tree_add_subtree_format( VAR_2, VAR_0, VAR_14, VAR_25 + 1,
                        VAR_102, NULL, ""Group %u"", VAR_19);
                proto_tree_add_uint(VAR_7, VAR_34, VAR_0, VAR_14, 1,
                        VAR_25);
                proto_tree_add_item(VAR_7, VAR_103, VAR_0, VAR_14 + 1, 1, VAR_39);
                dissect_modbus_data(VAR_0, VAR_1, VAR_7, VAR_3, VAR_14 + 2, VAR_25 - 1, VAR_6->register_format, VAR_6->reg_base, 0);
                VAR_14 += (VAR_25 + 1);
                VAR_13 -= (VAR_25 + 1);
                VAR_19++;
            }
            break;

        case VAR_104:   /* COMMENT_7 */
            VAR_13 = (guint32)tvb_get_guint8(VAR_0, VAR_4);
            proto_tree_add_uint(VAR_2, VAR_34, VAR_0, VAR_4, 1, VAR_13);

            /* COMMENT_6 */
            VAR_14 = VAR_4 + 1;
            VAR_19 = 0;
            while (VAR_13 > 0) {
                VAR_26 = tvb_get_ntohs(VAR_0, VAR_14 + 5);
                VAR_25 = (2 * VAR_26) + 7;
                VAR_7 = proto_tree_add_subtree_format( VAR_2, VAR_0, VAR_14,
                        VAR_25, VAR_102, NULL, ""Group %u"", VAR_19);
                proto_tree_add_item(VAR_7, VAR_103, VAR_0, VAR_14, 1, VAR_39);
                proto_tree_add_item(VAR_7, VAR_105, VAR_0, VAR_14 + 1, 4, VAR_39);
                proto_tree_add_uint(VAR_7, VAR_100, VAR_0, VAR_14 + 5, 2, VAR_26);
                dissect_modbus_data(VAR_0, VAR_1, VAR_7, VAR_3, VAR_14 + 7, VAR_25 - 7, VAR_6->register_format, VAR_6->reg_base, 0);
                VAR_14 += VAR_25;
                VAR_13 -= VAR_25;
                VAR_19++;
            }
            break;

        case VAR_106:      /* COMMENT_7 */
            proto_tree_add_item(VAR_2, VAR_38, VAR_0, VAR_4, 2, VAR_39);
            proto_tree_add_item(VAR_2, VAR_107, VAR_0, VAR_4 + 2, 2, VAR_39);
            proto_tree_add_item(VAR_2, VAR_108, VAR_0, VAR_4 + 4, 2, VAR_39);
            break;

        case VAR_109:
            VAR_13 = (guint32)tvb_get_guint8(VAR_0, VAR_4);
            proto_tree_add_uint(VAR_2, VAR_34, VAR_0, VAR_4, 1, VAR_13);
            dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 1, VAR_13, VAR_6->register_format, VAR_6->reg_base, 0);
            break;

        case VAR_110:
            VAR_13 = (guint32)tvb_get_ntohs(VAR_0, VAR_4);
            proto_tree_add_uint(VAR_2, VAR_111, VAR_0, VAR_4, 2, VAR_13);
            proto_tree_add_item(VAR_2, VAR_100, VAR_0, VAR_4 + 2, 2, VAR_39);
            dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4 + 4, VAR_13 - 2, VAR_6->register_format, VAR_6->reg_base, 0);
            break;

        case VAR_112:
            proto_tree_add_item(VAR_2, VAR_113, VAR_0, VAR_4, 1, VAR_39);
            VAR_21 = tvb_get_guint8(VAR_0, VAR_4);
            switch (VAR_21)
            {
                case VAR_114:
                    proto_tree_add_item(VAR_2, VAR_115, VAR_0, VAR_4+1, 1, VAR_39);
                    proto_tree_add_item(VAR_2, VAR_116, VAR_0, VAR_4+2, 1, VAR_39);
                    proto_tree_add_item(VAR_2, VAR_117, VAR_0, VAR_4+3, 1, VAR_39);
                    proto_tree_add_item(VAR_2, VAR_118, VAR_0, VAR_4+4, 1, VAR_39);
                    VAR_18 = tvb_get_guint8(VAR_0, VAR_4+5);
                    proto_tree_add_uint(VAR_2, VAR_119, VAR_0, VAR_4+5, 1, VAR_18);
                    VAR_10 = proto_tree_add_subtree(VAR_2, VAR_0, VAR_4+6, VAR_5-6,
                                                                    VAR_120, NULL, ""Objects"");

                    VAR_16 = 0;
                    for (VAR_19 = 0; VAR_19 < VAR_18; VAR_19++)
                    {
                        /* COMMENT_8 */

                        /* COMMENT_9 */
                        VAR_20 = tvb_get_guint8(VAR_0, VAR_4+6+VAR_16);
                        VAR_17 = tvb_get_guint8(VAR_0, VAR_4+6+VAR_16+1);

                        VAR_11 = proto_tree_add_subtree_format(VAR_10, VAR_0, VAR_4+6+VAR_16, 2+VAR_17,
                                                    VAR_121, NULL, ""Object #%d"", VAR_19+1);

                        proto_tree_add_item(VAR_11, VAR_122, VAR_0, VAR_4+6+VAR_16, 1, VAR_39);
                        VAR_16++;

                        proto_tree_add_uint(VAR_11, VAR_123, VAR_0, VAR_4+6+VAR_16, 1, VAR_17);
                        VAR_16++;

                        if (VAR_20 < 7)
                        {
                            proto_tree_add_item(VAR_11, VAR_124, VAR_0, VAR_4+6+VAR_16, VAR_17, VAR_125|VAR_41);
                        }
                        else
                        {
                            if (VAR_17 > 0)
                                proto_tree_add_item(VAR_11, VAR_126, VAR_0, VAR_4+6+VAR_16, VAR_17, VAR_41);
                        }
                        VAR_16 += VAR_17;
                    } /* COMMENT_10 */
                    break;

                case VAR_127:
                    /* COMMENT_11 */
                default:
                    if (VAR_5 > 1)
                        dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5-1, VAR_6->register_format, VAR_6->reg_base, 0);
                    break;
            } /* COMMENT_12 */
            break;

        case VAR_128:
        default:
            if (VAR_5 > 0)
                dissect_modbus_data(VAR_0, VAR_1, VAR_2, VAR_3, VAR_4, VAR_5, VAR_6->register_format, VAR_6->reg_base, 0);
            break;

    } /* COMMENT_13 */

    return tvb_captured_length(VAR_0);
}",wireshark/bb41b6619210d998f1abacc43ee20acc985249a4/packet-mbtcp.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -6,11 +6,17 @@
     proto_item    *mei;
     gint          byte_cnt, group_offset, event_index, object_index, object_len, num_objects, ii;
     guint8        object_type, mei_code, event_code;
-    guint16       diagnostic_code, num_reg = pkt_info->num_reg;
+    guint16       diagnostic_code, num_reg;
     guint32       group_byte_cnt, group_word_cnt;
 
     nstime_t      response_time;
     proto_item    *request_frame_item, *response_time_item;
+
+    if (!pkt_info) {
+        return 0;
+    }
+
+    num_reg = pkt_info->num_reg;
 
     if (pkt_info->request_found == TRUE) {
         request_frame_item = proto_tree_add_uint(modbus_tree, hf_modbus_request_frame, tvb, 0, 0, pkt_info->req_frame_num);","{'deleted_lines': ['    guint16       diagnostic_code, num_reg = pkt_info->num_reg;'], 'added_lines': ['    guint16       diagnostic_code, num_reg;', '', '    if (!pkt_info) {', '        return 0;', '    }', '', '    num_reg = pkt_info->num_reg;']}",True,NULL pointer exception in the Modbus dissector in Wireshark 3.4.0 to 3.4.9 and 3.2.0 to 3.2.17 allows denial of service via packet injection or crafted capture file,7.5,HIGH,2,test,,5
CVE-2021-45078,['CWE-787'],AV:N/AC:M/Au:N/C:P/I:P/A:P,0,binutils-gdb,"
PR28694, Out-of-bounds write in stab_xcoff_builtin_type

	PR 28694
	* stabs.c (stab_xcoff_builtin_type): Make typenum unsigned.
	Negate typenum earlier, simplifying bounds checking.  Correct
	off-by-one indexing.  Adjust switch cases.
",161e87d12167b1e36193385485c1f6ce92f74f02,https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=161e87d12167b1e36193385485c1f6ce92f74f02,binutils/stabs.c,stab_xcoff_builtin_type,"static debug_type
stab_xcoff_builtin_type (void *dhandle, struct stab_handle *info,
int typenum)
{
debug_type rettype;
const char *name;
if (typenum >= 0 || typenum < -XCOFF_TYPE_COUNT)
{
fprintf (stderr, _(""Unrecognized XCOFF type %d\n""), typenum);
return DEBUG_TYPE_NULL;
}
if (info->xcoff_types[-typenum] != NULL)
return info->xcoff_types[-typenum];
switch (-typenum)
{
case 1:
name = ""int"";
rettype = debug_make_int_type (dhandle, 4, false);
break;
case 2:
name = ""char"";
rettype = debug_make_int_type (dhandle, 1, false);
break;
case 3:
name = ""short"";
rettype = debug_make_int_type (dhandle, 2, false);
break;
case 4:
name = ""long"";
rettype = debug_make_int_type (dhandle, 4, false);
break;
case 5:
name = ""unsigned char"";
rettype = debug_make_int_type (dhandle, 1, true);
break;
case 6:
name = ""signed char"";
rettype = debug_make_int_type (dhandle, 1, false);
break;
case 7:
name = ""unsigned short"";
rettype = debug_make_int_type (dhandle, 2, true);
break;
case 8:
name = ""unsigned int"";
rettype = debug_make_int_type (dhandle, 4, true);
break;
case 9:
name = ""unsigned"";
rettype = debug_make_int_type (dhandle, 4, true);
break;
case 10:
name = ""unsigned long"";
rettype = debug_make_int_type (dhandle, 4, true);
break;
case 11:
name = ""void"";
rettype = debug_make_void_type (dhandle);
break;
case 12:
name = ""float"";
rettype = debug_make_float_type (dhandle, 4);
break;
case 13:
name = ""double"";
rettype = debug_make_float_type (dhandle, 8);
break;
case 14:
name = ""long double"";
rettype = debug_make_float_type (dhandle, 8);
break;
case 15:
name = ""integer"";
rettype = debug_make_int_type (dhandle, 4, false);
break;
case 16:
name = ""boolean"";
rettype = debug_make_bool_type (dhandle, 4);
break;
case 17:
name = ""short real"";
rettype = debug_make_float_type (dhandle, 4);
break;
case 18:
name = ""real"";
rettype = debug_make_float_type (dhandle, 8);
break;
case 19:
name = ""stringptr"";
rettype = NULL;
break;
case 20:
name = ""character"";
rettype = debug_make_int_type (dhandle, 1, true);
break;
case 21:
name = ""logical*1"";
rettype = debug_make_bool_type (dhandle, 1);
break;
case 22:
name = ""logical*2"";
rettype = debug_make_bool_type (dhandle, 2);
break;
case 23:
name = ""logical*4"";
rettype = debug_make_bool_type (dhandle, 4);
break;
case 24:
name = ""logical"";
rettype = debug_make_bool_type (dhandle, 4);
break;
case 25:
name = ""complex"";
rettype = debug_make_complex_type (dhandle, 8);
break;
case 26:
name = ""double complex"";
rettype = debug_make_complex_type (dhandle, 16);
break;
case 27:
name = ""integer*1"";
rettype = debug_make_int_type (dhandle, 1, false);
break;
case 28:
name = ""integer*2"";
rettype = debug_make_int_type (dhandle, 2, false);
break;
case 29:
name = ""integer*4"";
rettype = debug_make_int_type (dhandle, 4, false);
break;
case 30:
name = ""wchar"";
rettype = debug_make_int_type (dhandle, 2, false);
break;
case 31:
name = ""long long"";
rettype = debug_make_int_type (dhandle, 8, false);
break;
case 32:
name = ""unsigned long long"";
rettype = debug_make_int_type (dhandle, 8, true);
break;
case 33:
name = ""logical*8"";
rettype = debug_make_bool_type (dhandle, 8);
break;
case 34:
name = ""integer*8"";
rettype = debug_make_int_type (dhandle, 8, false);
break;
default:
abort ();
}
rettype = debug_name_type (dhandle, name, rettype);
info->xcoff_types[-typenum] = rettype;
return rettype;
}","static debug_type
stab_xcoff_builtin_type (void *VAR_0, struct stab_handle *VAR_1,
int VAR_2)
{
debug_type VAR_3;
const char *VAR_4;
if (VAR_2 >= 0 || VAR_2 < -VAR_5)
{
fprintf (VAR_6, _(""Unrecognized XCOFF type %d\n""), VAR_2);
return VAR_7;
}
if (VAR_1->xcoff_types[-VAR_2] != NULL)
return VAR_1->xcoff_types[-VAR_2];
switch (-VAR_2)
{
case 1:
VAR_4 = ""int"";
VAR_3 = debug_make_int_type (VAR_0, 4, false);
break;
case 2:
VAR_4 = ""char"";
VAR_3 = debug_make_int_type (VAR_0, 1, false);
break;
case 3:
VAR_4 = ""short"";
VAR_3 = debug_make_int_type (VAR_0, 2, false);
break;
case 4:
VAR_4 = ""long"";
VAR_3 = debug_make_int_type (VAR_0, 4, false);
break;
case 5:
VAR_4 = ""unsigned char"";
VAR_3 = debug_make_int_type (VAR_0, 1, true);
break;
case 6:
VAR_4 = ""signed char"";
VAR_3 = debug_make_int_type (VAR_0, 1, false);
break;
case 7:
VAR_4 = ""unsigned short"";
VAR_3 = debug_make_int_type (VAR_0, 2, true);
break;
case 8:
VAR_4 = ""unsigned int"";
VAR_3 = debug_make_int_type (VAR_0, 4, true);
break;
case 9:
VAR_4 = ""unsigned"";
VAR_3 = debug_make_int_type (VAR_0, 4, true);
break;
case 10:
VAR_4 = ""unsigned long"";
VAR_3 = debug_make_int_type (VAR_0, 4, true);
break;
case 11:
VAR_4 = ""void"";
VAR_3 = debug_make_void_type (VAR_0);
break;
case 12:
VAR_4 = ""float"";
VAR_3 = debug_make_float_type (VAR_0, 4);
break;
case 13:
VAR_4 = ""double"";
VAR_3 = debug_make_float_type (VAR_0, 8);
break;
case 14:
VAR_4 = ""long double"";
VAR_3 = debug_make_float_type (VAR_0, 8);
break;
case 15:
VAR_4 = ""integer"";
VAR_3 = debug_make_int_type (VAR_0, 4, false);
break;
case 16:
VAR_4 = ""boolean"";
VAR_3 = debug_make_bool_type (VAR_0, 4);
break;
case 17:
VAR_4 = ""short real"";
VAR_3 = debug_make_float_type (VAR_0, 4);
break;
case 18:
VAR_4 = ""real"";
VAR_3 = debug_make_float_type (VAR_0, 8);
break;
case 19:
VAR_4 = ""stringptr"";
VAR_3 = NULL;
break;
case 20:
VAR_4 = ""character"";
VAR_3 = debug_make_int_type (VAR_0, 1, true);
break;
case 21:
VAR_4 = ""logical*1"";
VAR_3 = debug_make_bool_type (VAR_0, 1);
break;
case 22:
VAR_4 = ""logical*2"";
VAR_3 = debug_make_bool_type (VAR_0, 2);
break;
case 23:
VAR_4 = ""logical*4"";
VAR_3 = debug_make_bool_type (VAR_0, 4);
break;
case 24:
VAR_4 = ""logical"";
VAR_3 = debug_make_bool_type (VAR_0, 4);
break;
case 25:
VAR_4 = ""complex"";
VAR_3 = debug_make_complex_type (VAR_0, 8);
break;
case 26:
VAR_4 = ""double complex"";
VAR_3 = debug_make_complex_type (VAR_0, 16);
break;
case 27:
VAR_4 = ""integer*1"";
VAR_3 = debug_make_int_type (VAR_0, 1, false);
break;
case 28:
VAR_4 = ""integer*2"";
VAR_3 = debug_make_int_type (VAR_0, 2, false);
break;
case 29:
VAR_4 = ""integer*4"";
VAR_3 = debug_make_int_type (VAR_0, 4, false);
break;
case 30:
VAR_4 = ""wchar"";
VAR_3 = debug_make_int_type (VAR_0, 2, false);
break;
case 31:
VAR_4 = ""long long"";
VAR_3 = debug_make_int_type (VAR_0, 8, false);
break;
case 32:
VAR_4 = ""unsigned long long"";
VAR_3 = debug_make_int_type (VAR_0, 8, true);
break;
case 33:
VAR_4 = ""logical*8"";
VAR_3 = debug_make_bool_type (VAR_0, 8);
break;
case 34:
VAR_4 = ""integer*8"";
VAR_3 = debug_make_int_type (VAR_0, 8, false);
break;
default:
abort ();
}
VAR_3 = debug_name_type (VAR_0, VAR_4, VAR_3);
VAR_1->xcoff_types[-VAR_2] = VAR_3;
return VAR_3;
}",binutils-gdb/161e87d12167b1e36193385485c1f6ce92f74f02/stabs.c/vul/before/0.json,"static debug_type
stab_xcoff_builtin_type (void *dhandle, struct stab_handle *info,
			 unsigned int typenum)
{
  debug_type rettype;
  const char *name;

  typenum = -typenum - 1;
  if (typenum >= XCOFF_TYPE_COUNT)
    {
      fprintf (stderr, _(""Unrecognized XCOFF type %d\n""), -typenum - 1);
      return DEBUG_TYPE_NULL;
    }
  if (info->xcoff_types[typenum] != NULL)
    return info->xcoff_types[typenum];

  switch (typenum)
    {
    case 0:
      /* The size of this and all the other types are fixed, defined
	 by the debugging format.  */
      name = ""int"";
      rettype = debug_make_int_type (dhandle, 4, false);
      break;
    case 1:
      name = ""char"";
      rettype = debug_make_int_type (dhandle, 1, false);
      break;
    case 2:
      name = ""short"";
      rettype = debug_make_int_type (dhandle, 2, false);
      break;
    case 3:
      name = ""long"";
      rettype = debug_make_int_type (dhandle, 4, false);
      break;
    case 4:
      name = ""unsigned char"";
      rettype = debug_make_int_type (dhandle, 1, true);
      break;
    case 5:
      name = ""signed char"";
      rettype = debug_make_int_type (dhandle, 1, false);
      break;
    case 6:
      name = ""unsigned short"";
      rettype = debug_make_int_type (dhandle, 2, true);
      break;
    case 7:
      name = ""unsigned int"";
      rettype = debug_make_int_type (dhandle, 4, true);
      break;
    case 8:
      name = ""unsigned"";
      rettype = debug_make_int_type (dhandle, 4, true);
      break;
    case 9:
      name = ""unsigned long"";
      rettype = debug_make_int_type (dhandle, 4, true);
      break;
    case 10:
      name = ""void"";
      rettype = debug_make_void_type (dhandle);
      break;
    case 11:
      /* IEEE single precision (32 bit).  */
      name = ""float"";
      rettype = debug_make_float_type (dhandle, 4);
      break;
    case 12:
      /* IEEE double precision (64 bit).  */
      name = ""double"";
      rettype = debug_make_float_type (dhandle, 8);
      break;
    case 13:
      /* This is an IEEE double on the RS/6000, and different machines
	 with different sizes for ""long double"" should use different
	 negative type numbers.  See stabs.texinfo.  */
      name = ""long double"";
      rettype = debug_make_float_type (dhandle, 8);
      break;
    case 14:
      name = ""integer"";
      rettype = debug_make_int_type (dhandle, 4, false);
      break;
    case 15:
      name = ""boolean"";
      rettype = debug_make_bool_type (dhandle, 4);
      break;
    case 16:
      name = ""short real"";
      rettype = debug_make_float_type (dhandle, 4);
      break;
    case 17:
      name = ""real"";
      rettype = debug_make_float_type (dhandle, 8);
      break;
    case 18:
      /* FIXME */
      name = ""stringptr"";
      rettype = NULL;
      break;
    case 19:
      /* FIXME */
      name = ""character"";
      rettype = debug_make_int_type (dhandle, 1, true);
      break;
    case 20:
      name = ""logical*1"";
      rettype = debug_make_bool_type (dhandle, 1);
      break;
    case 21:
      name = ""logical*2"";
      rettype = debug_make_bool_type (dhandle, 2);
      break;
    case 22:
      name = ""logical*4"";
      rettype = debug_make_bool_type (dhandle, 4);
      break;
    case 23:
      name = ""logical"";
      rettype = debug_make_bool_type (dhandle, 4);
      break;
    case 24:
      /* Complex type consisting of two IEEE single precision values.  */
      name = ""complex"";
      rettype = debug_make_complex_type (dhandle, 8);
      break;
    case 25:
      /* Complex type consisting of two IEEE double precision values.  */
      name = ""double complex"";
      rettype = debug_make_complex_type (dhandle, 16);
      break;
    case 26:
      name = ""integer*1"";
      rettype = debug_make_int_type (dhandle, 1, false);
      break;
    case 27:
      name = ""integer*2"";
      rettype = debug_make_int_type (dhandle, 2, false);
      break;
    case 28:
      name = ""integer*4"";
      rettype = debug_make_int_type (dhandle, 4, false);
      break;
    case 29:
      /* FIXME */
      name = ""wchar"";
      rettype = debug_make_int_type (dhandle, 2, false);
      break;
    case 30:
      name = ""long long"";
      rettype = debug_make_int_type (dhandle, 8, false);
      break;
    case 31:
      name = ""unsigned long long"";
      rettype = debug_make_int_type (dhandle, 8, true);
      break;
    case 32:
      name = ""logical*8"";
      rettype = debug_make_bool_type (dhandle, 8);
      break;
    case 33:
      name = ""integer*8"";
      rettype = debug_make_int_type (dhandle, 8, false);
      break;
    default:
      abort ();
    }

  rettype = debug_name_type (dhandle, name, rettype);
  info->xcoff_types[typenum] = rettype;
  return rettype;
}","static debug_type
stab_xcoff_builtin_type (void *VAR_0, struct stab_handle *VAR_1,
			 unsigned int VAR_2)
{
  debug_type VAR_3;
  const char *VAR_4;

  VAR_2 = -VAR_2 - 1;
  if (VAR_2 >= VAR_5)
    {
      fprintf (VAR_6, _(""Unrecognized XCOFF type %d\n""), -VAR_2 - 1);
      return VAR_7;
    }
  if (VAR_1->xcoff_types[VAR_2] != NULL)
    return VAR_1->xcoff_types[VAR_2];

  switch (VAR_2)
    {
    case 0:
      /* COMMENT_0 */
                              
      VAR_4 = ""int"";
      VAR_3 = debug_make_int_type (VAR_0, 4, false);
      break;
    case 1:
      VAR_4 = ""char"";
      VAR_3 = debug_make_int_type (VAR_0, 1, false);
      break;
    case 2:
      VAR_4 = ""short"";
      VAR_3 = debug_make_int_type (VAR_0, 2, false);
      break;
    case 3:
      VAR_4 = ""long"";
      VAR_3 = debug_make_int_type (VAR_0, 4, false);
      break;
    case 4:
      VAR_4 = ""unsigned char"";
      VAR_3 = debug_make_int_type (VAR_0, 1, true);
      break;
    case 5:
      VAR_4 = ""signed char"";
      VAR_3 = debug_make_int_type (VAR_0, 1, false);
      break;
    case 6:
      VAR_4 = ""unsigned short"";
      VAR_3 = debug_make_int_type (VAR_0, 2, true);
      break;
    case 7:
      VAR_4 = ""unsigned int"";
      VAR_3 = debug_make_int_type (VAR_0, 4, true);
      break;
    case 8:
      VAR_4 = ""unsigned"";
      VAR_3 = debug_make_int_type (VAR_0, 4, true);
      break;
    case 9:
      VAR_4 = ""unsigned long"";
      VAR_3 = debug_make_int_type (VAR_0, 4, true);
      break;
    case 10:
      VAR_4 = ""void"";
      VAR_3 = debug_make_void_type (VAR_0);
      break;
    case 11:
      /* COMMENT_2 */
      VAR_4 = ""float"";
      VAR_3 = debug_make_float_type (VAR_0, 4);
      break;
    case 12:
      /* COMMENT_3 */
      VAR_4 = ""double"";
      VAR_3 = debug_make_float_type (VAR_0, 8);
      break;
    case 13:
      /* COMMENT_4 */
                                                             
                                                
      VAR_4 = ""long double"";
      VAR_3 = debug_make_float_type (VAR_0, 8);
      break;
    case 14:
      VAR_4 = ""integer"";
      VAR_3 = debug_make_int_type (VAR_0, 4, false);
      break;
    case 15:
      VAR_4 = ""boolean"";
      VAR_3 = debug_make_bool_type (VAR_0, 4);
      break;
    case 16:
      VAR_4 = ""short real"";
      VAR_3 = debug_make_float_type (VAR_0, 4);
      break;
    case 17:
      VAR_4 = ""real"";
      VAR_3 = debug_make_float_type (VAR_0, 8);
      break;
    case 18:
      /* COMMENT_7 */
      VAR_4 = ""stringptr"";
      VAR_3 = NULL;
      break;
    case 19:
      /* COMMENT_7 */
      VAR_4 = ""character"";
      VAR_3 = debug_make_int_type (VAR_0, 1, true);
      break;
    case 20:
      VAR_4 = ""logical*1"";
      VAR_3 = debug_make_bool_type (VAR_0, 1);
      break;
    case 21:
      VAR_4 = ""logical*2"";
      VAR_3 = debug_make_bool_type (VAR_0, 2);
      break;
    case 22:
      VAR_4 = ""logical*4"";
      VAR_3 = debug_make_bool_type (VAR_0, 4);
      break;
    case 23:
      VAR_4 = ""logical"";
      VAR_3 = debug_make_bool_type (VAR_0, 4);
      break;
    case 24:
      /* COMMENT_8 */
      VAR_4 = ""complex"";
      VAR_3 = debug_make_complex_type (VAR_0, 8);
      break;
    case 25:
      /* COMMENT_9 */
      VAR_4 = ""double complex"";
      VAR_3 = debug_make_complex_type (VAR_0, 16);
      break;
    case 26:
      VAR_4 = ""integer*1"";
      VAR_3 = debug_make_int_type (VAR_0, 1, false);
      break;
    case 27:
      VAR_4 = ""integer*2"";
      VAR_3 = debug_make_int_type (VAR_0, 2, false);
      break;
    case 28:
      VAR_4 = ""integer*4"";
      VAR_3 = debug_make_int_type (VAR_0, 4, false);
      break;
    case 29:
      /* COMMENT_7 */
      VAR_4 = ""wchar"";
      VAR_3 = debug_make_int_type (VAR_0, 2, false);
      break;
    case 30:
      VAR_4 = ""long long"";
      VAR_3 = debug_make_int_type (VAR_0, 8, false);
      break;
    case 31:
      VAR_4 = ""unsigned long long"";
      VAR_3 = debug_make_int_type (VAR_0, 8, true);
      break;
    case 32:
      VAR_4 = ""logical*8"";
      VAR_3 = debug_make_bool_type (VAR_0, 8);
      break;
    case 33:
      VAR_4 = ""integer*8"";
      VAR_3 = debug_make_int_type (VAR_0, 8, false);
      break;
    default:
      abort ();
    }

  VAR_3 = debug_name_type (VAR_0, VAR_4, VAR_3);
  VAR_1->xcoff_types[VAR_2] = VAR_3;
  return VAR_3;
}",binutils-gdb/161e87d12167b1e36193385485c1f6ce92f74f02/stabs.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,165 +1,166 @@
 static debug_type
 stab_xcoff_builtin_type (void *dhandle, struct stab_handle *info,
-			 int typenum)
+			 unsigned int typenum)
 {
   debug_type rettype;
   const char *name;
 
-  if (typenum >= 0 || typenum < -XCOFF_TYPE_COUNT)
+  typenum = -typenum - 1;
+  if (typenum >= XCOFF_TYPE_COUNT)
     {
-      fprintf (stderr, _(""Unrecognized XCOFF type %d\n""), typenum);
+      fprintf (stderr, _(""Unrecognized XCOFF type %d\n""), -typenum - 1);
       return DEBUG_TYPE_NULL;
     }
-  if (info->xcoff_types[-typenum] != NULL)
-    return info->xcoff_types[-typenum];
+  if (info->xcoff_types[typenum] != NULL)
+    return info->xcoff_types[typenum];
 
-  switch (-typenum)
+  switch (typenum)
     {
-    case 1:
+    case 0:
       /* The size of this and all the other types are fixed, defined
 	 by the debugging format.  */
       name = ""int"";
       rettype = debug_make_int_type (dhandle, 4, false);
       break;
-    case 2:
+    case 1:
       name = ""char"";
       rettype = debug_make_int_type (dhandle, 1, false);
       break;
-    case 3:
+    case 2:
       name = ""short"";
       rettype = debug_make_int_type (dhandle, 2, false);
       break;
-    case 4:
+    case 3:
       name = ""long"";
       rettype = debug_make_int_type (dhandle, 4, false);
       break;
-    case 5:
+    case 4:
       name = ""unsigned char"";
       rettype = debug_make_int_type (dhandle, 1, true);
       break;
-    case 6:
+    case 5:
       name = ""signed char"";
       rettype = debug_make_int_type (dhandle, 1, false);
       break;
-    case 7:
+    case 6:
       name = ""unsigned short"";
       rettype = debug_make_int_type (dhandle, 2, true);
       break;
-    case 8:
+    case 7:
       name = ""unsigned int"";
       rettype = debug_make_int_type (dhandle, 4, true);
       break;
-    case 9:
+    case 8:
       name = ""unsigned"";
       rettype = debug_make_int_type (dhandle, 4, true);
       break;
-    case 10:
+    case 9:
       name = ""unsigned long"";
       rettype = debug_make_int_type (dhandle, 4, true);
       break;
-    case 11:
+    case 10:
       name = ""void"";
       rettype = debug_make_void_type (dhandle);
       break;
-    case 12:
+    case 11:
       /* IEEE single precision (32 bit).  */
       name = ""float"";
       rettype = debug_make_float_type (dhandle, 4);
       break;
-    case 13:
+    case 12:
       /* IEEE double precision (64 bit).  */
       name = ""double"";
       rettype = debug_make_float_type (dhandle, 8);
       break;
-    case 14:
+    case 13:
       /* This is an IEEE double on the RS/6000, and different machines
 	 with different sizes for ""long double"" should use different
 	 negative type numbers.  See stabs.texinfo.  */
       name = ""long double"";
       rettype = debug_make_float_type (dhandle, 8);
       break;
-    case 15:
+    case 14:
       name = ""integer"";
       rettype = debug_make_int_type (dhandle, 4, false);
       break;
-    case 16:
+    case 15:
       name = ""boolean"";
       rettype = debug_make_bool_type (dhandle, 4);
       break;
-    case 17:
+    case 16:
       name = ""short real"";
       rettype = debug_make_float_type (dhandle, 4);
       break;
-    case 18:
+    case 17:
       name = ""real"";
       rettype = debug_make_float_type (dhandle, 8);
       break;
-    case 19:
+    case 18:
       /* FIXME */
       name = ""stringptr"";
       rettype = NULL;
       break;
-    case 20:
+    case 19:
       /* FIXME */
       name = ""character"";
       rettype = debug_make_int_type (dhandle, 1, true);
       break;
-    case 21:
+    case 20:
       name = ""logical*1"";
       rettype = debug_make_bool_type (dhandle, 1);
       break;
-    case 22:
+    case 21:
       name = ""logical*2"";
       rettype = debug_make_bool_type (dhandle, 2);
       break;
-    case 23:
+    case 22:
       name = ""logical*4"";
       rettype = debug_make_bool_type (dhandle, 4);
       break;
-    case 24:
+    case 23:
       name = ""logical"";
       rettype = debug_make_bool_type (dhandle, 4);
       break;
-    case 25:
+    case 24:
       /* Complex type consisting of two IEEE single precision values.  */
       name = ""complex"";
       rettype = debug_make_complex_type (dhandle, 8);
       break;
-    case 26:
+    case 25:
       /* Complex type consisting of two IEEE double precision values.  */
       name = ""double complex"";
       rettype = debug_make_complex_type (dhandle, 16);
       break;
-    case 27:
+    case 26:
       name = ""integer*1"";
       rettype = debug_make_int_type (dhandle, 1, false);
       break;
-    case 28:
+    case 27:
       name = ""integer*2"";
       rettype = debug_make_int_type (dhandle, 2, false);
       break;
-    case 29:
+    case 28:
       name = ""integer*4"";
       rettype = debug_make_int_type (dhandle, 4, false);
       break;
-    case 30:
+    case 29:
       /* FIXME */
       name = ""wchar"";
       rettype = debug_make_int_type (dhandle, 2, false);
       break;
-    case 31:
+    case 30:
       name = ""long long"";
       rettype = debug_make_int_type (dhandle, 8, false);
       break;
-    case 32:
+    case 31:
       name = ""unsigned long long"";
       rettype = debug_make_int_type (dhandle, 8, true);
       break;
-    case 33:
+    case 32:
       name = ""logical*8"";
       rettype = debug_make_bool_type (dhandle, 8);
       break;
-    case 34:
+    case 33:
       name = ""integer*8"";
       rettype = debug_make_int_type (dhandle, 8, false);
       break;
@@ -168,8 +169,6 @@
     }
 
   rettype = debug_name_type (dhandle, name, rettype);
-
-  info->xcoff_types[-typenum] = rettype;
-
+  info->xcoff_types[typenum] = rettype;
   return rettype;
 }","{'deleted_lines': ['\t\t\t int typenum)', '  if (typenum >= 0 || typenum < -XCOFF_TYPE_COUNT)', '      fprintf (stderr, _(""Unrecognized XCOFF type %d\\n""), typenum);', '  if (info->xcoff_types[-typenum] != NULL)', '    return info->xcoff_types[-typenum];', '  switch (-typenum)', '    case 1:', '    case 2:', '    case 3:', '    case 4:', '    case 5:', '    case 6:', '    case 7:', '    case 8:', '    case 9:', '    case 10:', '    case 11:', '    case 12:', '    case 13:', '    case 14:', '    case 15:', '    case 16:', '    case 17:', '    case 18:', '    case 19:', '    case 20:', '    case 21:', '    case 22:', '    case 23:', '    case 24:', '    case 25:', '    case 26:', '    case 27:', '    case 28:', '    case 29:', '    case 30:', '    case 31:', '    case 32:', '    case 33:', '    case 34:', '', '  info->xcoff_types[-typenum] = rettype;', ''], 'added_lines': ['\t\t\t unsigned int typenum)', '  typenum = -typenum - 1;', '  if (typenum >= XCOFF_TYPE_COUNT)', '      fprintf (stderr, _(""Unrecognized XCOFF type %d\\n""), -typenum - 1);', '  if (info->xcoff_types[typenum] != NULL)', '    return info->xcoff_types[typenum];', '  switch (typenum)', '    case 0:', '    case 1:', '    case 2:', '    case 3:', '    case 4:', '    case 5:', '    case 6:', '    case 7:', '    case 8:', '    case 9:', '    case 10:', '    case 11:', '    case 12:', '    case 13:', '    case 14:', '    case 15:', '    case 16:', '    case 17:', '    case 18:', '    case 19:', '    case 20:', '    case 21:', '    case 22:', '    case 23:', '    case 24:', '    case 25:', '    case 26:', '    case 27:', '    case 28:', '    case 29:', '    case 30:', '    case 31:', '    case 32:', '    case 33:', '  info->xcoff_types[typenum] = rettype;']}",True,"stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact, as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.",7.8,HIGH,2,test,,5
CVE-2021-4145,['CWE-476'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,qemu-project/qemu,"block/mirror: fix NULL pointer dereference in mirror_wait_on_conflicts()

In mirror_iteration() we call mirror_wait_on_conflicts() with
`self` parameter set to NULL.

Starting from commit d44dae1a7c we dereference `self` pointer in
mirror_wait_on_conflicts() without checks if it is not NULL.

Backtrace:
  Program terminated with signal SIGSEGV, Segmentation fault.
  #0  mirror_wait_on_conflicts (self=0x0, s=<optimized out>, offset=<optimized out>, bytes=<optimized out>)
      at ../block/mirror.c:172
  172	                self->waiting_for_op = op;
  [Current thread is 1 (Thread 0x7f0908931ec0 (LWP 380249))]
  (gdb) bt
  #0  mirror_wait_on_conflicts (self=0x0, s=<optimized out>, offset=<optimized out>, bytes=<optimized out>)
      at ../block/mirror.c:172
  #1  0x00005610c5d9d631 in mirror_run (job=0x5610c76a2c00, errp=<optimized out>) at ../block/mirror.c:491
  #2  0x00005610c5d58726 in job_co_entry (opaque=0x5610c76a2c00) at ../job.c:917
  #3  0x00005610c5f046c6 in coroutine_trampoline (i0=<optimized out>, i1=<optimized out>)
      at ../util/coroutine-ucontext.c:173
  #4  0x00007f0909975820 in ?? () at ../sysdeps/unix/sysv/linux/x86_64/__start_context.S:91
      from /usr/lib64/libc.so.6

Buglink: https://bugzilla.redhat.com/show_bug.cgi?id=2001404
Fixes: d44dae1a7c (""block/mirror: fix active mirror dead-lock in mirror_wait_on_conflicts"")
Signed-off-by: Stefano Garzarella <sgarzare@redhat.com>
Message-Id: <20210910124533.288318-1-sgarzare@redhat.com>
Reviewed-by: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
Signed-off-by: Hanna Reitz <hreitz@redhat.com>
",66fed30c9cd11854fc878a4eceb507e915d7c9cd,https://gitlab.com/qemu-project/qemu/-/commit/66fed30c9cd11854fc878a4eceb507e915d7c9cd,block/mirror.c,mirror_wait_on_conflicts,"static void coroutine_fn mirror_wait_on_conflicts(MirrorOp *self,
MirrorBlockJob *s,
uint64_t offset,
uint64_t bytes)
{
uint64_t self_start_chunk = offset / s->granularity;
uint64_t self_end_chunk = DIV_ROUND_UP(offset + bytes, s->granularity);
uint64_t self_nb_chunks = self_end_chunk - self_start_chunk;
while (find_next_bit(s->in_flight_bitmap, self_end_chunk,
self_start_chunk) < self_end_chunk &&
s->ret >= 0)
{
MirrorOp *op;
QTAILQ_FOREACH(op, &s->ops_in_flight, next) {
uint64_t op_start_chunk = op->offset / s->granularity;
uint64_t op_nb_chunks = DIV_ROUND_UP(op->offset + op->bytes,
s->granularity) -
op_start_chunk;
if (op == self) {
continue;
}
if (ranges_overlap(self_start_chunk, self_nb_chunks,
op_start_chunk, op_nb_chunks))
{
if (op->waiting_for_op) {
continue;
}
self->waiting_for_op = op;
qemu_co_queue_wait(&op->waiting_requests, NULL);
self->waiting_for_op = NULL;
break;
}
}
}
}","static void VAR_0 mirror_wait_on_conflicts(MirrorOp *VAR_1,
MirrorBlockJob *VAR_2,
uint64_t VAR_3,
uint64_t VAR_4)
{
uint64_t VAR_5 = VAR_3 / VAR_2->granularity;
uint64_t VAR_6 = DIV_ROUND_UP(VAR_3 + VAR_4, VAR_2->granularity);
uint64_t VAR_7 = VAR_6 - VAR_5;
while (find_next_bit(VAR_2->in_flight_bitmap, VAR_6,
VAR_5) < VAR_6 &&
VAR_2->ret >= 0)
{
MirrorOp *VAR_8;
QTAILQ_FOREACH(VAR_8, &VAR_2->ops_in_flight, VAR_9) {
uint64_t VAR_10 = VAR_8->offset / VAR_2->granularity;
uint64_t VAR_11 = DIV_ROUND_UP(VAR_8->offset + VAR_8->bytes,
VAR_2->granularity) -
VAR_10;
if (VAR_8 == VAR_1) {
continue;
}
if (ranges_overlap(VAR_5, VAR_7,
VAR_10, VAR_11))
{
if (VAR_8->waiting_for_op) {
continue;
}
VAR_1->waiting_for_op = VAR_8;
qemu_co_queue_wait(&VAR_8->waiting_requests, NULL);
VAR_1->waiting_for_op = NULL;
break;
}
}
}
}",,"static void coroutine_fn mirror_wait_on_conflicts(MirrorOp *self,
                                                  MirrorBlockJob *s,
                                                  uint64_t offset,
                                                  uint64_t bytes)
{
    uint64_t self_start_chunk = offset / s->granularity;
    uint64_t self_end_chunk = DIV_ROUND_UP(offset + bytes, s->granularity);
    uint64_t self_nb_chunks = self_end_chunk - self_start_chunk;

    while (find_next_bit(s->in_flight_bitmap, self_end_chunk,
                         self_start_chunk) < self_end_chunk &&
           s->ret >= 0)
    {
        MirrorOp *op;

        QTAILQ_FOREACH(op, &s->ops_in_flight, next) {
            uint64_t op_start_chunk = op->offset / s->granularity;
            uint64_t op_nb_chunks = DIV_ROUND_UP(op->offset + op->bytes,
                                                 s->granularity) -
                                    op_start_chunk;

            if (op == self) {
                continue;
            }

            if (ranges_overlap(self_start_chunk, self_nb_chunks,
                               op_start_chunk, op_nb_chunks))
            {
                if (self) {
                    /*
                     * If the operation is already (indirectly) waiting for us,
                     * or will wait for us as soon as it wakes up, then just go
                     * on (instead of producing a deadlock in the former case).
                     */
                    if (op->waiting_for_op) {
                        continue;
                    }

                    self->waiting_for_op = op;
                }

                qemu_co_queue_wait(&op->waiting_requests, NULL);

                if (self) {
                    self->waiting_for_op = NULL;
                }

                break;
            }
        }
    }
}","static void VAR_0 mirror_wait_on_conflicts(MirrorOp *VAR_1,
                                                  MirrorBlockJob *VAR_2,
                                                  uint64_t VAR_3,
                                                  uint64_t VAR_4)
{
    uint64_t VAR_5 = VAR_3 / VAR_2->granularity;
    uint64_t VAR_6 = DIV_ROUND_UP(VAR_3 + VAR_4, VAR_2->granularity);
    uint64_t VAR_7 = VAR_6 - VAR_5;

    while (find_next_bit(VAR_2->in_flight_bitmap, VAR_6,
                         VAR_5) < VAR_6 &&
           VAR_2->ret >= 0)
    {
        MirrorOp *VAR_8;

        QTAILQ_FOREACH(VAR_8, &VAR_2->ops_in_flight, VAR_9) {
            uint64_t VAR_10 = VAR_8->offset / VAR_2->granularity;
            uint64_t VAR_11 = DIV_ROUND_UP(VAR_8->offset + VAR_8->bytes,
                                                 VAR_2->granularity) -
                                    VAR_10;

            if (VAR_8 == VAR_1) {
                continue;
            }

            if (ranges_overlap(VAR_5, VAR_7,
                               VAR_10, VAR_11))
            {
                if (VAR_1) {
                    /* COMMENT_0 */
                                                                               
                                                                               
                                                                               
                       
                    if (VAR_8->waiting_for_op) {
                        continue;
                    }

                    VAR_1->waiting_for_op = VAR_8;
                }

                qemu_co_queue_wait(&VAR_8->waiting_requests, NULL);

                if (VAR_1) {
                    VAR_1->waiting_for_op = NULL;
                }

                break;
            }
        }
    }
}",,"--- func_before
+++ func_after
@@ -26,18 +26,25 @@
             if (ranges_overlap(self_start_chunk, self_nb_chunks,
                                op_start_chunk, op_nb_chunks))
             {
-                /*
-                 * If the operation is already (indirectly) waiting for us, or
-                 * will wait for us as soon as it wakes up, then just go on
-                 * (instead of producing a deadlock in the former case).
-                 */
-                if (op->waiting_for_op) {
-                    continue;
+                if (self) {
+                    /*
+                     * If the operation is already (indirectly) waiting for us,
+                     * or will wait for us as soon as it wakes up, then just go
+                     * on (instead of producing a deadlock in the former case).
+                     */
+                    if (op->waiting_for_op) {
+                        continue;
+                    }
+
+                    self->waiting_for_op = op;
                 }
 
-                self->waiting_for_op = op;
                 qemu_co_queue_wait(&op->waiting_requests, NULL);
-                self->waiting_for_op = NULL;
+
+                if (self) {
+                    self->waiting_for_op = NULL;
+                }
+
                 break;
             }
         }","{'deleted_lines': ['                /*', '                 * If the operation is already (indirectly) waiting for us, or', '                 * will wait for us as soon as it wakes up, then just go on', '                 * (instead of producing a deadlock in the former case).', '                 */', '                if (op->waiting_for_op) {', '                    continue;', '                self->waiting_for_op = op;', '                self->waiting_for_op = NULL;'], 'added_lines': ['                if (self) {', '                    /*', '                     * If the operation is already (indirectly) waiting for us,', '                     * or will wait for us as soon as it wakes up, then just go', '                     * on (instead of producing a deadlock in the former case).', '                     */', '                    if (op->waiting_for_op) {', '                        continue;', '                    }', '', '                    self->waiting_for_op = op;', '', '                if (self) {', '                    self->waiting_for_op = NULL;', '                }', '']}",True,A NULL pointer dereference issue was found in the block mirror layer of QEMU in versions prior to 6.2.0. The `self` pointer is dereferenced in mirror_wait_on_conflicts() without ensuring that it's not NULL. A malicious unprivileged user within the guest could use this flaw to crash the QEMU process on the host when writing data reaches the threshold of mirroring node.,6.5,MEDIUM,1,test,,5
CVE-2023-40080,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,android,"Fix multiple OOB bugs in btm_ble_gap.cc

Bug: 275057843
Bug: 275057678
Test: manual
Tag: #security
Ignore-AOSP-First: security
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:3bb913ee8c7da4602798db754045c0fac57afecf)
Merged-In: I4c8ec50c15e2727839a49da0e582164557bcd38a
Change-Id: I4c8ec50c15e2727839a49da0e582164557bcd38a
",7b30443dac7bb9138275c909549110191bcbcae9,https://android.googlesource.com/platform/packages/modules/Bluetooth/+/7b30443dac7bb9138275c909549110191bcbcae9,system/stack/btm/btm_ble_gap.cc,BTM_BlePeriodicSyncSetInfo,"void BTM_BlePeriodicSyncSetInfo(RawAddress addr, uint16_t service_data,
uint8_t adv_handle, SyncTransferCb cb) {
uint16_t conn_handle = BTM_GetHCIConnHandle(addr, BT_TRANSPORT_LE);
tACL_CONN* p_acl = btm_acl_for_bda(addr, BT_TRANSPORT_LE);
LOG_DEBUG(""[PAST] for connection_handle = %u"", conn_handle);
if (conn_handle == 0xFFFF || p_acl == nullptr) {
LOG_ERROR(""[PAST]:Invalid connection handle %u or no LE ACL link"",
conn_handle);
cb.Run(BTM_UNKNOWN_ADDR, addr);
return;
}
if (!HCI_LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_RECIPIENT(
p_acl->peer_le_features)) {
LOG_ERROR(""%s"", ""[PAST]:Remote doesn't support PAST"");
cb.Run(BTM_MODE_UNSUPPORTED, addr);
return;
}
int index = btm_ble_get_free_sync_transfer_index();
tBTM_BLE_PERIODIC_SYNC_TRANSFER* p_sync_transfer =
&btm_ble_pa_sync_cb.sync_transfer[index];
p_sync_transfer->in_use = true;
p_sync_transfer->conn_handle = conn_handle;
p_sync_transfer->addr = addr;
p_sync_transfer->cb = cb;
if (BleScanningManager::IsInitialized()) {
BleScanningManager::Get()->PeriodicAdvSetInfoTransfer(
addr, service_data, adv_handle,
base::Bind(&btm_ble_periodic_syc_transfer_cmd_cmpl));
}
}","void BTM_BlePeriodicSyncSetInfo(RawAddress VAR_0, uint16_t VAR_1,
uint8_t VAR_2, SyncTransferCb VAR_3) {
uint16_t VAR_4 = BTM_GetHCIConnHandle(VAR_0, VAR_5);
tACL_CONN* VAR_6 = btm_acl_for_bda(VAR_0, VAR_5);
LOG_DEBUG(""[PAST] for connection_handle = %u"", VAR_4);
if (VAR_4 == 0xFFFF || VAR_6 == nullptr) {
LOG_ERROR(""[PAST]:Invalid connection handle %u or no LE ACL link"",
VAR_4);
VAR_3.Run(VAR_7, VAR_0);
return;
}
if (!HCI_LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_RECIPIENT(
VAR_6->peer_le_features)) {
LOG_ERROR(""%s"", ""[PAST]:Remote doesn't support PAST"");
VAR_3.Run(VAR_8, VAR_0);
return;
}
int VAR_9 = btm_ble_get_free_sync_transfer_index();
tBTM_BLE_PERIODIC_SYNC_TRANSFER* VAR_10 =
&VAR_11.sync_transfer[VAR_9];
VAR_10->in_use = true;
VAR_10->conn_handle = VAR_4;
VAR_10->addr = VAR_0;
VAR_10->cb = VAR_3;
if (BleScanningManager::IsInitialized()) {
BleScanningManager::Get()->PeriodicAdvSetInfoTransfer(
VAR_0, VAR_1, VAR_2,
base::Bind(&VAR_12));
}
}",android/7b30443dac7bb9138275c909549110191bcbcae9/btm_ble_gap.cc/vul/before/0.json,"void BTM_BlePeriodicSyncSetInfo(RawAddress addr, uint16_t service_data,
                                uint8_t adv_handle, SyncTransferCb cb) {
  uint16_t conn_handle = BTM_GetHCIConnHandle(addr, BT_TRANSPORT_LE);
  tACL_CONN* p_acl = btm_acl_for_bda(addr, BT_TRANSPORT_LE);
  LOG_DEBUG(""[PAST] for connection_handle = %u"", conn_handle);
  if (conn_handle == 0xFFFF || p_acl == nullptr) {
    LOG_ERROR(""[PAST]:Invalid connection handle %u or no LE ACL link"",
              conn_handle);
    cb.Run(BTM_UNKNOWN_ADDR, addr);
    return;
  }
  if (!HCI_LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_RECIPIENT(
          p_acl->peer_le_features)) {
    LOG_ERROR(""%s"", ""[PAST]:Remote doesn't support PAST"");
    cb.Run(BTM_MODE_UNSUPPORTED, addr);
    return;
  }

  int index = btm_ble_get_free_sync_transfer_index();
  if (index == MAX_SYNC_TRANSACTION) {
    BTM_TRACE_ERROR(""Failed to get sync transfer index"");
    cb.Run(BTM_ILLEGAL_VALUE, addr);
    return;
  }

  tBTM_BLE_PERIODIC_SYNC_TRANSFER* p_sync_transfer =
      &btm_ble_pa_sync_cb.sync_transfer[index];
  p_sync_transfer->in_use = true;
  p_sync_transfer->conn_handle = conn_handle;
  p_sync_transfer->addr = addr;
  p_sync_transfer->cb = cb;
  if (BleScanningManager::IsInitialized()) {
    BleScanningManager::Get()->PeriodicAdvSetInfoTransfer(
        addr, service_data, adv_handle,
        base::Bind(&btm_ble_periodic_syc_transfer_cmd_cmpl));
  }
}","void BTM_BlePeriodicSyncSetInfo(RawAddress VAR_0, uint16_t VAR_1,
                                uint8_t VAR_2, SyncTransferCb VAR_3) {
  uint16_t VAR_4 = BTM_GetHCIConnHandle(VAR_0, VAR_5);
  tACL_CONN* VAR_6 = btm_acl_for_bda(VAR_0, VAR_5);
  LOG_DEBUG(""[PAST] for connection_handle = %u"", VAR_4);
  if (VAR_4 == 0xFFFF || VAR_6 == nullptr) {
    LOG_ERROR(""[PAST]:Invalid connection handle %u or no LE ACL link"",
              VAR_4);
    VAR_3.Run(VAR_7, VAR_0);
    return;
  }
  if (!HCI_LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_RECIPIENT(
          VAR_6->peer_le_features)) {
    LOG_ERROR(""%s"", ""[PAST]:Remote doesn't support PAST"");
    VAR_3.Run(VAR_8, VAR_0);
    return;
  }

  int VAR_9 = btm_ble_get_free_sync_transfer_index();
  if (VAR_9 == VAR_10) {
    BTM_TRACE_ERROR(""Failed to get sync transfer index"");
    VAR_3.Run(VAR_11, VAR_0);
    return;
  }

  tBTM_BLE_PERIODIC_SYNC_TRANSFER* VAR_12 =
      &VAR_13.sync_transfer[VAR_9];
  VAR_12->in_use = true;
  VAR_12->conn_handle = VAR_4;
  VAR_12->addr = VAR_0;
  VAR_12->cb = VAR_3;
  if (BleScanningManager::IsInitialized()) {
    BleScanningManager::Get()->PeriodicAdvSetInfoTransfer(
        VAR_0, VAR_1, VAR_2,
        base::Bind(&VAR_14));
  }
}",android/7b30443dac7bb9138275c909549110191bcbcae9/btm_ble_gap.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,6 +17,12 @@
   }
 
   int index = btm_ble_get_free_sync_transfer_index();
+  if (index == MAX_SYNC_TRANSACTION) {
+    BTM_TRACE_ERROR(""Failed to get sync transfer index"");
+    cb.Run(BTM_ILLEGAL_VALUE, addr);
+    return;
+  }
+
   tBTM_BLE_PERIODIC_SYNC_TRANSFER* p_sync_transfer =
       &btm_ble_pa_sync_cb.sync_transfer[index];
   p_sync_transfer->in_use = true;","{'deleted_lines': [], 'added_lines': ['  if (index == MAX_SYNC_TRANSACTION) {', '    BTM_TRACE_ERROR(""Failed to get sync transfer index"");', '    cb.Run(BTM_ILLEGAL_VALUE, addr);', '    return;', '  }', '']}",True,"In multiple functions of btm_ble_gap.cc, there is a possible out of bounds write due to a logic error in the code. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.",7.8,HIGH,2,test,,5
CVE-2023-40080,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,android,"Fix multiple OOB bugs in btm_ble_gap.cc

Bug: 275057843
Bug: 275057678
Test: manual
Tag: #security
Ignore-AOSP-First: security
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:3bb913ee8c7da4602798db754045c0fac57afecf)
Merged-In: I4c8ec50c15e2727839a49da0e582164557bcd38a
Change-Id: I4c8ec50c15e2727839a49da0e582164557bcd38a
",7b30443dac7bb9138275c909549110191bcbcae9,https://android.googlesource.com/platform/packages/modules/Bluetooth/+/7b30443dac7bb9138275c909549110191bcbcae9,system/stack/btm/btm_ble_gap.cc,btm_ble_start_sync_request,"void btm_ble_start_sync_request(uint8_t sid, RawAddress addr, uint16_t skip,
uint16_t timeout) {
tBLE_ADDR_TYPE address_type = BLE_ADDR_RANDOM;
tINQ_DB_ENT* p_i = btm_inq_db_find(addr);
if (p_i) {
address_type = p_i->inq_info.results.ble_addr_type;    }
btm_random_pseudo_to_identity_addr(&addr, &address_type);
address_type &= ~BLE_ADDR_TYPE_ID_BIT;
uint8_t options = 0;
uint8_t cte_type = 7;
int index = btm_ble_get_psync_index(sid, addr);
tBTM_BLE_PERIODIC_SYNC* p = &btm_ble_pa_sync_cb.p_sync[index];
p->sync_state = PERIODIC_SYNC_PENDING;
if (BleScanningManager::IsInitialized()) {
BleScanningManager::Get()->PeriodicScanStart(options, sid, address_type,
addr, skip, timeout, cte_type);
}
alarm_set(sync_timeout_alarm, SYNC_TIMEOUT, btm_ble_start_sync_timeout, NULL);
}","void btm_ble_start_sync_request(uint8_t VAR_0, RawAddress VAR_1, uint16_t VAR_2,
uint16_t VAR_3) {
tBLE_ADDR_TYPE VAR_4 = VAR_5;
tINQ_DB_ENT* VAR_6 = btm_inq_db_find(VAR_1);
if (VAR_6) {
VAR_4 = VAR_6->inq_info.results.ble_addr_type;  
}
btm_random_pseudo_to_identity_addr(&VAR_1, &VAR_4);
VAR_4 &= ~VAR_7;
uint8_t VAR_8 = 0;
uint8_t VAR_9 = 7;
int VAR_10 = btm_ble_get_psync_index(VAR_0, VAR_1);
tBTM_BLE_PERIODIC_SYNC* VAR_11 = &VAR_12.p_sync[VAR_10];
VAR_11->sync_state = VAR_13;
if (BleScanningManager::IsInitialized()) {
BleScanningManager::Get()->PeriodicScanStart(VAR_8, VAR_0, VAR_4,
VAR_1, VAR_2, VAR_3, VAR_9);
}
alarm_set(VAR_14, VAR_15, VAR_16, NULL);
}",android/7b30443dac7bb9138275c909549110191bcbcae9/btm_ble_gap.cc/vul/before/1.json,"void btm_ble_start_sync_request(uint8_t sid, RawAddress addr, uint16_t skip,
                                uint16_t timeout) {
  tBLE_ADDR_TYPE address_type = BLE_ADDR_RANDOM;
  tINQ_DB_ENT* p_i = btm_inq_db_find(addr);
  if (p_i) {
    address_type = p_i->inq_info.results.ble_addr_type;  // Random
  }
  btm_random_pseudo_to_identity_addr(&addr, &address_type);
  address_type &= ~BLE_ADDR_TYPE_ID_BIT;
  uint8_t options = 0;
  uint8_t cte_type = 7;
  int index = btm_ble_get_psync_index(sid, addr);

  if (index == MAX_SYNC_TRANSACTION) {
    LOG_ERROR(""Failed to get sync transfer index"");
    return;
  }

  tBTM_BLE_PERIODIC_SYNC* p = &btm_ble_pa_sync_cb.p_sync[index];
  p->sync_state = PERIODIC_SYNC_PENDING;

  if (BleScanningManager::IsInitialized()) {
    BleScanningManager::Get()->PeriodicScanStart(options, sid, address_type,
                                                 addr, skip, timeout, cte_type);
  }

  alarm_set(sync_timeout_alarm, SYNC_TIMEOUT, btm_ble_start_sync_timeout, NULL);
}","void btm_ble_start_sync_request(uint8_t VAR_0, RawAddress VAR_1, uint16_t VAR_2,
                                uint16_t VAR_3) {
  tBLE_ADDR_TYPE VAR_4 = VAR_5;
  tINQ_DB_ENT* VAR_6 = btm_inq_db_find(VAR_1);
  if (VAR_6) {
    VAR_4 = VAR_6->inq_info.results.ble_addr_type;  /* COMMENT_0 */
  }
  btm_random_pseudo_to_identity_addr(&VAR_1, &VAR_4);
  VAR_4 &= ~VAR_7;
  uint8_t VAR_8 = 0;
  uint8_t VAR_9 = 7;
  int VAR_10 = btm_ble_get_psync_index(VAR_0, VAR_1);

  if (VAR_10 == VAR_11) {
    LOG_ERROR(""Failed to get sync transfer index"");
    return;
  }

  tBTM_BLE_PERIODIC_SYNC* VAR_12 = &VAR_13.p_sync[VAR_10];
  VAR_12->sync_state = VAR_14;

  if (BleScanningManager::IsInitialized()) {
    BleScanningManager::Get()->PeriodicScanStart(VAR_8, VAR_0, VAR_4,
                                                 VAR_1, VAR_2, VAR_3, VAR_9);
  }

  alarm_set(VAR_15, VAR_16, VAR_17, NULL);
}",android/7b30443dac7bb9138275c909549110191bcbcae9/btm_ble_gap.cc/vul/after/1.json,"--- func_before
+++ func_after
@@ -10,6 +10,12 @@
   uint8_t options = 0;
   uint8_t cte_type = 7;
   int index = btm_ble_get_psync_index(sid, addr);
+
+  if (index == MAX_SYNC_TRANSACTION) {
+    LOG_ERROR(""Failed to get sync transfer index"");
+    return;
+  }
+
   tBTM_BLE_PERIODIC_SYNC* p = &btm_ble_pa_sync_cb.p_sync[index];
   p->sync_state = PERIODIC_SYNC_PENDING;
 ","{'deleted_lines': [], 'added_lines': ['', '  if (index == MAX_SYNC_TRANSACTION) {', '    LOG_ERROR(""Failed to get sync transfer index"");', '    return;', '  }', '']}",True,"In multiple functions of btm_ble_gap.cc, there is a possible out of bounds write due to a logic error in the code. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.",7.8,HIGH,2,test,,5
CVE-2023-40080,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,android,"Fix multiple OOB bugs in btm_ble_gap.cc

Bug: 275057843
Bug: 275057678
Test: manual
Tag: #security
Ignore-AOSP-First: security
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:3bb913ee8c7da4602798db754045c0fac57afecf)
Merged-In: I4c8ec50c15e2727839a49da0e582164557bcd38a
Change-Id: I4c8ec50c15e2727839a49da0e582164557bcd38a
",7b30443dac7bb9138275c909549110191bcbcae9,https://android.googlesource.com/platform/packages/modules/Bluetooth/+/7b30443dac7bb9138275c909549110191bcbcae9,system/stack/btm/btm_ble_gap.cc,BTM_BlePeriodicSyncTransfer,"void BTM_BlePeriodicSyncTransfer(RawAddress addr, uint16_t service_data,
uint16_t sync_handle, SyncTransferCb cb) {
uint16_t conn_handle = BTM_GetHCIConnHandle(addr, BT_TRANSPORT_LE);
tACL_CONN* p_acl = btm_acl_for_bda(addr, BT_TRANSPORT_LE);
BTM_TRACE_DEBUG(""[PAST]%s for connection_handle = %x"", __func__, conn_handle);
if (conn_handle == 0xFFFF || p_acl == NULL) {
BTM_TRACE_ERROR(""[PAST]%s:Invalid connection handle or no LE ACL link"",
__func__);
cb.Run(BTM_UNKNOWN_ADDR, addr);
return;
}
if (!HCI_LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_RECIPIENT(
p_acl->peer_le_features)) {
BTM_TRACE_ERROR(""[PAST]%s:Remote doesn't support PAST"", __func__);
cb.Run(BTM_MODE_UNSUPPORTED, addr);
return;
}
int index = btm_ble_get_free_sync_transfer_index();
tBTM_BLE_PERIODIC_SYNC_TRANSFER* p_sync_transfer =
&btm_ble_pa_sync_cb.sync_transfer[index];
p_sync_transfer->in_use = true;
p_sync_transfer->conn_handle = conn_handle;
p_sync_transfer->addr = addr;
p_sync_transfer->cb = cb;
if (BleScanningManager::IsInitialized()) {
BleScanningManager::Get()->PeriodicAdvSyncTransfer(
addr, service_data, sync_handle,
base::Bind(&btm_ble_periodic_syc_transfer_cmd_cmpl));
}
}","void BTM_BlePeriodicSyncTransfer(RawAddress VAR_0, uint16_t VAR_1,
uint16_t VAR_2, SyncTransferCb VAR_3) {
uint16_t VAR_4 = BTM_GetHCIConnHandle(VAR_0, VAR_5);
tACL_CONN* VAR_6 = btm_acl_for_bda(VAR_0, VAR_5);
BTM_TRACE_DEBUG(""[PAST]%s for connection_handle = %x"", VAR_7, VAR_4);
if (VAR_4 == 0xFFFF || VAR_6 == NULL) {
BTM_TRACE_ERROR(""[PAST]%s:Invalid connection handle or no LE ACL link"",
VAR_7);
VAR_3.Run(VAR_8, VAR_0);
return;
}
if (!HCI_LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_RECIPIENT(
VAR_6->peer_le_features)) {
BTM_TRACE_ERROR(""[PAST]%s:Remote doesn't support PAST"", VAR_7);
VAR_3.Run(VAR_9, VAR_0);
return;
}
int VAR_10 = btm_ble_get_free_sync_transfer_index();
tBTM_BLE_PERIODIC_SYNC_TRANSFER* VAR_11 =
&VAR_12.sync_transfer[VAR_10];
VAR_11->in_use = true;
VAR_11->conn_handle = VAR_4;
VAR_11->addr = VAR_0;
VAR_11->cb = VAR_3;
if (BleScanningManager::IsInitialized()) {
BleScanningManager::Get()->PeriodicAdvSyncTransfer(
VAR_0, VAR_1, VAR_2,
base::Bind(&VAR_13));
}
}",android/7b30443dac7bb9138275c909549110191bcbcae9/btm_ble_gap.cc/vul/before/2.json,"void BTM_BlePeriodicSyncTransfer(RawAddress addr, uint16_t service_data,
                                 uint16_t sync_handle, SyncTransferCb cb) {
  uint16_t conn_handle = BTM_GetHCIConnHandle(addr, BT_TRANSPORT_LE);
  tACL_CONN* p_acl = btm_acl_for_bda(addr, BT_TRANSPORT_LE);
  BTM_TRACE_DEBUG(""[PAST]%s for connection_handle = %x"", __func__, conn_handle);
  if (conn_handle == 0xFFFF || p_acl == NULL) {
    BTM_TRACE_ERROR(""[PAST]%s:Invalid connection handle or no LE ACL link"",
                    __func__);
    cb.Run(BTM_UNKNOWN_ADDR, addr);
    return;
  }

  if (!HCI_LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_RECIPIENT(
          p_acl->peer_le_features)) {
    BTM_TRACE_ERROR(""[PAST]%s:Remote doesn't support PAST"", __func__);
    cb.Run(BTM_MODE_UNSUPPORTED, addr);
    return;
  }

  int index = btm_ble_get_free_sync_transfer_index();
  if (index == MAX_SYNC_TRANSACTION) {
    BTM_TRACE_ERROR(""Failed to get sync transfer index"");
    cb.Run(BTM_ILLEGAL_VALUE, addr);
    return;
  }

  tBTM_BLE_PERIODIC_SYNC_TRANSFER* p_sync_transfer =
      &btm_ble_pa_sync_cb.sync_transfer[index];
  p_sync_transfer->in_use = true;
  p_sync_transfer->conn_handle = conn_handle;
  p_sync_transfer->addr = addr;
  p_sync_transfer->cb = cb;
  if (BleScanningManager::IsInitialized()) {
    BleScanningManager::Get()->PeriodicAdvSyncTransfer(
        addr, service_data, sync_handle,
        base::Bind(&btm_ble_periodic_syc_transfer_cmd_cmpl));
  }
}","void BTM_BlePeriodicSyncTransfer(RawAddress VAR_0, uint16_t VAR_1,
                                 uint16_t VAR_2, SyncTransferCb VAR_3) {
  uint16_t VAR_4 = BTM_GetHCIConnHandle(VAR_0, VAR_5);
  tACL_CONN* VAR_6 = btm_acl_for_bda(VAR_0, VAR_5);
  BTM_TRACE_DEBUG(""[PAST]%s for connection_handle = %x"", VAR_7, VAR_4);
  if (VAR_4 == 0xFFFF || VAR_6 == NULL) {
    BTM_TRACE_ERROR(""[PAST]%s:Invalid connection handle or no LE ACL link"",
                    VAR_7);
    VAR_3.Run(VAR_8, VAR_0);
    return;
  }

  if (!HCI_LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_RECIPIENT(
          VAR_6->peer_le_features)) {
    BTM_TRACE_ERROR(""[PAST]%s:Remote doesn't support PAST"", VAR_7);
    VAR_3.Run(VAR_9, VAR_0);
    return;
  }

  int VAR_10 = btm_ble_get_free_sync_transfer_index();
  if (VAR_10 == VAR_11) {
    BTM_TRACE_ERROR(""Failed to get sync transfer index"");
    VAR_3.Run(VAR_12, VAR_0);
    return;
  }

  tBTM_BLE_PERIODIC_SYNC_TRANSFER* VAR_13 =
      &VAR_14.sync_transfer[VAR_10];
  VAR_13->in_use = true;
  VAR_13->conn_handle = VAR_4;
  VAR_13->addr = VAR_0;
  VAR_13->cb = VAR_3;
  if (BleScanningManager::IsInitialized()) {
    BleScanningManager::Get()->PeriodicAdvSyncTransfer(
        VAR_0, VAR_1, VAR_2,
        base::Bind(&VAR_15));
  }
}",android/7b30443dac7bb9138275c909549110191bcbcae9/btm_ble_gap.cc/vul/after/2.json,"--- func_before
+++ func_after
@@ -18,6 +18,12 @@
   }
 
   int index = btm_ble_get_free_sync_transfer_index();
+  if (index == MAX_SYNC_TRANSACTION) {
+    BTM_TRACE_ERROR(""Failed to get sync transfer index"");
+    cb.Run(BTM_ILLEGAL_VALUE, addr);
+    return;
+  }
+
   tBTM_BLE_PERIODIC_SYNC_TRANSFER* p_sync_transfer =
       &btm_ble_pa_sync_cb.sync_transfer[index];
   p_sync_transfer->in_use = true;","{'deleted_lines': [], 'added_lines': ['  if (index == MAX_SYNC_TRANSACTION) {', '    BTM_TRACE_ERROR(""Failed to get sync transfer index"");', '    cb.Run(BTM_ILLEGAL_VALUE, addr);', '    return;', '  }', '']}",True,"In multiple functions of btm_ble_gap.cc, there is a possible out of bounds write due to a logic error in the code. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.",7.8,HIGH,2,test,,5
CVE-2023-40080,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,android,"Fix multiple OOB bugs in btm_ble_gap.cc

Bug: 275057843
Bug: 275057678
Test: manual
Tag: #security
Ignore-AOSP-First: security
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:3bb913ee8c7da4602798db754045c0fac57afecf)
Merged-In: I4c8ec50c15e2727839a49da0e582164557bcd38a
Change-Id: I4c8ec50c15e2727839a49da0e582164557bcd38a
",7b30443dac7bb9138275c909549110191bcbcae9,https://android.googlesource.com/platform/packages/modules/Bluetooth/+/7b30443dac7bb9138275c909549110191bcbcae9,system/stack/btm/btm_ble_gap.cc,btm_ble_start_sync_timeout,"static void btm_ble_start_sync_timeout(void* data) {
LOG_DEBUG(""%s"", """");
sync_node_t* p_head = (sync_node_t*)list_front(sync_queue);
uint8_t adv_sid = p_head->sid;
RawAddress address = p_head->address;
int index = btm_ble_get_psync_index(adv_sid, address);
tBTM_BLE_PERIODIC_SYNC* p = &btm_ble_pa_sync_cb.p_sync[index];
if (BleScanningManager::IsInitialized()) {
BleScanningManager::Get()->PeriodicScanCancelStart();
}
p->sync_start_cb.Run(0x3C, 0, p->sid, 0, p->remote_bda, 0, 0);
p->sync_state = PERIODIC_SYNC_IDLE;
p->in_use = false;
p->remote_bda = RawAddress::kEmpty;
p->sid = 0;
p->sync_handle = 0;
p->in_use = false;
}","static void btm_ble_start_sync_timeout(void* VAR_0) {
LOG_DEBUG(""%s"", """");
sync_node_t* VAR_1 = (sync_node_t*)list_front(VAR_2);
uint8_t VAR_3 = VAR_1->sid;
RawAddress VAR_4 = VAR_1->address;
int VAR_5 = btm_ble_get_psync_index(VAR_3, VAR_4);
tBTM_BLE_PERIODIC_SYNC* VAR_6 = &VAR_7.p_sync[VAR_5];
if (BleScanningManager::IsInitialized()) {
BleScanningManager::Get()->PeriodicScanCancelStart();
}
VAR_6->sync_start_cb.Run(0x3C, 0, VAR_6->sid, 0, VAR_6->remote_bda, 0, 0);
VAR_6->sync_state = VAR_8;
VAR_6->in_use = false;
VAR_6->remote_bda = RawAddress::kEmpty;
VAR_6->sid = 0;
VAR_6->sync_handle = 0;
VAR_6->in_use = false;
}",android/7b30443dac7bb9138275c909549110191bcbcae9/btm_ble_gap.cc/vul/before/3.json,"static void btm_ble_start_sync_timeout(void* data) {
  LOG_DEBUG(""%s"", """");
  sync_node_t* p_head = (sync_node_t*)list_front(sync_queue);
  uint8_t adv_sid = p_head->sid;
  RawAddress address = p_head->address;

  int index = btm_ble_get_psync_index(adv_sid, address);

  if (index == MAX_SYNC_TRANSACTION) {
    LOG_ERROR(""Failed to get sync transfer index"");
    return;
  }

  tBTM_BLE_PERIODIC_SYNC* p = &btm_ble_pa_sync_cb.p_sync[index];

  if (BleScanningManager::IsInitialized()) {
    BleScanningManager::Get()->PeriodicScanCancelStart();
  }
  p->sync_start_cb.Run(0x3C, 0, p->sid, 0, p->remote_bda, 0, 0);

  p->sync_state = PERIODIC_SYNC_IDLE;
  p->in_use = false;
  p->remote_bda = RawAddress::kEmpty;
  p->sid = 0;
  p->sync_handle = 0;
  p->in_use = false;
}","static void btm_ble_start_sync_timeout(void* VAR_0) {
  LOG_DEBUG(""%s"", """");
  sync_node_t* VAR_1 = (sync_node_t*)list_front(VAR_2);
  uint8_t VAR_3 = VAR_1->sid;
  RawAddress VAR_4 = VAR_1->address;

  int VAR_5 = btm_ble_get_psync_index(VAR_3, VAR_4);

  if (VAR_5 == VAR_6) {
    LOG_ERROR(""Failed to get sync transfer index"");
    return;
  }

  tBTM_BLE_PERIODIC_SYNC* VAR_7 = &VAR_8.p_sync[VAR_5];

  if (BleScanningManager::IsInitialized()) {
    BleScanningManager::Get()->PeriodicScanCancelStart();
  }
  VAR_7->sync_start_cb.Run(0x3C, 0, VAR_7->sid, 0, VAR_7->remote_bda, 0, 0);

  VAR_7->sync_state = VAR_9;
  VAR_7->in_use = false;
  VAR_7->remote_bda = RawAddress::kEmpty;
  VAR_7->sid = 0;
  VAR_7->sync_handle = 0;
  VAR_7->in_use = false;
}",android/7b30443dac7bb9138275c909549110191bcbcae9/btm_ble_gap.cc/vul/after/3.json,"--- func_before
+++ func_after
@@ -5,6 +5,11 @@
   RawAddress address = p_head->address;
 
   int index = btm_ble_get_psync_index(adv_sid, address);
+
+  if (index == MAX_SYNC_TRANSACTION) {
+    LOG_ERROR(""Failed to get sync transfer index"");
+    return;
+  }
 
   tBTM_BLE_PERIODIC_SYNC* p = &btm_ble_pa_sync_cb.p_sync[index];
 ","{'deleted_lines': [], 'added_lines': ['', '  if (index == MAX_SYNC_TRANSACTION) {', '    LOG_ERROR(""Failed to get sync transfer index"");', '    return;', '  }']}",True,"In multiple functions of btm_ble_gap.cc, there is a possible out of bounds write due to a logic error in the code. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.",7.8,HIGH,2,test,,5
CVE-2023-40080,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,android,"Fix multiple OOB bugs in btm_ble_gap.cc

Bug: 275057843
Bug: 275057678
Test: manual
Tag: #security
Ignore-AOSP-First: security
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:3bb913ee8c7da4602798db754045c0fac57afecf)
Merged-In: I4c8ec50c15e2727839a49da0e582164557bcd38a
Change-Id: I4c8ec50c15e2727839a49da0e582164557bcd38a
",7b30443dac7bb9138275c909549110191bcbcae9,https://android.googlesource.com/platform/packages/modules/Bluetooth/+/7b30443dac7bb9138275c909549110191bcbcae9,system/stack/btm/btm_ble_gap.cc,BTM_BleStartPeriodicSync,"void BTM_BleStartPeriodicSync(uint8_t adv_sid, RawAddress address,
uint16_t skip, uint16_t timeout,
StartSyncCb syncCb, SyncReportCb reportCb,
SyncLostCb lostCb) {
LOG_DEBUG(""%s"", ""[PSync]"");
int index = btm_ble_get_free_psync_index();
tBTM_BLE_PERIODIC_SYNC* p = &btm_ble_pa_sync_cb.p_sync[index];
if (index == MAX_SYNC_TRANSACTION) {
syncCb.Run(BTM_NO_RESOURCES, 0, adv_sid, BLE_ADDR_RANDOM, address, 0, 0);
return;
}
p->in_use = true;
p->remote_bda = address;
p->sid = adv_sid;
p->sync_start_cb = syncCb;
p->sync_report_cb = reportCb;
p->sync_lost_cb = lostCb;
btm_queue_start_sync_req(adv_sid, address, skip, timeout);
}","void BTM_BleStartPeriodicSync(uint8_t VAR_0, RawAddress VAR_1,
uint16_t VAR_2, uint16_t VAR_3,
StartSyncCb VAR_4, SyncReportCb VAR_5,
SyncLostCb VAR_6) {
LOG_DEBUG(""%s"", ""[PSync]"");
int VAR_7 = btm_ble_get_free_psync_index();
tBTM_BLE_PERIODIC_SYNC* VAR_8 = &VAR_9.p_sync[VAR_7];
if (VAR_7 == VAR_10) {
VAR_4.Run(VAR_11, 0, VAR_0, VAR_12, VAR_1, 0, 0);
return;
}
VAR_8->in_use = true;
VAR_8->remote_bda = VAR_1;
VAR_8->sid = VAR_0;
VAR_8->sync_start_cb = VAR_4;
VAR_8->sync_report_cb = VAR_5;
VAR_8->sync_lost_cb = VAR_6;
btm_queue_start_sync_req(VAR_0, VAR_1, VAR_2, VAR_3);
}",android/7b30443dac7bb9138275c909549110191bcbcae9/btm_ble_gap.cc/vul/before/4.json,"void BTM_BleStartPeriodicSync(uint8_t adv_sid, RawAddress address,
                              uint16_t skip, uint16_t timeout,
                              StartSyncCb syncCb, SyncReportCb reportCb,
                              SyncLostCb lostCb) {
  LOG_DEBUG(""%s"", ""[PSync]"");
  int index = btm_ble_get_free_psync_index();

  if (index == MAX_SYNC_TRANSACTION) {
    syncCb.Run(BTM_NO_RESOURCES, 0, adv_sid, BLE_ADDR_RANDOM, address, 0, 0);
    return;
  }

  tBTM_BLE_PERIODIC_SYNC* p = &btm_ble_pa_sync_cb.p_sync[index];

  p->in_use = true;
  p->remote_bda = address;
  p->sid = adv_sid;
  p->sync_start_cb = syncCb;
  p->sync_report_cb = reportCb;
  p->sync_lost_cb = lostCb;
  btm_queue_start_sync_req(adv_sid, address, skip, timeout);
}","void BTM_BleStartPeriodicSync(uint8_t VAR_0, RawAddress VAR_1,
                              uint16_t VAR_2, uint16_t VAR_3,
                              StartSyncCb VAR_4, SyncReportCb VAR_5,
                              SyncLostCb VAR_6) {
  LOG_DEBUG(""%s"", ""[PSync]"");
  int VAR_7 = btm_ble_get_free_psync_index();

  if (VAR_7 == VAR_8) {
    VAR_4.Run(VAR_9, 0, VAR_0, VAR_10, VAR_1, 0, 0);
    return;
  }

  tBTM_BLE_PERIODIC_SYNC* VAR_11 = &VAR_12.p_sync[VAR_7];

  VAR_11->in_use = true;
  VAR_11->remote_bda = VAR_1;
  VAR_11->sid = VAR_0;
  VAR_11->sync_start_cb = VAR_4;
  VAR_11->sync_report_cb = VAR_5;
  VAR_11->sync_lost_cb = VAR_6;
  btm_queue_start_sync_req(VAR_0, VAR_1, VAR_2, VAR_3);
}",android/7b30443dac7bb9138275c909549110191bcbcae9/btm_ble_gap.cc/vul/after/4.json,"--- func_before
+++ func_after
@@ -4,11 +4,14 @@
                               SyncLostCb lostCb) {
   LOG_DEBUG(""%s"", ""[PSync]"");
   int index = btm_ble_get_free_psync_index();
-  tBTM_BLE_PERIODIC_SYNC* p = &btm_ble_pa_sync_cb.p_sync[index];
+
   if (index == MAX_SYNC_TRANSACTION) {
     syncCb.Run(BTM_NO_RESOURCES, 0, adv_sid, BLE_ADDR_RANDOM, address, 0, 0);
     return;
   }
+
+  tBTM_BLE_PERIODIC_SYNC* p = &btm_ble_pa_sync_cb.p_sync[index];
+
   p->in_use = true;
   p->remote_bda = address;
   p->sid = adv_sid;","{'deleted_lines': ['  tBTM_BLE_PERIODIC_SYNC* p = &btm_ble_pa_sync_cb.p_sync[index];'], 'added_lines': ['', '', '  tBTM_BLE_PERIODIC_SYNC* p = &btm_ble_pa_sync_cb.p_sync[index];', '']}",True,"In multiple functions of btm_ble_gap.cc, there is a possible out of bounds write due to a logic error in the code. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.",7.8,HIGH,2,test,,5
CVE-2023-40083,['CWE-125'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N,1,android,"Fix an OOB bug in parse_gap_data

Bug: 277590580
bug: 275553827
Test: atest net_test_main_shim
Ignore-AOSP-First: security
Tag: #security
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:0d7e3d8fd96389f1435b76f37064c69ae61df6e7)
Merged-In: I7fcb7c46f668f48560a72399a3c5087c6da3827f
Change-Id: I7fcb7c46f668f48560a72399a3c5087c6da3827f
",a218e5be5e4049eae3b321f2a535a128d65d00b6,https://android.googlesource.com/platform/packages/modules/Bluetooth/+/a218e5be5e4049eae3b321f2a535a128d65d00b6,system/main/shim/utils.cc,parse_gap_data,"void parse_gap_data(const std::vector<uint8_t> &raw_data,
std::vector<hci::GapData> &output) {
size_t offset = 0;
while (offset < raw_data.size()) {
hci::GapData gap_data;
uint8_t len = raw_data[offset];
auto begin = raw_data.begin() + offset;
auto end = begin + len + 1;        auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);
bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
data_copy);
hci::GapData::Parse(&gap_data, packet.begin());
output.push_back(gap_data);
offset += len + 1;      }
}","void parse_gap_data(const std::vector<uint8_t> &VAR_0,
std::vector<hci::GapData> &VAR_1) {
size_t VAR_2 = 0;
while (VAR_2 < VAR_0.size()) {
hci::GapData VAR_3;
uint8_t VAR_4 = VAR_0[VAR_2];
auto VAR_5 = VAR_0.begin() + VAR_2;
auto VAR_6 = VAR_5 + VAR_4 + 1;  
auto VAR_7 = std::VAR_8<std::vector<uint8_t>>(VAR_5, VAR_6);
bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
data_copy);
hci::GapData::Parse(&VAR_3, VAR_9.begin());
VAR_1.push_back(VAR_3);
VAR_2 += VAR_4 + 1;  
}
}",android/a218e5be5e4049eae3b321f2a535a128d65d00b6/utils.cc/vul/before/0.json,"void parse_gap_data(const std::vector<uint8_t> &raw_data,
                    std::vector<hci::GapData> &output) {
    size_t offset = 0;
    while (offset < raw_data.size()) {
      hci::GapData gap_data;
      uint8_t len = raw_data[offset];

      if (offset + len + 1 > raw_data.size()) {
        break;
      }

      auto begin = raw_data.begin() + offset;
      auto end = begin + len + 1;  // 1 byte for len
      auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);
      bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
          data_copy);
      hci::GapData::Parse(&gap_data, packet.begin());
      output.push_back(gap_data);
      offset += len + 1;  // 1 byte for len
    }
}","void parse_gap_data(const std::vector<uint8_t> &VAR_0,
                    std::vector<hci::GapData> &VAR_1) {
    size_t VAR_2 = 0;
    while (VAR_2 < VAR_0.size()) {
      hci::GapData VAR_3;
      uint8_t VAR_4 = VAR_0[VAR_2];

      if (VAR_2 + VAR_4 + 1 > VAR_0.size()) {
        break;
      }

      auto VAR_5 = VAR_0.begin() + VAR_2;
      auto VAR_6 = VAR_5 + VAR_4 + 1;  /* COMMENT_0 */
      auto VAR_7 = std::VAR_8<std::vector<uint8_t>>(VAR_5, VAR_6);
      bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
          data_copy);
      hci::GapData::Parse(&VAR_3, VAR_9.begin());
      VAR_1.push_back(VAR_3);
      VAR_2 += VAR_4 + 1;  /* COMMENT_0 */
    }
}",android/a218e5be5e4049eae3b321f2a535a128d65d00b6/utils.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,6 +4,10 @@
     while (offset < raw_data.size()) {
       hci::GapData gap_data;
       uint8_t len = raw_data[offset];
+
+      if (offset + len + 1 > raw_data.size()) {
+        break;
+      }
 
       auto begin = raw_data.begin() + offset;
       auto end = begin + len + 1;  // 1 byte for len","{'deleted_lines': [], 'added_lines': ['', '      if (offset + len + 1 > raw_data.size()) {', '        break;', '      }']}",True,"In parse_gap_data of utils.cc, there is a possible out of bounds read due to a missing bounds check. This could lead to local information disclosure with User execution privileges needed. User interaction is not needed for exploitation.",5.5,MEDIUM,1,test,,5
CVE-2023-40083,['CWE-125'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N,1,android,"Factor out duplicate code for parsing gap data

This change is intended to be used to factor out
dup code for parsing GapData in StartAdvertisingSet
and make it easier to be tested.

Backport of Ia39886c415218353b6f9d59d7d3f6d1160477d6c

Bug: 296291440
Test: atest net_test_main_shim
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:08690d66322386d506818b298ad067622d4d5686)
Merged-In: Ia39886c415218353b6f9d59d7d3f6d1160477d6c
Change-Id: Ia39886c415218353b6f9d59d7d3f6d1160477d6c
",ea81185c89097500559d61b3d49fb9633899e848,https://android.googlesource.com/platform/packages/modules/Bluetooth/+/ea81185c89097500559d61b3d49fb9633899e848,system/main/shim/le_advertising_manager.cc,StartAdvertisingSet,"void StartAdvertisingSet(int reg_id, IdTxPowerStatusCallback register_cb,
AdvertiseParameters params,
std::vector<uint8_t> advertise_data,
std::vector<uint8_t> scan_response_data,
PeriodicAdvertisingParameters periodic_params,
std::vector<uint8_t> periodic_data,
uint16_t duration, uint8_t maxExtAdvEvents,
IdStatusCallback timeout_cb) {
LOG(INFO) << __func__ << "" in shim layer"";
bluetooth::hci::ExtendedAdvertisingConfig config{};
parse_parameter(config, params);
bluetooth::hci::PeriodicAdvertisingParameters periodic_parameters;
periodic_parameters.max_interval = periodic_params.max_interval;
periodic_parameters.min_interval = periodic_params.min_interval;
periodic_parameters.properties =
periodic_params.periodic_advertising_properties;
config.periodic_advertising_parameters = periodic_parameters;
size_t offset = 0;
while (offset < advertise_data.size()) {
GapData gap_data;
uint8_t len = advertise_data[offset];
auto begin = advertise_data.begin() + offset;
auto end = begin + len + 1;        auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);
bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
data_copy);
GapData::Parse(&gap_data, packet.begin());
config.advertisement.push_back(gap_data);
offset += len + 1;      }
offset = 0;
while (offset < scan_response_data.size()) {
GapData gap_data;
uint8_t len = scan_response_data[offset];
auto begin = scan_response_data.begin() + offset;
auto end = begin + len + 1;        auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);
bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
data_copy);
GapData::Parse(&gap_data, packet.begin());
config.scan_response.push_back(gap_data);
offset += len + 1;      }
offset = 0;
while (offset < periodic_data.size()) {
GapData gap_data;
uint8_t len = periodic_data[offset];
auto begin = periodic_data.begin() + offset;
auto end = begin + len + 1;        auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);
bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
data_copy);
GapData::Parse(&gap_data, packet.begin());
config.periodic_data.push_back(gap_data);
offset += len + 1;      }
bluetooth::hci::AdvertiserId id =
bluetooth::shim::GetAdvertising()->ExtendedCreateAdvertiser(
reg_id, config, scan_callback, set_terminated_callback, duration,
maxExtAdvEvents, bluetooth::shim::GetGdShimHandler());
LOG(INFO) << ""create advertising set, reg_id:"" << reg_id
<< "", id:"" << (uint16_t)id;
BTM_LogHistory(kBtmLogTag, RawAddress::kEmpty, ""Le advert started"",
base::StringPrintf(""advert_id:%d"", reg_id));
}","void StartAdvertisingSet(int VAR_0, IdTxPowerStatusCallback VAR_1,
AdvertiseParameters VAR_2,
std::vector<uint8_t> VAR_3,
std::vector<uint8_t> VAR_4,
PeriodicAdvertisingParameters VAR_5,
std::vector<uint8_t> VAR_6,
uint16_t VAR_7, uint8_t VAR_8,
IdStatusCallback VAR_9) {
LOG(VAR_10) << VAR_11 << "" in shim layer"";
bluetooth::hci::ExtendedAdvertisingConfig VAR_12{};
parse_parameter(VAR_12, VAR_2);
bluetooth::hci::PeriodicAdvertisingParameters VAR_13;
VAR_13.max_interval = VAR_5.max_interval;
VAR_13.min_interval = VAR_5.min_interval;
VAR_13.properties =
VAR_5.periodic_advertising_properties;
VAR_12.periodic_advertising_parameters = VAR_13;
size_t VAR_14 = 0;
while (VAR_14 < VAR_3.size()) {
GapData VAR_15;
uint8_t VAR_16 = VAR_3[VAR_14];
auto VAR_17 = VAR_3.begin() + VAR_14;
auto VAR_18 = VAR_17 + VAR_16 + 1;  
auto VAR_19 = std::VAR_20<std::vector<uint8_t>>(VAR_17, VAR_18);
bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
data_copy);
GapData::Parse(&VAR_15, VAR_21.begin());
VAR_12.advertisement.push_back(VAR_15);
VAR_14 += VAR_16 + 1;  
}
VAR_14 = 0;
while (VAR_14 < VAR_4.size()) {
GapData VAR_15;
uint8_t VAR_16 = VAR_4[VAR_14];
auto VAR_17 = VAR_4.begin() + VAR_14;
auto VAR_18 = VAR_17 + VAR_16 + 1;  
auto data_copy = std::VAR_20<std::vector<uint8_t>>(VAR_17, VAR_18);
bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
data_copy);
GapData::Parse(&VAR_15, VAR_21.begin());
VAR_12.scan_response.push_back(VAR_15);
VAR_14 += VAR_16 + 1;  
}
VAR_14 = 0;
while (VAR_14 < VAR_6.size()) {
GapData VAR_15;
uint8_t VAR_16 = VAR_6[VAR_14];
auto VAR_17 = VAR_6.begin() + VAR_14;
auto VAR_18 = VAR_17 + VAR_16 + 1;  
auto data_copy = std::VAR_20<std::vector<uint8_t>>(VAR_17, VAR_18);
bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
data_copy);
GapData::Parse(&VAR_15, VAR_21.begin());
VAR_12.periodic_data.push_back(VAR_15);
VAR_14 += VAR_16 + 1;  
}
bluetooth::hci::AdvertiserId VAR_22 =
bluetooth::shim::GetAdvertising()->ExtendedCreateAdvertiser(
VAR_0, VAR_12, VAR_23, VAR_24, VAR_7,
VAR_8, bluetooth::shim::GetGdShimHandler());
LOG(VAR_10) << ""create advertising set, reg_id:"" << VAR_0
<< "", id:"" << (uint16_t)VAR_22;
BTM_LogHistory(VAR_25, RawAddress::kEmpty, ""Le advert started"",
base::StringPrintf(""advert_id:%d"", VAR_0));
}",android/ea81185c89097500559d61b3d49fb9633899e848/le_advertising_manager.cc/vul/before/0.json,"void StartAdvertisingSet(int reg_id, IdTxPowerStatusCallback register_cb,
                           AdvertiseParameters params,
                           std::vector<uint8_t> advertise_data,
                           std::vector<uint8_t> scan_response_data,
                           PeriodicAdvertisingParameters periodic_params,
                           std::vector<uint8_t> periodic_data,
                           uint16_t duration, uint8_t maxExtAdvEvents,
                           IdStatusCallback timeout_cb) {
    LOG(INFO) << __func__ << "" in shim layer"";

    bluetooth::hci::ExtendedAdvertisingConfig config{};
    parse_parameter(config, params);
    bluetooth::hci::PeriodicAdvertisingParameters periodic_parameters;
    periodic_parameters.max_interval = periodic_params.max_interval;
    periodic_parameters.min_interval = periodic_params.min_interval;
    periodic_parameters.properties =
        periodic_params.periodic_advertising_properties;
    config.periodic_advertising_parameters = periodic_parameters;

    parse_gap_data(advertise_data, config.advertisement);
    parse_gap_data(scan_response_data, config.scan_response);
    parse_gap_data(periodic_data, config.periodic_data);

    bluetooth::hci::AdvertiserId id =
        bluetooth::shim::GetAdvertising()->ExtendedCreateAdvertiser(
            reg_id, config, scan_callback, set_terminated_callback, duration,
            maxExtAdvEvents, bluetooth::shim::GetGdShimHandler());

    LOG(INFO) << ""create advertising set, reg_id:"" << reg_id
              << "", id:"" << (uint16_t)id;

    BTM_LogHistory(kBtmLogTag, RawAddress::kEmpty, ""Le advert started"",
                   base::StringPrintf(""advert_id:%d"", reg_id));
  }","void StartAdvertisingSet(int VAR_0, IdTxPowerStatusCallback VAR_1,
                           AdvertiseParameters VAR_2,
                           std::vector<uint8_t> VAR_3,
                           std::vector<uint8_t> VAR_4,
                           PeriodicAdvertisingParameters VAR_5,
                           std::vector<uint8_t> VAR_6,
                           uint16_t VAR_7, uint8_t VAR_8,
                           IdStatusCallback VAR_9) {
    LOG(VAR_10) << VAR_11 << "" in shim layer"";

    bluetooth::hci::ExtendedAdvertisingConfig VAR_12{};
    parse_parameter(VAR_12, VAR_2);
    bluetooth::hci::PeriodicAdvertisingParameters VAR_13;
    VAR_13.max_interval = VAR_5.max_interval;
    VAR_13.min_interval = VAR_5.min_interval;
    VAR_13.properties =
        VAR_5.periodic_advertising_properties;
    VAR_12.periodic_advertising_parameters = VAR_13;

    parse_gap_data(VAR_3, VAR_12.advertisement);
    parse_gap_data(VAR_4, VAR_12.scan_response);
    parse_gap_data(VAR_6, VAR_12.periodic_data);

    bluetooth::hci::AdvertiserId VAR_14 =
        bluetooth::shim::GetAdvertising()->ExtendedCreateAdvertiser(
            VAR_0, VAR_12, VAR_15, VAR_16, VAR_7,
            VAR_8, bluetooth::shim::GetGdShimHandler());

    LOG(VAR_10) << ""create advertising set, reg_id:"" << VAR_0
              << "", id:"" << (uint16_t)VAR_14;

    BTM_LogHistory(VAR_17, RawAddress::kEmpty, ""Le advert started"",
                   base::StringPrintf(""advert_id:%d"", VAR_0));
  }",android/ea81185c89097500559d61b3d49fb9633899e848/le_advertising_manager.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -17,47 +17,9 @@
         periodic_params.periodic_advertising_properties;
     config.periodic_advertising_parameters = periodic_parameters;
 
-    size_t offset = 0;
-    while (offset < advertise_data.size()) {
-      GapData gap_data;
-      uint8_t len = advertise_data[offset];
-      auto begin = advertise_data.begin() + offset;
-      auto end = begin + len + 1;  // 1 byte for len
-      auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);
-      bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
-          data_copy);
-      GapData::Parse(&gap_data, packet.begin());
-      config.advertisement.push_back(gap_data);
-      offset += len + 1;  // 1 byte for len
-    }
-
-    offset = 0;
-    while (offset < scan_response_data.size()) {
-      GapData gap_data;
-      uint8_t len = scan_response_data[offset];
-      auto begin = scan_response_data.begin() + offset;
-      auto end = begin + len + 1;  // 1 byte for len
-      auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);
-      bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
-          data_copy);
-      GapData::Parse(&gap_data, packet.begin());
-      config.scan_response.push_back(gap_data);
-      offset += len + 1;  // 1 byte for len
-    }
-
-    offset = 0;
-    while (offset < periodic_data.size()) {
-      GapData gap_data;
-      uint8_t len = periodic_data[offset];
-      auto begin = periodic_data.begin() + offset;
-      auto end = begin + len + 1;  // 1 byte for len
-      auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);
-      bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
-          data_copy);
-      GapData::Parse(&gap_data, packet.begin());
-      config.periodic_data.push_back(gap_data);
-      offset += len + 1;  // 1 byte for len
-    }
+    parse_gap_data(advertise_data, config.advertisement);
+    parse_gap_data(scan_response_data, config.scan_response);
+    parse_gap_data(periodic_data, config.periodic_data);
 
     bluetooth::hci::AdvertiserId id =
         bluetooth::shim::GetAdvertising()->ExtendedCreateAdvertiser(","{'deleted_lines': ['    size_t offset = 0;', '    while (offset < advertise_data.size()) {', '      GapData gap_data;', '      uint8_t len = advertise_data[offset];', '      auto begin = advertise_data.begin() + offset;', '      auto end = begin + len + 1;  // 1 byte for len', '      auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);', '      bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(', '          data_copy);', '      GapData::Parse(&gap_data, packet.begin());', '      config.advertisement.push_back(gap_data);', '      offset += len + 1;  // 1 byte for len', '    }', '', '    offset = 0;', '    while (offset < scan_response_data.size()) {', '      GapData gap_data;', '      uint8_t len = scan_response_data[offset];', '      auto begin = scan_response_data.begin() + offset;', '      auto end = begin + len + 1;  // 1 byte for len', '      auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);', '      bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(', '          data_copy);', '      GapData::Parse(&gap_data, packet.begin());', '      config.scan_response.push_back(gap_data);', '      offset += len + 1;  // 1 byte for len', '    }', '', '    offset = 0;', '    while (offset < periodic_data.size()) {', '      GapData gap_data;', '      uint8_t len = periodic_data[offset];', '      auto begin = periodic_data.begin() + offset;', '      auto end = begin + len + 1;  // 1 byte for len', '      auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);', '      bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(', '          data_copy);', '      GapData::Parse(&gap_data, packet.begin());', '      config.periodic_data.push_back(gap_data);', '      offset += len + 1;  // 1 byte for len', '    }'], 'added_lines': ['    parse_gap_data(advertise_data, config.advertisement);', '    parse_gap_data(scan_response_data, config.scan_response);', '    parse_gap_data(periodic_data, config.periodic_data);']}",True,"In parse_gap_data of utils.cc, there is a possible out of bounds read due to a missing bounds check. This could lead to local information disclosure with User execution privileges needed. User interaction is not needed for exploitation.",5.5,MEDIUM,1,test,,5
CVE-2023-40083,['CWE-125'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N,1,android,"Factor out duplicate code for parsing gap data

This change is intended to be used to factor out
dup code for parsing GapData in StartAdvertisingSet
and make it easier to be tested.

Backport of Ia39886c415218353b6f9d59d7d3f6d1160477d6c

Bug: 296291440
Test: atest net_test_main_shim
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:08690d66322386d506818b298ad067622d4d5686)
Merged-In: Ia39886c415218353b6f9d59d7d3f6d1160477d6c
Change-Id: Ia39886c415218353b6f9d59d7d3f6d1160477d6c
",ea81185c89097500559d61b3d49fb9633899e848,https://android.googlesource.com/platform/packages/modules/Bluetooth/+/ea81185c89097500559d61b3d49fb9633899e848,system/main/shim/le_advertising_manager.cc,SetData,"void SetData(int advertiser_id, bool set_scan_rsp, vector<uint8_t> data,
StatusCallback cb) override {
LOG(INFO) << __func__ << "" in shim layer"";
size_t offset = 0;
std::vector<GapData> advertising_data = {};
while (offset < data.size()) {
GapData gap_data;
uint8_t len = data[offset];
auto begin = data.begin() + offset;
auto end = begin + len + 1;        auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);
bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
data_copy);
GapData::Parse(&gap_data, packet.begin());
advertising_data.push_back(gap_data);
offset += len + 1;      }
bluetooth::shim::GetAdvertising()->SetData(advertiser_id, set_scan_rsp,
advertising_data);
}","void SetData(int VAR_0, bool VAR_1, vector<uint8_t> VAR_2,
StatusCallback VAR_3) override {
LOG(VAR_4) << VAR_5 << "" in shim layer"";
size_t VAR_6 = 0;
std::vector<GapData> VAR_7 = {};
while (VAR_6 < VAR_2.size()) {
GapData VAR_8;
uint8_t VAR_9 = VAR_2[VAR_6];
auto VAR_10 = VAR_2.begin() + VAR_6;
auto VAR_11 = VAR_10 + VAR_9 + 1;  
auto VAR_12 = std::VAR_13<std::vector<uint8_t>>(VAR_10, VAR_11);
bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
data_copy);
GapData::Parse(&VAR_8, VAR_14.begin());
VAR_7.push_back(VAR_8);
VAR_6 += VAR_9 + 1;  
}
bluetooth::shim::GetAdvertising()->SetData(VAR_0, VAR_1,
VAR_7);
}",,"void SetData(int advertiser_id, bool set_scan_rsp, vector<uint8_t> data,
               StatusCallback cb) override {
    LOG(INFO) << __func__ << "" in shim layer"";
    std::vector<GapData> advertising_data = {};
    parse_gap_data(data, advertising_data);
    bluetooth::shim::GetAdvertising()->SetData(advertiser_id, set_scan_rsp,
                                               advertising_data);
  }","void SetData(int VAR_0, bool VAR_1, vector<uint8_t> VAR_2,
               StatusCallback VAR_3) override {
    LOG(VAR_4) << VAR_5 << "" in shim layer"";
    std::vector<GapData> VAR_6 = {};
    parse_gap_data(VAR_2, VAR_6);
    bluetooth::shim::GetAdvertising()->SetData(VAR_0, VAR_1,
                                               VAR_6);
  }",,"--- func_before
+++ func_after
@@ -1,23 +1,8 @@
 void SetData(int advertiser_id, bool set_scan_rsp, vector<uint8_t> data,
                StatusCallback cb) override {
     LOG(INFO) << __func__ << "" in shim layer"";
-
-    size_t offset = 0;
     std::vector<GapData> advertising_data = {};
-
-    while (offset < data.size()) {
-      GapData gap_data;
-      uint8_t len = data[offset];
-      auto begin = data.begin() + offset;
-      auto end = begin + len + 1;  // 1 byte for len
-      auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);
-      bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
-          data_copy);
-      GapData::Parse(&gap_data, packet.begin());
-      advertising_data.push_back(gap_data);
-      offset += len + 1;  // 1 byte for len
-    }
-
+    parse_gap_data(data, advertising_data);
     bluetooth::shim::GetAdvertising()->SetData(advertiser_id, set_scan_rsp,
                                                advertising_data);
   }","{'deleted_lines': ['', '    size_t offset = 0;', '', '    while (offset < data.size()) {', '      GapData gap_data;', '      uint8_t len = data[offset];', '      auto begin = data.begin() + offset;', '      auto end = begin + len + 1;  // 1 byte for len', '      auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);', '      bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(', '          data_copy);', '      GapData::Parse(&gap_data, packet.begin());', '      advertising_data.push_back(gap_data);', '      offset += len + 1;  // 1 byte for len', '    }', ''], 'added_lines': ['    parse_gap_data(data, advertising_data);']}",True,"In parse_gap_data of utils.cc, there is a possible out of bounds read due to a missing bounds check. This could lead to local information disclosure with User execution privileges needed. User interaction is not needed for exploitation.",5.5,MEDIUM,1,test,,5
CVE-2023-40083,['CWE-125'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N,1,android,"Factor out duplicate code for parsing gap data

This change is intended to be used to factor out
dup code for parsing GapData in StartAdvertisingSet
and make it easier to be tested.

Backport of Ia39886c415218353b6f9d59d7d3f6d1160477d6c

Bug: 296291440
Test: atest net_test_main_shim
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:08690d66322386d506818b298ad067622d4d5686)
Merged-In: Ia39886c415218353b6f9d59d7d3f6d1160477d6c
Change-Id: Ia39886c415218353b6f9d59d7d3f6d1160477d6c
",ea81185c89097500559d61b3d49fb9633899e848,https://android.googlesource.com/platform/packages/modules/Bluetooth/+/ea81185c89097500559d61b3d49fb9633899e848,system/main/shim/le_advertising_manager.cc,StartAdvertising,"void StartAdvertising(uint8_t advertiser_id, StatusCallback cb,
AdvertiseParameters params,
std::vector<uint8_t> advertise_data,
std::vector<uint8_t> scan_response_data, int timeout_s,
MultiAdvCb timeout_cb) override {
LOG(INFO) << __func__ << "" in shim layer"";
bluetooth::hci::ExtendedAdvertisingConfig config{};
parse_parameter(config, params);
size_t offset = 0;
while (offset < advertise_data.size()) {
GapData gap_data;
uint8_t len = advertise_data[offset];
auto begin = advertise_data.begin() + offset;
auto end = begin + len + 1;        auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);
bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
data_copy);
GapData::Parse(&gap_data, packet.begin());
config.advertisement.push_back(gap_data);
offset += len + 1;      }
offset = 0;
while (offset < scan_response_data.size()) {
GapData gap_data;
uint8_t len = scan_response_data[offset];
auto begin = scan_response_data.begin() + offset;
auto end = begin + len + 1;        auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);
bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
data_copy);
GapData::Parse(&gap_data, packet.begin());
config.scan_response.push_back(gap_data);
offset += len + 1;      }
bluetooth::shim::GetAdvertising()->StartAdvertising(
advertiser_id, config, timeout_s * 100, cb, timeout_cb, scan_callback,
set_terminated_callback, bluetooth::shim::GetGdShimHandler());
}","void StartAdvertising(uint8_t VAR_0, StatusCallback VAR_1,
AdvertiseParameters VAR_2,
std::vector<uint8_t> VAR_3,
std::vector<uint8_t> VAR_4, int VAR_5,
MultiAdvCb VAR_6) override {
LOG(VAR_7) << VAR_8 << "" in shim layer"";
bluetooth::hci::ExtendedAdvertisingConfig VAR_9{};
parse_parameter(VAR_9, VAR_2);
size_t VAR_10 = 0;
while (VAR_10 < VAR_3.size()) {
GapData VAR_11;
uint8_t VAR_12 = VAR_3[VAR_10];
auto VAR_13 = VAR_3.begin() + VAR_10;
auto VAR_14 = VAR_13 + VAR_12 + 1;  
auto VAR_15 = std::VAR_16<std::vector<uint8_t>>(VAR_13, VAR_14);
bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
data_copy);
GapData::Parse(&VAR_11, VAR_17.begin());
VAR_9.advertisement.push_back(VAR_11);
VAR_10 += VAR_12 + 1;  
}
VAR_10 = 0;
while (VAR_10 < VAR_4.size()) {
GapData VAR_11;
uint8_t VAR_12 = VAR_4[VAR_10];
auto VAR_13 = VAR_4.begin() + VAR_10;
auto VAR_14 = VAR_13 + VAR_12 + 1;  
auto data_copy = std::VAR_16<std::vector<uint8_t>>(VAR_13, VAR_14);
bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
data_copy);
GapData::Parse(&VAR_11, VAR_17.begin());
VAR_9.scan_response.push_back(VAR_11);
VAR_10 += VAR_12 + 1;  
}
bluetooth::shim::GetAdvertising()->StartAdvertising(
VAR_0, VAR_9, VAR_5 * 100, VAR_1, VAR_6, VAR_18,
VAR_19, bluetooth::shim::GetGdShimHandler());
}",,"void StartAdvertising(uint8_t advertiser_id, StatusCallback cb,
                        AdvertiseParameters params,
                        std::vector<uint8_t> advertise_data,
                        std::vector<uint8_t> scan_response_data, int timeout_s,
                        MultiAdvCb timeout_cb) override {
    LOG(INFO) << __func__ << "" in shim layer"";

    bluetooth::hci::ExtendedAdvertisingConfig config{};
    parse_parameter(config, params);

    parse_gap_data(advertise_data, config.advertisement);
    parse_gap_data(scan_response_data, config.scan_response);

    bluetooth::shim::GetAdvertising()->StartAdvertising(
        advertiser_id, config, timeout_s * 100, cb, timeout_cb, scan_callback,
        set_terminated_callback, bluetooth::shim::GetGdShimHandler());
  }","void StartAdvertising(uint8_t VAR_0, StatusCallback VAR_1,
                        AdvertiseParameters VAR_2,
                        std::vector<uint8_t> VAR_3,
                        std::vector<uint8_t> VAR_4, int VAR_5,
                        MultiAdvCb VAR_6) override {
    LOG(VAR_7) << VAR_8 << "" in shim layer"";

    bluetooth::hci::ExtendedAdvertisingConfig VAR_9{};
    parse_parameter(VAR_9, VAR_2);

    parse_gap_data(VAR_3, VAR_9.advertisement);
    parse_gap_data(VAR_4, VAR_9.scan_response);

    bluetooth::shim::GetAdvertising()->StartAdvertising(
        VAR_0, VAR_9, VAR_5 * 100, VAR_1, VAR_6, VAR_10,
        VAR_11, bluetooth::shim::GetGdShimHandler());
  }",,"--- func_before
+++ func_after
@@ -8,33 +8,8 @@
     bluetooth::hci::ExtendedAdvertisingConfig config{};
     parse_parameter(config, params);
 
-    size_t offset = 0;
-    while (offset < advertise_data.size()) {
-      GapData gap_data;
-      uint8_t len = advertise_data[offset];
-      auto begin = advertise_data.begin() + offset;
-      auto end = begin + len + 1;  // 1 byte for len
-      auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);
-      bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
-          data_copy);
-      GapData::Parse(&gap_data, packet.begin());
-      config.advertisement.push_back(gap_data);
-      offset += len + 1;  // 1 byte for len
-    }
-
-    offset = 0;
-    while (offset < scan_response_data.size()) {
-      GapData gap_data;
-      uint8_t len = scan_response_data[offset];
-      auto begin = scan_response_data.begin() + offset;
-      auto end = begin + len + 1;  // 1 byte for len
-      auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);
-      bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
-          data_copy);
-      GapData::Parse(&gap_data, packet.begin());
-      config.scan_response.push_back(gap_data);
-      offset += len + 1;  // 1 byte for len
-    }
+    parse_gap_data(advertise_data, config.advertisement);
+    parse_gap_data(scan_response_data, config.scan_response);
 
     bluetooth::shim::GetAdvertising()->StartAdvertising(
         advertiser_id, config, timeout_s * 100, cb, timeout_cb, scan_callback,","{'deleted_lines': ['    size_t offset = 0;', '    while (offset < advertise_data.size()) {', '      GapData gap_data;', '      uint8_t len = advertise_data[offset];', '      auto begin = advertise_data.begin() + offset;', '      auto end = begin + len + 1;  // 1 byte for len', '      auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);', '      bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(', '          data_copy);', '      GapData::Parse(&gap_data, packet.begin());', '      config.advertisement.push_back(gap_data);', '      offset += len + 1;  // 1 byte for len', '    }', '', '    offset = 0;', '    while (offset < scan_response_data.size()) {', '      GapData gap_data;', '      uint8_t len = scan_response_data[offset];', '      auto begin = scan_response_data.begin() + offset;', '      auto end = begin + len + 1;  // 1 byte for len', '      auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);', '      bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(', '          data_copy);', '      GapData::Parse(&gap_data, packet.begin());', '      config.scan_response.push_back(gap_data);', '      offset += len + 1;  // 1 byte for len', '    }'], 'added_lines': ['    parse_gap_data(advertise_data, config.advertisement);', '    parse_gap_data(scan_response_data, config.scan_response);']}",True,"In parse_gap_data of utils.cc, there is a possible out of bounds read due to a missing bounds check. This could lead to local information disclosure with User execution privileges needed. User interaction is not needed for exploitation.",5.5,MEDIUM,1,test,,5
CVE-2023-40083,['CWE-125'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N,1,android,"Factor out duplicate code for parsing gap data

This change is intended to be used to factor out
dup code for parsing GapData in StartAdvertisingSet
and make it easier to be tested.

Backport of Ia39886c415218353b6f9d59d7d3f6d1160477d6c

Bug: 296291440
Test: atest net_test_main_shim
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:08690d66322386d506818b298ad067622d4d5686)
Merged-In: Ia39886c415218353b6f9d59d7d3f6d1160477d6c
Change-Id: Ia39886c415218353b6f9d59d7d3f6d1160477d6c
",ea81185c89097500559d61b3d49fb9633899e848,https://android.googlesource.com/platform/packages/modules/Bluetooth/+/ea81185c89097500559d61b3d49fb9633899e848,system/main/shim/le_advertising_manager.cc,SetPeriodicAdvertisingData,"void SetPeriodicAdvertisingData(int advertiser_id, std::vector<uint8_t> data,
StatusCallback cb) override {
LOG(INFO) << __func__ << "" in shim layer"";
size_t offset = 0;
std::vector<GapData> advertising_data = {};
while (offset < data.size()) {
GapData gap_data;
uint8_t len = data[offset];
auto begin = data.begin() + offset;
auto end = begin + len + 1;        auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);
bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
data_copy);
GapData::Parse(&gap_data, packet.begin());
advertising_data.push_back(gap_data);
offset += len + 1;      }
bluetooth::shim::GetAdvertising()->SetPeriodicData(advertiser_id,
advertising_data);
}","void SetPeriodicAdvertisingData(int VAR_0, std::vector<uint8_t> VAR_1,
StatusCallback VAR_2) override {
LOG(VAR_3) << VAR_4 << "" in shim layer"";
size_t VAR_5 = 0;
std::vector<GapData> VAR_6 = {};
while (VAR_5 < VAR_1.size()) {
GapData VAR_7;
uint8_t VAR_8 = VAR_1[VAR_5];
auto VAR_9 = VAR_1.begin() + VAR_5;
auto VAR_10 = VAR_9 + VAR_8 + 1;  
auto VAR_11 = std::VAR_12<std::vector<uint8_t>>(VAR_9, VAR_10);
bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
data_copy);
GapData::Parse(&VAR_7, VAR_13.begin());
VAR_6.push_back(VAR_7);
VAR_5 += VAR_8 + 1;  
}
bluetooth::shim::GetAdvertising()->SetPeriodicData(VAR_0,
VAR_6);
}",,"void SetPeriodicAdvertisingData(int advertiser_id, std::vector<uint8_t> data,
                                  StatusCallback cb) override {
    LOG(INFO) << __func__ << "" in shim layer"";
    std::vector<GapData> advertising_data = {};
    parse_gap_data(data, advertising_data);
    bluetooth::shim::GetAdvertising()->SetPeriodicData(advertiser_id,
                                                       advertising_data);
  }","void SetPeriodicAdvertisingData(int VAR_0, std::vector<uint8_t> VAR_1,
                                  StatusCallback VAR_2) override {
    LOG(VAR_3) << VAR_4 << "" in shim layer"";
    std::vector<GapData> VAR_5 = {};
    parse_gap_data(VAR_1, VAR_5);
    bluetooth::shim::GetAdvertising()->SetPeriodicData(VAR_0,
                                                       VAR_5);
  }",,"--- func_before
+++ func_after
@@ -1,23 +1,8 @@
 void SetPeriodicAdvertisingData(int advertiser_id, std::vector<uint8_t> data,
                                   StatusCallback cb) override {
     LOG(INFO) << __func__ << "" in shim layer"";
-
-    size_t offset = 0;
     std::vector<GapData> advertising_data = {};
-
-    while (offset < data.size()) {
-      GapData gap_data;
-      uint8_t len = data[offset];
-      auto begin = data.begin() + offset;
-      auto end = begin + len + 1;  // 1 byte for len
-      auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);
-      bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(
-          data_copy);
-      GapData::Parse(&gap_data, packet.begin());
-      advertising_data.push_back(gap_data);
-      offset += len + 1;  // 1 byte for len
-    }
-
+    parse_gap_data(data, advertising_data);
     bluetooth::shim::GetAdvertising()->SetPeriodicData(advertiser_id,
                                                        advertising_data);
   }","{'deleted_lines': ['', '    size_t offset = 0;', '', '    while (offset < data.size()) {', '      GapData gap_data;', '      uint8_t len = data[offset];', '      auto begin = data.begin() + offset;', '      auto end = begin + len + 1;  // 1 byte for len', '      auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end);', '      bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet(', '          data_copy);', '      GapData::Parse(&gap_data, packet.begin());', '      advertising_data.push_back(gap_data);', '      offset += len + 1;  // 1 byte for len', '    }', ''], 'added_lines': ['    parse_gap_data(data, advertising_data);']}",True,"In parse_gap_data of utils.cc, there is a possible out of bounds read due to a missing bounds check. This could lead to local information disclosure with User execution privileges needed. User interaction is not needed for exploitation.",5.5,MEDIUM,1,test,,5
CVE-2023-40087,['CWE-787'],CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,android,"Add bounds checks in btif_avrcp_audio_track.cc

Fuzz testing reveals that the transcodeQ*ToFloat family of functions are
not bounds checked, causing a potential OOB write.

Check these functions against bounds of the destination array.

Bug: 275895309
Test: atest bluetooth_test_gd_unit, net_test_stack_btm
Tag: #security
Ignore-AOSP-First: Security
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:46803ae95d63ee133eae83d885e7c051964dc8ed)
Merged-In: I7a13261429797769cf5b913912a30e249668ac93
Change-Id: I7a13261429797769cf5b913912a30e249668ac93
",243fdf1c0d53bda9e829b4bec9f7c2a824b4d3d1,https://android.googlesource.com/platform/packages/modules/Bluetooth/+/243fdf1c0d53bda9e829b4bec9f7c2a824b4d3d1,system/btif/src/btif_avrcp_audio_track.cc,transcodeQ23ToFloat,"static size_t transcodeQ23ToFloat(uint8_t* buffer, size_t length,
BtifAvrcpAudioTrack* trackHolder) {
size_t sampleSize = sampleSizeFor(trackHolder);
size_t i = 0;
for (; i <= length / sampleSize; i++) {
size_t offset = i * sampleSize;
int32_t sample = *((int32_t*)(buffer + offset - 1)) & 0x00FFFFFF;
trackHolder->buffer[i] = sample * kScaleQ23ToFloat;
}
return i * sampleSize;
}","static size_t transcodeQ23ToFloat(uint8_t* VAR_0, size_t VAR_1,
BtifAvrcpAudioTrack* VAR_2) {
size_t VAR_3 = sampleSizeFor(VAR_2);
size_t VAR_4 = 0;
for (; VAR_4 <= VAR_1 / VAR_3; VAR_4++) {
size_t VAR_5 = VAR_4 * VAR_3;
int32_t VAR_6 = *((int32_t*)(VAR_0 + VAR_5 - 1)) & 0x00FFFFFF;
VAR_2->buffer[VAR_4] = VAR_6 * VAR_7;
}
return VAR_4 * VAR_3;
}",android/243fdf1c0d53bda9e829b4bec9f7c2a824b4d3d1/btif_avrcp_audio_track.cc/vul/before/0.json,"static size_t transcodeQ23ToFloat(uint8_t* buffer, size_t length,
                                  BtifAvrcpAudioTrack* trackHolder) {
  size_t sampleSize = sampleSizeFor(trackHolder);
  size_t i = 0;
  for (; i < std::min(trackHolder->bufferLength, length / sampleSize); i++) {
    size_t offset = i * sampleSize;
    int32_t sample = *((int32_t*)(buffer + offset - 1)) & 0x00FFFFFF;
    trackHolder->buffer[i] = sample * kScaleQ23ToFloat;
  }
  return i * sampleSize;
}","static size_t transcodeQ23ToFloat(uint8_t* VAR_0, size_t VAR_1,
                                  BtifAvrcpAudioTrack* VAR_2) {
  size_t VAR_3 = sampleSizeFor(VAR_2);
  size_t VAR_4 = 0;
  for (; VAR_4 < std::min(VAR_2->bufferLength, VAR_1 / VAR_3); VAR_4++) {
    size_t VAR_5 = VAR_4 * VAR_3;
    int32_t VAR_6 = *((int32_t*)(VAR_0 + VAR_5 - 1)) & 0x00FFFFFF;
    VAR_2->buffer[VAR_4] = VAR_6 * VAR_7;
  }
  return VAR_4 * VAR_3;
}",android/243fdf1c0d53bda9e829b4bec9f7c2a824b4d3d1/btif_avrcp_audio_track.cc/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
                                   BtifAvrcpAudioTrack* trackHolder) {
   size_t sampleSize = sampleSizeFor(trackHolder);
   size_t i = 0;
-  for (; i <= length / sampleSize; i++) {
+  for (; i < std::min(trackHolder->bufferLength, length / sampleSize); i++) {
     size_t offset = i * sampleSize;
     int32_t sample = *((int32_t*)(buffer + offset - 1)) & 0x00FFFFFF;
     trackHolder->buffer[i] = sample * kScaleQ23ToFloat;","{'deleted_lines': ['  for (; i <= length / sampleSize; i++) {'], 'added_lines': ['  for (; i < std::min(trackHolder->bufferLength, length / sampleSize); i++) {']}",True,"In transcodeQ*ToFloat of btif_avrcp_audio_track.cc, there is a possible out of bounds write due to a missing bounds check. This could lead to paired device escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.",8.8,HIGH,2,test,,5
CVE-2023-40087,['CWE-787'],CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,android,"Add bounds checks in btif_avrcp_audio_track.cc

Fuzz testing reveals that the transcodeQ*ToFloat family of functions are
not bounds checked, causing a potential OOB write.

Check these functions against bounds of the destination array.

Bug: 275895309
Test: atest bluetooth_test_gd_unit, net_test_stack_btm
Tag: #security
Ignore-AOSP-First: Security
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:46803ae95d63ee133eae83d885e7c051964dc8ed)
Merged-In: I7a13261429797769cf5b913912a30e249668ac93
Change-Id: I7a13261429797769cf5b913912a30e249668ac93
",243fdf1c0d53bda9e829b4bec9f7c2a824b4d3d1,https://android.googlesource.com/platform/packages/modules/Bluetooth/+/243fdf1c0d53bda9e829b4bec9f7c2a824b4d3d1,system/btif/src/btif_avrcp_audio_track.cc,transcodeQ31ToFloat,"static size_t transcodeQ31ToFloat(uint8_t* buffer, size_t length,
BtifAvrcpAudioTrack* trackHolder) {
size_t sampleSize = sampleSizeFor(trackHolder);
size_t i = 0;
for (; i <= length / sampleSize; i++) {
trackHolder->buffer[i] = ((int32_t*)buffer)[i] * kScaleQ31ToFloat;
}
return i * sampleSize;
}","static size_t transcodeQ31ToFloat(uint8_t* VAR_0, size_t VAR_1,
BtifAvrcpAudioTrack* VAR_2) {
size_t VAR_3 = sampleSizeFor(VAR_2);
size_t VAR_4 = 0;
for (; VAR_4 <= VAR_1 / VAR_3; VAR_4++) {
VAR_2->buffer[VAR_4] = ((int32_t*)VAR_0)[VAR_4] * VAR_5;
}
return VAR_4 * VAR_3;
}",android/243fdf1c0d53bda9e829b4bec9f7c2a824b4d3d1/btif_avrcp_audio_track.cc/vul/before/1.json,"static size_t transcodeQ31ToFloat(uint8_t* buffer, size_t length,
                                  BtifAvrcpAudioTrack* trackHolder) {
  size_t sampleSize = sampleSizeFor(trackHolder);
  size_t i = 0;
  for (; i < std::min(trackHolder->bufferLength, length / sampleSize); i++) {
    trackHolder->buffer[i] = ((int32_t*)buffer)[i] * kScaleQ31ToFloat;
  }
  return i * sampleSize;
}","static size_t transcodeQ31ToFloat(uint8_t* VAR_0, size_t VAR_1,
                                  BtifAvrcpAudioTrack* VAR_2) {
  size_t VAR_3 = sampleSizeFor(VAR_2);
  size_t VAR_4 = 0;
  for (; VAR_4 < std::min(VAR_2->bufferLength, VAR_1 / VAR_3); VAR_4++) {
    VAR_2->buffer[VAR_4] = ((int32_t*)VAR_0)[VAR_4] * VAR_5;
  }
  return VAR_4 * VAR_3;
}",android/243fdf1c0d53bda9e829b4bec9f7c2a824b4d3d1/btif_avrcp_audio_track.cc/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
                                   BtifAvrcpAudioTrack* trackHolder) {
   size_t sampleSize = sampleSizeFor(trackHolder);
   size_t i = 0;
-  for (; i <= length / sampleSize; i++) {
+  for (; i < std::min(trackHolder->bufferLength, length / sampleSize); i++) {
     trackHolder->buffer[i] = ((int32_t*)buffer)[i] * kScaleQ31ToFloat;
   }
   return i * sampleSize;","{'deleted_lines': ['  for (; i <= length / sampleSize; i++) {'], 'added_lines': ['  for (; i < std::min(trackHolder->bufferLength, length / sampleSize); i++) {']}",True,"In transcodeQ*ToFloat of btif_avrcp_audio_track.cc, there is a possible out of bounds write due to a missing bounds check. This could lead to paired device escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.",8.8,HIGH,2,test,,5
CVE-2023-40087,['CWE-787'],CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H,1,android,"Add bounds checks in btif_avrcp_audio_track.cc

Fuzz testing reveals that the transcodeQ*ToFloat family of functions are
not bounds checked, causing a potential OOB write.

Check these functions against bounds of the destination array.

Bug: 275895309
Test: atest bluetooth_test_gd_unit, net_test_stack_btm
Tag: #security
Ignore-AOSP-First: Security
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:46803ae95d63ee133eae83d885e7c051964dc8ed)
Merged-In: I7a13261429797769cf5b913912a30e249668ac93
Change-Id: I7a13261429797769cf5b913912a30e249668ac93
",243fdf1c0d53bda9e829b4bec9f7c2a824b4d3d1,https://android.googlesource.com/platform/packages/modules/Bluetooth/+/243fdf1c0d53bda9e829b4bec9f7c2a824b4d3d1,system/btif/src/btif_avrcp_audio_track.cc,transcodeQ15ToFloat,"static size_t transcodeQ15ToFloat(uint8_t* buffer, size_t length,
BtifAvrcpAudioTrack* trackHolder) {
size_t sampleSize = sampleSizeFor(trackHolder);
size_t i = 0;
for (; i <= length / sampleSize; i++) {
trackHolder->buffer[i] = ((int16_t*)buffer)[i] * kScaleQ15ToFloat;
}
return i * sampleSize;
}","static size_t transcodeQ15ToFloat(uint8_t* VAR_0, size_t VAR_1,
BtifAvrcpAudioTrack* VAR_2) {
size_t VAR_3 = sampleSizeFor(VAR_2);
size_t VAR_4 = 0;
for (; VAR_4 <= VAR_1 / VAR_3; VAR_4++) {
VAR_2->buffer[VAR_4] = ((int16_t*)VAR_0)[VAR_4] * VAR_5;
}
return VAR_4 * VAR_3;
}",android/243fdf1c0d53bda9e829b4bec9f7c2a824b4d3d1/btif_avrcp_audio_track.cc/vul/before/2.json,"static size_t transcodeQ15ToFloat(uint8_t* buffer, size_t length,
                                  BtifAvrcpAudioTrack* trackHolder) {
  size_t sampleSize = sampleSizeFor(trackHolder);
  size_t i = 0;
  for (; i < std::min(trackHolder->bufferLength, length / sampleSize); i++) {
    trackHolder->buffer[i] = ((int16_t*)buffer)[i] * kScaleQ15ToFloat;
  }
  return i * sampleSize;
}","static size_t transcodeQ15ToFloat(uint8_t* VAR_0, size_t VAR_1,
                                  BtifAvrcpAudioTrack* VAR_2) {
  size_t VAR_3 = sampleSizeFor(VAR_2);
  size_t VAR_4 = 0;
  for (; VAR_4 < std::min(VAR_2->bufferLength, VAR_1 / VAR_3); VAR_4++) {
    VAR_2->buffer[VAR_4] = ((int16_t*)VAR_0)[VAR_4] * VAR_5;
  }
  return VAR_4 * VAR_3;
}",android/243fdf1c0d53bda9e829b4bec9f7c2a824b4d3d1/btif_avrcp_audio_track.cc/vul/after/2.json,"--- func_before
+++ func_after
@@ -2,7 +2,7 @@
                                   BtifAvrcpAudioTrack* trackHolder) {
   size_t sampleSize = sampleSizeFor(trackHolder);
   size_t i = 0;
-  for (; i <= length / sampleSize; i++) {
+  for (; i < std::min(trackHolder->bufferLength, length / sampleSize); i++) {
     trackHolder->buffer[i] = ((int16_t*)buffer)[i] * kScaleQ15ToFloat;
   }
   return i * sampleSize;","{'deleted_lines': ['  for (; i <= length / sampleSize; i++) {'], 'added_lines': ['  for (; i < std::min(trackHolder->bufferLength, length / sampleSize); i++) {']}",True,"In transcodeQ*ToFloat of btif_avrcp_audio_track.cc, there is a possible out of bounds write due to a missing bounds check. This could lead to paired device escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.",8.8,HIGH,2,test,,5
CVE-2023-40091,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,android,"Use readUniqueFileDescriptor in incidentd service

readFileDescriptor doesn't provide ownership of the fds. fdopen
needs ownership of the fds. Fds read from parcel should be duped
in this scenario and readUniqueFileDescriptor dups fds internally.

Test: m incidentd_service_fuzzer && adb sync data && adb shell /data/fuzz/x86_64/incidentd_service_fuzzer/incidentd_service_fuzzer
Test: atest incidentd_test
Bug: 286931110
Bug: 283699145

(cherry picked from commit ba78ef276951269f7b024baebdf1b8fa40bedb23)
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:6fe75d9d37321843ebae8a34a049f4d3f24e1965)
Merged-In: Ibe03a17dee91ac5bf25d123d4fd9c0bdd3c7d80e
Change-Id: Ibe03a17dee91ac5bf25d123d4fd9c0bdd3c7d80e
",0ec7b119d41adcbba23f9349e16de9e7e11683f6,https://android.googlesource.com/platform/frameworks/base/+/0ec7b119d41adcbba23f9349e16de9e7e11683f6,cmds/incidentd/src/IncidentService.cpp,IncidentService::onTransact,"status_t IncidentService::onTransact(uint32_t code, const Parcel& data, Parcel* reply,
uint32_t flags) {
status_t err;
switch (code) {
case SHELL_COMMAND_TRANSACTION: {
int in = data.readFileDescriptor();
int out = data.readFileDescriptor();
int err = data.readFileDescriptor();
int argc = data.readInt32();
Vector<String8> args;
for (int i = 0; i < argc && data.dataAvail() > 0; i++) {
args.add(String8(data.readString16()));
}
sp<IShellCallback> shellCallback = IShellCallback::asInterface(data.readStrongBinder());
sp<IResultReceiver> resultReceiver =
IResultReceiver::asInterface(data.readStrongBinder());
FILE* fin = fdopen(in, ""r"");
FILE* fout = fdopen(out, ""w"");
FILE* ferr = fdopen(err, ""w"");
if (fin == NULL || fout == NULL || ferr == NULL) {
resultReceiver->send(NO_MEMORY);
} else {
err = command(fin, fout, ferr, args);
resultReceiver->send(err);
}
if (fin != NULL) {
fflush(fin);
fclose(fin);
}
if (fout != NULL) {
fflush(fout);
fclose(fout);
}
if (fout != NULL) {
fflush(ferr);
fclose(ferr);
}
return NO_ERROR;
} break;
default: { return BnIncidentManager::onTransact(code, data, reply, flags); }
}
}","status_t IncidentService::onTransact(uint32_t VAR_0, const Parcel& VAR_1, Parcel* VAR_2,
uint32_t VAR_3) {
status_t VAR_4;
switch (VAR_0) {
case VAR_5: {
int VAR_6 = VAR_1.readFileDescriptor();
int VAR_7 = VAR_1.readFileDescriptor();
int VAR_4 = VAR_1.readFileDescriptor();
int VAR_8 = VAR_1.readInt32();
Vector<String8> VAR_9;
for (int VAR_10 = 0; VAR_10 < VAR_8 && VAR_1.dataAvail() > 0; VAR_10++) {
VAR_9.add(String8(VAR_1.readString16()));
}
sp<IShellCallback> VAR_11 = IShellCallback::asInterface(VAR_1.readStrongBinder());
sp<IResultReceiver> VAR_12 =
IResultReceiver::asInterface(VAR_1.readStrongBinder());
FILE* VAR_13 = fdopen(VAR_6, ""r"");
FILE* VAR_14 = fdopen(VAR_7, ""w"");
FILE* VAR_15 = fdopen(VAR_4, ""w"");
if (VAR_13 == NULL || VAR_14 == NULL || VAR_15 == NULL) {
VAR_12->send(VAR_16);
} else {
VAR_4 = command(VAR_13, VAR_14, VAR_15, VAR_9);
VAR_12->send(VAR_4);
}
if (VAR_13 != NULL) {
fflush(VAR_13);
fclose(VAR_13);
}
if (VAR_14 != NULL) {
fflush(VAR_14);
fclose(VAR_14);
}
if (VAR_14 != NULL) {
fflush(VAR_15);
fclose(VAR_15);
}
return VAR_17;
} break;
default: { return BnIncidentManager::onTransact(VAR_0, VAR_1, VAR_2, VAR_3); }
}
}",android/0ec7b119d41adcbba23f9349e16de9e7e11683f6/IncidentService.cpp/vul/before/0.json,"status_t IncidentService::onTransact(uint32_t code, const Parcel& data, Parcel* reply,
                                     uint32_t flags) {
    status_t err;

    switch (code) {
        case SHELL_COMMAND_TRANSACTION: {
            unique_fd in, out, err;
            if (status_t status = data.readUniqueFileDescriptor(&in); status != OK) return status;

            if (status_t status = data.readUniqueFileDescriptor(&out); status != OK) return status;

            if (status_t status = data.readUniqueFileDescriptor(&err); status != OK) return status;

            int argc = data.readInt32();
            Vector<String8> args;
            for (int i = 0; i < argc && data.dataAvail() > 0; i++) {
                args.add(String8(data.readString16()));
            }
            sp<IShellCallback> shellCallback = IShellCallback::asInterface(data.readStrongBinder());
            sp<IResultReceiver> resultReceiver =
                    IResultReceiver::asInterface(data.readStrongBinder());

            FILE* fin = fdopen(in.release(), ""r"");
            FILE* fout = fdopen(out.release(), ""w"");
            FILE* ferr = fdopen(err.release(), ""w"");

            if (fin == NULL || fout == NULL || ferr == NULL) {
                resultReceiver->send(NO_MEMORY);
            } else {
                status_t result = command(fin, fout, ferr, args);
                resultReceiver->send(result);
            }

            if (fin != NULL) {
                fflush(fin);
                fclose(fin);
            }
            if (fout != NULL) {
                fflush(fout);
                fclose(fout);
            }
            if (fout != NULL) {
                fflush(ferr);
                fclose(ferr);
            }

            return NO_ERROR;
        } break;
        default: { return BnIncidentManager::onTransact(code, data, reply, flags); }
    }
}","status_t IncidentService::onTransact(uint32_t VAR_0, const Parcel& VAR_1, Parcel* VAR_2,
                                     uint32_t VAR_3) {
    status_t VAR_4;

    switch (VAR_0) {
        case VAR_5: {
            unique_fd VAR_6, VAR_7, VAR_4;
            if (status_t VAR_8 = VAR_1.readUniqueFileDescriptor(&VAR_6); VAR_8 != VAR_9) return VAR_8;

            if (status_t VAR_8 = VAR_1.readUniqueFileDescriptor(&VAR_7); VAR_8 != VAR_9) return VAR_8;

            if (status_t VAR_8 = VAR_1.readUniqueFileDescriptor(&VAR_4); VAR_8 != VAR_9) return VAR_8;

            int VAR_10 = VAR_1.readInt32();
            Vector<String8> VAR_11;
            for (int VAR_12 = 0; VAR_12 < VAR_10 && VAR_1.dataAvail() > 0; VAR_12++) {
                VAR_11.add(String8(VAR_1.readString16()));
            }
            sp<IShellCallback> VAR_13 = IShellCallback::asInterface(VAR_1.readStrongBinder());
            sp<IResultReceiver> VAR_14 =
                    IResultReceiver::asInterface(VAR_1.readStrongBinder());

            FILE* VAR_15 = fdopen(VAR_6.release(), ""r"");
            FILE* VAR_16 = fdopen(VAR_7.release(), ""w"");
            FILE* VAR_17 = fdopen(VAR_4.release(), ""w"");

            if (VAR_15 == NULL || VAR_16 == NULL || VAR_17 == NULL) {
                VAR_14->send(VAR_18);
            } else {
                status_t VAR_19 = command(VAR_15, VAR_16, VAR_17, VAR_11);
                VAR_14->send(VAR_19);
            }

            if (VAR_15 != NULL) {
                fflush(VAR_15);
                fclose(VAR_15);
            }
            if (VAR_16 != NULL) {
                fflush(VAR_16);
                fclose(VAR_16);
            }
            if (VAR_16 != NULL) {
                fflush(VAR_17);
                fclose(VAR_17);
            }

            return VAR_20;
        } break;
        default: { return BnIncidentManager::onTransact(VAR_0, VAR_1, VAR_2, VAR_3); }
    }
}",android/0ec7b119d41adcbba23f9349e16de9e7e11683f6/IncidentService.cpp/vul/after/0.json,"--- func_before
+++ func_after
@@ -4,9 +4,13 @@
 
     switch (code) {
         case SHELL_COMMAND_TRANSACTION: {
-            int in = data.readFileDescriptor();
-            int out = data.readFileDescriptor();
-            int err = data.readFileDescriptor();
+            unique_fd in, out, err;
+            if (status_t status = data.readUniqueFileDescriptor(&in); status != OK) return status;
+
+            if (status_t status = data.readUniqueFileDescriptor(&out); status != OK) return status;
+
+            if (status_t status = data.readUniqueFileDescriptor(&err); status != OK) return status;
+
             int argc = data.readInt32();
             Vector<String8> args;
             for (int i = 0; i < argc && data.dataAvail() > 0; i++) {
@@ -16,15 +20,15 @@
             sp<IResultReceiver> resultReceiver =
                     IResultReceiver::asInterface(data.readStrongBinder());
 
-            FILE* fin = fdopen(in, ""r"");
-            FILE* fout = fdopen(out, ""w"");
-            FILE* ferr = fdopen(err, ""w"");
+            FILE* fin = fdopen(in.release(), ""r"");
+            FILE* fout = fdopen(out.release(), ""w"");
+            FILE* ferr = fdopen(err.release(), ""w"");
 
             if (fin == NULL || fout == NULL || ferr == NULL) {
                 resultReceiver->send(NO_MEMORY);
             } else {
-                err = command(fin, fout, ferr, args);
-                resultReceiver->send(err);
+                status_t result = command(fin, fout, ferr, args);
+                resultReceiver->send(result);
             }
 
             if (fin != NULL) {","{'deleted_lines': ['            int in = data.readFileDescriptor();', '            int out = data.readFileDescriptor();', '            int err = data.readFileDescriptor();', '            FILE* fin = fdopen(in, ""r"");', '            FILE* fout = fdopen(out, ""w"");', '            FILE* ferr = fdopen(err, ""w"");', '                err = command(fin, fout, ferr, args);', '                resultReceiver->send(err);'], 'added_lines': ['            unique_fd in, out, err;', '            if (status_t status = data.readUniqueFileDescriptor(&in); status != OK) return status;', '', '            if (status_t status = data.readUniqueFileDescriptor(&out); status != OK) return status;', '', '            if (status_t status = data.readUniqueFileDescriptor(&err); status != OK) return status;', '', '            FILE* fin = fdopen(in.release(), ""r"");', '            FILE* fout = fdopen(out.release(), ""w"");', '            FILE* ferr = fdopen(err.release(), ""w"");', '                status_t result = command(fin, fout, ferr, args);', '                resultReceiver->send(result);']}",True,"In onTransact of IncidentService.cpp, there is a possible out of bounds write due to memory corruption. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.",7.8,HIGH,2,test,,5
CVE-2023-45775,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,android,"Fix 2 OOB bugs in CreateAudioBroadcast

Bug: 275340684
Bug: 282234870
Test: manual
Ignore-AOSP-First: security
Tag: #security
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:5f9059acdfed500ea5ff4b159795280d5fa2ecbf)
Merged-In: Ia8e9c3a3e534f419b6bd6c902a35d2caf4c7727b
Change-Id: Ia8e9c3a3e534f419b6bd6c902a35d2caf4c7727b
",8e3b3fc918b3ea77754c6d82ab0f09cce81e145b,https://android.googlesource.com/platform/packages/modules/Bluetooth/+/8e3b3fc918b3ea77754c6d82ab0f09cce81e145b,system/bta/le_audio/broadcaster/broadcaster.cc,CreateAudioBroadcast,"void CreateAudioBroadcast(
bool is_public, const std::string& broadcast_name,
const std::optional<bluetooth::le_audio::BroadcastCode>& broadcast_code,
const std::vector<uint8_t>& public_metadata,
const std::vector<uint8_t>& subgroup_quality,
const std::vector<std::vector<uint8_t>>& subgroup_metadata) override {
uint8_t public_features = 0;
LeAudioLtvMap public_ltv;
std::vector<LeAudioLtvMap> subgroup_ltvs;
if (is_public) {
bool is_metadata_valid;
public_ltv = LeAudioLtvMap::Parse(
public_metadata.data(), public_metadata.size(), is_metadata_valid);
if (!is_metadata_valid) {
LOG_ERROR(""Invalid metadata provided."");
return;
}
public_features = static_cast<uint8_t>(broadcast_code ? 1 : 0);
}
auto broadcast_id = available_broadcast_ids_.back();
available_broadcast_ids_.pop_back();
if (available_broadcast_ids_.size() == 0) GenerateBroadcastIds();
auto context_type = AudioContexts(LeAudioContextType::MEDIA);
if (stack_config_get_interface()
->get_pts_force_le_audio_multiple_contexts_metadata()) {
context_type =
LeAudioContextType::MEDIA | LeAudioContextType::CONVERSATIONAL;
}
for (const uint8_t quality : subgroup_quality) {
if (quality == bluetooth::le_audio::QUALITY_STANDARD) {
public_features |= bluetooth::le_audio::kLeAudioQualityStandard;
} else if (quality == bluetooth::le_audio::QUALITY_HIGH) {
public_features |= bluetooth::le_audio::kLeAudioQualityHigh;
}
}
for (const std::vector<uint8_t>& metadata : subgroup_metadata) {
bool is_metadata_valid;
auto ltv = LeAudioLtvMap::Parse(metadata.data(), metadata.size(), is_metadata_valid);
if (!is_metadata_valid) {
LOG_ERROR(""Invalid metadata provided."");
return;
}
if (stack_config_get_interface()
->get_pts_force_le_audio_multiple_contexts_metadata()) {
auto stream_context_vec = ltv.Find(
le_audio::types::kLeAudioMetadataTypeStreamingAudioContext);
if (stream_context_vec) {
auto pp = stream_context_vec.value().data();
UINT16_TO_STREAM(pp, context_type.value());
}
}
auto stream_context_vec =
ltv.Find(le_audio::types::kLeAudioMetadataTypeStreamingAudioContext);
if (stream_context_vec) {
auto pp = stream_context_vec.value().data();
STREAM_TO_UINT16(context_type.value_ref(), pp);
}
auto ccid_vec =
ContentControlIdKeeper::GetInstance()->GetAllCcids(context_type);
if (!ccid_vec.empty()) {
ltv.Add(le_audio::types::kLeAudioMetadataTypeCcidList, ccid_vec);
}
subgroup_ltvs.push_back(ltv);
}
if (CodecManager::GetInstance()->GetCodecLocation() ==
CodecLocation::ADSP) {
auto offload_config =
CodecManager::GetInstance()->GetBroadcastOffloadConfig();
if (offload_config == nullptr) {
LOG_ERROR(""No valid broadcast offload config"");
return;
}
BroadcastCodecWrapper codec_config(
{.coding_format = le_audio::types::kLeAudioCodingFormatLC3,
.vendor_company_id =
le_audio::types::kLeAudioVendorCompanyIdUndefined,
.vendor_codec_id = le_audio::types::kLeAudioVendorCodecIdUndefined},
{.num_channels =
static_cast<uint8_t>(offload_config->stream_map.size()),
.sample_rate = offload_config->sampling_rate,
.bits_per_sample = offload_config->bits_per_sample,
.data_interval_us = offload_config->frame_duration},
offload_config->codec_bitrate, offload_config->octets_per_frame);
BroadcastQosConfig qos_config(offload_config->retransmission_number,
offload_config->max_transport_latency);
BroadcastStateMachineConfig msg = {
.is_public = is_public,
.broadcast_name = broadcast_name,
.broadcast_id = broadcast_id,
.streaming_phy = GetStreamingPhy(),
.codec_wrapper = codec_config,
.qos_config = qos_config,
.announcement = prepareBasicAnnouncement(codec_config, subgroup_ltvs),
.broadcast_code = std::move(broadcast_code)};
if (is_public) {
msg.public_announcement =
preparePublicAnnouncement(public_features, public_ltv);
}
pending_broadcasts_.push_back(
std::move(BroadcastStateMachine::CreateInstance(std::move(msg))));
} else {
auto codec_qos_pair =
le_audio::broadcaster::getStreamConfigForContext(context_type);
BroadcastStateMachineConfig msg = {
.is_public = is_public,
.broadcast_name = broadcast_name,
.broadcast_id = broadcast_id,
.streaming_phy = GetStreamingPhy(),
.codec_wrapper = codec_qos_pair.first,
.qos_config = codec_qos_pair.second,
.announcement =
prepareBasicAnnouncement(codec_qos_pair.first, subgroup_ltvs),
.broadcast_code = std::move(broadcast_code)};
if (is_public) {
msg.public_announcement =
preparePublicAnnouncement(public_features, public_ltv);
}
pending_broadcasts_.push_back(
std::move(BroadcastStateMachine::CreateInstance(std::move(msg))));
}
LOG_INFO(""CreateAudioBroadcast"");
if (!pending_broadcasts_.back()->Initialize()) {
pending_broadcasts_.pop_back();
callbacks_->OnBroadcastCreated(bluetooth::le_audio::kBroadcastIdInvalid,
false);
}
}","void CreateAudioBroadcast(
bool VAR_0, const std::string& VAR_1,
const std::optional<bluetooth::le_audio::BroadcastCode>& VAR_2,
const std::vector<uint8_t>& VAR_3,
const std::vector<uint8_t>& VAR_4,
const std::vector<std::vector<uint8_t>>& VAR_5) override {
uint8_t VAR_6 = 0;
LeAudioLtvMap VAR_7;
std::vector<LeAudioLtvMap> VAR_8;
if (VAR_0) {
bool VAR_9;
VAR_7 = LeAudioLtvMap::Parse(
VAR_3.data(), VAR_3.size(), VAR_9);
if (!VAR_9) {
LOG_ERROR(""Invalid metadata provided."");
return;
}
VAR_6 = VAR_10<uint8_t>(VAR_2 ? 1 : 0);
}
auto VAR_11 = VAR_12.back();
VAR_12.pop_back();
if (VAR_12.size() == 0) GenerateBroadcastIds();
auto VAR_13 = AudioContexts(LeAudioContextType::MEDIA);
if (stack_config_get_interface()
->get_pts_force_le_audio_multiple_contexts_metadata()) {
VAR_13 =
LeAudioContextType::MEDIA | LeAudioContextType::CONVERSATIONAL;
}
for (const uint8_t VAR_14 : VAR_4) {
if (VAR_14 == bluetooth::le_audio::QUALITY_STANDARD) {
VAR_6 |= bluetooth::le_audio::kLeAudioQualityStandard;
} else if (VAR_14 == bluetooth::le_audio::QUALITY_HIGH) {
VAR_6 |= bluetooth::le_audio::kLeAudioQualityHigh;
}
}
for (const std::vector<uint8_t>& VAR_15 : VAR_5) {
bool VAR_9;
auto VAR_16 = LeAudioLtvMap::Parse(VAR_15.data(), VAR_15.size(), VAR_9);
if (!VAR_9) {
LOG_ERROR(""Invalid metadata provided."");
return;
}
if (stack_config_get_interface()
->get_pts_force_le_audio_multiple_contexts_metadata()) {
auto VAR_17 = VAR_16.Find(
le_audio::types::kLeAudioMetadataTypeStreamingAudioContext);
if (VAR_17) {
auto VAR_18 = VAR_17.value().data();
UINT16_TO_STREAM(VAR_18, VAR_13.value());
}
}
auto VAR_17 =
VAR_16.Find(le_audio::types::kLeAudioMetadataTypeStreamingAudioContext);
if (VAR_17) {
auto VAR_18 = VAR_17.value().data();
STREAM_TO_UINT16(VAR_13.value_ref(), VAR_18);
}
auto VAR_19 =
ContentControlIdKeeper::GetInstance()->GetAllCcids(VAR_13);
if (!VAR_19.empty()) {
VAR_16.Add(le_audio::types::kLeAudioMetadataTypeCcidList, VAR_19);
}
VAR_8.push_back(VAR_16);
}
if (CodecManager::GetInstance()->GetCodecLocation() ==
CodecLocation::ADSP) {
auto VAR_20 =
CodecManager::GetInstance()->GetBroadcastOffloadConfig();
if (VAR_20 == nullptr) {
LOG_ERROR(""No valid broadcast offload config"");
return;
}
BroadcastCodecWrapper VAR_21(
{.coding_format = le_audio::types::kLeAudioCodingFormatLC3,
.vendor_company_id =
le_audio::types::kLeAudioVendorCompanyIdUndefined,
.vendor_codec_id = le_audio::types::kLeAudioVendorCodecIdUndefined},
{.num_channels =
VAR_10<uint8_t>(VAR_20->stream_map.size()),
.sample_rate = VAR_20->sampling_rate,
.bits_per_sample = VAR_20->bits_per_sample,
.data_interval_us = VAR_20->frame_duration},
VAR_20->codec_bitrate, VAR_20->octets_per_frame);
BroadcastQosConfig VAR_22(VAR_20->retransmission_number,
VAR_20->max_transport_latency);
BroadcastStateMachineConfig VAR_23 = {
.is_public = VAR_0,
.broadcast_name = VAR_1,
.broadcast_id = VAR_11,
.streaming_phy = GetStreamingPhy(),
.codec_wrapper = VAR_21,
.qos_config = VAR_22,
.announcement = prepareBasicAnnouncement(VAR_21, VAR_8),
.broadcast_code = std::move(VAR_2)};
if (VAR_0) {
VAR_23.public_announcement =
preparePublicAnnouncement(VAR_6, VAR_7);
}
VAR_24.push_back(
std::move(BroadcastStateMachine::CreateInstance(std::move(VAR_23))));
} else {
auto VAR_25 =
le_audio::broadcaster::getStreamConfigForContext(VAR_13);
BroadcastStateMachineConfig VAR_23 = {
.is_public = VAR_0,
.broadcast_name = VAR_1,
.broadcast_id = VAR_11,
.streaming_phy = GetStreamingPhy(),
.codec_wrapper = VAR_25.first,
.qos_config = VAR_25.second,
.announcement =
prepareBasicAnnouncement(VAR_25.first, VAR_8),
.broadcast_code = std::move(VAR_2)};
if (VAR_0) {
VAR_23.public_announcement =
preparePublicAnnouncement(VAR_6, VAR_7);
}
VAR_24.push_back(
std::move(BroadcastStateMachine::CreateInstance(std::move(VAR_23))));
}
LOG_INFO(""CreateAudioBroadcast"");
if (!VAR_24.back()->Initialize()) {
VAR_24.pop_back();
VAR_26->OnBroadcastCreated(bluetooth::le_audio::kBroadcastIdInvalid,
false);
}
}",,"void CreateAudioBroadcast(
      bool is_public, const std::string& broadcast_name,
      const std::optional<bluetooth::le_audio::BroadcastCode>& broadcast_code,
      const std::vector<uint8_t>& public_metadata,
      const std::vector<uint8_t>& subgroup_quality,
      const std::vector<std::vector<uint8_t>>& subgroup_metadata) override {
    uint8_t public_features = 0;
    LeAudioLtvMap public_ltv;
    std::vector<LeAudioLtvMap> subgroup_ltvs;

    if (is_public) {
      // Prepare public broadcast announcement format
      bool is_metadata_valid;
      public_ltv = LeAudioLtvMap::Parse(
          public_metadata.data(), public_metadata.size(), is_metadata_valid);
      if (!is_metadata_valid) {
        LOG_ERROR(""Invalid metadata provided."");
        return;
      }
      // Prepare public features byte
      // bit 0 Encryption broadcast stream encrypted or not
      // bit 1 Standard quality audio configuration present or not
      // bit 2 High quality audio configuration present or not
      // bit 3-7 RFU
      public_features = static_cast<uint8_t>(broadcast_code ? 1 : 0);
    }

    auto broadcast_id = available_broadcast_ids_.back();
    available_broadcast_ids_.pop_back();
    if (available_broadcast_ids_.size() == 0) GenerateBroadcastIds();

    auto context_type = AudioContexts(LeAudioContextType::MEDIA);

    /* Adds multiple contexts and CCIDs regardless of the incoming audio
     * context. Android has only two CCIDs, one for Media and one for
     * Conversational context. Even though we are not broadcasting
     * Conversational streams, some PTS test cases wants multiple CCIDs.
     */
    if (stack_config_get_interface()
            ->get_pts_force_le_audio_multiple_contexts_metadata()) {
      context_type =
          LeAudioContextType::MEDIA | LeAudioContextType::CONVERSATIONAL;
    }

    for (const uint8_t quality : subgroup_quality) {
      if (quality == bluetooth::le_audio::QUALITY_STANDARD) {
        public_features |= bluetooth::le_audio::kLeAudioQualityStandard;
      } else if (quality == bluetooth::le_audio::QUALITY_HIGH) {
        public_features |= bluetooth::le_audio::kLeAudioQualityHigh;
      }
    }

    for (const std::vector<uint8_t>& metadata : subgroup_metadata) {
      /* Prepare the announcement format */
      bool is_metadata_valid;
      auto ltv = LeAudioLtvMap::Parse(metadata.data(), metadata.size(), is_metadata_valid);
      if (!is_metadata_valid) {
        LOG_ERROR(""Invalid metadata provided."");
        return;
      }

      if (stack_config_get_interface()
              ->get_pts_force_le_audio_multiple_contexts_metadata()) {
        auto stream_context_vec = ltv.Find(
            le_audio::types::kLeAudioMetadataTypeStreamingAudioContext);
        if (stream_context_vec) {
          if (stream_context_vec.value().size() < 2) {
            LOG_ERROR(""kLeAudioMetadataTypeStreamingAudioContext size < 2"");
            return;
          }
          auto pp = stream_context_vec.value().data();
          UINT16_TO_STREAM(pp, context_type.value());
        }
      }

      auto stream_context_vec =
          ltv.Find(le_audio::types::kLeAudioMetadataTypeStreamingAudioContext);
      if (stream_context_vec) {
        if (stream_context_vec.value().size() < 2) {
          LOG_ERROR(""kLeAudioMetadataTypeStreamingAudioContext size < 2"");
          return;
        }

        auto pp = stream_context_vec.value().data();
        STREAM_TO_UINT16(context_type.value_ref(), pp);
      }

      // Append the CCID list
      auto ccid_vec =
          ContentControlIdKeeper::GetInstance()->GetAllCcids(context_type);
      if (!ccid_vec.empty()) {
        ltv.Add(le_audio::types::kLeAudioMetadataTypeCcidList, ccid_vec);
      }

      // Push to subgroup ltvs
      subgroup_ltvs.push_back(ltv);
    }

    if (CodecManager::GetInstance()->GetCodecLocation() ==
        CodecLocation::ADSP) {
      auto offload_config =
          CodecManager::GetInstance()->GetBroadcastOffloadConfig();
      if (offload_config == nullptr) {
        LOG_ERROR(""No valid broadcast offload config"");
        return;
      }
      BroadcastCodecWrapper codec_config(
          {.coding_format = le_audio::types::kLeAudioCodingFormatLC3,
           .vendor_company_id =
               le_audio::types::kLeAudioVendorCompanyIdUndefined,
           .vendor_codec_id = le_audio::types::kLeAudioVendorCodecIdUndefined},
          {.num_channels =
               static_cast<uint8_t>(offload_config->stream_map.size()),
           .sample_rate = offload_config->sampling_rate,
           .bits_per_sample = offload_config->bits_per_sample,
           .data_interval_us = offload_config->frame_duration},
          offload_config->codec_bitrate, offload_config->octets_per_frame);
      BroadcastQosConfig qos_config(offload_config->retransmission_number,
                                    offload_config->max_transport_latency);

      BroadcastStateMachineConfig msg = {
          .is_public = is_public,
          .broadcast_name = broadcast_name,
          .broadcast_id = broadcast_id,
          .streaming_phy = GetStreamingPhy(),
          .codec_wrapper = codec_config,
          .qos_config = qos_config,
          .announcement = prepareBasicAnnouncement(codec_config, subgroup_ltvs),
          .broadcast_code = std::move(broadcast_code)};
      if (is_public) {
        msg.public_announcement =
            preparePublicAnnouncement(public_features, public_ltv);
      }
      pending_broadcasts_.push_back(
          std::move(BroadcastStateMachine::CreateInstance(std::move(msg))));
    } else {
      auto codec_qos_pair =
          le_audio::broadcaster::getStreamConfigForContext(context_type);
      BroadcastStateMachineConfig msg = {
          .is_public = is_public,
          .broadcast_name = broadcast_name,
          .broadcast_id = broadcast_id,
          .streaming_phy = GetStreamingPhy(),
          .codec_wrapper = codec_qos_pair.first,
          .qos_config = codec_qos_pair.second,
          .announcement =
              prepareBasicAnnouncement(codec_qos_pair.first, subgroup_ltvs),
          .broadcast_code = std::move(broadcast_code)};
      if (is_public) {
        msg.public_announcement =
            preparePublicAnnouncement(public_features, public_ltv);
      }
      /* Create the broadcaster instance - we'll receive it's init state in the
       * async callback
       */
      pending_broadcasts_.push_back(
          std::move(BroadcastStateMachine::CreateInstance(std::move(msg))));
    }

    LOG_INFO(""CreateAudioBroadcast"");

    // Notify the error instead just fail silently
    if (!pending_broadcasts_.back()->Initialize()) {
      pending_broadcasts_.pop_back();
      callbacks_->OnBroadcastCreated(bluetooth::le_audio::kBroadcastIdInvalid,
                                     false);
    }
  }","void CreateAudioBroadcast(
      bool VAR_0, const std::string& VAR_1,
      const std::optional<bluetooth::le_audio::BroadcastCode>& VAR_2,
      const std::vector<uint8_t>& VAR_3,
      const std::vector<uint8_t>& VAR_4,
      const std::vector<std::vector<uint8_t>>& VAR_5) override {
    uint8_t VAR_6 = 0;
    LeAudioLtvMap VAR_7;
    std::vector<LeAudioLtvMap> VAR_8;

    if (VAR_0) {
      /* COMMENT_0 */
      bool VAR_9;
      VAR_7 = LeAudioLtvMap::Parse(
          VAR_3.data(), VAR_3.size(), VAR_9);
      if (!VAR_9) {
        LOG_ERROR(""Invalid metadata provided."");
        return;
      }
      /* COMMENT_1 */
      /* COMMENT_2 */
      /* COMMENT_3 */
      /* COMMENT_4 */
      /* COMMENT_5 */
      VAR_6 = VAR_10<uint8_t>(VAR_2 ? 1 : 0);
    }

    auto VAR_11 = VAR_12.back();
    VAR_12.pop_back();
    if (VAR_12.size() == 0) GenerateBroadcastIds();

    auto VAR_13 = AudioContexts(LeAudioContextType::MEDIA);

    /* COMMENT_6 */
                                                                     
                                                                  
                                                                        
       
    if (stack_config_get_interface()
            ->get_pts_force_le_audio_multiple_contexts_metadata()) {
      VAR_13 =
          LeAudioContextType::MEDIA | LeAudioContextType::CONVERSATIONAL;
    }

    for (const uint8_t VAR_14 : VAR_4) {
      if (VAR_14 == bluetooth::le_audio::QUALITY_STANDARD) {
        VAR_6 |= bluetooth::le_audio::kLeAudioQualityStandard;
      } else if (VAR_14 == bluetooth::le_audio::QUALITY_HIGH) {
        VAR_6 |= bluetooth::le_audio::kLeAudioQualityHigh;
      }
    }

    for (const std::vector<uint8_t>& VAR_15 : VAR_5) {
      /* COMMENT_11 */
      bool VAR_9;
      auto VAR_16 = LeAudioLtvMap::Parse(VAR_15.data(), VAR_15.size(), VAR_9);
      if (!VAR_9) {
        LOG_ERROR(""Invalid metadata provided."");
        return;
      }

      if (stack_config_get_interface()
              ->get_pts_force_le_audio_multiple_contexts_metadata()) {
        auto VAR_17 = VAR_16.Find(
            le_audio::types::kLeAudioMetadataTypeStreamingAudioContext);
        if (VAR_17) {
          if (VAR_17.value().size() < 2) {
            LOG_ERROR(""kLeAudioMetadataTypeStreamingAudioContext size < 2"");
            return;
          }
          auto VAR_18 = VAR_17.value().data();
          UINT16_TO_STREAM(VAR_18, VAR_13.value());
        }
      }

      auto VAR_17 =
          VAR_16.Find(le_audio::types::kLeAudioMetadataTypeStreamingAudioContext);
      if (VAR_17) {
        if (VAR_17.value().size() < 2) {
          LOG_ERROR(""kLeAudioMetadataTypeStreamingAudioContext size < 2"");
          return;
        }

        auto VAR_18 = VAR_17.value().data();
        STREAM_TO_UINT16(VAR_13.value_ref(), VAR_18);
      }

      /* COMMENT_12 */
      auto VAR_19 =
          ContentControlIdKeeper::GetInstance()->GetAllCcids(VAR_13);
      if (!VAR_19.empty()) {
        VAR_16.Add(le_audio::types::kLeAudioMetadataTypeCcidList, VAR_19);
      }

      /* COMMENT_13 */
      VAR_8.push_back(VAR_16);
    }

    if (CodecManager::GetInstance()->GetCodecLocation() ==
        CodecLocation::ADSP) {
      auto VAR_20 =
          CodecManager::GetInstance()->GetBroadcastOffloadConfig();
      if (VAR_20 == nullptr) {
        LOG_ERROR(""No valid broadcast offload config"");
        return;
      }
      BroadcastCodecWrapper VAR_21(
          {.coding_format = le_audio::types::kLeAudioCodingFormatLC3,
           .vendor_company_id =
               le_audio::types::kLeAudioVendorCompanyIdUndefined,
           .vendor_codec_id = le_audio::types::kLeAudioVendorCodecIdUndefined},
          {.num_channels =
               VAR_10<uint8_t>(VAR_20->stream_map.size()),
           .sample_rate = VAR_20->sampling_rate,
           .bits_per_sample = VAR_20->bits_per_sample,
           .data_interval_us = VAR_20->frame_duration},
          VAR_20->codec_bitrate, VAR_20->octets_per_frame);
      BroadcastQosConfig VAR_22(VAR_20->retransmission_number,
                                    VAR_20->max_transport_latency);

      BroadcastStateMachineConfig VAR_23 = {
          .is_public = VAR_0,
          .broadcast_name = VAR_1,
          .broadcast_id = VAR_11,
          .streaming_phy = GetStreamingPhy(),
          .codec_wrapper = VAR_21,
          .qos_config = VAR_22,
          .announcement = prepareBasicAnnouncement(VAR_21, VAR_8),
          .broadcast_code = std::move(VAR_2)};
      if (VAR_0) {
        VAR_23.public_announcement =
            preparePublicAnnouncement(VAR_6, VAR_7);
      }
      VAR_24.push_back(
          std::move(BroadcastStateMachine::CreateInstance(std::move(VAR_23))));
    } else {
      auto VAR_25 =
          le_audio::broadcaster::getStreamConfigForContext(VAR_13);
      BroadcastStateMachineConfig VAR_23 = {
          .is_public = VAR_0,
          .broadcast_name = VAR_1,
          .broadcast_id = VAR_11,
          .streaming_phy = GetStreamingPhy(),
          .codec_wrapper = VAR_25.first,
          .qos_config = VAR_25.second,
          .announcement =
              prepareBasicAnnouncement(VAR_25.first, VAR_8),
          .broadcast_code = std::move(VAR_2)};
      if (VAR_0) {
        VAR_23.public_announcement =
            preparePublicAnnouncement(VAR_6, VAR_7);
      }
      /* COMMENT_14 */
                       
         
      VAR_24.push_back(
          std::move(BroadcastStateMachine::CreateInstance(std::move(VAR_23))));
    }

    LOG_INFO(""CreateAudioBroadcast"");

    /* COMMENT_17 */
    if (!VAR_24.back()->Initialize()) {
      VAR_24.pop_back();
      VAR_26->OnBroadcastCreated(bluetooth::le_audio::kBroadcastIdInvalid,
                                     false);
    }
  }",,"--- func_before
+++ func_after
@@ -64,6 +64,10 @@
         auto stream_context_vec = ltv.Find(
             le_audio::types::kLeAudioMetadataTypeStreamingAudioContext);
         if (stream_context_vec) {
+          if (stream_context_vec.value().size() < 2) {
+            LOG_ERROR(""kLeAudioMetadataTypeStreamingAudioContext size < 2"");
+            return;
+          }
           auto pp = stream_context_vec.value().data();
           UINT16_TO_STREAM(pp, context_type.value());
         }
@@ -72,6 +76,11 @@
       auto stream_context_vec =
           ltv.Find(le_audio::types::kLeAudioMetadataTypeStreamingAudioContext);
       if (stream_context_vec) {
+        if (stream_context_vec.value().size() < 2) {
+          LOG_ERROR(""kLeAudioMetadataTypeStreamingAudioContext size < 2"");
+          return;
+        }
+
         auto pp = stream_context_vec.value().data();
         STREAM_TO_UINT16(context_type.value_ref(), pp);
       }","{'deleted_lines': [], 'added_lines': ['          if (stream_context_vec.value().size() < 2) {', '            LOG_ERROR(""kLeAudioMetadataTypeStreamingAudioContext size < 2"");', '            return;', '          }', '        if (stream_context_vec.value().size() < 2) {', '          LOG_ERROR(""kLeAudioMetadataTypeStreamingAudioContext size < 2"");', '          return;', '        }', '']}",True,"In CreateAudioBroadcast of broadcaster.cc, there is a possible out of bounds write due to a missing bounds check. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.",7.8,HIGH,2,test,,5
CVE-2023-50431,['CWE-Other'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N,1,torvalds/linux,"This function may copy the pad0 field of struct hl_info_sec_attest to user
mode which has not been initialized, resulting in leakage of kernel heap
data to user mode. To prevent this, use kzalloc() to allocate and zero out
the buffer, which can also eliminate other uninitialized holes, if any.

Fixes: 0c88760f8f5e (""habanalabs/gaudi2: add secured attestation info uapi"")
Signed-off-by: Xingyuan Mo <hdthky0@gmail.com>
Reviewed-by: Oded Gabbay <ogabbay@kernel.org>
Signed-off-by: Oded Gabbay <ogabbay@kernel.org>
",a9f07790a4b2250f0140e9a61c7f842fd9b618c7,https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=a9f07790a4b2250f0140e9a61c7f842fd9b618c7,drivers/accel/habanalabs/common/habanalabs_ioctl.c,sec_attest_info,"static int sec_attest_info(struct hl_fpriv *hpriv, struct hl_info_args *args)
{
void __user *out = (void __user *) (uintptr_t) args->return_pointer;
struct cpucp_sec_attest_info *sec_attest_info;
struct hl_info_sec_attest *info;
u32 max_size = args->return_size;
int rc;
if ((!max_size) || (!out))
return -EINVAL;
sec_attest_info = kmalloc(sizeof(*sec_attest_info), GFP_KERNEL);
if (!sec_attest_info)
return -ENOMEM;
info = kmalloc(sizeof(*info), GFP_KERNEL);
if (!info) {
rc = -ENOMEM;
goto free_sec_attest_info;
}
rc = hl_fw_get_sec_attest_info(hpriv->hdev, sec_attest_info, args->sec_attest_nonce);
if (rc)
goto free_info;
info->nonce = le32_to_cpu(sec_attest_info->nonce);
info->pcr_quote_len = le16_to_cpu(sec_attest_info->pcr_quote_len);
info->pub_data_len = le16_to_cpu(sec_attest_info->pub_data_len);
info->certificate_len = le16_to_cpu(sec_attest_info->certificate_len);
info->pcr_num_reg = sec_attest_info->pcr_num_reg;
info->pcr_reg_len = sec_attest_info->pcr_reg_len;
info->quote_sig_len = sec_attest_info->quote_sig_len;
memcpy(&info->pcr_data, &sec_attest_info->pcr_data, sizeof(info->pcr_data));
memcpy(&info->pcr_quote, &sec_attest_info->pcr_quote, sizeof(info->pcr_quote));
memcpy(&info->public_data, &sec_attest_info->public_data, sizeof(info->public_data));
memcpy(&info->certificate, &sec_attest_info->certificate, sizeof(info->certificate));
memcpy(&info->quote_sig, &sec_attest_info->quote_sig, sizeof(info->quote_sig));
rc = copy_to_user(out, info,
min_t(size_t, max_size, sizeof(*info))) ? -EFAULT : 0;
free_info:
kfree(info);
free_sec_attest_info:
kfree(sec_attest_info);
return rc;
}","static int sec_attest_info(struct hl_fpriv *VAR_0, struct hl_info_args *VAR_1)
{
void __user *VAR_2 = (void __user *) (uintptr_t) VAR_1->return_pointer;
struct cpucp_sec_attest_info *VAR_3;
struct hl_info_sec_attest *VAR_4;
u32 VAR_5 = VAR_1->return_size;
int VAR_6;
if ((!VAR_5) || (!VAR_2))
return -VAR_7;
VAR_3 = kmalloc(sizeof(*VAR_3), VAR_8);
if (!VAR_3)
return -VAR_9;
VAR_4 = kmalloc(sizeof(*VAR_4), VAR_8);
if (!VAR_4) {
VAR_6 = -VAR_9;
goto free_sec_attest_info;
}
VAR_6 = hl_fw_get_sec_attest_info(VAR_0->hdev, VAR_3, VAR_1->sec_attest_nonce);
if (VAR_6)
goto free_info;
VAR_4->nonce = le32_to_cpu(VAR_3->nonce);
VAR_4->pcr_quote_len = le16_to_cpu(VAR_3->pcr_quote_len);
VAR_4->pub_data_len = le16_to_cpu(VAR_3->pub_data_len);
VAR_4->certificate_len = le16_to_cpu(VAR_3->certificate_len);
VAR_4->pcr_num_reg = VAR_3->pcr_num_reg;
VAR_4->pcr_reg_len = VAR_3->pcr_reg_len;
VAR_4->quote_sig_len = VAR_3->quote_sig_len;
memcpy(&VAR_4->pcr_data, &VAR_3->pcr_data, sizeof(VAR_4->pcr_data));
memcpy(&VAR_4->pcr_quote, &VAR_3->pcr_quote, sizeof(VAR_4->pcr_quote));
memcpy(&VAR_4->public_data, &VAR_3->public_data, sizeof(VAR_4->public_data));
memcpy(&VAR_4->certificate, &VAR_3->certificate, sizeof(VAR_4->certificate));
memcpy(&VAR_4->quote_sig, &VAR_3->quote_sig, sizeof(VAR_4->quote_sig));
VAR_6 = copy_to_user(VAR_2, VAR_4,
min_t(VAR_10, VAR_5, sizeof(*VAR_4))) ? -VAR_11 : 0;
free_info:
kfree(VAR_4);
free_sec_attest_info:
kfree(VAR_3);
return VAR_6;
}",torvalds/linux/a9f07790a4b2250f0140e9a61c7f842fd9b618c7/habanalabs_ioctl.c/vul/before/0.json,"static int sec_attest_info(struct hl_fpriv *hpriv, struct hl_info_args *args)
{
	void __user *out = (void __user *) (uintptr_t) args->return_pointer;
	struct cpucp_sec_attest_info *sec_attest_info;
	struct hl_info_sec_attest *info;
	u32 max_size = args->return_size;
	int rc;

	if ((!max_size) || (!out))
		return -EINVAL;

	sec_attest_info = kmalloc(sizeof(*sec_attest_info), GFP_KERNEL);
	if (!sec_attest_info)
		return -ENOMEM;

	info = kzalloc(sizeof(*info), GFP_KERNEL);
	if (!info) {
		rc = -ENOMEM;
		goto free_sec_attest_info;
	}

	rc = hl_fw_get_sec_attest_info(hpriv->hdev, sec_attest_info, args->sec_attest_nonce);
	if (rc)
		goto free_info;

	info->nonce = le32_to_cpu(sec_attest_info->nonce);
	info->pcr_quote_len = le16_to_cpu(sec_attest_info->pcr_quote_len);
	info->pub_data_len = le16_to_cpu(sec_attest_info->pub_data_len);
	info->certificate_len = le16_to_cpu(sec_attest_info->certificate_len);
	info->pcr_num_reg = sec_attest_info->pcr_num_reg;
	info->pcr_reg_len = sec_attest_info->pcr_reg_len;
	info->quote_sig_len = sec_attest_info->quote_sig_len;
	memcpy(&info->pcr_data, &sec_attest_info->pcr_data, sizeof(info->pcr_data));
	memcpy(&info->pcr_quote, &sec_attest_info->pcr_quote, sizeof(info->pcr_quote));
	memcpy(&info->public_data, &sec_attest_info->public_data, sizeof(info->public_data));
	memcpy(&info->certificate, &sec_attest_info->certificate, sizeof(info->certificate));
	memcpy(&info->quote_sig, &sec_attest_info->quote_sig, sizeof(info->quote_sig));

	rc = copy_to_user(out, info,
				min_t(size_t, max_size, sizeof(*info))) ? -EFAULT : 0;

free_info:
	kfree(info);
free_sec_attest_info:
	kfree(sec_attest_info);

	return rc;
}","static int sec_attest_info(struct hl_fpriv *VAR_0, struct hl_info_args *VAR_1)
{
	void __user *VAR_2 = (void __user *) (uintptr_t) VAR_1->return_pointer;
	struct cpucp_sec_attest_info *VAR_3;
	struct hl_info_sec_attest *VAR_4;
	u32 VAR_5 = VAR_1->return_size;
	int VAR_6;

	if ((!VAR_5) || (!VAR_2))
		return -VAR_7;

	VAR_3 = kmalloc(sizeof(*VAR_3), VAR_8);
	if (!VAR_3)
		return -VAR_9;

	VAR_4 = kzalloc(sizeof(*VAR_4), VAR_8);
	if (!VAR_4) {
		VAR_6 = -VAR_9;
		goto free_sec_attest_info;
	}

	VAR_6 = hl_fw_get_sec_attest_info(VAR_0->hdev, VAR_3, VAR_1->sec_attest_nonce);
	if (VAR_6)
		goto free_info;

	VAR_4->nonce = le32_to_cpu(VAR_3->nonce);
	VAR_4->pcr_quote_len = le16_to_cpu(VAR_3->pcr_quote_len);
	VAR_4->pub_data_len = le16_to_cpu(VAR_3->pub_data_len);
	VAR_4->certificate_len = le16_to_cpu(VAR_3->certificate_len);
	VAR_4->pcr_num_reg = VAR_3->pcr_num_reg;
	VAR_4->pcr_reg_len = VAR_3->pcr_reg_len;
	VAR_4->quote_sig_len = VAR_3->quote_sig_len;
	memcpy(&VAR_4->pcr_data, &VAR_3->pcr_data, sizeof(VAR_4->pcr_data));
	memcpy(&VAR_4->pcr_quote, &VAR_3->pcr_quote, sizeof(VAR_4->pcr_quote));
	memcpy(&VAR_4->public_data, &VAR_3->public_data, sizeof(VAR_4->public_data));
	memcpy(&VAR_4->certificate, &VAR_3->certificate, sizeof(VAR_4->certificate));
	memcpy(&VAR_4->quote_sig, &VAR_3->quote_sig, sizeof(VAR_4->quote_sig));

	VAR_6 = copy_to_user(VAR_2, VAR_4,
				min_t(VAR_10, VAR_5, sizeof(*VAR_4))) ? -VAR_11 : 0;

free_info:
	kfree(VAR_4);
free_sec_attest_info:
	kfree(VAR_3);

	return VAR_6;
}",torvalds/linux/a9f07790a4b2250f0140e9a61c7f842fd9b618c7/habanalabs_ioctl.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,7 +13,7 @@
 	if (!sec_attest_info)
 		return -ENOMEM;
 
-	info = kmalloc(sizeof(*info), GFP_KERNEL);
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
 	if (!info) {
 		rc = -ENOMEM;
 		goto free_sec_attest_info;","{'deleted_lines': ['\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);'], 'added_lines': ['\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);']}",True,sec_attest_info in drivers/accel/habanalabs/common/habanalabs_ioctl.c in the Linux kernel through 6.6.5 allows an information leak to user space because info->pad0 is not initialized.,5.5,MEDIUM,1,test,,5
CVE-2023-6931,['CWE-787'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"Budimir noted that perf_event_validate_size() only checks the size of
the newly added event, even though the sizes of all existing events
can also change due to not all events having the same read_format.

When we attach the new event, perf_group_attach(), we do re-compute
the size for all events.

Fixes: a723968c0ed3 (""perf: Fix u16 overflows"")
Reported-by: Budimir Markovic <markovicbudimir@gmail.com>
Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
",382c27f4ed28f803b1f1473ac2d8db0afc795a1b,https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=382c27f4ed28f803b1f1473ac2d8db0afc795a1b,kernel/events/core.c,perf_event__header_size,"static void perf_event__header_size(struct perf_event *event)
{
__perf_event_read_size(event,
event->group_leader->nr_siblings);
__perf_event_header_size(event, event->attr.sample_type);
}","static void perf_event__header_size(struct perf_event *VAR_0)
{
__perf_event_read_size(VAR_0,
VAR_0->group_leader->nr_siblings);
__perf_event_header_size(VAR_0, VAR_0->attr.sample_type);
}",torvalds/linux/382c27f4ed28f803b1f1473ac2d8db0afc795a1b/core.c/vul/before/0.json,"static void perf_event__header_size(struct perf_event *event)
{
	event->read_size =
		__perf_event_read_size(event->attr.read_format,
				       event->group_leader->nr_siblings);
	__perf_event_header_size(event, event->attr.sample_type);
}","static void perf_event__header_size(struct perf_event *VAR_0)
{
	VAR_0->read_size =
		__perf_event_read_size(VAR_0->attr.read_format,
				       VAR_0->group_leader->nr_siblings);
	__perf_event_header_size(VAR_0, VAR_0->attr.sample_type);
}",torvalds/linux/382c27f4ed28f803b1f1473ac2d8db0afc795a1b/core.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,6 +1,7 @@
 static void perf_event__header_size(struct perf_event *event)
 {
-	__perf_event_read_size(event,
-			       event->group_leader->nr_siblings);
+	event->read_size =
+		__perf_event_read_size(event->attr.read_format,
+				       event->group_leader->nr_siblings);
 	__perf_event_header_size(event, event->attr.sample_type);
 }","{'deleted_lines': ['\t__perf_event_read_size(event,', '\t\t\t       event->group_leader->nr_siblings);'], 'added_lines': ['\tevent->read_size =', '\t\t__perf_event_read_size(event->attr.read_format,', '\t\t\t\t       event->group_leader->nr_siblings);']}",True,"A heap out-of-bounds write vulnerability in the Linux kernel's Performance Events system component can be exploited to achieve local privilege escalation.

A perf_event's read_size can overflow, leading to an heap out-of-bounds increment or write in perf_read_group().

We recommend upgrading past commit 382c27f4ed28f803b1f1473ac2d8db0afc795a1b.

",7.8,HIGH,2,test,,5
CVE-2023-6931,['CWE-787'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"Budimir noted that perf_event_validate_size() only checks the size of
the newly added event, even though the sizes of all existing events
can also change due to not all events having the same read_format.

When we attach the new event, perf_group_attach(), we do re-compute
the size for all events.

Fixes: a723968c0ed3 (""perf: Fix u16 overflows"")
Reported-by: Budimir Markovic <markovicbudimir@gmail.com>
Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
",382c27f4ed28f803b1f1473ac2d8db0afc795a1b,https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=382c27f4ed28f803b1f1473ac2d8db0afc795a1b,kernel/events/core.c,perf_event_validate_size,"static bool perf_event_validate_size(struct perf_event *event)
{
__perf_event_read_size(event, event->group_leader->nr_siblings + 1);
__perf_event_header_size(event, event->attr.sample_type & ~PERF_SAMPLE_READ);
perf_event__id_header_size(event);
if (event->read_size + event->header_size +
event->id_header_size + sizeof(struct perf_event_header) >= 16*1024)
return false;
return true;
}","static bool perf_event_validate_size(struct perf_event *VAR_0)
{
__perf_event_read_size(VAR_0, VAR_0->group_leader->nr_siblings + 1);
__perf_event_header_size(VAR_0, VAR_0->attr.sample_type & ~VAR_1);
perf_event__id_header_size(VAR_0);
if (VAR_0->read_size + VAR_0->header_size +
VAR_0->id_header_size + sizeof(struct perf_event_header) >= 16*1024)
return false;
return true;
}",torvalds/linux/382c27f4ed28f803b1f1473ac2d8db0afc795a1b/core.c/vul/before/1.json,"static bool perf_event_validate_size(struct perf_event *event)
{
	struct perf_event *sibling, *group_leader = event->group_leader;

	if (__perf_event_read_size(event->attr.read_format,
				   group_leader->nr_siblings + 1) > 16*1024)
		return false;

	if (__perf_event_read_size(group_leader->attr.read_format,
				   group_leader->nr_siblings + 1) > 16*1024)
		return false;

	for_each_sibling_event(sibling, group_leader) {
		if (__perf_event_read_size(sibling->attr.read_format,
					   group_leader->nr_siblings + 1) > 16*1024)
			return false;
	}

	return true;
}","static bool perf_event_validate_size(struct perf_event *VAR_0)
{
	struct perf_event *VAR_1, *VAR_2 = VAR_0->group_leader;

	if (__perf_event_read_size(VAR_0->attr.read_format,
				   VAR_2->nr_siblings + 1) > 16*1024)
		return false;

	if (__perf_event_read_size(VAR_2->attr.read_format,
				   VAR_2->nr_siblings + 1) > 16*1024)
		return false;

	for_each_sibling_event(VAR_1, VAR_2) {
		if (__perf_event_read_size(VAR_1->attr.read_format,
					   VAR_2->nr_siblings + 1) > 16*1024)
			return false;
	}

	return true;
}",torvalds/linux/382c27f4ed28f803b1f1473ac2d8db0afc795a1b/core.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,20 +1,20 @@
 static bool perf_event_validate_size(struct perf_event *event)
 {
-	/*
-	 * The values computed here will be over-written when we actually
-	 * attach the event.
-	 */
-	__perf_event_read_size(event, event->group_leader->nr_siblings + 1);
-	__perf_event_header_size(event, event->attr.sample_type & ~PERF_SAMPLE_READ);
-	perf_event__id_header_size(event);
+	struct perf_event *sibling, *group_leader = event->group_leader;
 
-	/*
-	 * Sum the lot; should not exceed the 64k limit we have on records.
-	 * Conservative limit to allow for callchains and other variable fields.
-	 */
-	if (event->read_size + event->header_size +
-	    event->id_header_size + sizeof(struct perf_event_header) >= 16*1024)
+	if (__perf_event_read_size(event->attr.read_format,
+				   group_leader->nr_siblings + 1) > 16*1024)
 		return false;
+
+	if (__perf_event_read_size(group_leader->attr.read_format,
+				   group_leader->nr_siblings + 1) > 16*1024)
+		return false;
+
+	for_each_sibling_event(sibling, group_leader) {
+		if (__perf_event_read_size(sibling->attr.read_format,
+					   group_leader->nr_siblings + 1) > 16*1024)
+			return false;
+	}
 
 	return true;
 }","{'deleted_lines': ['\t/*', '\t * The values computed here will be over-written when we actually', '\t * attach the event.', '\t */', '\t__perf_event_read_size(event, event->group_leader->nr_siblings + 1);', '\t__perf_event_header_size(event, event->attr.sample_type & ~PERF_SAMPLE_READ);', '\tperf_event__id_header_size(event);', '\t/*', '\t * Sum the lot; should not exceed the 64k limit we have on records.', '\t * Conservative limit to allow for callchains and other variable fields.', '\t */', '\tif (event->read_size + event->header_size +', '\t    event->id_header_size + sizeof(struct perf_event_header) >= 16*1024)'], 'added_lines': ['\tstruct perf_event *sibling, *group_leader = event->group_leader;', '\tif (__perf_event_read_size(event->attr.read_format,', '\t\t\t\t   group_leader->nr_siblings + 1) > 16*1024)', '', '\tif (__perf_event_read_size(group_leader->attr.read_format,', '\t\t\t\t   group_leader->nr_siblings + 1) > 16*1024)', '\t\treturn false;', '', '\tfor_each_sibling_event(sibling, group_leader) {', '\t\tif (__perf_event_read_size(sibling->attr.read_format,', '\t\t\t\t\t   group_leader->nr_siblings + 1) > 16*1024)', '\t\t\treturn false;', '\t}']}",True,"A heap out-of-bounds write vulnerability in the Linux kernel's Performance Events system component can be exploited to achieve local privilege escalation.

A perf_event's read_size can overflow, leading to an heap out-of-bounds increment or write in perf_read_group().

We recommend upgrading past commit 382c27f4ed28f803b1f1473ac2d8db0afc795a1b.

",7.8,HIGH,2,test,,5
CVE-2023-6931,['CWE-787'],CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"Budimir noted that perf_event_validate_size() only checks the size of
the newly added event, even though the sizes of all existing events
can also change due to not all events having the same read_format.

When we attach the new event, perf_group_attach(), we do re-compute
the size for all events.

Fixes: a723968c0ed3 (""perf: Fix u16 overflows"")
Reported-by: Budimir Markovic <markovicbudimir@gmail.com>
Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
",382c27f4ed28f803b1f1473ac2d8db0afc795a1b,https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=382c27f4ed28f803b1f1473ac2d8db0afc795a1b,kernel/events/core.c,__perf_event_read_size,"static void __perf_event_read_size(struct perf_event *event, int nr_siblings)
{
int entry = sizeof(u64); 
int size = 0;
int nr = 1;
if (event->attr.read_format & PERF_FORMAT_TOTAL_TIME_ENABLED)
size += sizeof(u64);
if (event->attr.read_format & PERF_FORMAT_TOTAL_TIME_RUNNING)
size += sizeof(u64);
if (event->attr.read_format & PERF_FORMAT_ID)
entry += sizeof(u64);
if (event->attr.read_format & PERF_FORMAT_LOST)
entry += sizeof(u64);
if (event->attr.read_format & PERF_FORMAT_GROUP) {
nr += nr_siblings;
size += sizeof(u64);
}
size += entry * nr;
event->read_size = size;
}","static void __perf_event_read_size(struct perf_event *VAR_0, int VAR_1)
{
int VAR_2 = sizeof(VAR_3); 
int VAR_4 = 0;
int VAR_5 = 1;
if (VAR_0->attr.read_format & VAR_6)
VAR_4 += sizeof(VAR_3);
if (VAR_0->attr.read_format & VAR_7)
VAR_4 += sizeof(VAR_3);
if (VAR_0->attr.read_format & VAR_8)
VAR_2 += sizeof(VAR_3);
if (VAR_0->attr.read_format & VAR_9)
VAR_2 += sizeof(VAR_3);
if (VAR_0->attr.read_format & VAR_10) {
VAR_5 += VAR_1;
VAR_4 += sizeof(VAR_3);
}
VAR_4 += VAR_2 * VAR_5;
VAR_0->read_size = VAR_4;
}",torvalds/linux/382c27f4ed28f803b1f1473ac2d8db0afc795a1b/core.c/vul/before/2.json,"static int __perf_event_read_size(u64 read_format, int nr_siblings)
{
	int entry = sizeof(u64); /* value */
	int size = 0;
	int nr = 1;

	if (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED)
		size += sizeof(u64);

	if (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING)
		size += sizeof(u64);

	if (read_format & PERF_FORMAT_ID)
		entry += sizeof(u64);

	if (read_format & PERF_FORMAT_LOST)
		entry += sizeof(u64);

	if (read_format & PERF_FORMAT_GROUP) {
		nr += nr_siblings;
		size += sizeof(u64);
	}

	/*
	 * Since perf_event_validate_size() limits this to 16k and inhibits
	 * adding more siblings, this will never overflow.
	 */
	return size + nr * entry;
}","static int __perf_event_read_size(u64 VAR_0, int VAR_1)
{
	int VAR_2 = sizeof(u64); /* COMMENT_0 */
	int VAR_3 = 0;
	int VAR_4 = 1;

	if (VAR_0 & VAR_5)
		VAR_3 += sizeof(u64);

	if (VAR_0 & VAR_6)
		VAR_3 += sizeof(u64);

	if (VAR_0 & VAR_7)
		VAR_2 += sizeof(u64);

	if (VAR_0 & VAR_8)
		VAR_2 += sizeof(u64);

	if (VAR_0 & VAR_9) {
		VAR_4 += VAR_1;
		VAR_3 += sizeof(u64);
	}

	/* COMMENT_1 */
                                                                    
                                                   
    
	return VAR_3 + VAR_4 * VAR_2;
}",torvalds/linux/382c27f4ed28f803b1f1473ac2d8db0afc795a1b/core.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,26 +1,29 @@
-static void __perf_event_read_size(struct perf_event *event, int nr_siblings)
+static int __perf_event_read_size(u64 read_format, int nr_siblings)
 {
 	int entry = sizeof(u64); /* value */
 	int size = 0;
 	int nr = 1;
 
-	if (event->attr.read_format & PERF_FORMAT_TOTAL_TIME_ENABLED)
+	if (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED)
 		size += sizeof(u64);
 
-	if (event->attr.read_format & PERF_FORMAT_TOTAL_TIME_RUNNING)
+	if (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING)
 		size += sizeof(u64);
 
-	if (event->attr.read_format & PERF_FORMAT_ID)
+	if (read_format & PERF_FORMAT_ID)
 		entry += sizeof(u64);
 
-	if (event->attr.read_format & PERF_FORMAT_LOST)
+	if (read_format & PERF_FORMAT_LOST)
 		entry += sizeof(u64);
 
-	if (event->attr.read_format & PERF_FORMAT_GROUP) {
+	if (read_format & PERF_FORMAT_GROUP) {
 		nr += nr_siblings;
 		size += sizeof(u64);
 	}
 
-	size += entry * nr;
-	event->read_size = size;
+	/*
+	 * Since perf_event_validate_size() limits this to 16k and inhibits
+	 * adding more siblings, this will never overflow.
+	 */
+	return size + nr * entry;
 }","{'deleted_lines': ['static void __perf_event_read_size(struct perf_event *event, int nr_siblings)', '\tif (event->attr.read_format & PERF_FORMAT_TOTAL_TIME_ENABLED)', '\tif (event->attr.read_format & PERF_FORMAT_TOTAL_TIME_RUNNING)', '\tif (event->attr.read_format & PERF_FORMAT_ID)', '\tif (event->attr.read_format & PERF_FORMAT_LOST)', '\tif (event->attr.read_format & PERF_FORMAT_GROUP) {', '\tsize += entry * nr;', '\tevent->read_size = size;'], 'added_lines': ['static int __perf_event_read_size(u64 read_format, int nr_siblings)', '\tif (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED)', '\tif (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING)', '\tif (read_format & PERF_FORMAT_ID)', '\tif (read_format & PERF_FORMAT_LOST)', '\tif (read_format & PERF_FORMAT_GROUP) {', '\t/*', '\t * Since perf_event_validate_size() limits this to 16k and inhibits', '\t * adding more siblings, this will never overflow.', '\t */', '\treturn size + nr * entry;']}",True,"A heap out-of-bounds write vulnerability in the Linux kernel's Performance Events system component can be exploited to achieve local privilege escalation.

A perf_event's read_size can overflow, leading to an heap out-of-bounds increment or write in perf_read_group().

We recommend upgrading past commit 382c27f4ed28f803b1f1473ac2d8db0afc795a1b.

",7.8,HIGH,2,test,,5
CVE-2011-4915,['CWE-200'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,torvalds/linux,"get_proc_task() can fail to search the task and return NULL,
put_task_struct() will then bomb the kernel with following oops:

  BUG: unable to handle kernel NULL pointer dereference at 0000000000000010
  IP: [<ffffffff81217d34>] proc_pid_permission+0x64/0xe0
  PGD 112075067 PUD 112814067 PMD 0
  Oops: 0002 [#1] PREEMPT SMP

This is a regression introduced by commit 0499680a (""procfs: add hidepid=
and gid= mount options"").  The kernel should return -ESRCH if
get_proc_task() failed.

Signed-off-by: Xiaotian Feng <dannyfeng@tencent.com>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: Vasiliy Kulikov <segoon@openwall.com>
Cc: Stephen Wilson <wilsons@start.ca>
Acked-by: David Rientjes <rientjes@google.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
",a2ef990ab5a6705a356d146dd773a3b359787497,http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=a2ef990ab5a6705a356d146dd773a3b359787497,fs/proc/base.c,proc_pid_permission,"static int proc_pid_permission(struct inode *inode, int mask)
{
struct pid_namespace *pid = inode->i_sb->s_fs_info;
struct task_struct *task;
bool has_perms;
task = get_proc_task(inode);
has_perms = has_pid_permissions(pid, task, 1);
put_task_struct(task);
if (!has_perms) {
if (pid->hide_pid == 2) {
return -ENOENT;
}
return -EPERM;
}
return generic_permission(inode, mask);
}","static int proc_pid_permission(struct inode *inode, int VAR_0)
{
struct pid_namespace *VAR_1 = inode->i_sb->s_fs_info;
struct task_struct *VAR_2;
bool VAR_3;
VAR_2 = get_proc_task(inode);
VAR_3 = has_pid_permissions(VAR_1, VAR_2, 1);
put_task_struct(VAR_2);
if (!VAR_3) {
if (VAR_1->hide_pid == 2) {
return -VAR_4;
}
return -VAR_5;
}
return generic_permission(inode, VAR_0);
}",torvalds/linux/a2ef990ab5a6705a356d146dd773a3b359787497/base.c/vul/before/0.json,"static int proc_pid_permission(struct inode *inode, int mask)
{
	struct pid_namespace *pid = inode->i_sb->s_fs_info;
	struct task_struct *task;
	bool has_perms;

	task = get_proc_task(inode);
	if (!task)
		return -ESRCH;
	has_perms = has_pid_permissions(pid, task, 1);
	put_task_struct(task);

	if (!has_perms) {
		if (pid->hide_pid == 2) {
			/*
			 * Let's make getdents(), stat(), and open()
			 * consistent with each other.  If a process
			 * may not stat() a file, it shouldn't be seen
			 * in procfs at all.
			 */
			return -ENOENT;
		}

		return -EPERM;
	}
	return generic_permission(inode, mask);
}","static int proc_pid_permission(struct inode *inode, int VAR_0)
{
	struct pid_namespace *VAR_1 = inode->i_sb->s_fs_info;
	struct task_struct *VAR_2;
	bool VAR_3;

	VAR_2 = get_proc_task(inode);
	if (!VAR_2)
		return -VAR_4;
	VAR_3 = has_pid_permissions(VAR_1, VAR_2, 1);
	put_task_struct(VAR_2);

	if (!VAR_3) {
		if (VAR_1->hide_pid == 2) {
			/* COMMENT_0 */
                                               
                                               
                                                 
                       
      
			return -VAR_5;
		}

		return -VAR_6;
	}
	return generic_permission(inode, VAR_0);
}",torvalds/linux/a2ef990ab5a6705a356d146dd773a3b359787497/base.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,6 +5,8 @@
 	bool has_perms;
 
 	task = get_proc_task(inode);
+	if (!task)
+		return -ESRCH;
 	has_perms = has_pid_permissions(pid, task, 1);
 	put_task_struct(task);
 ","{'deleted_lines': [], 'added_lines': ['\tif (!task)', '\t\treturn -ESRCH;']}",True,fs/proc/base.c in the Linux kernel through 3.1 allows local users to obtain sensitive keystroke information via access to /proc/interrupts.,5.5,MEDIUM,1,test,,5
CVE-2011-4915,['CWE-200'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,torvalds/linux,"Add support for mount options to restrict access to /proc/PID/
directories.  The default backward-compatible ""relaxed"" behaviour is left
untouched.

The first mount option is called ""hidepid"" and its value defines how much
info about processes we want to be available for non-owners:

hidepid=0 (default) means the old behavior - anybody may read all
world-readable /proc/PID/* files.

hidepid=1 means users may not access any /proc/<pid>/ directories, but
their own.  Sensitive files like cmdline, sched*, status are now protected
against other users.  As permission checking done in proc_pid_permission()
and files' permissions are left untouched, programs expecting specific
files' modes are not confused.

hidepid=2 means hidepid=1 plus all /proc/PID/ will be invisible to other
users.  It doesn't mean that it hides whether a process exists (it can be
learned by other means, e.g.  by kill -0 $PID), but it hides process' euid
and egid.  It compicates intruder's task of gathering info about running
processes, whether some daemon runs with elevated privileges, whether
another user runs some sensitive program, whether other users run any
program at all, etc.

gid=XXX defines a group that will be able to gather all processes' info
(as in hidepid=0 mode).  This group should be used instead of putting
nonroot user in sudoers file or something.  However, untrusted users (like
daemons, etc.) which are not supposed to monitor the tasks in the whole
system should not be added to the group.

hidepid=1 or higher is designed to restrict access to procfs files, which
might reveal some sensitive private information like precise keystrokes
timings:

http://www.openwall.com/lists/oss-security/2011/11/05/3

hidepid=1/2 doesn't break monitoring userspace tools.  ps, top, pgrep, and
conky gracefully handle EPERM/ENOENT and behave as if the current user is
the only user running processes.  pstree shows the process subtree which
contains ""pstree"" process.

Note: the patch doesn't deal with setuid/setgid issues of keeping
preopened descriptors of procfs files (like
https://lkml.org/lkml/2011/2/7/368).  We rely on that the leaked
information like the scheduling counters of setuid apps doesn't threaten
anybody's privacy - only the user started the setuid program may read the
counters.

Signed-off-by: Vasiliy Kulikov <segoon@openwall.com>
Cc: Alexey Dobriyan <adobriyan@gmail.com>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: Randy Dunlap <rdunlap@xenotime.net>
Cc: ""H. Peter Anvin"" <hpa@zytor.com>
Cc: Greg KH <greg@kroah.com>
Cc: Theodore Tso <tytso@MIT.EDU>
Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
Cc: James Morris <jmorris@namei.org>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: Hugh Dickins <hughd@google.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
",0499680a42141d86417a8fbaa8c8db806bea1201,http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=0499680a42141d86417a8fbaa8c8db806bea1201,fs/proc/base.c,pid_getattr,"int pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
{
struct inode *inode = dentry->d_inode;
struct task_struct *task;
const struct cred *cred;
generic_fillattr(inode, stat);
rcu_read_lock();
stat->uid = 0;
stat->gid = 0;
task = pid_task(proc_pid(inode), PIDTYPE_PID);
if (task) {
if ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||
task_dumpable(task)) {
cred = __task_cred(task);
stat->uid = cred->euid;
stat->gid = cred->egid;
}
}
rcu_read_unlock();
return 0;
}","int pid_getattr(struct vfsmount *VAR_0, struct dentry *dentry, struct kstat *VAR_1)
{
struct inode *inode = dentry->d_inode;
struct task_struct *VAR_2;
const struct cred *cred;
generic_fillattr(inode, VAR_1);
rcu_read_lock();
VAR_1->uid = 0;
VAR_1->gid = 0;
VAR_2 = pid_task(proc_pid(inode), VAR_3);
if (VAR_2) {
if ((inode->i_mode == (VAR_4|VAR_5|VAR_6)) ||
task_dumpable(VAR_2)) {
cred = __task_cred(VAR_2);
VAR_1->uid = cred->euid;
VAR_1->gid = cred->egid;
}
}
rcu_read_unlock();
return 0;
}",torvalds/linux/0499680a42141d86417a8fbaa8c8db806bea1201/base.c/vul/before/0.json,"int pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)
{
	struct inode *inode = dentry->d_inode;
	struct task_struct *task;
	const struct cred *cred;
	struct pid_namespace *pid = dentry->d_sb->s_fs_info;

	generic_fillattr(inode, stat);

	rcu_read_lock();
	stat->uid = 0;
	stat->gid = 0;
	task = pid_task(proc_pid(inode), PIDTYPE_PID);
	if (task) {
		if (!has_pid_permissions(pid, task, 2)) {
			rcu_read_unlock();
			/*
			 * This doesn't prevent learning whether PID exists,
			 * it only makes getattr() consistent with readdir().
			 */
			return -ENOENT;
		}
		if ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||
		    task_dumpable(task)) {
			cred = __task_cred(task);
			stat->uid = cred->euid;
			stat->gid = cred->egid;
		}
	}
	rcu_read_unlock();
	return 0;
}","int pid_getattr(struct vfsmount *VAR_0, struct dentry *dentry, struct kstat *VAR_1)
{
	struct inode *inode = dentry->d_inode;
	struct task_struct *VAR_2;
	const struct cred *cred;
	struct pid_namespace *VAR_3 = dentry->d_sb->s_fs_info;

	generic_fillattr(inode, VAR_1);

	rcu_read_lock();
	VAR_1->uid = 0;
	VAR_1->gid = 0;
	VAR_2 = pid_task(proc_pid(inode), VAR_4);
	if (VAR_2) {
		if (!has_pid_permissions(VAR_3, VAR_2, 2)) {
			rcu_read_unlock();
			/* COMMENT_0 */
                                                       
                                                        
      
			return -VAR_5;
		}
		if ((inode->i_mode == (VAR_6|VAR_7|VAR_8)) ||
		    task_dumpable(VAR_2)) {
			cred = __task_cred(VAR_2);
			VAR_1->uid = cred->euid;
			VAR_1->gid = cred->egid;
		}
	}
	rcu_read_unlock();
	return 0;
}",torvalds/linux/0499680a42141d86417a8fbaa8c8db806bea1201/base.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,6 +3,7 @@
 	struct inode *inode = dentry->d_inode;
 	struct task_struct *task;
 	const struct cred *cred;
+	struct pid_namespace *pid = dentry->d_sb->s_fs_info;
 
 	generic_fillattr(inode, stat);
 
@@ -11,6 +12,14 @@
 	stat->gid = 0;
 	task = pid_task(proc_pid(inode), PIDTYPE_PID);
 	if (task) {
+		if (!has_pid_permissions(pid, task, 2)) {
+			rcu_read_unlock();
+			/*
+			 * This doesn't prevent learning whether PID exists,
+			 * it only makes getattr() consistent with readdir().
+			 */
+			return -ENOENT;
+		}
 		if ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||
 		    task_dumpable(task)) {
 			cred = __task_cred(task);","{'deleted_lines': [], 'added_lines': ['\tstruct pid_namespace *pid = dentry->d_sb->s_fs_info;', '\t\tif (!has_pid_permissions(pid, task, 2)) {', '\t\t\trcu_read_unlock();', '\t\t\t/*', ""\t\t\t * This doesn't prevent learning whether PID exists,"", '\t\t\t * it only makes getattr() consistent with readdir().', '\t\t\t */', '\t\t\treturn -ENOENT;', '\t\t}']}",True,fs/proc/base.c in the Linux kernel through 3.1 allows local users to obtain sensitive keystroke information via access to /proc/interrupts.,5.5,MEDIUM,1,test,,5
CVE-2011-4915,['CWE-200'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,torvalds/linux,"Add support for mount options to restrict access to /proc/PID/
directories.  The default backward-compatible ""relaxed"" behaviour is left
untouched.

The first mount option is called ""hidepid"" and its value defines how much
info about processes we want to be available for non-owners:

hidepid=0 (default) means the old behavior - anybody may read all
world-readable /proc/PID/* files.

hidepid=1 means users may not access any /proc/<pid>/ directories, but
their own.  Sensitive files like cmdline, sched*, status are now protected
against other users.  As permission checking done in proc_pid_permission()
and files' permissions are left untouched, programs expecting specific
files' modes are not confused.

hidepid=2 means hidepid=1 plus all /proc/PID/ will be invisible to other
users.  It doesn't mean that it hides whether a process exists (it can be
learned by other means, e.g.  by kill -0 $PID), but it hides process' euid
and egid.  It compicates intruder's task of gathering info about running
processes, whether some daemon runs with elevated privileges, whether
another user runs some sensitive program, whether other users run any
program at all, etc.

gid=XXX defines a group that will be able to gather all processes' info
(as in hidepid=0 mode).  This group should be used instead of putting
nonroot user in sudoers file or something.  However, untrusted users (like
daemons, etc.) which are not supposed to monitor the tasks in the whole
system should not be added to the group.

hidepid=1 or higher is designed to restrict access to procfs files, which
might reveal some sensitive private information like precise keystrokes
timings:

http://www.openwall.com/lists/oss-security/2011/11/05/3

hidepid=1/2 doesn't break monitoring userspace tools.  ps, top, pgrep, and
conky gracefully handle EPERM/ENOENT and behave as if the current user is
the only user running processes.  pstree shows the process subtree which
contains ""pstree"" process.

Note: the patch doesn't deal with setuid/setgid issues of keeping
preopened descriptors of procfs files (like
https://lkml.org/lkml/2011/2/7/368).  We rely on that the leaked
information like the scheduling counters of setuid apps doesn't threaten
anybody's privacy - only the user started the setuid program may read the
counters.

Signed-off-by: Vasiliy Kulikov <segoon@openwall.com>
Cc: Alexey Dobriyan <adobriyan@gmail.com>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: Randy Dunlap <rdunlap@xenotime.net>
Cc: ""H. Peter Anvin"" <hpa@zytor.com>
Cc: Greg KH <greg@kroah.com>
Cc: Theodore Tso <tytso@MIT.EDU>
Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
Cc: James Morris <jmorris@namei.org>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: Hugh Dickins <hughd@google.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
",0499680a42141d86417a8fbaa8c8db806bea1201,http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=0499680a42141d86417a8fbaa8c8db806bea1201,fs/proc/base.c,proc_pid_readdir,"int proc_pid_readdir(struct file * filp, void * dirent, filldir_t filldir)
{
unsigned int nr;
struct task_struct *reaper;
struct tgid_iter iter;
struct pid_namespace *ns;
if (filp->f_pos >= PID_MAX_LIMIT + TGID_OFFSET)
goto out_no_task;
nr = filp->f_pos - FIRST_PROCESS_ENTRY;
reaper = get_proc_task(filp->f_path.dentry->d_inode);
if (!reaper)
goto out_no_task;
for (; nr < ARRAY_SIZE(proc_base_stuff); filp->f_pos++, nr++) {
const struct pid_entry *p = &proc_base_stuff[nr];
if (proc_base_fill_cache(filp, dirent, filldir, reaper, p) < 0)
goto out;
}
ns = filp->f_dentry->d_sb->s_fs_info;
iter.task = NULL;
iter.tgid = filp->f_pos - TGID_OFFSET;
for (iter = next_tgid(ns, iter);
iter.task;
iter.tgid += 1, iter = next_tgid(ns, iter)) {
filp->f_pos = iter.tgid + TGID_OFFSET;
if (proc_pid_fill_cache(filp, dirent, filldir, iter) < 0) {
put_task_struct(iter.task);
goto out;
}
}
filp->f_pos = PID_MAX_LIMIT + TGID_OFFSET;
out:
put_task_struct(reaper);
out_no_task:
return 0;
}","int proc_pid_readdir(struct file * VAR_0, void * VAR_1, filldir_t VAR_2)
{
unsigned int VAR_3;
struct task_struct *VAR_4;
struct tgid_iter VAR_5;
struct pid_namespace *VAR_6;
if (VAR_0->f_pos >= VAR_7 + VAR_8)
goto out_no_task;
VAR_3 = VAR_0->f_pos - VAR_9;
VAR_4 = get_proc_task(VAR_0->f_path.dentry->d_inode);
if (!VAR_4)
goto out_no_task;
for (; VAR_3 < ARRAY_SIZE(VAR_10); VAR_0->f_pos++, VAR_3++) {
const struct pid_entry *VAR_11 = &VAR_10[VAR_3];
if (proc_base_fill_cache(VAR_0, VAR_1, VAR_2, VAR_4, VAR_11) < 0)
goto out;
}
VAR_6 = VAR_0->f_dentry->d_sb->s_fs_info;
VAR_5.task = NULL;
VAR_5.tgid = VAR_0->f_pos - VAR_8;
for (VAR_5 = next_tgid(VAR_6, VAR_5);
VAR_5.task;
VAR_5.tgid += 1, VAR_5 = next_tgid(VAR_6, VAR_5)) {
VAR_0->f_pos = VAR_5.tgid + VAR_8;
if (proc_pid_fill_cache(VAR_0, VAR_1, VAR_2, VAR_5) < 0) {
put_task_struct(VAR_5.task);
goto out;
}
}
VAR_0->f_pos = VAR_7 + VAR_8;
out:
put_task_struct(VAR_4);
out_no_task:
return 0;
}",torvalds/linux/0499680a42141d86417a8fbaa8c8db806bea1201/base.c/vul/before/1.json,"int proc_pid_readdir(struct file * filp, void * dirent, filldir_t filldir)
{
	unsigned int nr;
	struct task_struct *reaper;
	struct tgid_iter iter;
	struct pid_namespace *ns;
	filldir_t __filldir;

	if (filp->f_pos >= PID_MAX_LIMIT + TGID_OFFSET)
		goto out_no_task;
	nr = filp->f_pos - FIRST_PROCESS_ENTRY;

	reaper = get_proc_task(filp->f_path.dentry->d_inode);
	if (!reaper)
		goto out_no_task;

	for (; nr < ARRAY_SIZE(proc_base_stuff); filp->f_pos++, nr++) {
		const struct pid_entry *p = &proc_base_stuff[nr];
		if (proc_base_fill_cache(filp, dirent, filldir, reaper, p) < 0)
			goto out;
	}

	ns = filp->f_dentry->d_sb->s_fs_info;
	iter.task = NULL;
	iter.tgid = filp->f_pos - TGID_OFFSET;
	for (iter = next_tgid(ns, iter);
	     iter.task;
	     iter.tgid += 1, iter = next_tgid(ns, iter)) {
		if (has_pid_permissions(ns, iter.task, 2))
			__filldir = filldir;
		else
			__filldir = fake_filldir;

		filp->f_pos = iter.tgid + TGID_OFFSET;
		if (proc_pid_fill_cache(filp, dirent, __filldir, iter) < 0) {
			put_task_struct(iter.task);
			goto out;
		}
	}
	filp->f_pos = PID_MAX_LIMIT + TGID_OFFSET;
out:
	put_task_struct(reaper);
out_no_task:
	return 0;
}","int proc_pid_readdir(struct file * VAR_0, void * VAR_1, filldir_t VAR_2)
{
	unsigned int VAR_3;
	struct task_struct *VAR_4;
	struct tgid_iter VAR_5;
	struct pid_namespace *VAR_6;
	filldir_t VAR_7;

	if (VAR_0->f_pos >= VAR_8 + VAR_9)
		goto out_no_task;
	VAR_3 = VAR_0->f_pos - VAR_10;

	VAR_4 = get_proc_task(VAR_0->f_path.dentry->d_inode);
	if (!VAR_4)
		goto out_no_task;

	for (; VAR_3 < ARRAY_SIZE(VAR_11); VAR_0->f_pos++, VAR_3++) {
		const struct pid_entry *VAR_12 = &VAR_11[VAR_3];
		if (proc_base_fill_cache(VAR_0, VAR_1, VAR_2, VAR_4, VAR_12) < 0)
			goto out;
	}

	VAR_6 = VAR_0->f_dentry->d_sb->s_fs_info;
	VAR_5.task = NULL;
	VAR_5.tgid = VAR_0->f_pos - VAR_9;
	for (VAR_5 = next_tgid(VAR_6, VAR_5);
	     VAR_5.task;
	     VAR_5.tgid += 1, VAR_5 = next_tgid(VAR_6, VAR_5)) {
		if (has_pid_permissions(VAR_6, VAR_5.task, 2))
			VAR_7 = VAR_2;
		else
			VAR_7 = VAR_13;

		VAR_0->f_pos = VAR_5.tgid + VAR_9;
		if (proc_pid_fill_cache(VAR_0, VAR_1, VAR_7, VAR_5) < 0) {
			put_task_struct(VAR_5.task);
			goto out;
		}
	}
	VAR_0->f_pos = VAR_8 + VAR_9;
out:
	put_task_struct(VAR_4);
out_no_task:
	return 0;
}",torvalds/linux/0499680a42141d86417a8fbaa8c8db806bea1201/base.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -4,6 +4,7 @@
 	struct task_struct *reaper;
 	struct tgid_iter iter;
 	struct pid_namespace *ns;
+	filldir_t __filldir;
 
 	if (filp->f_pos >= PID_MAX_LIMIT + TGID_OFFSET)
 		goto out_no_task;
@@ -25,8 +26,13 @@
 	for (iter = next_tgid(ns, iter);
 	     iter.task;
 	     iter.tgid += 1, iter = next_tgid(ns, iter)) {
+		if (has_pid_permissions(ns, iter.task, 2))
+			__filldir = filldir;
+		else
+			__filldir = fake_filldir;
+
 		filp->f_pos = iter.tgid + TGID_OFFSET;
-		if (proc_pid_fill_cache(filp, dirent, filldir, iter) < 0) {
+		if (proc_pid_fill_cache(filp, dirent, __filldir, iter) < 0) {
 			put_task_struct(iter.task);
 			goto out;
 		}","{'deleted_lines': ['\t\tif (proc_pid_fill_cache(filp, dirent, filldir, iter) < 0) {'], 'added_lines': ['\tfilldir_t __filldir;', '\t\tif (has_pid_permissions(ns, iter.task, 2))', '\t\t\t__filldir = filldir;', '\t\telse', '\t\t\t__filldir = fake_filldir;', '', '\t\tif (proc_pid_fill_cache(filp, dirent, __filldir, iter) < 0) {']}",True,fs/proc/base.c in the Linux kernel through 3.1 allows local users to obtain sensitive keystroke information via access to /proc/interrupts.,5.5,MEDIUM,1,test,,5
CVE-2011-4915,['CWE-200'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,torvalds/linux,"Add support for mount options to restrict access to /proc/PID/
directories.  The default backward-compatible ""relaxed"" behaviour is left
untouched.

The first mount option is called ""hidepid"" and its value defines how much
info about processes we want to be available for non-owners:

hidepid=0 (default) means the old behavior - anybody may read all
world-readable /proc/PID/* files.

hidepid=1 means users may not access any /proc/<pid>/ directories, but
their own.  Sensitive files like cmdline, sched*, status are now protected
against other users.  As permission checking done in proc_pid_permission()
and files' permissions are left untouched, programs expecting specific
files' modes are not confused.

hidepid=2 means hidepid=1 plus all /proc/PID/ will be invisible to other
users.  It doesn't mean that it hides whether a process exists (it can be
learned by other means, e.g.  by kill -0 $PID), but it hides process' euid
and egid.  It compicates intruder's task of gathering info about running
processes, whether some daemon runs with elevated privileges, whether
another user runs some sensitive program, whether other users run any
program at all, etc.

gid=XXX defines a group that will be able to gather all processes' info
(as in hidepid=0 mode).  This group should be used instead of putting
nonroot user in sudoers file or something.  However, untrusted users (like
daemons, etc.) which are not supposed to monitor the tasks in the whole
system should not be added to the group.

hidepid=1 or higher is designed to restrict access to procfs files, which
might reveal some sensitive private information like precise keystrokes
timings:

http://www.openwall.com/lists/oss-security/2011/11/05/3

hidepid=1/2 doesn't break monitoring userspace tools.  ps, top, pgrep, and
conky gracefully handle EPERM/ENOENT and behave as if the current user is
the only user running processes.  pstree shows the process subtree which
contains ""pstree"" process.

Note: the patch doesn't deal with setuid/setgid issues of keeping
preopened descriptors of procfs files (like
https://lkml.org/lkml/2011/2/7/368).  We rely on that the leaked
information like the scheduling counters of setuid apps doesn't threaten
anybody's privacy - only the user started the setuid program may read the
counters.

Signed-off-by: Vasiliy Kulikov <segoon@openwall.com>
Cc: Alexey Dobriyan <adobriyan@gmail.com>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: Randy Dunlap <rdunlap@xenotime.net>
Cc: ""H. Peter Anvin"" <hpa@zytor.com>
Cc: Greg KH <greg@kroah.com>
Cc: Theodore Tso <tytso@MIT.EDU>
Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
Cc: James Morris <jmorris@namei.org>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: Hugh Dickins <hughd@google.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
",0499680a42141d86417a8fbaa8c8db806bea1201,http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=0499680a42141d86417a8fbaa8c8db806bea1201,fs/proc/root.c,proc_parse_options,"static int proc_parse_options(char *options, struct pid_namespace *pid)
{
char *p;
substring_t args[MAX_OPT_ARGS];
pr_debug(""proc: options = %s\n"", options);
if (!options)
return 1;
while ((p = strsep(&options, "","")) != NULL) {
int token;
if (!*p)
continue;
args[0].to = args[0].from = 0;
token = match_token(p, tokens, args);
switch (token) {
default:
pr_err(""proc: unrecognized mount option \""%s\"" ""
""or missing value\n"", p);
return 0;
}
}
return 1;
}","static int proc_parse_options(char *VAR_0, struct pid_namespace *VAR_1)
{
char *VAR_2;
substring_t VAR_3[VAR_4];
pr_debug(""proc: options = %s\n"", VAR_0);
if (!VAR_0)
return 1;
while ((VAR_2 = strsep(&VAR_0, "","")) != NULL) {
int VAR_5;
if (!*VAR_2)
continue;
VAR_3[0].to = VAR_3[0].from = 0;
VAR_5 = match_token(VAR_2, VAR_6, VAR_3);
switch (VAR_5) {
default:
pr_err(""proc: unrecognized mount option \""%s\"" ""
""or missing value\n"", VAR_2);
return 0;
}
}
return 1;
}",torvalds/linux/0499680a42141d86417a8fbaa8c8db806bea1201/root.c/vul/before/0.json,"static int proc_parse_options(char *options, struct pid_namespace *pid)
{
	char *p;
	substring_t args[MAX_OPT_ARGS];
	int option;

	if (!options)
		return 1;

	while ((p = strsep(&options, "","")) != NULL) {
		int token;
		if (!*p)
			continue;

		args[0].to = args[0].from = 0;
		token = match_token(p, tokens, args);
		switch (token) {
		case Opt_gid:
			if (match_int(&args[0], &option))
				return 0;
			pid->pid_gid = option;
			break;
		case Opt_hidepid:
			if (match_int(&args[0], &option))
				return 0;
			if (option < 0 || option > 2) {
				pr_err(""proc: hidepid value must be between 0 and 2.\n"");
				return 0;
			}
			pid->hide_pid = option;
			break;
		default:
			pr_err(""proc: unrecognized mount option \""%s\"" ""
			       ""or missing value\n"", p);
			return 0;
		}
	}

	return 1;
}","static int proc_parse_options(char *VAR_0, struct pid_namespace *VAR_1)
{
	char *VAR_2;
	substring_t VAR_3[VAR_4];
	int VAR_5;

	if (!VAR_0)
		return 1;

	while ((VAR_2 = strsep(&VAR_0, "","")) != NULL) {
		int VAR_6;
		if (!*VAR_2)
			continue;

		VAR_3[0].to = VAR_3[0].from = 0;
		VAR_6 = match_token(VAR_2, VAR_7, VAR_3);
		switch (VAR_6) {
		case VAR_8:
			if (match_int(&VAR_3[0], &VAR_5))
				return 0;
			VAR_1->pid_gid = VAR_5;
			break;
		case VAR_9:
			if (match_int(&VAR_3[0], &VAR_5))
				return 0;
			if (VAR_5 < 0 || VAR_5 > 2) {
				pr_err(""proc: hidepid value must be between 0 and 2.\n"");
				return 0;
			}
			VAR_1->hide_pid = VAR_5;
			break;
		default:
			pr_err(""proc: unrecognized mount option \""%s\"" ""
			       ""or missing value\n"", VAR_2);
			return 0;
		}
	}

	return 1;
}",torvalds/linux/0499680a42141d86417a8fbaa8c8db806bea1201/root.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -2,8 +2,7 @@
 {
 	char *p;
 	substring_t args[MAX_OPT_ARGS];
-
-	pr_debug(""proc: options = %s\n"", options);
+	int option;
 
 	if (!options)
 		return 1;
@@ -16,6 +15,20 @@
 		args[0].to = args[0].from = 0;
 		token = match_token(p, tokens, args);
 		switch (token) {
+		case Opt_gid:
+			if (match_int(&args[0], &option))
+				return 0;
+			pid->pid_gid = option;
+			break;
+		case Opt_hidepid:
+			if (match_int(&args[0], &option))
+				return 0;
+			if (option < 0 || option > 2) {
+				pr_err(""proc: hidepid value must be between 0 and 2.\n"");
+				return 0;
+			}
+			pid->hide_pid = option;
+			break;
 		default:
 			pr_err(""proc: unrecognized mount option \""%s\"" ""
 			       ""or missing value\n"", p);","{'deleted_lines': ['', '\tpr_debug(""proc: options = %s\\n"", options);'], 'added_lines': ['\tint option;', '\t\tcase Opt_gid:', '\t\t\tif (match_int(&args[0], &option))', '\t\t\t\treturn 0;', '\t\t\tpid->pid_gid = option;', '\t\t\tbreak;', '\t\tcase Opt_hidepid:', '\t\t\tif (match_int(&args[0], &option))', '\t\t\t\treturn 0;', '\t\t\tif (option < 0 || option > 2) {', '\t\t\t\tpr_err(""proc: hidepid value must be between 0 and 2.\\n"");', '\t\t\t\treturn 0;', '\t\t\t}', '\t\t\tpid->hide_pid = option;', '\t\t\tbreak;']}",True,fs/proc/base.c in the Linux kernel through 3.1 allows local users to obtain sensitive keystroke information via access to /proc/interrupts.,5.5,MEDIUM,1,test,,5
CVE-2011-4915,['CWE-200'],AV:L/AC:L/Au:N/C:P/I:N/A:N,0,torvalds/linux,"Add support for mount options to restrict access to /proc/PID/
directories.  The default backward-compatible ""relaxed"" behaviour is left
untouched.

The first mount option is called ""hidepid"" and its value defines how much
info about processes we want to be available for non-owners:

hidepid=0 (default) means the old behavior - anybody may read all
world-readable /proc/PID/* files.

hidepid=1 means users may not access any /proc/<pid>/ directories, but
their own.  Sensitive files like cmdline, sched*, status are now protected
against other users.  As permission checking done in proc_pid_permission()
and files' permissions are left untouched, programs expecting specific
files' modes are not confused.

hidepid=2 means hidepid=1 plus all /proc/PID/ will be invisible to other
users.  It doesn't mean that it hides whether a process exists (it can be
learned by other means, e.g.  by kill -0 $PID), but it hides process' euid
and egid.  It compicates intruder's task of gathering info about running
processes, whether some daemon runs with elevated privileges, whether
another user runs some sensitive program, whether other users run any
program at all, etc.

gid=XXX defines a group that will be able to gather all processes' info
(as in hidepid=0 mode).  This group should be used instead of putting
nonroot user in sudoers file or something.  However, untrusted users (like
daemons, etc.) which are not supposed to monitor the tasks in the whole
system should not be added to the group.

hidepid=1 or higher is designed to restrict access to procfs files, which
might reveal some sensitive private information like precise keystrokes
timings:

http://www.openwall.com/lists/oss-security/2011/11/05/3

hidepid=1/2 doesn't break monitoring userspace tools.  ps, top, pgrep, and
conky gracefully handle EPERM/ENOENT and behave as if the current user is
the only user running processes.  pstree shows the process subtree which
contains ""pstree"" process.

Note: the patch doesn't deal with setuid/setgid issues of keeping
preopened descriptors of procfs files (like
https://lkml.org/lkml/2011/2/7/368).  We rely on that the leaked
information like the scheduling counters of setuid apps doesn't threaten
anybody's privacy - only the user started the setuid program may read the
counters.

Signed-off-by: Vasiliy Kulikov <segoon@openwall.com>
Cc: Alexey Dobriyan <adobriyan@gmail.com>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: Randy Dunlap <rdunlap@xenotime.net>
Cc: ""H. Peter Anvin"" <hpa@zytor.com>
Cc: Greg KH <greg@kroah.com>
Cc: Theodore Tso <tytso@MIT.EDU>
Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
Cc: James Morris <jmorris@namei.org>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: Hugh Dickins <hughd@google.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
",0499680a42141d86417a8fbaa8c8db806bea1201,http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=0499680a42141d86417a8fbaa8c8db806bea1201,fs/proc/inode.c,proc_show_options,"static int proc_show_options(struct seq_file *seq, struct dentry *root)
{
return 0;
}","static int proc_show_options(struct seq_file *VAR_0, struct dentry *VAR_1)
{
return 0;
}",torvalds/linux/0499680a42141d86417a8fbaa8c8db806bea1201/inode.c/vul/before/0.json,"static int proc_show_options(struct seq_file *seq, struct dentry *root)
{
	struct super_block *sb = root->d_sb;
	struct pid_namespace *pid = sb->s_fs_info;

	if (pid->pid_gid)
		seq_printf(seq, "",gid=%lu"", (unsigned long)pid->pid_gid);
	if (pid->hide_pid != 0)
		seq_printf(seq, "",hidepid=%u"", pid->hide_pid);

	return 0;
}","static int proc_show_options(struct seq_file *VAR_0, struct dentry *VAR_1)
{
	struct super_block *VAR_2 = VAR_1->d_sb;
	struct pid_namespace *VAR_3 = VAR_2->s_fs_info;

	if (VAR_3->pid_gid)
		seq_printf(VAR_0, "",gid=%lu"", (unsigned long)VAR_3->pid_gid);
	if (VAR_3->hide_pid != 0)
		seq_printf(VAR_0, "",hidepid=%u"", VAR_3->hide_pid);

	return 0;
}",torvalds/linux/0499680a42141d86417a8fbaa8c8db806bea1201/inode.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,12 @@
 static int proc_show_options(struct seq_file *seq, struct dentry *root)
 {
+	struct super_block *sb = root->d_sb;
+	struct pid_namespace *pid = sb->s_fs_info;
+
+	if (pid->pid_gid)
+		seq_printf(seq, "",gid=%lu"", (unsigned long)pid->pid_gid);
+	if (pid->hide_pid != 0)
+		seq_printf(seq, "",hidepid=%u"", pid->hide_pid);
+
 	return 0;
 }","{'deleted_lines': [], 'added_lines': ['\tstruct super_block *sb = root->d_sb;', '\tstruct pid_namespace *pid = sb->s_fs_info;', '', '\tif (pid->pid_gid)', '\t\tseq_printf(seq, "",gid=%lu"", (unsigned long)pid->pid_gid);', '\tif (pid->hide_pid != 0)', '\t\tseq_printf(seq, "",hidepid=%u"", pid->hide_pid);', '']}",True,fs/proc/base.c in the Linux kernel through 3.1 allows local users to obtain sensitive keystroke information via access to /proc/interrupts.,5.5,MEDIUM,1,test,,5
CVE-2022-45884,"['CWE-362', 'CWE-416']",CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"dvb_register_device() dynamically allocates fops with kmemdup()
to set the fops->owner.
And these fops are registered in 'file->f_ops' using replace_fops()
in the dvb_device_open() process, and kfree()d in dvb_free_device().

However, it is not common to use dynamically allocated fops instead
of 'static const' fops as an argument of replace_fops(),
and UAF may occur.
These UAFs can occur on any dvb type using dvb_register_device(),
such as dvb_dvr, dvb_demux, dvb_frontend, dvb_net, etc.

So, instead of kfree() the fops dynamically allocated in
dvb_register_device() in dvb_free_device() called during the
.disconnect() process, kfree() it collectively in exit_dvbdev()
called when the dvbdev.c module is removed.

Link: https://lore.kernel.org/linux-media/20221117045925.14297-4-imv4bel@gmail.com
Signed-off-by: Hyunwoo Kim <imv4bel@gmail.com>
Reported-by: kernel test robot <lkp@intel.com>
Reported-by: Dan Carpenter <error27@gmail.com>
Signed-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>
",627bb528b086b4136315c25d6a447a98ea9448d3,https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=627bb528b086b4136315c25d6a447a98ea9448d3,drivers/media/dvb-core/dvbdev.c,dvb_register_device,"int dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,
const struct dvb_device *template, void *priv,
enum dvb_device_type type, int demux_sink_pads)
{
struct dvb_device *dvbdev;
struct file_operations *dvbdevfops;
struct device *clsdev;
int minor;
int id, ret;
mutex_lock(&dvbdev_register_lock);
if ((id = dvbdev_get_free_id (adap, type)) < 0){
mutex_unlock(&dvbdev_register_lock);
*pdvbdev = NULL;
pr_err(""%s: couldn't find free device id\n"", __func__);
return -ENFILE;
}
*pdvbdev = dvbdev = kzalloc(sizeof(*dvbdev), GFP_KERNEL);
if (!dvbdev){
mutex_unlock(&dvbdev_register_lock);
return -ENOMEM;
}
dvbdevfops = kmemdup(template->fops, sizeof(*dvbdevfops), GFP_KERNEL);
if (!dvbdevfops){
kfree (dvbdev);
mutex_unlock(&dvbdev_register_lock);
return -ENOMEM;
}
memcpy(dvbdev, template, sizeof(struct dvb_device));
kref_init(&dvbdev->ref);
dvbdev->type = type;
dvbdev->id = id;
dvbdev->adapter = adap;
dvbdev->priv = priv;
dvbdev->fops = dvbdevfops;
init_waitqueue_head (&dvbdev->wait_queue);
dvbdevfops->owner = adap->module;
list_add_tail (&dvbdev->list_head, &adap->device_list);
down_write(&minor_rwsem);
#ifdef CONFIG_DVB_DYNAMIC_MINORS
for (minor = 0; minor < MAX_DVB_MINORS; minor++)
if (dvb_minors[minor] == NULL)
break;
if (minor == MAX_DVB_MINORS) {
list_del (&dvbdev->list_head);
kfree(dvbdevfops);
kfree(dvbdev);
up_write(&minor_rwsem);
mutex_unlock(&dvbdev_register_lock);
return -EINVAL;
}
#else
minor = nums2minor(adap->num, type, id);
#endif
dvbdev->minor = minor;
dvb_minors[minor] = dvb_device_get(dvbdev);
up_write(&minor_rwsem);
ret = dvb_register_media_device(dvbdev, type, minor, demux_sink_pads);
if (ret) {
pr_err(""%s: dvb_register_media_device failed to create the mediagraph\n"",
__func__);
dvb_media_device_free(dvbdev);
list_del (&dvbdev->list_head);
kfree(dvbdevfops);
kfree(dvbdev);
mutex_unlock(&dvbdev_register_lock);
return ret;
}
mutex_unlock(&dvbdev_register_lock);
clsdev = device_create(dvb_class, adap->device,
MKDEV(DVB_MAJOR, minor),
dvbdev, ""dvb%d.%s%d"", adap->num, dnames[type], id);
if (IS_ERR(clsdev)) {
pr_err(""%s: failed to create device dvb%d.%s%d (%ld)\n"",
__func__, adap->num, dnames[type], id, PTR_ERR(clsdev));
dvb_media_device_free(dvbdev);
list_del (&dvbdev->list_head);
kfree(dvbdevfops);
kfree(dvbdev);
return PTR_ERR(clsdev);
}
dprintk(""DVB: register adapter%d/%s%d @ minor: %i (0x%02x)\n"",
adap->num, dnames[type], id, minor, minor);
return 0;
}","int dvb_register_device(struct dvb_adapter *VAR_0, struct dvb_device **VAR_1,
const struct dvb_device *VAR_2, void *VAR_3,
enum dvb_device_type VAR_4, int VAR_5)
{
struct dvb_device *VAR_6;
struct file_operations *VAR_7;
struct device *VAR_8;
int VAR_9;
int VAR_10, VAR_11;
mutex_lock(&VAR_12);
if ((VAR_10 = dvbdev_get_free_id (VAR_0, VAR_4)) < 0){
mutex_unlock(&VAR_12);
*VAR_1 = NULL;
pr_err(""%s: couldn't find free device id\n"", VAR_13);
return -VAR_14;
}
*VAR_1 = VAR_6 = kzalloc(sizeof(*VAR_6), VAR_15);
if (!VAR_6){
mutex_unlock(&VAR_12);
return -VAR_16;
}
VAR_7 = kmemdup(VAR_2->fops, sizeof(*VAR_7), VAR_15);
if (!VAR_7){
kfree (VAR_6);
mutex_unlock(&VAR_12);
return -VAR_16;
}
memcpy(VAR_6, VAR_2, sizeof(struct dvb_device));
kref_init(&VAR_6->ref);
VAR_6->type = VAR_4;
VAR_6->id = VAR_10;
VAR_6->adapter = VAR_0;
VAR_6->priv = VAR_3;
VAR_6->fops = VAR_7;
init_waitqueue_head (&VAR_6->wait_queue);
VAR_7->owner = VAR_0->module;
list_add_tail (&VAR_6->list_head, &VAR_0->device_list);
down_write(&VAR_17);
#ifdef VAR_18
for (VAR_9 = 0; VAR_9 < VAR_19; VAR_9++)
if (VAR_20[VAR_9] == NULL)
break;
if (VAR_9 == VAR_19) {
list_del (&VAR_6->list_head);
kfree(VAR_7);
kfree(VAR_6);
up_write(&VAR_17);
mutex_unlock(&VAR_12);
return -VAR_21;
}
#else
VAR_9 = nums2minor(VAR_0->num, VAR_4, VAR_10);
#endif
VAR_6->minor = VAR_9;
VAR_20[VAR_9] = dvb_device_get(VAR_6);
up_write(&VAR_17);
VAR_11 = dvb_register_media_device(VAR_6, VAR_4, VAR_9, VAR_5);
if (VAR_11) {
pr_err(""%s: dvb_register_media_device failed to create the mediagraph\n"",
VAR_13);
dvb_media_device_free(VAR_6);
list_del (&VAR_6->list_head);
kfree(VAR_7);
kfree(VAR_6);
mutex_unlock(&VAR_12);
return VAR_11;
}
mutex_unlock(&VAR_12);
VAR_8 = device_create(VAR_22, VAR_0->device,
MKDEV(VAR_23, VAR_9),
VAR_6, ""dvb%d.%s%d"", VAR_0->num, VAR_24[VAR_4], VAR_10);
if (IS_ERR(VAR_8)) {
pr_err(""%s: failed to create device dvb%d.%s%d (%ld)\n"",
VAR_13, VAR_0->num, VAR_24[VAR_4], VAR_10, PTR_ERR(VAR_8));
dvb_media_device_free(VAR_6);
list_del (&VAR_6->list_head);
kfree(VAR_7);
kfree(VAR_6);
return PTR_ERR(VAR_8);
}
dprintk(""DVB: register adapter%d/%s%d @ minor: %i (0x%02x)\n"",
VAR_0->num, VAR_24[VAR_4], VAR_10, VAR_9, VAR_9);
return 0;
}",torvalds/linux/627bb528b086b4136315c25d6a447a98ea9448d3/dvbdev.c/vul/before/0.json,"int dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,
			const struct dvb_device *template, void *priv,
			enum dvb_device_type type, int demux_sink_pads)
{
	struct dvb_device *dvbdev;
	struct file_operations *dvbdevfops = NULL;
	struct dvbdevfops_node *node = NULL, *new_node = NULL;
	struct device *clsdev;
	int minor;
	int id, ret;

	mutex_lock(&dvbdev_register_lock);

	if ((id = dvbdev_get_free_id (adap, type)) < 0) {
		mutex_unlock(&dvbdev_register_lock);
		*pdvbdev = NULL;
		pr_err(""%s: couldn't find free device id\n"", __func__);
		return -ENFILE;
	}

	*pdvbdev = dvbdev = kzalloc(sizeof(*dvbdev), GFP_KERNEL);
	if (!dvbdev){
		mutex_unlock(&dvbdev_register_lock);
		return -ENOMEM;
	}

	/*
	 * When a device of the same type is probe()d more than once,
	 * the first allocated fops are used. This prevents memory leaks
	 * that can occur when the same device is probe()d repeatedly.
	 */
	list_for_each_entry(node, &dvbdevfops_list, list_head) {
		if (node->fops->owner == adap->module &&
				node->type == type &&
				node->template == template) {
			dvbdevfops = node->fops;
			break;
		}
	}

	if (dvbdevfops == NULL) {
		dvbdevfops = kmemdup(template->fops, sizeof(*dvbdevfops), GFP_KERNEL);
		if (!dvbdevfops) {
			kfree(dvbdev);
			mutex_unlock(&dvbdev_register_lock);
			return -ENOMEM;
		}

		new_node = kzalloc(sizeof(struct dvbdevfops_node), GFP_KERNEL);
		if (!new_node) {
			kfree(dvbdevfops);
			kfree(dvbdev);
			mutex_unlock(&dvbdev_register_lock);
			return -ENOMEM;
		}

		new_node->fops = dvbdevfops;
		new_node->type = type;
		new_node->template = template;
		list_add_tail (&new_node->list_head, &dvbdevfops_list);
	}

	memcpy(dvbdev, template, sizeof(struct dvb_device));
	kref_init(&dvbdev->ref);
	dvbdev->type = type;
	dvbdev->id = id;
	dvbdev->adapter = adap;
	dvbdev->priv = priv;
	dvbdev->fops = dvbdevfops;
	init_waitqueue_head (&dvbdev->wait_queue);
	dvbdevfops->owner = adap->module;
	list_add_tail (&dvbdev->list_head, &adap->device_list);
	down_write(&minor_rwsem);
#ifdef CONFIG_DVB_DYNAMIC_MINORS
	for (minor = 0; minor < MAX_DVB_MINORS; minor++)
		if (dvb_minors[minor] == NULL)
			break;
	if (minor == MAX_DVB_MINORS) {
		if (new_node) {
			list_del (&new_node->list_head);
			kfree(dvbdevfops);
			kfree(new_node);
		}
		list_del (&dvbdev->list_head);
		kfree(dvbdev);
		up_write(&minor_rwsem);
		mutex_unlock(&dvbdev_register_lock);
		return -EINVAL;
	}
#else
	minor = nums2minor(adap->num, type, id);
#endif
	dvbdev->minor = minor;
	dvb_minors[minor] = dvb_device_get(dvbdev);
	up_write(&minor_rwsem);
	ret = dvb_register_media_device(dvbdev, type, minor, demux_sink_pads);
	if (ret) {
		pr_err(""%s: dvb_register_media_device failed to create the mediagraph\n"",
		      __func__);
		if (new_node) {
			list_del (&new_node->list_head);
			kfree(dvbdevfops);
			kfree(new_node);
		}
		dvb_media_device_free(dvbdev);
		list_del (&dvbdev->list_head);
		kfree(dvbdev);
		mutex_unlock(&dvbdev_register_lock);
		return ret;
	}

	clsdev = device_create(dvb_class, adap->device,
			       MKDEV(DVB_MAJOR, minor),
			       dvbdev, ""dvb%d.%s%d"", adap->num, dnames[type], id);
	if (IS_ERR(clsdev)) {
		pr_err(""%s: failed to create device dvb%d.%s%d (%ld)\n"",
		       __func__, adap->num, dnames[type], id, PTR_ERR(clsdev));
		if (new_node) {
			list_del (&new_node->list_head);
			kfree(dvbdevfops);
			kfree(new_node);
		}
		dvb_media_device_free(dvbdev);
		list_del (&dvbdev->list_head);
		kfree(dvbdev);
		mutex_unlock(&dvbdev_register_lock);
		return PTR_ERR(clsdev);
	}

	dprintk(""DVB: register adapter%d/%s%d @ minor: %i (0x%02x)\n"",
		adap->num, dnames[type], id, minor, minor);

	mutex_unlock(&dvbdev_register_lock);
	return 0;
}","int dvb_register_device(struct dvb_adapter *VAR_0, struct dvb_device **VAR_1,
			const struct dvb_device *VAR_2, void *VAR_3,
			enum dvb_device_type VAR_4, int VAR_5)
{
	struct dvb_device *VAR_6;
	struct file_operations *VAR_7 = NULL;
	struct dvbdevfops_node *VAR_8 = NULL, *VAR_9 = NULL;
	struct device *VAR_10;
	int VAR_11;
	int VAR_12, VAR_13;

	mutex_lock(&VAR_14);

	if ((VAR_12 = dvbdev_get_free_id (VAR_0, VAR_4)) < 0) {
		mutex_unlock(&VAR_14);
		*VAR_1 = NULL;
		pr_err(""%s: couldn't find free device id\n"", VAR_15);
		return -VAR_16;
	}

	*VAR_1 = VAR_6 = kzalloc(sizeof(*VAR_6), VAR_17);
	if (!VAR_6){
		mutex_unlock(&VAR_14);
		return -VAR_18;
	}

	/* COMMENT_0 */
                                                              
                                                                 
                                                               
    
	list_for_each_entry(VAR_8, &VAR_19, VAR_20) {
		if (VAR_8->fops->owner == VAR_0->module &&
				VAR_8->type == VAR_4 &&
				VAR_8->template == VAR_2) {
			VAR_7 = VAR_8->fops;
			break;
		}
	}

	if (VAR_7 == NULL) {
		VAR_7 = kmemdup(VAR_2->fops, sizeof(*VAR_7), VAR_17);
		if (!VAR_7) {
			kfree(VAR_6);
			mutex_unlock(&VAR_14);
			return -VAR_18;
		}

		VAR_9 = kzalloc(sizeof(struct dvbdevfops_node), VAR_17);
		if (!VAR_9) {
			kfree(VAR_7);
			kfree(VAR_6);
			mutex_unlock(&VAR_14);
			return -VAR_18;
		}

		VAR_9->fops = VAR_7;
		VAR_9->type = VAR_4;
		VAR_9->template = VAR_2;
		list_add_tail (&VAR_9->list_head, &VAR_19);
	}

	memcpy(VAR_6, VAR_2, sizeof(struct dvb_device));
	kref_init(&VAR_6->ref);
	VAR_6->type = VAR_4;
	VAR_6->id = VAR_12;
	VAR_6->adapter = VAR_0;
	VAR_6->priv = VAR_3;
	VAR_6->fops = VAR_7;
	init_waitqueue_head (&VAR_6->wait_queue);
	VAR_7->owner = VAR_0->module;
	list_add_tail (&VAR_6->list_head, &VAR_0->device_list);
	down_write(&VAR_21);
#ifdef VAR_22
	for (VAR_11 = 0; VAR_11 < VAR_23; VAR_11++)
		if (VAR_24[VAR_11] == NULL)
			break;
	if (VAR_11 == VAR_23) {
		if (VAR_9) {
			list_del (&VAR_9->list_head);
			kfree(VAR_7);
			kfree(VAR_9);
		}
		list_del (&VAR_6->list_head);
		kfree(VAR_6);
		up_write(&VAR_21);
		mutex_unlock(&VAR_14);
		return -VAR_25;
	}
#else
	VAR_11 = nums2minor(VAR_0->num, VAR_4, VAR_12);
#endif
	VAR_6->minor = VAR_11;
	VAR_24[VAR_11] = dvb_device_get(VAR_6);
	up_write(&VAR_21);
	VAR_13 = dvb_register_media_device(VAR_6, VAR_4, VAR_11, VAR_5);
	if (VAR_13) {
		pr_err(""%s: dvb_register_media_device failed to create the mediagraph\n"",
		      VAR_15);
		if (VAR_9) {
			list_del (&VAR_9->list_head);
			kfree(VAR_7);
			kfree(VAR_9);
		}
		dvb_media_device_free(VAR_6);
		list_del (&VAR_6->list_head);
		kfree(VAR_6);
		mutex_unlock(&VAR_14);
		return VAR_13;
	}

	VAR_10 = device_create(VAR_26, VAR_0->device,
			       MKDEV(VAR_27, VAR_11),
			       VAR_6, ""dvb%d.%s%d"", VAR_0->num, VAR_28[VAR_4], VAR_12);
	if (IS_ERR(VAR_10)) {
		pr_err(""%s: failed to create device dvb%d.%s%d (%ld)\n"",
		       VAR_15, VAR_0->num, VAR_28[VAR_4], VAR_12, PTR_ERR(VAR_10));
		if (VAR_9) {
			list_del (&VAR_9->list_head);
			kfree(VAR_7);
			kfree(VAR_9);
		}
		dvb_media_device_free(VAR_6);
		list_del (&VAR_6->list_head);
		kfree(VAR_6);
		mutex_unlock(&VAR_14);
		return PTR_ERR(VAR_10);
	}

	dprintk(""DVB: register adapter%d/%s%d @ minor: %i (0x%02x)\n"",
		VAR_0->num, VAR_28[VAR_4], VAR_12, VAR_11, VAR_11);

	mutex_unlock(&VAR_14);
	return 0;
}",torvalds/linux/627bb528b086b4136315c25d6a447a98ea9448d3/dvbdev.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,14 +3,15 @@
 			enum dvb_device_type type, int demux_sink_pads)
 {
 	struct dvb_device *dvbdev;
-	struct file_operations *dvbdevfops;
+	struct file_operations *dvbdevfops = NULL;
+	struct dvbdevfops_node *node = NULL, *new_node = NULL;
 	struct device *clsdev;
 	int minor;
 	int id, ret;
 
 	mutex_lock(&dvbdev_register_lock);
 
-	if ((id = dvbdev_get_free_id (adap, type)) < 0){
+	if ((id = dvbdev_get_free_id (adap, type)) < 0) {
 		mutex_unlock(&dvbdev_register_lock);
 		*pdvbdev = NULL;
 		pr_err(""%s: couldn't find free device id\n"", __func__);
@@ -18,18 +19,45 @@
 	}
 
 	*pdvbdev = dvbdev = kzalloc(sizeof(*dvbdev), GFP_KERNEL);
-
 	if (!dvbdev){
 		mutex_unlock(&dvbdev_register_lock);
 		return -ENOMEM;
 	}
 
-	dvbdevfops = kmemdup(template->fops, sizeof(*dvbdevfops), GFP_KERNEL);
+	/*
+	 * When a device of the same type is probe()d more than once,
+	 * the first allocated fops are used. This prevents memory leaks
+	 * that can occur when the same device is probe()d repeatedly.
+	 */
+	list_for_each_entry(node, &dvbdevfops_list, list_head) {
+		if (node->fops->owner == adap->module &&
+				node->type == type &&
+				node->template == template) {
+			dvbdevfops = node->fops;
+			break;
+		}
+	}
 
-	if (!dvbdevfops){
-		kfree (dvbdev);
-		mutex_unlock(&dvbdev_register_lock);
-		return -ENOMEM;
+	if (dvbdevfops == NULL) {
+		dvbdevfops = kmemdup(template->fops, sizeof(*dvbdevfops), GFP_KERNEL);
+		if (!dvbdevfops) {
+			kfree(dvbdev);
+			mutex_unlock(&dvbdev_register_lock);
+			return -ENOMEM;
+		}
+
+		new_node = kzalloc(sizeof(struct dvbdevfops_node), GFP_KERNEL);
+		if (!new_node) {
+			kfree(dvbdevfops);
+			kfree(dvbdev);
+			mutex_unlock(&dvbdev_register_lock);
+			return -ENOMEM;
+		}
+
+		new_node->fops = dvbdevfops;
+		new_node->type = type;
+		new_node->template = template;
+		list_add_tail (&new_node->list_head, &dvbdevfops_list);
 	}
 
 	memcpy(dvbdev, template, sizeof(struct dvb_device));
@@ -40,20 +68,20 @@
 	dvbdev->priv = priv;
 	dvbdev->fops = dvbdevfops;
 	init_waitqueue_head (&dvbdev->wait_queue);
-
 	dvbdevfops->owner = adap->module;
-
 	list_add_tail (&dvbdev->list_head, &adap->device_list);
-
 	down_write(&minor_rwsem);
 #ifdef CONFIG_DVB_DYNAMIC_MINORS
 	for (minor = 0; minor < MAX_DVB_MINORS; minor++)
 		if (dvb_minors[minor] == NULL)
 			break;
-
 	if (minor == MAX_DVB_MINORS) {
+		if (new_node) {
+			list_del (&new_node->list_head);
+			kfree(dvbdevfops);
+			kfree(new_node);
+		}
 		list_del (&dvbdev->list_head);
-		kfree(dvbdevfops);
 		kfree(dvbdev);
 		up_write(&minor_rwsem);
 		mutex_unlock(&dvbdev_register_lock);
@@ -62,25 +90,24 @@
 #else
 	minor = nums2minor(adap->num, type, id);
 #endif
-
 	dvbdev->minor = minor;
 	dvb_minors[minor] = dvb_device_get(dvbdev);
 	up_write(&minor_rwsem);
-
 	ret = dvb_register_media_device(dvbdev, type, minor, demux_sink_pads);
 	if (ret) {
 		pr_err(""%s: dvb_register_media_device failed to create the mediagraph\n"",
 		      __func__);
-
+		if (new_node) {
+			list_del (&new_node->list_head);
+			kfree(dvbdevfops);
+			kfree(new_node);
+		}
 		dvb_media_device_free(dvbdev);
 		list_del (&dvbdev->list_head);
-		kfree(dvbdevfops);
 		kfree(dvbdev);
 		mutex_unlock(&dvbdev_register_lock);
 		return ret;
 	}
-
-	mutex_unlock(&dvbdev_register_lock);
 
 	clsdev = device_create(dvb_class, adap->device,
 			       MKDEV(DVB_MAJOR, minor),
@@ -88,14 +115,21 @@
 	if (IS_ERR(clsdev)) {
 		pr_err(""%s: failed to create device dvb%d.%s%d (%ld)\n"",
 		       __func__, adap->num, dnames[type], id, PTR_ERR(clsdev));
+		if (new_node) {
+			list_del (&new_node->list_head);
+			kfree(dvbdevfops);
+			kfree(new_node);
+		}
 		dvb_media_device_free(dvbdev);
 		list_del (&dvbdev->list_head);
-		kfree(dvbdevfops);
 		kfree(dvbdev);
+		mutex_unlock(&dvbdev_register_lock);
 		return PTR_ERR(clsdev);
 	}
+
 	dprintk(""DVB: register adapter%d/%s%d @ minor: %i (0x%02x)\n"",
 		adap->num, dnames[type], id, minor, minor);
 
+	mutex_unlock(&dvbdev_register_lock);
 	return 0;
 }","{'deleted_lines': ['\tstruct file_operations *dvbdevfops;', '\tif ((id = dvbdev_get_free_id (adap, type)) < 0){', '', '\tdvbdevfops = kmemdup(template->fops, sizeof(*dvbdevfops), GFP_KERNEL);', '\tif (!dvbdevfops){', '\t\tkfree (dvbdev);', '\t\tmutex_unlock(&dvbdev_register_lock);', '\t\treturn -ENOMEM;', '', '', '', '', '\t\tkfree(dvbdevfops);', '', '', '', '\t\tkfree(dvbdevfops);', '', '\tmutex_unlock(&dvbdev_register_lock);', '\t\tkfree(dvbdevfops);'], 'added_lines': ['\tstruct file_operations *dvbdevfops = NULL;', '\tstruct dvbdevfops_node *node = NULL, *new_node = NULL;', '\tif ((id = dvbdev_get_free_id (adap, type)) < 0) {', '\t/*', '\t * When a device of the same type is probe()d more than once,', '\t * the first allocated fops are used. This prevents memory leaks', '\t * that can occur when the same device is probe()d repeatedly.', '\t */', '\tlist_for_each_entry(node, &dvbdevfops_list, list_head) {', '\t\tif (node->fops->owner == adap->module &&', '\t\t\t\tnode->type == type &&', '\t\t\t\tnode->template == template) {', '\t\t\tdvbdevfops = node->fops;', '\t\t\tbreak;', '\t\t}', '\t}', '\tif (dvbdevfops == NULL) {', '\t\tdvbdevfops = kmemdup(template->fops, sizeof(*dvbdevfops), GFP_KERNEL);', '\t\tif (!dvbdevfops) {', '\t\t\tkfree(dvbdev);', '\t\t\tmutex_unlock(&dvbdev_register_lock);', '\t\t\treturn -ENOMEM;', '\t\t}', '', '\t\tnew_node = kzalloc(sizeof(struct dvbdevfops_node), GFP_KERNEL);', '\t\tif (!new_node) {', '\t\t\tkfree(dvbdevfops);', '\t\t\tkfree(dvbdev);', '\t\t\tmutex_unlock(&dvbdev_register_lock);', '\t\t\treturn -ENOMEM;', '\t\t}', '', '\t\tnew_node->fops = dvbdevfops;', '\t\tnew_node->type = type;', '\t\tnew_node->template = template;', '\t\tlist_add_tail (&new_node->list_head, &dvbdevfops_list);', '\t\tif (new_node) {', '\t\t\tlist_del (&new_node->list_head);', '\t\t\tkfree(dvbdevfops);', '\t\t\tkfree(new_node);', '\t\t}', '\t\tif (new_node) {', '\t\t\tlist_del (&new_node->list_head);', '\t\t\tkfree(dvbdevfops);', '\t\t\tkfree(new_node);', '\t\t}', '\t\tif (new_node) {', '\t\t\tlist_del (&new_node->list_head);', '\t\t\tkfree(dvbdevfops);', '\t\t\tkfree(new_node);', '\t\t}', '\t\tmutex_unlock(&dvbdev_register_lock);', '', '\tmutex_unlock(&dvbdev_register_lock);']}",True,"An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvbdev.c has a use-after-free, related to dvb_register_device dynamically allocating fops.",7.0,HIGH,2,test,,5
CVE-2022-45884,"['CWE-362', 'CWE-416']",CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"dvb_register_device() dynamically allocates fops with kmemdup()
to set the fops->owner.
And these fops are registered in 'file->f_ops' using replace_fops()
in the dvb_device_open() process, and kfree()d in dvb_free_device().

However, it is not common to use dynamically allocated fops instead
of 'static const' fops as an argument of replace_fops(),
and UAF may occur.
These UAFs can occur on any dvb type using dvb_register_device(),
such as dvb_dvr, dvb_demux, dvb_frontend, dvb_net, etc.

So, instead of kfree() the fops dynamically allocated in
dvb_register_device() in dvb_free_device() called during the
.disconnect() process, kfree() it collectively in exit_dvbdev()
called when the dvbdev.c module is removed.

Link: https://lore.kernel.org/linux-media/20221117045925.14297-4-imv4bel@gmail.com
Signed-off-by: Hyunwoo Kim <imv4bel@gmail.com>
Reported-by: kernel test robot <lkp@intel.com>
Reported-by: Dan Carpenter <error27@gmail.com>
Signed-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>
",627bb528b086b4136315c25d6a447a98ea9448d3,https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=627bb528b086b4136315c25d6a447a98ea9448d3,drivers/media/dvb-core/dvbdev.c,dvb_free_device,"static void dvb_free_device(struct kref *ref)
{
struct dvb_device *dvbdev = container_of(ref, struct dvb_device, ref);
kfree (dvbdev->fops);
kfree (dvbdev);
}","static void dvb_free_device(struct kref *VAR_0)
{
struct dvb_device *VAR_1 = container_of(VAR_0, struct dvb_device, VAR_0);
kfree (VAR_1->fops);
kfree (VAR_1);
}",torvalds/linux/627bb528b086b4136315c25d6a447a98ea9448d3/dvbdev.c/vul/before/1.json,"static void dvb_free_device(struct kref *ref)
{
	struct dvb_device *dvbdev = container_of(ref, struct dvb_device, ref);

	kfree (dvbdev);
}","static void dvb_free_device(struct kref *VAR_0)
{
	struct dvb_device *VAR_1 = container_of(VAR_0, struct dvb_device, VAR_0);

	kfree (VAR_1);
}",torvalds/linux/627bb528b086b4136315c25d6a447a98ea9448d3/dvbdev.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -2,6 +2,5 @@
 {
 	struct dvb_device *dvbdev = container_of(ref, struct dvb_device, ref);
 
-	kfree (dvbdev->fops);
 	kfree (dvbdev);
 }","{'deleted_lines': ['\tkfree (dvbdev->fops);'], 'added_lines': []}",True,"An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvbdev.c has a use-after-free, related to dvb_register_device dynamically allocating fops.",7.0,HIGH,2,test,,5
CVE-2022-45884,"['CWE-362', 'CWE-416']",CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"dvb_register_device() dynamically allocates fops with kmemdup()
to set the fops->owner.
And these fops are registered in 'file->f_ops' using replace_fops()
in the dvb_device_open() process, and kfree()d in dvb_free_device().

However, it is not common to use dynamically allocated fops instead
of 'static const' fops as an argument of replace_fops(),
and UAF may occur.
These UAFs can occur on any dvb type using dvb_register_device(),
such as dvb_dvr, dvb_demux, dvb_frontend, dvb_net, etc.

So, instead of kfree() the fops dynamically allocated in
dvb_register_device() in dvb_free_device() called during the
.disconnect() process, kfree() it collectively in exit_dvbdev()
called when the dvbdev.c module is removed.

Link: https://lore.kernel.org/linux-media/20221117045925.14297-4-imv4bel@gmail.com
Signed-off-by: Hyunwoo Kim <imv4bel@gmail.com>
Reported-by: kernel test robot <lkp@intel.com>
Reported-by: Dan Carpenter <error27@gmail.com>
Signed-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>
",627bb528b086b4136315c25d6a447a98ea9448d3,https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=627bb528b086b4136315c25d6a447a98ea9448d3,drivers/media/dvb-core/dvbdev.c,exit_dvbdev,"static void __exit exit_dvbdev(void)
{
class_destroy(dvb_class);
cdev_del(&dvb_device_cdev);
unregister_chrdev_region(MKDEV(DVB_MAJOR, 0), MAX_DVB_MINORS);
}","static void VAR_0 exit_dvbdev(void)
{
class_destroy(VAR_1);
cdev_del(&VAR_2);
unregister_chrdev_region(MKDEV(VAR_3, 0), VAR_4);
}",,"static void __exit exit_dvbdev(void)
{
	struct dvbdevfops_node *node, *next;

	class_destroy(dvb_class);
	cdev_del(&dvb_device_cdev);
	unregister_chrdev_region(MKDEV(DVB_MAJOR, 0), MAX_DVB_MINORS);

	list_for_each_entry_safe(node, next, &dvbdevfops_list, list_head) {
		list_del (&node->list_head);
		kfree(node->fops);
		kfree(node);
	}
}","static void VAR_0 exit_dvbdev(void)
{
	struct dvbdevfops_node *VAR_1, *VAR_2;

	class_destroy(VAR_3);
	cdev_del(&VAR_4);
	unregister_chrdev_region(MKDEV(VAR_5, 0), VAR_6);

	list_for_each_entry_safe(VAR_1, VAR_2, &VAR_7, VAR_8) {
		list_del (&VAR_1->list_head);
		kfree(VAR_1->fops);
		kfree(VAR_1);
	}
}",,"--- func_before
+++ func_after
@@ -1,6 +1,14 @@
 static void __exit exit_dvbdev(void)
 {
+	struct dvbdevfops_node *node, *next;
+
 	class_destroy(dvb_class);
 	cdev_del(&dvb_device_cdev);
 	unregister_chrdev_region(MKDEV(DVB_MAJOR, 0), MAX_DVB_MINORS);
+
+	list_for_each_entry_safe(node, next, &dvbdevfops_list, list_head) {
+		list_del (&node->list_head);
+		kfree(node->fops);
+		kfree(node);
+	}
 }","{'deleted_lines': [], 'added_lines': ['\tstruct dvbdevfops_node *node, *next;', '', '', '\tlist_for_each_entry_safe(node, next, &dvbdevfops_list, list_head) {', '\t\tlist_del (&node->list_head);', '\t\tkfree(node->fops);', '\t\tkfree(node);', '\t}']}",True,"An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvbdev.c has a use-after-free, related to dvb_register_device dynamically allocating fops.",7.0,HIGH,2,test,,5
CVE-2022-45934,['CWE-190'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H,1,kernel/git/bluetooth/bluetooth-next,"By keep sending L2CAP_CONF_REQ packets, chan->num_conf_rsp increases
multiple times and eventually it will wrap around the maximum number
(i.e., 255).
This patch prevents this by adding a boundary check with
L2CAP_MAX_CONF_RSP

Btmon log:
Bluetooth monitor ver 5.64
= Note: Linux version 6.1.0-rc2 (x86_64)                               0.264594
= Note: Bluetooth subsystem version 2.22                               0.264636
@ MGMT Open: btmon (privileged) version 1.22                  {0x0001} 0.272191
= New Index: 00:00:00:00:00:00 (Primary,Virtual,hci0)          [hci0] 13.877604
@ RAW Open: 9496 (privileged) version 2.22                   {0x0002} 13.890741
= Open Index: 00:00:00:00:00:00                                [hci0] 13.900426
(...)
> ACL Data RX: Handle 200 flags 0x00 dlen 1033             #32 [hci0] 14.273106
        invalid packet size (12 != 1033)
        08 00 01 00 02 01 04 00 01 10 ff ff              ............
> ACL Data RX: Handle 200 flags 0x00 dlen 1547             #33 [hci0] 14.273561
        invalid packet size (14 != 1547)
        0a 00 01 00 04 01 06 00 40 00 00 00 00 00        ........@.....
> ACL Data RX: Handle 200 flags 0x00 dlen 2061             #34 [hci0] 14.274390
        invalid packet size (16 != 2061)
        0c 00 01 00 04 01 08 00 40 00 00 00 00 00 00 04  ........@.......
> ACL Data RX: Handle 200 flags 0x00 dlen 2061             #35 [hci0] 14.274932
        invalid packet size (16 != 2061)
        0c 00 01 00 04 01 08 00 40 00 00 00 07 00 03 00  ........@.......
= bluetoothd: Bluetooth daemon 5.43                                   14.401828
> ACL Data RX: Handle 200 flags 0x00 dlen 1033             #36 [hci0] 14.275753
        invalid packet size (12 != 1033)
        08 00 01 00 04 01 04 00 40 00 00 00              ........@...

Signed-off-by: Sungwoo Kim <iam@sung-woo.kim>
Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
",ae4569813a6e931258db627cdfe50dfb4f917d5d,https://git.kernel.org/pub/scm/linux/kernel/git/bluetooth/bluetooth-next.git/commit/?h=ae4569813a6e931258db627cdfe50dfb4f917d5d,net/bluetooth/l2cap_core.c,l2cap_config_req,"static inline int l2cap_config_req(struct l2cap_conn *conn,
struct l2cap_cmd_hdr *cmd, u16 cmd_len,
u8 *data)
{
struct l2cap_conf_req *req = (struct l2cap_conf_req *) data;
u16 dcid, flags;
u8 rsp[64];
struct l2cap_chan *chan;
int len, err = 0;
if (cmd_len < sizeof(*req))
return -EPROTO;
dcid  = __le16_to_cpu(req->dcid);
flags = __le16_to_cpu(req->flags);
BT_DBG(""dcid 0x%4.4x flags 0x%2.2x"", dcid, flags);
chan = l2cap_get_chan_by_scid(conn, dcid);
if (!chan) {
cmd_reject_invalid_cid(conn, cmd->ident, dcid, 0);
return 0;
}
if (chan->state != BT_CONFIG && chan->state != BT_CONNECT2 &&
chan->state != BT_CONNECTED) {
cmd_reject_invalid_cid(conn, cmd->ident, chan->scid,
chan->dcid);
goto unlock;
}
len = cmd_len - sizeof(*req);
if (chan->conf_len + len > sizeof(chan->conf_req)) {
l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
l2cap_build_conf_rsp(chan, rsp,
L2CAP_CONF_REJECT, flags), rsp);
goto unlock;
}
memcpy(chan->conf_req + chan->conf_len, req->data, len);
chan->conf_len += len;
if (flags & L2CAP_CONF_FLAG_CONTINUATION) {
l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
l2cap_build_conf_rsp(chan, rsp,
L2CAP_CONF_SUCCESS, flags), rsp);
goto unlock;
}
len = l2cap_parse_conf_req(chan, rsp, sizeof(rsp));
if (len < 0) {
l2cap_send_disconn_req(chan, ECONNRESET);
goto unlock;
}
chan->ident = cmd->ident;
l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);
chan->num_conf_rsp++;
chan->conf_len = 0;
if (!test_bit(CONF_OUTPUT_DONE, &chan->conf_state))
goto unlock;
if (test_bit(CONF_INPUT_DONE, &chan->conf_state)) {
set_default_fcs(chan);
if (chan->mode == L2CAP_MODE_ERTM ||
chan->mode == L2CAP_MODE_STREAMING)
err = l2cap_ertm_init(chan);
if (err < 0)
l2cap_send_disconn_req(chan, -err);
else
l2cap_chan_ready(chan);
goto unlock;
}
if (!test_and_set_bit(CONF_REQ_SENT, &chan->conf_state)) {
u8 buf[64];
l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);
chan->num_conf_req++;
}
if (test_bit(CONF_REM_CONF_PEND, &chan->conf_state) &&
test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {
if (!chan->hs_hcon)
l2cap_send_efs_conf_rsp(chan, rsp, cmd->ident, flags);
else
chan->ident = cmd->ident;
}
unlock:
l2cap_chan_unlock(chan);
l2cap_chan_put(chan);
return err;
}","static inline int l2cap_config_req(struct l2cap_conn *VAR_0,
struct l2cap_cmd_hdr *VAR_1, u16 VAR_2,
u8 *VAR_3)
{
struct l2cap_conf_req *VAR_4 = (struct l2cap_conf_req *) VAR_3;
u16 VAR_5, VAR_6;
u8 VAR_7[64];
struct l2cap_chan *VAR_8;
int VAR_9, VAR_10 = 0;
if (VAR_2 < sizeof(*VAR_4))
return -VAR_11;
VAR_5  = __le16_to_cpu(VAR_4->dcid);
VAR_6 = __le16_to_cpu(VAR_4->flags);
BT_DBG(""dcid 0x%4.4x flags 0x%2.2x"", VAR_5, VAR_6);
VAR_8 = l2cap_get_chan_by_scid(VAR_0, VAR_5);
if (!VAR_8) {
cmd_reject_invalid_cid(VAR_0, VAR_1->ident, VAR_5, 0);
return 0;
}
if (VAR_8->state != VAR_12 && VAR_8->state != VAR_13 &&
VAR_8->state != VAR_14) {
cmd_reject_invalid_cid(VAR_0, VAR_1->ident, VAR_8->scid,
VAR_8->dcid);
goto unlock;
}
VAR_9 = VAR_2 - sizeof(*VAR_4);
if (VAR_8->conf_len + VAR_9 > sizeof(VAR_8->conf_req)) {
l2cap_send_cmd(VAR_0, VAR_1->ident, VAR_15,
l2cap_build_conf_rsp(VAR_8, VAR_7,
VAR_16, VAR_6), VAR_7);
goto unlock;
}
memcpy(VAR_8->conf_req + VAR_8->conf_len, VAR_4->data, VAR_9);
VAR_8->conf_len += VAR_9;
if (VAR_6 & VAR_17) {
l2cap_send_cmd(VAR_0, VAR_1->ident, VAR_15,
l2cap_build_conf_rsp(VAR_8, VAR_7,
VAR_18, VAR_6), VAR_7);
goto unlock;
}
VAR_9 = l2cap_parse_conf_req(VAR_8, VAR_7, sizeof(VAR_7));
if (VAR_9 < 0) {
l2cap_send_disconn_req(VAR_8, VAR_19);
goto unlock;
}
VAR_8->ident = VAR_1->ident;
l2cap_send_cmd(VAR_0, VAR_1->ident, VAR_15, VAR_9, VAR_7);
VAR_8->num_conf_rsp++;
VAR_8->conf_len = 0;
if (!test_bit(VAR_20, &VAR_8->conf_state))
goto unlock;
if (test_bit(VAR_21, &VAR_8->conf_state)) {
set_default_fcs(VAR_8);
if (VAR_8->mode == VAR_22 ||
VAR_8->mode == VAR_23)
VAR_10 = l2cap_ertm_init(VAR_8);
if (VAR_10 < 0)
l2cap_send_disconn_req(VAR_8, -VAR_10);
else
l2cap_chan_ready(VAR_8);
goto unlock;
}
if (!test_and_set_bit(VAR_24, &VAR_8->conf_state)) {
u8 VAR_25[64];
l2cap_send_cmd(VAR_0, l2cap_get_ident(VAR_0), VAR_26,
l2cap_build_conf_req(VAR_8, VAR_25, sizeof(VAR_25)), VAR_25);
VAR_8->num_conf_req++;
}
if (test_bit(VAR_27, &VAR_8->conf_state) &&
test_bit(VAR_28, &VAR_8->conf_state)) {
if (!VAR_8->hs_hcon)
l2cap_send_efs_conf_rsp(VAR_8, VAR_7, VAR_1->ident, VAR_6);
else
VAR_8->ident = VAR_1->ident;
}
unlock:
l2cap_chan_unlock(VAR_8);
l2cap_chan_put(VAR_8);
return VAR_10;
}",kernel/git/bluetooth/bluetooth-next/ae4569813a6e931258db627cdfe50dfb4f917d5d/l2cap_core.c/vul/before/0.json,"static inline int l2cap_config_req(struct l2cap_conn *conn,
				   struct l2cap_cmd_hdr *cmd, u16 cmd_len,
				   u8 *data)
{
	struct l2cap_conf_req *req = (struct l2cap_conf_req *) data;
	u16 dcid, flags;
	u8 rsp[64];
	struct l2cap_chan *chan;
	int len, err = 0;

	if (cmd_len < sizeof(*req))
		return -EPROTO;

	dcid  = __le16_to_cpu(req->dcid);
	flags = __le16_to_cpu(req->flags);

	BT_DBG(""dcid 0x%4.4x flags 0x%2.2x"", dcid, flags);

	chan = l2cap_get_chan_by_scid(conn, dcid);
	if (!chan) {
		cmd_reject_invalid_cid(conn, cmd->ident, dcid, 0);
		return 0;
	}

	if (chan->state != BT_CONFIG && chan->state != BT_CONNECT2 &&
	    chan->state != BT_CONNECTED) {
		cmd_reject_invalid_cid(conn, cmd->ident, chan->scid,
				       chan->dcid);
		goto unlock;
	}

	/* Reject if config buffer is too small. */
	len = cmd_len - sizeof(*req);
	if (chan->conf_len + len > sizeof(chan->conf_req)) {
		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
			       l2cap_build_conf_rsp(chan, rsp,
			       L2CAP_CONF_REJECT, flags), rsp);
		goto unlock;
	}

	/* Store config. */
	memcpy(chan->conf_req + chan->conf_len, req->data, len);
	chan->conf_len += len;

	if (flags & L2CAP_CONF_FLAG_CONTINUATION) {
		/* Incomplete config. Send empty response. */
		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
			       l2cap_build_conf_rsp(chan, rsp,
			       L2CAP_CONF_SUCCESS, flags), rsp);
		goto unlock;
	}

	/* Complete config. */
	len = l2cap_parse_conf_req(chan, rsp, sizeof(rsp));
	if (len < 0) {
		l2cap_send_disconn_req(chan, ECONNRESET);
		goto unlock;
	}

	chan->ident = cmd->ident;
	l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);
	if (chan->num_conf_rsp < L2CAP_CONF_MAX_CONF_RSP)
		chan->num_conf_rsp++;

	/* Reset config buffer. */
	chan->conf_len = 0;

	if (!test_bit(CONF_OUTPUT_DONE, &chan->conf_state))
		goto unlock;

	if (test_bit(CONF_INPUT_DONE, &chan->conf_state)) {
		set_default_fcs(chan);

		if (chan->mode == L2CAP_MODE_ERTM ||
		    chan->mode == L2CAP_MODE_STREAMING)
			err = l2cap_ertm_init(chan);

		if (err < 0)
			l2cap_send_disconn_req(chan, -err);
		else
			l2cap_chan_ready(chan);

		goto unlock;
	}

	if (!test_and_set_bit(CONF_REQ_SENT, &chan->conf_state)) {
		u8 buf[64];
		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
			       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);
		chan->num_conf_req++;
	}

	/* Got Conf Rsp PENDING from remote side and assume we sent
	   Conf Rsp PENDING in the code above */
	if (test_bit(CONF_REM_CONF_PEND, &chan->conf_state) &&
	    test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {

		/* check compatibility */

		/* Send rsp for BR/EDR channel */
		if (!chan->hs_hcon)
			l2cap_send_efs_conf_rsp(chan, rsp, cmd->ident, flags);
		else
			chan->ident = cmd->ident;
	}

unlock:
	l2cap_chan_unlock(chan);
	l2cap_chan_put(chan);
	return err;
}","static inline int l2cap_config_req(struct l2cap_conn *VAR_0,
				   struct l2cap_cmd_hdr *VAR_1, u16 VAR_2,
				   u8 *VAR_3)
{
	struct l2cap_conf_req *VAR_4 = (struct l2cap_conf_req *) VAR_3;
	u16 VAR_5, VAR_6;
	u8 VAR_7[64];
	struct l2cap_chan *VAR_8;
	int VAR_9, VAR_10 = 0;

	if (VAR_2 < sizeof(*VAR_4))
		return -VAR_11;

	VAR_5  = __le16_to_cpu(VAR_4->dcid);
	VAR_6 = __le16_to_cpu(VAR_4->flags);

	BT_DBG(""dcid 0x%4.4x flags 0x%2.2x"", VAR_5, VAR_6);

	VAR_8 = l2cap_get_chan_by_scid(VAR_0, VAR_5);
	if (!VAR_8) {
		cmd_reject_invalid_cid(VAR_0, VAR_1->ident, VAR_5, 0);
		return 0;
	}

	if (VAR_8->state != VAR_12 && VAR_8->state != VAR_13 &&
	    VAR_8->state != VAR_14) {
		cmd_reject_invalid_cid(VAR_0, VAR_1->ident, VAR_8->scid,
				       VAR_8->dcid);
		goto unlock;
	}

	/* COMMENT_0 */
	VAR_9 = VAR_2 - sizeof(*VAR_4);
	if (VAR_8->conf_len + VAR_9 > sizeof(VAR_8->conf_req)) {
		l2cap_send_cmd(VAR_0, VAR_1->ident, VAR_15,
			       l2cap_build_conf_rsp(VAR_8, VAR_7,
			       VAR_16, VAR_6), VAR_7);
		goto unlock;
	}

	/* COMMENT_1 */
	memcpy(VAR_8->conf_req + VAR_8->conf_len, VAR_4->data, VAR_9);
	VAR_8->conf_len += VAR_9;

	if (VAR_6 & VAR_17) {
		/* COMMENT_2 */
		l2cap_send_cmd(VAR_0, VAR_1->ident, VAR_15,
			       l2cap_build_conf_rsp(VAR_8, VAR_7,
			       VAR_18, VAR_6), VAR_7);
		goto unlock;
	}

	/* COMMENT_3 */
	VAR_9 = l2cap_parse_conf_req(VAR_8, VAR_7, sizeof(VAR_7));
	if (VAR_9 < 0) {
		l2cap_send_disconn_req(VAR_8, VAR_19);
		goto unlock;
	}

	VAR_8->ident = VAR_1->ident;
	l2cap_send_cmd(VAR_0, VAR_1->ident, VAR_15, VAR_9, VAR_7);
	if (VAR_8->num_conf_rsp < VAR_20)
		VAR_8->num_conf_rsp++;

	/* COMMENT_4 */
	VAR_8->conf_len = 0;

	if (!test_bit(VAR_21, &VAR_8->conf_state))
		goto unlock;

	if (test_bit(VAR_22, &VAR_8->conf_state)) {
		set_default_fcs(VAR_8);

		if (VAR_8->mode == VAR_23 ||
		    VAR_8->mode == VAR_24)
			VAR_10 = l2cap_ertm_init(VAR_8);

		if (VAR_10 < 0)
			l2cap_send_disconn_req(VAR_8, -VAR_10);
		else
			l2cap_chan_ready(VAR_8);

		goto unlock;
	}

	if (!test_and_set_bit(VAR_25, &VAR_8->conf_state)) {
		u8 VAR_26[64];
		l2cap_send_cmd(VAR_0, l2cap_get_ident(VAR_0), VAR_27,
			       l2cap_build_conf_req(VAR_8, VAR_26, sizeof(VAR_26)), VAR_26);
		VAR_8->num_conf_req++;
	}

	/* COMMENT_5 */
                                         
	if (test_bit(VAR_28, &VAR_8->conf_state) &&
	    test_bit(VAR_29, &VAR_8->conf_state)) {

		/* COMMENT_7 */

		/* COMMENT_8 */
		if (!VAR_8->hs_hcon)
			l2cap_send_efs_conf_rsp(VAR_8, VAR_7, VAR_1->ident, VAR_6);
		else
			VAR_8->ident = VAR_1->ident;
	}

unlock:
	l2cap_chan_unlock(VAR_8);
	l2cap_chan_put(VAR_8);
	return VAR_10;
}",kernel/git/bluetooth/bluetooth-next/ae4569813a6e931258db627cdfe50dfb4f917d5d/l2cap_core.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -59,7 +59,8 @@
 
 	chan->ident = cmd->ident;
 	l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);
-	chan->num_conf_rsp++;
+	if (chan->num_conf_rsp < L2CAP_CONF_MAX_CONF_RSP)
+		chan->num_conf_rsp++;
 
 	/* Reset config buffer. */
 	chan->conf_len = 0;","{'deleted_lines': ['\tchan->num_conf_rsp++;'], 'added_lines': ['\tif (chan->num_conf_rsp < L2CAP_CONF_MAX_CONF_RSP)', '\t\tchan->num_conf_rsp++;']}",True,An issue was discovered in the Linux kernel through 6.0.10. l2cap_config_req in net/bluetooth/l2cap_core.c has an integer wraparound via L2CAP_CONF_REQ packets.,7.8,HIGH,2,test,,5
CVE-2023-35828,"['CWE-362', 'CWE-416']",CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"In renesas_usb3_probe, role_work is bound with renesas_usb3_role_work.
renesas_usb3_start will be called to start the work.

If we remove the driver which will call usbhs_remove, there may be
an unfinished work. The possible sequence is as follows:

CPU0                  			CPU1

                    			 renesas_usb3_role_work
renesas_usb3_remove
usb_role_switch_unregister
device_unregister
kfree(sw)
//free usb3->role_sw
                    			 usb_role_switch_set_role
                    			 //use usb3->role_sw

The usb3->role_sw could be freed under such circumstance and then
used in usb_role_switch_set_role.

This bug was found by static analysis. And note that removing a
driver is a root-only operation, and should never happen in normal
case. But the root user may directly remove the device which
will also trigger the remove function.

Fix it by canceling the work before cleanup in the renesas_usb3_remove.

Fixes: 39facfa01c9f (""usb: gadget: udc: renesas_usb3: Add register of usb role switch"")
Signed-off-by: Zheng Wang <zyytlz.wz@163.com>
Reviewed-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Link: https://lore.kernel.org/r/20230320062931.505170-1-zyytlz.wz@163.com
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
",2b947f8769be8b8181dc795fd292d3e7120f5204,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=2b947f8769be8b8181dc795fd292d3e7120f5204,drivers/usb/gadget/udc/renesas_usb3.c,renesas_usb3_remove,"static int renesas_usb3_remove(struct platform_device *pdev)
{
struct renesas_usb3 *usb3 = platform_get_drvdata(pdev);
debugfs_remove_recursive(usb3->dentry);
device_remove_file(&pdev->dev, &dev_attr_role);
usb_role_switch_unregister(usb3->role_sw);
usb_del_gadget_udc(&usb3->gadget);
reset_control_assert(usb3->usbp_rstc);
renesas_usb3_dma_free_prd(usb3, &pdev->dev);
__renesas_usb3_ep_free_request(usb3->ep0_req);
pm_runtime_disable(&pdev->dev);
return 0;
}","static int renesas_usb3_remove(struct platform_device *VAR_0)
{
struct renesas_usb3 *VAR_1 = platform_get_drvdata(VAR_0);
debugfs_remove_recursive(VAR_1->dentry);
device_remove_file(&VAR_0->dev, &VAR_2);
usb_role_switch_unregister(VAR_1->role_sw);
usb_del_gadget_udc(&VAR_1->gadget);
reset_control_assert(VAR_1->usbp_rstc);
renesas_usb3_dma_free_prd(VAR_1, &VAR_0->dev);
__renesas_usb3_ep_free_request(VAR_1->ep0_req);
pm_runtime_disable(&VAR_0->dev);
return 0;
}",torvalds/linux/2b947f8769be8b8181dc795fd292d3e7120f5204/renesas_usb3.c/vul/before/0.json,"static int renesas_usb3_remove(struct platform_device *pdev)
{
	struct renesas_usb3 *usb3 = platform_get_drvdata(pdev);

	debugfs_remove_recursive(usb3->dentry);
	device_remove_file(&pdev->dev, &dev_attr_role);

	cancel_work_sync(&usb3->role_work);
	usb_role_switch_unregister(usb3->role_sw);

	usb_del_gadget_udc(&usb3->gadget);
	reset_control_assert(usb3->usbp_rstc);
	renesas_usb3_dma_free_prd(usb3, &pdev->dev);

	__renesas_usb3_ep_free_request(usb3->ep0_req);
	pm_runtime_disable(&pdev->dev);

	return 0;
}","static int renesas_usb3_remove(struct platform_device *VAR_0)
{
	struct renesas_usb3 *VAR_1 = platform_get_drvdata(VAR_0);

	debugfs_remove_recursive(VAR_1->dentry);
	device_remove_file(&VAR_0->dev, &VAR_2);

	cancel_work_sync(&VAR_1->role_work);
	usb_role_switch_unregister(VAR_1->role_sw);

	usb_del_gadget_udc(&VAR_1->gadget);
	reset_control_assert(VAR_1->usbp_rstc);
	renesas_usb3_dma_free_prd(VAR_1, &VAR_0->dev);

	__renesas_usb3_ep_free_request(VAR_1->ep0_req);
	pm_runtime_disable(&VAR_0->dev);

	return 0;
}",torvalds/linux/2b947f8769be8b8181dc795fd292d3e7120f5204/renesas_usb3.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -5,6 +5,7 @@
 	debugfs_remove_recursive(usb3->dentry);
 	device_remove_file(&pdev->dev, &dev_attr_role);
 
+	cancel_work_sync(&usb3->role_work);
 	usb_role_switch_unregister(usb3->role_sw);
 
 	usb_del_gadget_udc(&usb3->gadget);","{'deleted_lines': [], 'added_lines': ['\tcancel_work_sync(&usb3->role_work);']}",True,An issue was discovered in the Linux kernel before 6.3.2. A use-after-free was found in renesas_usb3_remove in drivers/usb/gadget/udc/renesas_usb3.c.,7.0,HIGH,2,test,,5
CVE-2020-26418,['CWE-401'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"Kafka: Limit our decompression size.

Don't assume that the Internet has our best interests at heart when it
gives us the size of our decompression buffer. Assign an arbitrary limit
of 50 MB.

This fixes #16739 in that it takes care of

** (process:17681): WARNING **: 20:03:07.440: Dissector bug, protocol Kafka, in packet 31: ../epan/proto.c:7043: failed assertion ""end >= fi->start""

which is different from the original error output. It looks like *that*
might have taken care of in one of the other recent Kafka bug fixes.

The decompression routines return a success or failure status. Use
gbooleans instead of ints for that.
",f4374967bbf9c12746b8ec3cd54dddada9dd353e,https://gitlab.com/wireshark/wireshark/-/commit/f4374967bbf9c12746b8ec3cd54dddada9dd353e,epan/dissectors/packet-kafka.c,decompress_none,"static int
decompress_none(tvbuff_t *tvb, packet_info *pinfo _U_, int offset, guint32 length _U_, tvbuff_t **decompressed_tvb, int *decompressed_offset)
{
*decompressed_tvb = tvb;
*decompressed_offset = offset;
return 1;
}","static int
decompress_none(tvbuff_t *VAR_0, packet_info *VAR_1 _U_, int VAR_2, guint32 VAR_3 _U_, tvbuff_t **VAR_4, int *VAR_5)
{
*VAR_4 = VAR_0;
*VAR_5 = VAR_2;
return 1;
}",,"static gboolean
decompress_none(tvbuff_t *tvb, packet_info *pinfo _U_, int offset, guint32 length _U_, tvbuff_t **decompressed_tvb, int *decompressed_offset)
{
    *decompressed_tvb = tvb;
    *decompressed_offset = offset;
    return TRUE;
}","static gboolean
decompress_none(tvbuff_t *VAR_0, packet_info *VAR_1 _U_, int VAR_2, guint32 VAR_3 _U_, tvbuff_t **VAR_4, int *VAR_5)
{
    *VAR_4 = VAR_0;
    *VAR_5 = VAR_2;
    return TRUE;
}",,"--- func_before
+++ func_after
@@ -1,7 +1,7 @@
-static int
+static gboolean
 decompress_none(tvbuff_t *tvb, packet_info *pinfo _U_, int offset, guint32 length _U_, tvbuff_t **decompressed_tvb, int *decompressed_offset)
 {
     *decompressed_tvb = tvb;
     *decompressed_offset = offset;
-    return 1;
+    return TRUE;
 }","{'deleted_lines': ['static int', '    return 1;'], 'added_lines': ['static gboolean', '    return TRUE;']}",True,Memory leak in Kafka protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.,5.3,MEDIUM,1,test,,5
CVE-2020-26418,['CWE-401'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"Kafka: Limit our decompression size.

Don't assume that the Internet has our best interests at heart when it
gives us the size of our decompression buffer. Assign an arbitrary limit
of 50 MB.

This fixes #16739 in that it takes care of

** (process:17681): WARNING **: 20:03:07.440: Dissector bug, protocol Kafka, in packet 31: ../epan/proto.c:7043: failed assertion ""end >= fi->start""

which is different from the original error output. It looks like *that*
might have taken care of in one of the other recent Kafka bug fixes.

The decompression routines return a success or failure status. Use
gbooleans instead of ints for that.
",f4374967bbf9c12746b8ec3cd54dddada9dd353e,https://gitlab.com/wireshark/wireshark/-/commit/f4374967bbf9c12746b8ec3cd54dddada9dd353e,epan/dissectors/packet-kafka.c,decompress_gzip,"static int
decompress_gzip(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)
{
*decompressed_tvb = tvb_child_uncompress(tvb, tvb, offset, length);
*decompressed_offset = 0;
if (*decompressed_tvb) {
return 1;
} else {
col_append_str(pinfo->cinfo, COL_INFO, "" [gzip decompression failed] "");
return 0;
}
}","static int
decompress_gzip(tvbuff_t *VAR_0, packet_info *VAR_1, int VAR_2, guint32 VAR_3, tvbuff_t **VAR_4, int *VAR_5)
{
*VAR_4 = tvb_child_uncompress(VAR_0, VAR_0, VAR_2, VAR_3);
*VAR_5 = 0;
if (*VAR_4) {
return 1;
} else {
col_append_str(VAR_1->cinfo, VAR_6, "" [gzip decompression failed] "");
return 0;
}
}",wireshark/f4374967bbf9c12746b8ec3cd54dddada9dd353e/packet-kafka.c/vul/before/1.json,"static gboolean
decompress_gzip(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)
{
    *decompressed_tvb = tvb_child_uncompress(tvb, tvb, offset, length);
    *decompressed_offset = 0;
    if (*decompressed_tvb) {
        return TRUE;
    } else {
        col_append_str(pinfo->cinfo, COL_INFO, "" [gzip decompression failed] "");
        return FALSE;
    }
}","static gboolean
decompress_gzip(tvbuff_t *VAR_0, packet_info *VAR_1, int VAR_2, guint32 VAR_3, tvbuff_t **VAR_4, int *VAR_5)
{
    *VAR_4 = tvb_child_uncompress(VAR_0, VAR_0, VAR_2, VAR_3);
    *VAR_5 = 0;
    if (*VAR_4) {
        return TRUE;
    } else {
        col_append_str(VAR_1->cinfo, VAR_6, "" [gzip decompression failed] "");
        return FALSE;
    }
}",wireshark/f4374967bbf9c12746b8ec3cd54dddada9dd353e/packet-kafka.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -1,12 +1,12 @@
-static int
+static gboolean
 decompress_gzip(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)
 {
     *decompressed_tvb = tvb_child_uncompress(tvb, tvb, offset, length);
     *decompressed_offset = 0;
     if (*decompressed_tvb) {
-        return 1;
+        return TRUE;
     } else {
         col_append_str(pinfo->cinfo, COL_INFO, "" [gzip decompression failed] "");
-        return 0;
+        return FALSE;
     }
 }","{'deleted_lines': ['static int', '        return 1;', '        return 0;'], 'added_lines': ['static gboolean', '        return TRUE;', '        return FALSE;']}",True,Memory leak in Kafka protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.,5.3,MEDIUM,1,test,,5
CVE-2020-26418,['CWE-401'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"Kafka: Limit our decompression size.

Don't assume that the Internet has our best interests at heart when it
gives us the size of our decompression buffer. Assign an arbitrary limit
of 50 MB.

This fixes #16739 in that it takes care of

** (process:17681): WARNING **: 20:03:07.440: Dissector bug, protocol Kafka, in packet 31: ../epan/proto.c:7043: failed assertion ""end >= fi->start""

which is different from the original error output. It looks like *that*
might have taken care of in one of the other recent Kafka bug fixes.

The decompression routines return a success or failure status. Use
gbooleans instead of ints for that.
",f4374967bbf9c12746b8ec3cd54dddada9dd353e,https://gitlab.com/wireshark/wireshark/-/commit/f4374967bbf9c12746b8ec3cd54dddada9dd353e,epan/dissectors/packet-kafka.c,decompress_lz4,"static int
decompress_lz4(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)
{
LZ4F_decompressionContext_t lz4_ctxt = NULL;
LZ4F_frameInfo_t lz4_info;
LZ4F_errorCode_t rc = 0;
size_t src_offset = 0, src_size = 0, dst_size = 0;
guchar *decompressed_buffer = NULL;
tvbuff_t *composite_tvb = NULL;
int ret = 0;
guint8 *data = (guint8*)tvb_memdup(wmem_packet_scope(), tvb, offset, length);
if (length > 7) {
guint32 hdr_end = 6;
if (data[4] & 0x08) {
hdr_end += 8;
}
if (hdr_end < length) {
data[hdr_end] = (XXH32(&data[4], hdr_end - 4, 0) >> 8) & 0xff;
}
}
rc = LZ4F_createDecompressionContext(&lz4_ctxt, LZ4F_VERSION);
if (LZ4F_isError(rc)) {
goto end;
}
src_offset = length;
rc = LZ4F_getFrameInfo(lz4_ctxt, &lz4_info, data, &src_offset);
if (LZ4F_isError(rc)) {
goto end;
}
switch (lz4_info.blockSizeID) {
case LZ4F_max64KB:
dst_size = 1 << 16;
break;
case LZ4F_max256KB:
dst_size = 1 << 18;
break;
case LZ4F_max1MB:
dst_size = 1 << 20;
break;
case LZ4F_max4MB:
dst_size = 1 << 22;
break;
default:
goto end;
}
if (lz4_info.contentSize && lz4_info.contentSize < dst_size) {
dst_size = (size_t)lz4_info.contentSize;
}
do {
src_size = length - src_offset;         if (src_size == 0) {
goto end;
}
decompressed_buffer = (guchar*)wmem_alloc(pinfo->pool, dst_size);
rc = LZ4F_decompress(lz4_ctxt, decompressed_buffer, &dst_size,
&data[src_offset], &src_size, NULL);
if (LZ4F_isError(rc)) {
goto end;
}
if (dst_size == 0) {
goto end;
}
if (!composite_tvb) {
composite_tvb = tvb_new_composite();
}
tvb_composite_append(composite_tvb,
tvb_new_child_real_data(tvb, (guint8*)decompressed_buffer, (guint)dst_size, (gint)dst_size));
src_offset += src_size;     } while (rc > 0);
ret = 1;
end:
if (composite_tvb) {
tvb_composite_finalize(composite_tvb);
}
LZ4F_freeDecompressionContext(lz4_ctxt);
if (ret == 1) {
*decompressed_tvb = composite_tvb;
*decompressed_offset = 0;
}
else {
col_append_str(pinfo->cinfo, COL_INFO, "" [lz4 decompression failed]"");
}
return ret;
}","static int
decompress_lz4(tvbuff_t *VAR_0, packet_info *VAR_1, int VAR_2, guint32 VAR_3, tvbuff_t **VAR_4, int *VAR_5)
{
LZ4F_decompressionContext_t VAR_6 = NULL;
LZ4F_frameInfo_t VAR_7;
LZ4F_errorCode_t VAR_8 = 0;
size_t VAR_9 = 0, VAR_10 = 0, VAR_11 = 0;
guchar *VAR_12 = NULL;
tvbuff_t *VAR_13 = NULL;
int VAR_14 = 0;
guint8 *VAR_15 = (guint8*)tvb_memdup(wmem_packet_scope(), VAR_0, VAR_2, VAR_3);
if (VAR_3 > 7) {
guint32 VAR_16 = 6;
if (VAR_15[4] & 0x08) {
VAR_16 += 8;
}
if (VAR_16 < VAR_3) {
VAR_15[VAR_16] = (XXH32(&VAR_15[4], VAR_16 - 4, 0) >> 8) & 0xff;
}
}
VAR_8 = LZ4F_createDecompressionContext(&VAR_6, VAR_17);
if (LZ4F_isError(VAR_8)) {
goto end;
}
VAR_9 = VAR_3;
VAR_8 = LZ4F_getFrameInfo(VAR_6, &VAR_7, VAR_15, &VAR_9);
if (LZ4F_isError(VAR_8)) {
goto end;
}
switch (VAR_7.blockSizeID) {
case VAR_18:
VAR_11 = 1 << 16;
break;
case VAR_19:
VAR_11 = 1 << 18;
break;
case VAR_20:
VAR_11 = 1 << 20;
break;
case VAR_21:
VAR_11 = 1 << 22;
break;
default:
goto end;
}
if (VAR_7.contentSize && VAR_7.contentSize < VAR_11) {
VAR_11 = (size_t)VAR_7.contentSize;
}
do {
VAR_10 = VAR_3 - VAR_9; 
if (VAR_10 == 0) {
goto end;
}
VAR_12 = (guchar*)wmem_alloc(VAR_1->pool, VAR_11);
VAR_8 = LZ4F_decompress(VAR_6, VAR_12, &VAR_11,
&VAR_15[VAR_9], &VAR_10, NULL);
if (LZ4F_isError(VAR_8)) {
goto end;
}
if (VAR_11 == 0) {
goto end;
}
if (!VAR_13) {
VAR_13 = tvb_new_composite();
}
tvb_composite_append(VAR_13,
tvb_new_child_real_data(VAR_0, (guint8*)VAR_12, (guint)VAR_11, (gint)VAR_11));
VAR_9 += VAR_10; 
} while (VAR_8 > 0);
VAR_14 = 1;
end:
if (VAR_13) {
tvb_composite_finalize(VAR_13);
}
LZ4F_freeDecompressionContext(VAR_6);
if (VAR_14 == 1) {
*VAR_4 = VAR_13;
*VAR_5 = 0;
}
else {
col_append_str(VAR_1->cinfo, VAR_22, "" [lz4 decompression failed]"");
}
return VAR_14;
}",wireshark/f4374967bbf9c12746b8ec3cd54dddada9dd353e/packet-kafka.c/vul/before/2.json,"static gboolean
decompress_lz4(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)
{
    LZ4F_decompressionContext_t lz4_ctxt = NULL;
    LZ4F_frameInfo_t lz4_info;
    LZ4F_errorCode_t rc = 0;
    size_t src_offset = 0, src_size = 0, dst_size = 0;
    guchar *decompressed_buffer = NULL;
    tvbuff_t *composite_tvb = NULL;

    gboolean ret = FALSE;

    /* Prepare compressed data buffer */
    guint8 *data = (guint8*)tvb_memdup(wmem_packet_scope(), tvb, offset, length);
    /* Override header checksum to workaround buggy Kafka implementations */
    if (length > 7) {
        guint32 hdr_end = 6;
        if (data[4] & 0x08) {
            hdr_end += 8;
        }
        if (hdr_end < length) {
            data[hdr_end] = (XXH32(&data[4], hdr_end - 4, 0) >> 8) & 0xff;
        }
    }

    /* Allocate output buffer */
    rc = LZ4F_createDecompressionContext(&lz4_ctxt, LZ4F_VERSION);
    if (LZ4F_isError(rc)) {
        goto end;
    }

    src_offset = length;
    rc = LZ4F_getFrameInfo(lz4_ctxt, &lz4_info, data, &src_offset);
    if (LZ4F_isError(rc)) {
        goto end;
    }

    switch (lz4_info.blockSizeID) {
        case LZ4F_max64KB:
            dst_size = 1 << 16;
            break;
        case LZ4F_max256KB:
            dst_size = 1 << 18;
            break;
        case LZ4F_max1MB:
            dst_size = 1 << 20;
            break;
        case LZ4F_max4MB:
            dst_size = 1 << 22;
            break;
        default:
            goto end;
    }

    if (lz4_info.contentSize && lz4_info.contentSize < dst_size) {
        dst_size = (size_t)lz4_info.contentSize;
    }

    do {
        src_size = length - src_offset; // set the number of available octets
        if (src_size == 0) {
            goto end;
        }
        decompressed_buffer = (guchar*)wmem_alloc(pinfo->pool, dst_size);
        rc = LZ4F_decompress(lz4_ctxt, decompressed_buffer, &dst_size,
                              &data[src_offset], &src_size, NULL);
        if (LZ4F_isError(rc)) {
            goto end;
        }
        if (dst_size == 0) {
            goto end;
        }
        if (!composite_tvb) {
            composite_tvb = tvb_new_composite();
        }
        tvb_composite_append(composite_tvb,
                             tvb_new_child_real_data(tvb, (guint8*)decompressed_buffer, (guint)dst_size, (gint)dst_size));
        src_offset += src_size; // bump up the offset for the next iteration
    } while (rc > 0);

    ret = TRUE;
end:
    if (composite_tvb) {
        tvb_composite_finalize(composite_tvb);
    }
    LZ4F_freeDecompressionContext(lz4_ctxt);
    if (ret == 1) {
        *decompressed_tvb = composite_tvb;
        *decompressed_offset = 0;
    }
    else {
        col_append_str(pinfo->cinfo, COL_INFO, "" [lz4 decompression failed]"");
    }
    return ret;
}","static gboolean
decompress_lz4(tvbuff_t *VAR_0, packet_info *VAR_1, int VAR_2, guint32 VAR_3, tvbuff_t **VAR_4, int *VAR_5)
{
    LZ4F_decompressionContext_t VAR_6 = NULL;
    LZ4F_frameInfo_t VAR_7;
    LZ4F_errorCode_t VAR_8 = 0;
    size_t VAR_9 = 0, VAR_10 = 0, VAR_11 = 0;
    guchar *VAR_12 = NULL;
    tvbuff_t *VAR_13 = NULL;

    gboolean VAR_14 = FALSE;

    /* COMMENT_0 */
    guint8 *VAR_15 = (guint8*)tvb_memdup(wmem_packet_scope(), VAR_0, VAR_2, VAR_3);
    /* COMMENT_1 */
    if (VAR_3 > 7) {
        guint32 VAR_16 = 6;
        if (VAR_15[4] & 0x08) {
            VAR_16 += 8;
        }
        if (VAR_16 < VAR_3) {
            VAR_15[VAR_16] = (XXH32(&VAR_15[4], VAR_16 - 4, 0) >> 8) & 0xff;
        }
    }

    /* COMMENT_2 */
    VAR_8 = LZ4F_createDecompressionContext(&VAR_6, VAR_17);
    if (LZ4F_isError(VAR_8)) {
        goto end;
    }

    VAR_9 = VAR_3;
    VAR_8 = LZ4F_getFrameInfo(VAR_6, &VAR_7, VAR_15, &VAR_9);
    if (LZ4F_isError(VAR_8)) {
        goto end;
    }

    switch (VAR_7.blockSizeID) {
        case VAR_18:
            VAR_11 = 1 << 16;
            break;
        case VAR_19:
            VAR_11 = 1 << 18;
            break;
        case VAR_20:
            VAR_11 = 1 << 20;
            break;
        case VAR_21:
            VAR_11 = 1 << 22;
            break;
        default:
            goto end;
    }

    if (VAR_7.contentSize && VAR_7.contentSize < VAR_11) {
        VAR_11 = (size_t)VAR_7.contentSize;
    }

    do {
        VAR_10 = VAR_3 - VAR_9; /* COMMENT_3 */
        if (VAR_10 == 0) {
            goto end;
        }
        VAR_12 = (guchar*)wmem_alloc(VAR_1->pool, VAR_11);
        VAR_8 = LZ4F_decompress(VAR_6, VAR_12, &VAR_11,
                              &VAR_15[VAR_9], &VAR_10, NULL);
        if (LZ4F_isError(VAR_8)) {
            goto end;
        }
        if (VAR_11 == 0) {
            goto end;
        }
        if (!VAR_13) {
            VAR_13 = tvb_new_composite();
        }
        tvb_composite_append(VAR_13,
                             tvb_new_child_real_data(VAR_0, (guint8*)VAR_12, (guint)VAR_11, (gint)VAR_11));
        VAR_9 += VAR_10; /* COMMENT_4 */
    } while (VAR_8 > 0);

    VAR_14 = TRUE;
end:
    if (VAR_13) {
        tvb_composite_finalize(VAR_13);
    }
    LZ4F_freeDecompressionContext(VAR_6);
    if (VAR_14 == 1) {
        *VAR_4 = VAR_13;
        *VAR_5 = 0;
    }
    else {
        col_append_str(VAR_1->cinfo, VAR_22, "" [lz4 decompression failed]"");
    }
    return VAR_14;
}",wireshark/f4374967bbf9c12746b8ec3cd54dddada9dd353e/packet-kafka.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,4 +1,4 @@
-static int
+static gboolean
 decompress_lz4(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)
 {
     LZ4F_decompressionContext_t lz4_ctxt = NULL;
@@ -8,7 +8,7 @@
     guchar *decompressed_buffer = NULL;
     tvbuff_t *composite_tvb = NULL;
 
-    int ret = 0;
+    gboolean ret = FALSE;
 
     /* Prepare compressed data buffer */
     guint8 *data = (guint8*)tvb_memdup(wmem_packet_scope(), tvb, offset, length);
@@ -78,7 +78,7 @@
         src_offset += src_size; // bump up the offset for the next iteration
     } while (rc > 0);
 
-    ret = 1;
+    ret = TRUE;
 end:
     if (composite_tvb) {
         tvb_composite_finalize(composite_tvb);","{'deleted_lines': ['static int', '    int ret = 0;', '    ret = 1;'], 'added_lines': ['static gboolean', '    gboolean ret = FALSE;', '    ret = TRUE;']}",True,Memory leak in Kafka protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.,5.3,MEDIUM,1,test,,5
CVE-2020-26418,['CWE-401'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"Kafka: Limit our decompression size.

Don't assume that the Internet has our best interests at heart when it
gives us the size of our decompression buffer. Assign an arbitrary limit
of 50 MB.

This fixes #16739 in that it takes care of

** (process:17681): WARNING **: 20:03:07.440: Dissector bug, protocol Kafka, in packet 31: ../epan/proto.c:7043: failed assertion ""end >= fi->start""

which is different from the original error output. It looks like *that*
might have taken care of in one of the other recent Kafka bug fixes.

The decompression routines return a success or failure status. Use
gbooleans instead of ints for that.
",f4374967bbf9c12746b8ec3cd54dddada9dd353e,https://gitlab.com/wireshark/wireshark/-/commit/f4374967bbf9c12746b8ec3cd54dddada9dd353e,epan/dissectors/packet-kafka.c,decompress_snappy,"static int
decompress_snappy(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)
{
guint8 *data = (guint8*)tvb_memdup(wmem_packet_scope(), tvb, offset, length);
size_t uncompressed_size;
snappy_status rc = SNAPPY_OK;
tvbuff_t *composite_tvb = NULL;
int ret = 0;
if (tvb_memeql(tvb, offset, kafka_xerial_header, sizeof(kafka_xerial_header)) == 0) {
guint32 chunk_size, pos = 16;
while (pos < length) {
if (pos > length-4) {
goto end;
}
chunk_size = tvb_get_ntohl(tvb, offset+pos);
pos += 4;
if (chunk_size > length) {
goto end;
}
if (pos > length-chunk_size) {
goto end;
}
rc = snappy_uncompressed_length(&data[pos], chunk_size, &uncompressed_size);
if (rc != SNAPPY_OK) {
goto end;
}
guint8 *decompressed_buffer = (guint8*)wmem_alloc(pinfo->pool, uncompressed_size);
rc = snappy_uncompress(&data[pos], chunk_size, decompressed_buffer, &uncompressed_size);
if (rc != SNAPPY_OK) {
goto end;
}
if (!composite_tvb) {
composite_tvb = tvb_new_composite();
}
tvb_composite_append(composite_tvb,
tvb_new_child_real_data(tvb, decompressed_buffer, (guint)uncompressed_size, (gint)uncompressed_size));
pos += chunk_size;
}
} else {
rc = snappy_uncompressed_length(data, length, &uncompressed_size);
if (rc != SNAPPY_OK) {
goto end;
}
guint8 *decompressed_buffer = (guint8*)wmem_alloc(pinfo->pool, uncompressed_size);
rc = snappy_uncompress(data, length, decompressed_buffer, &uncompressed_size);
if (rc != SNAPPY_OK) {
goto end;
}
*decompressed_tvb = tvb_new_child_real_data(tvb, decompressed_buffer, (guint)uncompressed_size, (gint)uncompressed_size);
*decompressed_offset = 0;
}
ret = 1;
end:
if (composite_tvb) {
tvb_composite_finalize(composite_tvb);
if (ret == 1) {
*decompressed_tvb = composite_tvb;
*decompressed_offset = 0;
}
}
if (ret == 0) {
col_append_str(pinfo->cinfo, COL_INFO, "" [snappy decompression failed]"");
}
return ret;
}","static int
decompress_snappy(tvbuff_t *VAR_0, packet_info *VAR_1, int VAR_2, guint32 VAR_3, tvbuff_t **VAR_4, int *VAR_5)
{
guint8 *VAR_6 = (guint8*)tvb_memdup(wmem_packet_scope(), VAR_0, VAR_2, VAR_3);
size_t VAR_7;
snappy_status VAR_8 = VAR_9;
tvbuff_t *VAR_10 = NULL;
int VAR_11 = 0;
if (tvb_memeql(VAR_0, VAR_2, VAR_12, sizeof(VAR_12)) == 0) {
guint32 VAR_13, VAR_14 = 16;
while (VAR_14 < VAR_3) {
if (VAR_14 > VAR_3-4) {
goto end;
}
VAR_13 = tvb_get_ntohl(VAR_0, VAR_2+VAR_14);
VAR_14 += 4;
if (VAR_13 > VAR_3) {
goto end;
}
if (VAR_14 > VAR_3-VAR_13) {
goto end;
}
VAR_8 = snappy_uncompressed_length(&VAR_6[VAR_14], VAR_13, &VAR_7);
if (VAR_8 != VAR_9) {
goto end;
}
guint8 *VAR_15 = (guint8*)wmem_alloc(VAR_1->pool, VAR_7);
VAR_8 = snappy_uncompress(&VAR_6[VAR_14], VAR_13, VAR_15, &VAR_7);
if (VAR_8 != VAR_9) {
goto end;
}
if (!VAR_10) {
VAR_10 = tvb_new_composite();
}
tvb_composite_append(VAR_10,
tvb_new_child_real_data(VAR_0, VAR_15, (guint)VAR_7, (gint)VAR_7));
VAR_14 += VAR_13;
}
} else {
VAR_8 = snappy_uncompressed_length(VAR_6, VAR_3, &VAR_7);
if (VAR_8 != VAR_9) {
goto end;
}
guint8 *VAR_15 = (guint8*)wmem_alloc(VAR_1->pool, VAR_7);
VAR_8 = snappy_uncompress(VAR_6, VAR_3, VAR_15, &VAR_7);
if (VAR_8 != VAR_9) {
goto end;
}
*VAR_4 = tvb_new_child_real_data(VAR_0, VAR_15, (guint)VAR_7, (gint)VAR_7);
*VAR_5 = 0;
}
VAR_11 = 1;
end:
if (VAR_10) {
tvb_composite_finalize(VAR_10);
if (VAR_11 == 1) {
*VAR_4 = VAR_10;
*VAR_5 = 0;
}
}
if (VAR_11 == 0) {
col_append_str(VAR_1->cinfo, VAR_16, "" [snappy decompression failed]"");
}
return VAR_11;
}",wireshark/f4374967bbf9c12746b8ec3cd54dddada9dd353e/packet-kafka.c/vul/before/3.json,"static gboolean
decompress_snappy(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)
{
    guint8 *data = (guint8*)tvb_memdup(wmem_packet_scope(), tvb, offset, length);
    size_t uncompressed_size;
    snappy_status rc = SNAPPY_OK;
    tvbuff_t *composite_tvb = NULL;
    gboolean ret = FALSE;

    if (tvb_memeql(tvb, offset, kafka_xerial_header, sizeof(kafka_xerial_header)) == 0) {

        /* xerial framing format */
        guint32 chunk_size, pos = 16;

        while (pos < length) {
            if (pos > length-4) {
                // XXX - this is presumably an error, as the chunk size
                // doesn't fully fit in the data, so an error should be
                // reported.
                goto end;
            }
            chunk_size = tvb_get_ntohl(tvb, offset+pos);
            pos += 4;
            if (chunk_size > length) {
                // XXX - this is presumably an error, as the chunk to be
                // decompressed doesn't fully fit in the data, so an error
                // should be reported.
                goto end;
            }
            if (pos > length-chunk_size) {
                // XXX - this is presumably an error, as the chunk to be
                // decompressed doesn't fully fit in the data, so an error
                // should be reported.
                goto end;
            }
            rc = snappy_uncompressed_length(&data[pos], chunk_size, &uncompressed_size);
            if (rc != SNAPPY_OK) {
                goto end;
            }
            guint8 *decompressed_buffer = (guint8*)wmem_alloc(pinfo->pool, uncompressed_size);
            rc = snappy_uncompress(&data[pos], chunk_size, decompressed_buffer, &uncompressed_size);
            if (rc != SNAPPY_OK) {
                goto end;
            }

            if (!composite_tvb) {
                composite_tvb = tvb_new_composite();
            }
            tvb_composite_append(composite_tvb,
                      tvb_new_child_real_data(tvb, decompressed_buffer, (guint)uncompressed_size, (gint)uncompressed_size));
            pos += chunk_size;
        }

    } else {

        /* unframed format */
        rc = snappy_uncompressed_length(data, length, &uncompressed_size);
        if (rc != SNAPPY_OK) {
            goto end;
        }

        guint8 *decompressed_buffer = (guint8*)wmem_alloc(pinfo->pool, uncompressed_size);

        rc = snappy_uncompress(data, length, decompressed_buffer, &uncompressed_size);
        if (rc != SNAPPY_OK) {
            goto end;
        }

        *decompressed_tvb = tvb_new_child_real_data(tvb, decompressed_buffer, (guint)uncompressed_size, (gint)uncompressed_size);
        *decompressed_offset = 0;

    }
    ret = TRUE;
end:
    if (composite_tvb) {
        tvb_composite_finalize(composite_tvb);
        if (ret == 1) {
            *decompressed_tvb = composite_tvb;
            *decompressed_offset = 0;
        }
    }
    if (ret == FALSE) {
        col_append_str(pinfo->cinfo, COL_INFO, "" [snappy decompression failed]"");
    }
    return ret;
}","static gboolean
decompress_snappy(tvbuff_t *VAR_0, packet_info *VAR_1, int VAR_2, guint32 VAR_3, tvbuff_t **VAR_4, int *VAR_5)
{
    guint8 *VAR_6 = (guint8*)tvb_memdup(wmem_packet_scope(), VAR_0, VAR_2, VAR_3);
    size_t VAR_7;
    snappy_status VAR_8 = VAR_9;
    tvbuff_t *VAR_10 = NULL;
    gboolean VAR_11 = FALSE;

    if (tvb_memeql(VAR_0, VAR_2, VAR_12, sizeof(VAR_12)) == 0) {

        /* COMMENT_0 */
        guint32 VAR_13, VAR_14 = 16;

        while (VAR_14 < VAR_3) {
            if (VAR_14 > VAR_3-4) {
                /* COMMENT_1 */
                /* COMMENT_2 */
                /* COMMENT_3 */
                goto end;
            }
            VAR_13 = tvb_get_ntohl(VAR_0, VAR_2+VAR_14);
            VAR_14 += 4;
            if (VAR_13 > VAR_3) {
                /* COMMENT_4 */
                /* COMMENT_5 */
                /* COMMENT_6 */
                goto end;
            }
            if (VAR_14 > VAR_3-VAR_13) {
                /* COMMENT_4 */
                /* COMMENT_5 */
                /* COMMENT_6 */
                goto end;
            }
            VAR_8 = snappy_uncompressed_length(&VAR_6[VAR_14], VAR_13, &VAR_7);
            if (VAR_8 != VAR_9) {
                goto end;
            }
            guint8 *VAR_15 = (guint8*)wmem_alloc(VAR_1->pool, VAR_7);
            VAR_8 = snappy_uncompress(&VAR_6[VAR_14], VAR_13, VAR_15, &VAR_7);
            if (VAR_8 != VAR_9) {
                goto end;
            }

            if (!VAR_10) {
                VAR_10 = tvb_new_composite();
            }
            tvb_composite_append(VAR_10,
                      tvb_new_child_real_data(VAR_0, VAR_15, (guint)VAR_7, (gint)VAR_7));
            VAR_14 += VAR_13;
        }

    } else {

        /* COMMENT_7 */
        VAR_8 = snappy_uncompressed_length(VAR_6, VAR_3, &VAR_7);
        if (VAR_8 != VAR_9) {
            goto end;
        }

        guint8 *VAR_15 = (guint8*)wmem_alloc(VAR_1->pool, VAR_7);

        VAR_8 = snappy_uncompress(VAR_6, VAR_3, VAR_15, &VAR_7);
        if (VAR_8 != VAR_9) {
            goto end;
        }

        *VAR_4 = tvb_new_child_real_data(VAR_0, VAR_15, (guint)VAR_7, (gint)VAR_7);
        *VAR_5 = 0;

    }
    VAR_11 = TRUE;
end:
    if (VAR_10) {
        tvb_composite_finalize(VAR_10);
        if (VAR_11 == 1) {
            *VAR_4 = VAR_10;
            *VAR_5 = 0;
        }
    }
    if (VAR_11 == FALSE) {
        col_append_str(VAR_1->cinfo, VAR_16, "" [snappy decompression failed]"");
    }
    return VAR_11;
}",wireshark/f4374967bbf9c12746b8ec3cd54dddada9dd353e/packet-kafka.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -1,11 +1,11 @@
-static int
+static gboolean
 decompress_snappy(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)
 {
     guint8 *data = (guint8*)tvb_memdup(wmem_packet_scope(), tvb, offset, length);
     size_t uncompressed_size;
     snappy_status rc = SNAPPY_OK;
     tvbuff_t *composite_tvb = NULL;
-    int ret = 0;
+    gboolean ret = FALSE;
 
     if (tvb_memeql(tvb, offset, kafka_xerial_header, sizeof(kafka_xerial_header)) == 0) {
 
@@ -70,7 +70,7 @@
         *decompressed_offset = 0;
 
     }
-    ret = 1;
+    ret = TRUE;
 end:
     if (composite_tvb) {
         tvb_composite_finalize(composite_tvb);
@@ -79,7 +79,7 @@
             *decompressed_offset = 0;
         }
     }
-    if (ret == 0) {
+    if (ret == FALSE) {
         col_append_str(pinfo->cinfo, COL_INFO, "" [snappy decompression failed]"");
     }
     return ret;","{'deleted_lines': ['static int', '    int ret = 0;', '    ret = 1;', '    if (ret == 0) {'], 'added_lines': ['static gboolean', '    gboolean ret = FALSE;', '    ret = TRUE;', '    if (ret == FALSE) {']}",True,Memory leak in Kafka protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.,5.3,MEDIUM,1,test,,5
CVE-2020-26418,['CWE-401'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"Kafka: Limit our decompression size.

Don't assume that the Internet has our best interests at heart when it
gives us the size of our decompression buffer. Assign an arbitrary limit
of 50 MB.

This fixes #16739 in that it takes care of

** (process:17681): WARNING **: 20:03:07.440: Dissector bug, protocol Kafka, in packet 31: ../epan/proto.c:7043: failed assertion ""end >= fi->start""

which is different from the original error output. It looks like *that*
might have taken care of in one of the other recent Kafka bug fixes.

The decompression routines return a success or failure status. Use
gbooleans instead of ints for that.
",f4374967bbf9c12746b8ec3cd54dddada9dd353e,https://gitlab.com/wireshark/wireshark/-/commit/f4374967bbf9c12746b8ec3cd54dddada9dd353e,epan/dissectors/packet-kafka.c,dissect_kafka_message_old,"static int
dissect_kafka_message_old(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int end_offset _U_)
{
proto_item  *message_ti;
proto_tree  *subtree;
tvbuff_t    *decompressed_tvb;
int         decompressed_offset;
int         start_offset = offset;
int         bytes_offset;
gint8       magic_byte;
guint8      codec;
guint32     message_size;
guint32     length;
message_size = tvb_get_guint32(tvb, start_offset + 8, ENC_BIG_ENDIAN);
subtree = proto_tree_add_subtree(tree, tvb, start_offset, message_size + 12, ett_kafka_message, &message_ti, ""Message"");
offset = dissect_kafka_int64(subtree, hf_kafka_offset, tvb, pinfo, offset, NULL);
offset = dissect_kafka_int32(subtree, hf_kafka_message_size, tvb, pinfo, offset, NULL);
offset = dissect_kafka_int32(subtree, hf_kafka_message_crc, tvb, pinfo, offset, NULL);
offset = dissect_kafka_int8(subtree, hf_kafka_message_magic, tvb, pinfo, offset, &magic_byte);
offset = dissect_kafka_int8(subtree, hf_kafka_message_codec, tvb, pinfo, offset, &codec);
codec &= KAFKA_MESSAGE_CODEC_MASK;
offset = dissect_kafka_int8(subtree, hf_kafka_message_timestamp_type, tvb, pinfo, offset, NULL);
if (magic_byte == 1) {
proto_tree_add_item(subtree, hf_kafka_message_timestamp, tvb, offset, 8, ENC_TIME_MSECS|ENC_BIG_ENDIAN);
offset += 8;
}
bytes_offset = dissect_kafka_regular_bytes(subtree, hf_kafka_message_key, tvb, pinfo, offset, NULL, NULL);
if (bytes_offset > offset) {
offset = bytes_offset;
} else {
expert_add_info(pinfo, message_ti, &ei_kafka_bad_bytes_length);
return offset;
}
if (codec == 0) {
bytes_offset = dissect_kafka_regular_bytes(subtree, hf_kafka_message_value, tvb, pinfo, offset, NULL, &length);
if (bytes_offset > offset) {
offset = bytes_offset;
} else {
expert_add_info(pinfo, message_ti, &ei_kafka_bad_bytes_length);
return offset;
}
} else {
length = tvb_get_ntohl(tvb, offset);
offset += 4;
if (decompress(tvb, pinfo, offset, length, codec, &decompressed_tvb, &decompressed_offset)==1) {
add_new_data_source(pinfo, decompressed_tvb, ""Decompressed content"");
show_compression_reduction(tvb, subtree, length, tvb_captured_length(decompressed_tvb));
dissect_kafka_message_set(decompressed_tvb, pinfo, subtree, decompressed_offset,
tvb_reported_length_remaining(decompressed_tvb, decompressed_offset), codec);
} else {
proto_item_append_text(subtree, "" [Cannot decompress records]"");
}
offset += length;
}
proto_item_set_end(message_ti, tvb, offset);
return offset;
}","static int
dissect_kafka_message_old(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, int VAR_3, int VAR_4 _U_)
{
proto_item  *VAR_5;
proto_tree  *VAR_6;
tvbuff_t    *VAR_7;
int         VAR_8;
int         VAR_9 = VAR_3;
int         VAR_10;
gint8       VAR_11;
guint8      VAR_12;
guint32     VAR_13;
guint32     VAR_14;
VAR_13 = tvb_get_guint32(VAR_0, VAR_9 + 8, VAR_15);
VAR_6 = proto_tree_add_subtree(VAR_2, VAR_0, VAR_9, VAR_13 + 12, VAR_16, &VAR_5, ""Message"");
VAR_3 = dissect_kafka_int64(VAR_6, VAR_17, VAR_0, VAR_1, VAR_3, NULL);
VAR_3 = dissect_kafka_int32(VAR_6, VAR_18, VAR_0, VAR_1, VAR_3, NULL);
VAR_3 = dissect_kafka_int32(VAR_6, VAR_19, VAR_0, VAR_1, VAR_3, NULL);
VAR_3 = dissect_kafka_int8(VAR_6, VAR_20, VAR_0, VAR_1, VAR_3, &VAR_11);
VAR_3 = dissect_kafka_int8(VAR_6, VAR_21, VAR_0, VAR_1, VAR_3, &VAR_12);
VAR_12 &= VAR_22;
VAR_3 = dissect_kafka_int8(VAR_6, VAR_23, VAR_0, VAR_1, VAR_3, NULL);
if (VAR_11 == 1) {
proto_tree_add_item(VAR_6, VAR_24, VAR_0, VAR_3, 8, VAR_25|VAR_15);
VAR_3 += 8;
}
VAR_10 = dissect_kafka_regular_bytes(VAR_6, VAR_26, VAR_0, VAR_1, VAR_3, NULL, NULL);
if (VAR_10 > VAR_3) {
VAR_3 = VAR_10;
} else {
expert_add_info(VAR_1, VAR_5, &VAR_27);
return VAR_3;
}
if (VAR_12 == 0) {
VAR_10 = dissect_kafka_regular_bytes(VAR_6, VAR_28, VAR_0, VAR_1, VAR_3, NULL, &VAR_14);
if (VAR_10 > VAR_3) {
VAR_3 = VAR_10;
} else {
expert_add_info(VAR_1, VAR_5, &VAR_27);
return VAR_3;
}
} else {
VAR_14 = tvb_get_ntohl(VAR_0, VAR_3);
VAR_3 += 4;
if (decompress(VAR_0, VAR_1, VAR_3, VAR_14, VAR_12, &VAR_7, &VAR_8)==1) {
add_new_data_source(VAR_1, VAR_7, ""Decompressed content"");
show_compression_reduction(VAR_0, VAR_6, VAR_14, tvb_captured_length(VAR_7));
dissect_kafka_message_set(VAR_7, VAR_1, VAR_6, VAR_8,
tvb_reported_length_remaining(VAR_7, VAR_8), VAR_12);
} else {
proto_item_append_text(VAR_6, "" [Cannot decompress records]"");
}
VAR_3 += VAR_14;
}
proto_item_set_end(VAR_5, VAR_0, VAR_3);
return VAR_3;
}",,"static int
dissect_kafka_message_old(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int end_offset _U_)
{
    proto_item  *message_ti;
    proto_tree  *subtree;
    tvbuff_t    *decompressed_tvb;
    int         decompressed_offset;
    int         start_offset = offset;
    int         bytes_offset;
    gint8       magic_byte;
    guint8      codec;
    guint32     message_size;
    guint32     length;

    message_size = tvb_get_guint32(tvb, start_offset + 8, ENC_BIG_ENDIAN);

    subtree = proto_tree_add_subtree(tree, tvb, start_offset, message_size + 12, ett_kafka_message, &message_ti, ""Message"");

    offset = dissect_kafka_int64(subtree, hf_kafka_offset, tvb, pinfo, offset, NULL);

    offset = dissect_kafka_int32(subtree, hf_kafka_message_size, tvb, pinfo, offset, NULL);

    offset = dissect_kafka_int32(subtree, hf_kafka_message_crc, tvb, pinfo, offset, NULL);

    offset = dissect_kafka_int8(subtree, hf_kafka_message_magic, tvb, pinfo, offset, &magic_byte);

    offset = dissect_kafka_int8(subtree, hf_kafka_message_codec, tvb, pinfo, offset, &codec);
    codec &= KAFKA_MESSAGE_CODEC_MASK;

    offset = dissect_kafka_int8(subtree, hf_kafka_message_timestamp_type, tvb, pinfo, offset, NULL);

    if (magic_byte == 1) {
        proto_tree_add_item(subtree, hf_kafka_message_timestamp, tvb, offset, 8, ENC_TIME_MSECS|ENC_BIG_ENDIAN);
        offset += 8;
    }

    bytes_offset = dissect_kafka_regular_bytes(subtree, hf_kafka_message_key, tvb, pinfo, offset, NULL, NULL);
    if (bytes_offset > offset) {
        offset = bytes_offset;
    } else {
        expert_add_info(pinfo, message_ti, &ei_kafka_bad_bytes_length);
        return offset;
    }

    /*
     * depending on the compression codec, the payload is the actual message payload (codes=none)
     * or compressed set of messages (otherwise). In the new format (since Kafka 1.0) there
     * is no such duality.
     */
    if (codec == 0) {
        bytes_offset = dissect_kafka_regular_bytes(subtree, hf_kafka_message_value, tvb, pinfo, offset, NULL, &length);
        if (bytes_offset > offset) {
            offset = bytes_offset;
        } else {
            expert_add_info(pinfo, message_ti, &ei_kafka_bad_bytes_length);
            return offset;
        }
    } else {
        length = tvb_get_ntohl(tvb, offset);
        offset += 4;
        if (decompress(tvb, pinfo, offset, length, codec, &decompressed_tvb, &decompressed_offset)==1) {
            add_new_data_source(pinfo, decompressed_tvb, ""Decompressed content"");
            show_compression_reduction(tvb, subtree, length, tvb_captured_length(decompressed_tvb));
            dissect_kafka_message_set(decompressed_tvb, pinfo, subtree, decompressed_offset,
                tvb_reported_length_remaining(decompressed_tvb, decompressed_offset), codec);
            offset += length;
        } else {
            proto_item_append_text(subtree, "" [Cannot decompress records]"");
        }
    }

    proto_item_set_end(message_ti, tvb, offset);

    return offset;
}","static int
dissect_kafka_message_old(tvbuff_t *VAR_0, packet_info *VAR_1, proto_tree *VAR_2, int VAR_3, int VAR_4 _U_)
{
    proto_item  *VAR_5;
    proto_tree  *VAR_6;
    tvbuff_t    *VAR_7;
    int         VAR_8;
    int         VAR_9 = VAR_3;
    int         VAR_10;
    gint8       VAR_11;
    guint8      VAR_12;
    guint32     VAR_13;
    guint32     VAR_14;

    VAR_13 = tvb_get_guint32(VAR_0, VAR_9 + 8, VAR_15);

    VAR_6 = proto_tree_add_subtree(VAR_2, VAR_0, VAR_9, VAR_13 + 12, VAR_16, &VAR_5, ""Message"");

    VAR_3 = dissect_kafka_int64(VAR_6, VAR_17, VAR_0, VAR_1, VAR_3, NULL);

    VAR_3 = dissect_kafka_int32(VAR_6, VAR_18, VAR_0, VAR_1, VAR_3, NULL);

    VAR_3 = dissect_kafka_int32(VAR_6, VAR_19, VAR_0, VAR_1, VAR_3, NULL);

    VAR_3 = dissect_kafka_int8(VAR_6, VAR_20, VAR_0, VAR_1, VAR_3, &VAR_11);

    VAR_3 = dissect_kafka_int8(VAR_6, VAR_21, VAR_0, VAR_1, VAR_3, &VAR_12);
    VAR_12 &= VAR_22;

    VAR_3 = dissect_kafka_int8(VAR_6, VAR_23, VAR_0, VAR_1, VAR_3, NULL);

    if (VAR_11 == 1) {
        proto_tree_add_item(VAR_6, VAR_24, VAR_0, VAR_3, 8, VAR_25|VAR_15);
        VAR_3 += 8;
    }

    VAR_10 = dissect_kafka_regular_bytes(VAR_6, VAR_26, VAR_0, VAR_1, VAR_3, NULL, NULL);
    if (VAR_10 > VAR_3) {
        VAR_3 = VAR_10;
    } else {
        expert_add_info(VAR_1, VAR_5, &VAR_27);
        return VAR_3;
    }

    /* COMMENT_0 */
                                                                                                 
                                                                                           
                          
       
    if (VAR_12 == 0) {
        VAR_10 = dissect_kafka_regular_bytes(VAR_6, VAR_28, VAR_0, VAR_1, VAR_3, NULL, &VAR_14);
        if (VAR_10 > VAR_3) {
            VAR_3 = VAR_10;
        } else {
            expert_add_info(VAR_1, VAR_5, &VAR_27);
            return VAR_3;
        }
    } else {
        VAR_14 = tvb_get_ntohl(VAR_0, VAR_3);
        VAR_3 += 4;
        if (decompress(VAR_0, VAR_1, VAR_3, VAR_14, VAR_12, &VAR_7, &VAR_8)==1) {
            add_new_data_source(VAR_1, VAR_7, ""Decompressed content"");
            show_compression_reduction(VAR_0, VAR_6, VAR_14, tvb_captured_length(VAR_7));
            dissect_kafka_message_set(VAR_7, VAR_1, VAR_6, VAR_8,
                tvb_reported_length_remaining(VAR_7, VAR_8), VAR_12);
            VAR_3 += VAR_14;
        } else {
            proto_item_append_text(VAR_6, "" [Cannot decompress records]"");
        }
    }

    proto_item_set_end(VAR_5, VAR_0, VAR_3);

    return VAR_3;
}",,"--- func_before
+++ func_after
@@ -63,10 +63,10 @@
             show_compression_reduction(tvb, subtree, length, tvb_captured_length(decompressed_tvb));
             dissect_kafka_message_set(decompressed_tvb, pinfo, subtree, decompressed_offset,
                 tvb_reported_length_remaining(decompressed_tvb, decompressed_offset), codec);
+            offset += length;
         } else {
             proto_item_append_text(subtree, "" [Cannot decompress records]"");
         }
-        offset += length;
     }
 
     proto_item_set_end(message_ti, tvb, offset);","{'deleted_lines': ['        offset += length;'], 'added_lines': ['            offset += length;']}",True,Memory leak in Kafka protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.,5.3,MEDIUM,1,test,,5
CVE-2020-26418,['CWE-401'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"Kafka: Limit our decompression size.

Don't assume that the Internet has our best interests at heart when it
gives us the size of our decompression buffer. Assign an arbitrary limit
of 50 MB.

This fixes #16739 in that it takes care of

** (process:17681): WARNING **: 20:03:07.440: Dissector bug, protocol Kafka, in packet 31: ../epan/proto.c:7043: failed assertion ""end >= fi->start""

which is different from the original error output. It looks like *that*
might have taken care of in one of the other recent Kafka bug fixes.

The decompression routines return a success or failure status. Use
gbooleans instead of ints for that.
",f4374967bbf9c12746b8ec3cd54dddada9dd353e,https://gitlab.com/wireshark/wireshark/-/commit/f4374967bbf9c12746b8ec3cd54dddada9dd353e,epan/dissectors/packet-kafka.c,decompress,"static int
decompress(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, int codec, tvbuff_t **decompressed_tvb, int *decompressed_offset)
{
switch (codec) {
case KAFKA_MESSAGE_CODEC_SNAPPY:
return decompress_snappy(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);
case KAFKA_MESSAGE_CODEC_LZ4:
return decompress_lz4(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);
case KAFKA_MESSAGE_CODEC_ZSTD:
return decompress_zstd(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);
case KAFKA_MESSAGE_CODEC_GZIP:
return decompress_gzip(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);
case KAFKA_MESSAGE_CODEC_NONE:
return decompress_none(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);
default:
col_append_str(pinfo->cinfo, COL_INFO, "" [unsupported compression type]"");
return 0;
}
}","static int
decompress(tvbuff_t *VAR_0, packet_info *VAR_1, int VAR_2, guint32 VAR_3, int VAR_4, tvbuff_t **VAR_5, int *VAR_6)
{
switch (VAR_4) {
case VAR_7:
return decompress_snappy(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5, VAR_6);
case VAR_8:
return decompress_lz4(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5, VAR_6);
case VAR_9:
return decompress_zstd(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5, VAR_6);
case VAR_10:
return decompress_gzip(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5, VAR_6);
case VAR_11:
return decompress_none(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5, VAR_6);
default:
col_append_str(VAR_1->cinfo, VAR_12, "" [unsupported compression type]"");
return 0;
}
}",wireshark/f4374967bbf9c12746b8ec3cd54dddada9dd353e/packet-kafka.c/vul/before/5.json,"static gboolean
decompress(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, int codec, tvbuff_t **decompressed_tvb, int *decompressed_offset)
{
    if (length > MAX_DECOMPRESSION_SIZE) {
        expert_add_info(pinfo, NULL, &ei_kafka_bad_decompression_length);
        return FALSE;
    }
    switch (codec) {
        case KAFKA_MESSAGE_CODEC_SNAPPY:
            return decompress_snappy(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);
        case KAFKA_MESSAGE_CODEC_LZ4:
            return decompress_lz4(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);
        case KAFKA_MESSAGE_CODEC_ZSTD:
            return decompress_zstd(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);
        case KAFKA_MESSAGE_CODEC_GZIP:
            return decompress_gzip(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);
        case KAFKA_MESSAGE_CODEC_NONE:
            return decompress_none(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);
        default:
            col_append_str(pinfo->cinfo, COL_INFO, "" [unsupported compression type]"");
            return FALSE;
    }
}","static gboolean
decompress(tvbuff_t *VAR_0, packet_info *VAR_1, int VAR_2, guint32 VAR_3, int VAR_4, tvbuff_t **VAR_5, int *VAR_6)
{
    if (VAR_3 > VAR_7) {
        expert_add_info(VAR_1, NULL, &VAR_8);
        return FALSE;
    }
    switch (VAR_4) {
        case VAR_9:
            return decompress_snappy(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5, VAR_6);
        case VAR_10:
            return decompress_lz4(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5, VAR_6);
        case VAR_11:
            return decompress_zstd(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5, VAR_6);
        case VAR_12:
            return decompress_gzip(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5, VAR_6);
        case VAR_13:
            return decompress_none(VAR_0, VAR_1, VAR_2, VAR_3, VAR_5, VAR_6);
        default:
            col_append_str(VAR_1->cinfo, VAR_14, "" [unsupported compression type]"");
            return FALSE;
    }
}",wireshark/f4374967bbf9c12746b8ec3cd54dddada9dd353e/packet-kafka.c/vul/after/5.json,"--- func_before
+++ func_after
@@ -1,6 +1,10 @@
-static int
+static gboolean
 decompress(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, int codec, tvbuff_t **decompressed_tvb, int *decompressed_offset)
 {
+    if (length > MAX_DECOMPRESSION_SIZE) {
+        expert_add_info(pinfo, NULL, &ei_kafka_bad_decompression_length);
+        return FALSE;
+    }
     switch (codec) {
         case KAFKA_MESSAGE_CODEC_SNAPPY:
             return decompress_snappy(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);
@@ -14,6 +18,6 @@
             return decompress_none(tvb, pinfo, offset, length, decompressed_tvb, decompressed_offset);
         default:
             col_append_str(pinfo->cinfo, COL_INFO, "" [unsupported compression type]"");
-            return 0;
+            return FALSE;
     }
 }","{'deleted_lines': ['static int', '            return 0;'], 'added_lines': ['static gboolean', '    if (length > MAX_DECOMPRESSION_SIZE) {', '        expert_add_info(pinfo, NULL, &ei_kafka_bad_decompression_length);', '        return FALSE;', '    }', '            return FALSE;']}",True,Memory leak in Kafka protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.,5.3,MEDIUM,1,test,,5
CVE-2020-26418,['CWE-401'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"Kafka: Limit our decompression size.

Don't assume that the Internet has our best interests at heart when it
gives us the size of our decompression buffer. Assign an arbitrary limit
of 50 MB.

This fixes #16739 in that it takes care of

** (process:17681): WARNING **: 20:03:07.440: Dissector bug, protocol Kafka, in packet 31: ../epan/proto.c:7043: failed assertion ""end >= fi->start""

which is different from the original error output. It looks like *that*
might have taken care of in one of the other recent Kafka bug fixes.

The decompression routines return a success or failure status. Use
gbooleans instead of ints for that.
",f4374967bbf9c12746b8ec3cd54dddada9dd353e,https://gitlab.com/wireshark/wireshark/-/commit/f4374967bbf9c12746b8ec3cd54dddada9dd353e,epan/dissectors/packet-kafka.c,proto_register_kafka_expert_module,"static void
proto_register_kafka_expert_module(const int proto) {
expert_module_t* expert_kafka;
static ei_register_info ei[] = {
{ &ei_kafka_request_missing,
{ ""kafka.request_missing"", PI_UNDECODED, PI_WARN, ""Request missing"", EXPFILL }},
{ &ei_kafka_unknown_api_key,
{ ""kafka.unknown_api_key"", PI_UNDECODED, PI_WARN, ""Unknown API key"", EXPFILL }},
{ &ei_kafka_unsupported_api_version,
{ ""kafka.unsupported_api_version"", PI_UNDECODED, PI_WARN, ""Unsupported API version"", EXPFILL }},
{ &ei_kafka_bad_string_length,
{ ""kafka.bad_string_length"", PI_MALFORMED, PI_WARN, ""Invalid string length field"", EXPFILL }},
{ &ei_kafka_bad_bytes_length,
{ ""kafka.bad_bytes_length"", PI_MALFORMED, PI_WARN, ""Invalid byte length field"", EXPFILL }},
{ &ei_kafka_bad_array_length,
{ ""kafka.bad_array_length"", PI_MALFORMED, PI_WARN, ""Invalid array length field"", EXPFILL }},
{ &ei_kafka_bad_record_length,
{ ""kafka.bad_record_length"", PI_MALFORMED, PI_WARN, ""Invalid record length field"", EXPFILL }},
{ &ei_kafka_bad_varint,
{ ""kafka.bad_varint"", PI_MALFORMED, PI_WARN, ""Invalid varint bytes"", EXPFILL }},
{ &ei_kafka_bad_message_set_length,
{ ""kafka.ei_kafka_bad_message_set_length"", PI_MALFORMED, PI_WARN, ""Message set size does not match content"", EXPFILL }},
{ &ei_kafka_unknown_message_magic,
{ ""kafka.unknown_message_magic"", PI_MALFORMED, PI_WARN, ""Invalid message magic field"", EXPFILL }},
{ &ei_kafka_pdu_length_mismatch,
{ ""kafka.pdu_length_mismatch"", PI_MALFORMED, PI_WARN, ""Dissected message does not end at the pdu length offset"", EXPFILL }},
};
expert_kafka = expert_register_protocol(proto);
expert_register_field_array(expert_kafka, ei, array_length(ei));
}","static void
proto_register_kafka_expert_module(const int VAR_0) {
expert_module_t* VAR_1;
static ei_register_info VAR_2[] = {
{ &VAR_3,
{ ""kafka.request_missing"", VAR_4, VAR_5, ""Request missing"", VAR_6 }},
{ &VAR_7,
{ ""kafka.unknown_api_key"", VAR_4, VAR_5, ""Unknown API key"", VAR_6 }},
{ &VAR_8,
{ ""kafka.unsupported_api_version"", VAR_4, VAR_5, ""Unsupported API version"", VAR_6 }},
{ &VAR_9,
{ ""kafka.bad_string_length"", VAR_10, VAR_5, ""Invalid string length field"", VAR_6 }},
{ &VAR_11,
{ ""kafka.bad_bytes_length"", VAR_10, VAR_5, ""Invalid byte length field"", VAR_6 }},
{ &VAR_12,
{ ""kafka.bad_array_length"", VAR_10, VAR_5, ""Invalid array length field"", VAR_6 }},
{ &VAR_13,
{ ""kafka.bad_record_length"", VAR_10, VAR_5, ""Invalid record length field"", VAR_6 }},
{ &VAR_14,
{ ""kafka.bad_varint"", VAR_10, VAR_5, ""Invalid varint bytes"", VAR_6 }},
{ &VAR_15,
{ ""kafka.ei_kafka_bad_message_set_length"", VAR_10, VAR_5, ""Message set size does not match content"", VAR_6 }},
{ &VAR_16,
{ ""kafka.unknown_message_magic"", VAR_10, VAR_5, ""Invalid message magic field"", VAR_6 }},
{ &VAR_17,
{ ""kafka.pdu_length_mismatch"", VAR_10, VAR_5, ""Dissected message does not end at the pdu length offset"", VAR_6 }},
};
VAR_1 = expert_register_protocol(VAR_0);
expert_register_field_array(VAR_1, VAR_2, array_length(VAR_2));
}",wireshark/f4374967bbf9c12746b8ec3cd54dddada9dd353e/packet-kafka.c/vul/before/6.json,"static void
proto_register_kafka_expert_module(const int proto) {
    expert_module_t* expert_kafka;
    static ei_register_info ei[] = {
            { &ei_kafka_request_missing,
                    { ""kafka.request_missing"", PI_UNDECODED, PI_WARN, ""Request missing"", EXPFILL }},
            { &ei_kafka_unknown_api_key,
                    { ""kafka.unknown_api_key"", PI_UNDECODED, PI_WARN, ""Unknown API key"", EXPFILL }},
            { &ei_kafka_unsupported_api_version,
                    { ""kafka.unsupported_api_version"", PI_UNDECODED, PI_WARN, ""Unsupported API version"", EXPFILL }},
            { &ei_kafka_bad_string_length,
                    { ""kafka.bad_string_length"", PI_MALFORMED, PI_WARN, ""Invalid string length field"", EXPFILL }},
            { &ei_kafka_bad_bytes_length,
                    { ""kafka.bad_bytes_length"", PI_MALFORMED, PI_WARN, ""Invalid byte length field"", EXPFILL }},
            { &ei_kafka_bad_array_length,
                    { ""kafka.bad_array_length"", PI_MALFORMED, PI_WARN, ""Invalid array length field"", EXPFILL }},
            { &ei_kafka_bad_record_length,
                    { ""kafka.bad_record_length"", PI_MALFORMED, PI_WARN, ""Invalid record length field"", EXPFILL }},
            { &ei_kafka_bad_varint,
                    { ""kafka.bad_varint"", PI_MALFORMED, PI_WARN, ""Invalid varint bytes"", EXPFILL }},
            { &ei_kafka_bad_message_set_length,
                    { ""kafka.ei_kafka_bad_message_set_length"", PI_MALFORMED, PI_WARN, ""Message set size does not match content"", EXPFILL }},
            { &ei_kafka_bad_decompression_length,
                    { ""kafka.ei_kafka_bad_decompression_length"", PI_MALFORMED, PI_WARN, ""Decompression size too large"", EXPFILL }},
            { &ei_kafka_unknown_message_magic,
                    { ""kafka.unknown_message_magic"", PI_MALFORMED, PI_WARN, ""Invalid message magic field"", EXPFILL }},
            { &ei_kafka_pdu_length_mismatch,
                    { ""kafka.pdu_length_mismatch"", PI_MALFORMED, PI_WARN, ""Dissected message does not end at the pdu length offset"", EXPFILL }},
    };
    expert_kafka = expert_register_protocol(proto);
    expert_register_field_array(expert_kafka, ei, array_length(ei));
}","static void
proto_register_kafka_expert_module(const int VAR_0) {
    expert_module_t* VAR_1;
    static ei_register_info VAR_2[] = {
            { &VAR_3,
                    { ""kafka.request_missing"", VAR_4, VAR_5, ""Request missing"", VAR_6 }},
            { &VAR_7,
                    { ""kafka.unknown_api_key"", VAR_4, VAR_5, ""Unknown API key"", VAR_6 }},
            { &VAR_8,
                    { ""kafka.unsupported_api_version"", VAR_4, VAR_5, ""Unsupported API version"", VAR_6 }},
            { &VAR_9,
                    { ""kafka.bad_string_length"", VAR_10, VAR_5, ""Invalid string length field"", VAR_6 }},
            { &VAR_11,
                    { ""kafka.bad_bytes_length"", VAR_10, VAR_5, ""Invalid byte length field"", VAR_6 }},
            { &VAR_12,
                    { ""kafka.bad_array_length"", VAR_10, VAR_5, ""Invalid array length field"", VAR_6 }},
            { &VAR_13,
                    { ""kafka.bad_record_length"", VAR_10, VAR_5, ""Invalid record length field"", VAR_6 }},
            { &VAR_14,
                    { ""kafka.bad_varint"", VAR_10, VAR_5, ""Invalid varint bytes"", VAR_6 }},
            { &VAR_15,
                    { ""kafka.ei_kafka_bad_message_set_length"", VAR_10, VAR_5, ""Message set size does not match content"", VAR_6 }},
            { &VAR_16,
                    { ""kafka.ei_kafka_bad_decompression_length"", VAR_10, VAR_5, ""Decompression size too large"", VAR_6 }},
            { &VAR_17,
                    { ""kafka.unknown_message_magic"", VAR_10, VAR_5, ""Invalid message magic field"", VAR_6 }},
            { &VAR_18,
                    { ""kafka.pdu_length_mismatch"", VAR_10, VAR_5, ""Dissected message does not end at the pdu length offset"", VAR_6 }},
    };
    VAR_1 = expert_register_protocol(VAR_0);
    expert_register_field_array(VAR_1, VAR_2, array_length(VAR_2));
}",wireshark/f4374967bbf9c12746b8ec3cd54dddada9dd353e/packet-kafka.c/vul/after/6.json,"--- func_before
+++ func_after
@@ -20,6 +20,8 @@
                     { ""kafka.bad_varint"", PI_MALFORMED, PI_WARN, ""Invalid varint bytes"", EXPFILL }},
             { &ei_kafka_bad_message_set_length,
                     { ""kafka.ei_kafka_bad_message_set_length"", PI_MALFORMED, PI_WARN, ""Message set size does not match content"", EXPFILL }},
+            { &ei_kafka_bad_decompression_length,
+                    { ""kafka.ei_kafka_bad_decompression_length"", PI_MALFORMED, PI_WARN, ""Decompression size too large"", EXPFILL }},
             { &ei_kafka_unknown_message_magic,
                     { ""kafka.unknown_message_magic"", PI_MALFORMED, PI_WARN, ""Invalid message magic field"", EXPFILL }},
             { &ei_kafka_pdu_length_mismatch,","{'deleted_lines': [], 'added_lines': ['            { &ei_kafka_bad_decompression_length,', '                    { ""kafka.ei_kafka_bad_decompression_length"", PI_MALFORMED, PI_WARN, ""Decompression size too large"", EXPFILL }},']}",True,Memory leak in Kafka protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.,5.3,MEDIUM,1,test,,5
CVE-2020-26418,['CWE-401'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,wireshark,"Kafka: Limit our decompression size.

Don't assume that the Internet has our best interests at heart when it
gives us the size of our decompression buffer. Assign an arbitrary limit
of 50 MB.

This fixes #16739 in that it takes care of

** (process:17681): WARNING **: 20:03:07.440: Dissector bug, protocol Kafka, in packet 31: ../epan/proto.c:7043: failed assertion ""end >= fi->start""

which is different from the original error output. It looks like *that*
might have taken care of in one of the other recent Kafka bug fixes.

The decompression routines return a success or failure status. Use
gbooleans instead of ints for that.
",f4374967bbf9c12746b8ec3cd54dddada9dd353e,https://gitlab.com/wireshark/wireshark/-/commit/f4374967bbf9c12746b8ec3cd54dddada9dd353e,epan/dissectors/packet-kafka.c,decompress_zstd,"static int
decompress_zstd(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)
{
ZSTD_inBuffer input = { tvb_memdup(wmem_packet_scope(), tvb, offset, length), length, 0 };
ZSTD_DStream *zds = ZSTD_createDStream();
size_t rc = 0;
tvbuff_t *composite_tvb = NULL;
int ret = 0;
do {
ZSTD_outBuffer output = { wmem_alloc(pinfo->pool, ZSTD_DStreamOutSize()), ZSTD_DStreamOutSize(), 0 };
rc = ZSTD_decompressStream(zds, &output, &input);
if (ZSTD_isError(rc)) {
goto end;
}
if (!composite_tvb) {
composite_tvb = tvb_new_composite();
}
tvb_composite_append(composite_tvb,
tvb_new_child_real_data(tvb, (guint8*)output.dst, (guint)output.pos, (gint)output.pos));
} while (rc > 0);
ret = 1;
end:
if (composite_tvb) {
tvb_composite_finalize(composite_tvb);
}
ZSTD_freeDStream(zds);
if (ret == 1) {
*decompressed_tvb = composite_tvb;
*decompressed_offset = 0;
}
else {
col_append_str(pinfo->cinfo, COL_INFO, "" [zstd decompression failed]"");
}
return ret;
}","static int
decompress_zstd(tvbuff_t *VAR_0, packet_info *VAR_1, int VAR_2, guint32 VAR_3, tvbuff_t **VAR_4, int *VAR_5)
{
ZSTD_inBuffer VAR_6 = { tvb_memdup(wmem_packet_scope(), VAR_0, VAR_2, VAR_3), VAR_3, 0 };
ZSTD_DStream *VAR_7 = ZSTD_createDStream();
size_t VAR_8 = 0;
tvbuff_t *VAR_9 = NULL;
int VAR_10 = 0;
do {
ZSTD_outBuffer VAR_11 = { wmem_alloc(VAR_1->pool, ZSTD_DStreamOutSize()), ZSTD_DStreamOutSize(), 0 };
VAR_8 = ZSTD_decompressStream(VAR_7, &VAR_11, &VAR_6);
if (ZSTD_isError(VAR_8)) {
goto end;
}
if (!VAR_9) {
VAR_9 = tvb_new_composite();
}
tvb_composite_append(VAR_9,
tvb_new_child_real_data(VAR_0, (guint8*)VAR_11.dst, (guint)VAR_11.pos, (gint)VAR_11.pos));
} while (VAR_8 > 0);
VAR_10 = 1;
end:
if (VAR_9) {
tvb_composite_finalize(VAR_9);
}
ZSTD_freeDStream(VAR_7);
if (VAR_10 == 1) {
*VAR_4 = VAR_9;
*VAR_5 = 0;
}
else {
col_append_str(VAR_1->cinfo, VAR_12, "" [zstd decompression failed]"");
}
return VAR_10;
}",wireshark/f4374967bbf9c12746b8ec3cd54dddada9dd353e/packet-kafka.c/vul/before/7.json,"static gboolean
decompress_zstd(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)
{
    ZSTD_inBuffer input = { tvb_memdup(wmem_packet_scope(), tvb, offset, length), length, 0 };
    ZSTD_DStream *zds = ZSTD_createDStream();
    size_t rc = 0;
    tvbuff_t *composite_tvb = NULL;
    gboolean ret = FALSE;

    do {
        ZSTD_outBuffer output = { wmem_alloc(pinfo->pool, ZSTD_DStreamOutSize()), ZSTD_DStreamOutSize(), 0 };
        rc = ZSTD_decompressStream(zds, &output, &input);
        // rc holds either the number of decompressed offsets or the error code.
        // Both values are positive, one has to use ZSTD_isError to determine if the call succeeded.
        if (ZSTD_isError(rc)) {
            goto end;
        }
        if (!composite_tvb) {
            composite_tvb = tvb_new_composite();
        }
        tvb_composite_append(composite_tvb,
                             tvb_new_child_real_data(tvb, (guint8*)output.dst, (guint)output.pos, (gint)output.pos));
        // rc == 0 means there is nothing more to decompress, but there could be still something in the data
    } while (rc > 0);
    ret = TRUE;
end:
    if (composite_tvb) {
        tvb_composite_finalize(composite_tvb);
    }
    ZSTD_freeDStream(zds);
    if (ret == 1) {
        *decompressed_tvb = composite_tvb;
        *decompressed_offset = 0;
    }
    else {
        col_append_str(pinfo->cinfo, COL_INFO, "" [zstd decompression failed]"");
    }
    return ret;
}","static gboolean
decompress_zstd(tvbuff_t *VAR_0, packet_info *VAR_1, int VAR_2, guint32 VAR_3, tvbuff_t **VAR_4, int *VAR_5)
{
    ZSTD_inBuffer VAR_6 = { tvb_memdup(wmem_packet_scope(), VAR_0, VAR_2, VAR_3), VAR_3, 0 };
    ZSTD_DStream *VAR_7 = ZSTD_createDStream();
    size_t VAR_8 = 0;
    tvbuff_t *VAR_9 = NULL;
    gboolean VAR_10 = FALSE;

    do {
        ZSTD_outBuffer VAR_11 = { wmem_alloc(VAR_1->pool, ZSTD_DStreamOutSize()), ZSTD_DStreamOutSize(), 0 };
        VAR_8 = ZSTD_decompressStream(VAR_7, &VAR_11, &VAR_6);
        /* COMMENT_0 */
        /* COMMENT_1 */
        if (ZSTD_isError(VAR_8)) {
            goto end;
        }
        if (!VAR_9) {
            VAR_9 = tvb_new_composite();
        }
        tvb_composite_append(VAR_9,
                             tvb_new_child_real_data(VAR_0, (guint8*)VAR_11.dst, (guint)VAR_11.pos, (gint)VAR_11.pos));
        /* COMMENT_2 */
    } while (VAR_8 > 0);
    VAR_10 = TRUE;
end:
    if (VAR_9) {
        tvb_composite_finalize(VAR_9);
    }
    ZSTD_freeDStream(VAR_7);
    if (VAR_10 == 1) {
        *VAR_4 = VAR_9;
        *VAR_5 = 0;
    }
    else {
        col_append_str(VAR_1->cinfo, VAR_12, "" [zstd decompression failed]"");
    }
    return VAR_10;
}",wireshark/f4374967bbf9c12746b8ec3cd54dddada9dd353e/packet-kafka.c/vul/after/7.json,"--- func_before
+++ func_after
@@ -1,11 +1,11 @@
-static int
+static gboolean
 decompress_zstd(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)
 {
     ZSTD_inBuffer input = { tvb_memdup(wmem_packet_scope(), tvb, offset, length), length, 0 };
     ZSTD_DStream *zds = ZSTD_createDStream();
     size_t rc = 0;
     tvbuff_t *composite_tvb = NULL;
-    int ret = 0;
+    gboolean ret = FALSE;
 
     do {
         ZSTD_outBuffer output = { wmem_alloc(pinfo->pool, ZSTD_DStreamOutSize()), ZSTD_DStreamOutSize(), 0 };
@@ -22,7 +22,7 @@
                              tvb_new_child_real_data(tvb, (guint8*)output.dst, (guint)output.pos, (gint)output.pos));
         // rc == 0 means there is nothing more to decompress, but there could be still something in the data
     } while (rc > 0);
-    ret = 1;
+    ret = TRUE;
 end:
     if (composite_tvb) {
         tvb_composite_finalize(composite_tvb);","{'deleted_lines': ['static int', '    int ret = 0;', '    ret = 1;'], 'added_lines': ['static gboolean', '    gboolean ret = FALSE;', '    ret = TRUE;']}",True,Memory leak in Kafka protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.,5.3,MEDIUM,1,test,,5
CVE-2021-26931,['CWE-770'],AV:L/AC:M/Au:N/C:N/I:N/A:P,0,torvalds/linux,"In particular -ENOMEM may come back here, from set_foreign_p2m_mapping().
Don't make problems worse, the more that handling elsewhere (together
with map's status fields now indicating whether a mapping wasn't even
attempted, and hence has to be considered failed) doesn't require this
odd way of dealing with errors.

This is part of XSA-362.

Signed-off-by: Jan Beulich <jbeulich@suse.com>
Cc: stable@vger.kernel.org
Reviewed-by: Juergen Gross <jgross@suse.com>
Signed-off-by: Juergen Gross <jgross@suse.com>
",5a264285ed1cd32e26d9de4f3c8c6855e467fd63,https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=5a264285ed1cd32e26d9de4f3c8c6855e467fd63,drivers/block/xen-blkback/blkback.c,xen_blkbk_map,"static int xen_blkbk_map(struct xen_blkif_ring *ring,
struct grant_page *pages[],
int num, bool ro)
{
struct gnttab_map_grant_ref map[BLKIF_MAX_SEGMENTS_PER_REQUEST];
struct page *pages_to_gnt[BLKIF_MAX_SEGMENTS_PER_REQUEST];
struct persistent_gnt *persistent_gnt = NULL;
phys_addr_t addr = 0;
int i, seg_idx, new_map_idx;
int segs_to_map = 0;
int ret = 0;
int last_map = 0, map_until = 0;
int use_persistent_gnts;
struct xen_blkif *blkif = ring->blkif;
use_persistent_gnts = (blkif->vbd.feature_gnt_persistent);
again:
for (i = map_until; i < num; i++) {
uint32_t flags;
if (use_persistent_gnts) {
persistent_gnt = get_persistent_gnt(
ring,
pages[i]->gref);
}
if (persistent_gnt) {
pages[i]->page = persistent_gnt->page;
pages[i]->persistent_gnt = persistent_gnt;
} else {
if (gnttab_page_cache_get(&ring->free_pages,
&pages[i]->page))
goto out_of_memory;
addr = vaddr(pages[i]->page);
pages_to_gnt[segs_to_map] = pages[i]->page;
pages[i]->persistent_gnt = NULL;
flags = GNTMAP_host_map;
if (!use_persistent_gnts && ro)
flags |= GNTMAP_readonly;
gnttab_set_map_op(&map[segs_to_map++], addr,
flags, pages[i]->gref,
blkif->domid);
}
map_until = i + 1;
if (segs_to_map == BLKIF_MAX_SEGMENTS_PER_REQUEST)
break;
}
if (segs_to_map) {
ret = gnttab_map_refs(map, NULL, pages_to_gnt, segs_to_map);
BUG_ON(ret);
}
for (seg_idx = last_map, new_map_idx = 0; seg_idx < map_until; seg_idx++) {
if (!pages[seg_idx]->persistent_gnt) {
BUG_ON(new_map_idx >= segs_to_map);
if (unlikely(map[new_map_idx].status != 0)) {
pr_debug(""invalid buffer -- could not remap it\n"");
gnttab_page_cache_put(&ring->free_pages,
&pages[seg_idx]->page, 1);
pages[seg_idx]->handle = BLKBACK_INVALID_HANDLE;
ret |= 1;
goto next;
}
pages[seg_idx]->handle = map[new_map_idx].handle;
} else {
continue;
}
if (use_persistent_gnts &&
ring->persistent_gnt_c < max_pgrants) {
persistent_gnt = kmalloc(sizeof(struct persistent_gnt),
GFP_KERNEL);
if (!persistent_gnt) {
goto next;
}
persistent_gnt->gnt = map[new_map_idx].ref;
persistent_gnt->handle = map[new_map_idx].handle;
persistent_gnt->page = pages[seg_idx]->page;
if (add_persistent_gnt(ring,
persistent_gnt)) {
kfree(persistent_gnt);
persistent_gnt = NULL;
goto next;
}
pages[seg_idx]->persistent_gnt = persistent_gnt;
pr_debug(""grant %u added to the tree of persistent grants, using %u/%u\n"",
persistent_gnt->gnt, ring->persistent_gnt_c,
max_pgrants);
goto next;
}
if (use_persistent_gnts && !blkif->vbd.overflow_max_grants) {
blkif->vbd.overflow_max_grants = 1;
pr_debug(""domain %u, device %#x is using maximum number of persistent grants\n"",
blkif->domid, blkif->vbd.handle);
}
next:
new_map_idx++;
}
segs_to_map = 0;
last_map = map_until;
if (map_until != num)
goto again;
return ret;
out_of_memory:
pr_alert(""%s: out of memory\n"", __func__);
gnttab_page_cache_put(&ring->free_pages, pages_to_gnt, segs_to_map);
for (i = last_map; i < num; i++)
pages[i]->handle = BLKBACK_INVALID_HANDLE;
return -ENOMEM;
}","static int xen_blkbk_map(struct xen_blkif_ring *VAR_0,
struct grant_page *VAR_1[],
int VAR_2, bool VAR_3)
{
struct gnttab_map_grant_ref VAR_4[VAR_5];
struct page *VAR_6[VAR_5];
struct persistent_gnt *persistent_gnt = NULL;
phys_addr_t VAR_7 = 0;
int VAR_8, VAR_9, VAR_10;
int VAR_11 = 0;
int VAR_12 = 0;
int VAR_13 = 0, VAR_14 = 0;
int VAR_15;
struct xen_blkif *VAR_16 = VAR_0->blkif;
VAR_15 = (VAR_16->vbd.feature_gnt_persistent);
again:
for (VAR_8 = VAR_14; VAR_8 < VAR_2; VAR_8++) {
uint32_t VAR_17;
if (VAR_15) {
persistent_gnt = get_persistent_gnt(
VAR_0,
VAR_1[VAR_8]->gref);
}
if (persistent_gnt) {
VAR_1[VAR_8]->page = persistent_gnt->page;
VAR_1[VAR_8]->persistent_gnt = persistent_gnt;
} else {
if (gnttab_page_cache_get(&VAR_0->free_pages,
&VAR_1[VAR_8]->page))
goto out_of_memory;
VAR_7 = vaddr(VAR_1[VAR_8]->page);
VAR_6[VAR_11] = VAR_1[VAR_8]->page;
VAR_1[VAR_8]->persistent_gnt = NULL;
VAR_17 = VAR_18;
if (!VAR_15 && VAR_3)
VAR_17 |= VAR_19;
gnttab_set_map_op(&VAR_4[VAR_11++], VAR_7,
VAR_17, VAR_1[VAR_8]->gref,
VAR_16->domid);
}
VAR_14 = VAR_8 + 1;
if (VAR_11 == VAR_5)
break;
}
if (VAR_11) {
VAR_12 = gnttab_map_refs(VAR_4, NULL, VAR_6, VAR_11);
BUG_ON(VAR_12);
}
for (VAR_9 = VAR_13, VAR_10 = 0; VAR_9 < VAR_14; VAR_9++) {
if (!VAR_1[VAR_9]->persistent_gnt) {
BUG_ON(VAR_10 >= VAR_11);
if (unlikely(VAR_4[VAR_10].status != 0)) {
pr_debug(""invalid buffer -- could not remap it\n"");
gnttab_page_cache_put(&VAR_0->free_pages,
&VAR_1[VAR_9]->page, 1);
VAR_1[VAR_9]->handle = VAR_20;
VAR_12 |= 1;
goto next;
}
VAR_1[VAR_9]->handle = VAR_4[VAR_10].handle;
} else {
continue;
}
if (VAR_15 &&
VAR_0->persistent_gnt_c < VAR_21) {
persistent_gnt = kmalloc(sizeof(struct persistent_gnt),
VAR_22);
if (!persistent_gnt) {
goto next;
}
persistent_gnt->gnt = VAR_4[VAR_10].ref;
persistent_gnt->handle = VAR_4[VAR_10].handle;
persistent_gnt->page = VAR_1[VAR_9]->page;
if (add_persistent_gnt(VAR_0,
persistent_gnt)) {
kfree(persistent_gnt);
persistent_gnt = NULL;
goto next;
}
VAR_1[VAR_9]->persistent_gnt = persistent_gnt;
pr_debug(""grant %u added to the tree of persistent grants, using %u/%u\n"",
persistent_gnt->gnt, VAR_0->persistent_gnt_c,
VAR_21);
goto next;
}
if (VAR_15 && !VAR_16->vbd.overflow_max_grants) {
VAR_16->vbd.overflow_max_grants = 1;
pr_debug(""domain %u, device %#x is using maximum number of persistent grants\n"",
VAR_16->domid, VAR_16->vbd.handle);
}
next:
VAR_10++;
}
VAR_11 = 0;
VAR_13 = VAR_14;
if (VAR_14 != VAR_2)
goto again;
return VAR_12;
out_of_memory:
pr_alert(""%s: out of memory\n"", VAR_23);
gnttab_page_cache_put(&VAR_0->free_pages, VAR_6, VAR_11);
for (VAR_8 = VAR_13; VAR_8 < VAR_2; VAR_8++)
VAR_1[VAR_8]->handle = VAR_20;
return -VAR_24;
}",torvalds/linux/5a264285ed1cd32e26d9de4f3c8c6855e467fd63/blkback.c/vul/before/0.json,"static int xen_blkbk_map(struct xen_blkif_ring *ring,
			 struct grant_page *pages[],
			 int num, bool ro)
{
	struct gnttab_map_grant_ref map[BLKIF_MAX_SEGMENTS_PER_REQUEST];
	struct page *pages_to_gnt[BLKIF_MAX_SEGMENTS_PER_REQUEST];
	struct persistent_gnt *persistent_gnt = NULL;
	phys_addr_t addr = 0;
	int i, seg_idx, new_map_idx;
	int segs_to_map = 0;
	int ret = 0;
	int last_map = 0, map_until = 0;
	int use_persistent_gnts;
	struct xen_blkif *blkif = ring->blkif;

	use_persistent_gnts = (blkif->vbd.feature_gnt_persistent);

	/*
	 * Fill out preq.nr_sects with proper amount of sectors, and setup
	 * assign map[..] with the PFN of the page in our domain with the
	 * corresponding grant reference for each page.
	 */
again:
	for (i = map_until; i < num; i++) {
		uint32_t flags;

		if (use_persistent_gnts) {
			persistent_gnt = get_persistent_gnt(
				ring,
				pages[i]->gref);
		}

		if (persistent_gnt) {
			/*
			 * We are using persistent grants and
			 * the grant is already mapped
			 */
			pages[i]->page = persistent_gnt->page;
			pages[i]->persistent_gnt = persistent_gnt;
		} else {
			if (gnttab_page_cache_get(&ring->free_pages,
						  &pages[i]->page))
				goto out_of_memory;
			addr = vaddr(pages[i]->page);
			pages_to_gnt[segs_to_map] = pages[i]->page;
			pages[i]->persistent_gnt = NULL;
			flags = GNTMAP_host_map;
			if (!use_persistent_gnts && ro)
				flags |= GNTMAP_readonly;
			gnttab_set_map_op(&map[segs_to_map++], addr,
					  flags, pages[i]->gref,
					  blkif->domid);
		}
		map_until = i + 1;
		if (segs_to_map == BLKIF_MAX_SEGMENTS_PER_REQUEST)
			break;
	}

	if (segs_to_map)
		ret = gnttab_map_refs(map, NULL, pages_to_gnt, segs_to_map);

	/*
	 * Now swizzle the MFN in our domain with the MFN from the other domain
	 * so that when we access vaddr(pending_req,i) it has the contents of
	 * the page from the other domain.
	 */
	for (seg_idx = last_map, new_map_idx = 0; seg_idx < map_until; seg_idx++) {
		if (!pages[seg_idx]->persistent_gnt) {
			/* This is a newly mapped grant */
			BUG_ON(new_map_idx >= segs_to_map);
			if (unlikely(map[new_map_idx].status != 0)) {
				pr_debug(""invalid buffer -- could not remap it\n"");
				gnttab_page_cache_put(&ring->free_pages,
						      &pages[seg_idx]->page, 1);
				pages[seg_idx]->handle = BLKBACK_INVALID_HANDLE;
				ret |= !ret;
				goto next;
			}
			pages[seg_idx]->handle = map[new_map_idx].handle;
		} else {
			continue;
		}
		if (use_persistent_gnts &&
		    ring->persistent_gnt_c < max_pgrants) {
			/*
			 * We are using persistent grants, the grant is
			 * not mapped but we might have room for it.
			 */
			persistent_gnt = kmalloc(sizeof(struct persistent_gnt),
				                 GFP_KERNEL);
			if (!persistent_gnt) {
				/*
				 * If we don't have enough memory to
				 * allocate the persistent_gnt struct
				 * map this grant non-persistenly
				 */
				goto next;
			}
			persistent_gnt->gnt = map[new_map_idx].ref;
			persistent_gnt->handle = map[new_map_idx].handle;
			persistent_gnt->page = pages[seg_idx]->page;
			if (add_persistent_gnt(ring,
			                       persistent_gnt)) {
				kfree(persistent_gnt);
				persistent_gnt = NULL;
				goto next;
			}
			pages[seg_idx]->persistent_gnt = persistent_gnt;
			pr_debug(""grant %u added to the tree of persistent grants, using %u/%u\n"",
				 persistent_gnt->gnt, ring->persistent_gnt_c,
				 max_pgrants);
			goto next;
		}
		if (use_persistent_gnts && !blkif->vbd.overflow_max_grants) {
			blkif->vbd.overflow_max_grants = 1;
			pr_debug(""domain %u, device %#x is using maximum number of persistent grants\n"",
			         blkif->domid, blkif->vbd.handle);
		}
		/*
		 * We could not map this grant persistently, so use it as
		 * a non-persistent grant.
		 */
next:
		new_map_idx++;
	}
	segs_to_map = 0;
	last_map = map_until;
	if (map_until != num)
		goto again;

	return ret;

out_of_memory:
	pr_alert(""%s: out of memory\n"", __func__);
	gnttab_page_cache_put(&ring->free_pages, pages_to_gnt, segs_to_map);
	for (i = last_map; i < num; i++)
		pages[i]->handle = BLKBACK_INVALID_HANDLE;
	return -ENOMEM;
}","static int xen_blkbk_map(struct xen_blkif_ring *VAR_0,
			 struct grant_page *VAR_1[],
			 int VAR_2, bool VAR_3)
{
	struct gnttab_map_grant_ref VAR_4[VAR_5];
	struct page *VAR_6[VAR_5];
	struct persistent_gnt *persistent_gnt = NULL;
	phys_addr_t VAR_7 = 0;
	int VAR_8, VAR_9, VAR_10;
	int VAR_11 = 0;
	int VAR_12 = 0;
	int VAR_13 = 0, VAR_14 = 0;
	int VAR_15;
	struct xen_blkif *VAR_16 = VAR_0->blkif;

	VAR_15 = (VAR_16->vbd.feature_gnt_persistent);

	/* COMMENT_0 */
                                                                   
                                                                  
                                                
    
again:
	for (VAR_8 = VAR_14; VAR_8 < VAR_2; VAR_8++) {
		uint32_t VAR_17;

		if (VAR_15) {
			persistent_gnt = get_persistent_gnt(
				VAR_0,
				VAR_1[VAR_8]->gref);
		}

		if (persistent_gnt) {
			/* COMMENT_5 */
                                        
                                 
      
			VAR_1[VAR_8]->page = persistent_gnt->page;
			VAR_1[VAR_8]->persistent_gnt = persistent_gnt;
		} else {
			if (gnttab_page_cache_get(&VAR_0->free_pages,
						  &VAR_1[VAR_8]->page))
				goto out_of_memory;
			VAR_7 = vaddr(VAR_1[VAR_8]->page);
			VAR_6[VAR_11] = VAR_1[VAR_8]->page;
			VAR_1[VAR_8]->persistent_gnt = NULL;
			VAR_17 = VAR_18;
			if (!VAR_15 && VAR_3)
				VAR_17 |= VAR_19;
			gnttab_set_map_op(&VAR_4[VAR_11++], VAR_7,
					  VAR_17, VAR_1[VAR_8]->gref,
					  VAR_16->domid);
		}
		VAR_14 = VAR_8 + 1;
		if (VAR_11 == VAR_5)
			break;
	}

	if (VAR_11)
		VAR_12 = gnttab_map_refs(VAR_4, NULL, VAR_6, VAR_11);

	/* COMMENT_9 */
                                                                        
                                                                      
                                   
    
	for (VAR_9 = VAR_13, VAR_10 = 0; VAR_9 < VAR_14; VAR_9++) {
		if (!VAR_1[VAR_9]->persistent_gnt) {
			/* COMMENT_14 */
			BUG_ON(VAR_10 >= VAR_11);
			if (unlikely(VAR_4[VAR_10].status != 0)) {
				pr_debug(""invalid buffer -- could not remap it\n"");
				gnttab_page_cache_put(&VAR_0->free_pages,
						      &VAR_1[VAR_9]->page, 1);
				VAR_1[VAR_9]->handle = VAR_20;
				VAR_12 |= !VAR_12;
				goto next;
			}
			VAR_1[VAR_9]->handle = VAR_4[VAR_10].handle;
		} else {
			continue;
		}
		if (VAR_15 &&
		    VAR_0->persistent_gnt_c < VAR_21) {
			/* COMMENT_15 */
                                                  
                                               
      
			persistent_gnt = kmalloc(sizeof(struct persistent_gnt),
				                 VAR_22);
			if (!persistent_gnt) {
				/* COMMENT_19 */
                                        
                                         
                                     
       
				goto next;
			}
			persistent_gnt->gnt = VAR_4[VAR_10].ref;
			persistent_gnt->handle = VAR_4[VAR_10].handle;
			persistent_gnt->page = VAR_1[VAR_9]->page;
			if (add_persistent_gnt(VAR_0,
			                       persistent_gnt)) {
				kfree(persistent_gnt);
				persistent_gnt = NULL;
				goto next;
			}
			VAR_1[VAR_9]->persistent_gnt = persistent_gnt;
			pr_debug(""grant %u added to the tree of persistent grants, using %u/%u\n"",
				 persistent_gnt->gnt, VAR_0->persistent_gnt_c,
				 VAR_21);
			goto next;
		}
		if (VAR_15 && !VAR_16->vbd.overflow_max_grants) {
			VAR_16->vbd.overflow_max_grants = 1;
			pr_debug(""domain %u, device %#x is using maximum number of persistent grants\n"",
			         VAR_16->domid, VAR_16->vbd.handle);
		}
		/* COMMENT_24 */
                                                           
                            
     
next:
		VAR_10++;
	}
	VAR_11 = 0;
	VAR_13 = VAR_14;
	if (VAR_14 != VAR_2)
		goto again;

	return VAR_12;

out_of_memory:
	pr_alert(""%s: out of memory\n"", VAR_23);
	gnttab_page_cache_put(&VAR_0->free_pages, VAR_6, VAR_11);
	for (VAR_8 = VAR_13; VAR_8 < VAR_2; VAR_8++)
		VAR_1[VAR_8]->handle = VAR_20;
	return -VAR_24;
}",torvalds/linux/5a264285ed1cd32e26d9de4f3c8c6855e467fd63/blkback.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -56,10 +56,8 @@
 			break;
 	}
 
-	if (segs_to_map) {
+	if (segs_to_map)
 		ret = gnttab_map_refs(map, NULL, pages_to_gnt, segs_to_map);
-		BUG_ON(ret);
-	}
 
 	/*
 	 * Now swizzle the MFN in our domain with the MFN from the other domain
@@ -75,7 +73,7 @@
 				gnttab_page_cache_put(&ring->free_pages,
 						      &pages[seg_idx]->page, 1);
 				pages[seg_idx]->handle = BLKBACK_INVALID_HANDLE;
-				ret |= 1;
+				ret |= !ret;
 				goto next;
 			}
 			pages[seg_idx]->handle = map[new_map_idx].handle;","{'deleted_lines': ['\tif (segs_to_map) {', '\t\tBUG_ON(ret);', '\t}', '\t\t\t\tret |= 1;'], 'added_lines': ['\tif (segs_to_map)', '\t\t\t\tret |= !ret;']}",True,"An issue was discovered in the Linux kernel 2.6.39 through 5.10.16, as used in Xen. Block, net, and SCSI backends consider certain errors a plain bug, deliberately causing a kernel crash. For errors potentially being at least under the influence of guests (such as out of memory conditions), it isn't correct to assume a plain bug. Memory allocations potentially causing such crashes occur only when Linux is running in PV mode, though. This affects drivers/block/xen-blkback/blkback.c and drivers/xen/xen-scsiback.c.",5.5,MEDIUM,1,test,,5
CVE-2022-3105,['CWE-476'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"Because of the possible failure of the allocation, data might be NULL
pointer and will cause the dereference of the NULL pointer later.
Therefore, it might be better to check it and return -ENOMEM.

Fixes: 6884c6c4bd09 (""RDMA/verbs: Store the write/write_ex uapi entry points in the uverbs_api"")
Link: https://lore.kernel.org/r/20211231093315.1917667-1-jiasheng@iscas.ac.cn
Signed-off-by: Jiasheng Jiang <jiasheng@iscas.ac.cn>
Reviewed-by: Leon Romanovsky <leonro@nvidia.com>
Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
",7694a7de22c53a312ea98960fcafc6ec62046531,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=v5.19-rc2&h=7694a7de22c53a312ea98960fcafc6ec62046531,drivers/infiniband/core/uverbs_uapi.c,uapi_finalize,"static int uapi_finalize(struct uverbs_api *uapi)
{
const struct uverbs_api_write_method **data;
unsigned long max_write_ex = 0;
unsigned long max_write = 0;
struct radix_tree_iter iter;
void __rcu **slot;
int rc;
int i;
radix_tree_for_each_slot (slot, &uapi->radix, &iter, 0) {
struct uverbs_api_ioctl_method *method_elm =
rcu_dereference_protected(*slot, true);
if (uapi_key_is_ioctl_method(iter.index)) {
rc = uapi_finalize_ioctl_method(uapi, method_elm,
iter.index);
if (rc)
return rc;
}
if (uapi_key_is_write_method(iter.index))
max_write = max(max_write,
iter.index & UVERBS_API_ATTR_KEY_MASK);
if (uapi_key_is_write_ex_method(iter.index))
max_write_ex =
max(max_write_ex,
iter.index & UVERBS_API_ATTR_KEY_MASK);
}
uapi->notsupp_method.handler = ib_uverbs_notsupp;
uapi->num_write = max_write + 1;
uapi->num_write_ex = max_write_ex + 1;
data = kmalloc_array(uapi->num_write + uapi->num_write_ex,
sizeof(*uapi->write_methods), GFP_KERNEL);
for (i = 0; i != uapi->num_write + uapi->num_write_ex; i++)
data[i] = &uapi->notsupp_method;
uapi->write_methods = data;
uapi->write_ex_methods = data + uapi->num_write;
radix_tree_for_each_slot (slot, &uapi->radix, &iter, 0) {
if (uapi_key_is_write_method(iter.index))
uapi->write_methods[iter.index &
UVERBS_API_ATTR_KEY_MASK] =
rcu_dereference_protected(*slot, true);
if (uapi_key_is_write_ex_method(iter.index))
uapi->write_ex_methods[iter.index &
UVERBS_API_ATTR_KEY_MASK] =
rcu_dereference_protected(*slot, true);
}
return 0;
}","static int uapi_finalize(struct uverbs_api *VAR_0)
{
const struct uverbs_api_write_method **VAR_1;
unsigned long VAR_2 = 0;
unsigned long VAR_3 = 0;
struct radix_tree_iter VAR_4;
void VAR_5 **VAR_6;
int VAR_7;
int VAR_8;
radix_tree_for_each_slot (VAR_6, &VAR_0->radix, &VAR_4, 0) {
struct uverbs_api_ioctl_method *VAR_9 =
rcu_dereference_protected(*VAR_6, true);
if (uapi_key_is_ioctl_method(VAR_4.index)) {
VAR_7 = uapi_finalize_ioctl_method(VAR_0, VAR_9,
VAR_4.index);
if (VAR_7)
return VAR_7;
}
if (uapi_key_is_write_method(VAR_4.index))
VAR_3 = max(VAR_3,
VAR_4.index & VAR_10);
if (uapi_key_is_write_ex_method(VAR_4.index))
VAR_2 =
max(VAR_2,
VAR_4.index & VAR_10);
}
VAR_0->notsupp_method.handler = VAR_11;
VAR_0->num_write = VAR_3 + 1;
VAR_0->num_write_ex = VAR_2 + 1;
VAR_1 = kmalloc_array(VAR_0->num_write + VAR_0->num_write_ex,
sizeof(*VAR_0->write_methods), VAR_12);
for (VAR_8 = 0; VAR_8 != VAR_0->num_write + VAR_0->num_write_ex; VAR_8++)
VAR_1[VAR_8] = &VAR_0->notsupp_method;
VAR_0->write_methods = VAR_1;
VAR_0->write_ex_methods = VAR_1 + VAR_0->num_write;
radix_tree_for_each_slot (VAR_6, &VAR_0->radix, &VAR_4, 0) {
if (uapi_key_is_write_method(VAR_4.index))
VAR_0->write_methods[VAR_4.index &
VAR_10] =
rcu_dereference_protected(*VAR_6, true);
if (uapi_key_is_write_ex_method(VAR_4.index))
VAR_0->write_ex_methods[VAR_4.index &
VAR_10] =
rcu_dereference_protected(*VAR_6, true);
}
return 0;
}",torvalds/linux/7694a7de22c53a312ea98960fcafc6ec62046531/uverbs_uapi.c/vul/before/0.json,"static int uapi_finalize(struct uverbs_api *uapi)
{
	const struct uverbs_api_write_method **data;
	unsigned long max_write_ex = 0;
	unsigned long max_write = 0;
	struct radix_tree_iter iter;
	void __rcu **slot;
	int rc;
	int i;

	radix_tree_for_each_slot (slot, &uapi->radix, &iter, 0) {
		struct uverbs_api_ioctl_method *method_elm =
			rcu_dereference_protected(*slot, true);

		if (uapi_key_is_ioctl_method(iter.index)) {
			rc = uapi_finalize_ioctl_method(uapi, method_elm,
							iter.index);
			if (rc)
				return rc;
		}

		if (uapi_key_is_write_method(iter.index))
			max_write = max(max_write,
					iter.index & UVERBS_API_ATTR_KEY_MASK);
		if (uapi_key_is_write_ex_method(iter.index))
			max_write_ex =
				max(max_write_ex,
				    iter.index & UVERBS_API_ATTR_KEY_MASK);
	}

	uapi->notsupp_method.handler = ib_uverbs_notsupp;
	uapi->num_write = max_write + 1;
	uapi->num_write_ex = max_write_ex + 1;
	data = kmalloc_array(uapi->num_write + uapi->num_write_ex,
			     sizeof(*uapi->write_methods), GFP_KERNEL);
	if (!data)
		return -ENOMEM;

	for (i = 0; i != uapi->num_write + uapi->num_write_ex; i++)
		data[i] = &uapi->notsupp_method;
	uapi->write_methods = data;
	uapi->write_ex_methods = data + uapi->num_write;

	radix_tree_for_each_slot (slot, &uapi->radix, &iter, 0) {
		if (uapi_key_is_write_method(iter.index))
			uapi->write_methods[iter.index &
					    UVERBS_API_ATTR_KEY_MASK] =
				rcu_dereference_protected(*slot, true);
		if (uapi_key_is_write_ex_method(iter.index))
			uapi->write_ex_methods[iter.index &
					       UVERBS_API_ATTR_KEY_MASK] =
				rcu_dereference_protected(*slot, true);
	}

	return 0;
}","static int uapi_finalize(struct uverbs_api *VAR_0)
{
	const struct uverbs_api_write_method **VAR_1;
	unsigned long VAR_2 = 0;
	unsigned long VAR_3 = 0;
	struct radix_tree_iter VAR_4;
	void VAR_5 **VAR_6;
	int VAR_7;
	int VAR_8;

	radix_tree_for_each_slot (VAR_6, &VAR_0->radix, &VAR_4, 0) {
		struct uverbs_api_ioctl_method *VAR_9 =
			rcu_dereference_protected(*VAR_6, true);

		if (uapi_key_is_ioctl_method(VAR_4.index)) {
			VAR_7 = uapi_finalize_ioctl_method(VAR_0, VAR_9,
							VAR_4.index);
			if (VAR_7)
				return VAR_7;
		}

		if (uapi_key_is_write_method(VAR_4.index))
			VAR_3 = max(VAR_3,
					VAR_4.index & VAR_10);
		if (uapi_key_is_write_ex_method(VAR_4.index))
			VAR_2 =
				max(VAR_2,
				    VAR_4.index & VAR_10);
	}

	VAR_0->notsupp_method.handler = VAR_11;
	VAR_0->num_write = VAR_3 + 1;
	VAR_0->num_write_ex = VAR_2 + 1;
	VAR_1 = kmalloc_array(VAR_0->num_write + VAR_0->num_write_ex,
			     sizeof(*VAR_0->write_methods), VAR_12);
	if (!VAR_1)
		return -VAR_13;

	for (VAR_8 = 0; VAR_8 != VAR_0->num_write + VAR_0->num_write_ex; VAR_8++)
		VAR_1[VAR_8] = &VAR_0->notsupp_method;
	VAR_0->write_methods = VAR_1;
	VAR_0->write_ex_methods = VAR_1 + VAR_0->num_write;

	radix_tree_for_each_slot (VAR_6, &VAR_0->radix, &VAR_4, 0) {
		if (uapi_key_is_write_method(VAR_4.index))
			VAR_0->write_methods[VAR_4.index &
					    VAR_10] =
				rcu_dereference_protected(*VAR_6, true);
		if (uapi_key_is_write_ex_method(VAR_4.index))
			VAR_0->write_ex_methods[VAR_4.index &
					       VAR_10] =
				rcu_dereference_protected(*VAR_6, true);
	}

	return 0;
}",torvalds/linux/7694a7de22c53a312ea98960fcafc6ec62046531/uverbs_uapi.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -33,6 +33,9 @@
 	uapi->num_write_ex = max_write_ex + 1;
 	data = kmalloc_array(uapi->num_write + uapi->num_write_ex,
 			     sizeof(*uapi->write_methods), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
 	for (i = 0; i != uapi->num_write + uapi->num_write_ex; i++)
 		data[i] = &uapi->notsupp_method;
 	uapi->write_methods = data;","{'deleted_lines': [], 'added_lines': ['\tif (!data)', '\t\treturn -ENOMEM;', '']}",True,An issue was discovered in the Linux kernel through 5.16-rc6. uapi_finalize in drivers/infiniband/core/uverbs_uapi.c lacks check of kmalloc_array().,5.5,MEDIUM,1,test,,5
CVE-2022-3108,['CWE-252'],CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H,1,torvalds/linux,"As the possible failure of the allocation, kmemdup() may return NULL
pointer.
Therefore, it should be better to check the 'props2' in order to prevent
the dereference of NULL pointer.

Fixes: 3a87177eb141 (""drm/amdkfd: Add topology support for dGPUs"")
Signed-off-by: Jiasheng Jiang <jiasheng@iscas.ac.cn>
Reviewed-by: Felix Kuehling <Felix.Kuehling@amd.com>
Signed-off-by: Felix Kuehling <Felix.Kuehling@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
",abfaf0eee97925905e742aa3b0b72e04a918fa9e,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=v5.19-rc2&h=abfaf0eee97925905e742aa3b0b72e04a918fa9e,drivers/gpu/drm/amd/amdkfd/kfd_crat.c,kfd_parse_subtype_iolink,"static int kfd_parse_subtype_iolink(struct crat_subtype_iolink *iolink,
struct list_head *device_list)
{
struct kfd_iolink_properties *props = NULL, *props2;
struct kfd_topology_device *dev, *to_dev;
uint32_t id_from;
uint32_t id_to;
id_from = iolink->proximity_domain_from;
id_to = iolink->proximity_domain_to;
pr_debug(""Found IO link entry in CRAT table with id_from=%d, id_to %d\n"",
id_from, id_to);
list_for_each_entry(dev, device_list, list) {
if (id_from == dev->proximity_domain) {
props = kfd_alloc_struct(props);
if (!props)
return -ENOMEM;
props->node_from = id_from;
props->node_to = id_to;
props->ver_maj = iolink->version_major;
props->ver_min = iolink->version_minor;
props->iolink_type = iolink->io_interface_type;
if (props->iolink_type == CRAT_IOLINK_TYPE_PCIEXPRESS)
props->weight = 20;
else if (props->iolink_type == CRAT_IOLINK_TYPE_XGMI)
props->weight = 15 * iolink->num_hops_xgmi;
else
props->weight = node_distance(id_from, id_to);
props->min_latency = iolink->minimum_latency;
props->max_latency = iolink->maximum_latency;
props->min_bandwidth = iolink->minimum_bandwidth_mbs;
props->max_bandwidth = iolink->maximum_bandwidth_mbs;
props->rec_transfer_size =
iolink->recommended_transfer_size;
dev->io_link_count++;
dev->node_props.io_links_count++;
list_add_tail(&props->list, &dev->io_link_props);
break;
}
}
if (props && (iolink->flags & CRAT_IOLINK_FLAGS_BI_DIRECTIONAL)) {
to_dev = kfd_topology_device_by_proximity_domain(id_to);
if (!to_dev)
return -ENODEV;
props2 = kmemdup(props, sizeof(*props2), GFP_KERNEL);
props2->node_from = id_to;
props2->node_to = id_from;
props2->kobj = NULL;
to_dev->io_link_count++;
to_dev->node_props.io_links_count++;
list_add_tail(&props2->list, &to_dev->io_link_props);
}
return 0;
}","static int kfd_parse_subtype_iolink(struct crat_subtype_iolink *VAR_0,
struct list_head *VAR_1)
{
struct kfd_iolink_properties *VAR_2 = NULL, *VAR_3;
struct kfd_topology_device *VAR_4, *VAR_5;
uint32_t VAR_6;
uint32_t VAR_7;
VAR_6 = VAR_0->proximity_domain_from;
VAR_7 = VAR_0->proximity_domain_to;
pr_debug(""Found IO link entry in CRAT table with id_from=%d, id_to %d\n"",
VAR_6, VAR_7);
list_for_each_entry(VAR_4, VAR_1, VAR_8) {
if (VAR_6 == VAR_4->proximity_domain) {
VAR_2 = kfd_alloc_struct(VAR_2);
if (!VAR_2)
return -VAR_9;
VAR_2->node_from = VAR_6;
VAR_2->node_to = VAR_7;
VAR_2->ver_maj = VAR_0->version_major;
VAR_2->ver_min = VAR_0->version_minor;
VAR_2->iolink_type = VAR_0->io_interface_type;
if (VAR_2->iolink_type == VAR_10)
VAR_2->weight = 20;
else if (VAR_2->iolink_type == VAR_11)
VAR_2->weight = 15 * VAR_0->num_hops_xgmi;
else
VAR_2->weight = node_distance(VAR_6, VAR_7);
VAR_2->min_latency = VAR_0->minimum_latency;
VAR_2->max_latency = VAR_0->maximum_latency;
VAR_2->min_bandwidth = VAR_0->minimum_bandwidth_mbs;
VAR_2->max_bandwidth = VAR_0->maximum_bandwidth_mbs;
VAR_2->rec_transfer_size =
VAR_0->recommended_transfer_size;
VAR_4->io_link_count++;
VAR_4->node_props.io_links_count++;
list_add_tail(&VAR_2->list, &VAR_4->io_link_props);
break;
}
}
if (VAR_2 && (VAR_0->flags & VAR_12)) {
VAR_5 = kfd_topology_device_by_proximity_domain(VAR_7);
if (!VAR_5)
return -VAR_13;
VAR_3 = kmemdup(VAR_2, sizeof(*VAR_3), VAR_14);
VAR_3->node_from = VAR_7;
VAR_3->node_to = VAR_6;
VAR_3->kobj = NULL;
VAR_5->io_link_count++;
VAR_5->node_props.io_links_count++;
list_add_tail(&VAR_3->list, &VAR_5->io_link_props);
}
return 0;
}",torvalds/linux/abfaf0eee97925905e742aa3b0b72e04a918fa9e/kfd_crat.c/vul/before/0.json,"static int kfd_parse_subtype_iolink(struct crat_subtype_iolink *iolink,
					struct list_head *device_list)
{
	struct kfd_iolink_properties *props = NULL, *props2;
	struct kfd_topology_device *dev, *to_dev;
	uint32_t id_from;
	uint32_t id_to;

	id_from = iolink->proximity_domain_from;
	id_to = iolink->proximity_domain_to;

	pr_debug(""Found IO link entry in CRAT table with id_from=%d, id_to %d\n"",
			id_from, id_to);
	list_for_each_entry(dev, device_list, list) {
		if (id_from == dev->proximity_domain) {
			props = kfd_alloc_struct(props);
			if (!props)
				return -ENOMEM;

			props->node_from = id_from;
			props->node_to = id_to;
			props->ver_maj = iolink->version_major;
			props->ver_min = iolink->version_minor;
			props->iolink_type = iolink->io_interface_type;

			if (props->iolink_type == CRAT_IOLINK_TYPE_PCIEXPRESS)
				props->weight = 20;
			else if (props->iolink_type == CRAT_IOLINK_TYPE_XGMI)
				props->weight = 15 * iolink->num_hops_xgmi;
			else
				props->weight = node_distance(id_from, id_to);

			props->min_latency = iolink->minimum_latency;
			props->max_latency = iolink->maximum_latency;
			props->min_bandwidth = iolink->minimum_bandwidth_mbs;
			props->max_bandwidth = iolink->maximum_bandwidth_mbs;
			props->rec_transfer_size =
					iolink->recommended_transfer_size;

			dev->io_link_count++;
			dev->node_props.io_links_count++;
			list_add_tail(&props->list, &dev->io_link_props);
			break;
		}
	}

	/* CPU topology is created before GPUs are detected, so CPU->GPU
	 * links are not built at that time. If a PCIe type is discovered, it
	 * means a GPU is detected and we are adding GPU->CPU to the topology.
	 * At this time, also add the corresponded CPU->GPU link if GPU
	 * is large bar.
	 * For xGMI, we only added the link with one direction in the crat
	 * table, add corresponded reversed direction link now.
	 */
	if (props && (iolink->flags & CRAT_IOLINK_FLAGS_BI_DIRECTIONAL)) {
		to_dev = kfd_topology_device_by_proximity_domain(id_to);
		if (!to_dev)
			return -ENODEV;
		/* same everything but the other direction */
		props2 = kmemdup(props, sizeof(*props2), GFP_KERNEL);
		if (!props2)
			return -ENOMEM;

		props2->node_from = id_to;
		props2->node_to = id_from;
		props2->kobj = NULL;
		to_dev->io_link_count++;
		to_dev->node_props.io_links_count++;
		list_add_tail(&props2->list, &to_dev->io_link_props);
	}

	return 0;
}","static int kfd_parse_subtype_iolink(struct crat_subtype_iolink *VAR_0,
					struct list_head *VAR_1)
{
	struct kfd_iolink_properties *VAR_2 = NULL, *VAR_3;
	struct kfd_topology_device *VAR_4, *VAR_5;
	uint32_t VAR_6;
	uint32_t VAR_7;

	VAR_6 = VAR_0->proximity_domain_from;
	VAR_7 = VAR_0->proximity_domain_to;

	pr_debug(""Found IO link entry in CRAT table with id_from=%d, id_to %d\n"",
			VAR_6, VAR_7);
	list_for_each_entry(VAR_4, VAR_1, VAR_8) {
		if (VAR_6 == VAR_4->proximity_domain) {
			VAR_2 = kfd_alloc_struct(VAR_2);
			if (!VAR_2)
				return -VAR_9;

			VAR_2->node_from = VAR_6;
			VAR_2->node_to = VAR_7;
			VAR_2->ver_maj = VAR_0->version_major;
			VAR_2->ver_min = VAR_0->version_minor;
			VAR_2->iolink_type = VAR_0->io_interface_type;

			if (VAR_2->iolink_type == VAR_10)
				VAR_2->weight = 20;
			else if (VAR_2->iolink_type == VAR_11)
				VAR_2->weight = 15 * VAR_0->num_hops_xgmi;
			else
				VAR_2->weight = node_distance(VAR_6, VAR_7);

			VAR_2->min_latency = VAR_0->minimum_latency;
			VAR_2->max_latency = VAR_0->maximum_latency;
			VAR_2->min_bandwidth = VAR_0->minimum_bandwidth_mbs;
			VAR_2->max_bandwidth = VAR_0->maximum_bandwidth_mbs;
			VAR_2->rec_transfer_size =
					VAR_0->recommended_transfer_size;

			VAR_4->io_link_count++;
			VAR_4->node_props.io_links_count++;
			list_add_tail(&VAR_2->list, &VAR_4->io_link_props);
			break;
		}
	}

	/* COMMENT_0 */
                                                                      
                                                                       
                                                                
                 
                                                                   
                                                        
    
	if (VAR_2 && (VAR_0->flags & VAR_12)) {
		VAR_5 = kfd_topology_device_by_proximity_domain(VAR_7);
		if (!VAR_5)
			return -VAR_13;
		/* COMMENT_8 */
		VAR_3 = kmemdup(VAR_2, sizeof(*VAR_3), VAR_14);
		if (!VAR_3)
			return -VAR_9;

		VAR_3->node_from = VAR_7;
		VAR_3->node_to = VAR_6;
		VAR_3->kobj = NULL;
		VAR_5->io_link_count++;
		VAR_5->node_props.io_links_count++;
		list_add_tail(&VAR_3->list, &VAR_5->io_link_props);
	}

	return 0;
}",torvalds/linux/abfaf0eee97925905e742aa3b0b72e04a918fa9e/kfd_crat.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -58,6 +58,9 @@
 			return -ENODEV;
 		/* same everything but the other direction */
 		props2 = kmemdup(props, sizeof(*props2), GFP_KERNEL);
+		if (!props2)
+			return -ENOMEM;
+
 		props2->node_from = id_to;
 		props2->node_to = id_from;
 		props2->kobj = NULL;","{'deleted_lines': [], 'added_lines': ['\t\tif (!props2)', '\t\t\treturn -ENOMEM;', '']}",True,An issue was discovered in the Linux kernel through 5.16-rc6. kfd_parse_subtype_iolink in drivers/gpu/drm/amd/amdkfd/kfd_crat.c lacks check of the return value of kmemdup().,5.5,MEDIUM,1,test,,5
CVE-2018-1095,['CWE-476'],AV:N/AC:M/Au:N/C:N/I:N/A:C,0,kernel/git/tytso/ext4,"ext4 isn't validating the sizes of xattrs where the value of the xattr
is stored in an external inode.  This is problematic because
->e_value_size is a u32, but ext4_xattr_get() returns an int.  A very
large size is misinterpreted as an error code, which ext4_get_acl()
translates into a bogus ERR_PTR() for which IS_ERR() returns false,
causing a crash.

Fix this by validating that all xattrs are <= INT_MAX bytes.

This issue has been assigned CVE-2018-1095.

https://bugzilla.kernel.org/show_bug.cgi?id=199185
https://bugzilla.redhat.com/show_bug.cgi?id=1560793

Reported-by: Wen Xu <wen.xu@gatech.edu>
Signed-off-by: Eric Biggers <ebiggers@google.com>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
Cc: stable@vger.kernel.org
Fixes: e50e5129f384 (""ext4: xattr-in-inode support"")
",ce3fd194fcc6fbdc00ce095a852f22df97baa401,https://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4.git/commit/?h=ce3fd194fcc6fbdc00ce095a852f22df97baa401,fs/ext4/xattr.c,ext4_xattr_check_entries,"static int
ext4_xattr_check_entries(struct ext4_xattr_entry *entry, void *end,
void *value_start)
{
struct ext4_xattr_entry *e = entry;
while (!IS_LAST_ENTRY(e)) {
struct ext4_xattr_entry *next = EXT4_XATTR_NEXT(e);
if ((void *)next >= end)
return -EFSCORRUPTED;
e = next;
}
while (!IS_LAST_ENTRY(entry)) {
if (entry->e_value_size != 0 &&
entry->e_value_inum == 0) {
u16 offs = le16_to_cpu(entry->e_value_offs);
u32 size = le32_to_cpu(entry->e_value_size);
void *value;
if (offs > end - value_start)
return -EFSCORRUPTED;
value = value_start + offs;
if (value < (void *)e + sizeof(u32) ||
size > end - value ||
EXT4_XATTR_SIZE(size) > end - value)
return -EFSCORRUPTED;
}
entry = EXT4_XATTR_NEXT(entry);
}
return 0;
}","static int
ext4_xattr_check_entries(struct ext4_xattr_entry *VAR_0, void *VAR_1,
void *VAR_2)
{
struct ext4_xattr_entry *VAR_3 = VAR_0;
while (!IS_LAST_ENTRY(VAR_3)) {
struct ext4_xattr_entry *VAR_4 = EXT4_XATTR_NEXT(VAR_3);
if ((void *)VAR_4 >= VAR_1)
return -VAR_5;
VAR_3 = VAR_4;
}
while (!IS_LAST_ENTRY(VAR_0)) {
if (VAR_0->e_value_size != 0 &&
VAR_0->e_value_inum == 0) {
u16 VAR_6 = le16_to_cpu(VAR_0->e_value_offs);
u32 VAR_7 = le32_to_cpu(VAR_0->e_value_size);
void *VAR_8;
if (VAR_6 > VAR_1 - VAR_2)
return -VAR_5;
VAR_8 = VAR_2 + VAR_6;
if (VAR_8 < (void *)VAR_3 + sizeof(u32) ||
VAR_7 > VAR_1 - VAR_8 ||
EXT4_XATTR_SIZE(VAR_7) > VAR_1 - VAR_8)
return -VAR_5;
}
VAR_0 = EXT4_XATTR_NEXT(VAR_0);
}
return 0;
}",kernel/git/tytso/ext4/ce3fd194fcc6fbdc00ce095a852f22df97baa401/xattr.c/vul/before/0.json,"static int
ext4_xattr_check_entries(struct ext4_xattr_entry *entry, void *end,
			 void *value_start)
{
	struct ext4_xattr_entry *e = entry;

	/* Find the end of the names list */
	while (!IS_LAST_ENTRY(e)) {
		struct ext4_xattr_entry *next = EXT4_XATTR_NEXT(e);
		if ((void *)next >= end)
			return -EFSCORRUPTED;
		e = next;
	}

	/* Check the values */
	while (!IS_LAST_ENTRY(entry)) {
		u32 size = le32_to_cpu(entry->e_value_size);

		if (size > INT_MAX)
			return -EFSCORRUPTED;

		if (size != 0 && entry->e_value_inum == 0) {
			u16 offs = le16_to_cpu(entry->e_value_offs);
			void *value;

			/*
			 * The value cannot overlap the names, and the value
			 * with padding cannot extend beyond 'end'.  Check both
			 * the padded and unpadded sizes, since the size may
			 * overflow to 0 when adding padding.
			 */
			if (offs > end - value_start)
				return -EFSCORRUPTED;
			value = value_start + offs;
			if (value < (void *)e + sizeof(u32) ||
			    size > end - value ||
			    EXT4_XATTR_SIZE(size) > end - value)
				return -EFSCORRUPTED;
		}
		entry = EXT4_XATTR_NEXT(entry);
	}

	return 0;
}","static int
ext4_xattr_check_entries(struct ext4_xattr_entry *VAR_0, void *VAR_1,
			 void *VAR_2)
{
	struct ext4_xattr_entry *VAR_3 = VAR_0;

	/* COMMENT_0 */
	while (!IS_LAST_ENTRY(VAR_3)) {
		struct ext4_xattr_entry *VAR_4 = EXT4_XATTR_NEXT(VAR_3);
		if ((void *)VAR_4 >= VAR_1)
			return -VAR_5;
		VAR_3 = VAR_4;
	}

	/* COMMENT_1 */
	while (!IS_LAST_ENTRY(VAR_0)) {
		u32 VAR_6 = le32_to_cpu(VAR_0->e_value_size);

		if (VAR_6 > VAR_7)
			return -VAR_5;

		if (VAR_6 != 0 && VAR_0->e_value_inum == 0) {
			u16 VAR_8 = le16_to_cpu(VAR_0->e_value_offs);
			void *VAR_9;

			/* COMMENT_2 */
                                                       
                                                          
                                                       
                                        
      
			if (VAR_8 > VAR_1 - VAR_2)
				return -VAR_5;
			VAR_9 = VAR_2 + VAR_8;
			if (VAR_9 < (void *)VAR_3 + sizeof(u32) ||
			    VAR_6 > VAR_1 - VAR_9 ||
			    EXT4_XATTR_SIZE(VAR_6) > VAR_1 - VAR_9)
				return -VAR_5;
		}
		VAR_0 = EXT4_XATTR_NEXT(VAR_0);
	}

	return 0;
}",kernel/git/tytso/ext4/ce3fd194fcc6fbdc00ce095a852f22df97baa401/xattr.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -14,10 +14,13 @@
 
 	/* Check the values */
 	while (!IS_LAST_ENTRY(entry)) {
-		if (entry->e_value_size != 0 &&
-		    entry->e_value_inum == 0) {
+		u32 size = le32_to_cpu(entry->e_value_size);
+
+		if (size > INT_MAX)
+			return -EFSCORRUPTED;
+
+		if (size != 0 && entry->e_value_inum == 0) {
 			u16 offs = le16_to_cpu(entry->e_value_offs);
-			u32 size = le32_to_cpu(entry->e_value_size);
 			void *value;
 
 			/*","{'deleted_lines': ['\t\tif (entry->e_value_size != 0 &&', '\t\t    entry->e_value_inum == 0) {', '\t\t\tu32 size = le32_to_cpu(entry->e_value_size);'], 'added_lines': ['\t\tu32 size = le32_to_cpu(entry->e_value_size);', '', '\t\tif (size > INT_MAX)', '\t\t\treturn -EFSCORRUPTED;', '', '\t\tif (size != 0 && entry->e_value_inum == 0) {']}",True,"The ext4_xattr_check_entries function in fs/ext4/xattr.c in the Linux kernel through 4.15.15 does not properly validate xattr sizes, which causes misinterpretation of a size as an error code, and consequently allows attackers to cause a denial of service (get_acl NULL pointer dereference and system crash) via a crafted ext4 image.",5.5,MEDIUM,1,test,,5
CVE-2018-10583,['CWE-200'],AV:N/AC:L/Au:N/C:P/I:N/A:N,0,libreoffice/core,"to allow determining if the source document is from a trusted/untrusted
location

Change-Id: I780568652d2ef0cc8543c27ba26289277b5d9d0c
Reviewed-on: https://gerrit.libreoffice.org/53689
Tested-by: Jenkins <ci@libreoffice.org>
Reviewed-by: Caoln McNamara <caolanm@redhat.com>
Tested-by: Caoln McNamara <caolanm@redhat.com>
",0b7f4a4f57117fde33d0b1df96134aa6ccce023e,https://cgit.freedesktop.org/libreoffice/core/commit/?id=0b7f4a4f57117fde33d0b1df96134aa6ccce023e,sw/source/filter/xml/xmltexti.cxx,SwXMLTextImportHelper::createAndInsertOOoLink,"uno::Reference< XPropertySet > SwXMLTextImportHelper::createAndInsertOOoLink(
SvXMLImport& rImport,
const OUString& rHRef,
const OUString& ,
const OUString& ,
sal_Int32 nWidth, sal_Int32 nHeight )
{
SolarMutexGuard aGuard;
uno::Reference < XPropertySet > xPropSet;
uno::Reference<XUnoTunnel> xCursorTunnel( GetCursor(), UNO_QUERY );
assert(xCursorTunnel.is() && ""missing XUnoTunnel for Cursor"");
OTextCursorHelper *pTextCursor = reinterpret_cast< OTextCursorHelper * >(
sal::static_int_cast< sal_IntPtr >( xCursorTunnel->getSomething( OTextCursorHelper::getUnoTunnelId() )));
OSL_ENSURE( pTextCursor, ""SwXTextCursor missing"" );
SwDoc *pDoc = SwImport::GetDocFromXMLImport( rImport );
SfxItemSet aItemSet( pDoc->GetAttrPool(), svl::Items<RES_FRMATR_BEGIN,
RES_FRMATR_END>{} );
Size aTwipSize( 0, 0 );
lcl_putHeightAndWidth( aItemSet, nHeight, nWidth,
&aTwipSize );
INetURLObject aURLObj;
bool bValidURL = !rHRef.isEmpty() &&
aURLObj.SetURL( URIHelper::SmartRel2Abs(
INetURLObject( GetXMLImport().GetBaseURL() ), rHRef ) );
if( !bValidURL )
return xPropSet;
uno::Reference < embed::XStorage > xStorage = comphelper::OStorageHelper::GetTemporaryStorage();
try
{
uno::Reference < embed::XEmbeddedObjectCreator > xFactory =
embed::OOoEmbeddedObjectFactory::create(::comphelper::getProcessComponentContext());
uno::Sequence< beans::PropertyValue > aMediaDescriptor( 1 );
aMediaDescriptor[0].Name = ""URL"";
aMediaDescriptor[0].Value <<= aURLObj.GetMainURL( INetURLObject::DecodeMechanism::NONE );
if ( pDoc->GetDocShell() && pDoc->GetDocShell()->GetMedium() )
{
uno::Reference< task::XInteractionHandler > xInteraction =
pDoc->GetDocShell()->GetMedium()->GetInteractionHandler();
if ( xInteraction.is() )
{
aMediaDescriptor.realloc( 2 );
aMediaDescriptor[1].Name = ""InteractionHandler"";
aMediaDescriptor[1].Value <<= xInteraction;
}
}
uno::Reference < embed::XEmbeddedObject > xObj(
xFactory->createInstanceLink(
xStorage, ""DummyName"", aMediaDescriptor, uno::Sequence< beans::PropertyValue >() ),
uno::UNO_QUERY_THROW );
{
SwFrameFormat *const pFrameFormat =
pDoc->getIDocumentContentOperations().InsertEmbObject(
*pTextCursor->GetPaM(),
::svt::EmbeddedObjectRef(xObj, embed::Aspects::MSOLE_CONTENT),
&aItemSet );
xPropSet.set(SwXTextEmbeddedObject::CreateXTextEmbeddedObject(
*pDoc, pFrameFormat), uno::UNO_QUERY);
if( pDoc->getIDocumentDrawModelAccess().GetDrawModel() )
{
SwXFrame::GetOrCreateSdrObject(*
static_cast<SwFlyFrameFormat*>(pFrameFormat));             }
}
}
catch ( uno::Exception& )
{
}
return xPropSet;
}","uno::Reference< XPropertySet > SwXMLTextImportHelper::createAndInsertOOoLink(
SvXMLImport& VAR_0,
const OUString& VAR_1,
const OUString& ,
const OUString& ,
sal_Int32 VAR_2, sal_Int32 VAR_3 )
{
SolarMutexGuard VAR_4;
uno::Reference < XPropertySet > VAR_5;
uno::Reference<XUnoTunnel> xCursorTunnel( GetCursor(), UNO_QUERY );
assert(VAR_6.is() && ""missing XUnoTunnel for Cursor"");
OTextCursorHelper *VAR_7 = VAR_8< OTextCursorHelper * >(
sal::VAR_9< sal_IntPtr >( VAR_6->getSomething( OTextCursorHelper::getUnoTunnelId() )));
OSL_ENSURE( VAR_7, ""SwXTextCursor missing"" );
SwDoc *VAR_10 = SwImport::GetDocFromXMLImport( VAR_0 );
SfxItemSet VAR_11( VAR_10->GetAttrPool(), svl::Items<RES_FRMATR_BEGIN,
RES_FRMATR_END>{} );
Size VAR_12( 0, 0 );
lcl_putHeightAndWidth( VAR_11, VAR_3, VAR_2,
&VAR_12 );
INetURLObject VAR_13;
bool VAR_14 = !VAR_1.isEmpty() &&
VAR_13.SetURL( URIHelper::SmartRel2Abs(
INetURLObject( GetXMLImport().GetBaseURL() ), VAR_1 ) );
if( !VAR_14 )
return VAR_5;
uno::Reference < embed::XStorage > VAR_15 = comphelper::OStorageHelper::GetTemporaryStorage();
try
{
uno::Reference < embed::XEmbeddedObjectCreator > VAR_16 =
embed::OOoEmbeddedObjectFactory::create(::comphelper::getProcessComponentContext());
uno::Sequence< beans::PropertyValue > VAR_17( 1 );
VAR_17[0].Name = ""URL"";
VAR_17[0].Value <<= VAR_13.GetMainURL( INetURLObject::DecodeMechanism::NONE );
if ( VAR_10->GetDocShell() && VAR_10->GetDocShell()->GetMedium() )
{
uno::Reference< task::XInteractionHandler > VAR_18 =
VAR_10->GetDocShell()->GetMedium()->GetInteractionHandler();
if ( VAR_18.is() )
{
VAR_17.realloc( 2 );
VAR_17[1].Name = ""InteractionHandler"";
VAR_17[1].Value <<= VAR_18;
}
}
uno::Reference < embed::XEmbeddedObject > VAR_19(
VAR_16->createInstanceLink(
VAR_15, ""DummyName"", VAR_17, uno::Sequence< beans::PropertyValue >() ),
uno::UNO_QUERY_THROW );
{
SwFrameFormat *const VAR_20 =
VAR_10->getIDocumentContentOperations().InsertEmbObject(
*VAR_7->GetPaM(),
::svt::EmbeddedObjectRef(VAR_19, embed::Aspects::MSOLE_CONTENT),
&VAR_11 );
VAR_5.set(SwXTextEmbeddedObject::CreateXTextEmbeddedObject(
*VAR_10, VAR_20), uno::UNO_QUERY);
if( VAR_10->getIDocumentDrawModelAccess().GetDrawModel() )
{
SwXFrame::GetOrCreateSdrObject(*
VAR_21<SwFlyFrameFormat*>(VAR_20)); 
}
}
}
catch ( uno::Exception& )
{
}
return VAR_5;
}",libreoffice/core/0b7f4a4f57117fde33d0b1df96134aa6ccce023e/xmltexti.cxx/vul/before/0.json,"uno::Reference< XPropertySet > SwXMLTextImportHelper::createAndInsertOOoLink(
        SvXMLImport& rImport,
        const OUString& rHRef,
        const OUString& /*rStyleName*/,
        const OUString& /*rTableName*/,
        sal_Int32 nWidth, sal_Int32 nHeight )
{
    // this method will modify the document directly -> lock SolarMutex
    SolarMutexGuard aGuard;

    uno::Reference < XPropertySet > xPropSet;

    uno::Reference<XUnoTunnel> xCursorTunnel( GetCursor(), UNO_QUERY );
    assert(xCursorTunnel.is() && ""missing XUnoTunnel for Cursor"");
    OTextCursorHelper *pTextCursor = reinterpret_cast< OTextCursorHelper * >(
                sal::static_int_cast< sal_IntPtr >( xCursorTunnel->getSomething( OTextCursorHelper::getUnoTunnelId() )));
    OSL_ENSURE( pTextCursor, ""SwXTextCursor missing"" );
    SwDoc *pDoc = SwImport::GetDocFromXMLImport( rImport );

    SfxItemSet aItemSet( pDoc->GetAttrPool(), svl::Items<RES_FRMATR_BEGIN,
                         RES_FRMATR_END>{} );
    Size aTwipSize( 0, 0 );
    lcl_putHeightAndWidth( aItemSet, nHeight, nWidth,
                           &aTwipSize );

    // We'll need a (valid) URL. If we don't have do not insert the link and return early.
    // Copy URL into URL object on the way.
       INetURLObject aURLObj;
    bool bValidURL = !rHRef.isEmpty() &&
                     aURLObj.SetURL( URIHelper::SmartRel2Abs(
                                INetURLObject( GetXMLImport().GetBaseURL() ), rHRef ) );
    if( !bValidURL )
        return xPropSet;

    uno::Reference < embed::XStorage > xStorage = comphelper::OStorageHelper::GetTemporaryStorage();
    try
    {
        // create object with desired ClassId
        uno::Reference < embed::XEmbeddedObjectCreator > xFactory =
                embed::OOoEmbeddedObjectFactory::create(::comphelper::getProcessComponentContext());

        uno::Sequence< beans::PropertyValue > aMediaDescriptor( 1 );
        aMediaDescriptor[0].Name = ""URL"";
        aMediaDescriptor[0].Value <<= aURLObj.GetMainURL( INetURLObject::DecodeMechanism::NONE );

        if (SfxMedium* pMedium = pDoc->GetDocShell() ? pDoc->GetDocShell()->GetMedium() : nullptr)
        {
            uno::Reference< task::XInteractionHandler > xInteraction = pMedium->GetInteractionHandler();
            if ( xInteraction.is() )
            {
                aMediaDescriptor.realloc( 2 );
                aMediaDescriptor[1].Name = ""InteractionHandler"";
                aMediaDescriptor[1].Value <<= xInteraction;
            }

            const auto nLen = aMediaDescriptor.getLength() + 1;
            aMediaDescriptor.realloc(nLen);
            aMediaDescriptor[nLen - 1].Name = ""Referer"";
            aMediaDescriptor[nLen - 1].Value <<= pMedium->GetName();
        }

        uno::Reference < embed::XEmbeddedObject > xObj(
            xFactory->createInstanceLink(
                xStorage, ""DummyName"", aMediaDescriptor, uno::Sequence< beans::PropertyValue >() ),
            uno::UNO_QUERY_THROW );

        {
            SwFrameFormat *const pFrameFormat =
                pDoc->getIDocumentContentOperations().InsertEmbObject(
                    *pTextCursor->GetPaM(),
                    ::svt::EmbeddedObjectRef(xObj, embed::Aspects::MSOLE_CONTENT),
                    &aItemSet );

            // TODO/LATER: in future may need a way to set replacement image url to the link ( may be even to the object ), needs oasis cws???

            xPropSet.set(SwXTextEmbeddedObject::CreateXTextEmbeddedObject(
                            *pDoc, pFrameFormat), uno::UNO_QUERY);
            if( pDoc->getIDocumentDrawModelAccess().GetDrawModel() )
            {
                SwXFrame::GetOrCreateSdrObject(*
                        static_cast<SwFlyFrameFormat*>(pFrameFormat)); // req for z-order
            }
        }
    }
    catch ( uno::Exception& )
    {
    }

    // TODO/LATER: should the rStyleName and rTableName be handled as for usual embedded object?

    return xPropSet;
}","uno::Reference< XPropertySet > SwXMLTextImportHelper::createAndInsertOOoLink(
        SvXMLImport& VAR_0,
        const OUString& VAR_1,
        const OUString& /* COMMENT_0 */,
        const OUString& /* COMMENT_1 */,
        sal_Int32 VAR_2, sal_Int32 VAR_3 )
{
    /* COMMENT_2 */
    SolarMutexGuard VAR_4;

    uno::Reference < XPropertySet > VAR_5;

    uno::Reference<XUnoTunnel> xCursorTunnel( GetCursor(), UNO_QUERY );
    assert(VAR_6.is() && ""missing XUnoTunnel for Cursor"");
    OTextCursorHelper *VAR_7 = VAR_8< OTextCursorHelper * >(
                sal::VAR_9< sal_IntPtr >( VAR_6->getSomething( OTextCursorHelper::getUnoTunnelId() )));
    OSL_ENSURE( VAR_7, ""SwXTextCursor missing"" );
    SwDoc *VAR_10 = SwImport::GetDocFromXMLImport( VAR_0 );

    SfxItemSet VAR_11( VAR_10->GetAttrPool(), svl::Items<RES_FRMATR_BEGIN,
                         RES_FRMATR_END>{} );
    Size VAR_12( 0, 0 );
    lcl_putHeightAndWidth( VAR_11, VAR_3, VAR_2,
                           &VAR_12 );

    /* COMMENT_3 */
    /* COMMENT_4 */
       INetURLObject VAR_13;
    bool VAR_14 = !VAR_1.isEmpty() &&
                     VAR_13.SetURL( URIHelper::SmartRel2Abs(
                                INetURLObject( GetXMLImport().GetBaseURL() ), VAR_1 ) );
    if( !VAR_14 )
        return VAR_5;

    uno::Reference < embed::XStorage > VAR_15 = comphelper::OStorageHelper::GetTemporaryStorage();
    try
    {
        /* COMMENT_5 */
        uno::Reference < embed::XEmbeddedObjectCreator > VAR_16 =
                embed::OOoEmbeddedObjectFactory::create(::comphelper::getProcessComponentContext());

        uno::Sequence< beans::PropertyValue > VAR_17( 1 );
        VAR_17[0].Name = ""URL"";
        VAR_17[0].Value <<= VAR_13.GetMainURL( INetURLObject::DecodeMechanism::NONE );

        if (SfxMedium* VAR_18 = VAR_10->GetDocShell() ? VAR_10->GetDocShell()->GetMedium() : nullptr)
        {
            uno::Reference< task::XInteractionHandler > VAR_19 = VAR_18->GetInteractionHandler();
            if ( VAR_19.is() )
            {
                VAR_17.realloc( 2 );
                VAR_17[1].Name = ""InteractionHandler"";
                VAR_17[1].Value <<= VAR_19;
            }

            const auto VAR_20 = VAR_17.getLength() + 1;
            VAR_17.realloc(VAR_20);
            VAR_17[VAR_20 - 1].Name = ""Referer"";
            VAR_17[VAR_20 - 1].Value <<= VAR_18->GetName();
        }

        uno::Reference < embed::XEmbeddedObject > VAR_21(
            VAR_16->createInstanceLink(
                VAR_15, ""DummyName"", VAR_17, uno::Sequence< beans::PropertyValue >() ),
            uno::UNO_QUERY_THROW );

        {
            SwFrameFormat *const VAR_22 =
                VAR_10->getIDocumentContentOperations().InsertEmbObject(
                    *VAR_7->GetPaM(),
                    ::svt::EmbeddedObjectRef(VAR_21, embed::Aspects::MSOLE_CONTENT),
                    &VAR_11 );

            /* COMMENT_6 */

            VAR_5.set(SwXTextEmbeddedObject::CreateXTextEmbeddedObject(
                            *VAR_10, VAR_22), uno::UNO_QUERY);
            if( VAR_10->getIDocumentDrawModelAccess().GetDrawModel() )
            {
                SwXFrame::GetOrCreateSdrObject(*
                        VAR_23<SwFlyFrameFormat*>(VAR_22)); /* COMMENT_7 */
            }
        }
    }
    catch ( uno::Exception& )
    {
    }

    /* COMMENT_8 */

    return VAR_5;
}",libreoffice/core/0b7f4a4f57117fde33d0b1df96134aa6ccce023e/xmltexti.cxx/vul/after/0.json,"--- func_before
+++ func_after
@@ -42,16 +42,21 @@
         uno::Sequence< beans::PropertyValue > aMediaDescriptor( 1 );
         aMediaDescriptor[0].Name = ""URL"";
         aMediaDescriptor[0].Value <<= aURLObj.GetMainURL( INetURLObject::DecodeMechanism::NONE );
-        if ( pDoc->GetDocShell() && pDoc->GetDocShell()->GetMedium() )
+
+        if (SfxMedium* pMedium = pDoc->GetDocShell() ? pDoc->GetDocShell()->GetMedium() : nullptr)
         {
-            uno::Reference< task::XInteractionHandler > xInteraction =
-                                        pDoc->GetDocShell()->GetMedium()->GetInteractionHandler();
+            uno::Reference< task::XInteractionHandler > xInteraction = pMedium->GetInteractionHandler();
             if ( xInteraction.is() )
             {
                 aMediaDescriptor.realloc( 2 );
                 aMediaDescriptor[1].Name = ""InteractionHandler"";
                 aMediaDescriptor[1].Value <<= xInteraction;
             }
+
+            const auto nLen = aMediaDescriptor.getLength() + 1;
+            aMediaDescriptor.realloc(nLen);
+            aMediaDescriptor[nLen - 1].Name = ""Referer"";
+            aMediaDescriptor[nLen - 1].Value <<= pMedium->GetName();
         }
 
         uno::Reference < embed::XEmbeddedObject > xObj(","{'deleted_lines': ['        if ( pDoc->GetDocShell() && pDoc->GetDocShell()->GetMedium() )', '            uno::Reference< task::XInteractionHandler > xInteraction =', '                                        pDoc->GetDocShell()->GetMedium()->GetInteractionHandler();'], 'added_lines': ['', '        if (SfxMedium* pMedium = pDoc->GetDocShell() ? pDoc->GetDocShell()->GetMedium() : nullptr)', '            uno::Reference< task::XInteractionHandler > xInteraction = pMedium->GetInteractionHandler();', '', '            const auto nLen = aMediaDescriptor.getLength() + 1;', '            aMediaDescriptor.realloc(nLen);', '            aMediaDescriptor[nLen - 1].Name = ""Referer"";', '            aMediaDescriptor[nLen - 1].Value <<= pMedium->GetName();']}",True,"An information disclosure vulnerability occurs when LibreOffice 6.0.3 and Apache OpenOffice Writer 4.1.5 automatically process and initiate an SMB connection embedded in a malicious file, as demonstrated by xlink:href=file://192.168.0.2/test.jpg within an office:document-content element in a .odt XML document.",7.5,HIGH,2,test,,5
CVE-2018-5814,['CWE-362'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"stub_probe() calls put_busid_priv() in an error path when device isn't
found in the busid_table. Fix it by making put_busid_priv() safe to be
called with null struct bus_id_priv pointer.

This problem happens when ""usbip bind"" is run without loading usbip_host
driver and then running modprobe. The first failed bind attempt unbinds
the device from the original driver and when usbip_host is modprobed,
stub_probe() runs and doesn't find the device in its busid table and calls
put_busid_priv(0 with null bus_id_priv pointer.

usbip-host 3-10.2: 3-10.2 is not in match_busid table...  skip!

[  367.359679] =====================================
[  367.359681] WARNING: bad unlock balance detected!
[  367.359683] 4.17.0-rc4+ #5 Not tainted
[  367.359685] -------------------------------------
[  367.359688] modprobe/2768 is trying to release lock (
[  367.359689]
==================================================================
[  367.359696] BUG: KASAN: null-ptr-deref in print_unlock_imbalance_bug+0x99/0x110
[  367.359699] Read of size 8 at addr 0000000000000058 by task modprobe/2768

[  367.359705] CPU: 4 PID: 2768 Comm: modprobe Not tainted 4.17.0-rc4+ #5

Fixes: 22076557b07c (""usbip: usbip_host: fix NULL-ptr deref and use-after-free errors"") in usb-linus
Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>
Cc: stable <stable@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
",c171654caa875919be3c533d3518da8be5be966e,https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/commit/?h=c171654caa875919be3c533d3518da8be5be966e,drivers/usb/usbip/stub_main.c,put_busid_priv,"void put_busid_priv(struct bus_id_priv *bid)
{
spin_unlock(&bid->busid_lock);
}","void put_busid_priv(struct bus_id_priv *VAR_0)
{
spin_unlock(&VAR_0->busid_lock);
}",torvalds/linux/c171654caa875919be3c533d3518da8be5be966e/stub_main.c/vul/before/0.json,"void put_busid_priv(struct bus_id_priv *bid)
{
	if (bid)
		spin_unlock(&bid->busid_lock);
}","void put_busid_priv(struct bus_id_priv *VAR_0)
{
	if (VAR_0)
		spin_unlock(&VAR_0->busid_lock);
}",torvalds/linux/c171654caa875919be3c533d3518da8be5be966e/stub_main.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,4 +1,5 @@
 void put_busid_priv(struct bus_id_priv *bid)
 {
-	spin_unlock(&bid->busid_lock);
+	if (bid)
+		spin_unlock(&bid->busid_lock);
 }","{'deleted_lines': ['\tspin_unlock(&bid->busid_lock);'], 'added_lines': ['\tif (bid)', '\t\tspin_unlock(&bid->busid_lock);']}",True,"In the Linux Kernel before version 4.16.11, 4.14.43, 4.9.102, and 4.4.133, multiple race condition errors when handling probe, disconnect, and rebind operations can be exploited to trigger a use-after-free condition or a NULL pointer dereference by sending multiple USB over IP packets.",7.0,HIGH,2,test,,5
CVE-2018-5814,['CWE-362'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"usbip_host updates device status without holding lock from stub probe,
disconnect and rebind code paths. When multiple requests to import a
device are received, these unprotected code paths step all over each
other and drive fails with NULL-ptr deref and use-after-free errors.

The driver uses a table lock to protect the busid array for adding and
deleting busids to the table. However, the probe, disconnect and rebind
paths get the busid table entry and update the status without holding
the busid table lock. Add a new finer grain lock to protect the busid
entry. This new lock will be held to search and update the busid entry
fields from get_busid_idx(), add_match_busid() and del_match_busid().

match_busid_show() does the same to access the busid entry fields.

get_busid_priv() changed to return the pointer to the busid entry holding
the busid lock. stub_probe(), stub_disconnect() and stub_device_rebind()
call put_busid_priv() to release the busid lock before returning. This
changes fixes the unprotected code paths eliminating the race conditions
in updating the busid entries.

Reported-by: Jakub Jirasek
Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>
Cc: stable <stable@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
",22076557b07c12086eeb16b8ce2b0b735f7a27e7,https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/commit/?h=22076557b07c12086eeb16b8ce2b0b735f7a27e7,drivers/usb/usbip/stub_main.c,del_match_busid,"int del_match_busid(char *busid)
{
int idx;
int ret = -1;
spin_lock(&busid_table_lock);
idx = get_busid_idx(busid);
if (idx < 0)
goto out;
ret = 0;
if (busid_table[idx].status == STUB_BUSID_OTHER)
memset(busid_table[idx].name, 0, BUSID_SIZE);
if ((busid_table[idx].status != STUB_BUSID_OTHER) &&
(busid_table[idx].status != STUB_BUSID_ADDED))
busid_table[idx].status = STUB_BUSID_REMOV;
out:
spin_unlock(&busid_table_lock);
return ret;
}","int del_match_busid(char *VAR_0)
{
int VAR_1;
int VAR_2 = -1;
spin_lock(&VAR_3);
VAR_1 = get_busid_idx(VAR_0);
if (VAR_1 < 0)
goto out;
VAR_2 = 0;
if (VAR_4[VAR_1].status == VAR_5)
memset(VAR_4[VAR_1].name, 0, VAR_6);
if ((VAR_4[VAR_1].status != VAR_5) &&
(VAR_4[VAR_1].status != VAR_7))
VAR_4[VAR_1].status = VAR_8;
out:
spin_unlock(&VAR_3);
return VAR_2;
}",torvalds/linux/22076557b07c12086eeb16b8ce2b0b735f7a27e7/stub_main.c/vul/before/0.json,"int del_match_busid(char *busid)
{
	int idx;
	int ret = -1;

	spin_lock(&busid_table_lock);
	idx = get_busid_idx(busid);
	if (idx < 0)
		goto out;

	/* found */
	ret = 0;

	spin_lock(&busid_table[idx].busid_lock);

	if (busid_table[idx].status == STUB_BUSID_OTHER)
		memset(busid_table[idx].name, 0, BUSID_SIZE);

	if ((busid_table[idx].status != STUB_BUSID_OTHER) &&
	    (busid_table[idx].status != STUB_BUSID_ADDED))
		busid_table[idx].status = STUB_BUSID_REMOV;

	spin_unlock(&busid_table[idx].busid_lock);
out:
	spin_unlock(&busid_table_lock);

	return ret;
}","int del_match_busid(char *VAR_0)
{
	int VAR_1;
	int VAR_2 = -1;

	spin_lock(&VAR_3);
	VAR_1 = get_busid_idx(VAR_0);
	if (VAR_1 < 0)
		goto out;

	/* COMMENT_0 */
	VAR_2 = 0;

	spin_lock(&VAR_4[VAR_1].busid_lock);

	if (VAR_4[VAR_1].status == VAR_5)
		memset(VAR_4[VAR_1].name, 0, VAR_6);

	if ((VAR_4[VAR_1].status != VAR_5) &&
	    (VAR_4[VAR_1].status != VAR_7))
		VAR_4[VAR_1].status = VAR_8;

	spin_unlock(&VAR_4[VAR_1].busid_lock);
out:
	spin_unlock(&VAR_3);

	return VAR_2;
}",torvalds/linux/22076557b07c12086eeb16b8ce2b0b735f7a27e7/stub_main.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -11,6 +11,8 @@
 	/* found */
 	ret = 0;
 
+	spin_lock(&busid_table[idx].busid_lock);
+
 	if (busid_table[idx].status == STUB_BUSID_OTHER)
 		memset(busid_table[idx].name, 0, BUSID_SIZE);
 
@@ -18,6 +20,7 @@
 	    (busid_table[idx].status != STUB_BUSID_ADDED))
 		busid_table[idx].status = STUB_BUSID_REMOV;
 
+	spin_unlock(&busid_table[idx].busid_lock);
 out:
 	spin_unlock(&busid_table_lock);
 ","{'deleted_lines': [], 'added_lines': ['\tspin_lock(&busid_table[idx].busid_lock);', '', '\tspin_unlock(&busid_table[idx].busid_lock);']}",True,"In the Linux Kernel before version 4.16.11, 4.14.43, 4.9.102, and 4.4.133, multiple race condition errors when handling probe, disconnect, and rebind operations can be exploited to trigger a use-after-free condition or a NULL pointer dereference by sending multiple USB over IP packets.",7.0,HIGH,2,test,,5
CVE-2018-5814,['CWE-362'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"usbip_host updates device status without holding lock from stub probe,
disconnect and rebind code paths. When multiple requests to import a
device are received, these unprotected code paths step all over each
other and drive fails with NULL-ptr deref and use-after-free errors.

The driver uses a table lock to protect the busid array for adding and
deleting busids to the table. However, the probe, disconnect and rebind
paths get the busid table entry and update the status without holding
the busid table lock. Add a new finer grain lock to protect the busid
entry. This new lock will be held to search and update the busid entry
fields from get_busid_idx(), add_match_busid() and del_match_busid().

match_busid_show() does the same to access the busid entry fields.

get_busid_priv() changed to return the pointer to the busid entry holding
the busid lock. stub_probe(), stub_disconnect() and stub_device_rebind()
call put_busid_priv() to release the busid lock before returning. This
changes fixes the unprotected code paths eliminating the race conditions
in updating the busid entries.

Reported-by: Jakub Jirasek
Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>
Cc: stable <stable@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
",22076557b07c12086eeb16b8ce2b0b735f7a27e7,https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/commit/?h=22076557b07c12086eeb16b8ce2b0b735f7a27e7,drivers/usb/usbip/stub_main.c,stub_device_rebind,"static void stub_device_rebind(void)
{
#if IS_MODULE(CONFIG_USBIP_HOST)
struct bus_id_priv *busid_priv;
int i;
spin_lock(&busid_table_lock);
for (i = 0; i < MAX_BUSID; i++) {
if (busid_table[i].name[0] &&
busid_table[i].shutdown_busid) {
busid_priv = &(busid_table[i]);
busid_priv->status = STUB_BUSID_OTHER;
}
}
spin_unlock(&busid_table_lock);
for (i = 0; i < MAX_BUSID; i++) {
if (busid_table[i].name[0] &&
busid_table[i].shutdown_busid) {
busid_priv = &(busid_table[i]);
do_rebind(busid_table[i].name, busid_priv);
}
}
#endif
}","static void stub_device_rebind(void)
{
#if IS_MODULE(VAR_0)
struct bus_id_priv *VAR_1;
int VAR_2;
spin_lock(&VAR_3);
for (VAR_2 = 0; VAR_2 < VAR_4; VAR_2++) {
if (VAR_5[VAR_2].name[0] &&
VAR_5[VAR_2].shutdown_busid) {
VAR_1 = &(VAR_5[VAR_2]);
VAR_1->status = VAR_6;
}
}
spin_unlock(&VAR_3);
for (VAR_2 = 0; VAR_2 < VAR_4; VAR_2++) {
if (VAR_5[VAR_2].name[0] &&
VAR_5[VAR_2].shutdown_busid) {
VAR_1 = &(VAR_5[VAR_2]);
do_rebind(VAR_5[VAR_2].name, VAR_1);
}
}
#endif
}",torvalds/linux/22076557b07c12086eeb16b8ce2b0b735f7a27e7/stub_main.c/vul/before/1.json,"static void stub_device_rebind(void)
{
#if IS_MODULE(CONFIG_USBIP_HOST)
	struct bus_id_priv *busid_priv;
	int i;

	/* update status to STUB_BUSID_OTHER so probe ignores the device */
	spin_lock(&busid_table_lock);
	for (i = 0; i < MAX_BUSID; i++) {
		if (busid_table[i].name[0] &&
		    busid_table[i].shutdown_busid) {
			busid_priv = &(busid_table[i]);
			busid_priv->status = STUB_BUSID_OTHER;
		}
	}
	spin_unlock(&busid_table_lock);

	/* now run rebind - no need to hold locks. driver files are removed */
	for (i = 0; i < MAX_BUSID; i++) {
		if (busid_table[i].name[0] &&
		    busid_table[i].shutdown_busid) {
			busid_priv = &(busid_table[i]);
			do_rebind(busid_table[i].name, busid_priv);
		}
	}
#endif
}","static void stub_device_rebind(void)
{
#if IS_MODULE(VAR_0)
	struct bus_id_priv *VAR_1;
	int VAR_2;

	/* COMMENT_0 */
	spin_lock(&VAR_3);
	for (VAR_2 = 0; VAR_2 < VAR_4; VAR_2++) {
		if (VAR_5[VAR_2].name[0] &&
		    VAR_5[VAR_2].shutdown_busid) {
			VAR_1 = &(VAR_5[VAR_2]);
			VAR_1->status = VAR_6;
		}
	}
	spin_unlock(&VAR_3);

	/* COMMENT_1 */
	for (VAR_2 = 0; VAR_2 < VAR_4; VAR_2++) {
		if (VAR_5[VAR_2].name[0] &&
		    VAR_5[VAR_2].shutdown_busid) {
			VAR_1 = &(VAR_5[VAR_2]);
			do_rebind(VAR_5[VAR_2].name, VAR_1);
		}
	}
#endif
}",torvalds/linux/22076557b07c12086eeb16b8ce2b0b735f7a27e7/stub_main.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -15,7 +15,7 @@
 	}
 	spin_unlock(&busid_table_lock);
 
-	/* now run rebind */
+	/* now run rebind - no need to hold locks. driver files are removed */
 	for (i = 0; i < MAX_BUSID; i++) {
 		if (busid_table[i].name[0] &&
 		    busid_table[i].shutdown_busid) {","{'deleted_lines': ['\t/* now run rebind */'], 'added_lines': ['\t/* now run rebind - no need to hold locks. driver files are removed */']}",True,"In the Linux Kernel before version 4.16.11, 4.14.43, 4.9.102, and 4.4.133, multiple race condition errors when handling probe, disconnect, and rebind operations can be exploited to trigger a use-after-free condition or a NULL pointer dereference by sending multiple USB over IP packets.",7.0,HIGH,2,test,,5
CVE-2018-5814,['CWE-362'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"usbip_host updates device status without holding lock from stub probe,
disconnect and rebind code paths. When multiple requests to import a
device are received, these unprotected code paths step all over each
other and drive fails with NULL-ptr deref and use-after-free errors.

The driver uses a table lock to protect the busid array for adding and
deleting busids to the table. However, the probe, disconnect and rebind
paths get the busid table entry and update the status without holding
the busid table lock. Add a new finer grain lock to protect the busid
entry. This new lock will be held to search and update the busid entry
fields from get_busid_idx(), add_match_busid() and del_match_busid().

match_busid_show() does the same to access the busid entry fields.

get_busid_priv() changed to return the pointer to the busid entry holding
the busid lock. stub_probe(), stub_disconnect() and stub_device_rebind()
call put_busid_priv() to release the busid lock before returning. This
changes fixes the unprotected code paths eliminating the race conditions
in updating the busid entries.

Reported-by: Jakub Jirasek
Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>
Cc: stable <stable@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
",22076557b07c12086eeb16b8ce2b0b735f7a27e7,https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/commit/?h=22076557b07c12086eeb16b8ce2b0b735f7a27e7,drivers/usb/usbip/stub_main.c,init_busid_table,"static void init_busid_table(void)
{
memset(busid_table, 0, sizeof(busid_table));
spin_lock_init(&busid_table_lock);
}","static void init_busid_table(void)
{
memset(VAR_0, 0, sizeof(VAR_0));
spin_lock_init(&VAR_1);
}",torvalds/linux/22076557b07c12086eeb16b8ce2b0b735f7a27e7/stub_main.c/vul/before/2.json,"static void init_busid_table(void)
{
	int i;

	/*
	 * This also sets the bus_table[i].status to
	 * STUB_BUSID_OTHER, which is 0.
	 */
	memset(busid_table, 0, sizeof(busid_table));

	spin_lock_init(&busid_table_lock);

	for (i = 0; i < MAX_BUSID; i++)
		spin_lock_init(&busid_table[i].busid_lock);
}","static void init_busid_table(void)
{
	int VAR_0;

	/* COMMENT_0 */
                                             
                                 
    
	memset(VAR_1, 0, sizeof(VAR_1));

	spin_lock_init(&VAR_2);

	for (VAR_0 = 0; VAR_0 < VAR_3; VAR_0++)
		spin_lock_init(&VAR_1[VAR_0].busid_lock);
}",torvalds/linux/22076557b07c12086eeb16b8ce2b0b735f7a27e7/stub_main.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -1,5 +1,7 @@
 static void init_busid_table(void)
 {
+	int i;
+
 	/*
 	 * This also sets the bus_table[i].status to
 	 * STUB_BUSID_OTHER, which is 0.
@@ -7,4 +9,7 @@
 	memset(busid_table, 0, sizeof(busid_table));
 
 	spin_lock_init(&busid_table_lock);
+
+	for (i = 0; i < MAX_BUSID; i++)
+		spin_lock_init(&busid_table[i].busid_lock);
 }","{'deleted_lines': [], 'added_lines': ['\tint i;', '', '', '\tfor (i = 0; i < MAX_BUSID; i++)', '\t\tspin_lock_init(&busid_table[i].busid_lock);']}",True,"In the Linux Kernel before version 4.16.11, 4.14.43, 4.9.102, and 4.4.133, multiple race condition errors when handling probe, disconnect, and rebind operations can be exploited to trigger a use-after-free condition or a NULL pointer dereference by sending multiple USB over IP packets.",7.0,HIGH,2,test,,5
CVE-2018-5814,['CWE-362'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"usbip_host updates device status without holding lock from stub probe,
disconnect and rebind code paths. When multiple requests to import a
device are received, these unprotected code paths step all over each
other and drive fails with NULL-ptr deref and use-after-free errors.

The driver uses a table lock to protect the busid array for adding and
deleting busids to the table. However, the probe, disconnect and rebind
paths get the busid table entry and update the status without holding
the busid table lock. Add a new finer grain lock to protect the busid
entry. This new lock will be held to search and update the busid entry
fields from get_busid_idx(), add_match_busid() and del_match_busid().

match_busid_show() does the same to access the busid entry fields.

get_busid_priv() changed to return the pointer to the busid entry holding
the busid lock. stub_probe(), stub_disconnect() and stub_device_rebind()
call put_busid_priv() to release the busid lock before returning. This
changes fixes the unprotected code paths eliminating the race conditions
in updating the busid entries.

Reported-by: Jakub Jirasek
Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>
Cc: stable <stable@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
",22076557b07c12086eeb16b8ce2b0b735f7a27e7,https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/commit/?h=22076557b07c12086eeb16b8ce2b0b735f7a27e7,drivers/usb/usbip/stub_main.c,add_match_busid,"static int add_match_busid(char *busid)
{
int i;
int ret = -1;
spin_lock(&busid_table_lock);
if (get_busid_idx(busid) >= 0) {
ret = 0;
goto out;
}
for (i = 0; i < MAX_BUSID; i++)
if (!busid_table[i].name[0]) {
strlcpy(busid_table[i].name, busid, BUSID_SIZE);
if ((busid_table[i].status != STUB_BUSID_ALLOC) &&
(busid_table[i].status != STUB_BUSID_REMOV))
busid_table[i].status = STUB_BUSID_ADDED;
ret = 0;
break;
}
out:
spin_unlock(&busid_table_lock);
return ret;
}","static int add_match_busid(char *VAR_0)
{
int VAR_1;
int VAR_2 = -1;
spin_lock(&VAR_3);
if (get_busid_idx(VAR_0) >= 0) {
VAR_2 = 0;
goto out;
}
for (VAR_1 = 0; VAR_1 < VAR_4; VAR_1++)
if (!VAR_5[VAR_1].name[0]) {
strlcpy(VAR_5[VAR_1].name, VAR_0, VAR_6);
if ((VAR_5[VAR_1].status != VAR_7) &&
(VAR_5[VAR_1].status != VAR_8))
VAR_5[VAR_1].status = VAR_9;
VAR_2 = 0;
break;
}
out:
spin_unlock(&VAR_3);
return VAR_2;
}",torvalds/linux/22076557b07c12086eeb16b8ce2b0b735f7a27e7/stub_main.c/vul/before/3.json,"static int add_match_busid(char *busid)
{
	int i;
	int ret = -1;

	spin_lock(&busid_table_lock);
	/* already registered? */
	if (get_busid_idx(busid) >= 0) {
		ret = 0;
		goto out;
	}

	for (i = 0; i < MAX_BUSID; i++) {
		spin_lock(&busid_table[i].busid_lock);
		if (!busid_table[i].name[0]) {
			strlcpy(busid_table[i].name, busid, BUSID_SIZE);
			if ((busid_table[i].status != STUB_BUSID_ALLOC) &&
			    (busid_table[i].status != STUB_BUSID_REMOV))
				busid_table[i].status = STUB_BUSID_ADDED;
			ret = 0;
			spin_unlock(&busid_table[i].busid_lock);
			break;
		}
		spin_unlock(&busid_table[i].busid_lock);
	}

out:
	spin_unlock(&busid_table_lock);

	return ret;
}","static int add_match_busid(char *VAR_0)
{
	int VAR_1;
	int VAR_2 = -1;

	spin_lock(&VAR_3);
	/* COMMENT_0 */
	if (get_busid_idx(VAR_0) >= 0) {
		VAR_2 = 0;
		goto out;
	}

	for (VAR_1 = 0; VAR_1 < VAR_4; VAR_1++) {
		spin_lock(&VAR_5[VAR_1].busid_lock);
		if (!VAR_5[VAR_1].name[0]) {
			strlcpy(VAR_5[VAR_1].name, VAR_0, VAR_6);
			if ((VAR_5[VAR_1].status != VAR_7) &&
			    (VAR_5[VAR_1].status != VAR_8))
				VAR_5[VAR_1].status = VAR_9;
			VAR_2 = 0;
			spin_unlock(&VAR_5[VAR_1].busid_lock);
			break;
		}
		spin_unlock(&VAR_5[VAR_1].busid_lock);
	}

out:
	spin_unlock(&VAR_3);

	return VAR_2;
}",torvalds/linux/22076557b07c12086eeb16b8ce2b0b735f7a27e7/stub_main.c/vul/after/3.json,"--- func_before
+++ func_after
@@ -10,15 +10,19 @@
 		goto out;
 	}
 
-	for (i = 0; i < MAX_BUSID; i++)
+	for (i = 0; i < MAX_BUSID; i++) {
+		spin_lock(&busid_table[i].busid_lock);
 		if (!busid_table[i].name[0]) {
 			strlcpy(busid_table[i].name, busid, BUSID_SIZE);
 			if ((busid_table[i].status != STUB_BUSID_ALLOC) &&
 			    (busid_table[i].status != STUB_BUSID_REMOV))
 				busid_table[i].status = STUB_BUSID_ADDED;
 			ret = 0;
+			spin_unlock(&busid_table[i].busid_lock);
 			break;
 		}
+		spin_unlock(&busid_table[i].busid_lock);
+	}
 
 out:
 	spin_unlock(&busid_table_lock);","{'deleted_lines': ['\tfor (i = 0; i < MAX_BUSID; i++)'], 'added_lines': ['\tfor (i = 0; i < MAX_BUSID; i++) {', '\t\tspin_lock(&busid_table[i].busid_lock);', '\t\t\tspin_unlock(&busid_table[i].busid_lock);', '\t\tspin_unlock(&busid_table[i].busid_lock);', '\t}']}",True,"In the Linux Kernel before version 4.16.11, 4.14.43, 4.9.102, and 4.4.133, multiple race condition errors when handling probe, disconnect, and rebind operations can be exploited to trigger a use-after-free condition or a NULL pointer dereference by sending multiple USB over IP packets.",7.0,HIGH,2,test,,5
CVE-2018-5814,['CWE-362'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"usbip_host updates device status without holding lock from stub probe,
disconnect and rebind code paths. When multiple requests to import a
device are received, these unprotected code paths step all over each
other and drive fails with NULL-ptr deref and use-after-free errors.

The driver uses a table lock to protect the busid array for adding and
deleting busids to the table. However, the probe, disconnect and rebind
paths get the busid table entry and update the status without holding
the busid table lock. Add a new finer grain lock to protect the busid
entry. This new lock will be held to search and update the busid entry
fields from get_busid_idx(), add_match_busid() and del_match_busid().

match_busid_show() does the same to access the busid entry fields.

get_busid_priv() changed to return the pointer to the busid entry holding
the busid lock. stub_probe(), stub_disconnect() and stub_device_rebind()
call put_busid_priv() to release the busid lock before returning. This
changes fixes the unprotected code paths eliminating the race conditions
in updating the busid entries.

Reported-by: Jakub Jirasek
Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>
Cc: stable <stable@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
",22076557b07c12086eeb16b8ce2b0b735f7a27e7,https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/commit/?h=22076557b07c12086eeb16b8ce2b0b735f7a27e7,drivers/usb/usbip/stub_main.c,rebind_store,"static ssize_t rebind_store(struct device_driver *dev, const char *buf,
size_t count)
{
int ret;
int len;
struct bus_id_priv *bid;
len = strnlen(buf, BUSID_SIZE);
if (!(len < BUSID_SIZE))
return -EINVAL;
bid = get_busid_priv(buf);
if (!bid)
return -ENODEV;
bid->status = STUB_BUSID_OTHER;
ret = do_rebind((char *) buf, bid);
if (ret < 0)
return ret;
del_match_busid((char *) buf);
return count;
}","static ssize_t rebind_store(struct device_driver *VAR_0, const char *VAR_1,
size_t VAR_2)
{
int VAR_3;
int VAR_4;
struct bus_id_priv *VAR_5;
VAR_4 = strnlen(VAR_1, VAR_6);
if (!(VAR_4 < VAR_6))
return -VAR_7;
VAR_5 = get_busid_priv(VAR_1);
if (!VAR_5)
return -VAR_8;
VAR_5->status = VAR_9;
VAR_3 = do_rebind((char *) VAR_1, VAR_5);
if (VAR_3 < 0)
return VAR_3;
del_match_busid((char *) VAR_1);
return VAR_2;
}",torvalds/linux/22076557b07c12086eeb16b8ce2b0b735f7a27e7/stub_main.c/vul/before/4.json,"static ssize_t rebind_store(struct device_driver *dev, const char *buf,
				 size_t count)
{
	int ret;
	int len;
	struct bus_id_priv *bid;

	/* buf length should be less that BUSID_SIZE */
	len = strnlen(buf, BUSID_SIZE);

	if (!(len < BUSID_SIZE))
		return -EINVAL;

	bid = get_busid_priv(buf);
	if (!bid)
		return -ENODEV;

	/* mark the device for deletion so probe ignores it during rescan */
	bid->status = STUB_BUSID_OTHER;
	/* release the busid lock */
	put_busid_priv(bid);

	ret = do_rebind((char *) buf, bid);
	if (ret < 0)
		return ret;

	/* delete device from busid_table */
	del_match_busid((char *) buf);

	return count;
}","static ssize_t rebind_store(struct device_driver *VAR_0, const char *VAR_1,
				 size_t VAR_2)
{
	int VAR_3;
	int VAR_4;
	struct bus_id_priv *VAR_5;

	/* COMMENT_0 */
	VAR_4 = strnlen(VAR_1, VAR_6);

	if (!(VAR_4 < VAR_6))
		return -VAR_7;

	VAR_5 = get_busid_priv(VAR_1);
	if (!VAR_5)
		return -VAR_8;

	/* COMMENT_1 */
	VAR_5->status = VAR_9;
	/* COMMENT_2 */
	put_busid_priv(VAR_5);

	VAR_3 = do_rebind((char *) VAR_1, VAR_5);
	if (VAR_3 < 0)
		return VAR_3;

	/* COMMENT_3 */
	del_match_busid((char *) VAR_1);

	return VAR_2;
}",torvalds/linux/22076557b07c12086eeb16b8ce2b0b735f7a27e7/stub_main.c/vul/after/4.json,"--- func_before
+++ func_after
@@ -17,6 +17,8 @@
 
 	/* mark the device for deletion so probe ignores it during rescan */
 	bid->status = STUB_BUSID_OTHER;
+	/* release the busid lock */
+	put_busid_priv(bid);
 
 	ret = do_rebind((char *) buf, bid);
 	if (ret < 0)","{'deleted_lines': [], 'added_lines': ['\t/* release the busid lock */', '\tput_busid_priv(bid);']}",True,"In the Linux Kernel before version 4.16.11, 4.14.43, 4.9.102, and 4.4.133, multiple race condition errors when handling probe, disconnect, and rebind operations can be exploited to trigger a use-after-free condition or a NULL pointer dereference by sending multiple USB over IP packets.",7.0,HIGH,2,test,,5
CVE-2018-5814,['CWE-362'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"usbip_host updates device status without holding lock from stub probe,
disconnect and rebind code paths. When multiple requests to import a
device are received, these unprotected code paths step all over each
other and drive fails with NULL-ptr deref and use-after-free errors.

The driver uses a table lock to protect the busid array for adding and
deleting busids to the table. However, the probe, disconnect and rebind
paths get the busid table entry and update the status without holding
the busid table lock. Add a new finer grain lock to protect the busid
entry. This new lock will be held to search and update the busid entry
fields from get_busid_idx(), add_match_busid() and del_match_busid().

match_busid_show() does the same to access the busid entry fields.

get_busid_priv() changed to return the pointer to the busid entry holding
the busid lock. stub_probe(), stub_disconnect() and stub_device_rebind()
call put_busid_priv() to release the busid lock before returning. This
changes fixes the unprotected code paths eliminating the race conditions
in updating the busid entries.

Reported-by: Jakub Jirasek
Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>
Cc: stable <stable@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
",22076557b07c12086eeb16b8ce2b0b735f7a27e7,https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/commit/?h=22076557b07c12086eeb16b8ce2b0b735f7a27e7,drivers/usb/usbip/stub_main.c,match_busid_show,"static ssize_t match_busid_show(struct device_driver *drv, char *buf)
{
int i;
char *out = buf;
spin_lock(&busid_table_lock);
for (i = 0; i < MAX_BUSID; i++)
if (busid_table[i].name[0])
out += sprintf(out, ""%s "", busid_table[i].name);
spin_unlock(&busid_table_lock);
out += sprintf(out, ""\n"");
return out - buf;
}","static ssize_t match_busid_show(struct device_driver *VAR_0, char *VAR_1)
{
int VAR_2;
char *VAR_3 = VAR_1;
spin_lock(&VAR_4);
for (VAR_2 = 0; VAR_2 < VAR_5; VAR_2++)
if (VAR_6[VAR_2].name[0])
VAR_3 += sprintf(VAR_3, ""%s "", VAR_6[VAR_2].name);
spin_unlock(&VAR_4);
VAR_3 += sprintf(VAR_3, ""\n"");
return VAR_3 - VAR_1;
}",torvalds/linux/22076557b07c12086eeb16b8ce2b0b735f7a27e7/stub_main.c/vul/before/5.json,"static ssize_t match_busid_show(struct device_driver *drv, char *buf)
{
	int i;
	char *out = buf;

	spin_lock(&busid_table_lock);
	for (i = 0; i < MAX_BUSID; i++) {
		spin_lock(&busid_table[i].busid_lock);
		if (busid_table[i].name[0])
			out += sprintf(out, ""%s "", busid_table[i].name);
		spin_unlock(&busid_table[i].busid_lock);
	}
	spin_unlock(&busid_table_lock);
	out += sprintf(out, ""\n"");

	return out - buf;
}","static ssize_t match_busid_show(struct device_driver *VAR_0, char *VAR_1)
{
	int VAR_2;
	char *VAR_3 = VAR_1;

	spin_lock(&VAR_4);
	for (VAR_2 = 0; VAR_2 < VAR_5; VAR_2++) {
		spin_lock(&VAR_6[VAR_2].busid_lock);
		if (VAR_6[VAR_2].name[0])
			VAR_3 += sprintf(VAR_3, ""%s "", VAR_6[VAR_2].name);
		spin_unlock(&VAR_6[VAR_2].busid_lock);
	}
	spin_unlock(&VAR_4);
	VAR_3 += sprintf(VAR_3, ""\n"");

	return VAR_3 - VAR_1;
}",torvalds/linux/22076557b07c12086eeb16b8ce2b0b735f7a27e7/stub_main.c/vul/after/5.json,"--- func_before
+++ func_after
@@ -4,9 +4,12 @@
 	char *out = buf;
 
 	spin_lock(&busid_table_lock);
-	for (i = 0; i < MAX_BUSID; i++)
+	for (i = 0; i < MAX_BUSID; i++) {
+		spin_lock(&busid_table[i].busid_lock);
 		if (busid_table[i].name[0])
 			out += sprintf(out, ""%s "", busid_table[i].name);
+		spin_unlock(&busid_table[i].busid_lock);
+	}
 	spin_unlock(&busid_table_lock);
 	out += sprintf(out, ""\n"");
 ","{'deleted_lines': ['\tfor (i = 0; i < MAX_BUSID; i++)'], 'added_lines': ['\tfor (i = 0; i < MAX_BUSID; i++) {', '\t\tspin_lock(&busid_table[i].busid_lock);', '\t\tspin_unlock(&busid_table[i].busid_lock);', '\t}']}",True,"In the Linux Kernel before version 4.16.11, 4.14.43, 4.9.102, and 4.4.133, multiple race condition errors when handling probe, disconnect, and rebind operations can be exploited to trigger a use-after-free condition or a NULL pointer dereference by sending multiple USB over IP packets.",7.0,HIGH,2,test,,5
CVE-2018-5814,['CWE-362'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"usbip_host updates device status without holding lock from stub probe,
disconnect and rebind code paths. When multiple requests to import a
device are received, these unprotected code paths step all over each
other and drive fails with NULL-ptr deref and use-after-free errors.

The driver uses a table lock to protect the busid array for adding and
deleting busids to the table. However, the probe, disconnect and rebind
paths get the busid table entry and update the status without holding
the busid table lock. Add a new finer grain lock to protect the busid
entry. This new lock will be held to search and update the busid entry
fields from get_busid_idx(), add_match_busid() and del_match_busid().

match_busid_show() does the same to access the busid entry fields.

get_busid_priv() changed to return the pointer to the busid entry holding
the busid lock. stub_probe(), stub_disconnect() and stub_device_rebind()
call put_busid_priv() to release the busid lock before returning. This
changes fixes the unprotected code paths eliminating the race conditions
in updating the busid entries.

Reported-by: Jakub Jirasek
Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>
Cc: stable <stable@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
",22076557b07c12086eeb16b8ce2b0b735f7a27e7,https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/commit/?h=22076557b07c12086eeb16b8ce2b0b735f7a27e7,drivers/usb/usbip/stub_main.c,get_busid_priv,"struct bus_id_priv *get_busid_priv(const char *busid)
{
int idx;
struct bus_id_priv *bid = NULL;
spin_lock(&busid_table_lock);
idx = get_busid_idx(busid);
if (idx >= 0)
bid = &(busid_table[idx]);
spin_unlock(&busid_table_lock);
return bid;
}","struct bus_id_priv *get_busid_priv(const char *VAR_0)
{
int VAR_1;
struct bus_id_priv *VAR_2 = NULL;
spin_lock(&VAR_3);
VAR_1 = get_busid_idx(VAR_0);
if (VAR_1 >= 0)
VAR_2 = &(VAR_4[VAR_1]);
spin_unlock(&VAR_3);
return VAR_2;
}",torvalds/linux/22076557b07c12086eeb16b8ce2b0b735f7a27e7/stub_main.c/vul/before/6.json,"struct bus_id_priv *get_busid_priv(const char *busid)
{
	int idx;
	struct bus_id_priv *bid = NULL;

	spin_lock(&busid_table_lock);
	idx = get_busid_idx(busid);
	if (idx >= 0) {
		bid = &(busid_table[idx]);
		/* get busid_lock before returning */
		spin_lock(&bid->busid_lock);
	}
	spin_unlock(&busid_table_lock);

	return bid;
}","struct bus_id_priv *get_busid_priv(const char *VAR_0)
{
	int VAR_1;
	struct bus_id_priv *VAR_2 = NULL;

	spin_lock(&VAR_3);
	VAR_1 = get_busid_idx(VAR_0);
	if (VAR_1 >= 0) {
		VAR_2 = &(VAR_4[VAR_1]);
		/* COMMENT_0 */
		spin_lock(&VAR_2->busid_lock);
	}
	spin_unlock(&VAR_3);

	return VAR_2;
}",torvalds/linux/22076557b07c12086eeb16b8ce2b0b735f7a27e7/stub_main.c/vul/after/6.json,"--- func_before
+++ func_after
@@ -5,8 +5,11 @@
 
 	spin_lock(&busid_table_lock);
 	idx = get_busid_idx(busid);
-	if (idx >= 0)
+	if (idx >= 0) {
 		bid = &(busid_table[idx]);
+		/* get busid_lock before returning */
+		spin_lock(&bid->busid_lock);
+	}
 	spin_unlock(&busid_table_lock);
 
 	return bid;","{'deleted_lines': ['\tif (idx >= 0)'], 'added_lines': ['\tif (idx >= 0) {', '\t\t/* get busid_lock before returning */', '\t\tspin_lock(&bid->busid_lock);', '\t}']}",True,"In the Linux Kernel before version 4.16.11, 4.14.43, 4.9.102, and 4.4.133, multiple race condition errors when handling probe, disconnect, and rebind operations can be exploited to trigger a use-after-free condition or a NULL pointer dereference by sending multiple USB over IP packets.",7.0,HIGH,2,test,,5
CVE-2018-5814,['CWE-362'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"usbip_host updates device status without holding lock from stub probe,
disconnect and rebind code paths. When multiple requests to import a
device are received, these unprotected code paths step all over each
other and drive fails with NULL-ptr deref and use-after-free errors.

The driver uses a table lock to protect the busid array for adding and
deleting busids to the table. However, the probe, disconnect and rebind
paths get the busid table entry and update the status without holding
the busid table lock. Add a new finer grain lock to protect the busid
entry. This new lock will be held to search and update the busid entry
fields from get_busid_idx(), add_match_busid() and del_match_busid().

match_busid_show() does the same to access the busid entry fields.

get_busid_priv() changed to return the pointer to the busid entry holding
the busid lock. stub_probe(), stub_disconnect() and stub_device_rebind()
call put_busid_priv() to release the busid lock before returning. This
changes fixes the unprotected code paths eliminating the race conditions
in updating the busid entries.

Reported-by: Jakub Jirasek
Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>
Cc: stable <stable@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
",22076557b07c12086eeb16b8ce2b0b735f7a27e7,https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/commit/?h=22076557b07c12086eeb16b8ce2b0b735f7a27e7,drivers/usb/usbip/stub_main.c,get_busid_idx,"static int get_busid_idx(const char *busid)
{
int i;
int idx = -1;
for (i = 0; i < MAX_BUSID; i++)
if (busid_table[i].name[0])
if (!strncmp(busid_table[i].name, busid, BUSID_SIZE)) {
idx = i;
break;
}
return idx;
}","static int get_busid_idx(const char *VAR_0)
{
int VAR_1;
int VAR_2 = -1;
for (VAR_1 = 0; VAR_1 < VAR_3; VAR_1++)
if (VAR_4[VAR_1].name[0])
if (!strncmp(VAR_4[VAR_1].name, VAR_0, VAR_5)) {
VAR_2 = VAR_1;
break;
}
return VAR_2;
}",torvalds/linux/22076557b07c12086eeb16b8ce2b0b735f7a27e7/stub_main.c/vul/before/7.json,"static int get_busid_idx(const char *busid)
{
	int i;
	int idx = -1;

	for (i = 0; i < MAX_BUSID; i++) {
		spin_lock(&busid_table[i].busid_lock);
		if (busid_table[i].name[0])
			if (!strncmp(busid_table[i].name, busid, BUSID_SIZE)) {
				idx = i;
				spin_unlock(&busid_table[i].busid_lock);
				break;
			}
		spin_unlock(&busid_table[i].busid_lock);
	}
	return idx;
}","static int get_busid_idx(const char *VAR_0)
{
	int VAR_1;
	int VAR_2 = -1;

	for (VAR_1 = 0; VAR_1 < VAR_3; VAR_1++) {
		spin_lock(&VAR_4[VAR_1].busid_lock);
		if (VAR_4[VAR_1].name[0])
			if (!strncmp(VAR_4[VAR_1].name, VAR_0, VAR_5)) {
				VAR_2 = VAR_1;
				spin_unlock(&VAR_4[VAR_1].busid_lock);
				break;
			}
		spin_unlock(&VAR_4[VAR_1].busid_lock);
	}
	return VAR_2;
}",torvalds/linux/22076557b07c12086eeb16b8ce2b0b735f7a27e7/stub_main.c/vul/after/7.json,"--- func_before
+++ func_after
@@ -3,11 +3,15 @@
 	int i;
 	int idx = -1;
 
-	for (i = 0; i < MAX_BUSID; i++)
+	for (i = 0; i < MAX_BUSID; i++) {
+		spin_lock(&busid_table[i].busid_lock);
 		if (busid_table[i].name[0])
 			if (!strncmp(busid_table[i].name, busid, BUSID_SIZE)) {
 				idx = i;
+				spin_unlock(&busid_table[i].busid_lock);
 				break;
 			}
+		spin_unlock(&busid_table[i].busid_lock);
+	}
 	return idx;
 }","{'deleted_lines': ['\tfor (i = 0; i < MAX_BUSID; i++)'], 'added_lines': ['\tfor (i = 0; i < MAX_BUSID; i++) {', '\t\tspin_lock(&busid_table[i].busid_lock);', '\t\t\t\tspin_unlock(&busid_table[i].busid_lock);', '\t\tspin_unlock(&busid_table[i].busid_lock);', '\t}']}",True,"In the Linux Kernel before version 4.16.11, 4.14.43, 4.9.102, and 4.4.133, multiple race condition errors when handling probe, disconnect, and rebind operations can be exploited to trigger a use-after-free condition or a NULL pointer dereference by sending multiple USB over IP packets.",7.0,HIGH,2,test,,5
CVE-2018-5814,['CWE-362'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"usbip_host updates device status without holding lock from stub probe,
disconnect and rebind code paths. When multiple requests to import a
device are received, these unprotected code paths step all over each
other and drive fails with NULL-ptr deref and use-after-free errors.

The driver uses a table lock to protect the busid array for adding and
deleting busids to the table. However, the probe, disconnect and rebind
paths get the busid table entry and update the status without holding
the busid table lock. Add a new finer grain lock to protect the busid
entry. This new lock will be held to search and update the busid entry
fields from get_busid_idx(), add_match_busid() and del_match_busid().

match_busid_show() does the same to access the busid entry fields.

get_busid_priv() changed to return the pointer to the busid entry holding
the busid lock. stub_probe(), stub_disconnect() and stub_device_rebind()
call put_busid_priv() to release the busid lock before returning. This
changes fixes the unprotected code paths eliminating the race conditions
in updating the busid entries.

Reported-by: Jakub Jirasek
Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>
Cc: stable <stable@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
",22076557b07c12086eeb16b8ce2b0b735f7a27e7,https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/commit/?h=22076557b07c12086eeb16b8ce2b0b735f7a27e7,drivers/usb/usbip/stub_dev.c,stub_probe,"static int stub_probe(struct usb_device *udev)
{
struct stub_device *sdev = NULL;
const char *udev_busid = dev_name(&udev->dev);
struct bus_id_priv *busid_priv;
int rc;
dev_dbg(&udev->dev, ""Enter probe\n"");
busid_priv = get_busid_priv(udev_busid);
if (!busid_priv || (busid_priv->status == STUB_BUSID_REMOV) ||
(busid_priv->status == STUB_BUSID_OTHER)) {
dev_info(&udev->dev,
""%s is not in match_busid table... skip!\n"",
udev_busid);
return -ENODEV;
}
if (udev->descriptor.bDeviceClass == USB_CLASS_HUB) {
dev_dbg(&udev->dev, ""%s is a usb hub device... skip!\n"",
udev_busid);
return -ENODEV;
}
if (!strcmp(udev->bus->bus_name, ""vhci_hcd"")) {
dev_dbg(&udev->dev,
""%s is attached on vhci_hcd... skip!\n"",
udev_busid);
return -ENODEV;
}
sdev = stub_device_alloc(udev);
if (!sdev)
return -ENOMEM;
dev_info(&udev->dev,
""usbip-host: register new device (bus %u dev %u)\n"",
udev->bus->busnum, udev->devnum);
busid_priv->shutdown_busid = 0;
dev_set_drvdata(&udev->dev, sdev);
busid_priv->sdev = sdev;
busid_priv->udev = udev;
rc = usb_hub_claim_port(udev->parent, udev->portnum,
(struct usb_dev_state *) udev);
if (rc) {
dev_dbg(&udev->dev, ""unable to claim port\n"");
goto err_port;
}
rc = stub_add_files(&udev->dev);
if (rc) {
dev_err(&udev->dev, ""stub_add_files for %s\n"", udev_busid);
goto err_files;
}
busid_priv->status = STUB_BUSID_ALLOC;
return 0;
err_files:
usb_hub_release_port(udev->parent, udev->portnum,
(struct usb_dev_state *) udev);
err_port:
dev_set_drvdata(&udev->dev, NULL);
usb_put_dev(udev);
busid_priv->sdev = NULL;
stub_device_free(sdev);
return rc;
}","static int stub_probe(struct usb_device *VAR_0)
{
struct stub_device *VAR_1 = NULL;
const char *VAR_2 = dev_name(&VAR_0->dev);
struct bus_id_priv *VAR_3;
int VAR_4;
dev_dbg(&VAR_0->dev, ""Enter probe\n"");
VAR_3 = get_busid_priv(VAR_2);
if (!VAR_3 || (VAR_3->status == VAR_5) ||
(VAR_3->status == VAR_6)) {
dev_info(&VAR_0->dev,
""%s is not in match_busid table... skip!\n"",
VAR_2);
return -VAR_7;
}
if (VAR_0->descriptor.bDeviceClass == VAR_8) {
dev_dbg(&VAR_0->dev, ""%s is a usb hub device... skip!\n"",
VAR_2);
return -VAR_7;
}
if (!strcmp(VAR_0->bus->bus_name, ""vhci_hcd"")) {
dev_dbg(&VAR_0->dev,
""%s is attached on vhci_hcd... skip!\n"",
VAR_2);
return -VAR_7;
}
VAR_1 = stub_device_alloc(VAR_0);
if (!VAR_1)
return -VAR_9;
dev_info(&VAR_0->dev,
""usbip-host: register new device (bus %u dev %u)\n"",
VAR_0->bus->busnum, VAR_0->devnum);
VAR_3->shutdown_busid = 0;
dev_set_drvdata(&VAR_0->dev, VAR_1);
VAR_3->sdev = VAR_1;
VAR_3->udev = VAR_0;
VAR_4 = usb_hub_claim_port(VAR_0->parent, VAR_0->portnum,
(struct usb_dev_state *) VAR_0);
if (VAR_4) {
dev_dbg(&VAR_0->dev, ""unable to claim port\n"");
goto err_port;
}
VAR_4 = stub_add_files(&VAR_0->dev);
if (VAR_4) {
dev_err(&VAR_0->dev, ""stub_add_files for %s\n"", VAR_2);
goto err_files;
}
VAR_3->status = VAR_10;
return 0;
err_files:
usb_hub_release_port(VAR_0->parent, VAR_0->portnum,
(struct usb_dev_state *) VAR_0);
err_port:
dev_set_drvdata(&VAR_0->dev, NULL);
usb_put_dev(VAR_0);
VAR_3->sdev = NULL;
stub_device_free(VAR_1);
return VAR_4;
}",torvalds/linux/22076557b07c12086eeb16b8ce2b0b735f7a27e7/stub_dev.c/vul/before/0.json,"static int stub_probe(struct usb_device *udev)
{
	struct stub_device *sdev = NULL;
	const char *udev_busid = dev_name(&udev->dev);
	struct bus_id_priv *busid_priv;
	int rc = 0;

	dev_dbg(&udev->dev, ""Enter probe\n"");

	/* check we should claim or not by busid_table */
	busid_priv = get_busid_priv(udev_busid);
	if (!busid_priv || (busid_priv->status == STUB_BUSID_REMOV) ||
	    (busid_priv->status == STUB_BUSID_OTHER)) {
		dev_info(&udev->dev,
			""%s is not in match_busid table... skip!\n"",
			udev_busid);

		/*
		 * Return value should be ENODEV or ENOXIO to continue trying
		 * other matched drivers by the driver core.
		 * See driver_probe_device() in driver/base/dd.c
		 */
		rc = -ENODEV;
		goto call_put_busid_priv;
	}

	if (udev->descriptor.bDeviceClass == USB_CLASS_HUB) {
		dev_dbg(&udev->dev, ""%s is a usb hub device... skip!\n"",
			 udev_busid);
		rc = -ENODEV;
		goto call_put_busid_priv;
	}

	if (!strcmp(udev->bus->bus_name, ""vhci_hcd"")) {
		dev_dbg(&udev->dev,
			""%s is attached on vhci_hcd... skip!\n"",
			udev_busid);

		rc = -ENODEV;
		goto call_put_busid_priv;
	}

	/* ok, this is my device */
	sdev = stub_device_alloc(udev);
	if (!sdev) {
		rc = -ENOMEM;
		goto call_put_busid_priv;
	}

	dev_info(&udev->dev,
		""usbip-host: register new device (bus %u dev %u)\n"",
		udev->bus->busnum, udev->devnum);

	busid_priv->shutdown_busid = 0;

	/* set private data to usb_device */
	dev_set_drvdata(&udev->dev, sdev);
	busid_priv->sdev = sdev;
	busid_priv->udev = udev;

	/*
	 * Claim this hub port.
	 * It doesn't matter what value we pass as owner
	 * (struct dev_state) as long as it is unique.
	 */
	rc = usb_hub_claim_port(udev->parent, udev->portnum,
			(struct usb_dev_state *) udev);
	if (rc) {
		dev_dbg(&udev->dev, ""unable to claim port\n"");
		goto err_port;
	}

	rc = stub_add_files(&udev->dev);
	if (rc) {
		dev_err(&udev->dev, ""stub_add_files for %s\n"", udev_busid);
		goto err_files;
	}
	busid_priv->status = STUB_BUSID_ALLOC;

	rc = 0;
	goto call_put_busid_priv;

err_files:
	usb_hub_release_port(udev->parent, udev->portnum,
			     (struct usb_dev_state *) udev);
err_port:
	dev_set_drvdata(&udev->dev, NULL);
	usb_put_dev(udev);

	busid_priv->sdev = NULL;
	stub_device_free(sdev);

call_put_busid_priv:
	put_busid_priv(busid_priv);
	return rc;
}","static int stub_probe(struct usb_device *VAR_0)
{
	struct stub_device *VAR_1 = NULL;
	const char *VAR_2 = dev_name(&VAR_0->dev);
	struct bus_id_priv *VAR_3;
	int VAR_4 = 0;

	dev_dbg(&VAR_0->dev, ""Enter probe\n"");

	/* COMMENT_0 */
	VAR_3 = get_busid_priv(VAR_2);
	if (!VAR_3 || (VAR_3->status == VAR_5) ||
	    (VAR_3->status == VAR_6)) {
		dev_info(&VAR_0->dev,
			""%s is not in match_busid table... skip!\n"",
			VAR_2);

		/* COMMENT_1 */
                                                               
                                              
                                                  
     
		VAR_4 = -VAR_7;
		goto call_put_busid_priv;
	}

	if (VAR_0->descriptor.bDeviceClass == VAR_8) {
		dev_dbg(&VAR_0->dev, ""%s is a usb hub device... skip!\n"",
			 VAR_2);
		VAR_4 = -VAR_7;
		goto call_put_busid_priv;
	}

	if (!strcmp(VAR_0->bus->bus_name, ""vhci_hcd"")) {
		dev_dbg(&VAR_0->dev,
			""%s is attached on vhci_hcd... skip!\n"",
			VAR_2);

		VAR_4 = -VAR_7;
		goto call_put_busid_priv;
	}

	/* COMMENT_6 */
	VAR_1 = stub_device_alloc(VAR_0);
	if (!VAR_1) {
		VAR_4 = -VAR_9;
		goto call_put_busid_priv;
	}

	dev_info(&VAR_0->dev,
		""usbip-host: register new device (bus %u dev %u)\n"",
		VAR_0->bus->busnum, VAR_0->devnum);

	VAR_3->shutdown_busid = 0;

	/* COMMENT_7 */
	dev_set_drvdata(&VAR_0->dev, VAR_1);
	VAR_3->sdev = VAR_1;
	VAR_3->udev = VAR_0;

	/* COMMENT_8 */
                        
                                                 
                                               
    
	VAR_4 = usb_hub_claim_port(VAR_0->parent, VAR_0->portnum,
			(struct usb_dev_state *) VAR_0);
	if (VAR_4) {
		dev_dbg(&VAR_0->dev, ""unable to claim port\n"");
		goto err_port;
	}

	VAR_4 = stub_add_files(&VAR_0->dev);
	if (VAR_4) {
		dev_err(&VAR_0->dev, ""stub_add_files for %s\n"", VAR_2);
		goto err_files;
	}
	VAR_3->status = VAR_10;

	VAR_4 = 0;
	goto call_put_busid_priv;

err_files:
	usb_hub_release_port(VAR_0->parent, VAR_0->portnum,
			     (struct usb_dev_state *) VAR_0);
err_port:
	dev_set_drvdata(&VAR_0->dev, NULL);
	usb_put_dev(VAR_0);

	VAR_3->sdev = NULL;
	stub_device_free(VAR_1);

call_put_busid_priv:
	put_busid_priv(VAR_3);
	return VAR_4;
}",torvalds/linux/22076557b07c12086eeb16b8ce2b0b735f7a27e7/stub_dev.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,7 +3,7 @@
 	struct stub_device *sdev = NULL;
 	const char *udev_busid = dev_name(&udev->dev);
 	struct bus_id_priv *busid_priv;
-	int rc;
+	int rc = 0;
 
 	dev_dbg(&udev->dev, ""Enter probe\n"");
 
@@ -20,13 +20,15 @@
 		 * other matched drivers by the driver core.
 		 * See driver_probe_device() in driver/base/dd.c
 		 */
-		return -ENODEV;
+		rc = -ENODEV;
+		goto call_put_busid_priv;
 	}
 
 	if (udev->descriptor.bDeviceClass == USB_CLASS_HUB) {
 		dev_dbg(&udev->dev, ""%s is a usb hub device... skip!\n"",
 			 udev_busid);
-		return -ENODEV;
+		rc = -ENODEV;
+		goto call_put_busid_priv;
 	}
 
 	if (!strcmp(udev->bus->bus_name, ""vhci_hcd"")) {
@@ -34,13 +36,16 @@
 			""%s is attached on vhci_hcd... skip!\n"",
 			udev_busid);
 
-		return -ENODEV;
+		rc = -ENODEV;
+		goto call_put_busid_priv;
 	}
 
 	/* ok, this is my device */
 	sdev = stub_device_alloc(udev);
-	if (!sdev)
-		return -ENOMEM;
+	if (!sdev) {
+		rc = -ENOMEM;
+		goto call_put_busid_priv;
+	}
 
 	dev_info(&udev->dev,
 		""usbip-host: register new device (bus %u dev %u)\n"",
@@ -72,7 +77,9 @@
 	}
 	busid_priv->status = STUB_BUSID_ALLOC;
 
-	return 0;
+	rc = 0;
+	goto call_put_busid_priv;
+
 err_files:
 	usb_hub_release_port(udev->parent, udev->portnum,
 			     (struct usb_dev_state *) udev);
@@ -82,5 +89,8 @@
 
 	busid_priv->sdev = NULL;
 	stub_device_free(sdev);
+
+call_put_busid_priv:
+	put_busid_priv(busid_priv);
 	return rc;
 }","{'deleted_lines': ['\tint rc;', '\t\treturn -ENODEV;', '\t\treturn -ENODEV;', '\t\treturn -ENODEV;', '\tif (!sdev)', '\t\treturn -ENOMEM;', '\treturn 0;'], 'added_lines': ['\tint rc = 0;', '\t\trc = -ENODEV;', '\t\tgoto call_put_busid_priv;', '\t\trc = -ENODEV;', '\t\tgoto call_put_busid_priv;', '\t\trc = -ENODEV;', '\t\tgoto call_put_busid_priv;', '\tif (!sdev) {', '\t\trc = -ENOMEM;', '\t\tgoto call_put_busid_priv;', '\t}', '\trc = 0;', '\tgoto call_put_busid_priv;', '', '', 'call_put_busid_priv:', '\tput_busid_priv(busid_priv);']}",True,"In the Linux Kernel before version 4.16.11, 4.14.43, 4.9.102, and 4.4.133, multiple race condition errors when handling probe, disconnect, and rebind operations can be exploited to trigger a use-after-free condition or a NULL pointer dereference by sending multiple USB over IP packets.",7.0,HIGH,2,test,,5
CVE-2018-5814,['CWE-362'],AV:L/AC:M/Au:N/C:C/I:C/A:C,0,torvalds/linux,"usbip_host updates device status without holding lock from stub probe,
disconnect and rebind code paths. When multiple requests to import a
device are received, these unprotected code paths step all over each
other and drive fails with NULL-ptr deref and use-after-free errors.

The driver uses a table lock to protect the busid array for adding and
deleting busids to the table. However, the probe, disconnect and rebind
paths get the busid table entry and update the status without holding
the busid table lock. Add a new finer grain lock to protect the busid
entry. This new lock will be held to search and update the busid entry
fields from get_busid_idx(), add_match_busid() and del_match_busid().

match_busid_show() does the same to access the busid entry fields.

get_busid_priv() changed to return the pointer to the busid entry holding
the busid lock. stub_probe(), stub_disconnect() and stub_device_rebind()
call put_busid_priv() to release the busid lock before returning. This
changes fixes the unprotected code paths eliminating the race conditions
in updating the busid entries.

Reported-by: Jakub Jirasek
Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>
Cc: stable <stable@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
",22076557b07c12086eeb16b8ce2b0b735f7a27e7,https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/commit/?h=22076557b07c12086eeb16b8ce2b0b735f7a27e7,drivers/usb/usbip/stub_dev.c,stub_disconnect,"static void stub_disconnect(struct usb_device *udev)
{
struct stub_device *sdev;
const char *udev_busid = dev_name(&udev->dev);
struct bus_id_priv *busid_priv;
int rc;
dev_dbg(&udev->dev, ""Enter disconnect\n"");
busid_priv = get_busid_priv(udev_busid);
if (!busid_priv) {
BUG();
return;
}
sdev = dev_get_drvdata(&udev->dev);
if (!sdev) {
dev_err(&udev->dev, ""could not get device"");
return;
}
dev_set_drvdata(&udev->dev, NULL);
stub_remove_files(&udev->dev);
rc = usb_hub_release_port(udev->parent, udev->portnum,
(struct usb_dev_state *) udev);
if (rc) {
dev_dbg(&udev->dev, ""unable to release port\n"");
return;
}
if (usbip_in_eh(current))
return;
shutdown_busid(busid_priv);
usb_put_dev(sdev->udev);
busid_priv->sdev = NULL;
stub_device_free(sdev);
if (busid_priv->status == STUB_BUSID_ALLOC)
busid_priv->status = STUB_BUSID_ADDED;
}","static void stub_disconnect(struct usb_device *VAR_0)
{
struct stub_device *VAR_1;
const char *VAR_2 = dev_name(&VAR_0->dev);
struct bus_id_priv *VAR_3;
int VAR_4;
dev_dbg(&VAR_0->dev, ""Enter disconnect\n"");
VAR_3 = get_busid_priv(VAR_2);
if (!VAR_3) {
BUG();
return;
}
VAR_1 = dev_get_drvdata(&VAR_0->dev);
if (!VAR_1) {
dev_err(&VAR_0->dev, ""could not get device"");
return;
}
dev_set_drvdata(&VAR_0->dev, NULL);
stub_remove_files(&VAR_0->dev);
VAR_4 = usb_hub_release_port(VAR_0->parent, VAR_0->portnum,
(struct usb_dev_state *) VAR_0);
if (VAR_4) {
dev_dbg(&VAR_0->dev, ""unable to release port\n"");
return;
}
if (usbip_in_eh(VAR_5))
return;
shutdown_busid(VAR_3);
usb_put_dev(VAR_1->udev);
VAR_3->sdev = NULL;
stub_device_free(VAR_1);
if (VAR_3->status == VAR_6)
VAR_3->status = VAR_7;
}",torvalds/linux/22076557b07c12086eeb16b8ce2b0b735f7a27e7/stub_dev.c/vul/before/1.json,"static void stub_disconnect(struct usb_device *udev)
{
	struct stub_device *sdev;
	const char *udev_busid = dev_name(&udev->dev);
	struct bus_id_priv *busid_priv;
	int rc;

	dev_dbg(&udev->dev, ""Enter disconnect\n"");

	busid_priv = get_busid_priv(udev_busid);
	if (!busid_priv) {
		BUG();
		return;
	}

	sdev = dev_get_drvdata(&udev->dev);

	/* get stub_device */
	if (!sdev) {
		dev_err(&udev->dev, ""could not get device"");
		goto call_put_busid_priv;
	}

	dev_set_drvdata(&udev->dev, NULL);

	/*
	 * NOTE: rx/tx threads are invoked for each usb_device.
	 */
	stub_remove_files(&udev->dev);

	/* release port */
	rc = usb_hub_release_port(udev->parent, udev->portnum,
				  (struct usb_dev_state *) udev);
	if (rc) {
		dev_dbg(&udev->dev, ""unable to release port\n"");
		goto call_put_busid_priv;
	}

	/* If usb reset is called from event handler */
	if (usbip_in_eh(current))
		goto call_put_busid_priv;

	/* shutdown the current connection */
	shutdown_busid(busid_priv);

	usb_put_dev(sdev->udev);

	/* free sdev */
	busid_priv->sdev = NULL;
	stub_device_free(sdev);

	if (busid_priv->status == STUB_BUSID_ALLOC)
		busid_priv->status = STUB_BUSID_ADDED;

call_put_busid_priv:
	put_busid_priv(busid_priv);
}","static void stub_disconnect(struct usb_device *VAR_0)
{
	struct stub_device *VAR_1;
	const char *VAR_2 = dev_name(&VAR_0->dev);
	struct bus_id_priv *VAR_3;
	int VAR_4;

	dev_dbg(&VAR_0->dev, ""Enter disconnect\n"");

	VAR_3 = get_busid_priv(VAR_2);
	if (!VAR_3) {
		BUG();
		return;
	}

	VAR_1 = dev_get_drvdata(&VAR_0->dev);

	/* COMMENT_0 */
	if (!VAR_1) {
		dev_err(&VAR_0->dev, ""could not get device"");
		goto call_put_busid_priv;
	}

	dev_set_drvdata(&VAR_0->dev, NULL);

	/* COMMENT_1 */
                                                        
    
	stub_remove_files(&VAR_0->dev);

	/* COMMENT_4 */
	VAR_4 = usb_hub_release_port(VAR_0->parent, VAR_0->portnum,
				  (struct usb_dev_state *) VAR_0);
	if (VAR_4) {
		dev_dbg(&VAR_0->dev, ""unable to release port\n"");
		goto call_put_busid_priv;
	}

	/* COMMENT_5 */
	if (usbip_in_eh(VAR_5))
		goto call_put_busid_priv;

	/* COMMENT_6 */
	shutdown_busid(VAR_3);

	usb_put_dev(VAR_1->udev);

	/* COMMENT_7 */
	VAR_3->sdev = NULL;
	stub_device_free(VAR_1);

	if (VAR_3->status == VAR_6)
		VAR_3->status = VAR_7;

call_put_busid_priv:
	put_busid_priv(VAR_3);
}",torvalds/linux/22076557b07c12086eeb16b8ce2b0b735f7a27e7/stub_dev.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -18,7 +18,7 @@
 	/* get stub_device */
 	if (!sdev) {
 		dev_err(&udev->dev, ""could not get device"");
-		return;
+		goto call_put_busid_priv;
 	}
 
 	dev_set_drvdata(&udev->dev, NULL);
@@ -33,12 +33,12 @@
 				  (struct usb_dev_state *) udev);
 	if (rc) {
 		dev_dbg(&udev->dev, ""unable to release port\n"");
-		return;
+		goto call_put_busid_priv;
 	}
 
 	/* If usb reset is called from event handler */
 	if (usbip_in_eh(current))
-		return;
+		goto call_put_busid_priv;
 
 	/* shutdown the current connection */
 	shutdown_busid(busid_priv);
@@ -51,4 +51,7 @@
 
 	if (busid_priv->status == STUB_BUSID_ALLOC)
 		busid_priv->status = STUB_BUSID_ADDED;
+
+call_put_busid_priv:
+	put_busid_priv(busid_priv);
 }","{'deleted_lines': ['\t\treturn;', '\t\treturn;', '\t\treturn;'], 'added_lines': ['\t\tgoto call_put_busid_priv;', '\t\tgoto call_put_busid_priv;', '\t\tgoto call_put_busid_priv;', '', 'call_put_busid_priv:', '\tput_busid_priv(busid_priv);']}",True,"In the Linux Kernel before version 4.16.11, 4.14.43, 4.9.102, and 4.4.133, multiple race condition errors when handling probe, disconnect, and rebind operations can be exploited to trigger a use-after-free condition or a NULL pointer dereference by sending multiple USB over IP packets.",7.0,HIGH,2,test,,5
CVE-2021-33655,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"Pull fbdev fixes from Helge Deller:

 - fbcon now prevents switching to screen resolutions which are smaller
   than the font size, and prevents enabling a font which is bigger than
   the current screen resolution. This fixes vmalloc-out-of-bounds
   accesses found by KASAN.

 - Guiling Deng fixed a bug where the centered fbdev logo wasn't
   displayed correctly if the screen size matched the logo size.

 - Hsin-Yi Wang provided a patch to include errno.h to fix build when
   CONFIG_OF isn't enabled.

* tag 'for-5.19/fbdev-3' of git://git.kernel.org/pub/scm/linux/kernel/git/deller/linux-fbdev:
  fbcon: Use fbcon_info_from_console() in fbcon_modechange_possible()
  fbmem: Check virtual screen sizes in fb_set_var()
  fbcon: Prevent that screen size is smaller than font size
  fbcon: Disallow setting font bigger than screen size
  video: of_display_timing.h: include errno.h
  fbdev: fbmem: Fix logo center image dx issue
",086ff84617185393a0bbf25830c4f36412a7d3f4,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=086ff84617185393a0bbf25830c4f36412a7d3f4,drivers/video/fbdev/core/fbmem.c,fb_set_var,"int
fb_set_var(struct fb_info *info, struct fb_var_screeninfo *var)
{
int ret = 0;
u32 activate;
struct fb_var_screeninfo old_var;
struct fb_videomode mode;
struct fb_event event;
u32 unused;
if (var->activate & FB_ACTIVATE_INV_MODE) {
struct fb_videomode mode1, mode2;
fb_var_to_videomode(&mode1, var);
fb_var_to_videomode(&mode2, &info->var);
ret = fb_mode_is_equal(&mode1, &mode2);
if (!ret) {
ret = fbcon_mode_deleted(info, &mode1);
if (!ret)
fb_delete_videomode(&mode1, &info->modelist);
}
return ret ? -EINVAL : 0;
}
if (!(var->activate & FB_ACTIVATE_FORCE) &&
!memcmp(&info->var, var, sizeof(struct fb_var_screeninfo)))
return 0;
activate = var->activate;
if ((info->fix.capabilities & FB_CAP_FOURCC) &&
var->grayscale > 1) {
if (var->red.offset     || var->green.offset    ||
var->blue.offset    || var->transp.offset   ||
var->red.length     || var->green.length    ||
var->blue.length    || var->transp.length   ||
var->red.msb_right  || var->green.msb_right ||
var->blue.msb_right || var->transp.msb_right)
return -EINVAL;
}
if (!info->fbops->fb_check_var) {
*var = info->var;
return 0;
}
if (var->xres < 8 || var->yres < 8)
return -EINVAL;
if (check_mul_overflow(var->xres, var->yres, &unused) ||
check_mul_overflow(var->xres_virtual, var->yres_virtual, &unused))
return -EINVAL;
ret = info->fbops->fb_check_var(var, info);
if (ret)
return ret;
if ((var->activate & FB_ACTIVATE_MASK) != FB_ACTIVATE_NOW)
return 0;
if (info->fbops->fb_get_caps) {
ret = fb_check_caps(info, var, activate);
if (ret)
return ret;
}
old_var = info->var;
info->var = *var;
if (info->fbops->fb_set_par) {
ret = info->fbops->fb_set_par(info);
if (ret) {
info->var = old_var;
printk(KERN_WARNING ""detected ""
""fb_set_par error, ""
""error code: %d\n"", ret);
return ret;
}
}
fb_pan_display(info, &info->var);
fb_set_cmap(&info->cmap, info);
fb_var_to_videomode(&mode, &info->var);
if (info->modelist.prev && info->modelist.next &&
!list_empty(&info->modelist))
ret = fb_add_videomode(&mode, &info->modelist);
if (ret)
return ret;
event.info = info;
event.data = &mode;
fb_notifier_call_chain(FB_EVENT_MODE_CHANGE, &event);
return 0;
}","int
fb_set_var(struct fb_info *VAR_0, struct fb_var_screeninfo *VAR_1)
{
int VAR_2 = 0;
u32 VAR_3;
struct fb_var_screeninfo VAR_4;
struct fb_videomode VAR_5;
struct fb_event VAR_6;
u32 VAR_7;
if (VAR_1->activate & VAR_8) {
struct fb_videomode VAR_9, VAR_10;
fb_var_to_videomode(&VAR_9, VAR_1);
fb_var_to_videomode(&VAR_10, &VAR_0->var);
VAR_2 = fb_mode_is_equal(&VAR_9, &VAR_10);
if (!VAR_2) {
VAR_2 = fbcon_mode_deleted(VAR_0, &VAR_9);
if (!VAR_2)
fb_delete_videomode(&VAR_9, &VAR_0->modelist);
}
return VAR_2 ? -VAR_11 : 0;
}
if (!(VAR_1->activate & VAR_12) &&
!memcmp(&VAR_0->var, VAR_1, sizeof(struct fb_var_screeninfo)))
return 0;
VAR_3 = VAR_1->activate;
if ((VAR_0->fix.capabilities & VAR_13) &&
VAR_1->grayscale > 1) {
if (VAR_1->red.offset     || VAR_1->green.offset    ||
VAR_1->blue.offset    || VAR_1->transp.offset   ||
VAR_1->red.length     || VAR_1->green.length    ||
VAR_1->blue.length    || VAR_1->transp.length   ||
VAR_1->red.msb_right  || VAR_1->green.msb_right ||
VAR_1->blue.msb_right || VAR_1->transp.msb_right)
return -VAR_11;
}
if (!VAR_0->fbops->fb_check_var) {
*VAR_1 = VAR_0->var;
return 0;
}
if (VAR_1->xres < 8 || VAR_1->yres < 8)
return -VAR_11;
if (check_mul_overflow(VAR_1->xres, VAR_1->yres, &VAR_7) ||
check_mul_overflow(VAR_1->xres_virtual, VAR_1->yres_virtual, &VAR_7))
return -VAR_11;
VAR_2 = VAR_0->fbops->fb_check_var(VAR_1, VAR_0);
if (VAR_2)
return VAR_2;
if ((VAR_1->activate & VAR_14) != VAR_15)
return 0;
if (VAR_0->fbops->fb_get_caps) {
VAR_2 = fb_check_caps(VAR_0, VAR_1, VAR_3);
if (VAR_2)
return VAR_2;
}
VAR_4 = VAR_0->var;
VAR_0->var = *VAR_1;
if (VAR_0->fbops->fb_set_par) {
VAR_2 = VAR_0->fbops->fb_set_par(VAR_0);
if (VAR_2) {
VAR_0->var = VAR_4;
printk(KERN_WARNING ""detected ""
""fb_set_par error, ""
""error code: %d\n"", VAR_2);
return VAR_2;
}
}
fb_pan_display(VAR_0, &VAR_0->var);
fb_set_cmap(&VAR_0->cmap, VAR_0);
fb_var_to_videomode(&VAR_5, &VAR_0->var);
if (VAR_0->modelist.prev && VAR_0->modelist.next &&
!list_empty(&VAR_0->modelist))
VAR_2 = fb_add_videomode(&VAR_5, &VAR_0->modelist);
if (VAR_2)
return VAR_2;
VAR_6.info = VAR_0;
VAR_6.data = &VAR_5;
fb_notifier_call_chain(VAR_16, &VAR_6);
return 0;
}",torvalds/linux/086ff84617185393a0bbf25830c4f36412a7d3f4/fbmem.c/vul/before/0.json,"int
fb_set_var(struct fb_info *info, struct fb_var_screeninfo *var)
{
	int ret = 0;
	u32 activate;
	struct fb_var_screeninfo old_var;
	struct fb_videomode mode;
	struct fb_event event;
	u32 unused;

	if (var->activate & FB_ACTIVATE_INV_MODE) {
		struct fb_videomode mode1, mode2;

		fb_var_to_videomode(&mode1, var);
		fb_var_to_videomode(&mode2, &info->var);
		/* make sure we don't delete the videomode of current var */
		ret = fb_mode_is_equal(&mode1, &mode2);
		if (!ret) {
			ret = fbcon_mode_deleted(info, &mode1);
			if (!ret)
				fb_delete_videomode(&mode1, &info->modelist);
		}

		return ret ? -EINVAL : 0;
	}

	if (!(var->activate & FB_ACTIVATE_FORCE) &&
	    !memcmp(&info->var, var, sizeof(struct fb_var_screeninfo)))
		return 0;

	activate = var->activate;

	/* When using FOURCC mode, make sure the red, green, blue and
	 * transp fields are set to 0.
	 */
	if ((info->fix.capabilities & FB_CAP_FOURCC) &&
	    var->grayscale > 1) {
		if (var->red.offset     || var->green.offset    ||
		    var->blue.offset    || var->transp.offset   ||
		    var->red.length     || var->green.length    ||
		    var->blue.length    || var->transp.length   ||
		    var->red.msb_right  || var->green.msb_right ||
		    var->blue.msb_right || var->transp.msb_right)
			return -EINVAL;
	}

	if (!info->fbops->fb_check_var) {
		*var = info->var;
		return 0;
	}

	/* bitfill_aligned() assumes that it's at least 8x8 */
	if (var->xres < 8 || var->yres < 8)
		return -EINVAL;

	/* Too huge resolution causes multiplication overflow. */
	if (check_mul_overflow(var->xres, var->yres, &unused) ||
	    check_mul_overflow(var->xres_virtual, var->yres_virtual, &unused))
		return -EINVAL;

	ret = info->fbops->fb_check_var(var, info);

	if (ret)
		return ret;

	/* verify that virtual resolution >= physical resolution */
	if (var->xres_virtual < var->xres ||
	    var->yres_virtual < var->yres) {
		pr_warn(""WARNING: fbcon: Driver '%s' missed to adjust virtual screen size (%ux%u vs. %ux%u)\n"",
			info->fix.id,
			var->xres_virtual, var->yres_virtual,
			var->xres, var->yres);
		return -EINVAL;
	}

	if ((var->activate & FB_ACTIVATE_MASK) != FB_ACTIVATE_NOW)
		return 0;

	if (info->fbops->fb_get_caps) {
		ret = fb_check_caps(info, var, activate);

		if (ret)
			return ret;
	}

	old_var = info->var;
	info->var = *var;

	if (info->fbops->fb_set_par) {
		ret = info->fbops->fb_set_par(info);

		if (ret) {
			info->var = old_var;
			printk(KERN_WARNING ""detected ""
				""fb_set_par error, ""
				""error code: %d\n"", ret);
			return ret;
		}
	}

	fb_pan_display(info, &info->var);
	fb_set_cmap(&info->cmap, info);
	fb_var_to_videomode(&mode, &info->var);

	if (info->modelist.prev && info->modelist.next &&
	    !list_empty(&info->modelist))
		ret = fb_add_videomode(&mode, &info->modelist);

	if (ret)
		return ret;

	event.info = info;
	event.data = &mode;
	fb_notifier_call_chain(FB_EVENT_MODE_CHANGE, &event);

	return 0;
}","int
fb_set_var(struct fb_info *VAR_0, struct fb_var_screeninfo *VAR_1)
{
	int VAR_2 = 0;
	u32 VAR_3;
	struct fb_var_screeninfo VAR_4;
	struct fb_videomode VAR_5;
	struct fb_event VAR_6;
	u32 VAR_7;

	if (VAR_1->activate & VAR_8) {
		struct fb_videomode VAR_9, VAR_10;

		fb_var_to_videomode(&VAR_9, VAR_1);
		fb_var_to_videomode(&VAR_10, &VAR_0->var);
		/* COMMENT_0 */
		VAR_2 = fb_mode_is_equal(&VAR_9, &VAR_10);
		if (!VAR_2) {
			VAR_2 = fbcon_mode_deleted(VAR_0, &VAR_9);
			if (!VAR_2)
				fb_delete_videomode(&VAR_9, &VAR_0->modelist);
		}

		return VAR_2 ? -VAR_11 : 0;
	}

	if (!(VAR_1->activate & VAR_12) &&
	    !memcmp(&VAR_0->var, VAR_1, sizeof(struct fb_var_screeninfo)))
		return 0;

	VAR_3 = VAR_1->activate;

	/* COMMENT_1 */
                               
    
	if ((VAR_0->fix.capabilities & VAR_13) &&
	    VAR_1->grayscale > 1) {
		if (VAR_1->red.offset     || VAR_1->green.offset    ||
		    VAR_1->blue.offset    || VAR_1->transp.offset   ||
		    VAR_1->red.length     || VAR_1->green.length    ||
		    VAR_1->blue.length    || VAR_1->transp.length   ||
		    VAR_1->red.msb_right  || VAR_1->green.msb_right ||
		    VAR_1->blue.msb_right || VAR_1->transp.msb_right)
			return -VAR_11;
	}

	if (!VAR_0->fbops->fb_check_var) {
		*VAR_1 = VAR_0->var;
		return 0;
	}

	/* COMMENT_4 */
	if (VAR_1->xres < 8 || VAR_1->yres < 8)
		return -VAR_11;

	/* COMMENT_5 */
	if (check_mul_overflow(VAR_1->xres, VAR_1->yres, &VAR_7) ||
	    check_mul_overflow(VAR_1->xres_virtual, VAR_1->yres_virtual, &VAR_7))
		return -VAR_11;

	VAR_2 = VAR_0->fbops->fb_check_var(VAR_1, VAR_0);

	if (VAR_2)
		return VAR_2;

	/* COMMENT_6 */
	if (VAR_1->xres_virtual < VAR_1->xres ||
	    VAR_1->yres_virtual < VAR_1->yres) {
		pr_warn(""WARNING: fbcon: Driver '%s' missed to adjust virtual screen size (%ux%u vs. %ux%u)\n"",
			VAR_0->fix.id,
			VAR_1->xres_virtual, VAR_1->yres_virtual,
			VAR_1->xres, VAR_1->yres);
		return -VAR_11;
	}

	if ((VAR_1->activate & VAR_14) != VAR_15)
		return 0;

	if (VAR_0->fbops->fb_get_caps) {
		VAR_2 = fb_check_caps(VAR_0, VAR_1, VAR_3);

		if (VAR_2)
			return VAR_2;
	}

	VAR_4 = VAR_0->var;
	VAR_0->var = *VAR_1;

	if (VAR_0->fbops->fb_set_par) {
		VAR_2 = VAR_0->fbops->fb_set_par(VAR_0);

		if (VAR_2) {
			VAR_0->var = VAR_4;
			printk(KERN_WARNING ""detected ""
				""fb_set_par error, ""
				""error code: %d\n"", VAR_2);
			return VAR_2;
		}
	}

	fb_pan_display(VAR_0, &VAR_0->var);
	fb_set_cmap(&VAR_0->cmap, VAR_0);
	fb_var_to_videomode(&VAR_5, &VAR_0->var);

	if (VAR_0->modelist.prev && VAR_0->modelist.next &&
	    !list_empty(&VAR_0->modelist))
		VAR_2 = fb_add_videomode(&VAR_5, &VAR_0->modelist);

	if (VAR_2)
		return VAR_2;

	VAR_6.info = VAR_0;
	VAR_6.data = &VAR_5;
	fb_notifier_call_chain(VAR_16, &VAR_6);

	return 0;
}",torvalds/linux/086ff84617185393a0bbf25830c4f36412a7d3f4/fbmem.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -63,6 +63,16 @@
 	if (ret)
 		return ret;
 
+	/* verify that virtual resolution >= physical resolution */
+	if (var->xres_virtual < var->xres ||
+	    var->yres_virtual < var->yres) {
+		pr_warn(""WARNING: fbcon: Driver '%s' missed to adjust virtual screen size (%ux%u vs. %ux%u)\n"",
+			info->fix.id,
+			var->xres_virtual, var->yres_virtual,
+			var->xres, var->yres);
+		return -EINVAL;
+	}
+
 	if ((var->activate & FB_ACTIVATE_MASK) != FB_ACTIVATE_NOW)
 		return 0;
 ","{'deleted_lines': [], 'added_lines': ['\t/* verify that virtual resolution >= physical resolution */', '\tif (var->xres_virtual < var->xres ||', '\t    var->yres_virtual < var->yres) {', '\t\tpr_warn(""WARNING: fbcon: Driver \'%s\' missed to adjust virtual screen size (%ux%u vs. %ux%u)\\n"",', '\t\t\tinfo->fix.id,', '\t\t\tvar->xres_virtual, var->yres_virtual,', '\t\t\tvar->xres, var->yres);', '\t\treturn -EINVAL;', '\t}', '']}",True,"When sending malicous data to kernel by ioctl cmd FBIOPUT_VSCREENINFO,kernel will write memory out of bounds.",6.7,MEDIUM,1,test,,5
CVE-2021-33655,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"Pull fbdev fixes from Helge Deller:

 - fbcon now prevents switching to screen resolutions which are smaller
   than the font size, and prevents enabling a font which is bigger than
   the current screen resolution. This fixes vmalloc-out-of-bounds
   accesses found by KASAN.

 - Guiling Deng fixed a bug where the centered fbdev logo wasn't
   displayed correctly if the screen size matched the logo size.

 - Hsin-Yi Wang provided a patch to include errno.h to fix build when
   CONFIG_OF isn't enabled.

* tag 'for-5.19/fbdev-3' of git://git.kernel.org/pub/scm/linux/kernel/git/deller/linux-fbdev:
  fbcon: Use fbcon_info_from_console() in fbcon_modechange_possible()
  fbmem: Check virtual screen sizes in fb_set_var()
  fbcon: Prevent that screen size is smaller than font size
  fbcon: Disallow setting font bigger than screen size
  video: of_display_timing.h: include errno.h
  fbdev: fbmem: Fix logo center image dx issue
",086ff84617185393a0bbf25830c4f36412a7d3f4,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=086ff84617185393a0bbf25830c4f36412a7d3f4,drivers/video/fbdev/core/fbmem.c,do_fb_ioctl,"static long do_fb_ioctl(struct fb_info *info, unsigned int cmd,
unsigned long arg)
{
const struct fb_ops *fb;
struct fb_var_screeninfo var;
struct fb_fix_screeninfo fix;
struct fb_cmap cmap_from;
struct fb_cmap_user cmap;
void __user *argp = (void __user *)arg;
long ret = 0;
switch (cmd) {
case FBIOGET_VSCREENINFO:
lock_fb_info(info);
var = info->var;
unlock_fb_info(info);
ret = copy_to_user(argp, &var, sizeof(var)) ? -EFAULT : 0;
break;
case FBIOPUT_VSCREENINFO:
if (copy_from_user(&var, argp, sizeof(var)))
return -EFAULT;
console_lock();
lock_fb_info(info);
ret = fb_set_var(info, &var);
if (!ret)
fbcon_update_vcs(info, var.activate & FB_ACTIVATE_ALL);
unlock_fb_info(info);
console_unlock();
if (!ret && copy_to_user(argp, &var, sizeof(var)))
ret = -EFAULT;
break;
case FBIOGET_FSCREENINFO:
lock_fb_info(info);
memcpy(&fix, &info->fix, sizeof(fix));
if (info->flags & FBINFO_HIDE_SMEM_START)
fix.smem_start = 0;
unlock_fb_info(info);
ret = copy_to_user(argp, &fix, sizeof(fix)) ? -EFAULT : 0;
break;
case FBIOPUTCMAP:
if (copy_from_user(&cmap, argp, sizeof(cmap)))
return -EFAULT;
ret = fb_set_user_cmap(&cmap, info);
break;
case FBIOGETCMAP:
if (copy_from_user(&cmap, argp, sizeof(cmap)))
return -EFAULT;
lock_fb_info(info);
cmap_from = info->cmap;
unlock_fb_info(info);
ret = fb_cmap_to_user(&cmap_from, &cmap);
break;
case FBIOPAN_DISPLAY:
if (copy_from_user(&var, argp, sizeof(var)))
return -EFAULT;
console_lock();
lock_fb_info(info);
ret = fb_pan_display(info, &var);
unlock_fb_info(info);
console_unlock();
if (ret == 0 && copy_to_user(argp, &var, sizeof(var)))
return -EFAULT;
break;
case FBIO_CURSOR:
ret = -EINVAL;
break;
case FBIOGET_CON2FBMAP:
ret = fbcon_get_con2fb_map_ioctl(argp);
break;
case FBIOPUT_CON2FBMAP:
ret = fbcon_set_con2fb_map_ioctl(argp);
break;
case FBIOBLANK:
if (arg > FB_BLANK_POWERDOWN)
return -EINVAL;
console_lock();
lock_fb_info(info);
ret = fb_blank(info, arg);
fbcon_fb_blanked(info, arg);
unlock_fb_info(info);
console_unlock();
break;
default:
lock_fb_info(info);
fb = info->fbops;
if (fb->fb_ioctl)
ret = fb->fb_ioctl(info, cmd, arg);
else
ret = -ENOTTY;
unlock_fb_info(info);
}
return ret;
}","static long do_fb_ioctl(struct fb_info *VAR_0, unsigned int VAR_1,
unsigned long VAR_2)
{
const struct fb_ops *VAR_3;
struct fb_var_screeninfo VAR_4;
struct fb_fix_screeninfo VAR_5;
struct fb_cmap VAR_6;
struct fb_cmap_user VAR_7;
void __user *VAR_8 = (void __user *)VAR_2;
long VAR_9 = 0;
switch (VAR_1) {
case VAR_10:
lock_fb_info(VAR_0);
VAR_4 = VAR_0->var;
unlock_fb_info(VAR_0);
VAR_9 = copy_to_user(VAR_8, &VAR_4, sizeof(VAR_4)) ? -VAR_11 : 0;
break;
case VAR_12:
if (copy_from_user(&VAR_4, VAR_8, sizeof(VAR_4)))
return -VAR_11;
console_lock();
lock_fb_info(VAR_0);
VAR_9 = fb_set_var(VAR_0, &VAR_4);
if (!VAR_9)
fbcon_update_vcs(VAR_0, VAR_4.activate & VAR_13);
unlock_fb_info(VAR_0);
console_unlock();
if (!VAR_9 && copy_to_user(VAR_8, &VAR_4, sizeof(VAR_4)))
VAR_9 = -VAR_11;
break;
case VAR_14:
lock_fb_info(VAR_0);
memcpy(&VAR_5, &VAR_0->fix, sizeof(VAR_5));
if (VAR_0->flags & VAR_15)
VAR_5.smem_start = 0;
unlock_fb_info(VAR_0);
VAR_9 = copy_to_user(VAR_8, &VAR_5, sizeof(VAR_5)) ? -VAR_11 : 0;
break;
case VAR_16:
if (copy_from_user(&VAR_7, VAR_8, sizeof(VAR_7)))
return -VAR_11;
VAR_9 = fb_set_user_cmap(&VAR_7, VAR_0);
break;
case VAR_17:
if (copy_from_user(&VAR_7, VAR_8, sizeof(VAR_7)))
return -VAR_11;
lock_fb_info(VAR_0);
VAR_6 = VAR_0->cmap;
unlock_fb_info(VAR_0);
VAR_9 = fb_cmap_to_user(&VAR_6, &VAR_7);
break;
case VAR_18:
if (copy_from_user(&VAR_4, VAR_8, sizeof(VAR_4)))
return -VAR_11;
console_lock();
lock_fb_info(VAR_0);
VAR_9 = fb_pan_display(VAR_0, &VAR_4);
unlock_fb_info(VAR_0);
console_unlock();
if (VAR_9 == 0 && copy_to_user(VAR_8, &VAR_4, sizeof(VAR_4)))
return -VAR_11;
break;
case VAR_19:
VAR_9 = -VAR_20;
break;
case VAR_21:
VAR_9 = fbcon_get_con2fb_map_ioctl(VAR_8);
break;
case VAR_22:
VAR_9 = fbcon_set_con2fb_map_ioctl(VAR_8);
break;
case VAR_23:
if (VAR_2 > VAR_24)
return -VAR_20;
console_lock();
lock_fb_info(VAR_0);
VAR_9 = fb_blank(VAR_0, VAR_2);
fbcon_fb_blanked(VAR_0, VAR_2);
unlock_fb_info(VAR_0);
console_unlock();
break;
default:
lock_fb_info(VAR_0);
VAR_3 = VAR_0->fbops;
if (VAR_3->fb_ioctl)
VAR_9 = VAR_3->fb_ioctl(VAR_0, VAR_1, VAR_2);
else
VAR_9 = -VAR_25;
unlock_fb_info(VAR_0);
}
return VAR_9;
}",torvalds/linux/086ff84617185393a0bbf25830c4f36412a7d3f4/fbmem.c/vul/before/1.json,"static long do_fb_ioctl(struct fb_info *info, unsigned int cmd,
			unsigned long arg)
{
	const struct fb_ops *fb;
	struct fb_var_screeninfo var;
	struct fb_fix_screeninfo fix;
	struct fb_cmap cmap_from;
	struct fb_cmap_user cmap;
	void __user *argp = (void __user *)arg;
	long ret = 0;

	switch (cmd) {
	case FBIOGET_VSCREENINFO:
		lock_fb_info(info);
		var = info->var;
		unlock_fb_info(info);

		ret = copy_to_user(argp, &var, sizeof(var)) ? -EFAULT : 0;
		break;
	case FBIOPUT_VSCREENINFO:
		if (copy_from_user(&var, argp, sizeof(var)))
			return -EFAULT;
		console_lock();
		lock_fb_info(info);
		ret = fbcon_modechange_possible(info, &var);
		if (!ret)
			ret = fb_set_var(info, &var);
		if (!ret)
			fbcon_update_vcs(info, var.activate & FB_ACTIVATE_ALL);
		unlock_fb_info(info);
		console_unlock();
		if (!ret && copy_to_user(argp, &var, sizeof(var)))
			ret = -EFAULT;
		break;
	case FBIOGET_FSCREENINFO:
		lock_fb_info(info);
		memcpy(&fix, &info->fix, sizeof(fix));
		if (info->flags & FBINFO_HIDE_SMEM_START)
			fix.smem_start = 0;
		unlock_fb_info(info);

		ret = copy_to_user(argp, &fix, sizeof(fix)) ? -EFAULT : 0;
		break;
	case FBIOPUTCMAP:
		if (copy_from_user(&cmap, argp, sizeof(cmap)))
			return -EFAULT;
		ret = fb_set_user_cmap(&cmap, info);
		break;
	case FBIOGETCMAP:
		if (copy_from_user(&cmap, argp, sizeof(cmap)))
			return -EFAULT;
		lock_fb_info(info);
		cmap_from = info->cmap;
		unlock_fb_info(info);
		ret = fb_cmap_to_user(&cmap_from, &cmap);
		break;
	case FBIOPAN_DISPLAY:
		if (copy_from_user(&var, argp, sizeof(var)))
			return -EFAULT;
		console_lock();
		lock_fb_info(info);
		ret = fb_pan_display(info, &var);
		unlock_fb_info(info);
		console_unlock();
		if (ret == 0 && copy_to_user(argp, &var, sizeof(var)))
			return -EFAULT;
		break;
	case FBIO_CURSOR:
		ret = -EINVAL;
		break;
	case FBIOGET_CON2FBMAP:
		ret = fbcon_get_con2fb_map_ioctl(argp);
		break;
	case FBIOPUT_CON2FBMAP:
		ret = fbcon_set_con2fb_map_ioctl(argp);
		break;
	case FBIOBLANK:
		if (arg > FB_BLANK_POWERDOWN)
			return -EINVAL;
		console_lock();
		lock_fb_info(info);
		ret = fb_blank(info, arg);
		/* might again call into fb_blank */
		fbcon_fb_blanked(info, arg);
		unlock_fb_info(info);
		console_unlock();
		break;
	default:
		lock_fb_info(info);
		fb = info->fbops;
		if (fb->fb_ioctl)
			ret = fb->fb_ioctl(info, cmd, arg);
		else
			ret = -ENOTTY;
		unlock_fb_info(info);
	}
	return ret;
}","static long do_fb_ioctl(struct fb_info *VAR_0, unsigned int VAR_1,
			unsigned long VAR_2)
{
	const struct fb_ops *VAR_3;
	struct fb_var_screeninfo VAR_4;
	struct fb_fix_screeninfo VAR_5;
	struct fb_cmap VAR_6;
	struct fb_cmap_user VAR_7;
	void __user *VAR_8 = (void __user *)VAR_2;
	long VAR_9 = 0;

	switch (VAR_1) {
	case VAR_10:
		lock_fb_info(VAR_0);
		VAR_4 = VAR_0->var;
		unlock_fb_info(VAR_0);

		VAR_9 = copy_to_user(VAR_8, &VAR_4, sizeof(VAR_4)) ? -VAR_11 : 0;
		break;
	case VAR_12:
		if (copy_from_user(&VAR_4, VAR_8, sizeof(VAR_4)))
			return -VAR_11;
		console_lock();
		lock_fb_info(VAR_0);
		VAR_9 = fbcon_modechange_possible(VAR_0, &VAR_4);
		if (!VAR_9)
			VAR_9 = fb_set_var(VAR_0, &VAR_4);
		if (!VAR_9)
			fbcon_update_vcs(VAR_0, VAR_4.activate & VAR_13);
		unlock_fb_info(VAR_0);
		console_unlock();
		if (!VAR_9 && copy_to_user(VAR_8, &VAR_4, sizeof(VAR_4)))
			VAR_9 = -VAR_11;
		break;
	case VAR_14:
		lock_fb_info(VAR_0);
		memcpy(&VAR_5, &VAR_0->fix, sizeof(VAR_5));
		if (VAR_0->flags & VAR_15)
			VAR_5.smem_start = 0;
		unlock_fb_info(VAR_0);

		VAR_9 = copy_to_user(VAR_8, &VAR_5, sizeof(VAR_5)) ? -VAR_11 : 0;
		break;
	case VAR_16:
		if (copy_from_user(&VAR_7, VAR_8, sizeof(VAR_7)))
			return -VAR_11;
		VAR_9 = fb_set_user_cmap(&VAR_7, VAR_0);
		break;
	case VAR_17:
		if (copy_from_user(&VAR_7, VAR_8, sizeof(VAR_7)))
			return -VAR_11;
		lock_fb_info(VAR_0);
		VAR_6 = VAR_0->cmap;
		unlock_fb_info(VAR_0);
		VAR_9 = fb_cmap_to_user(&VAR_6, &VAR_7);
		break;
	case VAR_18:
		if (copy_from_user(&VAR_4, VAR_8, sizeof(VAR_4)))
			return -VAR_11;
		console_lock();
		lock_fb_info(VAR_0);
		VAR_9 = fb_pan_display(VAR_0, &VAR_4);
		unlock_fb_info(VAR_0);
		console_unlock();
		if (VAR_9 == 0 && copy_to_user(VAR_8, &VAR_4, sizeof(VAR_4)))
			return -VAR_11;
		break;
	case VAR_19:
		VAR_9 = -VAR_20;
		break;
	case VAR_21:
		VAR_9 = fbcon_get_con2fb_map_ioctl(VAR_8);
		break;
	case VAR_22:
		VAR_9 = fbcon_set_con2fb_map_ioctl(VAR_8);
		break;
	case VAR_23:
		if (VAR_2 > VAR_24)
			return -VAR_20;
		console_lock();
		lock_fb_info(VAR_0);
		VAR_9 = fb_blank(VAR_0, VAR_2);
		/* COMMENT_0 */
		fbcon_fb_blanked(VAR_0, VAR_2);
		unlock_fb_info(VAR_0);
		console_unlock();
		break;
	default:
		lock_fb_info(VAR_0);
		VAR_3 = VAR_0->fbops;
		if (VAR_3->fb_ioctl)
			VAR_9 = VAR_3->fb_ioctl(VAR_0, VAR_1, VAR_2);
		else
			VAR_9 = -VAR_25;
		unlock_fb_info(VAR_0);
	}
	return VAR_9;
}",torvalds/linux/086ff84617185393a0bbf25830c4f36412a7d3f4/fbmem.c/vul/after/1.json,"--- func_before
+++ func_after
@@ -22,7 +22,9 @@
 			return -EFAULT;
 		console_lock();
 		lock_fb_info(info);
-		ret = fb_set_var(info, &var);
+		ret = fbcon_modechange_possible(info, &var);
+		if (!ret)
+			ret = fb_set_var(info, &var);
 		if (!ret)
 			fbcon_update_vcs(info, var.activate & FB_ACTIVATE_ALL);
 		unlock_fb_info(info);","{'deleted_lines': ['\t\tret = fb_set_var(info, &var);'], 'added_lines': ['\t\tret = fbcon_modechange_possible(info, &var);', '\t\tif (!ret)', '\t\t\tret = fb_set_var(info, &var);']}",True,"When sending malicous data to kernel by ioctl cmd FBIOPUT_VSCREENINFO,kernel will write memory out of bounds.",6.7,MEDIUM,1,test,,5
CVE-2021-33655,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"Pull fbdev fixes from Helge Deller:

 - fbcon now prevents switching to screen resolutions which are smaller
   than the font size, and prevents enabling a font which is bigger than
   the current screen resolution. This fixes vmalloc-out-of-bounds
   accesses found by KASAN.

 - Guiling Deng fixed a bug where the centered fbdev logo wasn't
   displayed correctly if the screen size matched the logo size.

 - Hsin-Yi Wang provided a patch to include errno.h to fix build when
   CONFIG_OF isn't enabled.

* tag 'for-5.19/fbdev-3' of git://git.kernel.org/pub/scm/linux/kernel/git/deller/linux-fbdev:
  fbcon: Use fbcon_info_from_console() in fbcon_modechange_possible()
  fbmem: Check virtual screen sizes in fb_set_var()
  fbcon: Prevent that screen size is smaller than font size
  fbcon: Disallow setting font bigger than screen size
  video: of_display_timing.h: include errno.h
  fbdev: fbmem: Fix logo center image dx issue
",086ff84617185393a0bbf25830c4f36412a7d3f4,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=086ff84617185393a0bbf25830c4f36412a7d3f4,drivers/video/fbdev/core/fbmem.c,fb_show_logo_line,"static int fb_show_logo_line(struct fb_info *info, int rotate,
const struct linux_logo *logo, int y,
unsigned int n)
{
u32 *palette = NULL, *saved_pseudo_palette = NULL;
unsigned char *logo_new = NULL, *logo_rotate = NULL;
struct fb_image image;
if (logo == NULL || info->state != FBINFO_STATE_RUNNING ||
info->fbops->owner)
return 0;
image.depth = 8;
image.data = logo->data;
if (fb_logo.needs_cmapreset)
fb_set_logocmap(info, logo);
if (fb_logo.needs_truepalette ||
fb_logo.needs_directpalette) {
palette = kmalloc(256 * 4, GFP_KERNEL);
if (palette == NULL)
return 0;
if (fb_logo.needs_truepalette)
fb_set_logo_truepalette(info, logo, palette);
else
fb_set_logo_directpalette(info, logo, palette);
saved_pseudo_palette = info->pseudo_palette;
info->pseudo_palette = palette;
}
if (fb_logo.depth <= 4) {
logo_new = kmalloc_array(logo->width, logo->height,
GFP_KERNEL);
if (logo_new == NULL) {
kfree(palette);
if (saved_pseudo_palette)
info->pseudo_palette = saved_pseudo_palette;
return 0;
}
image.data = logo_new;
fb_set_logo(info, logo, logo_new, fb_logo.depth);
}
if (fb_center_logo) {
int xres = info->var.xres;
int yres = info->var.yres;
if (rotate == FB_ROTATE_CW || rotate == FB_ROTATE_CCW) {
xres = info->var.yres;
yres = info->var.xres;
}
while (n && (n * (logo->width + 8) - 8 > xres))
--n;
image.dx = (xres - n * (logo->width + 8) - 8) / 2;
image.dy = y ?: (yres - logo->height) / 2;
} else {
image.dx = 0;
image.dy = y;
}
image.width = logo->width;
image.height = logo->height;
if (rotate) {
logo_rotate = kmalloc_array(logo->width, logo->height,
GFP_KERNEL);
if (logo_rotate)
fb_rotate_logo(info, logo_rotate, &image, rotate);
}
fb_do_show_logo(info, &image, rotate, n);
kfree(palette);
if (saved_pseudo_palette != NULL)
info->pseudo_palette = saved_pseudo_palette;
kfree(logo_new);
kfree(logo_rotate);
return image.dy + logo->height;
}","static int fb_show_logo_line(struct fb_info *VAR_0, int VAR_1,
const struct linux_logo *VAR_2, int VAR_3,
unsigned int VAR_4)
{
u32 *VAR_5 = NULL, *VAR_6 = NULL;
unsigned char *VAR_7 = NULL, *VAR_8 = NULL;
struct fb_image VAR_9;
if (VAR_2 == NULL || VAR_0->state != VAR_10 ||
VAR_0->fbops->owner)
return 0;
VAR_9.depth = 8;
VAR_9.data = VAR_2->data;
if (VAR_11.needs_cmapreset)
fb_set_logocmap(VAR_0, VAR_2);
if (VAR_11.needs_truepalette ||
VAR_11.needs_directpalette) {
VAR_5 = kmalloc(256 * 4, VAR_12);
if (VAR_5 == NULL)
return 0;
if (VAR_11.needs_truepalette)
fb_set_logo_truepalette(VAR_0, VAR_2, VAR_5);
else
fb_set_logo_directpalette(VAR_0, VAR_2, VAR_5);
VAR_6 = VAR_0->pseudo_palette;
VAR_0->pseudo_palette = VAR_5;
}
if (VAR_11.depth <= 4) {
VAR_7 = kmalloc_array(VAR_2->width, VAR_2->height,
VAR_12);
if (VAR_7 == NULL) {
kfree(VAR_5);
if (VAR_6)
VAR_0->pseudo_palette = VAR_6;
return 0;
}
VAR_9.data = VAR_7;
fb_set_logo(VAR_0, VAR_2, VAR_7, VAR_11.depth);
}
if (VAR_13) {
int VAR_14 = VAR_0->var.xres;
int VAR_15 = VAR_0->var.yres;
if (VAR_1 == VAR_16 || VAR_1 == VAR_17) {
VAR_14 = VAR_0->var.yres;
VAR_15 = VAR_0->var.xres;
}
while (VAR_4 && (VAR_4 * (VAR_2->width + 8) - 8 > VAR_14))
--VAR_4;
VAR_9.dx = (VAR_14 - VAR_4 * (VAR_2->width + 8) - 8) / 2;
VAR_9.dy = VAR_3 ?VAR_18: (VAR_15 - VAR_2->height) / 2;
} else {
VAR_9.dx = 0;
VAR_9.dy = VAR_3;
}
VAR_9.width = VAR_2->width;
VAR_9.height = VAR_2->height;
if (VAR_1) {
VAR_8 = kmalloc_array(VAR_2->width, VAR_2->height,
VAR_12);
if (VAR_8)
fb_rotate_logo(VAR_0, VAR_8, &VAR_9, VAR_1);
}
fb_do_show_logo(VAR_0, &VAR_9, VAR_1, VAR_4);
kfree(VAR_5);
if (VAR_6 != NULL)
VAR_0->pseudo_palette = VAR_6;
kfree(VAR_7);
kfree(VAR_8);
return VAR_9.dy + VAR_2->height;
}",torvalds/linux/086ff84617185393a0bbf25830c4f36412a7d3f4/fbmem.c/vul/before/2.json,"static int fb_show_logo_line(struct fb_info *info, int rotate,
			     const struct linux_logo *logo, int y,
			     unsigned int n)
{
	u32 *palette = NULL, *saved_pseudo_palette = NULL;
	unsigned char *logo_new = NULL, *logo_rotate = NULL;
	struct fb_image image;

	/* Return if the frame buffer is not mapped or suspended */
	if (logo == NULL || info->state != FBINFO_STATE_RUNNING ||
	    info->fbops->owner)
		return 0;

	image.depth = 8;
	image.data = logo->data;

	if (fb_logo.needs_cmapreset)
		fb_set_logocmap(info, logo);

	if (fb_logo.needs_truepalette ||
	    fb_logo.needs_directpalette) {
		palette = kmalloc(256 * 4, GFP_KERNEL);
		if (palette == NULL)
			return 0;

		if (fb_logo.needs_truepalette)
			fb_set_logo_truepalette(info, logo, palette);
		else
			fb_set_logo_directpalette(info, logo, palette);

		saved_pseudo_palette = info->pseudo_palette;
		info->pseudo_palette = palette;
	}

	if (fb_logo.depth <= 4) {
		logo_new = kmalloc_array(logo->width, logo->height,
					 GFP_KERNEL);
		if (logo_new == NULL) {
			kfree(palette);
			if (saved_pseudo_palette)
				info->pseudo_palette = saved_pseudo_palette;
			return 0;
		}
		image.data = logo_new;
		fb_set_logo(info, logo, logo_new, fb_logo.depth);
	}

	if (fb_center_logo) {
		int xres = info->var.xres;
		int yres = info->var.yres;

		if (rotate == FB_ROTATE_CW || rotate == FB_ROTATE_CCW) {
			xres = info->var.yres;
			yres = info->var.xres;
		}

		while (n && (n * (logo->width + 8) - 8 > xres))
			--n;
		image.dx = (xres - (n * (logo->width + 8) - 8)) / 2;
		image.dy = y ?: (yres - logo->height) / 2;
	} else {
		image.dx = 0;
		image.dy = y;
	}

	image.width = logo->width;
	image.height = logo->height;

	if (rotate) {
		logo_rotate = kmalloc_array(logo->width, logo->height,
					    GFP_KERNEL);
		if (logo_rotate)
			fb_rotate_logo(info, logo_rotate, &image, rotate);
	}

	fb_do_show_logo(info, &image, rotate, n);

	kfree(palette);
	if (saved_pseudo_palette != NULL)
		info->pseudo_palette = saved_pseudo_palette;
	kfree(logo_new);
	kfree(logo_rotate);
	return image.dy + logo->height;
}","static int fb_show_logo_line(struct fb_info *VAR_0, int VAR_1,
			     const struct linux_logo *VAR_2, int VAR_3,
			     unsigned int VAR_4)
{
	u32 *VAR_5 = NULL, *VAR_6 = NULL;
	unsigned char *VAR_7 = NULL, *VAR_8 = NULL;
	struct fb_image VAR_9;

	/* COMMENT_0 */
	if (VAR_2 == NULL || VAR_0->state != VAR_10 ||
	    VAR_0->fbops->owner)
		return 0;

	VAR_9.depth = 8;
	VAR_9.data = VAR_2->data;

	if (VAR_11.needs_cmapreset)
		fb_set_logocmap(VAR_0, VAR_2);

	if (VAR_11.needs_truepalette ||
	    VAR_11.needs_directpalette) {
		VAR_5 = kmalloc(256 * 4, VAR_12);
		if (VAR_5 == NULL)
			return 0;

		if (VAR_11.needs_truepalette)
			fb_set_logo_truepalette(VAR_0, VAR_2, VAR_5);
		else
			fb_set_logo_directpalette(VAR_0, VAR_2, VAR_5);

		VAR_6 = VAR_0->pseudo_palette;
		VAR_0->pseudo_palette = VAR_5;
	}

	if (VAR_11.depth <= 4) {
		VAR_7 = kmalloc_array(VAR_2->width, VAR_2->height,
					 VAR_12);
		if (VAR_7 == NULL) {
			kfree(VAR_5);
			if (VAR_6)
				VAR_0->pseudo_palette = VAR_6;
			return 0;
		}
		VAR_9.data = VAR_7;
		fb_set_logo(VAR_0, VAR_2, VAR_7, VAR_11.depth);
	}

	if (VAR_13) {
		int VAR_14 = VAR_0->var.xres;
		int VAR_15 = VAR_0->var.yres;

		if (VAR_1 == VAR_16 || VAR_1 == VAR_17) {
			VAR_14 = VAR_0->var.yres;
			VAR_15 = VAR_0->var.xres;
		}

		while (VAR_4 && (VAR_4 * (VAR_2->width + 8) - 8 > VAR_14))
			--VAR_4;
		VAR_9.dx = (VAR_14 - (VAR_4 * (VAR_2->width + 8) - 8)) / 2;
		VAR_9.dy = VAR_3 ?VAR_18: (VAR_15 - VAR_2->height) / 2;
	} else {
		VAR_9.dx = 0;
		VAR_9.dy = VAR_3;
	}

	VAR_9.width = VAR_2->width;
	VAR_9.height = VAR_2->height;

	if (VAR_1) {
		VAR_8 = kmalloc_array(VAR_2->width, VAR_2->height,
					    VAR_12);
		if (VAR_8)
			fb_rotate_logo(VAR_0, VAR_8, &VAR_9, VAR_1);
	}

	fb_do_show_logo(VAR_0, &VAR_9, VAR_1, VAR_4);

	kfree(VAR_5);
	if (VAR_6 != NULL)
		VAR_0->pseudo_palette = VAR_6;
	kfree(VAR_7);
	kfree(VAR_8);
	return VAR_9.dy + VAR_2->height;
}",torvalds/linux/086ff84617185393a0bbf25830c4f36412a7d3f4/fbmem.c/vul/after/2.json,"--- func_before
+++ func_after
@@ -56,7 +56,7 @@
 
 		while (n && (n * (logo->width + 8) - 8 > xres))
 			--n;
-		image.dx = (xres - n * (logo->width + 8) - 8) / 2;
+		image.dx = (xres - (n * (logo->width + 8) - 8)) / 2;
 		image.dy = y ?: (yres - logo->height) / 2;
 	} else {
 		image.dx = 0;","{'deleted_lines': ['\t\timage.dx = (xres - n * (logo->width + 8) - 8) / 2;'], 'added_lines': ['\t\timage.dx = (xres - (n * (logo->width + 8) - 8)) / 2;']}",True,"When sending malicous data to kernel by ioctl cmd FBIOPUT_VSCREENINFO,kernel will write memory out of bounds.",6.7,MEDIUM,1,test,,5
CVE-2021-33655,['CWE-787'],CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H,1,torvalds/linux,"Pull fbdev fixes from Helge Deller:

 - fbcon now prevents switching to screen resolutions which are smaller
   than the font size, and prevents enabling a font which is bigger than
   the current screen resolution. This fixes vmalloc-out-of-bounds
   accesses found by KASAN.

 - Guiling Deng fixed a bug where the centered fbdev logo wasn't
   displayed correctly if the screen size matched the logo size.

 - Hsin-Yi Wang provided a patch to include errno.h to fix build when
   CONFIG_OF isn't enabled.

* tag 'for-5.19/fbdev-3' of git://git.kernel.org/pub/scm/linux/kernel/git/deller/linux-fbdev:
  fbcon: Use fbcon_info_from_console() in fbcon_modechange_possible()
  fbmem: Check virtual screen sizes in fb_set_var()
  fbcon: Prevent that screen size is smaller than font size
  fbcon: Disallow setting font bigger than screen size
  video: of_display_timing.h: include errno.h
  fbdev: fbmem: Fix logo center image dx issue
",086ff84617185393a0bbf25830c4f36412a7d3f4,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=086ff84617185393a0bbf25830c4f36412a7d3f4,drivers/video/fbdev/core/fbcon.c,fbcon_set_font,"static int fbcon_set_font(struct vc_data *vc, struct console_font *font,
unsigned int flags)
{
struct fb_info *info = fbcon_info_from_console(vc->vc_num);
unsigned charcount = font->charcount;
int w = font->width;
int h = font->height;
int size;
int i, csum;
u8 *new_data, *data = font->data;
int pitch = PITCH(font->width);
if (charcount != 256 && charcount != 512)
return -EINVAL;
if (!(info->pixmap.blit_x & (1 << (font->width - 1))) ||
!(info->pixmap.blit_y & (1 << (font->height - 1))))
return -EINVAL;
if (fbcon_invalid_charcount(info, charcount))
return -EINVAL;
size = CALC_FONTSZ(h, pitch, charcount);
new_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size, GFP_USER);
if (!new_data)
return -ENOMEM;
memset(new_data, 0, FONT_EXTRA_WORDS * sizeof(int));
new_data += FONT_EXTRA_WORDS * sizeof(int);
FNTSIZE(new_data) = size;
REFCOUNT(new_data) = 0;
for (i=0; i< charcount; i++) {
memcpy(new_data + i*h*pitch, data +  i*32*pitch, h*pitch);
}
csum = crc32(0, new_data, size);
FNTSUM(new_data) = csum;
for (i = first_fb_vc; i <= last_fb_vc; i++) {
struct vc_data *tmp = vc_cons[i].d;
if (fb_display[i].userfont &&
fb_display[i].fontdata &&
FNTSUM(fb_display[i].fontdata) == csum &&
FNTSIZE(fb_display[i].fontdata) == size &&
tmp->vc_font.width == w &&
!memcmp(fb_display[i].fontdata, new_data, size)) {
kfree(new_data - FONT_EXTRA_WORDS * sizeof(int));
new_data = (u8 *)fb_display[i].fontdata;
break;
}
}
return fbcon_do_set_font(vc, font->width, font->height, charcount, new_data, 1);
}","static int fbcon_set_font(struct vc_data *VAR_0, struct console_font *VAR_1,
unsigned int VAR_2)
{
struct fb_info *VAR_3 = fbcon_info_from_console(VAR_0->vc_num);
unsigned VAR_4 = VAR_1->charcount;
int VAR_5 = VAR_1->width;
int VAR_6 = VAR_1->height;
int VAR_7;
int VAR_8, VAR_9;
u8 *VAR_10, *VAR_11 = VAR_1->data;
int VAR_12 = PITCH(VAR_1->width);
if (VAR_4 != 256 && VAR_4 != 512)
return -VAR_13;
if (!(VAR_3->pixmap.blit_x & (1 << (VAR_1->width - 1))) ||
!(VAR_3->pixmap.blit_y & (1 << (VAR_1->height - 1))))
return -VAR_13;
if (fbcon_invalid_charcount(VAR_3, VAR_4))
return -VAR_13;
VAR_7 = CALC_FONTSZ(VAR_6, VAR_12, VAR_4);
VAR_10 = kmalloc(VAR_14 * sizeof(int) + VAR_7, VAR_15);
if (!VAR_10)
return -VAR_16;
memset(VAR_10, 0, VAR_14 * sizeof(int));
VAR_10 += VAR_14 * sizeof(int);
FNTSIZE(VAR_10) = VAR_7;
REFCOUNT(VAR_10) = 0;
for (VAR_8=0; VAR_8< VAR_4; VAR_8++) {
memcpy(VAR_10 + VAR_8*VAR_6*VAR_12, VAR_11 +  VAR_8*32*VAR_12, VAR_6*VAR_12);
}
VAR_9 = crc32(0, VAR_10, VAR_7);
FNTSUM(VAR_10) = VAR_9;
for (VAR_8 = VAR_17; VAR_8 <= VAR_18; VAR_8++) {
struct vc_data *VAR_19 = VAR_20[VAR_8].d;
if (VAR_21[VAR_8].userfont &&
VAR_21[VAR_8].fontdata &&
FNTSUM(VAR_21[VAR_8].fontdata) == VAR_9 &&
FNTSIZE(VAR_21[VAR_8].fontdata) == VAR_7 &&
VAR_19->vc_font.width == VAR_5 &&
!memcmp(VAR_21[VAR_8].fontdata, VAR_10, VAR_7)) {
kfree(VAR_10 - VAR_14 * sizeof(int));
VAR_10 = (u8 *)VAR_21[VAR_8].fontdata;
break;
}
}
return fbcon_do_set_font(VAR_0, VAR_1->width, VAR_1->height, VAR_4, VAR_10, 1);
}",torvalds/linux/086ff84617185393a0bbf25830c4f36412a7d3f4/fbcon.c/vul/before/0.json,"static int fbcon_set_font(struct vc_data *vc, struct console_font *font,
			  unsigned int flags)
{
	struct fb_info *info = fbcon_info_from_console(vc->vc_num);
	unsigned charcount = font->charcount;
	int w = font->width;
	int h = font->height;
	int size;
	int i, csum;
	u8 *new_data, *data = font->data;
	int pitch = PITCH(font->width);

	/* Is there a reason why fbconsole couldn't handle any charcount >256?
	 * If not this check should be changed to charcount < 256 */
	if (charcount != 256 && charcount != 512)
		return -EINVAL;

	/* font bigger than screen resolution ? */
	if (w > FBCON_SWAP(info->var.rotate, info->var.xres, info->var.yres) ||
	    h > FBCON_SWAP(info->var.rotate, info->var.yres, info->var.xres))
		return -EINVAL;

	/* Make sure drawing engine can handle the font */
	if (!(info->pixmap.blit_x & (1 << (font->width - 1))) ||
	    !(info->pixmap.blit_y & (1 << (font->height - 1))))
		return -EINVAL;

	/* Make sure driver can handle the font length */
	if (fbcon_invalid_charcount(info, charcount))
		return -EINVAL;

	size = CALC_FONTSZ(h, pitch, charcount);

	new_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size, GFP_USER);

	if (!new_data)
		return -ENOMEM;

	memset(new_data, 0, FONT_EXTRA_WORDS * sizeof(int));

	new_data += FONT_EXTRA_WORDS * sizeof(int);
	FNTSIZE(new_data) = size;
	REFCOUNT(new_data) = 0;	/* usage counter */
	for (i=0; i< charcount; i++) {
		memcpy(new_data + i*h*pitch, data +  i*32*pitch, h*pitch);
	}

	/* Since linux has a nice crc32 function use it for counting font
	 * checksums. */
	csum = crc32(0, new_data, size);

	FNTSUM(new_data) = csum;
	/* Check if the same font is on some other console already */
	for (i = first_fb_vc; i <= last_fb_vc; i++) {
		struct vc_data *tmp = vc_cons[i].d;
		
		if (fb_display[i].userfont &&
		    fb_display[i].fontdata &&
		    FNTSUM(fb_display[i].fontdata) == csum &&
		    FNTSIZE(fb_display[i].fontdata) == size &&
		    tmp->vc_font.width == w &&
		    !memcmp(fb_display[i].fontdata, new_data, size)) {
			kfree(new_data - FONT_EXTRA_WORDS * sizeof(int));
			new_data = (u8 *)fb_display[i].fontdata;
			break;
		}
	}
	return fbcon_do_set_font(vc, font->width, font->height, charcount, new_data, 1);
}","static int fbcon_set_font(struct vc_data *VAR_0, struct console_font *VAR_1,
			  unsigned int VAR_2)
{
	struct fb_info *VAR_3 = fbcon_info_from_console(VAR_0->vc_num);
	unsigned VAR_4 = VAR_1->charcount;
	int VAR_5 = VAR_1->width;
	int VAR_6 = VAR_1->height;
	int VAR_7;
	int VAR_8, VAR_9;
	u8 *VAR_10, *VAR_11 = VAR_1->data;
	int VAR_12 = PITCH(VAR_1->width);

	/* COMMENT_0 */
                                                             
	if (VAR_4 != 256 && VAR_4 != 512)
		return -VAR_13;

	/* COMMENT_2 */
	if (VAR_5 > FBCON_SWAP(VAR_3->var.rotate, VAR_3->var.xres, VAR_3->var.yres) ||
	    VAR_6 > FBCON_SWAP(VAR_3->var.rotate, VAR_3->var.yres, VAR_3->var.xres))
		return -VAR_13;

	/* COMMENT_3 */
	if (!(VAR_3->pixmap.blit_x & (1 << (VAR_1->width - 1))) ||
	    !(VAR_3->pixmap.blit_y & (1 << (VAR_1->height - 1))))
		return -VAR_13;

	/* COMMENT_4 */
	if (fbcon_invalid_charcount(VAR_3, VAR_4))
		return -VAR_13;

	VAR_7 = CALC_FONTSZ(VAR_6, VAR_12, VAR_4);

	VAR_10 = kmalloc(VAR_14 * sizeof(int) + VAR_7, VAR_15);

	if (!VAR_10)
		return -VAR_16;

	memset(VAR_10, 0, VAR_14 * sizeof(int));

	VAR_10 += VAR_14 * sizeof(int);
	FNTSIZE(VAR_10) = VAR_7;
	REFCOUNT(VAR_10) = 0;	/* COMMENT_5 */
	for (VAR_8=0; VAR_8< VAR_4; VAR_8++) {
		memcpy(VAR_10 + VAR_8*VAR_6*VAR_12, VAR_11 +  VAR_8*32*VAR_12, VAR_6*VAR_12);
	}

	/* COMMENT_6 */
                 
	VAR_9 = crc32(0, VAR_10, VAR_7);

	FNTSUM(VAR_10) = VAR_9;
	/* COMMENT_8 */
	for (VAR_8 = VAR_17; VAR_8 <= VAR_18; VAR_8++) {
		struct vc_data *VAR_19 = VAR_20[VAR_8].d;
		
		if (VAR_21[VAR_8].userfont &&
		    VAR_21[VAR_8].fontdata &&
		    FNTSUM(VAR_21[VAR_8].fontdata) == VAR_9 &&
		    FNTSIZE(VAR_21[VAR_8].fontdata) == VAR_7 &&
		    VAR_19->vc_font.width == VAR_5 &&
		    !memcmp(VAR_21[VAR_8].fontdata, VAR_10, VAR_7)) {
			kfree(VAR_10 - VAR_14 * sizeof(int));
			VAR_10 = (u8 *)VAR_21[VAR_8].fontdata;
			break;
		}
	}
	return fbcon_do_set_font(VAR_0, VAR_1->width, VAR_1->height, VAR_4, VAR_10, 1);
}",torvalds/linux/086ff84617185393a0bbf25830c4f36412a7d3f4/fbcon.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -13,6 +13,11 @@
 	/* Is there a reason why fbconsole couldn't handle any charcount >256?
 	 * If not this check should be changed to charcount < 256 */
 	if (charcount != 256 && charcount != 512)
+		return -EINVAL;
+
+	/* font bigger than screen resolution ? */
+	if (w > FBCON_SWAP(info->var.rotate, info->var.xres, info->var.yres) ||
+	    h > FBCON_SWAP(info->var.rotate, info->var.yres, info->var.xres))
 		return -EINVAL;
 
 	/* Make sure drawing engine can handle the font */","{'deleted_lines': [], 'added_lines': ['\t\treturn -EINVAL;', '', '\t/* font bigger than screen resolution ? */', '\tif (w > FBCON_SWAP(info->var.rotate, info->var.xres, info->var.yres) ||', '\t    h > FBCON_SWAP(info->var.rotate, info->var.yres, info->var.xres))']}",True,"When sending malicous data to kernel by ioctl cmd FBIOPUT_VSCREENINFO,kernel will write memory out of bounds.",6.7,MEDIUM,1,test,,5
CVE-2020-11494,"['CWE-908', 'CWE-909']",AV:L/AC:L/Au:N/C:P/I:N/A:N,0,kernel/git/tip/tip,"commit b9258a2cece4ec1f020715fe3554bc2e360f6264 upstream.

struct can_frame contains some padding which is not explicitly zeroed in
slc_bump. This uninitialized data will then be transmitted if the stack
initialization hardening feature is not enabled (CONFIG_INIT_STACK_ALL).

This commit just zeroes the whole struct including the padding.

Signed-off-by: Richard Palethorpe <rpalethorpe@suse.com>
Fixes: a1044e36e457 (""can: add slcan driver for serial/USB-serial CAN adapters"")
Reviewed-by: Kees Cook <keescook@chromium.org>
Cc: linux-can@vger.kernel.org
Cc: netdev@vger.kernel.org
Cc: security@kernel.org
Cc: wg@grandegger.com
Cc: mkl@pengutronix.de
Cc: davem@davemloft.net
Acked-by: Marc Kleine-Budde <mkl@pengutronix.de>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
",08fadc32ce6239dc75fd5e869590e29bc62bbc28,https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?h=08fadc32ce6239dc75fd5e869590e29bc62bbc28,drivers/net/can/slcan.c,slc_bump,"static void slc_bump(struct slcan *sl)
{
struct sk_buff *skb;
struct can_frame cf;
int i, tmp;
u32 tmpid;
char *cmd = sl->rbuff;
cf.can_id = 0;
switch (*cmd) {
case 'r':
cf.can_id = CAN_RTR_FLAG;
case 't':
cf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN];
sl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN] = 0;
cmd += SLC_CMD_LEN + SLC_SFF_ID_LEN + 1;
break;
case 'R':
cf.can_id = CAN_RTR_FLAG;
case 'T':
cf.can_id |= CAN_EFF_FLAG;
cf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN];
sl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN] = 0;
cmd += SLC_CMD_LEN + SLC_EFF_ID_LEN + 1;
break;
default:
return;
}
if (kstrtou32(sl->rbuff + SLC_CMD_LEN, 16, &tmpid))
return;
cf.can_id |= tmpid;
if (cf.can_dlc >= '0' && cf.can_dlc < '9')
cf.can_dlc -= '0';
else
return;
*(u64 *) (&cf.data) = 0; 
if (!(cf.can_id & CAN_RTR_FLAG)) {
for (i = 0; i < cf.can_dlc; i++) {
tmp = hex_to_bin(*cmd++);
if (tmp < 0)
return;
cf.data[i] = (tmp << 4);
tmp = hex_to_bin(*cmd++);
if (tmp < 0)
return;
cf.data[i] |= tmp;
}
}
skb = dev_alloc_skb(sizeof(struct can_frame) +
sizeof(struct can_skb_priv));
if (!skb)
return;
skb->dev = sl->dev;
skb->protocol = htons(ETH_P_CAN);
skb->pkt_type = PACKET_BROADCAST;
skb->ip_summed = CHECKSUM_UNNECESSARY;
can_skb_reserve(skb);
can_skb_prv(skb)->ifindex = sl->dev->ifindex;
memcpy(skb_put(skb, sizeof(struct can_frame)),
&cf, sizeof(struct can_frame));
netif_rx_ni(skb);
sl->dev->stats.rx_packets++;
sl->dev->stats.rx_bytes += cf.can_dlc;
}","static void slc_bump(struct slcan *VAR_0)
{
struct sk_buff *VAR_1;
struct can_frame VAR_2;
int VAR_3, VAR_4;
u32 VAR_5;
char *VAR_6 = VAR_0->rbuff;
VAR_2.can_id = 0;
switch (*VAR_6) {
case 'r':
VAR_2.can_id = VAR_7;
case 't':
VAR_2.can_dlc = VAR_0->rbuff[VAR_8 + VAR_9];
VAR_0->rbuff[VAR_8 + VAR_9] = 0;
VAR_6 += VAR_8 + VAR_9 + 1;
break;
case 'R':
VAR_2.can_id = VAR_7;
case 'T':
VAR_2.can_id |= VAR_10;
VAR_2.can_dlc = VAR_0->rbuff[VAR_8 + VAR_11];
VAR_0->rbuff[VAR_8 + VAR_11] = 0;
VAR_6 += VAR_8 + VAR_11 + 1;
break;
default:
return;
}
if (kstrtou32(VAR_0->rbuff + VAR_8, 16, &VAR_5))
return;
VAR_2.can_id |= VAR_5;
if (VAR_2.can_dlc >= '0' && VAR_2.can_dlc < '9')
VAR_2.can_dlc -= '0';
else
return;
*(u64 *) (&VAR_2.data) = 0; 
if (!(VAR_2.can_id & VAR_7)) {
for (VAR_3 = 0; VAR_3 < VAR_2.can_dlc; VAR_3++) {
VAR_4 = hex_to_bin(*VAR_6++);
if (VAR_4 < 0)
return;
VAR_2.data[VAR_3] = (VAR_4 << 4);
VAR_4 = hex_to_bin(*VAR_6++);
if (VAR_4 < 0)
return;
VAR_2.data[VAR_3] |= VAR_4;
}
}
VAR_1 = dev_alloc_skb(sizeof(struct can_frame) +
sizeof(struct can_skb_priv));
if (!VAR_1)
return;
VAR_1->dev = VAR_0->dev;
VAR_1->protocol = htons(VAR_12);
VAR_1->pkt_type = VAR_13;
VAR_1->ip_summed = VAR_14;
can_skb_reserve(VAR_1);
can_skb_prv(VAR_1)->ifindex = VAR_0->dev->ifindex;
memcpy(skb_put(VAR_1, sizeof(struct can_frame)),
&VAR_2, sizeof(struct can_frame));
netif_rx_ni(VAR_1);
VAR_0->dev->stats.rx_packets++;
VAR_0->dev->stats.rx_bytes += VAR_2.can_dlc;
}",kernel/git/tip/tip/08fadc32ce6239dc75fd5e869590e29bc62bbc28/slcan.c/vul/before/0.json,"static void slc_bump(struct slcan *sl)
{
	struct sk_buff *skb;
	struct can_frame cf;
	int i, tmp;
	u32 tmpid;
	char *cmd = sl->rbuff;

	memset(&cf, 0, sizeof(cf));

	switch (*cmd) {
	case 'r':
		cf.can_id = CAN_RTR_FLAG;
		/* fallthrough */
	case 't':
		/* store dlc ASCII value and terminate SFF CAN ID string */
		cf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN];
		sl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN] = 0;
		/* point to payload data behind the dlc */
		cmd += SLC_CMD_LEN + SLC_SFF_ID_LEN + 1;
		break;
	case 'R':
		cf.can_id = CAN_RTR_FLAG;
		/* fallthrough */
	case 'T':
		cf.can_id |= CAN_EFF_FLAG;
		/* store dlc ASCII value and terminate EFF CAN ID string */
		cf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN];
		sl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN] = 0;
		/* point to payload data behind the dlc */
		cmd += SLC_CMD_LEN + SLC_EFF_ID_LEN + 1;
		break;
	default:
		return;
	}

	if (kstrtou32(sl->rbuff + SLC_CMD_LEN, 16, &tmpid))
		return;

	cf.can_id |= tmpid;

	/* get can_dlc from sanitized ASCII value */
	if (cf.can_dlc >= '0' && cf.can_dlc < '9')
		cf.can_dlc -= '0';
	else
		return;

	/* RTR frames may have a dlc > 0 but they never have any data bytes */
	if (!(cf.can_id & CAN_RTR_FLAG)) {
		for (i = 0; i < cf.can_dlc; i++) {
			tmp = hex_to_bin(*cmd++);
			if (tmp < 0)
				return;
			cf.data[i] = (tmp << 4);
			tmp = hex_to_bin(*cmd++);
			if (tmp < 0)
				return;
			cf.data[i] |= tmp;
		}
	}

	skb = dev_alloc_skb(sizeof(struct can_frame) +
			    sizeof(struct can_skb_priv));
	if (!skb)
		return;

	skb->dev = sl->dev;
	skb->protocol = htons(ETH_P_CAN);
	skb->pkt_type = PACKET_BROADCAST;
	skb->ip_summed = CHECKSUM_UNNECESSARY;

	can_skb_reserve(skb);
	can_skb_prv(skb)->ifindex = sl->dev->ifindex;

	memcpy(skb_put(skb, sizeof(struct can_frame)),
	       &cf, sizeof(struct can_frame));
	netif_rx_ni(skb);

	sl->dev->stats.rx_packets++;
	sl->dev->stats.rx_bytes += cf.can_dlc;
}","static void slc_bump(struct slcan *VAR_0)
{
	struct sk_buff *VAR_1;
	struct can_frame VAR_2;
	int VAR_3, VAR_4;
	u32 VAR_5;
	char *VAR_6 = VAR_0->rbuff;

	memset(&VAR_2, 0, sizeof(VAR_2));

	switch (*VAR_6) {
	case 'r':
		VAR_2.can_id = VAR_7;
		/* COMMENT_0 */
	case 't':
		/* COMMENT_1 */
		VAR_2.can_dlc = VAR_0->rbuff[VAR_8 + VAR_9];
		VAR_0->rbuff[VAR_8 + VAR_9] = 0;
		/* COMMENT_2 */
		VAR_6 += VAR_8 + VAR_9 + 1;
		break;
	case 'R':
		VAR_2.can_id = VAR_7;
		/* COMMENT_0 */
	case 'T':
		VAR_2.can_id |= VAR_10;
		/* COMMENT_3 */
		VAR_2.can_dlc = VAR_0->rbuff[VAR_8 + VAR_11];
		VAR_0->rbuff[VAR_8 + VAR_11] = 0;
		/* COMMENT_2 */
		VAR_6 += VAR_8 + VAR_11 + 1;
		break;
	default:
		return;
	}

	if (kstrtou32(VAR_0->rbuff + VAR_8, 16, &VAR_5))
		return;

	VAR_2.can_id |= VAR_5;

	/* COMMENT_4 */
	if (VAR_2.can_dlc >= '0' && VAR_2.can_dlc < '9')
		VAR_2.can_dlc -= '0';
	else
		return;

	/* COMMENT_5 */
	if (!(VAR_2.can_id & VAR_7)) {
		for (VAR_3 = 0; VAR_3 < VAR_2.can_dlc; VAR_3++) {
			VAR_4 = hex_to_bin(*VAR_6++);
			if (VAR_4 < 0)
				return;
			VAR_2.data[VAR_3] = (VAR_4 << 4);
			VAR_4 = hex_to_bin(*VAR_6++);
			if (VAR_4 < 0)
				return;
			VAR_2.data[VAR_3] |= VAR_4;
		}
	}

	VAR_1 = dev_alloc_skb(sizeof(struct can_frame) +
			    sizeof(struct can_skb_priv));
	if (!VAR_1)
		return;

	VAR_1->dev = VAR_0->dev;
	VAR_1->protocol = htons(VAR_12);
	VAR_1->pkt_type = VAR_13;
	VAR_1->ip_summed = VAR_14;

	can_skb_reserve(VAR_1);
	can_skb_prv(VAR_1)->ifindex = VAR_0->dev->ifindex;

	memcpy(skb_put(VAR_1, sizeof(struct can_frame)),
	       &VAR_2, sizeof(struct can_frame));
	netif_rx_ni(VAR_1);

	VAR_0->dev->stats.rx_packets++;
	VAR_0->dev->stats.rx_bytes += VAR_2.can_dlc;
}",kernel/git/tip/tip/08fadc32ce6239dc75fd5e869590e29bc62bbc28/slcan.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -6,7 +6,7 @@
 	u32 tmpid;
 	char *cmd = sl->rbuff;
 
-	cf.can_id = 0;
+	memset(&cf, 0, sizeof(cf));
 
 	switch (*cmd) {
 	case 'r':
@@ -45,8 +45,6 @@
 	else
 		return;
 
-	*(u64 *) (&cf.data) = 0; /* clear payload */
-
 	/* RTR frames may have a dlc > 0 but they never have any data bytes */
 	if (!(cf.can_id & CAN_RTR_FLAG)) {
 		for (i = 0; i < cf.can_dlc; i++) {","{'deleted_lines': ['\tcf.can_id = 0;', '\t*(u64 *) (&cf.data) = 0; /* clear payload */', ''], 'added_lines': ['\tmemset(&cf, 0, sizeof(cf));']}",True,"An issue was discovered in slc_bump in drivers/net/can/slcan.c in the Linux kernel 3.16 through 5.6.2. It allows attackers to read uninitialized can_frame data, potentially containing sensitive information from kernel stack memory, if the configuration lacks CONFIG_INIT_STACK_ALL, aka CID-b9258a2cece4.",4.4,MEDIUM,1,test,,5
CVE-2020-1967,['CWE-476'],AV:N/AC:L/Au:N/C:N/I:N/A:P,0,openssl,"
Fix NULL dereference in SSL_check_chain() for TLS 1.3

In the tls1_check_sig_alg() helper function, we loop through the list of
""signature_algorithms_cert"" values received from the client and attempt
to look up each one in turn in our internal table that maps wire
codepoint to string-form name, digest and/or signature NID, etc., in
order to compare the signature scheme from the peer's list against what
is used to sign the certificates in the certificate chain we're
checking.  Unfortunately, when the peer sends a value that we don't
support, the lookup returns NULL, but we unconditionally dereference the
lookup result for the comparison, leading to an application crash
triggerable by an unauthenticated client.

Since we will not be able to say anything about algorithms we don't
recognize, treat NULL return from lookup as ""does not match"".

We currently only apply the ""signature_algorithm_cert"" checks on TLS 1.3
connections, so previous TLS versions are unaffected.  SSL_check_chain()
is not called directly from libssl, but may be used by the application
inside a callback (e.g., client_hello or cert callback) to verify that a
candidate certificate chain will be acceptable to the client.

CVE-2020-1967

Reviewed-by: Matt Caswell <matt@openssl.org>
",eb563247aef3e83dda7679c43f9649270462e5b1,https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=eb563247aef3e83dda7679c43f9649270462e5b1,ssl/t1_lib.c,tls1_check_sig_alg,"static int tls1_check_sig_alg(SSL *s, X509 *x, int default_nid)
{
int sig_nid, use_pc_sigalgs = 0;
size_t i;
const SIGALG_LOOKUP *sigalg;
size_t sigalgslen;
if (default_nid == -1)
return 1;
sig_nid = X509_get_signature_nid(x);
if (default_nid)
return sig_nid == default_nid ? 1 : 0;
if (SSL_IS_TLS13(s) && s->s3->tmp.peer_cert_sigalgs != NULL) {
sigalgslen = s->s3->tmp.peer_cert_sigalgslen;
use_pc_sigalgs = 1;
} else {
sigalgslen = s->shared_sigalgslen;
}
for (i = 0; i < sigalgslen; i++) {
sigalg = use_pc_sigalgs
? tls1_lookup_sigalg(s->s3->tmp.peer_cert_sigalgs[i])
: s->shared_sigalgs[i];
if (sig_nid == sigalg->sigandhash)
return 1;
}
return 0;
}","static int tls1_check_sig_alg(SSL *VAR_0, X509 *VAR_1, int VAR_2)
{
int VAR_3, VAR_4 = 0;
size_t VAR_5;
const SIGALG_LOOKUP *VAR_6;
size_t VAR_7;
if (VAR_2 == -1)
return 1;
VAR_3 = X509_get_signature_nid(VAR_1);
if (VAR_2)
return VAR_3 == VAR_2 ? 1 : 0;
if (SSL_IS_TLS13(VAR_0) && VAR_0->s3->tmp.peer_cert_sigalgs != NULL) {
VAR_7 = VAR_0->s3->tmp.peer_cert_sigalgslen;
VAR_4 = 1;
} else {
VAR_7 = VAR_0->shared_sigalgslen;
}
for (VAR_5 = 0; VAR_5 < VAR_7; VAR_5++) {
VAR_6 = VAR_4
? tls1_lookup_sigalg(VAR_0->s3->tmp.peer_cert_sigalgs[VAR_5])
: VAR_0->shared_sigalgs[VAR_5];
if (VAR_3 == VAR_6->sigandhash)
return 1;
}
return 0;
}",openssl/eb563247aef3e83dda7679c43f9649270462e5b1/t1_lib.c/vul/before/0.json,"static int tls1_check_sig_alg(SSL *s, X509 *x, int default_nid)
{
    int sig_nid, use_pc_sigalgs = 0;
    size_t i;
    const SIGALG_LOOKUP *sigalg;
    size_t sigalgslen;
    if (default_nid == -1)
        return 1;
    sig_nid = X509_get_signature_nid(x);
    if (default_nid)
        return sig_nid == default_nid ? 1 : 0;

    if (SSL_IS_TLS13(s) && s->s3->tmp.peer_cert_sigalgs != NULL) {
        /*
         * If we're in TLSv1.3 then we only get here if we're checking the
         * chain. If the peer has specified peer_cert_sigalgs then we use them
         * otherwise we default to normal sigalgs.
         */
        sigalgslen = s->s3->tmp.peer_cert_sigalgslen;
        use_pc_sigalgs = 1;
    } else {
        sigalgslen = s->shared_sigalgslen;
    }
    for (i = 0; i < sigalgslen; i++) {
        sigalg = use_pc_sigalgs
                 ? tls1_lookup_sigalg(s->s3->tmp.peer_cert_sigalgs[i])
                 : s->shared_sigalgs[i];
        if (sigalg != NULL && sig_nid == sigalg->sigandhash)
            return 1;
    }
    return 0;
}","static int tls1_check_sig_alg(SSL *VAR_0, X509 *VAR_1, int VAR_2)
{
    int VAR_3, VAR_4 = 0;
    size_t VAR_5;
    const SIGALG_LOOKUP *VAR_6;
    size_t VAR_7;
    if (VAR_2 == -1)
        return 1;
    VAR_3 = X509_get_signature_nid(VAR_1);
    if (VAR_2)
        return VAR_3 == VAR_2 ? 1 : 0;

    if (SSL_IS_TLS13(VAR_0) && VAR_0->s3->tmp.peer_cert_sigalgs != NULL) {
        /* COMMENT_0 */
                                                                          
                                                                              
                                                  
           
        VAR_7 = VAR_0->s3->tmp.peer_cert_sigalgslen;
        VAR_4 = 1;
    } else {
        VAR_7 = VAR_0->shared_sigalgslen;
    }
    for (VAR_5 = 0; VAR_5 < VAR_7; VAR_5++) {
        VAR_6 = VAR_4
                 ? tls1_lookup_sigalg(VAR_0->s3->tmp.peer_cert_sigalgs[VAR_5])
                 : VAR_0->shared_sigalgs[VAR_5];
        if (VAR_6 != NULL && VAR_3 == VAR_6->sigandhash)
            return 1;
    }
    return 0;
}",openssl/eb563247aef3e83dda7679c43f9649270462e5b1/t1_lib.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -25,7 +25,7 @@
         sigalg = use_pc_sigalgs
                  ? tls1_lookup_sigalg(s->s3->tmp.peer_cert_sigalgs[i])
                  : s->shared_sigalgs[i];
-        if (sig_nid == sigalg->sigandhash)
+        if (sigalg != NULL && sig_nid == sigalg->sigandhash)
             return 1;
     }
     return 0;","{'deleted_lines': ['        if (sig_nid == sigalg->sigandhash)'], 'added_lines': ['        if (sigalg != NULL && sig_nid == sigalg->sigandhash)']}",True,"Server or client applications that call the SSL_check_chain() function during or after a TLS 1.3 handshake may crash due to a NULL pointer dereference as a result of incorrect handling of the ""signature_algorithms_cert"" TLS extension. The crash occurs if an invalid or unrecognised signature algorithm is received from the peer. This could be exploited by a malicious peer in a Denial of Service attack. OpenSSL version 1.1.1d, 1.1.1e, and 1.1.1f are affected by this issue. This issue did not affect OpenSSL versions prior to 1.1.1d. Fixed in OpenSSL 1.1.1g (Affected 1.1.1d-1.1.1f).",7.5,HIGH,2,test,,5
CVE-2019-20810,['CWE-401'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,torvalds/linux,"go7007_snd_init() misses a snd_card_free() in an error path.
Add the missed call to fix it.

Signed-off-by: Chuhong Yuan <hslester96@gmail.com>
Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
",9453264ef58638ce8976121ac44c07a3ef375983,https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=9453264ef58638ce8976121ac44c07a3ef375983,drivers/media/usb/go7007/snd-go7007.c,go7007_snd_init,"int go7007_snd_init(struct go7007 *go)
{
static int dev;
struct go7007_snd *gosnd;
int ret;
if (dev >= SNDRV_CARDS)
return -ENODEV;
if (!enable[dev]) {
dev++;
return -ENOENT;
}
gosnd = kmalloc(sizeof(struct go7007_snd), GFP_KERNEL);
if (gosnd == NULL)
return -ENOMEM;
spin_lock_init(&gosnd->lock);
gosnd->hw_ptr = gosnd->w_idx = gosnd->avail = 0;
gosnd->capturing = 0;
ret = snd_card_new(go->dev, index[dev], id[dev], THIS_MODULE, 0,
&gosnd->card);
if (ret < 0) {
kfree(gosnd);
return ret;
}
ret = snd_device_new(gosnd->card, SNDRV_DEV_LOWLEVEL, go,
&go7007_snd_device_ops);
if (ret < 0) {
kfree(gosnd);
return ret;
}
ret = snd_pcm_new(gosnd->card, ""go7007"", 0, 0, 1, &gosnd->pcm);
if (ret < 0) {
snd_card_free(gosnd->card);
kfree(gosnd);
return ret;
}
strscpy(gosnd->card->driver, ""go7007"", sizeof(gosnd->card->driver));
strscpy(gosnd->card->shortname, go->name, sizeof(gosnd->card->shortname));
strscpy(gosnd->card->longname, gosnd->card->shortname,
sizeof(gosnd->card->longname));
gosnd->pcm->private_data = go;
snd_pcm_set_ops(gosnd->pcm, SNDRV_PCM_STREAM_CAPTURE,
&go7007_snd_capture_ops);
ret = snd_card_register(gosnd->card);
if (ret < 0) {
snd_card_free(gosnd->card);
kfree(gosnd);
return ret;
}
gosnd->substream = NULL;
go->snd_context = gosnd;
v4l2_device_get(&go->v4l2_dev);
++dev;
return 0;
}","int go7007_snd_init(struct go7007 *VAR_0)
{
static int VAR_1;
struct go7007_snd *VAR_2;
int VAR_3;
if (VAR_1 >= VAR_4)
return -VAR_5;
if (!VAR_6[VAR_1]) {
VAR_1++;
return -VAR_7;
}
VAR_2 = kmalloc(sizeof(struct go7007_snd), VAR_8);
if (VAR_2 == NULL)
return -VAR_9;
spin_lock_init(&VAR_2->lock);
VAR_2->hw_ptr = VAR_2->w_idx = VAR_2->avail = 0;
VAR_2->capturing = 0;
VAR_3 = snd_card_new(VAR_0->dev, VAR_10[VAR_1], VAR_11[VAR_1], VAR_12, 0,
&VAR_2->card);
if (VAR_3 < 0) {
kfree(VAR_2);
return VAR_3;
}
VAR_3 = snd_device_new(VAR_2->card, VAR_13, VAR_0,
&VAR_14);
if (VAR_3 < 0) {
kfree(VAR_2);
return VAR_3;
}
VAR_3 = snd_pcm_new(VAR_2->card, ""go7007"", 0, 0, 1, &VAR_2->pcm);
if (VAR_3 < 0) {
snd_card_free(VAR_2->card);
kfree(VAR_2);
return VAR_3;
}
strscpy(VAR_2->card->driver, ""go7007"", sizeof(VAR_2->card->driver));
strscpy(VAR_2->card->shortname, VAR_0->name, sizeof(VAR_2->card->shortname));
strscpy(VAR_2->card->longname, VAR_2->card->shortname,
sizeof(VAR_2->card->longname));
VAR_2->pcm->private_data = VAR_0;
snd_pcm_set_ops(VAR_2->pcm, VAR_15,
&VAR_16);
VAR_3 = snd_card_register(VAR_2->card);
if (VAR_3 < 0) {
snd_card_free(VAR_2->card);
kfree(VAR_2);
return VAR_3;
}
VAR_2->substream = NULL;
VAR_0->snd_context = VAR_2;
v4l2_device_get(&VAR_0->v4l2_dev);
++VAR_1;
return 0;
}",torvalds/linux/9453264ef58638ce8976121ac44c07a3ef375983/snd-go7007.c/vul/before/0.json,"int go7007_snd_init(struct go7007 *go)
{
	static int dev;
	struct go7007_snd *gosnd;
	int ret;

	if (dev >= SNDRV_CARDS)
		return -ENODEV;
	if (!enable[dev]) {
		dev++;
		return -ENOENT;
	}
	gosnd = kmalloc(sizeof(struct go7007_snd), GFP_KERNEL);
	if (gosnd == NULL)
		return -ENOMEM;
	spin_lock_init(&gosnd->lock);
	gosnd->hw_ptr = gosnd->w_idx = gosnd->avail = 0;
	gosnd->capturing = 0;
	ret = snd_card_new(go->dev, index[dev], id[dev], THIS_MODULE, 0,
			   &gosnd->card);
	if (ret < 0)
		goto free_snd;

	ret = snd_device_new(gosnd->card, SNDRV_DEV_LOWLEVEL, go,
			&go7007_snd_device_ops);
	if (ret < 0)
		goto free_card;

	ret = snd_pcm_new(gosnd->card, ""go7007"", 0, 0, 1, &gosnd->pcm);
	if (ret < 0)
		goto free_card;

	strscpy(gosnd->card->driver, ""go7007"", sizeof(gosnd->card->driver));
	strscpy(gosnd->card->shortname, go->name, sizeof(gosnd->card->shortname));
	strscpy(gosnd->card->longname, gosnd->card->shortname,
		sizeof(gosnd->card->longname));

	gosnd->pcm->private_data = go;
	snd_pcm_set_ops(gosnd->pcm, SNDRV_PCM_STREAM_CAPTURE,
			&go7007_snd_capture_ops);

	ret = snd_card_register(gosnd->card);
	if (ret < 0)
		goto free_card;

	gosnd->substream = NULL;
	go->snd_context = gosnd;
	v4l2_device_get(&go->v4l2_dev);
	++dev;

	return 0;

free_card:
	snd_card_free(gosnd->card);
free_snd:
	kfree(gosnd);
	return ret;
}","int go7007_snd_init(struct go7007 *VAR_0)
{
	static int VAR_1;
	struct go7007_snd *VAR_2;
	int VAR_3;

	if (VAR_1 >= VAR_4)
		return -VAR_5;
	if (!VAR_6[VAR_1]) {
		VAR_1++;
		return -VAR_7;
	}
	VAR_2 = kmalloc(sizeof(struct go7007_snd), VAR_8);
	if (VAR_2 == NULL)
		return -VAR_9;
	spin_lock_init(&VAR_2->lock);
	VAR_2->hw_ptr = VAR_2->w_idx = VAR_2->avail = 0;
	VAR_2->capturing = 0;
	VAR_3 = snd_card_new(VAR_0->dev, VAR_10[VAR_1], VAR_11[VAR_1], VAR_12, 0,
			   &VAR_2->card);
	if (VAR_3 < 0)
		goto free_snd;

	VAR_3 = snd_device_new(VAR_2->card, VAR_13, VAR_0,
			&VAR_14);
	if (VAR_3 < 0)
		goto free_card;

	VAR_3 = snd_pcm_new(VAR_2->card, ""go7007"", 0, 0, 1, &VAR_2->pcm);
	if (VAR_3 < 0)
		goto free_card;

	strscpy(VAR_2->card->driver, ""go7007"", sizeof(VAR_2->card->driver));
	strscpy(VAR_2->card->shortname, VAR_0->name, sizeof(VAR_2->card->shortname));
	strscpy(VAR_2->card->longname, VAR_2->card->shortname,
		sizeof(VAR_2->card->longname));

	VAR_2->pcm->private_data = VAR_0;
	snd_pcm_set_ops(VAR_2->pcm, VAR_15,
			&VAR_16);

	VAR_3 = snd_card_register(VAR_2->card);
	if (VAR_3 < 0)
		goto free_card;

	VAR_2->substream = NULL;
	VAR_0->snd_context = VAR_2;
	v4l2_device_get(&VAR_0->v4l2_dev);
	++VAR_1;

	return 0;

free_card:
	snd_card_free(VAR_2->card);
free_snd:
	kfree(VAR_2);
	return VAR_3;
}",torvalds/linux/9453264ef58638ce8976121ac44c07a3ef375983/snd-go7007.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -18,22 +18,18 @@
 	gosnd->capturing = 0;
 	ret = snd_card_new(go->dev, index[dev], id[dev], THIS_MODULE, 0,
 			   &gosnd->card);
-	if (ret < 0) {
-		kfree(gosnd);
-		return ret;
-	}
+	if (ret < 0)
+		goto free_snd;
+
 	ret = snd_device_new(gosnd->card, SNDRV_DEV_LOWLEVEL, go,
 			&go7007_snd_device_ops);
-	if (ret < 0) {
-		kfree(gosnd);
-		return ret;
-	}
+	if (ret < 0)
+		goto free_card;
+
 	ret = snd_pcm_new(gosnd->card, ""go7007"", 0, 0, 1, &gosnd->pcm);
-	if (ret < 0) {
-		snd_card_free(gosnd->card);
-		kfree(gosnd);
-		return ret;
-	}
+	if (ret < 0)
+		goto free_card;
+
 	strscpy(gosnd->card->driver, ""go7007"", sizeof(gosnd->card->driver));
 	strscpy(gosnd->card->shortname, go->name, sizeof(gosnd->card->shortname));
 	strscpy(gosnd->card->longname, gosnd->card->shortname,
@@ -44,11 +40,8 @@
 			&go7007_snd_capture_ops);
 
 	ret = snd_card_register(gosnd->card);
-	if (ret < 0) {
-		snd_card_free(gosnd->card);
-		kfree(gosnd);
-		return ret;
-	}
+	if (ret < 0)
+		goto free_card;
 
 	gosnd->substream = NULL;
 	go->snd_context = gosnd;
@@ -56,4 +49,10 @@
 	++dev;
 
 	return 0;
+
+free_card:
+	snd_card_free(gosnd->card);
+free_snd:
+	kfree(gosnd);
+	return ret;
 }","{'deleted_lines': ['\tif (ret < 0) {', '\t\tkfree(gosnd);', '\t\treturn ret;', '\t}', '\tif (ret < 0) {', '\t\tkfree(gosnd);', '\t\treturn ret;', '\t}', '\tif (ret < 0) {', '\t\tsnd_card_free(gosnd->card);', '\t\tkfree(gosnd);', '\t\treturn ret;', '\t}', '\tif (ret < 0) {', '\t\tsnd_card_free(gosnd->card);', '\t\tkfree(gosnd);', '\t\treturn ret;', '\t}'], 'added_lines': ['\tif (ret < 0)', '\t\tgoto free_snd;', '', '\tif (ret < 0)', '\t\tgoto free_card;', '', '\tif (ret < 0)', '\t\tgoto free_card;', '', '\tif (ret < 0)', '\t\tgoto free_card;', '', 'free_card:', '\tsnd_card_free(gosnd->card);', 'free_snd:', '\tkfree(gosnd);', '\treturn ret;']}",True,"go7007_snd_init in drivers/media/usb/go7007/snd-go7007.c in the Linux kernel before 5.6 does not call snd_card_free for a failure path, which causes a memory leak, aka CID-9453264ef586.",5.5,MEDIUM,1,test,,5
CVE-2020-12049,['CWE-404'],AV:L/AC:L/Au:N/C:N/I:N/A:C,0,dbus,"MSG_CTRUNC indicates that we have received fewer fds that we should
have done because the buffer was too small, but we were treating it
as though it indicated that we received *no* fds. If we received any,
we still have to make sure we close them, otherwise they will be leaked.

On the system bus, if an attacker can induce us to leak fds in this
way, that's a local denial of service via resource exhaustion.

Reported-by: Kevin Backhouse, GitHub Security Lab
Fixes: dbus#294
Fixes: CVE-2020-12049
Fixes: GHSL-2020-057
",872b085f12f56da25a2dbd9bd0b2dff31d5aea63,https://cgit.freedesktop.org/dbus/dbus/commit/?id=872b085f12f56da25a2dbd9bd0b2dff31d5aea63,dbus/dbus-sysdeps-unix.c,_dbus_read_socket_with_unix_fds,"int
_dbus_read_socket_with_unix_fds (DBusSocket        fd,
DBusString       *buffer,
int               count,
int              *fds,
unsigned int     *n_fds) {
#ifndef HAVE_UNIX_FD_PASSING
int r;
if ((r = _dbus_read_socket(fd, buffer, count)) < 0)
return r;
*n_fds = 0;
return r;
#else
int bytes_read;
int start;
struct msghdr m;
struct iovec iov;
_dbus_assert (count >= 0);
_dbus_assert (*n_fds <= DBUS_MAXIMUM_MESSAGE_UNIX_FDS);
start = _dbus_string_get_length (buffer);
if (!_dbus_string_lengthen (buffer, count))
{
errno = ENOMEM;
return -1;
}
_DBUS_ZERO(iov);
iov.iov_base = _dbus_string_get_data_len (buffer, start, count);
iov.iov_len = count;
_DBUS_ZERO(m);
m.msg_iov = &iov;
m.msg_iovlen = 1;
m.msg_controllen = CMSG_SPACE(*n_fds * sizeof(int));
m.msg_control = alloca(m.msg_controllen);
memset(m.msg_control, 0, m.msg_controllen);
m.msg_controllen = CMSG_LEN (*n_fds * sizeof(int));
again:
bytes_read = recvmsg (fd.fd, &m, 0
#ifdef MSG_CMSG_CLOEXEC
|MSG_CMSG_CLOEXEC
#endif
);
if (bytes_read < 0)
{
if (errno == EINTR)
goto again;
else
{
_dbus_string_set_length (buffer, start);
return -1;
}
}
else
{
struct cmsghdr *cm;
dbus_bool_t found = FALSE;
if (m.msg_flags & MSG_CTRUNC)
{
errno = ENOSPC;
_dbus_string_set_length (buffer, start);
return -1;
}
for (cm = CMSG_FIRSTHDR(&m); cm; cm = CMSG_NXTHDR(&m, cm))
if (cm->cmsg_level == SOL_SOCKET && cm->cmsg_type == SCM_RIGHTS)
{
size_t i;
int *payload = (int *) CMSG_DATA (cm);
size_t payload_len_bytes = (cm->cmsg_len - CMSG_LEN (0));
size_t payload_len_fds = payload_len_bytes / sizeof (int);
size_t fds_to_use;
_DBUS_STATIC_ASSERT (sizeof (size_t) >= sizeof (unsigned int));
if (_DBUS_LIKELY (payload_len_fds <= (size_t) *n_fds))
{
fds_to_use = payload_len_fds;
}
else
{
fds_to_use = (size_t) *n_fds;
for (i = fds_to_use; i < payload_len_fds; i++)
{
close (payload[i]);
}
}
memcpy (fds, payload, fds_to_use * sizeof (int));
found = TRUE;
*n_fds = (unsigned int) fds_to_use;
for (i = 0; i < fds_to_use; i++)
_dbus_fd_set_close_on_exec(fds[i]);
break;
}
if (!found)
*n_fds = 0;
_dbus_string_set_length (buffer, start + bytes_read);
#if 0
if (bytes_read > 0)
_dbus_verbose_bytes_of_string (buffer, start, bytes_read);
#endif
return bytes_read;
}
#endif
}","int
_dbus_read_socket_with_unix_fds (DBusSocket        VAR_0,
DBusString       *VAR_1,
int               VAR_2,
int              *VAR_3,
unsigned int     *VAR_4) {
#ifndef VAR_5
int VAR_6;
if ((VAR_6 = _dbus_read_socket(VAR_0, VAR_1, VAR_2)) < 0)
return VAR_6;
*VAR_4 = 0;
return VAR_6;
#else
int VAR_7;
int VAR_8;
struct msghdr VAR_9;
struct iovec VAR_10;
_dbus_assert (VAR_2 >= 0);
_dbus_assert (*VAR_4 <= VAR_11);
VAR_8 = _dbus_string_get_length (VAR_1);
if (!_dbus_string_lengthen (VAR_1, VAR_2))
{
VAR_12 = VAR_13;
return -1;
}
_DBUS_ZERO(VAR_10);
VAR_10.iov_base = _dbus_string_get_data_len (VAR_1, VAR_8, VAR_2);
VAR_10.iov_len = VAR_2;
_DBUS_ZERO(VAR_9);
VAR_9.msg_iov = &VAR_10;
VAR_9.msg_iovlen = 1;
VAR_9.msg_controllen = CMSG_SPACE(*VAR_4 * sizeof(int));
VAR_9.msg_control = alloca(VAR_9.msg_controllen);
memset(VAR_9.msg_control, 0, VAR_9.msg_controllen);
VAR_9.msg_controllen = CMSG_LEN (*VAR_4 * sizeof(int));
again:
VAR_7 = recvmsg (VAR_0.fd, &VAR_9, 0
#ifdef VAR_14
|VAR_14
#endif
);
if (VAR_7 < 0)
{
if (VAR_12 == VAR_15)
goto again;
else
{
_dbus_string_set_length (VAR_1, VAR_8);
return -1;
}
}
else
{
struct cmsghdr *VAR_16;
dbus_bool_t VAR_17 = FALSE;
if (VAR_9.msg_flags & VAR_18)
{
VAR_12 = VAR_19;
_dbus_string_set_length (VAR_1, VAR_8);
return -1;
}
for (VAR_16 = CMSG_FIRSTHDR(&VAR_9); VAR_16; VAR_16 = CMSG_NXTHDR(&VAR_9, VAR_16))
if (VAR_16->cmsg_level == VAR_20 && VAR_16->cmsg_type == VAR_21)
{
size_t VAR_22;
int *VAR_23 = (int *) CMSG_DATA (VAR_16);
size_t VAR_24 = (VAR_16->cmsg_len - CMSG_LEN (0));
size_t VAR_25 = VAR_24 / sizeof (int);
size_t VAR_26;
_DBUS_STATIC_ASSERT (sizeof (size_t) >= sizeof (unsigned int));
if (_DBUS_LIKELY (VAR_25 <= (size_t) *VAR_4))
{
VAR_26 = VAR_25;
}
else
{
VAR_26 = (size_t) *VAR_4;
for (VAR_22 = VAR_26; VAR_22 < VAR_25; VAR_22++)
{
close (VAR_23[VAR_22]);
}
}
memcpy (VAR_3, VAR_23, VAR_26 * sizeof (int));
VAR_17 = TRUE;
*VAR_4 = (unsigned int) VAR_26;
for (VAR_22 = 0; VAR_22 < VAR_26; VAR_22++)
_dbus_fd_set_close_on_exec(VAR_3[VAR_22]);
break;
}
if (!VAR_17)
*VAR_4 = 0;
_dbus_string_set_length (VAR_1, VAR_8 + VAR_7);
#if 0
if (VAR_7 > 0)
_dbus_verbose_bytes_of_string (VAR_1, VAR_8, VAR_7);
#endif
return VAR_7;
}
#endif
}",dbus/872b085f12f56da25a2dbd9bd0b2dff31d5aea63/dbus-sysdeps-unix.c/vul/before/0.json,"int
_dbus_read_socket_with_unix_fds (DBusSocket        fd,
                                 DBusString       *buffer,
                                 int               count,
                                 int              *fds,
                                 unsigned int     *n_fds) {
#ifndef HAVE_UNIX_FD_PASSING
  int r;

  if ((r = _dbus_read_socket(fd, buffer, count)) < 0)
    return r;

  *n_fds = 0;
  return r;

#else
  int bytes_read;
  int start;
  struct msghdr m;
  struct iovec iov;

  _dbus_assert (count >= 0);
  _dbus_assert (*n_fds <= DBUS_MAXIMUM_MESSAGE_UNIX_FDS);

  start = _dbus_string_get_length (buffer);

  if (!_dbus_string_lengthen (buffer, count))
    {
      errno = ENOMEM;
      return -1;
    }

  _DBUS_ZERO(iov);
  iov.iov_base = _dbus_string_get_data_len (buffer, start, count);
  iov.iov_len = count;

  _DBUS_ZERO(m);
  m.msg_iov = &iov;
  m.msg_iovlen = 1;

  /* Hmm, we have no clue how long the control data will actually be
     that is queued for us. The least we can do is assume that the
     caller knows. Hence let's make space for the number of fds that
     we shall read at max plus the cmsg header. */
  m.msg_controllen = CMSG_SPACE(*n_fds * sizeof(int));

  /* It's probably safe to assume that systems with SCM_RIGHTS also
     know alloca() */
  m.msg_control = alloca(m.msg_controllen);
  memset(m.msg_control, 0, m.msg_controllen);

  /* Do not include the padding at the end when we tell the kernel
   * how much we're willing to receive. This avoids getting
   * the padding filled with additional fds that we weren't expecting,
   * if a (potentially malicious) sender included them. (fd.o #83622) */
  m.msg_controllen = CMSG_LEN (*n_fds * sizeof(int));

 again:

  bytes_read = recvmsg (fd.fd, &m, 0
#ifdef MSG_CMSG_CLOEXEC
                       |MSG_CMSG_CLOEXEC
#endif
                       );

  if (bytes_read < 0)
    {
      if (errno == EINTR)
        goto again;
      else
        {
          /* put length back (note that this doesn't actually realloc anything) */
          _dbus_string_set_length (buffer, start);
          return -1;
        }
    }
  else
    {
      struct cmsghdr *cm;
      dbus_bool_t found = FALSE;

      for (cm = CMSG_FIRSTHDR(&m); cm; cm = CMSG_NXTHDR(&m, cm))
        if (cm->cmsg_level == SOL_SOCKET && cm->cmsg_type == SCM_RIGHTS)
          {
            size_t i;
            int *payload = (int *) CMSG_DATA (cm);
            size_t payload_len_bytes = (cm->cmsg_len - CMSG_LEN (0));
            size_t payload_len_fds = payload_len_bytes / sizeof (int);
            size_t fds_to_use;

            /* Every unsigned int fits in a size_t without truncation, so
             * casting (size_t) *n_fds is OK */
            _DBUS_STATIC_ASSERT (sizeof (size_t) >= sizeof (unsigned int));

            if (_DBUS_LIKELY (payload_len_fds <= (size_t) *n_fds))
              {
                /* The fds in the payload will fit in our buffer */
                fds_to_use = payload_len_fds;
              }
            else
              {
                /* Too many fds in the payload. This shouldn't happen
                 * any more because we're setting m.msg_controllen to
                 * the exact number we can accept, but be safe and
                 * truncate. */
                fds_to_use = (size_t) *n_fds;

                /* Close the excess fds to avoid DoS: if they stayed open,
                 * someone could send us an extra fd per message
                 * and we'd eventually run out. */
                for (i = fds_to_use; i < payload_len_fds; i++)
                  {
                    close (payload[i]);
                  }
              }

            memcpy (fds, payload, fds_to_use * sizeof (int));
            found = TRUE;
            /* This narrowing cast from size_t to unsigned int cannot
             * overflow because we have chosen fds_to_use
             * to be <= *n_fds */
            *n_fds = (unsigned int) fds_to_use;

            /* Linux doesn't tell us whether MSG_CMSG_CLOEXEC actually
               worked, hence we need to go through this list and set
               CLOEXEC everywhere in any case */
            for (i = 0; i < fds_to_use; i++)
              _dbus_fd_set_close_on_exec(fds[i]);

            break;
          }

      if (!found)
        *n_fds = 0;

      if (m.msg_flags & MSG_CTRUNC)
        {
          unsigned int i;

          /* Hmm, apparently the control data was truncated. The bad
             thing is that we might have completely lost a couple of fds
             without chance to recover them. Hence let's treat this as a
             serious error. */

          /* We still need to close whatever fds we *did* receive,
           * otherwise they'll never get closed. (CVE-2020-12049) */
          for (i = 0; i < *n_fds; i++)
            close (fds[i]);

          *n_fds = 0;
          errno = ENOSPC;
          _dbus_string_set_length (buffer, start);
          return -1;
        }

      /* put length back (doesn't actually realloc) */
      _dbus_string_set_length (buffer, start + bytes_read);

#if 0
      if (bytes_read > 0)
        _dbus_verbose_bytes_of_string (buffer, start, bytes_read);
#endif

      return bytes_read;
    }
#endif
}","int
_dbus_read_socket_with_unix_fds (DBusSocket        VAR_0,
                                 DBusString       *VAR_1,
                                 int               VAR_2,
                                 int              *VAR_3,
                                 unsigned int     *VAR_4) {
#ifndef VAR_5
  int VAR_6;

  if ((VAR_6 = _dbus_read_socket(VAR_0, VAR_1, VAR_2)) < 0)
    return VAR_6;

  *VAR_4 = 0;
  return VAR_6;

#else
  int VAR_7;
  int VAR_8;
  struct msghdr VAR_9;
  struct iovec VAR_10;

  _dbus_assert (VAR_2 >= 0);
  _dbus_assert (*VAR_4 <= VAR_11);

  VAR_8 = _dbus_string_get_length (VAR_1);

  if (!_dbus_string_lengthen (VAR_1, VAR_2))
    {
      VAR_12 = VAR_13;
      return -1;
    }

  _DBUS_ZERO(VAR_10);
  VAR_10.iov_base = _dbus_string_get_data_len (VAR_1, VAR_8, VAR_2);
  VAR_10.iov_len = VAR_2;

  _DBUS_ZERO(VAR_9);
  VAR_9.msg_iov = &VAR_10;
  VAR_9.msg_iovlen = 1;

  /* COMMENT_0 */
                                                                  
                                                                    
                                                  
  VAR_9.msg_controllen = CMSG_SPACE(*VAR_4 * sizeof(int));

  /* COMMENT_4 */
                     
  VAR_9.msg_control = alloca(VAR_9.msg_controllen);
  memset(VAR_9.msg_control, 0, VAR_9.msg_controllen);

  /* COMMENT_6 */
                                                           
                                                                      
                                                                        
  VAR_9.msg_controllen = CMSG_LEN (*VAR_4 * sizeof(int));

 again:

  VAR_7 = recvmsg (VAR_0.fd, &VAR_9, 0
#ifdef VAR_14
                       |VAR_14
#endif
                       );

  if (VAR_7 < 0)
    {
      if (VAR_12 == VAR_15)
        goto again;
      else
        {
          /* COMMENT_10 */
          _dbus_string_set_length (VAR_1, VAR_8);
          return -1;
        }
    }
  else
    {
      struct cmsghdr *VAR_16;
      dbus_bool_t VAR_17 = FALSE;

      for (VAR_16 = CMSG_FIRSTHDR(&VAR_9); VAR_16; VAR_16 = CMSG_NXTHDR(&VAR_9, VAR_16))
        if (VAR_16->cmsg_level == VAR_18 && VAR_16->cmsg_type == VAR_19)
          {
            size_t VAR_20;
            int *VAR_21 = (int *) CMSG_DATA (VAR_16);
            size_t VAR_22 = (VAR_16->cmsg_len - CMSG_LEN (0));
            size_t VAR_23 = VAR_22 / sizeof (int);
            size_t VAR_24;

            /* COMMENT_11 */
                                               
            _DBUS_STATIC_ASSERT (sizeof (size_t) >= sizeof (unsigned int));

            if (_DBUS_LIKELY (VAR_23 <= (size_t) *VAR_4))
              {
                /* COMMENT_13 */
                VAR_24 = VAR_23;
              }
            else
              {
                /* COMMENT_14 */
                                                                     
                                                                  
                               
                VAR_24 = (size_t) *VAR_4;

                /* COMMENT_18 */
                                                                
                                                  
                for (VAR_20 = VAR_24; VAR_20 < VAR_23; VAR_20++)
                  {
                    close (VAR_21[VAR_20]);
                  }
              }

            memcpy (VAR_3, VAR_21, VAR_24 * sizeof (int));
            VAR_17 = TRUE;
            /* COMMENT_21 */
                                                         
                                 
            *VAR_4 = (unsigned int) VAR_24;

            /* COMMENT_24 */
                                                                    
                                                
            for (VAR_20 = 0; VAR_20 < VAR_24; VAR_20++)
              _dbus_fd_set_close_on_exec(VAR_3[VAR_20]);

            break;
          }

      if (!VAR_17)
        *VAR_4 = 0;

      if (VAR_9.msg_flags & VAR_25)
        {
          unsigned int VAR_20;

          /* COMMENT_27 */
                                                                        
                                                                        
                              

          /* COMMENT_31 */
                                                                    
          for (VAR_20 = 0; VAR_20 < *VAR_4; VAR_20++)
            close (VAR_3[VAR_20]);

          *VAR_4 = 0;
          VAR_12 = VAR_26;
          _dbus_string_set_length (VAR_1, VAR_8);
          return -1;
        }

      /* COMMENT_33 */
      _dbus_string_set_length (VAR_1, VAR_8 + VAR_7);

#if 0
      if (VAR_7 > 0)
        _dbus_verbose_bytes_of_string (VAR_1, VAR_8, VAR_7);
#endif

      return VAR_7;
    }
#endif
}",dbus/872b085f12f56da25a2dbd9bd0b2dff31d5aea63/dbus-sysdeps-unix.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -79,18 +79,6 @@
       struct cmsghdr *cm;
       dbus_bool_t found = FALSE;
 
-      if (m.msg_flags & MSG_CTRUNC)
-        {
-          /* Hmm, apparently the control data was truncated. The bad
-             thing is that we might have completely lost a couple of fds
-             without chance to recover them. Hence let's treat this as a
-             serious error. */
-
-          errno = ENOSPC;
-          _dbus_string_set_length (buffer, start);
-          return -1;
-        }
-
       for (cm = CMSG_FIRSTHDR(&m); cm; cm = CMSG_NXTHDR(&m, cm))
         if (cm->cmsg_level == SOL_SOCKET && cm->cmsg_type == SCM_RIGHTS)
           {
@@ -145,6 +133,26 @@
       if (!found)
         *n_fds = 0;
 
+      if (m.msg_flags & MSG_CTRUNC)
+        {
+          unsigned int i;
+
+          /* Hmm, apparently the control data was truncated. The bad
+             thing is that we might have completely lost a couple of fds
+             without chance to recover them. Hence let's treat this as a
+             serious error. */
+
+          /* We still need to close whatever fds we *did* receive,
+           * otherwise they'll never get closed. (CVE-2020-12049) */
+          for (i = 0; i < *n_fds; i++)
+            close (fds[i]);
+
+          *n_fds = 0;
+          errno = ENOSPC;
+          _dbus_string_set_length (buffer, start);
+          return -1;
+        }
+
       /* put length back (doesn't actually realloc) */
       _dbus_string_set_length (buffer, start + bytes_read);
 ","{'deleted_lines': ['      if (m.msg_flags & MSG_CTRUNC)', '        {', '          /* Hmm, apparently the control data was truncated. The bad', '             thing is that we might have completely lost a couple of fds', ""             without chance to recover them. Hence let's treat this as a"", '             serious error. */', '', '          errno = ENOSPC;', '          _dbus_string_set_length (buffer, start);', '          return -1;', '        }', ''], 'added_lines': ['      if (m.msg_flags & MSG_CTRUNC)', '        {', '          unsigned int i;', '', '          /* Hmm, apparently the control data was truncated. The bad', '             thing is that we might have completely lost a couple of fds', ""             without chance to recover them. Hence let's treat this as a"", '             serious error. */', '', '          /* We still need to close whatever fds we *did* receive,', ""           * otherwise they'll never get closed. (CVE-2020-12049) */"", '          for (i = 0; i < *n_fds; i++)', '            close (fds[i]);', '', '          *n_fds = 0;', '          errno = ENOSPC;', '          _dbus_string_set_length (buffer, start);', '          return -1;', '        }', '']}",True,"An issue was discovered in dbus >= 1.3.0 before 1.12.18. The DBusServer in libdbus, as used in dbus-daemon, leaks file descriptors when a message exceeds the per-message file descriptor limit. A local attacker with access to the D-Bus system bus or another system service's private AF_UNIX socket could use this to make the system service reach its file descriptor limit, denying service to subsequent D-Bus clients.",5.5,MEDIUM,1,test,,5
CVE-2020-14954,['CWE-74'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,muttmua/mutt,"Fix STARTTLS response injection attack.

Thanks again to Damian Poddebniak and Fabian Ising from the Mnster
University of Applied Sciences for reporting this issue.  Their
summary in ticket 248 states the issue clearly:

  We found another STARTTLS-related issue in Mutt. Unfortunately, it
  affects SMTP, POP3 and IMAP.

  When the server responds with its ""let's do TLS now message"", e.g. A
  OK begin TLS\r\n in IMAP or +OK begin TLS\r\n in POP3, Mutt will
  also read any data after the \r\n and save it into some internal
  buffer for later processing. This is problematic, because a MITM
  attacker can inject arbitrary responses.

  There is a nice blogpost by Wietse Venema about a ""command
  injection"" in postfix (http://www.postfix.org/CVE-2011-0411.html).
  What we have here is the problem in reverse, i.e. not a command
  injection, but a ""response injection.""

This commit fixes the issue by clearing the CONNECTION input buffer in
mutt_ssl_starttls().

To make backporting this fix easier, the new functions only clear the
top-level CONNECTION buffer; they don't handle nested buffering in
mutt_zstrm.c or mutt_sasl.c.  However both of those wrap the
connection *after* STARTTLS, so this is currently okay.  mutt_tunnel.c
occurs before connecting, but it does not perform any nesting.
",c547433cdf2e79191b15c6932c57f1472bfb5ff4,https://gitlab.com/muttmua/mutt/-/commit/c547433cdf2e79191b15c6932c57f1472bfb5ff4,mutt_ssl.c,mutt_ssl_starttls,"int mutt_ssl_starttls (CONNECTION* conn)
{
sslsockdata* ssldata;
int maxbits;
long ssl_options = 0;
if (ssl_init())
goto bail;
ssldata = (sslsockdata*) safe_calloc (1, sizeof (sslsockdata));
if (! (ssldata->ctx = SSL_CTX_new (SSLv23_client_method())))
{
dprint (1, (debugfile, ""mutt_ssl_starttls: Error allocating SSL_CTX\n""));
goto bail_ssldata;
}
#ifdef SSL_OP_NO_TLSv1_3
if (!option(OPTTLSV1_3))
ssl_options |= SSL_OP_NO_TLSv1_3;
#endif
#ifdef SSL_OP_NO_TLSv1_2
if (!option(OPTTLSV1_2))
ssl_options |= SSL_OP_NO_TLSv1_2;
#endif
#ifdef SSL_OP_NO_TLSv1_1
if (!option(OPTTLSV1_1))
ssl_options |= SSL_OP_NO_TLSv1_1;
#endif
#ifdef SSL_OP_NO_TLSv1
if (!option(OPTTLSV1))
ssl_options |= SSL_OP_NO_TLSv1;
#endif
#ifdef SSL_OP_NO_SSLv3
ssl_options |= SSL_OP_NO_SSLv3;
#endif
#ifdef SSL_OP_NO_SSLv2
ssl_options |= SSL_OP_NO_SSLv2;
#endif
if (! SSL_CTX_set_options(ssldata->ctx, ssl_options))
{
dprint(1, (debugfile, ""mutt_ssl_starttls: Error setting options to %ld\n"", ssl_options));
goto bail_ctx;
}
if (option (OPTSSLSYSTEMCERTS))
{
if (! SSL_CTX_set_default_verify_paths (ssldata->ctx))
{
dprint (1, (debugfile, ""mutt_ssl_starttls: Error setting default verify paths\n""));
goto bail_ctx;
}
}
if (SslCertFile && !ssl_load_certificates (ssldata->ctx))
dprint (1, (debugfile, ""mutt_ssl_starttls: Error loading trusted certificates\n""));
ssl_get_client_cert(ssldata, conn);
if (SslCiphers)
{
if (!SSL_CTX_set_cipher_list (ssldata->ctx, SslCiphers))
{
dprint (1, (debugfile, ""mutt_ssl_starttls: Could not select preferred ciphers\n""));
goto bail_ctx;
}
}
if (ssl_set_verify_partial (ssldata->ctx))
{
mutt_error (_(""Warning: error enabling ssl_verify_partial_chains""));
mutt_sleep (2);
}
if (! (ssldata->ssl = SSL_new (ssldata->ctx)))
{
dprint (1, (debugfile, ""mutt_ssl_starttls: Error allocating SSL\n""));
goto bail_ctx;
}
if (SSL_set_fd (ssldata->ssl, conn->fd) != 1)
{
dprint (1, (debugfile, ""mutt_ssl_starttls: Error setting fd\n""));
goto bail_ssl;
}
if (ssl_negotiate (conn, ssldata))
goto bail_ssl;
ssldata->isopen = 1;
conn->sockdata = ssldata;
conn->conn_read = ssl_socket_read;
conn->conn_write = ssl_socket_write;
conn->conn_close = tls_close;
conn->conn_poll = ssl_socket_poll;
conn->ssf = SSL_CIPHER_get_bits (SSL_get_current_cipher (ssldata->ssl),
&maxbits);
return 0;
bail_ssl:
SSL_free (ssldata->ssl);
ssldata->ssl = 0;
bail_ctx:
SSL_CTX_free (ssldata->ctx);
ssldata->ctx = 0;
bail_ssldata:
FREE (&ssldata);
bail:
return -1;
}","int mutt_ssl_starttls (CONNECTION* VAR_0)
{
sslsockdata* VAR_1;
int VAR_2;
long VAR_3 = 0;
if (ssl_init())
goto bail;
VAR_1 = (sslsockdata*) safe_calloc (1, sizeof (sslsockdata));
if (! (VAR_1->ctx = SSL_CTX_new (SSLv23_client_method())))
{
dprint (1, (VAR_4, ""mutt_ssl_starttls: Error allocating SSL_CTX\n""));
goto bail_ssldata;
}
#ifdef VAR_5
if (!option(VAR_6))
VAR_3 |= VAR_5;
#endif
#ifdef VAR_7
if (!option(VAR_8))
VAR_3 |= VAR_7;
#endif
#ifdef VAR_9
if (!option(VAR_10))
VAR_3 |= VAR_9;
#endif
#ifdef VAR_11
if (!option(VAR_12))
VAR_3 |= VAR_11;
#endif
#ifdef VAR_13
VAR_3 |= VAR_13;
#endif
#ifdef VAR_14
VAR_3 |= VAR_14;
#endif
if (! SSL_CTX_set_options(VAR_1->ctx, VAR_3))
{
dprint(1, (VAR_4, ""mutt_ssl_starttls: Error setting options to %ld\n"", VAR_3));
goto bail_ctx;
}
if (option (VAR_15))
{
if (! SSL_CTX_set_default_verify_paths (VAR_1->ctx))
{
dprint (1, (VAR_4, ""mutt_ssl_starttls: Error setting default verify paths\n""));
goto bail_ctx;
}
}
if (VAR_16 && !ssl_load_certificates (VAR_1->ctx))
dprint (1, (VAR_4, ""mutt_ssl_starttls: Error loading trusted certificates\n""));
ssl_get_client_cert(VAR_1, VAR_0);
if (VAR_17)
{
if (!SSL_CTX_set_cipher_list (VAR_1->ctx, VAR_17))
{
dprint (1, (VAR_4, ""mutt_ssl_starttls: Could not select preferred ciphers\n""));
goto bail_ctx;
}
}
if (ssl_set_verify_partial (VAR_1->ctx))
{
mutt_error (_(""Warning: error enabling ssl_verify_partial_chains""));
mutt_sleep (2);
}
if (! (VAR_1->ssl = SSL_new (VAR_1->ctx)))
{
dprint (1, (VAR_4, ""mutt_ssl_starttls: Error allocating SSL\n""));
goto bail_ctx;
}
if (SSL_set_fd (VAR_1->ssl, VAR_0->fd) != 1)
{
dprint (1, (VAR_4, ""mutt_ssl_starttls: Error setting fd\n""));
goto bail_ssl;
}
if (ssl_negotiate (VAR_0, VAR_1))
goto bail_ssl;
VAR_1->isopen = 1;
VAR_0->sockdata = VAR_1;
VAR_0->conn_read = VAR_18;
VAR_0->conn_write = VAR_19;
VAR_0->conn_close = VAR_20;
VAR_0->conn_poll = VAR_21;
VAR_0->ssf = SSL_CIPHER_get_bits (SSL_get_current_cipher (VAR_1->ssl),
&VAR_2);
return 0;
bail_ssl:
SSL_free (VAR_1->ssl);
VAR_1->ssl = 0;
bail_ctx:
SSL_CTX_free (VAR_1->ctx);
VAR_1->ctx = 0;
bail_ssldata:
FREE (&VAR_1);
bail:
return -1;
}",muttmua/mutt/c547433cdf2e79191b15c6932c57f1472bfb5ff4/mutt_ssl.c/vul/before/0.json,"int mutt_ssl_starttls (CONNECTION* conn)
{
  sslsockdata* ssldata;
  int maxbits;
  long ssl_options = 0;

  if (mutt_socket_has_buffered_input (conn))
  {
    /* L10N:
       The server is not supposed to send data immediately after
       confirming STARTTLS.  This warns the user that something
       weird is going on.
    */
    mutt_error _(""Warning: clearing unexpected buffered data before STARTTLS"");
    mutt_sleep (0);
    mutt_socket_clear_buffered_input (conn);
  }

  if (ssl_init())
    goto bail;

  ssldata = (sslsockdata*) safe_calloc (1, sizeof (sslsockdata));
  /* the ssl_use_xxx protocol options don't apply. We must use TLS in TLS.
   *
   * However, we need to be able to negotiate amongst various TLS versions,
   * which at present can only be done with the SSLv23_client_method;
   * TLSv1_client_method gives us explicitly TLSv1.0, not 1.1 or 1.2 (True as
   * of OpenSSL 1.0.1c)
   */
  if (! (ssldata->ctx = SSL_CTX_new (SSLv23_client_method())))
  {
    dprint (1, (debugfile, ""mutt_ssl_starttls: Error allocating SSL_CTX\n""));
    goto bail_ssldata;
  }
#ifdef SSL_OP_NO_TLSv1_3
  if (!option(OPTTLSV1_3))
    ssl_options |= SSL_OP_NO_TLSv1_3;
#endif
#ifdef SSL_OP_NO_TLSv1_2
  if (!option(OPTTLSV1_2))
    ssl_options |= SSL_OP_NO_TLSv1_2;
#endif
#ifdef SSL_OP_NO_TLSv1_1
  if (!option(OPTTLSV1_1))
    ssl_options |= SSL_OP_NO_TLSv1_1;
#endif
#ifdef SSL_OP_NO_TLSv1
  if (!option(OPTTLSV1))
    ssl_options |= SSL_OP_NO_TLSv1;
#endif
  /* these are always set */
#ifdef SSL_OP_NO_SSLv3
  ssl_options |= SSL_OP_NO_SSLv3;
#endif
#ifdef SSL_OP_NO_SSLv2
  ssl_options |= SSL_OP_NO_SSLv2;
#endif
  if (! SSL_CTX_set_options(ssldata->ctx, ssl_options))
  {
    dprint(1, (debugfile, ""mutt_ssl_starttls: Error setting options to %ld\n"", ssl_options));
    goto bail_ctx;
  }

  if (option (OPTSSLSYSTEMCERTS))
  {
    if (! SSL_CTX_set_default_verify_paths (ssldata->ctx))
    {
      dprint (1, (debugfile, ""mutt_ssl_starttls: Error setting default verify paths\n""));
      goto bail_ctx;
    }
  }

  if (SslCertFile && !ssl_load_certificates (ssldata->ctx))
    dprint (1, (debugfile, ""mutt_ssl_starttls: Error loading trusted certificates\n""));

  ssl_get_client_cert(ssldata, conn);

  if (SslCiphers)
  {
    if (!SSL_CTX_set_cipher_list (ssldata->ctx, SslCiphers))
    {
      dprint (1, (debugfile, ""mutt_ssl_starttls: Could not select preferred ciphers\n""));
      goto bail_ctx;
    }
  }

  if (ssl_set_verify_partial (ssldata->ctx))
  {
    mutt_error (_(""Warning: error enabling ssl_verify_partial_chains""));
    mutt_sleep (2);
  }

  if (! (ssldata->ssl = SSL_new (ssldata->ctx)))
  {
    dprint (1, (debugfile, ""mutt_ssl_starttls: Error allocating SSL\n""));
    goto bail_ctx;
  }

  if (SSL_set_fd (ssldata->ssl, conn->fd) != 1)
  {
    dprint (1, (debugfile, ""mutt_ssl_starttls: Error setting fd\n""));
    goto bail_ssl;
  }

  if (ssl_negotiate (conn, ssldata))
    goto bail_ssl;

  ssldata->isopen = 1;

  /* hmm. watch out if we're starting TLS over any method other than raw. */
  conn->sockdata = ssldata;
  conn->conn_read = ssl_socket_read;
  conn->conn_write = ssl_socket_write;
  conn->conn_close = tls_close;
  conn->conn_poll = ssl_socket_poll;

  conn->ssf = SSL_CIPHER_get_bits (SSL_get_current_cipher (ssldata->ssl),
                                   &maxbits);

  return 0;

bail_ssl:
  SSL_free (ssldata->ssl);
  ssldata->ssl = 0;
bail_ctx:
  SSL_CTX_free (ssldata->ctx);
  ssldata->ctx = 0;
bail_ssldata:
  FREE (&ssldata);
bail:
  return -1;
}","int mutt_ssl_starttls (CONNECTION* VAR_0)
{
  sslsockdata* VAR_1;
  int VAR_2;
  long VAR_3 = 0;

  if (mutt_socket_has_buffered_input (VAR_0))
  {
    /* COMMENT_0 */
                                                                
                                                               
                         
      
    mutt_error VAR_4(""Warning: clearing unexpected buffered data before STARTTLS"");
    mutt_sleep (0);
    mutt_socket_clear_buffered_input (VAR_0);
  }

  if (ssl_init())
    goto bail;

  VAR_1 = (sslsockdata*) safe_calloc (1, sizeof (sslsockdata));
  /* COMMENT_5 */
    
                                                                           
                                                                     
                                                                             
                       
     
  if (! (VAR_1->ctx = SSL_CTX_new (SSLv23_client_method())))
  {
    dprint (1, (VAR_5, ""mutt_ssl_starttls: Error allocating SSL_CTX\n""));
    goto bail_ssldata;
  }
#ifdef VAR_6
  if (!option(VAR_7))
    VAR_3 |= VAR_6;
#endif
#ifdef VAR_8
  if (!option(VAR_9))
    VAR_3 |= VAR_8;
#endif
#ifdef VAR_10
  if (!option(VAR_11))
    VAR_3 |= VAR_10;
#endif
#ifdef VAR_12
  if (!option(VAR_13))
    VAR_3 |= VAR_12;
#endif
  /* COMMENT_12 */
#ifdef VAR_14
  VAR_3 |= VAR_14;
#endif
#ifdef VAR_15
  VAR_3 |= VAR_15;
#endif
  if (! SSL_CTX_set_options(VAR_1->ctx, VAR_3))
  {
    dprint(1, (VAR_5, ""mutt_ssl_starttls: Error setting options to %ld\n"", VAR_3));
    goto bail_ctx;
  }

  if (option (VAR_16))
  {
    if (! SSL_CTX_set_default_verify_paths (VAR_1->ctx))
    {
      dprint (1, (VAR_5, ""mutt_ssl_starttls: Error setting default verify paths\n""));
      goto bail_ctx;
    }
  }

  if (VAR_17 && !ssl_load_certificates (VAR_1->ctx))
    dprint (1, (VAR_5, ""mutt_ssl_starttls: Error loading trusted certificates\n""));

  ssl_get_client_cert(VAR_1, VAR_0);

  if (VAR_18)
  {
    if (!SSL_CTX_set_cipher_list (VAR_1->ctx, VAR_18))
    {
      dprint (1, (VAR_5, ""mutt_ssl_starttls: Could not select preferred ciphers\n""));
      goto bail_ctx;
    }
  }

  if (ssl_set_verify_partial (VAR_1->ctx))
  {
    mutt_error (VAR_4(""Warning: error enabling ssl_verify_partial_chains""));
    mutt_sleep (2);
  }

  if (! (VAR_1->ssl = SSL_new (VAR_1->ctx)))
  {
    dprint (1, (VAR_5, ""mutt_ssl_starttls: Error allocating SSL\n""));
    goto bail_ctx;
  }

  if (SSL_set_fd (VAR_1->ssl, VAR_0->fd) != 1)
  {
    dprint (1, (VAR_5, ""mutt_ssl_starttls: Error setting fd\n""));
    goto bail_ssl;
  }

  if (ssl_negotiate (VAR_0, VAR_1))
    goto bail_ssl;

  VAR_1->isopen = 1;

  /* COMMENT_13 */
  VAR_0->sockdata = VAR_1;
  VAR_0->conn_read = VAR_19;
  VAR_0->conn_write = VAR_20;
  VAR_0->conn_close = VAR_21;
  VAR_0->conn_poll = VAR_22;

  VAR_0->ssf = SSL_CIPHER_get_bits (SSL_get_current_cipher (VAR_1->ssl),
                                   &VAR_2);

  return 0;

bail_ssl:
  SSL_free (VAR_1->ssl);
  VAR_1->ssl = 0;
bail_ctx:
  SSL_CTX_free (VAR_1->ctx);
  VAR_1->ctx = 0;
bail_ssldata:
  FREE (&VAR_1);
bail:
  return -1;
}",muttmua/mutt/c547433cdf2e79191b15c6932c57f1472bfb5ff4/mutt_ssl.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -3,6 +3,18 @@
   sslsockdata* ssldata;
   int maxbits;
   long ssl_options = 0;
+
+  if (mutt_socket_has_buffered_input (conn))
+  {
+    /* L10N:
+       The server is not supposed to send data immediately after
+       confirming STARTTLS.  This warns the user that something
+       weird is going on.
+    */
+    mutt_error _(""Warning: clearing unexpected buffered data before STARTTLS"");
+    mutt_sleep (0);
+    mutt_socket_clear_buffered_input (conn);
+  }
 
   if (ssl_init())
     goto bail;","{'deleted_lines': [], 'added_lines': ['', '  if (mutt_socket_has_buffered_input (conn))', '  {', '    /* L10N:', '       The server is not supposed to send data immediately after', '       confirming STARTTLS.  This warns the user that something', '       weird is going on.', '    */', '    mutt_error _(""Warning: clearing unexpected buffered data before STARTTLS"");', '    mutt_sleep (0);', '    mutt_socket_clear_buffered_input (conn);', '  }']}",True,"Mutt before 1.14.4 and NeoMutt before 2020-06-19 have a STARTTLS buffering issue that affects IMAP, SMTP, and POP3. When a server sends a ""begin TLS"" response, the client reads additional data (e.g., from a man-in-the-middle attacker) and evaluates it in a TLS context, aka ""response injection.""",5.9,MEDIUM,1,test,,5
CVE-2020-14954,['CWE-74'],AV:N/AC:M/Au:N/C:N/I:P/A:N,0,muttmua/mutt,"Fix STARTTLS response injection attack.

Thanks again to Damian Poddebniak and Fabian Ising from the Mnster
University of Applied Sciences for reporting this issue.  Their
summary in ticket 248 states the issue clearly:

  We found another STARTTLS-related issue in Mutt. Unfortunately, it
  affects SMTP, POP3 and IMAP.

  When the server responds with its ""let's do TLS now message"", e.g. A
  OK begin TLS\r\n in IMAP or +OK begin TLS\r\n in POP3, Mutt will
  also read any data after the \r\n and save it into some internal
  buffer for later processing. This is problematic, because a MITM
  attacker can inject arbitrary responses.

  There is a nice blogpost by Wietse Venema about a ""command
  injection"" in postfix (http://www.postfix.org/CVE-2011-0411.html).
  What we have here is the problem in reverse, i.e. not a command
  injection, but a ""response injection.""

This commit fixes the issue by clearing the CONNECTION input buffer in
mutt_ssl_starttls().

To make backporting this fix easier, the new functions only clear the
top-level CONNECTION buffer; they don't handle nested buffering in
mutt_zstrm.c or mutt_sasl.c.  However both of those wrap the
connection *after* STARTTLS, so this is currently okay.  mutt_tunnel.c
occurs before connecting, but it does not perform any nesting.
",c547433cdf2e79191b15c6932c57f1472bfb5ff4,https://gitlab.com/muttmua/mutt/-/commit/c547433cdf2e79191b15c6932c57f1472bfb5ff4,mutt_ssl_gnutls.c,mutt_ssl_starttls,"int mutt_ssl_starttls (CONNECTION* conn)
{
if (tls_init() < 0)
return -1;
if (tls_negotiate (conn) < 0)
return -1;
conn->conn_read= tls_socket_read;
conn->conn_write= tls_socket_write;
conn->conn_close= tls_starttls_close;
conn->conn_poll       = tls_socket_poll;
return 0;
}","int mutt_ssl_starttls (CONNECTION* VAR_0)
{
if (tls_init() < 0)
return -1;
if (tls_negotiate (VAR_0) < 0)
return -1;
VAR_0->conn_read= VAR_1;
VAR_0->conn_write= VAR_2;
VAR_0->conn_close= VAR_3;
VAR_0->conn_poll       = VAR_4;
return 0;
}",muttmua/mutt/c547433cdf2e79191b15c6932c57f1472bfb5ff4/mutt_ssl_gnutls.c/vul/before/0.json,"int mutt_ssl_starttls (CONNECTION* conn)
{
  if (mutt_socket_has_buffered_input (conn))
  {
    /* L10N:
       The server is not supposed to send data immediately after
       confirming STARTTLS.  This warns the user that something
       weird is going on.
    */
    mutt_error _(""Warning: clearing unexpected buffered data before STARTTLS"");
    mutt_sleep (0);
    mutt_socket_clear_buffered_input (conn);
  }

  if (tls_init() < 0)
    return -1;

  if (tls_negotiate (conn) < 0)
    return -1;

  conn->conn_read	= tls_socket_read;
  conn->conn_write	= tls_socket_write;
  conn->conn_close	= tls_starttls_close;
  conn->conn_poll       = tls_socket_poll;

  return 0;
}","int mutt_ssl_starttls (CONNECTION* VAR_0)
{
  if (mutt_socket_has_buffered_input (VAR_0))
  {
    /* COMMENT_0 */
                                                                
                                                               
                         
      
    mutt_error VAR_1(""Warning: clearing unexpected buffered data before STARTTLS"");
    mutt_sleep (0);
    mutt_socket_clear_buffered_input (VAR_0);
  }

  if (tls_init() < 0)
    return -1;

  if (tls_negotiate (VAR_0) < 0)
    return -1;

  VAR_0->conn_read	= VAR_2;
  VAR_0->conn_write	= VAR_3;
  VAR_0->conn_close	= VAR_4;
  VAR_0->conn_poll       = VAR_5;

  return 0;
}",muttmua/mutt/c547433cdf2e79191b15c6932c57f1472bfb5ff4/mutt_ssl_gnutls.c/vul/after/0.json,"--- func_before
+++ func_after
@@ -1,5 +1,17 @@
 int mutt_ssl_starttls (CONNECTION* conn)
 {
+  if (mutt_socket_has_buffered_input (conn))
+  {
+    /* L10N:
+       The server is not supposed to send data immediately after
+       confirming STARTTLS.  This warns the user that something
+       weird is going on.
+    */
+    mutt_error _(""Warning: clearing unexpected buffered data before STARTTLS"");
+    mutt_sleep (0);
+    mutt_socket_clear_buffered_input (conn);
+  }
+
   if (tls_init() < 0)
     return -1;
 ","{'deleted_lines': [], 'added_lines': ['  if (mutt_socket_has_buffered_input (conn))', '  {', '    /* L10N:', '       The server is not supposed to send data immediately after', '       confirming STARTTLS.  This warns the user that something', '       weird is going on.', '    */', '    mutt_error _(""Warning: clearing unexpected buffered data before STARTTLS"");', '    mutt_sleep (0);', '    mutt_socket_clear_buffered_input (conn);', '  }', '']}",True,"Mutt before 1.14.4 and NeoMutt before 2020-06-19 have a STARTTLS buffering issue that affects IMAP, SMTP, and POP3. When a server sends a ""begin TLS"" response, the client reads additional data (e.g., from a man-in-the-middle attacker) and evaluates it in a TLS context, aka ""response injection.""",5.9,MEDIUM,1,test,,5
